// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Randomize ;
  11: CALL_OW 10
// InitVariables ;
  15: CALL 94 0 0
// InitMacro ;
  19: CALL 17382 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// ChangeSideFog ( 8 , 1 ) ;
  36: LD_INT 8
  38: PPUSH
  39: LD_INT 1
  41: PPUSH
  42: CALL_OW 343
// PrepareNature ( 4 , 3 , 6 , 3 , 2 , 0 , 7 , natureArea , waterArea ) ;
  46: LD_INT 4
  48: PPUSH
  49: LD_INT 3
  51: PPUSH
  52: LD_INT 6
  54: PPUSH
  55: LD_INT 3
  57: PPUSH
  58: LD_INT 2
  60: PPUSH
  61: LD_INT 0
  63: PPUSH
  64: LD_INT 7
  66: PPUSH
  67: LD_INT 18
  69: PPUSH
  70: LD_INT 19
  72: PPUSH
  73: CALL 80020 0 9
// PrepareAmerican ;
  77: CALL 562 0 0
// PrepareArabian ;
  81: CALL 2234 0 0
// MC_Start ( ) ;
  85: CALL 19494 0 0
// Action ;
  89: CALL 8072 0 0
// end ;
  93: END
// export debug , game ; export mission_prefix , mission_prefix_prev ; export ar_run , base_captured , ar_patrol , us_scout , seen , can_kamikazed , kamikazed , artifact_stolen , artifact_get , artifact_oncargo , game_time , powell_warn , loses_counter , gensher_active , selected , am_veh_consturcted ; function InitVariables ; begin
  94: LD_INT 0
  96: PPUSH
// debug := false ;
  97: LD_ADDR_EXP 1
 101: PUSH
 102: LD_INT 0
 104: ST_TO_ADDR
// game := true ;
 105: LD_ADDR_EXP 2
 109: PUSH
 110: LD_INT 1
 112: ST_TO_ADDR
// mission_prefix := 11_ ;
 113: LD_ADDR_EXP 3
 117: PUSH
 118: LD_STRING 11_
 120: ST_TO_ADDR
// mission_prefix_prev := 10c_ ;
 121: LD_ADDR_EXP 4
 125: PUSH
 126: LD_STRING 10c_
 128: ST_TO_ADDR
// ar_run := false ;
 129: LD_ADDR_EXP 5
 133: PUSH
 134: LD_INT 0
 136: ST_TO_ADDR
// ar_patrol := false ;
 137: LD_ADDR_EXP 7
 141: PUSH
 142: LD_INT 0
 144: ST_TO_ADDR
// base_captured := false ;
 145: LD_ADDR_EXP 6
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// us_scout := 0 ;
 153: LD_ADDR_EXP 8
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// seen := [ 0 , 0 , 0 , 0 , 0 ] ;
 161: LD_ADDR_EXP 9
 165: PUSH
 166: LD_INT 0
 168: PUSH
 169: LD_INT 0
 171: PUSH
 172: LD_INT 0
 174: PUSH
 175: LD_INT 0
 177: PUSH
 178: LD_INT 0
 180: PUSH
 181: EMPTY
 182: LIST
 183: LIST
 184: LIST
 185: LIST
 186: LIST
 187: ST_TO_ADDR
// kamikazed := false ;
 188: LD_ADDR_EXP 11
 192: PUSH
 193: LD_INT 0
 195: ST_TO_ADDR
// artifact_stolen := false ;
 196: LD_ADDR_EXP 12
 200: PUSH
 201: LD_INT 0
 203: ST_TO_ADDR
// artifact_get := false ;
 204: LD_ADDR_EXP 13
 208: PUSH
 209: LD_INT 0
 211: ST_TO_ADDR
// game_time := [ 130 130$00 , 120 120$00 , 115 115$00 ] [ Difficulty ] ;
 212: LD_ADDR_EXP 15
 216: PUSH
 217: LD_INT 273000
 219: PUSH
 220: LD_INT 252000
 222: PUSH
 223: LD_INT 241500
 225: PUSH
 226: EMPTY
 227: LIST
 228: LIST
 229: LIST
 230: PUSH
 231: LD_OWVAR 67
 235: ARRAY
 236: ST_TO_ADDR
// powell_warn := false ;
 237: LD_ADDR_EXP 16
 241: PUSH
 242: LD_INT 0
 244: ST_TO_ADDR
// loses_counter := 0 ;
 245: LD_ADDR_EXP 17
 249: PUSH
 250: LD_INT 0
 252: ST_TO_ADDR
// artifact_oncargo := false ;
 253: LD_ADDR_EXP 14
 257: PUSH
 258: LD_INT 0
 260: ST_TO_ADDR
// gensher_active := LoadVariable ( 10_GensherEscape_1 , debug ) ;
 261: LD_ADDR_EXP 18
 265: PUSH
 266: LD_STRING 10_GensherEscape_1
 268: PPUSH
 269: LD_EXP 1
 273: PPUSH
 274: CALL_OW 30
 278: ST_TO_ADDR
// can_kamikazed := false ;
 279: LD_ADDR_EXP 10
 283: PUSH
 284: LD_INT 0
 286: ST_TO_ADDR
// am_veh_consturcted := false ;
 287: LD_ADDR_EXP 20
 291: PUSH
 292: LD_INT 0
 294: ST_TO_ADDR
// end ;
 295: LD_VAR 0 1
 299: RET
// export function CustomInitMacro ; var i ; begin
 300: LD_INT 0
 302: PPUSH
 303: PPUSH
// mc_parking := [ parking_north , parking_west , parking_east ] ;
 304: LD_ADDR_EXP 74
 308: PUSH
 309: LD_INT 20
 311: PUSH
 312: LD_INT 21
 314: PUSH
 315: LD_INT 22
 317: PUSH
 318: EMPTY
 319: LIST
 320: LIST
 321: LIST
 322: ST_TO_ADDR
// mc_scan_area := [ base_north , base_west , base_east ] ;
 323: LD_ADDR_EXP 75
 327: PUSH
 328: LD_INT 28
 330: PUSH
 331: LD_INT 24
 333: PUSH
 334: LD_INT 26
 336: PUSH
 337: EMPTY
 338: LIST
 339: LIST
 340: LIST
 341: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 4 , 6 , 9 ] [ Difficulty ] , minefield1_left ) ;
 342: LD_INT 1
 344: PPUSH
 345: LD_INT 4
 347: PUSH
 348: LD_INT 6
 350: PUSH
 351: LD_INT 9
 353: PUSH
 354: EMPTY
 355: LIST
 356: LIST
 357: LIST
 358: PUSH
 359: LD_OWVAR 67
 363: ARRAY
 364: PPUSH
 365: LD_INT 3
 367: PPUSH
 368: CALL 40695 0 3
// MC_SetMinesField ( 2 , [ 4 , 6 , 9 ] [ Difficulty ] , minefield2_left ) ;
 372: LD_INT 2
 374: PPUSH
 375: LD_INT 4
 377: PUSH
 378: LD_INT 6
 380: PUSH
 381: LD_INT 9
 383: PUSH
 384: EMPTY
 385: LIST
 386: LIST
 387: LIST
 388: PUSH
 389: LD_OWVAR 67
 393: ARRAY
 394: PPUSH
 395: LD_INT 2
 397: PPUSH
 398: CALL 40695 0 3
// MC_SetMinesField ( 3 , [ 4 , 6 , 9 ] [ Difficulty ] , minefield3_left ) ;
 402: LD_INT 3
 404: PPUSH
 405: LD_INT 4
 407: PUSH
 408: LD_INT 6
 410: PUSH
 411: LD_INT 9
 413: PUSH
 414: EMPTY
 415: LIST
 416: LIST
 417: LIST
 418: PUSH
 419: LD_OWVAR 67
 423: ARRAY
 424: PPUSH
 425: LD_INT 1
 427: PPUSH
 428: CALL 40695 0 3
// for i = 1 to mc_bases do
 432: LD_ADDR_VAR 0 2
 436: PUSH
 437: DOUBLE
 438: LD_INT 1
 440: DEC
 441: ST_TO_ADDR
 442: LD_EXP 50
 446: PUSH
 447: FOR_TO
 448: IFFALSE 472
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 450: LD_VAR 0 2
 454: PPUSH
 455: LD_EXP 43
 459: PUSH
 460: LD_VAR 0 2
 464: ARRAY
 465: PPUSH
 466: CALL 41121 0 2
 470: GO 447
 472: POP
 473: POP
// end ;
 474: LD_VAR 0 1
 478: RET
// function Debuger ; var i ; begin
 479: LD_INT 0
 481: PPUSH
 482: PPUSH
// if not debug then
 483: LD_EXP 1
 487: NOT
 488: IFFALSE 492
// exit ;
 490: GO 528
// game_speed := 5 ;
 492: LD_ADDR_OWVAR 65
 496: PUSH
 497: LD_INT 5
 499: ST_TO_ADDR
// uc_side := 1 ;
 500: LD_ADDR_OWVAR 20
 504: PUSH
 505: LD_INT 1
 507: ST_TO_ADDR
// uc_nation := 1 ;
 508: LD_ADDR_OWVAR 21
 512: PUSH
 513: LD_INT 1
 515: ST_TO_ADDR
// SetSide ( ar_force_south , 1 ) ;
 516: LD_EXP 36
 520: PPUSH
 521: LD_INT 1
 523: PPUSH
 524: CALL_OW 235
// end ;
 528: LD_VAR 0 1
 532: RET
// every 0 0$1 trigger IsDead ( ar_dep_n ) and IsOk ( ar_dep_w ) do
 533: LD_INT 94
 535: PPUSH
 536: CALL_OW 301
 540: PUSH
 541: LD_INT 45
 543: PPUSH
 544: CALL_OW 302
 548: AND
 549: IFFALSE 561
 551: GO 553
 553: DISABLE
// SetAchievement ( ACH_EAST ) ; end_of_file
 554: LD_STRING ACH_EAST
 556: PPUSH
 557: CALL_OW 543
 561: END
// export JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Frank , Kikuchi ; export function PrepareAmerican ; var i , k , un , tmp , vehs , veh , others ; begin
 562: LD_INT 0
 564: PPUSH
 565: PPUSH
 566: PPUSH
 567: PPUSH
 568: PPUSH
 569: PPUSH
 570: PPUSH
 571: PPUSH
// uc_side := 4 ;
 572: LD_ADDR_OWVAR 20
 576: PUSH
 577: LD_INT 4
 579: ST_TO_ADDR
// uc_nation := 1 ;
 580: LD_ADDR_OWVAR 21
 584: PUSH
 585: LD_INT 1
 587: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
 588: LD_ADDR_EXP 30
 592: PUSH
 593: LD_STRING Powell
 595: PPUSH
 596: LD_INT 0
 598: PPUSH
 599: LD_STRING 
 601: PPUSH
 602: CALL 47405 0 3
 606: ST_TO_ADDR
// uc_side := 1 ;
 607: LD_ADDR_OWVAR 20
 611: PUSH
 612: LD_INT 1
 614: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , mission_prefix_prev ) ;
 615: LD_ADDR_EXP 21
 619: PUSH
 620: LD_STRING JMM
 622: PPUSH
 623: LD_EXP 1
 627: NOT
 628: PPUSH
 629: LD_EXP 4
 633: PPUSH
 634: CALL 47405 0 3
 638: ST_TO_ADDR
// if GetClass ( JMM ) > 4 then
 639: LD_EXP 21
 643: PPUSH
 644: CALL_OW 257
 648: PUSH
 649: LD_INT 4
 651: GREATER
 652: IFFALSE 666
// SetClass ( JMM , 1 ) ;
 654: LD_EXP 21
 658: PPUSH
 659: LD_INT 1
 661: PPUSH
 662: CALL_OW 336
// Lisa := PrepareUnit ( Lisa , ( not debug ) , mission_prefix_prev ) ;
 666: LD_ADDR_EXP 22
 670: PUSH
 671: LD_STRING Lisa
 673: PPUSH
 674: LD_EXP 1
 678: NOT
 679: PPUSH
 680: LD_EXP 4
 684: PPUSH
 685: CALL 47405 0 3
 689: ST_TO_ADDR
// if not Lisa then
 690: LD_EXP 22
 694: NOT
 695: IFFALSE 710
// Lisa := CreateCharacter ( 10_Lisa ) ;
 697: LD_ADDR_EXP 22
 701: PUSH
 702: LD_STRING 10_Lisa
 704: PPUSH
 705: CALL_OW 34
 709: ST_TO_ADDR
// if not Lisa then
 710: LD_EXP 22
 714: NOT
 715: IFFALSE 730
// Lisa := CreateCharacter ( 09_Lisa ) ;
 717: LD_ADDR_EXP 22
 721: PUSH
 722: LD_STRING 09_Lisa
 724: PPUSH
 725: CALL_OW 34
 729: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , mission_prefix_prev ) ;
 730: LD_ADDR_EXP 31
 734: PUSH
 735: LD_STRING Cornel
 737: PPUSH
 738: LD_EXP 1
 742: NOT
 743: PPUSH
 744: LD_EXP 4
 748: PPUSH
 749: CALL 47405 0 3
 753: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , mission_prefix_prev ) ;
 754: LD_ADDR_EXP 23
 758: PUSH
 759: LD_STRING Donaldson
 761: PPUSH
 762: LD_EXP 1
 766: NOT
 767: PPUSH
 768: LD_EXP 4
 772: PPUSH
 773: CALL 47405 0 3
 777: ST_TO_ADDR
// if not Donaldson then
 778: LD_EXP 23
 782: NOT
 783: IFFALSE 798
// Donaldson := CreateCharacter ( 10_Donaldson ) ;
 785: LD_ADDR_EXP 23
 789: PUSH
 790: LD_STRING 10_Donaldson
 792: PPUSH
 793: CALL_OW 34
 797: ST_TO_ADDR
// if not Donaldson then
 798: LD_EXP 23
 802: NOT
 803: IFFALSE 818
// Donaldson := CreateCharacter ( 09_Donaldson ) ;
 805: LD_ADDR_EXP 23
 809: PUSH
 810: LD_STRING 09_Donaldson
 812: PPUSH
 813: CALL_OW 34
 817: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , mission_prefix_prev ) ;
 818: LD_ADDR_EXP 24
 822: PUSH
 823: LD_STRING Bobby
 825: PPUSH
 826: LD_EXP 1
 830: NOT
 831: PPUSH
 832: LD_EXP 4
 836: PPUSH
 837: CALL 47405 0 3
 841: ST_TO_ADDR
// if not Bobby then
 842: LD_EXP 24
 846: NOT
 847: IFFALSE 862
// Bobby := CreateCharacter ( 10_Bobby ) ;
 849: LD_ADDR_EXP 24
 853: PUSH
 854: LD_STRING 10_Bobby
 856: PPUSH
 857: CALL_OW 34
 861: ST_TO_ADDR
// if not Bobby then
 862: LD_EXP 24
 866: NOT
 867: IFFALSE 882
// Bobby := CreateCharacter ( 09_Bobby ) ;
 869: LD_ADDR_EXP 24
 873: PUSH
 874: LD_STRING 09_Bobby
 876: PPUSH
 877: CALL_OW 34
 881: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , mission_prefix_prev ) ;
 882: LD_ADDR_EXP 25
 886: PUSH
 887: LD_STRING Cyrus
 889: PPUSH
 890: LD_EXP 1
 894: NOT
 895: PPUSH
 896: LD_EXP 4
 900: PPUSH
 901: CALL 47405 0 3
 905: ST_TO_ADDR
// if not Cyrus then
 906: LD_EXP 25
 910: NOT
 911: IFFALSE 926
// Cyrus := CreateCharacter ( 10_Cyrus ) ;
 913: LD_ADDR_EXP 25
 917: PUSH
 918: LD_STRING 10_Cyrus
 920: PPUSH
 921: CALL_OW 34
 925: ST_TO_ADDR
// if not Cyrus then
 926: LD_EXP 25
 930: NOT
 931: IFFALSE 946
// Cyrus := CreateCharacter ( 09_Cyrus ) ;
 933: LD_ADDR_EXP 25
 937: PUSH
 938: LD_STRING 09_Cyrus
 940: PPUSH
 941: CALL_OW 34
 945: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , mission_prefix_prev ) ;
 946: LD_ADDR_EXP 26
 950: PUSH
 951: LD_STRING Denis
 953: PPUSH
 954: LD_EXP 1
 958: NOT
 959: PPUSH
 960: LD_EXP 4
 964: PPUSH
 965: CALL 47405 0 3
 969: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , mission_prefix_prev ) ;
 970: LD_ADDR_EXP 27
 974: PUSH
 975: LD_STRING Brown
 977: PPUSH
 978: LD_EXP 1
 982: NOT
 983: PPUSH
 984: LD_EXP 4
 988: PPUSH
 989: CALL 47405 0 3
 993: ST_TO_ADDR
// if not Brown then
 994: LD_EXP 27
 998: NOT
 999: IFFALSE 1014
// Brown := CreateCharacter ( 10_Brown ) ;
1001: LD_ADDR_EXP 27
1005: PUSH
1006: LD_STRING 10_Brown
1008: PPUSH
1009: CALL_OW 34
1013: ST_TO_ADDR
// if not Brown then
1014: LD_EXP 27
1018: NOT
1019: IFFALSE 1034
// Brown := CreateCharacter ( 08_Brown ) ;
1021: LD_ADDR_EXP 27
1025: PUSH
1026: LD_STRING 08_Brown
1028: PPUSH
1029: CALL_OW 34
1033: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , mission_prefix_prev ) ;
1034: LD_ADDR_EXP 28
1038: PUSH
1039: LD_STRING Gladstone
1041: PPUSH
1042: LD_EXP 1
1046: NOT
1047: PPUSH
1048: LD_EXP 4
1052: PPUSH
1053: CALL 47405 0 3
1057: ST_TO_ADDR
// if not Gladstone then
1058: LD_EXP 28
1062: NOT
1063: IFFALSE 1078
// Gladstone := CreateCharacter ( 10_Gladstone ) ;
1065: LD_ADDR_EXP 28
1069: PUSH
1070: LD_STRING 10_Gladstone
1072: PPUSH
1073: CALL_OW 34
1077: ST_TO_ADDR
// if not Gladstone then
1078: LD_EXP 28
1082: NOT
1083: IFFALSE 1098
// Gladstone := CreateCharacter ( 08_Gladstone ) ;
1085: LD_ADDR_EXP 28
1089: PUSH
1090: LD_STRING 08_Gladstone
1092: PPUSH
1093: CALL_OW 34
1097: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , mission_prefix_prev ) ;
1098: LD_ADDR_EXP 29
1102: PUSH
1103: LD_STRING Houten
1105: PPUSH
1106: LD_EXP 1
1110: NOT
1111: PPUSH
1112: LD_EXP 4
1116: PPUSH
1117: CALL 47405 0 3
1121: ST_TO_ADDR
// if not Houten then
1122: LD_EXP 29
1126: NOT
1127: IFFALSE 1142
// Houten := CreateCharacter ( 10_Houten ) ;
1129: LD_ADDR_EXP 29
1133: PUSH
1134: LD_STRING 10_Houten
1136: PPUSH
1137: CALL_OW 34
1141: ST_TO_ADDR
// if not Houten then
1142: LD_EXP 29
1146: NOT
1147: IFFALSE 1162
// Houten := CreateCharacter ( 09_Houten ) ;
1149: LD_ADDR_EXP 29
1153: PUSH
1154: LD_STRING 09_Houten
1156: PPUSH
1157: CALL_OW 34
1161: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , ( not debug ) , mission_prefix_prev ) ;
1162: LD_ADDR_EXP 31
1166: PUSH
1167: LD_STRING Cornell
1169: PPUSH
1170: LD_EXP 1
1174: NOT
1175: PPUSH
1176: LD_EXP 4
1180: PPUSH
1181: CALL 47405 0 3
1185: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , mission_prefix_prev ) ;
1186: LD_ADDR_EXP 32
1190: PUSH
1191: LD_STRING Gary
1193: PPUSH
1194: LD_EXP 1
1198: NOT
1199: PPUSH
1200: LD_EXP 4
1204: PPUSH
1205: CALL 47405 0 3
1209: ST_TO_ADDR
// if not Gary then
1210: LD_EXP 32
1214: NOT
1215: IFFALSE 1230
// Gary := CreateCharacter ( 10_Gary ) ;
1217: LD_ADDR_EXP 32
1221: PUSH
1222: LD_STRING 10_Gary
1224: PPUSH
1225: CALL_OW 34
1229: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , mission_prefix_prev ) ;
1230: LD_ADDR_EXP 33
1234: PUSH
1235: LD_STRING Frank
1237: PPUSH
1238: LD_EXP 1
1242: NOT
1243: PPUSH
1244: LD_EXP 4
1248: PPUSH
1249: CALL 47405 0 3
1253: ST_TO_ADDR
// if not Frank then
1254: LD_EXP 33
1258: NOT
1259: IFFALSE 1274
// Frank := CreateCharacter ( 08_Frank ) ;
1261: LD_ADDR_EXP 33
1265: PUSH
1266: LD_STRING 08_Frank
1268: PPUSH
1269: CALL_OW 34
1273: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , mission_prefix_prev ) ;
1274: LD_ADDR_EXP 34
1278: PUSH
1279: LD_STRING Kikuchi
1281: PPUSH
1282: LD_EXP 1
1286: NOT
1287: PPUSH
1288: LD_EXP 4
1292: PPUSH
1293: CALL 47405 0 3
1297: ST_TO_ADDR
// if not Kikuchi then
1298: LD_EXP 34
1302: NOT
1303: IFFALSE 1318
// Kikuchi := CreateCharacter ( 08_Kikuchi ) ;
1305: LD_ADDR_EXP 34
1309: PUSH
1310: LD_STRING 08_Kikuchi
1312: PPUSH
1313: CALL_OW 34
1317: ST_TO_ADDR
// tmp := [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1318: LD_ADDR_VAR 0 5
1322: PUSH
1323: LD_EXP 22
1327: PUSH
1328: LD_EXP 23
1332: PUSH
1333: LD_EXP 24
1337: PUSH
1338: LD_EXP 25
1342: PUSH
1343: LD_EXP 26
1347: PUSH
1348: LD_EXP 27
1352: PUSH
1353: LD_EXP 28
1357: PUSH
1358: LD_EXP 29
1362: PUSH
1363: LD_EXP 31
1367: PUSH
1368: LD_EXP 32
1372: PUSH
1373: LD_EXP 33
1377: PUSH
1378: LD_EXP 34
1382: PUSH
1383: EMPTY
1384: LIST
1385: LIST
1386: LIST
1387: LIST
1388: LIST
1389: LIST
1390: LIST
1391: LIST
1392: LIST
1393: LIST
1394: LIST
1395: LIST
1396: ST_TO_ADDR
// tmp := tmp diff 0 ;
1397: LD_ADDR_VAR 0 5
1401: PUSH
1402: LD_VAR 0 5
1406: PUSH
1407: LD_INT 0
1409: DIFF
1410: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10_lock ) ;
1411: LD_ADDR_VAR 0 5
1415: PUSH
1416: LD_VAR 0 5
1420: PUSH
1421: LD_STRING 10_lock
1423: PPUSH
1424: CALL_OW 31
1428: UNION
1429: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10c_lock ) ;
1430: LD_ADDR_VAR 0 5
1434: PUSH
1435: LD_VAR 0 5
1439: PUSH
1440: LD_STRING 10c_lock
1442: PPUSH
1443: CALL_OW 31
1447: UNION
1448: ST_TO_ADDR
// DeleteCharacters ( 10_lock ) ;
1449: LD_STRING 10_lock
1451: PPUSH
1452: CALL_OW 40
// DeleteCharacters ( 10c_lock ) ;
1456: LD_STRING 10c_lock
1458: PPUSH
1459: CALL_OW 40
// for i in tmp do
1463: LD_ADDR_VAR 0 2
1467: PUSH
1468: LD_VAR 0 5
1472: PUSH
1473: FOR_IN
1474: IFFALSE 1512
// if GetClass ( i ) in [ class_mortar , class_engineer ] then
1476: LD_VAR 0 2
1480: PPUSH
1481: CALL_OW 257
1485: PUSH
1486: LD_INT 8
1488: PUSH
1489: LD_INT 2
1491: PUSH
1492: EMPTY
1493: LIST
1494: LIST
1495: IN
1496: IFFALSE 1510
// SetClass ( i , class_soldier ) ;
1498: LD_VAR 0 2
1502: PPUSH
1503: LD_INT 1
1505: PPUSH
1506: CALL_OW 336
1510: GO 1473
1512: POP
1513: POP
// if tmp < 12 then
1514: LD_VAR 0 5
1518: PUSH
1519: LD_INT 12
1521: LESS
1522: IFFALSE 1616
// begin k := 16 - tmp ;
1524: LD_ADDR_VAR 0 3
1528: PUSH
1529: LD_INT 16
1531: PUSH
1532: LD_VAR 0 5
1536: MINUS
1537: ST_TO_ADDR
// for i = 1 to k do
1538: LD_ADDR_VAR 0 2
1542: PUSH
1543: DOUBLE
1544: LD_INT 1
1546: DEC
1547: ST_TO_ADDR
1548: LD_VAR 0 3
1552: PUSH
1553: FOR_TO
1554: IFFALSE 1614
// begin PrepareHuman ( false , [ 1 , 1 , 3 , 4 ] [ rand ( 1 , 4 ) ] , 6 ) ;
1556: LD_INT 0
1558: PPUSH
1559: LD_INT 1
1561: PUSH
1562: LD_INT 1
1564: PUSH
1565: LD_INT 3
1567: PUSH
1568: LD_INT 4
1570: PUSH
1571: EMPTY
1572: LIST
1573: LIST
1574: LIST
1575: LIST
1576: PUSH
1577: LD_INT 1
1579: PPUSH
1580: LD_INT 4
1582: PPUSH
1583: CALL_OW 12
1587: ARRAY
1588: PPUSH
1589: LD_INT 6
1591: PPUSH
1592: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
1596: LD_ADDR_VAR 0 5
1600: PUSH
1601: LD_VAR 0 5
1605: PUSH
1606: CALL_OW 44
1610: ADD
1611: ST_TO_ADDR
// end ;
1612: GO 1553
1614: POP
1615: POP
// end ; selected := CharacterSelection ( 1 , 12 , 12 , [ sel_change_class , JMM , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp ^ [ sel_dont_change_class , sel_not_changeable , Powell ] , [ [ class_soldier , 4 ] , [ class_mechanic , 0 , 5 ] , [ class_scientistic , 0 , 3 ] , [ class_sniper , 0 , 2 ] ] ) ;
1616: LD_ADDR_EXP 19
1620: PUSH
1621: LD_STRING 1
1623: PPUSH
1624: LD_INT 12
1626: PPUSH
1627: LD_INT 12
1629: PPUSH
1630: LD_INT -5
1632: PUSH
1633: LD_EXP 21
1637: PUSH
1638: LD_INT -2
1640: PUSH
1641: LD_INT -3
1643: PUSH
1644: LD_INT -5
1646: PUSH
1647: EMPTY
1648: LIST
1649: LIST
1650: LIST
1651: LIST
1652: LIST
1653: PUSH
1654: LD_VAR 0 5
1658: ADD
1659: PUSH
1660: LD_INT -6
1662: PUSH
1663: LD_INT -4
1665: PUSH
1666: LD_EXP 30
1670: PUSH
1671: EMPTY
1672: LIST
1673: LIST
1674: LIST
1675: ADD
1676: PPUSH
1677: LD_INT 1
1679: PUSH
1680: LD_INT 4
1682: PUSH
1683: EMPTY
1684: LIST
1685: LIST
1686: PUSH
1687: LD_INT 3
1689: PUSH
1690: LD_INT 0
1692: PUSH
1693: LD_INT 5
1695: PUSH
1696: EMPTY
1697: LIST
1698: LIST
1699: LIST
1700: PUSH
1701: LD_INT 4
1703: PUSH
1704: LD_INT 0
1706: PUSH
1707: LD_INT 3
1709: PUSH
1710: EMPTY
1711: LIST
1712: LIST
1713: LIST
1714: PUSH
1715: LD_INT 5
1717: PUSH
1718: LD_INT 0
1720: PUSH
1721: LD_INT 2
1723: PUSH
1724: EMPTY
1725: LIST
1726: LIST
1727: LIST
1728: PUSH
1729: EMPTY
1730: LIST
1731: LIST
1732: LIST
1733: LIST
1734: PPUSH
1735: CALL_OW 42
1739: ST_TO_ADDR
// others := tmp diff selected ;
1740: LD_ADDR_VAR 0 8
1744: PUSH
1745: LD_VAR 0 5
1749: PUSH
1750: LD_EXP 19
1754: DIFF
1755: ST_TO_ADDR
// others := others diff [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1756: LD_ADDR_VAR 0 8
1760: PUSH
1761: LD_VAR 0 8
1765: PUSH
1766: LD_EXP 22
1770: PUSH
1771: LD_EXP 23
1775: PUSH
1776: LD_EXP 24
1780: PUSH
1781: LD_EXP 25
1785: PUSH
1786: LD_EXP 26
1790: PUSH
1791: LD_EXP 27
1795: PUSH
1796: LD_EXP 28
1800: PUSH
1801: LD_EXP 29
1805: PUSH
1806: LD_EXP 31
1810: PUSH
1811: LD_EXP 32
1815: PUSH
1816: LD_EXP 33
1820: PUSH
1821: LD_EXP 34
1825: PUSH
1826: EMPTY
1827: LIST
1828: LIST
1829: LIST
1830: LIST
1831: LIST
1832: LIST
1833: LIST
1834: LIST
1835: LIST
1836: LIST
1837: LIST
1838: LIST
1839: DIFF
1840: ST_TO_ADDR
// if others then
1841: LD_VAR 0 8
1845: IFFALSE 1859
// SaveCharacters ( others , 11_others ) ;
1847: LD_VAR 0 8
1851: PPUSH
1852: LD_STRING 11_others
1854: PPUSH
1855: CALL_OW 38
// vehs := [ [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun ] , [ us_medium_wheeled , engine_solar , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_medium_wheeled , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_solar , control_manual , us_rocket_launcher ] ] ;
1859: LD_ADDR_VAR 0 6
1863: PUSH
1864: LD_INT 3
1866: PUSH
1867: LD_INT 1
1869: PUSH
1870: LD_INT 1
1872: PUSH
1873: LD_INT 4
1875: PUSH
1876: EMPTY
1877: LIST
1878: LIST
1879: LIST
1880: LIST
1881: PUSH
1882: LD_INT 2
1884: PUSH
1885: LD_INT 2
1887: PUSH
1888: LD_INT 1
1890: PUSH
1891: LD_INT 5
1893: PUSH
1894: EMPTY
1895: LIST
1896: LIST
1897: LIST
1898: LIST
1899: PUSH
1900: LD_INT 4
1902: PUSH
1903: LD_INT 1
1905: PUSH
1906: LD_INT 1
1908: PUSH
1909: LD_INT 5
1911: PUSH
1912: EMPTY
1913: LIST
1914: LIST
1915: LIST
1916: LIST
1917: PUSH
1918: LD_INT 2
1920: PUSH
1921: LD_INT 1
1923: PUSH
1924: LD_INT 1
1926: PUSH
1927: LD_INT 7
1929: PUSH
1930: EMPTY
1931: LIST
1932: LIST
1933: LIST
1934: LIST
1935: PUSH
1936: LD_INT 3
1938: PUSH
1939: LD_INT 2
1941: PUSH
1942: LD_INT 1
1944: PUSH
1945: LD_INT 7
1947: PUSH
1948: EMPTY
1949: LIST
1950: LIST
1951: LIST
1952: LIST
1953: PUSH
1954: EMPTY
1955: LIST
1956: LIST
1957: LIST
1958: LIST
1959: LIST
1960: ST_TO_ADDR
// for i in JMM ^ selected do
1961: LD_ADDR_VAR 0 2
1965: PUSH
1966: LD_EXP 21
1970: PUSH
1971: LD_EXP 19
1975: ADD
1976: PUSH
1977: FOR_IN
1978: IFFALSE 2167
// begin if GetClass ( i ) = 3 then
1980: LD_VAR 0 2
1984: PPUSH
1985: CALL_OW 257
1989: PUSH
1990: LD_INT 3
1992: EQUAL
1993: IFFALSE 2150
// begin vc_chassis := vehs [ 1 ] [ 1 ] ;
1995: LD_ADDR_OWVAR 37
1999: PUSH
2000: LD_VAR 0 6
2004: PUSH
2005: LD_INT 1
2007: ARRAY
2008: PUSH
2009: LD_INT 1
2011: ARRAY
2012: ST_TO_ADDR
// vc_engine := vehs [ 1 ] [ 2 ] ;
2013: LD_ADDR_OWVAR 39
2017: PUSH
2018: LD_VAR 0 6
2022: PUSH
2023: LD_INT 1
2025: ARRAY
2026: PUSH
2027: LD_INT 2
2029: ARRAY
2030: ST_TO_ADDR
// vc_control := vehs [ 1 ] [ 3 ] ;
2031: LD_ADDR_OWVAR 38
2035: PUSH
2036: LD_VAR 0 6
2040: PUSH
2041: LD_INT 1
2043: ARRAY
2044: PUSH
2045: LD_INT 3
2047: ARRAY
2048: ST_TO_ADDR
// vc_weapon := vehs [ 1 ] [ 4 ] ;
2049: LD_ADDR_OWVAR 40
2053: PUSH
2054: LD_VAR 0 6
2058: PUSH
2059: LD_INT 1
2061: ARRAY
2062: PUSH
2063: LD_INT 4
2065: ARRAY
2066: ST_TO_ADDR
// vehs := Delete ( vehs , 1 ) ;
2067: LD_ADDR_VAR 0 6
2071: PUSH
2072: LD_VAR 0 6
2076: PPUSH
2077: LD_INT 1
2079: PPUSH
2080: CALL_OW 3
2084: ST_TO_ADDR
// veh := CreateVehicle ;
2085: LD_ADDR_VAR 0 7
2089: PUSH
2090: CALL_OW 45
2094: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2095: LD_VAR 0 7
2099: PPUSH
2100: LD_INT 8
2102: PPUSH
2103: LD_INT 0
2105: PPUSH
2106: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
2110: LD_VAR 0 2
2114: PPUSH
2115: LD_VAR 0 7
2119: PPUSH
2120: CALL_OW 52
// if i = JMM then
2124: LD_VAR 0 2
2128: PUSH
2129: LD_EXP 21
2133: EQUAL
2134: IFFALSE 2148
// SetMark ( veh , 1 ) ;
2136: LD_VAR 0 7
2140: PPUSH
2141: LD_INT 1
2143: PPUSH
2144: CALL_OW 242
// end else
2148: GO 2165
// PlaceUnitArea ( i , am_hum_start , false ) ;
2150: LD_VAR 0 2
2154: PPUSH
2155: LD_INT 9
2157: PPUSH
2158: LD_INT 0
2160: PPUSH
2161: CALL_OW 49
// end ;
2165: GO 1977
2167: POP
2168: POP
// vc_chassis := us_medium_tracked ;
2169: LD_ADDR_OWVAR 37
2173: PUSH
2174: LD_INT 3
2176: ST_TO_ADDR
// vc_engine := engine_solar ;
2177: LD_ADDR_OWVAR 39
2181: PUSH
2182: LD_INT 2
2184: ST_TO_ADDR
// vc_control := control_computer ;
2185: LD_ADDR_OWVAR 38
2189: PUSH
2190: LD_INT 3
2192: ST_TO_ADDR
// vc_weapon := us_radar ;
2193: LD_ADDR_OWVAR 40
2197: PUSH
2198: LD_INT 11
2200: ST_TO_ADDR
// veh := CreateVehicle ;
2201: LD_ADDR_VAR 0 7
2205: PUSH
2206: CALL_OW 45
2210: ST_TO_ADDR
// PlaceUnitXY ( veh , 87 , 142 , false ) ;
2211: LD_VAR 0 7
2215: PPUSH
2216: LD_INT 87
2218: PPUSH
2219: LD_INT 142
2221: PPUSH
2222: LD_INT 0
2224: PPUSH
2225: CALL_OW 48
// end ; end_of_file
2229: LD_VAR 0 1
2233: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_north_2 , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_kamikadze , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ; var i , d , un , skill , tmp ; begin
2234: LD_INT 0
2236: PPUSH
2237: PPUSH
2238: PPUSH
2239: PPUSH
2240: PPUSH
2241: PPUSH
// if Difficulty = 1 then
2242: LD_OWVAR 67
2246: PUSH
2247: LD_INT 1
2249: EQUAL
2250: IFFALSE 2347
// begin tmp := [ [ 129 , 45 ] , [ 143 , 58 ] , [ 184 , 113 ] , [ 163 , 107 ] ] ;
2252: LD_ADDR_VAR 0 6
2256: PUSH
2257: LD_INT 129
2259: PUSH
2260: LD_INT 45
2262: PUSH
2263: EMPTY
2264: LIST
2265: LIST
2266: PUSH
2267: LD_INT 143
2269: PUSH
2270: LD_INT 58
2272: PUSH
2273: EMPTY
2274: LIST
2275: LIST
2276: PUSH
2277: LD_INT 184
2279: PUSH
2280: LD_INT 113
2282: PUSH
2283: EMPTY
2284: LIST
2285: LIST
2286: PUSH
2287: LD_INT 163
2289: PUSH
2290: LD_INT 107
2292: PUSH
2293: EMPTY
2294: LIST
2295: LIST
2296: PUSH
2297: EMPTY
2298: LIST
2299: LIST
2300: LIST
2301: LIST
2302: ST_TO_ADDR
// for i in tmp do
2303: LD_ADDR_VAR 0 2
2307: PUSH
2308: LD_VAR 0 6
2312: PUSH
2313: FOR_IN
2314: IFFALSE 2345
// RemoveUnit ( HexInfo ( i [ 1 ] , i [ 2 ] ) ) ;
2316: LD_VAR 0 2
2320: PUSH
2321: LD_INT 1
2323: ARRAY
2324: PPUSH
2325: LD_VAR 0 2
2329: PUSH
2330: LD_INT 2
2332: ARRAY
2333: PPUSH
2334: CALL_OW 428
2338: PPUSH
2339: CALL_OW 64
2343: GO 2313
2345: POP
2346: POP
// end ; for i in FilterAllUnits ( [ f_type , unit_building ] ) do
2347: LD_ADDR_VAR 0 2
2351: PUSH
2352: LD_INT 21
2354: PUSH
2355: LD_INT 3
2357: PUSH
2358: EMPTY
2359: LIST
2360: LIST
2361: PPUSH
2362: CALL_OW 69
2366: PUSH
2367: FOR_IN
2368: IFFALSE 2401
// SetBLevel ( i , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
2370: LD_VAR 0 2
2374: PPUSH
2375: LD_INT 5
2377: PUSH
2378: LD_INT 6
2380: PUSH
2381: LD_INT 7
2383: PUSH
2384: EMPTY
2385: LIST
2386: LIST
2387: LIST
2388: PUSH
2389: LD_OWVAR 67
2393: ARRAY
2394: PPUSH
2395: CALL_OW 241
2399: GO 2367
2401: POP
2402: POP
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
2403: LD_ADDR_VAR 0 5
2407: PUSH
2408: LD_INT 5
2410: PUSH
2411: LD_INT 6
2413: PUSH
2414: LD_INT 7
2416: PUSH
2417: EMPTY
2418: LIST
2419: LIST
2420: LIST
2421: PUSH
2422: LD_OWVAR 67
2426: ARRAY
2427: ST_TO_ADDR
// uc_side := 2 ;
2428: LD_ADDR_OWVAR 20
2432: PUSH
2433: LD_INT 2
2435: ST_TO_ADDR
// uc_nation := 2 ;
2436: LD_ADDR_OWVAR 21
2440: PUSH
2441: LD_INT 2
2443: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
2444: LD_ADDR_OWVAR 37
2448: PUSH
2449: LD_INT 14
2451: ST_TO_ADDR
// vc_engine := engine_siberite ;
2452: LD_ADDR_OWVAR 39
2456: PUSH
2457: LD_INT 3
2459: ST_TO_ADDR
// vc_control := control_manual ;
2460: LD_ADDR_OWVAR 38
2464: PUSH
2465: LD_INT 1
2467: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
2468: LD_ADDR_OWVAR 40
2472: PUSH
2473: LD_INT 31
2475: ST_TO_ADDR
// for i = 1 to 3 do
2476: LD_ADDR_VAR 0 2
2480: PUSH
2481: DOUBLE
2482: LD_INT 1
2484: DEC
2485: ST_TO_ADDR
2486: LD_INT 3
2488: PUSH
2489: FOR_TO
2490: IFFALSE 2574
// begin PrepareHuman ( false , class_mechanic , skill ) ;
2492: LD_INT 0
2494: PPUSH
2495: LD_INT 3
2497: PPUSH
2498: LD_VAR 0 5
2502: PPUSH
2503: CALL_OW 380
// un := CreateVehicle ;
2507: LD_ADDR_VAR 0 4
2511: PUSH
2512: CALL_OW 45
2516: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
2517: LD_VAR 0 4
2521: PPUSH
2522: LD_INT 0
2524: PPUSH
2525: LD_INT 5
2527: PPUSH
2528: CALL_OW 12
2532: PPUSH
2533: CALL_OW 233
// PlaceUnitXYR ( un , 156 , 15 , 6 , false ) ;
2537: LD_VAR 0 4
2541: PPUSH
2542: LD_INT 156
2544: PPUSH
2545: LD_INT 15
2547: PPUSH
2548: LD_INT 6
2550: PPUSH
2551: LD_INT 0
2553: PPUSH
2554: CALL_OW 50
// PlaceHumanInUnit ( CreateHuman , un ) ;
2558: CALL_OW 44
2562: PPUSH
2563: LD_VAR 0 4
2567: PPUSH
2568: CALL_OW 52
// end ;
2572: GO 2489
2574: POP
2575: POP
// ar_force_north := PrepareBase ( ar_dep_n , base_north , dammam , skill , [ 10000 , 1000 , 300 ] , [ 16 , [ 2 , 3 , 4 ] [ Difficulty ] , - 1 , 4 ] ) ;
2576: LD_ADDR_EXP 37
2580: PUSH
2581: LD_INT 94
2583: PPUSH
2584: LD_INT 28
2586: PPUSH
2587: LD_STRING dammam
2589: PPUSH
2590: LD_VAR 0 5
2594: PPUSH
2595: LD_INT 10000
2597: PUSH
2598: LD_INT 1000
2600: PUSH
2601: LD_INT 300
2603: PUSH
2604: EMPTY
2605: LIST
2606: LIST
2607: LIST
2608: PPUSH
2609: LD_INT 16
2611: PUSH
2612: LD_INT 2
2614: PUSH
2615: LD_INT 3
2617: PUSH
2618: LD_INT 4
2620: PUSH
2621: EMPTY
2622: LIST
2623: LIST
2624: LIST
2625: PUSH
2626: LD_OWVAR 67
2630: ARRAY
2631: PUSH
2632: LD_INT 1
2634: NEG
2635: PUSH
2636: LD_INT 4
2638: PUSH
2639: EMPTY
2640: LIST
2641: LIST
2642: LIST
2643: LIST
2644: PPUSH
2645: CALL 55638 0 6
2649: ST_TO_ADDR
// ar_force_north := ar_force_north union PrepareBase ( ar_dep_n2 , base_north_2 ,  , skill , [ 500 , 60 , 0 ] , [ - 1 , [ 2 , 3 , 4 ] [ Difficulty ] , 2 , 0 ] ) ;
2650: LD_ADDR_EXP 37
2654: PUSH
2655: LD_EXP 37
2659: PUSH
2660: LD_INT 122
2662: PPUSH
2663: LD_INT 25
2665: PPUSH
2666: LD_STRING 
2668: PPUSH
2669: LD_VAR 0 5
2673: PPUSH
2674: LD_INT 500
2676: PUSH
2677: LD_INT 60
2679: PUSH
2680: LD_INT 0
2682: PUSH
2683: EMPTY
2684: LIST
2685: LIST
2686: LIST
2687: PPUSH
2688: LD_INT 1
2690: NEG
2691: PUSH
2692: LD_INT 2
2694: PUSH
2695: LD_INT 3
2697: PUSH
2698: LD_INT 4
2700: PUSH
2701: EMPTY
2702: LIST
2703: LIST
2704: LIST
2705: PUSH
2706: LD_OWVAR 67
2710: ARRAY
2711: PUSH
2712: LD_INT 2
2714: PUSH
2715: LD_INT 0
2717: PUSH
2718: EMPTY
2719: LIST
2720: LIST
2721: LIST
2722: LIST
2723: PPUSH
2724: CALL 55638 0 6
2728: UNION
2729: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , base_west , jeddah , skill , [ 700 , 300 , 10 ] , [ 10 , 4 , 3 , 2 ] ) ;
2730: LD_ADDR_EXP 35
2734: PUSH
2735: LD_INT 45
2737: PPUSH
2738: LD_INT 24
2740: PPUSH
2741: LD_STRING jeddah
2743: PPUSH
2744: LD_VAR 0 5
2748: PPUSH
2749: LD_INT 700
2751: PUSH
2752: LD_INT 300
2754: PUSH
2755: LD_INT 10
2757: PUSH
2758: EMPTY
2759: LIST
2760: LIST
2761: LIST
2762: PPUSH
2763: LD_INT 10
2765: PUSH
2766: LD_INT 4
2768: PUSH
2769: LD_INT 3
2771: PUSH
2772: LD_INT 2
2774: PUSH
2775: EMPTY
2776: LIST
2777: LIST
2778: LIST
2779: LIST
2780: PPUSH
2781: CALL 55638 0 6
2785: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , base_south , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
2786: LD_ADDR_EXP 36
2790: PUSH
2791: LD_INT 7
2793: PPUSH
2794: LD_INT 27
2796: PPUSH
2797: LD_STRING riyadh
2799: PPUSH
2800: LD_VAR 0 5
2804: PPUSH
2805: LD_INT 500
2807: PUSH
2808: LD_INT 60
2810: PUSH
2811: LD_INT 0
2813: PUSH
2814: EMPTY
2815: LIST
2816: LIST
2817: LIST
2818: PPUSH
2819: LD_INT 4
2821: PUSH
2822: LD_INT 2
2824: PUSH
2825: LD_INT 3
2827: PUSH
2828: LD_INT 1
2830: PUSH
2831: EMPTY
2832: LIST
2833: LIST
2834: LIST
2835: LIST
2836: PPUSH
2837: CALL 55638 0 6
2841: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e , base_east ,  , skill , [ 500 , 50 , 0 ] , [ 10 , 2 , 3 , 1 ] ) ;
2842: LD_ADDR_EXP 39
2846: PUSH
2847: LD_INT 204
2849: PPUSH
2850: LD_INT 26
2852: PPUSH
2853: LD_STRING 
2855: PPUSH
2856: LD_VAR 0 5
2860: PPUSH
2861: LD_INT 500
2863: PUSH
2864: LD_INT 50
2866: PUSH
2867: LD_INT 0
2869: PUSH
2870: EMPTY
2871: LIST
2872: LIST
2873: LIST
2874: PPUSH
2875: LD_INT 10
2877: PUSH
2878: LD_INT 2
2880: PUSH
2881: LD_INT 3
2883: PUSH
2884: LD_INT 1
2886: PUSH
2887: EMPTY
2888: LIST
2889: LIST
2890: LIST
2891: LIST
2892: PPUSH
2893: CALL 55638 0 6
2897: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east ] ;
2898: LD_ADDR_EXP 50
2902: PUSH
2903: LD_EXP 37
2907: PUSH
2908: LD_EXP 35
2912: PUSH
2913: LD_EXP 39
2917: PUSH
2918: EMPTY
2919: LIST
2920: LIST
2921: LIST
2922: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
2923: LD_ADDR_VAR 0 2
2927: PUSH
2928: LD_INT 22
2930: PUSH
2931: LD_INT 2
2933: PUSH
2934: EMPTY
2935: LIST
2936: LIST
2937: PUSH
2938: LD_INT 30
2940: PUSH
2941: LD_INT 31
2943: PUSH
2944: EMPTY
2945: LIST
2946: LIST
2947: PUSH
2948: LD_INT 58
2950: PUSH
2951: EMPTY
2952: LIST
2953: PUSH
2954: EMPTY
2955: LIST
2956: LIST
2957: LIST
2958: PPUSH
2959: CALL_OW 69
2963: PUSH
2964: FOR_IN
2965: IFFALSE 3090
// begin if GetBase ( i ) then
2967: LD_VAR 0 2
2971: PPUSH
2972: CALL_OW 274
2976: IFFALSE 2980
// continue ;
2978: GO 2964
// d := GetDir ( i ) ;
2980: LD_ADDR_VAR 0 3
2984: PUSH
2985: LD_VAR 0 2
2989: PPUSH
2990: CALL_OW 254
2994: ST_TO_ADDR
// if d < 3 then
2995: LD_VAR 0 3
2999: PUSH
3000: LD_INT 3
3002: LESS
3003: IFFALSE 3021
// d := d + 3 else
3005: LD_ADDR_VAR 0 3
3009: PUSH
3010: LD_VAR 0 3
3014: PUSH
3015: LD_INT 3
3017: PLUS
3018: ST_TO_ADDR
3019: GO 3035
// d := d - 3 ;
3021: LD_ADDR_VAR 0 3
3025: PUSH
3026: LD_VAR 0 3
3030: PUSH
3031: LD_INT 3
3033: MINUS
3034: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
3035: LD_INT 0
3037: PPUSH
3038: LD_INT 8
3040: PPUSH
3041: LD_VAR 0 5
3045: PPUSH
3046: CALL_OW 380
// un := CreateHuman ;
3050: LD_ADDR_VAR 0 4
3054: PUSH
3055: CALL_OW 44
3059: ST_TO_ADDR
// SetDir ( un , d ) ;
3060: LD_VAR 0 4
3064: PPUSH
3065: LD_VAR 0 3
3069: PPUSH
3070: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
3074: LD_VAR 0 4
3078: PPUSH
3079: LD_VAR 0 2
3083: PPUSH
3084: CALL_OW 52
// end ;
3088: GO 2964
3090: POP
3091: POP
// if Difficulty > 1 then
3092: LD_OWVAR 67
3096: PUSH
3097: LD_INT 1
3099: GREATER
3100: IFFALSE 3471
// begin ar_kamikadze := [ ] ;
3102: LD_ADDR_EXP 42
3106: PUSH
3107: EMPTY
3108: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
3109: LD_INT 0
3111: PPUSH
3112: LD_INT 1
3114: PPUSH
3115: LD_VAR 0 5
3119: PPUSH
3120: CALL_OW 380
// un := CreateHuman ;
3124: LD_ADDR_VAR 0 4
3128: PUSH
3129: CALL_OW 44
3133: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3134: LD_VAR 0 4
3138: PPUSH
3139: LD_INT 3
3141: PPUSH
3142: CALL_OW 233
// PlaceUnitXY ( un , 23 , 44 , false ) ;
3146: LD_VAR 0 4
3150: PPUSH
3151: LD_INT 23
3153: PPUSH
3154: LD_INT 44
3156: PPUSH
3157: LD_INT 0
3159: PPUSH
3160: CALL_OW 48
// ComCrawl ( un ) ;
3164: LD_VAR 0 4
3168: PPUSH
3169: CALL_OW 137
// un := CreateHuman ;
3173: LD_ADDR_VAR 0 4
3177: PUSH
3178: CALL_OW 44
3182: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3183: LD_VAR 0 4
3187: PPUSH
3188: LD_INT 3
3190: PPUSH
3191: CALL_OW 233
// PlaceUnitXY ( un , 30 , 39 , false ) ;
3195: LD_VAR 0 4
3199: PPUSH
3200: LD_INT 30
3202: PPUSH
3203: LD_INT 39
3205: PPUSH
3206: LD_INT 0
3208: PPUSH
3209: CALL_OW 48
// ComCrawl ( un ) ;
3213: LD_VAR 0 4
3217: PPUSH
3218: CALL_OW 137
// PrepareHuman ( false , 17 , skill ) ;
3222: LD_INT 0
3224: PPUSH
3225: LD_INT 17
3227: PPUSH
3228: LD_VAR 0 5
3232: PPUSH
3233: CALL_OW 380
// un := CreateHuman ;
3237: LD_ADDR_VAR 0 4
3241: PUSH
3242: CALL_OW 44
3246: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3247: LD_VAR 0 4
3251: PPUSH
3252: LD_INT 3
3254: PPUSH
3255: CALL_OW 233
// PlaceUnitXY ( un , 45 , 86 , false ) ;
3259: LD_VAR 0 4
3263: PPUSH
3264: LD_INT 45
3266: PPUSH
3267: LD_INT 86
3269: PPUSH
3270: LD_INT 0
3272: PPUSH
3273: CALL_OW 48
// ComHold ( un ) ;
3277: LD_VAR 0 4
3281: PPUSH
3282: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3286: LD_ADDR_EXP 42
3290: PUSH
3291: LD_EXP 42
3295: PPUSH
3296: LD_EXP 42
3300: PUSH
3301: LD_INT 1
3303: PLUS
3304: PPUSH
3305: LD_VAR 0 4
3309: PPUSH
3310: CALL_OW 1
3314: ST_TO_ADDR
// un := CreateHuman ;
3315: LD_ADDR_VAR 0 4
3319: PUSH
3320: CALL_OW 44
3324: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3325: LD_VAR 0 4
3329: PPUSH
3330: LD_INT 3
3332: PPUSH
3333: CALL_OW 233
// PlaceUnitXY ( un , 60 , 85 , false ) ;
3337: LD_VAR 0 4
3341: PPUSH
3342: LD_INT 60
3344: PPUSH
3345: LD_INT 85
3347: PPUSH
3348: LD_INT 0
3350: PPUSH
3351: CALL_OW 48
// ComHold ( un ) ;
3355: LD_VAR 0 4
3359: PPUSH
3360: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3364: LD_ADDR_EXP 42
3368: PUSH
3369: LD_EXP 42
3373: PPUSH
3374: LD_EXP 42
3378: PUSH
3379: LD_INT 1
3381: PLUS
3382: PPUSH
3383: LD_VAR 0 4
3387: PPUSH
3388: CALL_OW 1
3392: ST_TO_ADDR
// un := CreateHuman ;
3393: LD_ADDR_VAR 0 4
3397: PUSH
3398: CALL_OW 44
3402: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3403: LD_VAR 0 4
3407: PPUSH
3408: LD_INT 3
3410: PPUSH
3411: CALL_OW 233
// PlaceUnitXY ( un , 222 , 166 , false ) ;
3415: LD_VAR 0 4
3419: PPUSH
3420: LD_INT 222
3422: PPUSH
3423: LD_INT 166
3425: PPUSH
3426: LD_INT 0
3428: PPUSH
3429: CALL_OW 48
// ComHold ( un ) ;
3433: LD_VAR 0 4
3437: PPUSH
3438: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3442: LD_ADDR_EXP 42
3446: PUSH
3447: LD_EXP 42
3451: PPUSH
3452: LD_EXP 42
3456: PUSH
3457: LD_INT 1
3459: PLUS
3460: PPUSH
3461: LD_VAR 0 4
3465: PPUSH
3466: CALL_OW 1
3470: ST_TO_ADDR
// end ; ar_force_tmp := [ ] ;
3471: LD_ADDR_EXP 40
3475: PUSH
3476: EMPTY
3477: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
3478: LD_INT 1
3480: PPUSH
3481: LD_INT 1
3483: PPUSH
3484: LD_VAR 0 5
3488: PPUSH
3489: CALL_OW 380
// hc_name := Pavel Grigorovic ;
3493: LD_ADDR_OWVAR 26
3497: PUSH
3498: LD_STRING Pavel Grigorovic
3500: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3501: LD_ADDR_OWVAR 33
3505: PUSH
3506: LD_STRING SecondCharsGal
3508: ST_TO_ADDR
// hc_face_number := 4 ;
3509: LD_ADDR_OWVAR 34
3513: PUSH
3514: LD_INT 4
3516: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
3517: LD_ADDR_EXP 40
3521: PUSH
3522: LD_EXP 40
3526: PPUSH
3527: LD_INT 1
3529: PPUSH
3530: CALL_OW 44
3534: PPUSH
3535: CALL_OW 1
3539: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3540: LD_INT 2
3542: PPUSH
3543: LD_INT 4
3545: PPUSH
3546: LD_INT 2
3548: PPUSH
3549: CALL_OW 380
// hc_name := Lucy Sebel ;
3553: LD_ADDR_OWVAR 26
3557: PUSH
3558: LD_STRING Lucy Sebel
3560: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3561: LD_ADDR_OWVAR 33
3565: PUSH
3566: LD_STRING SecondCharsGal
3568: ST_TO_ADDR
// hc_face_number := 15 ;
3569: LD_ADDR_OWVAR 34
3573: PUSH
3574: LD_INT 15
3576: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
3577: LD_ADDR_EXP 40
3581: PUSH
3582: LD_EXP 40
3586: PPUSH
3587: LD_INT 2
3589: PPUSH
3590: CALL_OW 44
3594: PPUSH
3595: CALL_OW 1
3599: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3600: LD_INT 2
3602: PPUSH
3603: LD_INT 4
3605: PPUSH
3606: LD_INT 2
3608: PPUSH
3609: CALL_OW 380
// hc_gallery :=  ;
3613: LD_ADDR_OWVAR 33
3617: PUSH
3618: LD_STRING 
3620: ST_TO_ADDR
// hc_name :=  ;
3621: LD_ADDR_OWVAR 26
3625: PUSH
3626: LD_STRING 
3628: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
3629: LD_ADDR_EXP 40
3633: PUSH
3634: LD_EXP 40
3638: PPUSH
3639: LD_INT 3
3641: PPUSH
3642: CALL_OW 44
3646: PPUSH
3647: CALL_OW 1
3651: ST_TO_ADDR
// hc_sex := sex_male ;
3652: LD_ADDR_OWVAR 27
3656: PUSH
3657: LD_INT 1
3659: ST_TO_ADDR
// hc_class = 11 ;
3660: LD_ADDR_OWVAR 28
3664: PUSH
3665: LD_INT 11
3667: ST_TO_ADDR
// hc_gallery = sandar ;
3668: LD_ADDR_OWVAR 33
3672: PUSH
3673: LD_STRING sandar
3675: ST_TO_ADDR
// hc_face_number = 33 ;
3676: LD_ADDR_OWVAR 34
3680: PUSH
3681: LD_INT 33
3683: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
3684: LD_ADDR_OWVAR 26
3688: PUSH
3689: LD_STRING Thabit Muhair Saliba
3691: ST_TO_ADDR
// hc_skills = [ 0 , 0 , 0 , 0 ] ;
3692: LD_ADDR_OWVAR 31
3696: PUSH
3697: LD_INT 0
3699: PUSH
3700: LD_INT 0
3702: PUSH
3703: LD_INT 0
3705: PUSH
3706: LD_INT 0
3708: PUSH
3709: EMPTY
3710: LIST
3711: LIST
3712: LIST
3713: LIST
3714: ST_TO_ADDR
// Saliba = CreateHuman ;
3715: LD_ADDR_EXP 44
3719: PUSH
3720: CALL_OW 44
3724: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
3725: LD_EXP 44
3729: PPUSH
3730: LD_INT 7
3732: PPUSH
3733: CALL_OW 52
// if gensher_active then
3737: LD_EXP 18
3741: IFFALSE 3768
// begin Gensher = NewCharacter ( Dietrich ) ;
3743: LD_ADDR_EXP 45
3747: PUSH
3748: LD_STRING Dietrich
3750: PPUSH
3751: CALL_OW 25
3755: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
3756: LD_EXP 45
3760: PPUSH
3761: LD_INT 94
3763: PPUSH
3764: CALL_OW 52
// end ; InitHc ;
3768: CALL_OW 19
// ar_vehicles_tmp := [ ] ;
3772: LD_ADDR_EXP 41
3776: PUSH
3777: EMPTY
3778: ST_TO_ADDR
// for i = 1 to 5 do
3779: LD_ADDR_VAR 0 2
3783: PUSH
3784: DOUBLE
3785: LD_INT 1
3787: DEC
3788: ST_TO_ADDR
3789: LD_INT 5
3791: PUSH
3792: FOR_TO
3793: IFFALSE 3965
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , [ engine_combustion , engine_solar ] [ rand ( 1 , 2 ) ] , control_manual , [ ar_gatling_gun , ar_gun , ar_flame_thrower ] [ rand ( 1 , 3 ) ] , rand ( 60 , 100 ) ) ;
3795: LD_INT 13
3797: PUSH
3798: LD_INT 14
3800: PUSH
3801: EMPTY
3802: LIST
3803: LIST
3804: PUSH
3805: LD_INT 1
3807: PPUSH
3808: LD_INT 2
3810: PPUSH
3811: CALL_OW 12
3815: ARRAY
3816: PPUSH
3817: LD_INT 1
3819: PUSH
3820: LD_INT 2
3822: PUSH
3823: EMPTY
3824: LIST
3825: LIST
3826: PUSH
3827: LD_INT 1
3829: PPUSH
3830: LD_INT 2
3832: PPUSH
3833: CALL_OW 12
3837: ARRAY
3838: PPUSH
3839: LD_INT 1
3841: PPUSH
3842: LD_INT 25
3844: PUSH
3845: LD_INT 27
3847: PUSH
3848: LD_INT 26
3850: PUSH
3851: EMPTY
3852: LIST
3853: LIST
3854: LIST
3855: PUSH
3856: LD_INT 1
3858: PPUSH
3859: LD_INT 3
3861: PPUSH
3862: CALL_OW 12
3866: ARRAY
3867: PPUSH
3868: LD_INT 60
3870: PPUSH
3871: LD_INT 100
3873: PPUSH
3874: CALL_OW 12
3878: PPUSH
3879: CALL 52229 0 5
// un := CreateVehicle ;
3883: LD_ADDR_VAR 0 4
3887: PUSH
3888: CALL_OW 45
3892: ST_TO_ADDR
// ar_vehicles_tmp := Replace ( ar_vehicles_tmp , ar_vehicles_tmp + 1 , un ) ;
3893: LD_ADDR_EXP 41
3897: PUSH
3898: LD_EXP 41
3902: PPUSH
3903: LD_EXP 41
3907: PUSH
3908: LD_INT 1
3910: PLUS
3911: PPUSH
3912: LD_VAR 0 4
3916: PPUSH
3917: CALL_OW 1
3921: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
3922: LD_VAR 0 4
3926: PPUSH
3927: LD_INT 0
3929: PPUSH
3930: LD_INT 5
3932: PPUSH
3933: CALL_OW 12
3937: PPUSH
3938: CALL_OW 233
// PlaceUnitXYR ( un , 124 , 141 , 8 , false ) ;
3942: LD_VAR 0 4
3946: PPUSH
3947: LD_INT 124
3949: PPUSH
3950: LD_INT 141
3952: PPUSH
3953: LD_INT 8
3955: PPUSH
3956: LD_INT 0
3958: PPUSH
3959: CALL_OW 50
// end ;
3963: GO 3792
3965: POP
3966: POP
// ar_defenders_tmp := [ [ ] , [ ] , [ ] ] ;
3967: LD_ADDR_EXP 43
3971: PUSH
3972: EMPTY
3973: PUSH
3974: EMPTY
3975: PUSH
3976: EMPTY
3977: PUSH
3978: EMPTY
3979: LIST
3980: LIST
3981: LIST
3982: ST_TO_ADDR
// for d = 1 to [ 3 , 3 , 4 ] [ Difficulty ] do
3983: LD_ADDR_VAR 0 3
3987: PUSH
3988: DOUBLE
3989: LD_INT 1
3991: DEC
3992: ST_TO_ADDR
3993: LD_INT 3
3995: PUSH
3996: LD_INT 3
3998: PUSH
3999: LD_INT 4
4001: PUSH
4002: EMPTY
4003: LIST
4004: LIST
4005: LIST
4006: PUSH
4007: LD_OWVAR 67
4011: ARRAY
4012: PUSH
4013: FOR_TO
4014: IFFALSE 4228
// for i = 1 to 3 do
4016: LD_ADDR_VAR 0 2
4020: PUSH
4021: DOUBLE
4022: LD_INT 1
4024: DEC
4025: ST_TO_ADDR
4026: LD_INT 3
4028: PUSH
4029: FOR_TO
4030: IFFALSE 4224
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
4032: LD_INT 14
4034: PPUSH
4035: LD_INT 3
4037: PUSH
4038: LD_INT 2
4040: PUSH
4041: EMPTY
4042: LIST
4043: LIST
4044: PUSH
4045: LD_INT 1
4047: PPUSH
4048: LD_INT 2
4050: PPUSH
4051: CALL_OW 12
4055: ARRAY
4056: PPUSH
4057: LD_INT 1
4059: PUSH
4060: LD_INT 5
4062: PUSH
4063: EMPTY
4064: LIST
4065: LIST
4066: PUSH
4067: LD_INT 1
4069: PPUSH
4070: LD_INT 2
4072: PPUSH
4073: CALL_OW 12
4077: ARRAY
4078: PPUSH
4079: LD_INT 25
4081: PUSH
4082: LD_INT 27
4084: PUSH
4085: LD_INT 26
4087: PUSH
4088: LD_INT 28
4090: PUSH
4091: EMPTY
4092: LIST
4093: LIST
4094: LIST
4095: LIST
4096: PUSH
4097: LD_INT 1
4099: PPUSH
4100: LD_INT 4
4102: PPUSH
4103: CALL_OW 12
4107: ARRAY
4108: PPUSH
4109: LD_INT 100
4111: PPUSH
4112: CALL 52229 0 5
// un := CreateVehicle ;
4116: LD_ADDR_VAR 0 4
4120: PUSH
4121: CALL_OW 45
4125: ST_TO_ADDR
// ar_defenders_tmp := ReplaceIn ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
4126: LD_ADDR_EXP 43
4130: PUSH
4131: LD_EXP 43
4135: PPUSH
4136: LD_VAR 0 2
4140: PUSH
4141: LD_EXP 43
4145: PUSH
4146: LD_VAR 0 2
4150: ARRAY
4151: PUSH
4152: LD_INT 1
4154: PLUS
4155: PUSH
4156: EMPTY
4157: LIST
4158: LIST
4159: PPUSH
4160: LD_VAR 0 4
4164: PPUSH
4165: CALL 52351 0 3
4169: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4170: LD_VAR 0 4
4174: PPUSH
4175: LD_INT 0
4177: PPUSH
4178: LD_INT 5
4180: PPUSH
4181: CALL_OW 12
4185: PPUSH
4186: CALL_OW 233
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east ] [ i ] , false ) ;
4190: LD_VAR 0 4
4194: PPUSH
4195: LD_INT 20
4197: PUSH
4198: LD_INT 21
4200: PUSH
4201: LD_INT 22
4203: PUSH
4204: EMPTY
4205: LIST
4206: LIST
4207: LIST
4208: PUSH
4209: LD_VAR 0 2
4213: ARRAY
4214: PPUSH
4215: LD_INT 0
4217: PPUSH
4218: CALL_OW 49
// end ;
4222: GO 4029
4224: POP
4225: POP
4226: GO 4013
4228: POP
4229: POP
// InitHc ;
4230: CALL_OW 19
// CreateResourcesXY ( mat_artifact , 5 , 10 , 5 , false ) ;
4234: LD_INT 4
4236: PPUSH
4237: LD_INT 5
4239: PPUSH
4240: LD_INT 10
4242: PPUSH
4243: LD_INT 5
4245: PPUSH
4246: LD_INT 0
4248: PPUSH
4249: CALL_OW 58
// end ;
4253: LD_VAR 0 1
4257: RET
// every 0 0$1 trigger ar_kamikadze do var i ;
4258: LD_EXP 42
4262: IFFALSE 4336
4264: GO 4266
4266: DISABLE
4267: LD_INT 0
4269: PPUSH
// begin enable ;
4270: ENABLE
// for i in ar_kamikadze do
4271: LD_ADDR_VAR 0 1
4275: PUSH
4276: LD_EXP 42
4280: PUSH
4281: FOR_IN
4282: IFFALSE 4334
// if See ( 1 , i ) then
4284: LD_INT 1
4286: PPUSH
4287: LD_VAR 0 1
4291: PPUSH
4292: CALL_OW 292
4296: IFFALSE 4332
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
4298: LD_VAR 0 1
4302: PPUSH
4303: LD_INT 81
4305: PUSH
4306: LD_INT 2
4308: PUSH
4309: EMPTY
4310: LIST
4311: LIST
4312: PPUSH
4313: CALL_OW 69
4317: PPUSH
4318: LD_VAR 0 1
4322: PPUSH
4323: CALL_OW 74
4327: PPUSH
4328: CALL_OW 115
4332: GO 4281
4334: POP
4335: POP
// end ;
4336: PPOPN 1
4338: END
// every 5 5$20 trigger artifact_get do var i , cargo , tmp , pos ;
4339: LD_EXP 13
4343: IFFALSE 4660
4345: GO 4347
4347: DISABLE
4348: LD_INT 0
4350: PPUSH
4351: PPUSH
4352: PPUSH
4353: PPUSH
// begin repeat wait ( 0 0$1 ) ;
4354: LD_INT 35
4356: PPUSH
4357: CALL_OW 67
// until MC_GetProduceList ( 1 ) = 0 ;
4361: LD_INT 1
4363: PPUSH
4364: CALL 41409 0 1
4368: PUSH
4369: LD_INT 0
4371: EQUAL
4372: IFFALSE 4354
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
4374: LD_INT 1
4376: PPUSH
4377: LD_INT 14
4379: PUSH
4380: LD_INT 3
4382: PUSH
4383: LD_INT 2
4385: PUSH
4386: LD_INT 32
4388: PUSH
4389: EMPTY
4390: LIST
4391: LIST
4392: LIST
4393: LIST
4394: PUSH
4395: EMPTY
4396: LIST
4397: PPUSH
4398: CALL 41013 0 2
// repeat wait ( 0 0$1 ) ;
4402: LD_INT 35
4404: PPUSH
4405: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) ;
4409: LD_EXP 69
4413: PUSH
4414: LD_INT 1
4416: ARRAY
4417: PPUSH
4418: LD_INT 33
4420: PUSH
4421: LD_INT 2
4423: PUSH
4424: EMPTY
4425: LIST
4426: LIST
4427: PUSH
4428: LD_INT 34
4430: PUSH
4431: LD_INT 32
4433: PUSH
4434: EMPTY
4435: LIST
4436: LIST
4437: PUSH
4438: EMPTY
4439: LIST
4440: LIST
4441: PPUSH
4442: CALL_OW 72
4446: IFFALSE 4402
// cargo := UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) [ 1 ] ;
4448: LD_ADDR_VAR 0 2
4452: PUSH
4453: LD_EXP 69
4457: PUSH
4458: LD_INT 1
4460: ARRAY
4461: PPUSH
4462: LD_INT 33
4464: PUSH
4465: LD_INT 2
4467: PUSH
4468: EMPTY
4469: LIST
4470: LIST
4471: PUSH
4472: LD_INT 34
4474: PUSH
4475: LD_INT 32
4477: PUSH
4478: EMPTY
4479: LIST
4480: LIST
4481: PUSH
4482: EMPTY
4483: LIST
4484: LIST
4485: PPUSH
4486: CALL_OW 72
4490: PUSH
4491: LD_INT 1
4493: ARRAY
4494: ST_TO_ADDR
// pos := FindArtifact ( 5 ) ;
4495: LD_ADDR_VAR 0 4
4499: PUSH
4500: LD_INT 5
4502: PPUSH
4503: CALL_OW 469
4507: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4508: LD_INT 35
4510: PPUSH
4511: CALL_OW 67
// pos := FindArtifact ( 5 ) ;
4515: LD_ADDR_VAR 0 4
4519: PUSH
4520: LD_INT 5
4522: PPUSH
4523: CALL_OW 469
4527: ST_TO_ADDR
// tmp := 100 ;
4528: LD_ADDR_VAR 0 3
4532: PUSH
4533: LD_INT 100
4535: ST_TO_ADDR
// if pos then
4536: LD_VAR 0 4
4540: IFFALSE 4580
// tmp := DangerAtRangeXY ( 2 , pos [ 1 ] , pos [ 2 ] , 20 ) [ 4 ] ;
4542: LD_ADDR_VAR 0 3
4546: PUSH
4547: LD_INT 2
4549: PPUSH
4550: LD_VAR 0 4
4554: PUSH
4555: LD_INT 1
4557: ARRAY
4558: PPUSH
4559: LD_VAR 0 4
4563: PUSH
4564: LD_INT 2
4566: ARRAY
4567: PPUSH
4568: LD_INT 20
4570: PPUSH
4571: CALL 53247 0 4
4575: PUSH
4576: LD_INT 4
4578: ARRAY
4579: ST_TO_ADDR
// until pos and not artifact_oncargo and tmp < 10 ;
4580: LD_VAR 0 4
4584: PUSH
4585: LD_EXP 14
4589: NOT
4590: AND
4591: PUSH
4592: LD_VAR 0 3
4596: PUSH
4597: LD_INT 10
4599: LESS
4600: AND
4601: IFFALSE 4508
// ComGet ( cargo , pos [ 1 ] , pos [ 2 ] ) ;
4603: LD_VAR 0 2
4607: PPUSH
4608: LD_VAR 0 4
4612: PUSH
4613: LD_INT 1
4615: ARRAY
4616: PPUSH
4617: LD_VAR 0 4
4621: PUSH
4622: LD_INT 2
4624: ARRAY
4625: PPUSH
4626: CALL_OW 160
// AddComMoveXY ( cargo , 198 , 113 ) ;
4630: LD_VAR 0 2
4634: PPUSH
4635: LD_INT 198
4637: PPUSH
4638: LD_INT 113
4640: PPUSH
4641: CALL_OW 171
// AddComMoveXY ( cargo , 124 , 7 ) ;
4645: LD_VAR 0 2
4649: PPUSH
4650: LD_INT 124
4652: PPUSH
4653: LD_INT 7
4655: PPUSH
4656: CALL_OW 171
// end ;
4660: PPOPN 4
4662: END
// every 5 5$00 trigger base_captured do var i , un , tmp , skill , coords , flags , w , list ;
4663: LD_EXP 6
4667: IFFALSE 7448
4669: GO 4671
4671: DISABLE
4672: LD_INT 0
4674: PPUSH
4675: PPUSH
4676: PPUSH
4677: PPUSH
4678: PPUSH
4679: PPUSH
4680: PPUSH
4681: PPUSH
// begin skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
4682: LD_ADDR_VAR 0 4
4686: PUSH
4687: LD_INT 5
4689: PUSH
4690: LD_INT 6
4692: PUSH
4693: LD_INT 7
4695: PUSH
4696: EMPTY
4697: LIST
4698: LIST
4699: LIST
4700: PUSH
4701: LD_OWVAR 67
4705: ARRAY
4706: ST_TO_ADDR
// coords := [ ] ;
4707: LD_ADDR_VAR 0 5
4711: PUSH
4712: EMPTY
4713: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
4714: LD_ADDR_VAR 0 6
4718: PUSH
4719: LD_INT 0
4721: PUSH
4722: LD_INT 0
4724: PUSH
4725: LD_INT 0
4727: PUSH
4728: LD_INT 0
4730: PUSH
4731: LD_INT 1
4733: PUSH
4734: LD_INT 0
4736: PUSH
4737: LD_INT 0
4739: PUSH
4740: LD_INT 0
4742: PUSH
4743: LD_INT 1
4745: PUSH
4746: LD_INT 0
4748: PUSH
4749: EMPTY
4750: LIST
4751: LIST
4752: LIST
4753: LIST
4754: LIST
4755: LIST
4756: LIST
4757: LIST
4758: LIST
4759: LIST
4760: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ) ;
4761: LD_INT 1
4763: PPUSH
4764: LD_INT 14
4766: PUSH
4767: LD_INT 1
4769: PUSH
4770: LD_INT 2
4772: PUSH
4773: LD_INT 28
4775: PUSH
4776: EMPTY
4777: LIST
4778: LIST
4779: LIST
4780: LIST
4781: PUSH
4782: LD_INT 14
4784: PUSH
4785: LD_INT 1
4787: PUSH
4788: LD_INT 2
4790: PUSH
4791: LD_INT 25
4793: PUSH
4794: EMPTY
4795: LIST
4796: LIST
4797: LIST
4798: LIST
4799: PUSH
4800: LD_INT 14
4802: PUSH
4803: LD_INT 1
4805: PUSH
4806: LD_INT 2
4808: PUSH
4809: LD_INT 28
4811: PUSH
4812: EMPTY
4813: LIST
4814: LIST
4815: LIST
4816: LIST
4817: PUSH
4818: LD_INT 14
4820: PUSH
4821: LD_INT 1
4823: PUSH
4824: LD_INT 2
4826: PUSH
4827: LD_INT 29
4829: PUSH
4830: EMPTY
4831: LIST
4832: LIST
4833: LIST
4834: LIST
4835: PUSH
4836: EMPTY
4837: LIST
4838: LIST
4839: LIST
4840: LIST
4841: PPUSH
4842: CALL 41013 0 2
// wait ( [ 10 10$00 , 9 9$30 , 9 9$00 ] [ Difficulty ] ) ;
4846: LD_INT 21000
4848: PUSH
4849: LD_INT 19950
4851: PUSH
4852: LD_INT 18900
4854: PUSH
4855: EMPTY
4856: LIST
4857: LIST
4858: LIST
4859: PUSH
4860: LD_OWVAR 67
4864: ARRAY
4865: PPUSH
4866: CALL_OW 67
// InitHc ;
4870: CALL_OW 19
// InitUc ;
4874: CALL_OW 18
// uc_side := 2 ;
4878: LD_ADDR_OWVAR 20
4882: PUSH
4883: LD_INT 2
4885: ST_TO_ADDR
// uc_nation := 2 ;
4886: LD_ADDR_OWVAR 21
4890: PUSH
4891: LD_INT 2
4893: ST_TO_ADDR
// tmp := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
4894: LD_ADDR_VAR 0 3
4898: PUSH
4899: EMPTY
4900: PUSH
4901: EMPTY
4902: PUSH
4903: EMPTY
4904: PUSH
4905: EMPTY
4906: PUSH
4907: EMPTY
4908: PUSH
4909: EMPTY
4910: LIST
4911: LIST
4912: LIST
4913: LIST
4914: LIST
4915: ST_TO_ADDR
// tmp := Replace ( tmp , 1 , mc_vehicles [ 1 ] diff FilterAllUnits ( [ f_weapon , ar_cargo_bay ] ) ) ;
4916: LD_ADDR_VAR 0 3
4920: PUSH
4921: LD_VAR 0 3
4925: PPUSH
4926: LD_INT 1
4928: PPUSH
4929: LD_EXP 69
4933: PUSH
4934: LD_INT 1
4936: ARRAY
4937: PUSH
4938: LD_INT 34
4940: PUSH
4941: LD_INT 32
4943: PUSH
4944: EMPTY
4945: LIST
4946: LIST
4947: PPUSH
4948: CALL_OW 69
4952: DIFF
4953: PPUSH
4954: CALL_OW 1
4958: ST_TO_ADDR
// for i = 1 to Difficulty do
4959: LD_ADDR_VAR 0 1
4963: PUSH
4964: DOUBLE
4965: LD_INT 1
4967: DEC
4968: ST_TO_ADDR
4969: LD_OWVAR 67
4973: PUSH
4974: FOR_TO
4975: IFFALSE 5113
// begin uc_side := 2 ;
4977: LD_ADDR_OWVAR 20
4981: PUSH
4982: LD_INT 2
4984: ST_TO_ADDR
// uc_nation := 2 ;
4985: LD_ADDR_OWVAR 21
4989: PUSH
4990: LD_INT 2
4992: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
4993: LD_INT 13
4995: PPUSH
4996: LD_INT 3
4998: PPUSH
4999: LD_INT 5
5001: PPUSH
5002: LD_INT 29
5004: PPUSH
5005: LD_INT 100
5007: PPUSH
5008: CALL 52229 0 5
// un := CreateVehicle ;
5012: LD_ADDR_VAR 0 2
5016: PUSH
5017: CALL_OW 45
5021: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 1 , tmp [ 1 ] + 1 ] , un ) ;
5022: LD_ADDR_VAR 0 3
5026: PUSH
5027: LD_VAR 0 3
5031: PPUSH
5032: LD_INT 1
5034: PUSH
5035: LD_VAR 0 3
5039: PUSH
5040: LD_INT 1
5042: ARRAY
5043: PUSH
5044: LD_INT 1
5046: PLUS
5047: PUSH
5048: EMPTY
5049: LIST
5050: LIST
5051: PPUSH
5052: LD_VAR 0 2
5056: PPUSH
5057: CALL 52351 0 3
5061: ST_TO_ADDR
// SetDir ( un , 3 ) ;
5062: LD_VAR 0 2
5066: PPUSH
5067: LD_INT 3
5069: PPUSH
5070: CALL_OW 233
// PlaceUnitArea ( un , north_attack_spawn , false ) ;
5074: LD_VAR 0 2
5078: PPUSH
5079: LD_INT 16
5081: PPUSH
5082: LD_INT 0
5084: PPUSH
5085: CALL_OW 49
// ComMoveXY ( un , 51 , 10 ) ;
5089: LD_VAR 0 2
5093: PPUSH
5094: LD_INT 51
5096: PPUSH
5097: LD_INT 10
5099: PPUSH
5100: CALL_OW 111
// wait ( 0 0$2 ) ;
5104: LD_INT 70
5106: PPUSH
5107: CALL_OW 67
// end ;
5111: GO 4974
5113: POP
5114: POP
// coords := [ [ 51 , 24 ] , [ 75 , 90 ] ] ;
5115: LD_ADDR_VAR 0 5
5119: PUSH
5120: LD_INT 51
5122: PUSH
5123: LD_INT 24
5125: PUSH
5126: EMPTY
5127: LIST
5128: LIST
5129: PUSH
5130: LD_INT 75
5132: PUSH
5133: LD_INT 90
5135: PUSH
5136: EMPTY
5137: LIST
5138: LIST
5139: PUSH
5140: EMPTY
5141: LIST
5142: LIST
5143: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 1 ] , coords , flags ) ;
5144: LD_INT 1
5146: PPUSH
5147: LD_VAR 0 3
5151: PUSH
5152: LD_INT 1
5154: ARRAY
5155: PPUSH
5156: LD_VAR 0 5
5160: PPUSH
5161: LD_VAR 0 6
5165: PPUSH
5166: CALL 41246 0 4
// for i = 1 to [ 1 , 3 , 3 ] [ Difficulty ] do
5170: LD_ADDR_VAR 0 1
5174: PUSH
5175: DOUBLE
5176: LD_INT 1
5178: DEC
5179: ST_TO_ADDR
5180: LD_INT 1
5182: PUSH
5183: LD_INT 3
5185: PUSH
5186: LD_INT 3
5188: PUSH
5189: EMPTY
5190: LIST
5191: LIST
5192: LIST
5193: PUSH
5194: LD_OWVAR 67
5198: ARRAY
5199: PUSH
5200: FOR_TO
5201: IFFALSE 5301
// begin uc_side := 2 ;
5203: LD_ADDR_OWVAR 20
5207: PUSH
5208: LD_INT 2
5210: ST_TO_ADDR
// uc_nation := 2 ;
5211: LD_ADDR_OWVAR 21
5215: PUSH
5216: LD_INT 2
5218: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5219: LD_INT 0
5221: PPUSH
5222: LD_INT 17
5224: PPUSH
5225: LD_VAR 0 4
5229: PPUSH
5230: CALL_OW 380
// un := CreateHuman ;
5234: LD_ADDR_VAR 0 2
5238: PUSH
5239: CALL_OW 44
5243: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5244: LD_ADDR_VAR 0 3
5248: PUSH
5249: LD_VAR 0 3
5253: PPUSH
5254: LD_INT 2
5256: PUSH
5257: LD_VAR 0 3
5261: PUSH
5262: LD_INT 2
5264: ARRAY
5265: PUSH
5266: LD_INT 1
5268: PLUS
5269: PUSH
5270: EMPTY
5271: LIST
5272: LIST
5273: PPUSH
5274: LD_VAR 0 2
5278: PPUSH
5279: CALL 52351 0 3
5283: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5284: LD_VAR 0 2
5288: PPUSH
5289: LD_INT 13
5291: PPUSH
5292: LD_INT 0
5294: PPUSH
5295: CALL_OW 49
// end ;
5299: GO 5200
5301: POP
5302: POP
// for i = 1 to [ 3 , 4 , 4 ] [ Difficulty ] do
5303: LD_ADDR_VAR 0 1
5307: PUSH
5308: DOUBLE
5309: LD_INT 1
5311: DEC
5312: ST_TO_ADDR
5313: LD_INT 3
5315: PUSH
5316: LD_INT 4
5318: PUSH
5319: LD_INT 4
5321: PUSH
5322: EMPTY
5323: LIST
5324: LIST
5325: LIST
5326: PUSH
5327: LD_OWVAR 67
5331: ARRAY
5332: PUSH
5333: FOR_TO
5334: IFFALSE 5455
// begin uc_side := 2 ;
5336: LD_ADDR_OWVAR 20
5340: PUSH
5341: LD_INT 2
5343: ST_TO_ADDR
// uc_nation := 2 ;
5344: LD_ADDR_OWVAR 21
5348: PUSH
5349: LD_INT 2
5351: ST_TO_ADDR
// PrepareHuman ( false , [ 1 , 8 ] [ i mod 2 + 1 ] , skill ) ;
5352: LD_INT 0
5354: PPUSH
5355: LD_INT 1
5357: PUSH
5358: LD_INT 8
5360: PUSH
5361: EMPTY
5362: LIST
5363: LIST
5364: PUSH
5365: LD_VAR 0 1
5369: PUSH
5370: LD_INT 2
5372: MOD
5373: PUSH
5374: LD_INT 1
5376: PLUS
5377: ARRAY
5378: PPUSH
5379: LD_VAR 0 4
5383: PPUSH
5384: CALL_OW 380
// un := CreateHuman ;
5388: LD_ADDR_VAR 0 2
5392: PUSH
5393: CALL_OW 44
5397: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5398: LD_ADDR_VAR 0 3
5402: PUSH
5403: LD_VAR 0 3
5407: PPUSH
5408: LD_INT 2
5410: PUSH
5411: LD_VAR 0 3
5415: PUSH
5416: LD_INT 2
5418: ARRAY
5419: PUSH
5420: LD_INT 1
5422: PLUS
5423: PUSH
5424: EMPTY
5425: LIST
5426: LIST
5427: PPUSH
5428: LD_VAR 0 2
5432: PPUSH
5433: CALL 52351 0 3
5437: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5438: LD_VAR 0 2
5442: PPUSH
5443: LD_INT 13
5445: PPUSH
5446: LD_INT 0
5448: PPUSH
5449: CALL_OW 49
// end ;
5453: GO 5333
5455: POP
5456: POP
// coords := [ [ 67 , 112 ] , [ 85 , 130 ] ] ;
5457: LD_ADDR_VAR 0 5
5461: PUSH
5462: LD_INT 67
5464: PUSH
5465: LD_INT 112
5467: PUSH
5468: EMPTY
5469: LIST
5470: LIST
5471: PUSH
5472: LD_INT 85
5474: PUSH
5475: LD_INT 130
5477: PUSH
5478: EMPTY
5479: LIST
5480: LIST
5481: PUSH
5482: EMPTY
5483: LIST
5484: LIST
5485: ST_TO_ADDR
// MC_PrepareAttack ( 2 , tmp [ 2 ] , coords , flags ) ;
5486: LD_INT 2
5488: PPUSH
5489: LD_VAR 0 3
5493: PUSH
5494: LD_INT 2
5496: ARRAY
5497: PPUSH
5498: LD_VAR 0 5
5502: PPUSH
5503: LD_VAR 0 6
5507: PPUSH
5508: CALL 41246 0 4
// for i = 1 to [ 1 , 2 , 3 ] [ Difficulty ] do
5512: LD_ADDR_VAR 0 1
5516: PUSH
5517: DOUBLE
5518: LD_INT 1
5520: DEC
5521: ST_TO_ADDR
5522: LD_INT 1
5524: PUSH
5525: LD_INT 2
5527: PUSH
5528: LD_INT 3
5530: PUSH
5531: EMPTY
5532: LIST
5533: LIST
5534: LIST
5535: PUSH
5536: LD_OWVAR 67
5540: ARRAY
5541: PUSH
5542: FOR_TO
5543: IFFALSE 5643
// begin uc_side := 2 ;
5545: LD_ADDR_OWVAR 20
5549: PUSH
5550: LD_INT 2
5552: ST_TO_ADDR
// uc_nation := 2 ;
5553: LD_ADDR_OWVAR 21
5557: PUSH
5558: LD_INT 2
5560: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5561: LD_INT 0
5563: PPUSH
5564: LD_INT 17
5566: PPUSH
5567: LD_VAR 0 4
5571: PPUSH
5572: CALL_OW 380
// un := CreateHuman ;
5576: LD_ADDR_VAR 0 2
5580: PUSH
5581: CALL_OW 44
5585: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 3 , tmp [ 3 ] + 1 ] , un ) ;
5586: LD_ADDR_VAR 0 3
5590: PUSH
5591: LD_VAR 0 3
5595: PPUSH
5596: LD_INT 3
5598: PUSH
5599: LD_VAR 0 3
5603: PUSH
5604: LD_INT 3
5606: ARRAY
5607: PUSH
5608: LD_INT 1
5610: PLUS
5611: PUSH
5612: EMPTY
5613: LIST
5614: LIST
5615: PPUSH
5616: LD_VAR 0 2
5620: PPUSH
5621: CALL 52351 0 3
5625: ST_TO_ADDR
// PlaceUnitArea ( un , south_attack_spawn , false ) ;
5626: LD_VAR 0 2
5630: PPUSH
5631: LD_INT 14
5633: PPUSH
5634: LD_INT 0
5636: PPUSH
5637: CALL_OW 49
// end ;
5641: GO 5542
5643: POP
5644: POP
// coords := [ [ 148 , 158 ] , [ 148 , 158 ] ] ;
5645: LD_ADDR_VAR 0 5
5649: PUSH
5650: LD_INT 148
5652: PUSH
5653: LD_INT 158
5655: PUSH
5656: EMPTY
5657: LIST
5658: LIST
5659: PUSH
5660: LD_INT 148
5662: PUSH
5663: LD_INT 158
5665: PUSH
5666: EMPTY
5667: LIST
5668: LIST
5669: PUSH
5670: EMPTY
5671: LIST
5672: LIST
5673: ST_TO_ADDR
// MC_PrepareAttack ( 3 , tmp [ 3 ] , coords , flags ) ;
5674: LD_INT 3
5676: PPUSH
5677: LD_VAR 0 3
5681: PUSH
5682: LD_INT 3
5684: ARRAY
5685: PPUSH
5686: LD_VAR 0 5
5690: PPUSH
5691: LD_VAR 0 6
5695: PPUSH
5696: CALL 41246 0 4
// for i = 1 to [ 2 , 4 , 4 ] [ Difficulty ] do
5700: LD_ADDR_VAR 0 1
5704: PUSH
5705: DOUBLE
5706: LD_INT 1
5708: DEC
5709: ST_TO_ADDR
5710: LD_INT 2
5712: PUSH
5713: LD_INT 4
5715: PUSH
5716: LD_INT 4
5718: PUSH
5719: EMPTY
5720: LIST
5721: LIST
5722: LIST
5723: PUSH
5724: LD_OWVAR 67
5728: ARRAY
5729: PUSH
5730: FOR_TO
5731: IFFALSE 5955
// begin uc_side := 2 ;
5733: LD_ADDR_OWVAR 20
5737: PUSH
5738: LD_INT 2
5740: ST_TO_ADDR
// uc_nation := 2 ;
5741: LD_ADDR_OWVAR 21
5745: PUSH
5746: LD_INT 2
5748: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 3 ) ] , 100 ) ;
5749: LD_INT 14
5751: PPUSH
5752: LD_INT 3
5754: PPUSH
5755: LD_INT 1
5757: PUSH
5758: LD_INT 5
5760: PUSH
5761: EMPTY
5762: LIST
5763: LIST
5764: PUSH
5765: LD_INT 1
5767: PPUSH
5768: LD_INT 2
5770: PPUSH
5771: CALL_OW 12
5775: ARRAY
5776: PPUSH
5777: LD_INT 27
5779: PUSH
5780: LD_INT 26
5782: PUSH
5783: LD_INT 28
5785: PUSH
5786: EMPTY
5787: LIST
5788: LIST
5789: LIST
5790: PUSH
5791: LD_INT 1
5793: PPUSH
5794: LD_INT 3
5796: PPUSH
5797: CALL_OW 12
5801: ARRAY
5802: PPUSH
5803: LD_INT 100
5805: PPUSH
5806: CALL 52229 0 5
// un := CreateVehicle ;
5810: LD_ADDR_VAR 0 2
5814: PUSH
5815: CALL_OW 45
5819: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , un ) ;
5820: LD_ADDR_VAR 0 3
5824: PUSH
5825: LD_VAR 0 3
5829: PPUSH
5830: LD_INT 4
5832: PUSH
5833: LD_VAR 0 3
5837: PUSH
5838: LD_INT 4
5840: ARRAY
5841: PUSH
5842: LD_INT 1
5844: PLUS
5845: PUSH
5846: EMPTY
5847: LIST
5848: LIST
5849: PPUSH
5850: LD_VAR 0 2
5854: PPUSH
5855: CALL 52351 0 3
5859: ST_TO_ADDR
// SetDir ( un , 5 ) ;
5860: LD_VAR 0 2
5864: PPUSH
5865: LD_INT 5
5867: PPUSH
5868: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
5872: LD_VAR 0 2
5876: PPUSH
5877: LD_INT 15
5879: PPUSH
5880: LD_INT 0
5882: PPUSH
5883: CALL_OW 49
// if GetControl ( un ) = control_manual then
5887: LD_VAR 0 2
5891: PPUSH
5892: CALL_OW 263
5896: PUSH
5897: LD_INT 1
5899: EQUAL
5900: IFFALSE 5931
// begin PrepareHuman ( false , 3 , skill ) ;
5902: LD_INT 0
5904: PPUSH
5905: LD_INT 3
5907: PPUSH
5908: LD_VAR 0 4
5912: PPUSH
5913: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
5917: CALL_OW 44
5921: PPUSH
5922: LD_VAR 0 2
5926: PPUSH
5927: CALL_OW 52
// end ; ComMoveXY ( un , 179 , 135 ) ;
5931: LD_VAR 0 2
5935: PPUSH
5936: LD_INT 179
5938: PPUSH
5939: LD_INT 135
5941: PPUSH
5942: CALL_OW 111
// wait ( 0 0$2 ) ;
5946: LD_INT 70
5948: PPUSH
5949: CALL_OW 67
// end ;
5953: GO 5730
5955: POP
5956: POP
// vc_chassis := 15 ;
5957: LD_ADDR_OWVAR 37
5961: PUSH
5962: LD_INT 15
5964: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateVehicle ) ;
5965: LD_ADDR_VAR 0 3
5969: PUSH
5970: LD_VAR 0 3
5974: PPUSH
5975: LD_INT 4
5977: PUSH
5978: LD_VAR 0 3
5982: PUSH
5983: LD_INT 4
5985: ARRAY
5986: PUSH
5987: LD_INT 1
5989: PLUS
5990: PUSH
5991: EMPTY
5992: LIST
5993: LIST
5994: PPUSH
5995: CALL_OW 45
5999: PPUSH
6000: CALL 52351 0 3
6004: ST_TO_ADDR
// PlaceUnitArea ( tmp [ 4 ] [ tmp [ 4 ] ] , east_attack_spawn , false ) ;
6005: LD_VAR 0 3
6009: PUSH
6010: LD_INT 4
6012: ARRAY
6013: PUSH
6014: LD_VAR 0 3
6018: PUSH
6019: LD_INT 4
6021: ARRAY
6022: ARRAY
6023: PPUSH
6024: LD_INT 15
6026: PPUSH
6027: LD_INT 0
6029: PPUSH
6030: CALL_OW 49
// PrepareHuman ( false , class_desert_warior , skill ) ;
6034: LD_INT 0
6036: PPUSH
6037: LD_INT 11
6039: PPUSH
6040: LD_VAR 0 4
6044: PPUSH
6045: CALL_OW 380
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateHuman ) ;
6049: LD_ADDR_VAR 0 3
6053: PUSH
6054: LD_VAR 0 3
6058: PPUSH
6059: LD_INT 4
6061: PUSH
6062: LD_VAR 0 3
6066: PUSH
6067: LD_INT 4
6069: ARRAY
6070: PUSH
6071: LD_INT 1
6073: PLUS
6074: PUSH
6075: EMPTY
6076: LIST
6077: LIST
6078: PPUSH
6079: CALL_OW 44
6083: PPUSH
6084: CALL 52351 0 3
6088: ST_TO_ADDR
// PlaceHumanInUnit ( tmp [ 4 ] [ tmp [ 4 ] ] , tmp [ 4 ] [ tmp [ 4 ] - 1 ] ) ;
6089: LD_VAR 0 3
6093: PUSH
6094: LD_INT 4
6096: ARRAY
6097: PUSH
6098: LD_VAR 0 3
6102: PUSH
6103: LD_INT 4
6105: ARRAY
6106: ARRAY
6107: PPUSH
6108: LD_VAR 0 3
6112: PUSH
6113: LD_INT 4
6115: ARRAY
6116: PUSH
6117: LD_VAR 0 3
6121: PUSH
6122: LD_INT 4
6124: ARRAY
6125: PUSH
6126: LD_INT 1
6128: MINUS
6129: ARRAY
6130: PPUSH
6131: CALL_OW 52
// coords := [ [ 148 , 140 ] ] ;
6135: LD_ADDR_VAR 0 5
6139: PUSH
6140: LD_INT 148
6142: PUSH
6143: LD_INT 140
6145: PUSH
6146: EMPTY
6147: LIST
6148: LIST
6149: PUSH
6150: EMPTY
6151: LIST
6152: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 4 ] , coords , flags ) ;
6153: LD_INT 1
6155: PPUSH
6156: LD_VAR 0 3
6160: PUSH
6161: LD_INT 4
6163: ARRAY
6164: PPUSH
6165: LD_VAR 0 5
6169: PPUSH
6170: LD_VAR 0 6
6174: PPUSH
6175: CALL 41246 0 4
// if gensher_active then
6179: LD_EXP 18
6183: IFFALSE 6585
// begin SayRadio ( Gensher , D10-Diet-1 ) ;
6185: LD_EXP 45
6189: PPUSH
6190: LD_STRING D10-Diet-1
6192: PPUSH
6193: CALL_OW 94
// for i = 1 to 2 do
6197: LD_ADDR_VAR 0 1
6201: PUSH
6202: DOUBLE
6203: LD_INT 1
6205: DEC
6206: ST_TO_ADDR
6207: LD_INT 2
6209: PUSH
6210: FOR_TO
6211: IFFALSE 6349
// begin uc_side := 2 ;
6213: LD_ADDR_OWVAR 20
6217: PUSH
6218: LD_INT 2
6220: ST_TO_ADDR
// uc_nation := 2 ;
6221: LD_ADDR_OWVAR 21
6225: PUSH
6226: LD_INT 2
6228: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
6229: LD_INT 13
6231: PPUSH
6232: LD_INT 3
6234: PPUSH
6235: LD_INT 5
6237: PPUSH
6238: LD_INT 29
6240: PPUSH
6241: LD_INT 100
6243: PPUSH
6244: CALL 52229 0 5
// un := CreateVehicle ;
6248: LD_ADDR_VAR 0 2
6252: PUSH
6253: CALL_OW 45
6257: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6258: LD_ADDR_VAR 0 3
6262: PUSH
6263: LD_VAR 0 3
6267: PPUSH
6268: LD_INT 5
6270: PUSH
6271: LD_VAR 0 3
6275: PUSH
6276: LD_INT 5
6278: ARRAY
6279: PUSH
6280: LD_INT 1
6282: PLUS
6283: PUSH
6284: EMPTY
6285: LIST
6286: LIST
6287: PPUSH
6288: LD_VAR 0 2
6292: PPUSH
6293: CALL 52351 0 3
6297: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6298: LD_VAR 0 2
6302: PPUSH
6303: LD_INT 0
6305: PPUSH
6306: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6310: LD_VAR 0 2
6314: PPUSH
6315: LD_INT 23
6317: PPUSH
6318: LD_INT 0
6320: PPUSH
6321: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6325: LD_VAR 0 2
6329: PPUSH
6330: LD_INT 85
6332: PPUSH
6333: LD_INT 152
6335: PPUSH
6336: CALL_OW 111
// wait ( 0 0$2 ) ;
6340: LD_INT 70
6342: PPUSH
6343: CALL_OW 67
// end ;
6347: GO 6210
6349: POP
6350: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] do
6351: LD_ADDR_VAR 0 1
6355: PUSH
6356: DOUBLE
6357: LD_INT 1
6359: DEC
6360: ST_TO_ADDR
6361: LD_INT 2
6363: PUSH
6364: LD_INT 3
6366: PUSH
6367: LD_INT 3
6369: PUSH
6370: EMPTY
6371: LIST
6372: LIST
6373: LIST
6374: PUSH
6375: LD_OWVAR 67
6379: ARRAY
6380: PUSH
6381: FOR_TO
6382: IFFALSE 6539
// begin uc_side := 2 ;
6384: LD_ADDR_OWVAR 20
6388: PUSH
6389: LD_INT 2
6391: ST_TO_ADDR
// uc_nation := 2 ;
6392: LD_ADDR_OWVAR 21
6396: PUSH
6397: LD_INT 2
6399: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
6400: LD_INT 14
6402: PPUSH
6403: LD_INT 3
6405: PPUSH
6406: LD_INT 5
6408: PPUSH
6409: LD_INT 27
6411: PUSH
6412: LD_INT 28
6414: PUSH
6415: EMPTY
6416: LIST
6417: LIST
6418: PUSH
6419: LD_INT 1
6421: PPUSH
6422: LD_INT 2
6424: PPUSH
6425: CALL_OW 12
6429: ARRAY
6430: PPUSH
6431: LD_INT 100
6433: PPUSH
6434: CALL 52229 0 5
// un := CreateVehicle ;
6438: LD_ADDR_VAR 0 2
6442: PUSH
6443: CALL_OW 45
6447: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6448: LD_ADDR_VAR 0 3
6452: PUSH
6453: LD_VAR 0 3
6457: PPUSH
6458: LD_INT 5
6460: PUSH
6461: LD_VAR 0 3
6465: PUSH
6466: LD_INT 5
6468: ARRAY
6469: PUSH
6470: LD_INT 1
6472: PLUS
6473: PUSH
6474: EMPTY
6475: LIST
6476: LIST
6477: PPUSH
6478: LD_VAR 0 2
6482: PPUSH
6483: CALL 52351 0 3
6487: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6488: LD_VAR 0 2
6492: PPUSH
6493: LD_INT 0
6495: PPUSH
6496: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6500: LD_VAR 0 2
6504: PPUSH
6505: LD_INT 23
6507: PPUSH
6508: LD_INT 0
6510: PPUSH
6511: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6515: LD_VAR 0 2
6519: PPUSH
6520: LD_INT 85
6522: PPUSH
6523: LD_INT 152
6525: PPUSH
6526: CALL_OW 111
// wait ( 0 0$2 ) ;
6530: LD_INT 70
6532: PPUSH
6533: CALL_OW 67
// end ;
6537: GO 6381
6539: POP
6540: POP
// coords := [ [ 97 , 143 ] ] ;
6541: LD_ADDR_VAR 0 5
6545: PUSH
6546: LD_INT 97
6548: PUSH
6549: LD_INT 143
6551: PUSH
6552: EMPTY
6553: LIST
6554: LIST
6555: PUSH
6556: EMPTY
6557: LIST
6558: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 5 ] , coords , flags ) ;
6559: LD_INT 1
6561: PPUSH
6562: LD_VAR 0 3
6566: PUSH
6567: LD_INT 5
6569: ARRAY
6570: PPUSH
6571: LD_VAR 0 5
6575: PPUSH
6576: LD_VAR 0 6
6580: PPUSH
6581: CALL 41246 0 4
// end ; Wait ( 13 13$00 ) ;
6585: LD_INT 27300
6587: PPUSH
6588: CALL_OW 67
// tmp := [ ] ;
6592: LD_ADDR_VAR 0 3
6596: PUSH
6597: EMPTY
6598: ST_TO_ADDR
// w := 1 ;
6599: LD_ADDR_VAR 0 7
6603: PUSH
6604: LD_INT 1
6606: ST_TO_ADDR
// repeat tmp := [ ] ;
6607: LD_ADDR_VAR 0 3
6611: PUSH
6612: EMPTY
6613: ST_TO_ADDR
// if w mod 4 = 0 then
6614: LD_VAR 0 7
6618: PUSH
6619: LD_INT 4
6621: MOD
6622: PUSH
6623: LD_INT 0
6625: EQUAL
6626: IFFALSE 6713
// list := [ [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] else
6628: LD_ADDR_VAR 0 8
6632: PUSH
6633: LD_INT 11
6635: PUSH
6636: LD_INT 1
6638: PUSH
6639: LD_INT 2
6641: PUSH
6642: LD_INT 24
6644: PUSH
6645: EMPTY
6646: LIST
6647: LIST
6648: LIST
6649: LIST
6650: PUSH
6651: LD_INT 11
6653: PUSH
6654: LD_INT 1
6656: PUSH
6657: LD_INT 2
6659: PUSH
6660: LD_INT 24
6662: PUSH
6663: EMPTY
6664: LIST
6665: LIST
6666: LIST
6667: LIST
6668: PUSH
6669: LD_INT 11
6671: PUSH
6672: LD_INT 1
6674: PUSH
6675: LD_INT 2
6677: PUSH
6678: LD_INT 24
6680: PUSH
6681: EMPTY
6682: LIST
6683: LIST
6684: LIST
6685: LIST
6686: PUSH
6687: LD_INT 11
6689: PUSH
6690: LD_INT 1
6692: PUSH
6693: LD_INT 2
6695: PUSH
6696: LD_INT 24
6698: PUSH
6699: EMPTY
6700: LIST
6701: LIST
6702: LIST
6703: LIST
6704: PUSH
6705: EMPTY
6706: LIST
6707: LIST
6708: LIST
6709: LIST
6710: ST_TO_ADDR
6711: GO 6815
// list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] ;
6713: LD_ADDR_VAR 0 8
6717: PUSH
6718: LD_INT 14
6720: PUSH
6721: LD_INT 1
6723: PUSH
6724: LD_INT 2
6726: PUSH
6727: LD_INT 28
6729: PUSH
6730: EMPTY
6731: LIST
6732: LIST
6733: LIST
6734: LIST
6735: PUSH
6736: LD_INT 14
6738: PUSH
6739: LD_INT 1
6741: PUSH
6742: LD_INT 2
6744: PUSH
6745: LD_INT 25
6747: PUSH
6748: EMPTY
6749: LIST
6750: LIST
6751: LIST
6752: LIST
6753: PUSH
6754: LD_INT 14
6756: PUSH
6757: LD_INT 1
6759: PUSH
6760: LD_INT 2
6762: PUSH
6763: LD_INT 28
6765: PUSH
6766: EMPTY
6767: LIST
6768: LIST
6769: LIST
6770: LIST
6771: PUSH
6772: LD_INT 14
6774: PUSH
6775: LD_INT 1
6777: PUSH
6778: LD_INT 2
6780: PUSH
6781: LD_INT 29
6783: PUSH
6784: EMPTY
6785: LIST
6786: LIST
6787: LIST
6788: LIST
6789: PUSH
6790: LD_INT 11
6792: PUSH
6793: LD_INT 1
6795: PUSH
6796: LD_INT 2
6798: PUSH
6799: LD_INT 24
6801: PUSH
6802: EMPTY
6803: LIST
6804: LIST
6805: LIST
6806: LIST
6807: PUSH
6808: EMPTY
6809: LIST
6810: LIST
6811: LIST
6812: LIST
6813: LIST
6814: ST_TO_ADDR
// if w mod 3 = 0 then
6815: LD_VAR 0 7
6819: PUSH
6820: LD_INT 3
6822: MOD
6823: PUSH
6824: LD_INT 0
6826: EQUAL
6827: IFFALSE 6903
// list := ReplaceIn ( list , [ 1 , list [ i ] + 1 ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gatling_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] ] ) ;
6829: LD_ADDR_VAR 0 8
6833: PUSH
6834: LD_VAR 0 8
6838: PPUSH
6839: LD_INT 1
6841: PUSH
6842: LD_VAR 0 8
6846: PUSH
6847: LD_VAR 0 1
6851: ARRAY
6852: PUSH
6853: LD_INT 1
6855: PLUS
6856: PUSH
6857: EMPTY
6858: LIST
6859: LIST
6860: PPUSH
6861: LD_INT 14
6863: PUSH
6864: LD_INT 1
6866: PUSH
6867: LD_INT 2
6869: PUSH
6870: LD_INT 25
6872: PUSH
6873: LD_INT 28
6875: PUSH
6876: EMPTY
6877: LIST
6878: LIST
6879: PUSH
6880: LD_INT 1
6882: PPUSH
6883: LD_INT 2
6885: PPUSH
6886: CALL_OW 12
6890: ARRAY
6891: PUSH
6892: EMPTY
6893: LIST
6894: LIST
6895: LIST
6896: LIST
6897: PPUSH
6898: CALL 52351 0 3
6902: ST_TO_ADDR
// MC_SetProduceList ( 1 , list ) ;
6903: LD_INT 1
6905: PPUSH
6906: LD_VAR 0 8
6910: PPUSH
6911: CALL 41013 0 2
// if GetSide ( ar_dep_w ) = 2 then
6915: LD_INT 45
6917: PPUSH
6918: CALL_OW 255
6922: PUSH
6923: LD_INT 2
6925: EQUAL
6926: IFFALSE 7011
// begin list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] ] ;
6928: LD_ADDR_VAR 0 8
6932: PUSH
6933: LD_INT 14
6935: PUSH
6936: LD_INT 1
6938: PUSH
6939: LD_INT 2
6941: PUSH
6942: LD_INT 28
6944: PUSH
6945: EMPTY
6946: LIST
6947: LIST
6948: LIST
6949: LIST
6950: PUSH
6951: LD_INT 14
6953: PUSH
6954: LD_INT 1
6956: PUSH
6957: LD_INT 2
6959: PUSH
6960: LD_INT 27
6962: PUSH
6963: EMPTY
6964: LIST
6965: LIST
6966: LIST
6967: LIST
6968: PUSH
6969: LD_INT 14
6971: PUSH
6972: LD_INT 1
6974: PUSH
6975: LD_INT 2
6977: PUSH
6978: LD_INT 27
6980: PUSH
6981: EMPTY
6982: LIST
6983: LIST
6984: LIST
6985: LIST
6986: PUSH
6987: EMPTY
6988: LIST
6989: LIST
6990: LIST
6991: ST_TO_ADDR
// MC_SetProduceList ( 2 , list ) ;
6992: LD_INT 2
6994: PPUSH
6995: LD_VAR 0 8
6999: PPUSH
7000: CALL 41013 0 2
// wait ( 0 0$50 ) ;
7004: LD_INT 1750
7006: PPUSH
7007: CALL_OW 67
// end ; repeat wait ( 0 0$1 ) ;
7011: LD_INT 35
7013: PPUSH
7014: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_weapon , ar_cargo_bay ] ] ) >= 4 ;
7018: LD_EXP 69
7022: PUSH
7023: LD_INT 1
7025: ARRAY
7026: PPUSH
7027: LD_INT 3
7029: PUSH
7030: LD_INT 34
7032: PUSH
7033: LD_INT 32
7035: PUSH
7036: EMPTY
7037: LIST
7038: LIST
7039: PUSH
7040: EMPTY
7041: LIST
7042: LIST
7043: PPUSH
7044: CALL_OW 72
7048: PUSH
7049: LD_INT 4
7051: GREATEREQUAL
7052: IFFALSE 7011
// wait ( 0 0$10 ) ;
7054: LD_INT 350
7056: PPUSH
7057: CALL_OW 67
// tmp := UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_weapon , ar_cargo_bay ] ] ) ;
7061: LD_ADDR_VAR 0 3
7065: PUSH
7066: LD_EXP 69
7070: PUSH
7071: LD_INT 1
7073: ARRAY
7074: PPUSH
7075: LD_INT 3
7077: PUSH
7078: LD_INT 34
7080: PUSH
7081: LD_INT 32
7083: PUSH
7084: EMPTY
7085: LIST
7086: LIST
7087: PUSH
7088: EMPTY
7089: LIST
7090: LIST
7091: PPUSH
7092: CALL_OW 72
7096: ST_TO_ADDR
// if Prob ( 100 ) < 50 then
7097: LD_INT 100
7099: PPUSH
7100: CALL_OW 13
7104: PUSH
7105: LD_INT 50
7107: LESS
7108: IFFALSE 7141
// coords := [ [ 55 , 7 ] , [ 75 , 90 ] ] else
7110: LD_ADDR_VAR 0 5
7114: PUSH
7115: LD_INT 55
7117: PUSH
7118: LD_INT 7
7120: PUSH
7121: EMPTY
7122: LIST
7123: LIST
7124: PUSH
7125: LD_INT 75
7127: PUSH
7128: LD_INT 90
7130: PUSH
7131: EMPTY
7132: LIST
7133: LIST
7134: PUSH
7135: EMPTY
7136: LIST
7137: LIST
7138: ST_TO_ADDR
7139: GO 7170
// coords := [ [ 128 , 94 ] , [ 180 , 135 ] ] ;
7141: LD_ADDR_VAR 0 5
7145: PUSH
7146: LD_INT 128
7148: PUSH
7149: LD_INT 94
7151: PUSH
7152: EMPTY
7153: LIST
7154: LIST
7155: PUSH
7156: LD_INT 180
7158: PUSH
7159: LD_INT 135
7161: PUSH
7162: EMPTY
7163: LIST
7164: LIST
7165: PUSH
7166: EMPTY
7167: LIST
7168: LIST
7169: ST_TO_ADDR
// if w mod 4 = 0 then
7170: LD_VAR 0 7
7174: PUSH
7175: LD_INT 4
7177: MOD
7178: PUSH
7179: LD_INT 0
7181: EQUAL
7182: IFFALSE 7213
// coords := [ [ 91 , 58 ] , [ 117 , 107 ] ] ;
7184: LD_ADDR_VAR 0 5
7188: PUSH
7189: LD_INT 91
7191: PUSH
7192: LD_INT 58
7194: PUSH
7195: EMPTY
7196: LIST
7197: LIST
7198: PUSH
7199: LD_INT 117
7201: PUSH
7202: LD_INT 107
7204: PUSH
7205: EMPTY
7206: LIST
7207: LIST
7208: PUSH
7209: EMPTY
7210: LIST
7211: LIST
7212: ST_TO_ADDR
// ComAgressiveMove ( tmp , coords [ 1 ] , coords [ 2 ] ) ;
7213: LD_VAR 0 3
7217: PPUSH
7218: LD_VAR 0 5
7222: PUSH
7223: LD_INT 1
7225: ARRAY
7226: PPUSH
7227: LD_VAR 0 5
7231: PUSH
7232: LD_INT 2
7234: ARRAY
7235: PPUSH
7236: CALL_OW 114
// repeat wait ( 0 0$1 ) ;
7240: LD_INT 35
7242: PPUSH
7243: CALL_OW 67
// until UnitFilter ( tmp , [ f_hastask ] ) = 0 ;
7247: LD_VAR 0 3
7251: PPUSH
7252: LD_INT 60
7254: PUSH
7255: EMPTY
7256: LIST
7257: PPUSH
7258: CALL_OW 72
7262: PUSH
7263: LD_INT 0
7265: EQUAL
7266: IFFALSE 7240
// repeat wait ( 0 0$2 ) ;
7268: LD_INT 70
7270: PPUSH
7271: CALL_OW 67
// for i in tmp do
7275: LD_ADDR_VAR 0 1
7279: PUSH
7280: LD_VAR 0 3
7284: PUSH
7285: FOR_IN
7286: IFFALSE 7375
// if GetChassis ( i ) = ar_hovercraft then
7288: LD_VAR 0 1
7292: PPUSH
7293: CALL_OW 265
7297: PUSH
7298: LD_INT 11
7300: EQUAL
7301: IFFALSE 7339
// AttackHovercraft ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) else
7303: LD_VAR 0 1
7307: PPUSH
7308: LD_INT 22
7310: PUSH
7311: LD_INT 1
7313: PUSH
7314: EMPTY
7315: LIST
7316: LIST
7317: PPUSH
7318: CALL_OW 69
7322: PPUSH
7323: LD_VAR 0 1
7327: PPUSH
7328: CALL_OW 74
7332: PPUSH
7333: CALL 79539 0 2
7337: GO 7373
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
7339: LD_VAR 0 1
7343: PPUSH
7344: LD_INT 22
7346: PUSH
7347: LD_INT 1
7349: PUSH
7350: EMPTY
7351: LIST
7352: LIST
7353: PPUSH
7354: CALL_OW 69
7358: PPUSH
7359: LD_VAR 0 1
7363: PPUSH
7364: CALL_OW 74
7368: PPUSH
7369: CALL_OW 115
7373: GO 7285
7375: POP
7376: POP
// until not tmp ;
7377: LD_VAR 0 3
7381: NOT
7382: IFFALSE 7268
// wait ( rand ( 10 10$30 , 13 13$30 ) ) ;
7384: LD_INT 22050
7386: PPUSH
7387: LD_INT 28350
7389: PPUSH
7390: CALL_OW 12
7394: PPUSH
7395: CALL_OW 67
// w := w + 1 ;
7399: LD_ADDR_VAR 0 7
7403: PUSH
7404: LD_VAR 0 7
7408: PUSH
7409: LD_INT 1
7411: PLUS
7412: ST_TO_ADDR
// until IsDead ( ar_dep_n ) or not UnitFilter ( mc_bases [ 1 ] , [ f_btype , b_factory ] ) ;
7413: LD_INT 94
7415: PPUSH
7416: CALL_OW 301
7420: PUSH
7421: LD_EXP 50
7425: PUSH
7426: LD_INT 1
7428: ARRAY
7429: PPUSH
7430: LD_INT 30
7432: PUSH
7433: LD_INT 3
7435: PUSH
7436: EMPTY
7437: LIST
7438: LIST
7439: PPUSH
7440: CALL_OW 72
7444: NOT
7445: OR
7446: IFFALSE 6607
// end ;
7448: PPOPN 8
7450: END
// every 28 28$00 trigger ar_dep_e do var i , tmp , un , x ;
7451: LD_INT 204
7453: IFFALSE 7919
7455: GO 7457
7457: DISABLE
7458: LD_INT 0
7460: PPUSH
7461: PPUSH
7462: PPUSH
7463: PPUSH
// begin enable ;
7464: ENABLE
// wait ( rand ( 0 0$1 , 0 0$34 ) ) ;
7465: LD_INT 35
7467: PPUSH
7468: LD_INT 1190
7470: PPUSH
7471: CALL_OW 12
7475: PPUSH
7476: CALL_OW 67
// tmp := [ ] ;
7480: LD_ADDR_VAR 0 2
7484: PUSH
7485: EMPTY
7486: ST_TO_ADDR
// uc_side := 8 ;
7487: LD_ADDR_OWVAR 20
7491: PUSH
7492: LD_INT 8
7494: ST_TO_ADDR
// uc_nation := 2 ;
7495: LD_ADDR_OWVAR 21
7499: PUSH
7500: LD_INT 2
7502: ST_TO_ADDR
// InitHc ;
7503: CALL_OW 19
// for i = 1 to 3 do
7507: LD_ADDR_VAR 0 1
7511: PUSH
7512: DOUBLE
7513: LD_INT 1
7515: DEC
7516: ST_TO_ADDR
7517: LD_INT 3
7519: PUSH
7520: FOR_TO
7521: IFFALSE 7648
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
7523: LD_INT 13
7525: PUSH
7526: LD_INT 14
7528: PUSH
7529: EMPTY
7530: LIST
7531: LIST
7532: PUSH
7533: LD_INT 1
7535: PPUSH
7536: LD_INT 2
7538: PPUSH
7539: CALL_OW 12
7543: ARRAY
7544: PPUSH
7545: LD_INT 3
7547: PPUSH
7548: LD_INT 5
7550: PPUSH
7551: LD_INT 27
7553: PUSH
7554: LD_INT 28
7556: PUSH
7557: EMPTY
7558: LIST
7559: LIST
7560: PUSH
7561: LD_INT 1
7563: PPUSH
7564: LD_INT 2
7566: PPUSH
7567: CALL_OW 12
7571: ARRAY
7572: PPUSH
7573: LD_INT 100
7575: PPUSH
7576: CALL 52229 0 5
// un := CreateVehicle ;
7580: LD_ADDR_VAR 0 3
7584: PUSH
7585: CALL_OW 45
7589: ST_TO_ADDR
// SetDir ( un , 4 ) ;
7590: LD_VAR 0 3
7594: PPUSH
7595: LD_INT 4
7597: PPUSH
7598: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
7602: LD_VAR 0 3
7606: PPUSH
7607: LD_INT 15
7609: PPUSH
7610: LD_INT 0
7612: PPUSH
7613: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
7617: LD_ADDR_VAR 0 2
7621: PUSH
7622: LD_VAR 0 2
7626: PPUSH
7627: LD_VAR 0 2
7631: PUSH
7632: LD_INT 1
7634: PLUS
7635: PPUSH
7636: LD_VAR 0 3
7640: PPUSH
7641: CALL_OW 1
7645: ST_TO_ADDR
// end ;
7646: GO 7520
7648: POP
7649: POP
// for i = 1 to 4 do
7650: LD_ADDR_VAR 0 1
7654: PUSH
7655: DOUBLE
7656: LD_INT 1
7658: DEC
7659: ST_TO_ADDR
7660: LD_INT 4
7662: PUSH
7663: FOR_TO
7664: IFFALSE 7735
// begin PrepareHuman ( false , 1 , 6 ) ;
7666: LD_INT 0
7668: PPUSH
7669: LD_INT 1
7671: PPUSH
7672: LD_INT 6
7674: PPUSH
7675: CALL_OW 380
// un := CreateHuman ;
7679: LD_ADDR_VAR 0 3
7683: PUSH
7684: CALL_OW 44
7688: ST_TO_ADDR
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
7689: LD_VAR 0 3
7693: PPUSH
7694: LD_INT 15
7696: PPUSH
7697: LD_INT 0
7699: PPUSH
7700: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
7704: LD_ADDR_VAR 0 2
7708: PUSH
7709: LD_VAR 0 2
7713: PPUSH
7714: LD_VAR 0 2
7718: PUSH
7719: LD_INT 1
7721: PLUS
7722: PPUSH
7723: LD_VAR 0 3
7727: PPUSH
7728: CALL_OW 1
7732: ST_TO_ADDR
// end ;
7733: GO 7663
7735: POP
7736: POP
// wait ( 0 0$3 ) ;
7737: LD_INT 105
7739: PPUSH
7740: CALL_OW 67
// for i in tmp do
7744: LD_ADDR_VAR 0 1
7748: PUSH
7749: LD_VAR 0 2
7753: PUSH
7754: FOR_IN
7755: IFFALSE 7823
// if GetClass ( i ) = 1 or GetType ( i ) = unit_vehicle then
7757: LD_VAR 0 1
7761: PPUSH
7762: CALL_OW 257
7766: PUSH
7767: LD_INT 1
7769: EQUAL
7770: PUSH
7771: LD_VAR 0 1
7775: PPUSH
7776: CALL_OW 247
7780: PUSH
7781: LD_INT 2
7783: EQUAL
7784: OR
7785: IFFALSE 7821
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
7787: LD_VAR 0 1
7791: PPUSH
7792: LD_INT 81
7794: PUSH
7795: LD_INT 8
7797: PUSH
7798: EMPTY
7799: LIST
7800: LIST
7801: PPUSH
7802: CALL_OW 69
7806: PPUSH
7807: LD_VAR 0 1
7811: PPUSH
7812: CALL_OW 74
7816: PPUSH
7817: CALL_OW 115
7821: GO 7754
7823: POP
7824: POP
// repeat AddComAgressiveMove ( tmp , 210 , 178 ) ;
7825: LD_VAR 0 2
7829: PPUSH
7830: LD_INT 210
7832: PPUSH
7833: LD_INT 178
7835: PPUSH
7836: CALL_OW 174
// x := FilterUnitsInArea ( escape_area , [ f_side , 8 ] ) ;
7840: LD_ADDR_VAR 0 4
7844: PUSH
7845: LD_INT 10
7847: PPUSH
7848: LD_INT 22
7850: PUSH
7851: LD_INT 8
7853: PUSH
7854: EMPTY
7855: LIST
7856: LIST
7857: PPUSH
7858: CALL_OW 70
7862: ST_TO_ADDR
// if x then
7863: LD_VAR 0 4
7867: IFFALSE 7895
// for i in x do
7869: LD_ADDR_VAR 0 1
7873: PUSH
7874: LD_VAR 0 4
7878: PUSH
7879: FOR_IN
7880: IFFALSE 7893
// RemoveUnit ( i ) ;
7882: LD_VAR 0 1
7886: PPUSH
7887: CALL_OW 64
7891: GO 7879
7893: POP
7894: POP
// wait ( 0 0$1 ) ;
7895: LD_INT 35
7897: PPUSH
7898: CALL_OW 67
// until not FilterAllUnits ( [ f_side , 8 ] ) ;
7902: LD_INT 22
7904: PUSH
7905: LD_INT 8
7907: PUSH
7908: EMPTY
7909: LIST
7910: LIST
7911: PPUSH
7912: CALL_OW 69
7916: NOT
7917: IFFALSE 7825
// end ;
7919: PPOPN 4
7921: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
7922: LD_INT 22
7924: PUSH
7925: LD_INT 2
7927: PUSH
7928: EMPTY
7929: LIST
7930: LIST
7931: PUSH
7932: LD_INT 34
7934: PUSH
7935: LD_INT 31
7937: PUSH
7938: EMPTY
7939: LIST
7940: LIST
7941: PUSH
7942: LD_INT 3
7944: PUSH
7945: LD_INT 24
7947: PUSH
7948: LD_INT 1000
7950: PUSH
7951: EMPTY
7952: LIST
7953: LIST
7954: PUSH
7955: EMPTY
7956: LIST
7957: LIST
7958: PUSH
7959: EMPTY
7960: LIST
7961: LIST
7962: LIST
7963: PPUSH
7964: CALL_OW 69
7968: IFFALSE 8071
7970: GO 7972
7972: DISABLE
// begin if IsOk ( ar_dep_w ) and GetSide ( ar_dep_w ) then
7973: LD_INT 45
7975: PPUSH
7976: CALL_OW 302
7980: PUSH
7981: LD_INT 45
7983: PPUSH
7984: CALL_OW 255
7988: AND
7989: IFFALSE 8032
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 18 , 8 ) else
7991: LD_INT 22
7993: PUSH
7994: LD_INT 2
7996: PUSH
7997: EMPTY
7998: LIST
7999: LIST
8000: PUSH
8001: LD_INT 34
8003: PUSH
8004: LD_INT 31
8006: PUSH
8007: EMPTY
8008: LIST
8009: LIST
8010: PUSH
8011: EMPTY
8012: LIST
8013: LIST
8014: PPUSH
8015: CALL_OW 69
8019: PPUSH
8020: LD_INT 18
8022: PPUSH
8023: LD_INT 8
8025: PPUSH
8026: CALL_OW 111
8030: GO 8071
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 106 , 14 ) ;
8032: LD_INT 22
8034: PUSH
8035: LD_INT 2
8037: PUSH
8038: EMPTY
8039: LIST
8040: LIST
8041: PUSH
8042: LD_INT 34
8044: PUSH
8045: LD_INT 31
8047: PUSH
8048: EMPTY
8049: LIST
8050: LIST
8051: PUSH
8052: EMPTY
8053: LIST
8054: LIST
8055: PPUSH
8056: CALL_OW 69
8060: PPUSH
8061: LD_INT 106
8063: PPUSH
8064: LD_INT 14
8066: PPUSH
8067: CALL_OW 111
// end ; end_of_file
8071: END
// export function Action ; var tmp , p , radar , sols , i ; begin
8072: LD_INT 0
8074: PPUSH
8075: PPUSH
8076: PPUSH
8077: PPUSH
8078: PPUSH
8079: PPUSH
// InGameOn ;
8080: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
8084: LD_EXP 21
8088: PPUSH
8089: CALL_OW 87
// SetAttitude ( 2 , 1 , att_friend , true ) ;
8093: LD_INT 2
8095: PPUSH
8096: LD_INT 1
8098: PPUSH
8099: LD_INT 1
8101: PPUSH
8102: LD_INT 1
8104: PPUSH
8105: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) ;
8109: LD_ADDR_VAR 0 2
8113: PUSH
8114: LD_INT 22
8116: PUSH
8117: LD_INT 1
8119: PUSH
8120: EMPTY
8121: LIST
8122: LIST
8123: PUSH
8124: LD_INT 25
8126: PUSH
8127: LD_INT 1
8129: PUSH
8130: EMPTY
8131: LIST
8132: LIST
8133: PUSH
8134: EMPTY
8135: LIST
8136: LIST
8137: PPUSH
8138: CALL_OW 69
8142: ST_TO_ADDR
// radar := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_radar ] ] ) [ 1 ] ;
8143: LD_ADDR_VAR 0 4
8147: PUSH
8148: LD_INT 22
8150: PUSH
8151: LD_INT 1
8153: PUSH
8154: EMPTY
8155: LIST
8156: LIST
8157: PUSH
8158: LD_INT 34
8160: PUSH
8161: LD_INT 11
8163: PUSH
8164: EMPTY
8165: LIST
8166: LIST
8167: PUSH
8168: EMPTY
8169: LIST
8170: LIST
8171: PPUSH
8172: CALL_OW 69
8176: PUSH
8177: LD_INT 1
8179: ARRAY
8180: ST_TO_ADDR
// for i = 1 to tmp do
8181: LD_ADDR_VAR 0 6
8185: PUSH
8186: DOUBLE
8187: LD_INT 1
8189: DEC
8190: ST_TO_ADDR
8191: LD_VAR 0 2
8195: PUSH
8196: FOR_TO
8197: IFFALSE 8244
// begin if i = 5 then
8199: LD_VAR 0 6
8203: PUSH
8204: LD_INT 5
8206: EQUAL
8207: IFFALSE 8211
// break ;
8209: GO 8244
// sols := Replace ( sols , i , tmp [ i ] ) ;
8211: LD_ADDR_VAR 0 5
8215: PUSH
8216: LD_VAR 0 5
8220: PPUSH
8221: LD_VAR 0 6
8225: PPUSH
8226: LD_VAR 0 2
8230: PUSH
8231: LD_VAR 0 6
8235: ARRAY
8236: PPUSH
8237: CALL_OW 1
8241: ST_TO_ADDR
// end ;
8242: GO 8196
8244: POP
8245: POP
// tmp := ar_force_tmp ;
8246: LD_ADDR_VAR 0 2
8250: PUSH
8251: LD_EXP 40
8255: ST_TO_ADDR
// PlaceUnitXY ( tmp [ 1 ] , 108 , 139 , false ) ;
8256: LD_VAR 0 2
8260: PUSH
8261: LD_INT 1
8263: ARRAY
8264: PPUSH
8265: LD_INT 108
8267: PPUSH
8268: LD_INT 139
8270: PPUSH
8271: LD_INT 0
8273: PPUSH
8274: CALL_OW 48
// ComTurnUnit ( tmp [ 1 ] , JMM ) ;
8278: LD_VAR 0 2
8282: PUSH
8283: LD_INT 1
8285: ARRAY
8286: PPUSH
8287: LD_EXP 21
8291: PPUSH
8292: CALL_OW 119
// PlaceUnitXY ( tmp [ 2 ] , 114 , 132 , false ) ;
8296: LD_VAR 0 2
8300: PUSH
8301: LD_INT 2
8303: ARRAY
8304: PPUSH
8305: LD_INT 114
8307: PPUSH
8308: LD_INT 132
8310: PPUSH
8311: LD_INT 0
8313: PPUSH
8314: CALL_OW 48
// PlaceUnitXY ( tmp [ 3 ] , 115 , 132 , false ) ;
8318: LD_VAR 0 2
8322: PUSH
8323: LD_INT 3
8325: ARRAY
8326: PPUSH
8327: LD_INT 115
8329: PPUSH
8330: LD_INT 132
8332: PPUSH
8333: LD_INT 0
8335: PPUSH
8336: CALL_OW 48
// ComHold ( [ tmp [ 2 ] , tmp [ 3 ] ] ) ;
8340: LD_VAR 0 2
8344: PUSH
8345: LD_INT 2
8347: ARRAY
8348: PUSH
8349: LD_VAR 0 2
8353: PUSH
8354: LD_INT 3
8356: ARRAY
8357: PUSH
8358: EMPTY
8359: LIST
8360: LIST
8361: PPUSH
8362: CALL_OW 140
// ComMoveXY ( radar , 83 , 123 ) ;
8366: LD_VAR 0 4
8370: PPUSH
8371: LD_INT 83
8373: PPUSH
8374: LD_INT 123
8376: PPUSH
8377: CALL_OW 111
// Wait ( 0 0$01 ) ;
8381: LD_INT 35
8383: PPUSH
8384: CALL_OW 67
// CenterOnXY ( 90 , 144 ) ;
8388: LD_INT 90
8390: PPUSH
8391: LD_INT 144
8393: PPUSH
8394: CALL_OW 84
// ComMoveXY ( sols , 88 , 129 ) ;
8398: LD_VAR 0 5
8402: PPUSH
8403: LD_INT 88
8405: PPUSH
8406: LD_INT 129
8408: PPUSH
8409: CALL_OW 111
// p := [ [ 92 , 131 ] , [ 88 , 127 ] , [ 91 , 132 ] , [ 92 , 134 ] ] ;
8413: LD_ADDR_VAR 0 3
8417: PUSH
8418: LD_INT 92
8420: PUSH
8421: LD_INT 131
8423: PUSH
8424: EMPTY
8425: LIST
8426: LIST
8427: PUSH
8428: LD_INT 88
8430: PUSH
8431: LD_INT 127
8433: PUSH
8434: EMPTY
8435: LIST
8436: LIST
8437: PUSH
8438: LD_INT 91
8440: PUSH
8441: LD_INT 132
8443: PUSH
8444: EMPTY
8445: LIST
8446: LIST
8447: PUSH
8448: LD_INT 92
8450: PUSH
8451: LD_INT 134
8453: PUSH
8454: EMPTY
8455: LIST
8456: LIST
8457: PUSH
8458: EMPTY
8459: LIST
8460: LIST
8461: LIST
8462: LIST
8463: ST_TO_ADDR
// for i = 1 to sols do
8464: LD_ADDR_VAR 0 6
8468: PUSH
8469: DOUBLE
8470: LD_INT 1
8472: DEC
8473: ST_TO_ADDR
8474: LD_VAR 0 5
8478: PUSH
8479: FOR_TO
8480: IFFALSE 8553
// begin AddComMoveXY ( sols [ i ] , p [ i ] [ 1 ] , p [ i ] [ 2 ] ) ;
8482: LD_VAR 0 5
8486: PUSH
8487: LD_VAR 0 6
8491: ARRAY
8492: PPUSH
8493: LD_VAR 0 3
8497: PUSH
8498: LD_VAR 0 6
8502: ARRAY
8503: PUSH
8504: LD_INT 1
8506: ARRAY
8507: PPUSH
8508: LD_VAR 0 3
8512: PUSH
8513: LD_VAR 0 6
8517: ARRAY
8518: PUSH
8519: LD_INT 2
8521: ARRAY
8522: PPUSH
8523: CALL_OW 171
// AddComCrawl ( sols [ i ] ) ;
8527: LD_VAR 0 5
8531: PUSH
8532: LD_VAR 0 6
8536: ARRAY
8537: PPUSH
8538: CALL_OW 197
// AddComHold ( sols ) ;
8542: LD_VAR 0 5
8546: PPUSH
8547: CALL_OW 200
// end ;
8551: GO 8479
8553: POP
8554: POP
// repeat wait ( 0 0$1 ) ;
8555: LD_INT 35
8557: PPUSH
8558: CALL_OW 67
// until GetDistUnitXY ( sols [ 1 ] , 92 , 131 ) < 4 ;
8562: LD_VAR 0 5
8566: PUSH
8567: LD_INT 1
8569: ARRAY
8570: PPUSH
8571: LD_INT 92
8573: PPUSH
8574: LD_INT 131
8576: PPUSH
8577: CALL_OW 297
8581: PUSH
8582: LD_INT 4
8584: LESS
8585: IFFALSE 8555
// CenterOnXY ( 96 , 139 ) ;
8587: LD_INT 96
8589: PPUSH
8590: LD_INT 139
8592: PPUSH
8593: CALL_OW 84
// wait ( 0 0$3 ) ;
8597: LD_INT 105
8599: PPUSH
8600: CALL_OW 67
// PlaceSeeing ( 111 , 135 , 1 , - 25 ) ;
8604: LD_INT 111
8606: PPUSH
8607: LD_INT 135
8609: PPUSH
8610: LD_INT 1
8612: PPUSH
8613: LD_INT 25
8615: NEG
8616: PPUSH
8617: CALL_OW 330
// ComMoveXY ( tmp [ 2 ] , GetX ( tmp [ 1 ] ) + 3 , GetY ( tmp [ 1 ] ) ) ;
8621: LD_VAR 0 2
8625: PUSH
8626: LD_INT 2
8628: ARRAY
8629: PPUSH
8630: LD_VAR 0 2
8634: PUSH
8635: LD_INT 1
8637: ARRAY
8638: PPUSH
8639: CALL_OW 250
8643: PUSH
8644: LD_INT 3
8646: PLUS
8647: PPUSH
8648: LD_VAR 0 2
8652: PUSH
8653: LD_INT 1
8655: ARRAY
8656: PPUSH
8657: CALL_OW 251
8661: PPUSH
8662: CALL_OW 111
// ComEnterUnit ( tmp [ 3 ] , ar_dep_s ) ;
8666: LD_VAR 0 2
8670: PUSH
8671: LD_INT 3
8673: ARRAY
8674: PPUSH
8675: LD_INT 7
8677: PPUSH
8678: CALL_OW 120
// AddComTurnUnit ( tmp [ 2 ] , tmp [ 1 ] ) ;
8682: LD_VAR 0 2
8686: PUSH
8687: LD_INT 2
8689: ARRAY
8690: PPUSH
8691: LD_VAR 0 2
8695: PUSH
8696: LD_INT 1
8698: ARRAY
8699: PPUSH
8700: CALL_OW 179
// repeat wait ( 0 0$1 ) ;
8704: LD_INT 35
8706: PPUSH
8707: CALL_OW 67
// until GetDistUnits ( tmp [ 1 ] , tmp [ 2 ] ) < 5 ;
8711: LD_VAR 0 2
8715: PUSH
8716: LD_INT 1
8718: ARRAY
8719: PPUSH
8720: LD_VAR 0 2
8724: PUSH
8725: LD_INT 2
8727: ARRAY
8728: PPUSH
8729: CALL_OW 296
8733: PUSH
8734: LD_INT 5
8736: LESS
8737: IFFALSE 8704
// ComTurnUnit ( tmp [ 1 ] , tmp [ 2 ] ) ;
8739: LD_VAR 0 2
8743: PUSH
8744: LD_INT 1
8746: ARRAY
8747: PPUSH
8748: LD_VAR 0 2
8752: PUSH
8753: LD_INT 2
8755: ARRAY
8756: PPUSH
8757: CALL_OW 119
// Say ( tmp [ 1 ] , D1a-Merc1-1 ) ;
8761: LD_VAR 0 2
8765: PUSH
8766: LD_INT 1
8768: ARRAY
8769: PPUSH
8770: LD_STRING D1a-Merc1-1
8772: PPUSH
8773: CALL_OW 88
// Say ( tmp [ 2 ] , D1a-FMerc2-1 ) ;
8777: LD_VAR 0 2
8781: PUSH
8782: LD_INT 2
8784: ARRAY
8785: PPUSH
8786: LD_STRING D1a-FMerc2-1
8788: PPUSH
8789: CALL_OW 88
// ComHeal ( tmp [ 2 ] , tmp [ 1 ] ) ;
8793: LD_VAR 0 2
8797: PUSH
8798: LD_INT 2
8800: ARRAY
8801: PPUSH
8802: LD_VAR 0 2
8806: PUSH
8807: LD_INT 1
8809: ARRAY
8810: PPUSH
8811: CALL_OW 128
// SetLives ( tmp [ 1 ] , 500 ) ;
8815: LD_VAR 0 2
8819: PUSH
8820: LD_INT 1
8822: ARRAY
8823: PPUSH
8824: LD_INT 500
8826: PPUSH
8827: CALL_OW 234
// wait ( 0 0$2 ) ;
8831: LD_INT 70
8833: PPUSH
8834: CALL_OW 67
// SetLives ( tmp [ 1 ] , 2 ) ;
8838: LD_VAR 0 2
8842: PUSH
8843: LD_INT 1
8845: ARRAY
8846: PPUSH
8847: LD_INT 2
8849: PPUSH
8850: CALL_OW 234
// wait ( 0 0$0.3 ) ;
8854: LD_INT 10
8856: PPUSH
8857: CALL_OW 67
// ForceSay ( tmp [ 1 ] , D1a-Merc1-2 ) ;
8861: LD_VAR 0 2
8865: PUSH
8866: LD_INT 1
8868: ARRAY
8869: PPUSH
8870: LD_STRING D1a-Merc1-2
8872: PPUSH
8873: CALL_OW 91
// wait ( 0 0$0.2 ) ;
8877: LD_INT 7
8879: PPUSH
8880: CALL_OW 67
// KillUnit ( tmp [ 1 ] ) ;
8884: LD_VAR 0 2
8888: PUSH
8889: LD_INT 1
8891: ARRAY
8892: PPUSH
8893: CALL_OW 66
// ComMoveToArea ( tmp [ 2 ] , escape_area ) ;
8897: LD_VAR 0 2
8901: PUSH
8902: LD_INT 2
8904: ARRAY
8905: PPUSH
8906: LD_INT 10
8908: PPUSH
8909: CALL_OW 113
// Say ( tmp [ 2 ] , D1a-FMerc2-2 ) ;
8913: LD_VAR 0 2
8917: PUSH
8918: LD_INT 2
8920: ARRAY
8921: PPUSH
8922: LD_STRING D1a-FMerc2-2
8924: PPUSH
8925: CALL_OW 88
// wait ( 0 0$1 ) ;
8929: LD_INT 35
8931: PPUSH
8932: CALL_OW 67
// CenterOnUnits ( ar_dep_s ) ;
8936: LD_INT 7
8938: PPUSH
8939: CALL_OW 85
// wait ( 0 0$2 ) ;
8943: LD_INT 70
8945: PPUSH
8946: CALL_OW 67
// ForceSay ( Saliba , D1a-Saliba-1 ) ;
8950: LD_EXP 44
8954: PPUSH
8955: LD_STRING D1a-Saliba-1
8957: PPUSH
8958: CALL_OW 91
// KillUnit ( Saliba ) ;
8962: LD_EXP 44
8966: PPUSH
8967: CALL_OW 66
// ComExitBuilding ( tmp [ 3 ] ) ;
8971: LD_VAR 0 2
8975: PUSH
8976: LD_INT 3
8978: ARRAY
8979: PPUSH
8980: CALL_OW 122
// CenterOnUnits ( JMM ) ;
8984: LD_EXP 21
8988: PPUSH
8989: CALL_OW 85
// wait ( 0 0$1 ) ;
8993: LD_INT 35
8995: PPUSH
8996: CALL_OW 67
// ComMoveXY ( sols , 88 , 141 ) ;
9000: LD_VAR 0 5
9004: PPUSH
9005: LD_INT 88
9007: PPUSH
9008: LD_INT 141
9010: PPUSH
9011: CALL_OW 111
// AddComWait ( sols , 0 0$2 ) ;
9015: LD_VAR 0 5
9019: PPUSH
9020: LD_INT 70
9022: PPUSH
9023: CALL_OW 202
// wait ( 0 0$2 ) ;
9027: LD_INT 70
9029: PPUSH
9030: CALL_OW 67
// SetAttitude ( 2 , 1 , att_enemy , true ) ;
9034: LD_INT 2
9036: PPUSH
9037: LD_INT 1
9039: PPUSH
9040: LD_INT 2
9042: PPUSH
9043: LD_INT 1
9045: PPUSH
9046: CALL_OW 80
// InGameOff ;
9050: CALL_OW 9
// ComWalk ( sols ) ;
9054: LD_VAR 0 5
9058: PPUSH
9059: CALL_OW 138
// ChangeMissionObjectives ( M1 ) ;
9063: LD_STRING M1
9065: PPUSH
9066: CALL_OW 337
// game_speed := 4 ;
9070: LD_ADDR_OWVAR 65
9074: PUSH
9075: LD_INT 4
9077: ST_TO_ADDR
// RemoveSeeing ( 111 , 135 , 1 ) ;
9078: LD_INT 111
9080: PPUSH
9081: LD_INT 135
9083: PPUSH
9084: LD_INT 1
9086: PPUSH
9087: CALL_OW 331
// SaveForQuickRestart ;
9091: CALL_OW 22
// ar_run := true ;
9095: LD_ADDR_EXP 5
9099: PUSH
9100: LD_INT 1
9102: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9103: LD_INT 35
9105: PPUSH
9106: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 1 ] , [ f_dist , ar_dep_s , 10 ] ] ) or GetLives ( ar_dep_s ) < 999 ;
9110: LD_INT 22
9112: PUSH
9113: LD_INT 1
9115: PUSH
9116: EMPTY
9117: LIST
9118: LIST
9119: PUSH
9120: LD_INT 91
9122: PUSH
9123: LD_INT 7
9125: PUSH
9126: LD_INT 10
9128: PUSH
9129: EMPTY
9130: LIST
9131: LIST
9132: LIST
9133: PUSH
9134: EMPTY
9135: LIST
9136: LIST
9137: PPUSH
9138: CALL_OW 69
9142: PUSH
9143: LD_INT 7
9145: PPUSH
9146: CALL_OW 256
9150: PUSH
9151: LD_INT 999
9153: LESS
9154: OR
9155: IFFALSE 9103
// if GetSide ( ar_dep_s ) = 2 then
9157: LD_INT 7
9159: PPUSH
9160: CALL_OW 255
9164: PUSH
9165: LD_INT 2
9167: EQUAL
9168: IFFALSE 9180
// SetSide ( ar_dep_s , 1 ) ;
9170: LD_INT 7
9172: PPUSH
9173: LD_INT 1
9175: PPUSH
9176: CALL_OW 235
// end ;
9180: LD_VAR 0 1
9184: RET
// every 0 0$2 trigger ar_run do var i , tmp , k ;
9185: LD_EXP 5
9189: IFFALSE 9549
9191: GO 9193
9193: DISABLE
9194: LD_INT 0
9196: PPUSH
9197: PPUSH
9198: PPUSH
// begin tmp := ar_force_tmp ^ UnitFilter ( ar_force_south , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ) ;
9199: LD_ADDR_VAR 0 2
9203: PUSH
9204: LD_EXP 40
9208: PUSH
9209: LD_EXP 36
9213: PPUSH
9214: LD_INT 2
9216: PUSH
9217: LD_INT 21
9219: PUSH
9220: LD_INT 2
9222: PUSH
9223: EMPTY
9224: LIST
9225: LIST
9226: PUSH
9227: LD_INT 21
9229: PUSH
9230: LD_INT 1
9232: PUSH
9233: EMPTY
9234: LIST
9235: LIST
9236: PUSH
9237: EMPTY
9238: LIST
9239: LIST
9240: LIST
9241: PPUSH
9242: CALL_OW 72
9246: ADD
9247: ST_TO_ADDR
// SetSide ( tmp , 5 ) ;
9248: LD_VAR 0 2
9252: PPUSH
9253: LD_INT 5
9255: PPUSH
9256: CALL_OW 235
// ChangeSideFog ( 5 , 1 ) ;
9260: LD_INT 5
9262: PPUSH
9263: LD_INT 1
9265: PPUSH
9266: CALL_OW 343
// k := 1 ;
9270: LD_ADDR_VAR 0 3
9274: PUSH
9275: LD_INT 1
9277: ST_TO_ADDR
// for i in tmp do
9278: LD_ADDR_VAR 0 1
9282: PUSH
9283: LD_VAR 0 2
9287: PUSH
9288: FOR_IN
9289: IFFALSE 9374
// begin if IsInUnit ( i ) then
9291: LD_VAR 0 1
9295: PPUSH
9296: CALL_OW 310
9300: IFFALSE 9311
// ComExitBuilding ( i ) ;
9302: LD_VAR 0 1
9306: PPUSH
9307: CALL_OW 122
// if GetClass ( i ) = 3 then
9311: LD_VAR 0 1
9315: PPUSH
9316: CALL_OW 257
9320: PUSH
9321: LD_INT 3
9323: EQUAL
9324: IFFALSE 9360
// begin AddComEnterUnit ( i , ar_vehicles_tmp [ k ] ) ;
9326: LD_VAR 0 1
9330: PPUSH
9331: LD_EXP 41
9335: PUSH
9336: LD_VAR 0 3
9340: ARRAY
9341: PPUSH
9342: CALL_OW 180
// k := k + 1 ;
9346: LD_ADDR_VAR 0 3
9350: PUSH
9351: LD_VAR 0 3
9355: PUSH
9356: LD_INT 1
9358: PLUS
9359: ST_TO_ADDR
// end ; AddComMoveToArea ( i , escape_area ) ;
9360: LD_VAR 0 1
9364: PPUSH
9365: LD_INT 10
9367: PPUSH
9368: CALL_OW 173
// end ;
9372: GO 9288
9374: POP
9375: POP
// ar_patrol := true ;
9376: LD_ADDR_EXP 7
9380: PUSH
9381: LD_INT 1
9383: ST_TO_ADDR
// repeat wait ( 0 0$0.3 ) ;
9384: LD_INT 10
9386: PPUSH
9387: CALL_OW 67
// for i in tmp do
9391: LD_ADDR_VAR 0 1
9395: PUSH
9396: LD_VAR 0 2
9400: PUSH
9401: FOR_IN
9402: IFFALSE 9430
// if not HasTask ( i ) then
9404: LD_VAR 0 1
9408: PPUSH
9409: CALL_OW 314
9413: NOT
9414: IFFALSE 9428
// ComMoveToArea ( i , escape_area ) ;
9416: LD_VAR 0 1
9420: PPUSH
9421: LD_INT 10
9423: PPUSH
9424: CALL_OW 113
9428: GO 9401
9430: POP
9431: POP
// k := UnitFilter ( tmp , [ f_inarea , escape_area ] ) ;
9432: LD_ADDR_VAR 0 3
9436: PUSH
9437: LD_VAR 0 2
9441: PPUSH
9442: LD_INT 95
9444: PUSH
9445: LD_INT 10
9447: PUSH
9448: EMPTY
9449: LIST
9450: LIST
9451: PPUSH
9452: CALL_OW 72
9456: ST_TO_ADDR
// if k then
9457: LD_VAR 0 3
9461: IFFALSE 9530
// for i in k do
9463: LD_ADDR_VAR 0 1
9467: PUSH
9468: LD_VAR 0 3
9472: PUSH
9473: FOR_IN
9474: IFFALSE 9528
// begin if IsInUnit ( i ) then
9476: LD_VAR 0 1
9480: PPUSH
9481: CALL_OW 310
9485: IFFALSE 9501
// RemoveUnit ( IsInUnit ( i ) ) ;
9487: LD_VAR 0 1
9491: PPUSH
9492: CALL_OW 310
9496: PPUSH
9497: CALL_OW 64
// RemoveUnit ( i ) ;
9501: LD_VAR 0 1
9505: PPUSH
9506: CALL_OW 64
// tmp := tmp diff i ;
9510: LD_ADDR_VAR 0 2
9514: PUSH
9515: LD_VAR 0 2
9519: PUSH
9520: LD_VAR 0 1
9524: DIFF
9525: ST_TO_ADDR
// end ;
9526: GO 9473
9528: POP
9529: POP
// until tmp = [ ] ;
9530: LD_VAR 0 2
9534: PUSH
9535: EMPTY
9536: EQUAL
9537: IFFALSE 9384
// ChangeSideFog ( 5 , 5 ) ;
9539: LD_INT 5
9541: PPUSH
9542: LD_INT 5
9544: PPUSH
9545: CALL_OW 343
// end ;
9549: PPOPN 3
9551: END
// every 0 0$03 trigger ar_patrol do var i , un , veh ;
9552: LD_EXP 7
9556: IFFALSE 9846
9558: GO 9560
9560: DISABLE
9561: LD_INT 0
9563: PPUSH
9564: PPUSH
9565: PPUSH
// begin uc_side := 2 ;
9566: LD_ADDR_OWVAR 20
9570: PUSH
9571: LD_INT 2
9573: ST_TO_ADDR
// uc_nation := 2 ;
9574: LD_ADDR_OWVAR 21
9578: PUSH
9579: LD_INT 2
9581: ST_TO_ADDR
// InitHc ;
9582: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
9586: LD_INT 1
9588: PPUSH
9589: LD_INT 1
9591: PPUSH
9592: LD_INT 6
9594: PPUSH
9595: CALL_OW 380
// un := CreateHuman ;
9599: LD_ADDR_VAR 0 2
9603: PUSH
9604: CALL_OW 44
9608: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_combustion , control_manual , ar_gun , 98 ) ;
9609: LD_INT 14
9611: PPUSH
9612: LD_INT 1
9614: PPUSH
9615: LD_INT 1
9617: PPUSH
9618: LD_INT 27
9620: PPUSH
9621: LD_INT 98
9623: PPUSH
9624: CALL 52229 0 5
// veh := CreateVehicle ;
9628: LD_ADDR_VAR 0 3
9632: PUSH
9633: CALL_OW 45
9637: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
9638: LD_VAR 0 3
9642: PPUSH
9643: LD_INT 4
9645: PPUSH
9646: CALL_OW 233
// PlaceUnitXY ( veh , 179 , 135 , false ) ;
9650: LD_VAR 0 3
9654: PPUSH
9655: LD_INT 179
9657: PPUSH
9658: LD_INT 135
9660: PPUSH
9661: LD_INT 0
9663: PPUSH
9664: CALL_OW 48
// PlaceHumanInUnit ( un , veh ) ;
9668: LD_VAR 0 2
9672: PPUSH
9673: LD_VAR 0 3
9677: PPUSH
9678: CALL_OW 52
// ComMoveXY ( un , 126 , 133 ) ;
9682: LD_VAR 0 2
9686: PPUSH
9687: LD_INT 126
9689: PPUSH
9690: LD_INT 133
9692: PPUSH
9693: CALL_OW 111
// repeat wait ( 0 0$0.3 ) ;
9697: LD_INT 10
9699: PPUSH
9700: CALL_OW 67
// until See ( 1 , veh ) or GetDistUnits ( veh , ar_dep_s ) < 9 ;
9704: LD_INT 1
9706: PPUSH
9707: LD_VAR 0 3
9711: PPUSH
9712: CALL_OW 292
9716: PUSH
9717: LD_VAR 0 3
9721: PPUSH
9722: LD_INT 7
9724: PPUSH
9725: CALL_OW 296
9729: PUSH
9730: LD_INT 9
9732: LESS
9733: OR
9734: IFFALSE 9697
// ComHold ( veh ) ;
9736: LD_VAR 0 3
9740: PPUSH
9741: CALL_OW 140
// Say ( un , D2aa-Ar1-1 ) ;
9745: LD_VAR 0 2
9749: PPUSH
9750: LD_STRING D2aa-Ar1-1
9752: PPUSH
9753: CALL_OW 88
// ComMoveXY ( un , 177 , 96 ) ;
9757: LD_VAR 0 2
9761: PPUSH
9762: LD_INT 177
9764: PPUSH
9765: LD_INT 96
9767: PPUSH
9768: CALL_OW 111
// AddComExitVehicle ( un ) ;
9772: LD_VAR 0 2
9776: PPUSH
9777: CALL_OW 181
// repeat wait ( 0 0$1 ) ;
9781: LD_INT 35
9783: PPUSH
9784: CALL_OW 67
// until GetDistUnits ( un , ar_dep_e ) < 15 ;
9788: LD_VAR 0 2
9792: PPUSH
9793: LD_INT 204
9795: PPUSH
9796: CALL_OW 296
9800: PUSH
9801: LD_INT 15
9803: LESS
9804: IFFALSE 9781
// mc_bases := ReplaceIn ( mc_bases , [ 3 , mc_bases [ 3 ] + 1 ] , un ) ;
9806: LD_ADDR_EXP 50
9810: PUSH
9811: LD_EXP 50
9815: PPUSH
9816: LD_INT 3
9818: PUSH
9819: LD_EXP 50
9823: PUSH
9824: LD_INT 3
9826: ARRAY
9827: PUSH
9828: LD_INT 1
9830: PLUS
9831: PUSH
9832: EMPTY
9833: LIST
9834: LIST
9835: PPUSH
9836: LD_VAR 0 2
9840: PPUSH
9841: CALL 52351 0 3
9845: ST_TO_ADDR
// end ;
9846: PPOPN 3
9848: END
// every 0 0$2 trigger GetSide ( ar_dep_s ) = 1 or IsDead ( ar_dep_s ) do var i , points ;
9849: LD_INT 7
9851: PPUSH
9852: CALL_OW 255
9856: PUSH
9857: LD_INT 1
9859: EQUAL
9860: PUSH
9861: LD_INT 7
9863: PPUSH
9864: CALL_OW 301
9868: OR
9869: IFFALSE 12293
9871: GO 9873
9873: DISABLE
9874: LD_INT 0
9876: PPUSH
9877: PPUSH
// begin for i in UnitFilter ( ar_force_south , [ f_type , unit_building ] ) do
9878: LD_ADDR_VAR 0 1
9882: PUSH
9883: LD_EXP 36
9887: PPUSH
9888: LD_INT 21
9890: PUSH
9891: LD_INT 3
9893: PUSH
9894: EMPTY
9895: LIST
9896: LIST
9897: PPUSH
9898: CALL_OW 72
9902: PUSH
9903: FOR_IN
9904: IFFALSE 9920
// SetSide ( i , 1 ) ;
9906: LD_VAR 0 1
9910: PPUSH
9911: LD_INT 1
9913: PPUSH
9914: CALL_OW 235
9918: GO 9903
9920: POP
9921: POP
// points := [ [ 46 , 41 ] , [ 50 , 25 ] , [ 57 , 75 ] , [ 75 , 89 ] , [ 51 , 45 ] , [ 95 , 95 ] , [ 84 , 77 ] , [ 101 , 76 ] , [ 118 , 81 ] , [ 139 , 97 ] , [ 129 , 114 ] , [ 154 , 111 ] ] ;
9922: LD_ADDR_VAR 0 2
9926: PUSH
9927: LD_INT 46
9929: PUSH
9930: LD_INT 41
9932: PUSH
9933: EMPTY
9934: LIST
9935: LIST
9936: PUSH
9937: LD_INT 50
9939: PUSH
9940: LD_INT 25
9942: PUSH
9943: EMPTY
9944: LIST
9945: LIST
9946: PUSH
9947: LD_INT 57
9949: PUSH
9950: LD_INT 75
9952: PUSH
9953: EMPTY
9954: LIST
9955: LIST
9956: PUSH
9957: LD_INT 75
9959: PUSH
9960: LD_INT 89
9962: PUSH
9963: EMPTY
9964: LIST
9965: LIST
9966: PUSH
9967: LD_INT 51
9969: PUSH
9970: LD_INT 45
9972: PUSH
9973: EMPTY
9974: LIST
9975: LIST
9976: PUSH
9977: LD_INT 95
9979: PUSH
9980: LD_INT 95
9982: PUSH
9983: EMPTY
9984: LIST
9985: LIST
9986: PUSH
9987: LD_INT 84
9989: PUSH
9990: LD_INT 77
9992: PUSH
9993: EMPTY
9994: LIST
9995: LIST
9996: PUSH
9997: LD_INT 101
9999: PUSH
10000: LD_INT 76
10002: PUSH
10003: EMPTY
10004: LIST
10005: LIST
10006: PUSH
10007: LD_INT 118
10009: PUSH
10010: LD_INT 81
10012: PUSH
10013: EMPTY
10014: LIST
10015: LIST
10016: PUSH
10017: LD_INT 139
10019: PUSH
10020: LD_INT 97
10022: PUSH
10023: EMPTY
10024: LIST
10025: LIST
10026: PUSH
10027: LD_INT 129
10029: PUSH
10030: LD_INT 114
10032: PUSH
10033: EMPTY
10034: LIST
10035: LIST
10036: PUSH
10037: LD_INT 154
10039: PUSH
10040: LD_INT 111
10042: PUSH
10043: EMPTY
10044: LIST
10045: LIST
10046: PUSH
10047: EMPTY
10048: LIST
10049: LIST
10050: LIST
10051: LIST
10052: LIST
10053: LIST
10054: LIST
10055: LIST
10056: LIST
10057: LIST
10058: LIST
10059: LIST
10060: ST_TO_ADDR
// base_captured := true ;
10061: LD_ADDR_EXP 6
10065: PUSH
10066: LD_INT 1
10068: ST_TO_ADDR
// DialogueOn ;
10069: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
10073: LD_EXP 21
10077: PPUSH
10078: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
10082: LD_EXP 21
10086: PPUSH
10087: LD_STRING D2-JMM-1
10089: PPUSH
10090: CALL_OW 88
// SayRadio ( Powell , D2-Pow-1 ) ;
10094: LD_EXP 30
10098: PPUSH
10099: LD_STRING D2-Pow-1
10101: PPUSH
10102: CALL_OW 94
// Say ( JMM , D2-JMM-2 ) ;
10106: LD_EXP 21
10110: PPUSH
10111: LD_STRING D2-JMM-2
10113: PPUSH
10114: CALL_OW 88
// SayRadio ( Powell , D2-Pow-2 ) ;
10118: LD_EXP 30
10122: PPUSH
10123: LD_STRING D2-Pow-2
10125: PPUSH
10126: CALL_OW 94
// Say ( JMM , D2-JMM-3 ) ;
10130: LD_EXP 21
10134: PPUSH
10135: LD_STRING D2-JMM-3
10137: PPUSH
10138: CALL_OW 88
// DialogueOff ;
10142: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
10146: LD_STRING M2
10148: PPUSH
10149: CALL_OW 337
// Wait ( 0 0$2 ) ;
10153: LD_INT 70
10155: PPUSH
10156: CALL_OW 67
// if IsOk ( Gary ) then
10160: LD_EXP 32
10164: PPUSH
10165: CALL_OW 302
10169: IFFALSE 10183
// Say ( Gary , D2a-Gary-1 ) ;
10171: LD_EXP 32
10175: PPUSH
10176: LD_STRING D2a-Gary-1
10178: PPUSH
10179: CALL_OW 88
// if IsOk ( Bobby ) then
10183: LD_EXP 24
10187: PPUSH
10188: CALL_OW 302
10192: IFFALSE 10206
// Say ( Bobby , D2a-Bobby-1 ) ;
10194: LD_EXP 24
10198: PPUSH
10199: LD_STRING D2a-Bobby-1
10201: PPUSH
10202: CALL_OW 88
// if IsOk ( Cyrus ) then
10206: LD_EXP 25
10210: PPUSH
10211: CALL_OW 302
10215: IFFALSE 10229
// Say ( Cyrus , D2a-Cyrus-1 ) ;
10217: LD_EXP 25
10221: PPUSH
10222: LD_STRING D2a-Cyrus-1
10224: PPUSH
10225: CALL_OW 88
// if IsOk ( Lisa ) then
10229: LD_EXP 22
10233: PPUSH
10234: CALL_OW 302
10238: IFFALSE 10252
// Say ( Lisa , D2a-Lisa-1 ) ;
10240: LD_EXP 22
10244: PPUSH
10245: LD_STRING D2a-Lisa-1
10247: PPUSH
10248: CALL_OW 88
// if IsOk ( Frank ) then
10252: LD_EXP 33
10256: PPUSH
10257: CALL_OW 302
10261: IFFALSE 10275
// Say ( Frank , D2a-Frank-1 ) ;
10263: LD_EXP 33
10267: PPUSH
10268: LD_STRING D2a-Frank-1
10270: PPUSH
10271: CALL_OW 88
// if IsOk ( Cornel ) then
10275: LD_EXP 31
10279: PPUSH
10280: CALL_OW 302
10284: IFFALSE 10298
// Say ( Cornel , D2a-Corn-1 ) ;
10286: LD_EXP 31
10290: PPUSH
10291: LD_STRING D2a-Corn-1
10293: PPUSH
10294: CALL_OW 88
// if IsOk ( Donaldson ) then
10298: LD_EXP 23
10302: PPUSH
10303: CALL_OW 302
10307: IFFALSE 10321
// Say ( Donaldson , D2a-Don-1 ) ;
10309: LD_EXP 23
10313: PPUSH
10314: LD_STRING D2a-Don-1
10316: PPUSH
10317: CALL_OW 88
// if IsOk ( Brown ) then
10321: LD_EXP 27
10325: PPUSH
10326: CALL_OW 302
10330: IFFALSE 10344
// Say ( Brown , D2a-Brown-1 ) ;
10332: LD_EXP 27
10336: PPUSH
10337: LD_STRING D2a-Brown-1
10339: PPUSH
10340: CALL_OW 88
// Wait ( 0 0$30 ) ;
10344: LD_INT 1050
10346: PPUSH
10347: CALL_OW 67
// if IsOk ( Frank ) then
10351: LD_EXP 33
10355: PPUSH
10356: CALL_OW 302
10360: IFFALSE 10626
// begin DialogueOn ;
10362: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Frank ] ) ;
10366: LD_EXP 21
10370: PUSH
10371: LD_EXP 33
10375: PUSH
10376: EMPTY
10377: LIST
10378: LIST
10379: PPUSH
10380: CALL_OW 87
// Say ( Frank , D3F-Frank-1 ) ;
10384: LD_EXP 33
10388: PPUSH
10389: LD_STRING D3F-Frank-1
10391: PPUSH
10392: CALL_OW 88
// Say ( JMM , D3F-JMM-1 ) ;
10396: LD_EXP 21
10400: PPUSH
10401: LD_STRING D3F-JMM-1
10403: PPUSH
10404: CALL_OW 88
// Say ( Frank , D3F-Frank-2 ) ;
10408: LD_EXP 33
10412: PPUSH
10413: LD_STRING D3F-Frank-2
10415: PPUSH
10416: CALL_OW 88
// case Query ( QFrank ) of 1 :
10420: LD_STRING QFrank
10422: PPUSH
10423: CALL_OW 97
10427: PUSH
10428: LD_INT 1
10430: DOUBLE
10431: EQUAL
10432: IFTRUE 10436
10434: GO 10459
10436: POP
// begin Say ( JMM , D3Fa-JMM-1 ) ;
10437: LD_EXP 21
10441: PPUSH
10442: LD_STRING D3Fa-JMM-1
10444: PPUSH
10445: CALL_OW 88
// us_scout := 1 ;
10449: LD_ADDR_EXP 8
10453: PUSH
10454: LD_INT 1
10456: ST_TO_ADDR
// end ; 2 :
10457: GO 10622
10459: LD_INT 2
10461: DOUBLE
10462: EQUAL
10463: IFTRUE 10467
10465: GO 10589
10467: POP
// begin Say ( JMM , D3Fb-JMM-1 ) ;
10468: LD_EXP 21
10472: PPUSH
10473: LD_STRING D3Fb-JMM-1
10475: PPUSH
10476: CALL_OW 88
// Say ( Frank , D3Fb-Frank-1 ) ;
10480: LD_EXP 33
10484: PPUSH
10485: LD_STRING D3Fb-Frank-1
10487: PPUSH
10488: CALL_OW 88
// case Query ( QFrank2 ) of 1 :
10492: LD_STRING QFrank2
10494: PPUSH
10495: CALL_OW 97
10499: PUSH
10500: LD_INT 1
10502: DOUBLE
10503: EQUAL
10504: IFTRUE 10508
10506: GO 10555
10508: POP
// begin us_scout := 2 ;
10509: LD_ADDR_EXP 8
10513: PUSH
10514: LD_INT 2
10516: ST_TO_ADDR
// Say ( JMM , D3Fba-JMM-1 ) ;
10517: LD_EXP 21
10521: PPUSH
10522: LD_STRING D3Fba-JMM-1
10524: PPUSH
10525: CALL_OW 88
// Say ( Frank , D3Fba-Frank-1 ) ;
10529: LD_EXP 33
10533: PPUSH
10534: LD_STRING D3Fba-Frank-1
10536: PPUSH
10537: CALL_OW 88
// Say ( JMM , D3Fba-JMM-2 ) ;
10541: LD_EXP 21
10545: PPUSH
10546: LD_STRING D3Fba-JMM-2
10548: PPUSH
10549: CALL_OW 88
// end ; 2 :
10553: GO 10587
10555: LD_INT 2
10557: DOUBLE
10558: EQUAL
10559: IFTRUE 10563
10561: GO 10586
10563: POP
// begin us_scout := 0 ;
10564: LD_ADDR_EXP 8
10568: PUSH
10569: LD_INT 0
10571: ST_TO_ADDR
// Say ( JMM , D3Fbb-JMM-1 ) ;
10572: LD_EXP 21
10576: PPUSH
10577: LD_STRING D3Fbb-JMM-1
10579: PPUSH
10580: CALL_OW 88
// end ; end ;
10584: GO 10587
10586: POP
// end ; 3 :
10587: GO 10622
10589: LD_INT 3
10591: DOUBLE
10592: EQUAL
10593: IFTRUE 10597
10595: GO 10621
10597: POP
// begin us_scout := - 1 ;
10598: LD_ADDR_EXP 8
10602: PUSH
10603: LD_INT 1
10605: NEG
10606: ST_TO_ADDR
// Say ( JMM , D3Fc-JMM-1 ) ;
10607: LD_EXP 21
10611: PPUSH
10612: LD_STRING D3Fc-JMM-1
10614: PPUSH
10615: CALL_OW 88
// end ; end ;
10619: GO 10622
10621: POP
// DialogueOff ;
10622: CALL_OW 7
// end ; if us_scout in [ - 1 , 0 ] then
10626: LD_EXP 8
10630: PUSH
10631: LD_INT 1
10633: NEG
10634: PUSH
10635: LD_INT 0
10637: PUSH
10638: EMPTY
10639: LIST
10640: LIST
10641: IN
10642: IFFALSE 10646
// exit ;
10644: GO 12293
// if us_scout in [ 1 , 2 ] then
10646: LD_EXP 8
10650: PUSH
10651: LD_INT 1
10653: PUSH
10654: LD_INT 2
10656: PUSH
10657: EMPTY
10658: LIST
10659: LIST
10660: IN
10661: IFFALSE 11360
// begin if IsInUnit ( Frank ) then
10663: LD_EXP 33
10667: PPUSH
10668: CALL_OW 310
10672: IFFALSE 10683
// ComExitBuilding ( Frank ) ;
10674: LD_EXP 33
10678: PPUSH
10679: CALL_OW 122
// if IsDrivenBy ( Frank ) then
10683: LD_EXP 33
10687: PPUSH
10688: CALL_OW 311
10692: IFFALSE 10703
// ComExitVehicle ( Frank ) ;
10694: LD_EXP 33
10698: PPUSH
10699: CALL_OW 121
// SetSide ( Frank , 4 ) ;
10703: LD_EXP 33
10707: PPUSH
10708: LD_INT 4
10710: PPUSH
10711: CALL_OW 235
// wait ( 0 0$1 ) ;
10715: LD_INT 35
10717: PPUSH
10718: CALL_OW 67
// if us_scout = 2 then
10722: LD_EXP 8
10726: PUSH
10727: LD_INT 2
10729: EQUAL
10730: IFFALSE 11098
// begin ComMoveXY ( Frank , 75 , 63 ) ;
10732: LD_EXP 33
10736: PPUSH
10737: LD_INT 75
10739: PPUSH
10740: LD_INT 63
10742: PPUSH
10743: CALL_OW 111
// AddComHold ( Frank ) ;
10747: LD_EXP 33
10751: PPUSH
10752: CALL_OW 200
// AddComWait ( Frank , 0 0$22 ) ;
10756: LD_EXP 33
10760: PPUSH
10761: LD_INT 770
10763: PPUSH
10764: CALL_OW 202
// AddComMoveXY ( Frank , 100 , 75 ) ;
10768: LD_EXP 33
10772: PPUSH
10773: LD_INT 100
10775: PPUSH
10776: LD_INT 75
10778: PPUSH
10779: CALL_OW 171
// AddComMoveXY ( Frank , 123 , 103 ) ;
10783: LD_EXP 33
10787: PPUSH
10788: LD_INT 123
10790: PPUSH
10791: LD_INT 103
10793: PPUSH
10794: CALL_OW 171
// AddComMoveXY ( Frank , 138 , 108 ) ;
10798: LD_EXP 33
10802: PPUSH
10803: LD_INT 138
10805: PPUSH
10806: LD_INT 108
10808: PPUSH
10809: CALL_OW 171
// AddComHold ( Frank ) ;
10813: LD_EXP 33
10817: PPUSH
10818: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
10822: LD_INT 35
10824: PPUSH
10825: CALL_OW 67
// until IsAt ( Frank , 138 , 108 ) ;
10829: LD_EXP 33
10833: PPUSH
10834: LD_INT 138
10836: PPUSH
10837: LD_INT 108
10839: PPUSH
10840: CALL_OW 307
10844: IFFALSE 10822
// AddComMoveXY ( Frank , 125 , 132 ) ;
10846: LD_EXP 33
10850: PPUSH
10851: LD_INT 125
10853: PPUSH
10854: LD_INT 132
10856: PPUSH
10857: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
10861: LD_INT 35
10863: PPUSH
10864: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 7 ;
10868: LD_INT 1
10870: PPUSH
10871: LD_EXP 33
10875: PPUSH
10876: CALL_OW 292
10880: PUSH
10881: LD_EXP 33
10885: PPUSH
10886: LD_INT 7
10888: PPUSH
10889: CALL_OW 296
10893: PUSH
10894: LD_INT 7
10896: LESS
10897: OR
10898: IFFALSE 10861
// DialogueOn ;
10900: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
10904: LD_EXP 33
10908: PPUSH
10909: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
10913: LD_INT 10
10915: PPUSH
10916: CALL_OW 68
// Say ( JMM , D4Fa-JMM-1 ) ;
10920: LD_EXP 21
10924: PPUSH
10925: LD_STRING D4Fa-JMM-1
10927: PPUSH
10928: CALL_OW 88
// for i in points do
10932: LD_ADDR_VAR 0 1
10936: PUSH
10937: LD_VAR 0 2
10941: PUSH
10942: FOR_IN
10943: IFFALSE 11001
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
10945: LD_VAR 0 1
10949: PUSH
10950: LD_INT 1
10952: ARRAY
10953: PPUSH
10954: LD_VAR 0 1
10958: PUSH
10959: LD_INT 2
10961: ARRAY
10962: PPUSH
10963: LD_INT 1
10965: PPUSH
10966: LD_INT 20
10968: NEG
10969: PPUSH
10970: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
10974: LD_VAR 0 1
10978: PUSH
10979: LD_INT 1
10981: ARRAY
10982: PPUSH
10983: LD_VAR 0 1
10987: PUSH
10988: LD_INT 2
10990: ARRAY
10991: PPUSH
10992: LD_INT 1
10994: PPUSH
10995: CALL_OW 331
// end ;
10999: GO 10942
11001: POP
11002: POP
// dwait ( 0 0$0.5 ) ;
11003: LD_INT 18
11005: PPUSH
11006: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
11010: LD_INT 42
11012: PPUSH
11013: LD_INT 27
11015: PPUSH
11016: CALL_OW 84
// Say ( Frank , D4Fa-Frank-1 ) ;
11020: LD_EXP 33
11024: PPUSH
11025: LD_STRING D4Fa-Frank-1
11027: PPUSH
11028: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
11032: LD_INT 18
11034: PPUSH
11035: CALL_OW 68
// Say ( JMM , D4Fa-JMM-2 ) ;
11039: LD_EXP 21
11043: PPUSH
11044: LD_STRING D4Fa-JMM-2
11046: PPUSH
11047: CALL_OW 88
// CenterNowOnXY ( 118 , 80 ) ;
11051: LD_INT 118
11053: PPUSH
11054: LD_INT 80
11056: PPUSH
11057: CALL_OW 86
// Say ( Frank , D4Fa-Frank-2 ) ;
11061: LD_EXP 33
11065: PPUSH
11066: LD_STRING D4Fa-Frank-2
11068: PPUSH
11069: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
11073: LD_INT 10
11075: PPUSH
11076: CALL_OW 68
// DialogueOff ;
11080: CALL_OW 7
// SetSide ( Frank , 1 ) ;
11084: LD_EXP 33
11088: PPUSH
11089: LD_INT 1
11091: PPUSH
11092: CALL_OW 235
// end else
11096: GO 11360
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
11098: LD_INT 2
11100: PPUSH
11101: LD_INT 4
11103: PPUSH
11104: LD_INT 2
11106: PPUSH
11107: LD_INT 1
11109: PPUSH
11110: CALL_OW 80
// ComMoveXY ( Frank , 75 , 63 ) ;
11114: LD_EXP 33
11118: PPUSH
11119: LD_INT 75
11121: PPUSH
11122: LD_INT 63
11124: PPUSH
11125: CALL_OW 111
// AddComWait ( Frank , 0 0$5 ) ;
11129: LD_EXP 33
11133: PPUSH
11134: LD_INT 175
11136: PPUSH
11137: CALL_OW 202
// AddComMoveXY ( Frank , 102 , 76 ) ;
11141: LD_EXP 33
11145: PPUSH
11146: LD_INT 102
11148: PPUSH
11149: LD_INT 76
11151: PPUSH
11152: CALL_OW 171
// AddComMoveXY ( Frank , 108 , 70 ) ;
11156: LD_EXP 33
11160: PPUSH
11161: LD_INT 108
11163: PPUSH
11164: LD_INT 70
11166: PPUSH
11167: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11171: LD_INT 35
11173: PPUSH
11174: CALL_OW 67
// until See ( 2 , Frank ) ;
11178: LD_INT 2
11180: PPUSH
11181: LD_EXP 33
11185: PPUSH
11186: CALL_OW 292
11190: IFFALSE 11171
// ComMoveXY ( Frank , 112 , 118 ) ;
11192: LD_EXP 33
11196: PPUSH
11197: LD_INT 112
11199: PPUSH
11200: LD_INT 118
11202: PPUSH
11203: CALL_OW 111
// if GetLives ( Frank ) >= 750 then
11207: LD_EXP 33
11211: PPUSH
11212: CALL_OW 256
11216: PUSH
11217: LD_INT 750
11219: GREATEREQUAL
11220: IFFALSE 11234
// SetLives ( Frank , 700 ) ;
11222: LD_EXP 33
11226: PPUSH
11227: LD_INT 700
11229: PPUSH
11230: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
11234: LD_INT 35
11236: PPUSH
11237: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 17 ;
11241: LD_INT 1
11243: PPUSH
11244: LD_EXP 33
11248: PPUSH
11249: CALL_OW 292
11253: PUSH
11254: LD_EXP 33
11258: PPUSH
11259: LD_INT 7
11261: PPUSH
11262: CALL_OW 296
11266: PUSH
11267: LD_INT 17
11269: LESS
11270: OR
11271: IFFALSE 11234
// DialogueOn ;
11273: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11277: LD_EXP 33
11281: PPUSH
11282: CALL_OW 87
// Say ( Frank , D4Fb-Frank-1 ) ;
11286: LD_EXP 33
11290: PPUSH
11291: LD_STRING D4Fb-Frank-1
11293: PPUSH
11294: CALL_OW 88
// Say ( JMM , D4Fb-JMM-1 ) ;
11298: LD_EXP 21
11302: PPUSH
11303: LD_STRING D4Fb-JMM-1
11305: PPUSH
11306: CALL_OW 88
// SayRand ( sex_female , D4Fb-FSci1-1 ) ;
11310: LD_INT 2
11312: PPUSH
11313: LD_STRING D4Fb-FSci1-1
11315: PPUSH
11316: CALL 16197 0 2
// Say ( Frank , D4Fb-Frank-2 ) ;
11320: LD_EXP 33
11324: PPUSH
11325: LD_STRING D4Fb-Frank-2
11327: PPUSH
11328: CALL_OW 88
// Say ( JMM , D4Fb-JMM-2 ) ;
11332: LD_EXP 21
11336: PPUSH
11337: LD_STRING D4Fb-JMM-2
11339: PPUSH
11340: CALL_OW 88
// DialogueOff ;
11344: CALL_OW 7
// SetSide ( Frank , 1 ) ;
11348: LD_EXP 33
11352: PPUSH
11353: LD_INT 1
11355: PPUSH
11356: CALL_OW 235
// end ; end ; if IsOk ( Kikuchi ) and not Frank then
11360: LD_EXP 34
11364: PPUSH
11365: CALL_OW 302
11369: PUSH
11370: LD_EXP 33
11374: NOT
11375: AND
11376: IFFALSE 11524
// begin DialogueOn ;
11378: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Kikuchi ] ) ;
11382: LD_EXP 21
11386: PUSH
11387: LD_EXP 34
11391: PUSH
11392: EMPTY
11393: LIST
11394: LIST
11395: PPUSH
11396: CALL_OW 87
// Say ( Kikuchi , D3Y-Yam-1 ) ;
11400: LD_EXP 34
11404: PPUSH
11405: LD_STRING D3Y-Yam-1
11407: PPUSH
11408: CALL_OW 88
// Say ( JMM , D3Y-JMM-1 ) ;
11412: LD_EXP 21
11416: PPUSH
11417: LD_STRING D3Y-JMM-1
11419: PPUSH
11420: CALL_OW 88
// Say ( Kikuchi , D3Y-Yam-2 ) ;
11424: LD_EXP 34
11428: PPUSH
11429: LD_STRING D3Y-Yam-2
11431: PPUSH
11432: CALL_OW 88
// case Query ( QYamoko ) of 1 :
11436: LD_STRING QYamoko
11438: PPUSH
11439: CALL_OW 97
11443: PUSH
11444: LD_INT 1
11446: DOUBLE
11447: EQUAL
11448: IFTRUE 11452
11450: GO 11487
11452: POP
// begin Say ( JMM , D3Ya-JMM-1 ) ;
11453: LD_EXP 21
11457: PPUSH
11458: LD_STRING D3Ya-JMM-1
11460: PPUSH
11461: CALL_OW 88
// Say ( Kikuchi , D3Ya-Yam-1 ) ;
11465: LD_EXP 34
11469: PPUSH
11470: LD_STRING D3Ya-Yam-1
11472: PPUSH
11473: CALL_OW 88
// us_scout := 1 ;
11477: LD_ADDR_EXP 8
11481: PUSH
11482: LD_INT 1
11484: ST_TO_ADDR
// end ; 2 :
11485: GO 11520
11487: LD_INT 2
11489: DOUBLE
11490: EQUAL
11491: IFTRUE 11495
11493: GO 11519
11495: POP
// begin us_scout := - 1 ;
11496: LD_ADDR_EXP 8
11500: PUSH
11501: LD_INT 1
11503: NEG
11504: ST_TO_ADDR
// Say ( JMM , D3Yb-JMM-1 ) ;
11505: LD_EXP 21
11509: PPUSH
11510: LD_STRING D3Yb-JMM-1
11512: PPUSH
11513: CALL_OW 88
// end ; end ;
11517: GO 11520
11519: POP
// DialogueOff ;
11520: CALL_OW 7
// end ; if Frank then
11524: LD_EXP 33
11528: IFFALSE 11532
// exit ;
11530: GO 12293
// if us_scout in [ - 1 , 0 ] then
11532: LD_EXP 8
11536: PUSH
11537: LD_INT 1
11539: NEG
11540: PUSH
11541: LD_INT 0
11543: PUSH
11544: EMPTY
11545: LIST
11546: LIST
11547: IN
11548: IFFALSE 11552
// exit ;
11550: GO 12293
// us_scout := [ 2 , 2 , 1 ] [ Difficulty ] ;
11552: LD_ADDR_EXP 8
11556: PUSH
11557: LD_INT 2
11559: PUSH
11560: LD_INT 2
11562: PUSH
11563: LD_INT 1
11565: PUSH
11566: EMPTY
11567: LIST
11568: LIST
11569: LIST
11570: PUSH
11571: LD_OWVAR 67
11575: ARRAY
11576: ST_TO_ADDR
// if us_scout in [ 1 , 2 ] then
11577: LD_EXP 8
11581: PUSH
11582: LD_INT 1
11584: PUSH
11585: LD_INT 2
11587: PUSH
11588: EMPTY
11589: LIST
11590: LIST
11591: IN
11592: IFFALSE 12293
// begin if IsInUnit ( Kikuchi ) then
11594: LD_EXP 34
11598: PPUSH
11599: CALL_OW 310
11603: IFFALSE 11614
// ComExitBuilding ( Kikuchi ) ;
11605: LD_EXP 34
11609: PPUSH
11610: CALL_OW 122
// if IsDrivenBy ( Kikuchi ) then
11614: LD_EXP 34
11618: PPUSH
11619: CALL_OW 311
11623: IFFALSE 11634
// ComExitVehicle ( Kikuchi ) ;
11625: LD_EXP 34
11629: PPUSH
11630: CALL_OW 121
// SetSide ( Kikuchi , 4 ) ;
11634: LD_EXP 34
11638: PPUSH
11639: LD_INT 4
11641: PPUSH
11642: CALL_OW 235
// wait ( 0 0$1 ) ;
11646: LD_INT 35
11648: PPUSH
11649: CALL_OW 67
// if us_scout = 2 then
11653: LD_EXP 8
11657: PUSH
11658: LD_INT 2
11660: EQUAL
11661: IFFALSE 12041
// begin ComMoveXY ( Kikuchi , 75 , 63 ) ;
11663: LD_EXP 34
11667: PPUSH
11668: LD_INT 75
11670: PPUSH
11671: LD_INT 63
11673: PPUSH
11674: CALL_OW 111
// AddComHold ( Kikuchi ) ;
11678: LD_EXP 34
11682: PPUSH
11683: CALL_OW 200
// AddComWait ( Kikuchi , 0 0$22 ) ;
11687: LD_EXP 34
11691: PPUSH
11692: LD_INT 770
11694: PPUSH
11695: CALL_OW 202
// AddComMoveXY ( Kikuchi , 100 , 75 ) ;
11699: LD_EXP 34
11703: PPUSH
11704: LD_INT 100
11706: PPUSH
11707: LD_INT 75
11709: PPUSH
11710: CALL_OW 171
// AddComMoveXY ( Kikuchi , 123 , 103 ) ;
11714: LD_EXP 34
11718: PPUSH
11719: LD_INT 123
11721: PPUSH
11722: LD_INT 103
11724: PPUSH
11725: CALL_OW 171
// AddComMoveXY ( Kikuchi , 138 , 108 ) ;
11729: LD_EXP 34
11733: PPUSH
11734: LD_INT 138
11736: PPUSH
11737: LD_INT 108
11739: PPUSH
11740: CALL_OW 171
// AddComHold ( Kikuchi ) ;
11744: LD_EXP 34
11748: PPUSH
11749: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
11753: LD_INT 35
11755: PPUSH
11756: CALL_OW 67
// until IsAt ( Kikuchi , 138 , 108 ) ;
11760: LD_EXP 34
11764: PPUSH
11765: LD_INT 138
11767: PPUSH
11768: LD_INT 108
11770: PPUSH
11771: CALL_OW 307
11775: IFFALSE 11753
// AddComMoveXY ( Kikuchi , 125 , 132 ) ;
11777: LD_EXP 34
11781: PPUSH
11782: LD_INT 125
11784: PPUSH
11785: LD_INT 132
11787: PPUSH
11788: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11792: LD_INT 35
11794: PPUSH
11795: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 7 ;
11799: LD_INT 1
11801: PPUSH
11802: LD_EXP 34
11806: PPUSH
11807: CALL_OW 292
11811: PUSH
11812: LD_EXP 34
11816: PPUSH
11817: LD_INT 7
11819: PPUSH
11820: CALL_OW 296
11824: PUSH
11825: LD_INT 7
11827: LESS
11828: OR
11829: IFFALSE 11792
// DialogueOn ;
11831: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
11835: LD_EXP 34
11839: PPUSH
11840: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
11844: LD_INT 10
11846: PPUSH
11847: CALL_OW 68
// Say ( Kikuchi , D4Ya-Yam-1 ) ;
11851: LD_EXP 34
11855: PPUSH
11856: LD_STRING D4Ya-Yam-1
11858: PPUSH
11859: CALL_OW 88
// Say ( JMM , D4Ya-JMM-1 ) ;
11863: LD_EXP 21
11867: PPUSH
11868: LD_STRING D4Ya-JMM-1
11870: PPUSH
11871: CALL_OW 88
// for i in points do
11875: LD_ADDR_VAR 0 1
11879: PUSH
11880: LD_VAR 0 2
11884: PUSH
11885: FOR_IN
11886: IFFALSE 11944
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
11888: LD_VAR 0 1
11892: PUSH
11893: LD_INT 1
11895: ARRAY
11896: PPUSH
11897: LD_VAR 0 1
11901: PUSH
11902: LD_INT 2
11904: ARRAY
11905: PPUSH
11906: LD_INT 1
11908: PPUSH
11909: LD_INT 20
11911: NEG
11912: PPUSH
11913: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
11917: LD_VAR 0 1
11921: PUSH
11922: LD_INT 1
11924: ARRAY
11925: PPUSH
11926: LD_VAR 0 1
11930: PUSH
11931: LD_INT 2
11933: ARRAY
11934: PPUSH
11935: LD_INT 1
11937: PPUSH
11938: CALL_OW 331
// end ;
11942: GO 11885
11944: POP
11945: POP
// dwait ( 0 0$0.5 ) ;
11946: LD_INT 18
11948: PPUSH
11949: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
11953: LD_INT 42
11955: PPUSH
11956: LD_INT 27
11958: PPUSH
11959: CALL_OW 84
// Say ( Kikuchi , D4Ya-Yam-2 ) ;
11963: LD_EXP 34
11967: PPUSH
11968: LD_STRING D4Ya-Yam-2
11970: PPUSH
11971: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
11975: LD_INT 18
11977: PPUSH
11978: CALL_OW 68
// CenterNowOnXY ( 118 , 80 ) ;
11982: LD_INT 118
11984: PPUSH
11985: LD_INT 80
11987: PPUSH
11988: CALL_OW 86
// Say ( JMM , D4Ya-JMM-2 ) ;
11992: LD_EXP 21
11996: PPUSH
11997: LD_STRING D4Ya-JMM-2
11999: PPUSH
12000: CALL_OW 88
// Say ( Kikuchi , D4Ya-Yam-3 ) ;
12004: LD_EXP 34
12008: PPUSH
12009: LD_STRING D4Ya-Yam-3
12011: PPUSH
12012: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
12016: LD_INT 10
12018: PPUSH
12019: CALL_OW 68
// DialogueOff ;
12023: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12027: LD_EXP 34
12031: PPUSH
12032: LD_INT 1
12034: PPUSH
12035: CALL_OW 235
// end else
12039: GO 12293
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
12041: LD_INT 2
12043: PPUSH
12044: LD_INT 4
12046: PPUSH
12047: LD_INT 2
12049: PPUSH
12050: LD_INT 1
12052: PPUSH
12053: CALL_OW 80
// ComMoveXY ( Kikuchi , 75 , 63 ) ;
12057: LD_EXP 34
12061: PPUSH
12062: LD_INT 75
12064: PPUSH
12065: LD_INT 63
12067: PPUSH
12068: CALL_OW 111
// AddComWait ( Kikuchi , 0 0$5 ) ;
12072: LD_EXP 34
12076: PPUSH
12077: LD_INT 175
12079: PPUSH
12080: CALL_OW 202
// AddComMoveXY ( Kikuchi , 102 , 76 ) ;
12084: LD_EXP 34
12088: PPUSH
12089: LD_INT 102
12091: PPUSH
12092: LD_INT 76
12094: PPUSH
12095: CALL_OW 171
// AddComMoveXY ( Kikuchi , 108 , 70 ) ;
12099: LD_EXP 34
12103: PPUSH
12104: LD_INT 108
12106: PPUSH
12107: LD_INT 70
12109: PPUSH
12110: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12114: LD_INT 35
12116: PPUSH
12117: CALL_OW 67
// until See ( 2 , Kikuchi ) ;
12121: LD_INT 2
12123: PPUSH
12124: LD_EXP 34
12128: PPUSH
12129: CALL_OW 292
12133: IFFALSE 12114
// ComMoveXY ( Kikuchi , 112 , 118 ) ;
12135: LD_EXP 34
12139: PPUSH
12140: LD_INT 112
12142: PPUSH
12143: LD_INT 118
12145: PPUSH
12146: CALL_OW 111
// if GetLives ( Kikuchi ) >= 750 then
12150: LD_EXP 34
12154: PPUSH
12155: CALL_OW 256
12159: PUSH
12160: LD_INT 750
12162: GREATEREQUAL
12163: IFFALSE 12177
// SetLives ( Kikuchi , 700 ) ;
12165: LD_EXP 34
12169: PPUSH
12170: LD_INT 700
12172: PPUSH
12173: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
12177: LD_INT 35
12179: PPUSH
12180: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 17 ;
12184: LD_INT 1
12186: PPUSH
12187: LD_EXP 34
12191: PPUSH
12192: CALL_OW 292
12196: PUSH
12197: LD_EXP 34
12201: PPUSH
12202: LD_INT 7
12204: PPUSH
12205: CALL_OW 296
12209: PUSH
12210: LD_INT 17
12212: LESS
12213: OR
12214: IFFALSE 12177
// DialogueOn ;
12216: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12220: LD_EXP 34
12224: PPUSH
12225: CALL_OW 87
// Say ( Kikuchi , D4Yb-Yam-1 ) ;
12229: LD_EXP 34
12233: PPUSH
12234: LD_STRING D4Yb-Yam-1
12236: PPUSH
12237: CALL_OW 88
// Say ( JMM , D4Yb-JMM-1 ) ;
12241: LD_EXP 21
12245: PPUSH
12246: LD_STRING D4Yb-JMM-1
12248: PPUSH
12249: CALL_OW 88
// Say ( Kikuchi , D4Yb-Yam-2 ) ;
12253: LD_EXP 34
12257: PPUSH
12258: LD_STRING D4Yb-Yam-2
12260: PPUSH
12261: CALL_OW 88
// Say ( JMM , D4Yb-JMM-2 ) ;
12265: LD_EXP 21
12269: PPUSH
12270: LD_STRING D4Yb-JMM-2
12272: PPUSH
12273: CALL_OW 88
// DialogueOff ;
12277: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12281: LD_EXP 34
12285: PPUSH
12286: LD_INT 1
12288: PPUSH
12289: CALL_OW 235
// end ; end ; end ;
12293: PPOPN 2
12295: END
// every 0 0$01 trigger base_captured do var i , tmp , un , un2 ;
12296: LD_EXP 6
12300: IFFALSE 13333
12302: GO 12304
12304: DISABLE
12305: LD_INT 0
12307: PPUSH
12308: PPUSH
12309: PPUSH
12310: PPUSH
// begin enable ;
12311: ENABLE
// if not seen [ 1 ] then
12312: LD_EXP 9
12316: PUSH
12317: LD_INT 1
12319: ARRAY
12320: NOT
12321: IFFALSE 12501
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 11 ] , [ f_control , control_rider ] ] ] ) ;
12323: LD_ADDR_VAR 0 2
12327: PUSH
12328: LD_INT 22
12330: PUSH
12331: LD_INT 2
12333: PUSH
12334: EMPTY
12335: LIST
12336: LIST
12337: PUSH
12338: LD_INT 2
12340: PUSH
12341: LD_INT 25
12343: PUSH
12344: LD_INT 11
12346: PUSH
12347: EMPTY
12348: LIST
12349: LIST
12350: PUSH
12351: LD_INT 33
12353: PUSH
12354: LD_INT 4
12356: PUSH
12357: EMPTY
12358: LIST
12359: LIST
12360: PUSH
12361: EMPTY
12362: LIST
12363: LIST
12364: LIST
12365: PUSH
12366: EMPTY
12367: LIST
12368: LIST
12369: PPUSH
12370: CALL_OW 69
12374: ST_TO_ADDR
// if tmp then
12375: LD_VAR 0 2
12379: IFFALSE 12501
// for i in tmp do
12381: LD_ADDR_VAR 0 1
12385: PUSH
12386: LD_VAR 0 2
12390: PUSH
12391: FOR_IN
12392: IFFALSE 12499
// if See ( 1 , i ) then
12394: LD_INT 1
12396: PPUSH
12397: LD_VAR 0 1
12401: PPUSH
12402: CALL_OW 292
12406: IFFALSE 12497
// begin seen := Replace ( seen , 1 , true ) ;
12408: LD_ADDR_EXP 9
12412: PUSH
12413: LD_EXP 9
12417: PPUSH
12418: LD_INT 1
12420: PPUSH
12421: LD_INT 1
12423: PPUSH
12424: CALL_OW 1
12428: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12429: LD_INT 1
12431: PPUSH
12432: CALL 16019 0 1
12436: IFFALSE 12497
// begin DialogueOn ;
12438: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12442: LD_VAR 0 1
12446: PPUSH
12447: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12451: LD_INT 10
12453: PPUSH
12454: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol2-1 ) ;
12458: LD_ADDR_VAR 0 3
12462: PUSH
12463: LD_INT 1
12465: PPUSH
12466: LD_STRING D5a-Sol2-1
12468: PPUSH
12469: CALL 16197 0 2
12473: ST_TO_ADDR
// if not un then
12474: LD_VAR 0 3
12478: NOT
12479: IFFALSE 12491
// SayRand ( sex_female , D5a-FSol2-1 ) ;
12481: LD_INT 2
12483: PPUSH
12484: LD_STRING D5a-FSol2-1
12486: PPUSH
12487: CALL 16197 0 2
// DialogueOff ;
12491: CALL_OW 7
// break ;
12495: GO 12499
// end ; end ;
12497: GO 12391
12499: POP
12500: POP
// end ; if not seen [ 2 ] then
12501: LD_EXP 9
12505: PUSH
12506: LD_INT 2
12508: ARRAY
12509: NOT
12510: IFFALSE 12735
// begin can_kamikazed := true ;
12512: LD_ADDR_EXP 10
12516: PUSH
12517: LD_INT 1
12519: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 17 ] ] ) ;
12520: LD_ADDR_VAR 0 2
12524: PUSH
12525: LD_INT 22
12527: PUSH
12528: LD_INT 2
12530: PUSH
12531: EMPTY
12532: LIST
12533: LIST
12534: PUSH
12535: LD_INT 25
12537: PUSH
12538: LD_INT 17
12540: PUSH
12541: EMPTY
12542: LIST
12543: LIST
12544: PUSH
12545: EMPTY
12546: LIST
12547: LIST
12548: PPUSH
12549: CALL_OW 69
12553: ST_TO_ADDR
// if tmp then
12554: LD_VAR 0 2
12558: IFFALSE 12735
// for i in tmp do
12560: LD_ADDR_VAR 0 1
12564: PUSH
12565: LD_VAR 0 2
12569: PUSH
12570: FOR_IN
12571: IFFALSE 12733
// if See ( 1 , i ) then
12573: LD_INT 1
12575: PPUSH
12576: LD_VAR 0 1
12580: PPUSH
12581: CALL_OW 292
12585: IFFALSE 12731
// begin seen := Replace ( seen , 2 , true ) ;
12587: LD_ADDR_EXP 9
12591: PUSH
12592: LD_EXP 9
12596: PPUSH
12597: LD_INT 2
12599: PPUSH
12600: LD_INT 1
12602: PPUSH
12603: CALL_OW 1
12607: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12608: LD_INT 1
12610: PPUSH
12611: CALL 16019 0 1
12615: IFFALSE 12731
// begin DialogueOn ;
12617: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12621: LD_VAR 0 1
12625: PPUSH
12626: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12630: LD_INT 10
12632: PPUSH
12633: CALL_OW 68
// un := SayRand ( sex_male , D5b-Sol1-1 ) ;
12637: LD_ADDR_VAR 0 3
12641: PUSH
12642: LD_INT 1
12644: PPUSH
12645: LD_STRING D5b-Sol1-1
12647: PPUSH
12648: CALL 16197 0 2
12652: ST_TO_ADDR
// if not un then
12653: LD_VAR 0 3
12657: NOT
12658: IFFALSE 12676
// un := SayRand ( sex_female , D5b-FSol1-1 ) ;
12660: LD_ADDR_VAR 0 3
12664: PUSH
12665: LD_INT 2
12667: PPUSH
12668: LD_STRING D5b-FSol1-1
12670: PPUSH
12671: CALL 16197 0 2
12675: ST_TO_ADDR
// if un then
12676: LD_VAR 0 3
12680: IFFALSE 12725
// begin un2 := SayRand2 ( sex_male , D5b-Sol2-1 , un ) ;
12682: LD_ADDR_VAR 0 4
12686: PUSH
12687: LD_INT 1
12689: PPUSH
12690: LD_STRING D5b-Sol2-1
12692: PPUSH
12693: LD_VAR 0 3
12697: PPUSH
12698: CALL 16423 0 3
12702: ST_TO_ADDR
// if not un2 then
12703: LD_VAR 0 4
12707: NOT
12708: IFFALSE 12725
// SayRand2 ( sex_female , D5b-FSol2-1 , un ) ;
12710: LD_INT 2
12712: PPUSH
12713: LD_STRING D5b-FSol2-1
12715: PPUSH
12716: LD_VAR 0 3
12720: PPUSH
12721: CALL 16423 0 3
// end ; DialogueOff ;
12725: CALL_OW 7
// break ;
12729: GO 12733
// end ; end ;
12731: GO 12570
12733: POP
12734: POP
// end ; if not seen [ 3 ] then
12735: LD_EXP 9
12739: PUSH
12740: LD_INT 3
12742: ARRAY
12743: NOT
12744: IFFALSE 12918
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] ] ) ;
12746: LD_ADDR_VAR 0 2
12750: PUSH
12751: LD_INT 22
12753: PUSH
12754: LD_INT 2
12756: PUSH
12757: EMPTY
12758: LIST
12759: LIST
12760: PUSH
12761: LD_INT 33
12763: PUSH
12764: LD_INT 2
12766: PUSH
12767: EMPTY
12768: LIST
12769: LIST
12770: PUSH
12771: EMPTY
12772: LIST
12773: LIST
12774: PPUSH
12775: CALL_OW 69
12779: ST_TO_ADDR
// if tmp then
12780: LD_VAR 0 2
12784: IFFALSE 12918
// for i in tmp do
12786: LD_ADDR_VAR 0 1
12790: PUSH
12791: LD_VAR 0 2
12795: PUSH
12796: FOR_IN
12797: IFFALSE 12916
// if See ( 1 , i ) then
12799: LD_INT 1
12801: PPUSH
12802: LD_VAR 0 1
12806: PPUSH
12807: CALL_OW 292
12811: IFFALSE 12914
// begin seen := Replace ( seen , 3 , true ) ;
12813: LD_ADDR_EXP 9
12817: PUSH
12818: LD_EXP 9
12822: PPUSH
12823: LD_INT 3
12825: PPUSH
12826: LD_INT 1
12828: PPUSH
12829: CALL_OW 1
12833: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12834: LD_INT 1
12836: PPUSH
12837: CALL 16019 0 1
12841: IFFALSE 12914
// begin DialogueOn ;
12843: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12847: LD_VAR 0 1
12851: PPUSH
12852: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12856: LD_INT 10
12858: PPUSH
12859: CALL_OW 68
// un := SayRand ( sex_male , D8-Sol1-1 ) ;
12863: LD_ADDR_VAR 0 3
12867: PUSH
12868: LD_INT 1
12870: PPUSH
12871: LD_STRING D8-Sol1-1
12873: PPUSH
12874: CALL 16197 0 2
12878: ST_TO_ADDR
// if not un then
12879: LD_VAR 0 3
12883: NOT
12884: IFFALSE 12896
// SayRand ( sex_female , D8-FSol1-1 ) ;
12886: LD_INT 2
12888: PPUSH
12889: LD_STRING D8-FSol1-1
12891: PPUSH
12892: CALL 16197 0 2
// Say ( JMM , D8-JMM-1 ) ;
12896: LD_EXP 21
12900: PPUSH
12901: LD_STRING D8-JMM-1
12903: PPUSH
12904: CALL_OW 88
// DialogueOff ;
12908: CALL_OW 7
// break ;
12912: GO 12916
// end ; end ;
12914: GO 12796
12916: POP
12917: POP
// end ; if not seen [ 4 ] then
12918: LD_EXP 9
12922: PUSH
12923: LD_INT 4
12925: ARRAY
12926: NOT
12927: IFFALSE 13089
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] ] ) ;
12929: LD_ADDR_VAR 0 2
12933: PUSH
12934: LD_INT 22
12936: PUSH
12937: LD_INT 2
12939: PUSH
12940: EMPTY
12941: LIST
12942: LIST
12943: PUSH
12944: LD_INT 33
12946: PUSH
12947: LD_INT 5
12949: PUSH
12950: EMPTY
12951: LIST
12952: LIST
12953: PUSH
12954: EMPTY
12955: LIST
12956: LIST
12957: PPUSH
12958: CALL_OW 69
12962: ST_TO_ADDR
// if tmp then
12963: LD_VAR 0 2
12967: IFFALSE 13089
// for i in tmp do
12969: LD_ADDR_VAR 0 1
12973: PUSH
12974: LD_VAR 0 2
12978: PUSH
12979: FOR_IN
12980: IFFALSE 13087
// if See ( 1 , i ) then
12982: LD_INT 1
12984: PPUSH
12985: LD_VAR 0 1
12989: PPUSH
12990: CALL_OW 292
12994: IFFALSE 13085
// begin seen := Replace ( seen , 4 , true ) ;
12996: LD_ADDR_EXP 9
13000: PUSH
13001: LD_EXP 9
13005: PPUSH
13006: LD_INT 4
13008: PPUSH
13009: LD_INT 1
13011: PPUSH
13012: CALL_OW 1
13016: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13017: LD_INT 1
13019: PPUSH
13020: CALL 16019 0 1
13024: IFFALSE 13085
// begin DialogueOn ;
13026: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13030: LD_VAR 0 1
13034: PPUSH
13035: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13039: LD_INT 10
13041: PPUSH
13042: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol1-1 ) ;
13046: LD_ADDR_VAR 0 3
13050: PUSH
13051: LD_INT 1
13053: PPUSH
13054: LD_STRING D5a-Sol1-1
13056: PPUSH
13057: CALL 16197 0 2
13061: ST_TO_ADDR
// if not un then
13062: LD_VAR 0 3
13066: NOT
13067: IFFALSE 13079
// SayRand ( sex_female , D5a-FSol1-1 ) ;
13069: LD_INT 2
13071: PPUSH
13072: LD_STRING D5a-FSol1-1
13074: PPUSH
13075: CALL 16197 0 2
// DialogueOff ;
13079: CALL_OW 7
// break ;
13083: GO 13087
// end ; end ;
13085: GO 12979
13087: POP
13088: POP
// end ; if not seen [ 5 ] and seen [ 3 ] then
13089: LD_EXP 9
13093: PUSH
13094: LD_INT 5
13096: ARRAY
13097: NOT
13098: PUSH
13099: LD_EXP 9
13103: PUSH
13104: LD_INT 3
13106: ARRAY
13107: AND
13108: IFFALSE 13282
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) ;
13110: LD_ADDR_VAR 0 2
13114: PUSH
13115: LD_INT 22
13117: PUSH
13118: LD_INT 2
13120: PUSH
13121: EMPTY
13122: LIST
13123: LIST
13124: PUSH
13125: LD_INT 34
13127: PUSH
13128: LD_INT 31
13130: PUSH
13131: EMPTY
13132: LIST
13133: LIST
13134: PUSH
13135: EMPTY
13136: LIST
13137: LIST
13138: PPUSH
13139: CALL_OW 69
13143: ST_TO_ADDR
// if tmp then
13144: LD_VAR 0 2
13148: IFFALSE 13282
// for i in tmp do
13150: LD_ADDR_VAR 0 1
13154: PUSH
13155: LD_VAR 0 2
13159: PUSH
13160: FOR_IN
13161: IFFALSE 13280
// if See ( 1 , i ) then
13163: LD_INT 1
13165: PPUSH
13166: LD_VAR 0 1
13170: PPUSH
13171: CALL_OW 292
13175: IFFALSE 13278
// begin seen := Replace ( seen , 5 , true ) ;
13177: LD_ADDR_EXP 9
13181: PUSH
13182: LD_EXP 9
13186: PPUSH
13187: LD_INT 5
13189: PPUSH
13190: LD_INT 1
13192: PPUSH
13193: CALL_OW 1
13197: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13198: LD_INT 1
13200: PPUSH
13201: CALL 16019 0 1
13205: IFFALSE 13278
// begin DialogueOn ;
13207: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13211: LD_VAR 0 1
13215: PPUSH
13216: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13220: LD_INT 10
13222: PPUSH
13223: CALL_OW 68
// un := SayRand ( sex_male , D8a-Sol2-1 ) ;
13227: LD_ADDR_VAR 0 3
13231: PUSH
13232: LD_INT 1
13234: PPUSH
13235: LD_STRING D8a-Sol2-1
13237: PPUSH
13238: CALL 16197 0 2
13242: ST_TO_ADDR
// if not un then
13243: LD_VAR 0 3
13247: NOT
13248: IFFALSE 13260
// SayRand ( sex_female , D8a-FSol2-1 ) ;
13250: LD_INT 2
13252: PPUSH
13253: LD_STRING D8a-FSol2-1
13255: PPUSH
13256: CALL 16197 0 2
// Say ( JMM , D8a-JMM-1 ) ;
13260: LD_EXP 21
13264: PPUSH
13265: LD_STRING D8a-JMM-1
13267: PPUSH
13268: CALL_OW 88
// DialogueOff ;
13272: CALL_OW 7
// break ;
13276: GO 13280
// end ; end ;
13278: GO 13160
13280: POP
13281: POP
// end ; if seen [ 1 ] and seen [ 2 ] and seen [ 3 ] and seen [ 4 ] and seen [ 5 ] then
13282: LD_EXP 9
13286: PUSH
13287: LD_INT 1
13289: ARRAY
13290: PUSH
13291: LD_EXP 9
13295: PUSH
13296: LD_INT 2
13298: ARRAY
13299: AND
13300: PUSH
13301: LD_EXP 9
13305: PUSH
13306: LD_INT 3
13308: ARRAY
13309: AND
13310: PUSH
13311: LD_EXP 9
13315: PUSH
13316: LD_INT 4
13318: ARRAY
13319: AND
13320: PUSH
13321: LD_EXP 9
13325: PUSH
13326: LD_INT 5
13328: ARRAY
13329: AND
13330: IFFALSE 13333
// disable ;
13332: DISABLE
// end ;
13333: PPOPN 4
13335: END
// every 0 0$1 trigger can_kamikazed and kamikazed do var un ;
13336: LD_EXP 10
13340: PUSH
13341: LD_EXP 11
13345: AND
13346: IFFALSE 13544
13348: GO 13350
13350: DISABLE
13351: LD_INT 0
13353: PPUSH
// begin DialogueOn ;
13354: CALL_OW 6
// CenterNowOnUnits ( kamikazed ) ;
13358: LD_EXP 11
13362: PPUSH
13363: CALL_OW 87
// un := SayRand ( sex_male , D5c-Sol1-1 ) ;
13367: LD_ADDR_VAR 0 1
13371: PUSH
13372: LD_INT 1
13374: PPUSH
13375: LD_STRING D5c-Sol1-1
13377: PPUSH
13378: CALL 16197 0 2
13382: ST_TO_ADDR
// if not un then
13383: LD_VAR 0 1
13387: NOT
13388: IFFALSE 13406
// un := SayRand ( sex_female , D5c-FSol1-1 ) ;
13390: LD_ADDR_VAR 0 1
13394: PUSH
13395: LD_INT 2
13397: PPUSH
13398: LD_STRING D5c-FSol1-1
13400: PPUSH
13401: CALL 16197 0 2
13405: ST_TO_ADDR
// Say ( JMM , D5c-JMM-1 ) ;
13406: LD_EXP 21
13410: PPUSH
13411: LD_STRING D5c-JMM-1
13413: PPUSH
13414: CALL_OW 88
// if IsOk ( Lisa ) then
13418: LD_EXP 22
13422: PPUSH
13423: CALL_OW 302
13427: IFFALSE 13443
// Say ( Lisa , D5d-Lisa-1 ) else
13429: LD_EXP 22
13433: PPUSH
13434: LD_STRING D5d-Lisa-1
13436: PPUSH
13437: CALL_OW 88
13441: GO 13528
// if IsOk ( Cyrus ) then
13443: LD_EXP 25
13447: PPUSH
13448: CALL_OW 302
13452: IFFALSE 13468
// Say ( Cyrus , D5d-Cyrus-1 ) else
13454: LD_EXP 25
13458: PPUSH
13459: LD_STRING D5d-Cyrus-1
13461: PPUSH
13462: CALL_OW 88
13466: GO 13528
// if IsOk ( Gary ) then
13468: LD_EXP 32
13472: PPUSH
13473: CALL_OW 302
13477: IFFALSE 13493
// Say ( Gary , D5d-Gary-1 ) else
13479: LD_EXP 32
13483: PPUSH
13484: LD_STRING D5d-Gary-1
13486: PPUSH
13487: CALL_OW 88
13491: GO 13528
// if GetSex ( un ) = sex_male then
13493: LD_VAR 0 1
13497: PPUSH
13498: CALL_OW 258
13502: PUSH
13503: LD_INT 1
13505: EQUAL
13506: IFFALSE 13522
// Say ( un , D5d-Sol1-1 ) else
13508: LD_VAR 0 1
13512: PPUSH
13513: LD_STRING D5d-Sol1-1
13515: PPUSH
13516: CALL_OW 88
13520: GO 13528
// begin DialogueOff ;
13522: CALL_OW 7
// exit ;
13526: GO 13544
// end ; Say ( JMM , D5d-JMM-1 ) ;
13528: LD_EXP 21
13532: PPUSH
13533: LD_STRING D5d-JMM-1
13535: PPUSH
13536: CALL_OW 88
// DialogueOff ;
13540: CALL_OW 7
// end ;
13544: PPOPN 1
13546: END
// every 0 0$2 trigger SeeArea ( 1 , artifact_area ) >= 2 do var un ;
13547: LD_INT 1
13549: PPUSH
13550: LD_INT 17
13552: PPUSH
13553: CALL_OW 294
13557: PUSH
13558: LD_INT 2
13560: GREATEREQUAL
13561: IFFALSE 13682
13563: GO 13565
13565: DISABLE
13566: LD_INT 0
13568: PPUSH
// begin PlaceSeeing ( 10 , 5 , 1 , - 10 ) ;
13569: LD_INT 10
13571: PPUSH
13572: LD_INT 5
13574: PPUSH
13575: LD_INT 1
13577: PPUSH
13578: LD_INT 10
13580: NEG
13581: PPUSH
13582: CALL_OW 330
// RemoveSeeing ( 10 , 5 , 1 ) ;
13586: LD_INT 10
13588: PPUSH
13589: LD_INT 5
13591: PPUSH
13592: LD_INT 1
13594: PPUSH
13595: CALL_OW 331
// CenterNowOnXY ( 10 , 5 ) ;
13599: LD_INT 10
13601: PPUSH
13602: LD_INT 5
13604: PPUSH
13605: CALL_OW 86
// DialogueOn ;
13609: CALL_OW 6
// un := SayRand ( sex_male , D6-Sci1-1 ) ;
13613: LD_ADDR_VAR 0 1
13617: PUSH
13618: LD_INT 1
13620: PPUSH
13621: LD_STRING D6-Sci1-1
13623: PPUSH
13624: CALL 16197 0 2
13628: ST_TO_ADDR
// if un then
13629: LD_VAR 0 1
13633: IFFALSE 13671
// begin Say ( JMM , D6-JMM-1 ) ;
13635: LD_EXP 21
13639: PPUSH
13640: LD_STRING D6-JMM-1
13642: PPUSH
13643: CALL_OW 88
// Say ( un , D6-Sci1-2 ) ;
13647: LD_VAR 0 1
13651: PPUSH
13652: LD_STRING D6-Sci1-2
13654: PPUSH
13655: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
13659: LD_EXP 21
13663: PPUSH
13664: LD_STRING D6-JMM-2
13666: PPUSH
13667: CALL_OW 88
// end ; DialogueOff ;
13671: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
13675: LD_STRING M3
13677: PPUSH
13678: CALL_OW 337
// end ;
13682: PPOPN 1
13684: END
// export ar_mechanic , ar_mechanic_friend ; every 0 0$20 trigger tick >= 20 20$00 and ( DangerAtRangeXY ( 2 , 169 , 90 , 10 ) [ 4 ] = 0 or IsDead ( ar_dep_w ) or GetSide ( ar_dep_w ) = 1 ) and not IsDead ( ar_dep_n ) do var un , i , cargo , tmp , escaped ;
13685: LD_OWVAR 1
13689: PUSH
13690: LD_INT 42000
13692: GREATEREQUAL
13693: PUSH
13694: LD_INT 2
13696: PPUSH
13697: LD_INT 169
13699: PPUSH
13700: LD_INT 90
13702: PPUSH
13703: LD_INT 10
13705: PPUSH
13706: CALL 53247 0 4
13710: PUSH
13711: LD_INT 4
13713: ARRAY
13714: PUSH
13715: LD_INT 0
13717: EQUAL
13718: PUSH
13719: LD_INT 45
13721: PPUSH
13722: CALL_OW 301
13726: OR
13727: PUSH
13728: LD_INT 45
13730: PPUSH
13731: CALL_OW 255
13735: PUSH
13736: LD_INT 1
13738: EQUAL
13739: OR
13740: AND
13741: PUSH
13742: LD_INT 94
13744: PPUSH
13745: CALL_OW 301
13749: NOT
13750: AND
13751: IFFALSE 14956
13753: GO 13755
13755: DISABLE
13756: LD_INT 0
13758: PPUSH
13759: PPUSH
13760: PPUSH
13761: PPUSH
13762: PPUSH
// begin uc_side := 5 ;
13763: LD_ADDR_OWVAR 20
13767: PUSH
13768: LD_INT 5
13770: ST_TO_ADDR
// uc_nation := 2 ;
13771: LD_ADDR_OWVAR 21
13775: PUSH
13776: LD_INT 2
13778: ST_TO_ADDR
// InitHc ;
13779: CALL_OW 19
// PrepareHuman ( sex_male , 3 , 8 ) ;
13783: LD_INT 1
13785: PPUSH
13786: LD_INT 3
13788: PPUSH
13789: LD_INT 8
13791: PPUSH
13792: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
13796: LD_ADDR_OWVAR 29
13800: PUSH
13801: LD_INT 12
13803: PUSH
13804: LD_INT 12
13806: PUSH
13807: EMPTY
13808: LIST
13809: LIST
13810: ST_TO_ADDR
// hc_name := Hans Felige ;
13811: LD_ADDR_OWVAR 26
13815: PUSH
13816: LD_STRING Hans Felige
13818: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
13819: LD_ADDR_OWVAR 33
13823: PUSH
13824: LD_STRING SecondCharsGal
13826: ST_TO_ADDR
// hc_face_number := 7 ;
13827: LD_ADDR_OWVAR 34
13831: PUSH
13832: LD_INT 7
13834: ST_TO_ADDR
// ar_mechanic := CreateHuman ;
13835: LD_ADDR_EXP 46
13839: PUSH
13840: CALL_OW 44
13844: ST_TO_ADDR
// InitHc ;
13845: CALL_OW 19
// PrepareHuman ( sex_male , 16 , 2 ) ;
13849: LD_INT 1
13851: PPUSH
13852: LD_INT 16
13854: PPUSH
13855: LD_INT 2
13857: PPUSH
13858: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
13862: LD_ADDR_OWVAR 29
13866: PUSH
13867: LD_INT 12
13869: PUSH
13870: LD_INT 12
13872: PUSH
13873: EMPTY
13874: LIST
13875: LIST
13876: ST_TO_ADDR
// hc_name :=  ;
13877: LD_ADDR_OWVAR 26
13881: PUSH
13882: LD_STRING 
13884: ST_TO_ADDR
// ar_mechanic_friend := CreateHuman ;
13885: LD_ADDR_EXP 47
13889: PUSH
13890: CALL_OW 44
13894: ST_TO_ADDR
// InitHc ;
13895: CALL_OW 19
// repeat wait ( 0 0$1 ) ;
13899: LD_INT 35
13901: PPUSH
13902: CALL_OW 67
// until not InBattle ( 1 ) ;
13906: LD_INT 1
13908: PPUSH
13909: CALL_OW 463
13913: NOT
13914: IFFALSE 13899
// wait ( 0 0$5 ) ;
13916: LD_INT 175
13918: PPUSH
13919: CALL_OW 67
// DialogueOn ;
13923: CALL_OW 6
// InGameOn ;
13927: CALL_OW 8
// un := UnitFilter ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , [ f_sex , sex_male ] ) [ 1 ] ;
13931: LD_ADDR_VAR 0 1
13935: PUSH
13936: LD_INT 22
13938: PUSH
13939: LD_INT 1
13941: PUSH
13942: EMPTY
13943: LIST
13944: LIST
13945: PUSH
13946: LD_INT 2
13948: PUSH
13949: LD_INT 25
13951: PUSH
13952: LD_INT 1
13954: PUSH
13955: EMPTY
13956: LIST
13957: LIST
13958: PUSH
13959: LD_INT 25
13961: PUSH
13962: LD_INT 2
13964: PUSH
13965: EMPTY
13966: LIST
13967: LIST
13968: PUSH
13969: LD_INT 25
13971: PUSH
13972: LD_INT 3
13974: PUSH
13975: EMPTY
13976: LIST
13977: LIST
13978: PUSH
13979: LD_INT 25
13981: PUSH
13982: LD_INT 4
13984: PUSH
13985: EMPTY
13986: LIST
13987: LIST
13988: PUSH
13989: LD_INT 25
13991: PUSH
13992: LD_INT 5
13994: PUSH
13995: EMPTY
13996: LIST
13997: LIST
13998: PUSH
13999: LD_INT 25
14001: PUSH
14002: LD_INT 8
14004: PUSH
14005: EMPTY
14006: LIST
14007: LIST
14008: PUSH
14009: EMPTY
14010: LIST
14011: LIST
14012: LIST
14013: LIST
14014: LIST
14015: LIST
14016: LIST
14017: PUSH
14018: EMPTY
14019: LIST
14020: LIST
14021: PPUSH
14022: CALL_OW 69
14026: PUSH
14027: LD_EXP 21
14031: PUSH
14032: LD_EXP 22
14036: PUSH
14037: LD_EXP 23
14041: PUSH
14042: LD_EXP 24
14046: PUSH
14047: LD_EXP 25
14051: PUSH
14052: LD_EXP 26
14056: PUSH
14057: LD_EXP 27
14061: PUSH
14062: LD_EXP 28
14066: PUSH
14067: LD_EXP 29
14071: PUSH
14072: LD_EXP 31
14076: PUSH
14077: LD_EXP 32
14081: PUSH
14082: LD_EXP 33
14086: PUSH
14087: LD_EXP 34
14091: PUSH
14092: EMPTY
14093: LIST
14094: LIST
14095: LIST
14096: LIST
14097: LIST
14098: LIST
14099: LIST
14100: LIST
14101: LIST
14102: LIST
14103: LIST
14104: LIST
14105: LIST
14106: DIFF
14107: PPUSH
14108: LD_INT 26
14110: PUSH
14111: LD_INT 1
14113: PUSH
14114: EMPTY
14115: LIST
14116: LIST
14117: PPUSH
14118: CALL_OW 72
14122: PUSH
14123: LD_INT 1
14125: ARRAY
14126: ST_TO_ADDR
// if Brown then
14127: LD_EXP 27
14131: IFFALSE 14143
// un := Brown ;
14133: LD_ADDR_VAR 0 1
14137: PUSH
14138: LD_EXP 27
14142: ST_TO_ADDR
// if un then
14143: LD_VAR 0 1
14147: IFFALSE 14173
// begin Say ( un , D7-Sol1-1 ) ;
14149: LD_VAR 0 1
14153: PPUSH
14154: LD_STRING D7-Sol1-1
14156: PPUSH
14157: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
14161: LD_EXP 21
14165: PPUSH
14166: LD_STRING D7-JMM-1
14168: PPUSH
14169: CALL_OW 88
// end ; SayRadio ( ar_mechanic , D7-Ar1-1 ) ;
14173: LD_EXP 46
14177: PPUSH
14178: LD_STRING D7-Ar1-1
14180: PPUSH
14181: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
14185: LD_EXP 21
14189: PPUSH
14190: LD_STRING D7-JMM-2
14192: PPUSH
14193: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-2 ) ;
14197: LD_EXP 46
14201: PPUSH
14202: LD_STRING D7-Ar1-2
14204: PPUSH
14205: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
14209: LD_EXP 21
14213: PPUSH
14214: LD_STRING D7-JMM-3
14216: PPUSH
14217: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-3 ) ;
14221: LD_EXP 46
14225: PPUSH
14226: LD_STRING D7-Ar1-3
14228: PPUSH
14229: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
14233: LD_EXP 21
14237: PPUSH
14238: LD_STRING D7-JMM-4
14240: PPUSH
14241: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-4 ) ;
14245: LD_EXP 46
14249: PPUSH
14250: LD_STRING D7-Ar1-4
14252: PPUSH
14253: CALL_OW 94
// InGameOff ;
14257: CALL_OW 9
// DialogueOff ;
14261: CALL_OW 7
// case Query ( QCameras ) of 1 :
14265: LD_STRING QCameras
14267: PPUSH
14268: CALL_OW 97
14272: PUSH
14273: LD_INT 1
14275: DOUBLE
14276: EQUAL
14277: IFTRUE 14281
14279: GO 14284
14281: POP
// ; 2 :
14282: GO 14298
14284: LD_INT 2
14286: DOUBLE
14287: EQUAL
14288: IFTRUE 14292
14290: GO 14297
14292: POP
// exit ; end ;
14293: GO 14956
14295: GO 14298
14297: POP
// ChangeMissionObjectives ( MCar ) ;
14298: LD_STRING MCar
14300: PPUSH
14301: CALL_OW 337
// PlaceSeeing ( 124 , 90 , 1 , - 6 ) ;
14305: LD_INT 124
14307: PPUSH
14308: LD_INT 90
14310: PPUSH
14311: LD_INT 1
14313: PPUSH
14314: LD_INT 6
14316: NEG
14317: PPUSH
14318: CALL_OW 330
// RemoveSeeing ( 124 , 90 , 1 ) ;
14322: LD_INT 124
14324: PPUSH
14325: LD_INT 90
14327: PPUSH
14328: LD_INT 1
14330: PPUSH
14331: CALL_OW 331
// SetAreaMapShow ( parking_marea , 1 ) ;
14335: LD_INT 12
14337: PPUSH
14338: LD_INT 1
14340: PPUSH
14341: CALL_OW 424
// wait ( 3 ) ;
14345: LD_INT 3
14347: PPUSH
14348: CALL_OW 67
// CenterNowOnXY ( 124 , 90 ) ;
14352: LD_INT 124
14354: PPUSH
14355: LD_INT 90
14357: PPUSH
14358: CALL_OW 86
// cargo := false ;
14362: LD_ADDR_VAR 0 3
14366: PUSH
14367: LD_INT 0
14369: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
14370: LD_INT 35
14372: PPUSH
14373: CALL_OW 67
// cargo := FilterUnitsInArea ( parking_marea , [ [ f_engine , engine_siberite ] , [ f_weapon , ar_cargo_bay ] , [ f_empty ] ] ) ;
14377: LD_ADDR_VAR 0 3
14381: PUSH
14382: LD_INT 12
14384: PPUSH
14385: LD_INT 32
14387: PUSH
14388: LD_INT 3
14390: PUSH
14391: EMPTY
14392: LIST
14393: LIST
14394: PUSH
14395: LD_INT 34
14397: PUSH
14398: LD_INT 32
14400: PUSH
14401: EMPTY
14402: LIST
14403: LIST
14404: PUSH
14405: LD_INT 58
14407: PUSH
14408: EMPTY
14409: LIST
14410: PUSH
14411: EMPTY
14412: LIST
14413: LIST
14414: LIST
14415: PPUSH
14416: CALL_OW 70
14420: ST_TO_ADDR
// until cargo ;
14421: LD_VAR 0 3
14425: IFFALSE 14370
// cargo := cargo [ 1 ] ;
14427: LD_ADDR_VAR 0 3
14431: PUSH
14432: LD_VAR 0 3
14436: PUSH
14437: LD_INT 1
14439: ARRAY
14440: ST_TO_ADDR
// SetSide ( cargo , 5 ) ;
14441: LD_VAR 0 3
14445: PPUSH
14446: LD_INT 5
14448: PPUSH
14449: CALL_OW 235
// SetAreaMapShow ( parking_marea , 0 ) ;
14453: LD_INT 12
14455: PPUSH
14456: LD_INT 0
14458: PPUSH
14459: CALL_OW 424
// PlaceUnitArea ( ar_mechanic , mechanic_spawn , false ) ;
14463: LD_EXP 46
14467: PPUSH
14468: LD_INT 11
14470: PPUSH
14471: LD_INT 0
14473: PPUSH
14474: CALL_OW 49
// PlaceUnitArea ( ar_mechanic_friend , mechanic_spawn , false ) ;
14478: LD_EXP 47
14482: PPUSH
14483: LD_INT 11
14485: PPUSH
14486: LD_INT 0
14488: PPUSH
14489: CALL_OW 49
// ComMoveToArea ( [ ar_mechanic , ar_mechanic_friend ] , parking_marea ) ;
14493: LD_EXP 46
14497: PUSH
14498: LD_EXP 47
14502: PUSH
14503: EMPTY
14504: LIST
14505: LIST
14506: PPUSH
14507: LD_INT 12
14509: PPUSH
14510: CALL_OW 113
// AddComEnterUnit ( ar_mechanic , cargo ) ;
14514: LD_EXP 46
14518: PPUSH
14519: LD_VAR 0 3
14523: PPUSH
14524: CALL_OW 180
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
14528: LD_EXP 46
14532: PUSH
14533: LD_EXP 47
14537: PUSH
14538: EMPTY
14539: LIST
14540: LIST
14541: PPUSH
14542: LD_INT 209
14544: PPUSH
14545: LD_INT 178
14547: PPUSH
14548: CALL_OW 171
// escaped := 0 ;
14552: LD_ADDR_VAR 0 5
14556: PUSH
14557: LD_INT 0
14559: ST_TO_ADDR
// while ( true ) do
14560: LD_INT 1
14562: IFFALSE 14778
// begin wait ( 0 0$1 ) ;
14564: LD_INT 35
14566: PPUSH
14567: CALL_OW 67
// if not HasTask ( ar_mechanic ) or not HasTask ( ar_mechanic_friend ) then
14571: LD_EXP 46
14575: PPUSH
14576: CALL_OW 314
14580: NOT
14581: PUSH
14582: LD_EXP 47
14586: PPUSH
14587: CALL_OW 314
14591: NOT
14592: OR
14593: IFFALSE 14619
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
14595: LD_EXP 46
14599: PUSH
14600: LD_EXP 47
14604: PUSH
14605: EMPTY
14606: LIST
14607: LIST
14608: PPUSH
14609: LD_INT 209
14611: PPUSH
14612: LD_INT 178
14614: PPUSH
14615: CALL_OW 171
// if IsInArea ( ar_mechanic , escape_area ) then
14619: LD_EXP 46
14623: PPUSH
14624: LD_INT 10
14626: PPUSH
14627: CALL_OW 308
14631: IFFALSE 14656
// begin RemoveUnit ( ar_mechanic ) ;
14633: LD_EXP 46
14637: PPUSH
14638: CALL_OW 64
// escaped := escaped + 1 ;
14642: LD_ADDR_VAR 0 5
14646: PUSH
14647: LD_VAR 0 5
14651: PUSH
14652: LD_INT 1
14654: PLUS
14655: ST_TO_ADDR
// end ; if IsInArea ( ar_mechanic_friend , escape_area ) then
14656: LD_EXP 47
14660: PPUSH
14661: LD_INT 10
14663: PPUSH
14664: CALL_OW 308
14668: IFFALSE 14693
// begin RemoveUnit ( ar_mechanic_friend ) ;
14670: LD_EXP 47
14674: PPUSH
14675: CALL_OW 64
// escaped := escaped + 1 ;
14679: LD_ADDR_VAR 0 5
14683: PUSH
14684: LD_VAR 0 5
14688: PUSH
14689: LD_INT 1
14691: PLUS
14692: ST_TO_ADDR
// end ; if IsInArea ( cargo , escape_area ) then
14693: LD_VAR 0 3
14697: PPUSH
14698: LD_INT 10
14700: PPUSH
14701: CALL_OW 308
14705: IFFALSE 14716
// RemoveUnit ( cargo ) ;
14707: LD_VAR 0 3
14711: PPUSH
14712: CALL_OW 64
// if not IsPlaced ( ar_mechanic ) and escaped >= 2 then
14716: LD_EXP 46
14720: PPUSH
14721: CALL_OW 305
14725: NOT
14726: PUSH
14727: LD_VAR 0 5
14731: PUSH
14732: LD_INT 2
14734: GREATEREQUAL
14735: AND
14736: IFFALSE 14740
// break ;
14738: GO 14778
// if not IsPlaced ( ar_mechanic ) and not IsPlaced ( ar_mechanic_friend ) and escaped < 2 then
14740: LD_EXP 46
14744: PPUSH
14745: CALL_OW 305
14749: NOT
14750: PUSH
14751: LD_EXP 47
14755: PPUSH
14756: CALL_OW 305
14760: NOT
14761: AND
14762: PUSH
14763: LD_VAR 0 5
14767: PUSH
14768: LD_INT 2
14770: LESS
14771: AND
14772: IFFALSE 14776
// exit ;
14774: GO 14956
// end ;
14776: GO 14560
// wait ( 0 0$2 ) ;
14778: LD_INT 70
14780: PPUSH
14781: CALL_OW 67
// SayRadio ( ar_mechanic , D7a-Ar1-1 ) ;
14785: LD_EXP 46
14789: PPUSH
14790: LD_STRING D7a-Ar1-1
14792: PPUSH
14793: CALL_OW 94
// tmp := [ [ 129 , 10 ] , [ 103 , 6 ] , [ 148 , 47 ] , [ 155 , 16 ] ] ;
14797: LD_ADDR_VAR 0 4
14801: PUSH
14802: LD_INT 129
14804: PUSH
14805: LD_INT 10
14807: PUSH
14808: EMPTY
14809: LIST
14810: LIST
14811: PUSH
14812: LD_INT 103
14814: PUSH
14815: LD_INT 6
14817: PUSH
14818: EMPTY
14819: LIST
14820: LIST
14821: PUSH
14822: LD_INT 148
14824: PUSH
14825: LD_INT 47
14827: PUSH
14828: EMPTY
14829: LIST
14830: LIST
14831: PUSH
14832: LD_INT 155
14834: PUSH
14835: LD_INT 16
14837: PUSH
14838: EMPTY
14839: LIST
14840: LIST
14841: PUSH
14842: EMPTY
14843: LIST
14844: LIST
14845: LIST
14846: LIST
14847: ST_TO_ADDR
// if Difficulty = 1 then
14848: LD_OWVAR 67
14852: PUSH
14853: LD_INT 1
14855: EQUAL
14856: IFFALSE 14893
// tmp := tmp ^ [ [ 78 , 7 ] , [ 104 , 43 ] ] ;
14858: LD_ADDR_VAR 0 4
14862: PUSH
14863: LD_VAR 0 4
14867: PUSH
14868: LD_INT 78
14870: PUSH
14871: LD_INT 7
14873: PUSH
14874: EMPTY
14875: LIST
14876: LIST
14877: PUSH
14878: LD_INT 104
14880: PUSH
14881: LD_INT 43
14883: PUSH
14884: EMPTY
14885: LIST
14886: LIST
14887: PUSH
14888: EMPTY
14889: LIST
14890: LIST
14891: ADD
14892: ST_TO_ADDR
// for i in tmp do
14893: LD_ADDR_VAR 0 2
14897: PUSH
14898: LD_VAR 0 4
14902: PUSH
14903: FOR_IN
14904: IFFALSE 14937
// PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 9 ) ;
14906: LD_VAR 0 2
14910: PUSH
14911: LD_INT 1
14913: ARRAY
14914: PPUSH
14915: LD_VAR 0 2
14919: PUSH
14920: LD_INT 2
14922: ARRAY
14923: PPUSH
14924: LD_INT 1
14926: PPUSH
14927: LD_INT 9
14929: NEG
14930: PPUSH
14931: CALL_OW 330
14935: GO 14903
14937: POP
14938: POP
// SetAchievement ( ACH_FRIEND ) ;
14939: LD_STRING ACH_FRIEND
14941: PPUSH
14942: CALL_OW 543
// CenterOnXY ( 129 , 10 ) ;
14946: LD_INT 129
14948: PPUSH
14949: LD_INT 10
14951: PPUSH
14952: CALL_OW 84
// end ;
14956: PPOPN 5
14958: END
// every 0 0$1 trigger game_time - 10 10$00 <= tick do
14959: LD_EXP 15
14963: PUSH
14964: LD_INT 21000
14966: MINUS
14967: PUSH
14968: LD_OWVAR 1
14972: LESSEQUAL
14973: IFFALSE 15013
14975: GO 14977
14977: DISABLE
// begin powell_warn := true ;
14978: LD_ADDR_EXP 16
14982: PUSH
14983: LD_INT 1
14985: ST_TO_ADDR
// DialogueOn ;
14986: CALL_OW 6
// SayRadio ( Powell , D9-Pow-1 ) ;
14990: LD_EXP 30
14994: PPUSH
14995: LD_STRING D9-Pow-1
14997: PPUSH
14998: CALL_OW 94
// dwait ( 0 0$0.3 ) ;
15002: LD_INT 10
15004: PPUSH
15005: CALL_OW 68
// DialogueOff ;
15009: CALL_OW 7
// end ;
15013: END
// every 0 0$1 trigger game_time <= tick do
15014: LD_EXP 15
15018: PUSH
15019: LD_OWVAR 1
15023: LESSEQUAL
15024: IFFALSE 15063
15026: GO 15028
15028: DISABLE
// begin DialogueOn ;
15029: CALL_OW 6
// SayRadio ( Powell , D9a-Pow-1 ) ;
15033: LD_EXP 30
15037: PPUSH
15038: LD_STRING D9a-Pow-1
15040: PPUSH
15041: CALL_OW 94
// dwait ( 0 0$2 ) ;
15045: LD_INT 70
15047: PPUSH
15048: CALL_OW 68
// DialogueOff ;
15052: CALL_OW 7
// YouLost ( Command ) ;
15056: LD_STRING Command
15058: PPUSH
15059: CALL_OW 104
// end ;
15063: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_warehouse ] ] ) = 0 and IsOk ( JMM ) do var tmp , m1 , m2 , m3 ;
15064: LD_INT 22
15066: PUSH
15067: LD_INT 2
15069: PUSH
15070: EMPTY
15071: LIST
15072: LIST
15073: PUSH
15074: LD_INT 30
15076: PUSH
15077: LD_INT 1
15079: PUSH
15080: EMPTY
15081: LIST
15082: LIST
15083: PUSH
15084: EMPTY
15085: LIST
15086: LIST
15087: PPUSH
15088: CALL_OW 69
15092: PUSH
15093: LD_INT 0
15095: EQUAL
15096: PUSH
15097: LD_EXP 21
15101: PPUSH
15102: CALL_OW 302
15106: AND
15107: IFFALSE 16016
15109: GO 15111
15111: DISABLE
15112: LD_INT 0
15114: PPUSH
15115: PPUSH
15116: PPUSH
15117: PPUSH
// begin m1 := false ;
15118: LD_ADDR_VAR 0 2
15122: PUSH
15123: LD_INT 0
15125: ST_TO_ADDR
// m2 := false ;
15126: LD_ADDR_VAR 0 3
15130: PUSH
15131: LD_INT 0
15133: ST_TO_ADDR
// m3 := false ;
15134: LD_ADDR_VAR 0 4
15138: PUSH
15139: LD_INT 0
15141: ST_TO_ADDR
// if not am_veh_consturcted then
15142: LD_EXP 20
15146: NOT
15147: IFFALSE 15156
// SetAchievement ( ACH_ARABTECH ) ;
15149: LD_STRING ACH_ARABTECH
15151: PPUSH
15152: CALL_OW 543
// if tick < [ 120 120$00 , 100 100$00 , 95 95$00 ] [ Difficulty ] then
15156: LD_OWVAR 1
15160: PUSH
15161: LD_INT 252000
15163: PUSH
15164: LD_INT 210000
15166: PUSH
15167: LD_INT 199500
15169: PUSH
15170: EMPTY
15171: LIST
15172: LIST
15173: LIST
15174: PUSH
15175: LD_OWVAR 67
15179: ARRAY
15180: LESS
15181: IFFALSE 15203
// begin m3 := true ;
15183: LD_ADDR_VAR 0 4
15187: PUSH
15188: LD_INT 1
15190: ST_TO_ADDR
// AddMedal ( Time1 , 1 ) ;
15191: LD_STRING Time1
15193: PPUSH
15194: LD_INT 1
15196: PPUSH
15197: CALL_OW 101
// end else
15201: GO 15234
// if not powell_warn then
15203: LD_EXP 16
15207: NOT
15208: IFFALSE 15223
// AddMedal ( Time1 , - 1 ) else
15210: LD_STRING Time1
15212: PPUSH
15213: LD_INT 1
15215: NEG
15216: PPUSH
15217: CALL_OW 101
15221: GO 15234
// AddMedal ( Time1 , - 2 ) ;
15223: LD_STRING Time1
15225: PPUSH
15226: LD_INT 2
15228: NEG
15229: PPUSH
15230: CALL_OW 101
// if loses_counter >= [ 5 , 4 , 3 ] [ Difficulty ] then
15234: LD_EXP 17
15238: PUSH
15239: LD_INT 5
15241: PUSH
15242: LD_INT 4
15244: PUSH
15245: LD_INT 3
15247: PUSH
15248: EMPTY
15249: LIST
15250: LIST
15251: LIST
15252: PUSH
15253: LD_OWVAR 67
15257: ARRAY
15258: GREATEREQUAL
15259: IFFALSE 15274
// AddMedal ( Destroy , - 2 ) else
15261: LD_STRING Destroy
15263: PPUSH
15264: LD_INT 2
15266: NEG
15267: PPUSH
15268: CALL_OW 101
15272: GO 15407
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 25 then
15274: LD_INT 22
15276: PUSH
15277: LD_INT 2
15279: PUSH
15280: EMPTY
15281: LIST
15282: LIST
15283: PUSH
15284: LD_INT 21
15286: PUSH
15287: LD_INT 3
15289: PUSH
15290: EMPTY
15291: LIST
15292: LIST
15293: PUSH
15294: LD_INT 50
15296: PUSH
15297: EMPTY
15298: LIST
15299: PUSH
15300: EMPTY
15301: LIST
15302: LIST
15303: LIST
15304: PPUSH
15305: CALL_OW 69
15309: PUSH
15310: LD_INT 25
15312: GREATEREQUAL
15313: IFFALSE 15328
// AddMedal ( Destroy , - 1 ) else
15315: LD_STRING Destroy
15317: PPUSH
15318: LD_INT 1
15320: NEG
15321: PPUSH
15322: CALL_OW 101
15326: GO 15407
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 15 then
15328: LD_INT 22
15330: PUSH
15331: LD_INT 2
15333: PUSH
15334: EMPTY
15335: LIST
15336: LIST
15337: PUSH
15338: LD_INT 21
15340: PUSH
15341: LD_INT 3
15343: PUSH
15344: EMPTY
15345: LIST
15346: LIST
15347: PUSH
15348: LD_INT 50
15350: PUSH
15351: EMPTY
15352: LIST
15353: PUSH
15354: EMPTY
15355: LIST
15356: LIST
15357: LIST
15358: PPUSH
15359: CALL_OW 69
15363: PUSH
15364: LD_INT 15
15366: GREATEREQUAL
15367: IFFALSE 15389
// begin m1 := true ;
15369: LD_ADDR_VAR 0 2
15373: PUSH
15374: LD_INT 1
15376: ST_TO_ADDR
// AddMedal ( Destroy , 1 ) ;
15377: LD_STRING Destroy
15379: PPUSH
15380: LD_INT 1
15382: PPUSH
15383: CALL_OW 101
// end else
15387: GO 15407
// begin m1 := true ;
15389: LD_ADDR_VAR 0 2
15393: PUSH
15394: LD_INT 1
15396: ST_TO_ADDR
// AddMedal ( Destroy , 2 ) ;
15397: LD_STRING Destroy
15399: PPUSH
15400: LD_INT 2
15402: PPUSH
15403: CALL_OW 101
// end ; SaveVariable ( artifact_get , 11_artifact_captured ) ;
15407: LD_EXP 13
15411: PPUSH
15412: LD_STRING 11_artifact_captured
15414: PPUSH
15415: CALL_OW 39
// if artifact_get then
15419: LD_EXP 13
15423: IFFALSE 15445
// begin m2 := true ;
15425: LD_ADDR_VAR 0 3
15429: PUSH
15430: LD_INT 1
15432: ST_TO_ADDR
// AddMedal ( Artefact , 1 ) ;
15433: LD_STRING Artefact
15435: PPUSH
15436: LD_INT 1
15438: PPUSH
15439: CALL_OW 101
// end else
15443: GO 15456
// AddMedal ( Artefact , - 1 ) ;
15445: LD_STRING Artefact
15447: PPUSH
15448: LD_INT 1
15450: NEG
15451: PPUSH
15452: CALL_OW 101
// if m1 and m2 and m3 and Difficulty = 3 then
15456: LD_VAR 0 2
15460: PUSH
15461: LD_VAR 0 3
15465: AND
15466: PUSH
15467: LD_VAR 0 4
15471: AND
15472: PUSH
15473: LD_OWVAR 67
15477: PUSH
15478: LD_INT 3
15480: EQUAL
15481: AND
15482: IFFALSE 15494
// SetAchievementEX ( ACH_AMER , 11 ) ;
15484: LD_STRING ACH_AMER
15486: PPUSH
15487: LD_INT 11
15489: PPUSH
15490: CALL_OW 564
// if m1 and m2 and m3 and loses_counter = 0 then
15494: LD_VAR 0 2
15498: PUSH
15499: LD_VAR 0 3
15503: AND
15504: PUSH
15505: LD_VAR 0 4
15509: AND
15510: PUSH
15511: LD_EXP 17
15515: PUSH
15516: LD_INT 0
15518: EQUAL
15519: AND
15520: IFFALSE 15536
// begin wait ( 3 ) ;
15522: LD_INT 3
15524: PPUSH
15525: CALL_OW 67
// SetAchievement ( ACH_GENERAL ) ;
15529: LD_STRING ACH_GENERAL
15531: PPUSH
15532: CALL_OW 543
// end ; if tick <= 100 100$00 then
15536: LD_OWVAR 1
15540: PUSH
15541: LD_INT 210000
15543: LESSEQUAL
15544: IFFALSE 15560
// begin wait ( 3 ) ;
15546: LD_INT 3
15548: PPUSH
15549: CALL_OW 67
// SetAchievement ( ACH_ASPEED_11 ) ;
15553: LD_STRING ACH_ASPEED_11
15555: PPUSH
15556: CALL_OW 543
// end ; GiveMedals ( MAIN ) ;
15560: LD_STRING MAIN
15562: PPUSH
15563: CALL_OW 102
// selected := UnitFilter ( selected , [ f_alive ] ) ;
15567: LD_ADDR_EXP 19
15571: PUSH
15572: LD_EXP 19
15576: PPUSH
15577: LD_INT 51
15579: PUSH
15580: EMPTY
15581: LIST
15582: PPUSH
15583: CALL_OW 72
15587: ST_TO_ADDR
// tmp := JMM ^ selected ;
15588: LD_ADDR_VAR 0 1
15592: PUSH
15593: LD_EXP 21
15597: PUSH
15598: LD_EXP 19
15602: ADD
15603: ST_TO_ADDR
// RewardPeople ( tmp ) ;
15604: LD_VAR 0 1
15608: PPUSH
15609: CALL_OW 43
// SaveCharacters ( tmp diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , 11c_others ) ;
15613: LD_VAR 0 1
15617: PUSH
15618: LD_EXP 21
15622: PUSH
15623: LD_EXP 22
15627: PUSH
15628: LD_EXP 23
15632: PUSH
15633: LD_EXP 24
15637: PUSH
15638: LD_EXP 25
15642: PUSH
15643: LD_EXP 26
15647: PUSH
15648: LD_EXP 27
15652: PUSH
15653: LD_EXP 28
15657: PUSH
15658: LD_EXP 29
15662: PUSH
15663: LD_EXP 31
15667: PUSH
15668: LD_EXP 32
15672: PUSH
15673: LD_EXP 33
15677: PUSH
15678: LD_EXP 34
15682: PUSH
15683: EMPTY
15684: LIST
15685: LIST
15686: LIST
15687: LIST
15688: LIST
15689: LIST
15690: LIST
15691: LIST
15692: LIST
15693: LIST
15694: LIST
15695: LIST
15696: LIST
15697: DIFF
15698: PPUSH
15699: LD_STRING 11c_others
15701: PPUSH
15702: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
15706: LD_EXP 21
15710: PPUSH
15711: LD_EXP 3
15715: PUSH
15716: LD_STRING JMM
15718: STR
15719: PPUSH
15720: CALL_OW 38
// if Lisa then
15724: LD_EXP 22
15728: IFFALSE 15748
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
15730: LD_EXP 22
15734: PPUSH
15735: LD_EXP 3
15739: PUSH
15740: LD_STRING Lisa
15742: STR
15743: PPUSH
15744: CALL_OW 38
// if Donaldson then
15748: LD_EXP 23
15752: IFFALSE 15772
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
15754: LD_EXP 23
15758: PPUSH
15759: LD_EXP 3
15763: PUSH
15764: LD_STRING Donaldson
15766: STR
15767: PPUSH
15768: CALL_OW 38
// if Bobby then
15772: LD_EXP 24
15776: IFFALSE 15796
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
15778: LD_EXP 24
15782: PPUSH
15783: LD_EXP 3
15787: PUSH
15788: LD_STRING Bobby
15790: STR
15791: PPUSH
15792: CALL_OW 38
// if Cyrus then
15796: LD_EXP 25
15800: IFFALSE 15820
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
15802: LD_EXP 25
15806: PPUSH
15807: LD_EXP 3
15811: PUSH
15812: LD_STRING Cyrus
15814: STR
15815: PPUSH
15816: CALL_OW 38
// if Denis then
15820: LD_EXP 26
15824: IFFALSE 15844
// SaveCharacters ( Denis , mission_prefix & Denis ) ;
15826: LD_EXP 26
15830: PPUSH
15831: LD_EXP 3
15835: PUSH
15836: LD_STRING Denis
15838: STR
15839: PPUSH
15840: CALL_OW 38
// if Brown then
15844: LD_EXP 27
15848: IFFALSE 15868
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
15850: LD_EXP 27
15854: PPUSH
15855: LD_EXP 3
15859: PUSH
15860: LD_STRING Brown
15862: STR
15863: PPUSH
15864: CALL_OW 38
// if Gladstone then
15868: LD_EXP 28
15872: IFFALSE 15892
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
15874: LD_EXP 28
15878: PPUSH
15879: LD_EXP 3
15883: PUSH
15884: LD_STRING Gladstone
15886: STR
15887: PPUSH
15888: CALL_OW 38
// if Houten then
15892: LD_EXP 29
15896: IFFALSE 15916
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
15898: LD_EXP 29
15902: PPUSH
15903: LD_EXP 3
15907: PUSH
15908: LD_STRING Houten
15910: STR
15911: PPUSH
15912: CALL_OW 38
// if Cornel then
15916: LD_EXP 31
15920: IFFALSE 15940
// SaveCharacters ( Cornel , mission_prefix & Cornell ) ;
15922: LD_EXP 31
15926: PPUSH
15927: LD_EXP 3
15931: PUSH
15932: LD_STRING Cornell
15934: STR
15935: PPUSH
15936: CALL_OW 38
// if Gary then
15940: LD_EXP 32
15944: IFFALSE 15964
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
15946: LD_EXP 32
15950: PPUSH
15951: LD_EXP 3
15955: PUSH
15956: LD_STRING Gary
15958: STR
15959: PPUSH
15960: CALL_OW 38
// if Frank then
15964: LD_EXP 33
15968: IFFALSE 15988
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
15970: LD_EXP 33
15974: PPUSH
15975: LD_EXP 3
15979: PUSH
15980: LD_STRING Frank
15982: STR
15983: PPUSH
15984: CALL_OW 38
// if Kikuchi then
15988: LD_EXP 34
15992: IFFALSE 16012
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
15994: LD_EXP 34
15998: PPUSH
15999: LD_EXP 3
16003: PUSH
16004: LD_STRING Kikuchi
16006: STR
16007: PPUSH
16008: CALL_OW 38
// YouWin ;
16012: CALL_OW 103
// end ;
16016: PPOPN 4
16018: END
// export function CanSayRand ( side ) ; begin
16019: LD_INT 0
16021: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16022: LD_ADDR_VAR 0 2
16026: PUSH
16027: LD_INT 52
16029: PUSH
16030: EMPTY
16031: LIST
16032: PUSH
16033: LD_INT 22
16035: PUSH
16036: LD_VAR 0 1
16040: PUSH
16041: EMPTY
16042: LIST
16043: LIST
16044: PUSH
16045: LD_INT 2
16047: PUSH
16048: LD_INT 25
16050: PUSH
16051: LD_INT 1
16053: PUSH
16054: EMPTY
16055: LIST
16056: LIST
16057: PUSH
16058: LD_INT 25
16060: PUSH
16061: LD_INT 2
16063: PUSH
16064: EMPTY
16065: LIST
16066: LIST
16067: PUSH
16068: LD_INT 25
16070: PUSH
16071: LD_INT 3
16073: PUSH
16074: EMPTY
16075: LIST
16076: LIST
16077: PUSH
16078: LD_INT 25
16080: PUSH
16081: LD_INT 4
16083: PUSH
16084: EMPTY
16085: LIST
16086: LIST
16087: PUSH
16088: EMPTY
16089: LIST
16090: LIST
16091: LIST
16092: LIST
16093: LIST
16094: PUSH
16095: EMPTY
16096: LIST
16097: LIST
16098: LIST
16099: PPUSH
16100: CALL_OW 69
16104: PUSH
16105: LD_EXP 21
16109: PUSH
16110: LD_EXP 33
16114: PUSH
16115: LD_EXP 22
16119: PUSH
16120: LD_EXP 23
16124: PUSH
16125: LD_EXP 24
16129: PUSH
16130: LD_EXP 25
16134: PUSH
16135: LD_EXP 26
16139: PUSH
16140: LD_EXP 27
16144: PUSH
16145: LD_EXP 28
16149: PUSH
16150: LD_EXP 29
16154: PUSH
16155: LD_EXP 30
16159: PUSH
16160: LD_EXP 31
16164: PUSH
16165: LD_EXP 32
16169: PUSH
16170: LD_EXP 34
16174: PUSH
16175: EMPTY
16176: LIST
16177: LIST
16178: LIST
16179: LIST
16180: LIST
16181: LIST
16182: LIST
16183: LIST
16184: LIST
16185: LIST
16186: LIST
16187: LIST
16188: LIST
16189: LIST
16190: DIFF
16191: ST_TO_ADDR
// end ;
16192: LD_VAR 0 2
16196: RET
// export function SayRand ( sex , dial ) ; begin
16197: LD_INT 0
16199: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16200: LD_ADDR_VAR 0 3
16204: PUSH
16205: LD_INT 52
16207: PUSH
16208: EMPTY
16209: LIST
16210: PUSH
16211: LD_INT 22
16213: PUSH
16214: LD_INT 1
16216: PUSH
16217: EMPTY
16218: LIST
16219: LIST
16220: PUSH
16221: LD_INT 26
16223: PUSH
16224: LD_VAR 0 1
16228: PUSH
16229: EMPTY
16230: LIST
16231: LIST
16232: PUSH
16233: LD_INT 2
16235: PUSH
16236: LD_INT 25
16238: PUSH
16239: LD_INT 1
16241: PUSH
16242: EMPTY
16243: LIST
16244: LIST
16245: PUSH
16246: LD_INT 25
16248: PUSH
16249: LD_INT 2
16251: PUSH
16252: EMPTY
16253: LIST
16254: LIST
16255: PUSH
16256: LD_INT 25
16258: PUSH
16259: LD_INT 3
16261: PUSH
16262: EMPTY
16263: LIST
16264: LIST
16265: PUSH
16266: LD_INT 25
16268: PUSH
16269: LD_INT 4
16271: PUSH
16272: EMPTY
16273: LIST
16274: LIST
16275: PUSH
16276: EMPTY
16277: LIST
16278: LIST
16279: LIST
16280: LIST
16281: LIST
16282: PUSH
16283: EMPTY
16284: LIST
16285: LIST
16286: LIST
16287: LIST
16288: PPUSH
16289: CALL_OW 69
16293: PUSH
16294: LD_EXP 21
16298: PUSH
16299: LD_EXP 33
16303: PUSH
16304: LD_EXP 22
16308: PUSH
16309: LD_EXP 23
16313: PUSH
16314: LD_EXP 24
16318: PUSH
16319: LD_EXP 25
16323: PUSH
16324: LD_EXP 26
16328: PUSH
16329: LD_EXP 27
16333: PUSH
16334: LD_EXP 28
16338: PUSH
16339: LD_EXP 29
16343: PUSH
16344: LD_EXP 30
16348: PUSH
16349: LD_EXP 31
16353: PUSH
16354: LD_EXP 32
16358: PUSH
16359: LD_EXP 34
16363: PUSH
16364: EMPTY
16365: LIST
16366: LIST
16367: LIST
16368: LIST
16369: LIST
16370: LIST
16371: LIST
16372: LIST
16373: LIST
16374: LIST
16375: LIST
16376: LIST
16377: LIST
16378: LIST
16379: DIFF
16380: ST_TO_ADDR
// if not result then
16381: LD_VAR 0 3
16385: NOT
16386: IFFALSE 16390
// exit ;
16388: GO 16418
// result := result [ 1 ] ;
16390: LD_ADDR_VAR 0 3
16394: PUSH
16395: LD_VAR 0 3
16399: PUSH
16400: LD_INT 1
16402: ARRAY
16403: ST_TO_ADDR
// Say ( result , dial ) ;
16404: LD_VAR 0 3
16408: PPUSH
16409: LD_VAR 0 2
16413: PPUSH
16414: CALL_OW 88
// end ;
16418: LD_VAR 0 3
16422: RET
// export function SayRand2 ( sex , dial , filter ) ; begin
16423: LD_INT 0
16425: PPUSH
// result := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ^ filter ;
16426: LD_ADDR_VAR 0 4
16430: PUSH
16431: LD_INT 22
16433: PUSH
16434: LD_INT 1
16436: PUSH
16437: EMPTY
16438: LIST
16439: LIST
16440: PUSH
16441: LD_INT 26
16443: PUSH
16444: LD_VAR 0 1
16448: PUSH
16449: EMPTY
16450: LIST
16451: LIST
16452: PUSH
16453: LD_INT 2
16455: PUSH
16456: LD_INT 25
16458: PUSH
16459: LD_INT 1
16461: PUSH
16462: EMPTY
16463: LIST
16464: LIST
16465: PUSH
16466: LD_INT 25
16468: PUSH
16469: LD_INT 2
16471: PUSH
16472: EMPTY
16473: LIST
16474: LIST
16475: PUSH
16476: LD_INT 25
16478: PUSH
16479: LD_INT 3
16481: PUSH
16482: EMPTY
16483: LIST
16484: LIST
16485: PUSH
16486: LD_INT 25
16488: PUSH
16489: LD_INT 4
16491: PUSH
16492: EMPTY
16493: LIST
16494: LIST
16495: PUSH
16496: EMPTY
16497: LIST
16498: LIST
16499: LIST
16500: LIST
16501: LIST
16502: PUSH
16503: EMPTY
16504: LIST
16505: LIST
16506: LIST
16507: PPUSH
16508: CALL_OW 69
16512: PUSH
16513: LD_EXP 21
16517: PUSH
16518: LD_EXP 33
16522: PUSH
16523: LD_EXP 22
16527: PUSH
16528: LD_EXP 23
16532: PUSH
16533: LD_EXP 24
16537: PUSH
16538: LD_EXP 25
16542: PUSH
16543: LD_EXP 26
16547: PUSH
16548: LD_EXP 27
16552: PUSH
16553: LD_EXP 28
16557: PUSH
16558: LD_EXP 29
16562: PUSH
16563: LD_EXP 30
16567: PUSH
16568: LD_EXP 31
16572: PUSH
16573: LD_EXP 32
16577: PUSH
16578: LD_EXP 34
16582: PUSH
16583: EMPTY
16584: LIST
16585: LIST
16586: LIST
16587: LIST
16588: LIST
16589: LIST
16590: LIST
16591: LIST
16592: LIST
16593: LIST
16594: LIST
16595: LIST
16596: LIST
16597: LIST
16598: PUSH
16599: LD_VAR 0 3
16603: ADD
16604: DIFF
16605: ST_TO_ADDR
// if not result then
16606: LD_VAR 0 4
16610: NOT
16611: IFFALSE 16615
// exit ;
16613: GO 16643
// result := result [ 1 ] ;
16615: LD_ADDR_VAR 0 4
16619: PUSH
16620: LD_VAR 0 4
16624: PUSH
16625: LD_INT 1
16627: ARRAY
16628: ST_TO_ADDR
// Say ( result , dial ) ;
16629: LD_VAR 0 4
16633: PPUSH
16634: LD_VAR 0 2
16638: PPUSH
16639: CALL_OW 88
// end ; end_of_file
16643: LD_VAR 0 4
16647: RET
// export function CustomEvent ( event ) ; begin
16648: LD_INT 0
16650: PPUSH
// end ;
16651: LD_VAR 0 2
16655: RET
// on ArtifactLoaded ( cargo , artifact ) do begin if GetSide ( cargo ) = 1 then
16656: LD_VAR 0 1
16660: PPUSH
16661: CALL_OW 255
16665: PUSH
16666: LD_INT 1
16668: EQUAL
16669: IFFALSE 16679
// artifact_get := true ;
16671: LD_ADDR_EXP 13
16675: PUSH
16676: LD_INT 1
16678: ST_TO_ADDR
// if GetSide ( cargo ) = 2 then
16679: LD_VAR 0 1
16683: PPUSH
16684: CALL_OW 255
16688: PUSH
16689: LD_INT 2
16691: EQUAL
16692: IFFALSE 16710
// begin artifact_get := false ;
16694: LD_ADDR_EXP 13
16698: PUSH
16699: LD_INT 0
16701: ST_TO_ADDR
// artifact_stolen := true ;
16702: LD_ADDR_EXP 12
16706: PUSH
16707: LD_INT 1
16709: ST_TO_ADDR
// end ; artifact_oncargo := true ;
16710: LD_ADDR_EXP 14
16714: PUSH
16715: LD_INT 1
16717: ST_TO_ADDR
// end ;
16718: PPOPN 2
16720: END
// on ArtifactUnloaded ( cargo , artifact ) do begin artifact_oncargo := false ;
16721: LD_ADDR_EXP 14
16725: PUSH
16726: LD_INT 0
16728: ST_TO_ADDR
// end ;
16729: PPOPN 2
16731: END
// on UnitDestroyed ( un ) do begin if un = JMM then
16732: LD_VAR 0 1
16736: PUSH
16737: LD_EXP 21
16741: EQUAL
16742: IFFALSE 16753
// begin YouLost ( JMM ) ;
16744: LD_STRING JMM
16746: PPUSH
16747: CALL_OW 104
// exit ;
16751: GO 16885
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) then
16753: LD_VAR 0 1
16757: PUSH
16758: LD_INT 22
16760: PUSH
16761: LD_INT 1
16763: PUSH
16764: EMPTY
16765: LIST
16766: LIST
16767: PUSH
16768: LD_INT 21
16770: PUSH
16771: LD_INT 1
16773: PUSH
16774: EMPTY
16775: LIST
16776: LIST
16777: PUSH
16778: LD_INT 2
16780: PUSH
16781: LD_INT 25
16783: PUSH
16784: LD_INT 1
16786: PUSH
16787: EMPTY
16788: LIST
16789: LIST
16790: PUSH
16791: LD_INT 25
16793: PUSH
16794: LD_INT 2
16796: PUSH
16797: EMPTY
16798: LIST
16799: LIST
16800: PUSH
16801: LD_INT 25
16803: PUSH
16804: LD_INT 3
16806: PUSH
16807: EMPTY
16808: LIST
16809: LIST
16810: PUSH
16811: LD_INT 25
16813: PUSH
16814: LD_INT 4
16816: PUSH
16817: EMPTY
16818: LIST
16819: LIST
16820: PUSH
16821: LD_INT 25
16823: PUSH
16824: LD_INT 5
16826: PUSH
16827: EMPTY
16828: LIST
16829: LIST
16830: PUSH
16831: LD_INT 25
16833: PUSH
16834: LD_INT 8
16836: PUSH
16837: EMPTY
16838: LIST
16839: LIST
16840: PUSH
16841: EMPTY
16842: LIST
16843: LIST
16844: LIST
16845: LIST
16846: LIST
16847: LIST
16848: LIST
16849: PUSH
16850: EMPTY
16851: LIST
16852: LIST
16853: LIST
16854: PPUSH
16855: CALL_OW 69
16859: IN
16860: IFFALSE 16876
// loses_counter := loses_counter + 1 ;
16862: LD_ADDR_EXP 17
16866: PUSH
16867: LD_EXP 17
16871: PUSH
16872: LD_INT 1
16874: PLUS
16875: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
16876: LD_VAR 0 1
16880: PPUSH
16881: CALL 44453 0 1
// end ;
16885: PPOPN 1
16887: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
16888: LD_VAR 0 1
16892: PPUSH
16893: LD_VAR 0 2
16897: PPUSH
16898: CALL 46787 0 2
// end ;
16902: PPOPN 2
16904: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
16905: LD_VAR 0 1
16909: PPUSH
16910: CALL 46096 0 1
// end ;
16914: PPOPN 1
16916: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
16917: LD_VAR 0 1
16921: PPUSH
16922: LD_VAR 0 2
16926: PPUSH
16927: LD_VAR 0 3
16931: PPUSH
16932: LD_VAR 0 4
16936: PPUSH
16937: LD_VAR 0 5
16941: PPUSH
16942: CALL 43769 0 5
// end ;
16946: PPOPN 5
16948: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetNation ( vehicle ) = nation_american then
16949: LD_VAR 0 1
16953: PPUSH
16954: CALL_OW 248
16958: PUSH
16959: LD_INT 1
16961: EQUAL
16962: IFFALSE 16972
// am_veh_consturcted := true ;
16964: LD_ADDR_EXP 20
16968: PUSH
16969: LD_INT 1
16971: ST_TO_ADDR
// MCE_VehicleConstructed ( vehicle , factory ) ;
16972: LD_VAR 0 1
16976: PPUSH
16977: LD_VAR 0 2
16981: PPUSH
16982: CALL 43365 0 2
// end ;
16986: PPOPN 2
16988: END
// on UnitKamikazed ( unit ) do begin if GetType ( unit ) = unit_vehicle then
16989: LD_VAR 0 1
16993: PPUSH
16994: CALL_OW 247
16998: PUSH
16999: LD_INT 2
17001: EQUAL
17002: IFFALSE 17006
// exit ;
17004: GO 17023
// if not kamikazed then
17006: LD_EXP 11
17010: NOT
17011: IFFALSE 17023
// kamikazed := unit ;
17013: LD_ADDR_EXP 11
17017: PUSH
17018: LD_VAR 0 1
17022: ST_TO_ADDR
// end ;
17023: PPOPN 1
17025: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do var i , tmp ;
17026: LD_INT 0
17028: PPUSH
17029: PPUSH
// begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
17030: LD_VAR 0 1
17034: PPUSH
17035: LD_VAR 0 2
17039: PPUSH
17040: LD_VAR 0 3
17044: PPUSH
17045: LD_VAR 0 4
17049: PPUSH
17050: CALL 43203 0 4
// end ;
17054: PPOPN 6
17056: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
17057: LD_VAR 0 1
17061: PPUSH
17062: LD_VAR 0 2
17066: PPUSH
17067: LD_VAR 0 3
17071: PPUSH
17072: CALL 42978 0 3
// end ;
17076: PPOPN 3
17078: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
17079: LD_VAR 0 1
17083: PPUSH
17084: LD_VAR 0 2
17088: PPUSH
17089: CALL 44149 0 2
// end ;
17093: PPOPN 2
17095: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
17096: LD_VAR 0 1
17100: PPUSH
17101: LD_VAR 0 2
17105: PPUSH
17106: CALL 42672 0 2
// end ;
17110: PPOPN 2
17112: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
17113: LD_VAR 0 1
17117: PPUSH
17118: LD_VAR 0 2
17122: PPUSH
17123: CALL 42863 0 2
// end ;
17127: PPOPN 2
17129: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
17130: LD_VAR 0 1
17134: PPUSH
17135: CALL 45855 0 1
// end ;
17139: PPOPN 1
17141: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
17142: LD_VAR 0 1
17146: PPUSH
17147: LD_VAR 0 2
17151: PPUSH
17152: CALL 47048 0 2
// end ;
17156: PPOPN 2
17158: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
17159: LD_VAR 0 1
17163: PPUSH
17164: LD_VAR 0 2
17168: PPUSH
17169: LD_VAR 0 3
17173: PPUSH
17174: LD_VAR 0 4
17178: PPUSH
17179: CALL 47264 0 4
// end ;
17183: PPOPN 4
17185: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
17186: LD_VAR 0 1
17190: PPUSH
17191: CALL 96666 0 1
// end ; end_of_file
17195: PPOPN 1
17197: END
// every 0 0$1 trigger game do
17198: LD_EXP 2
17202: IFFALSE 17232
17204: GO 17206
17206: DISABLE
// SpawnCrates ( [ crates_west , crates_east , crates_north_west , crates_east ] , 0 0$50 ) ;
17207: LD_INT 7
17209: PUSH
17210: LD_INT 6
17212: PUSH
17213: LD_INT 4
17215: PUSH
17216: LD_INT 6
17218: PUSH
17219: EMPTY
17220: LIST
17221: LIST
17222: LIST
17223: LIST
17224: PPUSH
17225: LD_INT 1750
17227: PPUSH
17228: CALL 17233 0 2
17232: END
// export function SpawnCrates ( areas , time ) ; var i , p ; begin
17233: LD_INT 0
17235: PPUSH
17236: PPUSH
17237: PPUSH
// if not areas then
17238: LD_VAR 0 1
17242: NOT
17243: IFFALSE 17247
// exit ;
17245: GO 17377
// repeat wait ( time ) ;
17247: LD_VAR 0 2
17251: PPUSH
17252: CALL_OW 67
// p := rand ( 1 , 90 ) ;
17256: LD_ADDR_VAR 0 5
17260: PUSH
17261: LD_INT 1
17263: PPUSH
17264: LD_INT 90
17266: PPUSH
17267: CALL_OW 12
17271: ST_TO_ADDR
// for i in areas do
17272: LD_ADDR_VAR 0 4
17276: PUSH
17277: LD_VAR 0 1
17281: PUSH
17282: FOR_IN
17283: IFFALSE 17336
// begin if Prob ( p ) then
17285: LD_VAR 0 5
17289: PPUSH
17290: CALL_OW 13
17294: IFFALSE 17334
// begin CreateCratesArea ( rand ( 1 , 5 ) , i , true ) ;
17296: LD_INT 1
17298: PPUSH
17299: LD_INT 5
17301: PPUSH
17302: CALL_OW 12
17306: PPUSH
17307: LD_VAR 0 4
17311: PPUSH
17312: LD_INT 1
17314: PPUSH
17315: CALL_OW 55
// wait ( rand ( 0 0$11 , 0 0$17 ) ) ;
17319: LD_INT 385
17321: PPUSH
17322: LD_INT 595
17324: PPUSH
17325: CALL_OW 12
17329: PPUSH
17330: CALL_OW 67
// end ; end ;
17334: GO 17282
17336: POP
17337: POP
// time := time + 0 0$3 ;
17338: LD_ADDR_VAR 0 2
17342: PUSH
17343: LD_VAR 0 2
17347: PUSH
17348: LD_INT 105
17350: PLUS
17351: ST_TO_ADDR
// if time > 7 7$00 then
17352: LD_VAR 0 2
17356: PUSH
17357: LD_INT 14700
17359: GREATER
17360: IFFALSE 17370
// time := 0 0$40 ;
17362: LD_ADDR_VAR 0 2
17366: PUSH
17367: LD_INT 1400
17369: ST_TO_ADDR
// until not game ;
17370: LD_EXP 2
17374: NOT
17375: IFFALSE 17247
// end ; end_of_file
17377: LD_VAR 0 3
17381: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
17382: LD_INT 0
17384: PPUSH
17385: PPUSH
// skirmish := false ;
17386: LD_ADDR_EXP 48
17390: PUSH
17391: LD_INT 0
17393: ST_TO_ADDR
// debug_mc := false ;
17394: LD_ADDR_EXP 49
17398: PUSH
17399: LD_INT 0
17401: ST_TO_ADDR
// mc_bases := [ ] ;
17402: LD_ADDR_EXP 50
17406: PUSH
17407: EMPTY
17408: ST_TO_ADDR
// mc_sides := [ ] ;
17409: LD_ADDR_EXP 76
17413: PUSH
17414: EMPTY
17415: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
17416: LD_ADDR_EXP 51
17420: PUSH
17421: EMPTY
17422: ST_TO_ADDR
// mc_building_repairs := [ ] ;
17423: LD_ADDR_EXP 52
17427: PUSH
17428: EMPTY
17429: ST_TO_ADDR
// mc_need_heal := [ ] ;
17430: LD_ADDR_EXP 53
17434: PUSH
17435: EMPTY
17436: ST_TO_ADDR
// mc_healers := [ ] ;
17437: LD_ADDR_EXP 54
17441: PUSH
17442: EMPTY
17443: ST_TO_ADDR
// mc_build_list := [ ] ;
17444: LD_ADDR_EXP 55
17448: PUSH
17449: EMPTY
17450: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
17451: LD_ADDR_EXP 82
17455: PUSH
17456: EMPTY
17457: ST_TO_ADDR
// mc_builders := [ ] ;
17458: LD_ADDR_EXP 56
17462: PUSH
17463: EMPTY
17464: ST_TO_ADDR
// mc_construct_list := [ ] ;
17465: LD_ADDR_EXP 57
17469: PUSH
17470: EMPTY
17471: ST_TO_ADDR
// mc_turret_list := [ ] ;
17472: LD_ADDR_EXP 58
17476: PUSH
17477: EMPTY
17478: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
17479: LD_ADDR_EXP 59
17483: PUSH
17484: EMPTY
17485: ST_TO_ADDR
// mc_miners := [ ] ;
17486: LD_ADDR_EXP 64
17490: PUSH
17491: EMPTY
17492: ST_TO_ADDR
// mc_mines := [ ] ;
17493: LD_ADDR_EXP 63
17497: PUSH
17498: EMPTY
17499: ST_TO_ADDR
// mc_minefields := [ ] ;
17500: LD_ADDR_EXP 65
17504: PUSH
17505: EMPTY
17506: ST_TO_ADDR
// mc_crates := [ ] ;
17507: LD_ADDR_EXP 66
17511: PUSH
17512: EMPTY
17513: ST_TO_ADDR
// mc_crates_collector := [ ] ;
17514: LD_ADDR_EXP 67
17518: PUSH
17519: EMPTY
17520: ST_TO_ADDR
// mc_crates_area := [ ] ;
17521: LD_ADDR_EXP 68
17525: PUSH
17526: EMPTY
17527: ST_TO_ADDR
// mc_vehicles := [ ] ;
17528: LD_ADDR_EXP 69
17532: PUSH
17533: EMPTY
17534: ST_TO_ADDR
// mc_attack := [ ] ;
17535: LD_ADDR_EXP 70
17539: PUSH
17540: EMPTY
17541: ST_TO_ADDR
// mc_produce := [ ] ;
17542: LD_ADDR_EXP 71
17546: PUSH
17547: EMPTY
17548: ST_TO_ADDR
// mc_defender := [ ] ;
17549: LD_ADDR_EXP 72
17553: PUSH
17554: EMPTY
17555: ST_TO_ADDR
// mc_parking := [ ] ;
17556: LD_ADDR_EXP 74
17560: PUSH
17561: EMPTY
17562: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
17563: LD_ADDR_EXP 60
17567: PUSH
17568: EMPTY
17569: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
17570: LD_ADDR_EXP 62
17574: PUSH
17575: EMPTY
17576: ST_TO_ADDR
// mc_scan := [ ] ;
17577: LD_ADDR_EXP 73
17581: PUSH
17582: EMPTY
17583: ST_TO_ADDR
// mc_scan_area := [ ] ;
17584: LD_ADDR_EXP 75
17588: PUSH
17589: EMPTY
17590: ST_TO_ADDR
// mc_tech := [ ] ;
17591: LD_ADDR_EXP 77
17595: PUSH
17596: EMPTY
17597: ST_TO_ADDR
// mc_class := [ ] ;
17598: LD_ADDR_EXP 91
17602: PUSH
17603: EMPTY
17604: ST_TO_ADDR
// mc_class_case_use := [ ] ;
17605: LD_ADDR_EXP 92
17609: PUSH
17610: EMPTY
17611: ST_TO_ADDR
// end ;
17612: LD_VAR 0 1
17616: RET
// export function MC_Kill ( base ) ; begin
17617: LD_INT 0
17619: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
17620: LD_ADDR_EXP 50
17624: PUSH
17625: LD_EXP 50
17629: PPUSH
17630: LD_VAR 0 1
17634: PPUSH
17635: EMPTY
17636: PPUSH
17637: CALL_OW 1
17641: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
17642: LD_ADDR_EXP 51
17646: PUSH
17647: LD_EXP 51
17651: PPUSH
17652: LD_VAR 0 1
17656: PPUSH
17657: EMPTY
17658: PPUSH
17659: CALL_OW 1
17663: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
17664: LD_ADDR_EXP 52
17668: PUSH
17669: LD_EXP 52
17673: PPUSH
17674: LD_VAR 0 1
17678: PPUSH
17679: EMPTY
17680: PPUSH
17681: CALL_OW 1
17685: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
17686: LD_ADDR_EXP 53
17690: PUSH
17691: LD_EXP 53
17695: PPUSH
17696: LD_VAR 0 1
17700: PPUSH
17701: EMPTY
17702: PPUSH
17703: CALL_OW 1
17707: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
17708: LD_ADDR_EXP 54
17712: PUSH
17713: LD_EXP 54
17717: PPUSH
17718: LD_VAR 0 1
17722: PPUSH
17723: EMPTY
17724: PPUSH
17725: CALL_OW 1
17729: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
17730: LD_ADDR_EXP 55
17734: PUSH
17735: LD_EXP 55
17739: PPUSH
17740: LD_VAR 0 1
17744: PPUSH
17745: EMPTY
17746: PPUSH
17747: CALL_OW 1
17751: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
17752: LD_ADDR_EXP 56
17756: PUSH
17757: LD_EXP 56
17761: PPUSH
17762: LD_VAR 0 1
17766: PPUSH
17767: EMPTY
17768: PPUSH
17769: CALL_OW 1
17773: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
17774: LD_ADDR_EXP 57
17778: PUSH
17779: LD_EXP 57
17783: PPUSH
17784: LD_VAR 0 1
17788: PPUSH
17789: EMPTY
17790: PPUSH
17791: CALL_OW 1
17795: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
17796: LD_ADDR_EXP 58
17800: PUSH
17801: LD_EXP 58
17805: PPUSH
17806: LD_VAR 0 1
17810: PPUSH
17811: EMPTY
17812: PPUSH
17813: CALL_OW 1
17817: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
17818: LD_ADDR_EXP 59
17822: PUSH
17823: LD_EXP 59
17827: PPUSH
17828: LD_VAR 0 1
17832: PPUSH
17833: EMPTY
17834: PPUSH
17835: CALL_OW 1
17839: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
17840: LD_ADDR_EXP 60
17844: PUSH
17845: LD_EXP 60
17849: PPUSH
17850: LD_VAR 0 1
17854: PPUSH
17855: EMPTY
17856: PPUSH
17857: CALL_OW 1
17861: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
17862: LD_ADDR_EXP 61
17866: PUSH
17867: LD_EXP 61
17871: PPUSH
17872: LD_VAR 0 1
17876: PPUSH
17877: LD_INT 0
17879: PPUSH
17880: CALL_OW 1
17884: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
17885: LD_ADDR_EXP 62
17889: PUSH
17890: LD_EXP 62
17894: PPUSH
17895: LD_VAR 0 1
17899: PPUSH
17900: EMPTY
17901: PPUSH
17902: CALL_OW 1
17906: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
17907: LD_ADDR_EXP 63
17911: PUSH
17912: LD_EXP 63
17916: PPUSH
17917: LD_VAR 0 1
17921: PPUSH
17922: EMPTY
17923: PPUSH
17924: CALL_OW 1
17928: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
17929: LD_ADDR_EXP 64
17933: PUSH
17934: LD_EXP 64
17938: PPUSH
17939: LD_VAR 0 1
17943: PPUSH
17944: EMPTY
17945: PPUSH
17946: CALL_OW 1
17950: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
17951: LD_ADDR_EXP 65
17955: PUSH
17956: LD_EXP 65
17960: PPUSH
17961: LD_VAR 0 1
17965: PPUSH
17966: EMPTY
17967: PPUSH
17968: CALL_OW 1
17972: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
17973: LD_ADDR_EXP 66
17977: PUSH
17978: LD_EXP 66
17982: PPUSH
17983: LD_VAR 0 1
17987: PPUSH
17988: EMPTY
17989: PPUSH
17990: CALL_OW 1
17994: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
17995: LD_ADDR_EXP 67
17999: PUSH
18000: LD_EXP 67
18004: PPUSH
18005: LD_VAR 0 1
18009: PPUSH
18010: EMPTY
18011: PPUSH
18012: CALL_OW 1
18016: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
18017: LD_ADDR_EXP 68
18021: PUSH
18022: LD_EXP 68
18026: PPUSH
18027: LD_VAR 0 1
18031: PPUSH
18032: EMPTY
18033: PPUSH
18034: CALL_OW 1
18038: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
18039: LD_ADDR_EXP 69
18043: PUSH
18044: LD_EXP 69
18048: PPUSH
18049: LD_VAR 0 1
18053: PPUSH
18054: EMPTY
18055: PPUSH
18056: CALL_OW 1
18060: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
18061: LD_ADDR_EXP 70
18065: PUSH
18066: LD_EXP 70
18070: PPUSH
18071: LD_VAR 0 1
18075: PPUSH
18076: EMPTY
18077: PPUSH
18078: CALL_OW 1
18082: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
18083: LD_ADDR_EXP 71
18087: PUSH
18088: LD_EXP 71
18092: PPUSH
18093: LD_VAR 0 1
18097: PPUSH
18098: EMPTY
18099: PPUSH
18100: CALL_OW 1
18104: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
18105: LD_ADDR_EXP 72
18109: PUSH
18110: LD_EXP 72
18114: PPUSH
18115: LD_VAR 0 1
18119: PPUSH
18120: EMPTY
18121: PPUSH
18122: CALL_OW 1
18126: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
18127: LD_ADDR_EXP 73
18131: PUSH
18132: LD_EXP 73
18136: PPUSH
18137: LD_VAR 0 1
18141: PPUSH
18142: EMPTY
18143: PPUSH
18144: CALL_OW 1
18148: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
18149: LD_ADDR_EXP 74
18153: PUSH
18154: LD_EXP 74
18158: PPUSH
18159: LD_VAR 0 1
18163: PPUSH
18164: EMPTY
18165: PPUSH
18166: CALL_OW 1
18170: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
18171: LD_ADDR_EXP 75
18175: PUSH
18176: LD_EXP 75
18180: PPUSH
18181: LD_VAR 0 1
18185: PPUSH
18186: EMPTY
18187: PPUSH
18188: CALL_OW 1
18192: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
18193: LD_ADDR_EXP 77
18197: PUSH
18198: LD_EXP 77
18202: PPUSH
18203: LD_VAR 0 1
18207: PPUSH
18208: EMPTY
18209: PPUSH
18210: CALL_OW 1
18214: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
18215: LD_ADDR_EXP 79
18219: PUSH
18220: LD_EXP 79
18224: PPUSH
18225: LD_VAR 0 1
18229: PPUSH
18230: EMPTY
18231: PPUSH
18232: CALL_OW 1
18236: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
18237: LD_ADDR_EXP 80
18241: PUSH
18242: LD_EXP 80
18246: PPUSH
18247: LD_VAR 0 1
18251: PPUSH
18252: EMPTY
18253: PPUSH
18254: CALL_OW 1
18258: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
18259: LD_ADDR_EXP 81
18263: PUSH
18264: LD_EXP 81
18268: PPUSH
18269: LD_VAR 0 1
18273: PPUSH
18274: EMPTY
18275: PPUSH
18276: CALL_OW 1
18280: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
18281: LD_ADDR_EXP 82
18285: PUSH
18286: LD_EXP 82
18290: PPUSH
18291: LD_VAR 0 1
18295: PPUSH
18296: EMPTY
18297: PPUSH
18298: CALL_OW 1
18302: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
18303: LD_ADDR_EXP 83
18307: PUSH
18308: LD_EXP 83
18312: PPUSH
18313: LD_VAR 0 1
18317: PPUSH
18318: EMPTY
18319: PPUSH
18320: CALL_OW 1
18324: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
18325: LD_ADDR_EXP 84
18329: PUSH
18330: LD_EXP 84
18334: PPUSH
18335: LD_VAR 0 1
18339: PPUSH
18340: EMPTY
18341: PPUSH
18342: CALL_OW 1
18346: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
18347: LD_ADDR_EXP 85
18351: PUSH
18352: LD_EXP 85
18356: PPUSH
18357: LD_VAR 0 1
18361: PPUSH
18362: EMPTY
18363: PPUSH
18364: CALL_OW 1
18368: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
18369: LD_ADDR_EXP 86
18373: PUSH
18374: LD_EXP 86
18378: PPUSH
18379: LD_VAR 0 1
18383: PPUSH
18384: EMPTY
18385: PPUSH
18386: CALL_OW 1
18390: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
18391: LD_ADDR_EXP 87
18395: PUSH
18396: LD_EXP 87
18400: PPUSH
18401: LD_VAR 0 1
18405: PPUSH
18406: EMPTY
18407: PPUSH
18408: CALL_OW 1
18412: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
18413: LD_ADDR_EXP 88
18417: PUSH
18418: LD_EXP 88
18422: PPUSH
18423: LD_VAR 0 1
18427: PPUSH
18428: EMPTY
18429: PPUSH
18430: CALL_OW 1
18434: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
18435: LD_ADDR_EXP 89
18439: PUSH
18440: LD_EXP 89
18444: PPUSH
18445: LD_VAR 0 1
18449: PPUSH
18450: EMPTY
18451: PPUSH
18452: CALL_OW 1
18456: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
18457: LD_ADDR_EXP 90
18461: PUSH
18462: LD_EXP 90
18466: PPUSH
18467: LD_VAR 0 1
18471: PPUSH
18472: EMPTY
18473: PPUSH
18474: CALL_OW 1
18478: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
18479: LD_ADDR_EXP 91
18483: PUSH
18484: LD_EXP 91
18488: PPUSH
18489: LD_VAR 0 1
18493: PPUSH
18494: EMPTY
18495: PPUSH
18496: CALL_OW 1
18500: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
18501: LD_ADDR_EXP 92
18505: PUSH
18506: LD_EXP 92
18510: PPUSH
18511: LD_VAR 0 1
18515: PPUSH
18516: LD_INT 0
18518: PPUSH
18519: CALL_OW 1
18523: ST_TO_ADDR
// end ;
18524: LD_VAR 0 2
18528: RET
// export function MC_Add ( side , units ) ; var base ; begin
18529: LD_INT 0
18531: PPUSH
18532: PPUSH
// base := mc_bases + 1 ;
18533: LD_ADDR_VAR 0 4
18537: PUSH
18538: LD_EXP 50
18542: PUSH
18543: LD_INT 1
18545: PLUS
18546: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
18547: LD_ADDR_EXP 76
18551: PUSH
18552: LD_EXP 76
18556: PPUSH
18557: LD_VAR 0 4
18561: PPUSH
18562: LD_VAR 0 1
18566: PPUSH
18567: CALL_OW 1
18571: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
18572: LD_ADDR_EXP 50
18576: PUSH
18577: LD_EXP 50
18581: PPUSH
18582: LD_VAR 0 4
18586: PPUSH
18587: LD_VAR 0 2
18591: PPUSH
18592: CALL_OW 1
18596: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
18597: LD_ADDR_EXP 51
18601: PUSH
18602: LD_EXP 51
18606: PPUSH
18607: LD_VAR 0 4
18611: PPUSH
18612: EMPTY
18613: PPUSH
18614: CALL_OW 1
18618: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
18619: LD_ADDR_EXP 52
18623: PUSH
18624: LD_EXP 52
18628: PPUSH
18629: LD_VAR 0 4
18633: PPUSH
18634: EMPTY
18635: PPUSH
18636: CALL_OW 1
18640: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
18641: LD_ADDR_EXP 53
18645: PUSH
18646: LD_EXP 53
18650: PPUSH
18651: LD_VAR 0 4
18655: PPUSH
18656: EMPTY
18657: PPUSH
18658: CALL_OW 1
18662: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
18663: LD_ADDR_EXP 54
18667: PUSH
18668: LD_EXP 54
18672: PPUSH
18673: LD_VAR 0 4
18677: PPUSH
18678: EMPTY
18679: PPUSH
18680: CALL_OW 1
18684: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
18685: LD_ADDR_EXP 55
18689: PUSH
18690: LD_EXP 55
18694: PPUSH
18695: LD_VAR 0 4
18699: PPUSH
18700: EMPTY
18701: PPUSH
18702: CALL_OW 1
18706: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
18707: LD_ADDR_EXP 56
18711: PUSH
18712: LD_EXP 56
18716: PPUSH
18717: LD_VAR 0 4
18721: PPUSH
18722: EMPTY
18723: PPUSH
18724: CALL_OW 1
18728: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
18729: LD_ADDR_EXP 57
18733: PUSH
18734: LD_EXP 57
18738: PPUSH
18739: LD_VAR 0 4
18743: PPUSH
18744: EMPTY
18745: PPUSH
18746: CALL_OW 1
18750: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
18751: LD_ADDR_EXP 58
18755: PUSH
18756: LD_EXP 58
18760: PPUSH
18761: LD_VAR 0 4
18765: PPUSH
18766: EMPTY
18767: PPUSH
18768: CALL_OW 1
18772: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
18773: LD_ADDR_EXP 59
18777: PUSH
18778: LD_EXP 59
18782: PPUSH
18783: LD_VAR 0 4
18787: PPUSH
18788: EMPTY
18789: PPUSH
18790: CALL_OW 1
18794: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
18795: LD_ADDR_EXP 60
18799: PUSH
18800: LD_EXP 60
18804: PPUSH
18805: LD_VAR 0 4
18809: PPUSH
18810: EMPTY
18811: PPUSH
18812: CALL_OW 1
18816: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
18817: LD_ADDR_EXP 61
18821: PUSH
18822: LD_EXP 61
18826: PPUSH
18827: LD_VAR 0 4
18831: PPUSH
18832: LD_INT 0
18834: PPUSH
18835: CALL_OW 1
18839: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
18840: LD_ADDR_EXP 62
18844: PUSH
18845: LD_EXP 62
18849: PPUSH
18850: LD_VAR 0 4
18854: PPUSH
18855: EMPTY
18856: PPUSH
18857: CALL_OW 1
18861: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
18862: LD_ADDR_EXP 63
18866: PUSH
18867: LD_EXP 63
18871: PPUSH
18872: LD_VAR 0 4
18876: PPUSH
18877: EMPTY
18878: PPUSH
18879: CALL_OW 1
18883: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
18884: LD_ADDR_EXP 64
18888: PUSH
18889: LD_EXP 64
18893: PPUSH
18894: LD_VAR 0 4
18898: PPUSH
18899: EMPTY
18900: PPUSH
18901: CALL_OW 1
18905: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
18906: LD_ADDR_EXP 65
18910: PUSH
18911: LD_EXP 65
18915: PPUSH
18916: LD_VAR 0 4
18920: PPUSH
18921: EMPTY
18922: PPUSH
18923: CALL_OW 1
18927: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
18928: LD_ADDR_EXP 66
18932: PUSH
18933: LD_EXP 66
18937: PPUSH
18938: LD_VAR 0 4
18942: PPUSH
18943: EMPTY
18944: PPUSH
18945: CALL_OW 1
18949: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
18950: LD_ADDR_EXP 67
18954: PUSH
18955: LD_EXP 67
18959: PPUSH
18960: LD_VAR 0 4
18964: PPUSH
18965: EMPTY
18966: PPUSH
18967: CALL_OW 1
18971: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
18972: LD_ADDR_EXP 68
18976: PUSH
18977: LD_EXP 68
18981: PPUSH
18982: LD_VAR 0 4
18986: PPUSH
18987: EMPTY
18988: PPUSH
18989: CALL_OW 1
18993: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
18994: LD_ADDR_EXP 69
18998: PUSH
18999: LD_EXP 69
19003: PPUSH
19004: LD_VAR 0 4
19008: PPUSH
19009: EMPTY
19010: PPUSH
19011: CALL_OW 1
19015: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
19016: LD_ADDR_EXP 70
19020: PUSH
19021: LD_EXP 70
19025: PPUSH
19026: LD_VAR 0 4
19030: PPUSH
19031: EMPTY
19032: PPUSH
19033: CALL_OW 1
19037: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
19038: LD_ADDR_EXP 71
19042: PUSH
19043: LD_EXP 71
19047: PPUSH
19048: LD_VAR 0 4
19052: PPUSH
19053: EMPTY
19054: PPUSH
19055: CALL_OW 1
19059: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
19060: LD_ADDR_EXP 72
19064: PUSH
19065: LD_EXP 72
19069: PPUSH
19070: LD_VAR 0 4
19074: PPUSH
19075: EMPTY
19076: PPUSH
19077: CALL_OW 1
19081: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
19082: LD_ADDR_EXP 73
19086: PUSH
19087: LD_EXP 73
19091: PPUSH
19092: LD_VAR 0 4
19096: PPUSH
19097: EMPTY
19098: PPUSH
19099: CALL_OW 1
19103: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
19104: LD_ADDR_EXP 74
19108: PUSH
19109: LD_EXP 74
19113: PPUSH
19114: LD_VAR 0 4
19118: PPUSH
19119: EMPTY
19120: PPUSH
19121: CALL_OW 1
19125: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
19126: LD_ADDR_EXP 75
19130: PUSH
19131: LD_EXP 75
19135: PPUSH
19136: LD_VAR 0 4
19140: PPUSH
19141: EMPTY
19142: PPUSH
19143: CALL_OW 1
19147: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
19148: LD_ADDR_EXP 77
19152: PUSH
19153: LD_EXP 77
19157: PPUSH
19158: LD_VAR 0 4
19162: PPUSH
19163: EMPTY
19164: PPUSH
19165: CALL_OW 1
19169: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
19170: LD_ADDR_EXP 79
19174: PUSH
19175: LD_EXP 79
19179: PPUSH
19180: LD_VAR 0 4
19184: PPUSH
19185: EMPTY
19186: PPUSH
19187: CALL_OW 1
19191: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
19192: LD_ADDR_EXP 80
19196: PUSH
19197: LD_EXP 80
19201: PPUSH
19202: LD_VAR 0 4
19206: PPUSH
19207: EMPTY
19208: PPUSH
19209: CALL_OW 1
19213: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
19214: LD_ADDR_EXP 81
19218: PUSH
19219: LD_EXP 81
19223: PPUSH
19224: LD_VAR 0 4
19228: PPUSH
19229: EMPTY
19230: PPUSH
19231: CALL_OW 1
19235: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
19236: LD_ADDR_EXP 82
19240: PUSH
19241: LD_EXP 82
19245: PPUSH
19246: LD_VAR 0 4
19250: PPUSH
19251: EMPTY
19252: PPUSH
19253: CALL_OW 1
19257: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
19258: LD_ADDR_EXP 83
19262: PUSH
19263: LD_EXP 83
19267: PPUSH
19268: LD_VAR 0 4
19272: PPUSH
19273: EMPTY
19274: PPUSH
19275: CALL_OW 1
19279: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
19280: LD_ADDR_EXP 84
19284: PUSH
19285: LD_EXP 84
19289: PPUSH
19290: LD_VAR 0 4
19294: PPUSH
19295: EMPTY
19296: PPUSH
19297: CALL_OW 1
19301: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
19302: LD_ADDR_EXP 85
19306: PUSH
19307: LD_EXP 85
19311: PPUSH
19312: LD_VAR 0 4
19316: PPUSH
19317: EMPTY
19318: PPUSH
19319: CALL_OW 1
19323: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
19324: LD_ADDR_EXP 86
19328: PUSH
19329: LD_EXP 86
19333: PPUSH
19334: LD_VAR 0 4
19338: PPUSH
19339: EMPTY
19340: PPUSH
19341: CALL_OW 1
19345: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
19346: LD_ADDR_EXP 87
19350: PUSH
19351: LD_EXP 87
19355: PPUSH
19356: LD_VAR 0 4
19360: PPUSH
19361: EMPTY
19362: PPUSH
19363: CALL_OW 1
19367: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
19368: LD_ADDR_EXP 88
19372: PUSH
19373: LD_EXP 88
19377: PPUSH
19378: LD_VAR 0 4
19382: PPUSH
19383: EMPTY
19384: PPUSH
19385: CALL_OW 1
19389: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
19390: LD_ADDR_EXP 89
19394: PUSH
19395: LD_EXP 89
19399: PPUSH
19400: LD_VAR 0 4
19404: PPUSH
19405: EMPTY
19406: PPUSH
19407: CALL_OW 1
19411: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
19412: LD_ADDR_EXP 90
19416: PUSH
19417: LD_EXP 90
19421: PPUSH
19422: LD_VAR 0 4
19426: PPUSH
19427: EMPTY
19428: PPUSH
19429: CALL_OW 1
19433: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
19434: LD_ADDR_EXP 91
19438: PUSH
19439: LD_EXP 91
19443: PPUSH
19444: LD_VAR 0 4
19448: PPUSH
19449: EMPTY
19450: PPUSH
19451: CALL_OW 1
19455: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
19456: LD_ADDR_EXP 92
19460: PUSH
19461: LD_EXP 92
19465: PPUSH
19466: LD_VAR 0 4
19470: PPUSH
19471: LD_INT 0
19473: PPUSH
19474: CALL_OW 1
19478: ST_TO_ADDR
// result := base ;
19479: LD_ADDR_VAR 0 3
19483: PUSH
19484: LD_VAR 0 4
19488: ST_TO_ADDR
// end ;
19489: LD_VAR 0 3
19493: RET
// export function MC_Start ( ) ; var i ; begin
19494: LD_INT 0
19496: PPUSH
19497: PPUSH
// for i = 1 to mc_bases do
19498: LD_ADDR_VAR 0 2
19502: PUSH
19503: DOUBLE
19504: LD_INT 1
19506: DEC
19507: ST_TO_ADDR
19508: LD_EXP 50
19512: PUSH
19513: FOR_TO
19514: IFFALSE 20591
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
19516: LD_ADDR_EXP 50
19520: PUSH
19521: LD_EXP 50
19525: PPUSH
19526: LD_VAR 0 2
19530: PPUSH
19531: LD_EXP 50
19535: PUSH
19536: LD_VAR 0 2
19540: ARRAY
19541: PUSH
19542: LD_INT 0
19544: DIFF
19545: PPUSH
19546: CALL_OW 1
19550: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
19551: LD_ADDR_EXP 51
19555: PUSH
19556: LD_EXP 51
19560: PPUSH
19561: LD_VAR 0 2
19565: PPUSH
19566: EMPTY
19567: PPUSH
19568: CALL_OW 1
19572: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
19573: LD_ADDR_EXP 52
19577: PUSH
19578: LD_EXP 52
19582: PPUSH
19583: LD_VAR 0 2
19587: PPUSH
19588: EMPTY
19589: PPUSH
19590: CALL_OW 1
19594: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
19595: LD_ADDR_EXP 53
19599: PUSH
19600: LD_EXP 53
19604: PPUSH
19605: LD_VAR 0 2
19609: PPUSH
19610: EMPTY
19611: PPUSH
19612: CALL_OW 1
19616: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
19617: LD_ADDR_EXP 54
19621: PUSH
19622: LD_EXP 54
19626: PPUSH
19627: LD_VAR 0 2
19631: PPUSH
19632: EMPTY
19633: PUSH
19634: EMPTY
19635: PUSH
19636: EMPTY
19637: LIST
19638: LIST
19639: PPUSH
19640: CALL_OW 1
19644: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
19645: LD_ADDR_EXP 55
19649: PUSH
19650: LD_EXP 55
19654: PPUSH
19655: LD_VAR 0 2
19659: PPUSH
19660: EMPTY
19661: PPUSH
19662: CALL_OW 1
19666: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
19667: LD_ADDR_EXP 82
19671: PUSH
19672: LD_EXP 82
19676: PPUSH
19677: LD_VAR 0 2
19681: PPUSH
19682: EMPTY
19683: PPUSH
19684: CALL_OW 1
19688: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
19689: LD_ADDR_EXP 56
19693: PUSH
19694: LD_EXP 56
19698: PPUSH
19699: LD_VAR 0 2
19703: PPUSH
19704: EMPTY
19705: PPUSH
19706: CALL_OW 1
19710: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
19711: LD_ADDR_EXP 57
19715: PUSH
19716: LD_EXP 57
19720: PPUSH
19721: LD_VAR 0 2
19725: PPUSH
19726: EMPTY
19727: PPUSH
19728: CALL_OW 1
19732: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
19733: LD_ADDR_EXP 58
19737: PUSH
19738: LD_EXP 58
19742: PPUSH
19743: LD_VAR 0 2
19747: PPUSH
19748: LD_EXP 50
19752: PUSH
19753: LD_VAR 0 2
19757: ARRAY
19758: PPUSH
19759: LD_INT 2
19761: PUSH
19762: LD_INT 30
19764: PUSH
19765: LD_INT 32
19767: PUSH
19768: EMPTY
19769: LIST
19770: LIST
19771: PUSH
19772: LD_INT 30
19774: PUSH
19775: LD_INT 33
19777: PUSH
19778: EMPTY
19779: LIST
19780: LIST
19781: PUSH
19782: EMPTY
19783: LIST
19784: LIST
19785: LIST
19786: PPUSH
19787: CALL_OW 72
19791: PPUSH
19792: CALL_OW 1
19796: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
19797: LD_ADDR_EXP 59
19801: PUSH
19802: LD_EXP 59
19806: PPUSH
19807: LD_VAR 0 2
19811: PPUSH
19812: LD_EXP 50
19816: PUSH
19817: LD_VAR 0 2
19821: ARRAY
19822: PPUSH
19823: LD_INT 2
19825: PUSH
19826: LD_INT 30
19828: PUSH
19829: LD_INT 32
19831: PUSH
19832: EMPTY
19833: LIST
19834: LIST
19835: PUSH
19836: LD_INT 30
19838: PUSH
19839: LD_INT 31
19841: PUSH
19842: EMPTY
19843: LIST
19844: LIST
19845: PUSH
19846: EMPTY
19847: LIST
19848: LIST
19849: LIST
19850: PUSH
19851: LD_INT 58
19853: PUSH
19854: EMPTY
19855: LIST
19856: PUSH
19857: EMPTY
19858: LIST
19859: LIST
19860: PPUSH
19861: CALL_OW 72
19865: PPUSH
19866: CALL_OW 1
19870: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
19871: LD_ADDR_EXP 60
19875: PUSH
19876: LD_EXP 60
19880: PPUSH
19881: LD_VAR 0 2
19885: PPUSH
19886: EMPTY
19887: PPUSH
19888: CALL_OW 1
19892: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
19893: LD_ADDR_EXP 64
19897: PUSH
19898: LD_EXP 64
19902: PPUSH
19903: LD_VAR 0 2
19907: PPUSH
19908: EMPTY
19909: PPUSH
19910: CALL_OW 1
19914: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
19915: LD_ADDR_EXP 63
19919: PUSH
19920: LD_EXP 63
19924: PPUSH
19925: LD_VAR 0 2
19929: PPUSH
19930: EMPTY
19931: PPUSH
19932: CALL_OW 1
19936: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
19937: LD_ADDR_EXP 65
19941: PUSH
19942: LD_EXP 65
19946: PPUSH
19947: LD_VAR 0 2
19951: PPUSH
19952: EMPTY
19953: PPUSH
19954: CALL_OW 1
19958: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
19959: LD_ADDR_EXP 66
19963: PUSH
19964: LD_EXP 66
19968: PPUSH
19969: LD_VAR 0 2
19973: PPUSH
19974: EMPTY
19975: PPUSH
19976: CALL_OW 1
19980: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
19981: LD_ADDR_EXP 67
19985: PUSH
19986: LD_EXP 67
19990: PPUSH
19991: LD_VAR 0 2
19995: PPUSH
19996: EMPTY
19997: PPUSH
19998: CALL_OW 1
20002: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
20003: LD_ADDR_EXP 68
20007: PUSH
20008: LD_EXP 68
20012: PPUSH
20013: LD_VAR 0 2
20017: PPUSH
20018: EMPTY
20019: PPUSH
20020: CALL_OW 1
20024: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
20025: LD_ADDR_EXP 69
20029: PUSH
20030: LD_EXP 69
20034: PPUSH
20035: LD_VAR 0 2
20039: PPUSH
20040: EMPTY
20041: PPUSH
20042: CALL_OW 1
20046: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
20047: LD_ADDR_EXP 70
20051: PUSH
20052: LD_EXP 70
20056: PPUSH
20057: LD_VAR 0 2
20061: PPUSH
20062: EMPTY
20063: PPUSH
20064: CALL_OW 1
20068: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
20069: LD_ADDR_EXP 71
20073: PUSH
20074: LD_EXP 71
20078: PPUSH
20079: LD_VAR 0 2
20083: PPUSH
20084: EMPTY
20085: PPUSH
20086: CALL_OW 1
20090: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
20091: LD_ADDR_EXP 72
20095: PUSH
20096: LD_EXP 72
20100: PPUSH
20101: LD_VAR 0 2
20105: PPUSH
20106: EMPTY
20107: PPUSH
20108: CALL_OW 1
20112: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
20113: LD_ADDR_EXP 61
20117: PUSH
20118: LD_EXP 61
20122: PPUSH
20123: LD_VAR 0 2
20127: PPUSH
20128: LD_INT 0
20130: PPUSH
20131: CALL_OW 1
20135: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
20136: LD_ADDR_EXP 74
20140: PUSH
20141: LD_EXP 74
20145: PPUSH
20146: LD_VAR 0 2
20150: PPUSH
20151: LD_INT 0
20153: PPUSH
20154: CALL_OW 1
20158: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
20159: LD_ADDR_EXP 62
20163: PUSH
20164: LD_EXP 62
20168: PPUSH
20169: LD_VAR 0 2
20173: PPUSH
20174: EMPTY
20175: PPUSH
20176: CALL_OW 1
20180: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
20181: LD_ADDR_EXP 73
20185: PUSH
20186: LD_EXP 73
20190: PPUSH
20191: LD_VAR 0 2
20195: PPUSH
20196: LD_INT 0
20198: PPUSH
20199: CALL_OW 1
20203: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
20204: LD_ADDR_EXP 75
20208: PUSH
20209: LD_EXP 75
20213: PPUSH
20214: LD_VAR 0 2
20218: PPUSH
20219: EMPTY
20220: PPUSH
20221: CALL_OW 1
20225: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
20226: LD_ADDR_EXP 78
20230: PUSH
20231: LD_EXP 78
20235: PPUSH
20236: LD_VAR 0 2
20240: PPUSH
20241: LD_INT 0
20243: PPUSH
20244: CALL_OW 1
20248: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
20249: LD_ADDR_EXP 79
20253: PUSH
20254: LD_EXP 79
20258: PPUSH
20259: LD_VAR 0 2
20263: PPUSH
20264: EMPTY
20265: PPUSH
20266: CALL_OW 1
20270: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
20271: LD_ADDR_EXP 80
20275: PUSH
20276: LD_EXP 80
20280: PPUSH
20281: LD_VAR 0 2
20285: PPUSH
20286: EMPTY
20287: PPUSH
20288: CALL_OW 1
20292: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
20293: LD_ADDR_EXP 81
20297: PUSH
20298: LD_EXP 81
20302: PPUSH
20303: LD_VAR 0 2
20307: PPUSH
20308: EMPTY
20309: PPUSH
20310: CALL_OW 1
20314: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
20315: LD_ADDR_EXP 83
20319: PUSH
20320: LD_EXP 83
20324: PPUSH
20325: LD_VAR 0 2
20329: PPUSH
20330: LD_EXP 50
20334: PUSH
20335: LD_VAR 0 2
20339: ARRAY
20340: PPUSH
20341: LD_INT 2
20343: PUSH
20344: LD_INT 30
20346: PUSH
20347: LD_INT 6
20349: PUSH
20350: EMPTY
20351: LIST
20352: LIST
20353: PUSH
20354: LD_INT 30
20356: PUSH
20357: LD_INT 7
20359: PUSH
20360: EMPTY
20361: LIST
20362: LIST
20363: PUSH
20364: LD_INT 30
20366: PUSH
20367: LD_INT 8
20369: PUSH
20370: EMPTY
20371: LIST
20372: LIST
20373: PUSH
20374: EMPTY
20375: LIST
20376: LIST
20377: LIST
20378: LIST
20379: PPUSH
20380: CALL_OW 72
20384: PPUSH
20385: CALL_OW 1
20389: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
20390: LD_ADDR_EXP 84
20394: PUSH
20395: LD_EXP 84
20399: PPUSH
20400: LD_VAR 0 2
20404: PPUSH
20405: EMPTY
20406: PPUSH
20407: CALL_OW 1
20411: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
20412: LD_ADDR_EXP 85
20416: PUSH
20417: LD_EXP 85
20421: PPUSH
20422: LD_VAR 0 2
20426: PPUSH
20427: EMPTY
20428: PPUSH
20429: CALL_OW 1
20433: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
20434: LD_ADDR_EXP 86
20438: PUSH
20439: LD_EXP 86
20443: PPUSH
20444: LD_VAR 0 2
20448: PPUSH
20449: EMPTY
20450: PPUSH
20451: CALL_OW 1
20455: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
20456: LD_ADDR_EXP 87
20460: PUSH
20461: LD_EXP 87
20465: PPUSH
20466: LD_VAR 0 2
20470: PPUSH
20471: EMPTY
20472: PPUSH
20473: CALL_OW 1
20477: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
20478: LD_ADDR_EXP 88
20482: PUSH
20483: LD_EXP 88
20487: PPUSH
20488: LD_VAR 0 2
20492: PPUSH
20493: EMPTY
20494: PPUSH
20495: CALL_OW 1
20499: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
20500: LD_ADDR_EXP 89
20504: PUSH
20505: LD_EXP 89
20509: PPUSH
20510: LD_VAR 0 2
20514: PPUSH
20515: EMPTY
20516: PPUSH
20517: CALL_OW 1
20521: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
20522: LD_ADDR_EXP 90
20526: PUSH
20527: LD_EXP 90
20531: PPUSH
20532: LD_VAR 0 2
20536: PPUSH
20537: EMPTY
20538: PPUSH
20539: CALL_OW 1
20543: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
20544: LD_ADDR_EXP 91
20548: PUSH
20549: LD_EXP 91
20553: PPUSH
20554: LD_VAR 0 2
20558: PPUSH
20559: EMPTY
20560: PPUSH
20561: CALL_OW 1
20565: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
20566: LD_ADDR_EXP 92
20570: PUSH
20571: LD_EXP 92
20575: PPUSH
20576: LD_VAR 0 2
20580: PPUSH
20581: LD_INT 0
20583: PPUSH
20584: CALL_OW 1
20588: ST_TO_ADDR
// end ;
20589: GO 19513
20591: POP
20592: POP
// MC_InitSides ( ) ;
20593: CALL 20879 0 0
// MC_InitResearch ( ) ;
20597: CALL 20618 0 0
// CustomInitMacro ( ) ;
20601: CALL 300 0 0
// skirmish := true ;
20605: LD_ADDR_EXP 48
20609: PUSH
20610: LD_INT 1
20612: ST_TO_ADDR
// end ;
20613: LD_VAR 0 1
20617: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
20618: LD_INT 0
20620: PPUSH
20621: PPUSH
20622: PPUSH
20623: PPUSH
20624: PPUSH
20625: PPUSH
// if not mc_bases then
20626: LD_EXP 50
20630: NOT
20631: IFFALSE 20635
// exit ;
20633: GO 20874
// for i = 1 to 8 do
20635: LD_ADDR_VAR 0 2
20639: PUSH
20640: DOUBLE
20641: LD_INT 1
20643: DEC
20644: ST_TO_ADDR
20645: LD_INT 8
20647: PUSH
20648: FOR_TO
20649: IFFALSE 20675
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
20651: LD_ADDR_EXP 77
20655: PUSH
20656: LD_EXP 77
20660: PPUSH
20661: LD_VAR 0 2
20665: PPUSH
20666: EMPTY
20667: PPUSH
20668: CALL_OW 1
20672: ST_TO_ADDR
20673: GO 20648
20675: POP
20676: POP
// tmp := [ ] ;
20677: LD_ADDR_VAR 0 5
20681: PUSH
20682: EMPTY
20683: ST_TO_ADDR
// for i = 1 to mc_sides do
20684: LD_ADDR_VAR 0 2
20688: PUSH
20689: DOUBLE
20690: LD_INT 1
20692: DEC
20693: ST_TO_ADDR
20694: LD_EXP 76
20698: PUSH
20699: FOR_TO
20700: IFFALSE 20758
// if not mc_sides [ i ] in tmp then
20702: LD_EXP 76
20706: PUSH
20707: LD_VAR 0 2
20711: ARRAY
20712: PUSH
20713: LD_VAR 0 5
20717: IN
20718: NOT
20719: IFFALSE 20756
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
20721: LD_ADDR_VAR 0 5
20725: PUSH
20726: LD_VAR 0 5
20730: PPUSH
20731: LD_VAR 0 5
20735: PUSH
20736: LD_INT 1
20738: PLUS
20739: PPUSH
20740: LD_EXP 76
20744: PUSH
20745: LD_VAR 0 2
20749: ARRAY
20750: PPUSH
20751: CALL_OW 2
20755: ST_TO_ADDR
20756: GO 20699
20758: POP
20759: POP
// if not tmp then
20760: LD_VAR 0 5
20764: NOT
20765: IFFALSE 20769
// exit ;
20767: GO 20874
// for j in tmp do
20769: LD_ADDR_VAR 0 3
20773: PUSH
20774: LD_VAR 0 5
20778: PUSH
20779: FOR_IN
20780: IFFALSE 20872
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
20782: LD_ADDR_VAR 0 6
20786: PUSH
20787: LD_INT 22
20789: PUSH
20790: LD_VAR 0 3
20794: PUSH
20795: EMPTY
20796: LIST
20797: LIST
20798: PPUSH
20799: CALL_OW 69
20803: ST_TO_ADDR
// if not un then
20804: LD_VAR 0 6
20808: NOT
20809: IFFALSE 20813
// continue ;
20811: GO 20779
// nation := GetNation ( un [ 1 ] ) ;
20813: LD_ADDR_VAR 0 4
20817: PUSH
20818: LD_VAR 0 6
20822: PUSH
20823: LD_INT 1
20825: ARRAY
20826: PPUSH
20827: CALL_OW 248
20831: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
20832: LD_ADDR_EXP 77
20836: PUSH
20837: LD_EXP 77
20841: PPUSH
20842: LD_VAR 0 3
20846: PPUSH
20847: LD_VAR 0 3
20851: PPUSH
20852: LD_VAR 0 4
20856: PPUSH
20857: LD_INT 1
20859: PPUSH
20860: CALL 47468 0 3
20864: PPUSH
20865: CALL_OW 1
20869: ST_TO_ADDR
// end ;
20870: GO 20779
20872: POP
20873: POP
// end ;
20874: LD_VAR 0 1
20878: RET
// export function MC_InitSides ( ) ; var i ; begin
20879: LD_INT 0
20881: PPUSH
20882: PPUSH
// if not mc_bases then
20883: LD_EXP 50
20887: NOT
20888: IFFALSE 20892
// exit ;
20890: GO 20966
// for i = 1 to mc_bases do
20892: LD_ADDR_VAR 0 2
20896: PUSH
20897: DOUBLE
20898: LD_INT 1
20900: DEC
20901: ST_TO_ADDR
20902: LD_EXP 50
20906: PUSH
20907: FOR_TO
20908: IFFALSE 20964
// if mc_bases [ i ] then
20910: LD_EXP 50
20914: PUSH
20915: LD_VAR 0 2
20919: ARRAY
20920: IFFALSE 20962
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
20922: LD_ADDR_EXP 76
20926: PUSH
20927: LD_EXP 76
20931: PPUSH
20932: LD_VAR 0 2
20936: PPUSH
20937: LD_EXP 50
20941: PUSH
20942: LD_VAR 0 2
20946: ARRAY
20947: PUSH
20948: LD_INT 1
20950: ARRAY
20951: PPUSH
20952: CALL_OW 255
20956: PPUSH
20957: CALL_OW 1
20961: ST_TO_ADDR
20962: GO 20907
20964: POP
20965: POP
// end ;
20966: LD_VAR 0 1
20970: RET
// every 0 0$01 trigger skirmish do
20971: LD_EXP 48
20975: IFFALSE 21129
20977: GO 20979
20979: DISABLE
// begin enable ;
20980: ENABLE
// MC_CheckBuildings ( ) ;
20981: CALL 25627 0 0
// MC_CheckPeopleLife ( ) ;
20985: CALL 25752 0 0
// RaiseSailEvent ( 100 ) ;
20989: LD_INT 100
20991: PPUSH
20992: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
20996: LD_INT 103
20998: PPUSH
20999: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
21003: LD_INT 104
21005: PPUSH
21006: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
21010: LD_INT 105
21012: PPUSH
21013: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
21017: LD_INT 106
21019: PPUSH
21020: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
21024: LD_INT 107
21026: PPUSH
21027: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
21031: LD_INT 108
21033: PPUSH
21034: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
21038: LD_INT 109
21040: PPUSH
21041: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
21045: LD_INT 110
21047: PPUSH
21048: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
21052: LD_INT 111
21054: PPUSH
21055: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
21059: LD_INT 112
21061: PPUSH
21062: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
21066: LD_INT 113
21068: PPUSH
21069: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
21073: LD_INT 120
21075: PPUSH
21076: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
21080: LD_INT 121
21082: PPUSH
21083: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
21087: LD_INT 122
21089: PPUSH
21090: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
21094: LD_INT 123
21096: PPUSH
21097: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
21101: LD_INT 124
21103: PPUSH
21104: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
21108: LD_INT 125
21110: PPUSH
21111: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
21115: LD_INT 126
21117: PPUSH
21118: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
21122: LD_INT 200
21124: PPUSH
21125: CALL_OW 427
// end ;
21129: END
// on SailEvent ( event ) do begin if event < 100 then
21130: LD_VAR 0 1
21134: PUSH
21135: LD_INT 100
21137: LESS
21138: IFFALSE 21149
// CustomEvent ( event ) ;
21140: LD_VAR 0 1
21144: PPUSH
21145: CALL 16648 0 1
// if event = 100 then
21149: LD_VAR 0 1
21153: PUSH
21154: LD_INT 100
21156: EQUAL
21157: IFFALSE 21163
// MC_ClassManager ( ) ;
21159: CALL 21555 0 0
// if event = 101 then
21163: LD_VAR 0 1
21167: PUSH
21168: LD_INT 101
21170: EQUAL
21171: IFFALSE 21177
// MC_RepairBuildings ( ) ;
21173: CALL 26337 0 0
// if event = 102 then
21177: LD_VAR 0 1
21181: PUSH
21182: LD_INT 102
21184: EQUAL
21185: IFFALSE 21191
// MC_Heal ( ) ;
21187: CALL 27196 0 0
// if event = 103 then
21191: LD_VAR 0 1
21195: PUSH
21196: LD_INT 103
21198: EQUAL
21199: IFFALSE 21205
// MC_Build ( ) ;
21201: CALL 27618 0 0
// if event = 104 then
21205: LD_VAR 0 1
21209: PUSH
21210: LD_INT 104
21212: EQUAL
21213: IFFALSE 21219
// MC_TurretWeapon ( ) ;
21215: CALL 29231 0 0
// if event = 105 then
21219: LD_VAR 0 1
21223: PUSH
21224: LD_INT 105
21226: EQUAL
21227: IFFALSE 21233
// MC_BuildUpgrade ( ) ;
21229: CALL 28782 0 0
// if event = 106 then
21233: LD_VAR 0 1
21237: PUSH
21238: LD_INT 106
21240: EQUAL
21241: IFFALSE 21247
// MC_PlantMines ( ) ;
21243: CALL 29661 0 0
// if event = 107 then
21247: LD_VAR 0 1
21251: PUSH
21252: LD_INT 107
21254: EQUAL
21255: IFFALSE 21261
// MC_CollectCrates ( ) ;
21257: CALL 30459 0 0
// if event = 108 then
21261: LD_VAR 0 1
21265: PUSH
21266: LD_INT 108
21268: EQUAL
21269: IFFALSE 21275
// MC_LinkRemoteControl ( ) ;
21271: CALL 32235 0 0
// if event = 109 then
21275: LD_VAR 0 1
21279: PUSH
21280: LD_INT 109
21282: EQUAL
21283: IFFALSE 21289
// MC_ProduceVehicle ( ) ;
21285: CALL 32416 0 0
// if event = 110 then
21289: LD_VAR 0 1
21293: PUSH
21294: LD_INT 110
21296: EQUAL
21297: IFFALSE 21303
// MC_SendAttack ( ) ;
21299: CALL 32882 0 0
// if event = 111 then
21303: LD_VAR 0 1
21307: PUSH
21308: LD_INT 111
21310: EQUAL
21311: IFFALSE 21317
// MC_Defend ( ) ;
21313: CALL 32990 0 0
// if event = 112 then
21317: LD_VAR 0 1
21321: PUSH
21322: LD_INT 112
21324: EQUAL
21325: IFFALSE 21331
// MC_Research ( ) ;
21327: CALL 33595 0 0
// if event = 113 then
21331: LD_VAR 0 1
21335: PUSH
21336: LD_INT 113
21338: EQUAL
21339: IFFALSE 21345
// MC_MinesTrigger ( ) ;
21341: CALL 34709 0 0
// if event = 120 then
21345: LD_VAR 0 1
21349: PUSH
21350: LD_INT 120
21352: EQUAL
21353: IFFALSE 21359
// MC_RepairVehicle ( ) ;
21355: CALL 34808 0 0
// if event = 121 then
21359: LD_VAR 0 1
21363: PUSH
21364: LD_INT 121
21366: EQUAL
21367: IFFALSE 21373
// MC_TameApe ( ) ;
21369: CALL 35538 0 0
// if event = 122 then
21373: LD_VAR 0 1
21377: PUSH
21378: LD_INT 122
21380: EQUAL
21381: IFFALSE 21387
// MC_ChangeApeClass ( ) ;
21383: CALL 36367 0 0
// if event = 123 then
21387: LD_VAR 0 1
21391: PUSH
21392: LD_INT 123
21394: EQUAL
21395: IFFALSE 21401
// MC_Bazooka ( ) ;
21397: CALL 37017 0 0
// if event = 124 then
21401: LD_VAR 0 1
21405: PUSH
21406: LD_INT 124
21408: EQUAL
21409: IFFALSE 21415
// MC_TeleportExit ( ) ;
21411: CALL 37215 0 0
// if event = 125 then
21415: LD_VAR 0 1
21419: PUSH
21420: LD_INT 125
21422: EQUAL
21423: IFFALSE 21429
// MC_Deposits ( ) ;
21425: CALL 37862 0 0
// if event = 126 then
21429: LD_VAR 0 1
21433: PUSH
21434: LD_INT 126
21436: EQUAL
21437: IFFALSE 21443
// MC_RemoteDriver ( ) ;
21439: CALL 38487 0 0
// if event = 200 then
21443: LD_VAR 0 1
21447: PUSH
21448: LD_INT 200
21450: EQUAL
21451: IFFALSE 21457
// MC_Idle ( ) ;
21453: CALL 40436 0 0
// end ;
21457: PPOPN 1
21459: END
// export function MC_Reset ( base , tag ) ; var i ; begin
21460: LD_INT 0
21462: PPUSH
21463: PPUSH
// if not mc_bases [ base ] or not tag then
21464: LD_EXP 50
21468: PUSH
21469: LD_VAR 0 1
21473: ARRAY
21474: NOT
21475: PUSH
21476: LD_VAR 0 2
21480: NOT
21481: OR
21482: IFFALSE 21486
// exit ;
21484: GO 21550
// for i in mc_bases [ base ] union mc_ape [ base ] do
21486: LD_ADDR_VAR 0 4
21490: PUSH
21491: LD_EXP 50
21495: PUSH
21496: LD_VAR 0 1
21500: ARRAY
21501: PUSH
21502: LD_EXP 79
21506: PUSH
21507: LD_VAR 0 1
21511: ARRAY
21512: UNION
21513: PUSH
21514: FOR_IN
21515: IFFALSE 21548
// if GetTag ( i ) = tag then
21517: LD_VAR 0 4
21521: PPUSH
21522: CALL_OW 110
21526: PUSH
21527: LD_VAR 0 2
21531: EQUAL
21532: IFFALSE 21546
// SetTag ( i , 0 ) ;
21534: LD_VAR 0 4
21538: PPUSH
21539: LD_INT 0
21541: PPUSH
21542: CALL_OW 109
21546: GO 21514
21548: POP
21549: POP
// end ;
21550: LD_VAR 0 3
21554: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
21555: LD_INT 0
21557: PPUSH
21558: PPUSH
21559: PPUSH
21560: PPUSH
21561: PPUSH
21562: PPUSH
21563: PPUSH
21564: PPUSH
// if not mc_bases then
21565: LD_EXP 50
21569: NOT
21570: IFFALSE 21574
// exit ;
21572: GO 22032
// for i = 1 to mc_bases do
21574: LD_ADDR_VAR 0 2
21578: PUSH
21579: DOUBLE
21580: LD_INT 1
21582: DEC
21583: ST_TO_ADDR
21584: LD_EXP 50
21588: PUSH
21589: FOR_TO
21590: IFFALSE 22030
// begin tmp := MC_ClassCheckReq ( i ) ;
21592: LD_ADDR_VAR 0 4
21596: PUSH
21597: LD_VAR 0 2
21601: PPUSH
21602: CALL 22037 0 1
21606: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
21607: LD_ADDR_EXP 91
21611: PUSH
21612: LD_EXP 91
21616: PPUSH
21617: LD_VAR 0 2
21621: PPUSH
21622: LD_VAR 0 4
21626: PPUSH
21627: CALL_OW 1
21631: ST_TO_ADDR
// if not tmp then
21632: LD_VAR 0 4
21636: NOT
21637: IFFALSE 21641
// continue ;
21639: GO 21589
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
21641: LD_ADDR_VAR 0 6
21645: PUSH
21646: LD_EXP 50
21650: PUSH
21651: LD_VAR 0 2
21655: ARRAY
21656: PPUSH
21657: LD_INT 2
21659: PUSH
21660: LD_INT 30
21662: PUSH
21663: LD_INT 4
21665: PUSH
21666: EMPTY
21667: LIST
21668: LIST
21669: PUSH
21670: LD_INT 30
21672: PUSH
21673: LD_INT 5
21675: PUSH
21676: EMPTY
21677: LIST
21678: LIST
21679: PUSH
21680: EMPTY
21681: LIST
21682: LIST
21683: LIST
21684: PPUSH
21685: CALL_OW 72
21689: PUSH
21690: LD_EXP 50
21694: PUSH
21695: LD_VAR 0 2
21699: ARRAY
21700: PPUSH
21701: LD_INT 2
21703: PUSH
21704: LD_INT 30
21706: PUSH
21707: LD_INT 0
21709: PUSH
21710: EMPTY
21711: LIST
21712: LIST
21713: PUSH
21714: LD_INT 30
21716: PUSH
21717: LD_INT 1
21719: PUSH
21720: EMPTY
21721: LIST
21722: LIST
21723: PUSH
21724: EMPTY
21725: LIST
21726: LIST
21727: LIST
21728: PPUSH
21729: CALL_OW 72
21733: PUSH
21734: LD_EXP 50
21738: PUSH
21739: LD_VAR 0 2
21743: ARRAY
21744: PPUSH
21745: LD_INT 30
21747: PUSH
21748: LD_INT 3
21750: PUSH
21751: EMPTY
21752: LIST
21753: LIST
21754: PPUSH
21755: CALL_OW 72
21759: PUSH
21760: LD_EXP 50
21764: PUSH
21765: LD_VAR 0 2
21769: ARRAY
21770: PPUSH
21771: LD_INT 2
21773: PUSH
21774: LD_INT 30
21776: PUSH
21777: LD_INT 6
21779: PUSH
21780: EMPTY
21781: LIST
21782: LIST
21783: PUSH
21784: LD_INT 30
21786: PUSH
21787: LD_INT 7
21789: PUSH
21790: EMPTY
21791: LIST
21792: LIST
21793: PUSH
21794: LD_INT 30
21796: PUSH
21797: LD_INT 8
21799: PUSH
21800: EMPTY
21801: LIST
21802: LIST
21803: PUSH
21804: EMPTY
21805: LIST
21806: LIST
21807: LIST
21808: LIST
21809: PPUSH
21810: CALL_OW 72
21814: PUSH
21815: EMPTY
21816: LIST
21817: LIST
21818: LIST
21819: LIST
21820: ST_TO_ADDR
// for j = 1 to 4 do
21821: LD_ADDR_VAR 0 3
21825: PUSH
21826: DOUBLE
21827: LD_INT 1
21829: DEC
21830: ST_TO_ADDR
21831: LD_INT 4
21833: PUSH
21834: FOR_TO
21835: IFFALSE 22026
// begin if not tmp [ j ] then
21837: LD_VAR 0 4
21841: PUSH
21842: LD_VAR 0 3
21846: ARRAY
21847: NOT
21848: IFFALSE 21852
// continue ;
21850: GO 21834
// for p in tmp [ j ] do
21852: LD_ADDR_VAR 0 5
21856: PUSH
21857: LD_VAR 0 4
21861: PUSH
21862: LD_VAR 0 3
21866: ARRAY
21867: PUSH
21868: FOR_IN
21869: IFFALSE 22022
// begin if not b [ j ] then
21871: LD_VAR 0 6
21875: PUSH
21876: LD_VAR 0 3
21880: ARRAY
21881: NOT
21882: IFFALSE 21886
// break ;
21884: GO 22022
// e := 0 ;
21886: LD_ADDR_VAR 0 7
21890: PUSH
21891: LD_INT 0
21893: ST_TO_ADDR
// for k in b [ j ] do
21894: LD_ADDR_VAR 0 8
21898: PUSH
21899: LD_VAR 0 6
21903: PUSH
21904: LD_VAR 0 3
21908: ARRAY
21909: PUSH
21910: FOR_IN
21911: IFFALSE 21938
// if IsNotFull ( k ) then
21913: LD_VAR 0 8
21917: PPUSH
21918: CALL 49617 0 1
21922: IFFALSE 21936
// begin e := k ;
21924: LD_ADDR_VAR 0 7
21928: PUSH
21929: LD_VAR 0 8
21933: ST_TO_ADDR
// break ;
21934: GO 21938
// end ;
21936: GO 21910
21938: POP
21939: POP
// if e and not UnitGoingToBuilding ( p , e ) then
21940: LD_VAR 0 7
21944: PUSH
21945: LD_VAR 0 5
21949: PPUSH
21950: LD_VAR 0 7
21954: PPUSH
21955: CALL 82037 0 2
21959: NOT
21960: AND
21961: IFFALSE 22020
// begin if IsInUnit ( p ) then
21963: LD_VAR 0 5
21967: PPUSH
21968: CALL_OW 310
21972: IFFALSE 21983
// ComExitBuilding ( p ) ;
21974: LD_VAR 0 5
21978: PPUSH
21979: CALL_OW 122
// ComEnterUnit ( p , e ) ;
21983: LD_VAR 0 5
21987: PPUSH
21988: LD_VAR 0 7
21992: PPUSH
21993: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
21997: LD_VAR 0 5
22001: PPUSH
22002: LD_VAR 0 3
22006: PPUSH
22007: CALL_OW 183
// AddComExitBuilding ( p ) ;
22011: LD_VAR 0 5
22015: PPUSH
22016: CALL_OW 182
// end ; end ;
22020: GO 21868
22022: POP
22023: POP
// end ;
22024: GO 21834
22026: POP
22027: POP
// end ;
22028: GO 21589
22030: POP
22031: POP
// end ;
22032: LD_VAR 0 1
22036: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
22037: LD_INT 0
22039: PPUSH
22040: PPUSH
22041: PPUSH
22042: PPUSH
22043: PPUSH
22044: PPUSH
22045: PPUSH
22046: PPUSH
22047: PPUSH
22048: PPUSH
22049: PPUSH
22050: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
22051: LD_VAR 0 1
22055: NOT
22056: PUSH
22057: LD_EXP 50
22061: PUSH
22062: LD_VAR 0 1
22066: ARRAY
22067: NOT
22068: OR
22069: PUSH
22070: LD_EXP 50
22074: PUSH
22075: LD_VAR 0 1
22079: ARRAY
22080: PPUSH
22081: LD_INT 2
22083: PUSH
22084: LD_INT 30
22086: PUSH
22087: LD_INT 0
22089: PUSH
22090: EMPTY
22091: LIST
22092: LIST
22093: PUSH
22094: LD_INT 30
22096: PUSH
22097: LD_INT 1
22099: PUSH
22100: EMPTY
22101: LIST
22102: LIST
22103: PUSH
22104: EMPTY
22105: LIST
22106: LIST
22107: LIST
22108: PPUSH
22109: CALL_OW 72
22113: NOT
22114: OR
22115: IFFALSE 22119
// exit ;
22117: GO 25622
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
22119: LD_ADDR_VAR 0 4
22123: PUSH
22124: LD_EXP 50
22128: PUSH
22129: LD_VAR 0 1
22133: ARRAY
22134: PPUSH
22135: LD_INT 2
22137: PUSH
22138: LD_INT 25
22140: PUSH
22141: LD_INT 1
22143: PUSH
22144: EMPTY
22145: LIST
22146: LIST
22147: PUSH
22148: LD_INT 25
22150: PUSH
22151: LD_INT 2
22153: PUSH
22154: EMPTY
22155: LIST
22156: LIST
22157: PUSH
22158: LD_INT 25
22160: PUSH
22161: LD_INT 3
22163: PUSH
22164: EMPTY
22165: LIST
22166: LIST
22167: PUSH
22168: LD_INT 25
22170: PUSH
22171: LD_INT 4
22173: PUSH
22174: EMPTY
22175: LIST
22176: LIST
22177: PUSH
22178: LD_INT 25
22180: PUSH
22181: LD_INT 5
22183: PUSH
22184: EMPTY
22185: LIST
22186: LIST
22187: PUSH
22188: LD_INT 25
22190: PUSH
22191: LD_INT 8
22193: PUSH
22194: EMPTY
22195: LIST
22196: LIST
22197: PUSH
22198: LD_INT 25
22200: PUSH
22201: LD_INT 9
22203: PUSH
22204: EMPTY
22205: LIST
22206: LIST
22207: PUSH
22208: EMPTY
22209: LIST
22210: LIST
22211: LIST
22212: LIST
22213: LIST
22214: LIST
22215: LIST
22216: LIST
22217: PPUSH
22218: CALL_OW 72
22222: ST_TO_ADDR
// if not tmp then
22223: LD_VAR 0 4
22227: NOT
22228: IFFALSE 22232
// exit ;
22230: GO 25622
// for i in tmp do
22232: LD_ADDR_VAR 0 3
22236: PUSH
22237: LD_VAR 0 4
22241: PUSH
22242: FOR_IN
22243: IFFALSE 22274
// if GetTag ( i ) then
22245: LD_VAR 0 3
22249: PPUSH
22250: CALL_OW 110
22254: IFFALSE 22272
// tmp := tmp diff i ;
22256: LD_ADDR_VAR 0 4
22260: PUSH
22261: LD_VAR 0 4
22265: PUSH
22266: LD_VAR 0 3
22270: DIFF
22271: ST_TO_ADDR
22272: GO 22242
22274: POP
22275: POP
// if not tmp then
22276: LD_VAR 0 4
22280: NOT
22281: IFFALSE 22285
// exit ;
22283: GO 25622
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
22285: LD_ADDR_VAR 0 5
22289: PUSH
22290: LD_EXP 50
22294: PUSH
22295: LD_VAR 0 1
22299: ARRAY
22300: PPUSH
22301: LD_INT 2
22303: PUSH
22304: LD_INT 25
22306: PUSH
22307: LD_INT 1
22309: PUSH
22310: EMPTY
22311: LIST
22312: LIST
22313: PUSH
22314: LD_INT 25
22316: PUSH
22317: LD_INT 5
22319: PUSH
22320: EMPTY
22321: LIST
22322: LIST
22323: PUSH
22324: LD_INT 25
22326: PUSH
22327: LD_INT 8
22329: PUSH
22330: EMPTY
22331: LIST
22332: LIST
22333: PUSH
22334: LD_INT 25
22336: PUSH
22337: LD_INT 9
22339: PUSH
22340: EMPTY
22341: LIST
22342: LIST
22343: PUSH
22344: EMPTY
22345: LIST
22346: LIST
22347: LIST
22348: LIST
22349: LIST
22350: PPUSH
22351: CALL_OW 72
22355: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
22356: LD_ADDR_VAR 0 6
22360: PUSH
22361: LD_EXP 50
22365: PUSH
22366: LD_VAR 0 1
22370: ARRAY
22371: PPUSH
22372: LD_INT 25
22374: PUSH
22375: LD_INT 2
22377: PUSH
22378: EMPTY
22379: LIST
22380: LIST
22381: PPUSH
22382: CALL_OW 72
22386: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
22387: LD_ADDR_VAR 0 7
22391: PUSH
22392: LD_EXP 50
22396: PUSH
22397: LD_VAR 0 1
22401: ARRAY
22402: PPUSH
22403: LD_INT 25
22405: PUSH
22406: LD_INT 3
22408: PUSH
22409: EMPTY
22410: LIST
22411: LIST
22412: PPUSH
22413: CALL_OW 72
22417: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
22418: LD_ADDR_VAR 0 8
22422: PUSH
22423: LD_EXP 50
22427: PUSH
22428: LD_VAR 0 1
22432: ARRAY
22433: PPUSH
22434: LD_INT 25
22436: PUSH
22437: LD_INT 4
22439: PUSH
22440: EMPTY
22441: LIST
22442: LIST
22443: PUSH
22444: LD_INT 24
22446: PUSH
22447: LD_INT 251
22449: PUSH
22450: EMPTY
22451: LIST
22452: LIST
22453: PUSH
22454: EMPTY
22455: LIST
22456: LIST
22457: PPUSH
22458: CALL_OW 72
22462: ST_TO_ADDR
// if mc_scan [ base ] then
22463: LD_EXP 73
22467: PUSH
22468: LD_VAR 0 1
22472: ARRAY
22473: IFFALSE 22934
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
22475: LD_ADDR_EXP 92
22479: PUSH
22480: LD_EXP 92
22484: PPUSH
22485: LD_VAR 0 1
22489: PPUSH
22490: LD_INT 4
22492: PPUSH
22493: CALL_OW 1
22497: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
22498: LD_ADDR_VAR 0 12
22502: PUSH
22503: LD_EXP 50
22507: PUSH
22508: LD_VAR 0 1
22512: ARRAY
22513: PPUSH
22514: LD_INT 2
22516: PUSH
22517: LD_INT 30
22519: PUSH
22520: LD_INT 4
22522: PUSH
22523: EMPTY
22524: LIST
22525: LIST
22526: PUSH
22527: LD_INT 30
22529: PUSH
22530: LD_INT 5
22532: PUSH
22533: EMPTY
22534: LIST
22535: LIST
22536: PUSH
22537: EMPTY
22538: LIST
22539: LIST
22540: LIST
22541: PPUSH
22542: CALL_OW 72
22546: ST_TO_ADDR
// if not b then
22547: LD_VAR 0 12
22551: NOT
22552: IFFALSE 22556
// exit ;
22554: GO 25622
// p := [ ] ;
22556: LD_ADDR_VAR 0 11
22560: PUSH
22561: EMPTY
22562: ST_TO_ADDR
// if sci >= 2 then
22563: LD_VAR 0 8
22567: PUSH
22568: LD_INT 2
22570: GREATEREQUAL
22571: IFFALSE 22602
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
22573: LD_ADDR_VAR 0 8
22577: PUSH
22578: LD_VAR 0 8
22582: PUSH
22583: LD_INT 1
22585: ARRAY
22586: PUSH
22587: LD_VAR 0 8
22591: PUSH
22592: LD_INT 2
22594: ARRAY
22595: PUSH
22596: EMPTY
22597: LIST
22598: LIST
22599: ST_TO_ADDR
22600: GO 22663
// if sci = 1 then
22602: LD_VAR 0 8
22606: PUSH
22607: LD_INT 1
22609: EQUAL
22610: IFFALSE 22631
// sci := [ sci [ 1 ] ] else
22612: LD_ADDR_VAR 0 8
22616: PUSH
22617: LD_VAR 0 8
22621: PUSH
22622: LD_INT 1
22624: ARRAY
22625: PUSH
22626: EMPTY
22627: LIST
22628: ST_TO_ADDR
22629: GO 22663
// if sci = 0 then
22631: LD_VAR 0 8
22635: PUSH
22636: LD_INT 0
22638: EQUAL
22639: IFFALSE 22663
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
22641: LD_ADDR_VAR 0 11
22645: PUSH
22646: LD_VAR 0 4
22650: PPUSH
22651: LD_INT 4
22653: PPUSH
22654: CALL 81900 0 2
22658: PUSH
22659: LD_INT 1
22661: ARRAY
22662: ST_TO_ADDR
// if eng > 4 then
22663: LD_VAR 0 6
22667: PUSH
22668: LD_INT 4
22670: GREATER
22671: IFFALSE 22717
// for i = eng downto 4 do
22673: LD_ADDR_VAR 0 3
22677: PUSH
22678: DOUBLE
22679: LD_VAR 0 6
22683: INC
22684: ST_TO_ADDR
22685: LD_INT 4
22687: PUSH
22688: FOR_DOWNTO
22689: IFFALSE 22715
// eng := eng diff eng [ i ] ;
22691: LD_ADDR_VAR 0 6
22695: PUSH
22696: LD_VAR 0 6
22700: PUSH
22701: LD_VAR 0 6
22705: PUSH
22706: LD_VAR 0 3
22710: ARRAY
22711: DIFF
22712: ST_TO_ADDR
22713: GO 22688
22715: POP
22716: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
22717: LD_ADDR_VAR 0 4
22721: PUSH
22722: LD_VAR 0 4
22726: PUSH
22727: LD_VAR 0 5
22731: PUSH
22732: LD_VAR 0 6
22736: UNION
22737: PUSH
22738: LD_VAR 0 7
22742: UNION
22743: PUSH
22744: LD_VAR 0 8
22748: UNION
22749: DIFF
22750: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
22751: LD_ADDR_VAR 0 13
22755: PUSH
22756: LD_EXP 50
22760: PUSH
22761: LD_VAR 0 1
22765: ARRAY
22766: PPUSH
22767: LD_INT 2
22769: PUSH
22770: LD_INT 30
22772: PUSH
22773: LD_INT 32
22775: PUSH
22776: EMPTY
22777: LIST
22778: LIST
22779: PUSH
22780: LD_INT 30
22782: PUSH
22783: LD_INT 31
22785: PUSH
22786: EMPTY
22787: LIST
22788: LIST
22789: PUSH
22790: EMPTY
22791: LIST
22792: LIST
22793: LIST
22794: PPUSH
22795: CALL_OW 72
22799: PUSH
22800: LD_EXP 50
22804: PUSH
22805: LD_VAR 0 1
22809: ARRAY
22810: PPUSH
22811: LD_INT 2
22813: PUSH
22814: LD_INT 30
22816: PUSH
22817: LD_INT 4
22819: PUSH
22820: EMPTY
22821: LIST
22822: LIST
22823: PUSH
22824: LD_INT 30
22826: PUSH
22827: LD_INT 5
22829: PUSH
22830: EMPTY
22831: LIST
22832: LIST
22833: PUSH
22834: EMPTY
22835: LIST
22836: LIST
22837: LIST
22838: PPUSH
22839: CALL_OW 72
22843: PUSH
22844: LD_INT 6
22846: MUL
22847: PLUS
22848: ST_TO_ADDR
// if bcount < tmp then
22849: LD_VAR 0 13
22853: PUSH
22854: LD_VAR 0 4
22858: LESS
22859: IFFALSE 22905
// for i = tmp downto bcount do
22861: LD_ADDR_VAR 0 3
22865: PUSH
22866: DOUBLE
22867: LD_VAR 0 4
22871: INC
22872: ST_TO_ADDR
22873: LD_VAR 0 13
22877: PUSH
22878: FOR_DOWNTO
22879: IFFALSE 22903
// tmp := Delete ( tmp , tmp ) ;
22881: LD_ADDR_VAR 0 4
22885: PUSH
22886: LD_VAR 0 4
22890: PPUSH
22891: LD_VAR 0 4
22895: PPUSH
22896: CALL_OW 3
22900: ST_TO_ADDR
22901: GO 22878
22903: POP
22904: POP
// result := [ tmp , 0 , 0 , p ] ;
22905: LD_ADDR_VAR 0 2
22909: PUSH
22910: LD_VAR 0 4
22914: PUSH
22915: LD_INT 0
22917: PUSH
22918: LD_INT 0
22920: PUSH
22921: LD_VAR 0 11
22925: PUSH
22926: EMPTY
22927: LIST
22928: LIST
22929: LIST
22930: LIST
22931: ST_TO_ADDR
// exit ;
22932: GO 25622
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
22934: LD_EXP 50
22938: PUSH
22939: LD_VAR 0 1
22943: ARRAY
22944: PPUSH
22945: LD_INT 2
22947: PUSH
22948: LD_INT 30
22950: PUSH
22951: LD_INT 6
22953: PUSH
22954: EMPTY
22955: LIST
22956: LIST
22957: PUSH
22958: LD_INT 30
22960: PUSH
22961: LD_INT 7
22963: PUSH
22964: EMPTY
22965: LIST
22966: LIST
22967: PUSH
22968: LD_INT 30
22970: PUSH
22971: LD_INT 8
22973: PUSH
22974: EMPTY
22975: LIST
22976: LIST
22977: PUSH
22978: EMPTY
22979: LIST
22980: LIST
22981: LIST
22982: LIST
22983: PPUSH
22984: CALL_OW 72
22988: NOT
22989: PUSH
22990: LD_EXP 50
22994: PUSH
22995: LD_VAR 0 1
22999: ARRAY
23000: PPUSH
23001: LD_INT 30
23003: PUSH
23004: LD_INT 3
23006: PUSH
23007: EMPTY
23008: LIST
23009: LIST
23010: PPUSH
23011: CALL_OW 72
23015: NOT
23016: AND
23017: IFFALSE 23089
// begin if eng = tmp then
23019: LD_VAR 0 6
23023: PUSH
23024: LD_VAR 0 4
23028: EQUAL
23029: IFFALSE 23033
// exit ;
23031: GO 25622
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
23033: LD_ADDR_EXP 92
23037: PUSH
23038: LD_EXP 92
23042: PPUSH
23043: LD_VAR 0 1
23047: PPUSH
23048: LD_INT 1
23050: PPUSH
23051: CALL_OW 1
23055: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
23056: LD_ADDR_VAR 0 2
23060: PUSH
23061: LD_INT 0
23063: PUSH
23064: LD_VAR 0 4
23068: PUSH
23069: LD_VAR 0 6
23073: DIFF
23074: PUSH
23075: LD_INT 0
23077: PUSH
23078: LD_INT 0
23080: PUSH
23081: EMPTY
23082: LIST
23083: LIST
23084: LIST
23085: LIST
23086: ST_TO_ADDR
// exit ;
23087: GO 25622
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
23089: LD_EXP 77
23093: PUSH
23094: LD_EXP 76
23098: PUSH
23099: LD_VAR 0 1
23103: ARRAY
23104: ARRAY
23105: PUSH
23106: LD_EXP 50
23110: PUSH
23111: LD_VAR 0 1
23115: ARRAY
23116: PPUSH
23117: LD_INT 2
23119: PUSH
23120: LD_INT 30
23122: PUSH
23123: LD_INT 6
23125: PUSH
23126: EMPTY
23127: LIST
23128: LIST
23129: PUSH
23130: LD_INT 30
23132: PUSH
23133: LD_INT 7
23135: PUSH
23136: EMPTY
23137: LIST
23138: LIST
23139: PUSH
23140: LD_INT 30
23142: PUSH
23143: LD_INT 8
23145: PUSH
23146: EMPTY
23147: LIST
23148: LIST
23149: PUSH
23150: EMPTY
23151: LIST
23152: LIST
23153: LIST
23154: LIST
23155: PPUSH
23156: CALL_OW 72
23160: AND
23161: PUSH
23162: LD_EXP 50
23166: PUSH
23167: LD_VAR 0 1
23171: ARRAY
23172: PPUSH
23173: LD_INT 30
23175: PUSH
23176: LD_INT 3
23178: PUSH
23179: EMPTY
23180: LIST
23181: LIST
23182: PPUSH
23183: CALL_OW 72
23187: NOT
23188: AND
23189: IFFALSE 23403
// begin if sci >= 6 then
23191: LD_VAR 0 8
23195: PUSH
23196: LD_INT 6
23198: GREATEREQUAL
23199: IFFALSE 23203
// exit ;
23201: GO 25622
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
23203: LD_ADDR_EXP 92
23207: PUSH
23208: LD_EXP 92
23212: PPUSH
23213: LD_VAR 0 1
23217: PPUSH
23218: LD_INT 2
23220: PPUSH
23221: CALL_OW 1
23225: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
23226: LD_ADDR_VAR 0 9
23230: PUSH
23231: LD_VAR 0 4
23235: PUSH
23236: LD_VAR 0 8
23240: DIFF
23241: PPUSH
23242: LD_INT 4
23244: PPUSH
23245: CALL 81900 0 2
23249: ST_TO_ADDR
// p := [ ] ;
23250: LD_ADDR_VAR 0 11
23254: PUSH
23255: EMPTY
23256: ST_TO_ADDR
// if sci < 6 and sort > 6 then
23257: LD_VAR 0 8
23261: PUSH
23262: LD_INT 6
23264: LESS
23265: PUSH
23266: LD_VAR 0 9
23270: PUSH
23271: LD_INT 6
23273: GREATER
23274: AND
23275: IFFALSE 23356
// begin for i = 1 to 6 - sci do
23277: LD_ADDR_VAR 0 3
23281: PUSH
23282: DOUBLE
23283: LD_INT 1
23285: DEC
23286: ST_TO_ADDR
23287: LD_INT 6
23289: PUSH
23290: LD_VAR 0 8
23294: MINUS
23295: PUSH
23296: FOR_TO
23297: IFFALSE 23352
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
23299: LD_ADDR_VAR 0 11
23303: PUSH
23304: LD_VAR 0 11
23308: PPUSH
23309: LD_VAR 0 11
23313: PUSH
23314: LD_INT 1
23316: PLUS
23317: PPUSH
23318: LD_VAR 0 9
23322: PUSH
23323: LD_INT 1
23325: ARRAY
23326: PPUSH
23327: CALL_OW 2
23331: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
23332: LD_ADDR_VAR 0 9
23336: PUSH
23337: LD_VAR 0 9
23341: PPUSH
23342: LD_INT 1
23344: PPUSH
23345: CALL_OW 3
23349: ST_TO_ADDR
// end ;
23350: GO 23296
23352: POP
23353: POP
// end else
23354: GO 23376
// if sort then
23356: LD_VAR 0 9
23360: IFFALSE 23376
// p := sort [ 1 ] ;
23362: LD_ADDR_VAR 0 11
23366: PUSH
23367: LD_VAR 0 9
23371: PUSH
23372: LD_INT 1
23374: ARRAY
23375: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
23376: LD_ADDR_VAR 0 2
23380: PUSH
23381: LD_INT 0
23383: PUSH
23384: LD_INT 0
23386: PUSH
23387: LD_INT 0
23389: PUSH
23390: LD_VAR 0 11
23394: PUSH
23395: EMPTY
23396: LIST
23397: LIST
23398: LIST
23399: LIST
23400: ST_TO_ADDR
// exit ;
23401: GO 25622
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
23403: LD_EXP 77
23407: PUSH
23408: LD_EXP 76
23412: PUSH
23413: LD_VAR 0 1
23417: ARRAY
23418: ARRAY
23419: PUSH
23420: LD_EXP 50
23424: PUSH
23425: LD_VAR 0 1
23429: ARRAY
23430: PPUSH
23431: LD_INT 2
23433: PUSH
23434: LD_INT 30
23436: PUSH
23437: LD_INT 6
23439: PUSH
23440: EMPTY
23441: LIST
23442: LIST
23443: PUSH
23444: LD_INT 30
23446: PUSH
23447: LD_INT 7
23449: PUSH
23450: EMPTY
23451: LIST
23452: LIST
23453: PUSH
23454: LD_INT 30
23456: PUSH
23457: LD_INT 8
23459: PUSH
23460: EMPTY
23461: LIST
23462: LIST
23463: PUSH
23464: EMPTY
23465: LIST
23466: LIST
23467: LIST
23468: LIST
23469: PPUSH
23470: CALL_OW 72
23474: AND
23475: PUSH
23476: LD_EXP 50
23480: PUSH
23481: LD_VAR 0 1
23485: ARRAY
23486: PPUSH
23487: LD_INT 30
23489: PUSH
23490: LD_INT 3
23492: PUSH
23493: EMPTY
23494: LIST
23495: LIST
23496: PPUSH
23497: CALL_OW 72
23501: AND
23502: IFFALSE 24236
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
23504: LD_ADDR_EXP 92
23508: PUSH
23509: LD_EXP 92
23513: PPUSH
23514: LD_VAR 0 1
23518: PPUSH
23519: LD_INT 3
23521: PPUSH
23522: CALL_OW 1
23526: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
23527: LD_ADDR_VAR 0 2
23531: PUSH
23532: LD_INT 0
23534: PUSH
23535: LD_INT 0
23537: PUSH
23538: LD_INT 0
23540: PUSH
23541: LD_INT 0
23543: PUSH
23544: EMPTY
23545: LIST
23546: LIST
23547: LIST
23548: LIST
23549: ST_TO_ADDR
// if not eng then
23550: LD_VAR 0 6
23554: NOT
23555: IFFALSE 23618
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
23557: LD_ADDR_VAR 0 11
23561: PUSH
23562: LD_VAR 0 4
23566: PPUSH
23567: LD_INT 2
23569: PPUSH
23570: CALL 81900 0 2
23574: PUSH
23575: LD_INT 1
23577: ARRAY
23578: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
23579: LD_ADDR_VAR 0 2
23583: PUSH
23584: LD_VAR 0 2
23588: PPUSH
23589: LD_INT 2
23591: PPUSH
23592: LD_VAR 0 11
23596: PPUSH
23597: CALL_OW 1
23601: ST_TO_ADDR
// tmp := tmp diff p ;
23602: LD_ADDR_VAR 0 4
23606: PUSH
23607: LD_VAR 0 4
23611: PUSH
23612: LD_VAR 0 11
23616: DIFF
23617: ST_TO_ADDR
// end ; if tmp and sci < 6 then
23618: LD_VAR 0 4
23622: PUSH
23623: LD_VAR 0 8
23627: PUSH
23628: LD_INT 6
23630: LESS
23631: AND
23632: IFFALSE 23820
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
23634: LD_ADDR_VAR 0 9
23638: PUSH
23639: LD_VAR 0 4
23643: PUSH
23644: LD_VAR 0 8
23648: PUSH
23649: LD_VAR 0 7
23653: UNION
23654: DIFF
23655: PPUSH
23656: LD_INT 4
23658: PPUSH
23659: CALL 81900 0 2
23663: ST_TO_ADDR
// p := [ ] ;
23664: LD_ADDR_VAR 0 11
23668: PUSH
23669: EMPTY
23670: ST_TO_ADDR
// if sort then
23671: LD_VAR 0 9
23675: IFFALSE 23791
// for i = 1 to 6 - sci do
23677: LD_ADDR_VAR 0 3
23681: PUSH
23682: DOUBLE
23683: LD_INT 1
23685: DEC
23686: ST_TO_ADDR
23687: LD_INT 6
23689: PUSH
23690: LD_VAR 0 8
23694: MINUS
23695: PUSH
23696: FOR_TO
23697: IFFALSE 23789
// begin if i = sort then
23699: LD_VAR 0 3
23703: PUSH
23704: LD_VAR 0 9
23708: EQUAL
23709: IFFALSE 23713
// break ;
23711: GO 23789
// if GetClass ( i ) = 4 then
23713: LD_VAR 0 3
23717: PPUSH
23718: CALL_OW 257
23722: PUSH
23723: LD_INT 4
23725: EQUAL
23726: IFFALSE 23730
// continue ;
23728: GO 23696
// p := Insert ( p , p + 1 , sort [ i ] ) ;
23730: LD_ADDR_VAR 0 11
23734: PUSH
23735: LD_VAR 0 11
23739: PPUSH
23740: LD_VAR 0 11
23744: PUSH
23745: LD_INT 1
23747: PLUS
23748: PPUSH
23749: LD_VAR 0 9
23753: PUSH
23754: LD_VAR 0 3
23758: ARRAY
23759: PPUSH
23760: CALL_OW 2
23764: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
23765: LD_ADDR_VAR 0 4
23769: PUSH
23770: LD_VAR 0 4
23774: PUSH
23775: LD_VAR 0 9
23779: PUSH
23780: LD_VAR 0 3
23784: ARRAY
23785: DIFF
23786: ST_TO_ADDR
// end ;
23787: GO 23696
23789: POP
23790: POP
// if p then
23791: LD_VAR 0 11
23795: IFFALSE 23820
// result := Replace ( result , 4 , p ) ;
23797: LD_ADDR_VAR 0 2
23801: PUSH
23802: LD_VAR 0 2
23806: PPUSH
23807: LD_INT 4
23809: PPUSH
23810: LD_VAR 0 11
23814: PPUSH
23815: CALL_OW 1
23819: ST_TO_ADDR
// end ; if tmp and mech < 6 then
23820: LD_VAR 0 4
23824: PUSH
23825: LD_VAR 0 7
23829: PUSH
23830: LD_INT 6
23832: LESS
23833: AND
23834: IFFALSE 24022
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
23836: LD_ADDR_VAR 0 9
23840: PUSH
23841: LD_VAR 0 4
23845: PUSH
23846: LD_VAR 0 8
23850: PUSH
23851: LD_VAR 0 7
23855: UNION
23856: DIFF
23857: PPUSH
23858: LD_INT 3
23860: PPUSH
23861: CALL 81900 0 2
23865: ST_TO_ADDR
// p := [ ] ;
23866: LD_ADDR_VAR 0 11
23870: PUSH
23871: EMPTY
23872: ST_TO_ADDR
// if sort then
23873: LD_VAR 0 9
23877: IFFALSE 23993
// for i = 1 to 6 - mech do
23879: LD_ADDR_VAR 0 3
23883: PUSH
23884: DOUBLE
23885: LD_INT 1
23887: DEC
23888: ST_TO_ADDR
23889: LD_INT 6
23891: PUSH
23892: LD_VAR 0 7
23896: MINUS
23897: PUSH
23898: FOR_TO
23899: IFFALSE 23991
// begin if i = sort then
23901: LD_VAR 0 3
23905: PUSH
23906: LD_VAR 0 9
23910: EQUAL
23911: IFFALSE 23915
// break ;
23913: GO 23991
// if GetClass ( i ) = 3 then
23915: LD_VAR 0 3
23919: PPUSH
23920: CALL_OW 257
23924: PUSH
23925: LD_INT 3
23927: EQUAL
23928: IFFALSE 23932
// continue ;
23930: GO 23898
// p := Insert ( p , p + 1 , sort [ i ] ) ;
23932: LD_ADDR_VAR 0 11
23936: PUSH
23937: LD_VAR 0 11
23941: PPUSH
23942: LD_VAR 0 11
23946: PUSH
23947: LD_INT 1
23949: PLUS
23950: PPUSH
23951: LD_VAR 0 9
23955: PUSH
23956: LD_VAR 0 3
23960: ARRAY
23961: PPUSH
23962: CALL_OW 2
23966: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
23967: LD_ADDR_VAR 0 4
23971: PUSH
23972: LD_VAR 0 4
23976: PUSH
23977: LD_VAR 0 9
23981: PUSH
23982: LD_VAR 0 3
23986: ARRAY
23987: DIFF
23988: ST_TO_ADDR
// end ;
23989: GO 23898
23991: POP
23992: POP
// if p then
23993: LD_VAR 0 11
23997: IFFALSE 24022
// result := Replace ( result , 3 , p ) ;
23999: LD_ADDR_VAR 0 2
24003: PUSH
24004: LD_VAR 0 2
24008: PPUSH
24009: LD_INT 3
24011: PPUSH
24012: LD_VAR 0 11
24016: PPUSH
24017: CALL_OW 1
24021: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
24022: LD_VAR 0 4
24026: PUSH
24027: LD_INT 6
24029: GREATER
24030: PUSH
24031: LD_VAR 0 6
24035: PUSH
24036: LD_INT 6
24038: LESS
24039: AND
24040: IFFALSE 24234
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
24042: LD_ADDR_VAR 0 9
24046: PUSH
24047: LD_VAR 0 4
24051: PUSH
24052: LD_VAR 0 8
24056: PUSH
24057: LD_VAR 0 7
24061: UNION
24062: PUSH
24063: LD_VAR 0 6
24067: UNION
24068: DIFF
24069: PPUSH
24070: LD_INT 2
24072: PPUSH
24073: CALL 81900 0 2
24077: ST_TO_ADDR
// p := [ ] ;
24078: LD_ADDR_VAR 0 11
24082: PUSH
24083: EMPTY
24084: ST_TO_ADDR
// if sort then
24085: LD_VAR 0 9
24089: IFFALSE 24205
// for i = 1 to 6 - eng do
24091: LD_ADDR_VAR 0 3
24095: PUSH
24096: DOUBLE
24097: LD_INT 1
24099: DEC
24100: ST_TO_ADDR
24101: LD_INT 6
24103: PUSH
24104: LD_VAR 0 6
24108: MINUS
24109: PUSH
24110: FOR_TO
24111: IFFALSE 24203
// begin if i = sort then
24113: LD_VAR 0 3
24117: PUSH
24118: LD_VAR 0 9
24122: EQUAL
24123: IFFALSE 24127
// break ;
24125: GO 24203
// if GetClass ( i ) = 2 then
24127: LD_VAR 0 3
24131: PPUSH
24132: CALL_OW 257
24136: PUSH
24137: LD_INT 2
24139: EQUAL
24140: IFFALSE 24144
// continue ;
24142: GO 24110
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24144: LD_ADDR_VAR 0 11
24148: PUSH
24149: LD_VAR 0 11
24153: PPUSH
24154: LD_VAR 0 11
24158: PUSH
24159: LD_INT 1
24161: PLUS
24162: PPUSH
24163: LD_VAR 0 9
24167: PUSH
24168: LD_VAR 0 3
24172: ARRAY
24173: PPUSH
24174: CALL_OW 2
24178: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24179: LD_ADDR_VAR 0 4
24183: PUSH
24184: LD_VAR 0 4
24188: PUSH
24189: LD_VAR 0 9
24193: PUSH
24194: LD_VAR 0 3
24198: ARRAY
24199: DIFF
24200: ST_TO_ADDR
// end ;
24201: GO 24110
24203: POP
24204: POP
// if p then
24205: LD_VAR 0 11
24209: IFFALSE 24234
// result := Replace ( result , 2 , p ) ;
24211: LD_ADDR_VAR 0 2
24215: PUSH
24216: LD_VAR 0 2
24220: PPUSH
24221: LD_INT 2
24223: PPUSH
24224: LD_VAR 0 11
24228: PPUSH
24229: CALL_OW 1
24233: ST_TO_ADDR
// end ; exit ;
24234: GO 25622
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
24236: LD_EXP 77
24240: PUSH
24241: LD_EXP 76
24245: PUSH
24246: LD_VAR 0 1
24250: ARRAY
24251: ARRAY
24252: NOT
24253: PUSH
24254: LD_EXP 50
24258: PUSH
24259: LD_VAR 0 1
24263: ARRAY
24264: PPUSH
24265: LD_INT 30
24267: PUSH
24268: LD_INT 3
24270: PUSH
24271: EMPTY
24272: LIST
24273: LIST
24274: PPUSH
24275: CALL_OW 72
24279: AND
24280: PUSH
24281: LD_EXP 55
24285: PUSH
24286: LD_VAR 0 1
24290: ARRAY
24291: AND
24292: IFFALSE 24900
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
24294: LD_ADDR_EXP 92
24298: PUSH
24299: LD_EXP 92
24303: PPUSH
24304: LD_VAR 0 1
24308: PPUSH
24309: LD_INT 5
24311: PPUSH
24312: CALL_OW 1
24316: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
24317: LD_ADDR_VAR 0 2
24321: PUSH
24322: LD_INT 0
24324: PUSH
24325: LD_INT 0
24327: PUSH
24328: LD_INT 0
24330: PUSH
24331: LD_INT 0
24333: PUSH
24334: EMPTY
24335: LIST
24336: LIST
24337: LIST
24338: LIST
24339: ST_TO_ADDR
// if sci > 1 then
24340: LD_VAR 0 8
24344: PUSH
24345: LD_INT 1
24347: GREATER
24348: IFFALSE 24376
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
24350: LD_ADDR_VAR 0 4
24354: PUSH
24355: LD_VAR 0 4
24359: PUSH
24360: LD_VAR 0 8
24364: PUSH
24365: LD_VAR 0 8
24369: PUSH
24370: LD_INT 1
24372: ARRAY
24373: DIFF
24374: DIFF
24375: ST_TO_ADDR
// if tmp and not sci then
24376: LD_VAR 0 4
24380: PUSH
24381: LD_VAR 0 8
24385: NOT
24386: AND
24387: IFFALSE 24456
// begin sort := SortBySkill ( tmp , 4 ) ;
24389: LD_ADDR_VAR 0 9
24393: PUSH
24394: LD_VAR 0 4
24398: PPUSH
24399: LD_INT 4
24401: PPUSH
24402: CALL 81900 0 2
24406: ST_TO_ADDR
// if sort then
24407: LD_VAR 0 9
24411: IFFALSE 24427
// p := sort [ 1 ] ;
24413: LD_ADDR_VAR 0 11
24417: PUSH
24418: LD_VAR 0 9
24422: PUSH
24423: LD_INT 1
24425: ARRAY
24426: ST_TO_ADDR
// if p then
24427: LD_VAR 0 11
24431: IFFALSE 24456
// result := Replace ( result , 4 , p ) ;
24433: LD_ADDR_VAR 0 2
24437: PUSH
24438: LD_VAR 0 2
24442: PPUSH
24443: LD_INT 4
24445: PPUSH
24446: LD_VAR 0 11
24450: PPUSH
24451: CALL_OW 1
24455: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
24456: LD_ADDR_VAR 0 4
24460: PUSH
24461: LD_VAR 0 4
24465: PUSH
24466: LD_VAR 0 7
24470: DIFF
24471: ST_TO_ADDR
// if tmp and mech < 6 then
24472: LD_VAR 0 4
24476: PUSH
24477: LD_VAR 0 7
24481: PUSH
24482: LD_INT 6
24484: LESS
24485: AND
24486: IFFALSE 24674
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
24488: LD_ADDR_VAR 0 9
24492: PUSH
24493: LD_VAR 0 4
24497: PUSH
24498: LD_VAR 0 8
24502: PUSH
24503: LD_VAR 0 7
24507: UNION
24508: DIFF
24509: PPUSH
24510: LD_INT 3
24512: PPUSH
24513: CALL 81900 0 2
24517: ST_TO_ADDR
// p := [ ] ;
24518: LD_ADDR_VAR 0 11
24522: PUSH
24523: EMPTY
24524: ST_TO_ADDR
// if sort then
24525: LD_VAR 0 9
24529: IFFALSE 24645
// for i = 1 to 6 - mech do
24531: LD_ADDR_VAR 0 3
24535: PUSH
24536: DOUBLE
24537: LD_INT 1
24539: DEC
24540: ST_TO_ADDR
24541: LD_INT 6
24543: PUSH
24544: LD_VAR 0 7
24548: MINUS
24549: PUSH
24550: FOR_TO
24551: IFFALSE 24643
// begin if i = sort then
24553: LD_VAR 0 3
24557: PUSH
24558: LD_VAR 0 9
24562: EQUAL
24563: IFFALSE 24567
// break ;
24565: GO 24643
// if GetClass ( i ) = 3 then
24567: LD_VAR 0 3
24571: PPUSH
24572: CALL_OW 257
24576: PUSH
24577: LD_INT 3
24579: EQUAL
24580: IFFALSE 24584
// continue ;
24582: GO 24550
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24584: LD_ADDR_VAR 0 11
24588: PUSH
24589: LD_VAR 0 11
24593: PPUSH
24594: LD_VAR 0 11
24598: PUSH
24599: LD_INT 1
24601: PLUS
24602: PPUSH
24603: LD_VAR 0 9
24607: PUSH
24608: LD_VAR 0 3
24612: ARRAY
24613: PPUSH
24614: CALL_OW 2
24618: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24619: LD_ADDR_VAR 0 4
24623: PUSH
24624: LD_VAR 0 4
24628: PUSH
24629: LD_VAR 0 9
24633: PUSH
24634: LD_VAR 0 3
24638: ARRAY
24639: DIFF
24640: ST_TO_ADDR
// end ;
24641: GO 24550
24643: POP
24644: POP
// if p then
24645: LD_VAR 0 11
24649: IFFALSE 24674
// result := Replace ( result , 3 , p ) ;
24651: LD_ADDR_VAR 0 2
24655: PUSH
24656: LD_VAR 0 2
24660: PPUSH
24661: LD_INT 3
24663: PPUSH
24664: LD_VAR 0 11
24668: PPUSH
24669: CALL_OW 1
24673: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
24674: LD_ADDR_VAR 0 4
24678: PUSH
24679: LD_VAR 0 4
24683: PUSH
24684: LD_VAR 0 6
24688: DIFF
24689: ST_TO_ADDR
// if tmp and eng < 6 then
24690: LD_VAR 0 4
24694: PUSH
24695: LD_VAR 0 6
24699: PUSH
24700: LD_INT 6
24702: LESS
24703: AND
24704: IFFALSE 24898
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
24706: LD_ADDR_VAR 0 9
24710: PUSH
24711: LD_VAR 0 4
24715: PUSH
24716: LD_VAR 0 8
24720: PUSH
24721: LD_VAR 0 7
24725: UNION
24726: PUSH
24727: LD_VAR 0 6
24731: UNION
24732: DIFF
24733: PPUSH
24734: LD_INT 2
24736: PPUSH
24737: CALL 81900 0 2
24741: ST_TO_ADDR
// p := [ ] ;
24742: LD_ADDR_VAR 0 11
24746: PUSH
24747: EMPTY
24748: ST_TO_ADDR
// if sort then
24749: LD_VAR 0 9
24753: IFFALSE 24869
// for i = 1 to 6 - eng do
24755: LD_ADDR_VAR 0 3
24759: PUSH
24760: DOUBLE
24761: LD_INT 1
24763: DEC
24764: ST_TO_ADDR
24765: LD_INT 6
24767: PUSH
24768: LD_VAR 0 6
24772: MINUS
24773: PUSH
24774: FOR_TO
24775: IFFALSE 24867
// begin if i = sort then
24777: LD_VAR 0 3
24781: PUSH
24782: LD_VAR 0 9
24786: EQUAL
24787: IFFALSE 24791
// break ;
24789: GO 24867
// if GetClass ( i ) = 2 then
24791: LD_VAR 0 3
24795: PPUSH
24796: CALL_OW 257
24800: PUSH
24801: LD_INT 2
24803: EQUAL
24804: IFFALSE 24808
// continue ;
24806: GO 24774
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24808: LD_ADDR_VAR 0 11
24812: PUSH
24813: LD_VAR 0 11
24817: PPUSH
24818: LD_VAR 0 11
24822: PUSH
24823: LD_INT 1
24825: PLUS
24826: PPUSH
24827: LD_VAR 0 9
24831: PUSH
24832: LD_VAR 0 3
24836: ARRAY
24837: PPUSH
24838: CALL_OW 2
24842: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24843: LD_ADDR_VAR 0 4
24847: PUSH
24848: LD_VAR 0 4
24852: PUSH
24853: LD_VAR 0 9
24857: PUSH
24858: LD_VAR 0 3
24862: ARRAY
24863: DIFF
24864: ST_TO_ADDR
// end ;
24865: GO 24774
24867: POP
24868: POP
// if p then
24869: LD_VAR 0 11
24873: IFFALSE 24898
// result := Replace ( result , 2 , p ) ;
24875: LD_ADDR_VAR 0 2
24879: PUSH
24880: LD_VAR 0 2
24884: PPUSH
24885: LD_INT 2
24887: PPUSH
24888: LD_VAR 0 11
24892: PPUSH
24893: CALL_OW 1
24897: ST_TO_ADDR
// end ; exit ;
24898: GO 25622
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
24900: LD_EXP 77
24904: PUSH
24905: LD_EXP 76
24909: PUSH
24910: LD_VAR 0 1
24914: ARRAY
24915: ARRAY
24916: NOT
24917: PUSH
24918: LD_EXP 50
24922: PUSH
24923: LD_VAR 0 1
24927: ARRAY
24928: PPUSH
24929: LD_INT 30
24931: PUSH
24932: LD_INT 3
24934: PUSH
24935: EMPTY
24936: LIST
24937: LIST
24938: PPUSH
24939: CALL_OW 72
24943: AND
24944: PUSH
24945: LD_EXP 55
24949: PUSH
24950: LD_VAR 0 1
24954: ARRAY
24955: NOT
24956: AND
24957: IFFALSE 25622
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
24959: LD_ADDR_EXP 92
24963: PUSH
24964: LD_EXP 92
24968: PPUSH
24969: LD_VAR 0 1
24973: PPUSH
24974: LD_INT 6
24976: PPUSH
24977: CALL_OW 1
24981: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
24982: LD_ADDR_VAR 0 2
24986: PUSH
24987: LD_INT 0
24989: PUSH
24990: LD_INT 0
24992: PUSH
24993: LD_INT 0
24995: PUSH
24996: LD_INT 0
24998: PUSH
24999: EMPTY
25000: LIST
25001: LIST
25002: LIST
25003: LIST
25004: ST_TO_ADDR
// if sci >= 1 then
25005: LD_VAR 0 8
25009: PUSH
25010: LD_INT 1
25012: GREATEREQUAL
25013: IFFALSE 25035
// tmp := tmp diff sci [ 1 ] ;
25015: LD_ADDR_VAR 0 4
25019: PUSH
25020: LD_VAR 0 4
25024: PUSH
25025: LD_VAR 0 8
25029: PUSH
25030: LD_INT 1
25032: ARRAY
25033: DIFF
25034: ST_TO_ADDR
// if tmp and not sci then
25035: LD_VAR 0 4
25039: PUSH
25040: LD_VAR 0 8
25044: NOT
25045: AND
25046: IFFALSE 25115
// begin sort := SortBySkill ( tmp , 4 ) ;
25048: LD_ADDR_VAR 0 9
25052: PUSH
25053: LD_VAR 0 4
25057: PPUSH
25058: LD_INT 4
25060: PPUSH
25061: CALL 81900 0 2
25065: ST_TO_ADDR
// if sort then
25066: LD_VAR 0 9
25070: IFFALSE 25086
// p := sort [ 1 ] ;
25072: LD_ADDR_VAR 0 11
25076: PUSH
25077: LD_VAR 0 9
25081: PUSH
25082: LD_INT 1
25084: ARRAY
25085: ST_TO_ADDR
// if p then
25086: LD_VAR 0 11
25090: IFFALSE 25115
// result := Replace ( result , 4 , p ) ;
25092: LD_ADDR_VAR 0 2
25096: PUSH
25097: LD_VAR 0 2
25101: PPUSH
25102: LD_INT 4
25104: PPUSH
25105: LD_VAR 0 11
25109: PPUSH
25110: CALL_OW 1
25114: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
25115: LD_ADDR_VAR 0 4
25119: PUSH
25120: LD_VAR 0 4
25124: PUSH
25125: LD_VAR 0 7
25129: DIFF
25130: ST_TO_ADDR
// if tmp and mech < 6 then
25131: LD_VAR 0 4
25135: PUSH
25136: LD_VAR 0 7
25140: PUSH
25141: LD_INT 6
25143: LESS
25144: AND
25145: IFFALSE 25327
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
25147: LD_ADDR_VAR 0 9
25151: PUSH
25152: LD_VAR 0 4
25156: PUSH
25157: LD_VAR 0 7
25161: DIFF
25162: PPUSH
25163: LD_INT 3
25165: PPUSH
25166: CALL 81900 0 2
25170: ST_TO_ADDR
// p := [ ] ;
25171: LD_ADDR_VAR 0 11
25175: PUSH
25176: EMPTY
25177: ST_TO_ADDR
// if sort then
25178: LD_VAR 0 9
25182: IFFALSE 25298
// for i = 1 to 6 - mech do
25184: LD_ADDR_VAR 0 3
25188: PUSH
25189: DOUBLE
25190: LD_INT 1
25192: DEC
25193: ST_TO_ADDR
25194: LD_INT 6
25196: PUSH
25197: LD_VAR 0 7
25201: MINUS
25202: PUSH
25203: FOR_TO
25204: IFFALSE 25296
// begin if i = sort then
25206: LD_VAR 0 3
25210: PUSH
25211: LD_VAR 0 9
25215: EQUAL
25216: IFFALSE 25220
// break ;
25218: GO 25296
// if GetClass ( i ) = 3 then
25220: LD_VAR 0 3
25224: PPUSH
25225: CALL_OW 257
25229: PUSH
25230: LD_INT 3
25232: EQUAL
25233: IFFALSE 25237
// continue ;
25235: GO 25203
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25237: LD_ADDR_VAR 0 11
25241: PUSH
25242: LD_VAR 0 11
25246: PPUSH
25247: LD_VAR 0 11
25251: PUSH
25252: LD_INT 1
25254: PLUS
25255: PPUSH
25256: LD_VAR 0 9
25260: PUSH
25261: LD_VAR 0 3
25265: ARRAY
25266: PPUSH
25267: CALL_OW 2
25271: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25272: LD_ADDR_VAR 0 4
25276: PUSH
25277: LD_VAR 0 4
25281: PUSH
25282: LD_VAR 0 9
25286: PUSH
25287: LD_VAR 0 3
25291: ARRAY
25292: DIFF
25293: ST_TO_ADDR
// end ;
25294: GO 25203
25296: POP
25297: POP
// if p then
25298: LD_VAR 0 11
25302: IFFALSE 25327
// result := Replace ( result , 3 , p ) ;
25304: LD_ADDR_VAR 0 2
25308: PUSH
25309: LD_VAR 0 2
25313: PPUSH
25314: LD_INT 3
25316: PPUSH
25317: LD_VAR 0 11
25321: PPUSH
25322: CALL_OW 1
25326: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
25327: LD_ADDR_VAR 0 4
25331: PUSH
25332: LD_VAR 0 4
25336: PUSH
25337: LD_VAR 0 6
25341: DIFF
25342: ST_TO_ADDR
// if tmp and eng < 4 then
25343: LD_VAR 0 4
25347: PUSH
25348: LD_VAR 0 6
25352: PUSH
25353: LD_INT 4
25355: LESS
25356: AND
25357: IFFALSE 25547
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
25359: LD_ADDR_VAR 0 9
25363: PUSH
25364: LD_VAR 0 4
25368: PUSH
25369: LD_VAR 0 7
25373: PUSH
25374: LD_VAR 0 6
25378: UNION
25379: DIFF
25380: PPUSH
25381: LD_INT 2
25383: PPUSH
25384: CALL 81900 0 2
25388: ST_TO_ADDR
// p := [ ] ;
25389: LD_ADDR_VAR 0 11
25393: PUSH
25394: EMPTY
25395: ST_TO_ADDR
// if sort then
25396: LD_VAR 0 9
25400: IFFALSE 25516
// for i = 1 to 4 - eng do
25402: LD_ADDR_VAR 0 3
25406: PUSH
25407: DOUBLE
25408: LD_INT 1
25410: DEC
25411: ST_TO_ADDR
25412: LD_INT 4
25414: PUSH
25415: LD_VAR 0 6
25419: MINUS
25420: PUSH
25421: FOR_TO
25422: IFFALSE 25514
// begin if i = sort then
25424: LD_VAR 0 3
25428: PUSH
25429: LD_VAR 0 9
25433: EQUAL
25434: IFFALSE 25438
// break ;
25436: GO 25514
// if GetClass ( i ) = 2 then
25438: LD_VAR 0 3
25442: PPUSH
25443: CALL_OW 257
25447: PUSH
25448: LD_INT 2
25450: EQUAL
25451: IFFALSE 25455
// continue ;
25453: GO 25421
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25455: LD_ADDR_VAR 0 11
25459: PUSH
25460: LD_VAR 0 11
25464: PPUSH
25465: LD_VAR 0 11
25469: PUSH
25470: LD_INT 1
25472: PLUS
25473: PPUSH
25474: LD_VAR 0 9
25478: PUSH
25479: LD_VAR 0 3
25483: ARRAY
25484: PPUSH
25485: CALL_OW 2
25489: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25490: LD_ADDR_VAR 0 4
25494: PUSH
25495: LD_VAR 0 4
25499: PUSH
25500: LD_VAR 0 9
25504: PUSH
25505: LD_VAR 0 3
25509: ARRAY
25510: DIFF
25511: ST_TO_ADDR
// end ;
25512: GO 25421
25514: POP
25515: POP
// if p then
25516: LD_VAR 0 11
25520: IFFALSE 25545
// result := Replace ( result , 2 , p ) ;
25522: LD_ADDR_VAR 0 2
25526: PUSH
25527: LD_VAR 0 2
25531: PPUSH
25532: LD_INT 2
25534: PPUSH
25535: LD_VAR 0 11
25539: PPUSH
25540: CALL_OW 1
25544: ST_TO_ADDR
// end else
25545: GO 25591
// for i = eng downto 5 do
25547: LD_ADDR_VAR 0 3
25551: PUSH
25552: DOUBLE
25553: LD_VAR 0 6
25557: INC
25558: ST_TO_ADDR
25559: LD_INT 5
25561: PUSH
25562: FOR_DOWNTO
25563: IFFALSE 25589
// tmp := tmp union eng [ i ] ;
25565: LD_ADDR_VAR 0 4
25569: PUSH
25570: LD_VAR 0 4
25574: PUSH
25575: LD_VAR 0 6
25579: PUSH
25580: LD_VAR 0 3
25584: ARRAY
25585: UNION
25586: ST_TO_ADDR
25587: GO 25562
25589: POP
25590: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
25591: LD_ADDR_VAR 0 2
25595: PUSH
25596: LD_VAR 0 2
25600: PPUSH
25601: LD_INT 1
25603: PPUSH
25604: LD_VAR 0 4
25608: PUSH
25609: LD_VAR 0 5
25613: DIFF
25614: PPUSH
25615: CALL_OW 1
25619: ST_TO_ADDR
// exit ;
25620: GO 25622
// end ; end ;
25622: LD_VAR 0 2
25626: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
25627: LD_INT 0
25629: PPUSH
25630: PPUSH
25631: PPUSH
// if not mc_bases then
25632: LD_EXP 50
25636: NOT
25637: IFFALSE 25641
// exit ;
25639: GO 25747
// for i = 1 to mc_bases do
25641: LD_ADDR_VAR 0 2
25645: PUSH
25646: DOUBLE
25647: LD_INT 1
25649: DEC
25650: ST_TO_ADDR
25651: LD_EXP 50
25655: PUSH
25656: FOR_TO
25657: IFFALSE 25738
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
25659: LD_ADDR_VAR 0 3
25663: PUSH
25664: LD_EXP 50
25668: PUSH
25669: LD_VAR 0 2
25673: ARRAY
25674: PPUSH
25675: LD_INT 21
25677: PUSH
25678: LD_INT 3
25680: PUSH
25681: EMPTY
25682: LIST
25683: LIST
25684: PUSH
25685: LD_INT 3
25687: PUSH
25688: LD_INT 24
25690: PUSH
25691: LD_INT 1000
25693: PUSH
25694: EMPTY
25695: LIST
25696: LIST
25697: PUSH
25698: EMPTY
25699: LIST
25700: LIST
25701: PUSH
25702: EMPTY
25703: LIST
25704: LIST
25705: PPUSH
25706: CALL_OW 72
25710: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
25711: LD_ADDR_EXP 51
25715: PUSH
25716: LD_EXP 51
25720: PPUSH
25721: LD_VAR 0 2
25725: PPUSH
25726: LD_VAR 0 3
25730: PPUSH
25731: CALL_OW 1
25735: ST_TO_ADDR
// end ;
25736: GO 25656
25738: POP
25739: POP
// RaiseSailEvent ( 101 ) ;
25740: LD_INT 101
25742: PPUSH
25743: CALL_OW 427
// end ;
25747: LD_VAR 0 1
25751: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
25752: LD_INT 0
25754: PPUSH
25755: PPUSH
25756: PPUSH
25757: PPUSH
25758: PPUSH
25759: PPUSH
25760: PPUSH
// if not mc_bases then
25761: LD_EXP 50
25765: NOT
25766: IFFALSE 25770
// exit ;
25768: GO 26332
// for i = 1 to mc_bases do
25770: LD_ADDR_VAR 0 2
25774: PUSH
25775: DOUBLE
25776: LD_INT 1
25778: DEC
25779: ST_TO_ADDR
25780: LD_EXP 50
25784: PUSH
25785: FOR_TO
25786: IFFALSE 26323
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
25788: LD_ADDR_VAR 0 5
25792: PUSH
25793: LD_EXP 50
25797: PUSH
25798: LD_VAR 0 2
25802: ARRAY
25803: PUSH
25804: LD_EXP 79
25808: PUSH
25809: LD_VAR 0 2
25813: ARRAY
25814: UNION
25815: PPUSH
25816: LD_INT 21
25818: PUSH
25819: LD_INT 1
25821: PUSH
25822: EMPTY
25823: LIST
25824: LIST
25825: PUSH
25826: LD_INT 1
25828: PUSH
25829: LD_INT 3
25831: PUSH
25832: LD_INT 54
25834: PUSH
25835: EMPTY
25836: LIST
25837: PUSH
25838: EMPTY
25839: LIST
25840: LIST
25841: PUSH
25842: LD_INT 3
25844: PUSH
25845: LD_INT 24
25847: PUSH
25848: LD_INT 800
25850: PUSH
25851: EMPTY
25852: LIST
25853: LIST
25854: PUSH
25855: EMPTY
25856: LIST
25857: LIST
25858: PUSH
25859: EMPTY
25860: LIST
25861: LIST
25862: LIST
25863: PUSH
25864: EMPTY
25865: LIST
25866: LIST
25867: PPUSH
25868: CALL_OW 72
25872: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
25873: LD_ADDR_VAR 0 6
25877: PUSH
25878: LD_EXP 50
25882: PUSH
25883: LD_VAR 0 2
25887: ARRAY
25888: PPUSH
25889: LD_INT 21
25891: PUSH
25892: LD_INT 1
25894: PUSH
25895: EMPTY
25896: LIST
25897: LIST
25898: PUSH
25899: LD_INT 1
25901: PUSH
25902: LD_INT 3
25904: PUSH
25905: LD_INT 54
25907: PUSH
25908: EMPTY
25909: LIST
25910: PUSH
25911: EMPTY
25912: LIST
25913: LIST
25914: PUSH
25915: LD_INT 3
25917: PUSH
25918: LD_INT 24
25920: PUSH
25921: LD_INT 250
25923: PUSH
25924: EMPTY
25925: LIST
25926: LIST
25927: PUSH
25928: EMPTY
25929: LIST
25930: LIST
25931: PUSH
25932: EMPTY
25933: LIST
25934: LIST
25935: LIST
25936: PUSH
25937: EMPTY
25938: LIST
25939: LIST
25940: PPUSH
25941: CALL_OW 72
25945: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
25946: LD_ADDR_VAR 0 7
25950: PUSH
25951: LD_VAR 0 5
25955: PUSH
25956: LD_VAR 0 6
25960: DIFF
25961: ST_TO_ADDR
// if not need_heal_1 then
25962: LD_VAR 0 6
25966: NOT
25967: IFFALSE 26000
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
25969: LD_ADDR_EXP 53
25973: PUSH
25974: LD_EXP 53
25978: PPUSH
25979: LD_VAR 0 2
25983: PUSH
25984: LD_INT 1
25986: PUSH
25987: EMPTY
25988: LIST
25989: LIST
25990: PPUSH
25991: EMPTY
25992: PPUSH
25993: CALL 52351 0 3
25997: ST_TO_ADDR
25998: GO 26070
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
26000: LD_ADDR_EXP 53
26004: PUSH
26005: LD_EXP 53
26009: PPUSH
26010: LD_VAR 0 2
26014: PUSH
26015: LD_INT 1
26017: PUSH
26018: EMPTY
26019: LIST
26020: LIST
26021: PPUSH
26022: LD_EXP 53
26026: PUSH
26027: LD_VAR 0 2
26031: ARRAY
26032: PUSH
26033: LD_INT 1
26035: ARRAY
26036: PPUSH
26037: LD_INT 3
26039: PUSH
26040: LD_INT 24
26042: PUSH
26043: LD_INT 1000
26045: PUSH
26046: EMPTY
26047: LIST
26048: LIST
26049: PUSH
26050: EMPTY
26051: LIST
26052: LIST
26053: PPUSH
26054: CALL_OW 72
26058: PUSH
26059: LD_VAR 0 6
26063: UNION
26064: PPUSH
26065: CALL 52351 0 3
26069: ST_TO_ADDR
// if not need_heal_2 then
26070: LD_VAR 0 7
26074: NOT
26075: IFFALSE 26108
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
26077: LD_ADDR_EXP 53
26081: PUSH
26082: LD_EXP 53
26086: PPUSH
26087: LD_VAR 0 2
26091: PUSH
26092: LD_INT 2
26094: PUSH
26095: EMPTY
26096: LIST
26097: LIST
26098: PPUSH
26099: EMPTY
26100: PPUSH
26101: CALL 52351 0 3
26105: ST_TO_ADDR
26106: GO 26140
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
26108: LD_ADDR_EXP 53
26112: PUSH
26113: LD_EXP 53
26117: PPUSH
26118: LD_VAR 0 2
26122: PUSH
26123: LD_INT 2
26125: PUSH
26126: EMPTY
26127: LIST
26128: LIST
26129: PPUSH
26130: LD_VAR 0 7
26134: PPUSH
26135: CALL 52351 0 3
26139: ST_TO_ADDR
// if need_heal_2 then
26140: LD_VAR 0 7
26144: IFFALSE 26305
// for j in need_heal_2 do
26146: LD_ADDR_VAR 0 3
26150: PUSH
26151: LD_VAR 0 7
26155: PUSH
26156: FOR_IN
26157: IFFALSE 26303
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
26159: LD_ADDR_VAR 0 5
26163: PUSH
26164: LD_EXP 50
26168: PUSH
26169: LD_VAR 0 2
26173: ARRAY
26174: PPUSH
26175: LD_INT 2
26177: PUSH
26178: LD_INT 30
26180: PUSH
26181: LD_INT 6
26183: PUSH
26184: EMPTY
26185: LIST
26186: LIST
26187: PUSH
26188: LD_INT 30
26190: PUSH
26191: LD_INT 7
26193: PUSH
26194: EMPTY
26195: LIST
26196: LIST
26197: PUSH
26198: LD_INT 30
26200: PUSH
26201: LD_INT 8
26203: PUSH
26204: EMPTY
26205: LIST
26206: LIST
26207: PUSH
26208: LD_INT 30
26210: PUSH
26211: LD_INT 0
26213: PUSH
26214: EMPTY
26215: LIST
26216: LIST
26217: PUSH
26218: LD_INT 30
26220: PUSH
26221: LD_INT 1
26223: PUSH
26224: EMPTY
26225: LIST
26226: LIST
26227: PUSH
26228: EMPTY
26229: LIST
26230: LIST
26231: LIST
26232: LIST
26233: LIST
26234: LIST
26235: PPUSH
26236: CALL_OW 72
26240: ST_TO_ADDR
// if tmp then
26241: LD_VAR 0 5
26245: IFFALSE 26301
// begin k := NearestUnitToUnit ( tmp , j ) ;
26247: LD_ADDR_VAR 0 4
26251: PUSH
26252: LD_VAR 0 5
26256: PPUSH
26257: LD_VAR 0 3
26261: PPUSH
26262: CALL_OW 74
26266: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
26267: LD_VAR 0 3
26271: PPUSH
26272: LD_VAR 0 4
26276: PPUSH
26277: CALL_OW 296
26281: PUSH
26282: LD_INT 5
26284: GREATER
26285: IFFALSE 26301
// ComMoveUnit ( j , k ) ;
26287: LD_VAR 0 3
26291: PPUSH
26292: LD_VAR 0 4
26296: PPUSH
26297: CALL_OW 112
// end ; end ;
26301: GO 26156
26303: POP
26304: POP
// if not need_heal_1 and not need_heal_2 then
26305: LD_VAR 0 6
26309: NOT
26310: PUSH
26311: LD_VAR 0 7
26315: NOT
26316: AND
26317: IFFALSE 26321
// continue ;
26319: GO 25785
// end ;
26321: GO 25785
26323: POP
26324: POP
// RaiseSailEvent ( 102 ) ;
26325: LD_INT 102
26327: PPUSH
26328: CALL_OW 427
// end ;
26332: LD_VAR 0 1
26336: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
26337: LD_INT 0
26339: PPUSH
26340: PPUSH
26341: PPUSH
26342: PPUSH
26343: PPUSH
26344: PPUSH
26345: PPUSH
26346: PPUSH
// if not mc_bases then
26347: LD_EXP 50
26351: NOT
26352: IFFALSE 26356
// exit ;
26354: GO 27191
// for i = 1 to mc_bases do
26356: LD_ADDR_VAR 0 2
26360: PUSH
26361: DOUBLE
26362: LD_INT 1
26364: DEC
26365: ST_TO_ADDR
26366: LD_EXP 50
26370: PUSH
26371: FOR_TO
26372: IFFALSE 27189
// begin if not mc_building_need_repair [ i ] then
26374: LD_EXP 51
26378: PUSH
26379: LD_VAR 0 2
26383: ARRAY
26384: NOT
26385: IFFALSE 26559
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
26387: LD_ADDR_VAR 0 6
26391: PUSH
26392: LD_EXP 69
26396: PUSH
26397: LD_VAR 0 2
26401: ARRAY
26402: PPUSH
26403: LD_INT 3
26405: PUSH
26406: LD_INT 24
26408: PUSH
26409: LD_INT 1000
26411: PUSH
26412: EMPTY
26413: LIST
26414: LIST
26415: PUSH
26416: EMPTY
26417: LIST
26418: LIST
26419: PUSH
26420: LD_INT 2
26422: PUSH
26423: LD_INT 34
26425: PUSH
26426: LD_INT 13
26428: PUSH
26429: EMPTY
26430: LIST
26431: LIST
26432: PUSH
26433: LD_INT 34
26435: PUSH
26436: LD_INT 52
26438: PUSH
26439: EMPTY
26440: LIST
26441: LIST
26442: PUSH
26443: EMPTY
26444: LIST
26445: LIST
26446: LIST
26447: PUSH
26448: EMPTY
26449: LIST
26450: LIST
26451: PPUSH
26452: CALL_OW 72
26456: ST_TO_ADDR
// if cranes then
26457: LD_VAR 0 6
26461: IFFALSE 26523
// for j in cranes do
26463: LD_ADDR_VAR 0 3
26467: PUSH
26468: LD_VAR 0 6
26472: PUSH
26473: FOR_IN
26474: IFFALSE 26521
// if not IsInArea ( j , mc_parking [ i ] ) then
26476: LD_VAR 0 3
26480: PPUSH
26481: LD_EXP 74
26485: PUSH
26486: LD_VAR 0 2
26490: ARRAY
26491: PPUSH
26492: CALL_OW 308
26496: NOT
26497: IFFALSE 26519
// ComMoveToArea ( j , mc_parking [ i ] ) ;
26499: LD_VAR 0 3
26503: PPUSH
26504: LD_EXP 74
26508: PUSH
26509: LD_VAR 0 2
26513: ARRAY
26514: PPUSH
26515: CALL_OW 113
26519: GO 26473
26521: POP
26522: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
26523: LD_ADDR_EXP 52
26527: PUSH
26528: LD_EXP 52
26532: PPUSH
26533: LD_VAR 0 2
26537: PPUSH
26538: EMPTY
26539: PPUSH
26540: CALL_OW 1
26544: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
26545: LD_VAR 0 2
26549: PPUSH
26550: LD_INT 101
26552: PPUSH
26553: CALL 21460 0 2
// continue ;
26557: GO 26371
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
26559: LD_ADDR_EXP 56
26563: PUSH
26564: LD_EXP 56
26568: PPUSH
26569: LD_VAR 0 2
26573: PPUSH
26574: EMPTY
26575: PPUSH
26576: CALL_OW 1
26580: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
26581: LD_VAR 0 2
26585: PPUSH
26586: LD_INT 103
26588: PPUSH
26589: CALL 21460 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
26593: LD_ADDR_VAR 0 5
26597: PUSH
26598: LD_EXP 50
26602: PUSH
26603: LD_VAR 0 2
26607: ARRAY
26608: PUSH
26609: LD_EXP 79
26613: PUSH
26614: LD_VAR 0 2
26618: ARRAY
26619: UNION
26620: PPUSH
26621: LD_INT 2
26623: PUSH
26624: LD_INT 25
26626: PUSH
26627: LD_INT 2
26629: PUSH
26630: EMPTY
26631: LIST
26632: LIST
26633: PUSH
26634: LD_INT 25
26636: PUSH
26637: LD_INT 16
26639: PUSH
26640: EMPTY
26641: LIST
26642: LIST
26643: PUSH
26644: EMPTY
26645: LIST
26646: LIST
26647: LIST
26648: PUSH
26649: EMPTY
26650: LIST
26651: PPUSH
26652: CALL_OW 72
26656: PUSH
26657: LD_EXP 53
26661: PUSH
26662: LD_VAR 0 2
26666: ARRAY
26667: PUSH
26668: LD_INT 1
26670: ARRAY
26671: PUSH
26672: LD_EXP 53
26676: PUSH
26677: LD_VAR 0 2
26681: ARRAY
26682: PUSH
26683: LD_INT 2
26685: ARRAY
26686: UNION
26687: DIFF
26688: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
26689: LD_ADDR_VAR 0 6
26693: PUSH
26694: LD_EXP 69
26698: PUSH
26699: LD_VAR 0 2
26703: ARRAY
26704: PPUSH
26705: LD_INT 2
26707: PUSH
26708: LD_INT 34
26710: PUSH
26711: LD_INT 13
26713: PUSH
26714: EMPTY
26715: LIST
26716: LIST
26717: PUSH
26718: LD_INT 34
26720: PUSH
26721: LD_INT 52
26723: PUSH
26724: EMPTY
26725: LIST
26726: LIST
26727: PUSH
26728: EMPTY
26729: LIST
26730: LIST
26731: LIST
26732: PPUSH
26733: CALL_OW 72
26737: ST_TO_ADDR
// if cranes then
26738: LD_VAR 0 6
26742: IFFALSE 26878
// begin for j in cranes do
26744: LD_ADDR_VAR 0 3
26748: PUSH
26749: LD_VAR 0 6
26753: PUSH
26754: FOR_IN
26755: IFFALSE 26876
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
26757: LD_VAR 0 3
26761: PPUSH
26762: CALL_OW 256
26766: PUSH
26767: LD_INT 500
26769: GREATEREQUAL
26770: PUSH
26771: LD_VAR 0 3
26775: PPUSH
26776: CALL_OW 314
26780: NOT
26781: AND
26782: IFFALSE 26816
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
26784: LD_VAR 0 3
26788: PPUSH
26789: LD_EXP 51
26793: PUSH
26794: LD_VAR 0 2
26798: ARRAY
26799: PPUSH
26800: LD_VAR 0 3
26804: PPUSH
26805: CALL_OW 74
26809: PPUSH
26810: CALL_OW 130
26814: GO 26874
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
26816: LD_VAR 0 3
26820: PPUSH
26821: CALL_OW 256
26825: PUSH
26826: LD_INT 500
26828: LESS
26829: PUSH
26830: LD_VAR 0 3
26834: PPUSH
26835: LD_EXP 74
26839: PUSH
26840: LD_VAR 0 2
26844: ARRAY
26845: PPUSH
26846: CALL_OW 308
26850: NOT
26851: AND
26852: IFFALSE 26874
// ComMoveToArea ( j , mc_parking [ i ] ) ;
26854: LD_VAR 0 3
26858: PPUSH
26859: LD_EXP 74
26863: PUSH
26864: LD_VAR 0 2
26868: ARRAY
26869: PPUSH
26870: CALL_OW 113
26874: GO 26754
26876: POP
26877: POP
// end ; if tmp > 3 then
26878: LD_VAR 0 5
26882: PUSH
26883: LD_INT 3
26885: GREATER
26886: IFFALSE 26906
// tmp := ShrinkArray ( tmp , 4 ) ;
26888: LD_ADDR_VAR 0 5
26892: PUSH
26893: LD_VAR 0 5
26897: PPUSH
26898: LD_INT 4
26900: PPUSH
26901: CALL 83590 0 2
26905: ST_TO_ADDR
// if not tmp then
26906: LD_VAR 0 5
26910: NOT
26911: IFFALSE 26915
// continue ;
26913: GO 26371
// for j in tmp do
26915: LD_ADDR_VAR 0 3
26919: PUSH
26920: LD_VAR 0 5
26924: PUSH
26925: FOR_IN
26926: IFFALSE 27185
// begin if IsInUnit ( j ) then
26928: LD_VAR 0 3
26932: PPUSH
26933: CALL_OW 310
26937: IFFALSE 26948
// ComExitBuilding ( j ) ;
26939: LD_VAR 0 3
26943: PPUSH
26944: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
26948: LD_VAR 0 3
26952: PUSH
26953: LD_EXP 52
26957: PUSH
26958: LD_VAR 0 2
26962: ARRAY
26963: IN
26964: NOT
26965: IFFALSE 27023
// begin SetTag ( j , 101 ) ;
26967: LD_VAR 0 3
26971: PPUSH
26972: LD_INT 101
26974: PPUSH
26975: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
26979: LD_ADDR_EXP 52
26983: PUSH
26984: LD_EXP 52
26988: PPUSH
26989: LD_VAR 0 2
26993: PUSH
26994: LD_EXP 52
26998: PUSH
26999: LD_VAR 0 2
27003: ARRAY
27004: PUSH
27005: LD_INT 1
27007: PLUS
27008: PUSH
27009: EMPTY
27010: LIST
27011: LIST
27012: PPUSH
27013: LD_VAR 0 3
27017: PPUSH
27018: CALL 52351 0 3
27022: ST_TO_ADDR
// end ; wait ( 1 ) ;
27023: LD_INT 1
27025: PPUSH
27026: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
27030: LD_ADDR_VAR 0 7
27034: PUSH
27035: LD_EXP 51
27039: PUSH
27040: LD_VAR 0 2
27044: ARRAY
27045: ST_TO_ADDR
// if mc_scan [ i ] then
27046: LD_EXP 73
27050: PUSH
27051: LD_VAR 0 2
27055: ARRAY
27056: IFFALSE 27118
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
27058: LD_ADDR_VAR 0 7
27062: PUSH
27063: LD_EXP 51
27067: PUSH
27068: LD_VAR 0 2
27072: ARRAY
27073: PPUSH
27074: LD_INT 3
27076: PUSH
27077: LD_INT 30
27079: PUSH
27080: LD_INT 32
27082: PUSH
27083: EMPTY
27084: LIST
27085: LIST
27086: PUSH
27087: LD_INT 30
27089: PUSH
27090: LD_INT 33
27092: PUSH
27093: EMPTY
27094: LIST
27095: LIST
27096: PUSH
27097: LD_INT 30
27099: PUSH
27100: LD_INT 31
27102: PUSH
27103: EMPTY
27104: LIST
27105: LIST
27106: PUSH
27107: EMPTY
27108: LIST
27109: LIST
27110: LIST
27111: LIST
27112: PPUSH
27113: CALL_OW 72
27117: ST_TO_ADDR
// if not to_repair_tmp then
27118: LD_VAR 0 7
27122: NOT
27123: IFFALSE 27127
// continue ;
27125: GO 26925
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
27127: LD_ADDR_VAR 0 8
27131: PUSH
27132: LD_VAR 0 7
27136: PPUSH
27137: LD_VAR 0 3
27141: PPUSH
27142: CALL_OW 74
27146: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 5 then
27147: LD_VAR 0 8
27151: PPUSH
27152: LD_INT 16
27154: PPUSH
27155: CALL 54944 0 2
27159: PUSH
27160: LD_INT 4
27162: ARRAY
27163: PUSH
27164: LD_INT 5
27166: LESS
27167: IFFALSE 27183
// ComRepairBuilding ( j , to_repair ) ;
27169: LD_VAR 0 3
27173: PPUSH
27174: LD_VAR 0 8
27178: PPUSH
27179: CALL_OW 130
// end ;
27183: GO 26925
27185: POP
27186: POP
// end ;
27187: GO 26371
27189: POP
27190: POP
// end ;
27191: LD_VAR 0 1
27195: RET
// export function MC_Heal ; var i , j , tmp ; begin
27196: LD_INT 0
27198: PPUSH
27199: PPUSH
27200: PPUSH
27201: PPUSH
// if not mc_bases then
27202: LD_EXP 50
27206: NOT
27207: IFFALSE 27211
// exit ;
27209: GO 27613
// for i = 1 to mc_bases do
27211: LD_ADDR_VAR 0 2
27215: PUSH
27216: DOUBLE
27217: LD_INT 1
27219: DEC
27220: ST_TO_ADDR
27221: LD_EXP 50
27225: PUSH
27226: FOR_TO
27227: IFFALSE 27611
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
27229: LD_EXP 53
27233: PUSH
27234: LD_VAR 0 2
27238: ARRAY
27239: PUSH
27240: LD_INT 1
27242: ARRAY
27243: NOT
27244: PUSH
27245: LD_EXP 53
27249: PUSH
27250: LD_VAR 0 2
27254: ARRAY
27255: PUSH
27256: LD_INT 2
27258: ARRAY
27259: NOT
27260: AND
27261: IFFALSE 27299
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
27263: LD_ADDR_EXP 54
27267: PUSH
27268: LD_EXP 54
27272: PPUSH
27273: LD_VAR 0 2
27277: PPUSH
27278: EMPTY
27279: PPUSH
27280: CALL_OW 1
27284: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
27285: LD_VAR 0 2
27289: PPUSH
27290: LD_INT 102
27292: PPUSH
27293: CALL 21460 0 2
// continue ;
27297: GO 27226
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
27299: LD_ADDR_VAR 0 4
27303: PUSH
27304: LD_EXP 50
27308: PUSH
27309: LD_VAR 0 2
27313: ARRAY
27314: PPUSH
27315: LD_INT 25
27317: PUSH
27318: LD_INT 4
27320: PUSH
27321: EMPTY
27322: LIST
27323: LIST
27324: PPUSH
27325: CALL_OW 72
27329: ST_TO_ADDR
// if not tmp then
27330: LD_VAR 0 4
27334: NOT
27335: IFFALSE 27339
// continue ;
27337: GO 27226
// if mc_taming [ i ] then
27339: LD_EXP 81
27343: PUSH
27344: LD_VAR 0 2
27348: ARRAY
27349: IFFALSE 27373
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
27351: LD_ADDR_EXP 81
27355: PUSH
27356: LD_EXP 81
27360: PPUSH
27361: LD_VAR 0 2
27365: PPUSH
27366: EMPTY
27367: PPUSH
27368: CALL_OW 1
27372: ST_TO_ADDR
// for j in tmp do
27373: LD_ADDR_VAR 0 3
27377: PUSH
27378: LD_VAR 0 4
27382: PUSH
27383: FOR_IN
27384: IFFALSE 27607
// begin if IsInUnit ( j ) then
27386: LD_VAR 0 3
27390: PPUSH
27391: CALL_OW 310
27395: IFFALSE 27406
// ComExitBuilding ( j ) ;
27397: LD_VAR 0 3
27401: PPUSH
27402: CALL_OW 122
// if not j in mc_healers [ i ] then
27406: LD_VAR 0 3
27410: PUSH
27411: LD_EXP 54
27415: PUSH
27416: LD_VAR 0 2
27420: ARRAY
27421: IN
27422: NOT
27423: IFFALSE 27469
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
27425: LD_ADDR_EXP 54
27429: PUSH
27430: LD_EXP 54
27434: PPUSH
27435: LD_VAR 0 2
27439: PUSH
27440: LD_EXP 54
27444: PUSH
27445: LD_VAR 0 2
27449: ARRAY
27450: PUSH
27451: LD_INT 1
27453: PLUS
27454: PUSH
27455: EMPTY
27456: LIST
27457: LIST
27458: PPUSH
27459: LD_VAR 0 3
27463: PPUSH
27464: CALL 52351 0 3
27468: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
27469: LD_VAR 0 3
27473: PPUSH
27474: CALL_OW 110
27478: PUSH
27479: LD_INT 102
27481: NONEQUAL
27482: IFFALSE 27496
// SetTag ( j , 102 ) ;
27484: LD_VAR 0 3
27488: PPUSH
27489: LD_INT 102
27491: PPUSH
27492: CALL_OW 109
// Wait ( 3 ) ;
27496: LD_INT 3
27498: PPUSH
27499: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
27503: LD_EXP 53
27507: PUSH
27508: LD_VAR 0 2
27512: ARRAY
27513: PUSH
27514: LD_INT 1
27516: ARRAY
27517: IFFALSE 27549
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
27519: LD_VAR 0 3
27523: PPUSH
27524: LD_EXP 53
27528: PUSH
27529: LD_VAR 0 2
27533: ARRAY
27534: PUSH
27535: LD_INT 1
27537: ARRAY
27538: PUSH
27539: LD_INT 1
27541: ARRAY
27542: PPUSH
27543: CALL_OW 128
27547: GO 27605
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
27549: LD_VAR 0 3
27553: PPUSH
27554: CALL_OW 314
27558: NOT
27559: PUSH
27560: LD_EXP 53
27564: PUSH
27565: LD_VAR 0 2
27569: ARRAY
27570: PUSH
27571: LD_INT 2
27573: ARRAY
27574: AND
27575: IFFALSE 27605
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
27577: LD_VAR 0 3
27581: PPUSH
27582: LD_EXP 53
27586: PUSH
27587: LD_VAR 0 2
27591: ARRAY
27592: PUSH
27593: LD_INT 2
27595: ARRAY
27596: PUSH
27597: LD_INT 1
27599: ARRAY
27600: PPUSH
27601: CALL_OW 128
// end ;
27605: GO 27383
27607: POP
27608: POP
// end ;
27609: GO 27226
27611: POP
27612: POP
// end ;
27613: LD_VAR 0 1
27617: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
27618: LD_INT 0
27620: PPUSH
27621: PPUSH
27622: PPUSH
27623: PPUSH
27624: PPUSH
// if not mc_bases then
27625: LD_EXP 50
27629: NOT
27630: IFFALSE 27634
// exit ;
27632: GO 28777
// for i = 1 to mc_bases do
27634: LD_ADDR_VAR 0 2
27638: PUSH
27639: DOUBLE
27640: LD_INT 1
27642: DEC
27643: ST_TO_ADDR
27644: LD_EXP 50
27648: PUSH
27649: FOR_TO
27650: IFFALSE 28775
// begin if mc_scan [ i ] then
27652: LD_EXP 73
27656: PUSH
27657: LD_VAR 0 2
27661: ARRAY
27662: IFFALSE 27666
// continue ;
27664: GO 27649
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
27666: LD_EXP 55
27670: PUSH
27671: LD_VAR 0 2
27675: ARRAY
27676: NOT
27677: PUSH
27678: LD_EXP 57
27682: PUSH
27683: LD_VAR 0 2
27687: ARRAY
27688: NOT
27689: AND
27690: PUSH
27691: LD_EXP 56
27695: PUSH
27696: LD_VAR 0 2
27700: ARRAY
27701: AND
27702: IFFALSE 27740
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
27704: LD_ADDR_EXP 56
27708: PUSH
27709: LD_EXP 56
27713: PPUSH
27714: LD_VAR 0 2
27718: PPUSH
27719: EMPTY
27720: PPUSH
27721: CALL_OW 1
27725: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
27726: LD_VAR 0 2
27730: PPUSH
27731: LD_INT 103
27733: PPUSH
27734: CALL 21460 0 2
// continue ;
27738: GO 27649
// end ; if mc_construct_list [ i ] then
27740: LD_EXP 57
27744: PUSH
27745: LD_VAR 0 2
27749: ARRAY
27750: IFFALSE 27970
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
27752: LD_ADDR_VAR 0 4
27756: PUSH
27757: LD_EXP 50
27761: PUSH
27762: LD_VAR 0 2
27766: ARRAY
27767: PPUSH
27768: LD_INT 25
27770: PUSH
27771: LD_INT 2
27773: PUSH
27774: EMPTY
27775: LIST
27776: LIST
27777: PPUSH
27778: CALL_OW 72
27782: PUSH
27783: LD_EXP 52
27787: PUSH
27788: LD_VAR 0 2
27792: ARRAY
27793: DIFF
27794: ST_TO_ADDR
// if not tmp then
27795: LD_VAR 0 4
27799: NOT
27800: IFFALSE 27804
// continue ;
27802: GO 27649
// for j in tmp do
27804: LD_ADDR_VAR 0 3
27808: PUSH
27809: LD_VAR 0 4
27813: PUSH
27814: FOR_IN
27815: IFFALSE 27966
// begin if not mc_builders [ i ] then
27817: LD_EXP 56
27821: PUSH
27822: LD_VAR 0 2
27826: ARRAY
27827: NOT
27828: IFFALSE 27886
// begin SetTag ( j , 103 ) ;
27830: LD_VAR 0 3
27834: PPUSH
27835: LD_INT 103
27837: PPUSH
27838: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
27842: LD_ADDR_EXP 56
27846: PUSH
27847: LD_EXP 56
27851: PPUSH
27852: LD_VAR 0 2
27856: PUSH
27857: LD_EXP 56
27861: PUSH
27862: LD_VAR 0 2
27866: ARRAY
27867: PUSH
27868: LD_INT 1
27870: PLUS
27871: PUSH
27872: EMPTY
27873: LIST
27874: LIST
27875: PPUSH
27876: LD_VAR 0 3
27880: PPUSH
27881: CALL 52351 0 3
27885: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
27886: LD_VAR 0 3
27890: PPUSH
27891: CALL_OW 310
27895: IFFALSE 27906
// ComExitBuilding ( j ) ;
27897: LD_VAR 0 3
27901: PPUSH
27902: CALL_OW 122
// wait ( 3 ) ;
27906: LD_INT 3
27908: PPUSH
27909: CALL_OW 67
// if not mc_construct_list [ i ] then
27913: LD_EXP 57
27917: PUSH
27918: LD_VAR 0 2
27922: ARRAY
27923: NOT
27924: IFFALSE 27928
// break ;
27926: GO 27966
// if not HasTask ( j ) then
27928: LD_VAR 0 3
27932: PPUSH
27933: CALL_OW 314
27937: NOT
27938: IFFALSE 27964
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
27940: LD_VAR 0 3
27944: PPUSH
27945: LD_EXP 57
27949: PUSH
27950: LD_VAR 0 2
27954: ARRAY
27955: PUSH
27956: LD_INT 1
27958: ARRAY
27959: PPUSH
27960: CALL 55202 0 2
// end ;
27964: GO 27814
27966: POP
27967: POP
// end else
27968: GO 28773
// if mc_build_list [ i ] then
27970: LD_EXP 55
27974: PUSH
27975: LD_VAR 0 2
27979: ARRAY
27980: IFFALSE 28773
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
27982: LD_ADDR_VAR 0 5
27986: PUSH
27987: LD_EXP 50
27991: PUSH
27992: LD_VAR 0 2
27996: ARRAY
27997: PPUSH
27998: LD_INT 2
28000: PUSH
28001: LD_INT 30
28003: PUSH
28004: LD_INT 0
28006: PUSH
28007: EMPTY
28008: LIST
28009: LIST
28010: PUSH
28011: LD_INT 30
28013: PUSH
28014: LD_INT 1
28016: PUSH
28017: EMPTY
28018: LIST
28019: LIST
28020: PUSH
28021: EMPTY
28022: LIST
28023: LIST
28024: LIST
28025: PPUSH
28026: CALL_OW 72
28030: ST_TO_ADDR
// if depot then
28031: LD_VAR 0 5
28035: IFFALSE 28053
// depot := depot [ 1 ] else
28037: LD_ADDR_VAR 0 5
28041: PUSH
28042: LD_VAR 0 5
28046: PUSH
28047: LD_INT 1
28049: ARRAY
28050: ST_TO_ADDR
28051: GO 28061
// depot := 0 ;
28053: LD_ADDR_VAR 0 5
28057: PUSH
28058: LD_INT 0
28060: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
28061: LD_EXP 55
28065: PUSH
28066: LD_VAR 0 2
28070: ARRAY
28071: PUSH
28072: LD_INT 1
28074: ARRAY
28075: PUSH
28076: LD_INT 1
28078: ARRAY
28079: PPUSH
28080: CALL 55032 0 1
28084: PUSH
28085: LD_EXP 50
28089: PUSH
28090: LD_VAR 0 2
28094: ARRAY
28095: PPUSH
28096: LD_INT 2
28098: PUSH
28099: LD_INT 30
28101: PUSH
28102: LD_INT 2
28104: PUSH
28105: EMPTY
28106: LIST
28107: LIST
28108: PUSH
28109: LD_INT 30
28111: PUSH
28112: LD_INT 3
28114: PUSH
28115: EMPTY
28116: LIST
28117: LIST
28118: PUSH
28119: EMPTY
28120: LIST
28121: LIST
28122: LIST
28123: PPUSH
28124: CALL_OW 72
28128: NOT
28129: AND
28130: IFFALSE 28235
// begin for j = 1 to mc_build_list [ i ] do
28132: LD_ADDR_VAR 0 3
28136: PUSH
28137: DOUBLE
28138: LD_INT 1
28140: DEC
28141: ST_TO_ADDR
28142: LD_EXP 55
28146: PUSH
28147: LD_VAR 0 2
28151: ARRAY
28152: PUSH
28153: FOR_TO
28154: IFFALSE 28233
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
28156: LD_EXP 55
28160: PUSH
28161: LD_VAR 0 2
28165: ARRAY
28166: PUSH
28167: LD_VAR 0 3
28171: ARRAY
28172: PUSH
28173: LD_INT 1
28175: ARRAY
28176: PUSH
28177: LD_INT 2
28179: EQUAL
28180: IFFALSE 28231
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
28182: LD_ADDR_EXP 55
28186: PUSH
28187: LD_EXP 55
28191: PPUSH
28192: LD_VAR 0 2
28196: PPUSH
28197: LD_EXP 55
28201: PUSH
28202: LD_VAR 0 2
28206: ARRAY
28207: PPUSH
28208: LD_VAR 0 3
28212: PPUSH
28213: LD_INT 1
28215: PPUSH
28216: LD_INT 0
28218: PPUSH
28219: CALL 51769 0 4
28223: PPUSH
28224: CALL_OW 1
28228: ST_TO_ADDR
// break ;
28229: GO 28233
// end ;
28231: GO 28153
28233: POP
28234: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
28235: LD_EXP 55
28239: PUSH
28240: LD_VAR 0 2
28244: ARRAY
28245: PUSH
28246: LD_INT 1
28248: ARRAY
28249: PUSH
28250: LD_INT 1
28252: ARRAY
28253: PUSH
28254: LD_INT 0
28256: EQUAL
28257: PUSH
28258: LD_VAR 0 5
28262: PUSH
28263: LD_VAR 0 5
28267: PPUSH
28268: LD_EXP 55
28272: PUSH
28273: LD_VAR 0 2
28277: ARRAY
28278: PUSH
28279: LD_INT 1
28281: ARRAY
28282: PUSH
28283: LD_INT 1
28285: ARRAY
28286: PPUSH
28287: LD_EXP 55
28291: PUSH
28292: LD_VAR 0 2
28296: ARRAY
28297: PUSH
28298: LD_INT 1
28300: ARRAY
28301: PUSH
28302: LD_INT 2
28304: ARRAY
28305: PPUSH
28306: LD_EXP 55
28310: PUSH
28311: LD_VAR 0 2
28315: ARRAY
28316: PUSH
28317: LD_INT 1
28319: ARRAY
28320: PUSH
28321: LD_INT 3
28323: ARRAY
28324: PPUSH
28325: LD_EXP 55
28329: PUSH
28330: LD_VAR 0 2
28334: ARRAY
28335: PUSH
28336: LD_INT 1
28338: ARRAY
28339: PUSH
28340: LD_INT 4
28342: ARRAY
28343: PPUSH
28344: CALL 59766 0 5
28348: AND
28349: OR
28350: IFFALSE 28631
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
28352: LD_ADDR_VAR 0 4
28356: PUSH
28357: LD_EXP 50
28361: PUSH
28362: LD_VAR 0 2
28366: ARRAY
28367: PPUSH
28368: LD_INT 25
28370: PUSH
28371: LD_INT 2
28373: PUSH
28374: EMPTY
28375: LIST
28376: LIST
28377: PPUSH
28378: CALL_OW 72
28382: PUSH
28383: LD_EXP 52
28387: PUSH
28388: LD_VAR 0 2
28392: ARRAY
28393: DIFF
28394: ST_TO_ADDR
// if not tmp then
28395: LD_VAR 0 4
28399: NOT
28400: IFFALSE 28404
// continue ;
28402: GO 27649
// for j in tmp do
28404: LD_ADDR_VAR 0 3
28408: PUSH
28409: LD_VAR 0 4
28413: PUSH
28414: FOR_IN
28415: IFFALSE 28627
// begin if not mc_builders [ i ] then
28417: LD_EXP 56
28421: PUSH
28422: LD_VAR 0 2
28426: ARRAY
28427: NOT
28428: IFFALSE 28486
// begin SetTag ( j , 103 ) ;
28430: LD_VAR 0 3
28434: PPUSH
28435: LD_INT 103
28437: PPUSH
28438: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
28442: LD_ADDR_EXP 56
28446: PUSH
28447: LD_EXP 56
28451: PPUSH
28452: LD_VAR 0 2
28456: PUSH
28457: LD_EXP 56
28461: PUSH
28462: LD_VAR 0 2
28466: ARRAY
28467: PUSH
28468: LD_INT 1
28470: PLUS
28471: PUSH
28472: EMPTY
28473: LIST
28474: LIST
28475: PPUSH
28476: LD_VAR 0 3
28480: PPUSH
28481: CALL 52351 0 3
28485: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
28486: LD_VAR 0 3
28490: PPUSH
28491: CALL_OW 310
28495: IFFALSE 28506
// ComExitBuilding ( j ) ;
28497: LD_VAR 0 3
28501: PPUSH
28502: CALL_OW 122
// wait ( 3 ) ;
28506: LD_INT 3
28508: PPUSH
28509: CALL_OW 67
// if not mc_build_list [ i ] then
28513: LD_EXP 55
28517: PUSH
28518: LD_VAR 0 2
28522: ARRAY
28523: NOT
28524: IFFALSE 28528
// break ;
28526: GO 28627
// if not HasTask ( j ) then
28528: LD_VAR 0 3
28532: PPUSH
28533: CALL_OW 314
28537: NOT
28538: IFFALSE 28625
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
28540: LD_VAR 0 3
28544: PPUSH
28545: LD_EXP 55
28549: PUSH
28550: LD_VAR 0 2
28554: ARRAY
28555: PUSH
28556: LD_INT 1
28558: ARRAY
28559: PUSH
28560: LD_INT 1
28562: ARRAY
28563: PPUSH
28564: LD_EXP 55
28568: PUSH
28569: LD_VAR 0 2
28573: ARRAY
28574: PUSH
28575: LD_INT 1
28577: ARRAY
28578: PUSH
28579: LD_INT 2
28581: ARRAY
28582: PPUSH
28583: LD_EXP 55
28587: PUSH
28588: LD_VAR 0 2
28592: ARRAY
28593: PUSH
28594: LD_INT 1
28596: ARRAY
28597: PUSH
28598: LD_INT 3
28600: ARRAY
28601: PPUSH
28602: LD_EXP 55
28606: PUSH
28607: LD_VAR 0 2
28611: ARRAY
28612: PUSH
28613: LD_INT 1
28615: ARRAY
28616: PUSH
28617: LD_INT 4
28619: ARRAY
28620: PPUSH
28621: CALL_OW 145
// end ;
28625: GO 28414
28627: POP
28628: POP
// end else
28629: GO 28773
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
28631: LD_EXP 50
28635: PUSH
28636: LD_VAR 0 2
28640: ARRAY
28641: PPUSH
28642: LD_EXP 55
28646: PUSH
28647: LD_VAR 0 2
28651: ARRAY
28652: PUSH
28653: LD_INT 1
28655: ARRAY
28656: PUSH
28657: LD_INT 1
28659: ARRAY
28660: PPUSH
28661: LD_EXP 55
28665: PUSH
28666: LD_VAR 0 2
28670: ARRAY
28671: PUSH
28672: LD_INT 1
28674: ARRAY
28675: PUSH
28676: LD_INT 2
28678: ARRAY
28679: PPUSH
28680: LD_EXP 55
28684: PUSH
28685: LD_VAR 0 2
28689: ARRAY
28690: PUSH
28691: LD_INT 1
28693: ARRAY
28694: PUSH
28695: LD_INT 3
28697: ARRAY
28698: PPUSH
28699: LD_EXP 55
28703: PUSH
28704: LD_VAR 0 2
28708: ARRAY
28709: PUSH
28710: LD_INT 1
28712: ARRAY
28713: PUSH
28714: LD_INT 4
28716: ARRAY
28717: PPUSH
28718: CALL 59102 0 5
28722: NOT
28723: IFFALSE 28773
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
28725: LD_ADDR_EXP 55
28729: PUSH
28730: LD_EXP 55
28734: PPUSH
28735: LD_VAR 0 2
28739: PPUSH
28740: LD_EXP 55
28744: PUSH
28745: LD_VAR 0 2
28749: ARRAY
28750: PPUSH
28751: LD_INT 1
28753: PPUSH
28754: LD_INT 1
28756: NEG
28757: PPUSH
28758: LD_INT 0
28760: PPUSH
28761: CALL 51769 0 4
28765: PPUSH
28766: CALL_OW 1
28770: ST_TO_ADDR
// continue ;
28771: GO 27649
// end ; end ; end ;
28773: GO 27649
28775: POP
28776: POP
// end ;
28777: LD_VAR 0 1
28781: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
28782: LD_INT 0
28784: PPUSH
28785: PPUSH
28786: PPUSH
28787: PPUSH
28788: PPUSH
28789: PPUSH
// if not mc_bases then
28790: LD_EXP 50
28794: NOT
28795: IFFALSE 28799
// exit ;
28797: GO 29226
// for i = 1 to mc_bases do
28799: LD_ADDR_VAR 0 2
28803: PUSH
28804: DOUBLE
28805: LD_INT 1
28807: DEC
28808: ST_TO_ADDR
28809: LD_EXP 50
28813: PUSH
28814: FOR_TO
28815: IFFALSE 29224
// begin tmp := mc_build_upgrade [ i ] ;
28817: LD_ADDR_VAR 0 4
28821: PUSH
28822: LD_EXP 82
28826: PUSH
28827: LD_VAR 0 2
28831: ARRAY
28832: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
28833: LD_ADDR_VAR 0 6
28837: PUSH
28838: LD_EXP 83
28842: PUSH
28843: LD_VAR 0 2
28847: ARRAY
28848: PPUSH
28849: LD_INT 2
28851: PUSH
28852: LD_INT 30
28854: PUSH
28855: LD_INT 6
28857: PUSH
28858: EMPTY
28859: LIST
28860: LIST
28861: PUSH
28862: LD_INT 30
28864: PUSH
28865: LD_INT 7
28867: PUSH
28868: EMPTY
28869: LIST
28870: LIST
28871: PUSH
28872: EMPTY
28873: LIST
28874: LIST
28875: LIST
28876: PPUSH
28877: CALL_OW 72
28881: ST_TO_ADDR
// if not tmp and not lab then
28882: LD_VAR 0 4
28886: NOT
28887: PUSH
28888: LD_VAR 0 6
28892: NOT
28893: AND
28894: IFFALSE 28898
// continue ;
28896: GO 28814
// if tmp then
28898: LD_VAR 0 4
28902: IFFALSE 29022
// for j in tmp do
28904: LD_ADDR_VAR 0 3
28908: PUSH
28909: LD_VAR 0 4
28913: PUSH
28914: FOR_IN
28915: IFFALSE 29020
// begin if UpgradeCost ( j ) then
28917: LD_VAR 0 3
28921: PPUSH
28922: CALL 58762 0 1
28926: IFFALSE 29018
// begin ComUpgrade ( j ) ;
28928: LD_VAR 0 3
28932: PPUSH
28933: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
28937: LD_ADDR_EXP 82
28941: PUSH
28942: LD_EXP 82
28946: PPUSH
28947: LD_VAR 0 2
28951: PPUSH
28952: LD_EXP 82
28956: PUSH
28957: LD_VAR 0 2
28961: ARRAY
28962: PUSH
28963: LD_VAR 0 3
28967: DIFF
28968: PPUSH
28969: CALL_OW 1
28973: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
28974: LD_ADDR_EXP 57
28978: PUSH
28979: LD_EXP 57
28983: PPUSH
28984: LD_VAR 0 2
28988: PUSH
28989: LD_EXP 57
28993: PUSH
28994: LD_VAR 0 2
28998: ARRAY
28999: PUSH
29000: LD_INT 1
29002: PLUS
29003: PUSH
29004: EMPTY
29005: LIST
29006: LIST
29007: PPUSH
29008: LD_VAR 0 3
29012: PPUSH
29013: CALL 52351 0 3
29017: ST_TO_ADDR
// end ; end ;
29018: GO 28914
29020: POP
29021: POP
// if not lab or not mc_lab_upgrade [ i ] then
29022: LD_VAR 0 6
29026: NOT
29027: PUSH
29028: LD_EXP 84
29032: PUSH
29033: LD_VAR 0 2
29037: ARRAY
29038: NOT
29039: OR
29040: IFFALSE 29044
// continue ;
29042: GO 28814
// for j in lab do
29044: LD_ADDR_VAR 0 3
29048: PUSH
29049: LD_VAR 0 6
29053: PUSH
29054: FOR_IN
29055: IFFALSE 29220
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
29057: LD_VAR 0 3
29061: PPUSH
29062: CALL_OW 266
29066: PUSH
29067: LD_INT 6
29069: PUSH
29070: LD_INT 7
29072: PUSH
29073: EMPTY
29074: LIST
29075: LIST
29076: IN
29077: PUSH
29078: LD_VAR 0 3
29082: PPUSH
29083: CALL_OW 461
29087: PUSH
29088: LD_INT 1
29090: NONEQUAL
29091: AND
29092: IFFALSE 29218
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
29094: LD_VAR 0 3
29098: PPUSH
29099: LD_EXP 84
29103: PUSH
29104: LD_VAR 0 2
29108: ARRAY
29109: PUSH
29110: LD_INT 1
29112: ARRAY
29113: PPUSH
29114: CALL 58967 0 2
29118: IFFALSE 29218
// begin ComCancel ( j ) ;
29120: LD_VAR 0 3
29124: PPUSH
29125: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
29129: LD_VAR 0 3
29133: PPUSH
29134: LD_EXP 84
29138: PUSH
29139: LD_VAR 0 2
29143: ARRAY
29144: PUSH
29145: LD_INT 1
29147: ARRAY
29148: PPUSH
29149: CALL_OW 207
// if not j in mc_construct_list [ i ] then
29153: LD_VAR 0 3
29157: PUSH
29158: LD_EXP 57
29162: PUSH
29163: LD_VAR 0 2
29167: ARRAY
29168: IN
29169: NOT
29170: IFFALSE 29216
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
29172: LD_ADDR_EXP 57
29176: PUSH
29177: LD_EXP 57
29181: PPUSH
29182: LD_VAR 0 2
29186: PUSH
29187: LD_EXP 57
29191: PUSH
29192: LD_VAR 0 2
29196: ARRAY
29197: PUSH
29198: LD_INT 1
29200: PLUS
29201: PUSH
29202: EMPTY
29203: LIST
29204: LIST
29205: PPUSH
29206: LD_VAR 0 3
29210: PPUSH
29211: CALL 52351 0 3
29215: ST_TO_ADDR
// break ;
29216: GO 29220
// end ; end ; end ;
29218: GO 29054
29220: POP
29221: POP
// end ;
29222: GO 28814
29224: POP
29225: POP
// end ;
29226: LD_VAR 0 1
29230: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
29231: LD_INT 0
29233: PPUSH
29234: PPUSH
29235: PPUSH
29236: PPUSH
29237: PPUSH
29238: PPUSH
29239: PPUSH
29240: PPUSH
29241: PPUSH
// if not mc_bases then
29242: LD_EXP 50
29246: NOT
29247: IFFALSE 29251
// exit ;
29249: GO 29656
// for i = 1 to mc_bases do
29251: LD_ADDR_VAR 0 2
29255: PUSH
29256: DOUBLE
29257: LD_INT 1
29259: DEC
29260: ST_TO_ADDR
29261: LD_EXP 50
29265: PUSH
29266: FOR_TO
29267: IFFALSE 29654
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
29269: LD_EXP 58
29273: PUSH
29274: LD_VAR 0 2
29278: ARRAY
29279: NOT
29280: PUSH
29281: LD_EXP 50
29285: PUSH
29286: LD_VAR 0 2
29290: ARRAY
29291: PPUSH
29292: LD_INT 30
29294: PUSH
29295: LD_INT 3
29297: PUSH
29298: EMPTY
29299: LIST
29300: LIST
29301: PPUSH
29302: CALL_OW 72
29306: NOT
29307: OR
29308: IFFALSE 29312
// continue ;
29310: GO 29266
// busy := false ;
29312: LD_ADDR_VAR 0 8
29316: PUSH
29317: LD_INT 0
29319: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
29320: LD_ADDR_VAR 0 4
29324: PUSH
29325: LD_EXP 50
29329: PUSH
29330: LD_VAR 0 2
29334: ARRAY
29335: PPUSH
29336: LD_INT 30
29338: PUSH
29339: LD_INT 3
29341: PUSH
29342: EMPTY
29343: LIST
29344: LIST
29345: PPUSH
29346: CALL_OW 72
29350: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
29351: LD_ADDR_VAR 0 6
29355: PUSH
29356: LD_EXP 58
29360: PUSH
29361: LD_VAR 0 2
29365: ARRAY
29366: PPUSH
29367: LD_INT 2
29369: PUSH
29370: LD_INT 30
29372: PUSH
29373: LD_INT 32
29375: PUSH
29376: EMPTY
29377: LIST
29378: LIST
29379: PUSH
29380: LD_INT 30
29382: PUSH
29383: LD_INT 33
29385: PUSH
29386: EMPTY
29387: LIST
29388: LIST
29389: PUSH
29390: EMPTY
29391: LIST
29392: LIST
29393: LIST
29394: PPUSH
29395: CALL_OW 72
29399: ST_TO_ADDR
// if not t then
29400: LD_VAR 0 6
29404: NOT
29405: IFFALSE 29409
// continue ;
29407: GO 29266
// for j in tmp do
29409: LD_ADDR_VAR 0 3
29413: PUSH
29414: LD_VAR 0 4
29418: PUSH
29419: FOR_IN
29420: IFFALSE 29450
// if not BuildingStatus ( j ) = bs_idle then
29422: LD_VAR 0 3
29426: PPUSH
29427: CALL_OW 461
29431: PUSH
29432: LD_INT 2
29434: EQUAL
29435: NOT
29436: IFFALSE 29448
// begin busy := true ;
29438: LD_ADDR_VAR 0 8
29442: PUSH
29443: LD_INT 1
29445: ST_TO_ADDR
// break ;
29446: GO 29450
// end ;
29448: GO 29419
29450: POP
29451: POP
// if busy then
29452: LD_VAR 0 8
29456: IFFALSE 29460
// continue ;
29458: GO 29266
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
29460: LD_ADDR_VAR 0 7
29464: PUSH
29465: LD_VAR 0 6
29469: PPUSH
29470: LD_INT 35
29472: PUSH
29473: LD_INT 0
29475: PUSH
29476: EMPTY
29477: LIST
29478: LIST
29479: PPUSH
29480: CALL_OW 72
29484: ST_TO_ADDR
// if tw then
29485: LD_VAR 0 7
29489: IFFALSE 29566
// begin tw := tw [ 1 ] ;
29491: LD_ADDR_VAR 0 7
29495: PUSH
29496: LD_VAR 0 7
29500: PUSH
29501: LD_INT 1
29503: ARRAY
29504: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
29505: LD_ADDR_VAR 0 9
29509: PUSH
29510: LD_VAR 0 7
29514: PPUSH
29515: LD_EXP 75
29519: PUSH
29520: LD_VAR 0 2
29524: ARRAY
29525: PPUSH
29526: CALL 57321 0 2
29530: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
29531: LD_EXP 89
29535: PUSH
29536: LD_VAR 0 2
29540: ARRAY
29541: IFFALSE 29564
// if not weapon in mc_allowed_tower_weapons [ i ] then
29543: LD_VAR 0 9
29547: PUSH
29548: LD_EXP 89
29552: PUSH
29553: LD_VAR 0 2
29557: ARRAY
29558: IN
29559: NOT
29560: IFFALSE 29564
// continue ;
29562: GO 29266
// end else
29564: GO 29629
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
29566: LD_ADDR_VAR 0 5
29570: PUSH
29571: LD_EXP 58
29575: PUSH
29576: LD_VAR 0 2
29580: ARRAY
29581: PPUSH
29582: LD_VAR 0 4
29586: PPUSH
29587: CALL 82823 0 2
29591: ST_TO_ADDR
// if not tmp2 then
29592: LD_VAR 0 5
29596: NOT
29597: IFFALSE 29601
// continue ;
29599: GO 29266
// tw := tmp2 [ 1 ] ;
29601: LD_ADDR_VAR 0 7
29605: PUSH
29606: LD_VAR 0 5
29610: PUSH
29611: LD_INT 1
29613: ARRAY
29614: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
29615: LD_ADDR_VAR 0 9
29619: PUSH
29620: LD_VAR 0 5
29624: PUSH
29625: LD_INT 2
29627: ARRAY
29628: ST_TO_ADDR
// end ; if not weapon then
29629: LD_VAR 0 9
29633: NOT
29634: IFFALSE 29638
// continue ;
29636: GO 29266
// ComPlaceWeapon ( tw , weapon ) ;
29638: LD_VAR 0 7
29642: PPUSH
29643: LD_VAR 0 9
29647: PPUSH
29648: CALL_OW 148
// end ;
29652: GO 29266
29654: POP
29655: POP
// end ;
29656: LD_VAR 0 1
29660: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
29661: LD_INT 0
29663: PPUSH
29664: PPUSH
29665: PPUSH
29666: PPUSH
29667: PPUSH
29668: PPUSH
// if not mc_bases then
29669: LD_EXP 50
29673: NOT
29674: IFFALSE 29678
// exit ;
29676: GO 30454
// for i = 1 to mc_bases do
29678: LD_ADDR_VAR 0 2
29682: PUSH
29683: DOUBLE
29684: LD_INT 1
29686: DEC
29687: ST_TO_ADDR
29688: LD_EXP 50
29692: PUSH
29693: FOR_TO
29694: IFFALSE 30452
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
29696: LD_EXP 63
29700: PUSH
29701: LD_VAR 0 2
29705: ARRAY
29706: NOT
29707: PUSH
29708: LD_EXP 63
29712: PUSH
29713: LD_VAR 0 2
29717: ARRAY
29718: PUSH
29719: LD_EXP 64
29723: PUSH
29724: LD_VAR 0 2
29728: ARRAY
29729: EQUAL
29730: OR
29731: PUSH
29732: LD_EXP 73
29736: PUSH
29737: LD_VAR 0 2
29741: ARRAY
29742: OR
29743: IFFALSE 29747
// continue ;
29745: GO 29693
// if mc_miners [ i ] then
29747: LD_EXP 64
29751: PUSH
29752: LD_VAR 0 2
29756: ARRAY
29757: IFFALSE 30139
// begin for j = mc_miners [ i ] downto 1 do
29759: LD_ADDR_VAR 0 3
29763: PUSH
29764: DOUBLE
29765: LD_EXP 64
29769: PUSH
29770: LD_VAR 0 2
29774: ARRAY
29775: INC
29776: ST_TO_ADDR
29777: LD_INT 1
29779: PUSH
29780: FOR_DOWNTO
29781: IFFALSE 30137
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
29783: LD_EXP 64
29787: PUSH
29788: LD_VAR 0 2
29792: ARRAY
29793: PUSH
29794: LD_VAR 0 3
29798: ARRAY
29799: PPUSH
29800: CALL_OW 301
29804: PUSH
29805: LD_EXP 64
29809: PUSH
29810: LD_VAR 0 2
29814: ARRAY
29815: PUSH
29816: LD_VAR 0 3
29820: ARRAY
29821: PPUSH
29822: CALL_OW 257
29826: PUSH
29827: LD_INT 1
29829: NONEQUAL
29830: OR
29831: IFFALSE 29894
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
29833: LD_ADDR_VAR 0 5
29837: PUSH
29838: LD_EXP 64
29842: PUSH
29843: LD_VAR 0 2
29847: ARRAY
29848: PUSH
29849: LD_EXP 64
29853: PUSH
29854: LD_VAR 0 2
29858: ARRAY
29859: PUSH
29860: LD_VAR 0 3
29864: ARRAY
29865: DIFF
29866: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
29867: LD_ADDR_EXP 64
29871: PUSH
29872: LD_EXP 64
29876: PPUSH
29877: LD_VAR 0 2
29881: PPUSH
29882: LD_VAR 0 5
29886: PPUSH
29887: CALL_OW 1
29891: ST_TO_ADDR
// continue ;
29892: GO 29780
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
29894: LD_EXP 64
29898: PUSH
29899: LD_VAR 0 2
29903: ARRAY
29904: PUSH
29905: LD_VAR 0 3
29909: ARRAY
29910: PPUSH
29911: CALL_OW 257
29915: PUSH
29916: LD_INT 1
29918: EQUAL
29919: PUSH
29920: LD_EXP 64
29924: PUSH
29925: LD_VAR 0 2
29929: ARRAY
29930: PUSH
29931: LD_VAR 0 3
29935: ARRAY
29936: PPUSH
29937: CALL_OW 459
29941: NOT
29942: AND
29943: PUSH
29944: LD_EXP 64
29948: PUSH
29949: LD_VAR 0 2
29953: ARRAY
29954: PUSH
29955: LD_VAR 0 3
29959: ARRAY
29960: PPUSH
29961: CALL_OW 314
29965: NOT
29966: AND
29967: IFFALSE 30135
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
29969: LD_EXP 64
29973: PUSH
29974: LD_VAR 0 2
29978: ARRAY
29979: PUSH
29980: LD_VAR 0 3
29984: ARRAY
29985: PPUSH
29986: CALL_OW 310
29990: IFFALSE 30013
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
29992: LD_EXP 64
29996: PUSH
29997: LD_VAR 0 2
30001: ARRAY
30002: PUSH
30003: LD_VAR 0 3
30007: ARRAY
30008: PPUSH
30009: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
30013: LD_EXP 64
30017: PUSH
30018: LD_VAR 0 2
30022: ARRAY
30023: PUSH
30024: LD_VAR 0 3
30028: ARRAY
30029: PPUSH
30030: CALL_OW 314
30034: NOT
30035: IFFALSE 30135
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
30037: LD_EXP 64
30041: PUSH
30042: LD_VAR 0 2
30046: ARRAY
30047: PUSH
30048: LD_VAR 0 3
30052: ARRAY
30053: PPUSH
30054: LD_EXP 63
30058: PUSH
30059: LD_VAR 0 2
30063: ARRAY
30064: PUSH
30065: LD_VAR 0 3
30069: PUSH
30070: LD_EXP 63
30074: PUSH
30075: LD_VAR 0 2
30079: ARRAY
30080: MOD
30081: PUSH
30082: LD_INT 1
30084: PLUS
30085: ARRAY
30086: PUSH
30087: LD_INT 1
30089: ARRAY
30090: PPUSH
30091: LD_EXP 63
30095: PUSH
30096: LD_VAR 0 2
30100: ARRAY
30101: PUSH
30102: LD_VAR 0 3
30106: PUSH
30107: LD_EXP 63
30111: PUSH
30112: LD_VAR 0 2
30116: ARRAY
30117: MOD
30118: PUSH
30119: LD_INT 1
30121: PLUS
30122: ARRAY
30123: PUSH
30124: LD_INT 2
30126: ARRAY
30127: PPUSH
30128: LD_INT 0
30130: PPUSH
30131: CALL_OW 193
// end ; end ;
30135: GO 29780
30137: POP
30138: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
30139: LD_ADDR_VAR 0 5
30143: PUSH
30144: LD_EXP 50
30148: PUSH
30149: LD_VAR 0 2
30153: ARRAY
30154: PPUSH
30155: LD_INT 2
30157: PUSH
30158: LD_INT 30
30160: PUSH
30161: LD_INT 4
30163: PUSH
30164: EMPTY
30165: LIST
30166: LIST
30167: PUSH
30168: LD_INT 30
30170: PUSH
30171: LD_INT 5
30173: PUSH
30174: EMPTY
30175: LIST
30176: LIST
30177: PUSH
30178: LD_INT 30
30180: PUSH
30181: LD_INT 32
30183: PUSH
30184: EMPTY
30185: LIST
30186: LIST
30187: PUSH
30188: EMPTY
30189: LIST
30190: LIST
30191: LIST
30192: LIST
30193: PPUSH
30194: CALL_OW 72
30198: ST_TO_ADDR
// if not tmp then
30199: LD_VAR 0 5
30203: NOT
30204: IFFALSE 30208
// continue ;
30206: GO 29693
// list := [ ] ;
30208: LD_ADDR_VAR 0 6
30212: PUSH
30213: EMPTY
30214: ST_TO_ADDR
// for j in tmp do
30215: LD_ADDR_VAR 0 3
30219: PUSH
30220: LD_VAR 0 5
30224: PUSH
30225: FOR_IN
30226: IFFALSE 30295
// begin for k in UnitsInside ( j ) do
30228: LD_ADDR_VAR 0 4
30232: PUSH
30233: LD_VAR 0 3
30237: PPUSH
30238: CALL_OW 313
30242: PUSH
30243: FOR_IN
30244: IFFALSE 30291
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
30246: LD_VAR 0 4
30250: PPUSH
30251: CALL_OW 257
30255: PUSH
30256: LD_INT 1
30258: EQUAL
30259: PUSH
30260: LD_VAR 0 4
30264: PPUSH
30265: CALL_OW 459
30269: NOT
30270: AND
30271: IFFALSE 30289
// list := list ^ k ;
30273: LD_ADDR_VAR 0 6
30277: PUSH
30278: LD_VAR 0 6
30282: PUSH
30283: LD_VAR 0 4
30287: ADD
30288: ST_TO_ADDR
30289: GO 30243
30291: POP
30292: POP
// end ;
30293: GO 30225
30295: POP
30296: POP
// list := list diff mc_miners [ i ] ;
30297: LD_ADDR_VAR 0 6
30301: PUSH
30302: LD_VAR 0 6
30306: PUSH
30307: LD_EXP 64
30311: PUSH
30312: LD_VAR 0 2
30316: ARRAY
30317: DIFF
30318: ST_TO_ADDR
// if not list then
30319: LD_VAR 0 6
30323: NOT
30324: IFFALSE 30328
// continue ;
30326: GO 29693
// k := mc_mines [ i ] - mc_miners [ i ] ;
30328: LD_ADDR_VAR 0 4
30332: PUSH
30333: LD_EXP 63
30337: PUSH
30338: LD_VAR 0 2
30342: ARRAY
30343: PUSH
30344: LD_EXP 64
30348: PUSH
30349: LD_VAR 0 2
30353: ARRAY
30354: MINUS
30355: ST_TO_ADDR
// if k > list then
30356: LD_VAR 0 4
30360: PUSH
30361: LD_VAR 0 6
30365: GREATER
30366: IFFALSE 30378
// k := list ;
30368: LD_ADDR_VAR 0 4
30372: PUSH
30373: LD_VAR 0 6
30377: ST_TO_ADDR
// for j = 1 to k do
30378: LD_ADDR_VAR 0 3
30382: PUSH
30383: DOUBLE
30384: LD_INT 1
30386: DEC
30387: ST_TO_ADDR
30388: LD_VAR 0 4
30392: PUSH
30393: FOR_TO
30394: IFFALSE 30448
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
30396: LD_ADDR_EXP 64
30400: PUSH
30401: LD_EXP 64
30405: PPUSH
30406: LD_VAR 0 2
30410: PUSH
30411: LD_EXP 64
30415: PUSH
30416: LD_VAR 0 2
30420: ARRAY
30421: PUSH
30422: LD_INT 1
30424: PLUS
30425: PUSH
30426: EMPTY
30427: LIST
30428: LIST
30429: PPUSH
30430: LD_VAR 0 6
30434: PUSH
30435: LD_VAR 0 3
30439: ARRAY
30440: PPUSH
30441: CALL 52351 0 3
30445: ST_TO_ADDR
30446: GO 30393
30448: POP
30449: POP
// end ;
30450: GO 29693
30452: POP
30453: POP
// end ;
30454: LD_VAR 0 1
30458: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
30459: LD_INT 0
30461: PPUSH
30462: PPUSH
30463: PPUSH
30464: PPUSH
30465: PPUSH
30466: PPUSH
30467: PPUSH
30468: PPUSH
30469: PPUSH
30470: PPUSH
// if not mc_bases then
30471: LD_EXP 50
30475: NOT
30476: IFFALSE 30480
// exit ;
30478: GO 32230
// for i = 1 to mc_bases do
30480: LD_ADDR_VAR 0 2
30484: PUSH
30485: DOUBLE
30486: LD_INT 1
30488: DEC
30489: ST_TO_ADDR
30490: LD_EXP 50
30494: PUSH
30495: FOR_TO
30496: IFFALSE 32228
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
30498: LD_EXP 50
30502: PUSH
30503: LD_VAR 0 2
30507: ARRAY
30508: NOT
30509: PUSH
30510: LD_EXP 57
30514: PUSH
30515: LD_VAR 0 2
30519: ARRAY
30520: OR
30521: IFFALSE 30525
// continue ;
30523: GO 30495
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
30525: LD_EXP 66
30529: PUSH
30530: LD_VAR 0 2
30534: ARRAY
30535: NOT
30536: PUSH
30537: LD_EXP 67
30541: PUSH
30542: LD_VAR 0 2
30546: ARRAY
30547: AND
30548: IFFALSE 30586
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
30550: LD_ADDR_EXP 67
30554: PUSH
30555: LD_EXP 67
30559: PPUSH
30560: LD_VAR 0 2
30564: PPUSH
30565: EMPTY
30566: PPUSH
30567: CALL_OW 1
30571: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
30572: LD_VAR 0 2
30576: PPUSH
30577: LD_INT 107
30579: PPUSH
30580: CALL 21460 0 2
// continue ;
30584: GO 30495
// end ; target := [ ] ;
30586: LD_ADDR_VAR 0 6
30590: PUSH
30591: EMPTY
30592: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
30593: LD_ADDR_VAR 0 3
30597: PUSH
30598: DOUBLE
30599: LD_EXP 66
30603: PUSH
30604: LD_VAR 0 2
30608: ARRAY
30609: INC
30610: ST_TO_ADDR
30611: LD_INT 1
30613: PUSH
30614: FOR_DOWNTO
30615: IFFALSE 30875
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
30617: LD_EXP 66
30621: PUSH
30622: LD_VAR 0 2
30626: ARRAY
30627: PUSH
30628: LD_VAR 0 3
30632: ARRAY
30633: PUSH
30634: LD_INT 2
30636: ARRAY
30637: PPUSH
30638: LD_EXP 66
30642: PUSH
30643: LD_VAR 0 2
30647: ARRAY
30648: PUSH
30649: LD_VAR 0 3
30653: ARRAY
30654: PUSH
30655: LD_INT 3
30657: ARRAY
30658: PPUSH
30659: CALL_OW 488
30663: PUSH
30664: LD_EXP 66
30668: PUSH
30669: LD_VAR 0 2
30673: ARRAY
30674: PUSH
30675: LD_VAR 0 3
30679: ARRAY
30680: PUSH
30681: LD_INT 2
30683: ARRAY
30684: PPUSH
30685: LD_EXP 66
30689: PUSH
30690: LD_VAR 0 2
30694: ARRAY
30695: PUSH
30696: LD_VAR 0 3
30700: ARRAY
30701: PUSH
30702: LD_INT 3
30704: ARRAY
30705: PPUSH
30706: CALL_OW 284
30710: PUSH
30711: LD_INT 0
30713: EQUAL
30714: AND
30715: IFFALSE 30770
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
30717: LD_ADDR_VAR 0 5
30721: PUSH
30722: LD_EXP 66
30726: PUSH
30727: LD_VAR 0 2
30731: ARRAY
30732: PPUSH
30733: LD_VAR 0 3
30737: PPUSH
30738: CALL_OW 3
30742: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
30743: LD_ADDR_EXP 66
30747: PUSH
30748: LD_EXP 66
30752: PPUSH
30753: LD_VAR 0 2
30757: PPUSH
30758: LD_VAR 0 5
30762: PPUSH
30763: CALL_OW 1
30767: ST_TO_ADDR
// continue ;
30768: GO 30614
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
30770: LD_EXP 50
30774: PUSH
30775: LD_VAR 0 2
30779: ARRAY
30780: PUSH
30781: LD_INT 1
30783: ARRAY
30784: PPUSH
30785: CALL_OW 255
30789: PPUSH
30790: LD_EXP 66
30794: PUSH
30795: LD_VAR 0 2
30799: ARRAY
30800: PUSH
30801: LD_VAR 0 3
30805: ARRAY
30806: PUSH
30807: LD_INT 2
30809: ARRAY
30810: PPUSH
30811: LD_EXP 66
30815: PUSH
30816: LD_VAR 0 2
30820: ARRAY
30821: PUSH
30822: LD_VAR 0 3
30826: ARRAY
30827: PUSH
30828: LD_INT 3
30830: ARRAY
30831: PPUSH
30832: LD_INT 30
30834: PPUSH
30835: CALL 53247 0 4
30839: PUSH
30840: LD_INT 4
30842: ARRAY
30843: PUSH
30844: LD_INT 0
30846: EQUAL
30847: IFFALSE 30873
// begin target := mc_crates [ i ] [ j ] ;
30849: LD_ADDR_VAR 0 6
30853: PUSH
30854: LD_EXP 66
30858: PUSH
30859: LD_VAR 0 2
30863: ARRAY
30864: PUSH
30865: LD_VAR 0 3
30869: ARRAY
30870: ST_TO_ADDR
// break ;
30871: GO 30875
// end ; end ;
30873: GO 30614
30875: POP
30876: POP
// if not target then
30877: LD_VAR 0 6
30881: NOT
30882: IFFALSE 30886
// continue ;
30884: GO 30495
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
30886: LD_ADDR_VAR 0 7
30890: PUSH
30891: LD_EXP 69
30895: PUSH
30896: LD_VAR 0 2
30900: ARRAY
30901: PPUSH
30902: LD_INT 2
30904: PUSH
30905: LD_INT 3
30907: PUSH
30908: LD_INT 58
30910: PUSH
30911: EMPTY
30912: LIST
30913: PUSH
30914: EMPTY
30915: LIST
30916: LIST
30917: PUSH
30918: LD_INT 61
30920: PUSH
30921: EMPTY
30922: LIST
30923: PUSH
30924: LD_INT 33
30926: PUSH
30927: LD_INT 5
30929: PUSH
30930: EMPTY
30931: LIST
30932: LIST
30933: PUSH
30934: LD_INT 33
30936: PUSH
30937: LD_INT 3
30939: PUSH
30940: EMPTY
30941: LIST
30942: LIST
30943: PUSH
30944: EMPTY
30945: LIST
30946: LIST
30947: LIST
30948: LIST
30949: LIST
30950: PUSH
30951: LD_INT 2
30953: PUSH
30954: LD_INT 34
30956: PUSH
30957: LD_INT 32
30959: PUSH
30960: EMPTY
30961: LIST
30962: LIST
30963: PUSH
30964: LD_INT 34
30966: PUSH
30967: LD_INT 51
30969: PUSH
30970: EMPTY
30971: LIST
30972: LIST
30973: PUSH
30974: LD_INT 34
30976: PUSH
30977: LD_INT 12
30979: PUSH
30980: EMPTY
30981: LIST
30982: LIST
30983: PUSH
30984: EMPTY
30985: LIST
30986: LIST
30987: LIST
30988: LIST
30989: PUSH
30990: EMPTY
30991: LIST
30992: LIST
30993: PPUSH
30994: CALL_OW 72
30998: ST_TO_ADDR
// if not cargo then
30999: LD_VAR 0 7
31003: NOT
31004: IFFALSE 31647
// begin if mc_crates_collector [ i ] < 5 then
31006: LD_EXP 67
31010: PUSH
31011: LD_VAR 0 2
31015: ARRAY
31016: PUSH
31017: LD_INT 5
31019: LESS
31020: IFFALSE 31386
// begin if mc_ape [ i ] then
31022: LD_EXP 79
31026: PUSH
31027: LD_VAR 0 2
31031: ARRAY
31032: IFFALSE 31079
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
31034: LD_ADDR_VAR 0 5
31038: PUSH
31039: LD_EXP 79
31043: PUSH
31044: LD_VAR 0 2
31048: ARRAY
31049: PPUSH
31050: LD_INT 25
31052: PUSH
31053: LD_INT 16
31055: PUSH
31056: EMPTY
31057: LIST
31058: LIST
31059: PUSH
31060: LD_INT 24
31062: PUSH
31063: LD_INT 750
31065: PUSH
31066: EMPTY
31067: LIST
31068: LIST
31069: PUSH
31070: EMPTY
31071: LIST
31072: LIST
31073: PPUSH
31074: CALL_OW 72
31078: ST_TO_ADDR
// if not tmp then
31079: LD_VAR 0 5
31083: NOT
31084: IFFALSE 31131
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
31086: LD_ADDR_VAR 0 5
31090: PUSH
31091: LD_EXP 50
31095: PUSH
31096: LD_VAR 0 2
31100: ARRAY
31101: PPUSH
31102: LD_INT 25
31104: PUSH
31105: LD_INT 2
31107: PUSH
31108: EMPTY
31109: LIST
31110: LIST
31111: PUSH
31112: LD_INT 24
31114: PUSH
31115: LD_INT 750
31117: PUSH
31118: EMPTY
31119: LIST
31120: LIST
31121: PUSH
31122: EMPTY
31123: LIST
31124: LIST
31125: PPUSH
31126: CALL_OW 72
31130: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
31131: LD_EXP 79
31135: PUSH
31136: LD_VAR 0 2
31140: ARRAY
31141: PUSH
31142: LD_EXP 50
31146: PUSH
31147: LD_VAR 0 2
31151: ARRAY
31152: PPUSH
31153: LD_INT 25
31155: PUSH
31156: LD_INT 2
31158: PUSH
31159: EMPTY
31160: LIST
31161: LIST
31162: PUSH
31163: LD_INT 24
31165: PUSH
31166: LD_INT 750
31168: PUSH
31169: EMPTY
31170: LIST
31171: LIST
31172: PUSH
31173: EMPTY
31174: LIST
31175: LIST
31176: PPUSH
31177: CALL_OW 72
31181: AND
31182: PUSH
31183: LD_VAR 0 5
31187: PUSH
31188: LD_INT 5
31190: LESS
31191: AND
31192: IFFALSE 31274
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
31194: LD_ADDR_VAR 0 3
31198: PUSH
31199: LD_EXP 50
31203: PUSH
31204: LD_VAR 0 2
31208: ARRAY
31209: PPUSH
31210: LD_INT 25
31212: PUSH
31213: LD_INT 2
31215: PUSH
31216: EMPTY
31217: LIST
31218: LIST
31219: PUSH
31220: LD_INT 24
31222: PUSH
31223: LD_INT 750
31225: PUSH
31226: EMPTY
31227: LIST
31228: LIST
31229: PUSH
31230: EMPTY
31231: LIST
31232: LIST
31233: PPUSH
31234: CALL_OW 72
31238: PUSH
31239: FOR_IN
31240: IFFALSE 31272
// begin tmp := tmp union j ;
31242: LD_ADDR_VAR 0 5
31246: PUSH
31247: LD_VAR 0 5
31251: PUSH
31252: LD_VAR 0 3
31256: UNION
31257: ST_TO_ADDR
// if tmp >= 5 then
31258: LD_VAR 0 5
31262: PUSH
31263: LD_INT 5
31265: GREATEREQUAL
31266: IFFALSE 31270
// break ;
31268: GO 31272
// end ;
31270: GO 31239
31272: POP
31273: POP
// end ; if not tmp then
31274: LD_VAR 0 5
31278: NOT
31279: IFFALSE 31283
// continue ;
31281: GO 30495
// for j in tmp do
31283: LD_ADDR_VAR 0 3
31287: PUSH
31288: LD_VAR 0 5
31292: PUSH
31293: FOR_IN
31294: IFFALSE 31384
// if not GetTag ( j ) then
31296: LD_VAR 0 3
31300: PPUSH
31301: CALL_OW 110
31305: NOT
31306: IFFALSE 31382
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
31308: LD_ADDR_EXP 67
31312: PUSH
31313: LD_EXP 67
31317: PPUSH
31318: LD_VAR 0 2
31322: PUSH
31323: LD_EXP 67
31327: PUSH
31328: LD_VAR 0 2
31332: ARRAY
31333: PUSH
31334: LD_INT 1
31336: PLUS
31337: PUSH
31338: EMPTY
31339: LIST
31340: LIST
31341: PPUSH
31342: LD_VAR 0 3
31346: PPUSH
31347: CALL 52351 0 3
31351: ST_TO_ADDR
// SetTag ( j , 107 ) ;
31352: LD_VAR 0 3
31356: PPUSH
31357: LD_INT 107
31359: PPUSH
31360: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
31364: LD_EXP 67
31368: PUSH
31369: LD_VAR 0 2
31373: ARRAY
31374: PUSH
31375: LD_INT 5
31377: GREATEREQUAL
31378: IFFALSE 31382
// break ;
31380: GO 31384
// end ;
31382: GO 31293
31384: POP
31385: POP
// end ; if mc_crates_collector [ i ] and target then
31386: LD_EXP 67
31390: PUSH
31391: LD_VAR 0 2
31395: ARRAY
31396: PUSH
31397: LD_VAR 0 6
31401: AND
31402: IFFALSE 31645
// begin if mc_crates_collector [ i ] < target [ 1 ] then
31404: LD_EXP 67
31408: PUSH
31409: LD_VAR 0 2
31413: ARRAY
31414: PUSH
31415: LD_VAR 0 6
31419: PUSH
31420: LD_INT 1
31422: ARRAY
31423: LESS
31424: IFFALSE 31444
// tmp := mc_crates_collector [ i ] else
31426: LD_ADDR_VAR 0 5
31430: PUSH
31431: LD_EXP 67
31435: PUSH
31436: LD_VAR 0 2
31440: ARRAY
31441: ST_TO_ADDR
31442: GO 31458
// tmp := target [ 1 ] ;
31444: LD_ADDR_VAR 0 5
31448: PUSH
31449: LD_VAR 0 6
31453: PUSH
31454: LD_INT 1
31456: ARRAY
31457: ST_TO_ADDR
// k := 0 ;
31458: LD_ADDR_VAR 0 4
31462: PUSH
31463: LD_INT 0
31465: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
31466: LD_ADDR_VAR 0 3
31470: PUSH
31471: LD_EXP 67
31475: PUSH
31476: LD_VAR 0 2
31480: ARRAY
31481: PUSH
31482: FOR_IN
31483: IFFALSE 31643
// begin k := k + 1 ;
31485: LD_ADDR_VAR 0 4
31489: PUSH
31490: LD_VAR 0 4
31494: PUSH
31495: LD_INT 1
31497: PLUS
31498: ST_TO_ADDR
// if k > tmp then
31499: LD_VAR 0 4
31503: PUSH
31504: LD_VAR 0 5
31508: GREATER
31509: IFFALSE 31513
// break ;
31511: GO 31643
// if not GetClass ( j ) in [ 2 , 16 ] then
31513: LD_VAR 0 3
31517: PPUSH
31518: CALL_OW 257
31522: PUSH
31523: LD_INT 2
31525: PUSH
31526: LD_INT 16
31528: PUSH
31529: EMPTY
31530: LIST
31531: LIST
31532: IN
31533: NOT
31534: IFFALSE 31587
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
31536: LD_ADDR_EXP 67
31540: PUSH
31541: LD_EXP 67
31545: PPUSH
31546: LD_VAR 0 2
31550: PPUSH
31551: LD_EXP 67
31555: PUSH
31556: LD_VAR 0 2
31560: ARRAY
31561: PUSH
31562: LD_VAR 0 3
31566: DIFF
31567: PPUSH
31568: CALL_OW 1
31572: ST_TO_ADDR
// SetTag ( j , 0 ) ;
31573: LD_VAR 0 3
31577: PPUSH
31578: LD_INT 0
31580: PPUSH
31581: CALL_OW 109
// continue ;
31585: GO 31482
// end ; if IsInUnit ( j ) then
31587: LD_VAR 0 3
31591: PPUSH
31592: CALL_OW 310
31596: IFFALSE 31607
// ComExitBuilding ( j ) ;
31598: LD_VAR 0 3
31602: PPUSH
31603: CALL_OW 122
// wait ( 3 ) ;
31607: LD_INT 3
31609: PPUSH
31610: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
31614: LD_VAR 0 3
31618: PPUSH
31619: LD_VAR 0 6
31623: PUSH
31624: LD_INT 2
31626: ARRAY
31627: PPUSH
31628: LD_VAR 0 6
31632: PUSH
31633: LD_INT 3
31635: ARRAY
31636: PPUSH
31637: CALL_OW 117
// end ;
31641: GO 31482
31643: POP
31644: POP
// end ; end else
31645: GO 32226
// begin for j in cargo do
31647: LD_ADDR_VAR 0 3
31651: PUSH
31652: LD_VAR 0 7
31656: PUSH
31657: FOR_IN
31658: IFFALSE 32224
// begin if GetTag ( j ) <> 0 then
31660: LD_VAR 0 3
31664: PPUSH
31665: CALL_OW 110
31669: PUSH
31670: LD_INT 0
31672: NONEQUAL
31673: IFFALSE 31677
// continue ;
31675: GO 31657
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
31677: LD_VAR 0 3
31681: PPUSH
31682: CALL_OW 256
31686: PUSH
31687: LD_INT 1000
31689: LESS
31690: PUSH
31691: LD_VAR 0 3
31695: PPUSH
31696: LD_EXP 74
31700: PUSH
31701: LD_VAR 0 2
31705: ARRAY
31706: PPUSH
31707: CALL_OW 308
31711: NOT
31712: AND
31713: IFFALSE 31735
// ComMoveToArea ( j , mc_parking [ i ] ) ;
31715: LD_VAR 0 3
31719: PPUSH
31720: LD_EXP 74
31724: PUSH
31725: LD_VAR 0 2
31729: ARRAY
31730: PPUSH
31731: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
31735: LD_VAR 0 3
31739: PPUSH
31740: CALL_OW 256
31744: PUSH
31745: LD_INT 1000
31747: LESS
31748: PUSH
31749: LD_VAR 0 3
31753: PPUSH
31754: LD_EXP 74
31758: PUSH
31759: LD_VAR 0 2
31763: ARRAY
31764: PPUSH
31765: CALL_OW 308
31769: AND
31770: IFFALSE 31774
// continue ;
31772: GO 31657
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
31774: LD_VAR 0 3
31778: PPUSH
31779: CALL_OW 262
31783: PUSH
31784: LD_INT 2
31786: EQUAL
31787: PUSH
31788: LD_VAR 0 3
31792: PPUSH
31793: CALL_OW 261
31797: PUSH
31798: LD_INT 15
31800: LESS
31801: AND
31802: IFFALSE 31806
// continue ;
31804: GO 31657
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
31806: LD_VAR 0 3
31810: PPUSH
31811: CALL_OW 262
31815: PUSH
31816: LD_INT 1
31818: EQUAL
31819: PUSH
31820: LD_VAR 0 3
31824: PPUSH
31825: CALL_OW 261
31829: PUSH
31830: LD_INT 10
31832: LESS
31833: AND
31834: IFFALSE 32163
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31836: LD_ADDR_VAR 0 8
31840: PUSH
31841: LD_EXP 50
31845: PUSH
31846: LD_VAR 0 2
31850: ARRAY
31851: PPUSH
31852: LD_INT 2
31854: PUSH
31855: LD_INT 30
31857: PUSH
31858: LD_INT 0
31860: PUSH
31861: EMPTY
31862: LIST
31863: LIST
31864: PUSH
31865: LD_INT 30
31867: PUSH
31868: LD_INT 1
31870: PUSH
31871: EMPTY
31872: LIST
31873: LIST
31874: PUSH
31875: EMPTY
31876: LIST
31877: LIST
31878: LIST
31879: PPUSH
31880: CALL_OW 72
31884: ST_TO_ADDR
// if not depot then
31885: LD_VAR 0 8
31889: NOT
31890: IFFALSE 31894
// continue ;
31892: GO 31657
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
31894: LD_VAR 0 3
31898: PPUSH
31899: LD_VAR 0 8
31903: PPUSH
31904: LD_VAR 0 3
31908: PPUSH
31909: CALL_OW 74
31913: PPUSH
31914: CALL_OW 296
31918: PUSH
31919: LD_INT 6
31921: LESS
31922: IFFALSE 31938
// SetFuel ( j , 100 ) else
31924: LD_VAR 0 3
31928: PPUSH
31929: LD_INT 100
31931: PPUSH
31932: CALL_OW 240
31936: GO 32163
// if GetFuel ( j ) = 0 then
31938: LD_VAR 0 3
31942: PPUSH
31943: CALL_OW 261
31947: PUSH
31948: LD_INT 0
31950: EQUAL
31951: IFFALSE 32163
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
31953: LD_ADDR_EXP 69
31957: PUSH
31958: LD_EXP 69
31962: PPUSH
31963: LD_VAR 0 2
31967: PPUSH
31968: LD_EXP 69
31972: PUSH
31973: LD_VAR 0 2
31977: ARRAY
31978: PUSH
31979: LD_VAR 0 3
31983: DIFF
31984: PPUSH
31985: CALL_OW 1
31989: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
31990: LD_VAR 0 3
31994: PPUSH
31995: CALL_OW 263
31999: PUSH
32000: LD_INT 1
32002: EQUAL
32003: IFFALSE 32019
// ComExitVehicle ( IsInUnit ( j ) ) ;
32005: LD_VAR 0 3
32009: PPUSH
32010: CALL_OW 310
32014: PPUSH
32015: CALL_OW 121
// if GetControl ( j ) = control_remote then
32019: LD_VAR 0 3
32023: PPUSH
32024: CALL_OW 263
32028: PUSH
32029: LD_INT 2
32031: EQUAL
32032: IFFALSE 32043
// ComUnlink ( j ) ;
32034: LD_VAR 0 3
32038: PPUSH
32039: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
32043: LD_ADDR_VAR 0 9
32047: PUSH
32048: LD_VAR 0 2
32052: PPUSH
32053: LD_INT 3
32055: PPUSH
32056: CALL 41516 0 2
32060: ST_TO_ADDR
// if fac then
32061: LD_VAR 0 9
32065: IFFALSE 32161
// begin for k in fac do
32067: LD_ADDR_VAR 0 4
32071: PUSH
32072: LD_VAR 0 9
32076: PUSH
32077: FOR_IN
32078: IFFALSE 32159
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
32080: LD_ADDR_VAR 0 10
32084: PUSH
32085: LD_VAR 0 9
32089: PPUSH
32090: LD_VAR 0 3
32094: PPUSH
32095: CALL_OW 265
32099: PPUSH
32100: LD_VAR 0 3
32104: PPUSH
32105: CALL_OW 262
32109: PPUSH
32110: LD_VAR 0 3
32114: PPUSH
32115: CALL_OW 263
32119: PPUSH
32120: LD_VAR 0 3
32124: PPUSH
32125: CALL_OW 264
32129: PPUSH
32130: CALL 49883 0 5
32134: ST_TO_ADDR
// if components then
32135: LD_VAR 0 10
32139: IFFALSE 32157
// begin MC_InsertProduceList ( i , components ) ;
32141: LD_VAR 0 2
32145: PPUSH
32146: LD_VAR 0 10
32150: PPUSH
32151: CALL 41061 0 2
// break ;
32155: GO 32159
// end ; end ;
32157: GO 32077
32159: POP
32160: POP
// end ; continue ;
32161: GO 31657
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
32163: LD_VAR 0 3
32167: PPUSH
32168: LD_INT 1
32170: PPUSH
32171: CALL_OW 289
32175: PUSH
32176: LD_INT 100
32178: LESS
32179: PUSH
32180: LD_VAR 0 3
32184: PPUSH
32185: CALL_OW 314
32189: NOT
32190: AND
32191: IFFALSE 32220
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
32193: LD_VAR 0 3
32197: PPUSH
32198: LD_VAR 0 6
32202: PUSH
32203: LD_INT 2
32205: ARRAY
32206: PPUSH
32207: LD_VAR 0 6
32211: PUSH
32212: LD_INT 3
32214: ARRAY
32215: PPUSH
32216: CALL_OW 117
// break ;
32220: GO 32224
// end ;
32222: GO 31657
32224: POP
32225: POP
// end ; end ;
32226: GO 30495
32228: POP
32229: POP
// end ;
32230: LD_VAR 0 1
32234: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
32235: LD_INT 0
32237: PPUSH
32238: PPUSH
32239: PPUSH
32240: PPUSH
// if not mc_bases then
32241: LD_EXP 50
32245: NOT
32246: IFFALSE 32250
// exit ;
32248: GO 32411
// for i = 1 to mc_bases do
32250: LD_ADDR_VAR 0 2
32254: PUSH
32255: DOUBLE
32256: LD_INT 1
32258: DEC
32259: ST_TO_ADDR
32260: LD_EXP 50
32264: PUSH
32265: FOR_TO
32266: IFFALSE 32409
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
32268: LD_ADDR_VAR 0 4
32272: PUSH
32273: LD_EXP 69
32277: PUSH
32278: LD_VAR 0 2
32282: ARRAY
32283: PUSH
32284: LD_EXP 72
32288: PUSH
32289: LD_VAR 0 2
32293: ARRAY
32294: UNION
32295: PPUSH
32296: LD_INT 33
32298: PUSH
32299: LD_INT 2
32301: PUSH
32302: EMPTY
32303: LIST
32304: LIST
32305: PPUSH
32306: CALL_OW 72
32310: ST_TO_ADDR
// if tmp then
32311: LD_VAR 0 4
32315: IFFALSE 32407
// for j in tmp do
32317: LD_ADDR_VAR 0 3
32321: PUSH
32322: LD_VAR 0 4
32326: PUSH
32327: FOR_IN
32328: IFFALSE 32405
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
32330: LD_VAR 0 3
32334: PPUSH
32335: CALL_OW 312
32339: NOT
32340: PUSH
32341: LD_VAR 0 3
32345: PPUSH
32346: CALL_OW 256
32350: PUSH
32351: LD_INT 250
32353: GREATEREQUAL
32354: AND
32355: IFFALSE 32368
// Connect ( j ) else
32357: LD_VAR 0 3
32361: PPUSH
32362: CALL 55284 0 1
32366: GO 32403
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
32368: LD_VAR 0 3
32372: PPUSH
32373: CALL_OW 256
32377: PUSH
32378: LD_INT 250
32380: LESS
32381: PUSH
32382: LD_VAR 0 3
32386: PPUSH
32387: CALL_OW 312
32391: AND
32392: IFFALSE 32403
// ComUnlink ( j ) ;
32394: LD_VAR 0 3
32398: PPUSH
32399: CALL_OW 136
32403: GO 32327
32405: POP
32406: POP
// end ;
32407: GO 32265
32409: POP
32410: POP
// end ;
32411: LD_VAR 0 1
32415: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
32416: LD_INT 0
32418: PPUSH
32419: PPUSH
32420: PPUSH
32421: PPUSH
32422: PPUSH
// if not mc_bases then
32423: LD_EXP 50
32427: NOT
32428: IFFALSE 32432
// exit ;
32430: GO 32877
// for i = 1 to mc_bases do
32432: LD_ADDR_VAR 0 2
32436: PUSH
32437: DOUBLE
32438: LD_INT 1
32440: DEC
32441: ST_TO_ADDR
32442: LD_EXP 50
32446: PUSH
32447: FOR_TO
32448: IFFALSE 32875
// begin if not mc_produce [ i ] then
32450: LD_EXP 71
32454: PUSH
32455: LD_VAR 0 2
32459: ARRAY
32460: NOT
32461: IFFALSE 32465
// continue ;
32463: GO 32447
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
32465: LD_ADDR_VAR 0 5
32469: PUSH
32470: LD_EXP 50
32474: PUSH
32475: LD_VAR 0 2
32479: ARRAY
32480: PPUSH
32481: LD_INT 30
32483: PUSH
32484: LD_INT 3
32486: PUSH
32487: EMPTY
32488: LIST
32489: LIST
32490: PPUSH
32491: CALL_OW 72
32495: ST_TO_ADDR
// if not fac then
32496: LD_VAR 0 5
32500: NOT
32501: IFFALSE 32505
// continue ;
32503: GO 32447
// for j in fac do
32505: LD_ADDR_VAR 0 3
32509: PUSH
32510: LD_VAR 0 5
32514: PUSH
32515: FOR_IN
32516: IFFALSE 32871
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
32518: LD_VAR 0 3
32522: PPUSH
32523: CALL_OW 461
32527: PUSH
32528: LD_INT 2
32530: NONEQUAL
32531: PUSH
32532: LD_VAR 0 3
32536: PPUSH
32537: LD_INT 15
32539: PPUSH
32540: CALL 54944 0 2
32544: PUSH
32545: LD_INT 4
32547: ARRAY
32548: OR
32549: IFFALSE 32553
// continue ;
32551: GO 32515
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
32553: LD_VAR 0 3
32557: PPUSH
32558: LD_EXP 71
32562: PUSH
32563: LD_VAR 0 2
32567: ARRAY
32568: PUSH
32569: LD_INT 1
32571: ARRAY
32572: PUSH
32573: LD_INT 1
32575: ARRAY
32576: PPUSH
32577: LD_EXP 71
32581: PUSH
32582: LD_VAR 0 2
32586: ARRAY
32587: PUSH
32588: LD_INT 1
32590: ARRAY
32591: PUSH
32592: LD_INT 2
32594: ARRAY
32595: PPUSH
32596: LD_EXP 71
32600: PUSH
32601: LD_VAR 0 2
32605: ARRAY
32606: PUSH
32607: LD_INT 1
32609: ARRAY
32610: PUSH
32611: LD_INT 3
32613: ARRAY
32614: PPUSH
32615: LD_EXP 71
32619: PUSH
32620: LD_VAR 0 2
32624: ARRAY
32625: PUSH
32626: LD_INT 1
32628: ARRAY
32629: PUSH
32630: LD_INT 4
32632: ARRAY
32633: PPUSH
32634: CALL_OW 448
32638: PUSH
32639: LD_VAR 0 3
32643: PPUSH
32644: LD_EXP 71
32648: PUSH
32649: LD_VAR 0 2
32653: ARRAY
32654: PUSH
32655: LD_INT 1
32657: ARRAY
32658: PUSH
32659: LD_INT 1
32661: ARRAY
32662: PUSH
32663: LD_EXP 71
32667: PUSH
32668: LD_VAR 0 2
32672: ARRAY
32673: PUSH
32674: LD_INT 1
32676: ARRAY
32677: PUSH
32678: LD_INT 2
32680: ARRAY
32681: PUSH
32682: LD_EXP 71
32686: PUSH
32687: LD_VAR 0 2
32691: ARRAY
32692: PUSH
32693: LD_INT 1
32695: ARRAY
32696: PUSH
32697: LD_INT 3
32699: ARRAY
32700: PUSH
32701: LD_EXP 71
32705: PUSH
32706: LD_VAR 0 2
32710: ARRAY
32711: PUSH
32712: LD_INT 1
32714: ARRAY
32715: PUSH
32716: LD_INT 4
32718: ARRAY
32719: PUSH
32720: EMPTY
32721: LIST
32722: LIST
32723: LIST
32724: LIST
32725: PPUSH
32726: CALL 58615 0 2
32730: AND
32731: IFFALSE 32869
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
32733: LD_VAR 0 3
32737: PPUSH
32738: LD_EXP 71
32742: PUSH
32743: LD_VAR 0 2
32747: ARRAY
32748: PUSH
32749: LD_INT 1
32751: ARRAY
32752: PUSH
32753: LD_INT 1
32755: ARRAY
32756: PPUSH
32757: LD_EXP 71
32761: PUSH
32762: LD_VAR 0 2
32766: ARRAY
32767: PUSH
32768: LD_INT 1
32770: ARRAY
32771: PUSH
32772: LD_INT 2
32774: ARRAY
32775: PPUSH
32776: LD_EXP 71
32780: PUSH
32781: LD_VAR 0 2
32785: ARRAY
32786: PUSH
32787: LD_INT 1
32789: ARRAY
32790: PUSH
32791: LD_INT 3
32793: ARRAY
32794: PPUSH
32795: LD_EXP 71
32799: PUSH
32800: LD_VAR 0 2
32804: ARRAY
32805: PUSH
32806: LD_INT 1
32808: ARRAY
32809: PUSH
32810: LD_INT 4
32812: ARRAY
32813: PPUSH
32814: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
32818: LD_ADDR_VAR 0 4
32822: PUSH
32823: LD_EXP 71
32827: PUSH
32828: LD_VAR 0 2
32832: ARRAY
32833: PPUSH
32834: LD_INT 1
32836: PPUSH
32837: CALL_OW 3
32841: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
32842: LD_ADDR_EXP 71
32846: PUSH
32847: LD_EXP 71
32851: PPUSH
32852: LD_VAR 0 2
32856: PPUSH
32857: LD_VAR 0 4
32861: PPUSH
32862: CALL_OW 1
32866: ST_TO_ADDR
// break ;
32867: GO 32871
// end ; end ;
32869: GO 32515
32871: POP
32872: POP
// end ;
32873: GO 32447
32875: POP
32876: POP
// end ;
32877: LD_VAR 0 1
32881: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
32882: LD_INT 0
32884: PPUSH
32885: PPUSH
32886: PPUSH
// if not mc_bases then
32887: LD_EXP 50
32891: NOT
32892: IFFALSE 32896
// exit ;
32894: GO 32985
// for i = 1 to mc_bases do
32896: LD_ADDR_VAR 0 2
32900: PUSH
32901: DOUBLE
32902: LD_INT 1
32904: DEC
32905: ST_TO_ADDR
32906: LD_EXP 50
32910: PUSH
32911: FOR_TO
32912: IFFALSE 32983
// begin if mc_attack [ i ] then
32914: LD_EXP 70
32918: PUSH
32919: LD_VAR 0 2
32923: ARRAY
32924: IFFALSE 32981
// begin tmp := mc_attack [ i ] [ 1 ] ;
32926: LD_ADDR_VAR 0 3
32930: PUSH
32931: LD_EXP 70
32935: PUSH
32936: LD_VAR 0 2
32940: ARRAY
32941: PUSH
32942: LD_INT 1
32944: ARRAY
32945: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
32946: LD_ADDR_EXP 70
32950: PUSH
32951: LD_EXP 70
32955: PPUSH
32956: LD_VAR 0 2
32960: PPUSH
32961: EMPTY
32962: PPUSH
32963: CALL_OW 1
32967: ST_TO_ADDR
// Attack ( tmp ) ;
32968: LD_VAR 0 3
32972: PPUSH
32973: CALL 98348 0 1
// exit ;
32977: POP
32978: POP
32979: GO 32985
// end ; end ;
32981: GO 32911
32983: POP
32984: POP
// end ;
32985: LD_VAR 0 1
32989: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
32990: LD_INT 0
32992: PPUSH
32993: PPUSH
32994: PPUSH
32995: PPUSH
32996: PPUSH
32997: PPUSH
32998: PPUSH
// if not mc_bases then
32999: LD_EXP 50
33003: NOT
33004: IFFALSE 33008
// exit ;
33006: GO 33590
// for i = 1 to mc_bases do
33008: LD_ADDR_VAR 0 2
33012: PUSH
33013: DOUBLE
33014: LD_INT 1
33016: DEC
33017: ST_TO_ADDR
33018: LD_EXP 50
33022: PUSH
33023: FOR_TO
33024: IFFALSE 33588
// begin if not mc_bases [ i ] then
33026: LD_EXP 50
33030: PUSH
33031: LD_VAR 0 2
33035: ARRAY
33036: NOT
33037: IFFALSE 33041
// continue ;
33039: GO 33023
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
33041: LD_ADDR_VAR 0 7
33045: PUSH
33046: LD_EXP 50
33050: PUSH
33051: LD_VAR 0 2
33055: ARRAY
33056: PUSH
33057: LD_INT 1
33059: ARRAY
33060: PPUSH
33061: CALL 49187 0 1
33065: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
33066: LD_ADDR_EXP 73
33070: PUSH
33071: LD_EXP 73
33075: PPUSH
33076: LD_VAR 0 2
33080: PPUSH
33081: LD_EXP 50
33085: PUSH
33086: LD_VAR 0 2
33090: ARRAY
33091: PUSH
33092: LD_INT 1
33094: ARRAY
33095: PPUSH
33096: CALL_OW 255
33100: PPUSH
33101: LD_EXP 75
33105: PUSH
33106: LD_VAR 0 2
33110: ARRAY
33111: PPUSH
33112: CALL 49152 0 2
33116: PPUSH
33117: CALL_OW 1
33121: ST_TO_ADDR
// if not mc_scan [ i ] then
33122: LD_EXP 73
33126: PUSH
33127: LD_VAR 0 2
33131: ARRAY
33132: NOT
33133: IFFALSE 33288
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
33135: LD_ADDR_VAR 0 4
33139: PUSH
33140: LD_EXP 50
33144: PUSH
33145: LD_VAR 0 2
33149: ARRAY
33150: PPUSH
33151: LD_INT 2
33153: PUSH
33154: LD_INT 25
33156: PUSH
33157: LD_INT 5
33159: PUSH
33160: EMPTY
33161: LIST
33162: LIST
33163: PUSH
33164: LD_INT 25
33166: PUSH
33167: LD_INT 8
33169: PUSH
33170: EMPTY
33171: LIST
33172: LIST
33173: PUSH
33174: LD_INT 25
33176: PUSH
33177: LD_INT 9
33179: PUSH
33180: EMPTY
33181: LIST
33182: LIST
33183: PUSH
33184: EMPTY
33185: LIST
33186: LIST
33187: LIST
33188: LIST
33189: PPUSH
33190: CALL_OW 72
33194: ST_TO_ADDR
// if not tmp then
33195: LD_VAR 0 4
33199: NOT
33200: IFFALSE 33204
// continue ;
33202: GO 33023
// for j in tmp do
33204: LD_ADDR_VAR 0 3
33208: PUSH
33209: LD_VAR 0 4
33213: PUSH
33214: FOR_IN
33215: IFFALSE 33286
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
33217: LD_VAR 0 3
33221: PPUSH
33222: CALL_OW 310
33226: PPUSH
33227: CALL_OW 266
33231: PUSH
33232: LD_INT 5
33234: EQUAL
33235: PUSH
33236: LD_VAR 0 3
33240: PPUSH
33241: CALL_OW 257
33245: PUSH
33246: LD_INT 1
33248: EQUAL
33249: AND
33250: PUSH
33251: LD_VAR 0 3
33255: PPUSH
33256: CALL_OW 459
33260: NOT
33261: AND
33262: PUSH
33263: LD_VAR 0 7
33267: AND
33268: IFFALSE 33284
// ComChangeProfession ( j , class ) ;
33270: LD_VAR 0 3
33274: PPUSH
33275: LD_VAR 0 7
33279: PPUSH
33280: CALL_OW 123
33284: GO 33214
33286: POP
33287: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
33288: LD_EXP 73
33292: PUSH
33293: LD_VAR 0 2
33297: ARRAY
33298: PUSH
33299: LD_EXP 72
33303: PUSH
33304: LD_VAR 0 2
33308: ARRAY
33309: NOT
33310: AND
33311: PUSH
33312: LD_EXP 50
33316: PUSH
33317: LD_VAR 0 2
33321: ARRAY
33322: PPUSH
33323: LD_INT 30
33325: PUSH
33326: LD_INT 32
33328: PUSH
33329: EMPTY
33330: LIST
33331: LIST
33332: PPUSH
33333: CALL_OW 72
33337: NOT
33338: AND
33339: PUSH
33340: LD_EXP 50
33344: PUSH
33345: LD_VAR 0 2
33349: ARRAY
33350: PPUSH
33351: LD_INT 2
33353: PUSH
33354: LD_INT 30
33356: PUSH
33357: LD_INT 4
33359: PUSH
33360: EMPTY
33361: LIST
33362: LIST
33363: PUSH
33364: LD_INT 30
33366: PUSH
33367: LD_INT 5
33369: PUSH
33370: EMPTY
33371: LIST
33372: LIST
33373: PUSH
33374: EMPTY
33375: LIST
33376: LIST
33377: LIST
33378: PPUSH
33379: CALL_OW 72
33383: NOT
33384: AND
33385: IFFALSE 33517
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
33387: LD_ADDR_VAR 0 4
33391: PUSH
33392: LD_EXP 50
33396: PUSH
33397: LD_VAR 0 2
33401: ARRAY
33402: PPUSH
33403: LD_INT 2
33405: PUSH
33406: LD_INT 25
33408: PUSH
33409: LD_INT 1
33411: PUSH
33412: EMPTY
33413: LIST
33414: LIST
33415: PUSH
33416: LD_INT 25
33418: PUSH
33419: LD_INT 5
33421: PUSH
33422: EMPTY
33423: LIST
33424: LIST
33425: PUSH
33426: LD_INT 25
33428: PUSH
33429: LD_INT 8
33431: PUSH
33432: EMPTY
33433: LIST
33434: LIST
33435: PUSH
33436: LD_INT 25
33438: PUSH
33439: LD_INT 9
33441: PUSH
33442: EMPTY
33443: LIST
33444: LIST
33445: PUSH
33446: EMPTY
33447: LIST
33448: LIST
33449: LIST
33450: LIST
33451: LIST
33452: PPUSH
33453: CALL_OW 72
33457: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
33458: LD_ADDR_VAR 0 4
33462: PUSH
33463: LD_VAR 0 4
33467: PUSH
33468: LD_VAR 0 4
33472: PPUSH
33473: LD_INT 18
33475: PPUSH
33476: CALL 80912 0 2
33480: DIFF
33481: ST_TO_ADDR
// if tmp then
33482: LD_VAR 0 4
33486: IFFALSE 33517
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
33488: LD_VAR 0 2
33492: PPUSH
33493: LD_VAR 0 4
33497: PPUSH
33498: LD_EXP 75
33502: PUSH
33503: LD_VAR 0 2
33507: ARRAY
33508: PPUSH
33509: CALL 103057 0 3
// exit ;
33513: POP
33514: POP
33515: GO 33590
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
33517: LD_EXP 73
33521: PUSH
33522: LD_VAR 0 2
33526: ARRAY
33527: PUSH
33528: LD_EXP 72
33532: PUSH
33533: LD_VAR 0 2
33537: ARRAY
33538: AND
33539: IFFALSE 33586
// begin tmp := mc_defender [ i ] ;
33541: LD_ADDR_VAR 0 4
33545: PUSH
33546: LD_EXP 72
33550: PUSH
33551: LD_VAR 0 2
33555: ARRAY
33556: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
33557: LD_VAR 0 2
33561: PPUSH
33562: LD_VAR 0 4
33566: PPUSH
33567: LD_EXP 73
33571: PUSH
33572: LD_VAR 0 2
33576: ARRAY
33577: PPUSH
33578: CALL 103618 0 3
// exit ;
33582: POP
33583: POP
33584: GO 33590
// end ; end ;
33586: GO 33023
33588: POP
33589: POP
// end ;
33590: LD_VAR 0 1
33594: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
33595: LD_INT 0
33597: PPUSH
33598: PPUSH
33599: PPUSH
33600: PPUSH
33601: PPUSH
33602: PPUSH
33603: PPUSH
33604: PPUSH
33605: PPUSH
33606: PPUSH
33607: PPUSH
// if not mc_bases then
33608: LD_EXP 50
33612: NOT
33613: IFFALSE 33617
// exit ;
33615: GO 34704
// for i = 1 to mc_bases do
33617: LD_ADDR_VAR 0 2
33621: PUSH
33622: DOUBLE
33623: LD_INT 1
33625: DEC
33626: ST_TO_ADDR
33627: LD_EXP 50
33631: PUSH
33632: FOR_TO
33633: IFFALSE 34702
// begin tmp := mc_lab [ i ] ;
33635: LD_ADDR_VAR 0 6
33639: PUSH
33640: LD_EXP 83
33644: PUSH
33645: LD_VAR 0 2
33649: ARRAY
33650: ST_TO_ADDR
// if not tmp then
33651: LD_VAR 0 6
33655: NOT
33656: IFFALSE 33660
// continue ;
33658: GO 33632
// idle_lab := 0 ;
33660: LD_ADDR_VAR 0 11
33664: PUSH
33665: LD_INT 0
33667: ST_TO_ADDR
// for j in tmp do
33668: LD_ADDR_VAR 0 3
33672: PUSH
33673: LD_VAR 0 6
33677: PUSH
33678: FOR_IN
33679: IFFALSE 34698
// begin researching := false ;
33681: LD_ADDR_VAR 0 10
33685: PUSH
33686: LD_INT 0
33688: ST_TO_ADDR
// side := GetSide ( j ) ;
33689: LD_ADDR_VAR 0 4
33693: PUSH
33694: LD_VAR 0 3
33698: PPUSH
33699: CALL_OW 255
33703: ST_TO_ADDR
// if not mc_tech [ side ] then
33704: LD_EXP 77
33708: PUSH
33709: LD_VAR 0 4
33713: ARRAY
33714: NOT
33715: IFFALSE 33719
// continue ;
33717: GO 33678
// if BuildingStatus ( j ) = bs_idle then
33719: LD_VAR 0 3
33723: PPUSH
33724: CALL_OW 461
33728: PUSH
33729: LD_INT 2
33731: EQUAL
33732: IFFALSE 33920
// begin if idle_lab and UnitsInside ( j ) < 6 then
33734: LD_VAR 0 11
33738: PUSH
33739: LD_VAR 0 3
33743: PPUSH
33744: CALL_OW 313
33748: PUSH
33749: LD_INT 6
33751: LESS
33752: AND
33753: IFFALSE 33824
// begin tmp2 := UnitsInside ( idle_lab ) ;
33755: LD_ADDR_VAR 0 9
33759: PUSH
33760: LD_VAR 0 11
33764: PPUSH
33765: CALL_OW 313
33769: ST_TO_ADDR
// if tmp2 then
33770: LD_VAR 0 9
33774: IFFALSE 33816
// for x in tmp2 do
33776: LD_ADDR_VAR 0 7
33780: PUSH
33781: LD_VAR 0 9
33785: PUSH
33786: FOR_IN
33787: IFFALSE 33814
// begin ComExitBuilding ( x ) ;
33789: LD_VAR 0 7
33793: PPUSH
33794: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
33798: LD_VAR 0 7
33802: PPUSH
33803: LD_VAR 0 3
33807: PPUSH
33808: CALL_OW 180
// end ;
33812: GO 33786
33814: POP
33815: POP
// idle_lab := 0 ;
33816: LD_ADDR_VAR 0 11
33820: PUSH
33821: LD_INT 0
33823: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
33824: LD_ADDR_VAR 0 5
33828: PUSH
33829: LD_EXP 77
33833: PUSH
33834: LD_VAR 0 4
33838: ARRAY
33839: PUSH
33840: FOR_IN
33841: IFFALSE 33901
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
33843: LD_VAR 0 3
33847: PPUSH
33848: LD_VAR 0 5
33852: PPUSH
33853: CALL_OW 430
33857: PUSH
33858: LD_VAR 0 4
33862: PPUSH
33863: LD_VAR 0 5
33867: PPUSH
33868: CALL 48257 0 2
33872: AND
33873: IFFALSE 33899
// begin researching := true ;
33875: LD_ADDR_VAR 0 10
33879: PUSH
33880: LD_INT 1
33882: ST_TO_ADDR
// ComResearch ( j , t ) ;
33883: LD_VAR 0 3
33887: PPUSH
33888: LD_VAR 0 5
33892: PPUSH
33893: CALL_OW 124
// break ;
33897: GO 33901
// end ;
33899: GO 33840
33901: POP
33902: POP
// if not researching then
33903: LD_VAR 0 10
33907: NOT
33908: IFFALSE 33920
// idle_lab := j ;
33910: LD_ADDR_VAR 0 11
33914: PUSH
33915: LD_VAR 0 3
33919: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
33920: LD_VAR 0 3
33924: PPUSH
33925: CALL_OW 461
33929: PUSH
33930: LD_INT 10
33932: EQUAL
33933: IFFALSE 34521
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
33935: LD_EXP 79
33939: PUSH
33940: LD_VAR 0 2
33944: ARRAY
33945: NOT
33946: PUSH
33947: LD_EXP 80
33951: PUSH
33952: LD_VAR 0 2
33956: ARRAY
33957: NOT
33958: AND
33959: PUSH
33960: LD_EXP 77
33964: PUSH
33965: LD_VAR 0 4
33969: ARRAY
33970: PUSH
33971: LD_INT 1
33973: GREATER
33974: AND
33975: IFFALSE 34106
// begin ComCancel ( j ) ;
33977: LD_VAR 0 3
33981: PPUSH
33982: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
33986: LD_ADDR_EXP 77
33990: PUSH
33991: LD_EXP 77
33995: PPUSH
33996: LD_VAR 0 4
34000: PPUSH
34001: LD_EXP 77
34005: PUSH
34006: LD_VAR 0 4
34010: ARRAY
34011: PPUSH
34012: LD_EXP 77
34016: PUSH
34017: LD_VAR 0 4
34021: ARRAY
34022: PUSH
34023: LD_INT 1
34025: MINUS
34026: PPUSH
34027: LD_EXP 77
34031: PUSH
34032: LD_VAR 0 4
34036: ARRAY
34037: PPUSH
34038: LD_INT 0
34040: PPUSH
34041: CALL 51769 0 4
34045: PPUSH
34046: CALL_OW 1
34050: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
34051: LD_ADDR_EXP 77
34055: PUSH
34056: LD_EXP 77
34060: PPUSH
34061: LD_VAR 0 4
34065: PPUSH
34066: LD_EXP 77
34070: PUSH
34071: LD_VAR 0 4
34075: ARRAY
34076: PPUSH
34077: LD_EXP 77
34081: PUSH
34082: LD_VAR 0 4
34086: ARRAY
34087: PPUSH
34088: LD_INT 1
34090: PPUSH
34091: LD_INT 0
34093: PPUSH
34094: CALL 51769 0 4
34098: PPUSH
34099: CALL_OW 1
34103: ST_TO_ADDR
// continue ;
34104: GO 33678
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
34106: LD_EXP 79
34110: PUSH
34111: LD_VAR 0 2
34115: ARRAY
34116: PUSH
34117: LD_EXP 80
34121: PUSH
34122: LD_VAR 0 2
34126: ARRAY
34127: NOT
34128: AND
34129: IFFALSE 34256
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
34131: LD_ADDR_EXP 80
34135: PUSH
34136: LD_EXP 80
34140: PPUSH
34141: LD_VAR 0 2
34145: PUSH
34146: LD_EXP 80
34150: PUSH
34151: LD_VAR 0 2
34155: ARRAY
34156: PUSH
34157: LD_INT 1
34159: PLUS
34160: PUSH
34161: EMPTY
34162: LIST
34163: LIST
34164: PPUSH
34165: LD_EXP 79
34169: PUSH
34170: LD_VAR 0 2
34174: ARRAY
34175: PUSH
34176: LD_INT 1
34178: ARRAY
34179: PPUSH
34180: CALL 52351 0 3
34184: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
34185: LD_EXP 79
34189: PUSH
34190: LD_VAR 0 2
34194: ARRAY
34195: PUSH
34196: LD_INT 1
34198: ARRAY
34199: PPUSH
34200: LD_INT 112
34202: PPUSH
34203: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
34207: LD_ADDR_VAR 0 9
34211: PUSH
34212: LD_EXP 79
34216: PUSH
34217: LD_VAR 0 2
34221: ARRAY
34222: PPUSH
34223: LD_INT 1
34225: PPUSH
34226: CALL_OW 3
34230: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
34231: LD_ADDR_EXP 79
34235: PUSH
34236: LD_EXP 79
34240: PPUSH
34241: LD_VAR 0 2
34245: PPUSH
34246: LD_VAR 0 9
34250: PPUSH
34251: CALL_OW 1
34255: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
34256: LD_EXP 79
34260: PUSH
34261: LD_VAR 0 2
34265: ARRAY
34266: PUSH
34267: LD_EXP 80
34271: PUSH
34272: LD_VAR 0 2
34276: ARRAY
34277: AND
34278: PUSH
34279: LD_EXP 80
34283: PUSH
34284: LD_VAR 0 2
34288: ARRAY
34289: PUSH
34290: LD_INT 1
34292: ARRAY
34293: PPUSH
34294: CALL_OW 310
34298: NOT
34299: AND
34300: PUSH
34301: LD_VAR 0 3
34305: PPUSH
34306: CALL_OW 313
34310: PUSH
34311: LD_INT 6
34313: EQUAL
34314: AND
34315: IFFALSE 34371
// begin tmp2 := UnitsInside ( j ) ;
34317: LD_ADDR_VAR 0 9
34321: PUSH
34322: LD_VAR 0 3
34326: PPUSH
34327: CALL_OW 313
34331: ST_TO_ADDR
// if tmp2 = 6 then
34332: LD_VAR 0 9
34336: PUSH
34337: LD_INT 6
34339: EQUAL
34340: IFFALSE 34371
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
34342: LD_VAR 0 9
34346: PUSH
34347: LD_INT 1
34349: ARRAY
34350: PPUSH
34351: LD_INT 112
34353: PPUSH
34354: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
34358: LD_VAR 0 9
34362: PUSH
34363: LD_INT 1
34365: ARRAY
34366: PPUSH
34367: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
34371: LD_EXP 80
34375: PUSH
34376: LD_VAR 0 2
34380: ARRAY
34381: PUSH
34382: LD_EXP 80
34386: PUSH
34387: LD_VAR 0 2
34391: ARRAY
34392: PUSH
34393: LD_INT 1
34395: ARRAY
34396: PPUSH
34397: CALL_OW 314
34401: NOT
34402: AND
34403: PUSH
34404: LD_EXP 80
34408: PUSH
34409: LD_VAR 0 2
34413: ARRAY
34414: PUSH
34415: LD_INT 1
34417: ARRAY
34418: PPUSH
34419: CALL_OW 310
34423: NOT
34424: AND
34425: IFFALSE 34451
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
34427: LD_EXP 80
34431: PUSH
34432: LD_VAR 0 2
34436: ARRAY
34437: PUSH
34438: LD_INT 1
34440: ARRAY
34441: PPUSH
34442: LD_VAR 0 3
34446: PPUSH
34447: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
34451: LD_EXP 80
34455: PUSH
34456: LD_VAR 0 2
34460: ARRAY
34461: PUSH
34462: LD_INT 1
34464: ARRAY
34465: PPUSH
34466: CALL_OW 310
34470: PUSH
34471: LD_EXP 80
34475: PUSH
34476: LD_VAR 0 2
34480: ARRAY
34481: PUSH
34482: LD_INT 1
34484: ARRAY
34485: PPUSH
34486: CALL_OW 310
34490: PPUSH
34491: CALL_OW 461
34495: PUSH
34496: LD_INT 3
34498: NONEQUAL
34499: AND
34500: IFFALSE 34521
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
34502: LD_EXP 80
34506: PUSH
34507: LD_VAR 0 2
34511: ARRAY
34512: PUSH
34513: LD_INT 1
34515: ARRAY
34516: PPUSH
34517: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
34521: LD_VAR 0 3
34525: PPUSH
34526: CALL_OW 461
34530: PUSH
34531: LD_INT 6
34533: EQUAL
34534: PUSH
34535: LD_VAR 0 6
34539: PUSH
34540: LD_INT 1
34542: GREATER
34543: AND
34544: IFFALSE 34696
// begin sci := [ ] ;
34546: LD_ADDR_VAR 0 8
34550: PUSH
34551: EMPTY
34552: ST_TO_ADDR
// for x in ( tmp diff j ) do
34553: LD_ADDR_VAR 0 7
34557: PUSH
34558: LD_VAR 0 6
34562: PUSH
34563: LD_VAR 0 3
34567: DIFF
34568: PUSH
34569: FOR_IN
34570: IFFALSE 34622
// begin if sci = 6 then
34572: LD_VAR 0 8
34576: PUSH
34577: LD_INT 6
34579: EQUAL
34580: IFFALSE 34584
// break ;
34582: GO 34622
// if BuildingStatus ( x ) = bs_idle then
34584: LD_VAR 0 7
34588: PPUSH
34589: CALL_OW 461
34593: PUSH
34594: LD_INT 2
34596: EQUAL
34597: IFFALSE 34620
// sci := sci ^ UnitsInside ( x ) ;
34599: LD_ADDR_VAR 0 8
34603: PUSH
34604: LD_VAR 0 8
34608: PUSH
34609: LD_VAR 0 7
34613: PPUSH
34614: CALL_OW 313
34618: ADD
34619: ST_TO_ADDR
// end ;
34620: GO 34569
34622: POP
34623: POP
// if not sci then
34624: LD_VAR 0 8
34628: NOT
34629: IFFALSE 34633
// continue ;
34631: GO 33678
// for x in sci do
34633: LD_ADDR_VAR 0 7
34637: PUSH
34638: LD_VAR 0 8
34642: PUSH
34643: FOR_IN
34644: IFFALSE 34694
// if IsInUnit ( x ) and not HasTask ( x ) then
34646: LD_VAR 0 7
34650: PPUSH
34651: CALL_OW 310
34655: PUSH
34656: LD_VAR 0 7
34660: PPUSH
34661: CALL_OW 314
34665: NOT
34666: AND
34667: IFFALSE 34692
// begin ComExitBuilding ( x ) ;
34669: LD_VAR 0 7
34673: PPUSH
34674: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
34678: LD_VAR 0 7
34682: PPUSH
34683: LD_VAR 0 3
34687: PPUSH
34688: CALL_OW 180
// end ;
34692: GO 34643
34694: POP
34695: POP
// end ; end ;
34696: GO 33678
34698: POP
34699: POP
// end ;
34700: GO 33632
34702: POP
34703: POP
// end ;
34704: LD_VAR 0 1
34708: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
34709: LD_INT 0
34711: PPUSH
34712: PPUSH
// if not mc_bases then
34713: LD_EXP 50
34717: NOT
34718: IFFALSE 34722
// exit ;
34720: GO 34803
// for i = 1 to mc_bases do
34722: LD_ADDR_VAR 0 2
34726: PUSH
34727: DOUBLE
34728: LD_INT 1
34730: DEC
34731: ST_TO_ADDR
34732: LD_EXP 50
34736: PUSH
34737: FOR_TO
34738: IFFALSE 34801
// if mc_mines [ i ] and mc_miners [ i ] then
34740: LD_EXP 63
34744: PUSH
34745: LD_VAR 0 2
34749: ARRAY
34750: PUSH
34751: LD_EXP 64
34755: PUSH
34756: LD_VAR 0 2
34760: ARRAY
34761: AND
34762: IFFALSE 34799
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
34764: LD_EXP 64
34768: PUSH
34769: LD_VAR 0 2
34773: ARRAY
34774: PUSH
34775: LD_INT 1
34777: ARRAY
34778: PPUSH
34779: CALL_OW 255
34783: PPUSH
34784: LD_EXP 63
34788: PUSH
34789: LD_VAR 0 2
34793: ARRAY
34794: PPUSH
34795: CALL 49340 0 2
34799: GO 34737
34801: POP
34802: POP
// end ;
34803: LD_VAR 0 1
34807: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
34808: LD_INT 0
34810: PPUSH
34811: PPUSH
34812: PPUSH
34813: PPUSH
34814: PPUSH
34815: PPUSH
34816: PPUSH
34817: PPUSH
// if not mc_bases or not mc_parking then
34818: LD_EXP 50
34822: NOT
34823: PUSH
34824: LD_EXP 74
34828: NOT
34829: OR
34830: IFFALSE 34834
// exit ;
34832: GO 35533
// for i = 1 to mc_bases do
34834: LD_ADDR_VAR 0 2
34838: PUSH
34839: DOUBLE
34840: LD_INT 1
34842: DEC
34843: ST_TO_ADDR
34844: LD_EXP 50
34848: PUSH
34849: FOR_TO
34850: IFFALSE 35531
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
34852: LD_EXP 50
34856: PUSH
34857: LD_VAR 0 2
34861: ARRAY
34862: NOT
34863: PUSH
34864: LD_EXP 74
34868: PUSH
34869: LD_VAR 0 2
34873: ARRAY
34874: NOT
34875: OR
34876: IFFALSE 34880
// continue ;
34878: GO 34849
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
34880: LD_ADDR_VAR 0 5
34884: PUSH
34885: LD_EXP 50
34889: PUSH
34890: LD_VAR 0 2
34894: ARRAY
34895: PUSH
34896: LD_INT 1
34898: ARRAY
34899: PPUSH
34900: CALL_OW 255
34904: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
34905: LD_ADDR_VAR 0 6
34909: PUSH
34910: LD_EXP 50
34914: PUSH
34915: LD_VAR 0 2
34919: ARRAY
34920: PPUSH
34921: LD_INT 30
34923: PUSH
34924: LD_INT 3
34926: PUSH
34927: EMPTY
34928: LIST
34929: LIST
34930: PPUSH
34931: CALL_OW 72
34935: ST_TO_ADDR
// if not fac then
34936: LD_VAR 0 6
34940: NOT
34941: IFFALSE 34992
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
34943: LD_ADDR_VAR 0 6
34947: PUSH
34948: LD_EXP 50
34952: PUSH
34953: LD_VAR 0 2
34957: ARRAY
34958: PPUSH
34959: LD_INT 2
34961: PUSH
34962: LD_INT 30
34964: PUSH
34965: LD_INT 0
34967: PUSH
34968: EMPTY
34969: LIST
34970: LIST
34971: PUSH
34972: LD_INT 30
34974: PUSH
34975: LD_INT 1
34977: PUSH
34978: EMPTY
34979: LIST
34980: LIST
34981: PUSH
34982: EMPTY
34983: LIST
34984: LIST
34985: LIST
34986: PPUSH
34987: CALL_OW 72
34991: ST_TO_ADDR
// if not fac then
34992: LD_VAR 0 6
34996: NOT
34997: IFFALSE 35001
// continue ;
34999: GO 34849
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
35001: LD_ADDR_VAR 0 7
35005: PUSH
35006: LD_EXP 74
35010: PUSH
35011: LD_VAR 0 2
35015: ARRAY
35016: PPUSH
35017: LD_INT 22
35019: PUSH
35020: LD_VAR 0 5
35024: PUSH
35025: EMPTY
35026: LIST
35027: LIST
35028: PUSH
35029: LD_INT 21
35031: PUSH
35032: LD_INT 2
35034: PUSH
35035: EMPTY
35036: LIST
35037: LIST
35038: PUSH
35039: LD_INT 3
35041: PUSH
35042: LD_INT 24
35044: PUSH
35045: LD_INT 1000
35047: PUSH
35048: EMPTY
35049: LIST
35050: LIST
35051: PUSH
35052: EMPTY
35053: LIST
35054: LIST
35055: PUSH
35056: EMPTY
35057: LIST
35058: LIST
35059: LIST
35060: PPUSH
35061: CALL_OW 70
35065: ST_TO_ADDR
// for j in fac do
35066: LD_ADDR_VAR 0 3
35070: PUSH
35071: LD_VAR 0 6
35075: PUSH
35076: FOR_IN
35077: IFFALSE 35158
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
35079: LD_ADDR_VAR 0 7
35083: PUSH
35084: LD_VAR 0 7
35088: PUSH
35089: LD_INT 22
35091: PUSH
35092: LD_VAR 0 5
35096: PUSH
35097: EMPTY
35098: LIST
35099: LIST
35100: PUSH
35101: LD_INT 91
35103: PUSH
35104: LD_VAR 0 3
35108: PUSH
35109: LD_INT 15
35111: PUSH
35112: EMPTY
35113: LIST
35114: LIST
35115: LIST
35116: PUSH
35117: LD_INT 21
35119: PUSH
35120: LD_INT 2
35122: PUSH
35123: EMPTY
35124: LIST
35125: LIST
35126: PUSH
35127: LD_INT 3
35129: PUSH
35130: LD_INT 24
35132: PUSH
35133: LD_INT 1000
35135: PUSH
35136: EMPTY
35137: LIST
35138: LIST
35139: PUSH
35140: EMPTY
35141: LIST
35142: LIST
35143: PUSH
35144: EMPTY
35145: LIST
35146: LIST
35147: LIST
35148: LIST
35149: PPUSH
35150: CALL_OW 69
35154: UNION
35155: ST_TO_ADDR
35156: GO 35076
35158: POP
35159: POP
// if not vehs then
35160: LD_VAR 0 7
35164: NOT
35165: IFFALSE 35191
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
35167: LD_ADDR_EXP 62
35171: PUSH
35172: LD_EXP 62
35176: PPUSH
35177: LD_VAR 0 2
35181: PPUSH
35182: EMPTY
35183: PPUSH
35184: CALL_OW 1
35188: ST_TO_ADDR
// continue ;
35189: GO 34849
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
35191: LD_ADDR_VAR 0 8
35195: PUSH
35196: LD_EXP 50
35200: PUSH
35201: LD_VAR 0 2
35205: ARRAY
35206: PPUSH
35207: LD_INT 30
35209: PUSH
35210: LD_INT 3
35212: PUSH
35213: EMPTY
35214: LIST
35215: LIST
35216: PPUSH
35217: CALL_OW 72
35221: ST_TO_ADDR
// if tmp then
35222: LD_VAR 0 8
35226: IFFALSE 35329
// begin for j in tmp do
35228: LD_ADDR_VAR 0 3
35232: PUSH
35233: LD_VAR 0 8
35237: PUSH
35238: FOR_IN
35239: IFFALSE 35327
// for k in UnitsInside ( j ) do
35241: LD_ADDR_VAR 0 4
35245: PUSH
35246: LD_VAR 0 3
35250: PPUSH
35251: CALL_OW 313
35255: PUSH
35256: FOR_IN
35257: IFFALSE 35323
// if k then
35259: LD_VAR 0 4
35263: IFFALSE 35321
// if not k in mc_repair_vehicle [ i ] then
35265: LD_VAR 0 4
35269: PUSH
35270: LD_EXP 62
35274: PUSH
35275: LD_VAR 0 2
35279: ARRAY
35280: IN
35281: NOT
35282: IFFALSE 35321
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
35284: LD_ADDR_EXP 62
35288: PUSH
35289: LD_EXP 62
35293: PPUSH
35294: LD_VAR 0 2
35298: PPUSH
35299: LD_EXP 62
35303: PUSH
35304: LD_VAR 0 2
35308: ARRAY
35309: PUSH
35310: LD_VAR 0 4
35314: UNION
35315: PPUSH
35316: CALL_OW 1
35320: ST_TO_ADDR
35321: GO 35256
35323: POP
35324: POP
35325: GO 35238
35327: POP
35328: POP
// end ; if not mc_repair_vehicle [ i ] then
35329: LD_EXP 62
35333: PUSH
35334: LD_VAR 0 2
35338: ARRAY
35339: NOT
35340: IFFALSE 35344
// continue ;
35342: GO 34849
// for j in mc_repair_vehicle [ i ] do
35344: LD_ADDR_VAR 0 3
35348: PUSH
35349: LD_EXP 62
35353: PUSH
35354: LD_VAR 0 2
35358: ARRAY
35359: PUSH
35360: FOR_IN
35361: IFFALSE 35527
// begin if GetClass ( j ) <> 3 then
35363: LD_VAR 0 3
35367: PPUSH
35368: CALL_OW 257
35372: PUSH
35373: LD_INT 3
35375: NONEQUAL
35376: IFFALSE 35417
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
35378: LD_ADDR_EXP 62
35382: PUSH
35383: LD_EXP 62
35387: PPUSH
35388: LD_VAR 0 2
35392: PPUSH
35393: LD_EXP 62
35397: PUSH
35398: LD_VAR 0 2
35402: ARRAY
35403: PUSH
35404: LD_VAR 0 3
35408: DIFF
35409: PPUSH
35410: CALL_OW 1
35414: ST_TO_ADDR
// continue ;
35415: GO 35360
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
35417: LD_VAR 0 3
35421: PPUSH
35422: CALL_OW 311
35426: NOT
35427: PUSH
35428: LD_VAR 0 3
35432: PUSH
35433: LD_EXP 53
35437: PUSH
35438: LD_VAR 0 2
35442: ARRAY
35443: PUSH
35444: LD_INT 1
35446: ARRAY
35447: IN
35448: NOT
35449: AND
35450: PUSH
35451: LD_VAR 0 3
35455: PUSH
35456: LD_EXP 53
35460: PUSH
35461: LD_VAR 0 2
35465: ARRAY
35466: PUSH
35467: LD_INT 2
35469: ARRAY
35470: IN
35471: NOT
35472: AND
35473: IFFALSE 35525
// begin if IsInUnit ( j ) then
35475: LD_VAR 0 3
35479: PPUSH
35480: CALL_OW 310
35484: IFFALSE 35495
// ComExitBuilding ( j ) ;
35486: LD_VAR 0 3
35490: PPUSH
35491: CALL_OW 122
// if not HasTask ( j ) then
35495: LD_VAR 0 3
35499: PPUSH
35500: CALL_OW 314
35504: NOT
35505: IFFALSE 35525
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
35507: LD_VAR 0 3
35511: PPUSH
35512: LD_VAR 0 7
35516: PUSH
35517: LD_INT 1
35519: ARRAY
35520: PPUSH
35521: CALL_OW 189
// end ; end ;
35525: GO 35360
35527: POP
35528: POP
// end ;
35529: GO 34849
35531: POP
35532: POP
// end ;
35533: LD_VAR 0 1
35537: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
35538: LD_INT 0
35540: PPUSH
35541: PPUSH
35542: PPUSH
35543: PPUSH
35544: PPUSH
35545: PPUSH
35546: PPUSH
35547: PPUSH
35548: PPUSH
35549: PPUSH
35550: PPUSH
// if not mc_bases then
35551: LD_EXP 50
35555: NOT
35556: IFFALSE 35560
// exit ;
35558: GO 36362
// for i = 1 to mc_bases do
35560: LD_ADDR_VAR 0 2
35564: PUSH
35565: DOUBLE
35566: LD_INT 1
35568: DEC
35569: ST_TO_ADDR
35570: LD_EXP 50
35574: PUSH
35575: FOR_TO
35576: IFFALSE 36360
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
35578: LD_EXP 78
35582: PUSH
35583: LD_VAR 0 2
35587: ARRAY
35588: NOT
35589: PUSH
35590: LD_EXP 53
35594: PUSH
35595: LD_VAR 0 2
35599: ARRAY
35600: PUSH
35601: LD_INT 1
35603: ARRAY
35604: OR
35605: PUSH
35606: LD_EXP 53
35610: PUSH
35611: LD_VAR 0 2
35615: ARRAY
35616: PUSH
35617: LD_INT 2
35619: ARRAY
35620: OR
35621: PUSH
35622: LD_EXP 76
35626: PUSH
35627: LD_VAR 0 2
35631: ARRAY
35632: PPUSH
35633: LD_INT 1
35635: PPUSH
35636: CALL_OW 325
35640: NOT
35641: OR
35642: PUSH
35643: LD_EXP 73
35647: PUSH
35648: LD_VAR 0 2
35652: ARRAY
35653: OR
35654: IFFALSE 35658
// continue ;
35656: GO 35575
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
35658: LD_ADDR_VAR 0 8
35662: PUSH
35663: LD_EXP 50
35667: PUSH
35668: LD_VAR 0 2
35672: ARRAY
35673: PPUSH
35674: LD_INT 25
35676: PUSH
35677: LD_INT 4
35679: PUSH
35680: EMPTY
35681: LIST
35682: LIST
35683: PUSH
35684: LD_INT 50
35686: PUSH
35687: EMPTY
35688: LIST
35689: PUSH
35690: LD_INT 3
35692: PUSH
35693: LD_INT 60
35695: PUSH
35696: EMPTY
35697: LIST
35698: PUSH
35699: EMPTY
35700: LIST
35701: LIST
35702: PUSH
35703: EMPTY
35704: LIST
35705: LIST
35706: LIST
35707: PPUSH
35708: CALL_OW 72
35712: PUSH
35713: LD_EXP 54
35717: PUSH
35718: LD_VAR 0 2
35722: ARRAY
35723: DIFF
35724: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
35725: LD_ADDR_VAR 0 9
35729: PUSH
35730: LD_EXP 50
35734: PUSH
35735: LD_VAR 0 2
35739: ARRAY
35740: PPUSH
35741: LD_INT 2
35743: PUSH
35744: LD_INT 30
35746: PUSH
35747: LD_INT 0
35749: PUSH
35750: EMPTY
35751: LIST
35752: LIST
35753: PUSH
35754: LD_INT 30
35756: PUSH
35757: LD_INT 1
35759: PUSH
35760: EMPTY
35761: LIST
35762: LIST
35763: PUSH
35764: EMPTY
35765: LIST
35766: LIST
35767: LIST
35768: PPUSH
35769: CALL_OW 72
35773: ST_TO_ADDR
// if not tmp or not dep then
35774: LD_VAR 0 8
35778: NOT
35779: PUSH
35780: LD_VAR 0 9
35784: NOT
35785: OR
35786: IFFALSE 35790
// continue ;
35788: GO 35575
// side := GetSide ( tmp [ 1 ] ) ;
35790: LD_ADDR_VAR 0 11
35794: PUSH
35795: LD_VAR 0 8
35799: PUSH
35800: LD_INT 1
35802: ARRAY
35803: PPUSH
35804: CALL_OW 255
35808: ST_TO_ADDR
// dep := dep [ 1 ] ;
35809: LD_ADDR_VAR 0 9
35813: PUSH
35814: LD_VAR 0 9
35818: PUSH
35819: LD_INT 1
35821: ARRAY
35822: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
35823: LD_ADDR_VAR 0 7
35827: PUSH
35828: LD_EXP 78
35832: PUSH
35833: LD_VAR 0 2
35837: ARRAY
35838: PPUSH
35839: LD_INT 22
35841: PUSH
35842: LD_INT 0
35844: PUSH
35845: EMPTY
35846: LIST
35847: LIST
35848: PUSH
35849: LD_INT 25
35851: PUSH
35852: LD_INT 12
35854: PUSH
35855: EMPTY
35856: LIST
35857: LIST
35858: PUSH
35859: EMPTY
35860: LIST
35861: LIST
35862: PPUSH
35863: CALL_OW 70
35867: PUSH
35868: LD_INT 22
35870: PUSH
35871: LD_INT 0
35873: PUSH
35874: EMPTY
35875: LIST
35876: LIST
35877: PUSH
35878: LD_INT 25
35880: PUSH
35881: LD_INT 12
35883: PUSH
35884: EMPTY
35885: LIST
35886: LIST
35887: PUSH
35888: LD_INT 91
35890: PUSH
35891: LD_VAR 0 9
35895: PUSH
35896: LD_INT 20
35898: PUSH
35899: EMPTY
35900: LIST
35901: LIST
35902: LIST
35903: PUSH
35904: EMPTY
35905: LIST
35906: LIST
35907: LIST
35908: PPUSH
35909: CALL_OW 69
35913: UNION
35914: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
35915: LD_ADDR_VAR 0 10
35919: PUSH
35920: LD_EXP 78
35924: PUSH
35925: LD_VAR 0 2
35929: ARRAY
35930: PPUSH
35931: LD_INT 81
35933: PUSH
35934: LD_VAR 0 11
35938: PUSH
35939: EMPTY
35940: LIST
35941: LIST
35942: PPUSH
35943: CALL_OW 70
35947: ST_TO_ADDR
// if not apes or danger_at_area then
35948: LD_VAR 0 7
35952: NOT
35953: PUSH
35954: LD_VAR 0 10
35958: OR
35959: IFFALSE 36009
// begin if mc_taming [ i ] then
35961: LD_EXP 81
35965: PUSH
35966: LD_VAR 0 2
35970: ARRAY
35971: IFFALSE 36007
// begin MC_Reset ( i , 121 ) ;
35973: LD_VAR 0 2
35977: PPUSH
35978: LD_INT 121
35980: PPUSH
35981: CALL 21460 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
35985: LD_ADDR_EXP 81
35989: PUSH
35990: LD_EXP 81
35994: PPUSH
35995: LD_VAR 0 2
35999: PPUSH
36000: EMPTY
36001: PPUSH
36002: CALL_OW 1
36006: ST_TO_ADDR
// end ; continue ;
36007: GO 35575
// end ; for j in tmp do
36009: LD_ADDR_VAR 0 3
36013: PUSH
36014: LD_VAR 0 8
36018: PUSH
36019: FOR_IN
36020: IFFALSE 36356
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
36022: LD_VAR 0 3
36026: PUSH
36027: LD_EXP 81
36031: PUSH
36032: LD_VAR 0 2
36036: ARRAY
36037: IN
36038: NOT
36039: PUSH
36040: LD_EXP 81
36044: PUSH
36045: LD_VAR 0 2
36049: ARRAY
36050: PUSH
36051: LD_INT 3
36053: LESS
36054: AND
36055: IFFALSE 36113
// begin SetTag ( j , 121 ) ;
36057: LD_VAR 0 3
36061: PPUSH
36062: LD_INT 121
36064: PPUSH
36065: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
36069: LD_ADDR_EXP 81
36073: PUSH
36074: LD_EXP 81
36078: PPUSH
36079: LD_VAR 0 2
36083: PUSH
36084: LD_EXP 81
36088: PUSH
36089: LD_VAR 0 2
36093: ARRAY
36094: PUSH
36095: LD_INT 1
36097: PLUS
36098: PUSH
36099: EMPTY
36100: LIST
36101: LIST
36102: PPUSH
36103: LD_VAR 0 3
36107: PPUSH
36108: CALL 52351 0 3
36112: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
36113: LD_VAR 0 3
36117: PUSH
36118: LD_EXP 81
36122: PUSH
36123: LD_VAR 0 2
36127: ARRAY
36128: IN
36129: IFFALSE 36354
// begin if GetClass ( j ) <> 4 then
36131: LD_VAR 0 3
36135: PPUSH
36136: CALL_OW 257
36140: PUSH
36141: LD_INT 4
36143: NONEQUAL
36144: IFFALSE 36197
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
36146: LD_ADDR_EXP 81
36150: PUSH
36151: LD_EXP 81
36155: PPUSH
36156: LD_VAR 0 2
36160: PPUSH
36161: LD_EXP 81
36165: PUSH
36166: LD_VAR 0 2
36170: ARRAY
36171: PUSH
36172: LD_VAR 0 3
36176: DIFF
36177: PPUSH
36178: CALL_OW 1
36182: ST_TO_ADDR
// SetTag ( j , 0 ) ;
36183: LD_VAR 0 3
36187: PPUSH
36188: LD_INT 0
36190: PPUSH
36191: CALL_OW 109
// continue ;
36195: GO 36019
// end ; if IsInUnit ( j ) then
36197: LD_VAR 0 3
36201: PPUSH
36202: CALL_OW 310
36206: IFFALSE 36217
// ComExitBuilding ( j ) ;
36208: LD_VAR 0 3
36212: PPUSH
36213: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
36217: LD_ADDR_VAR 0 6
36221: PUSH
36222: LD_VAR 0 7
36226: PPUSH
36227: LD_VAR 0 3
36231: PPUSH
36232: CALL_OW 74
36236: ST_TO_ADDR
// if not ape then
36237: LD_VAR 0 6
36241: NOT
36242: IFFALSE 36246
// break ;
36244: GO 36356
// x := GetX ( ape ) ;
36246: LD_ADDR_VAR 0 4
36250: PUSH
36251: LD_VAR 0 6
36255: PPUSH
36256: CALL_OW 250
36260: ST_TO_ADDR
// y := GetY ( ape ) ;
36261: LD_ADDR_VAR 0 5
36265: PUSH
36266: LD_VAR 0 6
36270: PPUSH
36271: CALL_OW 251
36275: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
36276: LD_VAR 0 4
36280: PPUSH
36281: LD_VAR 0 5
36285: PPUSH
36286: CALL_OW 488
36290: NOT
36291: PUSH
36292: LD_VAR 0 11
36296: PPUSH
36297: LD_VAR 0 4
36301: PPUSH
36302: LD_VAR 0 5
36306: PPUSH
36307: LD_INT 20
36309: PPUSH
36310: CALL 53247 0 4
36314: PUSH
36315: LD_INT 4
36317: ARRAY
36318: OR
36319: IFFALSE 36323
// break ;
36321: GO 36356
// if not HasTask ( j ) then
36323: LD_VAR 0 3
36327: PPUSH
36328: CALL_OW 314
36332: NOT
36333: IFFALSE 36354
// ComTameXY ( j , x , y ) ;
36335: LD_VAR 0 3
36339: PPUSH
36340: LD_VAR 0 4
36344: PPUSH
36345: LD_VAR 0 5
36349: PPUSH
36350: CALL_OW 131
// end ; end ;
36354: GO 36019
36356: POP
36357: POP
// end ;
36358: GO 35575
36360: POP
36361: POP
// end ;
36362: LD_VAR 0 1
36366: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
36367: LD_INT 0
36369: PPUSH
36370: PPUSH
36371: PPUSH
36372: PPUSH
36373: PPUSH
36374: PPUSH
36375: PPUSH
36376: PPUSH
// if not mc_bases then
36377: LD_EXP 50
36381: NOT
36382: IFFALSE 36386
// exit ;
36384: GO 37012
// for i = 1 to mc_bases do
36386: LD_ADDR_VAR 0 2
36390: PUSH
36391: DOUBLE
36392: LD_INT 1
36394: DEC
36395: ST_TO_ADDR
36396: LD_EXP 50
36400: PUSH
36401: FOR_TO
36402: IFFALSE 37010
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
36404: LD_EXP 79
36408: PUSH
36409: LD_VAR 0 2
36413: ARRAY
36414: NOT
36415: PUSH
36416: LD_EXP 79
36420: PUSH
36421: LD_VAR 0 2
36425: ARRAY
36426: PPUSH
36427: LD_INT 25
36429: PUSH
36430: LD_INT 12
36432: PUSH
36433: EMPTY
36434: LIST
36435: LIST
36436: PPUSH
36437: CALL_OW 72
36441: NOT
36442: OR
36443: IFFALSE 36447
// continue ;
36445: GO 36401
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
36447: LD_ADDR_VAR 0 5
36451: PUSH
36452: LD_EXP 79
36456: PUSH
36457: LD_VAR 0 2
36461: ARRAY
36462: PUSH
36463: LD_INT 1
36465: ARRAY
36466: PPUSH
36467: CALL_OW 255
36471: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
36472: LD_VAR 0 5
36476: PPUSH
36477: LD_INT 2
36479: PPUSH
36480: CALL_OW 325
36484: IFFALSE 36737
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
36486: LD_ADDR_VAR 0 4
36490: PUSH
36491: LD_EXP 79
36495: PUSH
36496: LD_VAR 0 2
36500: ARRAY
36501: PPUSH
36502: LD_INT 25
36504: PUSH
36505: LD_INT 16
36507: PUSH
36508: EMPTY
36509: LIST
36510: LIST
36511: PPUSH
36512: CALL_OW 72
36516: ST_TO_ADDR
// if tmp < 6 then
36517: LD_VAR 0 4
36521: PUSH
36522: LD_INT 6
36524: LESS
36525: IFFALSE 36737
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
36527: LD_ADDR_VAR 0 6
36531: PUSH
36532: LD_EXP 50
36536: PUSH
36537: LD_VAR 0 2
36541: ARRAY
36542: PPUSH
36543: LD_INT 2
36545: PUSH
36546: LD_INT 30
36548: PUSH
36549: LD_INT 0
36551: PUSH
36552: EMPTY
36553: LIST
36554: LIST
36555: PUSH
36556: LD_INT 30
36558: PUSH
36559: LD_INT 1
36561: PUSH
36562: EMPTY
36563: LIST
36564: LIST
36565: PUSH
36566: EMPTY
36567: LIST
36568: LIST
36569: LIST
36570: PPUSH
36571: CALL_OW 72
36575: ST_TO_ADDR
// if depot then
36576: LD_VAR 0 6
36580: IFFALSE 36737
// begin selected := 0 ;
36582: LD_ADDR_VAR 0 7
36586: PUSH
36587: LD_INT 0
36589: ST_TO_ADDR
// for j in depot do
36590: LD_ADDR_VAR 0 3
36594: PUSH
36595: LD_VAR 0 6
36599: PUSH
36600: FOR_IN
36601: IFFALSE 36632
// begin if UnitsInside ( j ) < 6 then
36603: LD_VAR 0 3
36607: PPUSH
36608: CALL_OW 313
36612: PUSH
36613: LD_INT 6
36615: LESS
36616: IFFALSE 36630
// begin selected := j ;
36618: LD_ADDR_VAR 0 7
36622: PUSH
36623: LD_VAR 0 3
36627: ST_TO_ADDR
// break ;
36628: GO 36632
// end ; end ;
36630: GO 36600
36632: POP
36633: POP
// if selected then
36634: LD_VAR 0 7
36638: IFFALSE 36737
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
36640: LD_ADDR_VAR 0 3
36644: PUSH
36645: LD_EXP 79
36649: PUSH
36650: LD_VAR 0 2
36654: ARRAY
36655: PPUSH
36656: LD_INT 25
36658: PUSH
36659: LD_INT 12
36661: PUSH
36662: EMPTY
36663: LIST
36664: LIST
36665: PPUSH
36666: CALL_OW 72
36670: PUSH
36671: FOR_IN
36672: IFFALSE 36735
// if not HasTask ( j ) then
36674: LD_VAR 0 3
36678: PPUSH
36679: CALL_OW 314
36683: NOT
36684: IFFALSE 36733
// begin if not IsInUnit ( j ) then
36686: LD_VAR 0 3
36690: PPUSH
36691: CALL_OW 310
36695: NOT
36696: IFFALSE 36712
// ComEnterUnit ( j , selected ) ;
36698: LD_VAR 0 3
36702: PPUSH
36703: LD_VAR 0 7
36707: PPUSH
36708: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
36712: LD_VAR 0 3
36716: PPUSH
36717: LD_INT 16
36719: PPUSH
36720: CALL_OW 183
// AddComExitBuilding ( j ) ;
36724: LD_VAR 0 3
36728: PPUSH
36729: CALL_OW 182
// end ;
36733: GO 36671
36735: POP
36736: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
36737: LD_VAR 0 5
36741: PPUSH
36742: LD_INT 11
36744: PPUSH
36745: CALL_OW 325
36749: IFFALSE 37008
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
36751: LD_ADDR_VAR 0 4
36755: PUSH
36756: LD_EXP 79
36760: PUSH
36761: LD_VAR 0 2
36765: ARRAY
36766: PPUSH
36767: LD_INT 25
36769: PUSH
36770: LD_INT 16
36772: PUSH
36773: EMPTY
36774: LIST
36775: LIST
36776: PPUSH
36777: CALL_OW 72
36781: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
36782: LD_VAR 0 4
36786: PUSH
36787: LD_INT 6
36789: GREATEREQUAL
36790: PUSH
36791: LD_VAR 0 5
36795: PPUSH
36796: LD_INT 2
36798: PPUSH
36799: CALL_OW 325
36803: NOT
36804: OR
36805: IFFALSE 37008
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
36807: LD_ADDR_VAR 0 8
36811: PUSH
36812: LD_EXP 50
36816: PUSH
36817: LD_VAR 0 2
36821: ARRAY
36822: PPUSH
36823: LD_INT 2
36825: PUSH
36826: LD_INT 30
36828: PUSH
36829: LD_INT 4
36831: PUSH
36832: EMPTY
36833: LIST
36834: LIST
36835: PUSH
36836: LD_INT 30
36838: PUSH
36839: LD_INT 5
36841: PUSH
36842: EMPTY
36843: LIST
36844: LIST
36845: PUSH
36846: EMPTY
36847: LIST
36848: LIST
36849: LIST
36850: PPUSH
36851: CALL_OW 72
36855: ST_TO_ADDR
// if barracks then
36856: LD_VAR 0 8
36860: IFFALSE 37008
// begin selected := 0 ;
36862: LD_ADDR_VAR 0 7
36866: PUSH
36867: LD_INT 0
36869: ST_TO_ADDR
// for j in barracks do
36870: LD_ADDR_VAR 0 3
36874: PUSH
36875: LD_VAR 0 8
36879: PUSH
36880: FOR_IN
36881: IFFALSE 36912
// begin if UnitsInside ( j ) < 6 then
36883: LD_VAR 0 3
36887: PPUSH
36888: CALL_OW 313
36892: PUSH
36893: LD_INT 6
36895: LESS
36896: IFFALSE 36910
// begin selected := j ;
36898: LD_ADDR_VAR 0 7
36902: PUSH
36903: LD_VAR 0 3
36907: ST_TO_ADDR
// break ;
36908: GO 36912
// end ; end ;
36910: GO 36880
36912: POP
36913: POP
// if selected then
36914: LD_VAR 0 7
36918: IFFALSE 37008
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
36920: LD_ADDR_VAR 0 3
36924: PUSH
36925: LD_EXP 79
36929: PUSH
36930: LD_VAR 0 2
36934: ARRAY
36935: PPUSH
36936: LD_INT 25
36938: PUSH
36939: LD_INT 12
36941: PUSH
36942: EMPTY
36943: LIST
36944: LIST
36945: PPUSH
36946: CALL_OW 72
36950: PUSH
36951: FOR_IN
36952: IFFALSE 37006
// if not IsInUnit ( j ) and not HasTask ( j ) then
36954: LD_VAR 0 3
36958: PPUSH
36959: CALL_OW 310
36963: NOT
36964: PUSH
36965: LD_VAR 0 3
36969: PPUSH
36970: CALL_OW 314
36974: NOT
36975: AND
36976: IFFALSE 37004
// begin ComEnterUnit ( j , selected ) ;
36978: LD_VAR 0 3
36982: PPUSH
36983: LD_VAR 0 7
36987: PPUSH
36988: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
36992: LD_VAR 0 3
36996: PPUSH
36997: LD_INT 15
36999: PPUSH
37000: CALL_OW 183
// end ;
37004: GO 36951
37006: POP
37007: POP
// end ; end ; end ; end ; end ;
37008: GO 36401
37010: POP
37011: POP
// end ;
37012: LD_VAR 0 1
37016: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
37017: LD_INT 0
37019: PPUSH
37020: PPUSH
37021: PPUSH
37022: PPUSH
// if not mc_bases then
37023: LD_EXP 50
37027: NOT
37028: IFFALSE 37032
// exit ;
37030: GO 37210
// for i = 1 to mc_bases do
37032: LD_ADDR_VAR 0 2
37036: PUSH
37037: DOUBLE
37038: LD_INT 1
37040: DEC
37041: ST_TO_ADDR
37042: LD_EXP 50
37046: PUSH
37047: FOR_TO
37048: IFFALSE 37208
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
37050: LD_ADDR_VAR 0 4
37054: PUSH
37055: LD_EXP 50
37059: PUSH
37060: LD_VAR 0 2
37064: ARRAY
37065: PPUSH
37066: LD_INT 25
37068: PUSH
37069: LD_INT 9
37071: PUSH
37072: EMPTY
37073: LIST
37074: LIST
37075: PPUSH
37076: CALL_OW 72
37080: ST_TO_ADDR
// if not tmp then
37081: LD_VAR 0 4
37085: NOT
37086: IFFALSE 37090
// continue ;
37088: GO 37047
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
37090: LD_EXP 76
37094: PUSH
37095: LD_VAR 0 2
37099: ARRAY
37100: PPUSH
37101: LD_INT 29
37103: PPUSH
37104: CALL_OW 325
37108: NOT
37109: PUSH
37110: LD_EXP 76
37114: PUSH
37115: LD_VAR 0 2
37119: ARRAY
37120: PPUSH
37121: LD_INT 28
37123: PPUSH
37124: CALL_OW 325
37128: NOT
37129: AND
37130: IFFALSE 37134
// continue ;
37132: GO 37047
// for j in tmp do
37134: LD_ADDR_VAR 0 3
37138: PUSH
37139: LD_VAR 0 4
37143: PUSH
37144: FOR_IN
37145: IFFALSE 37204
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
37147: LD_VAR 0 3
37151: PUSH
37152: LD_EXP 53
37156: PUSH
37157: LD_VAR 0 2
37161: ARRAY
37162: PUSH
37163: LD_INT 1
37165: ARRAY
37166: IN
37167: NOT
37168: PUSH
37169: LD_VAR 0 3
37173: PUSH
37174: LD_EXP 53
37178: PUSH
37179: LD_VAR 0 2
37183: ARRAY
37184: PUSH
37185: LD_INT 2
37187: ARRAY
37188: IN
37189: NOT
37190: AND
37191: IFFALSE 37202
// ComSpaceTimeShoot ( j ) ;
37193: LD_VAR 0 3
37197: PPUSH
37198: CALL 48348 0 1
37202: GO 37144
37204: POP
37205: POP
// end ;
37206: GO 37047
37208: POP
37209: POP
// end ;
37210: LD_VAR 0 1
37214: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
37215: LD_INT 0
37217: PPUSH
37218: PPUSH
37219: PPUSH
37220: PPUSH
37221: PPUSH
37222: PPUSH
37223: PPUSH
37224: PPUSH
37225: PPUSH
// if not mc_bases then
37226: LD_EXP 50
37230: NOT
37231: IFFALSE 37235
// exit ;
37233: GO 37857
// for i = 1 to mc_bases do
37235: LD_ADDR_VAR 0 2
37239: PUSH
37240: DOUBLE
37241: LD_INT 1
37243: DEC
37244: ST_TO_ADDR
37245: LD_EXP 50
37249: PUSH
37250: FOR_TO
37251: IFFALSE 37855
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
37253: LD_EXP 85
37257: PUSH
37258: LD_VAR 0 2
37262: ARRAY
37263: NOT
37264: PUSH
37265: LD_INT 38
37267: PPUSH
37268: LD_EXP 76
37272: PUSH
37273: LD_VAR 0 2
37277: ARRAY
37278: PPUSH
37279: CALL_OW 321
37283: PUSH
37284: LD_INT 2
37286: NONEQUAL
37287: OR
37288: IFFALSE 37292
// continue ;
37290: GO 37250
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
37292: LD_ADDR_VAR 0 8
37296: PUSH
37297: LD_EXP 50
37301: PUSH
37302: LD_VAR 0 2
37306: ARRAY
37307: PPUSH
37308: LD_INT 30
37310: PUSH
37311: LD_INT 34
37313: PUSH
37314: EMPTY
37315: LIST
37316: LIST
37317: PPUSH
37318: CALL_OW 72
37322: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
37323: LD_ADDR_VAR 0 9
37327: PUSH
37328: LD_EXP 50
37332: PUSH
37333: LD_VAR 0 2
37337: ARRAY
37338: PPUSH
37339: LD_INT 25
37341: PUSH
37342: LD_INT 4
37344: PUSH
37345: EMPTY
37346: LIST
37347: LIST
37348: PPUSH
37349: CALL_OW 72
37353: PPUSH
37354: LD_INT 0
37356: PPUSH
37357: CALL 80912 0 2
37361: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
37362: LD_VAR 0 9
37366: NOT
37367: PUSH
37368: LD_VAR 0 8
37372: NOT
37373: OR
37374: PUSH
37375: LD_EXP 50
37379: PUSH
37380: LD_VAR 0 2
37384: ARRAY
37385: PPUSH
37386: LD_INT 124
37388: PPUSH
37389: CALL 80912 0 2
37393: OR
37394: IFFALSE 37398
// continue ;
37396: GO 37250
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
37398: LD_EXP 86
37402: PUSH
37403: LD_VAR 0 2
37407: ARRAY
37408: PUSH
37409: LD_EXP 85
37413: PUSH
37414: LD_VAR 0 2
37418: ARRAY
37419: LESS
37420: PUSH
37421: LD_EXP 86
37425: PUSH
37426: LD_VAR 0 2
37430: ARRAY
37431: PUSH
37432: LD_VAR 0 8
37436: LESS
37437: AND
37438: IFFALSE 37853
// begin tmp := sci [ 1 ] ;
37440: LD_ADDR_VAR 0 7
37444: PUSH
37445: LD_VAR 0 9
37449: PUSH
37450: LD_INT 1
37452: ARRAY
37453: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
37454: LD_VAR 0 7
37458: PPUSH
37459: LD_INT 124
37461: PPUSH
37462: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
37466: LD_ADDR_VAR 0 3
37470: PUSH
37471: DOUBLE
37472: LD_EXP 85
37476: PUSH
37477: LD_VAR 0 2
37481: ARRAY
37482: INC
37483: ST_TO_ADDR
37484: LD_EXP 85
37488: PUSH
37489: LD_VAR 0 2
37493: ARRAY
37494: PUSH
37495: FOR_DOWNTO
37496: IFFALSE 37839
// begin if IsInUnit ( tmp ) then
37498: LD_VAR 0 7
37502: PPUSH
37503: CALL_OW 310
37507: IFFALSE 37518
// ComExitBuilding ( tmp ) ;
37509: LD_VAR 0 7
37513: PPUSH
37514: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
37518: LD_INT 35
37520: PPUSH
37521: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
37525: LD_VAR 0 7
37529: PPUSH
37530: CALL_OW 310
37534: NOT
37535: PUSH
37536: LD_VAR 0 7
37540: PPUSH
37541: CALL_OW 314
37545: NOT
37546: AND
37547: IFFALSE 37518
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
37549: LD_ADDR_VAR 0 6
37553: PUSH
37554: LD_VAR 0 7
37558: PPUSH
37559: CALL_OW 250
37563: PUSH
37564: LD_VAR 0 7
37568: PPUSH
37569: CALL_OW 251
37573: PUSH
37574: EMPTY
37575: LIST
37576: LIST
37577: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
37578: LD_INT 35
37580: PPUSH
37581: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
37585: LD_ADDR_VAR 0 4
37589: PUSH
37590: LD_EXP 85
37594: PUSH
37595: LD_VAR 0 2
37599: ARRAY
37600: PUSH
37601: LD_VAR 0 3
37605: ARRAY
37606: PUSH
37607: LD_INT 1
37609: ARRAY
37610: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
37611: LD_ADDR_VAR 0 5
37615: PUSH
37616: LD_EXP 85
37620: PUSH
37621: LD_VAR 0 2
37625: ARRAY
37626: PUSH
37627: LD_VAR 0 3
37631: ARRAY
37632: PUSH
37633: LD_INT 2
37635: ARRAY
37636: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
37637: LD_VAR 0 7
37641: PPUSH
37642: LD_INT 10
37644: PPUSH
37645: CALL 54944 0 2
37649: PUSH
37650: LD_INT 4
37652: ARRAY
37653: IFFALSE 37691
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
37655: LD_VAR 0 7
37659: PPUSH
37660: LD_VAR 0 6
37664: PUSH
37665: LD_INT 1
37667: ARRAY
37668: PPUSH
37669: LD_VAR 0 6
37673: PUSH
37674: LD_INT 2
37676: ARRAY
37677: PPUSH
37678: CALL_OW 111
// wait ( 0 0$10 ) ;
37682: LD_INT 350
37684: PPUSH
37685: CALL_OW 67
// end else
37689: GO 37717
// begin ComMoveXY ( tmp , x , y ) ;
37691: LD_VAR 0 7
37695: PPUSH
37696: LD_VAR 0 4
37700: PPUSH
37701: LD_VAR 0 5
37705: PPUSH
37706: CALL_OW 111
// wait ( 0 0$3 ) ;
37710: LD_INT 105
37712: PPUSH
37713: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
37717: LD_VAR 0 7
37721: PPUSH
37722: LD_VAR 0 4
37726: PPUSH
37727: LD_VAR 0 5
37731: PPUSH
37732: CALL_OW 307
37736: IFFALSE 37578
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
37738: LD_VAR 0 7
37742: PPUSH
37743: LD_VAR 0 4
37747: PPUSH
37748: LD_VAR 0 5
37752: PPUSH
37753: LD_VAR 0 8
37757: PUSH
37758: LD_VAR 0 3
37762: ARRAY
37763: PPUSH
37764: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
37768: LD_INT 35
37770: PPUSH
37771: CALL_OW 67
// until not HasTask ( tmp ) ;
37775: LD_VAR 0 7
37779: PPUSH
37780: CALL_OW 314
37784: NOT
37785: IFFALSE 37768
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
37787: LD_ADDR_EXP 86
37791: PUSH
37792: LD_EXP 86
37796: PPUSH
37797: LD_VAR 0 2
37801: PUSH
37802: LD_EXP 86
37806: PUSH
37807: LD_VAR 0 2
37811: ARRAY
37812: PUSH
37813: LD_INT 1
37815: PLUS
37816: PUSH
37817: EMPTY
37818: LIST
37819: LIST
37820: PPUSH
37821: LD_VAR 0 8
37825: PUSH
37826: LD_VAR 0 3
37830: ARRAY
37831: PPUSH
37832: CALL 52351 0 3
37836: ST_TO_ADDR
// end ;
37837: GO 37495
37839: POP
37840: POP
// MC_Reset ( i , 124 ) ;
37841: LD_VAR 0 2
37845: PPUSH
37846: LD_INT 124
37848: PPUSH
37849: CALL 21460 0 2
// end ; end ;
37853: GO 37250
37855: POP
37856: POP
// end ;
37857: LD_VAR 0 1
37861: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
37862: LD_INT 0
37864: PPUSH
37865: PPUSH
37866: PPUSH
// if not mc_bases then
37867: LD_EXP 50
37871: NOT
37872: IFFALSE 37876
// exit ;
37874: GO 38482
// for i = 1 to mc_bases do
37876: LD_ADDR_VAR 0 2
37880: PUSH
37881: DOUBLE
37882: LD_INT 1
37884: DEC
37885: ST_TO_ADDR
37886: LD_EXP 50
37890: PUSH
37891: FOR_TO
37892: IFFALSE 38480
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
37894: LD_ADDR_VAR 0 3
37898: PUSH
37899: LD_EXP 50
37903: PUSH
37904: LD_VAR 0 2
37908: ARRAY
37909: PPUSH
37910: LD_INT 25
37912: PUSH
37913: LD_INT 4
37915: PUSH
37916: EMPTY
37917: LIST
37918: LIST
37919: PPUSH
37920: CALL_OW 72
37924: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
37925: LD_VAR 0 3
37929: NOT
37930: PUSH
37931: LD_EXP 87
37935: PUSH
37936: LD_VAR 0 2
37940: ARRAY
37941: NOT
37942: OR
37943: PUSH
37944: LD_EXP 50
37948: PUSH
37949: LD_VAR 0 2
37953: ARRAY
37954: PPUSH
37955: LD_INT 2
37957: PUSH
37958: LD_INT 30
37960: PUSH
37961: LD_INT 0
37963: PUSH
37964: EMPTY
37965: LIST
37966: LIST
37967: PUSH
37968: LD_INT 30
37970: PUSH
37971: LD_INT 1
37973: PUSH
37974: EMPTY
37975: LIST
37976: LIST
37977: PUSH
37978: EMPTY
37979: LIST
37980: LIST
37981: LIST
37982: PPUSH
37983: CALL_OW 72
37987: NOT
37988: OR
37989: IFFALSE 38039
// begin if mc_deposits_finder [ i ] then
37991: LD_EXP 88
37995: PUSH
37996: LD_VAR 0 2
38000: ARRAY
38001: IFFALSE 38037
// begin MC_Reset ( i , 125 ) ;
38003: LD_VAR 0 2
38007: PPUSH
38008: LD_INT 125
38010: PPUSH
38011: CALL 21460 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
38015: LD_ADDR_EXP 88
38019: PUSH
38020: LD_EXP 88
38024: PPUSH
38025: LD_VAR 0 2
38029: PPUSH
38030: EMPTY
38031: PPUSH
38032: CALL_OW 1
38036: ST_TO_ADDR
// end ; continue ;
38037: GO 37891
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
38039: LD_EXP 87
38043: PUSH
38044: LD_VAR 0 2
38048: ARRAY
38049: PUSH
38050: LD_INT 1
38052: ARRAY
38053: PUSH
38054: LD_INT 3
38056: ARRAY
38057: PUSH
38058: LD_INT 1
38060: EQUAL
38061: PUSH
38062: LD_INT 20
38064: PPUSH
38065: LD_EXP 76
38069: PUSH
38070: LD_VAR 0 2
38074: ARRAY
38075: PPUSH
38076: CALL_OW 321
38080: PUSH
38081: LD_INT 2
38083: NONEQUAL
38084: AND
38085: IFFALSE 38135
// begin if mc_deposits_finder [ i ] then
38087: LD_EXP 88
38091: PUSH
38092: LD_VAR 0 2
38096: ARRAY
38097: IFFALSE 38133
// begin MC_Reset ( i , 125 ) ;
38099: LD_VAR 0 2
38103: PPUSH
38104: LD_INT 125
38106: PPUSH
38107: CALL 21460 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
38111: LD_ADDR_EXP 88
38115: PUSH
38116: LD_EXP 88
38120: PPUSH
38121: LD_VAR 0 2
38125: PPUSH
38126: EMPTY
38127: PPUSH
38128: CALL_OW 1
38132: ST_TO_ADDR
// end ; continue ;
38133: GO 37891
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
38135: LD_EXP 87
38139: PUSH
38140: LD_VAR 0 2
38144: ARRAY
38145: PUSH
38146: LD_INT 1
38148: ARRAY
38149: PUSH
38150: LD_INT 1
38152: ARRAY
38153: PPUSH
38154: LD_EXP 87
38158: PUSH
38159: LD_VAR 0 2
38163: ARRAY
38164: PUSH
38165: LD_INT 1
38167: ARRAY
38168: PUSH
38169: LD_INT 2
38171: ARRAY
38172: PPUSH
38173: LD_EXP 76
38177: PUSH
38178: LD_VAR 0 2
38182: ARRAY
38183: PPUSH
38184: CALL_OW 440
38188: IFFALSE 38231
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
38190: LD_ADDR_EXP 87
38194: PUSH
38195: LD_EXP 87
38199: PPUSH
38200: LD_VAR 0 2
38204: PPUSH
38205: LD_EXP 87
38209: PUSH
38210: LD_VAR 0 2
38214: ARRAY
38215: PPUSH
38216: LD_INT 1
38218: PPUSH
38219: CALL_OW 3
38223: PPUSH
38224: CALL_OW 1
38228: ST_TO_ADDR
38229: GO 38478
// begin if not mc_deposits_finder [ i ] then
38231: LD_EXP 88
38235: PUSH
38236: LD_VAR 0 2
38240: ARRAY
38241: NOT
38242: IFFALSE 38294
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
38244: LD_ADDR_EXP 88
38248: PUSH
38249: LD_EXP 88
38253: PPUSH
38254: LD_VAR 0 2
38258: PPUSH
38259: LD_VAR 0 3
38263: PUSH
38264: LD_INT 1
38266: ARRAY
38267: PUSH
38268: EMPTY
38269: LIST
38270: PPUSH
38271: CALL_OW 1
38275: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
38276: LD_VAR 0 3
38280: PUSH
38281: LD_INT 1
38283: ARRAY
38284: PPUSH
38285: LD_INT 125
38287: PPUSH
38288: CALL_OW 109
// end else
38292: GO 38478
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
38294: LD_EXP 88
38298: PUSH
38299: LD_VAR 0 2
38303: ARRAY
38304: PUSH
38305: LD_INT 1
38307: ARRAY
38308: PPUSH
38309: CALL_OW 310
38313: IFFALSE 38336
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
38315: LD_EXP 88
38319: PUSH
38320: LD_VAR 0 2
38324: ARRAY
38325: PUSH
38326: LD_INT 1
38328: ARRAY
38329: PPUSH
38330: CALL_OW 122
38334: GO 38478
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
38336: LD_EXP 88
38340: PUSH
38341: LD_VAR 0 2
38345: ARRAY
38346: PUSH
38347: LD_INT 1
38349: ARRAY
38350: PPUSH
38351: CALL_OW 314
38355: NOT
38356: PUSH
38357: LD_EXP 88
38361: PUSH
38362: LD_VAR 0 2
38366: ARRAY
38367: PUSH
38368: LD_INT 1
38370: ARRAY
38371: PPUSH
38372: LD_EXP 87
38376: PUSH
38377: LD_VAR 0 2
38381: ARRAY
38382: PUSH
38383: LD_INT 1
38385: ARRAY
38386: PUSH
38387: LD_INT 1
38389: ARRAY
38390: PPUSH
38391: LD_EXP 87
38395: PUSH
38396: LD_VAR 0 2
38400: ARRAY
38401: PUSH
38402: LD_INT 1
38404: ARRAY
38405: PUSH
38406: LD_INT 2
38408: ARRAY
38409: PPUSH
38410: CALL_OW 297
38414: PUSH
38415: LD_INT 6
38417: GREATER
38418: AND
38419: IFFALSE 38478
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
38421: LD_EXP 88
38425: PUSH
38426: LD_VAR 0 2
38430: ARRAY
38431: PUSH
38432: LD_INT 1
38434: ARRAY
38435: PPUSH
38436: LD_EXP 87
38440: PUSH
38441: LD_VAR 0 2
38445: ARRAY
38446: PUSH
38447: LD_INT 1
38449: ARRAY
38450: PUSH
38451: LD_INT 1
38453: ARRAY
38454: PPUSH
38455: LD_EXP 87
38459: PUSH
38460: LD_VAR 0 2
38464: ARRAY
38465: PUSH
38466: LD_INT 1
38468: ARRAY
38469: PUSH
38470: LD_INT 2
38472: ARRAY
38473: PPUSH
38474: CALL_OW 111
// end ; end ; end ;
38478: GO 37891
38480: POP
38481: POP
// end ;
38482: LD_VAR 0 1
38486: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
38487: LD_INT 0
38489: PPUSH
38490: PPUSH
38491: PPUSH
38492: PPUSH
38493: PPUSH
38494: PPUSH
38495: PPUSH
38496: PPUSH
38497: PPUSH
38498: PPUSH
38499: PPUSH
// if not mc_bases then
38500: LD_EXP 50
38504: NOT
38505: IFFALSE 38509
// exit ;
38507: GO 39449
// for i = 1 to mc_bases do
38509: LD_ADDR_VAR 0 2
38513: PUSH
38514: DOUBLE
38515: LD_INT 1
38517: DEC
38518: ST_TO_ADDR
38519: LD_EXP 50
38523: PUSH
38524: FOR_TO
38525: IFFALSE 39447
// begin if not mc_bases [ i ] or mc_scan [ i ] then
38527: LD_EXP 50
38531: PUSH
38532: LD_VAR 0 2
38536: ARRAY
38537: NOT
38538: PUSH
38539: LD_EXP 73
38543: PUSH
38544: LD_VAR 0 2
38548: ARRAY
38549: OR
38550: IFFALSE 38554
// continue ;
38552: GO 38524
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
38554: LD_ADDR_VAR 0 7
38558: PUSH
38559: LD_EXP 50
38563: PUSH
38564: LD_VAR 0 2
38568: ARRAY
38569: PUSH
38570: LD_INT 1
38572: ARRAY
38573: PPUSH
38574: CALL_OW 248
38578: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
38579: LD_VAR 0 7
38583: PUSH
38584: LD_INT 3
38586: EQUAL
38587: PUSH
38588: LD_EXP 69
38592: PUSH
38593: LD_VAR 0 2
38597: ARRAY
38598: PUSH
38599: LD_EXP 72
38603: PUSH
38604: LD_VAR 0 2
38608: ARRAY
38609: UNION
38610: PPUSH
38611: LD_INT 33
38613: PUSH
38614: LD_INT 2
38616: PUSH
38617: EMPTY
38618: LIST
38619: LIST
38620: PPUSH
38621: CALL_OW 72
38625: NOT
38626: OR
38627: IFFALSE 38631
// continue ;
38629: GO 38524
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
38631: LD_ADDR_VAR 0 9
38635: PUSH
38636: LD_EXP 50
38640: PUSH
38641: LD_VAR 0 2
38645: ARRAY
38646: PPUSH
38647: LD_INT 30
38649: PUSH
38650: LD_INT 36
38652: PUSH
38653: EMPTY
38654: LIST
38655: LIST
38656: PPUSH
38657: CALL_OW 72
38661: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
38662: LD_ADDR_VAR 0 10
38666: PUSH
38667: LD_EXP 69
38671: PUSH
38672: LD_VAR 0 2
38676: ARRAY
38677: PPUSH
38678: LD_INT 34
38680: PUSH
38681: LD_INT 31
38683: PUSH
38684: EMPTY
38685: LIST
38686: LIST
38687: PPUSH
38688: CALL_OW 72
38692: ST_TO_ADDR
// if not cts and not mcts then
38693: LD_VAR 0 9
38697: NOT
38698: PUSH
38699: LD_VAR 0 10
38703: NOT
38704: AND
38705: IFFALSE 38709
// continue ;
38707: GO 38524
// x := cts ;
38709: LD_ADDR_VAR 0 11
38713: PUSH
38714: LD_VAR 0 9
38718: ST_TO_ADDR
// if not x then
38719: LD_VAR 0 11
38723: NOT
38724: IFFALSE 38736
// x := mcts ;
38726: LD_ADDR_VAR 0 11
38730: PUSH
38731: LD_VAR 0 10
38735: ST_TO_ADDR
// if not x then
38736: LD_VAR 0 11
38740: NOT
38741: IFFALSE 38745
// continue ;
38743: GO 38524
// if mc_remote_driver [ i ] then
38745: LD_EXP 90
38749: PUSH
38750: LD_VAR 0 2
38754: ARRAY
38755: IFFALSE 39142
// for j in mc_remote_driver [ i ] do
38757: LD_ADDR_VAR 0 3
38761: PUSH
38762: LD_EXP 90
38766: PUSH
38767: LD_VAR 0 2
38771: ARRAY
38772: PUSH
38773: FOR_IN
38774: IFFALSE 39140
// begin if GetClass ( j ) <> 3 then
38776: LD_VAR 0 3
38780: PPUSH
38781: CALL_OW 257
38785: PUSH
38786: LD_INT 3
38788: NONEQUAL
38789: IFFALSE 38842
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
38791: LD_ADDR_EXP 90
38795: PUSH
38796: LD_EXP 90
38800: PPUSH
38801: LD_VAR 0 2
38805: PPUSH
38806: LD_EXP 90
38810: PUSH
38811: LD_VAR 0 2
38815: ARRAY
38816: PUSH
38817: LD_VAR 0 3
38821: DIFF
38822: PPUSH
38823: CALL_OW 1
38827: ST_TO_ADDR
// SetTag ( j , 0 ) ;
38828: LD_VAR 0 3
38832: PPUSH
38833: LD_INT 0
38835: PPUSH
38836: CALL_OW 109
// continue ;
38840: GO 38773
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
38842: LD_EXP 69
38846: PUSH
38847: LD_VAR 0 2
38851: ARRAY
38852: PPUSH
38853: LD_INT 34
38855: PUSH
38856: LD_INT 31
38858: PUSH
38859: EMPTY
38860: LIST
38861: LIST
38862: PUSH
38863: LD_INT 58
38865: PUSH
38866: EMPTY
38867: LIST
38868: PUSH
38869: EMPTY
38870: LIST
38871: LIST
38872: PPUSH
38873: CALL_OW 72
38877: PUSH
38878: LD_VAR 0 3
38882: PPUSH
38883: CALL 81000 0 1
38887: NOT
38888: AND
38889: IFFALSE 38960
// begin if IsInUnit ( j ) then
38891: LD_VAR 0 3
38895: PPUSH
38896: CALL_OW 310
38900: IFFALSE 38911
// ComExitBuilding ( j ) ;
38902: LD_VAR 0 3
38906: PPUSH
38907: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
38911: LD_VAR 0 3
38915: PPUSH
38916: LD_EXP 69
38920: PUSH
38921: LD_VAR 0 2
38925: ARRAY
38926: PPUSH
38927: LD_INT 34
38929: PUSH
38930: LD_INT 31
38932: PUSH
38933: EMPTY
38934: LIST
38935: LIST
38936: PUSH
38937: LD_INT 58
38939: PUSH
38940: EMPTY
38941: LIST
38942: PUSH
38943: EMPTY
38944: LIST
38945: LIST
38946: PPUSH
38947: CALL_OW 72
38951: PUSH
38952: LD_INT 1
38954: ARRAY
38955: PPUSH
38956: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
38960: LD_VAR 0 3
38964: PPUSH
38965: CALL_OW 310
38969: NOT
38970: PUSH
38971: LD_VAR 0 3
38975: PPUSH
38976: CALL_OW 310
38980: PPUSH
38981: CALL_OW 266
38985: PUSH
38986: LD_INT 36
38988: NONEQUAL
38989: PUSH
38990: LD_VAR 0 3
38994: PPUSH
38995: CALL 81000 0 1
38999: NOT
39000: AND
39001: OR
39002: IFFALSE 39138
// begin if IsInUnit ( j ) then
39004: LD_VAR 0 3
39008: PPUSH
39009: CALL_OW 310
39013: IFFALSE 39024
// ComExitBuilding ( j ) ;
39015: LD_VAR 0 3
39019: PPUSH
39020: CALL_OW 122
// ct := 0 ;
39024: LD_ADDR_VAR 0 8
39028: PUSH
39029: LD_INT 0
39031: ST_TO_ADDR
// for k in x do
39032: LD_ADDR_VAR 0 4
39036: PUSH
39037: LD_VAR 0 11
39041: PUSH
39042: FOR_IN
39043: IFFALSE 39116
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
39045: LD_VAR 0 4
39049: PPUSH
39050: CALL_OW 264
39054: PUSH
39055: LD_INT 31
39057: EQUAL
39058: PUSH
39059: LD_VAR 0 4
39063: PPUSH
39064: CALL_OW 311
39068: NOT
39069: AND
39070: PUSH
39071: LD_VAR 0 4
39075: PPUSH
39076: CALL_OW 266
39080: PUSH
39081: LD_INT 36
39083: EQUAL
39084: PUSH
39085: LD_VAR 0 4
39089: PPUSH
39090: CALL_OW 313
39094: PUSH
39095: LD_INT 3
39097: LESS
39098: AND
39099: OR
39100: IFFALSE 39114
// begin ct := k ;
39102: LD_ADDR_VAR 0 8
39106: PUSH
39107: LD_VAR 0 4
39111: ST_TO_ADDR
// break ;
39112: GO 39116
// end ;
39114: GO 39042
39116: POP
39117: POP
// if ct then
39118: LD_VAR 0 8
39122: IFFALSE 39138
// ComEnterUnit ( j , ct ) ;
39124: LD_VAR 0 3
39128: PPUSH
39129: LD_VAR 0 8
39133: PPUSH
39134: CALL_OW 120
// end ; end ;
39138: GO 38773
39140: POP
39141: POP
// places := 0 ;
39142: LD_ADDR_VAR 0 5
39146: PUSH
39147: LD_INT 0
39149: ST_TO_ADDR
// for j = 1 to x do
39150: LD_ADDR_VAR 0 3
39154: PUSH
39155: DOUBLE
39156: LD_INT 1
39158: DEC
39159: ST_TO_ADDR
39160: LD_VAR 0 11
39164: PUSH
39165: FOR_TO
39166: IFFALSE 39242
// if GetWeapon ( x [ j ] ) = ar_control_tower then
39168: LD_VAR 0 11
39172: PUSH
39173: LD_VAR 0 3
39177: ARRAY
39178: PPUSH
39179: CALL_OW 264
39183: PUSH
39184: LD_INT 31
39186: EQUAL
39187: IFFALSE 39205
// places := places + 1 else
39189: LD_ADDR_VAR 0 5
39193: PUSH
39194: LD_VAR 0 5
39198: PUSH
39199: LD_INT 1
39201: PLUS
39202: ST_TO_ADDR
39203: GO 39240
// if GetBType ( x [ j ] ) = b_control_tower then
39205: LD_VAR 0 11
39209: PUSH
39210: LD_VAR 0 3
39214: ARRAY
39215: PPUSH
39216: CALL_OW 266
39220: PUSH
39221: LD_INT 36
39223: EQUAL
39224: IFFALSE 39240
// places := places + 3 ;
39226: LD_ADDR_VAR 0 5
39230: PUSH
39231: LD_VAR 0 5
39235: PUSH
39236: LD_INT 3
39238: PLUS
39239: ST_TO_ADDR
39240: GO 39165
39242: POP
39243: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
39244: LD_VAR 0 5
39248: PUSH
39249: LD_INT 0
39251: EQUAL
39252: PUSH
39253: LD_VAR 0 5
39257: PUSH
39258: LD_EXP 90
39262: PUSH
39263: LD_VAR 0 2
39267: ARRAY
39268: LESSEQUAL
39269: OR
39270: IFFALSE 39274
// continue ;
39272: GO 38524
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
39274: LD_ADDR_VAR 0 6
39278: PUSH
39279: LD_EXP 50
39283: PUSH
39284: LD_VAR 0 2
39288: ARRAY
39289: PPUSH
39290: LD_INT 25
39292: PUSH
39293: LD_INT 3
39295: PUSH
39296: EMPTY
39297: LIST
39298: LIST
39299: PPUSH
39300: CALL_OW 72
39304: PUSH
39305: LD_EXP 90
39309: PUSH
39310: LD_VAR 0 2
39314: ARRAY
39315: DIFF
39316: PPUSH
39317: LD_INT 3
39319: PPUSH
39320: CALL 81900 0 2
39324: ST_TO_ADDR
// for j in tmp do
39325: LD_ADDR_VAR 0 3
39329: PUSH
39330: LD_VAR 0 6
39334: PUSH
39335: FOR_IN
39336: IFFALSE 39371
// if GetTag ( j ) > 0 then
39338: LD_VAR 0 3
39342: PPUSH
39343: CALL_OW 110
39347: PUSH
39348: LD_INT 0
39350: GREATER
39351: IFFALSE 39369
// tmp := tmp diff j ;
39353: LD_ADDR_VAR 0 6
39357: PUSH
39358: LD_VAR 0 6
39362: PUSH
39363: LD_VAR 0 3
39367: DIFF
39368: ST_TO_ADDR
39369: GO 39335
39371: POP
39372: POP
// if not tmp then
39373: LD_VAR 0 6
39377: NOT
39378: IFFALSE 39382
// continue ;
39380: GO 38524
// if places then
39382: LD_VAR 0 5
39386: IFFALSE 39445
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
39388: LD_ADDR_EXP 90
39392: PUSH
39393: LD_EXP 90
39397: PPUSH
39398: LD_VAR 0 2
39402: PPUSH
39403: LD_EXP 90
39407: PUSH
39408: LD_VAR 0 2
39412: ARRAY
39413: PUSH
39414: LD_VAR 0 6
39418: PUSH
39419: LD_INT 1
39421: ARRAY
39422: UNION
39423: PPUSH
39424: CALL_OW 1
39428: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
39429: LD_VAR 0 6
39433: PUSH
39434: LD_INT 1
39436: ARRAY
39437: PPUSH
39438: LD_INT 126
39440: PPUSH
39441: CALL_OW 109
// end ; end ;
39445: GO 38524
39447: POP
39448: POP
// end ;
39449: LD_VAR 0 1
39453: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
39454: LD_INT 0
39456: PPUSH
39457: PPUSH
39458: PPUSH
39459: PPUSH
39460: PPUSH
39461: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
39462: LD_VAR 0 1
39466: NOT
39467: PUSH
39468: LD_VAR 0 2
39472: NOT
39473: OR
39474: PUSH
39475: LD_VAR 0 3
39479: NOT
39480: OR
39481: PUSH
39482: LD_VAR 0 4
39486: PUSH
39487: LD_INT 1
39489: PUSH
39490: LD_INT 2
39492: PUSH
39493: LD_INT 3
39495: PUSH
39496: LD_INT 4
39498: PUSH
39499: LD_INT 5
39501: PUSH
39502: LD_INT 8
39504: PUSH
39505: LD_INT 9
39507: PUSH
39508: LD_INT 15
39510: PUSH
39511: LD_INT 16
39513: PUSH
39514: EMPTY
39515: LIST
39516: LIST
39517: LIST
39518: LIST
39519: LIST
39520: LIST
39521: LIST
39522: LIST
39523: LIST
39524: IN
39525: NOT
39526: OR
39527: IFFALSE 39531
// exit ;
39529: GO 40431
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
39531: LD_ADDR_VAR 0 2
39535: PUSH
39536: LD_VAR 0 2
39540: PPUSH
39541: LD_INT 21
39543: PUSH
39544: LD_INT 3
39546: PUSH
39547: EMPTY
39548: LIST
39549: LIST
39550: PUSH
39551: LD_INT 24
39553: PUSH
39554: LD_INT 250
39556: PUSH
39557: EMPTY
39558: LIST
39559: LIST
39560: PUSH
39561: EMPTY
39562: LIST
39563: LIST
39564: PPUSH
39565: CALL_OW 72
39569: ST_TO_ADDR
// case class of 1 , 15 :
39570: LD_VAR 0 4
39574: PUSH
39575: LD_INT 1
39577: DOUBLE
39578: EQUAL
39579: IFTRUE 39589
39581: LD_INT 15
39583: DOUBLE
39584: EQUAL
39585: IFTRUE 39589
39587: GO 39674
39589: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
39590: LD_ADDR_VAR 0 8
39594: PUSH
39595: LD_VAR 0 2
39599: PPUSH
39600: LD_INT 2
39602: PUSH
39603: LD_INT 30
39605: PUSH
39606: LD_INT 32
39608: PUSH
39609: EMPTY
39610: LIST
39611: LIST
39612: PUSH
39613: LD_INT 30
39615: PUSH
39616: LD_INT 31
39618: PUSH
39619: EMPTY
39620: LIST
39621: LIST
39622: PUSH
39623: EMPTY
39624: LIST
39625: LIST
39626: LIST
39627: PPUSH
39628: CALL_OW 72
39632: PUSH
39633: LD_VAR 0 2
39637: PPUSH
39638: LD_INT 2
39640: PUSH
39641: LD_INT 30
39643: PUSH
39644: LD_INT 4
39646: PUSH
39647: EMPTY
39648: LIST
39649: LIST
39650: PUSH
39651: LD_INT 30
39653: PUSH
39654: LD_INT 5
39656: PUSH
39657: EMPTY
39658: LIST
39659: LIST
39660: PUSH
39661: EMPTY
39662: LIST
39663: LIST
39664: LIST
39665: PPUSH
39666: CALL_OW 72
39670: ADD
39671: ST_TO_ADDR
39672: GO 39920
39674: LD_INT 2
39676: DOUBLE
39677: EQUAL
39678: IFTRUE 39688
39680: LD_INT 16
39682: DOUBLE
39683: EQUAL
39684: IFTRUE 39688
39686: GO 39734
39688: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
39689: LD_ADDR_VAR 0 8
39693: PUSH
39694: LD_VAR 0 2
39698: PPUSH
39699: LD_INT 2
39701: PUSH
39702: LD_INT 30
39704: PUSH
39705: LD_INT 0
39707: PUSH
39708: EMPTY
39709: LIST
39710: LIST
39711: PUSH
39712: LD_INT 30
39714: PUSH
39715: LD_INT 1
39717: PUSH
39718: EMPTY
39719: LIST
39720: LIST
39721: PUSH
39722: EMPTY
39723: LIST
39724: LIST
39725: LIST
39726: PPUSH
39727: CALL_OW 72
39731: ST_TO_ADDR
39732: GO 39920
39734: LD_INT 3
39736: DOUBLE
39737: EQUAL
39738: IFTRUE 39742
39740: GO 39788
39742: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
39743: LD_ADDR_VAR 0 8
39747: PUSH
39748: LD_VAR 0 2
39752: PPUSH
39753: LD_INT 2
39755: PUSH
39756: LD_INT 30
39758: PUSH
39759: LD_INT 2
39761: PUSH
39762: EMPTY
39763: LIST
39764: LIST
39765: PUSH
39766: LD_INT 30
39768: PUSH
39769: LD_INT 3
39771: PUSH
39772: EMPTY
39773: LIST
39774: LIST
39775: PUSH
39776: EMPTY
39777: LIST
39778: LIST
39779: LIST
39780: PPUSH
39781: CALL_OW 72
39785: ST_TO_ADDR
39786: GO 39920
39788: LD_INT 4
39790: DOUBLE
39791: EQUAL
39792: IFTRUE 39796
39794: GO 39853
39796: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
39797: LD_ADDR_VAR 0 8
39801: PUSH
39802: LD_VAR 0 2
39806: PPUSH
39807: LD_INT 2
39809: PUSH
39810: LD_INT 30
39812: PUSH
39813: LD_INT 6
39815: PUSH
39816: EMPTY
39817: LIST
39818: LIST
39819: PUSH
39820: LD_INT 30
39822: PUSH
39823: LD_INT 7
39825: PUSH
39826: EMPTY
39827: LIST
39828: LIST
39829: PUSH
39830: LD_INT 30
39832: PUSH
39833: LD_INT 8
39835: PUSH
39836: EMPTY
39837: LIST
39838: LIST
39839: PUSH
39840: EMPTY
39841: LIST
39842: LIST
39843: LIST
39844: LIST
39845: PPUSH
39846: CALL_OW 72
39850: ST_TO_ADDR
39851: GO 39920
39853: LD_INT 5
39855: DOUBLE
39856: EQUAL
39857: IFTRUE 39873
39859: LD_INT 8
39861: DOUBLE
39862: EQUAL
39863: IFTRUE 39873
39865: LD_INT 9
39867: DOUBLE
39868: EQUAL
39869: IFTRUE 39873
39871: GO 39919
39873: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
39874: LD_ADDR_VAR 0 8
39878: PUSH
39879: LD_VAR 0 2
39883: PPUSH
39884: LD_INT 2
39886: PUSH
39887: LD_INT 30
39889: PUSH
39890: LD_INT 4
39892: PUSH
39893: EMPTY
39894: LIST
39895: LIST
39896: PUSH
39897: LD_INT 30
39899: PUSH
39900: LD_INT 5
39902: PUSH
39903: EMPTY
39904: LIST
39905: LIST
39906: PUSH
39907: EMPTY
39908: LIST
39909: LIST
39910: LIST
39911: PPUSH
39912: CALL_OW 72
39916: ST_TO_ADDR
39917: GO 39920
39919: POP
// if not tmp then
39920: LD_VAR 0 8
39924: NOT
39925: IFFALSE 39929
// exit ;
39927: GO 40431
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
39929: LD_VAR 0 4
39933: PUSH
39934: LD_INT 1
39936: PUSH
39937: LD_INT 15
39939: PUSH
39940: EMPTY
39941: LIST
39942: LIST
39943: IN
39944: PUSH
39945: LD_EXP 59
39949: PUSH
39950: LD_VAR 0 1
39954: ARRAY
39955: AND
39956: IFFALSE 40112
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
39958: LD_ADDR_VAR 0 9
39962: PUSH
39963: LD_EXP 59
39967: PUSH
39968: LD_VAR 0 1
39972: ARRAY
39973: PUSH
39974: LD_INT 1
39976: ARRAY
39977: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
39978: LD_VAR 0 9
39982: PUSH
39983: LD_EXP 60
39987: PUSH
39988: LD_VAR 0 1
39992: ARRAY
39993: IN
39994: NOT
39995: IFFALSE 40110
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
39997: LD_ADDR_EXP 60
40001: PUSH
40002: LD_EXP 60
40006: PPUSH
40007: LD_VAR 0 1
40011: PUSH
40012: LD_EXP 60
40016: PUSH
40017: LD_VAR 0 1
40021: ARRAY
40022: PUSH
40023: LD_INT 1
40025: PLUS
40026: PUSH
40027: EMPTY
40028: LIST
40029: LIST
40030: PPUSH
40031: LD_VAR 0 9
40035: PPUSH
40036: CALL 52351 0 3
40040: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
40041: LD_ADDR_EXP 59
40045: PUSH
40046: LD_EXP 59
40050: PPUSH
40051: LD_VAR 0 1
40055: PPUSH
40056: LD_EXP 59
40060: PUSH
40061: LD_VAR 0 1
40065: ARRAY
40066: PUSH
40067: LD_VAR 0 9
40071: DIFF
40072: PPUSH
40073: CALL_OW 1
40077: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
40078: LD_VAR 0 3
40082: PPUSH
40083: LD_EXP 60
40087: PUSH
40088: LD_VAR 0 1
40092: ARRAY
40093: PUSH
40094: LD_EXP 60
40098: PUSH
40099: LD_VAR 0 1
40103: ARRAY
40104: ARRAY
40105: PPUSH
40106: CALL_OW 120
// end ; exit ;
40110: GO 40431
// end ; if tmp > 1 then
40112: LD_VAR 0 8
40116: PUSH
40117: LD_INT 1
40119: GREATER
40120: IFFALSE 40224
// for i = 2 to tmp do
40122: LD_ADDR_VAR 0 6
40126: PUSH
40127: DOUBLE
40128: LD_INT 2
40130: DEC
40131: ST_TO_ADDR
40132: LD_VAR 0 8
40136: PUSH
40137: FOR_TO
40138: IFFALSE 40222
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
40140: LD_VAR 0 8
40144: PUSH
40145: LD_VAR 0 6
40149: ARRAY
40150: PPUSH
40151: CALL_OW 461
40155: PUSH
40156: LD_INT 6
40158: EQUAL
40159: IFFALSE 40220
// begin x := tmp [ i ] ;
40161: LD_ADDR_VAR 0 9
40165: PUSH
40166: LD_VAR 0 8
40170: PUSH
40171: LD_VAR 0 6
40175: ARRAY
40176: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
40177: LD_ADDR_VAR 0 8
40181: PUSH
40182: LD_VAR 0 8
40186: PPUSH
40187: LD_VAR 0 6
40191: PPUSH
40192: CALL_OW 3
40196: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
40197: LD_ADDR_VAR 0 8
40201: PUSH
40202: LD_VAR 0 8
40206: PPUSH
40207: LD_INT 1
40209: PPUSH
40210: LD_VAR 0 9
40214: PPUSH
40215: CALL_OW 2
40219: ST_TO_ADDR
// end ;
40220: GO 40137
40222: POP
40223: POP
// for i in tmp do
40224: LD_ADDR_VAR 0 6
40228: PUSH
40229: LD_VAR 0 8
40233: PUSH
40234: FOR_IN
40235: IFFALSE 40304
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
40237: LD_VAR 0 6
40241: PPUSH
40242: CALL_OW 313
40246: PUSH
40247: LD_INT 6
40249: LESS
40250: PUSH
40251: LD_VAR 0 6
40255: PPUSH
40256: CALL_OW 266
40260: PUSH
40261: LD_INT 31
40263: PUSH
40264: LD_INT 32
40266: PUSH
40267: EMPTY
40268: LIST
40269: LIST
40270: IN
40271: NOT
40272: AND
40273: PUSH
40274: LD_VAR 0 6
40278: PPUSH
40279: CALL_OW 313
40283: PUSH
40284: LD_INT 0
40286: EQUAL
40287: OR
40288: IFFALSE 40302
// begin j := i ;
40290: LD_ADDR_VAR 0 7
40294: PUSH
40295: LD_VAR 0 6
40299: ST_TO_ADDR
// break ;
40300: GO 40304
// end ; end ;
40302: GO 40234
40304: POP
40305: POP
// if j then
40306: LD_VAR 0 7
40310: IFFALSE 40328
// ComEnterUnit ( unit , j ) else
40312: LD_VAR 0 3
40316: PPUSH
40317: LD_VAR 0 7
40321: PPUSH
40322: CALL_OW 120
40326: GO 40431
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
40328: LD_ADDR_VAR 0 10
40332: PUSH
40333: LD_VAR 0 2
40337: PPUSH
40338: LD_INT 2
40340: PUSH
40341: LD_INT 30
40343: PUSH
40344: LD_INT 0
40346: PUSH
40347: EMPTY
40348: LIST
40349: LIST
40350: PUSH
40351: LD_INT 30
40353: PUSH
40354: LD_INT 1
40356: PUSH
40357: EMPTY
40358: LIST
40359: LIST
40360: PUSH
40361: EMPTY
40362: LIST
40363: LIST
40364: LIST
40365: PPUSH
40366: CALL_OW 72
40370: ST_TO_ADDR
// if depot then
40371: LD_VAR 0 10
40375: IFFALSE 40431
// begin depot := NearestUnitToUnit ( depot , unit ) ;
40377: LD_ADDR_VAR 0 10
40381: PUSH
40382: LD_VAR 0 10
40386: PPUSH
40387: LD_VAR 0 3
40391: PPUSH
40392: CALL_OW 74
40396: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
40397: LD_VAR 0 3
40401: PPUSH
40402: LD_VAR 0 10
40406: PPUSH
40407: CALL_OW 296
40411: PUSH
40412: LD_INT 10
40414: GREATER
40415: IFFALSE 40431
// ComStandNearbyBuilding ( unit , depot ) ;
40417: LD_VAR 0 3
40421: PPUSH
40422: LD_VAR 0 10
40426: PPUSH
40427: CALL 48965 0 2
// end ; end ; end ;
40431: LD_VAR 0 5
40435: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
40436: LD_INT 0
40438: PPUSH
40439: PPUSH
40440: PPUSH
40441: PPUSH
// if not mc_bases then
40442: LD_EXP 50
40446: NOT
40447: IFFALSE 40451
// exit ;
40449: GO 40690
// for i = 1 to mc_bases do
40451: LD_ADDR_VAR 0 2
40455: PUSH
40456: DOUBLE
40457: LD_INT 1
40459: DEC
40460: ST_TO_ADDR
40461: LD_EXP 50
40465: PUSH
40466: FOR_TO
40467: IFFALSE 40688
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
40469: LD_ADDR_VAR 0 4
40473: PUSH
40474: LD_EXP 50
40478: PUSH
40479: LD_VAR 0 2
40483: ARRAY
40484: PPUSH
40485: LD_INT 21
40487: PUSH
40488: LD_INT 1
40490: PUSH
40491: EMPTY
40492: LIST
40493: LIST
40494: PPUSH
40495: CALL_OW 72
40499: PUSH
40500: LD_EXP 79
40504: PUSH
40505: LD_VAR 0 2
40509: ARRAY
40510: UNION
40511: ST_TO_ADDR
// if not tmp then
40512: LD_VAR 0 4
40516: NOT
40517: IFFALSE 40521
// continue ;
40519: GO 40466
// for j in tmp do
40521: LD_ADDR_VAR 0 3
40525: PUSH
40526: LD_VAR 0 4
40530: PUSH
40531: FOR_IN
40532: IFFALSE 40684
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
40534: LD_VAR 0 3
40538: PPUSH
40539: CALL_OW 110
40543: NOT
40544: PUSH
40545: LD_VAR 0 3
40549: PPUSH
40550: CALL_OW 314
40554: NOT
40555: AND
40556: PUSH
40557: LD_VAR 0 3
40561: PPUSH
40562: CALL_OW 311
40566: NOT
40567: AND
40568: PUSH
40569: LD_VAR 0 3
40573: PPUSH
40574: CALL_OW 310
40578: NOT
40579: AND
40580: PUSH
40581: LD_VAR 0 3
40585: PUSH
40586: LD_EXP 53
40590: PUSH
40591: LD_VAR 0 2
40595: ARRAY
40596: PUSH
40597: LD_INT 1
40599: ARRAY
40600: IN
40601: NOT
40602: AND
40603: PUSH
40604: LD_VAR 0 3
40608: PUSH
40609: LD_EXP 53
40613: PUSH
40614: LD_VAR 0 2
40618: ARRAY
40619: PUSH
40620: LD_INT 2
40622: ARRAY
40623: IN
40624: NOT
40625: AND
40626: PUSH
40627: LD_VAR 0 3
40631: PUSH
40632: LD_EXP 62
40636: PUSH
40637: LD_VAR 0 2
40641: ARRAY
40642: IN
40643: NOT
40644: AND
40645: IFFALSE 40682
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
40647: LD_VAR 0 2
40651: PPUSH
40652: LD_EXP 50
40656: PUSH
40657: LD_VAR 0 2
40661: ARRAY
40662: PPUSH
40663: LD_VAR 0 3
40667: PPUSH
40668: LD_VAR 0 3
40672: PPUSH
40673: CALL_OW 257
40677: PPUSH
40678: CALL 39454 0 4
// end ;
40682: GO 40531
40684: POP
40685: POP
// end ;
40686: GO 40466
40688: POP
40689: POP
// end ;
40690: LD_VAR 0 1
40694: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
40695: LD_INT 0
40697: PPUSH
40698: PPUSH
40699: PPUSH
40700: PPUSH
40701: PPUSH
40702: PPUSH
// if not mc_bases [ base ] then
40703: LD_EXP 50
40707: PUSH
40708: LD_VAR 0 1
40712: ARRAY
40713: NOT
40714: IFFALSE 40718
// exit ;
40716: GO 40900
// tmp := [ ] ;
40718: LD_ADDR_VAR 0 6
40722: PUSH
40723: EMPTY
40724: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
40725: LD_ADDR_VAR 0 7
40729: PUSH
40730: LD_VAR 0 3
40734: PPUSH
40735: LD_INT 0
40737: PPUSH
40738: CALL_OW 517
40742: ST_TO_ADDR
// if not list then
40743: LD_VAR 0 7
40747: NOT
40748: IFFALSE 40752
// exit ;
40750: GO 40900
// for i = 1 to amount do
40752: LD_ADDR_VAR 0 5
40756: PUSH
40757: DOUBLE
40758: LD_INT 1
40760: DEC
40761: ST_TO_ADDR
40762: LD_VAR 0 2
40766: PUSH
40767: FOR_TO
40768: IFFALSE 40848
// begin x := rand ( 1 , list [ 1 ] ) ;
40770: LD_ADDR_VAR 0 8
40774: PUSH
40775: LD_INT 1
40777: PPUSH
40778: LD_VAR 0 7
40782: PUSH
40783: LD_INT 1
40785: ARRAY
40786: PPUSH
40787: CALL_OW 12
40791: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
40792: LD_ADDR_VAR 0 6
40796: PUSH
40797: LD_VAR 0 6
40801: PPUSH
40802: LD_VAR 0 5
40806: PPUSH
40807: LD_VAR 0 7
40811: PUSH
40812: LD_INT 1
40814: ARRAY
40815: PUSH
40816: LD_VAR 0 8
40820: ARRAY
40821: PUSH
40822: LD_VAR 0 7
40826: PUSH
40827: LD_INT 2
40829: ARRAY
40830: PUSH
40831: LD_VAR 0 8
40835: ARRAY
40836: PUSH
40837: EMPTY
40838: LIST
40839: LIST
40840: PPUSH
40841: CALL_OW 1
40845: ST_TO_ADDR
// end ;
40846: GO 40767
40848: POP
40849: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
40850: LD_ADDR_EXP 63
40854: PUSH
40855: LD_EXP 63
40859: PPUSH
40860: LD_VAR 0 1
40864: PPUSH
40865: LD_VAR 0 6
40869: PPUSH
40870: CALL_OW 1
40874: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
40875: LD_ADDR_EXP 65
40879: PUSH
40880: LD_EXP 65
40884: PPUSH
40885: LD_VAR 0 1
40889: PPUSH
40890: LD_VAR 0 3
40894: PPUSH
40895: CALL_OW 1
40899: ST_TO_ADDR
// end ;
40900: LD_VAR 0 4
40904: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
40905: LD_INT 0
40907: PPUSH
// if not mc_bases [ base ] then
40908: LD_EXP 50
40912: PUSH
40913: LD_VAR 0 1
40917: ARRAY
40918: NOT
40919: IFFALSE 40923
// exit ;
40921: GO 40948
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
40923: LD_ADDR_EXP 55
40927: PUSH
40928: LD_EXP 55
40932: PPUSH
40933: LD_VAR 0 1
40937: PPUSH
40938: LD_VAR 0 2
40942: PPUSH
40943: CALL_OW 1
40947: ST_TO_ADDR
// end ;
40948: LD_VAR 0 3
40952: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
40953: LD_INT 0
40955: PPUSH
// if not mc_bases [ base ] then
40956: LD_EXP 50
40960: PUSH
40961: LD_VAR 0 1
40965: ARRAY
40966: NOT
40967: IFFALSE 40971
// exit ;
40969: GO 41008
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
40971: LD_ADDR_EXP 55
40975: PUSH
40976: LD_EXP 55
40980: PPUSH
40981: LD_VAR 0 1
40985: PPUSH
40986: LD_EXP 55
40990: PUSH
40991: LD_VAR 0 1
40995: ARRAY
40996: PUSH
40997: LD_VAR 0 2
41001: UNION
41002: PPUSH
41003: CALL_OW 1
41007: ST_TO_ADDR
// end ;
41008: LD_VAR 0 3
41012: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
41013: LD_INT 0
41015: PPUSH
// if not mc_bases [ base ] then
41016: LD_EXP 50
41020: PUSH
41021: LD_VAR 0 1
41025: ARRAY
41026: NOT
41027: IFFALSE 41031
// exit ;
41029: GO 41056
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
41031: LD_ADDR_EXP 71
41035: PUSH
41036: LD_EXP 71
41040: PPUSH
41041: LD_VAR 0 1
41045: PPUSH
41046: LD_VAR 0 2
41050: PPUSH
41051: CALL_OW 1
41055: ST_TO_ADDR
// end ;
41056: LD_VAR 0 3
41060: RET
// export function MC_InsertProduceList ( base , components ) ; begin
41061: LD_INT 0
41063: PPUSH
// if not mc_bases [ base ] then
41064: LD_EXP 50
41068: PUSH
41069: LD_VAR 0 1
41073: ARRAY
41074: NOT
41075: IFFALSE 41079
// exit ;
41077: GO 41116
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
41079: LD_ADDR_EXP 71
41083: PUSH
41084: LD_EXP 71
41088: PPUSH
41089: LD_VAR 0 1
41093: PPUSH
41094: LD_EXP 71
41098: PUSH
41099: LD_VAR 0 1
41103: ARRAY
41104: PUSH
41105: LD_VAR 0 2
41109: ADD
41110: PPUSH
41111: CALL_OW 1
41115: ST_TO_ADDR
// end ;
41116: LD_VAR 0 3
41120: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
41121: LD_INT 0
41123: PPUSH
// if not mc_bases [ base ] then
41124: LD_EXP 50
41128: PUSH
41129: LD_VAR 0 1
41133: ARRAY
41134: NOT
41135: IFFALSE 41139
// exit ;
41137: GO 41193
// mc_defender := Replace ( mc_defender , base , deflist ) ;
41139: LD_ADDR_EXP 72
41143: PUSH
41144: LD_EXP 72
41148: PPUSH
41149: LD_VAR 0 1
41153: PPUSH
41154: LD_VAR 0 2
41158: PPUSH
41159: CALL_OW 1
41163: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
41164: LD_ADDR_EXP 61
41168: PUSH
41169: LD_EXP 61
41173: PPUSH
41174: LD_VAR 0 1
41178: PPUSH
41179: LD_VAR 0 2
41183: PUSH
41184: LD_INT 0
41186: PLUS
41187: PPUSH
41188: CALL_OW 1
41192: ST_TO_ADDR
// end ;
41193: LD_VAR 0 3
41197: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
41198: LD_INT 0
41200: PPUSH
// if not mc_bases [ base ] then
41201: LD_EXP 50
41205: PUSH
41206: LD_VAR 0 1
41210: ARRAY
41211: NOT
41212: IFFALSE 41216
// exit ;
41214: GO 41241
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
41216: LD_ADDR_EXP 61
41220: PUSH
41221: LD_EXP 61
41225: PPUSH
41226: LD_VAR 0 1
41230: PPUSH
41231: LD_VAR 0 2
41235: PPUSH
41236: CALL_OW 1
41240: ST_TO_ADDR
// end ;
41241: LD_VAR 0 3
41245: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
41246: LD_INT 0
41248: PPUSH
41249: PPUSH
41250: PPUSH
41251: PPUSH
// if not mc_bases [ base ] then
41252: LD_EXP 50
41256: PUSH
41257: LD_VAR 0 1
41261: ARRAY
41262: NOT
41263: IFFALSE 41267
// exit ;
41265: GO 41332
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
41267: LD_ADDR_EXP 70
41271: PUSH
41272: LD_EXP 70
41276: PPUSH
41277: LD_VAR 0 1
41281: PUSH
41282: LD_EXP 70
41286: PUSH
41287: LD_VAR 0 1
41291: ARRAY
41292: PUSH
41293: LD_INT 1
41295: PLUS
41296: PUSH
41297: EMPTY
41298: LIST
41299: LIST
41300: PPUSH
41301: LD_VAR 0 1
41305: PUSH
41306: LD_VAR 0 2
41310: PUSH
41311: LD_VAR 0 3
41315: PUSH
41316: LD_VAR 0 4
41320: PUSH
41321: EMPTY
41322: LIST
41323: LIST
41324: LIST
41325: LIST
41326: PPUSH
41327: CALL 52351 0 3
41331: ST_TO_ADDR
// end ;
41332: LD_VAR 0 5
41336: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
41337: LD_INT 0
41339: PPUSH
// if not mc_bases [ base ] then
41340: LD_EXP 50
41344: PUSH
41345: LD_VAR 0 1
41349: ARRAY
41350: NOT
41351: IFFALSE 41355
// exit ;
41353: GO 41380
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
41355: LD_ADDR_EXP 87
41359: PUSH
41360: LD_EXP 87
41364: PPUSH
41365: LD_VAR 0 1
41369: PPUSH
41370: LD_VAR 0 2
41374: PPUSH
41375: CALL_OW 1
41379: ST_TO_ADDR
// end ;
41380: LD_VAR 0 3
41384: RET
// export function MC_GetMinesField ( base ) ; begin
41385: LD_INT 0
41387: PPUSH
// result := mc_mines [ base ] ;
41388: LD_ADDR_VAR 0 2
41392: PUSH
41393: LD_EXP 63
41397: PUSH
41398: LD_VAR 0 1
41402: ARRAY
41403: ST_TO_ADDR
// end ;
41404: LD_VAR 0 2
41408: RET
// export function MC_GetProduceList ( base ) ; begin
41409: LD_INT 0
41411: PPUSH
// result := mc_produce [ base ] ;
41412: LD_ADDR_VAR 0 2
41416: PUSH
41417: LD_EXP 71
41421: PUSH
41422: LD_VAR 0 1
41426: ARRAY
41427: ST_TO_ADDR
// end ;
41428: LD_VAR 0 2
41432: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
41433: LD_INT 0
41435: PPUSH
41436: PPUSH
// if not mc_bases then
41437: LD_EXP 50
41441: NOT
41442: IFFALSE 41446
// exit ;
41444: GO 41511
// if mc_bases [ base ] then
41446: LD_EXP 50
41450: PUSH
41451: LD_VAR 0 1
41455: ARRAY
41456: IFFALSE 41511
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
41458: LD_ADDR_VAR 0 3
41462: PUSH
41463: LD_EXP 50
41467: PUSH
41468: LD_VAR 0 1
41472: ARRAY
41473: PPUSH
41474: LD_INT 30
41476: PUSH
41477: LD_VAR 0 2
41481: PUSH
41482: EMPTY
41483: LIST
41484: LIST
41485: PPUSH
41486: CALL_OW 72
41490: ST_TO_ADDR
// if result then
41491: LD_VAR 0 3
41495: IFFALSE 41511
// result := result [ 1 ] ;
41497: LD_ADDR_VAR 0 3
41501: PUSH
41502: LD_VAR 0 3
41506: PUSH
41507: LD_INT 1
41509: ARRAY
41510: ST_TO_ADDR
// end ; end ;
41511: LD_VAR 0 3
41515: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
41516: LD_INT 0
41518: PPUSH
41519: PPUSH
// if not mc_bases then
41520: LD_EXP 50
41524: NOT
41525: IFFALSE 41529
// exit ;
41527: GO 41574
// if mc_bases [ base ] then
41529: LD_EXP 50
41533: PUSH
41534: LD_VAR 0 1
41538: ARRAY
41539: IFFALSE 41574
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
41541: LD_ADDR_VAR 0 3
41545: PUSH
41546: LD_EXP 50
41550: PUSH
41551: LD_VAR 0 1
41555: ARRAY
41556: PPUSH
41557: LD_INT 30
41559: PUSH
41560: LD_VAR 0 2
41564: PUSH
41565: EMPTY
41566: LIST
41567: LIST
41568: PPUSH
41569: CALL_OW 72
41573: ST_TO_ADDR
// end ;
41574: LD_VAR 0 3
41578: RET
// export function MC_SetTame ( base , area ) ; begin
41579: LD_INT 0
41581: PPUSH
// if not mc_bases or not base then
41582: LD_EXP 50
41586: NOT
41587: PUSH
41588: LD_VAR 0 1
41592: NOT
41593: OR
41594: IFFALSE 41598
// exit ;
41596: GO 41623
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
41598: LD_ADDR_EXP 78
41602: PUSH
41603: LD_EXP 78
41607: PPUSH
41608: LD_VAR 0 1
41612: PPUSH
41613: LD_VAR 0 2
41617: PPUSH
41618: CALL_OW 1
41622: ST_TO_ADDR
// end ;
41623: LD_VAR 0 3
41627: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
41628: LD_INT 0
41630: PPUSH
41631: PPUSH
// if not mc_bases or not base then
41632: LD_EXP 50
41636: NOT
41637: PUSH
41638: LD_VAR 0 1
41642: NOT
41643: OR
41644: IFFALSE 41648
// exit ;
41646: GO 41750
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
41648: LD_ADDR_VAR 0 4
41652: PUSH
41653: LD_EXP 50
41657: PUSH
41658: LD_VAR 0 1
41662: ARRAY
41663: PPUSH
41664: LD_INT 30
41666: PUSH
41667: LD_VAR 0 2
41671: PUSH
41672: EMPTY
41673: LIST
41674: LIST
41675: PPUSH
41676: CALL_OW 72
41680: ST_TO_ADDR
// if not tmp then
41681: LD_VAR 0 4
41685: NOT
41686: IFFALSE 41690
// exit ;
41688: GO 41750
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
41690: LD_ADDR_EXP 82
41694: PUSH
41695: LD_EXP 82
41699: PPUSH
41700: LD_VAR 0 1
41704: PPUSH
41705: LD_EXP 82
41709: PUSH
41710: LD_VAR 0 1
41714: ARRAY
41715: PPUSH
41716: LD_EXP 82
41720: PUSH
41721: LD_VAR 0 1
41725: ARRAY
41726: PUSH
41727: LD_INT 1
41729: PLUS
41730: PPUSH
41731: LD_VAR 0 4
41735: PUSH
41736: LD_INT 1
41738: ARRAY
41739: PPUSH
41740: CALL_OW 2
41744: PPUSH
41745: CALL_OW 1
41749: ST_TO_ADDR
// end ;
41750: LD_VAR 0 3
41754: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
41755: LD_INT 0
41757: PPUSH
41758: PPUSH
// if not mc_bases or not base or not kinds then
41759: LD_EXP 50
41763: NOT
41764: PUSH
41765: LD_VAR 0 1
41769: NOT
41770: OR
41771: PUSH
41772: LD_VAR 0 2
41776: NOT
41777: OR
41778: IFFALSE 41782
// exit ;
41780: GO 41843
// for i in kinds do
41782: LD_ADDR_VAR 0 4
41786: PUSH
41787: LD_VAR 0 2
41791: PUSH
41792: FOR_IN
41793: IFFALSE 41841
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
41795: LD_ADDR_EXP 84
41799: PUSH
41800: LD_EXP 84
41804: PPUSH
41805: LD_VAR 0 1
41809: PUSH
41810: LD_EXP 84
41814: PUSH
41815: LD_VAR 0 1
41819: ARRAY
41820: PUSH
41821: LD_INT 1
41823: PLUS
41824: PUSH
41825: EMPTY
41826: LIST
41827: LIST
41828: PPUSH
41829: LD_VAR 0 4
41833: PPUSH
41834: CALL 52351 0 3
41838: ST_TO_ADDR
41839: GO 41792
41841: POP
41842: POP
// end ;
41843: LD_VAR 0 3
41847: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
41848: LD_INT 0
41850: PPUSH
// if not mc_bases or not base or not areas then
41851: LD_EXP 50
41855: NOT
41856: PUSH
41857: LD_VAR 0 1
41861: NOT
41862: OR
41863: PUSH
41864: LD_VAR 0 2
41868: NOT
41869: OR
41870: IFFALSE 41874
// exit ;
41872: GO 41899
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
41874: LD_ADDR_EXP 68
41878: PUSH
41879: LD_EXP 68
41883: PPUSH
41884: LD_VAR 0 1
41888: PPUSH
41889: LD_VAR 0 2
41893: PPUSH
41894: CALL_OW 1
41898: ST_TO_ADDR
// end ;
41899: LD_VAR 0 3
41903: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
41904: LD_INT 0
41906: PPUSH
// if not mc_bases or not base or not teleports_exit then
41907: LD_EXP 50
41911: NOT
41912: PUSH
41913: LD_VAR 0 1
41917: NOT
41918: OR
41919: PUSH
41920: LD_VAR 0 2
41924: NOT
41925: OR
41926: IFFALSE 41930
// exit ;
41928: GO 41955
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
41930: LD_ADDR_EXP 85
41934: PUSH
41935: LD_EXP 85
41939: PPUSH
41940: LD_VAR 0 1
41944: PPUSH
41945: LD_VAR 0 2
41949: PPUSH
41950: CALL_OW 1
41954: ST_TO_ADDR
// end ;
41955: LD_VAR 0 3
41959: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
41960: LD_INT 0
41962: PPUSH
41963: PPUSH
41964: PPUSH
// if not mc_bases or not base or not ext_list then
41965: LD_EXP 50
41969: NOT
41970: PUSH
41971: LD_VAR 0 1
41975: NOT
41976: OR
41977: PUSH
41978: LD_VAR 0 5
41982: NOT
41983: OR
41984: IFFALSE 41988
// exit ;
41986: GO 42161
// tmp := GetFacExtXYD ( x , y , d ) ;
41988: LD_ADDR_VAR 0 8
41992: PUSH
41993: LD_VAR 0 2
41997: PPUSH
41998: LD_VAR 0 3
42002: PPUSH
42003: LD_VAR 0 4
42007: PPUSH
42008: CALL 81030 0 3
42012: ST_TO_ADDR
// if not tmp then
42013: LD_VAR 0 8
42017: NOT
42018: IFFALSE 42022
// exit ;
42020: GO 42161
// for i in tmp do
42022: LD_ADDR_VAR 0 7
42026: PUSH
42027: LD_VAR 0 8
42031: PUSH
42032: FOR_IN
42033: IFFALSE 42159
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
42035: LD_ADDR_EXP 55
42039: PUSH
42040: LD_EXP 55
42044: PPUSH
42045: LD_VAR 0 1
42049: PPUSH
42050: LD_EXP 55
42054: PUSH
42055: LD_VAR 0 1
42059: ARRAY
42060: PPUSH
42061: LD_EXP 55
42065: PUSH
42066: LD_VAR 0 1
42070: ARRAY
42071: PUSH
42072: LD_INT 1
42074: PLUS
42075: PPUSH
42076: LD_VAR 0 5
42080: PUSH
42081: LD_INT 1
42083: ARRAY
42084: PUSH
42085: LD_VAR 0 7
42089: PUSH
42090: LD_INT 1
42092: ARRAY
42093: PUSH
42094: LD_VAR 0 7
42098: PUSH
42099: LD_INT 2
42101: ARRAY
42102: PUSH
42103: LD_VAR 0 7
42107: PUSH
42108: LD_INT 3
42110: ARRAY
42111: PUSH
42112: EMPTY
42113: LIST
42114: LIST
42115: LIST
42116: LIST
42117: PPUSH
42118: CALL_OW 2
42122: PPUSH
42123: CALL_OW 1
42127: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
42128: LD_ADDR_VAR 0 5
42132: PUSH
42133: LD_VAR 0 5
42137: PPUSH
42138: LD_INT 1
42140: PPUSH
42141: CALL_OW 3
42145: ST_TO_ADDR
// if not ext_list then
42146: LD_VAR 0 5
42150: NOT
42151: IFFALSE 42157
// exit ;
42153: POP
42154: POP
42155: GO 42161
// end ;
42157: GO 42032
42159: POP
42160: POP
// end ;
42161: LD_VAR 0 6
42165: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
42166: LD_INT 0
42168: PPUSH
// if not mc_bases or not base or not weapon_list then
42169: LD_EXP 50
42173: NOT
42174: PUSH
42175: LD_VAR 0 1
42179: NOT
42180: OR
42181: PUSH
42182: LD_VAR 0 2
42186: NOT
42187: OR
42188: IFFALSE 42192
// exit ;
42190: GO 42217
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
42192: LD_ADDR_EXP 89
42196: PUSH
42197: LD_EXP 89
42201: PPUSH
42202: LD_VAR 0 1
42206: PPUSH
42207: LD_VAR 0 2
42211: PPUSH
42212: CALL_OW 1
42216: ST_TO_ADDR
// end ;
42217: LD_VAR 0 3
42221: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
42222: LD_INT 0
42224: PPUSH
// if not mc_bases or not base or not tech_list then
42225: LD_EXP 50
42229: NOT
42230: PUSH
42231: LD_VAR 0 1
42235: NOT
42236: OR
42237: PUSH
42238: LD_VAR 0 2
42242: NOT
42243: OR
42244: IFFALSE 42248
// exit ;
42246: GO 42273
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
42248: LD_ADDR_EXP 77
42252: PUSH
42253: LD_EXP 77
42257: PPUSH
42258: LD_VAR 0 1
42262: PPUSH
42263: LD_VAR 0 2
42267: PPUSH
42268: CALL_OW 1
42272: ST_TO_ADDR
// end ;
42273: LD_VAR 0 3
42277: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
42278: LD_INT 0
42280: PPUSH
// if not mc_bases or not parking_area or not base then
42281: LD_EXP 50
42285: NOT
42286: PUSH
42287: LD_VAR 0 2
42291: NOT
42292: OR
42293: PUSH
42294: LD_VAR 0 1
42298: NOT
42299: OR
42300: IFFALSE 42304
// exit ;
42302: GO 42329
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
42304: LD_ADDR_EXP 74
42308: PUSH
42309: LD_EXP 74
42313: PPUSH
42314: LD_VAR 0 1
42318: PPUSH
42319: LD_VAR 0 2
42323: PPUSH
42324: CALL_OW 1
42328: ST_TO_ADDR
// end ;
42329: LD_VAR 0 3
42333: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
42334: LD_INT 0
42336: PPUSH
// if not mc_bases or not base or not scan_area then
42337: LD_EXP 50
42341: NOT
42342: PUSH
42343: LD_VAR 0 1
42347: NOT
42348: OR
42349: PUSH
42350: LD_VAR 0 2
42354: NOT
42355: OR
42356: IFFALSE 42360
// exit ;
42358: GO 42385
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
42360: LD_ADDR_EXP 75
42364: PUSH
42365: LD_EXP 75
42369: PPUSH
42370: LD_VAR 0 1
42374: PPUSH
42375: LD_VAR 0 2
42379: PPUSH
42380: CALL_OW 1
42384: ST_TO_ADDR
// end ;
42385: LD_VAR 0 3
42389: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
42390: LD_INT 0
42392: PPUSH
42393: PPUSH
// if not mc_bases or not base then
42394: LD_EXP 50
42398: NOT
42399: PUSH
42400: LD_VAR 0 1
42404: NOT
42405: OR
42406: IFFALSE 42410
// exit ;
42408: GO 42474
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
42410: LD_ADDR_VAR 0 3
42414: PUSH
42415: LD_INT 1
42417: PUSH
42418: LD_INT 2
42420: PUSH
42421: LD_INT 3
42423: PUSH
42424: LD_INT 4
42426: PUSH
42427: LD_INT 11
42429: PUSH
42430: EMPTY
42431: LIST
42432: LIST
42433: LIST
42434: LIST
42435: LIST
42436: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
42437: LD_ADDR_EXP 77
42441: PUSH
42442: LD_EXP 77
42446: PPUSH
42447: LD_VAR 0 1
42451: PPUSH
42452: LD_EXP 77
42456: PUSH
42457: LD_VAR 0 1
42461: ARRAY
42462: PUSH
42463: LD_VAR 0 3
42467: DIFF
42468: PPUSH
42469: CALL_OW 1
42473: ST_TO_ADDR
// end ;
42474: LD_VAR 0 2
42478: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
42479: LD_INT 0
42481: PPUSH
// result := mc_vehicles [ base ] ;
42482: LD_ADDR_VAR 0 3
42486: PUSH
42487: LD_EXP 69
42491: PUSH
42492: LD_VAR 0 1
42496: ARRAY
42497: ST_TO_ADDR
// if onlyCombat then
42498: LD_VAR 0 2
42502: IFFALSE 42667
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
42504: LD_ADDR_VAR 0 3
42508: PUSH
42509: LD_VAR 0 3
42513: PUSH
42514: LD_VAR 0 3
42518: PPUSH
42519: LD_INT 2
42521: PUSH
42522: LD_INT 34
42524: PUSH
42525: LD_INT 12
42527: PUSH
42528: EMPTY
42529: LIST
42530: LIST
42531: PUSH
42532: LD_INT 34
42534: PUSH
42535: LD_INT 51
42537: PUSH
42538: EMPTY
42539: LIST
42540: LIST
42541: PUSH
42542: LD_INT 34
42544: PUSH
42545: LD_EXP 94
42549: PUSH
42550: EMPTY
42551: LIST
42552: LIST
42553: PUSH
42554: LD_INT 34
42556: PUSH
42557: LD_INT 32
42559: PUSH
42560: EMPTY
42561: LIST
42562: LIST
42563: PUSH
42564: LD_INT 34
42566: PUSH
42567: LD_INT 13
42569: PUSH
42570: EMPTY
42571: LIST
42572: LIST
42573: PUSH
42574: LD_INT 34
42576: PUSH
42577: LD_INT 52
42579: PUSH
42580: EMPTY
42581: LIST
42582: LIST
42583: PUSH
42584: LD_INT 34
42586: PUSH
42587: LD_INT 14
42589: PUSH
42590: EMPTY
42591: LIST
42592: LIST
42593: PUSH
42594: LD_INT 34
42596: PUSH
42597: LD_INT 53
42599: PUSH
42600: EMPTY
42601: LIST
42602: LIST
42603: PUSH
42604: LD_INT 34
42606: PUSH
42607: LD_EXP 93
42611: PUSH
42612: EMPTY
42613: LIST
42614: LIST
42615: PUSH
42616: LD_INT 34
42618: PUSH
42619: LD_INT 31
42621: PUSH
42622: EMPTY
42623: LIST
42624: LIST
42625: PUSH
42626: LD_INT 34
42628: PUSH
42629: LD_INT 48
42631: PUSH
42632: EMPTY
42633: LIST
42634: LIST
42635: PUSH
42636: LD_INT 34
42638: PUSH
42639: LD_INT 8
42641: PUSH
42642: EMPTY
42643: LIST
42644: LIST
42645: PUSH
42646: EMPTY
42647: LIST
42648: LIST
42649: LIST
42650: LIST
42651: LIST
42652: LIST
42653: LIST
42654: LIST
42655: LIST
42656: LIST
42657: LIST
42658: LIST
42659: LIST
42660: PPUSH
42661: CALL_OW 72
42665: DIFF
42666: ST_TO_ADDR
// end ; end_of_file
42667: LD_VAR 0 3
42671: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
42672: LD_INT 0
42674: PPUSH
42675: PPUSH
42676: PPUSH
// if not mc_bases or not skirmish then
42677: LD_EXP 50
42681: NOT
42682: PUSH
42683: LD_EXP 48
42687: NOT
42688: OR
42689: IFFALSE 42693
// exit ;
42691: GO 42858
// for i = 1 to mc_bases do
42693: LD_ADDR_VAR 0 4
42697: PUSH
42698: DOUBLE
42699: LD_INT 1
42701: DEC
42702: ST_TO_ADDR
42703: LD_EXP 50
42707: PUSH
42708: FOR_TO
42709: IFFALSE 42856
// begin if sci in mc_bases [ i ] then
42711: LD_VAR 0 2
42715: PUSH
42716: LD_EXP 50
42720: PUSH
42721: LD_VAR 0 4
42725: ARRAY
42726: IN
42727: IFFALSE 42854
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
42729: LD_ADDR_EXP 79
42733: PUSH
42734: LD_EXP 79
42738: PPUSH
42739: LD_VAR 0 4
42743: PUSH
42744: LD_EXP 79
42748: PUSH
42749: LD_VAR 0 4
42753: ARRAY
42754: PUSH
42755: LD_INT 1
42757: PLUS
42758: PUSH
42759: EMPTY
42760: LIST
42761: LIST
42762: PPUSH
42763: LD_VAR 0 1
42767: PPUSH
42768: CALL 52351 0 3
42772: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
42773: LD_ADDR_VAR 0 5
42777: PUSH
42778: LD_EXP 50
42782: PUSH
42783: LD_VAR 0 4
42787: ARRAY
42788: PPUSH
42789: LD_INT 2
42791: PUSH
42792: LD_INT 30
42794: PUSH
42795: LD_INT 0
42797: PUSH
42798: EMPTY
42799: LIST
42800: LIST
42801: PUSH
42802: LD_INT 30
42804: PUSH
42805: LD_INT 1
42807: PUSH
42808: EMPTY
42809: LIST
42810: LIST
42811: PUSH
42812: EMPTY
42813: LIST
42814: LIST
42815: LIST
42816: PPUSH
42817: CALL_OW 72
42821: PPUSH
42822: LD_VAR 0 1
42826: PPUSH
42827: CALL_OW 74
42831: ST_TO_ADDR
// if tmp then
42832: LD_VAR 0 5
42836: IFFALSE 42852
// ComStandNearbyBuilding ( ape , tmp ) ;
42838: LD_VAR 0 1
42842: PPUSH
42843: LD_VAR 0 5
42847: PPUSH
42848: CALL 48965 0 2
// break ;
42852: GO 42856
// end ; end ;
42854: GO 42708
42856: POP
42857: POP
// end ;
42858: LD_VAR 0 3
42862: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
42863: LD_INT 0
42865: PPUSH
42866: PPUSH
42867: PPUSH
// if not mc_bases or not skirmish then
42868: LD_EXP 50
42872: NOT
42873: PUSH
42874: LD_EXP 48
42878: NOT
42879: OR
42880: IFFALSE 42884
// exit ;
42882: GO 42973
// for i = 1 to mc_bases do
42884: LD_ADDR_VAR 0 4
42888: PUSH
42889: DOUBLE
42890: LD_INT 1
42892: DEC
42893: ST_TO_ADDR
42894: LD_EXP 50
42898: PUSH
42899: FOR_TO
42900: IFFALSE 42971
// begin if building in mc_busy_turret_list [ i ] then
42902: LD_VAR 0 1
42906: PUSH
42907: LD_EXP 60
42911: PUSH
42912: LD_VAR 0 4
42916: ARRAY
42917: IN
42918: IFFALSE 42969
// begin tmp := mc_busy_turret_list [ i ] diff building ;
42920: LD_ADDR_VAR 0 5
42924: PUSH
42925: LD_EXP 60
42929: PUSH
42930: LD_VAR 0 4
42934: ARRAY
42935: PUSH
42936: LD_VAR 0 1
42940: DIFF
42941: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
42942: LD_ADDR_EXP 60
42946: PUSH
42947: LD_EXP 60
42951: PPUSH
42952: LD_VAR 0 4
42956: PPUSH
42957: LD_VAR 0 5
42961: PPUSH
42962: CALL_OW 1
42966: ST_TO_ADDR
// break ;
42967: GO 42971
// end ; end ;
42969: GO 42899
42971: POP
42972: POP
// end ;
42973: LD_VAR 0 3
42977: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
42978: LD_INT 0
42980: PPUSH
42981: PPUSH
42982: PPUSH
// if not mc_bases or not skirmish then
42983: LD_EXP 50
42987: NOT
42988: PUSH
42989: LD_EXP 48
42993: NOT
42994: OR
42995: IFFALSE 42999
// exit ;
42997: GO 43198
// for i = 1 to mc_bases do
42999: LD_ADDR_VAR 0 5
43003: PUSH
43004: DOUBLE
43005: LD_INT 1
43007: DEC
43008: ST_TO_ADDR
43009: LD_EXP 50
43013: PUSH
43014: FOR_TO
43015: IFFALSE 43196
// if building in mc_bases [ i ] then
43017: LD_VAR 0 1
43021: PUSH
43022: LD_EXP 50
43026: PUSH
43027: LD_VAR 0 5
43031: ARRAY
43032: IN
43033: IFFALSE 43194
// begin tmp := mc_bases [ i ] diff building ;
43035: LD_ADDR_VAR 0 6
43039: PUSH
43040: LD_EXP 50
43044: PUSH
43045: LD_VAR 0 5
43049: ARRAY
43050: PUSH
43051: LD_VAR 0 1
43055: DIFF
43056: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
43057: LD_ADDR_EXP 50
43061: PUSH
43062: LD_EXP 50
43066: PPUSH
43067: LD_VAR 0 5
43071: PPUSH
43072: LD_VAR 0 6
43076: PPUSH
43077: CALL_OW 1
43081: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
43082: LD_VAR 0 1
43086: PUSH
43087: LD_EXP 58
43091: PUSH
43092: LD_VAR 0 5
43096: ARRAY
43097: IN
43098: IFFALSE 43137
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
43100: LD_ADDR_EXP 58
43104: PUSH
43105: LD_EXP 58
43109: PPUSH
43110: LD_VAR 0 5
43114: PPUSH
43115: LD_EXP 58
43119: PUSH
43120: LD_VAR 0 5
43124: ARRAY
43125: PUSH
43126: LD_VAR 0 1
43130: DIFF
43131: PPUSH
43132: CALL_OW 1
43136: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
43137: LD_VAR 0 1
43141: PUSH
43142: LD_EXP 59
43146: PUSH
43147: LD_VAR 0 5
43151: ARRAY
43152: IN
43153: IFFALSE 43192
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
43155: LD_ADDR_EXP 59
43159: PUSH
43160: LD_EXP 59
43164: PPUSH
43165: LD_VAR 0 5
43169: PPUSH
43170: LD_EXP 59
43174: PUSH
43175: LD_VAR 0 5
43179: ARRAY
43180: PUSH
43181: LD_VAR 0 1
43185: DIFF
43186: PPUSH
43187: CALL_OW 1
43191: ST_TO_ADDR
// break ;
43192: GO 43196
// end ;
43194: GO 43014
43196: POP
43197: POP
// end ;
43198: LD_VAR 0 4
43202: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
43203: LD_INT 0
43205: PPUSH
43206: PPUSH
43207: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
43208: LD_EXP 50
43212: NOT
43213: PUSH
43214: LD_EXP 48
43218: NOT
43219: OR
43220: PUSH
43221: LD_VAR 0 3
43225: PUSH
43226: LD_EXP 76
43230: IN
43231: NOT
43232: OR
43233: IFFALSE 43237
// exit ;
43235: GO 43360
// for i = 1 to mc_vehicles do
43237: LD_ADDR_VAR 0 6
43241: PUSH
43242: DOUBLE
43243: LD_INT 1
43245: DEC
43246: ST_TO_ADDR
43247: LD_EXP 69
43251: PUSH
43252: FOR_TO
43253: IFFALSE 43358
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
43255: LD_VAR 0 2
43259: PUSH
43260: LD_EXP 69
43264: PUSH
43265: LD_VAR 0 6
43269: ARRAY
43270: IN
43271: PUSH
43272: LD_VAR 0 1
43276: PUSH
43277: LD_EXP 69
43281: PUSH
43282: LD_VAR 0 6
43286: ARRAY
43287: IN
43288: OR
43289: IFFALSE 43356
// begin tmp := mc_vehicles [ i ] diff old ;
43291: LD_ADDR_VAR 0 7
43295: PUSH
43296: LD_EXP 69
43300: PUSH
43301: LD_VAR 0 6
43305: ARRAY
43306: PUSH
43307: LD_VAR 0 2
43311: DIFF
43312: ST_TO_ADDR
// tmp := tmp diff new ;
43313: LD_ADDR_VAR 0 7
43317: PUSH
43318: LD_VAR 0 7
43322: PUSH
43323: LD_VAR 0 1
43327: DIFF
43328: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
43329: LD_ADDR_EXP 69
43333: PUSH
43334: LD_EXP 69
43338: PPUSH
43339: LD_VAR 0 6
43343: PPUSH
43344: LD_VAR 0 7
43348: PPUSH
43349: CALL_OW 1
43353: ST_TO_ADDR
// break ;
43354: GO 43358
// end ;
43356: GO 43252
43358: POP
43359: POP
// end ;
43360: LD_VAR 0 5
43364: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
43365: LD_INT 0
43367: PPUSH
43368: PPUSH
43369: PPUSH
43370: PPUSH
// if not mc_bases or not skirmish then
43371: LD_EXP 50
43375: NOT
43376: PUSH
43377: LD_EXP 48
43381: NOT
43382: OR
43383: IFFALSE 43387
// exit ;
43385: GO 43764
// side := GetSide ( vehicle ) ;
43387: LD_ADDR_VAR 0 5
43391: PUSH
43392: LD_VAR 0 1
43396: PPUSH
43397: CALL_OW 255
43401: ST_TO_ADDR
// for i = 1 to mc_bases do
43402: LD_ADDR_VAR 0 4
43406: PUSH
43407: DOUBLE
43408: LD_INT 1
43410: DEC
43411: ST_TO_ADDR
43412: LD_EXP 50
43416: PUSH
43417: FOR_TO
43418: IFFALSE 43762
// begin if factory in mc_bases [ i ] then
43420: LD_VAR 0 2
43424: PUSH
43425: LD_EXP 50
43429: PUSH
43430: LD_VAR 0 4
43434: ARRAY
43435: IN
43436: IFFALSE 43760
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
43438: LD_EXP 72
43442: PUSH
43443: LD_VAR 0 4
43447: ARRAY
43448: PUSH
43449: LD_EXP 61
43453: PUSH
43454: LD_VAR 0 4
43458: ARRAY
43459: LESS
43460: PUSH
43461: LD_VAR 0 1
43465: PPUSH
43466: CALL_OW 264
43470: PUSH
43471: LD_INT 31
43473: PUSH
43474: LD_INT 32
43476: PUSH
43477: LD_INT 51
43479: PUSH
43480: LD_EXP 94
43484: PUSH
43485: LD_INT 12
43487: PUSH
43488: LD_INT 30
43490: PUSH
43491: LD_EXP 93
43495: PUSH
43496: LD_INT 11
43498: PUSH
43499: LD_INT 53
43501: PUSH
43502: LD_INT 14
43504: PUSH
43505: LD_EXP 97
43509: PUSH
43510: LD_INT 29
43512: PUSH
43513: LD_EXP 95
43517: PUSH
43518: LD_INT 13
43520: PUSH
43521: LD_INT 52
43523: PUSH
43524: LD_INT 48
43526: PUSH
43527: LD_INT 8
43529: PUSH
43530: EMPTY
43531: LIST
43532: LIST
43533: LIST
43534: LIST
43535: LIST
43536: LIST
43537: LIST
43538: LIST
43539: LIST
43540: LIST
43541: LIST
43542: LIST
43543: LIST
43544: LIST
43545: LIST
43546: LIST
43547: LIST
43548: IN
43549: NOT
43550: AND
43551: IFFALSE 43599
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
43553: LD_ADDR_EXP 72
43557: PUSH
43558: LD_EXP 72
43562: PPUSH
43563: LD_VAR 0 4
43567: PUSH
43568: LD_EXP 72
43572: PUSH
43573: LD_VAR 0 4
43577: ARRAY
43578: PUSH
43579: LD_INT 1
43581: PLUS
43582: PUSH
43583: EMPTY
43584: LIST
43585: LIST
43586: PPUSH
43587: LD_VAR 0 1
43591: PPUSH
43592: CALL 52351 0 3
43596: ST_TO_ADDR
43597: GO 43643
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
43599: LD_ADDR_EXP 69
43603: PUSH
43604: LD_EXP 69
43608: PPUSH
43609: LD_VAR 0 4
43613: PUSH
43614: LD_EXP 69
43618: PUSH
43619: LD_VAR 0 4
43623: ARRAY
43624: PUSH
43625: LD_INT 1
43627: PLUS
43628: PUSH
43629: EMPTY
43630: LIST
43631: LIST
43632: PPUSH
43633: LD_VAR 0 1
43637: PPUSH
43638: CALL 52351 0 3
43642: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
43643: LD_VAR 0 1
43647: PPUSH
43648: CALL_OW 263
43652: PUSH
43653: LD_INT 2
43655: EQUAL
43656: IFFALSE 43676
// begin repeat wait ( 0 0$1 ) ;
43658: LD_INT 35
43660: PPUSH
43661: CALL_OW 67
// until IsControledBy ( vehicle ) ;
43665: LD_VAR 0 1
43669: PPUSH
43670: CALL_OW 312
43674: IFFALSE 43658
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
43676: LD_VAR 0 1
43680: PPUSH
43681: LD_EXP 74
43685: PUSH
43686: LD_VAR 0 4
43690: ARRAY
43691: PPUSH
43692: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
43696: LD_VAR 0 1
43700: PPUSH
43701: CALL_OW 263
43705: PUSH
43706: LD_INT 1
43708: NONEQUAL
43709: IFFALSE 43713
// break ;
43711: GO 43762
// repeat wait ( 0 0$1 ) ;
43713: LD_INT 35
43715: PPUSH
43716: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
43720: LD_VAR 0 1
43724: PPUSH
43725: LD_EXP 74
43729: PUSH
43730: LD_VAR 0 4
43734: ARRAY
43735: PPUSH
43736: CALL_OW 308
43740: IFFALSE 43713
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
43742: LD_VAR 0 1
43746: PPUSH
43747: CALL_OW 311
43751: PPUSH
43752: CALL_OW 121
// exit ;
43756: POP
43757: POP
43758: GO 43764
// end ; end ;
43760: GO 43417
43762: POP
43763: POP
// end ;
43764: LD_VAR 0 3
43768: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
43769: LD_INT 0
43771: PPUSH
43772: PPUSH
43773: PPUSH
43774: PPUSH
// if not mc_bases or not skirmish then
43775: LD_EXP 50
43779: NOT
43780: PUSH
43781: LD_EXP 48
43785: NOT
43786: OR
43787: IFFALSE 43791
// exit ;
43789: GO 44144
// repeat wait ( 0 0$1 ) ;
43791: LD_INT 35
43793: PPUSH
43794: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
43798: LD_VAR 0 2
43802: PPUSH
43803: LD_VAR 0 3
43807: PPUSH
43808: CALL_OW 284
43812: IFFALSE 43791
// if GetResourceTypeXY ( x , y ) = mat_artefact then
43814: LD_VAR 0 2
43818: PPUSH
43819: LD_VAR 0 3
43823: PPUSH
43824: CALL_OW 283
43828: PUSH
43829: LD_INT 4
43831: EQUAL
43832: IFFALSE 43836
// exit ;
43834: GO 44144
// for i = 1 to mc_bases do
43836: LD_ADDR_VAR 0 7
43840: PUSH
43841: DOUBLE
43842: LD_INT 1
43844: DEC
43845: ST_TO_ADDR
43846: LD_EXP 50
43850: PUSH
43851: FOR_TO
43852: IFFALSE 44142
// begin if mc_crates_area [ i ] then
43854: LD_EXP 68
43858: PUSH
43859: LD_VAR 0 7
43863: ARRAY
43864: IFFALSE 43975
// for j in mc_crates_area [ i ] do
43866: LD_ADDR_VAR 0 8
43870: PUSH
43871: LD_EXP 68
43875: PUSH
43876: LD_VAR 0 7
43880: ARRAY
43881: PUSH
43882: FOR_IN
43883: IFFALSE 43973
// if InArea ( x , y , j ) then
43885: LD_VAR 0 2
43889: PPUSH
43890: LD_VAR 0 3
43894: PPUSH
43895: LD_VAR 0 8
43899: PPUSH
43900: CALL_OW 309
43904: IFFALSE 43971
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
43906: LD_ADDR_EXP 66
43910: PUSH
43911: LD_EXP 66
43915: PPUSH
43916: LD_VAR 0 7
43920: PUSH
43921: LD_EXP 66
43925: PUSH
43926: LD_VAR 0 7
43930: ARRAY
43931: PUSH
43932: LD_INT 1
43934: PLUS
43935: PUSH
43936: EMPTY
43937: LIST
43938: LIST
43939: PPUSH
43940: LD_VAR 0 4
43944: PUSH
43945: LD_VAR 0 2
43949: PUSH
43950: LD_VAR 0 3
43954: PUSH
43955: EMPTY
43956: LIST
43957: LIST
43958: LIST
43959: PPUSH
43960: CALL 52351 0 3
43964: ST_TO_ADDR
// exit ;
43965: POP
43966: POP
43967: POP
43968: POP
43969: GO 44144
// end ;
43971: GO 43882
43973: POP
43974: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
43975: LD_ADDR_VAR 0 9
43979: PUSH
43980: LD_EXP 50
43984: PUSH
43985: LD_VAR 0 7
43989: ARRAY
43990: PPUSH
43991: LD_INT 2
43993: PUSH
43994: LD_INT 30
43996: PUSH
43997: LD_INT 0
43999: PUSH
44000: EMPTY
44001: LIST
44002: LIST
44003: PUSH
44004: LD_INT 30
44006: PUSH
44007: LD_INT 1
44009: PUSH
44010: EMPTY
44011: LIST
44012: LIST
44013: PUSH
44014: EMPTY
44015: LIST
44016: LIST
44017: LIST
44018: PPUSH
44019: CALL_OW 72
44023: ST_TO_ADDR
// if not depot then
44024: LD_VAR 0 9
44028: NOT
44029: IFFALSE 44033
// continue ;
44031: GO 43851
// for j in depot do
44033: LD_ADDR_VAR 0 8
44037: PUSH
44038: LD_VAR 0 9
44042: PUSH
44043: FOR_IN
44044: IFFALSE 44138
// if GetDistUnitXY ( j , x , y ) < 30 then
44046: LD_VAR 0 8
44050: PPUSH
44051: LD_VAR 0 2
44055: PPUSH
44056: LD_VAR 0 3
44060: PPUSH
44061: CALL_OW 297
44065: PUSH
44066: LD_INT 30
44068: LESS
44069: IFFALSE 44136
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
44071: LD_ADDR_EXP 66
44075: PUSH
44076: LD_EXP 66
44080: PPUSH
44081: LD_VAR 0 7
44085: PUSH
44086: LD_EXP 66
44090: PUSH
44091: LD_VAR 0 7
44095: ARRAY
44096: PUSH
44097: LD_INT 1
44099: PLUS
44100: PUSH
44101: EMPTY
44102: LIST
44103: LIST
44104: PPUSH
44105: LD_VAR 0 4
44109: PUSH
44110: LD_VAR 0 2
44114: PUSH
44115: LD_VAR 0 3
44119: PUSH
44120: EMPTY
44121: LIST
44122: LIST
44123: LIST
44124: PPUSH
44125: CALL 52351 0 3
44129: ST_TO_ADDR
// exit ;
44130: POP
44131: POP
44132: POP
44133: POP
44134: GO 44144
// end ;
44136: GO 44043
44138: POP
44139: POP
// end ;
44140: GO 43851
44142: POP
44143: POP
// end ;
44144: LD_VAR 0 6
44148: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
44149: LD_INT 0
44151: PPUSH
44152: PPUSH
44153: PPUSH
44154: PPUSH
// if not mc_bases or not skirmish then
44155: LD_EXP 50
44159: NOT
44160: PUSH
44161: LD_EXP 48
44165: NOT
44166: OR
44167: IFFALSE 44171
// exit ;
44169: GO 44448
// side := GetSide ( lab ) ;
44171: LD_ADDR_VAR 0 4
44175: PUSH
44176: LD_VAR 0 2
44180: PPUSH
44181: CALL_OW 255
44185: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
44186: LD_VAR 0 4
44190: PUSH
44191: LD_EXP 76
44195: IN
44196: NOT
44197: PUSH
44198: LD_EXP 77
44202: NOT
44203: OR
44204: PUSH
44205: LD_EXP 50
44209: NOT
44210: OR
44211: IFFALSE 44215
// exit ;
44213: GO 44448
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
44215: LD_ADDR_EXP 77
44219: PUSH
44220: LD_EXP 77
44224: PPUSH
44225: LD_VAR 0 4
44229: PPUSH
44230: LD_EXP 77
44234: PUSH
44235: LD_VAR 0 4
44239: ARRAY
44240: PUSH
44241: LD_VAR 0 1
44245: DIFF
44246: PPUSH
44247: CALL_OW 1
44251: ST_TO_ADDR
// for i = 1 to mc_bases do
44252: LD_ADDR_VAR 0 5
44256: PUSH
44257: DOUBLE
44258: LD_INT 1
44260: DEC
44261: ST_TO_ADDR
44262: LD_EXP 50
44266: PUSH
44267: FOR_TO
44268: IFFALSE 44446
// begin if lab in mc_bases [ i ] then
44270: LD_VAR 0 2
44274: PUSH
44275: LD_EXP 50
44279: PUSH
44280: LD_VAR 0 5
44284: ARRAY
44285: IN
44286: IFFALSE 44444
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
44288: LD_VAR 0 1
44292: PUSH
44293: LD_INT 11
44295: PUSH
44296: LD_INT 4
44298: PUSH
44299: LD_INT 3
44301: PUSH
44302: LD_INT 2
44304: PUSH
44305: EMPTY
44306: LIST
44307: LIST
44308: LIST
44309: LIST
44310: IN
44311: PUSH
44312: LD_EXP 80
44316: PUSH
44317: LD_VAR 0 5
44321: ARRAY
44322: AND
44323: IFFALSE 44444
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
44325: LD_ADDR_VAR 0 6
44329: PUSH
44330: LD_EXP 80
44334: PUSH
44335: LD_VAR 0 5
44339: ARRAY
44340: PUSH
44341: LD_INT 1
44343: ARRAY
44344: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
44345: LD_ADDR_EXP 80
44349: PUSH
44350: LD_EXP 80
44354: PPUSH
44355: LD_VAR 0 5
44359: PPUSH
44360: EMPTY
44361: PPUSH
44362: CALL_OW 1
44366: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
44367: LD_VAR 0 6
44371: PPUSH
44372: LD_INT 0
44374: PPUSH
44375: CALL_OW 109
// ComExitBuilding ( tmp ) ;
44379: LD_VAR 0 6
44383: PPUSH
44384: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
44388: LD_ADDR_EXP 79
44392: PUSH
44393: LD_EXP 79
44397: PPUSH
44398: LD_VAR 0 5
44402: PPUSH
44403: LD_EXP 79
44407: PUSH
44408: LD_VAR 0 5
44412: ARRAY
44413: PPUSH
44414: LD_INT 1
44416: PPUSH
44417: LD_VAR 0 6
44421: PPUSH
44422: CALL_OW 2
44426: PPUSH
44427: CALL_OW 1
44431: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
44432: LD_VAR 0 5
44436: PPUSH
44437: LD_INT 112
44439: PPUSH
44440: CALL 21460 0 2
// end ; end ; end ;
44444: GO 44267
44446: POP
44447: POP
// end ;
44448: LD_VAR 0 3
44452: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
44453: LD_INT 0
44455: PPUSH
44456: PPUSH
44457: PPUSH
44458: PPUSH
44459: PPUSH
44460: PPUSH
44461: PPUSH
44462: PPUSH
// if not mc_bases or not skirmish then
44463: LD_EXP 50
44467: NOT
44468: PUSH
44469: LD_EXP 48
44473: NOT
44474: OR
44475: IFFALSE 44479
// exit ;
44477: GO 45850
// for i = 1 to mc_bases do
44479: LD_ADDR_VAR 0 3
44483: PUSH
44484: DOUBLE
44485: LD_INT 1
44487: DEC
44488: ST_TO_ADDR
44489: LD_EXP 50
44493: PUSH
44494: FOR_TO
44495: IFFALSE 45848
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
44497: LD_VAR 0 1
44501: PUSH
44502: LD_EXP 50
44506: PUSH
44507: LD_VAR 0 3
44511: ARRAY
44512: IN
44513: PUSH
44514: LD_VAR 0 1
44518: PUSH
44519: LD_EXP 57
44523: PUSH
44524: LD_VAR 0 3
44528: ARRAY
44529: IN
44530: OR
44531: PUSH
44532: LD_VAR 0 1
44536: PUSH
44537: LD_EXP 72
44541: PUSH
44542: LD_VAR 0 3
44546: ARRAY
44547: IN
44548: OR
44549: PUSH
44550: LD_VAR 0 1
44554: PUSH
44555: LD_EXP 69
44559: PUSH
44560: LD_VAR 0 3
44564: ARRAY
44565: IN
44566: OR
44567: PUSH
44568: LD_VAR 0 1
44572: PUSH
44573: LD_EXP 79
44577: PUSH
44578: LD_VAR 0 3
44582: ARRAY
44583: IN
44584: OR
44585: PUSH
44586: LD_VAR 0 1
44590: PUSH
44591: LD_EXP 80
44595: PUSH
44596: LD_VAR 0 3
44600: ARRAY
44601: IN
44602: OR
44603: IFFALSE 45846
// begin if un in mc_ape [ i ] then
44605: LD_VAR 0 1
44609: PUSH
44610: LD_EXP 79
44614: PUSH
44615: LD_VAR 0 3
44619: ARRAY
44620: IN
44621: IFFALSE 44660
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
44623: LD_ADDR_EXP 79
44627: PUSH
44628: LD_EXP 79
44632: PPUSH
44633: LD_VAR 0 3
44637: PPUSH
44638: LD_EXP 79
44642: PUSH
44643: LD_VAR 0 3
44647: ARRAY
44648: PUSH
44649: LD_VAR 0 1
44653: DIFF
44654: PPUSH
44655: CALL_OW 1
44659: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
44660: LD_VAR 0 1
44664: PUSH
44665: LD_EXP 80
44669: PUSH
44670: LD_VAR 0 3
44674: ARRAY
44675: IN
44676: IFFALSE 44700
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
44678: LD_ADDR_EXP 80
44682: PUSH
44683: LD_EXP 80
44687: PPUSH
44688: LD_VAR 0 3
44692: PPUSH
44693: EMPTY
44694: PPUSH
44695: CALL_OW 1
44699: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
44700: LD_VAR 0 1
44704: PPUSH
44705: CALL_OW 247
44709: PUSH
44710: LD_INT 2
44712: EQUAL
44713: PUSH
44714: LD_VAR 0 1
44718: PPUSH
44719: CALL_OW 110
44723: PUSH
44724: LD_INT 20
44726: EQUAL
44727: PUSH
44728: LD_VAR 0 1
44732: PUSH
44733: LD_EXP 72
44737: PUSH
44738: LD_VAR 0 3
44742: ARRAY
44743: IN
44744: OR
44745: PUSH
44746: LD_VAR 0 1
44750: PPUSH
44751: CALL_OW 264
44755: PUSH
44756: LD_INT 12
44758: PUSH
44759: LD_INT 51
44761: PUSH
44762: LD_EXP 94
44766: PUSH
44767: LD_INT 32
44769: PUSH
44770: LD_INT 13
44772: PUSH
44773: LD_INT 52
44775: PUSH
44776: LD_INT 31
44778: PUSH
44779: EMPTY
44780: LIST
44781: LIST
44782: LIST
44783: LIST
44784: LIST
44785: LIST
44786: LIST
44787: IN
44788: OR
44789: AND
44790: IFFALSE 45098
// begin if un in mc_defender [ i ] then
44792: LD_VAR 0 1
44796: PUSH
44797: LD_EXP 72
44801: PUSH
44802: LD_VAR 0 3
44806: ARRAY
44807: IN
44808: IFFALSE 44847
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
44810: LD_ADDR_EXP 72
44814: PUSH
44815: LD_EXP 72
44819: PPUSH
44820: LD_VAR 0 3
44824: PPUSH
44825: LD_EXP 72
44829: PUSH
44830: LD_VAR 0 3
44834: ARRAY
44835: PUSH
44836: LD_VAR 0 1
44840: DIFF
44841: PPUSH
44842: CALL_OW 1
44846: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
44847: LD_ADDR_VAR 0 8
44851: PUSH
44852: LD_VAR 0 3
44856: PPUSH
44857: LD_INT 3
44859: PPUSH
44860: CALL 41516 0 2
44864: ST_TO_ADDR
// if fac then
44865: LD_VAR 0 8
44869: IFFALSE 45098
// begin for j in fac do
44871: LD_ADDR_VAR 0 4
44875: PUSH
44876: LD_VAR 0 8
44880: PUSH
44881: FOR_IN
44882: IFFALSE 45096
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
44884: LD_ADDR_VAR 0 9
44888: PUSH
44889: LD_VAR 0 8
44893: PPUSH
44894: LD_VAR 0 1
44898: PPUSH
44899: CALL_OW 265
44903: PPUSH
44904: LD_VAR 0 1
44908: PPUSH
44909: CALL_OW 262
44913: PPUSH
44914: LD_VAR 0 1
44918: PPUSH
44919: CALL_OW 263
44923: PPUSH
44924: LD_VAR 0 1
44928: PPUSH
44929: CALL_OW 264
44933: PPUSH
44934: CALL 49883 0 5
44938: ST_TO_ADDR
// if components then
44939: LD_VAR 0 9
44943: IFFALSE 45094
// begin if GetWeapon ( un ) = ar_control_tower then
44945: LD_VAR 0 1
44949: PPUSH
44950: CALL_OW 264
44954: PUSH
44955: LD_INT 31
44957: EQUAL
44958: IFFALSE 45075
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
44960: LD_VAR 0 1
44964: PPUSH
44965: CALL_OW 311
44969: PPUSH
44970: LD_INT 0
44972: PPUSH
44973: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
44977: LD_ADDR_EXP 90
44981: PUSH
44982: LD_EXP 90
44986: PPUSH
44987: LD_VAR 0 3
44991: PPUSH
44992: LD_EXP 90
44996: PUSH
44997: LD_VAR 0 3
45001: ARRAY
45002: PUSH
45003: LD_VAR 0 1
45007: PPUSH
45008: CALL_OW 311
45012: DIFF
45013: PPUSH
45014: CALL_OW 1
45018: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
45019: LD_ADDR_VAR 0 7
45023: PUSH
45024: LD_EXP 71
45028: PUSH
45029: LD_VAR 0 3
45033: ARRAY
45034: PPUSH
45035: LD_INT 1
45037: PPUSH
45038: LD_VAR 0 9
45042: PPUSH
45043: CALL_OW 2
45047: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
45048: LD_ADDR_EXP 71
45052: PUSH
45053: LD_EXP 71
45057: PPUSH
45058: LD_VAR 0 3
45062: PPUSH
45063: LD_VAR 0 7
45067: PPUSH
45068: CALL_OW 1
45072: ST_TO_ADDR
// end else
45073: GO 45092
// MC_InsertProduceList ( i , [ components ] ) ;
45075: LD_VAR 0 3
45079: PPUSH
45080: LD_VAR 0 9
45084: PUSH
45085: EMPTY
45086: LIST
45087: PPUSH
45088: CALL 41061 0 2
// break ;
45092: GO 45096
// end ; end ;
45094: GO 44881
45096: POP
45097: POP
// end ; end ; if GetType ( un ) = unit_building then
45098: LD_VAR 0 1
45102: PPUSH
45103: CALL_OW 247
45107: PUSH
45108: LD_INT 3
45110: EQUAL
45111: IFFALSE 45514
// begin btype := GetBType ( un ) ;
45113: LD_ADDR_VAR 0 5
45117: PUSH
45118: LD_VAR 0 1
45122: PPUSH
45123: CALL_OW 266
45127: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
45128: LD_VAR 0 5
45132: PUSH
45133: LD_INT 29
45135: PUSH
45136: LD_INT 30
45138: PUSH
45139: EMPTY
45140: LIST
45141: LIST
45142: IN
45143: IFFALSE 45216
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
45145: LD_VAR 0 1
45149: PPUSH
45150: CALL_OW 250
45154: PPUSH
45155: LD_VAR 0 1
45159: PPUSH
45160: CALL_OW 251
45164: PPUSH
45165: LD_VAR 0 1
45169: PPUSH
45170: CALL_OW 255
45174: PPUSH
45175: CALL_OW 440
45179: NOT
45180: IFFALSE 45216
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
45182: LD_VAR 0 1
45186: PPUSH
45187: CALL_OW 250
45191: PPUSH
45192: LD_VAR 0 1
45196: PPUSH
45197: CALL_OW 251
45201: PPUSH
45202: LD_VAR 0 1
45206: PPUSH
45207: CALL_OW 255
45211: PPUSH
45212: CALL_OW 441
// end ; if btype = b_warehouse then
45216: LD_VAR 0 5
45220: PUSH
45221: LD_INT 1
45223: EQUAL
45224: IFFALSE 45242
// begin btype := b_depot ;
45226: LD_ADDR_VAR 0 5
45230: PUSH
45231: LD_INT 0
45233: ST_TO_ADDR
// pos := 1 ;
45234: LD_ADDR_VAR 0 6
45238: PUSH
45239: LD_INT 1
45241: ST_TO_ADDR
// end ; if btype = b_factory then
45242: LD_VAR 0 5
45246: PUSH
45247: LD_INT 3
45249: EQUAL
45250: IFFALSE 45268
// begin btype := b_workshop ;
45252: LD_ADDR_VAR 0 5
45256: PUSH
45257: LD_INT 2
45259: ST_TO_ADDR
// pos := 1 ;
45260: LD_ADDR_VAR 0 6
45264: PUSH
45265: LD_INT 1
45267: ST_TO_ADDR
// end ; if btype = b_barracks then
45268: LD_VAR 0 5
45272: PUSH
45273: LD_INT 5
45275: EQUAL
45276: IFFALSE 45286
// btype := b_armoury ;
45278: LD_ADDR_VAR 0 5
45282: PUSH
45283: LD_INT 4
45285: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
45286: LD_VAR 0 5
45290: PUSH
45291: LD_INT 7
45293: PUSH
45294: LD_INT 8
45296: PUSH
45297: EMPTY
45298: LIST
45299: LIST
45300: IN
45301: IFFALSE 45311
// btype := b_lab ;
45303: LD_ADDR_VAR 0 5
45307: PUSH
45308: LD_INT 6
45310: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
45311: LD_ADDR_EXP 55
45315: PUSH
45316: LD_EXP 55
45320: PPUSH
45321: LD_VAR 0 3
45325: PUSH
45326: LD_EXP 55
45330: PUSH
45331: LD_VAR 0 3
45335: ARRAY
45336: PUSH
45337: LD_INT 1
45339: PLUS
45340: PUSH
45341: EMPTY
45342: LIST
45343: LIST
45344: PPUSH
45345: LD_VAR 0 5
45349: PUSH
45350: LD_VAR 0 1
45354: PPUSH
45355: CALL_OW 250
45359: PUSH
45360: LD_VAR 0 1
45364: PPUSH
45365: CALL_OW 251
45369: PUSH
45370: LD_VAR 0 1
45374: PPUSH
45375: CALL_OW 254
45379: PUSH
45380: EMPTY
45381: LIST
45382: LIST
45383: LIST
45384: LIST
45385: PPUSH
45386: CALL 52351 0 3
45390: ST_TO_ADDR
// if pos = 1 then
45391: LD_VAR 0 6
45395: PUSH
45396: LD_INT 1
45398: EQUAL
45399: IFFALSE 45514
// begin tmp := mc_build_list [ i ] ;
45401: LD_ADDR_VAR 0 7
45405: PUSH
45406: LD_EXP 55
45410: PUSH
45411: LD_VAR 0 3
45415: ARRAY
45416: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
45417: LD_VAR 0 7
45421: PPUSH
45422: LD_INT 2
45424: PUSH
45425: LD_INT 30
45427: PUSH
45428: LD_INT 0
45430: PUSH
45431: EMPTY
45432: LIST
45433: LIST
45434: PUSH
45435: LD_INT 30
45437: PUSH
45438: LD_INT 1
45440: PUSH
45441: EMPTY
45442: LIST
45443: LIST
45444: PUSH
45445: EMPTY
45446: LIST
45447: LIST
45448: LIST
45449: PPUSH
45450: CALL_OW 72
45454: IFFALSE 45464
// pos := 2 ;
45456: LD_ADDR_VAR 0 6
45460: PUSH
45461: LD_INT 2
45463: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
45464: LD_ADDR_VAR 0 7
45468: PUSH
45469: LD_VAR 0 7
45473: PPUSH
45474: LD_VAR 0 6
45478: PPUSH
45479: LD_VAR 0 7
45483: PPUSH
45484: CALL 52677 0 3
45488: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
45489: LD_ADDR_EXP 55
45493: PUSH
45494: LD_EXP 55
45498: PPUSH
45499: LD_VAR 0 3
45503: PPUSH
45504: LD_VAR 0 7
45508: PPUSH
45509: CALL_OW 1
45513: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
45514: LD_VAR 0 1
45518: PUSH
45519: LD_EXP 50
45523: PUSH
45524: LD_VAR 0 3
45528: ARRAY
45529: IN
45530: IFFALSE 45569
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
45532: LD_ADDR_EXP 50
45536: PUSH
45537: LD_EXP 50
45541: PPUSH
45542: LD_VAR 0 3
45546: PPUSH
45547: LD_EXP 50
45551: PUSH
45552: LD_VAR 0 3
45556: ARRAY
45557: PUSH
45558: LD_VAR 0 1
45562: DIFF
45563: PPUSH
45564: CALL_OW 1
45568: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
45569: LD_VAR 0 1
45573: PUSH
45574: LD_EXP 57
45578: PUSH
45579: LD_VAR 0 3
45583: ARRAY
45584: IN
45585: IFFALSE 45624
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
45587: LD_ADDR_EXP 57
45591: PUSH
45592: LD_EXP 57
45596: PPUSH
45597: LD_VAR 0 3
45601: PPUSH
45602: LD_EXP 57
45606: PUSH
45607: LD_VAR 0 3
45611: ARRAY
45612: PUSH
45613: LD_VAR 0 1
45617: DIFF
45618: PPUSH
45619: CALL_OW 1
45623: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
45624: LD_VAR 0 1
45628: PUSH
45629: LD_EXP 69
45633: PUSH
45634: LD_VAR 0 3
45638: ARRAY
45639: IN
45640: IFFALSE 45679
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
45642: LD_ADDR_EXP 69
45646: PUSH
45647: LD_EXP 69
45651: PPUSH
45652: LD_VAR 0 3
45656: PPUSH
45657: LD_EXP 69
45661: PUSH
45662: LD_VAR 0 3
45666: ARRAY
45667: PUSH
45668: LD_VAR 0 1
45672: DIFF
45673: PPUSH
45674: CALL_OW 1
45678: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
45679: LD_VAR 0 1
45683: PUSH
45684: LD_EXP 72
45688: PUSH
45689: LD_VAR 0 3
45693: ARRAY
45694: IN
45695: IFFALSE 45734
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
45697: LD_ADDR_EXP 72
45701: PUSH
45702: LD_EXP 72
45706: PPUSH
45707: LD_VAR 0 3
45711: PPUSH
45712: LD_EXP 72
45716: PUSH
45717: LD_VAR 0 3
45721: ARRAY
45722: PUSH
45723: LD_VAR 0 1
45727: DIFF
45728: PPUSH
45729: CALL_OW 1
45733: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
45734: LD_VAR 0 1
45738: PUSH
45739: LD_EXP 59
45743: PUSH
45744: LD_VAR 0 3
45748: ARRAY
45749: IN
45750: IFFALSE 45789
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
45752: LD_ADDR_EXP 59
45756: PUSH
45757: LD_EXP 59
45761: PPUSH
45762: LD_VAR 0 3
45766: PPUSH
45767: LD_EXP 59
45771: PUSH
45772: LD_VAR 0 3
45776: ARRAY
45777: PUSH
45778: LD_VAR 0 1
45782: DIFF
45783: PPUSH
45784: CALL_OW 1
45788: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
45789: LD_VAR 0 1
45793: PUSH
45794: LD_EXP 58
45798: PUSH
45799: LD_VAR 0 3
45803: ARRAY
45804: IN
45805: IFFALSE 45844
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
45807: LD_ADDR_EXP 58
45811: PUSH
45812: LD_EXP 58
45816: PPUSH
45817: LD_VAR 0 3
45821: PPUSH
45822: LD_EXP 58
45826: PUSH
45827: LD_VAR 0 3
45831: ARRAY
45832: PUSH
45833: LD_VAR 0 1
45837: DIFF
45838: PPUSH
45839: CALL_OW 1
45843: ST_TO_ADDR
// end ; break ;
45844: GO 45848
// end ;
45846: GO 44494
45848: POP
45849: POP
// end ;
45850: LD_VAR 0 2
45854: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
45855: LD_INT 0
45857: PPUSH
45858: PPUSH
45859: PPUSH
// if not mc_bases or not skirmish then
45860: LD_EXP 50
45864: NOT
45865: PUSH
45866: LD_EXP 48
45870: NOT
45871: OR
45872: IFFALSE 45876
// exit ;
45874: GO 46091
// for i = 1 to mc_bases do
45876: LD_ADDR_VAR 0 3
45880: PUSH
45881: DOUBLE
45882: LD_INT 1
45884: DEC
45885: ST_TO_ADDR
45886: LD_EXP 50
45890: PUSH
45891: FOR_TO
45892: IFFALSE 46089
// begin if building in mc_construct_list [ i ] then
45894: LD_VAR 0 1
45898: PUSH
45899: LD_EXP 57
45903: PUSH
45904: LD_VAR 0 3
45908: ARRAY
45909: IN
45910: IFFALSE 46087
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
45912: LD_ADDR_EXP 57
45916: PUSH
45917: LD_EXP 57
45921: PPUSH
45922: LD_VAR 0 3
45926: PPUSH
45927: LD_EXP 57
45931: PUSH
45932: LD_VAR 0 3
45936: ARRAY
45937: PUSH
45938: LD_VAR 0 1
45942: DIFF
45943: PPUSH
45944: CALL_OW 1
45948: ST_TO_ADDR
// if building in mc_lab [ i ] then
45949: LD_VAR 0 1
45953: PUSH
45954: LD_EXP 83
45958: PUSH
45959: LD_VAR 0 3
45963: ARRAY
45964: IN
45965: IFFALSE 46020
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
45967: LD_ADDR_EXP 84
45971: PUSH
45972: LD_EXP 84
45976: PPUSH
45977: LD_VAR 0 3
45981: PPUSH
45982: LD_EXP 84
45986: PUSH
45987: LD_VAR 0 3
45991: ARRAY
45992: PPUSH
45993: LD_INT 1
45995: PPUSH
45996: LD_EXP 84
46000: PUSH
46001: LD_VAR 0 3
46005: ARRAY
46006: PPUSH
46007: LD_INT 0
46009: PPUSH
46010: CALL 51769 0 4
46014: PPUSH
46015: CALL_OW 1
46019: ST_TO_ADDR
// if not building in mc_bases [ i ] then
46020: LD_VAR 0 1
46024: PUSH
46025: LD_EXP 50
46029: PUSH
46030: LD_VAR 0 3
46034: ARRAY
46035: IN
46036: NOT
46037: IFFALSE 46083
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
46039: LD_ADDR_EXP 50
46043: PUSH
46044: LD_EXP 50
46048: PPUSH
46049: LD_VAR 0 3
46053: PUSH
46054: LD_EXP 50
46058: PUSH
46059: LD_VAR 0 3
46063: ARRAY
46064: PUSH
46065: LD_INT 1
46067: PLUS
46068: PUSH
46069: EMPTY
46070: LIST
46071: LIST
46072: PPUSH
46073: LD_VAR 0 1
46077: PPUSH
46078: CALL 52351 0 3
46082: ST_TO_ADDR
// exit ;
46083: POP
46084: POP
46085: GO 46091
// end ; end ;
46087: GO 45891
46089: POP
46090: POP
// end ;
46091: LD_VAR 0 2
46095: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
46096: LD_INT 0
46098: PPUSH
46099: PPUSH
46100: PPUSH
46101: PPUSH
46102: PPUSH
46103: PPUSH
46104: PPUSH
// if not mc_bases or not skirmish then
46105: LD_EXP 50
46109: NOT
46110: PUSH
46111: LD_EXP 48
46115: NOT
46116: OR
46117: IFFALSE 46121
// exit ;
46119: GO 46782
// for i = 1 to mc_bases do
46121: LD_ADDR_VAR 0 3
46125: PUSH
46126: DOUBLE
46127: LD_INT 1
46129: DEC
46130: ST_TO_ADDR
46131: LD_EXP 50
46135: PUSH
46136: FOR_TO
46137: IFFALSE 46780
// begin if building in mc_construct_list [ i ] then
46139: LD_VAR 0 1
46143: PUSH
46144: LD_EXP 57
46148: PUSH
46149: LD_VAR 0 3
46153: ARRAY
46154: IN
46155: IFFALSE 46778
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
46157: LD_ADDR_EXP 57
46161: PUSH
46162: LD_EXP 57
46166: PPUSH
46167: LD_VAR 0 3
46171: PPUSH
46172: LD_EXP 57
46176: PUSH
46177: LD_VAR 0 3
46181: ARRAY
46182: PUSH
46183: LD_VAR 0 1
46187: DIFF
46188: PPUSH
46189: CALL_OW 1
46193: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
46194: LD_ADDR_EXP 50
46198: PUSH
46199: LD_EXP 50
46203: PPUSH
46204: LD_VAR 0 3
46208: PUSH
46209: LD_EXP 50
46213: PUSH
46214: LD_VAR 0 3
46218: ARRAY
46219: PUSH
46220: LD_INT 1
46222: PLUS
46223: PUSH
46224: EMPTY
46225: LIST
46226: LIST
46227: PPUSH
46228: LD_VAR 0 1
46232: PPUSH
46233: CALL 52351 0 3
46237: ST_TO_ADDR
// btype := GetBType ( building ) ;
46238: LD_ADDR_VAR 0 5
46242: PUSH
46243: LD_VAR 0 1
46247: PPUSH
46248: CALL_OW 266
46252: ST_TO_ADDR
// side := GetSide ( building ) ;
46253: LD_ADDR_VAR 0 8
46257: PUSH
46258: LD_VAR 0 1
46262: PPUSH
46263: CALL_OW 255
46267: ST_TO_ADDR
// if btype = b_lab then
46268: LD_VAR 0 5
46272: PUSH
46273: LD_INT 6
46275: EQUAL
46276: IFFALSE 46326
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
46278: LD_ADDR_EXP 83
46282: PUSH
46283: LD_EXP 83
46287: PPUSH
46288: LD_VAR 0 3
46292: PUSH
46293: LD_EXP 83
46297: PUSH
46298: LD_VAR 0 3
46302: ARRAY
46303: PUSH
46304: LD_INT 1
46306: PLUS
46307: PUSH
46308: EMPTY
46309: LIST
46310: LIST
46311: PPUSH
46312: LD_VAR 0 1
46316: PPUSH
46317: CALL 52351 0 3
46321: ST_TO_ADDR
// exit ;
46322: POP
46323: POP
46324: GO 46782
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
46326: LD_VAR 0 5
46330: PUSH
46331: LD_INT 0
46333: PUSH
46334: LD_INT 2
46336: PUSH
46337: LD_INT 4
46339: PUSH
46340: EMPTY
46341: LIST
46342: LIST
46343: LIST
46344: IN
46345: IFFALSE 46469
// begin if btype = b_armoury then
46347: LD_VAR 0 5
46351: PUSH
46352: LD_INT 4
46354: EQUAL
46355: IFFALSE 46365
// btype := b_barracks ;
46357: LD_ADDR_VAR 0 5
46361: PUSH
46362: LD_INT 5
46364: ST_TO_ADDR
// if btype = b_depot then
46365: LD_VAR 0 5
46369: PUSH
46370: LD_INT 0
46372: EQUAL
46373: IFFALSE 46383
// btype := b_warehouse ;
46375: LD_ADDR_VAR 0 5
46379: PUSH
46380: LD_INT 1
46382: ST_TO_ADDR
// if btype = b_workshop then
46383: LD_VAR 0 5
46387: PUSH
46388: LD_INT 2
46390: EQUAL
46391: IFFALSE 46401
// btype := b_factory ;
46393: LD_ADDR_VAR 0 5
46397: PUSH
46398: LD_INT 3
46400: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
46401: LD_VAR 0 5
46405: PPUSH
46406: LD_VAR 0 8
46410: PPUSH
46411: CALL_OW 323
46415: PUSH
46416: LD_INT 1
46418: EQUAL
46419: IFFALSE 46465
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
46421: LD_ADDR_EXP 82
46425: PUSH
46426: LD_EXP 82
46430: PPUSH
46431: LD_VAR 0 3
46435: PUSH
46436: LD_EXP 82
46440: PUSH
46441: LD_VAR 0 3
46445: ARRAY
46446: PUSH
46447: LD_INT 1
46449: PLUS
46450: PUSH
46451: EMPTY
46452: LIST
46453: LIST
46454: PPUSH
46455: LD_VAR 0 1
46459: PPUSH
46460: CALL 52351 0 3
46464: ST_TO_ADDR
// exit ;
46465: POP
46466: POP
46467: GO 46782
// end ; if btype in [ b_bunker , b_turret ] then
46469: LD_VAR 0 5
46473: PUSH
46474: LD_INT 32
46476: PUSH
46477: LD_INT 33
46479: PUSH
46480: EMPTY
46481: LIST
46482: LIST
46483: IN
46484: IFFALSE 46774
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
46486: LD_ADDR_EXP 58
46490: PUSH
46491: LD_EXP 58
46495: PPUSH
46496: LD_VAR 0 3
46500: PUSH
46501: LD_EXP 58
46505: PUSH
46506: LD_VAR 0 3
46510: ARRAY
46511: PUSH
46512: LD_INT 1
46514: PLUS
46515: PUSH
46516: EMPTY
46517: LIST
46518: LIST
46519: PPUSH
46520: LD_VAR 0 1
46524: PPUSH
46525: CALL 52351 0 3
46529: ST_TO_ADDR
// if btype = b_bunker then
46530: LD_VAR 0 5
46534: PUSH
46535: LD_INT 32
46537: EQUAL
46538: IFFALSE 46774
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
46540: LD_ADDR_EXP 59
46544: PUSH
46545: LD_EXP 59
46549: PPUSH
46550: LD_VAR 0 3
46554: PUSH
46555: LD_EXP 59
46559: PUSH
46560: LD_VAR 0 3
46564: ARRAY
46565: PUSH
46566: LD_INT 1
46568: PLUS
46569: PUSH
46570: EMPTY
46571: LIST
46572: LIST
46573: PPUSH
46574: LD_VAR 0 1
46578: PPUSH
46579: CALL 52351 0 3
46583: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
46584: LD_ADDR_VAR 0 6
46588: PUSH
46589: LD_EXP 50
46593: PUSH
46594: LD_VAR 0 3
46598: ARRAY
46599: PPUSH
46600: LD_INT 25
46602: PUSH
46603: LD_INT 1
46605: PUSH
46606: EMPTY
46607: LIST
46608: LIST
46609: PUSH
46610: LD_INT 3
46612: PUSH
46613: LD_INT 54
46615: PUSH
46616: EMPTY
46617: LIST
46618: PUSH
46619: EMPTY
46620: LIST
46621: LIST
46622: PUSH
46623: EMPTY
46624: LIST
46625: LIST
46626: PPUSH
46627: CALL_OW 72
46631: ST_TO_ADDR
// if tmp then
46632: LD_VAR 0 6
46636: IFFALSE 46642
// exit ;
46638: POP
46639: POP
46640: GO 46782
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
46642: LD_ADDR_VAR 0 6
46646: PUSH
46647: LD_EXP 50
46651: PUSH
46652: LD_VAR 0 3
46656: ARRAY
46657: PPUSH
46658: LD_INT 2
46660: PUSH
46661: LD_INT 30
46663: PUSH
46664: LD_INT 4
46666: PUSH
46667: EMPTY
46668: LIST
46669: LIST
46670: PUSH
46671: LD_INT 30
46673: PUSH
46674: LD_INT 5
46676: PUSH
46677: EMPTY
46678: LIST
46679: LIST
46680: PUSH
46681: EMPTY
46682: LIST
46683: LIST
46684: LIST
46685: PPUSH
46686: CALL_OW 72
46690: ST_TO_ADDR
// if not tmp then
46691: LD_VAR 0 6
46695: NOT
46696: IFFALSE 46702
// exit ;
46698: POP
46699: POP
46700: GO 46782
// for j in tmp do
46702: LD_ADDR_VAR 0 4
46706: PUSH
46707: LD_VAR 0 6
46711: PUSH
46712: FOR_IN
46713: IFFALSE 46772
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
46715: LD_ADDR_VAR 0 7
46719: PUSH
46720: LD_VAR 0 4
46724: PPUSH
46725: CALL_OW 313
46729: PPUSH
46730: LD_INT 25
46732: PUSH
46733: LD_INT 1
46735: PUSH
46736: EMPTY
46737: LIST
46738: LIST
46739: PPUSH
46740: CALL_OW 72
46744: ST_TO_ADDR
// if units then
46745: LD_VAR 0 7
46749: IFFALSE 46770
// begin ComExitBuilding ( units [ 1 ] ) ;
46751: LD_VAR 0 7
46755: PUSH
46756: LD_INT 1
46758: ARRAY
46759: PPUSH
46760: CALL_OW 122
// exit ;
46764: POP
46765: POP
46766: POP
46767: POP
46768: GO 46782
// end ; end ;
46770: GO 46712
46772: POP
46773: POP
// end ; end ; exit ;
46774: POP
46775: POP
46776: GO 46782
// end ; end ;
46778: GO 46136
46780: POP
46781: POP
// end ;
46782: LD_VAR 0 2
46786: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
46787: LD_INT 0
46789: PPUSH
46790: PPUSH
46791: PPUSH
46792: PPUSH
46793: PPUSH
46794: PPUSH
46795: PPUSH
// if not mc_bases or not skirmish then
46796: LD_EXP 50
46800: NOT
46801: PUSH
46802: LD_EXP 48
46806: NOT
46807: OR
46808: IFFALSE 46812
// exit ;
46810: GO 47043
// btype := GetBType ( building ) ;
46812: LD_ADDR_VAR 0 6
46816: PUSH
46817: LD_VAR 0 1
46821: PPUSH
46822: CALL_OW 266
46826: ST_TO_ADDR
// x := GetX ( building ) ;
46827: LD_ADDR_VAR 0 7
46831: PUSH
46832: LD_VAR 0 1
46836: PPUSH
46837: CALL_OW 250
46841: ST_TO_ADDR
// y := GetY ( building ) ;
46842: LD_ADDR_VAR 0 8
46846: PUSH
46847: LD_VAR 0 1
46851: PPUSH
46852: CALL_OW 251
46856: ST_TO_ADDR
// d := GetDir ( building ) ;
46857: LD_ADDR_VAR 0 9
46861: PUSH
46862: LD_VAR 0 1
46866: PPUSH
46867: CALL_OW 254
46871: ST_TO_ADDR
// for i = 1 to mc_bases do
46872: LD_ADDR_VAR 0 4
46876: PUSH
46877: DOUBLE
46878: LD_INT 1
46880: DEC
46881: ST_TO_ADDR
46882: LD_EXP 50
46886: PUSH
46887: FOR_TO
46888: IFFALSE 47041
// begin if not mc_build_list [ i ] then
46890: LD_EXP 55
46894: PUSH
46895: LD_VAR 0 4
46899: ARRAY
46900: NOT
46901: IFFALSE 46905
// continue ;
46903: GO 46887
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
46905: LD_VAR 0 6
46909: PUSH
46910: LD_VAR 0 7
46914: PUSH
46915: LD_VAR 0 8
46919: PUSH
46920: LD_VAR 0 9
46924: PUSH
46925: EMPTY
46926: LIST
46927: LIST
46928: LIST
46929: LIST
46930: PPUSH
46931: LD_EXP 55
46935: PUSH
46936: LD_VAR 0 4
46940: ARRAY
46941: PUSH
46942: LD_INT 1
46944: ARRAY
46945: PPUSH
46946: CALL 58520 0 2
46950: IFFALSE 47039
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
46952: LD_ADDR_EXP 55
46956: PUSH
46957: LD_EXP 55
46961: PPUSH
46962: LD_VAR 0 4
46966: PPUSH
46967: LD_EXP 55
46971: PUSH
46972: LD_VAR 0 4
46976: ARRAY
46977: PPUSH
46978: LD_INT 1
46980: PPUSH
46981: CALL_OW 3
46985: PPUSH
46986: CALL_OW 1
46990: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
46991: LD_ADDR_EXP 57
46995: PUSH
46996: LD_EXP 57
47000: PPUSH
47001: LD_VAR 0 4
47005: PUSH
47006: LD_EXP 57
47010: PUSH
47011: LD_VAR 0 4
47015: ARRAY
47016: PUSH
47017: LD_INT 1
47019: PLUS
47020: PUSH
47021: EMPTY
47022: LIST
47023: LIST
47024: PPUSH
47025: LD_VAR 0 1
47029: PPUSH
47030: CALL 52351 0 3
47034: ST_TO_ADDR
// exit ;
47035: POP
47036: POP
47037: GO 47043
// end ; end ;
47039: GO 46887
47041: POP
47042: POP
// end ;
47043: LD_VAR 0 3
47047: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
47048: LD_INT 0
47050: PPUSH
47051: PPUSH
47052: PPUSH
// if not mc_bases or not skirmish then
47053: LD_EXP 50
47057: NOT
47058: PUSH
47059: LD_EXP 48
47063: NOT
47064: OR
47065: IFFALSE 47069
// exit ;
47067: GO 47259
// for i = 1 to mc_bases do
47069: LD_ADDR_VAR 0 4
47073: PUSH
47074: DOUBLE
47075: LD_INT 1
47077: DEC
47078: ST_TO_ADDR
47079: LD_EXP 50
47083: PUSH
47084: FOR_TO
47085: IFFALSE 47172
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
47087: LD_VAR 0 1
47091: PUSH
47092: LD_EXP 58
47096: PUSH
47097: LD_VAR 0 4
47101: ARRAY
47102: IN
47103: PUSH
47104: LD_VAR 0 1
47108: PUSH
47109: LD_EXP 59
47113: PUSH
47114: LD_VAR 0 4
47118: ARRAY
47119: IN
47120: NOT
47121: AND
47122: IFFALSE 47170
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
47124: LD_ADDR_EXP 59
47128: PUSH
47129: LD_EXP 59
47133: PPUSH
47134: LD_VAR 0 4
47138: PUSH
47139: LD_EXP 59
47143: PUSH
47144: LD_VAR 0 4
47148: ARRAY
47149: PUSH
47150: LD_INT 1
47152: PLUS
47153: PUSH
47154: EMPTY
47155: LIST
47156: LIST
47157: PPUSH
47158: LD_VAR 0 1
47162: PPUSH
47163: CALL 52351 0 3
47167: ST_TO_ADDR
// break ;
47168: GO 47172
// end ; end ;
47170: GO 47084
47172: POP
47173: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
47174: LD_VAR 0 1
47178: PPUSH
47179: CALL_OW 257
47183: PUSH
47184: LD_EXP 76
47188: IN
47189: PUSH
47190: LD_VAR 0 1
47194: PPUSH
47195: CALL_OW 266
47199: PUSH
47200: LD_INT 5
47202: EQUAL
47203: AND
47204: PUSH
47205: LD_VAR 0 2
47209: PPUSH
47210: CALL_OW 110
47214: PUSH
47215: LD_INT 18
47217: NONEQUAL
47218: AND
47219: IFFALSE 47259
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
47221: LD_VAR 0 2
47225: PPUSH
47226: CALL_OW 257
47230: PUSH
47231: LD_INT 5
47233: PUSH
47234: LD_INT 8
47236: PUSH
47237: LD_INT 9
47239: PUSH
47240: EMPTY
47241: LIST
47242: LIST
47243: LIST
47244: IN
47245: IFFALSE 47259
// SetClass ( unit , 1 ) ;
47247: LD_VAR 0 2
47251: PPUSH
47252: LD_INT 1
47254: PPUSH
47255: CALL_OW 336
// end ;
47259: LD_VAR 0 3
47263: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
47264: LD_INT 0
47266: PPUSH
47267: PPUSH
// if not mc_bases or not skirmish then
47268: LD_EXP 50
47272: NOT
47273: PUSH
47274: LD_EXP 48
47278: NOT
47279: OR
47280: IFFALSE 47284
// exit ;
47282: GO 47400
// if GetLives ( abandoned_vehicle ) > 250 then
47284: LD_VAR 0 2
47288: PPUSH
47289: CALL_OW 256
47293: PUSH
47294: LD_INT 250
47296: GREATER
47297: IFFALSE 47301
// exit ;
47299: GO 47400
// for i = 1 to mc_bases do
47301: LD_ADDR_VAR 0 6
47305: PUSH
47306: DOUBLE
47307: LD_INT 1
47309: DEC
47310: ST_TO_ADDR
47311: LD_EXP 50
47315: PUSH
47316: FOR_TO
47317: IFFALSE 47398
// begin if driver in mc_bases [ i ] then
47319: LD_VAR 0 1
47323: PUSH
47324: LD_EXP 50
47328: PUSH
47329: LD_VAR 0 6
47333: ARRAY
47334: IN
47335: IFFALSE 47396
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
47337: LD_VAR 0 1
47341: PPUSH
47342: LD_EXP 50
47346: PUSH
47347: LD_VAR 0 6
47351: ARRAY
47352: PPUSH
47353: LD_INT 2
47355: PUSH
47356: LD_INT 30
47358: PUSH
47359: LD_INT 0
47361: PUSH
47362: EMPTY
47363: LIST
47364: LIST
47365: PUSH
47366: LD_INT 30
47368: PUSH
47369: LD_INT 1
47371: PUSH
47372: EMPTY
47373: LIST
47374: LIST
47375: PUSH
47376: EMPTY
47377: LIST
47378: LIST
47379: LIST
47380: PPUSH
47381: CALL_OW 72
47385: PUSH
47386: LD_INT 1
47388: ARRAY
47389: PPUSH
47390: CALL_OW 112
// break ;
47394: GO 47398
// end ; end ;
47396: GO 47316
47398: POP
47399: POP
// end ; end_of_file
47400: LD_VAR 0 5
47404: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
47405: LD_INT 0
47407: PPUSH
47408: PPUSH
// if exist_mode then
47409: LD_VAR 0 2
47413: IFFALSE 47438
// unit := CreateCharacter ( prefix & ident ) else
47415: LD_ADDR_VAR 0 5
47419: PUSH
47420: LD_VAR 0 3
47424: PUSH
47425: LD_VAR 0 1
47429: STR
47430: PPUSH
47431: CALL_OW 34
47435: ST_TO_ADDR
47436: GO 47453
// unit := NewCharacter ( ident ) ;
47438: LD_ADDR_VAR 0 5
47442: PUSH
47443: LD_VAR 0 1
47447: PPUSH
47448: CALL_OW 25
47452: ST_TO_ADDR
// result := unit ;
47453: LD_ADDR_VAR 0 4
47457: PUSH
47458: LD_VAR 0 5
47462: ST_TO_ADDR
// end ;
47463: LD_VAR 0 4
47467: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
47468: LD_INT 0
47470: PPUSH
47471: PPUSH
// if not side or not nation then
47472: LD_VAR 0 1
47476: NOT
47477: PUSH
47478: LD_VAR 0 2
47482: NOT
47483: OR
47484: IFFALSE 47488
// exit ;
47486: GO 48252
// case nation of nation_american :
47488: LD_VAR 0 2
47492: PUSH
47493: LD_INT 1
47495: DOUBLE
47496: EQUAL
47497: IFTRUE 47501
47499: GO 47715
47501: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
47502: LD_ADDR_VAR 0 4
47506: PUSH
47507: LD_INT 35
47509: PUSH
47510: LD_INT 45
47512: PUSH
47513: LD_INT 46
47515: PUSH
47516: LD_INT 47
47518: PUSH
47519: LD_INT 82
47521: PUSH
47522: LD_INT 83
47524: PUSH
47525: LD_INT 84
47527: PUSH
47528: LD_INT 85
47530: PUSH
47531: LD_INT 86
47533: PUSH
47534: LD_INT 1
47536: PUSH
47537: LD_INT 2
47539: PUSH
47540: LD_INT 6
47542: PUSH
47543: LD_INT 15
47545: PUSH
47546: LD_INT 16
47548: PUSH
47549: LD_INT 7
47551: PUSH
47552: LD_INT 12
47554: PUSH
47555: LD_INT 13
47557: PUSH
47558: LD_INT 10
47560: PUSH
47561: LD_INT 14
47563: PUSH
47564: LD_INT 20
47566: PUSH
47567: LD_INT 21
47569: PUSH
47570: LD_INT 22
47572: PUSH
47573: LD_INT 25
47575: PUSH
47576: LD_INT 32
47578: PUSH
47579: LD_INT 27
47581: PUSH
47582: LD_INT 36
47584: PUSH
47585: LD_INT 69
47587: PUSH
47588: LD_INT 39
47590: PUSH
47591: LD_INT 34
47593: PUSH
47594: LD_INT 40
47596: PUSH
47597: LD_INT 48
47599: PUSH
47600: LD_INT 49
47602: PUSH
47603: LD_INT 50
47605: PUSH
47606: LD_INT 51
47608: PUSH
47609: LD_INT 52
47611: PUSH
47612: LD_INT 53
47614: PUSH
47615: LD_INT 54
47617: PUSH
47618: LD_INT 55
47620: PUSH
47621: LD_INT 56
47623: PUSH
47624: LD_INT 57
47626: PUSH
47627: LD_INT 58
47629: PUSH
47630: LD_INT 59
47632: PUSH
47633: LD_INT 60
47635: PUSH
47636: LD_INT 61
47638: PUSH
47639: LD_INT 62
47641: PUSH
47642: LD_INT 80
47644: PUSH
47645: LD_INT 82
47647: PUSH
47648: LD_INT 83
47650: PUSH
47651: LD_INT 84
47653: PUSH
47654: LD_INT 85
47656: PUSH
47657: LD_INT 86
47659: PUSH
47660: EMPTY
47661: LIST
47662: LIST
47663: LIST
47664: LIST
47665: LIST
47666: LIST
47667: LIST
47668: LIST
47669: LIST
47670: LIST
47671: LIST
47672: LIST
47673: LIST
47674: LIST
47675: LIST
47676: LIST
47677: LIST
47678: LIST
47679: LIST
47680: LIST
47681: LIST
47682: LIST
47683: LIST
47684: LIST
47685: LIST
47686: LIST
47687: LIST
47688: LIST
47689: LIST
47690: LIST
47691: LIST
47692: LIST
47693: LIST
47694: LIST
47695: LIST
47696: LIST
47697: LIST
47698: LIST
47699: LIST
47700: LIST
47701: LIST
47702: LIST
47703: LIST
47704: LIST
47705: LIST
47706: LIST
47707: LIST
47708: LIST
47709: LIST
47710: LIST
47711: LIST
47712: ST_TO_ADDR
47713: GO 48176
47715: LD_INT 2
47717: DOUBLE
47718: EQUAL
47719: IFTRUE 47723
47721: GO 47945
47723: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
47724: LD_ADDR_VAR 0 4
47728: PUSH
47729: LD_INT 35
47731: PUSH
47732: LD_INT 45
47734: PUSH
47735: LD_INT 46
47737: PUSH
47738: LD_INT 47
47740: PUSH
47741: LD_INT 82
47743: PUSH
47744: LD_INT 83
47746: PUSH
47747: LD_INT 84
47749: PUSH
47750: LD_INT 85
47752: PUSH
47753: LD_INT 87
47755: PUSH
47756: LD_INT 70
47758: PUSH
47759: LD_INT 1
47761: PUSH
47762: LD_INT 11
47764: PUSH
47765: LD_INT 3
47767: PUSH
47768: LD_INT 4
47770: PUSH
47771: LD_INT 5
47773: PUSH
47774: LD_INT 6
47776: PUSH
47777: LD_INT 15
47779: PUSH
47780: LD_INT 18
47782: PUSH
47783: LD_INT 7
47785: PUSH
47786: LD_INT 17
47788: PUSH
47789: LD_INT 8
47791: PUSH
47792: LD_INT 20
47794: PUSH
47795: LD_INT 21
47797: PUSH
47798: LD_INT 22
47800: PUSH
47801: LD_INT 72
47803: PUSH
47804: LD_INT 26
47806: PUSH
47807: LD_INT 69
47809: PUSH
47810: LD_INT 39
47812: PUSH
47813: LD_INT 40
47815: PUSH
47816: LD_INT 41
47818: PUSH
47819: LD_INT 42
47821: PUSH
47822: LD_INT 43
47824: PUSH
47825: LD_INT 48
47827: PUSH
47828: LD_INT 49
47830: PUSH
47831: LD_INT 50
47833: PUSH
47834: LD_INT 51
47836: PUSH
47837: LD_INT 52
47839: PUSH
47840: LD_INT 53
47842: PUSH
47843: LD_INT 54
47845: PUSH
47846: LD_INT 55
47848: PUSH
47849: LD_INT 56
47851: PUSH
47852: LD_INT 60
47854: PUSH
47855: LD_INT 61
47857: PUSH
47858: LD_INT 62
47860: PUSH
47861: LD_INT 66
47863: PUSH
47864: LD_INT 67
47866: PUSH
47867: LD_INT 68
47869: PUSH
47870: LD_INT 81
47872: PUSH
47873: LD_INT 82
47875: PUSH
47876: LD_INT 83
47878: PUSH
47879: LD_INT 84
47881: PUSH
47882: LD_INT 85
47884: PUSH
47885: LD_INT 87
47887: PUSH
47888: EMPTY
47889: LIST
47890: LIST
47891: LIST
47892: LIST
47893: LIST
47894: LIST
47895: LIST
47896: LIST
47897: LIST
47898: LIST
47899: LIST
47900: LIST
47901: LIST
47902: LIST
47903: LIST
47904: LIST
47905: LIST
47906: LIST
47907: LIST
47908: LIST
47909: LIST
47910: LIST
47911: LIST
47912: LIST
47913: LIST
47914: LIST
47915: LIST
47916: LIST
47917: LIST
47918: LIST
47919: LIST
47920: LIST
47921: LIST
47922: LIST
47923: LIST
47924: LIST
47925: LIST
47926: LIST
47927: LIST
47928: LIST
47929: LIST
47930: LIST
47931: LIST
47932: LIST
47933: LIST
47934: LIST
47935: LIST
47936: LIST
47937: LIST
47938: LIST
47939: LIST
47940: LIST
47941: LIST
47942: ST_TO_ADDR
47943: GO 48176
47945: LD_INT 3
47947: DOUBLE
47948: EQUAL
47949: IFTRUE 47953
47951: GO 48175
47953: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
47954: LD_ADDR_VAR 0 4
47958: PUSH
47959: LD_INT 46
47961: PUSH
47962: LD_INT 47
47964: PUSH
47965: LD_INT 1
47967: PUSH
47968: LD_INT 2
47970: PUSH
47971: LD_INT 82
47973: PUSH
47974: LD_INT 83
47976: PUSH
47977: LD_INT 84
47979: PUSH
47980: LD_INT 85
47982: PUSH
47983: LD_INT 86
47985: PUSH
47986: LD_INT 11
47988: PUSH
47989: LD_INT 9
47991: PUSH
47992: LD_INT 20
47994: PUSH
47995: LD_INT 19
47997: PUSH
47998: LD_INT 21
48000: PUSH
48001: LD_INT 24
48003: PUSH
48004: LD_INT 22
48006: PUSH
48007: LD_INT 25
48009: PUSH
48010: LD_INT 28
48012: PUSH
48013: LD_INT 29
48015: PUSH
48016: LD_INT 30
48018: PUSH
48019: LD_INT 31
48021: PUSH
48022: LD_INT 37
48024: PUSH
48025: LD_INT 38
48027: PUSH
48028: LD_INT 32
48030: PUSH
48031: LD_INT 27
48033: PUSH
48034: LD_INT 33
48036: PUSH
48037: LD_INT 69
48039: PUSH
48040: LD_INT 39
48042: PUSH
48043: LD_INT 34
48045: PUSH
48046: LD_INT 40
48048: PUSH
48049: LD_INT 71
48051: PUSH
48052: LD_INT 23
48054: PUSH
48055: LD_INT 44
48057: PUSH
48058: LD_INT 48
48060: PUSH
48061: LD_INT 49
48063: PUSH
48064: LD_INT 50
48066: PUSH
48067: LD_INT 51
48069: PUSH
48070: LD_INT 52
48072: PUSH
48073: LD_INT 53
48075: PUSH
48076: LD_INT 54
48078: PUSH
48079: LD_INT 55
48081: PUSH
48082: LD_INT 56
48084: PUSH
48085: LD_INT 57
48087: PUSH
48088: LD_INT 58
48090: PUSH
48091: LD_INT 59
48093: PUSH
48094: LD_INT 63
48096: PUSH
48097: LD_INT 64
48099: PUSH
48100: LD_INT 65
48102: PUSH
48103: LD_INT 82
48105: PUSH
48106: LD_INT 83
48108: PUSH
48109: LD_INT 84
48111: PUSH
48112: LD_INT 85
48114: PUSH
48115: LD_INT 86
48117: PUSH
48118: EMPTY
48119: LIST
48120: LIST
48121: LIST
48122: LIST
48123: LIST
48124: LIST
48125: LIST
48126: LIST
48127: LIST
48128: LIST
48129: LIST
48130: LIST
48131: LIST
48132: LIST
48133: LIST
48134: LIST
48135: LIST
48136: LIST
48137: LIST
48138: LIST
48139: LIST
48140: LIST
48141: LIST
48142: LIST
48143: LIST
48144: LIST
48145: LIST
48146: LIST
48147: LIST
48148: LIST
48149: LIST
48150: LIST
48151: LIST
48152: LIST
48153: LIST
48154: LIST
48155: LIST
48156: LIST
48157: LIST
48158: LIST
48159: LIST
48160: LIST
48161: LIST
48162: LIST
48163: LIST
48164: LIST
48165: LIST
48166: LIST
48167: LIST
48168: LIST
48169: LIST
48170: LIST
48171: LIST
48172: ST_TO_ADDR
48173: GO 48176
48175: POP
// if state > - 1 and state < 3 then
48176: LD_VAR 0 3
48180: PUSH
48181: LD_INT 1
48183: NEG
48184: GREATER
48185: PUSH
48186: LD_VAR 0 3
48190: PUSH
48191: LD_INT 3
48193: LESS
48194: AND
48195: IFFALSE 48252
// for i in result do
48197: LD_ADDR_VAR 0 5
48201: PUSH
48202: LD_VAR 0 4
48206: PUSH
48207: FOR_IN
48208: IFFALSE 48250
// if GetTech ( i , side ) <> state then
48210: LD_VAR 0 5
48214: PPUSH
48215: LD_VAR 0 1
48219: PPUSH
48220: CALL_OW 321
48224: PUSH
48225: LD_VAR 0 3
48229: NONEQUAL
48230: IFFALSE 48248
// result := result diff i ;
48232: LD_ADDR_VAR 0 4
48236: PUSH
48237: LD_VAR 0 4
48241: PUSH
48242: LD_VAR 0 5
48246: DIFF
48247: ST_TO_ADDR
48248: GO 48207
48250: POP
48251: POP
// end ;
48252: LD_VAR 0 4
48256: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
48257: LD_INT 0
48259: PPUSH
48260: PPUSH
48261: PPUSH
// result := true ;
48262: LD_ADDR_VAR 0 3
48266: PUSH
48267: LD_INT 1
48269: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
48270: LD_ADDR_VAR 0 5
48274: PUSH
48275: LD_VAR 0 2
48279: PPUSH
48280: CALL_OW 480
48284: ST_TO_ADDR
// if not tmp then
48285: LD_VAR 0 5
48289: NOT
48290: IFFALSE 48294
// exit ;
48292: GO 48343
// for i in tmp do
48294: LD_ADDR_VAR 0 4
48298: PUSH
48299: LD_VAR 0 5
48303: PUSH
48304: FOR_IN
48305: IFFALSE 48341
// if GetTech ( i , side ) <> state_researched then
48307: LD_VAR 0 4
48311: PPUSH
48312: LD_VAR 0 1
48316: PPUSH
48317: CALL_OW 321
48321: PUSH
48322: LD_INT 2
48324: NONEQUAL
48325: IFFALSE 48339
// begin result := false ;
48327: LD_ADDR_VAR 0 3
48331: PUSH
48332: LD_INT 0
48334: ST_TO_ADDR
// exit ;
48335: POP
48336: POP
48337: GO 48343
// end ;
48339: GO 48304
48341: POP
48342: POP
// end ;
48343: LD_VAR 0 3
48347: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
48348: LD_INT 0
48350: PPUSH
48351: PPUSH
48352: PPUSH
48353: PPUSH
48354: PPUSH
48355: PPUSH
48356: PPUSH
48357: PPUSH
48358: PPUSH
48359: PPUSH
48360: PPUSH
48361: PPUSH
48362: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
48363: LD_VAR 0 1
48367: NOT
48368: PUSH
48369: LD_VAR 0 1
48373: PPUSH
48374: CALL_OW 257
48378: PUSH
48379: LD_INT 9
48381: NONEQUAL
48382: OR
48383: IFFALSE 48387
// exit ;
48385: GO 48960
// side := GetSide ( unit ) ;
48387: LD_ADDR_VAR 0 9
48391: PUSH
48392: LD_VAR 0 1
48396: PPUSH
48397: CALL_OW 255
48401: ST_TO_ADDR
// tech_space := tech_spacanom ;
48402: LD_ADDR_VAR 0 12
48406: PUSH
48407: LD_INT 29
48409: ST_TO_ADDR
// tech_time := tech_taurad ;
48410: LD_ADDR_VAR 0 13
48414: PUSH
48415: LD_INT 28
48417: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
48418: LD_ADDR_VAR 0 11
48422: PUSH
48423: LD_VAR 0 1
48427: PPUSH
48428: CALL_OW 310
48432: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
48433: LD_VAR 0 11
48437: PPUSH
48438: CALL_OW 247
48442: PUSH
48443: LD_INT 2
48445: EQUAL
48446: IFFALSE 48450
// exit ;
48448: GO 48960
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
48450: LD_ADDR_VAR 0 8
48454: PUSH
48455: LD_INT 81
48457: PUSH
48458: LD_VAR 0 9
48462: PUSH
48463: EMPTY
48464: LIST
48465: LIST
48466: PUSH
48467: LD_INT 3
48469: PUSH
48470: LD_INT 21
48472: PUSH
48473: LD_INT 3
48475: PUSH
48476: EMPTY
48477: LIST
48478: LIST
48479: PUSH
48480: EMPTY
48481: LIST
48482: LIST
48483: PUSH
48484: EMPTY
48485: LIST
48486: LIST
48487: PPUSH
48488: CALL_OW 69
48492: ST_TO_ADDR
// if not tmp then
48493: LD_VAR 0 8
48497: NOT
48498: IFFALSE 48502
// exit ;
48500: GO 48960
// if in_unit then
48502: LD_VAR 0 11
48506: IFFALSE 48530
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
48508: LD_ADDR_VAR 0 10
48512: PUSH
48513: LD_VAR 0 8
48517: PPUSH
48518: LD_VAR 0 11
48522: PPUSH
48523: CALL_OW 74
48527: ST_TO_ADDR
48528: GO 48550
// enemy := NearestUnitToUnit ( tmp , unit ) ;
48530: LD_ADDR_VAR 0 10
48534: PUSH
48535: LD_VAR 0 8
48539: PPUSH
48540: LD_VAR 0 1
48544: PPUSH
48545: CALL_OW 74
48549: ST_TO_ADDR
// if not enemy then
48550: LD_VAR 0 10
48554: NOT
48555: IFFALSE 48559
// exit ;
48557: GO 48960
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
48559: LD_VAR 0 11
48563: PUSH
48564: LD_VAR 0 11
48568: PPUSH
48569: LD_VAR 0 10
48573: PPUSH
48574: CALL_OW 296
48578: PUSH
48579: LD_INT 13
48581: GREATER
48582: AND
48583: PUSH
48584: LD_VAR 0 1
48588: PPUSH
48589: LD_VAR 0 10
48593: PPUSH
48594: CALL_OW 296
48598: PUSH
48599: LD_INT 12
48601: GREATER
48602: OR
48603: IFFALSE 48607
// exit ;
48605: GO 48960
// missile := [ 1 ] ;
48607: LD_ADDR_VAR 0 14
48611: PUSH
48612: LD_INT 1
48614: PUSH
48615: EMPTY
48616: LIST
48617: ST_TO_ADDR
// if Researched ( side , tech_space ) then
48618: LD_VAR 0 9
48622: PPUSH
48623: LD_VAR 0 12
48627: PPUSH
48628: CALL_OW 325
48632: IFFALSE 48661
// missile := Insert ( missile , missile + 1 , 2 ) ;
48634: LD_ADDR_VAR 0 14
48638: PUSH
48639: LD_VAR 0 14
48643: PPUSH
48644: LD_VAR 0 14
48648: PUSH
48649: LD_INT 1
48651: PLUS
48652: PPUSH
48653: LD_INT 2
48655: PPUSH
48656: CALL_OW 2
48660: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
48661: LD_VAR 0 9
48665: PPUSH
48666: LD_VAR 0 13
48670: PPUSH
48671: CALL_OW 325
48675: PUSH
48676: LD_VAR 0 10
48680: PPUSH
48681: CALL_OW 255
48685: PPUSH
48686: LD_VAR 0 13
48690: PPUSH
48691: CALL_OW 325
48695: NOT
48696: AND
48697: IFFALSE 48726
// missile := Insert ( missile , missile + 1 , 3 ) ;
48699: LD_ADDR_VAR 0 14
48703: PUSH
48704: LD_VAR 0 14
48708: PPUSH
48709: LD_VAR 0 14
48713: PUSH
48714: LD_INT 1
48716: PLUS
48717: PPUSH
48718: LD_INT 3
48720: PPUSH
48721: CALL_OW 2
48725: ST_TO_ADDR
// if missile < 2 then
48726: LD_VAR 0 14
48730: PUSH
48731: LD_INT 2
48733: LESS
48734: IFFALSE 48738
// exit ;
48736: GO 48960
// x := GetX ( enemy ) ;
48738: LD_ADDR_VAR 0 4
48742: PUSH
48743: LD_VAR 0 10
48747: PPUSH
48748: CALL_OW 250
48752: ST_TO_ADDR
// y := GetY ( enemy ) ;
48753: LD_ADDR_VAR 0 5
48757: PUSH
48758: LD_VAR 0 10
48762: PPUSH
48763: CALL_OW 251
48767: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
48768: LD_ADDR_VAR 0 6
48772: PUSH
48773: LD_VAR 0 4
48777: PUSH
48778: LD_INT 1
48780: NEG
48781: PPUSH
48782: LD_INT 1
48784: PPUSH
48785: CALL_OW 12
48789: PLUS
48790: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
48791: LD_ADDR_VAR 0 7
48795: PUSH
48796: LD_VAR 0 5
48800: PUSH
48801: LD_INT 1
48803: NEG
48804: PPUSH
48805: LD_INT 1
48807: PPUSH
48808: CALL_OW 12
48812: PLUS
48813: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
48814: LD_VAR 0 6
48818: PPUSH
48819: LD_VAR 0 7
48823: PPUSH
48824: CALL_OW 488
48828: NOT
48829: IFFALSE 48851
// begin _x := x ;
48831: LD_ADDR_VAR 0 6
48835: PUSH
48836: LD_VAR 0 4
48840: ST_TO_ADDR
// _y := y ;
48841: LD_ADDR_VAR 0 7
48845: PUSH
48846: LD_VAR 0 5
48850: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
48851: LD_ADDR_VAR 0 3
48855: PUSH
48856: LD_INT 1
48858: PPUSH
48859: LD_VAR 0 14
48863: PPUSH
48864: CALL_OW 12
48868: ST_TO_ADDR
// case i of 1 :
48869: LD_VAR 0 3
48873: PUSH
48874: LD_INT 1
48876: DOUBLE
48877: EQUAL
48878: IFTRUE 48882
48880: GO 48899
48882: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
48883: LD_VAR 0 1
48887: PPUSH
48888: LD_VAR 0 10
48892: PPUSH
48893: CALL_OW 115
48897: GO 48960
48899: LD_INT 2
48901: DOUBLE
48902: EQUAL
48903: IFTRUE 48907
48905: GO 48929
48907: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
48908: LD_VAR 0 1
48912: PPUSH
48913: LD_VAR 0 6
48917: PPUSH
48918: LD_VAR 0 7
48922: PPUSH
48923: CALL_OW 153
48927: GO 48960
48929: LD_INT 3
48931: DOUBLE
48932: EQUAL
48933: IFTRUE 48937
48935: GO 48959
48937: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
48938: LD_VAR 0 1
48942: PPUSH
48943: LD_VAR 0 6
48947: PPUSH
48948: LD_VAR 0 7
48952: PPUSH
48953: CALL_OW 154
48957: GO 48960
48959: POP
// end ;
48960: LD_VAR 0 2
48964: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
48965: LD_INT 0
48967: PPUSH
48968: PPUSH
48969: PPUSH
48970: PPUSH
48971: PPUSH
48972: PPUSH
// if not unit or not building then
48973: LD_VAR 0 1
48977: NOT
48978: PUSH
48979: LD_VAR 0 2
48983: NOT
48984: OR
48985: IFFALSE 48989
// exit ;
48987: GO 49147
// x := GetX ( building ) ;
48989: LD_ADDR_VAR 0 5
48993: PUSH
48994: LD_VAR 0 2
48998: PPUSH
48999: CALL_OW 250
49003: ST_TO_ADDR
// y := GetY ( building ) ;
49004: LD_ADDR_VAR 0 6
49008: PUSH
49009: LD_VAR 0 2
49013: PPUSH
49014: CALL_OW 251
49018: ST_TO_ADDR
// for i = 0 to 5 do
49019: LD_ADDR_VAR 0 4
49023: PUSH
49024: DOUBLE
49025: LD_INT 0
49027: DEC
49028: ST_TO_ADDR
49029: LD_INT 5
49031: PUSH
49032: FOR_TO
49033: IFFALSE 49145
// begin _x := ShiftX ( x , i , 3 ) ;
49035: LD_ADDR_VAR 0 7
49039: PUSH
49040: LD_VAR 0 5
49044: PPUSH
49045: LD_VAR 0 4
49049: PPUSH
49050: LD_INT 3
49052: PPUSH
49053: CALL_OW 272
49057: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
49058: LD_ADDR_VAR 0 8
49062: PUSH
49063: LD_VAR 0 6
49067: PPUSH
49068: LD_VAR 0 4
49072: PPUSH
49073: LD_INT 3
49075: PPUSH
49076: CALL_OW 273
49080: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
49081: LD_VAR 0 7
49085: PPUSH
49086: LD_VAR 0 8
49090: PPUSH
49091: CALL_OW 488
49095: NOT
49096: IFFALSE 49100
// continue ;
49098: GO 49032
// if HexInfo ( _x , _y ) = 0 then
49100: LD_VAR 0 7
49104: PPUSH
49105: LD_VAR 0 8
49109: PPUSH
49110: CALL_OW 428
49114: PUSH
49115: LD_INT 0
49117: EQUAL
49118: IFFALSE 49143
// begin ComMoveXY ( unit , _x , _y ) ;
49120: LD_VAR 0 1
49124: PPUSH
49125: LD_VAR 0 7
49129: PPUSH
49130: LD_VAR 0 8
49134: PPUSH
49135: CALL_OW 111
// exit ;
49139: POP
49140: POP
49141: GO 49147
// end ; end ;
49143: GO 49032
49145: POP
49146: POP
// end ;
49147: LD_VAR 0 3
49151: RET
// export function ScanBase ( side , base_area ) ; begin
49152: LD_INT 0
49154: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
49155: LD_ADDR_VAR 0 3
49159: PUSH
49160: LD_VAR 0 2
49164: PPUSH
49165: LD_INT 81
49167: PUSH
49168: LD_VAR 0 1
49172: PUSH
49173: EMPTY
49174: LIST
49175: LIST
49176: PPUSH
49177: CALL_OW 70
49181: ST_TO_ADDR
// end ;
49182: LD_VAR 0 3
49186: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
49187: LD_INT 0
49189: PPUSH
49190: PPUSH
49191: PPUSH
49192: PPUSH
// result := false ;
49193: LD_ADDR_VAR 0 2
49197: PUSH
49198: LD_INT 0
49200: ST_TO_ADDR
// side := GetSide ( unit ) ;
49201: LD_ADDR_VAR 0 3
49205: PUSH
49206: LD_VAR 0 1
49210: PPUSH
49211: CALL_OW 255
49215: ST_TO_ADDR
// nat := GetNation ( unit ) ;
49216: LD_ADDR_VAR 0 4
49220: PUSH
49221: LD_VAR 0 1
49225: PPUSH
49226: CALL_OW 248
49230: ST_TO_ADDR
// case nat of 1 :
49231: LD_VAR 0 4
49235: PUSH
49236: LD_INT 1
49238: DOUBLE
49239: EQUAL
49240: IFTRUE 49244
49242: GO 49255
49244: POP
// tech := tech_lassight ; 2 :
49245: LD_ADDR_VAR 0 5
49249: PUSH
49250: LD_INT 12
49252: ST_TO_ADDR
49253: GO 49294
49255: LD_INT 2
49257: DOUBLE
49258: EQUAL
49259: IFTRUE 49263
49261: GO 49274
49263: POP
// tech := tech_mortar ; 3 :
49264: LD_ADDR_VAR 0 5
49268: PUSH
49269: LD_INT 41
49271: ST_TO_ADDR
49272: GO 49294
49274: LD_INT 3
49276: DOUBLE
49277: EQUAL
49278: IFTRUE 49282
49280: GO 49293
49282: POP
// tech := tech_bazooka ; end ;
49283: LD_ADDR_VAR 0 5
49287: PUSH
49288: LD_INT 44
49290: ST_TO_ADDR
49291: GO 49294
49293: POP
// if Researched ( side , tech ) then
49294: LD_VAR 0 3
49298: PPUSH
49299: LD_VAR 0 5
49303: PPUSH
49304: CALL_OW 325
49308: IFFALSE 49335
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
49310: LD_ADDR_VAR 0 2
49314: PUSH
49315: LD_INT 5
49317: PUSH
49318: LD_INT 8
49320: PUSH
49321: LD_INT 9
49323: PUSH
49324: EMPTY
49325: LIST
49326: LIST
49327: LIST
49328: PUSH
49329: LD_VAR 0 4
49333: ARRAY
49334: ST_TO_ADDR
// end ;
49335: LD_VAR 0 2
49339: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
49340: LD_INT 0
49342: PPUSH
49343: PPUSH
49344: PPUSH
// if not mines then
49345: LD_VAR 0 2
49349: NOT
49350: IFFALSE 49354
// exit ;
49352: GO 49498
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
49354: LD_ADDR_VAR 0 5
49358: PUSH
49359: LD_INT 81
49361: PUSH
49362: LD_VAR 0 1
49366: PUSH
49367: EMPTY
49368: LIST
49369: LIST
49370: PUSH
49371: LD_INT 3
49373: PUSH
49374: LD_INT 21
49376: PUSH
49377: LD_INT 3
49379: PUSH
49380: EMPTY
49381: LIST
49382: LIST
49383: PUSH
49384: EMPTY
49385: LIST
49386: LIST
49387: PUSH
49388: EMPTY
49389: LIST
49390: LIST
49391: PPUSH
49392: CALL_OW 69
49396: ST_TO_ADDR
// for i in mines do
49397: LD_ADDR_VAR 0 4
49401: PUSH
49402: LD_VAR 0 2
49406: PUSH
49407: FOR_IN
49408: IFFALSE 49496
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
49410: LD_VAR 0 4
49414: PUSH
49415: LD_INT 1
49417: ARRAY
49418: PPUSH
49419: LD_VAR 0 4
49423: PUSH
49424: LD_INT 2
49426: ARRAY
49427: PPUSH
49428: CALL_OW 458
49432: NOT
49433: IFFALSE 49437
// continue ;
49435: GO 49407
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
49437: LD_VAR 0 4
49441: PUSH
49442: LD_INT 1
49444: ARRAY
49445: PPUSH
49446: LD_VAR 0 4
49450: PUSH
49451: LD_INT 2
49453: ARRAY
49454: PPUSH
49455: CALL_OW 428
49459: PUSH
49460: LD_VAR 0 5
49464: IN
49465: IFFALSE 49494
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
49467: LD_VAR 0 4
49471: PUSH
49472: LD_INT 1
49474: ARRAY
49475: PPUSH
49476: LD_VAR 0 4
49480: PUSH
49481: LD_INT 2
49483: ARRAY
49484: PPUSH
49485: LD_VAR 0 1
49489: PPUSH
49490: CALL_OW 456
// end ;
49494: GO 49407
49496: POP
49497: POP
// end ;
49498: LD_VAR 0 3
49502: RET
// export function Count ( array ) ; var i ; begin
49503: LD_INT 0
49505: PPUSH
49506: PPUSH
// result := 0 ;
49507: LD_ADDR_VAR 0 2
49511: PUSH
49512: LD_INT 0
49514: ST_TO_ADDR
// for i in array do
49515: LD_ADDR_VAR 0 3
49519: PUSH
49520: LD_VAR 0 1
49524: PUSH
49525: FOR_IN
49526: IFFALSE 49550
// if i then
49528: LD_VAR 0 3
49532: IFFALSE 49548
// result := result + 1 ;
49534: LD_ADDR_VAR 0 2
49538: PUSH
49539: LD_VAR 0 2
49543: PUSH
49544: LD_INT 1
49546: PLUS
49547: ST_TO_ADDR
49548: GO 49525
49550: POP
49551: POP
// end ;
49552: LD_VAR 0 2
49556: RET
// export function IsEmpty ( building ) ; begin
49557: LD_INT 0
49559: PPUSH
// if not building then
49560: LD_VAR 0 1
49564: NOT
49565: IFFALSE 49569
// exit ;
49567: GO 49612
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
49569: LD_ADDR_VAR 0 2
49573: PUSH
49574: LD_VAR 0 1
49578: PUSH
49579: LD_INT 22
49581: PUSH
49582: LD_VAR 0 1
49586: PPUSH
49587: CALL_OW 255
49591: PUSH
49592: EMPTY
49593: LIST
49594: LIST
49595: PUSH
49596: LD_INT 58
49598: PUSH
49599: EMPTY
49600: LIST
49601: PUSH
49602: EMPTY
49603: LIST
49604: LIST
49605: PPUSH
49606: CALL_OW 69
49610: IN
49611: ST_TO_ADDR
// end ;
49612: LD_VAR 0 2
49616: RET
// export function IsNotFull ( building ) ; begin
49617: LD_INT 0
49619: PPUSH
// if not building then
49620: LD_VAR 0 1
49624: NOT
49625: IFFALSE 49629
// exit ;
49627: GO 49648
// result := UnitsInside ( building ) < 6 ;
49629: LD_ADDR_VAR 0 2
49633: PUSH
49634: LD_VAR 0 1
49638: PPUSH
49639: CALL_OW 313
49643: PUSH
49644: LD_INT 6
49646: LESS
49647: ST_TO_ADDR
// end ;
49648: LD_VAR 0 2
49652: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
49653: LD_INT 0
49655: PPUSH
49656: PPUSH
49657: PPUSH
49658: PPUSH
// tmp := [ ] ;
49659: LD_ADDR_VAR 0 3
49663: PUSH
49664: EMPTY
49665: ST_TO_ADDR
// list := [ ] ;
49666: LD_ADDR_VAR 0 5
49670: PUSH
49671: EMPTY
49672: ST_TO_ADDR
// for i = 16 to 25 do
49673: LD_ADDR_VAR 0 4
49677: PUSH
49678: DOUBLE
49679: LD_INT 16
49681: DEC
49682: ST_TO_ADDR
49683: LD_INT 25
49685: PUSH
49686: FOR_TO
49687: IFFALSE 49760
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
49689: LD_ADDR_VAR 0 3
49693: PUSH
49694: LD_VAR 0 3
49698: PUSH
49699: LD_INT 22
49701: PUSH
49702: LD_VAR 0 1
49706: PPUSH
49707: CALL_OW 255
49711: PUSH
49712: EMPTY
49713: LIST
49714: LIST
49715: PUSH
49716: LD_INT 91
49718: PUSH
49719: LD_VAR 0 1
49723: PUSH
49724: LD_INT 6
49726: PUSH
49727: EMPTY
49728: LIST
49729: LIST
49730: LIST
49731: PUSH
49732: LD_INT 30
49734: PUSH
49735: LD_VAR 0 4
49739: PUSH
49740: EMPTY
49741: LIST
49742: LIST
49743: PUSH
49744: EMPTY
49745: LIST
49746: LIST
49747: LIST
49748: PUSH
49749: EMPTY
49750: LIST
49751: PPUSH
49752: CALL_OW 69
49756: ADD
49757: ST_TO_ADDR
49758: GO 49686
49760: POP
49761: POP
// for i = 1 to tmp do
49762: LD_ADDR_VAR 0 4
49766: PUSH
49767: DOUBLE
49768: LD_INT 1
49770: DEC
49771: ST_TO_ADDR
49772: LD_VAR 0 3
49776: PUSH
49777: FOR_TO
49778: IFFALSE 49866
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
49780: LD_ADDR_VAR 0 5
49784: PUSH
49785: LD_VAR 0 5
49789: PUSH
49790: LD_VAR 0 3
49794: PUSH
49795: LD_VAR 0 4
49799: ARRAY
49800: PPUSH
49801: CALL_OW 266
49805: PUSH
49806: LD_VAR 0 3
49810: PUSH
49811: LD_VAR 0 4
49815: ARRAY
49816: PPUSH
49817: CALL_OW 250
49821: PUSH
49822: LD_VAR 0 3
49826: PUSH
49827: LD_VAR 0 4
49831: ARRAY
49832: PPUSH
49833: CALL_OW 251
49837: PUSH
49838: LD_VAR 0 3
49842: PUSH
49843: LD_VAR 0 4
49847: ARRAY
49848: PPUSH
49849: CALL_OW 254
49853: PUSH
49854: EMPTY
49855: LIST
49856: LIST
49857: LIST
49858: LIST
49859: PUSH
49860: EMPTY
49861: LIST
49862: ADD
49863: ST_TO_ADDR
49864: GO 49777
49866: POP
49867: POP
// result := list ;
49868: LD_ADDR_VAR 0 2
49872: PUSH
49873: LD_VAR 0 5
49877: ST_TO_ADDR
// end ;
49878: LD_VAR 0 2
49882: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
49883: LD_INT 0
49885: PPUSH
49886: PPUSH
49887: PPUSH
49888: PPUSH
49889: PPUSH
49890: PPUSH
49891: PPUSH
// if not factory then
49892: LD_VAR 0 1
49896: NOT
49897: IFFALSE 49901
// exit ;
49899: GO 50494
// if control = control_apeman then
49901: LD_VAR 0 4
49905: PUSH
49906: LD_INT 5
49908: EQUAL
49909: IFFALSE 50018
// begin tmp := UnitsInside ( factory ) ;
49911: LD_ADDR_VAR 0 8
49915: PUSH
49916: LD_VAR 0 1
49920: PPUSH
49921: CALL_OW 313
49925: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
49926: LD_VAR 0 8
49930: PPUSH
49931: LD_INT 25
49933: PUSH
49934: LD_INT 12
49936: PUSH
49937: EMPTY
49938: LIST
49939: LIST
49940: PPUSH
49941: CALL_OW 72
49945: NOT
49946: IFFALSE 49956
// control := control_manual ;
49948: LD_ADDR_VAR 0 4
49952: PUSH
49953: LD_INT 1
49955: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
49956: LD_ADDR_VAR 0 8
49960: PUSH
49961: LD_VAR 0 1
49965: PPUSH
49966: CALL 49653 0 1
49970: ST_TO_ADDR
// if tmp then
49971: LD_VAR 0 8
49975: IFFALSE 50018
// begin for i in tmp do
49977: LD_ADDR_VAR 0 7
49981: PUSH
49982: LD_VAR 0 8
49986: PUSH
49987: FOR_IN
49988: IFFALSE 50016
// if i [ 1 ] = b_ext_radio then
49990: LD_VAR 0 7
49994: PUSH
49995: LD_INT 1
49997: ARRAY
49998: PUSH
49999: LD_INT 22
50001: EQUAL
50002: IFFALSE 50014
// begin control := control_remote ;
50004: LD_ADDR_VAR 0 4
50008: PUSH
50009: LD_INT 2
50011: ST_TO_ADDR
// break ;
50012: GO 50016
// end ;
50014: GO 49987
50016: POP
50017: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
50018: LD_VAR 0 1
50022: PPUSH
50023: LD_VAR 0 2
50027: PPUSH
50028: LD_VAR 0 3
50032: PPUSH
50033: LD_VAR 0 4
50037: PPUSH
50038: LD_VAR 0 5
50042: PPUSH
50043: CALL_OW 448
50047: IFFALSE 50082
// begin result := [ chassis , engine , control , weapon ] ;
50049: LD_ADDR_VAR 0 6
50053: PUSH
50054: LD_VAR 0 2
50058: PUSH
50059: LD_VAR 0 3
50063: PUSH
50064: LD_VAR 0 4
50068: PUSH
50069: LD_VAR 0 5
50073: PUSH
50074: EMPTY
50075: LIST
50076: LIST
50077: LIST
50078: LIST
50079: ST_TO_ADDR
// exit ;
50080: GO 50494
// end ; _chassis := AvailableChassisList ( factory ) ;
50082: LD_ADDR_VAR 0 9
50086: PUSH
50087: LD_VAR 0 1
50091: PPUSH
50092: CALL_OW 475
50096: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
50097: LD_ADDR_VAR 0 11
50101: PUSH
50102: LD_VAR 0 1
50106: PPUSH
50107: CALL_OW 476
50111: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
50112: LD_ADDR_VAR 0 12
50116: PUSH
50117: LD_VAR 0 1
50121: PPUSH
50122: CALL_OW 477
50126: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
50127: LD_ADDR_VAR 0 10
50131: PUSH
50132: LD_VAR 0 1
50136: PPUSH
50137: CALL_OW 478
50141: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
50142: LD_VAR 0 9
50146: NOT
50147: PUSH
50148: LD_VAR 0 11
50152: NOT
50153: OR
50154: PUSH
50155: LD_VAR 0 12
50159: NOT
50160: OR
50161: PUSH
50162: LD_VAR 0 10
50166: NOT
50167: OR
50168: IFFALSE 50203
// begin result := [ chassis , engine , control , weapon ] ;
50170: LD_ADDR_VAR 0 6
50174: PUSH
50175: LD_VAR 0 2
50179: PUSH
50180: LD_VAR 0 3
50184: PUSH
50185: LD_VAR 0 4
50189: PUSH
50190: LD_VAR 0 5
50194: PUSH
50195: EMPTY
50196: LIST
50197: LIST
50198: LIST
50199: LIST
50200: ST_TO_ADDR
// exit ;
50201: GO 50494
// end ; if not chassis in _chassis then
50203: LD_VAR 0 2
50207: PUSH
50208: LD_VAR 0 9
50212: IN
50213: NOT
50214: IFFALSE 50240
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
50216: LD_ADDR_VAR 0 2
50220: PUSH
50221: LD_VAR 0 9
50225: PUSH
50226: LD_INT 1
50228: PPUSH
50229: LD_VAR 0 9
50233: PPUSH
50234: CALL_OW 12
50238: ARRAY
50239: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
50240: LD_VAR 0 2
50244: PPUSH
50245: LD_VAR 0 3
50249: PPUSH
50250: CALL 50499 0 2
50254: NOT
50255: IFFALSE 50314
// repeat engine := _engine [ 1 ] ;
50257: LD_ADDR_VAR 0 3
50261: PUSH
50262: LD_VAR 0 11
50266: PUSH
50267: LD_INT 1
50269: ARRAY
50270: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
50271: LD_ADDR_VAR 0 11
50275: PUSH
50276: LD_VAR 0 11
50280: PPUSH
50281: LD_INT 1
50283: PPUSH
50284: CALL_OW 3
50288: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
50289: LD_VAR 0 2
50293: PPUSH
50294: LD_VAR 0 3
50298: PPUSH
50299: CALL 50499 0 2
50303: PUSH
50304: LD_VAR 0 11
50308: PUSH
50309: EMPTY
50310: EQUAL
50311: OR
50312: IFFALSE 50257
// if not control in _control then
50314: LD_VAR 0 4
50318: PUSH
50319: LD_VAR 0 12
50323: IN
50324: NOT
50325: IFFALSE 50351
// control := _control [ rand ( 1 , _control ) ] ;
50327: LD_ADDR_VAR 0 4
50331: PUSH
50332: LD_VAR 0 12
50336: PUSH
50337: LD_INT 1
50339: PPUSH
50340: LD_VAR 0 12
50344: PPUSH
50345: CALL_OW 12
50349: ARRAY
50350: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
50351: LD_VAR 0 2
50355: PPUSH
50356: LD_VAR 0 5
50360: PPUSH
50361: CALL 50719 0 2
50365: NOT
50366: IFFALSE 50425
// repeat weapon := _weapon [ 1 ] ;
50368: LD_ADDR_VAR 0 5
50372: PUSH
50373: LD_VAR 0 10
50377: PUSH
50378: LD_INT 1
50380: ARRAY
50381: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
50382: LD_ADDR_VAR 0 10
50386: PUSH
50387: LD_VAR 0 10
50391: PPUSH
50392: LD_INT 1
50394: PPUSH
50395: CALL_OW 3
50399: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
50400: LD_VAR 0 2
50404: PPUSH
50405: LD_VAR 0 5
50409: PPUSH
50410: CALL 50719 0 2
50414: PUSH
50415: LD_VAR 0 10
50419: PUSH
50420: EMPTY
50421: EQUAL
50422: OR
50423: IFFALSE 50368
// result := [ ] ;
50425: LD_ADDR_VAR 0 6
50429: PUSH
50430: EMPTY
50431: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
50432: LD_VAR 0 1
50436: PPUSH
50437: LD_VAR 0 2
50441: PPUSH
50442: LD_VAR 0 3
50446: PPUSH
50447: LD_VAR 0 4
50451: PPUSH
50452: LD_VAR 0 5
50456: PPUSH
50457: CALL_OW 448
50461: IFFALSE 50494
// result := [ chassis , engine , control , weapon ] ;
50463: LD_ADDR_VAR 0 6
50467: PUSH
50468: LD_VAR 0 2
50472: PUSH
50473: LD_VAR 0 3
50477: PUSH
50478: LD_VAR 0 4
50482: PUSH
50483: LD_VAR 0 5
50487: PUSH
50488: EMPTY
50489: LIST
50490: LIST
50491: LIST
50492: LIST
50493: ST_TO_ADDR
// end ;
50494: LD_VAR 0 6
50498: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
50499: LD_INT 0
50501: PPUSH
// if not chassis or not engine then
50502: LD_VAR 0 1
50506: NOT
50507: PUSH
50508: LD_VAR 0 2
50512: NOT
50513: OR
50514: IFFALSE 50518
// exit ;
50516: GO 50714
// case engine of engine_solar :
50518: LD_VAR 0 2
50522: PUSH
50523: LD_INT 2
50525: DOUBLE
50526: EQUAL
50527: IFTRUE 50531
50529: GO 50569
50531: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
50532: LD_ADDR_VAR 0 3
50536: PUSH
50537: LD_INT 11
50539: PUSH
50540: LD_INT 12
50542: PUSH
50543: LD_INT 13
50545: PUSH
50546: LD_INT 14
50548: PUSH
50549: LD_INT 1
50551: PUSH
50552: LD_INT 2
50554: PUSH
50555: LD_INT 3
50557: PUSH
50558: EMPTY
50559: LIST
50560: LIST
50561: LIST
50562: LIST
50563: LIST
50564: LIST
50565: LIST
50566: ST_TO_ADDR
50567: GO 50698
50569: LD_INT 1
50571: DOUBLE
50572: EQUAL
50573: IFTRUE 50577
50575: GO 50639
50577: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
50578: LD_ADDR_VAR 0 3
50582: PUSH
50583: LD_INT 11
50585: PUSH
50586: LD_INT 12
50588: PUSH
50589: LD_INT 13
50591: PUSH
50592: LD_INT 14
50594: PUSH
50595: LD_INT 1
50597: PUSH
50598: LD_INT 2
50600: PUSH
50601: LD_INT 3
50603: PUSH
50604: LD_INT 4
50606: PUSH
50607: LD_INT 5
50609: PUSH
50610: LD_INT 21
50612: PUSH
50613: LD_INT 23
50615: PUSH
50616: LD_INT 22
50618: PUSH
50619: LD_INT 24
50621: PUSH
50622: EMPTY
50623: LIST
50624: LIST
50625: LIST
50626: LIST
50627: LIST
50628: LIST
50629: LIST
50630: LIST
50631: LIST
50632: LIST
50633: LIST
50634: LIST
50635: LIST
50636: ST_TO_ADDR
50637: GO 50698
50639: LD_INT 3
50641: DOUBLE
50642: EQUAL
50643: IFTRUE 50647
50645: GO 50697
50647: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
50648: LD_ADDR_VAR 0 3
50652: PUSH
50653: LD_INT 13
50655: PUSH
50656: LD_INT 14
50658: PUSH
50659: LD_INT 2
50661: PUSH
50662: LD_INT 3
50664: PUSH
50665: LD_INT 4
50667: PUSH
50668: LD_INT 5
50670: PUSH
50671: LD_INT 21
50673: PUSH
50674: LD_INT 22
50676: PUSH
50677: LD_INT 23
50679: PUSH
50680: LD_INT 24
50682: PUSH
50683: EMPTY
50684: LIST
50685: LIST
50686: LIST
50687: LIST
50688: LIST
50689: LIST
50690: LIST
50691: LIST
50692: LIST
50693: LIST
50694: ST_TO_ADDR
50695: GO 50698
50697: POP
// result := ( chassis in result ) ;
50698: LD_ADDR_VAR 0 3
50702: PUSH
50703: LD_VAR 0 1
50707: PUSH
50708: LD_VAR 0 3
50712: IN
50713: ST_TO_ADDR
// end ;
50714: LD_VAR 0 3
50718: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
50719: LD_INT 0
50721: PPUSH
// if not chassis or not weapon then
50722: LD_VAR 0 1
50726: NOT
50727: PUSH
50728: LD_VAR 0 2
50732: NOT
50733: OR
50734: IFFALSE 50738
// exit ;
50736: GO 51764
// case weapon of us_machine_gun :
50738: LD_VAR 0 2
50742: PUSH
50743: LD_INT 2
50745: DOUBLE
50746: EQUAL
50747: IFTRUE 50751
50749: GO 50781
50751: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
50752: LD_ADDR_VAR 0 3
50756: PUSH
50757: LD_INT 1
50759: PUSH
50760: LD_INT 2
50762: PUSH
50763: LD_INT 3
50765: PUSH
50766: LD_INT 4
50768: PUSH
50769: LD_INT 5
50771: PUSH
50772: EMPTY
50773: LIST
50774: LIST
50775: LIST
50776: LIST
50777: LIST
50778: ST_TO_ADDR
50779: GO 51748
50781: LD_INT 3
50783: DOUBLE
50784: EQUAL
50785: IFTRUE 50789
50787: GO 50819
50789: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
50790: LD_ADDR_VAR 0 3
50794: PUSH
50795: LD_INT 1
50797: PUSH
50798: LD_INT 2
50800: PUSH
50801: LD_INT 3
50803: PUSH
50804: LD_INT 4
50806: PUSH
50807: LD_INT 5
50809: PUSH
50810: EMPTY
50811: LIST
50812: LIST
50813: LIST
50814: LIST
50815: LIST
50816: ST_TO_ADDR
50817: GO 51748
50819: LD_INT 11
50821: DOUBLE
50822: EQUAL
50823: IFTRUE 50827
50825: GO 50857
50827: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
50828: LD_ADDR_VAR 0 3
50832: PUSH
50833: LD_INT 1
50835: PUSH
50836: LD_INT 2
50838: PUSH
50839: LD_INT 3
50841: PUSH
50842: LD_INT 4
50844: PUSH
50845: LD_INT 5
50847: PUSH
50848: EMPTY
50849: LIST
50850: LIST
50851: LIST
50852: LIST
50853: LIST
50854: ST_TO_ADDR
50855: GO 51748
50857: LD_INT 4
50859: DOUBLE
50860: EQUAL
50861: IFTRUE 50865
50863: GO 50891
50865: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
50866: LD_ADDR_VAR 0 3
50870: PUSH
50871: LD_INT 2
50873: PUSH
50874: LD_INT 3
50876: PUSH
50877: LD_INT 4
50879: PUSH
50880: LD_INT 5
50882: PUSH
50883: EMPTY
50884: LIST
50885: LIST
50886: LIST
50887: LIST
50888: ST_TO_ADDR
50889: GO 51748
50891: LD_INT 5
50893: DOUBLE
50894: EQUAL
50895: IFTRUE 50899
50897: GO 50925
50899: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
50900: LD_ADDR_VAR 0 3
50904: PUSH
50905: LD_INT 2
50907: PUSH
50908: LD_INT 3
50910: PUSH
50911: LD_INT 4
50913: PUSH
50914: LD_INT 5
50916: PUSH
50917: EMPTY
50918: LIST
50919: LIST
50920: LIST
50921: LIST
50922: ST_TO_ADDR
50923: GO 51748
50925: LD_INT 9
50927: DOUBLE
50928: EQUAL
50929: IFTRUE 50933
50931: GO 50959
50933: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
50934: LD_ADDR_VAR 0 3
50938: PUSH
50939: LD_INT 2
50941: PUSH
50942: LD_INT 3
50944: PUSH
50945: LD_INT 4
50947: PUSH
50948: LD_INT 5
50950: PUSH
50951: EMPTY
50952: LIST
50953: LIST
50954: LIST
50955: LIST
50956: ST_TO_ADDR
50957: GO 51748
50959: LD_INT 7
50961: DOUBLE
50962: EQUAL
50963: IFTRUE 50967
50965: GO 50993
50967: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
50968: LD_ADDR_VAR 0 3
50972: PUSH
50973: LD_INT 2
50975: PUSH
50976: LD_INT 3
50978: PUSH
50979: LD_INT 4
50981: PUSH
50982: LD_INT 5
50984: PUSH
50985: EMPTY
50986: LIST
50987: LIST
50988: LIST
50989: LIST
50990: ST_TO_ADDR
50991: GO 51748
50993: LD_INT 12
50995: DOUBLE
50996: EQUAL
50997: IFTRUE 51001
50999: GO 51027
51001: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
51002: LD_ADDR_VAR 0 3
51006: PUSH
51007: LD_INT 2
51009: PUSH
51010: LD_INT 3
51012: PUSH
51013: LD_INT 4
51015: PUSH
51016: LD_INT 5
51018: PUSH
51019: EMPTY
51020: LIST
51021: LIST
51022: LIST
51023: LIST
51024: ST_TO_ADDR
51025: GO 51748
51027: LD_INT 13
51029: DOUBLE
51030: EQUAL
51031: IFTRUE 51035
51033: GO 51061
51035: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
51036: LD_ADDR_VAR 0 3
51040: PUSH
51041: LD_INT 2
51043: PUSH
51044: LD_INT 3
51046: PUSH
51047: LD_INT 4
51049: PUSH
51050: LD_INT 5
51052: PUSH
51053: EMPTY
51054: LIST
51055: LIST
51056: LIST
51057: LIST
51058: ST_TO_ADDR
51059: GO 51748
51061: LD_INT 14
51063: DOUBLE
51064: EQUAL
51065: IFTRUE 51069
51067: GO 51087
51069: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
51070: LD_ADDR_VAR 0 3
51074: PUSH
51075: LD_INT 4
51077: PUSH
51078: LD_INT 5
51080: PUSH
51081: EMPTY
51082: LIST
51083: LIST
51084: ST_TO_ADDR
51085: GO 51748
51087: LD_INT 6
51089: DOUBLE
51090: EQUAL
51091: IFTRUE 51095
51093: GO 51113
51095: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
51096: LD_ADDR_VAR 0 3
51100: PUSH
51101: LD_INT 4
51103: PUSH
51104: LD_INT 5
51106: PUSH
51107: EMPTY
51108: LIST
51109: LIST
51110: ST_TO_ADDR
51111: GO 51748
51113: LD_INT 10
51115: DOUBLE
51116: EQUAL
51117: IFTRUE 51121
51119: GO 51139
51121: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
51122: LD_ADDR_VAR 0 3
51126: PUSH
51127: LD_INT 4
51129: PUSH
51130: LD_INT 5
51132: PUSH
51133: EMPTY
51134: LIST
51135: LIST
51136: ST_TO_ADDR
51137: GO 51748
51139: LD_INT 22
51141: DOUBLE
51142: EQUAL
51143: IFTRUE 51147
51145: GO 51173
51147: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
51148: LD_ADDR_VAR 0 3
51152: PUSH
51153: LD_INT 11
51155: PUSH
51156: LD_INT 12
51158: PUSH
51159: LD_INT 13
51161: PUSH
51162: LD_INT 14
51164: PUSH
51165: EMPTY
51166: LIST
51167: LIST
51168: LIST
51169: LIST
51170: ST_TO_ADDR
51171: GO 51748
51173: LD_INT 23
51175: DOUBLE
51176: EQUAL
51177: IFTRUE 51181
51179: GO 51207
51181: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
51182: LD_ADDR_VAR 0 3
51186: PUSH
51187: LD_INT 11
51189: PUSH
51190: LD_INT 12
51192: PUSH
51193: LD_INT 13
51195: PUSH
51196: LD_INT 14
51198: PUSH
51199: EMPTY
51200: LIST
51201: LIST
51202: LIST
51203: LIST
51204: ST_TO_ADDR
51205: GO 51748
51207: LD_INT 24
51209: DOUBLE
51210: EQUAL
51211: IFTRUE 51215
51213: GO 51241
51215: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
51216: LD_ADDR_VAR 0 3
51220: PUSH
51221: LD_INT 11
51223: PUSH
51224: LD_INT 12
51226: PUSH
51227: LD_INT 13
51229: PUSH
51230: LD_INT 14
51232: PUSH
51233: EMPTY
51234: LIST
51235: LIST
51236: LIST
51237: LIST
51238: ST_TO_ADDR
51239: GO 51748
51241: LD_INT 30
51243: DOUBLE
51244: EQUAL
51245: IFTRUE 51249
51247: GO 51275
51249: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
51250: LD_ADDR_VAR 0 3
51254: PUSH
51255: LD_INT 11
51257: PUSH
51258: LD_INT 12
51260: PUSH
51261: LD_INT 13
51263: PUSH
51264: LD_INT 14
51266: PUSH
51267: EMPTY
51268: LIST
51269: LIST
51270: LIST
51271: LIST
51272: ST_TO_ADDR
51273: GO 51748
51275: LD_INT 25
51277: DOUBLE
51278: EQUAL
51279: IFTRUE 51283
51281: GO 51301
51283: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
51284: LD_ADDR_VAR 0 3
51288: PUSH
51289: LD_INT 13
51291: PUSH
51292: LD_INT 14
51294: PUSH
51295: EMPTY
51296: LIST
51297: LIST
51298: ST_TO_ADDR
51299: GO 51748
51301: LD_INT 27
51303: DOUBLE
51304: EQUAL
51305: IFTRUE 51309
51307: GO 51327
51309: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
51310: LD_ADDR_VAR 0 3
51314: PUSH
51315: LD_INT 13
51317: PUSH
51318: LD_INT 14
51320: PUSH
51321: EMPTY
51322: LIST
51323: LIST
51324: ST_TO_ADDR
51325: GO 51748
51327: LD_INT 28
51329: DOUBLE
51330: EQUAL
51331: IFTRUE 51335
51333: GO 51353
51335: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
51336: LD_ADDR_VAR 0 3
51340: PUSH
51341: LD_INT 13
51343: PUSH
51344: LD_INT 14
51346: PUSH
51347: EMPTY
51348: LIST
51349: LIST
51350: ST_TO_ADDR
51351: GO 51748
51353: LD_INT 29
51355: DOUBLE
51356: EQUAL
51357: IFTRUE 51361
51359: GO 51379
51361: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
51362: LD_ADDR_VAR 0 3
51366: PUSH
51367: LD_INT 13
51369: PUSH
51370: LD_INT 14
51372: PUSH
51373: EMPTY
51374: LIST
51375: LIST
51376: ST_TO_ADDR
51377: GO 51748
51379: LD_INT 31
51381: DOUBLE
51382: EQUAL
51383: IFTRUE 51387
51385: GO 51405
51387: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
51388: LD_ADDR_VAR 0 3
51392: PUSH
51393: LD_INT 13
51395: PUSH
51396: LD_INT 14
51398: PUSH
51399: EMPTY
51400: LIST
51401: LIST
51402: ST_TO_ADDR
51403: GO 51748
51405: LD_INT 26
51407: DOUBLE
51408: EQUAL
51409: IFTRUE 51413
51411: GO 51431
51413: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
51414: LD_ADDR_VAR 0 3
51418: PUSH
51419: LD_INT 13
51421: PUSH
51422: LD_INT 14
51424: PUSH
51425: EMPTY
51426: LIST
51427: LIST
51428: ST_TO_ADDR
51429: GO 51748
51431: LD_INT 42
51433: DOUBLE
51434: EQUAL
51435: IFTRUE 51439
51437: GO 51465
51439: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
51440: LD_ADDR_VAR 0 3
51444: PUSH
51445: LD_INT 21
51447: PUSH
51448: LD_INT 22
51450: PUSH
51451: LD_INT 23
51453: PUSH
51454: LD_INT 24
51456: PUSH
51457: EMPTY
51458: LIST
51459: LIST
51460: LIST
51461: LIST
51462: ST_TO_ADDR
51463: GO 51748
51465: LD_INT 43
51467: DOUBLE
51468: EQUAL
51469: IFTRUE 51473
51471: GO 51499
51473: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
51474: LD_ADDR_VAR 0 3
51478: PUSH
51479: LD_INT 21
51481: PUSH
51482: LD_INT 22
51484: PUSH
51485: LD_INT 23
51487: PUSH
51488: LD_INT 24
51490: PUSH
51491: EMPTY
51492: LIST
51493: LIST
51494: LIST
51495: LIST
51496: ST_TO_ADDR
51497: GO 51748
51499: LD_INT 44
51501: DOUBLE
51502: EQUAL
51503: IFTRUE 51507
51505: GO 51533
51507: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
51508: LD_ADDR_VAR 0 3
51512: PUSH
51513: LD_INT 21
51515: PUSH
51516: LD_INT 22
51518: PUSH
51519: LD_INT 23
51521: PUSH
51522: LD_INT 24
51524: PUSH
51525: EMPTY
51526: LIST
51527: LIST
51528: LIST
51529: LIST
51530: ST_TO_ADDR
51531: GO 51748
51533: LD_INT 45
51535: DOUBLE
51536: EQUAL
51537: IFTRUE 51541
51539: GO 51567
51541: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
51542: LD_ADDR_VAR 0 3
51546: PUSH
51547: LD_INT 21
51549: PUSH
51550: LD_INT 22
51552: PUSH
51553: LD_INT 23
51555: PUSH
51556: LD_INT 24
51558: PUSH
51559: EMPTY
51560: LIST
51561: LIST
51562: LIST
51563: LIST
51564: ST_TO_ADDR
51565: GO 51748
51567: LD_INT 49
51569: DOUBLE
51570: EQUAL
51571: IFTRUE 51575
51573: GO 51601
51575: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
51576: LD_ADDR_VAR 0 3
51580: PUSH
51581: LD_INT 21
51583: PUSH
51584: LD_INT 22
51586: PUSH
51587: LD_INT 23
51589: PUSH
51590: LD_INT 24
51592: PUSH
51593: EMPTY
51594: LIST
51595: LIST
51596: LIST
51597: LIST
51598: ST_TO_ADDR
51599: GO 51748
51601: LD_INT 51
51603: DOUBLE
51604: EQUAL
51605: IFTRUE 51609
51607: GO 51635
51609: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
51610: LD_ADDR_VAR 0 3
51614: PUSH
51615: LD_INT 21
51617: PUSH
51618: LD_INT 22
51620: PUSH
51621: LD_INT 23
51623: PUSH
51624: LD_INT 24
51626: PUSH
51627: EMPTY
51628: LIST
51629: LIST
51630: LIST
51631: LIST
51632: ST_TO_ADDR
51633: GO 51748
51635: LD_INT 52
51637: DOUBLE
51638: EQUAL
51639: IFTRUE 51643
51641: GO 51669
51643: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
51644: LD_ADDR_VAR 0 3
51648: PUSH
51649: LD_INT 21
51651: PUSH
51652: LD_INT 22
51654: PUSH
51655: LD_INT 23
51657: PUSH
51658: LD_INT 24
51660: PUSH
51661: EMPTY
51662: LIST
51663: LIST
51664: LIST
51665: LIST
51666: ST_TO_ADDR
51667: GO 51748
51669: LD_INT 53
51671: DOUBLE
51672: EQUAL
51673: IFTRUE 51677
51675: GO 51695
51677: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
51678: LD_ADDR_VAR 0 3
51682: PUSH
51683: LD_INT 23
51685: PUSH
51686: LD_INT 24
51688: PUSH
51689: EMPTY
51690: LIST
51691: LIST
51692: ST_TO_ADDR
51693: GO 51748
51695: LD_INT 46
51697: DOUBLE
51698: EQUAL
51699: IFTRUE 51703
51701: GO 51721
51703: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
51704: LD_ADDR_VAR 0 3
51708: PUSH
51709: LD_INT 23
51711: PUSH
51712: LD_INT 24
51714: PUSH
51715: EMPTY
51716: LIST
51717: LIST
51718: ST_TO_ADDR
51719: GO 51748
51721: LD_INT 47
51723: DOUBLE
51724: EQUAL
51725: IFTRUE 51729
51727: GO 51747
51729: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
51730: LD_ADDR_VAR 0 3
51734: PUSH
51735: LD_INT 23
51737: PUSH
51738: LD_INT 24
51740: PUSH
51741: EMPTY
51742: LIST
51743: LIST
51744: ST_TO_ADDR
51745: GO 51748
51747: POP
// result := ( chassis in result ) ;
51748: LD_ADDR_VAR 0 3
51752: PUSH
51753: LD_VAR 0 1
51757: PUSH
51758: LD_VAR 0 3
51762: IN
51763: ST_TO_ADDR
// end ;
51764: LD_VAR 0 3
51768: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
51769: LD_INT 0
51771: PPUSH
51772: PPUSH
51773: PPUSH
51774: PPUSH
51775: PPUSH
51776: PPUSH
51777: PPUSH
// result := array ;
51778: LD_ADDR_VAR 0 5
51782: PUSH
51783: LD_VAR 0 1
51787: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
51788: LD_VAR 0 1
51792: NOT
51793: PUSH
51794: LD_VAR 0 2
51798: NOT
51799: OR
51800: PUSH
51801: LD_VAR 0 3
51805: NOT
51806: OR
51807: PUSH
51808: LD_VAR 0 2
51812: PUSH
51813: LD_VAR 0 1
51817: GREATER
51818: OR
51819: PUSH
51820: LD_VAR 0 3
51824: PUSH
51825: LD_VAR 0 1
51829: GREATER
51830: OR
51831: IFFALSE 51835
// exit ;
51833: GO 52131
// if direction then
51835: LD_VAR 0 4
51839: IFFALSE 51903
// begin d := 1 ;
51841: LD_ADDR_VAR 0 9
51845: PUSH
51846: LD_INT 1
51848: ST_TO_ADDR
// if i_from > i_to then
51849: LD_VAR 0 2
51853: PUSH
51854: LD_VAR 0 3
51858: GREATER
51859: IFFALSE 51885
// length := ( array - i_from ) + i_to else
51861: LD_ADDR_VAR 0 11
51865: PUSH
51866: LD_VAR 0 1
51870: PUSH
51871: LD_VAR 0 2
51875: MINUS
51876: PUSH
51877: LD_VAR 0 3
51881: PLUS
51882: ST_TO_ADDR
51883: GO 51901
// length := i_to - i_from ;
51885: LD_ADDR_VAR 0 11
51889: PUSH
51890: LD_VAR 0 3
51894: PUSH
51895: LD_VAR 0 2
51899: MINUS
51900: ST_TO_ADDR
// end else
51901: GO 51964
// begin d := - 1 ;
51903: LD_ADDR_VAR 0 9
51907: PUSH
51908: LD_INT 1
51910: NEG
51911: ST_TO_ADDR
// if i_from > i_to then
51912: LD_VAR 0 2
51916: PUSH
51917: LD_VAR 0 3
51921: GREATER
51922: IFFALSE 51942
// length := i_from - i_to else
51924: LD_ADDR_VAR 0 11
51928: PUSH
51929: LD_VAR 0 2
51933: PUSH
51934: LD_VAR 0 3
51938: MINUS
51939: ST_TO_ADDR
51940: GO 51964
// length := ( array - i_to ) + i_from ;
51942: LD_ADDR_VAR 0 11
51946: PUSH
51947: LD_VAR 0 1
51951: PUSH
51952: LD_VAR 0 3
51956: MINUS
51957: PUSH
51958: LD_VAR 0 2
51962: PLUS
51963: ST_TO_ADDR
// end ; if not length then
51964: LD_VAR 0 11
51968: NOT
51969: IFFALSE 51973
// exit ;
51971: GO 52131
// tmp := array ;
51973: LD_ADDR_VAR 0 10
51977: PUSH
51978: LD_VAR 0 1
51982: ST_TO_ADDR
// for i = 1 to length do
51983: LD_ADDR_VAR 0 6
51987: PUSH
51988: DOUBLE
51989: LD_INT 1
51991: DEC
51992: ST_TO_ADDR
51993: LD_VAR 0 11
51997: PUSH
51998: FOR_TO
51999: IFFALSE 52119
// begin for j = 1 to array do
52001: LD_ADDR_VAR 0 7
52005: PUSH
52006: DOUBLE
52007: LD_INT 1
52009: DEC
52010: ST_TO_ADDR
52011: LD_VAR 0 1
52015: PUSH
52016: FOR_TO
52017: IFFALSE 52105
// begin k := j + d ;
52019: LD_ADDR_VAR 0 8
52023: PUSH
52024: LD_VAR 0 7
52028: PUSH
52029: LD_VAR 0 9
52033: PLUS
52034: ST_TO_ADDR
// if k > array then
52035: LD_VAR 0 8
52039: PUSH
52040: LD_VAR 0 1
52044: GREATER
52045: IFFALSE 52055
// k := 1 ;
52047: LD_ADDR_VAR 0 8
52051: PUSH
52052: LD_INT 1
52054: ST_TO_ADDR
// if not k then
52055: LD_VAR 0 8
52059: NOT
52060: IFFALSE 52072
// k := array ;
52062: LD_ADDR_VAR 0 8
52066: PUSH
52067: LD_VAR 0 1
52071: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
52072: LD_ADDR_VAR 0 10
52076: PUSH
52077: LD_VAR 0 10
52081: PPUSH
52082: LD_VAR 0 8
52086: PPUSH
52087: LD_VAR 0 1
52091: PUSH
52092: LD_VAR 0 7
52096: ARRAY
52097: PPUSH
52098: CALL_OW 1
52102: ST_TO_ADDR
// end ;
52103: GO 52016
52105: POP
52106: POP
// array := tmp ;
52107: LD_ADDR_VAR 0 1
52111: PUSH
52112: LD_VAR 0 10
52116: ST_TO_ADDR
// end ;
52117: GO 51998
52119: POP
52120: POP
// result := array ;
52121: LD_ADDR_VAR 0 5
52125: PUSH
52126: LD_VAR 0 1
52130: ST_TO_ADDR
// end ;
52131: LD_VAR 0 5
52135: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
52136: LD_INT 0
52138: PPUSH
52139: PPUSH
// result := 0 ;
52140: LD_ADDR_VAR 0 3
52144: PUSH
52145: LD_INT 0
52147: ST_TO_ADDR
// if not array or not value in array then
52148: LD_VAR 0 1
52152: NOT
52153: PUSH
52154: LD_VAR 0 2
52158: PUSH
52159: LD_VAR 0 1
52163: IN
52164: NOT
52165: OR
52166: IFFALSE 52170
// exit ;
52168: GO 52224
// for i = 1 to array do
52170: LD_ADDR_VAR 0 4
52174: PUSH
52175: DOUBLE
52176: LD_INT 1
52178: DEC
52179: ST_TO_ADDR
52180: LD_VAR 0 1
52184: PUSH
52185: FOR_TO
52186: IFFALSE 52222
// if value = array [ i ] then
52188: LD_VAR 0 2
52192: PUSH
52193: LD_VAR 0 1
52197: PUSH
52198: LD_VAR 0 4
52202: ARRAY
52203: EQUAL
52204: IFFALSE 52220
// begin result := i ;
52206: LD_ADDR_VAR 0 3
52210: PUSH
52211: LD_VAR 0 4
52215: ST_TO_ADDR
// exit ;
52216: POP
52217: POP
52218: GO 52224
// end ;
52220: GO 52185
52222: POP
52223: POP
// end ;
52224: LD_VAR 0 3
52228: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
52229: LD_INT 0
52231: PPUSH
// vc_chassis := chassis ;
52232: LD_ADDR_OWVAR 37
52236: PUSH
52237: LD_VAR 0 1
52241: ST_TO_ADDR
// vc_engine := engine ;
52242: LD_ADDR_OWVAR 39
52246: PUSH
52247: LD_VAR 0 2
52251: ST_TO_ADDR
// vc_control := control ;
52252: LD_ADDR_OWVAR 38
52256: PUSH
52257: LD_VAR 0 3
52261: ST_TO_ADDR
// vc_weapon := weapon ;
52262: LD_ADDR_OWVAR 40
52266: PUSH
52267: LD_VAR 0 4
52271: ST_TO_ADDR
// vc_fuel_battery := fuel ;
52272: LD_ADDR_OWVAR 41
52276: PUSH
52277: LD_VAR 0 5
52281: ST_TO_ADDR
// end ;
52282: LD_VAR 0 6
52286: RET
// export function WantPlant ( unit ) ; var task ; begin
52287: LD_INT 0
52289: PPUSH
52290: PPUSH
// result := false ;
52291: LD_ADDR_VAR 0 2
52295: PUSH
52296: LD_INT 0
52298: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
52299: LD_ADDR_VAR 0 3
52303: PUSH
52304: LD_VAR 0 1
52308: PPUSH
52309: CALL_OW 437
52313: ST_TO_ADDR
// if task then
52314: LD_VAR 0 3
52318: IFFALSE 52346
// if task [ 1 ] [ 1 ] = p then
52320: LD_VAR 0 3
52324: PUSH
52325: LD_INT 1
52327: ARRAY
52328: PUSH
52329: LD_INT 1
52331: ARRAY
52332: PUSH
52333: LD_STRING p
52335: EQUAL
52336: IFFALSE 52346
// result := true ;
52338: LD_ADDR_VAR 0 2
52342: PUSH
52343: LD_INT 1
52345: ST_TO_ADDR
// end ;
52346: LD_VAR 0 2
52350: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
52351: LD_INT 0
52353: PPUSH
52354: PPUSH
52355: PPUSH
52356: PPUSH
// if pos < 1 then
52357: LD_VAR 0 2
52361: PUSH
52362: LD_INT 1
52364: LESS
52365: IFFALSE 52369
// exit ;
52367: GO 52672
// if pos = 1 then
52369: LD_VAR 0 2
52373: PUSH
52374: LD_INT 1
52376: EQUAL
52377: IFFALSE 52410
// result := Replace ( arr , pos [ 1 ] , value ) else
52379: LD_ADDR_VAR 0 4
52383: PUSH
52384: LD_VAR 0 1
52388: PPUSH
52389: LD_VAR 0 2
52393: PUSH
52394: LD_INT 1
52396: ARRAY
52397: PPUSH
52398: LD_VAR 0 3
52402: PPUSH
52403: CALL_OW 1
52407: ST_TO_ADDR
52408: GO 52672
// begin tmp := arr ;
52410: LD_ADDR_VAR 0 6
52414: PUSH
52415: LD_VAR 0 1
52419: ST_TO_ADDR
// s_arr := [ tmp ] ;
52420: LD_ADDR_VAR 0 7
52424: PUSH
52425: LD_VAR 0 6
52429: PUSH
52430: EMPTY
52431: LIST
52432: ST_TO_ADDR
// for i = 1 to pos - 1 do
52433: LD_ADDR_VAR 0 5
52437: PUSH
52438: DOUBLE
52439: LD_INT 1
52441: DEC
52442: ST_TO_ADDR
52443: LD_VAR 0 2
52447: PUSH
52448: LD_INT 1
52450: MINUS
52451: PUSH
52452: FOR_TO
52453: IFFALSE 52498
// begin tmp := tmp [ pos [ i ] ] ;
52455: LD_ADDR_VAR 0 6
52459: PUSH
52460: LD_VAR 0 6
52464: PUSH
52465: LD_VAR 0 2
52469: PUSH
52470: LD_VAR 0 5
52474: ARRAY
52475: ARRAY
52476: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
52477: LD_ADDR_VAR 0 7
52481: PUSH
52482: LD_VAR 0 7
52486: PUSH
52487: LD_VAR 0 6
52491: PUSH
52492: EMPTY
52493: LIST
52494: ADD
52495: ST_TO_ADDR
// end ;
52496: GO 52452
52498: POP
52499: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
52500: LD_ADDR_VAR 0 6
52504: PUSH
52505: LD_VAR 0 6
52509: PPUSH
52510: LD_VAR 0 2
52514: PUSH
52515: LD_VAR 0 2
52519: ARRAY
52520: PPUSH
52521: LD_VAR 0 3
52525: PPUSH
52526: CALL_OW 1
52530: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
52531: LD_ADDR_VAR 0 7
52535: PUSH
52536: LD_VAR 0 7
52540: PPUSH
52541: LD_VAR 0 7
52545: PPUSH
52546: LD_VAR 0 6
52550: PPUSH
52551: CALL_OW 1
52555: ST_TO_ADDR
// for i = s_arr downto 2 do
52556: LD_ADDR_VAR 0 5
52560: PUSH
52561: DOUBLE
52562: LD_VAR 0 7
52566: INC
52567: ST_TO_ADDR
52568: LD_INT 2
52570: PUSH
52571: FOR_DOWNTO
52572: IFFALSE 52656
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
52574: LD_ADDR_VAR 0 6
52578: PUSH
52579: LD_VAR 0 7
52583: PUSH
52584: LD_VAR 0 5
52588: PUSH
52589: LD_INT 1
52591: MINUS
52592: ARRAY
52593: PPUSH
52594: LD_VAR 0 2
52598: PUSH
52599: LD_VAR 0 5
52603: PUSH
52604: LD_INT 1
52606: MINUS
52607: ARRAY
52608: PPUSH
52609: LD_VAR 0 7
52613: PUSH
52614: LD_VAR 0 5
52618: ARRAY
52619: PPUSH
52620: CALL_OW 1
52624: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
52625: LD_ADDR_VAR 0 7
52629: PUSH
52630: LD_VAR 0 7
52634: PPUSH
52635: LD_VAR 0 5
52639: PUSH
52640: LD_INT 1
52642: MINUS
52643: PPUSH
52644: LD_VAR 0 6
52648: PPUSH
52649: CALL_OW 1
52653: ST_TO_ADDR
// end ;
52654: GO 52571
52656: POP
52657: POP
// result := s_arr [ 1 ] ;
52658: LD_ADDR_VAR 0 4
52662: PUSH
52663: LD_VAR 0 7
52667: PUSH
52668: LD_INT 1
52670: ARRAY
52671: ST_TO_ADDR
// end ; end ;
52672: LD_VAR 0 4
52676: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
52677: LD_INT 0
52679: PPUSH
52680: PPUSH
// if not list then
52681: LD_VAR 0 1
52685: NOT
52686: IFFALSE 52690
// exit ;
52688: GO 52781
// i := list [ pos1 ] ;
52690: LD_ADDR_VAR 0 5
52694: PUSH
52695: LD_VAR 0 1
52699: PUSH
52700: LD_VAR 0 2
52704: ARRAY
52705: ST_TO_ADDR
// if not i then
52706: LD_VAR 0 5
52710: NOT
52711: IFFALSE 52715
// exit ;
52713: GO 52781
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
52715: LD_ADDR_VAR 0 1
52719: PUSH
52720: LD_VAR 0 1
52724: PPUSH
52725: LD_VAR 0 2
52729: PPUSH
52730: LD_VAR 0 1
52734: PUSH
52735: LD_VAR 0 3
52739: ARRAY
52740: PPUSH
52741: CALL_OW 1
52745: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
52746: LD_ADDR_VAR 0 1
52750: PUSH
52751: LD_VAR 0 1
52755: PPUSH
52756: LD_VAR 0 3
52760: PPUSH
52761: LD_VAR 0 5
52765: PPUSH
52766: CALL_OW 1
52770: ST_TO_ADDR
// result := list ;
52771: LD_ADDR_VAR 0 4
52775: PUSH
52776: LD_VAR 0 1
52780: ST_TO_ADDR
// end ;
52781: LD_VAR 0 4
52785: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
52786: LD_INT 0
52788: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
52789: LD_ADDR_VAR 0 5
52793: PUSH
52794: LD_VAR 0 1
52798: PPUSH
52799: CALL_OW 250
52803: PPUSH
52804: LD_VAR 0 1
52808: PPUSH
52809: CALL_OW 251
52813: PPUSH
52814: LD_VAR 0 2
52818: PPUSH
52819: LD_VAR 0 3
52823: PPUSH
52824: LD_VAR 0 4
52828: PPUSH
52829: CALL 52839 0 5
52833: ST_TO_ADDR
// end ;
52834: LD_VAR 0 5
52838: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
52839: LD_INT 0
52841: PPUSH
52842: PPUSH
52843: PPUSH
52844: PPUSH
// if not list then
52845: LD_VAR 0 3
52849: NOT
52850: IFFALSE 52854
// exit ;
52852: GO 53242
// result := [ ] ;
52854: LD_ADDR_VAR 0 6
52858: PUSH
52859: EMPTY
52860: ST_TO_ADDR
// for i in list do
52861: LD_ADDR_VAR 0 7
52865: PUSH
52866: LD_VAR 0 3
52870: PUSH
52871: FOR_IN
52872: IFFALSE 53074
// begin tmp := GetDistUnitXY ( i , x , y ) ;
52874: LD_ADDR_VAR 0 9
52878: PUSH
52879: LD_VAR 0 7
52883: PPUSH
52884: LD_VAR 0 1
52888: PPUSH
52889: LD_VAR 0 2
52893: PPUSH
52894: CALL_OW 297
52898: ST_TO_ADDR
// if not result then
52899: LD_VAR 0 6
52903: NOT
52904: IFFALSE 52930
// result := [ [ i , tmp ] ] else
52906: LD_ADDR_VAR 0 6
52910: PUSH
52911: LD_VAR 0 7
52915: PUSH
52916: LD_VAR 0 9
52920: PUSH
52921: EMPTY
52922: LIST
52923: LIST
52924: PUSH
52925: EMPTY
52926: LIST
52927: ST_TO_ADDR
52928: GO 53072
// begin if result [ result ] [ 2 ] < tmp then
52930: LD_VAR 0 6
52934: PUSH
52935: LD_VAR 0 6
52939: ARRAY
52940: PUSH
52941: LD_INT 2
52943: ARRAY
52944: PUSH
52945: LD_VAR 0 9
52949: LESS
52950: IFFALSE 52992
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
52952: LD_ADDR_VAR 0 6
52956: PUSH
52957: LD_VAR 0 6
52961: PPUSH
52962: LD_VAR 0 6
52966: PUSH
52967: LD_INT 1
52969: PLUS
52970: PPUSH
52971: LD_VAR 0 7
52975: PUSH
52976: LD_VAR 0 9
52980: PUSH
52981: EMPTY
52982: LIST
52983: LIST
52984: PPUSH
52985: CALL_OW 2
52989: ST_TO_ADDR
52990: GO 53072
// for j = 1 to result do
52992: LD_ADDR_VAR 0 8
52996: PUSH
52997: DOUBLE
52998: LD_INT 1
53000: DEC
53001: ST_TO_ADDR
53002: LD_VAR 0 6
53006: PUSH
53007: FOR_TO
53008: IFFALSE 53070
// begin if tmp < result [ j ] [ 2 ] then
53010: LD_VAR 0 9
53014: PUSH
53015: LD_VAR 0 6
53019: PUSH
53020: LD_VAR 0 8
53024: ARRAY
53025: PUSH
53026: LD_INT 2
53028: ARRAY
53029: LESS
53030: IFFALSE 53068
// begin result := Insert ( result , j , [ i , tmp ] ) ;
53032: LD_ADDR_VAR 0 6
53036: PUSH
53037: LD_VAR 0 6
53041: PPUSH
53042: LD_VAR 0 8
53046: PPUSH
53047: LD_VAR 0 7
53051: PUSH
53052: LD_VAR 0 9
53056: PUSH
53057: EMPTY
53058: LIST
53059: LIST
53060: PPUSH
53061: CALL_OW 2
53065: ST_TO_ADDR
// break ;
53066: GO 53070
// end ; end ;
53068: GO 53007
53070: POP
53071: POP
// end ; end ;
53072: GO 52871
53074: POP
53075: POP
// if result and not asc then
53076: LD_VAR 0 6
53080: PUSH
53081: LD_VAR 0 4
53085: NOT
53086: AND
53087: IFFALSE 53162
// begin tmp := result ;
53089: LD_ADDR_VAR 0 9
53093: PUSH
53094: LD_VAR 0 6
53098: ST_TO_ADDR
// for i = tmp downto 1 do
53099: LD_ADDR_VAR 0 7
53103: PUSH
53104: DOUBLE
53105: LD_VAR 0 9
53109: INC
53110: ST_TO_ADDR
53111: LD_INT 1
53113: PUSH
53114: FOR_DOWNTO
53115: IFFALSE 53160
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
53117: LD_ADDR_VAR 0 6
53121: PUSH
53122: LD_VAR 0 6
53126: PPUSH
53127: LD_VAR 0 9
53131: PUSH
53132: LD_VAR 0 7
53136: MINUS
53137: PUSH
53138: LD_INT 1
53140: PLUS
53141: PPUSH
53142: LD_VAR 0 9
53146: PUSH
53147: LD_VAR 0 7
53151: ARRAY
53152: PPUSH
53153: CALL_OW 1
53157: ST_TO_ADDR
53158: GO 53114
53160: POP
53161: POP
// end ; tmp := [ ] ;
53162: LD_ADDR_VAR 0 9
53166: PUSH
53167: EMPTY
53168: ST_TO_ADDR
// if mode then
53169: LD_VAR 0 5
53173: IFFALSE 53242
// begin for i = 1 to result do
53175: LD_ADDR_VAR 0 7
53179: PUSH
53180: DOUBLE
53181: LD_INT 1
53183: DEC
53184: ST_TO_ADDR
53185: LD_VAR 0 6
53189: PUSH
53190: FOR_TO
53191: IFFALSE 53230
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
53193: LD_ADDR_VAR 0 9
53197: PUSH
53198: LD_VAR 0 9
53202: PPUSH
53203: LD_VAR 0 7
53207: PPUSH
53208: LD_VAR 0 6
53212: PUSH
53213: LD_VAR 0 7
53217: ARRAY
53218: PUSH
53219: LD_INT 1
53221: ARRAY
53222: PPUSH
53223: CALL_OW 1
53227: ST_TO_ADDR
53228: GO 53190
53230: POP
53231: POP
// result := tmp ;
53232: LD_ADDR_VAR 0 6
53236: PUSH
53237: LD_VAR 0 9
53241: ST_TO_ADDR
// end ; end ;
53242: LD_VAR 0 6
53246: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
53247: LD_INT 0
53249: PPUSH
53250: PPUSH
53251: PPUSH
53252: PPUSH
53253: PPUSH
53254: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
53255: LD_ADDR_VAR 0 5
53259: PUSH
53260: LD_INT 0
53262: PUSH
53263: LD_INT 0
53265: PUSH
53266: LD_INT 0
53268: PUSH
53269: EMPTY
53270: PUSH
53271: EMPTY
53272: LIST
53273: LIST
53274: LIST
53275: LIST
53276: ST_TO_ADDR
// if not x or not y then
53277: LD_VAR 0 2
53281: NOT
53282: PUSH
53283: LD_VAR 0 3
53287: NOT
53288: OR
53289: IFFALSE 53293
// exit ;
53291: GO 54939
// if not range then
53293: LD_VAR 0 4
53297: NOT
53298: IFFALSE 53308
// range := 10 ;
53300: LD_ADDR_VAR 0 4
53304: PUSH
53305: LD_INT 10
53307: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
53308: LD_ADDR_VAR 0 8
53312: PUSH
53313: LD_INT 81
53315: PUSH
53316: LD_VAR 0 1
53320: PUSH
53321: EMPTY
53322: LIST
53323: LIST
53324: PUSH
53325: LD_INT 92
53327: PUSH
53328: LD_VAR 0 2
53332: PUSH
53333: LD_VAR 0 3
53337: PUSH
53338: LD_VAR 0 4
53342: PUSH
53343: EMPTY
53344: LIST
53345: LIST
53346: LIST
53347: LIST
53348: PUSH
53349: LD_INT 3
53351: PUSH
53352: LD_INT 21
53354: PUSH
53355: LD_INT 3
53357: PUSH
53358: EMPTY
53359: LIST
53360: LIST
53361: PUSH
53362: EMPTY
53363: LIST
53364: LIST
53365: PUSH
53366: EMPTY
53367: LIST
53368: LIST
53369: LIST
53370: PPUSH
53371: CALL_OW 69
53375: ST_TO_ADDR
// if not tmp then
53376: LD_VAR 0 8
53380: NOT
53381: IFFALSE 53385
// exit ;
53383: GO 54939
// for i in tmp do
53385: LD_ADDR_VAR 0 6
53389: PUSH
53390: LD_VAR 0 8
53394: PUSH
53395: FOR_IN
53396: IFFALSE 54914
// begin points := [ 0 , 0 , 0 ] ;
53398: LD_ADDR_VAR 0 9
53402: PUSH
53403: LD_INT 0
53405: PUSH
53406: LD_INT 0
53408: PUSH
53409: LD_INT 0
53411: PUSH
53412: EMPTY
53413: LIST
53414: LIST
53415: LIST
53416: ST_TO_ADDR
// bpoints := 1 ;
53417: LD_ADDR_VAR 0 10
53421: PUSH
53422: LD_INT 1
53424: ST_TO_ADDR
// case GetType ( i ) of unit_human :
53425: LD_VAR 0 6
53429: PPUSH
53430: CALL_OW 247
53434: PUSH
53435: LD_INT 1
53437: DOUBLE
53438: EQUAL
53439: IFTRUE 53443
53441: GO 54021
53443: POP
// begin if GetClass ( i ) = 1 then
53444: LD_VAR 0 6
53448: PPUSH
53449: CALL_OW 257
53453: PUSH
53454: LD_INT 1
53456: EQUAL
53457: IFFALSE 53478
// points := [ 10 , 5 , 3 ] ;
53459: LD_ADDR_VAR 0 9
53463: PUSH
53464: LD_INT 10
53466: PUSH
53467: LD_INT 5
53469: PUSH
53470: LD_INT 3
53472: PUSH
53473: EMPTY
53474: LIST
53475: LIST
53476: LIST
53477: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
53478: LD_VAR 0 6
53482: PPUSH
53483: CALL_OW 257
53487: PUSH
53488: LD_INT 2
53490: PUSH
53491: LD_INT 3
53493: PUSH
53494: LD_INT 4
53496: PUSH
53497: EMPTY
53498: LIST
53499: LIST
53500: LIST
53501: IN
53502: IFFALSE 53523
// points := [ 3 , 2 , 1 ] ;
53504: LD_ADDR_VAR 0 9
53508: PUSH
53509: LD_INT 3
53511: PUSH
53512: LD_INT 2
53514: PUSH
53515: LD_INT 1
53517: PUSH
53518: EMPTY
53519: LIST
53520: LIST
53521: LIST
53522: ST_TO_ADDR
// if GetClass ( i ) = 5 then
53523: LD_VAR 0 6
53527: PPUSH
53528: CALL_OW 257
53532: PUSH
53533: LD_INT 5
53535: EQUAL
53536: IFFALSE 53557
// points := [ 130 , 5 , 2 ] ;
53538: LD_ADDR_VAR 0 9
53542: PUSH
53543: LD_INT 130
53545: PUSH
53546: LD_INT 5
53548: PUSH
53549: LD_INT 2
53551: PUSH
53552: EMPTY
53553: LIST
53554: LIST
53555: LIST
53556: ST_TO_ADDR
// if GetClass ( i ) = 8 then
53557: LD_VAR 0 6
53561: PPUSH
53562: CALL_OW 257
53566: PUSH
53567: LD_INT 8
53569: EQUAL
53570: IFFALSE 53591
// points := [ 35 , 35 , 30 ] ;
53572: LD_ADDR_VAR 0 9
53576: PUSH
53577: LD_INT 35
53579: PUSH
53580: LD_INT 35
53582: PUSH
53583: LD_INT 30
53585: PUSH
53586: EMPTY
53587: LIST
53588: LIST
53589: LIST
53590: ST_TO_ADDR
// if GetClass ( i ) = 9 then
53591: LD_VAR 0 6
53595: PPUSH
53596: CALL_OW 257
53600: PUSH
53601: LD_INT 9
53603: EQUAL
53604: IFFALSE 53625
// points := [ 20 , 55 , 40 ] ;
53606: LD_ADDR_VAR 0 9
53610: PUSH
53611: LD_INT 20
53613: PUSH
53614: LD_INT 55
53616: PUSH
53617: LD_INT 40
53619: PUSH
53620: EMPTY
53621: LIST
53622: LIST
53623: LIST
53624: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
53625: LD_VAR 0 6
53629: PPUSH
53630: CALL_OW 257
53634: PUSH
53635: LD_INT 12
53637: PUSH
53638: LD_INT 16
53640: PUSH
53641: EMPTY
53642: LIST
53643: LIST
53644: IN
53645: IFFALSE 53666
// points := [ 5 , 3 , 2 ] ;
53647: LD_ADDR_VAR 0 9
53651: PUSH
53652: LD_INT 5
53654: PUSH
53655: LD_INT 3
53657: PUSH
53658: LD_INT 2
53660: PUSH
53661: EMPTY
53662: LIST
53663: LIST
53664: LIST
53665: ST_TO_ADDR
// if GetClass ( i ) = 17 then
53666: LD_VAR 0 6
53670: PPUSH
53671: CALL_OW 257
53675: PUSH
53676: LD_INT 17
53678: EQUAL
53679: IFFALSE 53700
// points := [ 100 , 50 , 75 ] ;
53681: LD_ADDR_VAR 0 9
53685: PUSH
53686: LD_INT 100
53688: PUSH
53689: LD_INT 50
53691: PUSH
53692: LD_INT 75
53694: PUSH
53695: EMPTY
53696: LIST
53697: LIST
53698: LIST
53699: ST_TO_ADDR
// if GetClass ( i ) = 15 then
53700: LD_VAR 0 6
53704: PPUSH
53705: CALL_OW 257
53709: PUSH
53710: LD_INT 15
53712: EQUAL
53713: IFFALSE 53734
// points := [ 10 , 5 , 3 ] ;
53715: LD_ADDR_VAR 0 9
53719: PUSH
53720: LD_INT 10
53722: PUSH
53723: LD_INT 5
53725: PUSH
53726: LD_INT 3
53728: PUSH
53729: EMPTY
53730: LIST
53731: LIST
53732: LIST
53733: ST_TO_ADDR
// if GetClass ( i ) = 14 then
53734: LD_VAR 0 6
53738: PPUSH
53739: CALL_OW 257
53743: PUSH
53744: LD_INT 14
53746: EQUAL
53747: IFFALSE 53768
// points := [ 10 , 0 , 0 ] ;
53749: LD_ADDR_VAR 0 9
53753: PUSH
53754: LD_INT 10
53756: PUSH
53757: LD_INT 0
53759: PUSH
53760: LD_INT 0
53762: PUSH
53763: EMPTY
53764: LIST
53765: LIST
53766: LIST
53767: ST_TO_ADDR
// if GetClass ( i ) = 11 then
53768: LD_VAR 0 6
53772: PPUSH
53773: CALL_OW 257
53777: PUSH
53778: LD_INT 11
53780: EQUAL
53781: IFFALSE 53802
// points := [ 30 , 10 , 5 ] ;
53783: LD_ADDR_VAR 0 9
53787: PUSH
53788: LD_INT 30
53790: PUSH
53791: LD_INT 10
53793: PUSH
53794: LD_INT 5
53796: PUSH
53797: EMPTY
53798: LIST
53799: LIST
53800: LIST
53801: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
53802: LD_VAR 0 1
53806: PPUSH
53807: LD_INT 5
53809: PPUSH
53810: CALL_OW 321
53814: PUSH
53815: LD_INT 2
53817: EQUAL
53818: IFFALSE 53835
// bpoints := bpoints * 1.8 ;
53820: LD_ADDR_VAR 0 10
53824: PUSH
53825: LD_VAR 0 10
53829: PUSH
53830: LD_REAL  1.80000000000000E+0000
53833: MUL
53834: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
53835: LD_VAR 0 6
53839: PPUSH
53840: CALL_OW 257
53844: PUSH
53845: LD_INT 1
53847: PUSH
53848: LD_INT 2
53850: PUSH
53851: LD_INT 3
53853: PUSH
53854: LD_INT 4
53856: PUSH
53857: EMPTY
53858: LIST
53859: LIST
53860: LIST
53861: LIST
53862: IN
53863: PUSH
53864: LD_VAR 0 1
53868: PPUSH
53869: LD_INT 51
53871: PPUSH
53872: CALL_OW 321
53876: PUSH
53877: LD_INT 2
53879: EQUAL
53880: AND
53881: IFFALSE 53898
// bpoints := bpoints * 1.2 ;
53883: LD_ADDR_VAR 0 10
53887: PUSH
53888: LD_VAR 0 10
53892: PUSH
53893: LD_REAL  1.20000000000000E+0000
53896: MUL
53897: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
53898: LD_VAR 0 6
53902: PPUSH
53903: CALL_OW 257
53907: PUSH
53908: LD_INT 5
53910: PUSH
53911: LD_INT 7
53913: PUSH
53914: LD_INT 9
53916: PUSH
53917: EMPTY
53918: LIST
53919: LIST
53920: LIST
53921: IN
53922: PUSH
53923: LD_VAR 0 1
53927: PPUSH
53928: LD_INT 52
53930: PPUSH
53931: CALL_OW 321
53935: PUSH
53936: LD_INT 2
53938: EQUAL
53939: AND
53940: IFFALSE 53957
// bpoints := bpoints * 1.5 ;
53942: LD_ADDR_VAR 0 10
53946: PUSH
53947: LD_VAR 0 10
53951: PUSH
53952: LD_REAL  1.50000000000000E+0000
53955: MUL
53956: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
53957: LD_VAR 0 1
53961: PPUSH
53962: LD_INT 66
53964: PPUSH
53965: CALL_OW 321
53969: PUSH
53970: LD_INT 2
53972: EQUAL
53973: IFFALSE 53990
// bpoints := bpoints * 1.1 ;
53975: LD_ADDR_VAR 0 10
53979: PUSH
53980: LD_VAR 0 10
53984: PUSH
53985: LD_REAL  1.10000000000000E+0000
53988: MUL
53989: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
53990: LD_ADDR_VAR 0 10
53994: PUSH
53995: LD_VAR 0 10
53999: PUSH
54000: LD_VAR 0 6
54004: PPUSH
54005: LD_INT 1
54007: PPUSH
54008: CALL_OW 259
54012: PUSH
54013: LD_REAL  1.15000000000000E+0000
54016: MUL
54017: MUL
54018: ST_TO_ADDR
// end ; unit_vehicle :
54019: GO 54843
54021: LD_INT 2
54023: DOUBLE
54024: EQUAL
54025: IFTRUE 54029
54027: GO 54831
54029: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
54030: LD_VAR 0 6
54034: PPUSH
54035: CALL_OW 264
54039: PUSH
54040: LD_INT 2
54042: PUSH
54043: LD_INT 42
54045: PUSH
54046: LD_INT 24
54048: PUSH
54049: EMPTY
54050: LIST
54051: LIST
54052: LIST
54053: IN
54054: IFFALSE 54075
// points := [ 25 , 5 , 3 ] ;
54056: LD_ADDR_VAR 0 9
54060: PUSH
54061: LD_INT 25
54063: PUSH
54064: LD_INT 5
54066: PUSH
54067: LD_INT 3
54069: PUSH
54070: EMPTY
54071: LIST
54072: LIST
54073: LIST
54074: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
54075: LD_VAR 0 6
54079: PPUSH
54080: CALL_OW 264
54084: PUSH
54085: LD_INT 4
54087: PUSH
54088: LD_INT 43
54090: PUSH
54091: LD_INT 25
54093: PUSH
54094: EMPTY
54095: LIST
54096: LIST
54097: LIST
54098: IN
54099: IFFALSE 54120
// points := [ 40 , 15 , 5 ] ;
54101: LD_ADDR_VAR 0 9
54105: PUSH
54106: LD_INT 40
54108: PUSH
54109: LD_INT 15
54111: PUSH
54112: LD_INT 5
54114: PUSH
54115: EMPTY
54116: LIST
54117: LIST
54118: LIST
54119: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
54120: LD_VAR 0 6
54124: PPUSH
54125: CALL_OW 264
54129: PUSH
54130: LD_INT 3
54132: PUSH
54133: LD_INT 23
54135: PUSH
54136: EMPTY
54137: LIST
54138: LIST
54139: IN
54140: IFFALSE 54161
// points := [ 7 , 25 , 8 ] ;
54142: LD_ADDR_VAR 0 9
54146: PUSH
54147: LD_INT 7
54149: PUSH
54150: LD_INT 25
54152: PUSH
54153: LD_INT 8
54155: PUSH
54156: EMPTY
54157: LIST
54158: LIST
54159: LIST
54160: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
54161: LD_VAR 0 6
54165: PPUSH
54166: CALL_OW 264
54170: PUSH
54171: LD_INT 5
54173: PUSH
54174: LD_INT 27
54176: PUSH
54177: LD_INT 44
54179: PUSH
54180: EMPTY
54181: LIST
54182: LIST
54183: LIST
54184: IN
54185: IFFALSE 54206
// points := [ 14 , 50 , 16 ] ;
54187: LD_ADDR_VAR 0 9
54191: PUSH
54192: LD_INT 14
54194: PUSH
54195: LD_INT 50
54197: PUSH
54198: LD_INT 16
54200: PUSH
54201: EMPTY
54202: LIST
54203: LIST
54204: LIST
54205: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
54206: LD_VAR 0 6
54210: PPUSH
54211: CALL_OW 264
54215: PUSH
54216: LD_INT 6
54218: PUSH
54219: LD_INT 46
54221: PUSH
54222: EMPTY
54223: LIST
54224: LIST
54225: IN
54226: IFFALSE 54247
// points := [ 32 , 120 , 70 ] ;
54228: LD_ADDR_VAR 0 9
54232: PUSH
54233: LD_INT 32
54235: PUSH
54236: LD_INT 120
54238: PUSH
54239: LD_INT 70
54241: PUSH
54242: EMPTY
54243: LIST
54244: LIST
54245: LIST
54246: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
54247: LD_VAR 0 6
54251: PPUSH
54252: CALL_OW 264
54256: PUSH
54257: LD_INT 7
54259: PUSH
54260: LD_INT 28
54262: PUSH
54263: LD_INT 45
54265: PUSH
54266: EMPTY
54267: LIST
54268: LIST
54269: LIST
54270: IN
54271: IFFALSE 54292
// points := [ 35 , 20 , 45 ] ;
54273: LD_ADDR_VAR 0 9
54277: PUSH
54278: LD_INT 35
54280: PUSH
54281: LD_INT 20
54283: PUSH
54284: LD_INT 45
54286: PUSH
54287: EMPTY
54288: LIST
54289: LIST
54290: LIST
54291: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
54292: LD_VAR 0 6
54296: PPUSH
54297: CALL_OW 264
54301: PUSH
54302: LD_INT 47
54304: PUSH
54305: EMPTY
54306: LIST
54307: IN
54308: IFFALSE 54329
// points := [ 67 , 45 , 75 ] ;
54310: LD_ADDR_VAR 0 9
54314: PUSH
54315: LD_INT 67
54317: PUSH
54318: LD_INT 45
54320: PUSH
54321: LD_INT 75
54323: PUSH
54324: EMPTY
54325: LIST
54326: LIST
54327: LIST
54328: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
54329: LD_VAR 0 6
54333: PPUSH
54334: CALL_OW 264
54338: PUSH
54339: LD_INT 26
54341: PUSH
54342: EMPTY
54343: LIST
54344: IN
54345: IFFALSE 54366
// points := [ 120 , 30 , 80 ] ;
54347: LD_ADDR_VAR 0 9
54351: PUSH
54352: LD_INT 120
54354: PUSH
54355: LD_INT 30
54357: PUSH
54358: LD_INT 80
54360: PUSH
54361: EMPTY
54362: LIST
54363: LIST
54364: LIST
54365: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
54366: LD_VAR 0 6
54370: PPUSH
54371: CALL_OW 264
54375: PUSH
54376: LD_INT 22
54378: PUSH
54379: EMPTY
54380: LIST
54381: IN
54382: IFFALSE 54403
// points := [ 40 , 1 , 1 ] ;
54384: LD_ADDR_VAR 0 9
54388: PUSH
54389: LD_INT 40
54391: PUSH
54392: LD_INT 1
54394: PUSH
54395: LD_INT 1
54397: PUSH
54398: EMPTY
54399: LIST
54400: LIST
54401: LIST
54402: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
54403: LD_VAR 0 6
54407: PPUSH
54408: CALL_OW 264
54412: PUSH
54413: LD_INT 29
54415: PUSH
54416: EMPTY
54417: LIST
54418: IN
54419: IFFALSE 54440
// points := [ 70 , 200 , 400 ] ;
54421: LD_ADDR_VAR 0 9
54425: PUSH
54426: LD_INT 70
54428: PUSH
54429: LD_INT 200
54431: PUSH
54432: LD_INT 400
54434: PUSH
54435: EMPTY
54436: LIST
54437: LIST
54438: LIST
54439: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
54440: LD_VAR 0 6
54444: PPUSH
54445: CALL_OW 264
54449: PUSH
54450: LD_INT 14
54452: PUSH
54453: LD_INT 53
54455: PUSH
54456: EMPTY
54457: LIST
54458: LIST
54459: IN
54460: IFFALSE 54481
// points := [ 40 , 10 , 20 ] ;
54462: LD_ADDR_VAR 0 9
54466: PUSH
54467: LD_INT 40
54469: PUSH
54470: LD_INT 10
54472: PUSH
54473: LD_INT 20
54475: PUSH
54476: EMPTY
54477: LIST
54478: LIST
54479: LIST
54480: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
54481: LD_VAR 0 6
54485: PPUSH
54486: CALL_OW 264
54490: PUSH
54491: LD_INT 9
54493: PUSH
54494: EMPTY
54495: LIST
54496: IN
54497: IFFALSE 54518
// points := [ 5 , 70 , 20 ] ;
54499: LD_ADDR_VAR 0 9
54503: PUSH
54504: LD_INT 5
54506: PUSH
54507: LD_INT 70
54509: PUSH
54510: LD_INT 20
54512: PUSH
54513: EMPTY
54514: LIST
54515: LIST
54516: LIST
54517: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
54518: LD_VAR 0 6
54522: PPUSH
54523: CALL_OW 264
54527: PUSH
54528: LD_INT 10
54530: PUSH
54531: EMPTY
54532: LIST
54533: IN
54534: IFFALSE 54555
// points := [ 35 , 110 , 70 ] ;
54536: LD_ADDR_VAR 0 9
54540: PUSH
54541: LD_INT 35
54543: PUSH
54544: LD_INT 110
54546: PUSH
54547: LD_INT 70
54549: PUSH
54550: EMPTY
54551: LIST
54552: LIST
54553: LIST
54554: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
54555: LD_VAR 0 6
54559: PPUSH
54560: CALL_OW 265
54564: PUSH
54565: LD_INT 25
54567: EQUAL
54568: IFFALSE 54589
// points := [ 80 , 65 , 100 ] ;
54570: LD_ADDR_VAR 0 9
54574: PUSH
54575: LD_INT 80
54577: PUSH
54578: LD_INT 65
54580: PUSH
54581: LD_INT 100
54583: PUSH
54584: EMPTY
54585: LIST
54586: LIST
54587: LIST
54588: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
54589: LD_VAR 0 6
54593: PPUSH
54594: CALL_OW 263
54598: PUSH
54599: LD_INT 1
54601: EQUAL
54602: IFFALSE 54637
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
54604: LD_ADDR_VAR 0 10
54608: PUSH
54609: LD_VAR 0 10
54613: PUSH
54614: LD_VAR 0 6
54618: PPUSH
54619: CALL_OW 311
54623: PPUSH
54624: LD_INT 3
54626: PPUSH
54627: CALL_OW 259
54631: PUSH
54632: LD_INT 4
54634: MUL
54635: MUL
54636: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
54637: LD_VAR 0 6
54641: PPUSH
54642: CALL_OW 263
54646: PUSH
54647: LD_INT 2
54649: EQUAL
54650: IFFALSE 54701
// begin j := IsControledBy ( i ) ;
54652: LD_ADDR_VAR 0 7
54656: PUSH
54657: LD_VAR 0 6
54661: PPUSH
54662: CALL_OW 312
54666: ST_TO_ADDR
// if j then
54667: LD_VAR 0 7
54671: IFFALSE 54701
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
54673: LD_ADDR_VAR 0 10
54677: PUSH
54678: LD_VAR 0 10
54682: PUSH
54683: LD_VAR 0 7
54687: PPUSH
54688: LD_INT 3
54690: PPUSH
54691: CALL_OW 259
54695: PUSH
54696: LD_INT 3
54698: MUL
54699: MUL
54700: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
54701: LD_VAR 0 6
54705: PPUSH
54706: CALL_OW 264
54710: PUSH
54711: LD_INT 5
54713: PUSH
54714: LD_INT 6
54716: PUSH
54717: LD_INT 46
54719: PUSH
54720: LD_INT 44
54722: PUSH
54723: LD_INT 47
54725: PUSH
54726: LD_INT 45
54728: PUSH
54729: LD_INT 28
54731: PUSH
54732: LD_INT 7
54734: PUSH
54735: LD_INT 27
54737: PUSH
54738: LD_INT 29
54740: PUSH
54741: EMPTY
54742: LIST
54743: LIST
54744: LIST
54745: LIST
54746: LIST
54747: LIST
54748: LIST
54749: LIST
54750: LIST
54751: LIST
54752: IN
54753: PUSH
54754: LD_VAR 0 1
54758: PPUSH
54759: LD_INT 52
54761: PPUSH
54762: CALL_OW 321
54766: PUSH
54767: LD_INT 2
54769: EQUAL
54770: AND
54771: IFFALSE 54788
// bpoints := bpoints * 1.2 ;
54773: LD_ADDR_VAR 0 10
54777: PUSH
54778: LD_VAR 0 10
54782: PUSH
54783: LD_REAL  1.20000000000000E+0000
54786: MUL
54787: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
54788: LD_VAR 0 6
54792: PPUSH
54793: CALL_OW 264
54797: PUSH
54798: LD_INT 6
54800: PUSH
54801: LD_INT 46
54803: PUSH
54804: LD_INT 47
54806: PUSH
54807: EMPTY
54808: LIST
54809: LIST
54810: LIST
54811: IN
54812: IFFALSE 54829
// bpoints := bpoints * 1.2 ;
54814: LD_ADDR_VAR 0 10
54818: PUSH
54819: LD_VAR 0 10
54823: PUSH
54824: LD_REAL  1.20000000000000E+0000
54827: MUL
54828: ST_TO_ADDR
// end ; unit_building :
54829: GO 54843
54831: LD_INT 3
54833: DOUBLE
54834: EQUAL
54835: IFTRUE 54839
54837: GO 54842
54839: POP
// ; end ;
54840: GO 54843
54842: POP
// for j = 1 to 3 do
54843: LD_ADDR_VAR 0 7
54847: PUSH
54848: DOUBLE
54849: LD_INT 1
54851: DEC
54852: ST_TO_ADDR
54853: LD_INT 3
54855: PUSH
54856: FOR_TO
54857: IFFALSE 54910
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
54859: LD_ADDR_VAR 0 5
54863: PUSH
54864: LD_VAR 0 5
54868: PPUSH
54869: LD_VAR 0 7
54873: PPUSH
54874: LD_VAR 0 5
54878: PUSH
54879: LD_VAR 0 7
54883: ARRAY
54884: PUSH
54885: LD_VAR 0 9
54889: PUSH
54890: LD_VAR 0 7
54894: ARRAY
54895: PUSH
54896: LD_VAR 0 10
54900: MUL
54901: PLUS
54902: PPUSH
54903: CALL_OW 1
54907: ST_TO_ADDR
54908: GO 54856
54910: POP
54911: POP
// end ;
54912: GO 53395
54914: POP
54915: POP
// result := Replace ( result , 4 , tmp ) ;
54916: LD_ADDR_VAR 0 5
54920: PUSH
54921: LD_VAR 0 5
54925: PPUSH
54926: LD_INT 4
54928: PPUSH
54929: LD_VAR 0 8
54933: PPUSH
54934: CALL_OW 1
54938: ST_TO_ADDR
// end ;
54939: LD_VAR 0 5
54943: RET
// export function DangerAtRange ( unit , range ) ; begin
54944: LD_INT 0
54946: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
54947: LD_ADDR_VAR 0 3
54951: PUSH
54952: LD_VAR 0 1
54956: PPUSH
54957: CALL_OW 255
54961: PPUSH
54962: LD_VAR 0 1
54966: PPUSH
54967: CALL_OW 250
54971: PPUSH
54972: LD_VAR 0 1
54976: PPUSH
54977: CALL_OW 251
54981: PPUSH
54982: LD_VAR 0 2
54986: PPUSH
54987: CALL 53247 0 4
54991: ST_TO_ADDR
// end ;
54992: LD_VAR 0 3
54996: RET
// export function DangerInArea ( side , area ) ; begin
54997: LD_INT 0
54999: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
55000: LD_ADDR_VAR 0 3
55004: PUSH
55005: LD_VAR 0 2
55009: PPUSH
55010: LD_INT 81
55012: PUSH
55013: LD_VAR 0 1
55017: PUSH
55018: EMPTY
55019: LIST
55020: LIST
55021: PPUSH
55022: CALL_OW 70
55026: ST_TO_ADDR
// end ;
55027: LD_VAR 0 3
55031: RET
// export function IsExtension ( b ) ; begin
55032: LD_INT 0
55034: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
55035: LD_ADDR_VAR 0 2
55039: PUSH
55040: LD_VAR 0 1
55044: PUSH
55045: LD_INT 23
55047: PUSH
55048: LD_INT 20
55050: PUSH
55051: LD_INT 22
55053: PUSH
55054: LD_INT 17
55056: PUSH
55057: LD_INT 24
55059: PUSH
55060: LD_INT 21
55062: PUSH
55063: LD_INT 19
55065: PUSH
55066: LD_INT 16
55068: PUSH
55069: LD_INT 25
55071: PUSH
55072: LD_INT 18
55074: PUSH
55075: EMPTY
55076: LIST
55077: LIST
55078: LIST
55079: LIST
55080: LIST
55081: LIST
55082: LIST
55083: LIST
55084: LIST
55085: LIST
55086: IN
55087: ST_TO_ADDR
// end ;
55088: LD_VAR 0 2
55092: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
55093: LD_INT 0
55095: PPUSH
55096: PPUSH
55097: PPUSH
// result := [ ] ;
55098: LD_ADDR_VAR 0 3
55102: PUSH
55103: EMPTY
55104: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
55105: LD_ADDR_VAR 0 4
55109: PUSH
55110: LD_VAR 0 2
55114: PPUSH
55115: LD_INT 21
55117: PUSH
55118: LD_INT 3
55120: PUSH
55121: EMPTY
55122: LIST
55123: LIST
55124: PPUSH
55125: CALL_OW 70
55129: ST_TO_ADDR
// if not tmp then
55130: LD_VAR 0 4
55134: NOT
55135: IFFALSE 55139
// exit ;
55137: GO 55197
// for i in tmp do
55139: LD_ADDR_VAR 0 5
55143: PUSH
55144: LD_VAR 0 4
55148: PUSH
55149: FOR_IN
55150: IFFALSE 55185
// if GetBase ( i ) <> base then
55152: LD_VAR 0 5
55156: PPUSH
55157: CALL_OW 274
55161: PUSH
55162: LD_VAR 0 1
55166: NONEQUAL
55167: IFFALSE 55183
// ComLinkToBase ( base , i ) ;
55169: LD_VAR 0 1
55173: PPUSH
55174: LD_VAR 0 5
55178: PPUSH
55179: CALL_OW 169
55183: GO 55149
55185: POP
55186: POP
// result := tmp ;
55187: LD_ADDR_VAR 0 3
55191: PUSH
55192: LD_VAR 0 4
55196: ST_TO_ADDR
// end ;
55197: LD_VAR 0 3
55201: RET
// export function ComComplete ( unit , b ) ; var i ; begin
55202: LD_INT 0
55204: PPUSH
55205: PPUSH
// if BuildingStatus ( b ) = bs_build then
55206: LD_VAR 0 2
55210: PPUSH
55211: CALL_OW 461
55215: PUSH
55216: LD_INT 1
55218: EQUAL
55219: IFFALSE 55279
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
55221: LD_VAR 0 1
55225: PPUSH
55226: LD_STRING h
55228: PUSH
55229: LD_VAR 0 2
55233: PPUSH
55234: CALL_OW 250
55238: PUSH
55239: LD_VAR 0 2
55243: PPUSH
55244: CALL_OW 251
55248: PUSH
55249: LD_VAR 0 2
55253: PUSH
55254: LD_INT 0
55256: PUSH
55257: LD_INT 0
55259: PUSH
55260: LD_INT 0
55262: PUSH
55263: EMPTY
55264: LIST
55265: LIST
55266: LIST
55267: LIST
55268: LIST
55269: LIST
55270: LIST
55271: PUSH
55272: EMPTY
55273: LIST
55274: PPUSH
55275: CALL_OW 446
// end ;
55279: LD_VAR 0 3
55283: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
55284: LD_INT 0
55286: PPUSH
55287: PPUSH
55288: PPUSH
55289: PPUSH
55290: PPUSH
55291: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
55292: LD_VAR 0 1
55296: NOT
55297: PUSH
55298: LD_VAR 0 1
55302: PPUSH
55303: CALL_OW 263
55307: PUSH
55308: LD_INT 2
55310: EQUAL
55311: NOT
55312: OR
55313: IFFALSE 55317
// exit ;
55315: GO 55633
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
55317: LD_ADDR_VAR 0 6
55321: PUSH
55322: LD_INT 22
55324: PUSH
55325: LD_VAR 0 1
55329: PPUSH
55330: CALL_OW 255
55334: PUSH
55335: EMPTY
55336: LIST
55337: LIST
55338: PUSH
55339: LD_INT 2
55341: PUSH
55342: LD_INT 30
55344: PUSH
55345: LD_INT 36
55347: PUSH
55348: EMPTY
55349: LIST
55350: LIST
55351: PUSH
55352: LD_INT 34
55354: PUSH
55355: LD_INT 31
55357: PUSH
55358: EMPTY
55359: LIST
55360: LIST
55361: PUSH
55362: EMPTY
55363: LIST
55364: LIST
55365: LIST
55366: PUSH
55367: EMPTY
55368: LIST
55369: LIST
55370: PPUSH
55371: CALL_OW 69
55375: ST_TO_ADDR
// if not tmp then
55376: LD_VAR 0 6
55380: NOT
55381: IFFALSE 55385
// exit ;
55383: GO 55633
// result := [ ] ;
55385: LD_ADDR_VAR 0 2
55389: PUSH
55390: EMPTY
55391: ST_TO_ADDR
// for i in tmp do
55392: LD_ADDR_VAR 0 3
55396: PUSH
55397: LD_VAR 0 6
55401: PUSH
55402: FOR_IN
55403: IFFALSE 55474
// begin t := UnitsInside ( i ) ;
55405: LD_ADDR_VAR 0 4
55409: PUSH
55410: LD_VAR 0 3
55414: PPUSH
55415: CALL_OW 313
55419: ST_TO_ADDR
// if t then
55420: LD_VAR 0 4
55424: IFFALSE 55472
// for j in t do
55426: LD_ADDR_VAR 0 7
55430: PUSH
55431: LD_VAR 0 4
55435: PUSH
55436: FOR_IN
55437: IFFALSE 55470
// result := Insert ( result , result + 1 , j ) ;
55439: LD_ADDR_VAR 0 2
55443: PUSH
55444: LD_VAR 0 2
55448: PPUSH
55449: LD_VAR 0 2
55453: PUSH
55454: LD_INT 1
55456: PLUS
55457: PPUSH
55458: LD_VAR 0 7
55462: PPUSH
55463: CALL_OW 2
55467: ST_TO_ADDR
55468: GO 55436
55470: POP
55471: POP
// end ;
55472: GO 55402
55474: POP
55475: POP
// if not result then
55476: LD_VAR 0 2
55480: NOT
55481: IFFALSE 55485
// exit ;
55483: GO 55633
// mech := result [ 1 ] ;
55485: LD_ADDR_VAR 0 5
55489: PUSH
55490: LD_VAR 0 2
55494: PUSH
55495: LD_INT 1
55497: ARRAY
55498: ST_TO_ADDR
// if result > 1 then
55499: LD_VAR 0 2
55503: PUSH
55504: LD_INT 1
55506: GREATER
55507: IFFALSE 55619
// for i = 2 to result do
55509: LD_ADDR_VAR 0 3
55513: PUSH
55514: DOUBLE
55515: LD_INT 2
55517: DEC
55518: ST_TO_ADDR
55519: LD_VAR 0 2
55523: PUSH
55524: FOR_TO
55525: IFFALSE 55617
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
55527: LD_ADDR_VAR 0 4
55531: PUSH
55532: LD_VAR 0 2
55536: PUSH
55537: LD_VAR 0 3
55541: ARRAY
55542: PPUSH
55543: LD_INT 3
55545: PPUSH
55546: CALL_OW 259
55550: PUSH
55551: LD_VAR 0 2
55555: PUSH
55556: LD_VAR 0 3
55560: ARRAY
55561: PPUSH
55562: CALL_OW 432
55566: MINUS
55567: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
55568: LD_VAR 0 4
55572: PUSH
55573: LD_VAR 0 5
55577: PPUSH
55578: LD_INT 3
55580: PPUSH
55581: CALL_OW 259
55585: PUSH
55586: LD_VAR 0 5
55590: PPUSH
55591: CALL_OW 432
55595: MINUS
55596: GREATEREQUAL
55597: IFFALSE 55615
// mech := result [ i ] ;
55599: LD_ADDR_VAR 0 5
55603: PUSH
55604: LD_VAR 0 2
55608: PUSH
55609: LD_VAR 0 3
55613: ARRAY
55614: ST_TO_ADDR
// end ;
55615: GO 55524
55617: POP
55618: POP
// ComLinkTo ( vehicle , mech ) ;
55619: LD_VAR 0 1
55623: PPUSH
55624: LD_VAR 0 5
55628: PPUSH
55629: CALL_OW 135
// end ;
55633: LD_VAR 0 2
55637: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
55638: LD_INT 0
55640: PPUSH
55641: PPUSH
55642: PPUSH
55643: PPUSH
55644: PPUSH
55645: PPUSH
55646: PPUSH
55647: PPUSH
55648: PPUSH
55649: PPUSH
55650: PPUSH
55651: PPUSH
55652: PPUSH
// result := [ ] ;
55653: LD_ADDR_VAR 0 7
55657: PUSH
55658: EMPTY
55659: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
55660: LD_VAR 0 1
55664: PPUSH
55665: CALL_OW 266
55669: PUSH
55670: LD_INT 0
55672: PUSH
55673: LD_INT 1
55675: PUSH
55676: EMPTY
55677: LIST
55678: LIST
55679: IN
55680: NOT
55681: IFFALSE 55685
// exit ;
55683: GO 57316
// if name then
55685: LD_VAR 0 3
55689: IFFALSE 55705
// SetBName ( base_dep , name ) ;
55691: LD_VAR 0 1
55695: PPUSH
55696: LD_VAR 0 3
55700: PPUSH
55701: CALL_OW 500
// base := GetBase ( base_dep ) ;
55705: LD_ADDR_VAR 0 15
55709: PUSH
55710: LD_VAR 0 1
55714: PPUSH
55715: CALL_OW 274
55719: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
55720: LD_ADDR_VAR 0 16
55724: PUSH
55725: LD_VAR 0 1
55729: PPUSH
55730: CALL_OW 255
55734: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
55735: LD_ADDR_VAR 0 17
55739: PUSH
55740: LD_VAR 0 1
55744: PPUSH
55745: CALL_OW 248
55749: ST_TO_ADDR
// if sources then
55750: LD_VAR 0 5
55754: IFFALSE 55801
// for i = 1 to 3 do
55756: LD_ADDR_VAR 0 8
55760: PUSH
55761: DOUBLE
55762: LD_INT 1
55764: DEC
55765: ST_TO_ADDR
55766: LD_INT 3
55768: PUSH
55769: FOR_TO
55770: IFFALSE 55799
// AddResourceType ( base , i , sources [ i ] ) ;
55772: LD_VAR 0 15
55776: PPUSH
55777: LD_VAR 0 8
55781: PPUSH
55782: LD_VAR 0 5
55786: PUSH
55787: LD_VAR 0 8
55791: ARRAY
55792: PPUSH
55793: CALL_OW 276
55797: GO 55769
55799: POP
55800: POP
// buildings := GetBaseBuildings ( base , area ) ;
55801: LD_ADDR_VAR 0 18
55805: PUSH
55806: LD_VAR 0 15
55810: PPUSH
55811: LD_VAR 0 2
55815: PPUSH
55816: CALL 55093 0 2
55820: ST_TO_ADDR
// InitHc ;
55821: CALL_OW 19
// InitUc ;
55825: CALL_OW 18
// uc_side := side ;
55829: LD_ADDR_OWVAR 20
55833: PUSH
55834: LD_VAR 0 16
55838: ST_TO_ADDR
// uc_nation := nation ;
55839: LD_ADDR_OWVAR 21
55843: PUSH
55844: LD_VAR 0 17
55848: ST_TO_ADDR
// if buildings then
55849: LD_VAR 0 18
55853: IFFALSE 57175
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
55855: LD_ADDR_VAR 0 19
55859: PUSH
55860: LD_VAR 0 18
55864: PPUSH
55865: LD_INT 2
55867: PUSH
55868: LD_INT 30
55870: PUSH
55871: LD_INT 29
55873: PUSH
55874: EMPTY
55875: LIST
55876: LIST
55877: PUSH
55878: LD_INT 30
55880: PUSH
55881: LD_INT 30
55883: PUSH
55884: EMPTY
55885: LIST
55886: LIST
55887: PUSH
55888: EMPTY
55889: LIST
55890: LIST
55891: LIST
55892: PPUSH
55893: CALL_OW 72
55897: ST_TO_ADDR
// if tmp then
55898: LD_VAR 0 19
55902: IFFALSE 55950
// for i in tmp do
55904: LD_ADDR_VAR 0 8
55908: PUSH
55909: LD_VAR 0 19
55913: PUSH
55914: FOR_IN
55915: IFFALSE 55948
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
55917: LD_VAR 0 8
55921: PPUSH
55922: CALL_OW 250
55926: PPUSH
55927: LD_VAR 0 8
55931: PPUSH
55932: CALL_OW 251
55936: PPUSH
55937: LD_VAR 0 16
55941: PPUSH
55942: CALL_OW 441
55946: GO 55914
55948: POP
55949: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
55950: LD_VAR 0 18
55954: PPUSH
55955: LD_INT 2
55957: PUSH
55958: LD_INT 30
55960: PUSH
55961: LD_INT 32
55963: PUSH
55964: EMPTY
55965: LIST
55966: LIST
55967: PUSH
55968: LD_INT 30
55970: PUSH
55971: LD_INT 33
55973: PUSH
55974: EMPTY
55975: LIST
55976: LIST
55977: PUSH
55978: EMPTY
55979: LIST
55980: LIST
55981: LIST
55982: PPUSH
55983: CALL_OW 72
55987: IFFALSE 56075
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
55989: LD_ADDR_VAR 0 8
55993: PUSH
55994: LD_VAR 0 18
55998: PPUSH
55999: LD_INT 2
56001: PUSH
56002: LD_INT 30
56004: PUSH
56005: LD_INT 32
56007: PUSH
56008: EMPTY
56009: LIST
56010: LIST
56011: PUSH
56012: LD_INT 30
56014: PUSH
56015: LD_INT 33
56017: PUSH
56018: EMPTY
56019: LIST
56020: LIST
56021: PUSH
56022: EMPTY
56023: LIST
56024: LIST
56025: LIST
56026: PPUSH
56027: CALL_OW 72
56031: PUSH
56032: FOR_IN
56033: IFFALSE 56073
// begin if not GetBWeapon ( i ) then
56035: LD_VAR 0 8
56039: PPUSH
56040: CALL_OW 269
56044: NOT
56045: IFFALSE 56071
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
56047: LD_VAR 0 8
56051: PPUSH
56052: LD_VAR 0 8
56056: PPUSH
56057: LD_VAR 0 2
56061: PPUSH
56062: CALL 57321 0 2
56066: PPUSH
56067: CALL_OW 431
// end ;
56071: GO 56032
56073: POP
56074: POP
// end ; for i = 1 to personel do
56075: LD_ADDR_VAR 0 8
56079: PUSH
56080: DOUBLE
56081: LD_INT 1
56083: DEC
56084: ST_TO_ADDR
56085: LD_VAR 0 6
56089: PUSH
56090: FOR_TO
56091: IFFALSE 57155
// begin if i > 4 then
56093: LD_VAR 0 8
56097: PUSH
56098: LD_INT 4
56100: GREATER
56101: IFFALSE 56105
// break ;
56103: GO 57155
// case i of 1 :
56105: LD_VAR 0 8
56109: PUSH
56110: LD_INT 1
56112: DOUBLE
56113: EQUAL
56114: IFTRUE 56118
56116: GO 56198
56118: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
56119: LD_ADDR_VAR 0 12
56123: PUSH
56124: LD_VAR 0 18
56128: PPUSH
56129: LD_INT 22
56131: PUSH
56132: LD_VAR 0 16
56136: PUSH
56137: EMPTY
56138: LIST
56139: LIST
56140: PUSH
56141: LD_INT 58
56143: PUSH
56144: EMPTY
56145: LIST
56146: PUSH
56147: LD_INT 2
56149: PUSH
56150: LD_INT 30
56152: PUSH
56153: LD_INT 32
56155: PUSH
56156: EMPTY
56157: LIST
56158: LIST
56159: PUSH
56160: LD_INT 30
56162: PUSH
56163: LD_INT 4
56165: PUSH
56166: EMPTY
56167: LIST
56168: LIST
56169: PUSH
56170: LD_INT 30
56172: PUSH
56173: LD_INT 5
56175: PUSH
56176: EMPTY
56177: LIST
56178: LIST
56179: PUSH
56180: EMPTY
56181: LIST
56182: LIST
56183: LIST
56184: LIST
56185: PUSH
56186: EMPTY
56187: LIST
56188: LIST
56189: LIST
56190: PPUSH
56191: CALL_OW 72
56195: ST_TO_ADDR
56196: GO 56420
56198: LD_INT 2
56200: DOUBLE
56201: EQUAL
56202: IFTRUE 56206
56204: GO 56268
56206: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
56207: LD_ADDR_VAR 0 12
56211: PUSH
56212: LD_VAR 0 18
56216: PPUSH
56217: LD_INT 22
56219: PUSH
56220: LD_VAR 0 16
56224: PUSH
56225: EMPTY
56226: LIST
56227: LIST
56228: PUSH
56229: LD_INT 2
56231: PUSH
56232: LD_INT 30
56234: PUSH
56235: LD_INT 0
56237: PUSH
56238: EMPTY
56239: LIST
56240: LIST
56241: PUSH
56242: LD_INT 30
56244: PUSH
56245: LD_INT 1
56247: PUSH
56248: EMPTY
56249: LIST
56250: LIST
56251: PUSH
56252: EMPTY
56253: LIST
56254: LIST
56255: LIST
56256: PUSH
56257: EMPTY
56258: LIST
56259: LIST
56260: PPUSH
56261: CALL_OW 72
56265: ST_TO_ADDR
56266: GO 56420
56268: LD_INT 3
56270: DOUBLE
56271: EQUAL
56272: IFTRUE 56276
56274: GO 56338
56276: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
56277: LD_ADDR_VAR 0 12
56281: PUSH
56282: LD_VAR 0 18
56286: PPUSH
56287: LD_INT 22
56289: PUSH
56290: LD_VAR 0 16
56294: PUSH
56295: EMPTY
56296: LIST
56297: LIST
56298: PUSH
56299: LD_INT 2
56301: PUSH
56302: LD_INT 30
56304: PUSH
56305: LD_INT 2
56307: PUSH
56308: EMPTY
56309: LIST
56310: LIST
56311: PUSH
56312: LD_INT 30
56314: PUSH
56315: LD_INT 3
56317: PUSH
56318: EMPTY
56319: LIST
56320: LIST
56321: PUSH
56322: EMPTY
56323: LIST
56324: LIST
56325: LIST
56326: PUSH
56327: EMPTY
56328: LIST
56329: LIST
56330: PPUSH
56331: CALL_OW 72
56335: ST_TO_ADDR
56336: GO 56420
56338: LD_INT 4
56340: DOUBLE
56341: EQUAL
56342: IFTRUE 56346
56344: GO 56419
56346: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
56347: LD_ADDR_VAR 0 12
56351: PUSH
56352: LD_VAR 0 18
56356: PPUSH
56357: LD_INT 22
56359: PUSH
56360: LD_VAR 0 16
56364: PUSH
56365: EMPTY
56366: LIST
56367: LIST
56368: PUSH
56369: LD_INT 2
56371: PUSH
56372: LD_INT 30
56374: PUSH
56375: LD_INT 6
56377: PUSH
56378: EMPTY
56379: LIST
56380: LIST
56381: PUSH
56382: LD_INT 30
56384: PUSH
56385: LD_INT 7
56387: PUSH
56388: EMPTY
56389: LIST
56390: LIST
56391: PUSH
56392: LD_INT 30
56394: PUSH
56395: LD_INT 8
56397: PUSH
56398: EMPTY
56399: LIST
56400: LIST
56401: PUSH
56402: EMPTY
56403: LIST
56404: LIST
56405: LIST
56406: LIST
56407: PUSH
56408: EMPTY
56409: LIST
56410: LIST
56411: PPUSH
56412: CALL_OW 72
56416: ST_TO_ADDR
56417: GO 56420
56419: POP
// if i = 1 then
56420: LD_VAR 0 8
56424: PUSH
56425: LD_INT 1
56427: EQUAL
56428: IFFALSE 56539
// begin tmp := [ ] ;
56430: LD_ADDR_VAR 0 19
56434: PUSH
56435: EMPTY
56436: ST_TO_ADDR
// for j in f do
56437: LD_ADDR_VAR 0 9
56441: PUSH
56442: LD_VAR 0 12
56446: PUSH
56447: FOR_IN
56448: IFFALSE 56521
// if GetBType ( j ) = b_bunker then
56450: LD_VAR 0 9
56454: PPUSH
56455: CALL_OW 266
56459: PUSH
56460: LD_INT 32
56462: EQUAL
56463: IFFALSE 56490
// tmp := Insert ( tmp , 1 , j ) else
56465: LD_ADDR_VAR 0 19
56469: PUSH
56470: LD_VAR 0 19
56474: PPUSH
56475: LD_INT 1
56477: PPUSH
56478: LD_VAR 0 9
56482: PPUSH
56483: CALL_OW 2
56487: ST_TO_ADDR
56488: GO 56519
// tmp := Insert ( tmp , tmp + 1 , j ) ;
56490: LD_ADDR_VAR 0 19
56494: PUSH
56495: LD_VAR 0 19
56499: PPUSH
56500: LD_VAR 0 19
56504: PUSH
56505: LD_INT 1
56507: PLUS
56508: PPUSH
56509: LD_VAR 0 9
56513: PPUSH
56514: CALL_OW 2
56518: ST_TO_ADDR
56519: GO 56447
56521: POP
56522: POP
// if tmp then
56523: LD_VAR 0 19
56527: IFFALSE 56539
// f := tmp ;
56529: LD_ADDR_VAR 0 12
56533: PUSH
56534: LD_VAR 0 19
56538: ST_TO_ADDR
// end ; x := personel [ i ] ;
56539: LD_ADDR_VAR 0 13
56543: PUSH
56544: LD_VAR 0 6
56548: PUSH
56549: LD_VAR 0 8
56553: ARRAY
56554: ST_TO_ADDR
// if x = - 1 then
56555: LD_VAR 0 13
56559: PUSH
56560: LD_INT 1
56562: NEG
56563: EQUAL
56564: IFFALSE 56773
// begin for j in f do
56566: LD_ADDR_VAR 0 9
56570: PUSH
56571: LD_VAR 0 12
56575: PUSH
56576: FOR_IN
56577: IFFALSE 56769
// repeat InitHc ;
56579: CALL_OW 19
// if GetBType ( j ) = b_barracks then
56583: LD_VAR 0 9
56587: PPUSH
56588: CALL_OW 266
56592: PUSH
56593: LD_INT 5
56595: EQUAL
56596: IFFALSE 56666
// begin if UnitsInside ( j ) < 3 then
56598: LD_VAR 0 9
56602: PPUSH
56603: CALL_OW 313
56607: PUSH
56608: LD_INT 3
56610: LESS
56611: IFFALSE 56647
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
56613: LD_INT 0
56615: PPUSH
56616: LD_INT 5
56618: PUSH
56619: LD_INT 8
56621: PUSH
56622: LD_INT 9
56624: PUSH
56625: EMPTY
56626: LIST
56627: LIST
56628: LIST
56629: PUSH
56630: LD_VAR 0 17
56634: ARRAY
56635: PPUSH
56636: LD_VAR 0 4
56640: PPUSH
56641: CALL_OW 380
56645: GO 56664
// PrepareHuman ( false , i , skill ) ;
56647: LD_INT 0
56649: PPUSH
56650: LD_VAR 0 8
56654: PPUSH
56655: LD_VAR 0 4
56659: PPUSH
56660: CALL_OW 380
// end else
56664: GO 56683
// PrepareHuman ( false , i , skill ) ;
56666: LD_INT 0
56668: PPUSH
56669: LD_VAR 0 8
56673: PPUSH
56674: LD_VAR 0 4
56678: PPUSH
56679: CALL_OW 380
// un := CreateHuman ;
56683: LD_ADDR_VAR 0 14
56687: PUSH
56688: CALL_OW 44
56692: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
56693: LD_ADDR_VAR 0 7
56697: PUSH
56698: LD_VAR 0 7
56702: PPUSH
56703: LD_INT 1
56705: PPUSH
56706: LD_VAR 0 14
56710: PPUSH
56711: CALL_OW 2
56715: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
56716: LD_VAR 0 14
56720: PPUSH
56721: LD_VAR 0 9
56725: PPUSH
56726: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
56730: LD_VAR 0 9
56734: PPUSH
56735: CALL_OW 313
56739: PUSH
56740: LD_INT 6
56742: EQUAL
56743: PUSH
56744: LD_VAR 0 9
56748: PPUSH
56749: CALL_OW 266
56753: PUSH
56754: LD_INT 32
56756: PUSH
56757: LD_INT 31
56759: PUSH
56760: EMPTY
56761: LIST
56762: LIST
56763: IN
56764: OR
56765: IFFALSE 56579
56767: GO 56576
56769: POP
56770: POP
// end else
56771: GO 57153
// for j = 1 to x do
56773: LD_ADDR_VAR 0 9
56777: PUSH
56778: DOUBLE
56779: LD_INT 1
56781: DEC
56782: ST_TO_ADDR
56783: LD_VAR 0 13
56787: PUSH
56788: FOR_TO
56789: IFFALSE 57151
// begin InitHc ;
56791: CALL_OW 19
// if not f then
56795: LD_VAR 0 12
56799: NOT
56800: IFFALSE 56889
// begin PrepareHuman ( false , i , skill ) ;
56802: LD_INT 0
56804: PPUSH
56805: LD_VAR 0 8
56809: PPUSH
56810: LD_VAR 0 4
56814: PPUSH
56815: CALL_OW 380
// un := CreateHuman ;
56819: LD_ADDR_VAR 0 14
56823: PUSH
56824: CALL_OW 44
56828: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
56829: LD_ADDR_VAR 0 7
56833: PUSH
56834: LD_VAR 0 7
56838: PPUSH
56839: LD_INT 1
56841: PPUSH
56842: LD_VAR 0 14
56846: PPUSH
56847: CALL_OW 2
56851: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
56852: LD_VAR 0 14
56856: PPUSH
56857: LD_VAR 0 1
56861: PPUSH
56862: CALL_OW 250
56866: PPUSH
56867: LD_VAR 0 1
56871: PPUSH
56872: CALL_OW 251
56876: PPUSH
56877: LD_INT 10
56879: PPUSH
56880: LD_INT 0
56882: PPUSH
56883: CALL_OW 50
// continue ;
56887: GO 56788
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
56889: LD_VAR 0 12
56893: PUSH
56894: LD_INT 1
56896: ARRAY
56897: PPUSH
56898: CALL_OW 313
56902: PUSH
56903: LD_VAR 0 12
56907: PUSH
56908: LD_INT 1
56910: ARRAY
56911: PPUSH
56912: CALL_OW 266
56916: PUSH
56917: LD_INT 32
56919: PUSH
56920: LD_INT 31
56922: PUSH
56923: EMPTY
56924: LIST
56925: LIST
56926: IN
56927: AND
56928: PUSH
56929: LD_VAR 0 12
56933: PUSH
56934: LD_INT 1
56936: ARRAY
56937: PPUSH
56938: CALL_OW 313
56942: PUSH
56943: LD_INT 6
56945: EQUAL
56946: OR
56947: IFFALSE 56967
// f := Delete ( f , 1 ) ;
56949: LD_ADDR_VAR 0 12
56953: PUSH
56954: LD_VAR 0 12
56958: PPUSH
56959: LD_INT 1
56961: PPUSH
56962: CALL_OW 3
56966: ST_TO_ADDR
// if not f then
56967: LD_VAR 0 12
56971: NOT
56972: IFFALSE 56990
// begin x := x + 2 ;
56974: LD_ADDR_VAR 0 13
56978: PUSH
56979: LD_VAR 0 13
56983: PUSH
56984: LD_INT 2
56986: PLUS
56987: ST_TO_ADDR
// continue ;
56988: GO 56788
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
56990: LD_VAR 0 12
56994: PUSH
56995: LD_INT 1
56997: ARRAY
56998: PPUSH
56999: CALL_OW 266
57003: PUSH
57004: LD_INT 5
57006: EQUAL
57007: IFFALSE 57081
// begin if UnitsInside ( f [ 1 ] ) < 3 then
57009: LD_VAR 0 12
57013: PUSH
57014: LD_INT 1
57016: ARRAY
57017: PPUSH
57018: CALL_OW 313
57022: PUSH
57023: LD_INT 3
57025: LESS
57026: IFFALSE 57062
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
57028: LD_INT 0
57030: PPUSH
57031: LD_INT 5
57033: PUSH
57034: LD_INT 8
57036: PUSH
57037: LD_INT 9
57039: PUSH
57040: EMPTY
57041: LIST
57042: LIST
57043: LIST
57044: PUSH
57045: LD_VAR 0 17
57049: ARRAY
57050: PPUSH
57051: LD_VAR 0 4
57055: PPUSH
57056: CALL_OW 380
57060: GO 57079
// PrepareHuman ( false , i , skill ) ;
57062: LD_INT 0
57064: PPUSH
57065: LD_VAR 0 8
57069: PPUSH
57070: LD_VAR 0 4
57074: PPUSH
57075: CALL_OW 380
// end else
57079: GO 57098
// PrepareHuman ( false , i , skill ) ;
57081: LD_INT 0
57083: PPUSH
57084: LD_VAR 0 8
57088: PPUSH
57089: LD_VAR 0 4
57093: PPUSH
57094: CALL_OW 380
// un := CreateHuman ;
57098: LD_ADDR_VAR 0 14
57102: PUSH
57103: CALL_OW 44
57107: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
57108: LD_ADDR_VAR 0 7
57112: PUSH
57113: LD_VAR 0 7
57117: PPUSH
57118: LD_INT 1
57120: PPUSH
57121: LD_VAR 0 14
57125: PPUSH
57126: CALL_OW 2
57130: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
57131: LD_VAR 0 14
57135: PPUSH
57136: LD_VAR 0 12
57140: PUSH
57141: LD_INT 1
57143: ARRAY
57144: PPUSH
57145: CALL_OW 52
// end ;
57149: GO 56788
57151: POP
57152: POP
// end ;
57153: GO 56090
57155: POP
57156: POP
// result := result ^ buildings ;
57157: LD_ADDR_VAR 0 7
57161: PUSH
57162: LD_VAR 0 7
57166: PUSH
57167: LD_VAR 0 18
57171: ADD
57172: ST_TO_ADDR
// end else
57173: GO 57316
// begin for i = 1 to personel do
57175: LD_ADDR_VAR 0 8
57179: PUSH
57180: DOUBLE
57181: LD_INT 1
57183: DEC
57184: ST_TO_ADDR
57185: LD_VAR 0 6
57189: PUSH
57190: FOR_TO
57191: IFFALSE 57314
// begin if i > 4 then
57193: LD_VAR 0 8
57197: PUSH
57198: LD_INT 4
57200: GREATER
57201: IFFALSE 57205
// break ;
57203: GO 57314
// x := personel [ i ] ;
57205: LD_ADDR_VAR 0 13
57209: PUSH
57210: LD_VAR 0 6
57214: PUSH
57215: LD_VAR 0 8
57219: ARRAY
57220: ST_TO_ADDR
// if x = - 1 then
57221: LD_VAR 0 13
57225: PUSH
57226: LD_INT 1
57228: NEG
57229: EQUAL
57230: IFFALSE 57234
// continue ;
57232: GO 57190
// PrepareHuman ( false , i , skill ) ;
57234: LD_INT 0
57236: PPUSH
57237: LD_VAR 0 8
57241: PPUSH
57242: LD_VAR 0 4
57246: PPUSH
57247: CALL_OW 380
// un := CreateHuman ;
57251: LD_ADDR_VAR 0 14
57255: PUSH
57256: CALL_OW 44
57260: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
57261: LD_VAR 0 14
57265: PPUSH
57266: LD_VAR 0 1
57270: PPUSH
57271: CALL_OW 250
57275: PPUSH
57276: LD_VAR 0 1
57280: PPUSH
57281: CALL_OW 251
57285: PPUSH
57286: LD_INT 10
57288: PPUSH
57289: LD_INT 0
57291: PPUSH
57292: CALL_OW 50
// result := result ^ un ;
57296: LD_ADDR_VAR 0 7
57300: PUSH
57301: LD_VAR 0 7
57305: PUSH
57306: LD_VAR 0 14
57310: ADD
57311: ST_TO_ADDR
// end ;
57312: GO 57190
57314: POP
57315: POP
// end ; end ;
57316: LD_VAR 0 7
57320: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
57321: LD_INT 0
57323: PPUSH
57324: PPUSH
57325: PPUSH
57326: PPUSH
57327: PPUSH
57328: PPUSH
57329: PPUSH
57330: PPUSH
57331: PPUSH
57332: PPUSH
57333: PPUSH
57334: PPUSH
57335: PPUSH
57336: PPUSH
57337: PPUSH
57338: PPUSH
// result := false ;
57339: LD_ADDR_VAR 0 3
57343: PUSH
57344: LD_INT 0
57346: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
57347: LD_VAR 0 1
57351: NOT
57352: PUSH
57353: LD_VAR 0 1
57357: PPUSH
57358: CALL_OW 266
57362: PUSH
57363: LD_INT 32
57365: PUSH
57366: LD_INT 33
57368: PUSH
57369: EMPTY
57370: LIST
57371: LIST
57372: IN
57373: NOT
57374: OR
57375: IFFALSE 57379
// exit ;
57377: GO 58515
// nat := GetNation ( tower ) ;
57379: LD_ADDR_VAR 0 12
57383: PUSH
57384: LD_VAR 0 1
57388: PPUSH
57389: CALL_OW 248
57393: ST_TO_ADDR
// side := GetSide ( tower ) ;
57394: LD_ADDR_VAR 0 16
57398: PUSH
57399: LD_VAR 0 1
57403: PPUSH
57404: CALL_OW 255
57408: ST_TO_ADDR
// x := GetX ( tower ) ;
57409: LD_ADDR_VAR 0 10
57413: PUSH
57414: LD_VAR 0 1
57418: PPUSH
57419: CALL_OW 250
57423: ST_TO_ADDR
// y := GetY ( tower ) ;
57424: LD_ADDR_VAR 0 11
57428: PUSH
57429: LD_VAR 0 1
57433: PPUSH
57434: CALL_OW 251
57438: ST_TO_ADDR
// if not x or not y then
57439: LD_VAR 0 10
57443: NOT
57444: PUSH
57445: LD_VAR 0 11
57449: NOT
57450: OR
57451: IFFALSE 57455
// exit ;
57453: GO 58515
// weapon := 0 ;
57455: LD_ADDR_VAR 0 18
57459: PUSH
57460: LD_INT 0
57462: ST_TO_ADDR
// fac_list := [ ] ;
57463: LD_ADDR_VAR 0 17
57467: PUSH
57468: EMPTY
57469: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
57470: LD_ADDR_VAR 0 6
57474: PUSH
57475: LD_VAR 0 1
57479: PPUSH
57480: CALL_OW 274
57484: PPUSH
57485: LD_VAR 0 2
57489: PPUSH
57490: CALL 55093 0 2
57494: PPUSH
57495: LD_INT 30
57497: PUSH
57498: LD_INT 3
57500: PUSH
57501: EMPTY
57502: LIST
57503: LIST
57504: PPUSH
57505: CALL_OW 72
57509: ST_TO_ADDR
// if not factories then
57510: LD_VAR 0 6
57514: NOT
57515: IFFALSE 57519
// exit ;
57517: GO 58515
// for i in factories do
57519: LD_ADDR_VAR 0 8
57523: PUSH
57524: LD_VAR 0 6
57528: PUSH
57529: FOR_IN
57530: IFFALSE 57555
// fac_list := fac_list union AvailableWeaponList ( i ) ;
57532: LD_ADDR_VAR 0 17
57536: PUSH
57537: LD_VAR 0 17
57541: PUSH
57542: LD_VAR 0 8
57546: PPUSH
57547: CALL_OW 478
57551: UNION
57552: ST_TO_ADDR
57553: GO 57529
57555: POP
57556: POP
// if not fac_list then
57557: LD_VAR 0 17
57561: NOT
57562: IFFALSE 57566
// exit ;
57564: GO 58515
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
57566: LD_ADDR_VAR 0 5
57570: PUSH
57571: LD_INT 4
57573: PUSH
57574: LD_INT 5
57576: PUSH
57577: LD_INT 9
57579: PUSH
57580: LD_INT 10
57582: PUSH
57583: LD_INT 6
57585: PUSH
57586: LD_INT 7
57588: PUSH
57589: LD_INT 11
57591: PUSH
57592: EMPTY
57593: LIST
57594: LIST
57595: LIST
57596: LIST
57597: LIST
57598: LIST
57599: LIST
57600: PUSH
57601: LD_INT 27
57603: PUSH
57604: LD_INT 28
57606: PUSH
57607: LD_INT 26
57609: PUSH
57610: LD_INT 30
57612: PUSH
57613: EMPTY
57614: LIST
57615: LIST
57616: LIST
57617: LIST
57618: PUSH
57619: LD_INT 43
57621: PUSH
57622: LD_INT 44
57624: PUSH
57625: LD_INT 46
57627: PUSH
57628: LD_INT 45
57630: PUSH
57631: LD_INT 47
57633: PUSH
57634: LD_INT 49
57636: PUSH
57637: EMPTY
57638: LIST
57639: LIST
57640: LIST
57641: LIST
57642: LIST
57643: LIST
57644: PUSH
57645: EMPTY
57646: LIST
57647: LIST
57648: LIST
57649: PUSH
57650: LD_VAR 0 12
57654: ARRAY
57655: ST_TO_ADDR
// for i in list do
57656: LD_ADDR_VAR 0 8
57660: PUSH
57661: LD_VAR 0 5
57665: PUSH
57666: FOR_IN
57667: IFFALSE 57700
// if not i in fac_list then
57669: LD_VAR 0 8
57673: PUSH
57674: LD_VAR 0 17
57678: IN
57679: NOT
57680: IFFALSE 57698
// list := list diff i ;
57682: LD_ADDR_VAR 0 5
57686: PUSH
57687: LD_VAR 0 5
57691: PUSH
57692: LD_VAR 0 8
57696: DIFF
57697: ST_TO_ADDR
57698: GO 57666
57700: POP
57701: POP
// if not list then
57702: LD_VAR 0 5
57706: NOT
57707: IFFALSE 57711
// exit ;
57709: GO 58515
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
57711: LD_VAR 0 12
57715: PUSH
57716: LD_INT 3
57718: EQUAL
57719: PUSH
57720: LD_INT 49
57722: PUSH
57723: LD_VAR 0 5
57727: IN
57728: AND
57729: PUSH
57730: LD_INT 31
57732: PPUSH
57733: LD_VAR 0 16
57737: PPUSH
57738: CALL_OW 321
57742: PUSH
57743: LD_INT 2
57745: EQUAL
57746: AND
57747: IFFALSE 57807
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
57749: LD_INT 22
57751: PUSH
57752: LD_VAR 0 16
57756: PUSH
57757: EMPTY
57758: LIST
57759: LIST
57760: PUSH
57761: LD_INT 35
57763: PUSH
57764: LD_INT 49
57766: PUSH
57767: EMPTY
57768: LIST
57769: LIST
57770: PUSH
57771: LD_INT 91
57773: PUSH
57774: LD_VAR 0 1
57778: PUSH
57779: LD_INT 10
57781: PUSH
57782: EMPTY
57783: LIST
57784: LIST
57785: LIST
57786: PUSH
57787: EMPTY
57788: LIST
57789: LIST
57790: LIST
57791: PPUSH
57792: CALL_OW 69
57796: NOT
57797: IFFALSE 57807
// weapon := ru_time_lapser ;
57799: LD_ADDR_VAR 0 18
57803: PUSH
57804: LD_INT 49
57806: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
57807: LD_VAR 0 12
57811: PUSH
57812: LD_INT 1
57814: PUSH
57815: LD_INT 2
57817: PUSH
57818: EMPTY
57819: LIST
57820: LIST
57821: IN
57822: PUSH
57823: LD_INT 11
57825: PUSH
57826: LD_VAR 0 5
57830: IN
57831: PUSH
57832: LD_INT 30
57834: PUSH
57835: LD_VAR 0 5
57839: IN
57840: OR
57841: AND
57842: PUSH
57843: LD_INT 6
57845: PPUSH
57846: LD_VAR 0 16
57850: PPUSH
57851: CALL_OW 321
57855: PUSH
57856: LD_INT 2
57858: EQUAL
57859: AND
57860: IFFALSE 58025
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
57862: LD_INT 22
57864: PUSH
57865: LD_VAR 0 16
57869: PUSH
57870: EMPTY
57871: LIST
57872: LIST
57873: PUSH
57874: LD_INT 2
57876: PUSH
57877: LD_INT 35
57879: PUSH
57880: LD_INT 11
57882: PUSH
57883: EMPTY
57884: LIST
57885: LIST
57886: PUSH
57887: LD_INT 35
57889: PUSH
57890: LD_INT 30
57892: PUSH
57893: EMPTY
57894: LIST
57895: LIST
57896: PUSH
57897: EMPTY
57898: LIST
57899: LIST
57900: LIST
57901: PUSH
57902: LD_INT 91
57904: PUSH
57905: LD_VAR 0 1
57909: PUSH
57910: LD_INT 18
57912: PUSH
57913: EMPTY
57914: LIST
57915: LIST
57916: LIST
57917: PUSH
57918: EMPTY
57919: LIST
57920: LIST
57921: LIST
57922: PPUSH
57923: CALL_OW 69
57927: NOT
57928: PUSH
57929: LD_INT 22
57931: PUSH
57932: LD_VAR 0 16
57936: PUSH
57937: EMPTY
57938: LIST
57939: LIST
57940: PUSH
57941: LD_INT 2
57943: PUSH
57944: LD_INT 30
57946: PUSH
57947: LD_INT 32
57949: PUSH
57950: EMPTY
57951: LIST
57952: LIST
57953: PUSH
57954: LD_INT 30
57956: PUSH
57957: LD_INT 33
57959: PUSH
57960: EMPTY
57961: LIST
57962: LIST
57963: PUSH
57964: EMPTY
57965: LIST
57966: LIST
57967: LIST
57968: PUSH
57969: LD_INT 91
57971: PUSH
57972: LD_VAR 0 1
57976: PUSH
57977: LD_INT 12
57979: PUSH
57980: EMPTY
57981: LIST
57982: LIST
57983: LIST
57984: PUSH
57985: EMPTY
57986: LIST
57987: LIST
57988: LIST
57989: PUSH
57990: EMPTY
57991: LIST
57992: PPUSH
57993: CALL_OW 69
57997: PUSH
57998: LD_INT 2
58000: GREATER
58001: AND
58002: IFFALSE 58025
// weapon := [ us_radar , ar_radar ] [ nat ] ;
58004: LD_ADDR_VAR 0 18
58008: PUSH
58009: LD_INT 11
58011: PUSH
58012: LD_INT 30
58014: PUSH
58015: EMPTY
58016: LIST
58017: LIST
58018: PUSH
58019: LD_VAR 0 12
58023: ARRAY
58024: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
58025: LD_VAR 0 18
58029: NOT
58030: PUSH
58031: LD_INT 40
58033: PPUSH
58034: LD_VAR 0 16
58038: PPUSH
58039: CALL_OW 321
58043: PUSH
58044: LD_INT 2
58046: EQUAL
58047: AND
58048: PUSH
58049: LD_INT 7
58051: PUSH
58052: LD_VAR 0 5
58056: IN
58057: PUSH
58058: LD_INT 28
58060: PUSH
58061: LD_VAR 0 5
58065: IN
58066: OR
58067: PUSH
58068: LD_INT 45
58070: PUSH
58071: LD_VAR 0 5
58075: IN
58076: OR
58077: AND
58078: IFFALSE 58332
// begin hex := GetHexInfo ( x , y ) ;
58080: LD_ADDR_VAR 0 4
58084: PUSH
58085: LD_VAR 0 10
58089: PPUSH
58090: LD_VAR 0 11
58094: PPUSH
58095: CALL_OW 546
58099: ST_TO_ADDR
// if hex [ 1 ] then
58100: LD_VAR 0 4
58104: PUSH
58105: LD_INT 1
58107: ARRAY
58108: IFFALSE 58112
// exit ;
58110: GO 58515
// height := hex [ 2 ] ;
58112: LD_ADDR_VAR 0 15
58116: PUSH
58117: LD_VAR 0 4
58121: PUSH
58122: LD_INT 2
58124: ARRAY
58125: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
58126: LD_ADDR_VAR 0 14
58130: PUSH
58131: LD_INT 0
58133: PUSH
58134: LD_INT 2
58136: PUSH
58137: LD_INT 3
58139: PUSH
58140: LD_INT 5
58142: PUSH
58143: EMPTY
58144: LIST
58145: LIST
58146: LIST
58147: LIST
58148: ST_TO_ADDR
// for i in tmp do
58149: LD_ADDR_VAR 0 8
58153: PUSH
58154: LD_VAR 0 14
58158: PUSH
58159: FOR_IN
58160: IFFALSE 58330
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
58162: LD_ADDR_VAR 0 9
58166: PUSH
58167: LD_VAR 0 10
58171: PPUSH
58172: LD_VAR 0 8
58176: PPUSH
58177: LD_INT 5
58179: PPUSH
58180: CALL_OW 272
58184: PUSH
58185: LD_VAR 0 11
58189: PPUSH
58190: LD_VAR 0 8
58194: PPUSH
58195: LD_INT 5
58197: PPUSH
58198: CALL_OW 273
58202: PUSH
58203: EMPTY
58204: LIST
58205: LIST
58206: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
58207: LD_VAR 0 9
58211: PUSH
58212: LD_INT 1
58214: ARRAY
58215: PPUSH
58216: LD_VAR 0 9
58220: PUSH
58221: LD_INT 2
58223: ARRAY
58224: PPUSH
58225: CALL_OW 488
58229: IFFALSE 58328
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
58231: LD_ADDR_VAR 0 4
58235: PUSH
58236: LD_VAR 0 9
58240: PUSH
58241: LD_INT 1
58243: ARRAY
58244: PPUSH
58245: LD_VAR 0 9
58249: PUSH
58250: LD_INT 2
58252: ARRAY
58253: PPUSH
58254: CALL_OW 546
58258: ST_TO_ADDR
// if hex [ 1 ] then
58259: LD_VAR 0 4
58263: PUSH
58264: LD_INT 1
58266: ARRAY
58267: IFFALSE 58271
// continue ;
58269: GO 58159
// h := hex [ 2 ] ;
58271: LD_ADDR_VAR 0 13
58275: PUSH
58276: LD_VAR 0 4
58280: PUSH
58281: LD_INT 2
58283: ARRAY
58284: ST_TO_ADDR
// if h + 7 < height then
58285: LD_VAR 0 13
58289: PUSH
58290: LD_INT 7
58292: PLUS
58293: PUSH
58294: LD_VAR 0 15
58298: LESS
58299: IFFALSE 58328
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
58301: LD_ADDR_VAR 0 18
58305: PUSH
58306: LD_INT 7
58308: PUSH
58309: LD_INT 28
58311: PUSH
58312: LD_INT 45
58314: PUSH
58315: EMPTY
58316: LIST
58317: LIST
58318: LIST
58319: PUSH
58320: LD_VAR 0 12
58324: ARRAY
58325: ST_TO_ADDR
// break ;
58326: GO 58330
// end ; end ; end ;
58328: GO 58159
58330: POP
58331: POP
// end ; if not weapon then
58332: LD_VAR 0 18
58336: NOT
58337: IFFALSE 58397
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
58339: LD_ADDR_VAR 0 5
58343: PUSH
58344: LD_VAR 0 5
58348: PUSH
58349: LD_INT 11
58351: PUSH
58352: LD_INT 30
58354: PUSH
58355: LD_INT 49
58357: PUSH
58358: EMPTY
58359: LIST
58360: LIST
58361: LIST
58362: DIFF
58363: ST_TO_ADDR
// if not list then
58364: LD_VAR 0 5
58368: NOT
58369: IFFALSE 58373
// exit ;
58371: GO 58515
// weapon := list [ rand ( 1 , list ) ] ;
58373: LD_ADDR_VAR 0 18
58377: PUSH
58378: LD_VAR 0 5
58382: PUSH
58383: LD_INT 1
58385: PPUSH
58386: LD_VAR 0 5
58390: PPUSH
58391: CALL_OW 12
58395: ARRAY
58396: ST_TO_ADDR
// end ; if weapon then
58397: LD_VAR 0 18
58401: IFFALSE 58515
// begin tmp := CostOfWeapon ( weapon ) ;
58403: LD_ADDR_VAR 0 14
58407: PUSH
58408: LD_VAR 0 18
58412: PPUSH
58413: CALL_OW 451
58417: ST_TO_ADDR
// j := GetBase ( tower ) ;
58418: LD_ADDR_VAR 0 9
58422: PUSH
58423: LD_VAR 0 1
58427: PPUSH
58428: CALL_OW 274
58432: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
58433: LD_VAR 0 9
58437: PPUSH
58438: LD_INT 1
58440: PPUSH
58441: CALL_OW 275
58445: PUSH
58446: LD_VAR 0 14
58450: PUSH
58451: LD_INT 1
58453: ARRAY
58454: GREATEREQUAL
58455: PUSH
58456: LD_VAR 0 9
58460: PPUSH
58461: LD_INT 2
58463: PPUSH
58464: CALL_OW 275
58468: PUSH
58469: LD_VAR 0 14
58473: PUSH
58474: LD_INT 2
58476: ARRAY
58477: GREATEREQUAL
58478: AND
58479: PUSH
58480: LD_VAR 0 9
58484: PPUSH
58485: LD_INT 3
58487: PPUSH
58488: CALL_OW 275
58492: PUSH
58493: LD_VAR 0 14
58497: PUSH
58498: LD_INT 3
58500: ARRAY
58501: GREATEREQUAL
58502: AND
58503: IFFALSE 58515
// result := weapon ;
58505: LD_ADDR_VAR 0 3
58509: PUSH
58510: LD_VAR 0 18
58514: ST_TO_ADDR
// end ; end ;
58515: LD_VAR 0 3
58519: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
58520: LD_INT 0
58522: PPUSH
58523: PPUSH
// result := true ;
58524: LD_ADDR_VAR 0 3
58528: PUSH
58529: LD_INT 1
58531: ST_TO_ADDR
// if array1 = array2 then
58532: LD_VAR 0 1
58536: PUSH
58537: LD_VAR 0 2
58541: EQUAL
58542: IFFALSE 58602
// begin for i = 1 to array1 do
58544: LD_ADDR_VAR 0 4
58548: PUSH
58549: DOUBLE
58550: LD_INT 1
58552: DEC
58553: ST_TO_ADDR
58554: LD_VAR 0 1
58558: PUSH
58559: FOR_TO
58560: IFFALSE 58598
// if array1 [ i ] <> array2 [ i ] then
58562: LD_VAR 0 1
58566: PUSH
58567: LD_VAR 0 4
58571: ARRAY
58572: PUSH
58573: LD_VAR 0 2
58577: PUSH
58578: LD_VAR 0 4
58582: ARRAY
58583: NONEQUAL
58584: IFFALSE 58596
// begin result := false ;
58586: LD_ADDR_VAR 0 3
58590: PUSH
58591: LD_INT 0
58593: ST_TO_ADDR
// break ;
58594: GO 58598
// end ;
58596: GO 58559
58598: POP
58599: POP
// end else
58600: GO 58610
// result := false ;
58602: LD_ADDR_VAR 0 3
58606: PUSH
58607: LD_INT 0
58609: ST_TO_ADDR
// end ;
58610: LD_VAR 0 3
58614: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
58615: LD_INT 0
58617: PPUSH
58618: PPUSH
58619: PPUSH
// pom := GetBase ( fac ) ;
58620: LD_ADDR_VAR 0 5
58624: PUSH
58625: LD_VAR 0 1
58629: PPUSH
58630: CALL_OW 274
58634: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
58635: LD_ADDR_VAR 0 4
58639: PUSH
58640: LD_VAR 0 2
58644: PUSH
58645: LD_INT 1
58647: ARRAY
58648: PPUSH
58649: LD_VAR 0 2
58653: PUSH
58654: LD_INT 2
58656: ARRAY
58657: PPUSH
58658: LD_VAR 0 2
58662: PUSH
58663: LD_INT 3
58665: ARRAY
58666: PPUSH
58667: LD_VAR 0 2
58671: PUSH
58672: LD_INT 4
58674: ARRAY
58675: PPUSH
58676: CALL_OW 449
58680: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
58681: LD_ADDR_VAR 0 3
58685: PUSH
58686: LD_VAR 0 5
58690: PPUSH
58691: LD_INT 1
58693: PPUSH
58694: CALL_OW 275
58698: PUSH
58699: LD_VAR 0 4
58703: PUSH
58704: LD_INT 1
58706: ARRAY
58707: GREATEREQUAL
58708: PUSH
58709: LD_VAR 0 5
58713: PPUSH
58714: LD_INT 2
58716: PPUSH
58717: CALL_OW 275
58721: PUSH
58722: LD_VAR 0 4
58726: PUSH
58727: LD_INT 2
58729: ARRAY
58730: GREATEREQUAL
58731: AND
58732: PUSH
58733: LD_VAR 0 5
58737: PPUSH
58738: LD_INT 3
58740: PPUSH
58741: CALL_OW 275
58745: PUSH
58746: LD_VAR 0 4
58750: PUSH
58751: LD_INT 3
58753: ARRAY
58754: GREATEREQUAL
58755: AND
58756: ST_TO_ADDR
// end ;
58757: LD_VAR 0 3
58761: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
58762: LD_INT 0
58764: PPUSH
58765: PPUSH
58766: PPUSH
58767: PPUSH
// pom := GetBase ( building ) ;
58768: LD_ADDR_VAR 0 3
58772: PUSH
58773: LD_VAR 0 1
58777: PPUSH
58778: CALL_OW 274
58782: ST_TO_ADDR
// if not pom then
58783: LD_VAR 0 3
58787: NOT
58788: IFFALSE 58792
// exit ;
58790: GO 58962
// btype := GetBType ( building ) ;
58792: LD_ADDR_VAR 0 5
58796: PUSH
58797: LD_VAR 0 1
58801: PPUSH
58802: CALL_OW 266
58806: ST_TO_ADDR
// if btype = b_armoury then
58807: LD_VAR 0 5
58811: PUSH
58812: LD_INT 4
58814: EQUAL
58815: IFFALSE 58825
// btype := b_barracks ;
58817: LD_ADDR_VAR 0 5
58821: PUSH
58822: LD_INT 5
58824: ST_TO_ADDR
// if btype = b_depot then
58825: LD_VAR 0 5
58829: PUSH
58830: LD_INT 0
58832: EQUAL
58833: IFFALSE 58843
// btype := b_warehouse ;
58835: LD_ADDR_VAR 0 5
58839: PUSH
58840: LD_INT 1
58842: ST_TO_ADDR
// if btype = b_workshop then
58843: LD_VAR 0 5
58847: PUSH
58848: LD_INT 2
58850: EQUAL
58851: IFFALSE 58861
// btype := b_factory ;
58853: LD_ADDR_VAR 0 5
58857: PUSH
58858: LD_INT 3
58860: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
58861: LD_ADDR_VAR 0 4
58865: PUSH
58866: LD_VAR 0 5
58870: PPUSH
58871: LD_VAR 0 1
58875: PPUSH
58876: CALL_OW 248
58880: PPUSH
58881: CALL_OW 450
58885: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
58886: LD_ADDR_VAR 0 2
58890: PUSH
58891: LD_VAR 0 3
58895: PPUSH
58896: LD_INT 1
58898: PPUSH
58899: CALL_OW 275
58903: PUSH
58904: LD_VAR 0 4
58908: PUSH
58909: LD_INT 1
58911: ARRAY
58912: GREATEREQUAL
58913: PUSH
58914: LD_VAR 0 3
58918: PPUSH
58919: LD_INT 2
58921: PPUSH
58922: CALL_OW 275
58926: PUSH
58927: LD_VAR 0 4
58931: PUSH
58932: LD_INT 2
58934: ARRAY
58935: GREATEREQUAL
58936: AND
58937: PUSH
58938: LD_VAR 0 3
58942: PPUSH
58943: LD_INT 3
58945: PPUSH
58946: CALL_OW 275
58950: PUSH
58951: LD_VAR 0 4
58955: PUSH
58956: LD_INT 3
58958: ARRAY
58959: GREATEREQUAL
58960: AND
58961: ST_TO_ADDR
// end ;
58962: LD_VAR 0 2
58966: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
58967: LD_INT 0
58969: PPUSH
58970: PPUSH
58971: PPUSH
// pom := GetBase ( building ) ;
58972: LD_ADDR_VAR 0 4
58976: PUSH
58977: LD_VAR 0 1
58981: PPUSH
58982: CALL_OW 274
58986: ST_TO_ADDR
// if not pom then
58987: LD_VAR 0 4
58991: NOT
58992: IFFALSE 58996
// exit ;
58994: GO 59097
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
58996: LD_ADDR_VAR 0 5
59000: PUSH
59001: LD_VAR 0 2
59005: PPUSH
59006: LD_VAR 0 1
59010: PPUSH
59011: CALL_OW 248
59015: PPUSH
59016: CALL_OW 450
59020: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
59021: LD_ADDR_VAR 0 3
59025: PUSH
59026: LD_VAR 0 4
59030: PPUSH
59031: LD_INT 1
59033: PPUSH
59034: CALL_OW 275
59038: PUSH
59039: LD_VAR 0 5
59043: PUSH
59044: LD_INT 1
59046: ARRAY
59047: GREATEREQUAL
59048: PUSH
59049: LD_VAR 0 4
59053: PPUSH
59054: LD_INT 2
59056: PPUSH
59057: CALL_OW 275
59061: PUSH
59062: LD_VAR 0 5
59066: PUSH
59067: LD_INT 2
59069: ARRAY
59070: GREATEREQUAL
59071: AND
59072: PUSH
59073: LD_VAR 0 4
59077: PPUSH
59078: LD_INT 3
59080: PPUSH
59081: CALL_OW 275
59085: PUSH
59086: LD_VAR 0 5
59090: PUSH
59091: LD_INT 3
59093: ARRAY
59094: GREATEREQUAL
59095: AND
59096: ST_TO_ADDR
// end ;
59097: LD_VAR 0 3
59101: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
59102: LD_INT 0
59104: PPUSH
59105: PPUSH
59106: PPUSH
59107: PPUSH
59108: PPUSH
59109: PPUSH
59110: PPUSH
59111: PPUSH
59112: PPUSH
59113: PPUSH
// result := false ;
59114: LD_ADDR_VAR 0 6
59118: PUSH
59119: LD_INT 0
59121: ST_TO_ADDR
// if not base or not btype or not x or not y then
59122: LD_VAR 0 1
59126: NOT
59127: PUSH
59128: LD_VAR 0 2
59132: NOT
59133: OR
59134: PUSH
59135: LD_VAR 0 3
59139: NOT
59140: OR
59141: PUSH
59142: LD_VAR 0 4
59146: NOT
59147: OR
59148: IFFALSE 59152
// exit ;
59150: GO 59761
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
59152: LD_ADDR_VAR 0 12
59156: PUSH
59157: LD_VAR 0 2
59161: PPUSH
59162: LD_VAR 0 3
59166: PPUSH
59167: LD_VAR 0 4
59171: PPUSH
59172: LD_VAR 0 5
59176: PPUSH
59177: LD_VAR 0 1
59181: PUSH
59182: LD_INT 1
59184: ARRAY
59185: PPUSH
59186: CALL_OW 248
59190: PPUSH
59191: LD_INT 0
59193: PPUSH
59194: CALL 60598 0 6
59198: ST_TO_ADDR
// if not hexes then
59199: LD_VAR 0 12
59203: NOT
59204: IFFALSE 59208
// exit ;
59206: GO 59761
// for i = 1 to hexes do
59208: LD_ADDR_VAR 0 7
59212: PUSH
59213: DOUBLE
59214: LD_INT 1
59216: DEC
59217: ST_TO_ADDR
59218: LD_VAR 0 12
59222: PUSH
59223: FOR_TO
59224: IFFALSE 59759
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
59226: LD_ADDR_VAR 0 11
59230: PUSH
59231: LD_VAR 0 12
59235: PUSH
59236: LD_VAR 0 7
59240: ARRAY
59241: PUSH
59242: LD_INT 1
59244: ARRAY
59245: PPUSH
59246: LD_VAR 0 12
59250: PUSH
59251: LD_VAR 0 7
59255: ARRAY
59256: PUSH
59257: LD_INT 2
59259: ARRAY
59260: PPUSH
59261: CALL_OW 428
59265: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
59266: LD_VAR 0 12
59270: PUSH
59271: LD_VAR 0 7
59275: ARRAY
59276: PUSH
59277: LD_INT 1
59279: ARRAY
59280: PPUSH
59281: LD_VAR 0 12
59285: PUSH
59286: LD_VAR 0 7
59290: ARRAY
59291: PUSH
59292: LD_INT 2
59294: ARRAY
59295: PPUSH
59296: CALL_OW 351
59300: PUSH
59301: LD_VAR 0 12
59305: PUSH
59306: LD_VAR 0 7
59310: ARRAY
59311: PUSH
59312: LD_INT 1
59314: ARRAY
59315: PPUSH
59316: LD_VAR 0 12
59320: PUSH
59321: LD_VAR 0 7
59325: ARRAY
59326: PUSH
59327: LD_INT 2
59329: ARRAY
59330: PPUSH
59331: CALL_OW 488
59335: NOT
59336: OR
59337: PUSH
59338: LD_VAR 0 11
59342: PPUSH
59343: CALL_OW 247
59347: PUSH
59348: LD_INT 3
59350: EQUAL
59351: OR
59352: IFFALSE 59358
// exit ;
59354: POP
59355: POP
59356: GO 59761
// if not tmp or not tmp in base then
59358: LD_VAR 0 11
59362: NOT
59363: PUSH
59364: LD_VAR 0 11
59368: PUSH
59369: LD_VAR 0 1
59373: IN
59374: NOT
59375: OR
59376: IFFALSE 59380
// continue ;
59378: GO 59223
// result := true ;
59380: LD_ADDR_VAR 0 6
59384: PUSH
59385: LD_INT 1
59387: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
59388: LD_ADDR_VAR 0 15
59392: PUSH
59393: LD_VAR 0 1
59397: PPUSH
59398: LD_INT 22
59400: PUSH
59401: LD_VAR 0 11
59405: PPUSH
59406: CALL_OW 255
59410: PUSH
59411: EMPTY
59412: LIST
59413: LIST
59414: PUSH
59415: LD_INT 2
59417: PUSH
59418: LD_INT 30
59420: PUSH
59421: LD_INT 0
59423: PUSH
59424: EMPTY
59425: LIST
59426: LIST
59427: PUSH
59428: LD_INT 30
59430: PUSH
59431: LD_INT 1
59433: PUSH
59434: EMPTY
59435: LIST
59436: LIST
59437: PUSH
59438: EMPTY
59439: LIST
59440: LIST
59441: LIST
59442: PUSH
59443: EMPTY
59444: LIST
59445: LIST
59446: PPUSH
59447: CALL_OW 72
59451: ST_TO_ADDR
// if dep then
59452: LD_VAR 0 15
59456: IFFALSE 59592
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
59458: LD_ADDR_VAR 0 14
59462: PUSH
59463: LD_VAR 0 15
59467: PUSH
59468: LD_INT 1
59470: ARRAY
59471: PPUSH
59472: CALL_OW 250
59476: PPUSH
59477: LD_VAR 0 15
59481: PUSH
59482: LD_INT 1
59484: ARRAY
59485: PPUSH
59486: CALL_OW 254
59490: PPUSH
59491: LD_INT 5
59493: PPUSH
59494: CALL_OW 272
59498: PUSH
59499: LD_VAR 0 15
59503: PUSH
59504: LD_INT 1
59506: ARRAY
59507: PPUSH
59508: CALL_OW 251
59512: PPUSH
59513: LD_VAR 0 15
59517: PUSH
59518: LD_INT 1
59520: ARRAY
59521: PPUSH
59522: CALL_OW 254
59526: PPUSH
59527: LD_INT 5
59529: PPUSH
59530: CALL_OW 273
59534: PUSH
59535: EMPTY
59536: LIST
59537: LIST
59538: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
59539: LD_VAR 0 14
59543: PUSH
59544: LD_INT 1
59546: ARRAY
59547: PPUSH
59548: LD_VAR 0 14
59552: PUSH
59553: LD_INT 2
59555: ARRAY
59556: PPUSH
59557: CALL_OW 488
59561: IFFALSE 59592
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
59563: LD_VAR 0 11
59567: PPUSH
59568: LD_VAR 0 14
59572: PUSH
59573: LD_INT 1
59575: ARRAY
59576: PPUSH
59577: LD_VAR 0 14
59581: PUSH
59582: LD_INT 2
59584: ARRAY
59585: PPUSH
59586: CALL_OW 111
// continue ;
59590: GO 59223
// end ; end ; r := GetDir ( tmp ) ;
59592: LD_ADDR_VAR 0 13
59596: PUSH
59597: LD_VAR 0 11
59601: PPUSH
59602: CALL_OW 254
59606: ST_TO_ADDR
// if r = 5 then
59607: LD_VAR 0 13
59611: PUSH
59612: LD_INT 5
59614: EQUAL
59615: IFFALSE 59625
// r := 0 ;
59617: LD_ADDR_VAR 0 13
59621: PUSH
59622: LD_INT 0
59624: ST_TO_ADDR
// for j = r to 5 do
59625: LD_ADDR_VAR 0 8
59629: PUSH
59630: DOUBLE
59631: LD_VAR 0 13
59635: DEC
59636: ST_TO_ADDR
59637: LD_INT 5
59639: PUSH
59640: FOR_TO
59641: IFFALSE 59755
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
59643: LD_ADDR_VAR 0 9
59647: PUSH
59648: LD_VAR 0 11
59652: PPUSH
59653: CALL_OW 250
59657: PPUSH
59658: LD_VAR 0 8
59662: PPUSH
59663: LD_INT 2
59665: PPUSH
59666: CALL_OW 272
59670: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
59671: LD_ADDR_VAR 0 10
59675: PUSH
59676: LD_VAR 0 11
59680: PPUSH
59681: CALL_OW 251
59685: PPUSH
59686: LD_VAR 0 8
59690: PPUSH
59691: LD_INT 2
59693: PPUSH
59694: CALL_OW 273
59698: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
59699: LD_VAR 0 9
59703: PPUSH
59704: LD_VAR 0 10
59708: PPUSH
59709: CALL_OW 488
59713: PUSH
59714: LD_VAR 0 9
59718: PPUSH
59719: LD_VAR 0 10
59723: PPUSH
59724: CALL_OW 428
59728: NOT
59729: AND
59730: IFFALSE 59753
// begin ComMoveXY ( tmp , _x , _y ) ;
59732: LD_VAR 0 11
59736: PPUSH
59737: LD_VAR 0 9
59741: PPUSH
59742: LD_VAR 0 10
59746: PPUSH
59747: CALL_OW 111
// break ;
59751: GO 59755
// end ; end ;
59753: GO 59640
59755: POP
59756: POP
// end ;
59757: GO 59223
59759: POP
59760: POP
// end ;
59761: LD_VAR 0 6
59765: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
59766: LD_INT 0
59768: PPUSH
59769: PPUSH
59770: PPUSH
59771: PPUSH
59772: PPUSH
59773: PPUSH
59774: PPUSH
59775: PPUSH
59776: PPUSH
59777: PPUSH
// result := false ;
59778: LD_ADDR_VAR 0 6
59782: PUSH
59783: LD_INT 0
59785: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
59786: LD_VAR 0 1
59790: NOT
59791: PUSH
59792: LD_VAR 0 1
59796: PPUSH
59797: CALL_OW 266
59801: PUSH
59802: LD_INT 0
59804: PUSH
59805: LD_INT 1
59807: PUSH
59808: EMPTY
59809: LIST
59810: LIST
59811: IN
59812: NOT
59813: OR
59814: PUSH
59815: LD_VAR 0 2
59819: NOT
59820: OR
59821: PUSH
59822: LD_VAR 0 5
59826: PUSH
59827: LD_INT 0
59829: PUSH
59830: LD_INT 1
59832: PUSH
59833: LD_INT 2
59835: PUSH
59836: LD_INT 3
59838: PUSH
59839: LD_INT 4
59841: PUSH
59842: LD_INT 5
59844: PUSH
59845: EMPTY
59846: LIST
59847: LIST
59848: LIST
59849: LIST
59850: LIST
59851: LIST
59852: IN
59853: NOT
59854: OR
59855: PUSH
59856: LD_VAR 0 3
59860: PPUSH
59861: LD_VAR 0 4
59865: PPUSH
59866: CALL_OW 488
59870: NOT
59871: OR
59872: IFFALSE 59876
// exit ;
59874: GO 60593
// pom := GetBase ( depot ) ;
59876: LD_ADDR_VAR 0 10
59880: PUSH
59881: LD_VAR 0 1
59885: PPUSH
59886: CALL_OW 274
59890: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
59891: LD_ADDR_VAR 0 11
59895: PUSH
59896: LD_VAR 0 2
59900: PPUSH
59901: LD_VAR 0 1
59905: PPUSH
59906: CALL_OW 248
59910: PPUSH
59911: CALL_OW 450
59915: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
59916: LD_VAR 0 10
59920: PPUSH
59921: LD_INT 1
59923: PPUSH
59924: CALL_OW 275
59928: PUSH
59929: LD_VAR 0 11
59933: PUSH
59934: LD_INT 1
59936: ARRAY
59937: GREATEREQUAL
59938: PUSH
59939: LD_VAR 0 10
59943: PPUSH
59944: LD_INT 2
59946: PPUSH
59947: CALL_OW 275
59951: PUSH
59952: LD_VAR 0 11
59956: PUSH
59957: LD_INT 2
59959: ARRAY
59960: GREATEREQUAL
59961: AND
59962: PUSH
59963: LD_VAR 0 10
59967: PPUSH
59968: LD_INT 3
59970: PPUSH
59971: CALL_OW 275
59975: PUSH
59976: LD_VAR 0 11
59980: PUSH
59981: LD_INT 3
59983: ARRAY
59984: GREATEREQUAL
59985: AND
59986: NOT
59987: IFFALSE 59991
// exit ;
59989: GO 60593
// if GetBType ( depot ) = b_depot then
59991: LD_VAR 0 1
59995: PPUSH
59996: CALL_OW 266
60000: PUSH
60001: LD_INT 0
60003: EQUAL
60004: IFFALSE 60016
// dist := 28 else
60006: LD_ADDR_VAR 0 14
60010: PUSH
60011: LD_INT 28
60013: ST_TO_ADDR
60014: GO 60024
// dist := 36 ;
60016: LD_ADDR_VAR 0 14
60020: PUSH
60021: LD_INT 36
60023: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
60024: LD_VAR 0 1
60028: PPUSH
60029: LD_VAR 0 3
60033: PPUSH
60034: LD_VAR 0 4
60038: PPUSH
60039: CALL_OW 297
60043: PUSH
60044: LD_VAR 0 14
60048: GREATER
60049: IFFALSE 60053
// exit ;
60051: GO 60593
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
60053: LD_ADDR_VAR 0 12
60057: PUSH
60058: LD_VAR 0 2
60062: PPUSH
60063: LD_VAR 0 3
60067: PPUSH
60068: LD_VAR 0 4
60072: PPUSH
60073: LD_VAR 0 5
60077: PPUSH
60078: LD_VAR 0 1
60082: PPUSH
60083: CALL_OW 248
60087: PPUSH
60088: LD_INT 0
60090: PPUSH
60091: CALL 60598 0 6
60095: ST_TO_ADDR
// if not hexes then
60096: LD_VAR 0 12
60100: NOT
60101: IFFALSE 60105
// exit ;
60103: GO 60593
// hex := GetHexInfo ( x , y ) ;
60105: LD_ADDR_VAR 0 15
60109: PUSH
60110: LD_VAR 0 3
60114: PPUSH
60115: LD_VAR 0 4
60119: PPUSH
60120: CALL_OW 546
60124: ST_TO_ADDR
// if hex [ 1 ] then
60125: LD_VAR 0 15
60129: PUSH
60130: LD_INT 1
60132: ARRAY
60133: IFFALSE 60137
// exit ;
60135: GO 60593
// height := hex [ 2 ] ;
60137: LD_ADDR_VAR 0 13
60141: PUSH
60142: LD_VAR 0 15
60146: PUSH
60147: LD_INT 2
60149: ARRAY
60150: ST_TO_ADDR
// for i = 1 to hexes do
60151: LD_ADDR_VAR 0 7
60155: PUSH
60156: DOUBLE
60157: LD_INT 1
60159: DEC
60160: ST_TO_ADDR
60161: LD_VAR 0 12
60165: PUSH
60166: FOR_TO
60167: IFFALSE 60497
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
60169: LD_VAR 0 12
60173: PUSH
60174: LD_VAR 0 7
60178: ARRAY
60179: PUSH
60180: LD_INT 1
60182: ARRAY
60183: PPUSH
60184: LD_VAR 0 12
60188: PUSH
60189: LD_VAR 0 7
60193: ARRAY
60194: PUSH
60195: LD_INT 2
60197: ARRAY
60198: PPUSH
60199: CALL_OW 488
60203: NOT
60204: PUSH
60205: LD_VAR 0 12
60209: PUSH
60210: LD_VAR 0 7
60214: ARRAY
60215: PUSH
60216: LD_INT 1
60218: ARRAY
60219: PPUSH
60220: LD_VAR 0 12
60224: PUSH
60225: LD_VAR 0 7
60229: ARRAY
60230: PUSH
60231: LD_INT 2
60233: ARRAY
60234: PPUSH
60235: CALL_OW 428
60239: PUSH
60240: LD_INT 0
60242: GREATER
60243: OR
60244: PUSH
60245: LD_VAR 0 12
60249: PUSH
60250: LD_VAR 0 7
60254: ARRAY
60255: PUSH
60256: LD_INT 1
60258: ARRAY
60259: PPUSH
60260: LD_VAR 0 12
60264: PUSH
60265: LD_VAR 0 7
60269: ARRAY
60270: PUSH
60271: LD_INT 2
60273: ARRAY
60274: PPUSH
60275: CALL_OW 351
60279: OR
60280: IFFALSE 60286
// exit ;
60282: POP
60283: POP
60284: GO 60593
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
60286: LD_ADDR_VAR 0 8
60290: PUSH
60291: LD_VAR 0 12
60295: PUSH
60296: LD_VAR 0 7
60300: ARRAY
60301: PUSH
60302: LD_INT 1
60304: ARRAY
60305: PPUSH
60306: LD_VAR 0 12
60310: PUSH
60311: LD_VAR 0 7
60315: ARRAY
60316: PUSH
60317: LD_INT 2
60319: ARRAY
60320: PPUSH
60321: CALL_OW 546
60325: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
60326: LD_VAR 0 8
60330: PUSH
60331: LD_INT 1
60333: ARRAY
60334: PUSH
60335: LD_VAR 0 8
60339: PUSH
60340: LD_INT 2
60342: ARRAY
60343: PUSH
60344: LD_VAR 0 13
60348: PUSH
60349: LD_INT 2
60351: PLUS
60352: GREATER
60353: OR
60354: PUSH
60355: LD_VAR 0 8
60359: PUSH
60360: LD_INT 2
60362: ARRAY
60363: PUSH
60364: LD_VAR 0 13
60368: PUSH
60369: LD_INT 2
60371: MINUS
60372: LESS
60373: OR
60374: PUSH
60375: LD_VAR 0 8
60379: PUSH
60380: LD_INT 3
60382: ARRAY
60383: PUSH
60384: LD_INT 0
60386: PUSH
60387: LD_INT 8
60389: PUSH
60390: LD_INT 9
60392: PUSH
60393: LD_INT 10
60395: PUSH
60396: LD_INT 11
60398: PUSH
60399: LD_INT 12
60401: PUSH
60402: LD_INT 13
60404: PUSH
60405: LD_INT 16
60407: PUSH
60408: LD_INT 17
60410: PUSH
60411: LD_INT 18
60413: PUSH
60414: LD_INT 19
60416: PUSH
60417: LD_INT 20
60419: PUSH
60420: LD_INT 21
60422: PUSH
60423: EMPTY
60424: LIST
60425: LIST
60426: LIST
60427: LIST
60428: LIST
60429: LIST
60430: LIST
60431: LIST
60432: LIST
60433: LIST
60434: LIST
60435: LIST
60436: LIST
60437: IN
60438: NOT
60439: OR
60440: PUSH
60441: LD_VAR 0 8
60445: PUSH
60446: LD_INT 5
60448: ARRAY
60449: NOT
60450: OR
60451: PUSH
60452: LD_VAR 0 8
60456: PUSH
60457: LD_INT 6
60459: ARRAY
60460: PUSH
60461: LD_INT 1
60463: PUSH
60464: LD_INT 2
60466: PUSH
60467: LD_INT 7
60469: PUSH
60470: LD_INT 9
60472: PUSH
60473: LD_INT 10
60475: PUSH
60476: LD_INT 11
60478: PUSH
60479: EMPTY
60480: LIST
60481: LIST
60482: LIST
60483: LIST
60484: LIST
60485: LIST
60486: IN
60487: NOT
60488: OR
60489: IFFALSE 60495
// exit ;
60491: POP
60492: POP
60493: GO 60593
// end ;
60495: GO 60166
60497: POP
60498: POP
// side := GetSide ( depot ) ;
60499: LD_ADDR_VAR 0 9
60503: PUSH
60504: LD_VAR 0 1
60508: PPUSH
60509: CALL_OW 255
60513: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
60514: LD_VAR 0 9
60518: PPUSH
60519: LD_VAR 0 3
60523: PPUSH
60524: LD_VAR 0 4
60528: PPUSH
60529: LD_INT 20
60531: PPUSH
60532: CALL 53247 0 4
60536: PUSH
60537: LD_INT 4
60539: ARRAY
60540: IFFALSE 60544
// exit ;
60542: GO 60593
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
60544: LD_VAR 0 2
60548: PUSH
60549: LD_INT 29
60551: PUSH
60552: LD_INT 30
60554: PUSH
60555: EMPTY
60556: LIST
60557: LIST
60558: IN
60559: PUSH
60560: LD_VAR 0 3
60564: PPUSH
60565: LD_VAR 0 4
60569: PPUSH
60570: LD_VAR 0 9
60574: PPUSH
60575: CALL_OW 440
60579: NOT
60580: AND
60581: IFFALSE 60585
// exit ;
60583: GO 60593
// result := true ;
60585: LD_ADDR_VAR 0 6
60589: PUSH
60590: LD_INT 1
60592: ST_TO_ADDR
// end ;
60593: LD_VAR 0 6
60597: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
60598: LD_INT 0
60600: PPUSH
60601: PPUSH
60602: PPUSH
60603: PPUSH
60604: PPUSH
60605: PPUSH
60606: PPUSH
60607: PPUSH
60608: PPUSH
60609: PPUSH
60610: PPUSH
60611: PPUSH
60612: PPUSH
60613: PPUSH
60614: PPUSH
60615: PPUSH
60616: PPUSH
60617: PPUSH
60618: PPUSH
60619: PPUSH
60620: PPUSH
60621: PPUSH
60622: PPUSH
60623: PPUSH
60624: PPUSH
60625: PPUSH
60626: PPUSH
60627: PPUSH
60628: PPUSH
60629: PPUSH
60630: PPUSH
60631: PPUSH
60632: PPUSH
60633: PPUSH
60634: PPUSH
60635: PPUSH
60636: PPUSH
60637: PPUSH
60638: PPUSH
60639: PPUSH
60640: PPUSH
60641: PPUSH
60642: PPUSH
60643: PPUSH
60644: PPUSH
60645: PPUSH
60646: PPUSH
60647: PPUSH
60648: PPUSH
60649: PPUSH
60650: PPUSH
60651: PPUSH
60652: PPUSH
60653: PPUSH
60654: PPUSH
60655: PPUSH
60656: PPUSH
60657: PPUSH
// result = [ ] ;
60658: LD_ADDR_VAR 0 7
60662: PUSH
60663: EMPTY
60664: ST_TO_ADDR
// temp_list = [ ] ;
60665: LD_ADDR_VAR 0 9
60669: PUSH
60670: EMPTY
60671: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
60672: LD_VAR 0 4
60676: PUSH
60677: LD_INT 0
60679: PUSH
60680: LD_INT 1
60682: PUSH
60683: LD_INT 2
60685: PUSH
60686: LD_INT 3
60688: PUSH
60689: LD_INT 4
60691: PUSH
60692: LD_INT 5
60694: PUSH
60695: EMPTY
60696: LIST
60697: LIST
60698: LIST
60699: LIST
60700: LIST
60701: LIST
60702: IN
60703: NOT
60704: PUSH
60705: LD_VAR 0 1
60709: PUSH
60710: LD_INT 0
60712: PUSH
60713: LD_INT 1
60715: PUSH
60716: EMPTY
60717: LIST
60718: LIST
60719: IN
60720: PUSH
60721: LD_VAR 0 5
60725: PUSH
60726: LD_INT 1
60728: PUSH
60729: LD_INT 2
60731: PUSH
60732: LD_INT 3
60734: PUSH
60735: EMPTY
60736: LIST
60737: LIST
60738: LIST
60739: IN
60740: NOT
60741: AND
60742: OR
60743: IFFALSE 60747
// exit ;
60745: GO 79138
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
60747: LD_VAR 0 1
60751: PUSH
60752: LD_INT 6
60754: PUSH
60755: LD_INT 7
60757: PUSH
60758: LD_INT 8
60760: PUSH
60761: LD_INT 13
60763: PUSH
60764: LD_INT 12
60766: PUSH
60767: LD_INT 15
60769: PUSH
60770: LD_INT 11
60772: PUSH
60773: LD_INT 14
60775: PUSH
60776: LD_INT 10
60778: PUSH
60779: EMPTY
60780: LIST
60781: LIST
60782: LIST
60783: LIST
60784: LIST
60785: LIST
60786: LIST
60787: LIST
60788: LIST
60789: IN
60790: IFFALSE 60800
// btype = b_lab ;
60792: LD_ADDR_VAR 0 1
60796: PUSH
60797: LD_INT 6
60799: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
60800: LD_VAR 0 6
60804: PUSH
60805: LD_INT 0
60807: PUSH
60808: LD_INT 1
60810: PUSH
60811: LD_INT 2
60813: PUSH
60814: EMPTY
60815: LIST
60816: LIST
60817: LIST
60818: IN
60819: NOT
60820: PUSH
60821: LD_VAR 0 1
60825: PUSH
60826: LD_INT 0
60828: PUSH
60829: LD_INT 1
60831: PUSH
60832: LD_INT 2
60834: PUSH
60835: LD_INT 3
60837: PUSH
60838: LD_INT 6
60840: PUSH
60841: LD_INT 36
60843: PUSH
60844: LD_INT 4
60846: PUSH
60847: LD_INT 5
60849: PUSH
60850: LD_INT 31
60852: PUSH
60853: LD_INT 32
60855: PUSH
60856: LD_INT 33
60858: PUSH
60859: EMPTY
60860: LIST
60861: LIST
60862: LIST
60863: LIST
60864: LIST
60865: LIST
60866: LIST
60867: LIST
60868: LIST
60869: LIST
60870: LIST
60871: IN
60872: NOT
60873: PUSH
60874: LD_VAR 0 6
60878: PUSH
60879: LD_INT 1
60881: EQUAL
60882: AND
60883: OR
60884: PUSH
60885: LD_VAR 0 1
60889: PUSH
60890: LD_INT 2
60892: PUSH
60893: LD_INT 3
60895: PUSH
60896: EMPTY
60897: LIST
60898: LIST
60899: IN
60900: NOT
60901: PUSH
60902: LD_VAR 0 6
60906: PUSH
60907: LD_INT 2
60909: EQUAL
60910: AND
60911: OR
60912: IFFALSE 60922
// mode = 0 ;
60914: LD_ADDR_VAR 0 6
60918: PUSH
60919: LD_INT 0
60921: ST_TO_ADDR
// case mode of 0 :
60922: LD_VAR 0 6
60926: PUSH
60927: LD_INT 0
60929: DOUBLE
60930: EQUAL
60931: IFTRUE 60935
60933: GO 72388
60935: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
60936: LD_ADDR_VAR 0 11
60940: PUSH
60941: LD_INT 0
60943: PUSH
60944: LD_INT 0
60946: PUSH
60947: EMPTY
60948: LIST
60949: LIST
60950: PUSH
60951: LD_INT 0
60953: PUSH
60954: LD_INT 1
60956: NEG
60957: PUSH
60958: EMPTY
60959: LIST
60960: LIST
60961: PUSH
60962: LD_INT 1
60964: PUSH
60965: LD_INT 0
60967: PUSH
60968: EMPTY
60969: LIST
60970: LIST
60971: PUSH
60972: LD_INT 1
60974: PUSH
60975: LD_INT 1
60977: PUSH
60978: EMPTY
60979: LIST
60980: LIST
60981: PUSH
60982: LD_INT 0
60984: PUSH
60985: LD_INT 1
60987: PUSH
60988: EMPTY
60989: LIST
60990: LIST
60991: PUSH
60992: LD_INT 1
60994: NEG
60995: PUSH
60996: LD_INT 0
60998: PUSH
60999: EMPTY
61000: LIST
61001: LIST
61002: PUSH
61003: LD_INT 1
61005: NEG
61006: PUSH
61007: LD_INT 1
61009: NEG
61010: PUSH
61011: EMPTY
61012: LIST
61013: LIST
61014: PUSH
61015: LD_INT 1
61017: NEG
61018: PUSH
61019: LD_INT 2
61021: NEG
61022: PUSH
61023: EMPTY
61024: LIST
61025: LIST
61026: PUSH
61027: LD_INT 0
61029: PUSH
61030: LD_INT 2
61032: NEG
61033: PUSH
61034: EMPTY
61035: LIST
61036: LIST
61037: PUSH
61038: LD_INT 1
61040: PUSH
61041: LD_INT 1
61043: NEG
61044: PUSH
61045: EMPTY
61046: LIST
61047: LIST
61048: PUSH
61049: LD_INT 1
61051: PUSH
61052: LD_INT 2
61054: PUSH
61055: EMPTY
61056: LIST
61057: LIST
61058: PUSH
61059: LD_INT 0
61061: PUSH
61062: LD_INT 2
61064: PUSH
61065: EMPTY
61066: LIST
61067: LIST
61068: PUSH
61069: LD_INT 1
61071: NEG
61072: PUSH
61073: LD_INT 1
61075: PUSH
61076: EMPTY
61077: LIST
61078: LIST
61079: PUSH
61080: LD_INT 1
61082: PUSH
61083: LD_INT 3
61085: PUSH
61086: EMPTY
61087: LIST
61088: LIST
61089: PUSH
61090: LD_INT 0
61092: PUSH
61093: LD_INT 3
61095: PUSH
61096: EMPTY
61097: LIST
61098: LIST
61099: PUSH
61100: LD_INT 1
61102: NEG
61103: PUSH
61104: LD_INT 2
61106: PUSH
61107: EMPTY
61108: LIST
61109: LIST
61110: PUSH
61111: EMPTY
61112: LIST
61113: LIST
61114: LIST
61115: LIST
61116: LIST
61117: LIST
61118: LIST
61119: LIST
61120: LIST
61121: LIST
61122: LIST
61123: LIST
61124: LIST
61125: LIST
61126: LIST
61127: LIST
61128: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
61129: LD_ADDR_VAR 0 12
61133: PUSH
61134: LD_INT 0
61136: PUSH
61137: LD_INT 0
61139: PUSH
61140: EMPTY
61141: LIST
61142: LIST
61143: PUSH
61144: LD_INT 0
61146: PUSH
61147: LD_INT 1
61149: NEG
61150: PUSH
61151: EMPTY
61152: LIST
61153: LIST
61154: PUSH
61155: LD_INT 1
61157: PUSH
61158: LD_INT 0
61160: PUSH
61161: EMPTY
61162: LIST
61163: LIST
61164: PUSH
61165: LD_INT 1
61167: PUSH
61168: LD_INT 1
61170: PUSH
61171: EMPTY
61172: LIST
61173: LIST
61174: PUSH
61175: LD_INT 0
61177: PUSH
61178: LD_INT 1
61180: PUSH
61181: EMPTY
61182: LIST
61183: LIST
61184: PUSH
61185: LD_INT 1
61187: NEG
61188: PUSH
61189: LD_INT 0
61191: PUSH
61192: EMPTY
61193: LIST
61194: LIST
61195: PUSH
61196: LD_INT 1
61198: NEG
61199: PUSH
61200: LD_INT 1
61202: NEG
61203: PUSH
61204: EMPTY
61205: LIST
61206: LIST
61207: PUSH
61208: LD_INT 1
61210: PUSH
61211: LD_INT 1
61213: NEG
61214: PUSH
61215: EMPTY
61216: LIST
61217: LIST
61218: PUSH
61219: LD_INT 2
61221: PUSH
61222: LD_INT 0
61224: PUSH
61225: EMPTY
61226: LIST
61227: LIST
61228: PUSH
61229: LD_INT 2
61231: PUSH
61232: LD_INT 1
61234: PUSH
61235: EMPTY
61236: LIST
61237: LIST
61238: PUSH
61239: LD_INT 1
61241: NEG
61242: PUSH
61243: LD_INT 1
61245: PUSH
61246: EMPTY
61247: LIST
61248: LIST
61249: PUSH
61250: LD_INT 2
61252: NEG
61253: PUSH
61254: LD_INT 0
61256: PUSH
61257: EMPTY
61258: LIST
61259: LIST
61260: PUSH
61261: LD_INT 2
61263: NEG
61264: PUSH
61265: LD_INT 1
61267: NEG
61268: PUSH
61269: EMPTY
61270: LIST
61271: LIST
61272: PUSH
61273: LD_INT 2
61275: NEG
61276: PUSH
61277: LD_INT 1
61279: PUSH
61280: EMPTY
61281: LIST
61282: LIST
61283: PUSH
61284: LD_INT 3
61286: NEG
61287: PUSH
61288: LD_INT 0
61290: PUSH
61291: EMPTY
61292: LIST
61293: LIST
61294: PUSH
61295: LD_INT 3
61297: NEG
61298: PUSH
61299: LD_INT 1
61301: NEG
61302: PUSH
61303: EMPTY
61304: LIST
61305: LIST
61306: PUSH
61307: EMPTY
61308: LIST
61309: LIST
61310: LIST
61311: LIST
61312: LIST
61313: LIST
61314: LIST
61315: LIST
61316: LIST
61317: LIST
61318: LIST
61319: LIST
61320: LIST
61321: LIST
61322: LIST
61323: LIST
61324: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
61325: LD_ADDR_VAR 0 13
61329: PUSH
61330: LD_INT 0
61332: PUSH
61333: LD_INT 0
61335: PUSH
61336: EMPTY
61337: LIST
61338: LIST
61339: PUSH
61340: LD_INT 0
61342: PUSH
61343: LD_INT 1
61345: NEG
61346: PUSH
61347: EMPTY
61348: LIST
61349: LIST
61350: PUSH
61351: LD_INT 1
61353: PUSH
61354: LD_INT 0
61356: PUSH
61357: EMPTY
61358: LIST
61359: LIST
61360: PUSH
61361: LD_INT 1
61363: PUSH
61364: LD_INT 1
61366: PUSH
61367: EMPTY
61368: LIST
61369: LIST
61370: PUSH
61371: LD_INT 0
61373: PUSH
61374: LD_INT 1
61376: PUSH
61377: EMPTY
61378: LIST
61379: LIST
61380: PUSH
61381: LD_INT 1
61383: NEG
61384: PUSH
61385: LD_INT 0
61387: PUSH
61388: EMPTY
61389: LIST
61390: LIST
61391: PUSH
61392: LD_INT 1
61394: NEG
61395: PUSH
61396: LD_INT 1
61398: NEG
61399: PUSH
61400: EMPTY
61401: LIST
61402: LIST
61403: PUSH
61404: LD_INT 1
61406: NEG
61407: PUSH
61408: LD_INT 2
61410: NEG
61411: PUSH
61412: EMPTY
61413: LIST
61414: LIST
61415: PUSH
61416: LD_INT 2
61418: PUSH
61419: LD_INT 1
61421: PUSH
61422: EMPTY
61423: LIST
61424: LIST
61425: PUSH
61426: LD_INT 2
61428: PUSH
61429: LD_INT 2
61431: PUSH
61432: EMPTY
61433: LIST
61434: LIST
61435: PUSH
61436: LD_INT 1
61438: PUSH
61439: LD_INT 2
61441: PUSH
61442: EMPTY
61443: LIST
61444: LIST
61445: PUSH
61446: LD_INT 2
61448: NEG
61449: PUSH
61450: LD_INT 1
61452: NEG
61453: PUSH
61454: EMPTY
61455: LIST
61456: LIST
61457: PUSH
61458: LD_INT 2
61460: NEG
61461: PUSH
61462: LD_INT 2
61464: NEG
61465: PUSH
61466: EMPTY
61467: LIST
61468: LIST
61469: PUSH
61470: LD_INT 2
61472: NEG
61473: PUSH
61474: LD_INT 3
61476: NEG
61477: PUSH
61478: EMPTY
61479: LIST
61480: LIST
61481: PUSH
61482: LD_INT 3
61484: NEG
61485: PUSH
61486: LD_INT 2
61488: NEG
61489: PUSH
61490: EMPTY
61491: LIST
61492: LIST
61493: PUSH
61494: LD_INT 3
61496: NEG
61497: PUSH
61498: LD_INT 3
61500: NEG
61501: PUSH
61502: EMPTY
61503: LIST
61504: LIST
61505: PUSH
61506: EMPTY
61507: LIST
61508: LIST
61509: LIST
61510: LIST
61511: LIST
61512: LIST
61513: LIST
61514: LIST
61515: LIST
61516: LIST
61517: LIST
61518: LIST
61519: LIST
61520: LIST
61521: LIST
61522: LIST
61523: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
61524: LD_ADDR_VAR 0 14
61528: PUSH
61529: LD_INT 0
61531: PUSH
61532: LD_INT 0
61534: PUSH
61535: EMPTY
61536: LIST
61537: LIST
61538: PUSH
61539: LD_INT 0
61541: PUSH
61542: LD_INT 1
61544: NEG
61545: PUSH
61546: EMPTY
61547: LIST
61548: LIST
61549: PUSH
61550: LD_INT 1
61552: PUSH
61553: LD_INT 0
61555: PUSH
61556: EMPTY
61557: LIST
61558: LIST
61559: PUSH
61560: LD_INT 1
61562: PUSH
61563: LD_INT 1
61565: PUSH
61566: EMPTY
61567: LIST
61568: LIST
61569: PUSH
61570: LD_INT 0
61572: PUSH
61573: LD_INT 1
61575: PUSH
61576: EMPTY
61577: LIST
61578: LIST
61579: PUSH
61580: LD_INT 1
61582: NEG
61583: PUSH
61584: LD_INT 0
61586: PUSH
61587: EMPTY
61588: LIST
61589: LIST
61590: PUSH
61591: LD_INT 1
61593: NEG
61594: PUSH
61595: LD_INT 1
61597: NEG
61598: PUSH
61599: EMPTY
61600: LIST
61601: LIST
61602: PUSH
61603: LD_INT 1
61605: NEG
61606: PUSH
61607: LD_INT 2
61609: NEG
61610: PUSH
61611: EMPTY
61612: LIST
61613: LIST
61614: PUSH
61615: LD_INT 0
61617: PUSH
61618: LD_INT 2
61620: NEG
61621: PUSH
61622: EMPTY
61623: LIST
61624: LIST
61625: PUSH
61626: LD_INT 1
61628: PUSH
61629: LD_INT 1
61631: NEG
61632: PUSH
61633: EMPTY
61634: LIST
61635: LIST
61636: PUSH
61637: LD_INT 1
61639: PUSH
61640: LD_INT 2
61642: PUSH
61643: EMPTY
61644: LIST
61645: LIST
61646: PUSH
61647: LD_INT 0
61649: PUSH
61650: LD_INT 2
61652: PUSH
61653: EMPTY
61654: LIST
61655: LIST
61656: PUSH
61657: LD_INT 1
61659: NEG
61660: PUSH
61661: LD_INT 1
61663: PUSH
61664: EMPTY
61665: LIST
61666: LIST
61667: PUSH
61668: LD_INT 1
61670: NEG
61671: PUSH
61672: LD_INT 3
61674: NEG
61675: PUSH
61676: EMPTY
61677: LIST
61678: LIST
61679: PUSH
61680: LD_INT 0
61682: PUSH
61683: LD_INT 3
61685: NEG
61686: PUSH
61687: EMPTY
61688: LIST
61689: LIST
61690: PUSH
61691: LD_INT 1
61693: PUSH
61694: LD_INT 2
61696: NEG
61697: PUSH
61698: EMPTY
61699: LIST
61700: LIST
61701: PUSH
61702: EMPTY
61703: LIST
61704: LIST
61705: LIST
61706: LIST
61707: LIST
61708: LIST
61709: LIST
61710: LIST
61711: LIST
61712: LIST
61713: LIST
61714: LIST
61715: LIST
61716: LIST
61717: LIST
61718: LIST
61719: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
61720: LD_ADDR_VAR 0 15
61724: PUSH
61725: LD_INT 0
61727: PUSH
61728: LD_INT 0
61730: PUSH
61731: EMPTY
61732: LIST
61733: LIST
61734: PUSH
61735: LD_INT 0
61737: PUSH
61738: LD_INT 1
61740: NEG
61741: PUSH
61742: EMPTY
61743: LIST
61744: LIST
61745: PUSH
61746: LD_INT 1
61748: PUSH
61749: LD_INT 0
61751: PUSH
61752: EMPTY
61753: LIST
61754: LIST
61755: PUSH
61756: LD_INT 1
61758: PUSH
61759: LD_INT 1
61761: PUSH
61762: EMPTY
61763: LIST
61764: LIST
61765: PUSH
61766: LD_INT 0
61768: PUSH
61769: LD_INT 1
61771: PUSH
61772: EMPTY
61773: LIST
61774: LIST
61775: PUSH
61776: LD_INT 1
61778: NEG
61779: PUSH
61780: LD_INT 0
61782: PUSH
61783: EMPTY
61784: LIST
61785: LIST
61786: PUSH
61787: LD_INT 1
61789: NEG
61790: PUSH
61791: LD_INT 1
61793: NEG
61794: PUSH
61795: EMPTY
61796: LIST
61797: LIST
61798: PUSH
61799: LD_INT 1
61801: PUSH
61802: LD_INT 1
61804: NEG
61805: PUSH
61806: EMPTY
61807: LIST
61808: LIST
61809: PUSH
61810: LD_INT 2
61812: PUSH
61813: LD_INT 0
61815: PUSH
61816: EMPTY
61817: LIST
61818: LIST
61819: PUSH
61820: LD_INT 2
61822: PUSH
61823: LD_INT 1
61825: PUSH
61826: EMPTY
61827: LIST
61828: LIST
61829: PUSH
61830: LD_INT 1
61832: NEG
61833: PUSH
61834: LD_INT 1
61836: PUSH
61837: EMPTY
61838: LIST
61839: LIST
61840: PUSH
61841: LD_INT 2
61843: NEG
61844: PUSH
61845: LD_INT 0
61847: PUSH
61848: EMPTY
61849: LIST
61850: LIST
61851: PUSH
61852: LD_INT 2
61854: NEG
61855: PUSH
61856: LD_INT 1
61858: NEG
61859: PUSH
61860: EMPTY
61861: LIST
61862: LIST
61863: PUSH
61864: LD_INT 2
61866: PUSH
61867: LD_INT 1
61869: NEG
61870: PUSH
61871: EMPTY
61872: LIST
61873: LIST
61874: PUSH
61875: LD_INT 3
61877: PUSH
61878: LD_INT 0
61880: PUSH
61881: EMPTY
61882: LIST
61883: LIST
61884: PUSH
61885: LD_INT 3
61887: PUSH
61888: LD_INT 1
61890: PUSH
61891: EMPTY
61892: LIST
61893: LIST
61894: PUSH
61895: EMPTY
61896: LIST
61897: LIST
61898: LIST
61899: LIST
61900: LIST
61901: LIST
61902: LIST
61903: LIST
61904: LIST
61905: LIST
61906: LIST
61907: LIST
61908: LIST
61909: LIST
61910: LIST
61911: LIST
61912: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
61913: LD_ADDR_VAR 0 16
61917: PUSH
61918: LD_INT 0
61920: PUSH
61921: LD_INT 0
61923: PUSH
61924: EMPTY
61925: LIST
61926: LIST
61927: PUSH
61928: LD_INT 0
61930: PUSH
61931: LD_INT 1
61933: NEG
61934: PUSH
61935: EMPTY
61936: LIST
61937: LIST
61938: PUSH
61939: LD_INT 1
61941: PUSH
61942: LD_INT 0
61944: PUSH
61945: EMPTY
61946: LIST
61947: LIST
61948: PUSH
61949: LD_INT 1
61951: PUSH
61952: LD_INT 1
61954: PUSH
61955: EMPTY
61956: LIST
61957: LIST
61958: PUSH
61959: LD_INT 0
61961: PUSH
61962: LD_INT 1
61964: PUSH
61965: EMPTY
61966: LIST
61967: LIST
61968: PUSH
61969: LD_INT 1
61971: NEG
61972: PUSH
61973: LD_INT 0
61975: PUSH
61976: EMPTY
61977: LIST
61978: LIST
61979: PUSH
61980: LD_INT 1
61982: NEG
61983: PUSH
61984: LD_INT 1
61986: NEG
61987: PUSH
61988: EMPTY
61989: LIST
61990: LIST
61991: PUSH
61992: LD_INT 1
61994: NEG
61995: PUSH
61996: LD_INT 2
61998: NEG
61999: PUSH
62000: EMPTY
62001: LIST
62002: LIST
62003: PUSH
62004: LD_INT 2
62006: PUSH
62007: LD_INT 1
62009: PUSH
62010: EMPTY
62011: LIST
62012: LIST
62013: PUSH
62014: LD_INT 2
62016: PUSH
62017: LD_INT 2
62019: PUSH
62020: EMPTY
62021: LIST
62022: LIST
62023: PUSH
62024: LD_INT 1
62026: PUSH
62027: LD_INT 2
62029: PUSH
62030: EMPTY
62031: LIST
62032: LIST
62033: PUSH
62034: LD_INT 2
62036: NEG
62037: PUSH
62038: LD_INT 1
62040: NEG
62041: PUSH
62042: EMPTY
62043: LIST
62044: LIST
62045: PUSH
62046: LD_INT 2
62048: NEG
62049: PUSH
62050: LD_INT 2
62052: NEG
62053: PUSH
62054: EMPTY
62055: LIST
62056: LIST
62057: PUSH
62058: LD_INT 3
62060: PUSH
62061: LD_INT 2
62063: PUSH
62064: EMPTY
62065: LIST
62066: LIST
62067: PUSH
62068: LD_INT 3
62070: PUSH
62071: LD_INT 3
62073: PUSH
62074: EMPTY
62075: LIST
62076: LIST
62077: PUSH
62078: LD_INT 2
62080: PUSH
62081: LD_INT 3
62083: PUSH
62084: EMPTY
62085: LIST
62086: LIST
62087: PUSH
62088: EMPTY
62089: LIST
62090: LIST
62091: LIST
62092: LIST
62093: LIST
62094: LIST
62095: LIST
62096: LIST
62097: LIST
62098: LIST
62099: LIST
62100: LIST
62101: LIST
62102: LIST
62103: LIST
62104: LIST
62105: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
62106: LD_ADDR_VAR 0 17
62110: PUSH
62111: LD_INT 0
62113: PUSH
62114: LD_INT 0
62116: PUSH
62117: EMPTY
62118: LIST
62119: LIST
62120: PUSH
62121: LD_INT 0
62123: PUSH
62124: LD_INT 1
62126: NEG
62127: PUSH
62128: EMPTY
62129: LIST
62130: LIST
62131: PUSH
62132: LD_INT 1
62134: PUSH
62135: LD_INT 0
62137: PUSH
62138: EMPTY
62139: LIST
62140: LIST
62141: PUSH
62142: LD_INT 1
62144: PUSH
62145: LD_INT 1
62147: PUSH
62148: EMPTY
62149: LIST
62150: LIST
62151: PUSH
62152: LD_INT 0
62154: PUSH
62155: LD_INT 1
62157: PUSH
62158: EMPTY
62159: LIST
62160: LIST
62161: PUSH
62162: LD_INT 1
62164: NEG
62165: PUSH
62166: LD_INT 0
62168: PUSH
62169: EMPTY
62170: LIST
62171: LIST
62172: PUSH
62173: LD_INT 1
62175: NEG
62176: PUSH
62177: LD_INT 1
62179: NEG
62180: PUSH
62181: EMPTY
62182: LIST
62183: LIST
62184: PUSH
62185: LD_INT 1
62187: NEG
62188: PUSH
62189: LD_INT 2
62191: NEG
62192: PUSH
62193: EMPTY
62194: LIST
62195: LIST
62196: PUSH
62197: LD_INT 0
62199: PUSH
62200: LD_INT 2
62202: NEG
62203: PUSH
62204: EMPTY
62205: LIST
62206: LIST
62207: PUSH
62208: LD_INT 1
62210: PUSH
62211: LD_INT 1
62213: NEG
62214: PUSH
62215: EMPTY
62216: LIST
62217: LIST
62218: PUSH
62219: LD_INT 2
62221: PUSH
62222: LD_INT 0
62224: PUSH
62225: EMPTY
62226: LIST
62227: LIST
62228: PUSH
62229: LD_INT 2
62231: PUSH
62232: LD_INT 1
62234: PUSH
62235: EMPTY
62236: LIST
62237: LIST
62238: PUSH
62239: LD_INT 2
62241: PUSH
62242: LD_INT 2
62244: PUSH
62245: EMPTY
62246: LIST
62247: LIST
62248: PUSH
62249: LD_INT 1
62251: PUSH
62252: LD_INT 2
62254: PUSH
62255: EMPTY
62256: LIST
62257: LIST
62258: PUSH
62259: LD_INT 0
62261: PUSH
62262: LD_INT 2
62264: PUSH
62265: EMPTY
62266: LIST
62267: LIST
62268: PUSH
62269: LD_INT 1
62271: NEG
62272: PUSH
62273: LD_INT 1
62275: PUSH
62276: EMPTY
62277: LIST
62278: LIST
62279: PUSH
62280: LD_INT 2
62282: NEG
62283: PUSH
62284: LD_INT 0
62286: PUSH
62287: EMPTY
62288: LIST
62289: LIST
62290: PUSH
62291: LD_INT 2
62293: NEG
62294: PUSH
62295: LD_INT 1
62297: NEG
62298: PUSH
62299: EMPTY
62300: LIST
62301: LIST
62302: PUSH
62303: LD_INT 2
62305: NEG
62306: PUSH
62307: LD_INT 2
62309: NEG
62310: PUSH
62311: EMPTY
62312: LIST
62313: LIST
62314: PUSH
62315: EMPTY
62316: LIST
62317: LIST
62318: LIST
62319: LIST
62320: LIST
62321: LIST
62322: LIST
62323: LIST
62324: LIST
62325: LIST
62326: LIST
62327: LIST
62328: LIST
62329: LIST
62330: LIST
62331: LIST
62332: LIST
62333: LIST
62334: LIST
62335: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
62336: LD_ADDR_VAR 0 18
62340: PUSH
62341: LD_INT 0
62343: PUSH
62344: LD_INT 0
62346: PUSH
62347: EMPTY
62348: LIST
62349: LIST
62350: PUSH
62351: LD_INT 0
62353: PUSH
62354: LD_INT 1
62356: NEG
62357: PUSH
62358: EMPTY
62359: LIST
62360: LIST
62361: PUSH
62362: LD_INT 1
62364: PUSH
62365: LD_INT 0
62367: PUSH
62368: EMPTY
62369: LIST
62370: LIST
62371: PUSH
62372: LD_INT 1
62374: PUSH
62375: LD_INT 1
62377: PUSH
62378: EMPTY
62379: LIST
62380: LIST
62381: PUSH
62382: LD_INT 0
62384: PUSH
62385: LD_INT 1
62387: PUSH
62388: EMPTY
62389: LIST
62390: LIST
62391: PUSH
62392: LD_INT 1
62394: NEG
62395: PUSH
62396: LD_INT 0
62398: PUSH
62399: EMPTY
62400: LIST
62401: LIST
62402: PUSH
62403: LD_INT 1
62405: NEG
62406: PUSH
62407: LD_INT 1
62409: NEG
62410: PUSH
62411: EMPTY
62412: LIST
62413: LIST
62414: PUSH
62415: LD_INT 1
62417: NEG
62418: PUSH
62419: LD_INT 2
62421: NEG
62422: PUSH
62423: EMPTY
62424: LIST
62425: LIST
62426: PUSH
62427: LD_INT 0
62429: PUSH
62430: LD_INT 2
62432: NEG
62433: PUSH
62434: EMPTY
62435: LIST
62436: LIST
62437: PUSH
62438: LD_INT 1
62440: PUSH
62441: LD_INT 1
62443: NEG
62444: PUSH
62445: EMPTY
62446: LIST
62447: LIST
62448: PUSH
62449: LD_INT 2
62451: PUSH
62452: LD_INT 0
62454: PUSH
62455: EMPTY
62456: LIST
62457: LIST
62458: PUSH
62459: LD_INT 2
62461: PUSH
62462: LD_INT 1
62464: PUSH
62465: EMPTY
62466: LIST
62467: LIST
62468: PUSH
62469: LD_INT 2
62471: PUSH
62472: LD_INT 2
62474: PUSH
62475: EMPTY
62476: LIST
62477: LIST
62478: PUSH
62479: LD_INT 1
62481: PUSH
62482: LD_INT 2
62484: PUSH
62485: EMPTY
62486: LIST
62487: LIST
62488: PUSH
62489: LD_INT 0
62491: PUSH
62492: LD_INT 2
62494: PUSH
62495: EMPTY
62496: LIST
62497: LIST
62498: PUSH
62499: LD_INT 1
62501: NEG
62502: PUSH
62503: LD_INT 1
62505: PUSH
62506: EMPTY
62507: LIST
62508: LIST
62509: PUSH
62510: LD_INT 2
62512: NEG
62513: PUSH
62514: LD_INT 0
62516: PUSH
62517: EMPTY
62518: LIST
62519: LIST
62520: PUSH
62521: LD_INT 2
62523: NEG
62524: PUSH
62525: LD_INT 1
62527: NEG
62528: PUSH
62529: EMPTY
62530: LIST
62531: LIST
62532: PUSH
62533: LD_INT 2
62535: NEG
62536: PUSH
62537: LD_INT 2
62539: NEG
62540: PUSH
62541: EMPTY
62542: LIST
62543: LIST
62544: PUSH
62545: EMPTY
62546: LIST
62547: LIST
62548: LIST
62549: LIST
62550: LIST
62551: LIST
62552: LIST
62553: LIST
62554: LIST
62555: LIST
62556: LIST
62557: LIST
62558: LIST
62559: LIST
62560: LIST
62561: LIST
62562: LIST
62563: LIST
62564: LIST
62565: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
62566: LD_ADDR_VAR 0 19
62570: PUSH
62571: LD_INT 0
62573: PUSH
62574: LD_INT 0
62576: PUSH
62577: EMPTY
62578: LIST
62579: LIST
62580: PUSH
62581: LD_INT 0
62583: PUSH
62584: LD_INT 1
62586: NEG
62587: PUSH
62588: EMPTY
62589: LIST
62590: LIST
62591: PUSH
62592: LD_INT 1
62594: PUSH
62595: LD_INT 0
62597: PUSH
62598: EMPTY
62599: LIST
62600: LIST
62601: PUSH
62602: LD_INT 1
62604: PUSH
62605: LD_INT 1
62607: PUSH
62608: EMPTY
62609: LIST
62610: LIST
62611: PUSH
62612: LD_INT 0
62614: PUSH
62615: LD_INT 1
62617: PUSH
62618: EMPTY
62619: LIST
62620: LIST
62621: PUSH
62622: LD_INT 1
62624: NEG
62625: PUSH
62626: LD_INT 0
62628: PUSH
62629: EMPTY
62630: LIST
62631: LIST
62632: PUSH
62633: LD_INT 1
62635: NEG
62636: PUSH
62637: LD_INT 1
62639: NEG
62640: PUSH
62641: EMPTY
62642: LIST
62643: LIST
62644: PUSH
62645: LD_INT 1
62647: NEG
62648: PUSH
62649: LD_INT 2
62651: NEG
62652: PUSH
62653: EMPTY
62654: LIST
62655: LIST
62656: PUSH
62657: LD_INT 0
62659: PUSH
62660: LD_INT 2
62662: NEG
62663: PUSH
62664: EMPTY
62665: LIST
62666: LIST
62667: PUSH
62668: LD_INT 1
62670: PUSH
62671: LD_INT 1
62673: NEG
62674: PUSH
62675: EMPTY
62676: LIST
62677: LIST
62678: PUSH
62679: LD_INT 2
62681: PUSH
62682: LD_INT 0
62684: PUSH
62685: EMPTY
62686: LIST
62687: LIST
62688: PUSH
62689: LD_INT 2
62691: PUSH
62692: LD_INT 1
62694: PUSH
62695: EMPTY
62696: LIST
62697: LIST
62698: PUSH
62699: LD_INT 2
62701: PUSH
62702: LD_INT 2
62704: PUSH
62705: EMPTY
62706: LIST
62707: LIST
62708: PUSH
62709: LD_INT 1
62711: PUSH
62712: LD_INT 2
62714: PUSH
62715: EMPTY
62716: LIST
62717: LIST
62718: PUSH
62719: LD_INT 0
62721: PUSH
62722: LD_INT 2
62724: PUSH
62725: EMPTY
62726: LIST
62727: LIST
62728: PUSH
62729: LD_INT 1
62731: NEG
62732: PUSH
62733: LD_INT 1
62735: PUSH
62736: EMPTY
62737: LIST
62738: LIST
62739: PUSH
62740: LD_INT 2
62742: NEG
62743: PUSH
62744: LD_INT 0
62746: PUSH
62747: EMPTY
62748: LIST
62749: LIST
62750: PUSH
62751: LD_INT 2
62753: NEG
62754: PUSH
62755: LD_INT 1
62757: NEG
62758: PUSH
62759: EMPTY
62760: LIST
62761: LIST
62762: PUSH
62763: LD_INT 2
62765: NEG
62766: PUSH
62767: LD_INT 2
62769: NEG
62770: PUSH
62771: EMPTY
62772: LIST
62773: LIST
62774: PUSH
62775: EMPTY
62776: LIST
62777: LIST
62778: LIST
62779: LIST
62780: LIST
62781: LIST
62782: LIST
62783: LIST
62784: LIST
62785: LIST
62786: LIST
62787: LIST
62788: LIST
62789: LIST
62790: LIST
62791: LIST
62792: LIST
62793: LIST
62794: LIST
62795: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
62796: LD_ADDR_VAR 0 20
62800: PUSH
62801: LD_INT 0
62803: PUSH
62804: LD_INT 0
62806: PUSH
62807: EMPTY
62808: LIST
62809: LIST
62810: PUSH
62811: LD_INT 0
62813: PUSH
62814: LD_INT 1
62816: NEG
62817: PUSH
62818: EMPTY
62819: LIST
62820: LIST
62821: PUSH
62822: LD_INT 1
62824: PUSH
62825: LD_INT 0
62827: PUSH
62828: EMPTY
62829: LIST
62830: LIST
62831: PUSH
62832: LD_INT 1
62834: PUSH
62835: LD_INT 1
62837: PUSH
62838: EMPTY
62839: LIST
62840: LIST
62841: PUSH
62842: LD_INT 0
62844: PUSH
62845: LD_INT 1
62847: PUSH
62848: EMPTY
62849: LIST
62850: LIST
62851: PUSH
62852: LD_INT 1
62854: NEG
62855: PUSH
62856: LD_INT 0
62858: PUSH
62859: EMPTY
62860: LIST
62861: LIST
62862: PUSH
62863: LD_INT 1
62865: NEG
62866: PUSH
62867: LD_INT 1
62869: NEG
62870: PUSH
62871: EMPTY
62872: LIST
62873: LIST
62874: PUSH
62875: LD_INT 1
62877: NEG
62878: PUSH
62879: LD_INT 2
62881: NEG
62882: PUSH
62883: EMPTY
62884: LIST
62885: LIST
62886: PUSH
62887: LD_INT 0
62889: PUSH
62890: LD_INT 2
62892: NEG
62893: PUSH
62894: EMPTY
62895: LIST
62896: LIST
62897: PUSH
62898: LD_INT 1
62900: PUSH
62901: LD_INT 1
62903: NEG
62904: PUSH
62905: EMPTY
62906: LIST
62907: LIST
62908: PUSH
62909: LD_INT 2
62911: PUSH
62912: LD_INT 0
62914: PUSH
62915: EMPTY
62916: LIST
62917: LIST
62918: PUSH
62919: LD_INT 2
62921: PUSH
62922: LD_INT 1
62924: PUSH
62925: EMPTY
62926: LIST
62927: LIST
62928: PUSH
62929: LD_INT 2
62931: PUSH
62932: LD_INT 2
62934: PUSH
62935: EMPTY
62936: LIST
62937: LIST
62938: PUSH
62939: LD_INT 1
62941: PUSH
62942: LD_INT 2
62944: PUSH
62945: EMPTY
62946: LIST
62947: LIST
62948: PUSH
62949: LD_INT 0
62951: PUSH
62952: LD_INT 2
62954: PUSH
62955: EMPTY
62956: LIST
62957: LIST
62958: PUSH
62959: LD_INT 1
62961: NEG
62962: PUSH
62963: LD_INT 1
62965: PUSH
62966: EMPTY
62967: LIST
62968: LIST
62969: PUSH
62970: LD_INT 2
62972: NEG
62973: PUSH
62974: LD_INT 0
62976: PUSH
62977: EMPTY
62978: LIST
62979: LIST
62980: PUSH
62981: LD_INT 2
62983: NEG
62984: PUSH
62985: LD_INT 1
62987: NEG
62988: PUSH
62989: EMPTY
62990: LIST
62991: LIST
62992: PUSH
62993: LD_INT 2
62995: NEG
62996: PUSH
62997: LD_INT 2
62999: NEG
63000: PUSH
63001: EMPTY
63002: LIST
63003: LIST
63004: PUSH
63005: EMPTY
63006: LIST
63007: LIST
63008: LIST
63009: LIST
63010: LIST
63011: LIST
63012: LIST
63013: LIST
63014: LIST
63015: LIST
63016: LIST
63017: LIST
63018: LIST
63019: LIST
63020: LIST
63021: LIST
63022: LIST
63023: LIST
63024: LIST
63025: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
63026: LD_ADDR_VAR 0 21
63030: PUSH
63031: LD_INT 0
63033: PUSH
63034: LD_INT 0
63036: PUSH
63037: EMPTY
63038: LIST
63039: LIST
63040: PUSH
63041: LD_INT 0
63043: PUSH
63044: LD_INT 1
63046: NEG
63047: PUSH
63048: EMPTY
63049: LIST
63050: LIST
63051: PUSH
63052: LD_INT 1
63054: PUSH
63055: LD_INT 0
63057: PUSH
63058: EMPTY
63059: LIST
63060: LIST
63061: PUSH
63062: LD_INT 1
63064: PUSH
63065: LD_INT 1
63067: PUSH
63068: EMPTY
63069: LIST
63070: LIST
63071: PUSH
63072: LD_INT 0
63074: PUSH
63075: LD_INT 1
63077: PUSH
63078: EMPTY
63079: LIST
63080: LIST
63081: PUSH
63082: LD_INT 1
63084: NEG
63085: PUSH
63086: LD_INT 0
63088: PUSH
63089: EMPTY
63090: LIST
63091: LIST
63092: PUSH
63093: LD_INT 1
63095: NEG
63096: PUSH
63097: LD_INT 1
63099: NEG
63100: PUSH
63101: EMPTY
63102: LIST
63103: LIST
63104: PUSH
63105: LD_INT 1
63107: NEG
63108: PUSH
63109: LD_INT 2
63111: NEG
63112: PUSH
63113: EMPTY
63114: LIST
63115: LIST
63116: PUSH
63117: LD_INT 0
63119: PUSH
63120: LD_INT 2
63122: NEG
63123: PUSH
63124: EMPTY
63125: LIST
63126: LIST
63127: PUSH
63128: LD_INT 1
63130: PUSH
63131: LD_INT 1
63133: NEG
63134: PUSH
63135: EMPTY
63136: LIST
63137: LIST
63138: PUSH
63139: LD_INT 2
63141: PUSH
63142: LD_INT 0
63144: PUSH
63145: EMPTY
63146: LIST
63147: LIST
63148: PUSH
63149: LD_INT 2
63151: PUSH
63152: LD_INT 1
63154: PUSH
63155: EMPTY
63156: LIST
63157: LIST
63158: PUSH
63159: LD_INT 2
63161: PUSH
63162: LD_INT 2
63164: PUSH
63165: EMPTY
63166: LIST
63167: LIST
63168: PUSH
63169: LD_INT 1
63171: PUSH
63172: LD_INT 2
63174: PUSH
63175: EMPTY
63176: LIST
63177: LIST
63178: PUSH
63179: LD_INT 0
63181: PUSH
63182: LD_INT 2
63184: PUSH
63185: EMPTY
63186: LIST
63187: LIST
63188: PUSH
63189: LD_INT 1
63191: NEG
63192: PUSH
63193: LD_INT 1
63195: PUSH
63196: EMPTY
63197: LIST
63198: LIST
63199: PUSH
63200: LD_INT 2
63202: NEG
63203: PUSH
63204: LD_INT 0
63206: PUSH
63207: EMPTY
63208: LIST
63209: LIST
63210: PUSH
63211: LD_INT 2
63213: NEG
63214: PUSH
63215: LD_INT 1
63217: NEG
63218: PUSH
63219: EMPTY
63220: LIST
63221: LIST
63222: PUSH
63223: LD_INT 2
63225: NEG
63226: PUSH
63227: LD_INT 2
63229: NEG
63230: PUSH
63231: EMPTY
63232: LIST
63233: LIST
63234: PUSH
63235: EMPTY
63236: LIST
63237: LIST
63238: LIST
63239: LIST
63240: LIST
63241: LIST
63242: LIST
63243: LIST
63244: LIST
63245: LIST
63246: LIST
63247: LIST
63248: LIST
63249: LIST
63250: LIST
63251: LIST
63252: LIST
63253: LIST
63254: LIST
63255: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
63256: LD_ADDR_VAR 0 22
63260: PUSH
63261: LD_INT 0
63263: PUSH
63264: LD_INT 0
63266: PUSH
63267: EMPTY
63268: LIST
63269: LIST
63270: PUSH
63271: LD_INT 0
63273: PUSH
63274: LD_INT 1
63276: NEG
63277: PUSH
63278: EMPTY
63279: LIST
63280: LIST
63281: PUSH
63282: LD_INT 1
63284: PUSH
63285: LD_INT 0
63287: PUSH
63288: EMPTY
63289: LIST
63290: LIST
63291: PUSH
63292: LD_INT 1
63294: PUSH
63295: LD_INT 1
63297: PUSH
63298: EMPTY
63299: LIST
63300: LIST
63301: PUSH
63302: LD_INT 0
63304: PUSH
63305: LD_INT 1
63307: PUSH
63308: EMPTY
63309: LIST
63310: LIST
63311: PUSH
63312: LD_INT 1
63314: NEG
63315: PUSH
63316: LD_INT 0
63318: PUSH
63319: EMPTY
63320: LIST
63321: LIST
63322: PUSH
63323: LD_INT 1
63325: NEG
63326: PUSH
63327: LD_INT 1
63329: NEG
63330: PUSH
63331: EMPTY
63332: LIST
63333: LIST
63334: PUSH
63335: LD_INT 1
63337: NEG
63338: PUSH
63339: LD_INT 2
63341: NEG
63342: PUSH
63343: EMPTY
63344: LIST
63345: LIST
63346: PUSH
63347: LD_INT 0
63349: PUSH
63350: LD_INT 2
63352: NEG
63353: PUSH
63354: EMPTY
63355: LIST
63356: LIST
63357: PUSH
63358: LD_INT 1
63360: PUSH
63361: LD_INT 1
63363: NEG
63364: PUSH
63365: EMPTY
63366: LIST
63367: LIST
63368: PUSH
63369: LD_INT 2
63371: PUSH
63372: LD_INT 0
63374: PUSH
63375: EMPTY
63376: LIST
63377: LIST
63378: PUSH
63379: LD_INT 2
63381: PUSH
63382: LD_INT 1
63384: PUSH
63385: EMPTY
63386: LIST
63387: LIST
63388: PUSH
63389: LD_INT 2
63391: PUSH
63392: LD_INT 2
63394: PUSH
63395: EMPTY
63396: LIST
63397: LIST
63398: PUSH
63399: LD_INT 1
63401: PUSH
63402: LD_INT 2
63404: PUSH
63405: EMPTY
63406: LIST
63407: LIST
63408: PUSH
63409: LD_INT 0
63411: PUSH
63412: LD_INT 2
63414: PUSH
63415: EMPTY
63416: LIST
63417: LIST
63418: PUSH
63419: LD_INT 1
63421: NEG
63422: PUSH
63423: LD_INT 1
63425: PUSH
63426: EMPTY
63427: LIST
63428: LIST
63429: PUSH
63430: LD_INT 2
63432: NEG
63433: PUSH
63434: LD_INT 0
63436: PUSH
63437: EMPTY
63438: LIST
63439: LIST
63440: PUSH
63441: LD_INT 2
63443: NEG
63444: PUSH
63445: LD_INT 1
63447: NEG
63448: PUSH
63449: EMPTY
63450: LIST
63451: LIST
63452: PUSH
63453: LD_INT 2
63455: NEG
63456: PUSH
63457: LD_INT 2
63459: NEG
63460: PUSH
63461: EMPTY
63462: LIST
63463: LIST
63464: PUSH
63465: EMPTY
63466: LIST
63467: LIST
63468: LIST
63469: LIST
63470: LIST
63471: LIST
63472: LIST
63473: LIST
63474: LIST
63475: LIST
63476: LIST
63477: LIST
63478: LIST
63479: LIST
63480: LIST
63481: LIST
63482: LIST
63483: LIST
63484: LIST
63485: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
63486: LD_ADDR_VAR 0 23
63490: PUSH
63491: LD_INT 0
63493: PUSH
63494: LD_INT 0
63496: PUSH
63497: EMPTY
63498: LIST
63499: LIST
63500: PUSH
63501: LD_INT 0
63503: PUSH
63504: LD_INT 1
63506: NEG
63507: PUSH
63508: EMPTY
63509: LIST
63510: LIST
63511: PUSH
63512: LD_INT 1
63514: PUSH
63515: LD_INT 0
63517: PUSH
63518: EMPTY
63519: LIST
63520: LIST
63521: PUSH
63522: LD_INT 1
63524: PUSH
63525: LD_INT 1
63527: PUSH
63528: EMPTY
63529: LIST
63530: LIST
63531: PUSH
63532: LD_INT 0
63534: PUSH
63535: LD_INT 1
63537: PUSH
63538: EMPTY
63539: LIST
63540: LIST
63541: PUSH
63542: LD_INT 1
63544: NEG
63545: PUSH
63546: LD_INT 0
63548: PUSH
63549: EMPTY
63550: LIST
63551: LIST
63552: PUSH
63553: LD_INT 1
63555: NEG
63556: PUSH
63557: LD_INT 1
63559: NEG
63560: PUSH
63561: EMPTY
63562: LIST
63563: LIST
63564: PUSH
63565: LD_INT 1
63567: NEG
63568: PUSH
63569: LD_INT 2
63571: NEG
63572: PUSH
63573: EMPTY
63574: LIST
63575: LIST
63576: PUSH
63577: LD_INT 0
63579: PUSH
63580: LD_INT 2
63582: NEG
63583: PUSH
63584: EMPTY
63585: LIST
63586: LIST
63587: PUSH
63588: LD_INT 1
63590: PUSH
63591: LD_INT 1
63593: NEG
63594: PUSH
63595: EMPTY
63596: LIST
63597: LIST
63598: PUSH
63599: LD_INT 2
63601: PUSH
63602: LD_INT 0
63604: PUSH
63605: EMPTY
63606: LIST
63607: LIST
63608: PUSH
63609: LD_INT 2
63611: PUSH
63612: LD_INT 1
63614: PUSH
63615: EMPTY
63616: LIST
63617: LIST
63618: PUSH
63619: LD_INT 2
63621: PUSH
63622: LD_INT 2
63624: PUSH
63625: EMPTY
63626: LIST
63627: LIST
63628: PUSH
63629: LD_INT 1
63631: PUSH
63632: LD_INT 2
63634: PUSH
63635: EMPTY
63636: LIST
63637: LIST
63638: PUSH
63639: LD_INT 0
63641: PUSH
63642: LD_INT 2
63644: PUSH
63645: EMPTY
63646: LIST
63647: LIST
63648: PUSH
63649: LD_INT 1
63651: NEG
63652: PUSH
63653: LD_INT 1
63655: PUSH
63656: EMPTY
63657: LIST
63658: LIST
63659: PUSH
63660: LD_INT 2
63662: NEG
63663: PUSH
63664: LD_INT 0
63666: PUSH
63667: EMPTY
63668: LIST
63669: LIST
63670: PUSH
63671: LD_INT 2
63673: NEG
63674: PUSH
63675: LD_INT 1
63677: NEG
63678: PUSH
63679: EMPTY
63680: LIST
63681: LIST
63682: PUSH
63683: LD_INT 2
63685: NEG
63686: PUSH
63687: LD_INT 2
63689: NEG
63690: PUSH
63691: EMPTY
63692: LIST
63693: LIST
63694: PUSH
63695: LD_INT 2
63697: NEG
63698: PUSH
63699: LD_INT 3
63701: NEG
63702: PUSH
63703: EMPTY
63704: LIST
63705: LIST
63706: PUSH
63707: LD_INT 1
63709: NEG
63710: PUSH
63711: LD_INT 3
63713: NEG
63714: PUSH
63715: EMPTY
63716: LIST
63717: LIST
63718: PUSH
63719: LD_INT 1
63721: PUSH
63722: LD_INT 2
63724: NEG
63725: PUSH
63726: EMPTY
63727: LIST
63728: LIST
63729: PUSH
63730: LD_INT 2
63732: PUSH
63733: LD_INT 1
63735: NEG
63736: PUSH
63737: EMPTY
63738: LIST
63739: LIST
63740: PUSH
63741: EMPTY
63742: LIST
63743: LIST
63744: LIST
63745: LIST
63746: LIST
63747: LIST
63748: LIST
63749: LIST
63750: LIST
63751: LIST
63752: LIST
63753: LIST
63754: LIST
63755: LIST
63756: LIST
63757: LIST
63758: LIST
63759: LIST
63760: LIST
63761: LIST
63762: LIST
63763: LIST
63764: LIST
63765: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
63766: LD_ADDR_VAR 0 24
63770: PUSH
63771: LD_INT 0
63773: PUSH
63774: LD_INT 0
63776: PUSH
63777: EMPTY
63778: LIST
63779: LIST
63780: PUSH
63781: LD_INT 0
63783: PUSH
63784: LD_INT 1
63786: NEG
63787: PUSH
63788: EMPTY
63789: LIST
63790: LIST
63791: PUSH
63792: LD_INT 1
63794: PUSH
63795: LD_INT 0
63797: PUSH
63798: EMPTY
63799: LIST
63800: LIST
63801: PUSH
63802: LD_INT 1
63804: PUSH
63805: LD_INT 1
63807: PUSH
63808: EMPTY
63809: LIST
63810: LIST
63811: PUSH
63812: LD_INT 0
63814: PUSH
63815: LD_INT 1
63817: PUSH
63818: EMPTY
63819: LIST
63820: LIST
63821: PUSH
63822: LD_INT 1
63824: NEG
63825: PUSH
63826: LD_INT 0
63828: PUSH
63829: EMPTY
63830: LIST
63831: LIST
63832: PUSH
63833: LD_INT 1
63835: NEG
63836: PUSH
63837: LD_INT 1
63839: NEG
63840: PUSH
63841: EMPTY
63842: LIST
63843: LIST
63844: PUSH
63845: LD_INT 1
63847: NEG
63848: PUSH
63849: LD_INT 2
63851: NEG
63852: PUSH
63853: EMPTY
63854: LIST
63855: LIST
63856: PUSH
63857: LD_INT 0
63859: PUSH
63860: LD_INT 2
63862: NEG
63863: PUSH
63864: EMPTY
63865: LIST
63866: LIST
63867: PUSH
63868: LD_INT 1
63870: PUSH
63871: LD_INT 1
63873: NEG
63874: PUSH
63875: EMPTY
63876: LIST
63877: LIST
63878: PUSH
63879: LD_INT 2
63881: PUSH
63882: LD_INT 0
63884: PUSH
63885: EMPTY
63886: LIST
63887: LIST
63888: PUSH
63889: LD_INT 2
63891: PUSH
63892: LD_INT 1
63894: PUSH
63895: EMPTY
63896: LIST
63897: LIST
63898: PUSH
63899: LD_INT 2
63901: PUSH
63902: LD_INT 2
63904: PUSH
63905: EMPTY
63906: LIST
63907: LIST
63908: PUSH
63909: LD_INT 1
63911: PUSH
63912: LD_INT 2
63914: PUSH
63915: EMPTY
63916: LIST
63917: LIST
63918: PUSH
63919: LD_INT 0
63921: PUSH
63922: LD_INT 2
63924: PUSH
63925: EMPTY
63926: LIST
63927: LIST
63928: PUSH
63929: LD_INT 1
63931: NEG
63932: PUSH
63933: LD_INT 1
63935: PUSH
63936: EMPTY
63937: LIST
63938: LIST
63939: PUSH
63940: LD_INT 2
63942: NEG
63943: PUSH
63944: LD_INT 0
63946: PUSH
63947: EMPTY
63948: LIST
63949: LIST
63950: PUSH
63951: LD_INT 2
63953: NEG
63954: PUSH
63955: LD_INT 1
63957: NEG
63958: PUSH
63959: EMPTY
63960: LIST
63961: LIST
63962: PUSH
63963: LD_INT 2
63965: NEG
63966: PUSH
63967: LD_INT 2
63969: NEG
63970: PUSH
63971: EMPTY
63972: LIST
63973: LIST
63974: PUSH
63975: LD_INT 1
63977: PUSH
63978: LD_INT 2
63980: NEG
63981: PUSH
63982: EMPTY
63983: LIST
63984: LIST
63985: PUSH
63986: LD_INT 2
63988: PUSH
63989: LD_INT 1
63991: NEG
63992: PUSH
63993: EMPTY
63994: LIST
63995: LIST
63996: PUSH
63997: LD_INT 3
63999: PUSH
64000: LD_INT 1
64002: PUSH
64003: EMPTY
64004: LIST
64005: LIST
64006: PUSH
64007: LD_INT 3
64009: PUSH
64010: LD_INT 2
64012: PUSH
64013: EMPTY
64014: LIST
64015: LIST
64016: PUSH
64017: EMPTY
64018: LIST
64019: LIST
64020: LIST
64021: LIST
64022: LIST
64023: LIST
64024: LIST
64025: LIST
64026: LIST
64027: LIST
64028: LIST
64029: LIST
64030: LIST
64031: LIST
64032: LIST
64033: LIST
64034: LIST
64035: LIST
64036: LIST
64037: LIST
64038: LIST
64039: LIST
64040: LIST
64041: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
64042: LD_ADDR_VAR 0 25
64046: PUSH
64047: LD_INT 0
64049: PUSH
64050: LD_INT 0
64052: PUSH
64053: EMPTY
64054: LIST
64055: LIST
64056: PUSH
64057: LD_INT 0
64059: PUSH
64060: LD_INT 1
64062: NEG
64063: PUSH
64064: EMPTY
64065: LIST
64066: LIST
64067: PUSH
64068: LD_INT 1
64070: PUSH
64071: LD_INT 0
64073: PUSH
64074: EMPTY
64075: LIST
64076: LIST
64077: PUSH
64078: LD_INT 1
64080: PUSH
64081: LD_INT 1
64083: PUSH
64084: EMPTY
64085: LIST
64086: LIST
64087: PUSH
64088: LD_INT 0
64090: PUSH
64091: LD_INT 1
64093: PUSH
64094: EMPTY
64095: LIST
64096: LIST
64097: PUSH
64098: LD_INT 1
64100: NEG
64101: PUSH
64102: LD_INT 0
64104: PUSH
64105: EMPTY
64106: LIST
64107: LIST
64108: PUSH
64109: LD_INT 1
64111: NEG
64112: PUSH
64113: LD_INT 1
64115: NEG
64116: PUSH
64117: EMPTY
64118: LIST
64119: LIST
64120: PUSH
64121: LD_INT 1
64123: NEG
64124: PUSH
64125: LD_INT 2
64127: NEG
64128: PUSH
64129: EMPTY
64130: LIST
64131: LIST
64132: PUSH
64133: LD_INT 0
64135: PUSH
64136: LD_INT 2
64138: NEG
64139: PUSH
64140: EMPTY
64141: LIST
64142: LIST
64143: PUSH
64144: LD_INT 1
64146: PUSH
64147: LD_INT 1
64149: NEG
64150: PUSH
64151: EMPTY
64152: LIST
64153: LIST
64154: PUSH
64155: LD_INT 2
64157: PUSH
64158: LD_INT 0
64160: PUSH
64161: EMPTY
64162: LIST
64163: LIST
64164: PUSH
64165: LD_INT 2
64167: PUSH
64168: LD_INT 1
64170: PUSH
64171: EMPTY
64172: LIST
64173: LIST
64174: PUSH
64175: LD_INT 2
64177: PUSH
64178: LD_INT 2
64180: PUSH
64181: EMPTY
64182: LIST
64183: LIST
64184: PUSH
64185: LD_INT 1
64187: PUSH
64188: LD_INT 2
64190: PUSH
64191: EMPTY
64192: LIST
64193: LIST
64194: PUSH
64195: LD_INT 0
64197: PUSH
64198: LD_INT 2
64200: PUSH
64201: EMPTY
64202: LIST
64203: LIST
64204: PUSH
64205: LD_INT 1
64207: NEG
64208: PUSH
64209: LD_INT 1
64211: PUSH
64212: EMPTY
64213: LIST
64214: LIST
64215: PUSH
64216: LD_INT 2
64218: NEG
64219: PUSH
64220: LD_INT 0
64222: PUSH
64223: EMPTY
64224: LIST
64225: LIST
64226: PUSH
64227: LD_INT 2
64229: NEG
64230: PUSH
64231: LD_INT 1
64233: NEG
64234: PUSH
64235: EMPTY
64236: LIST
64237: LIST
64238: PUSH
64239: LD_INT 2
64241: NEG
64242: PUSH
64243: LD_INT 2
64245: NEG
64246: PUSH
64247: EMPTY
64248: LIST
64249: LIST
64250: PUSH
64251: LD_INT 3
64253: PUSH
64254: LD_INT 1
64256: PUSH
64257: EMPTY
64258: LIST
64259: LIST
64260: PUSH
64261: LD_INT 3
64263: PUSH
64264: LD_INT 2
64266: PUSH
64267: EMPTY
64268: LIST
64269: LIST
64270: PUSH
64271: LD_INT 2
64273: PUSH
64274: LD_INT 3
64276: PUSH
64277: EMPTY
64278: LIST
64279: LIST
64280: PUSH
64281: LD_INT 1
64283: PUSH
64284: LD_INT 3
64286: PUSH
64287: EMPTY
64288: LIST
64289: LIST
64290: PUSH
64291: EMPTY
64292: LIST
64293: LIST
64294: LIST
64295: LIST
64296: LIST
64297: LIST
64298: LIST
64299: LIST
64300: LIST
64301: LIST
64302: LIST
64303: LIST
64304: LIST
64305: LIST
64306: LIST
64307: LIST
64308: LIST
64309: LIST
64310: LIST
64311: LIST
64312: LIST
64313: LIST
64314: LIST
64315: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
64316: LD_ADDR_VAR 0 26
64320: PUSH
64321: LD_INT 0
64323: PUSH
64324: LD_INT 0
64326: PUSH
64327: EMPTY
64328: LIST
64329: LIST
64330: PUSH
64331: LD_INT 0
64333: PUSH
64334: LD_INT 1
64336: NEG
64337: PUSH
64338: EMPTY
64339: LIST
64340: LIST
64341: PUSH
64342: LD_INT 1
64344: PUSH
64345: LD_INT 0
64347: PUSH
64348: EMPTY
64349: LIST
64350: LIST
64351: PUSH
64352: LD_INT 1
64354: PUSH
64355: LD_INT 1
64357: PUSH
64358: EMPTY
64359: LIST
64360: LIST
64361: PUSH
64362: LD_INT 0
64364: PUSH
64365: LD_INT 1
64367: PUSH
64368: EMPTY
64369: LIST
64370: LIST
64371: PUSH
64372: LD_INT 1
64374: NEG
64375: PUSH
64376: LD_INT 0
64378: PUSH
64379: EMPTY
64380: LIST
64381: LIST
64382: PUSH
64383: LD_INT 1
64385: NEG
64386: PUSH
64387: LD_INT 1
64389: NEG
64390: PUSH
64391: EMPTY
64392: LIST
64393: LIST
64394: PUSH
64395: LD_INT 1
64397: NEG
64398: PUSH
64399: LD_INT 2
64401: NEG
64402: PUSH
64403: EMPTY
64404: LIST
64405: LIST
64406: PUSH
64407: LD_INT 0
64409: PUSH
64410: LD_INT 2
64412: NEG
64413: PUSH
64414: EMPTY
64415: LIST
64416: LIST
64417: PUSH
64418: LD_INT 1
64420: PUSH
64421: LD_INT 1
64423: NEG
64424: PUSH
64425: EMPTY
64426: LIST
64427: LIST
64428: PUSH
64429: LD_INT 2
64431: PUSH
64432: LD_INT 0
64434: PUSH
64435: EMPTY
64436: LIST
64437: LIST
64438: PUSH
64439: LD_INT 2
64441: PUSH
64442: LD_INT 1
64444: PUSH
64445: EMPTY
64446: LIST
64447: LIST
64448: PUSH
64449: LD_INT 2
64451: PUSH
64452: LD_INT 2
64454: PUSH
64455: EMPTY
64456: LIST
64457: LIST
64458: PUSH
64459: LD_INT 1
64461: PUSH
64462: LD_INT 2
64464: PUSH
64465: EMPTY
64466: LIST
64467: LIST
64468: PUSH
64469: LD_INT 0
64471: PUSH
64472: LD_INT 2
64474: PUSH
64475: EMPTY
64476: LIST
64477: LIST
64478: PUSH
64479: LD_INT 1
64481: NEG
64482: PUSH
64483: LD_INT 1
64485: PUSH
64486: EMPTY
64487: LIST
64488: LIST
64489: PUSH
64490: LD_INT 2
64492: NEG
64493: PUSH
64494: LD_INT 0
64496: PUSH
64497: EMPTY
64498: LIST
64499: LIST
64500: PUSH
64501: LD_INT 2
64503: NEG
64504: PUSH
64505: LD_INT 1
64507: NEG
64508: PUSH
64509: EMPTY
64510: LIST
64511: LIST
64512: PUSH
64513: LD_INT 2
64515: NEG
64516: PUSH
64517: LD_INT 2
64519: NEG
64520: PUSH
64521: EMPTY
64522: LIST
64523: LIST
64524: PUSH
64525: LD_INT 2
64527: PUSH
64528: LD_INT 3
64530: PUSH
64531: EMPTY
64532: LIST
64533: LIST
64534: PUSH
64535: LD_INT 1
64537: PUSH
64538: LD_INT 3
64540: PUSH
64541: EMPTY
64542: LIST
64543: LIST
64544: PUSH
64545: LD_INT 1
64547: NEG
64548: PUSH
64549: LD_INT 2
64551: PUSH
64552: EMPTY
64553: LIST
64554: LIST
64555: PUSH
64556: LD_INT 2
64558: NEG
64559: PUSH
64560: LD_INT 1
64562: PUSH
64563: EMPTY
64564: LIST
64565: LIST
64566: PUSH
64567: EMPTY
64568: LIST
64569: LIST
64570: LIST
64571: LIST
64572: LIST
64573: LIST
64574: LIST
64575: LIST
64576: LIST
64577: LIST
64578: LIST
64579: LIST
64580: LIST
64581: LIST
64582: LIST
64583: LIST
64584: LIST
64585: LIST
64586: LIST
64587: LIST
64588: LIST
64589: LIST
64590: LIST
64591: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
64592: LD_ADDR_VAR 0 27
64596: PUSH
64597: LD_INT 0
64599: PUSH
64600: LD_INT 0
64602: PUSH
64603: EMPTY
64604: LIST
64605: LIST
64606: PUSH
64607: LD_INT 0
64609: PUSH
64610: LD_INT 1
64612: NEG
64613: PUSH
64614: EMPTY
64615: LIST
64616: LIST
64617: PUSH
64618: LD_INT 1
64620: PUSH
64621: LD_INT 0
64623: PUSH
64624: EMPTY
64625: LIST
64626: LIST
64627: PUSH
64628: LD_INT 1
64630: PUSH
64631: LD_INT 1
64633: PUSH
64634: EMPTY
64635: LIST
64636: LIST
64637: PUSH
64638: LD_INT 0
64640: PUSH
64641: LD_INT 1
64643: PUSH
64644: EMPTY
64645: LIST
64646: LIST
64647: PUSH
64648: LD_INT 1
64650: NEG
64651: PUSH
64652: LD_INT 0
64654: PUSH
64655: EMPTY
64656: LIST
64657: LIST
64658: PUSH
64659: LD_INT 1
64661: NEG
64662: PUSH
64663: LD_INT 1
64665: NEG
64666: PUSH
64667: EMPTY
64668: LIST
64669: LIST
64670: PUSH
64671: LD_INT 1
64673: NEG
64674: PUSH
64675: LD_INT 2
64677: NEG
64678: PUSH
64679: EMPTY
64680: LIST
64681: LIST
64682: PUSH
64683: LD_INT 0
64685: PUSH
64686: LD_INT 2
64688: NEG
64689: PUSH
64690: EMPTY
64691: LIST
64692: LIST
64693: PUSH
64694: LD_INT 1
64696: PUSH
64697: LD_INT 1
64699: NEG
64700: PUSH
64701: EMPTY
64702: LIST
64703: LIST
64704: PUSH
64705: LD_INT 2
64707: PUSH
64708: LD_INT 0
64710: PUSH
64711: EMPTY
64712: LIST
64713: LIST
64714: PUSH
64715: LD_INT 2
64717: PUSH
64718: LD_INT 1
64720: PUSH
64721: EMPTY
64722: LIST
64723: LIST
64724: PUSH
64725: LD_INT 2
64727: PUSH
64728: LD_INT 2
64730: PUSH
64731: EMPTY
64732: LIST
64733: LIST
64734: PUSH
64735: LD_INT 1
64737: PUSH
64738: LD_INT 2
64740: PUSH
64741: EMPTY
64742: LIST
64743: LIST
64744: PUSH
64745: LD_INT 0
64747: PUSH
64748: LD_INT 2
64750: PUSH
64751: EMPTY
64752: LIST
64753: LIST
64754: PUSH
64755: LD_INT 1
64757: NEG
64758: PUSH
64759: LD_INT 1
64761: PUSH
64762: EMPTY
64763: LIST
64764: LIST
64765: PUSH
64766: LD_INT 2
64768: NEG
64769: PUSH
64770: LD_INT 0
64772: PUSH
64773: EMPTY
64774: LIST
64775: LIST
64776: PUSH
64777: LD_INT 2
64779: NEG
64780: PUSH
64781: LD_INT 1
64783: NEG
64784: PUSH
64785: EMPTY
64786: LIST
64787: LIST
64788: PUSH
64789: LD_INT 2
64791: NEG
64792: PUSH
64793: LD_INT 2
64795: NEG
64796: PUSH
64797: EMPTY
64798: LIST
64799: LIST
64800: PUSH
64801: LD_INT 1
64803: NEG
64804: PUSH
64805: LD_INT 2
64807: PUSH
64808: EMPTY
64809: LIST
64810: LIST
64811: PUSH
64812: LD_INT 2
64814: NEG
64815: PUSH
64816: LD_INT 1
64818: PUSH
64819: EMPTY
64820: LIST
64821: LIST
64822: PUSH
64823: LD_INT 3
64825: NEG
64826: PUSH
64827: LD_INT 1
64829: NEG
64830: PUSH
64831: EMPTY
64832: LIST
64833: LIST
64834: PUSH
64835: LD_INT 3
64837: NEG
64838: PUSH
64839: LD_INT 2
64841: NEG
64842: PUSH
64843: EMPTY
64844: LIST
64845: LIST
64846: PUSH
64847: EMPTY
64848: LIST
64849: LIST
64850: LIST
64851: LIST
64852: LIST
64853: LIST
64854: LIST
64855: LIST
64856: LIST
64857: LIST
64858: LIST
64859: LIST
64860: LIST
64861: LIST
64862: LIST
64863: LIST
64864: LIST
64865: LIST
64866: LIST
64867: LIST
64868: LIST
64869: LIST
64870: LIST
64871: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
64872: LD_ADDR_VAR 0 28
64876: PUSH
64877: LD_INT 0
64879: PUSH
64880: LD_INT 0
64882: PUSH
64883: EMPTY
64884: LIST
64885: LIST
64886: PUSH
64887: LD_INT 0
64889: PUSH
64890: LD_INT 1
64892: NEG
64893: PUSH
64894: EMPTY
64895: LIST
64896: LIST
64897: PUSH
64898: LD_INT 1
64900: PUSH
64901: LD_INT 0
64903: PUSH
64904: EMPTY
64905: LIST
64906: LIST
64907: PUSH
64908: LD_INT 1
64910: PUSH
64911: LD_INT 1
64913: PUSH
64914: EMPTY
64915: LIST
64916: LIST
64917: PUSH
64918: LD_INT 0
64920: PUSH
64921: LD_INT 1
64923: PUSH
64924: EMPTY
64925: LIST
64926: LIST
64927: PUSH
64928: LD_INT 1
64930: NEG
64931: PUSH
64932: LD_INT 0
64934: PUSH
64935: EMPTY
64936: LIST
64937: LIST
64938: PUSH
64939: LD_INT 1
64941: NEG
64942: PUSH
64943: LD_INT 1
64945: NEG
64946: PUSH
64947: EMPTY
64948: LIST
64949: LIST
64950: PUSH
64951: LD_INT 1
64953: NEG
64954: PUSH
64955: LD_INT 2
64957: NEG
64958: PUSH
64959: EMPTY
64960: LIST
64961: LIST
64962: PUSH
64963: LD_INT 0
64965: PUSH
64966: LD_INT 2
64968: NEG
64969: PUSH
64970: EMPTY
64971: LIST
64972: LIST
64973: PUSH
64974: LD_INT 1
64976: PUSH
64977: LD_INT 1
64979: NEG
64980: PUSH
64981: EMPTY
64982: LIST
64983: LIST
64984: PUSH
64985: LD_INT 2
64987: PUSH
64988: LD_INT 0
64990: PUSH
64991: EMPTY
64992: LIST
64993: LIST
64994: PUSH
64995: LD_INT 2
64997: PUSH
64998: LD_INT 1
65000: PUSH
65001: EMPTY
65002: LIST
65003: LIST
65004: PUSH
65005: LD_INT 2
65007: PUSH
65008: LD_INT 2
65010: PUSH
65011: EMPTY
65012: LIST
65013: LIST
65014: PUSH
65015: LD_INT 1
65017: PUSH
65018: LD_INT 2
65020: PUSH
65021: EMPTY
65022: LIST
65023: LIST
65024: PUSH
65025: LD_INT 0
65027: PUSH
65028: LD_INT 2
65030: PUSH
65031: EMPTY
65032: LIST
65033: LIST
65034: PUSH
65035: LD_INT 1
65037: NEG
65038: PUSH
65039: LD_INT 1
65041: PUSH
65042: EMPTY
65043: LIST
65044: LIST
65045: PUSH
65046: LD_INT 2
65048: NEG
65049: PUSH
65050: LD_INT 0
65052: PUSH
65053: EMPTY
65054: LIST
65055: LIST
65056: PUSH
65057: LD_INT 2
65059: NEG
65060: PUSH
65061: LD_INT 1
65063: NEG
65064: PUSH
65065: EMPTY
65066: LIST
65067: LIST
65068: PUSH
65069: LD_INT 2
65071: NEG
65072: PUSH
65073: LD_INT 2
65075: NEG
65076: PUSH
65077: EMPTY
65078: LIST
65079: LIST
65080: PUSH
65081: LD_INT 2
65083: NEG
65084: PUSH
65085: LD_INT 3
65087: NEG
65088: PUSH
65089: EMPTY
65090: LIST
65091: LIST
65092: PUSH
65093: LD_INT 1
65095: NEG
65096: PUSH
65097: LD_INT 3
65099: NEG
65100: PUSH
65101: EMPTY
65102: LIST
65103: LIST
65104: PUSH
65105: LD_INT 3
65107: NEG
65108: PUSH
65109: LD_INT 1
65111: NEG
65112: PUSH
65113: EMPTY
65114: LIST
65115: LIST
65116: PUSH
65117: LD_INT 3
65119: NEG
65120: PUSH
65121: LD_INT 2
65123: NEG
65124: PUSH
65125: EMPTY
65126: LIST
65127: LIST
65128: PUSH
65129: EMPTY
65130: LIST
65131: LIST
65132: LIST
65133: LIST
65134: LIST
65135: LIST
65136: LIST
65137: LIST
65138: LIST
65139: LIST
65140: LIST
65141: LIST
65142: LIST
65143: LIST
65144: LIST
65145: LIST
65146: LIST
65147: LIST
65148: LIST
65149: LIST
65150: LIST
65151: LIST
65152: LIST
65153: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
65154: LD_ADDR_VAR 0 29
65158: PUSH
65159: LD_INT 0
65161: PUSH
65162: LD_INT 0
65164: PUSH
65165: EMPTY
65166: LIST
65167: LIST
65168: PUSH
65169: LD_INT 0
65171: PUSH
65172: LD_INT 1
65174: NEG
65175: PUSH
65176: EMPTY
65177: LIST
65178: LIST
65179: PUSH
65180: LD_INT 1
65182: PUSH
65183: LD_INT 0
65185: PUSH
65186: EMPTY
65187: LIST
65188: LIST
65189: PUSH
65190: LD_INT 1
65192: PUSH
65193: LD_INT 1
65195: PUSH
65196: EMPTY
65197: LIST
65198: LIST
65199: PUSH
65200: LD_INT 0
65202: PUSH
65203: LD_INT 1
65205: PUSH
65206: EMPTY
65207: LIST
65208: LIST
65209: PUSH
65210: LD_INT 1
65212: NEG
65213: PUSH
65214: LD_INT 0
65216: PUSH
65217: EMPTY
65218: LIST
65219: LIST
65220: PUSH
65221: LD_INT 1
65223: NEG
65224: PUSH
65225: LD_INT 1
65227: NEG
65228: PUSH
65229: EMPTY
65230: LIST
65231: LIST
65232: PUSH
65233: LD_INT 1
65235: NEG
65236: PUSH
65237: LD_INT 2
65239: NEG
65240: PUSH
65241: EMPTY
65242: LIST
65243: LIST
65244: PUSH
65245: LD_INT 0
65247: PUSH
65248: LD_INT 2
65250: NEG
65251: PUSH
65252: EMPTY
65253: LIST
65254: LIST
65255: PUSH
65256: LD_INT 1
65258: PUSH
65259: LD_INT 1
65261: NEG
65262: PUSH
65263: EMPTY
65264: LIST
65265: LIST
65266: PUSH
65267: LD_INT 2
65269: PUSH
65270: LD_INT 0
65272: PUSH
65273: EMPTY
65274: LIST
65275: LIST
65276: PUSH
65277: LD_INT 2
65279: PUSH
65280: LD_INT 1
65282: PUSH
65283: EMPTY
65284: LIST
65285: LIST
65286: PUSH
65287: LD_INT 1
65289: PUSH
65290: LD_INT 2
65292: PUSH
65293: EMPTY
65294: LIST
65295: LIST
65296: PUSH
65297: LD_INT 0
65299: PUSH
65300: LD_INT 2
65302: PUSH
65303: EMPTY
65304: LIST
65305: LIST
65306: PUSH
65307: LD_INT 1
65309: NEG
65310: PUSH
65311: LD_INT 1
65313: PUSH
65314: EMPTY
65315: LIST
65316: LIST
65317: PUSH
65318: LD_INT 2
65320: NEG
65321: PUSH
65322: LD_INT 1
65324: NEG
65325: PUSH
65326: EMPTY
65327: LIST
65328: LIST
65329: PUSH
65330: LD_INT 2
65332: NEG
65333: PUSH
65334: LD_INT 2
65336: NEG
65337: PUSH
65338: EMPTY
65339: LIST
65340: LIST
65341: PUSH
65342: LD_INT 2
65344: NEG
65345: PUSH
65346: LD_INT 3
65348: NEG
65349: PUSH
65350: EMPTY
65351: LIST
65352: LIST
65353: PUSH
65354: LD_INT 2
65356: PUSH
65357: LD_INT 1
65359: NEG
65360: PUSH
65361: EMPTY
65362: LIST
65363: LIST
65364: PUSH
65365: LD_INT 3
65367: PUSH
65368: LD_INT 1
65370: PUSH
65371: EMPTY
65372: LIST
65373: LIST
65374: PUSH
65375: LD_INT 1
65377: PUSH
65378: LD_INT 3
65380: PUSH
65381: EMPTY
65382: LIST
65383: LIST
65384: PUSH
65385: LD_INT 1
65387: NEG
65388: PUSH
65389: LD_INT 2
65391: PUSH
65392: EMPTY
65393: LIST
65394: LIST
65395: PUSH
65396: LD_INT 3
65398: NEG
65399: PUSH
65400: LD_INT 2
65402: NEG
65403: PUSH
65404: EMPTY
65405: LIST
65406: LIST
65407: PUSH
65408: EMPTY
65409: LIST
65410: LIST
65411: LIST
65412: LIST
65413: LIST
65414: LIST
65415: LIST
65416: LIST
65417: LIST
65418: LIST
65419: LIST
65420: LIST
65421: LIST
65422: LIST
65423: LIST
65424: LIST
65425: LIST
65426: LIST
65427: LIST
65428: LIST
65429: LIST
65430: LIST
65431: LIST
65432: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
65433: LD_ADDR_VAR 0 30
65437: PUSH
65438: LD_INT 0
65440: PUSH
65441: LD_INT 0
65443: PUSH
65444: EMPTY
65445: LIST
65446: LIST
65447: PUSH
65448: LD_INT 0
65450: PUSH
65451: LD_INT 1
65453: NEG
65454: PUSH
65455: EMPTY
65456: LIST
65457: LIST
65458: PUSH
65459: LD_INT 1
65461: PUSH
65462: LD_INT 0
65464: PUSH
65465: EMPTY
65466: LIST
65467: LIST
65468: PUSH
65469: LD_INT 1
65471: PUSH
65472: LD_INT 1
65474: PUSH
65475: EMPTY
65476: LIST
65477: LIST
65478: PUSH
65479: LD_INT 0
65481: PUSH
65482: LD_INT 1
65484: PUSH
65485: EMPTY
65486: LIST
65487: LIST
65488: PUSH
65489: LD_INT 1
65491: NEG
65492: PUSH
65493: LD_INT 0
65495: PUSH
65496: EMPTY
65497: LIST
65498: LIST
65499: PUSH
65500: LD_INT 1
65502: NEG
65503: PUSH
65504: LD_INT 1
65506: NEG
65507: PUSH
65508: EMPTY
65509: LIST
65510: LIST
65511: PUSH
65512: LD_INT 1
65514: NEG
65515: PUSH
65516: LD_INT 2
65518: NEG
65519: PUSH
65520: EMPTY
65521: LIST
65522: LIST
65523: PUSH
65524: LD_INT 0
65526: PUSH
65527: LD_INT 2
65529: NEG
65530: PUSH
65531: EMPTY
65532: LIST
65533: LIST
65534: PUSH
65535: LD_INT 1
65537: PUSH
65538: LD_INT 1
65540: NEG
65541: PUSH
65542: EMPTY
65543: LIST
65544: LIST
65545: PUSH
65546: LD_INT 2
65548: PUSH
65549: LD_INT 0
65551: PUSH
65552: EMPTY
65553: LIST
65554: LIST
65555: PUSH
65556: LD_INT 2
65558: PUSH
65559: LD_INT 1
65561: PUSH
65562: EMPTY
65563: LIST
65564: LIST
65565: PUSH
65566: LD_INT 2
65568: PUSH
65569: LD_INT 2
65571: PUSH
65572: EMPTY
65573: LIST
65574: LIST
65575: PUSH
65576: LD_INT 1
65578: PUSH
65579: LD_INT 2
65581: PUSH
65582: EMPTY
65583: LIST
65584: LIST
65585: PUSH
65586: LD_INT 1
65588: NEG
65589: PUSH
65590: LD_INT 1
65592: PUSH
65593: EMPTY
65594: LIST
65595: LIST
65596: PUSH
65597: LD_INT 2
65599: NEG
65600: PUSH
65601: LD_INT 0
65603: PUSH
65604: EMPTY
65605: LIST
65606: LIST
65607: PUSH
65608: LD_INT 2
65610: NEG
65611: PUSH
65612: LD_INT 1
65614: NEG
65615: PUSH
65616: EMPTY
65617: LIST
65618: LIST
65619: PUSH
65620: LD_INT 1
65622: NEG
65623: PUSH
65624: LD_INT 3
65626: NEG
65627: PUSH
65628: EMPTY
65629: LIST
65630: LIST
65631: PUSH
65632: LD_INT 1
65634: PUSH
65635: LD_INT 2
65637: NEG
65638: PUSH
65639: EMPTY
65640: LIST
65641: LIST
65642: PUSH
65643: LD_INT 3
65645: PUSH
65646: LD_INT 2
65648: PUSH
65649: EMPTY
65650: LIST
65651: LIST
65652: PUSH
65653: LD_INT 2
65655: PUSH
65656: LD_INT 3
65658: PUSH
65659: EMPTY
65660: LIST
65661: LIST
65662: PUSH
65663: LD_INT 2
65665: NEG
65666: PUSH
65667: LD_INT 1
65669: PUSH
65670: EMPTY
65671: LIST
65672: LIST
65673: PUSH
65674: LD_INT 3
65676: NEG
65677: PUSH
65678: LD_INT 1
65680: NEG
65681: PUSH
65682: EMPTY
65683: LIST
65684: LIST
65685: PUSH
65686: EMPTY
65687: LIST
65688: LIST
65689: LIST
65690: LIST
65691: LIST
65692: LIST
65693: LIST
65694: LIST
65695: LIST
65696: LIST
65697: LIST
65698: LIST
65699: LIST
65700: LIST
65701: LIST
65702: LIST
65703: LIST
65704: LIST
65705: LIST
65706: LIST
65707: LIST
65708: LIST
65709: LIST
65710: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
65711: LD_ADDR_VAR 0 31
65715: PUSH
65716: LD_INT 0
65718: PUSH
65719: LD_INT 0
65721: PUSH
65722: EMPTY
65723: LIST
65724: LIST
65725: PUSH
65726: LD_INT 0
65728: PUSH
65729: LD_INT 1
65731: NEG
65732: PUSH
65733: EMPTY
65734: LIST
65735: LIST
65736: PUSH
65737: LD_INT 1
65739: PUSH
65740: LD_INT 0
65742: PUSH
65743: EMPTY
65744: LIST
65745: LIST
65746: PUSH
65747: LD_INT 1
65749: PUSH
65750: LD_INT 1
65752: PUSH
65753: EMPTY
65754: LIST
65755: LIST
65756: PUSH
65757: LD_INT 0
65759: PUSH
65760: LD_INT 1
65762: PUSH
65763: EMPTY
65764: LIST
65765: LIST
65766: PUSH
65767: LD_INT 1
65769: NEG
65770: PUSH
65771: LD_INT 0
65773: PUSH
65774: EMPTY
65775: LIST
65776: LIST
65777: PUSH
65778: LD_INT 1
65780: NEG
65781: PUSH
65782: LD_INT 1
65784: NEG
65785: PUSH
65786: EMPTY
65787: LIST
65788: LIST
65789: PUSH
65790: LD_INT 1
65792: NEG
65793: PUSH
65794: LD_INT 2
65796: NEG
65797: PUSH
65798: EMPTY
65799: LIST
65800: LIST
65801: PUSH
65802: LD_INT 1
65804: PUSH
65805: LD_INT 1
65807: NEG
65808: PUSH
65809: EMPTY
65810: LIST
65811: LIST
65812: PUSH
65813: LD_INT 2
65815: PUSH
65816: LD_INT 0
65818: PUSH
65819: EMPTY
65820: LIST
65821: LIST
65822: PUSH
65823: LD_INT 2
65825: PUSH
65826: LD_INT 1
65828: PUSH
65829: EMPTY
65830: LIST
65831: LIST
65832: PUSH
65833: LD_INT 2
65835: PUSH
65836: LD_INT 2
65838: PUSH
65839: EMPTY
65840: LIST
65841: LIST
65842: PUSH
65843: LD_INT 1
65845: PUSH
65846: LD_INT 2
65848: PUSH
65849: EMPTY
65850: LIST
65851: LIST
65852: PUSH
65853: LD_INT 0
65855: PUSH
65856: LD_INT 2
65858: PUSH
65859: EMPTY
65860: LIST
65861: LIST
65862: PUSH
65863: LD_INT 1
65865: NEG
65866: PUSH
65867: LD_INT 1
65869: PUSH
65870: EMPTY
65871: LIST
65872: LIST
65873: PUSH
65874: LD_INT 2
65876: NEG
65877: PUSH
65878: LD_INT 1
65880: NEG
65881: PUSH
65882: EMPTY
65883: LIST
65884: LIST
65885: PUSH
65886: LD_INT 2
65888: NEG
65889: PUSH
65890: LD_INT 2
65892: NEG
65893: PUSH
65894: EMPTY
65895: LIST
65896: LIST
65897: PUSH
65898: LD_INT 2
65900: NEG
65901: PUSH
65902: LD_INT 3
65904: NEG
65905: PUSH
65906: EMPTY
65907: LIST
65908: LIST
65909: PUSH
65910: LD_INT 2
65912: PUSH
65913: LD_INT 1
65915: NEG
65916: PUSH
65917: EMPTY
65918: LIST
65919: LIST
65920: PUSH
65921: LD_INT 3
65923: PUSH
65924: LD_INT 1
65926: PUSH
65927: EMPTY
65928: LIST
65929: LIST
65930: PUSH
65931: LD_INT 1
65933: PUSH
65934: LD_INT 3
65936: PUSH
65937: EMPTY
65938: LIST
65939: LIST
65940: PUSH
65941: LD_INT 1
65943: NEG
65944: PUSH
65945: LD_INT 2
65947: PUSH
65948: EMPTY
65949: LIST
65950: LIST
65951: PUSH
65952: LD_INT 3
65954: NEG
65955: PUSH
65956: LD_INT 2
65958: NEG
65959: PUSH
65960: EMPTY
65961: LIST
65962: LIST
65963: PUSH
65964: EMPTY
65965: LIST
65966: LIST
65967: LIST
65968: LIST
65969: LIST
65970: LIST
65971: LIST
65972: LIST
65973: LIST
65974: LIST
65975: LIST
65976: LIST
65977: LIST
65978: LIST
65979: LIST
65980: LIST
65981: LIST
65982: LIST
65983: LIST
65984: LIST
65985: LIST
65986: LIST
65987: LIST
65988: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
65989: LD_ADDR_VAR 0 32
65993: PUSH
65994: LD_INT 0
65996: PUSH
65997: LD_INT 0
65999: PUSH
66000: EMPTY
66001: LIST
66002: LIST
66003: PUSH
66004: LD_INT 0
66006: PUSH
66007: LD_INT 1
66009: NEG
66010: PUSH
66011: EMPTY
66012: LIST
66013: LIST
66014: PUSH
66015: LD_INT 1
66017: PUSH
66018: LD_INT 0
66020: PUSH
66021: EMPTY
66022: LIST
66023: LIST
66024: PUSH
66025: LD_INT 1
66027: PUSH
66028: LD_INT 1
66030: PUSH
66031: EMPTY
66032: LIST
66033: LIST
66034: PUSH
66035: LD_INT 0
66037: PUSH
66038: LD_INT 1
66040: PUSH
66041: EMPTY
66042: LIST
66043: LIST
66044: PUSH
66045: LD_INT 1
66047: NEG
66048: PUSH
66049: LD_INT 0
66051: PUSH
66052: EMPTY
66053: LIST
66054: LIST
66055: PUSH
66056: LD_INT 1
66058: NEG
66059: PUSH
66060: LD_INT 1
66062: NEG
66063: PUSH
66064: EMPTY
66065: LIST
66066: LIST
66067: PUSH
66068: LD_INT 1
66070: NEG
66071: PUSH
66072: LD_INT 2
66074: NEG
66075: PUSH
66076: EMPTY
66077: LIST
66078: LIST
66079: PUSH
66080: LD_INT 0
66082: PUSH
66083: LD_INT 2
66085: NEG
66086: PUSH
66087: EMPTY
66088: LIST
66089: LIST
66090: PUSH
66091: LD_INT 1
66093: PUSH
66094: LD_INT 1
66096: NEG
66097: PUSH
66098: EMPTY
66099: LIST
66100: LIST
66101: PUSH
66102: LD_INT 2
66104: PUSH
66105: LD_INT 1
66107: PUSH
66108: EMPTY
66109: LIST
66110: LIST
66111: PUSH
66112: LD_INT 2
66114: PUSH
66115: LD_INT 2
66117: PUSH
66118: EMPTY
66119: LIST
66120: LIST
66121: PUSH
66122: LD_INT 1
66124: PUSH
66125: LD_INT 2
66127: PUSH
66128: EMPTY
66129: LIST
66130: LIST
66131: PUSH
66132: LD_INT 0
66134: PUSH
66135: LD_INT 2
66137: PUSH
66138: EMPTY
66139: LIST
66140: LIST
66141: PUSH
66142: LD_INT 1
66144: NEG
66145: PUSH
66146: LD_INT 1
66148: PUSH
66149: EMPTY
66150: LIST
66151: LIST
66152: PUSH
66153: LD_INT 2
66155: NEG
66156: PUSH
66157: LD_INT 0
66159: PUSH
66160: EMPTY
66161: LIST
66162: LIST
66163: PUSH
66164: LD_INT 2
66166: NEG
66167: PUSH
66168: LD_INT 1
66170: NEG
66171: PUSH
66172: EMPTY
66173: LIST
66174: LIST
66175: PUSH
66176: LD_INT 1
66178: NEG
66179: PUSH
66180: LD_INT 3
66182: NEG
66183: PUSH
66184: EMPTY
66185: LIST
66186: LIST
66187: PUSH
66188: LD_INT 1
66190: PUSH
66191: LD_INT 2
66193: NEG
66194: PUSH
66195: EMPTY
66196: LIST
66197: LIST
66198: PUSH
66199: LD_INT 3
66201: PUSH
66202: LD_INT 2
66204: PUSH
66205: EMPTY
66206: LIST
66207: LIST
66208: PUSH
66209: LD_INT 2
66211: PUSH
66212: LD_INT 3
66214: PUSH
66215: EMPTY
66216: LIST
66217: LIST
66218: PUSH
66219: LD_INT 2
66221: NEG
66222: PUSH
66223: LD_INT 1
66225: PUSH
66226: EMPTY
66227: LIST
66228: LIST
66229: PUSH
66230: LD_INT 3
66232: NEG
66233: PUSH
66234: LD_INT 1
66236: NEG
66237: PUSH
66238: EMPTY
66239: LIST
66240: LIST
66241: PUSH
66242: EMPTY
66243: LIST
66244: LIST
66245: LIST
66246: LIST
66247: LIST
66248: LIST
66249: LIST
66250: LIST
66251: LIST
66252: LIST
66253: LIST
66254: LIST
66255: LIST
66256: LIST
66257: LIST
66258: LIST
66259: LIST
66260: LIST
66261: LIST
66262: LIST
66263: LIST
66264: LIST
66265: LIST
66266: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
66267: LD_ADDR_VAR 0 33
66271: PUSH
66272: LD_INT 0
66274: PUSH
66275: LD_INT 0
66277: PUSH
66278: EMPTY
66279: LIST
66280: LIST
66281: PUSH
66282: LD_INT 0
66284: PUSH
66285: LD_INT 1
66287: NEG
66288: PUSH
66289: EMPTY
66290: LIST
66291: LIST
66292: PUSH
66293: LD_INT 1
66295: PUSH
66296: LD_INT 0
66298: PUSH
66299: EMPTY
66300: LIST
66301: LIST
66302: PUSH
66303: LD_INT 1
66305: PUSH
66306: LD_INT 1
66308: PUSH
66309: EMPTY
66310: LIST
66311: LIST
66312: PUSH
66313: LD_INT 0
66315: PUSH
66316: LD_INT 1
66318: PUSH
66319: EMPTY
66320: LIST
66321: LIST
66322: PUSH
66323: LD_INT 1
66325: NEG
66326: PUSH
66327: LD_INT 0
66329: PUSH
66330: EMPTY
66331: LIST
66332: LIST
66333: PUSH
66334: LD_INT 1
66336: NEG
66337: PUSH
66338: LD_INT 1
66340: NEG
66341: PUSH
66342: EMPTY
66343: LIST
66344: LIST
66345: PUSH
66346: LD_INT 1
66348: NEG
66349: PUSH
66350: LD_INT 2
66352: NEG
66353: PUSH
66354: EMPTY
66355: LIST
66356: LIST
66357: PUSH
66358: LD_INT 1
66360: PUSH
66361: LD_INT 1
66363: NEG
66364: PUSH
66365: EMPTY
66366: LIST
66367: LIST
66368: PUSH
66369: LD_INT 2
66371: PUSH
66372: LD_INT 0
66374: PUSH
66375: EMPTY
66376: LIST
66377: LIST
66378: PUSH
66379: LD_INT 2
66381: PUSH
66382: LD_INT 1
66384: PUSH
66385: EMPTY
66386: LIST
66387: LIST
66388: PUSH
66389: LD_INT 1
66391: PUSH
66392: LD_INT 2
66394: PUSH
66395: EMPTY
66396: LIST
66397: LIST
66398: PUSH
66399: LD_INT 0
66401: PUSH
66402: LD_INT 2
66404: PUSH
66405: EMPTY
66406: LIST
66407: LIST
66408: PUSH
66409: LD_INT 1
66411: NEG
66412: PUSH
66413: LD_INT 1
66415: PUSH
66416: EMPTY
66417: LIST
66418: LIST
66419: PUSH
66420: LD_INT 2
66422: NEG
66423: PUSH
66424: LD_INT 0
66426: PUSH
66427: EMPTY
66428: LIST
66429: LIST
66430: PUSH
66431: LD_INT 2
66433: NEG
66434: PUSH
66435: LD_INT 1
66437: NEG
66438: PUSH
66439: EMPTY
66440: LIST
66441: LIST
66442: PUSH
66443: LD_INT 2
66445: NEG
66446: PUSH
66447: LD_INT 2
66449: NEG
66450: PUSH
66451: EMPTY
66452: LIST
66453: LIST
66454: PUSH
66455: LD_INT 2
66457: NEG
66458: PUSH
66459: LD_INT 3
66461: NEG
66462: PUSH
66463: EMPTY
66464: LIST
66465: LIST
66466: PUSH
66467: LD_INT 2
66469: PUSH
66470: LD_INT 1
66472: NEG
66473: PUSH
66474: EMPTY
66475: LIST
66476: LIST
66477: PUSH
66478: LD_INT 3
66480: PUSH
66481: LD_INT 1
66483: PUSH
66484: EMPTY
66485: LIST
66486: LIST
66487: PUSH
66488: LD_INT 1
66490: PUSH
66491: LD_INT 3
66493: PUSH
66494: EMPTY
66495: LIST
66496: LIST
66497: PUSH
66498: LD_INT 1
66500: NEG
66501: PUSH
66502: LD_INT 2
66504: PUSH
66505: EMPTY
66506: LIST
66507: LIST
66508: PUSH
66509: LD_INT 3
66511: NEG
66512: PUSH
66513: LD_INT 2
66515: NEG
66516: PUSH
66517: EMPTY
66518: LIST
66519: LIST
66520: PUSH
66521: EMPTY
66522: LIST
66523: LIST
66524: LIST
66525: LIST
66526: LIST
66527: LIST
66528: LIST
66529: LIST
66530: LIST
66531: LIST
66532: LIST
66533: LIST
66534: LIST
66535: LIST
66536: LIST
66537: LIST
66538: LIST
66539: LIST
66540: LIST
66541: LIST
66542: LIST
66543: LIST
66544: LIST
66545: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
66546: LD_ADDR_VAR 0 34
66550: PUSH
66551: LD_INT 0
66553: PUSH
66554: LD_INT 0
66556: PUSH
66557: EMPTY
66558: LIST
66559: LIST
66560: PUSH
66561: LD_INT 0
66563: PUSH
66564: LD_INT 1
66566: NEG
66567: PUSH
66568: EMPTY
66569: LIST
66570: LIST
66571: PUSH
66572: LD_INT 1
66574: PUSH
66575: LD_INT 0
66577: PUSH
66578: EMPTY
66579: LIST
66580: LIST
66581: PUSH
66582: LD_INT 1
66584: PUSH
66585: LD_INT 1
66587: PUSH
66588: EMPTY
66589: LIST
66590: LIST
66591: PUSH
66592: LD_INT 0
66594: PUSH
66595: LD_INT 1
66597: PUSH
66598: EMPTY
66599: LIST
66600: LIST
66601: PUSH
66602: LD_INT 1
66604: NEG
66605: PUSH
66606: LD_INT 0
66608: PUSH
66609: EMPTY
66610: LIST
66611: LIST
66612: PUSH
66613: LD_INT 1
66615: NEG
66616: PUSH
66617: LD_INT 1
66619: NEG
66620: PUSH
66621: EMPTY
66622: LIST
66623: LIST
66624: PUSH
66625: LD_INT 1
66627: NEG
66628: PUSH
66629: LD_INT 2
66631: NEG
66632: PUSH
66633: EMPTY
66634: LIST
66635: LIST
66636: PUSH
66637: LD_INT 0
66639: PUSH
66640: LD_INT 2
66642: NEG
66643: PUSH
66644: EMPTY
66645: LIST
66646: LIST
66647: PUSH
66648: LD_INT 1
66650: PUSH
66651: LD_INT 1
66653: NEG
66654: PUSH
66655: EMPTY
66656: LIST
66657: LIST
66658: PUSH
66659: LD_INT 2
66661: PUSH
66662: LD_INT 1
66664: PUSH
66665: EMPTY
66666: LIST
66667: LIST
66668: PUSH
66669: LD_INT 2
66671: PUSH
66672: LD_INT 2
66674: PUSH
66675: EMPTY
66676: LIST
66677: LIST
66678: PUSH
66679: LD_INT 1
66681: PUSH
66682: LD_INT 2
66684: PUSH
66685: EMPTY
66686: LIST
66687: LIST
66688: PUSH
66689: LD_INT 1
66691: NEG
66692: PUSH
66693: LD_INT 1
66695: PUSH
66696: EMPTY
66697: LIST
66698: LIST
66699: PUSH
66700: LD_INT 2
66702: NEG
66703: PUSH
66704: LD_INT 0
66706: PUSH
66707: EMPTY
66708: LIST
66709: LIST
66710: PUSH
66711: LD_INT 2
66713: NEG
66714: PUSH
66715: LD_INT 1
66717: NEG
66718: PUSH
66719: EMPTY
66720: LIST
66721: LIST
66722: PUSH
66723: LD_INT 2
66725: NEG
66726: PUSH
66727: LD_INT 2
66729: NEG
66730: PUSH
66731: EMPTY
66732: LIST
66733: LIST
66734: PUSH
66735: LD_INT 1
66737: NEG
66738: PUSH
66739: LD_INT 3
66741: NEG
66742: PUSH
66743: EMPTY
66744: LIST
66745: LIST
66746: PUSH
66747: LD_INT 1
66749: PUSH
66750: LD_INT 2
66752: NEG
66753: PUSH
66754: EMPTY
66755: LIST
66756: LIST
66757: PUSH
66758: LD_INT 3
66760: PUSH
66761: LD_INT 2
66763: PUSH
66764: EMPTY
66765: LIST
66766: LIST
66767: PUSH
66768: LD_INT 2
66770: PUSH
66771: LD_INT 3
66773: PUSH
66774: EMPTY
66775: LIST
66776: LIST
66777: PUSH
66778: LD_INT 2
66780: NEG
66781: PUSH
66782: LD_INT 1
66784: PUSH
66785: EMPTY
66786: LIST
66787: LIST
66788: PUSH
66789: LD_INT 3
66791: NEG
66792: PUSH
66793: LD_INT 1
66795: NEG
66796: PUSH
66797: EMPTY
66798: LIST
66799: LIST
66800: PUSH
66801: EMPTY
66802: LIST
66803: LIST
66804: LIST
66805: LIST
66806: LIST
66807: LIST
66808: LIST
66809: LIST
66810: LIST
66811: LIST
66812: LIST
66813: LIST
66814: LIST
66815: LIST
66816: LIST
66817: LIST
66818: LIST
66819: LIST
66820: LIST
66821: LIST
66822: LIST
66823: LIST
66824: LIST
66825: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
66826: LD_ADDR_VAR 0 35
66830: PUSH
66831: LD_INT 0
66833: PUSH
66834: LD_INT 0
66836: PUSH
66837: EMPTY
66838: LIST
66839: LIST
66840: PUSH
66841: LD_INT 0
66843: PUSH
66844: LD_INT 1
66846: NEG
66847: PUSH
66848: EMPTY
66849: LIST
66850: LIST
66851: PUSH
66852: LD_INT 1
66854: PUSH
66855: LD_INT 0
66857: PUSH
66858: EMPTY
66859: LIST
66860: LIST
66861: PUSH
66862: LD_INT 1
66864: PUSH
66865: LD_INT 1
66867: PUSH
66868: EMPTY
66869: LIST
66870: LIST
66871: PUSH
66872: LD_INT 0
66874: PUSH
66875: LD_INT 1
66877: PUSH
66878: EMPTY
66879: LIST
66880: LIST
66881: PUSH
66882: LD_INT 1
66884: NEG
66885: PUSH
66886: LD_INT 0
66888: PUSH
66889: EMPTY
66890: LIST
66891: LIST
66892: PUSH
66893: LD_INT 1
66895: NEG
66896: PUSH
66897: LD_INT 1
66899: NEG
66900: PUSH
66901: EMPTY
66902: LIST
66903: LIST
66904: PUSH
66905: LD_INT 2
66907: PUSH
66908: LD_INT 1
66910: PUSH
66911: EMPTY
66912: LIST
66913: LIST
66914: PUSH
66915: LD_INT 2
66917: NEG
66918: PUSH
66919: LD_INT 1
66921: NEG
66922: PUSH
66923: EMPTY
66924: LIST
66925: LIST
66926: PUSH
66927: EMPTY
66928: LIST
66929: LIST
66930: LIST
66931: LIST
66932: LIST
66933: LIST
66934: LIST
66935: LIST
66936: LIST
66937: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
66938: LD_ADDR_VAR 0 36
66942: PUSH
66943: LD_INT 0
66945: PUSH
66946: LD_INT 0
66948: PUSH
66949: EMPTY
66950: LIST
66951: LIST
66952: PUSH
66953: LD_INT 0
66955: PUSH
66956: LD_INT 1
66958: NEG
66959: PUSH
66960: EMPTY
66961: LIST
66962: LIST
66963: PUSH
66964: LD_INT 1
66966: PUSH
66967: LD_INT 0
66969: PUSH
66970: EMPTY
66971: LIST
66972: LIST
66973: PUSH
66974: LD_INT 1
66976: PUSH
66977: LD_INT 1
66979: PUSH
66980: EMPTY
66981: LIST
66982: LIST
66983: PUSH
66984: LD_INT 0
66986: PUSH
66987: LD_INT 1
66989: PUSH
66990: EMPTY
66991: LIST
66992: LIST
66993: PUSH
66994: LD_INT 1
66996: NEG
66997: PUSH
66998: LD_INT 0
67000: PUSH
67001: EMPTY
67002: LIST
67003: LIST
67004: PUSH
67005: LD_INT 1
67007: NEG
67008: PUSH
67009: LD_INT 1
67011: NEG
67012: PUSH
67013: EMPTY
67014: LIST
67015: LIST
67016: PUSH
67017: LD_INT 1
67019: NEG
67020: PUSH
67021: LD_INT 2
67023: NEG
67024: PUSH
67025: EMPTY
67026: LIST
67027: LIST
67028: PUSH
67029: LD_INT 1
67031: PUSH
67032: LD_INT 2
67034: PUSH
67035: EMPTY
67036: LIST
67037: LIST
67038: PUSH
67039: EMPTY
67040: LIST
67041: LIST
67042: LIST
67043: LIST
67044: LIST
67045: LIST
67046: LIST
67047: LIST
67048: LIST
67049: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
67050: LD_ADDR_VAR 0 37
67054: PUSH
67055: LD_INT 0
67057: PUSH
67058: LD_INT 0
67060: PUSH
67061: EMPTY
67062: LIST
67063: LIST
67064: PUSH
67065: LD_INT 0
67067: PUSH
67068: LD_INT 1
67070: NEG
67071: PUSH
67072: EMPTY
67073: LIST
67074: LIST
67075: PUSH
67076: LD_INT 1
67078: PUSH
67079: LD_INT 0
67081: PUSH
67082: EMPTY
67083: LIST
67084: LIST
67085: PUSH
67086: LD_INT 1
67088: PUSH
67089: LD_INT 1
67091: PUSH
67092: EMPTY
67093: LIST
67094: LIST
67095: PUSH
67096: LD_INT 0
67098: PUSH
67099: LD_INT 1
67101: PUSH
67102: EMPTY
67103: LIST
67104: LIST
67105: PUSH
67106: LD_INT 1
67108: NEG
67109: PUSH
67110: LD_INT 0
67112: PUSH
67113: EMPTY
67114: LIST
67115: LIST
67116: PUSH
67117: LD_INT 1
67119: NEG
67120: PUSH
67121: LD_INT 1
67123: NEG
67124: PUSH
67125: EMPTY
67126: LIST
67127: LIST
67128: PUSH
67129: LD_INT 1
67131: PUSH
67132: LD_INT 1
67134: NEG
67135: PUSH
67136: EMPTY
67137: LIST
67138: LIST
67139: PUSH
67140: LD_INT 1
67142: NEG
67143: PUSH
67144: LD_INT 1
67146: PUSH
67147: EMPTY
67148: LIST
67149: LIST
67150: PUSH
67151: EMPTY
67152: LIST
67153: LIST
67154: LIST
67155: LIST
67156: LIST
67157: LIST
67158: LIST
67159: LIST
67160: LIST
67161: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
67162: LD_ADDR_VAR 0 38
67166: PUSH
67167: LD_INT 0
67169: PUSH
67170: LD_INT 0
67172: PUSH
67173: EMPTY
67174: LIST
67175: LIST
67176: PUSH
67177: LD_INT 0
67179: PUSH
67180: LD_INT 1
67182: NEG
67183: PUSH
67184: EMPTY
67185: LIST
67186: LIST
67187: PUSH
67188: LD_INT 1
67190: PUSH
67191: LD_INT 0
67193: PUSH
67194: EMPTY
67195: LIST
67196: LIST
67197: PUSH
67198: LD_INT 1
67200: PUSH
67201: LD_INT 1
67203: PUSH
67204: EMPTY
67205: LIST
67206: LIST
67207: PUSH
67208: LD_INT 0
67210: PUSH
67211: LD_INT 1
67213: PUSH
67214: EMPTY
67215: LIST
67216: LIST
67217: PUSH
67218: LD_INT 1
67220: NEG
67221: PUSH
67222: LD_INT 0
67224: PUSH
67225: EMPTY
67226: LIST
67227: LIST
67228: PUSH
67229: LD_INT 1
67231: NEG
67232: PUSH
67233: LD_INT 1
67235: NEG
67236: PUSH
67237: EMPTY
67238: LIST
67239: LIST
67240: PUSH
67241: LD_INT 2
67243: PUSH
67244: LD_INT 1
67246: PUSH
67247: EMPTY
67248: LIST
67249: LIST
67250: PUSH
67251: LD_INT 2
67253: NEG
67254: PUSH
67255: LD_INT 1
67257: NEG
67258: PUSH
67259: EMPTY
67260: LIST
67261: LIST
67262: PUSH
67263: EMPTY
67264: LIST
67265: LIST
67266: LIST
67267: LIST
67268: LIST
67269: LIST
67270: LIST
67271: LIST
67272: LIST
67273: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
67274: LD_ADDR_VAR 0 39
67278: PUSH
67279: LD_INT 0
67281: PUSH
67282: LD_INT 0
67284: PUSH
67285: EMPTY
67286: LIST
67287: LIST
67288: PUSH
67289: LD_INT 0
67291: PUSH
67292: LD_INT 1
67294: NEG
67295: PUSH
67296: EMPTY
67297: LIST
67298: LIST
67299: PUSH
67300: LD_INT 1
67302: PUSH
67303: LD_INT 0
67305: PUSH
67306: EMPTY
67307: LIST
67308: LIST
67309: PUSH
67310: LD_INT 1
67312: PUSH
67313: LD_INT 1
67315: PUSH
67316: EMPTY
67317: LIST
67318: LIST
67319: PUSH
67320: LD_INT 0
67322: PUSH
67323: LD_INT 1
67325: PUSH
67326: EMPTY
67327: LIST
67328: LIST
67329: PUSH
67330: LD_INT 1
67332: NEG
67333: PUSH
67334: LD_INT 0
67336: PUSH
67337: EMPTY
67338: LIST
67339: LIST
67340: PUSH
67341: LD_INT 1
67343: NEG
67344: PUSH
67345: LD_INT 1
67347: NEG
67348: PUSH
67349: EMPTY
67350: LIST
67351: LIST
67352: PUSH
67353: LD_INT 1
67355: NEG
67356: PUSH
67357: LD_INT 2
67359: NEG
67360: PUSH
67361: EMPTY
67362: LIST
67363: LIST
67364: PUSH
67365: LD_INT 1
67367: PUSH
67368: LD_INT 2
67370: PUSH
67371: EMPTY
67372: LIST
67373: LIST
67374: PUSH
67375: EMPTY
67376: LIST
67377: LIST
67378: LIST
67379: LIST
67380: LIST
67381: LIST
67382: LIST
67383: LIST
67384: LIST
67385: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
67386: LD_ADDR_VAR 0 40
67390: PUSH
67391: LD_INT 0
67393: PUSH
67394: LD_INT 0
67396: PUSH
67397: EMPTY
67398: LIST
67399: LIST
67400: PUSH
67401: LD_INT 0
67403: PUSH
67404: LD_INT 1
67406: NEG
67407: PUSH
67408: EMPTY
67409: LIST
67410: LIST
67411: PUSH
67412: LD_INT 1
67414: PUSH
67415: LD_INT 0
67417: PUSH
67418: EMPTY
67419: LIST
67420: LIST
67421: PUSH
67422: LD_INT 1
67424: PUSH
67425: LD_INT 1
67427: PUSH
67428: EMPTY
67429: LIST
67430: LIST
67431: PUSH
67432: LD_INT 0
67434: PUSH
67435: LD_INT 1
67437: PUSH
67438: EMPTY
67439: LIST
67440: LIST
67441: PUSH
67442: LD_INT 1
67444: NEG
67445: PUSH
67446: LD_INT 0
67448: PUSH
67449: EMPTY
67450: LIST
67451: LIST
67452: PUSH
67453: LD_INT 1
67455: NEG
67456: PUSH
67457: LD_INT 1
67459: NEG
67460: PUSH
67461: EMPTY
67462: LIST
67463: LIST
67464: PUSH
67465: LD_INT 1
67467: PUSH
67468: LD_INT 1
67470: NEG
67471: PUSH
67472: EMPTY
67473: LIST
67474: LIST
67475: PUSH
67476: LD_INT 1
67478: NEG
67479: PUSH
67480: LD_INT 1
67482: PUSH
67483: EMPTY
67484: LIST
67485: LIST
67486: PUSH
67487: EMPTY
67488: LIST
67489: LIST
67490: LIST
67491: LIST
67492: LIST
67493: LIST
67494: LIST
67495: LIST
67496: LIST
67497: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
67498: LD_ADDR_VAR 0 41
67502: PUSH
67503: LD_INT 0
67505: PUSH
67506: LD_INT 0
67508: PUSH
67509: EMPTY
67510: LIST
67511: LIST
67512: PUSH
67513: LD_INT 0
67515: PUSH
67516: LD_INT 1
67518: NEG
67519: PUSH
67520: EMPTY
67521: LIST
67522: LIST
67523: PUSH
67524: LD_INT 1
67526: PUSH
67527: LD_INT 0
67529: PUSH
67530: EMPTY
67531: LIST
67532: LIST
67533: PUSH
67534: LD_INT 1
67536: PUSH
67537: LD_INT 1
67539: PUSH
67540: EMPTY
67541: LIST
67542: LIST
67543: PUSH
67544: LD_INT 0
67546: PUSH
67547: LD_INT 1
67549: PUSH
67550: EMPTY
67551: LIST
67552: LIST
67553: PUSH
67554: LD_INT 1
67556: NEG
67557: PUSH
67558: LD_INT 0
67560: PUSH
67561: EMPTY
67562: LIST
67563: LIST
67564: PUSH
67565: LD_INT 1
67567: NEG
67568: PUSH
67569: LD_INT 1
67571: NEG
67572: PUSH
67573: EMPTY
67574: LIST
67575: LIST
67576: PUSH
67577: LD_INT 1
67579: NEG
67580: PUSH
67581: LD_INT 2
67583: NEG
67584: PUSH
67585: EMPTY
67586: LIST
67587: LIST
67588: PUSH
67589: LD_INT 1
67591: PUSH
67592: LD_INT 1
67594: NEG
67595: PUSH
67596: EMPTY
67597: LIST
67598: LIST
67599: PUSH
67600: LD_INT 2
67602: PUSH
67603: LD_INT 0
67605: PUSH
67606: EMPTY
67607: LIST
67608: LIST
67609: PUSH
67610: LD_INT 2
67612: PUSH
67613: LD_INT 1
67615: PUSH
67616: EMPTY
67617: LIST
67618: LIST
67619: PUSH
67620: LD_INT 2
67622: PUSH
67623: LD_INT 2
67625: PUSH
67626: EMPTY
67627: LIST
67628: LIST
67629: PUSH
67630: LD_INT 1
67632: PUSH
67633: LD_INT 2
67635: PUSH
67636: EMPTY
67637: LIST
67638: LIST
67639: PUSH
67640: LD_INT 1
67642: NEG
67643: PUSH
67644: LD_INT 1
67646: PUSH
67647: EMPTY
67648: LIST
67649: LIST
67650: PUSH
67651: LD_INT 2
67653: NEG
67654: PUSH
67655: LD_INT 0
67657: PUSH
67658: EMPTY
67659: LIST
67660: LIST
67661: PUSH
67662: LD_INT 2
67664: NEG
67665: PUSH
67666: LD_INT 1
67668: NEG
67669: PUSH
67670: EMPTY
67671: LIST
67672: LIST
67673: PUSH
67674: LD_INT 2
67676: NEG
67677: PUSH
67678: LD_INT 2
67680: NEG
67681: PUSH
67682: EMPTY
67683: LIST
67684: LIST
67685: PUSH
67686: LD_INT 2
67688: NEG
67689: PUSH
67690: LD_INT 3
67692: NEG
67693: PUSH
67694: EMPTY
67695: LIST
67696: LIST
67697: PUSH
67698: LD_INT 2
67700: PUSH
67701: LD_INT 1
67703: NEG
67704: PUSH
67705: EMPTY
67706: LIST
67707: LIST
67708: PUSH
67709: LD_INT 3
67711: PUSH
67712: LD_INT 0
67714: PUSH
67715: EMPTY
67716: LIST
67717: LIST
67718: PUSH
67719: LD_INT 3
67721: PUSH
67722: LD_INT 1
67724: PUSH
67725: EMPTY
67726: LIST
67727: LIST
67728: PUSH
67729: LD_INT 3
67731: PUSH
67732: LD_INT 2
67734: PUSH
67735: EMPTY
67736: LIST
67737: LIST
67738: PUSH
67739: LD_INT 3
67741: PUSH
67742: LD_INT 3
67744: PUSH
67745: EMPTY
67746: LIST
67747: LIST
67748: PUSH
67749: LD_INT 2
67751: PUSH
67752: LD_INT 3
67754: PUSH
67755: EMPTY
67756: LIST
67757: LIST
67758: PUSH
67759: LD_INT 2
67761: NEG
67762: PUSH
67763: LD_INT 1
67765: PUSH
67766: EMPTY
67767: LIST
67768: LIST
67769: PUSH
67770: LD_INT 3
67772: NEG
67773: PUSH
67774: LD_INT 0
67776: PUSH
67777: EMPTY
67778: LIST
67779: LIST
67780: PUSH
67781: LD_INT 3
67783: NEG
67784: PUSH
67785: LD_INT 1
67787: NEG
67788: PUSH
67789: EMPTY
67790: LIST
67791: LIST
67792: PUSH
67793: LD_INT 3
67795: NEG
67796: PUSH
67797: LD_INT 2
67799: NEG
67800: PUSH
67801: EMPTY
67802: LIST
67803: LIST
67804: PUSH
67805: LD_INT 3
67807: NEG
67808: PUSH
67809: LD_INT 3
67811: NEG
67812: PUSH
67813: EMPTY
67814: LIST
67815: LIST
67816: PUSH
67817: EMPTY
67818: LIST
67819: LIST
67820: LIST
67821: LIST
67822: LIST
67823: LIST
67824: LIST
67825: LIST
67826: LIST
67827: LIST
67828: LIST
67829: LIST
67830: LIST
67831: LIST
67832: LIST
67833: LIST
67834: LIST
67835: LIST
67836: LIST
67837: LIST
67838: LIST
67839: LIST
67840: LIST
67841: LIST
67842: LIST
67843: LIST
67844: LIST
67845: LIST
67846: LIST
67847: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
67848: LD_ADDR_VAR 0 42
67852: PUSH
67853: LD_INT 0
67855: PUSH
67856: LD_INT 0
67858: PUSH
67859: EMPTY
67860: LIST
67861: LIST
67862: PUSH
67863: LD_INT 0
67865: PUSH
67866: LD_INT 1
67868: NEG
67869: PUSH
67870: EMPTY
67871: LIST
67872: LIST
67873: PUSH
67874: LD_INT 1
67876: PUSH
67877: LD_INT 0
67879: PUSH
67880: EMPTY
67881: LIST
67882: LIST
67883: PUSH
67884: LD_INT 1
67886: PUSH
67887: LD_INT 1
67889: PUSH
67890: EMPTY
67891: LIST
67892: LIST
67893: PUSH
67894: LD_INT 0
67896: PUSH
67897: LD_INT 1
67899: PUSH
67900: EMPTY
67901: LIST
67902: LIST
67903: PUSH
67904: LD_INT 1
67906: NEG
67907: PUSH
67908: LD_INT 0
67910: PUSH
67911: EMPTY
67912: LIST
67913: LIST
67914: PUSH
67915: LD_INT 1
67917: NEG
67918: PUSH
67919: LD_INT 1
67921: NEG
67922: PUSH
67923: EMPTY
67924: LIST
67925: LIST
67926: PUSH
67927: LD_INT 1
67929: NEG
67930: PUSH
67931: LD_INT 2
67933: NEG
67934: PUSH
67935: EMPTY
67936: LIST
67937: LIST
67938: PUSH
67939: LD_INT 0
67941: PUSH
67942: LD_INT 2
67944: NEG
67945: PUSH
67946: EMPTY
67947: LIST
67948: LIST
67949: PUSH
67950: LD_INT 1
67952: PUSH
67953: LD_INT 1
67955: NEG
67956: PUSH
67957: EMPTY
67958: LIST
67959: LIST
67960: PUSH
67961: LD_INT 2
67963: PUSH
67964: LD_INT 1
67966: PUSH
67967: EMPTY
67968: LIST
67969: LIST
67970: PUSH
67971: LD_INT 2
67973: PUSH
67974: LD_INT 2
67976: PUSH
67977: EMPTY
67978: LIST
67979: LIST
67980: PUSH
67981: LD_INT 1
67983: PUSH
67984: LD_INT 2
67986: PUSH
67987: EMPTY
67988: LIST
67989: LIST
67990: PUSH
67991: LD_INT 0
67993: PUSH
67994: LD_INT 2
67996: PUSH
67997: EMPTY
67998: LIST
67999: LIST
68000: PUSH
68001: LD_INT 1
68003: NEG
68004: PUSH
68005: LD_INT 1
68007: PUSH
68008: EMPTY
68009: LIST
68010: LIST
68011: PUSH
68012: LD_INT 2
68014: NEG
68015: PUSH
68016: LD_INT 1
68018: NEG
68019: PUSH
68020: EMPTY
68021: LIST
68022: LIST
68023: PUSH
68024: LD_INT 2
68026: NEG
68027: PUSH
68028: LD_INT 2
68030: NEG
68031: PUSH
68032: EMPTY
68033: LIST
68034: LIST
68035: PUSH
68036: LD_INT 2
68038: NEG
68039: PUSH
68040: LD_INT 3
68042: NEG
68043: PUSH
68044: EMPTY
68045: LIST
68046: LIST
68047: PUSH
68048: LD_INT 1
68050: NEG
68051: PUSH
68052: LD_INT 3
68054: NEG
68055: PUSH
68056: EMPTY
68057: LIST
68058: LIST
68059: PUSH
68060: LD_INT 0
68062: PUSH
68063: LD_INT 3
68065: NEG
68066: PUSH
68067: EMPTY
68068: LIST
68069: LIST
68070: PUSH
68071: LD_INT 1
68073: PUSH
68074: LD_INT 2
68076: NEG
68077: PUSH
68078: EMPTY
68079: LIST
68080: LIST
68081: PUSH
68082: LD_INT 3
68084: PUSH
68085: LD_INT 2
68087: PUSH
68088: EMPTY
68089: LIST
68090: LIST
68091: PUSH
68092: LD_INT 3
68094: PUSH
68095: LD_INT 3
68097: PUSH
68098: EMPTY
68099: LIST
68100: LIST
68101: PUSH
68102: LD_INT 2
68104: PUSH
68105: LD_INT 3
68107: PUSH
68108: EMPTY
68109: LIST
68110: LIST
68111: PUSH
68112: LD_INT 1
68114: PUSH
68115: LD_INT 3
68117: PUSH
68118: EMPTY
68119: LIST
68120: LIST
68121: PUSH
68122: LD_INT 0
68124: PUSH
68125: LD_INT 3
68127: PUSH
68128: EMPTY
68129: LIST
68130: LIST
68131: PUSH
68132: LD_INT 1
68134: NEG
68135: PUSH
68136: LD_INT 2
68138: PUSH
68139: EMPTY
68140: LIST
68141: LIST
68142: PUSH
68143: LD_INT 3
68145: NEG
68146: PUSH
68147: LD_INT 2
68149: NEG
68150: PUSH
68151: EMPTY
68152: LIST
68153: LIST
68154: PUSH
68155: LD_INT 3
68157: NEG
68158: PUSH
68159: LD_INT 3
68161: NEG
68162: PUSH
68163: EMPTY
68164: LIST
68165: LIST
68166: PUSH
68167: EMPTY
68168: LIST
68169: LIST
68170: LIST
68171: LIST
68172: LIST
68173: LIST
68174: LIST
68175: LIST
68176: LIST
68177: LIST
68178: LIST
68179: LIST
68180: LIST
68181: LIST
68182: LIST
68183: LIST
68184: LIST
68185: LIST
68186: LIST
68187: LIST
68188: LIST
68189: LIST
68190: LIST
68191: LIST
68192: LIST
68193: LIST
68194: LIST
68195: LIST
68196: LIST
68197: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
68198: LD_ADDR_VAR 0 43
68202: PUSH
68203: LD_INT 0
68205: PUSH
68206: LD_INT 0
68208: PUSH
68209: EMPTY
68210: LIST
68211: LIST
68212: PUSH
68213: LD_INT 0
68215: PUSH
68216: LD_INT 1
68218: NEG
68219: PUSH
68220: EMPTY
68221: LIST
68222: LIST
68223: PUSH
68224: LD_INT 1
68226: PUSH
68227: LD_INT 0
68229: PUSH
68230: EMPTY
68231: LIST
68232: LIST
68233: PUSH
68234: LD_INT 1
68236: PUSH
68237: LD_INT 1
68239: PUSH
68240: EMPTY
68241: LIST
68242: LIST
68243: PUSH
68244: LD_INT 0
68246: PUSH
68247: LD_INT 1
68249: PUSH
68250: EMPTY
68251: LIST
68252: LIST
68253: PUSH
68254: LD_INT 1
68256: NEG
68257: PUSH
68258: LD_INT 0
68260: PUSH
68261: EMPTY
68262: LIST
68263: LIST
68264: PUSH
68265: LD_INT 1
68267: NEG
68268: PUSH
68269: LD_INT 1
68271: NEG
68272: PUSH
68273: EMPTY
68274: LIST
68275: LIST
68276: PUSH
68277: LD_INT 1
68279: NEG
68280: PUSH
68281: LD_INT 2
68283: NEG
68284: PUSH
68285: EMPTY
68286: LIST
68287: LIST
68288: PUSH
68289: LD_INT 0
68291: PUSH
68292: LD_INT 2
68294: NEG
68295: PUSH
68296: EMPTY
68297: LIST
68298: LIST
68299: PUSH
68300: LD_INT 1
68302: PUSH
68303: LD_INT 1
68305: NEG
68306: PUSH
68307: EMPTY
68308: LIST
68309: LIST
68310: PUSH
68311: LD_INT 2
68313: PUSH
68314: LD_INT 0
68316: PUSH
68317: EMPTY
68318: LIST
68319: LIST
68320: PUSH
68321: LD_INT 2
68323: PUSH
68324: LD_INT 1
68326: PUSH
68327: EMPTY
68328: LIST
68329: LIST
68330: PUSH
68331: LD_INT 1
68333: PUSH
68334: LD_INT 2
68336: PUSH
68337: EMPTY
68338: LIST
68339: LIST
68340: PUSH
68341: LD_INT 0
68343: PUSH
68344: LD_INT 2
68346: PUSH
68347: EMPTY
68348: LIST
68349: LIST
68350: PUSH
68351: LD_INT 1
68353: NEG
68354: PUSH
68355: LD_INT 1
68357: PUSH
68358: EMPTY
68359: LIST
68360: LIST
68361: PUSH
68362: LD_INT 2
68364: NEG
68365: PUSH
68366: LD_INT 0
68368: PUSH
68369: EMPTY
68370: LIST
68371: LIST
68372: PUSH
68373: LD_INT 2
68375: NEG
68376: PUSH
68377: LD_INT 1
68379: NEG
68380: PUSH
68381: EMPTY
68382: LIST
68383: LIST
68384: PUSH
68385: LD_INT 1
68387: NEG
68388: PUSH
68389: LD_INT 3
68391: NEG
68392: PUSH
68393: EMPTY
68394: LIST
68395: LIST
68396: PUSH
68397: LD_INT 0
68399: PUSH
68400: LD_INT 3
68402: NEG
68403: PUSH
68404: EMPTY
68405: LIST
68406: LIST
68407: PUSH
68408: LD_INT 1
68410: PUSH
68411: LD_INT 2
68413: NEG
68414: PUSH
68415: EMPTY
68416: LIST
68417: LIST
68418: PUSH
68419: LD_INT 2
68421: PUSH
68422: LD_INT 1
68424: NEG
68425: PUSH
68426: EMPTY
68427: LIST
68428: LIST
68429: PUSH
68430: LD_INT 3
68432: PUSH
68433: LD_INT 0
68435: PUSH
68436: EMPTY
68437: LIST
68438: LIST
68439: PUSH
68440: LD_INT 3
68442: PUSH
68443: LD_INT 1
68445: PUSH
68446: EMPTY
68447: LIST
68448: LIST
68449: PUSH
68450: LD_INT 1
68452: PUSH
68453: LD_INT 3
68455: PUSH
68456: EMPTY
68457: LIST
68458: LIST
68459: PUSH
68460: LD_INT 0
68462: PUSH
68463: LD_INT 3
68465: PUSH
68466: EMPTY
68467: LIST
68468: LIST
68469: PUSH
68470: LD_INT 1
68472: NEG
68473: PUSH
68474: LD_INT 2
68476: PUSH
68477: EMPTY
68478: LIST
68479: LIST
68480: PUSH
68481: LD_INT 2
68483: NEG
68484: PUSH
68485: LD_INT 1
68487: PUSH
68488: EMPTY
68489: LIST
68490: LIST
68491: PUSH
68492: LD_INT 3
68494: NEG
68495: PUSH
68496: LD_INT 0
68498: PUSH
68499: EMPTY
68500: LIST
68501: LIST
68502: PUSH
68503: LD_INT 3
68505: NEG
68506: PUSH
68507: LD_INT 1
68509: NEG
68510: PUSH
68511: EMPTY
68512: LIST
68513: LIST
68514: PUSH
68515: EMPTY
68516: LIST
68517: LIST
68518: LIST
68519: LIST
68520: LIST
68521: LIST
68522: LIST
68523: LIST
68524: LIST
68525: LIST
68526: LIST
68527: LIST
68528: LIST
68529: LIST
68530: LIST
68531: LIST
68532: LIST
68533: LIST
68534: LIST
68535: LIST
68536: LIST
68537: LIST
68538: LIST
68539: LIST
68540: LIST
68541: LIST
68542: LIST
68543: LIST
68544: LIST
68545: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
68546: LD_ADDR_VAR 0 44
68550: PUSH
68551: LD_INT 0
68553: PUSH
68554: LD_INT 0
68556: PUSH
68557: EMPTY
68558: LIST
68559: LIST
68560: PUSH
68561: LD_INT 0
68563: PUSH
68564: LD_INT 1
68566: NEG
68567: PUSH
68568: EMPTY
68569: LIST
68570: LIST
68571: PUSH
68572: LD_INT 1
68574: PUSH
68575: LD_INT 0
68577: PUSH
68578: EMPTY
68579: LIST
68580: LIST
68581: PUSH
68582: LD_INT 1
68584: PUSH
68585: LD_INT 1
68587: PUSH
68588: EMPTY
68589: LIST
68590: LIST
68591: PUSH
68592: LD_INT 0
68594: PUSH
68595: LD_INT 1
68597: PUSH
68598: EMPTY
68599: LIST
68600: LIST
68601: PUSH
68602: LD_INT 1
68604: NEG
68605: PUSH
68606: LD_INT 0
68608: PUSH
68609: EMPTY
68610: LIST
68611: LIST
68612: PUSH
68613: LD_INT 1
68615: NEG
68616: PUSH
68617: LD_INT 1
68619: NEG
68620: PUSH
68621: EMPTY
68622: LIST
68623: LIST
68624: PUSH
68625: LD_INT 1
68627: NEG
68628: PUSH
68629: LD_INT 2
68631: NEG
68632: PUSH
68633: EMPTY
68634: LIST
68635: LIST
68636: PUSH
68637: LD_INT 1
68639: PUSH
68640: LD_INT 1
68642: NEG
68643: PUSH
68644: EMPTY
68645: LIST
68646: LIST
68647: PUSH
68648: LD_INT 2
68650: PUSH
68651: LD_INT 0
68653: PUSH
68654: EMPTY
68655: LIST
68656: LIST
68657: PUSH
68658: LD_INT 2
68660: PUSH
68661: LD_INT 1
68663: PUSH
68664: EMPTY
68665: LIST
68666: LIST
68667: PUSH
68668: LD_INT 2
68670: PUSH
68671: LD_INT 2
68673: PUSH
68674: EMPTY
68675: LIST
68676: LIST
68677: PUSH
68678: LD_INT 1
68680: PUSH
68681: LD_INT 2
68683: PUSH
68684: EMPTY
68685: LIST
68686: LIST
68687: PUSH
68688: LD_INT 1
68690: NEG
68691: PUSH
68692: LD_INT 1
68694: PUSH
68695: EMPTY
68696: LIST
68697: LIST
68698: PUSH
68699: LD_INT 2
68701: NEG
68702: PUSH
68703: LD_INT 0
68705: PUSH
68706: EMPTY
68707: LIST
68708: LIST
68709: PUSH
68710: LD_INT 2
68712: NEG
68713: PUSH
68714: LD_INT 1
68716: NEG
68717: PUSH
68718: EMPTY
68719: LIST
68720: LIST
68721: PUSH
68722: LD_INT 2
68724: NEG
68725: PUSH
68726: LD_INT 2
68728: NEG
68729: PUSH
68730: EMPTY
68731: LIST
68732: LIST
68733: PUSH
68734: LD_INT 2
68736: NEG
68737: PUSH
68738: LD_INT 3
68740: NEG
68741: PUSH
68742: EMPTY
68743: LIST
68744: LIST
68745: PUSH
68746: LD_INT 2
68748: PUSH
68749: LD_INT 1
68751: NEG
68752: PUSH
68753: EMPTY
68754: LIST
68755: LIST
68756: PUSH
68757: LD_INT 3
68759: PUSH
68760: LD_INT 0
68762: PUSH
68763: EMPTY
68764: LIST
68765: LIST
68766: PUSH
68767: LD_INT 3
68769: PUSH
68770: LD_INT 1
68772: PUSH
68773: EMPTY
68774: LIST
68775: LIST
68776: PUSH
68777: LD_INT 3
68779: PUSH
68780: LD_INT 2
68782: PUSH
68783: EMPTY
68784: LIST
68785: LIST
68786: PUSH
68787: LD_INT 3
68789: PUSH
68790: LD_INT 3
68792: PUSH
68793: EMPTY
68794: LIST
68795: LIST
68796: PUSH
68797: LD_INT 2
68799: PUSH
68800: LD_INT 3
68802: PUSH
68803: EMPTY
68804: LIST
68805: LIST
68806: PUSH
68807: LD_INT 2
68809: NEG
68810: PUSH
68811: LD_INT 1
68813: PUSH
68814: EMPTY
68815: LIST
68816: LIST
68817: PUSH
68818: LD_INT 3
68820: NEG
68821: PUSH
68822: LD_INT 0
68824: PUSH
68825: EMPTY
68826: LIST
68827: LIST
68828: PUSH
68829: LD_INT 3
68831: NEG
68832: PUSH
68833: LD_INT 1
68835: NEG
68836: PUSH
68837: EMPTY
68838: LIST
68839: LIST
68840: PUSH
68841: LD_INT 3
68843: NEG
68844: PUSH
68845: LD_INT 2
68847: NEG
68848: PUSH
68849: EMPTY
68850: LIST
68851: LIST
68852: PUSH
68853: LD_INT 3
68855: NEG
68856: PUSH
68857: LD_INT 3
68859: NEG
68860: PUSH
68861: EMPTY
68862: LIST
68863: LIST
68864: PUSH
68865: EMPTY
68866: LIST
68867: LIST
68868: LIST
68869: LIST
68870: LIST
68871: LIST
68872: LIST
68873: LIST
68874: LIST
68875: LIST
68876: LIST
68877: LIST
68878: LIST
68879: LIST
68880: LIST
68881: LIST
68882: LIST
68883: LIST
68884: LIST
68885: LIST
68886: LIST
68887: LIST
68888: LIST
68889: LIST
68890: LIST
68891: LIST
68892: LIST
68893: LIST
68894: LIST
68895: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
68896: LD_ADDR_VAR 0 45
68900: PUSH
68901: LD_INT 0
68903: PUSH
68904: LD_INT 0
68906: PUSH
68907: EMPTY
68908: LIST
68909: LIST
68910: PUSH
68911: LD_INT 0
68913: PUSH
68914: LD_INT 1
68916: NEG
68917: PUSH
68918: EMPTY
68919: LIST
68920: LIST
68921: PUSH
68922: LD_INT 1
68924: PUSH
68925: LD_INT 0
68927: PUSH
68928: EMPTY
68929: LIST
68930: LIST
68931: PUSH
68932: LD_INT 1
68934: PUSH
68935: LD_INT 1
68937: PUSH
68938: EMPTY
68939: LIST
68940: LIST
68941: PUSH
68942: LD_INT 0
68944: PUSH
68945: LD_INT 1
68947: PUSH
68948: EMPTY
68949: LIST
68950: LIST
68951: PUSH
68952: LD_INT 1
68954: NEG
68955: PUSH
68956: LD_INT 0
68958: PUSH
68959: EMPTY
68960: LIST
68961: LIST
68962: PUSH
68963: LD_INT 1
68965: NEG
68966: PUSH
68967: LD_INT 1
68969: NEG
68970: PUSH
68971: EMPTY
68972: LIST
68973: LIST
68974: PUSH
68975: LD_INT 1
68977: NEG
68978: PUSH
68979: LD_INT 2
68981: NEG
68982: PUSH
68983: EMPTY
68984: LIST
68985: LIST
68986: PUSH
68987: LD_INT 0
68989: PUSH
68990: LD_INT 2
68992: NEG
68993: PUSH
68994: EMPTY
68995: LIST
68996: LIST
68997: PUSH
68998: LD_INT 1
69000: PUSH
69001: LD_INT 1
69003: NEG
69004: PUSH
69005: EMPTY
69006: LIST
69007: LIST
69008: PUSH
69009: LD_INT 2
69011: PUSH
69012: LD_INT 1
69014: PUSH
69015: EMPTY
69016: LIST
69017: LIST
69018: PUSH
69019: LD_INT 2
69021: PUSH
69022: LD_INT 2
69024: PUSH
69025: EMPTY
69026: LIST
69027: LIST
69028: PUSH
69029: LD_INT 1
69031: PUSH
69032: LD_INT 2
69034: PUSH
69035: EMPTY
69036: LIST
69037: LIST
69038: PUSH
69039: LD_INT 0
69041: PUSH
69042: LD_INT 2
69044: PUSH
69045: EMPTY
69046: LIST
69047: LIST
69048: PUSH
69049: LD_INT 1
69051: NEG
69052: PUSH
69053: LD_INT 1
69055: PUSH
69056: EMPTY
69057: LIST
69058: LIST
69059: PUSH
69060: LD_INT 2
69062: NEG
69063: PUSH
69064: LD_INT 1
69066: NEG
69067: PUSH
69068: EMPTY
69069: LIST
69070: LIST
69071: PUSH
69072: LD_INT 2
69074: NEG
69075: PUSH
69076: LD_INT 2
69078: NEG
69079: PUSH
69080: EMPTY
69081: LIST
69082: LIST
69083: PUSH
69084: LD_INT 2
69086: NEG
69087: PUSH
69088: LD_INT 3
69090: NEG
69091: PUSH
69092: EMPTY
69093: LIST
69094: LIST
69095: PUSH
69096: LD_INT 1
69098: NEG
69099: PUSH
69100: LD_INT 3
69102: NEG
69103: PUSH
69104: EMPTY
69105: LIST
69106: LIST
69107: PUSH
69108: LD_INT 0
69110: PUSH
69111: LD_INT 3
69113: NEG
69114: PUSH
69115: EMPTY
69116: LIST
69117: LIST
69118: PUSH
69119: LD_INT 1
69121: PUSH
69122: LD_INT 2
69124: NEG
69125: PUSH
69126: EMPTY
69127: LIST
69128: LIST
69129: PUSH
69130: LD_INT 3
69132: PUSH
69133: LD_INT 2
69135: PUSH
69136: EMPTY
69137: LIST
69138: LIST
69139: PUSH
69140: LD_INT 3
69142: PUSH
69143: LD_INT 3
69145: PUSH
69146: EMPTY
69147: LIST
69148: LIST
69149: PUSH
69150: LD_INT 2
69152: PUSH
69153: LD_INT 3
69155: PUSH
69156: EMPTY
69157: LIST
69158: LIST
69159: PUSH
69160: LD_INT 1
69162: PUSH
69163: LD_INT 3
69165: PUSH
69166: EMPTY
69167: LIST
69168: LIST
69169: PUSH
69170: LD_INT 0
69172: PUSH
69173: LD_INT 3
69175: PUSH
69176: EMPTY
69177: LIST
69178: LIST
69179: PUSH
69180: LD_INT 1
69182: NEG
69183: PUSH
69184: LD_INT 2
69186: PUSH
69187: EMPTY
69188: LIST
69189: LIST
69190: PUSH
69191: LD_INT 3
69193: NEG
69194: PUSH
69195: LD_INT 2
69197: NEG
69198: PUSH
69199: EMPTY
69200: LIST
69201: LIST
69202: PUSH
69203: LD_INT 3
69205: NEG
69206: PUSH
69207: LD_INT 3
69209: NEG
69210: PUSH
69211: EMPTY
69212: LIST
69213: LIST
69214: PUSH
69215: EMPTY
69216: LIST
69217: LIST
69218: LIST
69219: LIST
69220: LIST
69221: LIST
69222: LIST
69223: LIST
69224: LIST
69225: LIST
69226: LIST
69227: LIST
69228: LIST
69229: LIST
69230: LIST
69231: LIST
69232: LIST
69233: LIST
69234: LIST
69235: LIST
69236: LIST
69237: LIST
69238: LIST
69239: LIST
69240: LIST
69241: LIST
69242: LIST
69243: LIST
69244: LIST
69245: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
69246: LD_ADDR_VAR 0 46
69250: PUSH
69251: LD_INT 0
69253: PUSH
69254: LD_INT 0
69256: PUSH
69257: EMPTY
69258: LIST
69259: LIST
69260: PUSH
69261: LD_INT 0
69263: PUSH
69264: LD_INT 1
69266: NEG
69267: PUSH
69268: EMPTY
69269: LIST
69270: LIST
69271: PUSH
69272: LD_INT 1
69274: PUSH
69275: LD_INT 0
69277: PUSH
69278: EMPTY
69279: LIST
69280: LIST
69281: PUSH
69282: LD_INT 1
69284: PUSH
69285: LD_INT 1
69287: PUSH
69288: EMPTY
69289: LIST
69290: LIST
69291: PUSH
69292: LD_INT 0
69294: PUSH
69295: LD_INT 1
69297: PUSH
69298: EMPTY
69299: LIST
69300: LIST
69301: PUSH
69302: LD_INT 1
69304: NEG
69305: PUSH
69306: LD_INT 0
69308: PUSH
69309: EMPTY
69310: LIST
69311: LIST
69312: PUSH
69313: LD_INT 1
69315: NEG
69316: PUSH
69317: LD_INT 1
69319: NEG
69320: PUSH
69321: EMPTY
69322: LIST
69323: LIST
69324: PUSH
69325: LD_INT 1
69327: NEG
69328: PUSH
69329: LD_INT 2
69331: NEG
69332: PUSH
69333: EMPTY
69334: LIST
69335: LIST
69336: PUSH
69337: LD_INT 0
69339: PUSH
69340: LD_INT 2
69342: NEG
69343: PUSH
69344: EMPTY
69345: LIST
69346: LIST
69347: PUSH
69348: LD_INT 1
69350: PUSH
69351: LD_INT 1
69353: NEG
69354: PUSH
69355: EMPTY
69356: LIST
69357: LIST
69358: PUSH
69359: LD_INT 2
69361: PUSH
69362: LD_INT 0
69364: PUSH
69365: EMPTY
69366: LIST
69367: LIST
69368: PUSH
69369: LD_INT 2
69371: PUSH
69372: LD_INT 1
69374: PUSH
69375: EMPTY
69376: LIST
69377: LIST
69378: PUSH
69379: LD_INT 1
69381: PUSH
69382: LD_INT 2
69384: PUSH
69385: EMPTY
69386: LIST
69387: LIST
69388: PUSH
69389: LD_INT 0
69391: PUSH
69392: LD_INT 2
69394: PUSH
69395: EMPTY
69396: LIST
69397: LIST
69398: PUSH
69399: LD_INT 1
69401: NEG
69402: PUSH
69403: LD_INT 1
69405: PUSH
69406: EMPTY
69407: LIST
69408: LIST
69409: PUSH
69410: LD_INT 2
69412: NEG
69413: PUSH
69414: LD_INT 0
69416: PUSH
69417: EMPTY
69418: LIST
69419: LIST
69420: PUSH
69421: LD_INT 2
69423: NEG
69424: PUSH
69425: LD_INT 1
69427: NEG
69428: PUSH
69429: EMPTY
69430: LIST
69431: LIST
69432: PUSH
69433: LD_INT 1
69435: NEG
69436: PUSH
69437: LD_INT 3
69439: NEG
69440: PUSH
69441: EMPTY
69442: LIST
69443: LIST
69444: PUSH
69445: LD_INT 0
69447: PUSH
69448: LD_INT 3
69450: NEG
69451: PUSH
69452: EMPTY
69453: LIST
69454: LIST
69455: PUSH
69456: LD_INT 1
69458: PUSH
69459: LD_INT 2
69461: NEG
69462: PUSH
69463: EMPTY
69464: LIST
69465: LIST
69466: PUSH
69467: LD_INT 2
69469: PUSH
69470: LD_INT 1
69472: NEG
69473: PUSH
69474: EMPTY
69475: LIST
69476: LIST
69477: PUSH
69478: LD_INT 3
69480: PUSH
69481: LD_INT 0
69483: PUSH
69484: EMPTY
69485: LIST
69486: LIST
69487: PUSH
69488: LD_INT 3
69490: PUSH
69491: LD_INT 1
69493: PUSH
69494: EMPTY
69495: LIST
69496: LIST
69497: PUSH
69498: LD_INT 1
69500: PUSH
69501: LD_INT 3
69503: PUSH
69504: EMPTY
69505: LIST
69506: LIST
69507: PUSH
69508: LD_INT 0
69510: PUSH
69511: LD_INT 3
69513: PUSH
69514: EMPTY
69515: LIST
69516: LIST
69517: PUSH
69518: LD_INT 1
69520: NEG
69521: PUSH
69522: LD_INT 2
69524: PUSH
69525: EMPTY
69526: LIST
69527: LIST
69528: PUSH
69529: LD_INT 2
69531: NEG
69532: PUSH
69533: LD_INT 1
69535: PUSH
69536: EMPTY
69537: LIST
69538: LIST
69539: PUSH
69540: LD_INT 3
69542: NEG
69543: PUSH
69544: LD_INT 0
69546: PUSH
69547: EMPTY
69548: LIST
69549: LIST
69550: PUSH
69551: LD_INT 3
69553: NEG
69554: PUSH
69555: LD_INT 1
69557: NEG
69558: PUSH
69559: EMPTY
69560: LIST
69561: LIST
69562: PUSH
69563: EMPTY
69564: LIST
69565: LIST
69566: LIST
69567: LIST
69568: LIST
69569: LIST
69570: LIST
69571: LIST
69572: LIST
69573: LIST
69574: LIST
69575: LIST
69576: LIST
69577: LIST
69578: LIST
69579: LIST
69580: LIST
69581: LIST
69582: LIST
69583: LIST
69584: LIST
69585: LIST
69586: LIST
69587: LIST
69588: LIST
69589: LIST
69590: LIST
69591: LIST
69592: LIST
69593: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
69594: LD_ADDR_VAR 0 47
69598: PUSH
69599: LD_INT 0
69601: PUSH
69602: LD_INT 0
69604: PUSH
69605: EMPTY
69606: LIST
69607: LIST
69608: PUSH
69609: LD_INT 0
69611: PUSH
69612: LD_INT 1
69614: NEG
69615: PUSH
69616: EMPTY
69617: LIST
69618: LIST
69619: PUSH
69620: LD_INT 1
69622: PUSH
69623: LD_INT 0
69625: PUSH
69626: EMPTY
69627: LIST
69628: LIST
69629: PUSH
69630: LD_INT 1
69632: PUSH
69633: LD_INT 1
69635: PUSH
69636: EMPTY
69637: LIST
69638: LIST
69639: PUSH
69640: LD_INT 0
69642: PUSH
69643: LD_INT 1
69645: PUSH
69646: EMPTY
69647: LIST
69648: LIST
69649: PUSH
69650: LD_INT 1
69652: NEG
69653: PUSH
69654: LD_INT 0
69656: PUSH
69657: EMPTY
69658: LIST
69659: LIST
69660: PUSH
69661: LD_INT 1
69663: NEG
69664: PUSH
69665: LD_INT 1
69667: NEG
69668: PUSH
69669: EMPTY
69670: LIST
69671: LIST
69672: PUSH
69673: LD_INT 1
69675: NEG
69676: PUSH
69677: LD_INT 2
69679: NEG
69680: PUSH
69681: EMPTY
69682: LIST
69683: LIST
69684: PUSH
69685: LD_INT 0
69687: PUSH
69688: LD_INT 2
69690: NEG
69691: PUSH
69692: EMPTY
69693: LIST
69694: LIST
69695: PUSH
69696: LD_INT 1
69698: PUSH
69699: LD_INT 1
69701: NEG
69702: PUSH
69703: EMPTY
69704: LIST
69705: LIST
69706: PUSH
69707: LD_INT 2
69709: NEG
69710: PUSH
69711: LD_INT 1
69713: NEG
69714: PUSH
69715: EMPTY
69716: LIST
69717: LIST
69718: PUSH
69719: LD_INT 2
69721: NEG
69722: PUSH
69723: LD_INT 2
69725: NEG
69726: PUSH
69727: EMPTY
69728: LIST
69729: LIST
69730: PUSH
69731: EMPTY
69732: LIST
69733: LIST
69734: LIST
69735: LIST
69736: LIST
69737: LIST
69738: LIST
69739: LIST
69740: LIST
69741: LIST
69742: LIST
69743: LIST
69744: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
69745: LD_ADDR_VAR 0 48
69749: PUSH
69750: LD_INT 0
69752: PUSH
69753: LD_INT 0
69755: PUSH
69756: EMPTY
69757: LIST
69758: LIST
69759: PUSH
69760: LD_INT 0
69762: PUSH
69763: LD_INT 1
69765: NEG
69766: PUSH
69767: EMPTY
69768: LIST
69769: LIST
69770: PUSH
69771: LD_INT 1
69773: PUSH
69774: LD_INT 0
69776: PUSH
69777: EMPTY
69778: LIST
69779: LIST
69780: PUSH
69781: LD_INT 1
69783: PUSH
69784: LD_INT 1
69786: PUSH
69787: EMPTY
69788: LIST
69789: LIST
69790: PUSH
69791: LD_INT 0
69793: PUSH
69794: LD_INT 1
69796: PUSH
69797: EMPTY
69798: LIST
69799: LIST
69800: PUSH
69801: LD_INT 1
69803: NEG
69804: PUSH
69805: LD_INT 0
69807: PUSH
69808: EMPTY
69809: LIST
69810: LIST
69811: PUSH
69812: LD_INT 1
69814: NEG
69815: PUSH
69816: LD_INT 1
69818: NEG
69819: PUSH
69820: EMPTY
69821: LIST
69822: LIST
69823: PUSH
69824: LD_INT 1
69826: NEG
69827: PUSH
69828: LD_INT 2
69830: NEG
69831: PUSH
69832: EMPTY
69833: LIST
69834: LIST
69835: PUSH
69836: LD_INT 0
69838: PUSH
69839: LD_INT 2
69841: NEG
69842: PUSH
69843: EMPTY
69844: LIST
69845: LIST
69846: PUSH
69847: LD_INT 1
69849: PUSH
69850: LD_INT 1
69852: NEG
69853: PUSH
69854: EMPTY
69855: LIST
69856: LIST
69857: PUSH
69858: LD_INT 2
69860: PUSH
69861: LD_INT 0
69863: PUSH
69864: EMPTY
69865: LIST
69866: LIST
69867: PUSH
69868: LD_INT 2
69870: PUSH
69871: LD_INT 1
69873: PUSH
69874: EMPTY
69875: LIST
69876: LIST
69877: PUSH
69878: EMPTY
69879: LIST
69880: LIST
69881: LIST
69882: LIST
69883: LIST
69884: LIST
69885: LIST
69886: LIST
69887: LIST
69888: LIST
69889: LIST
69890: LIST
69891: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
69892: LD_ADDR_VAR 0 49
69896: PUSH
69897: LD_INT 0
69899: PUSH
69900: LD_INT 0
69902: PUSH
69903: EMPTY
69904: LIST
69905: LIST
69906: PUSH
69907: LD_INT 0
69909: PUSH
69910: LD_INT 1
69912: NEG
69913: PUSH
69914: EMPTY
69915: LIST
69916: LIST
69917: PUSH
69918: LD_INT 1
69920: PUSH
69921: LD_INT 0
69923: PUSH
69924: EMPTY
69925: LIST
69926: LIST
69927: PUSH
69928: LD_INT 1
69930: PUSH
69931: LD_INT 1
69933: PUSH
69934: EMPTY
69935: LIST
69936: LIST
69937: PUSH
69938: LD_INT 0
69940: PUSH
69941: LD_INT 1
69943: PUSH
69944: EMPTY
69945: LIST
69946: LIST
69947: PUSH
69948: LD_INT 1
69950: NEG
69951: PUSH
69952: LD_INT 0
69954: PUSH
69955: EMPTY
69956: LIST
69957: LIST
69958: PUSH
69959: LD_INT 1
69961: NEG
69962: PUSH
69963: LD_INT 1
69965: NEG
69966: PUSH
69967: EMPTY
69968: LIST
69969: LIST
69970: PUSH
69971: LD_INT 1
69973: PUSH
69974: LD_INT 1
69976: NEG
69977: PUSH
69978: EMPTY
69979: LIST
69980: LIST
69981: PUSH
69982: LD_INT 2
69984: PUSH
69985: LD_INT 0
69987: PUSH
69988: EMPTY
69989: LIST
69990: LIST
69991: PUSH
69992: LD_INT 2
69994: PUSH
69995: LD_INT 1
69997: PUSH
69998: EMPTY
69999: LIST
70000: LIST
70001: PUSH
70002: LD_INT 2
70004: PUSH
70005: LD_INT 2
70007: PUSH
70008: EMPTY
70009: LIST
70010: LIST
70011: PUSH
70012: LD_INT 1
70014: PUSH
70015: LD_INT 2
70017: PUSH
70018: EMPTY
70019: LIST
70020: LIST
70021: PUSH
70022: EMPTY
70023: LIST
70024: LIST
70025: LIST
70026: LIST
70027: LIST
70028: LIST
70029: LIST
70030: LIST
70031: LIST
70032: LIST
70033: LIST
70034: LIST
70035: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
70036: LD_ADDR_VAR 0 50
70040: PUSH
70041: LD_INT 0
70043: PUSH
70044: LD_INT 0
70046: PUSH
70047: EMPTY
70048: LIST
70049: LIST
70050: PUSH
70051: LD_INT 0
70053: PUSH
70054: LD_INT 1
70056: NEG
70057: PUSH
70058: EMPTY
70059: LIST
70060: LIST
70061: PUSH
70062: LD_INT 1
70064: PUSH
70065: LD_INT 0
70067: PUSH
70068: EMPTY
70069: LIST
70070: LIST
70071: PUSH
70072: LD_INT 1
70074: PUSH
70075: LD_INT 1
70077: PUSH
70078: EMPTY
70079: LIST
70080: LIST
70081: PUSH
70082: LD_INT 0
70084: PUSH
70085: LD_INT 1
70087: PUSH
70088: EMPTY
70089: LIST
70090: LIST
70091: PUSH
70092: LD_INT 1
70094: NEG
70095: PUSH
70096: LD_INT 0
70098: PUSH
70099: EMPTY
70100: LIST
70101: LIST
70102: PUSH
70103: LD_INT 1
70105: NEG
70106: PUSH
70107: LD_INT 1
70109: NEG
70110: PUSH
70111: EMPTY
70112: LIST
70113: LIST
70114: PUSH
70115: LD_INT 2
70117: PUSH
70118: LD_INT 1
70120: PUSH
70121: EMPTY
70122: LIST
70123: LIST
70124: PUSH
70125: LD_INT 2
70127: PUSH
70128: LD_INT 2
70130: PUSH
70131: EMPTY
70132: LIST
70133: LIST
70134: PUSH
70135: LD_INT 1
70137: PUSH
70138: LD_INT 2
70140: PUSH
70141: EMPTY
70142: LIST
70143: LIST
70144: PUSH
70145: LD_INT 0
70147: PUSH
70148: LD_INT 2
70150: PUSH
70151: EMPTY
70152: LIST
70153: LIST
70154: PUSH
70155: LD_INT 1
70157: NEG
70158: PUSH
70159: LD_INT 1
70161: PUSH
70162: EMPTY
70163: LIST
70164: LIST
70165: PUSH
70166: EMPTY
70167: LIST
70168: LIST
70169: LIST
70170: LIST
70171: LIST
70172: LIST
70173: LIST
70174: LIST
70175: LIST
70176: LIST
70177: LIST
70178: LIST
70179: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
70180: LD_ADDR_VAR 0 51
70184: PUSH
70185: LD_INT 0
70187: PUSH
70188: LD_INT 0
70190: PUSH
70191: EMPTY
70192: LIST
70193: LIST
70194: PUSH
70195: LD_INT 0
70197: PUSH
70198: LD_INT 1
70200: NEG
70201: PUSH
70202: EMPTY
70203: LIST
70204: LIST
70205: PUSH
70206: LD_INT 1
70208: PUSH
70209: LD_INT 0
70211: PUSH
70212: EMPTY
70213: LIST
70214: LIST
70215: PUSH
70216: LD_INT 1
70218: PUSH
70219: LD_INT 1
70221: PUSH
70222: EMPTY
70223: LIST
70224: LIST
70225: PUSH
70226: LD_INT 0
70228: PUSH
70229: LD_INT 1
70231: PUSH
70232: EMPTY
70233: LIST
70234: LIST
70235: PUSH
70236: LD_INT 1
70238: NEG
70239: PUSH
70240: LD_INT 0
70242: PUSH
70243: EMPTY
70244: LIST
70245: LIST
70246: PUSH
70247: LD_INT 1
70249: NEG
70250: PUSH
70251: LD_INT 1
70253: NEG
70254: PUSH
70255: EMPTY
70256: LIST
70257: LIST
70258: PUSH
70259: LD_INT 1
70261: PUSH
70262: LD_INT 2
70264: PUSH
70265: EMPTY
70266: LIST
70267: LIST
70268: PUSH
70269: LD_INT 0
70271: PUSH
70272: LD_INT 2
70274: PUSH
70275: EMPTY
70276: LIST
70277: LIST
70278: PUSH
70279: LD_INT 1
70281: NEG
70282: PUSH
70283: LD_INT 1
70285: PUSH
70286: EMPTY
70287: LIST
70288: LIST
70289: PUSH
70290: LD_INT 2
70292: NEG
70293: PUSH
70294: LD_INT 0
70296: PUSH
70297: EMPTY
70298: LIST
70299: LIST
70300: PUSH
70301: LD_INT 2
70303: NEG
70304: PUSH
70305: LD_INT 1
70307: NEG
70308: PUSH
70309: EMPTY
70310: LIST
70311: LIST
70312: PUSH
70313: EMPTY
70314: LIST
70315: LIST
70316: LIST
70317: LIST
70318: LIST
70319: LIST
70320: LIST
70321: LIST
70322: LIST
70323: LIST
70324: LIST
70325: LIST
70326: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
70327: LD_ADDR_VAR 0 52
70331: PUSH
70332: LD_INT 0
70334: PUSH
70335: LD_INT 0
70337: PUSH
70338: EMPTY
70339: LIST
70340: LIST
70341: PUSH
70342: LD_INT 0
70344: PUSH
70345: LD_INT 1
70347: NEG
70348: PUSH
70349: EMPTY
70350: LIST
70351: LIST
70352: PUSH
70353: LD_INT 1
70355: PUSH
70356: LD_INT 0
70358: PUSH
70359: EMPTY
70360: LIST
70361: LIST
70362: PUSH
70363: LD_INT 1
70365: PUSH
70366: LD_INT 1
70368: PUSH
70369: EMPTY
70370: LIST
70371: LIST
70372: PUSH
70373: LD_INT 0
70375: PUSH
70376: LD_INT 1
70378: PUSH
70379: EMPTY
70380: LIST
70381: LIST
70382: PUSH
70383: LD_INT 1
70385: NEG
70386: PUSH
70387: LD_INT 0
70389: PUSH
70390: EMPTY
70391: LIST
70392: LIST
70393: PUSH
70394: LD_INT 1
70396: NEG
70397: PUSH
70398: LD_INT 1
70400: NEG
70401: PUSH
70402: EMPTY
70403: LIST
70404: LIST
70405: PUSH
70406: LD_INT 1
70408: NEG
70409: PUSH
70410: LD_INT 2
70412: NEG
70413: PUSH
70414: EMPTY
70415: LIST
70416: LIST
70417: PUSH
70418: LD_INT 1
70420: NEG
70421: PUSH
70422: LD_INT 1
70424: PUSH
70425: EMPTY
70426: LIST
70427: LIST
70428: PUSH
70429: LD_INT 2
70431: NEG
70432: PUSH
70433: LD_INT 0
70435: PUSH
70436: EMPTY
70437: LIST
70438: LIST
70439: PUSH
70440: LD_INT 2
70442: NEG
70443: PUSH
70444: LD_INT 1
70446: NEG
70447: PUSH
70448: EMPTY
70449: LIST
70450: LIST
70451: PUSH
70452: LD_INT 2
70454: NEG
70455: PUSH
70456: LD_INT 2
70458: NEG
70459: PUSH
70460: EMPTY
70461: LIST
70462: LIST
70463: PUSH
70464: EMPTY
70465: LIST
70466: LIST
70467: LIST
70468: LIST
70469: LIST
70470: LIST
70471: LIST
70472: LIST
70473: LIST
70474: LIST
70475: LIST
70476: LIST
70477: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
70478: LD_ADDR_VAR 0 53
70482: PUSH
70483: LD_INT 0
70485: PUSH
70486: LD_INT 0
70488: PUSH
70489: EMPTY
70490: LIST
70491: LIST
70492: PUSH
70493: LD_INT 0
70495: PUSH
70496: LD_INT 1
70498: NEG
70499: PUSH
70500: EMPTY
70501: LIST
70502: LIST
70503: PUSH
70504: LD_INT 1
70506: PUSH
70507: LD_INT 0
70509: PUSH
70510: EMPTY
70511: LIST
70512: LIST
70513: PUSH
70514: LD_INT 1
70516: PUSH
70517: LD_INT 1
70519: PUSH
70520: EMPTY
70521: LIST
70522: LIST
70523: PUSH
70524: LD_INT 0
70526: PUSH
70527: LD_INT 1
70529: PUSH
70530: EMPTY
70531: LIST
70532: LIST
70533: PUSH
70534: LD_INT 1
70536: NEG
70537: PUSH
70538: LD_INT 0
70540: PUSH
70541: EMPTY
70542: LIST
70543: LIST
70544: PUSH
70545: LD_INT 1
70547: NEG
70548: PUSH
70549: LD_INT 1
70551: NEG
70552: PUSH
70553: EMPTY
70554: LIST
70555: LIST
70556: PUSH
70557: LD_INT 1
70559: NEG
70560: PUSH
70561: LD_INT 2
70563: NEG
70564: PUSH
70565: EMPTY
70566: LIST
70567: LIST
70568: PUSH
70569: LD_INT 0
70571: PUSH
70572: LD_INT 2
70574: NEG
70575: PUSH
70576: EMPTY
70577: LIST
70578: LIST
70579: PUSH
70580: LD_INT 1
70582: PUSH
70583: LD_INT 1
70585: NEG
70586: PUSH
70587: EMPTY
70588: LIST
70589: LIST
70590: PUSH
70591: LD_INT 2
70593: PUSH
70594: LD_INT 0
70596: PUSH
70597: EMPTY
70598: LIST
70599: LIST
70600: PUSH
70601: LD_INT 2
70603: PUSH
70604: LD_INT 1
70606: PUSH
70607: EMPTY
70608: LIST
70609: LIST
70610: PUSH
70611: LD_INT 2
70613: PUSH
70614: LD_INT 2
70616: PUSH
70617: EMPTY
70618: LIST
70619: LIST
70620: PUSH
70621: LD_INT 1
70623: PUSH
70624: LD_INT 2
70626: PUSH
70627: EMPTY
70628: LIST
70629: LIST
70630: PUSH
70631: LD_INT 0
70633: PUSH
70634: LD_INT 2
70636: PUSH
70637: EMPTY
70638: LIST
70639: LIST
70640: PUSH
70641: LD_INT 1
70643: NEG
70644: PUSH
70645: LD_INT 1
70647: PUSH
70648: EMPTY
70649: LIST
70650: LIST
70651: PUSH
70652: LD_INT 2
70654: NEG
70655: PUSH
70656: LD_INT 0
70658: PUSH
70659: EMPTY
70660: LIST
70661: LIST
70662: PUSH
70663: LD_INT 2
70665: NEG
70666: PUSH
70667: LD_INT 1
70669: NEG
70670: PUSH
70671: EMPTY
70672: LIST
70673: LIST
70674: PUSH
70675: LD_INT 2
70677: NEG
70678: PUSH
70679: LD_INT 2
70681: NEG
70682: PUSH
70683: EMPTY
70684: LIST
70685: LIST
70686: PUSH
70687: EMPTY
70688: LIST
70689: LIST
70690: LIST
70691: LIST
70692: LIST
70693: LIST
70694: LIST
70695: LIST
70696: LIST
70697: LIST
70698: LIST
70699: LIST
70700: LIST
70701: LIST
70702: LIST
70703: LIST
70704: LIST
70705: LIST
70706: LIST
70707: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
70708: LD_ADDR_VAR 0 54
70712: PUSH
70713: LD_INT 0
70715: PUSH
70716: LD_INT 0
70718: PUSH
70719: EMPTY
70720: LIST
70721: LIST
70722: PUSH
70723: LD_INT 0
70725: PUSH
70726: LD_INT 1
70728: NEG
70729: PUSH
70730: EMPTY
70731: LIST
70732: LIST
70733: PUSH
70734: LD_INT 1
70736: PUSH
70737: LD_INT 0
70739: PUSH
70740: EMPTY
70741: LIST
70742: LIST
70743: PUSH
70744: LD_INT 1
70746: PUSH
70747: LD_INT 1
70749: PUSH
70750: EMPTY
70751: LIST
70752: LIST
70753: PUSH
70754: LD_INT 0
70756: PUSH
70757: LD_INT 1
70759: PUSH
70760: EMPTY
70761: LIST
70762: LIST
70763: PUSH
70764: LD_INT 1
70766: NEG
70767: PUSH
70768: LD_INT 0
70770: PUSH
70771: EMPTY
70772: LIST
70773: LIST
70774: PUSH
70775: LD_INT 1
70777: NEG
70778: PUSH
70779: LD_INT 1
70781: NEG
70782: PUSH
70783: EMPTY
70784: LIST
70785: LIST
70786: PUSH
70787: LD_INT 1
70789: NEG
70790: PUSH
70791: LD_INT 2
70793: NEG
70794: PUSH
70795: EMPTY
70796: LIST
70797: LIST
70798: PUSH
70799: LD_INT 0
70801: PUSH
70802: LD_INT 2
70804: NEG
70805: PUSH
70806: EMPTY
70807: LIST
70808: LIST
70809: PUSH
70810: LD_INT 1
70812: PUSH
70813: LD_INT 1
70815: NEG
70816: PUSH
70817: EMPTY
70818: LIST
70819: LIST
70820: PUSH
70821: LD_INT 2
70823: PUSH
70824: LD_INT 0
70826: PUSH
70827: EMPTY
70828: LIST
70829: LIST
70830: PUSH
70831: LD_INT 2
70833: PUSH
70834: LD_INT 1
70836: PUSH
70837: EMPTY
70838: LIST
70839: LIST
70840: PUSH
70841: LD_INT 2
70843: PUSH
70844: LD_INT 2
70846: PUSH
70847: EMPTY
70848: LIST
70849: LIST
70850: PUSH
70851: LD_INT 1
70853: PUSH
70854: LD_INT 2
70856: PUSH
70857: EMPTY
70858: LIST
70859: LIST
70860: PUSH
70861: LD_INT 0
70863: PUSH
70864: LD_INT 2
70866: PUSH
70867: EMPTY
70868: LIST
70869: LIST
70870: PUSH
70871: LD_INT 1
70873: NEG
70874: PUSH
70875: LD_INT 1
70877: PUSH
70878: EMPTY
70879: LIST
70880: LIST
70881: PUSH
70882: LD_INT 2
70884: NEG
70885: PUSH
70886: LD_INT 0
70888: PUSH
70889: EMPTY
70890: LIST
70891: LIST
70892: PUSH
70893: LD_INT 2
70895: NEG
70896: PUSH
70897: LD_INT 1
70899: NEG
70900: PUSH
70901: EMPTY
70902: LIST
70903: LIST
70904: PUSH
70905: LD_INT 2
70907: NEG
70908: PUSH
70909: LD_INT 2
70911: NEG
70912: PUSH
70913: EMPTY
70914: LIST
70915: LIST
70916: PUSH
70917: EMPTY
70918: LIST
70919: LIST
70920: LIST
70921: LIST
70922: LIST
70923: LIST
70924: LIST
70925: LIST
70926: LIST
70927: LIST
70928: LIST
70929: LIST
70930: LIST
70931: LIST
70932: LIST
70933: LIST
70934: LIST
70935: LIST
70936: LIST
70937: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
70938: LD_ADDR_VAR 0 55
70942: PUSH
70943: LD_INT 0
70945: PUSH
70946: LD_INT 0
70948: PUSH
70949: EMPTY
70950: LIST
70951: LIST
70952: PUSH
70953: LD_INT 0
70955: PUSH
70956: LD_INT 1
70958: NEG
70959: PUSH
70960: EMPTY
70961: LIST
70962: LIST
70963: PUSH
70964: LD_INT 1
70966: PUSH
70967: LD_INT 0
70969: PUSH
70970: EMPTY
70971: LIST
70972: LIST
70973: PUSH
70974: LD_INT 1
70976: PUSH
70977: LD_INT 1
70979: PUSH
70980: EMPTY
70981: LIST
70982: LIST
70983: PUSH
70984: LD_INT 0
70986: PUSH
70987: LD_INT 1
70989: PUSH
70990: EMPTY
70991: LIST
70992: LIST
70993: PUSH
70994: LD_INT 1
70996: NEG
70997: PUSH
70998: LD_INT 0
71000: PUSH
71001: EMPTY
71002: LIST
71003: LIST
71004: PUSH
71005: LD_INT 1
71007: NEG
71008: PUSH
71009: LD_INT 1
71011: NEG
71012: PUSH
71013: EMPTY
71014: LIST
71015: LIST
71016: PUSH
71017: LD_INT 1
71019: NEG
71020: PUSH
71021: LD_INT 2
71023: NEG
71024: PUSH
71025: EMPTY
71026: LIST
71027: LIST
71028: PUSH
71029: LD_INT 0
71031: PUSH
71032: LD_INT 2
71034: NEG
71035: PUSH
71036: EMPTY
71037: LIST
71038: LIST
71039: PUSH
71040: LD_INT 1
71042: PUSH
71043: LD_INT 1
71045: NEG
71046: PUSH
71047: EMPTY
71048: LIST
71049: LIST
71050: PUSH
71051: LD_INT 2
71053: PUSH
71054: LD_INT 0
71056: PUSH
71057: EMPTY
71058: LIST
71059: LIST
71060: PUSH
71061: LD_INT 2
71063: PUSH
71064: LD_INT 1
71066: PUSH
71067: EMPTY
71068: LIST
71069: LIST
71070: PUSH
71071: LD_INT 2
71073: PUSH
71074: LD_INT 2
71076: PUSH
71077: EMPTY
71078: LIST
71079: LIST
71080: PUSH
71081: LD_INT 1
71083: PUSH
71084: LD_INT 2
71086: PUSH
71087: EMPTY
71088: LIST
71089: LIST
71090: PUSH
71091: LD_INT 0
71093: PUSH
71094: LD_INT 2
71096: PUSH
71097: EMPTY
71098: LIST
71099: LIST
71100: PUSH
71101: LD_INT 1
71103: NEG
71104: PUSH
71105: LD_INT 1
71107: PUSH
71108: EMPTY
71109: LIST
71110: LIST
71111: PUSH
71112: LD_INT 2
71114: NEG
71115: PUSH
71116: LD_INT 0
71118: PUSH
71119: EMPTY
71120: LIST
71121: LIST
71122: PUSH
71123: LD_INT 2
71125: NEG
71126: PUSH
71127: LD_INT 1
71129: NEG
71130: PUSH
71131: EMPTY
71132: LIST
71133: LIST
71134: PUSH
71135: LD_INT 2
71137: NEG
71138: PUSH
71139: LD_INT 2
71141: NEG
71142: PUSH
71143: EMPTY
71144: LIST
71145: LIST
71146: PUSH
71147: EMPTY
71148: LIST
71149: LIST
71150: LIST
71151: LIST
71152: LIST
71153: LIST
71154: LIST
71155: LIST
71156: LIST
71157: LIST
71158: LIST
71159: LIST
71160: LIST
71161: LIST
71162: LIST
71163: LIST
71164: LIST
71165: LIST
71166: LIST
71167: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71168: LD_ADDR_VAR 0 56
71172: PUSH
71173: LD_INT 0
71175: PUSH
71176: LD_INT 0
71178: PUSH
71179: EMPTY
71180: LIST
71181: LIST
71182: PUSH
71183: LD_INT 0
71185: PUSH
71186: LD_INT 1
71188: NEG
71189: PUSH
71190: EMPTY
71191: LIST
71192: LIST
71193: PUSH
71194: LD_INT 1
71196: PUSH
71197: LD_INT 0
71199: PUSH
71200: EMPTY
71201: LIST
71202: LIST
71203: PUSH
71204: LD_INT 1
71206: PUSH
71207: LD_INT 1
71209: PUSH
71210: EMPTY
71211: LIST
71212: LIST
71213: PUSH
71214: LD_INT 0
71216: PUSH
71217: LD_INT 1
71219: PUSH
71220: EMPTY
71221: LIST
71222: LIST
71223: PUSH
71224: LD_INT 1
71226: NEG
71227: PUSH
71228: LD_INT 0
71230: PUSH
71231: EMPTY
71232: LIST
71233: LIST
71234: PUSH
71235: LD_INT 1
71237: NEG
71238: PUSH
71239: LD_INT 1
71241: NEG
71242: PUSH
71243: EMPTY
71244: LIST
71245: LIST
71246: PUSH
71247: LD_INT 1
71249: NEG
71250: PUSH
71251: LD_INT 2
71253: NEG
71254: PUSH
71255: EMPTY
71256: LIST
71257: LIST
71258: PUSH
71259: LD_INT 0
71261: PUSH
71262: LD_INT 2
71264: NEG
71265: PUSH
71266: EMPTY
71267: LIST
71268: LIST
71269: PUSH
71270: LD_INT 1
71272: PUSH
71273: LD_INT 1
71275: NEG
71276: PUSH
71277: EMPTY
71278: LIST
71279: LIST
71280: PUSH
71281: LD_INT 2
71283: PUSH
71284: LD_INT 0
71286: PUSH
71287: EMPTY
71288: LIST
71289: LIST
71290: PUSH
71291: LD_INT 2
71293: PUSH
71294: LD_INT 1
71296: PUSH
71297: EMPTY
71298: LIST
71299: LIST
71300: PUSH
71301: LD_INT 2
71303: PUSH
71304: LD_INT 2
71306: PUSH
71307: EMPTY
71308: LIST
71309: LIST
71310: PUSH
71311: LD_INT 1
71313: PUSH
71314: LD_INT 2
71316: PUSH
71317: EMPTY
71318: LIST
71319: LIST
71320: PUSH
71321: LD_INT 0
71323: PUSH
71324: LD_INT 2
71326: PUSH
71327: EMPTY
71328: LIST
71329: LIST
71330: PUSH
71331: LD_INT 1
71333: NEG
71334: PUSH
71335: LD_INT 1
71337: PUSH
71338: EMPTY
71339: LIST
71340: LIST
71341: PUSH
71342: LD_INT 2
71344: NEG
71345: PUSH
71346: LD_INT 0
71348: PUSH
71349: EMPTY
71350: LIST
71351: LIST
71352: PUSH
71353: LD_INT 2
71355: NEG
71356: PUSH
71357: LD_INT 1
71359: NEG
71360: PUSH
71361: EMPTY
71362: LIST
71363: LIST
71364: PUSH
71365: LD_INT 2
71367: NEG
71368: PUSH
71369: LD_INT 2
71371: NEG
71372: PUSH
71373: EMPTY
71374: LIST
71375: LIST
71376: PUSH
71377: EMPTY
71378: LIST
71379: LIST
71380: LIST
71381: LIST
71382: LIST
71383: LIST
71384: LIST
71385: LIST
71386: LIST
71387: LIST
71388: LIST
71389: LIST
71390: LIST
71391: LIST
71392: LIST
71393: LIST
71394: LIST
71395: LIST
71396: LIST
71397: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71398: LD_ADDR_VAR 0 57
71402: PUSH
71403: LD_INT 0
71405: PUSH
71406: LD_INT 0
71408: PUSH
71409: EMPTY
71410: LIST
71411: LIST
71412: PUSH
71413: LD_INT 0
71415: PUSH
71416: LD_INT 1
71418: NEG
71419: PUSH
71420: EMPTY
71421: LIST
71422: LIST
71423: PUSH
71424: LD_INT 1
71426: PUSH
71427: LD_INT 0
71429: PUSH
71430: EMPTY
71431: LIST
71432: LIST
71433: PUSH
71434: LD_INT 1
71436: PUSH
71437: LD_INT 1
71439: PUSH
71440: EMPTY
71441: LIST
71442: LIST
71443: PUSH
71444: LD_INT 0
71446: PUSH
71447: LD_INT 1
71449: PUSH
71450: EMPTY
71451: LIST
71452: LIST
71453: PUSH
71454: LD_INT 1
71456: NEG
71457: PUSH
71458: LD_INT 0
71460: PUSH
71461: EMPTY
71462: LIST
71463: LIST
71464: PUSH
71465: LD_INT 1
71467: NEG
71468: PUSH
71469: LD_INT 1
71471: NEG
71472: PUSH
71473: EMPTY
71474: LIST
71475: LIST
71476: PUSH
71477: LD_INT 1
71479: NEG
71480: PUSH
71481: LD_INT 2
71483: NEG
71484: PUSH
71485: EMPTY
71486: LIST
71487: LIST
71488: PUSH
71489: LD_INT 0
71491: PUSH
71492: LD_INT 2
71494: NEG
71495: PUSH
71496: EMPTY
71497: LIST
71498: LIST
71499: PUSH
71500: LD_INT 1
71502: PUSH
71503: LD_INT 1
71505: NEG
71506: PUSH
71507: EMPTY
71508: LIST
71509: LIST
71510: PUSH
71511: LD_INT 2
71513: PUSH
71514: LD_INT 0
71516: PUSH
71517: EMPTY
71518: LIST
71519: LIST
71520: PUSH
71521: LD_INT 2
71523: PUSH
71524: LD_INT 1
71526: PUSH
71527: EMPTY
71528: LIST
71529: LIST
71530: PUSH
71531: LD_INT 2
71533: PUSH
71534: LD_INT 2
71536: PUSH
71537: EMPTY
71538: LIST
71539: LIST
71540: PUSH
71541: LD_INT 1
71543: PUSH
71544: LD_INT 2
71546: PUSH
71547: EMPTY
71548: LIST
71549: LIST
71550: PUSH
71551: LD_INT 0
71553: PUSH
71554: LD_INT 2
71556: PUSH
71557: EMPTY
71558: LIST
71559: LIST
71560: PUSH
71561: LD_INT 1
71563: NEG
71564: PUSH
71565: LD_INT 1
71567: PUSH
71568: EMPTY
71569: LIST
71570: LIST
71571: PUSH
71572: LD_INT 2
71574: NEG
71575: PUSH
71576: LD_INT 0
71578: PUSH
71579: EMPTY
71580: LIST
71581: LIST
71582: PUSH
71583: LD_INT 2
71585: NEG
71586: PUSH
71587: LD_INT 1
71589: NEG
71590: PUSH
71591: EMPTY
71592: LIST
71593: LIST
71594: PUSH
71595: LD_INT 2
71597: NEG
71598: PUSH
71599: LD_INT 2
71601: NEG
71602: PUSH
71603: EMPTY
71604: LIST
71605: LIST
71606: PUSH
71607: EMPTY
71608: LIST
71609: LIST
71610: LIST
71611: LIST
71612: LIST
71613: LIST
71614: LIST
71615: LIST
71616: LIST
71617: LIST
71618: LIST
71619: LIST
71620: LIST
71621: LIST
71622: LIST
71623: LIST
71624: LIST
71625: LIST
71626: LIST
71627: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71628: LD_ADDR_VAR 0 58
71632: PUSH
71633: LD_INT 0
71635: PUSH
71636: LD_INT 0
71638: PUSH
71639: EMPTY
71640: LIST
71641: LIST
71642: PUSH
71643: LD_INT 0
71645: PUSH
71646: LD_INT 1
71648: NEG
71649: PUSH
71650: EMPTY
71651: LIST
71652: LIST
71653: PUSH
71654: LD_INT 1
71656: PUSH
71657: LD_INT 0
71659: PUSH
71660: EMPTY
71661: LIST
71662: LIST
71663: PUSH
71664: LD_INT 1
71666: PUSH
71667: LD_INT 1
71669: PUSH
71670: EMPTY
71671: LIST
71672: LIST
71673: PUSH
71674: LD_INT 0
71676: PUSH
71677: LD_INT 1
71679: PUSH
71680: EMPTY
71681: LIST
71682: LIST
71683: PUSH
71684: LD_INT 1
71686: NEG
71687: PUSH
71688: LD_INT 0
71690: PUSH
71691: EMPTY
71692: LIST
71693: LIST
71694: PUSH
71695: LD_INT 1
71697: NEG
71698: PUSH
71699: LD_INT 1
71701: NEG
71702: PUSH
71703: EMPTY
71704: LIST
71705: LIST
71706: PUSH
71707: LD_INT 1
71709: NEG
71710: PUSH
71711: LD_INT 2
71713: NEG
71714: PUSH
71715: EMPTY
71716: LIST
71717: LIST
71718: PUSH
71719: LD_INT 0
71721: PUSH
71722: LD_INT 2
71724: NEG
71725: PUSH
71726: EMPTY
71727: LIST
71728: LIST
71729: PUSH
71730: LD_INT 1
71732: PUSH
71733: LD_INT 1
71735: NEG
71736: PUSH
71737: EMPTY
71738: LIST
71739: LIST
71740: PUSH
71741: LD_INT 2
71743: PUSH
71744: LD_INT 0
71746: PUSH
71747: EMPTY
71748: LIST
71749: LIST
71750: PUSH
71751: LD_INT 2
71753: PUSH
71754: LD_INT 1
71756: PUSH
71757: EMPTY
71758: LIST
71759: LIST
71760: PUSH
71761: LD_INT 2
71763: PUSH
71764: LD_INT 2
71766: PUSH
71767: EMPTY
71768: LIST
71769: LIST
71770: PUSH
71771: LD_INT 1
71773: PUSH
71774: LD_INT 2
71776: PUSH
71777: EMPTY
71778: LIST
71779: LIST
71780: PUSH
71781: LD_INT 0
71783: PUSH
71784: LD_INT 2
71786: PUSH
71787: EMPTY
71788: LIST
71789: LIST
71790: PUSH
71791: LD_INT 1
71793: NEG
71794: PUSH
71795: LD_INT 1
71797: PUSH
71798: EMPTY
71799: LIST
71800: LIST
71801: PUSH
71802: LD_INT 2
71804: NEG
71805: PUSH
71806: LD_INT 0
71808: PUSH
71809: EMPTY
71810: LIST
71811: LIST
71812: PUSH
71813: LD_INT 2
71815: NEG
71816: PUSH
71817: LD_INT 1
71819: NEG
71820: PUSH
71821: EMPTY
71822: LIST
71823: LIST
71824: PUSH
71825: LD_INT 2
71827: NEG
71828: PUSH
71829: LD_INT 2
71831: NEG
71832: PUSH
71833: EMPTY
71834: LIST
71835: LIST
71836: PUSH
71837: EMPTY
71838: LIST
71839: LIST
71840: LIST
71841: LIST
71842: LIST
71843: LIST
71844: LIST
71845: LIST
71846: LIST
71847: LIST
71848: LIST
71849: LIST
71850: LIST
71851: LIST
71852: LIST
71853: LIST
71854: LIST
71855: LIST
71856: LIST
71857: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
71858: LD_ADDR_VAR 0 59
71862: PUSH
71863: LD_INT 0
71865: PUSH
71866: LD_INT 0
71868: PUSH
71869: EMPTY
71870: LIST
71871: LIST
71872: PUSH
71873: LD_INT 0
71875: PUSH
71876: LD_INT 1
71878: NEG
71879: PUSH
71880: EMPTY
71881: LIST
71882: LIST
71883: PUSH
71884: LD_INT 1
71886: PUSH
71887: LD_INT 0
71889: PUSH
71890: EMPTY
71891: LIST
71892: LIST
71893: PUSH
71894: LD_INT 1
71896: PUSH
71897: LD_INT 1
71899: PUSH
71900: EMPTY
71901: LIST
71902: LIST
71903: PUSH
71904: LD_INT 0
71906: PUSH
71907: LD_INT 1
71909: PUSH
71910: EMPTY
71911: LIST
71912: LIST
71913: PUSH
71914: LD_INT 1
71916: NEG
71917: PUSH
71918: LD_INT 0
71920: PUSH
71921: EMPTY
71922: LIST
71923: LIST
71924: PUSH
71925: LD_INT 1
71927: NEG
71928: PUSH
71929: LD_INT 1
71931: NEG
71932: PUSH
71933: EMPTY
71934: LIST
71935: LIST
71936: PUSH
71937: EMPTY
71938: LIST
71939: LIST
71940: LIST
71941: LIST
71942: LIST
71943: LIST
71944: LIST
71945: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
71946: LD_ADDR_VAR 0 60
71950: PUSH
71951: LD_INT 0
71953: PUSH
71954: LD_INT 0
71956: PUSH
71957: EMPTY
71958: LIST
71959: LIST
71960: PUSH
71961: LD_INT 0
71963: PUSH
71964: LD_INT 1
71966: NEG
71967: PUSH
71968: EMPTY
71969: LIST
71970: LIST
71971: PUSH
71972: LD_INT 1
71974: PUSH
71975: LD_INT 0
71977: PUSH
71978: EMPTY
71979: LIST
71980: LIST
71981: PUSH
71982: LD_INT 1
71984: PUSH
71985: LD_INT 1
71987: PUSH
71988: EMPTY
71989: LIST
71990: LIST
71991: PUSH
71992: LD_INT 0
71994: PUSH
71995: LD_INT 1
71997: PUSH
71998: EMPTY
71999: LIST
72000: LIST
72001: PUSH
72002: LD_INT 1
72004: NEG
72005: PUSH
72006: LD_INT 0
72008: PUSH
72009: EMPTY
72010: LIST
72011: LIST
72012: PUSH
72013: LD_INT 1
72015: NEG
72016: PUSH
72017: LD_INT 1
72019: NEG
72020: PUSH
72021: EMPTY
72022: LIST
72023: LIST
72024: PUSH
72025: EMPTY
72026: LIST
72027: LIST
72028: LIST
72029: LIST
72030: LIST
72031: LIST
72032: LIST
72033: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
72034: LD_ADDR_VAR 0 61
72038: PUSH
72039: LD_INT 0
72041: PUSH
72042: LD_INT 0
72044: PUSH
72045: EMPTY
72046: LIST
72047: LIST
72048: PUSH
72049: LD_INT 0
72051: PUSH
72052: LD_INT 1
72054: NEG
72055: PUSH
72056: EMPTY
72057: LIST
72058: LIST
72059: PUSH
72060: LD_INT 1
72062: PUSH
72063: LD_INT 0
72065: PUSH
72066: EMPTY
72067: LIST
72068: LIST
72069: PUSH
72070: LD_INT 1
72072: PUSH
72073: LD_INT 1
72075: PUSH
72076: EMPTY
72077: LIST
72078: LIST
72079: PUSH
72080: LD_INT 0
72082: PUSH
72083: LD_INT 1
72085: PUSH
72086: EMPTY
72087: LIST
72088: LIST
72089: PUSH
72090: LD_INT 1
72092: NEG
72093: PUSH
72094: LD_INT 0
72096: PUSH
72097: EMPTY
72098: LIST
72099: LIST
72100: PUSH
72101: LD_INT 1
72103: NEG
72104: PUSH
72105: LD_INT 1
72107: NEG
72108: PUSH
72109: EMPTY
72110: LIST
72111: LIST
72112: PUSH
72113: EMPTY
72114: LIST
72115: LIST
72116: LIST
72117: LIST
72118: LIST
72119: LIST
72120: LIST
72121: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
72122: LD_ADDR_VAR 0 62
72126: PUSH
72127: LD_INT 0
72129: PUSH
72130: LD_INT 0
72132: PUSH
72133: EMPTY
72134: LIST
72135: LIST
72136: PUSH
72137: LD_INT 0
72139: PUSH
72140: LD_INT 1
72142: NEG
72143: PUSH
72144: EMPTY
72145: LIST
72146: LIST
72147: PUSH
72148: LD_INT 1
72150: PUSH
72151: LD_INT 0
72153: PUSH
72154: EMPTY
72155: LIST
72156: LIST
72157: PUSH
72158: LD_INT 1
72160: PUSH
72161: LD_INT 1
72163: PUSH
72164: EMPTY
72165: LIST
72166: LIST
72167: PUSH
72168: LD_INT 0
72170: PUSH
72171: LD_INT 1
72173: PUSH
72174: EMPTY
72175: LIST
72176: LIST
72177: PUSH
72178: LD_INT 1
72180: NEG
72181: PUSH
72182: LD_INT 0
72184: PUSH
72185: EMPTY
72186: LIST
72187: LIST
72188: PUSH
72189: LD_INT 1
72191: NEG
72192: PUSH
72193: LD_INT 1
72195: NEG
72196: PUSH
72197: EMPTY
72198: LIST
72199: LIST
72200: PUSH
72201: EMPTY
72202: LIST
72203: LIST
72204: LIST
72205: LIST
72206: LIST
72207: LIST
72208: LIST
72209: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
72210: LD_ADDR_VAR 0 63
72214: PUSH
72215: LD_INT 0
72217: PUSH
72218: LD_INT 0
72220: PUSH
72221: EMPTY
72222: LIST
72223: LIST
72224: PUSH
72225: LD_INT 0
72227: PUSH
72228: LD_INT 1
72230: NEG
72231: PUSH
72232: EMPTY
72233: LIST
72234: LIST
72235: PUSH
72236: LD_INT 1
72238: PUSH
72239: LD_INT 0
72241: PUSH
72242: EMPTY
72243: LIST
72244: LIST
72245: PUSH
72246: LD_INT 1
72248: PUSH
72249: LD_INT 1
72251: PUSH
72252: EMPTY
72253: LIST
72254: LIST
72255: PUSH
72256: LD_INT 0
72258: PUSH
72259: LD_INT 1
72261: PUSH
72262: EMPTY
72263: LIST
72264: LIST
72265: PUSH
72266: LD_INT 1
72268: NEG
72269: PUSH
72270: LD_INT 0
72272: PUSH
72273: EMPTY
72274: LIST
72275: LIST
72276: PUSH
72277: LD_INT 1
72279: NEG
72280: PUSH
72281: LD_INT 1
72283: NEG
72284: PUSH
72285: EMPTY
72286: LIST
72287: LIST
72288: PUSH
72289: EMPTY
72290: LIST
72291: LIST
72292: LIST
72293: LIST
72294: LIST
72295: LIST
72296: LIST
72297: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
72298: LD_ADDR_VAR 0 64
72302: PUSH
72303: LD_INT 0
72305: PUSH
72306: LD_INT 0
72308: PUSH
72309: EMPTY
72310: LIST
72311: LIST
72312: PUSH
72313: LD_INT 0
72315: PUSH
72316: LD_INT 1
72318: NEG
72319: PUSH
72320: EMPTY
72321: LIST
72322: LIST
72323: PUSH
72324: LD_INT 1
72326: PUSH
72327: LD_INT 0
72329: PUSH
72330: EMPTY
72331: LIST
72332: LIST
72333: PUSH
72334: LD_INT 1
72336: PUSH
72337: LD_INT 1
72339: PUSH
72340: EMPTY
72341: LIST
72342: LIST
72343: PUSH
72344: LD_INT 0
72346: PUSH
72347: LD_INT 1
72349: PUSH
72350: EMPTY
72351: LIST
72352: LIST
72353: PUSH
72354: LD_INT 1
72356: NEG
72357: PUSH
72358: LD_INT 0
72360: PUSH
72361: EMPTY
72362: LIST
72363: LIST
72364: PUSH
72365: LD_INT 1
72367: NEG
72368: PUSH
72369: LD_INT 1
72371: NEG
72372: PUSH
72373: EMPTY
72374: LIST
72375: LIST
72376: PUSH
72377: EMPTY
72378: LIST
72379: LIST
72380: LIST
72381: LIST
72382: LIST
72383: LIST
72384: LIST
72385: ST_TO_ADDR
// end ; 1 :
72386: GO 78283
72388: LD_INT 1
72390: DOUBLE
72391: EQUAL
72392: IFTRUE 72396
72394: GO 75019
72396: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
72397: LD_ADDR_VAR 0 11
72401: PUSH
72402: LD_INT 1
72404: NEG
72405: PUSH
72406: LD_INT 3
72408: NEG
72409: PUSH
72410: EMPTY
72411: LIST
72412: LIST
72413: PUSH
72414: LD_INT 0
72416: PUSH
72417: LD_INT 3
72419: NEG
72420: PUSH
72421: EMPTY
72422: LIST
72423: LIST
72424: PUSH
72425: LD_INT 1
72427: PUSH
72428: LD_INT 2
72430: NEG
72431: PUSH
72432: EMPTY
72433: LIST
72434: LIST
72435: PUSH
72436: EMPTY
72437: LIST
72438: LIST
72439: LIST
72440: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
72441: LD_ADDR_VAR 0 12
72445: PUSH
72446: LD_INT 2
72448: PUSH
72449: LD_INT 1
72451: NEG
72452: PUSH
72453: EMPTY
72454: LIST
72455: LIST
72456: PUSH
72457: LD_INT 3
72459: PUSH
72460: LD_INT 0
72462: PUSH
72463: EMPTY
72464: LIST
72465: LIST
72466: PUSH
72467: LD_INT 3
72469: PUSH
72470: LD_INT 1
72472: PUSH
72473: EMPTY
72474: LIST
72475: LIST
72476: PUSH
72477: EMPTY
72478: LIST
72479: LIST
72480: LIST
72481: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
72482: LD_ADDR_VAR 0 13
72486: PUSH
72487: LD_INT 3
72489: PUSH
72490: LD_INT 2
72492: PUSH
72493: EMPTY
72494: LIST
72495: LIST
72496: PUSH
72497: LD_INT 3
72499: PUSH
72500: LD_INT 3
72502: PUSH
72503: EMPTY
72504: LIST
72505: LIST
72506: PUSH
72507: LD_INT 2
72509: PUSH
72510: LD_INT 3
72512: PUSH
72513: EMPTY
72514: LIST
72515: LIST
72516: PUSH
72517: EMPTY
72518: LIST
72519: LIST
72520: LIST
72521: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
72522: LD_ADDR_VAR 0 14
72526: PUSH
72527: LD_INT 1
72529: PUSH
72530: LD_INT 3
72532: PUSH
72533: EMPTY
72534: LIST
72535: LIST
72536: PUSH
72537: LD_INT 0
72539: PUSH
72540: LD_INT 3
72542: PUSH
72543: EMPTY
72544: LIST
72545: LIST
72546: PUSH
72547: LD_INT 1
72549: NEG
72550: PUSH
72551: LD_INT 2
72553: PUSH
72554: EMPTY
72555: LIST
72556: LIST
72557: PUSH
72558: EMPTY
72559: LIST
72560: LIST
72561: LIST
72562: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
72563: LD_ADDR_VAR 0 15
72567: PUSH
72568: LD_INT 2
72570: NEG
72571: PUSH
72572: LD_INT 1
72574: PUSH
72575: EMPTY
72576: LIST
72577: LIST
72578: PUSH
72579: LD_INT 3
72581: NEG
72582: PUSH
72583: LD_INT 0
72585: PUSH
72586: EMPTY
72587: LIST
72588: LIST
72589: PUSH
72590: LD_INT 3
72592: NEG
72593: PUSH
72594: LD_INT 1
72596: NEG
72597: PUSH
72598: EMPTY
72599: LIST
72600: LIST
72601: PUSH
72602: EMPTY
72603: LIST
72604: LIST
72605: LIST
72606: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72607: LD_ADDR_VAR 0 16
72611: PUSH
72612: LD_INT 2
72614: NEG
72615: PUSH
72616: LD_INT 3
72618: NEG
72619: PUSH
72620: EMPTY
72621: LIST
72622: LIST
72623: PUSH
72624: LD_INT 3
72626: NEG
72627: PUSH
72628: LD_INT 2
72630: NEG
72631: PUSH
72632: EMPTY
72633: LIST
72634: LIST
72635: PUSH
72636: LD_INT 3
72638: NEG
72639: PUSH
72640: LD_INT 3
72642: NEG
72643: PUSH
72644: EMPTY
72645: LIST
72646: LIST
72647: PUSH
72648: EMPTY
72649: LIST
72650: LIST
72651: LIST
72652: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
72653: LD_ADDR_VAR 0 17
72657: PUSH
72658: LD_INT 1
72660: NEG
72661: PUSH
72662: LD_INT 3
72664: NEG
72665: PUSH
72666: EMPTY
72667: LIST
72668: LIST
72669: PUSH
72670: LD_INT 0
72672: PUSH
72673: LD_INT 3
72675: NEG
72676: PUSH
72677: EMPTY
72678: LIST
72679: LIST
72680: PUSH
72681: LD_INT 1
72683: PUSH
72684: LD_INT 2
72686: NEG
72687: PUSH
72688: EMPTY
72689: LIST
72690: LIST
72691: PUSH
72692: EMPTY
72693: LIST
72694: LIST
72695: LIST
72696: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
72697: LD_ADDR_VAR 0 18
72701: PUSH
72702: LD_INT 2
72704: PUSH
72705: LD_INT 1
72707: NEG
72708: PUSH
72709: EMPTY
72710: LIST
72711: LIST
72712: PUSH
72713: LD_INT 3
72715: PUSH
72716: LD_INT 0
72718: PUSH
72719: EMPTY
72720: LIST
72721: LIST
72722: PUSH
72723: LD_INT 3
72725: PUSH
72726: LD_INT 1
72728: PUSH
72729: EMPTY
72730: LIST
72731: LIST
72732: PUSH
72733: EMPTY
72734: LIST
72735: LIST
72736: LIST
72737: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
72738: LD_ADDR_VAR 0 19
72742: PUSH
72743: LD_INT 3
72745: PUSH
72746: LD_INT 2
72748: PUSH
72749: EMPTY
72750: LIST
72751: LIST
72752: PUSH
72753: LD_INT 3
72755: PUSH
72756: LD_INT 3
72758: PUSH
72759: EMPTY
72760: LIST
72761: LIST
72762: PUSH
72763: LD_INT 2
72765: PUSH
72766: LD_INT 3
72768: PUSH
72769: EMPTY
72770: LIST
72771: LIST
72772: PUSH
72773: EMPTY
72774: LIST
72775: LIST
72776: LIST
72777: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
72778: LD_ADDR_VAR 0 20
72782: PUSH
72783: LD_INT 1
72785: PUSH
72786: LD_INT 3
72788: PUSH
72789: EMPTY
72790: LIST
72791: LIST
72792: PUSH
72793: LD_INT 0
72795: PUSH
72796: LD_INT 3
72798: PUSH
72799: EMPTY
72800: LIST
72801: LIST
72802: PUSH
72803: LD_INT 1
72805: NEG
72806: PUSH
72807: LD_INT 2
72809: PUSH
72810: EMPTY
72811: LIST
72812: LIST
72813: PUSH
72814: EMPTY
72815: LIST
72816: LIST
72817: LIST
72818: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
72819: LD_ADDR_VAR 0 21
72823: PUSH
72824: LD_INT 2
72826: NEG
72827: PUSH
72828: LD_INT 1
72830: PUSH
72831: EMPTY
72832: LIST
72833: LIST
72834: PUSH
72835: LD_INT 3
72837: NEG
72838: PUSH
72839: LD_INT 0
72841: PUSH
72842: EMPTY
72843: LIST
72844: LIST
72845: PUSH
72846: LD_INT 3
72848: NEG
72849: PUSH
72850: LD_INT 1
72852: NEG
72853: PUSH
72854: EMPTY
72855: LIST
72856: LIST
72857: PUSH
72858: EMPTY
72859: LIST
72860: LIST
72861: LIST
72862: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72863: LD_ADDR_VAR 0 22
72867: PUSH
72868: LD_INT 2
72870: NEG
72871: PUSH
72872: LD_INT 3
72874: NEG
72875: PUSH
72876: EMPTY
72877: LIST
72878: LIST
72879: PUSH
72880: LD_INT 3
72882: NEG
72883: PUSH
72884: LD_INT 2
72886: NEG
72887: PUSH
72888: EMPTY
72889: LIST
72890: LIST
72891: PUSH
72892: LD_INT 3
72894: NEG
72895: PUSH
72896: LD_INT 3
72898: NEG
72899: PUSH
72900: EMPTY
72901: LIST
72902: LIST
72903: PUSH
72904: EMPTY
72905: LIST
72906: LIST
72907: LIST
72908: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
72909: LD_ADDR_VAR 0 23
72913: PUSH
72914: LD_INT 0
72916: PUSH
72917: LD_INT 3
72919: NEG
72920: PUSH
72921: EMPTY
72922: LIST
72923: LIST
72924: PUSH
72925: LD_INT 1
72927: NEG
72928: PUSH
72929: LD_INT 4
72931: NEG
72932: PUSH
72933: EMPTY
72934: LIST
72935: LIST
72936: PUSH
72937: LD_INT 1
72939: PUSH
72940: LD_INT 3
72942: NEG
72943: PUSH
72944: EMPTY
72945: LIST
72946: LIST
72947: PUSH
72948: EMPTY
72949: LIST
72950: LIST
72951: LIST
72952: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
72953: LD_ADDR_VAR 0 24
72957: PUSH
72958: LD_INT 3
72960: PUSH
72961: LD_INT 0
72963: PUSH
72964: EMPTY
72965: LIST
72966: LIST
72967: PUSH
72968: LD_INT 3
72970: PUSH
72971: LD_INT 1
72973: NEG
72974: PUSH
72975: EMPTY
72976: LIST
72977: LIST
72978: PUSH
72979: LD_INT 4
72981: PUSH
72982: LD_INT 1
72984: PUSH
72985: EMPTY
72986: LIST
72987: LIST
72988: PUSH
72989: EMPTY
72990: LIST
72991: LIST
72992: LIST
72993: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
72994: LD_ADDR_VAR 0 25
72998: PUSH
72999: LD_INT 3
73001: PUSH
73002: LD_INT 3
73004: PUSH
73005: EMPTY
73006: LIST
73007: LIST
73008: PUSH
73009: LD_INT 4
73011: PUSH
73012: LD_INT 3
73014: PUSH
73015: EMPTY
73016: LIST
73017: LIST
73018: PUSH
73019: LD_INT 3
73021: PUSH
73022: LD_INT 4
73024: PUSH
73025: EMPTY
73026: LIST
73027: LIST
73028: PUSH
73029: EMPTY
73030: LIST
73031: LIST
73032: LIST
73033: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
73034: LD_ADDR_VAR 0 26
73038: PUSH
73039: LD_INT 0
73041: PUSH
73042: LD_INT 3
73044: PUSH
73045: EMPTY
73046: LIST
73047: LIST
73048: PUSH
73049: LD_INT 1
73051: PUSH
73052: LD_INT 4
73054: PUSH
73055: EMPTY
73056: LIST
73057: LIST
73058: PUSH
73059: LD_INT 1
73061: NEG
73062: PUSH
73063: LD_INT 3
73065: PUSH
73066: EMPTY
73067: LIST
73068: LIST
73069: PUSH
73070: EMPTY
73071: LIST
73072: LIST
73073: LIST
73074: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
73075: LD_ADDR_VAR 0 27
73079: PUSH
73080: LD_INT 3
73082: NEG
73083: PUSH
73084: LD_INT 0
73086: PUSH
73087: EMPTY
73088: LIST
73089: LIST
73090: PUSH
73091: LD_INT 3
73093: NEG
73094: PUSH
73095: LD_INT 1
73097: PUSH
73098: EMPTY
73099: LIST
73100: LIST
73101: PUSH
73102: LD_INT 4
73104: NEG
73105: PUSH
73106: LD_INT 1
73108: NEG
73109: PUSH
73110: EMPTY
73111: LIST
73112: LIST
73113: PUSH
73114: EMPTY
73115: LIST
73116: LIST
73117: LIST
73118: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
73119: LD_ADDR_VAR 0 28
73123: PUSH
73124: LD_INT 3
73126: NEG
73127: PUSH
73128: LD_INT 3
73130: NEG
73131: PUSH
73132: EMPTY
73133: LIST
73134: LIST
73135: PUSH
73136: LD_INT 3
73138: NEG
73139: PUSH
73140: LD_INT 4
73142: NEG
73143: PUSH
73144: EMPTY
73145: LIST
73146: LIST
73147: PUSH
73148: LD_INT 4
73150: NEG
73151: PUSH
73152: LD_INT 3
73154: NEG
73155: PUSH
73156: EMPTY
73157: LIST
73158: LIST
73159: PUSH
73160: EMPTY
73161: LIST
73162: LIST
73163: LIST
73164: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
73165: LD_ADDR_VAR 0 29
73169: PUSH
73170: LD_INT 1
73172: NEG
73173: PUSH
73174: LD_INT 3
73176: NEG
73177: PUSH
73178: EMPTY
73179: LIST
73180: LIST
73181: PUSH
73182: LD_INT 0
73184: PUSH
73185: LD_INT 3
73187: NEG
73188: PUSH
73189: EMPTY
73190: LIST
73191: LIST
73192: PUSH
73193: LD_INT 1
73195: PUSH
73196: LD_INT 2
73198: NEG
73199: PUSH
73200: EMPTY
73201: LIST
73202: LIST
73203: PUSH
73204: LD_INT 1
73206: NEG
73207: PUSH
73208: LD_INT 4
73210: NEG
73211: PUSH
73212: EMPTY
73213: LIST
73214: LIST
73215: PUSH
73216: LD_INT 0
73218: PUSH
73219: LD_INT 4
73221: NEG
73222: PUSH
73223: EMPTY
73224: LIST
73225: LIST
73226: PUSH
73227: LD_INT 1
73229: PUSH
73230: LD_INT 3
73232: NEG
73233: PUSH
73234: EMPTY
73235: LIST
73236: LIST
73237: PUSH
73238: LD_INT 1
73240: NEG
73241: PUSH
73242: LD_INT 5
73244: NEG
73245: PUSH
73246: EMPTY
73247: LIST
73248: LIST
73249: PUSH
73250: LD_INT 0
73252: PUSH
73253: LD_INT 5
73255: NEG
73256: PUSH
73257: EMPTY
73258: LIST
73259: LIST
73260: PUSH
73261: LD_INT 1
73263: PUSH
73264: LD_INT 4
73266: NEG
73267: PUSH
73268: EMPTY
73269: LIST
73270: LIST
73271: PUSH
73272: LD_INT 1
73274: NEG
73275: PUSH
73276: LD_INT 6
73278: NEG
73279: PUSH
73280: EMPTY
73281: LIST
73282: LIST
73283: PUSH
73284: LD_INT 0
73286: PUSH
73287: LD_INT 6
73289: NEG
73290: PUSH
73291: EMPTY
73292: LIST
73293: LIST
73294: PUSH
73295: LD_INT 1
73297: PUSH
73298: LD_INT 5
73300: NEG
73301: PUSH
73302: EMPTY
73303: LIST
73304: LIST
73305: PUSH
73306: EMPTY
73307: LIST
73308: LIST
73309: LIST
73310: LIST
73311: LIST
73312: LIST
73313: LIST
73314: LIST
73315: LIST
73316: LIST
73317: LIST
73318: LIST
73319: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
73320: LD_ADDR_VAR 0 30
73324: PUSH
73325: LD_INT 2
73327: PUSH
73328: LD_INT 1
73330: NEG
73331: PUSH
73332: EMPTY
73333: LIST
73334: LIST
73335: PUSH
73336: LD_INT 3
73338: PUSH
73339: LD_INT 0
73341: PUSH
73342: EMPTY
73343: LIST
73344: LIST
73345: PUSH
73346: LD_INT 3
73348: PUSH
73349: LD_INT 1
73351: PUSH
73352: EMPTY
73353: LIST
73354: LIST
73355: PUSH
73356: LD_INT 3
73358: PUSH
73359: LD_INT 1
73361: NEG
73362: PUSH
73363: EMPTY
73364: LIST
73365: LIST
73366: PUSH
73367: LD_INT 4
73369: PUSH
73370: LD_INT 0
73372: PUSH
73373: EMPTY
73374: LIST
73375: LIST
73376: PUSH
73377: LD_INT 4
73379: PUSH
73380: LD_INT 1
73382: PUSH
73383: EMPTY
73384: LIST
73385: LIST
73386: PUSH
73387: LD_INT 4
73389: PUSH
73390: LD_INT 1
73392: NEG
73393: PUSH
73394: EMPTY
73395: LIST
73396: LIST
73397: PUSH
73398: LD_INT 5
73400: PUSH
73401: LD_INT 0
73403: PUSH
73404: EMPTY
73405: LIST
73406: LIST
73407: PUSH
73408: LD_INT 5
73410: PUSH
73411: LD_INT 1
73413: PUSH
73414: EMPTY
73415: LIST
73416: LIST
73417: PUSH
73418: LD_INT 5
73420: PUSH
73421: LD_INT 1
73423: NEG
73424: PUSH
73425: EMPTY
73426: LIST
73427: LIST
73428: PUSH
73429: LD_INT 6
73431: PUSH
73432: LD_INT 0
73434: PUSH
73435: EMPTY
73436: LIST
73437: LIST
73438: PUSH
73439: LD_INT 6
73441: PUSH
73442: LD_INT 1
73444: PUSH
73445: EMPTY
73446: LIST
73447: LIST
73448: PUSH
73449: EMPTY
73450: LIST
73451: LIST
73452: LIST
73453: LIST
73454: LIST
73455: LIST
73456: LIST
73457: LIST
73458: LIST
73459: LIST
73460: LIST
73461: LIST
73462: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
73463: LD_ADDR_VAR 0 31
73467: PUSH
73468: LD_INT 3
73470: PUSH
73471: LD_INT 2
73473: PUSH
73474: EMPTY
73475: LIST
73476: LIST
73477: PUSH
73478: LD_INT 3
73480: PUSH
73481: LD_INT 3
73483: PUSH
73484: EMPTY
73485: LIST
73486: LIST
73487: PUSH
73488: LD_INT 2
73490: PUSH
73491: LD_INT 3
73493: PUSH
73494: EMPTY
73495: LIST
73496: LIST
73497: PUSH
73498: LD_INT 4
73500: PUSH
73501: LD_INT 3
73503: PUSH
73504: EMPTY
73505: LIST
73506: LIST
73507: PUSH
73508: LD_INT 4
73510: PUSH
73511: LD_INT 4
73513: PUSH
73514: EMPTY
73515: LIST
73516: LIST
73517: PUSH
73518: LD_INT 3
73520: PUSH
73521: LD_INT 4
73523: PUSH
73524: EMPTY
73525: LIST
73526: LIST
73527: PUSH
73528: LD_INT 5
73530: PUSH
73531: LD_INT 4
73533: PUSH
73534: EMPTY
73535: LIST
73536: LIST
73537: PUSH
73538: LD_INT 5
73540: PUSH
73541: LD_INT 5
73543: PUSH
73544: EMPTY
73545: LIST
73546: LIST
73547: PUSH
73548: LD_INT 4
73550: PUSH
73551: LD_INT 5
73553: PUSH
73554: EMPTY
73555: LIST
73556: LIST
73557: PUSH
73558: LD_INT 6
73560: PUSH
73561: LD_INT 5
73563: PUSH
73564: EMPTY
73565: LIST
73566: LIST
73567: PUSH
73568: LD_INT 6
73570: PUSH
73571: LD_INT 6
73573: PUSH
73574: EMPTY
73575: LIST
73576: LIST
73577: PUSH
73578: LD_INT 5
73580: PUSH
73581: LD_INT 6
73583: PUSH
73584: EMPTY
73585: LIST
73586: LIST
73587: PUSH
73588: EMPTY
73589: LIST
73590: LIST
73591: LIST
73592: LIST
73593: LIST
73594: LIST
73595: LIST
73596: LIST
73597: LIST
73598: LIST
73599: LIST
73600: LIST
73601: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
73602: LD_ADDR_VAR 0 32
73606: PUSH
73607: LD_INT 1
73609: PUSH
73610: LD_INT 3
73612: PUSH
73613: EMPTY
73614: LIST
73615: LIST
73616: PUSH
73617: LD_INT 0
73619: PUSH
73620: LD_INT 3
73622: PUSH
73623: EMPTY
73624: LIST
73625: LIST
73626: PUSH
73627: LD_INT 1
73629: NEG
73630: PUSH
73631: LD_INT 2
73633: PUSH
73634: EMPTY
73635: LIST
73636: LIST
73637: PUSH
73638: LD_INT 1
73640: PUSH
73641: LD_INT 4
73643: PUSH
73644: EMPTY
73645: LIST
73646: LIST
73647: PUSH
73648: LD_INT 0
73650: PUSH
73651: LD_INT 4
73653: PUSH
73654: EMPTY
73655: LIST
73656: LIST
73657: PUSH
73658: LD_INT 1
73660: NEG
73661: PUSH
73662: LD_INT 3
73664: PUSH
73665: EMPTY
73666: LIST
73667: LIST
73668: PUSH
73669: LD_INT 1
73671: PUSH
73672: LD_INT 5
73674: PUSH
73675: EMPTY
73676: LIST
73677: LIST
73678: PUSH
73679: LD_INT 0
73681: PUSH
73682: LD_INT 5
73684: PUSH
73685: EMPTY
73686: LIST
73687: LIST
73688: PUSH
73689: LD_INT 1
73691: NEG
73692: PUSH
73693: LD_INT 4
73695: PUSH
73696: EMPTY
73697: LIST
73698: LIST
73699: PUSH
73700: LD_INT 1
73702: PUSH
73703: LD_INT 6
73705: PUSH
73706: EMPTY
73707: LIST
73708: LIST
73709: PUSH
73710: LD_INT 0
73712: PUSH
73713: LD_INT 6
73715: PUSH
73716: EMPTY
73717: LIST
73718: LIST
73719: PUSH
73720: LD_INT 1
73722: NEG
73723: PUSH
73724: LD_INT 5
73726: PUSH
73727: EMPTY
73728: LIST
73729: LIST
73730: PUSH
73731: EMPTY
73732: LIST
73733: LIST
73734: LIST
73735: LIST
73736: LIST
73737: LIST
73738: LIST
73739: LIST
73740: LIST
73741: LIST
73742: LIST
73743: LIST
73744: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
73745: LD_ADDR_VAR 0 33
73749: PUSH
73750: LD_INT 2
73752: NEG
73753: PUSH
73754: LD_INT 1
73756: PUSH
73757: EMPTY
73758: LIST
73759: LIST
73760: PUSH
73761: LD_INT 3
73763: NEG
73764: PUSH
73765: LD_INT 0
73767: PUSH
73768: EMPTY
73769: LIST
73770: LIST
73771: PUSH
73772: LD_INT 3
73774: NEG
73775: PUSH
73776: LD_INT 1
73778: NEG
73779: PUSH
73780: EMPTY
73781: LIST
73782: LIST
73783: PUSH
73784: LD_INT 3
73786: NEG
73787: PUSH
73788: LD_INT 1
73790: PUSH
73791: EMPTY
73792: LIST
73793: LIST
73794: PUSH
73795: LD_INT 4
73797: NEG
73798: PUSH
73799: LD_INT 0
73801: PUSH
73802: EMPTY
73803: LIST
73804: LIST
73805: PUSH
73806: LD_INT 4
73808: NEG
73809: PUSH
73810: LD_INT 1
73812: NEG
73813: PUSH
73814: EMPTY
73815: LIST
73816: LIST
73817: PUSH
73818: LD_INT 4
73820: NEG
73821: PUSH
73822: LD_INT 1
73824: PUSH
73825: EMPTY
73826: LIST
73827: LIST
73828: PUSH
73829: LD_INT 5
73831: NEG
73832: PUSH
73833: LD_INT 0
73835: PUSH
73836: EMPTY
73837: LIST
73838: LIST
73839: PUSH
73840: LD_INT 5
73842: NEG
73843: PUSH
73844: LD_INT 1
73846: NEG
73847: PUSH
73848: EMPTY
73849: LIST
73850: LIST
73851: PUSH
73852: LD_INT 5
73854: NEG
73855: PUSH
73856: LD_INT 1
73858: PUSH
73859: EMPTY
73860: LIST
73861: LIST
73862: PUSH
73863: LD_INT 6
73865: NEG
73866: PUSH
73867: LD_INT 0
73869: PUSH
73870: EMPTY
73871: LIST
73872: LIST
73873: PUSH
73874: LD_INT 6
73876: NEG
73877: PUSH
73878: LD_INT 1
73880: NEG
73881: PUSH
73882: EMPTY
73883: LIST
73884: LIST
73885: PUSH
73886: EMPTY
73887: LIST
73888: LIST
73889: LIST
73890: LIST
73891: LIST
73892: LIST
73893: LIST
73894: LIST
73895: LIST
73896: LIST
73897: LIST
73898: LIST
73899: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
73900: LD_ADDR_VAR 0 34
73904: PUSH
73905: LD_INT 2
73907: NEG
73908: PUSH
73909: LD_INT 3
73911: NEG
73912: PUSH
73913: EMPTY
73914: LIST
73915: LIST
73916: PUSH
73917: LD_INT 3
73919: NEG
73920: PUSH
73921: LD_INT 2
73923: NEG
73924: PUSH
73925: EMPTY
73926: LIST
73927: LIST
73928: PUSH
73929: LD_INT 3
73931: NEG
73932: PUSH
73933: LD_INT 3
73935: NEG
73936: PUSH
73937: EMPTY
73938: LIST
73939: LIST
73940: PUSH
73941: LD_INT 3
73943: NEG
73944: PUSH
73945: LD_INT 4
73947: NEG
73948: PUSH
73949: EMPTY
73950: LIST
73951: LIST
73952: PUSH
73953: LD_INT 4
73955: NEG
73956: PUSH
73957: LD_INT 3
73959: NEG
73960: PUSH
73961: EMPTY
73962: LIST
73963: LIST
73964: PUSH
73965: LD_INT 4
73967: NEG
73968: PUSH
73969: LD_INT 4
73971: NEG
73972: PUSH
73973: EMPTY
73974: LIST
73975: LIST
73976: PUSH
73977: LD_INT 4
73979: NEG
73980: PUSH
73981: LD_INT 5
73983: NEG
73984: PUSH
73985: EMPTY
73986: LIST
73987: LIST
73988: PUSH
73989: LD_INT 5
73991: NEG
73992: PUSH
73993: LD_INT 4
73995: NEG
73996: PUSH
73997: EMPTY
73998: LIST
73999: LIST
74000: PUSH
74001: LD_INT 5
74003: NEG
74004: PUSH
74005: LD_INT 5
74007: NEG
74008: PUSH
74009: EMPTY
74010: LIST
74011: LIST
74012: PUSH
74013: LD_INT 5
74015: NEG
74016: PUSH
74017: LD_INT 6
74019: NEG
74020: PUSH
74021: EMPTY
74022: LIST
74023: LIST
74024: PUSH
74025: LD_INT 6
74027: NEG
74028: PUSH
74029: LD_INT 5
74031: NEG
74032: PUSH
74033: EMPTY
74034: LIST
74035: LIST
74036: PUSH
74037: LD_INT 6
74039: NEG
74040: PUSH
74041: LD_INT 6
74043: NEG
74044: PUSH
74045: EMPTY
74046: LIST
74047: LIST
74048: PUSH
74049: EMPTY
74050: LIST
74051: LIST
74052: LIST
74053: LIST
74054: LIST
74055: LIST
74056: LIST
74057: LIST
74058: LIST
74059: LIST
74060: LIST
74061: LIST
74062: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
74063: LD_ADDR_VAR 0 41
74067: PUSH
74068: LD_INT 0
74070: PUSH
74071: LD_INT 2
74073: NEG
74074: PUSH
74075: EMPTY
74076: LIST
74077: LIST
74078: PUSH
74079: LD_INT 1
74081: NEG
74082: PUSH
74083: LD_INT 3
74085: NEG
74086: PUSH
74087: EMPTY
74088: LIST
74089: LIST
74090: PUSH
74091: LD_INT 1
74093: PUSH
74094: LD_INT 2
74096: NEG
74097: PUSH
74098: EMPTY
74099: LIST
74100: LIST
74101: PUSH
74102: EMPTY
74103: LIST
74104: LIST
74105: LIST
74106: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
74107: LD_ADDR_VAR 0 42
74111: PUSH
74112: LD_INT 2
74114: PUSH
74115: LD_INT 0
74117: PUSH
74118: EMPTY
74119: LIST
74120: LIST
74121: PUSH
74122: LD_INT 2
74124: PUSH
74125: LD_INT 1
74127: NEG
74128: PUSH
74129: EMPTY
74130: LIST
74131: LIST
74132: PUSH
74133: LD_INT 3
74135: PUSH
74136: LD_INT 1
74138: PUSH
74139: EMPTY
74140: LIST
74141: LIST
74142: PUSH
74143: EMPTY
74144: LIST
74145: LIST
74146: LIST
74147: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
74148: LD_ADDR_VAR 0 43
74152: PUSH
74153: LD_INT 2
74155: PUSH
74156: LD_INT 2
74158: PUSH
74159: EMPTY
74160: LIST
74161: LIST
74162: PUSH
74163: LD_INT 3
74165: PUSH
74166: LD_INT 2
74168: PUSH
74169: EMPTY
74170: LIST
74171: LIST
74172: PUSH
74173: LD_INT 2
74175: PUSH
74176: LD_INT 3
74178: PUSH
74179: EMPTY
74180: LIST
74181: LIST
74182: PUSH
74183: EMPTY
74184: LIST
74185: LIST
74186: LIST
74187: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
74188: LD_ADDR_VAR 0 44
74192: PUSH
74193: LD_INT 0
74195: PUSH
74196: LD_INT 2
74198: PUSH
74199: EMPTY
74200: LIST
74201: LIST
74202: PUSH
74203: LD_INT 1
74205: PUSH
74206: LD_INT 3
74208: PUSH
74209: EMPTY
74210: LIST
74211: LIST
74212: PUSH
74213: LD_INT 1
74215: NEG
74216: PUSH
74217: LD_INT 2
74219: PUSH
74220: EMPTY
74221: LIST
74222: LIST
74223: PUSH
74224: EMPTY
74225: LIST
74226: LIST
74227: LIST
74228: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
74229: LD_ADDR_VAR 0 45
74233: PUSH
74234: LD_INT 2
74236: NEG
74237: PUSH
74238: LD_INT 0
74240: PUSH
74241: EMPTY
74242: LIST
74243: LIST
74244: PUSH
74245: LD_INT 2
74247: NEG
74248: PUSH
74249: LD_INT 1
74251: PUSH
74252: EMPTY
74253: LIST
74254: LIST
74255: PUSH
74256: LD_INT 3
74258: NEG
74259: PUSH
74260: LD_INT 1
74262: NEG
74263: PUSH
74264: EMPTY
74265: LIST
74266: LIST
74267: PUSH
74268: EMPTY
74269: LIST
74270: LIST
74271: LIST
74272: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
74273: LD_ADDR_VAR 0 46
74277: PUSH
74278: LD_INT 2
74280: NEG
74281: PUSH
74282: LD_INT 2
74284: NEG
74285: PUSH
74286: EMPTY
74287: LIST
74288: LIST
74289: PUSH
74290: LD_INT 2
74292: NEG
74293: PUSH
74294: LD_INT 3
74296: NEG
74297: PUSH
74298: EMPTY
74299: LIST
74300: LIST
74301: PUSH
74302: LD_INT 3
74304: NEG
74305: PUSH
74306: LD_INT 2
74308: NEG
74309: PUSH
74310: EMPTY
74311: LIST
74312: LIST
74313: PUSH
74314: EMPTY
74315: LIST
74316: LIST
74317: LIST
74318: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
74319: LD_ADDR_VAR 0 47
74323: PUSH
74324: LD_INT 2
74326: NEG
74327: PUSH
74328: LD_INT 3
74330: NEG
74331: PUSH
74332: EMPTY
74333: LIST
74334: LIST
74335: PUSH
74336: LD_INT 1
74338: NEG
74339: PUSH
74340: LD_INT 3
74342: NEG
74343: PUSH
74344: EMPTY
74345: LIST
74346: LIST
74347: PUSH
74348: EMPTY
74349: LIST
74350: LIST
74351: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
74352: LD_ADDR_VAR 0 48
74356: PUSH
74357: LD_INT 1
74359: PUSH
74360: LD_INT 2
74362: NEG
74363: PUSH
74364: EMPTY
74365: LIST
74366: LIST
74367: PUSH
74368: LD_INT 2
74370: PUSH
74371: LD_INT 1
74373: NEG
74374: PUSH
74375: EMPTY
74376: LIST
74377: LIST
74378: PUSH
74379: EMPTY
74380: LIST
74381: LIST
74382: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
74383: LD_ADDR_VAR 0 49
74387: PUSH
74388: LD_INT 3
74390: PUSH
74391: LD_INT 1
74393: PUSH
74394: EMPTY
74395: LIST
74396: LIST
74397: PUSH
74398: LD_INT 3
74400: PUSH
74401: LD_INT 2
74403: PUSH
74404: EMPTY
74405: LIST
74406: LIST
74407: PUSH
74408: EMPTY
74409: LIST
74410: LIST
74411: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
74412: LD_ADDR_VAR 0 50
74416: PUSH
74417: LD_INT 2
74419: PUSH
74420: LD_INT 3
74422: PUSH
74423: EMPTY
74424: LIST
74425: LIST
74426: PUSH
74427: LD_INT 1
74429: PUSH
74430: LD_INT 3
74432: PUSH
74433: EMPTY
74434: LIST
74435: LIST
74436: PUSH
74437: EMPTY
74438: LIST
74439: LIST
74440: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
74441: LD_ADDR_VAR 0 51
74445: PUSH
74446: LD_INT 1
74448: NEG
74449: PUSH
74450: LD_INT 2
74452: PUSH
74453: EMPTY
74454: LIST
74455: LIST
74456: PUSH
74457: LD_INT 2
74459: NEG
74460: PUSH
74461: LD_INT 1
74463: PUSH
74464: EMPTY
74465: LIST
74466: LIST
74467: PUSH
74468: EMPTY
74469: LIST
74470: LIST
74471: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
74472: LD_ADDR_VAR 0 52
74476: PUSH
74477: LD_INT 3
74479: NEG
74480: PUSH
74481: LD_INT 1
74483: NEG
74484: PUSH
74485: EMPTY
74486: LIST
74487: LIST
74488: PUSH
74489: LD_INT 3
74491: NEG
74492: PUSH
74493: LD_INT 2
74495: NEG
74496: PUSH
74497: EMPTY
74498: LIST
74499: LIST
74500: PUSH
74501: EMPTY
74502: LIST
74503: LIST
74504: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
74505: LD_ADDR_VAR 0 53
74509: PUSH
74510: LD_INT 1
74512: NEG
74513: PUSH
74514: LD_INT 3
74516: NEG
74517: PUSH
74518: EMPTY
74519: LIST
74520: LIST
74521: PUSH
74522: LD_INT 0
74524: PUSH
74525: LD_INT 3
74527: NEG
74528: PUSH
74529: EMPTY
74530: LIST
74531: LIST
74532: PUSH
74533: LD_INT 1
74535: PUSH
74536: LD_INT 2
74538: NEG
74539: PUSH
74540: EMPTY
74541: LIST
74542: LIST
74543: PUSH
74544: EMPTY
74545: LIST
74546: LIST
74547: LIST
74548: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
74549: LD_ADDR_VAR 0 54
74553: PUSH
74554: LD_INT 2
74556: PUSH
74557: LD_INT 1
74559: NEG
74560: PUSH
74561: EMPTY
74562: LIST
74563: LIST
74564: PUSH
74565: LD_INT 3
74567: PUSH
74568: LD_INT 0
74570: PUSH
74571: EMPTY
74572: LIST
74573: LIST
74574: PUSH
74575: LD_INT 3
74577: PUSH
74578: LD_INT 1
74580: PUSH
74581: EMPTY
74582: LIST
74583: LIST
74584: PUSH
74585: EMPTY
74586: LIST
74587: LIST
74588: LIST
74589: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
74590: LD_ADDR_VAR 0 55
74594: PUSH
74595: LD_INT 3
74597: PUSH
74598: LD_INT 2
74600: PUSH
74601: EMPTY
74602: LIST
74603: LIST
74604: PUSH
74605: LD_INT 3
74607: PUSH
74608: LD_INT 3
74610: PUSH
74611: EMPTY
74612: LIST
74613: LIST
74614: PUSH
74615: LD_INT 2
74617: PUSH
74618: LD_INT 3
74620: PUSH
74621: EMPTY
74622: LIST
74623: LIST
74624: PUSH
74625: EMPTY
74626: LIST
74627: LIST
74628: LIST
74629: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
74630: LD_ADDR_VAR 0 56
74634: PUSH
74635: LD_INT 1
74637: PUSH
74638: LD_INT 3
74640: PUSH
74641: EMPTY
74642: LIST
74643: LIST
74644: PUSH
74645: LD_INT 0
74647: PUSH
74648: LD_INT 3
74650: PUSH
74651: EMPTY
74652: LIST
74653: LIST
74654: PUSH
74655: LD_INT 1
74657: NEG
74658: PUSH
74659: LD_INT 2
74661: PUSH
74662: EMPTY
74663: LIST
74664: LIST
74665: PUSH
74666: EMPTY
74667: LIST
74668: LIST
74669: LIST
74670: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74671: LD_ADDR_VAR 0 57
74675: PUSH
74676: LD_INT 2
74678: NEG
74679: PUSH
74680: LD_INT 1
74682: PUSH
74683: EMPTY
74684: LIST
74685: LIST
74686: PUSH
74687: LD_INT 3
74689: NEG
74690: PUSH
74691: LD_INT 0
74693: PUSH
74694: EMPTY
74695: LIST
74696: LIST
74697: PUSH
74698: LD_INT 3
74700: NEG
74701: PUSH
74702: LD_INT 1
74704: NEG
74705: PUSH
74706: EMPTY
74707: LIST
74708: LIST
74709: PUSH
74710: EMPTY
74711: LIST
74712: LIST
74713: LIST
74714: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74715: LD_ADDR_VAR 0 58
74719: PUSH
74720: LD_INT 2
74722: NEG
74723: PUSH
74724: LD_INT 3
74726: NEG
74727: PUSH
74728: EMPTY
74729: LIST
74730: LIST
74731: PUSH
74732: LD_INT 3
74734: NEG
74735: PUSH
74736: LD_INT 2
74738: NEG
74739: PUSH
74740: EMPTY
74741: LIST
74742: LIST
74743: PUSH
74744: LD_INT 3
74746: NEG
74747: PUSH
74748: LD_INT 3
74750: NEG
74751: PUSH
74752: EMPTY
74753: LIST
74754: LIST
74755: PUSH
74756: EMPTY
74757: LIST
74758: LIST
74759: LIST
74760: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
74761: LD_ADDR_VAR 0 59
74765: PUSH
74766: LD_INT 1
74768: NEG
74769: PUSH
74770: LD_INT 2
74772: NEG
74773: PUSH
74774: EMPTY
74775: LIST
74776: LIST
74777: PUSH
74778: LD_INT 0
74780: PUSH
74781: LD_INT 2
74783: NEG
74784: PUSH
74785: EMPTY
74786: LIST
74787: LIST
74788: PUSH
74789: LD_INT 1
74791: PUSH
74792: LD_INT 1
74794: NEG
74795: PUSH
74796: EMPTY
74797: LIST
74798: LIST
74799: PUSH
74800: EMPTY
74801: LIST
74802: LIST
74803: LIST
74804: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
74805: LD_ADDR_VAR 0 60
74809: PUSH
74810: LD_INT 1
74812: PUSH
74813: LD_INT 1
74815: NEG
74816: PUSH
74817: EMPTY
74818: LIST
74819: LIST
74820: PUSH
74821: LD_INT 2
74823: PUSH
74824: LD_INT 0
74826: PUSH
74827: EMPTY
74828: LIST
74829: LIST
74830: PUSH
74831: LD_INT 2
74833: PUSH
74834: LD_INT 1
74836: PUSH
74837: EMPTY
74838: LIST
74839: LIST
74840: PUSH
74841: EMPTY
74842: LIST
74843: LIST
74844: LIST
74845: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
74846: LD_ADDR_VAR 0 61
74850: PUSH
74851: LD_INT 2
74853: PUSH
74854: LD_INT 1
74856: PUSH
74857: EMPTY
74858: LIST
74859: LIST
74860: PUSH
74861: LD_INT 2
74863: PUSH
74864: LD_INT 2
74866: PUSH
74867: EMPTY
74868: LIST
74869: LIST
74870: PUSH
74871: LD_INT 1
74873: PUSH
74874: LD_INT 2
74876: PUSH
74877: EMPTY
74878: LIST
74879: LIST
74880: PUSH
74881: EMPTY
74882: LIST
74883: LIST
74884: LIST
74885: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
74886: LD_ADDR_VAR 0 62
74890: PUSH
74891: LD_INT 1
74893: PUSH
74894: LD_INT 2
74896: PUSH
74897: EMPTY
74898: LIST
74899: LIST
74900: PUSH
74901: LD_INT 0
74903: PUSH
74904: LD_INT 2
74906: PUSH
74907: EMPTY
74908: LIST
74909: LIST
74910: PUSH
74911: LD_INT 1
74913: NEG
74914: PUSH
74915: LD_INT 1
74917: PUSH
74918: EMPTY
74919: LIST
74920: LIST
74921: PUSH
74922: EMPTY
74923: LIST
74924: LIST
74925: LIST
74926: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
74927: LD_ADDR_VAR 0 63
74931: PUSH
74932: LD_INT 1
74934: NEG
74935: PUSH
74936: LD_INT 1
74938: PUSH
74939: EMPTY
74940: LIST
74941: LIST
74942: PUSH
74943: LD_INT 2
74945: NEG
74946: PUSH
74947: LD_INT 0
74949: PUSH
74950: EMPTY
74951: LIST
74952: LIST
74953: PUSH
74954: LD_INT 2
74956: NEG
74957: PUSH
74958: LD_INT 1
74960: NEG
74961: PUSH
74962: EMPTY
74963: LIST
74964: LIST
74965: PUSH
74966: EMPTY
74967: LIST
74968: LIST
74969: LIST
74970: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74971: LD_ADDR_VAR 0 64
74975: PUSH
74976: LD_INT 1
74978: NEG
74979: PUSH
74980: LD_INT 2
74982: NEG
74983: PUSH
74984: EMPTY
74985: LIST
74986: LIST
74987: PUSH
74988: LD_INT 2
74990: NEG
74991: PUSH
74992: LD_INT 1
74994: NEG
74995: PUSH
74996: EMPTY
74997: LIST
74998: LIST
74999: PUSH
75000: LD_INT 2
75002: NEG
75003: PUSH
75004: LD_INT 2
75006: NEG
75007: PUSH
75008: EMPTY
75009: LIST
75010: LIST
75011: PUSH
75012: EMPTY
75013: LIST
75014: LIST
75015: LIST
75016: ST_TO_ADDR
// end ; 2 :
75017: GO 78283
75019: LD_INT 2
75021: DOUBLE
75022: EQUAL
75023: IFTRUE 75027
75025: GO 78282
75027: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
75028: LD_ADDR_VAR 0 29
75032: PUSH
75033: LD_INT 4
75035: PUSH
75036: LD_INT 0
75038: PUSH
75039: EMPTY
75040: LIST
75041: LIST
75042: PUSH
75043: LD_INT 4
75045: PUSH
75046: LD_INT 1
75048: NEG
75049: PUSH
75050: EMPTY
75051: LIST
75052: LIST
75053: PUSH
75054: LD_INT 5
75056: PUSH
75057: LD_INT 0
75059: PUSH
75060: EMPTY
75061: LIST
75062: LIST
75063: PUSH
75064: LD_INT 5
75066: PUSH
75067: LD_INT 1
75069: PUSH
75070: EMPTY
75071: LIST
75072: LIST
75073: PUSH
75074: LD_INT 4
75076: PUSH
75077: LD_INT 1
75079: PUSH
75080: EMPTY
75081: LIST
75082: LIST
75083: PUSH
75084: LD_INT 3
75086: PUSH
75087: LD_INT 0
75089: PUSH
75090: EMPTY
75091: LIST
75092: LIST
75093: PUSH
75094: LD_INT 3
75096: PUSH
75097: LD_INT 1
75099: NEG
75100: PUSH
75101: EMPTY
75102: LIST
75103: LIST
75104: PUSH
75105: LD_INT 3
75107: PUSH
75108: LD_INT 2
75110: NEG
75111: PUSH
75112: EMPTY
75113: LIST
75114: LIST
75115: PUSH
75116: LD_INT 5
75118: PUSH
75119: LD_INT 2
75121: PUSH
75122: EMPTY
75123: LIST
75124: LIST
75125: PUSH
75126: LD_INT 3
75128: PUSH
75129: LD_INT 3
75131: PUSH
75132: EMPTY
75133: LIST
75134: LIST
75135: PUSH
75136: LD_INT 3
75138: PUSH
75139: LD_INT 2
75141: PUSH
75142: EMPTY
75143: LIST
75144: LIST
75145: PUSH
75146: LD_INT 4
75148: PUSH
75149: LD_INT 3
75151: PUSH
75152: EMPTY
75153: LIST
75154: LIST
75155: PUSH
75156: LD_INT 4
75158: PUSH
75159: LD_INT 4
75161: PUSH
75162: EMPTY
75163: LIST
75164: LIST
75165: PUSH
75166: LD_INT 3
75168: PUSH
75169: LD_INT 4
75171: PUSH
75172: EMPTY
75173: LIST
75174: LIST
75175: PUSH
75176: LD_INT 2
75178: PUSH
75179: LD_INT 3
75181: PUSH
75182: EMPTY
75183: LIST
75184: LIST
75185: PUSH
75186: LD_INT 2
75188: PUSH
75189: LD_INT 2
75191: PUSH
75192: EMPTY
75193: LIST
75194: LIST
75195: PUSH
75196: LD_INT 4
75198: PUSH
75199: LD_INT 2
75201: PUSH
75202: EMPTY
75203: LIST
75204: LIST
75205: PUSH
75206: LD_INT 2
75208: PUSH
75209: LD_INT 4
75211: PUSH
75212: EMPTY
75213: LIST
75214: LIST
75215: PUSH
75216: LD_INT 0
75218: PUSH
75219: LD_INT 4
75221: PUSH
75222: EMPTY
75223: LIST
75224: LIST
75225: PUSH
75226: LD_INT 0
75228: PUSH
75229: LD_INT 3
75231: PUSH
75232: EMPTY
75233: LIST
75234: LIST
75235: PUSH
75236: LD_INT 1
75238: PUSH
75239: LD_INT 4
75241: PUSH
75242: EMPTY
75243: LIST
75244: LIST
75245: PUSH
75246: LD_INT 1
75248: PUSH
75249: LD_INT 5
75251: PUSH
75252: EMPTY
75253: LIST
75254: LIST
75255: PUSH
75256: LD_INT 0
75258: PUSH
75259: LD_INT 5
75261: PUSH
75262: EMPTY
75263: LIST
75264: LIST
75265: PUSH
75266: LD_INT 1
75268: NEG
75269: PUSH
75270: LD_INT 4
75272: PUSH
75273: EMPTY
75274: LIST
75275: LIST
75276: PUSH
75277: LD_INT 1
75279: NEG
75280: PUSH
75281: LD_INT 3
75283: PUSH
75284: EMPTY
75285: LIST
75286: LIST
75287: PUSH
75288: LD_INT 2
75290: PUSH
75291: LD_INT 5
75293: PUSH
75294: EMPTY
75295: LIST
75296: LIST
75297: PUSH
75298: LD_INT 2
75300: NEG
75301: PUSH
75302: LD_INT 3
75304: PUSH
75305: EMPTY
75306: LIST
75307: LIST
75308: PUSH
75309: LD_INT 3
75311: NEG
75312: PUSH
75313: LD_INT 0
75315: PUSH
75316: EMPTY
75317: LIST
75318: LIST
75319: PUSH
75320: LD_INT 3
75322: NEG
75323: PUSH
75324: LD_INT 1
75326: NEG
75327: PUSH
75328: EMPTY
75329: LIST
75330: LIST
75331: PUSH
75332: LD_INT 2
75334: NEG
75335: PUSH
75336: LD_INT 0
75338: PUSH
75339: EMPTY
75340: LIST
75341: LIST
75342: PUSH
75343: LD_INT 2
75345: NEG
75346: PUSH
75347: LD_INT 1
75349: PUSH
75350: EMPTY
75351: LIST
75352: LIST
75353: PUSH
75354: LD_INT 3
75356: NEG
75357: PUSH
75358: LD_INT 1
75360: PUSH
75361: EMPTY
75362: LIST
75363: LIST
75364: PUSH
75365: LD_INT 4
75367: NEG
75368: PUSH
75369: LD_INT 0
75371: PUSH
75372: EMPTY
75373: LIST
75374: LIST
75375: PUSH
75376: LD_INT 4
75378: NEG
75379: PUSH
75380: LD_INT 1
75382: NEG
75383: PUSH
75384: EMPTY
75385: LIST
75386: LIST
75387: PUSH
75388: LD_INT 4
75390: NEG
75391: PUSH
75392: LD_INT 2
75394: NEG
75395: PUSH
75396: EMPTY
75397: LIST
75398: LIST
75399: PUSH
75400: LD_INT 2
75402: NEG
75403: PUSH
75404: LD_INT 2
75406: PUSH
75407: EMPTY
75408: LIST
75409: LIST
75410: PUSH
75411: LD_INT 4
75413: NEG
75414: PUSH
75415: LD_INT 4
75417: NEG
75418: PUSH
75419: EMPTY
75420: LIST
75421: LIST
75422: PUSH
75423: LD_INT 4
75425: NEG
75426: PUSH
75427: LD_INT 5
75429: NEG
75430: PUSH
75431: EMPTY
75432: LIST
75433: LIST
75434: PUSH
75435: LD_INT 3
75437: NEG
75438: PUSH
75439: LD_INT 4
75441: NEG
75442: PUSH
75443: EMPTY
75444: LIST
75445: LIST
75446: PUSH
75447: LD_INT 3
75449: NEG
75450: PUSH
75451: LD_INT 3
75453: NEG
75454: PUSH
75455: EMPTY
75456: LIST
75457: LIST
75458: PUSH
75459: LD_INT 4
75461: NEG
75462: PUSH
75463: LD_INT 3
75465: NEG
75466: PUSH
75467: EMPTY
75468: LIST
75469: LIST
75470: PUSH
75471: LD_INT 5
75473: NEG
75474: PUSH
75475: LD_INT 4
75477: NEG
75478: PUSH
75479: EMPTY
75480: LIST
75481: LIST
75482: PUSH
75483: LD_INT 5
75485: NEG
75486: PUSH
75487: LD_INT 5
75489: NEG
75490: PUSH
75491: EMPTY
75492: LIST
75493: LIST
75494: PUSH
75495: LD_INT 3
75497: NEG
75498: PUSH
75499: LD_INT 5
75501: NEG
75502: PUSH
75503: EMPTY
75504: LIST
75505: LIST
75506: PUSH
75507: LD_INT 5
75509: NEG
75510: PUSH
75511: LD_INT 3
75513: NEG
75514: PUSH
75515: EMPTY
75516: LIST
75517: LIST
75518: PUSH
75519: EMPTY
75520: LIST
75521: LIST
75522: LIST
75523: LIST
75524: LIST
75525: LIST
75526: LIST
75527: LIST
75528: LIST
75529: LIST
75530: LIST
75531: LIST
75532: LIST
75533: LIST
75534: LIST
75535: LIST
75536: LIST
75537: LIST
75538: LIST
75539: LIST
75540: LIST
75541: LIST
75542: LIST
75543: LIST
75544: LIST
75545: LIST
75546: LIST
75547: LIST
75548: LIST
75549: LIST
75550: LIST
75551: LIST
75552: LIST
75553: LIST
75554: LIST
75555: LIST
75556: LIST
75557: LIST
75558: LIST
75559: LIST
75560: LIST
75561: LIST
75562: LIST
75563: LIST
75564: LIST
75565: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
75566: LD_ADDR_VAR 0 30
75570: PUSH
75571: LD_INT 4
75573: PUSH
75574: LD_INT 4
75576: PUSH
75577: EMPTY
75578: LIST
75579: LIST
75580: PUSH
75581: LD_INT 4
75583: PUSH
75584: LD_INT 3
75586: PUSH
75587: EMPTY
75588: LIST
75589: LIST
75590: PUSH
75591: LD_INT 5
75593: PUSH
75594: LD_INT 4
75596: PUSH
75597: EMPTY
75598: LIST
75599: LIST
75600: PUSH
75601: LD_INT 5
75603: PUSH
75604: LD_INT 5
75606: PUSH
75607: EMPTY
75608: LIST
75609: LIST
75610: PUSH
75611: LD_INT 4
75613: PUSH
75614: LD_INT 5
75616: PUSH
75617: EMPTY
75618: LIST
75619: LIST
75620: PUSH
75621: LD_INT 3
75623: PUSH
75624: LD_INT 4
75626: PUSH
75627: EMPTY
75628: LIST
75629: LIST
75630: PUSH
75631: LD_INT 3
75633: PUSH
75634: LD_INT 3
75636: PUSH
75637: EMPTY
75638: LIST
75639: LIST
75640: PUSH
75641: LD_INT 5
75643: PUSH
75644: LD_INT 3
75646: PUSH
75647: EMPTY
75648: LIST
75649: LIST
75650: PUSH
75651: LD_INT 3
75653: PUSH
75654: LD_INT 5
75656: PUSH
75657: EMPTY
75658: LIST
75659: LIST
75660: PUSH
75661: LD_INT 0
75663: PUSH
75664: LD_INT 3
75666: PUSH
75667: EMPTY
75668: LIST
75669: LIST
75670: PUSH
75671: LD_INT 0
75673: PUSH
75674: LD_INT 2
75676: PUSH
75677: EMPTY
75678: LIST
75679: LIST
75680: PUSH
75681: LD_INT 1
75683: PUSH
75684: LD_INT 3
75686: PUSH
75687: EMPTY
75688: LIST
75689: LIST
75690: PUSH
75691: LD_INT 1
75693: PUSH
75694: LD_INT 4
75696: PUSH
75697: EMPTY
75698: LIST
75699: LIST
75700: PUSH
75701: LD_INT 0
75703: PUSH
75704: LD_INT 4
75706: PUSH
75707: EMPTY
75708: LIST
75709: LIST
75710: PUSH
75711: LD_INT 1
75713: NEG
75714: PUSH
75715: LD_INT 3
75717: PUSH
75718: EMPTY
75719: LIST
75720: LIST
75721: PUSH
75722: LD_INT 1
75724: NEG
75725: PUSH
75726: LD_INT 2
75728: PUSH
75729: EMPTY
75730: LIST
75731: LIST
75732: PUSH
75733: LD_INT 2
75735: PUSH
75736: LD_INT 4
75738: PUSH
75739: EMPTY
75740: LIST
75741: LIST
75742: PUSH
75743: LD_INT 2
75745: NEG
75746: PUSH
75747: LD_INT 2
75749: PUSH
75750: EMPTY
75751: LIST
75752: LIST
75753: PUSH
75754: LD_INT 4
75756: NEG
75757: PUSH
75758: LD_INT 0
75760: PUSH
75761: EMPTY
75762: LIST
75763: LIST
75764: PUSH
75765: LD_INT 4
75767: NEG
75768: PUSH
75769: LD_INT 1
75771: NEG
75772: PUSH
75773: EMPTY
75774: LIST
75775: LIST
75776: PUSH
75777: LD_INT 3
75779: NEG
75780: PUSH
75781: LD_INT 0
75783: PUSH
75784: EMPTY
75785: LIST
75786: LIST
75787: PUSH
75788: LD_INT 3
75790: NEG
75791: PUSH
75792: LD_INT 1
75794: PUSH
75795: EMPTY
75796: LIST
75797: LIST
75798: PUSH
75799: LD_INT 4
75801: NEG
75802: PUSH
75803: LD_INT 1
75805: PUSH
75806: EMPTY
75807: LIST
75808: LIST
75809: PUSH
75810: LD_INT 5
75812: NEG
75813: PUSH
75814: LD_INT 0
75816: PUSH
75817: EMPTY
75818: LIST
75819: LIST
75820: PUSH
75821: LD_INT 5
75823: NEG
75824: PUSH
75825: LD_INT 1
75827: NEG
75828: PUSH
75829: EMPTY
75830: LIST
75831: LIST
75832: PUSH
75833: LD_INT 5
75835: NEG
75836: PUSH
75837: LD_INT 2
75839: NEG
75840: PUSH
75841: EMPTY
75842: LIST
75843: LIST
75844: PUSH
75845: LD_INT 3
75847: NEG
75848: PUSH
75849: LD_INT 2
75851: PUSH
75852: EMPTY
75853: LIST
75854: LIST
75855: PUSH
75856: LD_INT 3
75858: NEG
75859: PUSH
75860: LD_INT 3
75862: NEG
75863: PUSH
75864: EMPTY
75865: LIST
75866: LIST
75867: PUSH
75868: LD_INT 3
75870: NEG
75871: PUSH
75872: LD_INT 4
75874: NEG
75875: PUSH
75876: EMPTY
75877: LIST
75878: LIST
75879: PUSH
75880: LD_INT 2
75882: NEG
75883: PUSH
75884: LD_INT 3
75886: NEG
75887: PUSH
75888: EMPTY
75889: LIST
75890: LIST
75891: PUSH
75892: LD_INT 2
75894: NEG
75895: PUSH
75896: LD_INT 2
75898: NEG
75899: PUSH
75900: EMPTY
75901: LIST
75902: LIST
75903: PUSH
75904: LD_INT 3
75906: NEG
75907: PUSH
75908: LD_INT 2
75910: NEG
75911: PUSH
75912: EMPTY
75913: LIST
75914: LIST
75915: PUSH
75916: LD_INT 4
75918: NEG
75919: PUSH
75920: LD_INT 3
75922: NEG
75923: PUSH
75924: EMPTY
75925: LIST
75926: LIST
75927: PUSH
75928: LD_INT 4
75930: NEG
75931: PUSH
75932: LD_INT 4
75934: NEG
75935: PUSH
75936: EMPTY
75937: LIST
75938: LIST
75939: PUSH
75940: LD_INT 2
75942: NEG
75943: PUSH
75944: LD_INT 4
75946: NEG
75947: PUSH
75948: EMPTY
75949: LIST
75950: LIST
75951: PUSH
75952: LD_INT 4
75954: NEG
75955: PUSH
75956: LD_INT 2
75958: NEG
75959: PUSH
75960: EMPTY
75961: LIST
75962: LIST
75963: PUSH
75964: LD_INT 0
75966: PUSH
75967: LD_INT 4
75969: NEG
75970: PUSH
75971: EMPTY
75972: LIST
75973: LIST
75974: PUSH
75975: LD_INT 0
75977: PUSH
75978: LD_INT 5
75980: NEG
75981: PUSH
75982: EMPTY
75983: LIST
75984: LIST
75985: PUSH
75986: LD_INT 1
75988: PUSH
75989: LD_INT 4
75991: NEG
75992: PUSH
75993: EMPTY
75994: LIST
75995: LIST
75996: PUSH
75997: LD_INT 1
75999: PUSH
76000: LD_INT 3
76002: NEG
76003: PUSH
76004: EMPTY
76005: LIST
76006: LIST
76007: PUSH
76008: LD_INT 0
76010: PUSH
76011: LD_INT 3
76013: NEG
76014: PUSH
76015: EMPTY
76016: LIST
76017: LIST
76018: PUSH
76019: LD_INT 1
76021: NEG
76022: PUSH
76023: LD_INT 4
76025: NEG
76026: PUSH
76027: EMPTY
76028: LIST
76029: LIST
76030: PUSH
76031: LD_INT 1
76033: NEG
76034: PUSH
76035: LD_INT 5
76037: NEG
76038: PUSH
76039: EMPTY
76040: LIST
76041: LIST
76042: PUSH
76043: LD_INT 2
76045: PUSH
76046: LD_INT 3
76048: NEG
76049: PUSH
76050: EMPTY
76051: LIST
76052: LIST
76053: PUSH
76054: LD_INT 2
76056: NEG
76057: PUSH
76058: LD_INT 5
76060: NEG
76061: PUSH
76062: EMPTY
76063: LIST
76064: LIST
76065: PUSH
76066: EMPTY
76067: LIST
76068: LIST
76069: LIST
76070: LIST
76071: LIST
76072: LIST
76073: LIST
76074: LIST
76075: LIST
76076: LIST
76077: LIST
76078: LIST
76079: LIST
76080: LIST
76081: LIST
76082: LIST
76083: LIST
76084: LIST
76085: LIST
76086: LIST
76087: LIST
76088: LIST
76089: LIST
76090: LIST
76091: LIST
76092: LIST
76093: LIST
76094: LIST
76095: LIST
76096: LIST
76097: LIST
76098: LIST
76099: LIST
76100: LIST
76101: LIST
76102: LIST
76103: LIST
76104: LIST
76105: LIST
76106: LIST
76107: LIST
76108: LIST
76109: LIST
76110: LIST
76111: LIST
76112: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
76113: LD_ADDR_VAR 0 31
76117: PUSH
76118: LD_INT 0
76120: PUSH
76121: LD_INT 4
76123: PUSH
76124: EMPTY
76125: LIST
76126: LIST
76127: PUSH
76128: LD_INT 0
76130: PUSH
76131: LD_INT 3
76133: PUSH
76134: EMPTY
76135: LIST
76136: LIST
76137: PUSH
76138: LD_INT 1
76140: PUSH
76141: LD_INT 4
76143: PUSH
76144: EMPTY
76145: LIST
76146: LIST
76147: PUSH
76148: LD_INT 1
76150: PUSH
76151: LD_INT 5
76153: PUSH
76154: EMPTY
76155: LIST
76156: LIST
76157: PUSH
76158: LD_INT 0
76160: PUSH
76161: LD_INT 5
76163: PUSH
76164: EMPTY
76165: LIST
76166: LIST
76167: PUSH
76168: LD_INT 1
76170: NEG
76171: PUSH
76172: LD_INT 4
76174: PUSH
76175: EMPTY
76176: LIST
76177: LIST
76178: PUSH
76179: LD_INT 1
76181: NEG
76182: PUSH
76183: LD_INT 3
76185: PUSH
76186: EMPTY
76187: LIST
76188: LIST
76189: PUSH
76190: LD_INT 2
76192: PUSH
76193: LD_INT 5
76195: PUSH
76196: EMPTY
76197: LIST
76198: LIST
76199: PUSH
76200: LD_INT 2
76202: NEG
76203: PUSH
76204: LD_INT 3
76206: PUSH
76207: EMPTY
76208: LIST
76209: LIST
76210: PUSH
76211: LD_INT 3
76213: NEG
76214: PUSH
76215: LD_INT 0
76217: PUSH
76218: EMPTY
76219: LIST
76220: LIST
76221: PUSH
76222: LD_INT 3
76224: NEG
76225: PUSH
76226: LD_INT 1
76228: NEG
76229: PUSH
76230: EMPTY
76231: LIST
76232: LIST
76233: PUSH
76234: LD_INT 2
76236: NEG
76237: PUSH
76238: LD_INT 0
76240: PUSH
76241: EMPTY
76242: LIST
76243: LIST
76244: PUSH
76245: LD_INT 2
76247: NEG
76248: PUSH
76249: LD_INT 1
76251: PUSH
76252: EMPTY
76253: LIST
76254: LIST
76255: PUSH
76256: LD_INT 3
76258: NEG
76259: PUSH
76260: LD_INT 1
76262: PUSH
76263: EMPTY
76264: LIST
76265: LIST
76266: PUSH
76267: LD_INT 4
76269: NEG
76270: PUSH
76271: LD_INT 0
76273: PUSH
76274: EMPTY
76275: LIST
76276: LIST
76277: PUSH
76278: LD_INT 4
76280: NEG
76281: PUSH
76282: LD_INT 1
76284: NEG
76285: PUSH
76286: EMPTY
76287: LIST
76288: LIST
76289: PUSH
76290: LD_INT 4
76292: NEG
76293: PUSH
76294: LD_INT 2
76296: NEG
76297: PUSH
76298: EMPTY
76299: LIST
76300: LIST
76301: PUSH
76302: LD_INT 2
76304: NEG
76305: PUSH
76306: LD_INT 2
76308: PUSH
76309: EMPTY
76310: LIST
76311: LIST
76312: PUSH
76313: LD_INT 4
76315: NEG
76316: PUSH
76317: LD_INT 4
76319: NEG
76320: PUSH
76321: EMPTY
76322: LIST
76323: LIST
76324: PUSH
76325: LD_INT 4
76327: NEG
76328: PUSH
76329: LD_INT 5
76331: NEG
76332: PUSH
76333: EMPTY
76334: LIST
76335: LIST
76336: PUSH
76337: LD_INT 3
76339: NEG
76340: PUSH
76341: LD_INT 4
76343: NEG
76344: PUSH
76345: EMPTY
76346: LIST
76347: LIST
76348: PUSH
76349: LD_INT 3
76351: NEG
76352: PUSH
76353: LD_INT 3
76355: NEG
76356: PUSH
76357: EMPTY
76358: LIST
76359: LIST
76360: PUSH
76361: LD_INT 4
76363: NEG
76364: PUSH
76365: LD_INT 3
76367: NEG
76368: PUSH
76369: EMPTY
76370: LIST
76371: LIST
76372: PUSH
76373: LD_INT 5
76375: NEG
76376: PUSH
76377: LD_INT 4
76379: NEG
76380: PUSH
76381: EMPTY
76382: LIST
76383: LIST
76384: PUSH
76385: LD_INT 5
76387: NEG
76388: PUSH
76389: LD_INT 5
76391: NEG
76392: PUSH
76393: EMPTY
76394: LIST
76395: LIST
76396: PUSH
76397: LD_INT 3
76399: NEG
76400: PUSH
76401: LD_INT 5
76403: NEG
76404: PUSH
76405: EMPTY
76406: LIST
76407: LIST
76408: PUSH
76409: LD_INT 5
76411: NEG
76412: PUSH
76413: LD_INT 3
76415: NEG
76416: PUSH
76417: EMPTY
76418: LIST
76419: LIST
76420: PUSH
76421: LD_INT 0
76423: PUSH
76424: LD_INT 3
76426: NEG
76427: PUSH
76428: EMPTY
76429: LIST
76430: LIST
76431: PUSH
76432: LD_INT 0
76434: PUSH
76435: LD_INT 4
76437: NEG
76438: PUSH
76439: EMPTY
76440: LIST
76441: LIST
76442: PUSH
76443: LD_INT 1
76445: PUSH
76446: LD_INT 3
76448: NEG
76449: PUSH
76450: EMPTY
76451: LIST
76452: LIST
76453: PUSH
76454: LD_INT 1
76456: PUSH
76457: LD_INT 2
76459: NEG
76460: PUSH
76461: EMPTY
76462: LIST
76463: LIST
76464: PUSH
76465: LD_INT 0
76467: PUSH
76468: LD_INT 2
76470: NEG
76471: PUSH
76472: EMPTY
76473: LIST
76474: LIST
76475: PUSH
76476: LD_INT 1
76478: NEG
76479: PUSH
76480: LD_INT 3
76482: NEG
76483: PUSH
76484: EMPTY
76485: LIST
76486: LIST
76487: PUSH
76488: LD_INT 1
76490: NEG
76491: PUSH
76492: LD_INT 4
76494: NEG
76495: PUSH
76496: EMPTY
76497: LIST
76498: LIST
76499: PUSH
76500: LD_INT 2
76502: PUSH
76503: LD_INT 2
76505: NEG
76506: PUSH
76507: EMPTY
76508: LIST
76509: LIST
76510: PUSH
76511: LD_INT 2
76513: NEG
76514: PUSH
76515: LD_INT 4
76517: NEG
76518: PUSH
76519: EMPTY
76520: LIST
76521: LIST
76522: PUSH
76523: LD_INT 4
76525: PUSH
76526: LD_INT 0
76528: PUSH
76529: EMPTY
76530: LIST
76531: LIST
76532: PUSH
76533: LD_INT 4
76535: PUSH
76536: LD_INT 1
76538: NEG
76539: PUSH
76540: EMPTY
76541: LIST
76542: LIST
76543: PUSH
76544: LD_INT 5
76546: PUSH
76547: LD_INT 0
76549: PUSH
76550: EMPTY
76551: LIST
76552: LIST
76553: PUSH
76554: LD_INT 5
76556: PUSH
76557: LD_INT 1
76559: PUSH
76560: EMPTY
76561: LIST
76562: LIST
76563: PUSH
76564: LD_INT 4
76566: PUSH
76567: LD_INT 1
76569: PUSH
76570: EMPTY
76571: LIST
76572: LIST
76573: PUSH
76574: LD_INT 3
76576: PUSH
76577: LD_INT 0
76579: PUSH
76580: EMPTY
76581: LIST
76582: LIST
76583: PUSH
76584: LD_INT 3
76586: PUSH
76587: LD_INT 1
76589: NEG
76590: PUSH
76591: EMPTY
76592: LIST
76593: LIST
76594: PUSH
76595: LD_INT 3
76597: PUSH
76598: LD_INT 2
76600: NEG
76601: PUSH
76602: EMPTY
76603: LIST
76604: LIST
76605: PUSH
76606: LD_INT 5
76608: PUSH
76609: LD_INT 2
76611: PUSH
76612: EMPTY
76613: LIST
76614: LIST
76615: PUSH
76616: EMPTY
76617: LIST
76618: LIST
76619: LIST
76620: LIST
76621: LIST
76622: LIST
76623: LIST
76624: LIST
76625: LIST
76626: LIST
76627: LIST
76628: LIST
76629: LIST
76630: LIST
76631: LIST
76632: LIST
76633: LIST
76634: LIST
76635: LIST
76636: LIST
76637: LIST
76638: LIST
76639: LIST
76640: LIST
76641: LIST
76642: LIST
76643: LIST
76644: LIST
76645: LIST
76646: LIST
76647: LIST
76648: LIST
76649: LIST
76650: LIST
76651: LIST
76652: LIST
76653: LIST
76654: LIST
76655: LIST
76656: LIST
76657: LIST
76658: LIST
76659: LIST
76660: LIST
76661: LIST
76662: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
76663: LD_ADDR_VAR 0 32
76667: PUSH
76668: LD_INT 4
76670: NEG
76671: PUSH
76672: LD_INT 0
76674: PUSH
76675: EMPTY
76676: LIST
76677: LIST
76678: PUSH
76679: LD_INT 4
76681: NEG
76682: PUSH
76683: LD_INT 1
76685: NEG
76686: PUSH
76687: EMPTY
76688: LIST
76689: LIST
76690: PUSH
76691: LD_INT 3
76693: NEG
76694: PUSH
76695: LD_INT 0
76697: PUSH
76698: EMPTY
76699: LIST
76700: LIST
76701: PUSH
76702: LD_INT 3
76704: NEG
76705: PUSH
76706: LD_INT 1
76708: PUSH
76709: EMPTY
76710: LIST
76711: LIST
76712: PUSH
76713: LD_INT 4
76715: NEG
76716: PUSH
76717: LD_INT 1
76719: PUSH
76720: EMPTY
76721: LIST
76722: LIST
76723: PUSH
76724: LD_INT 5
76726: NEG
76727: PUSH
76728: LD_INT 0
76730: PUSH
76731: EMPTY
76732: LIST
76733: LIST
76734: PUSH
76735: LD_INT 5
76737: NEG
76738: PUSH
76739: LD_INT 1
76741: NEG
76742: PUSH
76743: EMPTY
76744: LIST
76745: LIST
76746: PUSH
76747: LD_INT 5
76749: NEG
76750: PUSH
76751: LD_INT 2
76753: NEG
76754: PUSH
76755: EMPTY
76756: LIST
76757: LIST
76758: PUSH
76759: LD_INT 3
76761: NEG
76762: PUSH
76763: LD_INT 2
76765: PUSH
76766: EMPTY
76767: LIST
76768: LIST
76769: PUSH
76770: LD_INT 3
76772: NEG
76773: PUSH
76774: LD_INT 3
76776: NEG
76777: PUSH
76778: EMPTY
76779: LIST
76780: LIST
76781: PUSH
76782: LD_INT 3
76784: NEG
76785: PUSH
76786: LD_INT 4
76788: NEG
76789: PUSH
76790: EMPTY
76791: LIST
76792: LIST
76793: PUSH
76794: LD_INT 2
76796: NEG
76797: PUSH
76798: LD_INT 3
76800: NEG
76801: PUSH
76802: EMPTY
76803: LIST
76804: LIST
76805: PUSH
76806: LD_INT 2
76808: NEG
76809: PUSH
76810: LD_INT 2
76812: NEG
76813: PUSH
76814: EMPTY
76815: LIST
76816: LIST
76817: PUSH
76818: LD_INT 3
76820: NEG
76821: PUSH
76822: LD_INT 2
76824: NEG
76825: PUSH
76826: EMPTY
76827: LIST
76828: LIST
76829: PUSH
76830: LD_INT 4
76832: NEG
76833: PUSH
76834: LD_INT 3
76836: NEG
76837: PUSH
76838: EMPTY
76839: LIST
76840: LIST
76841: PUSH
76842: LD_INT 4
76844: NEG
76845: PUSH
76846: LD_INT 4
76848: NEG
76849: PUSH
76850: EMPTY
76851: LIST
76852: LIST
76853: PUSH
76854: LD_INT 2
76856: NEG
76857: PUSH
76858: LD_INT 4
76860: NEG
76861: PUSH
76862: EMPTY
76863: LIST
76864: LIST
76865: PUSH
76866: LD_INT 4
76868: NEG
76869: PUSH
76870: LD_INT 2
76872: NEG
76873: PUSH
76874: EMPTY
76875: LIST
76876: LIST
76877: PUSH
76878: LD_INT 0
76880: PUSH
76881: LD_INT 4
76883: NEG
76884: PUSH
76885: EMPTY
76886: LIST
76887: LIST
76888: PUSH
76889: LD_INT 0
76891: PUSH
76892: LD_INT 5
76894: NEG
76895: PUSH
76896: EMPTY
76897: LIST
76898: LIST
76899: PUSH
76900: LD_INT 1
76902: PUSH
76903: LD_INT 4
76905: NEG
76906: PUSH
76907: EMPTY
76908: LIST
76909: LIST
76910: PUSH
76911: LD_INT 1
76913: PUSH
76914: LD_INT 3
76916: NEG
76917: PUSH
76918: EMPTY
76919: LIST
76920: LIST
76921: PUSH
76922: LD_INT 0
76924: PUSH
76925: LD_INT 3
76927: NEG
76928: PUSH
76929: EMPTY
76930: LIST
76931: LIST
76932: PUSH
76933: LD_INT 1
76935: NEG
76936: PUSH
76937: LD_INT 4
76939: NEG
76940: PUSH
76941: EMPTY
76942: LIST
76943: LIST
76944: PUSH
76945: LD_INT 1
76947: NEG
76948: PUSH
76949: LD_INT 5
76951: NEG
76952: PUSH
76953: EMPTY
76954: LIST
76955: LIST
76956: PUSH
76957: LD_INT 2
76959: PUSH
76960: LD_INT 3
76962: NEG
76963: PUSH
76964: EMPTY
76965: LIST
76966: LIST
76967: PUSH
76968: LD_INT 2
76970: NEG
76971: PUSH
76972: LD_INT 5
76974: NEG
76975: PUSH
76976: EMPTY
76977: LIST
76978: LIST
76979: PUSH
76980: LD_INT 3
76982: PUSH
76983: LD_INT 0
76985: PUSH
76986: EMPTY
76987: LIST
76988: LIST
76989: PUSH
76990: LD_INT 3
76992: PUSH
76993: LD_INT 1
76995: NEG
76996: PUSH
76997: EMPTY
76998: LIST
76999: LIST
77000: PUSH
77001: LD_INT 4
77003: PUSH
77004: LD_INT 0
77006: PUSH
77007: EMPTY
77008: LIST
77009: LIST
77010: PUSH
77011: LD_INT 4
77013: PUSH
77014: LD_INT 1
77016: PUSH
77017: EMPTY
77018: LIST
77019: LIST
77020: PUSH
77021: LD_INT 3
77023: PUSH
77024: LD_INT 1
77026: PUSH
77027: EMPTY
77028: LIST
77029: LIST
77030: PUSH
77031: LD_INT 2
77033: PUSH
77034: LD_INT 0
77036: PUSH
77037: EMPTY
77038: LIST
77039: LIST
77040: PUSH
77041: LD_INT 2
77043: PUSH
77044: LD_INT 1
77046: NEG
77047: PUSH
77048: EMPTY
77049: LIST
77050: LIST
77051: PUSH
77052: LD_INT 2
77054: PUSH
77055: LD_INT 2
77057: NEG
77058: PUSH
77059: EMPTY
77060: LIST
77061: LIST
77062: PUSH
77063: LD_INT 4
77065: PUSH
77066: LD_INT 2
77068: PUSH
77069: EMPTY
77070: LIST
77071: LIST
77072: PUSH
77073: LD_INT 4
77075: PUSH
77076: LD_INT 4
77078: PUSH
77079: EMPTY
77080: LIST
77081: LIST
77082: PUSH
77083: LD_INT 4
77085: PUSH
77086: LD_INT 3
77088: PUSH
77089: EMPTY
77090: LIST
77091: LIST
77092: PUSH
77093: LD_INT 5
77095: PUSH
77096: LD_INT 4
77098: PUSH
77099: EMPTY
77100: LIST
77101: LIST
77102: PUSH
77103: LD_INT 5
77105: PUSH
77106: LD_INT 5
77108: PUSH
77109: EMPTY
77110: LIST
77111: LIST
77112: PUSH
77113: LD_INT 4
77115: PUSH
77116: LD_INT 5
77118: PUSH
77119: EMPTY
77120: LIST
77121: LIST
77122: PUSH
77123: LD_INT 3
77125: PUSH
77126: LD_INT 4
77128: PUSH
77129: EMPTY
77130: LIST
77131: LIST
77132: PUSH
77133: LD_INT 3
77135: PUSH
77136: LD_INT 3
77138: PUSH
77139: EMPTY
77140: LIST
77141: LIST
77142: PUSH
77143: LD_INT 5
77145: PUSH
77146: LD_INT 3
77148: PUSH
77149: EMPTY
77150: LIST
77151: LIST
77152: PUSH
77153: LD_INT 3
77155: PUSH
77156: LD_INT 5
77158: PUSH
77159: EMPTY
77160: LIST
77161: LIST
77162: PUSH
77163: EMPTY
77164: LIST
77165: LIST
77166: LIST
77167: LIST
77168: LIST
77169: LIST
77170: LIST
77171: LIST
77172: LIST
77173: LIST
77174: LIST
77175: LIST
77176: LIST
77177: LIST
77178: LIST
77179: LIST
77180: LIST
77181: LIST
77182: LIST
77183: LIST
77184: LIST
77185: LIST
77186: LIST
77187: LIST
77188: LIST
77189: LIST
77190: LIST
77191: LIST
77192: LIST
77193: LIST
77194: LIST
77195: LIST
77196: LIST
77197: LIST
77198: LIST
77199: LIST
77200: LIST
77201: LIST
77202: LIST
77203: LIST
77204: LIST
77205: LIST
77206: LIST
77207: LIST
77208: LIST
77209: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
77210: LD_ADDR_VAR 0 33
77214: PUSH
77215: LD_INT 4
77217: NEG
77218: PUSH
77219: LD_INT 4
77221: NEG
77222: PUSH
77223: EMPTY
77224: LIST
77225: LIST
77226: PUSH
77227: LD_INT 4
77229: NEG
77230: PUSH
77231: LD_INT 5
77233: NEG
77234: PUSH
77235: EMPTY
77236: LIST
77237: LIST
77238: PUSH
77239: LD_INT 3
77241: NEG
77242: PUSH
77243: LD_INT 4
77245: NEG
77246: PUSH
77247: EMPTY
77248: LIST
77249: LIST
77250: PUSH
77251: LD_INT 3
77253: NEG
77254: PUSH
77255: LD_INT 3
77257: NEG
77258: PUSH
77259: EMPTY
77260: LIST
77261: LIST
77262: PUSH
77263: LD_INT 4
77265: NEG
77266: PUSH
77267: LD_INT 3
77269: NEG
77270: PUSH
77271: EMPTY
77272: LIST
77273: LIST
77274: PUSH
77275: LD_INT 5
77277: NEG
77278: PUSH
77279: LD_INT 4
77281: NEG
77282: PUSH
77283: EMPTY
77284: LIST
77285: LIST
77286: PUSH
77287: LD_INT 5
77289: NEG
77290: PUSH
77291: LD_INT 5
77293: NEG
77294: PUSH
77295: EMPTY
77296: LIST
77297: LIST
77298: PUSH
77299: LD_INT 3
77301: NEG
77302: PUSH
77303: LD_INT 5
77305: NEG
77306: PUSH
77307: EMPTY
77308: LIST
77309: LIST
77310: PUSH
77311: LD_INT 5
77313: NEG
77314: PUSH
77315: LD_INT 3
77317: NEG
77318: PUSH
77319: EMPTY
77320: LIST
77321: LIST
77322: PUSH
77323: LD_INT 0
77325: PUSH
77326: LD_INT 3
77328: NEG
77329: PUSH
77330: EMPTY
77331: LIST
77332: LIST
77333: PUSH
77334: LD_INT 0
77336: PUSH
77337: LD_INT 4
77339: NEG
77340: PUSH
77341: EMPTY
77342: LIST
77343: LIST
77344: PUSH
77345: LD_INT 1
77347: PUSH
77348: LD_INT 3
77350: NEG
77351: PUSH
77352: EMPTY
77353: LIST
77354: LIST
77355: PUSH
77356: LD_INT 1
77358: PUSH
77359: LD_INT 2
77361: NEG
77362: PUSH
77363: EMPTY
77364: LIST
77365: LIST
77366: PUSH
77367: LD_INT 0
77369: PUSH
77370: LD_INT 2
77372: NEG
77373: PUSH
77374: EMPTY
77375: LIST
77376: LIST
77377: PUSH
77378: LD_INT 1
77380: NEG
77381: PUSH
77382: LD_INT 3
77384: NEG
77385: PUSH
77386: EMPTY
77387: LIST
77388: LIST
77389: PUSH
77390: LD_INT 1
77392: NEG
77393: PUSH
77394: LD_INT 4
77396: NEG
77397: PUSH
77398: EMPTY
77399: LIST
77400: LIST
77401: PUSH
77402: LD_INT 2
77404: PUSH
77405: LD_INT 2
77407: NEG
77408: PUSH
77409: EMPTY
77410: LIST
77411: LIST
77412: PUSH
77413: LD_INT 2
77415: NEG
77416: PUSH
77417: LD_INT 4
77419: NEG
77420: PUSH
77421: EMPTY
77422: LIST
77423: LIST
77424: PUSH
77425: LD_INT 4
77427: PUSH
77428: LD_INT 0
77430: PUSH
77431: EMPTY
77432: LIST
77433: LIST
77434: PUSH
77435: LD_INT 4
77437: PUSH
77438: LD_INT 1
77440: NEG
77441: PUSH
77442: EMPTY
77443: LIST
77444: LIST
77445: PUSH
77446: LD_INT 5
77448: PUSH
77449: LD_INT 0
77451: PUSH
77452: EMPTY
77453: LIST
77454: LIST
77455: PUSH
77456: LD_INT 5
77458: PUSH
77459: LD_INT 1
77461: PUSH
77462: EMPTY
77463: LIST
77464: LIST
77465: PUSH
77466: LD_INT 4
77468: PUSH
77469: LD_INT 1
77471: PUSH
77472: EMPTY
77473: LIST
77474: LIST
77475: PUSH
77476: LD_INT 3
77478: PUSH
77479: LD_INT 0
77481: PUSH
77482: EMPTY
77483: LIST
77484: LIST
77485: PUSH
77486: LD_INT 3
77488: PUSH
77489: LD_INT 1
77491: NEG
77492: PUSH
77493: EMPTY
77494: LIST
77495: LIST
77496: PUSH
77497: LD_INT 3
77499: PUSH
77500: LD_INT 2
77502: NEG
77503: PUSH
77504: EMPTY
77505: LIST
77506: LIST
77507: PUSH
77508: LD_INT 5
77510: PUSH
77511: LD_INT 2
77513: PUSH
77514: EMPTY
77515: LIST
77516: LIST
77517: PUSH
77518: LD_INT 3
77520: PUSH
77521: LD_INT 3
77523: PUSH
77524: EMPTY
77525: LIST
77526: LIST
77527: PUSH
77528: LD_INT 3
77530: PUSH
77531: LD_INT 2
77533: PUSH
77534: EMPTY
77535: LIST
77536: LIST
77537: PUSH
77538: LD_INT 4
77540: PUSH
77541: LD_INT 3
77543: PUSH
77544: EMPTY
77545: LIST
77546: LIST
77547: PUSH
77548: LD_INT 4
77550: PUSH
77551: LD_INT 4
77553: PUSH
77554: EMPTY
77555: LIST
77556: LIST
77557: PUSH
77558: LD_INT 3
77560: PUSH
77561: LD_INT 4
77563: PUSH
77564: EMPTY
77565: LIST
77566: LIST
77567: PUSH
77568: LD_INT 2
77570: PUSH
77571: LD_INT 3
77573: PUSH
77574: EMPTY
77575: LIST
77576: LIST
77577: PUSH
77578: LD_INT 2
77580: PUSH
77581: LD_INT 2
77583: PUSH
77584: EMPTY
77585: LIST
77586: LIST
77587: PUSH
77588: LD_INT 4
77590: PUSH
77591: LD_INT 2
77593: PUSH
77594: EMPTY
77595: LIST
77596: LIST
77597: PUSH
77598: LD_INT 2
77600: PUSH
77601: LD_INT 4
77603: PUSH
77604: EMPTY
77605: LIST
77606: LIST
77607: PUSH
77608: LD_INT 0
77610: PUSH
77611: LD_INT 4
77613: PUSH
77614: EMPTY
77615: LIST
77616: LIST
77617: PUSH
77618: LD_INT 0
77620: PUSH
77621: LD_INT 3
77623: PUSH
77624: EMPTY
77625: LIST
77626: LIST
77627: PUSH
77628: LD_INT 1
77630: PUSH
77631: LD_INT 4
77633: PUSH
77634: EMPTY
77635: LIST
77636: LIST
77637: PUSH
77638: LD_INT 1
77640: PUSH
77641: LD_INT 5
77643: PUSH
77644: EMPTY
77645: LIST
77646: LIST
77647: PUSH
77648: LD_INT 0
77650: PUSH
77651: LD_INT 5
77653: PUSH
77654: EMPTY
77655: LIST
77656: LIST
77657: PUSH
77658: LD_INT 1
77660: NEG
77661: PUSH
77662: LD_INT 4
77664: PUSH
77665: EMPTY
77666: LIST
77667: LIST
77668: PUSH
77669: LD_INT 1
77671: NEG
77672: PUSH
77673: LD_INT 3
77675: PUSH
77676: EMPTY
77677: LIST
77678: LIST
77679: PUSH
77680: LD_INT 2
77682: PUSH
77683: LD_INT 5
77685: PUSH
77686: EMPTY
77687: LIST
77688: LIST
77689: PUSH
77690: LD_INT 2
77692: NEG
77693: PUSH
77694: LD_INT 3
77696: PUSH
77697: EMPTY
77698: LIST
77699: LIST
77700: PUSH
77701: EMPTY
77702: LIST
77703: LIST
77704: LIST
77705: LIST
77706: LIST
77707: LIST
77708: LIST
77709: LIST
77710: LIST
77711: LIST
77712: LIST
77713: LIST
77714: LIST
77715: LIST
77716: LIST
77717: LIST
77718: LIST
77719: LIST
77720: LIST
77721: LIST
77722: LIST
77723: LIST
77724: LIST
77725: LIST
77726: LIST
77727: LIST
77728: LIST
77729: LIST
77730: LIST
77731: LIST
77732: LIST
77733: LIST
77734: LIST
77735: LIST
77736: LIST
77737: LIST
77738: LIST
77739: LIST
77740: LIST
77741: LIST
77742: LIST
77743: LIST
77744: LIST
77745: LIST
77746: LIST
77747: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
77748: LD_ADDR_VAR 0 34
77752: PUSH
77753: LD_INT 0
77755: PUSH
77756: LD_INT 4
77758: NEG
77759: PUSH
77760: EMPTY
77761: LIST
77762: LIST
77763: PUSH
77764: LD_INT 0
77766: PUSH
77767: LD_INT 5
77769: NEG
77770: PUSH
77771: EMPTY
77772: LIST
77773: LIST
77774: PUSH
77775: LD_INT 1
77777: PUSH
77778: LD_INT 4
77780: NEG
77781: PUSH
77782: EMPTY
77783: LIST
77784: LIST
77785: PUSH
77786: LD_INT 1
77788: PUSH
77789: LD_INT 3
77791: NEG
77792: PUSH
77793: EMPTY
77794: LIST
77795: LIST
77796: PUSH
77797: LD_INT 0
77799: PUSH
77800: LD_INT 3
77802: NEG
77803: PUSH
77804: EMPTY
77805: LIST
77806: LIST
77807: PUSH
77808: LD_INT 1
77810: NEG
77811: PUSH
77812: LD_INT 4
77814: NEG
77815: PUSH
77816: EMPTY
77817: LIST
77818: LIST
77819: PUSH
77820: LD_INT 1
77822: NEG
77823: PUSH
77824: LD_INT 5
77826: NEG
77827: PUSH
77828: EMPTY
77829: LIST
77830: LIST
77831: PUSH
77832: LD_INT 2
77834: PUSH
77835: LD_INT 3
77837: NEG
77838: PUSH
77839: EMPTY
77840: LIST
77841: LIST
77842: PUSH
77843: LD_INT 2
77845: NEG
77846: PUSH
77847: LD_INT 5
77849: NEG
77850: PUSH
77851: EMPTY
77852: LIST
77853: LIST
77854: PUSH
77855: LD_INT 3
77857: PUSH
77858: LD_INT 0
77860: PUSH
77861: EMPTY
77862: LIST
77863: LIST
77864: PUSH
77865: LD_INT 3
77867: PUSH
77868: LD_INT 1
77870: NEG
77871: PUSH
77872: EMPTY
77873: LIST
77874: LIST
77875: PUSH
77876: LD_INT 4
77878: PUSH
77879: LD_INT 0
77881: PUSH
77882: EMPTY
77883: LIST
77884: LIST
77885: PUSH
77886: LD_INT 4
77888: PUSH
77889: LD_INT 1
77891: PUSH
77892: EMPTY
77893: LIST
77894: LIST
77895: PUSH
77896: LD_INT 3
77898: PUSH
77899: LD_INT 1
77901: PUSH
77902: EMPTY
77903: LIST
77904: LIST
77905: PUSH
77906: LD_INT 2
77908: PUSH
77909: LD_INT 0
77911: PUSH
77912: EMPTY
77913: LIST
77914: LIST
77915: PUSH
77916: LD_INT 2
77918: PUSH
77919: LD_INT 1
77921: NEG
77922: PUSH
77923: EMPTY
77924: LIST
77925: LIST
77926: PUSH
77927: LD_INT 2
77929: PUSH
77930: LD_INT 2
77932: NEG
77933: PUSH
77934: EMPTY
77935: LIST
77936: LIST
77937: PUSH
77938: LD_INT 4
77940: PUSH
77941: LD_INT 2
77943: PUSH
77944: EMPTY
77945: LIST
77946: LIST
77947: PUSH
77948: LD_INT 4
77950: PUSH
77951: LD_INT 4
77953: PUSH
77954: EMPTY
77955: LIST
77956: LIST
77957: PUSH
77958: LD_INT 4
77960: PUSH
77961: LD_INT 3
77963: PUSH
77964: EMPTY
77965: LIST
77966: LIST
77967: PUSH
77968: LD_INT 5
77970: PUSH
77971: LD_INT 4
77973: PUSH
77974: EMPTY
77975: LIST
77976: LIST
77977: PUSH
77978: LD_INT 5
77980: PUSH
77981: LD_INT 5
77983: PUSH
77984: EMPTY
77985: LIST
77986: LIST
77987: PUSH
77988: LD_INT 4
77990: PUSH
77991: LD_INT 5
77993: PUSH
77994: EMPTY
77995: LIST
77996: LIST
77997: PUSH
77998: LD_INT 3
78000: PUSH
78001: LD_INT 4
78003: PUSH
78004: EMPTY
78005: LIST
78006: LIST
78007: PUSH
78008: LD_INT 3
78010: PUSH
78011: LD_INT 3
78013: PUSH
78014: EMPTY
78015: LIST
78016: LIST
78017: PUSH
78018: LD_INT 5
78020: PUSH
78021: LD_INT 3
78023: PUSH
78024: EMPTY
78025: LIST
78026: LIST
78027: PUSH
78028: LD_INT 3
78030: PUSH
78031: LD_INT 5
78033: PUSH
78034: EMPTY
78035: LIST
78036: LIST
78037: PUSH
78038: LD_INT 0
78040: PUSH
78041: LD_INT 3
78043: PUSH
78044: EMPTY
78045: LIST
78046: LIST
78047: PUSH
78048: LD_INT 0
78050: PUSH
78051: LD_INT 2
78053: PUSH
78054: EMPTY
78055: LIST
78056: LIST
78057: PUSH
78058: LD_INT 1
78060: PUSH
78061: LD_INT 3
78063: PUSH
78064: EMPTY
78065: LIST
78066: LIST
78067: PUSH
78068: LD_INT 1
78070: PUSH
78071: LD_INT 4
78073: PUSH
78074: EMPTY
78075: LIST
78076: LIST
78077: PUSH
78078: LD_INT 0
78080: PUSH
78081: LD_INT 4
78083: PUSH
78084: EMPTY
78085: LIST
78086: LIST
78087: PUSH
78088: LD_INT 1
78090: NEG
78091: PUSH
78092: LD_INT 3
78094: PUSH
78095: EMPTY
78096: LIST
78097: LIST
78098: PUSH
78099: LD_INT 1
78101: NEG
78102: PUSH
78103: LD_INT 2
78105: PUSH
78106: EMPTY
78107: LIST
78108: LIST
78109: PUSH
78110: LD_INT 2
78112: PUSH
78113: LD_INT 4
78115: PUSH
78116: EMPTY
78117: LIST
78118: LIST
78119: PUSH
78120: LD_INT 2
78122: NEG
78123: PUSH
78124: LD_INT 2
78126: PUSH
78127: EMPTY
78128: LIST
78129: LIST
78130: PUSH
78131: LD_INT 4
78133: NEG
78134: PUSH
78135: LD_INT 0
78137: PUSH
78138: EMPTY
78139: LIST
78140: LIST
78141: PUSH
78142: LD_INT 4
78144: NEG
78145: PUSH
78146: LD_INT 1
78148: NEG
78149: PUSH
78150: EMPTY
78151: LIST
78152: LIST
78153: PUSH
78154: LD_INT 3
78156: NEG
78157: PUSH
78158: LD_INT 0
78160: PUSH
78161: EMPTY
78162: LIST
78163: LIST
78164: PUSH
78165: LD_INT 3
78167: NEG
78168: PUSH
78169: LD_INT 1
78171: PUSH
78172: EMPTY
78173: LIST
78174: LIST
78175: PUSH
78176: LD_INT 4
78178: NEG
78179: PUSH
78180: LD_INT 1
78182: PUSH
78183: EMPTY
78184: LIST
78185: LIST
78186: PUSH
78187: LD_INT 5
78189: NEG
78190: PUSH
78191: LD_INT 0
78193: PUSH
78194: EMPTY
78195: LIST
78196: LIST
78197: PUSH
78198: LD_INT 5
78200: NEG
78201: PUSH
78202: LD_INT 1
78204: NEG
78205: PUSH
78206: EMPTY
78207: LIST
78208: LIST
78209: PUSH
78210: LD_INT 5
78212: NEG
78213: PUSH
78214: LD_INT 2
78216: NEG
78217: PUSH
78218: EMPTY
78219: LIST
78220: LIST
78221: PUSH
78222: LD_INT 3
78224: NEG
78225: PUSH
78226: LD_INT 2
78228: PUSH
78229: EMPTY
78230: LIST
78231: LIST
78232: PUSH
78233: EMPTY
78234: LIST
78235: LIST
78236: LIST
78237: LIST
78238: LIST
78239: LIST
78240: LIST
78241: LIST
78242: LIST
78243: LIST
78244: LIST
78245: LIST
78246: LIST
78247: LIST
78248: LIST
78249: LIST
78250: LIST
78251: LIST
78252: LIST
78253: LIST
78254: LIST
78255: LIST
78256: LIST
78257: LIST
78258: LIST
78259: LIST
78260: LIST
78261: LIST
78262: LIST
78263: LIST
78264: LIST
78265: LIST
78266: LIST
78267: LIST
78268: LIST
78269: LIST
78270: LIST
78271: LIST
78272: LIST
78273: LIST
78274: LIST
78275: LIST
78276: LIST
78277: LIST
78278: LIST
78279: ST_TO_ADDR
// end ; end ;
78280: GO 78283
78282: POP
// case btype of b_depot , b_warehouse :
78283: LD_VAR 0 1
78287: PUSH
78288: LD_INT 0
78290: DOUBLE
78291: EQUAL
78292: IFTRUE 78302
78294: LD_INT 1
78296: DOUBLE
78297: EQUAL
78298: IFTRUE 78302
78300: GO 78503
78302: POP
// case nation of nation_american :
78303: LD_VAR 0 5
78307: PUSH
78308: LD_INT 1
78310: DOUBLE
78311: EQUAL
78312: IFTRUE 78316
78314: GO 78372
78316: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
78317: LD_ADDR_VAR 0 9
78321: PUSH
78322: LD_VAR 0 11
78326: PUSH
78327: LD_VAR 0 12
78331: PUSH
78332: LD_VAR 0 13
78336: PUSH
78337: LD_VAR 0 14
78341: PUSH
78342: LD_VAR 0 15
78346: PUSH
78347: LD_VAR 0 16
78351: PUSH
78352: EMPTY
78353: LIST
78354: LIST
78355: LIST
78356: LIST
78357: LIST
78358: LIST
78359: PUSH
78360: LD_VAR 0 4
78364: PUSH
78365: LD_INT 1
78367: PLUS
78368: ARRAY
78369: ST_TO_ADDR
78370: GO 78501
78372: LD_INT 2
78374: DOUBLE
78375: EQUAL
78376: IFTRUE 78380
78378: GO 78436
78380: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
78381: LD_ADDR_VAR 0 9
78385: PUSH
78386: LD_VAR 0 17
78390: PUSH
78391: LD_VAR 0 18
78395: PUSH
78396: LD_VAR 0 19
78400: PUSH
78401: LD_VAR 0 20
78405: PUSH
78406: LD_VAR 0 21
78410: PUSH
78411: LD_VAR 0 22
78415: PUSH
78416: EMPTY
78417: LIST
78418: LIST
78419: LIST
78420: LIST
78421: LIST
78422: LIST
78423: PUSH
78424: LD_VAR 0 4
78428: PUSH
78429: LD_INT 1
78431: PLUS
78432: ARRAY
78433: ST_TO_ADDR
78434: GO 78501
78436: LD_INT 3
78438: DOUBLE
78439: EQUAL
78440: IFTRUE 78444
78442: GO 78500
78444: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
78445: LD_ADDR_VAR 0 9
78449: PUSH
78450: LD_VAR 0 23
78454: PUSH
78455: LD_VAR 0 24
78459: PUSH
78460: LD_VAR 0 25
78464: PUSH
78465: LD_VAR 0 26
78469: PUSH
78470: LD_VAR 0 27
78474: PUSH
78475: LD_VAR 0 28
78479: PUSH
78480: EMPTY
78481: LIST
78482: LIST
78483: LIST
78484: LIST
78485: LIST
78486: LIST
78487: PUSH
78488: LD_VAR 0 4
78492: PUSH
78493: LD_INT 1
78495: PLUS
78496: ARRAY
78497: ST_TO_ADDR
78498: GO 78501
78500: POP
78501: GO 79056
78503: LD_INT 2
78505: DOUBLE
78506: EQUAL
78507: IFTRUE 78517
78509: LD_INT 3
78511: DOUBLE
78512: EQUAL
78513: IFTRUE 78517
78515: GO 78573
78517: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
78518: LD_ADDR_VAR 0 9
78522: PUSH
78523: LD_VAR 0 29
78527: PUSH
78528: LD_VAR 0 30
78532: PUSH
78533: LD_VAR 0 31
78537: PUSH
78538: LD_VAR 0 32
78542: PUSH
78543: LD_VAR 0 33
78547: PUSH
78548: LD_VAR 0 34
78552: PUSH
78553: EMPTY
78554: LIST
78555: LIST
78556: LIST
78557: LIST
78558: LIST
78559: LIST
78560: PUSH
78561: LD_VAR 0 4
78565: PUSH
78566: LD_INT 1
78568: PLUS
78569: ARRAY
78570: ST_TO_ADDR
78571: GO 79056
78573: LD_INT 16
78575: DOUBLE
78576: EQUAL
78577: IFTRUE 78635
78579: LD_INT 17
78581: DOUBLE
78582: EQUAL
78583: IFTRUE 78635
78585: LD_INT 18
78587: DOUBLE
78588: EQUAL
78589: IFTRUE 78635
78591: LD_INT 19
78593: DOUBLE
78594: EQUAL
78595: IFTRUE 78635
78597: LD_INT 22
78599: DOUBLE
78600: EQUAL
78601: IFTRUE 78635
78603: LD_INT 20
78605: DOUBLE
78606: EQUAL
78607: IFTRUE 78635
78609: LD_INT 21
78611: DOUBLE
78612: EQUAL
78613: IFTRUE 78635
78615: LD_INT 23
78617: DOUBLE
78618: EQUAL
78619: IFTRUE 78635
78621: LD_INT 24
78623: DOUBLE
78624: EQUAL
78625: IFTRUE 78635
78627: LD_INT 25
78629: DOUBLE
78630: EQUAL
78631: IFTRUE 78635
78633: GO 78691
78635: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
78636: LD_ADDR_VAR 0 9
78640: PUSH
78641: LD_VAR 0 35
78645: PUSH
78646: LD_VAR 0 36
78650: PUSH
78651: LD_VAR 0 37
78655: PUSH
78656: LD_VAR 0 38
78660: PUSH
78661: LD_VAR 0 39
78665: PUSH
78666: LD_VAR 0 40
78670: PUSH
78671: EMPTY
78672: LIST
78673: LIST
78674: LIST
78675: LIST
78676: LIST
78677: LIST
78678: PUSH
78679: LD_VAR 0 4
78683: PUSH
78684: LD_INT 1
78686: PLUS
78687: ARRAY
78688: ST_TO_ADDR
78689: GO 79056
78691: LD_INT 6
78693: DOUBLE
78694: EQUAL
78695: IFTRUE 78747
78697: LD_INT 7
78699: DOUBLE
78700: EQUAL
78701: IFTRUE 78747
78703: LD_INT 8
78705: DOUBLE
78706: EQUAL
78707: IFTRUE 78747
78709: LD_INT 13
78711: DOUBLE
78712: EQUAL
78713: IFTRUE 78747
78715: LD_INT 12
78717: DOUBLE
78718: EQUAL
78719: IFTRUE 78747
78721: LD_INT 15
78723: DOUBLE
78724: EQUAL
78725: IFTRUE 78747
78727: LD_INT 11
78729: DOUBLE
78730: EQUAL
78731: IFTRUE 78747
78733: LD_INT 14
78735: DOUBLE
78736: EQUAL
78737: IFTRUE 78747
78739: LD_INT 10
78741: DOUBLE
78742: EQUAL
78743: IFTRUE 78747
78745: GO 78803
78747: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
78748: LD_ADDR_VAR 0 9
78752: PUSH
78753: LD_VAR 0 41
78757: PUSH
78758: LD_VAR 0 42
78762: PUSH
78763: LD_VAR 0 43
78767: PUSH
78768: LD_VAR 0 44
78772: PUSH
78773: LD_VAR 0 45
78777: PUSH
78778: LD_VAR 0 46
78782: PUSH
78783: EMPTY
78784: LIST
78785: LIST
78786: LIST
78787: LIST
78788: LIST
78789: LIST
78790: PUSH
78791: LD_VAR 0 4
78795: PUSH
78796: LD_INT 1
78798: PLUS
78799: ARRAY
78800: ST_TO_ADDR
78801: GO 79056
78803: LD_INT 36
78805: DOUBLE
78806: EQUAL
78807: IFTRUE 78811
78809: GO 78867
78811: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
78812: LD_ADDR_VAR 0 9
78816: PUSH
78817: LD_VAR 0 47
78821: PUSH
78822: LD_VAR 0 48
78826: PUSH
78827: LD_VAR 0 49
78831: PUSH
78832: LD_VAR 0 50
78836: PUSH
78837: LD_VAR 0 51
78841: PUSH
78842: LD_VAR 0 52
78846: PUSH
78847: EMPTY
78848: LIST
78849: LIST
78850: LIST
78851: LIST
78852: LIST
78853: LIST
78854: PUSH
78855: LD_VAR 0 4
78859: PUSH
78860: LD_INT 1
78862: PLUS
78863: ARRAY
78864: ST_TO_ADDR
78865: GO 79056
78867: LD_INT 4
78869: DOUBLE
78870: EQUAL
78871: IFTRUE 78893
78873: LD_INT 5
78875: DOUBLE
78876: EQUAL
78877: IFTRUE 78893
78879: LD_INT 34
78881: DOUBLE
78882: EQUAL
78883: IFTRUE 78893
78885: LD_INT 37
78887: DOUBLE
78888: EQUAL
78889: IFTRUE 78893
78891: GO 78949
78893: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
78894: LD_ADDR_VAR 0 9
78898: PUSH
78899: LD_VAR 0 53
78903: PUSH
78904: LD_VAR 0 54
78908: PUSH
78909: LD_VAR 0 55
78913: PUSH
78914: LD_VAR 0 56
78918: PUSH
78919: LD_VAR 0 57
78923: PUSH
78924: LD_VAR 0 58
78928: PUSH
78929: EMPTY
78930: LIST
78931: LIST
78932: LIST
78933: LIST
78934: LIST
78935: LIST
78936: PUSH
78937: LD_VAR 0 4
78941: PUSH
78942: LD_INT 1
78944: PLUS
78945: ARRAY
78946: ST_TO_ADDR
78947: GO 79056
78949: LD_INT 31
78951: DOUBLE
78952: EQUAL
78953: IFTRUE 78999
78955: LD_INT 32
78957: DOUBLE
78958: EQUAL
78959: IFTRUE 78999
78961: LD_INT 33
78963: DOUBLE
78964: EQUAL
78965: IFTRUE 78999
78967: LD_INT 27
78969: DOUBLE
78970: EQUAL
78971: IFTRUE 78999
78973: LD_INT 26
78975: DOUBLE
78976: EQUAL
78977: IFTRUE 78999
78979: LD_INT 28
78981: DOUBLE
78982: EQUAL
78983: IFTRUE 78999
78985: LD_INT 29
78987: DOUBLE
78988: EQUAL
78989: IFTRUE 78999
78991: LD_INT 30
78993: DOUBLE
78994: EQUAL
78995: IFTRUE 78999
78997: GO 79055
78999: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
79000: LD_ADDR_VAR 0 9
79004: PUSH
79005: LD_VAR 0 59
79009: PUSH
79010: LD_VAR 0 60
79014: PUSH
79015: LD_VAR 0 61
79019: PUSH
79020: LD_VAR 0 62
79024: PUSH
79025: LD_VAR 0 63
79029: PUSH
79030: LD_VAR 0 64
79034: PUSH
79035: EMPTY
79036: LIST
79037: LIST
79038: LIST
79039: LIST
79040: LIST
79041: LIST
79042: PUSH
79043: LD_VAR 0 4
79047: PUSH
79048: LD_INT 1
79050: PLUS
79051: ARRAY
79052: ST_TO_ADDR
79053: GO 79056
79055: POP
// temp_list2 = [ ] ;
79056: LD_ADDR_VAR 0 10
79060: PUSH
79061: EMPTY
79062: ST_TO_ADDR
// for i in temp_list do
79063: LD_ADDR_VAR 0 8
79067: PUSH
79068: LD_VAR 0 9
79072: PUSH
79073: FOR_IN
79074: IFFALSE 79126
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
79076: LD_ADDR_VAR 0 10
79080: PUSH
79081: LD_VAR 0 10
79085: PUSH
79086: LD_VAR 0 8
79090: PUSH
79091: LD_INT 1
79093: ARRAY
79094: PUSH
79095: LD_VAR 0 2
79099: PLUS
79100: PUSH
79101: LD_VAR 0 8
79105: PUSH
79106: LD_INT 2
79108: ARRAY
79109: PUSH
79110: LD_VAR 0 3
79114: PLUS
79115: PUSH
79116: EMPTY
79117: LIST
79118: LIST
79119: PUSH
79120: EMPTY
79121: LIST
79122: ADD
79123: ST_TO_ADDR
79124: GO 79073
79126: POP
79127: POP
// result = temp_list2 ;
79128: LD_ADDR_VAR 0 7
79132: PUSH
79133: LD_VAR 0 10
79137: ST_TO_ADDR
// end ;
79138: LD_VAR 0 7
79142: RET
// export function EnemyInRange ( unit , dist ) ; begin
79143: LD_INT 0
79145: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
79146: LD_ADDR_VAR 0 3
79150: PUSH
79151: LD_VAR 0 1
79155: PPUSH
79156: CALL_OW 255
79160: PPUSH
79161: LD_VAR 0 1
79165: PPUSH
79166: CALL_OW 250
79170: PPUSH
79171: LD_VAR 0 1
79175: PPUSH
79176: CALL_OW 251
79180: PPUSH
79181: LD_VAR 0 2
79185: PPUSH
79186: CALL 53247 0 4
79190: PUSH
79191: LD_INT 4
79193: ARRAY
79194: ST_TO_ADDR
// end ;
79195: LD_VAR 0 3
79199: RET
// export function PlayerSeeMe ( unit ) ; begin
79200: LD_INT 0
79202: PPUSH
// result := See ( your_side , unit ) ;
79203: LD_ADDR_VAR 0 2
79207: PUSH
79208: LD_OWVAR 2
79212: PPUSH
79213: LD_VAR 0 1
79217: PPUSH
79218: CALL_OW 292
79222: ST_TO_ADDR
// end ;
79223: LD_VAR 0 2
79227: RET
// export function ReverseDir ( unit ) ; begin
79228: LD_INT 0
79230: PPUSH
// if not unit then
79231: LD_VAR 0 1
79235: NOT
79236: IFFALSE 79240
// exit ;
79238: GO 79263
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
79240: LD_ADDR_VAR 0 2
79244: PUSH
79245: LD_VAR 0 1
79249: PPUSH
79250: CALL_OW 254
79254: PUSH
79255: LD_INT 3
79257: PLUS
79258: PUSH
79259: LD_INT 6
79261: MOD
79262: ST_TO_ADDR
// end ;
79263: LD_VAR 0 2
79267: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
79268: LD_INT 0
79270: PPUSH
79271: PPUSH
79272: PPUSH
79273: PPUSH
79274: PPUSH
// if not hexes then
79275: LD_VAR 0 2
79279: NOT
79280: IFFALSE 79284
// exit ;
79282: GO 79432
// dist := 9999 ;
79284: LD_ADDR_VAR 0 5
79288: PUSH
79289: LD_INT 9999
79291: ST_TO_ADDR
// for i = 1 to hexes do
79292: LD_ADDR_VAR 0 4
79296: PUSH
79297: DOUBLE
79298: LD_INT 1
79300: DEC
79301: ST_TO_ADDR
79302: LD_VAR 0 2
79306: PUSH
79307: FOR_TO
79308: IFFALSE 79420
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
79310: LD_VAR 0 1
79314: PPUSH
79315: LD_VAR 0 2
79319: PUSH
79320: LD_VAR 0 4
79324: ARRAY
79325: PUSH
79326: LD_INT 1
79328: ARRAY
79329: PPUSH
79330: LD_VAR 0 2
79334: PUSH
79335: LD_VAR 0 4
79339: ARRAY
79340: PUSH
79341: LD_INT 2
79343: ARRAY
79344: PPUSH
79345: CALL_OW 297
79349: PUSH
79350: LD_VAR 0 5
79354: LESS
79355: IFFALSE 79418
// begin hex := hexes [ i ] ;
79357: LD_ADDR_VAR 0 7
79361: PUSH
79362: LD_VAR 0 2
79366: PUSH
79367: LD_VAR 0 4
79371: ARRAY
79372: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
79373: LD_ADDR_VAR 0 5
79377: PUSH
79378: LD_VAR 0 1
79382: PPUSH
79383: LD_VAR 0 2
79387: PUSH
79388: LD_VAR 0 4
79392: ARRAY
79393: PUSH
79394: LD_INT 1
79396: ARRAY
79397: PPUSH
79398: LD_VAR 0 2
79402: PUSH
79403: LD_VAR 0 4
79407: ARRAY
79408: PUSH
79409: LD_INT 2
79411: ARRAY
79412: PPUSH
79413: CALL_OW 297
79417: ST_TO_ADDR
// end ; end ;
79418: GO 79307
79420: POP
79421: POP
// result := hex ;
79422: LD_ADDR_VAR 0 3
79426: PUSH
79427: LD_VAR 0 7
79431: ST_TO_ADDR
// end ;
79432: LD_VAR 0 3
79436: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
79437: LD_INT 0
79439: PPUSH
79440: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
79441: LD_VAR 0 1
79445: NOT
79446: PUSH
79447: LD_VAR 0 1
79451: PUSH
79452: LD_INT 21
79454: PUSH
79455: LD_INT 2
79457: PUSH
79458: EMPTY
79459: LIST
79460: LIST
79461: PUSH
79462: LD_INT 23
79464: PUSH
79465: LD_INT 2
79467: PUSH
79468: EMPTY
79469: LIST
79470: LIST
79471: PUSH
79472: EMPTY
79473: LIST
79474: LIST
79475: PPUSH
79476: CALL_OW 69
79480: IN
79481: NOT
79482: OR
79483: IFFALSE 79487
// exit ;
79485: GO 79534
// for i = 1 to 3 do
79487: LD_ADDR_VAR 0 3
79491: PUSH
79492: DOUBLE
79493: LD_INT 1
79495: DEC
79496: ST_TO_ADDR
79497: LD_INT 3
79499: PUSH
79500: FOR_TO
79501: IFFALSE 79532
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
79503: LD_VAR 0 1
79507: PPUSH
79508: CALL_OW 250
79512: PPUSH
79513: LD_VAR 0 1
79517: PPUSH
79518: CALL_OW 251
79522: PPUSH
79523: LD_INT 1
79525: PPUSH
79526: CALL_OW 453
79530: GO 79500
79532: POP
79533: POP
// end ;
79534: LD_VAR 0 2
79538: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
79539: LD_INT 0
79541: PPUSH
79542: PPUSH
79543: PPUSH
79544: PPUSH
79545: PPUSH
79546: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
79547: LD_VAR 0 1
79551: NOT
79552: PUSH
79553: LD_VAR 0 2
79557: NOT
79558: OR
79559: PUSH
79560: LD_VAR 0 1
79564: PPUSH
79565: CALL_OW 314
79569: OR
79570: IFFALSE 79574
// exit ;
79572: GO 80015
// x := GetX ( enemy_unit ) ;
79574: LD_ADDR_VAR 0 7
79578: PUSH
79579: LD_VAR 0 2
79583: PPUSH
79584: CALL_OW 250
79588: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
79589: LD_ADDR_VAR 0 8
79593: PUSH
79594: LD_VAR 0 2
79598: PPUSH
79599: CALL_OW 251
79603: ST_TO_ADDR
// if not x or not y then
79604: LD_VAR 0 7
79608: NOT
79609: PUSH
79610: LD_VAR 0 8
79614: NOT
79615: OR
79616: IFFALSE 79620
// exit ;
79618: GO 80015
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
79620: LD_ADDR_VAR 0 6
79624: PUSH
79625: LD_VAR 0 7
79629: PPUSH
79630: LD_INT 0
79632: PPUSH
79633: LD_INT 4
79635: PPUSH
79636: CALL_OW 272
79640: PUSH
79641: LD_VAR 0 8
79645: PPUSH
79646: LD_INT 0
79648: PPUSH
79649: LD_INT 4
79651: PPUSH
79652: CALL_OW 273
79656: PUSH
79657: EMPTY
79658: LIST
79659: LIST
79660: PUSH
79661: LD_VAR 0 7
79665: PPUSH
79666: LD_INT 1
79668: PPUSH
79669: LD_INT 4
79671: PPUSH
79672: CALL_OW 272
79676: PUSH
79677: LD_VAR 0 8
79681: PPUSH
79682: LD_INT 1
79684: PPUSH
79685: LD_INT 4
79687: PPUSH
79688: CALL_OW 273
79692: PUSH
79693: EMPTY
79694: LIST
79695: LIST
79696: PUSH
79697: LD_VAR 0 7
79701: PPUSH
79702: LD_INT 2
79704: PPUSH
79705: LD_INT 4
79707: PPUSH
79708: CALL_OW 272
79712: PUSH
79713: LD_VAR 0 8
79717: PPUSH
79718: LD_INT 2
79720: PPUSH
79721: LD_INT 4
79723: PPUSH
79724: CALL_OW 273
79728: PUSH
79729: EMPTY
79730: LIST
79731: LIST
79732: PUSH
79733: LD_VAR 0 7
79737: PPUSH
79738: LD_INT 3
79740: PPUSH
79741: LD_INT 4
79743: PPUSH
79744: CALL_OW 272
79748: PUSH
79749: LD_VAR 0 8
79753: PPUSH
79754: LD_INT 3
79756: PPUSH
79757: LD_INT 4
79759: PPUSH
79760: CALL_OW 273
79764: PUSH
79765: EMPTY
79766: LIST
79767: LIST
79768: PUSH
79769: LD_VAR 0 7
79773: PPUSH
79774: LD_INT 4
79776: PPUSH
79777: LD_INT 4
79779: PPUSH
79780: CALL_OW 272
79784: PUSH
79785: LD_VAR 0 8
79789: PPUSH
79790: LD_INT 4
79792: PPUSH
79793: LD_INT 4
79795: PPUSH
79796: CALL_OW 273
79800: PUSH
79801: EMPTY
79802: LIST
79803: LIST
79804: PUSH
79805: LD_VAR 0 7
79809: PPUSH
79810: LD_INT 5
79812: PPUSH
79813: LD_INT 4
79815: PPUSH
79816: CALL_OW 272
79820: PUSH
79821: LD_VAR 0 8
79825: PPUSH
79826: LD_INT 5
79828: PPUSH
79829: LD_INT 4
79831: PPUSH
79832: CALL_OW 273
79836: PUSH
79837: EMPTY
79838: LIST
79839: LIST
79840: PUSH
79841: EMPTY
79842: LIST
79843: LIST
79844: LIST
79845: LIST
79846: LIST
79847: LIST
79848: ST_TO_ADDR
// for i = tmp downto 1 do
79849: LD_ADDR_VAR 0 4
79853: PUSH
79854: DOUBLE
79855: LD_VAR 0 6
79859: INC
79860: ST_TO_ADDR
79861: LD_INT 1
79863: PUSH
79864: FOR_DOWNTO
79865: IFFALSE 79966
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
79867: LD_VAR 0 6
79871: PUSH
79872: LD_VAR 0 4
79876: ARRAY
79877: PUSH
79878: LD_INT 1
79880: ARRAY
79881: PPUSH
79882: LD_VAR 0 6
79886: PUSH
79887: LD_VAR 0 4
79891: ARRAY
79892: PUSH
79893: LD_INT 2
79895: ARRAY
79896: PPUSH
79897: CALL_OW 488
79901: NOT
79902: PUSH
79903: LD_VAR 0 6
79907: PUSH
79908: LD_VAR 0 4
79912: ARRAY
79913: PUSH
79914: LD_INT 1
79916: ARRAY
79917: PPUSH
79918: LD_VAR 0 6
79922: PUSH
79923: LD_VAR 0 4
79927: ARRAY
79928: PUSH
79929: LD_INT 2
79931: ARRAY
79932: PPUSH
79933: CALL_OW 428
79937: PUSH
79938: LD_INT 0
79940: NONEQUAL
79941: OR
79942: IFFALSE 79964
// tmp := Delete ( tmp , i ) ;
79944: LD_ADDR_VAR 0 6
79948: PUSH
79949: LD_VAR 0 6
79953: PPUSH
79954: LD_VAR 0 4
79958: PPUSH
79959: CALL_OW 3
79963: ST_TO_ADDR
79964: GO 79864
79966: POP
79967: POP
// j := GetClosestHex ( unit , tmp ) ;
79968: LD_ADDR_VAR 0 5
79972: PUSH
79973: LD_VAR 0 1
79977: PPUSH
79978: LD_VAR 0 6
79982: PPUSH
79983: CALL 79268 0 2
79987: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
79988: LD_VAR 0 1
79992: PPUSH
79993: LD_VAR 0 5
79997: PUSH
79998: LD_INT 1
80000: ARRAY
80001: PPUSH
80002: LD_VAR 0 5
80006: PUSH
80007: LD_INT 2
80009: ARRAY
80010: PPUSH
80011: CALL_OW 111
// end ;
80015: LD_VAR 0 3
80019: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
80020: LD_INT 0
80022: PPUSH
80023: PPUSH
80024: PPUSH
// uc_side = 0 ;
80025: LD_ADDR_OWVAR 20
80029: PUSH
80030: LD_INT 0
80032: ST_TO_ADDR
// uc_nation = 0 ;
80033: LD_ADDR_OWVAR 21
80037: PUSH
80038: LD_INT 0
80040: ST_TO_ADDR
// InitHc ;
80041: CALL_OW 19
// InitVc ;
80045: CALL_OW 20
// if mastodonts then
80049: LD_VAR 0 6
80053: IFFALSE 80120
// for i = 1 to mastodonts do
80055: LD_ADDR_VAR 0 11
80059: PUSH
80060: DOUBLE
80061: LD_INT 1
80063: DEC
80064: ST_TO_ADDR
80065: LD_VAR 0 6
80069: PUSH
80070: FOR_TO
80071: IFFALSE 80118
// begin vc_chassis := 31 ;
80073: LD_ADDR_OWVAR 37
80077: PUSH
80078: LD_INT 31
80080: ST_TO_ADDR
// vc_control := control_rider ;
80081: LD_ADDR_OWVAR 38
80085: PUSH
80086: LD_INT 4
80088: ST_TO_ADDR
// animal := CreateVehicle ;
80089: LD_ADDR_VAR 0 12
80093: PUSH
80094: CALL_OW 45
80098: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
80099: LD_VAR 0 12
80103: PPUSH
80104: LD_VAR 0 8
80108: PPUSH
80109: LD_INT 0
80111: PPUSH
80112: CALL 82189 0 3
// end ;
80116: GO 80070
80118: POP
80119: POP
// if horses then
80120: LD_VAR 0 5
80124: IFFALSE 80191
// for i = 1 to horses do
80126: LD_ADDR_VAR 0 11
80130: PUSH
80131: DOUBLE
80132: LD_INT 1
80134: DEC
80135: ST_TO_ADDR
80136: LD_VAR 0 5
80140: PUSH
80141: FOR_TO
80142: IFFALSE 80189
// begin hc_class := 21 ;
80144: LD_ADDR_OWVAR 28
80148: PUSH
80149: LD_INT 21
80151: ST_TO_ADDR
// hc_gallery :=  ;
80152: LD_ADDR_OWVAR 33
80156: PUSH
80157: LD_STRING 
80159: ST_TO_ADDR
// animal := CreateHuman ;
80160: LD_ADDR_VAR 0 12
80164: PUSH
80165: CALL_OW 44
80169: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
80170: LD_VAR 0 12
80174: PPUSH
80175: LD_VAR 0 8
80179: PPUSH
80180: LD_INT 0
80182: PPUSH
80183: CALL 82189 0 3
// end ;
80187: GO 80141
80189: POP
80190: POP
// if birds then
80191: LD_VAR 0 1
80195: IFFALSE 80262
// for i = 1 to birds do
80197: LD_ADDR_VAR 0 11
80201: PUSH
80202: DOUBLE
80203: LD_INT 1
80205: DEC
80206: ST_TO_ADDR
80207: LD_VAR 0 1
80211: PUSH
80212: FOR_TO
80213: IFFALSE 80260
// begin hc_class = 18 ;
80215: LD_ADDR_OWVAR 28
80219: PUSH
80220: LD_INT 18
80222: ST_TO_ADDR
// hc_gallery =  ;
80223: LD_ADDR_OWVAR 33
80227: PUSH
80228: LD_STRING 
80230: ST_TO_ADDR
// animal := CreateHuman ;
80231: LD_ADDR_VAR 0 12
80235: PUSH
80236: CALL_OW 44
80240: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
80241: LD_VAR 0 12
80245: PPUSH
80246: LD_VAR 0 8
80250: PPUSH
80251: LD_INT 0
80253: PPUSH
80254: CALL 82189 0 3
// end ;
80258: GO 80212
80260: POP
80261: POP
// if tigers then
80262: LD_VAR 0 2
80266: IFFALSE 80350
// for i = 1 to tigers do
80268: LD_ADDR_VAR 0 11
80272: PUSH
80273: DOUBLE
80274: LD_INT 1
80276: DEC
80277: ST_TO_ADDR
80278: LD_VAR 0 2
80282: PUSH
80283: FOR_TO
80284: IFFALSE 80348
// begin hc_class = class_tiger ;
80286: LD_ADDR_OWVAR 28
80290: PUSH
80291: LD_INT 14
80293: ST_TO_ADDR
// hc_gallery =  ;
80294: LD_ADDR_OWVAR 33
80298: PUSH
80299: LD_STRING 
80301: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
80302: LD_ADDR_OWVAR 35
80306: PUSH
80307: LD_INT 7
80309: NEG
80310: PPUSH
80311: LD_INT 7
80313: PPUSH
80314: CALL_OW 12
80318: ST_TO_ADDR
// animal := CreateHuman ;
80319: LD_ADDR_VAR 0 12
80323: PUSH
80324: CALL_OW 44
80328: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
80329: LD_VAR 0 12
80333: PPUSH
80334: LD_VAR 0 8
80338: PPUSH
80339: LD_INT 0
80341: PPUSH
80342: CALL 82189 0 3
// end ;
80346: GO 80283
80348: POP
80349: POP
// if apemans then
80350: LD_VAR 0 3
80354: IFFALSE 80477
// for i = 1 to apemans do
80356: LD_ADDR_VAR 0 11
80360: PUSH
80361: DOUBLE
80362: LD_INT 1
80364: DEC
80365: ST_TO_ADDR
80366: LD_VAR 0 3
80370: PUSH
80371: FOR_TO
80372: IFFALSE 80475
// begin hc_class = class_apeman ;
80374: LD_ADDR_OWVAR 28
80378: PUSH
80379: LD_INT 12
80381: ST_TO_ADDR
// hc_gallery =  ;
80382: LD_ADDR_OWVAR 33
80386: PUSH
80387: LD_STRING 
80389: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
80390: LD_ADDR_OWVAR 35
80394: PUSH
80395: LD_INT 5
80397: NEG
80398: PPUSH
80399: LD_INT 5
80401: PPUSH
80402: CALL_OW 12
80406: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
80407: LD_ADDR_OWVAR 31
80411: PUSH
80412: LD_INT 1
80414: PPUSH
80415: LD_INT 3
80417: PPUSH
80418: CALL_OW 12
80422: PUSH
80423: LD_INT 1
80425: PPUSH
80426: LD_INT 3
80428: PPUSH
80429: CALL_OW 12
80433: PUSH
80434: LD_INT 0
80436: PUSH
80437: LD_INT 0
80439: PUSH
80440: EMPTY
80441: LIST
80442: LIST
80443: LIST
80444: LIST
80445: ST_TO_ADDR
// animal := CreateHuman ;
80446: LD_ADDR_VAR 0 12
80450: PUSH
80451: CALL_OW 44
80455: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
80456: LD_VAR 0 12
80460: PPUSH
80461: LD_VAR 0 8
80465: PPUSH
80466: LD_INT 0
80468: PPUSH
80469: CALL 82189 0 3
// end ;
80473: GO 80371
80475: POP
80476: POP
// if enchidnas then
80477: LD_VAR 0 4
80481: IFFALSE 80548
// for i = 1 to enchidnas do
80483: LD_ADDR_VAR 0 11
80487: PUSH
80488: DOUBLE
80489: LD_INT 1
80491: DEC
80492: ST_TO_ADDR
80493: LD_VAR 0 4
80497: PUSH
80498: FOR_TO
80499: IFFALSE 80546
// begin hc_class = 13 ;
80501: LD_ADDR_OWVAR 28
80505: PUSH
80506: LD_INT 13
80508: ST_TO_ADDR
// hc_gallery =  ;
80509: LD_ADDR_OWVAR 33
80513: PUSH
80514: LD_STRING 
80516: ST_TO_ADDR
// animal := CreateHuman ;
80517: LD_ADDR_VAR 0 12
80521: PUSH
80522: CALL_OW 44
80526: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
80527: LD_VAR 0 12
80531: PPUSH
80532: LD_VAR 0 8
80536: PPUSH
80537: LD_INT 0
80539: PPUSH
80540: CALL 82189 0 3
// end ;
80544: GO 80498
80546: POP
80547: POP
// if fishes then
80548: LD_VAR 0 7
80552: IFFALSE 80619
// for i = 1 to fishes do
80554: LD_ADDR_VAR 0 11
80558: PUSH
80559: DOUBLE
80560: LD_INT 1
80562: DEC
80563: ST_TO_ADDR
80564: LD_VAR 0 7
80568: PUSH
80569: FOR_TO
80570: IFFALSE 80617
// begin hc_class = 20 ;
80572: LD_ADDR_OWVAR 28
80576: PUSH
80577: LD_INT 20
80579: ST_TO_ADDR
// hc_gallery =  ;
80580: LD_ADDR_OWVAR 33
80584: PUSH
80585: LD_STRING 
80587: ST_TO_ADDR
// animal := CreateHuman ;
80588: LD_ADDR_VAR 0 12
80592: PUSH
80593: CALL_OW 44
80597: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
80598: LD_VAR 0 12
80602: PPUSH
80603: LD_VAR 0 9
80607: PPUSH
80608: LD_INT 0
80610: PPUSH
80611: CALL 82189 0 3
// end ;
80615: GO 80569
80617: POP
80618: POP
// end ;
80619: LD_VAR 0 10
80623: RET
// export function WantHeal ( sci , unit ) ; begin
80624: LD_INT 0
80626: PPUSH
// if GetTaskList ( sci ) > 0 then
80627: LD_VAR 0 1
80631: PPUSH
80632: CALL_OW 437
80636: PUSH
80637: LD_INT 0
80639: GREATER
80640: IFFALSE 80710
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
80642: LD_VAR 0 1
80646: PPUSH
80647: CALL_OW 437
80651: PUSH
80652: LD_INT 1
80654: ARRAY
80655: PUSH
80656: LD_INT 1
80658: ARRAY
80659: PUSH
80660: LD_STRING l
80662: EQUAL
80663: PUSH
80664: LD_VAR 0 1
80668: PPUSH
80669: CALL_OW 437
80673: PUSH
80674: LD_INT 1
80676: ARRAY
80677: PUSH
80678: LD_INT 4
80680: ARRAY
80681: PUSH
80682: LD_VAR 0 2
80686: EQUAL
80687: AND
80688: IFFALSE 80700
// result := true else
80690: LD_ADDR_VAR 0 3
80694: PUSH
80695: LD_INT 1
80697: ST_TO_ADDR
80698: GO 80708
// result := false ;
80700: LD_ADDR_VAR 0 3
80704: PUSH
80705: LD_INT 0
80707: ST_TO_ADDR
// end else
80708: GO 80718
// result := false ;
80710: LD_ADDR_VAR 0 3
80714: PUSH
80715: LD_INT 0
80717: ST_TO_ADDR
// end ;
80718: LD_VAR 0 3
80722: RET
// export function HealTarget ( sci ) ; begin
80723: LD_INT 0
80725: PPUSH
// if not sci then
80726: LD_VAR 0 1
80730: NOT
80731: IFFALSE 80735
// exit ;
80733: GO 80800
// result := 0 ;
80735: LD_ADDR_VAR 0 2
80739: PUSH
80740: LD_INT 0
80742: ST_TO_ADDR
// if GetTaskList ( sci ) then
80743: LD_VAR 0 1
80747: PPUSH
80748: CALL_OW 437
80752: IFFALSE 80800
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
80754: LD_VAR 0 1
80758: PPUSH
80759: CALL_OW 437
80763: PUSH
80764: LD_INT 1
80766: ARRAY
80767: PUSH
80768: LD_INT 1
80770: ARRAY
80771: PUSH
80772: LD_STRING l
80774: EQUAL
80775: IFFALSE 80800
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
80777: LD_ADDR_VAR 0 2
80781: PUSH
80782: LD_VAR 0 1
80786: PPUSH
80787: CALL_OW 437
80791: PUSH
80792: LD_INT 1
80794: ARRAY
80795: PUSH
80796: LD_INT 4
80798: ARRAY
80799: ST_TO_ADDR
// end ;
80800: LD_VAR 0 2
80804: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
80805: LD_INT 0
80807: PPUSH
80808: PPUSH
80809: PPUSH
80810: PPUSH
// if not base_units then
80811: LD_VAR 0 1
80815: NOT
80816: IFFALSE 80820
// exit ;
80818: GO 80907
// result := false ;
80820: LD_ADDR_VAR 0 2
80824: PUSH
80825: LD_INT 0
80827: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
80828: LD_ADDR_VAR 0 5
80832: PUSH
80833: LD_VAR 0 1
80837: PPUSH
80838: LD_INT 21
80840: PUSH
80841: LD_INT 3
80843: PUSH
80844: EMPTY
80845: LIST
80846: LIST
80847: PPUSH
80848: CALL_OW 72
80852: ST_TO_ADDR
// if not tmp then
80853: LD_VAR 0 5
80857: NOT
80858: IFFALSE 80862
// exit ;
80860: GO 80907
// for i in tmp do
80862: LD_ADDR_VAR 0 3
80866: PUSH
80867: LD_VAR 0 5
80871: PUSH
80872: FOR_IN
80873: IFFALSE 80905
// begin result := EnemyInRange ( i , 22 ) ;
80875: LD_ADDR_VAR 0 2
80879: PUSH
80880: LD_VAR 0 3
80884: PPUSH
80885: LD_INT 22
80887: PPUSH
80888: CALL 79143 0 2
80892: ST_TO_ADDR
// if result then
80893: LD_VAR 0 2
80897: IFFALSE 80903
// exit ;
80899: POP
80900: POP
80901: GO 80907
// end ;
80903: GO 80872
80905: POP
80906: POP
// end ;
80907: LD_VAR 0 2
80911: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
80912: LD_INT 0
80914: PPUSH
80915: PPUSH
// if not units then
80916: LD_VAR 0 1
80920: NOT
80921: IFFALSE 80925
// exit ;
80923: GO 80995
// result := [ ] ;
80925: LD_ADDR_VAR 0 3
80929: PUSH
80930: EMPTY
80931: ST_TO_ADDR
// for i in units do
80932: LD_ADDR_VAR 0 4
80936: PUSH
80937: LD_VAR 0 1
80941: PUSH
80942: FOR_IN
80943: IFFALSE 80993
// if GetTag ( i ) = tag then
80945: LD_VAR 0 4
80949: PPUSH
80950: CALL_OW 110
80954: PUSH
80955: LD_VAR 0 2
80959: EQUAL
80960: IFFALSE 80991
// result := Insert ( result , result + 1 , i ) ;
80962: LD_ADDR_VAR 0 3
80966: PUSH
80967: LD_VAR 0 3
80971: PPUSH
80972: LD_VAR 0 3
80976: PUSH
80977: LD_INT 1
80979: PLUS
80980: PPUSH
80981: LD_VAR 0 4
80985: PPUSH
80986: CALL_OW 2
80990: ST_TO_ADDR
80991: GO 80942
80993: POP
80994: POP
// end ;
80995: LD_VAR 0 3
80999: RET
// export function IsDriver ( un ) ; begin
81000: LD_INT 0
81002: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
81003: LD_ADDR_VAR 0 2
81007: PUSH
81008: LD_VAR 0 1
81012: PUSH
81013: LD_INT 55
81015: PUSH
81016: EMPTY
81017: LIST
81018: PPUSH
81019: CALL_OW 69
81023: IN
81024: ST_TO_ADDR
// end ;
81025: LD_VAR 0 2
81029: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
81030: LD_INT 0
81032: PPUSH
81033: PPUSH
// list := [ ] ;
81034: LD_ADDR_VAR 0 5
81038: PUSH
81039: EMPTY
81040: ST_TO_ADDR
// case d of 0 :
81041: LD_VAR 0 3
81045: PUSH
81046: LD_INT 0
81048: DOUBLE
81049: EQUAL
81050: IFTRUE 81054
81052: GO 81187
81054: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
81055: LD_ADDR_VAR 0 5
81059: PUSH
81060: LD_VAR 0 1
81064: PUSH
81065: LD_INT 4
81067: MINUS
81068: PUSH
81069: LD_VAR 0 2
81073: PUSH
81074: LD_INT 4
81076: MINUS
81077: PUSH
81078: LD_INT 2
81080: PUSH
81081: EMPTY
81082: LIST
81083: LIST
81084: LIST
81085: PUSH
81086: LD_VAR 0 1
81090: PUSH
81091: LD_INT 3
81093: MINUS
81094: PUSH
81095: LD_VAR 0 2
81099: PUSH
81100: LD_INT 1
81102: PUSH
81103: EMPTY
81104: LIST
81105: LIST
81106: LIST
81107: PUSH
81108: LD_VAR 0 1
81112: PUSH
81113: LD_INT 4
81115: PLUS
81116: PUSH
81117: LD_VAR 0 2
81121: PUSH
81122: LD_INT 4
81124: PUSH
81125: EMPTY
81126: LIST
81127: LIST
81128: LIST
81129: PUSH
81130: LD_VAR 0 1
81134: PUSH
81135: LD_INT 3
81137: PLUS
81138: PUSH
81139: LD_VAR 0 2
81143: PUSH
81144: LD_INT 3
81146: PLUS
81147: PUSH
81148: LD_INT 5
81150: PUSH
81151: EMPTY
81152: LIST
81153: LIST
81154: LIST
81155: PUSH
81156: LD_VAR 0 1
81160: PUSH
81161: LD_VAR 0 2
81165: PUSH
81166: LD_INT 4
81168: PLUS
81169: PUSH
81170: LD_INT 0
81172: PUSH
81173: EMPTY
81174: LIST
81175: LIST
81176: LIST
81177: PUSH
81178: EMPTY
81179: LIST
81180: LIST
81181: LIST
81182: LIST
81183: LIST
81184: ST_TO_ADDR
// end ; 1 :
81185: GO 81885
81187: LD_INT 1
81189: DOUBLE
81190: EQUAL
81191: IFTRUE 81195
81193: GO 81328
81195: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
81196: LD_ADDR_VAR 0 5
81200: PUSH
81201: LD_VAR 0 1
81205: PUSH
81206: LD_VAR 0 2
81210: PUSH
81211: LD_INT 4
81213: MINUS
81214: PUSH
81215: LD_INT 3
81217: PUSH
81218: EMPTY
81219: LIST
81220: LIST
81221: LIST
81222: PUSH
81223: LD_VAR 0 1
81227: PUSH
81228: LD_INT 3
81230: MINUS
81231: PUSH
81232: LD_VAR 0 2
81236: PUSH
81237: LD_INT 3
81239: MINUS
81240: PUSH
81241: LD_INT 2
81243: PUSH
81244: EMPTY
81245: LIST
81246: LIST
81247: LIST
81248: PUSH
81249: LD_VAR 0 1
81253: PUSH
81254: LD_INT 4
81256: MINUS
81257: PUSH
81258: LD_VAR 0 2
81262: PUSH
81263: LD_INT 1
81265: PUSH
81266: EMPTY
81267: LIST
81268: LIST
81269: LIST
81270: PUSH
81271: LD_VAR 0 1
81275: PUSH
81276: LD_VAR 0 2
81280: PUSH
81281: LD_INT 3
81283: PLUS
81284: PUSH
81285: LD_INT 0
81287: PUSH
81288: EMPTY
81289: LIST
81290: LIST
81291: LIST
81292: PUSH
81293: LD_VAR 0 1
81297: PUSH
81298: LD_INT 4
81300: PLUS
81301: PUSH
81302: LD_VAR 0 2
81306: PUSH
81307: LD_INT 4
81309: PLUS
81310: PUSH
81311: LD_INT 5
81313: PUSH
81314: EMPTY
81315: LIST
81316: LIST
81317: LIST
81318: PUSH
81319: EMPTY
81320: LIST
81321: LIST
81322: LIST
81323: LIST
81324: LIST
81325: ST_TO_ADDR
// end ; 2 :
81326: GO 81885
81328: LD_INT 2
81330: DOUBLE
81331: EQUAL
81332: IFTRUE 81336
81334: GO 81465
81336: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
81337: LD_ADDR_VAR 0 5
81341: PUSH
81342: LD_VAR 0 1
81346: PUSH
81347: LD_VAR 0 2
81351: PUSH
81352: LD_INT 3
81354: MINUS
81355: PUSH
81356: LD_INT 3
81358: PUSH
81359: EMPTY
81360: LIST
81361: LIST
81362: LIST
81363: PUSH
81364: LD_VAR 0 1
81368: PUSH
81369: LD_INT 4
81371: PLUS
81372: PUSH
81373: LD_VAR 0 2
81377: PUSH
81378: LD_INT 4
81380: PUSH
81381: EMPTY
81382: LIST
81383: LIST
81384: LIST
81385: PUSH
81386: LD_VAR 0 1
81390: PUSH
81391: LD_VAR 0 2
81395: PUSH
81396: LD_INT 4
81398: PLUS
81399: PUSH
81400: LD_INT 0
81402: PUSH
81403: EMPTY
81404: LIST
81405: LIST
81406: LIST
81407: PUSH
81408: LD_VAR 0 1
81412: PUSH
81413: LD_INT 3
81415: MINUS
81416: PUSH
81417: LD_VAR 0 2
81421: PUSH
81422: LD_INT 1
81424: PUSH
81425: EMPTY
81426: LIST
81427: LIST
81428: LIST
81429: PUSH
81430: LD_VAR 0 1
81434: PUSH
81435: LD_INT 4
81437: MINUS
81438: PUSH
81439: LD_VAR 0 2
81443: PUSH
81444: LD_INT 4
81446: MINUS
81447: PUSH
81448: LD_INT 2
81450: PUSH
81451: EMPTY
81452: LIST
81453: LIST
81454: LIST
81455: PUSH
81456: EMPTY
81457: LIST
81458: LIST
81459: LIST
81460: LIST
81461: LIST
81462: ST_TO_ADDR
// end ; 3 :
81463: GO 81885
81465: LD_INT 3
81467: DOUBLE
81468: EQUAL
81469: IFTRUE 81473
81471: GO 81606
81473: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
81474: LD_ADDR_VAR 0 5
81478: PUSH
81479: LD_VAR 0 1
81483: PUSH
81484: LD_INT 3
81486: PLUS
81487: PUSH
81488: LD_VAR 0 2
81492: PUSH
81493: LD_INT 4
81495: PUSH
81496: EMPTY
81497: LIST
81498: LIST
81499: LIST
81500: PUSH
81501: LD_VAR 0 1
81505: PUSH
81506: LD_INT 4
81508: PLUS
81509: PUSH
81510: LD_VAR 0 2
81514: PUSH
81515: LD_INT 4
81517: PLUS
81518: PUSH
81519: LD_INT 5
81521: PUSH
81522: EMPTY
81523: LIST
81524: LIST
81525: LIST
81526: PUSH
81527: LD_VAR 0 1
81531: PUSH
81532: LD_INT 4
81534: MINUS
81535: PUSH
81536: LD_VAR 0 2
81540: PUSH
81541: LD_INT 1
81543: PUSH
81544: EMPTY
81545: LIST
81546: LIST
81547: LIST
81548: PUSH
81549: LD_VAR 0 1
81553: PUSH
81554: LD_VAR 0 2
81558: PUSH
81559: LD_INT 4
81561: MINUS
81562: PUSH
81563: LD_INT 3
81565: PUSH
81566: EMPTY
81567: LIST
81568: LIST
81569: LIST
81570: PUSH
81571: LD_VAR 0 1
81575: PUSH
81576: LD_INT 3
81578: MINUS
81579: PUSH
81580: LD_VAR 0 2
81584: PUSH
81585: LD_INT 3
81587: MINUS
81588: PUSH
81589: LD_INT 2
81591: PUSH
81592: EMPTY
81593: LIST
81594: LIST
81595: LIST
81596: PUSH
81597: EMPTY
81598: LIST
81599: LIST
81600: LIST
81601: LIST
81602: LIST
81603: ST_TO_ADDR
// end ; 4 :
81604: GO 81885
81606: LD_INT 4
81608: DOUBLE
81609: EQUAL
81610: IFTRUE 81614
81612: GO 81747
81614: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
81615: LD_ADDR_VAR 0 5
81619: PUSH
81620: LD_VAR 0 1
81624: PUSH
81625: LD_VAR 0 2
81629: PUSH
81630: LD_INT 4
81632: PLUS
81633: PUSH
81634: LD_INT 0
81636: PUSH
81637: EMPTY
81638: LIST
81639: LIST
81640: LIST
81641: PUSH
81642: LD_VAR 0 1
81646: PUSH
81647: LD_INT 3
81649: PLUS
81650: PUSH
81651: LD_VAR 0 2
81655: PUSH
81656: LD_INT 3
81658: PLUS
81659: PUSH
81660: LD_INT 5
81662: PUSH
81663: EMPTY
81664: LIST
81665: LIST
81666: LIST
81667: PUSH
81668: LD_VAR 0 1
81672: PUSH
81673: LD_INT 4
81675: PLUS
81676: PUSH
81677: LD_VAR 0 2
81681: PUSH
81682: LD_INT 4
81684: PUSH
81685: EMPTY
81686: LIST
81687: LIST
81688: LIST
81689: PUSH
81690: LD_VAR 0 1
81694: PUSH
81695: LD_VAR 0 2
81699: PUSH
81700: LD_INT 3
81702: MINUS
81703: PUSH
81704: LD_INT 3
81706: PUSH
81707: EMPTY
81708: LIST
81709: LIST
81710: LIST
81711: PUSH
81712: LD_VAR 0 1
81716: PUSH
81717: LD_INT 4
81719: MINUS
81720: PUSH
81721: LD_VAR 0 2
81725: PUSH
81726: LD_INT 4
81728: MINUS
81729: PUSH
81730: LD_INT 2
81732: PUSH
81733: EMPTY
81734: LIST
81735: LIST
81736: LIST
81737: PUSH
81738: EMPTY
81739: LIST
81740: LIST
81741: LIST
81742: LIST
81743: LIST
81744: ST_TO_ADDR
// end ; 5 :
81745: GO 81885
81747: LD_INT 5
81749: DOUBLE
81750: EQUAL
81751: IFTRUE 81755
81753: GO 81884
81755: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
81756: LD_ADDR_VAR 0 5
81760: PUSH
81761: LD_VAR 0 1
81765: PUSH
81766: LD_INT 4
81768: MINUS
81769: PUSH
81770: LD_VAR 0 2
81774: PUSH
81775: LD_INT 1
81777: PUSH
81778: EMPTY
81779: LIST
81780: LIST
81781: LIST
81782: PUSH
81783: LD_VAR 0 1
81787: PUSH
81788: LD_VAR 0 2
81792: PUSH
81793: LD_INT 4
81795: MINUS
81796: PUSH
81797: LD_INT 3
81799: PUSH
81800: EMPTY
81801: LIST
81802: LIST
81803: LIST
81804: PUSH
81805: LD_VAR 0 1
81809: PUSH
81810: LD_INT 4
81812: PLUS
81813: PUSH
81814: LD_VAR 0 2
81818: PUSH
81819: LD_INT 4
81821: PLUS
81822: PUSH
81823: LD_INT 5
81825: PUSH
81826: EMPTY
81827: LIST
81828: LIST
81829: LIST
81830: PUSH
81831: LD_VAR 0 1
81835: PUSH
81836: LD_INT 3
81838: PLUS
81839: PUSH
81840: LD_VAR 0 2
81844: PUSH
81845: LD_INT 4
81847: PUSH
81848: EMPTY
81849: LIST
81850: LIST
81851: LIST
81852: PUSH
81853: LD_VAR 0 1
81857: PUSH
81858: LD_VAR 0 2
81862: PUSH
81863: LD_INT 3
81865: PLUS
81866: PUSH
81867: LD_INT 0
81869: PUSH
81870: EMPTY
81871: LIST
81872: LIST
81873: LIST
81874: PUSH
81875: EMPTY
81876: LIST
81877: LIST
81878: LIST
81879: LIST
81880: LIST
81881: ST_TO_ADDR
// end ; end ;
81882: GO 81885
81884: POP
// result := list ;
81885: LD_ADDR_VAR 0 4
81889: PUSH
81890: LD_VAR 0 5
81894: ST_TO_ADDR
// end ;
81895: LD_VAR 0 4
81899: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
81900: LD_INT 0
81902: PPUSH
81903: PPUSH
81904: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
81905: LD_VAR 0 1
81909: NOT
81910: PUSH
81911: LD_VAR 0 2
81915: PUSH
81916: LD_INT 1
81918: PUSH
81919: LD_INT 2
81921: PUSH
81922: LD_INT 3
81924: PUSH
81925: LD_INT 4
81927: PUSH
81928: EMPTY
81929: LIST
81930: LIST
81931: LIST
81932: LIST
81933: IN
81934: NOT
81935: OR
81936: IFFALSE 81940
// exit ;
81938: GO 82032
// tmp := [ ] ;
81940: LD_ADDR_VAR 0 5
81944: PUSH
81945: EMPTY
81946: ST_TO_ADDR
// for i in units do
81947: LD_ADDR_VAR 0 4
81951: PUSH
81952: LD_VAR 0 1
81956: PUSH
81957: FOR_IN
81958: IFFALSE 82001
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
81960: LD_ADDR_VAR 0 5
81964: PUSH
81965: LD_VAR 0 5
81969: PPUSH
81970: LD_VAR 0 5
81974: PUSH
81975: LD_INT 1
81977: PLUS
81978: PPUSH
81979: LD_VAR 0 4
81983: PPUSH
81984: LD_VAR 0 2
81988: PPUSH
81989: CALL_OW 259
81993: PPUSH
81994: CALL_OW 2
81998: ST_TO_ADDR
81999: GO 81957
82001: POP
82002: POP
// if not tmp then
82003: LD_VAR 0 5
82007: NOT
82008: IFFALSE 82012
// exit ;
82010: GO 82032
// result := SortListByListDesc ( units , tmp ) ;
82012: LD_ADDR_VAR 0 3
82016: PUSH
82017: LD_VAR 0 1
82021: PPUSH
82022: LD_VAR 0 5
82026: PPUSH
82027: CALL_OW 77
82031: ST_TO_ADDR
// end ;
82032: LD_VAR 0 3
82036: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
82037: LD_INT 0
82039: PPUSH
82040: PPUSH
82041: PPUSH
// x := GetX ( building ) ;
82042: LD_ADDR_VAR 0 4
82046: PUSH
82047: LD_VAR 0 2
82051: PPUSH
82052: CALL_OW 250
82056: ST_TO_ADDR
// y := GetY ( building ) ;
82057: LD_ADDR_VAR 0 5
82061: PUSH
82062: LD_VAR 0 2
82066: PPUSH
82067: CALL_OW 251
82071: ST_TO_ADDR
// if GetTaskList ( unit ) then
82072: LD_VAR 0 1
82076: PPUSH
82077: CALL_OW 437
82081: IFFALSE 82176
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
82083: LD_STRING e
82085: PUSH
82086: LD_VAR 0 1
82090: PPUSH
82091: CALL_OW 437
82095: PUSH
82096: LD_INT 1
82098: ARRAY
82099: PUSH
82100: LD_INT 1
82102: ARRAY
82103: EQUAL
82104: PUSH
82105: LD_VAR 0 4
82109: PUSH
82110: LD_VAR 0 1
82114: PPUSH
82115: CALL_OW 437
82119: PUSH
82120: LD_INT 1
82122: ARRAY
82123: PUSH
82124: LD_INT 2
82126: ARRAY
82127: EQUAL
82128: AND
82129: PUSH
82130: LD_VAR 0 5
82134: PUSH
82135: LD_VAR 0 1
82139: PPUSH
82140: CALL_OW 437
82144: PUSH
82145: LD_INT 1
82147: ARRAY
82148: PUSH
82149: LD_INT 3
82151: ARRAY
82152: EQUAL
82153: AND
82154: IFFALSE 82166
// result := true else
82156: LD_ADDR_VAR 0 3
82160: PUSH
82161: LD_INT 1
82163: ST_TO_ADDR
82164: GO 82174
// result := false ;
82166: LD_ADDR_VAR 0 3
82170: PUSH
82171: LD_INT 0
82173: ST_TO_ADDR
// end else
82174: GO 82184
// result := false ;
82176: LD_ADDR_VAR 0 3
82180: PUSH
82181: LD_INT 0
82183: ST_TO_ADDR
// end ;
82184: LD_VAR 0 3
82188: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
82189: LD_INT 0
82191: PPUSH
82192: PPUSH
82193: PPUSH
82194: PPUSH
// if not unit or not area then
82195: LD_VAR 0 1
82199: NOT
82200: PUSH
82201: LD_VAR 0 2
82205: NOT
82206: OR
82207: IFFALSE 82211
// exit ;
82209: GO 82375
// tmp := AreaToList ( area , i ) ;
82211: LD_ADDR_VAR 0 6
82215: PUSH
82216: LD_VAR 0 2
82220: PPUSH
82221: LD_VAR 0 5
82225: PPUSH
82226: CALL_OW 517
82230: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
82231: LD_ADDR_VAR 0 5
82235: PUSH
82236: DOUBLE
82237: LD_INT 1
82239: DEC
82240: ST_TO_ADDR
82241: LD_VAR 0 6
82245: PUSH
82246: LD_INT 1
82248: ARRAY
82249: PUSH
82250: FOR_TO
82251: IFFALSE 82373
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
82253: LD_ADDR_VAR 0 7
82257: PUSH
82258: LD_VAR 0 6
82262: PUSH
82263: LD_INT 1
82265: ARRAY
82266: PUSH
82267: LD_VAR 0 5
82271: ARRAY
82272: PUSH
82273: LD_VAR 0 6
82277: PUSH
82278: LD_INT 2
82280: ARRAY
82281: PUSH
82282: LD_VAR 0 5
82286: ARRAY
82287: PUSH
82288: EMPTY
82289: LIST
82290: LIST
82291: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
82292: LD_VAR 0 7
82296: PUSH
82297: LD_INT 1
82299: ARRAY
82300: PPUSH
82301: LD_VAR 0 7
82305: PUSH
82306: LD_INT 2
82308: ARRAY
82309: PPUSH
82310: CALL_OW 428
82314: PUSH
82315: LD_INT 0
82317: EQUAL
82318: IFFALSE 82371
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
82320: LD_VAR 0 1
82324: PPUSH
82325: LD_VAR 0 7
82329: PUSH
82330: LD_INT 1
82332: ARRAY
82333: PPUSH
82334: LD_VAR 0 7
82338: PUSH
82339: LD_INT 2
82341: ARRAY
82342: PPUSH
82343: LD_VAR 0 3
82347: PPUSH
82348: CALL_OW 48
// result := IsPlaced ( unit ) ;
82352: LD_ADDR_VAR 0 4
82356: PUSH
82357: LD_VAR 0 1
82361: PPUSH
82362: CALL_OW 305
82366: ST_TO_ADDR
// exit ;
82367: POP
82368: POP
82369: GO 82375
// end ; end ;
82371: GO 82250
82373: POP
82374: POP
// end ;
82375: LD_VAR 0 4
82379: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
82380: LD_INT 0
82382: PPUSH
82383: PPUSH
82384: PPUSH
// if not side or side > 8 then
82385: LD_VAR 0 1
82389: NOT
82390: PUSH
82391: LD_VAR 0 1
82395: PUSH
82396: LD_INT 8
82398: GREATER
82399: OR
82400: IFFALSE 82404
// exit ;
82402: GO 82591
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
82404: LD_ADDR_VAR 0 4
82408: PUSH
82409: LD_INT 22
82411: PUSH
82412: LD_VAR 0 1
82416: PUSH
82417: EMPTY
82418: LIST
82419: LIST
82420: PUSH
82421: LD_INT 21
82423: PUSH
82424: LD_INT 3
82426: PUSH
82427: EMPTY
82428: LIST
82429: LIST
82430: PUSH
82431: EMPTY
82432: LIST
82433: LIST
82434: PPUSH
82435: CALL_OW 69
82439: ST_TO_ADDR
// if not tmp then
82440: LD_VAR 0 4
82444: NOT
82445: IFFALSE 82449
// exit ;
82447: GO 82591
// enable_addtolog := true ;
82449: LD_ADDR_OWVAR 81
82453: PUSH
82454: LD_INT 1
82456: ST_TO_ADDR
// AddToLog ( [ ) ;
82457: LD_STRING [
82459: PPUSH
82460: CALL_OW 561
// for i in tmp do
82464: LD_ADDR_VAR 0 3
82468: PUSH
82469: LD_VAR 0 4
82473: PUSH
82474: FOR_IN
82475: IFFALSE 82582
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
82477: LD_STRING [
82479: PUSH
82480: LD_VAR 0 3
82484: PPUSH
82485: CALL_OW 266
82489: STR
82490: PUSH
82491: LD_STRING , 
82493: STR
82494: PUSH
82495: LD_VAR 0 3
82499: PPUSH
82500: CALL_OW 250
82504: STR
82505: PUSH
82506: LD_STRING , 
82508: STR
82509: PUSH
82510: LD_VAR 0 3
82514: PPUSH
82515: CALL_OW 251
82519: STR
82520: PUSH
82521: LD_STRING , 
82523: STR
82524: PUSH
82525: LD_VAR 0 3
82529: PPUSH
82530: CALL_OW 254
82534: STR
82535: PUSH
82536: LD_STRING , 
82538: STR
82539: PUSH
82540: LD_VAR 0 3
82544: PPUSH
82545: LD_INT 1
82547: PPUSH
82548: CALL_OW 268
82552: STR
82553: PUSH
82554: LD_STRING , 
82556: STR
82557: PUSH
82558: LD_VAR 0 3
82562: PPUSH
82563: LD_INT 2
82565: PPUSH
82566: CALL_OW 268
82570: STR
82571: PUSH
82572: LD_STRING ],
82574: STR
82575: PPUSH
82576: CALL_OW 561
// end ;
82580: GO 82474
82582: POP
82583: POP
// AddToLog ( ]; ) ;
82584: LD_STRING ];
82586: PPUSH
82587: CALL_OW 561
// end ;
82591: LD_VAR 0 2
82595: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
82596: LD_INT 0
82598: PPUSH
82599: PPUSH
82600: PPUSH
82601: PPUSH
82602: PPUSH
// if not area or not rate or not max then
82603: LD_VAR 0 1
82607: NOT
82608: PUSH
82609: LD_VAR 0 2
82613: NOT
82614: OR
82615: PUSH
82616: LD_VAR 0 4
82620: NOT
82621: OR
82622: IFFALSE 82626
// exit ;
82624: GO 82818
// while 1 do
82626: LD_INT 1
82628: IFFALSE 82818
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
82630: LD_ADDR_VAR 0 9
82634: PUSH
82635: LD_VAR 0 1
82639: PPUSH
82640: LD_INT 1
82642: PPUSH
82643: CALL_OW 287
82647: PUSH
82648: LD_INT 10
82650: MUL
82651: ST_TO_ADDR
// r := rate / 10 ;
82652: LD_ADDR_VAR 0 7
82656: PUSH
82657: LD_VAR 0 2
82661: PUSH
82662: LD_INT 10
82664: DIVREAL
82665: ST_TO_ADDR
// time := 1 1$00 ;
82666: LD_ADDR_VAR 0 8
82670: PUSH
82671: LD_INT 2100
82673: ST_TO_ADDR
// if amount < min then
82674: LD_VAR 0 9
82678: PUSH
82679: LD_VAR 0 3
82683: LESS
82684: IFFALSE 82702
// r := r * 2 else
82686: LD_ADDR_VAR 0 7
82690: PUSH
82691: LD_VAR 0 7
82695: PUSH
82696: LD_INT 2
82698: MUL
82699: ST_TO_ADDR
82700: GO 82728
// if amount > max then
82702: LD_VAR 0 9
82706: PUSH
82707: LD_VAR 0 4
82711: GREATER
82712: IFFALSE 82728
// r := r / 2 ;
82714: LD_ADDR_VAR 0 7
82718: PUSH
82719: LD_VAR 0 7
82723: PUSH
82724: LD_INT 2
82726: DIVREAL
82727: ST_TO_ADDR
// time := time / r ;
82728: LD_ADDR_VAR 0 8
82732: PUSH
82733: LD_VAR 0 8
82737: PUSH
82738: LD_VAR 0 7
82742: DIVREAL
82743: ST_TO_ADDR
// if time < 0 then
82744: LD_VAR 0 8
82748: PUSH
82749: LD_INT 0
82751: LESS
82752: IFFALSE 82769
// time := time * - 1 ;
82754: LD_ADDR_VAR 0 8
82758: PUSH
82759: LD_VAR 0 8
82763: PUSH
82764: LD_INT 1
82766: NEG
82767: MUL
82768: ST_TO_ADDR
// wait ( time ) ;
82769: LD_VAR 0 8
82773: PPUSH
82774: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
82778: LD_INT 35
82780: PPUSH
82781: LD_INT 875
82783: PPUSH
82784: CALL_OW 12
82788: PPUSH
82789: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
82793: LD_INT 1
82795: PPUSH
82796: LD_INT 5
82798: PPUSH
82799: CALL_OW 12
82803: PPUSH
82804: LD_VAR 0 1
82808: PPUSH
82809: LD_INT 1
82811: PPUSH
82812: CALL_OW 55
// end ;
82816: GO 82626
// end ;
82818: LD_VAR 0 5
82822: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
82823: LD_INT 0
82825: PPUSH
82826: PPUSH
82827: PPUSH
82828: PPUSH
82829: PPUSH
82830: PPUSH
82831: PPUSH
82832: PPUSH
// if not turrets or not factories then
82833: LD_VAR 0 1
82837: NOT
82838: PUSH
82839: LD_VAR 0 2
82843: NOT
82844: OR
82845: IFFALSE 82849
// exit ;
82847: GO 83156
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
82849: LD_ADDR_VAR 0 10
82853: PUSH
82854: LD_INT 5
82856: PUSH
82857: LD_INT 6
82859: PUSH
82860: EMPTY
82861: LIST
82862: LIST
82863: PUSH
82864: LD_INT 2
82866: PUSH
82867: LD_INT 4
82869: PUSH
82870: EMPTY
82871: LIST
82872: LIST
82873: PUSH
82874: LD_INT 3
82876: PUSH
82877: LD_INT 5
82879: PUSH
82880: EMPTY
82881: LIST
82882: LIST
82883: PUSH
82884: EMPTY
82885: LIST
82886: LIST
82887: LIST
82888: PUSH
82889: LD_INT 24
82891: PUSH
82892: LD_INT 25
82894: PUSH
82895: EMPTY
82896: LIST
82897: LIST
82898: PUSH
82899: LD_INT 23
82901: PUSH
82902: LD_INT 27
82904: PUSH
82905: EMPTY
82906: LIST
82907: LIST
82908: PUSH
82909: EMPTY
82910: LIST
82911: LIST
82912: PUSH
82913: LD_INT 42
82915: PUSH
82916: LD_INT 43
82918: PUSH
82919: EMPTY
82920: LIST
82921: LIST
82922: PUSH
82923: LD_INT 44
82925: PUSH
82926: LD_INT 46
82928: PUSH
82929: EMPTY
82930: LIST
82931: LIST
82932: PUSH
82933: LD_INT 45
82935: PUSH
82936: LD_INT 47
82938: PUSH
82939: EMPTY
82940: LIST
82941: LIST
82942: PUSH
82943: EMPTY
82944: LIST
82945: LIST
82946: LIST
82947: PUSH
82948: EMPTY
82949: LIST
82950: LIST
82951: LIST
82952: ST_TO_ADDR
// result := [ ] ;
82953: LD_ADDR_VAR 0 3
82957: PUSH
82958: EMPTY
82959: ST_TO_ADDR
// for i in turrets do
82960: LD_ADDR_VAR 0 4
82964: PUSH
82965: LD_VAR 0 1
82969: PUSH
82970: FOR_IN
82971: IFFALSE 83154
// begin nat := GetNation ( i ) ;
82973: LD_ADDR_VAR 0 7
82977: PUSH
82978: LD_VAR 0 4
82982: PPUSH
82983: CALL_OW 248
82987: ST_TO_ADDR
// weapon := 0 ;
82988: LD_ADDR_VAR 0 8
82992: PUSH
82993: LD_INT 0
82995: ST_TO_ADDR
// if not nat then
82996: LD_VAR 0 7
83000: NOT
83001: IFFALSE 83005
// continue ;
83003: GO 82970
// for j in list [ nat ] do
83005: LD_ADDR_VAR 0 5
83009: PUSH
83010: LD_VAR 0 10
83014: PUSH
83015: LD_VAR 0 7
83019: ARRAY
83020: PUSH
83021: FOR_IN
83022: IFFALSE 83063
// if GetBWeapon ( i ) = j [ 1 ] then
83024: LD_VAR 0 4
83028: PPUSH
83029: CALL_OW 269
83033: PUSH
83034: LD_VAR 0 5
83038: PUSH
83039: LD_INT 1
83041: ARRAY
83042: EQUAL
83043: IFFALSE 83061
// begin weapon := j [ 2 ] ;
83045: LD_ADDR_VAR 0 8
83049: PUSH
83050: LD_VAR 0 5
83054: PUSH
83055: LD_INT 2
83057: ARRAY
83058: ST_TO_ADDR
// break ;
83059: GO 83063
// end ;
83061: GO 83021
83063: POP
83064: POP
// if not weapon then
83065: LD_VAR 0 8
83069: NOT
83070: IFFALSE 83074
// continue ;
83072: GO 82970
// for k in factories do
83074: LD_ADDR_VAR 0 6
83078: PUSH
83079: LD_VAR 0 2
83083: PUSH
83084: FOR_IN
83085: IFFALSE 83150
// begin weapons := AvailableWeaponList ( k ) ;
83087: LD_ADDR_VAR 0 9
83091: PUSH
83092: LD_VAR 0 6
83096: PPUSH
83097: CALL_OW 478
83101: ST_TO_ADDR
// if not weapons then
83102: LD_VAR 0 9
83106: NOT
83107: IFFALSE 83111
// continue ;
83109: GO 83084
// if weapon in weapons then
83111: LD_VAR 0 8
83115: PUSH
83116: LD_VAR 0 9
83120: IN
83121: IFFALSE 83148
// begin result := [ i , weapon ] ;
83123: LD_ADDR_VAR 0 3
83127: PUSH
83128: LD_VAR 0 4
83132: PUSH
83133: LD_VAR 0 8
83137: PUSH
83138: EMPTY
83139: LIST
83140: LIST
83141: ST_TO_ADDR
// exit ;
83142: POP
83143: POP
83144: POP
83145: POP
83146: GO 83156
// end ; end ;
83148: GO 83084
83150: POP
83151: POP
// end ;
83152: GO 82970
83154: POP
83155: POP
// end ;
83156: LD_VAR 0 3
83160: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
83161: LD_INT 0
83163: PPUSH
// if not side or side > 8 then
83164: LD_VAR 0 3
83168: NOT
83169: PUSH
83170: LD_VAR 0 3
83174: PUSH
83175: LD_INT 8
83177: GREATER
83178: OR
83179: IFFALSE 83183
// exit ;
83181: GO 83242
// if not range then
83183: LD_VAR 0 4
83187: NOT
83188: IFFALSE 83199
// range := - 12 ;
83190: LD_ADDR_VAR 0 4
83194: PUSH
83195: LD_INT 12
83197: NEG
83198: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
83199: LD_VAR 0 1
83203: PPUSH
83204: LD_VAR 0 2
83208: PPUSH
83209: LD_VAR 0 3
83213: PPUSH
83214: LD_VAR 0 4
83218: PPUSH
83219: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
83223: LD_VAR 0 1
83227: PPUSH
83228: LD_VAR 0 2
83232: PPUSH
83233: LD_VAR 0 3
83237: PPUSH
83238: CALL_OW 331
// end ;
83242: LD_VAR 0 5
83246: RET
// export function Video ( mode ) ; begin
83247: LD_INT 0
83249: PPUSH
// ingame_video = mode ;
83250: LD_ADDR_OWVAR 52
83254: PUSH
83255: LD_VAR 0 1
83259: ST_TO_ADDR
// interface_hidden = mode ;
83260: LD_ADDR_OWVAR 54
83264: PUSH
83265: LD_VAR 0 1
83269: ST_TO_ADDR
// end ;
83270: LD_VAR 0 2
83274: RET
// export function Join ( array , element ) ; begin
83275: LD_INT 0
83277: PPUSH
// result := Replace ( array , array + 1 , element ) ;
83278: LD_ADDR_VAR 0 3
83282: PUSH
83283: LD_VAR 0 1
83287: PPUSH
83288: LD_VAR 0 1
83292: PUSH
83293: LD_INT 1
83295: PLUS
83296: PPUSH
83297: LD_VAR 0 2
83301: PPUSH
83302: CALL_OW 1
83306: ST_TO_ADDR
// end ;
83307: LD_VAR 0 3
83311: RET
// export function JoinUnion ( array , element ) ; begin
83312: LD_INT 0
83314: PPUSH
// result := array union element ;
83315: LD_ADDR_VAR 0 3
83319: PUSH
83320: LD_VAR 0 1
83324: PUSH
83325: LD_VAR 0 2
83329: UNION
83330: ST_TO_ADDR
// end ;
83331: LD_VAR 0 3
83335: RET
// export function GetBehemoths ( side ) ; begin
83336: LD_INT 0
83338: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
83339: LD_ADDR_VAR 0 2
83343: PUSH
83344: LD_INT 22
83346: PUSH
83347: LD_VAR 0 1
83351: PUSH
83352: EMPTY
83353: LIST
83354: LIST
83355: PUSH
83356: LD_INT 31
83358: PUSH
83359: LD_INT 25
83361: PUSH
83362: EMPTY
83363: LIST
83364: LIST
83365: PUSH
83366: EMPTY
83367: LIST
83368: LIST
83369: PPUSH
83370: CALL_OW 69
83374: ST_TO_ADDR
// end ;
83375: LD_VAR 0 2
83379: RET
// export function Shuffle ( array ) ; var i , index ; begin
83380: LD_INT 0
83382: PPUSH
83383: PPUSH
83384: PPUSH
// result := [ ] ;
83385: LD_ADDR_VAR 0 2
83389: PUSH
83390: EMPTY
83391: ST_TO_ADDR
// if not array then
83392: LD_VAR 0 1
83396: NOT
83397: IFFALSE 83401
// exit ;
83399: GO 83500
// Randomize ;
83401: CALL_OW 10
// for i = array downto 1 do
83405: LD_ADDR_VAR 0 3
83409: PUSH
83410: DOUBLE
83411: LD_VAR 0 1
83415: INC
83416: ST_TO_ADDR
83417: LD_INT 1
83419: PUSH
83420: FOR_DOWNTO
83421: IFFALSE 83498
// begin index := rand ( 1 , array ) ;
83423: LD_ADDR_VAR 0 4
83427: PUSH
83428: LD_INT 1
83430: PPUSH
83431: LD_VAR 0 1
83435: PPUSH
83436: CALL_OW 12
83440: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
83441: LD_ADDR_VAR 0 2
83445: PUSH
83446: LD_VAR 0 2
83450: PPUSH
83451: LD_VAR 0 2
83455: PUSH
83456: LD_INT 1
83458: PLUS
83459: PPUSH
83460: LD_VAR 0 1
83464: PUSH
83465: LD_VAR 0 4
83469: ARRAY
83470: PPUSH
83471: CALL_OW 2
83475: ST_TO_ADDR
// array := Delete ( array , index ) ;
83476: LD_ADDR_VAR 0 1
83480: PUSH
83481: LD_VAR 0 1
83485: PPUSH
83486: LD_VAR 0 4
83490: PPUSH
83491: CALL_OW 3
83495: ST_TO_ADDR
// end ;
83496: GO 83420
83498: POP
83499: POP
// end ;
83500: LD_VAR 0 2
83504: RET
// export function GetBaseMaterials ( base ) ; begin
83505: LD_INT 0
83507: PPUSH
// result := [ 0 , 0 , 0 ] ;
83508: LD_ADDR_VAR 0 2
83512: PUSH
83513: LD_INT 0
83515: PUSH
83516: LD_INT 0
83518: PUSH
83519: LD_INT 0
83521: PUSH
83522: EMPTY
83523: LIST
83524: LIST
83525: LIST
83526: ST_TO_ADDR
// if not base then
83527: LD_VAR 0 1
83531: NOT
83532: IFFALSE 83536
// exit ;
83534: GO 83585
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
83536: LD_ADDR_VAR 0 2
83540: PUSH
83541: LD_VAR 0 1
83545: PPUSH
83546: LD_INT 1
83548: PPUSH
83549: CALL_OW 275
83553: PUSH
83554: LD_VAR 0 1
83558: PPUSH
83559: LD_INT 2
83561: PPUSH
83562: CALL_OW 275
83566: PUSH
83567: LD_VAR 0 1
83571: PPUSH
83572: LD_INT 3
83574: PPUSH
83575: CALL_OW 275
83579: PUSH
83580: EMPTY
83581: LIST
83582: LIST
83583: LIST
83584: ST_TO_ADDR
// end ;
83585: LD_VAR 0 2
83589: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
83590: LD_INT 0
83592: PPUSH
83593: PPUSH
// result := array ;
83594: LD_ADDR_VAR 0 3
83598: PUSH
83599: LD_VAR 0 1
83603: ST_TO_ADDR
// if size > 0 then
83604: LD_VAR 0 2
83608: PUSH
83609: LD_INT 0
83611: GREATER
83612: IFFALSE 83658
// for i := array downto size do
83614: LD_ADDR_VAR 0 4
83618: PUSH
83619: DOUBLE
83620: LD_VAR 0 1
83624: INC
83625: ST_TO_ADDR
83626: LD_VAR 0 2
83630: PUSH
83631: FOR_DOWNTO
83632: IFFALSE 83656
// result := Delete ( result , result ) ;
83634: LD_ADDR_VAR 0 3
83638: PUSH
83639: LD_VAR 0 3
83643: PPUSH
83644: LD_VAR 0 3
83648: PPUSH
83649: CALL_OW 3
83653: ST_TO_ADDR
83654: GO 83631
83656: POP
83657: POP
// end ;
83658: LD_VAR 0 3
83662: RET
// export function ComExit ( unit ) ; var tmp ; begin
83663: LD_INT 0
83665: PPUSH
83666: PPUSH
// if not IsInUnit ( unit ) then
83667: LD_VAR 0 1
83671: PPUSH
83672: CALL_OW 310
83676: NOT
83677: IFFALSE 83681
// exit ;
83679: GO 83741
// tmp := IsInUnit ( unit ) ;
83681: LD_ADDR_VAR 0 3
83685: PUSH
83686: LD_VAR 0 1
83690: PPUSH
83691: CALL_OW 310
83695: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
83696: LD_VAR 0 3
83700: PPUSH
83701: CALL_OW 247
83705: PUSH
83706: LD_INT 2
83708: EQUAL
83709: IFFALSE 83722
// ComExitVehicle ( unit ) else
83711: LD_VAR 0 1
83715: PPUSH
83716: CALL_OW 121
83720: GO 83731
// ComExitBuilding ( unit ) ;
83722: LD_VAR 0 1
83726: PPUSH
83727: CALL_OW 122
// result := tmp ;
83731: LD_ADDR_VAR 0 2
83735: PUSH
83736: LD_VAR 0 3
83740: ST_TO_ADDR
// end ;
83741: LD_VAR 0 2
83745: RET
// export function ResetHc ; begin
83746: LD_INT 0
83748: PPUSH
// InitHc ;
83749: CALL_OW 19
// hc_importance := 0 ;
83753: LD_ADDR_OWVAR 32
83757: PUSH
83758: LD_INT 0
83760: ST_TO_ADDR
// end ; end_of_file
83761: LD_VAR 0 1
83765: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar , ar_crane ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; export function InitGlobalVariables ; begin
83766: LD_INT 0
83768: PPUSH
// ar_crane := 88 ;
83769: LD_ADDR_EXP 99
83773: PUSH
83774: LD_INT 88
83776: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
83777: LD_ADDR_EXP 94
83781: PUSH
83782: LD_INT 89
83784: ST_TO_ADDR
// us_hack := 99 ;
83785: LD_ADDR_EXP 95
83789: PUSH
83790: LD_INT 99
83792: ST_TO_ADDR
// us_artillery := 97 ;
83793: LD_ADDR_EXP 96
83797: PUSH
83798: LD_INT 97
83800: ST_TO_ADDR
// ar_bio_bomb := 91 ;
83801: LD_ADDR_EXP 97
83805: PUSH
83806: LD_INT 91
83808: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
83809: LD_ADDR_EXP 98
83813: PUSH
83814: LD_INT 92
83816: ST_TO_ADDR
// ru_radar := 98 ;
83817: LD_ADDR_EXP 93
83821: PUSH
83822: LD_INT 98
83824: ST_TO_ADDR
// tech_Artillery := 80 ;
83825: LD_ADDR_EXP 100
83829: PUSH
83830: LD_INT 80
83832: ST_TO_ADDR
// tech_RadMat := 81 ;
83833: LD_ADDR_EXP 101
83837: PUSH
83838: LD_INT 81
83840: ST_TO_ADDR
// tech_BasicTools := 82 ;
83841: LD_ADDR_EXP 102
83845: PUSH
83846: LD_INT 82
83848: ST_TO_ADDR
// tech_Cargo := 83 ;
83849: LD_ADDR_EXP 103
83853: PUSH
83854: LD_INT 83
83856: ST_TO_ADDR
// tech_Track := 84 ;
83857: LD_ADDR_EXP 104
83861: PUSH
83862: LD_INT 84
83864: ST_TO_ADDR
// tech_Crane := 85 ;
83865: LD_ADDR_EXP 105
83869: PUSH
83870: LD_INT 85
83872: ST_TO_ADDR
// tech_Bulldozer := 86 ;
83873: LD_ADDR_EXP 106
83877: PUSH
83878: LD_INT 86
83880: ST_TO_ADDR
// tech_Hovercraft := 87 ;
83881: LD_ADDR_EXP 107
83885: PUSH
83886: LD_INT 87
83888: ST_TO_ADDR
// end ;
83889: LD_VAR 0 1
83893: RET
// every 1 do
83894: GO 83896
83896: DISABLE
// InitGlobalVariables ; end_of_file end_of_file
83897: CALL 83766 0 0
83901: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
83902: LD_VAR 0 2
83906: PUSH
83907: LD_INT 100
83909: EQUAL
83910: IFFALSE 84859
// begin if not StreamModeActive then
83912: LD_EXP 108
83916: NOT
83917: IFFALSE 83927
// StreamModeActive := true ;
83919: LD_ADDR_EXP 108
83923: PUSH
83924: LD_INT 1
83926: ST_TO_ADDR
// if p3 = 0 then
83927: LD_VAR 0 3
83931: PUSH
83932: LD_INT 0
83934: EQUAL
83935: IFFALSE 83941
// InitStreamMode ;
83937: CALL 85092 0 0
// if p3 = 1 then
83941: LD_VAR 0 3
83945: PUSH
83946: LD_INT 1
83948: EQUAL
83949: IFFALSE 83959
// sRocket := true ;
83951: LD_ADDR_EXP 113
83955: PUSH
83956: LD_INT 1
83958: ST_TO_ADDR
// if p3 = 2 then
83959: LD_VAR 0 3
83963: PUSH
83964: LD_INT 2
83966: EQUAL
83967: IFFALSE 83977
// sSpeed := true ;
83969: LD_ADDR_EXP 112
83973: PUSH
83974: LD_INT 1
83976: ST_TO_ADDR
// if p3 = 3 then
83977: LD_VAR 0 3
83981: PUSH
83982: LD_INT 3
83984: EQUAL
83985: IFFALSE 83995
// sEngine := true ;
83987: LD_ADDR_EXP 114
83991: PUSH
83992: LD_INT 1
83994: ST_TO_ADDR
// if p3 = 4 then
83995: LD_VAR 0 3
83999: PUSH
84000: LD_INT 4
84002: EQUAL
84003: IFFALSE 84013
// sSpec := true ;
84005: LD_ADDR_EXP 111
84009: PUSH
84010: LD_INT 1
84012: ST_TO_ADDR
// if p3 = 5 then
84013: LD_VAR 0 3
84017: PUSH
84018: LD_INT 5
84020: EQUAL
84021: IFFALSE 84031
// sLevel := true ;
84023: LD_ADDR_EXP 115
84027: PUSH
84028: LD_INT 1
84030: ST_TO_ADDR
// if p3 = 6 then
84031: LD_VAR 0 3
84035: PUSH
84036: LD_INT 6
84038: EQUAL
84039: IFFALSE 84049
// sArmoury := true ;
84041: LD_ADDR_EXP 116
84045: PUSH
84046: LD_INT 1
84048: ST_TO_ADDR
// if p3 = 7 then
84049: LD_VAR 0 3
84053: PUSH
84054: LD_INT 7
84056: EQUAL
84057: IFFALSE 84067
// sRadar := true ;
84059: LD_ADDR_EXP 117
84063: PUSH
84064: LD_INT 1
84066: ST_TO_ADDR
// if p3 = 8 then
84067: LD_VAR 0 3
84071: PUSH
84072: LD_INT 8
84074: EQUAL
84075: IFFALSE 84085
// sBunker := true ;
84077: LD_ADDR_EXP 118
84081: PUSH
84082: LD_INT 1
84084: ST_TO_ADDR
// if p3 = 9 then
84085: LD_VAR 0 3
84089: PUSH
84090: LD_INT 9
84092: EQUAL
84093: IFFALSE 84103
// sHack := true ;
84095: LD_ADDR_EXP 119
84099: PUSH
84100: LD_INT 1
84102: ST_TO_ADDR
// if p3 = 10 then
84103: LD_VAR 0 3
84107: PUSH
84108: LD_INT 10
84110: EQUAL
84111: IFFALSE 84121
// sFire := true ;
84113: LD_ADDR_EXP 120
84117: PUSH
84118: LD_INT 1
84120: ST_TO_ADDR
// if p3 = 11 then
84121: LD_VAR 0 3
84125: PUSH
84126: LD_INT 11
84128: EQUAL
84129: IFFALSE 84139
// sRefresh := true ;
84131: LD_ADDR_EXP 121
84135: PUSH
84136: LD_INT 1
84138: ST_TO_ADDR
// if p3 = 12 then
84139: LD_VAR 0 3
84143: PUSH
84144: LD_INT 12
84146: EQUAL
84147: IFFALSE 84157
// sExp := true ;
84149: LD_ADDR_EXP 122
84153: PUSH
84154: LD_INT 1
84156: ST_TO_ADDR
// if p3 = 13 then
84157: LD_VAR 0 3
84161: PUSH
84162: LD_INT 13
84164: EQUAL
84165: IFFALSE 84175
// sDepot := true ;
84167: LD_ADDR_EXP 123
84171: PUSH
84172: LD_INT 1
84174: ST_TO_ADDR
// if p3 = 14 then
84175: LD_VAR 0 3
84179: PUSH
84180: LD_INT 14
84182: EQUAL
84183: IFFALSE 84193
// sFlag := true ;
84185: LD_ADDR_EXP 124
84189: PUSH
84190: LD_INT 1
84192: ST_TO_ADDR
// if p3 = 15 then
84193: LD_VAR 0 3
84197: PUSH
84198: LD_INT 15
84200: EQUAL
84201: IFFALSE 84211
// sKamikadze := true ;
84203: LD_ADDR_EXP 132
84207: PUSH
84208: LD_INT 1
84210: ST_TO_ADDR
// if p3 = 16 then
84211: LD_VAR 0 3
84215: PUSH
84216: LD_INT 16
84218: EQUAL
84219: IFFALSE 84229
// sTroll := true ;
84221: LD_ADDR_EXP 133
84225: PUSH
84226: LD_INT 1
84228: ST_TO_ADDR
// if p3 = 17 then
84229: LD_VAR 0 3
84233: PUSH
84234: LD_INT 17
84236: EQUAL
84237: IFFALSE 84247
// sSlow := true ;
84239: LD_ADDR_EXP 134
84243: PUSH
84244: LD_INT 1
84246: ST_TO_ADDR
// if p3 = 18 then
84247: LD_VAR 0 3
84251: PUSH
84252: LD_INT 18
84254: EQUAL
84255: IFFALSE 84265
// sLack := true ;
84257: LD_ADDR_EXP 135
84261: PUSH
84262: LD_INT 1
84264: ST_TO_ADDR
// if p3 = 19 then
84265: LD_VAR 0 3
84269: PUSH
84270: LD_INT 19
84272: EQUAL
84273: IFFALSE 84283
// sTank := true ;
84275: LD_ADDR_EXP 137
84279: PUSH
84280: LD_INT 1
84282: ST_TO_ADDR
// if p3 = 20 then
84283: LD_VAR 0 3
84287: PUSH
84288: LD_INT 20
84290: EQUAL
84291: IFFALSE 84301
// sRemote := true ;
84293: LD_ADDR_EXP 138
84297: PUSH
84298: LD_INT 1
84300: ST_TO_ADDR
// if p3 = 21 then
84301: LD_VAR 0 3
84305: PUSH
84306: LD_INT 21
84308: EQUAL
84309: IFFALSE 84319
// sPowell := true ;
84311: LD_ADDR_EXP 139
84315: PUSH
84316: LD_INT 1
84318: ST_TO_ADDR
// if p3 = 22 then
84319: LD_VAR 0 3
84323: PUSH
84324: LD_INT 22
84326: EQUAL
84327: IFFALSE 84337
// sTeleport := true ;
84329: LD_ADDR_EXP 142
84333: PUSH
84334: LD_INT 1
84336: ST_TO_ADDR
// if p3 = 23 then
84337: LD_VAR 0 3
84341: PUSH
84342: LD_INT 23
84344: EQUAL
84345: IFFALSE 84355
// sOilTower := true ;
84347: LD_ADDR_EXP 144
84351: PUSH
84352: LD_INT 1
84354: ST_TO_ADDR
// if p3 = 24 then
84355: LD_VAR 0 3
84359: PUSH
84360: LD_INT 24
84362: EQUAL
84363: IFFALSE 84373
// sShovel := true ;
84365: LD_ADDR_EXP 145
84369: PUSH
84370: LD_INT 1
84372: ST_TO_ADDR
// if p3 = 25 then
84373: LD_VAR 0 3
84377: PUSH
84378: LD_INT 25
84380: EQUAL
84381: IFFALSE 84391
// sSheik := true ;
84383: LD_ADDR_EXP 146
84387: PUSH
84388: LD_INT 1
84390: ST_TO_ADDR
// if p3 = 26 then
84391: LD_VAR 0 3
84395: PUSH
84396: LD_INT 26
84398: EQUAL
84399: IFFALSE 84409
// sEarthquake := true ;
84401: LD_ADDR_EXP 148
84405: PUSH
84406: LD_INT 1
84408: ST_TO_ADDR
// if p3 = 27 then
84409: LD_VAR 0 3
84413: PUSH
84414: LD_INT 27
84416: EQUAL
84417: IFFALSE 84427
// sAI := true ;
84419: LD_ADDR_EXP 149
84423: PUSH
84424: LD_INT 1
84426: ST_TO_ADDR
// if p3 = 28 then
84427: LD_VAR 0 3
84431: PUSH
84432: LD_INT 28
84434: EQUAL
84435: IFFALSE 84445
// sCargo := true ;
84437: LD_ADDR_EXP 152
84441: PUSH
84442: LD_INT 1
84444: ST_TO_ADDR
// if p3 = 29 then
84445: LD_VAR 0 3
84449: PUSH
84450: LD_INT 29
84452: EQUAL
84453: IFFALSE 84463
// sDLaser := true ;
84455: LD_ADDR_EXP 153
84459: PUSH
84460: LD_INT 1
84462: ST_TO_ADDR
// if p3 = 30 then
84463: LD_VAR 0 3
84467: PUSH
84468: LD_INT 30
84470: EQUAL
84471: IFFALSE 84481
// sExchange := true ;
84473: LD_ADDR_EXP 154
84477: PUSH
84478: LD_INT 1
84480: ST_TO_ADDR
// if p3 = 31 then
84481: LD_VAR 0 3
84485: PUSH
84486: LD_INT 31
84488: EQUAL
84489: IFFALSE 84499
// sFac := true ;
84491: LD_ADDR_EXP 155
84495: PUSH
84496: LD_INT 1
84498: ST_TO_ADDR
// if p3 = 32 then
84499: LD_VAR 0 3
84503: PUSH
84504: LD_INT 32
84506: EQUAL
84507: IFFALSE 84517
// sPower := true ;
84509: LD_ADDR_EXP 156
84513: PUSH
84514: LD_INT 1
84516: ST_TO_ADDR
// if p3 = 33 then
84517: LD_VAR 0 3
84521: PUSH
84522: LD_INT 33
84524: EQUAL
84525: IFFALSE 84535
// sRandom := true ;
84527: LD_ADDR_EXP 157
84531: PUSH
84532: LD_INT 1
84534: ST_TO_ADDR
// if p3 = 34 then
84535: LD_VAR 0 3
84539: PUSH
84540: LD_INT 34
84542: EQUAL
84543: IFFALSE 84553
// sShield := true ;
84545: LD_ADDR_EXP 158
84549: PUSH
84550: LD_INT 1
84552: ST_TO_ADDR
// if p3 = 35 then
84553: LD_VAR 0 3
84557: PUSH
84558: LD_INT 35
84560: EQUAL
84561: IFFALSE 84571
// sTime := true ;
84563: LD_ADDR_EXP 159
84567: PUSH
84568: LD_INT 1
84570: ST_TO_ADDR
// if p3 = 36 then
84571: LD_VAR 0 3
84575: PUSH
84576: LD_INT 36
84578: EQUAL
84579: IFFALSE 84589
// sTools := true ;
84581: LD_ADDR_EXP 160
84585: PUSH
84586: LD_INT 1
84588: ST_TO_ADDR
// if p3 = 101 then
84589: LD_VAR 0 3
84593: PUSH
84594: LD_INT 101
84596: EQUAL
84597: IFFALSE 84607
// sSold := true ;
84599: LD_ADDR_EXP 125
84603: PUSH
84604: LD_INT 1
84606: ST_TO_ADDR
// if p3 = 102 then
84607: LD_VAR 0 3
84611: PUSH
84612: LD_INT 102
84614: EQUAL
84615: IFFALSE 84625
// sDiff := true ;
84617: LD_ADDR_EXP 126
84621: PUSH
84622: LD_INT 1
84624: ST_TO_ADDR
// if p3 = 103 then
84625: LD_VAR 0 3
84629: PUSH
84630: LD_INT 103
84632: EQUAL
84633: IFFALSE 84643
// sFog := true ;
84635: LD_ADDR_EXP 129
84639: PUSH
84640: LD_INT 1
84642: ST_TO_ADDR
// if p3 = 104 then
84643: LD_VAR 0 3
84647: PUSH
84648: LD_INT 104
84650: EQUAL
84651: IFFALSE 84661
// sReset := true ;
84653: LD_ADDR_EXP 130
84657: PUSH
84658: LD_INT 1
84660: ST_TO_ADDR
// if p3 = 105 then
84661: LD_VAR 0 3
84665: PUSH
84666: LD_INT 105
84668: EQUAL
84669: IFFALSE 84679
// sSun := true ;
84671: LD_ADDR_EXP 131
84675: PUSH
84676: LD_INT 1
84678: ST_TO_ADDR
// if p3 = 106 then
84679: LD_VAR 0 3
84683: PUSH
84684: LD_INT 106
84686: EQUAL
84687: IFFALSE 84697
// sTiger := true ;
84689: LD_ADDR_EXP 127
84693: PUSH
84694: LD_INT 1
84696: ST_TO_ADDR
// if p3 = 107 then
84697: LD_VAR 0 3
84701: PUSH
84702: LD_INT 107
84704: EQUAL
84705: IFFALSE 84715
// sBomb := true ;
84707: LD_ADDR_EXP 128
84711: PUSH
84712: LD_INT 1
84714: ST_TO_ADDR
// if p3 = 108 then
84715: LD_VAR 0 3
84719: PUSH
84720: LD_INT 108
84722: EQUAL
84723: IFFALSE 84733
// sWound := true ;
84725: LD_ADDR_EXP 136
84729: PUSH
84730: LD_INT 1
84732: ST_TO_ADDR
// if p3 = 109 then
84733: LD_VAR 0 3
84737: PUSH
84738: LD_INT 109
84740: EQUAL
84741: IFFALSE 84751
// sBetray := true ;
84743: LD_ADDR_EXP 140
84747: PUSH
84748: LD_INT 1
84750: ST_TO_ADDR
// if p3 = 110 then
84751: LD_VAR 0 3
84755: PUSH
84756: LD_INT 110
84758: EQUAL
84759: IFFALSE 84769
// sContamin := true ;
84761: LD_ADDR_EXP 141
84765: PUSH
84766: LD_INT 1
84768: ST_TO_ADDR
// if p3 = 111 then
84769: LD_VAR 0 3
84773: PUSH
84774: LD_INT 111
84776: EQUAL
84777: IFFALSE 84787
// sOil := true ;
84779: LD_ADDR_EXP 143
84783: PUSH
84784: LD_INT 1
84786: ST_TO_ADDR
// if p3 = 112 then
84787: LD_VAR 0 3
84791: PUSH
84792: LD_INT 112
84794: EQUAL
84795: IFFALSE 84805
// sStu := true ;
84797: LD_ADDR_EXP 147
84801: PUSH
84802: LD_INT 1
84804: ST_TO_ADDR
// if p3 = 113 then
84805: LD_VAR 0 3
84809: PUSH
84810: LD_INT 113
84812: EQUAL
84813: IFFALSE 84823
// sBazooka := true ;
84815: LD_ADDR_EXP 150
84819: PUSH
84820: LD_INT 1
84822: ST_TO_ADDR
// if p3 = 114 then
84823: LD_VAR 0 3
84827: PUSH
84828: LD_INT 114
84830: EQUAL
84831: IFFALSE 84841
// sMortar := true ;
84833: LD_ADDR_EXP 151
84837: PUSH
84838: LD_INT 1
84840: ST_TO_ADDR
// if p3 = 115 then
84841: LD_VAR 0 3
84845: PUSH
84846: LD_INT 115
84848: EQUAL
84849: IFFALSE 84859
// sRanger := true ;
84851: LD_ADDR_EXP 161
84855: PUSH
84856: LD_INT 1
84858: ST_TO_ADDR
// end ; if p2 = 101 then
84859: LD_VAR 0 2
84863: PUSH
84864: LD_INT 101
84866: EQUAL
84867: IFFALSE 85070
// begin case p3 of 1 :
84869: LD_VAR 0 3
84873: PUSH
84874: LD_INT 1
84876: DOUBLE
84877: EQUAL
84878: IFTRUE 84882
84880: GO 84889
84882: POP
// hHackUnlimitedResources ; 2 :
84883: CALL 95164 0 0
84887: GO 85070
84889: LD_INT 2
84891: DOUBLE
84892: EQUAL
84893: IFTRUE 84897
84895: GO 84904
84897: POP
// hHackSetLevel10 ; 3 :
84898: CALL 95297 0 0
84902: GO 85070
84904: LD_INT 3
84906: DOUBLE
84907: EQUAL
84908: IFTRUE 84912
84910: GO 84919
84912: POP
// hHackSetLevel10YourUnits ; 4 :
84913: CALL 95382 0 0
84917: GO 85070
84919: LD_INT 4
84921: DOUBLE
84922: EQUAL
84923: IFTRUE 84927
84925: GO 84949
84927: POP
// hHackSpawnHuman ( p4 , p5 , p6 ) ; 5 :
84928: LD_VAR 0 4
84932: PPUSH
84933: LD_VAR 0 5
84937: PPUSH
84938: LD_VAR 0 6
84942: PPUSH
84943: CALL 95472 0 3
84947: GO 85070
84949: LD_INT 5
84951: DOUBLE
84952: EQUAL
84953: IFTRUE 84957
84955: GO 84964
84957: POP
// hHackSpawnVehicle ; 6 :
84958: CALL 95533 0 0
84962: GO 85070
84964: LD_INT 6
84966: DOUBLE
84967: EQUAL
84968: IFTRUE 84972
84970: GO 84979
84972: POP
// hHackInvincible ; 7 :
84973: CALL 96079 0 0
84977: GO 85070
84979: LD_INT 7
84981: DOUBLE
84982: EQUAL
84983: IFTRUE 84987
84985: GO 84994
84987: POP
// hHackInvisible ; 8 :
84988: CALL 96190 0 0
84992: GO 85070
84994: LD_INT 8
84996: DOUBLE
84997: EQUAL
84998: IFTRUE 85002
85000: GO 85009
85002: POP
// hHackChangeYourSide ; 9 :
85003: CALL 96247 0 0
85007: GO 85070
85009: LD_INT 9
85011: DOUBLE
85012: EQUAL
85013: IFTRUE 85017
85015: GO 85024
85017: POP
// hHackChangeUnitSide ; 10 :
85018: CALL 96289 0 0
85022: GO 85070
85024: LD_INT 10
85026: DOUBLE
85027: EQUAL
85028: IFTRUE 85032
85030: GO 85039
85032: POP
// hHackFog ; 11 :
85033: CALL 96390 0 0
85037: GO 85070
85039: LD_INT 11
85041: DOUBLE
85042: EQUAL
85043: IFTRUE 85047
85045: GO 85054
85047: POP
// hHackApeman ; 12 :
85048: CALL 96405 0 0
85052: GO 85070
85054: LD_INT 12
85056: DOUBLE
85057: EQUAL
85058: IFTRUE 85062
85060: GO 85069
85062: POP
// hHackBoom ; end ;
85063: CALL 96490 0 0
85067: GO 85070
85069: POP
// end ; end ;
85070: PPOPN 6
85072: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
85073: GO 85075
85075: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
85076: LD_STRING initStreamRollete();
85078: PPUSH
85079: CALL_OW 559
// InitStreamMode ;
85083: CALL 85092 0 0
// DefineStreamItems ( ) ;
85087: CALL 85532 0 0
// end ;
85091: END
// function InitStreamMode ; begin
85092: LD_INT 0
85094: PPUSH
// streamModeActive := false ;
85095: LD_ADDR_EXP 108
85099: PUSH
85100: LD_INT 0
85102: ST_TO_ADDR
// normalCounter := 36 ;
85103: LD_ADDR_EXP 109
85107: PUSH
85108: LD_INT 36
85110: ST_TO_ADDR
// hardcoreCounter := 16 ;
85111: LD_ADDR_EXP 110
85115: PUSH
85116: LD_INT 16
85118: ST_TO_ADDR
// sRocket := false ;
85119: LD_ADDR_EXP 113
85123: PUSH
85124: LD_INT 0
85126: ST_TO_ADDR
// sSpeed := false ;
85127: LD_ADDR_EXP 112
85131: PUSH
85132: LD_INT 0
85134: ST_TO_ADDR
// sEngine := false ;
85135: LD_ADDR_EXP 114
85139: PUSH
85140: LD_INT 0
85142: ST_TO_ADDR
// sSpec := false ;
85143: LD_ADDR_EXP 111
85147: PUSH
85148: LD_INT 0
85150: ST_TO_ADDR
// sLevel := false ;
85151: LD_ADDR_EXP 115
85155: PUSH
85156: LD_INT 0
85158: ST_TO_ADDR
// sArmoury := false ;
85159: LD_ADDR_EXP 116
85163: PUSH
85164: LD_INT 0
85166: ST_TO_ADDR
// sRadar := false ;
85167: LD_ADDR_EXP 117
85171: PUSH
85172: LD_INT 0
85174: ST_TO_ADDR
// sBunker := false ;
85175: LD_ADDR_EXP 118
85179: PUSH
85180: LD_INT 0
85182: ST_TO_ADDR
// sHack := false ;
85183: LD_ADDR_EXP 119
85187: PUSH
85188: LD_INT 0
85190: ST_TO_ADDR
// sFire := false ;
85191: LD_ADDR_EXP 120
85195: PUSH
85196: LD_INT 0
85198: ST_TO_ADDR
// sRefresh := false ;
85199: LD_ADDR_EXP 121
85203: PUSH
85204: LD_INT 0
85206: ST_TO_ADDR
// sExp := false ;
85207: LD_ADDR_EXP 122
85211: PUSH
85212: LD_INT 0
85214: ST_TO_ADDR
// sDepot := false ;
85215: LD_ADDR_EXP 123
85219: PUSH
85220: LD_INT 0
85222: ST_TO_ADDR
// sFlag := false ;
85223: LD_ADDR_EXP 124
85227: PUSH
85228: LD_INT 0
85230: ST_TO_ADDR
// sKamikadze := false ;
85231: LD_ADDR_EXP 132
85235: PUSH
85236: LD_INT 0
85238: ST_TO_ADDR
// sTroll := false ;
85239: LD_ADDR_EXP 133
85243: PUSH
85244: LD_INT 0
85246: ST_TO_ADDR
// sSlow := false ;
85247: LD_ADDR_EXP 134
85251: PUSH
85252: LD_INT 0
85254: ST_TO_ADDR
// sLack := false ;
85255: LD_ADDR_EXP 135
85259: PUSH
85260: LD_INT 0
85262: ST_TO_ADDR
// sTank := false ;
85263: LD_ADDR_EXP 137
85267: PUSH
85268: LD_INT 0
85270: ST_TO_ADDR
// sRemote := false ;
85271: LD_ADDR_EXP 138
85275: PUSH
85276: LD_INT 0
85278: ST_TO_ADDR
// sPowell := false ;
85279: LD_ADDR_EXP 139
85283: PUSH
85284: LD_INT 0
85286: ST_TO_ADDR
// sTeleport := false ;
85287: LD_ADDR_EXP 142
85291: PUSH
85292: LD_INT 0
85294: ST_TO_ADDR
// sOilTower := false ;
85295: LD_ADDR_EXP 144
85299: PUSH
85300: LD_INT 0
85302: ST_TO_ADDR
// sShovel := false ;
85303: LD_ADDR_EXP 145
85307: PUSH
85308: LD_INT 0
85310: ST_TO_ADDR
// sSheik := false ;
85311: LD_ADDR_EXP 146
85315: PUSH
85316: LD_INT 0
85318: ST_TO_ADDR
// sEarthquake := false ;
85319: LD_ADDR_EXP 148
85323: PUSH
85324: LD_INT 0
85326: ST_TO_ADDR
// sAI := false ;
85327: LD_ADDR_EXP 149
85331: PUSH
85332: LD_INT 0
85334: ST_TO_ADDR
// sCargo := false ;
85335: LD_ADDR_EXP 152
85339: PUSH
85340: LD_INT 0
85342: ST_TO_ADDR
// sDLaser := false ;
85343: LD_ADDR_EXP 153
85347: PUSH
85348: LD_INT 0
85350: ST_TO_ADDR
// sExchange := false ;
85351: LD_ADDR_EXP 154
85355: PUSH
85356: LD_INT 0
85358: ST_TO_ADDR
// sFac := false ;
85359: LD_ADDR_EXP 155
85363: PUSH
85364: LD_INT 0
85366: ST_TO_ADDR
// sPower := false ;
85367: LD_ADDR_EXP 156
85371: PUSH
85372: LD_INT 0
85374: ST_TO_ADDR
// sRandom := false ;
85375: LD_ADDR_EXP 157
85379: PUSH
85380: LD_INT 0
85382: ST_TO_ADDR
// sShield := false ;
85383: LD_ADDR_EXP 158
85387: PUSH
85388: LD_INT 0
85390: ST_TO_ADDR
// sTime := false ;
85391: LD_ADDR_EXP 159
85395: PUSH
85396: LD_INT 0
85398: ST_TO_ADDR
// sTools := false ;
85399: LD_ADDR_EXP 160
85403: PUSH
85404: LD_INT 0
85406: ST_TO_ADDR
// sSold := false ;
85407: LD_ADDR_EXP 125
85411: PUSH
85412: LD_INT 0
85414: ST_TO_ADDR
// sDiff := false ;
85415: LD_ADDR_EXP 126
85419: PUSH
85420: LD_INT 0
85422: ST_TO_ADDR
// sFog := false ;
85423: LD_ADDR_EXP 129
85427: PUSH
85428: LD_INT 0
85430: ST_TO_ADDR
// sReset := false ;
85431: LD_ADDR_EXP 130
85435: PUSH
85436: LD_INT 0
85438: ST_TO_ADDR
// sSun := false ;
85439: LD_ADDR_EXP 131
85443: PUSH
85444: LD_INT 0
85446: ST_TO_ADDR
// sTiger := false ;
85447: LD_ADDR_EXP 127
85451: PUSH
85452: LD_INT 0
85454: ST_TO_ADDR
// sBomb := false ;
85455: LD_ADDR_EXP 128
85459: PUSH
85460: LD_INT 0
85462: ST_TO_ADDR
// sWound := false ;
85463: LD_ADDR_EXP 136
85467: PUSH
85468: LD_INT 0
85470: ST_TO_ADDR
// sBetray := false ;
85471: LD_ADDR_EXP 140
85475: PUSH
85476: LD_INT 0
85478: ST_TO_ADDR
// sContamin := false ;
85479: LD_ADDR_EXP 141
85483: PUSH
85484: LD_INT 0
85486: ST_TO_ADDR
// sOil := false ;
85487: LD_ADDR_EXP 143
85491: PUSH
85492: LD_INT 0
85494: ST_TO_ADDR
// sStu := false ;
85495: LD_ADDR_EXP 147
85499: PUSH
85500: LD_INT 0
85502: ST_TO_ADDR
// sBazooka := false ;
85503: LD_ADDR_EXP 150
85507: PUSH
85508: LD_INT 0
85510: ST_TO_ADDR
// sMortar := false ;
85511: LD_ADDR_EXP 151
85515: PUSH
85516: LD_INT 0
85518: ST_TO_ADDR
// sRanger := false ;
85519: LD_ADDR_EXP 161
85523: PUSH
85524: LD_INT 0
85526: ST_TO_ADDR
// end ;
85527: LD_VAR 0 1
85531: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
85532: LD_INT 0
85534: PPUSH
85535: PPUSH
85536: PPUSH
85537: PPUSH
85538: PPUSH
// result := [ ] ;
85539: LD_ADDR_VAR 0 1
85543: PUSH
85544: EMPTY
85545: ST_TO_ADDR
// if campaign_id = 1 then
85546: LD_OWVAR 69
85550: PUSH
85551: LD_INT 1
85553: EQUAL
85554: IFFALSE 88492
// begin case mission_number of 1 :
85556: LD_OWVAR 70
85560: PUSH
85561: LD_INT 1
85563: DOUBLE
85564: EQUAL
85565: IFTRUE 85569
85567: GO 85633
85569: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
85570: LD_ADDR_VAR 0 1
85574: PUSH
85575: LD_INT 2
85577: PUSH
85578: LD_INT 4
85580: PUSH
85581: LD_INT 11
85583: PUSH
85584: LD_INT 12
85586: PUSH
85587: LD_INT 15
85589: PUSH
85590: LD_INT 16
85592: PUSH
85593: LD_INT 22
85595: PUSH
85596: LD_INT 23
85598: PUSH
85599: LD_INT 26
85601: PUSH
85602: EMPTY
85603: LIST
85604: LIST
85605: LIST
85606: LIST
85607: LIST
85608: LIST
85609: LIST
85610: LIST
85611: LIST
85612: PUSH
85613: LD_INT 101
85615: PUSH
85616: LD_INT 102
85618: PUSH
85619: LD_INT 106
85621: PUSH
85622: EMPTY
85623: LIST
85624: LIST
85625: LIST
85626: PUSH
85627: EMPTY
85628: LIST
85629: LIST
85630: ST_TO_ADDR
85631: GO 88490
85633: LD_INT 2
85635: DOUBLE
85636: EQUAL
85637: IFTRUE 85641
85639: GO 85713
85641: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
85642: LD_ADDR_VAR 0 1
85646: PUSH
85647: LD_INT 2
85649: PUSH
85650: LD_INT 4
85652: PUSH
85653: LD_INT 11
85655: PUSH
85656: LD_INT 12
85658: PUSH
85659: LD_INT 15
85661: PUSH
85662: LD_INT 16
85664: PUSH
85665: LD_INT 22
85667: PUSH
85668: LD_INT 23
85670: PUSH
85671: LD_INT 26
85673: PUSH
85674: EMPTY
85675: LIST
85676: LIST
85677: LIST
85678: LIST
85679: LIST
85680: LIST
85681: LIST
85682: LIST
85683: LIST
85684: PUSH
85685: LD_INT 101
85687: PUSH
85688: LD_INT 102
85690: PUSH
85691: LD_INT 105
85693: PUSH
85694: LD_INT 106
85696: PUSH
85697: LD_INT 108
85699: PUSH
85700: EMPTY
85701: LIST
85702: LIST
85703: LIST
85704: LIST
85705: LIST
85706: PUSH
85707: EMPTY
85708: LIST
85709: LIST
85710: ST_TO_ADDR
85711: GO 88490
85713: LD_INT 3
85715: DOUBLE
85716: EQUAL
85717: IFTRUE 85721
85719: GO 85797
85721: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
85722: LD_ADDR_VAR 0 1
85726: PUSH
85727: LD_INT 2
85729: PUSH
85730: LD_INT 4
85732: PUSH
85733: LD_INT 5
85735: PUSH
85736: LD_INT 11
85738: PUSH
85739: LD_INT 12
85741: PUSH
85742: LD_INT 15
85744: PUSH
85745: LD_INT 16
85747: PUSH
85748: LD_INT 22
85750: PUSH
85751: LD_INT 26
85753: PUSH
85754: LD_INT 36
85756: PUSH
85757: EMPTY
85758: LIST
85759: LIST
85760: LIST
85761: LIST
85762: LIST
85763: LIST
85764: LIST
85765: LIST
85766: LIST
85767: LIST
85768: PUSH
85769: LD_INT 101
85771: PUSH
85772: LD_INT 102
85774: PUSH
85775: LD_INT 105
85777: PUSH
85778: LD_INT 106
85780: PUSH
85781: LD_INT 108
85783: PUSH
85784: EMPTY
85785: LIST
85786: LIST
85787: LIST
85788: LIST
85789: LIST
85790: PUSH
85791: EMPTY
85792: LIST
85793: LIST
85794: ST_TO_ADDR
85795: GO 88490
85797: LD_INT 4
85799: DOUBLE
85800: EQUAL
85801: IFTRUE 85805
85803: GO 85889
85805: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
85806: LD_ADDR_VAR 0 1
85810: PUSH
85811: LD_INT 2
85813: PUSH
85814: LD_INT 4
85816: PUSH
85817: LD_INT 5
85819: PUSH
85820: LD_INT 8
85822: PUSH
85823: LD_INT 11
85825: PUSH
85826: LD_INT 12
85828: PUSH
85829: LD_INT 15
85831: PUSH
85832: LD_INT 16
85834: PUSH
85835: LD_INT 22
85837: PUSH
85838: LD_INT 23
85840: PUSH
85841: LD_INT 26
85843: PUSH
85844: LD_INT 36
85846: PUSH
85847: EMPTY
85848: LIST
85849: LIST
85850: LIST
85851: LIST
85852: LIST
85853: LIST
85854: LIST
85855: LIST
85856: LIST
85857: LIST
85858: LIST
85859: LIST
85860: PUSH
85861: LD_INT 101
85863: PUSH
85864: LD_INT 102
85866: PUSH
85867: LD_INT 105
85869: PUSH
85870: LD_INT 106
85872: PUSH
85873: LD_INT 108
85875: PUSH
85876: EMPTY
85877: LIST
85878: LIST
85879: LIST
85880: LIST
85881: LIST
85882: PUSH
85883: EMPTY
85884: LIST
85885: LIST
85886: ST_TO_ADDR
85887: GO 88490
85889: LD_INT 5
85891: DOUBLE
85892: EQUAL
85893: IFTRUE 85897
85895: GO 85997
85897: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
85898: LD_ADDR_VAR 0 1
85902: PUSH
85903: LD_INT 2
85905: PUSH
85906: LD_INT 4
85908: PUSH
85909: LD_INT 5
85911: PUSH
85912: LD_INT 6
85914: PUSH
85915: LD_INT 8
85917: PUSH
85918: LD_INT 11
85920: PUSH
85921: LD_INT 12
85923: PUSH
85924: LD_INT 15
85926: PUSH
85927: LD_INT 16
85929: PUSH
85930: LD_INT 22
85932: PUSH
85933: LD_INT 23
85935: PUSH
85936: LD_INT 25
85938: PUSH
85939: LD_INT 26
85941: PUSH
85942: LD_INT 36
85944: PUSH
85945: EMPTY
85946: LIST
85947: LIST
85948: LIST
85949: LIST
85950: LIST
85951: LIST
85952: LIST
85953: LIST
85954: LIST
85955: LIST
85956: LIST
85957: LIST
85958: LIST
85959: LIST
85960: PUSH
85961: LD_INT 101
85963: PUSH
85964: LD_INT 102
85966: PUSH
85967: LD_INT 105
85969: PUSH
85970: LD_INT 106
85972: PUSH
85973: LD_INT 108
85975: PUSH
85976: LD_INT 109
85978: PUSH
85979: LD_INT 112
85981: PUSH
85982: EMPTY
85983: LIST
85984: LIST
85985: LIST
85986: LIST
85987: LIST
85988: LIST
85989: LIST
85990: PUSH
85991: EMPTY
85992: LIST
85993: LIST
85994: ST_TO_ADDR
85995: GO 88490
85997: LD_INT 6
85999: DOUBLE
86000: EQUAL
86001: IFTRUE 86005
86003: GO 86125
86005: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
86006: LD_ADDR_VAR 0 1
86010: PUSH
86011: LD_INT 2
86013: PUSH
86014: LD_INT 4
86016: PUSH
86017: LD_INT 5
86019: PUSH
86020: LD_INT 6
86022: PUSH
86023: LD_INT 8
86025: PUSH
86026: LD_INT 11
86028: PUSH
86029: LD_INT 12
86031: PUSH
86032: LD_INT 15
86034: PUSH
86035: LD_INT 16
86037: PUSH
86038: LD_INT 20
86040: PUSH
86041: LD_INT 21
86043: PUSH
86044: LD_INT 22
86046: PUSH
86047: LD_INT 23
86049: PUSH
86050: LD_INT 25
86052: PUSH
86053: LD_INT 26
86055: PUSH
86056: LD_INT 30
86058: PUSH
86059: LD_INT 31
86061: PUSH
86062: LD_INT 32
86064: PUSH
86065: LD_INT 36
86067: PUSH
86068: EMPTY
86069: LIST
86070: LIST
86071: LIST
86072: LIST
86073: LIST
86074: LIST
86075: LIST
86076: LIST
86077: LIST
86078: LIST
86079: LIST
86080: LIST
86081: LIST
86082: LIST
86083: LIST
86084: LIST
86085: LIST
86086: LIST
86087: LIST
86088: PUSH
86089: LD_INT 101
86091: PUSH
86092: LD_INT 102
86094: PUSH
86095: LD_INT 105
86097: PUSH
86098: LD_INT 106
86100: PUSH
86101: LD_INT 108
86103: PUSH
86104: LD_INT 109
86106: PUSH
86107: LD_INT 112
86109: PUSH
86110: EMPTY
86111: LIST
86112: LIST
86113: LIST
86114: LIST
86115: LIST
86116: LIST
86117: LIST
86118: PUSH
86119: EMPTY
86120: LIST
86121: LIST
86122: ST_TO_ADDR
86123: GO 88490
86125: LD_INT 7
86127: DOUBLE
86128: EQUAL
86129: IFTRUE 86133
86131: GO 86233
86133: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
86134: LD_ADDR_VAR 0 1
86138: PUSH
86139: LD_INT 2
86141: PUSH
86142: LD_INT 4
86144: PUSH
86145: LD_INT 5
86147: PUSH
86148: LD_INT 7
86150: PUSH
86151: LD_INT 11
86153: PUSH
86154: LD_INT 12
86156: PUSH
86157: LD_INT 15
86159: PUSH
86160: LD_INT 16
86162: PUSH
86163: LD_INT 20
86165: PUSH
86166: LD_INT 21
86168: PUSH
86169: LD_INT 22
86171: PUSH
86172: LD_INT 23
86174: PUSH
86175: LD_INT 25
86177: PUSH
86178: LD_INT 26
86180: PUSH
86181: EMPTY
86182: LIST
86183: LIST
86184: LIST
86185: LIST
86186: LIST
86187: LIST
86188: LIST
86189: LIST
86190: LIST
86191: LIST
86192: LIST
86193: LIST
86194: LIST
86195: LIST
86196: PUSH
86197: LD_INT 101
86199: PUSH
86200: LD_INT 102
86202: PUSH
86203: LD_INT 103
86205: PUSH
86206: LD_INT 105
86208: PUSH
86209: LD_INT 106
86211: PUSH
86212: LD_INT 108
86214: PUSH
86215: LD_INT 112
86217: PUSH
86218: EMPTY
86219: LIST
86220: LIST
86221: LIST
86222: LIST
86223: LIST
86224: LIST
86225: LIST
86226: PUSH
86227: EMPTY
86228: LIST
86229: LIST
86230: ST_TO_ADDR
86231: GO 88490
86233: LD_INT 8
86235: DOUBLE
86236: EQUAL
86237: IFTRUE 86241
86239: GO 86369
86241: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
86242: LD_ADDR_VAR 0 1
86246: PUSH
86247: LD_INT 2
86249: PUSH
86250: LD_INT 4
86252: PUSH
86253: LD_INT 5
86255: PUSH
86256: LD_INT 6
86258: PUSH
86259: LD_INT 7
86261: PUSH
86262: LD_INT 8
86264: PUSH
86265: LD_INT 11
86267: PUSH
86268: LD_INT 12
86270: PUSH
86271: LD_INT 15
86273: PUSH
86274: LD_INT 16
86276: PUSH
86277: LD_INT 20
86279: PUSH
86280: LD_INT 21
86282: PUSH
86283: LD_INT 22
86285: PUSH
86286: LD_INT 23
86288: PUSH
86289: LD_INT 25
86291: PUSH
86292: LD_INT 26
86294: PUSH
86295: LD_INT 30
86297: PUSH
86298: LD_INT 31
86300: PUSH
86301: LD_INT 32
86303: PUSH
86304: LD_INT 36
86306: PUSH
86307: EMPTY
86308: LIST
86309: LIST
86310: LIST
86311: LIST
86312: LIST
86313: LIST
86314: LIST
86315: LIST
86316: LIST
86317: LIST
86318: LIST
86319: LIST
86320: LIST
86321: LIST
86322: LIST
86323: LIST
86324: LIST
86325: LIST
86326: LIST
86327: LIST
86328: PUSH
86329: LD_INT 101
86331: PUSH
86332: LD_INT 102
86334: PUSH
86335: LD_INT 103
86337: PUSH
86338: LD_INT 105
86340: PUSH
86341: LD_INT 106
86343: PUSH
86344: LD_INT 108
86346: PUSH
86347: LD_INT 109
86349: PUSH
86350: LD_INT 112
86352: PUSH
86353: EMPTY
86354: LIST
86355: LIST
86356: LIST
86357: LIST
86358: LIST
86359: LIST
86360: LIST
86361: LIST
86362: PUSH
86363: EMPTY
86364: LIST
86365: LIST
86366: ST_TO_ADDR
86367: GO 88490
86369: LD_INT 9
86371: DOUBLE
86372: EQUAL
86373: IFTRUE 86377
86375: GO 86513
86377: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
86378: LD_ADDR_VAR 0 1
86382: PUSH
86383: LD_INT 2
86385: PUSH
86386: LD_INT 4
86388: PUSH
86389: LD_INT 5
86391: PUSH
86392: LD_INT 6
86394: PUSH
86395: LD_INT 7
86397: PUSH
86398: LD_INT 8
86400: PUSH
86401: LD_INT 11
86403: PUSH
86404: LD_INT 12
86406: PUSH
86407: LD_INT 15
86409: PUSH
86410: LD_INT 16
86412: PUSH
86413: LD_INT 20
86415: PUSH
86416: LD_INT 21
86418: PUSH
86419: LD_INT 22
86421: PUSH
86422: LD_INT 23
86424: PUSH
86425: LD_INT 25
86427: PUSH
86428: LD_INT 26
86430: PUSH
86431: LD_INT 28
86433: PUSH
86434: LD_INT 30
86436: PUSH
86437: LD_INT 31
86439: PUSH
86440: LD_INT 32
86442: PUSH
86443: LD_INT 36
86445: PUSH
86446: EMPTY
86447: LIST
86448: LIST
86449: LIST
86450: LIST
86451: LIST
86452: LIST
86453: LIST
86454: LIST
86455: LIST
86456: LIST
86457: LIST
86458: LIST
86459: LIST
86460: LIST
86461: LIST
86462: LIST
86463: LIST
86464: LIST
86465: LIST
86466: LIST
86467: LIST
86468: PUSH
86469: LD_INT 101
86471: PUSH
86472: LD_INT 102
86474: PUSH
86475: LD_INT 103
86477: PUSH
86478: LD_INT 105
86480: PUSH
86481: LD_INT 106
86483: PUSH
86484: LD_INT 108
86486: PUSH
86487: LD_INT 109
86489: PUSH
86490: LD_INT 112
86492: PUSH
86493: LD_INT 114
86495: PUSH
86496: EMPTY
86497: LIST
86498: LIST
86499: LIST
86500: LIST
86501: LIST
86502: LIST
86503: LIST
86504: LIST
86505: LIST
86506: PUSH
86507: EMPTY
86508: LIST
86509: LIST
86510: ST_TO_ADDR
86511: GO 88490
86513: LD_INT 10
86515: DOUBLE
86516: EQUAL
86517: IFTRUE 86521
86519: GO 86705
86521: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
86522: LD_ADDR_VAR 0 1
86526: PUSH
86527: LD_INT 2
86529: PUSH
86530: LD_INT 4
86532: PUSH
86533: LD_INT 5
86535: PUSH
86536: LD_INT 6
86538: PUSH
86539: LD_INT 7
86541: PUSH
86542: LD_INT 8
86544: PUSH
86545: LD_INT 9
86547: PUSH
86548: LD_INT 10
86550: PUSH
86551: LD_INT 11
86553: PUSH
86554: LD_INT 12
86556: PUSH
86557: LD_INT 13
86559: PUSH
86560: LD_INT 14
86562: PUSH
86563: LD_INT 15
86565: PUSH
86566: LD_INT 16
86568: PUSH
86569: LD_INT 17
86571: PUSH
86572: LD_INT 18
86574: PUSH
86575: LD_INT 19
86577: PUSH
86578: LD_INT 20
86580: PUSH
86581: LD_INT 21
86583: PUSH
86584: LD_INT 22
86586: PUSH
86587: LD_INT 23
86589: PUSH
86590: LD_INT 24
86592: PUSH
86593: LD_INT 25
86595: PUSH
86596: LD_INT 26
86598: PUSH
86599: LD_INT 28
86601: PUSH
86602: LD_INT 30
86604: PUSH
86605: LD_INT 31
86607: PUSH
86608: LD_INT 32
86610: PUSH
86611: LD_INT 36
86613: PUSH
86614: EMPTY
86615: LIST
86616: LIST
86617: LIST
86618: LIST
86619: LIST
86620: LIST
86621: LIST
86622: LIST
86623: LIST
86624: LIST
86625: LIST
86626: LIST
86627: LIST
86628: LIST
86629: LIST
86630: LIST
86631: LIST
86632: LIST
86633: LIST
86634: LIST
86635: LIST
86636: LIST
86637: LIST
86638: LIST
86639: LIST
86640: LIST
86641: LIST
86642: LIST
86643: LIST
86644: PUSH
86645: LD_INT 101
86647: PUSH
86648: LD_INT 102
86650: PUSH
86651: LD_INT 103
86653: PUSH
86654: LD_INT 104
86656: PUSH
86657: LD_INT 105
86659: PUSH
86660: LD_INT 106
86662: PUSH
86663: LD_INT 107
86665: PUSH
86666: LD_INT 108
86668: PUSH
86669: LD_INT 109
86671: PUSH
86672: LD_INT 110
86674: PUSH
86675: LD_INT 111
86677: PUSH
86678: LD_INT 112
86680: PUSH
86681: LD_INT 114
86683: PUSH
86684: EMPTY
86685: LIST
86686: LIST
86687: LIST
86688: LIST
86689: LIST
86690: LIST
86691: LIST
86692: LIST
86693: LIST
86694: LIST
86695: LIST
86696: LIST
86697: LIST
86698: PUSH
86699: EMPTY
86700: LIST
86701: LIST
86702: ST_TO_ADDR
86703: GO 88490
86705: LD_INT 11
86707: DOUBLE
86708: EQUAL
86709: IFTRUE 86713
86711: GO 86905
86713: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
86714: LD_ADDR_VAR 0 1
86718: PUSH
86719: LD_INT 2
86721: PUSH
86722: LD_INT 3
86724: PUSH
86725: LD_INT 4
86727: PUSH
86728: LD_INT 5
86730: PUSH
86731: LD_INT 6
86733: PUSH
86734: LD_INT 7
86736: PUSH
86737: LD_INT 8
86739: PUSH
86740: LD_INT 9
86742: PUSH
86743: LD_INT 10
86745: PUSH
86746: LD_INT 11
86748: PUSH
86749: LD_INT 12
86751: PUSH
86752: LD_INT 13
86754: PUSH
86755: LD_INT 14
86757: PUSH
86758: LD_INT 15
86760: PUSH
86761: LD_INT 16
86763: PUSH
86764: LD_INT 17
86766: PUSH
86767: LD_INT 18
86769: PUSH
86770: LD_INT 19
86772: PUSH
86773: LD_INT 20
86775: PUSH
86776: LD_INT 21
86778: PUSH
86779: LD_INT 22
86781: PUSH
86782: LD_INT 23
86784: PUSH
86785: LD_INT 24
86787: PUSH
86788: LD_INT 25
86790: PUSH
86791: LD_INT 26
86793: PUSH
86794: LD_INT 28
86796: PUSH
86797: LD_INT 30
86799: PUSH
86800: LD_INT 31
86802: PUSH
86803: LD_INT 32
86805: PUSH
86806: LD_INT 34
86808: PUSH
86809: LD_INT 36
86811: PUSH
86812: EMPTY
86813: LIST
86814: LIST
86815: LIST
86816: LIST
86817: LIST
86818: LIST
86819: LIST
86820: LIST
86821: LIST
86822: LIST
86823: LIST
86824: LIST
86825: LIST
86826: LIST
86827: LIST
86828: LIST
86829: LIST
86830: LIST
86831: LIST
86832: LIST
86833: LIST
86834: LIST
86835: LIST
86836: LIST
86837: LIST
86838: LIST
86839: LIST
86840: LIST
86841: LIST
86842: LIST
86843: LIST
86844: PUSH
86845: LD_INT 101
86847: PUSH
86848: LD_INT 102
86850: PUSH
86851: LD_INT 103
86853: PUSH
86854: LD_INT 104
86856: PUSH
86857: LD_INT 105
86859: PUSH
86860: LD_INT 106
86862: PUSH
86863: LD_INT 107
86865: PUSH
86866: LD_INT 108
86868: PUSH
86869: LD_INT 109
86871: PUSH
86872: LD_INT 110
86874: PUSH
86875: LD_INT 111
86877: PUSH
86878: LD_INT 112
86880: PUSH
86881: LD_INT 114
86883: PUSH
86884: EMPTY
86885: LIST
86886: LIST
86887: LIST
86888: LIST
86889: LIST
86890: LIST
86891: LIST
86892: LIST
86893: LIST
86894: LIST
86895: LIST
86896: LIST
86897: LIST
86898: PUSH
86899: EMPTY
86900: LIST
86901: LIST
86902: ST_TO_ADDR
86903: GO 88490
86905: LD_INT 12
86907: DOUBLE
86908: EQUAL
86909: IFTRUE 86913
86911: GO 87121
86913: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
86914: LD_ADDR_VAR 0 1
86918: PUSH
86919: LD_INT 1
86921: PUSH
86922: LD_INT 2
86924: PUSH
86925: LD_INT 3
86927: PUSH
86928: LD_INT 4
86930: PUSH
86931: LD_INT 5
86933: PUSH
86934: LD_INT 6
86936: PUSH
86937: LD_INT 7
86939: PUSH
86940: LD_INT 8
86942: PUSH
86943: LD_INT 9
86945: PUSH
86946: LD_INT 10
86948: PUSH
86949: LD_INT 11
86951: PUSH
86952: LD_INT 12
86954: PUSH
86955: LD_INT 13
86957: PUSH
86958: LD_INT 14
86960: PUSH
86961: LD_INT 15
86963: PUSH
86964: LD_INT 16
86966: PUSH
86967: LD_INT 17
86969: PUSH
86970: LD_INT 18
86972: PUSH
86973: LD_INT 19
86975: PUSH
86976: LD_INT 20
86978: PUSH
86979: LD_INT 21
86981: PUSH
86982: LD_INT 22
86984: PUSH
86985: LD_INT 23
86987: PUSH
86988: LD_INT 24
86990: PUSH
86991: LD_INT 25
86993: PUSH
86994: LD_INT 26
86996: PUSH
86997: LD_INT 27
86999: PUSH
87000: LD_INT 28
87002: PUSH
87003: LD_INT 30
87005: PUSH
87006: LD_INT 31
87008: PUSH
87009: LD_INT 32
87011: PUSH
87012: LD_INT 33
87014: PUSH
87015: LD_INT 34
87017: PUSH
87018: LD_INT 36
87020: PUSH
87021: EMPTY
87022: LIST
87023: LIST
87024: LIST
87025: LIST
87026: LIST
87027: LIST
87028: LIST
87029: LIST
87030: LIST
87031: LIST
87032: LIST
87033: LIST
87034: LIST
87035: LIST
87036: LIST
87037: LIST
87038: LIST
87039: LIST
87040: LIST
87041: LIST
87042: LIST
87043: LIST
87044: LIST
87045: LIST
87046: LIST
87047: LIST
87048: LIST
87049: LIST
87050: LIST
87051: LIST
87052: LIST
87053: LIST
87054: LIST
87055: LIST
87056: PUSH
87057: LD_INT 101
87059: PUSH
87060: LD_INT 102
87062: PUSH
87063: LD_INT 103
87065: PUSH
87066: LD_INT 104
87068: PUSH
87069: LD_INT 105
87071: PUSH
87072: LD_INT 106
87074: PUSH
87075: LD_INT 107
87077: PUSH
87078: LD_INT 108
87080: PUSH
87081: LD_INT 109
87083: PUSH
87084: LD_INT 110
87086: PUSH
87087: LD_INT 111
87089: PUSH
87090: LD_INT 112
87092: PUSH
87093: LD_INT 113
87095: PUSH
87096: LD_INT 114
87098: PUSH
87099: EMPTY
87100: LIST
87101: LIST
87102: LIST
87103: LIST
87104: LIST
87105: LIST
87106: LIST
87107: LIST
87108: LIST
87109: LIST
87110: LIST
87111: LIST
87112: LIST
87113: LIST
87114: PUSH
87115: EMPTY
87116: LIST
87117: LIST
87118: ST_TO_ADDR
87119: GO 88490
87121: LD_INT 13
87123: DOUBLE
87124: EQUAL
87125: IFTRUE 87129
87127: GO 87325
87129: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
87130: LD_ADDR_VAR 0 1
87134: PUSH
87135: LD_INT 1
87137: PUSH
87138: LD_INT 2
87140: PUSH
87141: LD_INT 3
87143: PUSH
87144: LD_INT 4
87146: PUSH
87147: LD_INT 5
87149: PUSH
87150: LD_INT 8
87152: PUSH
87153: LD_INT 9
87155: PUSH
87156: LD_INT 10
87158: PUSH
87159: LD_INT 11
87161: PUSH
87162: LD_INT 12
87164: PUSH
87165: LD_INT 14
87167: PUSH
87168: LD_INT 15
87170: PUSH
87171: LD_INT 16
87173: PUSH
87174: LD_INT 17
87176: PUSH
87177: LD_INT 18
87179: PUSH
87180: LD_INT 19
87182: PUSH
87183: LD_INT 20
87185: PUSH
87186: LD_INT 21
87188: PUSH
87189: LD_INT 22
87191: PUSH
87192: LD_INT 23
87194: PUSH
87195: LD_INT 24
87197: PUSH
87198: LD_INT 25
87200: PUSH
87201: LD_INT 26
87203: PUSH
87204: LD_INT 27
87206: PUSH
87207: LD_INT 28
87209: PUSH
87210: LD_INT 30
87212: PUSH
87213: LD_INT 31
87215: PUSH
87216: LD_INT 32
87218: PUSH
87219: LD_INT 33
87221: PUSH
87222: LD_INT 34
87224: PUSH
87225: LD_INT 36
87227: PUSH
87228: EMPTY
87229: LIST
87230: LIST
87231: LIST
87232: LIST
87233: LIST
87234: LIST
87235: LIST
87236: LIST
87237: LIST
87238: LIST
87239: LIST
87240: LIST
87241: LIST
87242: LIST
87243: LIST
87244: LIST
87245: LIST
87246: LIST
87247: LIST
87248: LIST
87249: LIST
87250: LIST
87251: LIST
87252: LIST
87253: LIST
87254: LIST
87255: LIST
87256: LIST
87257: LIST
87258: LIST
87259: LIST
87260: PUSH
87261: LD_INT 101
87263: PUSH
87264: LD_INT 102
87266: PUSH
87267: LD_INT 103
87269: PUSH
87270: LD_INT 104
87272: PUSH
87273: LD_INT 105
87275: PUSH
87276: LD_INT 106
87278: PUSH
87279: LD_INT 107
87281: PUSH
87282: LD_INT 108
87284: PUSH
87285: LD_INT 109
87287: PUSH
87288: LD_INT 110
87290: PUSH
87291: LD_INT 111
87293: PUSH
87294: LD_INT 112
87296: PUSH
87297: LD_INT 113
87299: PUSH
87300: LD_INT 114
87302: PUSH
87303: EMPTY
87304: LIST
87305: LIST
87306: LIST
87307: LIST
87308: LIST
87309: LIST
87310: LIST
87311: LIST
87312: LIST
87313: LIST
87314: LIST
87315: LIST
87316: LIST
87317: LIST
87318: PUSH
87319: EMPTY
87320: LIST
87321: LIST
87322: ST_TO_ADDR
87323: GO 88490
87325: LD_INT 14
87327: DOUBLE
87328: EQUAL
87329: IFTRUE 87333
87331: GO 87545
87333: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
87334: LD_ADDR_VAR 0 1
87338: PUSH
87339: LD_INT 1
87341: PUSH
87342: LD_INT 2
87344: PUSH
87345: LD_INT 3
87347: PUSH
87348: LD_INT 4
87350: PUSH
87351: LD_INT 5
87353: PUSH
87354: LD_INT 6
87356: PUSH
87357: LD_INT 7
87359: PUSH
87360: LD_INT 8
87362: PUSH
87363: LD_INT 9
87365: PUSH
87366: LD_INT 10
87368: PUSH
87369: LD_INT 11
87371: PUSH
87372: LD_INT 12
87374: PUSH
87375: LD_INT 13
87377: PUSH
87378: LD_INT 14
87380: PUSH
87381: LD_INT 15
87383: PUSH
87384: LD_INT 16
87386: PUSH
87387: LD_INT 17
87389: PUSH
87390: LD_INT 18
87392: PUSH
87393: LD_INT 19
87395: PUSH
87396: LD_INT 20
87398: PUSH
87399: LD_INT 21
87401: PUSH
87402: LD_INT 22
87404: PUSH
87405: LD_INT 23
87407: PUSH
87408: LD_INT 24
87410: PUSH
87411: LD_INT 25
87413: PUSH
87414: LD_INT 26
87416: PUSH
87417: LD_INT 27
87419: PUSH
87420: LD_INT 28
87422: PUSH
87423: LD_INT 29
87425: PUSH
87426: LD_INT 30
87428: PUSH
87429: LD_INT 31
87431: PUSH
87432: LD_INT 32
87434: PUSH
87435: LD_INT 33
87437: PUSH
87438: LD_INT 34
87440: PUSH
87441: LD_INT 36
87443: PUSH
87444: EMPTY
87445: LIST
87446: LIST
87447: LIST
87448: LIST
87449: LIST
87450: LIST
87451: LIST
87452: LIST
87453: LIST
87454: LIST
87455: LIST
87456: LIST
87457: LIST
87458: LIST
87459: LIST
87460: LIST
87461: LIST
87462: LIST
87463: LIST
87464: LIST
87465: LIST
87466: LIST
87467: LIST
87468: LIST
87469: LIST
87470: LIST
87471: LIST
87472: LIST
87473: LIST
87474: LIST
87475: LIST
87476: LIST
87477: LIST
87478: LIST
87479: LIST
87480: PUSH
87481: LD_INT 101
87483: PUSH
87484: LD_INT 102
87486: PUSH
87487: LD_INT 103
87489: PUSH
87490: LD_INT 104
87492: PUSH
87493: LD_INT 105
87495: PUSH
87496: LD_INT 106
87498: PUSH
87499: LD_INT 107
87501: PUSH
87502: LD_INT 108
87504: PUSH
87505: LD_INT 109
87507: PUSH
87508: LD_INT 110
87510: PUSH
87511: LD_INT 111
87513: PUSH
87514: LD_INT 112
87516: PUSH
87517: LD_INT 113
87519: PUSH
87520: LD_INT 114
87522: PUSH
87523: EMPTY
87524: LIST
87525: LIST
87526: LIST
87527: LIST
87528: LIST
87529: LIST
87530: LIST
87531: LIST
87532: LIST
87533: LIST
87534: LIST
87535: LIST
87536: LIST
87537: LIST
87538: PUSH
87539: EMPTY
87540: LIST
87541: LIST
87542: ST_TO_ADDR
87543: GO 88490
87545: LD_INT 15
87547: DOUBLE
87548: EQUAL
87549: IFTRUE 87553
87551: GO 87765
87553: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
87554: LD_ADDR_VAR 0 1
87558: PUSH
87559: LD_INT 1
87561: PUSH
87562: LD_INT 2
87564: PUSH
87565: LD_INT 3
87567: PUSH
87568: LD_INT 4
87570: PUSH
87571: LD_INT 5
87573: PUSH
87574: LD_INT 6
87576: PUSH
87577: LD_INT 7
87579: PUSH
87580: LD_INT 8
87582: PUSH
87583: LD_INT 9
87585: PUSH
87586: LD_INT 10
87588: PUSH
87589: LD_INT 11
87591: PUSH
87592: LD_INT 12
87594: PUSH
87595: LD_INT 13
87597: PUSH
87598: LD_INT 14
87600: PUSH
87601: LD_INT 15
87603: PUSH
87604: LD_INT 16
87606: PUSH
87607: LD_INT 17
87609: PUSH
87610: LD_INT 18
87612: PUSH
87613: LD_INT 19
87615: PUSH
87616: LD_INT 20
87618: PUSH
87619: LD_INT 21
87621: PUSH
87622: LD_INT 22
87624: PUSH
87625: LD_INT 23
87627: PUSH
87628: LD_INT 24
87630: PUSH
87631: LD_INT 25
87633: PUSH
87634: LD_INT 26
87636: PUSH
87637: LD_INT 27
87639: PUSH
87640: LD_INT 28
87642: PUSH
87643: LD_INT 29
87645: PUSH
87646: LD_INT 30
87648: PUSH
87649: LD_INT 31
87651: PUSH
87652: LD_INT 32
87654: PUSH
87655: LD_INT 33
87657: PUSH
87658: LD_INT 34
87660: PUSH
87661: LD_INT 36
87663: PUSH
87664: EMPTY
87665: LIST
87666: LIST
87667: LIST
87668: LIST
87669: LIST
87670: LIST
87671: LIST
87672: LIST
87673: LIST
87674: LIST
87675: LIST
87676: LIST
87677: LIST
87678: LIST
87679: LIST
87680: LIST
87681: LIST
87682: LIST
87683: LIST
87684: LIST
87685: LIST
87686: LIST
87687: LIST
87688: LIST
87689: LIST
87690: LIST
87691: LIST
87692: LIST
87693: LIST
87694: LIST
87695: LIST
87696: LIST
87697: LIST
87698: LIST
87699: LIST
87700: PUSH
87701: LD_INT 101
87703: PUSH
87704: LD_INT 102
87706: PUSH
87707: LD_INT 103
87709: PUSH
87710: LD_INT 104
87712: PUSH
87713: LD_INT 105
87715: PUSH
87716: LD_INT 106
87718: PUSH
87719: LD_INT 107
87721: PUSH
87722: LD_INT 108
87724: PUSH
87725: LD_INT 109
87727: PUSH
87728: LD_INT 110
87730: PUSH
87731: LD_INT 111
87733: PUSH
87734: LD_INT 112
87736: PUSH
87737: LD_INT 113
87739: PUSH
87740: LD_INT 114
87742: PUSH
87743: EMPTY
87744: LIST
87745: LIST
87746: LIST
87747: LIST
87748: LIST
87749: LIST
87750: LIST
87751: LIST
87752: LIST
87753: LIST
87754: LIST
87755: LIST
87756: LIST
87757: LIST
87758: PUSH
87759: EMPTY
87760: LIST
87761: LIST
87762: ST_TO_ADDR
87763: GO 88490
87765: LD_INT 16
87767: DOUBLE
87768: EQUAL
87769: IFTRUE 87773
87771: GO 87897
87773: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
87774: LD_ADDR_VAR 0 1
87778: PUSH
87779: LD_INT 2
87781: PUSH
87782: LD_INT 4
87784: PUSH
87785: LD_INT 5
87787: PUSH
87788: LD_INT 7
87790: PUSH
87791: LD_INT 11
87793: PUSH
87794: LD_INT 12
87796: PUSH
87797: LD_INT 15
87799: PUSH
87800: LD_INT 16
87802: PUSH
87803: LD_INT 20
87805: PUSH
87806: LD_INT 21
87808: PUSH
87809: LD_INT 22
87811: PUSH
87812: LD_INT 23
87814: PUSH
87815: LD_INT 25
87817: PUSH
87818: LD_INT 26
87820: PUSH
87821: LD_INT 30
87823: PUSH
87824: LD_INT 31
87826: PUSH
87827: LD_INT 32
87829: PUSH
87830: LD_INT 33
87832: PUSH
87833: LD_INT 34
87835: PUSH
87836: EMPTY
87837: LIST
87838: LIST
87839: LIST
87840: LIST
87841: LIST
87842: LIST
87843: LIST
87844: LIST
87845: LIST
87846: LIST
87847: LIST
87848: LIST
87849: LIST
87850: LIST
87851: LIST
87852: LIST
87853: LIST
87854: LIST
87855: LIST
87856: PUSH
87857: LD_INT 101
87859: PUSH
87860: LD_INT 102
87862: PUSH
87863: LD_INT 103
87865: PUSH
87866: LD_INT 106
87868: PUSH
87869: LD_INT 108
87871: PUSH
87872: LD_INT 112
87874: PUSH
87875: LD_INT 113
87877: PUSH
87878: LD_INT 114
87880: PUSH
87881: EMPTY
87882: LIST
87883: LIST
87884: LIST
87885: LIST
87886: LIST
87887: LIST
87888: LIST
87889: LIST
87890: PUSH
87891: EMPTY
87892: LIST
87893: LIST
87894: ST_TO_ADDR
87895: GO 88490
87897: LD_INT 17
87899: DOUBLE
87900: EQUAL
87901: IFTRUE 87905
87903: GO 88117
87905: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
87906: LD_ADDR_VAR 0 1
87910: PUSH
87911: LD_INT 1
87913: PUSH
87914: LD_INT 2
87916: PUSH
87917: LD_INT 3
87919: PUSH
87920: LD_INT 4
87922: PUSH
87923: LD_INT 5
87925: PUSH
87926: LD_INT 6
87928: PUSH
87929: LD_INT 7
87931: PUSH
87932: LD_INT 8
87934: PUSH
87935: LD_INT 9
87937: PUSH
87938: LD_INT 10
87940: PUSH
87941: LD_INT 11
87943: PUSH
87944: LD_INT 12
87946: PUSH
87947: LD_INT 13
87949: PUSH
87950: LD_INT 14
87952: PUSH
87953: LD_INT 15
87955: PUSH
87956: LD_INT 16
87958: PUSH
87959: LD_INT 17
87961: PUSH
87962: LD_INT 18
87964: PUSH
87965: LD_INT 19
87967: PUSH
87968: LD_INT 20
87970: PUSH
87971: LD_INT 21
87973: PUSH
87974: LD_INT 22
87976: PUSH
87977: LD_INT 23
87979: PUSH
87980: LD_INT 24
87982: PUSH
87983: LD_INT 25
87985: PUSH
87986: LD_INT 26
87988: PUSH
87989: LD_INT 27
87991: PUSH
87992: LD_INT 28
87994: PUSH
87995: LD_INT 29
87997: PUSH
87998: LD_INT 30
88000: PUSH
88001: LD_INT 31
88003: PUSH
88004: LD_INT 32
88006: PUSH
88007: LD_INT 33
88009: PUSH
88010: LD_INT 34
88012: PUSH
88013: LD_INT 36
88015: PUSH
88016: EMPTY
88017: LIST
88018: LIST
88019: LIST
88020: LIST
88021: LIST
88022: LIST
88023: LIST
88024: LIST
88025: LIST
88026: LIST
88027: LIST
88028: LIST
88029: LIST
88030: LIST
88031: LIST
88032: LIST
88033: LIST
88034: LIST
88035: LIST
88036: LIST
88037: LIST
88038: LIST
88039: LIST
88040: LIST
88041: LIST
88042: LIST
88043: LIST
88044: LIST
88045: LIST
88046: LIST
88047: LIST
88048: LIST
88049: LIST
88050: LIST
88051: LIST
88052: PUSH
88053: LD_INT 101
88055: PUSH
88056: LD_INT 102
88058: PUSH
88059: LD_INT 103
88061: PUSH
88062: LD_INT 104
88064: PUSH
88065: LD_INT 105
88067: PUSH
88068: LD_INT 106
88070: PUSH
88071: LD_INT 107
88073: PUSH
88074: LD_INT 108
88076: PUSH
88077: LD_INT 109
88079: PUSH
88080: LD_INT 110
88082: PUSH
88083: LD_INT 111
88085: PUSH
88086: LD_INT 112
88088: PUSH
88089: LD_INT 113
88091: PUSH
88092: LD_INT 114
88094: PUSH
88095: EMPTY
88096: LIST
88097: LIST
88098: LIST
88099: LIST
88100: LIST
88101: LIST
88102: LIST
88103: LIST
88104: LIST
88105: LIST
88106: LIST
88107: LIST
88108: LIST
88109: LIST
88110: PUSH
88111: EMPTY
88112: LIST
88113: LIST
88114: ST_TO_ADDR
88115: GO 88490
88117: LD_INT 18
88119: DOUBLE
88120: EQUAL
88121: IFTRUE 88125
88123: GO 88261
88125: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
88126: LD_ADDR_VAR 0 1
88130: PUSH
88131: LD_INT 2
88133: PUSH
88134: LD_INT 4
88136: PUSH
88137: LD_INT 5
88139: PUSH
88140: LD_INT 7
88142: PUSH
88143: LD_INT 11
88145: PUSH
88146: LD_INT 12
88148: PUSH
88149: LD_INT 15
88151: PUSH
88152: LD_INT 16
88154: PUSH
88155: LD_INT 20
88157: PUSH
88158: LD_INT 21
88160: PUSH
88161: LD_INT 22
88163: PUSH
88164: LD_INT 23
88166: PUSH
88167: LD_INT 25
88169: PUSH
88170: LD_INT 26
88172: PUSH
88173: LD_INT 30
88175: PUSH
88176: LD_INT 31
88178: PUSH
88179: LD_INT 32
88181: PUSH
88182: LD_INT 33
88184: PUSH
88185: LD_INT 34
88187: PUSH
88188: LD_INT 35
88190: PUSH
88191: LD_INT 36
88193: PUSH
88194: EMPTY
88195: LIST
88196: LIST
88197: LIST
88198: LIST
88199: LIST
88200: LIST
88201: LIST
88202: LIST
88203: LIST
88204: LIST
88205: LIST
88206: LIST
88207: LIST
88208: LIST
88209: LIST
88210: LIST
88211: LIST
88212: LIST
88213: LIST
88214: LIST
88215: LIST
88216: PUSH
88217: LD_INT 101
88219: PUSH
88220: LD_INT 102
88222: PUSH
88223: LD_INT 103
88225: PUSH
88226: LD_INT 106
88228: PUSH
88229: LD_INT 108
88231: PUSH
88232: LD_INT 112
88234: PUSH
88235: LD_INT 113
88237: PUSH
88238: LD_INT 114
88240: PUSH
88241: LD_INT 115
88243: PUSH
88244: EMPTY
88245: LIST
88246: LIST
88247: LIST
88248: LIST
88249: LIST
88250: LIST
88251: LIST
88252: LIST
88253: LIST
88254: PUSH
88255: EMPTY
88256: LIST
88257: LIST
88258: ST_TO_ADDR
88259: GO 88490
88261: LD_INT 19
88263: DOUBLE
88264: EQUAL
88265: IFTRUE 88269
88267: GO 88489
88269: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
88270: LD_ADDR_VAR 0 1
88274: PUSH
88275: LD_INT 1
88277: PUSH
88278: LD_INT 2
88280: PUSH
88281: LD_INT 3
88283: PUSH
88284: LD_INT 4
88286: PUSH
88287: LD_INT 5
88289: PUSH
88290: LD_INT 6
88292: PUSH
88293: LD_INT 7
88295: PUSH
88296: LD_INT 8
88298: PUSH
88299: LD_INT 9
88301: PUSH
88302: LD_INT 10
88304: PUSH
88305: LD_INT 11
88307: PUSH
88308: LD_INT 12
88310: PUSH
88311: LD_INT 13
88313: PUSH
88314: LD_INT 14
88316: PUSH
88317: LD_INT 15
88319: PUSH
88320: LD_INT 16
88322: PUSH
88323: LD_INT 17
88325: PUSH
88326: LD_INT 18
88328: PUSH
88329: LD_INT 19
88331: PUSH
88332: LD_INT 20
88334: PUSH
88335: LD_INT 21
88337: PUSH
88338: LD_INT 22
88340: PUSH
88341: LD_INT 23
88343: PUSH
88344: LD_INT 24
88346: PUSH
88347: LD_INT 25
88349: PUSH
88350: LD_INT 26
88352: PUSH
88353: LD_INT 27
88355: PUSH
88356: LD_INT 28
88358: PUSH
88359: LD_INT 29
88361: PUSH
88362: LD_INT 30
88364: PUSH
88365: LD_INT 31
88367: PUSH
88368: LD_INT 32
88370: PUSH
88371: LD_INT 33
88373: PUSH
88374: LD_INT 34
88376: PUSH
88377: LD_INT 35
88379: PUSH
88380: LD_INT 36
88382: PUSH
88383: EMPTY
88384: LIST
88385: LIST
88386: LIST
88387: LIST
88388: LIST
88389: LIST
88390: LIST
88391: LIST
88392: LIST
88393: LIST
88394: LIST
88395: LIST
88396: LIST
88397: LIST
88398: LIST
88399: LIST
88400: LIST
88401: LIST
88402: LIST
88403: LIST
88404: LIST
88405: LIST
88406: LIST
88407: LIST
88408: LIST
88409: LIST
88410: LIST
88411: LIST
88412: LIST
88413: LIST
88414: LIST
88415: LIST
88416: LIST
88417: LIST
88418: LIST
88419: LIST
88420: PUSH
88421: LD_INT 101
88423: PUSH
88424: LD_INT 102
88426: PUSH
88427: LD_INT 103
88429: PUSH
88430: LD_INT 104
88432: PUSH
88433: LD_INT 105
88435: PUSH
88436: LD_INT 106
88438: PUSH
88439: LD_INT 107
88441: PUSH
88442: LD_INT 108
88444: PUSH
88445: LD_INT 109
88447: PUSH
88448: LD_INT 110
88450: PUSH
88451: LD_INT 111
88453: PUSH
88454: LD_INT 112
88456: PUSH
88457: LD_INT 113
88459: PUSH
88460: LD_INT 114
88462: PUSH
88463: LD_INT 115
88465: PUSH
88466: EMPTY
88467: LIST
88468: LIST
88469: LIST
88470: LIST
88471: LIST
88472: LIST
88473: LIST
88474: LIST
88475: LIST
88476: LIST
88477: LIST
88478: LIST
88479: LIST
88480: LIST
88481: LIST
88482: PUSH
88483: EMPTY
88484: LIST
88485: LIST
88486: ST_TO_ADDR
88487: GO 88490
88489: POP
// end else
88490: GO 88709
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
88492: LD_ADDR_VAR 0 1
88496: PUSH
88497: LD_INT 1
88499: PUSH
88500: LD_INT 2
88502: PUSH
88503: LD_INT 3
88505: PUSH
88506: LD_INT 4
88508: PUSH
88509: LD_INT 5
88511: PUSH
88512: LD_INT 6
88514: PUSH
88515: LD_INT 7
88517: PUSH
88518: LD_INT 8
88520: PUSH
88521: LD_INT 9
88523: PUSH
88524: LD_INT 10
88526: PUSH
88527: LD_INT 11
88529: PUSH
88530: LD_INT 12
88532: PUSH
88533: LD_INT 13
88535: PUSH
88536: LD_INT 14
88538: PUSH
88539: LD_INT 15
88541: PUSH
88542: LD_INT 16
88544: PUSH
88545: LD_INT 17
88547: PUSH
88548: LD_INT 18
88550: PUSH
88551: LD_INT 19
88553: PUSH
88554: LD_INT 20
88556: PUSH
88557: LD_INT 21
88559: PUSH
88560: LD_INT 22
88562: PUSH
88563: LD_INT 23
88565: PUSH
88566: LD_INT 24
88568: PUSH
88569: LD_INT 25
88571: PUSH
88572: LD_INT 26
88574: PUSH
88575: LD_INT 27
88577: PUSH
88578: LD_INT 28
88580: PUSH
88581: LD_INT 29
88583: PUSH
88584: LD_INT 30
88586: PUSH
88587: LD_INT 31
88589: PUSH
88590: LD_INT 32
88592: PUSH
88593: LD_INT 33
88595: PUSH
88596: LD_INT 34
88598: PUSH
88599: LD_INT 35
88601: PUSH
88602: LD_INT 36
88604: PUSH
88605: EMPTY
88606: LIST
88607: LIST
88608: LIST
88609: LIST
88610: LIST
88611: LIST
88612: LIST
88613: LIST
88614: LIST
88615: LIST
88616: LIST
88617: LIST
88618: LIST
88619: LIST
88620: LIST
88621: LIST
88622: LIST
88623: LIST
88624: LIST
88625: LIST
88626: LIST
88627: LIST
88628: LIST
88629: LIST
88630: LIST
88631: LIST
88632: LIST
88633: LIST
88634: LIST
88635: LIST
88636: LIST
88637: LIST
88638: LIST
88639: LIST
88640: LIST
88641: LIST
88642: PUSH
88643: LD_INT 101
88645: PUSH
88646: LD_INT 102
88648: PUSH
88649: LD_INT 103
88651: PUSH
88652: LD_INT 104
88654: PUSH
88655: LD_INT 105
88657: PUSH
88658: LD_INT 106
88660: PUSH
88661: LD_INT 107
88663: PUSH
88664: LD_INT 108
88666: PUSH
88667: LD_INT 109
88669: PUSH
88670: LD_INT 110
88672: PUSH
88673: LD_INT 111
88675: PUSH
88676: LD_INT 112
88678: PUSH
88679: LD_INT 113
88681: PUSH
88682: LD_INT 114
88684: PUSH
88685: LD_INT 115
88687: PUSH
88688: EMPTY
88689: LIST
88690: LIST
88691: LIST
88692: LIST
88693: LIST
88694: LIST
88695: LIST
88696: LIST
88697: LIST
88698: LIST
88699: LIST
88700: LIST
88701: LIST
88702: LIST
88703: LIST
88704: PUSH
88705: EMPTY
88706: LIST
88707: LIST
88708: ST_TO_ADDR
// if result then
88709: LD_VAR 0 1
88713: IFFALSE 89002
// begin normal :=  ;
88715: LD_ADDR_VAR 0 3
88719: PUSH
88720: LD_STRING 
88722: ST_TO_ADDR
// hardcore :=  ;
88723: LD_ADDR_VAR 0 4
88727: PUSH
88728: LD_STRING 
88730: ST_TO_ADDR
// for i = 1 to normalCounter do
88731: LD_ADDR_VAR 0 5
88735: PUSH
88736: DOUBLE
88737: LD_INT 1
88739: DEC
88740: ST_TO_ADDR
88741: LD_EXP 109
88745: PUSH
88746: FOR_TO
88747: IFFALSE 88848
// begin tmp := 0 ;
88749: LD_ADDR_VAR 0 2
88753: PUSH
88754: LD_STRING 0
88756: ST_TO_ADDR
// if result [ 1 ] then
88757: LD_VAR 0 1
88761: PUSH
88762: LD_INT 1
88764: ARRAY
88765: IFFALSE 88830
// if result [ 1 ] [ 1 ] = i then
88767: LD_VAR 0 1
88771: PUSH
88772: LD_INT 1
88774: ARRAY
88775: PUSH
88776: LD_INT 1
88778: ARRAY
88779: PUSH
88780: LD_VAR 0 5
88784: EQUAL
88785: IFFALSE 88830
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
88787: LD_ADDR_VAR 0 1
88791: PUSH
88792: LD_VAR 0 1
88796: PPUSH
88797: LD_INT 1
88799: PPUSH
88800: LD_VAR 0 1
88804: PUSH
88805: LD_INT 1
88807: ARRAY
88808: PPUSH
88809: LD_INT 1
88811: PPUSH
88812: CALL_OW 3
88816: PPUSH
88817: CALL_OW 1
88821: ST_TO_ADDR
// tmp := 1 ;
88822: LD_ADDR_VAR 0 2
88826: PUSH
88827: LD_STRING 1
88829: ST_TO_ADDR
// end ; normal := normal & tmp ;
88830: LD_ADDR_VAR 0 3
88834: PUSH
88835: LD_VAR 0 3
88839: PUSH
88840: LD_VAR 0 2
88844: STR
88845: ST_TO_ADDR
// end ;
88846: GO 88746
88848: POP
88849: POP
// for i = 1 to hardcoreCounter do
88850: LD_ADDR_VAR 0 5
88854: PUSH
88855: DOUBLE
88856: LD_INT 1
88858: DEC
88859: ST_TO_ADDR
88860: LD_EXP 110
88864: PUSH
88865: FOR_TO
88866: IFFALSE 88971
// begin tmp := 0 ;
88868: LD_ADDR_VAR 0 2
88872: PUSH
88873: LD_STRING 0
88875: ST_TO_ADDR
// if result [ 2 ] then
88876: LD_VAR 0 1
88880: PUSH
88881: LD_INT 2
88883: ARRAY
88884: IFFALSE 88953
// if result [ 2 ] [ 1 ] = 100 + i then
88886: LD_VAR 0 1
88890: PUSH
88891: LD_INT 2
88893: ARRAY
88894: PUSH
88895: LD_INT 1
88897: ARRAY
88898: PUSH
88899: LD_INT 100
88901: PUSH
88902: LD_VAR 0 5
88906: PLUS
88907: EQUAL
88908: IFFALSE 88953
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
88910: LD_ADDR_VAR 0 1
88914: PUSH
88915: LD_VAR 0 1
88919: PPUSH
88920: LD_INT 2
88922: PPUSH
88923: LD_VAR 0 1
88927: PUSH
88928: LD_INT 2
88930: ARRAY
88931: PPUSH
88932: LD_INT 1
88934: PPUSH
88935: CALL_OW 3
88939: PPUSH
88940: CALL_OW 1
88944: ST_TO_ADDR
// tmp := 1 ;
88945: LD_ADDR_VAR 0 2
88949: PUSH
88950: LD_STRING 1
88952: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
88953: LD_ADDR_VAR 0 4
88957: PUSH
88958: LD_VAR 0 4
88962: PUSH
88963: LD_VAR 0 2
88967: STR
88968: ST_TO_ADDR
// end ;
88969: GO 88865
88971: POP
88972: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
88973: LD_STRING getStreamItemsFromMission("
88975: PUSH
88976: LD_VAR 0 3
88980: STR
88981: PUSH
88982: LD_STRING ","
88984: STR
88985: PUSH
88986: LD_VAR 0 4
88990: STR
88991: PUSH
88992: LD_STRING ")
88994: STR
88995: PPUSH
88996: CALL_OW 559
// end else
89000: GO 89009
// ToLua ( getStreamItemsFromMission("","") ) ;
89002: LD_STRING getStreamItemsFromMission("","")
89004: PPUSH
89005: CALL_OW 559
// end ;
89009: LD_VAR 0 1
89013: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
89014: LD_EXP 108
89018: PUSH
89019: LD_EXP 113
89023: AND
89024: IFFALSE 89148
89026: GO 89028
89028: DISABLE
89029: LD_INT 0
89031: PPUSH
89032: PPUSH
// begin enable ;
89033: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
89034: LD_ADDR_VAR 0 2
89038: PUSH
89039: LD_INT 22
89041: PUSH
89042: LD_OWVAR 2
89046: PUSH
89047: EMPTY
89048: LIST
89049: LIST
89050: PUSH
89051: LD_INT 2
89053: PUSH
89054: LD_INT 34
89056: PUSH
89057: LD_INT 7
89059: PUSH
89060: EMPTY
89061: LIST
89062: LIST
89063: PUSH
89064: LD_INT 34
89066: PUSH
89067: LD_INT 45
89069: PUSH
89070: EMPTY
89071: LIST
89072: LIST
89073: PUSH
89074: LD_INT 34
89076: PUSH
89077: LD_INT 28
89079: PUSH
89080: EMPTY
89081: LIST
89082: LIST
89083: PUSH
89084: LD_INT 34
89086: PUSH
89087: LD_INT 47
89089: PUSH
89090: EMPTY
89091: LIST
89092: LIST
89093: PUSH
89094: EMPTY
89095: LIST
89096: LIST
89097: LIST
89098: LIST
89099: LIST
89100: PUSH
89101: EMPTY
89102: LIST
89103: LIST
89104: PPUSH
89105: CALL_OW 69
89109: ST_TO_ADDR
// if not tmp then
89110: LD_VAR 0 2
89114: NOT
89115: IFFALSE 89119
// exit ;
89117: GO 89148
// for i in tmp do
89119: LD_ADDR_VAR 0 1
89123: PUSH
89124: LD_VAR 0 2
89128: PUSH
89129: FOR_IN
89130: IFFALSE 89146
// begin SetLives ( i , 0 ) ;
89132: LD_VAR 0 1
89136: PPUSH
89137: LD_INT 0
89139: PPUSH
89140: CALL_OW 234
// end ;
89144: GO 89129
89146: POP
89147: POP
// end ;
89148: PPOPN 2
89150: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
89151: LD_EXP 108
89155: PUSH
89156: LD_EXP 114
89160: AND
89161: IFFALSE 89245
89163: GO 89165
89165: DISABLE
89166: LD_INT 0
89168: PPUSH
89169: PPUSH
// begin enable ;
89170: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
89171: LD_ADDR_VAR 0 2
89175: PUSH
89176: LD_INT 22
89178: PUSH
89179: LD_OWVAR 2
89183: PUSH
89184: EMPTY
89185: LIST
89186: LIST
89187: PUSH
89188: LD_INT 32
89190: PUSH
89191: LD_INT 3
89193: PUSH
89194: EMPTY
89195: LIST
89196: LIST
89197: PUSH
89198: EMPTY
89199: LIST
89200: LIST
89201: PPUSH
89202: CALL_OW 69
89206: ST_TO_ADDR
// if not tmp then
89207: LD_VAR 0 2
89211: NOT
89212: IFFALSE 89216
// exit ;
89214: GO 89245
// for i in tmp do
89216: LD_ADDR_VAR 0 1
89220: PUSH
89221: LD_VAR 0 2
89225: PUSH
89226: FOR_IN
89227: IFFALSE 89243
// begin SetLives ( i , 0 ) ;
89229: LD_VAR 0 1
89233: PPUSH
89234: LD_INT 0
89236: PPUSH
89237: CALL_OW 234
// end ;
89241: GO 89226
89243: POP
89244: POP
// end ;
89245: PPOPN 2
89247: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
89248: LD_EXP 108
89252: PUSH
89253: LD_EXP 111
89257: AND
89258: IFFALSE 89351
89260: GO 89262
89262: DISABLE
89263: LD_INT 0
89265: PPUSH
// begin enable ;
89266: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
89267: LD_ADDR_VAR 0 1
89271: PUSH
89272: LD_INT 22
89274: PUSH
89275: LD_OWVAR 2
89279: PUSH
89280: EMPTY
89281: LIST
89282: LIST
89283: PUSH
89284: LD_INT 2
89286: PUSH
89287: LD_INT 25
89289: PUSH
89290: LD_INT 5
89292: PUSH
89293: EMPTY
89294: LIST
89295: LIST
89296: PUSH
89297: LD_INT 25
89299: PUSH
89300: LD_INT 9
89302: PUSH
89303: EMPTY
89304: LIST
89305: LIST
89306: PUSH
89307: LD_INT 25
89309: PUSH
89310: LD_INT 8
89312: PUSH
89313: EMPTY
89314: LIST
89315: LIST
89316: PUSH
89317: EMPTY
89318: LIST
89319: LIST
89320: LIST
89321: LIST
89322: PUSH
89323: EMPTY
89324: LIST
89325: LIST
89326: PPUSH
89327: CALL_OW 69
89331: PUSH
89332: FOR_IN
89333: IFFALSE 89349
// begin SetClass ( i , 1 ) ;
89335: LD_VAR 0 1
89339: PPUSH
89340: LD_INT 1
89342: PPUSH
89343: CALL_OW 336
// end ;
89347: GO 89332
89349: POP
89350: POP
// end ;
89351: PPOPN 1
89353: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
89354: LD_EXP 108
89358: PUSH
89359: LD_EXP 112
89363: AND
89364: PUSH
89365: LD_OWVAR 65
89369: PUSH
89370: LD_INT 7
89372: LESS
89373: AND
89374: IFFALSE 89388
89376: GO 89378
89378: DISABLE
// begin enable ;
89379: ENABLE
// game_speed := 7 ;
89380: LD_ADDR_OWVAR 65
89384: PUSH
89385: LD_INT 7
89387: ST_TO_ADDR
// end ;
89388: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
89389: LD_EXP 108
89393: PUSH
89394: LD_EXP 115
89398: AND
89399: IFFALSE 89601
89401: GO 89403
89403: DISABLE
89404: LD_INT 0
89406: PPUSH
89407: PPUSH
89408: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
89409: LD_ADDR_VAR 0 3
89413: PUSH
89414: LD_INT 81
89416: PUSH
89417: LD_OWVAR 2
89421: PUSH
89422: EMPTY
89423: LIST
89424: LIST
89425: PUSH
89426: LD_INT 21
89428: PUSH
89429: LD_INT 1
89431: PUSH
89432: EMPTY
89433: LIST
89434: LIST
89435: PUSH
89436: EMPTY
89437: LIST
89438: LIST
89439: PPUSH
89440: CALL_OW 69
89444: ST_TO_ADDR
// if not tmp then
89445: LD_VAR 0 3
89449: NOT
89450: IFFALSE 89454
// exit ;
89452: GO 89601
// if tmp > 5 then
89454: LD_VAR 0 3
89458: PUSH
89459: LD_INT 5
89461: GREATER
89462: IFFALSE 89474
// k := 5 else
89464: LD_ADDR_VAR 0 2
89468: PUSH
89469: LD_INT 5
89471: ST_TO_ADDR
89472: GO 89484
// k := tmp ;
89474: LD_ADDR_VAR 0 2
89478: PUSH
89479: LD_VAR 0 3
89483: ST_TO_ADDR
// for i := 1 to k do
89484: LD_ADDR_VAR 0 1
89488: PUSH
89489: DOUBLE
89490: LD_INT 1
89492: DEC
89493: ST_TO_ADDR
89494: LD_VAR 0 2
89498: PUSH
89499: FOR_TO
89500: IFFALSE 89599
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
89502: LD_VAR 0 3
89506: PUSH
89507: LD_VAR 0 1
89511: ARRAY
89512: PPUSH
89513: LD_VAR 0 1
89517: PUSH
89518: LD_INT 4
89520: MOD
89521: PUSH
89522: LD_INT 1
89524: PLUS
89525: PPUSH
89526: CALL_OW 259
89530: PUSH
89531: LD_INT 10
89533: LESS
89534: IFFALSE 89597
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
89536: LD_VAR 0 3
89540: PUSH
89541: LD_VAR 0 1
89545: ARRAY
89546: PPUSH
89547: LD_VAR 0 1
89551: PUSH
89552: LD_INT 4
89554: MOD
89555: PUSH
89556: LD_INT 1
89558: PLUS
89559: PPUSH
89560: LD_VAR 0 3
89564: PUSH
89565: LD_VAR 0 1
89569: ARRAY
89570: PPUSH
89571: LD_VAR 0 1
89575: PUSH
89576: LD_INT 4
89578: MOD
89579: PUSH
89580: LD_INT 1
89582: PLUS
89583: PPUSH
89584: CALL_OW 259
89588: PUSH
89589: LD_INT 1
89591: PLUS
89592: PPUSH
89593: CALL_OW 237
89597: GO 89499
89599: POP
89600: POP
// end ;
89601: PPOPN 3
89603: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
89604: LD_EXP 108
89608: PUSH
89609: LD_EXP 116
89613: AND
89614: IFFALSE 89634
89616: GO 89618
89618: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
89619: LD_INT 4
89621: PPUSH
89622: LD_OWVAR 2
89626: PPUSH
89627: LD_INT 0
89629: PPUSH
89630: CALL_OW 324
89634: END
// every 0 0$1 trigger StreamModeActive and sShovel do
89635: LD_EXP 108
89639: PUSH
89640: LD_EXP 145
89644: AND
89645: IFFALSE 89665
89647: GO 89649
89649: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
89650: LD_INT 19
89652: PPUSH
89653: LD_OWVAR 2
89657: PPUSH
89658: LD_INT 0
89660: PPUSH
89661: CALL_OW 324
89665: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
89666: LD_EXP 108
89670: PUSH
89671: LD_EXP 117
89675: AND
89676: IFFALSE 89778
89678: GO 89680
89680: DISABLE
89681: LD_INT 0
89683: PPUSH
89684: PPUSH
// begin enable ;
89685: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
89686: LD_ADDR_VAR 0 2
89690: PUSH
89691: LD_INT 22
89693: PUSH
89694: LD_OWVAR 2
89698: PUSH
89699: EMPTY
89700: LIST
89701: LIST
89702: PUSH
89703: LD_INT 2
89705: PUSH
89706: LD_INT 34
89708: PUSH
89709: LD_INT 11
89711: PUSH
89712: EMPTY
89713: LIST
89714: LIST
89715: PUSH
89716: LD_INT 34
89718: PUSH
89719: LD_INT 30
89721: PUSH
89722: EMPTY
89723: LIST
89724: LIST
89725: PUSH
89726: EMPTY
89727: LIST
89728: LIST
89729: LIST
89730: PUSH
89731: EMPTY
89732: LIST
89733: LIST
89734: PPUSH
89735: CALL_OW 69
89739: ST_TO_ADDR
// if not tmp then
89740: LD_VAR 0 2
89744: NOT
89745: IFFALSE 89749
// exit ;
89747: GO 89778
// for i in tmp do
89749: LD_ADDR_VAR 0 1
89753: PUSH
89754: LD_VAR 0 2
89758: PUSH
89759: FOR_IN
89760: IFFALSE 89776
// begin SetLives ( i , 0 ) ;
89762: LD_VAR 0 1
89766: PPUSH
89767: LD_INT 0
89769: PPUSH
89770: CALL_OW 234
// end ;
89774: GO 89759
89776: POP
89777: POP
// end ;
89778: PPOPN 2
89780: END
// every 0 0$1 trigger StreamModeActive and sBunker do
89781: LD_EXP 108
89785: PUSH
89786: LD_EXP 118
89790: AND
89791: IFFALSE 89811
89793: GO 89795
89795: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
89796: LD_INT 32
89798: PPUSH
89799: LD_OWVAR 2
89803: PPUSH
89804: LD_INT 0
89806: PPUSH
89807: CALL_OW 324
89811: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
89812: LD_EXP 108
89816: PUSH
89817: LD_EXP 119
89821: AND
89822: IFFALSE 90003
89824: GO 89826
89826: DISABLE
89827: LD_INT 0
89829: PPUSH
89830: PPUSH
89831: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
89832: LD_ADDR_VAR 0 2
89836: PUSH
89837: LD_INT 22
89839: PUSH
89840: LD_OWVAR 2
89844: PUSH
89845: EMPTY
89846: LIST
89847: LIST
89848: PUSH
89849: LD_INT 33
89851: PUSH
89852: LD_INT 3
89854: PUSH
89855: EMPTY
89856: LIST
89857: LIST
89858: PUSH
89859: EMPTY
89860: LIST
89861: LIST
89862: PPUSH
89863: CALL_OW 69
89867: ST_TO_ADDR
// if not tmp then
89868: LD_VAR 0 2
89872: NOT
89873: IFFALSE 89877
// exit ;
89875: GO 90003
// side := 0 ;
89877: LD_ADDR_VAR 0 3
89881: PUSH
89882: LD_INT 0
89884: ST_TO_ADDR
// for i := 1 to 8 do
89885: LD_ADDR_VAR 0 1
89889: PUSH
89890: DOUBLE
89891: LD_INT 1
89893: DEC
89894: ST_TO_ADDR
89895: LD_INT 8
89897: PUSH
89898: FOR_TO
89899: IFFALSE 89947
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
89901: LD_OWVAR 2
89905: PUSH
89906: LD_VAR 0 1
89910: NONEQUAL
89911: PUSH
89912: LD_OWVAR 2
89916: PPUSH
89917: LD_VAR 0 1
89921: PPUSH
89922: CALL_OW 81
89926: PUSH
89927: LD_INT 2
89929: EQUAL
89930: AND
89931: IFFALSE 89945
// begin side := i ;
89933: LD_ADDR_VAR 0 3
89937: PUSH
89938: LD_VAR 0 1
89942: ST_TO_ADDR
// break ;
89943: GO 89947
// end ;
89945: GO 89898
89947: POP
89948: POP
// if not side then
89949: LD_VAR 0 3
89953: NOT
89954: IFFALSE 89958
// exit ;
89956: GO 90003
// for i := 1 to tmp do
89958: LD_ADDR_VAR 0 1
89962: PUSH
89963: DOUBLE
89964: LD_INT 1
89966: DEC
89967: ST_TO_ADDR
89968: LD_VAR 0 2
89972: PUSH
89973: FOR_TO
89974: IFFALSE 90001
// if Prob ( 60 ) then
89976: LD_INT 60
89978: PPUSH
89979: CALL_OW 13
89983: IFFALSE 89999
// SetSide ( i , side ) ;
89985: LD_VAR 0 1
89989: PPUSH
89990: LD_VAR 0 3
89994: PPUSH
89995: CALL_OW 235
89999: GO 89973
90001: POP
90002: POP
// end ;
90003: PPOPN 3
90005: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
90006: LD_EXP 108
90010: PUSH
90011: LD_EXP 121
90015: AND
90016: IFFALSE 90135
90018: GO 90020
90020: DISABLE
90021: LD_INT 0
90023: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
90024: LD_ADDR_VAR 0 1
90028: PUSH
90029: LD_INT 22
90031: PUSH
90032: LD_OWVAR 2
90036: PUSH
90037: EMPTY
90038: LIST
90039: LIST
90040: PUSH
90041: LD_INT 21
90043: PUSH
90044: LD_INT 1
90046: PUSH
90047: EMPTY
90048: LIST
90049: LIST
90050: PUSH
90051: LD_INT 3
90053: PUSH
90054: LD_INT 23
90056: PUSH
90057: LD_INT 0
90059: PUSH
90060: EMPTY
90061: LIST
90062: LIST
90063: PUSH
90064: EMPTY
90065: LIST
90066: LIST
90067: PUSH
90068: EMPTY
90069: LIST
90070: LIST
90071: LIST
90072: PPUSH
90073: CALL_OW 69
90077: PUSH
90078: FOR_IN
90079: IFFALSE 90133
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
90081: LD_VAR 0 1
90085: PPUSH
90086: CALL_OW 257
90090: PUSH
90091: LD_INT 1
90093: PUSH
90094: LD_INT 2
90096: PUSH
90097: LD_INT 3
90099: PUSH
90100: LD_INT 4
90102: PUSH
90103: EMPTY
90104: LIST
90105: LIST
90106: LIST
90107: LIST
90108: IN
90109: IFFALSE 90131
// SetClass ( un , rand ( 1 , 4 ) ) ;
90111: LD_VAR 0 1
90115: PPUSH
90116: LD_INT 1
90118: PPUSH
90119: LD_INT 4
90121: PPUSH
90122: CALL_OW 12
90126: PPUSH
90127: CALL_OW 336
90131: GO 90078
90133: POP
90134: POP
// end ;
90135: PPOPN 1
90137: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
90138: LD_EXP 108
90142: PUSH
90143: LD_EXP 120
90147: AND
90148: IFFALSE 90227
90150: GO 90152
90152: DISABLE
90153: LD_INT 0
90155: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
90156: LD_ADDR_VAR 0 1
90160: PUSH
90161: LD_INT 22
90163: PUSH
90164: LD_OWVAR 2
90168: PUSH
90169: EMPTY
90170: LIST
90171: LIST
90172: PUSH
90173: LD_INT 21
90175: PUSH
90176: LD_INT 3
90178: PUSH
90179: EMPTY
90180: LIST
90181: LIST
90182: PUSH
90183: EMPTY
90184: LIST
90185: LIST
90186: PPUSH
90187: CALL_OW 69
90191: ST_TO_ADDR
// if not tmp then
90192: LD_VAR 0 1
90196: NOT
90197: IFFALSE 90201
// exit ;
90199: GO 90227
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
90201: LD_VAR 0 1
90205: PUSH
90206: LD_INT 1
90208: PPUSH
90209: LD_VAR 0 1
90213: PPUSH
90214: CALL_OW 12
90218: ARRAY
90219: PPUSH
90220: LD_INT 100
90222: PPUSH
90223: CALL_OW 234
// end ;
90227: PPOPN 1
90229: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
90230: LD_EXP 108
90234: PUSH
90235: LD_EXP 122
90239: AND
90240: IFFALSE 90338
90242: GO 90244
90244: DISABLE
90245: LD_INT 0
90247: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
90248: LD_ADDR_VAR 0 1
90252: PUSH
90253: LD_INT 22
90255: PUSH
90256: LD_OWVAR 2
90260: PUSH
90261: EMPTY
90262: LIST
90263: LIST
90264: PUSH
90265: LD_INT 21
90267: PUSH
90268: LD_INT 1
90270: PUSH
90271: EMPTY
90272: LIST
90273: LIST
90274: PUSH
90275: EMPTY
90276: LIST
90277: LIST
90278: PPUSH
90279: CALL_OW 69
90283: ST_TO_ADDR
// if not tmp then
90284: LD_VAR 0 1
90288: NOT
90289: IFFALSE 90293
// exit ;
90291: GO 90338
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
90293: LD_VAR 0 1
90297: PUSH
90298: LD_INT 1
90300: PPUSH
90301: LD_VAR 0 1
90305: PPUSH
90306: CALL_OW 12
90310: ARRAY
90311: PPUSH
90312: LD_INT 1
90314: PPUSH
90315: LD_INT 4
90317: PPUSH
90318: CALL_OW 12
90322: PPUSH
90323: LD_INT 3000
90325: PPUSH
90326: LD_INT 9000
90328: PPUSH
90329: CALL_OW 12
90333: PPUSH
90334: CALL_OW 492
// end ;
90338: PPOPN 1
90340: END
// every 0 0$1 trigger StreamModeActive and sDepot do
90341: LD_EXP 108
90345: PUSH
90346: LD_EXP 123
90350: AND
90351: IFFALSE 90371
90353: GO 90355
90355: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
90356: LD_INT 1
90358: PPUSH
90359: LD_OWVAR 2
90363: PPUSH
90364: LD_INT 0
90366: PPUSH
90367: CALL_OW 324
90371: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
90372: LD_EXP 108
90376: PUSH
90377: LD_EXP 124
90381: AND
90382: IFFALSE 90465
90384: GO 90386
90386: DISABLE
90387: LD_INT 0
90389: PPUSH
90390: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
90391: LD_ADDR_VAR 0 2
90395: PUSH
90396: LD_INT 22
90398: PUSH
90399: LD_OWVAR 2
90403: PUSH
90404: EMPTY
90405: LIST
90406: LIST
90407: PUSH
90408: LD_INT 21
90410: PUSH
90411: LD_INT 3
90413: PUSH
90414: EMPTY
90415: LIST
90416: LIST
90417: PUSH
90418: EMPTY
90419: LIST
90420: LIST
90421: PPUSH
90422: CALL_OW 69
90426: ST_TO_ADDR
// if not tmp then
90427: LD_VAR 0 2
90431: NOT
90432: IFFALSE 90436
// exit ;
90434: GO 90465
// for i in tmp do
90436: LD_ADDR_VAR 0 1
90440: PUSH
90441: LD_VAR 0 2
90445: PUSH
90446: FOR_IN
90447: IFFALSE 90463
// SetBLevel ( i , 10 ) ;
90449: LD_VAR 0 1
90453: PPUSH
90454: LD_INT 10
90456: PPUSH
90457: CALL_OW 241
90461: GO 90446
90463: POP
90464: POP
// end ;
90465: PPOPN 2
90467: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
90468: LD_EXP 108
90472: PUSH
90473: LD_EXP 125
90477: AND
90478: IFFALSE 90589
90480: GO 90482
90482: DISABLE
90483: LD_INT 0
90485: PPUSH
90486: PPUSH
90487: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
90488: LD_ADDR_VAR 0 3
90492: PUSH
90493: LD_INT 22
90495: PUSH
90496: LD_OWVAR 2
90500: PUSH
90501: EMPTY
90502: LIST
90503: LIST
90504: PUSH
90505: LD_INT 25
90507: PUSH
90508: LD_INT 1
90510: PUSH
90511: EMPTY
90512: LIST
90513: LIST
90514: PUSH
90515: EMPTY
90516: LIST
90517: LIST
90518: PPUSH
90519: CALL_OW 69
90523: ST_TO_ADDR
// if not tmp then
90524: LD_VAR 0 3
90528: NOT
90529: IFFALSE 90533
// exit ;
90531: GO 90589
// un := tmp [ rand ( 1 , tmp ) ] ;
90533: LD_ADDR_VAR 0 2
90537: PUSH
90538: LD_VAR 0 3
90542: PUSH
90543: LD_INT 1
90545: PPUSH
90546: LD_VAR 0 3
90550: PPUSH
90551: CALL_OW 12
90555: ARRAY
90556: ST_TO_ADDR
// if Crawls ( un ) then
90557: LD_VAR 0 2
90561: PPUSH
90562: CALL_OW 318
90566: IFFALSE 90577
// ComWalk ( un ) ;
90568: LD_VAR 0 2
90572: PPUSH
90573: CALL_OW 138
// SetClass ( un , class_sniper ) ;
90577: LD_VAR 0 2
90581: PPUSH
90582: LD_INT 5
90584: PPUSH
90585: CALL_OW 336
// end ;
90589: PPOPN 3
90591: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
90592: LD_EXP 108
90596: PUSH
90597: LD_EXP 126
90601: AND
90602: PUSH
90603: LD_OWVAR 67
90607: PUSH
90608: LD_INT 3
90610: LESS
90611: AND
90612: IFFALSE 90631
90614: GO 90616
90616: DISABLE
// Difficulty := Difficulty + 1 ;
90617: LD_ADDR_OWVAR 67
90621: PUSH
90622: LD_OWVAR 67
90626: PUSH
90627: LD_INT 1
90629: PLUS
90630: ST_TO_ADDR
90631: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
90632: LD_EXP 108
90636: PUSH
90637: LD_EXP 127
90641: AND
90642: IFFALSE 90745
90644: GO 90646
90646: DISABLE
90647: LD_INT 0
90649: PPUSH
// begin for i := 1 to 5 do
90650: LD_ADDR_VAR 0 1
90654: PUSH
90655: DOUBLE
90656: LD_INT 1
90658: DEC
90659: ST_TO_ADDR
90660: LD_INT 5
90662: PUSH
90663: FOR_TO
90664: IFFALSE 90743
// begin uc_nation := nation_nature ;
90666: LD_ADDR_OWVAR 21
90670: PUSH
90671: LD_INT 0
90673: ST_TO_ADDR
// uc_side := 0 ;
90674: LD_ADDR_OWVAR 20
90678: PUSH
90679: LD_INT 0
90681: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
90682: LD_ADDR_OWVAR 29
90686: PUSH
90687: LD_INT 12
90689: PUSH
90690: LD_INT 12
90692: PUSH
90693: EMPTY
90694: LIST
90695: LIST
90696: ST_TO_ADDR
// hc_agressivity := 20 ;
90697: LD_ADDR_OWVAR 35
90701: PUSH
90702: LD_INT 20
90704: ST_TO_ADDR
// hc_class := class_tiger ;
90705: LD_ADDR_OWVAR 28
90709: PUSH
90710: LD_INT 14
90712: ST_TO_ADDR
// hc_gallery :=  ;
90713: LD_ADDR_OWVAR 33
90717: PUSH
90718: LD_STRING 
90720: ST_TO_ADDR
// hc_name :=  ;
90721: LD_ADDR_OWVAR 26
90725: PUSH
90726: LD_STRING 
90728: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
90729: CALL_OW 44
90733: PPUSH
90734: LD_INT 0
90736: PPUSH
90737: CALL_OW 51
// end ;
90741: GO 90663
90743: POP
90744: POP
// end ;
90745: PPOPN 1
90747: END
// every 0 0$1 trigger StreamModeActive and sBomb do
90748: LD_EXP 108
90752: PUSH
90753: LD_EXP 128
90757: AND
90758: IFFALSE 90767
90760: GO 90762
90762: DISABLE
// StreamSibBomb ;
90763: CALL 90768 0 0
90767: END
// export function StreamSibBomb ; var i , x , y ; begin
90768: LD_INT 0
90770: PPUSH
90771: PPUSH
90772: PPUSH
90773: PPUSH
// result := false ;
90774: LD_ADDR_VAR 0 1
90778: PUSH
90779: LD_INT 0
90781: ST_TO_ADDR
// for i := 1 to 16 do
90782: LD_ADDR_VAR 0 2
90786: PUSH
90787: DOUBLE
90788: LD_INT 1
90790: DEC
90791: ST_TO_ADDR
90792: LD_INT 16
90794: PUSH
90795: FOR_TO
90796: IFFALSE 90995
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
90798: LD_ADDR_VAR 0 3
90802: PUSH
90803: LD_INT 10
90805: PUSH
90806: LD_INT 20
90808: PUSH
90809: LD_INT 30
90811: PUSH
90812: LD_INT 40
90814: PUSH
90815: LD_INT 50
90817: PUSH
90818: LD_INT 60
90820: PUSH
90821: LD_INT 70
90823: PUSH
90824: LD_INT 80
90826: PUSH
90827: LD_INT 90
90829: PUSH
90830: LD_INT 100
90832: PUSH
90833: LD_INT 110
90835: PUSH
90836: LD_INT 120
90838: PUSH
90839: LD_INT 130
90841: PUSH
90842: LD_INT 140
90844: PUSH
90845: LD_INT 150
90847: PUSH
90848: EMPTY
90849: LIST
90850: LIST
90851: LIST
90852: LIST
90853: LIST
90854: LIST
90855: LIST
90856: LIST
90857: LIST
90858: LIST
90859: LIST
90860: LIST
90861: LIST
90862: LIST
90863: LIST
90864: PUSH
90865: LD_INT 1
90867: PPUSH
90868: LD_INT 15
90870: PPUSH
90871: CALL_OW 12
90875: ARRAY
90876: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
90877: LD_ADDR_VAR 0 4
90881: PUSH
90882: LD_INT 10
90884: PUSH
90885: LD_INT 20
90887: PUSH
90888: LD_INT 30
90890: PUSH
90891: LD_INT 40
90893: PUSH
90894: LD_INT 50
90896: PUSH
90897: LD_INT 60
90899: PUSH
90900: LD_INT 70
90902: PUSH
90903: LD_INT 80
90905: PUSH
90906: LD_INT 90
90908: PUSH
90909: LD_INT 100
90911: PUSH
90912: LD_INT 110
90914: PUSH
90915: LD_INT 120
90917: PUSH
90918: LD_INT 130
90920: PUSH
90921: LD_INT 140
90923: PUSH
90924: LD_INT 150
90926: PUSH
90927: EMPTY
90928: LIST
90929: LIST
90930: LIST
90931: LIST
90932: LIST
90933: LIST
90934: LIST
90935: LIST
90936: LIST
90937: LIST
90938: LIST
90939: LIST
90940: LIST
90941: LIST
90942: LIST
90943: PUSH
90944: LD_INT 1
90946: PPUSH
90947: LD_INT 15
90949: PPUSH
90950: CALL_OW 12
90954: ARRAY
90955: ST_TO_ADDR
// if ValidHex ( x , y ) then
90956: LD_VAR 0 3
90960: PPUSH
90961: LD_VAR 0 4
90965: PPUSH
90966: CALL_OW 488
90970: IFFALSE 90993
// begin result := [ x , y ] ;
90972: LD_ADDR_VAR 0 1
90976: PUSH
90977: LD_VAR 0 3
90981: PUSH
90982: LD_VAR 0 4
90986: PUSH
90987: EMPTY
90988: LIST
90989: LIST
90990: ST_TO_ADDR
// break ;
90991: GO 90995
// end ; end ;
90993: GO 90795
90995: POP
90996: POP
// if result then
90997: LD_VAR 0 1
91001: IFFALSE 91061
// begin ToLua ( playSibBomb() ) ;
91003: LD_STRING playSibBomb()
91005: PPUSH
91006: CALL_OW 559
// wait ( 0 0$14 ) ;
91010: LD_INT 490
91012: PPUSH
91013: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
91017: LD_VAR 0 1
91021: PUSH
91022: LD_INT 1
91024: ARRAY
91025: PPUSH
91026: LD_VAR 0 1
91030: PUSH
91031: LD_INT 2
91033: ARRAY
91034: PPUSH
91035: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
91039: LD_VAR 0 1
91043: PUSH
91044: LD_INT 1
91046: ARRAY
91047: PPUSH
91048: LD_VAR 0 1
91052: PUSH
91053: LD_INT 2
91055: ARRAY
91056: PPUSH
91057: CALL_OW 429
// end ; end ;
91061: LD_VAR 0 1
91065: RET
// every 0 0$1 trigger StreamModeActive and sReset do
91066: LD_EXP 108
91070: PUSH
91071: LD_EXP 130
91075: AND
91076: IFFALSE 91088
91078: GO 91080
91080: DISABLE
// YouLost (  ) ;
91081: LD_STRING 
91083: PPUSH
91084: CALL_OW 104
91088: END
// every 0 0$1 trigger StreamModeActive and sFog do
91089: LD_EXP 108
91093: PUSH
91094: LD_EXP 129
91098: AND
91099: IFFALSE 91113
91101: GO 91103
91103: DISABLE
// FogOff ( your_side ) ;
91104: LD_OWVAR 2
91108: PPUSH
91109: CALL_OW 344
91113: END
// every 0 0$1 trigger StreamModeActive and sSun do
91114: LD_EXP 108
91118: PUSH
91119: LD_EXP 131
91123: AND
91124: IFFALSE 91152
91126: GO 91128
91128: DISABLE
// begin solar_recharge_percent := 0 ;
91129: LD_ADDR_OWVAR 79
91133: PUSH
91134: LD_INT 0
91136: ST_TO_ADDR
// wait ( 5 5$00 ) ;
91137: LD_INT 10500
91139: PPUSH
91140: CALL_OW 67
// solar_recharge_percent := 100 ;
91144: LD_ADDR_OWVAR 79
91148: PUSH
91149: LD_INT 100
91151: ST_TO_ADDR
// end ;
91152: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
91153: LD_EXP 108
91157: PUSH
91158: LD_EXP 132
91162: AND
91163: IFFALSE 91402
91165: GO 91167
91167: DISABLE
91168: LD_INT 0
91170: PPUSH
91171: PPUSH
91172: PPUSH
// begin tmp := [ ] ;
91173: LD_ADDR_VAR 0 3
91177: PUSH
91178: EMPTY
91179: ST_TO_ADDR
// for i := 1 to 6 do
91180: LD_ADDR_VAR 0 1
91184: PUSH
91185: DOUBLE
91186: LD_INT 1
91188: DEC
91189: ST_TO_ADDR
91190: LD_INT 6
91192: PUSH
91193: FOR_TO
91194: IFFALSE 91299
// begin uc_nation := nation_nature ;
91196: LD_ADDR_OWVAR 21
91200: PUSH
91201: LD_INT 0
91203: ST_TO_ADDR
// uc_side := 0 ;
91204: LD_ADDR_OWVAR 20
91208: PUSH
91209: LD_INT 0
91211: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
91212: LD_ADDR_OWVAR 29
91216: PUSH
91217: LD_INT 12
91219: PUSH
91220: LD_INT 12
91222: PUSH
91223: EMPTY
91224: LIST
91225: LIST
91226: ST_TO_ADDR
// hc_agressivity := 20 ;
91227: LD_ADDR_OWVAR 35
91231: PUSH
91232: LD_INT 20
91234: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
91235: LD_ADDR_OWVAR 28
91239: PUSH
91240: LD_INT 17
91242: ST_TO_ADDR
// hc_gallery :=  ;
91243: LD_ADDR_OWVAR 33
91247: PUSH
91248: LD_STRING 
91250: ST_TO_ADDR
// hc_name :=  ;
91251: LD_ADDR_OWVAR 26
91255: PUSH
91256: LD_STRING 
91258: ST_TO_ADDR
// un := CreateHuman ;
91259: LD_ADDR_VAR 0 2
91263: PUSH
91264: CALL_OW 44
91268: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
91269: LD_VAR 0 2
91273: PPUSH
91274: LD_INT 1
91276: PPUSH
91277: CALL_OW 51
// tmp := tmp ^ un ;
91281: LD_ADDR_VAR 0 3
91285: PUSH
91286: LD_VAR 0 3
91290: PUSH
91291: LD_VAR 0 2
91295: ADD
91296: ST_TO_ADDR
// end ;
91297: GO 91193
91299: POP
91300: POP
// repeat wait ( 0 0$1 ) ;
91301: LD_INT 35
91303: PPUSH
91304: CALL_OW 67
// for un in tmp do
91308: LD_ADDR_VAR 0 2
91312: PUSH
91313: LD_VAR 0 3
91317: PUSH
91318: FOR_IN
91319: IFFALSE 91393
// begin if IsDead ( un ) then
91321: LD_VAR 0 2
91325: PPUSH
91326: CALL_OW 301
91330: IFFALSE 91350
// begin tmp := tmp diff un ;
91332: LD_ADDR_VAR 0 3
91336: PUSH
91337: LD_VAR 0 3
91341: PUSH
91342: LD_VAR 0 2
91346: DIFF
91347: ST_TO_ADDR
// continue ;
91348: GO 91318
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
91350: LD_VAR 0 2
91354: PPUSH
91355: LD_INT 3
91357: PUSH
91358: LD_INT 22
91360: PUSH
91361: LD_INT 0
91363: PUSH
91364: EMPTY
91365: LIST
91366: LIST
91367: PUSH
91368: EMPTY
91369: LIST
91370: LIST
91371: PPUSH
91372: CALL_OW 69
91376: PPUSH
91377: LD_VAR 0 2
91381: PPUSH
91382: CALL_OW 74
91386: PPUSH
91387: CALL_OW 115
// end ;
91391: GO 91318
91393: POP
91394: POP
// until not tmp ;
91395: LD_VAR 0 3
91399: NOT
91400: IFFALSE 91301
// end ;
91402: PPOPN 3
91404: END
// every 0 0$1 trigger StreamModeActive and sTroll do
91405: LD_EXP 108
91409: PUSH
91410: LD_EXP 133
91414: AND
91415: IFFALSE 91469
91417: GO 91419
91419: DISABLE
// begin ToLua ( displayTroll(); ) ;
91420: LD_STRING displayTroll();
91422: PPUSH
91423: CALL_OW 559
// wait ( 3 3$00 ) ;
91427: LD_INT 6300
91429: PPUSH
91430: CALL_OW 67
// ToLua ( hideTroll(); ) ;
91434: LD_STRING hideTroll();
91436: PPUSH
91437: CALL_OW 559
// wait ( 1 1$00 ) ;
91441: LD_INT 2100
91443: PPUSH
91444: CALL_OW 67
// ToLua ( displayTroll(); ) ;
91448: LD_STRING displayTroll();
91450: PPUSH
91451: CALL_OW 559
// wait ( 1 1$00 ) ;
91455: LD_INT 2100
91457: PPUSH
91458: CALL_OW 67
// ToLua ( hideTroll(); ) ;
91462: LD_STRING hideTroll();
91464: PPUSH
91465: CALL_OW 559
// end ;
91469: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
91470: LD_EXP 108
91474: PUSH
91475: LD_EXP 134
91479: AND
91480: IFFALSE 91543
91482: GO 91484
91484: DISABLE
91485: LD_INT 0
91487: PPUSH
// begin p := 0 ;
91488: LD_ADDR_VAR 0 1
91492: PUSH
91493: LD_INT 0
91495: ST_TO_ADDR
// repeat game_speed := 1 ;
91496: LD_ADDR_OWVAR 65
91500: PUSH
91501: LD_INT 1
91503: ST_TO_ADDR
// wait ( 0 0$1 ) ;
91504: LD_INT 35
91506: PPUSH
91507: CALL_OW 67
// p := p + 1 ;
91511: LD_ADDR_VAR 0 1
91515: PUSH
91516: LD_VAR 0 1
91520: PUSH
91521: LD_INT 1
91523: PLUS
91524: ST_TO_ADDR
// until p >= 60 ;
91525: LD_VAR 0 1
91529: PUSH
91530: LD_INT 60
91532: GREATEREQUAL
91533: IFFALSE 91496
// game_speed := 4 ;
91535: LD_ADDR_OWVAR 65
91539: PUSH
91540: LD_INT 4
91542: ST_TO_ADDR
// end ;
91543: PPOPN 1
91545: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
91546: LD_EXP 108
91550: PUSH
91551: LD_EXP 135
91555: AND
91556: IFFALSE 91702
91558: GO 91560
91560: DISABLE
91561: LD_INT 0
91563: PPUSH
91564: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
91565: LD_ADDR_VAR 0 1
91569: PUSH
91570: LD_INT 22
91572: PUSH
91573: LD_OWVAR 2
91577: PUSH
91578: EMPTY
91579: LIST
91580: LIST
91581: PUSH
91582: LD_INT 2
91584: PUSH
91585: LD_INT 30
91587: PUSH
91588: LD_INT 0
91590: PUSH
91591: EMPTY
91592: LIST
91593: LIST
91594: PUSH
91595: LD_INT 30
91597: PUSH
91598: LD_INT 1
91600: PUSH
91601: EMPTY
91602: LIST
91603: LIST
91604: PUSH
91605: EMPTY
91606: LIST
91607: LIST
91608: LIST
91609: PUSH
91610: EMPTY
91611: LIST
91612: LIST
91613: PPUSH
91614: CALL_OW 69
91618: ST_TO_ADDR
// if not depot then
91619: LD_VAR 0 1
91623: NOT
91624: IFFALSE 91628
// exit ;
91626: GO 91702
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
91628: LD_ADDR_VAR 0 2
91632: PUSH
91633: LD_VAR 0 1
91637: PUSH
91638: LD_INT 1
91640: PPUSH
91641: LD_VAR 0 1
91645: PPUSH
91646: CALL_OW 12
91650: ARRAY
91651: PPUSH
91652: CALL_OW 274
91656: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
91657: LD_VAR 0 2
91661: PPUSH
91662: LD_INT 1
91664: PPUSH
91665: LD_INT 0
91667: PPUSH
91668: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
91672: LD_VAR 0 2
91676: PPUSH
91677: LD_INT 2
91679: PPUSH
91680: LD_INT 0
91682: PPUSH
91683: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
91687: LD_VAR 0 2
91691: PPUSH
91692: LD_INT 3
91694: PPUSH
91695: LD_INT 0
91697: PPUSH
91698: CALL_OW 277
// end ;
91702: PPOPN 2
91704: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
91705: LD_EXP 108
91709: PUSH
91710: LD_EXP 136
91714: AND
91715: IFFALSE 91812
91717: GO 91719
91719: DISABLE
91720: LD_INT 0
91722: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
91723: LD_ADDR_VAR 0 1
91727: PUSH
91728: LD_INT 22
91730: PUSH
91731: LD_OWVAR 2
91735: PUSH
91736: EMPTY
91737: LIST
91738: LIST
91739: PUSH
91740: LD_INT 21
91742: PUSH
91743: LD_INT 1
91745: PUSH
91746: EMPTY
91747: LIST
91748: LIST
91749: PUSH
91750: LD_INT 3
91752: PUSH
91753: LD_INT 23
91755: PUSH
91756: LD_INT 0
91758: PUSH
91759: EMPTY
91760: LIST
91761: LIST
91762: PUSH
91763: EMPTY
91764: LIST
91765: LIST
91766: PUSH
91767: EMPTY
91768: LIST
91769: LIST
91770: LIST
91771: PPUSH
91772: CALL_OW 69
91776: ST_TO_ADDR
// if not tmp then
91777: LD_VAR 0 1
91781: NOT
91782: IFFALSE 91786
// exit ;
91784: GO 91812
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
91786: LD_VAR 0 1
91790: PUSH
91791: LD_INT 1
91793: PPUSH
91794: LD_VAR 0 1
91798: PPUSH
91799: CALL_OW 12
91803: ARRAY
91804: PPUSH
91805: LD_INT 200
91807: PPUSH
91808: CALL_OW 234
// end ;
91812: PPOPN 1
91814: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
91815: LD_EXP 108
91819: PUSH
91820: LD_EXP 137
91824: AND
91825: IFFALSE 91904
91827: GO 91829
91829: DISABLE
91830: LD_INT 0
91832: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
91833: LD_ADDR_VAR 0 1
91837: PUSH
91838: LD_INT 22
91840: PUSH
91841: LD_OWVAR 2
91845: PUSH
91846: EMPTY
91847: LIST
91848: LIST
91849: PUSH
91850: LD_INT 21
91852: PUSH
91853: LD_INT 2
91855: PUSH
91856: EMPTY
91857: LIST
91858: LIST
91859: PUSH
91860: EMPTY
91861: LIST
91862: LIST
91863: PPUSH
91864: CALL_OW 69
91868: ST_TO_ADDR
// if not tmp then
91869: LD_VAR 0 1
91873: NOT
91874: IFFALSE 91878
// exit ;
91876: GO 91904
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
91878: LD_VAR 0 1
91882: PUSH
91883: LD_INT 1
91885: PPUSH
91886: LD_VAR 0 1
91890: PPUSH
91891: CALL_OW 12
91895: ARRAY
91896: PPUSH
91897: LD_INT 60
91899: PPUSH
91900: CALL_OW 234
// end ;
91904: PPOPN 1
91906: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
91907: LD_EXP 108
91911: PUSH
91912: LD_EXP 138
91916: AND
91917: IFFALSE 92016
91919: GO 91921
91921: DISABLE
91922: LD_INT 0
91924: PPUSH
91925: PPUSH
// begin enable ;
91926: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
91927: LD_ADDR_VAR 0 1
91931: PUSH
91932: LD_INT 22
91934: PUSH
91935: LD_OWVAR 2
91939: PUSH
91940: EMPTY
91941: LIST
91942: LIST
91943: PUSH
91944: LD_INT 61
91946: PUSH
91947: EMPTY
91948: LIST
91949: PUSH
91950: LD_INT 33
91952: PUSH
91953: LD_INT 2
91955: PUSH
91956: EMPTY
91957: LIST
91958: LIST
91959: PUSH
91960: EMPTY
91961: LIST
91962: LIST
91963: LIST
91964: PPUSH
91965: CALL_OW 69
91969: ST_TO_ADDR
// if not tmp then
91970: LD_VAR 0 1
91974: NOT
91975: IFFALSE 91979
// exit ;
91977: GO 92016
// for i in tmp do
91979: LD_ADDR_VAR 0 2
91983: PUSH
91984: LD_VAR 0 1
91988: PUSH
91989: FOR_IN
91990: IFFALSE 92014
// if IsControledBy ( i ) then
91992: LD_VAR 0 2
91996: PPUSH
91997: CALL_OW 312
92001: IFFALSE 92012
// ComUnlink ( i ) ;
92003: LD_VAR 0 2
92007: PPUSH
92008: CALL_OW 136
92012: GO 91989
92014: POP
92015: POP
// end ;
92016: PPOPN 2
92018: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
92019: LD_EXP 108
92023: PUSH
92024: LD_EXP 139
92028: AND
92029: IFFALSE 92169
92031: GO 92033
92033: DISABLE
92034: LD_INT 0
92036: PPUSH
92037: PPUSH
// begin ToLua ( displayPowell(); ) ;
92038: LD_STRING displayPowell();
92040: PPUSH
92041: CALL_OW 559
// uc_side := 0 ;
92045: LD_ADDR_OWVAR 20
92049: PUSH
92050: LD_INT 0
92052: ST_TO_ADDR
// uc_nation := 2 ;
92053: LD_ADDR_OWVAR 21
92057: PUSH
92058: LD_INT 2
92060: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
92061: LD_ADDR_OWVAR 37
92065: PUSH
92066: LD_INT 14
92068: ST_TO_ADDR
// vc_engine := engine_siberite ;
92069: LD_ADDR_OWVAR 39
92073: PUSH
92074: LD_INT 3
92076: ST_TO_ADDR
// vc_control := control_apeman ;
92077: LD_ADDR_OWVAR 38
92081: PUSH
92082: LD_INT 5
92084: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
92085: LD_ADDR_OWVAR 40
92089: PUSH
92090: LD_INT 29
92092: ST_TO_ADDR
// un := CreateVehicle ;
92093: LD_ADDR_VAR 0 2
92097: PUSH
92098: CALL_OW 45
92102: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
92103: LD_VAR 0 2
92107: PPUSH
92108: LD_INT 1
92110: PPUSH
92111: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
92115: LD_INT 35
92117: PPUSH
92118: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
92122: LD_VAR 0 2
92126: PPUSH
92127: LD_INT 22
92129: PUSH
92130: LD_OWVAR 2
92134: PUSH
92135: EMPTY
92136: LIST
92137: LIST
92138: PPUSH
92139: CALL_OW 69
92143: PPUSH
92144: LD_VAR 0 2
92148: PPUSH
92149: CALL_OW 74
92153: PPUSH
92154: CALL_OW 115
// until IsDead ( un ) ;
92158: LD_VAR 0 2
92162: PPUSH
92163: CALL_OW 301
92167: IFFALSE 92115
// end ;
92169: PPOPN 2
92171: END
// every 0 0$1 trigger StreamModeActive and sStu do
92172: LD_EXP 108
92176: PUSH
92177: LD_EXP 147
92181: AND
92182: IFFALSE 92198
92184: GO 92186
92186: DISABLE
// begin ToLua ( displayStucuk(); ) ;
92187: LD_STRING displayStucuk();
92189: PPUSH
92190: CALL_OW 559
// ResetFog ;
92194: CALL_OW 335
// end ;
92198: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
92199: LD_EXP 108
92203: PUSH
92204: LD_EXP 140
92208: AND
92209: IFFALSE 92350
92211: GO 92213
92213: DISABLE
92214: LD_INT 0
92216: PPUSH
92217: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
92218: LD_ADDR_VAR 0 2
92222: PUSH
92223: LD_INT 22
92225: PUSH
92226: LD_OWVAR 2
92230: PUSH
92231: EMPTY
92232: LIST
92233: LIST
92234: PUSH
92235: LD_INT 21
92237: PUSH
92238: LD_INT 1
92240: PUSH
92241: EMPTY
92242: LIST
92243: LIST
92244: PUSH
92245: EMPTY
92246: LIST
92247: LIST
92248: PPUSH
92249: CALL_OW 69
92253: ST_TO_ADDR
// if not tmp then
92254: LD_VAR 0 2
92258: NOT
92259: IFFALSE 92263
// exit ;
92261: GO 92350
// un := tmp [ rand ( 1 , tmp ) ] ;
92263: LD_ADDR_VAR 0 1
92267: PUSH
92268: LD_VAR 0 2
92272: PUSH
92273: LD_INT 1
92275: PPUSH
92276: LD_VAR 0 2
92280: PPUSH
92281: CALL_OW 12
92285: ARRAY
92286: ST_TO_ADDR
// SetSide ( un , 0 ) ;
92287: LD_VAR 0 1
92291: PPUSH
92292: LD_INT 0
92294: PPUSH
92295: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
92299: LD_VAR 0 1
92303: PPUSH
92304: LD_OWVAR 3
92308: PUSH
92309: LD_VAR 0 1
92313: DIFF
92314: PPUSH
92315: LD_VAR 0 1
92319: PPUSH
92320: CALL_OW 74
92324: PPUSH
92325: CALL_OW 115
// wait ( 0 0$20 ) ;
92329: LD_INT 700
92331: PPUSH
92332: CALL_OW 67
// SetSide ( un , your_side ) ;
92336: LD_VAR 0 1
92340: PPUSH
92341: LD_OWVAR 2
92345: PPUSH
92346: CALL_OW 235
// end ;
92350: PPOPN 2
92352: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
92353: LD_EXP 108
92357: PUSH
92358: LD_EXP 141
92362: AND
92363: IFFALSE 92469
92365: GO 92367
92367: DISABLE
92368: LD_INT 0
92370: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
92371: LD_ADDR_VAR 0 1
92375: PUSH
92376: LD_INT 22
92378: PUSH
92379: LD_OWVAR 2
92383: PUSH
92384: EMPTY
92385: LIST
92386: LIST
92387: PUSH
92388: LD_INT 2
92390: PUSH
92391: LD_INT 30
92393: PUSH
92394: LD_INT 0
92396: PUSH
92397: EMPTY
92398: LIST
92399: LIST
92400: PUSH
92401: LD_INT 30
92403: PUSH
92404: LD_INT 1
92406: PUSH
92407: EMPTY
92408: LIST
92409: LIST
92410: PUSH
92411: EMPTY
92412: LIST
92413: LIST
92414: LIST
92415: PUSH
92416: EMPTY
92417: LIST
92418: LIST
92419: PPUSH
92420: CALL_OW 69
92424: ST_TO_ADDR
// if not depot then
92425: LD_VAR 0 1
92429: NOT
92430: IFFALSE 92434
// exit ;
92432: GO 92469
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
92434: LD_VAR 0 1
92438: PUSH
92439: LD_INT 1
92441: ARRAY
92442: PPUSH
92443: CALL_OW 250
92447: PPUSH
92448: LD_VAR 0 1
92452: PUSH
92453: LD_INT 1
92455: ARRAY
92456: PPUSH
92457: CALL_OW 251
92461: PPUSH
92462: LD_INT 70
92464: PPUSH
92465: CALL_OW 495
// end ;
92469: PPOPN 1
92471: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
92472: LD_EXP 108
92476: PUSH
92477: LD_EXP 142
92481: AND
92482: IFFALSE 92693
92484: GO 92486
92486: DISABLE
92487: LD_INT 0
92489: PPUSH
92490: PPUSH
92491: PPUSH
92492: PPUSH
92493: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
92494: LD_ADDR_VAR 0 5
92498: PUSH
92499: LD_INT 22
92501: PUSH
92502: LD_OWVAR 2
92506: PUSH
92507: EMPTY
92508: LIST
92509: LIST
92510: PUSH
92511: LD_INT 21
92513: PUSH
92514: LD_INT 1
92516: PUSH
92517: EMPTY
92518: LIST
92519: LIST
92520: PUSH
92521: EMPTY
92522: LIST
92523: LIST
92524: PPUSH
92525: CALL_OW 69
92529: ST_TO_ADDR
// if not tmp then
92530: LD_VAR 0 5
92534: NOT
92535: IFFALSE 92539
// exit ;
92537: GO 92693
// for i in tmp do
92539: LD_ADDR_VAR 0 1
92543: PUSH
92544: LD_VAR 0 5
92548: PUSH
92549: FOR_IN
92550: IFFALSE 92691
// begin d := rand ( 0 , 5 ) ;
92552: LD_ADDR_VAR 0 4
92556: PUSH
92557: LD_INT 0
92559: PPUSH
92560: LD_INT 5
92562: PPUSH
92563: CALL_OW 12
92567: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
92568: LD_ADDR_VAR 0 2
92572: PUSH
92573: LD_VAR 0 1
92577: PPUSH
92578: CALL_OW 250
92582: PPUSH
92583: LD_VAR 0 4
92587: PPUSH
92588: LD_INT 3
92590: PPUSH
92591: LD_INT 12
92593: PPUSH
92594: CALL_OW 12
92598: PPUSH
92599: CALL_OW 272
92603: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
92604: LD_ADDR_VAR 0 3
92608: PUSH
92609: LD_VAR 0 1
92613: PPUSH
92614: CALL_OW 251
92618: PPUSH
92619: LD_VAR 0 4
92623: PPUSH
92624: LD_INT 3
92626: PPUSH
92627: LD_INT 12
92629: PPUSH
92630: CALL_OW 12
92634: PPUSH
92635: CALL_OW 273
92639: ST_TO_ADDR
// if ValidHex ( x , y ) then
92640: LD_VAR 0 2
92644: PPUSH
92645: LD_VAR 0 3
92649: PPUSH
92650: CALL_OW 488
92654: IFFALSE 92689
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
92656: LD_VAR 0 1
92660: PPUSH
92661: LD_VAR 0 2
92665: PPUSH
92666: LD_VAR 0 3
92670: PPUSH
92671: LD_INT 3
92673: PPUSH
92674: LD_INT 6
92676: PPUSH
92677: CALL_OW 12
92681: PPUSH
92682: LD_INT 1
92684: PPUSH
92685: CALL_OW 483
// end ;
92689: GO 92549
92691: POP
92692: POP
// end ;
92693: PPOPN 5
92695: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
92696: LD_EXP 108
92700: PUSH
92701: LD_EXP 143
92705: AND
92706: IFFALSE 92800
92708: GO 92710
92710: DISABLE
92711: LD_INT 0
92713: PPUSH
92714: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
92715: LD_ADDR_VAR 0 2
92719: PUSH
92720: LD_INT 22
92722: PUSH
92723: LD_OWVAR 2
92727: PUSH
92728: EMPTY
92729: LIST
92730: LIST
92731: PUSH
92732: LD_INT 32
92734: PUSH
92735: LD_INT 1
92737: PUSH
92738: EMPTY
92739: LIST
92740: LIST
92741: PUSH
92742: LD_INT 21
92744: PUSH
92745: LD_INT 2
92747: PUSH
92748: EMPTY
92749: LIST
92750: LIST
92751: PUSH
92752: EMPTY
92753: LIST
92754: LIST
92755: LIST
92756: PPUSH
92757: CALL_OW 69
92761: ST_TO_ADDR
// if not tmp then
92762: LD_VAR 0 2
92766: NOT
92767: IFFALSE 92771
// exit ;
92769: GO 92800
// for i in tmp do
92771: LD_ADDR_VAR 0 1
92775: PUSH
92776: LD_VAR 0 2
92780: PUSH
92781: FOR_IN
92782: IFFALSE 92798
// SetFuel ( i , 0 ) ;
92784: LD_VAR 0 1
92788: PPUSH
92789: LD_INT 0
92791: PPUSH
92792: CALL_OW 240
92796: GO 92781
92798: POP
92799: POP
// end ;
92800: PPOPN 2
92802: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
92803: LD_EXP 108
92807: PUSH
92808: LD_EXP 144
92812: AND
92813: IFFALSE 92879
92815: GO 92817
92817: DISABLE
92818: LD_INT 0
92820: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
92821: LD_ADDR_VAR 0 1
92825: PUSH
92826: LD_INT 22
92828: PUSH
92829: LD_OWVAR 2
92833: PUSH
92834: EMPTY
92835: LIST
92836: LIST
92837: PUSH
92838: LD_INT 30
92840: PUSH
92841: LD_INT 29
92843: PUSH
92844: EMPTY
92845: LIST
92846: LIST
92847: PUSH
92848: EMPTY
92849: LIST
92850: LIST
92851: PPUSH
92852: CALL_OW 69
92856: ST_TO_ADDR
// if not tmp then
92857: LD_VAR 0 1
92861: NOT
92862: IFFALSE 92866
// exit ;
92864: GO 92879
// DestroyUnit ( tmp [ 1 ] ) ;
92866: LD_VAR 0 1
92870: PUSH
92871: LD_INT 1
92873: ARRAY
92874: PPUSH
92875: CALL_OW 65
// end ;
92879: PPOPN 1
92881: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
92882: LD_EXP 108
92886: PUSH
92887: LD_EXP 146
92891: AND
92892: IFFALSE 93021
92894: GO 92896
92896: DISABLE
92897: LD_INT 0
92899: PPUSH
// begin uc_side := 0 ;
92900: LD_ADDR_OWVAR 20
92904: PUSH
92905: LD_INT 0
92907: ST_TO_ADDR
// uc_nation := nation_arabian ;
92908: LD_ADDR_OWVAR 21
92912: PUSH
92913: LD_INT 2
92915: ST_TO_ADDR
// hc_gallery :=  ;
92916: LD_ADDR_OWVAR 33
92920: PUSH
92921: LD_STRING 
92923: ST_TO_ADDR
// hc_name :=  ;
92924: LD_ADDR_OWVAR 26
92928: PUSH
92929: LD_STRING 
92931: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
92932: LD_INT 1
92934: PPUSH
92935: LD_INT 11
92937: PPUSH
92938: LD_INT 10
92940: PPUSH
92941: CALL_OW 380
// un := CreateHuman ;
92945: LD_ADDR_VAR 0 1
92949: PUSH
92950: CALL_OW 44
92954: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
92955: LD_VAR 0 1
92959: PPUSH
92960: LD_INT 1
92962: PPUSH
92963: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
92967: LD_INT 35
92969: PPUSH
92970: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
92974: LD_VAR 0 1
92978: PPUSH
92979: LD_INT 22
92981: PUSH
92982: LD_OWVAR 2
92986: PUSH
92987: EMPTY
92988: LIST
92989: LIST
92990: PPUSH
92991: CALL_OW 69
92995: PPUSH
92996: LD_VAR 0 1
93000: PPUSH
93001: CALL_OW 74
93005: PPUSH
93006: CALL_OW 115
// until IsDead ( un ) ;
93010: LD_VAR 0 1
93014: PPUSH
93015: CALL_OW 301
93019: IFFALSE 92967
// end ;
93021: PPOPN 1
93023: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
93024: LD_EXP 108
93028: PUSH
93029: LD_EXP 148
93033: AND
93034: IFFALSE 93046
93036: GO 93038
93038: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
93039: LD_STRING earthquake(getX(game), 0, 32)
93041: PPUSH
93042: CALL_OW 559
93046: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
93047: LD_EXP 108
93051: PUSH
93052: LD_EXP 149
93056: AND
93057: IFFALSE 93148
93059: GO 93061
93061: DISABLE
93062: LD_INT 0
93064: PPUSH
// begin enable ;
93065: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
93066: LD_ADDR_VAR 0 1
93070: PUSH
93071: LD_INT 22
93073: PUSH
93074: LD_OWVAR 2
93078: PUSH
93079: EMPTY
93080: LIST
93081: LIST
93082: PUSH
93083: LD_INT 21
93085: PUSH
93086: LD_INT 2
93088: PUSH
93089: EMPTY
93090: LIST
93091: LIST
93092: PUSH
93093: LD_INT 33
93095: PUSH
93096: LD_INT 3
93098: PUSH
93099: EMPTY
93100: LIST
93101: LIST
93102: PUSH
93103: EMPTY
93104: LIST
93105: LIST
93106: LIST
93107: PPUSH
93108: CALL_OW 69
93112: ST_TO_ADDR
// if not tmp then
93113: LD_VAR 0 1
93117: NOT
93118: IFFALSE 93122
// exit ;
93120: GO 93148
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
93122: LD_VAR 0 1
93126: PUSH
93127: LD_INT 1
93129: PPUSH
93130: LD_VAR 0 1
93134: PPUSH
93135: CALL_OW 12
93139: ARRAY
93140: PPUSH
93141: LD_INT 1
93143: PPUSH
93144: CALL_OW 234
// end ;
93148: PPOPN 1
93150: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
93151: LD_EXP 108
93155: PUSH
93156: LD_EXP 150
93160: AND
93161: IFFALSE 93302
93163: GO 93165
93165: DISABLE
93166: LD_INT 0
93168: PPUSH
93169: PPUSH
93170: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
93171: LD_ADDR_VAR 0 3
93175: PUSH
93176: LD_INT 22
93178: PUSH
93179: LD_OWVAR 2
93183: PUSH
93184: EMPTY
93185: LIST
93186: LIST
93187: PUSH
93188: LD_INT 25
93190: PUSH
93191: LD_INT 1
93193: PUSH
93194: EMPTY
93195: LIST
93196: LIST
93197: PUSH
93198: EMPTY
93199: LIST
93200: LIST
93201: PPUSH
93202: CALL_OW 69
93206: ST_TO_ADDR
// if not tmp then
93207: LD_VAR 0 3
93211: NOT
93212: IFFALSE 93216
// exit ;
93214: GO 93302
// un := tmp [ rand ( 1 , tmp ) ] ;
93216: LD_ADDR_VAR 0 2
93220: PUSH
93221: LD_VAR 0 3
93225: PUSH
93226: LD_INT 1
93228: PPUSH
93229: LD_VAR 0 3
93233: PPUSH
93234: CALL_OW 12
93238: ARRAY
93239: ST_TO_ADDR
// if Crawls ( un ) then
93240: LD_VAR 0 2
93244: PPUSH
93245: CALL_OW 318
93249: IFFALSE 93260
// ComWalk ( un ) ;
93251: LD_VAR 0 2
93255: PPUSH
93256: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
93260: LD_VAR 0 2
93264: PPUSH
93265: LD_INT 9
93267: PPUSH
93268: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
93272: LD_INT 28
93274: PPUSH
93275: LD_OWVAR 2
93279: PPUSH
93280: LD_INT 2
93282: PPUSH
93283: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
93287: LD_INT 29
93289: PPUSH
93290: LD_OWVAR 2
93294: PPUSH
93295: LD_INT 2
93297: PPUSH
93298: CALL_OW 322
// end ;
93302: PPOPN 3
93304: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
93305: LD_EXP 108
93309: PUSH
93310: LD_EXP 151
93314: AND
93315: IFFALSE 93426
93317: GO 93319
93319: DISABLE
93320: LD_INT 0
93322: PPUSH
93323: PPUSH
93324: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
93325: LD_ADDR_VAR 0 3
93329: PUSH
93330: LD_INT 22
93332: PUSH
93333: LD_OWVAR 2
93337: PUSH
93338: EMPTY
93339: LIST
93340: LIST
93341: PUSH
93342: LD_INT 25
93344: PUSH
93345: LD_INT 1
93347: PUSH
93348: EMPTY
93349: LIST
93350: LIST
93351: PUSH
93352: EMPTY
93353: LIST
93354: LIST
93355: PPUSH
93356: CALL_OW 69
93360: ST_TO_ADDR
// if not tmp then
93361: LD_VAR 0 3
93365: NOT
93366: IFFALSE 93370
// exit ;
93368: GO 93426
// un := tmp [ rand ( 1 , tmp ) ] ;
93370: LD_ADDR_VAR 0 2
93374: PUSH
93375: LD_VAR 0 3
93379: PUSH
93380: LD_INT 1
93382: PPUSH
93383: LD_VAR 0 3
93387: PPUSH
93388: CALL_OW 12
93392: ARRAY
93393: ST_TO_ADDR
// if Crawls ( un ) then
93394: LD_VAR 0 2
93398: PPUSH
93399: CALL_OW 318
93403: IFFALSE 93414
// ComWalk ( un ) ;
93405: LD_VAR 0 2
93409: PPUSH
93410: CALL_OW 138
// SetClass ( un , class_mortar ) ;
93414: LD_VAR 0 2
93418: PPUSH
93419: LD_INT 8
93421: PPUSH
93422: CALL_OW 336
// end ;
93426: PPOPN 3
93428: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
93429: LD_EXP 108
93433: PUSH
93434: LD_EXP 152
93438: AND
93439: IFFALSE 93583
93441: GO 93443
93443: DISABLE
93444: LD_INT 0
93446: PPUSH
93447: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
93448: LD_ADDR_VAR 0 2
93452: PUSH
93453: LD_INT 22
93455: PUSH
93456: LD_OWVAR 2
93460: PUSH
93461: EMPTY
93462: LIST
93463: LIST
93464: PUSH
93465: LD_INT 21
93467: PUSH
93468: LD_INT 2
93470: PUSH
93471: EMPTY
93472: LIST
93473: LIST
93474: PUSH
93475: LD_INT 2
93477: PUSH
93478: LD_INT 34
93480: PUSH
93481: LD_INT 12
93483: PUSH
93484: EMPTY
93485: LIST
93486: LIST
93487: PUSH
93488: LD_INT 34
93490: PUSH
93491: LD_INT 51
93493: PUSH
93494: EMPTY
93495: LIST
93496: LIST
93497: PUSH
93498: LD_INT 34
93500: PUSH
93501: LD_INT 32
93503: PUSH
93504: EMPTY
93505: LIST
93506: LIST
93507: PUSH
93508: EMPTY
93509: LIST
93510: LIST
93511: LIST
93512: LIST
93513: PUSH
93514: EMPTY
93515: LIST
93516: LIST
93517: LIST
93518: PPUSH
93519: CALL_OW 69
93523: ST_TO_ADDR
// if not tmp then
93524: LD_VAR 0 2
93528: NOT
93529: IFFALSE 93533
// exit ;
93531: GO 93583
// for i in tmp do
93533: LD_ADDR_VAR 0 1
93537: PUSH
93538: LD_VAR 0 2
93542: PUSH
93543: FOR_IN
93544: IFFALSE 93581
// if GetCargo ( i , mat_artifact ) = 0 then
93546: LD_VAR 0 1
93550: PPUSH
93551: LD_INT 4
93553: PPUSH
93554: CALL_OW 289
93558: PUSH
93559: LD_INT 0
93561: EQUAL
93562: IFFALSE 93579
// SetCargo ( i , mat_siberit , 100 ) ;
93564: LD_VAR 0 1
93568: PPUSH
93569: LD_INT 3
93571: PPUSH
93572: LD_INT 100
93574: PPUSH
93575: CALL_OW 290
93579: GO 93543
93581: POP
93582: POP
// end ;
93583: PPOPN 2
93585: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
93586: LD_EXP 108
93590: PUSH
93591: LD_EXP 153
93595: AND
93596: IFFALSE 93779
93598: GO 93600
93600: DISABLE
93601: LD_INT 0
93603: PPUSH
93604: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
93605: LD_ADDR_VAR 0 2
93609: PUSH
93610: LD_INT 22
93612: PUSH
93613: LD_OWVAR 2
93617: PUSH
93618: EMPTY
93619: LIST
93620: LIST
93621: PPUSH
93622: CALL_OW 69
93626: ST_TO_ADDR
// if not tmp then
93627: LD_VAR 0 2
93631: NOT
93632: IFFALSE 93636
// exit ;
93634: GO 93779
// for i := 1 to 2 do
93636: LD_ADDR_VAR 0 1
93640: PUSH
93641: DOUBLE
93642: LD_INT 1
93644: DEC
93645: ST_TO_ADDR
93646: LD_INT 2
93648: PUSH
93649: FOR_TO
93650: IFFALSE 93777
// begin uc_side := your_side ;
93652: LD_ADDR_OWVAR 20
93656: PUSH
93657: LD_OWVAR 2
93661: ST_TO_ADDR
// uc_nation := nation_american ;
93662: LD_ADDR_OWVAR 21
93666: PUSH
93667: LD_INT 1
93669: ST_TO_ADDR
// vc_chassis := us_morphling ;
93670: LD_ADDR_OWVAR 37
93674: PUSH
93675: LD_INT 5
93677: ST_TO_ADDR
// vc_engine := engine_siberite ;
93678: LD_ADDR_OWVAR 39
93682: PUSH
93683: LD_INT 3
93685: ST_TO_ADDR
// vc_control := control_computer ;
93686: LD_ADDR_OWVAR 38
93690: PUSH
93691: LD_INT 3
93693: ST_TO_ADDR
// vc_weapon := us_double_laser ;
93694: LD_ADDR_OWVAR 40
93698: PUSH
93699: LD_INT 10
93701: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
93702: LD_VAR 0 2
93706: PUSH
93707: LD_INT 1
93709: ARRAY
93710: PPUSH
93711: CALL_OW 310
93715: NOT
93716: IFFALSE 93763
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
93718: CALL_OW 45
93722: PPUSH
93723: LD_VAR 0 2
93727: PUSH
93728: LD_INT 1
93730: ARRAY
93731: PPUSH
93732: CALL_OW 250
93736: PPUSH
93737: LD_VAR 0 2
93741: PUSH
93742: LD_INT 1
93744: ARRAY
93745: PPUSH
93746: CALL_OW 251
93750: PPUSH
93751: LD_INT 12
93753: PPUSH
93754: LD_INT 1
93756: PPUSH
93757: CALL_OW 50
93761: GO 93775
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
93763: CALL_OW 45
93767: PPUSH
93768: LD_INT 1
93770: PPUSH
93771: CALL_OW 51
// end ;
93775: GO 93649
93777: POP
93778: POP
// end ;
93779: PPOPN 2
93781: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
93782: LD_EXP 108
93786: PUSH
93787: LD_EXP 154
93791: AND
93792: IFFALSE 94014
93794: GO 93796
93796: DISABLE
93797: LD_INT 0
93799: PPUSH
93800: PPUSH
93801: PPUSH
93802: PPUSH
93803: PPUSH
93804: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
93805: LD_ADDR_VAR 0 6
93809: PUSH
93810: LD_INT 22
93812: PUSH
93813: LD_OWVAR 2
93817: PUSH
93818: EMPTY
93819: LIST
93820: LIST
93821: PUSH
93822: LD_INT 21
93824: PUSH
93825: LD_INT 1
93827: PUSH
93828: EMPTY
93829: LIST
93830: LIST
93831: PUSH
93832: LD_INT 3
93834: PUSH
93835: LD_INT 23
93837: PUSH
93838: LD_INT 0
93840: PUSH
93841: EMPTY
93842: LIST
93843: LIST
93844: PUSH
93845: EMPTY
93846: LIST
93847: LIST
93848: PUSH
93849: EMPTY
93850: LIST
93851: LIST
93852: LIST
93853: PPUSH
93854: CALL_OW 69
93858: ST_TO_ADDR
// if not tmp then
93859: LD_VAR 0 6
93863: NOT
93864: IFFALSE 93868
// exit ;
93866: GO 94014
// s1 := rand ( 1 , 4 ) ;
93868: LD_ADDR_VAR 0 2
93872: PUSH
93873: LD_INT 1
93875: PPUSH
93876: LD_INT 4
93878: PPUSH
93879: CALL_OW 12
93883: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
93884: LD_ADDR_VAR 0 4
93888: PUSH
93889: LD_VAR 0 6
93893: PUSH
93894: LD_INT 1
93896: ARRAY
93897: PPUSH
93898: LD_VAR 0 2
93902: PPUSH
93903: CALL_OW 259
93907: ST_TO_ADDR
// if s1 = 1 then
93908: LD_VAR 0 2
93912: PUSH
93913: LD_INT 1
93915: EQUAL
93916: IFFALSE 93936
// s2 := rand ( 2 , 4 ) else
93918: LD_ADDR_VAR 0 3
93922: PUSH
93923: LD_INT 2
93925: PPUSH
93926: LD_INT 4
93928: PPUSH
93929: CALL_OW 12
93933: ST_TO_ADDR
93934: GO 93944
// s2 := 1 ;
93936: LD_ADDR_VAR 0 3
93940: PUSH
93941: LD_INT 1
93943: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
93944: LD_ADDR_VAR 0 5
93948: PUSH
93949: LD_VAR 0 6
93953: PUSH
93954: LD_INT 1
93956: ARRAY
93957: PPUSH
93958: LD_VAR 0 3
93962: PPUSH
93963: CALL_OW 259
93967: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
93968: LD_VAR 0 6
93972: PUSH
93973: LD_INT 1
93975: ARRAY
93976: PPUSH
93977: LD_VAR 0 2
93981: PPUSH
93982: LD_VAR 0 5
93986: PPUSH
93987: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
93991: LD_VAR 0 6
93995: PUSH
93996: LD_INT 1
93998: ARRAY
93999: PPUSH
94000: LD_VAR 0 3
94004: PPUSH
94005: LD_VAR 0 4
94009: PPUSH
94010: CALL_OW 237
// end ;
94014: PPOPN 6
94016: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
94017: LD_EXP 108
94021: PUSH
94022: LD_EXP 155
94026: AND
94027: IFFALSE 94106
94029: GO 94031
94031: DISABLE
94032: LD_INT 0
94034: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
94035: LD_ADDR_VAR 0 1
94039: PUSH
94040: LD_INT 22
94042: PUSH
94043: LD_OWVAR 2
94047: PUSH
94048: EMPTY
94049: LIST
94050: LIST
94051: PUSH
94052: LD_INT 30
94054: PUSH
94055: LD_INT 3
94057: PUSH
94058: EMPTY
94059: LIST
94060: LIST
94061: PUSH
94062: EMPTY
94063: LIST
94064: LIST
94065: PPUSH
94066: CALL_OW 69
94070: ST_TO_ADDR
// if not tmp then
94071: LD_VAR 0 1
94075: NOT
94076: IFFALSE 94080
// exit ;
94078: GO 94106
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
94080: LD_VAR 0 1
94084: PUSH
94085: LD_INT 1
94087: PPUSH
94088: LD_VAR 0 1
94092: PPUSH
94093: CALL_OW 12
94097: ARRAY
94098: PPUSH
94099: LD_INT 1
94101: PPUSH
94102: CALL_OW 234
// end ;
94106: PPOPN 1
94108: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
94109: LD_EXP 108
94113: PUSH
94114: LD_EXP 156
94118: AND
94119: IFFALSE 94231
94121: GO 94123
94123: DISABLE
94124: LD_INT 0
94126: PPUSH
94127: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
94128: LD_ADDR_VAR 0 2
94132: PUSH
94133: LD_INT 22
94135: PUSH
94136: LD_OWVAR 2
94140: PUSH
94141: EMPTY
94142: LIST
94143: LIST
94144: PUSH
94145: LD_INT 2
94147: PUSH
94148: LD_INT 30
94150: PUSH
94151: LD_INT 27
94153: PUSH
94154: EMPTY
94155: LIST
94156: LIST
94157: PUSH
94158: LD_INT 30
94160: PUSH
94161: LD_INT 26
94163: PUSH
94164: EMPTY
94165: LIST
94166: LIST
94167: PUSH
94168: LD_INT 30
94170: PUSH
94171: LD_INT 28
94173: PUSH
94174: EMPTY
94175: LIST
94176: LIST
94177: PUSH
94178: EMPTY
94179: LIST
94180: LIST
94181: LIST
94182: LIST
94183: PUSH
94184: EMPTY
94185: LIST
94186: LIST
94187: PPUSH
94188: CALL_OW 69
94192: ST_TO_ADDR
// if not tmp then
94193: LD_VAR 0 2
94197: NOT
94198: IFFALSE 94202
// exit ;
94200: GO 94231
// for i in tmp do
94202: LD_ADDR_VAR 0 1
94206: PUSH
94207: LD_VAR 0 2
94211: PUSH
94212: FOR_IN
94213: IFFALSE 94229
// SetLives ( i , 1 ) ;
94215: LD_VAR 0 1
94219: PPUSH
94220: LD_INT 1
94222: PPUSH
94223: CALL_OW 234
94227: GO 94212
94229: POP
94230: POP
// end ;
94231: PPOPN 2
94233: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
94234: LD_EXP 108
94238: PUSH
94239: LD_EXP 157
94243: AND
94244: IFFALSE 94518
94246: GO 94248
94248: DISABLE
94249: LD_INT 0
94251: PPUSH
94252: PPUSH
94253: PPUSH
// begin i := rand ( 1 , 7 ) ;
94254: LD_ADDR_VAR 0 1
94258: PUSH
94259: LD_INT 1
94261: PPUSH
94262: LD_INT 7
94264: PPUSH
94265: CALL_OW 12
94269: ST_TO_ADDR
// case i of 1 :
94270: LD_VAR 0 1
94274: PUSH
94275: LD_INT 1
94277: DOUBLE
94278: EQUAL
94279: IFTRUE 94283
94281: GO 94293
94283: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
94284: LD_STRING earthquake(getX(game), 0, 32)
94286: PPUSH
94287: CALL_OW 559
94291: GO 94518
94293: LD_INT 2
94295: DOUBLE
94296: EQUAL
94297: IFTRUE 94301
94299: GO 94315
94301: POP
// begin ToLua ( displayStucuk(); ) ;
94302: LD_STRING displayStucuk();
94304: PPUSH
94305: CALL_OW 559
// ResetFog ;
94309: CALL_OW 335
// end ; 3 :
94313: GO 94518
94315: LD_INT 3
94317: DOUBLE
94318: EQUAL
94319: IFTRUE 94323
94321: GO 94427
94323: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
94324: LD_ADDR_VAR 0 2
94328: PUSH
94329: LD_INT 22
94331: PUSH
94332: LD_OWVAR 2
94336: PUSH
94337: EMPTY
94338: LIST
94339: LIST
94340: PUSH
94341: LD_INT 25
94343: PUSH
94344: LD_INT 1
94346: PUSH
94347: EMPTY
94348: LIST
94349: LIST
94350: PUSH
94351: EMPTY
94352: LIST
94353: LIST
94354: PPUSH
94355: CALL_OW 69
94359: ST_TO_ADDR
// if not tmp then
94360: LD_VAR 0 2
94364: NOT
94365: IFFALSE 94369
// exit ;
94367: GO 94518
// un := tmp [ rand ( 1 , tmp ) ] ;
94369: LD_ADDR_VAR 0 3
94373: PUSH
94374: LD_VAR 0 2
94378: PUSH
94379: LD_INT 1
94381: PPUSH
94382: LD_VAR 0 2
94386: PPUSH
94387: CALL_OW 12
94391: ARRAY
94392: ST_TO_ADDR
// if Crawls ( un ) then
94393: LD_VAR 0 3
94397: PPUSH
94398: CALL_OW 318
94402: IFFALSE 94413
// ComWalk ( un ) ;
94404: LD_VAR 0 3
94408: PPUSH
94409: CALL_OW 138
// SetClass ( un , class_mortar ) ;
94413: LD_VAR 0 3
94417: PPUSH
94418: LD_INT 8
94420: PPUSH
94421: CALL_OW 336
// end ; 4 :
94425: GO 94518
94427: LD_INT 4
94429: DOUBLE
94430: EQUAL
94431: IFTRUE 94435
94433: GO 94496
94435: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
94436: LD_ADDR_VAR 0 2
94440: PUSH
94441: LD_INT 22
94443: PUSH
94444: LD_OWVAR 2
94448: PUSH
94449: EMPTY
94450: LIST
94451: LIST
94452: PUSH
94453: LD_INT 30
94455: PUSH
94456: LD_INT 29
94458: PUSH
94459: EMPTY
94460: LIST
94461: LIST
94462: PUSH
94463: EMPTY
94464: LIST
94465: LIST
94466: PPUSH
94467: CALL_OW 69
94471: ST_TO_ADDR
// if not tmp then
94472: LD_VAR 0 2
94476: NOT
94477: IFFALSE 94481
// exit ;
94479: GO 94518
// DestroyUnit ( tmp [ 1 ] ) ;
94481: LD_VAR 0 2
94485: PUSH
94486: LD_INT 1
94488: ARRAY
94489: PPUSH
94490: CALL_OW 65
// end ; 5 .. 7 :
94494: GO 94518
94496: LD_INT 5
94498: DOUBLE
94499: GREATEREQUAL
94500: IFFALSE 94508
94502: LD_INT 7
94504: DOUBLE
94505: LESSEQUAL
94506: IFTRUE 94510
94508: GO 94517
94510: POP
// StreamSibBomb ; end ;
94511: CALL 90768 0 0
94515: GO 94518
94517: POP
// end ;
94518: PPOPN 3
94520: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
94521: LD_EXP 108
94525: PUSH
94526: LD_EXP 158
94530: AND
94531: IFFALSE 94687
94533: GO 94535
94535: DISABLE
94536: LD_INT 0
94538: PPUSH
94539: PPUSH
94540: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
94541: LD_ADDR_VAR 0 2
94545: PUSH
94546: LD_INT 81
94548: PUSH
94549: LD_OWVAR 2
94553: PUSH
94554: EMPTY
94555: LIST
94556: LIST
94557: PUSH
94558: LD_INT 2
94560: PUSH
94561: LD_INT 21
94563: PUSH
94564: LD_INT 1
94566: PUSH
94567: EMPTY
94568: LIST
94569: LIST
94570: PUSH
94571: LD_INT 21
94573: PUSH
94574: LD_INT 2
94576: PUSH
94577: EMPTY
94578: LIST
94579: LIST
94580: PUSH
94581: EMPTY
94582: LIST
94583: LIST
94584: LIST
94585: PUSH
94586: EMPTY
94587: LIST
94588: LIST
94589: PPUSH
94590: CALL_OW 69
94594: ST_TO_ADDR
// if not tmp then
94595: LD_VAR 0 2
94599: NOT
94600: IFFALSE 94604
// exit ;
94602: GO 94687
// p := 0 ;
94604: LD_ADDR_VAR 0 3
94608: PUSH
94609: LD_INT 0
94611: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
94612: LD_INT 35
94614: PPUSH
94615: CALL_OW 67
// p := p + 1 ;
94619: LD_ADDR_VAR 0 3
94623: PUSH
94624: LD_VAR 0 3
94628: PUSH
94629: LD_INT 1
94631: PLUS
94632: ST_TO_ADDR
// for i in tmp do
94633: LD_ADDR_VAR 0 1
94637: PUSH
94638: LD_VAR 0 2
94642: PUSH
94643: FOR_IN
94644: IFFALSE 94675
// if GetLives ( i ) < 1000 then
94646: LD_VAR 0 1
94650: PPUSH
94651: CALL_OW 256
94655: PUSH
94656: LD_INT 1000
94658: LESS
94659: IFFALSE 94673
// SetLives ( i , 1000 ) ;
94661: LD_VAR 0 1
94665: PPUSH
94666: LD_INT 1000
94668: PPUSH
94669: CALL_OW 234
94673: GO 94643
94675: POP
94676: POP
// until p > 20 ;
94677: LD_VAR 0 3
94681: PUSH
94682: LD_INT 20
94684: GREATER
94685: IFFALSE 94612
// end ;
94687: PPOPN 3
94689: END
// every 0 0$1 trigger StreamModeActive and sTime do
94690: LD_EXP 108
94694: PUSH
94695: LD_EXP 159
94699: AND
94700: IFFALSE 94735
94702: GO 94704
94704: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
94705: LD_INT 28
94707: PPUSH
94708: LD_OWVAR 2
94712: PPUSH
94713: LD_INT 2
94715: PPUSH
94716: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
94720: LD_INT 30
94722: PPUSH
94723: LD_OWVAR 2
94727: PPUSH
94728: LD_INT 2
94730: PPUSH
94731: CALL_OW 322
// end ;
94735: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
94736: LD_EXP 108
94740: PUSH
94741: LD_EXP 160
94745: AND
94746: IFFALSE 94867
94748: GO 94750
94750: DISABLE
94751: LD_INT 0
94753: PPUSH
94754: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
94755: LD_ADDR_VAR 0 2
94759: PUSH
94760: LD_INT 22
94762: PUSH
94763: LD_OWVAR 2
94767: PUSH
94768: EMPTY
94769: LIST
94770: LIST
94771: PUSH
94772: LD_INT 21
94774: PUSH
94775: LD_INT 1
94777: PUSH
94778: EMPTY
94779: LIST
94780: LIST
94781: PUSH
94782: LD_INT 3
94784: PUSH
94785: LD_INT 23
94787: PUSH
94788: LD_INT 0
94790: PUSH
94791: EMPTY
94792: LIST
94793: LIST
94794: PUSH
94795: EMPTY
94796: LIST
94797: LIST
94798: PUSH
94799: EMPTY
94800: LIST
94801: LIST
94802: LIST
94803: PPUSH
94804: CALL_OW 69
94808: ST_TO_ADDR
// if not tmp then
94809: LD_VAR 0 2
94813: NOT
94814: IFFALSE 94818
// exit ;
94816: GO 94867
// for i in tmp do
94818: LD_ADDR_VAR 0 1
94822: PUSH
94823: LD_VAR 0 2
94827: PUSH
94828: FOR_IN
94829: IFFALSE 94865
// begin if Crawls ( i ) then
94831: LD_VAR 0 1
94835: PPUSH
94836: CALL_OW 318
94840: IFFALSE 94851
// ComWalk ( i ) ;
94842: LD_VAR 0 1
94846: PPUSH
94847: CALL_OW 138
// SetClass ( i , 2 ) ;
94851: LD_VAR 0 1
94855: PPUSH
94856: LD_INT 2
94858: PPUSH
94859: CALL_OW 336
// end ;
94863: GO 94828
94865: POP
94866: POP
// end ;
94867: PPOPN 2
94869: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
94870: LD_EXP 108
94874: PUSH
94875: LD_EXP 161
94879: AND
94880: IFFALSE 95161
94882: GO 94884
94884: DISABLE
94885: LD_INT 0
94887: PPUSH
94888: PPUSH
94889: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
94890: LD_OWVAR 2
94894: PPUSH
94895: LD_INT 9
94897: PPUSH
94898: LD_INT 1
94900: PPUSH
94901: LD_INT 1
94903: PPUSH
94904: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
94908: LD_INT 9
94910: PPUSH
94911: LD_OWVAR 2
94915: PPUSH
94916: CALL_OW 343
// uc_side := 9 ;
94920: LD_ADDR_OWVAR 20
94924: PUSH
94925: LD_INT 9
94927: ST_TO_ADDR
// uc_nation := 2 ;
94928: LD_ADDR_OWVAR 21
94932: PUSH
94933: LD_INT 2
94935: ST_TO_ADDR
// hc_name := Dark Warrior ;
94936: LD_ADDR_OWVAR 26
94940: PUSH
94941: LD_STRING Dark Warrior
94943: ST_TO_ADDR
// hc_gallery :=  ;
94944: LD_ADDR_OWVAR 33
94948: PUSH
94949: LD_STRING 
94951: ST_TO_ADDR
// hc_noskilllimit := true ;
94952: LD_ADDR_OWVAR 76
94956: PUSH
94957: LD_INT 1
94959: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
94960: LD_ADDR_OWVAR 31
94964: PUSH
94965: LD_INT 30
94967: PUSH
94968: LD_INT 30
94970: PUSH
94971: LD_INT 30
94973: PUSH
94974: LD_INT 30
94976: PUSH
94977: EMPTY
94978: LIST
94979: LIST
94980: LIST
94981: LIST
94982: ST_TO_ADDR
// un := CreateHuman ;
94983: LD_ADDR_VAR 0 3
94987: PUSH
94988: CALL_OW 44
94992: ST_TO_ADDR
// hc_noskilllimit := false ;
94993: LD_ADDR_OWVAR 76
94997: PUSH
94998: LD_INT 0
95000: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
95001: LD_VAR 0 3
95005: PPUSH
95006: LD_INT 1
95008: PPUSH
95009: CALL_OW 51
// p := 0 ;
95013: LD_ADDR_VAR 0 2
95017: PUSH
95018: LD_INT 0
95020: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
95021: LD_INT 35
95023: PPUSH
95024: CALL_OW 67
// p := p + 1 ;
95028: LD_ADDR_VAR 0 2
95032: PUSH
95033: LD_VAR 0 2
95037: PUSH
95038: LD_INT 1
95040: PLUS
95041: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
95042: LD_VAR 0 3
95046: PPUSH
95047: CALL_OW 256
95051: PUSH
95052: LD_INT 1000
95054: LESS
95055: IFFALSE 95069
// SetLives ( un , 1000 ) ;
95057: LD_VAR 0 3
95061: PPUSH
95062: LD_INT 1000
95064: PPUSH
95065: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
95069: LD_VAR 0 3
95073: PPUSH
95074: LD_INT 81
95076: PUSH
95077: LD_OWVAR 2
95081: PUSH
95082: EMPTY
95083: LIST
95084: LIST
95085: PUSH
95086: LD_INT 91
95088: PUSH
95089: LD_VAR 0 3
95093: PUSH
95094: LD_INT 30
95096: PUSH
95097: EMPTY
95098: LIST
95099: LIST
95100: LIST
95101: PUSH
95102: EMPTY
95103: LIST
95104: LIST
95105: PPUSH
95106: CALL_OW 69
95110: PPUSH
95111: LD_VAR 0 3
95115: PPUSH
95116: CALL_OW 74
95120: PPUSH
95121: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
95125: LD_VAR 0 2
95129: PUSH
95130: LD_INT 60
95132: GREATER
95133: PUSH
95134: LD_VAR 0 3
95138: PPUSH
95139: CALL_OW 301
95143: OR
95144: IFFALSE 95021
// if un then
95146: LD_VAR 0 3
95150: IFFALSE 95161
// RemoveUnit ( un ) ;
95152: LD_VAR 0 3
95156: PPUSH
95157: CALL_OW 64
// end ;
95161: PPOPN 3
95163: END
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
95164: LD_INT 0
95166: PPUSH
95167: PPUSH
95168: PPUSH
95169: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
95170: LD_ADDR_VAR 0 4
95174: PUSH
95175: LD_INT 22
95177: PUSH
95178: LD_OWVAR 2
95182: PUSH
95183: EMPTY
95184: LIST
95185: LIST
95186: PUSH
95187: LD_INT 2
95189: PUSH
95190: LD_INT 30
95192: PUSH
95193: LD_INT 0
95195: PUSH
95196: EMPTY
95197: LIST
95198: LIST
95199: PUSH
95200: LD_INT 30
95202: PUSH
95203: LD_INT 1
95205: PUSH
95206: EMPTY
95207: LIST
95208: LIST
95209: PUSH
95210: EMPTY
95211: LIST
95212: LIST
95213: LIST
95214: PUSH
95215: EMPTY
95216: LIST
95217: LIST
95218: PPUSH
95219: CALL_OW 69
95223: ST_TO_ADDR
// if not tmp then
95224: LD_VAR 0 4
95228: NOT
95229: IFFALSE 95233
// exit ;
95231: GO 95292
// for i in tmp do
95233: LD_ADDR_VAR 0 2
95237: PUSH
95238: LD_VAR 0 4
95242: PUSH
95243: FOR_IN
95244: IFFALSE 95290
// for j = 1 to 3 do
95246: LD_ADDR_VAR 0 3
95250: PUSH
95251: DOUBLE
95252: LD_INT 1
95254: DEC
95255: ST_TO_ADDR
95256: LD_INT 3
95258: PUSH
95259: FOR_TO
95260: IFFALSE 95286
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
95262: LD_VAR 0 2
95266: PPUSH
95267: CALL_OW 274
95271: PPUSH
95272: LD_VAR 0 3
95276: PPUSH
95277: LD_INT 99999
95279: PPUSH
95280: CALL_OW 277
95284: GO 95259
95286: POP
95287: POP
95288: GO 95243
95290: POP
95291: POP
// end ;
95292: LD_VAR 0 1
95296: RET
// export function hHackSetLevel10 ; var i , j ; begin
95297: LD_INT 0
95299: PPUSH
95300: PPUSH
95301: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
95302: LD_ADDR_VAR 0 2
95306: PUSH
95307: LD_INT 21
95309: PUSH
95310: LD_INT 1
95312: PUSH
95313: EMPTY
95314: LIST
95315: LIST
95316: PPUSH
95317: CALL_OW 69
95321: PUSH
95322: FOR_IN
95323: IFFALSE 95375
// if IsSelected ( i ) then
95325: LD_VAR 0 2
95329: PPUSH
95330: CALL_OW 306
95334: IFFALSE 95373
// begin for j := 1 to 4 do
95336: LD_ADDR_VAR 0 3
95340: PUSH
95341: DOUBLE
95342: LD_INT 1
95344: DEC
95345: ST_TO_ADDR
95346: LD_INT 4
95348: PUSH
95349: FOR_TO
95350: IFFALSE 95371
// SetSkill ( i , j , 10 ) ;
95352: LD_VAR 0 2
95356: PPUSH
95357: LD_VAR 0 3
95361: PPUSH
95362: LD_INT 10
95364: PPUSH
95365: CALL_OW 237
95369: GO 95349
95371: POP
95372: POP
// end ;
95373: GO 95322
95375: POP
95376: POP
// end ;
95377: LD_VAR 0 1
95381: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
95382: LD_INT 0
95384: PPUSH
95385: PPUSH
95386: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
95387: LD_ADDR_VAR 0 2
95391: PUSH
95392: LD_INT 22
95394: PUSH
95395: LD_OWVAR 2
95399: PUSH
95400: EMPTY
95401: LIST
95402: LIST
95403: PUSH
95404: LD_INT 21
95406: PUSH
95407: LD_INT 1
95409: PUSH
95410: EMPTY
95411: LIST
95412: LIST
95413: PUSH
95414: EMPTY
95415: LIST
95416: LIST
95417: PPUSH
95418: CALL_OW 69
95422: PUSH
95423: FOR_IN
95424: IFFALSE 95465
// begin for j := 1 to 4 do
95426: LD_ADDR_VAR 0 3
95430: PUSH
95431: DOUBLE
95432: LD_INT 1
95434: DEC
95435: ST_TO_ADDR
95436: LD_INT 4
95438: PUSH
95439: FOR_TO
95440: IFFALSE 95461
// SetSkill ( i , j , 10 ) ;
95442: LD_VAR 0 2
95446: PPUSH
95447: LD_VAR 0 3
95451: PPUSH
95452: LD_INT 10
95454: PPUSH
95455: CALL_OW 237
95459: GO 95439
95461: POP
95462: POP
// end ;
95463: GO 95423
95465: POP
95466: POP
// end ;
95467: LD_VAR 0 1
95471: RET
// export function hHackSpawnHuman ( nation , class , skill ) ; begin
95472: LD_INT 0
95474: PPUSH
// uc_side := your_side ;
95475: LD_ADDR_OWVAR 20
95479: PUSH
95480: LD_OWVAR 2
95484: ST_TO_ADDR
// uc_nation := nation ;
95485: LD_ADDR_OWVAR 21
95489: PUSH
95490: LD_VAR 0 1
95494: ST_TO_ADDR
// InitHc ;
95495: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
95499: LD_INT 0
95501: PPUSH
95502: LD_VAR 0 2
95506: PPUSH
95507: LD_VAR 0 3
95511: PPUSH
95512: CALL_OW 380
// PlaceUnitAnywhere ( CreateHuman , true ) ;
95516: CALL_OW 44
95520: PPUSH
95521: LD_INT 1
95523: PPUSH
95524: CALL_OW 51
// end ;
95528: LD_VAR 0 4
95532: RET
// export function hHackSpawnVehicle ; begin
95533: LD_INT 0
95535: PPUSH
// uc_side := your_side ;
95536: LD_ADDR_OWVAR 20
95540: PUSH
95541: LD_OWVAR 2
95545: ST_TO_ADDR
// uc_nation := rand ( 1 , 3 ) ;
95546: LD_ADDR_OWVAR 21
95550: PUSH
95551: LD_INT 1
95553: PPUSH
95554: LD_INT 3
95556: PPUSH
95557: CALL_OW 12
95561: ST_TO_ADDR
// InitVc ;
95562: CALL_OW 20
// case uc_nation of 1 :
95566: LD_OWVAR 21
95570: PUSH
95571: LD_INT 1
95573: DOUBLE
95574: EQUAL
95575: IFTRUE 95579
95577: GO 95723
95579: POP
// begin vc_chassis := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] [ rand ( 1 , 5 ) ] ;
95580: LD_ADDR_OWVAR 37
95584: PUSH
95585: LD_INT 1
95587: PUSH
95588: LD_INT 2
95590: PUSH
95591: LD_INT 3
95593: PUSH
95594: LD_INT 4
95596: PUSH
95597: LD_INT 5
95599: PUSH
95600: EMPTY
95601: LIST
95602: LIST
95603: LIST
95604: LIST
95605: LIST
95606: PUSH
95607: LD_INT 1
95609: PPUSH
95610: LD_INT 5
95612: PPUSH
95613: CALL_OW 12
95617: ARRAY
95618: ST_TO_ADDR
// vc_engine := rand ( 1 , 3 ) ;
95619: LD_ADDR_OWVAR 39
95623: PUSH
95624: LD_INT 1
95626: PPUSH
95627: LD_INT 3
95629: PPUSH
95630: CALL_OW 12
95634: ST_TO_ADDR
// vc_control := [ control_manual , control_remote , control_computer ] [ rand ( 1 , 3 ) ] ;
95635: LD_ADDR_OWVAR 38
95639: PUSH
95640: LD_INT 1
95642: PUSH
95643: LD_INT 2
95645: PUSH
95646: LD_INT 3
95648: PUSH
95649: EMPTY
95650: LIST
95651: LIST
95652: LIST
95653: PUSH
95654: LD_INT 1
95656: PPUSH
95657: LD_INT 3
95659: PPUSH
95660: CALL_OW 12
95664: ARRAY
95665: ST_TO_ADDR
// vc_weapon := [ us_machine_gun , us_gatling_gun , us_double_gun , us_light_gun , us_rocket_launcher , us_siberium_rocket , us_laser , us_double_laser , us_heavy_gun ] [ rand ( 1 , 9 ) ] ;
95666: LD_ADDR_OWVAR 40
95670: PUSH
95671: LD_INT 2
95673: PUSH
95674: LD_INT 4
95676: PUSH
95677: LD_INT 5
95679: PUSH
95680: LD_INT 3
95682: PUSH
95683: LD_INT 7
95685: PUSH
95686: LD_INT 8
95688: PUSH
95689: LD_INT 9
95691: PUSH
95692: LD_INT 10
95694: PUSH
95695: LD_INT 6
95697: PUSH
95698: EMPTY
95699: LIST
95700: LIST
95701: LIST
95702: LIST
95703: LIST
95704: LIST
95705: LIST
95706: LIST
95707: LIST
95708: PUSH
95709: LD_INT 1
95711: PPUSH
95712: LD_INT 9
95714: PPUSH
95715: CALL_OW 12
95719: ARRAY
95720: ST_TO_ADDR
// end ; 2 :
95721: GO 95988
95723: LD_INT 2
95725: DOUBLE
95726: EQUAL
95727: IFTRUE 95731
95729: GO 95855
95731: POP
// begin vc_chassis := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 4 ) ] ;
95732: LD_ADDR_OWVAR 37
95736: PUSH
95737: LD_INT 11
95739: PUSH
95740: LD_INT 12
95742: PUSH
95743: LD_INT 13
95745: PUSH
95746: LD_INT 14
95748: PUSH
95749: EMPTY
95750: LIST
95751: LIST
95752: LIST
95753: LIST
95754: PUSH
95755: LD_INT 1
95757: PPUSH
95758: LD_INT 4
95760: PPUSH
95761: CALL_OW 12
95765: ARRAY
95766: ST_TO_ADDR
// vc_engine := rand ( 1 , 3 ) ;
95767: LD_ADDR_OWVAR 39
95771: PUSH
95772: LD_INT 1
95774: PPUSH
95775: LD_INT 3
95777: PPUSH
95778: CALL_OW 12
95782: ST_TO_ADDR
// vc_control := [ control_manual , control_remote , control_apeman ] [ rand ( 1 , 3 ) ] ;
95783: LD_ADDR_OWVAR 38
95787: PUSH
95788: LD_INT 1
95790: PUSH
95791: LD_INT 2
95793: PUSH
95794: LD_INT 5
95796: PUSH
95797: EMPTY
95798: LIST
95799: LIST
95800: LIST
95801: PUSH
95802: LD_INT 1
95804: PPUSH
95805: LD_INT 3
95807: PPUSH
95808: CALL_OW 12
95812: ARRAY
95813: ST_TO_ADDR
// vc_weapon := [ ar_double_machine_gun , ar_flame_thrower , ar_gun , ar_rocket_launcher , ar_selfpropelled_bomb ] [ rand ( 1 , 5 ) ] ;
95814: LD_ADDR_OWVAR 40
95818: PUSH
95819: LD_INT 24
95821: PUSH
95822: LD_INT 26
95824: PUSH
95825: LD_INT 27
95827: PUSH
95828: LD_INT 28
95830: PUSH
95831: LD_INT 29
95833: PUSH
95834: EMPTY
95835: LIST
95836: LIST
95837: LIST
95838: LIST
95839: LIST
95840: PUSH
95841: LD_INT 1
95843: PPUSH
95844: LD_INT 5
95846: PPUSH
95847: CALL_OW 12
95851: ARRAY
95852: ST_TO_ADDR
// end ; 3 :
95853: GO 95988
95855: LD_INT 3
95857: DOUBLE
95858: EQUAL
95859: IFTRUE 95863
95861: GO 95987
95863: POP
// begin vc_chassis := [ ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] [ rand ( 1 , 4 ) ] ;
95864: LD_ADDR_OWVAR 37
95868: PUSH
95869: LD_INT 21
95871: PUSH
95872: LD_INT 23
95874: PUSH
95875: LD_INT 22
95877: PUSH
95878: LD_INT 24
95880: PUSH
95881: EMPTY
95882: LIST
95883: LIST
95884: LIST
95885: LIST
95886: PUSH
95887: LD_INT 1
95889: PPUSH
95890: LD_INT 4
95892: PPUSH
95893: CALL_OW 12
95897: ARRAY
95898: ST_TO_ADDR
// vc_engine := rand ( 1 , 3 ) ;
95899: LD_ADDR_OWVAR 39
95903: PUSH
95904: LD_INT 1
95906: PPUSH
95907: LD_INT 3
95909: PPUSH
95910: CALL_OW 12
95914: ST_TO_ADDR
// vc_control := [ control_manual , control_computer ] [ rand ( 1 , 2 ) ] ;
95915: LD_ADDR_OWVAR 38
95919: PUSH
95920: LD_INT 1
95922: PUSH
95923: LD_INT 3
95925: PUSH
95926: EMPTY
95927: LIST
95928: LIST
95929: PUSH
95930: LD_INT 1
95932: PPUSH
95933: LD_INT 2
95935: PPUSH
95936: CALL_OW 12
95940: ARRAY
95941: ST_TO_ADDR
// vc_weapon := [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun , ru_heavy_gun , ru_siberium_rocket , ru_rocket ] [ rand ( 1 , 6 ) ] ;
95942: LD_ADDR_OWVAR 40
95946: PUSH
95947: LD_INT 42
95949: PUSH
95950: LD_INT 43
95952: PUSH
95953: LD_INT 44
95955: PUSH
95956: LD_INT 46
95958: PUSH
95959: LD_INT 48
95961: PUSH
95962: LD_INT 47
95964: PUSH
95965: EMPTY
95966: LIST
95967: LIST
95968: LIST
95969: LIST
95970: LIST
95971: LIST
95972: PUSH
95973: LD_INT 1
95975: PPUSH
95976: LD_INT 6
95978: PPUSH
95979: CALL_OW 12
95983: ARRAY
95984: ST_TO_ADDR
// end ; end ;
95985: GO 95988
95987: POP
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
95988: CALL_OW 45
95992: PPUSH
95993: LD_INT 1
95995: PPUSH
95996: CALL_OW 51
// end ;
96000: LD_VAR 0 1
96004: RET
// export hInvincible ; every 1 do
96005: GO 96007
96007: DISABLE
// hInvincible := [ ] ;
96008: LD_ADDR_EXP 162
96012: PUSH
96013: EMPTY
96014: ST_TO_ADDR
96015: END
// every 10 do var i ;
96016: GO 96018
96018: DISABLE
96019: LD_INT 0
96021: PPUSH
// begin enable ;
96022: ENABLE
// if not hInvincible then
96023: LD_EXP 162
96027: NOT
96028: IFFALSE 96032
// exit ;
96030: GO 96076
// for i in hInvincible do
96032: LD_ADDR_VAR 0 1
96036: PUSH
96037: LD_EXP 162
96041: PUSH
96042: FOR_IN
96043: IFFALSE 96074
// if GetLives ( i ) < 1000 then
96045: LD_VAR 0 1
96049: PPUSH
96050: CALL_OW 256
96054: PUSH
96055: LD_INT 1000
96057: LESS
96058: IFFALSE 96072
// SetLives ( i , 1000 ) ;
96060: LD_VAR 0 1
96064: PPUSH
96065: LD_INT 1000
96067: PPUSH
96068: CALL_OW 234
96072: GO 96042
96074: POP
96075: POP
// end ;
96076: PPOPN 1
96078: END
// export function hHackInvincible ; var i ; begin
96079: LD_INT 0
96081: PPUSH
96082: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
96083: LD_ADDR_VAR 0 2
96087: PUSH
96088: LD_INT 2
96090: PUSH
96091: LD_INT 21
96093: PUSH
96094: LD_INT 1
96096: PUSH
96097: EMPTY
96098: LIST
96099: LIST
96100: PUSH
96101: LD_INT 21
96103: PUSH
96104: LD_INT 2
96106: PUSH
96107: EMPTY
96108: LIST
96109: LIST
96110: PUSH
96111: EMPTY
96112: LIST
96113: LIST
96114: LIST
96115: PPUSH
96116: CALL_OW 69
96120: PUSH
96121: FOR_IN
96122: IFFALSE 96183
// if IsSelected ( i ) then
96124: LD_VAR 0 2
96128: PPUSH
96129: CALL_OW 306
96133: IFFALSE 96181
// begin if i in hInvincible then
96135: LD_VAR 0 2
96139: PUSH
96140: LD_EXP 162
96144: IN
96145: IFFALSE 96165
// hInvincible := hInvincible diff i else
96147: LD_ADDR_EXP 162
96151: PUSH
96152: LD_EXP 162
96156: PUSH
96157: LD_VAR 0 2
96161: DIFF
96162: ST_TO_ADDR
96163: GO 96181
// hInvincible := hInvincible union i ;
96165: LD_ADDR_EXP 162
96169: PUSH
96170: LD_EXP 162
96174: PUSH
96175: LD_VAR 0 2
96179: UNION
96180: ST_TO_ADDR
// end ;
96181: GO 96121
96183: POP
96184: POP
// end ;
96185: LD_VAR 0 1
96189: RET
// export function hHackInvisible ; var i , j ; begin
96190: LD_INT 0
96192: PPUSH
96193: PPUSH
96194: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
96195: LD_ADDR_VAR 0 2
96199: PUSH
96200: LD_INT 21
96202: PUSH
96203: LD_INT 1
96205: PUSH
96206: EMPTY
96207: LIST
96208: LIST
96209: PPUSH
96210: CALL_OW 69
96214: PUSH
96215: FOR_IN
96216: IFFALSE 96240
// if IsSelected ( i ) then
96218: LD_VAR 0 2
96222: PPUSH
96223: CALL_OW 306
96227: IFFALSE 96238
// ComForceInvisible ( i ) ;
96229: LD_VAR 0 2
96233: PPUSH
96234: CALL_OW 496
96238: GO 96215
96240: POP
96241: POP
// end ;
96242: LD_VAR 0 1
96246: RET
// export function hHackChangeYourSide ; begin
96247: LD_INT 0
96249: PPUSH
// if your_side = 8 then
96250: LD_OWVAR 2
96254: PUSH
96255: LD_INT 8
96257: EQUAL
96258: IFFALSE 96270
// your_side := 0 else
96260: LD_ADDR_OWVAR 2
96264: PUSH
96265: LD_INT 0
96267: ST_TO_ADDR
96268: GO 96284
// your_side := your_side + 1 ;
96270: LD_ADDR_OWVAR 2
96274: PUSH
96275: LD_OWVAR 2
96279: PUSH
96280: LD_INT 1
96282: PLUS
96283: ST_TO_ADDR
// end ;
96284: LD_VAR 0 1
96288: RET
// export function hHackChangeUnitSide ; var i , j ; begin
96289: LD_INT 0
96291: PPUSH
96292: PPUSH
96293: PPUSH
// for i in all_units do
96294: LD_ADDR_VAR 0 2
96298: PUSH
96299: LD_OWVAR 3
96303: PUSH
96304: FOR_IN
96305: IFFALSE 96383
// if IsSelected ( i ) then
96307: LD_VAR 0 2
96311: PPUSH
96312: CALL_OW 306
96316: IFFALSE 96381
// begin j := GetSide ( i ) ;
96318: LD_ADDR_VAR 0 3
96322: PUSH
96323: LD_VAR 0 2
96327: PPUSH
96328: CALL_OW 255
96332: ST_TO_ADDR
// if j = 8 then
96333: LD_VAR 0 3
96337: PUSH
96338: LD_INT 8
96340: EQUAL
96341: IFFALSE 96353
// j := 0 else
96343: LD_ADDR_VAR 0 3
96347: PUSH
96348: LD_INT 0
96350: ST_TO_ADDR
96351: GO 96367
// j := j + 1 ;
96353: LD_ADDR_VAR 0 3
96357: PUSH
96358: LD_VAR 0 3
96362: PUSH
96363: LD_INT 1
96365: PLUS
96366: ST_TO_ADDR
// SetSide ( i , j ) ;
96367: LD_VAR 0 2
96371: PPUSH
96372: LD_VAR 0 3
96376: PPUSH
96377: CALL_OW 235
// end ;
96381: GO 96304
96383: POP
96384: POP
// end ;
96385: LD_VAR 0 1
96389: RET
// export function hHackFog ; begin
96390: LD_INT 0
96392: PPUSH
// FogOff ( true ) ;
96393: LD_INT 1
96395: PPUSH
96396: CALL_OW 344
// end ;
96400: LD_VAR 0 1
96404: RET
// export function hHackApeman ; begin
96405: LD_INT 0
96407: PPUSH
// uc_side := your_side ;
96408: LD_ADDR_OWVAR 20
96412: PUSH
96413: LD_OWVAR 2
96417: ST_TO_ADDR
// uc_nation := 0 ;
96418: LD_ADDR_OWVAR 21
96422: PUSH
96423: LD_INT 0
96425: ST_TO_ADDR
// hc_name :=  ;
96426: LD_ADDR_OWVAR 26
96430: PUSH
96431: LD_STRING 
96433: ST_TO_ADDR
// hc_gallery :=  ;
96434: LD_ADDR_OWVAR 33
96438: PUSH
96439: LD_STRING 
96441: ST_TO_ADDR
// hc_skills := [ 0 , 0 , 0 , 0 ] ;
96442: LD_ADDR_OWVAR 31
96446: PUSH
96447: LD_INT 0
96449: PUSH
96450: LD_INT 0
96452: PUSH
96453: LD_INT 0
96455: PUSH
96456: LD_INT 0
96458: PUSH
96459: EMPTY
96460: LIST
96461: LIST
96462: LIST
96463: LIST
96464: ST_TO_ADDR
// hc_class := class_apeman ;
96465: LD_ADDR_OWVAR 28
96469: PUSH
96470: LD_INT 12
96472: ST_TO_ADDR
// PlaceUnitAnywhere ( CreateHuman , true ) ;
96473: CALL_OW 44
96477: PPUSH
96478: LD_INT 1
96480: PPUSH
96481: CALL_OW 51
// end ;
96485: LD_VAR 0 1
96489: RET
// export function hHackBoom ; begin
96490: LD_INT 0
96492: PPUSH
// uc_side := your_side ;
96493: LD_ADDR_OWVAR 20
96497: PUSH
96498: LD_OWVAR 2
96502: ST_TO_ADDR
// uc_nation := 1 ;
96503: LD_ADDR_OWVAR 21
96507: PUSH
96508: LD_INT 1
96510: ST_TO_ADDR
// vc_chassis := us_morphling ;
96511: LD_ADDR_OWVAR 37
96515: PUSH
96516: LD_INT 5
96518: ST_TO_ADDR
// vc_engine := engine_siberite ;
96519: LD_ADDR_OWVAR 39
96523: PUSH
96524: LD_INT 3
96526: ST_TO_ADDR
// vc_control := control_computer ;
96527: LD_ADDR_OWVAR 38
96531: PUSH
96532: LD_INT 3
96534: ST_TO_ADDR
// vc_weapon := us_siberium_rocket ;
96535: LD_ADDR_OWVAR 40
96539: PUSH
96540: LD_INT 8
96542: ST_TO_ADDR
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
96543: CALL_OW 45
96547: PPUSH
96548: LD_INT 1
96550: PPUSH
96551: CALL_OW 51
// end ; end_of_file
96555: LD_VAR 0 1
96559: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
96560: LD_INT 0
96562: PPUSH
96563: PPUSH
96564: PPUSH
96565: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
96566: LD_VAR 0 1
96570: PPUSH
96571: CALL_OW 264
96575: PUSH
96576: LD_EXP 97
96580: EQUAL
96581: IFFALSE 96653
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
96583: LD_INT 68
96585: PPUSH
96586: LD_VAR 0 1
96590: PPUSH
96591: CALL_OW 255
96595: PPUSH
96596: CALL_OW 321
96600: PUSH
96601: LD_INT 2
96603: EQUAL
96604: IFFALSE 96616
// eff := 70 else
96606: LD_ADDR_VAR 0 4
96610: PUSH
96611: LD_INT 70
96613: ST_TO_ADDR
96614: GO 96624
// eff := 30 ;
96616: LD_ADDR_VAR 0 4
96620: PUSH
96621: LD_INT 30
96623: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
96624: LD_VAR 0 1
96628: PPUSH
96629: CALL_OW 250
96633: PPUSH
96634: LD_VAR 0 1
96638: PPUSH
96639: CALL_OW 251
96643: PPUSH
96644: LD_VAR 0 4
96648: PPUSH
96649: CALL_OW 495
// end ; end ;
96653: LD_VAR 0 2
96657: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
96658: LD_INT 0
96660: PPUSH
// end ;
96661: LD_VAR 0 4
96665: RET
// export function SOS_Command ( cmd ) ; begin
96666: LD_INT 0
96668: PPUSH
// end ;
96669: LD_VAR 0 2
96673: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y ) do begin if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
96674: LD_VAR 0 1
96678: PUSH
96679: LD_INT 254
96681: EQUAL
96682: PUSH
96683: LD_VAR 0 2
96687: PPUSH
96688: CALL_OW 264
96692: PUSH
96693: LD_EXP 95
96697: EQUAL
96698: AND
96699: PUSH
96700: LD_VAR 0 3
96704: PPUSH
96705: CALL_OW 263
96709: PUSH
96710: LD_INT 3
96712: EQUAL
96713: AND
96714: IFFALSE 96730
// HackDestroyVehicle ( unit , selectedUnit ) ;
96716: LD_VAR 0 2
96720: PPUSH
96721: LD_VAR 0 3
96725: PPUSH
96726: CALL 98237 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
96730: LD_VAR 0 1
96734: PUSH
96735: LD_INT 255
96737: EQUAL
96738: PUSH
96739: LD_VAR 0 2
96743: PPUSH
96744: CALL_OW 264
96748: PUSH
96749: LD_INT 14
96751: PUSH
96752: LD_INT 53
96754: PUSH
96755: EMPTY
96756: LIST
96757: LIST
96758: IN
96759: AND
96760: PUSH
96761: LD_VAR 0 4
96765: PPUSH
96766: LD_VAR 0 5
96770: PPUSH
96771: CALL_OW 488
96775: AND
96776: IFFALSE 96800
// CutTreeXYR ( unit , x , y , 12 ) ;
96778: LD_VAR 0 2
96782: PPUSH
96783: LD_VAR 0 4
96787: PPUSH
96788: LD_VAR 0 5
96792: PPUSH
96793: LD_INT 12
96795: PPUSH
96796: CALL 96803 0 4
// end ;
96800: PPOPN 5
96802: END
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
96803: LD_INT 0
96805: PPUSH
96806: PPUSH
96807: PPUSH
96808: PPUSH
96809: PPUSH
96810: PPUSH
96811: PPUSH
96812: PPUSH
96813: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
96814: LD_VAR 0 1
96818: NOT
96819: PUSH
96820: LD_VAR 0 2
96824: PPUSH
96825: LD_VAR 0 3
96829: PPUSH
96830: CALL_OW 488
96834: NOT
96835: OR
96836: PUSH
96837: LD_VAR 0 4
96841: NOT
96842: OR
96843: IFFALSE 96847
// exit ;
96845: GO 97187
// list := [ ] ;
96847: LD_ADDR_VAR 0 13
96851: PUSH
96852: EMPTY
96853: ST_TO_ADDR
// if x - r < 0 then
96854: LD_VAR 0 2
96858: PUSH
96859: LD_VAR 0 4
96863: MINUS
96864: PUSH
96865: LD_INT 0
96867: LESS
96868: IFFALSE 96880
// min_x := 0 else
96870: LD_ADDR_VAR 0 7
96874: PUSH
96875: LD_INT 0
96877: ST_TO_ADDR
96878: GO 96896
// min_x := x - r ;
96880: LD_ADDR_VAR 0 7
96884: PUSH
96885: LD_VAR 0 2
96889: PUSH
96890: LD_VAR 0 4
96894: MINUS
96895: ST_TO_ADDR
// if y - r < 0 then
96896: LD_VAR 0 3
96900: PUSH
96901: LD_VAR 0 4
96905: MINUS
96906: PUSH
96907: LD_INT 0
96909: LESS
96910: IFFALSE 96922
// min_y := 0 else
96912: LD_ADDR_VAR 0 8
96916: PUSH
96917: LD_INT 0
96919: ST_TO_ADDR
96920: GO 96938
// min_y := y - r ;
96922: LD_ADDR_VAR 0 8
96926: PUSH
96927: LD_VAR 0 3
96931: PUSH
96932: LD_VAR 0 4
96936: MINUS
96937: ST_TO_ADDR
// max_x := x + r ;
96938: LD_ADDR_VAR 0 9
96942: PUSH
96943: LD_VAR 0 2
96947: PUSH
96948: LD_VAR 0 4
96952: PLUS
96953: ST_TO_ADDR
// max_y := y + r ;
96954: LD_ADDR_VAR 0 10
96958: PUSH
96959: LD_VAR 0 3
96963: PUSH
96964: LD_VAR 0 4
96968: PLUS
96969: ST_TO_ADDR
// for _x = min_x to max_x do
96970: LD_ADDR_VAR 0 11
96974: PUSH
96975: DOUBLE
96976: LD_VAR 0 7
96980: DEC
96981: ST_TO_ADDR
96982: LD_VAR 0 9
96986: PUSH
96987: FOR_TO
96988: IFFALSE 97105
// for _y = min_y to max_y do
96990: LD_ADDR_VAR 0 12
96994: PUSH
96995: DOUBLE
96996: LD_VAR 0 8
97000: DEC
97001: ST_TO_ADDR
97002: LD_VAR 0 10
97006: PUSH
97007: FOR_TO
97008: IFFALSE 97101
// begin if not ValidHex ( _x , _y ) then
97010: LD_VAR 0 11
97014: PPUSH
97015: LD_VAR 0 12
97019: PPUSH
97020: CALL_OW 488
97024: NOT
97025: IFFALSE 97029
// continue ;
97027: GO 97007
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
97029: LD_VAR 0 11
97033: PPUSH
97034: LD_VAR 0 12
97038: PPUSH
97039: CALL_OW 351
97043: PUSH
97044: LD_VAR 0 11
97048: PPUSH
97049: LD_VAR 0 12
97053: PPUSH
97054: CALL_OW 554
97058: AND
97059: IFFALSE 97099
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
97061: LD_ADDR_VAR 0 13
97065: PUSH
97066: LD_VAR 0 13
97070: PPUSH
97071: LD_VAR 0 13
97075: PUSH
97076: LD_INT 1
97078: PLUS
97079: PPUSH
97080: LD_VAR 0 11
97084: PUSH
97085: LD_VAR 0 12
97089: PUSH
97090: EMPTY
97091: LIST
97092: LIST
97093: PPUSH
97094: CALL_OW 2
97098: ST_TO_ADDR
// end ;
97099: GO 97007
97101: POP
97102: POP
97103: GO 96987
97105: POP
97106: POP
// if not list then
97107: LD_VAR 0 13
97111: NOT
97112: IFFALSE 97116
// exit ;
97114: GO 97187
// for i in list do
97116: LD_ADDR_VAR 0 6
97120: PUSH
97121: LD_VAR 0 13
97125: PUSH
97126: FOR_IN
97127: IFFALSE 97185
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
97129: LD_VAR 0 1
97133: PPUSH
97134: LD_STRING M
97136: PUSH
97137: LD_VAR 0 6
97141: PUSH
97142: LD_INT 1
97144: ARRAY
97145: PUSH
97146: LD_VAR 0 6
97150: PUSH
97151: LD_INT 2
97153: ARRAY
97154: PUSH
97155: LD_INT 0
97157: PUSH
97158: LD_INT 0
97160: PUSH
97161: LD_INT 0
97163: PUSH
97164: LD_INT 0
97166: PUSH
97167: EMPTY
97168: LIST
97169: LIST
97170: LIST
97171: LIST
97172: LIST
97173: LIST
97174: LIST
97175: PUSH
97176: EMPTY
97177: LIST
97178: PPUSH
97179: CALL_OW 447
97183: GO 97126
97185: POP
97186: POP
// end ;
97187: LD_VAR 0 5
97191: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
97192: LD_EXP 163
97196: NOT
97197: IFFALSE 97247
97199: GO 97201
97201: DISABLE
// begin initHack := true ;
97202: LD_ADDR_EXP 163
97206: PUSH
97207: LD_INT 1
97209: ST_TO_ADDR
// hackTanks := [ ] ;
97210: LD_ADDR_EXP 164
97214: PUSH
97215: EMPTY
97216: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
97217: LD_ADDR_EXP 165
97221: PUSH
97222: EMPTY
97223: ST_TO_ADDR
// hackLimit := 3 ;
97224: LD_ADDR_EXP 166
97228: PUSH
97229: LD_INT 3
97231: ST_TO_ADDR
// hackDist := 12 ;
97232: LD_ADDR_EXP 167
97236: PUSH
97237: LD_INT 12
97239: ST_TO_ADDR
// hackCounter := [ ] ;
97240: LD_ADDR_EXP 168
97244: PUSH
97245: EMPTY
97246: ST_TO_ADDR
// end ;
97247: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
97248: LD_EXP 163
97252: PUSH
97253: LD_INT 34
97255: PUSH
97256: LD_EXP 95
97260: PUSH
97261: EMPTY
97262: LIST
97263: LIST
97264: PPUSH
97265: CALL_OW 69
97269: AND
97270: IFFALSE 97525
97272: GO 97274
97274: DISABLE
97275: LD_INT 0
97277: PPUSH
97278: PPUSH
// begin enable ;
97279: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
97280: LD_ADDR_VAR 0 1
97284: PUSH
97285: LD_INT 34
97287: PUSH
97288: LD_EXP 95
97292: PUSH
97293: EMPTY
97294: LIST
97295: LIST
97296: PPUSH
97297: CALL_OW 69
97301: PUSH
97302: FOR_IN
97303: IFFALSE 97523
// begin if not i in hackTanks then
97305: LD_VAR 0 1
97309: PUSH
97310: LD_EXP 164
97314: IN
97315: NOT
97316: IFFALSE 97399
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
97318: LD_ADDR_EXP 164
97322: PUSH
97323: LD_EXP 164
97327: PPUSH
97328: LD_EXP 164
97332: PUSH
97333: LD_INT 1
97335: PLUS
97336: PPUSH
97337: LD_VAR 0 1
97341: PPUSH
97342: CALL_OW 1
97346: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
97347: LD_ADDR_EXP 165
97351: PUSH
97352: LD_EXP 165
97356: PPUSH
97357: LD_EXP 165
97361: PUSH
97362: LD_INT 1
97364: PLUS
97365: PPUSH
97366: EMPTY
97367: PPUSH
97368: CALL_OW 1
97372: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
97373: LD_ADDR_EXP 168
97377: PUSH
97378: LD_EXP 168
97382: PPUSH
97383: LD_EXP 168
97387: PUSH
97388: LD_INT 1
97390: PLUS
97391: PPUSH
97392: EMPTY
97393: PPUSH
97394: CALL_OW 1
97398: ST_TO_ADDR
// end ; if not IsOk ( i ) then
97399: LD_VAR 0 1
97403: PPUSH
97404: CALL_OW 302
97408: NOT
97409: IFFALSE 97422
// begin HackUnlinkAll ( i ) ;
97411: LD_VAR 0 1
97415: PPUSH
97416: CALL 97528 0 1
// continue ;
97420: GO 97302
// end ; HackCheckCapturedStatus ( i ) ;
97422: LD_VAR 0 1
97426: PPUSH
97427: CALL 97971 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
97431: LD_ADDR_VAR 0 2
97435: PUSH
97436: LD_INT 81
97438: PUSH
97439: LD_VAR 0 1
97443: PPUSH
97444: CALL_OW 255
97448: PUSH
97449: EMPTY
97450: LIST
97451: LIST
97452: PUSH
97453: LD_INT 33
97455: PUSH
97456: LD_INT 3
97458: PUSH
97459: EMPTY
97460: LIST
97461: LIST
97462: PUSH
97463: LD_INT 91
97465: PUSH
97466: LD_VAR 0 1
97470: PUSH
97471: LD_EXP 167
97475: PUSH
97476: EMPTY
97477: LIST
97478: LIST
97479: LIST
97480: PUSH
97481: LD_INT 50
97483: PUSH
97484: EMPTY
97485: LIST
97486: PUSH
97487: EMPTY
97488: LIST
97489: LIST
97490: LIST
97491: LIST
97492: PPUSH
97493: CALL_OW 69
97497: ST_TO_ADDR
// if not tmp then
97498: LD_VAR 0 2
97502: NOT
97503: IFFALSE 97507
// continue ;
97505: GO 97302
// HackLink ( i , tmp ) ;
97507: LD_VAR 0 1
97511: PPUSH
97512: LD_VAR 0 2
97516: PPUSH
97517: CALL 97664 0 2
// end ;
97521: GO 97302
97523: POP
97524: POP
// end ;
97525: PPOPN 2
97527: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
97528: LD_INT 0
97530: PPUSH
97531: PPUSH
97532: PPUSH
// if not hack in hackTanks then
97533: LD_VAR 0 1
97537: PUSH
97538: LD_EXP 164
97542: IN
97543: NOT
97544: IFFALSE 97548
// exit ;
97546: GO 97659
// index := GetElementIndex ( hackTanks , hack ) ;
97548: LD_ADDR_VAR 0 4
97552: PUSH
97553: LD_EXP 164
97557: PPUSH
97558: LD_VAR 0 1
97562: PPUSH
97563: CALL 52136 0 2
97567: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
97568: LD_EXP 165
97572: PUSH
97573: LD_VAR 0 4
97577: ARRAY
97578: IFFALSE 97659
// begin for i in hackTanksCaptured [ index ] do
97580: LD_ADDR_VAR 0 3
97584: PUSH
97585: LD_EXP 165
97589: PUSH
97590: LD_VAR 0 4
97594: ARRAY
97595: PUSH
97596: FOR_IN
97597: IFFALSE 97623
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
97599: LD_VAR 0 3
97603: PUSH
97604: LD_INT 1
97606: ARRAY
97607: PPUSH
97608: LD_VAR 0 3
97612: PUSH
97613: LD_INT 2
97615: ARRAY
97616: PPUSH
97617: CALL_OW 235
97621: GO 97596
97623: POP
97624: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
97625: LD_ADDR_EXP 165
97629: PUSH
97630: LD_EXP 165
97634: PPUSH
97635: LD_VAR 0 4
97639: PPUSH
97640: EMPTY
97641: PPUSH
97642: CALL_OW 1
97646: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
97647: LD_VAR 0 1
97651: PPUSH
97652: LD_INT 0
97654: PPUSH
97655: CALL_OW 505
// end ; end ;
97659: LD_VAR 0 2
97663: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
97664: LD_INT 0
97666: PPUSH
97667: PPUSH
97668: PPUSH
// if not hack in hackTanks or not vehicles then
97669: LD_VAR 0 1
97673: PUSH
97674: LD_EXP 164
97678: IN
97679: NOT
97680: PUSH
97681: LD_VAR 0 2
97685: NOT
97686: OR
97687: IFFALSE 97691
// exit ;
97689: GO 97966
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
97691: LD_ADDR_VAR 0 2
97695: PUSH
97696: LD_VAR 0 1
97700: PPUSH
97701: LD_VAR 0 2
97705: PPUSH
97706: LD_INT 1
97708: PPUSH
97709: LD_INT 1
97711: PPUSH
97712: CALL 52786 0 4
97716: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
97717: LD_ADDR_VAR 0 5
97721: PUSH
97722: LD_EXP 164
97726: PPUSH
97727: LD_VAR 0 1
97731: PPUSH
97732: CALL 52136 0 2
97736: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
97737: LD_EXP 165
97741: PUSH
97742: LD_VAR 0 5
97746: ARRAY
97747: PUSH
97748: LD_EXP 166
97752: LESS
97753: IFFALSE 97942
// begin for i := 1 to vehicles do
97755: LD_ADDR_VAR 0 4
97759: PUSH
97760: DOUBLE
97761: LD_INT 1
97763: DEC
97764: ST_TO_ADDR
97765: LD_VAR 0 2
97769: PUSH
97770: FOR_TO
97771: IFFALSE 97940
// begin if hackTanksCaptured [ index ] = hackLimit then
97773: LD_EXP 165
97777: PUSH
97778: LD_VAR 0 5
97782: ARRAY
97783: PUSH
97784: LD_EXP 166
97788: EQUAL
97789: IFFALSE 97793
// break ;
97791: GO 97940
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
97793: LD_ADDR_EXP 168
97797: PUSH
97798: LD_EXP 168
97802: PPUSH
97803: LD_VAR 0 5
97807: PPUSH
97808: LD_EXP 168
97812: PUSH
97813: LD_VAR 0 5
97817: ARRAY
97818: PUSH
97819: LD_INT 1
97821: PLUS
97822: PPUSH
97823: CALL_OW 1
97827: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
97828: LD_ADDR_EXP 165
97832: PUSH
97833: LD_EXP 165
97837: PPUSH
97838: LD_VAR 0 5
97842: PUSH
97843: LD_EXP 165
97847: PUSH
97848: LD_VAR 0 5
97852: ARRAY
97853: PUSH
97854: LD_INT 1
97856: PLUS
97857: PUSH
97858: EMPTY
97859: LIST
97860: LIST
97861: PPUSH
97862: LD_VAR 0 2
97866: PUSH
97867: LD_VAR 0 4
97871: ARRAY
97872: PUSH
97873: LD_VAR 0 2
97877: PUSH
97878: LD_VAR 0 4
97882: ARRAY
97883: PPUSH
97884: CALL_OW 255
97888: PUSH
97889: EMPTY
97890: LIST
97891: LIST
97892: PPUSH
97893: CALL 52351 0 3
97897: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
97898: LD_VAR 0 2
97902: PUSH
97903: LD_VAR 0 4
97907: ARRAY
97908: PPUSH
97909: LD_VAR 0 1
97913: PPUSH
97914: CALL_OW 255
97918: PPUSH
97919: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
97923: LD_VAR 0 2
97927: PUSH
97928: LD_VAR 0 4
97932: ARRAY
97933: PPUSH
97934: CALL_OW 141
// end ;
97938: GO 97770
97940: POP
97941: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
97942: LD_VAR 0 1
97946: PPUSH
97947: LD_EXP 165
97951: PUSH
97952: LD_VAR 0 5
97956: ARRAY
97957: PUSH
97958: LD_INT 0
97960: PLUS
97961: PPUSH
97962: CALL_OW 505
// end ;
97966: LD_VAR 0 3
97970: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
97971: LD_INT 0
97973: PPUSH
97974: PPUSH
97975: PPUSH
97976: PPUSH
// if not hack in hackTanks then
97977: LD_VAR 0 1
97981: PUSH
97982: LD_EXP 164
97986: IN
97987: NOT
97988: IFFALSE 97992
// exit ;
97990: GO 98232
// index := GetElementIndex ( hackTanks , hack ) ;
97992: LD_ADDR_VAR 0 4
97996: PUSH
97997: LD_EXP 164
98001: PPUSH
98002: LD_VAR 0 1
98006: PPUSH
98007: CALL 52136 0 2
98011: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
98012: LD_ADDR_VAR 0 3
98016: PUSH
98017: DOUBLE
98018: LD_EXP 165
98022: PUSH
98023: LD_VAR 0 4
98027: ARRAY
98028: INC
98029: ST_TO_ADDR
98030: LD_INT 1
98032: PUSH
98033: FOR_DOWNTO
98034: IFFALSE 98206
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
98036: LD_ADDR_VAR 0 5
98040: PUSH
98041: LD_EXP 165
98045: PUSH
98046: LD_VAR 0 4
98050: ARRAY
98051: PUSH
98052: LD_VAR 0 3
98056: ARRAY
98057: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
98058: LD_VAR 0 5
98062: PUSH
98063: LD_INT 1
98065: ARRAY
98066: PPUSH
98067: CALL_OW 302
98071: NOT
98072: PUSH
98073: LD_VAR 0 5
98077: PUSH
98078: LD_INT 1
98080: ARRAY
98081: PPUSH
98082: CALL_OW 255
98086: PUSH
98087: LD_VAR 0 1
98091: PPUSH
98092: CALL_OW 255
98096: NONEQUAL
98097: OR
98098: IFFALSE 98204
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
98100: LD_VAR 0 5
98104: PUSH
98105: LD_INT 1
98107: ARRAY
98108: PPUSH
98109: CALL_OW 305
98113: PUSH
98114: LD_VAR 0 5
98118: PUSH
98119: LD_INT 1
98121: ARRAY
98122: PPUSH
98123: CALL_OW 255
98127: PUSH
98128: LD_VAR 0 1
98132: PPUSH
98133: CALL_OW 255
98137: EQUAL
98138: AND
98139: IFFALSE 98163
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
98141: LD_VAR 0 5
98145: PUSH
98146: LD_INT 1
98148: ARRAY
98149: PPUSH
98150: LD_VAR 0 5
98154: PUSH
98155: LD_INT 2
98157: ARRAY
98158: PPUSH
98159: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
98163: LD_ADDR_EXP 165
98167: PUSH
98168: LD_EXP 165
98172: PPUSH
98173: LD_VAR 0 4
98177: PPUSH
98178: LD_EXP 165
98182: PUSH
98183: LD_VAR 0 4
98187: ARRAY
98188: PPUSH
98189: LD_VAR 0 3
98193: PPUSH
98194: CALL_OW 3
98198: PPUSH
98199: CALL_OW 1
98203: ST_TO_ADDR
// end ; end ;
98204: GO 98033
98206: POP
98207: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
98208: LD_VAR 0 1
98212: PPUSH
98213: LD_EXP 165
98217: PUSH
98218: LD_VAR 0 4
98222: ARRAY
98223: PUSH
98224: LD_INT 0
98226: PLUS
98227: PPUSH
98228: CALL_OW 505
// end ;
98232: LD_VAR 0 2
98236: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
98237: LD_INT 0
98239: PPUSH
98240: PPUSH
98241: PPUSH
98242: PPUSH
// if not hack in hackTanks then
98243: LD_VAR 0 1
98247: PUSH
98248: LD_EXP 164
98252: IN
98253: NOT
98254: IFFALSE 98258
// exit ;
98256: GO 98343
// index := GetElementIndex ( hackTanks , hack ) ;
98258: LD_ADDR_VAR 0 5
98262: PUSH
98263: LD_EXP 164
98267: PPUSH
98268: LD_VAR 0 1
98272: PPUSH
98273: CALL 52136 0 2
98277: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
98278: LD_ADDR_VAR 0 4
98282: PUSH
98283: DOUBLE
98284: LD_INT 1
98286: DEC
98287: ST_TO_ADDR
98288: LD_EXP 165
98292: PUSH
98293: LD_VAR 0 5
98297: ARRAY
98298: PUSH
98299: FOR_TO
98300: IFFALSE 98341
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
98302: LD_EXP 165
98306: PUSH
98307: LD_VAR 0 5
98311: ARRAY
98312: PUSH
98313: LD_VAR 0 4
98317: ARRAY
98318: PUSH
98319: LD_INT 1
98321: ARRAY
98322: PUSH
98323: LD_VAR 0 2
98327: EQUAL
98328: IFFALSE 98339
// KillUnit ( vehicle ) ;
98330: LD_VAR 0 2
98334: PPUSH
98335: CALL_OW 66
98339: GO 98299
98341: POP
98342: POP
// end ; end_of_file
98343: LD_VAR 0 3
98347: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
98348: LD_INT 0
98350: PPUSH
98351: PPUSH
98352: PPUSH
98353: PPUSH
98354: PPUSH
98355: PPUSH
98356: PPUSH
98357: PPUSH
98358: PPUSH
98359: PPUSH
98360: PPUSH
98361: PPUSH
98362: PPUSH
98363: PPUSH
98364: PPUSH
98365: PPUSH
98366: PPUSH
98367: PPUSH
98368: PPUSH
98369: PPUSH
98370: PPUSH
98371: PPUSH
98372: PPUSH
98373: PPUSH
98374: PPUSH
98375: PPUSH
98376: PPUSH
98377: PPUSH
98378: PPUSH
98379: PPUSH
98380: PPUSH
98381: PPUSH
98382: PPUSH
98383: PPUSH
// if not list then
98384: LD_VAR 0 1
98388: NOT
98389: IFFALSE 98393
// exit ;
98391: GO 103052
// base := list [ 1 ] ;
98393: LD_ADDR_VAR 0 3
98397: PUSH
98398: LD_VAR 0 1
98402: PUSH
98403: LD_INT 1
98405: ARRAY
98406: ST_TO_ADDR
// group := list [ 2 ] ;
98407: LD_ADDR_VAR 0 4
98411: PUSH
98412: LD_VAR 0 1
98416: PUSH
98417: LD_INT 2
98419: ARRAY
98420: ST_TO_ADDR
// path := list [ 3 ] ;
98421: LD_ADDR_VAR 0 5
98425: PUSH
98426: LD_VAR 0 1
98430: PUSH
98431: LD_INT 3
98433: ARRAY
98434: ST_TO_ADDR
// flags := list [ 4 ] ;
98435: LD_ADDR_VAR 0 6
98439: PUSH
98440: LD_VAR 0 1
98444: PUSH
98445: LD_INT 4
98447: ARRAY
98448: ST_TO_ADDR
// mined := [ ] ;
98449: LD_ADDR_VAR 0 27
98453: PUSH
98454: EMPTY
98455: ST_TO_ADDR
// bombed := [ ] ;
98456: LD_ADDR_VAR 0 28
98460: PUSH
98461: EMPTY
98462: ST_TO_ADDR
// healers := [ ] ;
98463: LD_ADDR_VAR 0 31
98467: PUSH
98468: EMPTY
98469: ST_TO_ADDR
// to_heal := [ ] ;
98470: LD_ADDR_VAR 0 30
98474: PUSH
98475: EMPTY
98476: ST_TO_ADDR
// repairs := [ ] ;
98477: LD_ADDR_VAR 0 33
98481: PUSH
98482: EMPTY
98483: ST_TO_ADDR
// to_repair := [ ] ;
98484: LD_ADDR_VAR 0 32
98488: PUSH
98489: EMPTY
98490: ST_TO_ADDR
// if not group or not path then
98491: LD_VAR 0 4
98495: NOT
98496: PUSH
98497: LD_VAR 0 5
98501: NOT
98502: OR
98503: IFFALSE 98507
// exit ;
98505: GO 103052
// side := GetSide ( group [ 1 ] ) ;
98507: LD_ADDR_VAR 0 35
98511: PUSH
98512: LD_VAR 0 4
98516: PUSH
98517: LD_INT 1
98519: ARRAY
98520: PPUSH
98521: CALL_OW 255
98525: ST_TO_ADDR
// if flags then
98526: LD_VAR 0 6
98530: IFFALSE 98674
// begin f_ignore_area := flags [ 1 ] ;
98532: LD_ADDR_VAR 0 17
98536: PUSH
98537: LD_VAR 0 6
98541: PUSH
98542: LD_INT 1
98544: ARRAY
98545: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
98546: LD_ADDR_VAR 0 18
98550: PUSH
98551: LD_VAR 0 6
98555: PUSH
98556: LD_INT 2
98558: ARRAY
98559: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
98560: LD_ADDR_VAR 0 19
98564: PUSH
98565: LD_VAR 0 6
98569: PUSH
98570: LD_INT 3
98572: ARRAY
98573: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
98574: LD_ADDR_VAR 0 20
98578: PUSH
98579: LD_VAR 0 6
98583: PUSH
98584: LD_INT 4
98586: ARRAY
98587: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
98588: LD_ADDR_VAR 0 21
98592: PUSH
98593: LD_VAR 0 6
98597: PUSH
98598: LD_INT 5
98600: ARRAY
98601: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
98602: LD_ADDR_VAR 0 22
98606: PUSH
98607: LD_VAR 0 6
98611: PUSH
98612: LD_INT 6
98614: ARRAY
98615: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
98616: LD_ADDR_VAR 0 23
98620: PUSH
98621: LD_VAR 0 6
98625: PUSH
98626: LD_INT 7
98628: ARRAY
98629: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
98630: LD_ADDR_VAR 0 24
98634: PUSH
98635: LD_VAR 0 6
98639: PUSH
98640: LD_INT 8
98642: ARRAY
98643: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
98644: LD_ADDR_VAR 0 25
98648: PUSH
98649: LD_VAR 0 6
98653: PUSH
98654: LD_INT 9
98656: ARRAY
98657: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
98658: LD_ADDR_VAR 0 26
98662: PUSH
98663: LD_VAR 0 6
98667: PUSH
98668: LD_INT 10
98670: ARRAY
98671: ST_TO_ADDR
// end else
98672: GO 98754
// begin f_ignore_area := false ;
98674: LD_ADDR_VAR 0 17
98678: PUSH
98679: LD_INT 0
98681: ST_TO_ADDR
// f_capture := false ;
98682: LD_ADDR_VAR 0 18
98686: PUSH
98687: LD_INT 0
98689: ST_TO_ADDR
// f_ignore_civ := false ;
98690: LD_ADDR_VAR 0 19
98694: PUSH
98695: LD_INT 0
98697: ST_TO_ADDR
// f_murder := false ;
98698: LD_ADDR_VAR 0 20
98702: PUSH
98703: LD_INT 0
98705: ST_TO_ADDR
// f_mines := false ;
98706: LD_ADDR_VAR 0 21
98710: PUSH
98711: LD_INT 0
98713: ST_TO_ADDR
// f_repair := false ;
98714: LD_ADDR_VAR 0 22
98718: PUSH
98719: LD_INT 0
98721: ST_TO_ADDR
// f_heal := false ;
98722: LD_ADDR_VAR 0 23
98726: PUSH
98727: LD_INT 0
98729: ST_TO_ADDR
// f_spacetime := false ;
98730: LD_ADDR_VAR 0 24
98734: PUSH
98735: LD_INT 0
98737: ST_TO_ADDR
// f_attack_depot := false ;
98738: LD_ADDR_VAR 0 25
98742: PUSH
98743: LD_INT 0
98745: ST_TO_ADDR
// f_crawl := false ;
98746: LD_ADDR_VAR 0 26
98750: PUSH
98751: LD_INT 0
98753: ST_TO_ADDR
// end ; if f_heal then
98754: LD_VAR 0 23
98758: IFFALSE 98785
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
98760: LD_ADDR_VAR 0 31
98764: PUSH
98765: LD_VAR 0 4
98769: PPUSH
98770: LD_INT 25
98772: PUSH
98773: LD_INT 4
98775: PUSH
98776: EMPTY
98777: LIST
98778: LIST
98779: PPUSH
98780: CALL_OW 72
98784: ST_TO_ADDR
// if f_repair then
98785: LD_VAR 0 22
98789: IFFALSE 98816
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
98791: LD_ADDR_VAR 0 33
98795: PUSH
98796: LD_VAR 0 4
98800: PPUSH
98801: LD_INT 25
98803: PUSH
98804: LD_INT 3
98806: PUSH
98807: EMPTY
98808: LIST
98809: LIST
98810: PPUSH
98811: CALL_OW 72
98815: ST_TO_ADDR
// units_path := [ ] ;
98816: LD_ADDR_VAR 0 16
98820: PUSH
98821: EMPTY
98822: ST_TO_ADDR
// for i = 1 to group do
98823: LD_ADDR_VAR 0 7
98827: PUSH
98828: DOUBLE
98829: LD_INT 1
98831: DEC
98832: ST_TO_ADDR
98833: LD_VAR 0 4
98837: PUSH
98838: FOR_TO
98839: IFFALSE 98868
// units_path := Replace ( units_path , i , path ) ;
98841: LD_ADDR_VAR 0 16
98845: PUSH
98846: LD_VAR 0 16
98850: PPUSH
98851: LD_VAR 0 7
98855: PPUSH
98856: LD_VAR 0 5
98860: PPUSH
98861: CALL_OW 1
98865: ST_TO_ADDR
98866: GO 98838
98868: POP
98869: POP
// repeat for i = group downto 1 do
98870: LD_ADDR_VAR 0 7
98874: PUSH
98875: DOUBLE
98876: LD_VAR 0 4
98880: INC
98881: ST_TO_ADDR
98882: LD_INT 1
98884: PUSH
98885: FOR_DOWNTO
98886: IFFALSE 103008
// begin wait ( 5 ) ;
98888: LD_INT 5
98890: PPUSH
98891: CALL_OW 67
// tmp := [ ] ;
98895: LD_ADDR_VAR 0 14
98899: PUSH
98900: EMPTY
98901: ST_TO_ADDR
// attacking := false ;
98902: LD_ADDR_VAR 0 29
98906: PUSH
98907: LD_INT 0
98909: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
98910: LD_VAR 0 4
98914: PUSH
98915: LD_VAR 0 7
98919: ARRAY
98920: PPUSH
98921: CALL_OW 301
98925: PUSH
98926: LD_VAR 0 4
98930: PUSH
98931: LD_VAR 0 7
98935: ARRAY
98936: NOT
98937: OR
98938: IFFALSE 99047
// begin if GetType ( group [ i ] ) = unit_human then
98940: LD_VAR 0 4
98944: PUSH
98945: LD_VAR 0 7
98949: ARRAY
98950: PPUSH
98951: CALL_OW 247
98955: PUSH
98956: LD_INT 1
98958: EQUAL
98959: IFFALSE 99005
// begin to_heal := to_heal diff group [ i ] ;
98961: LD_ADDR_VAR 0 30
98965: PUSH
98966: LD_VAR 0 30
98970: PUSH
98971: LD_VAR 0 4
98975: PUSH
98976: LD_VAR 0 7
98980: ARRAY
98981: DIFF
98982: ST_TO_ADDR
// healers := healers diff group [ i ] ;
98983: LD_ADDR_VAR 0 31
98987: PUSH
98988: LD_VAR 0 31
98992: PUSH
98993: LD_VAR 0 4
98997: PUSH
98998: LD_VAR 0 7
99002: ARRAY
99003: DIFF
99004: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
99005: LD_ADDR_VAR 0 4
99009: PUSH
99010: LD_VAR 0 4
99014: PPUSH
99015: LD_VAR 0 7
99019: PPUSH
99020: CALL_OW 3
99024: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
99025: LD_ADDR_VAR 0 16
99029: PUSH
99030: LD_VAR 0 16
99034: PPUSH
99035: LD_VAR 0 7
99039: PPUSH
99040: CALL_OW 3
99044: ST_TO_ADDR
// continue ;
99045: GO 98885
// end ; if f_repair then
99047: LD_VAR 0 22
99051: IFFALSE 99540
// begin if GetType ( group [ i ] ) = unit_vehicle then
99053: LD_VAR 0 4
99057: PUSH
99058: LD_VAR 0 7
99062: ARRAY
99063: PPUSH
99064: CALL_OW 247
99068: PUSH
99069: LD_INT 2
99071: EQUAL
99072: IFFALSE 99262
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
99074: LD_VAR 0 4
99078: PUSH
99079: LD_VAR 0 7
99083: ARRAY
99084: PPUSH
99085: CALL_OW 256
99089: PUSH
99090: LD_INT 700
99092: LESS
99093: PUSH
99094: LD_VAR 0 4
99098: PUSH
99099: LD_VAR 0 7
99103: ARRAY
99104: PUSH
99105: LD_VAR 0 32
99109: IN
99110: NOT
99111: AND
99112: IFFALSE 99136
// to_repair := to_repair union group [ i ] ;
99114: LD_ADDR_VAR 0 32
99118: PUSH
99119: LD_VAR 0 32
99123: PUSH
99124: LD_VAR 0 4
99128: PUSH
99129: LD_VAR 0 7
99133: ARRAY
99134: UNION
99135: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
99136: LD_VAR 0 4
99140: PUSH
99141: LD_VAR 0 7
99145: ARRAY
99146: PPUSH
99147: CALL_OW 256
99151: PUSH
99152: LD_INT 1000
99154: EQUAL
99155: PUSH
99156: LD_VAR 0 4
99160: PUSH
99161: LD_VAR 0 7
99165: ARRAY
99166: PUSH
99167: LD_VAR 0 32
99171: IN
99172: AND
99173: IFFALSE 99197
// to_repair := to_repair diff group [ i ] ;
99175: LD_ADDR_VAR 0 32
99179: PUSH
99180: LD_VAR 0 32
99184: PUSH
99185: LD_VAR 0 4
99189: PUSH
99190: LD_VAR 0 7
99194: ARRAY
99195: DIFF
99196: ST_TO_ADDR
// if group [ i ] in to_repair then
99197: LD_VAR 0 4
99201: PUSH
99202: LD_VAR 0 7
99206: ARRAY
99207: PUSH
99208: LD_VAR 0 32
99212: IN
99213: IFFALSE 99260
// begin if not IsInArea ( group [ i ] , f_repair ) then
99215: LD_VAR 0 4
99219: PUSH
99220: LD_VAR 0 7
99224: ARRAY
99225: PPUSH
99226: LD_VAR 0 22
99230: PPUSH
99231: CALL_OW 308
99235: NOT
99236: IFFALSE 99258
// ComMoveToArea ( group [ i ] , f_repair ) ;
99238: LD_VAR 0 4
99242: PUSH
99243: LD_VAR 0 7
99247: ARRAY
99248: PPUSH
99249: LD_VAR 0 22
99253: PPUSH
99254: CALL_OW 113
// continue ;
99258: GO 98885
// end ; end else
99260: GO 99540
// if group [ i ] in repairs then
99262: LD_VAR 0 4
99266: PUSH
99267: LD_VAR 0 7
99271: ARRAY
99272: PUSH
99273: LD_VAR 0 33
99277: IN
99278: IFFALSE 99540
// begin if IsInUnit ( group [ i ] ) then
99280: LD_VAR 0 4
99284: PUSH
99285: LD_VAR 0 7
99289: ARRAY
99290: PPUSH
99291: CALL_OW 310
99295: IFFALSE 99363
// begin z := IsInUnit ( group [ i ] ) ;
99297: LD_ADDR_VAR 0 13
99301: PUSH
99302: LD_VAR 0 4
99306: PUSH
99307: LD_VAR 0 7
99311: ARRAY
99312: PPUSH
99313: CALL_OW 310
99317: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
99318: LD_VAR 0 13
99322: PUSH
99323: LD_VAR 0 32
99327: IN
99328: PUSH
99329: LD_VAR 0 13
99333: PPUSH
99334: LD_VAR 0 22
99338: PPUSH
99339: CALL_OW 308
99343: AND
99344: IFFALSE 99361
// ComExitVehicle ( group [ i ] ) ;
99346: LD_VAR 0 4
99350: PUSH
99351: LD_VAR 0 7
99355: ARRAY
99356: PPUSH
99357: CALL_OW 121
// end else
99361: GO 99540
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
99363: LD_ADDR_VAR 0 13
99367: PUSH
99368: LD_VAR 0 4
99372: PPUSH
99373: LD_INT 95
99375: PUSH
99376: LD_VAR 0 22
99380: PUSH
99381: EMPTY
99382: LIST
99383: LIST
99384: PUSH
99385: LD_INT 58
99387: PUSH
99388: EMPTY
99389: LIST
99390: PUSH
99391: EMPTY
99392: LIST
99393: LIST
99394: PPUSH
99395: CALL_OW 72
99399: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
99400: LD_VAR 0 4
99404: PUSH
99405: LD_VAR 0 7
99409: ARRAY
99410: PPUSH
99411: CALL_OW 314
99415: NOT
99416: IFFALSE 99538
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
99418: LD_ADDR_VAR 0 10
99422: PUSH
99423: LD_VAR 0 13
99427: PPUSH
99428: LD_VAR 0 4
99432: PUSH
99433: LD_VAR 0 7
99437: ARRAY
99438: PPUSH
99439: CALL_OW 74
99443: ST_TO_ADDR
// if not x then
99444: LD_VAR 0 10
99448: NOT
99449: IFFALSE 99453
// continue ;
99451: GO 98885
// if GetLives ( x ) < 1000 then
99453: LD_VAR 0 10
99457: PPUSH
99458: CALL_OW 256
99462: PUSH
99463: LD_INT 1000
99465: LESS
99466: IFFALSE 99490
// ComRepairVehicle ( group [ i ] , x ) else
99468: LD_VAR 0 4
99472: PUSH
99473: LD_VAR 0 7
99477: ARRAY
99478: PPUSH
99479: LD_VAR 0 10
99483: PPUSH
99484: CALL_OW 129
99488: GO 99538
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
99490: LD_VAR 0 23
99494: PUSH
99495: LD_VAR 0 4
99499: PUSH
99500: LD_VAR 0 7
99504: ARRAY
99505: PPUSH
99506: CALL_OW 256
99510: PUSH
99511: LD_INT 1000
99513: LESS
99514: AND
99515: NOT
99516: IFFALSE 99538
// ComEnterUnit ( group [ i ] , x ) ;
99518: LD_VAR 0 4
99522: PUSH
99523: LD_VAR 0 7
99527: ARRAY
99528: PPUSH
99529: LD_VAR 0 10
99533: PPUSH
99534: CALL_OW 120
// end ; continue ;
99538: GO 98885
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
99540: LD_VAR 0 23
99544: PUSH
99545: LD_VAR 0 4
99549: PUSH
99550: LD_VAR 0 7
99554: ARRAY
99555: PPUSH
99556: CALL_OW 247
99560: PUSH
99561: LD_INT 1
99563: EQUAL
99564: AND
99565: IFFALSE 100043
// begin if group [ i ] in healers then
99567: LD_VAR 0 4
99571: PUSH
99572: LD_VAR 0 7
99576: ARRAY
99577: PUSH
99578: LD_VAR 0 31
99582: IN
99583: IFFALSE 99856
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
99585: LD_VAR 0 4
99589: PUSH
99590: LD_VAR 0 7
99594: ARRAY
99595: PPUSH
99596: LD_VAR 0 23
99600: PPUSH
99601: CALL_OW 308
99605: NOT
99606: PUSH
99607: LD_VAR 0 4
99611: PUSH
99612: LD_VAR 0 7
99616: ARRAY
99617: PPUSH
99618: CALL_OW 314
99622: NOT
99623: AND
99624: IFFALSE 99648
// ComMoveToArea ( group [ i ] , f_heal ) else
99626: LD_VAR 0 4
99630: PUSH
99631: LD_VAR 0 7
99635: ARRAY
99636: PPUSH
99637: LD_VAR 0 23
99641: PPUSH
99642: CALL_OW 113
99646: GO 99854
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
99648: LD_VAR 0 4
99652: PUSH
99653: LD_VAR 0 7
99657: ARRAY
99658: PPUSH
99659: CALL 80723 0 1
99663: PPUSH
99664: CALL_OW 256
99668: PUSH
99669: LD_INT 1000
99671: EQUAL
99672: IFFALSE 99691
// ComStop ( group [ i ] ) else
99674: LD_VAR 0 4
99678: PUSH
99679: LD_VAR 0 7
99683: ARRAY
99684: PPUSH
99685: CALL_OW 141
99689: GO 99854
// if not HasTask ( group [ i ] ) and to_heal then
99691: LD_VAR 0 4
99695: PUSH
99696: LD_VAR 0 7
99700: ARRAY
99701: PPUSH
99702: CALL_OW 314
99706: NOT
99707: PUSH
99708: LD_VAR 0 30
99712: AND
99713: IFFALSE 99854
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
99715: LD_ADDR_VAR 0 13
99719: PUSH
99720: LD_VAR 0 30
99724: PPUSH
99725: LD_INT 3
99727: PUSH
99728: LD_INT 54
99730: PUSH
99731: EMPTY
99732: LIST
99733: PUSH
99734: EMPTY
99735: LIST
99736: LIST
99737: PPUSH
99738: CALL_OW 72
99742: PPUSH
99743: LD_VAR 0 4
99747: PUSH
99748: LD_VAR 0 7
99752: ARRAY
99753: PPUSH
99754: CALL_OW 74
99758: ST_TO_ADDR
// if z then
99759: LD_VAR 0 13
99763: IFFALSE 99854
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
99765: LD_INT 91
99767: PUSH
99768: LD_VAR 0 13
99772: PUSH
99773: LD_INT 10
99775: PUSH
99776: EMPTY
99777: LIST
99778: LIST
99779: LIST
99780: PUSH
99781: LD_INT 81
99783: PUSH
99784: LD_VAR 0 13
99788: PPUSH
99789: CALL_OW 255
99793: PUSH
99794: EMPTY
99795: LIST
99796: LIST
99797: PUSH
99798: EMPTY
99799: LIST
99800: LIST
99801: PPUSH
99802: CALL_OW 69
99806: PUSH
99807: LD_INT 0
99809: EQUAL
99810: IFFALSE 99834
// ComHeal ( group [ i ] , z ) else
99812: LD_VAR 0 4
99816: PUSH
99817: LD_VAR 0 7
99821: ARRAY
99822: PPUSH
99823: LD_VAR 0 13
99827: PPUSH
99828: CALL_OW 128
99832: GO 99854
// ComMoveToArea ( group [ i ] , f_heal ) ;
99834: LD_VAR 0 4
99838: PUSH
99839: LD_VAR 0 7
99843: ARRAY
99844: PPUSH
99845: LD_VAR 0 23
99849: PPUSH
99850: CALL_OW 113
// end ; continue ;
99854: GO 98885
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
99856: LD_VAR 0 4
99860: PUSH
99861: LD_VAR 0 7
99865: ARRAY
99866: PPUSH
99867: CALL_OW 256
99871: PUSH
99872: LD_INT 700
99874: LESS
99875: PUSH
99876: LD_VAR 0 4
99880: PUSH
99881: LD_VAR 0 7
99885: ARRAY
99886: PUSH
99887: LD_VAR 0 30
99891: IN
99892: NOT
99893: AND
99894: IFFALSE 99918
// to_heal := to_heal union group [ i ] ;
99896: LD_ADDR_VAR 0 30
99900: PUSH
99901: LD_VAR 0 30
99905: PUSH
99906: LD_VAR 0 4
99910: PUSH
99911: LD_VAR 0 7
99915: ARRAY
99916: UNION
99917: ST_TO_ADDR
// if group [ i ] in to_heal then
99918: LD_VAR 0 4
99922: PUSH
99923: LD_VAR 0 7
99927: ARRAY
99928: PUSH
99929: LD_VAR 0 30
99933: IN
99934: IFFALSE 100043
// begin if GetLives ( group [ i ] ) = 1000 then
99936: LD_VAR 0 4
99940: PUSH
99941: LD_VAR 0 7
99945: ARRAY
99946: PPUSH
99947: CALL_OW 256
99951: PUSH
99952: LD_INT 1000
99954: EQUAL
99955: IFFALSE 99981
// to_heal := to_heal diff group [ i ] else
99957: LD_ADDR_VAR 0 30
99961: PUSH
99962: LD_VAR 0 30
99966: PUSH
99967: LD_VAR 0 4
99971: PUSH
99972: LD_VAR 0 7
99976: ARRAY
99977: DIFF
99978: ST_TO_ADDR
99979: GO 100043
// begin if not IsInArea ( group [ i ] , to_heal ) then
99981: LD_VAR 0 4
99985: PUSH
99986: LD_VAR 0 7
99990: ARRAY
99991: PPUSH
99992: LD_VAR 0 30
99996: PPUSH
99997: CALL_OW 308
100001: NOT
100002: IFFALSE 100026
// ComMoveToArea ( group [ i ] , f_heal ) else
100004: LD_VAR 0 4
100008: PUSH
100009: LD_VAR 0 7
100013: ARRAY
100014: PPUSH
100015: LD_VAR 0 23
100019: PPUSH
100020: CALL_OW 113
100024: GO 100041
// ComHold ( group [ i ] ) ;
100026: LD_VAR 0 4
100030: PUSH
100031: LD_VAR 0 7
100035: ARRAY
100036: PPUSH
100037: CALL_OW 140
// continue ;
100041: GO 98885
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
100043: LD_VAR 0 4
100047: PUSH
100048: LD_VAR 0 7
100052: ARRAY
100053: PPUSH
100054: LD_INT 10
100056: PPUSH
100057: CALL 79143 0 2
100061: NOT
100062: PUSH
100063: LD_VAR 0 16
100067: PUSH
100068: LD_VAR 0 7
100072: ARRAY
100073: PUSH
100074: EMPTY
100075: EQUAL
100076: NOT
100077: AND
100078: IFFALSE 100344
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
100080: LD_VAR 0 4
100084: PUSH
100085: LD_VAR 0 7
100089: ARRAY
100090: PPUSH
100091: CALL_OW 262
100095: PUSH
100096: LD_INT 1
100098: PUSH
100099: LD_INT 2
100101: PUSH
100102: EMPTY
100103: LIST
100104: LIST
100105: IN
100106: IFFALSE 100147
// if GetFuel ( group [ i ] ) < 10 then
100108: LD_VAR 0 4
100112: PUSH
100113: LD_VAR 0 7
100117: ARRAY
100118: PPUSH
100119: CALL_OW 261
100123: PUSH
100124: LD_INT 10
100126: LESS
100127: IFFALSE 100147
// SetFuel ( group [ i ] , 12 ) ;
100129: LD_VAR 0 4
100133: PUSH
100134: LD_VAR 0 7
100138: ARRAY
100139: PPUSH
100140: LD_INT 12
100142: PPUSH
100143: CALL_OW 240
// if units_path [ i ] then
100147: LD_VAR 0 16
100151: PUSH
100152: LD_VAR 0 7
100156: ARRAY
100157: IFFALSE 100342
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
100159: LD_VAR 0 4
100163: PUSH
100164: LD_VAR 0 7
100168: ARRAY
100169: PPUSH
100170: LD_VAR 0 16
100174: PUSH
100175: LD_VAR 0 7
100179: ARRAY
100180: PUSH
100181: LD_INT 1
100183: ARRAY
100184: PUSH
100185: LD_INT 1
100187: ARRAY
100188: PPUSH
100189: LD_VAR 0 16
100193: PUSH
100194: LD_VAR 0 7
100198: ARRAY
100199: PUSH
100200: LD_INT 1
100202: ARRAY
100203: PUSH
100204: LD_INT 2
100206: ARRAY
100207: PPUSH
100208: CALL_OW 297
100212: PUSH
100213: LD_INT 6
100215: GREATER
100216: IFFALSE 100291
// begin if not HasTask ( group [ i ] ) then
100218: LD_VAR 0 4
100222: PUSH
100223: LD_VAR 0 7
100227: ARRAY
100228: PPUSH
100229: CALL_OW 314
100233: NOT
100234: IFFALSE 100289
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
100236: LD_VAR 0 4
100240: PUSH
100241: LD_VAR 0 7
100245: ARRAY
100246: PPUSH
100247: LD_VAR 0 16
100251: PUSH
100252: LD_VAR 0 7
100256: ARRAY
100257: PUSH
100258: LD_INT 1
100260: ARRAY
100261: PUSH
100262: LD_INT 1
100264: ARRAY
100265: PPUSH
100266: LD_VAR 0 16
100270: PUSH
100271: LD_VAR 0 7
100275: ARRAY
100276: PUSH
100277: LD_INT 1
100279: ARRAY
100280: PUSH
100281: LD_INT 2
100283: ARRAY
100284: PPUSH
100285: CALL_OW 114
// end else
100289: GO 100342
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
100291: LD_ADDR_VAR 0 15
100295: PUSH
100296: LD_VAR 0 16
100300: PUSH
100301: LD_VAR 0 7
100305: ARRAY
100306: PPUSH
100307: LD_INT 1
100309: PPUSH
100310: CALL_OW 3
100314: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
100315: LD_ADDR_VAR 0 16
100319: PUSH
100320: LD_VAR 0 16
100324: PPUSH
100325: LD_VAR 0 7
100329: PPUSH
100330: LD_VAR 0 15
100334: PPUSH
100335: CALL_OW 1
100339: ST_TO_ADDR
// continue ;
100340: GO 98885
// end ; end ; end else
100342: GO 103006
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
100344: LD_ADDR_VAR 0 14
100348: PUSH
100349: LD_INT 81
100351: PUSH
100352: LD_VAR 0 4
100356: PUSH
100357: LD_VAR 0 7
100361: ARRAY
100362: PPUSH
100363: CALL_OW 255
100367: PUSH
100368: EMPTY
100369: LIST
100370: LIST
100371: PPUSH
100372: CALL_OW 69
100376: ST_TO_ADDR
// if not tmp then
100377: LD_VAR 0 14
100381: NOT
100382: IFFALSE 100386
// continue ;
100384: GO 98885
// if f_ignore_area then
100386: LD_VAR 0 17
100390: IFFALSE 100478
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
100392: LD_ADDR_VAR 0 15
100396: PUSH
100397: LD_VAR 0 14
100401: PPUSH
100402: LD_INT 3
100404: PUSH
100405: LD_INT 92
100407: PUSH
100408: LD_VAR 0 17
100412: PUSH
100413: LD_INT 1
100415: ARRAY
100416: PUSH
100417: LD_VAR 0 17
100421: PUSH
100422: LD_INT 2
100424: ARRAY
100425: PUSH
100426: LD_VAR 0 17
100430: PUSH
100431: LD_INT 3
100433: ARRAY
100434: PUSH
100435: EMPTY
100436: LIST
100437: LIST
100438: LIST
100439: LIST
100440: PUSH
100441: EMPTY
100442: LIST
100443: LIST
100444: PPUSH
100445: CALL_OW 72
100449: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
100450: LD_VAR 0 14
100454: PUSH
100455: LD_VAR 0 15
100459: DIFF
100460: IFFALSE 100478
// tmp := tmp diff tmp2 ;
100462: LD_ADDR_VAR 0 14
100466: PUSH
100467: LD_VAR 0 14
100471: PUSH
100472: LD_VAR 0 15
100476: DIFF
100477: ST_TO_ADDR
// end ; if not f_murder then
100478: LD_VAR 0 20
100482: NOT
100483: IFFALSE 100541
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
100485: LD_ADDR_VAR 0 15
100489: PUSH
100490: LD_VAR 0 14
100494: PPUSH
100495: LD_INT 3
100497: PUSH
100498: LD_INT 50
100500: PUSH
100501: EMPTY
100502: LIST
100503: PUSH
100504: EMPTY
100505: LIST
100506: LIST
100507: PPUSH
100508: CALL_OW 72
100512: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
100513: LD_VAR 0 14
100517: PUSH
100518: LD_VAR 0 15
100522: DIFF
100523: IFFALSE 100541
// tmp := tmp diff tmp2 ;
100525: LD_ADDR_VAR 0 14
100529: PUSH
100530: LD_VAR 0 14
100534: PUSH
100535: LD_VAR 0 15
100539: DIFF
100540: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
100541: LD_ADDR_VAR 0 14
100545: PUSH
100546: LD_VAR 0 4
100550: PUSH
100551: LD_VAR 0 7
100555: ARRAY
100556: PPUSH
100557: LD_VAR 0 14
100561: PPUSH
100562: LD_INT 1
100564: PPUSH
100565: LD_INT 1
100567: PPUSH
100568: CALL 52786 0 4
100572: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
100573: LD_VAR 0 4
100577: PUSH
100578: LD_VAR 0 7
100582: ARRAY
100583: PPUSH
100584: CALL_OW 257
100588: PUSH
100589: LD_INT 1
100591: EQUAL
100592: IFFALSE 101040
// begin if WantPlant ( group [ i ] ) then
100594: LD_VAR 0 4
100598: PUSH
100599: LD_VAR 0 7
100603: ARRAY
100604: PPUSH
100605: CALL 52287 0 1
100609: IFFALSE 100613
// continue ;
100611: GO 98885
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
100613: LD_VAR 0 18
100617: PUSH
100618: LD_VAR 0 4
100622: PUSH
100623: LD_VAR 0 7
100627: ARRAY
100628: PPUSH
100629: CALL_OW 310
100633: NOT
100634: AND
100635: PUSH
100636: LD_VAR 0 14
100640: PUSH
100641: LD_INT 1
100643: ARRAY
100644: PUSH
100645: LD_VAR 0 14
100649: PPUSH
100650: LD_INT 21
100652: PUSH
100653: LD_INT 2
100655: PUSH
100656: EMPTY
100657: LIST
100658: LIST
100659: PUSH
100660: LD_INT 58
100662: PUSH
100663: EMPTY
100664: LIST
100665: PUSH
100666: EMPTY
100667: LIST
100668: LIST
100669: PPUSH
100670: CALL_OW 72
100674: IN
100675: AND
100676: IFFALSE 100712
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
100678: LD_VAR 0 4
100682: PUSH
100683: LD_VAR 0 7
100687: ARRAY
100688: PPUSH
100689: LD_VAR 0 14
100693: PUSH
100694: LD_INT 1
100696: ARRAY
100697: PPUSH
100698: CALL_OW 120
// attacking := true ;
100702: LD_ADDR_VAR 0 29
100706: PUSH
100707: LD_INT 1
100709: ST_TO_ADDR
// continue ;
100710: GO 98885
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
100712: LD_VAR 0 26
100716: PUSH
100717: LD_VAR 0 4
100721: PUSH
100722: LD_VAR 0 7
100726: ARRAY
100727: PPUSH
100728: CALL_OW 257
100732: PUSH
100733: LD_INT 1
100735: EQUAL
100736: AND
100737: PUSH
100738: LD_VAR 0 4
100742: PUSH
100743: LD_VAR 0 7
100747: ARRAY
100748: PPUSH
100749: CALL_OW 256
100753: PUSH
100754: LD_INT 800
100756: LESS
100757: AND
100758: PUSH
100759: LD_VAR 0 4
100763: PUSH
100764: LD_VAR 0 7
100768: ARRAY
100769: PPUSH
100770: CALL_OW 318
100774: NOT
100775: AND
100776: IFFALSE 100793
// ComCrawl ( group [ i ] ) ;
100778: LD_VAR 0 4
100782: PUSH
100783: LD_VAR 0 7
100787: ARRAY
100788: PPUSH
100789: CALL_OW 137
// if f_mines then
100793: LD_VAR 0 21
100797: IFFALSE 101040
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
100799: LD_VAR 0 14
100803: PUSH
100804: LD_INT 1
100806: ARRAY
100807: PPUSH
100808: CALL_OW 247
100812: PUSH
100813: LD_INT 3
100815: EQUAL
100816: PUSH
100817: LD_VAR 0 14
100821: PUSH
100822: LD_INT 1
100824: ARRAY
100825: PUSH
100826: LD_VAR 0 27
100830: IN
100831: NOT
100832: AND
100833: IFFALSE 101040
// begin x := GetX ( tmp [ 1 ] ) ;
100835: LD_ADDR_VAR 0 10
100839: PUSH
100840: LD_VAR 0 14
100844: PUSH
100845: LD_INT 1
100847: ARRAY
100848: PPUSH
100849: CALL_OW 250
100853: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
100854: LD_ADDR_VAR 0 11
100858: PUSH
100859: LD_VAR 0 14
100863: PUSH
100864: LD_INT 1
100866: ARRAY
100867: PPUSH
100868: CALL_OW 251
100872: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
100873: LD_ADDR_VAR 0 12
100877: PUSH
100878: LD_VAR 0 4
100882: PUSH
100883: LD_VAR 0 7
100887: ARRAY
100888: PPUSH
100889: CALL 79228 0 1
100893: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
100894: LD_VAR 0 4
100898: PUSH
100899: LD_VAR 0 7
100903: ARRAY
100904: PPUSH
100905: LD_VAR 0 10
100909: PPUSH
100910: LD_VAR 0 11
100914: PPUSH
100915: LD_VAR 0 14
100919: PUSH
100920: LD_INT 1
100922: ARRAY
100923: PPUSH
100924: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
100928: LD_VAR 0 4
100932: PUSH
100933: LD_VAR 0 7
100937: ARRAY
100938: PPUSH
100939: LD_VAR 0 10
100943: PPUSH
100944: LD_VAR 0 12
100948: PPUSH
100949: LD_INT 7
100951: PPUSH
100952: CALL_OW 272
100956: PPUSH
100957: LD_VAR 0 11
100961: PPUSH
100962: LD_VAR 0 12
100966: PPUSH
100967: LD_INT 7
100969: PPUSH
100970: CALL_OW 273
100974: PPUSH
100975: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
100979: LD_VAR 0 4
100983: PUSH
100984: LD_VAR 0 7
100988: ARRAY
100989: PPUSH
100990: LD_INT 71
100992: PPUSH
100993: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
100997: LD_ADDR_VAR 0 27
101001: PUSH
101002: LD_VAR 0 27
101006: PPUSH
101007: LD_VAR 0 27
101011: PUSH
101012: LD_INT 1
101014: PLUS
101015: PPUSH
101016: LD_VAR 0 14
101020: PUSH
101021: LD_INT 1
101023: ARRAY
101024: PPUSH
101025: CALL_OW 1
101029: ST_TO_ADDR
// attacking := true ;
101030: LD_ADDR_VAR 0 29
101034: PUSH
101035: LD_INT 1
101037: ST_TO_ADDR
// continue ;
101038: GO 98885
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
101040: LD_VAR 0 4
101044: PUSH
101045: LD_VAR 0 7
101049: ARRAY
101050: PPUSH
101051: CALL_OW 257
101055: PUSH
101056: LD_INT 17
101058: EQUAL
101059: PUSH
101060: LD_VAR 0 4
101064: PUSH
101065: LD_VAR 0 7
101069: ARRAY
101070: PPUSH
101071: CALL_OW 110
101075: PUSH
101076: LD_INT 71
101078: EQUAL
101079: NOT
101080: AND
101081: IFFALSE 101227
// begin attacking := false ;
101083: LD_ADDR_VAR 0 29
101087: PUSH
101088: LD_INT 0
101090: ST_TO_ADDR
// k := 5 ;
101091: LD_ADDR_VAR 0 9
101095: PUSH
101096: LD_INT 5
101098: ST_TO_ADDR
// if tmp < k then
101099: LD_VAR 0 14
101103: PUSH
101104: LD_VAR 0 9
101108: LESS
101109: IFFALSE 101121
// k := tmp ;
101111: LD_ADDR_VAR 0 9
101115: PUSH
101116: LD_VAR 0 14
101120: ST_TO_ADDR
// for j = 1 to k do
101121: LD_ADDR_VAR 0 8
101125: PUSH
101126: DOUBLE
101127: LD_INT 1
101129: DEC
101130: ST_TO_ADDR
101131: LD_VAR 0 9
101135: PUSH
101136: FOR_TO
101137: IFFALSE 101225
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
101139: LD_VAR 0 14
101143: PUSH
101144: LD_VAR 0 8
101148: ARRAY
101149: PUSH
101150: LD_VAR 0 14
101154: PPUSH
101155: LD_INT 58
101157: PUSH
101158: EMPTY
101159: LIST
101160: PPUSH
101161: CALL_OW 72
101165: IN
101166: NOT
101167: IFFALSE 101223
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
101169: LD_VAR 0 4
101173: PUSH
101174: LD_VAR 0 7
101178: ARRAY
101179: PPUSH
101180: LD_VAR 0 14
101184: PUSH
101185: LD_VAR 0 8
101189: ARRAY
101190: PPUSH
101191: CALL_OW 115
// attacking := true ;
101195: LD_ADDR_VAR 0 29
101199: PUSH
101200: LD_INT 1
101202: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
101203: LD_VAR 0 4
101207: PUSH
101208: LD_VAR 0 7
101212: ARRAY
101213: PPUSH
101214: LD_INT 71
101216: PPUSH
101217: CALL_OW 109
// continue ;
101221: GO 101136
// end ; end ;
101223: GO 101136
101225: POP
101226: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
101227: LD_VAR 0 4
101231: PUSH
101232: LD_VAR 0 7
101236: ARRAY
101237: PPUSH
101238: CALL_OW 257
101242: PUSH
101243: LD_INT 8
101245: EQUAL
101246: PUSH
101247: LD_VAR 0 4
101251: PUSH
101252: LD_VAR 0 7
101256: ARRAY
101257: PPUSH
101258: CALL_OW 264
101262: PUSH
101263: LD_INT 28
101265: PUSH
101266: LD_INT 45
101268: PUSH
101269: LD_INT 7
101271: PUSH
101272: LD_INT 47
101274: PUSH
101275: EMPTY
101276: LIST
101277: LIST
101278: LIST
101279: LIST
101280: IN
101281: OR
101282: IFFALSE 101538
// begin attacking := false ;
101284: LD_ADDR_VAR 0 29
101288: PUSH
101289: LD_INT 0
101291: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
101292: LD_VAR 0 14
101296: PUSH
101297: LD_INT 1
101299: ARRAY
101300: PPUSH
101301: CALL_OW 266
101305: PUSH
101306: LD_INT 32
101308: PUSH
101309: LD_INT 31
101311: PUSH
101312: LD_INT 33
101314: PUSH
101315: LD_INT 4
101317: PUSH
101318: LD_INT 5
101320: PUSH
101321: EMPTY
101322: LIST
101323: LIST
101324: LIST
101325: LIST
101326: LIST
101327: IN
101328: IFFALSE 101514
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
101330: LD_ADDR_VAR 0 9
101334: PUSH
101335: LD_VAR 0 14
101339: PUSH
101340: LD_INT 1
101342: ARRAY
101343: PPUSH
101344: CALL_OW 266
101348: PPUSH
101349: LD_VAR 0 14
101353: PUSH
101354: LD_INT 1
101356: ARRAY
101357: PPUSH
101358: CALL_OW 250
101362: PPUSH
101363: LD_VAR 0 14
101367: PUSH
101368: LD_INT 1
101370: ARRAY
101371: PPUSH
101372: CALL_OW 251
101376: PPUSH
101377: LD_VAR 0 14
101381: PUSH
101382: LD_INT 1
101384: ARRAY
101385: PPUSH
101386: CALL_OW 254
101390: PPUSH
101391: LD_VAR 0 14
101395: PUSH
101396: LD_INT 1
101398: ARRAY
101399: PPUSH
101400: CALL_OW 248
101404: PPUSH
101405: LD_INT 0
101407: PPUSH
101408: CALL 60598 0 6
101412: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
101413: LD_ADDR_VAR 0 8
101417: PUSH
101418: LD_VAR 0 4
101422: PUSH
101423: LD_VAR 0 7
101427: ARRAY
101428: PPUSH
101429: LD_VAR 0 9
101433: PPUSH
101434: CALL 79268 0 2
101438: ST_TO_ADDR
// if j then
101439: LD_VAR 0 8
101443: IFFALSE 101512
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
101445: LD_VAR 0 8
101449: PUSH
101450: LD_INT 1
101452: ARRAY
101453: PPUSH
101454: LD_VAR 0 8
101458: PUSH
101459: LD_INT 2
101461: ARRAY
101462: PPUSH
101463: CALL_OW 488
101467: IFFALSE 101512
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
101469: LD_VAR 0 4
101473: PUSH
101474: LD_VAR 0 7
101478: ARRAY
101479: PPUSH
101480: LD_VAR 0 8
101484: PUSH
101485: LD_INT 1
101487: ARRAY
101488: PPUSH
101489: LD_VAR 0 8
101493: PUSH
101494: LD_INT 2
101496: ARRAY
101497: PPUSH
101498: CALL_OW 116
// attacking := true ;
101502: LD_ADDR_VAR 0 29
101506: PUSH
101507: LD_INT 1
101509: ST_TO_ADDR
// continue ;
101510: GO 98885
// end ; end else
101512: GO 101538
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
101514: LD_VAR 0 4
101518: PUSH
101519: LD_VAR 0 7
101523: ARRAY
101524: PPUSH
101525: LD_VAR 0 14
101529: PUSH
101530: LD_INT 1
101532: ARRAY
101533: PPUSH
101534: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
101538: LD_VAR 0 4
101542: PUSH
101543: LD_VAR 0 7
101547: ARRAY
101548: PPUSH
101549: CALL_OW 265
101553: PUSH
101554: LD_INT 11
101556: EQUAL
101557: IFFALSE 101835
// begin k := 10 ;
101559: LD_ADDR_VAR 0 9
101563: PUSH
101564: LD_INT 10
101566: ST_TO_ADDR
// x := 0 ;
101567: LD_ADDR_VAR 0 10
101571: PUSH
101572: LD_INT 0
101574: ST_TO_ADDR
// if tmp < k then
101575: LD_VAR 0 14
101579: PUSH
101580: LD_VAR 0 9
101584: LESS
101585: IFFALSE 101597
// k := tmp ;
101587: LD_ADDR_VAR 0 9
101591: PUSH
101592: LD_VAR 0 14
101596: ST_TO_ADDR
// for j = k downto 1 do
101597: LD_ADDR_VAR 0 8
101601: PUSH
101602: DOUBLE
101603: LD_VAR 0 9
101607: INC
101608: ST_TO_ADDR
101609: LD_INT 1
101611: PUSH
101612: FOR_DOWNTO
101613: IFFALSE 101688
// begin if GetType ( tmp [ j ] ) = unit_human then
101615: LD_VAR 0 14
101619: PUSH
101620: LD_VAR 0 8
101624: ARRAY
101625: PPUSH
101626: CALL_OW 247
101630: PUSH
101631: LD_INT 1
101633: EQUAL
101634: IFFALSE 101686
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
101636: LD_VAR 0 4
101640: PUSH
101641: LD_VAR 0 7
101645: ARRAY
101646: PPUSH
101647: LD_VAR 0 14
101651: PUSH
101652: LD_VAR 0 8
101656: ARRAY
101657: PPUSH
101658: CALL 79539 0 2
// x := tmp [ j ] ;
101662: LD_ADDR_VAR 0 10
101666: PUSH
101667: LD_VAR 0 14
101671: PUSH
101672: LD_VAR 0 8
101676: ARRAY
101677: ST_TO_ADDR
// attacking := true ;
101678: LD_ADDR_VAR 0 29
101682: PUSH
101683: LD_INT 1
101685: ST_TO_ADDR
// end ; end ;
101686: GO 101612
101688: POP
101689: POP
// if not x then
101690: LD_VAR 0 10
101694: NOT
101695: IFFALSE 101835
// begin attacking := true ;
101697: LD_ADDR_VAR 0 29
101701: PUSH
101702: LD_INT 1
101704: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
101705: LD_VAR 0 4
101709: PUSH
101710: LD_VAR 0 7
101714: ARRAY
101715: PPUSH
101716: CALL_OW 250
101720: PPUSH
101721: LD_VAR 0 4
101725: PUSH
101726: LD_VAR 0 7
101730: ARRAY
101731: PPUSH
101732: CALL_OW 251
101736: PPUSH
101737: CALL_OW 546
101741: PUSH
101742: LD_INT 2
101744: ARRAY
101745: PUSH
101746: LD_VAR 0 14
101750: PUSH
101751: LD_INT 1
101753: ARRAY
101754: PPUSH
101755: CALL_OW 250
101759: PPUSH
101760: LD_VAR 0 14
101764: PUSH
101765: LD_INT 1
101767: ARRAY
101768: PPUSH
101769: CALL_OW 251
101773: PPUSH
101774: CALL_OW 546
101778: PUSH
101779: LD_INT 2
101781: ARRAY
101782: EQUAL
101783: IFFALSE 101811
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
101785: LD_VAR 0 4
101789: PUSH
101790: LD_VAR 0 7
101794: ARRAY
101795: PPUSH
101796: LD_VAR 0 14
101800: PUSH
101801: LD_INT 1
101803: ARRAY
101804: PPUSH
101805: CALL 79539 0 2
101809: GO 101835
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
101811: LD_VAR 0 4
101815: PUSH
101816: LD_VAR 0 7
101820: ARRAY
101821: PPUSH
101822: LD_VAR 0 14
101826: PUSH
101827: LD_INT 1
101829: ARRAY
101830: PPUSH
101831: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
101835: LD_VAR 0 4
101839: PUSH
101840: LD_VAR 0 7
101844: ARRAY
101845: PPUSH
101846: CALL_OW 264
101850: PUSH
101851: LD_INT 29
101853: EQUAL
101854: IFFALSE 102220
// begin if WantsToAttack ( group [ i ] ) in bombed then
101856: LD_VAR 0 4
101860: PUSH
101861: LD_VAR 0 7
101865: ARRAY
101866: PPUSH
101867: CALL_OW 319
101871: PUSH
101872: LD_VAR 0 28
101876: IN
101877: IFFALSE 101881
// continue ;
101879: GO 98885
// k := 8 ;
101881: LD_ADDR_VAR 0 9
101885: PUSH
101886: LD_INT 8
101888: ST_TO_ADDR
// x := 0 ;
101889: LD_ADDR_VAR 0 10
101893: PUSH
101894: LD_INT 0
101896: ST_TO_ADDR
// if tmp < k then
101897: LD_VAR 0 14
101901: PUSH
101902: LD_VAR 0 9
101906: LESS
101907: IFFALSE 101919
// k := tmp ;
101909: LD_ADDR_VAR 0 9
101913: PUSH
101914: LD_VAR 0 14
101918: ST_TO_ADDR
// for j = 1 to k do
101919: LD_ADDR_VAR 0 8
101923: PUSH
101924: DOUBLE
101925: LD_INT 1
101927: DEC
101928: ST_TO_ADDR
101929: LD_VAR 0 9
101933: PUSH
101934: FOR_TO
101935: IFFALSE 102067
// begin if GetType ( tmp [ j ] ) = unit_building then
101937: LD_VAR 0 14
101941: PUSH
101942: LD_VAR 0 8
101946: ARRAY
101947: PPUSH
101948: CALL_OW 247
101952: PUSH
101953: LD_INT 3
101955: EQUAL
101956: IFFALSE 102065
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
101958: LD_VAR 0 14
101962: PUSH
101963: LD_VAR 0 8
101967: ARRAY
101968: PUSH
101969: LD_VAR 0 28
101973: IN
101974: NOT
101975: PUSH
101976: LD_VAR 0 14
101980: PUSH
101981: LD_VAR 0 8
101985: ARRAY
101986: PPUSH
101987: CALL_OW 313
101991: AND
101992: IFFALSE 102065
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
101994: LD_VAR 0 4
101998: PUSH
101999: LD_VAR 0 7
102003: ARRAY
102004: PPUSH
102005: LD_VAR 0 14
102009: PUSH
102010: LD_VAR 0 8
102014: ARRAY
102015: PPUSH
102016: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
102020: LD_ADDR_VAR 0 28
102024: PUSH
102025: LD_VAR 0 28
102029: PPUSH
102030: LD_VAR 0 28
102034: PUSH
102035: LD_INT 1
102037: PLUS
102038: PPUSH
102039: LD_VAR 0 14
102043: PUSH
102044: LD_VAR 0 8
102048: ARRAY
102049: PPUSH
102050: CALL_OW 1
102054: ST_TO_ADDR
// attacking := true ;
102055: LD_ADDR_VAR 0 29
102059: PUSH
102060: LD_INT 1
102062: ST_TO_ADDR
// break ;
102063: GO 102067
// end ; end ;
102065: GO 101934
102067: POP
102068: POP
// if not attacking and f_attack_depot then
102069: LD_VAR 0 29
102073: NOT
102074: PUSH
102075: LD_VAR 0 25
102079: AND
102080: IFFALSE 102175
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
102082: LD_ADDR_VAR 0 13
102086: PUSH
102087: LD_VAR 0 14
102091: PPUSH
102092: LD_INT 2
102094: PUSH
102095: LD_INT 30
102097: PUSH
102098: LD_INT 0
102100: PUSH
102101: EMPTY
102102: LIST
102103: LIST
102104: PUSH
102105: LD_INT 30
102107: PUSH
102108: LD_INT 1
102110: PUSH
102111: EMPTY
102112: LIST
102113: LIST
102114: PUSH
102115: EMPTY
102116: LIST
102117: LIST
102118: LIST
102119: PPUSH
102120: CALL_OW 72
102124: ST_TO_ADDR
// if z then
102125: LD_VAR 0 13
102129: IFFALSE 102175
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
102131: LD_VAR 0 4
102135: PUSH
102136: LD_VAR 0 7
102140: ARRAY
102141: PPUSH
102142: LD_VAR 0 13
102146: PPUSH
102147: LD_VAR 0 4
102151: PUSH
102152: LD_VAR 0 7
102156: ARRAY
102157: PPUSH
102158: CALL_OW 74
102162: PPUSH
102163: CALL_OW 115
// attacking := true ;
102167: LD_ADDR_VAR 0 29
102171: PUSH
102172: LD_INT 1
102174: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
102175: LD_VAR 0 4
102179: PUSH
102180: LD_VAR 0 7
102184: ARRAY
102185: PPUSH
102186: CALL_OW 256
102190: PUSH
102191: LD_INT 500
102193: LESS
102194: IFFALSE 102220
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
102196: LD_VAR 0 4
102200: PUSH
102201: LD_VAR 0 7
102205: ARRAY
102206: PPUSH
102207: LD_VAR 0 14
102211: PUSH
102212: LD_INT 1
102214: ARRAY
102215: PPUSH
102216: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
102220: LD_VAR 0 4
102224: PUSH
102225: LD_VAR 0 7
102229: ARRAY
102230: PPUSH
102231: CALL_OW 264
102235: PUSH
102236: LD_INT 49
102238: EQUAL
102239: IFFALSE 102360
// begin if not HasTask ( group [ i ] ) then
102241: LD_VAR 0 4
102245: PUSH
102246: LD_VAR 0 7
102250: ARRAY
102251: PPUSH
102252: CALL_OW 314
102256: NOT
102257: IFFALSE 102360
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
102259: LD_ADDR_VAR 0 9
102263: PUSH
102264: LD_INT 81
102266: PUSH
102267: LD_VAR 0 4
102271: PUSH
102272: LD_VAR 0 7
102276: ARRAY
102277: PPUSH
102278: CALL_OW 255
102282: PUSH
102283: EMPTY
102284: LIST
102285: LIST
102286: PPUSH
102287: CALL_OW 69
102291: PPUSH
102292: LD_VAR 0 4
102296: PUSH
102297: LD_VAR 0 7
102301: ARRAY
102302: PPUSH
102303: CALL_OW 74
102307: ST_TO_ADDR
// if k then
102308: LD_VAR 0 9
102312: IFFALSE 102360
// if GetDistUnits ( group [ i ] , k ) > 10 then
102314: LD_VAR 0 4
102318: PUSH
102319: LD_VAR 0 7
102323: ARRAY
102324: PPUSH
102325: LD_VAR 0 9
102329: PPUSH
102330: CALL_OW 296
102334: PUSH
102335: LD_INT 10
102337: GREATER
102338: IFFALSE 102360
// ComMoveUnit ( group [ i ] , k ) ;
102340: LD_VAR 0 4
102344: PUSH
102345: LD_VAR 0 7
102349: ARRAY
102350: PPUSH
102351: LD_VAR 0 9
102355: PPUSH
102356: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
102360: LD_VAR 0 4
102364: PUSH
102365: LD_VAR 0 7
102369: ARRAY
102370: PPUSH
102371: CALL_OW 256
102375: PUSH
102376: LD_INT 250
102378: LESS
102379: PUSH
102380: LD_VAR 0 4
102384: PUSH
102385: LD_VAR 0 7
102389: ARRAY
102390: PUSH
102391: LD_INT 21
102393: PUSH
102394: LD_INT 2
102396: PUSH
102397: EMPTY
102398: LIST
102399: LIST
102400: PUSH
102401: LD_INT 23
102403: PUSH
102404: LD_INT 2
102406: PUSH
102407: EMPTY
102408: LIST
102409: LIST
102410: PUSH
102411: EMPTY
102412: LIST
102413: LIST
102414: PPUSH
102415: CALL_OW 69
102419: IN
102420: AND
102421: IFFALSE 102546
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
102423: LD_ADDR_VAR 0 9
102427: PUSH
102428: LD_OWVAR 3
102432: PUSH
102433: LD_VAR 0 4
102437: PUSH
102438: LD_VAR 0 7
102442: ARRAY
102443: DIFF
102444: PPUSH
102445: LD_VAR 0 4
102449: PUSH
102450: LD_VAR 0 7
102454: ARRAY
102455: PPUSH
102456: CALL_OW 74
102460: ST_TO_ADDR
// if not k then
102461: LD_VAR 0 9
102465: NOT
102466: IFFALSE 102470
// continue ;
102468: GO 98885
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
102470: LD_VAR 0 9
102474: PUSH
102475: LD_INT 81
102477: PUSH
102478: LD_VAR 0 4
102482: PUSH
102483: LD_VAR 0 7
102487: ARRAY
102488: PPUSH
102489: CALL_OW 255
102493: PUSH
102494: EMPTY
102495: LIST
102496: LIST
102497: PPUSH
102498: CALL_OW 69
102502: IN
102503: PUSH
102504: LD_VAR 0 9
102508: PPUSH
102509: LD_VAR 0 4
102513: PUSH
102514: LD_VAR 0 7
102518: ARRAY
102519: PPUSH
102520: CALL_OW 296
102524: PUSH
102525: LD_INT 5
102527: LESS
102528: AND
102529: IFFALSE 102546
// ComAutodestruct ( group [ i ] ) ;
102531: LD_VAR 0 4
102535: PUSH
102536: LD_VAR 0 7
102540: ARRAY
102541: PPUSH
102542: CALL 79437 0 1
// end ; if f_attack_depot then
102546: LD_VAR 0 25
102550: IFFALSE 102662
// begin k := 6 ;
102552: LD_ADDR_VAR 0 9
102556: PUSH
102557: LD_INT 6
102559: ST_TO_ADDR
// if tmp < k then
102560: LD_VAR 0 14
102564: PUSH
102565: LD_VAR 0 9
102569: LESS
102570: IFFALSE 102582
// k := tmp ;
102572: LD_ADDR_VAR 0 9
102576: PUSH
102577: LD_VAR 0 14
102581: ST_TO_ADDR
// for j = 1 to k do
102582: LD_ADDR_VAR 0 8
102586: PUSH
102587: DOUBLE
102588: LD_INT 1
102590: DEC
102591: ST_TO_ADDR
102592: LD_VAR 0 9
102596: PUSH
102597: FOR_TO
102598: IFFALSE 102660
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
102600: LD_VAR 0 8
102604: PPUSH
102605: CALL_OW 266
102609: PUSH
102610: LD_INT 0
102612: PUSH
102613: LD_INT 1
102615: PUSH
102616: EMPTY
102617: LIST
102618: LIST
102619: IN
102620: IFFALSE 102658
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
102622: LD_VAR 0 4
102626: PUSH
102627: LD_VAR 0 7
102631: ARRAY
102632: PPUSH
102633: LD_VAR 0 14
102637: PUSH
102638: LD_VAR 0 8
102642: ARRAY
102643: PPUSH
102644: CALL_OW 115
// attacking := true ;
102648: LD_ADDR_VAR 0 29
102652: PUSH
102653: LD_INT 1
102655: ST_TO_ADDR
// break ;
102656: GO 102660
// end ;
102658: GO 102597
102660: POP
102661: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
102662: LD_VAR 0 4
102666: PUSH
102667: LD_VAR 0 7
102671: ARRAY
102672: PPUSH
102673: CALL_OW 302
102677: PUSH
102678: LD_VAR 0 29
102682: NOT
102683: AND
102684: IFFALSE 103006
// begin if GetTag ( group [ i ] ) = 71 then
102686: LD_VAR 0 4
102690: PUSH
102691: LD_VAR 0 7
102695: ARRAY
102696: PPUSH
102697: CALL_OW 110
102701: PUSH
102702: LD_INT 71
102704: EQUAL
102705: IFFALSE 102746
// begin if HasTask ( group [ i ] ) then
102707: LD_VAR 0 4
102711: PUSH
102712: LD_VAR 0 7
102716: ARRAY
102717: PPUSH
102718: CALL_OW 314
102722: IFFALSE 102728
// continue else
102724: GO 98885
102726: GO 102746
// SetTag ( group [ i ] , 0 ) ;
102728: LD_VAR 0 4
102732: PUSH
102733: LD_VAR 0 7
102737: ARRAY
102738: PPUSH
102739: LD_INT 0
102741: PPUSH
102742: CALL_OW 109
// end ; k := 8 ;
102746: LD_ADDR_VAR 0 9
102750: PUSH
102751: LD_INT 8
102753: ST_TO_ADDR
// x := 0 ;
102754: LD_ADDR_VAR 0 10
102758: PUSH
102759: LD_INT 0
102761: ST_TO_ADDR
// if tmp < k then
102762: LD_VAR 0 14
102766: PUSH
102767: LD_VAR 0 9
102771: LESS
102772: IFFALSE 102784
// k := tmp ;
102774: LD_ADDR_VAR 0 9
102778: PUSH
102779: LD_VAR 0 14
102783: ST_TO_ADDR
// for j = 1 to k do
102784: LD_ADDR_VAR 0 8
102788: PUSH
102789: DOUBLE
102790: LD_INT 1
102792: DEC
102793: ST_TO_ADDR
102794: LD_VAR 0 9
102798: PUSH
102799: FOR_TO
102800: IFFALSE 102898
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
102802: LD_VAR 0 14
102806: PUSH
102807: LD_VAR 0 8
102811: ARRAY
102812: PPUSH
102813: CALL_OW 247
102817: PUSH
102818: LD_INT 1
102820: EQUAL
102821: PUSH
102822: LD_VAR 0 14
102826: PUSH
102827: LD_VAR 0 8
102831: ARRAY
102832: PPUSH
102833: CALL_OW 256
102837: PUSH
102838: LD_INT 250
102840: LESS
102841: PUSH
102842: LD_VAR 0 20
102846: AND
102847: PUSH
102848: LD_VAR 0 20
102852: NOT
102853: PUSH
102854: LD_VAR 0 14
102858: PUSH
102859: LD_VAR 0 8
102863: ARRAY
102864: PPUSH
102865: CALL_OW 256
102869: PUSH
102870: LD_INT 250
102872: GREATEREQUAL
102873: AND
102874: OR
102875: AND
102876: IFFALSE 102896
// begin x := tmp [ j ] ;
102878: LD_ADDR_VAR 0 10
102882: PUSH
102883: LD_VAR 0 14
102887: PUSH
102888: LD_VAR 0 8
102892: ARRAY
102893: ST_TO_ADDR
// break ;
102894: GO 102898
// end ;
102896: GO 102799
102898: POP
102899: POP
// if x then
102900: LD_VAR 0 10
102904: IFFALSE 102928
// ComAttackUnit ( group [ i ] , x ) else
102906: LD_VAR 0 4
102910: PUSH
102911: LD_VAR 0 7
102915: ARRAY
102916: PPUSH
102917: LD_VAR 0 10
102921: PPUSH
102922: CALL_OW 115
102926: GO 102952
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
102928: LD_VAR 0 4
102932: PUSH
102933: LD_VAR 0 7
102937: ARRAY
102938: PPUSH
102939: LD_VAR 0 14
102943: PUSH
102944: LD_INT 1
102946: ARRAY
102947: PPUSH
102948: CALL_OW 115
// if not HasTask ( group [ i ] ) then
102952: LD_VAR 0 4
102956: PUSH
102957: LD_VAR 0 7
102961: ARRAY
102962: PPUSH
102963: CALL_OW 314
102967: NOT
102968: IFFALSE 103006
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
102970: LD_VAR 0 4
102974: PUSH
102975: LD_VAR 0 7
102979: ARRAY
102980: PPUSH
102981: LD_VAR 0 14
102985: PPUSH
102986: LD_VAR 0 4
102990: PUSH
102991: LD_VAR 0 7
102995: ARRAY
102996: PPUSH
102997: CALL_OW 74
103001: PPUSH
103002: CALL_OW 115
// end ; end ; end ;
103006: GO 98885
103008: POP
103009: POP
// wait ( 0 0$2 ) ;
103010: LD_INT 70
103012: PPUSH
103013: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
103017: LD_VAR 0 4
103021: NOT
103022: PUSH
103023: LD_VAR 0 4
103027: PUSH
103028: EMPTY
103029: EQUAL
103030: OR
103031: PUSH
103032: LD_INT 81
103034: PUSH
103035: LD_VAR 0 35
103039: PUSH
103040: EMPTY
103041: LIST
103042: LIST
103043: PPUSH
103044: CALL_OW 69
103048: NOT
103049: OR
103050: IFFALSE 98870
// end ;
103052: LD_VAR 0 2
103056: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
103057: LD_INT 0
103059: PPUSH
103060: PPUSH
103061: PPUSH
103062: PPUSH
103063: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
103064: LD_VAR 0 1
103068: NOT
103069: PUSH
103070: LD_EXP 50
103074: PUSH
103075: LD_VAR 0 1
103079: ARRAY
103080: NOT
103081: OR
103082: PUSH
103083: LD_VAR 0 2
103087: NOT
103088: OR
103089: PUSH
103090: LD_VAR 0 3
103094: NOT
103095: OR
103096: IFFALSE 103100
// exit ;
103098: GO 103613
// side := mc_sides [ base ] ;
103100: LD_ADDR_VAR 0 6
103104: PUSH
103105: LD_EXP 76
103109: PUSH
103110: LD_VAR 0 1
103114: ARRAY
103115: ST_TO_ADDR
// if not side then
103116: LD_VAR 0 6
103120: NOT
103121: IFFALSE 103125
// exit ;
103123: GO 103613
// for i in solds do
103125: LD_ADDR_VAR 0 7
103129: PUSH
103130: LD_VAR 0 2
103134: PUSH
103135: FOR_IN
103136: IFFALSE 103197
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
103138: LD_VAR 0 7
103142: PPUSH
103143: CALL_OW 310
103147: PPUSH
103148: CALL_OW 266
103152: PUSH
103153: LD_INT 32
103155: PUSH
103156: LD_INT 31
103158: PUSH
103159: EMPTY
103160: LIST
103161: LIST
103162: IN
103163: IFFALSE 103183
// solds := solds diff i else
103165: LD_ADDR_VAR 0 2
103169: PUSH
103170: LD_VAR 0 2
103174: PUSH
103175: LD_VAR 0 7
103179: DIFF
103180: ST_TO_ADDR
103181: GO 103195
// SetTag ( i , 18 ) ;
103183: LD_VAR 0 7
103187: PPUSH
103188: LD_INT 18
103190: PPUSH
103191: CALL_OW 109
103195: GO 103135
103197: POP
103198: POP
// if not solds then
103199: LD_VAR 0 2
103203: NOT
103204: IFFALSE 103208
// exit ;
103206: GO 103613
// repeat wait ( 0 0$1 ) ;
103208: LD_INT 35
103210: PPUSH
103211: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
103215: LD_ADDR_VAR 0 5
103219: PUSH
103220: LD_VAR 0 6
103224: PPUSH
103225: LD_VAR 0 3
103229: PPUSH
103230: CALL 49152 0 2
103234: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
103235: LD_EXP 50
103239: PUSH
103240: LD_VAR 0 1
103244: ARRAY
103245: NOT
103246: PUSH
103247: LD_EXP 50
103251: PUSH
103252: LD_VAR 0 1
103256: ARRAY
103257: PUSH
103258: EMPTY
103259: EQUAL
103260: OR
103261: IFFALSE 103298
// begin for i in solds do
103263: LD_ADDR_VAR 0 7
103267: PUSH
103268: LD_VAR 0 2
103272: PUSH
103273: FOR_IN
103274: IFFALSE 103287
// ComStop ( i ) ;
103276: LD_VAR 0 7
103280: PPUSH
103281: CALL_OW 141
103285: GO 103273
103287: POP
103288: POP
// solds := [ ] ;
103289: LD_ADDR_VAR 0 2
103293: PUSH
103294: EMPTY
103295: ST_TO_ADDR
// exit ;
103296: GO 103613
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
103298: LD_VAR 0 5
103302: NOT
103303: PUSH
103304: LD_VAR 0 5
103308: PUSH
103309: LD_INT 3
103311: GREATER
103312: OR
103313: PUSH
103314: LD_EXP 72
103318: PUSH
103319: LD_VAR 0 1
103323: ARRAY
103324: OR
103325: IFFALSE 103366
// begin for i in solds do
103327: LD_ADDR_VAR 0 7
103331: PUSH
103332: LD_VAR 0 2
103336: PUSH
103337: FOR_IN
103338: IFFALSE 103362
// if HasTask ( i ) then
103340: LD_VAR 0 7
103344: PPUSH
103345: CALL_OW 314
103349: IFFALSE 103360
// ComStop ( i ) ;
103351: LD_VAR 0 7
103355: PPUSH
103356: CALL_OW 141
103360: GO 103337
103362: POP
103363: POP
// break ;
103364: GO 103601
// end ; for i in solds do
103366: LD_ADDR_VAR 0 7
103370: PUSH
103371: LD_VAR 0 2
103375: PUSH
103376: FOR_IN
103377: IFFALSE 103593
// begin if IsInUnit ( i ) then
103379: LD_VAR 0 7
103383: PPUSH
103384: CALL_OW 310
103388: IFFALSE 103399
// ComExitBuilding ( i ) ;
103390: LD_VAR 0 7
103394: PPUSH
103395: CALL_OW 122
// if GetLives ( i ) > 333 then
103399: LD_VAR 0 7
103403: PPUSH
103404: CALL_OW 256
103408: PUSH
103409: LD_INT 333
103411: GREATER
103412: IFFALSE 103440
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
103414: LD_VAR 0 7
103418: PPUSH
103419: LD_VAR 0 5
103423: PPUSH
103424: LD_VAR 0 7
103428: PPUSH
103429: CALL_OW 74
103433: PPUSH
103434: CALL_OW 115
103438: GO 103591
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
103440: LD_ADDR_VAR 0 8
103444: PUSH
103445: LD_EXP 50
103449: PUSH
103450: LD_VAR 0 1
103454: ARRAY
103455: PPUSH
103456: LD_INT 2
103458: PUSH
103459: LD_INT 30
103461: PUSH
103462: LD_INT 0
103464: PUSH
103465: EMPTY
103466: LIST
103467: LIST
103468: PUSH
103469: LD_INT 30
103471: PUSH
103472: LD_INT 1
103474: PUSH
103475: EMPTY
103476: LIST
103477: LIST
103478: PUSH
103479: LD_INT 30
103481: PUSH
103482: LD_INT 6
103484: PUSH
103485: EMPTY
103486: LIST
103487: LIST
103488: PUSH
103489: EMPTY
103490: LIST
103491: LIST
103492: LIST
103493: LIST
103494: PPUSH
103495: CALL_OW 72
103499: PPUSH
103500: LD_VAR 0 7
103504: PPUSH
103505: CALL_OW 74
103509: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
103510: LD_VAR 0 7
103514: PPUSH
103515: LD_VAR 0 8
103519: PPUSH
103520: CALL_OW 250
103524: PPUSH
103525: LD_INT 3
103527: PPUSH
103528: LD_INT 5
103530: PPUSH
103531: CALL_OW 272
103535: PPUSH
103536: LD_VAR 0 8
103540: PPUSH
103541: CALL_OW 251
103545: PPUSH
103546: LD_INT 3
103548: PPUSH
103549: LD_INT 5
103551: PPUSH
103552: CALL_OW 273
103556: PPUSH
103557: CALL_OW 111
// SetTag ( i , 0 ) ;
103561: LD_VAR 0 7
103565: PPUSH
103566: LD_INT 0
103568: PPUSH
103569: CALL_OW 109
// solds := solds diff i ;
103573: LD_ADDR_VAR 0 2
103577: PUSH
103578: LD_VAR 0 2
103582: PUSH
103583: LD_VAR 0 7
103587: DIFF
103588: ST_TO_ADDR
// continue ;
103589: GO 103376
// end ; end ;
103591: GO 103376
103593: POP
103594: POP
// until solds ;
103595: LD_VAR 0 2
103599: IFFALSE 103208
// MC_Reset ( base , 18 ) ;
103601: LD_VAR 0 1
103605: PPUSH
103606: LD_INT 18
103608: PPUSH
103609: CALL 21460 0 2
// end ;
103613: LD_VAR 0 4
103617: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
103618: LD_INT 0
103620: PPUSH
103621: PPUSH
103622: PPUSH
103623: PPUSH
103624: PPUSH
103625: PPUSH
103626: PPUSH
103627: PPUSH
103628: PPUSH
103629: PPUSH
103630: PPUSH
103631: PPUSH
103632: PPUSH
103633: PPUSH
103634: PPUSH
103635: PPUSH
103636: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
103637: LD_ADDR_VAR 0 13
103641: PUSH
103642: LD_EXP 50
103646: PUSH
103647: LD_VAR 0 1
103651: ARRAY
103652: PPUSH
103653: LD_INT 25
103655: PUSH
103656: LD_INT 3
103658: PUSH
103659: EMPTY
103660: LIST
103661: LIST
103662: PPUSH
103663: CALL_OW 72
103667: ST_TO_ADDR
// if mc_remote_driver [ base ] then
103668: LD_EXP 90
103672: PUSH
103673: LD_VAR 0 1
103677: ARRAY
103678: IFFALSE 103702
// mechs := mechs diff mc_remote_driver [ base ] ;
103680: LD_ADDR_VAR 0 13
103684: PUSH
103685: LD_VAR 0 13
103689: PUSH
103690: LD_EXP 90
103694: PUSH
103695: LD_VAR 0 1
103699: ARRAY
103700: DIFF
103701: ST_TO_ADDR
// for i in mechs do
103702: LD_ADDR_VAR 0 5
103706: PUSH
103707: LD_VAR 0 13
103711: PUSH
103712: FOR_IN
103713: IFFALSE 103748
// if GetTag ( i ) > 0 then
103715: LD_VAR 0 5
103719: PPUSH
103720: CALL_OW 110
103724: PUSH
103725: LD_INT 0
103727: GREATER
103728: IFFALSE 103746
// mechs := mechs diff i ;
103730: LD_ADDR_VAR 0 13
103734: PUSH
103735: LD_VAR 0 13
103739: PUSH
103740: LD_VAR 0 5
103744: DIFF
103745: ST_TO_ADDR
103746: GO 103712
103748: POP
103749: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
103750: LD_ADDR_VAR 0 9
103754: PUSH
103755: LD_EXP 50
103759: PUSH
103760: LD_VAR 0 1
103764: ARRAY
103765: PPUSH
103766: LD_INT 2
103768: PUSH
103769: LD_INT 25
103771: PUSH
103772: LD_INT 1
103774: PUSH
103775: EMPTY
103776: LIST
103777: LIST
103778: PUSH
103779: LD_INT 25
103781: PUSH
103782: LD_INT 5
103784: PUSH
103785: EMPTY
103786: LIST
103787: LIST
103788: PUSH
103789: LD_INT 25
103791: PUSH
103792: LD_INT 8
103794: PUSH
103795: EMPTY
103796: LIST
103797: LIST
103798: PUSH
103799: LD_INT 25
103801: PUSH
103802: LD_INT 9
103804: PUSH
103805: EMPTY
103806: LIST
103807: LIST
103808: PUSH
103809: EMPTY
103810: LIST
103811: LIST
103812: LIST
103813: LIST
103814: LIST
103815: PPUSH
103816: CALL_OW 72
103820: ST_TO_ADDR
// if not defenders and not solds then
103821: LD_VAR 0 2
103825: NOT
103826: PUSH
103827: LD_VAR 0 9
103831: NOT
103832: AND
103833: IFFALSE 103837
// exit ;
103835: GO 105463
// depot_under_attack := false ;
103837: LD_ADDR_VAR 0 17
103841: PUSH
103842: LD_INT 0
103844: ST_TO_ADDR
// sold_defenders := [ ] ;
103845: LD_ADDR_VAR 0 18
103849: PUSH
103850: EMPTY
103851: ST_TO_ADDR
// if mechs then
103852: LD_VAR 0 13
103856: IFFALSE 103985
// for i in defenders do
103858: LD_ADDR_VAR 0 5
103862: PUSH
103863: LD_VAR 0 2
103867: PUSH
103868: FOR_IN
103869: IFFALSE 103983
// begin SetTag ( i , 20 ) ;
103871: LD_VAR 0 5
103875: PPUSH
103876: LD_INT 20
103878: PPUSH
103879: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
103883: LD_VAR 0 5
103887: PPUSH
103888: CALL_OW 263
103892: PUSH
103893: LD_INT 1
103895: EQUAL
103896: PUSH
103897: LD_VAR 0 5
103901: PPUSH
103902: CALL_OW 311
103906: NOT
103907: AND
103908: PUSH
103909: LD_VAR 0 13
103913: AND
103914: IFFALSE 103981
// begin un := mechs [ 1 ] ;
103916: LD_ADDR_VAR 0 11
103920: PUSH
103921: LD_VAR 0 13
103925: PUSH
103926: LD_INT 1
103928: ARRAY
103929: ST_TO_ADDR
// ComExitBuilding ( un ) ;
103930: LD_VAR 0 11
103934: PPUSH
103935: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
103939: LD_VAR 0 11
103943: PPUSH
103944: LD_VAR 0 5
103948: PPUSH
103949: CALL_OW 180
// SetTag ( un , 19 ) ;
103953: LD_VAR 0 11
103957: PPUSH
103958: LD_INT 19
103960: PPUSH
103961: CALL_OW 109
// mechs := mechs diff un ;
103965: LD_ADDR_VAR 0 13
103969: PUSH
103970: LD_VAR 0 13
103974: PUSH
103975: LD_VAR 0 11
103979: DIFF
103980: ST_TO_ADDR
// end ; end ;
103981: GO 103868
103983: POP
103984: POP
// if solds then
103985: LD_VAR 0 9
103989: IFFALSE 104048
// for i in solds do
103991: LD_ADDR_VAR 0 5
103995: PUSH
103996: LD_VAR 0 9
104000: PUSH
104001: FOR_IN
104002: IFFALSE 104046
// if not GetTag ( i ) then
104004: LD_VAR 0 5
104008: PPUSH
104009: CALL_OW 110
104013: NOT
104014: IFFALSE 104044
// begin defenders := defenders union i ;
104016: LD_ADDR_VAR 0 2
104020: PUSH
104021: LD_VAR 0 2
104025: PUSH
104026: LD_VAR 0 5
104030: UNION
104031: ST_TO_ADDR
// SetTag ( i , 18 ) ;
104032: LD_VAR 0 5
104036: PPUSH
104037: LD_INT 18
104039: PPUSH
104040: CALL_OW 109
// end ;
104044: GO 104001
104046: POP
104047: POP
// repeat wait ( 0 0$1 ) ;
104048: LD_INT 35
104050: PPUSH
104051: CALL_OW 67
// enemy := mc_scan [ base ] ;
104055: LD_ADDR_VAR 0 3
104059: PUSH
104060: LD_EXP 73
104064: PUSH
104065: LD_VAR 0 1
104069: ARRAY
104070: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
104071: LD_EXP 50
104075: PUSH
104076: LD_VAR 0 1
104080: ARRAY
104081: NOT
104082: PUSH
104083: LD_EXP 50
104087: PUSH
104088: LD_VAR 0 1
104092: ARRAY
104093: PUSH
104094: EMPTY
104095: EQUAL
104096: OR
104097: IFFALSE 104134
// begin for i in defenders do
104099: LD_ADDR_VAR 0 5
104103: PUSH
104104: LD_VAR 0 2
104108: PUSH
104109: FOR_IN
104110: IFFALSE 104123
// ComStop ( i ) ;
104112: LD_VAR 0 5
104116: PPUSH
104117: CALL_OW 141
104121: GO 104109
104123: POP
104124: POP
// defenders := [ ] ;
104125: LD_ADDR_VAR 0 2
104129: PUSH
104130: EMPTY
104131: ST_TO_ADDR
// exit ;
104132: GO 105463
// end ; for i in defenders do
104134: LD_ADDR_VAR 0 5
104138: PUSH
104139: LD_VAR 0 2
104143: PUSH
104144: FOR_IN
104145: IFFALSE 104963
// begin e := NearestUnitToUnit ( enemy , i ) ;
104147: LD_ADDR_VAR 0 14
104151: PUSH
104152: LD_VAR 0 3
104156: PPUSH
104157: LD_VAR 0 5
104161: PPUSH
104162: CALL_OW 74
104166: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
104167: LD_ADDR_VAR 0 8
104171: PUSH
104172: LD_EXP 50
104176: PUSH
104177: LD_VAR 0 1
104181: ARRAY
104182: PPUSH
104183: LD_INT 2
104185: PUSH
104186: LD_INT 30
104188: PUSH
104189: LD_INT 0
104191: PUSH
104192: EMPTY
104193: LIST
104194: LIST
104195: PUSH
104196: LD_INT 30
104198: PUSH
104199: LD_INT 1
104201: PUSH
104202: EMPTY
104203: LIST
104204: LIST
104205: PUSH
104206: EMPTY
104207: LIST
104208: LIST
104209: LIST
104210: PPUSH
104211: CALL_OW 72
104215: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
104216: LD_ADDR_VAR 0 17
104220: PUSH
104221: LD_VAR 0 8
104225: NOT
104226: PUSH
104227: LD_VAR 0 8
104231: PPUSH
104232: LD_INT 3
104234: PUSH
104235: LD_INT 24
104237: PUSH
104238: LD_INT 600
104240: PUSH
104241: EMPTY
104242: LIST
104243: LIST
104244: PUSH
104245: EMPTY
104246: LIST
104247: LIST
104248: PPUSH
104249: CALL_OW 72
104253: OR
104254: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
104255: LD_VAR 0 5
104259: PPUSH
104260: CALL_OW 247
104264: PUSH
104265: LD_INT 2
104267: DOUBLE
104268: EQUAL
104269: IFTRUE 104273
104271: GO 104669
104273: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
104274: LD_VAR 0 5
104278: PPUSH
104279: CALL_OW 256
104283: PUSH
104284: LD_INT 650
104286: GREATER
104287: PUSH
104288: LD_VAR 0 5
104292: PPUSH
104293: LD_VAR 0 14
104297: PPUSH
104298: CALL_OW 296
104302: PUSH
104303: LD_INT 40
104305: LESS
104306: PUSH
104307: LD_VAR 0 14
104311: PPUSH
104312: LD_EXP 75
104316: PUSH
104317: LD_VAR 0 1
104321: ARRAY
104322: PPUSH
104323: CALL_OW 308
104327: OR
104328: AND
104329: IFFALSE 104451
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
104331: LD_VAR 0 5
104335: PPUSH
104336: CALL_OW 262
104340: PUSH
104341: LD_INT 1
104343: EQUAL
104344: PUSH
104345: LD_VAR 0 5
104349: PPUSH
104350: CALL_OW 261
104354: PUSH
104355: LD_INT 30
104357: LESS
104358: AND
104359: PUSH
104360: LD_VAR 0 8
104364: AND
104365: IFFALSE 104435
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
104367: LD_VAR 0 5
104371: PPUSH
104372: LD_VAR 0 8
104376: PPUSH
104377: LD_VAR 0 5
104381: PPUSH
104382: CALL_OW 74
104386: PPUSH
104387: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
104391: LD_VAR 0 5
104395: PPUSH
104396: LD_VAR 0 8
104400: PPUSH
104401: LD_VAR 0 5
104405: PPUSH
104406: CALL_OW 74
104410: PPUSH
104411: CALL_OW 296
104415: PUSH
104416: LD_INT 6
104418: LESS
104419: IFFALSE 104433
// SetFuel ( i , 100 ) ;
104421: LD_VAR 0 5
104425: PPUSH
104426: LD_INT 100
104428: PPUSH
104429: CALL_OW 240
// end else
104433: GO 104449
// ComAttackUnit ( i , e ) ;
104435: LD_VAR 0 5
104439: PPUSH
104440: LD_VAR 0 14
104444: PPUSH
104445: CALL_OW 115
// end else
104449: GO 104552
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
104451: LD_VAR 0 14
104455: PPUSH
104456: LD_EXP 75
104460: PUSH
104461: LD_VAR 0 1
104465: ARRAY
104466: PPUSH
104467: CALL_OW 308
104471: NOT
104472: PUSH
104473: LD_VAR 0 5
104477: PPUSH
104478: LD_VAR 0 14
104482: PPUSH
104483: CALL_OW 296
104487: PUSH
104488: LD_INT 40
104490: GREATEREQUAL
104491: AND
104492: PUSH
104493: LD_VAR 0 5
104497: PPUSH
104498: CALL_OW 256
104502: PUSH
104503: LD_INT 650
104505: LESSEQUAL
104506: OR
104507: PUSH
104508: LD_VAR 0 5
104512: PPUSH
104513: LD_EXP 74
104517: PUSH
104518: LD_VAR 0 1
104522: ARRAY
104523: PPUSH
104524: CALL_OW 308
104528: NOT
104529: AND
104530: IFFALSE 104552
// ComMoveToArea ( i , mc_parking [ base ] ) ;
104532: LD_VAR 0 5
104536: PPUSH
104537: LD_EXP 74
104541: PUSH
104542: LD_VAR 0 1
104546: ARRAY
104547: PPUSH
104548: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
104552: LD_VAR 0 5
104556: PPUSH
104557: CALL_OW 256
104561: PUSH
104562: LD_INT 998
104564: LESS
104565: PUSH
104566: LD_VAR 0 5
104570: PPUSH
104571: CALL_OW 263
104575: PUSH
104576: LD_INT 1
104578: EQUAL
104579: AND
104580: PUSH
104581: LD_VAR 0 5
104585: PPUSH
104586: CALL_OW 311
104590: AND
104591: PUSH
104592: LD_VAR 0 5
104596: PPUSH
104597: LD_EXP 74
104601: PUSH
104602: LD_VAR 0 1
104606: ARRAY
104607: PPUSH
104608: CALL_OW 308
104612: AND
104613: IFFALSE 104667
// begin mech := IsDrivenBy ( i ) ;
104615: LD_ADDR_VAR 0 10
104619: PUSH
104620: LD_VAR 0 5
104624: PPUSH
104625: CALL_OW 311
104629: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
104630: LD_VAR 0 10
104634: PPUSH
104635: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
104639: LD_VAR 0 10
104643: PPUSH
104644: LD_VAR 0 5
104648: PPUSH
104649: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
104653: LD_VAR 0 10
104657: PPUSH
104658: LD_VAR 0 5
104662: PPUSH
104663: CALL_OW 180
// end ; end ; unit_human :
104667: GO 104934
104669: LD_INT 1
104671: DOUBLE
104672: EQUAL
104673: IFTRUE 104677
104675: GO 104933
104677: POP
// begin b := IsInUnit ( i ) ;
104678: LD_ADDR_VAR 0 19
104682: PUSH
104683: LD_VAR 0 5
104687: PPUSH
104688: CALL_OW 310
104692: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
104693: LD_ADDR_VAR 0 20
104697: PUSH
104698: LD_VAR 0 19
104702: NOT
104703: PUSH
104704: LD_VAR 0 19
104708: PPUSH
104709: CALL_OW 266
104713: PUSH
104714: LD_INT 32
104716: PUSH
104717: LD_INT 31
104719: PUSH
104720: EMPTY
104721: LIST
104722: LIST
104723: IN
104724: OR
104725: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
104726: LD_VAR 0 17
104730: PUSH
104731: LD_VAR 0 2
104735: PPUSH
104736: LD_INT 21
104738: PUSH
104739: LD_INT 2
104741: PUSH
104742: EMPTY
104743: LIST
104744: LIST
104745: PPUSH
104746: CALL_OW 72
104750: PUSH
104751: LD_INT 1
104753: LESSEQUAL
104754: OR
104755: PUSH
104756: LD_VAR 0 20
104760: AND
104761: PUSH
104762: LD_VAR 0 5
104766: PUSH
104767: LD_VAR 0 18
104771: IN
104772: NOT
104773: AND
104774: IFFALSE 104867
// begin if b then
104776: LD_VAR 0 19
104780: IFFALSE 104829
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
104782: LD_VAR 0 19
104786: PPUSH
104787: LD_VAR 0 3
104791: PPUSH
104792: LD_VAR 0 19
104796: PPUSH
104797: CALL_OW 74
104801: PPUSH
104802: CALL_OW 296
104806: PUSH
104807: LD_INT 10
104809: LESS
104810: PUSH
104811: LD_VAR 0 19
104815: PPUSH
104816: CALL_OW 461
104820: PUSH
104821: LD_INT 7
104823: NONEQUAL
104824: AND
104825: IFFALSE 104829
// continue ;
104827: GO 104144
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
104829: LD_ADDR_VAR 0 18
104833: PUSH
104834: LD_VAR 0 18
104838: PPUSH
104839: LD_VAR 0 18
104843: PUSH
104844: LD_INT 1
104846: PLUS
104847: PPUSH
104848: LD_VAR 0 5
104852: PPUSH
104853: CALL_OW 1
104857: ST_TO_ADDR
// ComExitBuilding ( i ) ;
104858: LD_VAR 0 5
104862: PPUSH
104863: CALL_OW 122
// end ; if sold_defenders then
104867: LD_VAR 0 18
104871: IFFALSE 104931
// if i in sold_defenders then
104873: LD_VAR 0 5
104877: PUSH
104878: LD_VAR 0 18
104882: IN
104883: IFFALSE 104931
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
104885: LD_VAR 0 5
104889: PPUSH
104890: CALL_OW 314
104894: NOT
104895: PUSH
104896: LD_VAR 0 5
104900: PPUSH
104901: LD_VAR 0 14
104905: PPUSH
104906: CALL_OW 296
104910: PUSH
104911: LD_INT 30
104913: LESS
104914: AND
104915: IFFALSE 104931
// ComAttackUnit ( i , e ) ;
104917: LD_VAR 0 5
104921: PPUSH
104922: LD_VAR 0 14
104926: PPUSH
104927: CALL_OW 115
// end ; end ; end ;
104931: GO 104934
104933: POP
// if IsDead ( i ) then
104934: LD_VAR 0 5
104938: PPUSH
104939: CALL_OW 301
104943: IFFALSE 104961
// defenders := defenders diff i ;
104945: LD_ADDR_VAR 0 2
104949: PUSH
104950: LD_VAR 0 2
104954: PUSH
104955: LD_VAR 0 5
104959: DIFF
104960: ST_TO_ADDR
// end ;
104961: GO 104144
104963: POP
104964: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
104965: LD_VAR 0 3
104969: NOT
104970: PUSH
104971: LD_VAR 0 2
104975: NOT
104976: OR
104977: PUSH
104978: LD_EXP 50
104982: PUSH
104983: LD_VAR 0 1
104987: ARRAY
104988: NOT
104989: OR
104990: IFFALSE 104048
// MC_Reset ( base , 18 ) ;
104992: LD_VAR 0 1
104996: PPUSH
104997: LD_INT 18
104999: PPUSH
105000: CALL 21460 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
105004: LD_ADDR_VAR 0 2
105008: PUSH
105009: LD_VAR 0 2
105013: PUSH
105014: LD_VAR 0 2
105018: PPUSH
105019: LD_INT 2
105021: PUSH
105022: LD_INT 25
105024: PUSH
105025: LD_INT 1
105027: PUSH
105028: EMPTY
105029: LIST
105030: LIST
105031: PUSH
105032: LD_INT 25
105034: PUSH
105035: LD_INT 5
105037: PUSH
105038: EMPTY
105039: LIST
105040: LIST
105041: PUSH
105042: LD_INT 25
105044: PUSH
105045: LD_INT 8
105047: PUSH
105048: EMPTY
105049: LIST
105050: LIST
105051: PUSH
105052: LD_INT 25
105054: PUSH
105055: LD_INT 9
105057: PUSH
105058: EMPTY
105059: LIST
105060: LIST
105061: PUSH
105062: EMPTY
105063: LIST
105064: LIST
105065: LIST
105066: LIST
105067: LIST
105068: PPUSH
105069: CALL_OW 72
105073: DIFF
105074: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
105075: LD_VAR 0 3
105079: NOT
105080: PUSH
105081: LD_VAR 0 2
105085: PPUSH
105086: LD_INT 21
105088: PUSH
105089: LD_INT 2
105091: PUSH
105092: EMPTY
105093: LIST
105094: LIST
105095: PPUSH
105096: CALL_OW 72
105100: AND
105101: IFFALSE 105439
// begin tmp := FilterByTag ( defenders , 19 ) ;
105103: LD_ADDR_VAR 0 12
105107: PUSH
105108: LD_VAR 0 2
105112: PPUSH
105113: LD_INT 19
105115: PPUSH
105116: CALL 80912 0 2
105120: ST_TO_ADDR
// if tmp then
105121: LD_VAR 0 12
105125: IFFALSE 105195
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
105127: LD_ADDR_VAR 0 12
105131: PUSH
105132: LD_VAR 0 12
105136: PPUSH
105137: LD_INT 25
105139: PUSH
105140: LD_INT 3
105142: PUSH
105143: EMPTY
105144: LIST
105145: LIST
105146: PPUSH
105147: CALL_OW 72
105151: ST_TO_ADDR
// if tmp then
105152: LD_VAR 0 12
105156: IFFALSE 105195
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
105158: LD_ADDR_EXP 62
105162: PUSH
105163: LD_EXP 62
105167: PPUSH
105168: LD_VAR 0 1
105172: PPUSH
105173: LD_EXP 62
105177: PUSH
105178: LD_VAR 0 1
105182: ARRAY
105183: PUSH
105184: LD_VAR 0 12
105188: UNION
105189: PPUSH
105190: CALL_OW 1
105194: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
105195: LD_VAR 0 1
105199: PPUSH
105200: LD_INT 19
105202: PPUSH
105203: CALL 21460 0 2
// repeat wait ( 0 0$1 ) ;
105207: LD_INT 35
105209: PPUSH
105210: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
105214: LD_EXP 50
105218: PUSH
105219: LD_VAR 0 1
105223: ARRAY
105224: NOT
105225: PUSH
105226: LD_EXP 50
105230: PUSH
105231: LD_VAR 0 1
105235: ARRAY
105236: PUSH
105237: EMPTY
105238: EQUAL
105239: OR
105240: IFFALSE 105277
// begin for i in defenders do
105242: LD_ADDR_VAR 0 5
105246: PUSH
105247: LD_VAR 0 2
105251: PUSH
105252: FOR_IN
105253: IFFALSE 105266
// ComStop ( i ) ;
105255: LD_VAR 0 5
105259: PPUSH
105260: CALL_OW 141
105264: GO 105252
105266: POP
105267: POP
// defenders := [ ] ;
105268: LD_ADDR_VAR 0 2
105272: PUSH
105273: EMPTY
105274: ST_TO_ADDR
// exit ;
105275: GO 105463
// end ; for i in defenders do
105277: LD_ADDR_VAR 0 5
105281: PUSH
105282: LD_VAR 0 2
105286: PUSH
105287: FOR_IN
105288: IFFALSE 105377
// begin if not IsInArea ( i , mc_parking [ base ] ) then
105290: LD_VAR 0 5
105294: PPUSH
105295: LD_EXP 74
105299: PUSH
105300: LD_VAR 0 1
105304: ARRAY
105305: PPUSH
105306: CALL_OW 308
105310: NOT
105311: IFFALSE 105335
// ComMoveToArea ( i , mc_parking [ base ] ) else
105313: LD_VAR 0 5
105317: PPUSH
105318: LD_EXP 74
105322: PUSH
105323: LD_VAR 0 1
105327: ARRAY
105328: PPUSH
105329: CALL_OW 113
105333: GO 105375
// if GetControl ( i ) = control_manual then
105335: LD_VAR 0 5
105339: PPUSH
105340: CALL_OW 263
105344: PUSH
105345: LD_INT 1
105347: EQUAL
105348: IFFALSE 105375
// if IsDrivenBy ( i ) then
105350: LD_VAR 0 5
105354: PPUSH
105355: CALL_OW 311
105359: IFFALSE 105375
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
105361: LD_VAR 0 5
105365: PPUSH
105366: CALL_OW 311
105370: PPUSH
105371: CALL_OW 121
// end ;
105375: GO 105287
105377: POP
105378: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
105379: LD_VAR 0 2
105383: PPUSH
105384: LD_INT 95
105386: PUSH
105387: LD_EXP 74
105391: PUSH
105392: LD_VAR 0 1
105396: ARRAY
105397: PUSH
105398: EMPTY
105399: LIST
105400: LIST
105401: PPUSH
105402: CALL_OW 72
105406: PUSH
105407: LD_VAR 0 2
105411: EQUAL
105412: PUSH
105413: LD_EXP 73
105417: PUSH
105418: LD_VAR 0 1
105422: ARRAY
105423: OR
105424: PUSH
105425: LD_EXP 50
105429: PUSH
105430: LD_VAR 0 1
105434: ARRAY
105435: NOT
105436: OR
105437: IFFALSE 105207
// end ; MC_Reset ( base , 19 ) ;
105439: LD_VAR 0 1
105443: PPUSH
105444: LD_INT 19
105446: PPUSH
105447: CALL 21460 0 2
// MC_Reset ( base , 20 ) ;
105451: LD_VAR 0 1
105455: PPUSH
105456: LD_INT 20
105458: PPUSH
105459: CALL 21460 0 2
// end ;
105463: LD_VAR 0 4
105467: RET
