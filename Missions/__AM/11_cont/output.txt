// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Randomize ;
  11: CALL_OW 10
// InitVariables ;
  15: CALL 94 0 0
// InitMacro ;
  19: CALL 18475 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// ChangeSideFog ( 8 , 1 ) ;
  36: LD_INT 8
  38: PPUSH
  39: LD_INT 1
  41: PPUSH
  42: CALL_OW 343
// PrepareNature ( 4 , 3 , 6 , 3 , 2 , 0 , 7 , natureArea , waterArea ) ;
  46: LD_INT 4
  48: PPUSH
  49: LD_INT 3
  51: PPUSH
  52: LD_INT 6
  54: PPUSH
  55: LD_INT 3
  57: PPUSH
  58: LD_INT 2
  60: PPUSH
  61: LD_INT 0
  63: PPUSH
  64: LD_INT 7
  66: PPUSH
  67: LD_INT 18
  69: PPUSH
  70: LD_INT 19
  72: PPUSH
  73: CALL 83551 0 9
// PrepareAmerican ;
  77: CALL 653 0 0
// PrepareArabian ;
  81: CALL 2624 0 0
// MC_Start ( ) ;
  85: CALL 20655 0 0
// Action ;
  89: CALL 8768 0 0
// end ;
  93: END
// export debug , game ; export mission_prefix , mission_prefix_prev ; export ar_run , base_captured , ar_patrol , us_scout , seen , can_kamikazed , kamikazed , artifact_stolen , artifact_get , artifact_oncargo , game_time , powell_warn , loses_counter , gensher_active , selected , am_veh_consturcted ; function InitVariables ; begin
  94: LD_INT 0
  96: PPUSH
// debug := false ;
  97: LD_ADDR_EXP 1
 101: PUSH
 102: LD_INT 0
 104: ST_TO_ADDR
// game := true ;
 105: LD_ADDR_EXP 2
 109: PUSH
 110: LD_INT 1
 112: ST_TO_ADDR
// mission_prefix := 11_ ;
 113: LD_ADDR_EXP 3
 117: PUSH
 118: LD_STRING 11_
 120: ST_TO_ADDR
// mission_prefix_prev := 10c_ ;
 121: LD_ADDR_EXP 4
 125: PUSH
 126: LD_STRING 10c_
 128: ST_TO_ADDR
// ar_run := false ;
 129: LD_ADDR_EXP 5
 133: PUSH
 134: LD_INT 0
 136: ST_TO_ADDR
// ar_patrol := false ;
 137: LD_ADDR_EXP 7
 141: PUSH
 142: LD_INT 0
 144: ST_TO_ADDR
// base_captured := false ;
 145: LD_ADDR_EXP 6
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// us_scout := 0 ;
 153: LD_ADDR_EXP 8
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// seen := [ 0 , 0 , 0 , 0 , 0 ] ;
 161: LD_ADDR_EXP 9
 165: PUSH
 166: LD_INT 0
 168: PUSH
 169: LD_INT 0
 171: PUSH
 172: LD_INT 0
 174: PUSH
 175: LD_INT 0
 177: PUSH
 178: LD_INT 0
 180: PUSH
 181: EMPTY
 182: LIST
 183: LIST
 184: LIST
 185: LIST
 186: LIST
 187: ST_TO_ADDR
// kamikazed := false ;
 188: LD_ADDR_EXP 11
 192: PUSH
 193: LD_INT 0
 195: ST_TO_ADDR
// artifact_stolen := false ;
 196: LD_ADDR_EXP 12
 200: PUSH
 201: LD_INT 0
 203: ST_TO_ADDR
// artifact_get := false ;
 204: LD_ADDR_EXP 13
 208: PUSH
 209: LD_INT 0
 211: ST_TO_ADDR
// game_time := [ 130 130$00 , 120 120$00 , 115 115$00 , 112 112$00 ] [ Difficulty ] ;
 212: LD_ADDR_EXP 15
 216: PUSH
 217: LD_INT 273000
 219: PUSH
 220: LD_INT 252000
 222: PUSH
 223: LD_INT 241500
 225: PUSH
 226: LD_INT 235200
 228: PUSH
 229: EMPTY
 230: LIST
 231: LIST
 232: LIST
 233: LIST
 234: PUSH
 235: LD_OWVAR 67
 239: ARRAY
 240: ST_TO_ADDR
// powell_warn := false ;
 241: LD_ADDR_EXP 16
 245: PUSH
 246: LD_INT 0
 248: ST_TO_ADDR
// loses_counter := 0 ;
 249: LD_ADDR_EXP 17
 253: PUSH
 254: LD_INT 0
 256: ST_TO_ADDR
// artifact_oncargo := false ;
 257: LD_ADDR_EXP 14
 261: PUSH
 262: LD_INT 0
 264: ST_TO_ADDR
// gensher_active := LoadVariable ( 10_GensherEscape_1 , debug ) ;
 265: LD_ADDR_EXP 18
 269: PUSH
 270: LD_STRING 10_GensherEscape_1
 272: PPUSH
 273: LD_EXP 1
 277: PPUSH
 278: CALL_OW 30
 282: ST_TO_ADDR
// can_kamikazed := false ;
 283: LD_ADDR_EXP 10
 287: PUSH
 288: LD_INT 0
 290: ST_TO_ADDR
// am_veh_consturcted := false ;
 291: LD_ADDR_EXP 20
 295: PUSH
 296: LD_INT 0
 298: ST_TO_ADDR
// end ;
 299: LD_VAR 0 1
 303: RET
// export function CustomInitMacro ; var i ; begin
 304: LD_INT 0
 306: PPUSH
 307: PPUSH
// mc_parking := [ parking_north , parking_west , parking_east ] ;
 308: LD_ADDR_EXP 74
 312: PUSH
 313: LD_INT 20
 315: PUSH
 316: LD_INT 21
 318: PUSH
 319: LD_INT 22
 321: PUSH
 322: EMPTY
 323: LIST
 324: LIST
 325: LIST
 326: ST_TO_ADDR
// mc_scan_area := [ base_north , base_west , base_east ] ;
 327: LD_ADDR_EXP 75
 331: PUSH
 332: LD_INT 28
 334: PUSH
 335: LD_INT 24
 337: PUSH
 338: LD_INT 26
 340: PUSH
 341: EMPTY
 342: LIST
 343: LIST
 344: LIST
 345: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield1_left ) ;
 346: LD_INT 1
 348: PPUSH
 349: LD_INT 4
 351: PUSH
 352: LD_INT 6
 354: PUSH
 355: LD_INT 8
 357: PUSH
 358: LD_INT 9
 360: PUSH
 361: EMPTY
 362: LIST
 363: LIST
 364: LIST
 365: LIST
 366: PUSH
 367: LD_OWVAR 67
 371: ARRAY
 372: PPUSH
 373: LD_INT 3
 375: PPUSH
 376: CALL 42372 0 3
// MC_SetMinesField ( 2 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield2_left ) ;
 380: LD_INT 2
 382: PPUSH
 383: LD_INT 4
 385: PUSH
 386: LD_INT 6
 388: PUSH
 389: LD_INT 8
 391: PUSH
 392: LD_INT 9
 394: PUSH
 395: EMPTY
 396: LIST
 397: LIST
 398: LIST
 399: LIST
 400: PUSH
 401: LD_OWVAR 67
 405: ARRAY
 406: PPUSH
 407: LD_INT 2
 409: PPUSH
 410: CALL 42372 0 3
// MC_SetMinesField ( 3 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield3_left ) ;
 414: LD_INT 3
 416: PPUSH
 417: LD_INT 4
 419: PUSH
 420: LD_INT 6
 422: PUSH
 423: LD_INT 8
 425: PUSH
 426: LD_INT 9
 428: PUSH
 429: EMPTY
 430: LIST
 431: LIST
 432: LIST
 433: LIST
 434: PUSH
 435: LD_OWVAR 67
 439: ARRAY
 440: PPUSH
 441: LD_INT 1
 443: PPUSH
 444: CALL 42372 0 3
// for i = 1 to mc_bases do
 448: LD_ADDR_VAR 0 2
 452: PUSH
 453: DOUBLE
 454: LD_INT 1
 456: DEC
 457: ST_TO_ADDR
 458: LD_EXP 50
 462: PUSH
 463: FOR_TO
 464: IFFALSE 488
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 466: LD_VAR 0 2
 470: PPUSH
 471: LD_EXP 43
 475: PUSH
 476: LD_VAR 0 2
 480: ARRAY
 481: PPUSH
 482: CALL 42817 0 2
 486: GO 463
 488: POP
 489: POP
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] , ] ) ;
 490: LD_INT 1
 492: PPUSH
 493: LD_INT 14
 495: PUSH
 496: LD_INT 1
 498: PUSH
 499: LD_INT 2
 501: PUSH
 502: LD_INT 88
 504: PUSH
 505: EMPTY
 506: LIST
 507: LIST
 508: LIST
 509: LIST
 510: PUSH
 511: LD_INT 14
 513: PUSH
 514: LD_INT 1
 516: PUSH
 517: LD_INT 2
 519: PUSH
 520: LD_INT 88
 522: PUSH
 523: EMPTY
 524: LIST
 525: LIST
 526: LIST
 527: LIST
 528: PUSH
 529: EMPTY
 530: LIST
 531: LIST
 532: PPUSH
 533: CALL 42709 0 2
// MC_SetProduceList ( 2 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 537: LD_INT 2
 539: PPUSH
 540: LD_INT 14
 542: PUSH
 543: LD_INT 1
 545: PUSH
 546: LD_INT 2
 548: PUSH
 549: LD_INT 88
 551: PUSH
 552: EMPTY
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: PUSH
 558: EMPTY
 559: LIST
 560: PPUSH
 561: CALL 42709 0 2
// end ;
 565: LD_VAR 0 1
 569: RET
// function Debuger ; var i ; begin
 570: LD_INT 0
 572: PPUSH
 573: PPUSH
// if not debug then
 574: LD_EXP 1
 578: NOT
 579: IFFALSE 583
// exit ;
 581: GO 619
// game_speed := 5 ;
 583: LD_ADDR_OWVAR 65
 587: PUSH
 588: LD_INT 5
 590: ST_TO_ADDR
// uc_side := 1 ;
 591: LD_ADDR_OWVAR 20
 595: PUSH
 596: LD_INT 1
 598: ST_TO_ADDR
// uc_nation := 1 ;
 599: LD_ADDR_OWVAR 21
 603: PUSH
 604: LD_INT 1
 606: ST_TO_ADDR
// SetSide ( ar_force_south , 1 ) ;
 607: LD_EXP 36
 611: PPUSH
 612: LD_INT 1
 614: PPUSH
 615: CALL_OW 235
// end ;
 619: LD_VAR 0 1
 623: RET
// every 0 0$1 trigger IsDead ( ar_dep_n ) and IsOk ( ar_dep_w ) do
 624: LD_INT 94
 626: PPUSH
 627: CALL_OW 301
 631: PUSH
 632: LD_INT 45
 634: PPUSH
 635: CALL_OW 302
 639: AND
 640: IFFALSE 652
 642: GO 644
 644: DISABLE
// SetAchievement ( ACH_EAST ) ; end_of_file
 645: LD_STRING ACH_EAST
 647: PPUSH
 648: CALL_OW 543
 652: END
// export JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Frank , Kikuchi ; export function PrepareAmerican ; var i , k , un , tmp , vehs , veh , others ; begin
 653: LD_INT 0
 655: PPUSH
 656: PPUSH
 657: PPUSH
 658: PPUSH
 659: PPUSH
 660: PPUSH
 661: PPUSH
 662: PPUSH
// uc_side := 4 ;
 663: LD_ADDR_OWVAR 20
 667: PUSH
 668: LD_INT 4
 670: ST_TO_ADDR
// uc_nation := 1 ;
 671: LD_ADDR_OWVAR 21
 675: PUSH
 676: LD_INT 1
 678: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
 679: LD_ADDR_EXP 30
 683: PUSH
 684: LD_STRING Powell
 686: PPUSH
 687: LD_INT 0
 689: PPUSH
 690: LD_STRING 
 692: PPUSH
 693: CALL 49183 0 3
 697: ST_TO_ADDR
// uc_side := 1 ;
 698: LD_ADDR_OWVAR 20
 702: PUSH
 703: LD_INT 1
 705: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , mission_prefix_prev ) ;
 706: LD_ADDR_EXP 21
 710: PUSH
 711: LD_STRING JMM
 713: PPUSH
 714: LD_EXP 1
 718: NOT
 719: PPUSH
 720: LD_EXP 4
 724: PPUSH
 725: CALL 49183 0 3
 729: ST_TO_ADDR
// if GetClass ( JMM ) > 4 then
 730: LD_EXP 21
 734: PPUSH
 735: CALL_OW 257
 739: PUSH
 740: LD_INT 4
 742: GREATER
 743: IFFALSE 757
// SetClass ( JMM , 1 ) ;
 745: LD_EXP 21
 749: PPUSH
 750: LD_INT 1
 752: PPUSH
 753: CALL_OW 336
// Lisa := PrepareUnit ( Lisa , ( not debug ) , mission_prefix_prev ) ;
 757: LD_ADDR_EXP 22
 761: PUSH
 762: LD_STRING Lisa
 764: PPUSH
 765: LD_EXP 1
 769: NOT
 770: PPUSH
 771: LD_EXP 4
 775: PPUSH
 776: CALL 49183 0 3
 780: ST_TO_ADDR
// if not Lisa then
 781: LD_EXP 22
 785: NOT
 786: IFFALSE 801
// Lisa := CreateCharacter ( 10_Lisa ) ;
 788: LD_ADDR_EXP 22
 792: PUSH
 793: LD_STRING 10_Lisa
 795: PPUSH
 796: CALL_OW 34
 800: ST_TO_ADDR
// if not Lisa then
 801: LD_EXP 22
 805: NOT
 806: IFFALSE 821
// Lisa := CreateCharacter ( 09_Lisa ) ;
 808: LD_ADDR_EXP 22
 812: PUSH
 813: LD_STRING 09_Lisa
 815: PPUSH
 816: CALL_OW 34
 820: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , mission_prefix_prev ) ;
 821: LD_ADDR_EXP 31
 825: PUSH
 826: LD_STRING Cornel
 828: PPUSH
 829: LD_EXP 1
 833: NOT
 834: PPUSH
 835: LD_EXP 4
 839: PPUSH
 840: CALL 49183 0 3
 844: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , mission_prefix_prev ) ;
 845: LD_ADDR_EXP 23
 849: PUSH
 850: LD_STRING Donaldson
 852: PPUSH
 853: LD_EXP 1
 857: NOT
 858: PPUSH
 859: LD_EXP 4
 863: PPUSH
 864: CALL 49183 0 3
 868: ST_TO_ADDR
// if not Donaldson then
 869: LD_EXP 23
 873: NOT
 874: IFFALSE 889
// Donaldson := CreateCharacter ( 10_Donaldson ) ;
 876: LD_ADDR_EXP 23
 880: PUSH
 881: LD_STRING 10_Donaldson
 883: PPUSH
 884: CALL_OW 34
 888: ST_TO_ADDR
// if not Donaldson then
 889: LD_EXP 23
 893: NOT
 894: IFFALSE 909
// Donaldson := CreateCharacter ( 09_Donaldson ) ;
 896: LD_ADDR_EXP 23
 900: PUSH
 901: LD_STRING 09_Donaldson
 903: PPUSH
 904: CALL_OW 34
 908: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , mission_prefix_prev ) ;
 909: LD_ADDR_EXP 24
 913: PUSH
 914: LD_STRING Bobby
 916: PPUSH
 917: LD_EXP 1
 921: NOT
 922: PPUSH
 923: LD_EXP 4
 927: PPUSH
 928: CALL 49183 0 3
 932: ST_TO_ADDR
// if not Bobby then
 933: LD_EXP 24
 937: NOT
 938: IFFALSE 953
// Bobby := CreateCharacter ( 10_Bobby ) ;
 940: LD_ADDR_EXP 24
 944: PUSH
 945: LD_STRING 10_Bobby
 947: PPUSH
 948: CALL_OW 34
 952: ST_TO_ADDR
// if not Bobby then
 953: LD_EXP 24
 957: NOT
 958: IFFALSE 973
// Bobby := CreateCharacter ( 09_Bobby ) ;
 960: LD_ADDR_EXP 24
 964: PUSH
 965: LD_STRING 09_Bobby
 967: PPUSH
 968: CALL_OW 34
 972: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , mission_prefix_prev ) ;
 973: LD_ADDR_EXP 25
 977: PUSH
 978: LD_STRING Cyrus
 980: PPUSH
 981: LD_EXP 1
 985: NOT
 986: PPUSH
 987: LD_EXP 4
 991: PPUSH
 992: CALL 49183 0 3
 996: ST_TO_ADDR
// if not Cyrus then
 997: LD_EXP 25
1001: NOT
1002: IFFALSE 1017
// Cyrus := CreateCharacter ( 10_Cyrus ) ;
1004: LD_ADDR_EXP 25
1008: PUSH
1009: LD_STRING 10_Cyrus
1011: PPUSH
1012: CALL_OW 34
1016: ST_TO_ADDR
// if not Cyrus then
1017: LD_EXP 25
1021: NOT
1022: IFFALSE 1037
// Cyrus := CreateCharacter ( 09_Cyrus ) ;
1024: LD_ADDR_EXP 25
1028: PUSH
1029: LD_STRING 09_Cyrus
1031: PPUSH
1032: CALL_OW 34
1036: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , mission_prefix_prev ) ;
1037: LD_ADDR_EXP 26
1041: PUSH
1042: LD_STRING Denis
1044: PPUSH
1045: LD_EXP 1
1049: NOT
1050: PPUSH
1051: LD_EXP 4
1055: PPUSH
1056: CALL 49183 0 3
1060: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , mission_prefix_prev ) ;
1061: LD_ADDR_EXP 27
1065: PUSH
1066: LD_STRING Brown
1068: PPUSH
1069: LD_EXP 1
1073: NOT
1074: PPUSH
1075: LD_EXP 4
1079: PPUSH
1080: CALL 49183 0 3
1084: ST_TO_ADDR
// if not Brown then
1085: LD_EXP 27
1089: NOT
1090: IFFALSE 1105
// Brown := CreateCharacter ( 10_Brown ) ;
1092: LD_ADDR_EXP 27
1096: PUSH
1097: LD_STRING 10_Brown
1099: PPUSH
1100: CALL_OW 34
1104: ST_TO_ADDR
// if not Brown then
1105: LD_EXP 27
1109: NOT
1110: IFFALSE 1125
// Brown := CreateCharacter ( 08_Brown ) ;
1112: LD_ADDR_EXP 27
1116: PUSH
1117: LD_STRING 08_Brown
1119: PPUSH
1120: CALL_OW 34
1124: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , mission_prefix_prev ) ;
1125: LD_ADDR_EXP 28
1129: PUSH
1130: LD_STRING Gladstone
1132: PPUSH
1133: LD_EXP 1
1137: NOT
1138: PPUSH
1139: LD_EXP 4
1143: PPUSH
1144: CALL 49183 0 3
1148: ST_TO_ADDR
// if not Gladstone then
1149: LD_EXP 28
1153: NOT
1154: IFFALSE 1169
// Gladstone := CreateCharacter ( 10_Gladstone ) ;
1156: LD_ADDR_EXP 28
1160: PUSH
1161: LD_STRING 10_Gladstone
1163: PPUSH
1164: CALL_OW 34
1168: ST_TO_ADDR
// if not Gladstone then
1169: LD_EXP 28
1173: NOT
1174: IFFALSE 1189
// Gladstone := CreateCharacter ( 08_Gladstone ) ;
1176: LD_ADDR_EXP 28
1180: PUSH
1181: LD_STRING 08_Gladstone
1183: PPUSH
1184: CALL_OW 34
1188: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , mission_prefix_prev ) ;
1189: LD_ADDR_EXP 29
1193: PUSH
1194: LD_STRING Houten
1196: PPUSH
1197: LD_EXP 1
1201: NOT
1202: PPUSH
1203: LD_EXP 4
1207: PPUSH
1208: CALL 49183 0 3
1212: ST_TO_ADDR
// if not Houten then
1213: LD_EXP 29
1217: NOT
1218: IFFALSE 1233
// Houten := CreateCharacter ( 10_Houten ) ;
1220: LD_ADDR_EXP 29
1224: PUSH
1225: LD_STRING 10_Houten
1227: PPUSH
1228: CALL_OW 34
1232: ST_TO_ADDR
// if not Houten then
1233: LD_EXP 29
1237: NOT
1238: IFFALSE 1253
// Houten := CreateCharacter ( 09_Houten ) ;
1240: LD_ADDR_EXP 29
1244: PUSH
1245: LD_STRING 09_Houten
1247: PPUSH
1248: CALL_OW 34
1252: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , ( not debug ) , mission_prefix_prev ) ;
1253: LD_ADDR_EXP 31
1257: PUSH
1258: LD_STRING Cornell
1260: PPUSH
1261: LD_EXP 1
1265: NOT
1266: PPUSH
1267: LD_EXP 4
1271: PPUSH
1272: CALL 49183 0 3
1276: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , mission_prefix_prev ) ;
1277: LD_ADDR_EXP 32
1281: PUSH
1282: LD_STRING Gary
1284: PPUSH
1285: LD_EXP 1
1289: NOT
1290: PPUSH
1291: LD_EXP 4
1295: PPUSH
1296: CALL 49183 0 3
1300: ST_TO_ADDR
// if not Gary then
1301: LD_EXP 32
1305: NOT
1306: IFFALSE 1321
// Gary := CreateCharacter ( 10_Gary ) ;
1308: LD_ADDR_EXP 32
1312: PUSH
1313: LD_STRING 10_Gary
1315: PPUSH
1316: CALL_OW 34
1320: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , mission_prefix_prev ) ;
1321: LD_ADDR_EXP 33
1325: PUSH
1326: LD_STRING Frank
1328: PPUSH
1329: LD_EXP 1
1333: NOT
1334: PPUSH
1335: LD_EXP 4
1339: PPUSH
1340: CALL 49183 0 3
1344: ST_TO_ADDR
// if not Frank then
1345: LD_EXP 33
1349: NOT
1350: IFFALSE 1365
// Frank := CreateCharacter ( 08_Frank ) ;
1352: LD_ADDR_EXP 33
1356: PUSH
1357: LD_STRING 08_Frank
1359: PPUSH
1360: CALL_OW 34
1364: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , mission_prefix_prev ) ;
1365: LD_ADDR_EXP 34
1369: PUSH
1370: LD_STRING Kikuchi
1372: PPUSH
1373: LD_EXP 1
1377: NOT
1378: PPUSH
1379: LD_EXP 4
1383: PPUSH
1384: CALL 49183 0 3
1388: ST_TO_ADDR
// if not Kikuchi then
1389: LD_EXP 34
1393: NOT
1394: IFFALSE 1409
// Kikuchi := CreateCharacter ( 08_Kikuchi ) ;
1396: LD_ADDR_EXP 34
1400: PUSH
1401: LD_STRING 08_Kikuchi
1403: PPUSH
1404: CALL_OW 34
1408: ST_TO_ADDR
// tmp := [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1409: LD_ADDR_VAR 0 5
1413: PUSH
1414: LD_EXP 22
1418: PUSH
1419: LD_EXP 23
1423: PUSH
1424: LD_EXP 24
1428: PUSH
1429: LD_EXP 25
1433: PUSH
1434: LD_EXP 26
1438: PUSH
1439: LD_EXP 27
1443: PUSH
1444: LD_EXP 28
1448: PUSH
1449: LD_EXP 29
1453: PUSH
1454: LD_EXP 31
1458: PUSH
1459: LD_EXP 32
1463: PUSH
1464: LD_EXP 33
1468: PUSH
1469: LD_EXP 34
1473: PUSH
1474: EMPTY
1475: LIST
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: LIST
1481: LIST
1482: LIST
1483: LIST
1484: LIST
1485: LIST
1486: LIST
1487: ST_TO_ADDR
// tmp := tmp diff 0 ;
1488: LD_ADDR_VAR 0 5
1492: PUSH
1493: LD_VAR 0 5
1497: PUSH
1498: LD_INT 0
1500: DIFF
1501: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10_other_survivors ) ;
1502: LD_ADDR_VAR 0 5
1506: PUSH
1507: LD_VAR 0 5
1511: PUSH
1512: LD_STRING 10_other_survivors
1514: PPUSH
1515: CALL_OW 31
1519: UNION
1520: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10_lock ) ;
1521: LD_ADDR_VAR 0 5
1525: PUSH
1526: LD_VAR 0 5
1530: PUSH
1531: LD_STRING 10_lock
1533: PPUSH
1534: CALL_OW 31
1538: UNION
1539: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10c_lock ) ;
1540: LD_ADDR_VAR 0 5
1544: PUSH
1545: LD_VAR 0 5
1549: PUSH
1550: LD_STRING 10c_lock
1552: PPUSH
1553: CALL_OW 31
1557: UNION
1558: ST_TO_ADDR
// DeleteCharacters ( 10_lock ) ;
1559: LD_STRING 10_lock
1561: PPUSH
1562: CALL_OW 40
// DeleteCharacters ( 10c_lock ) ;
1566: LD_STRING 10c_lock
1568: PPUSH
1569: CALL_OW 40
// for i in tmp do
1573: LD_ADDR_VAR 0 2
1577: PUSH
1578: LD_VAR 0 5
1582: PUSH
1583: FOR_IN
1584: IFFALSE 1622
// if GetClass ( i ) in [ class_mortar , class_engineer ] then
1586: LD_VAR 0 2
1590: PPUSH
1591: CALL_OW 257
1595: PUSH
1596: LD_INT 8
1598: PUSH
1599: LD_INT 2
1601: PUSH
1602: EMPTY
1603: LIST
1604: LIST
1605: IN
1606: IFFALSE 1620
// SetClass ( i , class_soldier ) ;
1608: LD_VAR 0 2
1612: PPUSH
1613: LD_INT 1
1615: PPUSH
1616: CALL_OW 336
1620: GO 1583
1622: POP
1623: POP
// if tmp < 12 then
1624: LD_VAR 0 5
1628: PUSH
1629: LD_INT 12
1631: LESS
1632: IFFALSE 1726
// begin k := 16 - tmp ;
1634: LD_ADDR_VAR 0 3
1638: PUSH
1639: LD_INT 16
1641: PUSH
1642: LD_VAR 0 5
1646: MINUS
1647: ST_TO_ADDR
// for i = 1 to k do
1648: LD_ADDR_VAR 0 2
1652: PUSH
1653: DOUBLE
1654: LD_INT 1
1656: DEC
1657: ST_TO_ADDR
1658: LD_VAR 0 3
1662: PUSH
1663: FOR_TO
1664: IFFALSE 1724
// begin PrepareHuman ( false , [ 1 , 1 , 3 , 4 ] [ rand ( 1 , 4 ) ] , 6 ) ;
1666: LD_INT 0
1668: PPUSH
1669: LD_INT 1
1671: PUSH
1672: LD_INT 1
1674: PUSH
1675: LD_INT 3
1677: PUSH
1678: LD_INT 4
1680: PUSH
1681: EMPTY
1682: LIST
1683: LIST
1684: LIST
1685: LIST
1686: PUSH
1687: LD_INT 1
1689: PPUSH
1690: LD_INT 4
1692: PPUSH
1693: CALL_OW 12
1697: ARRAY
1698: PPUSH
1699: LD_INT 6
1701: PPUSH
1702: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
1706: LD_ADDR_VAR 0 5
1710: PUSH
1711: LD_VAR 0 5
1715: PUSH
1716: CALL_OW 44
1720: ADD
1721: ST_TO_ADDR
// end ;
1722: GO 1663
1724: POP
1725: POP
// end ; selected := CharacterSelection ( 1 , 12 , 12 , [ sel_change_class , JMM , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp ^ [ sel_dont_change_class , sel_not_changeable , Powell ] , [ [ class_soldier , 4 ] , [ class_mechanic , 0 , 5 ] , [ class_scientistic , 0 , 3 ] , [ class_sniper , 0 , 2 ] ] ) ;
1726: LD_ADDR_EXP 19
1730: PUSH
1731: LD_STRING 1
1733: PPUSH
1734: LD_INT 12
1736: PPUSH
1737: LD_INT 12
1739: PPUSH
1740: LD_INT -5
1742: PUSH
1743: LD_EXP 21
1747: PUSH
1748: LD_INT -2
1750: PUSH
1751: LD_INT -3
1753: PUSH
1754: LD_INT -5
1756: PUSH
1757: EMPTY
1758: LIST
1759: LIST
1760: LIST
1761: LIST
1762: LIST
1763: PUSH
1764: LD_VAR 0 5
1768: ADD
1769: PUSH
1770: LD_INT -6
1772: PUSH
1773: LD_INT -4
1775: PUSH
1776: LD_EXP 30
1780: PUSH
1781: EMPTY
1782: LIST
1783: LIST
1784: LIST
1785: ADD
1786: PPUSH
1787: LD_INT 1
1789: PUSH
1790: LD_INT 4
1792: PUSH
1793: EMPTY
1794: LIST
1795: LIST
1796: PUSH
1797: LD_INT 3
1799: PUSH
1800: LD_INT 0
1802: PUSH
1803: LD_INT 5
1805: PUSH
1806: EMPTY
1807: LIST
1808: LIST
1809: LIST
1810: PUSH
1811: LD_INT 4
1813: PUSH
1814: LD_INT 0
1816: PUSH
1817: LD_INT 3
1819: PUSH
1820: EMPTY
1821: LIST
1822: LIST
1823: LIST
1824: PUSH
1825: LD_INT 5
1827: PUSH
1828: LD_INT 0
1830: PUSH
1831: LD_INT 2
1833: PUSH
1834: EMPTY
1835: LIST
1836: LIST
1837: LIST
1838: PUSH
1839: EMPTY
1840: LIST
1841: LIST
1842: LIST
1843: LIST
1844: PPUSH
1845: CALL_OW 42
1849: ST_TO_ADDR
// others := tmp diff selected ;
1850: LD_ADDR_VAR 0 8
1854: PUSH
1855: LD_VAR 0 5
1859: PUSH
1860: LD_EXP 19
1864: DIFF
1865: ST_TO_ADDR
// others := others diff [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1866: LD_ADDR_VAR 0 8
1870: PUSH
1871: LD_VAR 0 8
1875: PUSH
1876: LD_EXP 22
1880: PUSH
1881: LD_EXP 23
1885: PUSH
1886: LD_EXP 24
1890: PUSH
1891: LD_EXP 25
1895: PUSH
1896: LD_EXP 26
1900: PUSH
1901: LD_EXP 27
1905: PUSH
1906: LD_EXP 28
1910: PUSH
1911: LD_EXP 29
1915: PUSH
1916: LD_EXP 31
1920: PUSH
1921: LD_EXP 32
1925: PUSH
1926: LD_EXP 33
1930: PUSH
1931: LD_EXP 34
1935: PUSH
1936: EMPTY
1937: LIST
1938: LIST
1939: LIST
1940: LIST
1941: LIST
1942: LIST
1943: LIST
1944: LIST
1945: LIST
1946: LIST
1947: LIST
1948: LIST
1949: DIFF
1950: ST_TO_ADDR
// if others then
1951: LD_VAR 0 8
1955: IFFALSE 1969
// SaveCharacters ( others , 11_others ) ;
1957: LD_VAR 0 8
1961: PPUSH
1962: LD_STRING 11_others
1964: PPUSH
1965: CALL_OW 38
// vehs := [ [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun ] , [ us_medium_wheeled , engine_siberite , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_medium_wheeled , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_siberite , control_manual , us_rocket_launcher ] ] ;
1969: LD_ADDR_VAR 0 6
1973: PUSH
1974: LD_INT 3
1976: PUSH
1977: LD_INT 1
1979: PUSH
1980: LD_INT 1
1982: PUSH
1983: LD_INT 4
1985: PUSH
1986: EMPTY
1987: LIST
1988: LIST
1989: LIST
1990: LIST
1991: PUSH
1992: LD_INT 2
1994: PUSH
1995: LD_INT 3
1997: PUSH
1998: LD_INT 1
2000: PUSH
2001: LD_INT 5
2003: PUSH
2004: EMPTY
2005: LIST
2006: LIST
2007: LIST
2008: LIST
2009: PUSH
2010: LD_INT 4
2012: PUSH
2013: LD_INT 1
2015: PUSH
2016: LD_INT 1
2018: PUSH
2019: LD_INT 5
2021: PUSH
2022: EMPTY
2023: LIST
2024: LIST
2025: LIST
2026: LIST
2027: PUSH
2028: LD_INT 2
2030: PUSH
2031: LD_INT 1
2033: PUSH
2034: LD_INT 1
2036: PUSH
2037: LD_INT 7
2039: PUSH
2040: EMPTY
2041: LIST
2042: LIST
2043: LIST
2044: LIST
2045: PUSH
2046: LD_INT 3
2048: PUSH
2049: LD_INT 3
2051: PUSH
2052: LD_INT 1
2054: PUSH
2055: LD_INT 7
2057: PUSH
2058: EMPTY
2059: LIST
2060: LIST
2061: LIST
2062: LIST
2063: PUSH
2064: EMPTY
2065: LIST
2066: LIST
2067: LIST
2068: LIST
2069: LIST
2070: ST_TO_ADDR
// for i in JMM ^ selected do
2071: LD_ADDR_VAR 0 2
2075: PUSH
2076: LD_EXP 21
2080: PUSH
2081: LD_EXP 19
2085: ADD
2086: PUSH
2087: FOR_IN
2088: IFFALSE 2278
// begin if GetClass ( i ) = 3 then
2090: LD_VAR 0 2
2094: PPUSH
2095: CALL_OW 257
2099: PUSH
2100: LD_INT 3
2102: EQUAL
2103: IFFALSE 2261
// begin vc_chassis := vehs [ 1 ] [ 1 ] ;
2105: LD_ADDR_OWVAR 37
2109: PUSH
2110: LD_VAR 0 6
2114: PUSH
2115: LD_INT 1
2117: ARRAY
2118: PUSH
2119: LD_INT 1
2121: ARRAY
2122: ST_TO_ADDR
// vc_engine := vehs [ 1 ] [ 2 ] ;
2123: LD_ADDR_OWVAR 39
2127: PUSH
2128: LD_VAR 0 6
2132: PUSH
2133: LD_INT 1
2135: ARRAY
2136: PUSH
2137: LD_INT 2
2139: ARRAY
2140: ST_TO_ADDR
// vc_control := vehs [ 1 ] [ 3 ] ;
2141: LD_ADDR_OWVAR 38
2145: PUSH
2146: LD_VAR 0 6
2150: PUSH
2151: LD_INT 1
2153: ARRAY
2154: PUSH
2155: LD_INT 3
2157: ARRAY
2158: ST_TO_ADDR
// vc_weapon := vehs [ 1 ] [ 4 ] ;
2159: LD_ADDR_OWVAR 40
2163: PUSH
2164: LD_VAR 0 6
2168: PUSH
2169: LD_INT 1
2171: ARRAY
2172: PUSH
2173: LD_INT 4
2175: ARRAY
2176: ST_TO_ADDR
// vehs := Delete ( vehs , 1 ) ;
2177: LD_ADDR_VAR 0 6
2181: PUSH
2182: LD_VAR 0 6
2186: PPUSH
2187: LD_INT 1
2189: PPUSH
2190: CALL_OW 3
2194: ST_TO_ADDR
// veh := CreateVehicle ;
2195: LD_ADDR_VAR 0 7
2199: PUSH
2200: CALL_OW 45
2204: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2205: LD_VAR 0 7
2209: PPUSH
2210: LD_INT 8
2212: PPUSH
2213: LD_INT 0
2215: PPUSH
2216: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
2220: LD_VAR 0 2
2224: PPUSH
2225: LD_VAR 0 7
2229: PPUSH
2230: CALL_OW 52
// if i = JMM then
2234: LD_VAR 0 2
2238: PUSH
2239: LD_EXP 21
2243: EQUAL
2244: IFFALSE 2259
// SetMark ( veh , - 1 ) ;
2246: LD_VAR 0 7
2250: PPUSH
2251: LD_INT 1
2253: NEG
2254: PPUSH
2255: CALL_OW 242
// end else
2259: GO 2276
// PlaceUnitArea ( i , am_hum_start , false ) ;
2261: LD_VAR 0 2
2265: PPUSH
2266: LD_INT 9
2268: PPUSH
2269: LD_INT 0
2271: PPUSH
2272: CALL_OW 49
// end ;
2276: GO 2087
2278: POP
2279: POP
// vc_chassis := us_medium_tracked ;
2280: LD_ADDR_OWVAR 37
2284: PUSH
2285: LD_INT 3
2287: ST_TO_ADDR
// vc_engine := engine_solar ;
2288: LD_ADDR_OWVAR 39
2292: PUSH
2293: LD_INT 2
2295: ST_TO_ADDR
// vc_control := control_computer ;
2296: LD_ADDR_OWVAR 38
2300: PUSH
2301: LD_INT 3
2303: ST_TO_ADDR
// vc_weapon := us_radar ;
2304: LD_ADDR_OWVAR 40
2308: PUSH
2309: LD_INT 11
2311: ST_TO_ADDR
// veh := CreateVehicle ;
2312: LD_ADDR_VAR 0 7
2316: PUSH
2317: CALL_OW 45
2321: ST_TO_ADDR
// PlaceUnitXY ( veh , 87 , 142 , false ) ;
2322: LD_VAR 0 7
2326: PPUSH
2327: LD_INT 87
2329: PPUSH
2330: LD_INT 142
2332: PPUSH
2333: LD_INT 0
2335: PPUSH
2336: CALL_OW 48
// end ;
2340: LD_VAR 0 1
2344: RET
// export function AmericanReinforcements ; var i , vehs , veh ; begin
2345: LD_INT 0
2347: PPUSH
2348: PPUSH
2349: PPUSH
2350: PPUSH
// uc_side := 1 ;
2351: LD_ADDR_OWVAR 20
2355: PUSH
2356: LD_INT 1
2358: ST_TO_ADDR
// uc_nation := 1 ;
2359: LD_ADDR_OWVAR 21
2363: PUSH
2364: LD_INT 1
2366: ST_TO_ADDR
// vehs := [ [ us_medium_tracked , engine_combustion , control_computer , us_double_gun ] , [ us_medium_tracked , engine_combustion , control_computer , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_computer , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_computer , us_radar ] , [ us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_computer , us_double_gun ] ] ;
2367: LD_ADDR_VAR 0 3
2371: PUSH
2372: LD_INT 3
2374: PUSH
2375: LD_INT 1
2377: PUSH
2378: LD_INT 3
2380: PUSH
2381: LD_INT 5
2383: PUSH
2384: EMPTY
2385: LIST
2386: LIST
2387: LIST
2388: LIST
2389: PUSH
2390: LD_INT 3
2392: PUSH
2393: LD_INT 1
2395: PUSH
2396: LD_INT 3
2398: PUSH
2399: LD_INT 7
2401: PUSH
2402: EMPTY
2403: LIST
2404: LIST
2405: LIST
2406: LIST
2407: PUSH
2408: LD_INT 3
2410: PUSH
2411: LD_INT 1
2413: PUSH
2414: LD_INT 3
2416: PUSH
2417: LD_INT 7
2419: PUSH
2420: EMPTY
2421: LIST
2422: LIST
2423: LIST
2424: LIST
2425: PUSH
2426: LD_INT 3
2428: PUSH
2429: LD_INT 1
2431: PUSH
2432: LD_INT 3
2434: PUSH
2435: LD_INT 11
2437: PUSH
2438: EMPTY
2439: LIST
2440: LIST
2441: LIST
2442: LIST
2443: PUSH
2444: LD_INT 4
2446: PUSH
2447: LD_INT 1
2449: PUSH
2450: LD_INT 3
2452: PUSH
2453: LD_INT 6
2455: PUSH
2456: EMPTY
2457: LIST
2458: LIST
2459: LIST
2460: LIST
2461: PUSH
2462: LD_INT 4
2464: PUSH
2465: LD_INT 1
2467: PUSH
2468: LD_INT 3
2470: PUSH
2471: LD_INT 5
2473: PUSH
2474: EMPTY
2475: LIST
2476: LIST
2477: LIST
2478: LIST
2479: PUSH
2480: EMPTY
2481: LIST
2482: LIST
2483: LIST
2484: LIST
2485: LIST
2486: LIST
2487: ST_TO_ADDR
// for i := 1 to 7 - Difficulty do
2488: LD_ADDR_VAR 0 2
2492: PUSH
2493: DOUBLE
2494: LD_INT 1
2496: DEC
2497: ST_TO_ADDR
2498: LD_INT 7
2500: PUSH
2501: LD_OWVAR 67
2505: MINUS
2506: PUSH
2507: FOR_TO
2508: IFFALSE 2617
// begin vc_chassis := vehs [ i ] [ 1 ] ;
2510: LD_ADDR_OWVAR 37
2514: PUSH
2515: LD_VAR 0 3
2519: PUSH
2520: LD_VAR 0 2
2524: ARRAY
2525: PUSH
2526: LD_INT 1
2528: ARRAY
2529: ST_TO_ADDR
// vc_engine := vehs [ i ] [ 2 ] ;
2530: LD_ADDR_OWVAR 39
2534: PUSH
2535: LD_VAR 0 3
2539: PUSH
2540: LD_VAR 0 2
2544: ARRAY
2545: PUSH
2546: LD_INT 2
2548: ARRAY
2549: ST_TO_ADDR
// vc_control := vehs [ i ] [ 3 ] ;
2550: LD_ADDR_OWVAR 38
2554: PUSH
2555: LD_VAR 0 3
2559: PUSH
2560: LD_VAR 0 2
2564: ARRAY
2565: PUSH
2566: LD_INT 3
2568: ARRAY
2569: ST_TO_ADDR
// vc_weapon := vehs [ i ] [ 4 ] ;
2570: LD_ADDR_OWVAR 40
2574: PUSH
2575: LD_VAR 0 3
2579: PUSH
2580: LD_VAR 0 2
2584: ARRAY
2585: PUSH
2586: LD_INT 4
2588: ARRAY
2589: ST_TO_ADDR
// veh := CreateVehicle ;
2590: LD_ADDR_VAR 0 4
2594: PUSH
2595: CALL_OW 45
2599: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2600: LD_VAR 0 4
2604: PPUSH
2605: LD_INT 8
2607: PPUSH
2608: LD_INT 0
2610: PPUSH
2611: CALL_OW 49
// end ;
2615: GO 2507
2617: POP
2618: POP
// end ; end_of_file
2619: LD_VAR 0 1
2623: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_north_2 , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_kamikadze , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ; var i , d , un , skill , tmp ; begin
2624: LD_INT 0
2626: PPUSH
2627: PPUSH
2628: PPUSH
2629: PPUSH
2630: PPUSH
2631: PPUSH
// if Difficulty = 1 then
2632: LD_OWVAR 67
2636: PUSH
2637: LD_INT 1
2639: EQUAL
2640: IFFALSE 2737
// begin tmp := [ [ 129 , 45 ] , [ 143 , 58 ] , [ 184 , 113 ] , [ 163 , 107 ] ] ;
2642: LD_ADDR_VAR 0 6
2646: PUSH
2647: LD_INT 129
2649: PUSH
2650: LD_INT 45
2652: PUSH
2653: EMPTY
2654: LIST
2655: LIST
2656: PUSH
2657: LD_INT 143
2659: PUSH
2660: LD_INT 58
2662: PUSH
2663: EMPTY
2664: LIST
2665: LIST
2666: PUSH
2667: LD_INT 184
2669: PUSH
2670: LD_INT 113
2672: PUSH
2673: EMPTY
2674: LIST
2675: LIST
2676: PUSH
2677: LD_INT 163
2679: PUSH
2680: LD_INT 107
2682: PUSH
2683: EMPTY
2684: LIST
2685: LIST
2686: PUSH
2687: EMPTY
2688: LIST
2689: LIST
2690: LIST
2691: LIST
2692: ST_TO_ADDR
// for i in tmp do
2693: LD_ADDR_VAR 0 2
2697: PUSH
2698: LD_VAR 0 6
2702: PUSH
2703: FOR_IN
2704: IFFALSE 2735
// RemoveUnit ( HexInfo ( i [ 1 ] , i [ 2 ] ) ) ;
2706: LD_VAR 0 2
2710: PUSH
2711: LD_INT 1
2713: ARRAY
2714: PPUSH
2715: LD_VAR 0 2
2719: PUSH
2720: LD_INT 2
2722: ARRAY
2723: PPUSH
2724: CALL_OW 428
2728: PPUSH
2729: CALL_OW 64
2733: GO 2703
2735: POP
2736: POP
// end ; for i in FilterAllUnits ( [ f_type , unit_building ] ) do
2737: LD_ADDR_VAR 0 2
2741: PUSH
2742: LD_INT 21
2744: PUSH
2745: LD_INT 3
2747: PUSH
2748: EMPTY
2749: LIST
2750: LIST
2751: PPUSH
2752: CALL_OW 69
2756: PUSH
2757: FOR_IN
2758: IFFALSE 2795
// SetBLevel ( i , [ 5 , 6 , 7 , 8 ] [ Difficulty ] ) ;
2760: LD_VAR 0 2
2764: PPUSH
2765: LD_INT 5
2767: PUSH
2768: LD_INT 6
2770: PUSH
2771: LD_INT 7
2773: PUSH
2774: LD_INT 8
2776: PUSH
2777: EMPTY
2778: LIST
2779: LIST
2780: LIST
2781: LIST
2782: PUSH
2783: LD_OWVAR 67
2787: ARRAY
2788: PPUSH
2789: CALL_OW 241
2793: GO 2757
2795: POP
2796: POP
// skill := [ 5 , 6 , 7 , 8 ] [ Difficulty ] ;
2797: LD_ADDR_VAR 0 5
2801: PUSH
2802: LD_INT 5
2804: PUSH
2805: LD_INT 6
2807: PUSH
2808: LD_INT 7
2810: PUSH
2811: LD_INT 8
2813: PUSH
2814: EMPTY
2815: LIST
2816: LIST
2817: LIST
2818: LIST
2819: PUSH
2820: LD_OWVAR 67
2824: ARRAY
2825: ST_TO_ADDR
// uc_side := 2 ;
2826: LD_ADDR_OWVAR 20
2830: PUSH
2831: LD_INT 2
2833: ST_TO_ADDR
// uc_nation := 2 ;
2834: LD_ADDR_OWVAR 21
2838: PUSH
2839: LD_INT 2
2841: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
2842: LD_ADDR_OWVAR 37
2846: PUSH
2847: LD_INT 14
2849: ST_TO_ADDR
// vc_engine := engine_siberite ;
2850: LD_ADDR_OWVAR 39
2854: PUSH
2855: LD_INT 3
2857: ST_TO_ADDR
// vc_control := control_manual ;
2858: LD_ADDR_OWVAR 38
2862: PUSH
2863: LD_INT 1
2865: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
2866: LD_ADDR_OWVAR 40
2870: PUSH
2871: LD_INT 31
2873: ST_TO_ADDR
// for i = 1 to 3 do
2874: LD_ADDR_VAR 0 2
2878: PUSH
2879: DOUBLE
2880: LD_INT 1
2882: DEC
2883: ST_TO_ADDR
2884: LD_INT 3
2886: PUSH
2887: FOR_TO
2888: IFFALSE 2972
// begin PrepareHuman ( false , class_mechanic , skill ) ;
2890: LD_INT 0
2892: PPUSH
2893: LD_INT 3
2895: PPUSH
2896: LD_VAR 0 5
2900: PPUSH
2901: CALL_OW 380
// un := CreateVehicle ;
2905: LD_ADDR_VAR 0 4
2909: PUSH
2910: CALL_OW 45
2914: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
2915: LD_VAR 0 4
2919: PPUSH
2920: LD_INT 0
2922: PPUSH
2923: LD_INT 5
2925: PPUSH
2926: CALL_OW 12
2930: PPUSH
2931: CALL_OW 233
// PlaceUnitXYR ( un , 156 , 15 , 6 , false ) ;
2935: LD_VAR 0 4
2939: PPUSH
2940: LD_INT 156
2942: PPUSH
2943: LD_INT 15
2945: PPUSH
2946: LD_INT 6
2948: PPUSH
2949: LD_INT 0
2951: PPUSH
2952: CALL_OW 50
// PlaceHumanInUnit ( CreateHuman , un ) ;
2956: CALL_OW 44
2960: PPUSH
2961: LD_VAR 0 4
2965: PPUSH
2966: CALL_OW 52
// end ;
2970: GO 2887
2972: POP
2973: POP
// ar_force_north := PrepareBase ( ar_dep_n , base_north , dammam , skill , [ 10000 , 1000 , 300 ] , [ 12 , [ 2 , 3 , 4 , 4 ] [ Difficulty ] , - 1 , 4 ] ) ;
2974: LD_ADDR_EXP 37
2978: PUSH
2979: LD_INT 94
2981: PPUSH
2982: LD_INT 28
2984: PPUSH
2985: LD_STRING dammam
2987: PPUSH
2988: LD_VAR 0 5
2992: PPUSH
2993: LD_INT 10000
2995: PUSH
2996: LD_INT 1000
2998: PUSH
2999: LD_INT 300
3001: PUSH
3002: EMPTY
3003: LIST
3004: LIST
3005: LIST
3006: PPUSH
3007: LD_INT 12
3009: PUSH
3010: LD_INT 2
3012: PUSH
3013: LD_INT 3
3015: PUSH
3016: LD_INT 4
3018: PUSH
3019: LD_INT 4
3021: PUSH
3022: EMPTY
3023: LIST
3024: LIST
3025: LIST
3026: LIST
3027: PUSH
3028: LD_OWVAR 67
3032: ARRAY
3033: PUSH
3034: LD_INT 1
3036: NEG
3037: PUSH
3038: LD_INT 4
3040: PUSH
3041: EMPTY
3042: LIST
3043: LIST
3044: LIST
3045: LIST
3046: PPUSH
3047: CALL 57844 0 6
3051: ST_TO_ADDR
// ar_force_north := ar_force_north union PrepareBase ( ar_dep_n2 , base_north_2 ,  , skill , [ 500 , 60 , 0 ] , [ 8 , [ 2 , 3 , 4 , 5 ] [ Difficulty ] , 2 , 0 ] ) ;
3052: LD_ADDR_EXP 37
3056: PUSH
3057: LD_EXP 37
3061: PUSH
3062: LD_INT 122
3064: PPUSH
3065: LD_INT 25
3067: PPUSH
3068: LD_STRING 
3070: PPUSH
3071: LD_VAR 0 5
3075: PPUSH
3076: LD_INT 500
3078: PUSH
3079: LD_INT 60
3081: PUSH
3082: LD_INT 0
3084: PUSH
3085: EMPTY
3086: LIST
3087: LIST
3088: LIST
3089: PPUSH
3090: LD_INT 8
3092: PUSH
3093: LD_INT 2
3095: PUSH
3096: LD_INT 3
3098: PUSH
3099: LD_INT 4
3101: PUSH
3102: LD_INT 5
3104: PUSH
3105: EMPTY
3106: LIST
3107: LIST
3108: LIST
3109: LIST
3110: PUSH
3111: LD_OWVAR 67
3115: ARRAY
3116: PUSH
3117: LD_INT 2
3119: PUSH
3120: LD_INT 0
3122: PUSH
3123: EMPTY
3124: LIST
3125: LIST
3126: LIST
3127: LIST
3128: PPUSH
3129: CALL 57844 0 6
3133: UNION
3134: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , base_west , jeddah , skill , [ 700 , 300 , 10 ] , [ 9 , 4 , 3 , 2 ] ) ;
3135: LD_ADDR_EXP 35
3139: PUSH
3140: LD_INT 45
3142: PPUSH
3143: LD_INT 24
3145: PPUSH
3146: LD_STRING jeddah
3148: PPUSH
3149: LD_VAR 0 5
3153: PPUSH
3154: LD_INT 700
3156: PUSH
3157: LD_INT 300
3159: PUSH
3160: LD_INT 10
3162: PUSH
3163: EMPTY
3164: LIST
3165: LIST
3166: LIST
3167: PPUSH
3168: LD_INT 9
3170: PUSH
3171: LD_INT 4
3173: PUSH
3174: LD_INT 3
3176: PUSH
3177: LD_INT 2
3179: PUSH
3180: EMPTY
3181: LIST
3182: LIST
3183: LIST
3184: LIST
3185: PPUSH
3186: CALL 57844 0 6
3190: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , base_south , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
3191: LD_ADDR_EXP 36
3195: PUSH
3196: LD_INT 7
3198: PPUSH
3199: LD_INT 27
3201: PPUSH
3202: LD_STRING riyadh
3204: PPUSH
3205: LD_VAR 0 5
3209: PPUSH
3210: LD_INT 500
3212: PUSH
3213: LD_INT 60
3215: PUSH
3216: LD_INT 0
3218: PUSH
3219: EMPTY
3220: LIST
3221: LIST
3222: LIST
3223: PPUSH
3224: LD_INT 4
3226: PUSH
3227: LD_INT 2
3229: PUSH
3230: LD_INT 3
3232: PUSH
3233: LD_INT 1
3235: PUSH
3236: EMPTY
3237: LIST
3238: LIST
3239: LIST
3240: LIST
3241: PPUSH
3242: CALL 57844 0 6
3246: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e , base_east ,  , skill , [ 500 , 50 , 0 ] , [ 9 , 2 , 3 , 1 ] ) ;
3247: LD_ADDR_EXP 39
3251: PUSH
3252: LD_INT 204
3254: PPUSH
3255: LD_INT 26
3257: PPUSH
3258: LD_STRING 
3260: PPUSH
3261: LD_VAR 0 5
3265: PPUSH
3266: LD_INT 500
3268: PUSH
3269: LD_INT 50
3271: PUSH
3272: LD_INT 0
3274: PUSH
3275: EMPTY
3276: LIST
3277: LIST
3278: LIST
3279: PPUSH
3280: LD_INT 9
3282: PUSH
3283: LD_INT 2
3285: PUSH
3286: LD_INT 3
3288: PUSH
3289: LD_INT 1
3291: PUSH
3292: EMPTY
3293: LIST
3294: LIST
3295: LIST
3296: LIST
3297: PPUSH
3298: CALL 57844 0 6
3302: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east ] ;
3303: LD_ADDR_EXP 50
3307: PUSH
3308: LD_EXP 37
3312: PUSH
3313: LD_EXP 35
3317: PUSH
3318: LD_EXP 39
3322: PUSH
3323: EMPTY
3324: LIST
3325: LIST
3326: LIST
3327: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
3328: LD_ADDR_VAR 0 2
3332: PUSH
3333: LD_INT 22
3335: PUSH
3336: LD_INT 2
3338: PUSH
3339: EMPTY
3340: LIST
3341: LIST
3342: PUSH
3343: LD_INT 30
3345: PUSH
3346: LD_INT 31
3348: PUSH
3349: EMPTY
3350: LIST
3351: LIST
3352: PUSH
3353: LD_INT 58
3355: PUSH
3356: EMPTY
3357: LIST
3358: PUSH
3359: EMPTY
3360: LIST
3361: LIST
3362: LIST
3363: PPUSH
3364: CALL_OW 69
3368: PUSH
3369: FOR_IN
3370: IFFALSE 3495
// begin if GetBase ( i ) then
3372: LD_VAR 0 2
3376: PPUSH
3377: CALL_OW 274
3381: IFFALSE 3385
// continue ;
3383: GO 3369
// d := GetDir ( i ) ;
3385: LD_ADDR_VAR 0 3
3389: PUSH
3390: LD_VAR 0 2
3394: PPUSH
3395: CALL_OW 254
3399: ST_TO_ADDR
// if d < 3 then
3400: LD_VAR 0 3
3404: PUSH
3405: LD_INT 3
3407: LESS
3408: IFFALSE 3426
// d := d + 3 else
3410: LD_ADDR_VAR 0 3
3414: PUSH
3415: LD_VAR 0 3
3419: PUSH
3420: LD_INT 3
3422: PLUS
3423: ST_TO_ADDR
3424: GO 3440
// d := d - 3 ;
3426: LD_ADDR_VAR 0 3
3430: PUSH
3431: LD_VAR 0 3
3435: PUSH
3436: LD_INT 3
3438: MINUS
3439: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
3440: LD_INT 0
3442: PPUSH
3443: LD_INT 8
3445: PPUSH
3446: LD_VAR 0 5
3450: PPUSH
3451: CALL_OW 380
// un := CreateHuman ;
3455: LD_ADDR_VAR 0 4
3459: PUSH
3460: CALL_OW 44
3464: ST_TO_ADDR
// SetDir ( un , d ) ;
3465: LD_VAR 0 4
3469: PPUSH
3470: LD_VAR 0 3
3474: PPUSH
3475: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
3479: LD_VAR 0 4
3483: PPUSH
3484: LD_VAR 0 2
3488: PPUSH
3489: CALL_OW 52
// end ;
3493: GO 3369
3495: POP
3496: POP
// if Difficulty > 1 then
3497: LD_OWVAR 67
3501: PUSH
3502: LD_INT 1
3504: GREATER
3505: IFFALSE 3876
// begin ar_kamikadze := [ ] ;
3507: LD_ADDR_EXP 42
3511: PUSH
3512: EMPTY
3513: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
3514: LD_INT 0
3516: PPUSH
3517: LD_INT 1
3519: PPUSH
3520: LD_VAR 0 5
3524: PPUSH
3525: CALL_OW 380
// un := CreateHuman ;
3529: LD_ADDR_VAR 0 4
3533: PUSH
3534: CALL_OW 44
3538: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3539: LD_VAR 0 4
3543: PPUSH
3544: LD_INT 3
3546: PPUSH
3547: CALL_OW 233
// PlaceUnitXY ( un , 23 , 44 , false ) ;
3551: LD_VAR 0 4
3555: PPUSH
3556: LD_INT 23
3558: PPUSH
3559: LD_INT 44
3561: PPUSH
3562: LD_INT 0
3564: PPUSH
3565: CALL_OW 48
// ComCrawl ( un ) ;
3569: LD_VAR 0 4
3573: PPUSH
3574: CALL_OW 137
// un := CreateHuman ;
3578: LD_ADDR_VAR 0 4
3582: PUSH
3583: CALL_OW 44
3587: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3588: LD_VAR 0 4
3592: PPUSH
3593: LD_INT 3
3595: PPUSH
3596: CALL_OW 233
// PlaceUnitXY ( un , 30 , 39 , false ) ;
3600: LD_VAR 0 4
3604: PPUSH
3605: LD_INT 30
3607: PPUSH
3608: LD_INT 39
3610: PPUSH
3611: LD_INT 0
3613: PPUSH
3614: CALL_OW 48
// ComCrawl ( un ) ;
3618: LD_VAR 0 4
3622: PPUSH
3623: CALL_OW 137
// PrepareHuman ( false , 17 , skill ) ;
3627: LD_INT 0
3629: PPUSH
3630: LD_INT 17
3632: PPUSH
3633: LD_VAR 0 5
3637: PPUSH
3638: CALL_OW 380
// un := CreateHuman ;
3642: LD_ADDR_VAR 0 4
3646: PUSH
3647: CALL_OW 44
3651: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3652: LD_VAR 0 4
3656: PPUSH
3657: LD_INT 3
3659: PPUSH
3660: CALL_OW 233
// PlaceUnitXY ( un , 45 , 86 , false ) ;
3664: LD_VAR 0 4
3668: PPUSH
3669: LD_INT 45
3671: PPUSH
3672: LD_INT 86
3674: PPUSH
3675: LD_INT 0
3677: PPUSH
3678: CALL_OW 48
// ComHold ( un ) ;
3682: LD_VAR 0 4
3686: PPUSH
3687: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3691: LD_ADDR_EXP 42
3695: PUSH
3696: LD_EXP 42
3700: PPUSH
3701: LD_EXP 42
3705: PUSH
3706: LD_INT 1
3708: PLUS
3709: PPUSH
3710: LD_VAR 0 4
3714: PPUSH
3715: CALL_OW 1
3719: ST_TO_ADDR
// un := CreateHuman ;
3720: LD_ADDR_VAR 0 4
3724: PUSH
3725: CALL_OW 44
3729: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3730: LD_VAR 0 4
3734: PPUSH
3735: LD_INT 3
3737: PPUSH
3738: CALL_OW 233
// PlaceUnitXY ( un , 60 , 85 , false ) ;
3742: LD_VAR 0 4
3746: PPUSH
3747: LD_INT 60
3749: PPUSH
3750: LD_INT 85
3752: PPUSH
3753: LD_INT 0
3755: PPUSH
3756: CALL_OW 48
// ComHold ( un ) ;
3760: LD_VAR 0 4
3764: PPUSH
3765: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3769: LD_ADDR_EXP 42
3773: PUSH
3774: LD_EXP 42
3778: PPUSH
3779: LD_EXP 42
3783: PUSH
3784: LD_INT 1
3786: PLUS
3787: PPUSH
3788: LD_VAR 0 4
3792: PPUSH
3793: CALL_OW 1
3797: ST_TO_ADDR
// un := CreateHuman ;
3798: LD_ADDR_VAR 0 4
3802: PUSH
3803: CALL_OW 44
3807: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3808: LD_VAR 0 4
3812: PPUSH
3813: LD_INT 3
3815: PPUSH
3816: CALL_OW 233
// PlaceUnitXY ( un , 222 , 166 , false ) ;
3820: LD_VAR 0 4
3824: PPUSH
3825: LD_INT 222
3827: PPUSH
3828: LD_INT 166
3830: PPUSH
3831: LD_INT 0
3833: PPUSH
3834: CALL_OW 48
// ComHold ( un ) ;
3838: LD_VAR 0 4
3842: PPUSH
3843: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3847: LD_ADDR_EXP 42
3851: PUSH
3852: LD_EXP 42
3856: PPUSH
3857: LD_EXP 42
3861: PUSH
3862: LD_INT 1
3864: PLUS
3865: PPUSH
3866: LD_VAR 0 4
3870: PPUSH
3871: CALL_OW 1
3875: ST_TO_ADDR
// end ; ar_force_tmp := [ ] ;
3876: LD_ADDR_EXP 40
3880: PUSH
3881: EMPTY
3882: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
3883: LD_INT 1
3885: PPUSH
3886: LD_INT 1
3888: PPUSH
3889: LD_VAR 0 5
3893: PPUSH
3894: CALL_OW 380
// hc_name := Pavel Grigorovic ;
3898: LD_ADDR_OWVAR 26
3902: PUSH
3903: LD_STRING Pavel Grigorovic
3905: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3906: LD_ADDR_OWVAR 33
3910: PUSH
3911: LD_STRING SecondCharsGal
3913: ST_TO_ADDR
// hc_face_number := 4 ;
3914: LD_ADDR_OWVAR 34
3918: PUSH
3919: LD_INT 4
3921: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
3922: LD_ADDR_EXP 40
3926: PUSH
3927: LD_EXP 40
3931: PPUSH
3932: LD_INT 1
3934: PPUSH
3935: CALL_OW 44
3939: PPUSH
3940: CALL_OW 1
3944: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3945: LD_INT 2
3947: PPUSH
3948: LD_INT 4
3950: PPUSH
3951: LD_INT 2
3953: PPUSH
3954: CALL_OW 380
// hc_name := Lucy Sebel ;
3958: LD_ADDR_OWVAR 26
3962: PUSH
3963: LD_STRING Lucy Sebel
3965: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3966: LD_ADDR_OWVAR 33
3970: PUSH
3971: LD_STRING SecondCharsGal
3973: ST_TO_ADDR
// hc_face_number := 15 ;
3974: LD_ADDR_OWVAR 34
3978: PUSH
3979: LD_INT 15
3981: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
3982: LD_ADDR_EXP 40
3986: PUSH
3987: LD_EXP 40
3991: PPUSH
3992: LD_INT 2
3994: PPUSH
3995: CALL_OW 44
3999: PPUSH
4000: CALL_OW 1
4004: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
4005: LD_INT 2
4007: PPUSH
4008: LD_INT 4
4010: PPUSH
4011: LD_INT 2
4013: PPUSH
4014: CALL_OW 380
// hc_gallery :=  ;
4018: LD_ADDR_OWVAR 33
4022: PUSH
4023: LD_STRING 
4025: ST_TO_ADDR
// hc_name :=  ;
4026: LD_ADDR_OWVAR 26
4030: PUSH
4031: LD_STRING 
4033: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
4034: LD_ADDR_EXP 40
4038: PUSH
4039: LD_EXP 40
4043: PPUSH
4044: LD_INT 3
4046: PPUSH
4047: CALL_OW 44
4051: PPUSH
4052: CALL_OW 1
4056: ST_TO_ADDR
// hc_sex := sex_male ;
4057: LD_ADDR_OWVAR 27
4061: PUSH
4062: LD_INT 1
4064: ST_TO_ADDR
// hc_class = 11 ;
4065: LD_ADDR_OWVAR 28
4069: PUSH
4070: LD_INT 11
4072: ST_TO_ADDR
// hc_gallery = sandar ;
4073: LD_ADDR_OWVAR 33
4077: PUSH
4078: LD_STRING sandar
4080: ST_TO_ADDR
// hc_face_number = 33 ;
4081: LD_ADDR_OWVAR 34
4085: PUSH
4086: LD_INT 33
4088: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
4089: LD_ADDR_OWVAR 26
4093: PUSH
4094: LD_STRING Thabit Muhair Saliba
4096: ST_TO_ADDR
// hc_skills = [ 0 , 0 , 0 , 0 ] ;
4097: LD_ADDR_OWVAR 31
4101: PUSH
4102: LD_INT 0
4104: PUSH
4105: LD_INT 0
4107: PUSH
4108: LD_INT 0
4110: PUSH
4111: LD_INT 0
4113: PUSH
4114: EMPTY
4115: LIST
4116: LIST
4117: LIST
4118: LIST
4119: ST_TO_ADDR
// Saliba = CreateHuman ;
4120: LD_ADDR_EXP 44
4124: PUSH
4125: CALL_OW 44
4129: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
4130: LD_EXP 44
4134: PPUSH
4135: LD_INT 7
4137: PPUSH
4138: CALL_OW 52
// if gensher_active then
4142: LD_EXP 18
4146: IFFALSE 4173
// begin Gensher = NewCharacter ( Dietrich ) ;
4148: LD_ADDR_EXP 45
4152: PUSH
4153: LD_STRING Dietrich
4155: PPUSH
4156: CALL_OW 25
4160: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
4161: LD_EXP 45
4165: PPUSH
4166: LD_INT 94
4168: PPUSH
4169: CALL_OW 52
// end ; InitHc ;
4173: CALL_OW 19
// ar_vehicles_tmp := [ ] ;
4177: LD_ADDR_EXP 41
4181: PUSH
4182: EMPTY
4183: ST_TO_ADDR
// for i = 1 to 5 do
4184: LD_ADDR_VAR 0 2
4188: PUSH
4189: DOUBLE
4190: LD_INT 1
4192: DEC
4193: ST_TO_ADDR
4194: LD_INT 5
4196: PUSH
4197: FOR_TO
4198: IFFALSE 4370
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , [ engine_combustion , engine_solar ] [ rand ( 1 , 2 ) ] , control_manual , [ ar_gatling_gun , ar_gun , ar_flame_thrower ] [ rand ( 1 , 3 ) ] , rand ( 60 , 100 ) ) ;
4200: LD_INT 13
4202: PUSH
4203: LD_INT 14
4205: PUSH
4206: EMPTY
4207: LIST
4208: LIST
4209: PUSH
4210: LD_INT 1
4212: PPUSH
4213: LD_INT 2
4215: PPUSH
4216: CALL_OW 12
4220: ARRAY
4221: PPUSH
4222: LD_INT 1
4224: PUSH
4225: LD_INT 2
4227: PUSH
4228: EMPTY
4229: LIST
4230: LIST
4231: PUSH
4232: LD_INT 1
4234: PPUSH
4235: LD_INT 2
4237: PPUSH
4238: CALL_OW 12
4242: ARRAY
4243: PPUSH
4244: LD_INT 1
4246: PPUSH
4247: LD_INT 25
4249: PUSH
4250: LD_INT 27
4252: PUSH
4253: LD_INT 26
4255: PUSH
4256: EMPTY
4257: LIST
4258: LIST
4259: LIST
4260: PUSH
4261: LD_INT 1
4263: PPUSH
4264: LD_INT 3
4266: PPUSH
4267: CALL_OW 12
4271: ARRAY
4272: PPUSH
4273: LD_INT 60
4275: PPUSH
4276: LD_INT 100
4278: PPUSH
4279: CALL_OW 12
4283: PPUSH
4284: CALL 54023 0 5
// un := CreateVehicle ;
4288: LD_ADDR_VAR 0 4
4292: PUSH
4293: CALL_OW 45
4297: ST_TO_ADDR
// ar_vehicles_tmp := Replace ( ar_vehicles_tmp , ar_vehicles_tmp + 1 , un ) ;
4298: LD_ADDR_EXP 41
4302: PUSH
4303: LD_EXP 41
4307: PPUSH
4308: LD_EXP 41
4312: PUSH
4313: LD_INT 1
4315: PLUS
4316: PPUSH
4317: LD_VAR 0 4
4321: PPUSH
4322: CALL_OW 1
4326: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4327: LD_VAR 0 4
4331: PPUSH
4332: LD_INT 0
4334: PPUSH
4335: LD_INT 5
4337: PPUSH
4338: CALL_OW 12
4342: PPUSH
4343: CALL_OW 233
// PlaceUnitXYR ( un , 124 , 141 , 8 , false ) ;
4347: LD_VAR 0 4
4351: PPUSH
4352: LD_INT 124
4354: PPUSH
4355: LD_INT 141
4357: PPUSH
4358: LD_INT 8
4360: PPUSH
4361: LD_INT 0
4363: PPUSH
4364: CALL_OW 50
// end ;
4368: GO 4197
4370: POP
4371: POP
// ar_defenders_tmp := [ [ ] , [ ] , [ ] ] ;
4372: LD_ADDR_EXP 43
4376: PUSH
4377: EMPTY
4378: PUSH
4379: EMPTY
4380: PUSH
4381: EMPTY
4382: PUSH
4383: EMPTY
4384: LIST
4385: LIST
4386: LIST
4387: ST_TO_ADDR
// for d = 1 to [ 3 , 3 , 4 , 4 ] [ Difficulty ] do
4388: LD_ADDR_VAR 0 3
4392: PUSH
4393: DOUBLE
4394: LD_INT 1
4396: DEC
4397: ST_TO_ADDR
4398: LD_INT 3
4400: PUSH
4401: LD_INT 3
4403: PUSH
4404: LD_INT 4
4406: PUSH
4407: LD_INT 4
4409: PUSH
4410: EMPTY
4411: LIST
4412: LIST
4413: LIST
4414: LIST
4415: PUSH
4416: LD_OWVAR 67
4420: ARRAY
4421: PUSH
4422: FOR_TO
4423: IFFALSE 4637
// for i = 1 to 3 do
4425: LD_ADDR_VAR 0 2
4429: PUSH
4430: DOUBLE
4431: LD_INT 1
4433: DEC
4434: ST_TO_ADDR
4435: LD_INT 3
4437: PUSH
4438: FOR_TO
4439: IFFALSE 4633
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
4441: LD_INT 14
4443: PPUSH
4444: LD_INT 3
4446: PUSH
4447: LD_INT 2
4449: PUSH
4450: EMPTY
4451: LIST
4452: LIST
4453: PUSH
4454: LD_INT 1
4456: PPUSH
4457: LD_INT 2
4459: PPUSH
4460: CALL_OW 12
4464: ARRAY
4465: PPUSH
4466: LD_INT 1
4468: PUSH
4469: LD_INT 5
4471: PUSH
4472: EMPTY
4473: LIST
4474: LIST
4475: PUSH
4476: LD_INT 1
4478: PPUSH
4479: LD_INT 2
4481: PPUSH
4482: CALL_OW 12
4486: ARRAY
4487: PPUSH
4488: LD_INT 25
4490: PUSH
4491: LD_INT 27
4493: PUSH
4494: LD_INT 26
4496: PUSH
4497: LD_INT 28
4499: PUSH
4500: EMPTY
4501: LIST
4502: LIST
4503: LIST
4504: LIST
4505: PUSH
4506: LD_INT 1
4508: PPUSH
4509: LD_INT 4
4511: PPUSH
4512: CALL_OW 12
4516: ARRAY
4517: PPUSH
4518: LD_INT 100
4520: PPUSH
4521: CALL 54023 0 5
// un := CreateVehicle ;
4525: LD_ADDR_VAR 0 4
4529: PUSH
4530: CALL_OW 45
4534: ST_TO_ADDR
// ar_defenders_tmp := ReplaceIn ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
4535: LD_ADDR_EXP 43
4539: PUSH
4540: LD_EXP 43
4544: PPUSH
4545: LD_VAR 0 2
4549: PUSH
4550: LD_EXP 43
4554: PUSH
4555: LD_VAR 0 2
4559: ARRAY
4560: PUSH
4561: LD_INT 1
4563: PLUS
4564: PUSH
4565: EMPTY
4566: LIST
4567: LIST
4568: PPUSH
4569: LD_VAR 0 4
4573: PPUSH
4574: CALL 54145 0 3
4578: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4579: LD_VAR 0 4
4583: PPUSH
4584: LD_INT 0
4586: PPUSH
4587: LD_INT 5
4589: PPUSH
4590: CALL_OW 12
4594: PPUSH
4595: CALL_OW 233
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east ] [ i ] , false ) ;
4599: LD_VAR 0 4
4603: PPUSH
4604: LD_INT 20
4606: PUSH
4607: LD_INT 21
4609: PUSH
4610: LD_INT 22
4612: PUSH
4613: EMPTY
4614: LIST
4615: LIST
4616: LIST
4617: PUSH
4618: LD_VAR 0 2
4622: ARRAY
4623: PPUSH
4624: LD_INT 0
4626: PPUSH
4627: CALL_OW 49
// end ;
4631: GO 4438
4633: POP
4634: POP
4635: GO 4422
4637: POP
4638: POP
// InitHc ;
4639: CALL_OW 19
// CreateResourcesXY ( mat_artifact , 5 , 10 , 5 , false ) ;
4643: LD_INT 4
4645: PPUSH
4646: LD_INT 5
4648: PPUSH
4649: LD_INT 10
4651: PPUSH
4652: LD_INT 5
4654: PPUSH
4655: LD_INT 0
4657: PPUSH
4658: CALL_OW 58
// end ;
4662: LD_VAR 0 1
4666: RET
// every 0 0$1 trigger ar_kamikadze do var i ;
4667: LD_EXP 42
4671: IFFALSE 4745
4673: GO 4675
4675: DISABLE
4676: LD_INT 0
4678: PPUSH
// begin enable ;
4679: ENABLE
// for i in ar_kamikadze do
4680: LD_ADDR_VAR 0 1
4684: PUSH
4685: LD_EXP 42
4689: PUSH
4690: FOR_IN
4691: IFFALSE 4743
// if See ( 1 , i ) then
4693: LD_INT 1
4695: PPUSH
4696: LD_VAR 0 1
4700: PPUSH
4701: CALL_OW 292
4705: IFFALSE 4741
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
4707: LD_VAR 0 1
4711: PPUSH
4712: LD_INT 81
4714: PUSH
4715: LD_INT 2
4717: PUSH
4718: EMPTY
4719: LIST
4720: LIST
4721: PPUSH
4722: CALL_OW 69
4726: PPUSH
4727: LD_VAR 0 1
4731: PPUSH
4732: CALL_OW 74
4736: PPUSH
4737: CALL_OW 115
4741: GO 4690
4743: POP
4744: POP
// end ;
4745: PPOPN 1
4747: END
// every 5 5$20 trigger artifact_get do var i , cargo , tmp , pos ;
4748: LD_EXP 13
4752: IFFALSE 5069
4754: GO 4756
4756: DISABLE
4757: LD_INT 0
4759: PPUSH
4760: PPUSH
4761: PPUSH
4762: PPUSH
// begin repeat wait ( 0 0$1 ) ;
4763: LD_INT 35
4765: PPUSH
4766: CALL_OW 67
// until MC_GetProduceList ( 1 ) = 0 ;
4770: LD_INT 1
4772: PPUSH
4773: CALL 43105 0 1
4777: PUSH
4778: LD_INT 0
4780: EQUAL
4781: IFFALSE 4763
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
4783: LD_INT 1
4785: PPUSH
4786: LD_INT 14
4788: PUSH
4789: LD_INT 3
4791: PUSH
4792: LD_INT 2
4794: PUSH
4795: LD_INT 32
4797: PUSH
4798: EMPTY
4799: LIST
4800: LIST
4801: LIST
4802: LIST
4803: PUSH
4804: EMPTY
4805: LIST
4806: PPUSH
4807: CALL 42709 0 2
// repeat wait ( 0 0$1 ) ;
4811: LD_INT 35
4813: PPUSH
4814: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) ;
4818: LD_EXP 69
4822: PUSH
4823: LD_INT 1
4825: ARRAY
4826: PPUSH
4827: LD_INT 33
4829: PUSH
4830: LD_INT 2
4832: PUSH
4833: EMPTY
4834: LIST
4835: LIST
4836: PUSH
4837: LD_INT 34
4839: PUSH
4840: LD_INT 32
4842: PUSH
4843: EMPTY
4844: LIST
4845: LIST
4846: PUSH
4847: EMPTY
4848: LIST
4849: LIST
4850: PPUSH
4851: CALL_OW 72
4855: IFFALSE 4811
// cargo := UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) [ 1 ] ;
4857: LD_ADDR_VAR 0 2
4861: PUSH
4862: LD_EXP 69
4866: PUSH
4867: LD_INT 1
4869: ARRAY
4870: PPUSH
4871: LD_INT 33
4873: PUSH
4874: LD_INT 2
4876: PUSH
4877: EMPTY
4878: LIST
4879: LIST
4880: PUSH
4881: LD_INT 34
4883: PUSH
4884: LD_INT 32
4886: PUSH
4887: EMPTY
4888: LIST
4889: LIST
4890: PUSH
4891: EMPTY
4892: LIST
4893: LIST
4894: PPUSH
4895: CALL_OW 72
4899: PUSH
4900: LD_INT 1
4902: ARRAY
4903: ST_TO_ADDR
// pos := FindArtifact ( 5 ) ;
4904: LD_ADDR_VAR 0 4
4908: PUSH
4909: LD_INT 5
4911: PPUSH
4912: CALL_OW 469
4916: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4917: LD_INT 35
4919: PPUSH
4920: CALL_OW 67
// pos := FindArtifact ( 5 ) ;
4924: LD_ADDR_VAR 0 4
4928: PUSH
4929: LD_INT 5
4931: PPUSH
4932: CALL_OW 469
4936: ST_TO_ADDR
// tmp := 100 ;
4937: LD_ADDR_VAR 0 3
4941: PUSH
4942: LD_INT 100
4944: ST_TO_ADDR
// if pos then
4945: LD_VAR 0 4
4949: IFFALSE 4989
// tmp := DangerAtRangeXY ( 2 , pos [ 1 ] , pos [ 2 ] , 20 ) [ 4 ] ;
4951: LD_ADDR_VAR 0 3
4955: PUSH
4956: LD_INT 2
4958: PPUSH
4959: LD_VAR 0 4
4963: PUSH
4964: LD_INT 1
4966: ARRAY
4967: PPUSH
4968: LD_VAR 0 4
4972: PUSH
4973: LD_INT 2
4975: ARRAY
4976: PPUSH
4977: LD_INT 20
4979: PPUSH
4980: CALL 55409 0 4
4984: PUSH
4985: LD_INT 4
4987: ARRAY
4988: ST_TO_ADDR
// until pos and not artifact_oncargo and tmp < 10 ;
4989: LD_VAR 0 4
4993: PUSH
4994: LD_EXP 14
4998: NOT
4999: AND
5000: PUSH
5001: LD_VAR 0 3
5005: PUSH
5006: LD_INT 10
5008: LESS
5009: AND
5010: IFFALSE 4917
// ComGet ( cargo , pos [ 1 ] , pos [ 2 ] ) ;
5012: LD_VAR 0 2
5016: PPUSH
5017: LD_VAR 0 4
5021: PUSH
5022: LD_INT 1
5024: ARRAY
5025: PPUSH
5026: LD_VAR 0 4
5030: PUSH
5031: LD_INT 2
5033: ARRAY
5034: PPUSH
5035: CALL_OW 160
// AddComMoveXY ( cargo , 198 , 113 ) ;
5039: LD_VAR 0 2
5043: PPUSH
5044: LD_INT 198
5046: PPUSH
5047: LD_INT 113
5049: PPUSH
5050: CALL_OW 171
// AddComMoveXY ( cargo , 124 , 7 ) ;
5054: LD_VAR 0 2
5058: PPUSH
5059: LD_INT 124
5061: PPUSH
5062: LD_INT 7
5064: PPUSH
5065: CALL_OW 171
// end ;
5069: PPOPN 4
5071: END
// every 5 5$00 trigger base_captured do var i , un , tmp , skill , coords , flags , list ;
5072: LD_EXP 6
5076: IFFALSE 7039
5078: GO 5080
5080: DISABLE
5081: LD_INT 0
5083: PPUSH
5084: PPUSH
5085: PPUSH
5086: PPUSH
5087: PPUSH
5088: PPUSH
5089: PPUSH
// begin skill := [ 5 , 6 , 7 , 8 ] [ Difficulty ] ;
5090: LD_ADDR_VAR 0 4
5094: PUSH
5095: LD_INT 5
5097: PUSH
5098: LD_INT 6
5100: PUSH
5101: LD_INT 7
5103: PUSH
5104: LD_INT 8
5106: PUSH
5107: EMPTY
5108: LIST
5109: LIST
5110: LIST
5111: LIST
5112: PUSH
5113: LD_OWVAR 67
5117: ARRAY
5118: ST_TO_ADDR
// coords := [ ] ;
5119: LD_ADDR_VAR 0 5
5123: PUSH
5124: EMPTY
5125: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
5126: LD_ADDR_VAR 0 6
5130: PUSH
5131: LD_INT 0
5133: PUSH
5134: LD_INT 0
5136: PUSH
5137: LD_INT 0
5139: PUSH
5140: LD_INT 0
5142: PUSH
5143: LD_INT 1
5145: PUSH
5146: LD_INT 0
5148: PUSH
5149: LD_INT 0
5151: PUSH
5152: LD_INT 0
5154: PUSH
5155: LD_INT 1
5157: PUSH
5158: LD_INT 0
5160: PUSH
5161: EMPTY
5162: LIST
5163: LIST
5164: LIST
5165: LIST
5166: LIST
5167: LIST
5168: LIST
5169: LIST
5170: LIST
5171: LIST
5172: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ) ;
5173: LD_INT 1
5175: PPUSH
5176: LD_INT 14
5178: PUSH
5179: LD_INT 1
5181: PUSH
5182: LD_INT 2
5184: PUSH
5185: LD_INT 28
5187: PUSH
5188: EMPTY
5189: LIST
5190: LIST
5191: LIST
5192: LIST
5193: PUSH
5194: LD_INT 14
5196: PUSH
5197: LD_INT 1
5199: PUSH
5200: LD_INT 2
5202: PUSH
5203: LD_INT 25
5205: PUSH
5206: EMPTY
5207: LIST
5208: LIST
5209: LIST
5210: LIST
5211: PUSH
5212: LD_INT 14
5214: PUSH
5215: LD_INT 1
5217: PUSH
5218: LD_INT 2
5220: PUSH
5221: LD_INT 28
5223: PUSH
5224: EMPTY
5225: LIST
5226: LIST
5227: LIST
5228: LIST
5229: PUSH
5230: LD_INT 14
5232: PUSH
5233: LD_INT 1
5235: PUSH
5236: LD_INT 2
5238: PUSH
5239: LD_INT 29
5241: PUSH
5242: EMPTY
5243: LIST
5244: LIST
5245: LIST
5246: LIST
5247: PUSH
5248: EMPTY
5249: LIST
5250: LIST
5251: LIST
5252: LIST
5253: PPUSH
5254: CALL 42709 0 2
// wait ( [ 10 10$00 , 9 9$30 , 9 9$00 , 8 8$40 ] [ Difficulty ] ) ;
5258: LD_INT 21000
5260: PUSH
5261: LD_INT 19950
5263: PUSH
5264: LD_INT 18900
5266: PUSH
5267: LD_INT 18200
5269: PUSH
5270: EMPTY
5271: LIST
5272: LIST
5273: LIST
5274: LIST
5275: PUSH
5276: LD_OWVAR 67
5280: ARRAY
5281: PPUSH
5282: CALL_OW 67
// InitHc ;
5286: CALL_OW 19
// InitUc ;
5290: CALL_OW 18
// uc_side := 2 ;
5294: LD_ADDR_OWVAR 20
5298: PUSH
5299: LD_INT 2
5301: ST_TO_ADDR
// uc_nation := 2 ;
5302: LD_ADDR_OWVAR 21
5306: PUSH
5307: LD_INT 2
5309: ST_TO_ADDR
// tmp := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
5310: LD_ADDR_VAR 0 3
5314: PUSH
5315: EMPTY
5316: PUSH
5317: EMPTY
5318: PUSH
5319: EMPTY
5320: PUSH
5321: EMPTY
5322: PUSH
5323: EMPTY
5324: PUSH
5325: EMPTY
5326: LIST
5327: LIST
5328: LIST
5329: LIST
5330: LIST
5331: ST_TO_ADDR
// tmp := Replace ( tmp , 1 , mc_vehicles [ 1 ] diff FilterAllUnits ( [ f_or , [ f_weapon , ar_crane ] , [ f_weapon , ar_cargo_bay ] ] ) ) ;
5332: LD_ADDR_VAR 0 3
5336: PUSH
5337: LD_VAR 0 3
5341: PPUSH
5342: LD_INT 1
5344: PPUSH
5345: LD_EXP 69
5349: PUSH
5350: LD_INT 1
5352: ARRAY
5353: PUSH
5354: LD_INT 2
5356: PUSH
5357: LD_INT 34
5359: PUSH
5360: LD_INT 88
5362: PUSH
5363: EMPTY
5364: LIST
5365: LIST
5366: PUSH
5367: LD_INT 34
5369: PUSH
5370: LD_INT 32
5372: PUSH
5373: EMPTY
5374: LIST
5375: LIST
5376: PUSH
5377: EMPTY
5378: LIST
5379: LIST
5380: LIST
5381: PPUSH
5382: CALL_OW 69
5386: DIFF
5387: PPUSH
5388: CALL_OW 1
5392: ST_TO_ADDR
// for i = 1 to Difficulty do
5393: LD_ADDR_VAR 0 1
5397: PUSH
5398: DOUBLE
5399: LD_INT 1
5401: DEC
5402: ST_TO_ADDR
5403: LD_OWVAR 67
5407: PUSH
5408: FOR_TO
5409: IFFALSE 5547
// begin uc_side := 2 ;
5411: LD_ADDR_OWVAR 20
5415: PUSH
5416: LD_INT 2
5418: ST_TO_ADDR
// uc_nation := 2 ;
5419: LD_ADDR_OWVAR 21
5423: PUSH
5424: LD_INT 2
5426: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
5427: LD_INT 13
5429: PPUSH
5430: LD_INT 3
5432: PPUSH
5433: LD_INT 5
5435: PPUSH
5436: LD_INT 29
5438: PPUSH
5439: LD_INT 100
5441: PPUSH
5442: CALL 54023 0 5
// un := CreateVehicle ;
5446: LD_ADDR_VAR 0 2
5450: PUSH
5451: CALL_OW 45
5455: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 1 , tmp [ 1 ] + 1 ] , un ) ;
5456: LD_ADDR_VAR 0 3
5460: PUSH
5461: LD_VAR 0 3
5465: PPUSH
5466: LD_INT 1
5468: PUSH
5469: LD_VAR 0 3
5473: PUSH
5474: LD_INT 1
5476: ARRAY
5477: PUSH
5478: LD_INT 1
5480: PLUS
5481: PUSH
5482: EMPTY
5483: LIST
5484: LIST
5485: PPUSH
5486: LD_VAR 0 2
5490: PPUSH
5491: CALL 54145 0 3
5495: ST_TO_ADDR
// SetDir ( un , 3 ) ;
5496: LD_VAR 0 2
5500: PPUSH
5501: LD_INT 3
5503: PPUSH
5504: CALL_OW 233
// PlaceUnitArea ( un , north_attack_spawn , false ) ;
5508: LD_VAR 0 2
5512: PPUSH
5513: LD_INT 16
5515: PPUSH
5516: LD_INT 0
5518: PPUSH
5519: CALL_OW 49
// ComMoveXY ( un , 51 , 10 ) ;
5523: LD_VAR 0 2
5527: PPUSH
5528: LD_INT 51
5530: PPUSH
5531: LD_INT 10
5533: PPUSH
5534: CALL_OW 111
// wait ( 0 0$2 ) ;
5538: LD_INT 70
5540: PPUSH
5541: CALL_OW 67
// end ;
5545: GO 5408
5547: POP
5548: POP
// coords := [ [ 51 , 24 ] , [ 75 , 90 ] ] ;
5549: LD_ADDR_VAR 0 5
5553: PUSH
5554: LD_INT 51
5556: PUSH
5557: LD_INT 24
5559: PUSH
5560: EMPTY
5561: LIST
5562: LIST
5563: PUSH
5564: LD_INT 75
5566: PUSH
5567: LD_INT 90
5569: PUSH
5570: EMPTY
5571: LIST
5572: LIST
5573: PUSH
5574: EMPTY
5575: LIST
5576: LIST
5577: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 1 ] , coords , flags ) ;
5578: LD_INT 1
5580: PPUSH
5581: LD_VAR 0 3
5585: PUSH
5586: LD_INT 1
5588: ARRAY
5589: PPUSH
5590: LD_VAR 0 5
5594: PPUSH
5595: LD_VAR 0 6
5599: PPUSH
5600: CALL 42942 0 4
// for i = 1 to [ 1 , 3 , 4 , 5 ] [ Difficulty ] do
5604: LD_ADDR_VAR 0 1
5608: PUSH
5609: DOUBLE
5610: LD_INT 1
5612: DEC
5613: ST_TO_ADDR
5614: LD_INT 1
5616: PUSH
5617: LD_INT 3
5619: PUSH
5620: LD_INT 4
5622: PUSH
5623: LD_INT 5
5625: PUSH
5626: EMPTY
5627: LIST
5628: LIST
5629: LIST
5630: LIST
5631: PUSH
5632: LD_OWVAR 67
5636: ARRAY
5637: PUSH
5638: FOR_TO
5639: IFFALSE 5739
// begin uc_side := 2 ;
5641: LD_ADDR_OWVAR 20
5645: PUSH
5646: LD_INT 2
5648: ST_TO_ADDR
// uc_nation := 2 ;
5649: LD_ADDR_OWVAR 21
5653: PUSH
5654: LD_INT 2
5656: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5657: LD_INT 0
5659: PPUSH
5660: LD_INT 17
5662: PPUSH
5663: LD_VAR 0 4
5667: PPUSH
5668: CALL_OW 380
// un := CreateHuman ;
5672: LD_ADDR_VAR 0 2
5676: PUSH
5677: CALL_OW 44
5681: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5682: LD_ADDR_VAR 0 3
5686: PUSH
5687: LD_VAR 0 3
5691: PPUSH
5692: LD_INT 2
5694: PUSH
5695: LD_VAR 0 3
5699: PUSH
5700: LD_INT 2
5702: ARRAY
5703: PUSH
5704: LD_INT 1
5706: PLUS
5707: PUSH
5708: EMPTY
5709: LIST
5710: LIST
5711: PPUSH
5712: LD_VAR 0 2
5716: PPUSH
5717: CALL 54145 0 3
5721: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5722: LD_VAR 0 2
5726: PPUSH
5727: LD_INT 13
5729: PPUSH
5730: LD_INT 0
5732: PPUSH
5733: CALL_OW 49
// end ;
5737: GO 5638
5739: POP
5740: POP
// for i = 1 to [ 3 , 4 , 5 , 6 ] [ Difficulty ] do
5741: LD_ADDR_VAR 0 1
5745: PUSH
5746: DOUBLE
5747: LD_INT 1
5749: DEC
5750: ST_TO_ADDR
5751: LD_INT 3
5753: PUSH
5754: LD_INT 4
5756: PUSH
5757: LD_INT 5
5759: PUSH
5760: LD_INT 6
5762: PUSH
5763: EMPTY
5764: LIST
5765: LIST
5766: LIST
5767: LIST
5768: PUSH
5769: LD_OWVAR 67
5773: ARRAY
5774: PUSH
5775: FOR_TO
5776: IFFALSE 5897
// begin uc_side := 2 ;
5778: LD_ADDR_OWVAR 20
5782: PUSH
5783: LD_INT 2
5785: ST_TO_ADDR
// uc_nation := 2 ;
5786: LD_ADDR_OWVAR 21
5790: PUSH
5791: LD_INT 2
5793: ST_TO_ADDR
// PrepareHuman ( false , [ 1 , 8 ] [ i mod 2 + 1 ] , skill ) ;
5794: LD_INT 0
5796: PPUSH
5797: LD_INT 1
5799: PUSH
5800: LD_INT 8
5802: PUSH
5803: EMPTY
5804: LIST
5805: LIST
5806: PUSH
5807: LD_VAR 0 1
5811: PUSH
5812: LD_INT 2
5814: MOD
5815: PUSH
5816: LD_INT 1
5818: PLUS
5819: ARRAY
5820: PPUSH
5821: LD_VAR 0 4
5825: PPUSH
5826: CALL_OW 380
// un := CreateHuman ;
5830: LD_ADDR_VAR 0 2
5834: PUSH
5835: CALL_OW 44
5839: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5840: LD_ADDR_VAR 0 3
5844: PUSH
5845: LD_VAR 0 3
5849: PPUSH
5850: LD_INT 2
5852: PUSH
5853: LD_VAR 0 3
5857: PUSH
5858: LD_INT 2
5860: ARRAY
5861: PUSH
5862: LD_INT 1
5864: PLUS
5865: PUSH
5866: EMPTY
5867: LIST
5868: LIST
5869: PPUSH
5870: LD_VAR 0 2
5874: PPUSH
5875: CALL 54145 0 3
5879: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5880: LD_VAR 0 2
5884: PPUSH
5885: LD_INT 13
5887: PPUSH
5888: LD_INT 0
5890: PPUSH
5891: CALL_OW 49
// end ;
5895: GO 5775
5897: POP
5898: POP
// coords := [ [ 67 , 112 ] , [ 85 , 130 ] ] ;
5899: LD_ADDR_VAR 0 5
5903: PUSH
5904: LD_INT 67
5906: PUSH
5907: LD_INT 112
5909: PUSH
5910: EMPTY
5911: LIST
5912: LIST
5913: PUSH
5914: LD_INT 85
5916: PUSH
5917: LD_INT 130
5919: PUSH
5920: EMPTY
5921: LIST
5922: LIST
5923: PUSH
5924: EMPTY
5925: LIST
5926: LIST
5927: ST_TO_ADDR
// MC_PrepareAttack ( 2 , tmp [ 2 ] , coords , flags ) ;
5928: LD_INT 2
5930: PPUSH
5931: LD_VAR 0 3
5935: PUSH
5936: LD_INT 2
5938: ARRAY
5939: PPUSH
5940: LD_VAR 0 5
5944: PPUSH
5945: LD_VAR 0 6
5949: PPUSH
5950: CALL 42942 0 4
// for i = 1 to [ 1 , 2 , 3 , 5 ] [ Difficulty ] do
5954: LD_ADDR_VAR 0 1
5958: PUSH
5959: DOUBLE
5960: LD_INT 1
5962: DEC
5963: ST_TO_ADDR
5964: LD_INT 1
5966: PUSH
5967: LD_INT 2
5969: PUSH
5970: LD_INT 3
5972: PUSH
5973: LD_INT 5
5975: PUSH
5976: EMPTY
5977: LIST
5978: LIST
5979: LIST
5980: LIST
5981: PUSH
5982: LD_OWVAR 67
5986: ARRAY
5987: PUSH
5988: FOR_TO
5989: IFFALSE 6089
// begin uc_side := 2 ;
5991: LD_ADDR_OWVAR 20
5995: PUSH
5996: LD_INT 2
5998: ST_TO_ADDR
// uc_nation := 2 ;
5999: LD_ADDR_OWVAR 21
6003: PUSH
6004: LD_INT 2
6006: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
6007: LD_INT 0
6009: PPUSH
6010: LD_INT 17
6012: PPUSH
6013: LD_VAR 0 4
6017: PPUSH
6018: CALL_OW 380
// un := CreateHuman ;
6022: LD_ADDR_VAR 0 2
6026: PUSH
6027: CALL_OW 44
6031: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 3 , tmp [ 3 ] + 1 ] , un ) ;
6032: LD_ADDR_VAR 0 3
6036: PUSH
6037: LD_VAR 0 3
6041: PPUSH
6042: LD_INT 3
6044: PUSH
6045: LD_VAR 0 3
6049: PUSH
6050: LD_INT 3
6052: ARRAY
6053: PUSH
6054: LD_INT 1
6056: PLUS
6057: PUSH
6058: EMPTY
6059: LIST
6060: LIST
6061: PPUSH
6062: LD_VAR 0 2
6066: PPUSH
6067: CALL 54145 0 3
6071: ST_TO_ADDR
// PlaceUnitArea ( un , south_attack_spawn , false ) ;
6072: LD_VAR 0 2
6076: PPUSH
6077: LD_INT 14
6079: PPUSH
6080: LD_INT 0
6082: PPUSH
6083: CALL_OW 49
// end ;
6087: GO 5988
6089: POP
6090: POP
// coords := [ [ 148 , 158 ] , [ 148 , 158 ] ] ;
6091: LD_ADDR_VAR 0 5
6095: PUSH
6096: LD_INT 148
6098: PUSH
6099: LD_INT 158
6101: PUSH
6102: EMPTY
6103: LIST
6104: LIST
6105: PUSH
6106: LD_INT 148
6108: PUSH
6109: LD_INT 158
6111: PUSH
6112: EMPTY
6113: LIST
6114: LIST
6115: PUSH
6116: EMPTY
6117: LIST
6118: LIST
6119: ST_TO_ADDR
// MC_PrepareAttack ( 3 , tmp [ 3 ] , coords , flags ) ;
6120: LD_INT 3
6122: PPUSH
6123: LD_VAR 0 3
6127: PUSH
6128: LD_INT 3
6130: ARRAY
6131: PPUSH
6132: LD_VAR 0 5
6136: PPUSH
6137: LD_VAR 0 6
6141: PPUSH
6142: CALL 42942 0 4
// for i = 1 to [ 2 , 3 , 4 , 5 ] [ Difficulty ] do
6146: LD_ADDR_VAR 0 1
6150: PUSH
6151: DOUBLE
6152: LD_INT 1
6154: DEC
6155: ST_TO_ADDR
6156: LD_INT 2
6158: PUSH
6159: LD_INT 3
6161: PUSH
6162: LD_INT 4
6164: PUSH
6165: LD_INT 5
6167: PUSH
6168: EMPTY
6169: LIST
6170: LIST
6171: LIST
6172: LIST
6173: PUSH
6174: LD_OWVAR 67
6178: ARRAY
6179: PUSH
6180: FOR_TO
6181: IFFALSE 6405
// begin uc_side := 2 ;
6183: LD_ADDR_OWVAR 20
6187: PUSH
6188: LD_INT 2
6190: ST_TO_ADDR
// uc_nation := 2 ;
6191: LD_ADDR_OWVAR 21
6195: PUSH
6196: LD_INT 2
6198: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 3 ) ] , 100 ) ;
6199: LD_INT 14
6201: PPUSH
6202: LD_INT 3
6204: PPUSH
6205: LD_INT 1
6207: PUSH
6208: LD_INT 5
6210: PUSH
6211: EMPTY
6212: LIST
6213: LIST
6214: PUSH
6215: LD_INT 1
6217: PPUSH
6218: LD_INT 2
6220: PPUSH
6221: CALL_OW 12
6225: ARRAY
6226: PPUSH
6227: LD_INT 27
6229: PUSH
6230: LD_INT 26
6232: PUSH
6233: LD_INT 28
6235: PUSH
6236: EMPTY
6237: LIST
6238: LIST
6239: LIST
6240: PUSH
6241: LD_INT 1
6243: PPUSH
6244: LD_INT 3
6246: PPUSH
6247: CALL_OW 12
6251: ARRAY
6252: PPUSH
6253: LD_INT 100
6255: PPUSH
6256: CALL 54023 0 5
// un := CreateVehicle ;
6260: LD_ADDR_VAR 0 2
6264: PUSH
6265: CALL_OW 45
6269: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , un ) ;
6270: LD_ADDR_VAR 0 3
6274: PUSH
6275: LD_VAR 0 3
6279: PPUSH
6280: LD_INT 4
6282: PUSH
6283: LD_VAR 0 3
6287: PUSH
6288: LD_INT 4
6290: ARRAY
6291: PUSH
6292: LD_INT 1
6294: PLUS
6295: PUSH
6296: EMPTY
6297: LIST
6298: LIST
6299: PPUSH
6300: LD_VAR 0 2
6304: PPUSH
6305: CALL 54145 0 3
6309: ST_TO_ADDR
// SetDir ( un , 5 ) ;
6310: LD_VAR 0 2
6314: PPUSH
6315: LD_INT 5
6317: PPUSH
6318: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
6322: LD_VAR 0 2
6326: PPUSH
6327: LD_INT 15
6329: PPUSH
6330: LD_INT 0
6332: PPUSH
6333: CALL_OW 49
// if GetControl ( un ) = control_manual then
6337: LD_VAR 0 2
6341: PPUSH
6342: CALL_OW 263
6346: PUSH
6347: LD_INT 1
6349: EQUAL
6350: IFFALSE 6381
// begin PrepareHuman ( false , 3 , skill ) ;
6352: LD_INT 0
6354: PPUSH
6355: LD_INT 3
6357: PPUSH
6358: LD_VAR 0 4
6362: PPUSH
6363: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
6367: CALL_OW 44
6371: PPUSH
6372: LD_VAR 0 2
6376: PPUSH
6377: CALL_OW 52
// end ; ComMoveXY ( un , 179 , 135 ) ;
6381: LD_VAR 0 2
6385: PPUSH
6386: LD_INT 179
6388: PPUSH
6389: LD_INT 135
6391: PPUSH
6392: CALL_OW 111
// wait ( 0 0$2 ) ;
6396: LD_INT 70
6398: PPUSH
6399: CALL_OW 67
// end ;
6403: GO 6180
6405: POP
6406: POP
// vc_chassis := 15 ;
6407: LD_ADDR_OWVAR 37
6411: PUSH
6412: LD_INT 15
6414: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateVehicle ) ;
6415: LD_ADDR_VAR 0 3
6419: PUSH
6420: LD_VAR 0 3
6424: PPUSH
6425: LD_INT 4
6427: PUSH
6428: LD_VAR 0 3
6432: PUSH
6433: LD_INT 4
6435: ARRAY
6436: PUSH
6437: LD_INT 1
6439: PLUS
6440: PUSH
6441: EMPTY
6442: LIST
6443: LIST
6444: PPUSH
6445: CALL_OW 45
6449: PPUSH
6450: CALL 54145 0 3
6454: ST_TO_ADDR
// PlaceUnitArea ( tmp [ 4 ] [ tmp [ 4 ] ] , east_attack_spawn , false ) ;
6455: LD_VAR 0 3
6459: PUSH
6460: LD_INT 4
6462: ARRAY
6463: PUSH
6464: LD_VAR 0 3
6468: PUSH
6469: LD_INT 4
6471: ARRAY
6472: ARRAY
6473: PPUSH
6474: LD_INT 15
6476: PPUSH
6477: LD_INT 0
6479: PPUSH
6480: CALL_OW 49
// PrepareHuman ( false , class_desert_warior , skill ) ;
6484: LD_INT 0
6486: PPUSH
6487: LD_INT 11
6489: PPUSH
6490: LD_VAR 0 4
6494: PPUSH
6495: CALL_OW 380
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateHuman ) ;
6499: LD_ADDR_VAR 0 3
6503: PUSH
6504: LD_VAR 0 3
6508: PPUSH
6509: LD_INT 4
6511: PUSH
6512: LD_VAR 0 3
6516: PUSH
6517: LD_INT 4
6519: ARRAY
6520: PUSH
6521: LD_INT 1
6523: PLUS
6524: PUSH
6525: EMPTY
6526: LIST
6527: LIST
6528: PPUSH
6529: CALL_OW 44
6533: PPUSH
6534: CALL 54145 0 3
6538: ST_TO_ADDR
// PlaceHumanInUnit ( tmp [ 4 ] [ tmp [ 4 ] ] , tmp [ 4 ] [ tmp [ 4 ] - 1 ] ) ;
6539: LD_VAR 0 3
6543: PUSH
6544: LD_INT 4
6546: ARRAY
6547: PUSH
6548: LD_VAR 0 3
6552: PUSH
6553: LD_INT 4
6555: ARRAY
6556: ARRAY
6557: PPUSH
6558: LD_VAR 0 3
6562: PUSH
6563: LD_INT 4
6565: ARRAY
6566: PUSH
6567: LD_VAR 0 3
6571: PUSH
6572: LD_INT 4
6574: ARRAY
6575: PUSH
6576: LD_INT 1
6578: MINUS
6579: ARRAY
6580: PPUSH
6581: CALL_OW 52
// coords := [ [ 148 , 140 ] ] ;
6585: LD_ADDR_VAR 0 5
6589: PUSH
6590: LD_INT 148
6592: PUSH
6593: LD_INT 140
6595: PUSH
6596: EMPTY
6597: LIST
6598: LIST
6599: PUSH
6600: EMPTY
6601: LIST
6602: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 4 ] , coords , flags ) ;
6603: LD_INT 1
6605: PPUSH
6606: LD_VAR 0 3
6610: PUSH
6611: LD_INT 4
6613: ARRAY
6614: PPUSH
6615: LD_VAR 0 5
6619: PPUSH
6620: LD_VAR 0 6
6624: PPUSH
6625: CALL 42942 0 4
// if gensher_active then
6629: LD_EXP 18
6633: IFFALSE 7039
// begin SayRadio ( Gensher , D10-Diet-1 ) ;
6635: LD_EXP 45
6639: PPUSH
6640: LD_STRING D10-Diet-1
6642: PPUSH
6643: CALL_OW 94
// for i = 1 to 2 do
6647: LD_ADDR_VAR 0 1
6651: PUSH
6652: DOUBLE
6653: LD_INT 1
6655: DEC
6656: ST_TO_ADDR
6657: LD_INT 2
6659: PUSH
6660: FOR_TO
6661: IFFALSE 6799
// begin uc_side := 2 ;
6663: LD_ADDR_OWVAR 20
6667: PUSH
6668: LD_INT 2
6670: ST_TO_ADDR
// uc_nation := 2 ;
6671: LD_ADDR_OWVAR 21
6675: PUSH
6676: LD_INT 2
6678: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
6679: LD_INT 13
6681: PPUSH
6682: LD_INT 3
6684: PPUSH
6685: LD_INT 5
6687: PPUSH
6688: LD_INT 29
6690: PPUSH
6691: LD_INT 100
6693: PPUSH
6694: CALL 54023 0 5
// un := CreateVehicle ;
6698: LD_ADDR_VAR 0 2
6702: PUSH
6703: CALL_OW 45
6707: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6708: LD_ADDR_VAR 0 3
6712: PUSH
6713: LD_VAR 0 3
6717: PPUSH
6718: LD_INT 5
6720: PUSH
6721: LD_VAR 0 3
6725: PUSH
6726: LD_INT 5
6728: ARRAY
6729: PUSH
6730: LD_INT 1
6732: PLUS
6733: PUSH
6734: EMPTY
6735: LIST
6736: LIST
6737: PPUSH
6738: LD_VAR 0 2
6742: PPUSH
6743: CALL 54145 0 3
6747: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6748: LD_VAR 0 2
6752: PPUSH
6753: LD_INT 0
6755: PPUSH
6756: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6760: LD_VAR 0 2
6764: PPUSH
6765: LD_INT 23
6767: PPUSH
6768: LD_INT 0
6770: PPUSH
6771: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6775: LD_VAR 0 2
6779: PPUSH
6780: LD_INT 85
6782: PPUSH
6783: LD_INT 152
6785: PPUSH
6786: CALL_OW 111
// wait ( 0 0$2 ) ;
6790: LD_INT 70
6792: PPUSH
6793: CALL_OW 67
// end ;
6797: GO 6660
6799: POP
6800: POP
// for i = 1 to [ 2 , 3 , 3 , 4 ] [ Difficulty ] do
6801: LD_ADDR_VAR 0 1
6805: PUSH
6806: DOUBLE
6807: LD_INT 1
6809: DEC
6810: ST_TO_ADDR
6811: LD_INT 2
6813: PUSH
6814: LD_INT 3
6816: PUSH
6817: LD_INT 3
6819: PUSH
6820: LD_INT 4
6822: PUSH
6823: EMPTY
6824: LIST
6825: LIST
6826: LIST
6827: LIST
6828: PUSH
6829: LD_OWVAR 67
6833: ARRAY
6834: PUSH
6835: FOR_TO
6836: IFFALSE 6993
// begin uc_side := 2 ;
6838: LD_ADDR_OWVAR 20
6842: PUSH
6843: LD_INT 2
6845: ST_TO_ADDR
// uc_nation := 2 ;
6846: LD_ADDR_OWVAR 21
6850: PUSH
6851: LD_INT 2
6853: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
6854: LD_INT 14
6856: PPUSH
6857: LD_INT 3
6859: PPUSH
6860: LD_INT 5
6862: PPUSH
6863: LD_INT 27
6865: PUSH
6866: LD_INT 28
6868: PUSH
6869: EMPTY
6870: LIST
6871: LIST
6872: PUSH
6873: LD_INT 1
6875: PPUSH
6876: LD_INT 2
6878: PPUSH
6879: CALL_OW 12
6883: ARRAY
6884: PPUSH
6885: LD_INT 100
6887: PPUSH
6888: CALL 54023 0 5
// un := CreateVehicle ;
6892: LD_ADDR_VAR 0 2
6896: PUSH
6897: CALL_OW 45
6901: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6902: LD_ADDR_VAR 0 3
6906: PUSH
6907: LD_VAR 0 3
6911: PPUSH
6912: LD_INT 5
6914: PUSH
6915: LD_VAR 0 3
6919: PUSH
6920: LD_INT 5
6922: ARRAY
6923: PUSH
6924: LD_INT 1
6926: PLUS
6927: PUSH
6928: EMPTY
6929: LIST
6930: LIST
6931: PPUSH
6932: LD_VAR 0 2
6936: PPUSH
6937: CALL 54145 0 3
6941: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6942: LD_VAR 0 2
6946: PPUSH
6947: LD_INT 0
6949: PPUSH
6950: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6954: LD_VAR 0 2
6958: PPUSH
6959: LD_INT 23
6961: PPUSH
6962: LD_INT 0
6964: PPUSH
6965: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6969: LD_VAR 0 2
6973: PPUSH
6974: LD_INT 85
6976: PPUSH
6977: LD_INT 152
6979: PPUSH
6980: CALL_OW 111
// wait ( 0 0$2 ) ;
6984: LD_INT 70
6986: PPUSH
6987: CALL_OW 67
// end ;
6991: GO 6835
6993: POP
6994: POP
// coords := [ [ 97 , 143 ] ] ;
6995: LD_ADDR_VAR 0 5
6999: PUSH
7000: LD_INT 97
7002: PUSH
7003: LD_INT 143
7005: PUSH
7006: EMPTY
7007: LIST
7008: LIST
7009: PUSH
7010: EMPTY
7011: LIST
7012: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 5 ] , coords , flags ) ;
7013: LD_INT 1
7015: PPUSH
7016: LD_VAR 0 3
7020: PUSH
7021: LD_INT 5
7023: ARRAY
7024: PPUSH
7025: LD_VAR 0 5
7029: PPUSH
7030: LD_VAR 0 6
7034: PPUSH
7035: CALL 42942 0 4
// end ; end ;
7039: PPOPN 7
7041: END
// every 5 5$0 + 15 15$0 do var i , tmp , tmp2 , coords , w , list , p ;
7042: GO 7044
7044: DISABLE
7045: LD_INT 0
7047: PPUSH
7048: PPUSH
7049: PPUSH
7050: PPUSH
7051: PPUSH
7052: PPUSH
7053: PPUSH
// begin enable ;
7054: ENABLE
// tmp := [ ] ;
7055: LD_ADDR_VAR 0 2
7059: PUSH
7060: EMPTY
7061: ST_TO_ADDR
// w := rand ( 1 , 3 ) ;
7062: LD_ADDR_VAR 0 5
7066: PUSH
7067: LD_INT 1
7069: PPUSH
7070: LD_INT 3
7072: PPUSH
7073: CALL_OW 12
7077: ST_TO_ADDR
// if w = 3 then
7078: LD_VAR 0 5
7082: PUSH
7083: LD_INT 3
7085: EQUAL
7086: IFFALSE 7173
// list := [ [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] else
7088: LD_ADDR_VAR 0 6
7092: PUSH
7093: LD_INT 11
7095: PUSH
7096: LD_INT 1
7098: PUSH
7099: LD_INT 2
7101: PUSH
7102: LD_INT 24
7104: PUSH
7105: EMPTY
7106: LIST
7107: LIST
7108: LIST
7109: LIST
7110: PUSH
7111: LD_INT 11
7113: PUSH
7114: LD_INT 1
7116: PUSH
7117: LD_INT 2
7119: PUSH
7120: LD_INT 24
7122: PUSH
7123: EMPTY
7124: LIST
7125: LIST
7126: LIST
7127: LIST
7128: PUSH
7129: LD_INT 11
7131: PUSH
7132: LD_INT 1
7134: PUSH
7135: LD_INT 2
7137: PUSH
7138: LD_INT 24
7140: PUSH
7141: EMPTY
7142: LIST
7143: LIST
7144: LIST
7145: LIST
7146: PUSH
7147: LD_INT 11
7149: PUSH
7150: LD_INT 1
7152: PUSH
7153: LD_INT 2
7155: PUSH
7156: LD_INT 24
7158: PUSH
7159: EMPTY
7160: LIST
7161: LIST
7162: LIST
7163: LIST
7164: PUSH
7165: EMPTY
7166: LIST
7167: LIST
7168: LIST
7169: LIST
7170: ST_TO_ADDR
7171: GO 7275
// list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ;
7173: LD_ADDR_VAR 0 6
7177: PUSH
7178: LD_INT 14
7180: PUSH
7181: LD_INT 1
7183: PUSH
7184: LD_INT 2
7186: PUSH
7187: LD_INT 28
7189: PUSH
7190: EMPTY
7191: LIST
7192: LIST
7193: LIST
7194: LIST
7195: PUSH
7196: LD_INT 14
7198: PUSH
7199: LD_INT 1
7201: PUSH
7202: LD_INT 2
7204: PUSH
7205: LD_INT 25
7207: PUSH
7208: EMPTY
7209: LIST
7210: LIST
7211: LIST
7212: LIST
7213: PUSH
7214: LD_INT 14
7216: PUSH
7217: LD_INT 1
7219: PUSH
7220: LD_INT 2
7222: PUSH
7223: LD_INT 28
7225: PUSH
7226: EMPTY
7227: LIST
7228: LIST
7229: LIST
7230: LIST
7231: PUSH
7232: LD_INT 14
7234: PUSH
7235: LD_INT 1
7237: PUSH
7238: LD_INT 2
7240: PUSH
7241: LD_INT 29
7243: PUSH
7244: EMPTY
7245: LIST
7246: LIST
7247: LIST
7248: LIST
7249: PUSH
7250: LD_INT 14
7252: PUSH
7253: LD_INT 1
7255: PUSH
7256: LD_INT 2
7258: PUSH
7259: LD_INT 29
7261: PUSH
7262: EMPTY
7263: LIST
7264: LIST
7265: LIST
7266: LIST
7267: PUSH
7268: EMPTY
7269: LIST
7270: LIST
7271: LIST
7272: LIST
7273: LIST
7274: ST_TO_ADDR
// if w < 3 then
7275: LD_VAR 0 5
7279: PUSH
7280: LD_INT 3
7282: LESS
7283: IFFALSE 7363
// list := ReplaceIn ( list , [ 1 , list [ i ] + 1 ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gatling_gun , ar_rocket_launcher , ar_selfpropelled_bomb ] [ rand ( 1 , 3 ) ] ] ) ;
7285: LD_ADDR_VAR 0 6
7289: PUSH
7290: LD_VAR 0 6
7294: PPUSH
7295: LD_INT 1
7297: PUSH
7298: LD_VAR 0 6
7302: PUSH
7303: LD_VAR 0 1
7307: ARRAY
7308: PUSH
7309: LD_INT 1
7311: PLUS
7312: PUSH
7313: EMPTY
7314: LIST
7315: LIST
7316: PPUSH
7317: LD_INT 14
7319: PUSH
7320: LD_INT 1
7322: PUSH
7323: LD_INT 2
7325: PUSH
7326: LD_INT 25
7328: PUSH
7329: LD_INT 28
7331: PUSH
7332: LD_INT 29
7334: PUSH
7335: EMPTY
7336: LIST
7337: LIST
7338: LIST
7339: PUSH
7340: LD_INT 1
7342: PPUSH
7343: LD_INT 3
7345: PPUSH
7346: CALL_OW 12
7350: ARRAY
7351: PUSH
7352: EMPTY
7353: LIST
7354: LIST
7355: LIST
7356: LIST
7357: PPUSH
7358: CALL 54145 0 3
7362: ST_TO_ADDR
// MC_SetProduceList ( 1 , list ) ;
7363: LD_INT 1
7365: PPUSH
7366: LD_VAR 0 6
7370: PPUSH
7371: CALL 42709 0 2
// if GetSide ( ar_dep_w ) = 2 and IsOk ( ar_dep_w ) and w < 3 then
7375: LD_INT 45
7377: PPUSH
7378: CALL_OW 255
7382: PUSH
7383: LD_INT 2
7385: EQUAL
7386: PUSH
7387: LD_INT 45
7389: PPUSH
7390: CALL_OW 302
7394: AND
7395: PUSH
7396: LD_VAR 0 5
7400: PUSH
7401: LD_INT 3
7403: LESS
7404: AND
7405: IFFALSE 7490
// begin list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] ] ;
7407: LD_ADDR_VAR 0 6
7411: PUSH
7412: LD_INT 14
7414: PUSH
7415: LD_INT 1
7417: PUSH
7418: LD_INT 2
7420: PUSH
7421: LD_INT 28
7423: PUSH
7424: EMPTY
7425: LIST
7426: LIST
7427: LIST
7428: LIST
7429: PUSH
7430: LD_INT 14
7432: PUSH
7433: LD_INT 1
7435: PUSH
7436: LD_INT 2
7438: PUSH
7439: LD_INT 27
7441: PUSH
7442: EMPTY
7443: LIST
7444: LIST
7445: LIST
7446: LIST
7447: PUSH
7448: LD_INT 14
7450: PUSH
7451: LD_INT 1
7453: PUSH
7454: LD_INT 2
7456: PUSH
7457: LD_INT 27
7459: PUSH
7460: EMPTY
7461: LIST
7462: LIST
7463: LIST
7464: LIST
7465: PUSH
7466: EMPTY
7467: LIST
7468: LIST
7469: LIST
7470: ST_TO_ADDR
// MC_SetProduceList ( 2 , list ) ;
7471: LD_INT 2
7473: PPUSH
7474: LD_VAR 0 6
7478: PPUSH
7479: CALL 42709 0 2
// wait ( 0 0$20 ) ;
7483: LD_INT 700
7485: PPUSH
7486: CALL_OW 67
// end ; p := 60 ;
7490: LD_ADDR_VAR 0 7
7494: PUSH
7495: LD_INT 60
7497: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7498: LD_INT 35
7500: PPUSH
7501: CALL_OW 67
// p := Dec ( p ) ;
7505: LD_ADDR_VAR 0 7
7509: PUSH
7510: LD_VAR 0 7
7514: PPUSH
7515: CALL 88257 0 1
7519: ST_TO_ADDR
// until UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) >= 4 or p <= 0 ;
7520: LD_EXP 69
7524: PUSH
7525: LD_INT 1
7527: ARRAY
7528: PPUSH
7529: LD_INT 3
7531: PUSH
7532: LD_INT 34
7534: PUSH
7535: LD_INT 32
7537: PUSH
7538: EMPTY
7539: LIST
7540: LIST
7541: PUSH
7542: LD_INT 34
7544: PUSH
7545: LD_INT 88
7547: PUSH
7548: EMPTY
7549: LIST
7550: LIST
7551: PUSH
7552: EMPTY
7553: LIST
7554: LIST
7555: LIST
7556: PPUSH
7557: CALL_OW 72
7561: PUSH
7562: LD_INT 4
7564: GREATEREQUAL
7565: PUSH
7566: LD_VAR 0 7
7570: PUSH
7571: LD_INT 0
7573: LESSEQUAL
7574: OR
7575: IFFALSE 7498
// wait ( 0 0$10 ) ;
7577: LD_INT 350
7579: PPUSH
7580: CALL_OW 67
// tmp := UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
7584: LD_ADDR_VAR 0 2
7588: PUSH
7589: LD_EXP 69
7593: PUSH
7594: LD_INT 1
7596: ARRAY
7597: PPUSH
7598: LD_INT 3
7600: PUSH
7601: LD_INT 34
7603: PUSH
7604: LD_INT 32
7606: PUSH
7607: EMPTY
7608: LIST
7609: LIST
7610: PUSH
7611: LD_INT 34
7613: PUSH
7614: LD_INT 88
7616: PUSH
7617: EMPTY
7618: LIST
7619: LIST
7620: PUSH
7621: EMPTY
7622: LIST
7623: LIST
7624: LIST
7625: PPUSH
7626: CALL_OW 72
7630: ST_TO_ADDR
// tmp2 := UnitFilter ( mc_vehicles [ 2 ] , [ f_not , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
7631: LD_ADDR_VAR 0 3
7635: PUSH
7636: LD_EXP 69
7640: PUSH
7641: LD_INT 2
7643: ARRAY
7644: PPUSH
7645: LD_INT 3
7647: PUSH
7648: LD_INT 34
7650: PUSH
7651: LD_INT 32
7653: PUSH
7654: EMPTY
7655: LIST
7656: LIST
7657: PUSH
7658: LD_INT 34
7660: PUSH
7661: LD_INT 88
7663: PUSH
7664: EMPTY
7665: LIST
7666: LIST
7667: PUSH
7668: EMPTY
7669: LIST
7670: LIST
7671: LIST
7672: PPUSH
7673: CALL_OW 72
7677: ST_TO_ADDR
// if tmp2 then
7678: LD_VAR 0 3
7682: IFFALSE 7700
// tmp := tmp union tmp2 ;
7684: LD_ADDR_VAR 0 2
7688: PUSH
7689: LD_VAR 0 2
7693: PUSH
7694: LD_VAR 0 3
7698: UNION
7699: ST_TO_ADDR
// if not tmp then
7700: LD_VAR 0 2
7704: NOT
7705: IFFALSE 7709
// exit ;
7707: GO 8090
// if Count ( tmp2 ) or Prob ( 50 ) then
7709: LD_VAR 0 3
7713: PPUSH
7714: CALL 51285 0 1
7718: PUSH
7719: LD_INT 50
7721: PPUSH
7722: CALL_OW 13
7726: OR
7727: IFFALSE 7760
// coords := [ [ 48 , 33 ] , [ 71 , 88 ] ] else
7729: LD_ADDR_VAR 0 4
7733: PUSH
7734: LD_INT 48
7736: PUSH
7737: LD_INT 33
7739: PUSH
7740: EMPTY
7741: LIST
7742: LIST
7743: PUSH
7744: LD_INT 71
7746: PUSH
7747: LD_INT 88
7749: PUSH
7750: EMPTY
7751: LIST
7752: LIST
7753: PUSH
7754: EMPTY
7755: LIST
7756: LIST
7757: ST_TO_ADDR
7758: GO 7789
// coords := [ [ 128 , 94 ] , [ 180 , 135 ] ] ;
7760: LD_ADDR_VAR 0 4
7764: PUSH
7765: LD_INT 128
7767: PUSH
7768: LD_INT 94
7770: PUSH
7771: EMPTY
7772: LIST
7773: LIST
7774: PUSH
7775: LD_INT 180
7777: PUSH
7778: LD_INT 135
7780: PUSH
7781: EMPTY
7782: LIST
7783: LIST
7784: PUSH
7785: EMPTY
7786: LIST
7787: LIST
7788: ST_TO_ADDR
// if w = 3 then
7789: LD_VAR 0 5
7793: PUSH
7794: LD_INT 3
7796: EQUAL
7797: IFFALSE 7828
// coords := [ [ 91 , 58 ] , [ 117 , 107 ] ] ;
7799: LD_ADDR_VAR 0 4
7803: PUSH
7804: LD_INT 91
7806: PUSH
7807: LD_INT 58
7809: PUSH
7810: EMPTY
7811: LIST
7812: LIST
7813: PUSH
7814: LD_INT 117
7816: PUSH
7817: LD_INT 107
7819: PUSH
7820: EMPTY
7821: LIST
7822: LIST
7823: PUSH
7824: EMPTY
7825: LIST
7826: LIST
7827: ST_TO_ADDR
// if FilterUnitsInArea ( base_north , [ f_side , 1 ] ) then
7828: LD_INT 28
7830: PPUSH
7831: LD_INT 22
7833: PUSH
7834: LD_INT 1
7836: PUSH
7837: EMPTY
7838: LIST
7839: LIST
7840: PPUSH
7841: CALL_OW 70
7845: IFFALSE 7865
// coords := [ [ 163 , 41 ] ] ;
7847: LD_ADDR_VAR 0 4
7851: PUSH
7852: LD_INT 163
7854: PUSH
7855: LD_INT 41
7857: PUSH
7858: EMPTY
7859: LIST
7860: LIST
7861: PUSH
7862: EMPTY
7863: LIST
7864: ST_TO_ADDR
// ComAgressiveMove ( tmp , coords [ 1 ] , coords [ 2 ] ) ;
7865: LD_VAR 0 2
7869: PPUSH
7870: LD_VAR 0 4
7874: PUSH
7875: LD_INT 1
7877: ARRAY
7878: PPUSH
7879: LD_VAR 0 4
7883: PUSH
7884: LD_INT 2
7886: ARRAY
7887: PPUSH
7888: CALL_OW 114
// p := 30 ;
7892: LD_ADDR_VAR 0 7
7896: PUSH
7897: LD_INT 30
7899: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7900: LD_INT 35
7902: PPUSH
7903: CALL_OW 67
// p := Dec ( p ) ;
7907: LD_ADDR_VAR 0 7
7911: PUSH
7912: LD_VAR 0 7
7916: PPUSH
7917: CALL 88257 0 1
7921: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_hastask ] ) = 0 or p <= 0 ;
7922: LD_VAR 0 2
7926: PPUSH
7927: LD_INT 60
7929: PUSH
7930: EMPTY
7931: LIST
7932: PPUSH
7933: CALL_OW 72
7937: PUSH
7938: LD_INT 0
7940: EQUAL
7941: PUSH
7942: LD_VAR 0 7
7946: PUSH
7947: LD_INT 0
7949: LESSEQUAL
7950: OR
7951: IFFALSE 7900
// repeat wait ( 0 0$2 ) ;
7953: LD_INT 70
7955: PPUSH
7956: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
7960: LD_ADDR_VAR 0 2
7964: PUSH
7965: LD_VAR 0 2
7969: PPUSH
7970: LD_INT 50
7972: PUSH
7973: EMPTY
7974: LIST
7975: PPUSH
7976: CALL_OW 72
7980: ST_TO_ADDR
// for i in tmp do
7981: LD_ADDR_VAR 0 1
7985: PUSH
7986: LD_VAR 0 2
7990: PUSH
7991: FOR_IN
7992: IFFALSE 8081
// if GetChassis ( i ) = ar_hovercraft then
7994: LD_VAR 0 1
7998: PPUSH
7999: CALL_OW 265
8003: PUSH
8004: LD_INT 11
8006: EQUAL
8007: IFFALSE 8045
// AttackHovercraft ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) else
8009: LD_VAR 0 1
8013: PPUSH
8014: LD_INT 22
8016: PUSH
8017: LD_INT 1
8019: PUSH
8020: EMPTY
8021: LIST
8022: LIST
8023: PPUSH
8024: CALL_OW 69
8028: PPUSH
8029: LD_VAR 0 1
8033: PPUSH
8034: CALL_OW 74
8038: PPUSH
8039: CALL 82488 0 2
8043: GO 8079
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
8045: LD_VAR 0 1
8049: PPUSH
8050: LD_INT 22
8052: PUSH
8053: LD_INT 1
8055: PUSH
8056: EMPTY
8057: LIST
8058: LIST
8059: PPUSH
8060: CALL_OW 69
8064: PPUSH
8065: LD_VAR 0 1
8069: PPUSH
8070: CALL_OW 74
8074: PPUSH
8075: CALL_OW 115
8079: GO 7991
8081: POP
8082: POP
// until not tmp ;
8083: LD_VAR 0 2
8087: NOT
8088: IFFALSE 7953
// end ;
8090: PPOPN 7
8092: END
// every 28 28$00 do var i , tmp , un , x , p ;
8093: GO 8095
8095: DISABLE
8096: LD_INT 0
8098: PPUSH
8099: PPUSH
8100: PPUSH
8101: PPUSH
8102: PPUSH
// begin enable ;
8103: ENABLE
// wait ( rand ( 0 0$1 , 0 0$34 ) ) ;
8104: LD_INT 35
8106: PPUSH
8107: LD_INT 1190
8109: PPUSH
8110: CALL_OW 12
8114: PPUSH
8115: CALL_OW 67
// tmp := [ ] ;
8119: LD_ADDR_VAR 0 2
8123: PUSH
8124: EMPTY
8125: ST_TO_ADDR
// InitHc ;
8126: CALL_OW 19
// for i = 1 to 3 do
8130: LD_ADDR_VAR 0 1
8134: PUSH
8135: DOUBLE
8136: LD_INT 1
8138: DEC
8139: ST_TO_ADDR
8140: LD_INT 3
8142: PUSH
8143: FOR_TO
8144: IFFALSE 8287
// begin uc_side := 8 ;
8146: LD_ADDR_OWVAR 20
8150: PUSH
8151: LD_INT 8
8153: ST_TO_ADDR
// uc_nation := 2 ;
8154: LD_ADDR_OWVAR 21
8158: PUSH
8159: LD_INT 2
8161: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
8162: LD_INT 13
8164: PUSH
8165: LD_INT 14
8167: PUSH
8168: EMPTY
8169: LIST
8170: LIST
8171: PUSH
8172: LD_INT 1
8174: PPUSH
8175: LD_INT 2
8177: PPUSH
8178: CALL_OW 12
8182: ARRAY
8183: PPUSH
8184: LD_INT 3
8186: PPUSH
8187: LD_INT 5
8189: PPUSH
8190: LD_INT 27
8192: PUSH
8193: LD_INT 28
8195: PUSH
8196: EMPTY
8197: LIST
8198: LIST
8199: PUSH
8200: LD_INT 1
8202: PPUSH
8203: LD_INT 2
8205: PPUSH
8206: CALL_OW 12
8210: ARRAY
8211: PPUSH
8212: LD_INT 100
8214: PPUSH
8215: CALL 54023 0 5
// un := CreateVehicle ;
8219: LD_ADDR_VAR 0 3
8223: PUSH
8224: CALL_OW 45
8228: ST_TO_ADDR
// SetDir ( un , 4 ) ;
8229: LD_VAR 0 3
8233: PPUSH
8234: LD_INT 4
8236: PPUSH
8237: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
8241: LD_VAR 0 3
8245: PPUSH
8246: LD_INT 15
8248: PPUSH
8249: LD_INT 0
8251: PPUSH
8252: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8256: LD_ADDR_VAR 0 2
8260: PUSH
8261: LD_VAR 0 2
8265: PPUSH
8266: LD_VAR 0 2
8270: PUSH
8271: LD_INT 1
8273: PLUS
8274: PPUSH
8275: LD_VAR 0 3
8279: PPUSH
8280: CALL_OW 1
8284: ST_TO_ADDR
// end ;
8285: GO 8143
8287: POP
8288: POP
// for i = 1 to 3 do
8289: LD_ADDR_VAR 0 1
8293: PUSH
8294: DOUBLE
8295: LD_INT 1
8297: DEC
8298: ST_TO_ADDR
8299: LD_INT 3
8301: PUSH
8302: FOR_TO
8303: IFFALSE 8411
// begin uc_side := 8 ;
8305: LD_ADDR_OWVAR 20
8309: PUSH
8310: LD_INT 8
8312: ST_TO_ADDR
// uc_nation := 2 ;
8313: LD_ADDR_OWVAR 21
8317: PUSH
8318: LD_INT 2
8320: ST_TO_ADDR
// PrepareHuman ( false , 1 , 6 ) ;
8321: LD_INT 0
8323: PPUSH
8324: LD_INT 1
8326: PPUSH
8327: LD_INT 6
8329: PPUSH
8330: CALL_OW 380
// un := CreateHuman ;
8334: LD_ADDR_VAR 0 3
8338: PUSH
8339: CALL_OW 44
8343: ST_TO_ADDR
// if Prob ( 50 ) then
8344: LD_INT 50
8346: PPUSH
8347: CALL_OW 13
8351: IFFALSE 8365
// SetClass ( un , class_mortar ) ;
8353: LD_VAR 0 3
8357: PPUSH
8358: LD_INT 8
8360: PPUSH
8361: CALL_OW 336
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
8365: LD_VAR 0 3
8369: PPUSH
8370: LD_INT 15
8372: PPUSH
8373: LD_INT 0
8375: PPUSH
8376: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8380: LD_ADDR_VAR 0 2
8384: PUSH
8385: LD_VAR 0 2
8389: PPUSH
8390: LD_VAR 0 2
8394: PUSH
8395: LD_INT 1
8397: PLUS
8398: PPUSH
8399: LD_VAR 0 3
8403: PPUSH
8404: CALL_OW 1
8408: ST_TO_ADDR
// end ;
8409: GO 8302
8411: POP
8412: POP
// wait ( 0 0$3 ) ;
8413: LD_INT 105
8415: PPUSH
8416: CALL_OW 67
// p := 0 ;
8420: LD_ADDR_VAR 0 5
8424: PUSH
8425: LD_INT 0
8427: ST_TO_ADDR
// repeat wait ( 0 0$3 ) ;
8428: LD_INT 105
8430: PPUSH
8431: CALL_OW 67
// p := p + 3 ;
8435: LD_ADDR_VAR 0 5
8439: PUSH
8440: LD_VAR 0 5
8444: PUSH
8445: LD_INT 3
8447: PLUS
8448: ST_TO_ADDR
// for i in UnitFilter ( tmp , [ f_ok ] ) do
8449: LD_ADDR_VAR 0 1
8453: PUSH
8454: LD_VAR 0 2
8458: PPUSH
8459: LD_INT 50
8461: PUSH
8462: EMPTY
8463: LIST
8464: PPUSH
8465: CALL_OW 72
8469: PUSH
8470: FOR_IN
8471: IFFALSE 8509
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
8473: LD_VAR 0 1
8477: PPUSH
8478: LD_INT 81
8480: PUSH
8481: LD_INT 8
8483: PUSH
8484: EMPTY
8485: LIST
8486: LIST
8487: PPUSH
8488: CALL_OW 69
8492: PPUSH
8493: LD_VAR 0 1
8497: PPUSH
8498: CALL_OW 74
8502: PPUSH
8503: CALL_OW 115
8507: GO 8470
8509: POP
8510: POP
// until p >= 120 ;
8511: LD_VAR 0 5
8515: PUSH
8516: LD_INT 120
8518: GREATEREQUAL
8519: IFFALSE 8428
// repeat AddComAgressiveMove ( tmp , 210 , 178 ) ;
8521: LD_VAR 0 2
8525: PPUSH
8526: LD_INT 210
8528: PPUSH
8529: LD_INT 178
8531: PPUSH
8532: CALL_OW 174
// x := FilterUnitsInArea ( escape_area , [ f_side , 8 ] ) ;
8536: LD_ADDR_VAR 0 4
8540: PUSH
8541: LD_INT 10
8543: PPUSH
8544: LD_INT 22
8546: PUSH
8547: LD_INT 8
8549: PUSH
8550: EMPTY
8551: LIST
8552: LIST
8553: PPUSH
8554: CALL_OW 70
8558: ST_TO_ADDR
// if x then
8559: LD_VAR 0 4
8563: IFFALSE 8591
// for i in x do
8565: LD_ADDR_VAR 0 1
8569: PUSH
8570: LD_VAR 0 4
8574: PUSH
8575: FOR_IN
8576: IFFALSE 8589
// RemoveUnit ( i ) ;
8578: LD_VAR 0 1
8582: PPUSH
8583: CALL_OW 64
8587: GO 8575
8589: POP
8590: POP
// wait ( 0 0$1 ) ;
8591: LD_INT 35
8593: PPUSH
8594: CALL_OW 67
// until not FilterAllUnits ( [ f_side , 8 ] ) ;
8598: LD_INT 22
8600: PUSH
8601: LD_INT 8
8603: PUSH
8604: EMPTY
8605: LIST
8606: LIST
8607: PPUSH
8608: CALL_OW 69
8612: NOT
8613: IFFALSE 8521
// end ;
8615: PPOPN 5
8617: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
8618: LD_INT 22
8620: PUSH
8621: LD_INT 2
8623: PUSH
8624: EMPTY
8625: LIST
8626: LIST
8627: PUSH
8628: LD_INT 34
8630: PUSH
8631: LD_INT 31
8633: PUSH
8634: EMPTY
8635: LIST
8636: LIST
8637: PUSH
8638: LD_INT 3
8640: PUSH
8641: LD_INT 24
8643: PUSH
8644: LD_INT 1000
8646: PUSH
8647: EMPTY
8648: LIST
8649: LIST
8650: PUSH
8651: EMPTY
8652: LIST
8653: LIST
8654: PUSH
8655: EMPTY
8656: LIST
8657: LIST
8658: LIST
8659: PPUSH
8660: CALL_OW 69
8664: IFFALSE 8767
8666: GO 8668
8668: DISABLE
// begin if IsOk ( ar_dep_w ) and GetSide ( ar_dep_w ) then
8669: LD_INT 45
8671: PPUSH
8672: CALL_OW 302
8676: PUSH
8677: LD_INT 45
8679: PPUSH
8680: CALL_OW 255
8684: AND
8685: IFFALSE 8728
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 18 , 8 ) else
8687: LD_INT 22
8689: PUSH
8690: LD_INT 2
8692: PUSH
8693: EMPTY
8694: LIST
8695: LIST
8696: PUSH
8697: LD_INT 34
8699: PUSH
8700: LD_INT 31
8702: PUSH
8703: EMPTY
8704: LIST
8705: LIST
8706: PUSH
8707: EMPTY
8708: LIST
8709: LIST
8710: PPUSH
8711: CALL_OW 69
8715: PPUSH
8716: LD_INT 18
8718: PPUSH
8719: LD_INT 8
8721: PPUSH
8722: CALL_OW 111
8726: GO 8767
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 106 , 14 ) ;
8728: LD_INT 22
8730: PUSH
8731: LD_INT 2
8733: PUSH
8734: EMPTY
8735: LIST
8736: LIST
8737: PUSH
8738: LD_INT 34
8740: PUSH
8741: LD_INT 31
8743: PUSH
8744: EMPTY
8745: LIST
8746: LIST
8747: PUSH
8748: EMPTY
8749: LIST
8750: LIST
8751: PPUSH
8752: CALL_OW 69
8756: PPUSH
8757: LD_INT 106
8759: PPUSH
8760: LD_INT 14
8762: PPUSH
8763: CALL_OW 111
// end ; end_of_file
8767: END
// export function Action ; var tmp , p , radar , sols , i ; begin
8768: LD_INT 0
8770: PPUSH
8771: PPUSH
8772: PPUSH
8773: PPUSH
8774: PPUSH
8775: PPUSH
// InGameOn ;
8776: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
8780: LD_EXP 21
8784: PPUSH
8785: CALL_OW 87
// SetAttitude ( 2 , 1 , att_friend , true ) ;
8789: LD_INT 2
8791: PPUSH
8792: LD_INT 1
8794: PPUSH
8795: LD_INT 1
8797: PPUSH
8798: LD_INT 1
8800: PPUSH
8801: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) ;
8805: LD_ADDR_VAR 0 2
8809: PUSH
8810: LD_INT 22
8812: PUSH
8813: LD_INT 1
8815: PUSH
8816: EMPTY
8817: LIST
8818: LIST
8819: PUSH
8820: LD_INT 25
8822: PUSH
8823: LD_INT 1
8825: PUSH
8826: EMPTY
8827: LIST
8828: LIST
8829: PUSH
8830: EMPTY
8831: LIST
8832: LIST
8833: PPUSH
8834: CALL_OW 69
8838: ST_TO_ADDR
// radar := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_radar ] ] ) [ 1 ] ;
8839: LD_ADDR_VAR 0 4
8843: PUSH
8844: LD_INT 22
8846: PUSH
8847: LD_INT 1
8849: PUSH
8850: EMPTY
8851: LIST
8852: LIST
8853: PUSH
8854: LD_INT 34
8856: PUSH
8857: LD_INT 11
8859: PUSH
8860: EMPTY
8861: LIST
8862: LIST
8863: PUSH
8864: EMPTY
8865: LIST
8866: LIST
8867: PPUSH
8868: CALL_OW 69
8872: PUSH
8873: LD_INT 1
8875: ARRAY
8876: ST_TO_ADDR
// for i = 1 to tmp do
8877: LD_ADDR_VAR 0 6
8881: PUSH
8882: DOUBLE
8883: LD_INT 1
8885: DEC
8886: ST_TO_ADDR
8887: LD_VAR 0 2
8891: PUSH
8892: FOR_TO
8893: IFFALSE 8940
// begin if i = 5 then
8895: LD_VAR 0 6
8899: PUSH
8900: LD_INT 5
8902: EQUAL
8903: IFFALSE 8907
// break ;
8905: GO 8940
// sols := Replace ( sols , i , tmp [ i ] ) ;
8907: LD_ADDR_VAR 0 5
8911: PUSH
8912: LD_VAR 0 5
8916: PPUSH
8917: LD_VAR 0 6
8921: PPUSH
8922: LD_VAR 0 2
8926: PUSH
8927: LD_VAR 0 6
8931: ARRAY
8932: PPUSH
8933: CALL_OW 1
8937: ST_TO_ADDR
// end ;
8938: GO 8892
8940: POP
8941: POP
// tmp := ar_force_tmp ;
8942: LD_ADDR_VAR 0 2
8946: PUSH
8947: LD_EXP 40
8951: ST_TO_ADDR
// PlaceUnitXY ( tmp [ 1 ] , 108 , 139 , false ) ;
8952: LD_VAR 0 2
8956: PUSH
8957: LD_INT 1
8959: ARRAY
8960: PPUSH
8961: LD_INT 108
8963: PPUSH
8964: LD_INT 139
8966: PPUSH
8967: LD_INT 0
8969: PPUSH
8970: CALL_OW 48
// ComTurnUnit ( tmp [ 1 ] , JMM ) ;
8974: LD_VAR 0 2
8978: PUSH
8979: LD_INT 1
8981: ARRAY
8982: PPUSH
8983: LD_EXP 21
8987: PPUSH
8988: CALL_OW 119
// PlaceUnitXY ( tmp [ 2 ] , 114 , 132 , false ) ;
8992: LD_VAR 0 2
8996: PUSH
8997: LD_INT 2
8999: ARRAY
9000: PPUSH
9001: LD_INT 114
9003: PPUSH
9004: LD_INT 132
9006: PPUSH
9007: LD_INT 0
9009: PPUSH
9010: CALL_OW 48
// PlaceUnitXY ( tmp [ 3 ] , 115 , 132 , false ) ;
9014: LD_VAR 0 2
9018: PUSH
9019: LD_INT 3
9021: ARRAY
9022: PPUSH
9023: LD_INT 115
9025: PPUSH
9026: LD_INT 132
9028: PPUSH
9029: LD_INT 0
9031: PPUSH
9032: CALL_OW 48
// ComHold ( [ tmp [ 2 ] , tmp [ 3 ] ] ) ;
9036: LD_VAR 0 2
9040: PUSH
9041: LD_INT 2
9043: ARRAY
9044: PUSH
9045: LD_VAR 0 2
9049: PUSH
9050: LD_INT 3
9052: ARRAY
9053: PUSH
9054: EMPTY
9055: LIST
9056: LIST
9057: PPUSH
9058: CALL_OW 140
// ComMoveXY ( radar , 83 , 123 ) ;
9062: LD_VAR 0 4
9066: PPUSH
9067: LD_INT 83
9069: PPUSH
9070: LD_INT 123
9072: PPUSH
9073: CALL_OW 111
// Wait ( 0 0$01 ) ;
9077: LD_INT 35
9079: PPUSH
9080: CALL_OW 67
// CenterOnXY ( 90 , 144 ) ;
9084: LD_INT 90
9086: PPUSH
9087: LD_INT 144
9089: PPUSH
9090: CALL_OW 84
// ComMoveXY ( sols , 88 , 129 ) ;
9094: LD_VAR 0 5
9098: PPUSH
9099: LD_INT 88
9101: PPUSH
9102: LD_INT 129
9104: PPUSH
9105: CALL_OW 111
// p := [ [ 92 , 131 ] , [ 88 , 127 ] , [ 91 , 132 ] , [ 92 , 134 ] ] ;
9109: LD_ADDR_VAR 0 3
9113: PUSH
9114: LD_INT 92
9116: PUSH
9117: LD_INT 131
9119: PUSH
9120: EMPTY
9121: LIST
9122: LIST
9123: PUSH
9124: LD_INT 88
9126: PUSH
9127: LD_INT 127
9129: PUSH
9130: EMPTY
9131: LIST
9132: LIST
9133: PUSH
9134: LD_INT 91
9136: PUSH
9137: LD_INT 132
9139: PUSH
9140: EMPTY
9141: LIST
9142: LIST
9143: PUSH
9144: LD_INT 92
9146: PUSH
9147: LD_INT 134
9149: PUSH
9150: EMPTY
9151: LIST
9152: LIST
9153: PUSH
9154: EMPTY
9155: LIST
9156: LIST
9157: LIST
9158: LIST
9159: ST_TO_ADDR
// for i = 1 to sols do
9160: LD_ADDR_VAR 0 6
9164: PUSH
9165: DOUBLE
9166: LD_INT 1
9168: DEC
9169: ST_TO_ADDR
9170: LD_VAR 0 5
9174: PUSH
9175: FOR_TO
9176: IFFALSE 9249
// begin AddComMoveXY ( sols [ i ] , p [ i ] [ 1 ] , p [ i ] [ 2 ] ) ;
9178: LD_VAR 0 5
9182: PUSH
9183: LD_VAR 0 6
9187: ARRAY
9188: PPUSH
9189: LD_VAR 0 3
9193: PUSH
9194: LD_VAR 0 6
9198: ARRAY
9199: PUSH
9200: LD_INT 1
9202: ARRAY
9203: PPUSH
9204: LD_VAR 0 3
9208: PUSH
9209: LD_VAR 0 6
9213: ARRAY
9214: PUSH
9215: LD_INT 2
9217: ARRAY
9218: PPUSH
9219: CALL_OW 171
// AddComCrawl ( sols [ i ] ) ;
9223: LD_VAR 0 5
9227: PUSH
9228: LD_VAR 0 6
9232: ARRAY
9233: PPUSH
9234: CALL_OW 197
// AddComHold ( sols ) ;
9238: LD_VAR 0 5
9242: PPUSH
9243: CALL_OW 200
// end ;
9247: GO 9175
9249: POP
9250: POP
// repeat wait ( 0 0$1 ) ;
9251: LD_INT 35
9253: PPUSH
9254: CALL_OW 67
// until GetDistUnitXY ( sols [ 1 ] , 92 , 131 ) < 4 ;
9258: LD_VAR 0 5
9262: PUSH
9263: LD_INT 1
9265: ARRAY
9266: PPUSH
9267: LD_INT 92
9269: PPUSH
9270: LD_INT 131
9272: PPUSH
9273: CALL_OW 297
9277: PUSH
9278: LD_INT 4
9280: LESS
9281: IFFALSE 9251
// CenterOnXY ( 96 , 139 ) ;
9283: LD_INT 96
9285: PPUSH
9286: LD_INT 139
9288: PPUSH
9289: CALL_OW 84
// wait ( 0 0$3 ) ;
9293: LD_INT 105
9295: PPUSH
9296: CALL_OW 67
// PlaceSeeing ( 111 , 135 , 1 , - 25 ) ;
9300: LD_INT 111
9302: PPUSH
9303: LD_INT 135
9305: PPUSH
9306: LD_INT 1
9308: PPUSH
9309: LD_INT 25
9311: NEG
9312: PPUSH
9313: CALL_OW 330
// ComMoveXY ( tmp [ 2 ] , GetX ( tmp [ 1 ] ) + 3 , GetY ( tmp [ 1 ] ) ) ;
9317: LD_VAR 0 2
9321: PUSH
9322: LD_INT 2
9324: ARRAY
9325: PPUSH
9326: LD_VAR 0 2
9330: PUSH
9331: LD_INT 1
9333: ARRAY
9334: PPUSH
9335: CALL_OW 250
9339: PUSH
9340: LD_INT 3
9342: PLUS
9343: PPUSH
9344: LD_VAR 0 2
9348: PUSH
9349: LD_INT 1
9351: ARRAY
9352: PPUSH
9353: CALL_OW 251
9357: PPUSH
9358: CALL_OW 111
// ComEnterUnit ( tmp [ 3 ] , ar_dep_s ) ;
9362: LD_VAR 0 2
9366: PUSH
9367: LD_INT 3
9369: ARRAY
9370: PPUSH
9371: LD_INT 7
9373: PPUSH
9374: CALL_OW 120
// AddComTurnUnit ( tmp [ 2 ] , tmp [ 1 ] ) ;
9378: LD_VAR 0 2
9382: PUSH
9383: LD_INT 2
9385: ARRAY
9386: PPUSH
9387: LD_VAR 0 2
9391: PUSH
9392: LD_INT 1
9394: ARRAY
9395: PPUSH
9396: CALL_OW 179
// repeat wait ( 0 0$1 ) ;
9400: LD_INT 35
9402: PPUSH
9403: CALL_OW 67
// until GetDistUnits ( tmp [ 1 ] , tmp [ 2 ] ) < 5 ;
9407: LD_VAR 0 2
9411: PUSH
9412: LD_INT 1
9414: ARRAY
9415: PPUSH
9416: LD_VAR 0 2
9420: PUSH
9421: LD_INT 2
9423: ARRAY
9424: PPUSH
9425: CALL_OW 296
9429: PUSH
9430: LD_INT 5
9432: LESS
9433: IFFALSE 9400
// ComTurnUnit ( tmp [ 1 ] , tmp [ 2 ] ) ;
9435: LD_VAR 0 2
9439: PUSH
9440: LD_INT 1
9442: ARRAY
9443: PPUSH
9444: LD_VAR 0 2
9448: PUSH
9449: LD_INT 2
9451: ARRAY
9452: PPUSH
9453: CALL_OW 119
// Say ( tmp [ 1 ] , D1a-Merc1-1 ) ;
9457: LD_VAR 0 2
9461: PUSH
9462: LD_INT 1
9464: ARRAY
9465: PPUSH
9466: LD_STRING D1a-Merc1-1
9468: PPUSH
9469: CALL_OW 88
// Say ( tmp [ 2 ] , D1a-FMerc2-1 ) ;
9473: LD_VAR 0 2
9477: PUSH
9478: LD_INT 2
9480: ARRAY
9481: PPUSH
9482: LD_STRING D1a-FMerc2-1
9484: PPUSH
9485: CALL_OW 88
// ComHeal ( tmp [ 2 ] , tmp [ 1 ] ) ;
9489: LD_VAR 0 2
9493: PUSH
9494: LD_INT 2
9496: ARRAY
9497: PPUSH
9498: LD_VAR 0 2
9502: PUSH
9503: LD_INT 1
9505: ARRAY
9506: PPUSH
9507: CALL_OW 128
// SetLives ( tmp [ 1 ] , 500 ) ;
9511: LD_VAR 0 2
9515: PUSH
9516: LD_INT 1
9518: ARRAY
9519: PPUSH
9520: LD_INT 500
9522: PPUSH
9523: CALL_OW 234
// wait ( 0 0$2 ) ;
9527: LD_INT 70
9529: PPUSH
9530: CALL_OW 67
// SetLives ( tmp [ 1 ] , 2 ) ;
9534: LD_VAR 0 2
9538: PUSH
9539: LD_INT 1
9541: ARRAY
9542: PPUSH
9543: LD_INT 2
9545: PPUSH
9546: CALL_OW 234
// wait ( 0 0$0.3 ) ;
9550: LD_INT 10
9552: PPUSH
9553: CALL_OW 67
// ForceSay ( tmp [ 1 ] , D1a-Merc1-2 ) ;
9557: LD_VAR 0 2
9561: PUSH
9562: LD_INT 1
9564: ARRAY
9565: PPUSH
9566: LD_STRING D1a-Merc1-2
9568: PPUSH
9569: CALL_OW 91
// wait ( 0 0$0.2 ) ;
9573: LD_INT 7
9575: PPUSH
9576: CALL_OW 67
// KillUnit ( tmp [ 1 ] ) ;
9580: LD_VAR 0 2
9584: PUSH
9585: LD_INT 1
9587: ARRAY
9588: PPUSH
9589: CALL_OW 66
// ComMoveToArea ( tmp [ 2 ] , escape_area ) ;
9593: LD_VAR 0 2
9597: PUSH
9598: LD_INT 2
9600: ARRAY
9601: PPUSH
9602: LD_INT 10
9604: PPUSH
9605: CALL_OW 113
// Say ( tmp [ 2 ] , D1a-FMerc2-2 ) ;
9609: LD_VAR 0 2
9613: PUSH
9614: LD_INT 2
9616: ARRAY
9617: PPUSH
9618: LD_STRING D1a-FMerc2-2
9620: PPUSH
9621: CALL_OW 88
// wait ( 0 0$1 ) ;
9625: LD_INT 35
9627: PPUSH
9628: CALL_OW 67
// CenterOnUnits ( ar_dep_s ) ;
9632: LD_INT 7
9634: PPUSH
9635: CALL_OW 85
// wait ( 0 0$2 ) ;
9639: LD_INT 70
9641: PPUSH
9642: CALL_OW 67
// ForceSay ( Saliba , D1a-Saliba-1 ) ;
9646: LD_EXP 44
9650: PPUSH
9651: LD_STRING D1a-Saliba-1
9653: PPUSH
9654: CALL_OW 91
// KillUnit ( Saliba ) ;
9658: LD_EXP 44
9662: PPUSH
9663: CALL_OW 66
// ComExitBuilding ( tmp [ 3 ] ) ;
9667: LD_VAR 0 2
9671: PUSH
9672: LD_INT 3
9674: ARRAY
9675: PPUSH
9676: CALL_OW 122
// CenterOnUnits ( JMM ) ;
9680: LD_EXP 21
9684: PPUSH
9685: CALL_OW 85
// wait ( 0 0$1 ) ;
9689: LD_INT 35
9691: PPUSH
9692: CALL_OW 67
// ComMoveXY ( sols , 88 , 141 ) ;
9696: LD_VAR 0 5
9700: PPUSH
9701: LD_INT 88
9703: PPUSH
9704: LD_INT 141
9706: PPUSH
9707: CALL_OW 111
// AddComWait ( sols , 0 0$2 ) ;
9711: LD_VAR 0 5
9715: PPUSH
9716: LD_INT 70
9718: PPUSH
9719: CALL_OW 202
// wait ( 0 0$2 ) ;
9723: LD_INT 70
9725: PPUSH
9726: CALL_OW 67
// SetAttitude ( 2 , 1 , att_enemy , true ) ;
9730: LD_INT 2
9732: PPUSH
9733: LD_INT 1
9735: PPUSH
9736: LD_INT 2
9738: PPUSH
9739: LD_INT 1
9741: PPUSH
9742: CALL_OW 80
// InGameOff ;
9746: CALL_OW 9
// ComWalk ( sols ) ;
9750: LD_VAR 0 5
9754: PPUSH
9755: CALL_OW 138
// ChangeMissionObjectives ( M1 ) ;
9759: LD_STRING M1
9761: PPUSH
9762: CALL_OW 337
// game_speed := 4 ;
9766: LD_ADDR_OWVAR 65
9770: PUSH
9771: LD_INT 4
9773: ST_TO_ADDR
// RemoveSeeing ( 111 , 135 , 1 ) ;
9774: LD_INT 111
9776: PPUSH
9777: LD_INT 135
9779: PPUSH
9780: LD_INT 1
9782: PPUSH
9783: CALL_OW 331
// SaveForQuickRestart ;
9787: CALL_OW 22
// ar_run := true ;
9791: LD_ADDR_EXP 5
9795: PUSH
9796: LD_INT 1
9798: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9799: LD_INT 35
9801: PPUSH
9802: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 1 ] , [ f_dist , ar_dep_s , 10 ] ] ) or GetLives ( ar_dep_s ) < 999 ;
9806: LD_INT 22
9808: PUSH
9809: LD_INT 1
9811: PUSH
9812: EMPTY
9813: LIST
9814: LIST
9815: PUSH
9816: LD_INT 91
9818: PUSH
9819: LD_INT 7
9821: PUSH
9822: LD_INT 10
9824: PUSH
9825: EMPTY
9826: LIST
9827: LIST
9828: LIST
9829: PUSH
9830: EMPTY
9831: LIST
9832: LIST
9833: PPUSH
9834: CALL_OW 69
9838: PUSH
9839: LD_INT 7
9841: PPUSH
9842: CALL_OW 256
9846: PUSH
9847: LD_INT 999
9849: LESS
9850: OR
9851: IFFALSE 9799
// if GetSide ( ar_dep_s ) = 2 then
9853: LD_INT 7
9855: PPUSH
9856: CALL_OW 255
9860: PUSH
9861: LD_INT 2
9863: EQUAL
9864: IFFALSE 9876
// SetSide ( ar_dep_s , 1 ) ;
9866: LD_INT 7
9868: PPUSH
9869: LD_INT 1
9871: PPUSH
9872: CALL_OW 235
// end ;
9876: LD_VAR 0 1
9880: RET
// every 0 0$2 trigger ar_run do var i , tmp , k ;
9881: LD_EXP 5
9885: IFFALSE 10245
9887: GO 9889
9889: DISABLE
9890: LD_INT 0
9892: PPUSH
9893: PPUSH
9894: PPUSH
// begin tmp := ar_force_tmp ^ UnitFilter ( ar_force_south , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ) ;
9895: LD_ADDR_VAR 0 2
9899: PUSH
9900: LD_EXP 40
9904: PUSH
9905: LD_EXP 36
9909: PPUSH
9910: LD_INT 2
9912: PUSH
9913: LD_INT 21
9915: PUSH
9916: LD_INT 2
9918: PUSH
9919: EMPTY
9920: LIST
9921: LIST
9922: PUSH
9923: LD_INT 21
9925: PUSH
9926: LD_INT 1
9928: PUSH
9929: EMPTY
9930: LIST
9931: LIST
9932: PUSH
9933: EMPTY
9934: LIST
9935: LIST
9936: LIST
9937: PPUSH
9938: CALL_OW 72
9942: ADD
9943: ST_TO_ADDR
// SetSide ( tmp , 5 ) ;
9944: LD_VAR 0 2
9948: PPUSH
9949: LD_INT 5
9951: PPUSH
9952: CALL_OW 235
// ChangeSideFog ( 5 , 1 ) ;
9956: LD_INT 5
9958: PPUSH
9959: LD_INT 1
9961: PPUSH
9962: CALL_OW 343
// k := 1 ;
9966: LD_ADDR_VAR 0 3
9970: PUSH
9971: LD_INT 1
9973: ST_TO_ADDR
// for i in tmp do
9974: LD_ADDR_VAR 0 1
9978: PUSH
9979: LD_VAR 0 2
9983: PUSH
9984: FOR_IN
9985: IFFALSE 10070
// begin if IsInUnit ( i ) then
9987: LD_VAR 0 1
9991: PPUSH
9992: CALL_OW 310
9996: IFFALSE 10007
// ComExitBuilding ( i ) ;
9998: LD_VAR 0 1
10002: PPUSH
10003: CALL_OW 122
// if GetClass ( i ) = 3 then
10007: LD_VAR 0 1
10011: PPUSH
10012: CALL_OW 257
10016: PUSH
10017: LD_INT 3
10019: EQUAL
10020: IFFALSE 10056
// begin AddComEnterUnit ( i , ar_vehicles_tmp [ k ] ) ;
10022: LD_VAR 0 1
10026: PPUSH
10027: LD_EXP 41
10031: PUSH
10032: LD_VAR 0 3
10036: ARRAY
10037: PPUSH
10038: CALL_OW 180
// k := k + 1 ;
10042: LD_ADDR_VAR 0 3
10046: PUSH
10047: LD_VAR 0 3
10051: PUSH
10052: LD_INT 1
10054: PLUS
10055: ST_TO_ADDR
// end ; AddComMoveToArea ( i , escape_area ) ;
10056: LD_VAR 0 1
10060: PPUSH
10061: LD_INT 10
10063: PPUSH
10064: CALL_OW 173
// end ;
10068: GO 9984
10070: POP
10071: POP
// ar_patrol := true ;
10072: LD_ADDR_EXP 7
10076: PUSH
10077: LD_INT 1
10079: ST_TO_ADDR
// repeat wait ( 0 0$0.3 ) ;
10080: LD_INT 10
10082: PPUSH
10083: CALL_OW 67
// for i in tmp do
10087: LD_ADDR_VAR 0 1
10091: PUSH
10092: LD_VAR 0 2
10096: PUSH
10097: FOR_IN
10098: IFFALSE 10126
// if not HasTask ( i ) then
10100: LD_VAR 0 1
10104: PPUSH
10105: CALL_OW 314
10109: NOT
10110: IFFALSE 10124
// ComMoveToArea ( i , escape_area ) ;
10112: LD_VAR 0 1
10116: PPUSH
10117: LD_INT 10
10119: PPUSH
10120: CALL_OW 113
10124: GO 10097
10126: POP
10127: POP
// k := UnitFilter ( tmp , [ f_inarea , escape_area ] ) ;
10128: LD_ADDR_VAR 0 3
10132: PUSH
10133: LD_VAR 0 2
10137: PPUSH
10138: LD_INT 95
10140: PUSH
10141: LD_INT 10
10143: PUSH
10144: EMPTY
10145: LIST
10146: LIST
10147: PPUSH
10148: CALL_OW 72
10152: ST_TO_ADDR
// if k then
10153: LD_VAR 0 3
10157: IFFALSE 10226
// for i in k do
10159: LD_ADDR_VAR 0 1
10163: PUSH
10164: LD_VAR 0 3
10168: PUSH
10169: FOR_IN
10170: IFFALSE 10224
// begin if IsInUnit ( i ) then
10172: LD_VAR 0 1
10176: PPUSH
10177: CALL_OW 310
10181: IFFALSE 10197
// RemoveUnit ( IsInUnit ( i ) ) ;
10183: LD_VAR 0 1
10187: PPUSH
10188: CALL_OW 310
10192: PPUSH
10193: CALL_OW 64
// RemoveUnit ( i ) ;
10197: LD_VAR 0 1
10201: PPUSH
10202: CALL_OW 64
// tmp := tmp diff i ;
10206: LD_ADDR_VAR 0 2
10210: PUSH
10211: LD_VAR 0 2
10215: PUSH
10216: LD_VAR 0 1
10220: DIFF
10221: ST_TO_ADDR
// end ;
10222: GO 10169
10224: POP
10225: POP
// until tmp = [ ] ;
10226: LD_VAR 0 2
10230: PUSH
10231: EMPTY
10232: EQUAL
10233: IFFALSE 10080
// ChangeSideFog ( 5 , 5 ) ;
10235: LD_INT 5
10237: PPUSH
10238: LD_INT 5
10240: PPUSH
10241: CALL_OW 343
// end ;
10245: PPOPN 3
10247: END
// every 0 0$03 trigger ar_patrol do var i , un , veh ;
10248: LD_EXP 7
10252: IFFALSE 10542
10254: GO 10256
10256: DISABLE
10257: LD_INT 0
10259: PPUSH
10260: PPUSH
10261: PPUSH
// begin uc_side := 2 ;
10262: LD_ADDR_OWVAR 20
10266: PUSH
10267: LD_INT 2
10269: ST_TO_ADDR
// uc_nation := 2 ;
10270: LD_ADDR_OWVAR 21
10274: PUSH
10275: LD_INT 2
10277: ST_TO_ADDR
// InitHc ;
10278: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
10282: LD_INT 1
10284: PPUSH
10285: LD_INT 1
10287: PPUSH
10288: LD_INT 6
10290: PPUSH
10291: CALL_OW 380
// un := CreateHuman ;
10295: LD_ADDR_VAR 0 2
10299: PUSH
10300: CALL_OW 44
10304: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_combustion , control_manual , ar_gun , 98 ) ;
10305: LD_INT 14
10307: PPUSH
10308: LD_INT 1
10310: PPUSH
10311: LD_INT 1
10313: PPUSH
10314: LD_INT 27
10316: PPUSH
10317: LD_INT 98
10319: PPUSH
10320: CALL 54023 0 5
// veh := CreateVehicle ;
10324: LD_ADDR_VAR 0 3
10328: PUSH
10329: CALL_OW 45
10333: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
10334: LD_VAR 0 3
10338: PPUSH
10339: LD_INT 4
10341: PPUSH
10342: CALL_OW 233
// PlaceUnitXY ( veh , 179 , 135 , false ) ;
10346: LD_VAR 0 3
10350: PPUSH
10351: LD_INT 179
10353: PPUSH
10354: LD_INT 135
10356: PPUSH
10357: LD_INT 0
10359: PPUSH
10360: CALL_OW 48
// PlaceHumanInUnit ( un , veh ) ;
10364: LD_VAR 0 2
10368: PPUSH
10369: LD_VAR 0 3
10373: PPUSH
10374: CALL_OW 52
// ComMoveXY ( un , 126 , 133 ) ;
10378: LD_VAR 0 2
10382: PPUSH
10383: LD_INT 126
10385: PPUSH
10386: LD_INT 133
10388: PPUSH
10389: CALL_OW 111
// repeat wait ( 0 0$0.3 ) ;
10393: LD_INT 10
10395: PPUSH
10396: CALL_OW 67
// until See ( 1 , veh ) or GetDistUnits ( veh , ar_dep_s ) < 9 ;
10400: LD_INT 1
10402: PPUSH
10403: LD_VAR 0 3
10407: PPUSH
10408: CALL_OW 292
10412: PUSH
10413: LD_VAR 0 3
10417: PPUSH
10418: LD_INT 7
10420: PPUSH
10421: CALL_OW 296
10425: PUSH
10426: LD_INT 9
10428: LESS
10429: OR
10430: IFFALSE 10393
// ComHold ( veh ) ;
10432: LD_VAR 0 3
10436: PPUSH
10437: CALL_OW 140
// Say ( un , D2aa-Ar1-1 ) ;
10441: LD_VAR 0 2
10445: PPUSH
10446: LD_STRING D2aa-Ar1-1
10448: PPUSH
10449: CALL_OW 88
// ComMoveXY ( un , 177 , 96 ) ;
10453: LD_VAR 0 2
10457: PPUSH
10458: LD_INT 177
10460: PPUSH
10461: LD_INT 96
10463: PPUSH
10464: CALL_OW 111
// AddComExitVehicle ( un ) ;
10468: LD_VAR 0 2
10472: PPUSH
10473: CALL_OW 181
// repeat wait ( 0 0$1 ) ;
10477: LD_INT 35
10479: PPUSH
10480: CALL_OW 67
// until GetDistUnits ( un , ar_dep_e ) < 15 ;
10484: LD_VAR 0 2
10488: PPUSH
10489: LD_INT 204
10491: PPUSH
10492: CALL_OW 296
10496: PUSH
10497: LD_INT 15
10499: LESS
10500: IFFALSE 10477
// mc_bases := ReplaceIn ( mc_bases , [ 3 , mc_bases [ 3 ] + 1 ] , un ) ;
10502: LD_ADDR_EXP 50
10506: PUSH
10507: LD_EXP 50
10511: PPUSH
10512: LD_INT 3
10514: PUSH
10515: LD_EXP 50
10519: PUSH
10520: LD_INT 3
10522: ARRAY
10523: PUSH
10524: LD_INT 1
10526: PLUS
10527: PUSH
10528: EMPTY
10529: LIST
10530: LIST
10531: PPUSH
10532: LD_VAR 0 2
10536: PPUSH
10537: CALL 54145 0 3
10541: ST_TO_ADDR
// end ;
10542: PPOPN 3
10544: END
// every 0 0$2 trigger GetSide ( ar_dep_s ) = 1 or IsDead ( ar_dep_s ) do var i , points ;
10545: LD_INT 7
10547: PPUSH
10548: CALL_OW 255
10552: PUSH
10553: LD_INT 1
10555: EQUAL
10556: PUSH
10557: LD_INT 7
10559: PPUSH
10560: CALL_OW 301
10564: OR
10565: IFFALSE 12970
10567: GO 10569
10569: DISABLE
10570: LD_INT 0
10572: PPUSH
10573: PPUSH
// begin for i in UnitFilter ( ar_force_south , [ f_type , unit_building ] ) do
10574: LD_ADDR_VAR 0 1
10578: PUSH
10579: LD_EXP 36
10583: PPUSH
10584: LD_INT 21
10586: PUSH
10587: LD_INT 3
10589: PUSH
10590: EMPTY
10591: LIST
10592: LIST
10593: PPUSH
10594: CALL_OW 72
10598: PUSH
10599: FOR_IN
10600: IFFALSE 10616
// SetSide ( i , 1 ) ;
10602: LD_VAR 0 1
10606: PPUSH
10607: LD_INT 1
10609: PPUSH
10610: CALL_OW 235
10614: GO 10599
10616: POP
10617: POP
// points := [ [ 46 , 41 ] , [ 50 , 25 ] , [ 57 , 75 ] , [ 75 , 89 ] , [ 51 , 45 ] , [ 95 , 95 ] , [ 84 , 77 ] , [ 101 , 76 ] , [ 118 , 81 ] , [ 139 , 97 ] , [ 129 , 114 ] , [ 154 , 111 ] ] ;
10618: LD_ADDR_VAR 0 2
10622: PUSH
10623: LD_INT 46
10625: PUSH
10626: LD_INT 41
10628: PUSH
10629: EMPTY
10630: LIST
10631: LIST
10632: PUSH
10633: LD_INT 50
10635: PUSH
10636: LD_INT 25
10638: PUSH
10639: EMPTY
10640: LIST
10641: LIST
10642: PUSH
10643: LD_INT 57
10645: PUSH
10646: LD_INT 75
10648: PUSH
10649: EMPTY
10650: LIST
10651: LIST
10652: PUSH
10653: LD_INT 75
10655: PUSH
10656: LD_INT 89
10658: PUSH
10659: EMPTY
10660: LIST
10661: LIST
10662: PUSH
10663: LD_INT 51
10665: PUSH
10666: LD_INT 45
10668: PUSH
10669: EMPTY
10670: LIST
10671: LIST
10672: PUSH
10673: LD_INT 95
10675: PUSH
10676: LD_INT 95
10678: PUSH
10679: EMPTY
10680: LIST
10681: LIST
10682: PUSH
10683: LD_INT 84
10685: PUSH
10686: LD_INT 77
10688: PUSH
10689: EMPTY
10690: LIST
10691: LIST
10692: PUSH
10693: LD_INT 101
10695: PUSH
10696: LD_INT 76
10698: PUSH
10699: EMPTY
10700: LIST
10701: LIST
10702: PUSH
10703: LD_INT 118
10705: PUSH
10706: LD_INT 81
10708: PUSH
10709: EMPTY
10710: LIST
10711: LIST
10712: PUSH
10713: LD_INT 139
10715: PUSH
10716: LD_INT 97
10718: PUSH
10719: EMPTY
10720: LIST
10721: LIST
10722: PUSH
10723: LD_INT 129
10725: PUSH
10726: LD_INT 114
10728: PUSH
10729: EMPTY
10730: LIST
10731: LIST
10732: PUSH
10733: LD_INT 154
10735: PUSH
10736: LD_INT 111
10738: PUSH
10739: EMPTY
10740: LIST
10741: LIST
10742: PUSH
10743: EMPTY
10744: LIST
10745: LIST
10746: LIST
10747: LIST
10748: LIST
10749: LIST
10750: LIST
10751: LIST
10752: LIST
10753: LIST
10754: LIST
10755: LIST
10756: ST_TO_ADDR
// base_captured := true ;
10757: LD_ADDR_EXP 6
10761: PUSH
10762: LD_INT 1
10764: ST_TO_ADDR
// DialogueOn ;
10765: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
10769: LD_EXP 21
10773: PPUSH
10774: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
10778: LD_EXP 21
10782: PPUSH
10783: LD_STRING D2-JMM-1
10785: PPUSH
10786: CALL_OW 88
// SayRadio ( Powell , D2-Pow-1 ) ;
10790: LD_EXP 30
10794: PPUSH
10795: LD_STRING D2-Pow-1
10797: PPUSH
10798: CALL_OW 94
// Say ( JMM , D2-JMM-2 ) ;
10802: LD_EXP 21
10806: PPUSH
10807: LD_STRING D2-JMM-2
10809: PPUSH
10810: CALL_OW 88
// SayRadio ( Powell , D2-Pow-2 ) ;
10814: LD_EXP 30
10818: PPUSH
10819: LD_STRING D2-Pow-2
10821: PPUSH
10822: CALL_OW 94
// Say ( JMM , D2-JMM-3 ) ;
10826: LD_EXP 21
10830: PPUSH
10831: LD_STRING D2-JMM-3
10833: PPUSH
10834: CALL_OW 88
// DialogueOff ;
10838: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
10842: LD_STRING M2
10844: PPUSH
10845: CALL_OW 337
// Wait ( 0 0$2 ) ;
10849: LD_INT 70
10851: PPUSH
10852: CALL_OW 67
// if IsOk ( Gary ) then
10856: LD_EXP 32
10860: PPUSH
10861: CALL_OW 302
10865: IFFALSE 10879
// Say ( Gary , D2a-Gary-1 ) ;
10867: LD_EXP 32
10871: PPUSH
10872: LD_STRING D2a-Gary-1
10874: PPUSH
10875: CALL_OW 88
// if IsOk ( Bobby ) then
10879: LD_EXP 24
10883: PPUSH
10884: CALL_OW 302
10888: IFFALSE 10902
// Say ( Bobby , D2a-Bobby-1 ) ;
10890: LD_EXP 24
10894: PPUSH
10895: LD_STRING D2a-Bobby-1
10897: PPUSH
10898: CALL_OW 88
// if IsOk ( Cyrus ) then
10902: LD_EXP 25
10906: PPUSH
10907: CALL_OW 302
10911: IFFALSE 10925
// Say ( Cyrus , D2a-Cyrus-1 ) ;
10913: LD_EXP 25
10917: PPUSH
10918: LD_STRING D2a-Cyrus-1
10920: PPUSH
10921: CALL_OW 88
// if IsOk ( Lisa ) then
10925: LD_EXP 22
10929: PPUSH
10930: CALL_OW 302
10934: IFFALSE 10948
// Say ( Lisa , D2a-Lisa-1 ) ;
10936: LD_EXP 22
10940: PPUSH
10941: LD_STRING D2a-Lisa-1
10943: PPUSH
10944: CALL_OW 88
// if IsOk ( Frank ) then
10948: LD_EXP 33
10952: PPUSH
10953: CALL_OW 302
10957: IFFALSE 10971
// Say ( Frank , D2a-Frank-1 ) ;
10959: LD_EXP 33
10963: PPUSH
10964: LD_STRING D2a-Frank-1
10966: PPUSH
10967: CALL_OW 88
// if IsOk ( Cornel ) then
10971: LD_EXP 31
10975: PPUSH
10976: CALL_OW 302
10980: IFFALSE 10994
// Say ( Cornel , D2a-Corn-1 ) ;
10982: LD_EXP 31
10986: PPUSH
10987: LD_STRING D2a-Corn-1
10989: PPUSH
10990: CALL_OW 88
// if IsOk ( Donaldson ) then
10994: LD_EXP 23
10998: PPUSH
10999: CALL_OW 302
11003: IFFALSE 11017
// Say ( Donaldson , D2a-Don-1 ) ;
11005: LD_EXP 23
11009: PPUSH
11010: LD_STRING D2a-Don-1
11012: PPUSH
11013: CALL_OW 88
// if IsOk ( Brown ) then
11017: LD_EXP 27
11021: PPUSH
11022: CALL_OW 302
11026: IFFALSE 11040
// Say ( Brown , D2a-Brown-1 ) ;
11028: LD_EXP 27
11032: PPUSH
11033: LD_STRING D2a-Brown-1
11035: PPUSH
11036: CALL_OW 88
// Wait ( 0 0$30 ) ;
11040: LD_INT 1050
11042: PPUSH
11043: CALL_OW 67
// if IsOk ( Frank ) then
11047: LD_EXP 33
11051: PPUSH
11052: CALL_OW 302
11056: IFFALSE 12036
// begin DialogueOn ;
11058: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Frank ] ) ;
11062: LD_EXP 21
11066: PUSH
11067: LD_EXP 33
11071: PUSH
11072: EMPTY
11073: LIST
11074: LIST
11075: PPUSH
11076: CALL_OW 87
// Say ( Frank , D3F-Frank-1 ) ;
11080: LD_EXP 33
11084: PPUSH
11085: LD_STRING D3F-Frank-1
11087: PPUSH
11088: CALL_OW 88
// Say ( JMM , D3F-JMM-1 ) ;
11092: LD_EXP 21
11096: PPUSH
11097: LD_STRING D3F-JMM-1
11099: PPUSH
11100: CALL_OW 88
// Say ( Frank , D3F-Frank-2 ) ;
11104: LD_EXP 33
11108: PPUSH
11109: LD_STRING D3F-Frank-2
11111: PPUSH
11112: CALL_OW 88
// case Query ( QFrank ) of 1 :
11116: LD_STRING QFrank
11118: PPUSH
11119: CALL_OW 97
11123: PUSH
11124: LD_INT 1
11126: DOUBLE
11127: EQUAL
11128: IFTRUE 11132
11130: GO 11155
11132: POP
// begin Say ( JMM , D3Fa-JMM-1 ) ;
11133: LD_EXP 21
11137: PPUSH
11138: LD_STRING D3Fa-JMM-1
11140: PPUSH
11141: CALL_OW 88
// us_scout := 1 ;
11145: LD_ADDR_EXP 8
11149: PUSH
11150: LD_INT 1
11152: ST_TO_ADDR
// end ; 2 :
11153: GO 11318
11155: LD_INT 2
11157: DOUBLE
11158: EQUAL
11159: IFTRUE 11163
11161: GO 11285
11163: POP
// begin Say ( JMM , D3Fb-JMM-1 ) ;
11164: LD_EXP 21
11168: PPUSH
11169: LD_STRING D3Fb-JMM-1
11171: PPUSH
11172: CALL_OW 88
// Say ( Frank , D3Fb-Frank-1 ) ;
11176: LD_EXP 33
11180: PPUSH
11181: LD_STRING D3Fb-Frank-1
11183: PPUSH
11184: CALL_OW 88
// case Query ( QFrank2 ) of 1 :
11188: LD_STRING QFrank2
11190: PPUSH
11191: CALL_OW 97
11195: PUSH
11196: LD_INT 1
11198: DOUBLE
11199: EQUAL
11200: IFTRUE 11204
11202: GO 11251
11204: POP
// begin us_scout := 2 ;
11205: LD_ADDR_EXP 8
11209: PUSH
11210: LD_INT 2
11212: ST_TO_ADDR
// Say ( JMM , D3Fba-JMM-1 ) ;
11213: LD_EXP 21
11217: PPUSH
11218: LD_STRING D3Fba-JMM-1
11220: PPUSH
11221: CALL_OW 88
// Say ( Frank , D3Fba-Frank-1 ) ;
11225: LD_EXP 33
11229: PPUSH
11230: LD_STRING D3Fba-Frank-1
11232: PPUSH
11233: CALL_OW 88
// Say ( JMM , D3Fba-JMM-2 ) ;
11237: LD_EXP 21
11241: PPUSH
11242: LD_STRING D3Fba-JMM-2
11244: PPUSH
11245: CALL_OW 88
// end ; 2 :
11249: GO 11283
11251: LD_INT 2
11253: DOUBLE
11254: EQUAL
11255: IFTRUE 11259
11257: GO 11282
11259: POP
// begin us_scout := 0 ;
11260: LD_ADDR_EXP 8
11264: PUSH
11265: LD_INT 0
11267: ST_TO_ADDR
// Say ( JMM , D3Fbb-JMM-1 ) ;
11268: LD_EXP 21
11272: PPUSH
11273: LD_STRING D3Fbb-JMM-1
11275: PPUSH
11276: CALL_OW 88
// end ; end ;
11280: GO 11283
11282: POP
// end ; 3 :
11283: GO 11318
11285: LD_INT 3
11287: DOUBLE
11288: EQUAL
11289: IFTRUE 11293
11291: GO 11317
11293: POP
// begin us_scout := - 1 ;
11294: LD_ADDR_EXP 8
11298: PUSH
11299: LD_INT 1
11301: NEG
11302: ST_TO_ADDR
// Say ( JMM , D3Fc-JMM-1 ) ;
11303: LD_EXP 21
11307: PPUSH
11308: LD_STRING D3Fc-JMM-1
11310: PPUSH
11311: CALL_OW 88
// end ; end ;
11315: GO 11318
11317: POP
// DialogueOff ;
11318: CALL_OW 7
// if us_scout in [ - 1 , 0 ] then
11322: LD_EXP 8
11326: PUSH
11327: LD_INT 1
11329: NEG
11330: PUSH
11331: LD_INT 0
11333: PUSH
11334: EMPTY
11335: LIST
11336: LIST
11337: IN
11338: IFFALSE 11342
// exit ;
11340: GO 12970
// if us_scout in [ 1 , 2 ] then
11342: LD_EXP 8
11346: PUSH
11347: LD_INT 1
11349: PUSH
11350: LD_INT 2
11352: PUSH
11353: EMPTY
11354: LIST
11355: LIST
11356: IN
11357: IFFALSE 12036
// begin if IsInUnit ( Frank ) then
11359: LD_EXP 33
11363: PPUSH
11364: CALL_OW 310
11368: IFFALSE 11379
// ComExit ( Frank ) ;
11370: LD_EXP 33
11374: PPUSH
11375: CALL 87272 0 1
// SetSide ( Frank , 4 ) ;
11379: LD_EXP 33
11383: PPUSH
11384: LD_INT 4
11386: PPUSH
11387: CALL_OW 235
// wait ( 0 0$1 ) ;
11391: LD_INT 35
11393: PPUSH
11394: CALL_OW 67
// if us_scout = 2 then
11398: LD_EXP 8
11402: PUSH
11403: LD_INT 2
11405: EQUAL
11406: IFFALSE 11774
// begin ComMoveXY ( Frank , 75 , 63 ) ;
11408: LD_EXP 33
11412: PPUSH
11413: LD_INT 75
11415: PPUSH
11416: LD_INT 63
11418: PPUSH
11419: CALL_OW 111
// AddComHold ( Frank ) ;
11423: LD_EXP 33
11427: PPUSH
11428: CALL_OW 200
// AddComWait ( Frank , 0 0$22 ) ;
11432: LD_EXP 33
11436: PPUSH
11437: LD_INT 770
11439: PPUSH
11440: CALL_OW 202
// AddComMoveXY ( Frank , 100 , 75 ) ;
11444: LD_EXP 33
11448: PPUSH
11449: LD_INT 100
11451: PPUSH
11452: LD_INT 75
11454: PPUSH
11455: CALL_OW 171
// AddComMoveXY ( Frank , 123 , 103 ) ;
11459: LD_EXP 33
11463: PPUSH
11464: LD_INT 123
11466: PPUSH
11467: LD_INT 103
11469: PPUSH
11470: CALL_OW 171
// AddComMoveXY ( Frank , 138 , 108 ) ;
11474: LD_EXP 33
11478: PPUSH
11479: LD_INT 138
11481: PPUSH
11482: LD_INT 108
11484: PPUSH
11485: CALL_OW 171
// AddComHold ( Frank ) ;
11489: LD_EXP 33
11493: PPUSH
11494: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
11498: LD_INT 35
11500: PPUSH
11501: CALL_OW 67
// until IsAt ( Frank , 138 , 108 ) ;
11505: LD_EXP 33
11509: PPUSH
11510: LD_INT 138
11512: PPUSH
11513: LD_INT 108
11515: PPUSH
11516: CALL_OW 307
11520: IFFALSE 11498
// AddComMoveXY ( Frank , 125 , 132 ) ;
11522: LD_EXP 33
11526: PPUSH
11527: LD_INT 125
11529: PPUSH
11530: LD_INT 132
11532: PPUSH
11533: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11537: LD_INT 35
11539: PPUSH
11540: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 7 ;
11544: LD_INT 1
11546: PPUSH
11547: LD_EXP 33
11551: PPUSH
11552: CALL_OW 292
11556: PUSH
11557: LD_EXP 33
11561: PPUSH
11562: LD_INT 7
11564: PPUSH
11565: CALL_OW 296
11569: PUSH
11570: LD_INT 7
11572: LESS
11573: OR
11574: IFFALSE 11537
// DialogueOn ;
11576: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11580: LD_EXP 33
11584: PPUSH
11585: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
11589: LD_INT 10
11591: PPUSH
11592: CALL_OW 68
// Say ( JMM , D4Fa-JMM-1 ) ;
11596: LD_EXP 21
11600: PPUSH
11601: LD_STRING D4Fa-JMM-1
11603: PPUSH
11604: CALL_OW 88
// for i in points do
11608: LD_ADDR_VAR 0 1
11612: PUSH
11613: LD_VAR 0 2
11617: PUSH
11618: FOR_IN
11619: IFFALSE 11677
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
11621: LD_VAR 0 1
11625: PUSH
11626: LD_INT 1
11628: ARRAY
11629: PPUSH
11630: LD_VAR 0 1
11634: PUSH
11635: LD_INT 2
11637: ARRAY
11638: PPUSH
11639: LD_INT 1
11641: PPUSH
11642: LD_INT 20
11644: NEG
11645: PPUSH
11646: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
11650: LD_VAR 0 1
11654: PUSH
11655: LD_INT 1
11657: ARRAY
11658: PPUSH
11659: LD_VAR 0 1
11663: PUSH
11664: LD_INT 2
11666: ARRAY
11667: PPUSH
11668: LD_INT 1
11670: PPUSH
11671: CALL_OW 331
// end ;
11675: GO 11618
11677: POP
11678: POP
// dwait ( 0 0$0.5 ) ;
11679: LD_INT 18
11681: PPUSH
11682: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
11686: LD_INT 42
11688: PPUSH
11689: LD_INT 27
11691: PPUSH
11692: CALL_OW 84
// Say ( Frank , D4Fa-Frank-1 ) ;
11696: LD_EXP 33
11700: PPUSH
11701: LD_STRING D4Fa-Frank-1
11703: PPUSH
11704: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
11708: LD_INT 18
11710: PPUSH
11711: CALL_OW 68
// Say ( JMM , D4Fa-JMM-2 ) ;
11715: LD_EXP 21
11719: PPUSH
11720: LD_STRING D4Fa-JMM-2
11722: PPUSH
11723: CALL_OW 88
// CenterNowOnXY ( 118 , 80 ) ;
11727: LD_INT 118
11729: PPUSH
11730: LD_INT 80
11732: PPUSH
11733: CALL_OW 86
// Say ( Frank , D4Fa-Frank-2 ) ;
11737: LD_EXP 33
11741: PPUSH
11742: LD_STRING D4Fa-Frank-2
11744: PPUSH
11745: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
11749: LD_INT 10
11751: PPUSH
11752: CALL_OW 68
// DialogueOff ;
11756: CALL_OW 7
// SetSide ( Frank , 1 ) ;
11760: LD_EXP 33
11764: PPUSH
11765: LD_INT 1
11767: PPUSH
11768: CALL_OW 235
// end else
11772: GO 12036
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
11774: LD_INT 2
11776: PPUSH
11777: LD_INT 4
11779: PPUSH
11780: LD_INT 2
11782: PPUSH
11783: LD_INT 1
11785: PPUSH
11786: CALL_OW 80
// ComMoveXY ( Frank , 75 , 63 ) ;
11790: LD_EXP 33
11794: PPUSH
11795: LD_INT 75
11797: PPUSH
11798: LD_INT 63
11800: PPUSH
11801: CALL_OW 111
// AddComWait ( Frank , 0 0$5 ) ;
11805: LD_EXP 33
11809: PPUSH
11810: LD_INT 175
11812: PPUSH
11813: CALL_OW 202
// AddComMoveXY ( Frank , 102 , 76 ) ;
11817: LD_EXP 33
11821: PPUSH
11822: LD_INT 102
11824: PPUSH
11825: LD_INT 76
11827: PPUSH
11828: CALL_OW 171
// AddComMoveXY ( Frank , 108 , 70 ) ;
11832: LD_EXP 33
11836: PPUSH
11837: LD_INT 108
11839: PPUSH
11840: LD_INT 70
11842: PPUSH
11843: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11847: LD_INT 35
11849: PPUSH
11850: CALL_OW 67
// until See ( 2 , Frank ) ;
11854: LD_INT 2
11856: PPUSH
11857: LD_EXP 33
11861: PPUSH
11862: CALL_OW 292
11866: IFFALSE 11847
// ComMoveXY ( Frank , 112 , 118 ) ;
11868: LD_EXP 33
11872: PPUSH
11873: LD_INT 112
11875: PPUSH
11876: LD_INT 118
11878: PPUSH
11879: CALL_OW 111
// if GetLives ( Frank ) >= 750 then
11883: LD_EXP 33
11887: PPUSH
11888: CALL_OW 256
11892: PUSH
11893: LD_INT 750
11895: GREATEREQUAL
11896: IFFALSE 11910
// SetLives ( Frank , 700 ) ;
11898: LD_EXP 33
11902: PPUSH
11903: LD_INT 700
11905: PPUSH
11906: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
11910: LD_INT 35
11912: PPUSH
11913: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 17 ;
11917: LD_INT 1
11919: PPUSH
11920: LD_EXP 33
11924: PPUSH
11925: CALL_OW 292
11929: PUSH
11930: LD_EXP 33
11934: PPUSH
11935: LD_INT 7
11937: PPUSH
11938: CALL_OW 296
11942: PUSH
11943: LD_INT 17
11945: LESS
11946: OR
11947: IFFALSE 11910
// DialogueOn ;
11949: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11953: LD_EXP 33
11957: PPUSH
11958: CALL_OW 87
// Say ( Frank , D4Fb-Frank-1 ) ;
11962: LD_EXP 33
11966: PPUSH
11967: LD_STRING D4Fb-Frank-1
11969: PPUSH
11970: CALL_OW 88
// Say ( JMM , D4Fb-JMM-1 ) ;
11974: LD_EXP 21
11978: PPUSH
11979: LD_STRING D4Fb-JMM-1
11981: PPUSH
11982: CALL_OW 88
// SayRand ( sex_female , D4Fb-FSci1-1 ) ;
11986: LD_INT 2
11988: PPUSH
11989: LD_STRING D4Fb-FSci1-1
11991: PPUSH
11992: CALL 17025 0 2
// Say ( Frank , D4Fb-Frank-2 ) ;
11996: LD_EXP 33
12000: PPUSH
12001: LD_STRING D4Fb-Frank-2
12003: PPUSH
12004: CALL_OW 88
// Say ( JMM , D4Fb-JMM-2 ) ;
12008: LD_EXP 21
12012: PPUSH
12013: LD_STRING D4Fb-JMM-2
12015: PPUSH
12016: CALL_OW 88
// DialogueOff ;
12020: CALL_OW 7
// SetSide ( Frank , 1 ) ;
12024: LD_EXP 33
12028: PPUSH
12029: LD_INT 1
12031: PPUSH
12032: CALL_OW 235
// end ; end ; end ; if IsOk ( Kikuchi ) and not IsOk ( Frank ) then
12036: LD_EXP 34
12040: PPUSH
12041: CALL_OW 302
12045: PUSH
12046: LD_EXP 33
12050: PPUSH
12051: CALL_OW 302
12055: NOT
12056: AND
12057: IFFALSE 12970
// begin DialogueOn ;
12059: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Kikuchi ] ) ;
12063: LD_EXP 21
12067: PUSH
12068: LD_EXP 34
12072: PUSH
12073: EMPTY
12074: LIST
12075: LIST
12076: PPUSH
12077: CALL_OW 87
// Say ( Kikuchi , D3Y-Yam-1 ) ;
12081: LD_EXP 34
12085: PPUSH
12086: LD_STRING D3Y-Yam-1
12088: PPUSH
12089: CALL_OW 88
// Say ( JMM , D3Y-JMM-1 ) ;
12093: LD_EXP 21
12097: PPUSH
12098: LD_STRING D3Y-JMM-1
12100: PPUSH
12101: CALL_OW 88
// Say ( Kikuchi , D3Y-Yam-2 ) ;
12105: LD_EXP 34
12109: PPUSH
12110: LD_STRING D3Y-Yam-2
12112: PPUSH
12113: CALL_OW 88
// case Query ( QYamoko ) of 1 :
12117: LD_STRING QYamoko
12119: PPUSH
12120: CALL_OW 97
12124: PUSH
12125: LD_INT 1
12127: DOUBLE
12128: EQUAL
12129: IFTRUE 12133
12131: GO 12168
12133: POP
// begin Say ( JMM , D3Ya-JMM-1 ) ;
12134: LD_EXP 21
12138: PPUSH
12139: LD_STRING D3Ya-JMM-1
12141: PPUSH
12142: CALL_OW 88
// Say ( Kikuchi , D3Ya-Yam-1 ) ;
12146: LD_EXP 34
12150: PPUSH
12151: LD_STRING D3Ya-Yam-1
12153: PPUSH
12154: CALL_OW 88
// us_scout := 1 ;
12158: LD_ADDR_EXP 8
12162: PUSH
12163: LD_INT 1
12165: ST_TO_ADDR
// end ; 2 :
12166: GO 12201
12168: LD_INT 2
12170: DOUBLE
12171: EQUAL
12172: IFTRUE 12176
12174: GO 12200
12176: POP
// begin us_scout := - 1 ;
12177: LD_ADDR_EXP 8
12181: PUSH
12182: LD_INT 1
12184: NEG
12185: ST_TO_ADDR
// Say ( JMM , D3Yb-JMM-1 ) ;
12186: LD_EXP 21
12190: PPUSH
12191: LD_STRING D3Yb-JMM-1
12193: PPUSH
12194: CALL_OW 88
// end ; end ;
12198: GO 12201
12200: POP
// DialogueOff ;
12201: CALL_OW 7
// if us_scout in [ - 1 , 0 ] then
12205: LD_EXP 8
12209: PUSH
12210: LD_INT 1
12212: NEG
12213: PUSH
12214: LD_INT 0
12216: PUSH
12217: EMPTY
12218: LIST
12219: LIST
12220: IN
12221: IFFALSE 12225
// exit ;
12223: GO 12970
// us_scout := [ 2 , 2 , 1 , 1 ] [ Difficulty ] ;
12225: LD_ADDR_EXP 8
12229: PUSH
12230: LD_INT 2
12232: PUSH
12233: LD_INT 2
12235: PUSH
12236: LD_INT 1
12238: PUSH
12239: LD_INT 1
12241: PUSH
12242: EMPTY
12243: LIST
12244: LIST
12245: LIST
12246: LIST
12247: PUSH
12248: LD_OWVAR 67
12252: ARRAY
12253: ST_TO_ADDR
// if us_scout in [ 1 , 2 ] then
12254: LD_EXP 8
12258: PUSH
12259: LD_INT 1
12261: PUSH
12262: LD_INT 2
12264: PUSH
12265: EMPTY
12266: LIST
12267: LIST
12268: IN
12269: IFFALSE 12970
// begin if IsInUnit ( Kikuchi ) then
12271: LD_EXP 34
12275: PPUSH
12276: CALL_OW 310
12280: IFFALSE 12291
// ComExitBuilding ( Kikuchi ) ;
12282: LD_EXP 34
12286: PPUSH
12287: CALL_OW 122
// if IsDrivenBy ( Kikuchi ) then
12291: LD_EXP 34
12295: PPUSH
12296: CALL_OW 311
12300: IFFALSE 12311
// ComExitVehicle ( Kikuchi ) ;
12302: LD_EXP 34
12306: PPUSH
12307: CALL_OW 121
// SetSide ( Kikuchi , 4 ) ;
12311: LD_EXP 34
12315: PPUSH
12316: LD_INT 4
12318: PPUSH
12319: CALL_OW 235
// wait ( 0 0$1 ) ;
12323: LD_INT 35
12325: PPUSH
12326: CALL_OW 67
// if us_scout = 2 then
12330: LD_EXP 8
12334: PUSH
12335: LD_INT 2
12337: EQUAL
12338: IFFALSE 12718
// begin ComMoveXY ( Kikuchi , 75 , 63 ) ;
12340: LD_EXP 34
12344: PPUSH
12345: LD_INT 75
12347: PPUSH
12348: LD_INT 63
12350: PPUSH
12351: CALL_OW 111
// AddComHold ( Kikuchi ) ;
12355: LD_EXP 34
12359: PPUSH
12360: CALL_OW 200
// AddComWait ( Kikuchi , 0 0$22 ) ;
12364: LD_EXP 34
12368: PPUSH
12369: LD_INT 770
12371: PPUSH
12372: CALL_OW 202
// AddComMoveXY ( Kikuchi , 100 , 75 ) ;
12376: LD_EXP 34
12380: PPUSH
12381: LD_INT 100
12383: PPUSH
12384: LD_INT 75
12386: PPUSH
12387: CALL_OW 171
// AddComMoveXY ( Kikuchi , 123 , 103 ) ;
12391: LD_EXP 34
12395: PPUSH
12396: LD_INT 123
12398: PPUSH
12399: LD_INT 103
12401: PPUSH
12402: CALL_OW 171
// AddComMoveXY ( Kikuchi , 138 , 108 ) ;
12406: LD_EXP 34
12410: PPUSH
12411: LD_INT 138
12413: PPUSH
12414: LD_INT 108
12416: PPUSH
12417: CALL_OW 171
// AddComHold ( Kikuchi ) ;
12421: LD_EXP 34
12425: PPUSH
12426: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
12430: LD_INT 35
12432: PPUSH
12433: CALL_OW 67
// until IsAt ( Kikuchi , 138 , 108 ) ;
12437: LD_EXP 34
12441: PPUSH
12442: LD_INT 138
12444: PPUSH
12445: LD_INT 108
12447: PPUSH
12448: CALL_OW 307
12452: IFFALSE 12430
// AddComMoveXY ( Kikuchi , 125 , 132 ) ;
12454: LD_EXP 34
12458: PPUSH
12459: LD_INT 125
12461: PPUSH
12462: LD_INT 132
12464: PPUSH
12465: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12469: LD_INT 35
12471: PPUSH
12472: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 7 ;
12476: LD_INT 1
12478: PPUSH
12479: LD_EXP 34
12483: PPUSH
12484: CALL_OW 292
12488: PUSH
12489: LD_EXP 34
12493: PPUSH
12494: LD_INT 7
12496: PPUSH
12497: CALL_OW 296
12501: PUSH
12502: LD_INT 7
12504: LESS
12505: OR
12506: IFFALSE 12469
// DialogueOn ;
12508: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12512: LD_EXP 34
12516: PPUSH
12517: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12521: LD_INT 10
12523: PPUSH
12524: CALL_OW 68
// Say ( Kikuchi , D4Ya-Yam-1 ) ;
12528: LD_EXP 34
12532: PPUSH
12533: LD_STRING D4Ya-Yam-1
12535: PPUSH
12536: CALL_OW 88
// Say ( JMM , D4Ya-JMM-1 ) ;
12540: LD_EXP 21
12544: PPUSH
12545: LD_STRING D4Ya-JMM-1
12547: PPUSH
12548: CALL_OW 88
// for i in points do
12552: LD_ADDR_VAR 0 1
12556: PUSH
12557: LD_VAR 0 2
12561: PUSH
12562: FOR_IN
12563: IFFALSE 12621
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
12565: LD_VAR 0 1
12569: PUSH
12570: LD_INT 1
12572: ARRAY
12573: PPUSH
12574: LD_VAR 0 1
12578: PUSH
12579: LD_INT 2
12581: ARRAY
12582: PPUSH
12583: LD_INT 1
12585: PPUSH
12586: LD_INT 20
12588: NEG
12589: PPUSH
12590: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
12594: LD_VAR 0 1
12598: PUSH
12599: LD_INT 1
12601: ARRAY
12602: PPUSH
12603: LD_VAR 0 1
12607: PUSH
12608: LD_INT 2
12610: ARRAY
12611: PPUSH
12612: LD_INT 1
12614: PPUSH
12615: CALL_OW 331
// end ;
12619: GO 12562
12621: POP
12622: POP
// dwait ( 0 0$0.5 ) ;
12623: LD_INT 18
12625: PPUSH
12626: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
12630: LD_INT 42
12632: PPUSH
12633: LD_INT 27
12635: PPUSH
12636: CALL_OW 84
// Say ( Kikuchi , D4Ya-Yam-2 ) ;
12640: LD_EXP 34
12644: PPUSH
12645: LD_STRING D4Ya-Yam-2
12647: PPUSH
12648: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
12652: LD_INT 18
12654: PPUSH
12655: CALL_OW 68
// CenterNowOnXY ( 118 , 80 ) ;
12659: LD_INT 118
12661: PPUSH
12662: LD_INT 80
12664: PPUSH
12665: CALL_OW 86
// Say ( JMM , D4Ya-JMM-2 ) ;
12669: LD_EXP 21
12673: PPUSH
12674: LD_STRING D4Ya-JMM-2
12676: PPUSH
12677: CALL_OW 88
// Say ( Kikuchi , D4Ya-Yam-3 ) ;
12681: LD_EXP 34
12685: PPUSH
12686: LD_STRING D4Ya-Yam-3
12688: PPUSH
12689: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
12693: LD_INT 10
12695: PPUSH
12696: CALL_OW 68
// DialogueOff ;
12700: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12704: LD_EXP 34
12708: PPUSH
12709: LD_INT 1
12711: PPUSH
12712: CALL_OW 235
// end else
12716: GO 12970
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
12718: LD_INT 2
12720: PPUSH
12721: LD_INT 4
12723: PPUSH
12724: LD_INT 2
12726: PPUSH
12727: LD_INT 1
12729: PPUSH
12730: CALL_OW 80
// ComMoveXY ( Kikuchi , 75 , 63 ) ;
12734: LD_EXP 34
12738: PPUSH
12739: LD_INT 75
12741: PPUSH
12742: LD_INT 63
12744: PPUSH
12745: CALL_OW 111
// AddComWait ( Kikuchi , 0 0$5 ) ;
12749: LD_EXP 34
12753: PPUSH
12754: LD_INT 175
12756: PPUSH
12757: CALL_OW 202
// AddComMoveXY ( Kikuchi , 102 , 76 ) ;
12761: LD_EXP 34
12765: PPUSH
12766: LD_INT 102
12768: PPUSH
12769: LD_INT 76
12771: PPUSH
12772: CALL_OW 171
// AddComMoveXY ( Kikuchi , 108 , 70 ) ;
12776: LD_EXP 34
12780: PPUSH
12781: LD_INT 108
12783: PPUSH
12784: LD_INT 70
12786: PPUSH
12787: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12791: LD_INT 35
12793: PPUSH
12794: CALL_OW 67
// until See ( 2 , Kikuchi ) ;
12798: LD_INT 2
12800: PPUSH
12801: LD_EXP 34
12805: PPUSH
12806: CALL_OW 292
12810: IFFALSE 12791
// ComMoveXY ( Kikuchi , 112 , 118 ) ;
12812: LD_EXP 34
12816: PPUSH
12817: LD_INT 112
12819: PPUSH
12820: LD_INT 118
12822: PPUSH
12823: CALL_OW 111
// if GetLives ( Kikuchi ) >= 750 then
12827: LD_EXP 34
12831: PPUSH
12832: CALL_OW 256
12836: PUSH
12837: LD_INT 750
12839: GREATEREQUAL
12840: IFFALSE 12854
// SetLives ( Kikuchi , 700 ) ;
12842: LD_EXP 34
12846: PPUSH
12847: LD_INT 700
12849: PPUSH
12850: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
12854: LD_INT 35
12856: PPUSH
12857: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 17 ;
12861: LD_INT 1
12863: PPUSH
12864: LD_EXP 34
12868: PPUSH
12869: CALL_OW 292
12873: PUSH
12874: LD_EXP 34
12878: PPUSH
12879: LD_INT 7
12881: PPUSH
12882: CALL_OW 296
12886: PUSH
12887: LD_INT 17
12889: LESS
12890: OR
12891: IFFALSE 12854
// DialogueOn ;
12893: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12897: LD_EXP 34
12901: PPUSH
12902: CALL_OW 87
// Say ( Kikuchi , D4Yb-Yam-1 ) ;
12906: LD_EXP 34
12910: PPUSH
12911: LD_STRING D4Yb-Yam-1
12913: PPUSH
12914: CALL_OW 88
// Say ( JMM , D4Yb-JMM-1 ) ;
12918: LD_EXP 21
12922: PPUSH
12923: LD_STRING D4Yb-JMM-1
12925: PPUSH
12926: CALL_OW 88
// Say ( Kikuchi , D4Yb-Yam-2 ) ;
12930: LD_EXP 34
12934: PPUSH
12935: LD_STRING D4Yb-Yam-2
12937: PPUSH
12938: CALL_OW 88
// Say ( JMM , D4Yb-JMM-2 ) ;
12942: LD_EXP 21
12946: PPUSH
12947: LD_STRING D4Yb-JMM-2
12949: PPUSH
12950: CALL_OW 88
// DialogueOff ;
12954: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12958: LD_EXP 34
12962: PPUSH
12963: LD_INT 1
12965: PPUSH
12966: CALL_OW 235
// end ; end ; end ; end ;
12970: PPOPN 2
12972: END
// every 0 0$01 trigger base_captured do var i , tmp , un , un2 ;
12973: LD_EXP 6
12977: IFFALSE 14010
12979: GO 12981
12981: DISABLE
12982: LD_INT 0
12984: PPUSH
12985: PPUSH
12986: PPUSH
12987: PPUSH
// begin enable ;
12988: ENABLE
// if not seen [ 1 ] then
12989: LD_EXP 9
12993: PUSH
12994: LD_INT 1
12996: ARRAY
12997: NOT
12998: IFFALSE 13178
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 11 ] , [ f_control , control_rider ] ] ] ) ;
13000: LD_ADDR_VAR 0 2
13004: PUSH
13005: LD_INT 22
13007: PUSH
13008: LD_INT 2
13010: PUSH
13011: EMPTY
13012: LIST
13013: LIST
13014: PUSH
13015: LD_INT 2
13017: PUSH
13018: LD_INT 25
13020: PUSH
13021: LD_INT 11
13023: PUSH
13024: EMPTY
13025: LIST
13026: LIST
13027: PUSH
13028: LD_INT 33
13030: PUSH
13031: LD_INT 4
13033: PUSH
13034: EMPTY
13035: LIST
13036: LIST
13037: PUSH
13038: EMPTY
13039: LIST
13040: LIST
13041: LIST
13042: PUSH
13043: EMPTY
13044: LIST
13045: LIST
13046: PPUSH
13047: CALL_OW 69
13051: ST_TO_ADDR
// if tmp then
13052: LD_VAR 0 2
13056: IFFALSE 13178
// for i in tmp do
13058: LD_ADDR_VAR 0 1
13062: PUSH
13063: LD_VAR 0 2
13067: PUSH
13068: FOR_IN
13069: IFFALSE 13176
// if See ( 1 , i ) then
13071: LD_INT 1
13073: PPUSH
13074: LD_VAR 0 1
13078: PPUSH
13079: CALL_OW 292
13083: IFFALSE 13174
// begin seen := Replace ( seen , 1 , true ) ;
13085: LD_ADDR_EXP 9
13089: PUSH
13090: LD_EXP 9
13094: PPUSH
13095: LD_INT 1
13097: PPUSH
13098: LD_INT 1
13100: PPUSH
13101: CALL_OW 1
13105: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13106: LD_INT 1
13108: PPUSH
13109: CALL 16847 0 1
13113: IFFALSE 13174
// begin DialogueOn ;
13115: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13119: LD_VAR 0 1
13123: PPUSH
13124: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13128: LD_INT 10
13130: PPUSH
13131: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol2-1 ) ;
13135: LD_ADDR_VAR 0 3
13139: PUSH
13140: LD_INT 1
13142: PPUSH
13143: LD_STRING D5a-Sol2-1
13145: PPUSH
13146: CALL 17025 0 2
13150: ST_TO_ADDR
// if not un then
13151: LD_VAR 0 3
13155: NOT
13156: IFFALSE 13168
// SayRand ( sex_female , D5a-FSol2-1 ) ;
13158: LD_INT 2
13160: PPUSH
13161: LD_STRING D5a-FSol2-1
13163: PPUSH
13164: CALL 17025 0 2
// DialogueOff ;
13168: CALL_OW 7
// break ;
13172: GO 13176
// end ; end ;
13174: GO 13068
13176: POP
13177: POP
// end ; if not seen [ 2 ] then
13178: LD_EXP 9
13182: PUSH
13183: LD_INT 2
13185: ARRAY
13186: NOT
13187: IFFALSE 13412
// begin can_kamikazed := true ;
13189: LD_ADDR_EXP 10
13193: PUSH
13194: LD_INT 1
13196: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 17 ] ] ) ;
13197: LD_ADDR_VAR 0 2
13201: PUSH
13202: LD_INT 22
13204: PUSH
13205: LD_INT 2
13207: PUSH
13208: EMPTY
13209: LIST
13210: LIST
13211: PUSH
13212: LD_INT 25
13214: PUSH
13215: LD_INT 17
13217: PUSH
13218: EMPTY
13219: LIST
13220: LIST
13221: PUSH
13222: EMPTY
13223: LIST
13224: LIST
13225: PPUSH
13226: CALL_OW 69
13230: ST_TO_ADDR
// if tmp then
13231: LD_VAR 0 2
13235: IFFALSE 13412
// for i in tmp do
13237: LD_ADDR_VAR 0 1
13241: PUSH
13242: LD_VAR 0 2
13246: PUSH
13247: FOR_IN
13248: IFFALSE 13410
// if See ( 1 , i ) then
13250: LD_INT 1
13252: PPUSH
13253: LD_VAR 0 1
13257: PPUSH
13258: CALL_OW 292
13262: IFFALSE 13408
// begin seen := Replace ( seen , 2 , true ) ;
13264: LD_ADDR_EXP 9
13268: PUSH
13269: LD_EXP 9
13273: PPUSH
13274: LD_INT 2
13276: PPUSH
13277: LD_INT 1
13279: PPUSH
13280: CALL_OW 1
13284: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13285: LD_INT 1
13287: PPUSH
13288: CALL 16847 0 1
13292: IFFALSE 13408
// begin DialogueOn ;
13294: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13298: LD_VAR 0 1
13302: PPUSH
13303: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13307: LD_INT 10
13309: PPUSH
13310: CALL_OW 68
// un := SayRand ( sex_male , D5b-Sol1-1 ) ;
13314: LD_ADDR_VAR 0 3
13318: PUSH
13319: LD_INT 1
13321: PPUSH
13322: LD_STRING D5b-Sol1-1
13324: PPUSH
13325: CALL 17025 0 2
13329: ST_TO_ADDR
// if not un then
13330: LD_VAR 0 3
13334: NOT
13335: IFFALSE 13353
// un := SayRand ( sex_female , D5b-FSol1-1 ) ;
13337: LD_ADDR_VAR 0 3
13341: PUSH
13342: LD_INT 2
13344: PPUSH
13345: LD_STRING D5b-FSol1-1
13347: PPUSH
13348: CALL 17025 0 2
13352: ST_TO_ADDR
// if un then
13353: LD_VAR 0 3
13357: IFFALSE 13402
// begin un2 := SayRand2 ( sex_male , D5b-Sol2-1 , un ) ;
13359: LD_ADDR_VAR 0 4
13363: PUSH
13364: LD_INT 1
13366: PPUSH
13367: LD_STRING D5b-Sol2-1
13369: PPUSH
13370: LD_VAR 0 3
13374: PPUSH
13375: CALL 17251 0 3
13379: ST_TO_ADDR
// if not un2 then
13380: LD_VAR 0 4
13384: NOT
13385: IFFALSE 13402
// SayRand2 ( sex_female , D5b-FSol2-1 , un ) ;
13387: LD_INT 2
13389: PPUSH
13390: LD_STRING D5b-FSol2-1
13392: PPUSH
13393: LD_VAR 0 3
13397: PPUSH
13398: CALL 17251 0 3
// end ; DialogueOff ;
13402: CALL_OW 7
// break ;
13406: GO 13410
// end ; end ;
13408: GO 13247
13410: POP
13411: POP
// end ; if not seen [ 3 ] then
13412: LD_EXP 9
13416: PUSH
13417: LD_INT 3
13419: ARRAY
13420: NOT
13421: IFFALSE 13595
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] ] ) ;
13423: LD_ADDR_VAR 0 2
13427: PUSH
13428: LD_INT 22
13430: PUSH
13431: LD_INT 2
13433: PUSH
13434: EMPTY
13435: LIST
13436: LIST
13437: PUSH
13438: LD_INT 33
13440: PUSH
13441: LD_INT 2
13443: PUSH
13444: EMPTY
13445: LIST
13446: LIST
13447: PUSH
13448: EMPTY
13449: LIST
13450: LIST
13451: PPUSH
13452: CALL_OW 69
13456: ST_TO_ADDR
// if tmp then
13457: LD_VAR 0 2
13461: IFFALSE 13595
// for i in tmp do
13463: LD_ADDR_VAR 0 1
13467: PUSH
13468: LD_VAR 0 2
13472: PUSH
13473: FOR_IN
13474: IFFALSE 13593
// if See ( 1 , i ) then
13476: LD_INT 1
13478: PPUSH
13479: LD_VAR 0 1
13483: PPUSH
13484: CALL_OW 292
13488: IFFALSE 13591
// begin seen := Replace ( seen , 3 , true ) ;
13490: LD_ADDR_EXP 9
13494: PUSH
13495: LD_EXP 9
13499: PPUSH
13500: LD_INT 3
13502: PPUSH
13503: LD_INT 1
13505: PPUSH
13506: CALL_OW 1
13510: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13511: LD_INT 1
13513: PPUSH
13514: CALL 16847 0 1
13518: IFFALSE 13591
// begin DialogueOn ;
13520: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13524: LD_VAR 0 1
13528: PPUSH
13529: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13533: LD_INT 10
13535: PPUSH
13536: CALL_OW 68
// un := SayRand ( sex_male , D8-Sol1-1 ) ;
13540: LD_ADDR_VAR 0 3
13544: PUSH
13545: LD_INT 1
13547: PPUSH
13548: LD_STRING D8-Sol1-1
13550: PPUSH
13551: CALL 17025 0 2
13555: ST_TO_ADDR
// if not un then
13556: LD_VAR 0 3
13560: NOT
13561: IFFALSE 13573
// SayRand ( sex_female , D8-FSol1-1 ) ;
13563: LD_INT 2
13565: PPUSH
13566: LD_STRING D8-FSol1-1
13568: PPUSH
13569: CALL 17025 0 2
// Say ( JMM , D8-JMM-1 ) ;
13573: LD_EXP 21
13577: PPUSH
13578: LD_STRING D8-JMM-1
13580: PPUSH
13581: CALL_OW 88
// DialogueOff ;
13585: CALL_OW 7
// break ;
13589: GO 13593
// end ; end ;
13591: GO 13473
13593: POP
13594: POP
// end ; if not seen [ 4 ] then
13595: LD_EXP 9
13599: PUSH
13600: LD_INT 4
13602: ARRAY
13603: NOT
13604: IFFALSE 13766
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] ] ) ;
13606: LD_ADDR_VAR 0 2
13610: PUSH
13611: LD_INT 22
13613: PUSH
13614: LD_INT 2
13616: PUSH
13617: EMPTY
13618: LIST
13619: LIST
13620: PUSH
13621: LD_INT 33
13623: PUSH
13624: LD_INT 5
13626: PUSH
13627: EMPTY
13628: LIST
13629: LIST
13630: PUSH
13631: EMPTY
13632: LIST
13633: LIST
13634: PPUSH
13635: CALL_OW 69
13639: ST_TO_ADDR
// if tmp then
13640: LD_VAR 0 2
13644: IFFALSE 13766
// for i in tmp do
13646: LD_ADDR_VAR 0 1
13650: PUSH
13651: LD_VAR 0 2
13655: PUSH
13656: FOR_IN
13657: IFFALSE 13764
// if See ( 1 , i ) then
13659: LD_INT 1
13661: PPUSH
13662: LD_VAR 0 1
13666: PPUSH
13667: CALL_OW 292
13671: IFFALSE 13762
// begin seen := Replace ( seen , 4 , true ) ;
13673: LD_ADDR_EXP 9
13677: PUSH
13678: LD_EXP 9
13682: PPUSH
13683: LD_INT 4
13685: PPUSH
13686: LD_INT 1
13688: PPUSH
13689: CALL_OW 1
13693: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13694: LD_INT 1
13696: PPUSH
13697: CALL 16847 0 1
13701: IFFALSE 13762
// begin DialogueOn ;
13703: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13707: LD_VAR 0 1
13711: PPUSH
13712: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13716: LD_INT 10
13718: PPUSH
13719: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol1-1 ) ;
13723: LD_ADDR_VAR 0 3
13727: PUSH
13728: LD_INT 1
13730: PPUSH
13731: LD_STRING D5a-Sol1-1
13733: PPUSH
13734: CALL 17025 0 2
13738: ST_TO_ADDR
// if not un then
13739: LD_VAR 0 3
13743: NOT
13744: IFFALSE 13756
// SayRand ( sex_female , D5a-FSol1-1 ) ;
13746: LD_INT 2
13748: PPUSH
13749: LD_STRING D5a-FSol1-1
13751: PPUSH
13752: CALL 17025 0 2
// DialogueOff ;
13756: CALL_OW 7
// break ;
13760: GO 13764
// end ; end ;
13762: GO 13656
13764: POP
13765: POP
// end ; if not seen [ 5 ] and seen [ 3 ] then
13766: LD_EXP 9
13770: PUSH
13771: LD_INT 5
13773: ARRAY
13774: NOT
13775: PUSH
13776: LD_EXP 9
13780: PUSH
13781: LD_INT 3
13783: ARRAY
13784: AND
13785: IFFALSE 13959
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) ;
13787: LD_ADDR_VAR 0 2
13791: PUSH
13792: LD_INT 22
13794: PUSH
13795: LD_INT 2
13797: PUSH
13798: EMPTY
13799: LIST
13800: LIST
13801: PUSH
13802: LD_INT 34
13804: PUSH
13805: LD_INT 31
13807: PUSH
13808: EMPTY
13809: LIST
13810: LIST
13811: PUSH
13812: EMPTY
13813: LIST
13814: LIST
13815: PPUSH
13816: CALL_OW 69
13820: ST_TO_ADDR
// if tmp then
13821: LD_VAR 0 2
13825: IFFALSE 13959
// for i in tmp do
13827: LD_ADDR_VAR 0 1
13831: PUSH
13832: LD_VAR 0 2
13836: PUSH
13837: FOR_IN
13838: IFFALSE 13957
// if See ( 1 , i ) then
13840: LD_INT 1
13842: PPUSH
13843: LD_VAR 0 1
13847: PPUSH
13848: CALL_OW 292
13852: IFFALSE 13955
// begin seen := Replace ( seen , 5 , true ) ;
13854: LD_ADDR_EXP 9
13858: PUSH
13859: LD_EXP 9
13863: PPUSH
13864: LD_INT 5
13866: PPUSH
13867: LD_INT 1
13869: PPUSH
13870: CALL_OW 1
13874: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13875: LD_INT 1
13877: PPUSH
13878: CALL 16847 0 1
13882: IFFALSE 13955
// begin DialogueOn ;
13884: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13888: LD_VAR 0 1
13892: PPUSH
13893: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13897: LD_INT 10
13899: PPUSH
13900: CALL_OW 68
// un := SayRand ( sex_male , D8a-Sol2-1 ) ;
13904: LD_ADDR_VAR 0 3
13908: PUSH
13909: LD_INT 1
13911: PPUSH
13912: LD_STRING D8a-Sol2-1
13914: PPUSH
13915: CALL 17025 0 2
13919: ST_TO_ADDR
// if not un then
13920: LD_VAR 0 3
13924: NOT
13925: IFFALSE 13937
// SayRand ( sex_female , D8a-FSol2-1 ) ;
13927: LD_INT 2
13929: PPUSH
13930: LD_STRING D8a-FSol2-1
13932: PPUSH
13933: CALL 17025 0 2
// Say ( JMM , D8a-JMM-1 ) ;
13937: LD_EXP 21
13941: PPUSH
13942: LD_STRING D8a-JMM-1
13944: PPUSH
13945: CALL_OW 88
// DialogueOff ;
13949: CALL_OW 7
// break ;
13953: GO 13957
// end ; end ;
13955: GO 13837
13957: POP
13958: POP
// end ; if seen [ 1 ] and seen [ 2 ] and seen [ 3 ] and seen [ 4 ] and seen [ 5 ] then
13959: LD_EXP 9
13963: PUSH
13964: LD_INT 1
13966: ARRAY
13967: PUSH
13968: LD_EXP 9
13972: PUSH
13973: LD_INT 2
13975: ARRAY
13976: AND
13977: PUSH
13978: LD_EXP 9
13982: PUSH
13983: LD_INT 3
13985: ARRAY
13986: AND
13987: PUSH
13988: LD_EXP 9
13992: PUSH
13993: LD_INT 4
13995: ARRAY
13996: AND
13997: PUSH
13998: LD_EXP 9
14002: PUSH
14003: LD_INT 5
14005: ARRAY
14006: AND
14007: IFFALSE 14010
// disable ;
14009: DISABLE
// end ;
14010: PPOPN 4
14012: END
// every 0 0$1 trigger can_kamikazed and kamikazed do var un ;
14013: LD_EXP 10
14017: PUSH
14018: LD_EXP 11
14022: AND
14023: IFFALSE 14221
14025: GO 14027
14027: DISABLE
14028: LD_INT 0
14030: PPUSH
// begin DialogueOn ;
14031: CALL_OW 6
// CenterNowOnUnits ( kamikazed ) ;
14035: LD_EXP 11
14039: PPUSH
14040: CALL_OW 87
// un := SayRand ( sex_male , D5c-Sol1-1 ) ;
14044: LD_ADDR_VAR 0 1
14048: PUSH
14049: LD_INT 1
14051: PPUSH
14052: LD_STRING D5c-Sol1-1
14054: PPUSH
14055: CALL 17025 0 2
14059: ST_TO_ADDR
// if not un then
14060: LD_VAR 0 1
14064: NOT
14065: IFFALSE 14083
// un := SayRand ( sex_female , D5c-FSol1-1 ) ;
14067: LD_ADDR_VAR 0 1
14071: PUSH
14072: LD_INT 2
14074: PPUSH
14075: LD_STRING D5c-FSol1-1
14077: PPUSH
14078: CALL 17025 0 2
14082: ST_TO_ADDR
// Say ( JMM , D5c-JMM-1 ) ;
14083: LD_EXP 21
14087: PPUSH
14088: LD_STRING D5c-JMM-1
14090: PPUSH
14091: CALL_OW 88
// if IsOk ( Lisa ) then
14095: LD_EXP 22
14099: PPUSH
14100: CALL_OW 302
14104: IFFALSE 14120
// Say ( Lisa , D5d-Lisa-1 ) else
14106: LD_EXP 22
14110: PPUSH
14111: LD_STRING D5d-Lisa-1
14113: PPUSH
14114: CALL_OW 88
14118: GO 14205
// if IsOk ( Cyrus ) then
14120: LD_EXP 25
14124: PPUSH
14125: CALL_OW 302
14129: IFFALSE 14145
// Say ( Cyrus , D5d-Cyrus-1 ) else
14131: LD_EXP 25
14135: PPUSH
14136: LD_STRING D5d-Cyrus-1
14138: PPUSH
14139: CALL_OW 88
14143: GO 14205
// if IsOk ( Gary ) then
14145: LD_EXP 32
14149: PPUSH
14150: CALL_OW 302
14154: IFFALSE 14170
// Say ( Gary , D5d-Gary-1 ) else
14156: LD_EXP 32
14160: PPUSH
14161: LD_STRING D5d-Gary-1
14163: PPUSH
14164: CALL_OW 88
14168: GO 14205
// if GetSex ( un ) = sex_male then
14170: LD_VAR 0 1
14174: PPUSH
14175: CALL_OW 258
14179: PUSH
14180: LD_INT 1
14182: EQUAL
14183: IFFALSE 14199
// Say ( un , D5d-Sol1-1 ) else
14185: LD_VAR 0 1
14189: PPUSH
14190: LD_STRING D5d-Sol1-1
14192: PPUSH
14193: CALL_OW 88
14197: GO 14205
// begin DialogueOff ;
14199: CALL_OW 7
// exit ;
14203: GO 14221
// end ; Say ( JMM , D5d-JMM-1 ) ;
14205: LD_EXP 21
14209: PPUSH
14210: LD_STRING D5d-JMM-1
14212: PPUSH
14213: CALL_OW 88
// DialogueOff ;
14217: CALL_OW 7
// end ;
14221: PPOPN 1
14223: END
// every 0 0$2 trigger SeeArea ( 1 , artifact_area ) >= 2 do var un ;
14224: LD_INT 1
14226: PPUSH
14227: LD_INT 17
14229: PPUSH
14230: CALL_OW 294
14234: PUSH
14235: LD_INT 2
14237: GREATEREQUAL
14238: IFFALSE 14370
14240: GO 14242
14242: DISABLE
14243: LD_INT 0
14245: PPUSH
// begin PlaceSeeing ( 10 , 5 , 1 , - 10 ) ;
14246: LD_INT 10
14248: PPUSH
14249: LD_INT 5
14251: PPUSH
14252: LD_INT 1
14254: PPUSH
14255: LD_INT 10
14257: NEG
14258: PPUSH
14259: CALL_OW 330
// RemoveSeeing ( 10 , 5 , 1 ) ;
14263: LD_INT 10
14265: PPUSH
14266: LD_INT 5
14268: PPUSH
14269: LD_INT 1
14271: PPUSH
14272: CALL_OW 331
// CenterNowOnXY ( 10 , 5 ) ;
14276: LD_INT 10
14278: PPUSH
14279: LD_INT 5
14281: PPUSH
14282: CALL_OW 86
// DialogueOn ;
14286: CALL_OW 6
// un := SayRand ( sex_male , D6-Sci1-1 ) ;
14290: LD_ADDR_VAR 0 1
14294: PUSH
14295: LD_INT 1
14297: PPUSH
14298: LD_STRING D6-Sci1-1
14300: PPUSH
14301: CALL 17025 0 2
14305: ST_TO_ADDR
// if un then
14306: LD_VAR 0 1
14310: IFFALSE 14348
// begin Say ( JMM , D6-JMM-1 ) ;
14312: LD_EXP 21
14316: PPUSH
14317: LD_STRING D6-JMM-1
14319: PPUSH
14320: CALL_OW 88
// Say ( un , D6-Sci1-2 ) ;
14324: LD_VAR 0 1
14328: PPUSH
14329: LD_STRING D6-Sci1-2
14331: PPUSH
14332: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
14336: LD_EXP 21
14340: PPUSH
14341: LD_STRING D6-JMM-2
14343: PPUSH
14344: CALL_OW 88
// end ; DialogueOff ;
14348: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
14352: LD_STRING M3
14354: PPUSH
14355: CALL_OW 337
// wait ( 0 0$30 ) ;
14359: LD_INT 1050
14361: PPUSH
14362: CALL_OW 67
// AmericanReinforcements ;
14366: CALL 2345 0 0
// end ;
14370: PPOPN 1
14372: END
// export ar_mechanic , ar_mechanic_friend ; every 0 0$20 trigger tick >= 20 20$00 and ( DangerAtRangeXY ( 2 , 169 , 90 , 10 ) [ 4 ] = 0 or IsDead ( ar_dep_w ) or GetSide ( ar_dep_w ) = 1 ) and not IsDead ( ar_dep_n ) do var un , i , cargo , tmp , escaped ;
14373: LD_OWVAR 1
14377: PUSH
14378: LD_INT 42000
14380: GREATEREQUAL
14381: PUSH
14382: LD_INT 2
14384: PPUSH
14385: LD_INT 169
14387: PPUSH
14388: LD_INT 90
14390: PPUSH
14391: LD_INT 10
14393: PPUSH
14394: CALL 55409 0 4
14398: PUSH
14399: LD_INT 4
14401: ARRAY
14402: PUSH
14403: LD_INT 0
14405: EQUAL
14406: PUSH
14407: LD_INT 45
14409: PPUSH
14410: CALL_OW 301
14414: OR
14415: PUSH
14416: LD_INT 45
14418: PPUSH
14419: CALL_OW 255
14423: PUSH
14424: LD_INT 1
14426: EQUAL
14427: OR
14428: AND
14429: PUSH
14430: LD_INT 94
14432: PPUSH
14433: CALL_OW 301
14437: NOT
14438: AND
14439: IFFALSE 15644
14441: GO 14443
14443: DISABLE
14444: LD_INT 0
14446: PPUSH
14447: PPUSH
14448: PPUSH
14449: PPUSH
14450: PPUSH
// begin uc_side := 5 ;
14451: LD_ADDR_OWVAR 20
14455: PUSH
14456: LD_INT 5
14458: ST_TO_ADDR
// uc_nation := 2 ;
14459: LD_ADDR_OWVAR 21
14463: PUSH
14464: LD_INT 2
14466: ST_TO_ADDR
// InitHc ;
14467: CALL_OW 19
// PrepareHuman ( sex_male , 3 , 8 ) ;
14471: LD_INT 1
14473: PPUSH
14474: LD_INT 3
14476: PPUSH
14477: LD_INT 8
14479: PPUSH
14480: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
14484: LD_ADDR_OWVAR 29
14488: PUSH
14489: LD_INT 12
14491: PUSH
14492: LD_INT 12
14494: PUSH
14495: EMPTY
14496: LIST
14497: LIST
14498: ST_TO_ADDR
// hc_name := Hans Fliege ;
14499: LD_ADDR_OWVAR 26
14503: PUSH
14504: LD_STRING Hans Fliege
14506: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
14507: LD_ADDR_OWVAR 33
14511: PUSH
14512: LD_STRING SecondCharsGal
14514: ST_TO_ADDR
// hc_face_number := 7 ;
14515: LD_ADDR_OWVAR 34
14519: PUSH
14520: LD_INT 7
14522: ST_TO_ADDR
// ar_mechanic := CreateHuman ;
14523: LD_ADDR_EXP 46
14527: PUSH
14528: CALL_OW 44
14532: ST_TO_ADDR
// InitHc ;
14533: CALL_OW 19
// PrepareHuman ( sex_male , 16 , 2 ) ;
14537: LD_INT 1
14539: PPUSH
14540: LD_INT 16
14542: PPUSH
14543: LD_INT 2
14545: PPUSH
14546: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
14550: LD_ADDR_OWVAR 29
14554: PUSH
14555: LD_INT 12
14557: PUSH
14558: LD_INT 12
14560: PUSH
14561: EMPTY
14562: LIST
14563: LIST
14564: ST_TO_ADDR
// hc_name :=  ;
14565: LD_ADDR_OWVAR 26
14569: PUSH
14570: LD_STRING 
14572: ST_TO_ADDR
// ar_mechanic_friend := CreateHuman ;
14573: LD_ADDR_EXP 47
14577: PUSH
14578: CALL_OW 44
14582: ST_TO_ADDR
// InitHc ;
14583: CALL_OW 19
// repeat wait ( 0 0$1 ) ;
14587: LD_INT 35
14589: PPUSH
14590: CALL_OW 67
// until not InBattle ( 1 ) ;
14594: LD_INT 1
14596: PPUSH
14597: CALL_OW 463
14601: NOT
14602: IFFALSE 14587
// wait ( 0 0$5 ) ;
14604: LD_INT 175
14606: PPUSH
14607: CALL_OW 67
// DialogueOn ;
14611: CALL_OW 6
// InGameOn ;
14615: CALL_OW 8
// un := UnitFilter ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , [ f_sex , sex_male ] ) [ 1 ] ;
14619: LD_ADDR_VAR 0 1
14623: PUSH
14624: LD_INT 22
14626: PUSH
14627: LD_INT 1
14629: PUSH
14630: EMPTY
14631: LIST
14632: LIST
14633: PUSH
14634: LD_INT 2
14636: PUSH
14637: LD_INT 25
14639: PUSH
14640: LD_INT 1
14642: PUSH
14643: EMPTY
14644: LIST
14645: LIST
14646: PUSH
14647: LD_INT 25
14649: PUSH
14650: LD_INT 2
14652: PUSH
14653: EMPTY
14654: LIST
14655: LIST
14656: PUSH
14657: LD_INT 25
14659: PUSH
14660: LD_INT 3
14662: PUSH
14663: EMPTY
14664: LIST
14665: LIST
14666: PUSH
14667: LD_INT 25
14669: PUSH
14670: LD_INT 4
14672: PUSH
14673: EMPTY
14674: LIST
14675: LIST
14676: PUSH
14677: LD_INT 25
14679: PUSH
14680: LD_INT 5
14682: PUSH
14683: EMPTY
14684: LIST
14685: LIST
14686: PUSH
14687: LD_INT 25
14689: PUSH
14690: LD_INT 8
14692: PUSH
14693: EMPTY
14694: LIST
14695: LIST
14696: PUSH
14697: EMPTY
14698: LIST
14699: LIST
14700: LIST
14701: LIST
14702: LIST
14703: LIST
14704: LIST
14705: PUSH
14706: EMPTY
14707: LIST
14708: LIST
14709: PPUSH
14710: CALL_OW 69
14714: PUSH
14715: LD_EXP 21
14719: PUSH
14720: LD_EXP 22
14724: PUSH
14725: LD_EXP 23
14729: PUSH
14730: LD_EXP 24
14734: PUSH
14735: LD_EXP 25
14739: PUSH
14740: LD_EXP 26
14744: PUSH
14745: LD_EXP 27
14749: PUSH
14750: LD_EXP 28
14754: PUSH
14755: LD_EXP 29
14759: PUSH
14760: LD_EXP 31
14764: PUSH
14765: LD_EXP 32
14769: PUSH
14770: LD_EXP 33
14774: PUSH
14775: LD_EXP 34
14779: PUSH
14780: EMPTY
14781: LIST
14782: LIST
14783: LIST
14784: LIST
14785: LIST
14786: LIST
14787: LIST
14788: LIST
14789: LIST
14790: LIST
14791: LIST
14792: LIST
14793: LIST
14794: DIFF
14795: PPUSH
14796: LD_INT 26
14798: PUSH
14799: LD_INT 1
14801: PUSH
14802: EMPTY
14803: LIST
14804: LIST
14805: PPUSH
14806: CALL_OW 72
14810: PUSH
14811: LD_INT 1
14813: ARRAY
14814: ST_TO_ADDR
// if Brown then
14815: LD_EXP 27
14819: IFFALSE 14831
// un := Brown ;
14821: LD_ADDR_VAR 0 1
14825: PUSH
14826: LD_EXP 27
14830: ST_TO_ADDR
// if un then
14831: LD_VAR 0 1
14835: IFFALSE 14861
// begin Say ( un , D7-Sol1-1 ) ;
14837: LD_VAR 0 1
14841: PPUSH
14842: LD_STRING D7-Sol1-1
14844: PPUSH
14845: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
14849: LD_EXP 21
14853: PPUSH
14854: LD_STRING D7-JMM-1
14856: PPUSH
14857: CALL_OW 88
// end ; SayRadio ( ar_mechanic , D7-Ar1-1 ) ;
14861: LD_EXP 46
14865: PPUSH
14866: LD_STRING D7-Ar1-1
14868: PPUSH
14869: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
14873: LD_EXP 21
14877: PPUSH
14878: LD_STRING D7-JMM-2
14880: PPUSH
14881: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-2 ) ;
14885: LD_EXP 46
14889: PPUSH
14890: LD_STRING D7-Ar1-2
14892: PPUSH
14893: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
14897: LD_EXP 21
14901: PPUSH
14902: LD_STRING D7-JMM-3
14904: PPUSH
14905: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-3 ) ;
14909: LD_EXP 46
14913: PPUSH
14914: LD_STRING D7-Ar1-3
14916: PPUSH
14917: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
14921: LD_EXP 21
14925: PPUSH
14926: LD_STRING D7-JMM-4
14928: PPUSH
14929: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-4 ) ;
14933: LD_EXP 46
14937: PPUSH
14938: LD_STRING D7-Ar1-4
14940: PPUSH
14941: CALL_OW 94
// InGameOff ;
14945: CALL_OW 9
// DialogueOff ;
14949: CALL_OW 7
// case Query ( QCameras ) of 1 :
14953: LD_STRING QCameras
14955: PPUSH
14956: CALL_OW 97
14960: PUSH
14961: LD_INT 1
14963: DOUBLE
14964: EQUAL
14965: IFTRUE 14969
14967: GO 14972
14969: POP
// ; 2 :
14970: GO 14986
14972: LD_INT 2
14974: DOUBLE
14975: EQUAL
14976: IFTRUE 14980
14978: GO 14985
14980: POP
// exit ; end ;
14981: GO 15644
14983: GO 14986
14985: POP
// ChangeMissionObjectives ( MCar ) ;
14986: LD_STRING MCar
14988: PPUSH
14989: CALL_OW 337
// PlaceSeeing ( 124 , 90 , 1 , - 6 ) ;
14993: LD_INT 124
14995: PPUSH
14996: LD_INT 90
14998: PPUSH
14999: LD_INT 1
15001: PPUSH
15002: LD_INT 6
15004: NEG
15005: PPUSH
15006: CALL_OW 330
// RemoveSeeing ( 124 , 90 , 1 ) ;
15010: LD_INT 124
15012: PPUSH
15013: LD_INT 90
15015: PPUSH
15016: LD_INT 1
15018: PPUSH
15019: CALL_OW 331
// SetAreaMapShow ( parking_marea , 1 ) ;
15023: LD_INT 12
15025: PPUSH
15026: LD_INT 1
15028: PPUSH
15029: CALL_OW 424
// wait ( 3 ) ;
15033: LD_INT 3
15035: PPUSH
15036: CALL_OW 67
// CenterNowOnXY ( 124 , 90 ) ;
15040: LD_INT 124
15042: PPUSH
15043: LD_INT 90
15045: PPUSH
15046: CALL_OW 86
// cargo := false ;
15050: LD_ADDR_VAR 0 3
15054: PUSH
15055: LD_INT 0
15057: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
15058: LD_INT 35
15060: PPUSH
15061: CALL_OW 67
// cargo := FilterUnitsInArea ( parking_marea , [ [ f_engine , engine_siberite ] , [ f_weapon , ar_cargo_bay ] , [ f_empty ] ] ) ;
15065: LD_ADDR_VAR 0 3
15069: PUSH
15070: LD_INT 12
15072: PPUSH
15073: LD_INT 32
15075: PUSH
15076: LD_INT 3
15078: PUSH
15079: EMPTY
15080: LIST
15081: LIST
15082: PUSH
15083: LD_INT 34
15085: PUSH
15086: LD_INT 32
15088: PUSH
15089: EMPTY
15090: LIST
15091: LIST
15092: PUSH
15093: LD_INT 58
15095: PUSH
15096: EMPTY
15097: LIST
15098: PUSH
15099: EMPTY
15100: LIST
15101: LIST
15102: LIST
15103: PPUSH
15104: CALL_OW 70
15108: ST_TO_ADDR
// until cargo ;
15109: LD_VAR 0 3
15113: IFFALSE 15058
// cargo := cargo [ 1 ] ;
15115: LD_ADDR_VAR 0 3
15119: PUSH
15120: LD_VAR 0 3
15124: PUSH
15125: LD_INT 1
15127: ARRAY
15128: ST_TO_ADDR
// SetSide ( cargo , 5 ) ;
15129: LD_VAR 0 3
15133: PPUSH
15134: LD_INT 5
15136: PPUSH
15137: CALL_OW 235
// SetAreaMapShow ( parking_marea , 0 ) ;
15141: LD_INT 12
15143: PPUSH
15144: LD_INT 0
15146: PPUSH
15147: CALL_OW 424
// PlaceUnitArea ( ar_mechanic , mechanic_spawn , false ) ;
15151: LD_EXP 46
15155: PPUSH
15156: LD_INT 11
15158: PPUSH
15159: LD_INT 0
15161: PPUSH
15162: CALL_OW 49
// PlaceUnitArea ( ar_mechanic_friend , mechanic_spawn , false ) ;
15166: LD_EXP 47
15170: PPUSH
15171: LD_INT 11
15173: PPUSH
15174: LD_INT 0
15176: PPUSH
15177: CALL_OW 49
// ComMoveToArea ( [ ar_mechanic , ar_mechanic_friend ] , parking_marea ) ;
15181: LD_EXP 46
15185: PUSH
15186: LD_EXP 47
15190: PUSH
15191: EMPTY
15192: LIST
15193: LIST
15194: PPUSH
15195: LD_INT 12
15197: PPUSH
15198: CALL_OW 113
// AddComEnterUnit ( ar_mechanic , cargo ) ;
15202: LD_EXP 46
15206: PPUSH
15207: LD_VAR 0 3
15211: PPUSH
15212: CALL_OW 180
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
15216: LD_EXP 46
15220: PUSH
15221: LD_EXP 47
15225: PUSH
15226: EMPTY
15227: LIST
15228: LIST
15229: PPUSH
15230: LD_INT 209
15232: PPUSH
15233: LD_INT 178
15235: PPUSH
15236: CALL_OW 171
// escaped := 0 ;
15240: LD_ADDR_VAR 0 5
15244: PUSH
15245: LD_INT 0
15247: ST_TO_ADDR
// while ( true ) do
15248: LD_INT 1
15250: IFFALSE 15466
// begin wait ( 0 0$1 ) ;
15252: LD_INT 35
15254: PPUSH
15255: CALL_OW 67
// if not HasTask ( ar_mechanic ) or not HasTask ( ar_mechanic_friend ) then
15259: LD_EXP 46
15263: PPUSH
15264: CALL_OW 314
15268: NOT
15269: PUSH
15270: LD_EXP 47
15274: PPUSH
15275: CALL_OW 314
15279: NOT
15280: OR
15281: IFFALSE 15307
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
15283: LD_EXP 46
15287: PUSH
15288: LD_EXP 47
15292: PUSH
15293: EMPTY
15294: LIST
15295: LIST
15296: PPUSH
15297: LD_INT 209
15299: PPUSH
15300: LD_INT 178
15302: PPUSH
15303: CALL_OW 171
// if IsInArea ( ar_mechanic , escape_area ) then
15307: LD_EXP 46
15311: PPUSH
15312: LD_INT 10
15314: PPUSH
15315: CALL_OW 308
15319: IFFALSE 15344
// begin RemoveUnit ( ar_mechanic ) ;
15321: LD_EXP 46
15325: PPUSH
15326: CALL_OW 64
// escaped := escaped + 1 ;
15330: LD_ADDR_VAR 0 5
15334: PUSH
15335: LD_VAR 0 5
15339: PUSH
15340: LD_INT 1
15342: PLUS
15343: ST_TO_ADDR
// end ; if IsInArea ( ar_mechanic_friend , escape_area ) then
15344: LD_EXP 47
15348: PPUSH
15349: LD_INT 10
15351: PPUSH
15352: CALL_OW 308
15356: IFFALSE 15381
// begin RemoveUnit ( ar_mechanic_friend ) ;
15358: LD_EXP 47
15362: PPUSH
15363: CALL_OW 64
// escaped := escaped + 1 ;
15367: LD_ADDR_VAR 0 5
15371: PUSH
15372: LD_VAR 0 5
15376: PUSH
15377: LD_INT 1
15379: PLUS
15380: ST_TO_ADDR
// end ; if IsInArea ( cargo , escape_area ) then
15381: LD_VAR 0 3
15385: PPUSH
15386: LD_INT 10
15388: PPUSH
15389: CALL_OW 308
15393: IFFALSE 15404
// RemoveUnit ( cargo ) ;
15395: LD_VAR 0 3
15399: PPUSH
15400: CALL_OW 64
// if not IsPlaced ( ar_mechanic ) and escaped >= 2 then
15404: LD_EXP 46
15408: PPUSH
15409: CALL_OW 305
15413: NOT
15414: PUSH
15415: LD_VAR 0 5
15419: PUSH
15420: LD_INT 2
15422: GREATEREQUAL
15423: AND
15424: IFFALSE 15428
// break ;
15426: GO 15466
// if not IsPlaced ( ar_mechanic ) and not IsPlaced ( ar_mechanic_friend ) and escaped < 2 then
15428: LD_EXP 46
15432: PPUSH
15433: CALL_OW 305
15437: NOT
15438: PUSH
15439: LD_EXP 47
15443: PPUSH
15444: CALL_OW 305
15448: NOT
15449: AND
15450: PUSH
15451: LD_VAR 0 5
15455: PUSH
15456: LD_INT 2
15458: LESS
15459: AND
15460: IFFALSE 15464
// exit ;
15462: GO 15644
// end ;
15464: GO 15248
// wait ( 0 0$2 ) ;
15466: LD_INT 70
15468: PPUSH
15469: CALL_OW 67
// SayRadio ( ar_mechanic , D7a-Ar1-1 ) ;
15473: LD_EXP 46
15477: PPUSH
15478: LD_STRING D7a-Ar1-1
15480: PPUSH
15481: CALL_OW 94
// tmp := [ [ 129 , 10 ] , [ 103 , 6 ] , [ 148 , 47 ] , [ 155 , 16 ] ] ;
15485: LD_ADDR_VAR 0 4
15489: PUSH
15490: LD_INT 129
15492: PUSH
15493: LD_INT 10
15495: PUSH
15496: EMPTY
15497: LIST
15498: LIST
15499: PUSH
15500: LD_INT 103
15502: PUSH
15503: LD_INT 6
15505: PUSH
15506: EMPTY
15507: LIST
15508: LIST
15509: PUSH
15510: LD_INT 148
15512: PUSH
15513: LD_INT 47
15515: PUSH
15516: EMPTY
15517: LIST
15518: LIST
15519: PUSH
15520: LD_INT 155
15522: PUSH
15523: LD_INT 16
15525: PUSH
15526: EMPTY
15527: LIST
15528: LIST
15529: PUSH
15530: EMPTY
15531: LIST
15532: LIST
15533: LIST
15534: LIST
15535: ST_TO_ADDR
// if Difficulty = 1 then
15536: LD_OWVAR 67
15540: PUSH
15541: LD_INT 1
15543: EQUAL
15544: IFFALSE 15581
// tmp := tmp ^ [ [ 78 , 7 ] , [ 104 , 43 ] ] ;
15546: LD_ADDR_VAR 0 4
15550: PUSH
15551: LD_VAR 0 4
15555: PUSH
15556: LD_INT 78
15558: PUSH
15559: LD_INT 7
15561: PUSH
15562: EMPTY
15563: LIST
15564: LIST
15565: PUSH
15566: LD_INT 104
15568: PUSH
15569: LD_INT 43
15571: PUSH
15572: EMPTY
15573: LIST
15574: LIST
15575: PUSH
15576: EMPTY
15577: LIST
15578: LIST
15579: ADD
15580: ST_TO_ADDR
// for i in tmp do
15581: LD_ADDR_VAR 0 2
15585: PUSH
15586: LD_VAR 0 4
15590: PUSH
15591: FOR_IN
15592: IFFALSE 15625
// PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 9 ) ;
15594: LD_VAR 0 2
15598: PUSH
15599: LD_INT 1
15601: ARRAY
15602: PPUSH
15603: LD_VAR 0 2
15607: PUSH
15608: LD_INT 2
15610: ARRAY
15611: PPUSH
15612: LD_INT 1
15614: PPUSH
15615: LD_INT 9
15617: NEG
15618: PPUSH
15619: CALL_OW 330
15623: GO 15591
15625: POP
15626: POP
// SetAchievement ( ACH_FRIEND ) ;
15627: LD_STRING ACH_FRIEND
15629: PPUSH
15630: CALL_OW 543
// CenterOnXY ( 129 , 10 ) ;
15634: LD_INT 129
15636: PPUSH
15637: LD_INT 10
15639: PPUSH
15640: CALL_OW 84
// end ;
15644: PPOPN 5
15646: END
// every 0 0$1 trigger game_time - 10 10$00 <= tick do
15647: LD_EXP 15
15651: PUSH
15652: LD_INT 21000
15654: MINUS
15655: PUSH
15656: LD_OWVAR 1
15660: LESSEQUAL
15661: IFFALSE 15701
15663: GO 15665
15665: DISABLE
// begin powell_warn := true ;
15666: LD_ADDR_EXP 16
15670: PUSH
15671: LD_INT 1
15673: ST_TO_ADDR
// DialogueOn ;
15674: CALL_OW 6
// SayRadio ( Powell , D9-Pow-1 ) ;
15678: LD_EXP 30
15682: PPUSH
15683: LD_STRING D9-Pow-1
15685: PPUSH
15686: CALL_OW 94
// dwait ( 0 0$0.3 ) ;
15690: LD_INT 10
15692: PPUSH
15693: CALL_OW 68
// DialogueOff ;
15697: CALL_OW 7
// end ;
15701: END
// every 0 0$1 trigger game_time <= tick do
15702: LD_EXP 15
15706: PUSH
15707: LD_OWVAR 1
15711: LESSEQUAL
15712: IFFALSE 15751
15714: GO 15716
15716: DISABLE
// begin DialogueOn ;
15717: CALL_OW 6
// SayRadio ( Powell , D9a-Pow-1 ) ;
15721: LD_EXP 30
15725: PPUSH
15726: LD_STRING D9a-Pow-1
15728: PPUSH
15729: CALL_OW 94
// dwait ( 0 0$2 ) ;
15733: LD_INT 70
15735: PPUSH
15736: CALL_OW 68
// DialogueOff ;
15740: CALL_OW 7
// YouLost ( Command ) ;
15744: LD_STRING Command
15746: PPUSH
15747: CALL_OW 104
// end ;
15751: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_warehouse ] ] ) = 0 and IsOk ( JMM ) do
15752: LD_INT 22
15754: PUSH
15755: LD_INT 2
15757: PUSH
15758: EMPTY
15759: LIST
15760: LIST
15761: PUSH
15762: LD_INT 30
15764: PUSH
15765: LD_INT 1
15767: PUSH
15768: EMPTY
15769: LIST
15770: LIST
15771: PUSH
15772: EMPTY
15773: LIST
15774: LIST
15775: PPUSH
15776: CALL_OW 69
15780: PUSH
15781: LD_INT 0
15783: EQUAL
15784: PUSH
15785: LD_EXP 21
15789: PPUSH
15790: CALL_OW 302
15794: AND
15795: IFFALSE 15843
15797: GO 15799
15799: DISABLE
// begin case Query ( QEndMission ) of 1 :
15800: LD_STRING QEndMission
15802: PPUSH
15803: CALL_OW 97
15807: PUSH
15808: LD_INT 1
15810: DOUBLE
15811: EQUAL
15812: IFTRUE 15816
15814: GO 15827
15816: POP
// end_the_mission_allowed := true ; 2 :
15817: LD_ADDR_OWVAR 57
15821: PUSH
15822: LD_INT 1
15824: ST_TO_ADDR
15825: GO 15843
15827: LD_INT 2
15829: DOUBLE
15830: EQUAL
15831: IFTRUE 15835
15833: GO 15842
15835: POP
// EndMission ; end ;
15836: CALL 15865 0 0
15840: GO 15843
15842: POP
// end ;
15843: END
// on EndTheMissionRaised ( p ) do begin if end_the_mission_allowed then
15844: LD_OWVAR 57
15848: IFFALSE 15862
// begin end_the_mission_allowed := false ;
15850: LD_ADDR_OWVAR 57
15854: PUSH
15855: LD_INT 0
15857: ST_TO_ADDR
// EndMission ;
15858: CALL 15865 0 0
// end ; end ;
15862: PPOPN 1
15864: END
// function EndMission ; var tmp , m1 , m2 , m3 ; begin
15865: LD_INT 0
15867: PPUSH
15868: PPUSH
15869: PPUSH
15870: PPUSH
15871: PPUSH
// m1 := false ;
15872: LD_ADDR_VAR 0 3
15876: PUSH
15877: LD_INT 0
15879: ST_TO_ADDR
// m2 := false ;
15880: LD_ADDR_VAR 0 4
15884: PUSH
15885: LD_INT 0
15887: ST_TO_ADDR
// m3 := false ;
15888: LD_ADDR_VAR 0 5
15892: PUSH
15893: LD_INT 0
15895: ST_TO_ADDR
// if Count ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] , [ f_ok ] ] ) ) < 9 then
15896: LD_INT 22
15898: PUSH
15899: LD_INT 1
15901: PUSH
15902: EMPTY
15903: LIST
15904: LIST
15905: PUSH
15906: LD_INT 21
15908: PUSH
15909: LD_INT 1
15911: PUSH
15912: EMPTY
15913: LIST
15914: LIST
15915: PUSH
15916: LD_INT 23
15918: PUSH
15919: LD_INT 1
15921: PUSH
15922: EMPTY
15923: LIST
15924: LIST
15925: PUSH
15926: LD_INT 50
15928: PUSH
15929: EMPTY
15930: LIST
15931: PUSH
15932: EMPTY
15933: LIST
15934: LIST
15935: LIST
15936: LIST
15937: PPUSH
15938: CALL_OW 69
15942: PPUSH
15943: CALL 51285 0 1
15947: PUSH
15948: LD_INT 9
15950: LESS
15951: IFFALSE 15960
// YouLost ( LostVictory ) ;
15953: LD_STRING LostVictory
15955: PPUSH
15956: CALL_OW 104
// if not am_veh_consturcted then
15960: LD_EXP 20
15964: NOT
15965: IFFALSE 15974
// SetAchievement ( ACH_ARABTECH ) ;
15967: LD_STRING ACH_ARABTECH
15969: PPUSH
15970: CALL_OW 543
// if tick < [ 120 120$00 , 100 100$00 , 95 95$00 , 92 92$00 ] [ Difficulty ] then
15974: LD_OWVAR 1
15978: PUSH
15979: LD_INT 252000
15981: PUSH
15982: LD_INT 210000
15984: PUSH
15985: LD_INT 199500
15987: PUSH
15988: LD_INT 193200
15990: PUSH
15991: EMPTY
15992: LIST
15993: LIST
15994: LIST
15995: LIST
15996: PUSH
15997: LD_OWVAR 67
16001: ARRAY
16002: LESS
16003: IFFALSE 16025
// begin m3 := true ;
16005: LD_ADDR_VAR 0 5
16009: PUSH
16010: LD_INT 1
16012: ST_TO_ADDR
// AddMedal ( Time1 , 1 ) ;
16013: LD_STRING Time1
16015: PPUSH
16016: LD_INT 1
16018: PPUSH
16019: CALL_OW 101
// end else
16023: GO 16056
// if not powell_warn then
16025: LD_EXP 16
16029: NOT
16030: IFFALSE 16045
// AddMedal ( Time1 , - 1 ) else
16032: LD_STRING Time1
16034: PPUSH
16035: LD_INT 1
16037: NEG
16038: PPUSH
16039: CALL_OW 101
16043: GO 16056
// AddMedal ( Time1 , - 2 ) ;
16045: LD_STRING Time1
16047: PPUSH
16048: LD_INT 2
16050: NEG
16051: PPUSH
16052: CALL_OW 101
// if loses_counter >= [ 5 , 4 , 3 , 3 ] [ Difficulty ] then
16056: LD_EXP 17
16060: PUSH
16061: LD_INT 5
16063: PUSH
16064: LD_INT 4
16066: PUSH
16067: LD_INT 3
16069: PUSH
16070: LD_INT 3
16072: PUSH
16073: EMPTY
16074: LIST
16075: LIST
16076: LIST
16077: LIST
16078: PUSH
16079: LD_OWVAR 67
16083: ARRAY
16084: GREATEREQUAL
16085: IFFALSE 16100
// AddMedal ( Destroy , - 2 ) else
16087: LD_STRING Destroy
16089: PPUSH
16090: LD_INT 2
16092: NEG
16093: PPUSH
16094: CALL_OW 101
16098: GO 16233
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 25 then
16100: LD_INT 22
16102: PUSH
16103: LD_INT 2
16105: PUSH
16106: EMPTY
16107: LIST
16108: LIST
16109: PUSH
16110: LD_INT 21
16112: PUSH
16113: LD_INT 3
16115: PUSH
16116: EMPTY
16117: LIST
16118: LIST
16119: PUSH
16120: LD_INT 50
16122: PUSH
16123: EMPTY
16124: LIST
16125: PUSH
16126: EMPTY
16127: LIST
16128: LIST
16129: LIST
16130: PPUSH
16131: CALL_OW 69
16135: PUSH
16136: LD_INT 25
16138: GREATEREQUAL
16139: IFFALSE 16154
// AddMedal ( Destroy , - 1 ) else
16141: LD_STRING Destroy
16143: PPUSH
16144: LD_INT 1
16146: NEG
16147: PPUSH
16148: CALL_OW 101
16152: GO 16233
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 15 then
16154: LD_INT 22
16156: PUSH
16157: LD_INT 2
16159: PUSH
16160: EMPTY
16161: LIST
16162: LIST
16163: PUSH
16164: LD_INT 21
16166: PUSH
16167: LD_INT 3
16169: PUSH
16170: EMPTY
16171: LIST
16172: LIST
16173: PUSH
16174: LD_INT 50
16176: PUSH
16177: EMPTY
16178: LIST
16179: PUSH
16180: EMPTY
16181: LIST
16182: LIST
16183: LIST
16184: PPUSH
16185: CALL_OW 69
16189: PUSH
16190: LD_INT 15
16192: GREATEREQUAL
16193: IFFALSE 16215
// begin m1 := true ;
16195: LD_ADDR_VAR 0 3
16199: PUSH
16200: LD_INT 1
16202: ST_TO_ADDR
// AddMedal ( Destroy , 1 ) ;
16203: LD_STRING Destroy
16205: PPUSH
16206: LD_INT 1
16208: PPUSH
16209: CALL_OW 101
// end else
16213: GO 16233
// begin m1 := true ;
16215: LD_ADDR_VAR 0 3
16219: PUSH
16220: LD_INT 1
16222: ST_TO_ADDR
// AddMedal ( Destroy , 2 ) ;
16223: LD_STRING Destroy
16225: PPUSH
16226: LD_INT 2
16228: PPUSH
16229: CALL_OW 101
// end ; SaveVariable ( artifact_get , 11_artifact_captured ) ;
16233: LD_EXP 13
16237: PPUSH
16238: LD_STRING 11_artifact_captured
16240: PPUSH
16241: CALL_OW 39
// if artifact_get then
16245: LD_EXP 13
16249: IFFALSE 16271
// begin m2 := true ;
16251: LD_ADDR_VAR 0 4
16255: PUSH
16256: LD_INT 1
16258: ST_TO_ADDR
// AddMedal ( Artefact , 1 ) ;
16259: LD_STRING Artefact
16261: PPUSH
16262: LD_INT 1
16264: PPUSH
16265: CALL_OW 101
// end else
16269: GO 16282
// AddMedal ( Artefact , - 1 ) ;
16271: LD_STRING Artefact
16273: PPUSH
16274: LD_INT 1
16276: NEG
16277: PPUSH
16278: CALL_OW 101
// if m1 and m2 and m3 and Difficulty >= 3 then
16282: LD_VAR 0 3
16286: PUSH
16287: LD_VAR 0 4
16291: AND
16292: PUSH
16293: LD_VAR 0 5
16297: AND
16298: PUSH
16299: LD_OWVAR 67
16303: PUSH
16304: LD_INT 3
16306: GREATEREQUAL
16307: AND
16308: IFFALSE 16320
// SetAchievementEX ( ACH_AMER , 11 ) ;
16310: LD_STRING ACH_AMER
16312: PPUSH
16313: LD_INT 11
16315: PPUSH
16316: CALL_OW 564
// if m1 and m2 and m3 and loses_counter = 0 then
16320: LD_VAR 0 3
16324: PUSH
16325: LD_VAR 0 4
16329: AND
16330: PUSH
16331: LD_VAR 0 5
16335: AND
16336: PUSH
16337: LD_EXP 17
16341: PUSH
16342: LD_INT 0
16344: EQUAL
16345: AND
16346: IFFALSE 16362
// begin wait ( 3 ) ;
16348: LD_INT 3
16350: PPUSH
16351: CALL_OW 67
// SetAchievement ( ACH_GENERAL ) ;
16355: LD_STRING ACH_GENERAL
16357: PPUSH
16358: CALL_OW 543
// end ; if tick <= 100 100$00 then
16362: LD_OWVAR 1
16366: PUSH
16367: LD_INT 210000
16369: LESSEQUAL
16370: IFFALSE 16386
// begin wait ( 3 ) ;
16372: LD_INT 3
16374: PPUSH
16375: CALL_OW 67
// SetAchievement ( ACH_ASPEED_11 ) ;
16379: LD_STRING ACH_ASPEED_11
16381: PPUSH
16382: CALL_OW 543
// end ; GiveMedals ( MAIN ) ;
16386: LD_STRING MAIN
16388: PPUSH
16389: CALL_OW 102
// selected := UnitFilter ( selected , [ f_alive ] ) ;
16393: LD_ADDR_EXP 19
16397: PUSH
16398: LD_EXP 19
16402: PPUSH
16403: LD_INT 51
16405: PUSH
16406: EMPTY
16407: LIST
16408: PPUSH
16409: CALL_OW 72
16413: ST_TO_ADDR
// tmp := JMM ^ selected ;
16414: LD_ADDR_VAR 0 2
16418: PUSH
16419: LD_EXP 21
16423: PUSH
16424: LD_EXP 19
16428: ADD
16429: ST_TO_ADDR
// RewardPeople ( tmp ) ;
16430: LD_VAR 0 2
16434: PPUSH
16435: CALL_OW 43
// SaveCharacters ( tmp diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , 11c_others ) ;
16439: LD_VAR 0 2
16443: PUSH
16444: LD_EXP 21
16448: PUSH
16449: LD_EXP 22
16453: PUSH
16454: LD_EXP 23
16458: PUSH
16459: LD_EXP 24
16463: PUSH
16464: LD_EXP 25
16468: PUSH
16469: LD_EXP 26
16473: PUSH
16474: LD_EXP 27
16478: PUSH
16479: LD_EXP 28
16483: PUSH
16484: LD_EXP 29
16488: PUSH
16489: LD_EXP 31
16493: PUSH
16494: LD_EXP 32
16498: PUSH
16499: LD_EXP 33
16503: PUSH
16504: LD_EXP 34
16508: PUSH
16509: EMPTY
16510: LIST
16511: LIST
16512: LIST
16513: LIST
16514: LIST
16515: LIST
16516: LIST
16517: LIST
16518: LIST
16519: LIST
16520: LIST
16521: LIST
16522: LIST
16523: DIFF
16524: PPUSH
16525: LD_STRING 11c_others
16527: PPUSH
16528: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
16532: LD_EXP 21
16536: PPUSH
16537: LD_EXP 3
16541: PUSH
16542: LD_STRING JMM
16544: STR
16545: PPUSH
16546: CALL_OW 38
// if Lisa then
16550: LD_EXP 22
16554: IFFALSE 16574
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
16556: LD_EXP 22
16560: PPUSH
16561: LD_EXP 3
16565: PUSH
16566: LD_STRING Lisa
16568: STR
16569: PPUSH
16570: CALL_OW 38
// if Donaldson then
16574: LD_EXP 23
16578: IFFALSE 16598
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
16580: LD_EXP 23
16584: PPUSH
16585: LD_EXP 3
16589: PUSH
16590: LD_STRING Donaldson
16592: STR
16593: PPUSH
16594: CALL_OW 38
// if Bobby then
16598: LD_EXP 24
16602: IFFALSE 16622
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
16604: LD_EXP 24
16608: PPUSH
16609: LD_EXP 3
16613: PUSH
16614: LD_STRING Bobby
16616: STR
16617: PPUSH
16618: CALL_OW 38
// if Cyrus then
16622: LD_EXP 25
16626: IFFALSE 16646
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
16628: LD_EXP 25
16632: PPUSH
16633: LD_EXP 3
16637: PUSH
16638: LD_STRING Cyrus
16640: STR
16641: PPUSH
16642: CALL_OW 38
// if Denis then
16646: LD_EXP 26
16650: IFFALSE 16670
// SaveCharacters ( Denis , mission_prefix & Denis ) ;
16652: LD_EXP 26
16656: PPUSH
16657: LD_EXP 3
16661: PUSH
16662: LD_STRING Denis
16664: STR
16665: PPUSH
16666: CALL_OW 38
// if Brown then
16670: LD_EXP 27
16674: IFFALSE 16694
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
16676: LD_EXP 27
16680: PPUSH
16681: LD_EXP 3
16685: PUSH
16686: LD_STRING Brown
16688: STR
16689: PPUSH
16690: CALL_OW 38
// if Gladstone then
16694: LD_EXP 28
16698: IFFALSE 16718
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
16700: LD_EXP 28
16704: PPUSH
16705: LD_EXP 3
16709: PUSH
16710: LD_STRING Gladstone
16712: STR
16713: PPUSH
16714: CALL_OW 38
// if Houten then
16718: LD_EXP 29
16722: IFFALSE 16742
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
16724: LD_EXP 29
16728: PPUSH
16729: LD_EXP 3
16733: PUSH
16734: LD_STRING Houten
16736: STR
16737: PPUSH
16738: CALL_OW 38
// if Cornel then
16742: LD_EXP 31
16746: IFFALSE 16766
// SaveCharacters ( Cornel , mission_prefix & Cornell ) ;
16748: LD_EXP 31
16752: PPUSH
16753: LD_EXP 3
16757: PUSH
16758: LD_STRING Cornell
16760: STR
16761: PPUSH
16762: CALL_OW 38
// if Gary then
16766: LD_EXP 32
16770: IFFALSE 16790
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
16772: LD_EXP 32
16776: PPUSH
16777: LD_EXP 3
16781: PUSH
16782: LD_STRING Gary
16784: STR
16785: PPUSH
16786: CALL_OW 38
// if Frank then
16790: LD_EXP 33
16794: IFFALSE 16814
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
16796: LD_EXP 33
16800: PPUSH
16801: LD_EXP 3
16805: PUSH
16806: LD_STRING Frank
16808: STR
16809: PPUSH
16810: CALL_OW 38
// if Kikuchi then
16814: LD_EXP 34
16818: IFFALSE 16838
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
16820: LD_EXP 34
16824: PPUSH
16825: LD_EXP 3
16829: PUSH
16830: LD_STRING Kikuchi
16832: STR
16833: PPUSH
16834: CALL_OW 38
// YouWin ;
16838: CALL_OW 103
// end ;
16842: LD_VAR 0 1
16846: RET
// export function CanSayRand ( side ) ; begin
16847: LD_INT 0
16849: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16850: LD_ADDR_VAR 0 2
16854: PUSH
16855: LD_INT 52
16857: PUSH
16858: EMPTY
16859: LIST
16860: PUSH
16861: LD_INT 22
16863: PUSH
16864: LD_VAR 0 1
16868: PUSH
16869: EMPTY
16870: LIST
16871: LIST
16872: PUSH
16873: LD_INT 2
16875: PUSH
16876: LD_INT 25
16878: PUSH
16879: LD_INT 1
16881: PUSH
16882: EMPTY
16883: LIST
16884: LIST
16885: PUSH
16886: LD_INT 25
16888: PUSH
16889: LD_INT 2
16891: PUSH
16892: EMPTY
16893: LIST
16894: LIST
16895: PUSH
16896: LD_INT 25
16898: PUSH
16899: LD_INT 3
16901: PUSH
16902: EMPTY
16903: LIST
16904: LIST
16905: PUSH
16906: LD_INT 25
16908: PUSH
16909: LD_INT 4
16911: PUSH
16912: EMPTY
16913: LIST
16914: LIST
16915: PUSH
16916: EMPTY
16917: LIST
16918: LIST
16919: LIST
16920: LIST
16921: LIST
16922: PUSH
16923: EMPTY
16924: LIST
16925: LIST
16926: LIST
16927: PPUSH
16928: CALL_OW 69
16932: PUSH
16933: LD_EXP 21
16937: PUSH
16938: LD_EXP 33
16942: PUSH
16943: LD_EXP 22
16947: PUSH
16948: LD_EXP 23
16952: PUSH
16953: LD_EXP 24
16957: PUSH
16958: LD_EXP 25
16962: PUSH
16963: LD_EXP 26
16967: PUSH
16968: LD_EXP 27
16972: PUSH
16973: LD_EXP 28
16977: PUSH
16978: LD_EXP 29
16982: PUSH
16983: LD_EXP 30
16987: PUSH
16988: LD_EXP 31
16992: PUSH
16993: LD_EXP 32
16997: PUSH
16998: LD_EXP 34
17002: PUSH
17003: EMPTY
17004: LIST
17005: LIST
17006: LIST
17007: LIST
17008: LIST
17009: LIST
17010: LIST
17011: LIST
17012: LIST
17013: LIST
17014: LIST
17015: LIST
17016: LIST
17017: LIST
17018: DIFF
17019: ST_TO_ADDR
// end ;
17020: LD_VAR 0 2
17024: RET
// export function SayRand ( sex , dial ) ; begin
17025: LD_INT 0
17027: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
17028: LD_ADDR_VAR 0 3
17032: PUSH
17033: LD_INT 52
17035: PUSH
17036: EMPTY
17037: LIST
17038: PUSH
17039: LD_INT 22
17041: PUSH
17042: LD_INT 1
17044: PUSH
17045: EMPTY
17046: LIST
17047: LIST
17048: PUSH
17049: LD_INT 26
17051: PUSH
17052: LD_VAR 0 1
17056: PUSH
17057: EMPTY
17058: LIST
17059: LIST
17060: PUSH
17061: LD_INT 2
17063: PUSH
17064: LD_INT 25
17066: PUSH
17067: LD_INT 1
17069: PUSH
17070: EMPTY
17071: LIST
17072: LIST
17073: PUSH
17074: LD_INT 25
17076: PUSH
17077: LD_INT 2
17079: PUSH
17080: EMPTY
17081: LIST
17082: LIST
17083: PUSH
17084: LD_INT 25
17086: PUSH
17087: LD_INT 3
17089: PUSH
17090: EMPTY
17091: LIST
17092: LIST
17093: PUSH
17094: LD_INT 25
17096: PUSH
17097: LD_INT 4
17099: PUSH
17100: EMPTY
17101: LIST
17102: LIST
17103: PUSH
17104: EMPTY
17105: LIST
17106: LIST
17107: LIST
17108: LIST
17109: LIST
17110: PUSH
17111: EMPTY
17112: LIST
17113: LIST
17114: LIST
17115: LIST
17116: PPUSH
17117: CALL_OW 69
17121: PUSH
17122: LD_EXP 21
17126: PUSH
17127: LD_EXP 33
17131: PUSH
17132: LD_EXP 22
17136: PUSH
17137: LD_EXP 23
17141: PUSH
17142: LD_EXP 24
17146: PUSH
17147: LD_EXP 25
17151: PUSH
17152: LD_EXP 26
17156: PUSH
17157: LD_EXP 27
17161: PUSH
17162: LD_EXP 28
17166: PUSH
17167: LD_EXP 29
17171: PUSH
17172: LD_EXP 30
17176: PUSH
17177: LD_EXP 31
17181: PUSH
17182: LD_EXP 32
17186: PUSH
17187: LD_EXP 34
17191: PUSH
17192: EMPTY
17193: LIST
17194: LIST
17195: LIST
17196: LIST
17197: LIST
17198: LIST
17199: LIST
17200: LIST
17201: LIST
17202: LIST
17203: LIST
17204: LIST
17205: LIST
17206: LIST
17207: DIFF
17208: ST_TO_ADDR
// if not result then
17209: LD_VAR 0 3
17213: NOT
17214: IFFALSE 17218
// exit ;
17216: GO 17246
// result := result [ 1 ] ;
17218: LD_ADDR_VAR 0 3
17222: PUSH
17223: LD_VAR 0 3
17227: PUSH
17228: LD_INT 1
17230: ARRAY
17231: ST_TO_ADDR
// Say ( result , dial ) ;
17232: LD_VAR 0 3
17236: PPUSH
17237: LD_VAR 0 2
17241: PPUSH
17242: CALL_OW 88
// end ;
17246: LD_VAR 0 3
17250: RET
// export function SayRand2 ( sex , dial , filter ) ; begin
17251: LD_INT 0
17253: PPUSH
// result := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ^ filter ;
17254: LD_ADDR_VAR 0 4
17258: PUSH
17259: LD_INT 22
17261: PUSH
17262: LD_INT 1
17264: PUSH
17265: EMPTY
17266: LIST
17267: LIST
17268: PUSH
17269: LD_INT 26
17271: PUSH
17272: LD_VAR 0 1
17276: PUSH
17277: EMPTY
17278: LIST
17279: LIST
17280: PUSH
17281: LD_INT 2
17283: PUSH
17284: LD_INT 25
17286: PUSH
17287: LD_INT 1
17289: PUSH
17290: EMPTY
17291: LIST
17292: LIST
17293: PUSH
17294: LD_INT 25
17296: PUSH
17297: LD_INT 2
17299: PUSH
17300: EMPTY
17301: LIST
17302: LIST
17303: PUSH
17304: LD_INT 25
17306: PUSH
17307: LD_INT 3
17309: PUSH
17310: EMPTY
17311: LIST
17312: LIST
17313: PUSH
17314: LD_INT 25
17316: PUSH
17317: LD_INT 4
17319: PUSH
17320: EMPTY
17321: LIST
17322: LIST
17323: PUSH
17324: EMPTY
17325: LIST
17326: LIST
17327: LIST
17328: LIST
17329: LIST
17330: PUSH
17331: EMPTY
17332: LIST
17333: LIST
17334: LIST
17335: PPUSH
17336: CALL_OW 69
17340: PUSH
17341: LD_EXP 21
17345: PUSH
17346: LD_EXP 33
17350: PUSH
17351: LD_EXP 22
17355: PUSH
17356: LD_EXP 23
17360: PUSH
17361: LD_EXP 24
17365: PUSH
17366: LD_EXP 25
17370: PUSH
17371: LD_EXP 26
17375: PUSH
17376: LD_EXP 27
17380: PUSH
17381: LD_EXP 28
17385: PUSH
17386: LD_EXP 29
17390: PUSH
17391: LD_EXP 30
17395: PUSH
17396: LD_EXP 31
17400: PUSH
17401: LD_EXP 32
17405: PUSH
17406: LD_EXP 34
17410: PUSH
17411: EMPTY
17412: LIST
17413: LIST
17414: LIST
17415: LIST
17416: LIST
17417: LIST
17418: LIST
17419: LIST
17420: LIST
17421: LIST
17422: LIST
17423: LIST
17424: LIST
17425: LIST
17426: PUSH
17427: LD_VAR 0 3
17431: ADD
17432: DIFF
17433: ST_TO_ADDR
// if not result then
17434: LD_VAR 0 4
17438: NOT
17439: IFFALSE 17443
// exit ;
17441: GO 17471
// result := result [ 1 ] ;
17443: LD_ADDR_VAR 0 4
17447: PUSH
17448: LD_VAR 0 4
17452: PUSH
17453: LD_INT 1
17455: ARRAY
17456: ST_TO_ADDR
// Say ( result , dial ) ;
17457: LD_VAR 0 4
17461: PPUSH
17462: LD_VAR 0 2
17466: PPUSH
17467: CALL_OW 88
// end ; end_of_file
17471: LD_VAR 0 4
17475: RET
// export function CustomEvent ( event ) ; begin
17476: LD_INT 0
17478: PPUSH
// end ;
17479: LD_VAR 0 2
17483: RET
// on ArtifactLoaded ( cargo , artifact ) do begin if GetSide ( cargo ) = 1 then
17484: LD_VAR 0 1
17488: PPUSH
17489: CALL_OW 255
17493: PUSH
17494: LD_INT 1
17496: EQUAL
17497: IFFALSE 17507
// artifact_get := true ;
17499: LD_ADDR_EXP 13
17503: PUSH
17504: LD_INT 1
17506: ST_TO_ADDR
// if GetSide ( cargo ) = 2 then
17507: LD_VAR 0 1
17511: PPUSH
17512: CALL_OW 255
17516: PUSH
17517: LD_INT 2
17519: EQUAL
17520: IFFALSE 17538
// begin artifact_get := false ;
17522: LD_ADDR_EXP 13
17526: PUSH
17527: LD_INT 0
17529: ST_TO_ADDR
// artifact_stolen := true ;
17530: LD_ADDR_EXP 12
17534: PUSH
17535: LD_INT 1
17537: ST_TO_ADDR
// end ; artifact_oncargo := true ;
17538: LD_ADDR_EXP 14
17542: PUSH
17543: LD_INT 1
17545: ST_TO_ADDR
// end ;
17546: PPOPN 2
17548: END
// on ArtifactUnloaded ( cargo , artifact ) do begin artifact_oncargo := false ;
17549: LD_ADDR_EXP 14
17553: PUSH
17554: LD_INT 0
17556: ST_TO_ADDR
// end ;
17557: PPOPN 2
17559: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
17560: LD_VAR 0 1
17564: PPUSH
17565: CALL 107773 0 1
// if un = JMM then
17569: LD_VAR 0 1
17573: PUSH
17574: LD_EXP 21
17578: EQUAL
17579: IFFALSE 17590
// begin YouLost ( JMM ) ;
17581: LD_STRING JMM
17583: PPUSH
17584: CALL_OW 104
// exit ;
17588: GO 17722
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) then
17590: LD_VAR 0 1
17594: PUSH
17595: LD_INT 22
17597: PUSH
17598: LD_INT 1
17600: PUSH
17601: EMPTY
17602: LIST
17603: LIST
17604: PUSH
17605: LD_INT 21
17607: PUSH
17608: LD_INT 1
17610: PUSH
17611: EMPTY
17612: LIST
17613: LIST
17614: PUSH
17615: LD_INT 2
17617: PUSH
17618: LD_INT 25
17620: PUSH
17621: LD_INT 1
17623: PUSH
17624: EMPTY
17625: LIST
17626: LIST
17627: PUSH
17628: LD_INT 25
17630: PUSH
17631: LD_INT 2
17633: PUSH
17634: EMPTY
17635: LIST
17636: LIST
17637: PUSH
17638: LD_INT 25
17640: PUSH
17641: LD_INT 3
17643: PUSH
17644: EMPTY
17645: LIST
17646: LIST
17647: PUSH
17648: LD_INT 25
17650: PUSH
17651: LD_INT 4
17653: PUSH
17654: EMPTY
17655: LIST
17656: LIST
17657: PUSH
17658: LD_INT 25
17660: PUSH
17661: LD_INT 5
17663: PUSH
17664: EMPTY
17665: LIST
17666: LIST
17667: PUSH
17668: LD_INT 25
17670: PUSH
17671: LD_INT 8
17673: PUSH
17674: EMPTY
17675: LIST
17676: LIST
17677: PUSH
17678: EMPTY
17679: LIST
17680: LIST
17681: LIST
17682: LIST
17683: LIST
17684: LIST
17685: LIST
17686: PUSH
17687: EMPTY
17688: LIST
17689: LIST
17690: LIST
17691: PPUSH
17692: CALL_OW 69
17696: IN
17697: IFFALSE 17713
// loses_counter := loses_counter + 1 ;
17699: LD_ADDR_EXP 17
17703: PUSH
17704: LD_EXP 17
17708: PUSH
17709: LD_INT 1
17711: PLUS
17712: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
17713: LD_VAR 0 1
17717: PPUSH
17718: CALL 46199 0 1
// end ;
17722: PPOPN 1
17724: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
17725: LD_VAR 0 1
17729: PPUSH
17730: LD_VAR 0 2
17734: PPUSH
17735: CALL 48531 0 2
// end ;
17739: PPOPN 2
17741: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
17742: LD_VAR 0 1
17746: PPUSH
17747: CALL 47840 0 1
// end ;
17751: PPOPN 1
17753: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
17754: LD_VAR 0 1
17758: PPUSH
17759: LD_VAR 0 2
17763: PPUSH
17764: LD_VAR 0 3
17768: PPUSH
17769: LD_VAR 0 4
17773: PPUSH
17774: LD_VAR 0 5
17778: PPUSH
17779: CALL 45515 0 5
// end ;
17783: PPOPN 5
17785: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
17786: LD_VAR 0 1
17790: PPUSH
17791: LD_VAR 0 2
17795: PPUSH
17796: CALL 107893 0 2
// if GetNation ( vehicle ) = nation_american then
17800: LD_VAR 0 1
17804: PPUSH
17805: CALL_OW 248
17809: PUSH
17810: LD_INT 1
17812: EQUAL
17813: IFFALSE 17823
// am_veh_consturcted := true ;
17815: LD_ADDR_EXP 20
17819: PUSH
17820: LD_INT 1
17822: ST_TO_ADDR
// MCE_VehicleConstructed ( vehicle , factory ) ;
17823: LD_VAR 0 1
17827: PPUSH
17828: LD_VAR 0 2
17832: PPUSH
17833: CALL 45068 0 2
// end ;
17837: PPOPN 2
17839: END
// on UnitKamikazed ( unit ) do begin if GetType ( unit ) = unit_vehicle then
17840: LD_VAR 0 1
17844: PPUSH
17845: CALL_OW 247
17849: PUSH
17850: LD_INT 2
17852: EQUAL
17853: IFFALSE 17857
// exit ;
17855: GO 17874
// if not kamikazed then
17857: LD_EXP 11
17861: NOT
17862: IFFALSE 17874
// kamikazed := unit ;
17864: LD_ADDR_EXP 11
17868: PUSH
17869: LD_VAR 0 1
17873: ST_TO_ADDR
// end ;
17874: PPOPN 1
17876: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do var i , tmp ;
17877: LD_INT 0
17879: PPUSH
17880: PPUSH
// begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
17881: LD_VAR 0 1
17885: PPUSH
17886: LD_VAR 0 2
17890: PPUSH
17891: LD_VAR 0 3
17895: PPUSH
17896: LD_VAR 0 4
17900: PPUSH
17901: CALL 44906 0 4
// end ;
17905: PPOPN 6
17907: END
// on BuildingCaptured ( building , side , capturning_unit ) do var i ;
17908: LD_INT 0
17910: PPUSH
// begin if building = ar_dep_n then
17911: LD_VAR 0 1
17915: PUSH
17916: LD_INT 94
17918: EQUAL
17919: IFFALSE 17971
// begin for i := 1 to 3 do
17921: LD_ADDR_VAR 0 4
17925: PUSH
17926: DOUBLE
17927: LD_INT 1
17929: DEC
17930: ST_TO_ADDR
17931: LD_INT 3
17933: PUSH
17934: FOR_TO
17935: IFFALSE 17969
// begin MineExplosion ( 115 + ( i * 2 ) , 6 , 1 ) ;
17937: LD_INT 115
17939: PUSH
17940: LD_VAR 0 4
17944: PUSH
17945: LD_INT 2
17947: MUL
17948: PLUS
17949: PPUSH
17950: LD_INT 6
17952: PPUSH
17953: LD_INT 1
17955: PPUSH
17956: CALL_OW 453
// wait ( 0 0$0.3 ) ;
17960: LD_INT 10
17962: PPUSH
17963: CALL_OW 67
// end ;
17967: GO 17934
17969: POP
17970: POP
// end ; MCE_BuildingCaptured ( building , side , capturning_unit ) ;
17971: LD_VAR 0 1
17975: PPUSH
17976: LD_VAR 0 2
17980: PPUSH
17981: LD_VAR 0 3
17985: PPUSH
17986: CALL 44681 0 3
// end ;
17990: PPOPN 4
17992: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
17993: LD_VAR 0 1
17997: PPUSH
17998: LD_VAR 0 2
18002: PPUSH
18003: CALL 45895 0 2
// end ;
18007: PPOPN 2
18009: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
18010: LD_VAR 0 1
18014: PPUSH
18015: LD_VAR 0 2
18019: PPUSH
18020: CALL 44375 0 2
// end ;
18024: PPOPN 2
18026: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
18027: LD_VAR 0 1
18031: PPUSH
18032: LD_VAR 0 2
18036: PPUSH
18037: CALL 44566 0 2
// end ;
18041: PPOPN 2
18043: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
18044: LD_VAR 0 1
18048: PPUSH
18049: CALL 47599 0 1
// end ;
18053: PPOPN 1
18055: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
18056: LD_VAR 0 1
18060: PPUSH
18061: LD_VAR 0 2
18065: PPUSH
18066: CALL 48826 0 2
// end ;
18070: PPOPN 2
18072: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
18073: LD_VAR 0 1
18077: PPUSH
18078: LD_VAR 0 2
18082: PPUSH
18083: LD_VAR 0 3
18087: PPUSH
18088: LD_VAR 0 4
18092: PPUSH
18093: CALL 49042 0 4
// end ;
18097: PPOPN 4
18099: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
18100: LD_VAR 0 1
18104: PPUSH
18105: CALL 107877 0 1
// end ;
18109: PPOPN 1
18111: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_ok ] , [ f_type , engine_combustion ] ] ) do var i ;
18112: LD_INT 22
18114: PUSH
18115: LD_INT 2
18117: PUSH
18118: EMPTY
18119: LIST
18120: LIST
18121: PUSH
18122: LD_INT 50
18124: PUSH
18125: EMPTY
18126: LIST
18127: PUSH
18128: LD_INT 21
18130: PUSH
18131: LD_INT 1
18133: PUSH
18134: EMPTY
18135: LIST
18136: LIST
18137: PUSH
18138: EMPTY
18139: LIST
18140: LIST
18141: LIST
18142: PPUSH
18143: CALL_OW 69
18147: IFFALSE 18231
18149: GO 18151
18151: DISABLE
18152: LD_INT 0
18154: PPUSH
// begin enable ;
18155: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_ok ] , [ f_type , engine_combustion ] ] ) do
18156: LD_ADDR_VAR 0 1
18160: PUSH
18161: LD_INT 22
18163: PUSH
18164: LD_INT 2
18166: PUSH
18167: EMPTY
18168: LIST
18169: LIST
18170: PUSH
18171: LD_INT 50
18173: PUSH
18174: EMPTY
18175: LIST
18176: PUSH
18177: LD_INT 21
18179: PUSH
18180: LD_INT 1
18182: PUSH
18183: EMPTY
18184: LIST
18185: LIST
18186: PUSH
18187: EMPTY
18188: LIST
18189: LIST
18190: LIST
18191: PPUSH
18192: CALL_OW 69
18196: PUSH
18197: FOR_IN
18198: IFFALSE 18229
// if GetFuel ( i ) < 3 then
18200: LD_VAR 0 1
18204: PPUSH
18205: CALL_OW 261
18209: PUSH
18210: LD_INT 3
18212: LESS
18213: IFFALSE 18227
// SetFuel ( i , 5 ) ;
18215: LD_VAR 0 1
18219: PPUSH
18220: LD_INT 5
18222: PPUSH
18223: CALL_OW 240
18227: GO 18197
18229: POP
18230: POP
// end ; end_of_file
18231: PPOPN 1
18233: END
// every 0 0$1 trigger game do
18234: LD_EXP 2
18238: IFFALSE 18268
18240: GO 18242
18242: DISABLE
// SpawnCrates ( [ crates_west , crates_east , crates_north_west , crates_east ] , 0 0$50 ) ;
18243: LD_INT 7
18245: PUSH
18246: LD_INT 6
18248: PUSH
18249: LD_INT 4
18251: PUSH
18252: LD_INT 6
18254: PUSH
18255: EMPTY
18256: LIST
18257: LIST
18258: LIST
18259: LIST
18260: PPUSH
18261: LD_INT 1750
18263: PPUSH
18264: CALL 18269 0 2
18268: END
// export function SpawnCrates ( areas , time ) ; var i , p ; begin
18269: LD_INT 0
18271: PPUSH
18272: PPUSH
18273: PPUSH
// if not areas then
18274: LD_VAR 0 1
18278: NOT
18279: IFFALSE 18283
// exit ;
18281: GO 18413
// repeat wait ( time ) ;
18283: LD_VAR 0 2
18287: PPUSH
18288: CALL_OW 67
// for i in areas do
18292: LD_ADDR_VAR 0 4
18296: PUSH
18297: LD_VAR 0 1
18301: PUSH
18302: FOR_IN
18303: IFFALSE 18372
// begin p := rand ( 1 , 90 ) ;
18305: LD_ADDR_VAR 0 5
18309: PUSH
18310: LD_INT 1
18312: PPUSH
18313: LD_INT 90
18315: PPUSH
18316: CALL_OW 12
18320: ST_TO_ADDR
// if Prob ( p ) then
18321: LD_VAR 0 5
18325: PPUSH
18326: CALL_OW 13
18330: IFFALSE 18370
// begin CreateCratesArea ( rand ( 2 , 5 ) , i , true ) ;
18332: LD_INT 2
18334: PPUSH
18335: LD_INT 5
18337: PPUSH
18338: CALL_OW 12
18342: PPUSH
18343: LD_VAR 0 4
18347: PPUSH
18348: LD_INT 1
18350: PPUSH
18351: CALL_OW 55
// wait ( rand ( 0 0$21 , 0 0$37 ) ) ;
18355: LD_INT 735
18357: PPUSH
18358: LD_INT 1295
18360: PPUSH
18361: CALL_OW 12
18365: PPUSH
18366: CALL_OW 67
// end ; end ;
18370: GO 18302
18372: POP
18373: POP
// time := time + 0 0$3 ;
18374: LD_ADDR_VAR 0 2
18378: PUSH
18379: LD_VAR 0 2
18383: PUSH
18384: LD_INT 105
18386: PLUS
18387: ST_TO_ADDR
// if time > 3 3$00 then
18388: LD_VAR 0 2
18392: PUSH
18393: LD_INT 6300
18395: GREATER
18396: IFFALSE 18406
// time := 0 0$40 ;
18398: LD_ADDR_VAR 0 2
18402: PUSH
18403: LD_INT 1400
18405: ST_TO_ADDR
// until not game ;
18406: LD_EXP 2
18410: NOT
18411: IFFALSE 18283
// end ;
18413: LD_VAR 0 3
18417: RET
// every 0 0$45 + 3 3$00 trigger tick < [ 40 40$00 , 35 35$00 , 30 30$00 , 25 25$00 ] [ Difficulty ] do
18418: LD_OWVAR 1
18422: PUSH
18423: LD_INT 84000
18425: PUSH
18426: LD_INT 73500
18428: PUSH
18429: LD_INT 63000
18431: PUSH
18432: LD_INT 52500
18434: PUSH
18435: EMPTY
18436: LIST
18437: LIST
18438: LIST
18439: LIST
18440: PUSH
18441: LD_OWVAR 67
18445: ARRAY
18446: LESS
18447: IFFALSE 18474
18449: GO 18451
18451: DISABLE
// begin enable ;
18452: ENABLE
// CreateCratesArea ( rand ( 1 , 5 ) , crates_west , true ) ;
18453: LD_INT 1
18455: PPUSH
18456: LD_INT 5
18458: PPUSH
18459: CALL_OW 12
18463: PPUSH
18464: LD_INT 7
18466: PPUSH
18467: LD_INT 1
18469: PPUSH
18470: CALL_OW 55
// end ; end_of_file
18474: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
18475: LD_INT 0
18477: PPUSH
18478: PPUSH
// skirmish := false ;
18479: LD_ADDR_EXP 48
18483: PUSH
18484: LD_INT 0
18486: ST_TO_ADDR
// debug_mc := false ;
18487: LD_ADDR_EXP 49
18491: PUSH
18492: LD_INT 0
18494: ST_TO_ADDR
// mc_bases := [ ] ;
18495: LD_ADDR_EXP 50
18499: PUSH
18500: EMPTY
18501: ST_TO_ADDR
// mc_sides := [ ] ;
18502: LD_ADDR_EXP 76
18506: PUSH
18507: EMPTY
18508: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
18509: LD_ADDR_EXP 51
18513: PUSH
18514: EMPTY
18515: ST_TO_ADDR
// mc_building_repairs := [ ] ;
18516: LD_ADDR_EXP 52
18520: PUSH
18521: EMPTY
18522: ST_TO_ADDR
// mc_need_heal := [ ] ;
18523: LD_ADDR_EXP 53
18527: PUSH
18528: EMPTY
18529: ST_TO_ADDR
// mc_healers := [ ] ;
18530: LD_ADDR_EXP 54
18534: PUSH
18535: EMPTY
18536: ST_TO_ADDR
// mc_build_list := [ ] ;
18537: LD_ADDR_EXP 55
18541: PUSH
18542: EMPTY
18543: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
18544: LD_ADDR_EXP 82
18548: PUSH
18549: EMPTY
18550: ST_TO_ADDR
// mc_builders := [ ] ;
18551: LD_ADDR_EXP 56
18555: PUSH
18556: EMPTY
18557: ST_TO_ADDR
// mc_construct_list := [ ] ;
18558: LD_ADDR_EXP 57
18562: PUSH
18563: EMPTY
18564: ST_TO_ADDR
// mc_turret_list := [ ] ;
18565: LD_ADDR_EXP 58
18569: PUSH
18570: EMPTY
18571: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
18572: LD_ADDR_EXP 59
18576: PUSH
18577: EMPTY
18578: ST_TO_ADDR
// mc_miners := [ ] ;
18579: LD_ADDR_EXP 64
18583: PUSH
18584: EMPTY
18585: ST_TO_ADDR
// mc_mines := [ ] ;
18586: LD_ADDR_EXP 63
18590: PUSH
18591: EMPTY
18592: ST_TO_ADDR
// mc_minefields := [ ] ;
18593: LD_ADDR_EXP 65
18597: PUSH
18598: EMPTY
18599: ST_TO_ADDR
// mc_crates := [ ] ;
18600: LD_ADDR_EXP 66
18604: PUSH
18605: EMPTY
18606: ST_TO_ADDR
// mc_crates_collector := [ ] ;
18607: LD_ADDR_EXP 67
18611: PUSH
18612: EMPTY
18613: ST_TO_ADDR
// mc_crates_area := [ ] ;
18614: LD_ADDR_EXP 68
18618: PUSH
18619: EMPTY
18620: ST_TO_ADDR
// mc_vehicles := [ ] ;
18621: LD_ADDR_EXP 69
18625: PUSH
18626: EMPTY
18627: ST_TO_ADDR
// mc_attack := [ ] ;
18628: LD_ADDR_EXP 70
18632: PUSH
18633: EMPTY
18634: ST_TO_ADDR
// mc_produce := [ ] ;
18635: LD_ADDR_EXP 71
18639: PUSH
18640: EMPTY
18641: ST_TO_ADDR
// mc_defender := [ ] ;
18642: LD_ADDR_EXP 72
18646: PUSH
18647: EMPTY
18648: ST_TO_ADDR
// mc_parking := [ ] ;
18649: LD_ADDR_EXP 74
18653: PUSH
18654: EMPTY
18655: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
18656: LD_ADDR_EXP 60
18660: PUSH
18661: EMPTY
18662: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
18663: LD_ADDR_EXP 62
18667: PUSH
18668: EMPTY
18669: ST_TO_ADDR
// mc_scan := [ ] ;
18670: LD_ADDR_EXP 73
18674: PUSH
18675: EMPTY
18676: ST_TO_ADDR
// mc_scan_area := [ ] ;
18677: LD_ADDR_EXP 75
18681: PUSH
18682: EMPTY
18683: ST_TO_ADDR
// mc_tech := [ ] ;
18684: LD_ADDR_EXP 77
18688: PUSH
18689: EMPTY
18690: ST_TO_ADDR
// mc_class := [ ] ;
18691: LD_ADDR_EXP 91
18695: PUSH
18696: EMPTY
18697: ST_TO_ADDR
// mc_class_case_use := [ ] ;
18698: LD_ADDR_EXP 92
18702: PUSH
18703: EMPTY
18704: ST_TO_ADDR
// mc_is_defending := [ ] ;
18705: LD_ADDR_EXP 93
18709: PUSH
18710: EMPTY
18711: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
18712: LD_ADDR_EXP 84
18716: PUSH
18717: EMPTY
18718: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
18719: LD_ADDR_EXP 94
18723: PUSH
18724: LD_INT 0
18726: ST_TO_ADDR
// end ;
18727: LD_VAR 0 1
18731: RET
// export function MC_Kill ( base ) ; begin
18732: LD_INT 0
18734: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
18735: LD_ADDR_EXP 50
18739: PUSH
18740: LD_EXP 50
18744: PPUSH
18745: LD_VAR 0 1
18749: PPUSH
18750: EMPTY
18751: PPUSH
18752: CALL_OW 1
18756: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
18757: LD_ADDR_EXP 51
18761: PUSH
18762: LD_EXP 51
18766: PPUSH
18767: LD_VAR 0 1
18771: PPUSH
18772: EMPTY
18773: PPUSH
18774: CALL_OW 1
18778: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
18779: LD_ADDR_EXP 52
18783: PUSH
18784: LD_EXP 52
18788: PPUSH
18789: LD_VAR 0 1
18793: PPUSH
18794: EMPTY
18795: PPUSH
18796: CALL_OW 1
18800: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
18801: LD_ADDR_EXP 53
18805: PUSH
18806: LD_EXP 53
18810: PPUSH
18811: LD_VAR 0 1
18815: PPUSH
18816: EMPTY
18817: PPUSH
18818: CALL_OW 1
18822: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
18823: LD_ADDR_EXP 54
18827: PUSH
18828: LD_EXP 54
18832: PPUSH
18833: LD_VAR 0 1
18837: PPUSH
18838: EMPTY
18839: PPUSH
18840: CALL_OW 1
18844: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
18845: LD_ADDR_EXP 55
18849: PUSH
18850: LD_EXP 55
18854: PPUSH
18855: LD_VAR 0 1
18859: PPUSH
18860: EMPTY
18861: PPUSH
18862: CALL_OW 1
18866: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
18867: LD_ADDR_EXP 56
18871: PUSH
18872: LD_EXP 56
18876: PPUSH
18877: LD_VAR 0 1
18881: PPUSH
18882: EMPTY
18883: PPUSH
18884: CALL_OW 1
18888: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
18889: LD_ADDR_EXP 57
18893: PUSH
18894: LD_EXP 57
18898: PPUSH
18899: LD_VAR 0 1
18903: PPUSH
18904: EMPTY
18905: PPUSH
18906: CALL_OW 1
18910: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
18911: LD_ADDR_EXP 58
18915: PUSH
18916: LD_EXP 58
18920: PPUSH
18921: LD_VAR 0 1
18925: PPUSH
18926: EMPTY
18927: PPUSH
18928: CALL_OW 1
18932: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
18933: LD_ADDR_EXP 59
18937: PUSH
18938: LD_EXP 59
18942: PPUSH
18943: LD_VAR 0 1
18947: PPUSH
18948: EMPTY
18949: PPUSH
18950: CALL_OW 1
18954: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
18955: LD_ADDR_EXP 60
18959: PUSH
18960: LD_EXP 60
18964: PPUSH
18965: LD_VAR 0 1
18969: PPUSH
18970: EMPTY
18971: PPUSH
18972: CALL_OW 1
18976: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
18977: LD_ADDR_EXP 61
18981: PUSH
18982: LD_EXP 61
18986: PPUSH
18987: LD_VAR 0 1
18991: PPUSH
18992: LD_INT 0
18994: PPUSH
18995: CALL_OW 1
18999: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
19000: LD_ADDR_EXP 62
19004: PUSH
19005: LD_EXP 62
19009: PPUSH
19010: LD_VAR 0 1
19014: PPUSH
19015: EMPTY
19016: PPUSH
19017: CALL_OW 1
19021: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
19022: LD_ADDR_EXP 63
19026: PUSH
19027: LD_EXP 63
19031: PPUSH
19032: LD_VAR 0 1
19036: PPUSH
19037: EMPTY
19038: PPUSH
19039: CALL_OW 1
19043: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
19044: LD_ADDR_EXP 64
19048: PUSH
19049: LD_EXP 64
19053: PPUSH
19054: LD_VAR 0 1
19058: PPUSH
19059: EMPTY
19060: PPUSH
19061: CALL_OW 1
19065: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
19066: LD_ADDR_EXP 65
19070: PUSH
19071: LD_EXP 65
19075: PPUSH
19076: LD_VAR 0 1
19080: PPUSH
19081: EMPTY
19082: PPUSH
19083: CALL_OW 1
19087: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
19088: LD_ADDR_EXP 66
19092: PUSH
19093: LD_EXP 66
19097: PPUSH
19098: LD_VAR 0 1
19102: PPUSH
19103: EMPTY
19104: PPUSH
19105: CALL_OW 1
19109: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
19110: LD_ADDR_EXP 67
19114: PUSH
19115: LD_EXP 67
19119: PPUSH
19120: LD_VAR 0 1
19124: PPUSH
19125: EMPTY
19126: PPUSH
19127: CALL_OW 1
19131: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
19132: LD_ADDR_EXP 68
19136: PUSH
19137: LD_EXP 68
19141: PPUSH
19142: LD_VAR 0 1
19146: PPUSH
19147: EMPTY
19148: PPUSH
19149: CALL_OW 1
19153: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
19154: LD_ADDR_EXP 69
19158: PUSH
19159: LD_EXP 69
19163: PPUSH
19164: LD_VAR 0 1
19168: PPUSH
19169: EMPTY
19170: PPUSH
19171: CALL_OW 1
19175: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
19176: LD_ADDR_EXP 70
19180: PUSH
19181: LD_EXP 70
19185: PPUSH
19186: LD_VAR 0 1
19190: PPUSH
19191: EMPTY
19192: PPUSH
19193: CALL_OW 1
19197: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
19198: LD_ADDR_EXP 71
19202: PUSH
19203: LD_EXP 71
19207: PPUSH
19208: LD_VAR 0 1
19212: PPUSH
19213: EMPTY
19214: PPUSH
19215: CALL_OW 1
19219: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
19220: LD_ADDR_EXP 72
19224: PUSH
19225: LD_EXP 72
19229: PPUSH
19230: LD_VAR 0 1
19234: PPUSH
19235: EMPTY
19236: PPUSH
19237: CALL_OW 1
19241: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
19242: LD_ADDR_EXP 73
19246: PUSH
19247: LD_EXP 73
19251: PPUSH
19252: LD_VAR 0 1
19256: PPUSH
19257: EMPTY
19258: PPUSH
19259: CALL_OW 1
19263: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
19264: LD_ADDR_EXP 74
19268: PUSH
19269: LD_EXP 74
19273: PPUSH
19274: LD_VAR 0 1
19278: PPUSH
19279: EMPTY
19280: PPUSH
19281: CALL_OW 1
19285: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
19286: LD_ADDR_EXP 75
19290: PUSH
19291: LD_EXP 75
19295: PPUSH
19296: LD_VAR 0 1
19300: PPUSH
19301: EMPTY
19302: PPUSH
19303: CALL_OW 1
19307: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
19308: LD_ADDR_EXP 77
19312: PUSH
19313: LD_EXP 77
19317: PPUSH
19318: LD_VAR 0 1
19322: PPUSH
19323: EMPTY
19324: PPUSH
19325: CALL_OW 1
19329: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
19330: LD_ADDR_EXP 79
19334: PUSH
19335: LD_EXP 79
19339: PPUSH
19340: LD_VAR 0 1
19344: PPUSH
19345: EMPTY
19346: PPUSH
19347: CALL_OW 1
19351: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
19352: LD_ADDR_EXP 80
19356: PUSH
19357: LD_EXP 80
19361: PPUSH
19362: LD_VAR 0 1
19366: PPUSH
19367: EMPTY
19368: PPUSH
19369: CALL_OW 1
19373: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
19374: LD_ADDR_EXP 81
19378: PUSH
19379: LD_EXP 81
19383: PPUSH
19384: LD_VAR 0 1
19388: PPUSH
19389: EMPTY
19390: PPUSH
19391: CALL_OW 1
19395: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
19396: LD_ADDR_EXP 82
19400: PUSH
19401: LD_EXP 82
19405: PPUSH
19406: LD_VAR 0 1
19410: PPUSH
19411: EMPTY
19412: PPUSH
19413: CALL_OW 1
19417: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
19418: LD_ADDR_EXP 83
19422: PUSH
19423: LD_EXP 83
19427: PPUSH
19428: LD_VAR 0 1
19432: PPUSH
19433: EMPTY
19434: PPUSH
19435: CALL_OW 1
19439: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
19440: LD_ADDR_EXP 84
19444: PUSH
19445: LD_EXP 84
19449: PPUSH
19450: LD_VAR 0 1
19454: PPUSH
19455: EMPTY
19456: PPUSH
19457: CALL_OW 1
19461: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
19462: LD_ADDR_EXP 85
19466: PUSH
19467: LD_EXP 85
19471: PPUSH
19472: LD_VAR 0 1
19476: PPUSH
19477: EMPTY
19478: PPUSH
19479: CALL_OW 1
19483: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
19484: LD_ADDR_EXP 86
19488: PUSH
19489: LD_EXP 86
19493: PPUSH
19494: LD_VAR 0 1
19498: PPUSH
19499: EMPTY
19500: PPUSH
19501: CALL_OW 1
19505: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
19506: LD_ADDR_EXP 87
19510: PUSH
19511: LD_EXP 87
19515: PPUSH
19516: LD_VAR 0 1
19520: PPUSH
19521: EMPTY
19522: PPUSH
19523: CALL_OW 1
19527: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
19528: LD_ADDR_EXP 88
19532: PUSH
19533: LD_EXP 88
19537: PPUSH
19538: LD_VAR 0 1
19542: PPUSH
19543: EMPTY
19544: PPUSH
19545: CALL_OW 1
19549: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
19550: LD_ADDR_EXP 89
19554: PUSH
19555: LD_EXP 89
19559: PPUSH
19560: LD_VAR 0 1
19564: PPUSH
19565: EMPTY
19566: PPUSH
19567: CALL_OW 1
19571: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
19572: LD_ADDR_EXP 90
19576: PUSH
19577: LD_EXP 90
19581: PPUSH
19582: LD_VAR 0 1
19586: PPUSH
19587: EMPTY
19588: PPUSH
19589: CALL_OW 1
19593: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
19594: LD_ADDR_EXP 91
19598: PUSH
19599: LD_EXP 91
19603: PPUSH
19604: LD_VAR 0 1
19608: PPUSH
19609: EMPTY
19610: PPUSH
19611: CALL_OW 1
19615: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
19616: LD_ADDR_EXP 92
19620: PUSH
19621: LD_EXP 92
19625: PPUSH
19626: LD_VAR 0 1
19630: PPUSH
19631: LD_INT 0
19633: PPUSH
19634: CALL_OW 1
19638: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
19639: LD_ADDR_EXP 93
19643: PUSH
19644: LD_EXP 93
19648: PPUSH
19649: LD_VAR 0 1
19653: PPUSH
19654: LD_INT 0
19656: PPUSH
19657: CALL_OW 1
19661: ST_TO_ADDR
// end ;
19662: LD_VAR 0 2
19666: RET
// export function MC_Add ( side , units ) ; var base ; begin
19667: LD_INT 0
19669: PPUSH
19670: PPUSH
// base := mc_bases + 1 ;
19671: LD_ADDR_VAR 0 4
19675: PUSH
19676: LD_EXP 50
19680: PUSH
19681: LD_INT 1
19683: PLUS
19684: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
19685: LD_ADDR_EXP 76
19689: PUSH
19690: LD_EXP 76
19694: PPUSH
19695: LD_VAR 0 4
19699: PPUSH
19700: LD_VAR 0 1
19704: PPUSH
19705: CALL_OW 1
19709: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
19710: LD_ADDR_EXP 50
19714: PUSH
19715: LD_EXP 50
19719: PPUSH
19720: LD_VAR 0 4
19724: PPUSH
19725: LD_VAR 0 2
19729: PPUSH
19730: CALL_OW 1
19734: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
19735: LD_ADDR_EXP 51
19739: PUSH
19740: LD_EXP 51
19744: PPUSH
19745: LD_VAR 0 4
19749: PPUSH
19750: EMPTY
19751: PPUSH
19752: CALL_OW 1
19756: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
19757: LD_ADDR_EXP 52
19761: PUSH
19762: LD_EXP 52
19766: PPUSH
19767: LD_VAR 0 4
19771: PPUSH
19772: EMPTY
19773: PPUSH
19774: CALL_OW 1
19778: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
19779: LD_ADDR_EXP 53
19783: PUSH
19784: LD_EXP 53
19788: PPUSH
19789: LD_VAR 0 4
19793: PPUSH
19794: EMPTY
19795: PPUSH
19796: CALL_OW 1
19800: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
19801: LD_ADDR_EXP 54
19805: PUSH
19806: LD_EXP 54
19810: PPUSH
19811: LD_VAR 0 4
19815: PPUSH
19816: EMPTY
19817: PPUSH
19818: CALL_OW 1
19822: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
19823: LD_ADDR_EXP 55
19827: PUSH
19828: LD_EXP 55
19832: PPUSH
19833: LD_VAR 0 4
19837: PPUSH
19838: EMPTY
19839: PPUSH
19840: CALL_OW 1
19844: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
19845: LD_ADDR_EXP 56
19849: PUSH
19850: LD_EXP 56
19854: PPUSH
19855: LD_VAR 0 4
19859: PPUSH
19860: EMPTY
19861: PPUSH
19862: CALL_OW 1
19866: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
19867: LD_ADDR_EXP 57
19871: PUSH
19872: LD_EXP 57
19876: PPUSH
19877: LD_VAR 0 4
19881: PPUSH
19882: EMPTY
19883: PPUSH
19884: CALL_OW 1
19888: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
19889: LD_ADDR_EXP 58
19893: PUSH
19894: LD_EXP 58
19898: PPUSH
19899: LD_VAR 0 4
19903: PPUSH
19904: EMPTY
19905: PPUSH
19906: CALL_OW 1
19910: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
19911: LD_ADDR_EXP 59
19915: PUSH
19916: LD_EXP 59
19920: PPUSH
19921: LD_VAR 0 4
19925: PPUSH
19926: EMPTY
19927: PPUSH
19928: CALL_OW 1
19932: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
19933: LD_ADDR_EXP 60
19937: PUSH
19938: LD_EXP 60
19942: PPUSH
19943: LD_VAR 0 4
19947: PPUSH
19948: EMPTY
19949: PPUSH
19950: CALL_OW 1
19954: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
19955: LD_ADDR_EXP 61
19959: PUSH
19960: LD_EXP 61
19964: PPUSH
19965: LD_VAR 0 4
19969: PPUSH
19970: LD_INT 0
19972: PPUSH
19973: CALL_OW 1
19977: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
19978: LD_ADDR_EXP 62
19982: PUSH
19983: LD_EXP 62
19987: PPUSH
19988: LD_VAR 0 4
19992: PPUSH
19993: EMPTY
19994: PPUSH
19995: CALL_OW 1
19999: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
20000: LD_ADDR_EXP 63
20004: PUSH
20005: LD_EXP 63
20009: PPUSH
20010: LD_VAR 0 4
20014: PPUSH
20015: EMPTY
20016: PPUSH
20017: CALL_OW 1
20021: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
20022: LD_ADDR_EXP 64
20026: PUSH
20027: LD_EXP 64
20031: PPUSH
20032: LD_VAR 0 4
20036: PPUSH
20037: EMPTY
20038: PPUSH
20039: CALL_OW 1
20043: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
20044: LD_ADDR_EXP 65
20048: PUSH
20049: LD_EXP 65
20053: PPUSH
20054: LD_VAR 0 4
20058: PPUSH
20059: EMPTY
20060: PPUSH
20061: CALL_OW 1
20065: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
20066: LD_ADDR_EXP 66
20070: PUSH
20071: LD_EXP 66
20075: PPUSH
20076: LD_VAR 0 4
20080: PPUSH
20081: EMPTY
20082: PPUSH
20083: CALL_OW 1
20087: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
20088: LD_ADDR_EXP 67
20092: PUSH
20093: LD_EXP 67
20097: PPUSH
20098: LD_VAR 0 4
20102: PPUSH
20103: EMPTY
20104: PPUSH
20105: CALL_OW 1
20109: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
20110: LD_ADDR_EXP 68
20114: PUSH
20115: LD_EXP 68
20119: PPUSH
20120: LD_VAR 0 4
20124: PPUSH
20125: EMPTY
20126: PPUSH
20127: CALL_OW 1
20131: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
20132: LD_ADDR_EXP 69
20136: PUSH
20137: LD_EXP 69
20141: PPUSH
20142: LD_VAR 0 4
20146: PPUSH
20147: EMPTY
20148: PPUSH
20149: CALL_OW 1
20153: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
20154: LD_ADDR_EXP 70
20158: PUSH
20159: LD_EXP 70
20163: PPUSH
20164: LD_VAR 0 4
20168: PPUSH
20169: EMPTY
20170: PPUSH
20171: CALL_OW 1
20175: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
20176: LD_ADDR_EXP 71
20180: PUSH
20181: LD_EXP 71
20185: PPUSH
20186: LD_VAR 0 4
20190: PPUSH
20191: EMPTY
20192: PPUSH
20193: CALL_OW 1
20197: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
20198: LD_ADDR_EXP 72
20202: PUSH
20203: LD_EXP 72
20207: PPUSH
20208: LD_VAR 0 4
20212: PPUSH
20213: EMPTY
20214: PPUSH
20215: CALL_OW 1
20219: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
20220: LD_ADDR_EXP 73
20224: PUSH
20225: LD_EXP 73
20229: PPUSH
20230: LD_VAR 0 4
20234: PPUSH
20235: EMPTY
20236: PPUSH
20237: CALL_OW 1
20241: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
20242: LD_ADDR_EXP 74
20246: PUSH
20247: LD_EXP 74
20251: PPUSH
20252: LD_VAR 0 4
20256: PPUSH
20257: EMPTY
20258: PPUSH
20259: CALL_OW 1
20263: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
20264: LD_ADDR_EXP 75
20268: PUSH
20269: LD_EXP 75
20273: PPUSH
20274: LD_VAR 0 4
20278: PPUSH
20279: EMPTY
20280: PPUSH
20281: CALL_OW 1
20285: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
20286: LD_ADDR_EXP 77
20290: PUSH
20291: LD_EXP 77
20295: PPUSH
20296: LD_VAR 0 4
20300: PPUSH
20301: EMPTY
20302: PPUSH
20303: CALL_OW 1
20307: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
20308: LD_ADDR_EXP 79
20312: PUSH
20313: LD_EXP 79
20317: PPUSH
20318: LD_VAR 0 4
20322: PPUSH
20323: EMPTY
20324: PPUSH
20325: CALL_OW 1
20329: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
20330: LD_ADDR_EXP 80
20334: PUSH
20335: LD_EXP 80
20339: PPUSH
20340: LD_VAR 0 4
20344: PPUSH
20345: EMPTY
20346: PPUSH
20347: CALL_OW 1
20351: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
20352: LD_ADDR_EXP 81
20356: PUSH
20357: LD_EXP 81
20361: PPUSH
20362: LD_VAR 0 4
20366: PPUSH
20367: EMPTY
20368: PPUSH
20369: CALL_OW 1
20373: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
20374: LD_ADDR_EXP 82
20378: PUSH
20379: LD_EXP 82
20383: PPUSH
20384: LD_VAR 0 4
20388: PPUSH
20389: EMPTY
20390: PPUSH
20391: CALL_OW 1
20395: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
20396: LD_ADDR_EXP 83
20400: PUSH
20401: LD_EXP 83
20405: PPUSH
20406: LD_VAR 0 4
20410: PPUSH
20411: EMPTY
20412: PPUSH
20413: CALL_OW 1
20417: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
20418: LD_ADDR_EXP 84
20422: PUSH
20423: LD_EXP 84
20427: PPUSH
20428: LD_VAR 0 4
20432: PPUSH
20433: EMPTY
20434: PPUSH
20435: CALL_OW 1
20439: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
20440: LD_ADDR_EXP 85
20444: PUSH
20445: LD_EXP 85
20449: PPUSH
20450: LD_VAR 0 4
20454: PPUSH
20455: EMPTY
20456: PPUSH
20457: CALL_OW 1
20461: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
20462: LD_ADDR_EXP 86
20466: PUSH
20467: LD_EXP 86
20471: PPUSH
20472: LD_VAR 0 4
20476: PPUSH
20477: EMPTY
20478: PPUSH
20479: CALL_OW 1
20483: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
20484: LD_ADDR_EXP 87
20488: PUSH
20489: LD_EXP 87
20493: PPUSH
20494: LD_VAR 0 4
20498: PPUSH
20499: EMPTY
20500: PPUSH
20501: CALL_OW 1
20505: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
20506: LD_ADDR_EXP 88
20510: PUSH
20511: LD_EXP 88
20515: PPUSH
20516: LD_VAR 0 4
20520: PPUSH
20521: EMPTY
20522: PPUSH
20523: CALL_OW 1
20527: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
20528: LD_ADDR_EXP 89
20532: PUSH
20533: LD_EXP 89
20537: PPUSH
20538: LD_VAR 0 4
20542: PPUSH
20543: EMPTY
20544: PPUSH
20545: CALL_OW 1
20549: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
20550: LD_ADDR_EXP 90
20554: PUSH
20555: LD_EXP 90
20559: PPUSH
20560: LD_VAR 0 4
20564: PPUSH
20565: EMPTY
20566: PPUSH
20567: CALL_OW 1
20571: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
20572: LD_ADDR_EXP 91
20576: PUSH
20577: LD_EXP 91
20581: PPUSH
20582: LD_VAR 0 4
20586: PPUSH
20587: EMPTY
20588: PPUSH
20589: CALL_OW 1
20593: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
20594: LD_ADDR_EXP 92
20598: PUSH
20599: LD_EXP 92
20603: PPUSH
20604: LD_VAR 0 4
20608: PPUSH
20609: LD_INT 0
20611: PPUSH
20612: CALL_OW 1
20616: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
20617: LD_ADDR_EXP 93
20621: PUSH
20622: LD_EXP 93
20626: PPUSH
20627: LD_VAR 0 4
20631: PPUSH
20632: LD_INT 0
20634: PPUSH
20635: CALL_OW 1
20639: ST_TO_ADDR
// result := base ;
20640: LD_ADDR_VAR 0 3
20644: PUSH
20645: LD_VAR 0 4
20649: ST_TO_ADDR
// end ;
20650: LD_VAR 0 3
20654: RET
// export function MC_Start ( ) ; var i ; begin
20655: LD_INT 0
20657: PPUSH
20658: PPUSH
// for i = 1 to mc_bases do
20659: LD_ADDR_VAR 0 2
20663: PUSH
20664: DOUBLE
20665: LD_INT 1
20667: DEC
20668: ST_TO_ADDR
20669: LD_EXP 50
20673: PUSH
20674: FOR_TO
20675: IFFALSE 21775
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
20677: LD_ADDR_EXP 50
20681: PUSH
20682: LD_EXP 50
20686: PPUSH
20687: LD_VAR 0 2
20691: PPUSH
20692: LD_EXP 50
20696: PUSH
20697: LD_VAR 0 2
20701: ARRAY
20702: PUSH
20703: LD_INT 0
20705: DIFF
20706: PPUSH
20707: CALL_OW 1
20711: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
20712: LD_ADDR_EXP 51
20716: PUSH
20717: LD_EXP 51
20721: PPUSH
20722: LD_VAR 0 2
20726: PPUSH
20727: EMPTY
20728: PPUSH
20729: CALL_OW 1
20733: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
20734: LD_ADDR_EXP 52
20738: PUSH
20739: LD_EXP 52
20743: PPUSH
20744: LD_VAR 0 2
20748: PPUSH
20749: EMPTY
20750: PPUSH
20751: CALL_OW 1
20755: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
20756: LD_ADDR_EXP 53
20760: PUSH
20761: LD_EXP 53
20765: PPUSH
20766: LD_VAR 0 2
20770: PPUSH
20771: EMPTY
20772: PPUSH
20773: CALL_OW 1
20777: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
20778: LD_ADDR_EXP 54
20782: PUSH
20783: LD_EXP 54
20787: PPUSH
20788: LD_VAR 0 2
20792: PPUSH
20793: EMPTY
20794: PUSH
20795: EMPTY
20796: PUSH
20797: EMPTY
20798: LIST
20799: LIST
20800: PPUSH
20801: CALL_OW 1
20805: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
20806: LD_ADDR_EXP 55
20810: PUSH
20811: LD_EXP 55
20815: PPUSH
20816: LD_VAR 0 2
20820: PPUSH
20821: EMPTY
20822: PPUSH
20823: CALL_OW 1
20827: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
20828: LD_ADDR_EXP 82
20832: PUSH
20833: LD_EXP 82
20837: PPUSH
20838: LD_VAR 0 2
20842: PPUSH
20843: EMPTY
20844: PPUSH
20845: CALL_OW 1
20849: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
20850: LD_ADDR_EXP 56
20854: PUSH
20855: LD_EXP 56
20859: PPUSH
20860: LD_VAR 0 2
20864: PPUSH
20865: EMPTY
20866: PPUSH
20867: CALL_OW 1
20871: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
20872: LD_ADDR_EXP 57
20876: PUSH
20877: LD_EXP 57
20881: PPUSH
20882: LD_VAR 0 2
20886: PPUSH
20887: EMPTY
20888: PPUSH
20889: CALL_OW 1
20893: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
20894: LD_ADDR_EXP 58
20898: PUSH
20899: LD_EXP 58
20903: PPUSH
20904: LD_VAR 0 2
20908: PPUSH
20909: LD_EXP 50
20913: PUSH
20914: LD_VAR 0 2
20918: ARRAY
20919: PPUSH
20920: LD_INT 2
20922: PUSH
20923: LD_INT 30
20925: PUSH
20926: LD_INT 32
20928: PUSH
20929: EMPTY
20930: LIST
20931: LIST
20932: PUSH
20933: LD_INT 30
20935: PUSH
20936: LD_INT 33
20938: PUSH
20939: EMPTY
20940: LIST
20941: LIST
20942: PUSH
20943: EMPTY
20944: LIST
20945: LIST
20946: LIST
20947: PPUSH
20948: CALL_OW 72
20952: PPUSH
20953: CALL_OW 1
20957: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
20958: LD_ADDR_EXP 59
20962: PUSH
20963: LD_EXP 59
20967: PPUSH
20968: LD_VAR 0 2
20972: PPUSH
20973: LD_EXP 50
20977: PUSH
20978: LD_VAR 0 2
20982: ARRAY
20983: PPUSH
20984: LD_INT 2
20986: PUSH
20987: LD_INT 30
20989: PUSH
20990: LD_INT 32
20992: PUSH
20993: EMPTY
20994: LIST
20995: LIST
20996: PUSH
20997: LD_INT 30
20999: PUSH
21000: LD_INT 31
21002: PUSH
21003: EMPTY
21004: LIST
21005: LIST
21006: PUSH
21007: EMPTY
21008: LIST
21009: LIST
21010: LIST
21011: PUSH
21012: LD_INT 58
21014: PUSH
21015: EMPTY
21016: LIST
21017: PUSH
21018: EMPTY
21019: LIST
21020: LIST
21021: PPUSH
21022: CALL_OW 72
21026: PPUSH
21027: CALL_OW 1
21031: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
21032: LD_ADDR_EXP 60
21036: PUSH
21037: LD_EXP 60
21041: PPUSH
21042: LD_VAR 0 2
21046: PPUSH
21047: EMPTY
21048: PPUSH
21049: CALL_OW 1
21053: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
21054: LD_ADDR_EXP 64
21058: PUSH
21059: LD_EXP 64
21063: PPUSH
21064: LD_VAR 0 2
21068: PPUSH
21069: EMPTY
21070: PPUSH
21071: CALL_OW 1
21075: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
21076: LD_ADDR_EXP 63
21080: PUSH
21081: LD_EXP 63
21085: PPUSH
21086: LD_VAR 0 2
21090: PPUSH
21091: EMPTY
21092: PPUSH
21093: CALL_OW 1
21097: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
21098: LD_ADDR_EXP 65
21102: PUSH
21103: LD_EXP 65
21107: PPUSH
21108: LD_VAR 0 2
21112: PPUSH
21113: EMPTY
21114: PPUSH
21115: CALL_OW 1
21119: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
21120: LD_ADDR_EXP 66
21124: PUSH
21125: LD_EXP 66
21129: PPUSH
21130: LD_VAR 0 2
21134: PPUSH
21135: EMPTY
21136: PPUSH
21137: CALL_OW 1
21141: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
21142: LD_ADDR_EXP 67
21146: PUSH
21147: LD_EXP 67
21151: PPUSH
21152: LD_VAR 0 2
21156: PPUSH
21157: EMPTY
21158: PPUSH
21159: CALL_OW 1
21163: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
21164: LD_ADDR_EXP 68
21168: PUSH
21169: LD_EXP 68
21173: PPUSH
21174: LD_VAR 0 2
21178: PPUSH
21179: EMPTY
21180: PPUSH
21181: CALL_OW 1
21185: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
21186: LD_ADDR_EXP 69
21190: PUSH
21191: LD_EXP 69
21195: PPUSH
21196: LD_VAR 0 2
21200: PPUSH
21201: EMPTY
21202: PPUSH
21203: CALL_OW 1
21207: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
21208: LD_ADDR_EXP 70
21212: PUSH
21213: LD_EXP 70
21217: PPUSH
21218: LD_VAR 0 2
21222: PPUSH
21223: EMPTY
21224: PPUSH
21225: CALL_OW 1
21229: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
21230: LD_ADDR_EXP 71
21234: PUSH
21235: LD_EXP 71
21239: PPUSH
21240: LD_VAR 0 2
21244: PPUSH
21245: EMPTY
21246: PPUSH
21247: CALL_OW 1
21251: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
21252: LD_ADDR_EXP 72
21256: PUSH
21257: LD_EXP 72
21261: PPUSH
21262: LD_VAR 0 2
21266: PPUSH
21267: EMPTY
21268: PPUSH
21269: CALL_OW 1
21273: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
21274: LD_ADDR_EXP 61
21278: PUSH
21279: LD_EXP 61
21283: PPUSH
21284: LD_VAR 0 2
21288: PPUSH
21289: LD_INT 0
21291: PPUSH
21292: CALL_OW 1
21296: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
21297: LD_ADDR_EXP 74
21301: PUSH
21302: LD_EXP 74
21306: PPUSH
21307: LD_VAR 0 2
21311: PPUSH
21312: LD_INT 0
21314: PPUSH
21315: CALL_OW 1
21319: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
21320: LD_ADDR_EXP 62
21324: PUSH
21325: LD_EXP 62
21329: PPUSH
21330: LD_VAR 0 2
21334: PPUSH
21335: EMPTY
21336: PPUSH
21337: CALL_OW 1
21341: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
21342: LD_ADDR_EXP 73
21346: PUSH
21347: LD_EXP 73
21351: PPUSH
21352: LD_VAR 0 2
21356: PPUSH
21357: LD_INT 0
21359: PPUSH
21360: CALL_OW 1
21364: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
21365: LD_ADDR_EXP 75
21369: PUSH
21370: LD_EXP 75
21374: PPUSH
21375: LD_VAR 0 2
21379: PPUSH
21380: EMPTY
21381: PPUSH
21382: CALL_OW 1
21386: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
21387: LD_ADDR_EXP 78
21391: PUSH
21392: LD_EXP 78
21396: PPUSH
21397: LD_VAR 0 2
21401: PPUSH
21402: LD_INT 0
21404: PPUSH
21405: CALL_OW 1
21409: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
21410: LD_ADDR_EXP 79
21414: PUSH
21415: LD_EXP 79
21419: PPUSH
21420: LD_VAR 0 2
21424: PPUSH
21425: EMPTY
21426: PPUSH
21427: CALL_OW 1
21431: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
21432: LD_ADDR_EXP 80
21436: PUSH
21437: LD_EXP 80
21441: PPUSH
21442: LD_VAR 0 2
21446: PPUSH
21447: EMPTY
21448: PPUSH
21449: CALL_OW 1
21453: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
21454: LD_ADDR_EXP 81
21458: PUSH
21459: LD_EXP 81
21463: PPUSH
21464: LD_VAR 0 2
21468: PPUSH
21469: EMPTY
21470: PPUSH
21471: CALL_OW 1
21475: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
21476: LD_ADDR_EXP 83
21480: PUSH
21481: LD_EXP 83
21485: PPUSH
21486: LD_VAR 0 2
21490: PPUSH
21491: LD_EXP 50
21495: PUSH
21496: LD_VAR 0 2
21500: ARRAY
21501: PPUSH
21502: LD_INT 2
21504: PUSH
21505: LD_INT 30
21507: PUSH
21508: LD_INT 6
21510: PUSH
21511: EMPTY
21512: LIST
21513: LIST
21514: PUSH
21515: LD_INT 30
21517: PUSH
21518: LD_INT 7
21520: PUSH
21521: EMPTY
21522: LIST
21523: LIST
21524: PUSH
21525: LD_INT 30
21527: PUSH
21528: LD_INT 8
21530: PUSH
21531: EMPTY
21532: LIST
21533: LIST
21534: PUSH
21535: EMPTY
21536: LIST
21537: LIST
21538: LIST
21539: LIST
21540: PPUSH
21541: CALL_OW 72
21545: PPUSH
21546: CALL_OW 1
21550: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
21551: LD_ADDR_EXP 84
21555: PUSH
21556: LD_EXP 84
21560: PPUSH
21561: LD_VAR 0 2
21565: PPUSH
21566: EMPTY
21567: PPUSH
21568: CALL_OW 1
21572: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
21573: LD_ADDR_EXP 85
21577: PUSH
21578: LD_EXP 85
21582: PPUSH
21583: LD_VAR 0 2
21587: PPUSH
21588: EMPTY
21589: PPUSH
21590: CALL_OW 1
21594: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
21595: LD_ADDR_EXP 86
21599: PUSH
21600: LD_EXP 86
21604: PPUSH
21605: LD_VAR 0 2
21609: PPUSH
21610: EMPTY
21611: PPUSH
21612: CALL_OW 1
21616: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
21617: LD_ADDR_EXP 87
21621: PUSH
21622: LD_EXP 87
21626: PPUSH
21627: LD_VAR 0 2
21631: PPUSH
21632: EMPTY
21633: PPUSH
21634: CALL_OW 1
21638: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
21639: LD_ADDR_EXP 88
21643: PUSH
21644: LD_EXP 88
21648: PPUSH
21649: LD_VAR 0 2
21653: PPUSH
21654: EMPTY
21655: PPUSH
21656: CALL_OW 1
21660: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
21661: LD_ADDR_EXP 89
21665: PUSH
21666: LD_EXP 89
21670: PPUSH
21671: LD_VAR 0 2
21675: PPUSH
21676: EMPTY
21677: PPUSH
21678: CALL_OW 1
21682: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
21683: LD_ADDR_EXP 90
21687: PUSH
21688: LD_EXP 90
21692: PPUSH
21693: LD_VAR 0 2
21697: PPUSH
21698: EMPTY
21699: PPUSH
21700: CALL_OW 1
21704: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
21705: LD_ADDR_EXP 91
21709: PUSH
21710: LD_EXP 91
21714: PPUSH
21715: LD_VAR 0 2
21719: PPUSH
21720: EMPTY
21721: PPUSH
21722: CALL_OW 1
21726: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
21727: LD_ADDR_EXP 92
21731: PUSH
21732: LD_EXP 92
21736: PPUSH
21737: LD_VAR 0 2
21741: PPUSH
21742: LD_INT 0
21744: PPUSH
21745: CALL_OW 1
21749: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
21750: LD_ADDR_EXP 93
21754: PUSH
21755: LD_EXP 93
21759: PPUSH
21760: LD_VAR 0 2
21764: PPUSH
21765: LD_INT 0
21767: PPUSH
21768: CALL_OW 1
21772: ST_TO_ADDR
// end ;
21773: GO 20674
21775: POP
21776: POP
// MC_InitSides ( ) ;
21777: CALL 22063 0 0
// MC_InitResearch ( ) ;
21781: CALL 21802 0 0
// CustomInitMacro ( ) ;
21785: CALL 304 0 0
// skirmish := true ;
21789: LD_ADDR_EXP 48
21793: PUSH
21794: LD_INT 1
21796: ST_TO_ADDR
// end ;
21797: LD_VAR 0 1
21801: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
21802: LD_INT 0
21804: PPUSH
21805: PPUSH
21806: PPUSH
21807: PPUSH
21808: PPUSH
21809: PPUSH
// if not mc_bases then
21810: LD_EXP 50
21814: NOT
21815: IFFALSE 21819
// exit ;
21817: GO 22058
// for i = 1 to 8 do
21819: LD_ADDR_VAR 0 2
21823: PUSH
21824: DOUBLE
21825: LD_INT 1
21827: DEC
21828: ST_TO_ADDR
21829: LD_INT 8
21831: PUSH
21832: FOR_TO
21833: IFFALSE 21859
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
21835: LD_ADDR_EXP 77
21839: PUSH
21840: LD_EXP 77
21844: PPUSH
21845: LD_VAR 0 2
21849: PPUSH
21850: EMPTY
21851: PPUSH
21852: CALL_OW 1
21856: ST_TO_ADDR
21857: GO 21832
21859: POP
21860: POP
// tmp := [ ] ;
21861: LD_ADDR_VAR 0 5
21865: PUSH
21866: EMPTY
21867: ST_TO_ADDR
// for i = 1 to mc_sides do
21868: LD_ADDR_VAR 0 2
21872: PUSH
21873: DOUBLE
21874: LD_INT 1
21876: DEC
21877: ST_TO_ADDR
21878: LD_EXP 76
21882: PUSH
21883: FOR_TO
21884: IFFALSE 21942
// if not mc_sides [ i ] in tmp then
21886: LD_EXP 76
21890: PUSH
21891: LD_VAR 0 2
21895: ARRAY
21896: PUSH
21897: LD_VAR 0 5
21901: IN
21902: NOT
21903: IFFALSE 21940
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
21905: LD_ADDR_VAR 0 5
21909: PUSH
21910: LD_VAR 0 5
21914: PPUSH
21915: LD_VAR 0 5
21919: PUSH
21920: LD_INT 1
21922: PLUS
21923: PPUSH
21924: LD_EXP 76
21928: PUSH
21929: LD_VAR 0 2
21933: ARRAY
21934: PPUSH
21935: CALL_OW 2
21939: ST_TO_ADDR
21940: GO 21883
21942: POP
21943: POP
// if not tmp then
21944: LD_VAR 0 5
21948: NOT
21949: IFFALSE 21953
// exit ;
21951: GO 22058
// for j in tmp do
21953: LD_ADDR_VAR 0 3
21957: PUSH
21958: LD_VAR 0 5
21962: PUSH
21963: FOR_IN
21964: IFFALSE 22056
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
21966: LD_ADDR_VAR 0 6
21970: PUSH
21971: LD_INT 22
21973: PUSH
21974: LD_VAR 0 3
21978: PUSH
21979: EMPTY
21980: LIST
21981: LIST
21982: PPUSH
21983: CALL_OW 69
21987: ST_TO_ADDR
// if not un then
21988: LD_VAR 0 6
21992: NOT
21993: IFFALSE 21997
// continue ;
21995: GO 21963
// nation := GetNation ( un [ 1 ] ) ;
21997: LD_ADDR_VAR 0 4
22001: PUSH
22002: LD_VAR 0 6
22006: PUSH
22007: LD_INT 1
22009: ARRAY
22010: PPUSH
22011: CALL_OW 248
22015: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
22016: LD_ADDR_EXP 77
22020: PUSH
22021: LD_EXP 77
22025: PPUSH
22026: LD_VAR 0 3
22030: PPUSH
22031: LD_VAR 0 3
22035: PPUSH
22036: LD_VAR 0 4
22040: PPUSH
22041: LD_INT 1
22043: PPUSH
22044: CALL 49246 0 3
22048: PPUSH
22049: CALL_OW 1
22053: ST_TO_ADDR
// end ;
22054: GO 21963
22056: POP
22057: POP
// end ;
22058: LD_VAR 0 1
22062: RET
// export function MC_InitSides ( ) ; var i ; begin
22063: LD_INT 0
22065: PPUSH
22066: PPUSH
// if not mc_bases then
22067: LD_EXP 50
22071: NOT
22072: IFFALSE 22076
// exit ;
22074: GO 22150
// for i = 1 to mc_bases do
22076: LD_ADDR_VAR 0 2
22080: PUSH
22081: DOUBLE
22082: LD_INT 1
22084: DEC
22085: ST_TO_ADDR
22086: LD_EXP 50
22090: PUSH
22091: FOR_TO
22092: IFFALSE 22148
// if mc_bases [ i ] then
22094: LD_EXP 50
22098: PUSH
22099: LD_VAR 0 2
22103: ARRAY
22104: IFFALSE 22146
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
22106: LD_ADDR_EXP 76
22110: PUSH
22111: LD_EXP 76
22115: PPUSH
22116: LD_VAR 0 2
22120: PPUSH
22121: LD_EXP 50
22125: PUSH
22126: LD_VAR 0 2
22130: ARRAY
22131: PUSH
22132: LD_INT 1
22134: ARRAY
22135: PPUSH
22136: CALL_OW 255
22140: PPUSH
22141: CALL_OW 1
22145: ST_TO_ADDR
22146: GO 22091
22148: POP
22149: POP
// end ;
22150: LD_VAR 0 1
22154: RET
// every 0 0$03 trigger skirmish do
22155: LD_EXP 48
22159: IFFALSE 22313
22161: GO 22163
22163: DISABLE
// begin enable ;
22164: ENABLE
// MC_CheckBuildings ( ) ;
22165: CALL 26825 0 0
// MC_CheckPeopleLife ( ) ;
22169: CALL 26986 0 0
// RaiseSailEvent ( 100 ) ;
22173: LD_INT 100
22175: PPUSH
22176: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
22180: LD_INT 103
22182: PPUSH
22183: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
22187: LD_INT 104
22189: PPUSH
22190: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
22194: LD_INT 105
22196: PPUSH
22197: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
22201: LD_INT 106
22203: PPUSH
22204: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
22208: LD_INT 107
22210: PPUSH
22211: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
22215: LD_INT 108
22217: PPUSH
22218: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
22222: LD_INT 109
22224: PPUSH
22225: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
22229: LD_INT 110
22231: PPUSH
22232: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
22236: LD_INT 111
22238: PPUSH
22239: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
22243: LD_INT 112
22245: PPUSH
22246: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
22250: LD_INT 113
22252: PPUSH
22253: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
22257: LD_INT 120
22259: PPUSH
22260: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
22264: LD_INT 121
22266: PPUSH
22267: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
22271: LD_INT 122
22273: PPUSH
22274: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
22278: LD_INT 123
22280: PPUSH
22281: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
22285: LD_INT 124
22287: PPUSH
22288: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
22292: LD_INT 125
22294: PPUSH
22295: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
22299: LD_INT 126
22301: PPUSH
22302: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
22306: LD_INT 200
22308: PPUSH
22309: CALL_OW 427
// end ;
22313: END
// on SailEvent ( event ) do begin if event < 100 then
22314: LD_VAR 0 1
22318: PUSH
22319: LD_INT 100
22321: LESS
22322: IFFALSE 22333
// CustomEvent ( event ) ;
22324: LD_VAR 0 1
22328: PPUSH
22329: CALL 17476 0 1
// if event = 100 then
22333: LD_VAR 0 1
22337: PUSH
22338: LD_INT 100
22340: EQUAL
22341: IFFALSE 22347
// MC_ClassManager ( ) ;
22343: CALL 22739 0 0
// if event = 101 then
22347: LD_VAR 0 1
22351: PUSH
22352: LD_INT 101
22354: EQUAL
22355: IFFALSE 22361
// MC_RepairBuildings ( ) ;
22357: CALL 27571 0 0
// if event = 102 then
22361: LD_VAR 0 1
22365: PUSH
22366: LD_INT 102
22368: EQUAL
22369: IFFALSE 22375
// MC_Heal ( ) ;
22371: CALL 28506 0 0
// if event = 103 then
22375: LD_VAR 0 1
22379: PUSH
22380: LD_INT 103
22382: EQUAL
22383: IFFALSE 22389
// MC_Build ( ) ;
22385: CALL 28928 0 0
// if event = 104 then
22389: LD_VAR 0 1
22393: PUSH
22394: LD_INT 104
22396: EQUAL
22397: IFFALSE 22403
// MC_TurretWeapon ( ) ;
22399: CALL 30562 0 0
// if event = 105 then
22403: LD_VAR 0 1
22407: PUSH
22408: LD_INT 105
22410: EQUAL
22411: IFFALSE 22417
// MC_BuildUpgrade ( ) ;
22413: CALL 30113 0 0
// if event = 106 then
22417: LD_VAR 0 1
22421: PUSH
22422: LD_INT 106
22424: EQUAL
22425: IFFALSE 22431
// MC_PlantMines ( ) ;
22427: CALL 30992 0 0
// if event = 107 then
22431: LD_VAR 0 1
22435: PUSH
22436: LD_INT 107
22438: EQUAL
22439: IFFALSE 22445
// MC_CollectCrates ( ) ;
22441: CALL 31790 0 0
// if event = 108 then
22445: LD_VAR 0 1
22449: PUSH
22450: LD_INT 108
22452: EQUAL
22453: IFFALSE 22459
// MC_LinkRemoteControl ( ) ;
22455: CALL 33640 0 0
// if event = 109 then
22459: LD_VAR 0 1
22463: PUSH
22464: LD_INT 109
22466: EQUAL
22467: IFFALSE 22473
// MC_ProduceVehicle ( ) ;
22469: CALL 33821 0 0
// if event = 110 then
22473: LD_VAR 0 1
22477: PUSH
22478: LD_INT 110
22480: EQUAL
22481: IFFALSE 22487
// MC_SendAttack ( ) ;
22483: CALL 34287 0 0
// if event = 111 then
22487: LD_VAR 0 1
22491: PUSH
22492: LD_INT 111
22494: EQUAL
22495: IFFALSE 22501
// MC_Defend ( ) ;
22497: CALL 34395 0 0
// if event = 112 then
22501: LD_VAR 0 1
22505: PUSH
22506: LD_INT 112
22508: EQUAL
22509: IFFALSE 22515
// MC_Research ( ) ;
22511: CALL 35275 0 0
// if event = 113 then
22515: LD_VAR 0 1
22519: PUSH
22520: LD_INT 113
22522: EQUAL
22523: IFFALSE 22529
// MC_MinesTrigger ( ) ;
22525: CALL 36389 0 0
// if event = 120 then
22529: LD_VAR 0 1
22533: PUSH
22534: LD_INT 120
22536: EQUAL
22537: IFFALSE 22543
// MC_RepairVehicle ( ) ;
22539: CALL 36488 0 0
// if event = 121 then
22543: LD_VAR 0 1
22547: PUSH
22548: LD_INT 121
22550: EQUAL
22551: IFFALSE 22557
// MC_TameApe ( ) ;
22553: CALL 37257 0 0
// if event = 122 then
22557: LD_VAR 0 1
22561: PUSH
22562: LD_INT 122
22564: EQUAL
22565: IFFALSE 22571
// MC_ChangeApeClass ( ) ;
22567: CALL 38086 0 0
// if event = 123 then
22571: LD_VAR 0 1
22575: PUSH
22576: LD_INT 123
22578: EQUAL
22579: IFFALSE 22585
// MC_Bazooka ( ) ;
22581: CALL 38736 0 0
// if event = 124 then
22585: LD_VAR 0 1
22589: PUSH
22590: LD_INT 124
22592: EQUAL
22593: IFFALSE 22599
// MC_TeleportExit ( ) ;
22595: CALL 38934 0 0
// if event = 125 then
22599: LD_VAR 0 1
22603: PUSH
22604: LD_INT 125
22606: EQUAL
22607: IFFALSE 22613
// MC_Deposits ( ) ;
22609: CALL 39581 0 0
// if event = 126 then
22613: LD_VAR 0 1
22617: PUSH
22618: LD_INT 126
22620: EQUAL
22621: IFFALSE 22627
// MC_RemoteDriver ( ) ;
22623: CALL 40206 0 0
// if event = 200 then
22627: LD_VAR 0 1
22631: PUSH
22632: LD_INT 200
22634: EQUAL
22635: IFFALSE 22641
// MC_Idle ( ) ;
22637: CALL 42113 0 0
// end ;
22641: PPOPN 1
22643: END
// export function MC_Reset ( base , tag ) ; var i ; begin
22644: LD_INT 0
22646: PPUSH
22647: PPUSH
// if not mc_bases [ base ] or not tag then
22648: LD_EXP 50
22652: PUSH
22653: LD_VAR 0 1
22657: ARRAY
22658: NOT
22659: PUSH
22660: LD_VAR 0 2
22664: NOT
22665: OR
22666: IFFALSE 22670
// exit ;
22668: GO 22734
// for i in mc_bases [ base ] union mc_ape [ base ] do
22670: LD_ADDR_VAR 0 4
22674: PUSH
22675: LD_EXP 50
22679: PUSH
22680: LD_VAR 0 1
22684: ARRAY
22685: PUSH
22686: LD_EXP 79
22690: PUSH
22691: LD_VAR 0 1
22695: ARRAY
22696: UNION
22697: PUSH
22698: FOR_IN
22699: IFFALSE 22732
// if GetTag ( i ) = tag then
22701: LD_VAR 0 4
22705: PPUSH
22706: CALL_OW 110
22710: PUSH
22711: LD_VAR 0 2
22715: EQUAL
22716: IFFALSE 22730
// SetTag ( i , 0 ) ;
22718: LD_VAR 0 4
22722: PPUSH
22723: LD_INT 0
22725: PPUSH
22726: CALL_OW 109
22730: GO 22698
22732: POP
22733: POP
// end ;
22734: LD_VAR 0 3
22738: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
22739: LD_INT 0
22741: PPUSH
22742: PPUSH
22743: PPUSH
22744: PPUSH
22745: PPUSH
22746: PPUSH
22747: PPUSH
22748: PPUSH
// if not mc_bases then
22749: LD_EXP 50
22753: NOT
22754: IFFALSE 22758
// exit ;
22756: GO 23207
// for i = 1 to mc_bases do
22758: LD_ADDR_VAR 0 2
22762: PUSH
22763: DOUBLE
22764: LD_INT 1
22766: DEC
22767: ST_TO_ADDR
22768: LD_EXP 50
22772: PUSH
22773: FOR_TO
22774: IFFALSE 23205
// begin tmp := MC_ClassCheckReq ( i ) ;
22776: LD_ADDR_VAR 0 4
22780: PUSH
22781: LD_VAR 0 2
22785: PPUSH
22786: CALL 23212 0 1
22790: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
22791: LD_ADDR_EXP 91
22795: PUSH
22796: LD_EXP 91
22800: PPUSH
22801: LD_VAR 0 2
22805: PPUSH
22806: LD_VAR 0 4
22810: PPUSH
22811: CALL_OW 1
22815: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
22816: LD_ADDR_VAR 0 6
22820: PUSH
22821: LD_EXP 50
22825: PUSH
22826: LD_VAR 0 2
22830: ARRAY
22831: PPUSH
22832: LD_INT 2
22834: PUSH
22835: LD_INT 30
22837: PUSH
22838: LD_INT 4
22840: PUSH
22841: EMPTY
22842: LIST
22843: LIST
22844: PUSH
22845: LD_INT 30
22847: PUSH
22848: LD_INT 5
22850: PUSH
22851: EMPTY
22852: LIST
22853: LIST
22854: PUSH
22855: EMPTY
22856: LIST
22857: LIST
22858: LIST
22859: PPUSH
22860: CALL_OW 72
22864: PUSH
22865: LD_EXP 50
22869: PUSH
22870: LD_VAR 0 2
22874: ARRAY
22875: PPUSH
22876: LD_INT 2
22878: PUSH
22879: LD_INT 30
22881: PUSH
22882: LD_INT 0
22884: PUSH
22885: EMPTY
22886: LIST
22887: LIST
22888: PUSH
22889: LD_INT 30
22891: PUSH
22892: LD_INT 1
22894: PUSH
22895: EMPTY
22896: LIST
22897: LIST
22898: PUSH
22899: EMPTY
22900: LIST
22901: LIST
22902: LIST
22903: PPUSH
22904: CALL_OW 72
22908: PUSH
22909: LD_EXP 50
22913: PUSH
22914: LD_VAR 0 2
22918: ARRAY
22919: PPUSH
22920: LD_INT 30
22922: PUSH
22923: LD_INT 3
22925: PUSH
22926: EMPTY
22927: LIST
22928: LIST
22929: PPUSH
22930: CALL_OW 72
22934: PUSH
22935: LD_EXP 50
22939: PUSH
22940: LD_VAR 0 2
22944: ARRAY
22945: PPUSH
22946: LD_INT 2
22948: PUSH
22949: LD_INT 30
22951: PUSH
22952: LD_INT 6
22954: PUSH
22955: EMPTY
22956: LIST
22957: LIST
22958: PUSH
22959: LD_INT 30
22961: PUSH
22962: LD_INT 7
22964: PUSH
22965: EMPTY
22966: LIST
22967: LIST
22968: PUSH
22969: LD_INT 30
22971: PUSH
22972: LD_INT 8
22974: PUSH
22975: EMPTY
22976: LIST
22977: LIST
22978: PUSH
22979: EMPTY
22980: LIST
22981: LIST
22982: LIST
22983: LIST
22984: PPUSH
22985: CALL_OW 72
22989: PUSH
22990: EMPTY
22991: LIST
22992: LIST
22993: LIST
22994: LIST
22995: ST_TO_ADDR
// for j := 1 to 4 do
22996: LD_ADDR_VAR 0 3
23000: PUSH
23001: DOUBLE
23002: LD_INT 1
23004: DEC
23005: ST_TO_ADDR
23006: LD_INT 4
23008: PUSH
23009: FOR_TO
23010: IFFALSE 23201
// begin if not tmp [ j ] then
23012: LD_VAR 0 4
23016: PUSH
23017: LD_VAR 0 3
23021: ARRAY
23022: NOT
23023: IFFALSE 23027
// continue ;
23025: GO 23009
// for p in tmp [ j ] do
23027: LD_ADDR_VAR 0 5
23031: PUSH
23032: LD_VAR 0 4
23036: PUSH
23037: LD_VAR 0 3
23041: ARRAY
23042: PUSH
23043: FOR_IN
23044: IFFALSE 23197
// begin if not b [ j ] then
23046: LD_VAR 0 6
23050: PUSH
23051: LD_VAR 0 3
23055: ARRAY
23056: NOT
23057: IFFALSE 23061
// break ;
23059: GO 23197
// e := 0 ;
23061: LD_ADDR_VAR 0 7
23065: PUSH
23066: LD_INT 0
23068: ST_TO_ADDR
// for k in b [ j ] do
23069: LD_ADDR_VAR 0 8
23073: PUSH
23074: LD_VAR 0 6
23078: PUSH
23079: LD_VAR 0 3
23083: ARRAY
23084: PUSH
23085: FOR_IN
23086: IFFALSE 23113
// if IsNotFull ( k ) then
23088: LD_VAR 0 8
23092: PPUSH
23093: CALL 51367 0 1
23097: IFFALSE 23111
// begin e := k ;
23099: LD_ADDR_VAR 0 7
23103: PUSH
23104: LD_VAR 0 8
23108: ST_TO_ADDR
// break ;
23109: GO 23113
// end ;
23111: GO 23085
23113: POP
23114: POP
// if e and not UnitGoingToBuilding ( p , e ) then
23115: LD_VAR 0 7
23119: PUSH
23120: LD_VAR 0 5
23124: PPUSH
23125: LD_VAR 0 7
23129: PPUSH
23130: CALL 85506 0 2
23134: NOT
23135: AND
23136: IFFALSE 23195
// begin if IsInUnit ( p ) then
23138: LD_VAR 0 5
23142: PPUSH
23143: CALL_OW 310
23147: IFFALSE 23158
// ComExitBuilding ( p ) ;
23149: LD_VAR 0 5
23153: PPUSH
23154: CALL_OW 122
// ComEnterUnit ( p , e ) ;
23158: LD_VAR 0 5
23162: PPUSH
23163: LD_VAR 0 7
23167: PPUSH
23168: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
23172: LD_VAR 0 5
23176: PPUSH
23177: LD_VAR 0 3
23181: PPUSH
23182: CALL_OW 183
// AddComExitBuilding ( p ) ;
23186: LD_VAR 0 5
23190: PPUSH
23191: CALL_OW 182
// end ; end ;
23195: GO 23043
23197: POP
23198: POP
// end ;
23199: GO 23009
23201: POP
23202: POP
// end ;
23203: GO 22773
23205: POP
23206: POP
// end ;
23207: LD_VAR 0 1
23211: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
23212: LD_INT 0
23214: PPUSH
23215: PPUSH
23216: PPUSH
23217: PPUSH
23218: PPUSH
23219: PPUSH
23220: PPUSH
23221: PPUSH
23222: PPUSH
23223: PPUSH
23224: PPUSH
23225: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
23226: LD_ADDR_VAR 0 2
23230: PUSH
23231: LD_INT 0
23233: PUSH
23234: LD_INT 0
23236: PUSH
23237: LD_INT 0
23239: PUSH
23240: LD_INT 0
23242: PUSH
23243: EMPTY
23244: LIST
23245: LIST
23246: LIST
23247: LIST
23248: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
23249: LD_VAR 0 1
23253: NOT
23254: PUSH
23255: LD_EXP 50
23259: PUSH
23260: LD_VAR 0 1
23264: ARRAY
23265: NOT
23266: OR
23267: PUSH
23268: LD_EXP 50
23272: PUSH
23273: LD_VAR 0 1
23277: ARRAY
23278: PPUSH
23279: LD_INT 2
23281: PUSH
23282: LD_INT 30
23284: PUSH
23285: LD_INT 0
23287: PUSH
23288: EMPTY
23289: LIST
23290: LIST
23291: PUSH
23292: LD_INT 30
23294: PUSH
23295: LD_INT 1
23297: PUSH
23298: EMPTY
23299: LIST
23300: LIST
23301: PUSH
23302: EMPTY
23303: LIST
23304: LIST
23305: LIST
23306: PPUSH
23307: CALL_OW 72
23311: NOT
23312: OR
23313: IFFALSE 23317
// exit ;
23315: GO 26820
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
23317: LD_ADDR_VAR 0 4
23321: PUSH
23322: LD_EXP 50
23326: PUSH
23327: LD_VAR 0 1
23331: ARRAY
23332: PPUSH
23333: LD_INT 2
23335: PUSH
23336: LD_INT 25
23338: PUSH
23339: LD_INT 1
23341: PUSH
23342: EMPTY
23343: LIST
23344: LIST
23345: PUSH
23346: LD_INT 25
23348: PUSH
23349: LD_INT 2
23351: PUSH
23352: EMPTY
23353: LIST
23354: LIST
23355: PUSH
23356: LD_INT 25
23358: PUSH
23359: LD_INT 3
23361: PUSH
23362: EMPTY
23363: LIST
23364: LIST
23365: PUSH
23366: LD_INT 25
23368: PUSH
23369: LD_INT 4
23371: PUSH
23372: EMPTY
23373: LIST
23374: LIST
23375: PUSH
23376: LD_INT 25
23378: PUSH
23379: LD_INT 5
23381: PUSH
23382: EMPTY
23383: LIST
23384: LIST
23385: PUSH
23386: LD_INT 25
23388: PUSH
23389: LD_INT 8
23391: PUSH
23392: EMPTY
23393: LIST
23394: LIST
23395: PUSH
23396: LD_INT 25
23398: PUSH
23399: LD_INT 9
23401: PUSH
23402: EMPTY
23403: LIST
23404: LIST
23405: PUSH
23406: EMPTY
23407: LIST
23408: LIST
23409: LIST
23410: LIST
23411: LIST
23412: LIST
23413: LIST
23414: LIST
23415: PPUSH
23416: CALL_OW 72
23420: ST_TO_ADDR
// if not tmp then
23421: LD_VAR 0 4
23425: NOT
23426: IFFALSE 23430
// exit ;
23428: GO 26820
// for i in tmp do
23430: LD_ADDR_VAR 0 3
23434: PUSH
23435: LD_VAR 0 4
23439: PUSH
23440: FOR_IN
23441: IFFALSE 23472
// if GetTag ( i ) then
23443: LD_VAR 0 3
23447: PPUSH
23448: CALL_OW 110
23452: IFFALSE 23470
// tmp := tmp diff i ;
23454: LD_ADDR_VAR 0 4
23458: PUSH
23459: LD_VAR 0 4
23463: PUSH
23464: LD_VAR 0 3
23468: DIFF
23469: ST_TO_ADDR
23470: GO 23440
23472: POP
23473: POP
// if not tmp then
23474: LD_VAR 0 4
23478: NOT
23479: IFFALSE 23483
// exit ;
23481: GO 26820
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
23483: LD_ADDR_VAR 0 5
23487: PUSH
23488: LD_EXP 50
23492: PUSH
23493: LD_VAR 0 1
23497: ARRAY
23498: PPUSH
23499: LD_INT 2
23501: PUSH
23502: LD_INT 25
23504: PUSH
23505: LD_INT 1
23507: PUSH
23508: EMPTY
23509: LIST
23510: LIST
23511: PUSH
23512: LD_INT 25
23514: PUSH
23515: LD_INT 5
23517: PUSH
23518: EMPTY
23519: LIST
23520: LIST
23521: PUSH
23522: LD_INT 25
23524: PUSH
23525: LD_INT 8
23527: PUSH
23528: EMPTY
23529: LIST
23530: LIST
23531: PUSH
23532: LD_INT 25
23534: PUSH
23535: LD_INT 9
23537: PUSH
23538: EMPTY
23539: LIST
23540: LIST
23541: PUSH
23542: EMPTY
23543: LIST
23544: LIST
23545: LIST
23546: LIST
23547: LIST
23548: PPUSH
23549: CALL_OW 72
23553: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
23554: LD_ADDR_VAR 0 6
23558: PUSH
23559: LD_EXP 50
23563: PUSH
23564: LD_VAR 0 1
23568: ARRAY
23569: PPUSH
23570: LD_INT 25
23572: PUSH
23573: LD_INT 2
23575: PUSH
23576: EMPTY
23577: LIST
23578: LIST
23579: PPUSH
23580: CALL_OW 72
23584: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
23585: LD_ADDR_VAR 0 7
23589: PUSH
23590: LD_EXP 50
23594: PUSH
23595: LD_VAR 0 1
23599: ARRAY
23600: PPUSH
23601: LD_INT 25
23603: PUSH
23604: LD_INT 3
23606: PUSH
23607: EMPTY
23608: LIST
23609: LIST
23610: PPUSH
23611: CALL_OW 72
23615: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
23616: LD_ADDR_VAR 0 8
23620: PUSH
23621: LD_EXP 50
23625: PUSH
23626: LD_VAR 0 1
23630: ARRAY
23631: PPUSH
23632: LD_INT 25
23634: PUSH
23635: LD_INT 4
23637: PUSH
23638: EMPTY
23639: LIST
23640: LIST
23641: PUSH
23642: LD_INT 24
23644: PUSH
23645: LD_INT 251
23647: PUSH
23648: EMPTY
23649: LIST
23650: LIST
23651: PUSH
23652: EMPTY
23653: LIST
23654: LIST
23655: PPUSH
23656: CALL_OW 72
23660: ST_TO_ADDR
// if mc_is_defending [ base ] then
23661: LD_EXP 93
23665: PUSH
23666: LD_VAR 0 1
23670: ARRAY
23671: IFFALSE 24132
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
23673: LD_ADDR_EXP 92
23677: PUSH
23678: LD_EXP 92
23682: PPUSH
23683: LD_VAR 0 1
23687: PPUSH
23688: LD_INT 4
23690: PPUSH
23691: CALL_OW 1
23695: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
23696: LD_ADDR_VAR 0 12
23700: PUSH
23701: LD_EXP 50
23705: PUSH
23706: LD_VAR 0 1
23710: ARRAY
23711: PPUSH
23712: LD_INT 2
23714: PUSH
23715: LD_INT 30
23717: PUSH
23718: LD_INT 4
23720: PUSH
23721: EMPTY
23722: LIST
23723: LIST
23724: PUSH
23725: LD_INT 30
23727: PUSH
23728: LD_INT 5
23730: PUSH
23731: EMPTY
23732: LIST
23733: LIST
23734: PUSH
23735: EMPTY
23736: LIST
23737: LIST
23738: LIST
23739: PPUSH
23740: CALL_OW 72
23744: ST_TO_ADDR
// if not b then
23745: LD_VAR 0 12
23749: NOT
23750: IFFALSE 23754
// exit ;
23752: GO 26820
// p := [ ] ;
23754: LD_ADDR_VAR 0 11
23758: PUSH
23759: EMPTY
23760: ST_TO_ADDR
// if sci >= 2 then
23761: LD_VAR 0 8
23765: PUSH
23766: LD_INT 2
23768: GREATEREQUAL
23769: IFFALSE 23800
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
23771: LD_ADDR_VAR 0 8
23775: PUSH
23776: LD_VAR 0 8
23780: PUSH
23781: LD_INT 1
23783: ARRAY
23784: PUSH
23785: LD_VAR 0 8
23789: PUSH
23790: LD_INT 2
23792: ARRAY
23793: PUSH
23794: EMPTY
23795: LIST
23796: LIST
23797: ST_TO_ADDR
23798: GO 23861
// if sci = 1 then
23800: LD_VAR 0 8
23804: PUSH
23805: LD_INT 1
23807: EQUAL
23808: IFFALSE 23829
// sci := [ sci [ 1 ] ] else
23810: LD_ADDR_VAR 0 8
23814: PUSH
23815: LD_VAR 0 8
23819: PUSH
23820: LD_INT 1
23822: ARRAY
23823: PUSH
23824: EMPTY
23825: LIST
23826: ST_TO_ADDR
23827: GO 23861
// if sci = 0 then
23829: LD_VAR 0 8
23833: PUSH
23834: LD_INT 0
23836: EQUAL
23837: IFFALSE 23861
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
23839: LD_ADDR_VAR 0 11
23843: PUSH
23844: LD_VAR 0 4
23848: PPUSH
23849: LD_INT 4
23851: PPUSH
23852: CALL 85378 0 2
23856: PUSH
23857: LD_INT 1
23859: ARRAY
23860: ST_TO_ADDR
// if eng > 4 then
23861: LD_VAR 0 6
23865: PUSH
23866: LD_INT 4
23868: GREATER
23869: IFFALSE 23915
// for i = eng downto 4 do
23871: LD_ADDR_VAR 0 3
23875: PUSH
23876: DOUBLE
23877: LD_VAR 0 6
23881: INC
23882: ST_TO_ADDR
23883: LD_INT 4
23885: PUSH
23886: FOR_DOWNTO
23887: IFFALSE 23913
// eng := eng diff eng [ i ] ;
23889: LD_ADDR_VAR 0 6
23893: PUSH
23894: LD_VAR 0 6
23898: PUSH
23899: LD_VAR 0 6
23903: PUSH
23904: LD_VAR 0 3
23908: ARRAY
23909: DIFF
23910: ST_TO_ADDR
23911: GO 23886
23913: POP
23914: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
23915: LD_ADDR_VAR 0 4
23919: PUSH
23920: LD_VAR 0 4
23924: PUSH
23925: LD_VAR 0 5
23929: PUSH
23930: LD_VAR 0 6
23934: UNION
23935: PUSH
23936: LD_VAR 0 7
23940: UNION
23941: PUSH
23942: LD_VAR 0 8
23946: UNION
23947: DIFF
23948: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
23949: LD_ADDR_VAR 0 13
23953: PUSH
23954: LD_EXP 50
23958: PUSH
23959: LD_VAR 0 1
23963: ARRAY
23964: PPUSH
23965: LD_INT 2
23967: PUSH
23968: LD_INT 30
23970: PUSH
23971: LD_INT 32
23973: PUSH
23974: EMPTY
23975: LIST
23976: LIST
23977: PUSH
23978: LD_INT 30
23980: PUSH
23981: LD_INT 31
23983: PUSH
23984: EMPTY
23985: LIST
23986: LIST
23987: PUSH
23988: EMPTY
23989: LIST
23990: LIST
23991: LIST
23992: PPUSH
23993: CALL_OW 72
23997: PUSH
23998: LD_EXP 50
24002: PUSH
24003: LD_VAR 0 1
24007: ARRAY
24008: PPUSH
24009: LD_INT 2
24011: PUSH
24012: LD_INT 30
24014: PUSH
24015: LD_INT 4
24017: PUSH
24018: EMPTY
24019: LIST
24020: LIST
24021: PUSH
24022: LD_INT 30
24024: PUSH
24025: LD_INT 5
24027: PUSH
24028: EMPTY
24029: LIST
24030: LIST
24031: PUSH
24032: EMPTY
24033: LIST
24034: LIST
24035: LIST
24036: PPUSH
24037: CALL_OW 72
24041: PUSH
24042: LD_INT 6
24044: MUL
24045: PLUS
24046: ST_TO_ADDR
// if bcount < tmp then
24047: LD_VAR 0 13
24051: PUSH
24052: LD_VAR 0 4
24056: LESS
24057: IFFALSE 24103
// for i = tmp downto bcount do
24059: LD_ADDR_VAR 0 3
24063: PUSH
24064: DOUBLE
24065: LD_VAR 0 4
24069: INC
24070: ST_TO_ADDR
24071: LD_VAR 0 13
24075: PUSH
24076: FOR_DOWNTO
24077: IFFALSE 24101
// tmp := Delete ( tmp , tmp ) ;
24079: LD_ADDR_VAR 0 4
24083: PUSH
24084: LD_VAR 0 4
24088: PPUSH
24089: LD_VAR 0 4
24093: PPUSH
24094: CALL_OW 3
24098: ST_TO_ADDR
24099: GO 24076
24101: POP
24102: POP
// result := [ tmp , 0 , 0 , p ] ;
24103: LD_ADDR_VAR 0 2
24107: PUSH
24108: LD_VAR 0 4
24112: PUSH
24113: LD_INT 0
24115: PUSH
24116: LD_INT 0
24118: PUSH
24119: LD_VAR 0 11
24123: PUSH
24124: EMPTY
24125: LIST
24126: LIST
24127: LIST
24128: LIST
24129: ST_TO_ADDR
// exit ;
24130: GO 26820
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
24132: LD_EXP 50
24136: PUSH
24137: LD_VAR 0 1
24141: ARRAY
24142: PPUSH
24143: LD_INT 2
24145: PUSH
24146: LD_INT 30
24148: PUSH
24149: LD_INT 6
24151: PUSH
24152: EMPTY
24153: LIST
24154: LIST
24155: PUSH
24156: LD_INT 30
24158: PUSH
24159: LD_INT 7
24161: PUSH
24162: EMPTY
24163: LIST
24164: LIST
24165: PUSH
24166: LD_INT 30
24168: PUSH
24169: LD_INT 8
24171: PUSH
24172: EMPTY
24173: LIST
24174: LIST
24175: PUSH
24176: EMPTY
24177: LIST
24178: LIST
24179: LIST
24180: LIST
24181: PPUSH
24182: CALL_OW 72
24186: NOT
24187: PUSH
24188: LD_EXP 50
24192: PUSH
24193: LD_VAR 0 1
24197: ARRAY
24198: PPUSH
24199: LD_INT 30
24201: PUSH
24202: LD_INT 3
24204: PUSH
24205: EMPTY
24206: LIST
24207: LIST
24208: PPUSH
24209: CALL_OW 72
24213: NOT
24214: AND
24215: IFFALSE 24287
// begin if eng = tmp then
24217: LD_VAR 0 6
24221: PUSH
24222: LD_VAR 0 4
24226: EQUAL
24227: IFFALSE 24231
// exit ;
24229: GO 26820
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
24231: LD_ADDR_EXP 92
24235: PUSH
24236: LD_EXP 92
24240: PPUSH
24241: LD_VAR 0 1
24245: PPUSH
24246: LD_INT 1
24248: PPUSH
24249: CALL_OW 1
24253: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
24254: LD_ADDR_VAR 0 2
24258: PUSH
24259: LD_INT 0
24261: PUSH
24262: LD_VAR 0 4
24266: PUSH
24267: LD_VAR 0 6
24271: DIFF
24272: PUSH
24273: LD_INT 0
24275: PUSH
24276: LD_INT 0
24278: PUSH
24279: EMPTY
24280: LIST
24281: LIST
24282: LIST
24283: LIST
24284: ST_TO_ADDR
// exit ;
24285: GO 26820
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
24287: LD_EXP 77
24291: PUSH
24292: LD_EXP 76
24296: PUSH
24297: LD_VAR 0 1
24301: ARRAY
24302: ARRAY
24303: PUSH
24304: LD_EXP 50
24308: PUSH
24309: LD_VAR 0 1
24313: ARRAY
24314: PPUSH
24315: LD_INT 2
24317: PUSH
24318: LD_INT 30
24320: PUSH
24321: LD_INT 6
24323: PUSH
24324: EMPTY
24325: LIST
24326: LIST
24327: PUSH
24328: LD_INT 30
24330: PUSH
24331: LD_INT 7
24333: PUSH
24334: EMPTY
24335: LIST
24336: LIST
24337: PUSH
24338: LD_INT 30
24340: PUSH
24341: LD_INT 8
24343: PUSH
24344: EMPTY
24345: LIST
24346: LIST
24347: PUSH
24348: EMPTY
24349: LIST
24350: LIST
24351: LIST
24352: LIST
24353: PPUSH
24354: CALL_OW 72
24358: AND
24359: PUSH
24360: LD_EXP 50
24364: PUSH
24365: LD_VAR 0 1
24369: ARRAY
24370: PPUSH
24371: LD_INT 30
24373: PUSH
24374: LD_INT 3
24376: PUSH
24377: EMPTY
24378: LIST
24379: LIST
24380: PPUSH
24381: CALL_OW 72
24385: NOT
24386: AND
24387: IFFALSE 24601
// begin if sci >= 6 then
24389: LD_VAR 0 8
24393: PUSH
24394: LD_INT 6
24396: GREATEREQUAL
24397: IFFALSE 24401
// exit ;
24399: GO 26820
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
24401: LD_ADDR_EXP 92
24405: PUSH
24406: LD_EXP 92
24410: PPUSH
24411: LD_VAR 0 1
24415: PPUSH
24416: LD_INT 2
24418: PPUSH
24419: CALL_OW 1
24423: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
24424: LD_ADDR_VAR 0 9
24428: PUSH
24429: LD_VAR 0 4
24433: PUSH
24434: LD_VAR 0 8
24438: DIFF
24439: PPUSH
24440: LD_INT 4
24442: PPUSH
24443: CALL 85378 0 2
24447: ST_TO_ADDR
// p := [ ] ;
24448: LD_ADDR_VAR 0 11
24452: PUSH
24453: EMPTY
24454: ST_TO_ADDR
// if sci < 6 and sort > 6 then
24455: LD_VAR 0 8
24459: PUSH
24460: LD_INT 6
24462: LESS
24463: PUSH
24464: LD_VAR 0 9
24468: PUSH
24469: LD_INT 6
24471: GREATER
24472: AND
24473: IFFALSE 24554
// begin for i = 1 to 6 - sci do
24475: LD_ADDR_VAR 0 3
24479: PUSH
24480: DOUBLE
24481: LD_INT 1
24483: DEC
24484: ST_TO_ADDR
24485: LD_INT 6
24487: PUSH
24488: LD_VAR 0 8
24492: MINUS
24493: PUSH
24494: FOR_TO
24495: IFFALSE 24550
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
24497: LD_ADDR_VAR 0 11
24501: PUSH
24502: LD_VAR 0 11
24506: PPUSH
24507: LD_VAR 0 11
24511: PUSH
24512: LD_INT 1
24514: PLUS
24515: PPUSH
24516: LD_VAR 0 9
24520: PUSH
24521: LD_INT 1
24523: ARRAY
24524: PPUSH
24525: CALL_OW 2
24529: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
24530: LD_ADDR_VAR 0 9
24534: PUSH
24535: LD_VAR 0 9
24539: PPUSH
24540: LD_INT 1
24542: PPUSH
24543: CALL_OW 3
24547: ST_TO_ADDR
// end ;
24548: GO 24494
24550: POP
24551: POP
// end else
24552: GO 24574
// if sort then
24554: LD_VAR 0 9
24558: IFFALSE 24574
// p := sort [ 1 ] ;
24560: LD_ADDR_VAR 0 11
24564: PUSH
24565: LD_VAR 0 9
24569: PUSH
24570: LD_INT 1
24572: ARRAY
24573: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
24574: LD_ADDR_VAR 0 2
24578: PUSH
24579: LD_INT 0
24581: PUSH
24582: LD_INT 0
24584: PUSH
24585: LD_INT 0
24587: PUSH
24588: LD_VAR 0 11
24592: PUSH
24593: EMPTY
24594: LIST
24595: LIST
24596: LIST
24597: LIST
24598: ST_TO_ADDR
// exit ;
24599: GO 26820
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
24601: LD_EXP 77
24605: PUSH
24606: LD_EXP 76
24610: PUSH
24611: LD_VAR 0 1
24615: ARRAY
24616: ARRAY
24617: PUSH
24618: LD_EXP 50
24622: PUSH
24623: LD_VAR 0 1
24627: ARRAY
24628: PPUSH
24629: LD_INT 2
24631: PUSH
24632: LD_INT 30
24634: PUSH
24635: LD_INT 6
24637: PUSH
24638: EMPTY
24639: LIST
24640: LIST
24641: PUSH
24642: LD_INT 30
24644: PUSH
24645: LD_INT 7
24647: PUSH
24648: EMPTY
24649: LIST
24650: LIST
24651: PUSH
24652: LD_INT 30
24654: PUSH
24655: LD_INT 8
24657: PUSH
24658: EMPTY
24659: LIST
24660: LIST
24661: PUSH
24662: EMPTY
24663: LIST
24664: LIST
24665: LIST
24666: LIST
24667: PPUSH
24668: CALL_OW 72
24672: AND
24673: PUSH
24674: LD_EXP 50
24678: PUSH
24679: LD_VAR 0 1
24683: ARRAY
24684: PPUSH
24685: LD_INT 30
24687: PUSH
24688: LD_INT 3
24690: PUSH
24691: EMPTY
24692: LIST
24693: LIST
24694: PPUSH
24695: CALL_OW 72
24699: AND
24700: IFFALSE 25434
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
24702: LD_ADDR_EXP 92
24706: PUSH
24707: LD_EXP 92
24711: PPUSH
24712: LD_VAR 0 1
24716: PPUSH
24717: LD_INT 3
24719: PPUSH
24720: CALL_OW 1
24724: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
24725: LD_ADDR_VAR 0 2
24729: PUSH
24730: LD_INT 0
24732: PUSH
24733: LD_INT 0
24735: PUSH
24736: LD_INT 0
24738: PUSH
24739: LD_INT 0
24741: PUSH
24742: EMPTY
24743: LIST
24744: LIST
24745: LIST
24746: LIST
24747: ST_TO_ADDR
// if not eng then
24748: LD_VAR 0 6
24752: NOT
24753: IFFALSE 24816
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
24755: LD_ADDR_VAR 0 11
24759: PUSH
24760: LD_VAR 0 4
24764: PPUSH
24765: LD_INT 2
24767: PPUSH
24768: CALL 85378 0 2
24772: PUSH
24773: LD_INT 1
24775: ARRAY
24776: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
24777: LD_ADDR_VAR 0 2
24781: PUSH
24782: LD_VAR 0 2
24786: PPUSH
24787: LD_INT 2
24789: PPUSH
24790: LD_VAR 0 11
24794: PPUSH
24795: CALL_OW 1
24799: ST_TO_ADDR
// tmp := tmp diff p ;
24800: LD_ADDR_VAR 0 4
24804: PUSH
24805: LD_VAR 0 4
24809: PUSH
24810: LD_VAR 0 11
24814: DIFF
24815: ST_TO_ADDR
// end ; if tmp and sci < 6 then
24816: LD_VAR 0 4
24820: PUSH
24821: LD_VAR 0 8
24825: PUSH
24826: LD_INT 6
24828: LESS
24829: AND
24830: IFFALSE 25018
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
24832: LD_ADDR_VAR 0 9
24836: PUSH
24837: LD_VAR 0 4
24841: PUSH
24842: LD_VAR 0 8
24846: PUSH
24847: LD_VAR 0 7
24851: UNION
24852: DIFF
24853: PPUSH
24854: LD_INT 4
24856: PPUSH
24857: CALL 85378 0 2
24861: ST_TO_ADDR
// p := [ ] ;
24862: LD_ADDR_VAR 0 11
24866: PUSH
24867: EMPTY
24868: ST_TO_ADDR
// if sort then
24869: LD_VAR 0 9
24873: IFFALSE 24989
// for i = 1 to 6 - sci do
24875: LD_ADDR_VAR 0 3
24879: PUSH
24880: DOUBLE
24881: LD_INT 1
24883: DEC
24884: ST_TO_ADDR
24885: LD_INT 6
24887: PUSH
24888: LD_VAR 0 8
24892: MINUS
24893: PUSH
24894: FOR_TO
24895: IFFALSE 24987
// begin if i = sort then
24897: LD_VAR 0 3
24901: PUSH
24902: LD_VAR 0 9
24906: EQUAL
24907: IFFALSE 24911
// break ;
24909: GO 24987
// if GetClass ( i ) = 4 then
24911: LD_VAR 0 3
24915: PPUSH
24916: CALL_OW 257
24920: PUSH
24921: LD_INT 4
24923: EQUAL
24924: IFFALSE 24928
// continue ;
24926: GO 24894
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24928: LD_ADDR_VAR 0 11
24932: PUSH
24933: LD_VAR 0 11
24937: PPUSH
24938: LD_VAR 0 11
24942: PUSH
24943: LD_INT 1
24945: PLUS
24946: PPUSH
24947: LD_VAR 0 9
24951: PUSH
24952: LD_VAR 0 3
24956: ARRAY
24957: PPUSH
24958: CALL_OW 2
24962: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24963: LD_ADDR_VAR 0 4
24967: PUSH
24968: LD_VAR 0 4
24972: PUSH
24973: LD_VAR 0 9
24977: PUSH
24978: LD_VAR 0 3
24982: ARRAY
24983: DIFF
24984: ST_TO_ADDR
// end ;
24985: GO 24894
24987: POP
24988: POP
// if p then
24989: LD_VAR 0 11
24993: IFFALSE 25018
// result := Replace ( result , 4 , p ) ;
24995: LD_ADDR_VAR 0 2
24999: PUSH
25000: LD_VAR 0 2
25004: PPUSH
25005: LD_INT 4
25007: PPUSH
25008: LD_VAR 0 11
25012: PPUSH
25013: CALL_OW 1
25017: ST_TO_ADDR
// end ; if tmp and mech < 6 then
25018: LD_VAR 0 4
25022: PUSH
25023: LD_VAR 0 7
25027: PUSH
25028: LD_INT 6
25030: LESS
25031: AND
25032: IFFALSE 25220
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
25034: LD_ADDR_VAR 0 9
25038: PUSH
25039: LD_VAR 0 4
25043: PUSH
25044: LD_VAR 0 8
25048: PUSH
25049: LD_VAR 0 7
25053: UNION
25054: DIFF
25055: PPUSH
25056: LD_INT 3
25058: PPUSH
25059: CALL 85378 0 2
25063: ST_TO_ADDR
// p := [ ] ;
25064: LD_ADDR_VAR 0 11
25068: PUSH
25069: EMPTY
25070: ST_TO_ADDR
// if sort then
25071: LD_VAR 0 9
25075: IFFALSE 25191
// for i = 1 to 6 - mech do
25077: LD_ADDR_VAR 0 3
25081: PUSH
25082: DOUBLE
25083: LD_INT 1
25085: DEC
25086: ST_TO_ADDR
25087: LD_INT 6
25089: PUSH
25090: LD_VAR 0 7
25094: MINUS
25095: PUSH
25096: FOR_TO
25097: IFFALSE 25189
// begin if i = sort then
25099: LD_VAR 0 3
25103: PUSH
25104: LD_VAR 0 9
25108: EQUAL
25109: IFFALSE 25113
// break ;
25111: GO 25189
// if GetClass ( i ) = 3 then
25113: LD_VAR 0 3
25117: PPUSH
25118: CALL_OW 257
25122: PUSH
25123: LD_INT 3
25125: EQUAL
25126: IFFALSE 25130
// continue ;
25128: GO 25096
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25130: LD_ADDR_VAR 0 11
25134: PUSH
25135: LD_VAR 0 11
25139: PPUSH
25140: LD_VAR 0 11
25144: PUSH
25145: LD_INT 1
25147: PLUS
25148: PPUSH
25149: LD_VAR 0 9
25153: PUSH
25154: LD_VAR 0 3
25158: ARRAY
25159: PPUSH
25160: CALL_OW 2
25164: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25165: LD_ADDR_VAR 0 4
25169: PUSH
25170: LD_VAR 0 4
25174: PUSH
25175: LD_VAR 0 9
25179: PUSH
25180: LD_VAR 0 3
25184: ARRAY
25185: DIFF
25186: ST_TO_ADDR
// end ;
25187: GO 25096
25189: POP
25190: POP
// if p then
25191: LD_VAR 0 11
25195: IFFALSE 25220
// result := Replace ( result , 3 , p ) ;
25197: LD_ADDR_VAR 0 2
25201: PUSH
25202: LD_VAR 0 2
25206: PPUSH
25207: LD_INT 3
25209: PPUSH
25210: LD_VAR 0 11
25214: PPUSH
25215: CALL_OW 1
25219: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
25220: LD_VAR 0 4
25224: PUSH
25225: LD_INT 6
25227: GREATER
25228: PUSH
25229: LD_VAR 0 6
25233: PUSH
25234: LD_INT 6
25236: LESS
25237: AND
25238: IFFALSE 25432
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
25240: LD_ADDR_VAR 0 9
25244: PUSH
25245: LD_VAR 0 4
25249: PUSH
25250: LD_VAR 0 8
25254: PUSH
25255: LD_VAR 0 7
25259: UNION
25260: PUSH
25261: LD_VAR 0 6
25265: UNION
25266: DIFF
25267: PPUSH
25268: LD_INT 2
25270: PPUSH
25271: CALL 85378 0 2
25275: ST_TO_ADDR
// p := [ ] ;
25276: LD_ADDR_VAR 0 11
25280: PUSH
25281: EMPTY
25282: ST_TO_ADDR
// if sort then
25283: LD_VAR 0 9
25287: IFFALSE 25403
// for i = 1 to 6 - eng do
25289: LD_ADDR_VAR 0 3
25293: PUSH
25294: DOUBLE
25295: LD_INT 1
25297: DEC
25298: ST_TO_ADDR
25299: LD_INT 6
25301: PUSH
25302: LD_VAR 0 6
25306: MINUS
25307: PUSH
25308: FOR_TO
25309: IFFALSE 25401
// begin if i = sort then
25311: LD_VAR 0 3
25315: PUSH
25316: LD_VAR 0 9
25320: EQUAL
25321: IFFALSE 25325
// break ;
25323: GO 25401
// if GetClass ( i ) = 2 then
25325: LD_VAR 0 3
25329: PPUSH
25330: CALL_OW 257
25334: PUSH
25335: LD_INT 2
25337: EQUAL
25338: IFFALSE 25342
// continue ;
25340: GO 25308
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25342: LD_ADDR_VAR 0 11
25346: PUSH
25347: LD_VAR 0 11
25351: PPUSH
25352: LD_VAR 0 11
25356: PUSH
25357: LD_INT 1
25359: PLUS
25360: PPUSH
25361: LD_VAR 0 9
25365: PUSH
25366: LD_VAR 0 3
25370: ARRAY
25371: PPUSH
25372: CALL_OW 2
25376: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25377: LD_ADDR_VAR 0 4
25381: PUSH
25382: LD_VAR 0 4
25386: PUSH
25387: LD_VAR 0 9
25391: PUSH
25392: LD_VAR 0 3
25396: ARRAY
25397: DIFF
25398: ST_TO_ADDR
// end ;
25399: GO 25308
25401: POP
25402: POP
// if p then
25403: LD_VAR 0 11
25407: IFFALSE 25432
// result := Replace ( result , 2 , p ) ;
25409: LD_ADDR_VAR 0 2
25413: PUSH
25414: LD_VAR 0 2
25418: PPUSH
25419: LD_INT 2
25421: PPUSH
25422: LD_VAR 0 11
25426: PPUSH
25427: CALL_OW 1
25431: ST_TO_ADDR
// end ; exit ;
25432: GO 26820
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
25434: LD_EXP 77
25438: PUSH
25439: LD_EXP 76
25443: PUSH
25444: LD_VAR 0 1
25448: ARRAY
25449: ARRAY
25450: NOT
25451: PUSH
25452: LD_EXP 50
25456: PUSH
25457: LD_VAR 0 1
25461: ARRAY
25462: PPUSH
25463: LD_INT 30
25465: PUSH
25466: LD_INT 3
25468: PUSH
25469: EMPTY
25470: LIST
25471: LIST
25472: PPUSH
25473: CALL_OW 72
25477: AND
25478: PUSH
25479: LD_EXP 55
25483: PUSH
25484: LD_VAR 0 1
25488: ARRAY
25489: AND
25490: IFFALSE 26098
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
25492: LD_ADDR_EXP 92
25496: PUSH
25497: LD_EXP 92
25501: PPUSH
25502: LD_VAR 0 1
25506: PPUSH
25507: LD_INT 5
25509: PPUSH
25510: CALL_OW 1
25514: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
25515: LD_ADDR_VAR 0 2
25519: PUSH
25520: LD_INT 0
25522: PUSH
25523: LD_INT 0
25525: PUSH
25526: LD_INT 0
25528: PUSH
25529: LD_INT 0
25531: PUSH
25532: EMPTY
25533: LIST
25534: LIST
25535: LIST
25536: LIST
25537: ST_TO_ADDR
// if sci > 1 then
25538: LD_VAR 0 8
25542: PUSH
25543: LD_INT 1
25545: GREATER
25546: IFFALSE 25574
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
25548: LD_ADDR_VAR 0 4
25552: PUSH
25553: LD_VAR 0 4
25557: PUSH
25558: LD_VAR 0 8
25562: PUSH
25563: LD_VAR 0 8
25567: PUSH
25568: LD_INT 1
25570: ARRAY
25571: DIFF
25572: DIFF
25573: ST_TO_ADDR
// if tmp and not sci then
25574: LD_VAR 0 4
25578: PUSH
25579: LD_VAR 0 8
25583: NOT
25584: AND
25585: IFFALSE 25654
// begin sort := SortBySkill ( tmp , 4 ) ;
25587: LD_ADDR_VAR 0 9
25591: PUSH
25592: LD_VAR 0 4
25596: PPUSH
25597: LD_INT 4
25599: PPUSH
25600: CALL 85378 0 2
25604: ST_TO_ADDR
// if sort then
25605: LD_VAR 0 9
25609: IFFALSE 25625
// p := sort [ 1 ] ;
25611: LD_ADDR_VAR 0 11
25615: PUSH
25616: LD_VAR 0 9
25620: PUSH
25621: LD_INT 1
25623: ARRAY
25624: ST_TO_ADDR
// if p then
25625: LD_VAR 0 11
25629: IFFALSE 25654
// result := Replace ( result , 4 , p ) ;
25631: LD_ADDR_VAR 0 2
25635: PUSH
25636: LD_VAR 0 2
25640: PPUSH
25641: LD_INT 4
25643: PPUSH
25644: LD_VAR 0 11
25648: PPUSH
25649: CALL_OW 1
25653: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
25654: LD_ADDR_VAR 0 4
25658: PUSH
25659: LD_VAR 0 4
25663: PUSH
25664: LD_VAR 0 7
25668: DIFF
25669: ST_TO_ADDR
// if tmp and mech < 6 then
25670: LD_VAR 0 4
25674: PUSH
25675: LD_VAR 0 7
25679: PUSH
25680: LD_INT 6
25682: LESS
25683: AND
25684: IFFALSE 25872
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
25686: LD_ADDR_VAR 0 9
25690: PUSH
25691: LD_VAR 0 4
25695: PUSH
25696: LD_VAR 0 8
25700: PUSH
25701: LD_VAR 0 7
25705: UNION
25706: DIFF
25707: PPUSH
25708: LD_INT 3
25710: PPUSH
25711: CALL 85378 0 2
25715: ST_TO_ADDR
// p := [ ] ;
25716: LD_ADDR_VAR 0 11
25720: PUSH
25721: EMPTY
25722: ST_TO_ADDR
// if sort then
25723: LD_VAR 0 9
25727: IFFALSE 25843
// for i = 1 to 6 - mech do
25729: LD_ADDR_VAR 0 3
25733: PUSH
25734: DOUBLE
25735: LD_INT 1
25737: DEC
25738: ST_TO_ADDR
25739: LD_INT 6
25741: PUSH
25742: LD_VAR 0 7
25746: MINUS
25747: PUSH
25748: FOR_TO
25749: IFFALSE 25841
// begin if i = sort then
25751: LD_VAR 0 3
25755: PUSH
25756: LD_VAR 0 9
25760: EQUAL
25761: IFFALSE 25765
// break ;
25763: GO 25841
// if GetClass ( i ) = 3 then
25765: LD_VAR 0 3
25769: PPUSH
25770: CALL_OW 257
25774: PUSH
25775: LD_INT 3
25777: EQUAL
25778: IFFALSE 25782
// continue ;
25780: GO 25748
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25782: LD_ADDR_VAR 0 11
25786: PUSH
25787: LD_VAR 0 11
25791: PPUSH
25792: LD_VAR 0 11
25796: PUSH
25797: LD_INT 1
25799: PLUS
25800: PPUSH
25801: LD_VAR 0 9
25805: PUSH
25806: LD_VAR 0 3
25810: ARRAY
25811: PPUSH
25812: CALL_OW 2
25816: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25817: LD_ADDR_VAR 0 4
25821: PUSH
25822: LD_VAR 0 4
25826: PUSH
25827: LD_VAR 0 9
25831: PUSH
25832: LD_VAR 0 3
25836: ARRAY
25837: DIFF
25838: ST_TO_ADDR
// end ;
25839: GO 25748
25841: POP
25842: POP
// if p then
25843: LD_VAR 0 11
25847: IFFALSE 25872
// result := Replace ( result , 3 , p ) ;
25849: LD_ADDR_VAR 0 2
25853: PUSH
25854: LD_VAR 0 2
25858: PPUSH
25859: LD_INT 3
25861: PPUSH
25862: LD_VAR 0 11
25866: PPUSH
25867: CALL_OW 1
25871: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
25872: LD_ADDR_VAR 0 4
25876: PUSH
25877: LD_VAR 0 4
25881: PUSH
25882: LD_VAR 0 6
25886: DIFF
25887: ST_TO_ADDR
// if tmp and eng < 6 then
25888: LD_VAR 0 4
25892: PUSH
25893: LD_VAR 0 6
25897: PUSH
25898: LD_INT 6
25900: LESS
25901: AND
25902: IFFALSE 26096
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
25904: LD_ADDR_VAR 0 9
25908: PUSH
25909: LD_VAR 0 4
25913: PUSH
25914: LD_VAR 0 8
25918: PUSH
25919: LD_VAR 0 7
25923: UNION
25924: PUSH
25925: LD_VAR 0 6
25929: UNION
25930: DIFF
25931: PPUSH
25932: LD_INT 2
25934: PPUSH
25935: CALL 85378 0 2
25939: ST_TO_ADDR
// p := [ ] ;
25940: LD_ADDR_VAR 0 11
25944: PUSH
25945: EMPTY
25946: ST_TO_ADDR
// if sort then
25947: LD_VAR 0 9
25951: IFFALSE 26067
// for i = 1 to 6 - eng do
25953: LD_ADDR_VAR 0 3
25957: PUSH
25958: DOUBLE
25959: LD_INT 1
25961: DEC
25962: ST_TO_ADDR
25963: LD_INT 6
25965: PUSH
25966: LD_VAR 0 6
25970: MINUS
25971: PUSH
25972: FOR_TO
25973: IFFALSE 26065
// begin if i = sort then
25975: LD_VAR 0 3
25979: PUSH
25980: LD_VAR 0 9
25984: EQUAL
25985: IFFALSE 25989
// break ;
25987: GO 26065
// if GetClass ( i ) = 2 then
25989: LD_VAR 0 3
25993: PPUSH
25994: CALL_OW 257
25998: PUSH
25999: LD_INT 2
26001: EQUAL
26002: IFFALSE 26006
// continue ;
26004: GO 25972
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26006: LD_ADDR_VAR 0 11
26010: PUSH
26011: LD_VAR 0 11
26015: PPUSH
26016: LD_VAR 0 11
26020: PUSH
26021: LD_INT 1
26023: PLUS
26024: PPUSH
26025: LD_VAR 0 9
26029: PUSH
26030: LD_VAR 0 3
26034: ARRAY
26035: PPUSH
26036: CALL_OW 2
26040: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26041: LD_ADDR_VAR 0 4
26045: PUSH
26046: LD_VAR 0 4
26050: PUSH
26051: LD_VAR 0 9
26055: PUSH
26056: LD_VAR 0 3
26060: ARRAY
26061: DIFF
26062: ST_TO_ADDR
// end ;
26063: GO 25972
26065: POP
26066: POP
// if p then
26067: LD_VAR 0 11
26071: IFFALSE 26096
// result := Replace ( result , 2 , p ) ;
26073: LD_ADDR_VAR 0 2
26077: PUSH
26078: LD_VAR 0 2
26082: PPUSH
26083: LD_INT 2
26085: PPUSH
26086: LD_VAR 0 11
26090: PPUSH
26091: CALL_OW 1
26095: ST_TO_ADDR
// end ; exit ;
26096: GO 26820
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
26098: LD_EXP 77
26102: PUSH
26103: LD_EXP 76
26107: PUSH
26108: LD_VAR 0 1
26112: ARRAY
26113: ARRAY
26114: NOT
26115: PUSH
26116: LD_EXP 50
26120: PUSH
26121: LD_VAR 0 1
26125: ARRAY
26126: PPUSH
26127: LD_INT 30
26129: PUSH
26130: LD_INT 3
26132: PUSH
26133: EMPTY
26134: LIST
26135: LIST
26136: PPUSH
26137: CALL_OW 72
26141: AND
26142: PUSH
26143: LD_EXP 55
26147: PUSH
26148: LD_VAR 0 1
26152: ARRAY
26153: NOT
26154: AND
26155: IFFALSE 26820
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
26157: LD_ADDR_EXP 92
26161: PUSH
26162: LD_EXP 92
26166: PPUSH
26167: LD_VAR 0 1
26171: PPUSH
26172: LD_INT 6
26174: PPUSH
26175: CALL_OW 1
26179: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
26180: LD_ADDR_VAR 0 2
26184: PUSH
26185: LD_INT 0
26187: PUSH
26188: LD_INT 0
26190: PUSH
26191: LD_INT 0
26193: PUSH
26194: LD_INT 0
26196: PUSH
26197: EMPTY
26198: LIST
26199: LIST
26200: LIST
26201: LIST
26202: ST_TO_ADDR
// if sci >= 1 then
26203: LD_VAR 0 8
26207: PUSH
26208: LD_INT 1
26210: GREATEREQUAL
26211: IFFALSE 26233
// tmp := tmp diff sci [ 1 ] ;
26213: LD_ADDR_VAR 0 4
26217: PUSH
26218: LD_VAR 0 4
26222: PUSH
26223: LD_VAR 0 8
26227: PUSH
26228: LD_INT 1
26230: ARRAY
26231: DIFF
26232: ST_TO_ADDR
// if tmp and not sci then
26233: LD_VAR 0 4
26237: PUSH
26238: LD_VAR 0 8
26242: NOT
26243: AND
26244: IFFALSE 26313
// begin sort := SortBySkill ( tmp , 4 ) ;
26246: LD_ADDR_VAR 0 9
26250: PUSH
26251: LD_VAR 0 4
26255: PPUSH
26256: LD_INT 4
26258: PPUSH
26259: CALL 85378 0 2
26263: ST_TO_ADDR
// if sort then
26264: LD_VAR 0 9
26268: IFFALSE 26284
// p := sort [ 1 ] ;
26270: LD_ADDR_VAR 0 11
26274: PUSH
26275: LD_VAR 0 9
26279: PUSH
26280: LD_INT 1
26282: ARRAY
26283: ST_TO_ADDR
// if p then
26284: LD_VAR 0 11
26288: IFFALSE 26313
// result := Replace ( result , 4 , p ) ;
26290: LD_ADDR_VAR 0 2
26294: PUSH
26295: LD_VAR 0 2
26299: PPUSH
26300: LD_INT 4
26302: PPUSH
26303: LD_VAR 0 11
26307: PPUSH
26308: CALL_OW 1
26312: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
26313: LD_ADDR_VAR 0 4
26317: PUSH
26318: LD_VAR 0 4
26322: PUSH
26323: LD_VAR 0 7
26327: DIFF
26328: ST_TO_ADDR
// if tmp and mech < 6 then
26329: LD_VAR 0 4
26333: PUSH
26334: LD_VAR 0 7
26338: PUSH
26339: LD_INT 6
26341: LESS
26342: AND
26343: IFFALSE 26525
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
26345: LD_ADDR_VAR 0 9
26349: PUSH
26350: LD_VAR 0 4
26354: PUSH
26355: LD_VAR 0 7
26359: DIFF
26360: PPUSH
26361: LD_INT 3
26363: PPUSH
26364: CALL 85378 0 2
26368: ST_TO_ADDR
// p := [ ] ;
26369: LD_ADDR_VAR 0 11
26373: PUSH
26374: EMPTY
26375: ST_TO_ADDR
// if sort then
26376: LD_VAR 0 9
26380: IFFALSE 26496
// for i = 1 to 6 - mech do
26382: LD_ADDR_VAR 0 3
26386: PUSH
26387: DOUBLE
26388: LD_INT 1
26390: DEC
26391: ST_TO_ADDR
26392: LD_INT 6
26394: PUSH
26395: LD_VAR 0 7
26399: MINUS
26400: PUSH
26401: FOR_TO
26402: IFFALSE 26494
// begin if i = sort then
26404: LD_VAR 0 3
26408: PUSH
26409: LD_VAR 0 9
26413: EQUAL
26414: IFFALSE 26418
// break ;
26416: GO 26494
// if GetClass ( i ) = 3 then
26418: LD_VAR 0 3
26422: PPUSH
26423: CALL_OW 257
26427: PUSH
26428: LD_INT 3
26430: EQUAL
26431: IFFALSE 26435
// continue ;
26433: GO 26401
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26435: LD_ADDR_VAR 0 11
26439: PUSH
26440: LD_VAR 0 11
26444: PPUSH
26445: LD_VAR 0 11
26449: PUSH
26450: LD_INT 1
26452: PLUS
26453: PPUSH
26454: LD_VAR 0 9
26458: PUSH
26459: LD_VAR 0 3
26463: ARRAY
26464: PPUSH
26465: CALL_OW 2
26469: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26470: LD_ADDR_VAR 0 4
26474: PUSH
26475: LD_VAR 0 4
26479: PUSH
26480: LD_VAR 0 9
26484: PUSH
26485: LD_VAR 0 3
26489: ARRAY
26490: DIFF
26491: ST_TO_ADDR
// end ;
26492: GO 26401
26494: POP
26495: POP
// if p then
26496: LD_VAR 0 11
26500: IFFALSE 26525
// result := Replace ( result , 3 , p ) ;
26502: LD_ADDR_VAR 0 2
26506: PUSH
26507: LD_VAR 0 2
26511: PPUSH
26512: LD_INT 3
26514: PPUSH
26515: LD_VAR 0 11
26519: PPUSH
26520: CALL_OW 1
26524: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
26525: LD_ADDR_VAR 0 4
26529: PUSH
26530: LD_VAR 0 4
26534: PUSH
26535: LD_VAR 0 6
26539: DIFF
26540: ST_TO_ADDR
// if tmp and eng < 4 then
26541: LD_VAR 0 4
26545: PUSH
26546: LD_VAR 0 6
26550: PUSH
26551: LD_INT 4
26553: LESS
26554: AND
26555: IFFALSE 26745
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
26557: LD_ADDR_VAR 0 9
26561: PUSH
26562: LD_VAR 0 4
26566: PUSH
26567: LD_VAR 0 7
26571: PUSH
26572: LD_VAR 0 6
26576: UNION
26577: DIFF
26578: PPUSH
26579: LD_INT 2
26581: PPUSH
26582: CALL 85378 0 2
26586: ST_TO_ADDR
// p := [ ] ;
26587: LD_ADDR_VAR 0 11
26591: PUSH
26592: EMPTY
26593: ST_TO_ADDR
// if sort then
26594: LD_VAR 0 9
26598: IFFALSE 26714
// for i = 1 to 4 - eng do
26600: LD_ADDR_VAR 0 3
26604: PUSH
26605: DOUBLE
26606: LD_INT 1
26608: DEC
26609: ST_TO_ADDR
26610: LD_INT 4
26612: PUSH
26613: LD_VAR 0 6
26617: MINUS
26618: PUSH
26619: FOR_TO
26620: IFFALSE 26712
// begin if i = sort then
26622: LD_VAR 0 3
26626: PUSH
26627: LD_VAR 0 9
26631: EQUAL
26632: IFFALSE 26636
// break ;
26634: GO 26712
// if GetClass ( i ) = 2 then
26636: LD_VAR 0 3
26640: PPUSH
26641: CALL_OW 257
26645: PUSH
26646: LD_INT 2
26648: EQUAL
26649: IFFALSE 26653
// continue ;
26651: GO 26619
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26653: LD_ADDR_VAR 0 11
26657: PUSH
26658: LD_VAR 0 11
26662: PPUSH
26663: LD_VAR 0 11
26667: PUSH
26668: LD_INT 1
26670: PLUS
26671: PPUSH
26672: LD_VAR 0 9
26676: PUSH
26677: LD_VAR 0 3
26681: ARRAY
26682: PPUSH
26683: CALL_OW 2
26687: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26688: LD_ADDR_VAR 0 4
26692: PUSH
26693: LD_VAR 0 4
26697: PUSH
26698: LD_VAR 0 9
26702: PUSH
26703: LD_VAR 0 3
26707: ARRAY
26708: DIFF
26709: ST_TO_ADDR
// end ;
26710: GO 26619
26712: POP
26713: POP
// if p then
26714: LD_VAR 0 11
26718: IFFALSE 26743
// result := Replace ( result , 2 , p ) ;
26720: LD_ADDR_VAR 0 2
26724: PUSH
26725: LD_VAR 0 2
26729: PPUSH
26730: LD_INT 2
26732: PPUSH
26733: LD_VAR 0 11
26737: PPUSH
26738: CALL_OW 1
26742: ST_TO_ADDR
// end else
26743: GO 26789
// for i = eng downto 5 do
26745: LD_ADDR_VAR 0 3
26749: PUSH
26750: DOUBLE
26751: LD_VAR 0 6
26755: INC
26756: ST_TO_ADDR
26757: LD_INT 5
26759: PUSH
26760: FOR_DOWNTO
26761: IFFALSE 26787
// tmp := tmp union eng [ i ] ;
26763: LD_ADDR_VAR 0 4
26767: PUSH
26768: LD_VAR 0 4
26772: PUSH
26773: LD_VAR 0 6
26777: PUSH
26778: LD_VAR 0 3
26782: ARRAY
26783: UNION
26784: ST_TO_ADDR
26785: GO 26760
26787: POP
26788: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
26789: LD_ADDR_VAR 0 2
26793: PUSH
26794: LD_VAR 0 2
26798: PPUSH
26799: LD_INT 1
26801: PPUSH
26802: LD_VAR 0 4
26806: PUSH
26807: LD_VAR 0 5
26811: DIFF
26812: PPUSH
26813: CALL_OW 1
26817: ST_TO_ADDR
// exit ;
26818: GO 26820
// end ; end ;
26820: LD_VAR 0 2
26824: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
26825: LD_INT 0
26827: PPUSH
26828: PPUSH
26829: PPUSH
// if not mc_bases then
26830: LD_EXP 50
26834: NOT
26835: IFFALSE 26839
// exit ;
26837: GO 26981
// for i = 1 to mc_bases do
26839: LD_ADDR_VAR 0 2
26843: PUSH
26844: DOUBLE
26845: LD_INT 1
26847: DEC
26848: ST_TO_ADDR
26849: LD_EXP 50
26853: PUSH
26854: FOR_TO
26855: IFFALSE 26972
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
26857: LD_ADDR_VAR 0 3
26861: PUSH
26862: LD_EXP 50
26866: PUSH
26867: LD_VAR 0 2
26871: ARRAY
26872: PPUSH
26873: LD_INT 21
26875: PUSH
26876: LD_INT 3
26878: PUSH
26879: EMPTY
26880: LIST
26881: LIST
26882: PUSH
26883: LD_INT 3
26885: PUSH
26886: LD_INT 2
26888: PUSH
26889: LD_INT 30
26891: PUSH
26892: LD_INT 29
26894: PUSH
26895: EMPTY
26896: LIST
26897: LIST
26898: PUSH
26899: LD_INT 30
26901: PUSH
26902: LD_INT 30
26904: PUSH
26905: EMPTY
26906: LIST
26907: LIST
26908: PUSH
26909: EMPTY
26910: LIST
26911: LIST
26912: LIST
26913: PUSH
26914: EMPTY
26915: LIST
26916: LIST
26917: PUSH
26918: LD_INT 3
26920: PUSH
26921: LD_INT 24
26923: PUSH
26924: LD_INT 1000
26926: PUSH
26927: EMPTY
26928: LIST
26929: LIST
26930: PUSH
26931: EMPTY
26932: LIST
26933: LIST
26934: PUSH
26935: EMPTY
26936: LIST
26937: LIST
26938: LIST
26939: PPUSH
26940: CALL_OW 72
26944: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
26945: LD_ADDR_EXP 51
26949: PUSH
26950: LD_EXP 51
26954: PPUSH
26955: LD_VAR 0 2
26959: PPUSH
26960: LD_VAR 0 3
26964: PPUSH
26965: CALL_OW 1
26969: ST_TO_ADDR
// end ;
26970: GO 26854
26972: POP
26973: POP
// RaiseSailEvent ( 101 ) ;
26974: LD_INT 101
26976: PPUSH
26977: CALL_OW 427
// end ;
26981: LD_VAR 0 1
26985: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
26986: LD_INT 0
26988: PPUSH
26989: PPUSH
26990: PPUSH
26991: PPUSH
26992: PPUSH
26993: PPUSH
26994: PPUSH
// if not mc_bases then
26995: LD_EXP 50
26999: NOT
27000: IFFALSE 27004
// exit ;
27002: GO 27566
// for i = 1 to mc_bases do
27004: LD_ADDR_VAR 0 2
27008: PUSH
27009: DOUBLE
27010: LD_INT 1
27012: DEC
27013: ST_TO_ADDR
27014: LD_EXP 50
27018: PUSH
27019: FOR_TO
27020: IFFALSE 27557
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
27022: LD_ADDR_VAR 0 5
27026: PUSH
27027: LD_EXP 50
27031: PUSH
27032: LD_VAR 0 2
27036: ARRAY
27037: PUSH
27038: LD_EXP 79
27042: PUSH
27043: LD_VAR 0 2
27047: ARRAY
27048: UNION
27049: PPUSH
27050: LD_INT 21
27052: PUSH
27053: LD_INT 1
27055: PUSH
27056: EMPTY
27057: LIST
27058: LIST
27059: PUSH
27060: LD_INT 1
27062: PUSH
27063: LD_INT 3
27065: PUSH
27066: LD_INT 54
27068: PUSH
27069: EMPTY
27070: LIST
27071: PUSH
27072: EMPTY
27073: LIST
27074: LIST
27075: PUSH
27076: LD_INT 3
27078: PUSH
27079: LD_INT 24
27081: PUSH
27082: LD_INT 1000
27084: PUSH
27085: EMPTY
27086: LIST
27087: LIST
27088: PUSH
27089: EMPTY
27090: LIST
27091: LIST
27092: PUSH
27093: EMPTY
27094: LIST
27095: LIST
27096: LIST
27097: PUSH
27098: EMPTY
27099: LIST
27100: LIST
27101: PPUSH
27102: CALL_OW 72
27106: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
27107: LD_ADDR_VAR 0 6
27111: PUSH
27112: LD_EXP 50
27116: PUSH
27117: LD_VAR 0 2
27121: ARRAY
27122: PPUSH
27123: LD_INT 21
27125: PUSH
27126: LD_INT 1
27128: PUSH
27129: EMPTY
27130: LIST
27131: LIST
27132: PUSH
27133: LD_INT 1
27135: PUSH
27136: LD_INT 3
27138: PUSH
27139: LD_INT 54
27141: PUSH
27142: EMPTY
27143: LIST
27144: PUSH
27145: EMPTY
27146: LIST
27147: LIST
27148: PUSH
27149: LD_INT 3
27151: PUSH
27152: LD_INT 24
27154: PUSH
27155: LD_INT 250
27157: PUSH
27158: EMPTY
27159: LIST
27160: LIST
27161: PUSH
27162: EMPTY
27163: LIST
27164: LIST
27165: PUSH
27166: EMPTY
27167: LIST
27168: LIST
27169: LIST
27170: PUSH
27171: EMPTY
27172: LIST
27173: LIST
27174: PPUSH
27175: CALL_OW 72
27179: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
27180: LD_ADDR_VAR 0 7
27184: PUSH
27185: LD_VAR 0 5
27189: PUSH
27190: LD_VAR 0 6
27194: DIFF
27195: ST_TO_ADDR
// if not need_heal_1 then
27196: LD_VAR 0 6
27200: NOT
27201: IFFALSE 27234
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
27203: LD_ADDR_EXP 53
27207: PUSH
27208: LD_EXP 53
27212: PPUSH
27213: LD_VAR 0 2
27217: PUSH
27218: LD_INT 1
27220: PUSH
27221: EMPTY
27222: LIST
27223: LIST
27224: PPUSH
27225: EMPTY
27226: PPUSH
27227: CALL 54145 0 3
27231: ST_TO_ADDR
27232: GO 27304
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
27234: LD_ADDR_EXP 53
27238: PUSH
27239: LD_EXP 53
27243: PPUSH
27244: LD_VAR 0 2
27248: PUSH
27249: LD_INT 1
27251: PUSH
27252: EMPTY
27253: LIST
27254: LIST
27255: PPUSH
27256: LD_EXP 53
27260: PUSH
27261: LD_VAR 0 2
27265: ARRAY
27266: PUSH
27267: LD_INT 1
27269: ARRAY
27270: PPUSH
27271: LD_INT 3
27273: PUSH
27274: LD_INT 24
27276: PUSH
27277: LD_INT 1000
27279: PUSH
27280: EMPTY
27281: LIST
27282: LIST
27283: PUSH
27284: EMPTY
27285: LIST
27286: LIST
27287: PPUSH
27288: CALL_OW 72
27292: PUSH
27293: LD_VAR 0 6
27297: UNION
27298: PPUSH
27299: CALL 54145 0 3
27303: ST_TO_ADDR
// if not need_heal_2 then
27304: LD_VAR 0 7
27308: NOT
27309: IFFALSE 27342
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
27311: LD_ADDR_EXP 53
27315: PUSH
27316: LD_EXP 53
27320: PPUSH
27321: LD_VAR 0 2
27325: PUSH
27326: LD_INT 2
27328: PUSH
27329: EMPTY
27330: LIST
27331: LIST
27332: PPUSH
27333: EMPTY
27334: PPUSH
27335: CALL 54145 0 3
27339: ST_TO_ADDR
27340: GO 27374
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
27342: LD_ADDR_EXP 53
27346: PUSH
27347: LD_EXP 53
27351: PPUSH
27352: LD_VAR 0 2
27356: PUSH
27357: LD_INT 2
27359: PUSH
27360: EMPTY
27361: LIST
27362: LIST
27363: PPUSH
27364: LD_VAR 0 7
27368: PPUSH
27369: CALL 54145 0 3
27373: ST_TO_ADDR
// if need_heal_2 then
27374: LD_VAR 0 7
27378: IFFALSE 27539
// for j in need_heal_2 do
27380: LD_ADDR_VAR 0 3
27384: PUSH
27385: LD_VAR 0 7
27389: PUSH
27390: FOR_IN
27391: IFFALSE 27537
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
27393: LD_ADDR_VAR 0 5
27397: PUSH
27398: LD_EXP 50
27402: PUSH
27403: LD_VAR 0 2
27407: ARRAY
27408: PPUSH
27409: LD_INT 2
27411: PUSH
27412: LD_INT 30
27414: PUSH
27415: LD_INT 6
27417: PUSH
27418: EMPTY
27419: LIST
27420: LIST
27421: PUSH
27422: LD_INT 30
27424: PUSH
27425: LD_INT 7
27427: PUSH
27428: EMPTY
27429: LIST
27430: LIST
27431: PUSH
27432: LD_INT 30
27434: PUSH
27435: LD_INT 8
27437: PUSH
27438: EMPTY
27439: LIST
27440: LIST
27441: PUSH
27442: LD_INT 30
27444: PUSH
27445: LD_INT 0
27447: PUSH
27448: EMPTY
27449: LIST
27450: LIST
27451: PUSH
27452: LD_INT 30
27454: PUSH
27455: LD_INT 1
27457: PUSH
27458: EMPTY
27459: LIST
27460: LIST
27461: PUSH
27462: EMPTY
27463: LIST
27464: LIST
27465: LIST
27466: LIST
27467: LIST
27468: LIST
27469: PPUSH
27470: CALL_OW 72
27474: ST_TO_ADDR
// if tmp then
27475: LD_VAR 0 5
27479: IFFALSE 27535
// begin k := NearestUnitToUnit ( tmp , j ) ;
27481: LD_ADDR_VAR 0 4
27485: PUSH
27486: LD_VAR 0 5
27490: PPUSH
27491: LD_VAR 0 3
27495: PPUSH
27496: CALL_OW 74
27500: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
27501: LD_VAR 0 3
27505: PPUSH
27506: LD_VAR 0 4
27510: PPUSH
27511: CALL_OW 296
27515: PUSH
27516: LD_INT 5
27518: GREATER
27519: IFFALSE 27535
// ComMoveToNearbyEntrance ( j , k ) ;
27521: LD_VAR 0 3
27525: PPUSH
27526: LD_VAR 0 4
27530: PPUSH
27531: CALL 87751 0 2
// end ; end ;
27535: GO 27390
27537: POP
27538: POP
// if not need_heal_1 and not need_heal_2 then
27539: LD_VAR 0 6
27543: NOT
27544: PUSH
27545: LD_VAR 0 7
27549: NOT
27550: AND
27551: IFFALSE 27555
// continue ;
27553: GO 27019
// end ;
27555: GO 27019
27557: POP
27558: POP
// RaiseSailEvent ( 102 ) ;
27559: LD_INT 102
27561: PPUSH
27562: CALL_OW 427
// end ;
27566: LD_VAR 0 1
27570: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
27571: LD_INT 0
27573: PPUSH
27574: PPUSH
27575: PPUSH
27576: PPUSH
27577: PPUSH
27578: PPUSH
27579: PPUSH
27580: PPUSH
// if not mc_bases then
27581: LD_EXP 50
27585: NOT
27586: IFFALSE 27590
// exit ;
27588: GO 28501
// for i = 1 to mc_bases do
27590: LD_ADDR_VAR 0 2
27594: PUSH
27595: DOUBLE
27596: LD_INT 1
27598: DEC
27599: ST_TO_ADDR
27600: LD_EXP 50
27604: PUSH
27605: FOR_TO
27606: IFFALSE 28499
// begin if not mc_building_need_repair [ i ] then
27608: LD_EXP 51
27612: PUSH
27613: LD_VAR 0 2
27617: ARRAY
27618: NOT
27619: IFFALSE 27804
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
27621: LD_ADDR_VAR 0 6
27625: PUSH
27626: LD_EXP 69
27630: PUSH
27631: LD_VAR 0 2
27635: ARRAY
27636: PPUSH
27637: LD_INT 3
27639: PUSH
27640: LD_INT 24
27642: PUSH
27643: LD_INT 1000
27645: PUSH
27646: EMPTY
27647: LIST
27648: LIST
27649: PUSH
27650: EMPTY
27651: LIST
27652: LIST
27653: PUSH
27654: LD_INT 2
27656: PUSH
27657: LD_INT 34
27659: PUSH
27660: LD_INT 13
27662: PUSH
27663: EMPTY
27664: LIST
27665: LIST
27666: PUSH
27667: LD_INT 34
27669: PUSH
27670: LD_INT 52
27672: PUSH
27673: EMPTY
27674: LIST
27675: LIST
27676: PUSH
27677: LD_INT 34
27679: PUSH
27680: LD_INT 88
27682: PUSH
27683: EMPTY
27684: LIST
27685: LIST
27686: PUSH
27687: EMPTY
27688: LIST
27689: LIST
27690: LIST
27691: LIST
27692: PUSH
27693: EMPTY
27694: LIST
27695: LIST
27696: PPUSH
27697: CALL_OW 72
27701: ST_TO_ADDR
// if cranes then
27702: LD_VAR 0 6
27706: IFFALSE 27768
// for j in cranes do
27708: LD_ADDR_VAR 0 3
27712: PUSH
27713: LD_VAR 0 6
27717: PUSH
27718: FOR_IN
27719: IFFALSE 27766
// if not IsInArea ( j , mc_parking [ i ] ) then
27721: LD_VAR 0 3
27725: PPUSH
27726: LD_EXP 74
27730: PUSH
27731: LD_VAR 0 2
27735: ARRAY
27736: PPUSH
27737: CALL_OW 308
27741: NOT
27742: IFFALSE 27764
// ComMoveToArea ( j , mc_parking [ i ] ) ;
27744: LD_VAR 0 3
27748: PPUSH
27749: LD_EXP 74
27753: PUSH
27754: LD_VAR 0 2
27758: ARRAY
27759: PPUSH
27760: CALL_OW 113
27764: GO 27718
27766: POP
27767: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
27768: LD_ADDR_EXP 52
27772: PUSH
27773: LD_EXP 52
27777: PPUSH
27778: LD_VAR 0 2
27782: PPUSH
27783: EMPTY
27784: PPUSH
27785: CALL_OW 1
27789: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
27790: LD_VAR 0 2
27794: PPUSH
27795: LD_INT 101
27797: PPUSH
27798: CALL 22644 0 2
// continue ;
27802: GO 27605
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
27804: LD_ADDR_EXP 56
27808: PUSH
27809: LD_EXP 56
27813: PPUSH
27814: LD_VAR 0 2
27818: PPUSH
27819: EMPTY
27820: PPUSH
27821: CALL_OW 1
27825: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
27826: LD_VAR 0 2
27830: PPUSH
27831: LD_INT 103
27833: PPUSH
27834: CALL 22644 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
27838: LD_ADDR_VAR 0 5
27842: PUSH
27843: LD_EXP 50
27847: PUSH
27848: LD_VAR 0 2
27852: ARRAY
27853: PUSH
27854: LD_EXP 79
27858: PUSH
27859: LD_VAR 0 2
27863: ARRAY
27864: UNION
27865: PPUSH
27866: LD_INT 2
27868: PUSH
27869: LD_INT 25
27871: PUSH
27872: LD_INT 2
27874: PUSH
27875: EMPTY
27876: LIST
27877: LIST
27878: PUSH
27879: LD_INT 25
27881: PUSH
27882: LD_INT 16
27884: PUSH
27885: EMPTY
27886: LIST
27887: LIST
27888: PUSH
27889: EMPTY
27890: LIST
27891: LIST
27892: LIST
27893: PUSH
27894: EMPTY
27895: LIST
27896: PPUSH
27897: CALL_OW 72
27901: ST_TO_ADDR
// if mc_need_heal [ i ] then
27902: LD_EXP 53
27906: PUSH
27907: LD_VAR 0 2
27911: ARRAY
27912: IFFALSE 27956
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
27914: LD_ADDR_VAR 0 5
27918: PUSH
27919: LD_VAR 0 5
27923: PUSH
27924: LD_EXP 53
27928: PUSH
27929: LD_VAR 0 2
27933: ARRAY
27934: PUSH
27935: LD_INT 1
27937: ARRAY
27938: PUSH
27939: LD_EXP 53
27943: PUSH
27944: LD_VAR 0 2
27948: ARRAY
27949: PUSH
27950: LD_INT 2
27952: ARRAY
27953: UNION
27954: DIFF
27955: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
27956: LD_ADDR_VAR 0 6
27960: PUSH
27961: LD_EXP 69
27965: PUSH
27966: LD_VAR 0 2
27970: ARRAY
27971: PPUSH
27972: LD_INT 2
27974: PUSH
27975: LD_INT 34
27977: PUSH
27978: LD_INT 13
27980: PUSH
27981: EMPTY
27982: LIST
27983: LIST
27984: PUSH
27985: LD_INT 34
27987: PUSH
27988: LD_INT 52
27990: PUSH
27991: EMPTY
27992: LIST
27993: LIST
27994: PUSH
27995: LD_INT 34
27997: PUSH
27998: LD_INT 88
28000: PUSH
28001: EMPTY
28002: LIST
28003: LIST
28004: PUSH
28005: EMPTY
28006: LIST
28007: LIST
28008: LIST
28009: LIST
28010: PPUSH
28011: CALL_OW 72
28015: ST_TO_ADDR
// if cranes then
28016: LD_VAR 0 6
28020: IFFALSE 28188
// begin for j in cranes do
28022: LD_ADDR_VAR 0 3
28026: PUSH
28027: LD_VAR 0 6
28031: PUSH
28032: FOR_IN
28033: IFFALSE 28186
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
28035: LD_VAR 0 3
28039: PPUSH
28040: CALL_OW 256
28044: PUSH
28045: LD_INT 1000
28047: EQUAL
28048: PUSH
28049: LD_VAR 0 3
28053: PPUSH
28054: CALL_OW 314
28058: NOT
28059: AND
28060: IFFALSE 28126
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
28062: LD_ADDR_VAR 0 8
28066: PUSH
28067: LD_EXP 51
28071: PUSH
28072: LD_VAR 0 2
28076: ARRAY
28077: PPUSH
28078: LD_VAR 0 3
28082: PPUSH
28083: CALL_OW 74
28087: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
28088: LD_VAR 0 8
28092: PPUSH
28093: LD_INT 16
28095: PPUSH
28096: CALL 57110 0 2
28100: PUSH
28101: LD_INT 4
28103: ARRAY
28104: PUSH
28105: LD_INT 10
28107: LESS
28108: IFFALSE 28124
// ComRepairBuilding ( j , to_repair ) ;
28110: LD_VAR 0 3
28114: PPUSH
28115: LD_VAR 0 8
28119: PPUSH
28120: CALL_OW 130
// end else
28124: GO 28184
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
28126: LD_VAR 0 3
28130: PPUSH
28131: CALL_OW 256
28135: PUSH
28136: LD_INT 500
28138: LESS
28139: PUSH
28140: LD_VAR 0 3
28144: PPUSH
28145: LD_EXP 74
28149: PUSH
28150: LD_VAR 0 2
28154: ARRAY
28155: PPUSH
28156: CALL_OW 308
28160: NOT
28161: AND
28162: IFFALSE 28184
// ComMoveToArea ( j , mc_parking [ i ] ) ;
28164: LD_VAR 0 3
28168: PPUSH
28169: LD_EXP 74
28173: PUSH
28174: LD_VAR 0 2
28178: ARRAY
28179: PPUSH
28180: CALL_OW 113
// end ;
28184: GO 28032
28186: POP
28187: POP
// end ; if tmp > 3 then
28188: LD_VAR 0 5
28192: PUSH
28193: LD_INT 3
28195: GREATER
28196: IFFALSE 28216
// tmp := ShrinkArray ( tmp , 4 ) ;
28198: LD_ADDR_VAR 0 5
28202: PUSH
28203: LD_VAR 0 5
28207: PPUSH
28208: LD_INT 4
28210: PPUSH
28211: CALL 87189 0 2
28215: ST_TO_ADDR
// if not tmp then
28216: LD_VAR 0 5
28220: NOT
28221: IFFALSE 28225
// continue ;
28223: GO 27605
// for j in tmp do
28225: LD_ADDR_VAR 0 3
28229: PUSH
28230: LD_VAR 0 5
28234: PUSH
28235: FOR_IN
28236: IFFALSE 28495
// begin if IsInUnit ( j ) then
28238: LD_VAR 0 3
28242: PPUSH
28243: CALL_OW 310
28247: IFFALSE 28258
// ComExitBuilding ( j ) ;
28249: LD_VAR 0 3
28253: PPUSH
28254: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
28258: LD_VAR 0 3
28262: PUSH
28263: LD_EXP 52
28267: PUSH
28268: LD_VAR 0 2
28272: ARRAY
28273: IN
28274: NOT
28275: IFFALSE 28333
// begin SetTag ( j , 101 ) ;
28277: LD_VAR 0 3
28281: PPUSH
28282: LD_INT 101
28284: PPUSH
28285: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
28289: LD_ADDR_EXP 52
28293: PUSH
28294: LD_EXP 52
28298: PPUSH
28299: LD_VAR 0 2
28303: PUSH
28304: LD_EXP 52
28308: PUSH
28309: LD_VAR 0 2
28313: ARRAY
28314: PUSH
28315: LD_INT 1
28317: PLUS
28318: PUSH
28319: EMPTY
28320: LIST
28321: LIST
28322: PPUSH
28323: LD_VAR 0 3
28327: PPUSH
28328: CALL 54145 0 3
28332: ST_TO_ADDR
// end ; wait ( 1 ) ;
28333: LD_INT 1
28335: PPUSH
28336: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
28340: LD_ADDR_VAR 0 7
28344: PUSH
28345: LD_EXP 51
28349: PUSH
28350: LD_VAR 0 2
28354: ARRAY
28355: ST_TO_ADDR
// if mc_scan [ i ] then
28356: LD_EXP 73
28360: PUSH
28361: LD_VAR 0 2
28365: ARRAY
28366: IFFALSE 28428
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
28368: LD_ADDR_VAR 0 7
28372: PUSH
28373: LD_EXP 51
28377: PUSH
28378: LD_VAR 0 2
28382: ARRAY
28383: PPUSH
28384: LD_INT 3
28386: PUSH
28387: LD_INT 30
28389: PUSH
28390: LD_INT 32
28392: PUSH
28393: EMPTY
28394: LIST
28395: LIST
28396: PUSH
28397: LD_INT 30
28399: PUSH
28400: LD_INT 33
28402: PUSH
28403: EMPTY
28404: LIST
28405: LIST
28406: PUSH
28407: LD_INT 30
28409: PUSH
28410: LD_INT 31
28412: PUSH
28413: EMPTY
28414: LIST
28415: LIST
28416: PUSH
28417: EMPTY
28418: LIST
28419: LIST
28420: LIST
28421: LIST
28422: PPUSH
28423: CALL_OW 72
28427: ST_TO_ADDR
// if not to_repair_tmp then
28428: LD_VAR 0 7
28432: NOT
28433: IFFALSE 28437
// continue ;
28435: GO 28235
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
28437: LD_ADDR_VAR 0 8
28441: PUSH
28442: LD_VAR 0 7
28446: PPUSH
28447: LD_VAR 0 3
28451: PPUSH
28452: CALL_OW 74
28456: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
28457: LD_VAR 0 8
28461: PPUSH
28462: LD_INT 16
28464: PPUSH
28465: CALL 57110 0 2
28469: PUSH
28470: LD_INT 4
28472: ARRAY
28473: PUSH
28474: LD_INT 14
28476: LESS
28477: IFFALSE 28493
// ComRepairBuilding ( j , to_repair ) ;
28479: LD_VAR 0 3
28483: PPUSH
28484: LD_VAR 0 8
28488: PPUSH
28489: CALL_OW 130
// end ;
28493: GO 28235
28495: POP
28496: POP
// end ;
28497: GO 27605
28499: POP
28500: POP
// end ;
28501: LD_VAR 0 1
28505: RET
// export function MC_Heal ; var i , j , tmp ; begin
28506: LD_INT 0
28508: PPUSH
28509: PPUSH
28510: PPUSH
28511: PPUSH
// if not mc_bases then
28512: LD_EXP 50
28516: NOT
28517: IFFALSE 28521
// exit ;
28519: GO 28923
// for i = 1 to mc_bases do
28521: LD_ADDR_VAR 0 2
28525: PUSH
28526: DOUBLE
28527: LD_INT 1
28529: DEC
28530: ST_TO_ADDR
28531: LD_EXP 50
28535: PUSH
28536: FOR_TO
28537: IFFALSE 28921
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
28539: LD_EXP 53
28543: PUSH
28544: LD_VAR 0 2
28548: ARRAY
28549: PUSH
28550: LD_INT 1
28552: ARRAY
28553: NOT
28554: PUSH
28555: LD_EXP 53
28559: PUSH
28560: LD_VAR 0 2
28564: ARRAY
28565: PUSH
28566: LD_INT 2
28568: ARRAY
28569: NOT
28570: AND
28571: IFFALSE 28609
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
28573: LD_ADDR_EXP 54
28577: PUSH
28578: LD_EXP 54
28582: PPUSH
28583: LD_VAR 0 2
28587: PPUSH
28588: EMPTY
28589: PPUSH
28590: CALL_OW 1
28594: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
28595: LD_VAR 0 2
28599: PPUSH
28600: LD_INT 102
28602: PPUSH
28603: CALL 22644 0 2
// continue ;
28607: GO 28536
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
28609: LD_ADDR_VAR 0 4
28613: PUSH
28614: LD_EXP 50
28618: PUSH
28619: LD_VAR 0 2
28623: ARRAY
28624: PPUSH
28625: LD_INT 25
28627: PUSH
28628: LD_INT 4
28630: PUSH
28631: EMPTY
28632: LIST
28633: LIST
28634: PPUSH
28635: CALL_OW 72
28639: ST_TO_ADDR
// if not tmp then
28640: LD_VAR 0 4
28644: NOT
28645: IFFALSE 28649
// continue ;
28647: GO 28536
// if mc_taming [ i ] then
28649: LD_EXP 81
28653: PUSH
28654: LD_VAR 0 2
28658: ARRAY
28659: IFFALSE 28683
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
28661: LD_ADDR_EXP 81
28665: PUSH
28666: LD_EXP 81
28670: PPUSH
28671: LD_VAR 0 2
28675: PPUSH
28676: EMPTY
28677: PPUSH
28678: CALL_OW 1
28682: ST_TO_ADDR
// for j in tmp do
28683: LD_ADDR_VAR 0 3
28687: PUSH
28688: LD_VAR 0 4
28692: PUSH
28693: FOR_IN
28694: IFFALSE 28917
// begin if IsInUnit ( j ) then
28696: LD_VAR 0 3
28700: PPUSH
28701: CALL_OW 310
28705: IFFALSE 28716
// ComExitBuilding ( j ) ;
28707: LD_VAR 0 3
28711: PPUSH
28712: CALL_OW 122
// if not j in mc_healers [ i ] then
28716: LD_VAR 0 3
28720: PUSH
28721: LD_EXP 54
28725: PUSH
28726: LD_VAR 0 2
28730: ARRAY
28731: IN
28732: NOT
28733: IFFALSE 28779
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
28735: LD_ADDR_EXP 54
28739: PUSH
28740: LD_EXP 54
28744: PPUSH
28745: LD_VAR 0 2
28749: PUSH
28750: LD_EXP 54
28754: PUSH
28755: LD_VAR 0 2
28759: ARRAY
28760: PUSH
28761: LD_INT 1
28763: PLUS
28764: PUSH
28765: EMPTY
28766: LIST
28767: LIST
28768: PPUSH
28769: LD_VAR 0 3
28773: PPUSH
28774: CALL 54145 0 3
28778: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
28779: LD_VAR 0 3
28783: PPUSH
28784: CALL_OW 110
28788: PUSH
28789: LD_INT 102
28791: NONEQUAL
28792: IFFALSE 28806
// SetTag ( j , 102 ) ;
28794: LD_VAR 0 3
28798: PPUSH
28799: LD_INT 102
28801: PPUSH
28802: CALL_OW 109
// Wait ( 3 ) ;
28806: LD_INT 3
28808: PPUSH
28809: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
28813: LD_EXP 53
28817: PUSH
28818: LD_VAR 0 2
28822: ARRAY
28823: PUSH
28824: LD_INT 1
28826: ARRAY
28827: IFFALSE 28859
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
28829: LD_VAR 0 3
28833: PPUSH
28834: LD_EXP 53
28838: PUSH
28839: LD_VAR 0 2
28843: ARRAY
28844: PUSH
28845: LD_INT 1
28847: ARRAY
28848: PUSH
28849: LD_INT 1
28851: ARRAY
28852: PPUSH
28853: CALL_OW 128
28857: GO 28915
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
28859: LD_VAR 0 3
28863: PPUSH
28864: CALL_OW 314
28868: NOT
28869: PUSH
28870: LD_EXP 53
28874: PUSH
28875: LD_VAR 0 2
28879: ARRAY
28880: PUSH
28881: LD_INT 2
28883: ARRAY
28884: AND
28885: IFFALSE 28915
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
28887: LD_VAR 0 3
28891: PPUSH
28892: LD_EXP 53
28896: PUSH
28897: LD_VAR 0 2
28901: ARRAY
28902: PUSH
28903: LD_INT 2
28905: ARRAY
28906: PUSH
28907: LD_INT 1
28909: ARRAY
28910: PPUSH
28911: CALL_OW 128
// end ;
28915: GO 28693
28917: POP
28918: POP
// end ;
28919: GO 28536
28921: POP
28922: POP
// end ;
28923: LD_VAR 0 1
28927: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
28928: LD_INT 0
28930: PPUSH
28931: PPUSH
28932: PPUSH
28933: PPUSH
28934: PPUSH
28935: PPUSH
// if not mc_bases then
28936: LD_EXP 50
28940: NOT
28941: IFFALSE 28945
// exit ;
28943: GO 30108
// for i = 1 to mc_bases do
28945: LD_ADDR_VAR 0 2
28949: PUSH
28950: DOUBLE
28951: LD_INT 1
28953: DEC
28954: ST_TO_ADDR
28955: LD_EXP 50
28959: PUSH
28960: FOR_TO
28961: IFFALSE 30106
// begin if mc_scan [ i ] then
28963: LD_EXP 73
28967: PUSH
28968: LD_VAR 0 2
28972: ARRAY
28973: IFFALSE 28977
// continue ;
28975: GO 28960
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
28977: LD_EXP 55
28981: PUSH
28982: LD_VAR 0 2
28986: ARRAY
28987: NOT
28988: PUSH
28989: LD_EXP 57
28993: PUSH
28994: LD_VAR 0 2
28998: ARRAY
28999: NOT
29000: AND
29001: PUSH
29002: LD_EXP 56
29006: PUSH
29007: LD_VAR 0 2
29011: ARRAY
29012: AND
29013: IFFALSE 29051
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
29015: LD_ADDR_EXP 56
29019: PUSH
29020: LD_EXP 56
29024: PPUSH
29025: LD_VAR 0 2
29029: PPUSH
29030: EMPTY
29031: PPUSH
29032: CALL_OW 1
29036: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
29037: LD_VAR 0 2
29041: PPUSH
29042: LD_INT 103
29044: PPUSH
29045: CALL 22644 0 2
// continue ;
29049: GO 28960
// end ; if mc_construct_list [ i ] then
29051: LD_EXP 57
29055: PUSH
29056: LD_VAR 0 2
29060: ARRAY
29061: IFFALSE 29281
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
29063: LD_ADDR_VAR 0 5
29067: PUSH
29068: LD_EXP 50
29072: PUSH
29073: LD_VAR 0 2
29077: ARRAY
29078: PPUSH
29079: LD_INT 25
29081: PUSH
29082: LD_INT 2
29084: PUSH
29085: EMPTY
29086: LIST
29087: LIST
29088: PPUSH
29089: CALL_OW 72
29093: PUSH
29094: LD_EXP 52
29098: PUSH
29099: LD_VAR 0 2
29103: ARRAY
29104: DIFF
29105: ST_TO_ADDR
// if not tmp then
29106: LD_VAR 0 5
29110: NOT
29111: IFFALSE 29115
// continue ;
29113: GO 28960
// for j in tmp do
29115: LD_ADDR_VAR 0 3
29119: PUSH
29120: LD_VAR 0 5
29124: PUSH
29125: FOR_IN
29126: IFFALSE 29277
// begin if not mc_builders [ i ] then
29128: LD_EXP 56
29132: PUSH
29133: LD_VAR 0 2
29137: ARRAY
29138: NOT
29139: IFFALSE 29197
// begin SetTag ( j , 103 ) ;
29141: LD_VAR 0 3
29145: PPUSH
29146: LD_INT 103
29148: PPUSH
29149: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
29153: LD_ADDR_EXP 56
29157: PUSH
29158: LD_EXP 56
29162: PPUSH
29163: LD_VAR 0 2
29167: PUSH
29168: LD_EXP 56
29172: PUSH
29173: LD_VAR 0 2
29177: ARRAY
29178: PUSH
29179: LD_INT 1
29181: PLUS
29182: PUSH
29183: EMPTY
29184: LIST
29185: LIST
29186: PPUSH
29187: LD_VAR 0 3
29191: PPUSH
29192: CALL 54145 0 3
29196: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
29197: LD_VAR 0 3
29201: PPUSH
29202: CALL_OW 310
29206: IFFALSE 29217
// ComExitBuilding ( j ) ;
29208: LD_VAR 0 3
29212: PPUSH
29213: CALL_OW 122
// wait ( 3 ) ;
29217: LD_INT 3
29219: PPUSH
29220: CALL_OW 67
// if not mc_construct_list [ i ] then
29224: LD_EXP 57
29228: PUSH
29229: LD_VAR 0 2
29233: ARRAY
29234: NOT
29235: IFFALSE 29239
// break ;
29237: GO 29277
// if not HasTask ( j ) then
29239: LD_VAR 0 3
29243: PPUSH
29244: CALL_OW 314
29248: NOT
29249: IFFALSE 29275
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
29251: LD_VAR 0 3
29255: PPUSH
29256: LD_EXP 57
29260: PUSH
29261: LD_VAR 0 2
29265: ARRAY
29266: PUSH
29267: LD_INT 1
29269: ARRAY
29270: PPUSH
29271: CALL 57383 0 2
// end ;
29275: GO 29125
29277: POP
29278: POP
// end else
29279: GO 30104
// if mc_build_list [ i ] then
29281: LD_EXP 55
29285: PUSH
29286: LD_VAR 0 2
29290: ARRAY
29291: IFFALSE 30104
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
29293: LD_EXP 55
29297: PUSH
29298: LD_VAR 0 2
29302: ARRAY
29303: PUSH
29304: LD_INT 1
29306: ARRAY
29307: PUSH
29308: LD_INT 1
29310: ARRAY
29311: PPUSH
29312: CALL 57207 0 1
29316: PUSH
29317: LD_EXP 50
29321: PUSH
29322: LD_VAR 0 2
29326: ARRAY
29327: PPUSH
29328: LD_INT 2
29330: PUSH
29331: LD_INT 30
29333: PUSH
29334: LD_INT 2
29336: PUSH
29337: EMPTY
29338: LIST
29339: LIST
29340: PUSH
29341: LD_INT 30
29343: PUSH
29344: LD_INT 3
29346: PUSH
29347: EMPTY
29348: LIST
29349: LIST
29350: PUSH
29351: EMPTY
29352: LIST
29353: LIST
29354: LIST
29355: PPUSH
29356: CALL_OW 72
29360: NOT
29361: AND
29362: IFFALSE 29467
// begin for j = 1 to mc_build_list [ i ] do
29364: LD_ADDR_VAR 0 3
29368: PUSH
29369: DOUBLE
29370: LD_INT 1
29372: DEC
29373: ST_TO_ADDR
29374: LD_EXP 55
29378: PUSH
29379: LD_VAR 0 2
29383: ARRAY
29384: PUSH
29385: FOR_TO
29386: IFFALSE 29465
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
29388: LD_EXP 55
29392: PUSH
29393: LD_VAR 0 2
29397: ARRAY
29398: PUSH
29399: LD_VAR 0 3
29403: ARRAY
29404: PUSH
29405: LD_INT 1
29407: ARRAY
29408: PUSH
29409: LD_INT 2
29411: EQUAL
29412: IFFALSE 29463
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
29414: LD_ADDR_EXP 55
29418: PUSH
29419: LD_EXP 55
29423: PPUSH
29424: LD_VAR 0 2
29428: PPUSH
29429: LD_EXP 55
29433: PUSH
29434: LD_VAR 0 2
29438: ARRAY
29439: PPUSH
29440: LD_VAR 0 3
29444: PPUSH
29445: LD_INT 1
29447: PPUSH
29448: LD_INT 0
29450: PPUSH
29451: CALL 53563 0 4
29455: PPUSH
29456: CALL_OW 1
29460: ST_TO_ADDR
// break ;
29461: GO 29465
// end ;
29463: GO 29385
29465: POP
29466: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
29467: LD_ADDR_VAR 0 6
29471: PUSH
29472: LD_EXP 50
29476: PUSH
29477: LD_VAR 0 2
29481: ARRAY
29482: PPUSH
29483: LD_INT 2
29485: PUSH
29486: LD_INT 30
29488: PUSH
29489: LD_INT 0
29491: PUSH
29492: EMPTY
29493: LIST
29494: LIST
29495: PUSH
29496: LD_INT 30
29498: PUSH
29499: LD_INT 1
29501: PUSH
29502: EMPTY
29503: LIST
29504: LIST
29505: PUSH
29506: EMPTY
29507: LIST
29508: LIST
29509: LIST
29510: PPUSH
29511: CALL_OW 72
29515: ST_TO_ADDR
// for k := 1 to depot do
29516: LD_ADDR_VAR 0 4
29520: PUSH
29521: DOUBLE
29522: LD_INT 1
29524: DEC
29525: ST_TO_ADDR
29526: LD_VAR 0 6
29530: PUSH
29531: FOR_TO
29532: IFFALSE 30102
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
29534: LD_EXP 55
29538: PUSH
29539: LD_VAR 0 2
29543: ARRAY
29544: PUSH
29545: LD_INT 1
29547: ARRAY
29548: PUSH
29549: LD_INT 1
29551: ARRAY
29552: PUSH
29553: LD_INT 0
29555: EQUAL
29556: PUSH
29557: LD_VAR 0 6
29561: PUSH
29562: LD_VAR 0 4
29566: ARRAY
29567: PPUSH
29568: LD_EXP 55
29572: PUSH
29573: LD_VAR 0 2
29577: ARRAY
29578: PUSH
29579: LD_INT 1
29581: ARRAY
29582: PUSH
29583: LD_INT 1
29585: ARRAY
29586: PPUSH
29587: LD_EXP 55
29591: PUSH
29592: LD_VAR 0 2
29596: ARRAY
29597: PUSH
29598: LD_INT 1
29600: ARRAY
29601: PUSH
29602: LD_INT 2
29604: ARRAY
29605: PPUSH
29606: LD_EXP 55
29610: PUSH
29611: LD_VAR 0 2
29615: ARRAY
29616: PUSH
29617: LD_INT 1
29619: ARRAY
29620: PUSH
29621: LD_INT 3
29623: ARRAY
29624: PPUSH
29625: LD_EXP 55
29629: PUSH
29630: LD_VAR 0 2
29634: ARRAY
29635: PUSH
29636: LD_INT 1
29638: ARRAY
29639: PUSH
29640: LD_INT 4
29642: ARRAY
29643: PPUSH
29644: CALL 62619 0 5
29648: OR
29649: IFFALSE 29930
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
29651: LD_ADDR_VAR 0 5
29655: PUSH
29656: LD_EXP 50
29660: PUSH
29661: LD_VAR 0 2
29665: ARRAY
29666: PPUSH
29667: LD_INT 25
29669: PUSH
29670: LD_INT 2
29672: PUSH
29673: EMPTY
29674: LIST
29675: LIST
29676: PPUSH
29677: CALL_OW 72
29681: PUSH
29682: LD_EXP 52
29686: PUSH
29687: LD_VAR 0 2
29691: ARRAY
29692: DIFF
29693: ST_TO_ADDR
// if not tmp then
29694: LD_VAR 0 5
29698: NOT
29699: IFFALSE 29703
// continue ;
29701: GO 29531
// for j in tmp do
29703: LD_ADDR_VAR 0 3
29707: PUSH
29708: LD_VAR 0 5
29712: PUSH
29713: FOR_IN
29714: IFFALSE 29926
// begin if not mc_builders [ i ] then
29716: LD_EXP 56
29720: PUSH
29721: LD_VAR 0 2
29725: ARRAY
29726: NOT
29727: IFFALSE 29785
// begin SetTag ( j , 103 ) ;
29729: LD_VAR 0 3
29733: PPUSH
29734: LD_INT 103
29736: PPUSH
29737: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
29741: LD_ADDR_EXP 56
29745: PUSH
29746: LD_EXP 56
29750: PPUSH
29751: LD_VAR 0 2
29755: PUSH
29756: LD_EXP 56
29760: PUSH
29761: LD_VAR 0 2
29765: ARRAY
29766: PUSH
29767: LD_INT 1
29769: PLUS
29770: PUSH
29771: EMPTY
29772: LIST
29773: LIST
29774: PPUSH
29775: LD_VAR 0 3
29779: PPUSH
29780: CALL 54145 0 3
29784: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
29785: LD_VAR 0 3
29789: PPUSH
29790: CALL_OW 310
29794: IFFALSE 29805
// ComExitBuilding ( j ) ;
29796: LD_VAR 0 3
29800: PPUSH
29801: CALL_OW 122
// wait ( 3 ) ;
29805: LD_INT 3
29807: PPUSH
29808: CALL_OW 67
// if not mc_build_list [ i ] then
29812: LD_EXP 55
29816: PUSH
29817: LD_VAR 0 2
29821: ARRAY
29822: NOT
29823: IFFALSE 29827
// break ;
29825: GO 29926
// if not HasTask ( j ) then
29827: LD_VAR 0 3
29831: PPUSH
29832: CALL_OW 314
29836: NOT
29837: IFFALSE 29924
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
29839: LD_VAR 0 3
29843: PPUSH
29844: LD_EXP 55
29848: PUSH
29849: LD_VAR 0 2
29853: ARRAY
29854: PUSH
29855: LD_INT 1
29857: ARRAY
29858: PUSH
29859: LD_INT 1
29861: ARRAY
29862: PPUSH
29863: LD_EXP 55
29867: PUSH
29868: LD_VAR 0 2
29872: ARRAY
29873: PUSH
29874: LD_INT 1
29876: ARRAY
29877: PUSH
29878: LD_INT 2
29880: ARRAY
29881: PPUSH
29882: LD_EXP 55
29886: PUSH
29887: LD_VAR 0 2
29891: ARRAY
29892: PUSH
29893: LD_INT 1
29895: ARRAY
29896: PUSH
29897: LD_INT 3
29899: ARRAY
29900: PPUSH
29901: LD_EXP 55
29905: PUSH
29906: LD_VAR 0 2
29910: ARRAY
29911: PUSH
29912: LD_INT 1
29914: ARRAY
29915: PUSH
29916: LD_INT 4
29918: ARRAY
29919: PPUSH
29920: CALL_OW 145
// end ;
29924: GO 29713
29926: POP
29927: POP
// end else
29928: GO 30100
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
29930: LD_EXP 50
29934: PUSH
29935: LD_VAR 0 2
29939: ARRAY
29940: PPUSH
29941: LD_EXP 55
29945: PUSH
29946: LD_VAR 0 2
29950: ARRAY
29951: PUSH
29952: LD_INT 1
29954: ARRAY
29955: PUSH
29956: LD_INT 1
29958: ARRAY
29959: PPUSH
29960: LD_EXP 55
29964: PUSH
29965: LD_VAR 0 2
29969: ARRAY
29970: PUSH
29971: LD_INT 1
29973: ARRAY
29974: PUSH
29975: LD_INT 2
29977: ARRAY
29978: PPUSH
29979: LD_EXP 55
29983: PUSH
29984: LD_VAR 0 2
29988: ARRAY
29989: PUSH
29990: LD_INT 1
29992: ARRAY
29993: PUSH
29994: LD_INT 3
29996: ARRAY
29997: PPUSH
29998: LD_EXP 55
30002: PUSH
30003: LD_VAR 0 2
30007: ARRAY
30008: PUSH
30009: LD_INT 1
30011: ARRAY
30012: PUSH
30013: LD_INT 4
30015: ARRAY
30016: PPUSH
30017: LD_EXP 50
30021: PUSH
30022: LD_VAR 0 2
30026: ARRAY
30027: PPUSH
30028: LD_INT 21
30030: PUSH
30031: LD_INT 3
30033: PUSH
30034: EMPTY
30035: LIST
30036: LIST
30037: PPUSH
30038: CALL_OW 72
30042: PPUSH
30043: EMPTY
30044: PPUSH
30045: CALL 61373 0 7
30049: NOT
30050: IFFALSE 30100
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
30052: LD_ADDR_EXP 55
30056: PUSH
30057: LD_EXP 55
30061: PPUSH
30062: LD_VAR 0 2
30066: PPUSH
30067: LD_EXP 55
30071: PUSH
30072: LD_VAR 0 2
30076: ARRAY
30077: PPUSH
30078: LD_INT 1
30080: PPUSH
30081: LD_INT 1
30083: NEG
30084: PPUSH
30085: LD_INT 0
30087: PPUSH
30088: CALL 53563 0 4
30092: PPUSH
30093: CALL_OW 1
30097: ST_TO_ADDR
// continue ;
30098: GO 29531
// end ; end ;
30100: GO 29531
30102: POP
30103: POP
// end ; end ;
30104: GO 28960
30106: POP
30107: POP
// end ;
30108: LD_VAR 0 1
30112: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
30113: LD_INT 0
30115: PPUSH
30116: PPUSH
30117: PPUSH
30118: PPUSH
30119: PPUSH
30120: PPUSH
// if not mc_bases then
30121: LD_EXP 50
30125: NOT
30126: IFFALSE 30130
// exit ;
30128: GO 30557
// for i = 1 to mc_bases do
30130: LD_ADDR_VAR 0 2
30134: PUSH
30135: DOUBLE
30136: LD_INT 1
30138: DEC
30139: ST_TO_ADDR
30140: LD_EXP 50
30144: PUSH
30145: FOR_TO
30146: IFFALSE 30555
// begin tmp := mc_build_upgrade [ i ] ;
30148: LD_ADDR_VAR 0 4
30152: PUSH
30153: LD_EXP 82
30157: PUSH
30158: LD_VAR 0 2
30162: ARRAY
30163: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
30164: LD_ADDR_VAR 0 6
30168: PUSH
30169: LD_EXP 83
30173: PUSH
30174: LD_VAR 0 2
30178: ARRAY
30179: PPUSH
30180: LD_INT 2
30182: PUSH
30183: LD_INT 30
30185: PUSH
30186: LD_INT 6
30188: PUSH
30189: EMPTY
30190: LIST
30191: LIST
30192: PUSH
30193: LD_INT 30
30195: PUSH
30196: LD_INT 7
30198: PUSH
30199: EMPTY
30200: LIST
30201: LIST
30202: PUSH
30203: EMPTY
30204: LIST
30205: LIST
30206: LIST
30207: PPUSH
30208: CALL_OW 72
30212: ST_TO_ADDR
// if not tmp and not lab then
30213: LD_VAR 0 4
30217: NOT
30218: PUSH
30219: LD_VAR 0 6
30223: NOT
30224: AND
30225: IFFALSE 30229
// continue ;
30227: GO 30145
// if tmp then
30229: LD_VAR 0 4
30233: IFFALSE 30353
// for j in tmp do
30235: LD_ADDR_VAR 0 3
30239: PUSH
30240: LD_VAR 0 4
30244: PUSH
30245: FOR_IN
30246: IFFALSE 30351
// begin if UpgradeCost ( j ) then
30248: LD_VAR 0 3
30252: PPUSH
30253: CALL 61033 0 1
30257: IFFALSE 30349
// begin ComUpgrade ( j ) ;
30259: LD_VAR 0 3
30263: PPUSH
30264: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
30268: LD_ADDR_EXP 82
30272: PUSH
30273: LD_EXP 82
30277: PPUSH
30278: LD_VAR 0 2
30282: PPUSH
30283: LD_EXP 82
30287: PUSH
30288: LD_VAR 0 2
30292: ARRAY
30293: PUSH
30294: LD_VAR 0 3
30298: DIFF
30299: PPUSH
30300: CALL_OW 1
30304: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
30305: LD_ADDR_EXP 57
30309: PUSH
30310: LD_EXP 57
30314: PPUSH
30315: LD_VAR 0 2
30319: PUSH
30320: LD_EXP 57
30324: PUSH
30325: LD_VAR 0 2
30329: ARRAY
30330: PUSH
30331: LD_INT 1
30333: PLUS
30334: PUSH
30335: EMPTY
30336: LIST
30337: LIST
30338: PPUSH
30339: LD_VAR 0 3
30343: PPUSH
30344: CALL 54145 0 3
30348: ST_TO_ADDR
// end ; end ;
30349: GO 30245
30351: POP
30352: POP
// if not lab or not mc_lab_upgrade [ i ] then
30353: LD_VAR 0 6
30357: NOT
30358: PUSH
30359: LD_EXP 84
30363: PUSH
30364: LD_VAR 0 2
30368: ARRAY
30369: NOT
30370: OR
30371: IFFALSE 30375
// continue ;
30373: GO 30145
// for j in lab do
30375: LD_ADDR_VAR 0 3
30379: PUSH
30380: LD_VAR 0 6
30384: PUSH
30385: FOR_IN
30386: IFFALSE 30551
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
30388: LD_VAR 0 3
30392: PPUSH
30393: CALL_OW 266
30397: PUSH
30398: LD_INT 6
30400: PUSH
30401: LD_INT 7
30403: PUSH
30404: EMPTY
30405: LIST
30406: LIST
30407: IN
30408: PUSH
30409: LD_VAR 0 3
30413: PPUSH
30414: CALL_OW 461
30418: PUSH
30419: LD_INT 1
30421: NONEQUAL
30422: AND
30423: IFFALSE 30549
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
30425: LD_VAR 0 3
30429: PPUSH
30430: LD_EXP 84
30434: PUSH
30435: LD_VAR 0 2
30439: ARRAY
30440: PUSH
30441: LD_INT 1
30443: ARRAY
30444: PPUSH
30445: CALL 61238 0 2
30449: IFFALSE 30549
// begin ComCancel ( j ) ;
30451: LD_VAR 0 3
30455: PPUSH
30456: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
30460: LD_VAR 0 3
30464: PPUSH
30465: LD_EXP 84
30469: PUSH
30470: LD_VAR 0 2
30474: ARRAY
30475: PUSH
30476: LD_INT 1
30478: ARRAY
30479: PPUSH
30480: CALL_OW 207
// if not j in mc_construct_list [ i ] then
30484: LD_VAR 0 3
30488: PUSH
30489: LD_EXP 57
30493: PUSH
30494: LD_VAR 0 2
30498: ARRAY
30499: IN
30500: NOT
30501: IFFALSE 30547
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
30503: LD_ADDR_EXP 57
30507: PUSH
30508: LD_EXP 57
30512: PPUSH
30513: LD_VAR 0 2
30517: PUSH
30518: LD_EXP 57
30522: PUSH
30523: LD_VAR 0 2
30527: ARRAY
30528: PUSH
30529: LD_INT 1
30531: PLUS
30532: PUSH
30533: EMPTY
30534: LIST
30535: LIST
30536: PPUSH
30537: LD_VAR 0 3
30541: PPUSH
30542: CALL 54145 0 3
30546: ST_TO_ADDR
// break ;
30547: GO 30551
// end ; end ; end ;
30549: GO 30385
30551: POP
30552: POP
// end ;
30553: GO 30145
30555: POP
30556: POP
// end ;
30557: LD_VAR 0 1
30561: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
30562: LD_INT 0
30564: PPUSH
30565: PPUSH
30566: PPUSH
30567: PPUSH
30568: PPUSH
30569: PPUSH
30570: PPUSH
30571: PPUSH
30572: PPUSH
// if not mc_bases then
30573: LD_EXP 50
30577: NOT
30578: IFFALSE 30582
// exit ;
30580: GO 30987
// for i = 1 to mc_bases do
30582: LD_ADDR_VAR 0 2
30586: PUSH
30587: DOUBLE
30588: LD_INT 1
30590: DEC
30591: ST_TO_ADDR
30592: LD_EXP 50
30596: PUSH
30597: FOR_TO
30598: IFFALSE 30985
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
30600: LD_EXP 58
30604: PUSH
30605: LD_VAR 0 2
30609: ARRAY
30610: NOT
30611: PUSH
30612: LD_EXP 50
30616: PUSH
30617: LD_VAR 0 2
30621: ARRAY
30622: PPUSH
30623: LD_INT 30
30625: PUSH
30626: LD_INT 3
30628: PUSH
30629: EMPTY
30630: LIST
30631: LIST
30632: PPUSH
30633: CALL_OW 72
30637: NOT
30638: OR
30639: IFFALSE 30643
// continue ;
30641: GO 30597
// busy := false ;
30643: LD_ADDR_VAR 0 8
30647: PUSH
30648: LD_INT 0
30650: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
30651: LD_ADDR_VAR 0 4
30655: PUSH
30656: LD_EXP 50
30660: PUSH
30661: LD_VAR 0 2
30665: ARRAY
30666: PPUSH
30667: LD_INT 30
30669: PUSH
30670: LD_INT 3
30672: PUSH
30673: EMPTY
30674: LIST
30675: LIST
30676: PPUSH
30677: CALL_OW 72
30681: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
30682: LD_ADDR_VAR 0 6
30686: PUSH
30687: LD_EXP 58
30691: PUSH
30692: LD_VAR 0 2
30696: ARRAY
30697: PPUSH
30698: LD_INT 2
30700: PUSH
30701: LD_INT 30
30703: PUSH
30704: LD_INT 32
30706: PUSH
30707: EMPTY
30708: LIST
30709: LIST
30710: PUSH
30711: LD_INT 30
30713: PUSH
30714: LD_INT 33
30716: PUSH
30717: EMPTY
30718: LIST
30719: LIST
30720: PUSH
30721: EMPTY
30722: LIST
30723: LIST
30724: LIST
30725: PPUSH
30726: CALL_OW 72
30730: ST_TO_ADDR
// if not t then
30731: LD_VAR 0 6
30735: NOT
30736: IFFALSE 30740
// continue ;
30738: GO 30597
// for j in tmp do
30740: LD_ADDR_VAR 0 3
30744: PUSH
30745: LD_VAR 0 4
30749: PUSH
30750: FOR_IN
30751: IFFALSE 30781
// if not BuildingStatus ( j ) = bs_idle then
30753: LD_VAR 0 3
30757: PPUSH
30758: CALL_OW 461
30762: PUSH
30763: LD_INT 2
30765: EQUAL
30766: NOT
30767: IFFALSE 30779
// begin busy := true ;
30769: LD_ADDR_VAR 0 8
30773: PUSH
30774: LD_INT 1
30776: ST_TO_ADDR
// break ;
30777: GO 30781
// end ;
30779: GO 30750
30781: POP
30782: POP
// if busy then
30783: LD_VAR 0 8
30787: IFFALSE 30791
// continue ;
30789: GO 30597
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
30791: LD_ADDR_VAR 0 7
30795: PUSH
30796: LD_VAR 0 6
30800: PPUSH
30801: LD_INT 35
30803: PUSH
30804: LD_INT 0
30806: PUSH
30807: EMPTY
30808: LIST
30809: LIST
30810: PPUSH
30811: CALL_OW 72
30815: ST_TO_ADDR
// if tw then
30816: LD_VAR 0 7
30820: IFFALSE 30897
// begin tw := tw [ 1 ] ;
30822: LD_ADDR_VAR 0 7
30826: PUSH
30827: LD_VAR 0 7
30831: PUSH
30832: LD_INT 1
30834: ARRAY
30835: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
30836: LD_ADDR_VAR 0 9
30840: PUSH
30841: LD_VAR 0 7
30845: PPUSH
30846: LD_EXP 75
30850: PUSH
30851: LD_VAR 0 2
30855: ARRAY
30856: PPUSH
30857: CALL 59530 0 2
30861: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
30862: LD_EXP 89
30866: PUSH
30867: LD_VAR 0 2
30871: ARRAY
30872: IFFALSE 30895
// if not weapon in mc_allowed_tower_weapons [ i ] then
30874: LD_VAR 0 9
30878: PUSH
30879: LD_EXP 89
30883: PUSH
30884: LD_VAR 0 2
30888: ARRAY
30889: IN
30890: NOT
30891: IFFALSE 30895
// continue ;
30893: GO 30597
// end else
30895: GO 30960
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
30897: LD_ADDR_VAR 0 5
30901: PUSH
30902: LD_EXP 58
30906: PUSH
30907: LD_VAR 0 2
30911: ARRAY
30912: PPUSH
30913: LD_VAR 0 4
30917: PPUSH
30918: CALL 86422 0 2
30922: ST_TO_ADDR
// if not tmp2 then
30923: LD_VAR 0 5
30927: NOT
30928: IFFALSE 30932
// continue ;
30930: GO 30597
// tw := tmp2 [ 1 ] ;
30932: LD_ADDR_VAR 0 7
30936: PUSH
30937: LD_VAR 0 5
30941: PUSH
30942: LD_INT 1
30944: ARRAY
30945: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
30946: LD_ADDR_VAR 0 9
30950: PUSH
30951: LD_VAR 0 5
30955: PUSH
30956: LD_INT 2
30958: ARRAY
30959: ST_TO_ADDR
// end ; if not weapon then
30960: LD_VAR 0 9
30964: NOT
30965: IFFALSE 30969
// continue ;
30967: GO 30597
// ComPlaceWeapon ( tw , weapon ) ;
30969: LD_VAR 0 7
30973: PPUSH
30974: LD_VAR 0 9
30978: PPUSH
30979: CALL_OW 148
// end ;
30983: GO 30597
30985: POP
30986: POP
// end ;
30987: LD_VAR 0 1
30991: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
30992: LD_INT 0
30994: PPUSH
30995: PPUSH
30996: PPUSH
30997: PPUSH
30998: PPUSH
30999: PPUSH
31000: PPUSH
// if not mc_bases then
31001: LD_EXP 50
31005: NOT
31006: IFFALSE 31010
// exit ;
31008: GO 31785
// for i = 1 to mc_bases do
31010: LD_ADDR_VAR 0 2
31014: PUSH
31015: DOUBLE
31016: LD_INT 1
31018: DEC
31019: ST_TO_ADDR
31020: LD_EXP 50
31024: PUSH
31025: FOR_TO
31026: IFFALSE 31783
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
31028: LD_EXP 63
31032: PUSH
31033: LD_VAR 0 2
31037: ARRAY
31038: NOT
31039: PUSH
31040: LD_EXP 63
31044: PUSH
31045: LD_VAR 0 2
31049: ARRAY
31050: PUSH
31051: LD_EXP 64
31055: PUSH
31056: LD_VAR 0 2
31060: ARRAY
31061: EQUAL
31062: OR
31063: PUSH
31064: LD_EXP 73
31068: PUSH
31069: LD_VAR 0 2
31073: ARRAY
31074: OR
31075: IFFALSE 31079
// continue ;
31077: GO 31025
// if mc_miners [ i ] then
31079: LD_EXP 64
31083: PUSH
31084: LD_VAR 0 2
31088: ARRAY
31089: IFFALSE 31470
// begin for j = mc_miners [ i ] downto 1 do
31091: LD_ADDR_VAR 0 3
31095: PUSH
31096: DOUBLE
31097: LD_EXP 64
31101: PUSH
31102: LD_VAR 0 2
31106: ARRAY
31107: INC
31108: ST_TO_ADDR
31109: LD_INT 1
31111: PUSH
31112: FOR_DOWNTO
31113: IFFALSE 31468
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
31115: LD_EXP 64
31119: PUSH
31120: LD_VAR 0 2
31124: ARRAY
31125: PUSH
31126: LD_VAR 0 3
31130: ARRAY
31131: PPUSH
31132: CALL_OW 301
31136: PUSH
31137: LD_EXP 64
31141: PUSH
31142: LD_VAR 0 2
31146: ARRAY
31147: PUSH
31148: LD_VAR 0 3
31152: ARRAY
31153: PPUSH
31154: CALL_OW 257
31158: PUSH
31159: LD_INT 1
31161: NONEQUAL
31162: OR
31163: IFFALSE 31226
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
31165: LD_ADDR_VAR 0 5
31169: PUSH
31170: LD_EXP 64
31174: PUSH
31175: LD_VAR 0 2
31179: ARRAY
31180: PUSH
31181: LD_EXP 64
31185: PUSH
31186: LD_VAR 0 2
31190: ARRAY
31191: PUSH
31192: LD_VAR 0 3
31196: ARRAY
31197: DIFF
31198: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
31199: LD_ADDR_EXP 64
31203: PUSH
31204: LD_EXP 64
31208: PPUSH
31209: LD_VAR 0 2
31213: PPUSH
31214: LD_VAR 0 5
31218: PPUSH
31219: CALL_OW 1
31223: ST_TO_ADDR
// continue ;
31224: GO 31112
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
31226: LD_EXP 64
31230: PUSH
31231: LD_VAR 0 2
31235: ARRAY
31236: PUSH
31237: LD_VAR 0 3
31241: ARRAY
31242: PPUSH
31243: CALL_OW 257
31247: PUSH
31248: LD_INT 1
31250: EQUAL
31251: PUSH
31252: LD_EXP 64
31256: PUSH
31257: LD_VAR 0 2
31261: ARRAY
31262: PUSH
31263: LD_VAR 0 3
31267: ARRAY
31268: PPUSH
31269: CALL_OW 459
31273: NOT
31274: AND
31275: PUSH
31276: LD_EXP 64
31280: PUSH
31281: LD_VAR 0 2
31285: ARRAY
31286: PUSH
31287: LD_VAR 0 3
31291: ARRAY
31292: PPUSH
31293: CALL_OW 314
31297: NOT
31298: AND
31299: IFFALSE 31466
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
31301: LD_EXP 64
31305: PUSH
31306: LD_VAR 0 2
31310: ARRAY
31311: PUSH
31312: LD_VAR 0 3
31316: ARRAY
31317: PPUSH
31318: CALL_OW 310
31322: IFFALSE 31345
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
31324: LD_EXP 64
31328: PUSH
31329: LD_VAR 0 2
31333: ARRAY
31334: PUSH
31335: LD_VAR 0 3
31339: ARRAY
31340: PPUSH
31341: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
31345: LD_EXP 64
31349: PUSH
31350: LD_VAR 0 2
31354: ARRAY
31355: PUSH
31356: LD_VAR 0 3
31360: ARRAY
31361: PPUSH
31362: CALL_OW 314
31366: NOT
31367: IFFALSE 31466
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
31369: LD_ADDR_VAR 0 7
31373: PUSH
31374: LD_VAR 0 3
31378: PUSH
31379: LD_EXP 63
31383: PUSH
31384: LD_VAR 0 2
31388: ARRAY
31389: PPUSH
31390: CALL 51285 0 1
31394: MOD
31395: PUSH
31396: LD_INT 1
31398: PLUS
31399: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
31400: LD_EXP 64
31404: PUSH
31405: LD_VAR 0 2
31409: ARRAY
31410: PUSH
31411: LD_VAR 0 3
31415: ARRAY
31416: PPUSH
31417: LD_EXP 63
31421: PUSH
31422: LD_VAR 0 2
31426: ARRAY
31427: PUSH
31428: LD_VAR 0 7
31432: ARRAY
31433: PUSH
31434: LD_INT 1
31436: ARRAY
31437: PPUSH
31438: LD_EXP 63
31442: PUSH
31443: LD_VAR 0 2
31447: ARRAY
31448: PUSH
31449: LD_VAR 0 7
31453: ARRAY
31454: PUSH
31455: LD_INT 2
31457: ARRAY
31458: PPUSH
31459: LD_INT 0
31461: PPUSH
31462: CALL_OW 193
// end ; end ; end ;
31466: GO 31112
31468: POP
31469: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
31470: LD_ADDR_VAR 0 5
31474: PUSH
31475: LD_EXP 50
31479: PUSH
31480: LD_VAR 0 2
31484: ARRAY
31485: PPUSH
31486: LD_INT 2
31488: PUSH
31489: LD_INT 30
31491: PUSH
31492: LD_INT 4
31494: PUSH
31495: EMPTY
31496: LIST
31497: LIST
31498: PUSH
31499: LD_INT 30
31501: PUSH
31502: LD_INT 5
31504: PUSH
31505: EMPTY
31506: LIST
31507: LIST
31508: PUSH
31509: LD_INT 30
31511: PUSH
31512: LD_INT 32
31514: PUSH
31515: EMPTY
31516: LIST
31517: LIST
31518: PUSH
31519: EMPTY
31520: LIST
31521: LIST
31522: LIST
31523: LIST
31524: PPUSH
31525: CALL_OW 72
31529: ST_TO_ADDR
// if not tmp then
31530: LD_VAR 0 5
31534: NOT
31535: IFFALSE 31539
// continue ;
31537: GO 31025
// list := [ ] ;
31539: LD_ADDR_VAR 0 6
31543: PUSH
31544: EMPTY
31545: ST_TO_ADDR
// for j in tmp do
31546: LD_ADDR_VAR 0 3
31550: PUSH
31551: LD_VAR 0 5
31555: PUSH
31556: FOR_IN
31557: IFFALSE 31626
// begin for k in UnitsInside ( j ) do
31559: LD_ADDR_VAR 0 4
31563: PUSH
31564: LD_VAR 0 3
31568: PPUSH
31569: CALL_OW 313
31573: PUSH
31574: FOR_IN
31575: IFFALSE 31622
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
31577: LD_VAR 0 4
31581: PPUSH
31582: CALL_OW 257
31586: PUSH
31587: LD_INT 1
31589: EQUAL
31590: PUSH
31591: LD_VAR 0 4
31595: PPUSH
31596: CALL_OW 459
31600: NOT
31601: AND
31602: IFFALSE 31620
// list := list ^ k ;
31604: LD_ADDR_VAR 0 6
31608: PUSH
31609: LD_VAR 0 6
31613: PUSH
31614: LD_VAR 0 4
31618: ADD
31619: ST_TO_ADDR
31620: GO 31574
31622: POP
31623: POP
// end ;
31624: GO 31556
31626: POP
31627: POP
// list := list diff mc_miners [ i ] ;
31628: LD_ADDR_VAR 0 6
31632: PUSH
31633: LD_VAR 0 6
31637: PUSH
31638: LD_EXP 64
31642: PUSH
31643: LD_VAR 0 2
31647: ARRAY
31648: DIFF
31649: ST_TO_ADDR
// if not list then
31650: LD_VAR 0 6
31654: NOT
31655: IFFALSE 31659
// continue ;
31657: GO 31025
// k := mc_mines [ i ] - mc_miners [ i ] ;
31659: LD_ADDR_VAR 0 4
31663: PUSH
31664: LD_EXP 63
31668: PUSH
31669: LD_VAR 0 2
31673: ARRAY
31674: PUSH
31675: LD_EXP 64
31679: PUSH
31680: LD_VAR 0 2
31684: ARRAY
31685: MINUS
31686: ST_TO_ADDR
// if k > list then
31687: LD_VAR 0 4
31691: PUSH
31692: LD_VAR 0 6
31696: GREATER
31697: IFFALSE 31709
// k := list ;
31699: LD_ADDR_VAR 0 4
31703: PUSH
31704: LD_VAR 0 6
31708: ST_TO_ADDR
// for j = 1 to k do
31709: LD_ADDR_VAR 0 3
31713: PUSH
31714: DOUBLE
31715: LD_INT 1
31717: DEC
31718: ST_TO_ADDR
31719: LD_VAR 0 4
31723: PUSH
31724: FOR_TO
31725: IFFALSE 31779
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
31727: LD_ADDR_EXP 64
31731: PUSH
31732: LD_EXP 64
31736: PPUSH
31737: LD_VAR 0 2
31741: PUSH
31742: LD_EXP 64
31746: PUSH
31747: LD_VAR 0 2
31751: ARRAY
31752: PUSH
31753: LD_INT 1
31755: PLUS
31756: PUSH
31757: EMPTY
31758: LIST
31759: LIST
31760: PPUSH
31761: LD_VAR 0 6
31765: PUSH
31766: LD_VAR 0 3
31770: ARRAY
31771: PPUSH
31772: CALL 54145 0 3
31776: ST_TO_ADDR
31777: GO 31724
31779: POP
31780: POP
// end ;
31781: GO 31025
31783: POP
31784: POP
// end ;
31785: LD_VAR 0 1
31789: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
31790: LD_INT 0
31792: PPUSH
31793: PPUSH
31794: PPUSH
31795: PPUSH
31796: PPUSH
31797: PPUSH
31798: PPUSH
31799: PPUSH
31800: PPUSH
31801: PPUSH
31802: PPUSH
// if not mc_bases then
31803: LD_EXP 50
31807: NOT
31808: IFFALSE 31812
// exit ;
31810: GO 33635
// for i = 1 to mc_bases do
31812: LD_ADDR_VAR 0 2
31816: PUSH
31817: DOUBLE
31818: LD_INT 1
31820: DEC
31821: ST_TO_ADDR
31822: LD_EXP 50
31826: PUSH
31827: FOR_TO
31828: IFFALSE 33633
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
31830: LD_EXP 50
31834: PUSH
31835: LD_VAR 0 2
31839: ARRAY
31840: NOT
31841: PUSH
31842: LD_EXP 57
31846: PUSH
31847: LD_VAR 0 2
31851: ARRAY
31852: OR
31853: IFFALSE 31857
// continue ;
31855: GO 31827
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
31857: LD_EXP 66
31861: PUSH
31862: LD_VAR 0 2
31866: ARRAY
31867: NOT
31868: PUSH
31869: LD_EXP 67
31873: PUSH
31874: LD_VAR 0 2
31878: ARRAY
31879: AND
31880: IFFALSE 31918
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
31882: LD_ADDR_EXP 67
31886: PUSH
31887: LD_EXP 67
31891: PPUSH
31892: LD_VAR 0 2
31896: PPUSH
31897: EMPTY
31898: PPUSH
31899: CALL_OW 1
31903: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
31904: LD_VAR 0 2
31908: PPUSH
31909: LD_INT 107
31911: PPUSH
31912: CALL 22644 0 2
// continue ;
31916: GO 31827
// end ; target := [ ] ;
31918: LD_ADDR_VAR 0 7
31922: PUSH
31923: EMPTY
31924: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
31925: LD_ADDR_VAR 0 6
31929: PUSH
31930: LD_EXP 50
31934: PUSH
31935: LD_VAR 0 2
31939: ARRAY
31940: PUSH
31941: LD_INT 1
31943: ARRAY
31944: PPUSH
31945: CALL_OW 255
31949: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31950: LD_ADDR_VAR 0 9
31954: PUSH
31955: LD_EXP 50
31959: PUSH
31960: LD_VAR 0 2
31964: ARRAY
31965: PPUSH
31966: LD_INT 2
31968: PUSH
31969: LD_INT 30
31971: PUSH
31972: LD_INT 0
31974: PUSH
31975: EMPTY
31976: LIST
31977: LIST
31978: PUSH
31979: LD_INT 30
31981: PUSH
31982: LD_INT 1
31984: PUSH
31985: EMPTY
31986: LIST
31987: LIST
31988: PUSH
31989: EMPTY
31990: LIST
31991: LIST
31992: LIST
31993: PPUSH
31994: CALL_OW 72
31998: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
31999: LD_ADDR_VAR 0 3
32003: PUSH
32004: DOUBLE
32005: LD_EXP 66
32009: PUSH
32010: LD_VAR 0 2
32014: ARRAY
32015: INC
32016: ST_TO_ADDR
32017: LD_INT 1
32019: PUSH
32020: FOR_DOWNTO
32021: IFFALSE 32266
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
32023: LD_EXP 66
32027: PUSH
32028: LD_VAR 0 2
32032: ARRAY
32033: PUSH
32034: LD_VAR 0 3
32038: ARRAY
32039: PUSH
32040: LD_INT 2
32042: ARRAY
32043: PPUSH
32044: LD_EXP 66
32048: PUSH
32049: LD_VAR 0 2
32053: ARRAY
32054: PUSH
32055: LD_VAR 0 3
32059: ARRAY
32060: PUSH
32061: LD_INT 3
32063: ARRAY
32064: PPUSH
32065: CALL_OW 488
32069: PUSH
32070: LD_EXP 66
32074: PUSH
32075: LD_VAR 0 2
32079: ARRAY
32080: PUSH
32081: LD_VAR 0 3
32085: ARRAY
32086: PUSH
32087: LD_INT 2
32089: ARRAY
32090: PPUSH
32091: LD_EXP 66
32095: PUSH
32096: LD_VAR 0 2
32100: ARRAY
32101: PUSH
32102: LD_VAR 0 3
32106: ARRAY
32107: PUSH
32108: LD_INT 3
32110: ARRAY
32111: PPUSH
32112: CALL_OW 284
32116: PUSH
32117: LD_INT 0
32119: EQUAL
32120: AND
32121: IFFALSE 32176
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
32123: LD_ADDR_VAR 0 5
32127: PUSH
32128: LD_EXP 66
32132: PUSH
32133: LD_VAR 0 2
32137: ARRAY
32138: PPUSH
32139: LD_VAR 0 3
32143: PPUSH
32144: CALL_OW 3
32148: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
32149: LD_ADDR_EXP 66
32153: PUSH
32154: LD_EXP 66
32158: PPUSH
32159: LD_VAR 0 2
32163: PPUSH
32164: LD_VAR 0 5
32168: PPUSH
32169: CALL_OW 1
32173: ST_TO_ADDR
// continue ;
32174: GO 32020
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
32176: LD_VAR 0 6
32180: PPUSH
32181: LD_EXP 66
32185: PUSH
32186: LD_VAR 0 2
32190: ARRAY
32191: PUSH
32192: LD_VAR 0 3
32196: ARRAY
32197: PUSH
32198: LD_INT 2
32200: ARRAY
32201: PPUSH
32202: LD_EXP 66
32206: PUSH
32207: LD_VAR 0 2
32211: ARRAY
32212: PUSH
32213: LD_VAR 0 3
32217: ARRAY
32218: PUSH
32219: LD_INT 3
32221: ARRAY
32222: PPUSH
32223: LD_INT 30
32225: PPUSH
32226: CALL 55409 0 4
32230: PUSH
32231: LD_INT 4
32233: ARRAY
32234: PUSH
32235: LD_INT 0
32237: EQUAL
32238: IFFALSE 32264
// begin target := mc_crates [ i ] [ j ] ;
32240: LD_ADDR_VAR 0 7
32244: PUSH
32245: LD_EXP 66
32249: PUSH
32250: LD_VAR 0 2
32254: ARRAY
32255: PUSH
32256: LD_VAR 0 3
32260: ARRAY
32261: ST_TO_ADDR
// break ;
32262: GO 32266
// end ; end ;
32264: GO 32020
32266: POP
32267: POP
// if not target then
32268: LD_VAR 0 7
32272: NOT
32273: IFFALSE 32277
// continue ;
32275: GO 31827
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
32277: LD_ADDR_VAR 0 8
32281: PUSH
32282: LD_EXP 69
32286: PUSH
32287: LD_VAR 0 2
32291: ARRAY
32292: PPUSH
32293: LD_INT 2
32295: PUSH
32296: LD_INT 3
32298: PUSH
32299: LD_INT 58
32301: PUSH
32302: EMPTY
32303: LIST
32304: PUSH
32305: EMPTY
32306: LIST
32307: LIST
32308: PUSH
32309: LD_INT 61
32311: PUSH
32312: EMPTY
32313: LIST
32314: PUSH
32315: LD_INT 33
32317: PUSH
32318: LD_INT 5
32320: PUSH
32321: EMPTY
32322: LIST
32323: LIST
32324: PUSH
32325: LD_INT 33
32327: PUSH
32328: LD_INT 3
32330: PUSH
32331: EMPTY
32332: LIST
32333: LIST
32334: PUSH
32335: EMPTY
32336: LIST
32337: LIST
32338: LIST
32339: LIST
32340: LIST
32341: PUSH
32342: LD_INT 2
32344: PUSH
32345: LD_INT 34
32347: PUSH
32348: LD_INT 32
32350: PUSH
32351: EMPTY
32352: LIST
32353: LIST
32354: PUSH
32355: LD_INT 34
32357: PUSH
32358: LD_INT 51
32360: PUSH
32361: EMPTY
32362: LIST
32363: LIST
32364: PUSH
32365: LD_INT 34
32367: PUSH
32368: LD_INT 12
32370: PUSH
32371: EMPTY
32372: LIST
32373: LIST
32374: PUSH
32375: EMPTY
32376: LIST
32377: LIST
32378: LIST
32379: LIST
32380: PUSH
32381: EMPTY
32382: LIST
32383: LIST
32384: PPUSH
32385: CALL_OW 72
32389: ST_TO_ADDR
// if not cargo then
32390: LD_VAR 0 8
32394: NOT
32395: IFFALSE 33101
// begin if mc_crates_collector [ i ] < 5 then
32397: LD_EXP 67
32401: PUSH
32402: LD_VAR 0 2
32406: ARRAY
32407: PUSH
32408: LD_INT 5
32410: LESS
32411: IFFALSE 32777
// begin if mc_ape [ i ] then
32413: LD_EXP 79
32417: PUSH
32418: LD_VAR 0 2
32422: ARRAY
32423: IFFALSE 32470
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
32425: LD_ADDR_VAR 0 5
32429: PUSH
32430: LD_EXP 79
32434: PUSH
32435: LD_VAR 0 2
32439: ARRAY
32440: PPUSH
32441: LD_INT 25
32443: PUSH
32444: LD_INT 16
32446: PUSH
32447: EMPTY
32448: LIST
32449: LIST
32450: PUSH
32451: LD_INT 24
32453: PUSH
32454: LD_INT 750
32456: PUSH
32457: EMPTY
32458: LIST
32459: LIST
32460: PUSH
32461: EMPTY
32462: LIST
32463: LIST
32464: PPUSH
32465: CALL_OW 72
32469: ST_TO_ADDR
// if not tmp then
32470: LD_VAR 0 5
32474: NOT
32475: IFFALSE 32522
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
32477: LD_ADDR_VAR 0 5
32481: PUSH
32482: LD_EXP 50
32486: PUSH
32487: LD_VAR 0 2
32491: ARRAY
32492: PPUSH
32493: LD_INT 25
32495: PUSH
32496: LD_INT 2
32498: PUSH
32499: EMPTY
32500: LIST
32501: LIST
32502: PUSH
32503: LD_INT 24
32505: PUSH
32506: LD_INT 750
32508: PUSH
32509: EMPTY
32510: LIST
32511: LIST
32512: PUSH
32513: EMPTY
32514: LIST
32515: LIST
32516: PPUSH
32517: CALL_OW 72
32521: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
32522: LD_EXP 79
32526: PUSH
32527: LD_VAR 0 2
32531: ARRAY
32532: PUSH
32533: LD_EXP 50
32537: PUSH
32538: LD_VAR 0 2
32542: ARRAY
32543: PPUSH
32544: LD_INT 25
32546: PUSH
32547: LD_INT 2
32549: PUSH
32550: EMPTY
32551: LIST
32552: LIST
32553: PUSH
32554: LD_INT 24
32556: PUSH
32557: LD_INT 750
32559: PUSH
32560: EMPTY
32561: LIST
32562: LIST
32563: PUSH
32564: EMPTY
32565: LIST
32566: LIST
32567: PPUSH
32568: CALL_OW 72
32572: AND
32573: PUSH
32574: LD_VAR 0 5
32578: PUSH
32579: LD_INT 5
32581: LESS
32582: AND
32583: IFFALSE 32665
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
32585: LD_ADDR_VAR 0 3
32589: PUSH
32590: LD_EXP 50
32594: PUSH
32595: LD_VAR 0 2
32599: ARRAY
32600: PPUSH
32601: LD_INT 25
32603: PUSH
32604: LD_INT 2
32606: PUSH
32607: EMPTY
32608: LIST
32609: LIST
32610: PUSH
32611: LD_INT 24
32613: PUSH
32614: LD_INT 750
32616: PUSH
32617: EMPTY
32618: LIST
32619: LIST
32620: PUSH
32621: EMPTY
32622: LIST
32623: LIST
32624: PPUSH
32625: CALL_OW 72
32629: PUSH
32630: FOR_IN
32631: IFFALSE 32663
// begin tmp := tmp union j ;
32633: LD_ADDR_VAR 0 5
32637: PUSH
32638: LD_VAR 0 5
32642: PUSH
32643: LD_VAR 0 3
32647: UNION
32648: ST_TO_ADDR
// if tmp >= 5 then
32649: LD_VAR 0 5
32653: PUSH
32654: LD_INT 5
32656: GREATEREQUAL
32657: IFFALSE 32661
// break ;
32659: GO 32663
// end ;
32661: GO 32630
32663: POP
32664: POP
// end ; if not tmp then
32665: LD_VAR 0 5
32669: NOT
32670: IFFALSE 32674
// continue ;
32672: GO 31827
// for j in tmp do
32674: LD_ADDR_VAR 0 3
32678: PUSH
32679: LD_VAR 0 5
32683: PUSH
32684: FOR_IN
32685: IFFALSE 32775
// if not GetTag ( j ) then
32687: LD_VAR 0 3
32691: PPUSH
32692: CALL_OW 110
32696: NOT
32697: IFFALSE 32773
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
32699: LD_ADDR_EXP 67
32703: PUSH
32704: LD_EXP 67
32708: PPUSH
32709: LD_VAR 0 2
32713: PUSH
32714: LD_EXP 67
32718: PUSH
32719: LD_VAR 0 2
32723: ARRAY
32724: PUSH
32725: LD_INT 1
32727: PLUS
32728: PUSH
32729: EMPTY
32730: LIST
32731: LIST
32732: PPUSH
32733: LD_VAR 0 3
32737: PPUSH
32738: CALL 54145 0 3
32742: ST_TO_ADDR
// SetTag ( j , 107 ) ;
32743: LD_VAR 0 3
32747: PPUSH
32748: LD_INT 107
32750: PPUSH
32751: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
32755: LD_EXP 67
32759: PUSH
32760: LD_VAR 0 2
32764: ARRAY
32765: PUSH
32766: LD_INT 5
32768: GREATEREQUAL
32769: IFFALSE 32773
// break ;
32771: GO 32775
// end ;
32773: GO 32684
32775: POP
32776: POP
// end ; if mc_crates_collector [ i ] and target then
32777: LD_EXP 67
32781: PUSH
32782: LD_VAR 0 2
32786: ARRAY
32787: PUSH
32788: LD_VAR 0 7
32792: AND
32793: IFFALSE 33099
// begin if mc_crates_collector [ i ] < target [ 1 ] then
32795: LD_EXP 67
32799: PUSH
32800: LD_VAR 0 2
32804: ARRAY
32805: PUSH
32806: LD_VAR 0 7
32810: PUSH
32811: LD_INT 1
32813: ARRAY
32814: LESS
32815: IFFALSE 32835
// tmp := mc_crates_collector [ i ] else
32817: LD_ADDR_VAR 0 5
32821: PUSH
32822: LD_EXP 67
32826: PUSH
32827: LD_VAR 0 2
32831: ARRAY
32832: ST_TO_ADDR
32833: GO 32849
// tmp := target [ 1 ] ;
32835: LD_ADDR_VAR 0 5
32839: PUSH
32840: LD_VAR 0 7
32844: PUSH
32845: LD_INT 1
32847: ARRAY
32848: ST_TO_ADDR
// k := 0 ;
32849: LD_ADDR_VAR 0 4
32853: PUSH
32854: LD_INT 0
32856: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
32857: LD_ADDR_VAR 0 3
32861: PUSH
32862: LD_EXP 67
32866: PUSH
32867: LD_VAR 0 2
32871: ARRAY
32872: PUSH
32873: FOR_IN
32874: IFFALSE 33097
// begin k := k + 1 ;
32876: LD_ADDR_VAR 0 4
32880: PUSH
32881: LD_VAR 0 4
32885: PUSH
32886: LD_INT 1
32888: PLUS
32889: ST_TO_ADDR
// if k > tmp then
32890: LD_VAR 0 4
32894: PUSH
32895: LD_VAR 0 5
32899: GREATER
32900: IFFALSE 32904
// break ;
32902: GO 33097
// if not GetClass ( j ) in [ 2 , 16 ] then
32904: LD_VAR 0 3
32908: PPUSH
32909: CALL_OW 257
32913: PUSH
32914: LD_INT 2
32916: PUSH
32917: LD_INT 16
32919: PUSH
32920: EMPTY
32921: LIST
32922: LIST
32923: IN
32924: NOT
32925: IFFALSE 32978
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
32927: LD_ADDR_EXP 67
32931: PUSH
32932: LD_EXP 67
32936: PPUSH
32937: LD_VAR 0 2
32941: PPUSH
32942: LD_EXP 67
32946: PUSH
32947: LD_VAR 0 2
32951: ARRAY
32952: PUSH
32953: LD_VAR 0 3
32957: DIFF
32958: PPUSH
32959: CALL_OW 1
32963: ST_TO_ADDR
// SetTag ( j , 0 ) ;
32964: LD_VAR 0 3
32968: PPUSH
32969: LD_INT 0
32971: PPUSH
32972: CALL_OW 109
// continue ;
32976: GO 32873
// end ; if IsInUnit ( j ) then
32978: LD_VAR 0 3
32982: PPUSH
32983: CALL_OW 310
32987: IFFALSE 32998
// ComExitBuilding ( j ) ;
32989: LD_VAR 0 3
32993: PPUSH
32994: CALL_OW 122
// wait ( 3 ) ;
32998: LD_INT 3
33000: PPUSH
33001: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
33005: LD_VAR 0 3
33009: PPUSH
33010: CALL_OW 314
33014: PUSH
33015: LD_VAR 0 6
33019: PPUSH
33020: LD_VAR 0 7
33024: PUSH
33025: LD_INT 2
33027: ARRAY
33028: PPUSH
33029: LD_VAR 0 7
33033: PUSH
33034: LD_INT 3
33036: ARRAY
33037: PPUSH
33038: LD_INT 30
33040: PPUSH
33041: CALL 55409 0 4
33045: PUSH
33046: LD_INT 4
33048: ARRAY
33049: AND
33050: IFFALSE 33068
// ComStandNearbyBuilding ( j , depot ) else
33052: LD_VAR 0 3
33056: PPUSH
33057: LD_VAR 0 9
33061: PPUSH
33062: CALL 50747 0 2
33066: GO 33095
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
33068: LD_VAR 0 3
33072: PPUSH
33073: LD_VAR 0 7
33077: PUSH
33078: LD_INT 2
33080: ARRAY
33081: PPUSH
33082: LD_VAR 0 7
33086: PUSH
33087: LD_INT 3
33089: ARRAY
33090: PPUSH
33091: CALL_OW 117
// end ;
33095: GO 32873
33097: POP
33098: POP
// end ; end else
33099: GO 33631
// begin for j in cargo do
33101: LD_ADDR_VAR 0 3
33105: PUSH
33106: LD_VAR 0 8
33110: PUSH
33111: FOR_IN
33112: IFFALSE 33629
// begin if GetTag ( j ) <> 0 then
33114: LD_VAR 0 3
33118: PPUSH
33119: CALL_OW 110
33123: PUSH
33124: LD_INT 0
33126: NONEQUAL
33127: IFFALSE 33131
// continue ;
33129: GO 33111
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
33131: LD_VAR 0 3
33135: PPUSH
33136: CALL_OW 256
33140: PUSH
33141: LD_INT 1000
33143: LESS
33144: PUSH
33145: LD_VAR 0 3
33149: PPUSH
33150: LD_EXP 74
33154: PUSH
33155: LD_VAR 0 2
33159: ARRAY
33160: PPUSH
33161: CALL_OW 308
33165: NOT
33166: AND
33167: IFFALSE 33189
// ComMoveToArea ( j , mc_parking [ i ] ) ;
33169: LD_VAR 0 3
33173: PPUSH
33174: LD_EXP 74
33178: PUSH
33179: LD_VAR 0 2
33183: ARRAY
33184: PPUSH
33185: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
33189: LD_VAR 0 3
33193: PPUSH
33194: CALL_OW 256
33198: PUSH
33199: LD_INT 1000
33201: LESS
33202: PUSH
33203: LD_VAR 0 3
33207: PPUSH
33208: LD_EXP 74
33212: PUSH
33213: LD_VAR 0 2
33217: ARRAY
33218: PPUSH
33219: CALL_OW 308
33223: AND
33224: IFFALSE 33228
// continue ;
33226: GO 33111
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
33228: LD_VAR 0 3
33232: PPUSH
33233: CALL_OW 262
33237: PUSH
33238: LD_INT 2
33240: EQUAL
33241: PUSH
33242: LD_VAR 0 3
33246: PPUSH
33247: CALL_OW 261
33251: PUSH
33252: LD_INT 15
33254: LESS
33255: AND
33256: IFFALSE 33260
// continue ;
33258: GO 33111
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
33260: LD_VAR 0 3
33264: PPUSH
33265: CALL_OW 262
33269: PUSH
33270: LD_INT 1
33272: EQUAL
33273: PUSH
33274: LD_VAR 0 3
33278: PPUSH
33279: CALL_OW 261
33283: PUSH
33284: LD_INT 10
33286: LESS
33287: AND
33288: IFFALSE 33568
// begin if not depot then
33290: LD_VAR 0 9
33294: NOT
33295: IFFALSE 33299
// continue ;
33297: GO 33111
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
33299: LD_VAR 0 3
33303: PPUSH
33304: LD_VAR 0 9
33308: PPUSH
33309: LD_VAR 0 3
33313: PPUSH
33314: CALL_OW 74
33318: PPUSH
33319: CALL_OW 296
33323: PUSH
33324: LD_INT 6
33326: LESS
33327: IFFALSE 33343
// SetFuel ( j , 100 ) else
33329: LD_VAR 0 3
33333: PPUSH
33334: LD_INT 100
33336: PPUSH
33337: CALL_OW 240
33341: GO 33568
// if GetFuel ( j ) = 0 then
33343: LD_VAR 0 3
33347: PPUSH
33348: CALL_OW 261
33352: PUSH
33353: LD_INT 0
33355: EQUAL
33356: IFFALSE 33568
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
33358: LD_ADDR_EXP 69
33362: PUSH
33363: LD_EXP 69
33367: PPUSH
33368: LD_VAR 0 2
33372: PPUSH
33373: LD_EXP 69
33377: PUSH
33378: LD_VAR 0 2
33382: ARRAY
33383: PUSH
33384: LD_VAR 0 3
33388: DIFF
33389: PPUSH
33390: CALL_OW 1
33394: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
33395: LD_VAR 0 3
33399: PPUSH
33400: CALL_OW 263
33404: PUSH
33405: LD_INT 1
33407: EQUAL
33408: IFFALSE 33424
// ComExitVehicle ( IsInUnit ( j ) ) ;
33410: LD_VAR 0 3
33414: PPUSH
33415: CALL_OW 310
33419: PPUSH
33420: CALL_OW 121
// if GetControl ( j ) = control_remote then
33424: LD_VAR 0 3
33428: PPUSH
33429: CALL_OW 263
33433: PUSH
33434: LD_INT 2
33436: EQUAL
33437: IFFALSE 33448
// ComUnlink ( j ) ;
33439: LD_VAR 0 3
33443: PPUSH
33444: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
33448: LD_ADDR_VAR 0 10
33452: PUSH
33453: LD_VAR 0 2
33457: PPUSH
33458: LD_INT 3
33460: PPUSH
33461: CALL 43212 0 2
33465: ST_TO_ADDR
// if fac then
33466: LD_VAR 0 10
33470: IFFALSE 33566
// begin for k in fac do
33472: LD_ADDR_VAR 0 4
33476: PUSH
33477: LD_VAR 0 10
33481: PUSH
33482: FOR_IN
33483: IFFALSE 33564
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
33485: LD_ADDR_VAR 0 11
33489: PUSH
33490: LD_VAR 0 10
33494: PPUSH
33495: LD_VAR 0 3
33499: PPUSH
33500: CALL_OW 265
33504: PPUSH
33505: LD_VAR 0 3
33509: PPUSH
33510: CALL_OW 262
33514: PPUSH
33515: LD_VAR 0 3
33519: PPUSH
33520: CALL_OW 263
33524: PPUSH
33525: LD_VAR 0 3
33529: PPUSH
33530: CALL_OW 264
33534: PPUSH
33535: CALL 51643 0 5
33539: ST_TO_ADDR
// if components then
33540: LD_VAR 0 11
33544: IFFALSE 33562
// begin MC_InsertProduceList ( i , components ) ;
33546: LD_VAR 0 2
33550: PPUSH
33551: LD_VAR 0 11
33555: PPUSH
33556: CALL 42757 0 2
// break ;
33560: GO 33564
// end ; end ;
33562: GO 33482
33564: POP
33565: POP
// end ; continue ;
33566: GO 33111
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
33568: LD_VAR 0 3
33572: PPUSH
33573: LD_INT 1
33575: PPUSH
33576: CALL_OW 289
33580: PUSH
33581: LD_INT 100
33583: LESS
33584: PUSH
33585: LD_VAR 0 3
33589: PPUSH
33590: CALL_OW 314
33594: NOT
33595: AND
33596: IFFALSE 33625
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
33598: LD_VAR 0 3
33602: PPUSH
33603: LD_VAR 0 7
33607: PUSH
33608: LD_INT 2
33610: ARRAY
33611: PPUSH
33612: LD_VAR 0 7
33616: PUSH
33617: LD_INT 3
33619: ARRAY
33620: PPUSH
33621: CALL_OW 117
// break ;
33625: GO 33629
// end ;
33627: GO 33111
33629: POP
33630: POP
// end ; end ;
33631: GO 31827
33633: POP
33634: POP
// end ;
33635: LD_VAR 0 1
33639: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
33640: LD_INT 0
33642: PPUSH
33643: PPUSH
33644: PPUSH
33645: PPUSH
// if not mc_bases then
33646: LD_EXP 50
33650: NOT
33651: IFFALSE 33655
// exit ;
33653: GO 33816
// for i = 1 to mc_bases do
33655: LD_ADDR_VAR 0 2
33659: PUSH
33660: DOUBLE
33661: LD_INT 1
33663: DEC
33664: ST_TO_ADDR
33665: LD_EXP 50
33669: PUSH
33670: FOR_TO
33671: IFFALSE 33814
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
33673: LD_ADDR_VAR 0 4
33677: PUSH
33678: LD_EXP 69
33682: PUSH
33683: LD_VAR 0 2
33687: ARRAY
33688: PUSH
33689: LD_EXP 72
33693: PUSH
33694: LD_VAR 0 2
33698: ARRAY
33699: UNION
33700: PPUSH
33701: LD_INT 33
33703: PUSH
33704: LD_INT 2
33706: PUSH
33707: EMPTY
33708: LIST
33709: LIST
33710: PPUSH
33711: CALL_OW 72
33715: ST_TO_ADDR
// if tmp then
33716: LD_VAR 0 4
33720: IFFALSE 33812
// for j in tmp do
33722: LD_ADDR_VAR 0 3
33726: PUSH
33727: LD_VAR 0 4
33731: PUSH
33732: FOR_IN
33733: IFFALSE 33810
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
33735: LD_VAR 0 3
33739: PPUSH
33740: CALL_OW 312
33744: NOT
33745: PUSH
33746: LD_VAR 0 3
33750: PPUSH
33751: CALL_OW 256
33755: PUSH
33756: LD_INT 250
33758: GREATEREQUAL
33759: AND
33760: IFFALSE 33773
// Connect ( j ) else
33762: LD_VAR 0 3
33766: PPUSH
33767: CALL 57491 0 1
33771: GO 33808
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
33773: LD_VAR 0 3
33777: PPUSH
33778: CALL_OW 256
33782: PUSH
33783: LD_INT 250
33785: LESS
33786: PUSH
33787: LD_VAR 0 3
33791: PPUSH
33792: CALL_OW 312
33796: AND
33797: IFFALSE 33808
// ComUnlink ( j ) ;
33799: LD_VAR 0 3
33803: PPUSH
33804: CALL_OW 136
33808: GO 33732
33810: POP
33811: POP
// end ;
33812: GO 33670
33814: POP
33815: POP
// end ;
33816: LD_VAR 0 1
33820: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
33821: LD_INT 0
33823: PPUSH
33824: PPUSH
33825: PPUSH
33826: PPUSH
33827: PPUSH
// if not mc_bases then
33828: LD_EXP 50
33832: NOT
33833: IFFALSE 33837
// exit ;
33835: GO 34282
// for i = 1 to mc_bases do
33837: LD_ADDR_VAR 0 2
33841: PUSH
33842: DOUBLE
33843: LD_INT 1
33845: DEC
33846: ST_TO_ADDR
33847: LD_EXP 50
33851: PUSH
33852: FOR_TO
33853: IFFALSE 34280
// begin if not mc_produce [ i ] then
33855: LD_EXP 71
33859: PUSH
33860: LD_VAR 0 2
33864: ARRAY
33865: NOT
33866: IFFALSE 33870
// continue ;
33868: GO 33852
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
33870: LD_ADDR_VAR 0 5
33874: PUSH
33875: LD_EXP 50
33879: PUSH
33880: LD_VAR 0 2
33884: ARRAY
33885: PPUSH
33886: LD_INT 30
33888: PUSH
33889: LD_INT 3
33891: PUSH
33892: EMPTY
33893: LIST
33894: LIST
33895: PPUSH
33896: CALL_OW 72
33900: ST_TO_ADDR
// if not fac then
33901: LD_VAR 0 5
33905: NOT
33906: IFFALSE 33910
// continue ;
33908: GO 33852
// for j in fac do
33910: LD_ADDR_VAR 0 3
33914: PUSH
33915: LD_VAR 0 5
33919: PUSH
33920: FOR_IN
33921: IFFALSE 34276
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
33923: LD_VAR 0 3
33927: PPUSH
33928: CALL_OW 461
33932: PUSH
33933: LD_INT 2
33935: NONEQUAL
33936: PUSH
33937: LD_VAR 0 3
33941: PPUSH
33942: LD_INT 15
33944: PPUSH
33945: CALL 57110 0 2
33949: PUSH
33950: LD_INT 4
33952: ARRAY
33953: OR
33954: IFFALSE 33958
// continue ;
33956: GO 33920
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
33958: LD_VAR 0 3
33962: PPUSH
33963: LD_EXP 71
33967: PUSH
33968: LD_VAR 0 2
33972: ARRAY
33973: PUSH
33974: LD_INT 1
33976: ARRAY
33977: PUSH
33978: LD_INT 1
33980: ARRAY
33981: PPUSH
33982: LD_EXP 71
33986: PUSH
33987: LD_VAR 0 2
33991: ARRAY
33992: PUSH
33993: LD_INT 1
33995: ARRAY
33996: PUSH
33997: LD_INT 2
33999: ARRAY
34000: PPUSH
34001: LD_EXP 71
34005: PUSH
34006: LD_VAR 0 2
34010: ARRAY
34011: PUSH
34012: LD_INT 1
34014: ARRAY
34015: PUSH
34016: LD_INT 3
34018: ARRAY
34019: PPUSH
34020: LD_EXP 71
34024: PUSH
34025: LD_VAR 0 2
34029: ARRAY
34030: PUSH
34031: LD_INT 1
34033: ARRAY
34034: PUSH
34035: LD_INT 4
34037: ARRAY
34038: PPUSH
34039: CALL_OW 448
34043: PUSH
34044: LD_VAR 0 3
34048: PPUSH
34049: LD_EXP 71
34053: PUSH
34054: LD_VAR 0 2
34058: ARRAY
34059: PUSH
34060: LD_INT 1
34062: ARRAY
34063: PUSH
34064: LD_INT 1
34066: ARRAY
34067: PUSH
34068: LD_EXP 71
34072: PUSH
34073: LD_VAR 0 2
34077: ARRAY
34078: PUSH
34079: LD_INT 1
34081: ARRAY
34082: PUSH
34083: LD_INT 2
34085: ARRAY
34086: PUSH
34087: LD_EXP 71
34091: PUSH
34092: LD_VAR 0 2
34096: ARRAY
34097: PUSH
34098: LD_INT 1
34100: ARRAY
34101: PUSH
34102: LD_INT 3
34104: ARRAY
34105: PUSH
34106: LD_EXP 71
34110: PUSH
34111: LD_VAR 0 2
34115: ARRAY
34116: PUSH
34117: LD_INT 1
34119: ARRAY
34120: PUSH
34121: LD_INT 4
34123: ARRAY
34124: PUSH
34125: EMPTY
34126: LIST
34127: LIST
34128: LIST
34129: LIST
34130: PPUSH
34131: CALL 60886 0 2
34135: AND
34136: IFFALSE 34274
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
34138: LD_VAR 0 3
34142: PPUSH
34143: LD_EXP 71
34147: PUSH
34148: LD_VAR 0 2
34152: ARRAY
34153: PUSH
34154: LD_INT 1
34156: ARRAY
34157: PUSH
34158: LD_INT 1
34160: ARRAY
34161: PPUSH
34162: LD_EXP 71
34166: PUSH
34167: LD_VAR 0 2
34171: ARRAY
34172: PUSH
34173: LD_INT 1
34175: ARRAY
34176: PUSH
34177: LD_INT 2
34179: ARRAY
34180: PPUSH
34181: LD_EXP 71
34185: PUSH
34186: LD_VAR 0 2
34190: ARRAY
34191: PUSH
34192: LD_INT 1
34194: ARRAY
34195: PUSH
34196: LD_INT 3
34198: ARRAY
34199: PPUSH
34200: LD_EXP 71
34204: PUSH
34205: LD_VAR 0 2
34209: ARRAY
34210: PUSH
34211: LD_INT 1
34213: ARRAY
34214: PUSH
34215: LD_INT 4
34217: ARRAY
34218: PPUSH
34219: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
34223: LD_ADDR_VAR 0 4
34227: PUSH
34228: LD_EXP 71
34232: PUSH
34233: LD_VAR 0 2
34237: ARRAY
34238: PPUSH
34239: LD_INT 1
34241: PPUSH
34242: CALL_OW 3
34246: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
34247: LD_ADDR_EXP 71
34251: PUSH
34252: LD_EXP 71
34256: PPUSH
34257: LD_VAR 0 2
34261: PPUSH
34262: LD_VAR 0 4
34266: PPUSH
34267: CALL_OW 1
34271: ST_TO_ADDR
// break ;
34272: GO 34276
// end ; end ;
34274: GO 33920
34276: POP
34277: POP
// end ;
34278: GO 33852
34280: POP
34281: POP
// end ;
34282: LD_VAR 0 1
34286: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
34287: LD_INT 0
34289: PPUSH
34290: PPUSH
34291: PPUSH
// if not mc_bases then
34292: LD_EXP 50
34296: NOT
34297: IFFALSE 34301
// exit ;
34299: GO 34390
// for i = 1 to mc_bases do
34301: LD_ADDR_VAR 0 2
34305: PUSH
34306: DOUBLE
34307: LD_INT 1
34309: DEC
34310: ST_TO_ADDR
34311: LD_EXP 50
34315: PUSH
34316: FOR_TO
34317: IFFALSE 34388
// begin if mc_attack [ i ] then
34319: LD_EXP 70
34323: PUSH
34324: LD_VAR 0 2
34328: ARRAY
34329: IFFALSE 34386
// begin tmp := mc_attack [ i ] [ 1 ] ;
34331: LD_ADDR_VAR 0 3
34335: PUSH
34336: LD_EXP 70
34340: PUSH
34341: LD_VAR 0 2
34345: ARRAY
34346: PUSH
34347: LD_INT 1
34349: ARRAY
34350: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
34351: LD_ADDR_EXP 70
34355: PUSH
34356: LD_EXP 70
34360: PPUSH
34361: LD_VAR 0 2
34365: PPUSH
34366: EMPTY
34367: PPUSH
34368: CALL_OW 1
34372: ST_TO_ADDR
// Attack ( tmp ) ;
34373: LD_VAR 0 3
34377: PPUSH
34378: CALL 112667 0 1
// exit ;
34382: POP
34383: POP
34384: GO 34390
// end ; end ;
34386: GO 34316
34388: POP
34389: POP
// end ;
34390: LD_VAR 0 1
34394: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
34395: LD_INT 0
34397: PPUSH
34398: PPUSH
34399: PPUSH
34400: PPUSH
34401: PPUSH
34402: PPUSH
34403: PPUSH
// if not mc_bases then
34404: LD_EXP 50
34408: NOT
34409: IFFALSE 34413
// exit ;
34411: GO 35270
// for i = 1 to mc_bases do
34413: LD_ADDR_VAR 0 2
34417: PUSH
34418: DOUBLE
34419: LD_INT 1
34421: DEC
34422: ST_TO_ADDR
34423: LD_EXP 50
34427: PUSH
34428: FOR_TO
34429: IFFALSE 35268
// begin if not mc_bases [ i ] then
34431: LD_EXP 50
34435: PUSH
34436: LD_VAR 0 2
34440: ARRAY
34441: NOT
34442: IFFALSE 34446
// continue ;
34444: GO 34428
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
34446: LD_ADDR_VAR 0 7
34450: PUSH
34451: LD_EXP 50
34455: PUSH
34456: LD_VAR 0 2
34460: ARRAY
34461: PUSH
34462: LD_INT 1
34464: ARRAY
34465: PPUSH
34466: CALL 50969 0 1
34470: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
34471: LD_ADDR_EXP 73
34475: PUSH
34476: LD_EXP 73
34480: PPUSH
34481: LD_VAR 0 2
34485: PPUSH
34486: LD_EXP 50
34490: PUSH
34491: LD_VAR 0 2
34495: ARRAY
34496: PUSH
34497: LD_INT 1
34499: ARRAY
34500: PPUSH
34501: CALL_OW 255
34505: PPUSH
34506: LD_EXP 75
34510: PUSH
34511: LD_VAR 0 2
34515: ARRAY
34516: PPUSH
34517: CALL 50934 0 2
34521: PPUSH
34522: CALL_OW 1
34526: ST_TO_ADDR
// if not mc_scan [ i ] then
34527: LD_EXP 73
34531: PUSH
34532: LD_VAR 0 2
34536: ARRAY
34537: NOT
34538: IFFALSE 34716
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
34540: LD_ADDR_EXP 93
34544: PUSH
34545: LD_EXP 93
34549: PPUSH
34550: LD_VAR 0 2
34554: PPUSH
34555: LD_INT 0
34557: PPUSH
34558: CALL_OW 1
34562: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
34563: LD_ADDR_VAR 0 4
34567: PUSH
34568: LD_EXP 50
34572: PUSH
34573: LD_VAR 0 2
34577: ARRAY
34578: PPUSH
34579: LD_INT 2
34581: PUSH
34582: LD_INT 25
34584: PUSH
34585: LD_INT 5
34587: PUSH
34588: EMPTY
34589: LIST
34590: LIST
34591: PUSH
34592: LD_INT 25
34594: PUSH
34595: LD_INT 8
34597: PUSH
34598: EMPTY
34599: LIST
34600: LIST
34601: PUSH
34602: LD_INT 25
34604: PUSH
34605: LD_INT 9
34607: PUSH
34608: EMPTY
34609: LIST
34610: LIST
34611: PUSH
34612: EMPTY
34613: LIST
34614: LIST
34615: LIST
34616: LIST
34617: PPUSH
34618: CALL_OW 72
34622: ST_TO_ADDR
// if not tmp then
34623: LD_VAR 0 4
34627: NOT
34628: IFFALSE 34632
// continue ;
34630: GO 34428
// for j in tmp do
34632: LD_ADDR_VAR 0 3
34636: PUSH
34637: LD_VAR 0 4
34641: PUSH
34642: FOR_IN
34643: IFFALSE 34714
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
34645: LD_VAR 0 3
34649: PPUSH
34650: CALL_OW 310
34654: PPUSH
34655: CALL_OW 266
34659: PUSH
34660: LD_INT 5
34662: EQUAL
34663: PUSH
34664: LD_VAR 0 3
34668: PPUSH
34669: CALL_OW 257
34673: PUSH
34674: LD_INT 1
34676: EQUAL
34677: AND
34678: PUSH
34679: LD_VAR 0 3
34683: PPUSH
34684: CALL_OW 459
34688: NOT
34689: AND
34690: PUSH
34691: LD_VAR 0 7
34695: AND
34696: IFFALSE 34712
// ComChangeProfession ( j , class ) ;
34698: LD_VAR 0 3
34702: PPUSH
34703: LD_VAR 0 7
34707: PPUSH
34708: CALL_OW 123
34712: GO 34642
34714: POP
34715: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
34716: LD_EXP 73
34720: PUSH
34721: LD_VAR 0 2
34725: ARRAY
34726: PUSH
34727: LD_EXP 93
34731: PUSH
34732: LD_VAR 0 2
34736: ARRAY
34737: NOT
34738: AND
34739: PUSH
34740: LD_EXP 72
34744: PUSH
34745: LD_VAR 0 2
34749: ARRAY
34750: NOT
34751: AND
34752: PUSH
34753: LD_EXP 50
34757: PUSH
34758: LD_VAR 0 2
34762: ARRAY
34763: PPUSH
34764: LD_INT 50
34766: PUSH
34767: EMPTY
34768: LIST
34769: PUSH
34770: LD_INT 2
34772: PUSH
34773: LD_INT 30
34775: PUSH
34776: LD_INT 32
34778: PUSH
34779: EMPTY
34780: LIST
34781: LIST
34782: PUSH
34783: LD_INT 30
34785: PUSH
34786: LD_INT 33
34788: PUSH
34789: EMPTY
34790: LIST
34791: LIST
34792: PUSH
34793: LD_INT 30
34795: PUSH
34796: LD_INT 4
34798: PUSH
34799: EMPTY
34800: LIST
34801: LIST
34802: PUSH
34803: LD_INT 30
34805: PUSH
34806: LD_INT 5
34808: PUSH
34809: EMPTY
34810: LIST
34811: LIST
34812: PUSH
34813: EMPTY
34814: LIST
34815: LIST
34816: LIST
34817: LIST
34818: LIST
34819: PUSH
34820: EMPTY
34821: LIST
34822: LIST
34823: PPUSH
34824: CALL_OW 72
34828: PUSH
34829: LD_INT 4
34831: LESS
34832: PUSH
34833: LD_EXP 50
34837: PUSH
34838: LD_VAR 0 2
34842: ARRAY
34843: PPUSH
34844: LD_INT 3
34846: PUSH
34847: LD_INT 24
34849: PUSH
34850: LD_INT 1000
34852: PUSH
34853: EMPTY
34854: LIST
34855: LIST
34856: PUSH
34857: EMPTY
34858: LIST
34859: LIST
34860: PUSH
34861: LD_INT 2
34863: PUSH
34864: LD_INT 30
34866: PUSH
34867: LD_INT 0
34869: PUSH
34870: EMPTY
34871: LIST
34872: LIST
34873: PUSH
34874: LD_INT 30
34876: PUSH
34877: LD_INT 1
34879: PUSH
34880: EMPTY
34881: LIST
34882: LIST
34883: PUSH
34884: EMPTY
34885: LIST
34886: LIST
34887: LIST
34888: PUSH
34889: EMPTY
34890: LIST
34891: LIST
34892: PPUSH
34893: CALL_OW 72
34897: OR
34898: AND
34899: IFFALSE 35150
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
34901: LD_ADDR_EXP 93
34905: PUSH
34906: LD_EXP 93
34910: PPUSH
34911: LD_VAR 0 2
34915: PPUSH
34916: LD_INT 1
34918: PPUSH
34919: CALL_OW 1
34923: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
34924: LD_ADDR_VAR 0 4
34928: PUSH
34929: LD_EXP 50
34933: PUSH
34934: LD_VAR 0 2
34938: ARRAY
34939: PPUSH
34940: LD_INT 2
34942: PUSH
34943: LD_INT 25
34945: PUSH
34946: LD_INT 1
34948: PUSH
34949: EMPTY
34950: LIST
34951: LIST
34952: PUSH
34953: LD_INT 25
34955: PUSH
34956: LD_INT 5
34958: PUSH
34959: EMPTY
34960: LIST
34961: LIST
34962: PUSH
34963: LD_INT 25
34965: PUSH
34966: LD_INT 8
34968: PUSH
34969: EMPTY
34970: LIST
34971: LIST
34972: PUSH
34973: LD_INT 25
34975: PUSH
34976: LD_INT 9
34978: PUSH
34979: EMPTY
34980: LIST
34981: LIST
34982: PUSH
34983: EMPTY
34984: LIST
34985: LIST
34986: LIST
34987: LIST
34988: LIST
34989: PPUSH
34990: CALL_OW 72
34994: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
34995: LD_ADDR_VAR 0 4
34999: PUSH
35000: LD_VAR 0 4
35004: PUSH
35005: LD_VAR 0 4
35009: PPUSH
35010: LD_INT 18
35012: PPUSH
35013: CALL 84443 0 2
35017: DIFF
35018: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
35019: LD_VAR 0 4
35023: NOT
35024: PUSH
35025: LD_EXP 50
35029: PUSH
35030: LD_VAR 0 2
35034: ARRAY
35035: PPUSH
35036: LD_INT 2
35038: PUSH
35039: LD_INT 30
35041: PUSH
35042: LD_INT 4
35044: PUSH
35045: EMPTY
35046: LIST
35047: LIST
35048: PUSH
35049: LD_INT 30
35051: PUSH
35052: LD_INT 5
35054: PUSH
35055: EMPTY
35056: LIST
35057: LIST
35058: PUSH
35059: EMPTY
35060: LIST
35061: LIST
35062: LIST
35063: PPUSH
35064: CALL_OW 72
35068: NOT
35069: AND
35070: IFFALSE 35132
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
35072: LD_ADDR_VAR 0 4
35076: PUSH
35077: LD_EXP 50
35081: PUSH
35082: LD_VAR 0 2
35086: ARRAY
35087: PPUSH
35088: LD_INT 2
35090: PUSH
35091: LD_INT 25
35093: PUSH
35094: LD_INT 2
35096: PUSH
35097: EMPTY
35098: LIST
35099: LIST
35100: PUSH
35101: LD_INT 25
35103: PUSH
35104: LD_INT 3
35106: PUSH
35107: EMPTY
35108: LIST
35109: LIST
35110: PUSH
35111: LD_INT 25
35113: PUSH
35114: LD_INT 4
35116: PUSH
35117: EMPTY
35118: LIST
35119: LIST
35120: PUSH
35121: EMPTY
35122: LIST
35123: LIST
35124: LIST
35125: LIST
35126: PPUSH
35127: CALL_OW 72
35131: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
35132: LD_VAR 0 2
35136: PPUSH
35137: LD_VAR 0 4
35141: PPUSH
35142: CALL 117376 0 2
// exit ;
35146: POP
35147: POP
35148: GO 35270
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
35150: LD_EXP 73
35154: PUSH
35155: LD_VAR 0 2
35159: ARRAY
35160: PUSH
35161: LD_EXP 93
35165: PUSH
35166: LD_VAR 0 2
35170: ARRAY
35171: NOT
35172: AND
35173: PUSH
35174: LD_EXP 72
35178: PUSH
35179: LD_VAR 0 2
35183: ARRAY
35184: AND
35185: IFFALSE 35266
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
35187: LD_ADDR_EXP 93
35191: PUSH
35192: LD_EXP 93
35196: PPUSH
35197: LD_VAR 0 2
35201: PPUSH
35202: LD_INT 1
35204: PPUSH
35205: CALL_OW 1
35209: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
35210: LD_ADDR_VAR 0 4
35214: PUSH
35215: LD_EXP 72
35219: PUSH
35220: LD_VAR 0 2
35224: ARRAY
35225: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
35226: LD_ADDR_EXP 72
35230: PUSH
35231: LD_EXP 72
35235: PPUSH
35236: LD_VAR 0 2
35240: PPUSH
35241: EMPTY
35242: PPUSH
35243: CALL_OW 1
35247: ST_TO_ADDR
// Defend ( i , tmp ) ;
35248: LD_VAR 0 2
35252: PPUSH
35253: LD_VAR 0 4
35257: PPUSH
35258: CALL 117972 0 2
// exit ;
35262: POP
35263: POP
35264: GO 35270
// end ; end ;
35266: GO 34428
35268: POP
35269: POP
// end ;
35270: LD_VAR 0 1
35274: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
35275: LD_INT 0
35277: PPUSH
35278: PPUSH
35279: PPUSH
35280: PPUSH
35281: PPUSH
35282: PPUSH
35283: PPUSH
35284: PPUSH
35285: PPUSH
35286: PPUSH
35287: PPUSH
// if not mc_bases then
35288: LD_EXP 50
35292: NOT
35293: IFFALSE 35297
// exit ;
35295: GO 36384
// for i = 1 to mc_bases do
35297: LD_ADDR_VAR 0 2
35301: PUSH
35302: DOUBLE
35303: LD_INT 1
35305: DEC
35306: ST_TO_ADDR
35307: LD_EXP 50
35311: PUSH
35312: FOR_TO
35313: IFFALSE 36382
// begin tmp := mc_lab [ i ] ;
35315: LD_ADDR_VAR 0 6
35319: PUSH
35320: LD_EXP 83
35324: PUSH
35325: LD_VAR 0 2
35329: ARRAY
35330: ST_TO_ADDR
// if not tmp then
35331: LD_VAR 0 6
35335: NOT
35336: IFFALSE 35340
// continue ;
35338: GO 35312
// idle_lab := 0 ;
35340: LD_ADDR_VAR 0 11
35344: PUSH
35345: LD_INT 0
35347: ST_TO_ADDR
// for j in tmp do
35348: LD_ADDR_VAR 0 3
35352: PUSH
35353: LD_VAR 0 6
35357: PUSH
35358: FOR_IN
35359: IFFALSE 36378
// begin researching := false ;
35361: LD_ADDR_VAR 0 10
35365: PUSH
35366: LD_INT 0
35368: ST_TO_ADDR
// side := GetSide ( j ) ;
35369: LD_ADDR_VAR 0 4
35373: PUSH
35374: LD_VAR 0 3
35378: PPUSH
35379: CALL_OW 255
35383: ST_TO_ADDR
// if not mc_tech [ side ] then
35384: LD_EXP 77
35388: PUSH
35389: LD_VAR 0 4
35393: ARRAY
35394: NOT
35395: IFFALSE 35399
// continue ;
35397: GO 35358
// if BuildingStatus ( j ) = bs_idle then
35399: LD_VAR 0 3
35403: PPUSH
35404: CALL_OW 461
35408: PUSH
35409: LD_INT 2
35411: EQUAL
35412: IFFALSE 35600
// begin if idle_lab and UnitsInside ( j ) < 6 then
35414: LD_VAR 0 11
35418: PUSH
35419: LD_VAR 0 3
35423: PPUSH
35424: CALL_OW 313
35428: PUSH
35429: LD_INT 6
35431: LESS
35432: AND
35433: IFFALSE 35504
// begin tmp2 := UnitsInside ( idle_lab ) ;
35435: LD_ADDR_VAR 0 9
35439: PUSH
35440: LD_VAR 0 11
35444: PPUSH
35445: CALL_OW 313
35449: ST_TO_ADDR
// if tmp2 then
35450: LD_VAR 0 9
35454: IFFALSE 35496
// for x in tmp2 do
35456: LD_ADDR_VAR 0 7
35460: PUSH
35461: LD_VAR 0 9
35465: PUSH
35466: FOR_IN
35467: IFFALSE 35494
// begin ComExitBuilding ( x ) ;
35469: LD_VAR 0 7
35473: PPUSH
35474: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
35478: LD_VAR 0 7
35482: PPUSH
35483: LD_VAR 0 3
35487: PPUSH
35488: CALL_OW 180
// end ;
35492: GO 35466
35494: POP
35495: POP
// idle_lab := 0 ;
35496: LD_ADDR_VAR 0 11
35500: PUSH
35501: LD_INT 0
35503: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
35504: LD_ADDR_VAR 0 5
35508: PUSH
35509: LD_EXP 77
35513: PUSH
35514: LD_VAR 0 4
35518: ARRAY
35519: PUSH
35520: FOR_IN
35521: IFFALSE 35581
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
35523: LD_VAR 0 3
35527: PPUSH
35528: LD_VAR 0 5
35532: PPUSH
35533: CALL_OW 430
35537: PUSH
35538: LD_VAR 0 4
35542: PPUSH
35543: LD_VAR 0 5
35547: PPUSH
35548: CALL 50039 0 2
35552: AND
35553: IFFALSE 35579
// begin researching := true ;
35555: LD_ADDR_VAR 0 10
35559: PUSH
35560: LD_INT 1
35562: ST_TO_ADDR
// ComResearch ( j , t ) ;
35563: LD_VAR 0 3
35567: PPUSH
35568: LD_VAR 0 5
35572: PPUSH
35573: CALL_OW 124
// break ;
35577: GO 35581
// end ;
35579: GO 35520
35581: POP
35582: POP
// if not researching then
35583: LD_VAR 0 10
35587: NOT
35588: IFFALSE 35600
// idle_lab := j ;
35590: LD_ADDR_VAR 0 11
35594: PUSH
35595: LD_VAR 0 3
35599: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
35600: LD_VAR 0 3
35604: PPUSH
35605: CALL_OW 461
35609: PUSH
35610: LD_INT 10
35612: EQUAL
35613: IFFALSE 36201
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
35615: LD_EXP 79
35619: PUSH
35620: LD_VAR 0 2
35624: ARRAY
35625: NOT
35626: PUSH
35627: LD_EXP 80
35631: PUSH
35632: LD_VAR 0 2
35636: ARRAY
35637: NOT
35638: AND
35639: PUSH
35640: LD_EXP 77
35644: PUSH
35645: LD_VAR 0 4
35649: ARRAY
35650: PUSH
35651: LD_INT 1
35653: GREATER
35654: AND
35655: IFFALSE 35786
// begin ComCancel ( j ) ;
35657: LD_VAR 0 3
35661: PPUSH
35662: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
35666: LD_ADDR_EXP 77
35670: PUSH
35671: LD_EXP 77
35675: PPUSH
35676: LD_VAR 0 4
35680: PPUSH
35681: LD_EXP 77
35685: PUSH
35686: LD_VAR 0 4
35690: ARRAY
35691: PPUSH
35692: LD_EXP 77
35696: PUSH
35697: LD_VAR 0 4
35701: ARRAY
35702: PUSH
35703: LD_INT 1
35705: MINUS
35706: PPUSH
35707: LD_EXP 77
35711: PUSH
35712: LD_VAR 0 4
35716: ARRAY
35717: PPUSH
35718: LD_INT 0
35720: PPUSH
35721: CALL 53563 0 4
35725: PPUSH
35726: CALL_OW 1
35730: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
35731: LD_ADDR_EXP 77
35735: PUSH
35736: LD_EXP 77
35740: PPUSH
35741: LD_VAR 0 4
35745: PPUSH
35746: LD_EXP 77
35750: PUSH
35751: LD_VAR 0 4
35755: ARRAY
35756: PPUSH
35757: LD_EXP 77
35761: PUSH
35762: LD_VAR 0 4
35766: ARRAY
35767: PPUSH
35768: LD_INT 1
35770: PPUSH
35771: LD_INT 0
35773: PPUSH
35774: CALL 53563 0 4
35778: PPUSH
35779: CALL_OW 1
35783: ST_TO_ADDR
// continue ;
35784: GO 35358
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
35786: LD_EXP 79
35790: PUSH
35791: LD_VAR 0 2
35795: ARRAY
35796: PUSH
35797: LD_EXP 80
35801: PUSH
35802: LD_VAR 0 2
35806: ARRAY
35807: NOT
35808: AND
35809: IFFALSE 35936
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
35811: LD_ADDR_EXP 80
35815: PUSH
35816: LD_EXP 80
35820: PPUSH
35821: LD_VAR 0 2
35825: PUSH
35826: LD_EXP 80
35830: PUSH
35831: LD_VAR 0 2
35835: ARRAY
35836: PUSH
35837: LD_INT 1
35839: PLUS
35840: PUSH
35841: EMPTY
35842: LIST
35843: LIST
35844: PPUSH
35845: LD_EXP 79
35849: PUSH
35850: LD_VAR 0 2
35854: ARRAY
35855: PUSH
35856: LD_INT 1
35858: ARRAY
35859: PPUSH
35860: CALL 54145 0 3
35864: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
35865: LD_EXP 79
35869: PUSH
35870: LD_VAR 0 2
35874: ARRAY
35875: PUSH
35876: LD_INT 1
35878: ARRAY
35879: PPUSH
35880: LD_INT 112
35882: PPUSH
35883: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
35887: LD_ADDR_VAR 0 9
35891: PUSH
35892: LD_EXP 79
35896: PUSH
35897: LD_VAR 0 2
35901: ARRAY
35902: PPUSH
35903: LD_INT 1
35905: PPUSH
35906: CALL_OW 3
35910: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
35911: LD_ADDR_EXP 79
35915: PUSH
35916: LD_EXP 79
35920: PPUSH
35921: LD_VAR 0 2
35925: PPUSH
35926: LD_VAR 0 9
35930: PPUSH
35931: CALL_OW 1
35935: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
35936: LD_EXP 79
35940: PUSH
35941: LD_VAR 0 2
35945: ARRAY
35946: PUSH
35947: LD_EXP 80
35951: PUSH
35952: LD_VAR 0 2
35956: ARRAY
35957: AND
35958: PUSH
35959: LD_EXP 80
35963: PUSH
35964: LD_VAR 0 2
35968: ARRAY
35969: PUSH
35970: LD_INT 1
35972: ARRAY
35973: PPUSH
35974: CALL_OW 310
35978: NOT
35979: AND
35980: PUSH
35981: LD_VAR 0 3
35985: PPUSH
35986: CALL_OW 313
35990: PUSH
35991: LD_INT 6
35993: EQUAL
35994: AND
35995: IFFALSE 36051
// begin tmp2 := UnitsInside ( j ) ;
35997: LD_ADDR_VAR 0 9
36001: PUSH
36002: LD_VAR 0 3
36006: PPUSH
36007: CALL_OW 313
36011: ST_TO_ADDR
// if tmp2 = 6 then
36012: LD_VAR 0 9
36016: PUSH
36017: LD_INT 6
36019: EQUAL
36020: IFFALSE 36051
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
36022: LD_VAR 0 9
36026: PUSH
36027: LD_INT 1
36029: ARRAY
36030: PPUSH
36031: LD_INT 112
36033: PPUSH
36034: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
36038: LD_VAR 0 9
36042: PUSH
36043: LD_INT 1
36045: ARRAY
36046: PPUSH
36047: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
36051: LD_EXP 80
36055: PUSH
36056: LD_VAR 0 2
36060: ARRAY
36061: PUSH
36062: LD_EXP 80
36066: PUSH
36067: LD_VAR 0 2
36071: ARRAY
36072: PUSH
36073: LD_INT 1
36075: ARRAY
36076: PPUSH
36077: CALL_OW 314
36081: NOT
36082: AND
36083: PUSH
36084: LD_EXP 80
36088: PUSH
36089: LD_VAR 0 2
36093: ARRAY
36094: PUSH
36095: LD_INT 1
36097: ARRAY
36098: PPUSH
36099: CALL_OW 310
36103: NOT
36104: AND
36105: IFFALSE 36131
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
36107: LD_EXP 80
36111: PUSH
36112: LD_VAR 0 2
36116: ARRAY
36117: PUSH
36118: LD_INT 1
36120: ARRAY
36121: PPUSH
36122: LD_VAR 0 3
36126: PPUSH
36127: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
36131: LD_EXP 80
36135: PUSH
36136: LD_VAR 0 2
36140: ARRAY
36141: PUSH
36142: LD_INT 1
36144: ARRAY
36145: PPUSH
36146: CALL_OW 310
36150: PUSH
36151: LD_EXP 80
36155: PUSH
36156: LD_VAR 0 2
36160: ARRAY
36161: PUSH
36162: LD_INT 1
36164: ARRAY
36165: PPUSH
36166: CALL_OW 310
36170: PPUSH
36171: CALL_OW 461
36175: PUSH
36176: LD_INT 3
36178: NONEQUAL
36179: AND
36180: IFFALSE 36201
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
36182: LD_EXP 80
36186: PUSH
36187: LD_VAR 0 2
36191: ARRAY
36192: PUSH
36193: LD_INT 1
36195: ARRAY
36196: PPUSH
36197: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
36201: LD_VAR 0 3
36205: PPUSH
36206: CALL_OW 461
36210: PUSH
36211: LD_INT 6
36213: EQUAL
36214: PUSH
36215: LD_VAR 0 6
36219: PUSH
36220: LD_INT 1
36222: GREATER
36223: AND
36224: IFFALSE 36376
// begin sci := [ ] ;
36226: LD_ADDR_VAR 0 8
36230: PUSH
36231: EMPTY
36232: ST_TO_ADDR
// for x in ( tmp diff j ) do
36233: LD_ADDR_VAR 0 7
36237: PUSH
36238: LD_VAR 0 6
36242: PUSH
36243: LD_VAR 0 3
36247: DIFF
36248: PUSH
36249: FOR_IN
36250: IFFALSE 36302
// begin if sci = 6 then
36252: LD_VAR 0 8
36256: PUSH
36257: LD_INT 6
36259: EQUAL
36260: IFFALSE 36264
// break ;
36262: GO 36302
// if BuildingStatus ( x ) = bs_idle then
36264: LD_VAR 0 7
36268: PPUSH
36269: CALL_OW 461
36273: PUSH
36274: LD_INT 2
36276: EQUAL
36277: IFFALSE 36300
// sci := sci ^ UnitsInside ( x ) ;
36279: LD_ADDR_VAR 0 8
36283: PUSH
36284: LD_VAR 0 8
36288: PUSH
36289: LD_VAR 0 7
36293: PPUSH
36294: CALL_OW 313
36298: ADD
36299: ST_TO_ADDR
// end ;
36300: GO 36249
36302: POP
36303: POP
// if not sci then
36304: LD_VAR 0 8
36308: NOT
36309: IFFALSE 36313
// continue ;
36311: GO 35358
// for x in sci do
36313: LD_ADDR_VAR 0 7
36317: PUSH
36318: LD_VAR 0 8
36322: PUSH
36323: FOR_IN
36324: IFFALSE 36374
// if IsInUnit ( x ) and not HasTask ( x ) then
36326: LD_VAR 0 7
36330: PPUSH
36331: CALL_OW 310
36335: PUSH
36336: LD_VAR 0 7
36340: PPUSH
36341: CALL_OW 314
36345: NOT
36346: AND
36347: IFFALSE 36372
// begin ComExitBuilding ( x ) ;
36349: LD_VAR 0 7
36353: PPUSH
36354: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
36358: LD_VAR 0 7
36362: PPUSH
36363: LD_VAR 0 3
36367: PPUSH
36368: CALL_OW 180
// end ;
36372: GO 36323
36374: POP
36375: POP
// end ; end ;
36376: GO 35358
36378: POP
36379: POP
// end ;
36380: GO 35312
36382: POP
36383: POP
// end ;
36384: LD_VAR 0 1
36388: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
36389: LD_INT 0
36391: PPUSH
36392: PPUSH
// if not mc_bases then
36393: LD_EXP 50
36397: NOT
36398: IFFALSE 36402
// exit ;
36400: GO 36483
// for i = 1 to mc_bases do
36402: LD_ADDR_VAR 0 2
36406: PUSH
36407: DOUBLE
36408: LD_INT 1
36410: DEC
36411: ST_TO_ADDR
36412: LD_EXP 50
36416: PUSH
36417: FOR_TO
36418: IFFALSE 36481
// if mc_mines [ i ] and mc_miners [ i ] then
36420: LD_EXP 63
36424: PUSH
36425: LD_VAR 0 2
36429: ARRAY
36430: PUSH
36431: LD_EXP 64
36435: PUSH
36436: LD_VAR 0 2
36440: ARRAY
36441: AND
36442: IFFALSE 36479
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
36444: LD_EXP 64
36448: PUSH
36449: LD_VAR 0 2
36453: ARRAY
36454: PUSH
36455: LD_INT 1
36457: ARRAY
36458: PPUSH
36459: CALL_OW 255
36463: PPUSH
36464: LD_EXP 63
36468: PUSH
36469: LD_VAR 0 2
36473: ARRAY
36474: PPUSH
36475: CALL 51122 0 2
36479: GO 36417
36481: POP
36482: POP
// end ;
36483: LD_VAR 0 1
36487: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
36488: LD_INT 0
36490: PPUSH
36491: PPUSH
36492: PPUSH
36493: PPUSH
36494: PPUSH
36495: PPUSH
36496: PPUSH
36497: PPUSH
// if not mc_bases or not mc_parking then
36498: LD_EXP 50
36502: NOT
36503: PUSH
36504: LD_EXP 74
36508: NOT
36509: OR
36510: IFFALSE 36514
// exit ;
36512: GO 37252
// for i = 1 to mc_bases do
36514: LD_ADDR_VAR 0 2
36518: PUSH
36519: DOUBLE
36520: LD_INT 1
36522: DEC
36523: ST_TO_ADDR
36524: LD_EXP 50
36528: PUSH
36529: FOR_TO
36530: IFFALSE 37250
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
36532: LD_EXP 50
36536: PUSH
36537: LD_VAR 0 2
36541: ARRAY
36542: NOT
36543: PUSH
36544: LD_EXP 74
36548: PUSH
36549: LD_VAR 0 2
36553: ARRAY
36554: NOT
36555: OR
36556: IFFALSE 36560
// continue ;
36558: GO 36529
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
36560: LD_ADDR_VAR 0 5
36564: PUSH
36565: LD_EXP 50
36569: PUSH
36570: LD_VAR 0 2
36574: ARRAY
36575: PUSH
36576: LD_INT 1
36578: ARRAY
36579: PPUSH
36580: CALL_OW 255
36584: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
36585: LD_ADDR_VAR 0 6
36589: PUSH
36590: LD_EXP 50
36594: PUSH
36595: LD_VAR 0 2
36599: ARRAY
36600: PPUSH
36601: LD_INT 30
36603: PUSH
36604: LD_INT 3
36606: PUSH
36607: EMPTY
36608: LIST
36609: LIST
36610: PPUSH
36611: CALL_OW 72
36615: ST_TO_ADDR
// if not fac then
36616: LD_VAR 0 6
36620: NOT
36621: IFFALSE 36672
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
36623: LD_ADDR_VAR 0 6
36627: PUSH
36628: LD_EXP 50
36632: PUSH
36633: LD_VAR 0 2
36637: ARRAY
36638: PPUSH
36639: LD_INT 2
36641: PUSH
36642: LD_INT 30
36644: PUSH
36645: LD_INT 0
36647: PUSH
36648: EMPTY
36649: LIST
36650: LIST
36651: PUSH
36652: LD_INT 30
36654: PUSH
36655: LD_INT 1
36657: PUSH
36658: EMPTY
36659: LIST
36660: LIST
36661: PUSH
36662: EMPTY
36663: LIST
36664: LIST
36665: LIST
36666: PPUSH
36667: CALL_OW 72
36671: ST_TO_ADDR
// if not fac then
36672: LD_VAR 0 6
36676: NOT
36677: IFFALSE 36681
// continue ;
36679: GO 36529
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
36681: LD_ADDR_VAR 0 7
36685: PUSH
36686: LD_EXP 74
36690: PUSH
36691: LD_VAR 0 2
36695: ARRAY
36696: PPUSH
36697: LD_INT 22
36699: PUSH
36700: LD_VAR 0 5
36704: PUSH
36705: EMPTY
36706: LIST
36707: LIST
36708: PUSH
36709: LD_INT 21
36711: PUSH
36712: LD_INT 2
36714: PUSH
36715: EMPTY
36716: LIST
36717: LIST
36718: PUSH
36719: LD_INT 3
36721: PUSH
36722: LD_INT 60
36724: PUSH
36725: EMPTY
36726: LIST
36727: PUSH
36728: EMPTY
36729: LIST
36730: LIST
36731: PUSH
36732: LD_INT 3
36734: PUSH
36735: LD_INT 24
36737: PUSH
36738: LD_INT 1000
36740: PUSH
36741: EMPTY
36742: LIST
36743: LIST
36744: PUSH
36745: EMPTY
36746: LIST
36747: LIST
36748: PUSH
36749: EMPTY
36750: LIST
36751: LIST
36752: LIST
36753: LIST
36754: PPUSH
36755: CALL_OW 70
36759: ST_TO_ADDR
// for j in fac do
36760: LD_ADDR_VAR 0 3
36764: PUSH
36765: LD_VAR 0 6
36769: PUSH
36770: FOR_IN
36771: IFFALSE 36866
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
36773: LD_ADDR_VAR 0 7
36777: PUSH
36778: LD_VAR 0 7
36782: PUSH
36783: LD_INT 22
36785: PUSH
36786: LD_VAR 0 5
36790: PUSH
36791: EMPTY
36792: LIST
36793: LIST
36794: PUSH
36795: LD_INT 91
36797: PUSH
36798: LD_VAR 0 3
36802: PUSH
36803: LD_INT 15
36805: PUSH
36806: EMPTY
36807: LIST
36808: LIST
36809: LIST
36810: PUSH
36811: LD_INT 21
36813: PUSH
36814: LD_INT 2
36816: PUSH
36817: EMPTY
36818: LIST
36819: LIST
36820: PUSH
36821: LD_INT 3
36823: PUSH
36824: LD_INT 60
36826: PUSH
36827: EMPTY
36828: LIST
36829: PUSH
36830: EMPTY
36831: LIST
36832: LIST
36833: PUSH
36834: LD_INT 3
36836: PUSH
36837: LD_INT 24
36839: PUSH
36840: LD_INT 1000
36842: PUSH
36843: EMPTY
36844: LIST
36845: LIST
36846: PUSH
36847: EMPTY
36848: LIST
36849: LIST
36850: PUSH
36851: EMPTY
36852: LIST
36853: LIST
36854: LIST
36855: LIST
36856: LIST
36857: PPUSH
36858: CALL_OW 69
36862: UNION
36863: ST_TO_ADDR
36864: GO 36770
36866: POP
36867: POP
// if not vehs then
36868: LD_VAR 0 7
36872: NOT
36873: IFFALSE 36899
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
36875: LD_ADDR_EXP 62
36879: PUSH
36880: LD_EXP 62
36884: PPUSH
36885: LD_VAR 0 2
36889: PPUSH
36890: EMPTY
36891: PPUSH
36892: CALL_OW 1
36896: ST_TO_ADDR
// continue ;
36897: GO 36529
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
36899: LD_ADDR_VAR 0 8
36903: PUSH
36904: LD_EXP 50
36908: PUSH
36909: LD_VAR 0 2
36913: ARRAY
36914: PPUSH
36915: LD_INT 30
36917: PUSH
36918: LD_INT 3
36920: PUSH
36921: EMPTY
36922: LIST
36923: LIST
36924: PPUSH
36925: CALL_OW 72
36929: ST_TO_ADDR
// if tmp then
36930: LD_VAR 0 8
36934: IFFALSE 37037
// begin for j in tmp do
36936: LD_ADDR_VAR 0 3
36940: PUSH
36941: LD_VAR 0 8
36945: PUSH
36946: FOR_IN
36947: IFFALSE 37035
// for k in UnitsInside ( j ) do
36949: LD_ADDR_VAR 0 4
36953: PUSH
36954: LD_VAR 0 3
36958: PPUSH
36959: CALL_OW 313
36963: PUSH
36964: FOR_IN
36965: IFFALSE 37031
// if k then
36967: LD_VAR 0 4
36971: IFFALSE 37029
// if not k in mc_repair_vehicle [ i ] then
36973: LD_VAR 0 4
36977: PUSH
36978: LD_EXP 62
36982: PUSH
36983: LD_VAR 0 2
36987: ARRAY
36988: IN
36989: NOT
36990: IFFALSE 37029
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
36992: LD_ADDR_EXP 62
36996: PUSH
36997: LD_EXP 62
37001: PPUSH
37002: LD_VAR 0 2
37006: PPUSH
37007: LD_EXP 62
37011: PUSH
37012: LD_VAR 0 2
37016: ARRAY
37017: PUSH
37018: LD_VAR 0 4
37022: UNION
37023: PPUSH
37024: CALL_OW 1
37028: ST_TO_ADDR
37029: GO 36964
37031: POP
37032: POP
37033: GO 36946
37035: POP
37036: POP
// end ; if not mc_repair_vehicle [ i ] then
37037: LD_EXP 62
37041: PUSH
37042: LD_VAR 0 2
37046: ARRAY
37047: NOT
37048: IFFALSE 37052
// continue ;
37050: GO 36529
// for j in mc_repair_vehicle [ i ] do
37052: LD_ADDR_VAR 0 3
37056: PUSH
37057: LD_EXP 62
37061: PUSH
37062: LD_VAR 0 2
37066: ARRAY
37067: PUSH
37068: FOR_IN
37069: IFFALSE 37246
// begin if GetClass ( j ) <> 3 then
37071: LD_VAR 0 3
37075: PPUSH
37076: CALL_OW 257
37080: PUSH
37081: LD_INT 3
37083: NONEQUAL
37084: IFFALSE 37125
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
37086: LD_ADDR_EXP 62
37090: PUSH
37091: LD_EXP 62
37095: PPUSH
37096: LD_VAR 0 2
37100: PPUSH
37101: LD_EXP 62
37105: PUSH
37106: LD_VAR 0 2
37110: ARRAY
37111: PUSH
37112: LD_VAR 0 3
37116: DIFF
37117: PPUSH
37118: CALL_OW 1
37122: ST_TO_ADDR
// continue ;
37123: GO 37068
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
37125: LD_VAR 0 3
37129: PPUSH
37130: CALL_OW 311
37134: NOT
37135: PUSH
37136: LD_VAR 0 3
37140: PUSH
37141: LD_EXP 53
37145: PUSH
37146: LD_VAR 0 2
37150: ARRAY
37151: PUSH
37152: LD_INT 1
37154: ARRAY
37155: IN
37156: NOT
37157: AND
37158: PUSH
37159: LD_VAR 0 3
37163: PUSH
37164: LD_EXP 53
37168: PUSH
37169: LD_VAR 0 2
37173: ARRAY
37174: PUSH
37175: LD_INT 2
37177: ARRAY
37178: IN
37179: NOT
37180: AND
37181: IFFALSE 37244
// begin if IsInUnit ( j ) then
37183: LD_VAR 0 3
37187: PPUSH
37188: CALL_OW 310
37192: IFFALSE 37205
// ComExitBuilding ( j ) else
37194: LD_VAR 0 3
37198: PPUSH
37199: CALL_OW 122
37203: GO 37244
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
37205: LD_VAR 0 3
37209: PPUSH
37210: LD_VAR 0 7
37214: PUSH
37215: LD_INT 1
37217: ARRAY
37218: PPUSH
37219: CALL 88939 0 2
37223: NOT
37224: IFFALSE 37244
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
37226: LD_VAR 0 3
37230: PPUSH
37231: LD_VAR 0 7
37235: PUSH
37236: LD_INT 1
37238: ARRAY
37239: PPUSH
37240: CALL_OW 129
// end ; end ;
37244: GO 37068
37246: POP
37247: POP
// end ;
37248: GO 36529
37250: POP
37251: POP
// end ;
37252: LD_VAR 0 1
37256: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
37257: LD_INT 0
37259: PPUSH
37260: PPUSH
37261: PPUSH
37262: PPUSH
37263: PPUSH
37264: PPUSH
37265: PPUSH
37266: PPUSH
37267: PPUSH
37268: PPUSH
37269: PPUSH
// if not mc_bases then
37270: LD_EXP 50
37274: NOT
37275: IFFALSE 37279
// exit ;
37277: GO 38081
// for i = 1 to mc_bases do
37279: LD_ADDR_VAR 0 2
37283: PUSH
37284: DOUBLE
37285: LD_INT 1
37287: DEC
37288: ST_TO_ADDR
37289: LD_EXP 50
37293: PUSH
37294: FOR_TO
37295: IFFALSE 38079
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
37297: LD_EXP 78
37301: PUSH
37302: LD_VAR 0 2
37306: ARRAY
37307: NOT
37308: PUSH
37309: LD_EXP 53
37313: PUSH
37314: LD_VAR 0 2
37318: ARRAY
37319: PUSH
37320: LD_INT 1
37322: ARRAY
37323: OR
37324: PUSH
37325: LD_EXP 53
37329: PUSH
37330: LD_VAR 0 2
37334: ARRAY
37335: PUSH
37336: LD_INT 2
37338: ARRAY
37339: OR
37340: PUSH
37341: LD_EXP 76
37345: PUSH
37346: LD_VAR 0 2
37350: ARRAY
37351: PPUSH
37352: LD_INT 1
37354: PPUSH
37355: CALL_OW 325
37359: NOT
37360: OR
37361: PUSH
37362: LD_EXP 73
37366: PUSH
37367: LD_VAR 0 2
37371: ARRAY
37372: OR
37373: IFFALSE 37377
// continue ;
37375: GO 37294
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
37377: LD_ADDR_VAR 0 8
37381: PUSH
37382: LD_EXP 50
37386: PUSH
37387: LD_VAR 0 2
37391: ARRAY
37392: PPUSH
37393: LD_INT 25
37395: PUSH
37396: LD_INT 4
37398: PUSH
37399: EMPTY
37400: LIST
37401: LIST
37402: PUSH
37403: LD_INT 50
37405: PUSH
37406: EMPTY
37407: LIST
37408: PUSH
37409: LD_INT 3
37411: PUSH
37412: LD_INT 60
37414: PUSH
37415: EMPTY
37416: LIST
37417: PUSH
37418: EMPTY
37419: LIST
37420: LIST
37421: PUSH
37422: EMPTY
37423: LIST
37424: LIST
37425: LIST
37426: PPUSH
37427: CALL_OW 72
37431: PUSH
37432: LD_EXP 54
37436: PUSH
37437: LD_VAR 0 2
37441: ARRAY
37442: DIFF
37443: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
37444: LD_ADDR_VAR 0 9
37448: PUSH
37449: LD_EXP 50
37453: PUSH
37454: LD_VAR 0 2
37458: ARRAY
37459: PPUSH
37460: LD_INT 2
37462: PUSH
37463: LD_INT 30
37465: PUSH
37466: LD_INT 0
37468: PUSH
37469: EMPTY
37470: LIST
37471: LIST
37472: PUSH
37473: LD_INT 30
37475: PUSH
37476: LD_INT 1
37478: PUSH
37479: EMPTY
37480: LIST
37481: LIST
37482: PUSH
37483: EMPTY
37484: LIST
37485: LIST
37486: LIST
37487: PPUSH
37488: CALL_OW 72
37492: ST_TO_ADDR
// if not tmp or not dep then
37493: LD_VAR 0 8
37497: NOT
37498: PUSH
37499: LD_VAR 0 9
37503: NOT
37504: OR
37505: IFFALSE 37509
// continue ;
37507: GO 37294
// side := GetSide ( tmp [ 1 ] ) ;
37509: LD_ADDR_VAR 0 11
37513: PUSH
37514: LD_VAR 0 8
37518: PUSH
37519: LD_INT 1
37521: ARRAY
37522: PPUSH
37523: CALL_OW 255
37527: ST_TO_ADDR
// dep := dep [ 1 ] ;
37528: LD_ADDR_VAR 0 9
37532: PUSH
37533: LD_VAR 0 9
37537: PUSH
37538: LD_INT 1
37540: ARRAY
37541: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
37542: LD_ADDR_VAR 0 7
37546: PUSH
37547: LD_EXP 78
37551: PUSH
37552: LD_VAR 0 2
37556: ARRAY
37557: PPUSH
37558: LD_INT 22
37560: PUSH
37561: LD_INT 0
37563: PUSH
37564: EMPTY
37565: LIST
37566: LIST
37567: PUSH
37568: LD_INT 25
37570: PUSH
37571: LD_INT 12
37573: PUSH
37574: EMPTY
37575: LIST
37576: LIST
37577: PUSH
37578: EMPTY
37579: LIST
37580: LIST
37581: PPUSH
37582: CALL_OW 70
37586: PUSH
37587: LD_INT 22
37589: PUSH
37590: LD_INT 0
37592: PUSH
37593: EMPTY
37594: LIST
37595: LIST
37596: PUSH
37597: LD_INT 25
37599: PUSH
37600: LD_INT 12
37602: PUSH
37603: EMPTY
37604: LIST
37605: LIST
37606: PUSH
37607: LD_INT 91
37609: PUSH
37610: LD_VAR 0 9
37614: PUSH
37615: LD_INT 20
37617: PUSH
37618: EMPTY
37619: LIST
37620: LIST
37621: LIST
37622: PUSH
37623: EMPTY
37624: LIST
37625: LIST
37626: LIST
37627: PPUSH
37628: CALL_OW 69
37632: UNION
37633: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
37634: LD_ADDR_VAR 0 10
37638: PUSH
37639: LD_EXP 78
37643: PUSH
37644: LD_VAR 0 2
37648: ARRAY
37649: PPUSH
37650: LD_INT 81
37652: PUSH
37653: LD_VAR 0 11
37657: PUSH
37658: EMPTY
37659: LIST
37660: LIST
37661: PPUSH
37662: CALL_OW 70
37666: ST_TO_ADDR
// if not apes or danger_at_area then
37667: LD_VAR 0 7
37671: NOT
37672: PUSH
37673: LD_VAR 0 10
37677: OR
37678: IFFALSE 37728
// begin if mc_taming [ i ] then
37680: LD_EXP 81
37684: PUSH
37685: LD_VAR 0 2
37689: ARRAY
37690: IFFALSE 37726
// begin MC_Reset ( i , 121 ) ;
37692: LD_VAR 0 2
37696: PPUSH
37697: LD_INT 121
37699: PPUSH
37700: CALL 22644 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
37704: LD_ADDR_EXP 81
37708: PUSH
37709: LD_EXP 81
37713: PPUSH
37714: LD_VAR 0 2
37718: PPUSH
37719: EMPTY
37720: PPUSH
37721: CALL_OW 1
37725: ST_TO_ADDR
// end ; continue ;
37726: GO 37294
// end ; for j in tmp do
37728: LD_ADDR_VAR 0 3
37732: PUSH
37733: LD_VAR 0 8
37737: PUSH
37738: FOR_IN
37739: IFFALSE 38075
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
37741: LD_VAR 0 3
37745: PUSH
37746: LD_EXP 81
37750: PUSH
37751: LD_VAR 0 2
37755: ARRAY
37756: IN
37757: NOT
37758: PUSH
37759: LD_EXP 81
37763: PUSH
37764: LD_VAR 0 2
37768: ARRAY
37769: PUSH
37770: LD_INT 3
37772: LESS
37773: AND
37774: IFFALSE 37832
// begin SetTag ( j , 121 ) ;
37776: LD_VAR 0 3
37780: PPUSH
37781: LD_INT 121
37783: PPUSH
37784: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
37788: LD_ADDR_EXP 81
37792: PUSH
37793: LD_EXP 81
37797: PPUSH
37798: LD_VAR 0 2
37802: PUSH
37803: LD_EXP 81
37807: PUSH
37808: LD_VAR 0 2
37812: ARRAY
37813: PUSH
37814: LD_INT 1
37816: PLUS
37817: PUSH
37818: EMPTY
37819: LIST
37820: LIST
37821: PPUSH
37822: LD_VAR 0 3
37826: PPUSH
37827: CALL 54145 0 3
37831: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
37832: LD_VAR 0 3
37836: PUSH
37837: LD_EXP 81
37841: PUSH
37842: LD_VAR 0 2
37846: ARRAY
37847: IN
37848: IFFALSE 38073
// begin if GetClass ( j ) <> 4 then
37850: LD_VAR 0 3
37854: PPUSH
37855: CALL_OW 257
37859: PUSH
37860: LD_INT 4
37862: NONEQUAL
37863: IFFALSE 37916
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
37865: LD_ADDR_EXP 81
37869: PUSH
37870: LD_EXP 81
37874: PPUSH
37875: LD_VAR 0 2
37879: PPUSH
37880: LD_EXP 81
37884: PUSH
37885: LD_VAR 0 2
37889: ARRAY
37890: PUSH
37891: LD_VAR 0 3
37895: DIFF
37896: PPUSH
37897: CALL_OW 1
37901: ST_TO_ADDR
// SetTag ( j , 0 ) ;
37902: LD_VAR 0 3
37906: PPUSH
37907: LD_INT 0
37909: PPUSH
37910: CALL_OW 109
// continue ;
37914: GO 37738
// end ; if IsInUnit ( j ) then
37916: LD_VAR 0 3
37920: PPUSH
37921: CALL_OW 310
37925: IFFALSE 37936
// ComExitBuilding ( j ) ;
37927: LD_VAR 0 3
37931: PPUSH
37932: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
37936: LD_ADDR_VAR 0 6
37940: PUSH
37941: LD_VAR 0 7
37945: PPUSH
37946: LD_VAR 0 3
37950: PPUSH
37951: CALL_OW 74
37955: ST_TO_ADDR
// if not ape then
37956: LD_VAR 0 6
37960: NOT
37961: IFFALSE 37965
// break ;
37963: GO 38075
// x := GetX ( ape ) ;
37965: LD_ADDR_VAR 0 4
37969: PUSH
37970: LD_VAR 0 6
37974: PPUSH
37975: CALL_OW 250
37979: ST_TO_ADDR
// y := GetY ( ape ) ;
37980: LD_ADDR_VAR 0 5
37984: PUSH
37985: LD_VAR 0 6
37989: PPUSH
37990: CALL_OW 251
37994: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
37995: LD_VAR 0 4
37999: PPUSH
38000: LD_VAR 0 5
38004: PPUSH
38005: CALL_OW 488
38009: NOT
38010: PUSH
38011: LD_VAR 0 11
38015: PPUSH
38016: LD_VAR 0 4
38020: PPUSH
38021: LD_VAR 0 5
38025: PPUSH
38026: LD_INT 20
38028: PPUSH
38029: CALL 55409 0 4
38033: PUSH
38034: LD_INT 4
38036: ARRAY
38037: OR
38038: IFFALSE 38042
// break ;
38040: GO 38075
// if not HasTask ( j ) then
38042: LD_VAR 0 3
38046: PPUSH
38047: CALL_OW 314
38051: NOT
38052: IFFALSE 38073
// ComTameXY ( j , x , y ) ;
38054: LD_VAR 0 3
38058: PPUSH
38059: LD_VAR 0 4
38063: PPUSH
38064: LD_VAR 0 5
38068: PPUSH
38069: CALL_OW 131
// end ; end ;
38073: GO 37738
38075: POP
38076: POP
// end ;
38077: GO 37294
38079: POP
38080: POP
// end ;
38081: LD_VAR 0 1
38085: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
38086: LD_INT 0
38088: PPUSH
38089: PPUSH
38090: PPUSH
38091: PPUSH
38092: PPUSH
38093: PPUSH
38094: PPUSH
38095: PPUSH
// if not mc_bases then
38096: LD_EXP 50
38100: NOT
38101: IFFALSE 38105
// exit ;
38103: GO 38731
// for i = 1 to mc_bases do
38105: LD_ADDR_VAR 0 2
38109: PUSH
38110: DOUBLE
38111: LD_INT 1
38113: DEC
38114: ST_TO_ADDR
38115: LD_EXP 50
38119: PUSH
38120: FOR_TO
38121: IFFALSE 38729
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
38123: LD_EXP 79
38127: PUSH
38128: LD_VAR 0 2
38132: ARRAY
38133: NOT
38134: PUSH
38135: LD_EXP 79
38139: PUSH
38140: LD_VAR 0 2
38144: ARRAY
38145: PPUSH
38146: LD_INT 25
38148: PUSH
38149: LD_INT 12
38151: PUSH
38152: EMPTY
38153: LIST
38154: LIST
38155: PPUSH
38156: CALL_OW 72
38160: NOT
38161: OR
38162: IFFALSE 38166
// continue ;
38164: GO 38120
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
38166: LD_ADDR_VAR 0 5
38170: PUSH
38171: LD_EXP 79
38175: PUSH
38176: LD_VAR 0 2
38180: ARRAY
38181: PUSH
38182: LD_INT 1
38184: ARRAY
38185: PPUSH
38186: CALL_OW 255
38190: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
38191: LD_VAR 0 5
38195: PPUSH
38196: LD_INT 2
38198: PPUSH
38199: CALL_OW 325
38203: IFFALSE 38456
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
38205: LD_ADDR_VAR 0 4
38209: PUSH
38210: LD_EXP 79
38214: PUSH
38215: LD_VAR 0 2
38219: ARRAY
38220: PPUSH
38221: LD_INT 25
38223: PUSH
38224: LD_INT 16
38226: PUSH
38227: EMPTY
38228: LIST
38229: LIST
38230: PPUSH
38231: CALL_OW 72
38235: ST_TO_ADDR
// if tmp < 6 then
38236: LD_VAR 0 4
38240: PUSH
38241: LD_INT 6
38243: LESS
38244: IFFALSE 38456
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
38246: LD_ADDR_VAR 0 6
38250: PUSH
38251: LD_EXP 50
38255: PUSH
38256: LD_VAR 0 2
38260: ARRAY
38261: PPUSH
38262: LD_INT 2
38264: PUSH
38265: LD_INT 30
38267: PUSH
38268: LD_INT 0
38270: PUSH
38271: EMPTY
38272: LIST
38273: LIST
38274: PUSH
38275: LD_INT 30
38277: PUSH
38278: LD_INT 1
38280: PUSH
38281: EMPTY
38282: LIST
38283: LIST
38284: PUSH
38285: EMPTY
38286: LIST
38287: LIST
38288: LIST
38289: PPUSH
38290: CALL_OW 72
38294: ST_TO_ADDR
// if depot then
38295: LD_VAR 0 6
38299: IFFALSE 38456
// begin selected := 0 ;
38301: LD_ADDR_VAR 0 7
38305: PUSH
38306: LD_INT 0
38308: ST_TO_ADDR
// for j in depot do
38309: LD_ADDR_VAR 0 3
38313: PUSH
38314: LD_VAR 0 6
38318: PUSH
38319: FOR_IN
38320: IFFALSE 38351
// begin if UnitsInside ( j ) < 6 then
38322: LD_VAR 0 3
38326: PPUSH
38327: CALL_OW 313
38331: PUSH
38332: LD_INT 6
38334: LESS
38335: IFFALSE 38349
// begin selected := j ;
38337: LD_ADDR_VAR 0 7
38341: PUSH
38342: LD_VAR 0 3
38346: ST_TO_ADDR
// break ;
38347: GO 38351
// end ; end ;
38349: GO 38319
38351: POP
38352: POP
// if selected then
38353: LD_VAR 0 7
38357: IFFALSE 38456
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
38359: LD_ADDR_VAR 0 3
38363: PUSH
38364: LD_EXP 79
38368: PUSH
38369: LD_VAR 0 2
38373: ARRAY
38374: PPUSH
38375: LD_INT 25
38377: PUSH
38378: LD_INT 12
38380: PUSH
38381: EMPTY
38382: LIST
38383: LIST
38384: PPUSH
38385: CALL_OW 72
38389: PUSH
38390: FOR_IN
38391: IFFALSE 38454
// if not HasTask ( j ) then
38393: LD_VAR 0 3
38397: PPUSH
38398: CALL_OW 314
38402: NOT
38403: IFFALSE 38452
// begin if not IsInUnit ( j ) then
38405: LD_VAR 0 3
38409: PPUSH
38410: CALL_OW 310
38414: NOT
38415: IFFALSE 38431
// ComEnterUnit ( j , selected ) ;
38417: LD_VAR 0 3
38421: PPUSH
38422: LD_VAR 0 7
38426: PPUSH
38427: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
38431: LD_VAR 0 3
38435: PPUSH
38436: LD_INT 16
38438: PPUSH
38439: CALL_OW 183
// AddComExitBuilding ( j ) ;
38443: LD_VAR 0 3
38447: PPUSH
38448: CALL_OW 182
// end ;
38452: GO 38390
38454: POP
38455: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
38456: LD_VAR 0 5
38460: PPUSH
38461: LD_INT 11
38463: PPUSH
38464: CALL_OW 325
38468: IFFALSE 38727
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
38470: LD_ADDR_VAR 0 4
38474: PUSH
38475: LD_EXP 79
38479: PUSH
38480: LD_VAR 0 2
38484: ARRAY
38485: PPUSH
38486: LD_INT 25
38488: PUSH
38489: LD_INT 16
38491: PUSH
38492: EMPTY
38493: LIST
38494: LIST
38495: PPUSH
38496: CALL_OW 72
38500: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
38501: LD_VAR 0 4
38505: PUSH
38506: LD_INT 6
38508: GREATEREQUAL
38509: PUSH
38510: LD_VAR 0 5
38514: PPUSH
38515: LD_INT 2
38517: PPUSH
38518: CALL_OW 325
38522: NOT
38523: OR
38524: IFFALSE 38727
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
38526: LD_ADDR_VAR 0 8
38530: PUSH
38531: LD_EXP 50
38535: PUSH
38536: LD_VAR 0 2
38540: ARRAY
38541: PPUSH
38542: LD_INT 2
38544: PUSH
38545: LD_INT 30
38547: PUSH
38548: LD_INT 4
38550: PUSH
38551: EMPTY
38552: LIST
38553: LIST
38554: PUSH
38555: LD_INT 30
38557: PUSH
38558: LD_INT 5
38560: PUSH
38561: EMPTY
38562: LIST
38563: LIST
38564: PUSH
38565: EMPTY
38566: LIST
38567: LIST
38568: LIST
38569: PPUSH
38570: CALL_OW 72
38574: ST_TO_ADDR
// if barracks then
38575: LD_VAR 0 8
38579: IFFALSE 38727
// begin selected := 0 ;
38581: LD_ADDR_VAR 0 7
38585: PUSH
38586: LD_INT 0
38588: ST_TO_ADDR
// for j in barracks do
38589: LD_ADDR_VAR 0 3
38593: PUSH
38594: LD_VAR 0 8
38598: PUSH
38599: FOR_IN
38600: IFFALSE 38631
// begin if UnitsInside ( j ) < 6 then
38602: LD_VAR 0 3
38606: PPUSH
38607: CALL_OW 313
38611: PUSH
38612: LD_INT 6
38614: LESS
38615: IFFALSE 38629
// begin selected := j ;
38617: LD_ADDR_VAR 0 7
38621: PUSH
38622: LD_VAR 0 3
38626: ST_TO_ADDR
// break ;
38627: GO 38631
// end ; end ;
38629: GO 38599
38631: POP
38632: POP
// if selected then
38633: LD_VAR 0 7
38637: IFFALSE 38727
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
38639: LD_ADDR_VAR 0 3
38643: PUSH
38644: LD_EXP 79
38648: PUSH
38649: LD_VAR 0 2
38653: ARRAY
38654: PPUSH
38655: LD_INT 25
38657: PUSH
38658: LD_INT 12
38660: PUSH
38661: EMPTY
38662: LIST
38663: LIST
38664: PPUSH
38665: CALL_OW 72
38669: PUSH
38670: FOR_IN
38671: IFFALSE 38725
// if not IsInUnit ( j ) and not HasTask ( j ) then
38673: LD_VAR 0 3
38677: PPUSH
38678: CALL_OW 310
38682: NOT
38683: PUSH
38684: LD_VAR 0 3
38688: PPUSH
38689: CALL_OW 314
38693: NOT
38694: AND
38695: IFFALSE 38723
// begin ComEnterUnit ( j , selected ) ;
38697: LD_VAR 0 3
38701: PPUSH
38702: LD_VAR 0 7
38706: PPUSH
38707: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
38711: LD_VAR 0 3
38715: PPUSH
38716: LD_INT 15
38718: PPUSH
38719: CALL_OW 183
// end ;
38723: GO 38670
38725: POP
38726: POP
// end ; end ; end ; end ; end ;
38727: GO 38120
38729: POP
38730: POP
// end ;
38731: LD_VAR 0 1
38735: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
38736: LD_INT 0
38738: PPUSH
38739: PPUSH
38740: PPUSH
38741: PPUSH
// if not mc_bases then
38742: LD_EXP 50
38746: NOT
38747: IFFALSE 38751
// exit ;
38749: GO 38929
// for i = 1 to mc_bases do
38751: LD_ADDR_VAR 0 2
38755: PUSH
38756: DOUBLE
38757: LD_INT 1
38759: DEC
38760: ST_TO_ADDR
38761: LD_EXP 50
38765: PUSH
38766: FOR_TO
38767: IFFALSE 38927
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
38769: LD_ADDR_VAR 0 4
38773: PUSH
38774: LD_EXP 50
38778: PUSH
38779: LD_VAR 0 2
38783: ARRAY
38784: PPUSH
38785: LD_INT 25
38787: PUSH
38788: LD_INT 9
38790: PUSH
38791: EMPTY
38792: LIST
38793: LIST
38794: PPUSH
38795: CALL_OW 72
38799: ST_TO_ADDR
// if not tmp then
38800: LD_VAR 0 4
38804: NOT
38805: IFFALSE 38809
// continue ;
38807: GO 38766
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
38809: LD_EXP 76
38813: PUSH
38814: LD_VAR 0 2
38818: ARRAY
38819: PPUSH
38820: LD_INT 29
38822: PPUSH
38823: CALL_OW 325
38827: NOT
38828: PUSH
38829: LD_EXP 76
38833: PUSH
38834: LD_VAR 0 2
38838: ARRAY
38839: PPUSH
38840: LD_INT 28
38842: PPUSH
38843: CALL_OW 325
38847: NOT
38848: AND
38849: IFFALSE 38853
// continue ;
38851: GO 38766
// for j in tmp do
38853: LD_ADDR_VAR 0 3
38857: PUSH
38858: LD_VAR 0 4
38862: PUSH
38863: FOR_IN
38864: IFFALSE 38923
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
38866: LD_VAR 0 3
38870: PUSH
38871: LD_EXP 53
38875: PUSH
38876: LD_VAR 0 2
38880: ARRAY
38881: PUSH
38882: LD_INT 1
38884: ARRAY
38885: IN
38886: NOT
38887: PUSH
38888: LD_VAR 0 3
38892: PUSH
38893: LD_EXP 53
38897: PUSH
38898: LD_VAR 0 2
38902: ARRAY
38903: PUSH
38904: LD_INT 2
38906: ARRAY
38907: IN
38908: NOT
38909: AND
38910: IFFALSE 38921
// ComSpaceTimeShoot ( j ) ;
38912: LD_VAR 0 3
38916: PPUSH
38917: CALL 50130 0 1
38921: GO 38863
38923: POP
38924: POP
// end ;
38925: GO 38766
38927: POP
38928: POP
// end ;
38929: LD_VAR 0 1
38933: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
38934: LD_INT 0
38936: PPUSH
38937: PPUSH
38938: PPUSH
38939: PPUSH
38940: PPUSH
38941: PPUSH
38942: PPUSH
38943: PPUSH
38944: PPUSH
// if not mc_bases then
38945: LD_EXP 50
38949: NOT
38950: IFFALSE 38954
// exit ;
38952: GO 39576
// for i = 1 to mc_bases do
38954: LD_ADDR_VAR 0 2
38958: PUSH
38959: DOUBLE
38960: LD_INT 1
38962: DEC
38963: ST_TO_ADDR
38964: LD_EXP 50
38968: PUSH
38969: FOR_TO
38970: IFFALSE 39574
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
38972: LD_EXP 85
38976: PUSH
38977: LD_VAR 0 2
38981: ARRAY
38982: NOT
38983: PUSH
38984: LD_INT 38
38986: PPUSH
38987: LD_EXP 76
38991: PUSH
38992: LD_VAR 0 2
38996: ARRAY
38997: PPUSH
38998: CALL_OW 321
39002: PUSH
39003: LD_INT 2
39005: NONEQUAL
39006: OR
39007: IFFALSE 39011
// continue ;
39009: GO 38969
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
39011: LD_ADDR_VAR 0 8
39015: PUSH
39016: LD_EXP 50
39020: PUSH
39021: LD_VAR 0 2
39025: ARRAY
39026: PPUSH
39027: LD_INT 30
39029: PUSH
39030: LD_INT 34
39032: PUSH
39033: EMPTY
39034: LIST
39035: LIST
39036: PPUSH
39037: CALL_OW 72
39041: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
39042: LD_ADDR_VAR 0 9
39046: PUSH
39047: LD_EXP 50
39051: PUSH
39052: LD_VAR 0 2
39056: ARRAY
39057: PPUSH
39058: LD_INT 25
39060: PUSH
39061: LD_INT 4
39063: PUSH
39064: EMPTY
39065: LIST
39066: LIST
39067: PPUSH
39068: CALL_OW 72
39072: PPUSH
39073: LD_INT 0
39075: PPUSH
39076: CALL 84443 0 2
39080: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
39081: LD_VAR 0 9
39085: NOT
39086: PUSH
39087: LD_VAR 0 8
39091: NOT
39092: OR
39093: PUSH
39094: LD_EXP 50
39098: PUSH
39099: LD_VAR 0 2
39103: ARRAY
39104: PPUSH
39105: LD_INT 124
39107: PPUSH
39108: CALL 84443 0 2
39112: OR
39113: IFFALSE 39117
// continue ;
39115: GO 38969
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
39117: LD_EXP 86
39121: PUSH
39122: LD_VAR 0 2
39126: ARRAY
39127: PUSH
39128: LD_EXP 85
39132: PUSH
39133: LD_VAR 0 2
39137: ARRAY
39138: LESS
39139: PUSH
39140: LD_EXP 86
39144: PUSH
39145: LD_VAR 0 2
39149: ARRAY
39150: PUSH
39151: LD_VAR 0 8
39155: LESS
39156: AND
39157: IFFALSE 39572
// begin tmp := sci [ 1 ] ;
39159: LD_ADDR_VAR 0 7
39163: PUSH
39164: LD_VAR 0 9
39168: PUSH
39169: LD_INT 1
39171: ARRAY
39172: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
39173: LD_VAR 0 7
39177: PPUSH
39178: LD_INT 124
39180: PPUSH
39181: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
39185: LD_ADDR_VAR 0 3
39189: PUSH
39190: DOUBLE
39191: LD_EXP 85
39195: PUSH
39196: LD_VAR 0 2
39200: ARRAY
39201: INC
39202: ST_TO_ADDR
39203: LD_EXP 85
39207: PUSH
39208: LD_VAR 0 2
39212: ARRAY
39213: PUSH
39214: FOR_DOWNTO
39215: IFFALSE 39558
// begin if IsInUnit ( tmp ) then
39217: LD_VAR 0 7
39221: PPUSH
39222: CALL_OW 310
39226: IFFALSE 39237
// ComExitBuilding ( tmp ) ;
39228: LD_VAR 0 7
39232: PPUSH
39233: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
39237: LD_INT 35
39239: PPUSH
39240: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
39244: LD_VAR 0 7
39248: PPUSH
39249: CALL_OW 310
39253: NOT
39254: PUSH
39255: LD_VAR 0 7
39259: PPUSH
39260: CALL_OW 314
39264: NOT
39265: AND
39266: IFFALSE 39237
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
39268: LD_ADDR_VAR 0 6
39272: PUSH
39273: LD_VAR 0 7
39277: PPUSH
39278: CALL_OW 250
39282: PUSH
39283: LD_VAR 0 7
39287: PPUSH
39288: CALL_OW 251
39292: PUSH
39293: EMPTY
39294: LIST
39295: LIST
39296: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
39297: LD_INT 35
39299: PPUSH
39300: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
39304: LD_ADDR_VAR 0 4
39308: PUSH
39309: LD_EXP 85
39313: PUSH
39314: LD_VAR 0 2
39318: ARRAY
39319: PUSH
39320: LD_VAR 0 3
39324: ARRAY
39325: PUSH
39326: LD_INT 1
39328: ARRAY
39329: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
39330: LD_ADDR_VAR 0 5
39334: PUSH
39335: LD_EXP 85
39339: PUSH
39340: LD_VAR 0 2
39344: ARRAY
39345: PUSH
39346: LD_VAR 0 3
39350: ARRAY
39351: PUSH
39352: LD_INT 2
39354: ARRAY
39355: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
39356: LD_VAR 0 7
39360: PPUSH
39361: LD_INT 10
39363: PPUSH
39364: CALL 57110 0 2
39368: PUSH
39369: LD_INT 4
39371: ARRAY
39372: IFFALSE 39410
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
39374: LD_VAR 0 7
39378: PPUSH
39379: LD_VAR 0 6
39383: PUSH
39384: LD_INT 1
39386: ARRAY
39387: PPUSH
39388: LD_VAR 0 6
39392: PUSH
39393: LD_INT 2
39395: ARRAY
39396: PPUSH
39397: CALL_OW 111
// wait ( 0 0$10 ) ;
39401: LD_INT 350
39403: PPUSH
39404: CALL_OW 67
// end else
39408: GO 39436
// begin ComMoveXY ( tmp , x , y ) ;
39410: LD_VAR 0 7
39414: PPUSH
39415: LD_VAR 0 4
39419: PPUSH
39420: LD_VAR 0 5
39424: PPUSH
39425: CALL_OW 111
// wait ( 0 0$3 ) ;
39429: LD_INT 105
39431: PPUSH
39432: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
39436: LD_VAR 0 7
39440: PPUSH
39441: LD_VAR 0 4
39445: PPUSH
39446: LD_VAR 0 5
39450: PPUSH
39451: CALL_OW 307
39455: IFFALSE 39297
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
39457: LD_VAR 0 7
39461: PPUSH
39462: LD_VAR 0 4
39466: PPUSH
39467: LD_VAR 0 5
39471: PPUSH
39472: LD_VAR 0 8
39476: PUSH
39477: LD_VAR 0 3
39481: ARRAY
39482: PPUSH
39483: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
39487: LD_INT 35
39489: PPUSH
39490: CALL_OW 67
// until not HasTask ( tmp ) ;
39494: LD_VAR 0 7
39498: PPUSH
39499: CALL_OW 314
39503: NOT
39504: IFFALSE 39487
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
39506: LD_ADDR_EXP 86
39510: PUSH
39511: LD_EXP 86
39515: PPUSH
39516: LD_VAR 0 2
39520: PUSH
39521: LD_EXP 86
39525: PUSH
39526: LD_VAR 0 2
39530: ARRAY
39531: PUSH
39532: LD_INT 1
39534: PLUS
39535: PUSH
39536: EMPTY
39537: LIST
39538: LIST
39539: PPUSH
39540: LD_VAR 0 8
39544: PUSH
39545: LD_VAR 0 3
39549: ARRAY
39550: PPUSH
39551: CALL 54145 0 3
39555: ST_TO_ADDR
// end ;
39556: GO 39214
39558: POP
39559: POP
// MC_Reset ( i , 124 ) ;
39560: LD_VAR 0 2
39564: PPUSH
39565: LD_INT 124
39567: PPUSH
39568: CALL 22644 0 2
// end ; end ;
39572: GO 38969
39574: POP
39575: POP
// end ;
39576: LD_VAR 0 1
39580: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
39581: LD_INT 0
39583: PPUSH
39584: PPUSH
39585: PPUSH
// if not mc_bases then
39586: LD_EXP 50
39590: NOT
39591: IFFALSE 39595
// exit ;
39593: GO 40201
// for i = 1 to mc_bases do
39595: LD_ADDR_VAR 0 2
39599: PUSH
39600: DOUBLE
39601: LD_INT 1
39603: DEC
39604: ST_TO_ADDR
39605: LD_EXP 50
39609: PUSH
39610: FOR_TO
39611: IFFALSE 40199
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
39613: LD_ADDR_VAR 0 3
39617: PUSH
39618: LD_EXP 50
39622: PUSH
39623: LD_VAR 0 2
39627: ARRAY
39628: PPUSH
39629: LD_INT 25
39631: PUSH
39632: LD_INT 4
39634: PUSH
39635: EMPTY
39636: LIST
39637: LIST
39638: PPUSH
39639: CALL_OW 72
39643: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
39644: LD_VAR 0 3
39648: NOT
39649: PUSH
39650: LD_EXP 87
39654: PUSH
39655: LD_VAR 0 2
39659: ARRAY
39660: NOT
39661: OR
39662: PUSH
39663: LD_EXP 50
39667: PUSH
39668: LD_VAR 0 2
39672: ARRAY
39673: PPUSH
39674: LD_INT 2
39676: PUSH
39677: LD_INT 30
39679: PUSH
39680: LD_INT 0
39682: PUSH
39683: EMPTY
39684: LIST
39685: LIST
39686: PUSH
39687: LD_INT 30
39689: PUSH
39690: LD_INT 1
39692: PUSH
39693: EMPTY
39694: LIST
39695: LIST
39696: PUSH
39697: EMPTY
39698: LIST
39699: LIST
39700: LIST
39701: PPUSH
39702: CALL_OW 72
39706: NOT
39707: OR
39708: IFFALSE 39758
// begin if mc_deposits_finder [ i ] then
39710: LD_EXP 88
39714: PUSH
39715: LD_VAR 0 2
39719: ARRAY
39720: IFFALSE 39756
// begin MC_Reset ( i , 125 ) ;
39722: LD_VAR 0 2
39726: PPUSH
39727: LD_INT 125
39729: PPUSH
39730: CALL 22644 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
39734: LD_ADDR_EXP 88
39738: PUSH
39739: LD_EXP 88
39743: PPUSH
39744: LD_VAR 0 2
39748: PPUSH
39749: EMPTY
39750: PPUSH
39751: CALL_OW 1
39755: ST_TO_ADDR
// end ; continue ;
39756: GO 39610
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
39758: LD_EXP 87
39762: PUSH
39763: LD_VAR 0 2
39767: ARRAY
39768: PUSH
39769: LD_INT 1
39771: ARRAY
39772: PUSH
39773: LD_INT 3
39775: ARRAY
39776: PUSH
39777: LD_INT 1
39779: EQUAL
39780: PUSH
39781: LD_INT 20
39783: PPUSH
39784: LD_EXP 76
39788: PUSH
39789: LD_VAR 0 2
39793: ARRAY
39794: PPUSH
39795: CALL_OW 321
39799: PUSH
39800: LD_INT 2
39802: NONEQUAL
39803: AND
39804: IFFALSE 39854
// begin if mc_deposits_finder [ i ] then
39806: LD_EXP 88
39810: PUSH
39811: LD_VAR 0 2
39815: ARRAY
39816: IFFALSE 39852
// begin MC_Reset ( i , 125 ) ;
39818: LD_VAR 0 2
39822: PPUSH
39823: LD_INT 125
39825: PPUSH
39826: CALL 22644 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
39830: LD_ADDR_EXP 88
39834: PUSH
39835: LD_EXP 88
39839: PPUSH
39840: LD_VAR 0 2
39844: PPUSH
39845: EMPTY
39846: PPUSH
39847: CALL_OW 1
39851: ST_TO_ADDR
// end ; continue ;
39852: GO 39610
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
39854: LD_EXP 87
39858: PUSH
39859: LD_VAR 0 2
39863: ARRAY
39864: PUSH
39865: LD_INT 1
39867: ARRAY
39868: PUSH
39869: LD_INT 1
39871: ARRAY
39872: PPUSH
39873: LD_EXP 87
39877: PUSH
39878: LD_VAR 0 2
39882: ARRAY
39883: PUSH
39884: LD_INT 1
39886: ARRAY
39887: PUSH
39888: LD_INT 2
39890: ARRAY
39891: PPUSH
39892: LD_EXP 76
39896: PUSH
39897: LD_VAR 0 2
39901: ARRAY
39902: PPUSH
39903: CALL_OW 440
39907: IFFALSE 39950
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
39909: LD_ADDR_EXP 87
39913: PUSH
39914: LD_EXP 87
39918: PPUSH
39919: LD_VAR 0 2
39923: PPUSH
39924: LD_EXP 87
39928: PUSH
39929: LD_VAR 0 2
39933: ARRAY
39934: PPUSH
39935: LD_INT 1
39937: PPUSH
39938: CALL_OW 3
39942: PPUSH
39943: CALL_OW 1
39947: ST_TO_ADDR
39948: GO 40197
// begin if not mc_deposits_finder [ i ] then
39950: LD_EXP 88
39954: PUSH
39955: LD_VAR 0 2
39959: ARRAY
39960: NOT
39961: IFFALSE 40013
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
39963: LD_ADDR_EXP 88
39967: PUSH
39968: LD_EXP 88
39972: PPUSH
39973: LD_VAR 0 2
39977: PPUSH
39978: LD_VAR 0 3
39982: PUSH
39983: LD_INT 1
39985: ARRAY
39986: PUSH
39987: EMPTY
39988: LIST
39989: PPUSH
39990: CALL_OW 1
39994: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
39995: LD_VAR 0 3
39999: PUSH
40000: LD_INT 1
40002: ARRAY
40003: PPUSH
40004: LD_INT 125
40006: PPUSH
40007: CALL_OW 109
// end else
40011: GO 40197
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
40013: LD_EXP 88
40017: PUSH
40018: LD_VAR 0 2
40022: ARRAY
40023: PUSH
40024: LD_INT 1
40026: ARRAY
40027: PPUSH
40028: CALL_OW 310
40032: IFFALSE 40055
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
40034: LD_EXP 88
40038: PUSH
40039: LD_VAR 0 2
40043: ARRAY
40044: PUSH
40045: LD_INT 1
40047: ARRAY
40048: PPUSH
40049: CALL_OW 122
40053: GO 40197
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
40055: LD_EXP 88
40059: PUSH
40060: LD_VAR 0 2
40064: ARRAY
40065: PUSH
40066: LD_INT 1
40068: ARRAY
40069: PPUSH
40070: CALL_OW 314
40074: NOT
40075: PUSH
40076: LD_EXP 88
40080: PUSH
40081: LD_VAR 0 2
40085: ARRAY
40086: PUSH
40087: LD_INT 1
40089: ARRAY
40090: PPUSH
40091: LD_EXP 87
40095: PUSH
40096: LD_VAR 0 2
40100: ARRAY
40101: PUSH
40102: LD_INT 1
40104: ARRAY
40105: PUSH
40106: LD_INT 1
40108: ARRAY
40109: PPUSH
40110: LD_EXP 87
40114: PUSH
40115: LD_VAR 0 2
40119: ARRAY
40120: PUSH
40121: LD_INT 1
40123: ARRAY
40124: PUSH
40125: LD_INT 2
40127: ARRAY
40128: PPUSH
40129: CALL_OW 297
40133: PUSH
40134: LD_INT 6
40136: GREATER
40137: AND
40138: IFFALSE 40197
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
40140: LD_EXP 88
40144: PUSH
40145: LD_VAR 0 2
40149: ARRAY
40150: PUSH
40151: LD_INT 1
40153: ARRAY
40154: PPUSH
40155: LD_EXP 87
40159: PUSH
40160: LD_VAR 0 2
40164: ARRAY
40165: PUSH
40166: LD_INT 1
40168: ARRAY
40169: PUSH
40170: LD_INT 1
40172: ARRAY
40173: PPUSH
40174: LD_EXP 87
40178: PUSH
40179: LD_VAR 0 2
40183: ARRAY
40184: PUSH
40185: LD_INT 1
40187: ARRAY
40188: PUSH
40189: LD_INT 2
40191: ARRAY
40192: PPUSH
40193: CALL_OW 111
// end ; end ; end ;
40197: GO 39610
40199: POP
40200: POP
// end ;
40201: LD_VAR 0 1
40205: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
40206: LD_INT 0
40208: PPUSH
40209: PPUSH
40210: PPUSH
40211: PPUSH
40212: PPUSH
40213: PPUSH
40214: PPUSH
40215: PPUSH
40216: PPUSH
40217: PPUSH
40218: PPUSH
// if not mc_bases then
40219: LD_EXP 50
40223: NOT
40224: IFFALSE 40228
// exit ;
40226: GO 41168
// for i = 1 to mc_bases do
40228: LD_ADDR_VAR 0 2
40232: PUSH
40233: DOUBLE
40234: LD_INT 1
40236: DEC
40237: ST_TO_ADDR
40238: LD_EXP 50
40242: PUSH
40243: FOR_TO
40244: IFFALSE 41166
// begin if not mc_bases [ i ] or mc_scan [ i ] then
40246: LD_EXP 50
40250: PUSH
40251: LD_VAR 0 2
40255: ARRAY
40256: NOT
40257: PUSH
40258: LD_EXP 73
40262: PUSH
40263: LD_VAR 0 2
40267: ARRAY
40268: OR
40269: IFFALSE 40273
// continue ;
40271: GO 40243
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
40273: LD_ADDR_VAR 0 7
40277: PUSH
40278: LD_EXP 50
40282: PUSH
40283: LD_VAR 0 2
40287: ARRAY
40288: PUSH
40289: LD_INT 1
40291: ARRAY
40292: PPUSH
40293: CALL_OW 248
40297: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
40298: LD_VAR 0 7
40302: PUSH
40303: LD_INT 3
40305: EQUAL
40306: PUSH
40307: LD_EXP 69
40311: PUSH
40312: LD_VAR 0 2
40316: ARRAY
40317: PUSH
40318: LD_EXP 72
40322: PUSH
40323: LD_VAR 0 2
40327: ARRAY
40328: UNION
40329: PPUSH
40330: LD_INT 33
40332: PUSH
40333: LD_INT 2
40335: PUSH
40336: EMPTY
40337: LIST
40338: LIST
40339: PPUSH
40340: CALL_OW 72
40344: NOT
40345: OR
40346: IFFALSE 40350
// continue ;
40348: GO 40243
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
40350: LD_ADDR_VAR 0 9
40354: PUSH
40355: LD_EXP 50
40359: PUSH
40360: LD_VAR 0 2
40364: ARRAY
40365: PPUSH
40366: LD_INT 30
40368: PUSH
40369: LD_INT 36
40371: PUSH
40372: EMPTY
40373: LIST
40374: LIST
40375: PPUSH
40376: CALL_OW 72
40380: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
40381: LD_ADDR_VAR 0 10
40385: PUSH
40386: LD_EXP 69
40390: PUSH
40391: LD_VAR 0 2
40395: ARRAY
40396: PPUSH
40397: LD_INT 34
40399: PUSH
40400: LD_INT 31
40402: PUSH
40403: EMPTY
40404: LIST
40405: LIST
40406: PPUSH
40407: CALL_OW 72
40411: ST_TO_ADDR
// if not cts and not mcts then
40412: LD_VAR 0 9
40416: NOT
40417: PUSH
40418: LD_VAR 0 10
40422: NOT
40423: AND
40424: IFFALSE 40428
// continue ;
40426: GO 40243
// x := cts ;
40428: LD_ADDR_VAR 0 11
40432: PUSH
40433: LD_VAR 0 9
40437: ST_TO_ADDR
// if not x then
40438: LD_VAR 0 11
40442: NOT
40443: IFFALSE 40455
// x := mcts ;
40445: LD_ADDR_VAR 0 11
40449: PUSH
40450: LD_VAR 0 10
40454: ST_TO_ADDR
// if not x then
40455: LD_VAR 0 11
40459: NOT
40460: IFFALSE 40464
// continue ;
40462: GO 40243
// if mc_remote_driver [ i ] then
40464: LD_EXP 90
40468: PUSH
40469: LD_VAR 0 2
40473: ARRAY
40474: IFFALSE 40861
// for j in mc_remote_driver [ i ] do
40476: LD_ADDR_VAR 0 3
40480: PUSH
40481: LD_EXP 90
40485: PUSH
40486: LD_VAR 0 2
40490: ARRAY
40491: PUSH
40492: FOR_IN
40493: IFFALSE 40859
// begin if GetClass ( j ) <> 3 then
40495: LD_VAR 0 3
40499: PPUSH
40500: CALL_OW 257
40504: PUSH
40505: LD_INT 3
40507: NONEQUAL
40508: IFFALSE 40561
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
40510: LD_ADDR_EXP 90
40514: PUSH
40515: LD_EXP 90
40519: PPUSH
40520: LD_VAR 0 2
40524: PPUSH
40525: LD_EXP 90
40529: PUSH
40530: LD_VAR 0 2
40534: ARRAY
40535: PUSH
40536: LD_VAR 0 3
40540: DIFF
40541: PPUSH
40542: CALL_OW 1
40546: ST_TO_ADDR
// SetTag ( j , 0 ) ;
40547: LD_VAR 0 3
40551: PPUSH
40552: LD_INT 0
40554: PPUSH
40555: CALL_OW 109
// continue ;
40559: GO 40492
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
40561: LD_EXP 69
40565: PUSH
40566: LD_VAR 0 2
40570: ARRAY
40571: PPUSH
40572: LD_INT 34
40574: PUSH
40575: LD_INT 31
40577: PUSH
40578: EMPTY
40579: LIST
40580: LIST
40581: PUSH
40582: LD_INT 58
40584: PUSH
40585: EMPTY
40586: LIST
40587: PUSH
40588: EMPTY
40589: LIST
40590: LIST
40591: PPUSH
40592: CALL_OW 72
40596: PUSH
40597: LD_VAR 0 3
40601: PPUSH
40602: CALL 84478 0 1
40606: NOT
40607: AND
40608: IFFALSE 40679
// begin if IsInUnit ( j ) then
40610: LD_VAR 0 3
40614: PPUSH
40615: CALL_OW 310
40619: IFFALSE 40630
// ComExitBuilding ( j ) ;
40621: LD_VAR 0 3
40625: PPUSH
40626: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
40630: LD_VAR 0 3
40634: PPUSH
40635: LD_EXP 69
40639: PUSH
40640: LD_VAR 0 2
40644: ARRAY
40645: PPUSH
40646: LD_INT 34
40648: PUSH
40649: LD_INT 31
40651: PUSH
40652: EMPTY
40653: LIST
40654: LIST
40655: PUSH
40656: LD_INT 58
40658: PUSH
40659: EMPTY
40660: LIST
40661: PUSH
40662: EMPTY
40663: LIST
40664: LIST
40665: PPUSH
40666: CALL_OW 72
40670: PUSH
40671: LD_INT 1
40673: ARRAY
40674: PPUSH
40675: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
40679: LD_VAR 0 3
40683: PPUSH
40684: CALL_OW 310
40688: NOT
40689: PUSH
40690: LD_VAR 0 3
40694: PPUSH
40695: CALL_OW 310
40699: PPUSH
40700: CALL_OW 266
40704: PUSH
40705: LD_INT 36
40707: NONEQUAL
40708: PUSH
40709: LD_VAR 0 3
40713: PPUSH
40714: CALL 84478 0 1
40718: NOT
40719: AND
40720: OR
40721: IFFALSE 40857
// begin if IsInUnit ( j ) then
40723: LD_VAR 0 3
40727: PPUSH
40728: CALL_OW 310
40732: IFFALSE 40743
// ComExitBuilding ( j ) ;
40734: LD_VAR 0 3
40738: PPUSH
40739: CALL_OW 122
// ct := 0 ;
40743: LD_ADDR_VAR 0 8
40747: PUSH
40748: LD_INT 0
40750: ST_TO_ADDR
// for k in x do
40751: LD_ADDR_VAR 0 4
40755: PUSH
40756: LD_VAR 0 11
40760: PUSH
40761: FOR_IN
40762: IFFALSE 40835
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
40764: LD_VAR 0 4
40768: PPUSH
40769: CALL_OW 264
40773: PUSH
40774: LD_INT 31
40776: EQUAL
40777: PUSH
40778: LD_VAR 0 4
40782: PPUSH
40783: CALL_OW 311
40787: NOT
40788: AND
40789: PUSH
40790: LD_VAR 0 4
40794: PPUSH
40795: CALL_OW 266
40799: PUSH
40800: LD_INT 36
40802: EQUAL
40803: PUSH
40804: LD_VAR 0 4
40808: PPUSH
40809: CALL_OW 313
40813: PUSH
40814: LD_INT 3
40816: LESS
40817: AND
40818: OR
40819: IFFALSE 40833
// begin ct := k ;
40821: LD_ADDR_VAR 0 8
40825: PUSH
40826: LD_VAR 0 4
40830: ST_TO_ADDR
// break ;
40831: GO 40835
// end ;
40833: GO 40761
40835: POP
40836: POP
// if ct then
40837: LD_VAR 0 8
40841: IFFALSE 40857
// ComEnterUnit ( j , ct ) ;
40843: LD_VAR 0 3
40847: PPUSH
40848: LD_VAR 0 8
40852: PPUSH
40853: CALL_OW 120
// end ; end ;
40857: GO 40492
40859: POP
40860: POP
// places := 0 ;
40861: LD_ADDR_VAR 0 5
40865: PUSH
40866: LD_INT 0
40868: ST_TO_ADDR
// for j = 1 to x do
40869: LD_ADDR_VAR 0 3
40873: PUSH
40874: DOUBLE
40875: LD_INT 1
40877: DEC
40878: ST_TO_ADDR
40879: LD_VAR 0 11
40883: PUSH
40884: FOR_TO
40885: IFFALSE 40961
// if GetWeapon ( x [ j ] ) = ar_control_tower then
40887: LD_VAR 0 11
40891: PUSH
40892: LD_VAR 0 3
40896: ARRAY
40897: PPUSH
40898: CALL_OW 264
40902: PUSH
40903: LD_INT 31
40905: EQUAL
40906: IFFALSE 40924
// places := places + 1 else
40908: LD_ADDR_VAR 0 5
40912: PUSH
40913: LD_VAR 0 5
40917: PUSH
40918: LD_INT 1
40920: PLUS
40921: ST_TO_ADDR
40922: GO 40959
// if GetBType ( x [ j ] ) = b_control_tower then
40924: LD_VAR 0 11
40928: PUSH
40929: LD_VAR 0 3
40933: ARRAY
40934: PPUSH
40935: CALL_OW 266
40939: PUSH
40940: LD_INT 36
40942: EQUAL
40943: IFFALSE 40959
// places := places + 3 ;
40945: LD_ADDR_VAR 0 5
40949: PUSH
40950: LD_VAR 0 5
40954: PUSH
40955: LD_INT 3
40957: PLUS
40958: ST_TO_ADDR
40959: GO 40884
40961: POP
40962: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
40963: LD_VAR 0 5
40967: PUSH
40968: LD_INT 0
40970: EQUAL
40971: PUSH
40972: LD_VAR 0 5
40976: PUSH
40977: LD_EXP 90
40981: PUSH
40982: LD_VAR 0 2
40986: ARRAY
40987: LESSEQUAL
40988: OR
40989: IFFALSE 40993
// continue ;
40991: GO 40243
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
40993: LD_ADDR_VAR 0 6
40997: PUSH
40998: LD_EXP 50
41002: PUSH
41003: LD_VAR 0 2
41007: ARRAY
41008: PPUSH
41009: LD_INT 25
41011: PUSH
41012: LD_INT 3
41014: PUSH
41015: EMPTY
41016: LIST
41017: LIST
41018: PPUSH
41019: CALL_OW 72
41023: PUSH
41024: LD_EXP 90
41028: PUSH
41029: LD_VAR 0 2
41033: ARRAY
41034: DIFF
41035: PPUSH
41036: LD_INT 3
41038: PPUSH
41039: CALL 85378 0 2
41043: ST_TO_ADDR
// for j in tmp do
41044: LD_ADDR_VAR 0 3
41048: PUSH
41049: LD_VAR 0 6
41053: PUSH
41054: FOR_IN
41055: IFFALSE 41090
// if GetTag ( j ) > 0 then
41057: LD_VAR 0 3
41061: PPUSH
41062: CALL_OW 110
41066: PUSH
41067: LD_INT 0
41069: GREATER
41070: IFFALSE 41088
// tmp := tmp diff j ;
41072: LD_ADDR_VAR 0 6
41076: PUSH
41077: LD_VAR 0 6
41081: PUSH
41082: LD_VAR 0 3
41086: DIFF
41087: ST_TO_ADDR
41088: GO 41054
41090: POP
41091: POP
// if not tmp then
41092: LD_VAR 0 6
41096: NOT
41097: IFFALSE 41101
// continue ;
41099: GO 40243
// if places then
41101: LD_VAR 0 5
41105: IFFALSE 41164
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
41107: LD_ADDR_EXP 90
41111: PUSH
41112: LD_EXP 90
41116: PPUSH
41117: LD_VAR 0 2
41121: PPUSH
41122: LD_EXP 90
41126: PUSH
41127: LD_VAR 0 2
41131: ARRAY
41132: PUSH
41133: LD_VAR 0 6
41137: PUSH
41138: LD_INT 1
41140: ARRAY
41141: UNION
41142: PPUSH
41143: CALL_OW 1
41147: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
41148: LD_VAR 0 6
41152: PUSH
41153: LD_INT 1
41155: ARRAY
41156: PPUSH
41157: LD_INT 126
41159: PPUSH
41160: CALL_OW 109
// end ; end ;
41164: GO 40243
41166: POP
41167: POP
// end ;
41168: LD_VAR 0 1
41172: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
41173: LD_INT 0
41175: PPUSH
41176: PPUSH
41177: PPUSH
41178: PPUSH
41179: PPUSH
41180: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
41181: LD_VAR 0 1
41185: NOT
41186: PUSH
41187: LD_VAR 0 2
41191: NOT
41192: OR
41193: PUSH
41194: LD_VAR 0 3
41198: NOT
41199: OR
41200: PUSH
41201: LD_VAR 0 4
41205: PUSH
41206: LD_INT 1
41208: PUSH
41209: LD_INT 2
41211: PUSH
41212: LD_INT 3
41214: PUSH
41215: LD_INT 4
41217: PUSH
41218: LD_INT 5
41220: PUSH
41221: LD_INT 8
41223: PUSH
41224: LD_INT 9
41226: PUSH
41227: LD_INT 15
41229: PUSH
41230: LD_INT 16
41232: PUSH
41233: EMPTY
41234: LIST
41235: LIST
41236: LIST
41237: LIST
41238: LIST
41239: LIST
41240: LIST
41241: LIST
41242: LIST
41243: IN
41244: NOT
41245: OR
41246: IFFALSE 41250
// exit ;
41248: GO 42108
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
41250: LD_ADDR_VAR 0 2
41254: PUSH
41255: LD_VAR 0 2
41259: PPUSH
41260: LD_INT 21
41262: PUSH
41263: LD_INT 3
41265: PUSH
41266: EMPTY
41267: LIST
41268: LIST
41269: PUSH
41270: LD_INT 24
41272: PUSH
41273: LD_INT 250
41275: PUSH
41276: EMPTY
41277: LIST
41278: LIST
41279: PUSH
41280: EMPTY
41281: LIST
41282: LIST
41283: PPUSH
41284: CALL_OW 72
41288: ST_TO_ADDR
// case class of 1 , 15 :
41289: LD_VAR 0 4
41293: PUSH
41294: LD_INT 1
41296: DOUBLE
41297: EQUAL
41298: IFTRUE 41308
41300: LD_INT 15
41302: DOUBLE
41303: EQUAL
41304: IFTRUE 41308
41306: GO 41393
41308: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
41309: LD_ADDR_VAR 0 8
41313: PUSH
41314: LD_VAR 0 2
41318: PPUSH
41319: LD_INT 2
41321: PUSH
41322: LD_INT 30
41324: PUSH
41325: LD_INT 32
41327: PUSH
41328: EMPTY
41329: LIST
41330: LIST
41331: PUSH
41332: LD_INT 30
41334: PUSH
41335: LD_INT 31
41337: PUSH
41338: EMPTY
41339: LIST
41340: LIST
41341: PUSH
41342: EMPTY
41343: LIST
41344: LIST
41345: LIST
41346: PPUSH
41347: CALL_OW 72
41351: PUSH
41352: LD_VAR 0 2
41356: PPUSH
41357: LD_INT 2
41359: PUSH
41360: LD_INT 30
41362: PUSH
41363: LD_INT 4
41365: PUSH
41366: EMPTY
41367: LIST
41368: LIST
41369: PUSH
41370: LD_INT 30
41372: PUSH
41373: LD_INT 5
41375: PUSH
41376: EMPTY
41377: LIST
41378: LIST
41379: PUSH
41380: EMPTY
41381: LIST
41382: LIST
41383: LIST
41384: PPUSH
41385: CALL_OW 72
41389: ADD
41390: ST_TO_ADDR
41391: GO 41639
41393: LD_INT 2
41395: DOUBLE
41396: EQUAL
41397: IFTRUE 41407
41399: LD_INT 16
41401: DOUBLE
41402: EQUAL
41403: IFTRUE 41407
41405: GO 41453
41407: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
41408: LD_ADDR_VAR 0 8
41412: PUSH
41413: LD_VAR 0 2
41417: PPUSH
41418: LD_INT 2
41420: PUSH
41421: LD_INT 30
41423: PUSH
41424: LD_INT 0
41426: PUSH
41427: EMPTY
41428: LIST
41429: LIST
41430: PUSH
41431: LD_INT 30
41433: PUSH
41434: LD_INT 1
41436: PUSH
41437: EMPTY
41438: LIST
41439: LIST
41440: PUSH
41441: EMPTY
41442: LIST
41443: LIST
41444: LIST
41445: PPUSH
41446: CALL_OW 72
41450: ST_TO_ADDR
41451: GO 41639
41453: LD_INT 3
41455: DOUBLE
41456: EQUAL
41457: IFTRUE 41461
41459: GO 41507
41461: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
41462: LD_ADDR_VAR 0 8
41466: PUSH
41467: LD_VAR 0 2
41471: PPUSH
41472: LD_INT 2
41474: PUSH
41475: LD_INT 30
41477: PUSH
41478: LD_INT 2
41480: PUSH
41481: EMPTY
41482: LIST
41483: LIST
41484: PUSH
41485: LD_INT 30
41487: PUSH
41488: LD_INT 3
41490: PUSH
41491: EMPTY
41492: LIST
41493: LIST
41494: PUSH
41495: EMPTY
41496: LIST
41497: LIST
41498: LIST
41499: PPUSH
41500: CALL_OW 72
41504: ST_TO_ADDR
41505: GO 41639
41507: LD_INT 4
41509: DOUBLE
41510: EQUAL
41511: IFTRUE 41515
41513: GO 41572
41515: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
41516: LD_ADDR_VAR 0 8
41520: PUSH
41521: LD_VAR 0 2
41525: PPUSH
41526: LD_INT 2
41528: PUSH
41529: LD_INT 30
41531: PUSH
41532: LD_INT 6
41534: PUSH
41535: EMPTY
41536: LIST
41537: LIST
41538: PUSH
41539: LD_INT 30
41541: PUSH
41542: LD_INT 7
41544: PUSH
41545: EMPTY
41546: LIST
41547: LIST
41548: PUSH
41549: LD_INT 30
41551: PUSH
41552: LD_INT 8
41554: PUSH
41555: EMPTY
41556: LIST
41557: LIST
41558: PUSH
41559: EMPTY
41560: LIST
41561: LIST
41562: LIST
41563: LIST
41564: PPUSH
41565: CALL_OW 72
41569: ST_TO_ADDR
41570: GO 41639
41572: LD_INT 5
41574: DOUBLE
41575: EQUAL
41576: IFTRUE 41592
41578: LD_INT 8
41580: DOUBLE
41581: EQUAL
41582: IFTRUE 41592
41584: LD_INT 9
41586: DOUBLE
41587: EQUAL
41588: IFTRUE 41592
41590: GO 41638
41592: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
41593: LD_ADDR_VAR 0 8
41597: PUSH
41598: LD_VAR 0 2
41602: PPUSH
41603: LD_INT 2
41605: PUSH
41606: LD_INT 30
41608: PUSH
41609: LD_INT 4
41611: PUSH
41612: EMPTY
41613: LIST
41614: LIST
41615: PUSH
41616: LD_INT 30
41618: PUSH
41619: LD_INT 5
41621: PUSH
41622: EMPTY
41623: LIST
41624: LIST
41625: PUSH
41626: EMPTY
41627: LIST
41628: LIST
41629: LIST
41630: PPUSH
41631: CALL_OW 72
41635: ST_TO_ADDR
41636: GO 41639
41638: POP
// if not tmp then
41639: LD_VAR 0 8
41643: NOT
41644: IFFALSE 41648
// exit ;
41646: GO 42108
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
41648: LD_VAR 0 4
41652: PUSH
41653: LD_INT 1
41655: PUSH
41656: LD_INT 15
41658: PUSH
41659: EMPTY
41660: LIST
41661: LIST
41662: IN
41663: PUSH
41664: LD_EXP 59
41668: PUSH
41669: LD_VAR 0 1
41673: ARRAY
41674: AND
41675: IFFALSE 41831
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
41677: LD_ADDR_VAR 0 9
41681: PUSH
41682: LD_EXP 59
41686: PUSH
41687: LD_VAR 0 1
41691: ARRAY
41692: PUSH
41693: LD_INT 1
41695: ARRAY
41696: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
41697: LD_VAR 0 9
41701: PUSH
41702: LD_EXP 60
41706: PUSH
41707: LD_VAR 0 1
41711: ARRAY
41712: IN
41713: NOT
41714: IFFALSE 41829
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
41716: LD_ADDR_EXP 60
41720: PUSH
41721: LD_EXP 60
41725: PPUSH
41726: LD_VAR 0 1
41730: PUSH
41731: LD_EXP 60
41735: PUSH
41736: LD_VAR 0 1
41740: ARRAY
41741: PUSH
41742: LD_INT 1
41744: PLUS
41745: PUSH
41746: EMPTY
41747: LIST
41748: LIST
41749: PPUSH
41750: LD_VAR 0 9
41754: PPUSH
41755: CALL 54145 0 3
41759: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
41760: LD_ADDR_EXP 59
41764: PUSH
41765: LD_EXP 59
41769: PPUSH
41770: LD_VAR 0 1
41774: PPUSH
41775: LD_EXP 59
41779: PUSH
41780: LD_VAR 0 1
41784: ARRAY
41785: PUSH
41786: LD_VAR 0 9
41790: DIFF
41791: PPUSH
41792: CALL_OW 1
41796: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
41797: LD_VAR 0 3
41801: PPUSH
41802: LD_EXP 60
41806: PUSH
41807: LD_VAR 0 1
41811: ARRAY
41812: PUSH
41813: LD_EXP 60
41817: PUSH
41818: LD_VAR 0 1
41822: ARRAY
41823: ARRAY
41824: PPUSH
41825: CALL_OW 120
// end ; exit ;
41829: GO 42108
// end ; if tmp > 1 then
41831: LD_VAR 0 8
41835: PUSH
41836: LD_INT 1
41838: GREATER
41839: IFFALSE 41943
// for i = 2 to tmp do
41841: LD_ADDR_VAR 0 6
41845: PUSH
41846: DOUBLE
41847: LD_INT 2
41849: DEC
41850: ST_TO_ADDR
41851: LD_VAR 0 8
41855: PUSH
41856: FOR_TO
41857: IFFALSE 41941
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
41859: LD_VAR 0 8
41863: PUSH
41864: LD_VAR 0 6
41868: ARRAY
41869: PPUSH
41870: CALL_OW 461
41874: PUSH
41875: LD_INT 6
41877: EQUAL
41878: IFFALSE 41939
// begin x := tmp [ i ] ;
41880: LD_ADDR_VAR 0 9
41884: PUSH
41885: LD_VAR 0 8
41889: PUSH
41890: LD_VAR 0 6
41894: ARRAY
41895: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
41896: LD_ADDR_VAR 0 8
41900: PUSH
41901: LD_VAR 0 8
41905: PPUSH
41906: LD_VAR 0 6
41910: PPUSH
41911: CALL_OW 3
41915: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
41916: LD_ADDR_VAR 0 8
41920: PUSH
41921: LD_VAR 0 8
41925: PPUSH
41926: LD_INT 1
41928: PPUSH
41929: LD_VAR 0 9
41933: PPUSH
41934: CALL_OW 2
41938: ST_TO_ADDR
// end ;
41939: GO 41856
41941: POP
41942: POP
// for i in tmp do
41943: LD_ADDR_VAR 0 6
41947: PUSH
41948: LD_VAR 0 8
41952: PUSH
41953: FOR_IN
41954: IFFALSE 41981
// begin if IsNotFull ( i ) then
41956: LD_VAR 0 6
41960: PPUSH
41961: CALL 51367 0 1
41965: IFFALSE 41979
// begin j := i ;
41967: LD_ADDR_VAR 0 7
41971: PUSH
41972: LD_VAR 0 6
41976: ST_TO_ADDR
// break ;
41977: GO 41981
// end ; end ;
41979: GO 41953
41981: POP
41982: POP
// if j then
41983: LD_VAR 0 7
41987: IFFALSE 42005
// ComEnterUnit ( unit , j ) else
41989: LD_VAR 0 3
41993: PPUSH
41994: LD_VAR 0 7
41998: PPUSH
41999: CALL_OW 120
42003: GO 42108
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
42005: LD_ADDR_VAR 0 10
42009: PUSH
42010: LD_VAR 0 2
42014: PPUSH
42015: LD_INT 2
42017: PUSH
42018: LD_INT 30
42020: PUSH
42021: LD_INT 0
42023: PUSH
42024: EMPTY
42025: LIST
42026: LIST
42027: PUSH
42028: LD_INT 30
42030: PUSH
42031: LD_INT 1
42033: PUSH
42034: EMPTY
42035: LIST
42036: LIST
42037: PUSH
42038: EMPTY
42039: LIST
42040: LIST
42041: LIST
42042: PPUSH
42043: CALL_OW 72
42047: ST_TO_ADDR
// if depot then
42048: LD_VAR 0 10
42052: IFFALSE 42108
// begin depot := NearestUnitToUnit ( depot , unit ) ;
42054: LD_ADDR_VAR 0 10
42058: PUSH
42059: LD_VAR 0 10
42063: PPUSH
42064: LD_VAR 0 3
42068: PPUSH
42069: CALL_OW 74
42073: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
42074: LD_VAR 0 3
42078: PPUSH
42079: LD_VAR 0 10
42083: PPUSH
42084: CALL_OW 296
42088: PUSH
42089: LD_INT 10
42091: GREATER
42092: IFFALSE 42108
// ComStandNearbyBuilding ( unit , depot ) ;
42094: LD_VAR 0 3
42098: PPUSH
42099: LD_VAR 0 10
42103: PPUSH
42104: CALL 50747 0 2
// end ; end ; end ;
42108: LD_VAR 0 5
42112: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
42113: LD_INT 0
42115: PPUSH
42116: PPUSH
42117: PPUSH
42118: PPUSH
// if not mc_bases then
42119: LD_EXP 50
42123: NOT
42124: IFFALSE 42128
// exit ;
42126: GO 42367
// for i = 1 to mc_bases do
42128: LD_ADDR_VAR 0 2
42132: PUSH
42133: DOUBLE
42134: LD_INT 1
42136: DEC
42137: ST_TO_ADDR
42138: LD_EXP 50
42142: PUSH
42143: FOR_TO
42144: IFFALSE 42365
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
42146: LD_ADDR_VAR 0 4
42150: PUSH
42151: LD_EXP 50
42155: PUSH
42156: LD_VAR 0 2
42160: ARRAY
42161: PPUSH
42162: LD_INT 21
42164: PUSH
42165: LD_INT 1
42167: PUSH
42168: EMPTY
42169: LIST
42170: LIST
42171: PPUSH
42172: CALL_OW 72
42176: PUSH
42177: LD_EXP 79
42181: PUSH
42182: LD_VAR 0 2
42186: ARRAY
42187: UNION
42188: ST_TO_ADDR
// if not tmp then
42189: LD_VAR 0 4
42193: NOT
42194: IFFALSE 42198
// continue ;
42196: GO 42143
// for j in tmp do
42198: LD_ADDR_VAR 0 3
42202: PUSH
42203: LD_VAR 0 4
42207: PUSH
42208: FOR_IN
42209: IFFALSE 42361
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
42211: LD_VAR 0 3
42215: PPUSH
42216: CALL_OW 110
42220: NOT
42221: PUSH
42222: LD_VAR 0 3
42226: PPUSH
42227: CALL_OW 314
42231: NOT
42232: AND
42233: PUSH
42234: LD_VAR 0 3
42238: PPUSH
42239: CALL_OW 311
42243: NOT
42244: AND
42245: PUSH
42246: LD_VAR 0 3
42250: PPUSH
42251: CALL_OW 310
42255: NOT
42256: AND
42257: PUSH
42258: LD_VAR 0 3
42262: PUSH
42263: LD_EXP 53
42267: PUSH
42268: LD_VAR 0 2
42272: ARRAY
42273: PUSH
42274: LD_INT 1
42276: ARRAY
42277: IN
42278: NOT
42279: AND
42280: PUSH
42281: LD_VAR 0 3
42285: PUSH
42286: LD_EXP 53
42290: PUSH
42291: LD_VAR 0 2
42295: ARRAY
42296: PUSH
42297: LD_INT 2
42299: ARRAY
42300: IN
42301: NOT
42302: AND
42303: PUSH
42304: LD_VAR 0 3
42308: PUSH
42309: LD_EXP 62
42313: PUSH
42314: LD_VAR 0 2
42318: ARRAY
42319: IN
42320: NOT
42321: AND
42322: IFFALSE 42359
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
42324: LD_VAR 0 2
42328: PPUSH
42329: LD_EXP 50
42333: PUSH
42334: LD_VAR 0 2
42338: ARRAY
42339: PPUSH
42340: LD_VAR 0 3
42344: PPUSH
42345: LD_VAR 0 3
42349: PPUSH
42350: CALL_OW 257
42354: PPUSH
42355: CALL 41173 0 4
// end ;
42359: GO 42208
42361: POP
42362: POP
// end ;
42363: GO 42143
42365: POP
42366: POP
// end ;
42367: LD_VAR 0 1
42371: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
42372: LD_INT 0
42374: PPUSH
42375: PPUSH
42376: PPUSH
42377: PPUSH
42378: PPUSH
42379: PPUSH
// if not mc_bases [ base ] then
42380: LD_EXP 50
42384: PUSH
42385: LD_VAR 0 1
42389: ARRAY
42390: NOT
42391: IFFALSE 42395
// exit ;
42393: GO 42596
// tmp := [ ] ;
42395: LD_ADDR_VAR 0 6
42399: PUSH
42400: EMPTY
42401: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
42402: LD_ADDR_VAR 0 7
42406: PUSH
42407: LD_VAR 0 3
42411: PPUSH
42412: LD_INT 0
42414: PPUSH
42415: CALL_OW 517
42419: ST_TO_ADDR
// if not list then
42420: LD_VAR 0 7
42424: NOT
42425: IFFALSE 42429
// exit ;
42427: GO 42596
// c := Count ( list [ 1 ] ) ;
42429: LD_ADDR_VAR 0 9
42433: PUSH
42434: LD_VAR 0 7
42438: PUSH
42439: LD_INT 1
42441: ARRAY
42442: PPUSH
42443: CALL 51285 0 1
42447: ST_TO_ADDR
// if amount > c then
42448: LD_VAR 0 2
42452: PUSH
42453: LD_VAR 0 9
42457: GREATER
42458: IFFALSE 42470
// amount := c ;
42460: LD_ADDR_VAR 0 2
42464: PUSH
42465: LD_VAR 0 9
42469: ST_TO_ADDR
// for i := 1 to amount do
42470: LD_ADDR_VAR 0 5
42474: PUSH
42475: DOUBLE
42476: LD_INT 1
42478: DEC
42479: ST_TO_ADDR
42480: LD_VAR 0 2
42484: PUSH
42485: FOR_TO
42486: IFFALSE 42544
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
42488: LD_ADDR_VAR 0 6
42492: PUSH
42493: LD_VAR 0 6
42497: PPUSH
42498: LD_VAR 0 5
42502: PPUSH
42503: LD_VAR 0 7
42507: PUSH
42508: LD_INT 1
42510: ARRAY
42511: PUSH
42512: LD_VAR 0 5
42516: ARRAY
42517: PUSH
42518: LD_VAR 0 7
42522: PUSH
42523: LD_INT 2
42525: ARRAY
42526: PUSH
42527: LD_VAR 0 5
42531: ARRAY
42532: PUSH
42533: EMPTY
42534: LIST
42535: LIST
42536: PPUSH
42537: CALL_OW 1
42541: ST_TO_ADDR
42542: GO 42485
42544: POP
42545: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
42546: LD_ADDR_EXP 63
42550: PUSH
42551: LD_EXP 63
42555: PPUSH
42556: LD_VAR 0 1
42560: PPUSH
42561: LD_VAR 0 6
42565: PPUSH
42566: CALL_OW 1
42570: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
42571: LD_ADDR_EXP 65
42575: PUSH
42576: LD_EXP 65
42580: PPUSH
42581: LD_VAR 0 1
42585: PPUSH
42586: LD_VAR 0 3
42590: PPUSH
42591: CALL_OW 1
42595: ST_TO_ADDR
// end ;
42596: LD_VAR 0 4
42600: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
42601: LD_INT 0
42603: PPUSH
// if not mc_bases [ base ] then
42604: LD_EXP 50
42608: PUSH
42609: LD_VAR 0 1
42613: ARRAY
42614: NOT
42615: IFFALSE 42619
// exit ;
42617: GO 42644
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
42619: LD_ADDR_EXP 55
42623: PUSH
42624: LD_EXP 55
42628: PPUSH
42629: LD_VAR 0 1
42633: PPUSH
42634: LD_VAR 0 2
42638: PPUSH
42639: CALL_OW 1
42643: ST_TO_ADDR
// end ;
42644: LD_VAR 0 3
42648: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
42649: LD_INT 0
42651: PPUSH
// if not mc_bases [ base ] then
42652: LD_EXP 50
42656: PUSH
42657: LD_VAR 0 1
42661: ARRAY
42662: NOT
42663: IFFALSE 42667
// exit ;
42665: GO 42704
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
42667: LD_ADDR_EXP 55
42671: PUSH
42672: LD_EXP 55
42676: PPUSH
42677: LD_VAR 0 1
42681: PPUSH
42682: LD_EXP 55
42686: PUSH
42687: LD_VAR 0 1
42691: ARRAY
42692: PUSH
42693: LD_VAR 0 2
42697: UNION
42698: PPUSH
42699: CALL_OW 1
42703: ST_TO_ADDR
// end ;
42704: LD_VAR 0 3
42708: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
42709: LD_INT 0
42711: PPUSH
// if not mc_bases [ base ] then
42712: LD_EXP 50
42716: PUSH
42717: LD_VAR 0 1
42721: ARRAY
42722: NOT
42723: IFFALSE 42727
// exit ;
42725: GO 42752
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
42727: LD_ADDR_EXP 71
42731: PUSH
42732: LD_EXP 71
42736: PPUSH
42737: LD_VAR 0 1
42741: PPUSH
42742: LD_VAR 0 2
42746: PPUSH
42747: CALL_OW 1
42751: ST_TO_ADDR
// end ;
42752: LD_VAR 0 3
42756: RET
// export function MC_InsertProduceList ( base , components ) ; begin
42757: LD_INT 0
42759: PPUSH
// if not mc_bases [ base ] then
42760: LD_EXP 50
42764: PUSH
42765: LD_VAR 0 1
42769: ARRAY
42770: NOT
42771: IFFALSE 42775
// exit ;
42773: GO 42812
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
42775: LD_ADDR_EXP 71
42779: PUSH
42780: LD_EXP 71
42784: PPUSH
42785: LD_VAR 0 1
42789: PPUSH
42790: LD_EXP 71
42794: PUSH
42795: LD_VAR 0 1
42799: ARRAY
42800: PUSH
42801: LD_VAR 0 2
42805: ADD
42806: PPUSH
42807: CALL_OW 1
42811: ST_TO_ADDR
// end ;
42812: LD_VAR 0 3
42816: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
42817: LD_INT 0
42819: PPUSH
// if not mc_bases [ base ] then
42820: LD_EXP 50
42824: PUSH
42825: LD_VAR 0 1
42829: ARRAY
42830: NOT
42831: IFFALSE 42835
// exit ;
42833: GO 42889
// mc_defender := Replace ( mc_defender , base , deflist ) ;
42835: LD_ADDR_EXP 72
42839: PUSH
42840: LD_EXP 72
42844: PPUSH
42845: LD_VAR 0 1
42849: PPUSH
42850: LD_VAR 0 2
42854: PPUSH
42855: CALL_OW 1
42859: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
42860: LD_ADDR_EXP 61
42864: PUSH
42865: LD_EXP 61
42869: PPUSH
42870: LD_VAR 0 1
42874: PPUSH
42875: LD_VAR 0 2
42879: PUSH
42880: LD_INT 0
42882: PLUS
42883: PPUSH
42884: CALL_OW 1
42888: ST_TO_ADDR
// end ;
42889: LD_VAR 0 3
42893: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
42894: LD_INT 0
42896: PPUSH
// if not mc_bases [ base ] then
42897: LD_EXP 50
42901: PUSH
42902: LD_VAR 0 1
42906: ARRAY
42907: NOT
42908: IFFALSE 42912
// exit ;
42910: GO 42937
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
42912: LD_ADDR_EXP 61
42916: PUSH
42917: LD_EXP 61
42921: PPUSH
42922: LD_VAR 0 1
42926: PPUSH
42927: LD_VAR 0 2
42931: PPUSH
42932: CALL_OW 1
42936: ST_TO_ADDR
// end ;
42937: LD_VAR 0 3
42941: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
42942: LD_INT 0
42944: PPUSH
42945: PPUSH
42946: PPUSH
42947: PPUSH
// if not mc_bases [ base ] then
42948: LD_EXP 50
42952: PUSH
42953: LD_VAR 0 1
42957: ARRAY
42958: NOT
42959: IFFALSE 42963
// exit ;
42961: GO 43028
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
42963: LD_ADDR_EXP 70
42967: PUSH
42968: LD_EXP 70
42972: PPUSH
42973: LD_VAR 0 1
42977: PUSH
42978: LD_EXP 70
42982: PUSH
42983: LD_VAR 0 1
42987: ARRAY
42988: PUSH
42989: LD_INT 1
42991: PLUS
42992: PUSH
42993: EMPTY
42994: LIST
42995: LIST
42996: PPUSH
42997: LD_VAR 0 1
43001: PUSH
43002: LD_VAR 0 2
43006: PUSH
43007: LD_VAR 0 3
43011: PUSH
43012: LD_VAR 0 4
43016: PUSH
43017: EMPTY
43018: LIST
43019: LIST
43020: LIST
43021: LIST
43022: PPUSH
43023: CALL 54145 0 3
43027: ST_TO_ADDR
// end ;
43028: LD_VAR 0 5
43032: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
43033: LD_INT 0
43035: PPUSH
// if not mc_bases [ base ] then
43036: LD_EXP 50
43040: PUSH
43041: LD_VAR 0 1
43045: ARRAY
43046: NOT
43047: IFFALSE 43051
// exit ;
43049: GO 43076
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
43051: LD_ADDR_EXP 87
43055: PUSH
43056: LD_EXP 87
43060: PPUSH
43061: LD_VAR 0 1
43065: PPUSH
43066: LD_VAR 0 2
43070: PPUSH
43071: CALL_OW 1
43075: ST_TO_ADDR
// end ;
43076: LD_VAR 0 3
43080: RET
// export function MC_GetMinesField ( base ) ; begin
43081: LD_INT 0
43083: PPUSH
// result := mc_mines [ base ] ;
43084: LD_ADDR_VAR 0 2
43088: PUSH
43089: LD_EXP 63
43093: PUSH
43094: LD_VAR 0 1
43098: ARRAY
43099: ST_TO_ADDR
// end ;
43100: LD_VAR 0 2
43104: RET
// export function MC_GetProduceList ( base ) ; begin
43105: LD_INT 0
43107: PPUSH
// result := mc_produce [ base ] ;
43108: LD_ADDR_VAR 0 2
43112: PUSH
43113: LD_EXP 71
43117: PUSH
43118: LD_VAR 0 1
43122: ARRAY
43123: ST_TO_ADDR
// end ;
43124: LD_VAR 0 2
43128: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
43129: LD_INT 0
43131: PPUSH
43132: PPUSH
// if not mc_bases then
43133: LD_EXP 50
43137: NOT
43138: IFFALSE 43142
// exit ;
43140: GO 43207
// if mc_bases [ base ] then
43142: LD_EXP 50
43146: PUSH
43147: LD_VAR 0 1
43151: ARRAY
43152: IFFALSE 43207
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
43154: LD_ADDR_VAR 0 3
43158: PUSH
43159: LD_EXP 50
43163: PUSH
43164: LD_VAR 0 1
43168: ARRAY
43169: PPUSH
43170: LD_INT 30
43172: PUSH
43173: LD_VAR 0 2
43177: PUSH
43178: EMPTY
43179: LIST
43180: LIST
43181: PPUSH
43182: CALL_OW 72
43186: ST_TO_ADDR
// if result then
43187: LD_VAR 0 3
43191: IFFALSE 43207
// result := result [ 1 ] ;
43193: LD_ADDR_VAR 0 3
43197: PUSH
43198: LD_VAR 0 3
43202: PUSH
43203: LD_INT 1
43205: ARRAY
43206: ST_TO_ADDR
// end ; end ;
43207: LD_VAR 0 3
43211: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
43212: LD_INT 0
43214: PPUSH
43215: PPUSH
// if not mc_bases then
43216: LD_EXP 50
43220: NOT
43221: IFFALSE 43225
// exit ;
43223: GO 43270
// if mc_bases [ base ] then
43225: LD_EXP 50
43229: PUSH
43230: LD_VAR 0 1
43234: ARRAY
43235: IFFALSE 43270
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
43237: LD_ADDR_VAR 0 3
43241: PUSH
43242: LD_EXP 50
43246: PUSH
43247: LD_VAR 0 1
43251: ARRAY
43252: PPUSH
43253: LD_INT 30
43255: PUSH
43256: LD_VAR 0 2
43260: PUSH
43261: EMPTY
43262: LIST
43263: LIST
43264: PPUSH
43265: CALL_OW 72
43269: ST_TO_ADDR
// end ;
43270: LD_VAR 0 3
43274: RET
// export function MC_SetTame ( base , area ) ; begin
43275: LD_INT 0
43277: PPUSH
// if not mc_bases or not base then
43278: LD_EXP 50
43282: NOT
43283: PUSH
43284: LD_VAR 0 1
43288: NOT
43289: OR
43290: IFFALSE 43294
// exit ;
43292: GO 43319
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
43294: LD_ADDR_EXP 78
43298: PUSH
43299: LD_EXP 78
43303: PPUSH
43304: LD_VAR 0 1
43308: PPUSH
43309: LD_VAR 0 2
43313: PPUSH
43314: CALL_OW 1
43318: ST_TO_ADDR
// end ;
43319: LD_VAR 0 3
43323: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
43324: LD_INT 0
43326: PPUSH
43327: PPUSH
// if not mc_bases or not base then
43328: LD_EXP 50
43332: NOT
43333: PUSH
43334: LD_VAR 0 1
43338: NOT
43339: OR
43340: IFFALSE 43344
// exit ;
43342: GO 43446
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
43344: LD_ADDR_VAR 0 4
43348: PUSH
43349: LD_EXP 50
43353: PUSH
43354: LD_VAR 0 1
43358: ARRAY
43359: PPUSH
43360: LD_INT 30
43362: PUSH
43363: LD_VAR 0 2
43367: PUSH
43368: EMPTY
43369: LIST
43370: LIST
43371: PPUSH
43372: CALL_OW 72
43376: ST_TO_ADDR
// if not tmp then
43377: LD_VAR 0 4
43381: NOT
43382: IFFALSE 43386
// exit ;
43384: GO 43446
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
43386: LD_ADDR_EXP 82
43390: PUSH
43391: LD_EXP 82
43395: PPUSH
43396: LD_VAR 0 1
43400: PPUSH
43401: LD_EXP 82
43405: PUSH
43406: LD_VAR 0 1
43410: ARRAY
43411: PPUSH
43412: LD_EXP 82
43416: PUSH
43417: LD_VAR 0 1
43421: ARRAY
43422: PUSH
43423: LD_INT 1
43425: PLUS
43426: PPUSH
43427: LD_VAR 0 4
43431: PUSH
43432: LD_INT 1
43434: ARRAY
43435: PPUSH
43436: CALL_OW 2
43440: PPUSH
43441: CALL_OW 1
43445: ST_TO_ADDR
// end ;
43446: LD_VAR 0 3
43450: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
43451: LD_INT 0
43453: PPUSH
43454: PPUSH
// if not mc_bases or not base or not kinds then
43455: LD_EXP 50
43459: NOT
43460: PUSH
43461: LD_VAR 0 1
43465: NOT
43466: OR
43467: PUSH
43468: LD_VAR 0 2
43472: NOT
43473: OR
43474: IFFALSE 43478
// exit ;
43476: GO 43539
// for i in kinds do
43478: LD_ADDR_VAR 0 4
43482: PUSH
43483: LD_VAR 0 2
43487: PUSH
43488: FOR_IN
43489: IFFALSE 43537
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
43491: LD_ADDR_EXP 84
43495: PUSH
43496: LD_EXP 84
43500: PPUSH
43501: LD_VAR 0 1
43505: PUSH
43506: LD_EXP 84
43510: PUSH
43511: LD_VAR 0 1
43515: ARRAY
43516: PUSH
43517: LD_INT 1
43519: PLUS
43520: PUSH
43521: EMPTY
43522: LIST
43523: LIST
43524: PPUSH
43525: LD_VAR 0 4
43529: PPUSH
43530: CALL 54145 0 3
43534: ST_TO_ADDR
43535: GO 43488
43537: POP
43538: POP
// end ;
43539: LD_VAR 0 3
43543: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
43544: LD_INT 0
43546: PPUSH
// if not mc_bases or not base or not areas then
43547: LD_EXP 50
43551: NOT
43552: PUSH
43553: LD_VAR 0 1
43557: NOT
43558: OR
43559: PUSH
43560: LD_VAR 0 2
43564: NOT
43565: OR
43566: IFFALSE 43570
// exit ;
43568: GO 43595
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
43570: LD_ADDR_EXP 68
43574: PUSH
43575: LD_EXP 68
43579: PPUSH
43580: LD_VAR 0 1
43584: PPUSH
43585: LD_VAR 0 2
43589: PPUSH
43590: CALL_OW 1
43594: ST_TO_ADDR
// end ;
43595: LD_VAR 0 3
43599: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
43600: LD_INT 0
43602: PPUSH
// if not mc_bases or not base or not teleports_exit then
43603: LD_EXP 50
43607: NOT
43608: PUSH
43609: LD_VAR 0 1
43613: NOT
43614: OR
43615: PUSH
43616: LD_VAR 0 2
43620: NOT
43621: OR
43622: IFFALSE 43626
// exit ;
43624: GO 43651
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
43626: LD_ADDR_EXP 85
43630: PUSH
43631: LD_EXP 85
43635: PPUSH
43636: LD_VAR 0 1
43640: PPUSH
43641: LD_VAR 0 2
43645: PPUSH
43646: CALL_OW 1
43650: ST_TO_ADDR
// end ;
43651: LD_VAR 0 3
43655: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
43656: LD_INT 0
43658: PPUSH
43659: PPUSH
43660: PPUSH
// if not mc_bases or not base or not ext_list then
43661: LD_EXP 50
43665: NOT
43666: PUSH
43667: LD_VAR 0 1
43671: NOT
43672: OR
43673: PUSH
43674: LD_VAR 0 5
43678: NOT
43679: OR
43680: IFFALSE 43684
// exit ;
43682: GO 43857
// tmp := GetFacExtXYD ( x , y , d ) ;
43684: LD_ADDR_VAR 0 8
43688: PUSH
43689: LD_VAR 0 2
43693: PPUSH
43694: LD_VAR 0 3
43698: PPUSH
43699: LD_VAR 0 4
43703: PPUSH
43704: CALL 84508 0 3
43708: ST_TO_ADDR
// if not tmp then
43709: LD_VAR 0 8
43713: NOT
43714: IFFALSE 43718
// exit ;
43716: GO 43857
// for i in tmp do
43718: LD_ADDR_VAR 0 7
43722: PUSH
43723: LD_VAR 0 8
43727: PUSH
43728: FOR_IN
43729: IFFALSE 43855
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
43731: LD_ADDR_EXP 55
43735: PUSH
43736: LD_EXP 55
43740: PPUSH
43741: LD_VAR 0 1
43745: PPUSH
43746: LD_EXP 55
43750: PUSH
43751: LD_VAR 0 1
43755: ARRAY
43756: PPUSH
43757: LD_EXP 55
43761: PUSH
43762: LD_VAR 0 1
43766: ARRAY
43767: PUSH
43768: LD_INT 1
43770: PLUS
43771: PPUSH
43772: LD_VAR 0 5
43776: PUSH
43777: LD_INT 1
43779: ARRAY
43780: PUSH
43781: LD_VAR 0 7
43785: PUSH
43786: LD_INT 1
43788: ARRAY
43789: PUSH
43790: LD_VAR 0 7
43794: PUSH
43795: LD_INT 2
43797: ARRAY
43798: PUSH
43799: LD_VAR 0 7
43803: PUSH
43804: LD_INT 3
43806: ARRAY
43807: PUSH
43808: EMPTY
43809: LIST
43810: LIST
43811: LIST
43812: LIST
43813: PPUSH
43814: CALL_OW 2
43818: PPUSH
43819: CALL_OW 1
43823: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
43824: LD_ADDR_VAR 0 5
43828: PUSH
43829: LD_VAR 0 5
43833: PPUSH
43834: LD_INT 1
43836: PPUSH
43837: CALL_OW 3
43841: ST_TO_ADDR
// if not ext_list then
43842: LD_VAR 0 5
43846: NOT
43847: IFFALSE 43853
// exit ;
43849: POP
43850: POP
43851: GO 43857
// end ;
43853: GO 43728
43855: POP
43856: POP
// end ;
43857: LD_VAR 0 6
43861: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
43862: LD_INT 0
43864: PPUSH
// if not mc_bases or not base or not weapon_list then
43865: LD_EXP 50
43869: NOT
43870: PUSH
43871: LD_VAR 0 1
43875: NOT
43876: OR
43877: PUSH
43878: LD_VAR 0 2
43882: NOT
43883: OR
43884: IFFALSE 43888
// exit ;
43886: GO 43913
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
43888: LD_ADDR_EXP 89
43892: PUSH
43893: LD_EXP 89
43897: PPUSH
43898: LD_VAR 0 1
43902: PPUSH
43903: LD_VAR 0 2
43907: PPUSH
43908: CALL_OW 1
43912: ST_TO_ADDR
// end ;
43913: LD_VAR 0 3
43917: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
43918: LD_INT 0
43920: PPUSH
// if not mc_bases or not base or not tech_list then
43921: LD_EXP 50
43925: NOT
43926: PUSH
43927: LD_VAR 0 1
43931: NOT
43932: OR
43933: PUSH
43934: LD_VAR 0 2
43938: NOT
43939: OR
43940: IFFALSE 43944
// exit ;
43942: GO 43969
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
43944: LD_ADDR_EXP 77
43948: PUSH
43949: LD_EXP 77
43953: PPUSH
43954: LD_VAR 0 1
43958: PPUSH
43959: LD_VAR 0 2
43963: PPUSH
43964: CALL_OW 1
43968: ST_TO_ADDR
// end ;
43969: LD_VAR 0 3
43973: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
43974: LD_INT 0
43976: PPUSH
// if not mc_bases or not parking_area or not base then
43977: LD_EXP 50
43981: NOT
43982: PUSH
43983: LD_VAR 0 2
43987: NOT
43988: OR
43989: PUSH
43990: LD_VAR 0 1
43994: NOT
43995: OR
43996: IFFALSE 44000
// exit ;
43998: GO 44025
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
44000: LD_ADDR_EXP 74
44004: PUSH
44005: LD_EXP 74
44009: PPUSH
44010: LD_VAR 0 1
44014: PPUSH
44015: LD_VAR 0 2
44019: PPUSH
44020: CALL_OW 1
44024: ST_TO_ADDR
// end ;
44025: LD_VAR 0 3
44029: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
44030: LD_INT 0
44032: PPUSH
// if not mc_bases or not base or not scan_area then
44033: LD_EXP 50
44037: NOT
44038: PUSH
44039: LD_VAR 0 1
44043: NOT
44044: OR
44045: PUSH
44046: LD_VAR 0 2
44050: NOT
44051: OR
44052: IFFALSE 44056
// exit ;
44054: GO 44081
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
44056: LD_ADDR_EXP 75
44060: PUSH
44061: LD_EXP 75
44065: PPUSH
44066: LD_VAR 0 1
44070: PPUSH
44071: LD_VAR 0 2
44075: PPUSH
44076: CALL_OW 1
44080: ST_TO_ADDR
// end ;
44081: LD_VAR 0 3
44085: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
44086: LD_INT 0
44088: PPUSH
44089: PPUSH
// if not mc_bases or not base then
44090: LD_EXP 50
44094: NOT
44095: PUSH
44096: LD_VAR 0 1
44100: NOT
44101: OR
44102: IFFALSE 44106
// exit ;
44104: GO 44170
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
44106: LD_ADDR_VAR 0 3
44110: PUSH
44111: LD_INT 1
44113: PUSH
44114: LD_INT 2
44116: PUSH
44117: LD_INT 3
44119: PUSH
44120: LD_INT 4
44122: PUSH
44123: LD_INT 11
44125: PUSH
44126: EMPTY
44127: LIST
44128: LIST
44129: LIST
44130: LIST
44131: LIST
44132: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
44133: LD_ADDR_EXP 77
44137: PUSH
44138: LD_EXP 77
44142: PPUSH
44143: LD_VAR 0 1
44147: PPUSH
44148: LD_EXP 77
44152: PUSH
44153: LD_VAR 0 1
44157: ARRAY
44158: PUSH
44159: LD_VAR 0 3
44163: DIFF
44164: PPUSH
44165: CALL_OW 1
44169: ST_TO_ADDR
// end ;
44170: LD_VAR 0 2
44174: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
44175: LD_INT 0
44177: PPUSH
// result := mc_vehicles [ base ] ;
44178: LD_ADDR_VAR 0 3
44182: PUSH
44183: LD_EXP 69
44187: PUSH
44188: LD_VAR 0 1
44192: ARRAY
44193: ST_TO_ADDR
// if onlyCombat then
44194: LD_VAR 0 2
44198: IFFALSE 44370
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
44200: LD_ADDR_VAR 0 3
44204: PUSH
44205: LD_VAR 0 3
44209: PUSH
44210: LD_VAR 0 3
44214: PPUSH
44215: LD_INT 2
44217: PUSH
44218: LD_INT 34
44220: PUSH
44221: LD_INT 12
44223: PUSH
44224: EMPTY
44225: LIST
44226: LIST
44227: PUSH
44228: LD_INT 34
44230: PUSH
44231: LD_INT 51
44233: PUSH
44234: EMPTY
44235: LIST
44236: LIST
44237: PUSH
44238: LD_INT 34
44240: PUSH
44241: LD_INT 89
44243: PUSH
44244: EMPTY
44245: LIST
44246: LIST
44247: PUSH
44248: LD_INT 34
44250: PUSH
44251: LD_INT 32
44253: PUSH
44254: EMPTY
44255: LIST
44256: LIST
44257: PUSH
44258: LD_INT 34
44260: PUSH
44261: LD_INT 13
44263: PUSH
44264: EMPTY
44265: LIST
44266: LIST
44267: PUSH
44268: LD_INT 34
44270: PUSH
44271: LD_INT 52
44273: PUSH
44274: EMPTY
44275: LIST
44276: LIST
44277: PUSH
44278: LD_INT 34
44280: PUSH
44281: LD_INT 88
44283: PUSH
44284: EMPTY
44285: LIST
44286: LIST
44287: PUSH
44288: LD_INT 34
44290: PUSH
44291: LD_INT 14
44293: PUSH
44294: EMPTY
44295: LIST
44296: LIST
44297: PUSH
44298: LD_INT 34
44300: PUSH
44301: LD_INT 53
44303: PUSH
44304: EMPTY
44305: LIST
44306: LIST
44307: PUSH
44308: LD_INT 34
44310: PUSH
44311: LD_INT 98
44313: PUSH
44314: EMPTY
44315: LIST
44316: LIST
44317: PUSH
44318: LD_INT 34
44320: PUSH
44321: LD_INT 31
44323: PUSH
44324: EMPTY
44325: LIST
44326: LIST
44327: PUSH
44328: LD_INT 34
44330: PUSH
44331: LD_INT 48
44333: PUSH
44334: EMPTY
44335: LIST
44336: LIST
44337: PUSH
44338: LD_INT 34
44340: PUSH
44341: LD_INT 8
44343: PUSH
44344: EMPTY
44345: LIST
44346: LIST
44347: PUSH
44348: EMPTY
44349: LIST
44350: LIST
44351: LIST
44352: LIST
44353: LIST
44354: LIST
44355: LIST
44356: LIST
44357: LIST
44358: LIST
44359: LIST
44360: LIST
44361: LIST
44362: LIST
44363: PPUSH
44364: CALL_OW 72
44368: DIFF
44369: ST_TO_ADDR
// end ; end_of_file
44370: LD_VAR 0 3
44374: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
44375: LD_INT 0
44377: PPUSH
44378: PPUSH
44379: PPUSH
// if not mc_bases or not skirmish then
44380: LD_EXP 50
44384: NOT
44385: PUSH
44386: LD_EXP 48
44390: NOT
44391: OR
44392: IFFALSE 44396
// exit ;
44394: GO 44561
// for i = 1 to mc_bases do
44396: LD_ADDR_VAR 0 4
44400: PUSH
44401: DOUBLE
44402: LD_INT 1
44404: DEC
44405: ST_TO_ADDR
44406: LD_EXP 50
44410: PUSH
44411: FOR_TO
44412: IFFALSE 44559
// begin if sci in mc_bases [ i ] then
44414: LD_VAR 0 2
44418: PUSH
44419: LD_EXP 50
44423: PUSH
44424: LD_VAR 0 4
44428: ARRAY
44429: IN
44430: IFFALSE 44557
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
44432: LD_ADDR_EXP 79
44436: PUSH
44437: LD_EXP 79
44441: PPUSH
44442: LD_VAR 0 4
44446: PUSH
44447: LD_EXP 79
44451: PUSH
44452: LD_VAR 0 4
44456: ARRAY
44457: PUSH
44458: LD_INT 1
44460: PLUS
44461: PUSH
44462: EMPTY
44463: LIST
44464: LIST
44465: PPUSH
44466: LD_VAR 0 1
44470: PPUSH
44471: CALL 54145 0 3
44475: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
44476: LD_ADDR_VAR 0 5
44480: PUSH
44481: LD_EXP 50
44485: PUSH
44486: LD_VAR 0 4
44490: ARRAY
44491: PPUSH
44492: LD_INT 2
44494: PUSH
44495: LD_INT 30
44497: PUSH
44498: LD_INT 0
44500: PUSH
44501: EMPTY
44502: LIST
44503: LIST
44504: PUSH
44505: LD_INT 30
44507: PUSH
44508: LD_INT 1
44510: PUSH
44511: EMPTY
44512: LIST
44513: LIST
44514: PUSH
44515: EMPTY
44516: LIST
44517: LIST
44518: LIST
44519: PPUSH
44520: CALL_OW 72
44524: PPUSH
44525: LD_VAR 0 1
44529: PPUSH
44530: CALL_OW 74
44534: ST_TO_ADDR
// if tmp then
44535: LD_VAR 0 5
44539: IFFALSE 44555
// ComStandNearbyBuilding ( ape , tmp ) ;
44541: LD_VAR 0 1
44545: PPUSH
44546: LD_VAR 0 5
44550: PPUSH
44551: CALL 50747 0 2
// break ;
44555: GO 44559
// end ; end ;
44557: GO 44411
44559: POP
44560: POP
// end ;
44561: LD_VAR 0 3
44565: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
44566: LD_INT 0
44568: PPUSH
44569: PPUSH
44570: PPUSH
// if not mc_bases or not skirmish then
44571: LD_EXP 50
44575: NOT
44576: PUSH
44577: LD_EXP 48
44581: NOT
44582: OR
44583: IFFALSE 44587
// exit ;
44585: GO 44676
// for i = 1 to mc_bases do
44587: LD_ADDR_VAR 0 4
44591: PUSH
44592: DOUBLE
44593: LD_INT 1
44595: DEC
44596: ST_TO_ADDR
44597: LD_EXP 50
44601: PUSH
44602: FOR_TO
44603: IFFALSE 44674
// begin if building in mc_busy_turret_list [ i ] then
44605: LD_VAR 0 1
44609: PUSH
44610: LD_EXP 60
44614: PUSH
44615: LD_VAR 0 4
44619: ARRAY
44620: IN
44621: IFFALSE 44672
// begin tmp := mc_busy_turret_list [ i ] diff building ;
44623: LD_ADDR_VAR 0 5
44627: PUSH
44628: LD_EXP 60
44632: PUSH
44633: LD_VAR 0 4
44637: ARRAY
44638: PUSH
44639: LD_VAR 0 1
44643: DIFF
44644: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
44645: LD_ADDR_EXP 60
44649: PUSH
44650: LD_EXP 60
44654: PPUSH
44655: LD_VAR 0 4
44659: PPUSH
44660: LD_VAR 0 5
44664: PPUSH
44665: CALL_OW 1
44669: ST_TO_ADDR
// break ;
44670: GO 44674
// end ; end ;
44672: GO 44602
44674: POP
44675: POP
// end ;
44676: LD_VAR 0 3
44680: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
44681: LD_INT 0
44683: PPUSH
44684: PPUSH
44685: PPUSH
// if not mc_bases or not skirmish then
44686: LD_EXP 50
44690: NOT
44691: PUSH
44692: LD_EXP 48
44696: NOT
44697: OR
44698: IFFALSE 44702
// exit ;
44700: GO 44901
// for i = 1 to mc_bases do
44702: LD_ADDR_VAR 0 5
44706: PUSH
44707: DOUBLE
44708: LD_INT 1
44710: DEC
44711: ST_TO_ADDR
44712: LD_EXP 50
44716: PUSH
44717: FOR_TO
44718: IFFALSE 44899
// if building in mc_bases [ i ] then
44720: LD_VAR 0 1
44724: PUSH
44725: LD_EXP 50
44729: PUSH
44730: LD_VAR 0 5
44734: ARRAY
44735: IN
44736: IFFALSE 44897
// begin tmp := mc_bases [ i ] diff building ;
44738: LD_ADDR_VAR 0 6
44742: PUSH
44743: LD_EXP 50
44747: PUSH
44748: LD_VAR 0 5
44752: ARRAY
44753: PUSH
44754: LD_VAR 0 1
44758: DIFF
44759: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
44760: LD_ADDR_EXP 50
44764: PUSH
44765: LD_EXP 50
44769: PPUSH
44770: LD_VAR 0 5
44774: PPUSH
44775: LD_VAR 0 6
44779: PPUSH
44780: CALL_OW 1
44784: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
44785: LD_VAR 0 1
44789: PUSH
44790: LD_EXP 58
44794: PUSH
44795: LD_VAR 0 5
44799: ARRAY
44800: IN
44801: IFFALSE 44840
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
44803: LD_ADDR_EXP 58
44807: PUSH
44808: LD_EXP 58
44812: PPUSH
44813: LD_VAR 0 5
44817: PPUSH
44818: LD_EXP 58
44822: PUSH
44823: LD_VAR 0 5
44827: ARRAY
44828: PUSH
44829: LD_VAR 0 1
44833: DIFF
44834: PPUSH
44835: CALL_OW 1
44839: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
44840: LD_VAR 0 1
44844: PUSH
44845: LD_EXP 59
44849: PUSH
44850: LD_VAR 0 5
44854: ARRAY
44855: IN
44856: IFFALSE 44895
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
44858: LD_ADDR_EXP 59
44862: PUSH
44863: LD_EXP 59
44867: PPUSH
44868: LD_VAR 0 5
44872: PPUSH
44873: LD_EXP 59
44877: PUSH
44878: LD_VAR 0 5
44882: ARRAY
44883: PUSH
44884: LD_VAR 0 1
44888: DIFF
44889: PPUSH
44890: CALL_OW 1
44894: ST_TO_ADDR
// break ;
44895: GO 44899
// end ;
44897: GO 44717
44899: POP
44900: POP
// end ;
44901: LD_VAR 0 4
44905: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
44906: LD_INT 0
44908: PPUSH
44909: PPUSH
44910: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
44911: LD_EXP 50
44915: NOT
44916: PUSH
44917: LD_EXP 48
44921: NOT
44922: OR
44923: PUSH
44924: LD_VAR 0 3
44928: PUSH
44929: LD_EXP 76
44933: IN
44934: NOT
44935: OR
44936: IFFALSE 44940
// exit ;
44938: GO 45063
// for i = 1 to mc_vehicles do
44940: LD_ADDR_VAR 0 6
44944: PUSH
44945: DOUBLE
44946: LD_INT 1
44948: DEC
44949: ST_TO_ADDR
44950: LD_EXP 69
44954: PUSH
44955: FOR_TO
44956: IFFALSE 45061
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
44958: LD_VAR 0 2
44962: PUSH
44963: LD_EXP 69
44967: PUSH
44968: LD_VAR 0 6
44972: ARRAY
44973: IN
44974: PUSH
44975: LD_VAR 0 1
44979: PUSH
44980: LD_EXP 69
44984: PUSH
44985: LD_VAR 0 6
44989: ARRAY
44990: IN
44991: OR
44992: IFFALSE 45059
// begin tmp := mc_vehicles [ i ] diff old ;
44994: LD_ADDR_VAR 0 7
44998: PUSH
44999: LD_EXP 69
45003: PUSH
45004: LD_VAR 0 6
45008: ARRAY
45009: PUSH
45010: LD_VAR 0 2
45014: DIFF
45015: ST_TO_ADDR
// tmp := tmp diff new ;
45016: LD_ADDR_VAR 0 7
45020: PUSH
45021: LD_VAR 0 7
45025: PUSH
45026: LD_VAR 0 1
45030: DIFF
45031: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
45032: LD_ADDR_EXP 69
45036: PUSH
45037: LD_EXP 69
45041: PPUSH
45042: LD_VAR 0 6
45046: PPUSH
45047: LD_VAR 0 7
45051: PPUSH
45052: CALL_OW 1
45056: ST_TO_ADDR
// break ;
45057: GO 45061
// end ;
45059: GO 44955
45061: POP
45062: POP
// end ;
45063: LD_VAR 0 5
45067: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
45068: LD_INT 0
45070: PPUSH
45071: PPUSH
45072: PPUSH
45073: PPUSH
// if not mc_bases or not skirmish then
45074: LD_EXP 50
45078: NOT
45079: PUSH
45080: LD_EXP 48
45084: NOT
45085: OR
45086: IFFALSE 45090
// exit ;
45088: GO 45510
// repeat wait ( 0 0$1 ) ;
45090: LD_INT 35
45092: PPUSH
45093: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
45097: LD_EXP 94
45101: NOT
45102: IFFALSE 45090
// mc_block_vehicle_constructed_thread := true ;
45104: LD_ADDR_EXP 94
45108: PUSH
45109: LD_INT 1
45111: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
45112: LD_ADDR_VAR 0 5
45116: PUSH
45117: LD_VAR 0 1
45121: PPUSH
45122: CALL_OW 255
45126: ST_TO_ADDR
// for i = 1 to mc_bases do
45127: LD_ADDR_VAR 0 4
45131: PUSH
45132: DOUBLE
45133: LD_INT 1
45135: DEC
45136: ST_TO_ADDR
45137: LD_EXP 50
45141: PUSH
45142: FOR_TO
45143: IFFALSE 45500
// begin if factory in mc_bases [ i ] then
45145: LD_VAR 0 2
45149: PUSH
45150: LD_EXP 50
45154: PUSH
45155: LD_VAR 0 4
45159: ARRAY
45160: IN
45161: IFFALSE 45498
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
45163: LD_EXP 72
45167: PUSH
45168: LD_VAR 0 4
45172: ARRAY
45173: PUSH
45174: LD_EXP 61
45178: PUSH
45179: LD_VAR 0 4
45183: ARRAY
45184: LESS
45185: PUSH
45186: LD_VAR 0 1
45190: PPUSH
45191: CALL_OW 264
45195: PUSH
45196: LD_INT 31
45198: PUSH
45199: LD_INT 32
45201: PUSH
45202: LD_INT 51
45204: PUSH
45205: LD_INT 89
45207: PUSH
45208: LD_INT 12
45210: PUSH
45211: LD_INT 30
45213: PUSH
45214: LD_INT 98
45216: PUSH
45217: LD_INT 11
45219: PUSH
45220: LD_INT 53
45222: PUSH
45223: LD_INT 14
45225: PUSH
45226: LD_INT 91
45228: PUSH
45229: LD_INT 29
45231: PUSH
45232: LD_INT 99
45234: PUSH
45235: LD_INT 13
45237: PUSH
45238: LD_INT 52
45240: PUSH
45241: LD_INT 88
45243: PUSH
45244: LD_INT 48
45246: PUSH
45247: LD_INT 8
45249: PUSH
45250: EMPTY
45251: LIST
45252: LIST
45253: LIST
45254: LIST
45255: LIST
45256: LIST
45257: LIST
45258: LIST
45259: LIST
45260: LIST
45261: LIST
45262: LIST
45263: LIST
45264: LIST
45265: LIST
45266: LIST
45267: LIST
45268: LIST
45269: IN
45270: NOT
45271: AND
45272: IFFALSE 45320
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
45274: LD_ADDR_EXP 72
45278: PUSH
45279: LD_EXP 72
45283: PPUSH
45284: LD_VAR 0 4
45288: PUSH
45289: LD_EXP 72
45293: PUSH
45294: LD_VAR 0 4
45298: ARRAY
45299: PUSH
45300: LD_INT 1
45302: PLUS
45303: PUSH
45304: EMPTY
45305: LIST
45306: LIST
45307: PPUSH
45308: LD_VAR 0 1
45312: PPUSH
45313: CALL 54145 0 3
45317: ST_TO_ADDR
45318: GO 45364
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
45320: LD_ADDR_EXP 69
45324: PUSH
45325: LD_EXP 69
45329: PPUSH
45330: LD_VAR 0 4
45334: PUSH
45335: LD_EXP 69
45339: PUSH
45340: LD_VAR 0 4
45344: ARRAY
45345: PUSH
45346: LD_INT 1
45348: PLUS
45349: PUSH
45350: EMPTY
45351: LIST
45352: LIST
45353: PPUSH
45354: LD_VAR 0 1
45358: PPUSH
45359: CALL 54145 0 3
45363: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
45364: LD_ADDR_EXP 94
45368: PUSH
45369: LD_INT 0
45371: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
45372: LD_VAR 0 1
45376: PPUSH
45377: CALL_OW 263
45381: PUSH
45382: LD_INT 2
45384: EQUAL
45385: IFFALSE 45414
// begin repeat wait ( 0 0$3 ) ;
45387: LD_INT 105
45389: PPUSH
45390: CALL_OW 67
// Connect ( vehicle ) ;
45394: LD_VAR 0 1
45398: PPUSH
45399: CALL 57491 0 1
// until IsControledBy ( vehicle ) ;
45403: LD_VAR 0 1
45407: PPUSH
45408: CALL_OW 312
45412: IFFALSE 45387
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
45414: LD_VAR 0 1
45418: PPUSH
45419: LD_EXP 74
45423: PUSH
45424: LD_VAR 0 4
45428: ARRAY
45429: PPUSH
45430: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
45434: LD_VAR 0 1
45438: PPUSH
45439: CALL_OW 263
45443: PUSH
45444: LD_INT 1
45446: NONEQUAL
45447: IFFALSE 45451
// break ;
45449: GO 45500
// repeat wait ( 0 0$1 ) ;
45451: LD_INT 35
45453: PPUSH
45454: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
45458: LD_VAR 0 1
45462: PPUSH
45463: LD_EXP 74
45467: PUSH
45468: LD_VAR 0 4
45472: ARRAY
45473: PPUSH
45474: CALL_OW 308
45478: IFFALSE 45451
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
45480: LD_VAR 0 1
45484: PPUSH
45485: CALL_OW 311
45489: PPUSH
45490: CALL_OW 121
// exit ;
45494: POP
45495: POP
45496: GO 45510
// end ; end ;
45498: GO 45142
45500: POP
45501: POP
// mc_block_vehicle_constructed_thread := false ;
45502: LD_ADDR_EXP 94
45506: PUSH
45507: LD_INT 0
45509: ST_TO_ADDR
// end ;
45510: LD_VAR 0 3
45514: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
45515: LD_INT 0
45517: PPUSH
45518: PPUSH
45519: PPUSH
45520: PPUSH
// if not mc_bases or not skirmish then
45521: LD_EXP 50
45525: NOT
45526: PUSH
45527: LD_EXP 48
45531: NOT
45532: OR
45533: IFFALSE 45537
// exit ;
45535: GO 45890
// repeat wait ( 0 0$1 ) ;
45537: LD_INT 35
45539: PPUSH
45540: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
45544: LD_VAR 0 2
45548: PPUSH
45549: LD_VAR 0 3
45553: PPUSH
45554: CALL_OW 284
45558: IFFALSE 45537
// if GetResourceTypeXY ( x , y ) = mat_artefact then
45560: LD_VAR 0 2
45564: PPUSH
45565: LD_VAR 0 3
45569: PPUSH
45570: CALL_OW 283
45574: PUSH
45575: LD_INT 4
45577: EQUAL
45578: IFFALSE 45582
// exit ;
45580: GO 45890
// for i = 1 to mc_bases do
45582: LD_ADDR_VAR 0 7
45586: PUSH
45587: DOUBLE
45588: LD_INT 1
45590: DEC
45591: ST_TO_ADDR
45592: LD_EXP 50
45596: PUSH
45597: FOR_TO
45598: IFFALSE 45888
// begin if mc_crates_area [ i ] then
45600: LD_EXP 68
45604: PUSH
45605: LD_VAR 0 7
45609: ARRAY
45610: IFFALSE 45721
// for j in mc_crates_area [ i ] do
45612: LD_ADDR_VAR 0 8
45616: PUSH
45617: LD_EXP 68
45621: PUSH
45622: LD_VAR 0 7
45626: ARRAY
45627: PUSH
45628: FOR_IN
45629: IFFALSE 45719
// if InArea ( x , y , j ) then
45631: LD_VAR 0 2
45635: PPUSH
45636: LD_VAR 0 3
45640: PPUSH
45641: LD_VAR 0 8
45645: PPUSH
45646: CALL_OW 309
45650: IFFALSE 45717
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
45652: LD_ADDR_EXP 66
45656: PUSH
45657: LD_EXP 66
45661: PPUSH
45662: LD_VAR 0 7
45666: PUSH
45667: LD_EXP 66
45671: PUSH
45672: LD_VAR 0 7
45676: ARRAY
45677: PUSH
45678: LD_INT 1
45680: PLUS
45681: PUSH
45682: EMPTY
45683: LIST
45684: LIST
45685: PPUSH
45686: LD_VAR 0 4
45690: PUSH
45691: LD_VAR 0 2
45695: PUSH
45696: LD_VAR 0 3
45700: PUSH
45701: EMPTY
45702: LIST
45703: LIST
45704: LIST
45705: PPUSH
45706: CALL 54145 0 3
45710: ST_TO_ADDR
// exit ;
45711: POP
45712: POP
45713: POP
45714: POP
45715: GO 45890
// end ;
45717: GO 45628
45719: POP
45720: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
45721: LD_ADDR_VAR 0 9
45725: PUSH
45726: LD_EXP 50
45730: PUSH
45731: LD_VAR 0 7
45735: ARRAY
45736: PPUSH
45737: LD_INT 2
45739: PUSH
45740: LD_INT 30
45742: PUSH
45743: LD_INT 0
45745: PUSH
45746: EMPTY
45747: LIST
45748: LIST
45749: PUSH
45750: LD_INT 30
45752: PUSH
45753: LD_INT 1
45755: PUSH
45756: EMPTY
45757: LIST
45758: LIST
45759: PUSH
45760: EMPTY
45761: LIST
45762: LIST
45763: LIST
45764: PPUSH
45765: CALL_OW 72
45769: ST_TO_ADDR
// if not depot then
45770: LD_VAR 0 9
45774: NOT
45775: IFFALSE 45779
// continue ;
45777: GO 45597
// for j in depot do
45779: LD_ADDR_VAR 0 8
45783: PUSH
45784: LD_VAR 0 9
45788: PUSH
45789: FOR_IN
45790: IFFALSE 45884
// if GetDistUnitXY ( j , x , y ) < 30 then
45792: LD_VAR 0 8
45796: PPUSH
45797: LD_VAR 0 2
45801: PPUSH
45802: LD_VAR 0 3
45806: PPUSH
45807: CALL_OW 297
45811: PUSH
45812: LD_INT 30
45814: LESS
45815: IFFALSE 45882
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
45817: LD_ADDR_EXP 66
45821: PUSH
45822: LD_EXP 66
45826: PPUSH
45827: LD_VAR 0 7
45831: PUSH
45832: LD_EXP 66
45836: PUSH
45837: LD_VAR 0 7
45841: ARRAY
45842: PUSH
45843: LD_INT 1
45845: PLUS
45846: PUSH
45847: EMPTY
45848: LIST
45849: LIST
45850: PPUSH
45851: LD_VAR 0 4
45855: PUSH
45856: LD_VAR 0 2
45860: PUSH
45861: LD_VAR 0 3
45865: PUSH
45866: EMPTY
45867: LIST
45868: LIST
45869: LIST
45870: PPUSH
45871: CALL 54145 0 3
45875: ST_TO_ADDR
// exit ;
45876: POP
45877: POP
45878: POP
45879: POP
45880: GO 45890
// end ;
45882: GO 45789
45884: POP
45885: POP
// end ;
45886: GO 45597
45888: POP
45889: POP
// end ;
45890: LD_VAR 0 6
45894: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
45895: LD_INT 0
45897: PPUSH
45898: PPUSH
45899: PPUSH
45900: PPUSH
// if not mc_bases or not skirmish then
45901: LD_EXP 50
45905: NOT
45906: PUSH
45907: LD_EXP 48
45911: NOT
45912: OR
45913: IFFALSE 45917
// exit ;
45915: GO 46194
// side := GetSide ( lab ) ;
45917: LD_ADDR_VAR 0 4
45921: PUSH
45922: LD_VAR 0 2
45926: PPUSH
45927: CALL_OW 255
45931: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
45932: LD_VAR 0 4
45936: PUSH
45937: LD_EXP 76
45941: IN
45942: NOT
45943: PUSH
45944: LD_EXP 77
45948: NOT
45949: OR
45950: PUSH
45951: LD_EXP 50
45955: NOT
45956: OR
45957: IFFALSE 45961
// exit ;
45959: GO 46194
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
45961: LD_ADDR_EXP 77
45965: PUSH
45966: LD_EXP 77
45970: PPUSH
45971: LD_VAR 0 4
45975: PPUSH
45976: LD_EXP 77
45980: PUSH
45981: LD_VAR 0 4
45985: ARRAY
45986: PUSH
45987: LD_VAR 0 1
45991: DIFF
45992: PPUSH
45993: CALL_OW 1
45997: ST_TO_ADDR
// for i = 1 to mc_bases do
45998: LD_ADDR_VAR 0 5
46002: PUSH
46003: DOUBLE
46004: LD_INT 1
46006: DEC
46007: ST_TO_ADDR
46008: LD_EXP 50
46012: PUSH
46013: FOR_TO
46014: IFFALSE 46192
// begin if lab in mc_bases [ i ] then
46016: LD_VAR 0 2
46020: PUSH
46021: LD_EXP 50
46025: PUSH
46026: LD_VAR 0 5
46030: ARRAY
46031: IN
46032: IFFALSE 46190
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
46034: LD_VAR 0 1
46038: PUSH
46039: LD_INT 11
46041: PUSH
46042: LD_INT 4
46044: PUSH
46045: LD_INT 3
46047: PUSH
46048: LD_INT 2
46050: PUSH
46051: EMPTY
46052: LIST
46053: LIST
46054: LIST
46055: LIST
46056: IN
46057: PUSH
46058: LD_EXP 80
46062: PUSH
46063: LD_VAR 0 5
46067: ARRAY
46068: AND
46069: IFFALSE 46190
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
46071: LD_ADDR_VAR 0 6
46075: PUSH
46076: LD_EXP 80
46080: PUSH
46081: LD_VAR 0 5
46085: ARRAY
46086: PUSH
46087: LD_INT 1
46089: ARRAY
46090: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
46091: LD_ADDR_EXP 80
46095: PUSH
46096: LD_EXP 80
46100: PPUSH
46101: LD_VAR 0 5
46105: PPUSH
46106: EMPTY
46107: PPUSH
46108: CALL_OW 1
46112: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
46113: LD_VAR 0 6
46117: PPUSH
46118: LD_INT 0
46120: PPUSH
46121: CALL_OW 109
// ComExitBuilding ( tmp ) ;
46125: LD_VAR 0 6
46129: PPUSH
46130: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
46134: LD_ADDR_EXP 79
46138: PUSH
46139: LD_EXP 79
46143: PPUSH
46144: LD_VAR 0 5
46148: PPUSH
46149: LD_EXP 79
46153: PUSH
46154: LD_VAR 0 5
46158: ARRAY
46159: PPUSH
46160: LD_INT 1
46162: PPUSH
46163: LD_VAR 0 6
46167: PPUSH
46168: CALL_OW 2
46172: PPUSH
46173: CALL_OW 1
46177: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
46178: LD_VAR 0 5
46182: PPUSH
46183: LD_INT 112
46185: PPUSH
46186: CALL 22644 0 2
// end ; end ; end ;
46190: GO 46013
46192: POP
46193: POP
// end ;
46194: LD_VAR 0 3
46198: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
46199: LD_INT 0
46201: PPUSH
46202: PPUSH
46203: PPUSH
46204: PPUSH
46205: PPUSH
46206: PPUSH
46207: PPUSH
46208: PPUSH
// if not mc_bases or not skirmish then
46209: LD_EXP 50
46213: NOT
46214: PUSH
46215: LD_EXP 48
46219: NOT
46220: OR
46221: IFFALSE 46225
// exit ;
46223: GO 47594
// for i = 1 to mc_bases do
46225: LD_ADDR_VAR 0 3
46229: PUSH
46230: DOUBLE
46231: LD_INT 1
46233: DEC
46234: ST_TO_ADDR
46235: LD_EXP 50
46239: PUSH
46240: FOR_TO
46241: IFFALSE 47592
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
46243: LD_VAR 0 1
46247: PUSH
46248: LD_EXP 50
46252: PUSH
46253: LD_VAR 0 3
46257: ARRAY
46258: IN
46259: PUSH
46260: LD_VAR 0 1
46264: PUSH
46265: LD_EXP 57
46269: PUSH
46270: LD_VAR 0 3
46274: ARRAY
46275: IN
46276: OR
46277: PUSH
46278: LD_VAR 0 1
46282: PUSH
46283: LD_EXP 72
46287: PUSH
46288: LD_VAR 0 3
46292: ARRAY
46293: IN
46294: OR
46295: PUSH
46296: LD_VAR 0 1
46300: PUSH
46301: LD_EXP 69
46305: PUSH
46306: LD_VAR 0 3
46310: ARRAY
46311: IN
46312: OR
46313: PUSH
46314: LD_VAR 0 1
46318: PUSH
46319: LD_EXP 79
46323: PUSH
46324: LD_VAR 0 3
46328: ARRAY
46329: IN
46330: OR
46331: PUSH
46332: LD_VAR 0 1
46336: PUSH
46337: LD_EXP 80
46341: PUSH
46342: LD_VAR 0 3
46346: ARRAY
46347: IN
46348: OR
46349: IFFALSE 47590
// begin if un in mc_ape [ i ] then
46351: LD_VAR 0 1
46355: PUSH
46356: LD_EXP 79
46360: PUSH
46361: LD_VAR 0 3
46365: ARRAY
46366: IN
46367: IFFALSE 46406
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
46369: LD_ADDR_EXP 79
46373: PUSH
46374: LD_EXP 79
46378: PPUSH
46379: LD_VAR 0 3
46383: PPUSH
46384: LD_EXP 79
46388: PUSH
46389: LD_VAR 0 3
46393: ARRAY
46394: PUSH
46395: LD_VAR 0 1
46399: DIFF
46400: PPUSH
46401: CALL_OW 1
46405: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
46406: LD_VAR 0 1
46410: PUSH
46411: LD_EXP 80
46415: PUSH
46416: LD_VAR 0 3
46420: ARRAY
46421: IN
46422: IFFALSE 46446
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
46424: LD_ADDR_EXP 80
46428: PUSH
46429: LD_EXP 80
46433: PPUSH
46434: LD_VAR 0 3
46438: PPUSH
46439: EMPTY
46440: PPUSH
46441: CALL_OW 1
46445: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
46446: LD_VAR 0 1
46450: PPUSH
46451: CALL_OW 247
46455: PUSH
46456: LD_INT 2
46458: EQUAL
46459: PUSH
46460: LD_VAR 0 1
46464: PPUSH
46465: CALL_OW 110
46469: PUSH
46470: LD_INT 20
46472: EQUAL
46473: PUSH
46474: LD_VAR 0 1
46478: PUSH
46479: LD_EXP 72
46483: PUSH
46484: LD_VAR 0 3
46488: ARRAY
46489: IN
46490: OR
46491: PUSH
46492: LD_VAR 0 1
46496: PPUSH
46497: CALL_OW 264
46501: PUSH
46502: LD_INT 12
46504: PUSH
46505: LD_INT 51
46507: PUSH
46508: LD_INT 89
46510: PUSH
46511: LD_INT 32
46513: PUSH
46514: LD_INT 13
46516: PUSH
46517: LD_INT 52
46519: PUSH
46520: LD_INT 31
46522: PUSH
46523: EMPTY
46524: LIST
46525: LIST
46526: LIST
46527: LIST
46528: LIST
46529: LIST
46530: LIST
46531: IN
46532: OR
46533: AND
46534: IFFALSE 46842
// begin if un in mc_defender [ i ] then
46536: LD_VAR 0 1
46540: PUSH
46541: LD_EXP 72
46545: PUSH
46546: LD_VAR 0 3
46550: ARRAY
46551: IN
46552: IFFALSE 46591
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
46554: LD_ADDR_EXP 72
46558: PUSH
46559: LD_EXP 72
46563: PPUSH
46564: LD_VAR 0 3
46568: PPUSH
46569: LD_EXP 72
46573: PUSH
46574: LD_VAR 0 3
46578: ARRAY
46579: PUSH
46580: LD_VAR 0 1
46584: DIFF
46585: PPUSH
46586: CALL_OW 1
46590: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
46591: LD_ADDR_VAR 0 8
46595: PUSH
46596: LD_VAR 0 3
46600: PPUSH
46601: LD_INT 3
46603: PPUSH
46604: CALL 43212 0 2
46608: ST_TO_ADDR
// if fac then
46609: LD_VAR 0 8
46613: IFFALSE 46842
// begin for j in fac do
46615: LD_ADDR_VAR 0 4
46619: PUSH
46620: LD_VAR 0 8
46624: PUSH
46625: FOR_IN
46626: IFFALSE 46840
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
46628: LD_ADDR_VAR 0 9
46632: PUSH
46633: LD_VAR 0 8
46637: PPUSH
46638: LD_VAR 0 1
46642: PPUSH
46643: CALL_OW 265
46647: PPUSH
46648: LD_VAR 0 1
46652: PPUSH
46653: CALL_OW 262
46657: PPUSH
46658: LD_VAR 0 1
46662: PPUSH
46663: CALL_OW 263
46667: PPUSH
46668: LD_VAR 0 1
46672: PPUSH
46673: CALL_OW 264
46677: PPUSH
46678: CALL 51643 0 5
46682: ST_TO_ADDR
// if components then
46683: LD_VAR 0 9
46687: IFFALSE 46838
// begin if GetWeapon ( un ) = ar_control_tower then
46689: LD_VAR 0 1
46693: PPUSH
46694: CALL_OW 264
46698: PUSH
46699: LD_INT 31
46701: EQUAL
46702: IFFALSE 46819
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
46704: LD_VAR 0 1
46708: PPUSH
46709: CALL_OW 311
46713: PPUSH
46714: LD_INT 0
46716: PPUSH
46717: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
46721: LD_ADDR_EXP 90
46725: PUSH
46726: LD_EXP 90
46730: PPUSH
46731: LD_VAR 0 3
46735: PPUSH
46736: LD_EXP 90
46740: PUSH
46741: LD_VAR 0 3
46745: ARRAY
46746: PUSH
46747: LD_VAR 0 1
46751: PPUSH
46752: CALL_OW 311
46756: DIFF
46757: PPUSH
46758: CALL_OW 1
46762: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
46763: LD_ADDR_VAR 0 7
46767: PUSH
46768: LD_EXP 71
46772: PUSH
46773: LD_VAR 0 3
46777: ARRAY
46778: PPUSH
46779: LD_INT 1
46781: PPUSH
46782: LD_VAR 0 9
46786: PPUSH
46787: CALL_OW 2
46791: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
46792: LD_ADDR_EXP 71
46796: PUSH
46797: LD_EXP 71
46801: PPUSH
46802: LD_VAR 0 3
46806: PPUSH
46807: LD_VAR 0 7
46811: PPUSH
46812: CALL_OW 1
46816: ST_TO_ADDR
// end else
46817: GO 46836
// MC_InsertProduceList ( i , [ components ] ) ;
46819: LD_VAR 0 3
46823: PPUSH
46824: LD_VAR 0 9
46828: PUSH
46829: EMPTY
46830: LIST
46831: PPUSH
46832: CALL 42757 0 2
// break ;
46836: GO 46840
// end ; end ;
46838: GO 46625
46840: POP
46841: POP
// end ; end ; if GetType ( un ) = unit_building then
46842: LD_VAR 0 1
46846: PPUSH
46847: CALL_OW 247
46851: PUSH
46852: LD_INT 3
46854: EQUAL
46855: IFFALSE 47258
// begin btype := GetBType ( un ) ;
46857: LD_ADDR_VAR 0 5
46861: PUSH
46862: LD_VAR 0 1
46866: PPUSH
46867: CALL_OW 266
46871: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
46872: LD_VAR 0 5
46876: PUSH
46877: LD_INT 29
46879: PUSH
46880: LD_INT 30
46882: PUSH
46883: EMPTY
46884: LIST
46885: LIST
46886: IN
46887: IFFALSE 46960
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
46889: LD_VAR 0 1
46893: PPUSH
46894: CALL_OW 250
46898: PPUSH
46899: LD_VAR 0 1
46903: PPUSH
46904: CALL_OW 251
46908: PPUSH
46909: LD_VAR 0 1
46913: PPUSH
46914: CALL_OW 255
46918: PPUSH
46919: CALL_OW 440
46923: NOT
46924: IFFALSE 46960
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
46926: LD_VAR 0 1
46930: PPUSH
46931: CALL_OW 250
46935: PPUSH
46936: LD_VAR 0 1
46940: PPUSH
46941: CALL_OW 251
46945: PPUSH
46946: LD_VAR 0 1
46950: PPUSH
46951: CALL_OW 255
46955: PPUSH
46956: CALL_OW 441
// end ; if btype = b_warehouse then
46960: LD_VAR 0 5
46964: PUSH
46965: LD_INT 1
46967: EQUAL
46968: IFFALSE 46986
// begin btype := b_depot ;
46970: LD_ADDR_VAR 0 5
46974: PUSH
46975: LD_INT 0
46977: ST_TO_ADDR
// pos := 1 ;
46978: LD_ADDR_VAR 0 6
46982: PUSH
46983: LD_INT 1
46985: ST_TO_ADDR
// end ; if btype = b_factory then
46986: LD_VAR 0 5
46990: PUSH
46991: LD_INT 3
46993: EQUAL
46994: IFFALSE 47012
// begin btype := b_workshop ;
46996: LD_ADDR_VAR 0 5
47000: PUSH
47001: LD_INT 2
47003: ST_TO_ADDR
// pos := 1 ;
47004: LD_ADDR_VAR 0 6
47008: PUSH
47009: LD_INT 1
47011: ST_TO_ADDR
// end ; if btype = b_barracks then
47012: LD_VAR 0 5
47016: PUSH
47017: LD_INT 5
47019: EQUAL
47020: IFFALSE 47030
// btype := b_armoury ;
47022: LD_ADDR_VAR 0 5
47026: PUSH
47027: LD_INT 4
47029: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
47030: LD_VAR 0 5
47034: PUSH
47035: LD_INT 7
47037: PUSH
47038: LD_INT 8
47040: PUSH
47041: EMPTY
47042: LIST
47043: LIST
47044: IN
47045: IFFALSE 47055
// btype := b_lab ;
47047: LD_ADDR_VAR 0 5
47051: PUSH
47052: LD_INT 6
47054: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
47055: LD_ADDR_EXP 55
47059: PUSH
47060: LD_EXP 55
47064: PPUSH
47065: LD_VAR 0 3
47069: PUSH
47070: LD_EXP 55
47074: PUSH
47075: LD_VAR 0 3
47079: ARRAY
47080: PUSH
47081: LD_INT 1
47083: PLUS
47084: PUSH
47085: EMPTY
47086: LIST
47087: LIST
47088: PPUSH
47089: LD_VAR 0 5
47093: PUSH
47094: LD_VAR 0 1
47098: PPUSH
47099: CALL_OW 250
47103: PUSH
47104: LD_VAR 0 1
47108: PPUSH
47109: CALL_OW 251
47113: PUSH
47114: LD_VAR 0 1
47118: PPUSH
47119: CALL_OW 254
47123: PUSH
47124: EMPTY
47125: LIST
47126: LIST
47127: LIST
47128: LIST
47129: PPUSH
47130: CALL 54145 0 3
47134: ST_TO_ADDR
// if pos = 1 then
47135: LD_VAR 0 6
47139: PUSH
47140: LD_INT 1
47142: EQUAL
47143: IFFALSE 47258
// begin tmp := mc_build_list [ i ] ;
47145: LD_ADDR_VAR 0 7
47149: PUSH
47150: LD_EXP 55
47154: PUSH
47155: LD_VAR 0 3
47159: ARRAY
47160: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
47161: LD_VAR 0 7
47165: PPUSH
47166: LD_INT 2
47168: PUSH
47169: LD_INT 30
47171: PUSH
47172: LD_INT 0
47174: PUSH
47175: EMPTY
47176: LIST
47177: LIST
47178: PUSH
47179: LD_INT 30
47181: PUSH
47182: LD_INT 1
47184: PUSH
47185: EMPTY
47186: LIST
47187: LIST
47188: PUSH
47189: EMPTY
47190: LIST
47191: LIST
47192: LIST
47193: PPUSH
47194: CALL_OW 72
47198: IFFALSE 47208
// pos := 2 ;
47200: LD_ADDR_VAR 0 6
47204: PUSH
47205: LD_INT 2
47207: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
47208: LD_ADDR_VAR 0 7
47212: PUSH
47213: LD_VAR 0 7
47217: PPUSH
47218: LD_VAR 0 6
47222: PPUSH
47223: LD_VAR 0 7
47227: PPUSH
47228: CALL 54471 0 3
47232: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
47233: LD_ADDR_EXP 55
47237: PUSH
47238: LD_EXP 55
47242: PPUSH
47243: LD_VAR 0 3
47247: PPUSH
47248: LD_VAR 0 7
47252: PPUSH
47253: CALL_OW 1
47257: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
47258: LD_VAR 0 1
47262: PUSH
47263: LD_EXP 50
47267: PUSH
47268: LD_VAR 0 3
47272: ARRAY
47273: IN
47274: IFFALSE 47313
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
47276: LD_ADDR_EXP 50
47280: PUSH
47281: LD_EXP 50
47285: PPUSH
47286: LD_VAR 0 3
47290: PPUSH
47291: LD_EXP 50
47295: PUSH
47296: LD_VAR 0 3
47300: ARRAY
47301: PUSH
47302: LD_VAR 0 1
47306: DIFF
47307: PPUSH
47308: CALL_OW 1
47312: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
47313: LD_VAR 0 1
47317: PUSH
47318: LD_EXP 57
47322: PUSH
47323: LD_VAR 0 3
47327: ARRAY
47328: IN
47329: IFFALSE 47368
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
47331: LD_ADDR_EXP 57
47335: PUSH
47336: LD_EXP 57
47340: PPUSH
47341: LD_VAR 0 3
47345: PPUSH
47346: LD_EXP 57
47350: PUSH
47351: LD_VAR 0 3
47355: ARRAY
47356: PUSH
47357: LD_VAR 0 1
47361: DIFF
47362: PPUSH
47363: CALL_OW 1
47367: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
47368: LD_VAR 0 1
47372: PUSH
47373: LD_EXP 69
47377: PUSH
47378: LD_VAR 0 3
47382: ARRAY
47383: IN
47384: IFFALSE 47423
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
47386: LD_ADDR_EXP 69
47390: PUSH
47391: LD_EXP 69
47395: PPUSH
47396: LD_VAR 0 3
47400: PPUSH
47401: LD_EXP 69
47405: PUSH
47406: LD_VAR 0 3
47410: ARRAY
47411: PUSH
47412: LD_VAR 0 1
47416: DIFF
47417: PPUSH
47418: CALL_OW 1
47422: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
47423: LD_VAR 0 1
47427: PUSH
47428: LD_EXP 72
47432: PUSH
47433: LD_VAR 0 3
47437: ARRAY
47438: IN
47439: IFFALSE 47478
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
47441: LD_ADDR_EXP 72
47445: PUSH
47446: LD_EXP 72
47450: PPUSH
47451: LD_VAR 0 3
47455: PPUSH
47456: LD_EXP 72
47460: PUSH
47461: LD_VAR 0 3
47465: ARRAY
47466: PUSH
47467: LD_VAR 0 1
47471: DIFF
47472: PPUSH
47473: CALL_OW 1
47477: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
47478: LD_VAR 0 1
47482: PUSH
47483: LD_EXP 59
47487: PUSH
47488: LD_VAR 0 3
47492: ARRAY
47493: IN
47494: IFFALSE 47533
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
47496: LD_ADDR_EXP 59
47500: PUSH
47501: LD_EXP 59
47505: PPUSH
47506: LD_VAR 0 3
47510: PPUSH
47511: LD_EXP 59
47515: PUSH
47516: LD_VAR 0 3
47520: ARRAY
47521: PUSH
47522: LD_VAR 0 1
47526: DIFF
47527: PPUSH
47528: CALL_OW 1
47532: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
47533: LD_VAR 0 1
47537: PUSH
47538: LD_EXP 58
47542: PUSH
47543: LD_VAR 0 3
47547: ARRAY
47548: IN
47549: IFFALSE 47588
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
47551: LD_ADDR_EXP 58
47555: PUSH
47556: LD_EXP 58
47560: PPUSH
47561: LD_VAR 0 3
47565: PPUSH
47566: LD_EXP 58
47570: PUSH
47571: LD_VAR 0 3
47575: ARRAY
47576: PUSH
47577: LD_VAR 0 1
47581: DIFF
47582: PPUSH
47583: CALL_OW 1
47587: ST_TO_ADDR
// end ; break ;
47588: GO 47592
// end ;
47590: GO 46240
47592: POP
47593: POP
// end ;
47594: LD_VAR 0 2
47598: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
47599: LD_INT 0
47601: PPUSH
47602: PPUSH
47603: PPUSH
// if not mc_bases or not skirmish then
47604: LD_EXP 50
47608: NOT
47609: PUSH
47610: LD_EXP 48
47614: NOT
47615: OR
47616: IFFALSE 47620
// exit ;
47618: GO 47835
// for i = 1 to mc_bases do
47620: LD_ADDR_VAR 0 3
47624: PUSH
47625: DOUBLE
47626: LD_INT 1
47628: DEC
47629: ST_TO_ADDR
47630: LD_EXP 50
47634: PUSH
47635: FOR_TO
47636: IFFALSE 47833
// begin if building in mc_construct_list [ i ] then
47638: LD_VAR 0 1
47642: PUSH
47643: LD_EXP 57
47647: PUSH
47648: LD_VAR 0 3
47652: ARRAY
47653: IN
47654: IFFALSE 47831
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
47656: LD_ADDR_EXP 57
47660: PUSH
47661: LD_EXP 57
47665: PPUSH
47666: LD_VAR 0 3
47670: PPUSH
47671: LD_EXP 57
47675: PUSH
47676: LD_VAR 0 3
47680: ARRAY
47681: PUSH
47682: LD_VAR 0 1
47686: DIFF
47687: PPUSH
47688: CALL_OW 1
47692: ST_TO_ADDR
// if building in mc_lab [ i ] then
47693: LD_VAR 0 1
47697: PUSH
47698: LD_EXP 83
47702: PUSH
47703: LD_VAR 0 3
47707: ARRAY
47708: IN
47709: IFFALSE 47764
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
47711: LD_ADDR_EXP 84
47715: PUSH
47716: LD_EXP 84
47720: PPUSH
47721: LD_VAR 0 3
47725: PPUSH
47726: LD_EXP 84
47730: PUSH
47731: LD_VAR 0 3
47735: ARRAY
47736: PPUSH
47737: LD_INT 1
47739: PPUSH
47740: LD_EXP 84
47744: PUSH
47745: LD_VAR 0 3
47749: ARRAY
47750: PPUSH
47751: LD_INT 0
47753: PPUSH
47754: CALL 53563 0 4
47758: PPUSH
47759: CALL_OW 1
47763: ST_TO_ADDR
// if not building in mc_bases [ i ] then
47764: LD_VAR 0 1
47768: PUSH
47769: LD_EXP 50
47773: PUSH
47774: LD_VAR 0 3
47778: ARRAY
47779: IN
47780: NOT
47781: IFFALSE 47827
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
47783: LD_ADDR_EXP 50
47787: PUSH
47788: LD_EXP 50
47792: PPUSH
47793: LD_VAR 0 3
47797: PUSH
47798: LD_EXP 50
47802: PUSH
47803: LD_VAR 0 3
47807: ARRAY
47808: PUSH
47809: LD_INT 1
47811: PLUS
47812: PUSH
47813: EMPTY
47814: LIST
47815: LIST
47816: PPUSH
47817: LD_VAR 0 1
47821: PPUSH
47822: CALL 54145 0 3
47826: ST_TO_ADDR
// exit ;
47827: POP
47828: POP
47829: GO 47835
// end ; end ;
47831: GO 47635
47833: POP
47834: POP
// end ;
47835: LD_VAR 0 2
47839: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
47840: LD_INT 0
47842: PPUSH
47843: PPUSH
47844: PPUSH
47845: PPUSH
47846: PPUSH
47847: PPUSH
47848: PPUSH
// if not mc_bases or not skirmish then
47849: LD_EXP 50
47853: NOT
47854: PUSH
47855: LD_EXP 48
47859: NOT
47860: OR
47861: IFFALSE 47865
// exit ;
47863: GO 48526
// for i = 1 to mc_bases do
47865: LD_ADDR_VAR 0 3
47869: PUSH
47870: DOUBLE
47871: LD_INT 1
47873: DEC
47874: ST_TO_ADDR
47875: LD_EXP 50
47879: PUSH
47880: FOR_TO
47881: IFFALSE 48524
// begin if building in mc_construct_list [ i ] then
47883: LD_VAR 0 1
47887: PUSH
47888: LD_EXP 57
47892: PUSH
47893: LD_VAR 0 3
47897: ARRAY
47898: IN
47899: IFFALSE 48522
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
47901: LD_ADDR_EXP 57
47905: PUSH
47906: LD_EXP 57
47910: PPUSH
47911: LD_VAR 0 3
47915: PPUSH
47916: LD_EXP 57
47920: PUSH
47921: LD_VAR 0 3
47925: ARRAY
47926: PUSH
47927: LD_VAR 0 1
47931: DIFF
47932: PPUSH
47933: CALL_OW 1
47937: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
47938: LD_ADDR_EXP 50
47942: PUSH
47943: LD_EXP 50
47947: PPUSH
47948: LD_VAR 0 3
47952: PUSH
47953: LD_EXP 50
47957: PUSH
47958: LD_VAR 0 3
47962: ARRAY
47963: PUSH
47964: LD_INT 1
47966: PLUS
47967: PUSH
47968: EMPTY
47969: LIST
47970: LIST
47971: PPUSH
47972: LD_VAR 0 1
47976: PPUSH
47977: CALL 54145 0 3
47981: ST_TO_ADDR
// btype := GetBType ( building ) ;
47982: LD_ADDR_VAR 0 5
47986: PUSH
47987: LD_VAR 0 1
47991: PPUSH
47992: CALL_OW 266
47996: ST_TO_ADDR
// side := GetSide ( building ) ;
47997: LD_ADDR_VAR 0 8
48001: PUSH
48002: LD_VAR 0 1
48006: PPUSH
48007: CALL_OW 255
48011: ST_TO_ADDR
// if btype = b_lab then
48012: LD_VAR 0 5
48016: PUSH
48017: LD_INT 6
48019: EQUAL
48020: IFFALSE 48070
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
48022: LD_ADDR_EXP 83
48026: PUSH
48027: LD_EXP 83
48031: PPUSH
48032: LD_VAR 0 3
48036: PUSH
48037: LD_EXP 83
48041: PUSH
48042: LD_VAR 0 3
48046: ARRAY
48047: PUSH
48048: LD_INT 1
48050: PLUS
48051: PUSH
48052: EMPTY
48053: LIST
48054: LIST
48055: PPUSH
48056: LD_VAR 0 1
48060: PPUSH
48061: CALL 54145 0 3
48065: ST_TO_ADDR
// exit ;
48066: POP
48067: POP
48068: GO 48526
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
48070: LD_VAR 0 5
48074: PUSH
48075: LD_INT 0
48077: PUSH
48078: LD_INT 2
48080: PUSH
48081: LD_INT 4
48083: PUSH
48084: EMPTY
48085: LIST
48086: LIST
48087: LIST
48088: IN
48089: IFFALSE 48213
// begin if btype = b_armoury then
48091: LD_VAR 0 5
48095: PUSH
48096: LD_INT 4
48098: EQUAL
48099: IFFALSE 48109
// btype := b_barracks ;
48101: LD_ADDR_VAR 0 5
48105: PUSH
48106: LD_INT 5
48108: ST_TO_ADDR
// if btype = b_depot then
48109: LD_VAR 0 5
48113: PUSH
48114: LD_INT 0
48116: EQUAL
48117: IFFALSE 48127
// btype := b_warehouse ;
48119: LD_ADDR_VAR 0 5
48123: PUSH
48124: LD_INT 1
48126: ST_TO_ADDR
// if btype = b_workshop then
48127: LD_VAR 0 5
48131: PUSH
48132: LD_INT 2
48134: EQUAL
48135: IFFALSE 48145
// btype := b_factory ;
48137: LD_ADDR_VAR 0 5
48141: PUSH
48142: LD_INT 3
48144: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
48145: LD_VAR 0 5
48149: PPUSH
48150: LD_VAR 0 8
48154: PPUSH
48155: CALL_OW 323
48159: PUSH
48160: LD_INT 1
48162: EQUAL
48163: IFFALSE 48209
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
48165: LD_ADDR_EXP 82
48169: PUSH
48170: LD_EXP 82
48174: PPUSH
48175: LD_VAR 0 3
48179: PUSH
48180: LD_EXP 82
48184: PUSH
48185: LD_VAR 0 3
48189: ARRAY
48190: PUSH
48191: LD_INT 1
48193: PLUS
48194: PUSH
48195: EMPTY
48196: LIST
48197: LIST
48198: PPUSH
48199: LD_VAR 0 1
48203: PPUSH
48204: CALL 54145 0 3
48208: ST_TO_ADDR
// exit ;
48209: POP
48210: POP
48211: GO 48526
// end ; if btype in [ b_bunker , b_turret ] then
48213: LD_VAR 0 5
48217: PUSH
48218: LD_INT 32
48220: PUSH
48221: LD_INT 33
48223: PUSH
48224: EMPTY
48225: LIST
48226: LIST
48227: IN
48228: IFFALSE 48518
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
48230: LD_ADDR_EXP 58
48234: PUSH
48235: LD_EXP 58
48239: PPUSH
48240: LD_VAR 0 3
48244: PUSH
48245: LD_EXP 58
48249: PUSH
48250: LD_VAR 0 3
48254: ARRAY
48255: PUSH
48256: LD_INT 1
48258: PLUS
48259: PUSH
48260: EMPTY
48261: LIST
48262: LIST
48263: PPUSH
48264: LD_VAR 0 1
48268: PPUSH
48269: CALL 54145 0 3
48273: ST_TO_ADDR
// if btype = b_bunker then
48274: LD_VAR 0 5
48278: PUSH
48279: LD_INT 32
48281: EQUAL
48282: IFFALSE 48518
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
48284: LD_ADDR_EXP 59
48288: PUSH
48289: LD_EXP 59
48293: PPUSH
48294: LD_VAR 0 3
48298: PUSH
48299: LD_EXP 59
48303: PUSH
48304: LD_VAR 0 3
48308: ARRAY
48309: PUSH
48310: LD_INT 1
48312: PLUS
48313: PUSH
48314: EMPTY
48315: LIST
48316: LIST
48317: PPUSH
48318: LD_VAR 0 1
48322: PPUSH
48323: CALL 54145 0 3
48327: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
48328: LD_ADDR_VAR 0 6
48332: PUSH
48333: LD_EXP 50
48337: PUSH
48338: LD_VAR 0 3
48342: ARRAY
48343: PPUSH
48344: LD_INT 25
48346: PUSH
48347: LD_INT 1
48349: PUSH
48350: EMPTY
48351: LIST
48352: LIST
48353: PUSH
48354: LD_INT 3
48356: PUSH
48357: LD_INT 54
48359: PUSH
48360: EMPTY
48361: LIST
48362: PUSH
48363: EMPTY
48364: LIST
48365: LIST
48366: PUSH
48367: EMPTY
48368: LIST
48369: LIST
48370: PPUSH
48371: CALL_OW 72
48375: ST_TO_ADDR
// if tmp then
48376: LD_VAR 0 6
48380: IFFALSE 48386
// exit ;
48382: POP
48383: POP
48384: GO 48526
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
48386: LD_ADDR_VAR 0 6
48390: PUSH
48391: LD_EXP 50
48395: PUSH
48396: LD_VAR 0 3
48400: ARRAY
48401: PPUSH
48402: LD_INT 2
48404: PUSH
48405: LD_INT 30
48407: PUSH
48408: LD_INT 4
48410: PUSH
48411: EMPTY
48412: LIST
48413: LIST
48414: PUSH
48415: LD_INT 30
48417: PUSH
48418: LD_INT 5
48420: PUSH
48421: EMPTY
48422: LIST
48423: LIST
48424: PUSH
48425: EMPTY
48426: LIST
48427: LIST
48428: LIST
48429: PPUSH
48430: CALL_OW 72
48434: ST_TO_ADDR
// if not tmp then
48435: LD_VAR 0 6
48439: NOT
48440: IFFALSE 48446
// exit ;
48442: POP
48443: POP
48444: GO 48526
// for j in tmp do
48446: LD_ADDR_VAR 0 4
48450: PUSH
48451: LD_VAR 0 6
48455: PUSH
48456: FOR_IN
48457: IFFALSE 48516
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
48459: LD_ADDR_VAR 0 7
48463: PUSH
48464: LD_VAR 0 4
48468: PPUSH
48469: CALL_OW 313
48473: PPUSH
48474: LD_INT 25
48476: PUSH
48477: LD_INT 1
48479: PUSH
48480: EMPTY
48481: LIST
48482: LIST
48483: PPUSH
48484: CALL_OW 72
48488: ST_TO_ADDR
// if units then
48489: LD_VAR 0 7
48493: IFFALSE 48514
// begin ComExitBuilding ( units [ 1 ] ) ;
48495: LD_VAR 0 7
48499: PUSH
48500: LD_INT 1
48502: ARRAY
48503: PPUSH
48504: CALL_OW 122
// exit ;
48508: POP
48509: POP
48510: POP
48511: POP
48512: GO 48526
// end ; end ;
48514: GO 48456
48516: POP
48517: POP
// end ; end ; exit ;
48518: POP
48519: POP
48520: GO 48526
// end ; end ;
48522: GO 47880
48524: POP
48525: POP
// end ;
48526: LD_VAR 0 2
48530: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
48531: LD_INT 0
48533: PPUSH
48534: PPUSH
48535: PPUSH
48536: PPUSH
48537: PPUSH
48538: PPUSH
48539: PPUSH
// if not mc_bases or not skirmish then
48540: LD_EXP 50
48544: NOT
48545: PUSH
48546: LD_EXP 48
48550: NOT
48551: OR
48552: IFFALSE 48556
// exit ;
48554: GO 48821
// btype := GetBType ( building ) ;
48556: LD_ADDR_VAR 0 6
48560: PUSH
48561: LD_VAR 0 1
48565: PPUSH
48566: CALL_OW 266
48570: ST_TO_ADDR
// x := GetX ( building ) ;
48571: LD_ADDR_VAR 0 7
48575: PUSH
48576: LD_VAR 0 1
48580: PPUSH
48581: CALL_OW 250
48585: ST_TO_ADDR
// y := GetY ( building ) ;
48586: LD_ADDR_VAR 0 8
48590: PUSH
48591: LD_VAR 0 1
48595: PPUSH
48596: CALL_OW 251
48600: ST_TO_ADDR
// d := GetDir ( building ) ;
48601: LD_ADDR_VAR 0 9
48605: PUSH
48606: LD_VAR 0 1
48610: PPUSH
48611: CALL_OW 254
48615: ST_TO_ADDR
// for i = 1 to mc_bases do
48616: LD_ADDR_VAR 0 4
48620: PUSH
48621: DOUBLE
48622: LD_INT 1
48624: DEC
48625: ST_TO_ADDR
48626: LD_EXP 50
48630: PUSH
48631: FOR_TO
48632: IFFALSE 48819
// begin if not mc_build_list [ i ] then
48634: LD_EXP 55
48638: PUSH
48639: LD_VAR 0 4
48643: ARRAY
48644: NOT
48645: IFFALSE 48649
// continue ;
48647: GO 48631
// for j := 1 to mc_build_list [ i ] do
48649: LD_ADDR_VAR 0 5
48653: PUSH
48654: DOUBLE
48655: LD_INT 1
48657: DEC
48658: ST_TO_ADDR
48659: LD_EXP 55
48663: PUSH
48664: LD_VAR 0 4
48668: ARRAY
48669: PUSH
48670: FOR_TO
48671: IFFALSE 48815
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
48673: LD_VAR 0 6
48677: PUSH
48678: LD_VAR 0 7
48682: PUSH
48683: LD_VAR 0 8
48687: PUSH
48688: LD_VAR 0 9
48692: PUSH
48693: EMPTY
48694: LIST
48695: LIST
48696: LIST
48697: LIST
48698: PPUSH
48699: LD_EXP 55
48703: PUSH
48704: LD_VAR 0 4
48708: ARRAY
48709: PUSH
48710: LD_VAR 0 5
48714: ARRAY
48715: PPUSH
48716: CALL 60702 0 2
48720: IFFALSE 48813
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
48722: LD_ADDR_EXP 55
48726: PUSH
48727: LD_EXP 55
48731: PPUSH
48732: LD_VAR 0 4
48736: PPUSH
48737: LD_EXP 55
48741: PUSH
48742: LD_VAR 0 4
48746: ARRAY
48747: PPUSH
48748: LD_VAR 0 5
48752: PPUSH
48753: CALL_OW 3
48757: PPUSH
48758: CALL_OW 1
48762: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
48763: LD_ADDR_EXP 57
48767: PUSH
48768: LD_EXP 57
48772: PPUSH
48773: LD_VAR 0 4
48777: PUSH
48778: LD_EXP 57
48782: PUSH
48783: LD_VAR 0 4
48787: ARRAY
48788: PUSH
48789: LD_INT 1
48791: PLUS
48792: PUSH
48793: EMPTY
48794: LIST
48795: LIST
48796: PPUSH
48797: LD_VAR 0 1
48801: PPUSH
48802: CALL 54145 0 3
48806: ST_TO_ADDR
// exit ;
48807: POP
48808: POP
48809: POP
48810: POP
48811: GO 48821
// end ;
48813: GO 48670
48815: POP
48816: POP
// end ;
48817: GO 48631
48819: POP
48820: POP
// end ;
48821: LD_VAR 0 3
48825: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
48826: LD_INT 0
48828: PPUSH
48829: PPUSH
48830: PPUSH
// if not mc_bases or not skirmish then
48831: LD_EXP 50
48835: NOT
48836: PUSH
48837: LD_EXP 48
48841: NOT
48842: OR
48843: IFFALSE 48847
// exit ;
48845: GO 49037
// for i = 1 to mc_bases do
48847: LD_ADDR_VAR 0 4
48851: PUSH
48852: DOUBLE
48853: LD_INT 1
48855: DEC
48856: ST_TO_ADDR
48857: LD_EXP 50
48861: PUSH
48862: FOR_TO
48863: IFFALSE 48950
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
48865: LD_VAR 0 1
48869: PUSH
48870: LD_EXP 58
48874: PUSH
48875: LD_VAR 0 4
48879: ARRAY
48880: IN
48881: PUSH
48882: LD_VAR 0 1
48886: PUSH
48887: LD_EXP 59
48891: PUSH
48892: LD_VAR 0 4
48896: ARRAY
48897: IN
48898: NOT
48899: AND
48900: IFFALSE 48948
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
48902: LD_ADDR_EXP 59
48906: PUSH
48907: LD_EXP 59
48911: PPUSH
48912: LD_VAR 0 4
48916: PUSH
48917: LD_EXP 59
48921: PUSH
48922: LD_VAR 0 4
48926: ARRAY
48927: PUSH
48928: LD_INT 1
48930: PLUS
48931: PUSH
48932: EMPTY
48933: LIST
48934: LIST
48935: PPUSH
48936: LD_VAR 0 1
48940: PPUSH
48941: CALL 54145 0 3
48945: ST_TO_ADDR
// break ;
48946: GO 48950
// end ; end ;
48948: GO 48862
48950: POP
48951: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
48952: LD_VAR 0 1
48956: PPUSH
48957: CALL_OW 257
48961: PUSH
48962: LD_EXP 76
48966: IN
48967: PUSH
48968: LD_VAR 0 1
48972: PPUSH
48973: CALL_OW 266
48977: PUSH
48978: LD_INT 5
48980: EQUAL
48981: AND
48982: PUSH
48983: LD_VAR 0 2
48987: PPUSH
48988: CALL_OW 110
48992: PUSH
48993: LD_INT 18
48995: NONEQUAL
48996: AND
48997: IFFALSE 49037
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
48999: LD_VAR 0 2
49003: PPUSH
49004: CALL_OW 257
49008: PUSH
49009: LD_INT 5
49011: PUSH
49012: LD_INT 8
49014: PUSH
49015: LD_INT 9
49017: PUSH
49018: EMPTY
49019: LIST
49020: LIST
49021: LIST
49022: IN
49023: IFFALSE 49037
// SetClass ( unit , 1 ) ;
49025: LD_VAR 0 2
49029: PPUSH
49030: LD_INT 1
49032: PPUSH
49033: CALL_OW 336
// end ;
49037: LD_VAR 0 3
49041: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
49042: LD_INT 0
49044: PPUSH
49045: PPUSH
// if not mc_bases or not skirmish then
49046: LD_EXP 50
49050: NOT
49051: PUSH
49052: LD_EXP 48
49056: NOT
49057: OR
49058: IFFALSE 49062
// exit ;
49060: GO 49178
// if GetLives ( abandoned_vehicle ) > 250 then
49062: LD_VAR 0 2
49066: PPUSH
49067: CALL_OW 256
49071: PUSH
49072: LD_INT 250
49074: GREATER
49075: IFFALSE 49079
// exit ;
49077: GO 49178
// for i = 1 to mc_bases do
49079: LD_ADDR_VAR 0 6
49083: PUSH
49084: DOUBLE
49085: LD_INT 1
49087: DEC
49088: ST_TO_ADDR
49089: LD_EXP 50
49093: PUSH
49094: FOR_TO
49095: IFFALSE 49176
// begin if driver in mc_bases [ i ] then
49097: LD_VAR 0 1
49101: PUSH
49102: LD_EXP 50
49106: PUSH
49107: LD_VAR 0 6
49111: ARRAY
49112: IN
49113: IFFALSE 49174
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
49115: LD_VAR 0 1
49119: PPUSH
49120: LD_EXP 50
49124: PUSH
49125: LD_VAR 0 6
49129: ARRAY
49130: PPUSH
49131: LD_INT 2
49133: PUSH
49134: LD_INT 30
49136: PUSH
49137: LD_INT 0
49139: PUSH
49140: EMPTY
49141: LIST
49142: LIST
49143: PUSH
49144: LD_INT 30
49146: PUSH
49147: LD_INT 1
49149: PUSH
49150: EMPTY
49151: LIST
49152: LIST
49153: PUSH
49154: EMPTY
49155: LIST
49156: LIST
49157: LIST
49158: PPUSH
49159: CALL_OW 72
49163: PUSH
49164: LD_INT 1
49166: ARRAY
49167: PPUSH
49168: CALL 87751 0 2
// break ;
49172: GO 49176
// end ; end ;
49174: GO 49094
49176: POP
49177: POP
// end ; end_of_file
49178: LD_VAR 0 5
49182: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
49183: LD_INT 0
49185: PPUSH
49186: PPUSH
// if exist_mode then
49187: LD_VAR 0 2
49191: IFFALSE 49216
// unit := CreateCharacter ( prefix & ident ) else
49193: LD_ADDR_VAR 0 5
49197: PUSH
49198: LD_VAR 0 3
49202: PUSH
49203: LD_VAR 0 1
49207: STR
49208: PPUSH
49209: CALL_OW 34
49213: ST_TO_ADDR
49214: GO 49231
// unit := NewCharacter ( ident ) ;
49216: LD_ADDR_VAR 0 5
49220: PUSH
49221: LD_VAR 0 1
49225: PPUSH
49226: CALL_OW 25
49230: ST_TO_ADDR
// result := unit ;
49231: LD_ADDR_VAR 0 4
49235: PUSH
49236: LD_VAR 0 5
49240: ST_TO_ADDR
// end ;
49241: LD_VAR 0 4
49245: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
49246: LD_INT 0
49248: PPUSH
49249: PPUSH
// if not side or not nation then
49250: LD_VAR 0 1
49254: NOT
49255: PUSH
49256: LD_VAR 0 2
49260: NOT
49261: OR
49262: IFFALSE 49266
// exit ;
49264: GO 50034
// case nation of nation_american :
49266: LD_VAR 0 2
49270: PUSH
49271: LD_INT 1
49273: DOUBLE
49274: EQUAL
49275: IFTRUE 49279
49277: GO 49493
49279: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
49280: LD_ADDR_VAR 0 4
49284: PUSH
49285: LD_INT 35
49287: PUSH
49288: LD_INT 45
49290: PUSH
49291: LD_INT 46
49293: PUSH
49294: LD_INT 47
49296: PUSH
49297: LD_INT 82
49299: PUSH
49300: LD_INT 83
49302: PUSH
49303: LD_INT 84
49305: PUSH
49306: LD_INT 85
49308: PUSH
49309: LD_INT 86
49311: PUSH
49312: LD_INT 1
49314: PUSH
49315: LD_INT 2
49317: PUSH
49318: LD_INT 6
49320: PUSH
49321: LD_INT 15
49323: PUSH
49324: LD_INT 16
49326: PUSH
49327: LD_INT 7
49329: PUSH
49330: LD_INT 12
49332: PUSH
49333: LD_INT 13
49335: PUSH
49336: LD_INT 10
49338: PUSH
49339: LD_INT 14
49341: PUSH
49342: LD_INT 20
49344: PUSH
49345: LD_INT 21
49347: PUSH
49348: LD_INT 22
49350: PUSH
49351: LD_INT 25
49353: PUSH
49354: LD_INT 32
49356: PUSH
49357: LD_INT 27
49359: PUSH
49360: LD_INT 36
49362: PUSH
49363: LD_INT 69
49365: PUSH
49366: LD_INT 39
49368: PUSH
49369: LD_INT 34
49371: PUSH
49372: LD_INT 40
49374: PUSH
49375: LD_INT 48
49377: PUSH
49378: LD_INT 49
49380: PUSH
49381: LD_INT 50
49383: PUSH
49384: LD_INT 51
49386: PUSH
49387: LD_INT 52
49389: PUSH
49390: LD_INT 53
49392: PUSH
49393: LD_INT 54
49395: PUSH
49396: LD_INT 55
49398: PUSH
49399: LD_INT 56
49401: PUSH
49402: LD_INT 57
49404: PUSH
49405: LD_INT 58
49407: PUSH
49408: LD_INT 59
49410: PUSH
49411: LD_INT 60
49413: PUSH
49414: LD_INT 61
49416: PUSH
49417: LD_INT 62
49419: PUSH
49420: LD_INT 80
49422: PUSH
49423: LD_INT 82
49425: PUSH
49426: LD_INT 83
49428: PUSH
49429: LD_INT 84
49431: PUSH
49432: LD_INT 85
49434: PUSH
49435: LD_INT 86
49437: PUSH
49438: EMPTY
49439: LIST
49440: LIST
49441: LIST
49442: LIST
49443: LIST
49444: LIST
49445: LIST
49446: LIST
49447: LIST
49448: LIST
49449: LIST
49450: LIST
49451: LIST
49452: LIST
49453: LIST
49454: LIST
49455: LIST
49456: LIST
49457: LIST
49458: LIST
49459: LIST
49460: LIST
49461: LIST
49462: LIST
49463: LIST
49464: LIST
49465: LIST
49466: LIST
49467: LIST
49468: LIST
49469: LIST
49470: LIST
49471: LIST
49472: LIST
49473: LIST
49474: LIST
49475: LIST
49476: LIST
49477: LIST
49478: LIST
49479: LIST
49480: LIST
49481: LIST
49482: LIST
49483: LIST
49484: LIST
49485: LIST
49486: LIST
49487: LIST
49488: LIST
49489: LIST
49490: ST_TO_ADDR
49491: GO 49958
49493: LD_INT 2
49495: DOUBLE
49496: EQUAL
49497: IFTRUE 49501
49499: GO 49727
49501: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
49502: LD_ADDR_VAR 0 4
49506: PUSH
49507: LD_INT 35
49509: PUSH
49510: LD_INT 45
49512: PUSH
49513: LD_INT 46
49515: PUSH
49516: LD_INT 47
49518: PUSH
49519: LD_INT 82
49521: PUSH
49522: LD_INT 83
49524: PUSH
49525: LD_INT 84
49527: PUSH
49528: LD_INT 85
49530: PUSH
49531: LD_INT 87
49533: PUSH
49534: LD_INT 70
49536: PUSH
49537: LD_INT 1
49539: PUSH
49540: LD_INT 11
49542: PUSH
49543: LD_INT 3
49545: PUSH
49546: LD_INT 4
49548: PUSH
49549: LD_INT 5
49551: PUSH
49552: LD_INT 6
49554: PUSH
49555: LD_INT 15
49557: PUSH
49558: LD_INT 18
49560: PUSH
49561: LD_INT 7
49563: PUSH
49564: LD_INT 17
49566: PUSH
49567: LD_INT 8
49569: PUSH
49570: LD_INT 20
49572: PUSH
49573: LD_INT 21
49575: PUSH
49576: LD_INT 22
49578: PUSH
49579: LD_INT 72
49581: PUSH
49582: LD_INT 26
49584: PUSH
49585: LD_INT 69
49587: PUSH
49588: LD_INT 39
49590: PUSH
49591: LD_INT 40
49593: PUSH
49594: LD_INT 41
49596: PUSH
49597: LD_INT 42
49599: PUSH
49600: LD_INT 43
49602: PUSH
49603: LD_INT 48
49605: PUSH
49606: LD_INT 49
49608: PUSH
49609: LD_INT 50
49611: PUSH
49612: LD_INT 51
49614: PUSH
49615: LD_INT 52
49617: PUSH
49618: LD_INT 53
49620: PUSH
49621: LD_INT 54
49623: PUSH
49624: LD_INT 55
49626: PUSH
49627: LD_INT 56
49629: PUSH
49630: LD_INT 60
49632: PUSH
49633: LD_INT 61
49635: PUSH
49636: LD_INT 62
49638: PUSH
49639: LD_INT 66
49641: PUSH
49642: LD_INT 67
49644: PUSH
49645: LD_INT 68
49647: PUSH
49648: LD_INT 81
49650: PUSH
49651: LD_INT 82
49653: PUSH
49654: LD_INT 83
49656: PUSH
49657: LD_INT 84
49659: PUSH
49660: LD_INT 85
49662: PUSH
49663: LD_INT 87
49665: PUSH
49666: LD_INT 88
49668: PUSH
49669: EMPTY
49670: LIST
49671: LIST
49672: LIST
49673: LIST
49674: LIST
49675: LIST
49676: LIST
49677: LIST
49678: LIST
49679: LIST
49680: LIST
49681: LIST
49682: LIST
49683: LIST
49684: LIST
49685: LIST
49686: LIST
49687: LIST
49688: LIST
49689: LIST
49690: LIST
49691: LIST
49692: LIST
49693: LIST
49694: LIST
49695: LIST
49696: LIST
49697: LIST
49698: LIST
49699: LIST
49700: LIST
49701: LIST
49702: LIST
49703: LIST
49704: LIST
49705: LIST
49706: LIST
49707: LIST
49708: LIST
49709: LIST
49710: LIST
49711: LIST
49712: LIST
49713: LIST
49714: LIST
49715: LIST
49716: LIST
49717: LIST
49718: LIST
49719: LIST
49720: LIST
49721: LIST
49722: LIST
49723: LIST
49724: ST_TO_ADDR
49725: GO 49958
49727: LD_INT 3
49729: DOUBLE
49730: EQUAL
49731: IFTRUE 49735
49733: GO 49957
49735: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
49736: LD_ADDR_VAR 0 4
49740: PUSH
49741: LD_INT 46
49743: PUSH
49744: LD_INT 47
49746: PUSH
49747: LD_INT 1
49749: PUSH
49750: LD_INT 2
49752: PUSH
49753: LD_INT 82
49755: PUSH
49756: LD_INT 83
49758: PUSH
49759: LD_INT 84
49761: PUSH
49762: LD_INT 85
49764: PUSH
49765: LD_INT 86
49767: PUSH
49768: LD_INT 11
49770: PUSH
49771: LD_INT 9
49773: PUSH
49774: LD_INT 20
49776: PUSH
49777: LD_INT 19
49779: PUSH
49780: LD_INT 21
49782: PUSH
49783: LD_INT 24
49785: PUSH
49786: LD_INT 22
49788: PUSH
49789: LD_INT 25
49791: PUSH
49792: LD_INT 28
49794: PUSH
49795: LD_INT 29
49797: PUSH
49798: LD_INT 30
49800: PUSH
49801: LD_INT 31
49803: PUSH
49804: LD_INT 37
49806: PUSH
49807: LD_INT 38
49809: PUSH
49810: LD_INT 32
49812: PUSH
49813: LD_INT 27
49815: PUSH
49816: LD_INT 33
49818: PUSH
49819: LD_INT 69
49821: PUSH
49822: LD_INT 39
49824: PUSH
49825: LD_INT 34
49827: PUSH
49828: LD_INT 40
49830: PUSH
49831: LD_INT 71
49833: PUSH
49834: LD_INT 23
49836: PUSH
49837: LD_INT 44
49839: PUSH
49840: LD_INT 48
49842: PUSH
49843: LD_INT 49
49845: PUSH
49846: LD_INT 50
49848: PUSH
49849: LD_INT 51
49851: PUSH
49852: LD_INT 52
49854: PUSH
49855: LD_INT 53
49857: PUSH
49858: LD_INT 54
49860: PUSH
49861: LD_INT 55
49863: PUSH
49864: LD_INT 56
49866: PUSH
49867: LD_INT 57
49869: PUSH
49870: LD_INT 58
49872: PUSH
49873: LD_INT 59
49875: PUSH
49876: LD_INT 63
49878: PUSH
49879: LD_INT 64
49881: PUSH
49882: LD_INT 65
49884: PUSH
49885: LD_INT 82
49887: PUSH
49888: LD_INT 83
49890: PUSH
49891: LD_INT 84
49893: PUSH
49894: LD_INT 85
49896: PUSH
49897: LD_INT 86
49899: PUSH
49900: EMPTY
49901: LIST
49902: LIST
49903: LIST
49904: LIST
49905: LIST
49906: LIST
49907: LIST
49908: LIST
49909: LIST
49910: LIST
49911: LIST
49912: LIST
49913: LIST
49914: LIST
49915: LIST
49916: LIST
49917: LIST
49918: LIST
49919: LIST
49920: LIST
49921: LIST
49922: LIST
49923: LIST
49924: LIST
49925: LIST
49926: LIST
49927: LIST
49928: LIST
49929: LIST
49930: LIST
49931: LIST
49932: LIST
49933: LIST
49934: LIST
49935: LIST
49936: LIST
49937: LIST
49938: LIST
49939: LIST
49940: LIST
49941: LIST
49942: LIST
49943: LIST
49944: LIST
49945: LIST
49946: LIST
49947: LIST
49948: LIST
49949: LIST
49950: LIST
49951: LIST
49952: LIST
49953: LIST
49954: ST_TO_ADDR
49955: GO 49958
49957: POP
// if state > - 1 and state < 3 then
49958: LD_VAR 0 3
49962: PUSH
49963: LD_INT 1
49965: NEG
49966: GREATER
49967: PUSH
49968: LD_VAR 0 3
49972: PUSH
49973: LD_INT 3
49975: LESS
49976: AND
49977: IFFALSE 50034
// for i in result do
49979: LD_ADDR_VAR 0 5
49983: PUSH
49984: LD_VAR 0 4
49988: PUSH
49989: FOR_IN
49990: IFFALSE 50032
// if GetTech ( i , side ) <> state then
49992: LD_VAR 0 5
49996: PPUSH
49997: LD_VAR 0 1
50001: PPUSH
50002: CALL_OW 321
50006: PUSH
50007: LD_VAR 0 3
50011: NONEQUAL
50012: IFFALSE 50030
// result := result diff i ;
50014: LD_ADDR_VAR 0 4
50018: PUSH
50019: LD_VAR 0 4
50023: PUSH
50024: LD_VAR 0 5
50028: DIFF
50029: ST_TO_ADDR
50030: GO 49989
50032: POP
50033: POP
// end ;
50034: LD_VAR 0 4
50038: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
50039: LD_INT 0
50041: PPUSH
50042: PPUSH
50043: PPUSH
// result := true ;
50044: LD_ADDR_VAR 0 3
50048: PUSH
50049: LD_INT 1
50051: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
50052: LD_ADDR_VAR 0 5
50056: PUSH
50057: LD_VAR 0 2
50061: PPUSH
50062: CALL_OW 480
50066: ST_TO_ADDR
// if not tmp then
50067: LD_VAR 0 5
50071: NOT
50072: IFFALSE 50076
// exit ;
50074: GO 50125
// for i in tmp do
50076: LD_ADDR_VAR 0 4
50080: PUSH
50081: LD_VAR 0 5
50085: PUSH
50086: FOR_IN
50087: IFFALSE 50123
// if GetTech ( i , side ) <> state_researched then
50089: LD_VAR 0 4
50093: PPUSH
50094: LD_VAR 0 1
50098: PPUSH
50099: CALL_OW 321
50103: PUSH
50104: LD_INT 2
50106: NONEQUAL
50107: IFFALSE 50121
// begin result := false ;
50109: LD_ADDR_VAR 0 3
50113: PUSH
50114: LD_INT 0
50116: ST_TO_ADDR
// exit ;
50117: POP
50118: POP
50119: GO 50125
// end ;
50121: GO 50086
50123: POP
50124: POP
// end ;
50125: LD_VAR 0 3
50129: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
50130: LD_INT 0
50132: PPUSH
50133: PPUSH
50134: PPUSH
50135: PPUSH
50136: PPUSH
50137: PPUSH
50138: PPUSH
50139: PPUSH
50140: PPUSH
50141: PPUSH
50142: PPUSH
50143: PPUSH
50144: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
50145: LD_VAR 0 1
50149: NOT
50150: PUSH
50151: LD_VAR 0 1
50155: PPUSH
50156: CALL_OW 257
50160: PUSH
50161: LD_INT 9
50163: NONEQUAL
50164: OR
50165: IFFALSE 50169
// exit ;
50167: GO 50742
// side := GetSide ( unit ) ;
50169: LD_ADDR_VAR 0 9
50173: PUSH
50174: LD_VAR 0 1
50178: PPUSH
50179: CALL_OW 255
50183: ST_TO_ADDR
// tech_space := tech_spacanom ;
50184: LD_ADDR_VAR 0 12
50188: PUSH
50189: LD_INT 29
50191: ST_TO_ADDR
// tech_time := tech_taurad ;
50192: LD_ADDR_VAR 0 13
50196: PUSH
50197: LD_INT 28
50199: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
50200: LD_ADDR_VAR 0 11
50204: PUSH
50205: LD_VAR 0 1
50209: PPUSH
50210: CALL_OW 310
50214: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
50215: LD_VAR 0 11
50219: PPUSH
50220: CALL_OW 247
50224: PUSH
50225: LD_INT 2
50227: EQUAL
50228: IFFALSE 50232
// exit ;
50230: GO 50742
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
50232: LD_ADDR_VAR 0 8
50236: PUSH
50237: LD_INT 81
50239: PUSH
50240: LD_VAR 0 9
50244: PUSH
50245: EMPTY
50246: LIST
50247: LIST
50248: PUSH
50249: LD_INT 3
50251: PUSH
50252: LD_INT 21
50254: PUSH
50255: LD_INT 3
50257: PUSH
50258: EMPTY
50259: LIST
50260: LIST
50261: PUSH
50262: EMPTY
50263: LIST
50264: LIST
50265: PUSH
50266: EMPTY
50267: LIST
50268: LIST
50269: PPUSH
50270: CALL_OW 69
50274: ST_TO_ADDR
// if not tmp then
50275: LD_VAR 0 8
50279: NOT
50280: IFFALSE 50284
// exit ;
50282: GO 50742
// if in_unit then
50284: LD_VAR 0 11
50288: IFFALSE 50312
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
50290: LD_ADDR_VAR 0 10
50294: PUSH
50295: LD_VAR 0 8
50299: PPUSH
50300: LD_VAR 0 11
50304: PPUSH
50305: CALL_OW 74
50309: ST_TO_ADDR
50310: GO 50332
// enemy := NearestUnitToUnit ( tmp , unit ) ;
50312: LD_ADDR_VAR 0 10
50316: PUSH
50317: LD_VAR 0 8
50321: PPUSH
50322: LD_VAR 0 1
50326: PPUSH
50327: CALL_OW 74
50331: ST_TO_ADDR
// if not enemy then
50332: LD_VAR 0 10
50336: NOT
50337: IFFALSE 50341
// exit ;
50339: GO 50742
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
50341: LD_VAR 0 11
50345: PUSH
50346: LD_VAR 0 11
50350: PPUSH
50351: LD_VAR 0 10
50355: PPUSH
50356: CALL_OW 296
50360: PUSH
50361: LD_INT 13
50363: GREATER
50364: AND
50365: PUSH
50366: LD_VAR 0 1
50370: PPUSH
50371: LD_VAR 0 10
50375: PPUSH
50376: CALL_OW 296
50380: PUSH
50381: LD_INT 12
50383: GREATER
50384: OR
50385: IFFALSE 50389
// exit ;
50387: GO 50742
// missile := [ 1 ] ;
50389: LD_ADDR_VAR 0 14
50393: PUSH
50394: LD_INT 1
50396: PUSH
50397: EMPTY
50398: LIST
50399: ST_TO_ADDR
// if Researched ( side , tech_space ) then
50400: LD_VAR 0 9
50404: PPUSH
50405: LD_VAR 0 12
50409: PPUSH
50410: CALL_OW 325
50414: IFFALSE 50443
// missile := Replace ( missile , missile + 1 , 2 ) ;
50416: LD_ADDR_VAR 0 14
50420: PUSH
50421: LD_VAR 0 14
50425: PPUSH
50426: LD_VAR 0 14
50430: PUSH
50431: LD_INT 1
50433: PLUS
50434: PPUSH
50435: LD_INT 2
50437: PPUSH
50438: CALL_OW 1
50442: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
50443: LD_VAR 0 9
50447: PPUSH
50448: LD_VAR 0 13
50452: PPUSH
50453: CALL_OW 325
50457: PUSH
50458: LD_VAR 0 10
50462: PPUSH
50463: CALL_OW 255
50467: PPUSH
50468: LD_VAR 0 13
50472: PPUSH
50473: CALL_OW 325
50477: NOT
50478: AND
50479: IFFALSE 50508
// missile := Replace ( missile , missile + 1 , 3 ) ;
50481: LD_ADDR_VAR 0 14
50485: PUSH
50486: LD_VAR 0 14
50490: PPUSH
50491: LD_VAR 0 14
50495: PUSH
50496: LD_INT 1
50498: PLUS
50499: PPUSH
50500: LD_INT 3
50502: PPUSH
50503: CALL_OW 1
50507: ST_TO_ADDR
// if missile < 2 then
50508: LD_VAR 0 14
50512: PUSH
50513: LD_INT 2
50515: LESS
50516: IFFALSE 50520
// exit ;
50518: GO 50742
// x := GetX ( enemy ) ;
50520: LD_ADDR_VAR 0 4
50524: PUSH
50525: LD_VAR 0 10
50529: PPUSH
50530: CALL_OW 250
50534: ST_TO_ADDR
// y := GetY ( enemy ) ;
50535: LD_ADDR_VAR 0 5
50539: PUSH
50540: LD_VAR 0 10
50544: PPUSH
50545: CALL_OW 251
50549: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
50550: LD_ADDR_VAR 0 6
50554: PUSH
50555: LD_VAR 0 4
50559: PUSH
50560: LD_INT 1
50562: NEG
50563: PPUSH
50564: LD_INT 1
50566: PPUSH
50567: CALL_OW 12
50571: PLUS
50572: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
50573: LD_ADDR_VAR 0 7
50577: PUSH
50578: LD_VAR 0 5
50582: PUSH
50583: LD_INT 1
50585: NEG
50586: PPUSH
50587: LD_INT 1
50589: PPUSH
50590: CALL_OW 12
50594: PLUS
50595: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
50596: LD_VAR 0 6
50600: PPUSH
50601: LD_VAR 0 7
50605: PPUSH
50606: CALL_OW 488
50610: NOT
50611: IFFALSE 50633
// begin _x := x ;
50613: LD_ADDR_VAR 0 6
50617: PUSH
50618: LD_VAR 0 4
50622: ST_TO_ADDR
// _y := y ;
50623: LD_ADDR_VAR 0 7
50627: PUSH
50628: LD_VAR 0 5
50632: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
50633: LD_ADDR_VAR 0 3
50637: PUSH
50638: LD_INT 1
50640: PPUSH
50641: LD_VAR 0 14
50645: PPUSH
50646: CALL_OW 12
50650: ST_TO_ADDR
// case i of 1 :
50651: LD_VAR 0 3
50655: PUSH
50656: LD_INT 1
50658: DOUBLE
50659: EQUAL
50660: IFTRUE 50664
50662: GO 50681
50664: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
50665: LD_VAR 0 1
50669: PPUSH
50670: LD_VAR 0 10
50674: PPUSH
50675: CALL_OW 115
50679: GO 50742
50681: LD_INT 2
50683: DOUBLE
50684: EQUAL
50685: IFTRUE 50689
50687: GO 50711
50689: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
50690: LD_VAR 0 1
50694: PPUSH
50695: LD_VAR 0 6
50699: PPUSH
50700: LD_VAR 0 7
50704: PPUSH
50705: CALL_OW 153
50709: GO 50742
50711: LD_INT 3
50713: DOUBLE
50714: EQUAL
50715: IFTRUE 50719
50717: GO 50741
50719: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
50720: LD_VAR 0 1
50724: PPUSH
50725: LD_VAR 0 6
50729: PPUSH
50730: LD_VAR 0 7
50734: PPUSH
50735: CALL_OW 154
50739: GO 50742
50741: POP
// end ;
50742: LD_VAR 0 2
50746: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
50747: LD_INT 0
50749: PPUSH
50750: PPUSH
50751: PPUSH
50752: PPUSH
50753: PPUSH
50754: PPUSH
// if not unit or not building then
50755: LD_VAR 0 1
50759: NOT
50760: PUSH
50761: LD_VAR 0 2
50765: NOT
50766: OR
50767: IFFALSE 50771
// exit ;
50769: GO 50929
// x := GetX ( building ) ;
50771: LD_ADDR_VAR 0 5
50775: PUSH
50776: LD_VAR 0 2
50780: PPUSH
50781: CALL_OW 250
50785: ST_TO_ADDR
// y := GetY ( building ) ;
50786: LD_ADDR_VAR 0 6
50790: PUSH
50791: LD_VAR 0 2
50795: PPUSH
50796: CALL_OW 251
50800: ST_TO_ADDR
// for i = 0 to 5 do
50801: LD_ADDR_VAR 0 4
50805: PUSH
50806: DOUBLE
50807: LD_INT 0
50809: DEC
50810: ST_TO_ADDR
50811: LD_INT 5
50813: PUSH
50814: FOR_TO
50815: IFFALSE 50927
// begin _x := ShiftX ( x , i , 3 ) ;
50817: LD_ADDR_VAR 0 7
50821: PUSH
50822: LD_VAR 0 5
50826: PPUSH
50827: LD_VAR 0 4
50831: PPUSH
50832: LD_INT 3
50834: PPUSH
50835: CALL_OW 272
50839: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
50840: LD_ADDR_VAR 0 8
50844: PUSH
50845: LD_VAR 0 6
50849: PPUSH
50850: LD_VAR 0 4
50854: PPUSH
50855: LD_INT 3
50857: PPUSH
50858: CALL_OW 273
50862: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
50863: LD_VAR 0 7
50867: PPUSH
50868: LD_VAR 0 8
50872: PPUSH
50873: CALL_OW 488
50877: NOT
50878: IFFALSE 50882
// continue ;
50880: GO 50814
// if HexInfo ( _x , _y ) = 0 then
50882: LD_VAR 0 7
50886: PPUSH
50887: LD_VAR 0 8
50891: PPUSH
50892: CALL_OW 428
50896: PUSH
50897: LD_INT 0
50899: EQUAL
50900: IFFALSE 50925
// begin ComMoveXY ( unit , _x , _y ) ;
50902: LD_VAR 0 1
50906: PPUSH
50907: LD_VAR 0 7
50911: PPUSH
50912: LD_VAR 0 8
50916: PPUSH
50917: CALL_OW 111
// exit ;
50921: POP
50922: POP
50923: GO 50929
// end ; end ;
50925: GO 50814
50927: POP
50928: POP
// end ;
50929: LD_VAR 0 3
50933: RET
// export function ScanBase ( side , base_area ) ; begin
50934: LD_INT 0
50936: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
50937: LD_ADDR_VAR 0 3
50941: PUSH
50942: LD_VAR 0 2
50946: PPUSH
50947: LD_INT 81
50949: PUSH
50950: LD_VAR 0 1
50954: PUSH
50955: EMPTY
50956: LIST
50957: LIST
50958: PPUSH
50959: CALL_OW 70
50963: ST_TO_ADDR
// end ;
50964: LD_VAR 0 3
50968: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
50969: LD_INT 0
50971: PPUSH
50972: PPUSH
50973: PPUSH
50974: PPUSH
// result := false ;
50975: LD_ADDR_VAR 0 2
50979: PUSH
50980: LD_INT 0
50982: ST_TO_ADDR
// side := GetSide ( unit ) ;
50983: LD_ADDR_VAR 0 3
50987: PUSH
50988: LD_VAR 0 1
50992: PPUSH
50993: CALL_OW 255
50997: ST_TO_ADDR
// nat := GetNation ( unit ) ;
50998: LD_ADDR_VAR 0 4
51002: PUSH
51003: LD_VAR 0 1
51007: PPUSH
51008: CALL_OW 248
51012: ST_TO_ADDR
// case nat of 1 :
51013: LD_VAR 0 4
51017: PUSH
51018: LD_INT 1
51020: DOUBLE
51021: EQUAL
51022: IFTRUE 51026
51024: GO 51037
51026: POP
// tech := tech_lassight ; 2 :
51027: LD_ADDR_VAR 0 5
51031: PUSH
51032: LD_INT 12
51034: ST_TO_ADDR
51035: GO 51076
51037: LD_INT 2
51039: DOUBLE
51040: EQUAL
51041: IFTRUE 51045
51043: GO 51056
51045: POP
// tech := tech_mortar ; 3 :
51046: LD_ADDR_VAR 0 5
51050: PUSH
51051: LD_INT 41
51053: ST_TO_ADDR
51054: GO 51076
51056: LD_INT 3
51058: DOUBLE
51059: EQUAL
51060: IFTRUE 51064
51062: GO 51075
51064: POP
// tech := tech_bazooka ; end ;
51065: LD_ADDR_VAR 0 5
51069: PUSH
51070: LD_INT 44
51072: ST_TO_ADDR
51073: GO 51076
51075: POP
// if Researched ( side , tech ) then
51076: LD_VAR 0 3
51080: PPUSH
51081: LD_VAR 0 5
51085: PPUSH
51086: CALL_OW 325
51090: IFFALSE 51117
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
51092: LD_ADDR_VAR 0 2
51096: PUSH
51097: LD_INT 5
51099: PUSH
51100: LD_INT 8
51102: PUSH
51103: LD_INT 9
51105: PUSH
51106: EMPTY
51107: LIST
51108: LIST
51109: LIST
51110: PUSH
51111: LD_VAR 0 4
51115: ARRAY
51116: ST_TO_ADDR
// end ;
51117: LD_VAR 0 2
51121: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
51122: LD_INT 0
51124: PPUSH
51125: PPUSH
51126: PPUSH
// if not mines then
51127: LD_VAR 0 2
51131: NOT
51132: IFFALSE 51136
// exit ;
51134: GO 51280
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
51136: LD_ADDR_VAR 0 5
51140: PUSH
51141: LD_INT 81
51143: PUSH
51144: LD_VAR 0 1
51148: PUSH
51149: EMPTY
51150: LIST
51151: LIST
51152: PUSH
51153: LD_INT 3
51155: PUSH
51156: LD_INT 21
51158: PUSH
51159: LD_INT 3
51161: PUSH
51162: EMPTY
51163: LIST
51164: LIST
51165: PUSH
51166: EMPTY
51167: LIST
51168: LIST
51169: PUSH
51170: EMPTY
51171: LIST
51172: LIST
51173: PPUSH
51174: CALL_OW 69
51178: ST_TO_ADDR
// for i in mines do
51179: LD_ADDR_VAR 0 4
51183: PUSH
51184: LD_VAR 0 2
51188: PUSH
51189: FOR_IN
51190: IFFALSE 51278
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
51192: LD_VAR 0 4
51196: PUSH
51197: LD_INT 1
51199: ARRAY
51200: PPUSH
51201: LD_VAR 0 4
51205: PUSH
51206: LD_INT 2
51208: ARRAY
51209: PPUSH
51210: CALL_OW 458
51214: NOT
51215: IFFALSE 51219
// continue ;
51217: GO 51189
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
51219: LD_VAR 0 4
51223: PUSH
51224: LD_INT 1
51226: ARRAY
51227: PPUSH
51228: LD_VAR 0 4
51232: PUSH
51233: LD_INT 2
51235: ARRAY
51236: PPUSH
51237: CALL_OW 428
51241: PUSH
51242: LD_VAR 0 5
51246: IN
51247: IFFALSE 51276
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
51249: LD_VAR 0 4
51253: PUSH
51254: LD_INT 1
51256: ARRAY
51257: PPUSH
51258: LD_VAR 0 4
51262: PUSH
51263: LD_INT 2
51265: ARRAY
51266: PPUSH
51267: LD_VAR 0 1
51271: PPUSH
51272: CALL_OW 456
// end ;
51276: GO 51189
51278: POP
51279: POP
// end ;
51280: LD_VAR 0 3
51284: RET
// export function Count ( array ) ; begin
51285: LD_INT 0
51287: PPUSH
// result := array + 0 ;
51288: LD_ADDR_VAR 0 2
51292: PUSH
51293: LD_VAR 0 1
51297: PUSH
51298: LD_INT 0
51300: PLUS
51301: ST_TO_ADDR
// end ;
51302: LD_VAR 0 2
51306: RET
// export function IsEmpty ( building ) ; begin
51307: LD_INT 0
51309: PPUSH
// if not building then
51310: LD_VAR 0 1
51314: NOT
51315: IFFALSE 51319
// exit ;
51317: GO 51362
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
51319: LD_ADDR_VAR 0 2
51323: PUSH
51324: LD_VAR 0 1
51328: PUSH
51329: LD_INT 22
51331: PUSH
51332: LD_VAR 0 1
51336: PPUSH
51337: CALL_OW 255
51341: PUSH
51342: EMPTY
51343: LIST
51344: LIST
51345: PUSH
51346: LD_INT 58
51348: PUSH
51349: EMPTY
51350: LIST
51351: PUSH
51352: EMPTY
51353: LIST
51354: LIST
51355: PPUSH
51356: CALL_OW 69
51360: IN
51361: ST_TO_ADDR
// end ;
51362: LD_VAR 0 2
51366: RET
// export function IsNotFull ( building ) ; var places ; begin
51367: LD_INT 0
51369: PPUSH
51370: PPUSH
// if not building then
51371: LD_VAR 0 1
51375: NOT
51376: IFFALSE 51380
// exit ;
51378: GO 51408
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
51380: LD_ADDR_VAR 0 2
51384: PUSH
51385: LD_VAR 0 1
51389: PPUSH
51390: LD_INT 3
51392: PUSH
51393: LD_INT 62
51395: PUSH
51396: EMPTY
51397: LIST
51398: PUSH
51399: EMPTY
51400: LIST
51401: LIST
51402: PPUSH
51403: CALL_OW 72
51407: ST_TO_ADDR
// end ;
51408: LD_VAR 0 2
51412: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
51413: LD_INT 0
51415: PPUSH
51416: PPUSH
51417: PPUSH
51418: PPUSH
// tmp := [ ] ;
51419: LD_ADDR_VAR 0 3
51423: PUSH
51424: EMPTY
51425: ST_TO_ADDR
// list := [ ] ;
51426: LD_ADDR_VAR 0 5
51430: PUSH
51431: EMPTY
51432: ST_TO_ADDR
// for i = 16 to 25 do
51433: LD_ADDR_VAR 0 4
51437: PUSH
51438: DOUBLE
51439: LD_INT 16
51441: DEC
51442: ST_TO_ADDR
51443: LD_INT 25
51445: PUSH
51446: FOR_TO
51447: IFFALSE 51520
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
51449: LD_ADDR_VAR 0 3
51453: PUSH
51454: LD_VAR 0 3
51458: PUSH
51459: LD_INT 22
51461: PUSH
51462: LD_VAR 0 1
51466: PPUSH
51467: CALL_OW 255
51471: PUSH
51472: EMPTY
51473: LIST
51474: LIST
51475: PUSH
51476: LD_INT 91
51478: PUSH
51479: LD_VAR 0 1
51483: PUSH
51484: LD_INT 6
51486: PUSH
51487: EMPTY
51488: LIST
51489: LIST
51490: LIST
51491: PUSH
51492: LD_INT 30
51494: PUSH
51495: LD_VAR 0 4
51499: PUSH
51500: EMPTY
51501: LIST
51502: LIST
51503: PUSH
51504: EMPTY
51505: LIST
51506: LIST
51507: LIST
51508: PUSH
51509: EMPTY
51510: LIST
51511: PPUSH
51512: CALL_OW 69
51516: ADD
51517: ST_TO_ADDR
51518: GO 51446
51520: POP
51521: POP
// for i = 1 to tmp do
51522: LD_ADDR_VAR 0 4
51526: PUSH
51527: DOUBLE
51528: LD_INT 1
51530: DEC
51531: ST_TO_ADDR
51532: LD_VAR 0 3
51536: PUSH
51537: FOR_TO
51538: IFFALSE 51626
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
51540: LD_ADDR_VAR 0 5
51544: PUSH
51545: LD_VAR 0 5
51549: PUSH
51550: LD_VAR 0 3
51554: PUSH
51555: LD_VAR 0 4
51559: ARRAY
51560: PPUSH
51561: CALL_OW 266
51565: PUSH
51566: LD_VAR 0 3
51570: PUSH
51571: LD_VAR 0 4
51575: ARRAY
51576: PPUSH
51577: CALL_OW 250
51581: PUSH
51582: LD_VAR 0 3
51586: PUSH
51587: LD_VAR 0 4
51591: ARRAY
51592: PPUSH
51593: CALL_OW 251
51597: PUSH
51598: LD_VAR 0 3
51602: PUSH
51603: LD_VAR 0 4
51607: ARRAY
51608: PPUSH
51609: CALL_OW 254
51613: PUSH
51614: EMPTY
51615: LIST
51616: LIST
51617: LIST
51618: LIST
51619: PUSH
51620: EMPTY
51621: LIST
51622: ADD
51623: ST_TO_ADDR
51624: GO 51537
51626: POP
51627: POP
// result := list ;
51628: LD_ADDR_VAR 0 2
51632: PUSH
51633: LD_VAR 0 5
51637: ST_TO_ADDR
// end ;
51638: LD_VAR 0 2
51642: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
51643: LD_INT 0
51645: PPUSH
51646: PPUSH
51647: PPUSH
51648: PPUSH
51649: PPUSH
51650: PPUSH
51651: PPUSH
// if not factory then
51652: LD_VAR 0 1
51656: NOT
51657: IFFALSE 51661
// exit ;
51659: GO 52254
// if control = control_apeman then
51661: LD_VAR 0 4
51665: PUSH
51666: LD_INT 5
51668: EQUAL
51669: IFFALSE 51778
// begin tmp := UnitsInside ( factory ) ;
51671: LD_ADDR_VAR 0 8
51675: PUSH
51676: LD_VAR 0 1
51680: PPUSH
51681: CALL_OW 313
51685: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
51686: LD_VAR 0 8
51690: PPUSH
51691: LD_INT 25
51693: PUSH
51694: LD_INT 12
51696: PUSH
51697: EMPTY
51698: LIST
51699: LIST
51700: PPUSH
51701: CALL_OW 72
51705: NOT
51706: IFFALSE 51716
// control := control_manual ;
51708: LD_ADDR_VAR 0 4
51712: PUSH
51713: LD_INT 1
51715: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
51716: LD_ADDR_VAR 0 8
51720: PUSH
51721: LD_VAR 0 1
51725: PPUSH
51726: CALL 51413 0 1
51730: ST_TO_ADDR
// if tmp then
51731: LD_VAR 0 8
51735: IFFALSE 51778
// begin for i in tmp do
51737: LD_ADDR_VAR 0 7
51741: PUSH
51742: LD_VAR 0 8
51746: PUSH
51747: FOR_IN
51748: IFFALSE 51776
// if i [ 1 ] = b_ext_radio then
51750: LD_VAR 0 7
51754: PUSH
51755: LD_INT 1
51757: ARRAY
51758: PUSH
51759: LD_INT 22
51761: EQUAL
51762: IFFALSE 51774
// begin control := control_remote ;
51764: LD_ADDR_VAR 0 4
51768: PUSH
51769: LD_INT 2
51771: ST_TO_ADDR
// break ;
51772: GO 51776
// end ;
51774: GO 51747
51776: POP
51777: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
51778: LD_VAR 0 1
51782: PPUSH
51783: LD_VAR 0 2
51787: PPUSH
51788: LD_VAR 0 3
51792: PPUSH
51793: LD_VAR 0 4
51797: PPUSH
51798: LD_VAR 0 5
51802: PPUSH
51803: CALL_OW 448
51807: IFFALSE 51842
// begin result := [ chassis , engine , control , weapon ] ;
51809: LD_ADDR_VAR 0 6
51813: PUSH
51814: LD_VAR 0 2
51818: PUSH
51819: LD_VAR 0 3
51823: PUSH
51824: LD_VAR 0 4
51828: PUSH
51829: LD_VAR 0 5
51833: PUSH
51834: EMPTY
51835: LIST
51836: LIST
51837: LIST
51838: LIST
51839: ST_TO_ADDR
// exit ;
51840: GO 52254
// end ; _chassis := AvailableChassisList ( factory ) ;
51842: LD_ADDR_VAR 0 9
51846: PUSH
51847: LD_VAR 0 1
51851: PPUSH
51852: CALL_OW 475
51856: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
51857: LD_ADDR_VAR 0 11
51861: PUSH
51862: LD_VAR 0 1
51866: PPUSH
51867: CALL_OW 476
51871: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
51872: LD_ADDR_VAR 0 12
51876: PUSH
51877: LD_VAR 0 1
51881: PPUSH
51882: CALL_OW 477
51886: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
51887: LD_ADDR_VAR 0 10
51891: PUSH
51892: LD_VAR 0 1
51896: PPUSH
51897: CALL_OW 478
51901: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
51902: LD_VAR 0 9
51906: NOT
51907: PUSH
51908: LD_VAR 0 11
51912: NOT
51913: OR
51914: PUSH
51915: LD_VAR 0 12
51919: NOT
51920: OR
51921: PUSH
51922: LD_VAR 0 10
51926: NOT
51927: OR
51928: IFFALSE 51963
// begin result := [ chassis , engine , control , weapon ] ;
51930: LD_ADDR_VAR 0 6
51934: PUSH
51935: LD_VAR 0 2
51939: PUSH
51940: LD_VAR 0 3
51944: PUSH
51945: LD_VAR 0 4
51949: PUSH
51950: LD_VAR 0 5
51954: PUSH
51955: EMPTY
51956: LIST
51957: LIST
51958: LIST
51959: LIST
51960: ST_TO_ADDR
// exit ;
51961: GO 52254
// end ; if not chassis in _chassis then
51963: LD_VAR 0 2
51967: PUSH
51968: LD_VAR 0 9
51972: IN
51973: NOT
51974: IFFALSE 52000
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
51976: LD_ADDR_VAR 0 2
51980: PUSH
51981: LD_VAR 0 9
51985: PUSH
51986: LD_INT 1
51988: PPUSH
51989: LD_VAR 0 9
51993: PPUSH
51994: CALL_OW 12
51998: ARRAY
51999: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
52000: LD_VAR 0 2
52004: PPUSH
52005: LD_VAR 0 3
52009: PPUSH
52010: CALL 52259 0 2
52014: NOT
52015: IFFALSE 52074
// repeat engine := _engine [ 1 ] ;
52017: LD_ADDR_VAR 0 3
52021: PUSH
52022: LD_VAR 0 11
52026: PUSH
52027: LD_INT 1
52029: ARRAY
52030: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
52031: LD_ADDR_VAR 0 11
52035: PUSH
52036: LD_VAR 0 11
52040: PPUSH
52041: LD_INT 1
52043: PPUSH
52044: CALL_OW 3
52048: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
52049: LD_VAR 0 2
52053: PPUSH
52054: LD_VAR 0 3
52058: PPUSH
52059: CALL 52259 0 2
52063: PUSH
52064: LD_VAR 0 11
52068: PUSH
52069: EMPTY
52070: EQUAL
52071: OR
52072: IFFALSE 52017
// if not control in _control then
52074: LD_VAR 0 4
52078: PUSH
52079: LD_VAR 0 12
52083: IN
52084: NOT
52085: IFFALSE 52111
// control := _control [ rand ( 1 , _control ) ] ;
52087: LD_ADDR_VAR 0 4
52091: PUSH
52092: LD_VAR 0 12
52096: PUSH
52097: LD_INT 1
52099: PPUSH
52100: LD_VAR 0 12
52104: PPUSH
52105: CALL_OW 12
52109: ARRAY
52110: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
52111: LD_VAR 0 2
52115: PPUSH
52116: LD_VAR 0 5
52120: PPUSH
52121: CALL 52479 0 2
52125: NOT
52126: IFFALSE 52185
// repeat weapon := _weapon [ 1 ] ;
52128: LD_ADDR_VAR 0 5
52132: PUSH
52133: LD_VAR 0 10
52137: PUSH
52138: LD_INT 1
52140: ARRAY
52141: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
52142: LD_ADDR_VAR 0 10
52146: PUSH
52147: LD_VAR 0 10
52151: PPUSH
52152: LD_INT 1
52154: PPUSH
52155: CALL_OW 3
52159: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
52160: LD_VAR 0 2
52164: PPUSH
52165: LD_VAR 0 5
52169: PPUSH
52170: CALL 52479 0 2
52174: PUSH
52175: LD_VAR 0 10
52179: PUSH
52180: EMPTY
52181: EQUAL
52182: OR
52183: IFFALSE 52128
// result := [ ] ;
52185: LD_ADDR_VAR 0 6
52189: PUSH
52190: EMPTY
52191: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
52192: LD_VAR 0 1
52196: PPUSH
52197: LD_VAR 0 2
52201: PPUSH
52202: LD_VAR 0 3
52206: PPUSH
52207: LD_VAR 0 4
52211: PPUSH
52212: LD_VAR 0 5
52216: PPUSH
52217: CALL_OW 448
52221: IFFALSE 52254
// result := [ chassis , engine , control , weapon ] ;
52223: LD_ADDR_VAR 0 6
52227: PUSH
52228: LD_VAR 0 2
52232: PUSH
52233: LD_VAR 0 3
52237: PUSH
52238: LD_VAR 0 4
52242: PUSH
52243: LD_VAR 0 5
52247: PUSH
52248: EMPTY
52249: LIST
52250: LIST
52251: LIST
52252: LIST
52253: ST_TO_ADDR
// end ;
52254: LD_VAR 0 6
52258: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
52259: LD_INT 0
52261: PPUSH
// if not chassis or not engine then
52262: LD_VAR 0 1
52266: NOT
52267: PUSH
52268: LD_VAR 0 2
52272: NOT
52273: OR
52274: IFFALSE 52278
// exit ;
52276: GO 52474
// case engine of engine_solar :
52278: LD_VAR 0 2
52282: PUSH
52283: LD_INT 2
52285: DOUBLE
52286: EQUAL
52287: IFTRUE 52291
52289: GO 52329
52291: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
52292: LD_ADDR_VAR 0 3
52296: PUSH
52297: LD_INT 11
52299: PUSH
52300: LD_INT 12
52302: PUSH
52303: LD_INT 13
52305: PUSH
52306: LD_INT 14
52308: PUSH
52309: LD_INT 1
52311: PUSH
52312: LD_INT 2
52314: PUSH
52315: LD_INT 3
52317: PUSH
52318: EMPTY
52319: LIST
52320: LIST
52321: LIST
52322: LIST
52323: LIST
52324: LIST
52325: LIST
52326: ST_TO_ADDR
52327: GO 52458
52329: LD_INT 1
52331: DOUBLE
52332: EQUAL
52333: IFTRUE 52337
52335: GO 52399
52337: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
52338: LD_ADDR_VAR 0 3
52342: PUSH
52343: LD_INT 11
52345: PUSH
52346: LD_INT 12
52348: PUSH
52349: LD_INT 13
52351: PUSH
52352: LD_INT 14
52354: PUSH
52355: LD_INT 1
52357: PUSH
52358: LD_INT 2
52360: PUSH
52361: LD_INT 3
52363: PUSH
52364: LD_INT 4
52366: PUSH
52367: LD_INT 5
52369: PUSH
52370: LD_INT 21
52372: PUSH
52373: LD_INT 23
52375: PUSH
52376: LD_INT 22
52378: PUSH
52379: LD_INT 24
52381: PUSH
52382: EMPTY
52383: LIST
52384: LIST
52385: LIST
52386: LIST
52387: LIST
52388: LIST
52389: LIST
52390: LIST
52391: LIST
52392: LIST
52393: LIST
52394: LIST
52395: LIST
52396: ST_TO_ADDR
52397: GO 52458
52399: LD_INT 3
52401: DOUBLE
52402: EQUAL
52403: IFTRUE 52407
52405: GO 52457
52407: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
52408: LD_ADDR_VAR 0 3
52412: PUSH
52413: LD_INT 13
52415: PUSH
52416: LD_INT 14
52418: PUSH
52419: LD_INT 2
52421: PUSH
52422: LD_INT 3
52424: PUSH
52425: LD_INT 4
52427: PUSH
52428: LD_INT 5
52430: PUSH
52431: LD_INT 21
52433: PUSH
52434: LD_INT 22
52436: PUSH
52437: LD_INT 23
52439: PUSH
52440: LD_INT 24
52442: PUSH
52443: EMPTY
52444: LIST
52445: LIST
52446: LIST
52447: LIST
52448: LIST
52449: LIST
52450: LIST
52451: LIST
52452: LIST
52453: LIST
52454: ST_TO_ADDR
52455: GO 52458
52457: POP
// result := ( chassis in result ) ;
52458: LD_ADDR_VAR 0 3
52462: PUSH
52463: LD_VAR 0 1
52467: PUSH
52468: LD_VAR 0 3
52472: IN
52473: ST_TO_ADDR
// end ;
52474: LD_VAR 0 3
52478: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
52479: LD_INT 0
52481: PPUSH
// if not chassis or not weapon then
52482: LD_VAR 0 1
52486: NOT
52487: PUSH
52488: LD_VAR 0 2
52492: NOT
52493: OR
52494: IFFALSE 52498
// exit ;
52496: GO 53558
// case weapon of us_machine_gun :
52498: LD_VAR 0 2
52502: PUSH
52503: LD_INT 2
52505: DOUBLE
52506: EQUAL
52507: IFTRUE 52511
52509: GO 52541
52511: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
52512: LD_ADDR_VAR 0 3
52516: PUSH
52517: LD_INT 1
52519: PUSH
52520: LD_INT 2
52522: PUSH
52523: LD_INT 3
52525: PUSH
52526: LD_INT 4
52528: PUSH
52529: LD_INT 5
52531: PUSH
52532: EMPTY
52533: LIST
52534: LIST
52535: LIST
52536: LIST
52537: LIST
52538: ST_TO_ADDR
52539: GO 53542
52541: LD_INT 3
52543: DOUBLE
52544: EQUAL
52545: IFTRUE 52549
52547: GO 52579
52549: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
52550: LD_ADDR_VAR 0 3
52554: PUSH
52555: LD_INT 1
52557: PUSH
52558: LD_INT 2
52560: PUSH
52561: LD_INT 3
52563: PUSH
52564: LD_INT 4
52566: PUSH
52567: LD_INT 5
52569: PUSH
52570: EMPTY
52571: LIST
52572: LIST
52573: LIST
52574: LIST
52575: LIST
52576: ST_TO_ADDR
52577: GO 53542
52579: LD_INT 11
52581: DOUBLE
52582: EQUAL
52583: IFTRUE 52587
52585: GO 52617
52587: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
52588: LD_ADDR_VAR 0 3
52592: PUSH
52593: LD_INT 1
52595: PUSH
52596: LD_INT 2
52598: PUSH
52599: LD_INT 3
52601: PUSH
52602: LD_INT 4
52604: PUSH
52605: LD_INT 5
52607: PUSH
52608: EMPTY
52609: LIST
52610: LIST
52611: LIST
52612: LIST
52613: LIST
52614: ST_TO_ADDR
52615: GO 53542
52617: LD_INT 4
52619: DOUBLE
52620: EQUAL
52621: IFTRUE 52625
52623: GO 52651
52625: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
52626: LD_ADDR_VAR 0 3
52630: PUSH
52631: LD_INT 2
52633: PUSH
52634: LD_INT 3
52636: PUSH
52637: LD_INT 4
52639: PUSH
52640: LD_INT 5
52642: PUSH
52643: EMPTY
52644: LIST
52645: LIST
52646: LIST
52647: LIST
52648: ST_TO_ADDR
52649: GO 53542
52651: LD_INT 5
52653: DOUBLE
52654: EQUAL
52655: IFTRUE 52659
52657: GO 52685
52659: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
52660: LD_ADDR_VAR 0 3
52664: PUSH
52665: LD_INT 2
52667: PUSH
52668: LD_INT 3
52670: PUSH
52671: LD_INT 4
52673: PUSH
52674: LD_INT 5
52676: PUSH
52677: EMPTY
52678: LIST
52679: LIST
52680: LIST
52681: LIST
52682: ST_TO_ADDR
52683: GO 53542
52685: LD_INT 9
52687: DOUBLE
52688: EQUAL
52689: IFTRUE 52693
52691: GO 52719
52693: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
52694: LD_ADDR_VAR 0 3
52698: PUSH
52699: LD_INT 2
52701: PUSH
52702: LD_INT 3
52704: PUSH
52705: LD_INT 4
52707: PUSH
52708: LD_INT 5
52710: PUSH
52711: EMPTY
52712: LIST
52713: LIST
52714: LIST
52715: LIST
52716: ST_TO_ADDR
52717: GO 53542
52719: LD_INT 7
52721: DOUBLE
52722: EQUAL
52723: IFTRUE 52727
52725: GO 52753
52727: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
52728: LD_ADDR_VAR 0 3
52732: PUSH
52733: LD_INT 2
52735: PUSH
52736: LD_INT 3
52738: PUSH
52739: LD_INT 4
52741: PUSH
52742: LD_INT 5
52744: PUSH
52745: EMPTY
52746: LIST
52747: LIST
52748: LIST
52749: LIST
52750: ST_TO_ADDR
52751: GO 53542
52753: LD_INT 12
52755: DOUBLE
52756: EQUAL
52757: IFTRUE 52761
52759: GO 52787
52761: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
52762: LD_ADDR_VAR 0 3
52766: PUSH
52767: LD_INT 2
52769: PUSH
52770: LD_INT 3
52772: PUSH
52773: LD_INT 4
52775: PUSH
52776: LD_INT 5
52778: PUSH
52779: EMPTY
52780: LIST
52781: LIST
52782: LIST
52783: LIST
52784: ST_TO_ADDR
52785: GO 53542
52787: LD_INT 13
52789: DOUBLE
52790: EQUAL
52791: IFTRUE 52795
52793: GO 52821
52795: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
52796: LD_ADDR_VAR 0 3
52800: PUSH
52801: LD_INT 2
52803: PUSH
52804: LD_INT 3
52806: PUSH
52807: LD_INT 4
52809: PUSH
52810: LD_INT 5
52812: PUSH
52813: EMPTY
52814: LIST
52815: LIST
52816: LIST
52817: LIST
52818: ST_TO_ADDR
52819: GO 53542
52821: LD_INT 14
52823: DOUBLE
52824: EQUAL
52825: IFTRUE 52829
52827: GO 52847
52829: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
52830: LD_ADDR_VAR 0 3
52834: PUSH
52835: LD_INT 4
52837: PUSH
52838: LD_INT 5
52840: PUSH
52841: EMPTY
52842: LIST
52843: LIST
52844: ST_TO_ADDR
52845: GO 53542
52847: LD_INT 6
52849: DOUBLE
52850: EQUAL
52851: IFTRUE 52855
52853: GO 52873
52855: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
52856: LD_ADDR_VAR 0 3
52860: PUSH
52861: LD_INT 4
52863: PUSH
52864: LD_INT 5
52866: PUSH
52867: EMPTY
52868: LIST
52869: LIST
52870: ST_TO_ADDR
52871: GO 53542
52873: LD_INT 10
52875: DOUBLE
52876: EQUAL
52877: IFTRUE 52881
52879: GO 52899
52881: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
52882: LD_ADDR_VAR 0 3
52886: PUSH
52887: LD_INT 4
52889: PUSH
52890: LD_INT 5
52892: PUSH
52893: EMPTY
52894: LIST
52895: LIST
52896: ST_TO_ADDR
52897: GO 53542
52899: LD_INT 22
52901: DOUBLE
52902: EQUAL
52903: IFTRUE 52907
52905: GO 52933
52907: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
52908: LD_ADDR_VAR 0 3
52912: PUSH
52913: LD_INT 11
52915: PUSH
52916: LD_INT 12
52918: PUSH
52919: LD_INT 13
52921: PUSH
52922: LD_INT 14
52924: PUSH
52925: EMPTY
52926: LIST
52927: LIST
52928: LIST
52929: LIST
52930: ST_TO_ADDR
52931: GO 53542
52933: LD_INT 23
52935: DOUBLE
52936: EQUAL
52937: IFTRUE 52941
52939: GO 52967
52941: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
52942: LD_ADDR_VAR 0 3
52946: PUSH
52947: LD_INT 11
52949: PUSH
52950: LD_INT 12
52952: PUSH
52953: LD_INT 13
52955: PUSH
52956: LD_INT 14
52958: PUSH
52959: EMPTY
52960: LIST
52961: LIST
52962: LIST
52963: LIST
52964: ST_TO_ADDR
52965: GO 53542
52967: LD_INT 24
52969: DOUBLE
52970: EQUAL
52971: IFTRUE 52975
52973: GO 53001
52975: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
52976: LD_ADDR_VAR 0 3
52980: PUSH
52981: LD_INT 11
52983: PUSH
52984: LD_INT 12
52986: PUSH
52987: LD_INT 13
52989: PUSH
52990: LD_INT 14
52992: PUSH
52993: EMPTY
52994: LIST
52995: LIST
52996: LIST
52997: LIST
52998: ST_TO_ADDR
52999: GO 53542
53001: LD_INT 30
53003: DOUBLE
53004: EQUAL
53005: IFTRUE 53009
53007: GO 53035
53009: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
53010: LD_ADDR_VAR 0 3
53014: PUSH
53015: LD_INT 11
53017: PUSH
53018: LD_INT 12
53020: PUSH
53021: LD_INT 13
53023: PUSH
53024: LD_INT 14
53026: PUSH
53027: EMPTY
53028: LIST
53029: LIST
53030: LIST
53031: LIST
53032: ST_TO_ADDR
53033: GO 53542
53035: LD_INT 25
53037: DOUBLE
53038: EQUAL
53039: IFTRUE 53043
53041: GO 53061
53043: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
53044: LD_ADDR_VAR 0 3
53048: PUSH
53049: LD_INT 13
53051: PUSH
53052: LD_INT 14
53054: PUSH
53055: EMPTY
53056: LIST
53057: LIST
53058: ST_TO_ADDR
53059: GO 53542
53061: LD_INT 27
53063: DOUBLE
53064: EQUAL
53065: IFTRUE 53069
53067: GO 53087
53069: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
53070: LD_ADDR_VAR 0 3
53074: PUSH
53075: LD_INT 13
53077: PUSH
53078: LD_INT 14
53080: PUSH
53081: EMPTY
53082: LIST
53083: LIST
53084: ST_TO_ADDR
53085: GO 53542
53087: LD_INT 92
53089: DOUBLE
53090: EQUAL
53091: IFTRUE 53095
53093: GO 53121
53095: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
53096: LD_ADDR_VAR 0 3
53100: PUSH
53101: LD_INT 11
53103: PUSH
53104: LD_INT 12
53106: PUSH
53107: LD_INT 13
53109: PUSH
53110: LD_INT 14
53112: PUSH
53113: EMPTY
53114: LIST
53115: LIST
53116: LIST
53117: LIST
53118: ST_TO_ADDR
53119: GO 53542
53121: LD_INT 28
53123: DOUBLE
53124: EQUAL
53125: IFTRUE 53129
53127: GO 53147
53129: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
53130: LD_ADDR_VAR 0 3
53134: PUSH
53135: LD_INT 13
53137: PUSH
53138: LD_INT 14
53140: PUSH
53141: EMPTY
53142: LIST
53143: LIST
53144: ST_TO_ADDR
53145: GO 53542
53147: LD_INT 29
53149: DOUBLE
53150: EQUAL
53151: IFTRUE 53155
53153: GO 53173
53155: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
53156: LD_ADDR_VAR 0 3
53160: PUSH
53161: LD_INT 13
53163: PUSH
53164: LD_INT 14
53166: PUSH
53167: EMPTY
53168: LIST
53169: LIST
53170: ST_TO_ADDR
53171: GO 53542
53173: LD_INT 31
53175: DOUBLE
53176: EQUAL
53177: IFTRUE 53181
53179: GO 53199
53181: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
53182: LD_ADDR_VAR 0 3
53186: PUSH
53187: LD_INT 13
53189: PUSH
53190: LD_INT 14
53192: PUSH
53193: EMPTY
53194: LIST
53195: LIST
53196: ST_TO_ADDR
53197: GO 53542
53199: LD_INT 26
53201: DOUBLE
53202: EQUAL
53203: IFTRUE 53207
53205: GO 53225
53207: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
53208: LD_ADDR_VAR 0 3
53212: PUSH
53213: LD_INT 13
53215: PUSH
53216: LD_INT 14
53218: PUSH
53219: EMPTY
53220: LIST
53221: LIST
53222: ST_TO_ADDR
53223: GO 53542
53225: LD_INT 42
53227: DOUBLE
53228: EQUAL
53229: IFTRUE 53233
53231: GO 53259
53233: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
53234: LD_ADDR_VAR 0 3
53238: PUSH
53239: LD_INT 21
53241: PUSH
53242: LD_INT 22
53244: PUSH
53245: LD_INT 23
53247: PUSH
53248: LD_INT 24
53250: PUSH
53251: EMPTY
53252: LIST
53253: LIST
53254: LIST
53255: LIST
53256: ST_TO_ADDR
53257: GO 53542
53259: LD_INT 43
53261: DOUBLE
53262: EQUAL
53263: IFTRUE 53267
53265: GO 53293
53267: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
53268: LD_ADDR_VAR 0 3
53272: PUSH
53273: LD_INT 21
53275: PUSH
53276: LD_INT 22
53278: PUSH
53279: LD_INT 23
53281: PUSH
53282: LD_INT 24
53284: PUSH
53285: EMPTY
53286: LIST
53287: LIST
53288: LIST
53289: LIST
53290: ST_TO_ADDR
53291: GO 53542
53293: LD_INT 44
53295: DOUBLE
53296: EQUAL
53297: IFTRUE 53301
53299: GO 53327
53301: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
53302: LD_ADDR_VAR 0 3
53306: PUSH
53307: LD_INT 21
53309: PUSH
53310: LD_INT 22
53312: PUSH
53313: LD_INT 23
53315: PUSH
53316: LD_INT 24
53318: PUSH
53319: EMPTY
53320: LIST
53321: LIST
53322: LIST
53323: LIST
53324: ST_TO_ADDR
53325: GO 53542
53327: LD_INT 45
53329: DOUBLE
53330: EQUAL
53331: IFTRUE 53335
53333: GO 53361
53335: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
53336: LD_ADDR_VAR 0 3
53340: PUSH
53341: LD_INT 21
53343: PUSH
53344: LD_INT 22
53346: PUSH
53347: LD_INT 23
53349: PUSH
53350: LD_INT 24
53352: PUSH
53353: EMPTY
53354: LIST
53355: LIST
53356: LIST
53357: LIST
53358: ST_TO_ADDR
53359: GO 53542
53361: LD_INT 49
53363: DOUBLE
53364: EQUAL
53365: IFTRUE 53369
53367: GO 53395
53369: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
53370: LD_ADDR_VAR 0 3
53374: PUSH
53375: LD_INT 21
53377: PUSH
53378: LD_INT 22
53380: PUSH
53381: LD_INT 23
53383: PUSH
53384: LD_INT 24
53386: PUSH
53387: EMPTY
53388: LIST
53389: LIST
53390: LIST
53391: LIST
53392: ST_TO_ADDR
53393: GO 53542
53395: LD_INT 51
53397: DOUBLE
53398: EQUAL
53399: IFTRUE 53403
53401: GO 53429
53403: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
53404: LD_ADDR_VAR 0 3
53408: PUSH
53409: LD_INT 21
53411: PUSH
53412: LD_INT 22
53414: PUSH
53415: LD_INT 23
53417: PUSH
53418: LD_INT 24
53420: PUSH
53421: EMPTY
53422: LIST
53423: LIST
53424: LIST
53425: LIST
53426: ST_TO_ADDR
53427: GO 53542
53429: LD_INT 52
53431: DOUBLE
53432: EQUAL
53433: IFTRUE 53437
53435: GO 53463
53437: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
53438: LD_ADDR_VAR 0 3
53442: PUSH
53443: LD_INT 21
53445: PUSH
53446: LD_INT 22
53448: PUSH
53449: LD_INT 23
53451: PUSH
53452: LD_INT 24
53454: PUSH
53455: EMPTY
53456: LIST
53457: LIST
53458: LIST
53459: LIST
53460: ST_TO_ADDR
53461: GO 53542
53463: LD_INT 53
53465: DOUBLE
53466: EQUAL
53467: IFTRUE 53471
53469: GO 53489
53471: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
53472: LD_ADDR_VAR 0 3
53476: PUSH
53477: LD_INT 23
53479: PUSH
53480: LD_INT 24
53482: PUSH
53483: EMPTY
53484: LIST
53485: LIST
53486: ST_TO_ADDR
53487: GO 53542
53489: LD_INT 46
53491: DOUBLE
53492: EQUAL
53493: IFTRUE 53497
53495: GO 53515
53497: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
53498: LD_ADDR_VAR 0 3
53502: PUSH
53503: LD_INT 23
53505: PUSH
53506: LD_INT 24
53508: PUSH
53509: EMPTY
53510: LIST
53511: LIST
53512: ST_TO_ADDR
53513: GO 53542
53515: LD_INT 47
53517: DOUBLE
53518: EQUAL
53519: IFTRUE 53523
53521: GO 53541
53523: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
53524: LD_ADDR_VAR 0 3
53528: PUSH
53529: LD_INT 23
53531: PUSH
53532: LD_INT 24
53534: PUSH
53535: EMPTY
53536: LIST
53537: LIST
53538: ST_TO_ADDR
53539: GO 53542
53541: POP
// result := ( chassis in result ) ;
53542: LD_ADDR_VAR 0 3
53546: PUSH
53547: LD_VAR 0 1
53551: PUSH
53552: LD_VAR 0 3
53556: IN
53557: ST_TO_ADDR
// end ;
53558: LD_VAR 0 3
53562: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
53563: LD_INT 0
53565: PPUSH
53566: PPUSH
53567: PPUSH
53568: PPUSH
53569: PPUSH
53570: PPUSH
53571: PPUSH
// result := array ;
53572: LD_ADDR_VAR 0 5
53576: PUSH
53577: LD_VAR 0 1
53581: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
53582: LD_VAR 0 1
53586: NOT
53587: PUSH
53588: LD_VAR 0 2
53592: NOT
53593: OR
53594: PUSH
53595: LD_VAR 0 3
53599: NOT
53600: OR
53601: PUSH
53602: LD_VAR 0 2
53606: PUSH
53607: LD_VAR 0 1
53611: GREATER
53612: OR
53613: PUSH
53614: LD_VAR 0 3
53618: PUSH
53619: LD_VAR 0 1
53623: GREATER
53624: OR
53625: IFFALSE 53629
// exit ;
53627: GO 53925
// if direction then
53629: LD_VAR 0 4
53633: IFFALSE 53697
// begin d := 1 ;
53635: LD_ADDR_VAR 0 9
53639: PUSH
53640: LD_INT 1
53642: ST_TO_ADDR
// if i_from > i_to then
53643: LD_VAR 0 2
53647: PUSH
53648: LD_VAR 0 3
53652: GREATER
53653: IFFALSE 53679
// length := ( array - i_from ) + i_to else
53655: LD_ADDR_VAR 0 11
53659: PUSH
53660: LD_VAR 0 1
53664: PUSH
53665: LD_VAR 0 2
53669: MINUS
53670: PUSH
53671: LD_VAR 0 3
53675: PLUS
53676: ST_TO_ADDR
53677: GO 53695
// length := i_to - i_from ;
53679: LD_ADDR_VAR 0 11
53683: PUSH
53684: LD_VAR 0 3
53688: PUSH
53689: LD_VAR 0 2
53693: MINUS
53694: ST_TO_ADDR
// end else
53695: GO 53758
// begin d := - 1 ;
53697: LD_ADDR_VAR 0 9
53701: PUSH
53702: LD_INT 1
53704: NEG
53705: ST_TO_ADDR
// if i_from > i_to then
53706: LD_VAR 0 2
53710: PUSH
53711: LD_VAR 0 3
53715: GREATER
53716: IFFALSE 53736
// length := i_from - i_to else
53718: LD_ADDR_VAR 0 11
53722: PUSH
53723: LD_VAR 0 2
53727: PUSH
53728: LD_VAR 0 3
53732: MINUS
53733: ST_TO_ADDR
53734: GO 53758
// length := ( array - i_to ) + i_from ;
53736: LD_ADDR_VAR 0 11
53740: PUSH
53741: LD_VAR 0 1
53745: PUSH
53746: LD_VAR 0 3
53750: MINUS
53751: PUSH
53752: LD_VAR 0 2
53756: PLUS
53757: ST_TO_ADDR
// end ; if not length then
53758: LD_VAR 0 11
53762: NOT
53763: IFFALSE 53767
// exit ;
53765: GO 53925
// tmp := array ;
53767: LD_ADDR_VAR 0 10
53771: PUSH
53772: LD_VAR 0 1
53776: ST_TO_ADDR
// for i = 1 to length do
53777: LD_ADDR_VAR 0 6
53781: PUSH
53782: DOUBLE
53783: LD_INT 1
53785: DEC
53786: ST_TO_ADDR
53787: LD_VAR 0 11
53791: PUSH
53792: FOR_TO
53793: IFFALSE 53913
// begin for j = 1 to array do
53795: LD_ADDR_VAR 0 7
53799: PUSH
53800: DOUBLE
53801: LD_INT 1
53803: DEC
53804: ST_TO_ADDR
53805: LD_VAR 0 1
53809: PUSH
53810: FOR_TO
53811: IFFALSE 53899
// begin k := j + d ;
53813: LD_ADDR_VAR 0 8
53817: PUSH
53818: LD_VAR 0 7
53822: PUSH
53823: LD_VAR 0 9
53827: PLUS
53828: ST_TO_ADDR
// if k > array then
53829: LD_VAR 0 8
53833: PUSH
53834: LD_VAR 0 1
53838: GREATER
53839: IFFALSE 53849
// k := 1 ;
53841: LD_ADDR_VAR 0 8
53845: PUSH
53846: LD_INT 1
53848: ST_TO_ADDR
// if not k then
53849: LD_VAR 0 8
53853: NOT
53854: IFFALSE 53866
// k := array ;
53856: LD_ADDR_VAR 0 8
53860: PUSH
53861: LD_VAR 0 1
53865: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
53866: LD_ADDR_VAR 0 10
53870: PUSH
53871: LD_VAR 0 10
53875: PPUSH
53876: LD_VAR 0 8
53880: PPUSH
53881: LD_VAR 0 1
53885: PUSH
53886: LD_VAR 0 7
53890: ARRAY
53891: PPUSH
53892: CALL_OW 1
53896: ST_TO_ADDR
// end ;
53897: GO 53810
53899: POP
53900: POP
// array := tmp ;
53901: LD_ADDR_VAR 0 1
53905: PUSH
53906: LD_VAR 0 10
53910: ST_TO_ADDR
// end ;
53911: GO 53792
53913: POP
53914: POP
// result := array ;
53915: LD_ADDR_VAR 0 5
53919: PUSH
53920: LD_VAR 0 1
53924: ST_TO_ADDR
// end ;
53925: LD_VAR 0 5
53929: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
53930: LD_INT 0
53932: PPUSH
53933: PPUSH
// result := 0 ;
53934: LD_ADDR_VAR 0 3
53938: PUSH
53939: LD_INT 0
53941: ST_TO_ADDR
// if not array or not value in array then
53942: LD_VAR 0 1
53946: NOT
53947: PUSH
53948: LD_VAR 0 2
53952: PUSH
53953: LD_VAR 0 1
53957: IN
53958: NOT
53959: OR
53960: IFFALSE 53964
// exit ;
53962: GO 54018
// for i = 1 to array do
53964: LD_ADDR_VAR 0 4
53968: PUSH
53969: DOUBLE
53970: LD_INT 1
53972: DEC
53973: ST_TO_ADDR
53974: LD_VAR 0 1
53978: PUSH
53979: FOR_TO
53980: IFFALSE 54016
// if value = array [ i ] then
53982: LD_VAR 0 2
53986: PUSH
53987: LD_VAR 0 1
53991: PUSH
53992: LD_VAR 0 4
53996: ARRAY
53997: EQUAL
53998: IFFALSE 54014
// begin result := i ;
54000: LD_ADDR_VAR 0 3
54004: PUSH
54005: LD_VAR 0 4
54009: ST_TO_ADDR
// exit ;
54010: POP
54011: POP
54012: GO 54018
// end ;
54014: GO 53979
54016: POP
54017: POP
// end ;
54018: LD_VAR 0 3
54022: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
54023: LD_INT 0
54025: PPUSH
// vc_chassis := chassis ;
54026: LD_ADDR_OWVAR 37
54030: PUSH
54031: LD_VAR 0 1
54035: ST_TO_ADDR
// vc_engine := engine ;
54036: LD_ADDR_OWVAR 39
54040: PUSH
54041: LD_VAR 0 2
54045: ST_TO_ADDR
// vc_control := control ;
54046: LD_ADDR_OWVAR 38
54050: PUSH
54051: LD_VAR 0 3
54055: ST_TO_ADDR
// vc_weapon := weapon ;
54056: LD_ADDR_OWVAR 40
54060: PUSH
54061: LD_VAR 0 4
54065: ST_TO_ADDR
// vc_fuel_battery := fuel ;
54066: LD_ADDR_OWVAR 41
54070: PUSH
54071: LD_VAR 0 5
54075: ST_TO_ADDR
// end ;
54076: LD_VAR 0 6
54080: RET
// export function WantPlant ( unit ) ; var task ; begin
54081: LD_INT 0
54083: PPUSH
54084: PPUSH
// result := false ;
54085: LD_ADDR_VAR 0 2
54089: PUSH
54090: LD_INT 0
54092: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
54093: LD_ADDR_VAR 0 3
54097: PUSH
54098: LD_VAR 0 1
54102: PPUSH
54103: CALL_OW 437
54107: ST_TO_ADDR
// if task then
54108: LD_VAR 0 3
54112: IFFALSE 54140
// if task [ 1 ] [ 1 ] = p then
54114: LD_VAR 0 3
54118: PUSH
54119: LD_INT 1
54121: ARRAY
54122: PUSH
54123: LD_INT 1
54125: ARRAY
54126: PUSH
54127: LD_STRING p
54129: EQUAL
54130: IFFALSE 54140
// result := true ;
54132: LD_ADDR_VAR 0 2
54136: PUSH
54137: LD_INT 1
54139: ST_TO_ADDR
// end ;
54140: LD_VAR 0 2
54144: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
54145: LD_INT 0
54147: PPUSH
54148: PPUSH
54149: PPUSH
54150: PPUSH
// if pos < 1 then
54151: LD_VAR 0 2
54155: PUSH
54156: LD_INT 1
54158: LESS
54159: IFFALSE 54163
// exit ;
54161: GO 54466
// if pos = 1 then
54163: LD_VAR 0 2
54167: PUSH
54168: LD_INT 1
54170: EQUAL
54171: IFFALSE 54204
// result := Replace ( arr , pos [ 1 ] , value ) else
54173: LD_ADDR_VAR 0 4
54177: PUSH
54178: LD_VAR 0 1
54182: PPUSH
54183: LD_VAR 0 2
54187: PUSH
54188: LD_INT 1
54190: ARRAY
54191: PPUSH
54192: LD_VAR 0 3
54196: PPUSH
54197: CALL_OW 1
54201: ST_TO_ADDR
54202: GO 54466
// begin tmp := arr ;
54204: LD_ADDR_VAR 0 6
54208: PUSH
54209: LD_VAR 0 1
54213: ST_TO_ADDR
// s_arr := [ tmp ] ;
54214: LD_ADDR_VAR 0 7
54218: PUSH
54219: LD_VAR 0 6
54223: PUSH
54224: EMPTY
54225: LIST
54226: ST_TO_ADDR
// for i = 1 to pos - 1 do
54227: LD_ADDR_VAR 0 5
54231: PUSH
54232: DOUBLE
54233: LD_INT 1
54235: DEC
54236: ST_TO_ADDR
54237: LD_VAR 0 2
54241: PUSH
54242: LD_INT 1
54244: MINUS
54245: PUSH
54246: FOR_TO
54247: IFFALSE 54292
// begin tmp := tmp [ pos [ i ] ] ;
54249: LD_ADDR_VAR 0 6
54253: PUSH
54254: LD_VAR 0 6
54258: PUSH
54259: LD_VAR 0 2
54263: PUSH
54264: LD_VAR 0 5
54268: ARRAY
54269: ARRAY
54270: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
54271: LD_ADDR_VAR 0 7
54275: PUSH
54276: LD_VAR 0 7
54280: PUSH
54281: LD_VAR 0 6
54285: PUSH
54286: EMPTY
54287: LIST
54288: ADD
54289: ST_TO_ADDR
// end ;
54290: GO 54246
54292: POP
54293: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
54294: LD_ADDR_VAR 0 6
54298: PUSH
54299: LD_VAR 0 6
54303: PPUSH
54304: LD_VAR 0 2
54308: PUSH
54309: LD_VAR 0 2
54313: ARRAY
54314: PPUSH
54315: LD_VAR 0 3
54319: PPUSH
54320: CALL_OW 1
54324: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
54325: LD_ADDR_VAR 0 7
54329: PUSH
54330: LD_VAR 0 7
54334: PPUSH
54335: LD_VAR 0 7
54339: PPUSH
54340: LD_VAR 0 6
54344: PPUSH
54345: CALL_OW 1
54349: ST_TO_ADDR
// for i = s_arr downto 2 do
54350: LD_ADDR_VAR 0 5
54354: PUSH
54355: DOUBLE
54356: LD_VAR 0 7
54360: INC
54361: ST_TO_ADDR
54362: LD_INT 2
54364: PUSH
54365: FOR_DOWNTO
54366: IFFALSE 54450
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
54368: LD_ADDR_VAR 0 6
54372: PUSH
54373: LD_VAR 0 7
54377: PUSH
54378: LD_VAR 0 5
54382: PUSH
54383: LD_INT 1
54385: MINUS
54386: ARRAY
54387: PPUSH
54388: LD_VAR 0 2
54392: PUSH
54393: LD_VAR 0 5
54397: PUSH
54398: LD_INT 1
54400: MINUS
54401: ARRAY
54402: PPUSH
54403: LD_VAR 0 7
54407: PUSH
54408: LD_VAR 0 5
54412: ARRAY
54413: PPUSH
54414: CALL_OW 1
54418: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
54419: LD_ADDR_VAR 0 7
54423: PUSH
54424: LD_VAR 0 7
54428: PPUSH
54429: LD_VAR 0 5
54433: PUSH
54434: LD_INT 1
54436: MINUS
54437: PPUSH
54438: LD_VAR 0 6
54442: PPUSH
54443: CALL_OW 1
54447: ST_TO_ADDR
// end ;
54448: GO 54365
54450: POP
54451: POP
// result := s_arr [ 1 ] ;
54452: LD_ADDR_VAR 0 4
54456: PUSH
54457: LD_VAR 0 7
54461: PUSH
54462: LD_INT 1
54464: ARRAY
54465: ST_TO_ADDR
// end ; end ;
54466: LD_VAR 0 4
54470: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
54471: LD_INT 0
54473: PPUSH
54474: PPUSH
// if not list then
54475: LD_VAR 0 1
54479: NOT
54480: IFFALSE 54484
// exit ;
54482: GO 54575
// i := list [ pos1 ] ;
54484: LD_ADDR_VAR 0 5
54488: PUSH
54489: LD_VAR 0 1
54493: PUSH
54494: LD_VAR 0 2
54498: ARRAY
54499: ST_TO_ADDR
// if not i then
54500: LD_VAR 0 5
54504: NOT
54505: IFFALSE 54509
// exit ;
54507: GO 54575
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
54509: LD_ADDR_VAR 0 1
54513: PUSH
54514: LD_VAR 0 1
54518: PPUSH
54519: LD_VAR 0 2
54523: PPUSH
54524: LD_VAR 0 1
54528: PUSH
54529: LD_VAR 0 3
54533: ARRAY
54534: PPUSH
54535: CALL_OW 1
54539: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
54540: LD_ADDR_VAR 0 1
54544: PUSH
54545: LD_VAR 0 1
54549: PPUSH
54550: LD_VAR 0 3
54554: PPUSH
54555: LD_VAR 0 5
54559: PPUSH
54560: CALL_OW 1
54564: ST_TO_ADDR
// result := list ;
54565: LD_ADDR_VAR 0 4
54569: PUSH
54570: LD_VAR 0 1
54574: ST_TO_ADDR
// end ;
54575: LD_VAR 0 4
54579: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
54580: LD_INT 0
54582: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
54583: LD_ADDR_VAR 0 5
54587: PUSH
54588: LD_VAR 0 1
54592: PPUSH
54593: CALL_OW 250
54597: PPUSH
54598: LD_VAR 0 1
54602: PPUSH
54603: CALL_OW 251
54607: PPUSH
54608: LD_VAR 0 2
54612: PPUSH
54613: LD_VAR 0 3
54617: PPUSH
54618: LD_VAR 0 4
54622: PPUSH
54623: CALL 55001 0 5
54627: ST_TO_ADDR
// end ;
54628: LD_VAR 0 5
54632: RET
// export function SortHexesByDistanceFromUnit ( unit , list , asc , mode ) ; var i , j , tmp ; begin
54633: LD_INT 0
54635: PPUSH
54636: PPUSH
54637: PPUSH
54638: PPUSH
// if not list or not unit then
54639: LD_VAR 0 2
54643: NOT
54644: PUSH
54645: LD_VAR 0 1
54649: NOT
54650: OR
54651: IFFALSE 54655
// exit ;
54653: GO 54996
// result := [ ] ;
54655: LD_ADDR_VAR 0 5
54659: PUSH
54660: EMPTY
54661: ST_TO_ADDR
// for i in list do
54662: LD_ADDR_VAR 0 6
54666: PUSH
54667: LD_VAR 0 2
54671: PUSH
54672: FOR_IN
54673: IFFALSE 54891
// begin tmp := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
54675: LD_ADDR_VAR 0 8
54679: PUSH
54680: LD_VAR 0 1
54684: PPUSH
54685: LD_VAR 0 6
54689: PUSH
54690: LD_INT 1
54692: ARRAY
54693: PPUSH
54694: LD_VAR 0 6
54698: PUSH
54699: LD_INT 2
54701: ARRAY
54702: PPUSH
54703: CALL_OW 297
54707: ST_TO_ADDR
// if not Count ( result ) then
54708: LD_VAR 0 5
54712: PPUSH
54713: CALL 51285 0 1
54717: NOT
54718: IFFALSE 54751
// begin result := Join ( result , [ i , tmp ] ) ;
54720: LD_ADDR_VAR 0 5
54724: PUSH
54725: LD_VAR 0 5
54729: PPUSH
54730: LD_VAR 0 6
54734: PUSH
54735: LD_VAR 0 8
54739: PUSH
54740: EMPTY
54741: LIST
54742: LIST
54743: PPUSH
54744: CALL 86874 0 2
54748: ST_TO_ADDR
// continue ;
54749: GO 54672
// end ; if result [ result ] [ 2 ] <= tmp then
54751: LD_VAR 0 5
54755: PUSH
54756: LD_VAR 0 5
54760: ARRAY
54761: PUSH
54762: LD_INT 2
54764: ARRAY
54765: PUSH
54766: LD_VAR 0 8
54770: LESSEQUAL
54771: IFFALSE 54804
// result := Join ( result , [ i , tmp ] ) else
54773: LD_ADDR_VAR 0 5
54777: PUSH
54778: LD_VAR 0 5
54782: PPUSH
54783: LD_VAR 0 6
54787: PUSH
54788: LD_VAR 0 8
54792: PUSH
54793: EMPTY
54794: LIST
54795: LIST
54796: PPUSH
54797: CALL 86874 0 2
54801: ST_TO_ADDR
54802: GO 54889
// begin for j := 1 to Count ( result ) do
54804: LD_ADDR_VAR 0 7
54808: PUSH
54809: DOUBLE
54810: LD_INT 1
54812: DEC
54813: ST_TO_ADDR
54814: LD_VAR 0 5
54818: PPUSH
54819: CALL 51285 0 1
54823: PUSH
54824: FOR_TO
54825: IFFALSE 54887
// begin if tmp < result [ j ] [ 2 ] then
54827: LD_VAR 0 8
54831: PUSH
54832: LD_VAR 0 5
54836: PUSH
54837: LD_VAR 0 7
54841: ARRAY
54842: PUSH
54843: LD_INT 2
54845: ARRAY
54846: LESS
54847: IFFALSE 54885
// begin result := Insert ( result , j , [ i , tmp ] ) ;
54849: LD_ADDR_VAR 0 5
54853: PUSH
54854: LD_VAR 0 5
54858: PPUSH
54859: LD_VAR 0 7
54863: PPUSH
54864: LD_VAR 0 6
54868: PUSH
54869: LD_VAR 0 8
54873: PUSH
54874: EMPTY
54875: LIST
54876: LIST
54877: PPUSH
54878: CALL_OW 2
54882: ST_TO_ADDR
// break ;
54883: GO 54887
// end ; end ;
54885: GO 54824
54887: POP
54888: POP
// end ; end ;
54889: GO 54672
54891: POP
54892: POP
// if result and not asc then
54893: LD_VAR 0 5
54897: PUSH
54898: LD_VAR 0 3
54902: NOT
54903: AND
54904: IFFALSE 54921
// result := ReverseArray ( result ) ;
54906: LD_ADDR_VAR 0 5
54910: PUSH
54911: LD_VAR 0 5
54915: PPUSH
54916: CALL 82161 0 1
54920: ST_TO_ADDR
// tmp := [ ] ;
54921: LD_ADDR_VAR 0 8
54925: PUSH
54926: EMPTY
54927: ST_TO_ADDR
// if mode then
54928: LD_VAR 0 4
54932: IFFALSE 54996
// begin for i := 1 to result do
54934: LD_ADDR_VAR 0 6
54938: PUSH
54939: DOUBLE
54940: LD_INT 1
54942: DEC
54943: ST_TO_ADDR
54944: LD_VAR 0 5
54948: PUSH
54949: FOR_TO
54950: IFFALSE 54984
// tmp := Join ( tmp , result [ i ] [ 1 ] ) ;
54952: LD_ADDR_VAR 0 8
54956: PUSH
54957: LD_VAR 0 8
54961: PPUSH
54962: LD_VAR 0 5
54966: PUSH
54967: LD_VAR 0 6
54971: ARRAY
54972: PUSH
54973: LD_INT 1
54975: ARRAY
54976: PPUSH
54977: CALL 86874 0 2
54981: ST_TO_ADDR
54982: GO 54949
54984: POP
54985: POP
// result := tmp ;
54986: LD_ADDR_VAR 0 5
54990: PUSH
54991: LD_VAR 0 8
54995: ST_TO_ADDR
// end ; end ;
54996: LD_VAR 0 5
55000: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
55001: LD_INT 0
55003: PPUSH
55004: PPUSH
55005: PPUSH
55006: PPUSH
// if not list then
55007: LD_VAR 0 3
55011: NOT
55012: IFFALSE 55016
// exit ;
55014: GO 55404
// result := [ ] ;
55016: LD_ADDR_VAR 0 6
55020: PUSH
55021: EMPTY
55022: ST_TO_ADDR
// for i in list do
55023: LD_ADDR_VAR 0 7
55027: PUSH
55028: LD_VAR 0 3
55032: PUSH
55033: FOR_IN
55034: IFFALSE 55236
// begin tmp := GetDistUnitXY ( i , x , y ) ;
55036: LD_ADDR_VAR 0 9
55040: PUSH
55041: LD_VAR 0 7
55045: PPUSH
55046: LD_VAR 0 1
55050: PPUSH
55051: LD_VAR 0 2
55055: PPUSH
55056: CALL_OW 297
55060: ST_TO_ADDR
// if not result then
55061: LD_VAR 0 6
55065: NOT
55066: IFFALSE 55092
// result := [ [ i , tmp ] ] else
55068: LD_ADDR_VAR 0 6
55072: PUSH
55073: LD_VAR 0 7
55077: PUSH
55078: LD_VAR 0 9
55082: PUSH
55083: EMPTY
55084: LIST
55085: LIST
55086: PUSH
55087: EMPTY
55088: LIST
55089: ST_TO_ADDR
55090: GO 55234
// begin if result [ result ] [ 2 ] < tmp then
55092: LD_VAR 0 6
55096: PUSH
55097: LD_VAR 0 6
55101: ARRAY
55102: PUSH
55103: LD_INT 2
55105: ARRAY
55106: PUSH
55107: LD_VAR 0 9
55111: LESS
55112: IFFALSE 55154
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
55114: LD_ADDR_VAR 0 6
55118: PUSH
55119: LD_VAR 0 6
55123: PPUSH
55124: LD_VAR 0 6
55128: PUSH
55129: LD_INT 1
55131: PLUS
55132: PPUSH
55133: LD_VAR 0 7
55137: PUSH
55138: LD_VAR 0 9
55142: PUSH
55143: EMPTY
55144: LIST
55145: LIST
55146: PPUSH
55147: CALL_OW 2
55151: ST_TO_ADDR
55152: GO 55234
// for j = 1 to result do
55154: LD_ADDR_VAR 0 8
55158: PUSH
55159: DOUBLE
55160: LD_INT 1
55162: DEC
55163: ST_TO_ADDR
55164: LD_VAR 0 6
55168: PUSH
55169: FOR_TO
55170: IFFALSE 55232
// begin if tmp < result [ j ] [ 2 ] then
55172: LD_VAR 0 9
55176: PUSH
55177: LD_VAR 0 6
55181: PUSH
55182: LD_VAR 0 8
55186: ARRAY
55187: PUSH
55188: LD_INT 2
55190: ARRAY
55191: LESS
55192: IFFALSE 55230
// begin result := Insert ( result , j , [ i , tmp ] ) ;
55194: LD_ADDR_VAR 0 6
55198: PUSH
55199: LD_VAR 0 6
55203: PPUSH
55204: LD_VAR 0 8
55208: PPUSH
55209: LD_VAR 0 7
55213: PUSH
55214: LD_VAR 0 9
55218: PUSH
55219: EMPTY
55220: LIST
55221: LIST
55222: PPUSH
55223: CALL_OW 2
55227: ST_TO_ADDR
// break ;
55228: GO 55232
// end ; end ;
55230: GO 55169
55232: POP
55233: POP
// end ; end ;
55234: GO 55033
55236: POP
55237: POP
// if result and not asc then
55238: LD_VAR 0 6
55242: PUSH
55243: LD_VAR 0 4
55247: NOT
55248: AND
55249: IFFALSE 55324
// begin tmp := result ;
55251: LD_ADDR_VAR 0 9
55255: PUSH
55256: LD_VAR 0 6
55260: ST_TO_ADDR
// for i = tmp downto 1 do
55261: LD_ADDR_VAR 0 7
55265: PUSH
55266: DOUBLE
55267: LD_VAR 0 9
55271: INC
55272: ST_TO_ADDR
55273: LD_INT 1
55275: PUSH
55276: FOR_DOWNTO
55277: IFFALSE 55322
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
55279: LD_ADDR_VAR 0 6
55283: PUSH
55284: LD_VAR 0 6
55288: PPUSH
55289: LD_VAR 0 9
55293: PUSH
55294: LD_VAR 0 7
55298: MINUS
55299: PUSH
55300: LD_INT 1
55302: PLUS
55303: PPUSH
55304: LD_VAR 0 9
55308: PUSH
55309: LD_VAR 0 7
55313: ARRAY
55314: PPUSH
55315: CALL_OW 1
55319: ST_TO_ADDR
55320: GO 55276
55322: POP
55323: POP
// end ; tmp := [ ] ;
55324: LD_ADDR_VAR 0 9
55328: PUSH
55329: EMPTY
55330: ST_TO_ADDR
// if mode then
55331: LD_VAR 0 5
55335: IFFALSE 55404
// begin for i = 1 to result do
55337: LD_ADDR_VAR 0 7
55341: PUSH
55342: DOUBLE
55343: LD_INT 1
55345: DEC
55346: ST_TO_ADDR
55347: LD_VAR 0 6
55351: PUSH
55352: FOR_TO
55353: IFFALSE 55392
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
55355: LD_ADDR_VAR 0 9
55359: PUSH
55360: LD_VAR 0 9
55364: PPUSH
55365: LD_VAR 0 7
55369: PPUSH
55370: LD_VAR 0 6
55374: PUSH
55375: LD_VAR 0 7
55379: ARRAY
55380: PUSH
55381: LD_INT 1
55383: ARRAY
55384: PPUSH
55385: CALL_OW 1
55389: ST_TO_ADDR
55390: GO 55352
55392: POP
55393: POP
// result := tmp ;
55394: LD_ADDR_VAR 0 6
55398: PUSH
55399: LD_VAR 0 9
55403: ST_TO_ADDR
// end ; end ;
55404: LD_VAR 0 6
55408: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
55409: LD_INT 0
55411: PPUSH
55412: PPUSH
55413: PPUSH
55414: PPUSH
55415: PPUSH
55416: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
55417: LD_ADDR_VAR 0 5
55421: PUSH
55422: LD_INT 0
55424: PUSH
55425: LD_INT 0
55427: PUSH
55428: LD_INT 0
55430: PUSH
55431: EMPTY
55432: PUSH
55433: EMPTY
55434: LIST
55435: LIST
55436: LIST
55437: LIST
55438: ST_TO_ADDR
// if not x or not y then
55439: LD_VAR 0 2
55443: NOT
55444: PUSH
55445: LD_VAR 0 3
55449: NOT
55450: OR
55451: IFFALSE 55455
// exit ;
55453: GO 57105
// if not range then
55455: LD_VAR 0 4
55459: NOT
55460: IFFALSE 55470
// range := 10 ;
55462: LD_ADDR_VAR 0 4
55466: PUSH
55467: LD_INT 10
55469: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
55470: LD_ADDR_VAR 0 8
55474: PUSH
55475: LD_INT 81
55477: PUSH
55478: LD_VAR 0 1
55482: PUSH
55483: EMPTY
55484: LIST
55485: LIST
55486: PUSH
55487: LD_INT 92
55489: PUSH
55490: LD_VAR 0 2
55494: PUSH
55495: LD_VAR 0 3
55499: PUSH
55500: LD_VAR 0 4
55504: PUSH
55505: EMPTY
55506: LIST
55507: LIST
55508: LIST
55509: LIST
55510: PUSH
55511: LD_INT 3
55513: PUSH
55514: LD_INT 21
55516: PUSH
55517: LD_INT 3
55519: PUSH
55520: EMPTY
55521: LIST
55522: LIST
55523: PUSH
55524: EMPTY
55525: LIST
55526: LIST
55527: PUSH
55528: EMPTY
55529: LIST
55530: LIST
55531: LIST
55532: PPUSH
55533: CALL_OW 69
55537: ST_TO_ADDR
// if not tmp then
55538: LD_VAR 0 8
55542: NOT
55543: IFFALSE 55547
// exit ;
55545: GO 57105
// for i in tmp do
55547: LD_ADDR_VAR 0 6
55551: PUSH
55552: LD_VAR 0 8
55556: PUSH
55557: FOR_IN
55558: IFFALSE 57080
// begin points := [ 0 , 0 , 0 ] ;
55560: LD_ADDR_VAR 0 9
55564: PUSH
55565: LD_INT 0
55567: PUSH
55568: LD_INT 0
55570: PUSH
55571: LD_INT 0
55573: PUSH
55574: EMPTY
55575: LIST
55576: LIST
55577: LIST
55578: ST_TO_ADDR
// bpoints := 1 ;
55579: LD_ADDR_VAR 0 10
55583: PUSH
55584: LD_INT 1
55586: ST_TO_ADDR
// case GetType ( i ) of unit_human :
55587: LD_VAR 0 6
55591: PPUSH
55592: CALL_OW 247
55596: PUSH
55597: LD_INT 1
55599: DOUBLE
55600: EQUAL
55601: IFTRUE 55605
55603: GO 56183
55605: POP
// begin if GetClass ( i ) = 1 then
55606: LD_VAR 0 6
55610: PPUSH
55611: CALL_OW 257
55615: PUSH
55616: LD_INT 1
55618: EQUAL
55619: IFFALSE 55640
// points := [ 10 , 5 , 3 ] ;
55621: LD_ADDR_VAR 0 9
55625: PUSH
55626: LD_INT 10
55628: PUSH
55629: LD_INT 5
55631: PUSH
55632: LD_INT 3
55634: PUSH
55635: EMPTY
55636: LIST
55637: LIST
55638: LIST
55639: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
55640: LD_VAR 0 6
55644: PPUSH
55645: CALL_OW 257
55649: PUSH
55650: LD_INT 2
55652: PUSH
55653: LD_INT 3
55655: PUSH
55656: LD_INT 4
55658: PUSH
55659: EMPTY
55660: LIST
55661: LIST
55662: LIST
55663: IN
55664: IFFALSE 55685
// points := [ 3 , 2 , 1 ] ;
55666: LD_ADDR_VAR 0 9
55670: PUSH
55671: LD_INT 3
55673: PUSH
55674: LD_INT 2
55676: PUSH
55677: LD_INT 1
55679: PUSH
55680: EMPTY
55681: LIST
55682: LIST
55683: LIST
55684: ST_TO_ADDR
// if GetClass ( i ) = 5 then
55685: LD_VAR 0 6
55689: PPUSH
55690: CALL_OW 257
55694: PUSH
55695: LD_INT 5
55697: EQUAL
55698: IFFALSE 55719
// points := [ 130 , 5 , 2 ] ;
55700: LD_ADDR_VAR 0 9
55704: PUSH
55705: LD_INT 130
55707: PUSH
55708: LD_INT 5
55710: PUSH
55711: LD_INT 2
55713: PUSH
55714: EMPTY
55715: LIST
55716: LIST
55717: LIST
55718: ST_TO_ADDR
// if GetClass ( i ) = 8 then
55719: LD_VAR 0 6
55723: PPUSH
55724: CALL_OW 257
55728: PUSH
55729: LD_INT 8
55731: EQUAL
55732: IFFALSE 55753
// points := [ 35 , 35 , 30 ] ;
55734: LD_ADDR_VAR 0 9
55738: PUSH
55739: LD_INT 35
55741: PUSH
55742: LD_INT 35
55744: PUSH
55745: LD_INT 30
55747: PUSH
55748: EMPTY
55749: LIST
55750: LIST
55751: LIST
55752: ST_TO_ADDR
// if GetClass ( i ) = 9 then
55753: LD_VAR 0 6
55757: PPUSH
55758: CALL_OW 257
55762: PUSH
55763: LD_INT 9
55765: EQUAL
55766: IFFALSE 55787
// points := [ 20 , 55 , 40 ] ;
55768: LD_ADDR_VAR 0 9
55772: PUSH
55773: LD_INT 20
55775: PUSH
55776: LD_INT 55
55778: PUSH
55779: LD_INT 40
55781: PUSH
55782: EMPTY
55783: LIST
55784: LIST
55785: LIST
55786: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
55787: LD_VAR 0 6
55791: PPUSH
55792: CALL_OW 257
55796: PUSH
55797: LD_INT 12
55799: PUSH
55800: LD_INT 16
55802: PUSH
55803: EMPTY
55804: LIST
55805: LIST
55806: IN
55807: IFFALSE 55828
// points := [ 5 , 3 , 2 ] ;
55809: LD_ADDR_VAR 0 9
55813: PUSH
55814: LD_INT 5
55816: PUSH
55817: LD_INT 3
55819: PUSH
55820: LD_INT 2
55822: PUSH
55823: EMPTY
55824: LIST
55825: LIST
55826: LIST
55827: ST_TO_ADDR
// if GetClass ( i ) = 17 then
55828: LD_VAR 0 6
55832: PPUSH
55833: CALL_OW 257
55837: PUSH
55838: LD_INT 17
55840: EQUAL
55841: IFFALSE 55862
// points := [ 100 , 50 , 75 ] ;
55843: LD_ADDR_VAR 0 9
55847: PUSH
55848: LD_INT 100
55850: PUSH
55851: LD_INT 50
55853: PUSH
55854: LD_INT 75
55856: PUSH
55857: EMPTY
55858: LIST
55859: LIST
55860: LIST
55861: ST_TO_ADDR
// if GetClass ( i ) = 15 then
55862: LD_VAR 0 6
55866: PPUSH
55867: CALL_OW 257
55871: PUSH
55872: LD_INT 15
55874: EQUAL
55875: IFFALSE 55896
// points := [ 10 , 5 , 3 ] ;
55877: LD_ADDR_VAR 0 9
55881: PUSH
55882: LD_INT 10
55884: PUSH
55885: LD_INT 5
55887: PUSH
55888: LD_INT 3
55890: PUSH
55891: EMPTY
55892: LIST
55893: LIST
55894: LIST
55895: ST_TO_ADDR
// if GetClass ( i ) = 14 then
55896: LD_VAR 0 6
55900: PPUSH
55901: CALL_OW 257
55905: PUSH
55906: LD_INT 14
55908: EQUAL
55909: IFFALSE 55930
// points := [ 10 , 0 , 0 ] ;
55911: LD_ADDR_VAR 0 9
55915: PUSH
55916: LD_INT 10
55918: PUSH
55919: LD_INT 0
55921: PUSH
55922: LD_INT 0
55924: PUSH
55925: EMPTY
55926: LIST
55927: LIST
55928: LIST
55929: ST_TO_ADDR
// if GetClass ( i ) = 11 then
55930: LD_VAR 0 6
55934: PPUSH
55935: CALL_OW 257
55939: PUSH
55940: LD_INT 11
55942: EQUAL
55943: IFFALSE 55964
// points := [ 30 , 10 , 5 ] ;
55945: LD_ADDR_VAR 0 9
55949: PUSH
55950: LD_INT 30
55952: PUSH
55953: LD_INT 10
55955: PUSH
55956: LD_INT 5
55958: PUSH
55959: EMPTY
55960: LIST
55961: LIST
55962: LIST
55963: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
55964: LD_VAR 0 1
55968: PPUSH
55969: LD_INT 5
55971: PPUSH
55972: CALL_OW 321
55976: PUSH
55977: LD_INT 2
55979: EQUAL
55980: IFFALSE 55997
// bpoints := bpoints * 1.8 ;
55982: LD_ADDR_VAR 0 10
55986: PUSH
55987: LD_VAR 0 10
55991: PUSH
55992: LD_REAL  1.80000000000000E+0000
55995: MUL
55996: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
55997: LD_VAR 0 6
56001: PPUSH
56002: CALL_OW 257
56006: PUSH
56007: LD_INT 1
56009: PUSH
56010: LD_INT 2
56012: PUSH
56013: LD_INT 3
56015: PUSH
56016: LD_INT 4
56018: PUSH
56019: EMPTY
56020: LIST
56021: LIST
56022: LIST
56023: LIST
56024: IN
56025: PUSH
56026: LD_VAR 0 1
56030: PPUSH
56031: LD_INT 51
56033: PPUSH
56034: CALL_OW 321
56038: PUSH
56039: LD_INT 2
56041: EQUAL
56042: AND
56043: IFFALSE 56060
// bpoints := bpoints * 1.2 ;
56045: LD_ADDR_VAR 0 10
56049: PUSH
56050: LD_VAR 0 10
56054: PUSH
56055: LD_REAL  1.20000000000000E+0000
56058: MUL
56059: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
56060: LD_VAR 0 6
56064: PPUSH
56065: CALL_OW 257
56069: PUSH
56070: LD_INT 5
56072: PUSH
56073: LD_INT 7
56075: PUSH
56076: LD_INT 9
56078: PUSH
56079: EMPTY
56080: LIST
56081: LIST
56082: LIST
56083: IN
56084: PUSH
56085: LD_VAR 0 1
56089: PPUSH
56090: LD_INT 52
56092: PPUSH
56093: CALL_OW 321
56097: PUSH
56098: LD_INT 2
56100: EQUAL
56101: AND
56102: IFFALSE 56119
// bpoints := bpoints * 1.5 ;
56104: LD_ADDR_VAR 0 10
56108: PUSH
56109: LD_VAR 0 10
56113: PUSH
56114: LD_REAL  1.50000000000000E+0000
56117: MUL
56118: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
56119: LD_VAR 0 1
56123: PPUSH
56124: LD_INT 66
56126: PPUSH
56127: CALL_OW 321
56131: PUSH
56132: LD_INT 2
56134: EQUAL
56135: IFFALSE 56152
// bpoints := bpoints * 1.1 ;
56137: LD_ADDR_VAR 0 10
56141: PUSH
56142: LD_VAR 0 10
56146: PUSH
56147: LD_REAL  1.10000000000000E+0000
56150: MUL
56151: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
56152: LD_ADDR_VAR 0 10
56156: PUSH
56157: LD_VAR 0 10
56161: PUSH
56162: LD_VAR 0 6
56166: PPUSH
56167: LD_INT 1
56169: PPUSH
56170: CALL_OW 259
56174: PUSH
56175: LD_REAL  1.15000000000000E+0000
56178: MUL
56179: MUL
56180: ST_TO_ADDR
// end ; unit_vehicle :
56181: GO 57009
56183: LD_INT 2
56185: DOUBLE
56186: EQUAL
56187: IFTRUE 56191
56189: GO 56997
56191: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
56192: LD_VAR 0 6
56196: PPUSH
56197: CALL_OW 264
56201: PUSH
56202: LD_INT 2
56204: PUSH
56205: LD_INT 42
56207: PUSH
56208: LD_INT 24
56210: PUSH
56211: EMPTY
56212: LIST
56213: LIST
56214: LIST
56215: IN
56216: IFFALSE 56237
// points := [ 25 , 5 , 3 ] ;
56218: LD_ADDR_VAR 0 9
56222: PUSH
56223: LD_INT 25
56225: PUSH
56226: LD_INT 5
56228: PUSH
56229: LD_INT 3
56231: PUSH
56232: EMPTY
56233: LIST
56234: LIST
56235: LIST
56236: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
56237: LD_VAR 0 6
56241: PPUSH
56242: CALL_OW 264
56246: PUSH
56247: LD_INT 4
56249: PUSH
56250: LD_INT 43
56252: PUSH
56253: LD_INT 25
56255: PUSH
56256: EMPTY
56257: LIST
56258: LIST
56259: LIST
56260: IN
56261: IFFALSE 56282
// points := [ 40 , 15 , 5 ] ;
56263: LD_ADDR_VAR 0 9
56267: PUSH
56268: LD_INT 40
56270: PUSH
56271: LD_INT 15
56273: PUSH
56274: LD_INT 5
56276: PUSH
56277: EMPTY
56278: LIST
56279: LIST
56280: LIST
56281: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
56282: LD_VAR 0 6
56286: PPUSH
56287: CALL_OW 264
56291: PUSH
56292: LD_INT 3
56294: PUSH
56295: LD_INT 23
56297: PUSH
56298: EMPTY
56299: LIST
56300: LIST
56301: IN
56302: IFFALSE 56323
// points := [ 7 , 25 , 8 ] ;
56304: LD_ADDR_VAR 0 9
56308: PUSH
56309: LD_INT 7
56311: PUSH
56312: LD_INT 25
56314: PUSH
56315: LD_INT 8
56317: PUSH
56318: EMPTY
56319: LIST
56320: LIST
56321: LIST
56322: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
56323: LD_VAR 0 6
56327: PPUSH
56328: CALL_OW 264
56332: PUSH
56333: LD_INT 5
56335: PUSH
56336: LD_INT 27
56338: PUSH
56339: LD_INT 44
56341: PUSH
56342: EMPTY
56343: LIST
56344: LIST
56345: LIST
56346: IN
56347: IFFALSE 56368
// points := [ 14 , 50 , 16 ] ;
56349: LD_ADDR_VAR 0 9
56353: PUSH
56354: LD_INT 14
56356: PUSH
56357: LD_INT 50
56359: PUSH
56360: LD_INT 16
56362: PUSH
56363: EMPTY
56364: LIST
56365: LIST
56366: LIST
56367: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
56368: LD_VAR 0 6
56372: PPUSH
56373: CALL_OW 264
56377: PUSH
56378: LD_INT 6
56380: PUSH
56381: LD_INT 46
56383: PUSH
56384: EMPTY
56385: LIST
56386: LIST
56387: IN
56388: IFFALSE 56409
// points := [ 32 , 120 , 70 ] ;
56390: LD_ADDR_VAR 0 9
56394: PUSH
56395: LD_INT 32
56397: PUSH
56398: LD_INT 120
56400: PUSH
56401: LD_INT 70
56403: PUSH
56404: EMPTY
56405: LIST
56406: LIST
56407: LIST
56408: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
56409: LD_VAR 0 6
56413: PPUSH
56414: CALL_OW 264
56418: PUSH
56419: LD_INT 7
56421: PUSH
56422: LD_INT 28
56424: PUSH
56425: LD_INT 45
56427: PUSH
56428: LD_INT 92
56430: PUSH
56431: EMPTY
56432: LIST
56433: LIST
56434: LIST
56435: LIST
56436: IN
56437: IFFALSE 56458
// points := [ 35 , 20 , 45 ] ;
56439: LD_ADDR_VAR 0 9
56443: PUSH
56444: LD_INT 35
56446: PUSH
56447: LD_INT 20
56449: PUSH
56450: LD_INT 45
56452: PUSH
56453: EMPTY
56454: LIST
56455: LIST
56456: LIST
56457: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
56458: LD_VAR 0 6
56462: PPUSH
56463: CALL_OW 264
56467: PUSH
56468: LD_INT 47
56470: PUSH
56471: EMPTY
56472: LIST
56473: IN
56474: IFFALSE 56495
// points := [ 67 , 45 , 75 ] ;
56476: LD_ADDR_VAR 0 9
56480: PUSH
56481: LD_INT 67
56483: PUSH
56484: LD_INT 45
56486: PUSH
56487: LD_INT 75
56489: PUSH
56490: EMPTY
56491: LIST
56492: LIST
56493: LIST
56494: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
56495: LD_VAR 0 6
56499: PPUSH
56500: CALL_OW 264
56504: PUSH
56505: LD_INT 26
56507: PUSH
56508: EMPTY
56509: LIST
56510: IN
56511: IFFALSE 56532
// points := [ 120 , 30 , 80 ] ;
56513: LD_ADDR_VAR 0 9
56517: PUSH
56518: LD_INT 120
56520: PUSH
56521: LD_INT 30
56523: PUSH
56524: LD_INT 80
56526: PUSH
56527: EMPTY
56528: LIST
56529: LIST
56530: LIST
56531: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
56532: LD_VAR 0 6
56536: PPUSH
56537: CALL_OW 264
56541: PUSH
56542: LD_INT 22
56544: PUSH
56545: EMPTY
56546: LIST
56547: IN
56548: IFFALSE 56569
// points := [ 40 , 1 , 1 ] ;
56550: LD_ADDR_VAR 0 9
56554: PUSH
56555: LD_INT 40
56557: PUSH
56558: LD_INT 1
56560: PUSH
56561: LD_INT 1
56563: PUSH
56564: EMPTY
56565: LIST
56566: LIST
56567: LIST
56568: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
56569: LD_VAR 0 6
56573: PPUSH
56574: CALL_OW 264
56578: PUSH
56579: LD_INT 29
56581: PUSH
56582: EMPTY
56583: LIST
56584: IN
56585: IFFALSE 56606
// points := [ 70 , 200 , 400 ] ;
56587: LD_ADDR_VAR 0 9
56591: PUSH
56592: LD_INT 70
56594: PUSH
56595: LD_INT 200
56597: PUSH
56598: LD_INT 400
56600: PUSH
56601: EMPTY
56602: LIST
56603: LIST
56604: LIST
56605: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
56606: LD_VAR 0 6
56610: PPUSH
56611: CALL_OW 264
56615: PUSH
56616: LD_INT 14
56618: PUSH
56619: LD_INT 53
56621: PUSH
56622: EMPTY
56623: LIST
56624: LIST
56625: IN
56626: IFFALSE 56647
// points := [ 40 , 10 , 20 ] ;
56628: LD_ADDR_VAR 0 9
56632: PUSH
56633: LD_INT 40
56635: PUSH
56636: LD_INT 10
56638: PUSH
56639: LD_INT 20
56641: PUSH
56642: EMPTY
56643: LIST
56644: LIST
56645: LIST
56646: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
56647: LD_VAR 0 6
56651: PPUSH
56652: CALL_OW 264
56656: PUSH
56657: LD_INT 9
56659: PUSH
56660: EMPTY
56661: LIST
56662: IN
56663: IFFALSE 56684
// points := [ 5 , 70 , 20 ] ;
56665: LD_ADDR_VAR 0 9
56669: PUSH
56670: LD_INT 5
56672: PUSH
56673: LD_INT 70
56675: PUSH
56676: LD_INT 20
56678: PUSH
56679: EMPTY
56680: LIST
56681: LIST
56682: LIST
56683: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
56684: LD_VAR 0 6
56688: PPUSH
56689: CALL_OW 264
56693: PUSH
56694: LD_INT 10
56696: PUSH
56697: EMPTY
56698: LIST
56699: IN
56700: IFFALSE 56721
// points := [ 35 , 110 , 70 ] ;
56702: LD_ADDR_VAR 0 9
56706: PUSH
56707: LD_INT 35
56709: PUSH
56710: LD_INT 110
56712: PUSH
56713: LD_INT 70
56715: PUSH
56716: EMPTY
56717: LIST
56718: LIST
56719: LIST
56720: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
56721: LD_VAR 0 6
56725: PPUSH
56726: CALL_OW 265
56730: PUSH
56731: LD_INT 25
56733: EQUAL
56734: IFFALSE 56755
// points := [ 80 , 65 , 100 ] ;
56736: LD_ADDR_VAR 0 9
56740: PUSH
56741: LD_INT 80
56743: PUSH
56744: LD_INT 65
56746: PUSH
56747: LD_INT 100
56749: PUSH
56750: EMPTY
56751: LIST
56752: LIST
56753: LIST
56754: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
56755: LD_VAR 0 6
56759: PPUSH
56760: CALL_OW 263
56764: PUSH
56765: LD_INT 1
56767: EQUAL
56768: IFFALSE 56803
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
56770: LD_ADDR_VAR 0 10
56774: PUSH
56775: LD_VAR 0 10
56779: PUSH
56780: LD_VAR 0 6
56784: PPUSH
56785: CALL_OW 311
56789: PPUSH
56790: LD_INT 3
56792: PPUSH
56793: CALL_OW 259
56797: PUSH
56798: LD_INT 4
56800: MUL
56801: MUL
56802: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
56803: LD_VAR 0 6
56807: PPUSH
56808: CALL_OW 263
56812: PUSH
56813: LD_INT 2
56815: EQUAL
56816: IFFALSE 56867
// begin j := IsControledBy ( i ) ;
56818: LD_ADDR_VAR 0 7
56822: PUSH
56823: LD_VAR 0 6
56827: PPUSH
56828: CALL_OW 312
56832: ST_TO_ADDR
// if j then
56833: LD_VAR 0 7
56837: IFFALSE 56867
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
56839: LD_ADDR_VAR 0 10
56843: PUSH
56844: LD_VAR 0 10
56848: PUSH
56849: LD_VAR 0 7
56853: PPUSH
56854: LD_INT 3
56856: PPUSH
56857: CALL_OW 259
56861: PUSH
56862: LD_INT 3
56864: MUL
56865: MUL
56866: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
56867: LD_VAR 0 6
56871: PPUSH
56872: CALL_OW 264
56876: PUSH
56877: LD_INT 5
56879: PUSH
56880: LD_INT 6
56882: PUSH
56883: LD_INT 46
56885: PUSH
56886: LD_INT 44
56888: PUSH
56889: LD_INT 47
56891: PUSH
56892: LD_INT 45
56894: PUSH
56895: LD_INT 28
56897: PUSH
56898: LD_INT 7
56900: PUSH
56901: LD_INT 27
56903: PUSH
56904: LD_INT 29
56906: PUSH
56907: EMPTY
56908: LIST
56909: LIST
56910: LIST
56911: LIST
56912: LIST
56913: LIST
56914: LIST
56915: LIST
56916: LIST
56917: LIST
56918: IN
56919: PUSH
56920: LD_VAR 0 1
56924: PPUSH
56925: LD_INT 52
56927: PPUSH
56928: CALL_OW 321
56932: PUSH
56933: LD_INT 2
56935: EQUAL
56936: AND
56937: IFFALSE 56954
// bpoints := bpoints * 1.2 ;
56939: LD_ADDR_VAR 0 10
56943: PUSH
56944: LD_VAR 0 10
56948: PUSH
56949: LD_REAL  1.20000000000000E+0000
56952: MUL
56953: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
56954: LD_VAR 0 6
56958: PPUSH
56959: CALL_OW 264
56963: PUSH
56964: LD_INT 6
56966: PUSH
56967: LD_INT 46
56969: PUSH
56970: LD_INT 47
56972: PUSH
56973: EMPTY
56974: LIST
56975: LIST
56976: LIST
56977: IN
56978: IFFALSE 56995
// bpoints := bpoints * 1.2 ;
56980: LD_ADDR_VAR 0 10
56984: PUSH
56985: LD_VAR 0 10
56989: PUSH
56990: LD_REAL  1.20000000000000E+0000
56993: MUL
56994: ST_TO_ADDR
// end ; unit_building :
56995: GO 57009
56997: LD_INT 3
56999: DOUBLE
57000: EQUAL
57001: IFTRUE 57005
57003: GO 57008
57005: POP
// ; end ;
57006: GO 57009
57008: POP
// for j = 1 to 3 do
57009: LD_ADDR_VAR 0 7
57013: PUSH
57014: DOUBLE
57015: LD_INT 1
57017: DEC
57018: ST_TO_ADDR
57019: LD_INT 3
57021: PUSH
57022: FOR_TO
57023: IFFALSE 57076
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
57025: LD_ADDR_VAR 0 5
57029: PUSH
57030: LD_VAR 0 5
57034: PPUSH
57035: LD_VAR 0 7
57039: PPUSH
57040: LD_VAR 0 5
57044: PUSH
57045: LD_VAR 0 7
57049: ARRAY
57050: PUSH
57051: LD_VAR 0 9
57055: PUSH
57056: LD_VAR 0 7
57060: ARRAY
57061: PUSH
57062: LD_VAR 0 10
57066: MUL
57067: PLUS
57068: PPUSH
57069: CALL_OW 1
57073: ST_TO_ADDR
57074: GO 57022
57076: POP
57077: POP
// end ;
57078: GO 55557
57080: POP
57081: POP
// result := Replace ( result , 4 , tmp ) ;
57082: LD_ADDR_VAR 0 5
57086: PUSH
57087: LD_VAR 0 5
57091: PPUSH
57092: LD_INT 4
57094: PPUSH
57095: LD_VAR 0 8
57099: PPUSH
57100: CALL_OW 1
57104: ST_TO_ADDR
// end ;
57105: LD_VAR 0 5
57109: RET
// export function DangerAtRange ( unit , range ) ; begin
57110: LD_INT 0
57112: PPUSH
// if not unit then
57113: LD_VAR 0 1
57117: NOT
57118: IFFALSE 57122
// exit ;
57120: GO 57167
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
57122: LD_ADDR_VAR 0 3
57126: PUSH
57127: LD_VAR 0 1
57131: PPUSH
57132: CALL_OW 255
57136: PPUSH
57137: LD_VAR 0 1
57141: PPUSH
57142: CALL_OW 250
57146: PPUSH
57147: LD_VAR 0 1
57151: PPUSH
57152: CALL_OW 251
57156: PPUSH
57157: LD_VAR 0 2
57161: PPUSH
57162: CALL 55409 0 4
57166: ST_TO_ADDR
// end ;
57167: LD_VAR 0 3
57171: RET
// export function DangerInArea ( side , area ) ; begin
57172: LD_INT 0
57174: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
57175: LD_ADDR_VAR 0 3
57179: PUSH
57180: LD_VAR 0 2
57184: PPUSH
57185: LD_INT 81
57187: PUSH
57188: LD_VAR 0 1
57192: PUSH
57193: EMPTY
57194: LIST
57195: LIST
57196: PPUSH
57197: CALL_OW 70
57201: ST_TO_ADDR
// end ;
57202: LD_VAR 0 3
57206: RET
// export function IsExtension ( b ) ; begin
57207: LD_INT 0
57209: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
57210: LD_ADDR_VAR 0 2
57214: PUSH
57215: LD_VAR 0 1
57219: PUSH
57220: LD_INT 23
57222: PUSH
57223: LD_INT 20
57225: PUSH
57226: LD_INT 22
57228: PUSH
57229: LD_INT 17
57231: PUSH
57232: LD_INT 24
57234: PUSH
57235: LD_INT 21
57237: PUSH
57238: LD_INT 19
57240: PUSH
57241: LD_INT 16
57243: PUSH
57244: LD_INT 25
57246: PUSH
57247: LD_INT 18
57249: PUSH
57250: EMPTY
57251: LIST
57252: LIST
57253: LIST
57254: LIST
57255: LIST
57256: LIST
57257: LIST
57258: LIST
57259: LIST
57260: LIST
57261: IN
57262: ST_TO_ADDR
// end ;
57263: LD_VAR 0 2
57267: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
57268: LD_INT 0
57270: PPUSH
57271: PPUSH
57272: PPUSH
// result := [ ] ;
57273: LD_ADDR_VAR 0 4
57277: PUSH
57278: EMPTY
57279: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
57280: LD_ADDR_VAR 0 5
57284: PUSH
57285: LD_VAR 0 2
57289: PPUSH
57290: LD_INT 21
57292: PUSH
57293: LD_INT 3
57295: PUSH
57296: EMPTY
57297: LIST
57298: LIST
57299: PPUSH
57300: CALL_OW 70
57304: ST_TO_ADDR
// if not tmp then
57305: LD_VAR 0 5
57309: NOT
57310: IFFALSE 57314
// exit ;
57312: GO 57378
// if checkLink then
57314: LD_VAR 0 3
57318: IFFALSE 57368
// begin for i in tmp do
57320: LD_ADDR_VAR 0 6
57324: PUSH
57325: LD_VAR 0 5
57329: PUSH
57330: FOR_IN
57331: IFFALSE 57366
// if GetBase ( i ) <> base then
57333: LD_VAR 0 6
57337: PPUSH
57338: CALL_OW 274
57342: PUSH
57343: LD_VAR 0 1
57347: NONEQUAL
57348: IFFALSE 57364
// ComLinkToBase ( base , i ) ;
57350: LD_VAR 0 1
57354: PPUSH
57355: LD_VAR 0 6
57359: PPUSH
57360: CALL_OW 169
57364: GO 57330
57366: POP
57367: POP
// end ; result := tmp ;
57368: LD_ADDR_VAR 0 4
57372: PUSH
57373: LD_VAR 0 5
57377: ST_TO_ADDR
// end ;
57378: LD_VAR 0 4
57382: RET
// export function ComComplete ( units , b ) ; var i ; begin
57383: LD_INT 0
57385: PPUSH
57386: PPUSH
// if not units then
57387: LD_VAR 0 1
57391: NOT
57392: IFFALSE 57396
// exit ;
57394: GO 57486
// for i in units do
57396: LD_ADDR_VAR 0 4
57400: PUSH
57401: LD_VAR 0 1
57405: PUSH
57406: FOR_IN
57407: IFFALSE 57484
// if BuildingStatus ( b ) = bs_build then
57409: LD_VAR 0 2
57413: PPUSH
57414: CALL_OW 461
57418: PUSH
57419: LD_INT 1
57421: EQUAL
57422: IFFALSE 57482
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
57424: LD_VAR 0 4
57428: PPUSH
57429: LD_STRING h
57431: PUSH
57432: LD_VAR 0 2
57436: PPUSH
57437: CALL_OW 250
57441: PUSH
57442: LD_VAR 0 2
57446: PPUSH
57447: CALL_OW 251
57451: PUSH
57452: LD_VAR 0 2
57456: PUSH
57457: LD_INT 0
57459: PUSH
57460: LD_INT 0
57462: PUSH
57463: LD_INT 0
57465: PUSH
57466: EMPTY
57467: LIST
57468: LIST
57469: LIST
57470: LIST
57471: LIST
57472: LIST
57473: LIST
57474: PUSH
57475: EMPTY
57476: LIST
57477: PPUSH
57478: CALL_OW 446
57482: GO 57406
57484: POP
57485: POP
// end ;
57486: LD_VAR 0 3
57490: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
57491: LD_INT 0
57493: PPUSH
57494: PPUSH
57495: PPUSH
57496: PPUSH
57497: PPUSH
57498: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
57499: LD_VAR 0 1
57503: NOT
57504: PUSH
57505: LD_VAR 0 1
57509: PPUSH
57510: CALL_OW 263
57514: PUSH
57515: LD_INT 2
57517: NONEQUAL
57518: OR
57519: IFFALSE 57523
// exit ;
57521: GO 57839
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
57523: LD_ADDR_VAR 0 6
57527: PUSH
57528: LD_INT 22
57530: PUSH
57531: LD_VAR 0 1
57535: PPUSH
57536: CALL_OW 255
57540: PUSH
57541: EMPTY
57542: LIST
57543: LIST
57544: PUSH
57545: LD_INT 2
57547: PUSH
57548: LD_INT 30
57550: PUSH
57551: LD_INT 36
57553: PUSH
57554: EMPTY
57555: LIST
57556: LIST
57557: PUSH
57558: LD_INT 34
57560: PUSH
57561: LD_INT 31
57563: PUSH
57564: EMPTY
57565: LIST
57566: LIST
57567: PUSH
57568: EMPTY
57569: LIST
57570: LIST
57571: LIST
57572: PUSH
57573: EMPTY
57574: LIST
57575: LIST
57576: PPUSH
57577: CALL_OW 69
57581: ST_TO_ADDR
// if not tmp then
57582: LD_VAR 0 6
57586: NOT
57587: IFFALSE 57591
// exit ;
57589: GO 57839
// result := [ ] ;
57591: LD_ADDR_VAR 0 2
57595: PUSH
57596: EMPTY
57597: ST_TO_ADDR
// for i in tmp do
57598: LD_ADDR_VAR 0 3
57602: PUSH
57603: LD_VAR 0 6
57607: PUSH
57608: FOR_IN
57609: IFFALSE 57680
// begin t := UnitsInside ( i ) ;
57611: LD_ADDR_VAR 0 4
57615: PUSH
57616: LD_VAR 0 3
57620: PPUSH
57621: CALL_OW 313
57625: ST_TO_ADDR
// if t then
57626: LD_VAR 0 4
57630: IFFALSE 57678
// for j in t do
57632: LD_ADDR_VAR 0 7
57636: PUSH
57637: LD_VAR 0 4
57641: PUSH
57642: FOR_IN
57643: IFFALSE 57676
// result := Replace ( result , result + 1 , j ) ;
57645: LD_ADDR_VAR 0 2
57649: PUSH
57650: LD_VAR 0 2
57654: PPUSH
57655: LD_VAR 0 2
57659: PUSH
57660: LD_INT 1
57662: PLUS
57663: PPUSH
57664: LD_VAR 0 7
57668: PPUSH
57669: CALL_OW 1
57673: ST_TO_ADDR
57674: GO 57642
57676: POP
57677: POP
// end ;
57678: GO 57608
57680: POP
57681: POP
// if not result then
57682: LD_VAR 0 2
57686: NOT
57687: IFFALSE 57691
// exit ;
57689: GO 57839
// mech := result [ 1 ] ;
57691: LD_ADDR_VAR 0 5
57695: PUSH
57696: LD_VAR 0 2
57700: PUSH
57701: LD_INT 1
57703: ARRAY
57704: ST_TO_ADDR
// if result > 1 then
57705: LD_VAR 0 2
57709: PUSH
57710: LD_INT 1
57712: GREATER
57713: IFFALSE 57825
// begin for i = 2 to result do
57715: LD_ADDR_VAR 0 3
57719: PUSH
57720: DOUBLE
57721: LD_INT 2
57723: DEC
57724: ST_TO_ADDR
57725: LD_VAR 0 2
57729: PUSH
57730: FOR_TO
57731: IFFALSE 57823
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
57733: LD_ADDR_VAR 0 4
57737: PUSH
57738: LD_VAR 0 2
57742: PUSH
57743: LD_VAR 0 3
57747: ARRAY
57748: PPUSH
57749: LD_INT 3
57751: PPUSH
57752: CALL_OW 259
57756: PUSH
57757: LD_VAR 0 2
57761: PUSH
57762: LD_VAR 0 3
57766: ARRAY
57767: PPUSH
57768: CALL_OW 432
57772: MINUS
57773: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
57774: LD_VAR 0 4
57778: PUSH
57779: LD_VAR 0 5
57783: PPUSH
57784: LD_INT 3
57786: PPUSH
57787: CALL_OW 259
57791: PUSH
57792: LD_VAR 0 5
57796: PPUSH
57797: CALL_OW 432
57801: MINUS
57802: GREATEREQUAL
57803: IFFALSE 57821
// mech := result [ i ] ;
57805: LD_ADDR_VAR 0 5
57809: PUSH
57810: LD_VAR 0 2
57814: PUSH
57815: LD_VAR 0 3
57819: ARRAY
57820: ST_TO_ADDR
// end ;
57821: GO 57730
57823: POP
57824: POP
// end ; ComLinkTo ( vehicle , mech ) ;
57825: LD_VAR 0 1
57829: PPUSH
57830: LD_VAR 0 5
57834: PPUSH
57835: CALL_OW 135
// end ;
57839: LD_VAR 0 2
57843: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
57844: LD_INT 0
57846: PPUSH
57847: PPUSH
57848: PPUSH
57849: PPUSH
57850: PPUSH
57851: PPUSH
57852: PPUSH
57853: PPUSH
57854: PPUSH
57855: PPUSH
57856: PPUSH
57857: PPUSH
57858: PPUSH
// result := [ ] ;
57859: LD_ADDR_VAR 0 7
57863: PUSH
57864: EMPTY
57865: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
57866: LD_VAR 0 1
57870: PPUSH
57871: CALL_OW 266
57875: PUSH
57876: LD_INT 0
57878: PUSH
57879: LD_INT 1
57881: PUSH
57882: EMPTY
57883: LIST
57884: LIST
57885: IN
57886: NOT
57887: IFFALSE 57891
// exit ;
57889: GO 59525
// if name then
57891: LD_VAR 0 3
57895: IFFALSE 57911
// SetBName ( base_dep , name ) ;
57897: LD_VAR 0 1
57901: PPUSH
57902: LD_VAR 0 3
57906: PPUSH
57907: CALL_OW 500
// base := GetBase ( base_dep ) ;
57911: LD_ADDR_VAR 0 15
57915: PUSH
57916: LD_VAR 0 1
57920: PPUSH
57921: CALL_OW 274
57925: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
57926: LD_ADDR_VAR 0 16
57930: PUSH
57931: LD_VAR 0 1
57935: PPUSH
57936: CALL_OW 255
57940: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
57941: LD_ADDR_VAR 0 17
57945: PUSH
57946: LD_VAR 0 1
57950: PPUSH
57951: CALL_OW 248
57955: ST_TO_ADDR
// if sources then
57956: LD_VAR 0 5
57960: IFFALSE 58007
// for i = 1 to 3 do
57962: LD_ADDR_VAR 0 8
57966: PUSH
57967: DOUBLE
57968: LD_INT 1
57970: DEC
57971: ST_TO_ADDR
57972: LD_INT 3
57974: PUSH
57975: FOR_TO
57976: IFFALSE 58005
// AddResourceType ( base , i , sources [ i ] ) ;
57978: LD_VAR 0 15
57982: PPUSH
57983: LD_VAR 0 8
57987: PPUSH
57988: LD_VAR 0 5
57992: PUSH
57993: LD_VAR 0 8
57997: ARRAY
57998: PPUSH
57999: CALL_OW 276
58003: GO 57975
58005: POP
58006: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
58007: LD_ADDR_VAR 0 18
58011: PUSH
58012: LD_VAR 0 15
58016: PPUSH
58017: LD_VAR 0 2
58021: PPUSH
58022: LD_INT 1
58024: PPUSH
58025: CALL 57268 0 3
58029: ST_TO_ADDR
// InitHc ;
58030: CALL_OW 19
// InitUc ;
58034: CALL_OW 18
// uc_side := side ;
58038: LD_ADDR_OWVAR 20
58042: PUSH
58043: LD_VAR 0 16
58047: ST_TO_ADDR
// uc_nation := nation ;
58048: LD_ADDR_OWVAR 21
58052: PUSH
58053: LD_VAR 0 17
58057: ST_TO_ADDR
// if buildings then
58058: LD_VAR 0 18
58062: IFFALSE 59384
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
58064: LD_ADDR_VAR 0 19
58068: PUSH
58069: LD_VAR 0 18
58073: PPUSH
58074: LD_INT 2
58076: PUSH
58077: LD_INT 30
58079: PUSH
58080: LD_INT 29
58082: PUSH
58083: EMPTY
58084: LIST
58085: LIST
58086: PUSH
58087: LD_INT 30
58089: PUSH
58090: LD_INT 30
58092: PUSH
58093: EMPTY
58094: LIST
58095: LIST
58096: PUSH
58097: EMPTY
58098: LIST
58099: LIST
58100: LIST
58101: PPUSH
58102: CALL_OW 72
58106: ST_TO_ADDR
// if tmp then
58107: LD_VAR 0 19
58111: IFFALSE 58159
// for i in tmp do
58113: LD_ADDR_VAR 0 8
58117: PUSH
58118: LD_VAR 0 19
58122: PUSH
58123: FOR_IN
58124: IFFALSE 58157
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
58126: LD_VAR 0 8
58130: PPUSH
58131: CALL_OW 250
58135: PPUSH
58136: LD_VAR 0 8
58140: PPUSH
58141: CALL_OW 251
58145: PPUSH
58146: LD_VAR 0 16
58150: PPUSH
58151: CALL_OW 441
58155: GO 58123
58157: POP
58158: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
58159: LD_VAR 0 18
58163: PPUSH
58164: LD_INT 2
58166: PUSH
58167: LD_INT 30
58169: PUSH
58170: LD_INT 32
58172: PUSH
58173: EMPTY
58174: LIST
58175: LIST
58176: PUSH
58177: LD_INT 30
58179: PUSH
58180: LD_INT 33
58182: PUSH
58183: EMPTY
58184: LIST
58185: LIST
58186: PUSH
58187: EMPTY
58188: LIST
58189: LIST
58190: LIST
58191: PPUSH
58192: CALL_OW 72
58196: IFFALSE 58284
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
58198: LD_ADDR_VAR 0 8
58202: PUSH
58203: LD_VAR 0 18
58207: PPUSH
58208: LD_INT 2
58210: PUSH
58211: LD_INT 30
58213: PUSH
58214: LD_INT 32
58216: PUSH
58217: EMPTY
58218: LIST
58219: LIST
58220: PUSH
58221: LD_INT 30
58223: PUSH
58224: LD_INT 33
58226: PUSH
58227: EMPTY
58228: LIST
58229: LIST
58230: PUSH
58231: EMPTY
58232: LIST
58233: LIST
58234: LIST
58235: PPUSH
58236: CALL_OW 72
58240: PUSH
58241: FOR_IN
58242: IFFALSE 58282
// begin if not GetBWeapon ( i ) then
58244: LD_VAR 0 8
58248: PPUSH
58249: CALL_OW 269
58253: NOT
58254: IFFALSE 58280
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
58256: LD_VAR 0 8
58260: PPUSH
58261: LD_VAR 0 8
58265: PPUSH
58266: LD_VAR 0 2
58270: PPUSH
58271: CALL 59530 0 2
58275: PPUSH
58276: CALL_OW 431
// end ;
58280: GO 58241
58282: POP
58283: POP
// end ; for i = 1 to personel do
58284: LD_ADDR_VAR 0 8
58288: PUSH
58289: DOUBLE
58290: LD_INT 1
58292: DEC
58293: ST_TO_ADDR
58294: LD_VAR 0 6
58298: PUSH
58299: FOR_TO
58300: IFFALSE 59364
// begin if i > 4 then
58302: LD_VAR 0 8
58306: PUSH
58307: LD_INT 4
58309: GREATER
58310: IFFALSE 58314
// break ;
58312: GO 59364
// case i of 1 :
58314: LD_VAR 0 8
58318: PUSH
58319: LD_INT 1
58321: DOUBLE
58322: EQUAL
58323: IFTRUE 58327
58325: GO 58407
58327: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
58328: LD_ADDR_VAR 0 12
58332: PUSH
58333: LD_VAR 0 18
58337: PPUSH
58338: LD_INT 22
58340: PUSH
58341: LD_VAR 0 16
58345: PUSH
58346: EMPTY
58347: LIST
58348: LIST
58349: PUSH
58350: LD_INT 58
58352: PUSH
58353: EMPTY
58354: LIST
58355: PUSH
58356: LD_INT 2
58358: PUSH
58359: LD_INT 30
58361: PUSH
58362: LD_INT 32
58364: PUSH
58365: EMPTY
58366: LIST
58367: LIST
58368: PUSH
58369: LD_INT 30
58371: PUSH
58372: LD_INT 4
58374: PUSH
58375: EMPTY
58376: LIST
58377: LIST
58378: PUSH
58379: LD_INT 30
58381: PUSH
58382: LD_INT 5
58384: PUSH
58385: EMPTY
58386: LIST
58387: LIST
58388: PUSH
58389: EMPTY
58390: LIST
58391: LIST
58392: LIST
58393: LIST
58394: PUSH
58395: EMPTY
58396: LIST
58397: LIST
58398: LIST
58399: PPUSH
58400: CALL_OW 72
58404: ST_TO_ADDR
58405: GO 58629
58407: LD_INT 2
58409: DOUBLE
58410: EQUAL
58411: IFTRUE 58415
58413: GO 58477
58415: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
58416: LD_ADDR_VAR 0 12
58420: PUSH
58421: LD_VAR 0 18
58425: PPUSH
58426: LD_INT 22
58428: PUSH
58429: LD_VAR 0 16
58433: PUSH
58434: EMPTY
58435: LIST
58436: LIST
58437: PUSH
58438: LD_INT 2
58440: PUSH
58441: LD_INT 30
58443: PUSH
58444: LD_INT 0
58446: PUSH
58447: EMPTY
58448: LIST
58449: LIST
58450: PUSH
58451: LD_INT 30
58453: PUSH
58454: LD_INT 1
58456: PUSH
58457: EMPTY
58458: LIST
58459: LIST
58460: PUSH
58461: EMPTY
58462: LIST
58463: LIST
58464: LIST
58465: PUSH
58466: EMPTY
58467: LIST
58468: LIST
58469: PPUSH
58470: CALL_OW 72
58474: ST_TO_ADDR
58475: GO 58629
58477: LD_INT 3
58479: DOUBLE
58480: EQUAL
58481: IFTRUE 58485
58483: GO 58547
58485: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
58486: LD_ADDR_VAR 0 12
58490: PUSH
58491: LD_VAR 0 18
58495: PPUSH
58496: LD_INT 22
58498: PUSH
58499: LD_VAR 0 16
58503: PUSH
58504: EMPTY
58505: LIST
58506: LIST
58507: PUSH
58508: LD_INT 2
58510: PUSH
58511: LD_INT 30
58513: PUSH
58514: LD_INT 2
58516: PUSH
58517: EMPTY
58518: LIST
58519: LIST
58520: PUSH
58521: LD_INT 30
58523: PUSH
58524: LD_INT 3
58526: PUSH
58527: EMPTY
58528: LIST
58529: LIST
58530: PUSH
58531: EMPTY
58532: LIST
58533: LIST
58534: LIST
58535: PUSH
58536: EMPTY
58537: LIST
58538: LIST
58539: PPUSH
58540: CALL_OW 72
58544: ST_TO_ADDR
58545: GO 58629
58547: LD_INT 4
58549: DOUBLE
58550: EQUAL
58551: IFTRUE 58555
58553: GO 58628
58555: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
58556: LD_ADDR_VAR 0 12
58560: PUSH
58561: LD_VAR 0 18
58565: PPUSH
58566: LD_INT 22
58568: PUSH
58569: LD_VAR 0 16
58573: PUSH
58574: EMPTY
58575: LIST
58576: LIST
58577: PUSH
58578: LD_INT 2
58580: PUSH
58581: LD_INT 30
58583: PUSH
58584: LD_INT 6
58586: PUSH
58587: EMPTY
58588: LIST
58589: LIST
58590: PUSH
58591: LD_INT 30
58593: PUSH
58594: LD_INT 7
58596: PUSH
58597: EMPTY
58598: LIST
58599: LIST
58600: PUSH
58601: LD_INT 30
58603: PUSH
58604: LD_INT 8
58606: PUSH
58607: EMPTY
58608: LIST
58609: LIST
58610: PUSH
58611: EMPTY
58612: LIST
58613: LIST
58614: LIST
58615: LIST
58616: PUSH
58617: EMPTY
58618: LIST
58619: LIST
58620: PPUSH
58621: CALL_OW 72
58625: ST_TO_ADDR
58626: GO 58629
58628: POP
// if i = 1 then
58629: LD_VAR 0 8
58633: PUSH
58634: LD_INT 1
58636: EQUAL
58637: IFFALSE 58748
// begin tmp := [ ] ;
58639: LD_ADDR_VAR 0 19
58643: PUSH
58644: EMPTY
58645: ST_TO_ADDR
// for j in f do
58646: LD_ADDR_VAR 0 9
58650: PUSH
58651: LD_VAR 0 12
58655: PUSH
58656: FOR_IN
58657: IFFALSE 58730
// if GetBType ( j ) = b_bunker then
58659: LD_VAR 0 9
58663: PPUSH
58664: CALL_OW 266
58668: PUSH
58669: LD_INT 32
58671: EQUAL
58672: IFFALSE 58699
// tmp := Insert ( tmp , 1 , j ) else
58674: LD_ADDR_VAR 0 19
58678: PUSH
58679: LD_VAR 0 19
58683: PPUSH
58684: LD_INT 1
58686: PPUSH
58687: LD_VAR 0 9
58691: PPUSH
58692: CALL_OW 2
58696: ST_TO_ADDR
58697: GO 58728
// tmp := Insert ( tmp , tmp + 1 , j ) ;
58699: LD_ADDR_VAR 0 19
58703: PUSH
58704: LD_VAR 0 19
58708: PPUSH
58709: LD_VAR 0 19
58713: PUSH
58714: LD_INT 1
58716: PLUS
58717: PPUSH
58718: LD_VAR 0 9
58722: PPUSH
58723: CALL_OW 2
58727: ST_TO_ADDR
58728: GO 58656
58730: POP
58731: POP
// if tmp then
58732: LD_VAR 0 19
58736: IFFALSE 58748
// f := tmp ;
58738: LD_ADDR_VAR 0 12
58742: PUSH
58743: LD_VAR 0 19
58747: ST_TO_ADDR
// end ; x := personel [ i ] ;
58748: LD_ADDR_VAR 0 13
58752: PUSH
58753: LD_VAR 0 6
58757: PUSH
58758: LD_VAR 0 8
58762: ARRAY
58763: ST_TO_ADDR
// if x = - 1 then
58764: LD_VAR 0 13
58768: PUSH
58769: LD_INT 1
58771: NEG
58772: EQUAL
58773: IFFALSE 58982
// begin for j in f do
58775: LD_ADDR_VAR 0 9
58779: PUSH
58780: LD_VAR 0 12
58784: PUSH
58785: FOR_IN
58786: IFFALSE 58978
// repeat InitHc ;
58788: CALL_OW 19
// if GetBType ( j ) = b_barracks then
58792: LD_VAR 0 9
58796: PPUSH
58797: CALL_OW 266
58801: PUSH
58802: LD_INT 5
58804: EQUAL
58805: IFFALSE 58875
// begin if UnitsInside ( j ) < 3 then
58807: LD_VAR 0 9
58811: PPUSH
58812: CALL_OW 313
58816: PUSH
58817: LD_INT 3
58819: LESS
58820: IFFALSE 58856
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
58822: LD_INT 0
58824: PPUSH
58825: LD_INT 5
58827: PUSH
58828: LD_INT 8
58830: PUSH
58831: LD_INT 9
58833: PUSH
58834: EMPTY
58835: LIST
58836: LIST
58837: LIST
58838: PUSH
58839: LD_VAR 0 17
58843: ARRAY
58844: PPUSH
58845: LD_VAR 0 4
58849: PPUSH
58850: CALL_OW 380
58854: GO 58873
// PrepareHuman ( false , i , skill ) ;
58856: LD_INT 0
58858: PPUSH
58859: LD_VAR 0 8
58863: PPUSH
58864: LD_VAR 0 4
58868: PPUSH
58869: CALL_OW 380
// end else
58873: GO 58892
// PrepareHuman ( false , i , skill ) ;
58875: LD_INT 0
58877: PPUSH
58878: LD_VAR 0 8
58882: PPUSH
58883: LD_VAR 0 4
58887: PPUSH
58888: CALL_OW 380
// un := CreateHuman ;
58892: LD_ADDR_VAR 0 14
58896: PUSH
58897: CALL_OW 44
58901: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58902: LD_ADDR_VAR 0 7
58906: PUSH
58907: LD_VAR 0 7
58911: PPUSH
58912: LD_INT 1
58914: PPUSH
58915: LD_VAR 0 14
58919: PPUSH
58920: CALL_OW 2
58924: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
58925: LD_VAR 0 14
58929: PPUSH
58930: LD_VAR 0 9
58934: PPUSH
58935: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
58939: LD_VAR 0 9
58943: PPUSH
58944: CALL_OW 313
58948: PUSH
58949: LD_INT 6
58951: EQUAL
58952: PUSH
58953: LD_VAR 0 9
58957: PPUSH
58958: CALL_OW 266
58962: PUSH
58963: LD_INT 32
58965: PUSH
58966: LD_INT 31
58968: PUSH
58969: EMPTY
58970: LIST
58971: LIST
58972: IN
58973: OR
58974: IFFALSE 58788
58976: GO 58785
58978: POP
58979: POP
// end else
58980: GO 59362
// for j = 1 to x do
58982: LD_ADDR_VAR 0 9
58986: PUSH
58987: DOUBLE
58988: LD_INT 1
58990: DEC
58991: ST_TO_ADDR
58992: LD_VAR 0 13
58996: PUSH
58997: FOR_TO
58998: IFFALSE 59360
// begin InitHc ;
59000: CALL_OW 19
// if not f then
59004: LD_VAR 0 12
59008: NOT
59009: IFFALSE 59098
// begin PrepareHuman ( false , i , skill ) ;
59011: LD_INT 0
59013: PPUSH
59014: LD_VAR 0 8
59018: PPUSH
59019: LD_VAR 0 4
59023: PPUSH
59024: CALL_OW 380
// un := CreateHuman ;
59028: LD_ADDR_VAR 0 14
59032: PUSH
59033: CALL_OW 44
59037: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
59038: LD_ADDR_VAR 0 7
59042: PUSH
59043: LD_VAR 0 7
59047: PPUSH
59048: LD_INT 1
59050: PPUSH
59051: LD_VAR 0 14
59055: PPUSH
59056: CALL_OW 2
59060: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
59061: LD_VAR 0 14
59065: PPUSH
59066: LD_VAR 0 1
59070: PPUSH
59071: CALL_OW 250
59075: PPUSH
59076: LD_VAR 0 1
59080: PPUSH
59081: CALL_OW 251
59085: PPUSH
59086: LD_INT 10
59088: PPUSH
59089: LD_INT 0
59091: PPUSH
59092: CALL_OW 50
// continue ;
59096: GO 58997
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
59098: LD_VAR 0 12
59102: PUSH
59103: LD_INT 1
59105: ARRAY
59106: PPUSH
59107: CALL_OW 313
59111: PUSH
59112: LD_VAR 0 12
59116: PUSH
59117: LD_INT 1
59119: ARRAY
59120: PPUSH
59121: CALL_OW 266
59125: PUSH
59126: LD_INT 32
59128: PUSH
59129: LD_INT 31
59131: PUSH
59132: EMPTY
59133: LIST
59134: LIST
59135: IN
59136: AND
59137: PUSH
59138: LD_VAR 0 12
59142: PUSH
59143: LD_INT 1
59145: ARRAY
59146: PPUSH
59147: CALL_OW 313
59151: PUSH
59152: LD_INT 6
59154: EQUAL
59155: OR
59156: IFFALSE 59176
// f := Delete ( f , 1 ) ;
59158: LD_ADDR_VAR 0 12
59162: PUSH
59163: LD_VAR 0 12
59167: PPUSH
59168: LD_INT 1
59170: PPUSH
59171: CALL_OW 3
59175: ST_TO_ADDR
// if not f then
59176: LD_VAR 0 12
59180: NOT
59181: IFFALSE 59199
// begin x := x + 2 ;
59183: LD_ADDR_VAR 0 13
59187: PUSH
59188: LD_VAR 0 13
59192: PUSH
59193: LD_INT 2
59195: PLUS
59196: ST_TO_ADDR
// continue ;
59197: GO 58997
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
59199: LD_VAR 0 12
59203: PUSH
59204: LD_INT 1
59206: ARRAY
59207: PPUSH
59208: CALL_OW 266
59212: PUSH
59213: LD_INT 5
59215: EQUAL
59216: IFFALSE 59290
// begin if UnitsInside ( f [ 1 ] ) < 3 then
59218: LD_VAR 0 12
59222: PUSH
59223: LD_INT 1
59225: ARRAY
59226: PPUSH
59227: CALL_OW 313
59231: PUSH
59232: LD_INT 3
59234: LESS
59235: IFFALSE 59271
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
59237: LD_INT 0
59239: PPUSH
59240: LD_INT 5
59242: PUSH
59243: LD_INT 8
59245: PUSH
59246: LD_INT 9
59248: PUSH
59249: EMPTY
59250: LIST
59251: LIST
59252: LIST
59253: PUSH
59254: LD_VAR 0 17
59258: ARRAY
59259: PPUSH
59260: LD_VAR 0 4
59264: PPUSH
59265: CALL_OW 380
59269: GO 59288
// PrepareHuman ( false , i , skill ) ;
59271: LD_INT 0
59273: PPUSH
59274: LD_VAR 0 8
59278: PPUSH
59279: LD_VAR 0 4
59283: PPUSH
59284: CALL_OW 380
// end else
59288: GO 59307
// PrepareHuman ( false , i , skill ) ;
59290: LD_INT 0
59292: PPUSH
59293: LD_VAR 0 8
59297: PPUSH
59298: LD_VAR 0 4
59302: PPUSH
59303: CALL_OW 380
// un := CreateHuman ;
59307: LD_ADDR_VAR 0 14
59311: PUSH
59312: CALL_OW 44
59316: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
59317: LD_ADDR_VAR 0 7
59321: PUSH
59322: LD_VAR 0 7
59326: PPUSH
59327: LD_INT 1
59329: PPUSH
59330: LD_VAR 0 14
59334: PPUSH
59335: CALL_OW 2
59339: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
59340: LD_VAR 0 14
59344: PPUSH
59345: LD_VAR 0 12
59349: PUSH
59350: LD_INT 1
59352: ARRAY
59353: PPUSH
59354: CALL_OW 52
// end ;
59358: GO 58997
59360: POP
59361: POP
// end ;
59362: GO 58299
59364: POP
59365: POP
// result := result ^ buildings ;
59366: LD_ADDR_VAR 0 7
59370: PUSH
59371: LD_VAR 0 7
59375: PUSH
59376: LD_VAR 0 18
59380: ADD
59381: ST_TO_ADDR
// end else
59382: GO 59525
// begin for i = 1 to personel do
59384: LD_ADDR_VAR 0 8
59388: PUSH
59389: DOUBLE
59390: LD_INT 1
59392: DEC
59393: ST_TO_ADDR
59394: LD_VAR 0 6
59398: PUSH
59399: FOR_TO
59400: IFFALSE 59523
// begin if i > 4 then
59402: LD_VAR 0 8
59406: PUSH
59407: LD_INT 4
59409: GREATER
59410: IFFALSE 59414
// break ;
59412: GO 59523
// x := personel [ i ] ;
59414: LD_ADDR_VAR 0 13
59418: PUSH
59419: LD_VAR 0 6
59423: PUSH
59424: LD_VAR 0 8
59428: ARRAY
59429: ST_TO_ADDR
// if x = - 1 then
59430: LD_VAR 0 13
59434: PUSH
59435: LD_INT 1
59437: NEG
59438: EQUAL
59439: IFFALSE 59443
// continue ;
59441: GO 59399
// PrepareHuman ( false , i , skill ) ;
59443: LD_INT 0
59445: PPUSH
59446: LD_VAR 0 8
59450: PPUSH
59451: LD_VAR 0 4
59455: PPUSH
59456: CALL_OW 380
// un := CreateHuman ;
59460: LD_ADDR_VAR 0 14
59464: PUSH
59465: CALL_OW 44
59469: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
59470: LD_VAR 0 14
59474: PPUSH
59475: LD_VAR 0 1
59479: PPUSH
59480: CALL_OW 250
59484: PPUSH
59485: LD_VAR 0 1
59489: PPUSH
59490: CALL_OW 251
59494: PPUSH
59495: LD_INT 10
59497: PPUSH
59498: LD_INT 0
59500: PPUSH
59501: CALL_OW 50
// result := result ^ un ;
59505: LD_ADDR_VAR 0 7
59509: PUSH
59510: LD_VAR 0 7
59514: PUSH
59515: LD_VAR 0 14
59519: ADD
59520: ST_TO_ADDR
// end ;
59521: GO 59399
59523: POP
59524: POP
// end ; end ;
59525: LD_VAR 0 7
59529: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
59530: LD_INT 0
59532: PPUSH
59533: PPUSH
59534: PPUSH
59535: PPUSH
59536: PPUSH
59537: PPUSH
59538: PPUSH
59539: PPUSH
59540: PPUSH
59541: PPUSH
59542: PPUSH
59543: PPUSH
59544: PPUSH
59545: PPUSH
59546: PPUSH
59547: PPUSH
// result := false ;
59548: LD_ADDR_VAR 0 3
59552: PUSH
59553: LD_INT 0
59555: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
59556: LD_VAR 0 1
59560: NOT
59561: PUSH
59562: LD_VAR 0 1
59566: PPUSH
59567: CALL_OW 266
59571: PUSH
59572: LD_INT 32
59574: PUSH
59575: LD_INT 33
59577: PUSH
59578: EMPTY
59579: LIST
59580: LIST
59581: IN
59582: NOT
59583: OR
59584: IFFALSE 59588
// exit ;
59586: GO 60697
// nat := GetNation ( tower ) ;
59588: LD_ADDR_VAR 0 12
59592: PUSH
59593: LD_VAR 0 1
59597: PPUSH
59598: CALL_OW 248
59602: ST_TO_ADDR
// side := GetSide ( tower ) ;
59603: LD_ADDR_VAR 0 16
59607: PUSH
59608: LD_VAR 0 1
59612: PPUSH
59613: CALL_OW 255
59617: ST_TO_ADDR
// x := GetX ( tower ) ;
59618: LD_ADDR_VAR 0 10
59622: PUSH
59623: LD_VAR 0 1
59627: PPUSH
59628: CALL_OW 250
59632: ST_TO_ADDR
// y := GetY ( tower ) ;
59633: LD_ADDR_VAR 0 11
59637: PUSH
59638: LD_VAR 0 1
59642: PPUSH
59643: CALL_OW 251
59647: ST_TO_ADDR
// if not x or not y then
59648: LD_VAR 0 10
59652: NOT
59653: PUSH
59654: LD_VAR 0 11
59658: NOT
59659: OR
59660: IFFALSE 59664
// exit ;
59662: GO 60697
// weapon := 0 ;
59664: LD_ADDR_VAR 0 18
59668: PUSH
59669: LD_INT 0
59671: ST_TO_ADDR
// fac_list := [ ] ;
59672: LD_ADDR_VAR 0 17
59676: PUSH
59677: EMPTY
59678: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
59679: LD_ADDR_VAR 0 6
59683: PUSH
59684: LD_VAR 0 1
59688: PPUSH
59689: CALL_OW 274
59693: PPUSH
59694: LD_VAR 0 2
59698: PPUSH
59699: LD_INT 0
59701: PPUSH
59702: CALL 57268 0 3
59706: PPUSH
59707: LD_INT 30
59709: PUSH
59710: LD_INT 3
59712: PUSH
59713: EMPTY
59714: LIST
59715: LIST
59716: PPUSH
59717: CALL_OW 72
59721: ST_TO_ADDR
// if not factories then
59722: LD_VAR 0 6
59726: NOT
59727: IFFALSE 59731
// exit ;
59729: GO 60697
// for i in factories do
59731: LD_ADDR_VAR 0 8
59735: PUSH
59736: LD_VAR 0 6
59740: PUSH
59741: FOR_IN
59742: IFFALSE 59767
// fac_list := fac_list union AvailableWeaponList ( i ) ;
59744: LD_ADDR_VAR 0 17
59748: PUSH
59749: LD_VAR 0 17
59753: PUSH
59754: LD_VAR 0 8
59758: PPUSH
59759: CALL_OW 478
59763: UNION
59764: ST_TO_ADDR
59765: GO 59741
59767: POP
59768: POP
// if not fac_list then
59769: LD_VAR 0 17
59773: NOT
59774: IFFALSE 59778
// exit ;
59776: GO 60697
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
59778: LD_ADDR_VAR 0 5
59782: PUSH
59783: LD_INT 4
59785: PUSH
59786: LD_INT 5
59788: PUSH
59789: LD_INT 9
59791: PUSH
59792: LD_INT 10
59794: PUSH
59795: LD_INT 6
59797: PUSH
59798: LD_INT 7
59800: PUSH
59801: LD_INT 11
59803: PUSH
59804: EMPTY
59805: LIST
59806: LIST
59807: LIST
59808: LIST
59809: LIST
59810: LIST
59811: LIST
59812: PUSH
59813: LD_INT 27
59815: PUSH
59816: LD_INT 28
59818: PUSH
59819: LD_INT 26
59821: PUSH
59822: LD_INT 30
59824: PUSH
59825: EMPTY
59826: LIST
59827: LIST
59828: LIST
59829: LIST
59830: PUSH
59831: LD_INT 43
59833: PUSH
59834: LD_INT 44
59836: PUSH
59837: LD_INT 46
59839: PUSH
59840: LD_INT 45
59842: PUSH
59843: LD_INT 47
59845: PUSH
59846: LD_INT 49
59848: PUSH
59849: EMPTY
59850: LIST
59851: LIST
59852: LIST
59853: LIST
59854: LIST
59855: LIST
59856: PUSH
59857: EMPTY
59858: LIST
59859: LIST
59860: LIST
59861: PUSH
59862: LD_VAR 0 12
59866: ARRAY
59867: ST_TO_ADDR
// list := list isect fac_list ;
59868: LD_ADDR_VAR 0 5
59872: PUSH
59873: LD_VAR 0 5
59877: PUSH
59878: LD_VAR 0 17
59882: ISECT
59883: ST_TO_ADDR
// if not list then
59884: LD_VAR 0 5
59888: NOT
59889: IFFALSE 59893
// exit ;
59891: GO 60697
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
59893: LD_VAR 0 12
59897: PUSH
59898: LD_INT 3
59900: EQUAL
59901: PUSH
59902: LD_INT 49
59904: PUSH
59905: LD_VAR 0 5
59909: IN
59910: AND
59911: PUSH
59912: LD_INT 31
59914: PPUSH
59915: LD_VAR 0 16
59919: PPUSH
59920: CALL_OW 321
59924: PUSH
59925: LD_INT 2
59927: EQUAL
59928: AND
59929: IFFALSE 59989
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
59931: LD_INT 22
59933: PUSH
59934: LD_VAR 0 16
59938: PUSH
59939: EMPTY
59940: LIST
59941: LIST
59942: PUSH
59943: LD_INT 35
59945: PUSH
59946: LD_INT 49
59948: PUSH
59949: EMPTY
59950: LIST
59951: LIST
59952: PUSH
59953: LD_INT 91
59955: PUSH
59956: LD_VAR 0 1
59960: PUSH
59961: LD_INT 10
59963: PUSH
59964: EMPTY
59965: LIST
59966: LIST
59967: LIST
59968: PUSH
59969: EMPTY
59970: LIST
59971: LIST
59972: LIST
59973: PPUSH
59974: CALL_OW 69
59978: NOT
59979: IFFALSE 59989
// weapon := ru_time_lapser ;
59981: LD_ADDR_VAR 0 18
59985: PUSH
59986: LD_INT 49
59988: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
59989: LD_VAR 0 12
59993: PUSH
59994: LD_INT 1
59996: PUSH
59997: LD_INT 2
59999: PUSH
60000: EMPTY
60001: LIST
60002: LIST
60003: IN
60004: PUSH
60005: LD_INT 11
60007: PUSH
60008: LD_VAR 0 5
60012: IN
60013: PUSH
60014: LD_INT 30
60016: PUSH
60017: LD_VAR 0 5
60021: IN
60022: OR
60023: AND
60024: PUSH
60025: LD_INT 6
60027: PPUSH
60028: LD_VAR 0 16
60032: PPUSH
60033: CALL_OW 321
60037: PUSH
60038: LD_INT 2
60040: EQUAL
60041: AND
60042: IFFALSE 60207
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
60044: LD_INT 22
60046: PUSH
60047: LD_VAR 0 16
60051: PUSH
60052: EMPTY
60053: LIST
60054: LIST
60055: PUSH
60056: LD_INT 2
60058: PUSH
60059: LD_INT 35
60061: PUSH
60062: LD_INT 11
60064: PUSH
60065: EMPTY
60066: LIST
60067: LIST
60068: PUSH
60069: LD_INT 35
60071: PUSH
60072: LD_INT 30
60074: PUSH
60075: EMPTY
60076: LIST
60077: LIST
60078: PUSH
60079: EMPTY
60080: LIST
60081: LIST
60082: LIST
60083: PUSH
60084: LD_INT 91
60086: PUSH
60087: LD_VAR 0 1
60091: PUSH
60092: LD_INT 18
60094: PUSH
60095: EMPTY
60096: LIST
60097: LIST
60098: LIST
60099: PUSH
60100: EMPTY
60101: LIST
60102: LIST
60103: LIST
60104: PPUSH
60105: CALL_OW 69
60109: NOT
60110: PUSH
60111: LD_INT 22
60113: PUSH
60114: LD_VAR 0 16
60118: PUSH
60119: EMPTY
60120: LIST
60121: LIST
60122: PUSH
60123: LD_INT 2
60125: PUSH
60126: LD_INT 30
60128: PUSH
60129: LD_INT 32
60131: PUSH
60132: EMPTY
60133: LIST
60134: LIST
60135: PUSH
60136: LD_INT 30
60138: PUSH
60139: LD_INT 33
60141: PUSH
60142: EMPTY
60143: LIST
60144: LIST
60145: PUSH
60146: EMPTY
60147: LIST
60148: LIST
60149: LIST
60150: PUSH
60151: LD_INT 91
60153: PUSH
60154: LD_VAR 0 1
60158: PUSH
60159: LD_INT 12
60161: PUSH
60162: EMPTY
60163: LIST
60164: LIST
60165: LIST
60166: PUSH
60167: EMPTY
60168: LIST
60169: LIST
60170: LIST
60171: PUSH
60172: EMPTY
60173: LIST
60174: PPUSH
60175: CALL_OW 69
60179: PUSH
60180: LD_INT 2
60182: GREATER
60183: AND
60184: IFFALSE 60207
// weapon := [ us_radar , ar_radar ] [ nat ] ;
60186: LD_ADDR_VAR 0 18
60190: PUSH
60191: LD_INT 11
60193: PUSH
60194: LD_INT 30
60196: PUSH
60197: EMPTY
60198: LIST
60199: LIST
60200: PUSH
60201: LD_VAR 0 12
60205: ARRAY
60206: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
60207: LD_VAR 0 18
60211: NOT
60212: PUSH
60213: LD_INT 40
60215: PPUSH
60216: LD_VAR 0 16
60220: PPUSH
60221: CALL_OW 321
60225: PUSH
60226: LD_INT 2
60228: EQUAL
60229: AND
60230: PUSH
60231: LD_INT 7
60233: PUSH
60234: LD_VAR 0 5
60238: IN
60239: PUSH
60240: LD_INT 28
60242: PUSH
60243: LD_VAR 0 5
60247: IN
60248: OR
60249: PUSH
60250: LD_INT 45
60252: PUSH
60253: LD_VAR 0 5
60257: IN
60258: OR
60259: AND
60260: IFFALSE 60514
// begin hex := GetHexInfo ( x , y ) ;
60262: LD_ADDR_VAR 0 4
60266: PUSH
60267: LD_VAR 0 10
60271: PPUSH
60272: LD_VAR 0 11
60276: PPUSH
60277: CALL_OW 546
60281: ST_TO_ADDR
// if hex [ 1 ] then
60282: LD_VAR 0 4
60286: PUSH
60287: LD_INT 1
60289: ARRAY
60290: IFFALSE 60294
// exit ;
60292: GO 60697
// height := hex [ 2 ] ;
60294: LD_ADDR_VAR 0 15
60298: PUSH
60299: LD_VAR 0 4
60303: PUSH
60304: LD_INT 2
60306: ARRAY
60307: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
60308: LD_ADDR_VAR 0 14
60312: PUSH
60313: LD_INT 0
60315: PUSH
60316: LD_INT 2
60318: PUSH
60319: LD_INT 3
60321: PUSH
60322: LD_INT 5
60324: PUSH
60325: EMPTY
60326: LIST
60327: LIST
60328: LIST
60329: LIST
60330: ST_TO_ADDR
// for i in tmp do
60331: LD_ADDR_VAR 0 8
60335: PUSH
60336: LD_VAR 0 14
60340: PUSH
60341: FOR_IN
60342: IFFALSE 60512
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
60344: LD_ADDR_VAR 0 9
60348: PUSH
60349: LD_VAR 0 10
60353: PPUSH
60354: LD_VAR 0 8
60358: PPUSH
60359: LD_INT 5
60361: PPUSH
60362: CALL_OW 272
60366: PUSH
60367: LD_VAR 0 11
60371: PPUSH
60372: LD_VAR 0 8
60376: PPUSH
60377: LD_INT 5
60379: PPUSH
60380: CALL_OW 273
60384: PUSH
60385: EMPTY
60386: LIST
60387: LIST
60388: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
60389: LD_VAR 0 9
60393: PUSH
60394: LD_INT 1
60396: ARRAY
60397: PPUSH
60398: LD_VAR 0 9
60402: PUSH
60403: LD_INT 2
60405: ARRAY
60406: PPUSH
60407: CALL_OW 488
60411: IFFALSE 60510
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
60413: LD_ADDR_VAR 0 4
60417: PUSH
60418: LD_VAR 0 9
60422: PUSH
60423: LD_INT 1
60425: ARRAY
60426: PPUSH
60427: LD_VAR 0 9
60431: PUSH
60432: LD_INT 2
60434: ARRAY
60435: PPUSH
60436: CALL_OW 546
60440: ST_TO_ADDR
// if hex [ 1 ] then
60441: LD_VAR 0 4
60445: PUSH
60446: LD_INT 1
60448: ARRAY
60449: IFFALSE 60453
// continue ;
60451: GO 60341
// h := hex [ 2 ] ;
60453: LD_ADDR_VAR 0 13
60457: PUSH
60458: LD_VAR 0 4
60462: PUSH
60463: LD_INT 2
60465: ARRAY
60466: ST_TO_ADDR
// if h + 7 < height then
60467: LD_VAR 0 13
60471: PUSH
60472: LD_INT 7
60474: PLUS
60475: PUSH
60476: LD_VAR 0 15
60480: LESS
60481: IFFALSE 60510
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
60483: LD_ADDR_VAR 0 18
60487: PUSH
60488: LD_INT 7
60490: PUSH
60491: LD_INT 28
60493: PUSH
60494: LD_INT 45
60496: PUSH
60497: EMPTY
60498: LIST
60499: LIST
60500: LIST
60501: PUSH
60502: LD_VAR 0 12
60506: ARRAY
60507: ST_TO_ADDR
// break ;
60508: GO 60512
// end ; end ; end ;
60510: GO 60341
60512: POP
60513: POP
// end ; if not weapon then
60514: LD_VAR 0 18
60518: NOT
60519: IFFALSE 60579
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
60521: LD_ADDR_VAR 0 5
60525: PUSH
60526: LD_VAR 0 5
60530: PUSH
60531: LD_INT 11
60533: PUSH
60534: LD_INT 30
60536: PUSH
60537: LD_INT 49
60539: PUSH
60540: EMPTY
60541: LIST
60542: LIST
60543: LIST
60544: DIFF
60545: ST_TO_ADDR
// if not list then
60546: LD_VAR 0 5
60550: NOT
60551: IFFALSE 60555
// exit ;
60553: GO 60697
// weapon := list [ rand ( 1 , list ) ] ;
60555: LD_ADDR_VAR 0 18
60559: PUSH
60560: LD_VAR 0 5
60564: PUSH
60565: LD_INT 1
60567: PPUSH
60568: LD_VAR 0 5
60572: PPUSH
60573: CALL_OW 12
60577: ARRAY
60578: ST_TO_ADDR
// end ; if weapon then
60579: LD_VAR 0 18
60583: IFFALSE 60697
// begin tmp := CostOfWeapon ( weapon ) ;
60585: LD_ADDR_VAR 0 14
60589: PUSH
60590: LD_VAR 0 18
60594: PPUSH
60595: CALL_OW 451
60599: ST_TO_ADDR
// j := GetBase ( tower ) ;
60600: LD_ADDR_VAR 0 9
60604: PUSH
60605: LD_VAR 0 1
60609: PPUSH
60610: CALL_OW 274
60614: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
60615: LD_VAR 0 9
60619: PPUSH
60620: LD_INT 1
60622: PPUSH
60623: CALL_OW 275
60627: PUSH
60628: LD_VAR 0 14
60632: PUSH
60633: LD_INT 1
60635: ARRAY
60636: GREATEREQUAL
60637: PUSH
60638: LD_VAR 0 9
60642: PPUSH
60643: LD_INT 2
60645: PPUSH
60646: CALL_OW 275
60650: PUSH
60651: LD_VAR 0 14
60655: PUSH
60656: LD_INT 2
60658: ARRAY
60659: GREATEREQUAL
60660: AND
60661: PUSH
60662: LD_VAR 0 9
60666: PPUSH
60667: LD_INT 3
60669: PPUSH
60670: CALL_OW 275
60674: PUSH
60675: LD_VAR 0 14
60679: PUSH
60680: LD_INT 3
60682: ARRAY
60683: GREATEREQUAL
60684: AND
60685: IFFALSE 60697
// result := weapon ;
60687: LD_ADDR_VAR 0 3
60691: PUSH
60692: LD_VAR 0 18
60696: ST_TO_ADDR
// end ; end ;
60697: LD_VAR 0 3
60701: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
60702: LD_INT 0
60704: PPUSH
60705: PPUSH
// result := true ;
60706: LD_ADDR_VAR 0 3
60710: PUSH
60711: LD_INT 1
60713: ST_TO_ADDR
// if array1 = array2 then
60714: LD_VAR 0 1
60718: PUSH
60719: LD_VAR 0 2
60723: EQUAL
60724: IFFALSE 60784
// begin for i = 1 to array1 do
60726: LD_ADDR_VAR 0 4
60730: PUSH
60731: DOUBLE
60732: LD_INT 1
60734: DEC
60735: ST_TO_ADDR
60736: LD_VAR 0 1
60740: PUSH
60741: FOR_TO
60742: IFFALSE 60780
// if array1 [ i ] <> array2 [ i ] then
60744: LD_VAR 0 1
60748: PUSH
60749: LD_VAR 0 4
60753: ARRAY
60754: PUSH
60755: LD_VAR 0 2
60759: PUSH
60760: LD_VAR 0 4
60764: ARRAY
60765: NONEQUAL
60766: IFFALSE 60778
// begin result := false ;
60768: LD_ADDR_VAR 0 3
60772: PUSH
60773: LD_INT 0
60775: ST_TO_ADDR
// break ;
60776: GO 60780
// end ;
60778: GO 60741
60780: POP
60781: POP
// end else
60782: GO 60792
// result := false ;
60784: LD_ADDR_VAR 0 3
60788: PUSH
60789: LD_INT 0
60791: ST_TO_ADDR
// end ;
60792: LD_VAR 0 3
60796: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
60797: LD_INT 0
60799: PPUSH
60800: PPUSH
// if not array1 or not array2 then
60801: LD_VAR 0 1
60805: NOT
60806: PUSH
60807: LD_VAR 0 2
60811: NOT
60812: OR
60813: IFFALSE 60817
// exit ;
60815: GO 60881
// result := true ;
60817: LD_ADDR_VAR 0 3
60821: PUSH
60822: LD_INT 1
60824: ST_TO_ADDR
// for i = 1 to array1 do
60825: LD_ADDR_VAR 0 4
60829: PUSH
60830: DOUBLE
60831: LD_INT 1
60833: DEC
60834: ST_TO_ADDR
60835: LD_VAR 0 1
60839: PUSH
60840: FOR_TO
60841: IFFALSE 60879
// if array1 [ i ] <> array2 [ i ] then
60843: LD_VAR 0 1
60847: PUSH
60848: LD_VAR 0 4
60852: ARRAY
60853: PUSH
60854: LD_VAR 0 2
60858: PUSH
60859: LD_VAR 0 4
60863: ARRAY
60864: NONEQUAL
60865: IFFALSE 60877
// begin result := false ;
60867: LD_ADDR_VAR 0 3
60871: PUSH
60872: LD_INT 0
60874: ST_TO_ADDR
// break ;
60875: GO 60879
// end ;
60877: GO 60840
60879: POP
60880: POP
// end ;
60881: LD_VAR 0 3
60885: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
60886: LD_INT 0
60888: PPUSH
60889: PPUSH
60890: PPUSH
// pom := GetBase ( fac ) ;
60891: LD_ADDR_VAR 0 5
60895: PUSH
60896: LD_VAR 0 1
60900: PPUSH
60901: CALL_OW 274
60905: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
60906: LD_ADDR_VAR 0 4
60910: PUSH
60911: LD_VAR 0 2
60915: PUSH
60916: LD_INT 1
60918: ARRAY
60919: PPUSH
60920: LD_VAR 0 2
60924: PUSH
60925: LD_INT 2
60927: ARRAY
60928: PPUSH
60929: LD_VAR 0 2
60933: PUSH
60934: LD_INT 3
60936: ARRAY
60937: PPUSH
60938: LD_VAR 0 2
60942: PUSH
60943: LD_INT 4
60945: ARRAY
60946: PPUSH
60947: CALL_OW 449
60951: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60952: LD_ADDR_VAR 0 3
60956: PUSH
60957: LD_VAR 0 5
60961: PPUSH
60962: LD_INT 1
60964: PPUSH
60965: CALL_OW 275
60969: PUSH
60970: LD_VAR 0 4
60974: PUSH
60975: LD_INT 1
60977: ARRAY
60978: GREATEREQUAL
60979: PUSH
60980: LD_VAR 0 5
60984: PPUSH
60985: LD_INT 2
60987: PPUSH
60988: CALL_OW 275
60992: PUSH
60993: LD_VAR 0 4
60997: PUSH
60998: LD_INT 2
61000: ARRAY
61001: GREATEREQUAL
61002: AND
61003: PUSH
61004: LD_VAR 0 5
61008: PPUSH
61009: LD_INT 3
61011: PPUSH
61012: CALL_OW 275
61016: PUSH
61017: LD_VAR 0 4
61021: PUSH
61022: LD_INT 3
61024: ARRAY
61025: GREATEREQUAL
61026: AND
61027: ST_TO_ADDR
// end ;
61028: LD_VAR 0 3
61032: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
61033: LD_INT 0
61035: PPUSH
61036: PPUSH
61037: PPUSH
61038: PPUSH
// pom := GetBase ( building ) ;
61039: LD_ADDR_VAR 0 3
61043: PUSH
61044: LD_VAR 0 1
61048: PPUSH
61049: CALL_OW 274
61053: ST_TO_ADDR
// if not pom then
61054: LD_VAR 0 3
61058: NOT
61059: IFFALSE 61063
// exit ;
61061: GO 61233
// btype := GetBType ( building ) ;
61063: LD_ADDR_VAR 0 5
61067: PUSH
61068: LD_VAR 0 1
61072: PPUSH
61073: CALL_OW 266
61077: ST_TO_ADDR
// if btype = b_armoury then
61078: LD_VAR 0 5
61082: PUSH
61083: LD_INT 4
61085: EQUAL
61086: IFFALSE 61096
// btype := b_barracks ;
61088: LD_ADDR_VAR 0 5
61092: PUSH
61093: LD_INT 5
61095: ST_TO_ADDR
// if btype = b_depot then
61096: LD_VAR 0 5
61100: PUSH
61101: LD_INT 0
61103: EQUAL
61104: IFFALSE 61114
// btype := b_warehouse ;
61106: LD_ADDR_VAR 0 5
61110: PUSH
61111: LD_INT 1
61113: ST_TO_ADDR
// if btype = b_workshop then
61114: LD_VAR 0 5
61118: PUSH
61119: LD_INT 2
61121: EQUAL
61122: IFFALSE 61132
// btype := b_factory ;
61124: LD_ADDR_VAR 0 5
61128: PUSH
61129: LD_INT 3
61131: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
61132: LD_ADDR_VAR 0 4
61136: PUSH
61137: LD_VAR 0 5
61141: PPUSH
61142: LD_VAR 0 1
61146: PPUSH
61147: CALL_OW 248
61151: PPUSH
61152: CALL_OW 450
61156: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
61157: LD_ADDR_VAR 0 2
61161: PUSH
61162: LD_VAR 0 3
61166: PPUSH
61167: LD_INT 1
61169: PPUSH
61170: CALL_OW 275
61174: PUSH
61175: LD_VAR 0 4
61179: PUSH
61180: LD_INT 1
61182: ARRAY
61183: GREATEREQUAL
61184: PUSH
61185: LD_VAR 0 3
61189: PPUSH
61190: LD_INT 2
61192: PPUSH
61193: CALL_OW 275
61197: PUSH
61198: LD_VAR 0 4
61202: PUSH
61203: LD_INT 2
61205: ARRAY
61206: GREATEREQUAL
61207: AND
61208: PUSH
61209: LD_VAR 0 3
61213: PPUSH
61214: LD_INT 3
61216: PPUSH
61217: CALL_OW 275
61221: PUSH
61222: LD_VAR 0 4
61226: PUSH
61227: LD_INT 3
61229: ARRAY
61230: GREATEREQUAL
61231: AND
61232: ST_TO_ADDR
// end ;
61233: LD_VAR 0 2
61237: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
61238: LD_INT 0
61240: PPUSH
61241: PPUSH
61242: PPUSH
// pom := GetBase ( building ) ;
61243: LD_ADDR_VAR 0 4
61247: PUSH
61248: LD_VAR 0 1
61252: PPUSH
61253: CALL_OW 274
61257: ST_TO_ADDR
// if not pom then
61258: LD_VAR 0 4
61262: NOT
61263: IFFALSE 61267
// exit ;
61265: GO 61368
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
61267: LD_ADDR_VAR 0 5
61271: PUSH
61272: LD_VAR 0 2
61276: PPUSH
61277: LD_VAR 0 1
61281: PPUSH
61282: CALL_OW 248
61286: PPUSH
61287: CALL_OW 450
61291: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
61292: LD_ADDR_VAR 0 3
61296: PUSH
61297: LD_VAR 0 4
61301: PPUSH
61302: LD_INT 1
61304: PPUSH
61305: CALL_OW 275
61309: PUSH
61310: LD_VAR 0 5
61314: PUSH
61315: LD_INT 1
61317: ARRAY
61318: GREATEREQUAL
61319: PUSH
61320: LD_VAR 0 4
61324: PPUSH
61325: LD_INT 2
61327: PPUSH
61328: CALL_OW 275
61332: PUSH
61333: LD_VAR 0 5
61337: PUSH
61338: LD_INT 2
61340: ARRAY
61341: GREATEREQUAL
61342: AND
61343: PUSH
61344: LD_VAR 0 4
61348: PPUSH
61349: LD_INT 3
61351: PPUSH
61352: CALL_OW 275
61356: PUSH
61357: LD_VAR 0 5
61361: PUSH
61362: LD_INT 3
61364: ARRAY
61365: GREATEREQUAL
61366: AND
61367: ST_TO_ADDR
// end ;
61368: LD_VAR 0 3
61372: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
61373: LD_INT 0
61375: PPUSH
61376: PPUSH
61377: PPUSH
61378: PPUSH
61379: PPUSH
61380: PPUSH
61381: PPUSH
61382: PPUSH
61383: PPUSH
61384: PPUSH
61385: PPUSH
// result := false ;
61386: LD_ADDR_VAR 0 8
61390: PUSH
61391: LD_INT 0
61393: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
61394: LD_VAR 0 5
61398: NOT
61399: PUSH
61400: LD_VAR 0 1
61404: NOT
61405: OR
61406: PUSH
61407: LD_VAR 0 2
61411: NOT
61412: OR
61413: PUSH
61414: LD_VAR 0 3
61418: NOT
61419: OR
61420: IFFALSE 61424
// exit ;
61422: GO 62238
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
61424: LD_ADDR_VAR 0 14
61428: PUSH
61429: LD_VAR 0 1
61433: PPUSH
61434: LD_VAR 0 2
61438: PPUSH
61439: LD_VAR 0 3
61443: PPUSH
61444: LD_VAR 0 4
61448: PPUSH
61449: LD_VAR 0 5
61453: PUSH
61454: LD_INT 1
61456: ARRAY
61457: PPUSH
61458: CALL_OW 248
61462: PPUSH
61463: LD_INT 0
61465: PPUSH
61466: CALL 63491 0 6
61470: ST_TO_ADDR
// if not hexes then
61471: LD_VAR 0 14
61475: NOT
61476: IFFALSE 61480
// exit ;
61478: GO 62238
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
61480: LD_ADDR_VAR 0 17
61484: PUSH
61485: LD_VAR 0 5
61489: PPUSH
61490: LD_INT 22
61492: PUSH
61493: LD_VAR 0 13
61497: PPUSH
61498: CALL_OW 255
61502: PUSH
61503: EMPTY
61504: LIST
61505: LIST
61506: PUSH
61507: LD_INT 2
61509: PUSH
61510: LD_INT 30
61512: PUSH
61513: LD_INT 0
61515: PUSH
61516: EMPTY
61517: LIST
61518: LIST
61519: PUSH
61520: LD_INT 30
61522: PUSH
61523: LD_INT 1
61525: PUSH
61526: EMPTY
61527: LIST
61528: LIST
61529: PUSH
61530: EMPTY
61531: LIST
61532: LIST
61533: LIST
61534: PUSH
61535: EMPTY
61536: LIST
61537: LIST
61538: PPUSH
61539: CALL_OW 72
61543: ST_TO_ADDR
// for i = 1 to hexes do
61544: LD_ADDR_VAR 0 9
61548: PUSH
61549: DOUBLE
61550: LD_INT 1
61552: DEC
61553: ST_TO_ADDR
61554: LD_VAR 0 14
61558: PUSH
61559: FOR_TO
61560: IFFALSE 62236
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
61562: LD_ADDR_VAR 0 13
61566: PUSH
61567: LD_VAR 0 14
61571: PUSH
61572: LD_VAR 0 9
61576: ARRAY
61577: PUSH
61578: LD_INT 1
61580: ARRAY
61581: PPUSH
61582: LD_VAR 0 14
61586: PUSH
61587: LD_VAR 0 9
61591: ARRAY
61592: PUSH
61593: LD_INT 2
61595: ARRAY
61596: PPUSH
61597: CALL_OW 428
61601: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
61602: LD_VAR 0 14
61606: PUSH
61607: LD_VAR 0 9
61611: ARRAY
61612: PUSH
61613: LD_INT 1
61615: ARRAY
61616: PPUSH
61617: LD_VAR 0 14
61621: PUSH
61622: LD_VAR 0 9
61626: ARRAY
61627: PUSH
61628: LD_INT 2
61630: ARRAY
61631: PPUSH
61632: CALL_OW 351
61636: PUSH
61637: LD_VAR 0 14
61641: PUSH
61642: LD_VAR 0 9
61646: ARRAY
61647: PUSH
61648: LD_INT 1
61650: ARRAY
61651: PPUSH
61652: LD_VAR 0 14
61656: PUSH
61657: LD_VAR 0 9
61661: ARRAY
61662: PUSH
61663: LD_INT 2
61665: ARRAY
61666: PPUSH
61667: CALL_OW 488
61671: NOT
61672: OR
61673: PUSH
61674: LD_VAR 0 13
61678: PPUSH
61679: CALL_OW 247
61683: PUSH
61684: LD_INT 3
61686: EQUAL
61687: OR
61688: IFFALSE 61694
// exit ;
61690: POP
61691: POP
61692: GO 62238
// if not tmp then
61694: LD_VAR 0 13
61698: NOT
61699: IFFALSE 61703
// continue ;
61701: GO 61559
// result := true ;
61703: LD_ADDR_VAR 0 8
61707: PUSH
61708: LD_INT 1
61710: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
61711: LD_VAR 0 6
61715: PUSH
61716: LD_VAR 0 13
61720: PPUSH
61721: CALL_OW 247
61725: PUSH
61726: LD_INT 2
61728: EQUAL
61729: AND
61730: PUSH
61731: LD_VAR 0 13
61735: PPUSH
61736: CALL_OW 263
61740: PUSH
61741: LD_INT 1
61743: EQUAL
61744: AND
61745: IFFALSE 61909
// begin if IsDrivenBy ( tmp ) then
61747: LD_VAR 0 13
61751: PPUSH
61752: CALL_OW 311
61756: IFFALSE 61760
// continue ;
61758: GO 61559
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
61760: LD_VAR 0 6
61764: PPUSH
61765: LD_INT 3
61767: PUSH
61768: LD_INT 60
61770: PUSH
61771: EMPTY
61772: LIST
61773: PUSH
61774: EMPTY
61775: LIST
61776: LIST
61777: PUSH
61778: LD_INT 3
61780: PUSH
61781: LD_INT 55
61783: PUSH
61784: EMPTY
61785: LIST
61786: PUSH
61787: EMPTY
61788: LIST
61789: LIST
61790: PUSH
61791: EMPTY
61792: LIST
61793: LIST
61794: PPUSH
61795: CALL_OW 72
61799: IFFALSE 61907
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
61801: LD_ADDR_VAR 0 18
61805: PUSH
61806: LD_VAR 0 6
61810: PPUSH
61811: LD_INT 3
61813: PUSH
61814: LD_INT 60
61816: PUSH
61817: EMPTY
61818: LIST
61819: PUSH
61820: EMPTY
61821: LIST
61822: LIST
61823: PUSH
61824: LD_INT 3
61826: PUSH
61827: LD_INT 55
61829: PUSH
61830: EMPTY
61831: LIST
61832: PUSH
61833: EMPTY
61834: LIST
61835: LIST
61836: PUSH
61837: EMPTY
61838: LIST
61839: LIST
61840: PPUSH
61841: CALL_OW 72
61845: PUSH
61846: LD_INT 1
61848: ARRAY
61849: ST_TO_ADDR
// if IsInUnit ( driver ) then
61850: LD_VAR 0 18
61854: PPUSH
61855: CALL_OW 310
61859: IFFALSE 61870
// ComExit ( driver ) ;
61861: LD_VAR 0 18
61865: PPUSH
61866: CALL 87272 0 1
// AddComEnterUnit ( driver , tmp ) ;
61870: LD_VAR 0 18
61874: PPUSH
61875: LD_VAR 0 13
61879: PPUSH
61880: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
61884: LD_VAR 0 18
61888: PPUSH
61889: LD_VAR 0 7
61893: PPUSH
61894: CALL_OW 173
// AddComExitVehicle ( driver ) ;
61898: LD_VAR 0 18
61902: PPUSH
61903: CALL_OW 181
// end ; continue ;
61907: GO 61559
// end ; if not cleaners or not tmp in cleaners then
61909: LD_VAR 0 6
61913: NOT
61914: PUSH
61915: LD_VAR 0 13
61919: PUSH
61920: LD_VAR 0 6
61924: IN
61925: NOT
61926: OR
61927: IFFALSE 62234
// begin if dep then
61929: LD_VAR 0 17
61933: IFFALSE 62069
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
61935: LD_ADDR_VAR 0 16
61939: PUSH
61940: LD_VAR 0 17
61944: PUSH
61945: LD_INT 1
61947: ARRAY
61948: PPUSH
61949: CALL_OW 250
61953: PPUSH
61954: LD_VAR 0 17
61958: PUSH
61959: LD_INT 1
61961: ARRAY
61962: PPUSH
61963: CALL_OW 254
61967: PPUSH
61968: LD_INT 5
61970: PPUSH
61971: CALL_OW 272
61975: PUSH
61976: LD_VAR 0 17
61980: PUSH
61981: LD_INT 1
61983: ARRAY
61984: PPUSH
61985: CALL_OW 251
61989: PPUSH
61990: LD_VAR 0 17
61994: PUSH
61995: LD_INT 1
61997: ARRAY
61998: PPUSH
61999: CALL_OW 254
62003: PPUSH
62004: LD_INT 5
62006: PPUSH
62007: CALL_OW 273
62011: PUSH
62012: EMPTY
62013: LIST
62014: LIST
62015: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
62016: LD_VAR 0 16
62020: PUSH
62021: LD_INT 1
62023: ARRAY
62024: PPUSH
62025: LD_VAR 0 16
62029: PUSH
62030: LD_INT 2
62032: ARRAY
62033: PPUSH
62034: CALL_OW 488
62038: IFFALSE 62069
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
62040: LD_VAR 0 13
62044: PPUSH
62045: LD_VAR 0 16
62049: PUSH
62050: LD_INT 1
62052: ARRAY
62053: PPUSH
62054: LD_VAR 0 16
62058: PUSH
62059: LD_INT 2
62061: ARRAY
62062: PPUSH
62063: CALL_OW 111
// continue ;
62067: GO 61559
// end ; end ; r := GetDir ( tmp ) ;
62069: LD_ADDR_VAR 0 15
62073: PUSH
62074: LD_VAR 0 13
62078: PPUSH
62079: CALL_OW 254
62083: ST_TO_ADDR
// if r = 5 then
62084: LD_VAR 0 15
62088: PUSH
62089: LD_INT 5
62091: EQUAL
62092: IFFALSE 62102
// r := 0 ;
62094: LD_ADDR_VAR 0 15
62098: PUSH
62099: LD_INT 0
62101: ST_TO_ADDR
// for j = r to 5 do
62102: LD_ADDR_VAR 0 10
62106: PUSH
62107: DOUBLE
62108: LD_VAR 0 15
62112: DEC
62113: ST_TO_ADDR
62114: LD_INT 5
62116: PUSH
62117: FOR_TO
62118: IFFALSE 62232
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
62120: LD_ADDR_VAR 0 11
62124: PUSH
62125: LD_VAR 0 13
62129: PPUSH
62130: CALL_OW 250
62134: PPUSH
62135: LD_VAR 0 10
62139: PPUSH
62140: LD_INT 2
62142: PPUSH
62143: CALL_OW 272
62147: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
62148: LD_ADDR_VAR 0 12
62152: PUSH
62153: LD_VAR 0 13
62157: PPUSH
62158: CALL_OW 251
62162: PPUSH
62163: LD_VAR 0 10
62167: PPUSH
62168: LD_INT 2
62170: PPUSH
62171: CALL_OW 273
62175: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
62176: LD_VAR 0 11
62180: PPUSH
62181: LD_VAR 0 12
62185: PPUSH
62186: CALL_OW 488
62190: PUSH
62191: LD_VAR 0 11
62195: PPUSH
62196: LD_VAR 0 12
62200: PPUSH
62201: CALL_OW 428
62205: NOT
62206: AND
62207: IFFALSE 62230
// begin ComMoveXY ( tmp , _x , _y ) ;
62209: LD_VAR 0 13
62213: PPUSH
62214: LD_VAR 0 11
62218: PPUSH
62219: LD_VAR 0 12
62223: PPUSH
62224: CALL_OW 111
// break ;
62228: GO 62232
// end ; end ;
62230: GO 62117
62232: POP
62233: POP
// end ; end ;
62234: GO 61559
62236: POP
62237: POP
// end ;
62238: LD_VAR 0 8
62242: RET
// export function BuildingTechInvented ( side , btype ) ; begin
62243: LD_INT 0
62245: PPUSH
// result := true ;
62246: LD_ADDR_VAR 0 3
62250: PUSH
62251: LD_INT 1
62253: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
62254: LD_VAR 0 2
62258: PUSH
62259: LD_INT 24
62261: DOUBLE
62262: EQUAL
62263: IFTRUE 62273
62265: LD_INT 33
62267: DOUBLE
62268: EQUAL
62269: IFTRUE 62273
62271: GO 62298
62273: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
62274: LD_ADDR_VAR 0 3
62278: PUSH
62279: LD_INT 32
62281: PPUSH
62282: LD_VAR 0 1
62286: PPUSH
62287: CALL_OW 321
62291: PUSH
62292: LD_INT 2
62294: EQUAL
62295: ST_TO_ADDR
62296: GO 62614
62298: LD_INT 20
62300: DOUBLE
62301: EQUAL
62302: IFTRUE 62306
62304: GO 62331
62306: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
62307: LD_ADDR_VAR 0 3
62311: PUSH
62312: LD_INT 6
62314: PPUSH
62315: LD_VAR 0 1
62319: PPUSH
62320: CALL_OW 321
62324: PUSH
62325: LD_INT 2
62327: EQUAL
62328: ST_TO_ADDR
62329: GO 62614
62331: LD_INT 22
62333: DOUBLE
62334: EQUAL
62335: IFTRUE 62345
62337: LD_INT 36
62339: DOUBLE
62340: EQUAL
62341: IFTRUE 62345
62343: GO 62370
62345: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
62346: LD_ADDR_VAR 0 3
62350: PUSH
62351: LD_INT 15
62353: PPUSH
62354: LD_VAR 0 1
62358: PPUSH
62359: CALL_OW 321
62363: PUSH
62364: LD_INT 2
62366: EQUAL
62367: ST_TO_ADDR
62368: GO 62614
62370: LD_INT 30
62372: DOUBLE
62373: EQUAL
62374: IFTRUE 62378
62376: GO 62403
62378: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
62379: LD_ADDR_VAR 0 3
62383: PUSH
62384: LD_INT 20
62386: PPUSH
62387: LD_VAR 0 1
62391: PPUSH
62392: CALL_OW 321
62396: PUSH
62397: LD_INT 2
62399: EQUAL
62400: ST_TO_ADDR
62401: GO 62614
62403: LD_INT 28
62405: DOUBLE
62406: EQUAL
62407: IFTRUE 62417
62409: LD_INT 21
62411: DOUBLE
62412: EQUAL
62413: IFTRUE 62417
62415: GO 62442
62417: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
62418: LD_ADDR_VAR 0 3
62422: PUSH
62423: LD_INT 21
62425: PPUSH
62426: LD_VAR 0 1
62430: PPUSH
62431: CALL_OW 321
62435: PUSH
62436: LD_INT 2
62438: EQUAL
62439: ST_TO_ADDR
62440: GO 62614
62442: LD_INT 16
62444: DOUBLE
62445: EQUAL
62446: IFTRUE 62450
62448: GO 62475
62450: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
62451: LD_ADDR_VAR 0 3
62455: PUSH
62456: LD_INT 84
62458: PPUSH
62459: LD_VAR 0 1
62463: PPUSH
62464: CALL_OW 321
62468: PUSH
62469: LD_INT 2
62471: EQUAL
62472: ST_TO_ADDR
62473: GO 62614
62475: LD_INT 19
62477: DOUBLE
62478: EQUAL
62479: IFTRUE 62489
62481: LD_INT 23
62483: DOUBLE
62484: EQUAL
62485: IFTRUE 62489
62487: GO 62514
62489: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
62490: LD_ADDR_VAR 0 3
62494: PUSH
62495: LD_INT 83
62497: PPUSH
62498: LD_VAR 0 1
62502: PPUSH
62503: CALL_OW 321
62507: PUSH
62508: LD_INT 2
62510: EQUAL
62511: ST_TO_ADDR
62512: GO 62614
62514: LD_INT 17
62516: DOUBLE
62517: EQUAL
62518: IFTRUE 62522
62520: GO 62547
62522: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
62523: LD_ADDR_VAR 0 3
62527: PUSH
62528: LD_INT 39
62530: PPUSH
62531: LD_VAR 0 1
62535: PPUSH
62536: CALL_OW 321
62540: PUSH
62541: LD_INT 2
62543: EQUAL
62544: ST_TO_ADDR
62545: GO 62614
62547: LD_INT 18
62549: DOUBLE
62550: EQUAL
62551: IFTRUE 62555
62553: GO 62580
62555: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
62556: LD_ADDR_VAR 0 3
62560: PUSH
62561: LD_INT 40
62563: PPUSH
62564: LD_VAR 0 1
62568: PPUSH
62569: CALL_OW 321
62573: PUSH
62574: LD_INT 2
62576: EQUAL
62577: ST_TO_ADDR
62578: GO 62614
62580: LD_INT 27
62582: DOUBLE
62583: EQUAL
62584: IFTRUE 62588
62586: GO 62613
62588: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
62589: LD_ADDR_VAR 0 3
62593: PUSH
62594: LD_INT 35
62596: PPUSH
62597: LD_VAR 0 1
62601: PPUSH
62602: CALL_OW 321
62606: PUSH
62607: LD_INT 2
62609: EQUAL
62610: ST_TO_ADDR
62611: GO 62614
62613: POP
// end ;
62614: LD_VAR 0 3
62618: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
62619: LD_INT 0
62621: PPUSH
62622: PPUSH
62623: PPUSH
62624: PPUSH
62625: PPUSH
62626: PPUSH
62627: PPUSH
62628: PPUSH
62629: PPUSH
62630: PPUSH
62631: PPUSH
// result := false ;
62632: LD_ADDR_VAR 0 6
62636: PUSH
62637: LD_INT 0
62639: ST_TO_ADDR
// if btype = b_depot then
62640: LD_VAR 0 2
62644: PUSH
62645: LD_INT 0
62647: EQUAL
62648: IFFALSE 62660
// begin result := true ;
62650: LD_ADDR_VAR 0 6
62654: PUSH
62655: LD_INT 1
62657: ST_TO_ADDR
// exit ;
62658: GO 63486
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
62660: LD_VAR 0 1
62664: NOT
62665: PUSH
62666: LD_VAR 0 1
62670: PPUSH
62671: CALL_OW 266
62675: PUSH
62676: LD_INT 0
62678: PUSH
62679: LD_INT 1
62681: PUSH
62682: EMPTY
62683: LIST
62684: LIST
62685: IN
62686: NOT
62687: OR
62688: PUSH
62689: LD_VAR 0 2
62693: NOT
62694: OR
62695: PUSH
62696: LD_VAR 0 5
62700: PUSH
62701: LD_INT 0
62703: PUSH
62704: LD_INT 1
62706: PUSH
62707: LD_INT 2
62709: PUSH
62710: LD_INT 3
62712: PUSH
62713: LD_INT 4
62715: PUSH
62716: LD_INT 5
62718: PUSH
62719: EMPTY
62720: LIST
62721: LIST
62722: LIST
62723: LIST
62724: LIST
62725: LIST
62726: IN
62727: NOT
62728: OR
62729: PUSH
62730: LD_VAR 0 3
62734: PPUSH
62735: LD_VAR 0 4
62739: PPUSH
62740: CALL_OW 488
62744: NOT
62745: OR
62746: IFFALSE 62750
// exit ;
62748: GO 63486
// side := GetSide ( depot ) ;
62750: LD_ADDR_VAR 0 9
62754: PUSH
62755: LD_VAR 0 1
62759: PPUSH
62760: CALL_OW 255
62764: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
62765: LD_VAR 0 9
62769: PPUSH
62770: LD_VAR 0 2
62774: PPUSH
62775: CALL 62243 0 2
62779: NOT
62780: IFFALSE 62784
// exit ;
62782: GO 63486
// pom := GetBase ( depot ) ;
62784: LD_ADDR_VAR 0 10
62788: PUSH
62789: LD_VAR 0 1
62793: PPUSH
62794: CALL_OW 274
62798: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
62799: LD_ADDR_VAR 0 11
62803: PUSH
62804: LD_VAR 0 2
62808: PPUSH
62809: LD_VAR 0 1
62813: PPUSH
62814: CALL_OW 248
62818: PPUSH
62819: CALL_OW 450
62823: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
62824: LD_VAR 0 10
62828: PPUSH
62829: LD_INT 1
62831: PPUSH
62832: CALL_OW 275
62836: PUSH
62837: LD_VAR 0 11
62841: PUSH
62842: LD_INT 1
62844: ARRAY
62845: GREATEREQUAL
62846: PUSH
62847: LD_VAR 0 10
62851: PPUSH
62852: LD_INT 2
62854: PPUSH
62855: CALL_OW 275
62859: PUSH
62860: LD_VAR 0 11
62864: PUSH
62865: LD_INT 2
62867: ARRAY
62868: GREATEREQUAL
62869: AND
62870: PUSH
62871: LD_VAR 0 10
62875: PPUSH
62876: LD_INT 3
62878: PPUSH
62879: CALL_OW 275
62883: PUSH
62884: LD_VAR 0 11
62888: PUSH
62889: LD_INT 3
62891: ARRAY
62892: GREATEREQUAL
62893: AND
62894: NOT
62895: IFFALSE 62899
// exit ;
62897: GO 63486
// if GetBType ( depot ) = b_depot then
62899: LD_VAR 0 1
62903: PPUSH
62904: CALL_OW 266
62908: PUSH
62909: LD_INT 0
62911: EQUAL
62912: IFFALSE 62924
// dist := 28 else
62914: LD_ADDR_VAR 0 14
62918: PUSH
62919: LD_INT 28
62921: ST_TO_ADDR
62922: GO 62932
// dist := 36 ;
62924: LD_ADDR_VAR 0 14
62928: PUSH
62929: LD_INT 36
62931: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
62932: LD_VAR 0 1
62936: PPUSH
62937: LD_VAR 0 3
62941: PPUSH
62942: LD_VAR 0 4
62946: PPUSH
62947: CALL_OW 297
62951: PUSH
62952: LD_VAR 0 14
62956: GREATER
62957: IFFALSE 62961
// exit ;
62959: GO 63486
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
62961: LD_ADDR_VAR 0 12
62965: PUSH
62966: LD_VAR 0 2
62970: PPUSH
62971: LD_VAR 0 3
62975: PPUSH
62976: LD_VAR 0 4
62980: PPUSH
62981: LD_VAR 0 5
62985: PPUSH
62986: LD_VAR 0 1
62990: PPUSH
62991: CALL_OW 248
62995: PPUSH
62996: LD_INT 0
62998: PPUSH
62999: CALL 63491 0 6
63003: ST_TO_ADDR
// if not hexes then
63004: LD_VAR 0 12
63008: NOT
63009: IFFALSE 63013
// exit ;
63011: GO 63486
// hex := GetHexInfo ( x , y ) ;
63013: LD_ADDR_VAR 0 15
63017: PUSH
63018: LD_VAR 0 3
63022: PPUSH
63023: LD_VAR 0 4
63027: PPUSH
63028: CALL_OW 546
63032: ST_TO_ADDR
// if hex [ 1 ] then
63033: LD_VAR 0 15
63037: PUSH
63038: LD_INT 1
63040: ARRAY
63041: IFFALSE 63045
// exit ;
63043: GO 63486
// height := hex [ 2 ] ;
63045: LD_ADDR_VAR 0 13
63049: PUSH
63050: LD_VAR 0 15
63054: PUSH
63055: LD_INT 2
63057: ARRAY
63058: ST_TO_ADDR
// for i = 1 to hexes do
63059: LD_ADDR_VAR 0 7
63063: PUSH
63064: DOUBLE
63065: LD_INT 1
63067: DEC
63068: ST_TO_ADDR
63069: LD_VAR 0 12
63073: PUSH
63074: FOR_TO
63075: IFFALSE 63405
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
63077: LD_VAR 0 12
63081: PUSH
63082: LD_VAR 0 7
63086: ARRAY
63087: PUSH
63088: LD_INT 1
63090: ARRAY
63091: PPUSH
63092: LD_VAR 0 12
63096: PUSH
63097: LD_VAR 0 7
63101: ARRAY
63102: PUSH
63103: LD_INT 2
63105: ARRAY
63106: PPUSH
63107: CALL_OW 488
63111: NOT
63112: PUSH
63113: LD_VAR 0 12
63117: PUSH
63118: LD_VAR 0 7
63122: ARRAY
63123: PUSH
63124: LD_INT 1
63126: ARRAY
63127: PPUSH
63128: LD_VAR 0 12
63132: PUSH
63133: LD_VAR 0 7
63137: ARRAY
63138: PUSH
63139: LD_INT 2
63141: ARRAY
63142: PPUSH
63143: CALL_OW 428
63147: PUSH
63148: LD_INT 0
63150: GREATER
63151: OR
63152: PUSH
63153: LD_VAR 0 12
63157: PUSH
63158: LD_VAR 0 7
63162: ARRAY
63163: PUSH
63164: LD_INT 1
63166: ARRAY
63167: PPUSH
63168: LD_VAR 0 12
63172: PUSH
63173: LD_VAR 0 7
63177: ARRAY
63178: PUSH
63179: LD_INT 2
63181: ARRAY
63182: PPUSH
63183: CALL_OW 351
63187: OR
63188: IFFALSE 63194
// exit ;
63190: POP
63191: POP
63192: GO 63486
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
63194: LD_ADDR_VAR 0 8
63198: PUSH
63199: LD_VAR 0 12
63203: PUSH
63204: LD_VAR 0 7
63208: ARRAY
63209: PUSH
63210: LD_INT 1
63212: ARRAY
63213: PPUSH
63214: LD_VAR 0 12
63218: PUSH
63219: LD_VAR 0 7
63223: ARRAY
63224: PUSH
63225: LD_INT 2
63227: ARRAY
63228: PPUSH
63229: CALL_OW 546
63233: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
63234: LD_VAR 0 8
63238: PUSH
63239: LD_INT 1
63241: ARRAY
63242: PUSH
63243: LD_VAR 0 8
63247: PUSH
63248: LD_INT 2
63250: ARRAY
63251: PUSH
63252: LD_VAR 0 13
63256: PUSH
63257: LD_INT 2
63259: PLUS
63260: GREATER
63261: OR
63262: PUSH
63263: LD_VAR 0 8
63267: PUSH
63268: LD_INT 2
63270: ARRAY
63271: PUSH
63272: LD_VAR 0 13
63276: PUSH
63277: LD_INT 2
63279: MINUS
63280: LESS
63281: OR
63282: PUSH
63283: LD_VAR 0 8
63287: PUSH
63288: LD_INT 3
63290: ARRAY
63291: PUSH
63292: LD_INT 0
63294: PUSH
63295: LD_INT 8
63297: PUSH
63298: LD_INT 9
63300: PUSH
63301: LD_INT 10
63303: PUSH
63304: LD_INT 11
63306: PUSH
63307: LD_INT 12
63309: PUSH
63310: LD_INT 13
63312: PUSH
63313: LD_INT 16
63315: PUSH
63316: LD_INT 17
63318: PUSH
63319: LD_INT 18
63321: PUSH
63322: LD_INT 19
63324: PUSH
63325: LD_INT 20
63327: PUSH
63328: LD_INT 21
63330: PUSH
63331: EMPTY
63332: LIST
63333: LIST
63334: LIST
63335: LIST
63336: LIST
63337: LIST
63338: LIST
63339: LIST
63340: LIST
63341: LIST
63342: LIST
63343: LIST
63344: LIST
63345: IN
63346: NOT
63347: OR
63348: PUSH
63349: LD_VAR 0 8
63353: PUSH
63354: LD_INT 5
63356: ARRAY
63357: NOT
63358: OR
63359: PUSH
63360: LD_VAR 0 8
63364: PUSH
63365: LD_INT 6
63367: ARRAY
63368: PUSH
63369: LD_INT 1
63371: PUSH
63372: LD_INT 2
63374: PUSH
63375: LD_INT 7
63377: PUSH
63378: LD_INT 9
63380: PUSH
63381: LD_INT 10
63383: PUSH
63384: LD_INT 11
63386: PUSH
63387: EMPTY
63388: LIST
63389: LIST
63390: LIST
63391: LIST
63392: LIST
63393: LIST
63394: IN
63395: NOT
63396: OR
63397: IFFALSE 63403
// exit ;
63399: POP
63400: POP
63401: GO 63486
// end ;
63403: GO 63074
63405: POP
63406: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
63407: LD_VAR 0 9
63411: PPUSH
63412: LD_VAR 0 3
63416: PPUSH
63417: LD_VAR 0 4
63421: PPUSH
63422: LD_INT 20
63424: PPUSH
63425: CALL 55409 0 4
63429: PUSH
63430: LD_INT 4
63432: ARRAY
63433: IFFALSE 63437
// exit ;
63435: GO 63486
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
63437: LD_VAR 0 2
63441: PUSH
63442: LD_INT 29
63444: PUSH
63445: LD_INT 30
63447: PUSH
63448: EMPTY
63449: LIST
63450: LIST
63451: IN
63452: PUSH
63453: LD_VAR 0 3
63457: PPUSH
63458: LD_VAR 0 4
63462: PPUSH
63463: LD_VAR 0 9
63467: PPUSH
63468: CALL_OW 440
63472: NOT
63473: AND
63474: IFFALSE 63478
// exit ;
63476: GO 63486
// result := true ;
63478: LD_ADDR_VAR 0 6
63482: PUSH
63483: LD_INT 1
63485: ST_TO_ADDR
// end ;
63486: LD_VAR 0 6
63490: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
63491: LD_INT 0
63493: PPUSH
63494: PPUSH
63495: PPUSH
63496: PPUSH
63497: PPUSH
63498: PPUSH
63499: PPUSH
63500: PPUSH
63501: PPUSH
63502: PPUSH
63503: PPUSH
63504: PPUSH
63505: PPUSH
63506: PPUSH
63507: PPUSH
63508: PPUSH
63509: PPUSH
63510: PPUSH
63511: PPUSH
63512: PPUSH
63513: PPUSH
63514: PPUSH
63515: PPUSH
63516: PPUSH
63517: PPUSH
63518: PPUSH
63519: PPUSH
63520: PPUSH
63521: PPUSH
63522: PPUSH
63523: PPUSH
63524: PPUSH
63525: PPUSH
63526: PPUSH
63527: PPUSH
63528: PPUSH
63529: PPUSH
63530: PPUSH
63531: PPUSH
63532: PPUSH
63533: PPUSH
63534: PPUSH
63535: PPUSH
63536: PPUSH
63537: PPUSH
63538: PPUSH
63539: PPUSH
63540: PPUSH
63541: PPUSH
63542: PPUSH
63543: PPUSH
63544: PPUSH
63545: PPUSH
63546: PPUSH
63547: PPUSH
63548: PPUSH
63549: PPUSH
63550: PPUSH
// result = [ ] ;
63551: LD_ADDR_VAR 0 7
63555: PUSH
63556: EMPTY
63557: ST_TO_ADDR
// temp_list = [ ] ;
63558: LD_ADDR_VAR 0 9
63562: PUSH
63563: EMPTY
63564: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
63565: LD_VAR 0 4
63569: PUSH
63570: LD_INT 0
63572: PUSH
63573: LD_INT 1
63575: PUSH
63576: LD_INT 2
63578: PUSH
63579: LD_INT 3
63581: PUSH
63582: LD_INT 4
63584: PUSH
63585: LD_INT 5
63587: PUSH
63588: EMPTY
63589: LIST
63590: LIST
63591: LIST
63592: LIST
63593: LIST
63594: LIST
63595: IN
63596: NOT
63597: PUSH
63598: LD_VAR 0 1
63602: PUSH
63603: LD_INT 0
63605: PUSH
63606: LD_INT 1
63608: PUSH
63609: EMPTY
63610: LIST
63611: LIST
63612: IN
63613: PUSH
63614: LD_VAR 0 5
63618: PUSH
63619: LD_INT 1
63621: PUSH
63622: LD_INT 2
63624: PUSH
63625: LD_INT 3
63627: PUSH
63628: EMPTY
63629: LIST
63630: LIST
63631: LIST
63632: IN
63633: NOT
63634: AND
63635: OR
63636: IFFALSE 63640
// exit ;
63638: GO 82031
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
63640: LD_VAR 0 1
63644: PUSH
63645: LD_INT 6
63647: PUSH
63648: LD_INT 7
63650: PUSH
63651: LD_INT 8
63653: PUSH
63654: LD_INT 13
63656: PUSH
63657: LD_INT 12
63659: PUSH
63660: LD_INT 15
63662: PUSH
63663: LD_INT 11
63665: PUSH
63666: LD_INT 14
63668: PUSH
63669: LD_INT 10
63671: PUSH
63672: EMPTY
63673: LIST
63674: LIST
63675: LIST
63676: LIST
63677: LIST
63678: LIST
63679: LIST
63680: LIST
63681: LIST
63682: IN
63683: IFFALSE 63693
// btype = b_lab ;
63685: LD_ADDR_VAR 0 1
63689: PUSH
63690: LD_INT 6
63692: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
63693: LD_VAR 0 6
63697: PUSH
63698: LD_INT 0
63700: PUSH
63701: LD_INT 1
63703: PUSH
63704: LD_INT 2
63706: PUSH
63707: EMPTY
63708: LIST
63709: LIST
63710: LIST
63711: IN
63712: NOT
63713: PUSH
63714: LD_VAR 0 1
63718: PUSH
63719: LD_INT 0
63721: PUSH
63722: LD_INT 1
63724: PUSH
63725: LD_INT 2
63727: PUSH
63728: LD_INT 3
63730: PUSH
63731: LD_INT 6
63733: PUSH
63734: LD_INT 36
63736: PUSH
63737: LD_INT 4
63739: PUSH
63740: LD_INT 5
63742: PUSH
63743: LD_INT 31
63745: PUSH
63746: LD_INT 32
63748: PUSH
63749: LD_INT 33
63751: PUSH
63752: EMPTY
63753: LIST
63754: LIST
63755: LIST
63756: LIST
63757: LIST
63758: LIST
63759: LIST
63760: LIST
63761: LIST
63762: LIST
63763: LIST
63764: IN
63765: NOT
63766: PUSH
63767: LD_VAR 0 6
63771: PUSH
63772: LD_INT 1
63774: EQUAL
63775: AND
63776: OR
63777: PUSH
63778: LD_VAR 0 1
63782: PUSH
63783: LD_INT 2
63785: PUSH
63786: LD_INT 3
63788: PUSH
63789: EMPTY
63790: LIST
63791: LIST
63792: IN
63793: NOT
63794: PUSH
63795: LD_VAR 0 6
63799: PUSH
63800: LD_INT 2
63802: EQUAL
63803: AND
63804: OR
63805: IFFALSE 63815
// mode = 0 ;
63807: LD_ADDR_VAR 0 6
63811: PUSH
63812: LD_INT 0
63814: ST_TO_ADDR
// case mode of 0 :
63815: LD_VAR 0 6
63819: PUSH
63820: LD_INT 0
63822: DOUBLE
63823: EQUAL
63824: IFTRUE 63828
63826: GO 75281
63828: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
63829: LD_ADDR_VAR 0 11
63833: PUSH
63834: LD_INT 0
63836: PUSH
63837: LD_INT 0
63839: PUSH
63840: EMPTY
63841: LIST
63842: LIST
63843: PUSH
63844: LD_INT 0
63846: PUSH
63847: LD_INT 1
63849: NEG
63850: PUSH
63851: EMPTY
63852: LIST
63853: LIST
63854: PUSH
63855: LD_INT 1
63857: PUSH
63858: LD_INT 0
63860: PUSH
63861: EMPTY
63862: LIST
63863: LIST
63864: PUSH
63865: LD_INT 1
63867: PUSH
63868: LD_INT 1
63870: PUSH
63871: EMPTY
63872: LIST
63873: LIST
63874: PUSH
63875: LD_INT 0
63877: PUSH
63878: LD_INT 1
63880: PUSH
63881: EMPTY
63882: LIST
63883: LIST
63884: PUSH
63885: LD_INT 1
63887: NEG
63888: PUSH
63889: LD_INT 0
63891: PUSH
63892: EMPTY
63893: LIST
63894: LIST
63895: PUSH
63896: LD_INT 1
63898: NEG
63899: PUSH
63900: LD_INT 1
63902: NEG
63903: PUSH
63904: EMPTY
63905: LIST
63906: LIST
63907: PUSH
63908: LD_INT 1
63910: NEG
63911: PUSH
63912: LD_INT 2
63914: NEG
63915: PUSH
63916: EMPTY
63917: LIST
63918: LIST
63919: PUSH
63920: LD_INT 0
63922: PUSH
63923: LD_INT 2
63925: NEG
63926: PUSH
63927: EMPTY
63928: LIST
63929: LIST
63930: PUSH
63931: LD_INT 1
63933: PUSH
63934: LD_INT 1
63936: NEG
63937: PUSH
63938: EMPTY
63939: LIST
63940: LIST
63941: PUSH
63942: LD_INT 1
63944: PUSH
63945: LD_INT 2
63947: PUSH
63948: EMPTY
63949: LIST
63950: LIST
63951: PUSH
63952: LD_INT 0
63954: PUSH
63955: LD_INT 2
63957: PUSH
63958: EMPTY
63959: LIST
63960: LIST
63961: PUSH
63962: LD_INT 1
63964: NEG
63965: PUSH
63966: LD_INT 1
63968: PUSH
63969: EMPTY
63970: LIST
63971: LIST
63972: PUSH
63973: LD_INT 1
63975: PUSH
63976: LD_INT 3
63978: PUSH
63979: EMPTY
63980: LIST
63981: LIST
63982: PUSH
63983: LD_INT 0
63985: PUSH
63986: LD_INT 3
63988: PUSH
63989: EMPTY
63990: LIST
63991: LIST
63992: PUSH
63993: LD_INT 1
63995: NEG
63996: PUSH
63997: LD_INT 2
63999: PUSH
64000: EMPTY
64001: LIST
64002: LIST
64003: PUSH
64004: EMPTY
64005: LIST
64006: LIST
64007: LIST
64008: LIST
64009: LIST
64010: LIST
64011: LIST
64012: LIST
64013: LIST
64014: LIST
64015: LIST
64016: LIST
64017: LIST
64018: LIST
64019: LIST
64020: LIST
64021: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
64022: LD_ADDR_VAR 0 12
64026: PUSH
64027: LD_INT 0
64029: PUSH
64030: LD_INT 0
64032: PUSH
64033: EMPTY
64034: LIST
64035: LIST
64036: PUSH
64037: LD_INT 0
64039: PUSH
64040: LD_INT 1
64042: NEG
64043: PUSH
64044: EMPTY
64045: LIST
64046: LIST
64047: PUSH
64048: LD_INT 1
64050: PUSH
64051: LD_INT 0
64053: PUSH
64054: EMPTY
64055: LIST
64056: LIST
64057: PUSH
64058: LD_INT 1
64060: PUSH
64061: LD_INT 1
64063: PUSH
64064: EMPTY
64065: LIST
64066: LIST
64067: PUSH
64068: LD_INT 0
64070: PUSH
64071: LD_INT 1
64073: PUSH
64074: EMPTY
64075: LIST
64076: LIST
64077: PUSH
64078: LD_INT 1
64080: NEG
64081: PUSH
64082: LD_INT 0
64084: PUSH
64085: EMPTY
64086: LIST
64087: LIST
64088: PUSH
64089: LD_INT 1
64091: NEG
64092: PUSH
64093: LD_INT 1
64095: NEG
64096: PUSH
64097: EMPTY
64098: LIST
64099: LIST
64100: PUSH
64101: LD_INT 1
64103: PUSH
64104: LD_INT 1
64106: NEG
64107: PUSH
64108: EMPTY
64109: LIST
64110: LIST
64111: PUSH
64112: LD_INT 2
64114: PUSH
64115: LD_INT 0
64117: PUSH
64118: EMPTY
64119: LIST
64120: LIST
64121: PUSH
64122: LD_INT 2
64124: PUSH
64125: LD_INT 1
64127: PUSH
64128: EMPTY
64129: LIST
64130: LIST
64131: PUSH
64132: LD_INT 1
64134: NEG
64135: PUSH
64136: LD_INT 1
64138: PUSH
64139: EMPTY
64140: LIST
64141: LIST
64142: PUSH
64143: LD_INT 2
64145: NEG
64146: PUSH
64147: LD_INT 0
64149: PUSH
64150: EMPTY
64151: LIST
64152: LIST
64153: PUSH
64154: LD_INT 2
64156: NEG
64157: PUSH
64158: LD_INT 1
64160: NEG
64161: PUSH
64162: EMPTY
64163: LIST
64164: LIST
64165: PUSH
64166: LD_INT 2
64168: NEG
64169: PUSH
64170: LD_INT 1
64172: PUSH
64173: EMPTY
64174: LIST
64175: LIST
64176: PUSH
64177: LD_INT 3
64179: NEG
64180: PUSH
64181: LD_INT 0
64183: PUSH
64184: EMPTY
64185: LIST
64186: LIST
64187: PUSH
64188: LD_INT 3
64190: NEG
64191: PUSH
64192: LD_INT 1
64194: NEG
64195: PUSH
64196: EMPTY
64197: LIST
64198: LIST
64199: PUSH
64200: EMPTY
64201: LIST
64202: LIST
64203: LIST
64204: LIST
64205: LIST
64206: LIST
64207: LIST
64208: LIST
64209: LIST
64210: LIST
64211: LIST
64212: LIST
64213: LIST
64214: LIST
64215: LIST
64216: LIST
64217: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
64218: LD_ADDR_VAR 0 13
64222: PUSH
64223: LD_INT 0
64225: PUSH
64226: LD_INT 0
64228: PUSH
64229: EMPTY
64230: LIST
64231: LIST
64232: PUSH
64233: LD_INT 0
64235: PUSH
64236: LD_INT 1
64238: NEG
64239: PUSH
64240: EMPTY
64241: LIST
64242: LIST
64243: PUSH
64244: LD_INT 1
64246: PUSH
64247: LD_INT 0
64249: PUSH
64250: EMPTY
64251: LIST
64252: LIST
64253: PUSH
64254: LD_INT 1
64256: PUSH
64257: LD_INT 1
64259: PUSH
64260: EMPTY
64261: LIST
64262: LIST
64263: PUSH
64264: LD_INT 0
64266: PUSH
64267: LD_INT 1
64269: PUSH
64270: EMPTY
64271: LIST
64272: LIST
64273: PUSH
64274: LD_INT 1
64276: NEG
64277: PUSH
64278: LD_INT 0
64280: PUSH
64281: EMPTY
64282: LIST
64283: LIST
64284: PUSH
64285: LD_INT 1
64287: NEG
64288: PUSH
64289: LD_INT 1
64291: NEG
64292: PUSH
64293: EMPTY
64294: LIST
64295: LIST
64296: PUSH
64297: LD_INT 1
64299: NEG
64300: PUSH
64301: LD_INT 2
64303: NEG
64304: PUSH
64305: EMPTY
64306: LIST
64307: LIST
64308: PUSH
64309: LD_INT 2
64311: PUSH
64312: LD_INT 1
64314: PUSH
64315: EMPTY
64316: LIST
64317: LIST
64318: PUSH
64319: LD_INT 2
64321: PUSH
64322: LD_INT 2
64324: PUSH
64325: EMPTY
64326: LIST
64327: LIST
64328: PUSH
64329: LD_INT 1
64331: PUSH
64332: LD_INT 2
64334: PUSH
64335: EMPTY
64336: LIST
64337: LIST
64338: PUSH
64339: LD_INT 2
64341: NEG
64342: PUSH
64343: LD_INT 1
64345: NEG
64346: PUSH
64347: EMPTY
64348: LIST
64349: LIST
64350: PUSH
64351: LD_INT 2
64353: NEG
64354: PUSH
64355: LD_INT 2
64357: NEG
64358: PUSH
64359: EMPTY
64360: LIST
64361: LIST
64362: PUSH
64363: LD_INT 2
64365: NEG
64366: PUSH
64367: LD_INT 3
64369: NEG
64370: PUSH
64371: EMPTY
64372: LIST
64373: LIST
64374: PUSH
64375: LD_INT 3
64377: NEG
64378: PUSH
64379: LD_INT 2
64381: NEG
64382: PUSH
64383: EMPTY
64384: LIST
64385: LIST
64386: PUSH
64387: LD_INT 3
64389: NEG
64390: PUSH
64391: LD_INT 3
64393: NEG
64394: PUSH
64395: EMPTY
64396: LIST
64397: LIST
64398: PUSH
64399: EMPTY
64400: LIST
64401: LIST
64402: LIST
64403: LIST
64404: LIST
64405: LIST
64406: LIST
64407: LIST
64408: LIST
64409: LIST
64410: LIST
64411: LIST
64412: LIST
64413: LIST
64414: LIST
64415: LIST
64416: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
64417: LD_ADDR_VAR 0 14
64421: PUSH
64422: LD_INT 0
64424: PUSH
64425: LD_INT 0
64427: PUSH
64428: EMPTY
64429: LIST
64430: LIST
64431: PUSH
64432: LD_INT 0
64434: PUSH
64435: LD_INT 1
64437: NEG
64438: PUSH
64439: EMPTY
64440: LIST
64441: LIST
64442: PUSH
64443: LD_INT 1
64445: PUSH
64446: LD_INT 0
64448: PUSH
64449: EMPTY
64450: LIST
64451: LIST
64452: PUSH
64453: LD_INT 1
64455: PUSH
64456: LD_INT 1
64458: PUSH
64459: EMPTY
64460: LIST
64461: LIST
64462: PUSH
64463: LD_INT 0
64465: PUSH
64466: LD_INT 1
64468: PUSH
64469: EMPTY
64470: LIST
64471: LIST
64472: PUSH
64473: LD_INT 1
64475: NEG
64476: PUSH
64477: LD_INT 0
64479: PUSH
64480: EMPTY
64481: LIST
64482: LIST
64483: PUSH
64484: LD_INT 1
64486: NEG
64487: PUSH
64488: LD_INT 1
64490: NEG
64491: PUSH
64492: EMPTY
64493: LIST
64494: LIST
64495: PUSH
64496: LD_INT 1
64498: NEG
64499: PUSH
64500: LD_INT 2
64502: NEG
64503: PUSH
64504: EMPTY
64505: LIST
64506: LIST
64507: PUSH
64508: LD_INT 0
64510: PUSH
64511: LD_INT 2
64513: NEG
64514: PUSH
64515: EMPTY
64516: LIST
64517: LIST
64518: PUSH
64519: LD_INT 1
64521: PUSH
64522: LD_INT 1
64524: NEG
64525: PUSH
64526: EMPTY
64527: LIST
64528: LIST
64529: PUSH
64530: LD_INT 1
64532: PUSH
64533: LD_INT 2
64535: PUSH
64536: EMPTY
64537: LIST
64538: LIST
64539: PUSH
64540: LD_INT 0
64542: PUSH
64543: LD_INT 2
64545: PUSH
64546: EMPTY
64547: LIST
64548: LIST
64549: PUSH
64550: LD_INT 1
64552: NEG
64553: PUSH
64554: LD_INT 1
64556: PUSH
64557: EMPTY
64558: LIST
64559: LIST
64560: PUSH
64561: LD_INT 1
64563: NEG
64564: PUSH
64565: LD_INT 3
64567: NEG
64568: PUSH
64569: EMPTY
64570: LIST
64571: LIST
64572: PUSH
64573: LD_INT 0
64575: PUSH
64576: LD_INT 3
64578: NEG
64579: PUSH
64580: EMPTY
64581: LIST
64582: LIST
64583: PUSH
64584: LD_INT 1
64586: PUSH
64587: LD_INT 2
64589: NEG
64590: PUSH
64591: EMPTY
64592: LIST
64593: LIST
64594: PUSH
64595: EMPTY
64596: LIST
64597: LIST
64598: LIST
64599: LIST
64600: LIST
64601: LIST
64602: LIST
64603: LIST
64604: LIST
64605: LIST
64606: LIST
64607: LIST
64608: LIST
64609: LIST
64610: LIST
64611: LIST
64612: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
64613: LD_ADDR_VAR 0 15
64617: PUSH
64618: LD_INT 0
64620: PUSH
64621: LD_INT 0
64623: PUSH
64624: EMPTY
64625: LIST
64626: LIST
64627: PUSH
64628: LD_INT 0
64630: PUSH
64631: LD_INT 1
64633: NEG
64634: PUSH
64635: EMPTY
64636: LIST
64637: LIST
64638: PUSH
64639: LD_INT 1
64641: PUSH
64642: LD_INT 0
64644: PUSH
64645: EMPTY
64646: LIST
64647: LIST
64648: PUSH
64649: LD_INT 1
64651: PUSH
64652: LD_INT 1
64654: PUSH
64655: EMPTY
64656: LIST
64657: LIST
64658: PUSH
64659: LD_INT 0
64661: PUSH
64662: LD_INT 1
64664: PUSH
64665: EMPTY
64666: LIST
64667: LIST
64668: PUSH
64669: LD_INT 1
64671: NEG
64672: PUSH
64673: LD_INT 0
64675: PUSH
64676: EMPTY
64677: LIST
64678: LIST
64679: PUSH
64680: LD_INT 1
64682: NEG
64683: PUSH
64684: LD_INT 1
64686: NEG
64687: PUSH
64688: EMPTY
64689: LIST
64690: LIST
64691: PUSH
64692: LD_INT 1
64694: PUSH
64695: LD_INT 1
64697: NEG
64698: PUSH
64699: EMPTY
64700: LIST
64701: LIST
64702: PUSH
64703: LD_INT 2
64705: PUSH
64706: LD_INT 0
64708: PUSH
64709: EMPTY
64710: LIST
64711: LIST
64712: PUSH
64713: LD_INT 2
64715: PUSH
64716: LD_INT 1
64718: PUSH
64719: EMPTY
64720: LIST
64721: LIST
64722: PUSH
64723: LD_INT 1
64725: NEG
64726: PUSH
64727: LD_INT 1
64729: PUSH
64730: EMPTY
64731: LIST
64732: LIST
64733: PUSH
64734: LD_INT 2
64736: NEG
64737: PUSH
64738: LD_INT 0
64740: PUSH
64741: EMPTY
64742: LIST
64743: LIST
64744: PUSH
64745: LD_INT 2
64747: NEG
64748: PUSH
64749: LD_INT 1
64751: NEG
64752: PUSH
64753: EMPTY
64754: LIST
64755: LIST
64756: PUSH
64757: LD_INT 2
64759: PUSH
64760: LD_INT 1
64762: NEG
64763: PUSH
64764: EMPTY
64765: LIST
64766: LIST
64767: PUSH
64768: LD_INT 3
64770: PUSH
64771: LD_INT 0
64773: PUSH
64774: EMPTY
64775: LIST
64776: LIST
64777: PUSH
64778: LD_INT 3
64780: PUSH
64781: LD_INT 1
64783: PUSH
64784: EMPTY
64785: LIST
64786: LIST
64787: PUSH
64788: EMPTY
64789: LIST
64790: LIST
64791: LIST
64792: LIST
64793: LIST
64794: LIST
64795: LIST
64796: LIST
64797: LIST
64798: LIST
64799: LIST
64800: LIST
64801: LIST
64802: LIST
64803: LIST
64804: LIST
64805: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
64806: LD_ADDR_VAR 0 16
64810: PUSH
64811: LD_INT 0
64813: PUSH
64814: LD_INT 0
64816: PUSH
64817: EMPTY
64818: LIST
64819: LIST
64820: PUSH
64821: LD_INT 0
64823: PUSH
64824: LD_INT 1
64826: NEG
64827: PUSH
64828: EMPTY
64829: LIST
64830: LIST
64831: PUSH
64832: LD_INT 1
64834: PUSH
64835: LD_INT 0
64837: PUSH
64838: EMPTY
64839: LIST
64840: LIST
64841: PUSH
64842: LD_INT 1
64844: PUSH
64845: LD_INT 1
64847: PUSH
64848: EMPTY
64849: LIST
64850: LIST
64851: PUSH
64852: LD_INT 0
64854: PUSH
64855: LD_INT 1
64857: PUSH
64858: EMPTY
64859: LIST
64860: LIST
64861: PUSH
64862: LD_INT 1
64864: NEG
64865: PUSH
64866: LD_INT 0
64868: PUSH
64869: EMPTY
64870: LIST
64871: LIST
64872: PUSH
64873: LD_INT 1
64875: NEG
64876: PUSH
64877: LD_INT 1
64879: NEG
64880: PUSH
64881: EMPTY
64882: LIST
64883: LIST
64884: PUSH
64885: LD_INT 1
64887: NEG
64888: PUSH
64889: LD_INT 2
64891: NEG
64892: PUSH
64893: EMPTY
64894: LIST
64895: LIST
64896: PUSH
64897: LD_INT 2
64899: PUSH
64900: LD_INT 1
64902: PUSH
64903: EMPTY
64904: LIST
64905: LIST
64906: PUSH
64907: LD_INT 2
64909: PUSH
64910: LD_INT 2
64912: PUSH
64913: EMPTY
64914: LIST
64915: LIST
64916: PUSH
64917: LD_INT 1
64919: PUSH
64920: LD_INT 2
64922: PUSH
64923: EMPTY
64924: LIST
64925: LIST
64926: PUSH
64927: LD_INT 2
64929: NEG
64930: PUSH
64931: LD_INT 1
64933: NEG
64934: PUSH
64935: EMPTY
64936: LIST
64937: LIST
64938: PUSH
64939: LD_INT 2
64941: NEG
64942: PUSH
64943: LD_INT 2
64945: NEG
64946: PUSH
64947: EMPTY
64948: LIST
64949: LIST
64950: PUSH
64951: LD_INT 3
64953: PUSH
64954: LD_INT 2
64956: PUSH
64957: EMPTY
64958: LIST
64959: LIST
64960: PUSH
64961: LD_INT 3
64963: PUSH
64964: LD_INT 3
64966: PUSH
64967: EMPTY
64968: LIST
64969: LIST
64970: PUSH
64971: LD_INT 2
64973: PUSH
64974: LD_INT 3
64976: PUSH
64977: EMPTY
64978: LIST
64979: LIST
64980: PUSH
64981: EMPTY
64982: LIST
64983: LIST
64984: LIST
64985: LIST
64986: LIST
64987: LIST
64988: LIST
64989: LIST
64990: LIST
64991: LIST
64992: LIST
64993: LIST
64994: LIST
64995: LIST
64996: LIST
64997: LIST
64998: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64999: LD_ADDR_VAR 0 17
65003: PUSH
65004: LD_INT 0
65006: PUSH
65007: LD_INT 0
65009: PUSH
65010: EMPTY
65011: LIST
65012: LIST
65013: PUSH
65014: LD_INT 0
65016: PUSH
65017: LD_INT 1
65019: NEG
65020: PUSH
65021: EMPTY
65022: LIST
65023: LIST
65024: PUSH
65025: LD_INT 1
65027: PUSH
65028: LD_INT 0
65030: PUSH
65031: EMPTY
65032: LIST
65033: LIST
65034: PUSH
65035: LD_INT 1
65037: PUSH
65038: LD_INT 1
65040: PUSH
65041: EMPTY
65042: LIST
65043: LIST
65044: PUSH
65045: LD_INT 0
65047: PUSH
65048: LD_INT 1
65050: PUSH
65051: EMPTY
65052: LIST
65053: LIST
65054: PUSH
65055: LD_INT 1
65057: NEG
65058: PUSH
65059: LD_INT 0
65061: PUSH
65062: EMPTY
65063: LIST
65064: LIST
65065: PUSH
65066: LD_INT 1
65068: NEG
65069: PUSH
65070: LD_INT 1
65072: NEG
65073: PUSH
65074: EMPTY
65075: LIST
65076: LIST
65077: PUSH
65078: LD_INT 1
65080: NEG
65081: PUSH
65082: LD_INT 2
65084: NEG
65085: PUSH
65086: EMPTY
65087: LIST
65088: LIST
65089: PUSH
65090: LD_INT 0
65092: PUSH
65093: LD_INT 2
65095: NEG
65096: PUSH
65097: EMPTY
65098: LIST
65099: LIST
65100: PUSH
65101: LD_INT 1
65103: PUSH
65104: LD_INT 1
65106: NEG
65107: PUSH
65108: EMPTY
65109: LIST
65110: LIST
65111: PUSH
65112: LD_INT 2
65114: PUSH
65115: LD_INT 0
65117: PUSH
65118: EMPTY
65119: LIST
65120: LIST
65121: PUSH
65122: LD_INT 2
65124: PUSH
65125: LD_INT 1
65127: PUSH
65128: EMPTY
65129: LIST
65130: LIST
65131: PUSH
65132: LD_INT 2
65134: PUSH
65135: LD_INT 2
65137: PUSH
65138: EMPTY
65139: LIST
65140: LIST
65141: PUSH
65142: LD_INT 1
65144: PUSH
65145: LD_INT 2
65147: PUSH
65148: EMPTY
65149: LIST
65150: LIST
65151: PUSH
65152: LD_INT 0
65154: PUSH
65155: LD_INT 2
65157: PUSH
65158: EMPTY
65159: LIST
65160: LIST
65161: PUSH
65162: LD_INT 1
65164: NEG
65165: PUSH
65166: LD_INT 1
65168: PUSH
65169: EMPTY
65170: LIST
65171: LIST
65172: PUSH
65173: LD_INT 2
65175: NEG
65176: PUSH
65177: LD_INT 0
65179: PUSH
65180: EMPTY
65181: LIST
65182: LIST
65183: PUSH
65184: LD_INT 2
65186: NEG
65187: PUSH
65188: LD_INT 1
65190: NEG
65191: PUSH
65192: EMPTY
65193: LIST
65194: LIST
65195: PUSH
65196: LD_INT 2
65198: NEG
65199: PUSH
65200: LD_INT 2
65202: NEG
65203: PUSH
65204: EMPTY
65205: LIST
65206: LIST
65207: PUSH
65208: EMPTY
65209: LIST
65210: LIST
65211: LIST
65212: LIST
65213: LIST
65214: LIST
65215: LIST
65216: LIST
65217: LIST
65218: LIST
65219: LIST
65220: LIST
65221: LIST
65222: LIST
65223: LIST
65224: LIST
65225: LIST
65226: LIST
65227: LIST
65228: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65229: LD_ADDR_VAR 0 18
65233: PUSH
65234: LD_INT 0
65236: PUSH
65237: LD_INT 0
65239: PUSH
65240: EMPTY
65241: LIST
65242: LIST
65243: PUSH
65244: LD_INT 0
65246: PUSH
65247: LD_INT 1
65249: NEG
65250: PUSH
65251: EMPTY
65252: LIST
65253: LIST
65254: PUSH
65255: LD_INT 1
65257: PUSH
65258: LD_INT 0
65260: PUSH
65261: EMPTY
65262: LIST
65263: LIST
65264: PUSH
65265: LD_INT 1
65267: PUSH
65268: LD_INT 1
65270: PUSH
65271: EMPTY
65272: LIST
65273: LIST
65274: PUSH
65275: LD_INT 0
65277: PUSH
65278: LD_INT 1
65280: PUSH
65281: EMPTY
65282: LIST
65283: LIST
65284: PUSH
65285: LD_INT 1
65287: NEG
65288: PUSH
65289: LD_INT 0
65291: PUSH
65292: EMPTY
65293: LIST
65294: LIST
65295: PUSH
65296: LD_INT 1
65298: NEG
65299: PUSH
65300: LD_INT 1
65302: NEG
65303: PUSH
65304: EMPTY
65305: LIST
65306: LIST
65307: PUSH
65308: LD_INT 1
65310: NEG
65311: PUSH
65312: LD_INT 2
65314: NEG
65315: PUSH
65316: EMPTY
65317: LIST
65318: LIST
65319: PUSH
65320: LD_INT 0
65322: PUSH
65323: LD_INT 2
65325: NEG
65326: PUSH
65327: EMPTY
65328: LIST
65329: LIST
65330: PUSH
65331: LD_INT 1
65333: PUSH
65334: LD_INT 1
65336: NEG
65337: PUSH
65338: EMPTY
65339: LIST
65340: LIST
65341: PUSH
65342: LD_INT 2
65344: PUSH
65345: LD_INT 0
65347: PUSH
65348: EMPTY
65349: LIST
65350: LIST
65351: PUSH
65352: LD_INT 2
65354: PUSH
65355: LD_INT 1
65357: PUSH
65358: EMPTY
65359: LIST
65360: LIST
65361: PUSH
65362: LD_INT 2
65364: PUSH
65365: LD_INT 2
65367: PUSH
65368: EMPTY
65369: LIST
65370: LIST
65371: PUSH
65372: LD_INT 1
65374: PUSH
65375: LD_INT 2
65377: PUSH
65378: EMPTY
65379: LIST
65380: LIST
65381: PUSH
65382: LD_INT 0
65384: PUSH
65385: LD_INT 2
65387: PUSH
65388: EMPTY
65389: LIST
65390: LIST
65391: PUSH
65392: LD_INT 1
65394: NEG
65395: PUSH
65396: LD_INT 1
65398: PUSH
65399: EMPTY
65400: LIST
65401: LIST
65402: PUSH
65403: LD_INT 2
65405: NEG
65406: PUSH
65407: LD_INT 0
65409: PUSH
65410: EMPTY
65411: LIST
65412: LIST
65413: PUSH
65414: LD_INT 2
65416: NEG
65417: PUSH
65418: LD_INT 1
65420: NEG
65421: PUSH
65422: EMPTY
65423: LIST
65424: LIST
65425: PUSH
65426: LD_INT 2
65428: NEG
65429: PUSH
65430: LD_INT 2
65432: NEG
65433: PUSH
65434: EMPTY
65435: LIST
65436: LIST
65437: PUSH
65438: EMPTY
65439: LIST
65440: LIST
65441: LIST
65442: LIST
65443: LIST
65444: LIST
65445: LIST
65446: LIST
65447: LIST
65448: LIST
65449: LIST
65450: LIST
65451: LIST
65452: LIST
65453: LIST
65454: LIST
65455: LIST
65456: LIST
65457: LIST
65458: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65459: LD_ADDR_VAR 0 19
65463: PUSH
65464: LD_INT 0
65466: PUSH
65467: LD_INT 0
65469: PUSH
65470: EMPTY
65471: LIST
65472: LIST
65473: PUSH
65474: LD_INT 0
65476: PUSH
65477: LD_INT 1
65479: NEG
65480: PUSH
65481: EMPTY
65482: LIST
65483: LIST
65484: PUSH
65485: LD_INT 1
65487: PUSH
65488: LD_INT 0
65490: PUSH
65491: EMPTY
65492: LIST
65493: LIST
65494: PUSH
65495: LD_INT 1
65497: PUSH
65498: LD_INT 1
65500: PUSH
65501: EMPTY
65502: LIST
65503: LIST
65504: PUSH
65505: LD_INT 0
65507: PUSH
65508: LD_INT 1
65510: PUSH
65511: EMPTY
65512: LIST
65513: LIST
65514: PUSH
65515: LD_INT 1
65517: NEG
65518: PUSH
65519: LD_INT 0
65521: PUSH
65522: EMPTY
65523: LIST
65524: LIST
65525: PUSH
65526: LD_INT 1
65528: NEG
65529: PUSH
65530: LD_INT 1
65532: NEG
65533: PUSH
65534: EMPTY
65535: LIST
65536: LIST
65537: PUSH
65538: LD_INT 1
65540: NEG
65541: PUSH
65542: LD_INT 2
65544: NEG
65545: PUSH
65546: EMPTY
65547: LIST
65548: LIST
65549: PUSH
65550: LD_INT 0
65552: PUSH
65553: LD_INT 2
65555: NEG
65556: PUSH
65557: EMPTY
65558: LIST
65559: LIST
65560: PUSH
65561: LD_INT 1
65563: PUSH
65564: LD_INT 1
65566: NEG
65567: PUSH
65568: EMPTY
65569: LIST
65570: LIST
65571: PUSH
65572: LD_INT 2
65574: PUSH
65575: LD_INT 0
65577: PUSH
65578: EMPTY
65579: LIST
65580: LIST
65581: PUSH
65582: LD_INT 2
65584: PUSH
65585: LD_INT 1
65587: PUSH
65588: EMPTY
65589: LIST
65590: LIST
65591: PUSH
65592: LD_INT 2
65594: PUSH
65595: LD_INT 2
65597: PUSH
65598: EMPTY
65599: LIST
65600: LIST
65601: PUSH
65602: LD_INT 1
65604: PUSH
65605: LD_INT 2
65607: PUSH
65608: EMPTY
65609: LIST
65610: LIST
65611: PUSH
65612: LD_INT 0
65614: PUSH
65615: LD_INT 2
65617: PUSH
65618: EMPTY
65619: LIST
65620: LIST
65621: PUSH
65622: LD_INT 1
65624: NEG
65625: PUSH
65626: LD_INT 1
65628: PUSH
65629: EMPTY
65630: LIST
65631: LIST
65632: PUSH
65633: LD_INT 2
65635: NEG
65636: PUSH
65637: LD_INT 0
65639: PUSH
65640: EMPTY
65641: LIST
65642: LIST
65643: PUSH
65644: LD_INT 2
65646: NEG
65647: PUSH
65648: LD_INT 1
65650: NEG
65651: PUSH
65652: EMPTY
65653: LIST
65654: LIST
65655: PUSH
65656: LD_INT 2
65658: NEG
65659: PUSH
65660: LD_INT 2
65662: NEG
65663: PUSH
65664: EMPTY
65665: LIST
65666: LIST
65667: PUSH
65668: EMPTY
65669: LIST
65670: LIST
65671: LIST
65672: LIST
65673: LIST
65674: LIST
65675: LIST
65676: LIST
65677: LIST
65678: LIST
65679: LIST
65680: LIST
65681: LIST
65682: LIST
65683: LIST
65684: LIST
65685: LIST
65686: LIST
65687: LIST
65688: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65689: LD_ADDR_VAR 0 20
65693: PUSH
65694: LD_INT 0
65696: PUSH
65697: LD_INT 0
65699: PUSH
65700: EMPTY
65701: LIST
65702: LIST
65703: PUSH
65704: LD_INT 0
65706: PUSH
65707: LD_INT 1
65709: NEG
65710: PUSH
65711: EMPTY
65712: LIST
65713: LIST
65714: PUSH
65715: LD_INT 1
65717: PUSH
65718: LD_INT 0
65720: PUSH
65721: EMPTY
65722: LIST
65723: LIST
65724: PUSH
65725: LD_INT 1
65727: PUSH
65728: LD_INT 1
65730: PUSH
65731: EMPTY
65732: LIST
65733: LIST
65734: PUSH
65735: LD_INT 0
65737: PUSH
65738: LD_INT 1
65740: PUSH
65741: EMPTY
65742: LIST
65743: LIST
65744: PUSH
65745: LD_INT 1
65747: NEG
65748: PUSH
65749: LD_INT 0
65751: PUSH
65752: EMPTY
65753: LIST
65754: LIST
65755: PUSH
65756: LD_INT 1
65758: NEG
65759: PUSH
65760: LD_INT 1
65762: NEG
65763: PUSH
65764: EMPTY
65765: LIST
65766: LIST
65767: PUSH
65768: LD_INT 1
65770: NEG
65771: PUSH
65772: LD_INT 2
65774: NEG
65775: PUSH
65776: EMPTY
65777: LIST
65778: LIST
65779: PUSH
65780: LD_INT 0
65782: PUSH
65783: LD_INT 2
65785: NEG
65786: PUSH
65787: EMPTY
65788: LIST
65789: LIST
65790: PUSH
65791: LD_INT 1
65793: PUSH
65794: LD_INT 1
65796: NEG
65797: PUSH
65798: EMPTY
65799: LIST
65800: LIST
65801: PUSH
65802: LD_INT 2
65804: PUSH
65805: LD_INT 0
65807: PUSH
65808: EMPTY
65809: LIST
65810: LIST
65811: PUSH
65812: LD_INT 2
65814: PUSH
65815: LD_INT 1
65817: PUSH
65818: EMPTY
65819: LIST
65820: LIST
65821: PUSH
65822: LD_INT 2
65824: PUSH
65825: LD_INT 2
65827: PUSH
65828: EMPTY
65829: LIST
65830: LIST
65831: PUSH
65832: LD_INT 1
65834: PUSH
65835: LD_INT 2
65837: PUSH
65838: EMPTY
65839: LIST
65840: LIST
65841: PUSH
65842: LD_INT 0
65844: PUSH
65845: LD_INT 2
65847: PUSH
65848: EMPTY
65849: LIST
65850: LIST
65851: PUSH
65852: LD_INT 1
65854: NEG
65855: PUSH
65856: LD_INT 1
65858: PUSH
65859: EMPTY
65860: LIST
65861: LIST
65862: PUSH
65863: LD_INT 2
65865: NEG
65866: PUSH
65867: LD_INT 0
65869: PUSH
65870: EMPTY
65871: LIST
65872: LIST
65873: PUSH
65874: LD_INT 2
65876: NEG
65877: PUSH
65878: LD_INT 1
65880: NEG
65881: PUSH
65882: EMPTY
65883: LIST
65884: LIST
65885: PUSH
65886: LD_INT 2
65888: NEG
65889: PUSH
65890: LD_INT 2
65892: NEG
65893: PUSH
65894: EMPTY
65895: LIST
65896: LIST
65897: PUSH
65898: EMPTY
65899: LIST
65900: LIST
65901: LIST
65902: LIST
65903: LIST
65904: LIST
65905: LIST
65906: LIST
65907: LIST
65908: LIST
65909: LIST
65910: LIST
65911: LIST
65912: LIST
65913: LIST
65914: LIST
65915: LIST
65916: LIST
65917: LIST
65918: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65919: LD_ADDR_VAR 0 21
65923: PUSH
65924: LD_INT 0
65926: PUSH
65927: LD_INT 0
65929: PUSH
65930: EMPTY
65931: LIST
65932: LIST
65933: PUSH
65934: LD_INT 0
65936: PUSH
65937: LD_INT 1
65939: NEG
65940: PUSH
65941: EMPTY
65942: LIST
65943: LIST
65944: PUSH
65945: LD_INT 1
65947: PUSH
65948: LD_INT 0
65950: PUSH
65951: EMPTY
65952: LIST
65953: LIST
65954: PUSH
65955: LD_INT 1
65957: PUSH
65958: LD_INT 1
65960: PUSH
65961: EMPTY
65962: LIST
65963: LIST
65964: PUSH
65965: LD_INT 0
65967: PUSH
65968: LD_INT 1
65970: PUSH
65971: EMPTY
65972: LIST
65973: LIST
65974: PUSH
65975: LD_INT 1
65977: NEG
65978: PUSH
65979: LD_INT 0
65981: PUSH
65982: EMPTY
65983: LIST
65984: LIST
65985: PUSH
65986: LD_INT 1
65988: NEG
65989: PUSH
65990: LD_INT 1
65992: NEG
65993: PUSH
65994: EMPTY
65995: LIST
65996: LIST
65997: PUSH
65998: LD_INT 1
66000: NEG
66001: PUSH
66002: LD_INT 2
66004: NEG
66005: PUSH
66006: EMPTY
66007: LIST
66008: LIST
66009: PUSH
66010: LD_INT 0
66012: PUSH
66013: LD_INT 2
66015: NEG
66016: PUSH
66017: EMPTY
66018: LIST
66019: LIST
66020: PUSH
66021: LD_INT 1
66023: PUSH
66024: LD_INT 1
66026: NEG
66027: PUSH
66028: EMPTY
66029: LIST
66030: LIST
66031: PUSH
66032: LD_INT 2
66034: PUSH
66035: LD_INT 0
66037: PUSH
66038: EMPTY
66039: LIST
66040: LIST
66041: PUSH
66042: LD_INT 2
66044: PUSH
66045: LD_INT 1
66047: PUSH
66048: EMPTY
66049: LIST
66050: LIST
66051: PUSH
66052: LD_INT 2
66054: PUSH
66055: LD_INT 2
66057: PUSH
66058: EMPTY
66059: LIST
66060: LIST
66061: PUSH
66062: LD_INT 1
66064: PUSH
66065: LD_INT 2
66067: PUSH
66068: EMPTY
66069: LIST
66070: LIST
66071: PUSH
66072: LD_INT 0
66074: PUSH
66075: LD_INT 2
66077: PUSH
66078: EMPTY
66079: LIST
66080: LIST
66081: PUSH
66082: LD_INT 1
66084: NEG
66085: PUSH
66086: LD_INT 1
66088: PUSH
66089: EMPTY
66090: LIST
66091: LIST
66092: PUSH
66093: LD_INT 2
66095: NEG
66096: PUSH
66097: LD_INT 0
66099: PUSH
66100: EMPTY
66101: LIST
66102: LIST
66103: PUSH
66104: LD_INT 2
66106: NEG
66107: PUSH
66108: LD_INT 1
66110: NEG
66111: PUSH
66112: EMPTY
66113: LIST
66114: LIST
66115: PUSH
66116: LD_INT 2
66118: NEG
66119: PUSH
66120: LD_INT 2
66122: NEG
66123: PUSH
66124: EMPTY
66125: LIST
66126: LIST
66127: PUSH
66128: EMPTY
66129: LIST
66130: LIST
66131: LIST
66132: LIST
66133: LIST
66134: LIST
66135: LIST
66136: LIST
66137: LIST
66138: LIST
66139: LIST
66140: LIST
66141: LIST
66142: LIST
66143: LIST
66144: LIST
66145: LIST
66146: LIST
66147: LIST
66148: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66149: LD_ADDR_VAR 0 22
66153: PUSH
66154: LD_INT 0
66156: PUSH
66157: LD_INT 0
66159: PUSH
66160: EMPTY
66161: LIST
66162: LIST
66163: PUSH
66164: LD_INT 0
66166: PUSH
66167: LD_INT 1
66169: NEG
66170: PUSH
66171: EMPTY
66172: LIST
66173: LIST
66174: PUSH
66175: LD_INT 1
66177: PUSH
66178: LD_INT 0
66180: PUSH
66181: EMPTY
66182: LIST
66183: LIST
66184: PUSH
66185: LD_INT 1
66187: PUSH
66188: LD_INT 1
66190: PUSH
66191: EMPTY
66192: LIST
66193: LIST
66194: PUSH
66195: LD_INT 0
66197: PUSH
66198: LD_INT 1
66200: PUSH
66201: EMPTY
66202: LIST
66203: LIST
66204: PUSH
66205: LD_INT 1
66207: NEG
66208: PUSH
66209: LD_INT 0
66211: PUSH
66212: EMPTY
66213: LIST
66214: LIST
66215: PUSH
66216: LD_INT 1
66218: NEG
66219: PUSH
66220: LD_INT 1
66222: NEG
66223: PUSH
66224: EMPTY
66225: LIST
66226: LIST
66227: PUSH
66228: LD_INT 1
66230: NEG
66231: PUSH
66232: LD_INT 2
66234: NEG
66235: PUSH
66236: EMPTY
66237: LIST
66238: LIST
66239: PUSH
66240: LD_INT 0
66242: PUSH
66243: LD_INT 2
66245: NEG
66246: PUSH
66247: EMPTY
66248: LIST
66249: LIST
66250: PUSH
66251: LD_INT 1
66253: PUSH
66254: LD_INT 1
66256: NEG
66257: PUSH
66258: EMPTY
66259: LIST
66260: LIST
66261: PUSH
66262: LD_INT 2
66264: PUSH
66265: LD_INT 0
66267: PUSH
66268: EMPTY
66269: LIST
66270: LIST
66271: PUSH
66272: LD_INT 2
66274: PUSH
66275: LD_INT 1
66277: PUSH
66278: EMPTY
66279: LIST
66280: LIST
66281: PUSH
66282: LD_INT 2
66284: PUSH
66285: LD_INT 2
66287: PUSH
66288: EMPTY
66289: LIST
66290: LIST
66291: PUSH
66292: LD_INT 1
66294: PUSH
66295: LD_INT 2
66297: PUSH
66298: EMPTY
66299: LIST
66300: LIST
66301: PUSH
66302: LD_INT 0
66304: PUSH
66305: LD_INT 2
66307: PUSH
66308: EMPTY
66309: LIST
66310: LIST
66311: PUSH
66312: LD_INT 1
66314: NEG
66315: PUSH
66316: LD_INT 1
66318: PUSH
66319: EMPTY
66320: LIST
66321: LIST
66322: PUSH
66323: LD_INT 2
66325: NEG
66326: PUSH
66327: LD_INT 0
66329: PUSH
66330: EMPTY
66331: LIST
66332: LIST
66333: PUSH
66334: LD_INT 2
66336: NEG
66337: PUSH
66338: LD_INT 1
66340: NEG
66341: PUSH
66342: EMPTY
66343: LIST
66344: LIST
66345: PUSH
66346: LD_INT 2
66348: NEG
66349: PUSH
66350: LD_INT 2
66352: NEG
66353: PUSH
66354: EMPTY
66355: LIST
66356: LIST
66357: PUSH
66358: EMPTY
66359: LIST
66360: LIST
66361: LIST
66362: LIST
66363: LIST
66364: LIST
66365: LIST
66366: LIST
66367: LIST
66368: LIST
66369: LIST
66370: LIST
66371: LIST
66372: LIST
66373: LIST
66374: LIST
66375: LIST
66376: LIST
66377: LIST
66378: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
66379: LD_ADDR_VAR 0 23
66383: PUSH
66384: LD_INT 0
66386: PUSH
66387: LD_INT 0
66389: PUSH
66390: EMPTY
66391: LIST
66392: LIST
66393: PUSH
66394: LD_INT 0
66396: PUSH
66397: LD_INT 1
66399: NEG
66400: PUSH
66401: EMPTY
66402: LIST
66403: LIST
66404: PUSH
66405: LD_INT 1
66407: PUSH
66408: LD_INT 0
66410: PUSH
66411: EMPTY
66412: LIST
66413: LIST
66414: PUSH
66415: LD_INT 1
66417: PUSH
66418: LD_INT 1
66420: PUSH
66421: EMPTY
66422: LIST
66423: LIST
66424: PUSH
66425: LD_INT 0
66427: PUSH
66428: LD_INT 1
66430: PUSH
66431: EMPTY
66432: LIST
66433: LIST
66434: PUSH
66435: LD_INT 1
66437: NEG
66438: PUSH
66439: LD_INT 0
66441: PUSH
66442: EMPTY
66443: LIST
66444: LIST
66445: PUSH
66446: LD_INT 1
66448: NEG
66449: PUSH
66450: LD_INT 1
66452: NEG
66453: PUSH
66454: EMPTY
66455: LIST
66456: LIST
66457: PUSH
66458: LD_INT 1
66460: NEG
66461: PUSH
66462: LD_INT 2
66464: NEG
66465: PUSH
66466: EMPTY
66467: LIST
66468: LIST
66469: PUSH
66470: LD_INT 0
66472: PUSH
66473: LD_INT 2
66475: NEG
66476: PUSH
66477: EMPTY
66478: LIST
66479: LIST
66480: PUSH
66481: LD_INT 1
66483: PUSH
66484: LD_INT 1
66486: NEG
66487: PUSH
66488: EMPTY
66489: LIST
66490: LIST
66491: PUSH
66492: LD_INT 2
66494: PUSH
66495: LD_INT 0
66497: PUSH
66498: EMPTY
66499: LIST
66500: LIST
66501: PUSH
66502: LD_INT 2
66504: PUSH
66505: LD_INT 1
66507: PUSH
66508: EMPTY
66509: LIST
66510: LIST
66511: PUSH
66512: LD_INT 2
66514: PUSH
66515: LD_INT 2
66517: PUSH
66518: EMPTY
66519: LIST
66520: LIST
66521: PUSH
66522: LD_INT 1
66524: PUSH
66525: LD_INT 2
66527: PUSH
66528: EMPTY
66529: LIST
66530: LIST
66531: PUSH
66532: LD_INT 0
66534: PUSH
66535: LD_INT 2
66537: PUSH
66538: EMPTY
66539: LIST
66540: LIST
66541: PUSH
66542: LD_INT 1
66544: NEG
66545: PUSH
66546: LD_INT 1
66548: PUSH
66549: EMPTY
66550: LIST
66551: LIST
66552: PUSH
66553: LD_INT 2
66555: NEG
66556: PUSH
66557: LD_INT 0
66559: PUSH
66560: EMPTY
66561: LIST
66562: LIST
66563: PUSH
66564: LD_INT 2
66566: NEG
66567: PUSH
66568: LD_INT 1
66570: NEG
66571: PUSH
66572: EMPTY
66573: LIST
66574: LIST
66575: PUSH
66576: LD_INT 2
66578: NEG
66579: PUSH
66580: LD_INT 2
66582: NEG
66583: PUSH
66584: EMPTY
66585: LIST
66586: LIST
66587: PUSH
66588: LD_INT 2
66590: NEG
66591: PUSH
66592: LD_INT 3
66594: NEG
66595: PUSH
66596: EMPTY
66597: LIST
66598: LIST
66599: PUSH
66600: LD_INT 1
66602: NEG
66603: PUSH
66604: LD_INT 3
66606: NEG
66607: PUSH
66608: EMPTY
66609: LIST
66610: LIST
66611: PUSH
66612: LD_INT 1
66614: PUSH
66615: LD_INT 2
66617: NEG
66618: PUSH
66619: EMPTY
66620: LIST
66621: LIST
66622: PUSH
66623: LD_INT 2
66625: PUSH
66626: LD_INT 1
66628: NEG
66629: PUSH
66630: EMPTY
66631: LIST
66632: LIST
66633: PUSH
66634: EMPTY
66635: LIST
66636: LIST
66637: LIST
66638: LIST
66639: LIST
66640: LIST
66641: LIST
66642: LIST
66643: LIST
66644: LIST
66645: LIST
66646: LIST
66647: LIST
66648: LIST
66649: LIST
66650: LIST
66651: LIST
66652: LIST
66653: LIST
66654: LIST
66655: LIST
66656: LIST
66657: LIST
66658: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
66659: LD_ADDR_VAR 0 24
66663: PUSH
66664: LD_INT 0
66666: PUSH
66667: LD_INT 0
66669: PUSH
66670: EMPTY
66671: LIST
66672: LIST
66673: PUSH
66674: LD_INT 0
66676: PUSH
66677: LD_INT 1
66679: NEG
66680: PUSH
66681: EMPTY
66682: LIST
66683: LIST
66684: PUSH
66685: LD_INT 1
66687: PUSH
66688: LD_INT 0
66690: PUSH
66691: EMPTY
66692: LIST
66693: LIST
66694: PUSH
66695: LD_INT 1
66697: PUSH
66698: LD_INT 1
66700: PUSH
66701: EMPTY
66702: LIST
66703: LIST
66704: PUSH
66705: LD_INT 0
66707: PUSH
66708: LD_INT 1
66710: PUSH
66711: EMPTY
66712: LIST
66713: LIST
66714: PUSH
66715: LD_INT 1
66717: NEG
66718: PUSH
66719: LD_INT 0
66721: PUSH
66722: EMPTY
66723: LIST
66724: LIST
66725: PUSH
66726: LD_INT 1
66728: NEG
66729: PUSH
66730: LD_INT 1
66732: NEG
66733: PUSH
66734: EMPTY
66735: LIST
66736: LIST
66737: PUSH
66738: LD_INT 1
66740: NEG
66741: PUSH
66742: LD_INT 2
66744: NEG
66745: PUSH
66746: EMPTY
66747: LIST
66748: LIST
66749: PUSH
66750: LD_INT 0
66752: PUSH
66753: LD_INT 2
66755: NEG
66756: PUSH
66757: EMPTY
66758: LIST
66759: LIST
66760: PUSH
66761: LD_INT 1
66763: PUSH
66764: LD_INT 1
66766: NEG
66767: PUSH
66768: EMPTY
66769: LIST
66770: LIST
66771: PUSH
66772: LD_INT 2
66774: PUSH
66775: LD_INT 0
66777: PUSH
66778: EMPTY
66779: LIST
66780: LIST
66781: PUSH
66782: LD_INT 2
66784: PUSH
66785: LD_INT 1
66787: PUSH
66788: EMPTY
66789: LIST
66790: LIST
66791: PUSH
66792: LD_INT 2
66794: PUSH
66795: LD_INT 2
66797: PUSH
66798: EMPTY
66799: LIST
66800: LIST
66801: PUSH
66802: LD_INT 1
66804: PUSH
66805: LD_INT 2
66807: PUSH
66808: EMPTY
66809: LIST
66810: LIST
66811: PUSH
66812: LD_INT 0
66814: PUSH
66815: LD_INT 2
66817: PUSH
66818: EMPTY
66819: LIST
66820: LIST
66821: PUSH
66822: LD_INT 1
66824: NEG
66825: PUSH
66826: LD_INT 1
66828: PUSH
66829: EMPTY
66830: LIST
66831: LIST
66832: PUSH
66833: LD_INT 2
66835: NEG
66836: PUSH
66837: LD_INT 0
66839: PUSH
66840: EMPTY
66841: LIST
66842: LIST
66843: PUSH
66844: LD_INT 2
66846: NEG
66847: PUSH
66848: LD_INT 1
66850: NEG
66851: PUSH
66852: EMPTY
66853: LIST
66854: LIST
66855: PUSH
66856: LD_INT 2
66858: NEG
66859: PUSH
66860: LD_INT 2
66862: NEG
66863: PUSH
66864: EMPTY
66865: LIST
66866: LIST
66867: PUSH
66868: LD_INT 1
66870: PUSH
66871: LD_INT 2
66873: NEG
66874: PUSH
66875: EMPTY
66876: LIST
66877: LIST
66878: PUSH
66879: LD_INT 2
66881: PUSH
66882: LD_INT 1
66884: NEG
66885: PUSH
66886: EMPTY
66887: LIST
66888: LIST
66889: PUSH
66890: LD_INT 3
66892: PUSH
66893: LD_INT 1
66895: PUSH
66896: EMPTY
66897: LIST
66898: LIST
66899: PUSH
66900: LD_INT 3
66902: PUSH
66903: LD_INT 2
66905: PUSH
66906: EMPTY
66907: LIST
66908: LIST
66909: PUSH
66910: EMPTY
66911: LIST
66912: LIST
66913: LIST
66914: LIST
66915: LIST
66916: LIST
66917: LIST
66918: LIST
66919: LIST
66920: LIST
66921: LIST
66922: LIST
66923: LIST
66924: LIST
66925: LIST
66926: LIST
66927: LIST
66928: LIST
66929: LIST
66930: LIST
66931: LIST
66932: LIST
66933: LIST
66934: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
66935: LD_ADDR_VAR 0 25
66939: PUSH
66940: LD_INT 0
66942: PUSH
66943: LD_INT 0
66945: PUSH
66946: EMPTY
66947: LIST
66948: LIST
66949: PUSH
66950: LD_INT 0
66952: PUSH
66953: LD_INT 1
66955: NEG
66956: PUSH
66957: EMPTY
66958: LIST
66959: LIST
66960: PUSH
66961: LD_INT 1
66963: PUSH
66964: LD_INT 0
66966: PUSH
66967: EMPTY
66968: LIST
66969: LIST
66970: PUSH
66971: LD_INT 1
66973: PUSH
66974: LD_INT 1
66976: PUSH
66977: EMPTY
66978: LIST
66979: LIST
66980: PUSH
66981: LD_INT 0
66983: PUSH
66984: LD_INT 1
66986: PUSH
66987: EMPTY
66988: LIST
66989: LIST
66990: PUSH
66991: LD_INT 1
66993: NEG
66994: PUSH
66995: LD_INT 0
66997: PUSH
66998: EMPTY
66999: LIST
67000: LIST
67001: PUSH
67002: LD_INT 1
67004: NEG
67005: PUSH
67006: LD_INT 1
67008: NEG
67009: PUSH
67010: EMPTY
67011: LIST
67012: LIST
67013: PUSH
67014: LD_INT 1
67016: NEG
67017: PUSH
67018: LD_INT 2
67020: NEG
67021: PUSH
67022: EMPTY
67023: LIST
67024: LIST
67025: PUSH
67026: LD_INT 0
67028: PUSH
67029: LD_INT 2
67031: NEG
67032: PUSH
67033: EMPTY
67034: LIST
67035: LIST
67036: PUSH
67037: LD_INT 1
67039: PUSH
67040: LD_INT 1
67042: NEG
67043: PUSH
67044: EMPTY
67045: LIST
67046: LIST
67047: PUSH
67048: LD_INT 2
67050: PUSH
67051: LD_INT 0
67053: PUSH
67054: EMPTY
67055: LIST
67056: LIST
67057: PUSH
67058: LD_INT 2
67060: PUSH
67061: LD_INT 1
67063: PUSH
67064: EMPTY
67065: LIST
67066: LIST
67067: PUSH
67068: LD_INT 2
67070: PUSH
67071: LD_INT 2
67073: PUSH
67074: EMPTY
67075: LIST
67076: LIST
67077: PUSH
67078: LD_INT 1
67080: PUSH
67081: LD_INT 2
67083: PUSH
67084: EMPTY
67085: LIST
67086: LIST
67087: PUSH
67088: LD_INT 0
67090: PUSH
67091: LD_INT 2
67093: PUSH
67094: EMPTY
67095: LIST
67096: LIST
67097: PUSH
67098: LD_INT 1
67100: NEG
67101: PUSH
67102: LD_INT 1
67104: PUSH
67105: EMPTY
67106: LIST
67107: LIST
67108: PUSH
67109: LD_INT 2
67111: NEG
67112: PUSH
67113: LD_INT 0
67115: PUSH
67116: EMPTY
67117: LIST
67118: LIST
67119: PUSH
67120: LD_INT 2
67122: NEG
67123: PUSH
67124: LD_INT 1
67126: NEG
67127: PUSH
67128: EMPTY
67129: LIST
67130: LIST
67131: PUSH
67132: LD_INT 2
67134: NEG
67135: PUSH
67136: LD_INT 2
67138: NEG
67139: PUSH
67140: EMPTY
67141: LIST
67142: LIST
67143: PUSH
67144: LD_INT 3
67146: PUSH
67147: LD_INT 1
67149: PUSH
67150: EMPTY
67151: LIST
67152: LIST
67153: PUSH
67154: LD_INT 3
67156: PUSH
67157: LD_INT 2
67159: PUSH
67160: EMPTY
67161: LIST
67162: LIST
67163: PUSH
67164: LD_INT 2
67166: PUSH
67167: LD_INT 3
67169: PUSH
67170: EMPTY
67171: LIST
67172: LIST
67173: PUSH
67174: LD_INT 1
67176: PUSH
67177: LD_INT 3
67179: PUSH
67180: EMPTY
67181: LIST
67182: LIST
67183: PUSH
67184: EMPTY
67185: LIST
67186: LIST
67187: LIST
67188: LIST
67189: LIST
67190: LIST
67191: LIST
67192: LIST
67193: LIST
67194: LIST
67195: LIST
67196: LIST
67197: LIST
67198: LIST
67199: LIST
67200: LIST
67201: LIST
67202: LIST
67203: LIST
67204: LIST
67205: LIST
67206: LIST
67207: LIST
67208: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
67209: LD_ADDR_VAR 0 26
67213: PUSH
67214: LD_INT 0
67216: PUSH
67217: LD_INT 0
67219: PUSH
67220: EMPTY
67221: LIST
67222: LIST
67223: PUSH
67224: LD_INT 0
67226: PUSH
67227: LD_INT 1
67229: NEG
67230: PUSH
67231: EMPTY
67232: LIST
67233: LIST
67234: PUSH
67235: LD_INT 1
67237: PUSH
67238: LD_INT 0
67240: PUSH
67241: EMPTY
67242: LIST
67243: LIST
67244: PUSH
67245: LD_INT 1
67247: PUSH
67248: LD_INT 1
67250: PUSH
67251: EMPTY
67252: LIST
67253: LIST
67254: PUSH
67255: LD_INT 0
67257: PUSH
67258: LD_INT 1
67260: PUSH
67261: EMPTY
67262: LIST
67263: LIST
67264: PUSH
67265: LD_INT 1
67267: NEG
67268: PUSH
67269: LD_INT 0
67271: PUSH
67272: EMPTY
67273: LIST
67274: LIST
67275: PUSH
67276: LD_INT 1
67278: NEG
67279: PUSH
67280: LD_INT 1
67282: NEG
67283: PUSH
67284: EMPTY
67285: LIST
67286: LIST
67287: PUSH
67288: LD_INT 1
67290: NEG
67291: PUSH
67292: LD_INT 2
67294: NEG
67295: PUSH
67296: EMPTY
67297: LIST
67298: LIST
67299: PUSH
67300: LD_INT 0
67302: PUSH
67303: LD_INT 2
67305: NEG
67306: PUSH
67307: EMPTY
67308: LIST
67309: LIST
67310: PUSH
67311: LD_INT 1
67313: PUSH
67314: LD_INT 1
67316: NEG
67317: PUSH
67318: EMPTY
67319: LIST
67320: LIST
67321: PUSH
67322: LD_INT 2
67324: PUSH
67325: LD_INT 0
67327: PUSH
67328: EMPTY
67329: LIST
67330: LIST
67331: PUSH
67332: LD_INT 2
67334: PUSH
67335: LD_INT 1
67337: PUSH
67338: EMPTY
67339: LIST
67340: LIST
67341: PUSH
67342: LD_INT 2
67344: PUSH
67345: LD_INT 2
67347: PUSH
67348: EMPTY
67349: LIST
67350: LIST
67351: PUSH
67352: LD_INT 1
67354: PUSH
67355: LD_INT 2
67357: PUSH
67358: EMPTY
67359: LIST
67360: LIST
67361: PUSH
67362: LD_INT 0
67364: PUSH
67365: LD_INT 2
67367: PUSH
67368: EMPTY
67369: LIST
67370: LIST
67371: PUSH
67372: LD_INT 1
67374: NEG
67375: PUSH
67376: LD_INT 1
67378: PUSH
67379: EMPTY
67380: LIST
67381: LIST
67382: PUSH
67383: LD_INT 2
67385: NEG
67386: PUSH
67387: LD_INT 0
67389: PUSH
67390: EMPTY
67391: LIST
67392: LIST
67393: PUSH
67394: LD_INT 2
67396: NEG
67397: PUSH
67398: LD_INT 1
67400: NEG
67401: PUSH
67402: EMPTY
67403: LIST
67404: LIST
67405: PUSH
67406: LD_INT 2
67408: NEG
67409: PUSH
67410: LD_INT 2
67412: NEG
67413: PUSH
67414: EMPTY
67415: LIST
67416: LIST
67417: PUSH
67418: LD_INT 2
67420: PUSH
67421: LD_INT 3
67423: PUSH
67424: EMPTY
67425: LIST
67426: LIST
67427: PUSH
67428: LD_INT 1
67430: PUSH
67431: LD_INT 3
67433: PUSH
67434: EMPTY
67435: LIST
67436: LIST
67437: PUSH
67438: LD_INT 1
67440: NEG
67441: PUSH
67442: LD_INT 2
67444: PUSH
67445: EMPTY
67446: LIST
67447: LIST
67448: PUSH
67449: LD_INT 2
67451: NEG
67452: PUSH
67453: LD_INT 1
67455: PUSH
67456: EMPTY
67457: LIST
67458: LIST
67459: PUSH
67460: EMPTY
67461: LIST
67462: LIST
67463: LIST
67464: LIST
67465: LIST
67466: LIST
67467: LIST
67468: LIST
67469: LIST
67470: LIST
67471: LIST
67472: LIST
67473: LIST
67474: LIST
67475: LIST
67476: LIST
67477: LIST
67478: LIST
67479: LIST
67480: LIST
67481: LIST
67482: LIST
67483: LIST
67484: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
67485: LD_ADDR_VAR 0 27
67489: PUSH
67490: LD_INT 0
67492: PUSH
67493: LD_INT 0
67495: PUSH
67496: EMPTY
67497: LIST
67498: LIST
67499: PUSH
67500: LD_INT 0
67502: PUSH
67503: LD_INT 1
67505: NEG
67506: PUSH
67507: EMPTY
67508: LIST
67509: LIST
67510: PUSH
67511: LD_INT 1
67513: PUSH
67514: LD_INT 0
67516: PUSH
67517: EMPTY
67518: LIST
67519: LIST
67520: PUSH
67521: LD_INT 1
67523: PUSH
67524: LD_INT 1
67526: PUSH
67527: EMPTY
67528: LIST
67529: LIST
67530: PUSH
67531: LD_INT 0
67533: PUSH
67534: LD_INT 1
67536: PUSH
67537: EMPTY
67538: LIST
67539: LIST
67540: PUSH
67541: LD_INT 1
67543: NEG
67544: PUSH
67545: LD_INT 0
67547: PUSH
67548: EMPTY
67549: LIST
67550: LIST
67551: PUSH
67552: LD_INT 1
67554: NEG
67555: PUSH
67556: LD_INT 1
67558: NEG
67559: PUSH
67560: EMPTY
67561: LIST
67562: LIST
67563: PUSH
67564: LD_INT 1
67566: NEG
67567: PUSH
67568: LD_INT 2
67570: NEG
67571: PUSH
67572: EMPTY
67573: LIST
67574: LIST
67575: PUSH
67576: LD_INT 0
67578: PUSH
67579: LD_INT 2
67581: NEG
67582: PUSH
67583: EMPTY
67584: LIST
67585: LIST
67586: PUSH
67587: LD_INT 1
67589: PUSH
67590: LD_INT 1
67592: NEG
67593: PUSH
67594: EMPTY
67595: LIST
67596: LIST
67597: PUSH
67598: LD_INT 2
67600: PUSH
67601: LD_INT 0
67603: PUSH
67604: EMPTY
67605: LIST
67606: LIST
67607: PUSH
67608: LD_INT 2
67610: PUSH
67611: LD_INT 1
67613: PUSH
67614: EMPTY
67615: LIST
67616: LIST
67617: PUSH
67618: LD_INT 2
67620: PUSH
67621: LD_INT 2
67623: PUSH
67624: EMPTY
67625: LIST
67626: LIST
67627: PUSH
67628: LD_INT 1
67630: PUSH
67631: LD_INT 2
67633: PUSH
67634: EMPTY
67635: LIST
67636: LIST
67637: PUSH
67638: LD_INT 0
67640: PUSH
67641: LD_INT 2
67643: PUSH
67644: EMPTY
67645: LIST
67646: LIST
67647: PUSH
67648: LD_INT 1
67650: NEG
67651: PUSH
67652: LD_INT 1
67654: PUSH
67655: EMPTY
67656: LIST
67657: LIST
67658: PUSH
67659: LD_INT 2
67661: NEG
67662: PUSH
67663: LD_INT 0
67665: PUSH
67666: EMPTY
67667: LIST
67668: LIST
67669: PUSH
67670: LD_INT 2
67672: NEG
67673: PUSH
67674: LD_INT 1
67676: NEG
67677: PUSH
67678: EMPTY
67679: LIST
67680: LIST
67681: PUSH
67682: LD_INT 2
67684: NEG
67685: PUSH
67686: LD_INT 2
67688: NEG
67689: PUSH
67690: EMPTY
67691: LIST
67692: LIST
67693: PUSH
67694: LD_INT 1
67696: NEG
67697: PUSH
67698: LD_INT 2
67700: PUSH
67701: EMPTY
67702: LIST
67703: LIST
67704: PUSH
67705: LD_INT 2
67707: NEG
67708: PUSH
67709: LD_INT 1
67711: PUSH
67712: EMPTY
67713: LIST
67714: LIST
67715: PUSH
67716: LD_INT 3
67718: NEG
67719: PUSH
67720: LD_INT 1
67722: NEG
67723: PUSH
67724: EMPTY
67725: LIST
67726: LIST
67727: PUSH
67728: LD_INT 3
67730: NEG
67731: PUSH
67732: LD_INT 2
67734: NEG
67735: PUSH
67736: EMPTY
67737: LIST
67738: LIST
67739: PUSH
67740: EMPTY
67741: LIST
67742: LIST
67743: LIST
67744: LIST
67745: LIST
67746: LIST
67747: LIST
67748: LIST
67749: LIST
67750: LIST
67751: LIST
67752: LIST
67753: LIST
67754: LIST
67755: LIST
67756: LIST
67757: LIST
67758: LIST
67759: LIST
67760: LIST
67761: LIST
67762: LIST
67763: LIST
67764: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
67765: LD_ADDR_VAR 0 28
67769: PUSH
67770: LD_INT 0
67772: PUSH
67773: LD_INT 0
67775: PUSH
67776: EMPTY
67777: LIST
67778: LIST
67779: PUSH
67780: LD_INT 0
67782: PUSH
67783: LD_INT 1
67785: NEG
67786: PUSH
67787: EMPTY
67788: LIST
67789: LIST
67790: PUSH
67791: LD_INT 1
67793: PUSH
67794: LD_INT 0
67796: PUSH
67797: EMPTY
67798: LIST
67799: LIST
67800: PUSH
67801: LD_INT 1
67803: PUSH
67804: LD_INT 1
67806: PUSH
67807: EMPTY
67808: LIST
67809: LIST
67810: PUSH
67811: LD_INT 0
67813: PUSH
67814: LD_INT 1
67816: PUSH
67817: EMPTY
67818: LIST
67819: LIST
67820: PUSH
67821: LD_INT 1
67823: NEG
67824: PUSH
67825: LD_INT 0
67827: PUSH
67828: EMPTY
67829: LIST
67830: LIST
67831: PUSH
67832: LD_INT 1
67834: NEG
67835: PUSH
67836: LD_INT 1
67838: NEG
67839: PUSH
67840: EMPTY
67841: LIST
67842: LIST
67843: PUSH
67844: LD_INT 1
67846: NEG
67847: PUSH
67848: LD_INT 2
67850: NEG
67851: PUSH
67852: EMPTY
67853: LIST
67854: LIST
67855: PUSH
67856: LD_INT 0
67858: PUSH
67859: LD_INT 2
67861: NEG
67862: PUSH
67863: EMPTY
67864: LIST
67865: LIST
67866: PUSH
67867: LD_INT 1
67869: PUSH
67870: LD_INT 1
67872: NEG
67873: PUSH
67874: EMPTY
67875: LIST
67876: LIST
67877: PUSH
67878: LD_INT 2
67880: PUSH
67881: LD_INT 0
67883: PUSH
67884: EMPTY
67885: LIST
67886: LIST
67887: PUSH
67888: LD_INT 2
67890: PUSH
67891: LD_INT 1
67893: PUSH
67894: EMPTY
67895: LIST
67896: LIST
67897: PUSH
67898: LD_INT 2
67900: PUSH
67901: LD_INT 2
67903: PUSH
67904: EMPTY
67905: LIST
67906: LIST
67907: PUSH
67908: LD_INT 1
67910: PUSH
67911: LD_INT 2
67913: PUSH
67914: EMPTY
67915: LIST
67916: LIST
67917: PUSH
67918: LD_INT 0
67920: PUSH
67921: LD_INT 2
67923: PUSH
67924: EMPTY
67925: LIST
67926: LIST
67927: PUSH
67928: LD_INT 1
67930: NEG
67931: PUSH
67932: LD_INT 1
67934: PUSH
67935: EMPTY
67936: LIST
67937: LIST
67938: PUSH
67939: LD_INT 2
67941: NEG
67942: PUSH
67943: LD_INT 0
67945: PUSH
67946: EMPTY
67947: LIST
67948: LIST
67949: PUSH
67950: LD_INT 2
67952: NEG
67953: PUSH
67954: LD_INT 1
67956: NEG
67957: PUSH
67958: EMPTY
67959: LIST
67960: LIST
67961: PUSH
67962: LD_INT 2
67964: NEG
67965: PUSH
67966: LD_INT 2
67968: NEG
67969: PUSH
67970: EMPTY
67971: LIST
67972: LIST
67973: PUSH
67974: LD_INT 2
67976: NEG
67977: PUSH
67978: LD_INT 3
67980: NEG
67981: PUSH
67982: EMPTY
67983: LIST
67984: LIST
67985: PUSH
67986: LD_INT 1
67988: NEG
67989: PUSH
67990: LD_INT 3
67992: NEG
67993: PUSH
67994: EMPTY
67995: LIST
67996: LIST
67997: PUSH
67998: LD_INT 3
68000: NEG
68001: PUSH
68002: LD_INT 1
68004: NEG
68005: PUSH
68006: EMPTY
68007: LIST
68008: LIST
68009: PUSH
68010: LD_INT 3
68012: NEG
68013: PUSH
68014: LD_INT 2
68016: NEG
68017: PUSH
68018: EMPTY
68019: LIST
68020: LIST
68021: PUSH
68022: EMPTY
68023: LIST
68024: LIST
68025: LIST
68026: LIST
68027: LIST
68028: LIST
68029: LIST
68030: LIST
68031: LIST
68032: LIST
68033: LIST
68034: LIST
68035: LIST
68036: LIST
68037: LIST
68038: LIST
68039: LIST
68040: LIST
68041: LIST
68042: LIST
68043: LIST
68044: LIST
68045: LIST
68046: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
68047: LD_ADDR_VAR 0 29
68051: PUSH
68052: LD_INT 0
68054: PUSH
68055: LD_INT 0
68057: PUSH
68058: EMPTY
68059: LIST
68060: LIST
68061: PUSH
68062: LD_INT 0
68064: PUSH
68065: LD_INT 1
68067: NEG
68068: PUSH
68069: EMPTY
68070: LIST
68071: LIST
68072: PUSH
68073: LD_INT 1
68075: PUSH
68076: LD_INT 0
68078: PUSH
68079: EMPTY
68080: LIST
68081: LIST
68082: PUSH
68083: LD_INT 1
68085: PUSH
68086: LD_INT 1
68088: PUSH
68089: EMPTY
68090: LIST
68091: LIST
68092: PUSH
68093: LD_INT 0
68095: PUSH
68096: LD_INT 1
68098: PUSH
68099: EMPTY
68100: LIST
68101: LIST
68102: PUSH
68103: LD_INT 1
68105: NEG
68106: PUSH
68107: LD_INT 0
68109: PUSH
68110: EMPTY
68111: LIST
68112: LIST
68113: PUSH
68114: LD_INT 1
68116: NEG
68117: PUSH
68118: LD_INT 1
68120: NEG
68121: PUSH
68122: EMPTY
68123: LIST
68124: LIST
68125: PUSH
68126: LD_INT 1
68128: NEG
68129: PUSH
68130: LD_INT 2
68132: NEG
68133: PUSH
68134: EMPTY
68135: LIST
68136: LIST
68137: PUSH
68138: LD_INT 0
68140: PUSH
68141: LD_INT 2
68143: NEG
68144: PUSH
68145: EMPTY
68146: LIST
68147: LIST
68148: PUSH
68149: LD_INT 1
68151: PUSH
68152: LD_INT 1
68154: NEG
68155: PUSH
68156: EMPTY
68157: LIST
68158: LIST
68159: PUSH
68160: LD_INT 2
68162: PUSH
68163: LD_INT 0
68165: PUSH
68166: EMPTY
68167: LIST
68168: LIST
68169: PUSH
68170: LD_INT 2
68172: PUSH
68173: LD_INT 1
68175: PUSH
68176: EMPTY
68177: LIST
68178: LIST
68179: PUSH
68180: LD_INT 1
68182: PUSH
68183: LD_INT 2
68185: PUSH
68186: EMPTY
68187: LIST
68188: LIST
68189: PUSH
68190: LD_INT 0
68192: PUSH
68193: LD_INT 2
68195: PUSH
68196: EMPTY
68197: LIST
68198: LIST
68199: PUSH
68200: LD_INT 1
68202: NEG
68203: PUSH
68204: LD_INT 1
68206: PUSH
68207: EMPTY
68208: LIST
68209: LIST
68210: PUSH
68211: LD_INT 2
68213: NEG
68214: PUSH
68215: LD_INT 1
68217: NEG
68218: PUSH
68219: EMPTY
68220: LIST
68221: LIST
68222: PUSH
68223: LD_INT 2
68225: NEG
68226: PUSH
68227: LD_INT 2
68229: NEG
68230: PUSH
68231: EMPTY
68232: LIST
68233: LIST
68234: PUSH
68235: LD_INT 2
68237: NEG
68238: PUSH
68239: LD_INT 3
68241: NEG
68242: PUSH
68243: EMPTY
68244: LIST
68245: LIST
68246: PUSH
68247: LD_INT 2
68249: PUSH
68250: LD_INT 1
68252: NEG
68253: PUSH
68254: EMPTY
68255: LIST
68256: LIST
68257: PUSH
68258: LD_INT 3
68260: PUSH
68261: LD_INT 1
68263: PUSH
68264: EMPTY
68265: LIST
68266: LIST
68267: PUSH
68268: LD_INT 1
68270: PUSH
68271: LD_INT 3
68273: PUSH
68274: EMPTY
68275: LIST
68276: LIST
68277: PUSH
68278: LD_INT 1
68280: NEG
68281: PUSH
68282: LD_INT 2
68284: PUSH
68285: EMPTY
68286: LIST
68287: LIST
68288: PUSH
68289: LD_INT 3
68291: NEG
68292: PUSH
68293: LD_INT 2
68295: NEG
68296: PUSH
68297: EMPTY
68298: LIST
68299: LIST
68300: PUSH
68301: EMPTY
68302: LIST
68303: LIST
68304: LIST
68305: LIST
68306: LIST
68307: LIST
68308: LIST
68309: LIST
68310: LIST
68311: LIST
68312: LIST
68313: LIST
68314: LIST
68315: LIST
68316: LIST
68317: LIST
68318: LIST
68319: LIST
68320: LIST
68321: LIST
68322: LIST
68323: LIST
68324: LIST
68325: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
68326: LD_ADDR_VAR 0 30
68330: PUSH
68331: LD_INT 0
68333: PUSH
68334: LD_INT 0
68336: PUSH
68337: EMPTY
68338: LIST
68339: LIST
68340: PUSH
68341: LD_INT 0
68343: PUSH
68344: LD_INT 1
68346: NEG
68347: PUSH
68348: EMPTY
68349: LIST
68350: LIST
68351: PUSH
68352: LD_INT 1
68354: PUSH
68355: LD_INT 0
68357: PUSH
68358: EMPTY
68359: LIST
68360: LIST
68361: PUSH
68362: LD_INT 1
68364: PUSH
68365: LD_INT 1
68367: PUSH
68368: EMPTY
68369: LIST
68370: LIST
68371: PUSH
68372: LD_INT 0
68374: PUSH
68375: LD_INT 1
68377: PUSH
68378: EMPTY
68379: LIST
68380: LIST
68381: PUSH
68382: LD_INT 1
68384: NEG
68385: PUSH
68386: LD_INT 0
68388: PUSH
68389: EMPTY
68390: LIST
68391: LIST
68392: PUSH
68393: LD_INT 1
68395: NEG
68396: PUSH
68397: LD_INT 1
68399: NEG
68400: PUSH
68401: EMPTY
68402: LIST
68403: LIST
68404: PUSH
68405: LD_INT 1
68407: NEG
68408: PUSH
68409: LD_INT 2
68411: NEG
68412: PUSH
68413: EMPTY
68414: LIST
68415: LIST
68416: PUSH
68417: LD_INT 0
68419: PUSH
68420: LD_INT 2
68422: NEG
68423: PUSH
68424: EMPTY
68425: LIST
68426: LIST
68427: PUSH
68428: LD_INT 1
68430: PUSH
68431: LD_INT 1
68433: NEG
68434: PUSH
68435: EMPTY
68436: LIST
68437: LIST
68438: PUSH
68439: LD_INT 2
68441: PUSH
68442: LD_INT 0
68444: PUSH
68445: EMPTY
68446: LIST
68447: LIST
68448: PUSH
68449: LD_INT 2
68451: PUSH
68452: LD_INT 1
68454: PUSH
68455: EMPTY
68456: LIST
68457: LIST
68458: PUSH
68459: LD_INT 2
68461: PUSH
68462: LD_INT 2
68464: PUSH
68465: EMPTY
68466: LIST
68467: LIST
68468: PUSH
68469: LD_INT 1
68471: PUSH
68472: LD_INT 2
68474: PUSH
68475: EMPTY
68476: LIST
68477: LIST
68478: PUSH
68479: LD_INT 1
68481: NEG
68482: PUSH
68483: LD_INT 1
68485: PUSH
68486: EMPTY
68487: LIST
68488: LIST
68489: PUSH
68490: LD_INT 2
68492: NEG
68493: PUSH
68494: LD_INT 0
68496: PUSH
68497: EMPTY
68498: LIST
68499: LIST
68500: PUSH
68501: LD_INT 2
68503: NEG
68504: PUSH
68505: LD_INT 1
68507: NEG
68508: PUSH
68509: EMPTY
68510: LIST
68511: LIST
68512: PUSH
68513: LD_INT 1
68515: NEG
68516: PUSH
68517: LD_INT 3
68519: NEG
68520: PUSH
68521: EMPTY
68522: LIST
68523: LIST
68524: PUSH
68525: LD_INT 1
68527: PUSH
68528: LD_INT 2
68530: NEG
68531: PUSH
68532: EMPTY
68533: LIST
68534: LIST
68535: PUSH
68536: LD_INT 3
68538: PUSH
68539: LD_INT 2
68541: PUSH
68542: EMPTY
68543: LIST
68544: LIST
68545: PUSH
68546: LD_INT 2
68548: PUSH
68549: LD_INT 3
68551: PUSH
68552: EMPTY
68553: LIST
68554: LIST
68555: PUSH
68556: LD_INT 2
68558: NEG
68559: PUSH
68560: LD_INT 1
68562: PUSH
68563: EMPTY
68564: LIST
68565: LIST
68566: PUSH
68567: LD_INT 3
68569: NEG
68570: PUSH
68571: LD_INT 1
68573: NEG
68574: PUSH
68575: EMPTY
68576: LIST
68577: LIST
68578: PUSH
68579: EMPTY
68580: LIST
68581: LIST
68582: LIST
68583: LIST
68584: LIST
68585: LIST
68586: LIST
68587: LIST
68588: LIST
68589: LIST
68590: LIST
68591: LIST
68592: LIST
68593: LIST
68594: LIST
68595: LIST
68596: LIST
68597: LIST
68598: LIST
68599: LIST
68600: LIST
68601: LIST
68602: LIST
68603: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
68604: LD_ADDR_VAR 0 31
68608: PUSH
68609: LD_INT 0
68611: PUSH
68612: LD_INT 0
68614: PUSH
68615: EMPTY
68616: LIST
68617: LIST
68618: PUSH
68619: LD_INT 0
68621: PUSH
68622: LD_INT 1
68624: NEG
68625: PUSH
68626: EMPTY
68627: LIST
68628: LIST
68629: PUSH
68630: LD_INT 1
68632: PUSH
68633: LD_INT 0
68635: PUSH
68636: EMPTY
68637: LIST
68638: LIST
68639: PUSH
68640: LD_INT 1
68642: PUSH
68643: LD_INT 1
68645: PUSH
68646: EMPTY
68647: LIST
68648: LIST
68649: PUSH
68650: LD_INT 0
68652: PUSH
68653: LD_INT 1
68655: PUSH
68656: EMPTY
68657: LIST
68658: LIST
68659: PUSH
68660: LD_INT 1
68662: NEG
68663: PUSH
68664: LD_INT 0
68666: PUSH
68667: EMPTY
68668: LIST
68669: LIST
68670: PUSH
68671: LD_INT 1
68673: NEG
68674: PUSH
68675: LD_INT 1
68677: NEG
68678: PUSH
68679: EMPTY
68680: LIST
68681: LIST
68682: PUSH
68683: LD_INT 1
68685: NEG
68686: PUSH
68687: LD_INT 2
68689: NEG
68690: PUSH
68691: EMPTY
68692: LIST
68693: LIST
68694: PUSH
68695: LD_INT 1
68697: PUSH
68698: LD_INT 1
68700: NEG
68701: PUSH
68702: EMPTY
68703: LIST
68704: LIST
68705: PUSH
68706: LD_INT 2
68708: PUSH
68709: LD_INT 0
68711: PUSH
68712: EMPTY
68713: LIST
68714: LIST
68715: PUSH
68716: LD_INT 2
68718: PUSH
68719: LD_INT 1
68721: PUSH
68722: EMPTY
68723: LIST
68724: LIST
68725: PUSH
68726: LD_INT 2
68728: PUSH
68729: LD_INT 2
68731: PUSH
68732: EMPTY
68733: LIST
68734: LIST
68735: PUSH
68736: LD_INT 1
68738: PUSH
68739: LD_INT 2
68741: PUSH
68742: EMPTY
68743: LIST
68744: LIST
68745: PUSH
68746: LD_INT 0
68748: PUSH
68749: LD_INT 2
68751: PUSH
68752: EMPTY
68753: LIST
68754: LIST
68755: PUSH
68756: LD_INT 1
68758: NEG
68759: PUSH
68760: LD_INT 1
68762: PUSH
68763: EMPTY
68764: LIST
68765: LIST
68766: PUSH
68767: LD_INT 2
68769: NEG
68770: PUSH
68771: LD_INT 1
68773: NEG
68774: PUSH
68775: EMPTY
68776: LIST
68777: LIST
68778: PUSH
68779: LD_INT 2
68781: NEG
68782: PUSH
68783: LD_INT 2
68785: NEG
68786: PUSH
68787: EMPTY
68788: LIST
68789: LIST
68790: PUSH
68791: LD_INT 2
68793: NEG
68794: PUSH
68795: LD_INT 3
68797: NEG
68798: PUSH
68799: EMPTY
68800: LIST
68801: LIST
68802: PUSH
68803: LD_INT 2
68805: PUSH
68806: LD_INT 1
68808: NEG
68809: PUSH
68810: EMPTY
68811: LIST
68812: LIST
68813: PUSH
68814: LD_INT 3
68816: PUSH
68817: LD_INT 1
68819: PUSH
68820: EMPTY
68821: LIST
68822: LIST
68823: PUSH
68824: LD_INT 1
68826: PUSH
68827: LD_INT 3
68829: PUSH
68830: EMPTY
68831: LIST
68832: LIST
68833: PUSH
68834: LD_INT 1
68836: NEG
68837: PUSH
68838: LD_INT 2
68840: PUSH
68841: EMPTY
68842: LIST
68843: LIST
68844: PUSH
68845: LD_INT 3
68847: NEG
68848: PUSH
68849: LD_INT 2
68851: NEG
68852: PUSH
68853: EMPTY
68854: LIST
68855: LIST
68856: PUSH
68857: EMPTY
68858: LIST
68859: LIST
68860: LIST
68861: LIST
68862: LIST
68863: LIST
68864: LIST
68865: LIST
68866: LIST
68867: LIST
68868: LIST
68869: LIST
68870: LIST
68871: LIST
68872: LIST
68873: LIST
68874: LIST
68875: LIST
68876: LIST
68877: LIST
68878: LIST
68879: LIST
68880: LIST
68881: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
68882: LD_ADDR_VAR 0 32
68886: PUSH
68887: LD_INT 0
68889: PUSH
68890: LD_INT 0
68892: PUSH
68893: EMPTY
68894: LIST
68895: LIST
68896: PUSH
68897: LD_INT 0
68899: PUSH
68900: LD_INT 1
68902: NEG
68903: PUSH
68904: EMPTY
68905: LIST
68906: LIST
68907: PUSH
68908: LD_INT 1
68910: PUSH
68911: LD_INT 0
68913: PUSH
68914: EMPTY
68915: LIST
68916: LIST
68917: PUSH
68918: LD_INT 1
68920: PUSH
68921: LD_INT 1
68923: PUSH
68924: EMPTY
68925: LIST
68926: LIST
68927: PUSH
68928: LD_INT 0
68930: PUSH
68931: LD_INT 1
68933: PUSH
68934: EMPTY
68935: LIST
68936: LIST
68937: PUSH
68938: LD_INT 1
68940: NEG
68941: PUSH
68942: LD_INT 0
68944: PUSH
68945: EMPTY
68946: LIST
68947: LIST
68948: PUSH
68949: LD_INT 1
68951: NEG
68952: PUSH
68953: LD_INT 1
68955: NEG
68956: PUSH
68957: EMPTY
68958: LIST
68959: LIST
68960: PUSH
68961: LD_INT 1
68963: NEG
68964: PUSH
68965: LD_INT 2
68967: NEG
68968: PUSH
68969: EMPTY
68970: LIST
68971: LIST
68972: PUSH
68973: LD_INT 0
68975: PUSH
68976: LD_INT 2
68978: NEG
68979: PUSH
68980: EMPTY
68981: LIST
68982: LIST
68983: PUSH
68984: LD_INT 1
68986: PUSH
68987: LD_INT 1
68989: NEG
68990: PUSH
68991: EMPTY
68992: LIST
68993: LIST
68994: PUSH
68995: LD_INT 2
68997: PUSH
68998: LD_INT 1
69000: PUSH
69001: EMPTY
69002: LIST
69003: LIST
69004: PUSH
69005: LD_INT 2
69007: PUSH
69008: LD_INT 2
69010: PUSH
69011: EMPTY
69012: LIST
69013: LIST
69014: PUSH
69015: LD_INT 1
69017: PUSH
69018: LD_INT 2
69020: PUSH
69021: EMPTY
69022: LIST
69023: LIST
69024: PUSH
69025: LD_INT 0
69027: PUSH
69028: LD_INT 2
69030: PUSH
69031: EMPTY
69032: LIST
69033: LIST
69034: PUSH
69035: LD_INT 1
69037: NEG
69038: PUSH
69039: LD_INT 1
69041: PUSH
69042: EMPTY
69043: LIST
69044: LIST
69045: PUSH
69046: LD_INT 2
69048: NEG
69049: PUSH
69050: LD_INT 0
69052: PUSH
69053: EMPTY
69054: LIST
69055: LIST
69056: PUSH
69057: LD_INT 2
69059: NEG
69060: PUSH
69061: LD_INT 1
69063: NEG
69064: PUSH
69065: EMPTY
69066: LIST
69067: LIST
69068: PUSH
69069: LD_INT 1
69071: NEG
69072: PUSH
69073: LD_INT 3
69075: NEG
69076: PUSH
69077: EMPTY
69078: LIST
69079: LIST
69080: PUSH
69081: LD_INT 1
69083: PUSH
69084: LD_INT 2
69086: NEG
69087: PUSH
69088: EMPTY
69089: LIST
69090: LIST
69091: PUSH
69092: LD_INT 3
69094: PUSH
69095: LD_INT 2
69097: PUSH
69098: EMPTY
69099: LIST
69100: LIST
69101: PUSH
69102: LD_INT 2
69104: PUSH
69105: LD_INT 3
69107: PUSH
69108: EMPTY
69109: LIST
69110: LIST
69111: PUSH
69112: LD_INT 2
69114: NEG
69115: PUSH
69116: LD_INT 1
69118: PUSH
69119: EMPTY
69120: LIST
69121: LIST
69122: PUSH
69123: LD_INT 3
69125: NEG
69126: PUSH
69127: LD_INT 1
69129: NEG
69130: PUSH
69131: EMPTY
69132: LIST
69133: LIST
69134: PUSH
69135: EMPTY
69136: LIST
69137: LIST
69138: LIST
69139: LIST
69140: LIST
69141: LIST
69142: LIST
69143: LIST
69144: LIST
69145: LIST
69146: LIST
69147: LIST
69148: LIST
69149: LIST
69150: LIST
69151: LIST
69152: LIST
69153: LIST
69154: LIST
69155: LIST
69156: LIST
69157: LIST
69158: LIST
69159: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
69160: LD_ADDR_VAR 0 33
69164: PUSH
69165: LD_INT 0
69167: PUSH
69168: LD_INT 0
69170: PUSH
69171: EMPTY
69172: LIST
69173: LIST
69174: PUSH
69175: LD_INT 0
69177: PUSH
69178: LD_INT 1
69180: NEG
69181: PUSH
69182: EMPTY
69183: LIST
69184: LIST
69185: PUSH
69186: LD_INT 1
69188: PUSH
69189: LD_INT 0
69191: PUSH
69192: EMPTY
69193: LIST
69194: LIST
69195: PUSH
69196: LD_INT 1
69198: PUSH
69199: LD_INT 1
69201: PUSH
69202: EMPTY
69203: LIST
69204: LIST
69205: PUSH
69206: LD_INT 0
69208: PUSH
69209: LD_INT 1
69211: PUSH
69212: EMPTY
69213: LIST
69214: LIST
69215: PUSH
69216: LD_INT 1
69218: NEG
69219: PUSH
69220: LD_INT 0
69222: PUSH
69223: EMPTY
69224: LIST
69225: LIST
69226: PUSH
69227: LD_INT 1
69229: NEG
69230: PUSH
69231: LD_INT 1
69233: NEG
69234: PUSH
69235: EMPTY
69236: LIST
69237: LIST
69238: PUSH
69239: LD_INT 1
69241: NEG
69242: PUSH
69243: LD_INT 2
69245: NEG
69246: PUSH
69247: EMPTY
69248: LIST
69249: LIST
69250: PUSH
69251: LD_INT 1
69253: PUSH
69254: LD_INT 1
69256: NEG
69257: PUSH
69258: EMPTY
69259: LIST
69260: LIST
69261: PUSH
69262: LD_INT 2
69264: PUSH
69265: LD_INT 0
69267: PUSH
69268: EMPTY
69269: LIST
69270: LIST
69271: PUSH
69272: LD_INT 2
69274: PUSH
69275: LD_INT 1
69277: PUSH
69278: EMPTY
69279: LIST
69280: LIST
69281: PUSH
69282: LD_INT 1
69284: PUSH
69285: LD_INT 2
69287: PUSH
69288: EMPTY
69289: LIST
69290: LIST
69291: PUSH
69292: LD_INT 0
69294: PUSH
69295: LD_INT 2
69297: PUSH
69298: EMPTY
69299: LIST
69300: LIST
69301: PUSH
69302: LD_INT 1
69304: NEG
69305: PUSH
69306: LD_INT 1
69308: PUSH
69309: EMPTY
69310: LIST
69311: LIST
69312: PUSH
69313: LD_INT 2
69315: NEG
69316: PUSH
69317: LD_INT 0
69319: PUSH
69320: EMPTY
69321: LIST
69322: LIST
69323: PUSH
69324: LD_INT 2
69326: NEG
69327: PUSH
69328: LD_INT 1
69330: NEG
69331: PUSH
69332: EMPTY
69333: LIST
69334: LIST
69335: PUSH
69336: LD_INT 2
69338: NEG
69339: PUSH
69340: LD_INT 2
69342: NEG
69343: PUSH
69344: EMPTY
69345: LIST
69346: LIST
69347: PUSH
69348: LD_INT 2
69350: NEG
69351: PUSH
69352: LD_INT 3
69354: NEG
69355: PUSH
69356: EMPTY
69357: LIST
69358: LIST
69359: PUSH
69360: LD_INT 2
69362: PUSH
69363: LD_INT 1
69365: NEG
69366: PUSH
69367: EMPTY
69368: LIST
69369: LIST
69370: PUSH
69371: LD_INT 3
69373: PUSH
69374: LD_INT 1
69376: PUSH
69377: EMPTY
69378: LIST
69379: LIST
69380: PUSH
69381: LD_INT 1
69383: PUSH
69384: LD_INT 3
69386: PUSH
69387: EMPTY
69388: LIST
69389: LIST
69390: PUSH
69391: LD_INT 1
69393: NEG
69394: PUSH
69395: LD_INT 2
69397: PUSH
69398: EMPTY
69399: LIST
69400: LIST
69401: PUSH
69402: LD_INT 3
69404: NEG
69405: PUSH
69406: LD_INT 2
69408: NEG
69409: PUSH
69410: EMPTY
69411: LIST
69412: LIST
69413: PUSH
69414: EMPTY
69415: LIST
69416: LIST
69417: LIST
69418: LIST
69419: LIST
69420: LIST
69421: LIST
69422: LIST
69423: LIST
69424: LIST
69425: LIST
69426: LIST
69427: LIST
69428: LIST
69429: LIST
69430: LIST
69431: LIST
69432: LIST
69433: LIST
69434: LIST
69435: LIST
69436: LIST
69437: LIST
69438: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
69439: LD_ADDR_VAR 0 34
69443: PUSH
69444: LD_INT 0
69446: PUSH
69447: LD_INT 0
69449: PUSH
69450: EMPTY
69451: LIST
69452: LIST
69453: PUSH
69454: LD_INT 0
69456: PUSH
69457: LD_INT 1
69459: NEG
69460: PUSH
69461: EMPTY
69462: LIST
69463: LIST
69464: PUSH
69465: LD_INT 1
69467: PUSH
69468: LD_INT 0
69470: PUSH
69471: EMPTY
69472: LIST
69473: LIST
69474: PUSH
69475: LD_INT 1
69477: PUSH
69478: LD_INT 1
69480: PUSH
69481: EMPTY
69482: LIST
69483: LIST
69484: PUSH
69485: LD_INT 0
69487: PUSH
69488: LD_INT 1
69490: PUSH
69491: EMPTY
69492: LIST
69493: LIST
69494: PUSH
69495: LD_INT 1
69497: NEG
69498: PUSH
69499: LD_INT 0
69501: PUSH
69502: EMPTY
69503: LIST
69504: LIST
69505: PUSH
69506: LD_INT 1
69508: NEG
69509: PUSH
69510: LD_INT 1
69512: NEG
69513: PUSH
69514: EMPTY
69515: LIST
69516: LIST
69517: PUSH
69518: LD_INT 1
69520: NEG
69521: PUSH
69522: LD_INT 2
69524: NEG
69525: PUSH
69526: EMPTY
69527: LIST
69528: LIST
69529: PUSH
69530: LD_INT 0
69532: PUSH
69533: LD_INT 2
69535: NEG
69536: PUSH
69537: EMPTY
69538: LIST
69539: LIST
69540: PUSH
69541: LD_INT 1
69543: PUSH
69544: LD_INT 1
69546: NEG
69547: PUSH
69548: EMPTY
69549: LIST
69550: LIST
69551: PUSH
69552: LD_INT 2
69554: PUSH
69555: LD_INT 1
69557: PUSH
69558: EMPTY
69559: LIST
69560: LIST
69561: PUSH
69562: LD_INT 2
69564: PUSH
69565: LD_INT 2
69567: PUSH
69568: EMPTY
69569: LIST
69570: LIST
69571: PUSH
69572: LD_INT 1
69574: PUSH
69575: LD_INT 2
69577: PUSH
69578: EMPTY
69579: LIST
69580: LIST
69581: PUSH
69582: LD_INT 1
69584: NEG
69585: PUSH
69586: LD_INT 1
69588: PUSH
69589: EMPTY
69590: LIST
69591: LIST
69592: PUSH
69593: LD_INT 2
69595: NEG
69596: PUSH
69597: LD_INT 0
69599: PUSH
69600: EMPTY
69601: LIST
69602: LIST
69603: PUSH
69604: LD_INT 2
69606: NEG
69607: PUSH
69608: LD_INT 1
69610: NEG
69611: PUSH
69612: EMPTY
69613: LIST
69614: LIST
69615: PUSH
69616: LD_INT 2
69618: NEG
69619: PUSH
69620: LD_INT 2
69622: NEG
69623: PUSH
69624: EMPTY
69625: LIST
69626: LIST
69627: PUSH
69628: LD_INT 1
69630: NEG
69631: PUSH
69632: LD_INT 3
69634: NEG
69635: PUSH
69636: EMPTY
69637: LIST
69638: LIST
69639: PUSH
69640: LD_INT 1
69642: PUSH
69643: LD_INT 2
69645: NEG
69646: PUSH
69647: EMPTY
69648: LIST
69649: LIST
69650: PUSH
69651: LD_INT 3
69653: PUSH
69654: LD_INT 2
69656: PUSH
69657: EMPTY
69658: LIST
69659: LIST
69660: PUSH
69661: LD_INT 2
69663: PUSH
69664: LD_INT 3
69666: PUSH
69667: EMPTY
69668: LIST
69669: LIST
69670: PUSH
69671: LD_INT 2
69673: NEG
69674: PUSH
69675: LD_INT 1
69677: PUSH
69678: EMPTY
69679: LIST
69680: LIST
69681: PUSH
69682: LD_INT 3
69684: NEG
69685: PUSH
69686: LD_INT 1
69688: NEG
69689: PUSH
69690: EMPTY
69691: LIST
69692: LIST
69693: PUSH
69694: EMPTY
69695: LIST
69696: LIST
69697: LIST
69698: LIST
69699: LIST
69700: LIST
69701: LIST
69702: LIST
69703: LIST
69704: LIST
69705: LIST
69706: LIST
69707: LIST
69708: LIST
69709: LIST
69710: LIST
69711: LIST
69712: LIST
69713: LIST
69714: LIST
69715: LIST
69716: LIST
69717: LIST
69718: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
69719: LD_ADDR_VAR 0 35
69723: PUSH
69724: LD_INT 0
69726: PUSH
69727: LD_INT 0
69729: PUSH
69730: EMPTY
69731: LIST
69732: LIST
69733: PUSH
69734: LD_INT 0
69736: PUSH
69737: LD_INT 1
69739: NEG
69740: PUSH
69741: EMPTY
69742: LIST
69743: LIST
69744: PUSH
69745: LD_INT 1
69747: PUSH
69748: LD_INT 0
69750: PUSH
69751: EMPTY
69752: LIST
69753: LIST
69754: PUSH
69755: LD_INT 1
69757: PUSH
69758: LD_INT 1
69760: PUSH
69761: EMPTY
69762: LIST
69763: LIST
69764: PUSH
69765: LD_INT 0
69767: PUSH
69768: LD_INT 1
69770: PUSH
69771: EMPTY
69772: LIST
69773: LIST
69774: PUSH
69775: LD_INT 1
69777: NEG
69778: PUSH
69779: LD_INT 0
69781: PUSH
69782: EMPTY
69783: LIST
69784: LIST
69785: PUSH
69786: LD_INT 1
69788: NEG
69789: PUSH
69790: LD_INT 1
69792: NEG
69793: PUSH
69794: EMPTY
69795: LIST
69796: LIST
69797: PUSH
69798: LD_INT 2
69800: PUSH
69801: LD_INT 1
69803: PUSH
69804: EMPTY
69805: LIST
69806: LIST
69807: PUSH
69808: LD_INT 2
69810: NEG
69811: PUSH
69812: LD_INT 1
69814: NEG
69815: PUSH
69816: EMPTY
69817: LIST
69818: LIST
69819: PUSH
69820: EMPTY
69821: LIST
69822: LIST
69823: LIST
69824: LIST
69825: LIST
69826: LIST
69827: LIST
69828: LIST
69829: LIST
69830: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
69831: LD_ADDR_VAR 0 36
69835: PUSH
69836: LD_INT 0
69838: PUSH
69839: LD_INT 0
69841: PUSH
69842: EMPTY
69843: LIST
69844: LIST
69845: PUSH
69846: LD_INT 0
69848: PUSH
69849: LD_INT 1
69851: NEG
69852: PUSH
69853: EMPTY
69854: LIST
69855: LIST
69856: PUSH
69857: LD_INT 1
69859: PUSH
69860: LD_INT 0
69862: PUSH
69863: EMPTY
69864: LIST
69865: LIST
69866: PUSH
69867: LD_INT 1
69869: PUSH
69870: LD_INT 1
69872: PUSH
69873: EMPTY
69874: LIST
69875: LIST
69876: PUSH
69877: LD_INT 0
69879: PUSH
69880: LD_INT 1
69882: PUSH
69883: EMPTY
69884: LIST
69885: LIST
69886: PUSH
69887: LD_INT 1
69889: NEG
69890: PUSH
69891: LD_INT 0
69893: PUSH
69894: EMPTY
69895: LIST
69896: LIST
69897: PUSH
69898: LD_INT 1
69900: NEG
69901: PUSH
69902: LD_INT 1
69904: NEG
69905: PUSH
69906: EMPTY
69907: LIST
69908: LIST
69909: PUSH
69910: LD_INT 1
69912: NEG
69913: PUSH
69914: LD_INT 2
69916: NEG
69917: PUSH
69918: EMPTY
69919: LIST
69920: LIST
69921: PUSH
69922: LD_INT 1
69924: PUSH
69925: LD_INT 2
69927: PUSH
69928: EMPTY
69929: LIST
69930: LIST
69931: PUSH
69932: EMPTY
69933: LIST
69934: LIST
69935: LIST
69936: LIST
69937: LIST
69938: LIST
69939: LIST
69940: LIST
69941: LIST
69942: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
69943: LD_ADDR_VAR 0 37
69947: PUSH
69948: LD_INT 0
69950: PUSH
69951: LD_INT 0
69953: PUSH
69954: EMPTY
69955: LIST
69956: LIST
69957: PUSH
69958: LD_INT 0
69960: PUSH
69961: LD_INT 1
69963: NEG
69964: PUSH
69965: EMPTY
69966: LIST
69967: LIST
69968: PUSH
69969: LD_INT 1
69971: PUSH
69972: LD_INT 0
69974: PUSH
69975: EMPTY
69976: LIST
69977: LIST
69978: PUSH
69979: LD_INT 1
69981: PUSH
69982: LD_INT 1
69984: PUSH
69985: EMPTY
69986: LIST
69987: LIST
69988: PUSH
69989: LD_INT 0
69991: PUSH
69992: LD_INT 1
69994: PUSH
69995: EMPTY
69996: LIST
69997: LIST
69998: PUSH
69999: LD_INT 1
70001: NEG
70002: PUSH
70003: LD_INT 0
70005: PUSH
70006: EMPTY
70007: LIST
70008: LIST
70009: PUSH
70010: LD_INT 1
70012: NEG
70013: PUSH
70014: LD_INT 1
70016: NEG
70017: PUSH
70018: EMPTY
70019: LIST
70020: LIST
70021: PUSH
70022: LD_INT 1
70024: PUSH
70025: LD_INT 1
70027: NEG
70028: PUSH
70029: EMPTY
70030: LIST
70031: LIST
70032: PUSH
70033: LD_INT 1
70035: NEG
70036: PUSH
70037: LD_INT 1
70039: PUSH
70040: EMPTY
70041: LIST
70042: LIST
70043: PUSH
70044: EMPTY
70045: LIST
70046: LIST
70047: LIST
70048: LIST
70049: LIST
70050: LIST
70051: LIST
70052: LIST
70053: LIST
70054: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
70055: LD_ADDR_VAR 0 38
70059: PUSH
70060: LD_INT 0
70062: PUSH
70063: LD_INT 0
70065: PUSH
70066: EMPTY
70067: LIST
70068: LIST
70069: PUSH
70070: LD_INT 0
70072: PUSH
70073: LD_INT 1
70075: NEG
70076: PUSH
70077: EMPTY
70078: LIST
70079: LIST
70080: PUSH
70081: LD_INT 1
70083: PUSH
70084: LD_INT 0
70086: PUSH
70087: EMPTY
70088: LIST
70089: LIST
70090: PUSH
70091: LD_INT 1
70093: PUSH
70094: LD_INT 1
70096: PUSH
70097: EMPTY
70098: LIST
70099: LIST
70100: PUSH
70101: LD_INT 0
70103: PUSH
70104: LD_INT 1
70106: PUSH
70107: EMPTY
70108: LIST
70109: LIST
70110: PUSH
70111: LD_INT 1
70113: NEG
70114: PUSH
70115: LD_INT 0
70117: PUSH
70118: EMPTY
70119: LIST
70120: LIST
70121: PUSH
70122: LD_INT 1
70124: NEG
70125: PUSH
70126: LD_INT 1
70128: NEG
70129: PUSH
70130: EMPTY
70131: LIST
70132: LIST
70133: PUSH
70134: LD_INT 2
70136: PUSH
70137: LD_INT 1
70139: PUSH
70140: EMPTY
70141: LIST
70142: LIST
70143: PUSH
70144: LD_INT 2
70146: NEG
70147: PUSH
70148: LD_INT 1
70150: NEG
70151: PUSH
70152: EMPTY
70153: LIST
70154: LIST
70155: PUSH
70156: EMPTY
70157: LIST
70158: LIST
70159: LIST
70160: LIST
70161: LIST
70162: LIST
70163: LIST
70164: LIST
70165: LIST
70166: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
70167: LD_ADDR_VAR 0 39
70171: PUSH
70172: LD_INT 0
70174: PUSH
70175: LD_INT 0
70177: PUSH
70178: EMPTY
70179: LIST
70180: LIST
70181: PUSH
70182: LD_INT 0
70184: PUSH
70185: LD_INT 1
70187: NEG
70188: PUSH
70189: EMPTY
70190: LIST
70191: LIST
70192: PUSH
70193: LD_INT 1
70195: PUSH
70196: LD_INT 0
70198: PUSH
70199: EMPTY
70200: LIST
70201: LIST
70202: PUSH
70203: LD_INT 1
70205: PUSH
70206: LD_INT 1
70208: PUSH
70209: EMPTY
70210: LIST
70211: LIST
70212: PUSH
70213: LD_INT 0
70215: PUSH
70216: LD_INT 1
70218: PUSH
70219: EMPTY
70220: LIST
70221: LIST
70222: PUSH
70223: LD_INT 1
70225: NEG
70226: PUSH
70227: LD_INT 0
70229: PUSH
70230: EMPTY
70231: LIST
70232: LIST
70233: PUSH
70234: LD_INT 1
70236: NEG
70237: PUSH
70238: LD_INT 1
70240: NEG
70241: PUSH
70242: EMPTY
70243: LIST
70244: LIST
70245: PUSH
70246: LD_INT 1
70248: NEG
70249: PUSH
70250: LD_INT 2
70252: NEG
70253: PUSH
70254: EMPTY
70255: LIST
70256: LIST
70257: PUSH
70258: LD_INT 1
70260: PUSH
70261: LD_INT 2
70263: PUSH
70264: EMPTY
70265: LIST
70266: LIST
70267: PUSH
70268: EMPTY
70269: LIST
70270: LIST
70271: LIST
70272: LIST
70273: LIST
70274: LIST
70275: LIST
70276: LIST
70277: LIST
70278: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
70279: LD_ADDR_VAR 0 40
70283: PUSH
70284: LD_INT 0
70286: PUSH
70287: LD_INT 0
70289: PUSH
70290: EMPTY
70291: LIST
70292: LIST
70293: PUSH
70294: LD_INT 0
70296: PUSH
70297: LD_INT 1
70299: NEG
70300: PUSH
70301: EMPTY
70302: LIST
70303: LIST
70304: PUSH
70305: LD_INT 1
70307: PUSH
70308: LD_INT 0
70310: PUSH
70311: EMPTY
70312: LIST
70313: LIST
70314: PUSH
70315: LD_INT 1
70317: PUSH
70318: LD_INT 1
70320: PUSH
70321: EMPTY
70322: LIST
70323: LIST
70324: PUSH
70325: LD_INT 0
70327: PUSH
70328: LD_INT 1
70330: PUSH
70331: EMPTY
70332: LIST
70333: LIST
70334: PUSH
70335: LD_INT 1
70337: NEG
70338: PUSH
70339: LD_INT 0
70341: PUSH
70342: EMPTY
70343: LIST
70344: LIST
70345: PUSH
70346: LD_INT 1
70348: NEG
70349: PUSH
70350: LD_INT 1
70352: NEG
70353: PUSH
70354: EMPTY
70355: LIST
70356: LIST
70357: PUSH
70358: LD_INT 1
70360: PUSH
70361: LD_INT 1
70363: NEG
70364: PUSH
70365: EMPTY
70366: LIST
70367: LIST
70368: PUSH
70369: LD_INT 1
70371: NEG
70372: PUSH
70373: LD_INT 1
70375: PUSH
70376: EMPTY
70377: LIST
70378: LIST
70379: PUSH
70380: EMPTY
70381: LIST
70382: LIST
70383: LIST
70384: LIST
70385: LIST
70386: LIST
70387: LIST
70388: LIST
70389: LIST
70390: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70391: LD_ADDR_VAR 0 41
70395: PUSH
70396: LD_INT 0
70398: PUSH
70399: LD_INT 0
70401: PUSH
70402: EMPTY
70403: LIST
70404: LIST
70405: PUSH
70406: LD_INT 0
70408: PUSH
70409: LD_INT 1
70411: NEG
70412: PUSH
70413: EMPTY
70414: LIST
70415: LIST
70416: PUSH
70417: LD_INT 1
70419: PUSH
70420: LD_INT 0
70422: PUSH
70423: EMPTY
70424: LIST
70425: LIST
70426: PUSH
70427: LD_INT 1
70429: PUSH
70430: LD_INT 1
70432: PUSH
70433: EMPTY
70434: LIST
70435: LIST
70436: PUSH
70437: LD_INT 0
70439: PUSH
70440: LD_INT 1
70442: PUSH
70443: EMPTY
70444: LIST
70445: LIST
70446: PUSH
70447: LD_INT 1
70449: NEG
70450: PUSH
70451: LD_INT 0
70453: PUSH
70454: EMPTY
70455: LIST
70456: LIST
70457: PUSH
70458: LD_INT 1
70460: NEG
70461: PUSH
70462: LD_INT 1
70464: NEG
70465: PUSH
70466: EMPTY
70467: LIST
70468: LIST
70469: PUSH
70470: LD_INT 1
70472: NEG
70473: PUSH
70474: LD_INT 2
70476: NEG
70477: PUSH
70478: EMPTY
70479: LIST
70480: LIST
70481: PUSH
70482: LD_INT 1
70484: PUSH
70485: LD_INT 1
70487: NEG
70488: PUSH
70489: EMPTY
70490: LIST
70491: LIST
70492: PUSH
70493: LD_INT 2
70495: PUSH
70496: LD_INT 0
70498: PUSH
70499: EMPTY
70500: LIST
70501: LIST
70502: PUSH
70503: LD_INT 2
70505: PUSH
70506: LD_INT 1
70508: PUSH
70509: EMPTY
70510: LIST
70511: LIST
70512: PUSH
70513: LD_INT 2
70515: PUSH
70516: LD_INT 2
70518: PUSH
70519: EMPTY
70520: LIST
70521: LIST
70522: PUSH
70523: LD_INT 1
70525: PUSH
70526: LD_INT 2
70528: PUSH
70529: EMPTY
70530: LIST
70531: LIST
70532: PUSH
70533: LD_INT 1
70535: NEG
70536: PUSH
70537: LD_INT 1
70539: PUSH
70540: EMPTY
70541: LIST
70542: LIST
70543: PUSH
70544: LD_INT 2
70546: NEG
70547: PUSH
70548: LD_INT 0
70550: PUSH
70551: EMPTY
70552: LIST
70553: LIST
70554: PUSH
70555: LD_INT 2
70557: NEG
70558: PUSH
70559: LD_INT 1
70561: NEG
70562: PUSH
70563: EMPTY
70564: LIST
70565: LIST
70566: PUSH
70567: LD_INT 2
70569: NEG
70570: PUSH
70571: LD_INT 2
70573: NEG
70574: PUSH
70575: EMPTY
70576: LIST
70577: LIST
70578: PUSH
70579: LD_INT 2
70581: NEG
70582: PUSH
70583: LD_INT 3
70585: NEG
70586: PUSH
70587: EMPTY
70588: LIST
70589: LIST
70590: PUSH
70591: LD_INT 2
70593: PUSH
70594: LD_INT 1
70596: NEG
70597: PUSH
70598: EMPTY
70599: LIST
70600: LIST
70601: PUSH
70602: LD_INT 3
70604: PUSH
70605: LD_INT 0
70607: PUSH
70608: EMPTY
70609: LIST
70610: LIST
70611: PUSH
70612: LD_INT 3
70614: PUSH
70615: LD_INT 1
70617: PUSH
70618: EMPTY
70619: LIST
70620: LIST
70621: PUSH
70622: LD_INT 3
70624: PUSH
70625: LD_INT 2
70627: PUSH
70628: EMPTY
70629: LIST
70630: LIST
70631: PUSH
70632: LD_INT 3
70634: PUSH
70635: LD_INT 3
70637: PUSH
70638: EMPTY
70639: LIST
70640: LIST
70641: PUSH
70642: LD_INT 2
70644: PUSH
70645: LD_INT 3
70647: PUSH
70648: EMPTY
70649: LIST
70650: LIST
70651: PUSH
70652: LD_INT 2
70654: NEG
70655: PUSH
70656: LD_INT 1
70658: PUSH
70659: EMPTY
70660: LIST
70661: LIST
70662: PUSH
70663: LD_INT 3
70665: NEG
70666: PUSH
70667: LD_INT 0
70669: PUSH
70670: EMPTY
70671: LIST
70672: LIST
70673: PUSH
70674: LD_INT 3
70676: NEG
70677: PUSH
70678: LD_INT 1
70680: NEG
70681: PUSH
70682: EMPTY
70683: LIST
70684: LIST
70685: PUSH
70686: LD_INT 3
70688: NEG
70689: PUSH
70690: LD_INT 2
70692: NEG
70693: PUSH
70694: EMPTY
70695: LIST
70696: LIST
70697: PUSH
70698: LD_INT 3
70700: NEG
70701: PUSH
70702: LD_INT 3
70704: NEG
70705: PUSH
70706: EMPTY
70707: LIST
70708: LIST
70709: PUSH
70710: EMPTY
70711: LIST
70712: LIST
70713: LIST
70714: LIST
70715: LIST
70716: LIST
70717: LIST
70718: LIST
70719: LIST
70720: LIST
70721: LIST
70722: LIST
70723: LIST
70724: LIST
70725: LIST
70726: LIST
70727: LIST
70728: LIST
70729: LIST
70730: LIST
70731: LIST
70732: LIST
70733: LIST
70734: LIST
70735: LIST
70736: LIST
70737: LIST
70738: LIST
70739: LIST
70740: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70741: LD_ADDR_VAR 0 42
70745: PUSH
70746: LD_INT 0
70748: PUSH
70749: LD_INT 0
70751: PUSH
70752: EMPTY
70753: LIST
70754: LIST
70755: PUSH
70756: LD_INT 0
70758: PUSH
70759: LD_INT 1
70761: NEG
70762: PUSH
70763: EMPTY
70764: LIST
70765: LIST
70766: PUSH
70767: LD_INT 1
70769: PUSH
70770: LD_INT 0
70772: PUSH
70773: EMPTY
70774: LIST
70775: LIST
70776: PUSH
70777: LD_INT 1
70779: PUSH
70780: LD_INT 1
70782: PUSH
70783: EMPTY
70784: LIST
70785: LIST
70786: PUSH
70787: LD_INT 0
70789: PUSH
70790: LD_INT 1
70792: PUSH
70793: EMPTY
70794: LIST
70795: LIST
70796: PUSH
70797: LD_INT 1
70799: NEG
70800: PUSH
70801: LD_INT 0
70803: PUSH
70804: EMPTY
70805: LIST
70806: LIST
70807: PUSH
70808: LD_INT 1
70810: NEG
70811: PUSH
70812: LD_INT 1
70814: NEG
70815: PUSH
70816: EMPTY
70817: LIST
70818: LIST
70819: PUSH
70820: LD_INT 1
70822: NEG
70823: PUSH
70824: LD_INT 2
70826: NEG
70827: PUSH
70828: EMPTY
70829: LIST
70830: LIST
70831: PUSH
70832: LD_INT 0
70834: PUSH
70835: LD_INT 2
70837: NEG
70838: PUSH
70839: EMPTY
70840: LIST
70841: LIST
70842: PUSH
70843: LD_INT 1
70845: PUSH
70846: LD_INT 1
70848: NEG
70849: PUSH
70850: EMPTY
70851: LIST
70852: LIST
70853: PUSH
70854: LD_INT 2
70856: PUSH
70857: LD_INT 1
70859: PUSH
70860: EMPTY
70861: LIST
70862: LIST
70863: PUSH
70864: LD_INT 2
70866: PUSH
70867: LD_INT 2
70869: PUSH
70870: EMPTY
70871: LIST
70872: LIST
70873: PUSH
70874: LD_INT 1
70876: PUSH
70877: LD_INT 2
70879: PUSH
70880: EMPTY
70881: LIST
70882: LIST
70883: PUSH
70884: LD_INT 0
70886: PUSH
70887: LD_INT 2
70889: PUSH
70890: EMPTY
70891: LIST
70892: LIST
70893: PUSH
70894: LD_INT 1
70896: NEG
70897: PUSH
70898: LD_INT 1
70900: PUSH
70901: EMPTY
70902: LIST
70903: LIST
70904: PUSH
70905: LD_INT 2
70907: NEG
70908: PUSH
70909: LD_INT 1
70911: NEG
70912: PUSH
70913: EMPTY
70914: LIST
70915: LIST
70916: PUSH
70917: LD_INT 2
70919: NEG
70920: PUSH
70921: LD_INT 2
70923: NEG
70924: PUSH
70925: EMPTY
70926: LIST
70927: LIST
70928: PUSH
70929: LD_INT 2
70931: NEG
70932: PUSH
70933: LD_INT 3
70935: NEG
70936: PUSH
70937: EMPTY
70938: LIST
70939: LIST
70940: PUSH
70941: LD_INT 1
70943: NEG
70944: PUSH
70945: LD_INT 3
70947: NEG
70948: PUSH
70949: EMPTY
70950: LIST
70951: LIST
70952: PUSH
70953: LD_INT 0
70955: PUSH
70956: LD_INT 3
70958: NEG
70959: PUSH
70960: EMPTY
70961: LIST
70962: LIST
70963: PUSH
70964: LD_INT 1
70966: PUSH
70967: LD_INT 2
70969: NEG
70970: PUSH
70971: EMPTY
70972: LIST
70973: LIST
70974: PUSH
70975: LD_INT 3
70977: PUSH
70978: LD_INT 2
70980: PUSH
70981: EMPTY
70982: LIST
70983: LIST
70984: PUSH
70985: LD_INT 3
70987: PUSH
70988: LD_INT 3
70990: PUSH
70991: EMPTY
70992: LIST
70993: LIST
70994: PUSH
70995: LD_INT 2
70997: PUSH
70998: LD_INT 3
71000: PUSH
71001: EMPTY
71002: LIST
71003: LIST
71004: PUSH
71005: LD_INT 1
71007: PUSH
71008: LD_INT 3
71010: PUSH
71011: EMPTY
71012: LIST
71013: LIST
71014: PUSH
71015: LD_INT 0
71017: PUSH
71018: LD_INT 3
71020: PUSH
71021: EMPTY
71022: LIST
71023: LIST
71024: PUSH
71025: LD_INT 1
71027: NEG
71028: PUSH
71029: LD_INT 2
71031: PUSH
71032: EMPTY
71033: LIST
71034: LIST
71035: PUSH
71036: LD_INT 3
71038: NEG
71039: PUSH
71040: LD_INT 2
71042: NEG
71043: PUSH
71044: EMPTY
71045: LIST
71046: LIST
71047: PUSH
71048: LD_INT 3
71050: NEG
71051: PUSH
71052: LD_INT 3
71054: NEG
71055: PUSH
71056: EMPTY
71057: LIST
71058: LIST
71059: PUSH
71060: EMPTY
71061: LIST
71062: LIST
71063: LIST
71064: LIST
71065: LIST
71066: LIST
71067: LIST
71068: LIST
71069: LIST
71070: LIST
71071: LIST
71072: LIST
71073: LIST
71074: LIST
71075: LIST
71076: LIST
71077: LIST
71078: LIST
71079: LIST
71080: LIST
71081: LIST
71082: LIST
71083: LIST
71084: LIST
71085: LIST
71086: LIST
71087: LIST
71088: LIST
71089: LIST
71090: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
71091: LD_ADDR_VAR 0 43
71095: PUSH
71096: LD_INT 0
71098: PUSH
71099: LD_INT 0
71101: PUSH
71102: EMPTY
71103: LIST
71104: LIST
71105: PUSH
71106: LD_INT 0
71108: PUSH
71109: LD_INT 1
71111: NEG
71112: PUSH
71113: EMPTY
71114: LIST
71115: LIST
71116: PUSH
71117: LD_INT 1
71119: PUSH
71120: LD_INT 0
71122: PUSH
71123: EMPTY
71124: LIST
71125: LIST
71126: PUSH
71127: LD_INT 1
71129: PUSH
71130: LD_INT 1
71132: PUSH
71133: EMPTY
71134: LIST
71135: LIST
71136: PUSH
71137: LD_INT 0
71139: PUSH
71140: LD_INT 1
71142: PUSH
71143: EMPTY
71144: LIST
71145: LIST
71146: PUSH
71147: LD_INT 1
71149: NEG
71150: PUSH
71151: LD_INT 0
71153: PUSH
71154: EMPTY
71155: LIST
71156: LIST
71157: PUSH
71158: LD_INT 1
71160: NEG
71161: PUSH
71162: LD_INT 1
71164: NEG
71165: PUSH
71166: EMPTY
71167: LIST
71168: LIST
71169: PUSH
71170: LD_INT 1
71172: NEG
71173: PUSH
71174: LD_INT 2
71176: NEG
71177: PUSH
71178: EMPTY
71179: LIST
71180: LIST
71181: PUSH
71182: LD_INT 0
71184: PUSH
71185: LD_INT 2
71187: NEG
71188: PUSH
71189: EMPTY
71190: LIST
71191: LIST
71192: PUSH
71193: LD_INT 1
71195: PUSH
71196: LD_INT 1
71198: NEG
71199: PUSH
71200: EMPTY
71201: LIST
71202: LIST
71203: PUSH
71204: LD_INT 2
71206: PUSH
71207: LD_INT 0
71209: PUSH
71210: EMPTY
71211: LIST
71212: LIST
71213: PUSH
71214: LD_INT 2
71216: PUSH
71217: LD_INT 1
71219: PUSH
71220: EMPTY
71221: LIST
71222: LIST
71223: PUSH
71224: LD_INT 1
71226: PUSH
71227: LD_INT 2
71229: PUSH
71230: EMPTY
71231: LIST
71232: LIST
71233: PUSH
71234: LD_INT 0
71236: PUSH
71237: LD_INT 2
71239: PUSH
71240: EMPTY
71241: LIST
71242: LIST
71243: PUSH
71244: LD_INT 1
71246: NEG
71247: PUSH
71248: LD_INT 1
71250: PUSH
71251: EMPTY
71252: LIST
71253: LIST
71254: PUSH
71255: LD_INT 2
71257: NEG
71258: PUSH
71259: LD_INT 0
71261: PUSH
71262: EMPTY
71263: LIST
71264: LIST
71265: PUSH
71266: LD_INT 2
71268: NEG
71269: PUSH
71270: LD_INT 1
71272: NEG
71273: PUSH
71274: EMPTY
71275: LIST
71276: LIST
71277: PUSH
71278: LD_INT 1
71280: NEG
71281: PUSH
71282: LD_INT 3
71284: NEG
71285: PUSH
71286: EMPTY
71287: LIST
71288: LIST
71289: PUSH
71290: LD_INT 0
71292: PUSH
71293: LD_INT 3
71295: NEG
71296: PUSH
71297: EMPTY
71298: LIST
71299: LIST
71300: PUSH
71301: LD_INT 1
71303: PUSH
71304: LD_INT 2
71306: NEG
71307: PUSH
71308: EMPTY
71309: LIST
71310: LIST
71311: PUSH
71312: LD_INT 2
71314: PUSH
71315: LD_INT 1
71317: NEG
71318: PUSH
71319: EMPTY
71320: LIST
71321: LIST
71322: PUSH
71323: LD_INT 3
71325: PUSH
71326: LD_INT 0
71328: PUSH
71329: EMPTY
71330: LIST
71331: LIST
71332: PUSH
71333: LD_INT 3
71335: PUSH
71336: LD_INT 1
71338: PUSH
71339: EMPTY
71340: LIST
71341: LIST
71342: PUSH
71343: LD_INT 1
71345: PUSH
71346: LD_INT 3
71348: PUSH
71349: EMPTY
71350: LIST
71351: LIST
71352: PUSH
71353: LD_INT 0
71355: PUSH
71356: LD_INT 3
71358: PUSH
71359: EMPTY
71360: LIST
71361: LIST
71362: PUSH
71363: LD_INT 1
71365: NEG
71366: PUSH
71367: LD_INT 2
71369: PUSH
71370: EMPTY
71371: LIST
71372: LIST
71373: PUSH
71374: LD_INT 2
71376: NEG
71377: PUSH
71378: LD_INT 1
71380: PUSH
71381: EMPTY
71382: LIST
71383: LIST
71384: PUSH
71385: LD_INT 3
71387: NEG
71388: PUSH
71389: LD_INT 0
71391: PUSH
71392: EMPTY
71393: LIST
71394: LIST
71395: PUSH
71396: LD_INT 3
71398: NEG
71399: PUSH
71400: LD_INT 1
71402: NEG
71403: PUSH
71404: EMPTY
71405: LIST
71406: LIST
71407: PUSH
71408: EMPTY
71409: LIST
71410: LIST
71411: LIST
71412: LIST
71413: LIST
71414: LIST
71415: LIST
71416: LIST
71417: LIST
71418: LIST
71419: LIST
71420: LIST
71421: LIST
71422: LIST
71423: LIST
71424: LIST
71425: LIST
71426: LIST
71427: LIST
71428: LIST
71429: LIST
71430: LIST
71431: LIST
71432: LIST
71433: LIST
71434: LIST
71435: LIST
71436: LIST
71437: LIST
71438: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
71439: LD_ADDR_VAR 0 44
71443: PUSH
71444: LD_INT 0
71446: PUSH
71447: LD_INT 0
71449: PUSH
71450: EMPTY
71451: LIST
71452: LIST
71453: PUSH
71454: LD_INT 0
71456: PUSH
71457: LD_INT 1
71459: NEG
71460: PUSH
71461: EMPTY
71462: LIST
71463: LIST
71464: PUSH
71465: LD_INT 1
71467: PUSH
71468: LD_INT 0
71470: PUSH
71471: EMPTY
71472: LIST
71473: LIST
71474: PUSH
71475: LD_INT 1
71477: PUSH
71478: LD_INT 1
71480: PUSH
71481: EMPTY
71482: LIST
71483: LIST
71484: PUSH
71485: LD_INT 0
71487: PUSH
71488: LD_INT 1
71490: PUSH
71491: EMPTY
71492: LIST
71493: LIST
71494: PUSH
71495: LD_INT 1
71497: NEG
71498: PUSH
71499: LD_INT 0
71501: PUSH
71502: EMPTY
71503: LIST
71504: LIST
71505: PUSH
71506: LD_INT 1
71508: NEG
71509: PUSH
71510: LD_INT 1
71512: NEG
71513: PUSH
71514: EMPTY
71515: LIST
71516: LIST
71517: PUSH
71518: LD_INT 1
71520: NEG
71521: PUSH
71522: LD_INT 2
71524: NEG
71525: PUSH
71526: EMPTY
71527: LIST
71528: LIST
71529: PUSH
71530: LD_INT 1
71532: PUSH
71533: LD_INT 1
71535: NEG
71536: PUSH
71537: EMPTY
71538: LIST
71539: LIST
71540: PUSH
71541: LD_INT 2
71543: PUSH
71544: LD_INT 0
71546: PUSH
71547: EMPTY
71548: LIST
71549: LIST
71550: PUSH
71551: LD_INT 2
71553: PUSH
71554: LD_INT 1
71556: PUSH
71557: EMPTY
71558: LIST
71559: LIST
71560: PUSH
71561: LD_INT 2
71563: PUSH
71564: LD_INT 2
71566: PUSH
71567: EMPTY
71568: LIST
71569: LIST
71570: PUSH
71571: LD_INT 1
71573: PUSH
71574: LD_INT 2
71576: PUSH
71577: EMPTY
71578: LIST
71579: LIST
71580: PUSH
71581: LD_INT 1
71583: NEG
71584: PUSH
71585: LD_INT 1
71587: PUSH
71588: EMPTY
71589: LIST
71590: LIST
71591: PUSH
71592: LD_INT 2
71594: NEG
71595: PUSH
71596: LD_INT 0
71598: PUSH
71599: EMPTY
71600: LIST
71601: LIST
71602: PUSH
71603: LD_INT 2
71605: NEG
71606: PUSH
71607: LD_INT 1
71609: NEG
71610: PUSH
71611: EMPTY
71612: LIST
71613: LIST
71614: PUSH
71615: LD_INT 2
71617: NEG
71618: PUSH
71619: LD_INT 2
71621: NEG
71622: PUSH
71623: EMPTY
71624: LIST
71625: LIST
71626: PUSH
71627: LD_INT 2
71629: NEG
71630: PUSH
71631: LD_INT 3
71633: NEG
71634: PUSH
71635: EMPTY
71636: LIST
71637: LIST
71638: PUSH
71639: LD_INT 2
71641: PUSH
71642: LD_INT 1
71644: NEG
71645: PUSH
71646: EMPTY
71647: LIST
71648: LIST
71649: PUSH
71650: LD_INT 3
71652: PUSH
71653: LD_INT 0
71655: PUSH
71656: EMPTY
71657: LIST
71658: LIST
71659: PUSH
71660: LD_INT 3
71662: PUSH
71663: LD_INT 1
71665: PUSH
71666: EMPTY
71667: LIST
71668: LIST
71669: PUSH
71670: LD_INT 3
71672: PUSH
71673: LD_INT 2
71675: PUSH
71676: EMPTY
71677: LIST
71678: LIST
71679: PUSH
71680: LD_INT 3
71682: PUSH
71683: LD_INT 3
71685: PUSH
71686: EMPTY
71687: LIST
71688: LIST
71689: PUSH
71690: LD_INT 2
71692: PUSH
71693: LD_INT 3
71695: PUSH
71696: EMPTY
71697: LIST
71698: LIST
71699: PUSH
71700: LD_INT 2
71702: NEG
71703: PUSH
71704: LD_INT 1
71706: PUSH
71707: EMPTY
71708: LIST
71709: LIST
71710: PUSH
71711: LD_INT 3
71713: NEG
71714: PUSH
71715: LD_INT 0
71717: PUSH
71718: EMPTY
71719: LIST
71720: LIST
71721: PUSH
71722: LD_INT 3
71724: NEG
71725: PUSH
71726: LD_INT 1
71728: NEG
71729: PUSH
71730: EMPTY
71731: LIST
71732: LIST
71733: PUSH
71734: LD_INT 3
71736: NEG
71737: PUSH
71738: LD_INT 2
71740: NEG
71741: PUSH
71742: EMPTY
71743: LIST
71744: LIST
71745: PUSH
71746: LD_INT 3
71748: NEG
71749: PUSH
71750: LD_INT 3
71752: NEG
71753: PUSH
71754: EMPTY
71755: LIST
71756: LIST
71757: PUSH
71758: EMPTY
71759: LIST
71760: LIST
71761: LIST
71762: LIST
71763: LIST
71764: LIST
71765: LIST
71766: LIST
71767: LIST
71768: LIST
71769: LIST
71770: LIST
71771: LIST
71772: LIST
71773: LIST
71774: LIST
71775: LIST
71776: LIST
71777: LIST
71778: LIST
71779: LIST
71780: LIST
71781: LIST
71782: LIST
71783: LIST
71784: LIST
71785: LIST
71786: LIST
71787: LIST
71788: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
71789: LD_ADDR_VAR 0 45
71793: PUSH
71794: LD_INT 0
71796: PUSH
71797: LD_INT 0
71799: PUSH
71800: EMPTY
71801: LIST
71802: LIST
71803: PUSH
71804: LD_INT 0
71806: PUSH
71807: LD_INT 1
71809: NEG
71810: PUSH
71811: EMPTY
71812: LIST
71813: LIST
71814: PUSH
71815: LD_INT 1
71817: PUSH
71818: LD_INT 0
71820: PUSH
71821: EMPTY
71822: LIST
71823: LIST
71824: PUSH
71825: LD_INT 1
71827: PUSH
71828: LD_INT 1
71830: PUSH
71831: EMPTY
71832: LIST
71833: LIST
71834: PUSH
71835: LD_INT 0
71837: PUSH
71838: LD_INT 1
71840: PUSH
71841: EMPTY
71842: LIST
71843: LIST
71844: PUSH
71845: LD_INT 1
71847: NEG
71848: PUSH
71849: LD_INT 0
71851: PUSH
71852: EMPTY
71853: LIST
71854: LIST
71855: PUSH
71856: LD_INT 1
71858: NEG
71859: PUSH
71860: LD_INT 1
71862: NEG
71863: PUSH
71864: EMPTY
71865: LIST
71866: LIST
71867: PUSH
71868: LD_INT 1
71870: NEG
71871: PUSH
71872: LD_INT 2
71874: NEG
71875: PUSH
71876: EMPTY
71877: LIST
71878: LIST
71879: PUSH
71880: LD_INT 0
71882: PUSH
71883: LD_INT 2
71885: NEG
71886: PUSH
71887: EMPTY
71888: LIST
71889: LIST
71890: PUSH
71891: LD_INT 1
71893: PUSH
71894: LD_INT 1
71896: NEG
71897: PUSH
71898: EMPTY
71899: LIST
71900: LIST
71901: PUSH
71902: LD_INT 2
71904: PUSH
71905: LD_INT 1
71907: PUSH
71908: EMPTY
71909: LIST
71910: LIST
71911: PUSH
71912: LD_INT 2
71914: PUSH
71915: LD_INT 2
71917: PUSH
71918: EMPTY
71919: LIST
71920: LIST
71921: PUSH
71922: LD_INT 1
71924: PUSH
71925: LD_INT 2
71927: PUSH
71928: EMPTY
71929: LIST
71930: LIST
71931: PUSH
71932: LD_INT 0
71934: PUSH
71935: LD_INT 2
71937: PUSH
71938: EMPTY
71939: LIST
71940: LIST
71941: PUSH
71942: LD_INT 1
71944: NEG
71945: PUSH
71946: LD_INT 1
71948: PUSH
71949: EMPTY
71950: LIST
71951: LIST
71952: PUSH
71953: LD_INT 2
71955: NEG
71956: PUSH
71957: LD_INT 1
71959: NEG
71960: PUSH
71961: EMPTY
71962: LIST
71963: LIST
71964: PUSH
71965: LD_INT 2
71967: NEG
71968: PUSH
71969: LD_INT 2
71971: NEG
71972: PUSH
71973: EMPTY
71974: LIST
71975: LIST
71976: PUSH
71977: LD_INT 2
71979: NEG
71980: PUSH
71981: LD_INT 3
71983: NEG
71984: PUSH
71985: EMPTY
71986: LIST
71987: LIST
71988: PUSH
71989: LD_INT 1
71991: NEG
71992: PUSH
71993: LD_INT 3
71995: NEG
71996: PUSH
71997: EMPTY
71998: LIST
71999: LIST
72000: PUSH
72001: LD_INT 0
72003: PUSH
72004: LD_INT 3
72006: NEG
72007: PUSH
72008: EMPTY
72009: LIST
72010: LIST
72011: PUSH
72012: LD_INT 1
72014: PUSH
72015: LD_INT 2
72017: NEG
72018: PUSH
72019: EMPTY
72020: LIST
72021: LIST
72022: PUSH
72023: LD_INT 3
72025: PUSH
72026: LD_INT 2
72028: PUSH
72029: EMPTY
72030: LIST
72031: LIST
72032: PUSH
72033: LD_INT 3
72035: PUSH
72036: LD_INT 3
72038: PUSH
72039: EMPTY
72040: LIST
72041: LIST
72042: PUSH
72043: LD_INT 2
72045: PUSH
72046: LD_INT 3
72048: PUSH
72049: EMPTY
72050: LIST
72051: LIST
72052: PUSH
72053: LD_INT 1
72055: PUSH
72056: LD_INT 3
72058: PUSH
72059: EMPTY
72060: LIST
72061: LIST
72062: PUSH
72063: LD_INT 0
72065: PUSH
72066: LD_INT 3
72068: PUSH
72069: EMPTY
72070: LIST
72071: LIST
72072: PUSH
72073: LD_INT 1
72075: NEG
72076: PUSH
72077: LD_INT 2
72079: PUSH
72080: EMPTY
72081: LIST
72082: LIST
72083: PUSH
72084: LD_INT 3
72086: NEG
72087: PUSH
72088: LD_INT 2
72090: NEG
72091: PUSH
72092: EMPTY
72093: LIST
72094: LIST
72095: PUSH
72096: LD_INT 3
72098: NEG
72099: PUSH
72100: LD_INT 3
72102: NEG
72103: PUSH
72104: EMPTY
72105: LIST
72106: LIST
72107: PUSH
72108: EMPTY
72109: LIST
72110: LIST
72111: LIST
72112: LIST
72113: LIST
72114: LIST
72115: LIST
72116: LIST
72117: LIST
72118: LIST
72119: LIST
72120: LIST
72121: LIST
72122: LIST
72123: LIST
72124: LIST
72125: LIST
72126: LIST
72127: LIST
72128: LIST
72129: LIST
72130: LIST
72131: LIST
72132: LIST
72133: LIST
72134: LIST
72135: LIST
72136: LIST
72137: LIST
72138: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
72139: LD_ADDR_VAR 0 46
72143: PUSH
72144: LD_INT 0
72146: PUSH
72147: LD_INT 0
72149: PUSH
72150: EMPTY
72151: LIST
72152: LIST
72153: PUSH
72154: LD_INT 0
72156: PUSH
72157: LD_INT 1
72159: NEG
72160: PUSH
72161: EMPTY
72162: LIST
72163: LIST
72164: PUSH
72165: LD_INT 1
72167: PUSH
72168: LD_INT 0
72170: PUSH
72171: EMPTY
72172: LIST
72173: LIST
72174: PUSH
72175: LD_INT 1
72177: PUSH
72178: LD_INT 1
72180: PUSH
72181: EMPTY
72182: LIST
72183: LIST
72184: PUSH
72185: LD_INT 0
72187: PUSH
72188: LD_INT 1
72190: PUSH
72191: EMPTY
72192: LIST
72193: LIST
72194: PUSH
72195: LD_INT 1
72197: NEG
72198: PUSH
72199: LD_INT 0
72201: PUSH
72202: EMPTY
72203: LIST
72204: LIST
72205: PUSH
72206: LD_INT 1
72208: NEG
72209: PUSH
72210: LD_INT 1
72212: NEG
72213: PUSH
72214: EMPTY
72215: LIST
72216: LIST
72217: PUSH
72218: LD_INT 1
72220: NEG
72221: PUSH
72222: LD_INT 2
72224: NEG
72225: PUSH
72226: EMPTY
72227: LIST
72228: LIST
72229: PUSH
72230: LD_INT 0
72232: PUSH
72233: LD_INT 2
72235: NEG
72236: PUSH
72237: EMPTY
72238: LIST
72239: LIST
72240: PUSH
72241: LD_INT 1
72243: PUSH
72244: LD_INT 1
72246: NEG
72247: PUSH
72248: EMPTY
72249: LIST
72250: LIST
72251: PUSH
72252: LD_INT 2
72254: PUSH
72255: LD_INT 0
72257: PUSH
72258: EMPTY
72259: LIST
72260: LIST
72261: PUSH
72262: LD_INT 2
72264: PUSH
72265: LD_INT 1
72267: PUSH
72268: EMPTY
72269: LIST
72270: LIST
72271: PUSH
72272: LD_INT 1
72274: PUSH
72275: LD_INT 2
72277: PUSH
72278: EMPTY
72279: LIST
72280: LIST
72281: PUSH
72282: LD_INT 0
72284: PUSH
72285: LD_INT 2
72287: PUSH
72288: EMPTY
72289: LIST
72290: LIST
72291: PUSH
72292: LD_INT 1
72294: NEG
72295: PUSH
72296: LD_INT 1
72298: PUSH
72299: EMPTY
72300: LIST
72301: LIST
72302: PUSH
72303: LD_INT 2
72305: NEG
72306: PUSH
72307: LD_INT 0
72309: PUSH
72310: EMPTY
72311: LIST
72312: LIST
72313: PUSH
72314: LD_INT 2
72316: NEG
72317: PUSH
72318: LD_INT 1
72320: NEG
72321: PUSH
72322: EMPTY
72323: LIST
72324: LIST
72325: PUSH
72326: LD_INT 1
72328: NEG
72329: PUSH
72330: LD_INT 3
72332: NEG
72333: PUSH
72334: EMPTY
72335: LIST
72336: LIST
72337: PUSH
72338: LD_INT 0
72340: PUSH
72341: LD_INT 3
72343: NEG
72344: PUSH
72345: EMPTY
72346: LIST
72347: LIST
72348: PUSH
72349: LD_INT 1
72351: PUSH
72352: LD_INT 2
72354: NEG
72355: PUSH
72356: EMPTY
72357: LIST
72358: LIST
72359: PUSH
72360: LD_INT 2
72362: PUSH
72363: LD_INT 1
72365: NEG
72366: PUSH
72367: EMPTY
72368: LIST
72369: LIST
72370: PUSH
72371: LD_INT 3
72373: PUSH
72374: LD_INT 0
72376: PUSH
72377: EMPTY
72378: LIST
72379: LIST
72380: PUSH
72381: LD_INT 3
72383: PUSH
72384: LD_INT 1
72386: PUSH
72387: EMPTY
72388: LIST
72389: LIST
72390: PUSH
72391: LD_INT 1
72393: PUSH
72394: LD_INT 3
72396: PUSH
72397: EMPTY
72398: LIST
72399: LIST
72400: PUSH
72401: LD_INT 0
72403: PUSH
72404: LD_INT 3
72406: PUSH
72407: EMPTY
72408: LIST
72409: LIST
72410: PUSH
72411: LD_INT 1
72413: NEG
72414: PUSH
72415: LD_INT 2
72417: PUSH
72418: EMPTY
72419: LIST
72420: LIST
72421: PUSH
72422: LD_INT 2
72424: NEG
72425: PUSH
72426: LD_INT 1
72428: PUSH
72429: EMPTY
72430: LIST
72431: LIST
72432: PUSH
72433: LD_INT 3
72435: NEG
72436: PUSH
72437: LD_INT 0
72439: PUSH
72440: EMPTY
72441: LIST
72442: LIST
72443: PUSH
72444: LD_INT 3
72446: NEG
72447: PUSH
72448: LD_INT 1
72450: NEG
72451: PUSH
72452: EMPTY
72453: LIST
72454: LIST
72455: PUSH
72456: EMPTY
72457: LIST
72458: LIST
72459: LIST
72460: LIST
72461: LIST
72462: LIST
72463: LIST
72464: LIST
72465: LIST
72466: LIST
72467: LIST
72468: LIST
72469: LIST
72470: LIST
72471: LIST
72472: LIST
72473: LIST
72474: LIST
72475: LIST
72476: LIST
72477: LIST
72478: LIST
72479: LIST
72480: LIST
72481: LIST
72482: LIST
72483: LIST
72484: LIST
72485: LIST
72486: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72487: LD_ADDR_VAR 0 47
72491: PUSH
72492: LD_INT 0
72494: PUSH
72495: LD_INT 0
72497: PUSH
72498: EMPTY
72499: LIST
72500: LIST
72501: PUSH
72502: LD_INT 0
72504: PUSH
72505: LD_INT 1
72507: NEG
72508: PUSH
72509: EMPTY
72510: LIST
72511: LIST
72512: PUSH
72513: LD_INT 1
72515: PUSH
72516: LD_INT 0
72518: PUSH
72519: EMPTY
72520: LIST
72521: LIST
72522: PUSH
72523: LD_INT 1
72525: PUSH
72526: LD_INT 1
72528: PUSH
72529: EMPTY
72530: LIST
72531: LIST
72532: PUSH
72533: LD_INT 0
72535: PUSH
72536: LD_INT 1
72538: PUSH
72539: EMPTY
72540: LIST
72541: LIST
72542: PUSH
72543: LD_INT 1
72545: NEG
72546: PUSH
72547: LD_INT 0
72549: PUSH
72550: EMPTY
72551: LIST
72552: LIST
72553: PUSH
72554: LD_INT 1
72556: NEG
72557: PUSH
72558: LD_INT 1
72560: NEG
72561: PUSH
72562: EMPTY
72563: LIST
72564: LIST
72565: PUSH
72566: LD_INT 1
72568: NEG
72569: PUSH
72570: LD_INT 2
72572: NEG
72573: PUSH
72574: EMPTY
72575: LIST
72576: LIST
72577: PUSH
72578: LD_INT 0
72580: PUSH
72581: LD_INT 2
72583: NEG
72584: PUSH
72585: EMPTY
72586: LIST
72587: LIST
72588: PUSH
72589: LD_INT 1
72591: PUSH
72592: LD_INT 1
72594: NEG
72595: PUSH
72596: EMPTY
72597: LIST
72598: LIST
72599: PUSH
72600: LD_INT 2
72602: NEG
72603: PUSH
72604: LD_INT 1
72606: NEG
72607: PUSH
72608: EMPTY
72609: LIST
72610: LIST
72611: PUSH
72612: LD_INT 2
72614: NEG
72615: PUSH
72616: LD_INT 2
72618: NEG
72619: PUSH
72620: EMPTY
72621: LIST
72622: LIST
72623: PUSH
72624: EMPTY
72625: LIST
72626: LIST
72627: LIST
72628: LIST
72629: LIST
72630: LIST
72631: LIST
72632: LIST
72633: LIST
72634: LIST
72635: LIST
72636: LIST
72637: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
72638: LD_ADDR_VAR 0 48
72642: PUSH
72643: LD_INT 0
72645: PUSH
72646: LD_INT 0
72648: PUSH
72649: EMPTY
72650: LIST
72651: LIST
72652: PUSH
72653: LD_INT 0
72655: PUSH
72656: LD_INT 1
72658: NEG
72659: PUSH
72660: EMPTY
72661: LIST
72662: LIST
72663: PUSH
72664: LD_INT 1
72666: PUSH
72667: LD_INT 0
72669: PUSH
72670: EMPTY
72671: LIST
72672: LIST
72673: PUSH
72674: LD_INT 1
72676: PUSH
72677: LD_INT 1
72679: PUSH
72680: EMPTY
72681: LIST
72682: LIST
72683: PUSH
72684: LD_INT 0
72686: PUSH
72687: LD_INT 1
72689: PUSH
72690: EMPTY
72691: LIST
72692: LIST
72693: PUSH
72694: LD_INT 1
72696: NEG
72697: PUSH
72698: LD_INT 0
72700: PUSH
72701: EMPTY
72702: LIST
72703: LIST
72704: PUSH
72705: LD_INT 1
72707: NEG
72708: PUSH
72709: LD_INT 1
72711: NEG
72712: PUSH
72713: EMPTY
72714: LIST
72715: LIST
72716: PUSH
72717: LD_INT 1
72719: NEG
72720: PUSH
72721: LD_INT 2
72723: NEG
72724: PUSH
72725: EMPTY
72726: LIST
72727: LIST
72728: PUSH
72729: LD_INT 0
72731: PUSH
72732: LD_INT 2
72734: NEG
72735: PUSH
72736: EMPTY
72737: LIST
72738: LIST
72739: PUSH
72740: LD_INT 1
72742: PUSH
72743: LD_INT 1
72745: NEG
72746: PUSH
72747: EMPTY
72748: LIST
72749: LIST
72750: PUSH
72751: LD_INT 2
72753: PUSH
72754: LD_INT 0
72756: PUSH
72757: EMPTY
72758: LIST
72759: LIST
72760: PUSH
72761: LD_INT 2
72763: PUSH
72764: LD_INT 1
72766: PUSH
72767: EMPTY
72768: LIST
72769: LIST
72770: PUSH
72771: EMPTY
72772: LIST
72773: LIST
72774: LIST
72775: LIST
72776: LIST
72777: LIST
72778: LIST
72779: LIST
72780: LIST
72781: LIST
72782: LIST
72783: LIST
72784: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
72785: LD_ADDR_VAR 0 49
72789: PUSH
72790: LD_INT 0
72792: PUSH
72793: LD_INT 0
72795: PUSH
72796: EMPTY
72797: LIST
72798: LIST
72799: PUSH
72800: LD_INT 0
72802: PUSH
72803: LD_INT 1
72805: NEG
72806: PUSH
72807: EMPTY
72808: LIST
72809: LIST
72810: PUSH
72811: LD_INT 1
72813: PUSH
72814: LD_INT 0
72816: PUSH
72817: EMPTY
72818: LIST
72819: LIST
72820: PUSH
72821: LD_INT 1
72823: PUSH
72824: LD_INT 1
72826: PUSH
72827: EMPTY
72828: LIST
72829: LIST
72830: PUSH
72831: LD_INT 0
72833: PUSH
72834: LD_INT 1
72836: PUSH
72837: EMPTY
72838: LIST
72839: LIST
72840: PUSH
72841: LD_INT 1
72843: NEG
72844: PUSH
72845: LD_INT 0
72847: PUSH
72848: EMPTY
72849: LIST
72850: LIST
72851: PUSH
72852: LD_INT 1
72854: NEG
72855: PUSH
72856: LD_INT 1
72858: NEG
72859: PUSH
72860: EMPTY
72861: LIST
72862: LIST
72863: PUSH
72864: LD_INT 1
72866: PUSH
72867: LD_INT 1
72869: NEG
72870: PUSH
72871: EMPTY
72872: LIST
72873: LIST
72874: PUSH
72875: LD_INT 2
72877: PUSH
72878: LD_INT 0
72880: PUSH
72881: EMPTY
72882: LIST
72883: LIST
72884: PUSH
72885: LD_INT 2
72887: PUSH
72888: LD_INT 1
72890: PUSH
72891: EMPTY
72892: LIST
72893: LIST
72894: PUSH
72895: LD_INT 2
72897: PUSH
72898: LD_INT 2
72900: PUSH
72901: EMPTY
72902: LIST
72903: LIST
72904: PUSH
72905: LD_INT 1
72907: PUSH
72908: LD_INT 2
72910: PUSH
72911: EMPTY
72912: LIST
72913: LIST
72914: PUSH
72915: EMPTY
72916: LIST
72917: LIST
72918: LIST
72919: LIST
72920: LIST
72921: LIST
72922: LIST
72923: LIST
72924: LIST
72925: LIST
72926: LIST
72927: LIST
72928: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
72929: LD_ADDR_VAR 0 50
72933: PUSH
72934: LD_INT 0
72936: PUSH
72937: LD_INT 0
72939: PUSH
72940: EMPTY
72941: LIST
72942: LIST
72943: PUSH
72944: LD_INT 0
72946: PUSH
72947: LD_INT 1
72949: NEG
72950: PUSH
72951: EMPTY
72952: LIST
72953: LIST
72954: PUSH
72955: LD_INT 1
72957: PUSH
72958: LD_INT 0
72960: PUSH
72961: EMPTY
72962: LIST
72963: LIST
72964: PUSH
72965: LD_INT 1
72967: PUSH
72968: LD_INT 1
72970: PUSH
72971: EMPTY
72972: LIST
72973: LIST
72974: PUSH
72975: LD_INT 0
72977: PUSH
72978: LD_INT 1
72980: PUSH
72981: EMPTY
72982: LIST
72983: LIST
72984: PUSH
72985: LD_INT 1
72987: NEG
72988: PUSH
72989: LD_INT 0
72991: PUSH
72992: EMPTY
72993: LIST
72994: LIST
72995: PUSH
72996: LD_INT 1
72998: NEG
72999: PUSH
73000: LD_INT 1
73002: NEG
73003: PUSH
73004: EMPTY
73005: LIST
73006: LIST
73007: PUSH
73008: LD_INT 2
73010: PUSH
73011: LD_INT 1
73013: PUSH
73014: EMPTY
73015: LIST
73016: LIST
73017: PUSH
73018: LD_INT 2
73020: PUSH
73021: LD_INT 2
73023: PUSH
73024: EMPTY
73025: LIST
73026: LIST
73027: PUSH
73028: LD_INT 1
73030: PUSH
73031: LD_INT 2
73033: PUSH
73034: EMPTY
73035: LIST
73036: LIST
73037: PUSH
73038: LD_INT 0
73040: PUSH
73041: LD_INT 2
73043: PUSH
73044: EMPTY
73045: LIST
73046: LIST
73047: PUSH
73048: LD_INT 1
73050: NEG
73051: PUSH
73052: LD_INT 1
73054: PUSH
73055: EMPTY
73056: LIST
73057: LIST
73058: PUSH
73059: EMPTY
73060: LIST
73061: LIST
73062: LIST
73063: LIST
73064: LIST
73065: LIST
73066: LIST
73067: LIST
73068: LIST
73069: LIST
73070: LIST
73071: LIST
73072: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
73073: LD_ADDR_VAR 0 51
73077: PUSH
73078: LD_INT 0
73080: PUSH
73081: LD_INT 0
73083: PUSH
73084: EMPTY
73085: LIST
73086: LIST
73087: PUSH
73088: LD_INT 0
73090: PUSH
73091: LD_INT 1
73093: NEG
73094: PUSH
73095: EMPTY
73096: LIST
73097: LIST
73098: PUSH
73099: LD_INT 1
73101: PUSH
73102: LD_INT 0
73104: PUSH
73105: EMPTY
73106: LIST
73107: LIST
73108: PUSH
73109: LD_INT 1
73111: PUSH
73112: LD_INT 1
73114: PUSH
73115: EMPTY
73116: LIST
73117: LIST
73118: PUSH
73119: LD_INT 0
73121: PUSH
73122: LD_INT 1
73124: PUSH
73125: EMPTY
73126: LIST
73127: LIST
73128: PUSH
73129: LD_INT 1
73131: NEG
73132: PUSH
73133: LD_INT 0
73135: PUSH
73136: EMPTY
73137: LIST
73138: LIST
73139: PUSH
73140: LD_INT 1
73142: NEG
73143: PUSH
73144: LD_INT 1
73146: NEG
73147: PUSH
73148: EMPTY
73149: LIST
73150: LIST
73151: PUSH
73152: LD_INT 1
73154: PUSH
73155: LD_INT 2
73157: PUSH
73158: EMPTY
73159: LIST
73160: LIST
73161: PUSH
73162: LD_INT 0
73164: PUSH
73165: LD_INT 2
73167: PUSH
73168: EMPTY
73169: LIST
73170: LIST
73171: PUSH
73172: LD_INT 1
73174: NEG
73175: PUSH
73176: LD_INT 1
73178: PUSH
73179: EMPTY
73180: LIST
73181: LIST
73182: PUSH
73183: LD_INT 2
73185: NEG
73186: PUSH
73187: LD_INT 0
73189: PUSH
73190: EMPTY
73191: LIST
73192: LIST
73193: PUSH
73194: LD_INT 2
73196: NEG
73197: PUSH
73198: LD_INT 1
73200: NEG
73201: PUSH
73202: EMPTY
73203: LIST
73204: LIST
73205: PUSH
73206: EMPTY
73207: LIST
73208: LIST
73209: LIST
73210: LIST
73211: LIST
73212: LIST
73213: LIST
73214: LIST
73215: LIST
73216: LIST
73217: LIST
73218: LIST
73219: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73220: LD_ADDR_VAR 0 52
73224: PUSH
73225: LD_INT 0
73227: PUSH
73228: LD_INT 0
73230: PUSH
73231: EMPTY
73232: LIST
73233: LIST
73234: PUSH
73235: LD_INT 0
73237: PUSH
73238: LD_INT 1
73240: NEG
73241: PUSH
73242: EMPTY
73243: LIST
73244: LIST
73245: PUSH
73246: LD_INT 1
73248: PUSH
73249: LD_INT 0
73251: PUSH
73252: EMPTY
73253: LIST
73254: LIST
73255: PUSH
73256: LD_INT 1
73258: PUSH
73259: LD_INT 1
73261: PUSH
73262: EMPTY
73263: LIST
73264: LIST
73265: PUSH
73266: LD_INT 0
73268: PUSH
73269: LD_INT 1
73271: PUSH
73272: EMPTY
73273: LIST
73274: LIST
73275: PUSH
73276: LD_INT 1
73278: NEG
73279: PUSH
73280: LD_INT 0
73282: PUSH
73283: EMPTY
73284: LIST
73285: LIST
73286: PUSH
73287: LD_INT 1
73289: NEG
73290: PUSH
73291: LD_INT 1
73293: NEG
73294: PUSH
73295: EMPTY
73296: LIST
73297: LIST
73298: PUSH
73299: LD_INT 1
73301: NEG
73302: PUSH
73303: LD_INT 2
73305: NEG
73306: PUSH
73307: EMPTY
73308: LIST
73309: LIST
73310: PUSH
73311: LD_INT 1
73313: NEG
73314: PUSH
73315: LD_INT 1
73317: PUSH
73318: EMPTY
73319: LIST
73320: LIST
73321: PUSH
73322: LD_INT 2
73324: NEG
73325: PUSH
73326: LD_INT 0
73328: PUSH
73329: EMPTY
73330: LIST
73331: LIST
73332: PUSH
73333: LD_INT 2
73335: NEG
73336: PUSH
73337: LD_INT 1
73339: NEG
73340: PUSH
73341: EMPTY
73342: LIST
73343: LIST
73344: PUSH
73345: LD_INT 2
73347: NEG
73348: PUSH
73349: LD_INT 2
73351: NEG
73352: PUSH
73353: EMPTY
73354: LIST
73355: LIST
73356: PUSH
73357: EMPTY
73358: LIST
73359: LIST
73360: LIST
73361: LIST
73362: LIST
73363: LIST
73364: LIST
73365: LIST
73366: LIST
73367: LIST
73368: LIST
73369: LIST
73370: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73371: LD_ADDR_VAR 0 53
73375: PUSH
73376: LD_INT 0
73378: PUSH
73379: LD_INT 0
73381: PUSH
73382: EMPTY
73383: LIST
73384: LIST
73385: PUSH
73386: LD_INT 0
73388: PUSH
73389: LD_INT 1
73391: NEG
73392: PUSH
73393: EMPTY
73394: LIST
73395: LIST
73396: PUSH
73397: LD_INT 1
73399: PUSH
73400: LD_INT 0
73402: PUSH
73403: EMPTY
73404: LIST
73405: LIST
73406: PUSH
73407: LD_INT 1
73409: PUSH
73410: LD_INT 1
73412: PUSH
73413: EMPTY
73414: LIST
73415: LIST
73416: PUSH
73417: LD_INT 0
73419: PUSH
73420: LD_INT 1
73422: PUSH
73423: EMPTY
73424: LIST
73425: LIST
73426: PUSH
73427: LD_INT 1
73429: NEG
73430: PUSH
73431: LD_INT 0
73433: PUSH
73434: EMPTY
73435: LIST
73436: LIST
73437: PUSH
73438: LD_INT 1
73440: NEG
73441: PUSH
73442: LD_INT 1
73444: NEG
73445: PUSH
73446: EMPTY
73447: LIST
73448: LIST
73449: PUSH
73450: LD_INT 1
73452: NEG
73453: PUSH
73454: LD_INT 2
73456: NEG
73457: PUSH
73458: EMPTY
73459: LIST
73460: LIST
73461: PUSH
73462: LD_INT 0
73464: PUSH
73465: LD_INT 2
73467: NEG
73468: PUSH
73469: EMPTY
73470: LIST
73471: LIST
73472: PUSH
73473: LD_INT 1
73475: PUSH
73476: LD_INT 1
73478: NEG
73479: PUSH
73480: EMPTY
73481: LIST
73482: LIST
73483: PUSH
73484: LD_INT 2
73486: PUSH
73487: LD_INT 0
73489: PUSH
73490: EMPTY
73491: LIST
73492: LIST
73493: PUSH
73494: LD_INT 2
73496: PUSH
73497: LD_INT 1
73499: PUSH
73500: EMPTY
73501: LIST
73502: LIST
73503: PUSH
73504: LD_INT 2
73506: PUSH
73507: LD_INT 2
73509: PUSH
73510: EMPTY
73511: LIST
73512: LIST
73513: PUSH
73514: LD_INT 1
73516: PUSH
73517: LD_INT 2
73519: PUSH
73520: EMPTY
73521: LIST
73522: LIST
73523: PUSH
73524: LD_INT 0
73526: PUSH
73527: LD_INT 2
73529: PUSH
73530: EMPTY
73531: LIST
73532: LIST
73533: PUSH
73534: LD_INT 1
73536: NEG
73537: PUSH
73538: LD_INT 1
73540: PUSH
73541: EMPTY
73542: LIST
73543: LIST
73544: PUSH
73545: LD_INT 2
73547: NEG
73548: PUSH
73549: LD_INT 0
73551: PUSH
73552: EMPTY
73553: LIST
73554: LIST
73555: PUSH
73556: LD_INT 2
73558: NEG
73559: PUSH
73560: LD_INT 1
73562: NEG
73563: PUSH
73564: EMPTY
73565: LIST
73566: LIST
73567: PUSH
73568: LD_INT 2
73570: NEG
73571: PUSH
73572: LD_INT 2
73574: NEG
73575: PUSH
73576: EMPTY
73577: LIST
73578: LIST
73579: PUSH
73580: EMPTY
73581: LIST
73582: LIST
73583: LIST
73584: LIST
73585: LIST
73586: LIST
73587: LIST
73588: LIST
73589: LIST
73590: LIST
73591: LIST
73592: LIST
73593: LIST
73594: LIST
73595: LIST
73596: LIST
73597: LIST
73598: LIST
73599: LIST
73600: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73601: LD_ADDR_VAR 0 54
73605: PUSH
73606: LD_INT 0
73608: PUSH
73609: LD_INT 0
73611: PUSH
73612: EMPTY
73613: LIST
73614: LIST
73615: PUSH
73616: LD_INT 0
73618: PUSH
73619: LD_INT 1
73621: NEG
73622: PUSH
73623: EMPTY
73624: LIST
73625: LIST
73626: PUSH
73627: LD_INT 1
73629: PUSH
73630: LD_INT 0
73632: PUSH
73633: EMPTY
73634: LIST
73635: LIST
73636: PUSH
73637: LD_INT 1
73639: PUSH
73640: LD_INT 1
73642: PUSH
73643: EMPTY
73644: LIST
73645: LIST
73646: PUSH
73647: LD_INT 0
73649: PUSH
73650: LD_INT 1
73652: PUSH
73653: EMPTY
73654: LIST
73655: LIST
73656: PUSH
73657: LD_INT 1
73659: NEG
73660: PUSH
73661: LD_INT 0
73663: PUSH
73664: EMPTY
73665: LIST
73666: LIST
73667: PUSH
73668: LD_INT 1
73670: NEG
73671: PUSH
73672: LD_INT 1
73674: NEG
73675: PUSH
73676: EMPTY
73677: LIST
73678: LIST
73679: PUSH
73680: LD_INT 1
73682: NEG
73683: PUSH
73684: LD_INT 2
73686: NEG
73687: PUSH
73688: EMPTY
73689: LIST
73690: LIST
73691: PUSH
73692: LD_INT 0
73694: PUSH
73695: LD_INT 2
73697: NEG
73698: PUSH
73699: EMPTY
73700: LIST
73701: LIST
73702: PUSH
73703: LD_INT 1
73705: PUSH
73706: LD_INT 1
73708: NEG
73709: PUSH
73710: EMPTY
73711: LIST
73712: LIST
73713: PUSH
73714: LD_INT 2
73716: PUSH
73717: LD_INT 0
73719: PUSH
73720: EMPTY
73721: LIST
73722: LIST
73723: PUSH
73724: LD_INT 2
73726: PUSH
73727: LD_INT 1
73729: PUSH
73730: EMPTY
73731: LIST
73732: LIST
73733: PUSH
73734: LD_INT 2
73736: PUSH
73737: LD_INT 2
73739: PUSH
73740: EMPTY
73741: LIST
73742: LIST
73743: PUSH
73744: LD_INT 1
73746: PUSH
73747: LD_INT 2
73749: PUSH
73750: EMPTY
73751: LIST
73752: LIST
73753: PUSH
73754: LD_INT 0
73756: PUSH
73757: LD_INT 2
73759: PUSH
73760: EMPTY
73761: LIST
73762: LIST
73763: PUSH
73764: LD_INT 1
73766: NEG
73767: PUSH
73768: LD_INT 1
73770: PUSH
73771: EMPTY
73772: LIST
73773: LIST
73774: PUSH
73775: LD_INT 2
73777: NEG
73778: PUSH
73779: LD_INT 0
73781: PUSH
73782: EMPTY
73783: LIST
73784: LIST
73785: PUSH
73786: LD_INT 2
73788: NEG
73789: PUSH
73790: LD_INT 1
73792: NEG
73793: PUSH
73794: EMPTY
73795: LIST
73796: LIST
73797: PUSH
73798: LD_INT 2
73800: NEG
73801: PUSH
73802: LD_INT 2
73804: NEG
73805: PUSH
73806: EMPTY
73807: LIST
73808: LIST
73809: PUSH
73810: EMPTY
73811: LIST
73812: LIST
73813: LIST
73814: LIST
73815: LIST
73816: LIST
73817: LIST
73818: LIST
73819: LIST
73820: LIST
73821: LIST
73822: LIST
73823: LIST
73824: LIST
73825: LIST
73826: LIST
73827: LIST
73828: LIST
73829: LIST
73830: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73831: LD_ADDR_VAR 0 55
73835: PUSH
73836: LD_INT 0
73838: PUSH
73839: LD_INT 0
73841: PUSH
73842: EMPTY
73843: LIST
73844: LIST
73845: PUSH
73846: LD_INT 0
73848: PUSH
73849: LD_INT 1
73851: NEG
73852: PUSH
73853: EMPTY
73854: LIST
73855: LIST
73856: PUSH
73857: LD_INT 1
73859: PUSH
73860: LD_INT 0
73862: PUSH
73863: EMPTY
73864: LIST
73865: LIST
73866: PUSH
73867: LD_INT 1
73869: PUSH
73870: LD_INT 1
73872: PUSH
73873: EMPTY
73874: LIST
73875: LIST
73876: PUSH
73877: LD_INT 0
73879: PUSH
73880: LD_INT 1
73882: PUSH
73883: EMPTY
73884: LIST
73885: LIST
73886: PUSH
73887: LD_INT 1
73889: NEG
73890: PUSH
73891: LD_INT 0
73893: PUSH
73894: EMPTY
73895: LIST
73896: LIST
73897: PUSH
73898: LD_INT 1
73900: NEG
73901: PUSH
73902: LD_INT 1
73904: NEG
73905: PUSH
73906: EMPTY
73907: LIST
73908: LIST
73909: PUSH
73910: LD_INT 1
73912: NEG
73913: PUSH
73914: LD_INT 2
73916: NEG
73917: PUSH
73918: EMPTY
73919: LIST
73920: LIST
73921: PUSH
73922: LD_INT 0
73924: PUSH
73925: LD_INT 2
73927: NEG
73928: PUSH
73929: EMPTY
73930: LIST
73931: LIST
73932: PUSH
73933: LD_INT 1
73935: PUSH
73936: LD_INT 1
73938: NEG
73939: PUSH
73940: EMPTY
73941: LIST
73942: LIST
73943: PUSH
73944: LD_INT 2
73946: PUSH
73947: LD_INT 0
73949: PUSH
73950: EMPTY
73951: LIST
73952: LIST
73953: PUSH
73954: LD_INT 2
73956: PUSH
73957: LD_INT 1
73959: PUSH
73960: EMPTY
73961: LIST
73962: LIST
73963: PUSH
73964: LD_INT 2
73966: PUSH
73967: LD_INT 2
73969: PUSH
73970: EMPTY
73971: LIST
73972: LIST
73973: PUSH
73974: LD_INT 1
73976: PUSH
73977: LD_INT 2
73979: PUSH
73980: EMPTY
73981: LIST
73982: LIST
73983: PUSH
73984: LD_INT 0
73986: PUSH
73987: LD_INT 2
73989: PUSH
73990: EMPTY
73991: LIST
73992: LIST
73993: PUSH
73994: LD_INT 1
73996: NEG
73997: PUSH
73998: LD_INT 1
74000: PUSH
74001: EMPTY
74002: LIST
74003: LIST
74004: PUSH
74005: LD_INT 2
74007: NEG
74008: PUSH
74009: LD_INT 0
74011: PUSH
74012: EMPTY
74013: LIST
74014: LIST
74015: PUSH
74016: LD_INT 2
74018: NEG
74019: PUSH
74020: LD_INT 1
74022: NEG
74023: PUSH
74024: EMPTY
74025: LIST
74026: LIST
74027: PUSH
74028: LD_INT 2
74030: NEG
74031: PUSH
74032: LD_INT 2
74034: NEG
74035: PUSH
74036: EMPTY
74037: LIST
74038: LIST
74039: PUSH
74040: EMPTY
74041: LIST
74042: LIST
74043: LIST
74044: LIST
74045: LIST
74046: LIST
74047: LIST
74048: LIST
74049: LIST
74050: LIST
74051: LIST
74052: LIST
74053: LIST
74054: LIST
74055: LIST
74056: LIST
74057: LIST
74058: LIST
74059: LIST
74060: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74061: LD_ADDR_VAR 0 56
74065: PUSH
74066: LD_INT 0
74068: PUSH
74069: LD_INT 0
74071: PUSH
74072: EMPTY
74073: LIST
74074: LIST
74075: PUSH
74076: LD_INT 0
74078: PUSH
74079: LD_INT 1
74081: NEG
74082: PUSH
74083: EMPTY
74084: LIST
74085: LIST
74086: PUSH
74087: LD_INT 1
74089: PUSH
74090: LD_INT 0
74092: PUSH
74093: EMPTY
74094: LIST
74095: LIST
74096: PUSH
74097: LD_INT 1
74099: PUSH
74100: LD_INT 1
74102: PUSH
74103: EMPTY
74104: LIST
74105: LIST
74106: PUSH
74107: LD_INT 0
74109: PUSH
74110: LD_INT 1
74112: PUSH
74113: EMPTY
74114: LIST
74115: LIST
74116: PUSH
74117: LD_INT 1
74119: NEG
74120: PUSH
74121: LD_INT 0
74123: PUSH
74124: EMPTY
74125: LIST
74126: LIST
74127: PUSH
74128: LD_INT 1
74130: NEG
74131: PUSH
74132: LD_INT 1
74134: NEG
74135: PUSH
74136: EMPTY
74137: LIST
74138: LIST
74139: PUSH
74140: LD_INT 1
74142: NEG
74143: PUSH
74144: LD_INT 2
74146: NEG
74147: PUSH
74148: EMPTY
74149: LIST
74150: LIST
74151: PUSH
74152: LD_INT 0
74154: PUSH
74155: LD_INT 2
74157: NEG
74158: PUSH
74159: EMPTY
74160: LIST
74161: LIST
74162: PUSH
74163: LD_INT 1
74165: PUSH
74166: LD_INT 1
74168: NEG
74169: PUSH
74170: EMPTY
74171: LIST
74172: LIST
74173: PUSH
74174: LD_INT 2
74176: PUSH
74177: LD_INT 0
74179: PUSH
74180: EMPTY
74181: LIST
74182: LIST
74183: PUSH
74184: LD_INT 2
74186: PUSH
74187: LD_INT 1
74189: PUSH
74190: EMPTY
74191: LIST
74192: LIST
74193: PUSH
74194: LD_INT 2
74196: PUSH
74197: LD_INT 2
74199: PUSH
74200: EMPTY
74201: LIST
74202: LIST
74203: PUSH
74204: LD_INT 1
74206: PUSH
74207: LD_INT 2
74209: PUSH
74210: EMPTY
74211: LIST
74212: LIST
74213: PUSH
74214: LD_INT 0
74216: PUSH
74217: LD_INT 2
74219: PUSH
74220: EMPTY
74221: LIST
74222: LIST
74223: PUSH
74224: LD_INT 1
74226: NEG
74227: PUSH
74228: LD_INT 1
74230: PUSH
74231: EMPTY
74232: LIST
74233: LIST
74234: PUSH
74235: LD_INT 2
74237: NEG
74238: PUSH
74239: LD_INT 0
74241: PUSH
74242: EMPTY
74243: LIST
74244: LIST
74245: PUSH
74246: LD_INT 2
74248: NEG
74249: PUSH
74250: LD_INT 1
74252: NEG
74253: PUSH
74254: EMPTY
74255: LIST
74256: LIST
74257: PUSH
74258: LD_INT 2
74260: NEG
74261: PUSH
74262: LD_INT 2
74264: NEG
74265: PUSH
74266: EMPTY
74267: LIST
74268: LIST
74269: PUSH
74270: EMPTY
74271: LIST
74272: LIST
74273: LIST
74274: LIST
74275: LIST
74276: LIST
74277: LIST
74278: LIST
74279: LIST
74280: LIST
74281: LIST
74282: LIST
74283: LIST
74284: LIST
74285: LIST
74286: LIST
74287: LIST
74288: LIST
74289: LIST
74290: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74291: LD_ADDR_VAR 0 57
74295: PUSH
74296: LD_INT 0
74298: PUSH
74299: LD_INT 0
74301: PUSH
74302: EMPTY
74303: LIST
74304: LIST
74305: PUSH
74306: LD_INT 0
74308: PUSH
74309: LD_INT 1
74311: NEG
74312: PUSH
74313: EMPTY
74314: LIST
74315: LIST
74316: PUSH
74317: LD_INT 1
74319: PUSH
74320: LD_INT 0
74322: PUSH
74323: EMPTY
74324: LIST
74325: LIST
74326: PUSH
74327: LD_INT 1
74329: PUSH
74330: LD_INT 1
74332: PUSH
74333: EMPTY
74334: LIST
74335: LIST
74336: PUSH
74337: LD_INT 0
74339: PUSH
74340: LD_INT 1
74342: PUSH
74343: EMPTY
74344: LIST
74345: LIST
74346: PUSH
74347: LD_INT 1
74349: NEG
74350: PUSH
74351: LD_INT 0
74353: PUSH
74354: EMPTY
74355: LIST
74356: LIST
74357: PUSH
74358: LD_INT 1
74360: NEG
74361: PUSH
74362: LD_INT 1
74364: NEG
74365: PUSH
74366: EMPTY
74367: LIST
74368: LIST
74369: PUSH
74370: LD_INT 1
74372: NEG
74373: PUSH
74374: LD_INT 2
74376: NEG
74377: PUSH
74378: EMPTY
74379: LIST
74380: LIST
74381: PUSH
74382: LD_INT 0
74384: PUSH
74385: LD_INT 2
74387: NEG
74388: PUSH
74389: EMPTY
74390: LIST
74391: LIST
74392: PUSH
74393: LD_INT 1
74395: PUSH
74396: LD_INT 1
74398: NEG
74399: PUSH
74400: EMPTY
74401: LIST
74402: LIST
74403: PUSH
74404: LD_INT 2
74406: PUSH
74407: LD_INT 0
74409: PUSH
74410: EMPTY
74411: LIST
74412: LIST
74413: PUSH
74414: LD_INT 2
74416: PUSH
74417: LD_INT 1
74419: PUSH
74420: EMPTY
74421: LIST
74422: LIST
74423: PUSH
74424: LD_INT 2
74426: PUSH
74427: LD_INT 2
74429: PUSH
74430: EMPTY
74431: LIST
74432: LIST
74433: PUSH
74434: LD_INT 1
74436: PUSH
74437: LD_INT 2
74439: PUSH
74440: EMPTY
74441: LIST
74442: LIST
74443: PUSH
74444: LD_INT 0
74446: PUSH
74447: LD_INT 2
74449: PUSH
74450: EMPTY
74451: LIST
74452: LIST
74453: PUSH
74454: LD_INT 1
74456: NEG
74457: PUSH
74458: LD_INT 1
74460: PUSH
74461: EMPTY
74462: LIST
74463: LIST
74464: PUSH
74465: LD_INT 2
74467: NEG
74468: PUSH
74469: LD_INT 0
74471: PUSH
74472: EMPTY
74473: LIST
74474: LIST
74475: PUSH
74476: LD_INT 2
74478: NEG
74479: PUSH
74480: LD_INT 1
74482: NEG
74483: PUSH
74484: EMPTY
74485: LIST
74486: LIST
74487: PUSH
74488: LD_INT 2
74490: NEG
74491: PUSH
74492: LD_INT 2
74494: NEG
74495: PUSH
74496: EMPTY
74497: LIST
74498: LIST
74499: PUSH
74500: EMPTY
74501: LIST
74502: LIST
74503: LIST
74504: LIST
74505: LIST
74506: LIST
74507: LIST
74508: LIST
74509: LIST
74510: LIST
74511: LIST
74512: LIST
74513: LIST
74514: LIST
74515: LIST
74516: LIST
74517: LIST
74518: LIST
74519: LIST
74520: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74521: LD_ADDR_VAR 0 58
74525: PUSH
74526: LD_INT 0
74528: PUSH
74529: LD_INT 0
74531: PUSH
74532: EMPTY
74533: LIST
74534: LIST
74535: PUSH
74536: LD_INT 0
74538: PUSH
74539: LD_INT 1
74541: NEG
74542: PUSH
74543: EMPTY
74544: LIST
74545: LIST
74546: PUSH
74547: LD_INT 1
74549: PUSH
74550: LD_INT 0
74552: PUSH
74553: EMPTY
74554: LIST
74555: LIST
74556: PUSH
74557: LD_INT 1
74559: PUSH
74560: LD_INT 1
74562: PUSH
74563: EMPTY
74564: LIST
74565: LIST
74566: PUSH
74567: LD_INT 0
74569: PUSH
74570: LD_INT 1
74572: PUSH
74573: EMPTY
74574: LIST
74575: LIST
74576: PUSH
74577: LD_INT 1
74579: NEG
74580: PUSH
74581: LD_INT 0
74583: PUSH
74584: EMPTY
74585: LIST
74586: LIST
74587: PUSH
74588: LD_INT 1
74590: NEG
74591: PUSH
74592: LD_INT 1
74594: NEG
74595: PUSH
74596: EMPTY
74597: LIST
74598: LIST
74599: PUSH
74600: LD_INT 1
74602: NEG
74603: PUSH
74604: LD_INT 2
74606: NEG
74607: PUSH
74608: EMPTY
74609: LIST
74610: LIST
74611: PUSH
74612: LD_INT 0
74614: PUSH
74615: LD_INT 2
74617: NEG
74618: PUSH
74619: EMPTY
74620: LIST
74621: LIST
74622: PUSH
74623: LD_INT 1
74625: PUSH
74626: LD_INT 1
74628: NEG
74629: PUSH
74630: EMPTY
74631: LIST
74632: LIST
74633: PUSH
74634: LD_INT 2
74636: PUSH
74637: LD_INT 0
74639: PUSH
74640: EMPTY
74641: LIST
74642: LIST
74643: PUSH
74644: LD_INT 2
74646: PUSH
74647: LD_INT 1
74649: PUSH
74650: EMPTY
74651: LIST
74652: LIST
74653: PUSH
74654: LD_INT 2
74656: PUSH
74657: LD_INT 2
74659: PUSH
74660: EMPTY
74661: LIST
74662: LIST
74663: PUSH
74664: LD_INT 1
74666: PUSH
74667: LD_INT 2
74669: PUSH
74670: EMPTY
74671: LIST
74672: LIST
74673: PUSH
74674: LD_INT 0
74676: PUSH
74677: LD_INT 2
74679: PUSH
74680: EMPTY
74681: LIST
74682: LIST
74683: PUSH
74684: LD_INT 1
74686: NEG
74687: PUSH
74688: LD_INT 1
74690: PUSH
74691: EMPTY
74692: LIST
74693: LIST
74694: PUSH
74695: LD_INT 2
74697: NEG
74698: PUSH
74699: LD_INT 0
74701: PUSH
74702: EMPTY
74703: LIST
74704: LIST
74705: PUSH
74706: LD_INT 2
74708: NEG
74709: PUSH
74710: LD_INT 1
74712: NEG
74713: PUSH
74714: EMPTY
74715: LIST
74716: LIST
74717: PUSH
74718: LD_INT 2
74720: NEG
74721: PUSH
74722: LD_INT 2
74724: NEG
74725: PUSH
74726: EMPTY
74727: LIST
74728: LIST
74729: PUSH
74730: EMPTY
74731: LIST
74732: LIST
74733: LIST
74734: LIST
74735: LIST
74736: LIST
74737: LIST
74738: LIST
74739: LIST
74740: LIST
74741: LIST
74742: LIST
74743: LIST
74744: LIST
74745: LIST
74746: LIST
74747: LIST
74748: LIST
74749: LIST
74750: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74751: LD_ADDR_VAR 0 59
74755: PUSH
74756: LD_INT 0
74758: PUSH
74759: LD_INT 0
74761: PUSH
74762: EMPTY
74763: LIST
74764: LIST
74765: PUSH
74766: LD_INT 0
74768: PUSH
74769: LD_INT 1
74771: NEG
74772: PUSH
74773: EMPTY
74774: LIST
74775: LIST
74776: PUSH
74777: LD_INT 1
74779: PUSH
74780: LD_INT 0
74782: PUSH
74783: EMPTY
74784: LIST
74785: LIST
74786: PUSH
74787: LD_INT 1
74789: PUSH
74790: LD_INT 1
74792: PUSH
74793: EMPTY
74794: LIST
74795: LIST
74796: PUSH
74797: LD_INT 0
74799: PUSH
74800: LD_INT 1
74802: PUSH
74803: EMPTY
74804: LIST
74805: LIST
74806: PUSH
74807: LD_INT 1
74809: NEG
74810: PUSH
74811: LD_INT 0
74813: PUSH
74814: EMPTY
74815: LIST
74816: LIST
74817: PUSH
74818: LD_INT 1
74820: NEG
74821: PUSH
74822: LD_INT 1
74824: NEG
74825: PUSH
74826: EMPTY
74827: LIST
74828: LIST
74829: PUSH
74830: EMPTY
74831: LIST
74832: LIST
74833: LIST
74834: LIST
74835: LIST
74836: LIST
74837: LIST
74838: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74839: LD_ADDR_VAR 0 60
74843: PUSH
74844: LD_INT 0
74846: PUSH
74847: LD_INT 0
74849: PUSH
74850: EMPTY
74851: LIST
74852: LIST
74853: PUSH
74854: LD_INT 0
74856: PUSH
74857: LD_INT 1
74859: NEG
74860: PUSH
74861: EMPTY
74862: LIST
74863: LIST
74864: PUSH
74865: LD_INT 1
74867: PUSH
74868: LD_INT 0
74870: PUSH
74871: EMPTY
74872: LIST
74873: LIST
74874: PUSH
74875: LD_INT 1
74877: PUSH
74878: LD_INT 1
74880: PUSH
74881: EMPTY
74882: LIST
74883: LIST
74884: PUSH
74885: LD_INT 0
74887: PUSH
74888: LD_INT 1
74890: PUSH
74891: EMPTY
74892: LIST
74893: LIST
74894: PUSH
74895: LD_INT 1
74897: NEG
74898: PUSH
74899: LD_INT 0
74901: PUSH
74902: EMPTY
74903: LIST
74904: LIST
74905: PUSH
74906: LD_INT 1
74908: NEG
74909: PUSH
74910: LD_INT 1
74912: NEG
74913: PUSH
74914: EMPTY
74915: LIST
74916: LIST
74917: PUSH
74918: EMPTY
74919: LIST
74920: LIST
74921: LIST
74922: LIST
74923: LIST
74924: LIST
74925: LIST
74926: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74927: LD_ADDR_VAR 0 61
74931: PUSH
74932: LD_INT 0
74934: PUSH
74935: LD_INT 0
74937: PUSH
74938: EMPTY
74939: LIST
74940: LIST
74941: PUSH
74942: LD_INT 0
74944: PUSH
74945: LD_INT 1
74947: NEG
74948: PUSH
74949: EMPTY
74950: LIST
74951: LIST
74952: PUSH
74953: LD_INT 1
74955: PUSH
74956: LD_INT 0
74958: PUSH
74959: EMPTY
74960: LIST
74961: LIST
74962: PUSH
74963: LD_INT 1
74965: PUSH
74966: LD_INT 1
74968: PUSH
74969: EMPTY
74970: LIST
74971: LIST
74972: PUSH
74973: LD_INT 0
74975: PUSH
74976: LD_INT 1
74978: PUSH
74979: EMPTY
74980: LIST
74981: LIST
74982: PUSH
74983: LD_INT 1
74985: NEG
74986: PUSH
74987: LD_INT 0
74989: PUSH
74990: EMPTY
74991: LIST
74992: LIST
74993: PUSH
74994: LD_INT 1
74996: NEG
74997: PUSH
74998: LD_INT 1
75000: NEG
75001: PUSH
75002: EMPTY
75003: LIST
75004: LIST
75005: PUSH
75006: EMPTY
75007: LIST
75008: LIST
75009: LIST
75010: LIST
75011: LIST
75012: LIST
75013: LIST
75014: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75015: LD_ADDR_VAR 0 62
75019: PUSH
75020: LD_INT 0
75022: PUSH
75023: LD_INT 0
75025: PUSH
75026: EMPTY
75027: LIST
75028: LIST
75029: PUSH
75030: LD_INT 0
75032: PUSH
75033: LD_INT 1
75035: NEG
75036: PUSH
75037: EMPTY
75038: LIST
75039: LIST
75040: PUSH
75041: LD_INT 1
75043: PUSH
75044: LD_INT 0
75046: PUSH
75047: EMPTY
75048: LIST
75049: LIST
75050: PUSH
75051: LD_INT 1
75053: PUSH
75054: LD_INT 1
75056: PUSH
75057: EMPTY
75058: LIST
75059: LIST
75060: PUSH
75061: LD_INT 0
75063: PUSH
75064: LD_INT 1
75066: PUSH
75067: EMPTY
75068: LIST
75069: LIST
75070: PUSH
75071: LD_INT 1
75073: NEG
75074: PUSH
75075: LD_INT 0
75077: PUSH
75078: EMPTY
75079: LIST
75080: LIST
75081: PUSH
75082: LD_INT 1
75084: NEG
75085: PUSH
75086: LD_INT 1
75088: NEG
75089: PUSH
75090: EMPTY
75091: LIST
75092: LIST
75093: PUSH
75094: EMPTY
75095: LIST
75096: LIST
75097: LIST
75098: LIST
75099: LIST
75100: LIST
75101: LIST
75102: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75103: LD_ADDR_VAR 0 63
75107: PUSH
75108: LD_INT 0
75110: PUSH
75111: LD_INT 0
75113: PUSH
75114: EMPTY
75115: LIST
75116: LIST
75117: PUSH
75118: LD_INT 0
75120: PUSH
75121: LD_INT 1
75123: NEG
75124: PUSH
75125: EMPTY
75126: LIST
75127: LIST
75128: PUSH
75129: LD_INT 1
75131: PUSH
75132: LD_INT 0
75134: PUSH
75135: EMPTY
75136: LIST
75137: LIST
75138: PUSH
75139: LD_INT 1
75141: PUSH
75142: LD_INT 1
75144: PUSH
75145: EMPTY
75146: LIST
75147: LIST
75148: PUSH
75149: LD_INT 0
75151: PUSH
75152: LD_INT 1
75154: PUSH
75155: EMPTY
75156: LIST
75157: LIST
75158: PUSH
75159: LD_INT 1
75161: NEG
75162: PUSH
75163: LD_INT 0
75165: PUSH
75166: EMPTY
75167: LIST
75168: LIST
75169: PUSH
75170: LD_INT 1
75172: NEG
75173: PUSH
75174: LD_INT 1
75176: NEG
75177: PUSH
75178: EMPTY
75179: LIST
75180: LIST
75181: PUSH
75182: EMPTY
75183: LIST
75184: LIST
75185: LIST
75186: LIST
75187: LIST
75188: LIST
75189: LIST
75190: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75191: LD_ADDR_VAR 0 64
75195: PUSH
75196: LD_INT 0
75198: PUSH
75199: LD_INT 0
75201: PUSH
75202: EMPTY
75203: LIST
75204: LIST
75205: PUSH
75206: LD_INT 0
75208: PUSH
75209: LD_INT 1
75211: NEG
75212: PUSH
75213: EMPTY
75214: LIST
75215: LIST
75216: PUSH
75217: LD_INT 1
75219: PUSH
75220: LD_INT 0
75222: PUSH
75223: EMPTY
75224: LIST
75225: LIST
75226: PUSH
75227: LD_INT 1
75229: PUSH
75230: LD_INT 1
75232: PUSH
75233: EMPTY
75234: LIST
75235: LIST
75236: PUSH
75237: LD_INT 0
75239: PUSH
75240: LD_INT 1
75242: PUSH
75243: EMPTY
75244: LIST
75245: LIST
75246: PUSH
75247: LD_INT 1
75249: NEG
75250: PUSH
75251: LD_INT 0
75253: PUSH
75254: EMPTY
75255: LIST
75256: LIST
75257: PUSH
75258: LD_INT 1
75260: NEG
75261: PUSH
75262: LD_INT 1
75264: NEG
75265: PUSH
75266: EMPTY
75267: LIST
75268: LIST
75269: PUSH
75270: EMPTY
75271: LIST
75272: LIST
75273: LIST
75274: LIST
75275: LIST
75276: LIST
75277: LIST
75278: ST_TO_ADDR
// end ; 1 :
75279: GO 81176
75281: LD_INT 1
75283: DOUBLE
75284: EQUAL
75285: IFTRUE 75289
75287: GO 77912
75289: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
75290: LD_ADDR_VAR 0 11
75294: PUSH
75295: LD_INT 1
75297: NEG
75298: PUSH
75299: LD_INT 3
75301: NEG
75302: PUSH
75303: EMPTY
75304: LIST
75305: LIST
75306: PUSH
75307: LD_INT 0
75309: PUSH
75310: LD_INT 3
75312: NEG
75313: PUSH
75314: EMPTY
75315: LIST
75316: LIST
75317: PUSH
75318: LD_INT 1
75320: PUSH
75321: LD_INT 2
75323: NEG
75324: PUSH
75325: EMPTY
75326: LIST
75327: LIST
75328: PUSH
75329: EMPTY
75330: LIST
75331: LIST
75332: LIST
75333: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
75334: LD_ADDR_VAR 0 12
75338: PUSH
75339: LD_INT 2
75341: PUSH
75342: LD_INT 1
75344: NEG
75345: PUSH
75346: EMPTY
75347: LIST
75348: LIST
75349: PUSH
75350: LD_INT 3
75352: PUSH
75353: LD_INT 0
75355: PUSH
75356: EMPTY
75357: LIST
75358: LIST
75359: PUSH
75360: LD_INT 3
75362: PUSH
75363: LD_INT 1
75365: PUSH
75366: EMPTY
75367: LIST
75368: LIST
75369: PUSH
75370: EMPTY
75371: LIST
75372: LIST
75373: LIST
75374: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
75375: LD_ADDR_VAR 0 13
75379: PUSH
75380: LD_INT 3
75382: PUSH
75383: LD_INT 2
75385: PUSH
75386: EMPTY
75387: LIST
75388: LIST
75389: PUSH
75390: LD_INT 3
75392: PUSH
75393: LD_INT 3
75395: PUSH
75396: EMPTY
75397: LIST
75398: LIST
75399: PUSH
75400: LD_INT 2
75402: PUSH
75403: LD_INT 3
75405: PUSH
75406: EMPTY
75407: LIST
75408: LIST
75409: PUSH
75410: EMPTY
75411: LIST
75412: LIST
75413: LIST
75414: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
75415: LD_ADDR_VAR 0 14
75419: PUSH
75420: LD_INT 1
75422: PUSH
75423: LD_INT 3
75425: PUSH
75426: EMPTY
75427: LIST
75428: LIST
75429: PUSH
75430: LD_INT 0
75432: PUSH
75433: LD_INT 3
75435: PUSH
75436: EMPTY
75437: LIST
75438: LIST
75439: PUSH
75440: LD_INT 1
75442: NEG
75443: PUSH
75444: LD_INT 2
75446: PUSH
75447: EMPTY
75448: LIST
75449: LIST
75450: PUSH
75451: EMPTY
75452: LIST
75453: LIST
75454: LIST
75455: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
75456: LD_ADDR_VAR 0 15
75460: PUSH
75461: LD_INT 2
75463: NEG
75464: PUSH
75465: LD_INT 1
75467: PUSH
75468: EMPTY
75469: LIST
75470: LIST
75471: PUSH
75472: LD_INT 3
75474: NEG
75475: PUSH
75476: LD_INT 0
75478: PUSH
75479: EMPTY
75480: LIST
75481: LIST
75482: PUSH
75483: LD_INT 3
75485: NEG
75486: PUSH
75487: LD_INT 1
75489: NEG
75490: PUSH
75491: EMPTY
75492: LIST
75493: LIST
75494: PUSH
75495: EMPTY
75496: LIST
75497: LIST
75498: LIST
75499: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75500: LD_ADDR_VAR 0 16
75504: PUSH
75505: LD_INT 2
75507: NEG
75508: PUSH
75509: LD_INT 3
75511: NEG
75512: PUSH
75513: EMPTY
75514: LIST
75515: LIST
75516: PUSH
75517: LD_INT 3
75519: NEG
75520: PUSH
75521: LD_INT 2
75523: NEG
75524: PUSH
75525: EMPTY
75526: LIST
75527: LIST
75528: PUSH
75529: LD_INT 3
75531: NEG
75532: PUSH
75533: LD_INT 3
75535: NEG
75536: PUSH
75537: EMPTY
75538: LIST
75539: LIST
75540: PUSH
75541: EMPTY
75542: LIST
75543: LIST
75544: LIST
75545: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
75546: LD_ADDR_VAR 0 17
75550: PUSH
75551: LD_INT 1
75553: NEG
75554: PUSH
75555: LD_INT 3
75557: NEG
75558: PUSH
75559: EMPTY
75560: LIST
75561: LIST
75562: PUSH
75563: LD_INT 0
75565: PUSH
75566: LD_INT 3
75568: NEG
75569: PUSH
75570: EMPTY
75571: LIST
75572: LIST
75573: PUSH
75574: LD_INT 1
75576: PUSH
75577: LD_INT 2
75579: NEG
75580: PUSH
75581: EMPTY
75582: LIST
75583: LIST
75584: PUSH
75585: EMPTY
75586: LIST
75587: LIST
75588: LIST
75589: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
75590: LD_ADDR_VAR 0 18
75594: PUSH
75595: LD_INT 2
75597: PUSH
75598: LD_INT 1
75600: NEG
75601: PUSH
75602: EMPTY
75603: LIST
75604: LIST
75605: PUSH
75606: LD_INT 3
75608: PUSH
75609: LD_INT 0
75611: PUSH
75612: EMPTY
75613: LIST
75614: LIST
75615: PUSH
75616: LD_INT 3
75618: PUSH
75619: LD_INT 1
75621: PUSH
75622: EMPTY
75623: LIST
75624: LIST
75625: PUSH
75626: EMPTY
75627: LIST
75628: LIST
75629: LIST
75630: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
75631: LD_ADDR_VAR 0 19
75635: PUSH
75636: LD_INT 3
75638: PUSH
75639: LD_INT 2
75641: PUSH
75642: EMPTY
75643: LIST
75644: LIST
75645: PUSH
75646: LD_INT 3
75648: PUSH
75649: LD_INT 3
75651: PUSH
75652: EMPTY
75653: LIST
75654: LIST
75655: PUSH
75656: LD_INT 2
75658: PUSH
75659: LD_INT 3
75661: PUSH
75662: EMPTY
75663: LIST
75664: LIST
75665: PUSH
75666: EMPTY
75667: LIST
75668: LIST
75669: LIST
75670: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
75671: LD_ADDR_VAR 0 20
75675: PUSH
75676: LD_INT 1
75678: PUSH
75679: LD_INT 3
75681: PUSH
75682: EMPTY
75683: LIST
75684: LIST
75685: PUSH
75686: LD_INT 0
75688: PUSH
75689: LD_INT 3
75691: PUSH
75692: EMPTY
75693: LIST
75694: LIST
75695: PUSH
75696: LD_INT 1
75698: NEG
75699: PUSH
75700: LD_INT 2
75702: PUSH
75703: EMPTY
75704: LIST
75705: LIST
75706: PUSH
75707: EMPTY
75708: LIST
75709: LIST
75710: LIST
75711: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
75712: LD_ADDR_VAR 0 21
75716: PUSH
75717: LD_INT 2
75719: NEG
75720: PUSH
75721: LD_INT 1
75723: PUSH
75724: EMPTY
75725: LIST
75726: LIST
75727: PUSH
75728: LD_INT 3
75730: NEG
75731: PUSH
75732: LD_INT 0
75734: PUSH
75735: EMPTY
75736: LIST
75737: LIST
75738: PUSH
75739: LD_INT 3
75741: NEG
75742: PUSH
75743: LD_INT 1
75745: NEG
75746: PUSH
75747: EMPTY
75748: LIST
75749: LIST
75750: PUSH
75751: EMPTY
75752: LIST
75753: LIST
75754: LIST
75755: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75756: LD_ADDR_VAR 0 22
75760: PUSH
75761: LD_INT 2
75763: NEG
75764: PUSH
75765: LD_INT 3
75767: NEG
75768: PUSH
75769: EMPTY
75770: LIST
75771: LIST
75772: PUSH
75773: LD_INT 3
75775: NEG
75776: PUSH
75777: LD_INT 2
75779: NEG
75780: PUSH
75781: EMPTY
75782: LIST
75783: LIST
75784: PUSH
75785: LD_INT 3
75787: NEG
75788: PUSH
75789: LD_INT 3
75791: NEG
75792: PUSH
75793: EMPTY
75794: LIST
75795: LIST
75796: PUSH
75797: EMPTY
75798: LIST
75799: LIST
75800: LIST
75801: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
75802: LD_ADDR_VAR 0 23
75806: PUSH
75807: LD_INT 0
75809: PUSH
75810: LD_INT 3
75812: NEG
75813: PUSH
75814: EMPTY
75815: LIST
75816: LIST
75817: PUSH
75818: LD_INT 1
75820: NEG
75821: PUSH
75822: LD_INT 4
75824: NEG
75825: PUSH
75826: EMPTY
75827: LIST
75828: LIST
75829: PUSH
75830: LD_INT 1
75832: PUSH
75833: LD_INT 3
75835: NEG
75836: PUSH
75837: EMPTY
75838: LIST
75839: LIST
75840: PUSH
75841: EMPTY
75842: LIST
75843: LIST
75844: LIST
75845: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
75846: LD_ADDR_VAR 0 24
75850: PUSH
75851: LD_INT 3
75853: PUSH
75854: LD_INT 0
75856: PUSH
75857: EMPTY
75858: LIST
75859: LIST
75860: PUSH
75861: LD_INT 3
75863: PUSH
75864: LD_INT 1
75866: NEG
75867: PUSH
75868: EMPTY
75869: LIST
75870: LIST
75871: PUSH
75872: LD_INT 4
75874: PUSH
75875: LD_INT 1
75877: PUSH
75878: EMPTY
75879: LIST
75880: LIST
75881: PUSH
75882: EMPTY
75883: LIST
75884: LIST
75885: LIST
75886: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
75887: LD_ADDR_VAR 0 25
75891: PUSH
75892: LD_INT 3
75894: PUSH
75895: LD_INT 3
75897: PUSH
75898: EMPTY
75899: LIST
75900: LIST
75901: PUSH
75902: LD_INT 4
75904: PUSH
75905: LD_INT 3
75907: PUSH
75908: EMPTY
75909: LIST
75910: LIST
75911: PUSH
75912: LD_INT 3
75914: PUSH
75915: LD_INT 4
75917: PUSH
75918: EMPTY
75919: LIST
75920: LIST
75921: PUSH
75922: EMPTY
75923: LIST
75924: LIST
75925: LIST
75926: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
75927: LD_ADDR_VAR 0 26
75931: PUSH
75932: LD_INT 0
75934: PUSH
75935: LD_INT 3
75937: PUSH
75938: EMPTY
75939: LIST
75940: LIST
75941: PUSH
75942: LD_INT 1
75944: PUSH
75945: LD_INT 4
75947: PUSH
75948: EMPTY
75949: LIST
75950: LIST
75951: PUSH
75952: LD_INT 1
75954: NEG
75955: PUSH
75956: LD_INT 3
75958: PUSH
75959: EMPTY
75960: LIST
75961: LIST
75962: PUSH
75963: EMPTY
75964: LIST
75965: LIST
75966: LIST
75967: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
75968: LD_ADDR_VAR 0 27
75972: PUSH
75973: LD_INT 3
75975: NEG
75976: PUSH
75977: LD_INT 0
75979: PUSH
75980: EMPTY
75981: LIST
75982: LIST
75983: PUSH
75984: LD_INT 3
75986: NEG
75987: PUSH
75988: LD_INT 1
75990: PUSH
75991: EMPTY
75992: LIST
75993: LIST
75994: PUSH
75995: LD_INT 4
75997: NEG
75998: PUSH
75999: LD_INT 1
76001: NEG
76002: PUSH
76003: EMPTY
76004: LIST
76005: LIST
76006: PUSH
76007: EMPTY
76008: LIST
76009: LIST
76010: LIST
76011: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
76012: LD_ADDR_VAR 0 28
76016: PUSH
76017: LD_INT 3
76019: NEG
76020: PUSH
76021: LD_INT 3
76023: NEG
76024: PUSH
76025: EMPTY
76026: LIST
76027: LIST
76028: PUSH
76029: LD_INT 3
76031: NEG
76032: PUSH
76033: LD_INT 4
76035: NEG
76036: PUSH
76037: EMPTY
76038: LIST
76039: LIST
76040: PUSH
76041: LD_INT 4
76043: NEG
76044: PUSH
76045: LD_INT 3
76047: NEG
76048: PUSH
76049: EMPTY
76050: LIST
76051: LIST
76052: PUSH
76053: EMPTY
76054: LIST
76055: LIST
76056: LIST
76057: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
76058: LD_ADDR_VAR 0 29
76062: PUSH
76063: LD_INT 1
76065: NEG
76066: PUSH
76067: LD_INT 3
76069: NEG
76070: PUSH
76071: EMPTY
76072: LIST
76073: LIST
76074: PUSH
76075: LD_INT 0
76077: PUSH
76078: LD_INT 3
76080: NEG
76081: PUSH
76082: EMPTY
76083: LIST
76084: LIST
76085: PUSH
76086: LD_INT 1
76088: PUSH
76089: LD_INT 2
76091: NEG
76092: PUSH
76093: EMPTY
76094: LIST
76095: LIST
76096: PUSH
76097: LD_INT 1
76099: NEG
76100: PUSH
76101: LD_INT 4
76103: NEG
76104: PUSH
76105: EMPTY
76106: LIST
76107: LIST
76108: PUSH
76109: LD_INT 0
76111: PUSH
76112: LD_INT 4
76114: NEG
76115: PUSH
76116: EMPTY
76117: LIST
76118: LIST
76119: PUSH
76120: LD_INT 1
76122: PUSH
76123: LD_INT 3
76125: NEG
76126: PUSH
76127: EMPTY
76128: LIST
76129: LIST
76130: PUSH
76131: LD_INT 1
76133: NEG
76134: PUSH
76135: LD_INT 5
76137: NEG
76138: PUSH
76139: EMPTY
76140: LIST
76141: LIST
76142: PUSH
76143: LD_INT 0
76145: PUSH
76146: LD_INT 5
76148: NEG
76149: PUSH
76150: EMPTY
76151: LIST
76152: LIST
76153: PUSH
76154: LD_INT 1
76156: PUSH
76157: LD_INT 4
76159: NEG
76160: PUSH
76161: EMPTY
76162: LIST
76163: LIST
76164: PUSH
76165: LD_INT 1
76167: NEG
76168: PUSH
76169: LD_INT 6
76171: NEG
76172: PUSH
76173: EMPTY
76174: LIST
76175: LIST
76176: PUSH
76177: LD_INT 0
76179: PUSH
76180: LD_INT 6
76182: NEG
76183: PUSH
76184: EMPTY
76185: LIST
76186: LIST
76187: PUSH
76188: LD_INT 1
76190: PUSH
76191: LD_INT 5
76193: NEG
76194: PUSH
76195: EMPTY
76196: LIST
76197: LIST
76198: PUSH
76199: EMPTY
76200: LIST
76201: LIST
76202: LIST
76203: LIST
76204: LIST
76205: LIST
76206: LIST
76207: LIST
76208: LIST
76209: LIST
76210: LIST
76211: LIST
76212: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
76213: LD_ADDR_VAR 0 30
76217: PUSH
76218: LD_INT 2
76220: PUSH
76221: LD_INT 1
76223: NEG
76224: PUSH
76225: EMPTY
76226: LIST
76227: LIST
76228: PUSH
76229: LD_INT 3
76231: PUSH
76232: LD_INT 0
76234: PUSH
76235: EMPTY
76236: LIST
76237: LIST
76238: PUSH
76239: LD_INT 3
76241: PUSH
76242: LD_INT 1
76244: PUSH
76245: EMPTY
76246: LIST
76247: LIST
76248: PUSH
76249: LD_INT 3
76251: PUSH
76252: LD_INT 1
76254: NEG
76255: PUSH
76256: EMPTY
76257: LIST
76258: LIST
76259: PUSH
76260: LD_INT 4
76262: PUSH
76263: LD_INT 0
76265: PUSH
76266: EMPTY
76267: LIST
76268: LIST
76269: PUSH
76270: LD_INT 4
76272: PUSH
76273: LD_INT 1
76275: PUSH
76276: EMPTY
76277: LIST
76278: LIST
76279: PUSH
76280: LD_INT 4
76282: PUSH
76283: LD_INT 1
76285: NEG
76286: PUSH
76287: EMPTY
76288: LIST
76289: LIST
76290: PUSH
76291: LD_INT 5
76293: PUSH
76294: LD_INT 0
76296: PUSH
76297: EMPTY
76298: LIST
76299: LIST
76300: PUSH
76301: LD_INT 5
76303: PUSH
76304: LD_INT 1
76306: PUSH
76307: EMPTY
76308: LIST
76309: LIST
76310: PUSH
76311: LD_INT 5
76313: PUSH
76314: LD_INT 1
76316: NEG
76317: PUSH
76318: EMPTY
76319: LIST
76320: LIST
76321: PUSH
76322: LD_INT 6
76324: PUSH
76325: LD_INT 0
76327: PUSH
76328: EMPTY
76329: LIST
76330: LIST
76331: PUSH
76332: LD_INT 6
76334: PUSH
76335: LD_INT 1
76337: PUSH
76338: EMPTY
76339: LIST
76340: LIST
76341: PUSH
76342: EMPTY
76343: LIST
76344: LIST
76345: LIST
76346: LIST
76347: LIST
76348: LIST
76349: LIST
76350: LIST
76351: LIST
76352: LIST
76353: LIST
76354: LIST
76355: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
76356: LD_ADDR_VAR 0 31
76360: PUSH
76361: LD_INT 3
76363: PUSH
76364: LD_INT 2
76366: PUSH
76367: EMPTY
76368: LIST
76369: LIST
76370: PUSH
76371: LD_INT 3
76373: PUSH
76374: LD_INT 3
76376: PUSH
76377: EMPTY
76378: LIST
76379: LIST
76380: PUSH
76381: LD_INT 2
76383: PUSH
76384: LD_INT 3
76386: PUSH
76387: EMPTY
76388: LIST
76389: LIST
76390: PUSH
76391: LD_INT 4
76393: PUSH
76394: LD_INT 3
76396: PUSH
76397: EMPTY
76398: LIST
76399: LIST
76400: PUSH
76401: LD_INT 4
76403: PUSH
76404: LD_INT 4
76406: PUSH
76407: EMPTY
76408: LIST
76409: LIST
76410: PUSH
76411: LD_INT 3
76413: PUSH
76414: LD_INT 4
76416: PUSH
76417: EMPTY
76418: LIST
76419: LIST
76420: PUSH
76421: LD_INT 5
76423: PUSH
76424: LD_INT 4
76426: PUSH
76427: EMPTY
76428: LIST
76429: LIST
76430: PUSH
76431: LD_INT 5
76433: PUSH
76434: LD_INT 5
76436: PUSH
76437: EMPTY
76438: LIST
76439: LIST
76440: PUSH
76441: LD_INT 4
76443: PUSH
76444: LD_INT 5
76446: PUSH
76447: EMPTY
76448: LIST
76449: LIST
76450: PUSH
76451: LD_INT 6
76453: PUSH
76454: LD_INT 5
76456: PUSH
76457: EMPTY
76458: LIST
76459: LIST
76460: PUSH
76461: LD_INT 6
76463: PUSH
76464: LD_INT 6
76466: PUSH
76467: EMPTY
76468: LIST
76469: LIST
76470: PUSH
76471: LD_INT 5
76473: PUSH
76474: LD_INT 6
76476: PUSH
76477: EMPTY
76478: LIST
76479: LIST
76480: PUSH
76481: EMPTY
76482: LIST
76483: LIST
76484: LIST
76485: LIST
76486: LIST
76487: LIST
76488: LIST
76489: LIST
76490: LIST
76491: LIST
76492: LIST
76493: LIST
76494: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
76495: LD_ADDR_VAR 0 32
76499: PUSH
76500: LD_INT 1
76502: PUSH
76503: LD_INT 3
76505: PUSH
76506: EMPTY
76507: LIST
76508: LIST
76509: PUSH
76510: LD_INT 0
76512: PUSH
76513: LD_INT 3
76515: PUSH
76516: EMPTY
76517: LIST
76518: LIST
76519: PUSH
76520: LD_INT 1
76522: NEG
76523: PUSH
76524: LD_INT 2
76526: PUSH
76527: EMPTY
76528: LIST
76529: LIST
76530: PUSH
76531: LD_INT 1
76533: PUSH
76534: LD_INT 4
76536: PUSH
76537: EMPTY
76538: LIST
76539: LIST
76540: PUSH
76541: LD_INT 0
76543: PUSH
76544: LD_INT 4
76546: PUSH
76547: EMPTY
76548: LIST
76549: LIST
76550: PUSH
76551: LD_INT 1
76553: NEG
76554: PUSH
76555: LD_INT 3
76557: PUSH
76558: EMPTY
76559: LIST
76560: LIST
76561: PUSH
76562: LD_INT 1
76564: PUSH
76565: LD_INT 5
76567: PUSH
76568: EMPTY
76569: LIST
76570: LIST
76571: PUSH
76572: LD_INT 0
76574: PUSH
76575: LD_INT 5
76577: PUSH
76578: EMPTY
76579: LIST
76580: LIST
76581: PUSH
76582: LD_INT 1
76584: NEG
76585: PUSH
76586: LD_INT 4
76588: PUSH
76589: EMPTY
76590: LIST
76591: LIST
76592: PUSH
76593: LD_INT 1
76595: PUSH
76596: LD_INT 6
76598: PUSH
76599: EMPTY
76600: LIST
76601: LIST
76602: PUSH
76603: LD_INT 0
76605: PUSH
76606: LD_INT 6
76608: PUSH
76609: EMPTY
76610: LIST
76611: LIST
76612: PUSH
76613: LD_INT 1
76615: NEG
76616: PUSH
76617: LD_INT 5
76619: PUSH
76620: EMPTY
76621: LIST
76622: LIST
76623: PUSH
76624: EMPTY
76625: LIST
76626: LIST
76627: LIST
76628: LIST
76629: LIST
76630: LIST
76631: LIST
76632: LIST
76633: LIST
76634: LIST
76635: LIST
76636: LIST
76637: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
76638: LD_ADDR_VAR 0 33
76642: PUSH
76643: LD_INT 2
76645: NEG
76646: PUSH
76647: LD_INT 1
76649: PUSH
76650: EMPTY
76651: LIST
76652: LIST
76653: PUSH
76654: LD_INT 3
76656: NEG
76657: PUSH
76658: LD_INT 0
76660: PUSH
76661: EMPTY
76662: LIST
76663: LIST
76664: PUSH
76665: LD_INT 3
76667: NEG
76668: PUSH
76669: LD_INT 1
76671: NEG
76672: PUSH
76673: EMPTY
76674: LIST
76675: LIST
76676: PUSH
76677: LD_INT 3
76679: NEG
76680: PUSH
76681: LD_INT 1
76683: PUSH
76684: EMPTY
76685: LIST
76686: LIST
76687: PUSH
76688: LD_INT 4
76690: NEG
76691: PUSH
76692: LD_INT 0
76694: PUSH
76695: EMPTY
76696: LIST
76697: LIST
76698: PUSH
76699: LD_INT 4
76701: NEG
76702: PUSH
76703: LD_INT 1
76705: NEG
76706: PUSH
76707: EMPTY
76708: LIST
76709: LIST
76710: PUSH
76711: LD_INT 4
76713: NEG
76714: PUSH
76715: LD_INT 1
76717: PUSH
76718: EMPTY
76719: LIST
76720: LIST
76721: PUSH
76722: LD_INT 5
76724: NEG
76725: PUSH
76726: LD_INT 0
76728: PUSH
76729: EMPTY
76730: LIST
76731: LIST
76732: PUSH
76733: LD_INT 5
76735: NEG
76736: PUSH
76737: LD_INT 1
76739: NEG
76740: PUSH
76741: EMPTY
76742: LIST
76743: LIST
76744: PUSH
76745: LD_INT 5
76747: NEG
76748: PUSH
76749: LD_INT 1
76751: PUSH
76752: EMPTY
76753: LIST
76754: LIST
76755: PUSH
76756: LD_INT 6
76758: NEG
76759: PUSH
76760: LD_INT 0
76762: PUSH
76763: EMPTY
76764: LIST
76765: LIST
76766: PUSH
76767: LD_INT 6
76769: NEG
76770: PUSH
76771: LD_INT 1
76773: NEG
76774: PUSH
76775: EMPTY
76776: LIST
76777: LIST
76778: PUSH
76779: EMPTY
76780: LIST
76781: LIST
76782: LIST
76783: LIST
76784: LIST
76785: LIST
76786: LIST
76787: LIST
76788: LIST
76789: LIST
76790: LIST
76791: LIST
76792: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
76793: LD_ADDR_VAR 0 34
76797: PUSH
76798: LD_INT 2
76800: NEG
76801: PUSH
76802: LD_INT 3
76804: NEG
76805: PUSH
76806: EMPTY
76807: LIST
76808: LIST
76809: PUSH
76810: LD_INT 3
76812: NEG
76813: PUSH
76814: LD_INT 2
76816: NEG
76817: PUSH
76818: EMPTY
76819: LIST
76820: LIST
76821: PUSH
76822: LD_INT 3
76824: NEG
76825: PUSH
76826: LD_INT 3
76828: NEG
76829: PUSH
76830: EMPTY
76831: LIST
76832: LIST
76833: PUSH
76834: LD_INT 3
76836: NEG
76837: PUSH
76838: LD_INT 4
76840: NEG
76841: PUSH
76842: EMPTY
76843: LIST
76844: LIST
76845: PUSH
76846: LD_INT 4
76848: NEG
76849: PUSH
76850: LD_INT 3
76852: NEG
76853: PUSH
76854: EMPTY
76855: LIST
76856: LIST
76857: PUSH
76858: LD_INT 4
76860: NEG
76861: PUSH
76862: LD_INT 4
76864: NEG
76865: PUSH
76866: EMPTY
76867: LIST
76868: LIST
76869: PUSH
76870: LD_INT 4
76872: NEG
76873: PUSH
76874: LD_INT 5
76876: NEG
76877: PUSH
76878: EMPTY
76879: LIST
76880: LIST
76881: PUSH
76882: LD_INT 5
76884: NEG
76885: PUSH
76886: LD_INT 4
76888: NEG
76889: PUSH
76890: EMPTY
76891: LIST
76892: LIST
76893: PUSH
76894: LD_INT 5
76896: NEG
76897: PUSH
76898: LD_INT 5
76900: NEG
76901: PUSH
76902: EMPTY
76903: LIST
76904: LIST
76905: PUSH
76906: LD_INT 5
76908: NEG
76909: PUSH
76910: LD_INT 6
76912: NEG
76913: PUSH
76914: EMPTY
76915: LIST
76916: LIST
76917: PUSH
76918: LD_INT 6
76920: NEG
76921: PUSH
76922: LD_INT 5
76924: NEG
76925: PUSH
76926: EMPTY
76927: LIST
76928: LIST
76929: PUSH
76930: LD_INT 6
76932: NEG
76933: PUSH
76934: LD_INT 6
76936: NEG
76937: PUSH
76938: EMPTY
76939: LIST
76940: LIST
76941: PUSH
76942: EMPTY
76943: LIST
76944: LIST
76945: LIST
76946: LIST
76947: LIST
76948: LIST
76949: LIST
76950: LIST
76951: LIST
76952: LIST
76953: LIST
76954: LIST
76955: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
76956: LD_ADDR_VAR 0 41
76960: PUSH
76961: LD_INT 0
76963: PUSH
76964: LD_INT 2
76966: NEG
76967: PUSH
76968: EMPTY
76969: LIST
76970: LIST
76971: PUSH
76972: LD_INT 1
76974: NEG
76975: PUSH
76976: LD_INT 3
76978: NEG
76979: PUSH
76980: EMPTY
76981: LIST
76982: LIST
76983: PUSH
76984: LD_INT 1
76986: PUSH
76987: LD_INT 2
76989: NEG
76990: PUSH
76991: EMPTY
76992: LIST
76993: LIST
76994: PUSH
76995: EMPTY
76996: LIST
76997: LIST
76998: LIST
76999: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
77000: LD_ADDR_VAR 0 42
77004: PUSH
77005: LD_INT 2
77007: PUSH
77008: LD_INT 0
77010: PUSH
77011: EMPTY
77012: LIST
77013: LIST
77014: PUSH
77015: LD_INT 2
77017: PUSH
77018: LD_INT 1
77020: NEG
77021: PUSH
77022: EMPTY
77023: LIST
77024: LIST
77025: PUSH
77026: LD_INT 3
77028: PUSH
77029: LD_INT 1
77031: PUSH
77032: EMPTY
77033: LIST
77034: LIST
77035: PUSH
77036: EMPTY
77037: LIST
77038: LIST
77039: LIST
77040: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
77041: LD_ADDR_VAR 0 43
77045: PUSH
77046: LD_INT 2
77048: PUSH
77049: LD_INT 2
77051: PUSH
77052: EMPTY
77053: LIST
77054: LIST
77055: PUSH
77056: LD_INT 3
77058: PUSH
77059: LD_INT 2
77061: PUSH
77062: EMPTY
77063: LIST
77064: LIST
77065: PUSH
77066: LD_INT 2
77068: PUSH
77069: LD_INT 3
77071: PUSH
77072: EMPTY
77073: LIST
77074: LIST
77075: PUSH
77076: EMPTY
77077: LIST
77078: LIST
77079: LIST
77080: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
77081: LD_ADDR_VAR 0 44
77085: PUSH
77086: LD_INT 0
77088: PUSH
77089: LD_INT 2
77091: PUSH
77092: EMPTY
77093: LIST
77094: LIST
77095: PUSH
77096: LD_INT 1
77098: PUSH
77099: LD_INT 3
77101: PUSH
77102: EMPTY
77103: LIST
77104: LIST
77105: PUSH
77106: LD_INT 1
77108: NEG
77109: PUSH
77110: LD_INT 2
77112: PUSH
77113: EMPTY
77114: LIST
77115: LIST
77116: PUSH
77117: EMPTY
77118: LIST
77119: LIST
77120: LIST
77121: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
77122: LD_ADDR_VAR 0 45
77126: PUSH
77127: LD_INT 2
77129: NEG
77130: PUSH
77131: LD_INT 0
77133: PUSH
77134: EMPTY
77135: LIST
77136: LIST
77137: PUSH
77138: LD_INT 2
77140: NEG
77141: PUSH
77142: LD_INT 1
77144: PUSH
77145: EMPTY
77146: LIST
77147: LIST
77148: PUSH
77149: LD_INT 3
77151: NEG
77152: PUSH
77153: LD_INT 1
77155: NEG
77156: PUSH
77157: EMPTY
77158: LIST
77159: LIST
77160: PUSH
77161: EMPTY
77162: LIST
77163: LIST
77164: LIST
77165: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
77166: LD_ADDR_VAR 0 46
77170: PUSH
77171: LD_INT 2
77173: NEG
77174: PUSH
77175: LD_INT 2
77177: NEG
77178: PUSH
77179: EMPTY
77180: LIST
77181: LIST
77182: PUSH
77183: LD_INT 2
77185: NEG
77186: PUSH
77187: LD_INT 3
77189: NEG
77190: PUSH
77191: EMPTY
77192: LIST
77193: LIST
77194: PUSH
77195: LD_INT 3
77197: NEG
77198: PUSH
77199: LD_INT 2
77201: NEG
77202: PUSH
77203: EMPTY
77204: LIST
77205: LIST
77206: PUSH
77207: EMPTY
77208: LIST
77209: LIST
77210: LIST
77211: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
77212: LD_ADDR_VAR 0 47
77216: PUSH
77217: LD_INT 2
77219: NEG
77220: PUSH
77221: LD_INT 3
77223: NEG
77224: PUSH
77225: EMPTY
77226: LIST
77227: LIST
77228: PUSH
77229: LD_INT 1
77231: NEG
77232: PUSH
77233: LD_INT 3
77235: NEG
77236: PUSH
77237: EMPTY
77238: LIST
77239: LIST
77240: PUSH
77241: EMPTY
77242: LIST
77243: LIST
77244: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
77245: LD_ADDR_VAR 0 48
77249: PUSH
77250: LD_INT 1
77252: PUSH
77253: LD_INT 2
77255: NEG
77256: PUSH
77257: EMPTY
77258: LIST
77259: LIST
77260: PUSH
77261: LD_INT 2
77263: PUSH
77264: LD_INT 1
77266: NEG
77267: PUSH
77268: EMPTY
77269: LIST
77270: LIST
77271: PUSH
77272: EMPTY
77273: LIST
77274: LIST
77275: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
77276: LD_ADDR_VAR 0 49
77280: PUSH
77281: LD_INT 3
77283: PUSH
77284: LD_INT 1
77286: PUSH
77287: EMPTY
77288: LIST
77289: LIST
77290: PUSH
77291: LD_INT 3
77293: PUSH
77294: LD_INT 2
77296: PUSH
77297: EMPTY
77298: LIST
77299: LIST
77300: PUSH
77301: EMPTY
77302: LIST
77303: LIST
77304: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
77305: LD_ADDR_VAR 0 50
77309: PUSH
77310: LD_INT 2
77312: PUSH
77313: LD_INT 3
77315: PUSH
77316: EMPTY
77317: LIST
77318: LIST
77319: PUSH
77320: LD_INT 1
77322: PUSH
77323: LD_INT 3
77325: PUSH
77326: EMPTY
77327: LIST
77328: LIST
77329: PUSH
77330: EMPTY
77331: LIST
77332: LIST
77333: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
77334: LD_ADDR_VAR 0 51
77338: PUSH
77339: LD_INT 1
77341: NEG
77342: PUSH
77343: LD_INT 2
77345: PUSH
77346: EMPTY
77347: LIST
77348: LIST
77349: PUSH
77350: LD_INT 2
77352: NEG
77353: PUSH
77354: LD_INT 1
77356: PUSH
77357: EMPTY
77358: LIST
77359: LIST
77360: PUSH
77361: EMPTY
77362: LIST
77363: LIST
77364: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
77365: LD_ADDR_VAR 0 52
77369: PUSH
77370: LD_INT 3
77372: NEG
77373: PUSH
77374: LD_INT 1
77376: NEG
77377: PUSH
77378: EMPTY
77379: LIST
77380: LIST
77381: PUSH
77382: LD_INT 3
77384: NEG
77385: PUSH
77386: LD_INT 2
77388: NEG
77389: PUSH
77390: EMPTY
77391: LIST
77392: LIST
77393: PUSH
77394: EMPTY
77395: LIST
77396: LIST
77397: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
77398: LD_ADDR_VAR 0 53
77402: PUSH
77403: LD_INT 1
77405: NEG
77406: PUSH
77407: LD_INT 3
77409: NEG
77410: PUSH
77411: EMPTY
77412: LIST
77413: LIST
77414: PUSH
77415: LD_INT 0
77417: PUSH
77418: LD_INT 3
77420: NEG
77421: PUSH
77422: EMPTY
77423: LIST
77424: LIST
77425: PUSH
77426: LD_INT 1
77428: PUSH
77429: LD_INT 2
77431: NEG
77432: PUSH
77433: EMPTY
77434: LIST
77435: LIST
77436: PUSH
77437: EMPTY
77438: LIST
77439: LIST
77440: LIST
77441: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
77442: LD_ADDR_VAR 0 54
77446: PUSH
77447: LD_INT 2
77449: PUSH
77450: LD_INT 1
77452: NEG
77453: PUSH
77454: EMPTY
77455: LIST
77456: LIST
77457: PUSH
77458: LD_INT 3
77460: PUSH
77461: LD_INT 0
77463: PUSH
77464: EMPTY
77465: LIST
77466: LIST
77467: PUSH
77468: LD_INT 3
77470: PUSH
77471: LD_INT 1
77473: PUSH
77474: EMPTY
77475: LIST
77476: LIST
77477: PUSH
77478: EMPTY
77479: LIST
77480: LIST
77481: LIST
77482: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
77483: LD_ADDR_VAR 0 55
77487: PUSH
77488: LD_INT 3
77490: PUSH
77491: LD_INT 2
77493: PUSH
77494: EMPTY
77495: LIST
77496: LIST
77497: PUSH
77498: LD_INT 3
77500: PUSH
77501: LD_INT 3
77503: PUSH
77504: EMPTY
77505: LIST
77506: LIST
77507: PUSH
77508: LD_INT 2
77510: PUSH
77511: LD_INT 3
77513: PUSH
77514: EMPTY
77515: LIST
77516: LIST
77517: PUSH
77518: EMPTY
77519: LIST
77520: LIST
77521: LIST
77522: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
77523: LD_ADDR_VAR 0 56
77527: PUSH
77528: LD_INT 1
77530: PUSH
77531: LD_INT 3
77533: PUSH
77534: EMPTY
77535: LIST
77536: LIST
77537: PUSH
77538: LD_INT 0
77540: PUSH
77541: LD_INT 3
77543: PUSH
77544: EMPTY
77545: LIST
77546: LIST
77547: PUSH
77548: LD_INT 1
77550: NEG
77551: PUSH
77552: LD_INT 2
77554: PUSH
77555: EMPTY
77556: LIST
77557: LIST
77558: PUSH
77559: EMPTY
77560: LIST
77561: LIST
77562: LIST
77563: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
77564: LD_ADDR_VAR 0 57
77568: PUSH
77569: LD_INT 2
77571: NEG
77572: PUSH
77573: LD_INT 1
77575: PUSH
77576: EMPTY
77577: LIST
77578: LIST
77579: PUSH
77580: LD_INT 3
77582: NEG
77583: PUSH
77584: LD_INT 0
77586: PUSH
77587: EMPTY
77588: LIST
77589: LIST
77590: PUSH
77591: LD_INT 3
77593: NEG
77594: PUSH
77595: LD_INT 1
77597: NEG
77598: PUSH
77599: EMPTY
77600: LIST
77601: LIST
77602: PUSH
77603: EMPTY
77604: LIST
77605: LIST
77606: LIST
77607: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
77608: LD_ADDR_VAR 0 58
77612: PUSH
77613: LD_INT 2
77615: NEG
77616: PUSH
77617: LD_INT 3
77619: NEG
77620: PUSH
77621: EMPTY
77622: LIST
77623: LIST
77624: PUSH
77625: LD_INT 3
77627: NEG
77628: PUSH
77629: LD_INT 2
77631: NEG
77632: PUSH
77633: EMPTY
77634: LIST
77635: LIST
77636: PUSH
77637: LD_INT 3
77639: NEG
77640: PUSH
77641: LD_INT 3
77643: NEG
77644: PUSH
77645: EMPTY
77646: LIST
77647: LIST
77648: PUSH
77649: EMPTY
77650: LIST
77651: LIST
77652: LIST
77653: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
77654: LD_ADDR_VAR 0 59
77658: PUSH
77659: LD_INT 1
77661: NEG
77662: PUSH
77663: LD_INT 2
77665: NEG
77666: PUSH
77667: EMPTY
77668: LIST
77669: LIST
77670: PUSH
77671: LD_INT 0
77673: PUSH
77674: LD_INT 2
77676: NEG
77677: PUSH
77678: EMPTY
77679: LIST
77680: LIST
77681: PUSH
77682: LD_INT 1
77684: PUSH
77685: LD_INT 1
77687: NEG
77688: PUSH
77689: EMPTY
77690: LIST
77691: LIST
77692: PUSH
77693: EMPTY
77694: LIST
77695: LIST
77696: LIST
77697: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
77698: LD_ADDR_VAR 0 60
77702: PUSH
77703: LD_INT 1
77705: PUSH
77706: LD_INT 1
77708: NEG
77709: PUSH
77710: EMPTY
77711: LIST
77712: LIST
77713: PUSH
77714: LD_INT 2
77716: PUSH
77717: LD_INT 0
77719: PUSH
77720: EMPTY
77721: LIST
77722: LIST
77723: PUSH
77724: LD_INT 2
77726: PUSH
77727: LD_INT 1
77729: PUSH
77730: EMPTY
77731: LIST
77732: LIST
77733: PUSH
77734: EMPTY
77735: LIST
77736: LIST
77737: LIST
77738: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
77739: LD_ADDR_VAR 0 61
77743: PUSH
77744: LD_INT 2
77746: PUSH
77747: LD_INT 1
77749: PUSH
77750: EMPTY
77751: LIST
77752: LIST
77753: PUSH
77754: LD_INT 2
77756: PUSH
77757: LD_INT 2
77759: PUSH
77760: EMPTY
77761: LIST
77762: LIST
77763: PUSH
77764: LD_INT 1
77766: PUSH
77767: LD_INT 2
77769: PUSH
77770: EMPTY
77771: LIST
77772: LIST
77773: PUSH
77774: EMPTY
77775: LIST
77776: LIST
77777: LIST
77778: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
77779: LD_ADDR_VAR 0 62
77783: PUSH
77784: LD_INT 1
77786: PUSH
77787: LD_INT 2
77789: PUSH
77790: EMPTY
77791: LIST
77792: LIST
77793: PUSH
77794: LD_INT 0
77796: PUSH
77797: LD_INT 2
77799: PUSH
77800: EMPTY
77801: LIST
77802: LIST
77803: PUSH
77804: LD_INT 1
77806: NEG
77807: PUSH
77808: LD_INT 1
77810: PUSH
77811: EMPTY
77812: LIST
77813: LIST
77814: PUSH
77815: EMPTY
77816: LIST
77817: LIST
77818: LIST
77819: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
77820: LD_ADDR_VAR 0 63
77824: PUSH
77825: LD_INT 1
77827: NEG
77828: PUSH
77829: LD_INT 1
77831: PUSH
77832: EMPTY
77833: LIST
77834: LIST
77835: PUSH
77836: LD_INT 2
77838: NEG
77839: PUSH
77840: LD_INT 0
77842: PUSH
77843: EMPTY
77844: LIST
77845: LIST
77846: PUSH
77847: LD_INT 2
77849: NEG
77850: PUSH
77851: LD_INT 1
77853: NEG
77854: PUSH
77855: EMPTY
77856: LIST
77857: LIST
77858: PUSH
77859: EMPTY
77860: LIST
77861: LIST
77862: LIST
77863: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77864: LD_ADDR_VAR 0 64
77868: PUSH
77869: LD_INT 1
77871: NEG
77872: PUSH
77873: LD_INT 2
77875: NEG
77876: PUSH
77877: EMPTY
77878: LIST
77879: LIST
77880: PUSH
77881: LD_INT 2
77883: NEG
77884: PUSH
77885: LD_INT 1
77887: NEG
77888: PUSH
77889: EMPTY
77890: LIST
77891: LIST
77892: PUSH
77893: LD_INT 2
77895: NEG
77896: PUSH
77897: LD_INT 2
77899: NEG
77900: PUSH
77901: EMPTY
77902: LIST
77903: LIST
77904: PUSH
77905: EMPTY
77906: LIST
77907: LIST
77908: LIST
77909: ST_TO_ADDR
// end ; 2 :
77910: GO 81176
77912: LD_INT 2
77914: DOUBLE
77915: EQUAL
77916: IFTRUE 77920
77918: GO 81175
77920: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
77921: LD_ADDR_VAR 0 29
77925: PUSH
77926: LD_INT 4
77928: PUSH
77929: LD_INT 0
77931: PUSH
77932: EMPTY
77933: LIST
77934: LIST
77935: PUSH
77936: LD_INT 4
77938: PUSH
77939: LD_INT 1
77941: NEG
77942: PUSH
77943: EMPTY
77944: LIST
77945: LIST
77946: PUSH
77947: LD_INT 5
77949: PUSH
77950: LD_INT 0
77952: PUSH
77953: EMPTY
77954: LIST
77955: LIST
77956: PUSH
77957: LD_INT 5
77959: PUSH
77960: LD_INT 1
77962: PUSH
77963: EMPTY
77964: LIST
77965: LIST
77966: PUSH
77967: LD_INT 4
77969: PUSH
77970: LD_INT 1
77972: PUSH
77973: EMPTY
77974: LIST
77975: LIST
77976: PUSH
77977: LD_INT 3
77979: PUSH
77980: LD_INT 0
77982: PUSH
77983: EMPTY
77984: LIST
77985: LIST
77986: PUSH
77987: LD_INT 3
77989: PUSH
77990: LD_INT 1
77992: NEG
77993: PUSH
77994: EMPTY
77995: LIST
77996: LIST
77997: PUSH
77998: LD_INT 3
78000: PUSH
78001: LD_INT 2
78003: NEG
78004: PUSH
78005: EMPTY
78006: LIST
78007: LIST
78008: PUSH
78009: LD_INT 5
78011: PUSH
78012: LD_INT 2
78014: PUSH
78015: EMPTY
78016: LIST
78017: LIST
78018: PUSH
78019: LD_INT 3
78021: PUSH
78022: LD_INT 3
78024: PUSH
78025: EMPTY
78026: LIST
78027: LIST
78028: PUSH
78029: LD_INT 3
78031: PUSH
78032: LD_INT 2
78034: PUSH
78035: EMPTY
78036: LIST
78037: LIST
78038: PUSH
78039: LD_INT 4
78041: PUSH
78042: LD_INT 3
78044: PUSH
78045: EMPTY
78046: LIST
78047: LIST
78048: PUSH
78049: LD_INT 4
78051: PUSH
78052: LD_INT 4
78054: PUSH
78055: EMPTY
78056: LIST
78057: LIST
78058: PUSH
78059: LD_INT 3
78061: PUSH
78062: LD_INT 4
78064: PUSH
78065: EMPTY
78066: LIST
78067: LIST
78068: PUSH
78069: LD_INT 2
78071: PUSH
78072: LD_INT 3
78074: PUSH
78075: EMPTY
78076: LIST
78077: LIST
78078: PUSH
78079: LD_INT 2
78081: PUSH
78082: LD_INT 2
78084: PUSH
78085: EMPTY
78086: LIST
78087: LIST
78088: PUSH
78089: LD_INT 4
78091: PUSH
78092: LD_INT 2
78094: PUSH
78095: EMPTY
78096: LIST
78097: LIST
78098: PUSH
78099: LD_INT 2
78101: PUSH
78102: LD_INT 4
78104: PUSH
78105: EMPTY
78106: LIST
78107: LIST
78108: PUSH
78109: LD_INT 0
78111: PUSH
78112: LD_INT 4
78114: PUSH
78115: EMPTY
78116: LIST
78117: LIST
78118: PUSH
78119: LD_INT 0
78121: PUSH
78122: LD_INT 3
78124: PUSH
78125: EMPTY
78126: LIST
78127: LIST
78128: PUSH
78129: LD_INT 1
78131: PUSH
78132: LD_INT 4
78134: PUSH
78135: EMPTY
78136: LIST
78137: LIST
78138: PUSH
78139: LD_INT 1
78141: PUSH
78142: LD_INT 5
78144: PUSH
78145: EMPTY
78146: LIST
78147: LIST
78148: PUSH
78149: LD_INT 0
78151: PUSH
78152: LD_INT 5
78154: PUSH
78155: EMPTY
78156: LIST
78157: LIST
78158: PUSH
78159: LD_INT 1
78161: NEG
78162: PUSH
78163: LD_INT 4
78165: PUSH
78166: EMPTY
78167: LIST
78168: LIST
78169: PUSH
78170: LD_INT 1
78172: NEG
78173: PUSH
78174: LD_INT 3
78176: PUSH
78177: EMPTY
78178: LIST
78179: LIST
78180: PUSH
78181: LD_INT 2
78183: PUSH
78184: LD_INT 5
78186: PUSH
78187: EMPTY
78188: LIST
78189: LIST
78190: PUSH
78191: LD_INT 2
78193: NEG
78194: PUSH
78195: LD_INT 3
78197: PUSH
78198: EMPTY
78199: LIST
78200: LIST
78201: PUSH
78202: LD_INT 3
78204: NEG
78205: PUSH
78206: LD_INT 0
78208: PUSH
78209: EMPTY
78210: LIST
78211: LIST
78212: PUSH
78213: LD_INT 3
78215: NEG
78216: PUSH
78217: LD_INT 1
78219: NEG
78220: PUSH
78221: EMPTY
78222: LIST
78223: LIST
78224: PUSH
78225: LD_INT 2
78227: NEG
78228: PUSH
78229: LD_INT 0
78231: PUSH
78232: EMPTY
78233: LIST
78234: LIST
78235: PUSH
78236: LD_INT 2
78238: NEG
78239: PUSH
78240: LD_INT 1
78242: PUSH
78243: EMPTY
78244: LIST
78245: LIST
78246: PUSH
78247: LD_INT 3
78249: NEG
78250: PUSH
78251: LD_INT 1
78253: PUSH
78254: EMPTY
78255: LIST
78256: LIST
78257: PUSH
78258: LD_INT 4
78260: NEG
78261: PUSH
78262: LD_INT 0
78264: PUSH
78265: EMPTY
78266: LIST
78267: LIST
78268: PUSH
78269: LD_INT 4
78271: NEG
78272: PUSH
78273: LD_INT 1
78275: NEG
78276: PUSH
78277: EMPTY
78278: LIST
78279: LIST
78280: PUSH
78281: LD_INT 4
78283: NEG
78284: PUSH
78285: LD_INT 2
78287: NEG
78288: PUSH
78289: EMPTY
78290: LIST
78291: LIST
78292: PUSH
78293: LD_INT 2
78295: NEG
78296: PUSH
78297: LD_INT 2
78299: PUSH
78300: EMPTY
78301: LIST
78302: LIST
78303: PUSH
78304: LD_INT 4
78306: NEG
78307: PUSH
78308: LD_INT 4
78310: NEG
78311: PUSH
78312: EMPTY
78313: LIST
78314: LIST
78315: PUSH
78316: LD_INT 4
78318: NEG
78319: PUSH
78320: LD_INT 5
78322: NEG
78323: PUSH
78324: EMPTY
78325: LIST
78326: LIST
78327: PUSH
78328: LD_INT 3
78330: NEG
78331: PUSH
78332: LD_INT 4
78334: NEG
78335: PUSH
78336: EMPTY
78337: LIST
78338: LIST
78339: PUSH
78340: LD_INT 3
78342: NEG
78343: PUSH
78344: LD_INT 3
78346: NEG
78347: PUSH
78348: EMPTY
78349: LIST
78350: LIST
78351: PUSH
78352: LD_INT 4
78354: NEG
78355: PUSH
78356: LD_INT 3
78358: NEG
78359: PUSH
78360: EMPTY
78361: LIST
78362: LIST
78363: PUSH
78364: LD_INT 5
78366: NEG
78367: PUSH
78368: LD_INT 4
78370: NEG
78371: PUSH
78372: EMPTY
78373: LIST
78374: LIST
78375: PUSH
78376: LD_INT 5
78378: NEG
78379: PUSH
78380: LD_INT 5
78382: NEG
78383: PUSH
78384: EMPTY
78385: LIST
78386: LIST
78387: PUSH
78388: LD_INT 3
78390: NEG
78391: PUSH
78392: LD_INT 5
78394: NEG
78395: PUSH
78396: EMPTY
78397: LIST
78398: LIST
78399: PUSH
78400: LD_INT 5
78402: NEG
78403: PUSH
78404: LD_INT 3
78406: NEG
78407: PUSH
78408: EMPTY
78409: LIST
78410: LIST
78411: PUSH
78412: EMPTY
78413: LIST
78414: LIST
78415: LIST
78416: LIST
78417: LIST
78418: LIST
78419: LIST
78420: LIST
78421: LIST
78422: LIST
78423: LIST
78424: LIST
78425: LIST
78426: LIST
78427: LIST
78428: LIST
78429: LIST
78430: LIST
78431: LIST
78432: LIST
78433: LIST
78434: LIST
78435: LIST
78436: LIST
78437: LIST
78438: LIST
78439: LIST
78440: LIST
78441: LIST
78442: LIST
78443: LIST
78444: LIST
78445: LIST
78446: LIST
78447: LIST
78448: LIST
78449: LIST
78450: LIST
78451: LIST
78452: LIST
78453: LIST
78454: LIST
78455: LIST
78456: LIST
78457: LIST
78458: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
78459: LD_ADDR_VAR 0 30
78463: PUSH
78464: LD_INT 4
78466: PUSH
78467: LD_INT 4
78469: PUSH
78470: EMPTY
78471: LIST
78472: LIST
78473: PUSH
78474: LD_INT 4
78476: PUSH
78477: LD_INT 3
78479: PUSH
78480: EMPTY
78481: LIST
78482: LIST
78483: PUSH
78484: LD_INT 5
78486: PUSH
78487: LD_INT 4
78489: PUSH
78490: EMPTY
78491: LIST
78492: LIST
78493: PUSH
78494: LD_INT 5
78496: PUSH
78497: LD_INT 5
78499: PUSH
78500: EMPTY
78501: LIST
78502: LIST
78503: PUSH
78504: LD_INT 4
78506: PUSH
78507: LD_INT 5
78509: PUSH
78510: EMPTY
78511: LIST
78512: LIST
78513: PUSH
78514: LD_INT 3
78516: PUSH
78517: LD_INT 4
78519: PUSH
78520: EMPTY
78521: LIST
78522: LIST
78523: PUSH
78524: LD_INT 3
78526: PUSH
78527: LD_INT 3
78529: PUSH
78530: EMPTY
78531: LIST
78532: LIST
78533: PUSH
78534: LD_INT 5
78536: PUSH
78537: LD_INT 3
78539: PUSH
78540: EMPTY
78541: LIST
78542: LIST
78543: PUSH
78544: LD_INT 3
78546: PUSH
78547: LD_INT 5
78549: PUSH
78550: EMPTY
78551: LIST
78552: LIST
78553: PUSH
78554: LD_INT 0
78556: PUSH
78557: LD_INT 3
78559: PUSH
78560: EMPTY
78561: LIST
78562: LIST
78563: PUSH
78564: LD_INT 0
78566: PUSH
78567: LD_INT 2
78569: PUSH
78570: EMPTY
78571: LIST
78572: LIST
78573: PUSH
78574: LD_INT 1
78576: PUSH
78577: LD_INT 3
78579: PUSH
78580: EMPTY
78581: LIST
78582: LIST
78583: PUSH
78584: LD_INT 1
78586: PUSH
78587: LD_INT 4
78589: PUSH
78590: EMPTY
78591: LIST
78592: LIST
78593: PUSH
78594: LD_INT 0
78596: PUSH
78597: LD_INT 4
78599: PUSH
78600: EMPTY
78601: LIST
78602: LIST
78603: PUSH
78604: LD_INT 1
78606: NEG
78607: PUSH
78608: LD_INT 3
78610: PUSH
78611: EMPTY
78612: LIST
78613: LIST
78614: PUSH
78615: LD_INT 1
78617: NEG
78618: PUSH
78619: LD_INT 2
78621: PUSH
78622: EMPTY
78623: LIST
78624: LIST
78625: PUSH
78626: LD_INT 2
78628: PUSH
78629: LD_INT 4
78631: PUSH
78632: EMPTY
78633: LIST
78634: LIST
78635: PUSH
78636: LD_INT 2
78638: NEG
78639: PUSH
78640: LD_INT 2
78642: PUSH
78643: EMPTY
78644: LIST
78645: LIST
78646: PUSH
78647: LD_INT 4
78649: NEG
78650: PUSH
78651: LD_INT 0
78653: PUSH
78654: EMPTY
78655: LIST
78656: LIST
78657: PUSH
78658: LD_INT 4
78660: NEG
78661: PUSH
78662: LD_INT 1
78664: NEG
78665: PUSH
78666: EMPTY
78667: LIST
78668: LIST
78669: PUSH
78670: LD_INT 3
78672: NEG
78673: PUSH
78674: LD_INT 0
78676: PUSH
78677: EMPTY
78678: LIST
78679: LIST
78680: PUSH
78681: LD_INT 3
78683: NEG
78684: PUSH
78685: LD_INT 1
78687: PUSH
78688: EMPTY
78689: LIST
78690: LIST
78691: PUSH
78692: LD_INT 4
78694: NEG
78695: PUSH
78696: LD_INT 1
78698: PUSH
78699: EMPTY
78700: LIST
78701: LIST
78702: PUSH
78703: LD_INT 5
78705: NEG
78706: PUSH
78707: LD_INT 0
78709: PUSH
78710: EMPTY
78711: LIST
78712: LIST
78713: PUSH
78714: LD_INT 5
78716: NEG
78717: PUSH
78718: LD_INT 1
78720: NEG
78721: PUSH
78722: EMPTY
78723: LIST
78724: LIST
78725: PUSH
78726: LD_INT 5
78728: NEG
78729: PUSH
78730: LD_INT 2
78732: NEG
78733: PUSH
78734: EMPTY
78735: LIST
78736: LIST
78737: PUSH
78738: LD_INT 3
78740: NEG
78741: PUSH
78742: LD_INT 2
78744: PUSH
78745: EMPTY
78746: LIST
78747: LIST
78748: PUSH
78749: LD_INT 3
78751: NEG
78752: PUSH
78753: LD_INT 3
78755: NEG
78756: PUSH
78757: EMPTY
78758: LIST
78759: LIST
78760: PUSH
78761: LD_INT 3
78763: NEG
78764: PUSH
78765: LD_INT 4
78767: NEG
78768: PUSH
78769: EMPTY
78770: LIST
78771: LIST
78772: PUSH
78773: LD_INT 2
78775: NEG
78776: PUSH
78777: LD_INT 3
78779: NEG
78780: PUSH
78781: EMPTY
78782: LIST
78783: LIST
78784: PUSH
78785: LD_INT 2
78787: NEG
78788: PUSH
78789: LD_INT 2
78791: NEG
78792: PUSH
78793: EMPTY
78794: LIST
78795: LIST
78796: PUSH
78797: LD_INT 3
78799: NEG
78800: PUSH
78801: LD_INT 2
78803: NEG
78804: PUSH
78805: EMPTY
78806: LIST
78807: LIST
78808: PUSH
78809: LD_INT 4
78811: NEG
78812: PUSH
78813: LD_INT 3
78815: NEG
78816: PUSH
78817: EMPTY
78818: LIST
78819: LIST
78820: PUSH
78821: LD_INT 4
78823: NEG
78824: PUSH
78825: LD_INT 4
78827: NEG
78828: PUSH
78829: EMPTY
78830: LIST
78831: LIST
78832: PUSH
78833: LD_INT 2
78835: NEG
78836: PUSH
78837: LD_INT 4
78839: NEG
78840: PUSH
78841: EMPTY
78842: LIST
78843: LIST
78844: PUSH
78845: LD_INT 4
78847: NEG
78848: PUSH
78849: LD_INT 2
78851: NEG
78852: PUSH
78853: EMPTY
78854: LIST
78855: LIST
78856: PUSH
78857: LD_INT 0
78859: PUSH
78860: LD_INT 4
78862: NEG
78863: PUSH
78864: EMPTY
78865: LIST
78866: LIST
78867: PUSH
78868: LD_INT 0
78870: PUSH
78871: LD_INT 5
78873: NEG
78874: PUSH
78875: EMPTY
78876: LIST
78877: LIST
78878: PUSH
78879: LD_INT 1
78881: PUSH
78882: LD_INT 4
78884: NEG
78885: PUSH
78886: EMPTY
78887: LIST
78888: LIST
78889: PUSH
78890: LD_INT 1
78892: PUSH
78893: LD_INT 3
78895: NEG
78896: PUSH
78897: EMPTY
78898: LIST
78899: LIST
78900: PUSH
78901: LD_INT 0
78903: PUSH
78904: LD_INT 3
78906: NEG
78907: PUSH
78908: EMPTY
78909: LIST
78910: LIST
78911: PUSH
78912: LD_INT 1
78914: NEG
78915: PUSH
78916: LD_INT 4
78918: NEG
78919: PUSH
78920: EMPTY
78921: LIST
78922: LIST
78923: PUSH
78924: LD_INT 1
78926: NEG
78927: PUSH
78928: LD_INT 5
78930: NEG
78931: PUSH
78932: EMPTY
78933: LIST
78934: LIST
78935: PUSH
78936: LD_INT 2
78938: PUSH
78939: LD_INT 3
78941: NEG
78942: PUSH
78943: EMPTY
78944: LIST
78945: LIST
78946: PUSH
78947: LD_INT 2
78949: NEG
78950: PUSH
78951: LD_INT 5
78953: NEG
78954: PUSH
78955: EMPTY
78956: LIST
78957: LIST
78958: PUSH
78959: EMPTY
78960: LIST
78961: LIST
78962: LIST
78963: LIST
78964: LIST
78965: LIST
78966: LIST
78967: LIST
78968: LIST
78969: LIST
78970: LIST
78971: LIST
78972: LIST
78973: LIST
78974: LIST
78975: LIST
78976: LIST
78977: LIST
78978: LIST
78979: LIST
78980: LIST
78981: LIST
78982: LIST
78983: LIST
78984: LIST
78985: LIST
78986: LIST
78987: LIST
78988: LIST
78989: LIST
78990: LIST
78991: LIST
78992: LIST
78993: LIST
78994: LIST
78995: LIST
78996: LIST
78997: LIST
78998: LIST
78999: LIST
79000: LIST
79001: LIST
79002: LIST
79003: LIST
79004: LIST
79005: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
79006: LD_ADDR_VAR 0 31
79010: PUSH
79011: LD_INT 0
79013: PUSH
79014: LD_INT 4
79016: PUSH
79017: EMPTY
79018: LIST
79019: LIST
79020: PUSH
79021: LD_INT 0
79023: PUSH
79024: LD_INT 3
79026: PUSH
79027: EMPTY
79028: LIST
79029: LIST
79030: PUSH
79031: LD_INT 1
79033: PUSH
79034: LD_INT 4
79036: PUSH
79037: EMPTY
79038: LIST
79039: LIST
79040: PUSH
79041: LD_INT 1
79043: PUSH
79044: LD_INT 5
79046: PUSH
79047: EMPTY
79048: LIST
79049: LIST
79050: PUSH
79051: LD_INT 0
79053: PUSH
79054: LD_INT 5
79056: PUSH
79057: EMPTY
79058: LIST
79059: LIST
79060: PUSH
79061: LD_INT 1
79063: NEG
79064: PUSH
79065: LD_INT 4
79067: PUSH
79068: EMPTY
79069: LIST
79070: LIST
79071: PUSH
79072: LD_INT 1
79074: NEG
79075: PUSH
79076: LD_INT 3
79078: PUSH
79079: EMPTY
79080: LIST
79081: LIST
79082: PUSH
79083: LD_INT 2
79085: PUSH
79086: LD_INT 5
79088: PUSH
79089: EMPTY
79090: LIST
79091: LIST
79092: PUSH
79093: LD_INT 2
79095: NEG
79096: PUSH
79097: LD_INT 3
79099: PUSH
79100: EMPTY
79101: LIST
79102: LIST
79103: PUSH
79104: LD_INT 3
79106: NEG
79107: PUSH
79108: LD_INT 0
79110: PUSH
79111: EMPTY
79112: LIST
79113: LIST
79114: PUSH
79115: LD_INT 3
79117: NEG
79118: PUSH
79119: LD_INT 1
79121: NEG
79122: PUSH
79123: EMPTY
79124: LIST
79125: LIST
79126: PUSH
79127: LD_INT 2
79129: NEG
79130: PUSH
79131: LD_INT 0
79133: PUSH
79134: EMPTY
79135: LIST
79136: LIST
79137: PUSH
79138: LD_INT 2
79140: NEG
79141: PUSH
79142: LD_INT 1
79144: PUSH
79145: EMPTY
79146: LIST
79147: LIST
79148: PUSH
79149: LD_INT 3
79151: NEG
79152: PUSH
79153: LD_INT 1
79155: PUSH
79156: EMPTY
79157: LIST
79158: LIST
79159: PUSH
79160: LD_INT 4
79162: NEG
79163: PUSH
79164: LD_INT 0
79166: PUSH
79167: EMPTY
79168: LIST
79169: LIST
79170: PUSH
79171: LD_INT 4
79173: NEG
79174: PUSH
79175: LD_INT 1
79177: NEG
79178: PUSH
79179: EMPTY
79180: LIST
79181: LIST
79182: PUSH
79183: LD_INT 4
79185: NEG
79186: PUSH
79187: LD_INT 2
79189: NEG
79190: PUSH
79191: EMPTY
79192: LIST
79193: LIST
79194: PUSH
79195: LD_INT 2
79197: NEG
79198: PUSH
79199: LD_INT 2
79201: PUSH
79202: EMPTY
79203: LIST
79204: LIST
79205: PUSH
79206: LD_INT 4
79208: NEG
79209: PUSH
79210: LD_INT 4
79212: NEG
79213: PUSH
79214: EMPTY
79215: LIST
79216: LIST
79217: PUSH
79218: LD_INT 4
79220: NEG
79221: PUSH
79222: LD_INT 5
79224: NEG
79225: PUSH
79226: EMPTY
79227: LIST
79228: LIST
79229: PUSH
79230: LD_INT 3
79232: NEG
79233: PUSH
79234: LD_INT 4
79236: NEG
79237: PUSH
79238: EMPTY
79239: LIST
79240: LIST
79241: PUSH
79242: LD_INT 3
79244: NEG
79245: PUSH
79246: LD_INT 3
79248: NEG
79249: PUSH
79250: EMPTY
79251: LIST
79252: LIST
79253: PUSH
79254: LD_INT 4
79256: NEG
79257: PUSH
79258: LD_INT 3
79260: NEG
79261: PUSH
79262: EMPTY
79263: LIST
79264: LIST
79265: PUSH
79266: LD_INT 5
79268: NEG
79269: PUSH
79270: LD_INT 4
79272: NEG
79273: PUSH
79274: EMPTY
79275: LIST
79276: LIST
79277: PUSH
79278: LD_INT 5
79280: NEG
79281: PUSH
79282: LD_INT 5
79284: NEG
79285: PUSH
79286: EMPTY
79287: LIST
79288: LIST
79289: PUSH
79290: LD_INT 3
79292: NEG
79293: PUSH
79294: LD_INT 5
79296: NEG
79297: PUSH
79298: EMPTY
79299: LIST
79300: LIST
79301: PUSH
79302: LD_INT 5
79304: NEG
79305: PUSH
79306: LD_INT 3
79308: NEG
79309: PUSH
79310: EMPTY
79311: LIST
79312: LIST
79313: PUSH
79314: LD_INT 0
79316: PUSH
79317: LD_INT 3
79319: NEG
79320: PUSH
79321: EMPTY
79322: LIST
79323: LIST
79324: PUSH
79325: LD_INT 0
79327: PUSH
79328: LD_INT 4
79330: NEG
79331: PUSH
79332: EMPTY
79333: LIST
79334: LIST
79335: PUSH
79336: LD_INT 1
79338: PUSH
79339: LD_INT 3
79341: NEG
79342: PUSH
79343: EMPTY
79344: LIST
79345: LIST
79346: PUSH
79347: LD_INT 1
79349: PUSH
79350: LD_INT 2
79352: NEG
79353: PUSH
79354: EMPTY
79355: LIST
79356: LIST
79357: PUSH
79358: LD_INT 0
79360: PUSH
79361: LD_INT 2
79363: NEG
79364: PUSH
79365: EMPTY
79366: LIST
79367: LIST
79368: PUSH
79369: LD_INT 1
79371: NEG
79372: PUSH
79373: LD_INT 3
79375: NEG
79376: PUSH
79377: EMPTY
79378: LIST
79379: LIST
79380: PUSH
79381: LD_INT 1
79383: NEG
79384: PUSH
79385: LD_INT 4
79387: NEG
79388: PUSH
79389: EMPTY
79390: LIST
79391: LIST
79392: PUSH
79393: LD_INT 2
79395: PUSH
79396: LD_INT 2
79398: NEG
79399: PUSH
79400: EMPTY
79401: LIST
79402: LIST
79403: PUSH
79404: LD_INT 2
79406: NEG
79407: PUSH
79408: LD_INT 4
79410: NEG
79411: PUSH
79412: EMPTY
79413: LIST
79414: LIST
79415: PUSH
79416: LD_INT 4
79418: PUSH
79419: LD_INT 0
79421: PUSH
79422: EMPTY
79423: LIST
79424: LIST
79425: PUSH
79426: LD_INT 4
79428: PUSH
79429: LD_INT 1
79431: NEG
79432: PUSH
79433: EMPTY
79434: LIST
79435: LIST
79436: PUSH
79437: LD_INT 5
79439: PUSH
79440: LD_INT 0
79442: PUSH
79443: EMPTY
79444: LIST
79445: LIST
79446: PUSH
79447: LD_INT 5
79449: PUSH
79450: LD_INT 1
79452: PUSH
79453: EMPTY
79454: LIST
79455: LIST
79456: PUSH
79457: LD_INT 4
79459: PUSH
79460: LD_INT 1
79462: PUSH
79463: EMPTY
79464: LIST
79465: LIST
79466: PUSH
79467: LD_INT 3
79469: PUSH
79470: LD_INT 0
79472: PUSH
79473: EMPTY
79474: LIST
79475: LIST
79476: PUSH
79477: LD_INT 3
79479: PUSH
79480: LD_INT 1
79482: NEG
79483: PUSH
79484: EMPTY
79485: LIST
79486: LIST
79487: PUSH
79488: LD_INT 3
79490: PUSH
79491: LD_INT 2
79493: NEG
79494: PUSH
79495: EMPTY
79496: LIST
79497: LIST
79498: PUSH
79499: LD_INT 5
79501: PUSH
79502: LD_INT 2
79504: PUSH
79505: EMPTY
79506: LIST
79507: LIST
79508: PUSH
79509: EMPTY
79510: LIST
79511: LIST
79512: LIST
79513: LIST
79514: LIST
79515: LIST
79516: LIST
79517: LIST
79518: LIST
79519: LIST
79520: LIST
79521: LIST
79522: LIST
79523: LIST
79524: LIST
79525: LIST
79526: LIST
79527: LIST
79528: LIST
79529: LIST
79530: LIST
79531: LIST
79532: LIST
79533: LIST
79534: LIST
79535: LIST
79536: LIST
79537: LIST
79538: LIST
79539: LIST
79540: LIST
79541: LIST
79542: LIST
79543: LIST
79544: LIST
79545: LIST
79546: LIST
79547: LIST
79548: LIST
79549: LIST
79550: LIST
79551: LIST
79552: LIST
79553: LIST
79554: LIST
79555: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
79556: LD_ADDR_VAR 0 32
79560: PUSH
79561: LD_INT 4
79563: NEG
79564: PUSH
79565: LD_INT 0
79567: PUSH
79568: EMPTY
79569: LIST
79570: LIST
79571: PUSH
79572: LD_INT 4
79574: NEG
79575: PUSH
79576: LD_INT 1
79578: NEG
79579: PUSH
79580: EMPTY
79581: LIST
79582: LIST
79583: PUSH
79584: LD_INT 3
79586: NEG
79587: PUSH
79588: LD_INT 0
79590: PUSH
79591: EMPTY
79592: LIST
79593: LIST
79594: PUSH
79595: LD_INT 3
79597: NEG
79598: PUSH
79599: LD_INT 1
79601: PUSH
79602: EMPTY
79603: LIST
79604: LIST
79605: PUSH
79606: LD_INT 4
79608: NEG
79609: PUSH
79610: LD_INT 1
79612: PUSH
79613: EMPTY
79614: LIST
79615: LIST
79616: PUSH
79617: LD_INT 5
79619: NEG
79620: PUSH
79621: LD_INT 0
79623: PUSH
79624: EMPTY
79625: LIST
79626: LIST
79627: PUSH
79628: LD_INT 5
79630: NEG
79631: PUSH
79632: LD_INT 1
79634: NEG
79635: PUSH
79636: EMPTY
79637: LIST
79638: LIST
79639: PUSH
79640: LD_INT 5
79642: NEG
79643: PUSH
79644: LD_INT 2
79646: NEG
79647: PUSH
79648: EMPTY
79649: LIST
79650: LIST
79651: PUSH
79652: LD_INT 3
79654: NEG
79655: PUSH
79656: LD_INT 2
79658: PUSH
79659: EMPTY
79660: LIST
79661: LIST
79662: PUSH
79663: LD_INT 3
79665: NEG
79666: PUSH
79667: LD_INT 3
79669: NEG
79670: PUSH
79671: EMPTY
79672: LIST
79673: LIST
79674: PUSH
79675: LD_INT 3
79677: NEG
79678: PUSH
79679: LD_INT 4
79681: NEG
79682: PUSH
79683: EMPTY
79684: LIST
79685: LIST
79686: PUSH
79687: LD_INT 2
79689: NEG
79690: PUSH
79691: LD_INT 3
79693: NEG
79694: PUSH
79695: EMPTY
79696: LIST
79697: LIST
79698: PUSH
79699: LD_INT 2
79701: NEG
79702: PUSH
79703: LD_INT 2
79705: NEG
79706: PUSH
79707: EMPTY
79708: LIST
79709: LIST
79710: PUSH
79711: LD_INT 3
79713: NEG
79714: PUSH
79715: LD_INT 2
79717: NEG
79718: PUSH
79719: EMPTY
79720: LIST
79721: LIST
79722: PUSH
79723: LD_INT 4
79725: NEG
79726: PUSH
79727: LD_INT 3
79729: NEG
79730: PUSH
79731: EMPTY
79732: LIST
79733: LIST
79734: PUSH
79735: LD_INT 4
79737: NEG
79738: PUSH
79739: LD_INT 4
79741: NEG
79742: PUSH
79743: EMPTY
79744: LIST
79745: LIST
79746: PUSH
79747: LD_INT 2
79749: NEG
79750: PUSH
79751: LD_INT 4
79753: NEG
79754: PUSH
79755: EMPTY
79756: LIST
79757: LIST
79758: PUSH
79759: LD_INT 4
79761: NEG
79762: PUSH
79763: LD_INT 2
79765: NEG
79766: PUSH
79767: EMPTY
79768: LIST
79769: LIST
79770: PUSH
79771: LD_INT 0
79773: PUSH
79774: LD_INT 4
79776: NEG
79777: PUSH
79778: EMPTY
79779: LIST
79780: LIST
79781: PUSH
79782: LD_INT 0
79784: PUSH
79785: LD_INT 5
79787: NEG
79788: PUSH
79789: EMPTY
79790: LIST
79791: LIST
79792: PUSH
79793: LD_INT 1
79795: PUSH
79796: LD_INT 4
79798: NEG
79799: PUSH
79800: EMPTY
79801: LIST
79802: LIST
79803: PUSH
79804: LD_INT 1
79806: PUSH
79807: LD_INT 3
79809: NEG
79810: PUSH
79811: EMPTY
79812: LIST
79813: LIST
79814: PUSH
79815: LD_INT 0
79817: PUSH
79818: LD_INT 3
79820: NEG
79821: PUSH
79822: EMPTY
79823: LIST
79824: LIST
79825: PUSH
79826: LD_INT 1
79828: NEG
79829: PUSH
79830: LD_INT 4
79832: NEG
79833: PUSH
79834: EMPTY
79835: LIST
79836: LIST
79837: PUSH
79838: LD_INT 1
79840: NEG
79841: PUSH
79842: LD_INT 5
79844: NEG
79845: PUSH
79846: EMPTY
79847: LIST
79848: LIST
79849: PUSH
79850: LD_INT 2
79852: PUSH
79853: LD_INT 3
79855: NEG
79856: PUSH
79857: EMPTY
79858: LIST
79859: LIST
79860: PUSH
79861: LD_INT 2
79863: NEG
79864: PUSH
79865: LD_INT 5
79867: NEG
79868: PUSH
79869: EMPTY
79870: LIST
79871: LIST
79872: PUSH
79873: LD_INT 3
79875: PUSH
79876: LD_INT 0
79878: PUSH
79879: EMPTY
79880: LIST
79881: LIST
79882: PUSH
79883: LD_INT 3
79885: PUSH
79886: LD_INT 1
79888: NEG
79889: PUSH
79890: EMPTY
79891: LIST
79892: LIST
79893: PUSH
79894: LD_INT 4
79896: PUSH
79897: LD_INT 0
79899: PUSH
79900: EMPTY
79901: LIST
79902: LIST
79903: PUSH
79904: LD_INT 4
79906: PUSH
79907: LD_INT 1
79909: PUSH
79910: EMPTY
79911: LIST
79912: LIST
79913: PUSH
79914: LD_INT 3
79916: PUSH
79917: LD_INT 1
79919: PUSH
79920: EMPTY
79921: LIST
79922: LIST
79923: PUSH
79924: LD_INT 2
79926: PUSH
79927: LD_INT 0
79929: PUSH
79930: EMPTY
79931: LIST
79932: LIST
79933: PUSH
79934: LD_INT 2
79936: PUSH
79937: LD_INT 1
79939: NEG
79940: PUSH
79941: EMPTY
79942: LIST
79943: LIST
79944: PUSH
79945: LD_INT 2
79947: PUSH
79948: LD_INT 2
79950: NEG
79951: PUSH
79952: EMPTY
79953: LIST
79954: LIST
79955: PUSH
79956: LD_INT 4
79958: PUSH
79959: LD_INT 2
79961: PUSH
79962: EMPTY
79963: LIST
79964: LIST
79965: PUSH
79966: LD_INT 4
79968: PUSH
79969: LD_INT 4
79971: PUSH
79972: EMPTY
79973: LIST
79974: LIST
79975: PUSH
79976: LD_INT 4
79978: PUSH
79979: LD_INT 3
79981: PUSH
79982: EMPTY
79983: LIST
79984: LIST
79985: PUSH
79986: LD_INT 5
79988: PUSH
79989: LD_INT 4
79991: PUSH
79992: EMPTY
79993: LIST
79994: LIST
79995: PUSH
79996: LD_INT 5
79998: PUSH
79999: LD_INT 5
80001: PUSH
80002: EMPTY
80003: LIST
80004: LIST
80005: PUSH
80006: LD_INT 4
80008: PUSH
80009: LD_INT 5
80011: PUSH
80012: EMPTY
80013: LIST
80014: LIST
80015: PUSH
80016: LD_INT 3
80018: PUSH
80019: LD_INT 4
80021: PUSH
80022: EMPTY
80023: LIST
80024: LIST
80025: PUSH
80026: LD_INT 3
80028: PUSH
80029: LD_INT 3
80031: PUSH
80032: EMPTY
80033: LIST
80034: LIST
80035: PUSH
80036: LD_INT 5
80038: PUSH
80039: LD_INT 3
80041: PUSH
80042: EMPTY
80043: LIST
80044: LIST
80045: PUSH
80046: LD_INT 3
80048: PUSH
80049: LD_INT 5
80051: PUSH
80052: EMPTY
80053: LIST
80054: LIST
80055: PUSH
80056: EMPTY
80057: LIST
80058: LIST
80059: LIST
80060: LIST
80061: LIST
80062: LIST
80063: LIST
80064: LIST
80065: LIST
80066: LIST
80067: LIST
80068: LIST
80069: LIST
80070: LIST
80071: LIST
80072: LIST
80073: LIST
80074: LIST
80075: LIST
80076: LIST
80077: LIST
80078: LIST
80079: LIST
80080: LIST
80081: LIST
80082: LIST
80083: LIST
80084: LIST
80085: LIST
80086: LIST
80087: LIST
80088: LIST
80089: LIST
80090: LIST
80091: LIST
80092: LIST
80093: LIST
80094: LIST
80095: LIST
80096: LIST
80097: LIST
80098: LIST
80099: LIST
80100: LIST
80101: LIST
80102: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
80103: LD_ADDR_VAR 0 33
80107: PUSH
80108: LD_INT 4
80110: NEG
80111: PUSH
80112: LD_INT 4
80114: NEG
80115: PUSH
80116: EMPTY
80117: LIST
80118: LIST
80119: PUSH
80120: LD_INT 4
80122: NEG
80123: PUSH
80124: LD_INT 5
80126: NEG
80127: PUSH
80128: EMPTY
80129: LIST
80130: LIST
80131: PUSH
80132: LD_INT 3
80134: NEG
80135: PUSH
80136: LD_INT 4
80138: NEG
80139: PUSH
80140: EMPTY
80141: LIST
80142: LIST
80143: PUSH
80144: LD_INT 3
80146: NEG
80147: PUSH
80148: LD_INT 3
80150: NEG
80151: PUSH
80152: EMPTY
80153: LIST
80154: LIST
80155: PUSH
80156: LD_INT 4
80158: NEG
80159: PUSH
80160: LD_INT 3
80162: NEG
80163: PUSH
80164: EMPTY
80165: LIST
80166: LIST
80167: PUSH
80168: LD_INT 5
80170: NEG
80171: PUSH
80172: LD_INT 4
80174: NEG
80175: PUSH
80176: EMPTY
80177: LIST
80178: LIST
80179: PUSH
80180: LD_INT 5
80182: NEG
80183: PUSH
80184: LD_INT 5
80186: NEG
80187: PUSH
80188: EMPTY
80189: LIST
80190: LIST
80191: PUSH
80192: LD_INT 3
80194: NEG
80195: PUSH
80196: LD_INT 5
80198: NEG
80199: PUSH
80200: EMPTY
80201: LIST
80202: LIST
80203: PUSH
80204: LD_INT 5
80206: NEG
80207: PUSH
80208: LD_INT 3
80210: NEG
80211: PUSH
80212: EMPTY
80213: LIST
80214: LIST
80215: PUSH
80216: LD_INT 0
80218: PUSH
80219: LD_INT 3
80221: NEG
80222: PUSH
80223: EMPTY
80224: LIST
80225: LIST
80226: PUSH
80227: LD_INT 0
80229: PUSH
80230: LD_INT 4
80232: NEG
80233: PUSH
80234: EMPTY
80235: LIST
80236: LIST
80237: PUSH
80238: LD_INT 1
80240: PUSH
80241: LD_INT 3
80243: NEG
80244: PUSH
80245: EMPTY
80246: LIST
80247: LIST
80248: PUSH
80249: LD_INT 1
80251: PUSH
80252: LD_INT 2
80254: NEG
80255: PUSH
80256: EMPTY
80257: LIST
80258: LIST
80259: PUSH
80260: LD_INT 0
80262: PUSH
80263: LD_INT 2
80265: NEG
80266: PUSH
80267: EMPTY
80268: LIST
80269: LIST
80270: PUSH
80271: LD_INT 1
80273: NEG
80274: PUSH
80275: LD_INT 3
80277: NEG
80278: PUSH
80279: EMPTY
80280: LIST
80281: LIST
80282: PUSH
80283: LD_INT 1
80285: NEG
80286: PUSH
80287: LD_INT 4
80289: NEG
80290: PUSH
80291: EMPTY
80292: LIST
80293: LIST
80294: PUSH
80295: LD_INT 2
80297: PUSH
80298: LD_INT 2
80300: NEG
80301: PUSH
80302: EMPTY
80303: LIST
80304: LIST
80305: PUSH
80306: LD_INT 2
80308: NEG
80309: PUSH
80310: LD_INT 4
80312: NEG
80313: PUSH
80314: EMPTY
80315: LIST
80316: LIST
80317: PUSH
80318: LD_INT 4
80320: PUSH
80321: LD_INT 0
80323: PUSH
80324: EMPTY
80325: LIST
80326: LIST
80327: PUSH
80328: LD_INT 4
80330: PUSH
80331: LD_INT 1
80333: NEG
80334: PUSH
80335: EMPTY
80336: LIST
80337: LIST
80338: PUSH
80339: LD_INT 5
80341: PUSH
80342: LD_INT 0
80344: PUSH
80345: EMPTY
80346: LIST
80347: LIST
80348: PUSH
80349: LD_INT 5
80351: PUSH
80352: LD_INT 1
80354: PUSH
80355: EMPTY
80356: LIST
80357: LIST
80358: PUSH
80359: LD_INT 4
80361: PUSH
80362: LD_INT 1
80364: PUSH
80365: EMPTY
80366: LIST
80367: LIST
80368: PUSH
80369: LD_INT 3
80371: PUSH
80372: LD_INT 0
80374: PUSH
80375: EMPTY
80376: LIST
80377: LIST
80378: PUSH
80379: LD_INT 3
80381: PUSH
80382: LD_INT 1
80384: NEG
80385: PUSH
80386: EMPTY
80387: LIST
80388: LIST
80389: PUSH
80390: LD_INT 3
80392: PUSH
80393: LD_INT 2
80395: NEG
80396: PUSH
80397: EMPTY
80398: LIST
80399: LIST
80400: PUSH
80401: LD_INT 5
80403: PUSH
80404: LD_INT 2
80406: PUSH
80407: EMPTY
80408: LIST
80409: LIST
80410: PUSH
80411: LD_INT 3
80413: PUSH
80414: LD_INT 3
80416: PUSH
80417: EMPTY
80418: LIST
80419: LIST
80420: PUSH
80421: LD_INT 3
80423: PUSH
80424: LD_INT 2
80426: PUSH
80427: EMPTY
80428: LIST
80429: LIST
80430: PUSH
80431: LD_INT 4
80433: PUSH
80434: LD_INT 3
80436: PUSH
80437: EMPTY
80438: LIST
80439: LIST
80440: PUSH
80441: LD_INT 4
80443: PUSH
80444: LD_INT 4
80446: PUSH
80447: EMPTY
80448: LIST
80449: LIST
80450: PUSH
80451: LD_INT 3
80453: PUSH
80454: LD_INT 4
80456: PUSH
80457: EMPTY
80458: LIST
80459: LIST
80460: PUSH
80461: LD_INT 2
80463: PUSH
80464: LD_INT 3
80466: PUSH
80467: EMPTY
80468: LIST
80469: LIST
80470: PUSH
80471: LD_INT 2
80473: PUSH
80474: LD_INT 2
80476: PUSH
80477: EMPTY
80478: LIST
80479: LIST
80480: PUSH
80481: LD_INT 4
80483: PUSH
80484: LD_INT 2
80486: PUSH
80487: EMPTY
80488: LIST
80489: LIST
80490: PUSH
80491: LD_INT 2
80493: PUSH
80494: LD_INT 4
80496: PUSH
80497: EMPTY
80498: LIST
80499: LIST
80500: PUSH
80501: LD_INT 0
80503: PUSH
80504: LD_INT 4
80506: PUSH
80507: EMPTY
80508: LIST
80509: LIST
80510: PUSH
80511: LD_INT 0
80513: PUSH
80514: LD_INT 3
80516: PUSH
80517: EMPTY
80518: LIST
80519: LIST
80520: PUSH
80521: LD_INT 1
80523: PUSH
80524: LD_INT 4
80526: PUSH
80527: EMPTY
80528: LIST
80529: LIST
80530: PUSH
80531: LD_INT 1
80533: PUSH
80534: LD_INT 5
80536: PUSH
80537: EMPTY
80538: LIST
80539: LIST
80540: PUSH
80541: LD_INT 0
80543: PUSH
80544: LD_INT 5
80546: PUSH
80547: EMPTY
80548: LIST
80549: LIST
80550: PUSH
80551: LD_INT 1
80553: NEG
80554: PUSH
80555: LD_INT 4
80557: PUSH
80558: EMPTY
80559: LIST
80560: LIST
80561: PUSH
80562: LD_INT 1
80564: NEG
80565: PUSH
80566: LD_INT 3
80568: PUSH
80569: EMPTY
80570: LIST
80571: LIST
80572: PUSH
80573: LD_INT 2
80575: PUSH
80576: LD_INT 5
80578: PUSH
80579: EMPTY
80580: LIST
80581: LIST
80582: PUSH
80583: LD_INT 2
80585: NEG
80586: PUSH
80587: LD_INT 3
80589: PUSH
80590: EMPTY
80591: LIST
80592: LIST
80593: PUSH
80594: EMPTY
80595: LIST
80596: LIST
80597: LIST
80598: LIST
80599: LIST
80600: LIST
80601: LIST
80602: LIST
80603: LIST
80604: LIST
80605: LIST
80606: LIST
80607: LIST
80608: LIST
80609: LIST
80610: LIST
80611: LIST
80612: LIST
80613: LIST
80614: LIST
80615: LIST
80616: LIST
80617: LIST
80618: LIST
80619: LIST
80620: LIST
80621: LIST
80622: LIST
80623: LIST
80624: LIST
80625: LIST
80626: LIST
80627: LIST
80628: LIST
80629: LIST
80630: LIST
80631: LIST
80632: LIST
80633: LIST
80634: LIST
80635: LIST
80636: LIST
80637: LIST
80638: LIST
80639: LIST
80640: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
80641: LD_ADDR_VAR 0 34
80645: PUSH
80646: LD_INT 0
80648: PUSH
80649: LD_INT 4
80651: NEG
80652: PUSH
80653: EMPTY
80654: LIST
80655: LIST
80656: PUSH
80657: LD_INT 0
80659: PUSH
80660: LD_INT 5
80662: NEG
80663: PUSH
80664: EMPTY
80665: LIST
80666: LIST
80667: PUSH
80668: LD_INT 1
80670: PUSH
80671: LD_INT 4
80673: NEG
80674: PUSH
80675: EMPTY
80676: LIST
80677: LIST
80678: PUSH
80679: LD_INT 1
80681: PUSH
80682: LD_INT 3
80684: NEG
80685: PUSH
80686: EMPTY
80687: LIST
80688: LIST
80689: PUSH
80690: LD_INT 0
80692: PUSH
80693: LD_INT 3
80695: NEG
80696: PUSH
80697: EMPTY
80698: LIST
80699: LIST
80700: PUSH
80701: LD_INT 1
80703: NEG
80704: PUSH
80705: LD_INT 4
80707: NEG
80708: PUSH
80709: EMPTY
80710: LIST
80711: LIST
80712: PUSH
80713: LD_INT 1
80715: NEG
80716: PUSH
80717: LD_INT 5
80719: NEG
80720: PUSH
80721: EMPTY
80722: LIST
80723: LIST
80724: PUSH
80725: LD_INT 2
80727: PUSH
80728: LD_INT 3
80730: NEG
80731: PUSH
80732: EMPTY
80733: LIST
80734: LIST
80735: PUSH
80736: LD_INT 2
80738: NEG
80739: PUSH
80740: LD_INT 5
80742: NEG
80743: PUSH
80744: EMPTY
80745: LIST
80746: LIST
80747: PUSH
80748: LD_INT 3
80750: PUSH
80751: LD_INT 0
80753: PUSH
80754: EMPTY
80755: LIST
80756: LIST
80757: PUSH
80758: LD_INT 3
80760: PUSH
80761: LD_INT 1
80763: NEG
80764: PUSH
80765: EMPTY
80766: LIST
80767: LIST
80768: PUSH
80769: LD_INT 4
80771: PUSH
80772: LD_INT 0
80774: PUSH
80775: EMPTY
80776: LIST
80777: LIST
80778: PUSH
80779: LD_INT 4
80781: PUSH
80782: LD_INT 1
80784: PUSH
80785: EMPTY
80786: LIST
80787: LIST
80788: PUSH
80789: LD_INT 3
80791: PUSH
80792: LD_INT 1
80794: PUSH
80795: EMPTY
80796: LIST
80797: LIST
80798: PUSH
80799: LD_INT 2
80801: PUSH
80802: LD_INT 0
80804: PUSH
80805: EMPTY
80806: LIST
80807: LIST
80808: PUSH
80809: LD_INT 2
80811: PUSH
80812: LD_INT 1
80814: NEG
80815: PUSH
80816: EMPTY
80817: LIST
80818: LIST
80819: PUSH
80820: LD_INT 2
80822: PUSH
80823: LD_INT 2
80825: NEG
80826: PUSH
80827: EMPTY
80828: LIST
80829: LIST
80830: PUSH
80831: LD_INT 4
80833: PUSH
80834: LD_INT 2
80836: PUSH
80837: EMPTY
80838: LIST
80839: LIST
80840: PUSH
80841: LD_INT 4
80843: PUSH
80844: LD_INT 4
80846: PUSH
80847: EMPTY
80848: LIST
80849: LIST
80850: PUSH
80851: LD_INT 4
80853: PUSH
80854: LD_INT 3
80856: PUSH
80857: EMPTY
80858: LIST
80859: LIST
80860: PUSH
80861: LD_INT 5
80863: PUSH
80864: LD_INT 4
80866: PUSH
80867: EMPTY
80868: LIST
80869: LIST
80870: PUSH
80871: LD_INT 5
80873: PUSH
80874: LD_INT 5
80876: PUSH
80877: EMPTY
80878: LIST
80879: LIST
80880: PUSH
80881: LD_INT 4
80883: PUSH
80884: LD_INT 5
80886: PUSH
80887: EMPTY
80888: LIST
80889: LIST
80890: PUSH
80891: LD_INT 3
80893: PUSH
80894: LD_INT 4
80896: PUSH
80897: EMPTY
80898: LIST
80899: LIST
80900: PUSH
80901: LD_INT 3
80903: PUSH
80904: LD_INT 3
80906: PUSH
80907: EMPTY
80908: LIST
80909: LIST
80910: PUSH
80911: LD_INT 5
80913: PUSH
80914: LD_INT 3
80916: PUSH
80917: EMPTY
80918: LIST
80919: LIST
80920: PUSH
80921: LD_INT 3
80923: PUSH
80924: LD_INT 5
80926: PUSH
80927: EMPTY
80928: LIST
80929: LIST
80930: PUSH
80931: LD_INT 0
80933: PUSH
80934: LD_INT 3
80936: PUSH
80937: EMPTY
80938: LIST
80939: LIST
80940: PUSH
80941: LD_INT 0
80943: PUSH
80944: LD_INT 2
80946: PUSH
80947: EMPTY
80948: LIST
80949: LIST
80950: PUSH
80951: LD_INT 1
80953: PUSH
80954: LD_INT 3
80956: PUSH
80957: EMPTY
80958: LIST
80959: LIST
80960: PUSH
80961: LD_INT 1
80963: PUSH
80964: LD_INT 4
80966: PUSH
80967: EMPTY
80968: LIST
80969: LIST
80970: PUSH
80971: LD_INT 0
80973: PUSH
80974: LD_INT 4
80976: PUSH
80977: EMPTY
80978: LIST
80979: LIST
80980: PUSH
80981: LD_INT 1
80983: NEG
80984: PUSH
80985: LD_INT 3
80987: PUSH
80988: EMPTY
80989: LIST
80990: LIST
80991: PUSH
80992: LD_INT 1
80994: NEG
80995: PUSH
80996: LD_INT 2
80998: PUSH
80999: EMPTY
81000: LIST
81001: LIST
81002: PUSH
81003: LD_INT 2
81005: PUSH
81006: LD_INT 4
81008: PUSH
81009: EMPTY
81010: LIST
81011: LIST
81012: PUSH
81013: LD_INT 2
81015: NEG
81016: PUSH
81017: LD_INT 2
81019: PUSH
81020: EMPTY
81021: LIST
81022: LIST
81023: PUSH
81024: LD_INT 4
81026: NEG
81027: PUSH
81028: LD_INT 0
81030: PUSH
81031: EMPTY
81032: LIST
81033: LIST
81034: PUSH
81035: LD_INT 4
81037: NEG
81038: PUSH
81039: LD_INT 1
81041: NEG
81042: PUSH
81043: EMPTY
81044: LIST
81045: LIST
81046: PUSH
81047: LD_INT 3
81049: NEG
81050: PUSH
81051: LD_INT 0
81053: PUSH
81054: EMPTY
81055: LIST
81056: LIST
81057: PUSH
81058: LD_INT 3
81060: NEG
81061: PUSH
81062: LD_INT 1
81064: PUSH
81065: EMPTY
81066: LIST
81067: LIST
81068: PUSH
81069: LD_INT 4
81071: NEG
81072: PUSH
81073: LD_INT 1
81075: PUSH
81076: EMPTY
81077: LIST
81078: LIST
81079: PUSH
81080: LD_INT 5
81082: NEG
81083: PUSH
81084: LD_INT 0
81086: PUSH
81087: EMPTY
81088: LIST
81089: LIST
81090: PUSH
81091: LD_INT 5
81093: NEG
81094: PUSH
81095: LD_INT 1
81097: NEG
81098: PUSH
81099: EMPTY
81100: LIST
81101: LIST
81102: PUSH
81103: LD_INT 5
81105: NEG
81106: PUSH
81107: LD_INT 2
81109: NEG
81110: PUSH
81111: EMPTY
81112: LIST
81113: LIST
81114: PUSH
81115: LD_INT 3
81117: NEG
81118: PUSH
81119: LD_INT 2
81121: PUSH
81122: EMPTY
81123: LIST
81124: LIST
81125: PUSH
81126: EMPTY
81127: LIST
81128: LIST
81129: LIST
81130: LIST
81131: LIST
81132: LIST
81133: LIST
81134: LIST
81135: LIST
81136: LIST
81137: LIST
81138: LIST
81139: LIST
81140: LIST
81141: LIST
81142: LIST
81143: LIST
81144: LIST
81145: LIST
81146: LIST
81147: LIST
81148: LIST
81149: LIST
81150: LIST
81151: LIST
81152: LIST
81153: LIST
81154: LIST
81155: LIST
81156: LIST
81157: LIST
81158: LIST
81159: LIST
81160: LIST
81161: LIST
81162: LIST
81163: LIST
81164: LIST
81165: LIST
81166: LIST
81167: LIST
81168: LIST
81169: LIST
81170: LIST
81171: LIST
81172: ST_TO_ADDR
// end ; end ;
81173: GO 81176
81175: POP
// case btype of b_depot , b_warehouse :
81176: LD_VAR 0 1
81180: PUSH
81181: LD_INT 0
81183: DOUBLE
81184: EQUAL
81185: IFTRUE 81195
81187: LD_INT 1
81189: DOUBLE
81190: EQUAL
81191: IFTRUE 81195
81193: GO 81396
81195: POP
// case nation of nation_american :
81196: LD_VAR 0 5
81200: PUSH
81201: LD_INT 1
81203: DOUBLE
81204: EQUAL
81205: IFTRUE 81209
81207: GO 81265
81209: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
81210: LD_ADDR_VAR 0 9
81214: PUSH
81215: LD_VAR 0 11
81219: PUSH
81220: LD_VAR 0 12
81224: PUSH
81225: LD_VAR 0 13
81229: PUSH
81230: LD_VAR 0 14
81234: PUSH
81235: LD_VAR 0 15
81239: PUSH
81240: LD_VAR 0 16
81244: PUSH
81245: EMPTY
81246: LIST
81247: LIST
81248: LIST
81249: LIST
81250: LIST
81251: LIST
81252: PUSH
81253: LD_VAR 0 4
81257: PUSH
81258: LD_INT 1
81260: PLUS
81261: ARRAY
81262: ST_TO_ADDR
81263: GO 81394
81265: LD_INT 2
81267: DOUBLE
81268: EQUAL
81269: IFTRUE 81273
81271: GO 81329
81273: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
81274: LD_ADDR_VAR 0 9
81278: PUSH
81279: LD_VAR 0 17
81283: PUSH
81284: LD_VAR 0 18
81288: PUSH
81289: LD_VAR 0 19
81293: PUSH
81294: LD_VAR 0 20
81298: PUSH
81299: LD_VAR 0 21
81303: PUSH
81304: LD_VAR 0 22
81308: PUSH
81309: EMPTY
81310: LIST
81311: LIST
81312: LIST
81313: LIST
81314: LIST
81315: LIST
81316: PUSH
81317: LD_VAR 0 4
81321: PUSH
81322: LD_INT 1
81324: PLUS
81325: ARRAY
81326: ST_TO_ADDR
81327: GO 81394
81329: LD_INT 3
81331: DOUBLE
81332: EQUAL
81333: IFTRUE 81337
81335: GO 81393
81337: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
81338: LD_ADDR_VAR 0 9
81342: PUSH
81343: LD_VAR 0 23
81347: PUSH
81348: LD_VAR 0 24
81352: PUSH
81353: LD_VAR 0 25
81357: PUSH
81358: LD_VAR 0 26
81362: PUSH
81363: LD_VAR 0 27
81367: PUSH
81368: LD_VAR 0 28
81372: PUSH
81373: EMPTY
81374: LIST
81375: LIST
81376: LIST
81377: LIST
81378: LIST
81379: LIST
81380: PUSH
81381: LD_VAR 0 4
81385: PUSH
81386: LD_INT 1
81388: PLUS
81389: ARRAY
81390: ST_TO_ADDR
81391: GO 81394
81393: POP
81394: GO 81949
81396: LD_INT 2
81398: DOUBLE
81399: EQUAL
81400: IFTRUE 81410
81402: LD_INT 3
81404: DOUBLE
81405: EQUAL
81406: IFTRUE 81410
81408: GO 81466
81410: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
81411: LD_ADDR_VAR 0 9
81415: PUSH
81416: LD_VAR 0 29
81420: PUSH
81421: LD_VAR 0 30
81425: PUSH
81426: LD_VAR 0 31
81430: PUSH
81431: LD_VAR 0 32
81435: PUSH
81436: LD_VAR 0 33
81440: PUSH
81441: LD_VAR 0 34
81445: PUSH
81446: EMPTY
81447: LIST
81448: LIST
81449: LIST
81450: LIST
81451: LIST
81452: LIST
81453: PUSH
81454: LD_VAR 0 4
81458: PUSH
81459: LD_INT 1
81461: PLUS
81462: ARRAY
81463: ST_TO_ADDR
81464: GO 81949
81466: LD_INT 16
81468: DOUBLE
81469: EQUAL
81470: IFTRUE 81528
81472: LD_INT 17
81474: DOUBLE
81475: EQUAL
81476: IFTRUE 81528
81478: LD_INT 18
81480: DOUBLE
81481: EQUAL
81482: IFTRUE 81528
81484: LD_INT 19
81486: DOUBLE
81487: EQUAL
81488: IFTRUE 81528
81490: LD_INT 22
81492: DOUBLE
81493: EQUAL
81494: IFTRUE 81528
81496: LD_INT 20
81498: DOUBLE
81499: EQUAL
81500: IFTRUE 81528
81502: LD_INT 21
81504: DOUBLE
81505: EQUAL
81506: IFTRUE 81528
81508: LD_INT 23
81510: DOUBLE
81511: EQUAL
81512: IFTRUE 81528
81514: LD_INT 24
81516: DOUBLE
81517: EQUAL
81518: IFTRUE 81528
81520: LD_INT 25
81522: DOUBLE
81523: EQUAL
81524: IFTRUE 81528
81526: GO 81584
81528: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
81529: LD_ADDR_VAR 0 9
81533: PUSH
81534: LD_VAR 0 35
81538: PUSH
81539: LD_VAR 0 36
81543: PUSH
81544: LD_VAR 0 37
81548: PUSH
81549: LD_VAR 0 38
81553: PUSH
81554: LD_VAR 0 39
81558: PUSH
81559: LD_VAR 0 40
81563: PUSH
81564: EMPTY
81565: LIST
81566: LIST
81567: LIST
81568: LIST
81569: LIST
81570: LIST
81571: PUSH
81572: LD_VAR 0 4
81576: PUSH
81577: LD_INT 1
81579: PLUS
81580: ARRAY
81581: ST_TO_ADDR
81582: GO 81949
81584: LD_INT 6
81586: DOUBLE
81587: EQUAL
81588: IFTRUE 81640
81590: LD_INT 7
81592: DOUBLE
81593: EQUAL
81594: IFTRUE 81640
81596: LD_INT 8
81598: DOUBLE
81599: EQUAL
81600: IFTRUE 81640
81602: LD_INT 13
81604: DOUBLE
81605: EQUAL
81606: IFTRUE 81640
81608: LD_INT 12
81610: DOUBLE
81611: EQUAL
81612: IFTRUE 81640
81614: LD_INT 15
81616: DOUBLE
81617: EQUAL
81618: IFTRUE 81640
81620: LD_INT 11
81622: DOUBLE
81623: EQUAL
81624: IFTRUE 81640
81626: LD_INT 14
81628: DOUBLE
81629: EQUAL
81630: IFTRUE 81640
81632: LD_INT 10
81634: DOUBLE
81635: EQUAL
81636: IFTRUE 81640
81638: GO 81696
81640: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
81641: LD_ADDR_VAR 0 9
81645: PUSH
81646: LD_VAR 0 41
81650: PUSH
81651: LD_VAR 0 42
81655: PUSH
81656: LD_VAR 0 43
81660: PUSH
81661: LD_VAR 0 44
81665: PUSH
81666: LD_VAR 0 45
81670: PUSH
81671: LD_VAR 0 46
81675: PUSH
81676: EMPTY
81677: LIST
81678: LIST
81679: LIST
81680: LIST
81681: LIST
81682: LIST
81683: PUSH
81684: LD_VAR 0 4
81688: PUSH
81689: LD_INT 1
81691: PLUS
81692: ARRAY
81693: ST_TO_ADDR
81694: GO 81949
81696: LD_INT 36
81698: DOUBLE
81699: EQUAL
81700: IFTRUE 81704
81702: GO 81760
81704: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
81705: LD_ADDR_VAR 0 9
81709: PUSH
81710: LD_VAR 0 47
81714: PUSH
81715: LD_VAR 0 48
81719: PUSH
81720: LD_VAR 0 49
81724: PUSH
81725: LD_VAR 0 50
81729: PUSH
81730: LD_VAR 0 51
81734: PUSH
81735: LD_VAR 0 52
81739: PUSH
81740: EMPTY
81741: LIST
81742: LIST
81743: LIST
81744: LIST
81745: LIST
81746: LIST
81747: PUSH
81748: LD_VAR 0 4
81752: PUSH
81753: LD_INT 1
81755: PLUS
81756: ARRAY
81757: ST_TO_ADDR
81758: GO 81949
81760: LD_INT 4
81762: DOUBLE
81763: EQUAL
81764: IFTRUE 81786
81766: LD_INT 5
81768: DOUBLE
81769: EQUAL
81770: IFTRUE 81786
81772: LD_INT 34
81774: DOUBLE
81775: EQUAL
81776: IFTRUE 81786
81778: LD_INT 37
81780: DOUBLE
81781: EQUAL
81782: IFTRUE 81786
81784: GO 81842
81786: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
81787: LD_ADDR_VAR 0 9
81791: PUSH
81792: LD_VAR 0 53
81796: PUSH
81797: LD_VAR 0 54
81801: PUSH
81802: LD_VAR 0 55
81806: PUSH
81807: LD_VAR 0 56
81811: PUSH
81812: LD_VAR 0 57
81816: PUSH
81817: LD_VAR 0 58
81821: PUSH
81822: EMPTY
81823: LIST
81824: LIST
81825: LIST
81826: LIST
81827: LIST
81828: LIST
81829: PUSH
81830: LD_VAR 0 4
81834: PUSH
81835: LD_INT 1
81837: PLUS
81838: ARRAY
81839: ST_TO_ADDR
81840: GO 81949
81842: LD_INT 31
81844: DOUBLE
81845: EQUAL
81846: IFTRUE 81892
81848: LD_INT 32
81850: DOUBLE
81851: EQUAL
81852: IFTRUE 81892
81854: LD_INT 33
81856: DOUBLE
81857: EQUAL
81858: IFTRUE 81892
81860: LD_INT 27
81862: DOUBLE
81863: EQUAL
81864: IFTRUE 81892
81866: LD_INT 26
81868: DOUBLE
81869: EQUAL
81870: IFTRUE 81892
81872: LD_INT 28
81874: DOUBLE
81875: EQUAL
81876: IFTRUE 81892
81878: LD_INT 29
81880: DOUBLE
81881: EQUAL
81882: IFTRUE 81892
81884: LD_INT 30
81886: DOUBLE
81887: EQUAL
81888: IFTRUE 81892
81890: GO 81948
81892: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
81893: LD_ADDR_VAR 0 9
81897: PUSH
81898: LD_VAR 0 59
81902: PUSH
81903: LD_VAR 0 60
81907: PUSH
81908: LD_VAR 0 61
81912: PUSH
81913: LD_VAR 0 62
81917: PUSH
81918: LD_VAR 0 63
81922: PUSH
81923: LD_VAR 0 64
81927: PUSH
81928: EMPTY
81929: LIST
81930: LIST
81931: LIST
81932: LIST
81933: LIST
81934: LIST
81935: PUSH
81936: LD_VAR 0 4
81940: PUSH
81941: LD_INT 1
81943: PLUS
81944: ARRAY
81945: ST_TO_ADDR
81946: GO 81949
81948: POP
// temp_list2 = [ ] ;
81949: LD_ADDR_VAR 0 10
81953: PUSH
81954: EMPTY
81955: ST_TO_ADDR
// for i in temp_list do
81956: LD_ADDR_VAR 0 8
81960: PUSH
81961: LD_VAR 0 9
81965: PUSH
81966: FOR_IN
81967: IFFALSE 82019
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
81969: LD_ADDR_VAR 0 10
81973: PUSH
81974: LD_VAR 0 10
81978: PUSH
81979: LD_VAR 0 8
81983: PUSH
81984: LD_INT 1
81986: ARRAY
81987: PUSH
81988: LD_VAR 0 2
81992: PLUS
81993: PUSH
81994: LD_VAR 0 8
81998: PUSH
81999: LD_INT 2
82001: ARRAY
82002: PUSH
82003: LD_VAR 0 3
82007: PLUS
82008: PUSH
82009: EMPTY
82010: LIST
82011: LIST
82012: PUSH
82013: EMPTY
82014: LIST
82015: ADD
82016: ST_TO_ADDR
82017: GO 81966
82019: POP
82020: POP
// result = temp_list2 ;
82021: LD_ADDR_VAR 0 7
82025: PUSH
82026: LD_VAR 0 10
82030: ST_TO_ADDR
// end ;
82031: LD_VAR 0 7
82035: RET
// export function EnemyInRange ( unit , dist ) ; begin
82036: LD_INT 0
82038: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
82039: LD_ADDR_VAR 0 3
82043: PUSH
82044: LD_VAR 0 1
82048: PPUSH
82049: CALL_OW 255
82053: PPUSH
82054: LD_VAR 0 1
82058: PPUSH
82059: CALL_OW 250
82063: PPUSH
82064: LD_VAR 0 1
82068: PPUSH
82069: CALL_OW 251
82073: PPUSH
82074: LD_VAR 0 2
82078: PPUSH
82079: CALL 55409 0 4
82083: PUSH
82084: LD_INT 4
82086: ARRAY
82087: ST_TO_ADDR
// end ;
82088: LD_VAR 0 3
82092: RET
// export function PlayerSeeMe ( unit ) ; begin
82093: LD_INT 0
82095: PPUSH
// result := See ( your_side , unit ) ;
82096: LD_ADDR_VAR 0 2
82100: PUSH
82101: LD_OWVAR 2
82105: PPUSH
82106: LD_VAR 0 1
82110: PPUSH
82111: CALL_OW 292
82115: ST_TO_ADDR
// end ;
82116: LD_VAR 0 2
82120: RET
// export function ReverseDir ( unit ) ; begin
82121: LD_INT 0
82123: PPUSH
// if not unit then
82124: LD_VAR 0 1
82128: NOT
82129: IFFALSE 82133
// exit ;
82131: GO 82156
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
82133: LD_ADDR_VAR 0 2
82137: PUSH
82138: LD_VAR 0 1
82142: PPUSH
82143: CALL_OW 254
82147: PUSH
82148: LD_INT 3
82150: PLUS
82151: PUSH
82152: LD_INT 6
82154: MOD
82155: ST_TO_ADDR
// end ;
82156: LD_VAR 0 2
82160: RET
// export function ReverseArray ( array ) ; var i ; begin
82161: LD_INT 0
82163: PPUSH
82164: PPUSH
// if not array then
82165: LD_VAR 0 1
82169: NOT
82170: IFFALSE 82174
// exit ;
82172: GO 82229
// result := [ ] ;
82174: LD_ADDR_VAR 0 2
82178: PUSH
82179: EMPTY
82180: ST_TO_ADDR
// for i := array downto 1 do
82181: LD_ADDR_VAR 0 3
82185: PUSH
82186: DOUBLE
82187: LD_VAR 0 1
82191: INC
82192: ST_TO_ADDR
82193: LD_INT 1
82195: PUSH
82196: FOR_DOWNTO
82197: IFFALSE 82227
// result := Join ( result , array [ i ] ) ;
82199: LD_ADDR_VAR 0 2
82203: PUSH
82204: LD_VAR 0 2
82208: PPUSH
82209: LD_VAR 0 1
82213: PUSH
82214: LD_VAR 0 3
82218: ARRAY
82219: PPUSH
82220: CALL 86874 0 2
82224: ST_TO_ADDR
82225: GO 82196
82227: POP
82228: POP
// end ;
82229: LD_VAR 0 2
82233: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
82234: LD_INT 0
82236: PPUSH
82237: PPUSH
82238: PPUSH
82239: PPUSH
82240: PPUSH
82241: PPUSH
// if not unit or not hexes then
82242: LD_VAR 0 1
82246: NOT
82247: PUSH
82248: LD_VAR 0 2
82252: NOT
82253: OR
82254: IFFALSE 82258
// exit ;
82256: GO 82381
// dist := 9999 ;
82258: LD_ADDR_VAR 0 5
82262: PUSH
82263: LD_INT 9999
82265: ST_TO_ADDR
// for i = 1 to hexes do
82266: LD_ADDR_VAR 0 4
82270: PUSH
82271: DOUBLE
82272: LD_INT 1
82274: DEC
82275: ST_TO_ADDR
82276: LD_VAR 0 2
82280: PUSH
82281: FOR_TO
82282: IFFALSE 82369
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
82284: LD_ADDR_VAR 0 6
82288: PUSH
82289: LD_VAR 0 1
82293: PPUSH
82294: LD_VAR 0 2
82298: PUSH
82299: LD_VAR 0 4
82303: ARRAY
82304: PUSH
82305: LD_INT 1
82307: ARRAY
82308: PPUSH
82309: LD_VAR 0 2
82313: PUSH
82314: LD_VAR 0 4
82318: ARRAY
82319: PUSH
82320: LD_INT 2
82322: ARRAY
82323: PPUSH
82324: CALL_OW 297
82328: ST_TO_ADDR
// if tdist < dist then
82329: LD_VAR 0 6
82333: PUSH
82334: LD_VAR 0 5
82338: LESS
82339: IFFALSE 82367
// begin hex := hexes [ i ] ;
82341: LD_ADDR_VAR 0 8
82345: PUSH
82346: LD_VAR 0 2
82350: PUSH
82351: LD_VAR 0 4
82355: ARRAY
82356: ST_TO_ADDR
// dist := tdist ;
82357: LD_ADDR_VAR 0 5
82361: PUSH
82362: LD_VAR 0 6
82366: ST_TO_ADDR
// end ; end ;
82367: GO 82281
82369: POP
82370: POP
// result := hex ;
82371: LD_ADDR_VAR 0 3
82375: PUSH
82376: LD_VAR 0 8
82380: ST_TO_ADDR
// end ;
82381: LD_VAR 0 3
82385: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
82386: LD_INT 0
82388: PPUSH
82389: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
82390: LD_VAR 0 1
82394: NOT
82395: PUSH
82396: LD_VAR 0 1
82400: PUSH
82401: LD_INT 21
82403: PUSH
82404: LD_INT 2
82406: PUSH
82407: EMPTY
82408: LIST
82409: LIST
82410: PUSH
82411: LD_INT 23
82413: PUSH
82414: LD_INT 2
82416: PUSH
82417: EMPTY
82418: LIST
82419: LIST
82420: PUSH
82421: EMPTY
82422: LIST
82423: LIST
82424: PPUSH
82425: CALL_OW 69
82429: IN
82430: NOT
82431: OR
82432: IFFALSE 82436
// exit ;
82434: GO 82483
// for i = 1 to 3 do
82436: LD_ADDR_VAR 0 3
82440: PUSH
82441: DOUBLE
82442: LD_INT 1
82444: DEC
82445: ST_TO_ADDR
82446: LD_INT 3
82448: PUSH
82449: FOR_TO
82450: IFFALSE 82481
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
82452: LD_VAR 0 1
82456: PPUSH
82457: CALL_OW 250
82461: PPUSH
82462: LD_VAR 0 1
82466: PPUSH
82467: CALL_OW 251
82471: PPUSH
82472: LD_INT 1
82474: PPUSH
82475: CALL_OW 453
82479: GO 82449
82481: POP
82482: POP
// end ;
82483: LD_VAR 0 2
82487: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
82488: LD_INT 0
82490: PPUSH
82491: PPUSH
82492: PPUSH
82493: PPUSH
82494: PPUSH
82495: PPUSH
// if not unit or not enemy_unit then
82496: LD_VAR 0 1
82500: NOT
82501: PUSH
82502: LD_VAR 0 2
82506: NOT
82507: OR
82508: IFFALSE 82512
// exit ;
82510: GO 82979
// if GetLives ( i ) < 250 then
82512: LD_VAR 0 4
82516: PPUSH
82517: CALL_OW 256
82521: PUSH
82522: LD_INT 250
82524: LESS
82525: IFFALSE 82538
// begin ComAutodestruct ( i ) ;
82527: LD_VAR 0 4
82531: PPUSH
82532: CALL 82386 0 1
// exit ;
82536: GO 82979
// end ; x := GetX ( enemy_unit ) ;
82538: LD_ADDR_VAR 0 7
82542: PUSH
82543: LD_VAR 0 2
82547: PPUSH
82548: CALL_OW 250
82552: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
82553: LD_ADDR_VAR 0 8
82557: PUSH
82558: LD_VAR 0 2
82562: PPUSH
82563: CALL_OW 251
82567: ST_TO_ADDR
// if not x or not y then
82568: LD_VAR 0 7
82572: NOT
82573: PUSH
82574: LD_VAR 0 8
82578: NOT
82579: OR
82580: IFFALSE 82584
// exit ;
82582: GO 82979
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
82584: LD_ADDR_VAR 0 6
82588: PUSH
82589: LD_VAR 0 7
82593: PPUSH
82594: LD_INT 0
82596: PPUSH
82597: LD_INT 4
82599: PPUSH
82600: CALL_OW 272
82604: PUSH
82605: LD_VAR 0 8
82609: PPUSH
82610: LD_INT 0
82612: PPUSH
82613: LD_INT 4
82615: PPUSH
82616: CALL_OW 273
82620: PUSH
82621: EMPTY
82622: LIST
82623: LIST
82624: PUSH
82625: LD_VAR 0 7
82629: PPUSH
82630: LD_INT 1
82632: PPUSH
82633: LD_INT 4
82635: PPUSH
82636: CALL_OW 272
82640: PUSH
82641: LD_VAR 0 8
82645: PPUSH
82646: LD_INT 1
82648: PPUSH
82649: LD_INT 4
82651: PPUSH
82652: CALL_OW 273
82656: PUSH
82657: EMPTY
82658: LIST
82659: LIST
82660: PUSH
82661: LD_VAR 0 7
82665: PPUSH
82666: LD_INT 2
82668: PPUSH
82669: LD_INT 4
82671: PPUSH
82672: CALL_OW 272
82676: PUSH
82677: LD_VAR 0 8
82681: PPUSH
82682: LD_INT 2
82684: PPUSH
82685: LD_INT 4
82687: PPUSH
82688: CALL_OW 273
82692: PUSH
82693: EMPTY
82694: LIST
82695: LIST
82696: PUSH
82697: LD_VAR 0 7
82701: PPUSH
82702: LD_INT 3
82704: PPUSH
82705: LD_INT 4
82707: PPUSH
82708: CALL_OW 272
82712: PUSH
82713: LD_VAR 0 8
82717: PPUSH
82718: LD_INT 3
82720: PPUSH
82721: LD_INT 4
82723: PPUSH
82724: CALL_OW 273
82728: PUSH
82729: EMPTY
82730: LIST
82731: LIST
82732: PUSH
82733: LD_VAR 0 7
82737: PPUSH
82738: LD_INT 4
82740: PPUSH
82741: LD_INT 4
82743: PPUSH
82744: CALL_OW 272
82748: PUSH
82749: LD_VAR 0 8
82753: PPUSH
82754: LD_INT 4
82756: PPUSH
82757: LD_INT 4
82759: PPUSH
82760: CALL_OW 273
82764: PUSH
82765: EMPTY
82766: LIST
82767: LIST
82768: PUSH
82769: LD_VAR 0 7
82773: PPUSH
82774: LD_INT 5
82776: PPUSH
82777: LD_INT 4
82779: PPUSH
82780: CALL_OW 272
82784: PUSH
82785: LD_VAR 0 8
82789: PPUSH
82790: LD_INT 5
82792: PPUSH
82793: LD_INT 4
82795: PPUSH
82796: CALL_OW 273
82800: PUSH
82801: EMPTY
82802: LIST
82803: LIST
82804: PUSH
82805: EMPTY
82806: LIST
82807: LIST
82808: LIST
82809: LIST
82810: LIST
82811: LIST
82812: ST_TO_ADDR
// for i = tmp downto 1 do
82813: LD_ADDR_VAR 0 4
82817: PUSH
82818: DOUBLE
82819: LD_VAR 0 6
82823: INC
82824: ST_TO_ADDR
82825: LD_INT 1
82827: PUSH
82828: FOR_DOWNTO
82829: IFFALSE 82930
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
82831: LD_VAR 0 6
82835: PUSH
82836: LD_VAR 0 4
82840: ARRAY
82841: PUSH
82842: LD_INT 1
82844: ARRAY
82845: PPUSH
82846: LD_VAR 0 6
82850: PUSH
82851: LD_VAR 0 4
82855: ARRAY
82856: PUSH
82857: LD_INT 2
82859: ARRAY
82860: PPUSH
82861: CALL_OW 488
82865: NOT
82866: PUSH
82867: LD_VAR 0 6
82871: PUSH
82872: LD_VAR 0 4
82876: ARRAY
82877: PUSH
82878: LD_INT 1
82880: ARRAY
82881: PPUSH
82882: LD_VAR 0 6
82886: PUSH
82887: LD_VAR 0 4
82891: ARRAY
82892: PUSH
82893: LD_INT 2
82895: ARRAY
82896: PPUSH
82897: CALL_OW 428
82901: PUSH
82902: LD_INT 0
82904: NONEQUAL
82905: OR
82906: IFFALSE 82928
// tmp := Delete ( tmp , i ) ;
82908: LD_ADDR_VAR 0 6
82912: PUSH
82913: LD_VAR 0 6
82917: PPUSH
82918: LD_VAR 0 4
82922: PPUSH
82923: CALL_OW 3
82927: ST_TO_ADDR
82928: GO 82828
82930: POP
82931: POP
// j := GetClosestHex ( unit , tmp ) ;
82932: LD_ADDR_VAR 0 5
82936: PUSH
82937: LD_VAR 0 1
82941: PPUSH
82942: LD_VAR 0 6
82946: PPUSH
82947: CALL 82234 0 2
82951: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
82952: LD_VAR 0 1
82956: PPUSH
82957: LD_VAR 0 5
82961: PUSH
82962: LD_INT 1
82964: ARRAY
82965: PPUSH
82966: LD_VAR 0 5
82970: PUSH
82971: LD_INT 2
82973: ARRAY
82974: PPUSH
82975: CALL_OW 111
// end ;
82979: LD_VAR 0 3
82983: RET
// export function PrepareApemanSoldier ( ) ; begin
82984: LD_INT 0
82986: PPUSH
// uc_nation := 0 ;
82987: LD_ADDR_OWVAR 21
82991: PUSH
82992: LD_INT 0
82994: ST_TO_ADDR
// hc_sex := sex_male ;
82995: LD_ADDR_OWVAR 27
82999: PUSH
83000: LD_INT 1
83002: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
83003: LD_ADDR_OWVAR 28
83007: PUSH
83008: LD_INT 15
83010: ST_TO_ADDR
// hc_gallery :=  ;
83011: LD_ADDR_OWVAR 33
83015: PUSH
83016: LD_STRING 
83018: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
83019: LD_ADDR_OWVAR 31
83023: PUSH
83024: LD_INT 0
83026: PPUSH
83027: LD_INT 3
83029: PPUSH
83030: CALL_OW 12
83034: PUSH
83035: LD_INT 0
83037: PPUSH
83038: LD_INT 3
83040: PPUSH
83041: CALL_OW 12
83045: PUSH
83046: LD_INT 0
83048: PUSH
83049: LD_INT 0
83051: PUSH
83052: EMPTY
83053: LIST
83054: LIST
83055: LIST
83056: LIST
83057: ST_TO_ADDR
// end ;
83058: LD_VAR 0 1
83062: RET
// export function PrepareApemanEngineer ( ) ; begin
83063: LD_INT 0
83065: PPUSH
// uc_nation := 0 ;
83066: LD_ADDR_OWVAR 21
83070: PUSH
83071: LD_INT 0
83073: ST_TO_ADDR
// hc_sex := sex_male ;
83074: LD_ADDR_OWVAR 27
83078: PUSH
83079: LD_INT 1
83081: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
83082: LD_ADDR_OWVAR 28
83086: PUSH
83087: LD_INT 16
83089: ST_TO_ADDR
// hc_gallery :=  ;
83090: LD_ADDR_OWVAR 33
83094: PUSH
83095: LD_STRING 
83097: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
83098: LD_ADDR_OWVAR 31
83102: PUSH
83103: LD_INT 0
83105: PPUSH
83106: LD_INT 3
83108: PPUSH
83109: CALL_OW 12
83113: PUSH
83114: LD_INT 0
83116: PPUSH
83117: LD_INT 3
83119: PPUSH
83120: CALL_OW 12
83124: PUSH
83125: LD_INT 0
83127: PUSH
83128: LD_INT 0
83130: PUSH
83131: EMPTY
83132: LIST
83133: LIST
83134: LIST
83135: LIST
83136: ST_TO_ADDR
// end ;
83137: LD_VAR 0 1
83141: RET
// export function PrepareApeman ( agressivity ) ; begin
83142: LD_INT 0
83144: PPUSH
// uc_side := 0 ;
83145: LD_ADDR_OWVAR 20
83149: PUSH
83150: LD_INT 0
83152: ST_TO_ADDR
// uc_nation := 0 ;
83153: LD_ADDR_OWVAR 21
83157: PUSH
83158: LD_INT 0
83160: ST_TO_ADDR
// hc_sex := sex_male ;
83161: LD_ADDR_OWVAR 27
83165: PUSH
83166: LD_INT 1
83168: ST_TO_ADDR
// hc_class := class_apeman ;
83169: LD_ADDR_OWVAR 28
83173: PUSH
83174: LD_INT 12
83176: ST_TO_ADDR
// hc_gallery :=  ;
83177: LD_ADDR_OWVAR 33
83181: PUSH
83182: LD_STRING 
83184: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
83185: LD_ADDR_OWVAR 35
83189: PUSH
83190: LD_VAR 0 1
83194: NEG
83195: PPUSH
83196: LD_VAR 0 1
83200: PPUSH
83201: CALL_OW 12
83205: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
83206: LD_ADDR_OWVAR 31
83210: PUSH
83211: LD_INT 0
83213: PPUSH
83214: LD_INT 3
83216: PPUSH
83217: CALL_OW 12
83221: PUSH
83222: LD_INT 0
83224: PPUSH
83225: LD_INT 3
83227: PPUSH
83228: CALL_OW 12
83232: PUSH
83233: LD_INT 0
83235: PUSH
83236: LD_INT 0
83238: PUSH
83239: EMPTY
83240: LIST
83241: LIST
83242: LIST
83243: LIST
83244: ST_TO_ADDR
// end ;
83245: LD_VAR 0 2
83249: RET
// export function PrepareTiger ( agressivity ) ; begin
83250: LD_INT 0
83252: PPUSH
// uc_side := 0 ;
83253: LD_ADDR_OWVAR 20
83257: PUSH
83258: LD_INT 0
83260: ST_TO_ADDR
// uc_nation := 0 ;
83261: LD_ADDR_OWVAR 21
83265: PUSH
83266: LD_INT 0
83268: ST_TO_ADDR
// hc_class := class_tiger ;
83269: LD_ADDR_OWVAR 28
83273: PUSH
83274: LD_INT 14
83276: ST_TO_ADDR
// hc_gallery :=  ;
83277: LD_ADDR_OWVAR 33
83281: PUSH
83282: LD_STRING 
83284: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
83285: LD_ADDR_OWVAR 35
83289: PUSH
83290: LD_VAR 0 1
83294: NEG
83295: PPUSH
83296: LD_VAR 0 1
83300: PPUSH
83301: CALL_OW 12
83305: ST_TO_ADDR
// end ;
83306: LD_VAR 0 2
83310: RET
// export function PrepareEnchidna ( ) ; begin
83311: LD_INT 0
83313: PPUSH
// uc_side := 0 ;
83314: LD_ADDR_OWVAR 20
83318: PUSH
83319: LD_INT 0
83321: ST_TO_ADDR
// uc_nation := 0 ;
83322: LD_ADDR_OWVAR 21
83326: PUSH
83327: LD_INT 0
83329: ST_TO_ADDR
// hc_class := class_baggie ;
83330: LD_ADDR_OWVAR 28
83334: PUSH
83335: LD_INT 13
83337: ST_TO_ADDR
// hc_gallery :=  ;
83338: LD_ADDR_OWVAR 33
83342: PUSH
83343: LD_STRING 
83345: ST_TO_ADDR
// end ;
83346: LD_VAR 0 1
83350: RET
// export function PrepareFrog ( ) ; begin
83351: LD_INT 0
83353: PPUSH
// uc_side := 0 ;
83354: LD_ADDR_OWVAR 20
83358: PUSH
83359: LD_INT 0
83361: ST_TO_ADDR
// uc_nation := 0 ;
83362: LD_ADDR_OWVAR 21
83366: PUSH
83367: LD_INT 0
83369: ST_TO_ADDR
// hc_class := class_frog ;
83370: LD_ADDR_OWVAR 28
83374: PUSH
83375: LD_INT 19
83377: ST_TO_ADDR
// hc_gallery :=  ;
83378: LD_ADDR_OWVAR 33
83382: PUSH
83383: LD_STRING 
83385: ST_TO_ADDR
// end ;
83386: LD_VAR 0 1
83390: RET
// export function PrepareFish ( ) ; begin
83391: LD_INT 0
83393: PPUSH
// uc_side := 0 ;
83394: LD_ADDR_OWVAR 20
83398: PUSH
83399: LD_INT 0
83401: ST_TO_ADDR
// uc_nation := 0 ;
83402: LD_ADDR_OWVAR 21
83406: PUSH
83407: LD_INT 0
83409: ST_TO_ADDR
// hc_class := class_fish ;
83410: LD_ADDR_OWVAR 28
83414: PUSH
83415: LD_INT 20
83417: ST_TO_ADDR
// hc_gallery :=  ;
83418: LD_ADDR_OWVAR 33
83422: PUSH
83423: LD_STRING 
83425: ST_TO_ADDR
// end ;
83426: LD_VAR 0 1
83430: RET
// export function PrepareBird ( ) ; begin
83431: LD_INT 0
83433: PPUSH
// uc_side := 0 ;
83434: LD_ADDR_OWVAR 20
83438: PUSH
83439: LD_INT 0
83441: ST_TO_ADDR
// uc_nation := 0 ;
83442: LD_ADDR_OWVAR 21
83446: PUSH
83447: LD_INT 0
83449: ST_TO_ADDR
// hc_class := class_phororhacos ;
83450: LD_ADDR_OWVAR 28
83454: PUSH
83455: LD_INT 18
83457: ST_TO_ADDR
// hc_gallery :=  ;
83458: LD_ADDR_OWVAR 33
83462: PUSH
83463: LD_STRING 
83465: ST_TO_ADDR
// end ;
83466: LD_VAR 0 1
83470: RET
// export function PrepareHorse ( ) ; begin
83471: LD_INT 0
83473: PPUSH
// uc_side := 0 ;
83474: LD_ADDR_OWVAR 20
83478: PUSH
83479: LD_INT 0
83481: ST_TO_ADDR
// uc_nation := 0 ;
83482: LD_ADDR_OWVAR 21
83486: PUSH
83487: LD_INT 0
83489: ST_TO_ADDR
// hc_class := class_horse ;
83490: LD_ADDR_OWVAR 28
83494: PUSH
83495: LD_INT 21
83497: ST_TO_ADDR
// hc_gallery :=  ;
83498: LD_ADDR_OWVAR 33
83502: PUSH
83503: LD_STRING 
83505: ST_TO_ADDR
// end ;
83506: LD_VAR 0 1
83510: RET
// export function PrepareMastodont ( ) ; begin
83511: LD_INT 0
83513: PPUSH
// uc_side := 0 ;
83514: LD_ADDR_OWVAR 20
83518: PUSH
83519: LD_INT 0
83521: ST_TO_ADDR
// uc_nation := 0 ;
83522: LD_ADDR_OWVAR 21
83526: PUSH
83527: LD_INT 0
83529: ST_TO_ADDR
// vc_chassis := class_mastodont ;
83530: LD_ADDR_OWVAR 37
83534: PUSH
83535: LD_INT 31
83537: ST_TO_ADDR
// vc_control := control_rider ;
83538: LD_ADDR_OWVAR 38
83542: PUSH
83543: LD_INT 4
83545: ST_TO_ADDR
// end ;
83546: LD_VAR 0 1
83550: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
83551: LD_INT 0
83553: PPUSH
83554: PPUSH
83555: PPUSH
// uc_side = 0 ;
83556: LD_ADDR_OWVAR 20
83560: PUSH
83561: LD_INT 0
83563: ST_TO_ADDR
// uc_nation = 0 ;
83564: LD_ADDR_OWVAR 21
83568: PUSH
83569: LD_INT 0
83571: ST_TO_ADDR
// InitHc_All ( ) ;
83572: CALL_OW 584
// InitVc ;
83576: CALL_OW 20
// if mastodonts then
83580: LD_VAR 0 6
83584: IFFALSE 83651
// for i = 1 to mastodonts do
83586: LD_ADDR_VAR 0 11
83590: PUSH
83591: DOUBLE
83592: LD_INT 1
83594: DEC
83595: ST_TO_ADDR
83596: LD_VAR 0 6
83600: PUSH
83601: FOR_TO
83602: IFFALSE 83649
// begin vc_chassis := 31 ;
83604: LD_ADDR_OWVAR 37
83608: PUSH
83609: LD_INT 31
83611: ST_TO_ADDR
// vc_control := control_rider ;
83612: LD_ADDR_OWVAR 38
83616: PUSH
83617: LD_INT 4
83619: ST_TO_ADDR
// animal := CreateVehicle ;
83620: LD_ADDR_VAR 0 12
83624: PUSH
83625: CALL_OW 45
83629: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83630: LD_VAR 0 12
83634: PPUSH
83635: LD_VAR 0 8
83639: PPUSH
83640: LD_INT 0
83642: PPUSH
83643: CALL 85779 0 3
// end ;
83647: GO 83601
83649: POP
83650: POP
// if horses then
83651: LD_VAR 0 5
83655: IFFALSE 83722
// for i = 1 to horses do
83657: LD_ADDR_VAR 0 11
83661: PUSH
83662: DOUBLE
83663: LD_INT 1
83665: DEC
83666: ST_TO_ADDR
83667: LD_VAR 0 5
83671: PUSH
83672: FOR_TO
83673: IFFALSE 83720
// begin hc_class := 21 ;
83675: LD_ADDR_OWVAR 28
83679: PUSH
83680: LD_INT 21
83682: ST_TO_ADDR
// hc_gallery :=  ;
83683: LD_ADDR_OWVAR 33
83687: PUSH
83688: LD_STRING 
83690: ST_TO_ADDR
// animal := CreateHuman ;
83691: LD_ADDR_VAR 0 12
83695: PUSH
83696: CALL_OW 44
83700: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83701: LD_VAR 0 12
83705: PPUSH
83706: LD_VAR 0 8
83710: PPUSH
83711: LD_INT 0
83713: PPUSH
83714: CALL 85779 0 3
// end ;
83718: GO 83672
83720: POP
83721: POP
// if birds then
83722: LD_VAR 0 1
83726: IFFALSE 83793
// for i = 1 to birds do
83728: LD_ADDR_VAR 0 11
83732: PUSH
83733: DOUBLE
83734: LD_INT 1
83736: DEC
83737: ST_TO_ADDR
83738: LD_VAR 0 1
83742: PUSH
83743: FOR_TO
83744: IFFALSE 83791
// begin hc_class := 18 ;
83746: LD_ADDR_OWVAR 28
83750: PUSH
83751: LD_INT 18
83753: ST_TO_ADDR
// hc_gallery =  ;
83754: LD_ADDR_OWVAR 33
83758: PUSH
83759: LD_STRING 
83761: ST_TO_ADDR
// animal := CreateHuman ;
83762: LD_ADDR_VAR 0 12
83766: PUSH
83767: CALL_OW 44
83771: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83772: LD_VAR 0 12
83776: PPUSH
83777: LD_VAR 0 8
83781: PPUSH
83782: LD_INT 0
83784: PPUSH
83785: CALL 85779 0 3
// end ;
83789: GO 83743
83791: POP
83792: POP
// if tigers then
83793: LD_VAR 0 2
83797: IFFALSE 83881
// for i = 1 to tigers do
83799: LD_ADDR_VAR 0 11
83803: PUSH
83804: DOUBLE
83805: LD_INT 1
83807: DEC
83808: ST_TO_ADDR
83809: LD_VAR 0 2
83813: PUSH
83814: FOR_TO
83815: IFFALSE 83879
// begin hc_class = class_tiger ;
83817: LD_ADDR_OWVAR 28
83821: PUSH
83822: LD_INT 14
83824: ST_TO_ADDR
// hc_gallery =  ;
83825: LD_ADDR_OWVAR 33
83829: PUSH
83830: LD_STRING 
83832: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
83833: LD_ADDR_OWVAR 35
83837: PUSH
83838: LD_INT 7
83840: NEG
83841: PPUSH
83842: LD_INT 7
83844: PPUSH
83845: CALL_OW 12
83849: ST_TO_ADDR
// animal := CreateHuman ;
83850: LD_ADDR_VAR 0 12
83854: PUSH
83855: CALL_OW 44
83859: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83860: LD_VAR 0 12
83864: PPUSH
83865: LD_VAR 0 8
83869: PPUSH
83870: LD_INT 0
83872: PPUSH
83873: CALL 85779 0 3
// end ;
83877: GO 83814
83879: POP
83880: POP
// if apemans then
83881: LD_VAR 0 3
83885: IFFALSE 84008
// for i = 1 to apemans do
83887: LD_ADDR_VAR 0 11
83891: PUSH
83892: DOUBLE
83893: LD_INT 1
83895: DEC
83896: ST_TO_ADDR
83897: LD_VAR 0 3
83901: PUSH
83902: FOR_TO
83903: IFFALSE 84006
// begin hc_class = class_apeman ;
83905: LD_ADDR_OWVAR 28
83909: PUSH
83910: LD_INT 12
83912: ST_TO_ADDR
// hc_gallery =  ;
83913: LD_ADDR_OWVAR 33
83917: PUSH
83918: LD_STRING 
83920: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
83921: LD_ADDR_OWVAR 35
83925: PUSH
83926: LD_INT 2
83928: NEG
83929: PPUSH
83930: LD_INT 2
83932: PPUSH
83933: CALL_OW 12
83937: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
83938: LD_ADDR_OWVAR 31
83942: PUSH
83943: LD_INT 1
83945: PPUSH
83946: LD_INT 3
83948: PPUSH
83949: CALL_OW 12
83953: PUSH
83954: LD_INT 1
83956: PPUSH
83957: LD_INT 3
83959: PPUSH
83960: CALL_OW 12
83964: PUSH
83965: LD_INT 0
83967: PUSH
83968: LD_INT 0
83970: PUSH
83971: EMPTY
83972: LIST
83973: LIST
83974: LIST
83975: LIST
83976: ST_TO_ADDR
// animal := CreateHuman ;
83977: LD_ADDR_VAR 0 12
83981: PUSH
83982: CALL_OW 44
83986: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83987: LD_VAR 0 12
83991: PPUSH
83992: LD_VAR 0 8
83996: PPUSH
83997: LD_INT 0
83999: PPUSH
84000: CALL 85779 0 3
// end ;
84004: GO 83902
84006: POP
84007: POP
// if enchidnas then
84008: LD_VAR 0 4
84012: IFFALSE 84079
// for i = 1 to enchidnas do
84014: LD_ADDR_VAR 0 11
84018: PUSH
84019: DOUBLE
84020: LD_INT 1
84022: DEC
84023: ST_TO_ADDR
84024: LD_VAR 0 4
84028: PUSH
84029: FOR_TO
84030: IFFALSE 84077
// begin hc_class = 13 ;
84032: LD_ADDR_OWVAR 28
84036: PUSH
84037: LD_INT 13
84039: ST_TO_ADDR
// hc_gallery =  ;
84040: LD_ADDR_OWVAR 33
84044: PUSH
84045: LD_STRING 
84047: ST_TO_ADDR
// animal := CreateHuman ;
84048: LD_ADDR_VAR 0 12
84052: PUSH
84053: CALL_OW 44
84057: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84058: LD_VAR 0 12
84062: PPUSH
84063: LD_VAR 0 8
84067: PPUSH
84068: LD_INT 0
84070: PPUSH
84071: CALL 85779 0 3
// end ;
84075: GO 84029
84077: POP
84078: POP
// if fishes then
84079: LD_VAR 0 7
84083: IFFALSE 84150
// for i = 1 to fishes do
84085: LD_ADDR_VAR 0 11
84089: PUSH
84090: DOUBLE
84091: LD_INT 1
84093: DEC
84094: ST_TO_ADDR
84095: LD_VAR 0 7
84099: PUSH
84100: FOR_TO
84101: IFFALSE 84148
// begin hc_class = 20 ;
84103: LD_ADDR_OWVAR 28
84107: PUSH
84108: LD_INT 20
84110: ST_TO_ADDR
// hc_gallery =  ;
84111: LD_ADDR_OWVAR 33
84115: PUSH
84116: LD_STRING 
84118: ST_TO_ADDR
// animal := CreateHuman ;
84119: LD_ADDR_VAR 0 12
84123: PUSH
84124: CALL_OW 44
84128: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
84129: LD_VAR 0 12
84133: PPUSH
84134: LD_VAR 0 9
84138: PPUSH
84139: LD_INT 0
84141: PPUSH
84142: CALL 85779 0 3
// end ;
84146: GO 84100
84148: POP
84149: POP
// end ;
84150: LD_VAR 0 10
84154: RET
// export function WantHeal ( sci , unit ) ; begin
84155: LD_INT 0
84157: PPUSH
// if GetTaskList ( sci ) > 0 then
84158: LD_VAR 0 1
84162: PPUSH
84163: CALL_OW 437
84167: PUSH
84168: LD_INT 0
84170: GREATER
84171: IFFALSE 84241
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
84173: LD_VAR 0 1
84177: PPUSH
84178: CALL_OW 437
84182: PUSH
84183: LD_INT 1
84185: ARRAY
84186: PUSH
84187: LD_INT 1
84189: ARRAY
84190: PUSH
84191: LD_STRING l
84193: EQUAL
84194: PUSH
84195: LD_VAR 0 1
84199: PPUSH
84200: CALL_OW 437
84204: PUSH
84205: LD_INT 1
84207: ARRAY
84208: PUSH
84209: LD_INT 4
84211: ARRAY
84212: PUSH
84213: LD_VAR 0 2
84217: EQUAL
84218: AND
84219: IFFALSE 84231
// result := true else
84221: LD_ADDR_VAR 0 3
84225: PUSH
84226: LD_INT 1
84228: ST_TO_ADDR
84229: GO 84239
// result := false ;
84231: LD_ADDR_VAR 0 3
84235: PUSH
84236: LD_INT 0
84238: ST_TO_ADDR
// end else
84239: GO 84249
// result := false ;
84241: LD_ADDR_VAR 0 3
84245: PUSH
84246: LD_INT 0
84248: ST_TO_ADDR
// end ;
84249: LD_VAR 0 3
84253: RET
// export function HealTarget ( sci ) ; begin
84254: LD_INT 0
84256: PPUSH
// if not sci then
84257: LD_VAR 0 1
84261: NOT
84262: IFFALSE 84266
// exit ;
84264: GO 84331
// result := 0 ;
84266: LD_ADDR_VAR 0 2
84270: PUSH
84271: LD_INT 0
84273: ST_TO_ADDR
// if GetTaskList ( sci ) then
84274: LD_VAR 0 1
84278: PPUSH
84279: CALL_OW 437
84283: IFFALSE 84331
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
84285: LD_VAR 0 1
84289: PPUSH
84290: CALL_OW 437
84294: PUSH
84295: LD_INT 1
84297: ARRAY
84298: PUSH
84299: LD_INT 1
84301: ARRAY
84302: PUSH
84303: LD_STRING l
84305: EQUAL
84306: IFFALSE 84331
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
84308: LD_ADDR_VAR 0 2
84312: PUSH
84313: LD_VAR 0 1
84317: PPUSH
84318: CALL_OW 437
84322: PUSH
84323: LD_INT 1
84325: ARRAY
84326: PUSH
84327: LD_INT 4
84329: ARRAY
84330: ST_TO_ADDR
// end ;
84331: LD_VAR 0 2
84335: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
84336: LD_INT 0
84338: PPUSH
84339: PPUSH
84340: PPUSH
84341: PPUSH
// if not base_units then
84342: LD_VAR 0 1
84346: NOT
84347: IFFALSE 84351
// exit ;
84349: GO 84438
// result := false ;
84351: LD_ADDR_VAR 0 2
84355: PUSH
84356: LD_INT 0
84358: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
84359: LD_ADDR_VAR 0 5
84363: PUSH
84364: LD_VAR 0 1
84368: PPUSH
84369: LD_INT 21
84371: PUSH
84372: LD_INT 3
84374: PUSH
84375: EMPTY
84376: LIST
84377: LIST
84378: PPUSH
84379: CALL_OW 72
84383: ST_TO_ADDR
// if not tmp then
84384: LD_VAR 0 5
84388: NOT
84389: IFFALSE 84393
// exit ;
84391: GO 84438
// for i in tmp do
84393: LD_ADDR_VAR 0 3
84397: PUSH
84398: LD_VAR 0 5
84402: PUSH
84403: FOR_IN
84404: IFFALSE 84436
// begin result := EnemyInRange ( i , 22 ) ;
84406: LD_ADDR_VAR 0 2
84410: PUSH
84411: LD_VAR 0 3
84415: PPUSH
84416: LD_INT 22
84418: PPUSH
84419: CALL 82036 0 2
84423: ST_TO_ADDR
// if result then
84424: LD_VAR 0 2
84428: IFFALSE 84434
// exit ;
84430: POP
84431: POP
84432: GO 84438
// end ;
84434: GO 84403
84436: POP
84437: POP
// end ;
84438: LD_VAR 0 2
84442: RET
// export function FilterByTag ( units , tag ) ; begin
84443: LD_INT 0
84445: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
84446: LD_ADDR_VAR 0 3
84450: PUSH
84451: LD_VAR 0 1
84455: PPUSH
84456: LD_INT 120
84458: PUSH
84459: LD_VAR 0 2
84463: PUSH
84464: EMPTY
84465: LIST
84466: LIST
84467: PPUSH
84468: CALL_OW 72
84472: ST_TO_ADDR
// end ;
84473: LD_VAR 0 3
84477: RET
// export function IsDriver ( un ) ; begin
84478: LD_INT 0
84480: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
84481: LD_ADDR_VAR 0 2
84485: PUSH
84486: LD_VAR 0 1
84490: PUSH
84491: LD_INT 55
84493: PUSH
84494: EMPTY
84495: LIST
84496: PPUSH
84497: CALL_OW 69
84501: IN
84502: ST_TO_ADDR
// end ;
84503: LD_VAR 0 2
84507: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
84508: LD_INT 0
84510: PPUSH
84511: PPUSH
// list := [ ] ;
84512: LD_ADDR_VAR 0 5
84516: PUSH
84517: EMPTY
84518: ST_TO_ADDR
// case d of 0 :
84519: LD_VAR 0 3
84523: PUSH
84524: LD_INT 0
84526: DOUBLE
84527: EQUAL
84528: IFTRUE 84532
84530: GO 84665
84532: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
84533: LD_ADDR_VAR 0 5
84537: PUSH
84538: LD_VAR 0 1
84542: PUSH
84543: LD_INT 4
84545: MINUS
84546: PUSH
84547: LD_VAR 0 2
84551: PUSH
84552: LD_INT 4
84554: MINUS
84555: PUSH
84556: LD_INT 2
84558: PUSH
84559: EMPTY
84560: LIST
84561: LIST
84562: LIST
84563: PUSH
84564: LD_VAR 0 1
84568: PUSH
84569: LD_INT 3
84571: MINUS
84572: PUSH
84573: LD_VAR 0 2
84577: PUSH
84578: LD_INT 1
84580: PUSH
84581: EMPTY
84582: LIST
84583: LIST
84584: LIST
84585: PUSH
84586: LD_VAR 0 1
84590: PUSH
84591: LD_INT 4
84593: PLUS
84594: PUSH
84595: LD_VAR 0 2
84599: PUSH
84600: LD_INT 4
84602: PUSH
84603: EMPTY
84604: LIST
84605: LIST
84606: LIST
84607: PUSH
84608: LD_VAR 0 1
84612: PUSH
84613: LD_INT 3
84615: PLUS
84616: PUSH
84617: LD_VAR 0 2
84621: PUSH
84622: LD_INT 3
84624: PLUS
84625: PUSH
84626: LD_INT 5
84628: PUSH
84629: EMPTY
84630: LIST
84631: LIST
84632: LIST
84633: PUSH
84634: LD_VAR 0 1
84638: PUSH
84639: LD_VAR 0 2
84643: PUSH
84644: LD_INT 4
84646: PLUS
84647: PUSH
84648: LD_INT 0
84650: PUSH
84651: EMPTY
84652: LIST
84653: LIST
84654: LIST
84655: PUSH
84656: EMPTY
84657: LIST
84658: LIST
84659: LIST
84660: LIST
84661: LIST
84662: ST_TO_ADDR
// end ; 1 :
84663: GO 85363
84665: LD_INT 1
84667: DOUBLE
84668: EQUAL
84669: IFTRUE 84673
84671: GO 84806
84673: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
84674: LD_ADDR_VAR 0 5
84678: PUSH
84679: LD_VAR 0 1
84683: PUSH
84684: LD_VAR 0 2
84688: PUSH
84689: LD_INT 4
84691: MINUS
84692: PUSH
84693: LD_INT 3
84695: PUSH
84696: EMPTY
84697: LIST
84698: LIST
84699: LIST
84700: PUSH
84701: LD_VAR 0 1
84705: PUSH
84706: LD_INT 3
84708: MINUS
84709: PUSH
84710: LD_VAR 0 2
84714: PUSH
84715: LD_INT 3
84717: MINUS
84718: PUSH
84719: LD_INT 2
84721: PUSH
84722: EMPTY
84723: LIST
84724: LIST
84725: LIST
84726: PUSH
84727: LD_VAR 0 1
84731: PUSH
84732: LD_INT 4
84734: MINUS
84735: PUSH
84736: LD_VAR 0 2
84740: PUSH
84741: LD_INT 1
84743: PUSH
84744: EMPTY
84745: LIST
84746: LIST
84747: LIST
84748: PUSH
84749: LD_VAR 0 1
84753: PUSH
84754: LD_VAR 0 2
84758: PUSH
84759: LD_INT 3
84761: PLUS
84762: PUSH
84763: LD_INT 0
84765: PUSH
84766: EMPTY
84767: LIST
84768: LIST
84769: LIST
84770: PUSH
84771: LD_VAR 0 1
84775: PUSH
84776: LD_INT 4
84778: PLUS
84779: PUSH
84780: LD_VAR 0 2
84784: PUSH
84785: LD_INT 4
84787: PLUS
84788: PUSH
84789: LD_INT 5
84791: PUSH
84792: EMPTY
84793: LIST
84794: LIST
84795: LIST
84796: PUSH
84797: EMPTY
84798: LIST
84799: LIST
84800: LIST
84801: LIST
84802: LIST
84803: ST_TO_ADDR
// end ; 2 :
84804: GO 85363
84806: LD_INT 2
84808: DOUBLE
84809: EQUAL
84810: IFTRUE 84814
84812: GO 84943
84814: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
84815: LD_ADDR_VAR 0 5
84819: PUSH
84820: LD_VAR 0 1
84824: PUSH
84825: LD_VAR 0 2
84829: PUSH
84830: LD_INT 3
84832: MINUS
84833: PUSH
84834: LD_INT 3
84836: PUSH
84837: EMPTY
84838: LIST
84839: LIST
84840: LIST
84841: PUSH
84842: LD_VAR 0 1
84846: PUSH
84847: LD_INT 4
84849: PLUS
84850: PUSH
84851: LD_VAR 0 2
84855: PUSH
84856: LD_INT 4
84858: PUSH
84859: EMPTY
84860: LIST
84861: LIST
84862: LIST
84863: PUSH
84864: LD_VAR 0 1
84868: PUSH
84869: LD_VAR 0 2
84873: PUSH
84874: LD_INT 4
84876: PLUS
84877: PUSH
84878: LD_INT 0
84880: PUSH
84881: EMPTY
84882: LIST
84883: LIST
84884: LIST
84885: PUSH
84886: LD_VAR 0 1
84890: PUSH
84891: LD_INT 3
84893: MINUS
84894: PUSH
84895: LD_VAR 0 2
84899: PUSH
84900: LD_INT 1
84902: PUSH
84903: EMPTY
84904: LIST
84905: LIST
84906: LIST
84907: PUSH
84908: LD_VAR 0 1
84912: PUSH
84913: LD_INT 4
84915: MINUS
84916: PUSH
84917: LD_VAR 0 2
84921: PUSH
84922: LD_INT 4
84924: MINUS
84925: PUSH
84926: LD_INT 2
84928: PUSH
84929: EMPTY
84930: LIST
84931: LIST
84932: LIST
84933: PUSH
84934: EMPTY
84935: LIST
84936: LIST
84937: LIST
84938: LIST
84939: LIST
84940: ST_TO_ADDR
// end ; 3 :
84941: GO 85363
84943: LD_INT 3
84945: DOUBLE
84946: EQUAL
84947: IFTRUE 84951
84949: GO 85084
84951: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
84952: LD_ADDR_VAR 0 5
84956: PUSH
84957: LD_VAR 0 1
84961: PUSH
84962: LD_INT 3
84964: PLUS
84965: PUSH
84966: LD_VAR 0 2
84970: PUSH
84971: LD_INT 4
84973: PUSH
84974: EMPTY
84975: LIST
84976: LIST
84977: LIST
84978: PUSH
84979: LD_VAR 0 1
84983: PUSH
84984: LD_INT 4
84986: PLUS
84987: PUSH
84988: LD_VAR 0 2
84992: PUSH
84993: LD_INT 4
84995: PLUS
84996: PUSH
84997: LD_INT 5
84999: PUSH
85000: EMPTY
85001: LIST
85002: LIST
85003: LIST
85004: PUSH
85005: LD_VAR 0 1
85009: PUSH
85010: LD_INT 4
85012: MINUS
85013: PUSH
85014: LD_VAR 0 2
85018: PUSH
85019: LD_INT 1
85021: PUSH
85022: EMPTY
85023: LIST
85024: LIST
85025: LIST
85026: PUSH
85027: LD_VAR 0 1
85031: PUSH
85032: LD_VAR 0 2
85036: PUSH
85037: LD_INT 4
85039: MINUS
85040: PUSH
85041: LD_INT 3
85043: PUSH
85044: EMPTY
85045: LIST
85046: LIST
85047: LIST
85048: PUSH
85049: LD_VAR 0 1
85053: PUSH
85054: LD_INT 3
85056: MINUS
85057: PUSH
85058: LD_VAR 0 2
85062: PUSH
85063: LD_INT 3
85065: MINUS
85066: PUSH
85067: LD_INT 2
85069: PUSH
85070: EMPTY
85071: LIST
85072: LIST
85073: LIST
85074: PUSH
85075: EMPTY
85076: LIST
85077: LIST
85078: LIST
85079: LIST
85080: LIST
85081: ST_TO_ADDR
// end ; 4 :
85082: GO 85363
85084: LD_INT 4
85086: DOUBLE
85087: EQUAL
85088: IFTRUE 85092
85090: GO 85225
85092: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
85093: LD_ADDR_VAR 0 5
85097: PUSH
85098: LD_VAR 0 1
85102: PUSH
85103: LD_VAR 0 2
85107: PUSH
85108: LD_INT 4
85110: PLUS
85111: PUSH
85112: LD_INT 0
85114: PUSH
85115: EMPTY
85116: LIST
85117: LIST
85118: LIST
85119: PUSH
85120: LD_VAR 0 1
85124: PUSH
85125: LD_INT 3
85127: PLUS
85128: PUSH
85129: LD_VAR 0 2
85133: PUSH
85134: LD_INT 3
85136: PLUS
85137: PUSH
85138: LD_INT 5
85140: PUSH
85141: EMPTY
85142: LIST
85143: LIST
85144: LIST
85145: PUSH
85146: LD_VAR 0 1
85150: PUSH
85151: LD_INT 4
85153: PLUS
85154: PUSH
85155: LD_VAR 0 2
85159: PUSH
85160: LD_INT 4
85162: PUSH
85163: EMPTY
85164: LIST
85165: LIST
85166: LIST
85167: PUSH
85168: LD_VAR 0 1
85172: PUSH
85173: LD_VAR 0 2
85177: PUSH
85178: LD_INT 3
85180: MINUS
85181: PUSH
85182: LD_INT 3
85184: PUSH
85185: EMPTY
85186: LIST
85187: LIST
85188: LIST
85189: PUSH
85190: LD_VAR 0 1
85194: PUSH
85195: LD_INT 4
85197: MINUS
85198: PUSH
85199: LD_VAR 0 2
85203: PUSH
85204: LD_INT 4
85206: MINUS
85207: PUSH
85208: LD_INT 2
85210: PUSH
85211: EMPTY
85212: LIST
85213: LIST
85214: LIST
85215: PUSH
85216: EMPTY
85217: LIST
85218: LIST
85219: LIST
85220: LIST
85221: LIST
85222: ST_TO_ADDR
// end ; 5 :
85223: GO 85363
85225: LD_INT 5
85227: DOUBLE
85228: EQUAL
85229: IFTRUE 85233
85231: GO 85362
85233: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
85234: LD_ADDR_VAR 0 5
85238: PUSH
85239: LD_VAR 0 1
85243: PUSH
85244: LD_INT 4
85246: MINUS
85247: PUSH
85248: LD_VAR 0 2
85252: PUSH
85253: LD_INT 1
85255: PUSH
85256: EMPTY
85257: LIST
85258: LIST
85259: LIST
85260: PUSH
85261: LD_VAR 0 1
85265: PUSH
85266: LD_VAR 0 2
85270: PUSH
85271: LD_INT 4
85273: MINUS
85274: PUSH
85275: LD_INT 3
85277: PUSH
85278: EMPTY
85279: LIST
85280: LIST
85281: LIST
85282: PUSH
85283: LD_VAR 0 1
85287: PUSH
85288: LD_INT 4
85290: PLUS
85291: PUSH
85292: LD_VAR 0 2
85296: PUSH
85297: LD_INT 4
85299: PLUS
85300: PUSH
85301: LD_INT 5
85303: PUSH
85304: EMPTY
85305: LIST
85306: LIST
85307: LIST
85308: PUSH
85309: LD_VAR 0 1
85313: PUSH
85314: LD_INT 3
85316: PLUS
85317: PUSH
85318: LD_VAR 0 2
85322: PUSH
85323: LD_INT 4
85325: PUSH
85326: EMPTY
85327: LIST
85328: LIST
85329: LIST
85330: PUSH
85331: LD_VAR 0 1
85335: PUSH
85336: LD_VAR 0 2
85340: PUSH
85341: LD_INT 3
85343: PLUS
85344: PUSH
85345: LD_INT 0
85347: PUSH
85348: EMPTY
85349: LIST
85350: LIST
85351: LIST
85352: PUSH
85353: EMPTY
85354: LIST
85355: LIST
85356: LIST
85357: LIST
85358: LIST
85359: ST_TO_ADDR
// end ; end ;
85360: GO 85363
85362: POP
// result := list ;
85363: LD_ADDR_VAR 0 4
85367: PUSH
85368: LD_VAR 0 5
85372: ST_TO_ADDR
// end ;
85373: LD_VAR 0 4
85377: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
85378: LD_INT 0
85380: PPUSH
85381: PPUSH
85382: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
85383: LD_VAR 0 1
85387: NOT
85388: PUSH
85389: LD_VAR 0 2
85393: PUSH
85394: LD_INT 1
85396: PUSH
85397: LD_INT 2
85399: PUSH
85400: LD_INT 3
85402: PUSH
85403: LD_INT 4
85405: PUSH
85406: EMPTY
85407: LIST
85408: LIST
85409: LIST
85410: LIST
85411: IN
85412: NOT
85413: OR
85414: IFFALSE 85418
// exit ;
85416: GO 85501
// tmp := [ ] ;
85418: LD_ADDR_VAR 0 5
85422: PUSH
85423: EMPTY
85424: ST_TO_ADDR
// for i in units do
85425: LD_ADDR_VAR 0 4
85429: PUSH
85430: LD_VAR 0 1
85434: PUSH
85435: FOR_IN
85436: IFFALSE 85470
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
85438: LD_ADDR_VAR 0 5
85442: PUSH
85443: LD_VAR 0 5
85447: PPUSH
85448: LD_VAR 0 4
85452: PPUSH
85453: LD_VAR 0 2
85457: PPUSH
85458: CALL_OW 259
85462: PPUSH
85463: CALL 86874 0 2
85467: ST_TO_ADDR
85468: GO 85435
85470: POP
85471: POP
// if not tmp then
85472: LD_VAR 0 5
85476: NOT
85477: IFFALSE 85481
// exit ;
85479: GO 85501
// result := SortListByListDesc ( units , tmp ) ;
85481: LD_ADDR_VAR 0 3
85485: PUSH
85486: LD_VAR 0 1
85490: PPUSH
85491: LD_VAR 0 5
85495: PPUSH
85496: CALL_OW 77
85500: ST_TO_ADDR
// end ;
85501: LD_VAR 0 3
85505: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
85506: LD_INT 0
85508: PPUSH
85509: PPUSH
85510: PPUSH
// result := false ;
85511: LD_ADDR_VAR 0 3
85515: PUSH
85516: LD_INT 0
85518: ST_TO_ADDR
// if not building then
85519: LD_VAR 0 2
85523: NOT
85524: IFFALSE 85528
// exit ;
85526: GO 85666
// x := GetX ( building ) ;
85528: LD_ADDR_VAR 0 4
85532: PUSH
85533: LD_VAR 0 2
85537: PPUSH
85538: CALL_OW 250
85542: ST_TO_ADDR
// y := GetY ( building ) ;
85543: LD_ADDR_VAR 0 5
85547: PUSH
85548: LD_VAR 0 2
85552: PPUSH
85553: CALL_OW 251
85557: ST_TO_ADDR
// if not x or not y then
85558: LD_VAR 0 4
85562: NOT
85563: PUSH
85564: LD_VAR 0 5
85568: NOT
85569: OR
85570: IFFALSE 85574
// exit ;
85572: GO 85666
// if GetTaskList ( unit ) then
85574: LD_VAR 0 1
85578: PPUSH
85579: CALL_OW 437
85583: IFFALSE 85666
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
85585: LD_STRING e
85587: PUSH
85588: LD_VAR 0 1
85592: PPUSH
85593: CALL_OW 437
85597: PUSH
85598: LD_INT 1
85600: ARRAY
85601: PUSH
85602: LD_INT 1
85604: ARRAY
85605: EQUAL
85606: PUSH
85607: LD_VAR 0 4
85611: PUSH
85612: LD_VAR 0 1
85616: PPUSH
85617: CALL_OW 437
85621: PUSH
85622: LD_INT 1
85624: ARRAY
85625: PUSH
85626: LD_INT 2
85628: ARRAY
85629: EQUAL
85630: AND
85631: PUSH
85632: LD_VAR 0 5
85636: PUSH
85637: LD_VAR 0 1
85641: PPUSH
85642: CALL_OW 437
85646: PUSH
85647: LD_INT 1
85649: ARRAY
85650: PUSH
85651: LD_INT 3
85653: ARRAY
85654: EQUAL
85655: AND
85656: IFFALSE 85666
// result := true end ;
85658: LD_ADDR_VAR 0 3
85662: PUSH
85663: LD_INT 1
85665: ST_TO_ADDR
// end ;
85666: LD_VAR 0 3
85670: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
85671: LD_INT 0
85673: PPUSH
// result := false ;
85674: LD_ADDR_VAR 0 4
85678: PUSH
85679: LD_INT 0
85681: ST_TO_ADDR
// if GetTaskList ( unit ) then
85682: LD_VAR 0 1
85686: PPUSH
85687: CALL_OW 437
85691: IFFALSE 85774
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
85693: LD_STRING M
85695: PUSH
85696: LD_VAR 0 1
85700: PPUSH
85701: CALL_OW 437
85705: PUSH
85706: LD_INT 1
85708: ARRAY
85709: PUSH
85710: LD_INT 1
85712: ARRAY
85713: EQUAL
85714: PUSH
85715: LD_VAR 0 2
85719: PUSH
85720: LD_VAR 0 1
85724: PPUSH
85725: CALL_OW 437
85729: PUSH
85730: LD_INT 1
85732: ARRAY
85733: PUSH
85734: LD_INT 2
85736: ARRAY
85737: EQUAL
85738: AND
85739: PUSH
85740: LD_VAR 0 3
85744: PUSH
85745: LD_VAR 0 1
85749: PPUSH
85750: CALL_OW 437
85754: PUSH
85755: LD_INT 1
85757: ARRAY
85758: PUSH
85759: LD_INT 3
85761: ARRAY
85762: EQUAL
85763: AND
85764: IFFALSE 85774
// result := true ;
85766: LD_ADDR_VAR 0 4
85770: PUSH
85771: LD_INT 1
85773: ST_TO_ADDR
// end ; end ;
85774: LD_VAR 0 4
85778: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
85779: LD_INT 0
85781: PPUSH
85782: PPUSH
85783: PPUSH
85784: PPUSH
// if not unit or not area then
85785: LD_VAR 0 1
85789: NOT
85790: PUSH
85791: LD_VAR 0 2
85795: NOT
85796: OR
85797: IFFALSE 85801
// exit ;
85799: GO 85977
// tmp := AreaToList ( area , i ) ;
85801: LD_ADDR_VAR 0 6
85805: PUSH
85806: LD_VAR 0 2
85810: PPUSH
85811: LD_VAR 0 5
85815: PPUSH
85816: CALL_OW 517
85820: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
85821: LD_ADDR_VAR 0 5
85825: PUSH
85826: DOUBLE
85827: LD_INT 1
85829: DEC
85830: ST_TO_ADDR
85831: LD_VAR 0 6
85835: PUSH
85836: LD_INT 1
85838: ARRAY
85839: PUSH
85840: FOR_TO
85841: IFFALSE 85975
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
85843: LD_ADDR_VAR 0 7
85847: PUSH
85848: LD_VAR 0 6
85852: PUSH
85853: LD_INT 1
85855: ARRAY
85856: PUSH
85857: LD_VAR 0 5
85861: ARRAY
85862: PUSH
85863: LD_VAR 0 6
85867: PUSH
85868: LD_INT 2
85870: ARRAY
85871: PUSH
85872: LD_VAR 0 5
85876: ARRAY
85877: PUSH
85878: EMPTY
85879: LIST
85880: LIST
85881: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 2 ] ) = 0 then
85882: LD_INT 92
85884: PUSH
85885: LD_VAR 0 7
85889: PUSH
85890: LD_INT 1
85892: ARRAY
85893: PUSH
85894: LD_VAR 0 7
85898: PUSH
85899: LD_INT 2
85901: ARRAY
85902: PUSH
85903: LD_INT 2
85905: PUSH
85906: EMPTY
85907: LIST
85908: LIST
85909: LIST
85910: LIST
85911: PPUSH
85912: CALL_OW 69
85916: PUSH
85917: LD_INT 0
85919: EQUAL
85920: IFFALSE 85973
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
85922: LD_VAR 0 1
85926: PPUSH
85927: LD_VAR 0 7
85931: PUSH
85932: LD_INT 1
85934: ARRAY
85935: PPUSH
85936: LD_VAR 0 7
85940: PUSH
85941: LD_INT 2
85943: ARRAY
85944: PPUSH
85945: LD_VAR 0 3
85949: PPUSH
85950: CALL_OW 48
// result := IsPlaced ( unit ) ;
85954: LD_ADDR_VAR 0 4
85958: PUSH
85959: LD_VAR 0 1
85963: PPUSH
85964: CALL_OW 305
85968: ST_TO_ADDR
// exit ;
85969: POP
85970: POP
85971: GO 85977
// end ; end ;
85973: GO 85840
85975: POP
85976: POP
// end ;
85977: LD_VAR 0 4
85981: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
85982: LD_INT 0
85984: PPUSH
85985: PPUSH
85986: PPUSH
// if not side or side > 8 then
85987: LD_VAR 0 1
85991: NOT
85992: PUSH
85993: LD_VAR 0 1
85997: PUSH
85998: LD_INT 8
86000: GREATER
86001: OR
86002: IFFALSE 86006
// exit ;
86004: GO 86193
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
86006: LD_ADDR_VAR 0 4
86010: PUSH
86011: LD_INT 22
86013: PUSH
86014: LD_VAR 0 1
86018: PUSH
86019: EMPTY
86020: LIST
86021: LIST
86022: PUSH
86023: LD_INT 21
86025: PUSH
86026: LD_INT 3
86028: PUSH
86029: EMPTY
86030: LIST
86031: LIST
86032: PUSH
86033: EMPTY
86034: LIST
86035: LIST
86036: PPUSH
86037: CALL_OW 69
86041: ST_TO_ADDR
// if not tmp then
86042: LD_VAR 0 4
86046: NOT
86047: IFFALSE 86051
// exit ;
86049: GO 86193
// enable_addtolog := true ;
86051: LD_ADDR_OWVAR 81
86055: PUSH
86056: LD_INT 1
86058: ST_TO_ADDR
// AddToLog ( [ ) ;
86059: LD_STRING [
86061: PPUSH
86062: CALL_OW 561
// for i in tmp do
86066: LD_ADDR_VAR 0 3
86070: PUSH
86071: LD_VAR 0 4
86075: PUSH
86076: FOR_IN
86077: IFFALSE 86184
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
86079: LD_STRING [
86081: PUSH
86082: LD_VAR 0 3
86086: PPUSH
86087: CALL_OW 266
86091: STR
86092: PUSH
86093: LD_STRING , 
86095: STR
86096: PUSH
86097: LD_VAR 0 3
86101: PPUSH
86102: CALL_OW 250
86106: STR
86107: PUSH
86108: LD_STRING , 
86110: STR
86111: PUSH
86112: LD_VAR 0 3
86116: PPUSH
86117: CALL_OW 251
86121: STR
86122: PUSH
86123: LD_STRING , 
86125: STR
86126: PUSH
86127: LD_VAR 0 3
86131: PPUSH
86132: CALL_OW 254
86136: STR
86137: PUSH
86138: LD_STRING , 
86140: STR
86141: PUSH
86142: LD_VAR 0 3
86146: PPUSH
86147: LD_INT 1
86149: PPUSH
86150: CALL_OW 268
86154: STR
86155: PUSH
86156: LD_STRING , 
86158: STR
86159: PUSH
86160: LD_VAR 0 3
86164: PPUSH
86165: LD_INT 2
86167: PPUSH
86168: CALL_OW 268
86172: STR
86173: PUSH
86174: LD_STRING ],
86176: STR
86177: PPUSH
86178: CALL_OW 561
// end ;
86182: GO 86076
86184: POP
86185: POP
// AddToLog ( ]; ) ;
86186: LD_STRING ];
86188: PPUSH
86189: CALL_OW 561
// end ;
86193: LD_VAR 0 2
86197: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
86198: LD_INT 0
86200: PPUSH
86201: PPUSH
86202: PPUSH
86203: PPUSH
86204: PPUSH
// if not area or not rate or not max then
86205: LD_VAR 0 1
86209: NOT
86210: PUSH
86211: LD_VAR 0 2
86215: NOT
86216: OR
86217: PUSH
86218: LD_VAR 0 4
86222: NOT
86223: OR
86224: IFFALSE 86228
// exit ;
86226: GO 86417
// while 1 do
86228: LD_INT 1
86230: IFFALSE 86417
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
86232: LD_ADDR_VAR 0 9
86236: PUSH
86237: LD_VAR 0 1
86241: PPUSH
86242: LD_INT 1
86244: PPUSH
86245: CALL_OW 287
86249: PUSH
86250: LD_INT 10
86252: MUL
86253: ST_TO_ADDR
// r := rate / 10 ;
86254: LD_ADDR_VAR 0 7
86258: PUSH
86259: LD_VAR 0 2
86263: PUSH
86264: LD_INT 10
86266: DIVREAL
86267: ST_TO_ADDR
// time := 1 1$00 ;
86268: LD_ADDR_VAR 0 8
86272: PUSH
86273: LD_INT 2100
86275: ST_TO_ADDR
// if amount < min then
86276: LD_VAR 0 9
86280: PUSH
86281: LD_VAR 0 3
86285: LESS
86286: IFFALSE 86304
// r := r * 2 else
86288: LD_ADDR_VAR 0 7
86292: PUSH
86293: LD_VAR 0 7
86297: PUSH
86298: LD_INT 2
86300: MUL
86301: ST_TO_ADDR
86302: GO 86330
// if amount > max then
86304: LD_VAR 0 9
86308: PUSH
86309: LD_VAR 0 4
86313: GREATER
86314: IFFALSE 86330
// r := r / 2 ;
86316: LD_ADDR_VAR 0 7
86320: PUSH
86321: LD_VAR 0 7
86325: PUSH
86326: LD_INT 2
86328: DIVREAL
86329: ST_TO_ADDR
// time := time / r ;
86330: LD_ADDR_VAR 0 8
86334: PUSH
86335: LD_VAR 0 8
86339: PUSH
86340: LD_VAR 0 7
86344: DIVREAL
86345: ST_TO_ADDR
// if time < 0 then
86346: LD_VAR 0 8
86350: PUSH
86351: LD_INT 0
86353: LESS
86354: IFFALSE 86371
// time := time * - 1 ;
86356: LD_ADDR_VAR 0 8
86360: PUSH
86361: LD_VAR 0 8
86365: PUSH
86366: LD_INT 1
86368: NEG
86369: MUL
86370: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
86371: LD_VAR 0 8
86375: PUSH
86376: LD_INT 35
86378: PPUSH
86379: LD_INT 875
86381: PPUSH
86382: CALL_OW 12
86386: PLUS
86387: PPUSH
86388: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
86392: LD_INT 1
86394: PPUSH
86395: LD_INT 5
86397: PPUSH
86398: CALL_OW 12
86402: PPUSH
86403: LD_VAR 0 1
86407: PPUSH
86408: LD_INT 1
86410: PPUSH
86411: CALL_OW 55
// end ;
86415: GO 86228
// end ;
86417: LD_VAR 0 5
86421: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
86422: LD_INT 0
86424: PPUSH
86425: PPUSH
86426: PPUSH
86427: PPUSH
86428: PPUSH
86429: PPUSH
86430: PPUSH
86431: PPUSH
// if not turrets or not factories then
86432: LD_VAR 0 1
86436: NOT
86437: PUSH
86438: LD_VAR 0 2
86442: NOT
86443: OR
86444: IFFALSE 86448
// exit ;
86446: GO 86755
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
86448: LD_ADDR_VAR 0 10
86452: PUSH
86453: LD_INT 5
86455: PUSH
86456: LD_INT 6
86458: PUSH
86459: EMPTY
86460: LIST
86461: LIST
86462: PUSH
86463: LD_INT 2
86465: PUSH
86466: LD_INT 4
86468: PUSH
86469: EMPTY
86470: LIST
86471: LIST
86472: PUSH
86473: LD_INT 3
86475: PUSH
86476: LD_INT 5
86478: PUSH
86479: EMPTY
86480: LIST
86481: LIST
86482: PUSH
86483: EMPTY
86484: LIST
86485: LIST
86486: LIST
86487: PUSH
86488: LD_INT 24
86490: PUSH
86491: LD_INT 25
86493: PUSH
86494: EMPTY
86495: LIST
86496: LIST
86497: PUSH
86498: LD_INT 23
86500: PUSH
86501: LD_INT 27
86503: PUSH
86504: EMPTY
86505: LIST
86506: LIST
86507: PUSH
86508: EMPTY
86509: LIST
86510: LIST
86511: PUSH
86512: LD_INT 42
86514: PUSH
86515: LD_INT 43
86517: PUSH
86518: EMPTY
86519: LIST
86520: LIST
86521: PUSH
86522: LD_INT 44
86524: PUSH
86525: LD_INT 46
86527: PUSH
86528: EMPTY
86529: LIST
86530: LIST
86531: PUSH
86532: LD_INT 45
86534: PUSH
86535: LD_INT 47
86537: PUSH
86538: EMPTY
86539: LIST
86540: LIST
86541: PUSH
86542: EMPTY
86543: LIST
86544: LIST
86545: LIST
86546: PUSH
86547: EMPTY
86548: LIST
86549: LIST
86550: LIST
86551: ST_TO_ADDR
// result := [ ] ;
86552: LD_ADDR_VAR 0 3
86556: PUSH
86557: EMPTY
86558: ST_TO_ADDR
// for i in turrets do
86559: LD_ADDR_VAR 0 4
86563: PUSH
86564: LD_VAR 0 1
86568: PUSH
86569: FOR_IN
86570: IFFALSE 86753
// begin nat := GetNation ( i ) ;
86572: LD_ADDR_VAR 0 7
86576: PUSH
86577: LD_VAR 0 4
86581: PPUSH
86582: CALL_OW 248
86586: ST_TO_ADDR
// weapon := 0 ;
86587: LD_ADDR_VAR 0 8
86591: PUSH
86592: LD_INT 0
86594: ST_TO_ADDR
// if not nat then
86595: LD_VAR 0 7
86599: NOT
86600: IFFALSE 86604
// continue ;
86602: GO 86569
// for j in list [ nat ] do
86604: LD_ADDR_VAR 0 5
86608: PUSH
86609: LD_VAR 0 10
86613: PUSH
86614: LD_VAR 0 7
86618: ARRAY
86619: PUSH
86620: FOR_IN
86621: IFFALSE 86662
// if GetBWeapon ( i ) = j [ 1 ] then
86623: LD_VAR 0 4
86627: PPUSH
86628: CALL_OW 269
86632: PUSH
86633: LD_VAR 0 5
86637: PUSH
86638: LD_INT 1
86640: ARRAY
86641: EQUAL
86642: IFFALSE 86660
// begin weapon := j [ 2 ] ;
86644: LD_ADDR_VAR 0 8
86648: PUSH
86649: LD_VAR 0 5
86653: PUSH
86654: LD_INT 2
86656: ARRAY
86657: ST_TO_ADDR
// break ;
86658: GO 86662
// end ;
86660: GO 86620
86662: POP
86663: POP
// if not weapon then
86664: LD_VAR 0 8
86668: NOT
86669: IFFALSE 86673
// continue ;
86671: GO 86569
// for k in factories do
86673: LD_ADDR_VAR 0 6
86677: PUSH
86678: LD_VAR 0 2
86682: PUSH
86683: FOR_IN
86684: IFFALSE 86749
// begin weapons := AvailableWeaponList ( k ) ;
86686: LD_ADDR_VAR 0 9
86690: PUSH
86691: LD_VAR 0 6
86695: PPUSH
86696: CALL_OW 478
86700: ST_TO_ADDR
// if not weapons then
86701: LD_VAR 0 9
86705: NOT
86706: IFFALSE 86710
// continue ;
86708: GO 86683
// if weapon in weapons then
86710: LD_VAR 0 8
86714: PUSH
86715: LD_VAR 0 9
86719: IN
86720: IFFALSE 86747
// begin result := [ i , weapon ] ;
86722: LD_ADDR_VAR 0 3
86726: PUSH
86727: LD_VAR 0 4
86731: PUSH
86732: LD_VAR 0 8
86736: PUSH
86737: EMPTY
86738: LIST
86739: LIST
86740: ST_TO_ADDR
// exit ;
86741: POP
86742: POP
86743: POP
86744: POP
86745: GO 86755
// end ; end ;
86747: GO 86683
86749: POP
86750: POP
// end ;
86751: GO 86569
86753: POP
86754: POP
// end ;
86755: LD_VAR 0 3
86759: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
86760: LD_INT 0
86762: PPUSH
// if not side or side > 8 then
86763: LD_VAR 0 3
86767: NOT
86768: PUSH
86769: LD_VAR 0 3
86773: PUSH
86774: LD_INT 8
86776: GREATER
86777: OR
86778: IFFALSE 86782
// exit ;
86780: GO 86841
// if not range then
86782: LD_VAR 0 4
86786: NOT
86787: IFFALSE 86798
// range := - 12 ;
86789: LD_ADDR_VAR 0 4
86793: PUSH
86794: LD_INT 12
86796: NEG
86797: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
86798: LD_VAR 0 1
86802: PPUSH
86803: LD_VAR 0 2
86807: PPUSH
86808: LD_VAR 0 3
86812: PPUSH
86813: LD_VAR 0 4
86817: PPUSH
86818: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
86822: LD_VAR 0 1
86826: PPUSH
86827: LD_VAR 0 2
86831: PPUSH
86832: LD_VAR 0 3
86836: PPUSH
86837: CALL_OW 331
// end ;
86841: LD_VAR 0 5
86845: RET
// export function Video ( mode ) ; begin
86846: LD_INT 0
86848: PPUSH
// ingame_video = mode ;
86849: LD_ADDR_OWVAR 52
86853: PUSH
86854: LD_VAR 0 1
86858: ST_TO_ADDR
// interface_hidden = mode ;
86859: LD_ADDR_OWVAR 54
86863: PUSH
86864: LD_VAR 0 1
86868: ST_TO_ADDR
// end ;
86869: LD_VAR 0 2
86873: RET
// export function Join ( array , element ) ; begin
86874: LD_INT 0
86876: PPUSH
// result := Replace ( array , array + 1 , element ) ;
86877: LD_ADDR_VAR 0 3
86881: PUSH
86882: LD_VAR 0 1
86886: PPUSH
86887: LD_VAR 0 1
86891: PUSH
86892: LD_INT 1
86894: PLUS
86895: PPUSH
86896: LD_VAR 0 2
86900: PPUSH
86901: CALL_OW 1
86905: ST_TO_ADDR
// end ;
86906: LD_VAR 0 3
86910: RET
// export function JoinUnion ( array , element ) ; begin
86911: LD_INT 0
86913: PPUSH
// result := array union element ;
86914: LD_ADDR_VAR 0 3
86918: PUSH
86919: LD_VAR 0 1
86923: PUSH
86924: LD_VAR 0 2
86928: UNION
86929: ST_TO_ADDR
// end ;
86930: LD_VAR 0 3
86934: RET
// export function GetBehemoths ( side ) ; begin
86935: LD_INT 0
86937: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
86938: LD_ADDR_VAR 0 2
86942: PUSH
86943: LD_INT 22
86945: PUSH
86946: LD_VAR 0 1
86950: PUSH
86951: EMPTY
86952: LIST
86953: LIST
86954: PUSH
86955: LD_INT 31
86957: PUSH
86958: LD_INT 25
86960: PUSH
86961: EMPTY
86962: LIST
86963: LIST
86964: PUSH
86965: EMPTY
86966: LIST
86967: LIST
86968: PPUSH
86969: CALL_OW 69
86973: ST_TO_ADDR
// end ;
86974: LD_VAR 0 2
86978: RET
// export function Shuffle ( array ) ; var i , index ; begin
86979: LD_INT 0
86981: PPUSH
86982: PPUSH
86983: PPUSH
// result := [ ] ;
86984: LD_ADDR_VAR 0 2
86988: PUSH
86989: EMPTY
86990: ST_TO_ADDR
// if not array then
86991: LD_VAR 0 1
86995: NOT
86996: IFFALSE 87000
// exit ;
86998: GO 87099
// Randomize ;
87000: CALL_OW 10
// for i = array downto 1 do
87004: LD_ADDR_VAR 0 3
87008: PUSH
87009: DOUBLE
87010: LD_VAR 0 1
87014: INC
87015: ST_TO_ADDR
87016: LD_INT 1
87018: PUSH
87019: FOR_DOWNTO
87020: IFFALSE 87097
// begin index := rand ( 1 , array ) ;
87022: LD_ADDR_VAR 0 4
87026: PUSH
87027: LD_INT 1
87029: PPUSH
87030: LD_VAR 0 1
87034: PPUSH
87035: CALL_OW 12
87039: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
87040: LD_ADDR_VAR 0 2
87044: PUSH
87045: LD_VAR 0 2
87049: PPUSH
87050: LD_VAR 0 2
87054: PUSH
87055: LD_INT 1
87057: PLUS
87058: PPUSH
87059: LD_VAR 0 1
87063: PUSH
87064: LD_VAR 0 4
87068: ARRAY
87069: PPUSH
87070: CALL_OW 2
87074: ST_TO_ADDR
// array := Delete ( array , index ) ;
87075: LD_ADDR_VAR 0 1
87079: PUSH
87080: LD_VAR 0 1
87084: PPUSH
87085: LD_VAR 0 4
87089: PPUSH
87090: CALL_OW 3
87094: ST_TO_ADDR
// end ;
87095: GO 87019
87097: POP
87098: POP
// end ;
87099: LD_VAR 0 2
87103: RET
// export function GetBaseMaterials ( base ) ; begin
87104: LD_INT 0
87106: PPUSH
// result := [ 0 , 0 , 0 ] ;
87107: LD_ADDR_VAR 0 2
87111: PUSH
87112: LD_INT 0
87114: PUSH
87115: LD_INT 0
87117: PUSH
87118: LD_INT 0
87120: PUSH
87121: EMPTY
87122: LIST
87123: LIST
87124: LIST
87125: ST_TO_ADDR
// if not base then
87126: LD_VAR 0 1
87130: NOT
87131: IFFALSE 87135
// exit ;
87133: GO 87184
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
87135: LD_ADDR_VAR 0 2
87139: PUSH
87140: LD_VAR 0 1
87144: PPUSH
87145: LD_INT 1
87147: PPUSH
87148: CALL_OW 275
87152: PUSH
87153: LD_VAR 0 1
87157: PPUSH
87158: LD_INT 2
87160: PPUSH
87161: CALL_OW 275
87165: PUSH
87166: LD_VAR 0 1
87170: PPUSH
87171: LD_INT 3
87173: PPUSH
87174: CALL_OW 275
87178: PUSH
87179: EMPTY
87180: LIST
87181: LIST
87182: LIST
87183: ST_TO_ADDR
// end ;
87184: LD_VAR 0 2
87188: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
87189: LD_INT 0
87191: PPUSH
87192: PPUSH
// result := array ;
87193: LD_ADDR_VAR 0 3
87197: PUSH
87198: LD_VAR 0 1
87202: ST_TO_ADDR
// if size >= result then
87203: LD_VAR 0 2
87207: PUSH
87208: LD_VAR 0 3
87212: GREATEREQUAL
87213: IFFALSE 87217
// exit ;
87215: GO 87267
// if size then
87217: LD_VAR 0 2
87221: IFFALSE 87267
// for i := array downto size do
87223: LD_ADDR_VAR 0 4
87227: PUSH
87228: DOUBLE
87229: LD_VAR 0 1
87233: INC
87234: ST_TO_ADDR
87235: LD_VAR 0 2
87239: PUSH
87240: FOR_DOWNTO
87241: IFFALSE 87265
// result := Delete ( result , result ) ;
87243: LD_ADDR_VAR 0 3
87247: PUSH
87248: LD_VAR 0 3
87252: PPUSH
87253: LD_VAR 0 3
87257: PPUSH
87258: CALL_OW 3
87262: ST_TO_ADDR
87263: GO 87240
87265: POP
87266: POP
// end ;
87267: LD_VAR 0 3
87271: RET
// export function ComExit ( unit ) ; var tmp ; begin
87272: LD_INT 0
87274: PPUSH
87275: PPUSH
// if not IsInUnit ( unit ) then
87276: LD_VAR 0 1
87280: PPUSH
87281: CALL_OW 310
87285: NOT
87286: IFFALSE 87290
// exit ;
87288: GO 87350
// tmp := IsInUnit ( unit ) ;
87290: LD_ADDR_VAR 0 3
87294: PUSH
87295: LD_VAR 0 1
87299: PPUSH
87300: CALL_OW 310
87304: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
87305: LD_VAR 0 3
87309: PPUSH
87310: CALL_OW 247
87314: PUSH
87315: LD_INT 2
87317: EQUAL
87318: IFFALSE 87331
// ComExitVehicle ( unit ) else
87320: LD_VAR 0 1
87324: PPUSH
87325: CALL_OW 121
87329: GO 87340
// ComExitBuilding ( unit ) ;
87331: LD_VAR 0 1
87335: PPUSH
87336: CALL_OW 122
// result := tmp ;
87340: LD_ADDR_VAR 0 2
87344: PUSH
87345: LD_VAR 0 3
87349: ST_TO_ADDR
// end ;
87350: LD_VAR 0 2
87354: RET
// export function ComExitAll ( units ) ; var i ; begin
87355: LD_INT 0
87357: PPUSH
87358: PPUSH
// if not units then
87359: LD_VAR 0 1
87363: NOT
87364: IFFALSE 87368
// exit ;
87366: GO 87394
// for i in units do
87368: LD_ADDR_VAR 0 3
87372: PUSH
87373: LD_VAR 0 1
87377: PUSH
87378: FOR_IN
87379: IFFALSE 87392
// ComExit ( i ) ;
87381: LD_VAR 0 3
87385: PPUSH
87386: CALL 87272 0 1
87390: GO 87378
87392: POP
87393: POP
// end ;
87394: LD_VAR 0 2
87398: RET
// export function ResetHc ; begin
87399: LD_INT 0
87401: PPUSH
// InitHc ;
87402: CALL_OW 19
// hc_importance := 0 ;
87406: LD_ADDR_OWVAR 32
87410: PUSH
87411: LD_INT 0
87413: ST_TO_ADDR
// end ;
87414: LD_VAR 0 1
87418: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
87419: LD_INT 0
87421: PPUSH
87422: PPUSH
87423: PPUSH
// _x := ( x1 + x2 ) div 2 ;
87424: LD_ADDR_VAR 0 6
87428: PUSH
87429: LD_VAR 0 1
87433: PUSH
87434: LD_VAR 0 3
87438: PLUS
87439: PUSH
87440: LD_INT 2
87442: DIV
87443: ST_TO_ADDR
// if _x < 0 then
87444: LD_VAR 0 6
87448: PUSH
87449: LD_INT 0
87451: LESS
87452: IFFALSE 87469
// _x := _x * - 1 ;
87454: LD_ADDR_VAR 0 6
87458: PUSH
87459: LD_VAR 0 6
87463: PUSH
87464: LD_INT 1
87466: NEG
87467: MUL
87468: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
87469: LD_ADDR_VAR 0 7
87473: PUSH
87474: LD_VAR 0 2
87478: PUSH
87479: LD_VAR 0 4
87483: PLUS
87484: PUSH
87485: LD_INT 2
87487: DIV
87488: ST_TO_ADDR
// if _y < 0 then
87489: LD_VAR 0 7
87493: PUSH
87494: LD_INT 0
87496: LESS
87497: IFFALSE 87514
// _y := _y * - 1 ;
87499: LD_ADDR_VAR 0 7
87503: PUSH
87504: LD_VAR 0 7
87508: PUSH
87509: LD_INT 1
87511: NEG
87512: MUL
87513: ST_TO_ADDR
// result := [ _x , _y ] ;
87514: LD_ADDR_VAR 0 5
87518: PUSH
87519: LD_VAR 0 6
87523: PUSH
87524: LD_VAR 0 7
87528: PUSH
87529: EMPTY
87530: LIST
87531: LIST
87532: ST_TO_ADDR
// end ;
87533: LD_VAR 0 5
87537: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
87538: LD_INT 0
87540: PPUSH
87541: PPUSH
87542: PPUSH
87543: PPUSH
// task := GetTaskList ( unit ) ;
87544: LD_ADDR_VAR 0 7
87548: PUSH
87549: LD_VAR 0 1
87553: PPUSH
87554: CALL_OW 437
87558: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
87559: LD_VAR 0 7
87563: NOT
87564: PUSH
87565: LD_VAR 0 1
87569: PPUSH
87570: LD_VAR 0 2
87574: PPUSH
87575: CALL_OW 308
87579: NOT
87580: AND
87581: IFFALSE 87585
// exit ;
87583: GO 87703
// if IsInArea ( unit , area ) then
87585: LD_VAR 0 1
87589: PPUSH
87590: LD_VAR 0 2
87594: PPUSH
87595: CALL_OW 308
87599: IFFALSE 87617
// begin ComMoveToArea ( unit , goAway ) ;
87601: LD_VAR 0 1
87605: PPUSH
87606: LD_VAR 0 3
87610: PPUSH
87611: CALL_OW 113
// exit ;
87615: GO 87703
// end ; if task [ 1 ] [ 1 ] <> M then
87617: LD_VAR 0 7
87621: PUSH
87622: LD_INT 1
87624: ARRAY
87625: PUSH
87626: LD_INT 1
87628: ARRAY
87629: PUSH
87630: LD_STRING M
87632: NONEQUAL
87633: IFFALSE 87637
// exit ;
87635: GO 87703
// x := task [ 1 ] [ 2 ] ;
87637: LD_ADDR_VAR 0 5
87641: PUSH
87642: LD_VAR 0 7
87646: PUSH
87647: LD_INT 1
87649: ARRAY
87650: PUSH
87651: LD_INT 2
87653: ARRAY
87654: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
87655: LD_ADDR_VAR 0 6
87659: PUSH
87660: LD_VAR 0 7
87664: PUSH
87665: LD_INT 1
87667: ARRAY
87668: PUSH
87669: LD_INT 3
87671: ARRAY
87672: ST_TO_ADDR
// if InArea ( x , y , area ) then
87673: LD_VAR 0 5
87677: PPUSH
87678: LD_VAR 0 6
87682: PPUSH
87683: LD_VAR 0 2
87687: PPUSH
87688: CALL_OW 309
87692: IFFALSE 87703
// ComStop ( unit ) ;
87694: LD_VAR 0 1
87698: PPUSH
87699: CALL_OW 141
// end ;
87703: LD_VAR 0 4
87707: RET
// export function Abs ( value ) ; begin
87708: LD_INT 0
87710: PPUSH
// result := value ;
87711: LD_ADDR_VAR 0 2
87715: PUSH
87716: LD_VAR 0 1
87720: ST_TO_ADDR
// if value < 0 then
87721: LD_VAR 0 1
87725: PUSH
87726: LD_INT 0
87728: LESS
87729: IFFALSE 87746
// result := value * - 1 ;
87731: LD_ADDR_VAR 0 2
87735: PUSH
87736: LD_VAR 0 1
87740: PUSH
87741: LD_INT 1
87743: NEG
87744: MUL
87745: ST_TO_ADDR
// end ;
87746: LD_VAR 0 2
87750: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
87751: LD_INT 0
87753: PPUSH
87754: PPUSH
87755: PPUSH
87756: PPUSH
87757: PPUSH
87758: PPUSH
87759: PPUSH
87760: PPUSH
// if not unit or not building then
87761: LD_VAR 0 1
87765: NOT
87766: PUSH
87767: LD_VAR 0 2
87771: NOT
87772: OR
87773: IFFALSE 87777
// exit ;
87775: GO 88003
// x := GetX ( building ) ;
87777: LD_ADDR_VAR 0 4
87781: PUSH
87782: LD_VAR 0 2
87786: PPUSH
87787: CALL_OW 250
87791: ST_TO_ADDR
// y := GetY ( building ) ;
87792: LD_ADDR_VAR 0 6
87796: PUSH
87797: LD_VAR 0 2
87801: PPUSH
87802: CALL_OW 251
87806: ST_TO_ADDR
// d := GetDir ( building ) ;
87807: LD_ADDR_VAR 0 8
87811: PUSH
87812: LD_VAR 0 2
87816: PPUSH
87817: CALL_OW 254
87821: ST_TO_ADDR
// r := 4 ;
87822: LD_ADDR_VAR 0 9
87826: PUSH
87827: LD_INT 4
87829: ST_TO_ADDR
// for i := 1 to 5 do
87830: LD_ADDR_VAR 0 10
87834: PUSH
87835: DOUBLE
87836: LD_INT 1
87838: DEC
87839: ST_TO_ADDR
87840: LD_INT 5
87842: PUSH
87843: FOR_TO
87844: IFFALSE 88001
// begin _x := ShiftX ( x , d , r + i ) ;
87846: LD_ADDR_VAR 0 5
87850: PUSH
87851: LD_VAR 0 4
87855: PPUSH
87856: LD_VAR 0 8
87860: PPUSH
87861: LD_VAR 0 9
87865: PUSH
87866: LD_VAR 0 10
87870: PLUS
87871: PPUSH
87872: CALL_OW 272
87876: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
87877: LD_ADDR_VAR 0 7
87881: PUSH
87882: LD_VAR 0 6
87886: PPUSH
87887: LD_VAR 0 8
87891: PPUSH
87892: LD_VAR 0 9
87896: PUSH
87897: LD_VAR 0 10
87901: PLUS
87902: PPUSH
87903: CALL_OW 273
87907: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
87908: LD_VAR 0 5
87912: PPUSH
87913: LD_VAR 0 7
87917: PPUSH
87918: CALL_OW 488
87922: PUSH
87923: LD_VAR 0 5
87927: PPUSH
87928: LD_VAR 0 7
87932: PPUSH
87933: CALL_OW 428
87937: PPUSH
87938: CALL_OW 247
87942: PUSH
87943: LD_INT 3
87945: PUSH
87946: LD_INT 2
87948: PUSH
87949: EMPTY
87950: LIST
87951: LIST
87952: IN
87953: NOT
87954: AND
87955: IFFALSE 87999
// begin ComMoveXY ( unit , _x , _y ) ;
87957: LD_VAR 0 1
87961: PPUSH
87962: LD_VAR 0 5
87966: PPUSH
87967: LD_VAR 0 7
87971: PPUSH
87972: CALL_OW 111
// result := [ _x , _y ] ;
87976: LD_ADDR_VAR 0 3
87980: PUSH
87981: LD_VAR 0 5
87985: PUSH
87986: LD_VAR 0 7
87990: PUSH
87991: EMPTY
87992: LIST
87993: LIST
87994: ST_TO_ADDR
// exit ;
87995: POP
87996: POP
87997: GO 88003
// end ; end ;
87999: GO 87843
88001: POP
88002: POP
// end ;
88003: LD_VAR 0 3
88007: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
88008: LD_INT 0
88010: PPUSH
88011: PPUSH
88012: PPUSH
// result := 0 ;
88013: LD_ADDR_VAR 0 3
88017: PUSH
88018: LD_INT 0
88020: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
88021: LD_VAR 0 1
88025: PUSH
88026: LD_INT 0
88028: LESS
88029: PUSH
88030: LD_VAR 0 1
88034: PUSH
88035: LD_INT 8
88037: GREATER
88038: OR
88039: PUSH
88040: LD_VAR 0 2
88044: PUSH
88045: LD_INT 0
88047: LESS
88048: OR
88049: PUSH
88050: LD_VAR 0 2
88054: PUSH
88055: LD_INT 8
88057: GREATER
88058: OR
88059: IFFALSE 88063
// exit ;
88061: GO 88138
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
88063: LD_ADDR_VAR 0 4
88067: PUSH
88068: LD_INT 22
88070: PUSH
88071: LD_VAR 0 2
88075: PUSH
88076: EMPTY
88077: LIST
88078: LIST
88079: PPUSH
88080: CALL_OW 69
88084: PUSH
88085: FOR_IN
88086: IFFALSE 88136
// begin un := UnitShoot ( i ) ;
88088: LD_ADDR_VAR 0 5
88092: PUSH
88093: LD_VAR 0 4
88097: PPUSH
88098: CALL_OW 504
88102: ST_TO_ADDR
// if GetSide ( un ) = side1 then
88103: LD_VAR 0 5
88107: PPUSH
88108: CALL_OW 255
88112: PUSH
88113: LD_VAR 0 1
88117: EQUAL
88118: IFFALSE 88134
// begin result := un ;
88120: LD_ADDR_VAR 0 3
88124: PUSH
88125: LD_VAR 0 5
88129: ST_TO_ADDR
// exit ;
88130: POP
88131: POP
88132: GO 88138
// end ; end ;
88134: GO 88085
88136: POP
88137: POP
// end ;
88138: LD_VAR 0 3
88142: RET
// export function GetCargoBay ( units ) ; begin
88143: LD_INT 0
88145: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
88146: LD_ADDR_VAR 0 2
88150: PUSH
88151: LD_VAR 0 1
88155: PPUSH
88156: LD_INT 2
88158: PUSH
88159: LD_INT 34
88161: PUSH
88162: LD_INT 12
88164: PUSH
88165: EMPTY
88166: LIST
88167: LIST
88168: PUSH
88169: LD_INT 34
88171: PUSH
88172: LD_INT 51
88174: PUSH
88175: EMPTY
88176: LIST
88177: LIST
88178: PUSH
88179: LD_INT 34
88181: PUSH
88182: LD_INT 32
88184: PUSH
88185: EMPTY
88186: LIST
88187: LIST
88188: PUSH
88189: LD_INT 34
88191: PUSH
88192: LD_INT 89
88194: PUSH
88195: EMPTY
88196: LIST
88197: LIST
88198: PUSH
88199: EMPTY
88200: LIST
88201: LIST
88202: LIST
88203: LIST
88204: LIST
88205: PPUSH
88206: CALL_OW 72
88210: ST_TO_ADDR
// end ;
88211: LD_VAR 0 2
88215: RET
// export function Negate ( value ) ; begin
88216: LD_INT 0
88218: PPUSH
// result := not value ;
88219: LD_ADDR_VAR 0 2
88223: PUSH
88224: LD_VAR 0 1
88228: NOT
88229: ST_TO_ADDR
// end ;
88230: LD_VAR 0 2
88234: RET
// export function Inc ( value ) ; begin
88235: LD_INT 0
88237: PPUSH
// result := value + 1 ;
88238: LD_ADDR_VAR 0 2
88242: PUSH
88243: LD_VAR 0 1
88247: PUSH
88248: LD_INT 1
88250: PLUS
88251: ST_TO_ADDR
// end ;
88252: LD_VAR 0 2
88256: RET
// export function Dec ( value ) ; begin
88257: LD_INT 0
88259: PPUSH
// result := value - 1 ;
88260: LD_ADDR_VAR 0 2
88264: PUSH
88265: LD_VAR 0 1
88269: PUSH
88270: LD_INT 1
88272: MINUS
88273: ST_TO_ADDR
// end ;
88274: LD_VAR 0 2
88278: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
88279: LD_INT 0
88281: PPUSH
88282: PPUSH
88283: PPUSH
88284: PPUSH
88285: PPUSH
88286: PPUSH
88287: PPUSH
88288: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
88289: LD_VAR 0 1
88293: PPUSH
88294: LD_VAR 0 2
88298: PPUSH
88299: CALL_OW 488
88303: NOT
88304: PUSH
88305: LD_VAR 0 3
88309: PPUSH
88310: LD_VAR 0 4
88314: PPUSH
88315: CALL_OW 488
88319: NOT
88320: OR
88321: IFFALSE 88334
// begin result := - 1 ;
88323: LD_ADDR_VAR 0 5
88327: PUSH
88328: LD_INT 1
88330: NEG
88331: ST_TO_ADDR
// exit ;
88332: GO 88569
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
88334: LD_ADDR_VAR 0 12
88338: PUSH
88339: LD_VAR 0 1
88343: PPUSH
88344: LD_VAR 0 2
88348: PPUSH
88349: LD_VAR 0 3
88353: PPUSH
88354: LD_VAR 0 4
88358: PPUSH
88359: CALL 87419 0 4
88363: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
88364: LD_ADDR_VAR 0 11
88368: PUSH
88369: LD_VAR 0 1
88373: PPUSH
88374: LD_VAR 0 2
88378: PPUSH
88379: LD_VAR 0 12
88383: PUSH
88384: LD_INT 1
88386: ARRAY
88387: PPUSH
88388: LD_VAR 0 12
88392: PUSH
88393: LD_INT 2
88395: ARRAY
88396: PPUSH
88397: CALL_OW 298
88401: ST_TO_ADDR
// distance := 9999 ;
88402: LD_ADDR_VAR 0 10
88406: PUSH
88407: LD_INT 9999
88409: ST_TO_ADDR
// for i := 0 to 5 do
88410: LD_ADDR_VAR 0 6
88414: PUSH
88415: DOUBLE
88416: LD_INT 0
88418: DEC
88419: ST_TO_ADDR
88420: LD_INT 5
88422: PUSH
88423: FOR_TO
88424: IFFALSE 88567
// begin _x := ShiftX ( x1 , i , centerDist ) ;
88426: LD_ADDR_VAR 0 7
88430: PUSH
88431: LD_VAR 0 1
88435: PPUSH
88436: LD_VAR 0 6
88440: PPUSH
88441: LD_VAR 0 11
88445: PPUSH
88446: CALL_OW 272
88450: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
88451: LD_ADDR_VAR 0 8
88455: PUSH
88456: LD_VAR 0 2
88460: PPUSH
88461: LD_VAR 0 6
88465: PPUSH
88466: LD_VAR 0 11
88470: PPUSH
88471: CALL_OW 273
88475: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
88476: LD_VAR 0 7
88480: PPUSH
88481: LD_VAR 0 8
88485: PPUSH
88486: CALL_OW 488
88490: NOT
88491: IFFALSE 88495
// continue ;
88493: GO 88423
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
88495: LD_ADDR_VAR 0 9
88499: PUSH
88500: LD_VAR 0 12
88504: PUSH
88505: LD_INT 1
88507: ARRAY
88508: PPUSH
88509: LD_VAR 0 12
88513: PUSH
88514: LD_INT 2
88516: ARRAY
88517: PPUSH
88518: LD_VAR 0 7
88522: PPUSH
88523: LD_VAR 0 8
88527: PPUSH
88528: CALL_OW 298
88532: ST_TO_ADDR
// if tmp < distance then
88533: LD_VAR 0 9
88537: PUSH
88538: LD_VAR 0 10
88542: LESS
88543: IFFALSE 88565
// begin result := i ;
88545: LD_ADDR_VAR 0 5
88549: PUSH
88550: LD_VAR 0 6
88554: ST_TO_ADDR
// distance := tmp ;
88555: LD_ADDR_VAR 0 10
88559: PUSH
88560: LD_VAR 0 9
88564: ST_TO_ADDR
// end ; end ;
88565: GO 88423
88567: POP
88568: POP
// end ;
88569: LD_VAR 0 5
88573: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
88574: LD_INT 0
88576: PPUSH
88577: PPUSH
// if not driver or not IsInUnit ( driver ) then
88578: LD_VAR 0 1
88582: NOT
88583: PUSH
88584: LD_VAR 0 1
88588: PPUSH
88589: CALL_OW 310
88593: NOT
88594: OR
88595: IFFALSE 88599
// exit ;
88597: GO 88689
// vehicle := IsInUnit ( driver ) ;
88599: LD_ADDR_VAR 0 3
88603: PUSH
88604: LD_VAR 0 1
88608: PPUSH
88609: CALL_OW 310
88613: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
88614: LD_VAR 0 1
88618: PPUSH
88619: LD_STRING \
88621: PUSH
88622: LD_INT 0
88624: PUSH
88625: LD_INT 0
88627: PUSH
88628: LD_INT 0
88630: PUSH
88631: LD_INT 0
88633: PUSH
88634: LD_INT 0
88636: PUSH
88637: LD_INT 0
88639: PUSH
88640: EMPTY
88641: LIST
88642: LIST
88643: LIST
88644: LIST
88645: LIST
88646: LIST
88647: LIST
88648: PUSH
88649: LD_STRING E
88651: PUSH
88652: LD_INT 0
88654: PUSH
88655: LD_INT 0
88657: PUSH
88658: LD_VAR 0 3
88662: PUSH
88663: LD_INT 0
88665: PUSH
88666: LD_INT 0
88668: PUSH
88669: LD_INT 0
88671: PUSH
88672: EMPTY
88673: LIST
88674: LIST
88675: LIST
88676: LIST
88677: LIST
88678: LIST
88679: LIST
88680: PUSH
88681: EMPTY
88682: LIST
88683: LIST
88684: PPUSH
88685: CALL_OW 446
// end ;
88689: LD_VAR 0 2
88693: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
88694: LD_INT 0
88696: PPUSH
88697: PPUSH
// if not driver or not IsInUnit ( driver ) then
88698: LD_VAR 0 1
88702: NOT
88703: PUSH
88704: LD_VAR 0 1
88708: PPUSH
88709: CALL_OW 310
88713: NOT
88714: OR
88715: IFFALSE 88719
// exit ;
88717: GO 88809
// vehicle := IsInUnit ( driver ) ;
88719: LD_ADDR_VAR 0 3
88723: PUSH
88724: LD_VAR 0 1
88728: PPUSH
88729: CALL_OW 310
88733: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
88734: LD_VAR 0 1
88738: PPUSH
88739: LD_STRING \
88741: PUSH
88742: LD_INT 0
88744: PUSH
88745: LD_INT 0
88747: PUSH
88748: LD_INT 0
88750: PUSH
88751: LD_INT 0
88753: PUSH
88754: LD_INT 0
88756: PUSH
88757: LD_INT 0
88759: PUSH
88760: EMPTY
88761: LIST
88762: LIST
88763: LIST
88764: LIST
88765: LIST
88766: LIST
88767: LIST
88768: PUSH
88769: LD_STRING E
88771: PUSH
88772: LD_INT 0
88774: PUSH
88775: LD_INT 0
88777: PUSH
88778: LD_VAR 0 3
88782: PUSH
88783: LD_INT 0
88785: PUSH
88786: LD_INT 0
88788: PUSH
88789: LD_INT 0
88791: PUSH
88792: EMPTY
88793: LIST
88794: LIST
88795: LIST
88796: LIST
88797: LIST
88798: LIST
88799: LIST
88800: PUSH
88801: EMPTY
88802: LIST
88803: LIST
88804: PPUSH
88805: CALL_OW 447
// end ;
88809: LD_VAR 0 2
88813: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
88814: LD_INT 0
88816: PPUSH
88817: PPUSH
88818: PPUSH
// tmp := [ ] ;
88819: LD_ADDR_VAR 0 5
88823: PUSH
88824: EMPTY
88825: ST_TO_ADDR
// for i in units do
88826: LD_ADDR_VAR 0 4
88830: PUSH
88831: LD_VAR 0 1
88835: PUSH
88836: FOR_IN
88837: IFFALSE 88875
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
88839: LD_ADDR_VAR 0 5
88843: PUSH
88844: LD_VAR 0 5
88848: PPUSH
88849: LD_VAR 0 5
88853: PUSH
88854: LD_INT 1
88856: PLUS
88857: PPUSH
88858: LD_VAR 0 4
88862: PPUSH
88863: CALL_OW 256
88867: PPUSH
88868: CALL_OW 2
88872: ST_TO_ADDR
88873: GO 88836
88875: POP
88876: POP
// if not tmp then
88877: LD_VAR 0 5
88881: NOT
88882: IFFALSE 88886
// exit ;
88884: GO 88934
// if asc then
88886: LD_VAR 0 2
88890: IFFALSE 88914
// result := SortListByListAsc ( units , tmp ) else
88892: LD_ADDR_VAR 0 3
88896: PUSH
88897: LD_VAR 0 1
88901: PPUSH
88902: LD_VAR 0 5
88906: PPUSH
88907: CALL_OW 76
88911: ST_TO_ADDR
88912: GO 88934
// result := SortListByListDesc ( units , tmp ) ;
88914: LD_ADDR_VAR 0 3
88918: PUSH
88919: LD_VAR 0 1
88923: PPUSH
88924: LD_VAR 0 5
88928: PPUSH
88929: CALL_OW 77
88933: ST_TO_ADDR
// end ;
88934: LD_VAR 0 3
88938: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
88939: LD_INT 0
88941: PPUSH
88942: PPUSH
// task := GetTaskList ( mech ) ;
88943: LD_ADDR_VAR 0 4
88947: PUSH
88948: LD_VAR 0 1
88952: PPUSH
88953: CALL_OW 437
88957: ST_TO_ADDR
// if not task then
88958: LD_VAR 0 4
88962: NOT
88963: IFFALSE 88967
// exit ;
88965: GO 89009
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
88967: LD_ADDR_VAR 0 3
88971: PUSH
88972: LD_VAR 0 4
88976: PUSH
88977: LD_INT 1
88979: ARRAY
88980: PUSH
88981: LD_INT 1
88983: ARRAY
88984: PUSH
88985: LD_STRING r
88987: EQUAL
88988: PUSH
88989: LD_VAR 0 4
88993: PUSH
88994: LD_INT 1
88996: ARRAY
88997: PUSH
88998: LD_INT 4
89000: ARRAY
89001: PUSH
89002: LD_VAR 0 2
89006: EQUAL
89007: AND
89008: ST_TO_ADDR
// end ;
89009: LD_VAR 0 3
89013: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
89014: LD_INT 0
89016: PPUSH
// SetDir ( unit , d ) ;
89017: LD_VAR 0 1
89021: PPUSH
89022: LD_VAR 0 4
89026: PPUSH
89027: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
89031: LD_VAR 0 1
89035: PPUSH
89036: LD_VAR 0 2
89040: PPUSH
89041: LD_VAR 0 3
89045: PPUSH
89046: LD_VAR 0 5
89050: PPUSH
89051: CALL_OW 48
// end ;
89055: LD_VAR 0 6
89059: RET
// export function ToNaturalNumber ( number ) ; begin
89060: LD_INT 0
89062: PPUSH
// result := number div 1 ;
89063: LD_ADDR_VAR 0 2
89067: PUSH
89068: LD_VAR 0 1
89072: PUSH
89073: LD_INT 1
89075: DIV
89076: ST_TO_ADDR
// if number < 0 then
89077: LD_VAR 0 1
89081: PUSH
89082: LD_INT 0
89084: LESS
89085: IFFALSE 89095
// result := 0 ;
89087: LD_ADDR_VAR 0 2
89091: PUSH
89092: LD_INT 0
89094: ST_TO_ADDR
// end ;
89095: LD_VAR 0 2
89099: RET
// export function SortByClass ( units , class ) ; var un ; begin
89100: LD_INT 0
89102: PPUSH
89103: PPUSH
// if not units or not class then
89104: LD_VAR 0 1
89108: NOT
89109: PUSH
89110: LD_VAR 0 2
89114: NOT
89115: OR
89116: IFFALSE 89120
// exit ;
89118: GO 89215
// result := [ ] ;
89120: LD_ADDR_VAR 0 3
89124: PUSH
89125: EMPTY
89126: ST_TO_ADDR
// for un in units do
89127: LD_ADDR_VAR 0 4
89131: PUSH
89132: LD_VAR 0 1
89136: PUSH
89137: FOR_IN
89138: IFFALSE 89213
// if GetClass ( un ) = class then
89140: LD_VAR 0 4
89144: PPUSH
89145: CALL_OW 257
89149: PUSH
89150: LD_VAR 0 2
89154: EQUAL
89155: IFFALSE 89182
// result := Insert ( result , 1 , un ) else
89157: LD_ADDR_VAR 0 3
89161: PUSH
89162: LD_VAR 0 3
89166: PPUSH
89167: LD_INT 1
89169: PPUSH
89170: LD_VAR 0 4
89174: PPUSH
89175: CALL_OW 2
89179: ST_TO_ADDR
89180: GO 89211
// result := Replace ( result , result + 1 , un ) ;
89182: LD_ADDR_VAR 0 3
89186: PUSH
89187: LD_VAR 0 3
89191: PPUSH
89192: LD_VAR 0 3
89196: PUSH
89197: LD_INT 1
89199: PLUS
89200: PPUSH
89201: LD_VAR 0 4
89205: PPUSH
89206: CALL_OW 1
89210: ST_TO_ADDR
89211: GO 89137
89213: POP
89214: POP
// end ;
89215: LD_VAR 0 3
89219: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
89220: LD_INT 0
89222: PPUSH
89223: PPUSH
89224: PPUSH
89225: PPUSH
89226: PPUSH
89227: PPUSH
89228: PPUSH
// result := [ ] ;
89229: LD_ADDR_VAR 0 4
89233: PUSH
89234: EMPTY
89235: ST_TO_ADDR
// if x - r < 0 then
89236: LD_VAR 0 1
89240: PUSH
89241: LD_VAR 0 3
89245: MINUS
89246: PUSH
89247: LD_INT 0
89249: LESS
89250: IFFALSE 89262
// min_x := 0 else
89252: LD_ADDR_VAR 0 8
89256: PUSH
89257: LD_INT 0
89259: ST_TO_ADDR
89260: GO 89278
// min_x := x - r ;
89262: LD_ADDR_VAR 0 8
89266: PUSH
89267: LD_VAR 0 1
89271: PUSH
89272: LD_VAR 0 3
89276: MINUS
89277: ST_TO_ADDR
// if y - r < 0 then
89278: LD_VAR 0 2
89282: PUSH
89283: LD_VAR 0 3
89287: MINUS
89288: PUSH
89289: LD_INT 0
89291: LESS
89292: IFFALSE 89304
// min_y := 0 else
89294: LD_ADDR_VAR 0 7
89298: PUSH
89299: LD_INT 0
89301: ST_TO_ADDR
89302: GO 89320
// min_y := y - r ;
89304: LD_ADDR_VAR 0 7
89308: PUSH
89309: LD_VAR 0 2
89313: PUSH
89314: LD_VAR 0 3
89318: MINUS
89319: ST_TO_ADDR
// max_x := x + r ;
89320: LD_ADDR_VAR 0 9
89324: PUSH
89325: LD_VAR 0 1
89329: PUSH
89330: LD_VAR 0 3
89334: PLUS
89335: ST_TO_ADDR
// max_y := y + r ;
89336: LD_ADDR_VAR 0 10
89340: PUSH
89341: LD_VAR 0 2
89345: PUSH
89346: LD_VAR 0 3
89350: PLUS
89351: ST_TO_ADDR
// for _x = min_x to max_x do
89352: LD_ADDR_VAR 0 5
89356: PUSH
89357: DOUBLE
89358: LD_VAR 0 8
89362: DEC
89363: ST_TO_ADDR
89364: LD_VAR 0 9
89368: PUSH
89369: FOR_TO
89370: IFFALSE 89471
// for _y = min_y to max_y do
89372: LD_ADDR_VAR 0 6
89376: PUSH
89377: DOUBLE
89378: LD_VAR 0 7
89382: DEC
89383: ST_TO_ADDR
89384: LD_VAR 0 10
89388: PUSH
89389: FOR_TO
89390: IFFALSE 89467
// begin if not ValidHex ( _x , _y ) then
89392: LD_VAR 0 5
89396: PPUSH
89397: LD_VAR 0 6
89401: PPUSH
89402: CALL_OW 488
89406: NOT
89407: IFFALSE 89411
// continue ;
89409: GO 89389
// if GetResourceTypeXY ( _x , _y ) then
89411: LD_VAR 0 5
89415: PPUSH
89416: LD_VAR 0 6
89420: PPUSH
89421: CALL_OW 283
89425: IFFALSE 89465
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
89427: LD_ADDR_VAR 0 4
89431: PUSH
89432: LD_VAR 0 4
89436: PPUSH
89437: LD_VAR 0 4
89441: PUSH
89442: LD_INT 1
89444: PLUS
89445: PPUSH
89446: LD_VAR 0 5
89450: PUSH
89451: LD_VAR 0 6
89455: PUSH
89456: EMPTY
89457: LIST
89458: LIST
89459: PPUSH
89460: CALL_OW 1
89464: ST_TO_ADDR
// end ;
89465: GO 89389
89467: POP
89468: POP
89469: GO 89369
89471: POP
89472: POP
// end ;
89473: LD_VAR 0 4
89477: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
89478: LD_INT 0
89480: PPUSH
89481: PPUSH
89482: PPUSH
89483: PPUSH
89484: PPUSH
89485: PPUSH
89486: PPUSH
89487: PPUSH
// if not units then
89488: LD_VAR 0 1
89492: NOT
89493: IFFALSE 89497
// exit ;
89495: GO 90021
// result := UnitFilter ( units , [ f_ok ] ) ;
89497: LD_ADDR_VAR 0 3
89501: PUSH
89502: LD_VAR 0 1
89506: PPUSH
89507: LD_INT 50
89509: PUSH
89510: EMPTY
89511: LIST
89512: PPUSH
89513: CALL_OW 72
89517: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
89518: LD_ADDR_VAR 0 8
89522: PUSH
89523: LD_VAR 0 1
89527: PUSH
89528: LD_INT 1
89530: ARRAY
89531: PPUSH
89532: CALL_OW 255
89536: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
89537: LD_ADDR_VAR 0 10
89541: PUSH
89542: LD_INT 29
89544: PUSH
89545: LD_INT 91
89547: PUSH
89548: LD_INT 49
89550: PUSH
89551: EMPTY
89552: LIST
89553: LIST
89554: LIST
89555: ST_TO_ADDR
// if not result then
89556: LD_VAR 0 3
89560: NOT
89561: IFFALSE 89565
// exit ;
89563: GO 90021
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
89565: LD_ADDR_VAR 0 5
89569: PUSH
89570: LD_INT 81
89572: PUSH
89573: LD_VAR 0 8
89577: PUSH
89578: EMPTY
89579: LIST
89580: LIST
89581: PPUSH
89582: CALL_OW 69
89586: ST_TO_ADDR
// for i in result do
89587: LD_ADDR_VAR 0 4
89591: PUSH
89592: LD_VAR 0 3
89596: PUSH
89597: FOR_IN
89598: IFFALSE 90019
// begin tag := GetTag ( i ) + 1 ;
89600: LD_ADDR_VAR 0 9
89604: PUSH
89605: LD_VAR 0 4
89609: PPUSH
89610: CALL_OW 110
89614: PUSH
89615: LD_INT 1
89617: PLUS
89618: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
89619: LD_ADDR_VAR 0 7
89623: PUSH
89624: LD_VAR 0 4
89628: PPUSH
89629: CALL_OW 250
89633: PPUSH
89634: LD_VAR 0 4
89638: PPUSH
89639: CALL_OW 251
89643: PPUSH
89644: LD_INT 6
89646: PPUSH
89647: CALL 89220 0 3
89651: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
89652: LD_VAR 0 4
89656: PPUSH
89657: CALL_OW 247
89661: PUSH
89662: LD_INT 2
89664: EQUAL
89665: PUSH
89666: LD_VAR 0 7
89670: AND
89671: PUSH
89672: LD_VAR 0 4
89676: PPUSH
89677: CALL_OW 264
89681: PUSH
89682: LD_VAR 0 10
89686: IN
89687: NOT
89688: AND
89689: IFFALSE 89728
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
89691: LD_VAR 0 4
89695: PPUSH
89696: LD_VAR 0 7
89700: PUSH
89701: LD_INT 1
89703: ARRAY
89704: PUSH
89705: LD_INT 1
89707: ARRAY
89708: PPUSH
89709: LD_VAR 0 7
89713: PUSH
89714: LD_INT 1
89716: ARRAY
89717: PUSH
89718: LD_INT 2
89720: ARRAY
89721: PPUSH
89722: CALL_OW 116
89726: GO 90017
// if path > tag then
89728: LD_VAR 0 2
89732: PUSH
89733: LD_VAR 0 9
89737: GREATER
89738: IFFALSE 89946
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
89740: LD_ADDR_VAR 0 6
89744: PUSH
89745: LD_VAR 0 5
89749: PPUSH
89750: LD_INT 91
89752: PUSH
89753: LD_VAR 0 4
89757: PUSH
89758: LD_INT 8
89760: PUSH
89761: EMPTY
89762: LIST
89763: LIST
89764: LIST
89765: PPUSH
89766: CALL_OW 72
89770: ST_TO_ADDR
// if nearEnemy then
89771: LD_VAR 0 6
89775: IFFALSE 89844
// begin if GetWeapon ( i ) = ru_time_lapser then
89777: LD_VAR 0 4
89781: PPUSH
89782: CALL_OW 264
89786: PUSH
89787: LD_INT 49
89789: EQUAL
89790: IFFALSE 89818
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
89792: LD_VAR 0 4
89796: PPUSH
89797: LD_VAR 0 6
89801: PPUSH
89802: LD_VAR 0 4
89806: PPUSH
89807: CALL_OW 74
89811: PPUSH
89812: CALL_OW 112
89816: GO 89842
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
89818: LD_VAR 0 4
89822: PPUSH
89823: LD_VAR 0 6
89827: PPUSH
89828: LD_VAR 0 4
89832: PPUSH
89833: CALL_OW 74
89837: PPUSH
89838: CALL 90946 0 2
// end else
89842: GO 89944
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
89844: LD_VAR 0 4
89848: PPUSH
89849: LD_VAR 0 2
89853: PUSH
89854: LD_VAR 0 9
89858: ARRAY
89859: PUSH
89860: LD_INT 1
89862: ARRAY
89863: PPUSH
89864: LD_VAR 0 2
89868: PUSH
89869: LD_VAR 0 9
89873: ARRAY
89874: PUSH
89875: LD_INT 2
89877: ARRAY
89878: PPUSH
89879: CALL_OW 297
89883: PUSH
89884: LD_INT 6
89886: GREATER
89887: IFFALSE 89930
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
89889: LD_VAR 0 4
89893: PPUSH
89894: LD_VAR 0 2
89898: PUSH
89899: LD_VAR 0 9
89903: ARRAY
89904: PUSH
89905: LD_INT 1
89907: ARRAY
89908: PPUSH
89909: LD_VAR 0 2
89913: PUSH
89914: LD_VAR 0 9
89918: ARRAY
89919: PUSH
89920: LD_INT 2
89922: ARRAY
89923: PPUSH
89924: CALL_OW 114
89928: GO 89944
// SetTag ( i , tag ) ;
89930: LD_VAR 0 4
89934: PPUSH
89935: LD_VAR 0 9
89939: PPUSH
89940: CALL_OW 109
// end else
89944: GO 90017
// if enemy then
89946: LD_VAR 0 5
89950: IFFALSE 90017
// begin if GetWeapon ( i ) = ru_time_lapser then
89952: LD_VAR 0 4
89956: PPUSH
89957: CALL_OW 264
89961: PUSH
89962: LD_INT 49
89964: EQUAL
89965: IFFALSE 89993
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
89967: LD_VAR 0 4
89971: PPUSH
89972: LD_VAR 0 5
89976: PPUSH
89977: LD_VAR 0 4
89981: PPUSH
89982: CALL_OW 74
89986: PPUSH
89987: CALL_OW 112
89991: GO 90017
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
89993: LD_VAR 0 4
89997: PPUSH
89998: LD_VAR 0 5
90002: PPUSH
90003: LD_VAR 0 4
90007: PPUSH
90008: CALL_OW 74
90012: PPUSH
90013: CALL 90946 0 2
// end ; end ;
90017: GO 89597
90019: POP
90020: POP
// end ;
90021: LD_VAR 0 3
90025: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
90026: LD_INT 0
90028: PPUSH
90029: PPUSH
90030: PPUSH
// if not unit or IsInUnit ( unit ) then
90031: LD_VAR 0 1
90035: NOT
90036: PUSH
90037: LD_VAR 0 1
90041: PPUSH
90042: CALL_OW 310
90046: OR
90047: IFFALSE 90051
// exit ;
90049: GO 90142
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
90051: LD_ADDR_VAR 0 4
90055: PUSH
90056: LD_VAR 0 1
90060: PPUSH
90061: CALL_OW 250
90065: PPUSH
90066: LD_VAR 0 2
90070: PPUSH
90071: LD_INT 1
90073: PPUSH
90074: CALL_OW 272
90078: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
90079: LD_ADDR_VAR 0 5
90083: PUSH
90084: LD_VAR 0 1
90088: PPUSH
90089: CALL_OW 251
90093: PPUSH
90094: LD_VAR 0 2
90098: PPUSH
90099: LD_INT 1
90101: PPUSH
90102: CALL_OW 273
90106: ST_TO_ADDR
// if ValidHex ( x , y ) then
90107: LD_VAR 0 4
90111: PPUSH
90112: LD_VAR 0 5
90116: PPUSH
90117: CALL_OW 488
90121: IFFALSE 90142
// ComTurnXY ( unit , x , y ) ;
90123: LD_VAR 0 1
90127: PPUSH
90128: LD_VAR 0 4
90132: PPUSH
90133: LD_VAR 0 5
90137: PPUSH
90138: CALL_OW 118
// end ;
90142: LD_VAR 0 3
90146: RET
// export function SeeUnits ( side , units ) ; var i ; begin
90147: LD_INT 0
90149: PPUSH
90150: PPUSH
// result := false ;
90151: LD_ADDR_VAR 0 3
90155: PUSH
90156: LD_INT 0
90158: ST_TO_ADDR
// if not units then
90159: LD_VAR 0 2
90163: NOT
90164: IFFALSE 90168
// exit ;
90166: GO 90213
// for i in units do
90168: LD_ADDR_VAR 0 4
90172: PUSH
90173: LD_VAR 0 2
90177: PUSH
90178: FOR_IN
90179: IFFALSE 90211
// if See ( side , i ) then
90181: LD_VAR 0 1
90185: PPUSH
90186: LD_VAR 0 4
90190: PPUSH
90191: CALL_OW 292
90195: IFFALSE 90209
// begin result := true ;
90197: LD_ADDR_VAR 0 3
90201: PUSH
90202: LD_INT 1
90204: ST_TO_ADDR
// exit ;
90205: POP
90206: POP
90207: GO 90213
// end ;
90209: GO 90178
90211: POP
90212: POP
// end ;
90213: LD_VAR 0 3
90217: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
90218: LD_INT 0
90220: PPUSH
90221: PPUSH
90222: PPUSH
90223: PPUSH
// if not unit or not points then
90224: LD_VAR 0 1
90228: NOT
90229: PUSH
90230: LD_VAR 0 2
90234: NOT
90235: OR
90236: IFFALSE 90240
// exit ;
90238: GO 90330
// dist := 99999 ;
90240: LD_ADDR_VAR 0 5
90244: PUSH
90245: LD_INT 99999
90247: ST_TO_ADDR
// for i in points do
90248: LD_ADDR_VAR 0 4
90252: PUSH
90253: LD_VAR 0 2
90257: PUSH
90258: FOR_IN
90259: IFFALSE 90328
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
90261: LD_ADDR_VAR 0 6
90265: PUSH
90266: LD_VAR 0 1
90270: PPUSH
90271: LD_VAR 0 4
90275: PUSH
90276: LD_INT 1
90278: ARRAY
90279: PPUSH
90280: LD_VAR 0 4
90284: PUSH
90285: LD_INT 2
90287: ARRAY
90288: PPUSH
90289: CALL_OW 297
90293: ST_TO_ADDR
// if tmpDist < dist then
90294: LD_VAR 0 6
90298: PUSH
90299: LD_VAR 0 5
90303: LESS
90304: IFFALSE 90326
// begin result := i ;
90306: LD_ADDR_VAR 0 3
90310: PUSH
90311: LD_VAR 0 4
90315: ST_TO_ADDR
// dist := tmpDist ;
90316: LD_ADDR_VAR 0 5
90320: PUSH
90321: LD_VAR 0 6
90325: ST_TO_ADDR
// end ; end ;
90326: GO 90258
90328: POP
90329: POP
// end ;
90330: LD_VAR 0 3
90334: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
90335: LD_INT 0
90337: PPUSH
// uc_side := side ;
90338: LD_ADDR_OWVAR 20
90342: PUSH
90343: LD_VAR 0 1
90347: ST_TO_ADDR
// uc_nation := 3 ;
90348: LD_ADDR_OWVAR 21
90352: PUSH
90353: LD_INT 3
90355: ST_TO_ADDR
// vc_chassis := 25 ;
90356: LD_ADDR_OWVAR 37
90360: PUSH
90361: LD_INT 25
90363: ST_TO_ADDR
// vc_engine := engine_siberite ;
90364: LD_ADDR_OWVAR 39
90368: PUSH
90369: LD_INT 3
90371: ST_TO_ADDR
// vc_control := control_computer ;
90372: LD_ADDR_OWVAR 38
90376: PUSH
90377: LD_INT 3
90379: ST_TO_ADDR
// vc_weapon := 59 ;
90380: LD_ADDR_OWVAR 40
90384: PUSH
90385: LD_INT 59
90387: ST_TO_ADDR
// result := CreateVehicle ;
90388: LD_ADDR_VAR 0 5
90392: PUSH
90393: CALL_OW 45
90397: ST_TO_ADDR
// SetDir ( result , d ) ;
90398: LD_VAR 0 5
90402: PPUSH
90403: LD_VAR 0 4
90407: PPUSH
90408: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
90412: LD_VAR 0 5
90416: PPUSH
90417: LD_VAR 0 2
90421: PPUSH
90422: LD_VAR 0 3
90426: PPUSH
90427: LD_INT 0
90429: PPUSH
90430: CALL_OW 48
// end ;
90434: LD_VAR 0 5
90438: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
90439: LD_INT 0
90441: PPUSH
90442: PPUSH
90443: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
90444: LD_ADDR_VAR 0 2
90448: PUSH
90449: LD_INT 0
90451: PUSH
90452: LD_INT 0
90454: PUSH
90455: LD_INT 0
90457: PUSH
90458: LD_INT 0
90460: PUSH
90461: EMPTY
90462: LIST
90463: LIST
90464: LIST
90465: LIST
90466: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
90467: LD_VAR 0 1
90471: NOT
90472: PUSH
90473: LD_VAR 0 1
90477: PPUSH
90478: CALL_OW 264
90482: PUSH
90483: LD_INT 12
90485: PUSH
90486: LD_INT 51
90488: PUSH
90489: LD_INT 32
90491: PUSH
90492: LD_INT 89
90494: PUSH
90495: EMPTY
90496: LIST
90497: LIST
90498: LIST
90499: LIST
90500: IN
90501: NOT
90502: OR
90503: IFFALSE 90507
// exit ;
90505: GO 90605
// for i := 1 to 3 do
90507: LD_ADDR_VAR 0 3
90511: PUSH
90512: DOUBLE
90513: LD_INT 1
90515: DEC
90516: ST_TO_ADDR
90517: LD_INT 3
90519: PUSH
90520: FOR_TO
90521: IFFALSE 90603
// begin tmp := GetCargo ( cargo , i ) ;
90523: LD_ADDR_VAR 0 4
90527: PUSH
90528: LD_VAR 0 1
90532: PPUSH
90533: LD_VAR 0 3
90537: PPUSH
90538: CALL_OW 289
90542: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
90543: LD_ADDR_VAR 0 2
90547: PUSH
90548: LD_VAR 0 2
90552: PPUSH
90553: LD_VAR 0 3
90557: PPUSH
90558: LD_VAR 0 4
90562: PPUSH
90563: CALL_OW 1
90567: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
90568: LD_ADDR_VAR 0 2
90572: PUSH
90573: LD_VAR 0 2
90577: PPUSH
90578: LD_INT 4
90580: PPUSH
90581: LD_VAR 0 2
90585: PUSH
90586: LD_INT 4
90588: ARRAY
90589: PUSH
90590: LD_VAR 0 4
90594: PLUS
90595: PPUSH
90596: CALL_OW 1
90600: ST_TO_ADDR
// end ;
90601: GO 90520
90603: POP
90604: POP
// end ;
90605: LD_VAR 0 2
90609: RET
// export function Length ( array ) ; begin
90610: LD_INT 0
90612: PPUSH
// result := array + 0 ;
90613: LD_ADDR_VAR 0 2
90617: PUSH
90618: LD_VAR 0 1
90622: PUSH
90623: LD_INT 0
90625: PLUS
90626: ST_TO_ADDR
// end ;
90627: LD_VAR 0 2
90631: RET
// export function PrepareArray ( array ) ; begin
90632: LD_INT 0
90634: PPUSH
// result := array diff 0 ;
90635: LD_ADDR_VAR 0 2
90639: PUSH
90640: LD_VAR 0 1
90644: PUSH
90645: LD_INT 0
90647: DIFF
90648: ST_TO_ADDR
// if not result [ 1 ] then
90649: LD_VAR 0 2
90653: PUSH
90654: LD_INT 1
90656: ARRAY
90657: NOT
90658: IFFALSE 90678
// result := Delete ( result , 1 ) ;
90660: LD_ADDR_VAR 0 2
90664: PUSH
90665: LD_VAR 0 2
90669: PPUSH
90670: LD_INT 1
90672: PPUSH
90673: CALL_OW 3
90677: ST_TO_ADDR
// end ;
90678: LD_VAR 0 2
90682: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
90683: LD_INT 0
90685: PPUSH
90686: PPUSH
90687: PPUSH
90688: PPUSH
// sibRocketRange := 25 ;
90689: LD_ADDR_VAR 0 6
90693: PUSH
90694: LD_INT 25
90696: ST_TO_ADDR
// result := false ;
90697: LD_ADDR_VAR 0 4
90701: PUSH
90702: LD_INT 0
90704: ST_TO_ADDR
// for i := 0 to 5 do
90705: LD_ADDR_VAR 0 5
90709: PUSH
90710: DOUBLE
90711: LD_INT 0
90713: DEC
90714: ST_TO_ADDR
90715: LD_INT 5
90717: PUSH
90718: FOR_TO
90719: IFFALSE 90786
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
90721: LD_VAR 0 1
90725: PPUSH
90726: LD_VAR 0 5
90730: PPUSH
90731: LD_VAR 0 6
90735: PPUSH
90736: CALL_OW 272
90740: PPUSH
90741: LD_VAR 0 2
90745: PPUSH
90746: LD_VAR 0 5
90750: PPUSH
90751: LD_VAR 0 6
90755: PPUSH
90756: CALL_OW 273
90760: PPUSH
90761: LD_VAR 0 3
90765: PPUSH
90766: CALL_OW 309
90770: IFFALSE 90784
// begin result := true ;
90772: LD_ADDR_VAR 0 4
90776: PUSH
90777: LD_INT 1
90779: ST_TO_ADDR
// exit ;
90780: POP
90781: POP
90782: GO 90788
// end ;
90784: GO 90718
90786: POP
90787: POP
// end ;
90788: LD_VAR 0 4
90792: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
90793: LD_INT 0
90795: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
90796: LD_VAR 0 1
90800: PPUSH
90801: LD_VAR 0 2
90805: PPUSH
90806: LD_INT 0
90808: PPUSH
90809: LD_INT 0
90811: PPUSH
90812: LD_INT 1
90814: PPUSH
90815: LD_INT 0
90817: PPUSH
90818: CALL_OW 587
// end ;
90822: LD_VAR 0 3
90826: RET
// export function CenterOnNow ( unit ) ; begin
90827: LD_INT 0
90829: PPUSH
// result := IsInUnit ( unit ) ;
90830: LD_ADDR_VAR 0 2
90834: PUSH
90835: LD_VAR 0 1
90839: PPUSH
90840: CALL_OW 310
90844: ST_TO_ADDR
// if not result then
90845: LD_VAR 0 2
90849: NOT
90850: IFFALSE 90862
// result := unit ;
90852: LD_ADDR_VAR 0 2
90856: PUSH
90857: LD_VAR 0 1
90861: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
90862: LD_VAR 0 1
90866: PPUSH
90867: CALL_OW 87
// end ;
90871: LD_VAR 0 2
90875: RET
// export function ComMoveHex ( unit , hex ) ; begin
90876: LD_INT 0
90878: PPUSH
// if not hex then
90879: LD_VAR 0 2
90883: NOT
90884: IFFALSE 90888
// exit ;
90886: GO 90941
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
90888: LD_VAR 0 2
90892: PUSH
90893: LD_INT 1
90895: ARRAY
90896: PPUSH
90897: LD_VAR 0 2
90901: PUSH
90902: LD_INT 2
90904: ARRAY
90905: PPUSH
90906: CALL_OW 428
90910: IFFALSE 90914
// exit ;
90912: GO 90941
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
90914: LD_VAR 0 1
90918: PPUSH
90919: LD_VAR 0 2
90923: PUSH
90924: LD_INT 1
90926: ARRAY
90927: PPUSH
90928: LD_VAR 0 2
90932: PUSH
90933: LD_INT 2
90935: ARRAY
90936: PPUSH
90937: CALL_OW 111
// end ;
90941: LD_VAR 0 3
90945: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
90946: LD_INT 0
90948: PPUSH
90949: PPUSH
90950: PPUSH
// if not unit or not enemy then
90951: LD_VAR 0 1
90955: NOT
90956: PUSH
90957: LD_VAR 0 2
90961: NOT
90962: OR
90963: IFFALSE 90967
// exit ;
90965: GO 91091
// x := GetX ( enemy ) ;
90967: LD_ADDR_VAR 0 4
90971: PUSH
90972: LD_VAR 0 2
90976: PPUSH
90977: CALL_OW 250
90981: ST_TO_ADDR
// y := GetY ( enemy ) ;
90982: LD_ADDR_VAR 0 5
90986: PUSH
90987: LD_VAR 0 2
90991: PPUSH
90992: CALL_OW 251
90996: ST_TO_ADDR
// if ValidHex ( x , y ) then
90997: LD_VAR 0 4
91001: PPUSH
91002: LD_VAR 0 5
91006: PPUSH
91007: CALL_OW 488
91011: IFFALSE 91091
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] or See ( GetSide ( unit ) , enemy ) then
91013: LD_VAR 0 2
91017: PPUSH
91018: CALL_OW 247
91022: PUSH
91023: LD_INT 3
91025: PUSH
91026: LD_INT 2
91028: PUSH
91029: EMPTY
91030: LIST
91031: LIST
91032: IN
91033: PUSH
91034: LD_VAR 0 1
91038: PPUSH
91039: CALL_OW 255
91043: PPUSH
91044: LD_VAR 0 2
91048: PPUSH
91049: CALL_OW 292
91053: OR
91054: IFFALSE 91072
// ComAttackUnit ( unit , enemy ) else
91056: LD_VAR 0 1
91060: PPUSH
91061: LD_VAR 0 2
91065: PPUSH
91066: CALL_OW 115
91070: GO 91091
// ComAgressiveMove ( unit , x , y ) ;
91072: LD_VAR 0 1
91076: PPUSH
91077: LD_VAR 0 4
91081: PPUSH
91082: LD_VAR 0 5
91086: PPUSH
91087: CALL_OW 114
// end ;
91091: LD_VAR 0 3
91095: RET
// export function GetSourcesFromArea ( area , all ) ; var i , list ; begin
91096: LD_INT 0
91098: PPUSH
91099: PPUSH
91100: PPUSH
// list := AreaToList ( area , 0 ) ;
91101: LD_ADDR_VAR 0 5
91105: PUSH
91106: LD_VAR 0 1
91110: PPUSH
91111: LD_INT 0
91113: PPUSH
91114: CALL_OW 517
91118: ST_TO_ADDR
// if not list then
91119: LD_VAR 0 5
91123: NOT
91124: IFFALSE 91128
// exit ;
91126: GO 91258
// if all then
91128: LD_VAR 0 2
91132: IFFALSE 91220
// begin for i := 1 to list [ 1 ] do
91134: LD_ADDR_VAR 0 4
91138: PUSH
91139: DOUBLE
91140: LD_INT 1
91142: DEC
91143: ST_TO_ADDR
91144: LD_VAR 0 5
91148: PUSH
91149: LD_INT 1
91151: ARRAY
91152: PUSH
91153: FOR_TO
91154: IFFALSE 91216
// result := Replace ( result , result + 1 , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
91156: LD_ADDR_VAR 0 3
91160: PUSH
91161: LD_VAR 0 3
91165: PPUSH
91166: LD_VAR 0 3
91170: PUSH
91171: LD_INT 1
91173: PLUS
91174: PPUSH
91175: LD_VAR 0 5
91179: PUSH
91180: LD_INT 1
91182: ARRAY
91183: PUSH
91184: LD_VAR 0 4
91188: ARRAY
91189: PUSH
91190: LD_VAR 0 5
91194: PUSH
91195: LD_INT 2
91197: ARRAY
91198: PUSH
91199: LD_VAR 0 4
91203: ARRAY
91204: PUSH
91205: EMPTY
91206: LIST
91207: LIST
91208: PPUSH
91209: CALL_OW 1
91213: ST_TO_ADDR
91214: GO 91153
91216: POP
91217: POP
// exit ;
91218: GO 91258
// end ; result := [ [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] ] ] ;
91220: LD_ADDR_VAR 0 3
91224: PUSH
91225: LD_VAR 0 5
91229: PUSH
91230: LD_INT 1
91232: ARRAY
91233: PUSH
91234: LD_INT 1
91236: ARRAY
91237: PUSH
91238: LD_VAR 0 5
91242: PUSH
91243: LD_INT 2
91245: ARRAY
91246: PUSH
91247: LD_INT 1
91249: ARRAY
91250: PUSH
91251: EMPTY
91252: LIST
91253: LIST
91254: PUSH
91255: EMPTY
91256: LIST
91257: ST_TO_ADDR
// end ;
91258: LD_VAR 0 3
91262: RET
// export function GetBuildingFromArea ( area , direction ) ; var list ; begin
91263: LD_INT 0
91265: PPUSH
91266: PPUSH
// list := AreaToList ( area , 0 ) ;
91267: LD_ADDR_VAR 0 4
91271: PUSH
91272: LD_VAR 0 1
91276: PPUSH
91277: LD_INT 0
91279: PPUSH
91280: CALL_OW 517
91284: ST_TO_ADDR
// if not list then
91285: LD_VAR 0 4
91289: NOT
91290: IFFALSE 91294
// exit ;
91292: GO 91335
// result := [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] , direction ] ;
91294: LD_ADDR_VAR 0 3
91298: PUSH
91299: LD_VAR 0 4
91303: PUSH
91304: LD_INT 1
91306: ARRAY
91307: PUSH
91308: LD_INT 1
91310: ARRAY
91311: PUSH
91312: LD_VAR 0 4
91316: PUSH
91317: LD_INT 2
91319: ARRAY
91320: PUSH
91321: LD_INT 1
91323: ARRAY
91324: PUSH
91325: LD_VAR 0 2
91329: PUSH
91330: EMPTY
91331: LIST
91332: LIST
91333: LIST
91334: ST_TO_ADDR
// end ;
91335: LD_VAR 0 3
91339: RET
// export function First ( array ) ; begin
91340: LD_INT 0
91342: PPUSH
// if not array then
91343: LD_VAR 0 1
91347: NOT
91348: IFFALSE 91352
// exit ;
91350: GO 91366
// result := array [ 1 ] ;
91352: LD_ADDR_VAR 0 2
91356: PUSH
91357: LD_VAR 0 1
91361: PUSH
91362: LD_INT 1
91364: ARRAY
91365: ST_TO_ADDR
// end ;
91366: LD_VAR 0 2
91370: RET
// export function Last ( array ) ; begin
91371: LD_INT 0
91373: PPUSH
// if not array then
91374: LD_VAR 0 1
91378: NOT
91379: IFFALSE 91383
// exit ;
91381: GO 91399
// result := array [ array ] ;
91383: LD_ADDR_VAR 0 2
91387: PUSH
91388: LD_VAR 0 1
91392: PUSH
91393: LD_VAR 0 1
91397: ARRAY
91398: ST_TO_ADDR
// end ;
91399: LD_VAR 0 2
91403: RET
// export function CheckByIndex ( array , index , value , indexColumn ) ; var i ; begin
91404: LD_INT 0
91406: PPUSH
91407: PPUSH
// result := [ ] ;
91408: LD_ADDR_VAR 0 5
91412: PUSH
91413: EMPTY
91414: ST_TO_ADDR
// if not array then
91415: LD_VAR 0 1
91419: NOT
91420: IFFALSE 91424
// exit ;
91422: GO 91536
// for i := 1 to array do
91424: LD_ADDR_VAR 0 6
91428: PUSH
91429: DOUBLE
91430: LD_INT 1
91432: DEC
91433: ST_TO_ADDR
91434: LD_VAR 0 1
91438: PUSH
91439: FOR_TO
91440: IFFALSE 91534
// if array [ i ] [ index ] = value then
91442: LD_VAR 0 1
91446: PUSH
91447: LD_VAR 0 6
91451: ARRAY
91452: PUSH
91453: LD_VAR 0 2
91457: ARRAY
91458: PUSH
91459: LD_VAR 0 3
91463: EQUAL
91464: IFFALSE 91532
// begin if indexColumn then
91466: LD_VAR 0 4
91470: IFFALSE 91506
// result := Join ( result , array [ i ] [ indexColumn ] ) else
91472: LD_ADDR_VAR 0 5
91476: PUSH
91477: LD_VAR 0 5
91481: PPUSH
91482: LD_VAR 0 1
91486: PUSH
91487: LD_VAR 0 6
91491: ARRAY
91492: PUSH
91493: LD_VAR 0 4
91497: ARRAY
91498: PPUSH
91499: CALL 86874 0 2
91503: ST_TO_ADDR
91504: GO 91532
// result := Join ( result , array [ i ] ) ;
91506: LD_ADDR_VAR 0 5
91510: PUSH
91511: LD_VAR 0 5
91515: PPUSH
91516: LD_VAR 0 1
91520: PUSH
91521: LD_VAR 0 6
91525: ARRAY
91526: PPUSH
91527: CALL 86874 0 2
91531: ST_TO_ADDR
// end ;
91532: GO 91439
91534: POP
91535: POP
// end ;
91536: LD_VAR 0 5
91540: RET
// export function CanBeBuiltOnlyResources ( depot , btype ) ; var pom , cost ; begin
91541: LD_INT 0
91543: PPUSH
91544: PPUSH
91545: PPUSH
// if btype = b_depot then
91546: LD_VAR 0 2
91550: PUSH
91551: LD_INT 0
91553: EQUAL
91554: IFFALSE 91566
// begin result := true ;
91556: LD_ADDR_VAR 0 3
91560: PUSH
91561: LD_INT 1
91563: ST_TO_ADDR
// exit ;
91564: GO 91682
// end ; pom := GetBase ( depot ) ;
91566: LD_ADDR_VAR 0 4
91570: PUSH
91571: LD_VAR 0 1
91575: PPUSH
91576: CALL_OW 274
91580: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
91581: LD_ADDR_VAR 0 5
91585: PUSH
91586: LD_VAR 0 2
91590: PPUSH
91591: LD_VAR 0 1
91595: PPUSH
91596: CALL_OW 248
91600: PPUSH
91601: CALL_OW 450
91605: ST_TO_ADDR
// result := ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) ;
91606: LD_ADDR_VAR 0 3
91610: PUSH
91611: LD_VAR 0 4
91615: PPUSH
91616: LD_INT 1
91618: PPUSH
91619: CALL_OW 275
91623: PUSH
91624: LD_VAR 0 5
91628: PUSH
91629: LD_INT 1
91631: ARRAY
91632: GREATEREQUAL
91633: PUSH
91634: LD_VAR 0 4
91638: PPUSH
91639: LD_INT 2
91641: PPUSH
91642: CALL_OW 275
91646: PUSH
91647: LD_VAR 0 5
91651: PUSH
91652: LD_INT 2
91654: ARRAY
91655: GREATEREQUAL
91656: AND
91657: PUSH
91658: LD_VAR 0 4
91662: PPUSH
91663: LD_INT 3
91665: PPUSH
91666: CALL_OW 275
91670: PUSH
91671: LD_VAR 0 5
91675: PUSH
91676: LD_INT 3
91678: ARRAY
91679: GREATEREQUAL
91680: AND
91681: ST_TO_ADDR
// end ;
91682: LD_VAR 0 3
91686: RET
// export function ComBackOnParking ( vehicles , parkingPoint ) ; begin
91687: LD_INT 0
91689: PPUSH
// if not vehicles or not parkingPoint then
91690: LD_VAR 0 1
91694: NOT
91695: PUSH
91696: LD_VAR 0 2
91700: NOT
91701: OR
91702: IFFALSE 91706
// exit ;
91704: GO 91804
// vehicles := UnitFilter ( vehicles , [ [ f_ok ] , [ f_not , [ f_distxy , parkingPoint [ 1 ] , parkingPoint [ 2 ] , 8 ] ] ] ) ;
91706: LD_ADDR_VAR 0 1
91710: PUSH
91711: LD_VAR 0 1
91715: PPUSH
91716: LD_INT 50
91718: PUSH
91719: EMPTY
91720: LIST
91721: PUSH
91722: LD_INT 3
91724: PUSH
91725: LD_INT 92
91727: PUSH
91728: LD_VAR 0 2
91732: PUSH
91733: LD_INT 1
91735: ARRAY
91736: PUSH
91737: LD_VAR 0 2
91741: PUSH
91742: LD_INT 2
91744: ARRAY
91745: PUSH
91746: LD_INT 8
91748: PUSH
91749: EMPTY
91750: LIST
91751: LIST
91752: LIST
91753: LIST
91754: PUSH
91755: EMPTY
91756: LIST
91757: LIST
91758: PUSH
91759: EMPTY
91760: LIST
91761: LIST
91762: PPUSH
91763: CALL_OW 72
91767: ST_TO_ADDR
// if not vehicles then
91768: LD_VAR 0 1
91772: NOT
91773: IFFALSE 91777
// exit ;
91775: GO 91804
// ComMoveXY ( vehicles , parkingPoint [ 1 ] , parkingPoint [ 2 ] ) ;
91777: LD_VAR 0 1
91781: PPUSH
91782: LD_VAR 0 2
91786: PUSH
91787: LD_INT 1
91789: ARRAY
91790: PPUSH
91791: LD_VAR 0 2
91795: PUSH
91796: LD_INT 2
91798: ARRAY
91799: PPUSH
91800: CALL_OW 111
// end ;
91804: LD_VAR 0 3
91808: RET
// export function PlaceHiddenCamerasInArea ( side , area ) ; var i , tmp ; begin
91809: LD_INT 0
91811: PPUSH
91812: PPUSH
91813: PPUSH
// if not side or not area then
91814: LD_VAR 0 1
91818: NOT
91819: PUSH
91820: LD_VAR 0 2
91824: NOT
91825: OR
91826: IFFALSE 91830
// exit ;
91828: GO 91949
// tmp := AreaToList ( area , 0 ) ;
91830: LD_ADDR_VAR 0 5
91834: PUSH
91835: LD_VAR 0 2
91839: PPUSH
91840: LD_INT 0
91842: PPUSH
91843: CALL_OW 517
91847: ST_TO_ADDR
// for i := 1 to tmp [ 1 ] do
91848: LD_ADDR_VAR 0 4
91852: PUSH
91853: DOUBLE
91854: LD_INT 1
91856: DEC
91857: ST_TO_ADDR
91858: LD_VAR 0 5
91862: PUSH
91863: LD_INT 1
91865: ARRAY
91866: PUSH
91867: FOR_TO
91868: IFFALSE 91947
// begin if IsEnvironment ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ) then
91870: LD_VAR 0 5
91874: PUSH
91875: LD_INT 1
91877: ARRAY
91878: PUSH
91879: LD_VAR 0 4
91883: ARRAY
91884: PPUSH
91885: LD_VAR 0 5
91889: PUSH
91890: LD_INT 2
91892: ARRAY
91893: PUSH
91894: LD_VAR 0 4
91898: ARRAY
91899: PPUSH
91900: CALL_OW 351
91904: IFFALSE 91945
// HiddenCamera ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , side ) ;
91906: LD_VAR 0 5
91910: PUSH
91911: LD_INT 1
91913: ARRAY
91914: PUSH
91915: LD_VAR 0 4
91919: ARRAY
91920: PPUSH
91921: LD_VAR 0 5
91925: PUSH
91926: LD_INT 2
91928: ARRAY
91929: PUSH
91930: LD_VAR 0 4
91934: ARRAY
91935: PPUSH
91936: LD_VAR 0 1
91940: PPUSH
91941: CALL_OW 244
// end ;
91945: GO 91867
91947: POP
91948: POP
// end ; end_of_file end_of_file
91949: LD_VAR 0 3
91953: RET
// export globalGameSaveCounter ; every 0 0$1 do
91954: GO 91956
91956: DISABLE
// begin enable ;
91957: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
91958: LD_STRING updateTimer(
91960: PUSH
91961: LD_OWVAR 1
91965: STR
91966: PUSH
91967: LD_STRING );
91969: STR
91970: PPUSH
91971: CALL_OW 559
// end ;
91975: END
// every 0 0$1 do
91976: GO 91978
91978: DISABLE
// begin globalGameSaveCounter := 0 ;
91979: LD_ADDR_EXP 95
91983: PUSH
91984: LD_INT 0
91986: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
91987: LD_STRING setGameSaveCounter(0)
91989: PPUSH
91990: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
91994: LD_STRING initStreamRollete();
91996: PPUSH
91997: CALL_OW 559
// InitStreamMode ;
92001: CALL 93344 0 0
// DefineStreamItems ( false ) ;
92005: LD_INT 0
92007: PPUSH
92008: CALL 93808 0 1
// end ;
92012: END
// export function SOS_MapStart ( ) ; begin
92013: LD_INT 0
92015: PPUSH
// if streamModeActive then
92016: LD_EXP 96
92020: IFFALSE 92029
// DefineStreamItems ( true ) ;
92022: LD_INT 1
92024: PPUSH
92025: CALL 93808 0 1
// UpdateLuaVariables ( ) ;
92029: CALL 92046 0 0
// UpdateFactoryWaypoints ( ) ;
92033: CALL 106677 0 0
// UpdateWarehouseGatheringPoints ( ) ;
92037: CALL 106934 0 0
// end ;
92041: LD_VAR 0 1
92045: RET
// function UpdateLuaVariables ( ) ; begin
92046: LD_INT 0
92048: PPUSH
// if globalGameSaveCounter then
92049: LD_EXP 95
92053: IFFALSE 92087
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
92055: LD_ADDR_EXP 95
92059: PUSH
92060: LD_EXP 95
92064: PPUSH
92065: CALL 88235 0 1
92069: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
92070: LD_STRING setGameSaveCounter(
92072: PUSH
92073: LD_EXP 95
92077: STR
92078: PUSH
92079: LD_STRING )
92081: STR
92082: PPUSH
92083: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
92087: LD_STRING setGameDifficulty(
92089: PUSH
92090: LD_OWVAR 67
92094: STR
92095: PUSH
92096: LD_STRING )
92098: STR
92099: PPUSH
92100: CALL_OW 559
// ToLua ( displayDifficulty( & Difficulty & ) ) ;
92104: LD_STRING displayDifficulty(
92106: PUSH
92107: LD_OWVAR 67
92111: STR
92112: PUSH
92113: LD_STRING )
92115: STR
92116: PPUSH
92117: CALL_OW 559
// end ;
92121: LD_VAR 0 1
92125: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
92126: LD_INT 0
92128: PPUSH
// if p2 = stream_mode then
92129: LD_VAR 0 2
92133: PUSH
92134: LD_INT 100
92136: EQUAL
92137: IFFALSE 93140
// begin if not StreamModeActive then
92139: LD_EXP 96
92143: NOT
92144: IFFALSE 92154
// StreamModeActive := true ;
92146: LD_ADDR_EXP 96
92150: PUSH
92151: LD_INT 1
92153: ST_TO_ADDR
// if p3 = 0 then
92154: LD_VAR 0 3
92158: PUSH
92159: LD_INT 0
92161: EQUAL
92162: IFFALSE 92168
// InitStreamMode ;
92164: CALL 93344 0 0
// if p3 = 1 then
92168: LD_VAR 0 3
92172: PUSH
92173: LD_INT 1
92175: EQUAL
92176: IFFALSE 92186
// sRocket := true ;
92178: LD_ADDR_EXP 101
92182: PUSH
92183: LD_INT 1
92185: ST_TO_ADDR
// if p3 = 2 then
92186: LD_VAR 0 3
92190: PUSH
92191: LD_INT 2
92193: EQUAL
92194: IFFALSE 92204
// sSpeed := true ;
92196: LD_ADDR_EXP 100
92200: PUSH
92201: LD_INT 1
92203: ST_TO_ADDR
// if p3 = 3 then
92204: LD_VAR 0 3
92208: PUSH
92209: LD_INT 3
92211: EQUAL
92212: IFFALSE 92222
// sEngine := true ;
92214: LD_ADDR_EXP 102
92218: PUSH
92219: LD_INT 1
92221: ST_TO_ADDR
// if p3 = 4 then
92222: LD_VAR 0 3
92226: PUSH
92227: LD_INT 4
92229: EQUAL
92230: IFFALSE 92240
// sSpec := true ;
92232: LD_ADDR_EXP 99
92236: PUSH
92237: LD_INT 1
92239: ST_TO_ADDR
// if p3 = 5 then
92240: LD_VAR 0 3
92244: PUSH
92245: LD_INT 5
92247: EQUAL
92248: IFFALSE 92258
// sLevel := true ;
92250: LD_ADDR_EXP 103
92254: PUSH
92255: LD_INT 1
92257: ST_TO_ADDR
// if p3 = 6 then
92258: LD_VAR 0 3
92262: PUSH
92263: LD_INT 6
92265: EQUAL
92266: IFFALSE 92276
// sArmoury := true ;
92268: LD_ADDR_EXP 104
92272: PUSH
92273: LD_INT 1
92275: ST_TO_ADDR
// if p3 = 7 then
92276: LD_VAR 0 3
92280: PUSH
92281: LD_INT 7
92283: EQUAL
92284: IFFALSE 92294
// sRadar := true ;
92286: LD_ADDR_EXP 105
92290: PUSH
92291: LD_INT 1
92293: ST_TO_ADDR
// if p3 = 8 then
92294: LD_VAR 0 3
92298: PUSH
92299: LD_INT 8
92301: EQUAL
92302: IFFALSE 92312
// sBunker := true ;
92304: LD_ADDR_EXP 106
92308: PUSH
92309: LD_INT 1
92311: ST_TO_ADDR
// if p3 = 9 then
92312: LD_VAR 0 3
92316: PUSH
92317: LD_INT 9
92319: EQUAL
92320: IFFALSE 92330
// sHack := true ;
92322: LD_ADDR_EXP 107
92326: PUSH
92327: LD_INT 1
92329: ST_TO_ADDR
// if p3 = 10 then
92330: LD_VAR 0 3
92334: PUSH
92335: LD_INT 10
92337: EQUAL
92338: IFFALSE 92348
// sFire := true ;
92340: LD_ADDR_EXP 108
92344: PUSH
92345: LD_INT 1
92347: ST_TO_ADDR
// if p3 = 11 then
92348: LD_VAR 0 3
92352: PUSH
92353: LD_INT 11
92355: EQUAL
92356: IFFALSE 92366
// sRefresh := true ;
92358: LD_ADDR_EXP 109
92362: PUSH
92363: LD_INT 1
92365: ST_TO_ADDR
// if p3 = 12 then
92366: LD_VAR 0 3
92370: PUSH
92371: LD_INT 12
92373: EQUAL
92374: IFFALSE 92384
// sExp := true ;
92376: LD_ADDR_EXP 110
92380: PUSH
92381: LD_INT 1
92383: ST_TO_ADDR
// if p3 = 13 then
92384: LD_VAR 0 3
92388: PUSH
92389: LD_INT 13
92391: EQUAL
92392: IFFALSE 92402
// sDepot := true ;
92394: LD_ADDR_EXP 111
92398: PUSH
92399: LD_INT 1
92401: ST_TO_ADDR
// if p3 = 14 then
92402: LD_VAR 0 3
92406: PUSH
92407: LD_INT 14
92409: EQUAL
92410: IFFALSE 92420
// sFlag := true ;
92412: LD_ADDR_EXP 112
92416: PUSH
92417: LD_INT 1
92419: ST_TO_ADDR
// if p3 = 15 then
92420: LD_VAR 0 3
92424: PUSH
92425: LD_INT 15
92427: EQUAL
92428: IFFALSE 92438
// sKamikadze := true ;
92430: LD_ADDR_EXP 120
92434: PUSH
92435: LD_INT 1
92437: ST_TO_ADDR
// if p3 = 16 then
92438: LD_VAR 0 3
92442: PUSH
92443: LD_INT 16
92445: EQUAL
92446: IFFALSE 92456
// sTroll := true ;
92448: LD_ADDR_EXP 121
92452: PUSH
92453: LD_INT 1
92455: ST_TO_ADDR
// if p3 = 17 then
92456: LD_VAR 0 3
92460: PUSH
92461: LD_INT 17
92463: EQUAL
92464: IFFALSE 92474
// sSlow := true ;
92466: LD_ADDR_EXP 122
92470: PUSH
92471: LD_INT 1
92473: ST_TO_ADDR
// if p3 = 18 then
92474: LD_VAR 0 3
92478: PUSH
92479: LD_INT 18
92481: EQUAL
92482: IFFALSE 92492
// sLack := true ;
92484: LD_ADDR_EXP 123
92488: PUSH
92489: LD_INT 1
92491: ST_TO_ADDR
// if p3 = 19 then
92492: LD_VAR 0 3
92496: PUSH
92497: LD_INT 19
92499: EQUAL
92500: IFFALSE 92510
// sTank := true ;
92502: LD_ADDR_EXP 125
92506: PUSH
92507: LD_INT 1
92509: ST_TO_ADDR
// if p3 = 20 then
92510: LD_VAR 0 3
92514: PUSH
92515: LD_INT 20
92517: EQUAL
92518: IFFALSE 92528
// sRemote := true ;
92520: LD_ADDR_EXP 126
92524: PUSH
92525: LD_INT 1
92527: ST_TO_ADDR
// if p3 = 21 then
92528: LD_VAR 0 3
92532: PUSH
92533: LD_INT 21
92535: EQUAL
92536: IFFALSE 92546
// sPowell := true ;
92538: LD_ADDR_EXP 127
92542: PUSH
92543: LD_INT 1
92545: ST_TO_ADDR
// if p3 = 22 then
92546: LD_VAR 0 3
92550: PUSH
92551: LD_INT 22
92553: EQUAL
92554: IFFALSE 92564
// sTeleport := true ;
92556: LD_ADDR_EXP 130
92560: PUSH
92561: LD_INT 1
92563: ST_TO_ADDR
// if p3 = 23 then
92564: LD_VAR 0 3
92568: PUSH
92569: LD_INT 23
92571: EQUAL
92572: IFFALSE 92582
// sOilTower := true ;
92574: LD_ADDR_EXP 132
92578: PUSH
92579: LD_INT 1
92581: ST_TO_ADDR
// if p3 = 24 then
92582: LD_VAR 0 3
92586: PUSH
92587: LD_INT 24
92589: EQUAL
92590: IFFALSE 92600
// sShovel := true ;
92592: LD_ADDR_EXP 133
92596: PUSH
92597: LD_INT 1
92599: ST_TO_ADDR
// if p3 = 25 then
92600: LD_VAR 0 3
92604: PUSH
92605: LD_INT 25
92607: EQUAL
92608: IFFALSE 92618
// sSheik := true ;
92610: LD_ADDR_EXP 134
92614: PUSH
92615: LD_INT 1
92617: ST_TO_ADDR
// if p3 = 26 then
92618: LD_VAR 0 3
92622: PUSH
92623: LD_INT 26
92625: EQUAL
92626: IFFALSE 92636
// sEarthquake := true ;
92628: LD_ADDR_EXP 136
92632: PUSH
92633: LD_INT 1
92635: ST_TO_ADDR
// if p3 = 27 then
92636: LD_VAR 0 3
92640: PUSH
92641: LD_INT 27
92643: EQUAL
92644: IFFALSE 92654
// sAI := true ;
92646: LD_ADDR_EXP 137
92650: PUSH
92651: LD_INT 1
92653: ST_TO_ADDR
// if p3 = 28 then
92654: LD_VAR 0 3
92658: PUSH
92659: LD_INT 28
92661: EQUAL
92662: IFFALSE 92672
// sCargo := true ;
92664: LD_ADDR_EXP 140
92668: PUSH
92669: LD_INT 1
92671: ST_TO_ADDR
// if p3 = 29 then
92672: LD_VAR 0 3
92676: PUSH
92677: LD_INT 29
92679: EQUAL
92680: IFFALSE 92690
// sDLaser := true ;
92682: LD_ADDR_EXP 141
92686: PUSH
92687: LD_INT 1
92689: ST_TO_ADDR
// if p3 = 30 then
92690: LD_VAR 0 3
92694: PUSH
92695: LD_INT 30
92697: EQUAL
92698: IFFALSE 92708
// sExchange := true ;
92700: LD_ADDR_EXP 142
92704: PUSH
92705: LD_INT 1
92707: ST_TO_ADDR
// if p3 = 31 then
92708: LD_VAR 0 3
92712: PUSH
92713: LD_INT 31
92715: EQUAL
92716: IFFALSE 92726
// sFac := true ;
92718: LD_ADDR_EXP 143
92722: PUSH
92723: LD_INT 1
92725: ST_TO_ADDR
// if p3 = 32 then
92726: LD_VAR 0 3
92730: PUSH
92731: LD_INT 32
92733: EQUAL
92734: IFFALSE 92744
// sPower := true ;
92736: LD_ADDR_EXP 144
92740: PUSH
92741: LD_INT 1
92743: ST_TO_ADDR
// if p3 = 33 then
92744: LD_VAR 0 3
92748: PUSH
92749: LD_INT 33
92751: EQUAL
92752: IFFALSE 92762
// sRandom := true ;
92754: LD_ADDR_EXP 145
92758: PUSH
92759: LD_INT 1
92761: ST_TO_ADDR
// if p3 = 34 then
92762: LD_VAR 0 3
92766: PUSH
92767: LD_INT 34
92769: EQUAL
92770: IFFALSE 92780
// sShield := true ;
92772: LD_ADDR_EXP 146
92776: PUSH
92777: LD_INT 1
92779: ST_TO_ADDR
// if p3 = 35 then
92780: LD_VAR 0 3
92784: PUSH
92785: LD_INT 35
92787: EQUAL
92788: IFFALSE 92798
// sTime := true ;
92790: LD_ADDR_EXP 147
92794: PUSH
92795: LD_INT 1
92797: ST_TO_ADDR
// if p3 = 36 then
92798: LD_VAR 0 3
92802: PUSH
92803: LD_INT 36
92805: EQUAL
92806: IFFALSE 92816
// sTools := true ;
92808: LD_ADDR_EXP 148
92812: PUSH
92813: LD_INT 1
92815: ST_TO_ADDR
// if p3 = 101 then
92816: LD_VAR 0 3
92820: PUSH
92821: LD_INT 101
92823: EQUAL
92824: IFFALSE 92834
// sSold := true ;
92826: LD_ADDR_EXP 113
92830: PUSH
92831: LD_INT 1
92833: ST_TO_ADDR
// if p3 = 102 then
92834: LD_VAR 0 3
92838: PUSH
92839: LD_INT 102
92841: EQUAL
92842: IFFALSE 92852
// sDiff := true ;
92844: LD_ADDR_EXP 114
92848: PUSH
92849: LD_INT 1
92851: ST_TO_ADDR
// if p3 = 103 then
92852: LD_VAR 0 3
92856: PUSH
92857: LD_INT 103
92859: EQUAL
92860: IFFALSE 92870
// sFog := true ;
92862: LD_ADDR_EXP 117
92866: PUSH
92867: LD_INT 1
92869: ST_TO_ADDR
// if p3 = 104 then
92870: LD_VAR 0 3
92874: PUSH
92875: LD_INT 104
92877: EQUAL
92878: IFFALSE 92888
// sReset := true ;
92880: LD_ADDR_EXP 118
92884: PUSH
92885: LD_INT 1
92887: ST_TO_ADDR
// if p3 = 105 then
92888: LD_VAR 0 3
92892: PUSH
92893: LD_INT 105
92895: EQUAL
92896: IFFALSE 92906
// sSun := true ;
92898: LD_ADDR_EXP 119
92902: PUSH
92903: LD_INT 1
92905: ST_TO_ADDR
// if p3 = 106 then
92906: LD_VAR 0 3
92910: PUSH
92911: LD_INT 106
92913: EQUAL
92914: IFFALSE 92924
// sTiger := true ;
92916: LD_ADDR_EXP 115
92920: PUSH
92921: LD_INT 1
92923: ST_TO_ADDR
// if p3 = 107 then
92924: LD_VAR 0 3
92928: PUSH
92929: LD_INT 107
92931: EQUAL
92932: IFFALSE 92942
// sBomb := true ;
92934: LD_ADDR_EXP 116
92938: PUSH
92939: LD_INT 1
92941: ST_TO_ADDR
// if p3 = 108 then
92942: LD_VAR 0 3
92946: PUSH
92947: LD_INT 108
92949: EQUAL
92950: IFFALSE 92960
// sWound := true ;
92952: LD_ADDR_EXP 124
92956: PUSH
92957: LD_INT 1
92959: ST_TO_ADDR
// if p3 = 109 then
92960: LD_VAR 0 3
92964: PUSH
92965: LD_INT 109
92967: EQUAL
92968: IFFALSE 92978
// sBetray := true ;
92970: LD_ADDR_EXP 128
92974: PUSH
92975: LD_INT 1
92977: ST_TO_ADDR
// if p3 = 110 then
92978: LD_VAR 0 3
92982: PUSH
92983: LD_INT 110
92985: EQUAL
92986: IFFALSE 92996
// sContamin := true ;
92988: LD_ADDR_EXP 129
92992: PUSH
92993: LD_INT 1
92995: ST_TO_ADDR
// if p3 = 111 then
92996: LD_VAR 0 3
93000: PUSH
93001: LD_INT 111
93003: EQUAL
93004: IFFALSE 93014
// sOil := true ;
93006: LD_ADDR_EXP 131
93010: PUSH
93011: LD_INT 1
93013: ST_TO_ADDR
// if p3 = 112 then
93014: LD_VAR 0 3
93018: PUSH
93019: LD_INT 112
93021: EQUAL
93022: IFFALSE 93032
// sStu := true ;
93024: LD_ADDR_EXP 135
93028: PUSH
93029: LD_INT 1
93031: ST_TO_ADDR
// if p3 = 113 then
93032: LD_VAR 0 3
93036: PUSH
93037: LD_INT 113
93039: EQUAL
93040: IFFALSE 93050
// sBazooka := true ;
93042: LD_ADDR_EXP 138
93046: PUSH
93047: LD_INT 1
93049: ST_TO_ADDR
// if p3 = 114 then
93050: LD_VAR 0 3
93054: PUSH
93055: LD_INT 114
93057: EQUAL
93058: IFFALSE 93068
// sMortar := true ;
93060: LD_ADDR_EXP 139
93064: PUSH
93065: LD_INT 1
93067: ST_TO_ADDR
// if p3 = 115 then
93068: LD_VAR 0 3
93072: PUSH
93073: LD_INT 115
93075: EQUAL
93076: IFFALSE 93086
// sRanger := true ;
93078: LD_ADDR_EXP 149
93082: PUSH
93083: LD_INT 1
93085: ST_TO_ADDR
// if p3 = 116 then
93086: LD_VAR 0 3
93090: PUSH
93091: LD_INT 116
93093: EQUAL
93094: IFFALSE 93104
// sComputer := true ;
93096: LD_ADDR_EXP 150
93100: PUSH
93101: LD_INT 1
93103: ST_TO_ADDR
// if p3 = 117 then
93104: LD_VAR 0 3
93108: PUSH
93109: LD_INT 117
93111: EQUAL
93112: IFFALSE 93122
// s30 := true ;
93114: LD_ADDR_EXP 151
93118: PUSH
93119: LD_INT 1
93121: ST_TO_ADDR
// if p3 = 118 then
93122: LD_VAR 0 3
93126: PUSH
93127: LD_INT 118
93129: EQUAL
93130: IFFALSE 93140
// s60 := true ;
93132: LD_ADDR_EXP 152
93136: PUSH
93137: LD_INT 1
93139: ST_TO_ADDR
// end ; if p2 = hack_mode then
93140: LD_VAR 0 2
93144: PUSH
93145: LD_INT 101
93147: EQUAL
93148: IFFALSE 93276
// begin case p3 of 1 :
93150: LD_VAR 0 3
93154: PUSH
93155: LD_INT 1
93157: DOUBLE
93158: EQUAL
93159: IFTRUE 93163
93161: GO 93170
93163: POP
// hHackUnlimitedResources ; 2 :
93164: CALL 105423 0 0
93168: GO 93276
93170: LD_INT 2
93172: DOUBLE
93173: EQUAL
93174: IFTRUE 93178
93176: GO 93185
93178: POP
// hHackSetLevel10 ; 3 :
93179: CALL 105556 0 0
93183: GO 93276
93185: LD_INT 3
93187: DOUBLE
93188: EQUAL
93189: IFTRUE 93193
93191: GO 93200
93193: POP
// hHackSetLevel10YourUnits ; 4 :
93194: CALL 105641 0 0
93198: GO 93276
93200: LD_INT 4
93202: DOUBLE
93203: EQUAL
93204: IFTRUE 93208
93206: GO 93215
93208: POP
// hHackInvincible ; 5 :
93209: CALL 106089 0 0
93213: GO 93276
93215: LD_INT 5
93217: DOUBLE
93218: EQUAL
93219: IFTRUE 93223
93221: GO 93230
93223: POP
// hHackInvisible ; 6 :
93224: CALL 106200 0 0
93228: GO 93276
93230: LD_INT 6
93232: DOUBLE
93233: EQUAL
93234: IFTRUE 93238
93236: GO 93245
93238: POP
// hHackChangeYourSide ; 7 :
93239: CALL 106257 0 0
93243: GO 93276
93245: LD_INT 7
93247: DOUBLE
93248: EQUAL
93249: IFTRUE 93253
93251: GO 93260
93253: POP
// hHackChangeUnitSide ; 8 :
93254: CALL 106299 0 0
93258: GO 93276
93260: LD_INT 8
93262: DOUBLE
93263: EQUAL
93264: IFTRUE 93268
93266: GO 93275
93268: POP
// hHackFog ; end ;
93269: CALL 106400 0 0
93273: GO 93276
93275: POP
// end ; if p2 = game_save_mode then
93276: LD_VAR 0 2
93280: PUSH
93281: LD_INT 102
93283: EQUAL
93284: IFFALSE 93339
// begin if p3 = 1 then
93286: LD_VAR 0 3
93290: PUSH
93291: LD_INT 1
93293: EQUAL
93294: IFFALSE 93306
// globalGameSaveCounter := p4 ;
93296: LD_ADDR_EXP 95
93300: PUSH
93301: LD_VAR 0 4
93305: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
93306: LD_VAR 0 3
93310: PUSH
93311: LD_INT 2
93313: EQUAL
93314: PUSH
93315: LD_EXP 95
93319: AND
93320: IFFALSE 93339
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
93322: LD_STRING setGameSaveCounter(
93324: PUSH
93325: LD_EXP 95
93329: STR
93330: PUSH
93331: LD_STRING )
93333: STR
93334: PPUSH
93335: CALL_OW 559
// end ; end ;
93339: LD_VAR 0 7
93343: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
93344: LD_INT 0
93346: PPUSH
// streamModeActive := false ;
93347: LD_ADDR_EXP 96
93351: PUSH
93352: LD_INT 0
93354: ST_TO_ADDR
// normalCounter := 36 ;
93355: LD_ADDR_EXP 97
93359: PUSH
93360: LD_INT 36
93362: ST_TO_ADDR
// hardcoreCounter := 18 ;
93363: LD_ADDR_EXP 98
93367: PUSH
93368: LD_INT 18
93370: ST_TO_ADDR
// sRocket := false ;
93371: LD_ADDR_EXP 101
93375: PUSH
93376: LD_INT 0
93378: ST_TO_ADDR
// sSpeed := false ;
93379: LD_ADDR_EXP 100
93383: PUSH
93384: LD_INT 0
93386: ST_TO_ADDR
// sEngine := false ;
93387: LD_ADDR_EXP 102
93391: PUSH
93392: LD_INT 0
93394: ST_TO_ADDR
// sSpec := false ;
93395: LD_ADDR_EXP 99
93399: PUSH
93400: LD_INT 0
93402: ST_TO_ADDR
// sLevel := false ;
93403: LD_ADDR_EXP 103
93407: PUSH
93408: LD_INT 0
93410: ST_TO_ADDR
// sArmoury := false ;
93411: LD_ADDR_EXP 104
93415: PUSH
93416: LD_INT 0
93418: ST_TO_ADDR
// sRadar := false ;
93419: LD_ADDR_EXP 105
93423: PUSH
93424: LD_INT 0
93426: ST_TO_ADDR
// sBunker := false ;
93427: LD_ADDR_EXP 106
93431: PUSH
93432: LD_INT 0
93434: ST_TO_ADDR
// sHack := false ;
93435: LD_ADDR_EXP 107
93439: PUSH
93440: LD_INT 0
93442: ST_TO_ADDR
// sFire := false ;
93443: LD_ADDR_EXP 108
93447: PUSH
93448: LD_INT 0
93450: ST_TO_ADDR
// sRefresh := false ;
93451: LD_ADDR_EXP 109
93455: PUSH
93456: LD_INT 0
93458: ST_TO_ADDR
// sExp := false ;
93459: LD_ADDR_EXP 110
93463: PUSH
93464: LD_INT 0
93466: ST_TO_ADDR
// sDepot := false ;
93467: LD_ADDR_EXP 111
93471: PUSH
93472: LD_INT 0
93474: ST_TO_ADDR
// sFlag := false ;
93475: LD_ADDR_EXP 112
93479: PUSH
93480: LD_INT 0
93482: ST_TO_ADDR
// sKamikadze := false ;
93483: LD_ADDR_EXP 120
93487: PUSH
93488: LD_INT 0
93490: ST_TO_ADDR
// sTroll := false ;
93491: LD_ADDR_EXP 121
93495: PUSH
93496: LD_INT 0
93498: ST_TO_ADDR
// sSlow := false ;
93499: LD_ADDR_EXP 122
93503: PUSH
93504: LD_INT 0
93506: ST_TO_ADDR
// sLack := false ;
93507: LD_ADDR_EXP 123
93511: PUSH
93512: LD_INT 0
93514: ST_TO_ADDR
// sTank := false ;
93515: LD_ADDR_EXP 125
93519: PUSH
93520: LD_INT 0
93522: ST_TO_ADDR
// sRemote := false ;
93523: LD_ADDR_EXP 126
93527: PUSH
93528: LD_INT 0
93530: ST_TO_ADDR
// sPowell := false ;
93531: LD_ADDR_EXP 127
93535: PUSH
93536: LD_INT 0
93538: ST_TO_ADDR
// sTeleport := false ;
93539: LD_ADDR_EXP 130
93543: PUSH
93544: LD_INT 0
93546: ST_TO_ADDR
// sOilTower := false ;
93547: LD_ADDR_EXP 132
93551: PUSH
93552: LD_INT 0
93554: ST_TO_ADDR
// sShovel := false ;
93555: LD_ADDR_EXP 133
93559: PUSH
93560: LD_INT 0
93562: ST_TO_ADDR
// sSheik := false ;
93563: LD_ADDR_EXP 134
93567: PUSH
93568: LD_INT 0
93570: ST_TO_ADDR
// sEarthquake := false ;
93571: LD_ADDR_EXP 136
93575: PUSH
93576: LD_INT 0
93578: ST_TO_ADDR
// sAI := false ;
93579: LD_ADDR_EXP 137
93583: PUSH
93584: LD_INT 0
93586: ST_TO_ADDR
// sCargo := false ;
93587: LD_ADDR_EXP 140
93591: PUSH
93592: LD_INT 0
93594: ST_TO_ADDR
// sDLaser := false ;
93595: LD_ADDR_EXP 141
93599: PUSH
93600: LD_INT 0
93602: ST_TO_ADDR
// sExchange := false ;
93603: LD_ADDR_EXP 142
93607: PUSH
93608: LD_INT 0
93610: ST_TO_ADDR
// sFac := false ;
93611: LD_ADDR_EXP 143
93615: PUSH
93616: LD_INT 0
93618: ST_TO_ADDR
// sPower := false ;
93619: LD_ADDR_EXP 144
93623: PUSH
93624: LD_INT 0
93626: ST_TO_ADDR
// sRandom := false ;
93627: LD_ADDR_EXP 145
93631: PUSH
93632: LD_INT 0
93634: ST_TO_ADDR
// sShield := false ;
93635: LD_ADDR_EXP 146
93639: PUSH
93640: LD_INT 0
93642: ST_TO_ADDR
// sTime := false ;
93643: LD_ADDR_EXP 147
93647: PUSH
93648: LD_INT 0
93650: ST_TO_ADDR
// sTools := false ;
93651: LD_ADDR_EXP 148
93655: PUSH
93656: LD_INT 0
93658: ST_TO_ADDR
// sSold := false ;
93659: LD_ADDR_EXP 113
93663: PUSH
93664: LD_INT 0
93666: ST_TO_ADDR
// sDiff := false ;
93667: LD_ADDR_EXP 114
93671: PUSH
93672: LD_INT 0
93674: ST_TO_ADDR
// sFog := false ;
93675: LD_ADDR_EXP 117
93679: PUSH
93680: LD_INT 0
93682: ST_TO_ADDR
// sReset := false ;
93683: LD_ADDR_EXP 118
93687: PUSH
93688: LD_INT 0
93690: ST_TO_ADDR
// sSun := false ;
93691: LD_ADDR_EXP 119
93695: PUSH
93696: LD_INT 0
93698: ST_TO_ADDR
// sTiger := false ;
93699: LD_ADDR_EXP 115
93703: PUSH
93704: LD_INT 0
93706: ST_TO_ADDR
// sBomb := false ;
93707: LD_ADDR_EXP 116
93711: PUSH
93712: LD_INT 0
93714: ST_TO_ADDR
// sWound := false ;
93715: LD_ADDR_EXP 124
93719: PUSH
93720: LD_INT 0
93722: ST_TO_ADDR
// sBetray := false ;
93723: LD_ADDR_EXP 128
93727: PUSH
93728: LD_INT 0
93730: ST_TO_ADDR
// sContamin := false ;
93731: LD_ADDR_EXP 129
93735: PUSH
93736: LD_INT 0
93738: ST_TO_ADDR
// sOil := false ;
93739: LD_ADDR_EXP 131
93743: PUSH
93744: LD_INT 0
93746: ST_TO_ADDR
// sStu := false ;
93747: LD_ADDR_EXP 135
93751: PUSH
93752: LD_INT 0
93754: ST_TO_ADDR
// sBazooka := false ;
93755: LD_ADDR_EXP 138
93759: PUSH
93760: LD_INT 0
93762: ST_TO_ADDR
// sMortar := false ;
93763: LD_ADDR_EXP 139
93767: PUSH
93768: LD_INT 0
93770: ST_TO_ADDR
// sRanger := false ;
93771: LD_ADDR_EXP 149
93775: PUSH
93776: LD_INT 0
93778: ST_TO_ADDR
// sComputer := false ;
93779: LD_ADDR_EXP 150
93783: PUSH
93784: LD_INT 0
93786: ST_TO_ADDR
// s30 := false ;
93787: LD_ADDR_EXP 151
93791: PUSH
93792: LD_INT 0
93794: ST_TO_ADDR
// s60 := false ;
93795: LD_ADDR_EXP 152
93799: PUSH
93800: LD_INT 0
93802: ST_TO_ADDR
// end ;
93803: LD_VAR 0 1
93807: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
93808: LD_INT 0
93810: PPUSH
93811: PPUSH
93812: PPUSH
93813: PPUSH
93814: PPUSH
93815: PPUSH
93816: PPUSH
// result := [ ] ;
93817: LD_ADDR_VAR 0 2
93821: PUSH
93822: EMPTY
93823: ST_TO_ADDR
// if campaign_id = 1 then
93824: LD_OWVAR 69
93828: PUSH
93829: LD_INT 1
93831: EQUAL
93832: IFFALSE 96998
// begin case mission_number of 1 :
93834: LD_OWVAR 70
93838: PUSH
93839: LD_INT 1
93841: DOUBLE
93842: EQUAL
93843: IFTRUE 93847
93845: GO 93923
93847: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
93848: LD_ADDR_VAR 0 2
93852: PUSH
93853: LD_INT 2
93855: PUSH
93856: LD_INT 4
93858: PUSH
93859: LD_INT 11
93861: PUSH
93862: LD_INT 12
93864: PUSH
93865: LD_INT 15
93867: PUSH
93868: LD_INT 16
93870: PUSH
93871: LD_INT 22
93873: PUSH
93874: LD_INT 23
93876: PUSH
93877: LD_INT 26
93879: PUSH
93880: EMPTY
93881: LIST
93882: LIST
93883: LIST
93884: LIST
93885: LIST
93886: LIST
93887: LIST
93888: LIST
93889: LIST
93890: PUSH
93891: LD_INT 101
93893: PUSH
93894: LD_INT 102
93896: PUSH
93897: LD_INT 106
93899: PUSH
93900: LD_INT 116
93902: PUSH
93903: LD_INT 117
93905: PUSH
93906: LD_INT 118
93908: PUSH
93909: EMPTY
93910: LIST
93911: LIST
93912: LIST
93913: LIST
93914: LIST
93915: LIST
93916: PUSH
93917: EMPTY
93918: LIST
93919: LIST
93920: ST_TO_ADDR
93921: GO 96996
93923: LD_INT 2
93925: DOUBLE
93926: EQUAL
93927: IFTRUE 93931
93929: GO 94015
93931: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
93932: LD_ADDR_VAR 0 2
93936: PUSH
93937: LD_INT 2
93939: PUSH
93940: LD_INT 4
93942: PUSH
93943: LD_INT 11
93945: PUSH
93946: LD_INT 12
93948: PUSH
93949: LD_INT 15
93951: PUSH
93952: LD_INT 16
93954: PUSH
93955: LD_INT 22
93957: PUSH
93958: LD_INT 23
93960: PUSH
93961: LD_INT 26
93963: PUSH
93964: EMPTY
93965: LIST
93966: LIST
93967: LIST
93968: LIST
93969: LIST
93970: LIST
93971: LIST
93972: LIST
93973: LIST
93974: PUSH
93975: LD_INT 101
93977: PUSH
93978: LD_INT 102
93980: PUSH
93981: LD_INT 105
93983: PUSH
93984: LD_INT 106
93986: PUSH
93987: LD_INT 108
93989: PUSH
93990: LD_INT 116
93992: PUSH
93993: LD_INT 117
93995: PUSH
93996: LD_INT 118
93998: PUSH
93999: EMPTY
94000: LIST
94001: LIST
94002: LIST
94003: LIST
94004: LIST
94005: LIST
94006: LIST
94007: LIST
94008: PUSH
94009: EMPTY
94010: LIST
94011: LIST
94012: ST_TO_ADDR
94013: GO 96996
94015: LD_INT 3
94017: DOUBLE
94018: EQUAL
94019: IFTRUE 94023
94021: GO 94111
94023: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
94024: LD_ADDR_VAR 0 2
94028: PUSH
94029: LD_INT 2
94031: PUSH
94032: LD_INT 4
94034: PUSH
94035: LD_INT 5
94037: PUSH
94038: LD_INT 11
94040: PUSH
94041: LD_INT 12
94043: PUSH
94044: LD_INT 15
94046: PUSH
94047: LD_INT 16
94049: PUSH
94050: LD_INT 22
94052: PUSH
94053: LD_INT 26
94055: PUSH
94056: LD_INT 36
94058: PUSH
94059: EMPTY
94060: LIST
94061: LIST
94062: LIST
94063: LIST
94064: LIST
94065: LIST
94066: LIST
94067: LIST
94068: LIST
94069: LIST
94070: PUSH
94071: LD_INT 101
94073: PUSH
94074: LD_INT 102
94076: PUSH
94077: LD_INT 105
94079: PUSH
94080: LD_INT 106
94082: PUSH
94083: LD_INT 108
94085: PUSH
94086: LD_INT 116
94088: PUSH
94089: LD_INT 117
94091: PUSH
94092: LD_INT 118
94094: PUSH
94095: EMPTY
94096: LIST
94097: LIST
94098: LIST
94099: LIST
94100: LIST
94101: LIST
94102: LIST
94103: LIST
94104: PUSH
94105: EMPTY
94106: LIST
94107: LIST
94108: ST_TO_ADDR
94109: GO 96996
94111: LD_INT 4
94113: DOUBLE
94114: EQUAL
94115: IFTRUE 94119
94117: GO 94215
94119: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
94120: LD_ADDR_VAR 0 2
94124: PUSH
94125: LD_INT 2
94127: PUSH
94128: LD_INT 4
94130: PUSH
94131: LD_INT 5
94133: PUSH
94134: LD_INT 8
94136: PUSH
94137: LD_INT 11
94139: PUSH
94140: LD_INT 12
94142: PUSH
94143: LD_INT 15
94145: PUSH
94146: LD_INT 16
94148: PUSH
94149: LD_INT 22
94151: PUSH
94152: LD_INT 23
94154: PUSH
94155: LD_INT 26
94157: PUSH
94158: LD_INT 36
94160: PUSH
94161: EMPTY
94162: LIST
94163: LIST
94164: LIST
94165: LIST
94166: LIST
94167: LIST
94168: LIST
94169: LIST
94170: LIST
94171: LIST
94172: LIST
94173: LIST
94174: PUSH
94175: LD_INT 101
94177: PUSH
94178: LD_INT 102
94180: PUSH
94181: LD_INT 105
94183: PUSH
94184: LD_INT 106
94186: PUSH
94187: LD_INT 108
94189: PUSH
94190: LD_INT 116
94192: PUSH
94193: LD_INT 117
94195: PUSH
94196: LD_INT 118
94198: PUSH
94199: EMPTY
94200: LIST
94201: LIST
94202: LIST
94203: LIST
94204: LIST
94205: LIST
94206: LIST
94207: LIST
94208: PUSH
94209: EMPTY
94210: LIST
94211: LIST
94212: ST_TO_ADDR
94213: GO 96996
94215: LD_INT 5
94217: DOUBLE
94218: EQUAL
94219: IFTRUE 94223
94221: GO 94335
94223: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
94224: LD_ADDR_VAR 0 2
94228: PUSH
94229: LD_INT 2
94231: PUSH
94232: LD_INT 4
94234: PUSH
94235: LD_INT 5
94237: PUSH
94238: LD_INT 6
94240: PUSH
94241: LD_INT 8
94243: PUSH
94244: LD_INT 11
94246: PUSH
94247: LD_INT 12
94249: PUSH
94250: LD_INT 15
94252: PUSH
94253: LD_INT 16
94255: PUSH
94256: LD_INT 22
94258: PUSH
94259: LD_INT 23
94261: PUSH
94262: LD_INT 25
94264: PUSH
94265: LD_INT 26
94267: PUSH
94268: LD_INT 36
94270: PUSH
94271: EMPTY
94272: LIST
94273: LIST
94274: LIST
94275: LIST
94276: LIST
94277: LIST
94278: LIST
94279: LIST
94280: LIST
94281: LIST
94282: LIST
94283: LIST
94284: LIST
94285: LIST
94286: PUSH
94287: LD_INT 101
94289: PUSH
94290: LD_INT 102
94292: PUSH
94293: LD_INT 105
94295: PUSH
94296: LD_INT 106
94298: PUSH
94299: LD_INT 108
94301: PUSH
94302: LD_INT 109
94304: PUSH
94305: LD_INT 112
94307: PUSH
94308: LD_INT 116
94310: PUSH
94311: LD_INT 117
94313: PUSH
94314: LD_INT 118
94316: PUSH
94317: EMPTY
94318: LIST
94319: LIST
94320: LIST
94321: LIST
94322: LIST
94323: LIST
94324: LIST
94325: LIST
94326: LIST
94327: LIST
94328: PUSH
94329: EMPTY
94330: LIST
94331: LIST
94332: ST_TO_ADDR
94333: GO 96996
94335: LD_INT 6
94337: DOUBLE
94338: EQUAL
94339: IFTRUE 94343
94341: GO 94475
94343: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
94344: LD_ADDR_VAR 0 2
94348: PUSH
94349: LD_INT 2
94351: PUSH
94352: LD_INT 4
94354: PUSH
94355: LD_INT 5
94357: PUSH
94358: LD_INT 6
94360: PUSH
94361: LD_INT 8
94363: PUSH
94364: LD_INT 11
94366: PUSH
94367: LD_INT 12
94369: PUSH
94370: LD_INT 15
94372: PUSH
94373: LD_INT 16
94375: PUSH
94376: LD_INT 20
94378: PUSH
94379: LD_INT 21
94381: PUSH
94382: LD_INT 22
94384: PUSH
94385: LD_INT 23
94387: PUSH
94388: LD_INT 25
94390: PUSH
94391: LD_INT 26
94393: PUSH
94394: LD_INT 30
94396: PUSH
94397: LD_INT 31
94399: PUSH
94400: LD_INT 32
94402: PUSH
94403: LD_INT 36
94405: PUSH
94406: EMPTY
94407: LIST
94408: LIST
94409: LIST
94410: LIST
94411: LIST
94412: LIST
94413: LIST
94414: LIST
94415: LIST
94416: LIST
94417: LIST
94418: LIST
94419: LIST
94420: LIST
94421: LIST
94422: LIST
94423: LIST
94424: LIST
94425: LIST
94426: PUSH
94427: LD_INT 101
94429: PUSH
94430: LD_INT 102
94432: PUSH
94433: LD_INT 105
94435: PUSH
94436: LD_INT 106
94438: PUSH
94439: LD_INT 108
94441: PUSH
94442: LD_INT 109
94444: PUSH
94445: LD_INT 112
94447: PUSH
94448: LD_INT 116
94450: PUSH
94451: LD_INT 117
94453: PUSH
94454: LD_INT 118
94456: PUSH
94457: EMPTY
94458: LIST
94459: LIST
94460: LIST
94461: LIST
94462: LIST
94463: LIST
94464: LIST
94465: LIST
94466: LIST
94467: LIST
94468: PUSH
94469: EMPTY
94470: LIST
94471: LIST
94472: ST_TO_ADDR
94473: GO 96996
94475: LD_INT 7
94477: DOUBLE
94478: EQUAL
94479: IFTRUE 94483
94481: GO 94595
94483: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
94484: LD_ADDR_VAR 0 2
94488: PUSH
94489: LD_INT 2
94491: PUSH
94492: LD_INT 4
94494: PUSH
94495: LD_INT 5
94497: PUSH
94498: LD_INT 7
94500: PUSH
94501: LD_INT 11
94503: PUSH
94504: LD_INT 12
94506: PUSH
94507: LD_INT 15
94509: PUSH
94510: LD_INT 16
94512: PUSH
94513: LD_INT 20
94515: PUSH
94516: LD_INT 21
94518: PUSH
94519: LD_INT 22
94521: PUSH
94522: LD_INT 23
94524: PUSH
94525: LD_INT 25
94527: PUSH
94528: LD_INT 26
94530: PUSH
94531: EMPTY
94532: LIST
94533: LIST
94534: LIST
94535: LIST
94536: LIST
94537: LIST
94538: LIST
94539: LIST
94540: LIST
94541: LIST
94542: LIST
94543: LIST
94544: LIST
94545: LIST
94546: PUSH
94547: LD_INT 101
94549: PUSH
94550: LD_INT 102
94552: PUSH
94553: LD_INT 103
94555: PUSH
94556: LD_INT 105
94558: PUSH
94559: LD_INT 106
94561: PUSH
94562: LD_INT 108
94564: PUSH
94565: LD_INT 112
94567: PUSH
94568: LD_INT 116
94570: PUSH
94571: LD_INT 117
94573: PUSH
94574: LD_INT 118
94576: PUSH
94577: EMPTY
94578: LIST
94579: LIST
94580: LIST
94581: LIST
94582: LIST
94583: LIST
94584: LIST
94585: LIST
94586: LIST
94587: LIST
94588: PUSH
94589: EMPTY
94590: LIST
94591: LIST
94592: ST_TO_ADDR
94593: GO 96996
94595: LD_INT 8
94597: DOUBLE
94598: EQUAL
94599: IFTRUE 94603
94601: GO 94743
94603: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
94604: LD_ADDR_VAR 0 2
94608: PUSH
94609: LD_INT 2
94611: PUSH
94612: LD_INT 4
94614: PUSH
94615: LD_INT 5
94617: PUSH
94618: LD_INT 6
94620: PUSH
94621: LD_INT 7
94623: PUSH
94624: LD_INT 8
94626: PUSH
94627: LD_INT 11
94629: PUSH
94630: LD_INT 12
94632: PUSH
94633: LD_INT 15
94635: PUSH
94636: LD_INT 16
94638: PUSH
94639: LD_INT 20
94641: PUSH
94642: LD_INT 21
94644: PUSH
94645: LD_INT 22
94647: PUSH
94648: LD_INT 23
94650: PUSH
94651: LD_INT 25
94653: PUSH
94654: LD_INT 26
94656: PUSH
94657: LD_INT 30
94659: PUSH
94660: LD_INT 31
94662: PUSH
94663: LD_INT 32
94665: PUSH
94666: LD_INT 36
94668: PUSH
94669: EMPTY
94670: LIST
94671: LIST
94672: LIST
94673: LIST
94674: LIST
94675: LIST
94676: LIST
94677: LIST
94678: LIST
94679: LIST
94680: LIST
94681: LIST
94682: LIST
94683: LIST
94684: LIST
94685: LIST
94686: LIST
94687: LIST
94688: LIST
94689: LIST
94690: PUSH
94691: LD_INT 101
94693: PUSH
94694: LD_INT 102
94696: PUSH
94697: LD_INT 103
94699: PUSH
94700: LD_INT 105
94702: PUSH
94703: LD_INT 106
94705: PUSH
94706: LD_INT 108
94708: PUSH
94709: LD_INT 109
94711: PUSH
94712: LD_INT 112
94714: PUSH
94715: LD_INT 116
94717: PUSH
94718: LD_INT 117
94720: PUSH
94721: LD_INT 118
94723: PUSH
94724: EMPTY
94725: LIST
94726: LIST
94727: LIST
94728: LIST
94729: LIST
94730: LIST
94731: LIST
94732: LIST
94733: LIST
94734: LIST
94735: LIST
94736: PUSH
94737: EMPTY
94738: LIST
94739: LIST
94740: ST_TO_ADDR
94741: GO 96996
94743: LD_INT 9
94745: DOUBLE
94746: EQUAL
94747: IFTRUE 94751
94749: GO 94899
94751: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
94752: LD_ADDR_VAR 0 2
94756: PUSH
94757: LD_INT 2
94759: PUSH
94760: LD_INT 4
94762: PUSH
94763: LD_INT 5
94765: PUSH
94766: LD_INT 6
94768: PUSH
94769: LD_INT 7
94771: PUSH
94772: LD_INT 8
94774: PUSH
94775: LD_INT 11
94777: PUSH
94778: LD_INT 12
94780: PUSH
94781: LD_INT 15
94783: PUSH
94784: LD_INT 16
94786: PUSH
94787: LD_INT 20
94789: PUSH
94790: LD_INT 21
94792: PUSH
94793: LD_INT 22
94795: PUSH
94796: LD_INT 23
94798: PUSH
94799: LD_INT 25
94801: PUSH
94802: LD_INT 26
94804: PUSH
94805: LD_INT 28
94807: PUSH
94808: LD_INT 30
94810: PUSH
94811: LD_INT 31
94813: PUSH
94814: LD_INT 32
94816: PUSH
94817: LD_INT 36
94819: PUSH
94820: EMPTY
94821: LIST
94822: LIST
94823: LIST
94824: LIST
94825: LIST
94826: LIST
94827: LIST
94828: LIST
94829: LIST
94830: LIST
94831: LIST
94832: LIST
94833: LIST
94834: LIST
94835: LIST
94836: LIST
94837: LIST
94838: LIST
94839: LIST
94840: LIST
94841: LIST
94842: PUSH
94843: LD_INT 101
94845: PUSH
94846: LD_INT 102
94848: PUSH
94849: LD_INT 103
94851: PUSH
94852: LD_INT 105
94854: PUSH
94855: LD_INT 106
94857: PUSH
94858: LD_INT 108
94860: PUSH
94861: LD_INT 109
94863: PUSH
94864: LD_INT 112
94866: PUSH
94867: LD_INT 114
94869: PUSH
94870: LD_INT 116
94872: PUSH
94873: LD_INT 117
94875: PUSH
94876: LD_INT 118
94878: PUSH
94879: EMPTY
94880: LIST
94881: LIST
94882: LIST
94883: LIST
94884: LIST
94885: LIST
94886: LIST
94887: LIST
94888: LIST
94889: LIST
94890: LIST
94891: LIST
94892: PUSH
94893: EMPTY
94894: LIST
94895: LIST
94896: ST_TO_ADDR
94897: GO 96996
94899: LD_INT 10
94901: DOUBLE
94902: EQUAL
94903: IFTRUE 94907
94905: GO 95103
94907: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
94908: LD_ADDR_VAR 0 2
94912: PUSH
94913: LD_INT 2
94915: PUSH
94916: LD_INT 4
94918: PUSH
94919: LD_INT 5
94921: PUSH
94922: LD_INT 6
94924: PUSH
94925: LD_INT 7
94927: PUSH
94928: LD_INT 8
94930: PUSH
94931: LD_INT 9
94933: PUSH
94934: LD_INT 10
94936: PUSH
94937: LD_INT 11
94939: PUSH
94940: LD_INT 12
94942: PUSH
94943: LD_INT 13
94945: PUSH
94946: LD_INT 14
94948: PUSH
94949: LD_INT 15
94951: PUSH
94952: LD_INT 16
94954: PUSH
94955: LD_INT 17
94957: PUSH
94958: LD_INT 18
94960: PUSH
94961: LD_INT 19
94963: PUSH
94964: LD_INT 20
94966: PUSH
94967: LD_INT 21
94969: PUSH
94970: LD_INT 22
94972: PUSH
94973: LD_INT 23
94975: PUSH
94976: LD_INT 24
94978: PUSH
94979: LD_INT 25
94981: PUSH
94982: LD_INT 26
94984: PUSH
94985: LD_INT 28
94987: PUSH
94988: LD_INT 30
94990: PUSH
94991: LD_INT 31
94993: PUSH
94994: LD_INT 32
94996: PUSH
94997: LD_INT 36
94999: PUSH
95000: EMPTY
95001: LIST
95002: LIST
95003: LIST
95004: LIST
95005: LIST
95006: LIST
95007: LIST
95008: LIST
95009: LIST
95010: LIST
95011: LIST
95012: LIST
95013: LIST
95014: LIST
95015: LIST
95016: LIST
95017: LIST
95018: LIST
95019: LIST
95020: LIST
95021: LIST
95022: LIST
95023: LIST
95024: LIST
95025: LIST
95026: LIST
95027: LIST
95028: LIST
95029: LIST
95030: PUSH
95031: LD_INT 101
95033: PUSH
95034: LD_INT 102
95036: PUSH
95037: LD_INT 103
95039: PUSH
95040: LD_INT 104
95042: PUSH
95043: LD_INT 105
95045: PUSH
95046: LD_INT 106
95048: PUSH
95049: LD_INT 107
95051: PUSH
95052: LD_INT 108
95054: PUSH
95055: LD_INT 109
95057: PUSH
95058: LD_INT 110
95060: PUSH
95061: LD_INT 111
95063: PUSH
95064: LD_INT 112
95066: PUSH
95067: LD_INT 114
95069: PUSH
95070: LD_INT 116
95072: PUSH
95073: LD_INT 117
95075: PUSH
95076: LD_INT 118
95078: PUSH
95079: EMPTY
95080: LIST
95081: LIST
95082: LIST
95083: LIST
95084: LIST
95085: LIST
95086: LIST
95087: LIST
95088: LIST
95089: LIST
95090: LIST
95091: LIST
95092: LIST
95093: LIST
95094: LIST
95095: LIST
95096: PUSH
95097: EMPTY
95098: LIST
95099: LIST
95100: ST_TO_ADDR
95101: GO 96996
95103: LD_INT 11
95105: DOUBLE
95106: EQUAL
95107: IFTRUE 95111
95109: GO 95315
95111: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
95112: LD_ADDR_VAR 0 2
95116: PUSH
95117: LD_INT 2
95119: PUSH
95120: LD_INT 3
95122: PUSH
95123: LD_INT 4
95125: PUSH
95126: LD_INT 5
95128: PUSH
95129: LD_INT 6
95131: PUSH
95132: LD_INT 7
95134: PUSH
95135: LD_INT 8
95137: PUSH
95138: LD_INT 9
95140: PUSH
95141: LD_INT 10
95143: PUSH
95144: LD_INT 11
95146: PUSH
95147: LD_INT 12
95149: PUSH
95150: LD_INT 13
95152: PUSH
95153: LD_INT 14
95155: PUSH
95156: LD_INT 15
95158: PUSH
95159: LD_INT 16
95161: PUSH
95162: LD_INT 17
95164: PUSH
95165: LD_INT 18
95167: PUSH
95168: LD_INT 19
95170: PUSH
95171: LD_INT 20
95173: PUSH
95174: LD_INT 21
95176: PUSH
95177: LD_INT 22
95179: PUSH
95180: LD_INT 23
95182: PUSH
95183: LD_INT 24
95185: PUSH
95186: LD_INT 25
95188: PUSH
95189: LD_INT 26
95191: PUSH
95192: LD_INT 28
95194: PUSH
95195: LD_INT 30
95197: PUSH
95198: LD_INT 31
95200: PUSH
95201: LD_INT 32
95203: PUSH
95204: LD_INT 34
95206: PUSH
95207: LD_INT 36
95209: PUSH
95210: EMPTY
95211: LIST
95212: LIST
95213: LIST
95214: LIST
95215: LIST
95216: LIST
95217: LIST
95218: LIST
95219: LIST
95220: LIST
95221: LIST
95222: LIST
95223: LIST
95224: LIST
95225: LIST
95226: LIST
95227: LIST
95228: LIST
95229: LIST
95230: LIST
95231: LIST
95232: LIST
95233: LIST
95234: LIST
95235: LIST
95236: LIST
95237: LIST
95238: LIST
95239: LIST
95240: LIST
95241: LIST
95242: PUSH
95243: LD_INT 101
95245: PUSH
95246: LD_INT 102
95248: PUSH
95249: LD_INT 103
95251: PUSH
95252: LD_INT 104
95254: PUSH
95255: LD_INT 105
95257: PUSH
95258: LD_INT 106
95260: PUSH
95261: LD_INT 107
95263: PUSH
95264: LD_INT 108
95266: PUSH
95267: LD_INT 109
95269: PUSH
95270: LD_INT 110
95272: PUSH
95273: LD_INT 111
95275: PUSH
95276: LD_INT 112
95278: PUSH
95279: LD_INT 114
95281: PUSH
95282: LD_INT 116
95284: PUSH
95285: LD_INT 117
95287: PUSH
95288: LD_INT 118
95290: PUSH
95291: EMPTY
95292: LIST
95293: LIST
95294: LIST
95295: LIST
95296: LIST
95297: LIST
95298: LIST
95299: LIST
95300: LIST
95301: LIST
95302: LIST
95303: LIST
95304: LIST
95305: LIST
95306: LIST
95307: LIST
95308: PUSH
95309: EMPTY
95310: LIST
95311: LIST
95312: ST_TO_ADDR
95313: GO 96996
95315: LD_INT 12
95317: DOUBLE
95318: EQUAL
95319: IFTRUE 95323
95321: GO 95543
95323: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
95324: LD_ADDR_VAR 0 2
95328: PUSH
95329: LD_INT 1
95331: PUSH
95332: LD_INT 2
95334: PUSH
95335: LD_INT 3
95337: PUSH
95338: LD_INT 4
95340: PUSH
95341: LD_INT 5
95343: PUSH
95344: LD_INT 6
95346: PUSH
95347: LD_INT 7
95349: PUSH
95350: LD_INT 8
95352: PUSH
95353: LD_INT 9
95355: PUSH
95356: LD_INT 10
95358: PUSH
95359: LD_INT 11
95361: PUSH
95362: LD_INT 12
95364: PUSH
95365: LD_INT 13
95367: PUSH
95368: LD_INT 14
95370: PUSH
95371: LD_INT 15
95373: PUSH
95374: LD_INT 16
95376: PUSH
95377: LD_INT 17
95379: PUSH
95380: LD_INT 18
95382: PUSH
95383: LD_INT 19
95385: PUSH
95386: LD_INT 20
95388: PUSH
95389: LD_INT 21
95391: PUSH
95392: LD_INT 22
95394: PUSH
95395: LD_INT 23
95397: PUSH
95398: LD_INT 24
95400: PUSH
95401: LD_INT 25
95403: PUSH
95404: LD_INT 26
95406: PUSH
95407: LD_INT 27
95409: PUSH
95410: LD_INT 28
95412: PUSH
95413: LD_INT 30
95415: PUSH
95416: LD_INT 31
95418: PUSH
95419: LD_INT 32
95421: PUSH
95422: LD_INT 33
95424: PUSH
95425: LD_INT 34
95427: PUSH
95428: LD_INT 36
95430: PUSH
95431: EMPTY
95432: LIST
95433: LIST
95434: LIST
95435: LIST
95436: LIST
95437: LIST
95438: LIST
95439: LIST
95440: LIST
95441: LIST
95442: LIST
95443: LIST
95444: LIST
95445: LIST
95446: LIST
95447: LIST
95448: LIST
95449: LIST
95450: LIST
95451: LIST
95452: LIST
95453: LIST
95454: LIST
95455: LIST
95456: LIST
95457: LIST
95458: LIST
95459: LIST
95460: LIST
95461: LIST
95462: LIST
95463: LIST
95464: LIST
95465: LIST
95466: PUSH
95467: LD_INT 101
95469: PUSH
95470: LD_INT 102
95472: PUSH
95473: LD_INT 103
95475: PUSH
95476: LD_INT 104
95478: PUSH
95479: LD_INT 105
95481: PUSH
95482: LD_INT 106
95484: PUSH
95485: LD_INT 107
95487: PUSH
95488: LD_INT 108
95490: PUSH
95491: LD_INT 109
95493: PUSH
95494: LD_INT 110
95496: PUSH
95497: LD_INT 111
95499: PUSH
95500: LD_INT 112
95502: PUSH
95503: LD_INT 113
95505: PUSH
95506: LD_INT 114
95508: PUSH
95509: LD_INT 116
95511: PUSH
95512: LD_INT 117
95514: PUSH
95515: LD_INT 118
95517: PUSH
95518: EMPTY
95519: LIST
95520: LIST
95521: LIST
95522: LIST
95523: LIST
95524: LIST
95525: LIST
95526: LIST
95527: LIST
95528: LIST
95529: LIST
95530: LIST
95531: LIST
95532: LIST
95533: LIST
95534: LIST
95535: LIST
95536: PUSH
95537: EMPTY
95538: LIST
95539: LIST
95540: ST_TO_ADDR
95541: GO 96996
95543: LD_INT 13
95545: DOUBLE
95546: EQUAL
95547: IFTRUE 95551
95549: GO 95759
95551: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
95552: LD_ADDR_VAR 0 2
95556: PUSH
95557: LD_INT 1
95559: PUSH
95560: LD_INT 2
95562: PUSH
95563: LD_INT 3
95565: PUSH
95566: LD_INT 4
95568: PUSH
95569: LD_INT 5
95571: PUSH
95572: LD_INT 8
95574: PUSH
95575: LD_INT 9
95577: PUSH
95578: LD_INT 10
95580: PUSH
95581: LD_INT 11
95583: PUSH
95584: LD_INT 12
95586: PUSH
95587: LD_INT 14
95589: PUSH
95590: LD_INT 15
95592: PUSH
95593: LD_INT 16
95595: PUSH
95596: LD_INT 17
95598: PUSH
95599: LD_INT 18
95601: PUSH
95602: LD_INT 19
95604: PUSH
95605: LD_INT 20
95607: PUSH
95608: LD_INT 21
95610: PUSH
95611: LD_INT 22
95613: PUSH
95614: LD_INT 23
95616: PUSH
95617: LD_INT 24
95619: PUSH
95620: LD_INT 25
95622: PUSH
95623: LD_INT 26
95625: PUSH
95626: LD_INT 27
95628: PUSH
95629: LD_INT 28
95631: PUSH
95632: LD_INT 30
95634: PUSH
95635: LD_INT 31
95637: PUSH
95638: LD_INT 32
95640: PUSH
95641: LD_INT 33
95643: PUSH
95644: LD_INT 34
95646: PUSH
95647: LD_INT 36
95649: PUSH
95650: EMPTY
95651: LIST
95652: LIST
95653: LIST
95654: LIST
95655: LIST
95656: LIST
95657: LIST
95658: LIST
95659: LIST
95660: LIST
95661: LIST
95662: LIST
95663: LIST
95664: LIST
95665: LIST
95666: LIST
95667: LIST
95668: LIST
95669: LIST
95670: LIST
95671: LIST
95672: LIST
95673: LIST
95674: LIST
95675: LIST
95676: LIST
95677: LIST
95678: LIST
95679: LIST
95680: LIST
95681: LIST
95682: PUSH
95683: LD_INT 101
95685: PUSH
95686: LD_INT 102
95688: PUSH
95689: LD_INT 103
95691: PUSH
95692: LD_INT 104
95694: PUSH
95695: LD_INT 105
95697: PUSH
95698: LD_INT 106
95700: PUSH
95701: LD_INT 107
95703: PUSH
95704: LD_INT 108
95706: PUSH
95707: LD_INT 109
95709: PUSH
95710: LD_INT 110
95712: PUSH
95713: LD_INT 111
95715: PUSH
95716: LD_INT 112
95718: PUSH
95719: LD_INT 113
95721: PUSH
95722: LD_INT 114
95724: PUSH
95725: LD_INT 116
95727: PUSH
95728: LD_INT 117
95730: PUSH
95731: LD_INT 118
95733: PUSH
95734: EMPTY
95735: LIST
95736: LIST
95737: LIST
95738: LIST
95739: LIST
95740: LIST
95741: LIST
95742: LIST
95743: LIST
95744: LIST
95745: LIST
95746: LIST
95747: LIST
95748: LIST
95749: LIST
95750: LIST
95751: LIST
95752: PUSH
95753: EMPTY
95754: LIST
95755: LIST
95756: ST_TO_ADDR
95757: GO 96996
95759: LD_INT 14
95761: DOUBLE
95762: EQUAL
95763: IFTRUE 95767
95765: GO 95991
95767: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
95768: LD_ADDR_VAR 0 2
95772: PUSH
95773: LD_INT 1
95775: PUSH
95776: LD_INT 2
95778: PUSH
95779: LD_INT 3
95781: PUSH
95782: LD_INT 4
95784: PUSH
95785: LD_INT 5
95787: PUSH
95788: LD_INT 6
95790: PUSH
95791: LD_INT 7
95793: PUSH
95794: LD_INT 8
95796: PUSH
95797: LD_INT 9
95799: PUSH
95800: LD_INT 10
95802: PUSH
95803: LD_INT 11
95805: PUSH
95806: LD_INT 12
95808: PUSH
95809: LD_INT 13
95811: PUSH
95812: LD_INT 14
95814: PUSH
95815: LD_INT 15
95817: PUSH
95818: LD_INT 16
95820: PUSH
95821: LD_INT 17
95823: PUSH
95824: LD_INT 18
95826: PUSH
95827: LD_INT 19
95829: PUSH
95830: LD_INT 20
95832: PUSH
95833: LD_INT 21
95835: PUSH
95836: LD_INT 22
95838: PUSH
95839: LD_INT 23
95841: PUSH
95842: LD_INT 24
95844: PUSH
95845: LD_INT 25
95847: PUSH
95848: LD_INT 26
95850: PUSH
95851: LD_INT 27
95853: PUSH
95854: LD_INT 28
95856: PUSH
95857: LD_INT 29
95859: PUSH
95860: LD_INT 30
95862: PUSH
95863: LD_INT 31
95865: PUSH
95866: LD_INT 32
95868: PUSH
95869: LD_INT 33
95871: PUSH
95872: LD_INT 34
95874: PUSH
95875: LD_INT 36
95877: PUSH
95878: EMPTY
95879: LIST
95880: LIST
95881: LIST
95882: LIST
95883: LIST
95884: LIST
95885: LIST
95886: LIST
95887: LIST
95888: LIST
95889: LIST
95890: LIST
95891: LIST
95892: LIST
95893: LIST
95894: LIST
95895: LIST
95896: LIST
95897: LIST
95898: LIST
95899: LIST
95900: LIST
95901: LIST
95902: LIST
95903: LIST
95904: LIST
95905: LIST
95906: LIST
95907: LIST
95908: LIST
95909: LIST
95910: LIST
95911: LIST
95912: LIST
95913: LIST
95914: PUSH
95915: LD_INT 101
95917: PUSH
95918: LD_INT 102
95920: PUSH
95921: LD_INT 103
95923: PUSH
95924: LD_INT 104
95926: PUSH
95927: LD_INT 105
95929: PUSH
95930: LD_INT 106
95932: PUSH
95933: LD_INT 107
95935: PUSH
95936: LD_INT 108
95938: PUSH
95939: LD_INT 109
95941: PUSH
95942: LD_INT 110
95944: PUSH
95945: LD_INT 111
95947: PUSH
95948: LD_INT 112
95950: PUSH
95951: LD_INT 113
95953: PUSH
95954: LD_INT 114
95956: PUSH
95957: LD_INT 116
95959: PUSH
95960: LD_INT 117
95962: PUSH
95963: LD_INT 118
95965: PUSH
95966: EMPTY
95967: LIST
95968: LIST
95969: LIST
95970: LIST
95971: LIST
95972: LIST
95973: LIST
95974: LIST
95975: LIST
95976: LIST
95977: LIST
95978: LIST
95979: LIST
95980: LIST
95981: LIST
95982: LIST
95983: LIST
95984: PUSH
95985: EMPTY
95986: LIST
95987: LIST
95988: ST_TO_ADDR
95989: GO 96996
95991: LD_INT 15
95993: DOUBLE
95994: EQUAL
95995: IFTRUE 95999
95997: GO 96223
95999: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
96000: LD_ADDR_VAR 0 2
96004: PUSH
96005: LD_INT 1
96007: PUSH
96008: LD_INT 2
96010: PUSH
96011: LD_INT 3
96013: PUSH
96014: LD_INT 4
96016: PUSH
96017: LD_INT 5
96019: PUSH
96020: LD_INT 6
96022: PUSH
96023: LD_INT 7
96025: PUSH
96026: LD_INT 8
96028: PUSH
96029: LD_INT 9
96031: PUSH
96032: LD_INT 10
96034: PUSH
96035: LD_INT 11
96037: PUSH
96038: LD_INT 12
96040: PUSH
96041: LD_INT 13
96043: PUSH
96044: LD_INT 14
96046: PUSH
96047: LD_INT 15
96049: PUSH
96050: LD_INT 16
96052: PUSH
96053: LD_INT 17
96055: PUSH
96056: LD_INT 18
96058: PUSH
96059: LD_INT 19
96061: PUSH
96062: LD_INT 20
96064: PUSH
96065: LD_INT 21
96067: PUSH
96068: LD_INT 22
96070: PUSH
96071: LD_INT 23
96073: PUSH
96074: LD_INT 24
96076: PUSH
96077: LD_INT 25
96079: PUSH
96080: LD_INT 26
96082: PUSH
96083: LD_INT 27
96085: PUSH
96086: LD_INT 28
96088: PUSH
96089: LD_INT 29
96091: PUSH
96092: LD_INT 30
96094: PUSH
96095: LD_INT 31
96097: PUSH
96098: LD_INT 32
96100: PUSH
96101: LD_INT 33
96103: PUSH
96104: LD_INT 34
96106: PUSH
96107: LD_INT 36
96109: PUSH
96110: EMPTY
96111: LIST
96112: LIST
96113: LIST
96114: LIST
96115: LIST
96116: LIST
96117: LIST
96118: LIST
96119: LIST
96120: LIST
96121: LIST
96122: LIST
96123: LIST
96124: LIST
96125: LIST
96126: LIST
96127: LIST
96128: LIST
96129: LIST
96130: LIST
96131: LIST
96132: LIST
96133: LIST
96134: LIST
96135: LIST
96136: LIST
96137: LIST
96138: LIST
96139: LIST
96140: LIST
96141: LIST
96142: LIST
96143: LIST
96144: LIST
96145: LIST
96146: PUSH
96147: LD_INT 101
96149: PUSH
96150: LD_INT 102
96152: PUSH
96153: LD_INT 103
96155: PUSH
96156: LD_INT 104
96158: PUSH
96159: LD_INT 105
96161: PUSH
96162: LD_INT 106
96164: PUSH
96165: LD_INT 107
96167: PUSH
96168: LD_INT 108
96170: PUSH
96171: LD_INT 109
96173: PUSH
96174: LD_INT 110
96176: PUSH
96177: LD_INT 111
96179: PUSH
96180: LD_INT 112
96182: PUSH
96183: LD_INT 113
96185: PUSH
96186: LD_INT 114
96188: PUSH
96189: LD_INT 116
96191: PUSH
96192: LD_INT 117
96194: PUSH
96195: LD_INT 118
96197: PUSH
96198: EMPTY
96199: LIST
96200: LIST
96201: LIST
96202: LIST
96203: LIST
96204: LIST
96205: LIST
96206: LIST
96207: LIST
96208: LIST
96209: LIST
96210: LIST
96211: LIST
96212: LIST
96213: LIST
96214: LIST
96215: LIST
96216: PUSH
96217: EMPTY
96218: LIST
96219: LIST
96220: ST_TO_ADDR
96221: GO 96996
96223: LD_INT 16
96225: DOUBLE
96226: EQUAL
96227: IFTRUE 96231
96229: GO 96367
96231: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
96232: LD_ADDR_VAR 0 2
96236: PUSH
96237: LD_INT 2
96239: PUSH
96240: LD_INT 4
96242: PUSH
96243: LD_INT 5
96245: PUSH
96246: LD_INT 7
96248: PUSH
96249: LD_INT 11
96251: PUSH
96252: LD_INT 12
96254: PUSH
96255: LD_INT 15
96257: PUSH
96258: LD_INT 16
96260: PUSH
96261: LD_INT 20
96263: PUSH
96264: LD_INT 21
96266: PUSH
96267: LD_INT 22
96269: PUSH
96270: LD_INT 23
96272: PUSH
96273: LD_INT 25
96275: PUSH
96276: LD_INT 26
96278: PUSH
96279: LD_INT 30
96281: PUSH
96282: LD_INT 31
96284: PUSH
96285: LD_INT 32
96287: PUSH
96288: LD_INT 33
96290: PUSH
96291: LD_INT 34
96293: PUSH
96294: EMPTY
96295: LIST
96296: LIST
96297: LIST
96298: LIST
96299: LIST
96300: LIST
96301: LIST
96302: LIST
96303: LIST
96304: LIST
96305: LIST
96306: LIST
96307: LIST
96308: LIST
96309: LIST
96310: LIST
96311: LIST
96312: LIST
96313: LIST
96314: PUSH
96315: LD_INT 101
96317: PUSH
96318: LD_INT 102
96320: PUSH
96321: LD_INT 103
96323: PUSH
96324: LD_INT 106
96326: PUSH
96327: LD_INT 108
96329: PUSH
96330: LD_INT 112
96332: PUSH
96333: LD_INT 113
96335: PUSH
96336: LD_INT 114
96338: PUSH
96339: LD_INT 116
96341: PUSH
96342: LD_INT 117
96344: PUSH
96345: LD_INT 118
96347: PUSH
96348: EMPTY
96349: LIST
96350: LIST
96351: LIST
96352: LIST
96353: LIST
96354: LIST
96355: LIST
96356: LIST
96357: LIST
96358: LIST
96359: LIST
96360: PUSH
96361: EMPTY
96362: LIST
96363: LIST
96364: ST_TO_ADDR
96365: GO 96996
96367: LD_INT 17
96369: DOUBLE
96370: EQUAL
96371: IFTRUE 96375
96373: GO 96599
96375: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
96376: LD_ADDR_VAR 0 2
96380: PUSH
96381: LD_INT 1
96383: PUSH
96384: LD_INT 2
96386: PUSH
96387: LD_INT 3
96389: PUSH
96390: LD_INT 4
96392: PUSH
96393: LD_INT 5
96395: PUSH
96396: LD_INT 6
96398: PUSH
96399: LD_INT 7
96401: PUSH
96402: LD_INT 8
96404: PUSH
96405: LD_INT 9
96407: PUSH
96408: LD_INT 10
96410: PUSH
96411: LD_INT 11
96413: PUSH
96414: LD_INT 12
96416: PUSH
96417: LD_INT 13
96419: PUSH
96420: LD_INT 14
96422: PUSH
96423: LD_INT 15
96425: PUSH
96426: LD_INT 16
96428: PUSH
96429: LD_INT 17
96431: PUSH
96432: LD_INT 18
96434: PUSH
96435: LD_INT 19
96437: PUSH
96438: LD_INT 20
96440: PUSH
96441: LD_INT 21
96443: PUSH
96444: LD_INT 22
96446: PUSH
96447: LD_INT 23
96449: PUSH
96450: LD_INT 24
96452: PUSH
96453: LD_INT 25
96455: PUSH
96456: LD_INT 26
96458: PUSH
96459: LD_INT 27
96461: PUSH
96462: LD_INT 28
96464: PUSH
96465: LD_INT 29
96467: PUSH
96468: LD_INT 30
96470: PUSH
96471: LD_INT 31
96473: PUSH
96474: LD_INT 32
96476: PUSH
96477: LD_INT 33
96479: PUSH
96480: LD_INT 34
96482: PUSH
96483: LD_INT 36
96485: PUSH
96486: EMPTY
96487: LIST
96488: LIST
96489: LIST
96490: LIST
96491: LIST
96492: LIST
96493: LIST
96494: LIST
96495: LIST
96496: LIST
96497: LIST
96498: LIST
96499: LIST
96500: LIST
96501: LIST
96502: LIST
96503: LIST
96504: LIST
96505: LIST
96506: LIST
96507: LIST
96508: LIST
96509: LIST
96510: LIST
96511: LIST
96512: LIST
96513: LIST
96514: LIST
96515: LIST
96516: LIST
96517: LIST
96518: LIST
96519: LIST
96520: LIST
96521: LIST
96522: PUSH
96523: LD_INT 101
96525: PUSH
96526: LD_INT 102
96528: PUSH
96529: LD_INT 103
96531: PUSH
96532: LD_INT 104
96534: PUSH
96535: LD_INT 105
96537: PUSH
96538: LD_INT 106
96540: PUSH
96541: LD_INT 107
96543: PUSH
96544: LD_INT 108
96546: PUSH
96547: LD_INT 109
96549: PUSH
96550: LD_INT 110
96552: PUSH
96553: LD_INT 111
96555: PUSH
96556: LD_INT 112
96558: PUSH
96559: LD_INT 113
96561: PUSH
96562: LD_INT 114
96564: PUSH
96565: LD_INT 116
96567: PUSH
96568: LD_INT 117
96570: PUSH
96571: LD_INT 118
96573: PUSH
96574: EMPTY
96575: LIST
96576: LIST
96577: LIST
96578: LIST
96579: LIST
96580: LIST
96581: LIST
96582: LIST
96583: LIST
96584: LIST
96585: LIST
96586: LIST
96587: LIST
96588: LIST
96589: LIST
96590: LIST
96591: LIST
96592: PUSH
96593: EMPTY
96594: LIST
96595: LIST
96596: ST_TO_ADDR
96597: GO 96996
96599: LD_INT 18
96601: DOUBLE
96602: EQUAL
96603: IFTRUE 96607
96605: GO 96755
96607: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
96608: LD_ADDR_VAR 0 2
96612: PUSH
96613: LD_INT 2
96615: PUSH
96616: LD_INT 4
96618: PUSH
96619: LD_INT 5
96621: PUSH
96622: LD_INT 7
96624: PUSH
96625: LD_INT 11
96627: PUSH
96628: LD_INT 12
96630: PUSH
96631: LD_INT 15
96633: PUSH
96634: LD_INT 16
96636: PUSH
96637: LD_INT 20
96639: PUSH
96640: LD_INT 21
96642: PUSH
96643: LD_INT 22
96645: PUSH
96646: LD_INT 23
96648: PUSH
96649: LD_INT 25
96651: PUSH
96652: LD_INT 26
96654: PUSH
96655: LD_INT 30
96657: PUSH
96658: LD_INT 31
96660: PUSH
96661: LD_INT 32
96663: PUSH
96664: LD_INT 33
96666: PUSH
96667: LD_INT 34
96669: PUSH
96670: LD_INT 35
96672: PUSH
96673: LD_INT 36
96675: PUSH
96676: EMPTY
96677: LIST
96678: LIST
96679: LIST
96680: LIST
96681: LIST
96682: LIST
96683: LIST
96684: LIST
96685: LIST
96686: LIST
96687: LIST
96688: LIST
96689: LIST
96690: LIST
96691: LIST
96692: LIST
96693: LIST
96694: LIST
96695: LIST
96696: LIST
96697: LIST
96698: PUSH
96699: LD_INT 101
96701: PUSH
96702: LD_INT 102
96704: PUSH
96705: LD_INT 103
96707: PUSH
96708: LD_INT 106
96710: PUSH
96711: LD_INT 108
96713: PUSH
96714: LD_INT 112
96716: PUSH
96717: LD_INT 113
96719: PUSH
96720: LD_INT 114
96722: PUSH
96723: LD_INT 115
96725: PUSH
96726: LD_INT 116
96728: PUSH
96729: LD_INT 117
96731: PUSH
96732: LD_INT 118
96734: PUSH
96735: EMPTY
96736: LIST
96737: LIST
96738: LIST
96739: LIST
96740: LIST
96741: LIST
96742: LIST
96743: LIST
96744: LIST
96745: LIST
96746: LIST
96747: LIST
96748: PUSH
96749: EMPTY
96750: LIST
96751: LIST
96752: ST_TO_ADDR
96753: GO 96996
96755: LD_INT 19
96757: DOUBLE
96758: EQUAL
96759: IFTRUE 96763
96761: GO 96995
96763: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
96764: LD_ADDR_VAR 0 2
96768: PUSH
96769: LD_INT 1
96771: PUSH
96772: LD_INT 2
96774: PUSH
96775: LD_INT 3
96777: PUSH
96778: LD_INT 4
96780: PUSH
96781: LD_INT 5
96783: PUSH
96784: LD_INT 6
96786: PUSH
96787: LD_INT 7
96789: PUSH
96790: LD_INT 8
96792: PUSH
96793: LD_INT 9
96795: PUSH
96796: LD_INT 10
96798: PUSH
96799: LD_INT 11
96801: PUSH
96802: LD_INT 12
96804: PUSH
96805: LD_INT 13
96807: PUSH
96808: LD_INT 14
96810: PUSH
96811: LD_INT 15
96813: PUSH
96814: LD_INT 16
96816: PUSH
96817: LD_INT 17
96819: PUSH
96820: LD_INT 18
96822: PUSH
96823: LD_INT 19
96825: PUSH
96826: LD_INT 20
96828: PUSH
96829: LD_INT 21
96831: PUSH
96832: LD_INT 22
96834: PUSH
96835: LD_INT 23
96837: PUSH
96838: LD_INT 24
96840: PUSH
96841: LD_INT 25
96843: PUSH
96844: LD_INT 26
96846: PUSH
96847: LD_INT 27
96849: PUSH
96850: LD_INT 28
96852: PUSH
96853: LD_INT 29
96855: PUSH
96856: LD_INT 30
96858: PUSH
96859: LD_INT 31
96861: PUSH
96862: LD_INT 32
96864: PUSH
96865: LD_INT 33
96867: PUSH
96868: LD_INT 34
96870: PUSH
96871: LD_INT 35
96873: PUSH
96874: LD_INT 36
96876: PUSH
96877: EMPTY
96878: LIST
96879: LIST
96880: LIST
96881: LIST
96882: LIST
96883: LIST
96884: LIST
96885: LIST
96886: LIST
96887: LIST
96888: LIST
96889: LIST
96890: LIST
96891: LIST
96892: LIST
96893: LIST
96894: LIST
96895: LIST
96896: LIST
96897: LIST
96898: LIST
96899: LIST
96900: LIST
96901: LIST
96902: LIST
96903: LIST
96904: LIST
96905: LIST
96906: LIST
96907: LIST
96908: LIST
96909: LIST
96910: LIST
96911: LIST
96912: LIST
96913: LIST
96914: PUSH
96915: LD_INT 101
96917: PUSH
96918: LD_INT 102
96920: PUSH
96921: LD_INT 103
96923: PUSH
96924: LD_INT 104
96926: PUSH
96927: LD_INT 105
96929: PUSH
96930: LD_INT 106
96932: PUSH
96933: LD_INT 107
96935: PUSH
96936: LD_INT 108
96938: PUSH
96939: LD_INT 109
96941: PUSH
96942: LD_INT 110
96944: PUSH
96945: LD_INT 111
96947: PUSH
96948: LD_INT 112
96950: PUSH
96951: LD_INT 113
96953: PUSH
96954: LD_INT 114
96956: PUSH
96957: LD_INT 115
96959: PUSH
96960: LD_INT 116
96962: PUSH
96963: LD_INT 117
96965: PUSH
96966: LD_INT 118
96968: PUSH
96969: EMPTY
96970: LIST
96971: LIST
96972: LIST
96973: LIST
96974: LIST
96975: LIST
96976: LIST
96977: LIST
96978: LIST
96979: LIST
96980: LIST
96981: LIST
96982: LIST
96983: LIST
96984: LIST
96985: LIST
96986: LIST
96987: LIST
96988: PUSH
96989: EMPTY
96990: LIST
96991: LIST
96992: ST_TO_ADDR
96993: GO 96996
96995: POP
// end else
96996: GO 97227
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
96998: LD_ADDR_VAR 0 2
97002: PUSH
97003: LD_INT 1
97005: PUSH
97006: LD_INT 2
97008: PUSH
97009: LD_INT 3
97011: PUSH
97012: LD_INT 4
97014: PUSH
97015: LD_INT 5
97017: PUSH
97018: LD_INT 6
97020: PUSH
97021: LD_INT 7
97023: PUSH
97024: LD_INT 8
97026: PUSH
97027: LD_INT 9
97029: PUSH
97030: LD_INT 10
97032: PUSH
97033: LD_INT 11
97035: PUSH
97036: LD_INT 12
97038: PUSH
97039: LD_INT 13
97041: PUSH
97042: LD_INT 14
97044: PUSH
97045: LD_INT 15
97047: PUSH
97048: LD_INT 16
97050: PUSH
97051: LD_INT 17
97053: PUSH
97054: LD_INT 18
97056: PUSH
97057: LD_INT 19
97059: PUSH
97060: LD_INT 20
97062: PUSH
97063: LD_INT 21
97065: PUSH
97066: LD_INT 22
97068: PUSH
97069: LD_INT 23
97071: PUSH
97072: LD_INT 24
97074: PUSH
97075: LD_INT 25
97077: PUSH
97078: LD_INT 26
97080: PUSH
97081: LD_INT 27
97083: PUSH
97084: LD_INT 28
97086: PUSH
97087: LD_INT 29
97089: PUSH
97090: LD_INT 30
97092: PUSH
97093: LD_INT 31
97095: PUSH
97096: LD_INT 32
97098: PUSH
97099: LD_INT 33
97101: PUSH
97102: LD_INT 34
97104: PUSH
97105: LD_INT 35
97107: PUSH
97108: LD_INT 36
97110: PUSH
97111: EMPTY
97112: LIST
97113: LIST
97114: LIST
97115: LIST
97116: LIST
97117: LIST
97118: LIST
97119: LIST
97120: LIST
97121: LIST
97122: LIST
97123: LIST
97124: LIST
97125: LIST
97126: LIST
97127: LIST
97128: LIST
97129: LIST
97130: LIST
97131: LIST
97132: LIST
97133: LIST
97134: LIST
97135: LIST
97136: LIST
97137: LIST
97138: LIST
97139: LIST
97140: LIST
97141: LIST
97142: LIST
97143: LIST
97144: LIST
97145: LIST
97146: LIST
97147: LIST
97148: PUSH
97149: LD_INT 101
97151: PUSH
97152: LD_INT 102
97154: PUSH
97155: LD_INT 103
97157: PUSH
97158: LD_INT 104
97160: PUSH
97161: LD_INT 105
97163: PUSH
97164: LD_INT 106
97166: PUSH
97167: LD_INT 107
97169: PUSH
97170: LD_INT 108
97172: PUSH
97173: LD_INT 109
97175: PUSH
97176: LD_INT 110
97178: PUSH
97179: LD_INT 111
97181: PUSH
97182: LD_INT 112
97184: PUSH
97185: LD_INT 113
97187: PUSH
97188: LD_INT 114
97190: PUSH
97191: LD_INT 115
97193: PUSH
97194: LD_INT 116
97196: PUSH
97197: LD_INT 117
97199: PUSH
97200: LD_INT 118
97202: PUSH
97203: EMPTY
97204: LIST
97205: LIST
97206: LIST
97207: LIST
97208: LIST
97209: LIST
97210: LIST
97211: LIST
97212: LIST
97213: LIST
97214: LIST
97215: LIST
97216: LIST
97217: LIST
97218: LIST
97219: LIST
97220: LIST
97221: LIST
97222: PUSH
97223: EMPTY
97224: LIST
97225: LIST
97226: ST_TO_ADDR
// if result then
97227: LD_VAR 0 2
97231: IFFALSE 98017
// begin normal :=  ;
97233: LD_ADDR_VAR 0 5
97237: PUSH
97238: LD_STRING 
97240: ST_TO_ADDR
// hardcore :=  ;
97241: LD_ADDR_VAR 0 6
97245: PUSH
97246: LD_STRING 
97248: ST_TO_ADDR
// active :=  ;
97249: LD_ADDR_VAR 0 7
97253: PUSH
97254: LD_STRING 
97256: ST_TO_ADDR
// for i = 1 to normalCounter do
97257: LD_ADDR_VAR 0 8
97261: PUSH
97262: DOUBLE
97263: LD_INT 1
97265: DEC
97266: ST_TO_ADDR
97267: LD_EXP 97
97271: PUSH
97272: FOR_TO
97273: IFFALSE 97374
// begin tmp := 0 ;
97275: LD_ADDR_VAR 0 3
97279: PUSH
97280: LD_STRING 0
97282: ST_TO_ADDR
// if result [ 1 ] then
97283: LD_VAR 0 2
97287: PUSH
97288: LD_INT 1
97290: ARRAY
97291: IFFALSE 97356
// if result [ 1 ] [ 1 ] = i then
97293: LD_VAR 0 2
97297: PUSH
97298: LD_INT 1
97300: ARRAY
97301: PUSH
97302: LD_INT 1
97304: ARRAY
97305: PUSH
97306: LD_VAR 0 8
97310: EQUAL
97311: IFFALSE 97356
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
97313: LD_ADDR_VAR 0 2
97317: PUSH
97318: LD_VAR 0 2
97322: PPUSH
97323: LD_INT 1
97325: PPUSH
97326: LD_VAR 0 2
97330: PUSH
97331: LD_INT 1
97333: ARRAY
97334: PPUSH
97335: LD_INT 1
97337: PPUSH
97338: CALL_OW 3
97342: PPUSH
97343: CALL_OW 1
97347: ST_TO_ADDR
// tmp := 1 ;
97348: LD_ADDR_VAR 0 3
97352: PUSH
97353: LD_STRING 1
97355: ST_TO_ADDR
// end ; normal := normal & tmp ;
97356: LD_ADDR_VAR 0 5
97360: PUSH
97361: LD_VAR 0 5
97365: PUSH
97366: LD_VAR 0 3
97370: STR
97371: ST_TO_ADDR
// end ;
97372: GO 97272
97374: POP
97375: POP
// for i = 1 to hardcoreCounter do
97376: LD_ADDR_VAR 0 8
97380: PUSH
97381: DOUBLE
97382: LD_INT 1
97384: DEC
97385: ST_TO_ADDR
97386: LD_EXP 98
97390: PUSH
97391: FOR_TO
97392: IFFALSE 97497
// begin tmp := 0 ;
97394: LD_ADDR_VAR 0 3
97398: PUSH
97399: LD_STRING 0
97401: ST_TO_ADDR
// if result [ 2 ] then
97402: LD_VAR 0 2
97406: PUSH
97407: LD_INT 2
97409: ARRAY
97410: IFFALSE 97479
// if result [ 2 ] [ 1 ] = 100 + i then
97412: LD_VAR 0 2
97416: PUSH
97417: LD_INT 2
97419: ARRAY
97420: PUSH
97421: LD_INT 1
97423: ARRAY
97424: PUSH
97425: LD_INT 100
97427: PUSH
97428: LD_VAR 0 8
97432: PLUS
97433: EQUAL
97434: IFFALSE 97479
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
97436: LD_ADDR_VAR 0 2
97440: PUSH
97441: LD_VAR 0 2
97445: PPUSH
97446: LD_INT 2
97448: PPUSH
97449: LD_VAR 0 2
97453: PUSH
97454: LD_INT 2
97456: ARRAY
97457: PPUSH
97458: LD_INT 1
97460: PPUSH
97461: CALL_OW 3
97465: PPUSH
97466: CALL_OW 1
97470: ST_TO_ADDR
// tmp := 1 ;
97471: LD_ADDR_VAR 0 3
97475: PUSH
97476: LD_STRING 1
97478: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
97479: LD_ADDR_VAR 0 6
97483: PUSH
97484: LD_VAR 0 6
97488: PUSH
97489: LD_VAR 0 3
97493: STR
97494: ST_TO_ADDR
// end ;
97495: GO 97391
97497: POP
97498: POP
// if isGameLoad then
97499: LD_VAR 0 1
97503: IFFALSE 97978
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
97505: LD_ADDR_VAR 0 4
97509: PUSH
97510: LD_EXP 101
97514: PUSH
97515: LD_EXP 100
97519: PUSH
97520: LD_EXP 102
97524: PUSH
97525: LD_EXP 99
97529: PUSH
97530: LD_EXP 103
97534: PUSH
97535: LD_EXP 104
97539: PUSH
97540: LD_EXP 105
97544: PUSH
97545: LD_EXP 106
97549: PUSH
97550: LD_EXP 107
97554: PUSH
97555: LD_EXP 108
97559: PUSH
97560: LD_EXP 109
97564: PUSH
97565: LD_EXP 110
97569: PUSH
97570: LD_EXP 111
97574: PUSH
97575: LD_EXP 112
97579: PUSH
97580: LD_EXP 120
97584: PUSH
97585: LD_EXP 121
97589: PUSH
97590: LD_EXP 122
97594: PUSH
97595: LD_EXP 123
97599: PUSH
97600: LD_EXP 125
97604: PUSH
97605: LD_EXP 126
97609: PUSH
97610: LD_EXP 127
97614: PUSH
97615: LD_EXP 130
97619: PUSH
97620: LD_EXP 132
97624: PUSH
97625: LD_EXP 133
97629: PUSH
97630: LD_EXP 134
97634: PUSH
97635: LD_EXP 136
97639: PUSH
97640: LD_EXP 137
97644: PUSH
97645: LD_EXP 140
97649: PUSH
97650: LD_EXP 141
97654: PUSH
97655: LD_EXP 142
97659: PUSH
97660: LD_EXP 143
97664: PUSH
97665: LD_EXP 144
97669: PUSH
97670: LD_EXP 145
97674: PUSH
97675: LD_EXP 146
97679: PUSH
97680: LD_EXP 147
97684: PUSH
97685: LD_EXP 148
97689: PUSH
97690: LD_EXP 113
97694: PUSH
97695: LD_EXP 114
97699: PUSH
97700: LD_EXP 117
97704: PUSH
97705: LD_EXP 118
97709: PUSH
97710: LD_EXP 119
97714: PUSH
97715: LD_EXP 115
97719: PUSH
97720: LD_EXP 116
97724: PUSH
97725: LD_EXP 124
97729: PUSH
97730: LD_EXP 128
97734: PUSH
97735: LD_EXP 129
97739: PUSH
97740: LD_EXP 131
97744: PUSH
97745: LD_EXP 135
97749: PUSH
97750: LD_EXP 138
97754: PUSH
97755: LD_EXP 139
97759: PUSH
97760: LD_EXP 149
97764: PUSH
97765: LD_EXP 150
97769: PUSH
97770: LD_EXP 151
97774: PUSH
97775: LD_EXP 152
97779: PUSH
97780: EMPTY
97781: LIST
97782: LIST
97783: LIST
97784: LIST
97785: LIST
97786: LIST
97787: LIST
97788: LIST
97789: LIST
97790: LIST
97791: LIST
97792: LIST
97793: LIST
97794: LIST
97795: LIST
97796: LIST
97797: LIST
97798: LIST
97799: LIST
97800: LIST
97801: LIST
97802: LIST
97803: LIST
97804: LIST
97805: LIST
97806: LIST
97807: LIST
97808: LIST
97809: LIST
97810: LIST
97811: LIST
97812: LIST
97813: LIST
97814: LIST
97815: LIST
97816: LIST
97817: LIST
97818: LIST
97819: LIST
97820: LIST
97821: LIST
97822: LIST
97823: LIST
97824: LIST
97825: LIST
97826: LIST
97827: LIST
97828: LIST
97829: LIST
97830: LIST
97831: LIST
97832: LIST
97833: LIST
97834: LIST
97835: ST_TO_ADDR
// tmp :=  ;
97836: LD_ADDR_VAR 0 3
97840: PUSH
97841: LD_STRING 
97843: ST_TO_ADDR
// for i = 1 to normalCounter do
97844: LD_ADDR_VAR 0 8
97848: PUSH
97849: DOUBLE
97850: LD_INT 1
97852: DEC
97853: ST_TO_ADDR
97854: LD_EXP 97
97858: PUSH
97859: FOR_TO
97860: IFFALSE 97896
// begin if flags [ i ] then
97862: LD_VAR 0 4
97866: PUSH
97867: LD_VAR 0 8
97871: ARRAY
97872: IFFALSE 97894
// tmp := tmp & i & ; ;
97874: LD_ADDR_VAR 0 3
97878: PUSH
97879: LD_VAR 0 3
97883: PUSH
97884: LD_VAR 0 8
97888: STR
97889: PUSH
97890: LD_STRING ;
97892: STR
97893: ST_TO_ADDR
// end ;
97894: GO 97859
97896: POP
97897: POP
// for i = 1 to hardcoreCounter do
97898: LD_ADDR_VAR 0 8
97902: PUSH
97903: DOUBLE
97904: LD_INT 1
97906: DEC
97907: ST_TO_ADDR
97908: LD_EXP 98
97912: PUSH
97913: FOR_TO
97914: IFFALSE 97960
// begin if flags [ normalCounter + i ] then
97916: LD_VAR 0 4
97920: PUSH
97921: LD_EXP 97
97925: PUSH
97926: LD_VAR 0 8
97930: PLUS
97931: ARRAY
97932: IFFALSE 97958
// tmp := tmp & ( 100 + i ) & ; ;
97934: LD_ADDR_VAR 0 3
97938: PUSH
97939: LD_VAR 0 3
97943: PUSH
97944: LD_INT 100
97946: PUSH
97947: LD_VAR 0 8
97951: PLUS
97952: STR
97953: PUSH
97954: LD_STRING ;
97956: STR
97957: ST_TO_ADDR
// end ;
97958: GO 97913
97960: POP
97961: POP
// if tmp then
97962: LD_VAR 0 3
97966: IFFALSE 97978
// active := tmp ;
97968: LD_ADDR_VAR 0 7
97972: PUSH
97973: LD_VAR 0 3
97977: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
97978: LD_STRING getStreamItemsFromMission("
97980: PUSH
97981: LD_VAR 0 5
97985: STR
97986: PUSH
97987: LD_STRING ","
97989: STR
97990: PUSH
97991: LD_VAR 0 6
97995: STR
97996: PUSH
97997: LD_STRING ","
97999: STR
98000: PUSH
98001: LD_VAR 0 7
98005: STR
98006: PUSH
98007: LD_STRING ")
98009: STR
98010: PPUSH
98011: CALL_OW 559
// end else
98015: GO 98024
// ToLua ( getStreamItemsFromMission("","","") ) ;
98017: LD_STRING getStreamItemsFromMission("","","")
98019: PPUSH
98020: CALL_OW 559
// end ;
98024: LD_VAR 0 2
98028: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
98029: LD_EXP 96
98033: PUSH
98034: LD_EXP 101
98038: AND
98039: IFFALSE 98163
98041: GO 98043
98043: DISABLE
98044: LD_INT 0
98046: PPUSH
98047: PPUSH
// begin enable ;
98048: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
98049: LD_ADDR_VAR 0 2
98053: PUSH
98054: LD_INT 22
98056: PUSH
98057: LD_OWVAR 2
98061: PUSH
98062: EMPTY
98063: LIST
98064: LIST
98065: PUSH
98066: LD_INT 2
98068: PUSH
98069: LD_INT 34
98071: PUSH
98072: LD_INT 7
98074: PUSH
98075: EMPTY
98076: LIST
98077: LIST
98078: PUSH
98079: LD_INT 34
98081: PUSH
98082: LD_INT 45
98084: PUSH
98085: EMPTY
98086: LIST
98087: LIST
98088: PUSH
98089: LD_INT 34
98091: PUSH
98092: LD_INT 28
98094: PUSH
98095: EMPTY
98096: LIST
98097: LIST
98098: PUSH
98099: LD_INT 34
98101: PUSH
98102: LD_INT 47
98104: PUSH
98105: EMPTY
98106: LIST
98107: LIST
98108: PUSH
98109: EMPTY
98110: LIST
98111: LIST
98112: LIST
98113: LIST
98114: LIST
98115: PUSH
98116: EMPTY
98117: LIST
98118: LIST
98119: PPUSH
98120: CALL_OW 69
98124: ST_TO_ADDR
// if not tmp then
98125: LD_VAR 0 2
98129: NOT
98130: IFFALSE 98134
// exit ;
98132: GO 98163
// for i in tmp do
98134: LD_ADDR_VAR 0 1
98138: PUSH
98139: LD_VAR 0 2
98143: PUSH
98144: FOR_IN
98145: IFFALSE 98161
// begin SetLives ( i , 0 ) ;
98147: LD_VAR 0 1
98151: PPUSH
98152: LD_INT 0
98154: PPUSH
98155: CALL_OW 234
// end ;
98159: GO 98144
98161: POP
98162: POP
// end ;
98163: PPOPN 2
98165: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
98166: LD_EXP 96
98170: PUSH
98171: LD_EXP 102
98175: AND
98176: IFFALSE 98260
98178: GO 98180
98180: DISABLE
98181: LD_INT 0
98183: PPUSH
98184: PPUSH
// begin enable ;
98185: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
98186: LD_ADDR_VAR 0 2
98190: PUSH
98191: LD_INT 22
98193: PUSH
98194: LD_OWVAR 2
98198: PUSH
98199: EMPTY
98200: LIST
98201: LIST
98202: PUSH
98203: LD_INT 32
98205: PUSH
98206: LD_INT 3
98208: PUSH
98209: EMPTY
98210: LIST
98211: LIST
98212: PUSH
98213: EMPTY
98214: LIST
98215: LIST
98216: PPUSH
98217: CALL_OW 69
98221: ST_TO_ADDR
// if not tmp then
98222: LD_VAR 0 2
98226: NOT
98227: IFFALSE 98231
// exit ;
98229: GO 98260
// for i in tmp do
98231: LD_ADDR_VAR 0 1
98235: PUSH
98236: LD_VAR 0 2
98240: PUSH
98241: FOR_IN
98242: IFFALSE 98258
// begin SetLives ( i , 0 ) ;
98244: LD_VAR 0 1
98248: PPUSH
98249: LD_INT 0
98251: PPUSH
98252: CALL_OW 234
// end ;
98256: GO 98241
98258: POP
98259: POP
// end ;
98260: PPOPN 2
98262: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
98263: LD_EXP 96
98267: PUSH
98268: LD_EXP 99
98272: AND
98273: IFFALSE 98366
98275: GO 98277
98277: DISABLE
98278: LD_INT 0
98280: PPUSH
// begin enable ;
98281: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
98282: LD_ADDR_VAR 0 1
98286: PUSH
98287: LD_INT 22
98289: PUSH
98290: LD_OWVAR 2
98294: PUSH
98295: EMPTY
98296: LIST
98297: LIST
98298: PUSH
98299: LD_INT 2
98301: PUSH
98302: LD_INT 25
98304: PUSH
98305: LD_INT 5
98307: PUSH
98308: EMPTY
98309: LIST
98310: LIST
98311: PUSH
98312: LD_INT 25
98314: PUSH
98315: LD_INT 9
98317: PUSH
98318: EMPTY
98319: LIST
98320: LIST
98321: PUSH
98322: LD_INT 25
98324: PUSH
98325: LD_INT 8
98327: PUSH
98328: EMPTY
98329: LIST
98330: LIST
98331: PUSH
98332: EMPTY
98333: LIST
98334: LIST
98335: LIST
98336: LIST
98337: PUSH
98338: EMPTY
98339: LIST
98340: LIST
98341: PPUSH
98342: CALL_OW 69
98346: PUSH
98347: FOR_IN
98348: IFFALSE 98364
// begin SetClass ( i , 1 ) ;
98350: LD_VAR 0 1
98354: PPUSH
98355: LD_INT 1
98357: PPUSH
98358: CALL_OW 336
// end ;
98362: GO 98347
98364: POP
98365: POP
// end ;
98366: PPOPN 1
98368: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
98369: LD_EXP 96
98373: PUSH
98374: LD_EXP 100
98378: AND
98379: PUSH
98380: LD_OWVAR 65
98384: PUSH
98385: LD_INT 7
98387: LESS
98388: AND
98389: IFFALSE 98403
98391: GO 98393
98393: DISABLE
// begin enable ;
98394: ENABLE
// game_speed := 7 ;
98395: LD_ADDR_OWVAR 65
98399: PUSH
98400: LD_INT 7
98402: ST_TO_ADDR
// end ;
98403: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
98404: LD_EXP 96
98408: PUSH
98409: LD_EXP 103
98413: AND
98414: IFFALSE 98616
98416: GO 98418
98418: DISABLE
98419: LD_INT 0
98421: PPUSH
98422: PPUSH
98423: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
98424: LD_ADDR_VAR 0 3
98428: PUSH
98429: LD_INT 81
98431: PUSH
98432: LD_OWVAR 2
98436: PUSH
98437: EMPTY
98438: LIST
98439: LIST
98440: PUSH
98441: LD_INT 21
98443: PUSH
98444: LD_INT 1
98446: PUSH
98447: EMPTY
98448: LIST
98449: LIST
98450: PUSH
98451: EMPTY
98452: LIST
98453: LIST
98454: PPUSH
98455: CALL_OW 69
98459: ST_TO_ADDR
// if not tmp then
98460: LD_VAR 0 3
98464: NOT
98465: IFFALSE 98469
// exit ;
98467: GO 98616
// if tmp > 5 then
98469: LD_VAR 0 3
98473: PUSH
98474: LD_INT 5
98476: GREATER
98477: IFFALSE 98489
// k := 5 else
98479: LD_ADDR_VAR 0 2
98483: PUSH
98484: LD_INT 5
98486: ST_TO_ADDR
98487: GO 98499
// k := tmp ;
98489: LD_ADDR_VAR 0 2
98493: PUSH
98494: LD_VAR 0 3
98498: ST_TO_ADDR
// for i := 1 to k do
98499: LD_ADDR_VAR 0 1
98503: PUSH
98504: DOUBLE
98505: LD_INT 1
98507: DEC
98508: ST_TO_ADDR
98509: LD_VAR 0 2
98513: PUSH
98514: FOR_TO
98515: IFFALSE 98614
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
98517: LD_VAR 0 3
98521: PUSH
98522: LD_VAR 0 1
98526: ARRAY
98527: PPUSH
98528: LD_VAR 0 1
98532: PUSH
98533: LD_INT 4
98535: MOD
98536: PUSH
98537: LD_INT 1
98539: PLUS
98540: PPUSH
98541: CALL_OW 259
98545: PUSH
98546: LD_INT 10
98548: LESS
98549: IFFALSE 98612
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
98551: LD_VAR 0 3
98555: PUSH
98556: LD_VAR 0 1
98560: ARRAY
98561: PPUSH
98562: LD_VAR 0 1
98566: PUSH
98567: LD_INT 4
98569: MOD
98570: PUSH
98571: LD_INT 1
98573: PLUS
98574: PPUSH
98575: LD_VAR 0 3
98579: PUSH
98580: LD_VAR 0 1
98584: ARRAY
98585: PPUSH
98586: LD_VAR 0 1
98590: PUSH
98591: LD_INT 4
98593: MOD
98594: PUSH
98595: LD_INT 1
98597: PLUS
98598: PPUSH
98599: CALL_OW 259
98603: PUSH
98604: LD_INT 1
98606: PLUS
98607: PPUSH
98608: CALL_OW 237
98612: GO 98514
98614: POP
98615: POP
// end ;
98616: PPOPN 3
98618: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
98619: LD_EXP 96
98623: PUSH
98624: LD_EXP 104
98628: AND
98629: IFFALSE 98649
98631: GO 98633
98633: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
98634: LD_INT 4
98636: PPUSH
98637: LD_OWVAR 2
98641: PPUSH
98642: LD_INT 0
98644: PPUSH
98645: CALL_OW 324
98649: END
// every 0 0$1 trigger StreamModeActive and sShovel do
98650: LD_EXP 96
98654: PUSH
98655: LD_EXP 133
98659: AND
98660: IFFALSE 98680
98662: GO 98664
98664: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
98665: LD_INT 19
98667: PPUSH
98668: LD_OWVAR 2
98672: PPUSH
98673: LD_INT 0
98675: PPUSH
98676: CALL_OW 324
98680: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
98681: LD_EXP 96
98685: PUSH
98686: LD_EXP 105
98690: AND
98691: IFFALSE 98793
98693: GO 98695
98695: DISABLE
98696: LD_INT 0
98698: PPUSH
98699: PPUSH
// begin enable ;
98700: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
98701: LD_ADDR_VAR 0 2
98705: PUSH
98706: LD_INT 22
98708: PUSH
98709: LD_OWVAR 2
98713: PUSH
98714: EMPTY
98715: LIST
98716: LIST
98717: PUSH
98718: LD_INT 2
98720: PUSH
98721: LD_INT 34
98723: PUSH
98724: LD_INT 11
98726: PUSH
98727: EMPTY
98728: LIST
98729: LIST
98730: PUSH
98731: LD_INT 34
98733: PUSH
98734: LD_INT 30
98736: PUSH
98737: EMPTY
98738: LIST
98739: LIST
98740: PUSH
98741: EMPTY
98742: LIST
98743: LIST
98744: LIST
98745: PUSH
98746: EMPTY
98747: LIST
98748: LIST
98749: PPUSH
98750: CALL_OW 69
98754: ST_TO_ADDR
// if not tmp then
98755: LD_VAR 0 2
98759: NOT
98760: IFFALSE 98764
// exit ;
98762: GO 98793
// for i in tmp do
98764: LD_ADDR_VAR 0 1
98768: PUSH
98769: LD_VAR 0 2
98773: PUSH
98774: FOR_IN
98775: IFFALSE 98791
// begin SetLives ( i , 0 ) ;
98777: LD_VAR 0 1
98781: PPUSH
98782: LD_INT 0
98784: PPUSH
98785: CALL_OW 234
// end ;
98789: GO 98774
98791: POP
98792: POP
// end ;
98793: PPOPN 2
98795: END
// every 0 0$1 trigger StreamModeActive and sBunker do
98796: LD_EXP 96
98800: PUSH
98801: LD_EXP 106
98805: AND
98806: IFFALSE 98826
98808: GO 98810
98810: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
98811: LD_INT 32
98813: PPUSH
98814: LD_OWVAR 2
98818: PPUSH
98819: LD_INT 0
98821: PPUSH
98822: CALL_OW 324
98826: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
98827: LD_EXP 96
98831: PUSH
98832: LD_EXP 107
98836: AND
98837: IFFALSE 99018
98839: GO 98841
98841: DISABLE
98842: LD_INT 0
98844: PPUSH
98845: PPUSH
98846: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
98847: LD_ADDR_VAR 0 2
98851: PUSH
98852: LD_INT 22
98854: PUSH
98855: LD_OWVAR 2
98859: PUSH
98860: EMPTY
98861: LIST
98862: LIST
98863: PUSH
98864: LD_INT 33
98866: PUSH
98867: LD_INT 3
98869: PUSH
98870: EMPTY
98871: LIST
98872: LIST
98873: PUSH
98874: EMPTY
98875: LIST
98876: LIST
98877: PPUSH
98878: CALL_OW 69
98882: ST_TO_ADDR
// if not tmp then
98883: LD_VAR 0 2
98887: NOT
98888: IFFALSE 98892
// exit ;
98890: GO 99018
// side := 0 ;
98892: LD_ADDR_VAR 0 3
98896: PUSH
98897: LD_INT 0
98899: ST_TO_ADDR
// for i := 1 to 8 do
98900: LD_ADDR_VAR 0 1
98904: PUSH
98905: DOUBLE
98906: LD_INT 1
98908: DEC
98909: ST_TO_ADDR
98910: LD_INT 8
98912: PUSH
98913: FOR_TO
98914: IFFALSE 98962
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
98916: LD_OWVAR 2
98920: PUSH
98921: LD_VAR 0 1
98925: NONEQUAL
98926: PUSH
98927: LD_OWVAR 2
98931: PPUSH
98932: LD_VAR 0 1
98936: PPUSH
98937: CALL_OW 81
98941: PUSH
98942: LD_INT 2
98944: EQUAL
98945: AND
98946: IFFALSE 98960
// begin side := i ;
98948: LD_ADDR_VAR 0 3
98952: PUSH
98953: LD_VAR 0 1
98957: ST_TO_ADDR
// break ;
98958: GO 98962
// end ;
98960: GO 98913
98962: POP
98963: POP
// if not side then
98964: LD_VAR 0 3
98968: NOT
98969: IFFALSE 98973
// exit ;
98971: GO 99018
// for i := 1 to tmp do
98973: LD_ADDR_VAR 0 1
98977: PUSH
98978: DOUBLE
98979: LD_INT 1
98981: DEC
98982: ST_TO_ADDR
98983: LD_VAR 0 2
98987: PUSH
98988: FOR_TO
98989: IFFALSE 99016
// if Prob ( 60 ) then
98991: LD_INT 60
98993: PPUSH
98994: CALL_OW 13
98998: IFFALSE 99014
// SetSide ( i , side ) ;
99000: LD_VAR 0 1
99004: PPUSH
99005: LD_VAR 0 3
99009: PPUSH
99010: CALL_OW 235
99014: GO 98988
99016: POP
99017: POP
// end ;
99018: PPOPN 3
99020: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
99021: LD_EXP 96
99025: PUSH
99026: LD_EXP 109
99030: AND
99031: IFFALSE 99150
99033: GO 99035
99035: DISABLE
99036: LD_INT 0
99038: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
99039: LD_ADDR_VAR 0 1
99043: PUSH
99044: LD_INT 22
99046: PUSH
99047: LD_OWVAR 2
99051: PUSH
99052: EMPTY
99053: LIST
99054: LIST
99055: PUSH
99056: LD_INT 21
99058: PUSH
99059: LD_INT 1
99061: PUSH
99062: EMPTY
99063: LIST
99064: LIST
99065: PUSH
99066: LD_INT 3
99068: PUSH
99069: LD_INT 23
99071: PUSH
99072: LD_INT 0
99074: PUSH
99075: EMPTY
99076: LIST
99077: LIST
99078: PUSH
99079: EMPTY
99080: LIST
99081: LIST
99082: PUSH
99083: EMPTY
99084: LIST
99085: LIST
99086: LIST
99087: PPUSH
99088: CALL_OW 69
99092: PUSH
99093: FOR_IN
99094: IFFALSE 99148
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
99096: LD_VAR 0 1
99100: PPUSH
99101: CALL_OW 257
99105: PUSH
99106: LD_INT 1
99108: PUSH
99109: LD_INT 2
99111: PUSH
99112: LD_INT 3
99114: PUSH
99115: LD_INT 4
99117: PUSH
99118: EMPTY
99119: LIST
99120: LIST
99121: LIST
99122: LIST
99123: IN
99124: IFFALSE 99146
// SetClass ( un , rand ( 1 , 4 ) ) ;
99126: LD_VAR 0 1
99130: PPUSH
99131: LD_INT 1
99133: PPUSH
99134: LD_INT 4
99136: PPUSH
99137: CALL_OW 12
99141: PPUSH
99142: CALL_OW 336
99146: GO 99093
99148: POP
99149: POP
// end ;
99150: PPOPN 1
99152: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
99153: LD_EXP 96
99157: PUSH
99158: LD_EXP 108
99162: AND
99163: IFFALSE 99242
99165: GO 99167
99167: DISABLE
99168: LD_INT 0
99170: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
99171: LD_ADDR_VAR 0 1
99175: PUSH
99176: LD_INT 22
99178: PUSH
99179: LD_OWVAR 2
99183: PUSH
99184: EMPTY
99185: LIST
99186: LIST
99187: PUSH
99188: LD_INT 21
99190: PUSH
99191: LD_INT 3
99193: PUSH
99194: EMPTY
99195: LIST
99196: LIST
99197: PUSH
99198: EMPTY
99199: LIST
99200: LIST
99201: PPUSH
99202: CALL_OW 69
99206: ST_TO_ADDR
// if not tmp then
99207: LD_VAR 0 1
99211: NOT
99212: IFFALSE 99216
// exit ;
99214: GO 99242
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
99216: LD_VAR 0 1
99220: PUSH
99221: LD_INT 1
99223: PPUSH
99224: LD_VAR 0 1
99228: PPUSH
99229: CALL_OW 12
99233: ARRAY
99234: PPUSH
99235: LD_INT 100
99237: PPUSH
99238: CALL_OW 234
// end ;
99242: PPOPN 1
99244: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
99245: LD_EXP 96
99249: PUSH
99250: LD_EXP 110
99254: AND
99255: IFFALSE 99353
99257: GO 99259
99259: DISABLE
99260: LD_INT 0
99262: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
99263: LD_ADDR_VAR 0 1
99267: PUSH
99268: LD_INT 22
99270: PUSH
99271: LD_OWVAR 2
99275: PUSH
99276: EMPTY
99277: LIST
99278: LIST
99279: PUSH
99280: LD_INT 21
99282: PUSH
99283: LD_INT 1
99285: PUSH
99286: EMPTY
99287: LIST
99288: LIST
99289: PUSH
99290: EMPTY
99291: LIST
99292: LIST
99293: PPUSH
99294: CALL_OW 69
99298: ST_TO_ADDR
// if not tmp then
99299: LD_VAR 0 1
99303: NOT
99304: IFFALSE 99308
// exit ;
99306: GO 99353
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
99308: LD_VAR 0 1
99312: PUSH
99313: LD_INT 1
99315: PPUSH
99316: LD_VAR 0 1
99320: PPUSH
99321: CALL_OW 12
99325: ARRAY
99326: PPUSH
99327: LD_INT 1
99329: PPUSH
99330: LD_INT 4
99332: PPUSH
99333: CALL_OW 12
99337: PPUSH
99338: LD_INT 3000
99340: PPUSH
99341: LD_INT 9000
99343: PPUSH
99344: CALL_OW 12
99348: PPUSH
99349: CALL_OW 492
// end ;
99353: PPOPN 1
99355: END
// every 0 0$1 trigger StreamModeActive and sDepot do
99356: LD_EXP 96
99360: PUSH
99361: LD_EXP 111
99365: AND
99366: IFFALSE 99386
99368: GO 99370
99370: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
99371: LD_INT 1
99373: PPUSH
99374: LD_OWVAR 2
99378: PPUSH
99379: LD_INT 0
99381: PPUSH
99382: CALL_OW 324
99386: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
99387: LD_EXP 96
99391: PUSH
99392: LD_EXP 112
99396: AND
99397: IFFALSE 99480
99399: GO 99401
99401: DISABLE
99402: LD_INT 0
99404: PPUSH
99405: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
99406: LD_ADDR_VAR 0 2
99410: PUSH
99411: LD_INT 22
99413: PUSH
99414: LD_OWVAR 2
99418: PUSH
99419: EMPTY
99420: LIST
99421: LIST
99422: PUSH
99423: LD_INT 21
99425: PUSH
99426: LD_INT 3
99428: PUSH
99429: EMPTY
99430: LIST
99431: LIST
99432: PUSH
99433: EMPTY
99434: LIST
99435: LIST
99436: PPUSH
99437: CALL_OW 69
99441: ST_TO_ADDR
// if not tmp then
99442: LD_VAR 0 2
99446: NOT
99447: IFFALSE 99451
// exit ;
99449: GO 99480
// for i in tmp do
99451: LD_ADDR_VAR 0 1
99455: PUSH
99456: LD_VAR 0 2
99460: PUSH
99461: FOR_IN
99462: IFFALSE 99478
// SetBLevel ( i , 10 ) ;
99464: LD_VAR 0 1
99468: PPUSH
99469: LD_INT 10
99471: PPUSH
99472: CALL_OW 241
99476: GO 99461
99478: POP
99479: POP
// end ;
99480: PPOPN 2
99482: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
99483: LD_EXP 96
99487: PUSH
99488: LD_EXP 113
99492: AND
99493: IFFALSE 99604
99495: GO 99497
99497: DISABLE
99498: LD_INT 0
99500: PPUSH
99501: PPUSH
99502: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
99503: LD_ADDR_VAR 0 3
99507: PUSH
99508: LD_INT 22
99510: PUSH
99511: LD_OWVAR 2
99515: PUSH
99516: EMPTY
99517: LIST
99518: LIST
99519: PUSH
99520: LD_INT 25
99522: PUSH
99523: LD_INT 1
99525: PUSH
99526: EMPTY
99527: LIST
99528: LIST
99529: PUSH
99530: EMPTY
99531: LIST
99532: LIST
99533: PPUSH
99534: CALL_OW 69
99538: ST_TO_ADDR
// if not tmp then
99539: LD_VAR 0 3
99543: NOT
99544: IFFALSE 99548
// exit ;
99546: GO 99604
// un := tmp [ rand ( 1 , tmp ) ] ;
99548: LD_ADDR_VAR 0 2
99552: PUSH
99553: LD_VAR 0 3
99557: PUSH
99558: LD_INT 1
99560: PPUSH
99561: LD_VAR 0 3
99565: PPUSH
99566: CALL_OW 12
99570: ARRAY
99571: ST_TO_ADDR
// if Crawls ( un ) then
99572: LD_VAR 0 2
99576: PPUSH
99577: CALL_OW 318
99581: IFFALSE 99592
// ComWalk ( un ) ;
99583: LD_VAR 0 2
99587: PPUSH
99588: CALL_OW 138
// SetClass ( un , class_sniper ) ;
99592: LD_VAR 0 2
99596: PPUSH
99597: LD_INT 5
99599: PPUSH
99600: CALL_OW 336
// end ;
99604: PPOPN 3
99606: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
99607: LD_EXP 96
99611: PUSH
99612: LD_EXP 114
99616: AND
99617: PUSH
99618: LD_OWVAR 67
99622: PUSH
99623: LD_INT 4
99625: LESS
99626: AND
99627: IFFALSE 99646
99629: GO 99631
99631: DISABLE
// begin Difficulty := Difficulty + 1 ;
99632: LD_ADDR_OWVAR 67
99636: PUSH
99637: LD_OWVAR 67
99641: PUSH
99642: LD_INT 1
99644: PLUS
99645: ST_TO_ADDR
// end ;
99646: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
99647: LD_EXP 96
99651: PUSH
99652: LD_EXP 115
99656: AND
99657: IFFALSE 99760
99659: GO 99661
99661: DISABLE
99662: LD_INT 0
99664: PPUSH
// begin for i := 1 to 5 do
99665: LD_ADDR_VAR 0 1
99669: PUSH
99670: DOUBLE
99671: LD_INT 1
99673: DEC
99674: ST_TO_ADDR
99675: LD_INT 5
99677: PUSH
99678: FOR_TO
99679: IFFALSE 99758
// begin uc_nation := nation_nature ;
99681: LD_ADDR_OWVAR 21
99685: PUSH
99686: LD_INT 0
99688: ST_TO_ADDR
// uc_side := 0 ;
99689: LD_ADDR_OWVAR 20
99693: PUSH
99694: LD_INT 0
99696: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
99697: LD_ADDR_OWVAR 29
99701: PUSH
99702: LD_INT 12
99704: PUSH
99705: LD_INT 12
99707: PUSH
99708: EMPTY
99709: LIST
99710: LIST
99711: ST_TO_ADDR
// hc_agressivity := 20 ;
99712: LD_ADDR_OWVAR 35
99716: PUSH
99717: LD_INT 20
99719: ST_TO_ADDR
// hc_class := class_tiger ;
99720: LD_ADDR_OWVAR 28
99724: PUSH
99725: LD_INT 14
99727: ST_TO_ADDR
// hc_gallery :=  ;
99728: LD_ADDR_OWVAR 33
99732: PUSH
99733: LD_STRING 
99735: ST_TO_ADDR
// hc_name :=  ;
99736: LD_ADDR_OWVAR 26
99740: PUSH
99741: LD_STRING 
99743: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
99744: CALL_OW 44
99748: PPUSH
99749: LD_INT 0
99751: PPUSH
99752: CALL_OW 51
// end ;
99756: GO 99678
99758: POP
99759: POP
// end ;
99760: PPOPN 1
99762: END
// every 0 0$1 trigger StreamModeActive and sBomb do
99763: LD_EXP 96
99767: PUSH
99768: LD_EXP 116
99772: AND
99773: IFFALSE 99782
99775: GO 99777
99777: DISABLE
// StreamSibBomb ;
99778: CALL 99783 0 0
99782: END
// export function StreamSibBomb ; var i , x , y ; begin
99783: LD_INT 0
99785: PPUSH
99786: PPUSH
99787: PPUSH
99788: PPUSH
// result := false ;
99789: LD_ADDR_VAR 0 1
99793: PUSH
99794: LD_INT 0
99796: ST_TO_ADDR
// for i := 1 to 16 do
99797: LD_ADDR_VAR 0 2
99801: PUSH
99802: DOUBLE
99803: LD_INT 1
99805: DEC
99806: ST_TO_ADDR
99807: LD_INT 16
99809: PUSH
99810: FOR_TO
99811: IFFALSE 100010
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
99813: LD_ADDR_VAR 0 3
99817: PUSH
99818: LD_INT 10
99820: PUSH
99821: LD_INT 20
99823: PUSH
99824: LD_INT 30
99826: PUSH
99827: LD_INT 40
99829: PUSH
99830: LD_INT 50
99832: PUSH
99833: LD_INT 60
99835: PUSH
99836: LD_INT 70
99838: PUSH
99839: LD_INT 80
99841: PUSH
99842: LD_INT 90
99844: PUSH
99845: LD_INT 100
99847: PUSH
99848: LD_INT 110
99850: PUSH
99851: LD_INT 120
99853: PUSH
99854: LD_INT 130
99856: PUSH
99857: LD_INT 140
99859: PUSH
99860: LD_INT 150
99862: PUSH
99863: EMPTY
99864: LIST
99865: LIST
99866: LIST
99867: LIST
99868: LIST
99869: LIST
99870: LIST
99871: LIST
99872: LIST
99873: LIST
99874: LIST
99875: LIST
99876: LIST
99877: LIST
99878: LIST
99879: PUSH
99880: LD_INT 1
99882: PPUSH
99883: LD_INT 15
99885: PPUSH
99886: CALL_OW 12
99890: ARRAY
99891: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
99892: LD_ADDR_VAR 0 4
99896: PUSH
99897: LD_INT 10
99899: PUSH
99900: LD_INT 20
99902: PUSH
99903: LD_INT 30
99905: PUSH
99906: LD_INT 40
99908: PUSH
99909: LD_INT 50
99911: PUSH
99912: LD_INT 60
99914: PUSH
99915: LD_INT 70
99917: PUSH
99918: LD_INT 80
99920: PUSH
99921: LD_INT 90
99923: PUSH
99924: LD_INT 100
99926: PUSH
99927: LD_INT 110
99929: PUSH
99930: LD_INT 120
99932: PUSH
99933: LD_INT 130
99935: PUSH
99936: LD_INT 140
99938: PUSH
99939: LD_INT 150
99941: PUSH
99942: EMPTY
99943: LIST
99944: LIST
99945: LIST
99946: LIST
99947: LIST
99948: LIST
99949: LIST
99950: LIST
99951: LIST
99952: LIST
99953: LIST
99954: LIST
99955: LIST
99956: LIST
99957: LIST
99958: PUSH
99959: LD_INT 1
99961: PPUSH
99962: LD_INT 15
99964: PPUSH
99965: CALL_OW 12
99969: ARRAY
99970: ST_TO_ADDR
// if ValidHex ( x , y ) then
99971: LD_VAR 0 3
99975: PPUSH
99976: LD_VAR 0 4
99980: PPUSH
99981: CALL_OW 488
99985: IFFALSE 100008
// begin result := [ x , y ] ;
99987: LD_ADDR_VAR 0 1
99991: PUSH
99992: LD_VAR 0 3
99996: PUSH
99997: LD_VAR 0 4
100001: PUSH
100002: EMPTY
100003: LIST
100004: LIST
100005: ST_TO_ADDR
// break ;
100006: GO 100010
// end ; end ;
100008: GO 99810
100010: POP
100011: POP
// if result then
100012: LD_VAR 0 1
100016: IFFALSE 100076
// begin ToLua ( playSibBomb() ) ;
100018: LD_STRING playSibBomb()
100020: PPUSH
100021: CALL_OW 559
// wait ( 0 0$14 ) ;
100025: LD_INT 490
100027: PPUSH
100028: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
100032: LD_VAR 0 1
100036: PUSH
100037: LD_INT 1
100039: ARRAY
100040: PPUSH
100041: LD_VAR 0 1
100045: PUSH
100046: LD_INT 2
100048: ARRAY
100049: PPUSH
100050: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
100054: LD_VAR 0 1
100058: PUSH
100059: LD_INT 1
100061: ARRAY
100062: PPUSH
100063: LD_VAR 0 1
100067: PUSH
100068: LD_INT 2
100070: ARRAY
100071: PPUSH
100072: CALL_OW 429
// end ; end ;
100076: LD_VAR 0 1
100080: RET
// every 0 0$1 trigger StreamModeActive and sReset do
100081: LD_EXP 96
100085: PUSH
100086: LD_EXP 118
100090: AND
100091: IFFALSE 100103
100093: GO 100095
100095: DISABLE
// YouLost (  ) ;
100096: LD_STRING 
100098: PPUSH
100099: CALL_OW 104
100103: END
// every 0 0$1 trigger StreamModeActive and sFog do
100104: LD_EXP 96
100108: PUSH
100109: LD_EXP 117
100113: AND
100114: IFFALSE 100128
100116: GO 100118
100118: DISABLE
// FogOff ( your_side ) ;
100119: LD_OWVAR 2
100123: PPUSH
100124: CALL_OW 344
100128: END
// every 0 0$1 trigger StreamModeActive and sSun do
100129: LD_EXP 96
100133: PUSH
100134: LD_EXP 119
100138: AND
100139: IFFALSE 100167
100141: GO 100143
100143: DISABLE
// begin solar_recharge_percent := 0 ;
100144: LD_ADDR_OWVAR 79
100148: PUSH
100149: LD_INT 0
100151: ST_TO_ADDR
// wait ( 5 5$00 ) ;
100152: LD_INT 10500
100154: PPUSH
100155: CALL_OW 67
// solar_recharge_percent := 100 ;
100159: LD_ADDR_OWVAR 79
100163: PUSH
100164: LD_INT 100
100166: ST_TO_ADDR
// end ;
100167: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
100168: LD_EXP 96
100172: PUSH
100173: LD_EXP 120
100177: AND
100178: IFFALSE 100417
100180: GO 100182
100182: DISABLE
100183: LD_INT 0
100185: PPUSH
100186: PPUSH
100187: PPUSH
// begin tmp := [ ] ;
100188: LD_ADDR_VAR 0 3
100192: PUSH
100193: EMPTY
100194: ST_TO_ADDR
// for i := 1 to 6 do
100195: LD_ADDR_VAR 0 1
100199: PUSH
100200: DOUBLE
100201: LD_INT 1
100203: DEC
100204: ST_TO_ADDR
100205: LD_INT 6
100207: PUSH
100208: FOR_TO
100209: IFFALSE 100314
// begin uc_nation := nation_nature ;
100211: LD_ADDR_OWVAR 21
100215: PUSH
100216: LD_INT 0
100218: ST_TO_ADDR
// uc_side := 0 ;
100219: LD_ADDR_OWVAR 20
100223: PUSH
100224: LD_INT 0
100226: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
100227: LD_ADDR_OWVAR 29
100231: PUSH
100232: LD_INT 12
100234: PUSH
100235: LD_INT 12
100237: PUSH
100238: EMPTY
100239: LIST
100240: LIST
100241: ST_TO_ADDR
// hc_agressivity := 20 ;
100242: LD_ADDR_OWVAR 35
100246: PUSH
100247: LD_INT 20
100249: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
100250: LD_ADDR_OWVAR 28
100254: PUSH
100255: LD_INT 17
100257: ST_TO_ADDR
// hc_gallery :=  ;
100258: LD_ADDR_OWVAR 33
100262: PUSH
100263: LD_STRING 
100265: ST_TO_ADDR
// hc_name :=  ;
100266: LD_ADDR_OWVAR 26
100270: PUSH
100271: LD_STRING 
100273: ST_TO_ADDR
// un := CreateHuman ;
100274: LD_ADDR_VAR 0 2
100278: PUSH
100279: CALL_OW 44
100283: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
100284: LD_VAR 0 2
100288: PPUSH
100289: LD_INT 1
100291: PPUSH
100292: CALL_OW 51
// tmp := tmp ^ un ;
100296: LD_ADDR_VAR 0 3
100300: PUSH
100301: LD_VAR 0 3
100305: PUSH
100306: LD_VAR 0 2
100310: ADD
100311: ST_TO_ADDR
// end ;
100312: GO 100208
100314: POP
100315: POP
// repeat wait ( 0 0$1 ) ;
100316: LD_INT 35
100318: PPUSH
100319: CALL_OW 67
// for un in tmp do
100323: LD_ADDR_VAR 0 2
100327: PUSH
100328: LD_VAR 0 3
100332: PUSH
100333: FOR_IN
100334: IFFALSE 100408
// begin if IsDead ( un ) then
100336: LD_VAR 0 2
100340: PPUSH
100341: CALL_OW 301
100345: IFFALSE 100365
// begin tmp := tmp diff un ;
100347: LD_ADDR_VAR 0 3
100351: PUSH
100352: LD_VAR 0 3
100356: PUSH
100357: LD_VAR 0 2
100361: DIFF
100362: ST_TO_ADDR
// continue ;
100363: GO 100333
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
100365: LD_VAR 0 2
100369: PPUSH
100370: LD_INT 3
100372: PUSH
100373: LD_INT 22
100375: PUSH
100376: LD_INT 0
100378: PUSH
100379: EMPTY
100380: LIST
100381: LIST
100382: PUSH
100383: EMPTY
100384: LIST
100385: LIST
100386: PPUSH
100387: CALL_OW 69
100391: PPUSH
100392: LD_VAR 0 2
100396: PPUSH
100397: CALL_OW 74
100401: PPUSH
100402: CALL_OW 115
// end ;
100406: GO 100333
100408: POP
100409: POP
// until not tmp ;
100410: LD_VAR 0 3
100414: NOT
100415: IFFALSE 100316
// end ;
100417: PPOPN 3
100419: END
// every 0 0$1 trigger StreamModeActive and sTroll do
100420: LD_EXP 96
100424: PUSH
100425: LD_EXP 121
100429: AND
100430: IFFALSE 100484
100432: GO 100434
100434: DISABLE
// begin ToLua ( displayTroll(); ) ;
100435: LD_STRING displayTroll();
100437: PPUSH
100438: CALL_OW 559
// wait ( 3 3$00 ) ;
100442: LD_INT 6300
100444: PPUSH
100445: CALL_OW 67
// ToLua ( hideTroll(); ) ;
100449: LD_STRING hideTroll();
100451: PPUSH
100452: CALL_OW 559
// wait ( 1 1$00 ) ;
100456: LD_INT 2100
100458: PPUSH
100459: CALL_OW 67
// ToLua ( displayTroll(); ) ;
100463: LD_STRING displayTroll();
100465: PPUSH
100466: CALL_OW 559
// wait ( 1 1$00 ) ;
100470: LD_INT 2100
100472: PPUSH
100473: CALL_OW 67
// ToLua ( hideTroll(); ) ;
100477: LD_STRING hideTroll();
100479: PPUSH
100480: CALL_OW 559
// end ;
100484: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
100485: LD_EXP 96
100489: PUSH
100490: LD_EXP 122
100494: AND
100495: IFFALSE 100558
100497: GO 100499
100499: DISABLE
100500: LD_INT 0
100502: PPUSH
// begin p := 0 ;
100503: LD_ADDR_VAR 0 1
100507: PUSH
100508: LD_INT 0
100510: ST_TO_ADDR
// repeat game_speed := 1 ;
100511: LD_ADDR_OWVAR 65
100515: PUSH
100516: LD_INT 1
100518: ST_TO_ADDR
// wait ( 0 0$1 ) ;
100519: LD_INT 35
100521: PPUSH
100522: CALL_OW 67
// p := p + 1 ;
100526: LD_ADDR_VAR 0 1
100530: PUSH
100531: LD_VAR 0 1
100535: PUSH
100536: LD_INT 1
100538: PLUS
100539: ST_TO_ADDR
// until p >= 60 ;
100540: LD_VAR 0 1
100544: PUSH
100545: LD_INT 60
100547: GREATEREQUAL
100548: IFFALSE 100511
// game_speed := 4 ;
100550: LD_ADDR_OWVAR 65
100554: PUSH
100555: LD_INT 4
100557: ST_TO_ADDR
// end ;
100558: PPOPN 1
100560: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
100561: LD_EXP 96
100565: PUSH
100566: LD_EXP 123
100570: AND
100571: IFFALSE 100717
100573: GO 100575
100575: DISABLE
100576: LD_INT 0
100578: PPUSH
100579: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
100580: LD_ADDR_VAR 0 1
100584: PUSH
100585: LD_INT 22
100587: PUSH
100588: LD_OWVAR 2
100592: PUSH
100593: EMPTY
100594: LIST
100595: LIST
100596: PUSH
100597: LD_INT 2
100599: PUSH
100600: LD_INT 30
100602: PUSH
100603: LD_INT 0
100605: PUSH
100606: EMPTY
100607: LIST
100608: LIST
100609: PUSH
100610: LD_INT 30
100612: PUSH
100613: LD_INT 1
100615: PUSH
100616: EMPTY
100617: LIST
100618: LIST
100619: PUSH
100620: EMPTY
100621: LIST
100622: LIST
100623: LIST
100624: PUSH
100625: EMPTY
100626: LIST
100627: LIST
100628: PPUSH
100629: CALL_OW 69
100633: ST_TO_ADDR
// if not depot then
100634: LD_VAR 0 1
100638: NOT
100639: IFFALSE 100643
// exit ;
100641: GO 100717
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
100643: LD_ADDR_VAR 0 2
100647: PUSH
100648: LD_VAR 0 1
100652: PUSH
100653: LD_INT 1
100655: PPUSH
100656: LD_VAR 0 1
100660: PPUSH
100661: CALL_OW 12
100665: ARRAY
100666: PPUSH
100667: CALL_OW 274
100671: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
100672: LD_VAR 0 2
100676: PPUSH
100677: LD_INT 1
100679: PPUSH
100680: LD_INT 0
100682: PPUSH
100683: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
100687: LD_VAR 0 2
100691: PPUSH
100692: LD_INT 2
100694: PPUSH
100695: LD_INT 0
100697: PPUSH
100698: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
100702: LD_VAR 0 2
100706: PPUSH
100707: LD_INT 3
100709: PPUSH
100710: LD_INT 0
100712: PPUSH
100713: CALL_OW 277
// end ;
100717: PPOPN 2
100719: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
100720: LD_EXP 96
100724: PUSH
100725: LD_EXP 124
100729: AND
100730: IFFALSE 100827
100732: GO 100734
100734: DISABLE
100735: LD_INT 0
100737: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
100738: LD_ADDR_VAR 0 1
100742: PUSH
100743: LD_INT 22
100745: PUSH
100746: LD_OWVAR 2
100750: PUSH
100751: EMPTY
100752: LIST
100753: LIST
100754: PUSH
100755: LD_INT 21
100757: PUSH
100758: LD_INT 1
100760: PUSH
100761: EMPTY
100762: LIST
100763: LIST
100764: PUSH
100765: LD_INT 3
100767: PUSH
100768: LD_INT 23
100770: PUSH
100771: LD_INT 0
100773: PUSH
100774: EMPTY
100775: LIST
100776: LIST
100777: PUSH
100778: EMPTY
100779: LIST
100780: LIST
100781: PUSH
100782: EMPTY
100783: LIST
100784: LIST
100785: LIST
100786: PPUSH
100787: CALL_OW 69
100791: ST_TO_ADDR
// if not tmp then
100792: LD_VAR 0 1
100796: NOT
100797: IFFALSE 100801
// exit ;
100799: GO 100827
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
100801: LD_VAR 0 1
100805: PUSH
100806: LD_INT 1
100808: PPUSH
100809: LD_VAR 0 1
100813: PPUSH
100814: CALL_OW 12
100818: ARRAY
100819: PPUSH
100820: LD_INT 200
100822: PPUSH
100823: CALL_OW 234
// end ;
100827: PPOPN 1
100829: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
100830: LD_EXP 96
100834: PUSH
100835: LD_EXP 125
100839: AND
100840: IFFALSE 100919
100842: GO 100844
100844: DISABLE
100845: LD_INT 0
100847: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
100848: LD_ADDR_VAR 0 1
100852: PUSH
100853: LD_INT 22
100855: PUSH
100856: LD_OWVAR 2
100860: PUSH
100861: EMPTY
100862: LIST
100863: LIST
100864: PUSH
100865: LD_INT 21
100867: PUSH
100868: LD_INT 2
100870: PUSH
100871: EMPTY
100872: LIST
100873: LIST
100874: PUSH
100875: EMPTY
100876: LIST
100877: LIST
100878: PPUSH
100879: CALL_OW 69
100883: ST_TO_ADDR
// if not tmp then
100884: LD_VAR 0 1
100888: NOT
100889: IFFALSE 100893
// exit ;
100891: GO 100919
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
100893: LD_VAR 0 1
100897: PUSH
100898: LD_INT 1
100900: PPUSH
100901: LD_VAR 0 1
100905: PPUSH
100906: CALL_OW 12
100910: ARRAY
100911: PPUSH
100912: LD_INT 60
100914: PPUSH
100915: CALL_OW 234
// end ;
100919: PPOPN 1
100921: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
100922: LD_EXP 96
100926: PUSH
100927: LD_EXP 126
100931: AND
100932: IFFALSE 101031
100934: GO 100936
100936: DISABLE
100937: LD_INT 0
100939: PPUSH
100940: PPUSH
// begin enable ;
100941: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
100942: LD_ADDR_VAR 0 1
100946: PUSH
100947: LD_INT 22
100949: PUSH
100950: LD_OWVAR 2
100954: PUSH
100955: EMPTY
100956: LIST
100957: LIST
100958: PUSH
100959: LD_INT 61
100961: PUSH
100962: EMPTY
100963: LIST
100964: PUSH
100965: LD_INT 33
100967: PUSH
100968: LD_INT 2
100970: PUSH
100971: EMPTY
100972: LIST
100973: LIST
100974: PUSH
100975: EMPTY
100976: LIST
100977: LIST
100978: LIST
100979: PPUSH
100980: CALL_OW 69
100984: ST_TO_ADDR
// if not tmp then
100985: LD_VAR 0 1
100989: NOT
100990: IFFALSE 100994
// exit ;
100992: GO 101031
// for i in tmp do
100994: LD_ADDR_VAR 0 2
100998: PUSH
100999: LD_VAR 0 1
101003: PUSH
101004: FOR_IN
101005: IFFALSE 101029
// if IsControledBy ( i ) then
101007: LD_VAR 0 2
101011: PPUSH
101012: CALL_OW 312
101016: IFFALSE 101027
// ComUnlink ( i ) ;
101018: LD_VAR 0 2
101022: PPUSH
101023: CALL_OW 136
101027: GO 101004
101029: POP
101030: POP
// end ;
101031: PPOPN 2
101033: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
101034: LD_EXP 96
101038: PUSH
101039: LD_EXP 127
101043: AND
101044: IFFALSE 101184
101046: GO 101048
101048: DISABLE
101049: LD_INT 0
101051: PPUSH
101052: PPUSH
// begin ToLua ( displayPowell(); ) ;
101053: LD_STRING displayPowell();
101055: PPUSH
101056: CALL_OW 559
// uc_side := 0 ;
101060: LD_ADDR_OWVAR 20
101064: PUSH
101065: LD_INT 0
101067: ST_TO_ADDR
// uc_nation := 2 ;
101068: LD_ADDR_OWVAR 21
101072: PUSH
101073: LD_INT 2
101075: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
101076: LD_ADDR_OWVAR 37
101080: PUSH
101081: LD_INT 14
101083: ST_TO_ADDR
// vc_engine := engine_siberite ;
101084: LD_ADDR_OWVAR 39
101088: PUSH
101089: LD_INT 3
101091: ST_TO_ADDR
// vc_control := control_apeman ;
101092: LD_ADDR_OWVAR 38
101096: PUSH
101097: LD_INT 5
101099: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
101100: LD_ADDR_OWVAR 40
101104: PUSH
101105: LD_INT 29
101107: ST_TO_ADDR
// un := CreateVehicle ;
101108: LD_ADDR_VAR 0 2
101112: PUSH
101113: CALL_OW 45
101117: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
101118: LD_VAR 0 2
101122: PPUSH
101123: LD_INT 1
101125: PPUSH
101126: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
101130: LD_INT 35
101132: PPUSH
101133: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
101137: LD_VAR 0 2
101141: PPUSH
101142: LD_INT 22
101144: PUSH
101145: LD_OWVAR 2
101149: PUSH
101150: EMPTY
101151: LIST
101152: LIST
101153: PPUSH
101154: CALL_OW 69
101158: PPUSH
101159: LD_VAR 0 2
101163: PPUSH
101164: CALL_OW 74
101168: PPUSH
101169: CALL_OW 115
// until IsDead ( un ) ;
101173: LD_VAR 0 2
101177: PPUSH
101178: CALL_OW 301
101182: IFFALSE 101130
// end ;
101184: PPOPN 2
101186: END
// every 0 0$1 trigger StreamModeActive and sStu do
101187: LD_EXP 96
101191: PUSH
101192: LD_EXP 135
101196: AND
101197: IFFALSE 101213
101199: GO 101201
101201: DISABLE
// begin ToLua ( displayStucuk(); ) ;
101202: LD_STRING displayStucuk();
101204: PPUSH
101205: CALL_OW 559
// ResetFog ;
101209: CALL_OW 335
// end ;
101213: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
101214: LD_EXP 96
101218: PUSH
101219: LD_EXP 128
101223: AND
101224: IFFALSE 101365
101226: GO 101228
101228: DISABLE
101229: LD_INT 0
101231: PPUSH
101232: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
101233: LD_ADDR_VAR 0 2
101237: PUSH
101238: LD_INT 22
101240: PUSH
101241: LD_OWVAR 2
101245: PUSH
101246: EMPTY
101247: LIST
101248: LIST
101249: PUSH
101250: LD_INT 21
101252: PUSH
101253: LD_INT 1
101255: PUSH
101256: EMPTY
101257: LIST
101258: LIST
101259: PUSH
101260: EMPTY
101261: LIST
101262: LIST
101263: PPUSH
101264: CALL_OW 69
101268: ST_TO_ADDR
// if not tmp then
101269: LD_VAR 0 2
101273: NOT
101274: IFFALSE 101278
// exit ;
101276: GO 101365
// un := tmp [ rand ( 1 , tmp ) ] ;
101278: LD_ADDR_VAR 0 1
101282: PUSH
101283: LD_VAR 0 2
101287: PUSH
101288: LD_INT 1
101290: PPUSH
101291: LD_VAR 0 2
101295: PPUSH
101296: CALL_OW 12
101300: ARRAY
101301: ST_TO_ADDR
// SetSide ( un , 0 ) ;
101302: LD_VAR 0 1
101306: PPUSH
101307: LD_INT 0
101309: PPUSH
101310: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
101314: LD_VAR 0 1
101318: PPUSH
101319: LD_OWVAR 3
101323: PUSH
101324: LD_VAR 0 1
101328: DIFF
101329: PPUSH
101330: LD_VAR 0 1
101334: PPUSH
101335: CALL_OW 74
101339: PPUSH
101340: CALL_OW 115
// wait ( 0 0$20 ) ;
101344: LD_INT 700
101346: PPUSH
101347: CALL_OW 67
// SetSide ( un , your_side ) ;
101351: LD_VAR 0 1
101355: PPUSH
101356: LD_OWVAR 2
101360: PPUSH
101361: CALL_OW 235
// end ;
101365: PPOPN 2
101367: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
101368: LD_EXP 96
101372: PUSH
101373: LD_EXP 129
101377: AND
101378: IFFALSE 101484
101380: GO 101382
101382: DISABLE
101383: LD_INT 0
101385: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
101386: LD_ADDR_VAR 0 1
101390: PUSH
101391: LD_INT 22
101393: PUSH
101394: LD_OWVAR 2
101398: PUSH
101399: EMPTY
101400: LIST
101401: LIST
101402: PUSH
101403: LD_INT 2
101405: PUSH
101406: LD_INT 30
101408: PUSH
101409: LD_INT 0
101411: PUSH
101412: EMPTY
101413: LIST
101414: LIST
101415: PUSH
101416: LD_INT 30
101418: PUSH
101419: LD_INT 1
101421: PUSH
101422: EMPTY
101423: LIST
101424: LIST
101425: PUSH
101426: EMPTY
101427: LIST
101428: LIST
101429: LIST
101430: PUSH
101431: EMPTY
101432: LIST
101433: LIST
101434: PPUSH
101435: CALL_OW 69
101439: ST_TO_ADDR
// if not depot then
101440: LD_VAR 0 1
101444: NOT
101445: IFFALSE 101449
// exit ;
101447: GO 101484
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
101449: LD_VAR 0 1
101453: PUSH
101454: LD_INT 1
101456: ARRAY
101457: PPUSH
101458: CALL_OW 250
101462: PPUSH
101463: LD_VAR 0 1
101467: PUSH
101468: LD_INT 1
101470: ARRAY
101471: PPUSH
101472: CALL_OW 251
101476: PPUSH
101477: LD_INT 70
101479: PPUSH
101480: CALL_OW 495
// end ;
101484: PPOPN 1
101486: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
101487: LD_EXP 96
101491: PUSH
101492: LD_EXP 130
101496: AND
101497: IFFALSE 101708
101499: GO 101501
101501: DISABLE
101502: LD_INT 0
101504: PPUSH
101505: PPUSH
101506: PPUSH
101507: PPUSH
101508: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
101509: LD_ADDR_VAR 0 5
101513: PUSH
101514: LD_INT 22
101516: PUSH
101517: LD_OWVAR 2
101521: PUSH
101522: EMPTY
101523: LIST
101524: LIST
101525: PUSH
101526: LD_INT 21
101528: PUSH
101529: LD_INT 1
101531: PUSH
101532: EMPTY
101533: LIST
101534: LIST
101535: PUSH
101536: EMPTY
101537: LIST
101538: LIST
101539: PPUSH
101540: CALL_OW 69
101544: ST_TO_ADDR
// if not tmp then
101545: LD_VAR 0 5
101549: NOT
101550: IFFALSE 101554
// exit ;
101552: GO 101708
// for i in tmp do
101554: LD_ADDR_VAR 0 1
101558: PUSH
101559: LD_VAR 0 5
101563: PUSH
101564: FOR_IN
101565: IFFALSE 101706
// begin d := rand ( 0 , 5 ) ;
101567: LD_ADDR_VAR 0 4
101571: PUSH
101572: LD_INT 0
101574: PPUSH
101575: LD_INT 5
101577: PPUSH
101578: CALL_OW 12
101582: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
101583: LD_ADDR_VAR 0 2
101587: PUSH
101588: LD_VAR 0 1
101592: PPUSH
101593: CALL_OW 250
101597: PPUSH
101598: LD_VAR 0 4
101602: PPUSH
101603: LD_INT 3
101605: PPUSH
101606: LD_INT 12
101608: PPUSH
101609: CALL_OW 12
101613: PPUSH
101614: CALL_OW 272
101618: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
101619: LD_ADDR_VAR 0 3
101623: PUSH
101624: LD_VAR 0 1
101628: PPUSH
101629: CALL_OW 251
101633: PPUSH
101634: LD_VAR 0 4
101638: PPUSH
101639: LD_INT 3
101641: PPUSH
101642: LD_INT 12
101644: PPUSH
101645: CALL_OW 12
101649: PPUSH
101650: CALL_OW 273
101654: ST_TO_ADDR
// if ValidHex ( x , y ) then
101655: LD_VAR 0 2
101659: PPUSH
101660: LD_VAR 0 3
101664: PPUSH
101665: CALL_OW 488
101669: IFFALSE 101704
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
101671: LD_VAR 0 1
101675: PPUSH
101676: LD_VAR 0 2
101680: PPUSH
101681: LD_VAR 0 3
101685: PPUSH
101686: LD_INT 3
101688: PPUSH
101689: LD_INT 6
101691: PPUSH
101692: CALL_OW 12
101696: PPUSH
101697: LD_INT 1
101699: PPUSH
101700: CALL_OW 483
// end ;
101704: GO 101564
101706: POP
101707: POP
// end ;
101708: PPOPN 5
101710: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
101711: LD_EXP 96
101715: PUSH
101716: LD_EXP 131
101720: AND
101721: IFFALSE 101815
101723: GO 101725
101725: DISABLE
101726: LD_INT 0
101728: PPUSH
101729: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
101730: LD_ADDR_VAR 0 2
101734: PUSH
101735: LD_INT 22
101737: PUSH
101738: LD_OWVAR 2
101742: PUSH
101743: EMPTY
101744: LIST
101745: LIST
101746: PUSH
101747: LD_INT 32
101749: PUSH
101750: LD_INT 1
101752: PUSH
101753: EMPTY
101754: LIST
101755: LIST
101756: PUSH
101757: LD_INT 21
101759: PUSH
101760: LD_INT 2
101762: PUSH
101763: EMPTY
101764: LIST
101765: LIST
101766: PUSH
101767: EMPTY
101768: LIST
101769: LIST
101770: LIST
101771: PPUSH
101772: CALL_OW 69
101776: ST_TO_ADDR
// if not tmp then
101777: LD_VAR 0 2
101781: NOT
101782: IFFALSE 101786
// exit ;
101784: GO 101815
// for i in tmp do
101786: LD_ADDR_VAR 0 1
101790: PUSH
101791: LD_VAR 0 2
101795: PUSH
101796: FOR_IN
101797: IFFALSE 101813
// SetFuel ( i , 0 ) ;
101799: LD_VAR 0 1
101803: PPUSH
101804: LD_INT 0
101806: PPUSH
101807: CALL_OW 240
101811: GO 101796
101813: POP
101814: POP
// end ;
101815: PPOPN 2
101817: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
101818: LD_EXP 96
101822: PUSH
101823: LD_EXP 132
101827: AND
101828: IFFALSE 101894
101830: GO 101832
101832: DISABLE
101833: LD_INT 0
101835: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
101836: LD_ADDR_VAR 0 1
101840: PUSH
101841: LD_INT 22
101843: PUSH
101844: LD_OWVAR 2
101848: PUSH
101849: EMPTY
101850: LIST
101851: LIST
101852: PUSH
101853: LD_INT 30
101855: PUSH
101856: LD_INT 29
101858: PUSH
101859: EMPTY
101860: LIST
101861: LIST
101862: PUSH
101863: EMPTY
101864: LIST
101865: LIST
101866: PPUSH
101867: CALL_OW 69
101871: ST_TO_ADDR
// if not tmp then
101872: LD_VAR 0 1
101876: NOT
101877: IFFALSE 101881
// exit ;
101879: GO 101894
// DestroyUnit ( tmp [ 1 ] ) ;
101881: LD_VAR 0 1
101885: PUSH
101886: LD_INT 1
101888: ARRAY
101889: PPUSH
101890: CALL_OW 65
// end ;
101894: PPOPN 1
101896: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
101897: LD_EXP 96
101901: PUSH
101902: LD_EXP 134
101906: AND
101907: IFFALSE 102036
101909: GO 101911
101911: DISABLE
101912: LD_INT 0
101914: PPUSH
// begin uc_side := 0 ;
101915: LD_ADDR_OWVAR 20
101919: PUSH
101920: LD_INT 0
101922: ST_TO_ADDR
// uc_nation := nation_arabian ;
101923: LD_ADDR_OWVAR 21
101927: PUSH
101928: LD_INT 2
101930: ST_TO_ADDR
// hc_gallery :=  ;
101931: LD_ADDR_OWVAR 33
101935: PUSH
101936: LD_STRING 
101938: ST_TO_ADDR
// hc_name :=  ;
101939: LD_ADDR_OWVAR 26
101943: PUSH
101944: LD_STRING 
101946: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
101947: LD_INT 1
101949: PPUSH
101950: LD_INT 11
101952: PPUSH
101953: LD_INT 10
101955: PPUSH
101956: CALL_OW 380
// un := CreateHuman ;
101960: LD_ADDR_VAR 0 1
101964: PUSH
101965: CALL_OW 44
101969: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
101970: LD_VAR 0 1
101974: PPUSH
101975: LD_INT 1
101977: PPUSH
101978: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
101982: LD_INT 35
101984: PPUSH
101985: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
101989: LD_VAR 0 1
101993: PPUSH
101994: LD_INT 22
101996: PUSH
101997: LD_OWVAR 2
102001: PUSH
102002: EMPTY
102003: LIST
102004: LIST
102005: PPUSH
102006: CALL_OW 69
102010: PPUSH
102011: LD_VAR 0 1
102015: PPUSH
102016: CALL_OW 74
102020: PPUSH
102021: CALL_OW 115
// until IsDead ( un ) ;
102025: LD_VAR 0 1
102029: PPUSH
102030: CALL_OW 301
102034: IFFALSE 101982
// end ;
102036: PPOPN 1
102038: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
102039: LD_EXP 96
102043: PUSH
102044: LD_EXP 136
102048: AND
102049: IFFALSE 102061
102051: GO 102053
102053: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
102054: LD_STRING earthquake(getX(game), 0, 32)
102056: PPUSH
102057: CALL_OW 559
102061: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
102062: LD_EXP 96
102066: PUSH
102067: LD_EXP 137
102071: AND
102072: IFFALSE 102163
102074: GO 102076
102076: DISABLE
102077: LD_INT 0
102079: PPUSH
// begin enable ;
102080: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
102081: LD_ADDR_VAR 0 1
102085: PUSH
102086: LD_INT 22
102088: PUSH
102089: LD_OWVAR 2
102093: PUSH
102094: EMPTY
102095: LIST
102096: LIST
102097: PUSH
102098: LD_INT 21
102100: PUSH
102101: LD_INT 2
102103: PUSH
102104: EMPTY
102105: LIST
102106: LIST
102107: PUSH
102108: LD_INT 33
102110: PUSH
102111: LD_INT 3
102113: PUSH
102114: EMPTY
102115: LIST
102116: LIST
102117: PUSH
102118: EMPTY
102119: LIST
102120: LIST
102121: LIST
102122: PPUSH
102123: CALL_OW 69
102127: ST_TO_ADDR
// if not tmp then
102128: LD_VAR 0 1
102132: NOT
102133: IFFALSE 102137
// exit ;
102135: GO 102163
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
102137: LD_VAR 0 1
102141: PUSH
102142: LD_INT 1
102144: PPUSH
102145: LD_VAR 0 1
102149: PPUSH
102150: CALL_OW 12
102154: ARRAY
102155: PPUSH
102156: LD_INT 1
102158: PPUSH
102159: CALL_OW 234
// end ;
102163: PPOPN 1
102165: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
102166: LD_EXP 96
102170: PUSH
102171: LD_EXP 138
102175: AND
102176: IFFALSE 102317
102178: GO 102180
102180: DISABLE
102181: LD_INT 0
102183: PPUSH
102184: PPUSH
102185: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102186: LD_ADDR_VAR 0 3
102190: PUSH
102191: LD_INT 22
102193: PUSH
102194: LD_OWVAR 2
102198: PUSH
102199: EMPTY
102200: LIST
102201: LIST
102202: PUSH
102203: LD_INT 25
102205: PUSH
102206: LD_INT 1
102208: PUSH
102209: EMPTY
102210: LIST
102211: LIST
102212: PUSH
102213: EMPTY
102214: LIST
102215: LIST
102216: PPUSH
102217: CALL_OW 69
102221: ST_TO_ADDR
// if not tmp then
102222: LD_VAR 0 3
102226: NOT
102227: IFFALSE 102231
// exit ;
102229: GO 102317
// un := tmp [ rand ( 1 , tmp ) ] ;
102231: LD_ADDR_VAR 0 2
102235: PUSH
102236: LD_VAR 0 3
102240: PUSH
102241: LD_INT 1
102243: PPUSH
102244: LD_VAR 0 3
102248: PPUSH
102249: CALL_OW 12
102253: ARRAY
102254: ST_TO_ADDR
// if Crawls ( un ) then
102255: LD_VAR 0 2
102259: PPUSH
102260: CALL_OW 318
102264: IFFALSE 102275
// ComWalk ( un ) ;
102266: LD_VAR 0 2
102270: PPUSH
102271: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
102275: LD_VAR 0 2
102279: PPUSH
102280: LD_INT 9
102282: PPUSH
102283: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
102287: LD_INT 28
102289: PPUSH
102290: LD_OWVAR 2
102294: PPUSH
102295: LD_INT 2
102297: PPUSH
102298: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
102302: LD_INT 29
102304: PPUSH
102305: LD_OWVAR 2
102309: PPUSH
102310: LD_INT 2
102312: PPUSH
102313: CALL_OW 322
// end ;
102317: PPOPN 3
102319: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
102320: LD_EXP 96
102324: PUSH
102325: LD_EXP 139
102329: AND
102330: IFFALSE 102441
102332: GO 102334
102334: DISABLE
102335: LD_INT 0
102337: PPUSH
102338: PPUSH
102339: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102340: LD_ADDR_VAR 0 3
102344: PUSH
102345: LD_INT 22
102347: PUSH
102348: LD_OWVAR 2
102352: PUSH
102353: EMPTY
102354: LIST
102355: LIST
102356: PUSH
102357: LD_INT 25
102359: PUSH
102360: LD_INT 1
102362: PUSH
102363: EMPTY
102364: LIST
102365: LIST
102366: PUSH
102367: EMPTY
102368: LIST
102369: LIST
102370: PPUSH
102371: CALL_OW 69
102375: ST_TO_ADDR
// if not tmp then
102376: LD_VAR 0 3
102380: NOT
102381: IFFALSE 102385
// exit ;
102383: GO 102441
// un := tmp [ rand ( 1 , tmp ) ] ;
102385: LD_ADDR_VAR 0 2
102389: PUSH
102390: LD_VAR 0 3
102394: PUSH
102395: LD_INT 1
102397: PPUSH
102398: LD_VAR 0 3
102402: PPUSH
102403: CALL_OW 12
102407: ARRAY
102408: ST_TO_ADDR
// if Crawls ( un ) then
102409: LD_VAR 0 2
102413: PPUSH
102414: CALL_OW 318
102418: IFFALSE 102429
// ComWalk ( un ) ;
102420: LD_VAR 0 2
102424: PPUSH
102425: CALL_OW 138
// SetClass ( un , class_mortar ) ;
102429: LD_VAR 0 2
102433: PPUSH
102434: LD_INT 8
102436: PPUSH
102437: CALL_OW 336
// end ;
102441: PPOPN 3
102443: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
102444: LD_EXP 96
102448: PUSH
102449: LD_EXP 140
102453: AND
102454: IFFALSE 102598
102456: GO 102458
102458: DISABLE
102459: LD_INT 0
102461: PPUSH
102462: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
102463: LD_ADDR_VAR 0 2
102467: PUSH
102468: LD_INT 22
102470: PUSH
102471: LD_OWVAR 2
102475: PUSH
102476: EMPTY
102477: LIST
102478: LIST
102479: PUSH
102480: LD_INT 21
102482: PUSH
102483: LD_INT 2
102485: PUSH
102486: EMPTY
102487: LIST
102488: LIST
102489: PUSH
102490: LD_INT 2
102492: PUSH
102493: LD_INT 34
102495: PUSH
102496: LD_INT 12
102498: PUSH
102499: EMPTY
102500: LIST
102501: LIST
102502: PUSH
102503: LD_INT 34
102505: PUSH
102506: LD_INT 51
102508: PUSH
102509: EMPTY
102510: LIST
102511: LIST
102512: PUSH
102513: LD_INT 34
102515: PUSH
102516: LD_INT 32
102518: PUSH
102519: EMPTY
102520: LIST
102521: LIST
102522: PUSH
102523: EMPTY
102524: LIST
102525: LIST
102526: LIST
102527: LIST
102528: PUSH
102529: EMPTY
102530: LIST
102531: LIST
102532: LIST
102533: PPUSH
102534: CALL_OW 69
102538: ST_TO_ADDR
// if not tmp then
102539: LD_VAR 0 2
102543: NOT
102544: IFFALSE 102548
// exit ;
102546: GO 102598
// for i in tmp do
102548: LD_ADDR_VAR 0 1
102552: PUSH
102553: LD_VAR 0 2
102557: PUSH
102558: FOR_IN
102559: IFFALSE 102596
// if GetCargo ( i , mat_artifact ) = 0 then
102561: LD_VAR 0 1
102565: PPUSH
102566: LD_INT 4
102568: PPUSH
102569: CALL_OW 289
102573: PUSH
102574: LD_INT 0
102576: EQUAL
102577: IFFALSE 102594
// SetCargo ( i , mat_siberit , 100 ) ;
102579: LD_VAR 0 1
102583: PPUSH
102584: LD_INT 3
102586: PPUSH
102587: LD_INT 100
102589: PPUSH
102590: CALL_OW 290
102594: GO 102558
102596: POP
102597: POP
// end ;
102598: PPOPN 2
102600: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
102601: LD_EXP 96
102605: PUSH
102606: LD_EXP 141
102610: AND
102611: IFFALSE 102794
102613: GO 102615
102615: DISABLE
102616: LD_INT 0
102618: PPUSH
102619: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
102620: LD_ADDR_VAR 0 2
102624: PUSH
102625: LD_INT 22
102627: PUSH
102628: LD_OWVAR 2
102632: PUSH
102633: EMPTY
102634: LIST
102635: LIST
102636: PPUSH
102637: CALL_OW 69
102641: ST_TO_ADDR
// if not tmp then
102642: LD_VAR 0 2
102646: NOT
102647: IFFALSE 102651
// exit ;
102649: GO 102794
// for i := 1 to 2 do
102651: LD_ADDR_VAR 0 1
102655: PUSH
102656: DOUBLE
102657: LD_INT 1
102659: DEC
102660: ST_TO_ADDR
102661: LD_INT 2
102663: PUSH
102664: FOR_TO
102665: IFFALSE 102792
// begin uc_side := your_side ;
102667: LD_ADDR_OWVAR 20
102671: PUSH
102672: LD_OWVAR 2
102676: ST_TO_ADDR
// uc_nation := nation_american ;
102677: LD_ADDR_OWVAR 21
102681: PUSH
102682: LD_INT 1
102684: ST_TO_ADDR
// vc_chassis := us_morphling ;
102685: LD_ADDR_OWVAR 37
102689: PUSH
102690: LD_INT 5
102692: ST_TO_ADDR
// vc_engine := engine_siberite ;
102693: LD_ADDR_OWVAR 39
102697: PUSH
102698: LD_INT 3
102700: ST_TO_ADDR
// vc_control := control_computer ;
102701: LD_ADDR_OWVAR 38
102705: PUSH
102706: LD_INT 3
102708: ST_TO_ADDR
// vc_weapon := us_double_laser ;
102709: LD_ADDR_OWVAR 40
102713: PUSH
102714: LD_INT 10
102716: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
102717: LD_VAR 0 2
102721: PUSH
102722: LD_INT 1
102724: ARRAY
102725: PPUSH
102726: CALL_OW 310
102730: NOT
102731: IFFALSE 102778
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
102733: CALL_OW 45
102737: PPUSH
102738: LD_VAR 0 2
102742: PUSH
102743: LD_INT 1
102745: ARRAY
102746: PPUSH
102747: CALL_OW 250
102751: PPUSH
102752: LD_VAR 0 2
102756: PUSH
102757: LD_INT 1
102759: ARRAY
102760: PPUSH
102761: CALL_OW 251
102765: PPUSH
102766: LD_INT 12
102768: PPUSH
102769: LD_INT 1
102771: PPUSH
102772: CALL_OW 50
102776: GO 102790
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
102778: CALL_OW 45
102782: PPUSH
102783: LD_INT 1
102785: PPUSH
102786: CALL_OW 51
// end ;
102790: GO 102664
102792: POP
102793: POP
// end ;
102794: PPOPN 2
102796: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
102797: LD_EXP 96
102801: PUSH
102802: LD_EXP 142
102806: AND
102807: IFFALSE 103029
102809: GO 102811
102811: DISABLE
102812: LD_INT 0
102814: PPUSH
102815: PPUSH
102816: PPUSH
102817: PPUSH
102818: PPUSH
102819: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
102820: LD_ADDR_VAR 0 6
102824: PUSH
102825: LD_INT 22
102827: PUSH
102828: LD_OWVAR 2
102832: PUSH
102833: EMPTY
102834: LIST
102835: LIST
102836: PUSH
102837: LD_INT 21
102839: PUSH
102840: LD_INT 1
102842: PUSH
102843: EMPTY
102844: LIST
102845: LIST
102846: PUSH
102847: LD_INT 3
102849: PUSH
102850: LD_INT 23
102852: PUSH
102853: LD_INT 0
102855: PUSH
102856: EMPTY
102857: LIST
102858: LIST
102859: PUSH
102860: EMPTY
102861: LIST
102862: LIST
102863: PUSH
102864: EMPTY
102865: LIST
102866: LIST
102867: LIST
102868: PPUSH
102869: CALL_OW 69
102873: ST_TO_ADDR
// if not tmp then
102874: LD_VAR 0 6
102878: NOT
102879: IFFALSE 102883
// exit ;
102881: GO 103029
// s1 := rand ( 1 , 4 ) ;
102883: LD_ADDR_VAR 0 2
102887: PUSH
102888: LD_INT 1
102890: PPUSH
102891: LD_INT 4
102893: PPUSH
102894: CALL_OW 12
102898: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
102899: LD_ADDR_VAR 0 4
102903: PUSH
102904: LD_VAR 0 6
102908: PUSH
102909: LD_INT 1
102911: ARRAY
102912: PPUSH
102913: LD_VAR 0 2
102917: PPUSH
102918: CALL_OW 259
102922: ST_TO_ADDR
// if s1 = 1 then
102923: LD_VAR 0 2
102927: PUSH
102928: LD_INT 1
102930: EQUAL
102931: IFFALSE 102951
// s2 := rand ( 2 , 4 ) else
102933: LD_ADDR_VAR 0 3
102937: PUSH
102938: LD_INT 2
102940: PPUSH
102941: LD_INT 4
102943: PPUSH
102944: CALL_OW 12
102948: ST_TO_ADDR
102949: GO 102959
// s2 := 1 ;
102951: LD_ADDR_VAR 0 3
102955: PUSH
102956: LD_INT 1
102958: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
102959: LD_ADDR_VAR 0 5
102963: PUSH
102964: LD_VAR 0 6
102968: PUSH
102969: LD_INT 1
102971: ARRAY
102972: PPUSH
102973: LD_VAR 0 3
102977: PPUSH
102978: CALL_OW 259
102982: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
102983: LD_VAR 0 6
102987: PUSH
102988: LD_INT 1
102990: ARRAY
102991: PPUSH
102992: LD_VAR 0 2
102996: PPUSH
102997: LD_VAR 0 5
103001: PPUSH
103002: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
103006: LD_VAR 0 6
103010: PUSH
103011: LD_INT 1
103013: ARRAY
103014: PPUSH
103015: LD_VAR 0 3
103019: PPUSH
103020: LD_VAR 0 4
103024: PPUSH
103025: CALL_OW 237
// end ;
103029: PPOPN 6
103031: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
103032: LD_EXP 96
103036: PUSH
103037: LD_EXP 143
103041: AND
103042: IFFALSE 103121
103044: GO 103046
103046: DISABLE
103047: LD_INT 0
103049: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
103050: LD_ADDR_VAR 0 1
103054: PUSH
103055: LD_INT 22
103057: PUSH
103058: LD_OWVAR 2
103062: PUSH
103063: EMPTY
103064: LIST
103065: LIST
103066: PUSH
103067: LD_INT 30
103069: PUSH
103070: LD_INT 3
103072: PUSH
103073: EMPTY
103074: LIST
103075: LIST
103076: PUSH
103077: EMPTY
103078: LIST
103079: LIST
103080: PPUSH
103081: CALL_OW 69
103085: ST_TO_ADDR
// if not tmp then
103086: LD_VAR 0 1
103090: NOT
103091: IFFALSE 103095
// exit ;
103093: GO 103121
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
103095: LD_VAR 0 1
103099: PUSH
103100: LD_INT 1
103102: PPUSH
103103: LD_VAR 0 1
103107: PPUSH
103108: CALL_OW 12
103112: ARRAY
103113: PPUSH
103114: LD_INT 1
103116: PPUSH
103117: CALL_OW 234
// end ;
103121: PPOPN 1
103123: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
103124: LD_EXP 96
103128: PUSH
103129: LD_EXP 144
103133: AND
103134: IFFALSE 103246
103136: GO 103138
103138: DISABLE
103139: LD_INT 0
103141: PPUSH
103142: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
103143: LD_ADDR_VAR 0 2
103147: PUSH
103148: LD_INT 22
103150: PUSH
103151: LD_OWVAR 2
103155: PUSH
103156: EMPTY
103157: LIST
103158: LIST
103159: PUSH
103160: LD_INT 2
103162: PUSH
103163: LD_INT 30
103165: PUSH
103166: LD_INT 27
103168: PUSH
103169: EMPTY
103170: LIST
103171: LIST
103172: PUSH
103173: LD_INT 30
103175: PUSH
103176: LD_INT 26
103178: PUSH
103179: EMPTY
103180: LIST
103181: LIST
103182: PUSH
103183: LD_INT 30
103185: PUSH
103186: LD_INT 28
103188: PUSH
103189: EMPTY
103190: LIST
103191: LIST
103192: PUSH
103193: EMPTY
103194: LIST
103195: LIST
103196: LIST
103197: LIST
103198: PUSH
103199: EMPTY
103200: LIST
103201: LIST
103202: PPUSH
103203: CALL_OW 69
103207: ST_TO_ADDR
// if not tmp then
103208: LD_VAR 0 2
103212: NOT
103213: IFFALSE 103217
// exit ;
103215: GO 103246
// for i in tmp do
103217: LD_ADDR_VAR 0 1
103221: PUSH
103222: LD_VAR 0 2
103226: PUSH
103227: FOR_IN
103228: IFFALSE 103244
// SetLives ( i , 1 ) ;
103230: LD_VAR 0 1
103234: PPUSH
103235: LD_INT 1
103237: PPUSH
103238: CALL_OW 234
103242: GO 103227
103244: POP
103245: POP
// end ;
103246: PPOPN 2
103248: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
103249: LD_EXP 96
103253: PUSH
103254: LD_EXP 145
103258: AND
103259: IFFALSE 103546
103261: GO 103263
103263: DISABLE
103264: LD_INT 0
103266: PPUSH
103267: PPUSH
103268: PPUSH
// begin i := rand ( 1 , 7 ) ;
103269: LD_ADDR_VAR 0 1
103273: PUSH
103274: LD_INT 1
103276: PPUSH
103277: LD_INT 7
103279: PPUSH
103280: CALL_OW 12
103284: ST_TO_ADDR
// case i of 1 :
103285: LD_VAR 0 1
103289: PUSH
103290: LD_INT 1
103292: DOUBLE
103293: EQUAL
103294: IFTRUE 103298
103296: GO 103308
103298: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
103299: LD_STRING earthquake(getX(game), 0, 32)
103301: PPUSH
103302: CALL_OW 559
103306: GO 103546
103308: LD_INT 2
103310: DOUBLE
103311: EQUAL
103312: IFTRUE 103316
103314: GO 103330
103316: POP
// begin ToLua ( displayStucuk(); ) ;
103317: LD_STRING displayStucuk();
103319: PPUSH
103320: CALL_OW 559
// ResetFog ;
103324: CALL_OW 335
// end ; 3 :
103328: GO 103546
103330: LD_INT 3
103332: DOUBLE
103333: EQUAL
103334: IFTRUE 103338
103336: GO 103442
103338: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
103339: LD_ADDR_VAR 0 2
103343: PUSH
103344: LD_INT 22
103346: PUSH
103347: LD_OWVAR 2
103351: PUSH
103352: EMPTY
103353: LIST
103354: LIST
103355: PUSH
103356: LD_INT 25
103358: PUSH
103359: LD_INT 1
103361: PUSH
103362: EMPTY
103363: LIST
103364: LIST
103365: PUSH
103366: EMPTY
103367: LIST
103368: LIST
103369: PPUSH
103370: CALL_OW 69
103374: ST_TO_ADDR
// if not tmp then
103375: LD_VAR 0 2
103379: NOT
103380: IFFALSE 103384
// exit ;
103382: GO 103546
// un := tmp [ rand ( 1 , tmp ) ] ;
103384: LD_ADDR_VAR 0 3
103388: PUSH
103389: LD_VAR 0 2
103393: PUSH
103394: LD_INT 1
103396: PPUSH
103397: LD_VAR 0 2
103401: PPUSH
103402: CALL_OW 12
103406: ARRAY
103407: ST_TO_ADDR
// if Crawls ( un ) then
103408: LD_VAR 0 3
103412: PPUSH
103413: CALL_OW 318
103417: IFFALSE 103428
// ComWalk ( un ) ;
103419: LD_VAR 0 3
103423: PPUSH
103424: CALL_OW 138
// SetClass ( un , class_mortar ) ;
103428: LD_VAR 0 3
103432: PPUSH
103433: LD_INT 8
103435: PPUSH
103436: CALL_OW 336
// end ; 4 :
103440: GO 103546
103442: LD_INT 4
103444: DOUBLE
103445: EQUAL
103446: IFTRUE 103450
103448: GO 103524
103450: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
103451: LD_ADDR_VAR 0 2
103455: PUSH
103456: LD_INT 22
103458: PUSH
103459: LD_OWVAR 2
103463: PUSH
103464: EMPTY
103465: LIST
103466: LIST
103467: PUSH
103468: LD_INT 30
103470: PUSH
103471: LD_INT 29
103473: PUSH
103474: EMPTY
103475: LIST
103476: LIST
103477: PUSH
103478: EMPTY
103479: LIST
103480: LIST
103481: PPUSH
103482: CALL_OW 69
103486: ST_TO_ADDR
// if not tmp then
103487: LD_VAR 0 2
103491: NOT
103492: IFFALSE 103496
// exit ;
103494: GO 103546
// CenterNowOnUnits ( tmp [ 1 ] ) ;
103496: LD_VAR 0 2
103500: PUSH
103501: LD_INT 1
103503: ARRAY
103504: PPUSH
103505: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
103509: LD_VAR 0 2
103513: PUSH
103514: LD_INT 1
103516: ARRAY
103517: PPUSH
103518: CALL_OW 65
// end ; 5 .. 7 :
103522: GO 103546
103524: LD_INT 5
103526: DOUBLE
103527: GREATEREQUAL
103528: IFFALSE 103536
103530: LD_INT 7
103532: DOUBLE
103533: LESSEQUAL
103534: IFTRUE 103538
103536: GO 103545
103538: POP
// StreamSibBomb ; end ;
103539: CALL 99783 0 0
103543: GO 103546
103545: POP
// end ;
103546: PPOPN 3
103548: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
103549: LD_EXP 96
103553: PUSH
103554: LD_EXP 146
103558: AND
103559: IFFALSE 103715
103561: GO 103563
103563: DISABLE
103564: LD_INT 0
103566: PPUSH
103567: PPUSH
103568: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
103569: LD_ADDR_VAR 0 2
103573: PUSH
103574: LD_INT 81
103576: PUSH
103577: LD_OWVAR 2
103581: PUSH
103582: EMPTY
103583: LIST
103584: LIST
103585: PUSH
103586: LD_INT 2
103588: PUSH
103589: LD_INT 21
103591: PUSH
103592: LD_INT 1
103594: PUSH
103595: EMPTY
103596: LIST
103597: LIST
103598: PUSH
103599: LD_INT 21
103601: PUSH
103602: LD_INT 2
103604: PUSH
103605: EMPTY
103606: LIST
103607: LIST
103608: PUSH
103609: EMPTY
103610: LIST
103611: LIST
103612: LIST
103613: PUSH
103614: EMPTY
103615: LIST
103616: LIST
103617: PPUSH
103618: CALL_OW 69
103622: ST_TO_ADDR
// if not tmp then
103623: LD_VAR 0 2
103627: NOT
103628: IFFALSE 103632
// exit ;
103630: GO 103715
// p := 0 ;
103632: LD_ADDR_VAR 0 3
103636: PUSH
103637: LD_INT 0
103639: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
103640: LD_INT 35
103642: PPUSH
103643: CALL_OW 67
// p := p + 1 ;
103647: LD_ADDR_VAR 0 3
103651: PUSH
103652: LD_VAR 0 3
103656: PUSH
103657: LD_INT 1
103659: PLUS
103660: ST_TO_ADDR
// for i in tmp do
103661: LD_ADDR_VAR 0 1
103665: PUSH
103666: LD_VAR 0 2
103670: PUSH
103671: FOR_IN
103672: IFFALSE 103703
// if GetLives ( i ) < 1000 then
103674: LD_VAR 0 1
103678: PPUSH
103679: CALL_OW 256
103683: PUSH
103684: LD_INT 1000
103686: LESS
103687: IFFALSE 103701
// SetLives ( i , 1000 ) ;
103689: LD_VAR 0 1
103693: PPUSH
103694: LD_INT 1000
103696: PPUSH
103697: CALL_OW 234
103701: GO 103671
103703: POP
103704: POP
// until p > 20 ;
103705: LD_VAR 0 3
103709: PUSH
103710: LD_INT 20
103712: GREATER
103713: IFFALSE 103640
// end ;
103715: PPOPN 3
103717: END
// every 0 0$1 trigger StreamModeActive and sTime do
103718: LD_EXP 96
103722: PUSH
103723: LD_EXP 147
103727: AND
103728: IFFALSE 103763
103730: GO 103732
103732: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
103733: LD_INT 28
103735: PPUSH
103736: LD_OWVAR 2
103740: PPUSH
103741: LD_INT 2
103743: PPUSH
103744: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
103748: LD_INT 30
103750: PPUSH
103751: LD_OWVAR 2
103755: PPUSH
103756: LD_INT 2
103758: PPUSH
103759: CALL_OW 322
// end ;
103763: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
103764: LD_EXP 96
103768: PUSH
103769: LD_EXP 148
103773: AND
103774: IFFALSE 103895
103776: GO 103778
103778: DISABLE
103779: LD_INT 0
103781: PPUSH
103782: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
103783: LD_ADDR_VAR 0 2
103787: PUSH
103788: LD_INT 22
103790: PUSH
103791: LD_OWVAR 2
103795: PUSH
103796: EMPTY
103797: LIST
103798: LIST
103799: PUSH
103800: LD_INT 21
103802: PUSH
103803: LD_INT 1
103805: PUSH
103806: EMPTY
103807: LIST
103808: LIST
103809: PUSH
103810: LD_INT 3
103812: PUSH
103813: LD_INT 23
103815: PUSH
103816: LD_INT 0
103818: PUSH
103819: EMPTY
103820: LIST
103821: LIST
103822: PUSH
103823: EMPTY
103824: LIST
103825: LIST
103826: PUSH
103827: EMPTY
103828: LIST
103829: LIST
103830: LIST
103831: PPUSH
103832: CALL_OW 69
103836: ST_TO_ADDR
// if not tmp then
103837: LD_VAR 0 2
103841: NOT
103842: IFFALSE 103846
// exit ;
103844: GO 103895
// for i in tmp do
103846: LD_ADDR_VAR 0 1
103850: PUSH
103851: LD_VAR 0 2
103855: PUSH
103856: FOR_IN
103857: IFFALSE 103893
// begin if Crawls ( i ) then
103859: LD_VAR 0 1
103863: PPUSH
103864: CALL_OW 318
103868: IFFALSE 103879
// ComWalk ( i ) ;
103870: LD_VAR 0 1
103874: PPUSH
103875: CALL_OW 138
// SetClass ( i , 2 ) ;
103879: LD_VAR 0 1
103883: PPUSH
103884: LD_INT 2
103886: PPUSH
103887: CALL_OW 336
// end ;
103891: GO 103856
103893: POP
103894: POP
// end ;
103895: PPOPN 2
103897: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
103898: LD_EXP 96
103902: PUSH
103903: LD_EXP 149
103907: AND
103908: IFFALSE 104196
103910: GO 103912
103912: DISABLE
103913: LD_INT 0
103915: PPUSH
103916: PPUSH
103917: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
103918: LD_OWVAR 2
103922: PPUSH
103923: LD_INT 9
103925: PPUSH
103926: LD_INT 1
103928: PPUSH
103929: LD_INT 1
103931: PPUSH
103932: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
103936: LD_INT 9
103938: PPUSH
103939: LD_OWVAR 2
103943: PPUSH
103944: CALL_OW 343
// uc_side := 9 ;
103948: LD_ADDR_OWVAR 20
103952: PUSH
103953: LD_INT 9
103955: ST_TO_ADDR
// uc_nation := 2 ;
103956: LD_ADDR_OWVAR 21
103960: PUSH
103961: LD_INT 2
103963: ST_TO_ADDR
// hc_name := Dark Warrior ;
103964: LD_ADDR_OWVAR 26
103968: PUSH
103969: LD_STRING Dark Warrior
103971: ST_TO_ADDR
// hc_gallery :=  ;
103972: LD_ADDR_OWVAR 33
103976: PUSH
103977: LD_STRING 
103979: ST_TO_ADDR
// hc_noskilllimit := true ;
103980: LD_ADDR_OWVAR 76
103984: PUSH
103985: LD_INT 1
103987: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
103988: LD_ADDR_OWVAR 31
103992: PUSH
103993: LD_INT 30
103995: PUSH
103996: LD_INT 30
103998: PUSH
103999: LD_INT 30
104001: PUSH
104002: LD_INT 30
104004: PUSH
104005: EMPTY
104006: LIST
104007: LIST
104008: LIST
104009: LIST
104010: ST_TO_ADDR
// un := CreateHuman ;
104011: LD_ADDR_VAR 0 3
104015: PUSH
104016: CALL_OW 44
104020: ST_TO_ADDR
// hc_noskilllimit := false ;
104021: LD_ADDR_OWVAR 76
104025: PUSH
104026: LD_INT 0
104028: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
104029: LD_VAR 0 3
104033: PPUSH
104034: LD_INT 1
104036: PPUSH
104037: CALL_OW 51
// ToLua ( playRanger() ) ;
104041: LD_STRING playRanger()
104043: PPUSH
104044: CALL_OW 559
// p := 0 ;
104048: LD_ADDR_VAR 0 2
104052: PUSH
104053: LD_INT 0
104055: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
104056: LD_INT 35
104058: PPUSH
104059: CALL_OW 67
// p := p + 1 ;
104063: LD_ADDR_VAR 0 2
104067: PUSH
104068: LD_VAR 0 2
104072: PUSH
104073: LD_INT 1
104075: PLUS
104076: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
104077: LD_VAR 0 3
104081: PPUSH
104082: CALL_OW 256
104086: PUSH
104087: LD_INT 1000
104089: LESS
104090: IFFALSE 104104
// SetLives ( un , 1000 ) ;
104092: LD_VAR 0 3
104096: PPUSH
104097: LD_INT 1000
104099: PPUSH
104100: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
104104: LD_VAR 0 3
104108: PPUSH
104109: LD_INT 81
104111: PUSH
104112: LD_OWVAR 2
104116: PUSH
104117: EMPTY
104118: LIST
104119: LIST
104120: PUSH
104121: LD_INT 91
104123: PUSH
104124: LD_VAR 0 3
104128: PUSH
104129: LD_INT 30
104131: PUSH
104132: EMPTY
104133: LIST
104134: LIST
104135: LIST
104136: PUSH
104137: EMPTY
104138: LIST
104139: LIST
104140: PPUSH
104141: CALL_OW 69
104145: PPUSH
104146: LD_VAR 0 3
104150: PPUSH
104151: CALL_OW 74
104155: PPUSH
104156: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
104160: LD_VAR 0 2
104164: PUSH
104165: LD_INT 80
104167: GREATER
104168: PUSH
104169: LD_VAR 0 3
104173: PPUSH
104174: CALL_OW 301
104178: OR
104179: IFFALSE 104056
// if un then
104181: LD_VAR 0 3
104185: IFFALSE 104196
// RemoveUnit ( un ) ;
104187: LD_VAR 0 3
104191: PPUSH
104192: CALL_OW 64
// end ;
104196: PPOPN 3
104198: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
104199: LD_EXP 150
104203: IFFALSE 104319
104205: GO 104207
104207: DISABLE
104208: LD_INT 0
104210: PPUSH
104211: PPUSH
104212: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
104213: LD_ADDR_VAR 0 2
104217: PUSH
104218: LD_INT 81
104220: PUSH
104221: LD_OWVAR 2
104225: PUSH
104226: EMPTY
104227: LIST
104228: LIST
104229: PUSH
104230: LD_INT 21
104232: PUSH
104233: LD_INT 1
104235: PUSH
104236: EMPTY
104237: LIST
104238: LIST
104239: PUSH
104240: EMPTY
104241: LIST
104242: LIST
104243: PPUSH
104244: CALL_OW 69
104248: ST_TO_ADDR
// ToLua ( playComputer() ) ;
104249: LD_STRING playComputer()
104251: PPUSH
104252: CALL_OW 559
// if not tmp then
104256: LD_VAR 0 2
104260: NOT
104261: IFFALSE 104265
// exit ;
104263: GO 104319
// for i in tmp do
104265: LD_ADDR_VAR 0 1
104269: PUSH
104270: LD_VAR 0 2
104274: PUSH
104275: FOR_IN
104276: IFFALSE 104317
// for j := 1 to 4 do
104278: LD_ADDR_VAR 0 3
104282: PUSH
104283: DOUBLE
104284: LD_INT 1
104286: DEC
104287: ST_TO_ADDR
104288: LD_INT 4
104290: PUSH
104291: FOR_TO
104292: IFFALSE 104313
// SetSkill ( i , j , 10 ) ;
104294: LD_VAR 0 1
104298: PPUSH
104299: LD_VAR 0 3
104303: PPUSH
104304: LD_INT 10
104306: PPUSH
104307: CALL_OW 237
104311: GO 104291
104313: POP
104314: POP
104315: GO 104275
104317: POP
104318: POP
// end ;
104319: PPOPN 3
104321: END
// every 0 0$1 trigger s30 do var i , tmp ;
104322: LD_EXP 151
104326: IFFALSE 104395
104328: GO 104330
104330: DISABLE
104331: LD_INT 0
104333: PPUSH
104334: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
104335: LD_ADDR_VAR 0 2
104339: PUSH
104340: LD_INT 22
104342: PUSH
104343: LD_OWVAR 2
104347: PUSH
104348: EMPTY
104349: LIST
104350: LIST
104351: PPUSH
104352: CALL_OW 69
104356: ST_TO_ADDR
// if not tmp then
104357: LD_VAR 0 2
104361: NOT
104362: IFFALSE 104366
// exit ;
104364: GO 104395
// for i in tmp do
104366: LD_ADDR_VAR 0 1
104370: PUSH
104371: LD_VAR 0 2
104375: PUSH
104376: FOR_IN
104377: IFFALSE 104393
// SetLives ( i , 300 ) ;
104379: LD_VAR 0 1
104383: PPUSH
104384: LD_INT 300
104386: PPUSH
104387: CALL_OW 234
104391: GO 104376
104393: POP
104394: POP
// end ;
104395: PPOPN 2
104397: END
// every 0 0$1 trigger s60 do var i , tmp ;
104398: LD_EXP 152
104402: IFFALSE 104471
104404: GO 104406
104406: DISABLE
104407: LD_INT 0
104409: PPUSH
104410: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
104411: LD_ADDR_VAR 0 2
104415: PUSH
104416: LD_INT 22
104418: PUSH
104419: LD_OWVAR 2
104423: PUSH
104424: EMPTY
104425: LIST
104426: LIST
104427: PPUSH
104428: CALL_OW 69
104432: ST_TO_ADDR
// if not tmp then
104433: LD_VAR 0 2
104437: NOT
104438: IFFALSE 104442
// exit ;
104440: GO 104471
// for i in tmp do
104442: LD_ADDR_VAR 0 1
104446: PUSH
104447: LD_VAR 0 2
104451: PUSH
104452: FOR_IN
104453: IFFALSE 104469
// SetLives ( i , 600 ) ;
104455: LD_VAR 0 1
104459: PPUSH
104460: LD_INT 600
104462: PPUSH
104463: CALL_OW 234
104467: GO 104452
104469: POP
104470: POP
// end ;
104471: PPOPN 2
104473: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
104474: LD_INT 0
104476: PPUSH
// case cmd of 301 :
104477: LD_VAR 0 1
104481: PUSH
104482: LD_INT 301
104484: DOUBLE
104485: EQUAL
104486: IFTRUE 104490
104488: GO 104522
104490: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
104491: LD_VAR 0 6
104495: PPUSH
104496: LD_VAR 0 7
104500: PPUSH
104501: LD_VAR 0 8
104505: PPUSH
104506: LD_VAR 0 4
104510: PPUSH
104511: LD_VAR 0 5
104515: PPUSH
104516: CALL 105731 0 5
104520: GO 104643
104522: LD_INT 302
104524: DOUBLE
104525: EQUAL
104526: IFTRUE 104530
104528: GO 104567
104530: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
104531: LD_VAR 0 6
104535: PPUSH
104536: LD_VAR 0 7
104540: PPUSH
104541: LD_VAR 0 8
104545: PPUSH
104546: LD_VAR 0 9
104550: PPUSH
104551: LD_VAR 0 4
104555: PPUSH
104556: LD_VAR 0 5
104560: PPUSH
104561: CALL 105822 0 6
104565: GO 104643
104567: LD_INT 303
104569: DOUBLE
104570: EQUAL
104571: IFTRUE 104575
104573: GO 104612
104575: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
104576: LD_VAR 0 6
104580: PPUSH
104581: LD_VAR 0 7
104585: PPUSH
104586: LD_VAR 0 8
104590: PPUSH
104591: LD_VAR 0 9
104595: PPUSH
104596: LD_VAR 0 4
104600: PPUSH
104601: LD_VAR 0 5
104605: PPUSH
104606: CALL 104648 0 6
104610: GO 104643
104612: LD_INT 304
104614: DOUBLE
104615: EQUAL
104616: IFTRUE 104620
104618: GO 104642
104620: POP
// hHackTeleport ( unit , x , y ) ; end ;
104621: LD_VAR 0 2
104625: PPUSH
104626: LD_VAR 0 4
104630: PPUSH
104631: LD_VAR 0 5
104635: PPUSH
104636: CALL 106415 0 3
104640: GO 104643
104642: POP
// end ;
104643: LD_VAR 0 12
104647: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
104648: LD_INT 0
104650: PPUSH
104651: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
104652: LD_VAR 0 1
104656: PUSH
104657: LD_INT 1
104659: LESS
104660: PUSH
104661: LD_VAR 0 1
104665: PUSH
104666: LD_INT 3
104668: GREATER
104669: OR
104670: PUSH
104671: LD_VAR 0 5
104675: PPUSH
104676: LD_VAR 0 6
104680: PPUSH
104681: CALL_OW 428
104685: OR
104686: IFFALSE 104690
// exit ;
104688: GO 105418
// uc_side := your_side ;
104690: LD_ADDR_OWVAR 20
104694: PUSH
104695: LD_OWVAR 2
104699: ST_TO_ADDR
// uc_nation := nation ;
104700: LD_ADDR_OWVAR 21
104704: PUSH
104705: LD_VAR 0 1
104709: ST_TO_ADDR
// bc_level = 1 ;
104710: LD_ADDR_OWVAR 43
104714: PUSH
104715: LD_INT 1
104717: ST_TO_ADDR
// case btype of 1 :
104718: LD_VAR 0 2
104722: PUSH
104723: LD_INT 1
104725: DOUBLE
104726: EQUAL
104727: IFTRUE 104731
104729: GO 104742
104731: POP
// bc_type := b_depot ; 2 :
104732: LD_ADDR_OWVAR 42
104736: PUSH
104737: LD_INT 0
104739: ST_TO_ADDR
104740: GO 105362
104742: LD_INT 2
104744: DOUBLE
104745: EQUAL
104746: IFTRUE 104750
104748: GO 104761
104750: POP
// bc_type := b_warehouse ; 3 :
104751: LD_ADDR_OWVAR 42
104755: PUSH
104756: LD_INT 1
104758: ST_TO_ADDR
104759: GO 105362
104761: LD_INT 3
104763: DOUBLE
104764: EQUAL
104765: IFTRUE 104769
104767: GO 104780
104769: POP
// bc_type := b_lab ; 4 .. 9 :
104770: LD_ADDR_OWVAR 42
104774: PUSH
104775: LD_INT 6
104777: ST_TO_ADDR
104778: GO 105362
104780: LD_INT 4
104782: DOUBLE
104783: GREATEREQUAL
104784: IFFALSE 104792
104786: LD_INT 9
104788: DOUBLE
104789: LESSEQUAL
104790: IFTRUE 104794
104792: GO 104854
104794: POP
// begin bc_type := b_lab_half ;
104795: LD_ADDR_OWVAR 42
104799: PUSH
104800: LD_INT 7
104802: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
104803: LD_ADDR_OWVAR 44
104807: PUSH
104808: LD_INT 10
104810: PUSH
104811: LD_INT 11
104813: PUSH
104814: LD_INT 12
104816: PUSH
104817: LD_INT 15
104819: PUSH
104820: LD_INT 14
104822: PUSH
104823: LD_INT 13
104825: PUSH
104826: EMPTY
104827: LIST
104828: LIST
104829: LIST
104830: LIST
104831: LIST
104832: LIST
104833: PUSH
104834: LD_VAR 0 2
104838: PUSH
104839: LD_INT 3
104841: MINUS
104842: ARRAY
104843: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
104844: LD_ADDR_OWVAR 45
104848: PUSH
104849: LD_INT 9
104851: ST_TO_ADDR
// end ; 10 .. 13 :
104852: GO 105362
104854: LD_INT 10
104856: DOUBLE
104857: GREATEREQUAL
104858: IFFALSE 104866
104860: LD_INT 13
104862: DOUBLE
104863: LESSEQUAL
104864: IFTRUE 104868
104866: GO 104945
104868: POP
// begin bc_type := b_lab_full ;
104869: LD_ADDR_OWVAR 42
104873: PUSH
104874: LD_INT 8
104876: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
104877: LD_ADDR_OWVAR 44
104881: PUSH
104882: LD_INT 10
104884: PUSH
104885: LD_INT 12
104887: PUSH
104888: LD_INT 14
104890: PUSH
104891: LD_INT 13
104893: PUSH
104894: EMPTY
104895: LIST
104896: LIST
104897: LIST
104898: LIST
104899: PUSH
104900: LD_VAR 0 2
104904: PUSH
104905: LD_INT 9
104907: MINUS
104908: ARRAY
104909: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
104910: LD_ADDR_OWVAR 45
104914: PUSH
104915: LD_INT 11
104917: PUSH
104918: LD_INT 15
104920: PUSH
104921: LD_INT 12
104923: PUSH
104924: LD_INT 15
104926: PUSH
104927: EMPTY
104928: LIST
104929: LIST
104930: LIST
104931: LIST
104932: PUSH
104933: LD_VAR 0 2
104937: PUSH
104938: LD_INT 9
104940: MINUS
104941: ARRAY
104942: ST_TO_ADDR
// end ; 14 :
104943: GO 105362
104945: LD_INT 14
104947: DOUBLE
104948: EQUAL
104949: IFTRUE 104953
104951: GO 104964
104953: POP
// bc_type := b_workshop ; 15 :
104954: LD_ADDR_OWVAR 42
104958: PUSH
104959: LD_INT 2
104961: ST_TO_ADDR
104962: GO 105362
104964: LD_INT 15
104966: DOUBLE
104967: EQUAL
104968: IFTRUE 104972
104970: GO 104983
104972: POP
// bc_type := b_factory ; 16 :
104973: LD_ADDR_OWVAR 42
104977: PUSH
104978: LD_INT 3
104980: ST_TO_ADDR
104981: GO 105362
104983: LD_INT 16
104985: DOUBLE
104986: EQUAL
104987: IFTRUE 104991
104989: GO 105002
104991: POP
// bc_type := b_ext_gun ; 17 :
104992: LD_ADDR_OWVAR 42
104996: PUSH
104997: LD_INT 17
104999: ST_TO_ADDR
105000: GO 105362
105002: LD_INT 17
105004: DOUBLE
105005: EQUAL
105006: IFTRUE 105010
105008: GO 105038
105010: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
105011: LD_ADDR_OWVAR 42
105015: PUSH
105016: LD_INT 19
105018: PUSH
105019: LD_INT 23
105021: PUSH
105022: LD_INT 19
105024: PUSH
105025: EMPTY
105026: LIST
105027: LIST
105028: LIST
105029: PUSH
105030: LD_VAR 0 1
105034: ARRAY
105035: ST_TO_ADDR
105036: GO 105362
105038: LD_INT 18
105040: DOUBLE
105041: EQUAL
105042: IFTRUE 105046
105044: GO 105057
105046: POP
// bc_type := b_ext_radar ; 19 :
105047: LD_ADDR_OWVAR 42
105051: PUSH
105052: LD_INT 20
105054: ST_TO_ADDR
105055: GO 105362
105057: LD_INT 19
105059: DOUBLE
105060: EQUAL
105061: IFTRUE 105065
105063: GO 105076
105065: POP
// bc_type := b_ext_radio ; 20 :
105066: LD_ADDR_OWVAR 42
105070: PUSH
105071: LD_INT 22
105073: ST_TO_ADDR
105074: GO 105362
105076: LD_INT 20
105078: DOUBLE
105079: EQUAL
105080: IFTRUE 105084
105082: GO 105095
105084: POP
// bc_type := b_ext_siberium ; 21 :
105085: LD_ADDR_OWVAR 42
105089: PUSH
105090: LD_INT 21
105092: ST_TO_ADDR
105093: GO 105362
105095: LD_INT 21
105097: DOUBLE
105098: EQUAL
105099: IFTRUE 105103
105101: GO 105114
105103: POP
// bc_type := b_ext_computer ; 22 :
105104: LD_ADDR_OWVAR 42
105108: PUSH
105109: LD_INT 24
105111: ST_TO_ADDR
105112: GO 105362
105114: LD_INT 22
105116: DOUBLE
105117: EQUAL
105118: IFTRUE 105122
105120: GO 105133
105122: POP
// bc_type := b_ext_track ; 23 :
105123: LD_ADDR_OWVAR 42
105127: PUSH
105128: LD_INT 16
105130: ST_TO_ADDR
105131: GO 105362
105133: LD_INT 23
105135: DOUBLE
105136: EQUAL
105137: IFTRUE 105141
105139: GO 105152
105141: POP
// bc_type := b_ext_laser ; 24 :
105142: LD_ADDR_OWVAR 42
105146: PUSH
105147: LD_INT 25
105149: ST_TO_ADDR
105150: GO 105362
105152: LD_INT 24
105154: DOUBLE
105155: EQUAL
105156: IFTRUE 105160
105158: GO 105171
105160: POP
// bc_type := b_control_tower ; 25 :
105161: LD_ADDR_OWVAR 42
105165: PUSH
105166: LD_INT 36
105168: ST_TO_ADDR
105169: GO 105362
105171: LD_INT 25
105173: DOUBLE
105174: EQUAL
105175: IFTRUE 105179
105177: GO 105190
105179: POP
// bc_type := b_breastwork ; 26 :
105180: LD_ADDR_OWVAR 42
105184: PUSH
105185: LD_INT 31
105187: ST_TO_ADDR
105188: GO 105362
105190: LD_INT 26
105192: DOUBLE
105193: EQUAL
105194: IFTRUE 105198
105196: GO 105209
105198: POP
// bc_type := b_bunker ; 27 :
105199: LD_ADDR_OWVAR 42
105203: PUSH
105204: LD_INT 32
105206: ST_TO_ADDR
105207: GO 105362
105209: LD_INT 27
105211: DOUBLE
105212: EQUAL
105213: IFTRUE 105217
105215: GO 105228
105217: POP
// bc_type := b_turret ; 28 :
105218: LD_ADDR_OWVAR 42
105222: PUSH
105223: LD_INT 33
105225: ST_TO_ADDR
105226: GO 105362
105228: LD_INT 28
105230: DOUBLE
105231: EQUAL
105232: IFTRUE 105236
105234: GO 105247
105236: POP
// bc_type := b_armoury ; 29 :
105237: LD_ADDR_OWVAR 42
105241: PUSH
105242: LD_INT 4
105244: ST_TO_ADDR
105245: GO 105362
105247: LD_INT 29
105249: DOUBLE
105250: EQUAL
105251: IFTRUE 105255
105253: GO 105266
105255: POP
// bc_type := b_barracks ; 30 :
105256: LD_ADDR_OWVAR 42
105260: PUSH
105261: LD_INT 5
105263: ST_TO_ADDR
105264: GO 105362
105266: LD_INT 30
105268: DOUBLE
105269: EQUAL
105270: IFTRUE 105274
105272: GO 105285
105274: POP
// bc_type := b_solar_power ; 31 :
105275: LD_ADDR_OWVAR 42
105279: PUSH
105280: LD_INT 27
105282: ST_TO_ADDR
105283: GO 105362
105285: LD_INT 31
105287: DOUBLE
105288: EQUAL
105289: IFTRUE 105293
105291: GO 105304
105293: POP
// bc_type := b_oil_power ; 32 :
105294: LD_ADDR_OWVAR 42
105298: PUSH
105299: LD_INT 26
105301: ST_TO_ADDR
105302: GO 105362
105304: LD_INT 32
105306: DOUBLE
105307: EQUAL
105308: IFTRUE 105312
105310: GO 105323
105312: POP
// bc_type := b_siberite_power ; 33 :
105313: LD_ADDR_OWVAR 42
105317: PUSH
105318: LD_INT 28
105320: ST_TO_ADDR
105321: GO 105362
105323: LD_INT 33
105325: DOUBLE
105326: EQUAL
105327: IFTRUE 105331
105329: GO 105342
105331: POP
// bc_type := b_oil_mine ; 34 :
105332: LD_ADDR_OWVAR 42
105336: PUSH
105337: LD_INT 29
105339: ST_TO_ADDR
105340: GO 105362
105342: LD_INT 34
105344: DOUBLE
105345: EQUAL
105346: IFTRUE 105350
105348: GO 105361
105350: POP
// bc_type := b_siberite_mine ; end ;
105351: LD_ADDR_OWVAR 42
105355: PUSH
105356: LD_INT 30
105358: ST_TO_ADDR
105359: GO 105362
105361: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
105362: LD_ADDR_VAR 0 8
105366: PUSH
105367: LD_VAR 0 5
105371: PPUSH
105372: LD_VAR 0 6
105376: PPUSH
105377: LD_VAR 0 3
105381: PPUSH
105382: CALL_OW 47
105386: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
105387: LD_OWVAR 42
105391: PUSH
105392: LD_INT 32
105394: PUSH
105395: LD_INT 33
105397: PUSH
105398: EMPTY
105399: LIST
105400: LIST
105401: IN
105402: IFFALSE 105418
// PlaceWeaponTurret ( b , weapon ) ;
105404: LD_VAR 0 8
105408: PPUSH
105409: LD_VAR 0 4
105413: PPUSH
105414: CALL_OW 431
// end ;
105418: LD_VAR 0 7
105422: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
105423: LD_INT 0
105425: PPUSH
105426: PPUSH
105427: PPUSH
105428: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
105429: LD_ADDR_VAR 0 4
105433: PUSH
105434: LD_INT 22
105436: PUSH
105437: LD_OWVAR 2
105441: PUSH
105442: EMPTY
105443: LIST
105444: LIST
105445: PUSH
105446: LD_INT 2
105448: PUSH
105449: LD_INT 30
105451: PUSH
105452: LD_INT 0
105454: PUSH
105455: EMPTY
105456: LIST
105457: LIST
105458: PUSH
105459: LD_INT 30
105461: PUSH
105462: LD_INT 1
105464: PUSH
105465: EMPTY
105466: LIST
105467: LIST
105468: PUSH
105469: EMPTY
105470: LIST
105471: LIST
105472: LIST
105473: PUSH
105474: EMPTY
105475: LIST
105476: LIST
105477: PPUSH
105478: CALL_OW 69
105482: ST_TO_ADDR
// if not tmp then
105483: LD_VAR 0 4
105487: NOT
105488: IFFALSE 105492
// exit ;
105490: GO 105551
// for i in tmp do
105492: LD_ADDR_VAR 0 2
105496: PUSH
105497: LD_VAR 0 4
105501: PUSH
105502: FOR_IN
105503: IFFALSE 105549
// for j = 1 to 3 do
105505: LD_ADDR_VAR 0 3
105509: PUSH
105510: DOUBLE
105511: LD_INT 1
105513: DEC
105514: ST_TO_ADDR
105515: LD_INT 3
105517: PUSH
105518: FOR_TO
105519: IFFALSE 105545
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
105521: LD_VAR 0 2
105525: PPUSH
105526: CALL_OW 274
105530: PPUSH
105531: LD_VAR 0 3
105535: PPUSH
105536: LD_INT 99999
105538: PPUSH
105539: CALL_OW 277
105543: GO 105518
105545: POP
105546: POP
105547: GO 105502
105549: POP
105550: POP
// end ;
105551: LD_VAR 0 1
105555: RET
// export function hHackSetLevel10 ; var i , j ; begin
105556: LD_INT 0
105558: PPUSH
105559: PPUSH
105560: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
105561: LD_ADDR_VAR 0 2
105565: PUSH
105566: LD_INT 21
105568: PUSH
105569: LD_INT 1
105571: PUSH
105572: EMPTY
105573: LIST
105574: LIST
105575: PPUSH
105576: CALL_OW 69
105580: PUSH
105581: FOR_IN
105582: IFFALSE 105634
// if IsSelected ( i ) then
105584: LD_VAR 0 2
105588: PPUSH
105589: CALL_OW 306
105593: IFFALSE 105632
// begin for j := 1 to 4 do
105595: LD_ADDR_VAR 0 3
105599: PUSH
105600: DOUBLE
105601: LD_INT 1
105603: DEC
105604: ST_TO_ADDR
105605: LD_INT 4
105607: PUSH
105608: FOR_TO
105609: IFFALSE 105630
// SetSkill ( i , j , 10 ) ;
105611: LD_VAR 0 2
105615: PPUSH
105616: LD_VAR 0 3
105620: PPUSH
105621: LD_INT 10
105623: PPUSH
105624: CALL_OW 237
105628: GO 105608
105630: POP
105631: POP
// end ;
105632: GO 105581
105634: POP
105635: POP
// end ;
105636: LD_VAR 0 1
105640: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
105641: LD_INT 0
105643: PPUSH
105644: PPUSH
105645: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
105646: LD_ADDR_VAR 0 2
105650: PUSH
105651: LD_INT 22
105653: PUSH
105654: LD_OWVAR 2
105658: PUSH
105659: EMPTY
105660: LIST
105661: LIST
105662: PUSH
105663: LD_INT 21
105665: PUSH
105666: LD_INT 1
105668: PUSH
105669: EMPTY
105670: LIST
105671: LIST
105672: PUSH
105673: EMPTY
105674: LIST
105675: LIST
105676: PPUSH
105677: CALL_OW 69
105681: PUSH
105682: FOR_IN
105683: IFFALSE 105724
// begin for j := 1 to 4 do
105685: LD_ADDR_VAR 0 3
105689: PUSH
105690: DOUBLE
105691: LD_INT 1
105693: DEC
105694: ST_TO_ADDR
105695: LD_INT 4
105697: PUSH
105698: FOR_TO
105699: IFFALSE 105720
// SetSkill ( i , j , 10 ) ;
105701: LD_VAR 0 2
105705: PPUSH
105706: LD_VAR 0 3
105710: PPUSH
105711: LD_INT 10
105713: PPUSH
105714: CALL_OW 237
105718: GO 105698
105720: POP
105721: POP
// end ;
105722: GO 105682
105724: POP
105725: POP
// end ;
105726: LD_VAR 0 1
105730: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
105731: LD_INT 0
105733: PPUSH
// uc_side := your_side ;
105734: LD_ADDR_OWVAR 20
105738: PUSH
105739: LD_OWVAR 2
105743: ST_TO_ADDR
// uc_nation := nation ;
105744: LD_ADDR_OWVAR 21
105748: PUSH
105749: LD_VAR 0 1
105753: ST_TO_ADDR
// InitHc ;
105754: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
105758: LD_INT 0
105760: PPUSH
105761: LD_VAR 0 2
105765: PPUSH
105766: LD_VAR 0 3
105770: PPUSH
105771: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
105775: LD_VAR 0 4
105779: PPUSH
105780: LD_VAR 0 5
105784: PPUSH
105785: CALL_OW 428
105789: PUSH
105790: LD_INT 0
105792: EQUAL
105793: IFFALSE 105817
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
105795: CALL_OW 44
105799: PPUSH
105800: LD_VAR 0 4
105804: PPUSH
105805: LD_VAR 0 5
105809: PPUSH
105810: LD_INT 1
105812: PPUSH
105813: CALL_OW 48
// end ;
105817: LD_VAR 0 6
105821: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
105822: LD_INT 0
105824: PPUSH
105825: PPUSH
// uc_side := your_side ;
105826: LD_ADDR_OWVAR 20
105830: PUSH
105831: LD_OWVAR 2
105835: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
105836: LD_VAR 0 1
105840: PUSH
105841: LD_INT 1
105843: PUSH
105844: LD_INT 2
105846: PUSH
105847: LD_INT 3
105849: PUSH
105850: LD_INT 4
105852: PUSH
105853: LD_INT 5
105855: PUSH
105856: EMPTY
105857: LIST
105858: LIST
105859: LIST
105860: LIST
105861: LIST
105862: IN
105863: IFFALSE 105875
// uc_nation := nation_american else
105865: LD_ADDR_OWVAR 21
105869: PUSH
105870: LD_INT 1
105872: ST_TO_ADDR
105873: GO 105918
// if chassis in [ 11 , 12 , 13 , 14 ] then
105875: LD_VAR 0 1
105879: PUSH
105880: LD_INT 11
105882: PUSH
105883: LD_INT 12
105885: PUSH
105886: LD_INT 13
105888: PUSH
105889: LD_INT 14
105891: PUSH
105892: EMPTY
105893: LIST
105894: LIST
105895: LIST
105896: LIST
105897: IN
105898: IFFALSE 105910
// uc_nation := nation_arabian else
105900: LD_ADDR_OWVAR 21
105904: PUSH
105905: LD_INT 2
105907: ST_TO_ADDR
105908: GO 105918
// uc_nation := nation_russian ;
105910: LD_ADDR_OWVAR 21
105914: PUSH
105915: LD_INT 3
105917: ST_TO_ADDR
// vc_chassis := chassis ;
105918: LD_ADDR_OWVAR 37
105922: PUSH
105923: LD_VAR 0 1
105927: ST_TO_ADDR
// vc_engine := engine ;
105928: LD_ADDR_OWVAR 39
105932: PUSH
105933: LD_VAR 0 2
105937: ST_TO_ADDR
// vc_control := control ;
105938: LD_ADDR_OWVAR 38
105942: PUSH
105943: LD_VAR 0 3
105947: ST_TO_ADDR
// vc_weapon := weapon ;
105948: LD_ADDR_OWVAR 40
105952: PUSH
105953: LD_VAR 0 4
105957: ST_TO_ADDR
// un := CreateVehicle ;
105958: LD_ADDR_VAR 0 8
105962: PUSH
105963: CALL_OW 45
105967: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
105968: LD_VAR 0 8
105972: PPUSH
105973: LD_INT 0
105975: PPUSH
105976: LD_INT 5
105978: PPUSH
105979: CALL_OW 12
105983: PPUSH
105984: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
105988: LD_VAR 0 8
105992: PPUSH
105993: LD_VAR 0 5
105997: PPUSH
105998: LD_VAR 0 6
106002: PPUSH
106003: LD_INT 1
106005: PPUSH
106006: CALL_OW 48
// end ;
106010: LD_VAR 0 7
106014: RET
// export hInvincible ; every 1 do
106015: GO 106017
106017: DISABLE
// hInvincible := [ ] ;
106018: LD_ADDR_EXP 153
106022: PUSH
106023: EMPTY
106024: ST_TO_ADDR
106025: END
// every 10 do var i ;
106026: GO 106028
106028: DISABLE
106029: LD_INT 0
106031: PPUSH
// begin enable ;
106032: ENABLE
// if not hInvincible then
106033: LD_EXP 153
106037: NOT
106038: IFFALSE 106042
// exit ;
106040: GO 106086
// for i in hInvincible do
106042: LD_ADDR_VAR 0 1
106046: PUSH
106047: LD_EXP 153
106051: PUSH
106052: FOR_IN
106053: IFFALSE 106084
// if GetLives ( i ) < 1000 then
106055: LD_VAR 0 1
106059: PPUSH
106060: CALL_OW 256
106064: PUSH
106065: LD_INT 1000
106067: LESS
106068: IFFALSE 106082
// SetLives ( i , 1000 ) ;
106070: LD_VAR 0 1
106074: PPUSH
106075: LD_INT 1000
106077: PPUSH
106078: CALL_OW 234
106082: GO 106052
106084: POP
106085: POP
// end ;
106086: PPOPN 1
106088: END
// export function hHackInvincible ; var i ; begin
106089: LD_INT 0
106091: PPUSH
106092: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
106093: LD_ADDR_VAR 0 2
106097: PUSH
106098: LD_INT 2
106100: PUSH
106101: LD_INT 21
106103: PUSH
106104: LD_INT 1
106106: PUSH
106107: EMPTY
106108: LIST
106109: LIST
106110: PUSH
106111: LD_INT 21
106113: PUSH
106114: LD_INT 2
106116: PUSH
106117: EMPTY
106118: LIST
106119: LIST
106120: PUSH
106121: EMPTY
106122: LIST
106123: LIST
106124: LIST
106125: PPUSH
106126: CALL_OW 69
106130: PUSH
106131: FOR_IN
106132: IFFALSE 106193
// if IsSelected ( i ) then
106134: LD_VAR 0 2
106138: PPUSH
106139: CALL_OW 306
106143: IFFALSE 106191
// begin if i in hInvincible then
106145: LD_VAR 0 2
106149: PUSH
106150: LD_EXP 153
106154: IN
106155: IFFALSE 106175
// hInvincible := hInvincible diff i else
106157: LD_ADDR_EXP 153
106161: PUSH
106162: LD_EXP 153
106166: PUSH
106167: LD_VAR 0 2
106171: DIFF
106172: ST_TO_ADDR
106173: GO 106191
// hInvincible := hInvincible union i ;
106175: LD_ADDR_EXP 153
106179: PUSH
106180: LD_EXP 153
106184: PUSH
106185: LD_VAR 0 2
106189: UNION
106190: ST_TO_ADDR
// end ;
106191: GO 106131
106193: POP
106194: POP
// end ;
106195: LD_VAR 0 1
106199: RET
// export function hHackInvisible ; var i , j ; begin
106200: LD_INT 0
106202: PPUSH
106203: PPUSH
106204: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
106205: LD_ADDR_VAR 0 2
106209: PUSH
106210: LD_INT 21
106212: PUSH
106213: LD_INT 1
106215: PUSH
106216: EMPTY
106217: LIST
106218: LIST
106219: PPUSH
106220: CALL_OW 69
106224: PUSH
106225: FOR_IN
106226: IFFALSE 106250
// if IsSelected ( i ) then
106228: LD_VAR 0 2
106232: PPUSH
106233: CALL_OW 306
106237: IFFALSE 106248
// ComForceInvisible ( i ) ;
106239: LD_VAR 0 2
106243: PPUSH
106244: CALL_OW 496
106248: GO 106225
106250: POP
106251: POP
// end ;
106252: LD_VAR 0 1
106256: RET
// export function hHackChangeYourSide ; begin
106257: LD_INT 0
106259: PPUSH
// if your_side = 8 then
106260: LD_OWVAR 2
106264: PUSH
106265: LD_INT 8
106267: EQUAL
106268: IFFALSE 106280
// your_side := 0 else
106270: LD_ADDR_OWVAR 2
106274: PUSH
106275: LD_INT 0
106277: ST_TO_ADDR
106278: GO 106294
// your_side := your_side + 1 ;
106280: LD_ADDR_OWVAR 2
106284: PUSH
106285: LD_OWVAR 2
106289: PUSH
106290: LD_INT 1
106292: PLUS
106293: ST_TO_ADDR
// end ;
106294: LD_VAR 0 1
106298: RET
// export function hHackChangeUnitSide ; var i , j ; begin
106299: LD_INT 0
106301: PPUSH
106302: PPUSH
106303: PPUSH
// for i in all_units do
106304: LD_ADDR_VAR 0 2
106308: PUSH
106309: LD_OWVAR 3
106313: PUSH
106314: FOR_IN
106315: IFFALSE 106393
// if IsSelected ( i ) then
106317: LD_VAR 0 2
106321: PPUSH
106322: CALL_OW 306
106326: IFFALSE 106391
// begin j := GetSide ( i ) ;
106328: LD_ADDR_VAR 0 3
106332: PUSH
106333: LD_VAR 0 2
106337: PPUSH
106338: CALL_OW 255
106342: ST_TO_ADDR
// if j = 8 then
106343: LD_VAR 0 3
106347: PUSH
106348: LD_INT 8
106350: EQUAL
106351: IFFALSE 106363
// j := 0 else
106353: LD_ADDR_VAR 0 3
106357: PUSH
106358: LD_INT 0
106360: ST_TO_ADDR
106361: GO 106377
// j := j + 1 ;
106363: LD_ADDR_VAR 0 3
106367: PUSH
106368: LD_VAR 0 3
106372: PUSH
106373: LD_INT 1
106375: PLUS
106376: ST_TO_ADDR
// SetSide ( i , j ) ;
106377: LD_VAR 0 2
106381: PPUSH
106382: LD_VAR 0 3
106386: PPUSH
106387: CALL_OW 235
// end ;
106391: GO 106314
106393: POP
106394: POP
// end ;
106395: LD_VAR 0 1
106399: RET
// export function hHackFog ; begin
106400: LD_INT 0
106402: PPUSH
// FogOff ( true ) ;
106403: LD_INT 1
106405: PPUSH
106406: CALL_OW 344
// end ;
106410: LD_VAR 0 1
106414: RET
// export function hHackTeleport ( unit , x , y ) ; begin
106415: LD_INT 0
106417: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
106418: LD_VAR 0 1
106422: PPUSH
106423: LD_VAR 0 2
106427: PPUSH
106428: LD_VAR 0 3
106432: PPUSH
106433: LD_INT 1
106435: PPUSH
106436: LD_INT 1
106438: PPUSH
106439: CALL_OW 483
// CenterOnXY ( x , y ) ;
106443: LD_VAR 0 2
106447: PPUSH
106448: LD_VAR 0 3
106452: PPUSH
106453: CALL_OW 84
// end ;
106457: LD_VAR 0 4
106461: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
106462: LD_INT 0
106464: PPUSH
106465: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
106466: LD_VAR 0 1
106470: NOT
106471: PUSH
106472: LD_VAR 0 2
106476: PPUSH
106477: LD_VAR 0 3
106481: PPUSH
106482: CALL_OW 488
106486: NOT
106487: OR
106488: PUSH
106489: LD_VAR 0 1
106493: PPUSH
106494: CALL_OW 266
106498: PUSH
106499: LD_INT 3
106501: NONEQUAL
106502: PUSH
106503: LD_VAR 0 1
106507: PPUSH
106508: CALL_OW 247
106512: PUSH
106513: LD_INT 1
106515: EQUAL
106516: NOT
106517: AND
106518: OR
106519: IFFALSE 106523
// exit ;
106521: GO 106672
// if GetType ( factory ) = unit_human then
106523: LD_VAR 0 1
106527: PPUSH
106528: CALL_OW 247
106532: PUSH
106533: LD_INT 1
106535: EQUAL
106536: IFFALSE 106553
// factory := IsInUnit ( factory ) ;
106538: LD_ADDR_VAR 0 1
106542: PUSH
106543: LD_VAR 0 1
106547: PPUSH
106548: CALL_OW 310
106552: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
106553: LD_VAR 0 1
106557: PPUSH
106558: CALL_OW 266
106562: PUSH
106563: LD_INT 3
106565: NONEQUAL
106566: IFFALSE 106570
// exit ;
106568: GO 106672
// if HexInfo ( x , y ) = factory then
106570: LD_VAR 0 2
106574: PPUSH
106575: LD_VAR 0 3
106579: PPUSH
106580: CALL_OW 428
106584: PUSH
106585: LD_VAR 0 1
106589: EQUAL
106590: IFFALSE 106617
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
106592: LD_ADDR_EXP 154
106596: PUSH
106597: LD_EXP 154
106601: PPUSH
106602: LD_VAR 0 1
106606: PPUSH
106607: LD_INT 0
106609: PPUSH
106610: CALL_OW 1
106614: ST_TO_ADDR
106615: GO 106668
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
106617: LD_ADDR_EXP 154
106621: PUSH
106622: LD_EXP 154
106626: PPUSH
106627: LD_VAR 0 1
106631: PPUSH
106632: LD_VAR 0 1
106636: PPUSH
106637: CALL_OW 255
106641: PUSH
106642: LD_VAR 0 1
106646: PUSH
106647: LD_VAR 0 2
106651: PUSH
106652: LD_VAR 0 3
106656: PUSH
106657: EMPTY
106658: LIST
106659: LIST
106660: LIST
106661: LIST
106662: PPUSH
106663: CALL_OW 1
106667: ST_TO_ADDR
// UpdateFactoryWaypoints ;
106668: CALL 106677 0 0
// end ;
106672: LD_VAR 0 4
106676: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
106677: LD_INT 0
106679: PPUSH
106680: PPUSH
106681: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
106682: LD_STRING resetFactoryWaypoint();
106684: PPUSH
106685: CALL_OW 559
// if factoryWaypoints then
106689: LD_EXP 154
106693: IFFALSE 106819
// begin list := PrepareArray ( factoryWaypoints ) ;
106695: LD_ADDR_VAR 0 3
106699: PUSH
106700: LD_EXP 154
106704: PPUSH
106705: CALL 90632 0 1
106709: ST_TO_ADDR
// for i := 1 to list do
106710: LD_ADDR_VAR 0 2
106714: PUSH
106715: DOUBLE
106716: LD_INT 1
106718: DEC
106719: ST_TO_ADDR
106720: LD_VAR 0 3
106724: PUSH
106725: FOR_TO
106726: IFFALSE 106817
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
106728: LD_STRING setFactoryWaypointXY(
106730: PUSH
106731: LD_VAR 0 3
106735: PUSH
106736: LD_VAR 0 2
106740: ARRAY
106741: PUSH
106742: LD_INT 1
106744: ARRAY
106745: STR
106746: PUSH
106747: LD_STRING ,
106749: STR
106750: PUSH
106751: LD_VAR 0 3
106755: PUSH
106756: LD_VAR 0 2
106760: ARRAY
106761: PUSH
106762: LD_INT 2
106764: ARRAY
106765: STR
106766: PUSH
106767: LD_STRING ,
106769: STR
106770: PUSH
106771: LD_VAR 0 3
106775: PUSH
106776: LD_VAR 0 2
106780: ARRAY
106781: PUSH
106782: LD_INT 3
106784: ARRAY
106785: STR
106786: PUSH
106787: LD_STRING ,
106789: STR
106790: PUSH
106791: LD_VAR 0 3
106795: PUSH
106796: LD_VAR 0 2
106800: ARRAY
106801: PUSH
106802: LD_INT 4
106804: ARRAY
106805: STR
106806: PUSH
106807: LD_STRING )
106809: STR
106810: PPUSH
106811: CALL_OW 559
106815: GO 106725
106817: POP
106818: POP
// end ; end ;
106819: LD_VAR 0 1
106823: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
106824: LD_INT 0
106826: PPUSH
// if HexInfo ( x , y ) = warehouse then
106827: LD_VAR 0 2
106831: PPUSH
106832: LD_VAR 0 3
106836: PPUSH
106837: CALL_OW 428
106841: PUSH
106842: LD_VAR 0 1
106846: EQUAL
106847: IFFALSE 106874
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
106849: LD_ADDR_EXP 155
106853: PUSH
106854: LD_EXP 155
106858: PPUSH
106859: LD_VAR 0 1
106863: PPUSH
106864: LD_INT 0
106866: PPUSH
106867: CALL_OW 1
106871: ST_TO_ADDR
106872: GO 106925
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
106874: LD_ADDR_EXP 155
106878: PUSH
106879: LD_EXP 155
106883: PPUSH
106884: LD_VAR 0 1
106888: PPUSH
106889: LD_VAR 0 1
106893: PPUSH
106894: CALL_OW 255
106898: PUSH
106899: LD_VAR 0 1
106903: PUSH
106904: LD_VAR 0 2
106908: PUSH
106909: LD_VAR 0 3
106913: PUSH
106914: EMPTY
106915: LIST
106916: LIST
106917: LIST
106918: LIST
106919: PPUSH
106920: CALL_OW 1
106924: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
106925: CALL 106934 0 0
// end ;
106929: LD_VAR 0 4
106933: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
106934: LD_INT 0
106936: PPUSH
106937: PPUSH
106938: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
106939: LD_STRING resetWarehouseGatheringPoints();
106941: PPUSH
106942: CALL_OW 559
// if warehouseGatheringPoints then
106946: LD_EXP 155
106950: IFFALSE 107076
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
106952: LD_ADDR_VAR 0 3
106956: PUSH
106957: LD_EXP 155
106961: PPUSH
106962: CALL 90632 0 1
106966: ST_TO_ADDR
// for i := 1 to list do
106967: LD_ADDR_VAR 0 2
106971: PUSH
106972: DOUBLE
106973: LD_INT 1
106975: DEC
106976: ST_TO_ADDR
106977: LD_VAR 0 3
106981: PUSH
106982: FOR_TO
106983: IFFALSE 107074
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
106985: LD_STRING setWarehouseGatheringPointXY(
106987: PUSH
106988: LD_VAR 0 3
106992: PUSH
106993: LD_VAR 0 2
106997: ARRAY
106998: PUSH
106999: LD_INT 1
107001: ARRAY
107002: STR
107003: PUSH
107004: LD_STRING ,
107006: STR
107007: PUSH
107008: LD_VAR 0 3
107012: PUSH
107013: LD_VAR 0 2
107017: ARRAY
107018: PUSH
107019: LD_INT 2
107021: ARRAY
107022: STR
107023: PUSH
107024: LD_STRING ,
107026: STR
107027: PUSH
107028: LD_VAR 0 3
107032: PUSH
107033: LD_VAR 0 2
107037: ARRAY
107038: PUSH
107039: LD_INT 3
107041: ARRAY
107042: STR
107043: PUSH
107044: LD_STRING ,
107046: STR
107047: PUSH
107048: LD_VAR 0 3
107052: PUSH
107053: LD_VAR 0 2
107057: ARRAY
107058: PUSH
107059: LD_INT 4
107061: ARRAY
107062: STR
107063: PUSH
107064: LD_STRING )
107066: STR
107067: PPUSH
107068: CALL_OW 559
107072: GO 106982
107074: POP
107075: POP
// end ; end ;
107076: LD_VAR 0 1
107080: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
107081: LD_EXP 155
107085: IFFALSE 107770
107087: GO 107089
107089: DISABLE
107090: LD_INT 0
107092: PPUSH
107093: PPUSH
107094: PPUSH
107095: PPUSH
107096: PPUSH
107097: PPUSH
107098: PPUSH
107099: PPUSH
107100: PPUSH
// begin enable ;
107101: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
107102: LD_ADDR_VAR 0 3
107106: PUSH
107107: LD_EXP 155
107111: PPUSH
107112: CALL 90632 0 1
107116: ST_TO_ADDR
// if not list then
107117: LD_VAR 0 3
107121: NOT
107122: IFFALSE 107126
// exit ;
107124: GO 107770
// for i := 1 to list do
107126: LD_ADDR_VAR 0 1
107130: PUSH
107131: DOUBLE
107132: LD_INT 1
107134: DEC
107135: ST_TO_ADDR
107136: LD_VAR 0 3
107140: PUSH
107141: FOR_TO
107142: IFFALSE 107768
// begin depot := list [ i ] [ 2 ] ;
107144: LD_ADDR_VAR 0 8
107148: PUSH
107149: LD_VAR 0 3
107153: PUSH
107154: LD_VAR 0 1
107158: ARRAY
107159: PUSH
107160: LD_INT 2
107162: ARRAY
107163: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
107164: LD_ADDR_VAR 0 5
107168: PUSH
107169: LD_VAR 0 3
107173: PUSH
107174: LD_VAR 0 1
107178: ARRAY
107179: PUSH
107180: LD_INT 1
107182: ARRAY
107183: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
107184: LD_VAR 0 8
107188: PPUSH
107189: CALL_OW 301
107193: PUSH
107194: LD_VAR 0 5
107198: PUSH
107199: LD_VAR 0 8
107203: PPUSH
107204: CALL_OW 255
107208: NONEQUAL
107209: OR
107210: IFFALSE 107239
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
107212: LD_ADDR_EXP 155
107216: PUSH
107217: LD_EXP 155
107221: PPUSH
107222: LD_VAR 0 8
107226: PPUSH
107227: LD_INT 0
107229: PPUSH
107230: CALL_OW 1
107234: ST_TO_ADDR
// exit ;
107235: POP
107236: POP
107237: GO 107770
// end ; x := list [ i ] [ 3 ] ;
107239: LD_ADDR_VAR 0 6
107243: PUSH
107244: LD_VAR 0 3
107248: PUSH
107249: LD_VAR 0 1
107253: ARRAY
107254: PUSH
107255: LD_INT 3
107257: ARRAY
107258: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
107259: LD_ADDR_VAR 0 7
107263: PUSH
107264: LD_VAR 0 3
107268: PUSH
107269: LD_VAR 0 1
107273: ARRAY
107274: PUSH
107275: LD_INT 4
107277: ARRAY
107278: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
107279: LD_ADDR_VAR 0 9
107283: PUSH
107284: LD_VAR 0 6
107288: PPUSH
107289: LD_VAR 0 7
107293: PPUSH
107294: LD_INT 16
107296: PPUSH
107297: CALL 89220 0 3
107301: ST_TO_ADDR
// if not cratesNearbyPoint then
107302: LD_VAR 0 9
107306: NOT
107307: IFFALSE 107313
// exit ;
107309: POP
107310: POP
107311: GO 107770
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
107313: LD_ADDR_VAR 0 4
107317: PUSH
107318: LD_INT 22
107320: PUSH
107321: LD_VAR 0 5
107325: PUSH
107326: EMPTY
107327: LIST
107328: LIST
107329: PUSH
107330: LD_INT 3
107332: PUSH
107333: LD_INT 60
107335: PUSH
107336: EMPTY
107337: LIST
107338: PUSH
107339: EMPTY
107340: LIST
107341: LIST
107342: PUSH
107343: LD_INT 91
107345: PUSH
107346: LD_VAR 0 8
107350: PUSH
107351: LD_INT 6
107353: PUSH
107354: EMPTY
107355: LIST
107356: LIST
107357: LIST
107358: PUSH
107359: LD_INT 2
107361: PUSH
107362: LD_INT 25
107364: PUSH
107365: LD_INT 2
107367: PUSH
107368: EMPTY
107369: LIST
107370: LIST
107371: PUSH
107372: LD_INT 25
107374: PUSH
107375: LD_INT 16
107377: PUSH
107378: EMPTY
107379: LIST
107380: LIST
107381: PUSH
107382: EMPTY
107383: LIST
107384: LIST
107385: LIST
107386: PUSH
107387: EMPTY
107388: LIST
107389: LIST
107390: LIST
107391: LIST
107392: PPUSH
107393: CALL_OW 69
107397: PUSH
107398: LD_VAR 0 8
107402: PPUSH
107403: CALL_OW 313
107407: PPUSH
107408: LD_INT 3
107410: PUSH
107411: LD_INT 60
107413: PUSH
107414: EMPTY
107415: LIST
107416: PUSH
107417: EMPTY
107418: LIST
107419: LIST
107420: PUSH
107421: LD_INT 2
107423: PUSH
107424: LD_INT 25
107426: PUSH
107427: LD_INT 2
107429: PUSH
107430: EMPTY
107431: LIST
107432: LIST
107433: PUSH
107434: LD_INT 25
107436: PUSH
107437: LD_INT 16
107439: PUSH
107440: EMPTY
107441: LIST
107442: LIST
107443: PUSH
107444: EMPTY
107445: LIST
107446: LIST
107447: LIST
107448: PUSH
107449: EMPTY
107450: LIST
107451: LIST
107452: PPUSH
107453: CALL_OW 72
107457: UNION
107458: ST_TO_ADDR
// if tmp then
107459: LD_VAR 0 4
107463: IFFALSE 107543
// begin tmp := ShrinkArray ( tmp , 3 ) ;
107465: LD_ADDR_VAR 0 4
107469: PUSH
107470: LD_VAR 0 4
107474: PPUSH
107475: LD_INT 3
107477: PPUSH
107478: CALL 87189 0 2
107482: ST_TO_ADDR
// for j in tmp do
107483: LD_ADDR_VAR 0 2
107487: PUSH
107488: LD_VAR 0 4
107492: PUSH
107493: FOR_IN
107494: IFFALSE 107537
// begin if IsInUnit ( j ) then
107496: LD_VAR 0 2
107500: PPUSH
107501: CALL_OW 310
107505: IFFALSE 107516
// ComExit ( j ) ;
107507: LD_VAR 0 2
107511: PPUSH
107512: CALL 87272 0 1
// AddComCollect ( j , x , y ) ;
107516: LD_VAR 0 2
107520: PPUSH
107521: LD_VAR 0 6
107525: PPUSH
107526: LD_VAR 0 7
107530: PPUSH
107531: CALL_OW 177
// end ;
107535: GO 107493
107537: POP
107538: POP
// exit ;
107539: POP
107540: POP
107541: GO 107770
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
107543: LD_ADDR_VAR 0 4
107547: PUSH
107548: LD_INT 22
107550: PUSH
107551: LD_VAR 0 5
107555: PUSH
107556: EMPTY
107557: LIST
107558: LIST
107559: PUSH
107560: LD_INT 91
107562: PUSH
107563: LD_VAR 0 8
107567: PUSH
107568: LD_INT 8
107570: PUSH
107571: EMPTY
107572: LIST
107573: LIST
107574: LIST
107575: PUSH
107576: LD_INT 2
107578: PUSH
107579: LD_INT 34
107581: PUSH
107582: LD_INT 12
107584: PUSH
107585: EMPTY
107586: LIST
107587: LIST
107588: PUSH
107589: LD_INT 34
107591: PUSH
107592: LD_INT 51
107594: PUSH
107595: EMPTY
107596: LIST
107597: LIST
107598: PUSH
107599: LD_INT 34
107601: PUSH
107602: LD_INT 32
107604: PUSH
107605: EMPTY
107606: LIST
107607: LIST
107608: PUSH
107609: LD_INT 34
107611: PUSH
107612: LD_INT 89
107614: PUSH
107615: EMPTY
107616: LIST
107617: LIST
107618: PUSH
107619: EMPTY
107620: LIST
107621: LIST
107622: LIST
107623: LIST
107624: LIST
107625: PUSH
107626: EMPTY
107627: LIST
107628: LIST
107629: LIST
107630: PPUSH
107631: CALL_OW 69
107635: ST_TO_ADDR
// if tmp then
107636: LD_VAR 0 4
107640: IFFALSE 107766
// begin for j in tmp do
107642: LD_ADDR_VAR 0 2
107646: PUSH
107647: LD_VAR 0 4
107651: PUSH
107652: FOR_IN
107653: IFFALSE 107764
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
107655: LD_VAR 0 2
107659: PPUSH
107660: CALL_OW 262
107664: PUSH
107665: LD_INT 3
107667: EQUAL
107668: PUSH
107669: LD_VAR 0 2
107673: PPUSH
107674: CALL_OW 261
107678: PUSH
107679: LD_INT 20
107681: GREATER
107682: OR
107683: PUSH
107684: LD_VAR 0 2
107688: PPUSH
107689: CALL_OW 314
107693: NOT
107694: AND
107695: PUSH
107696: LD_VAR 0 2
107700: PPUSH
107701: CALL_OW 263
107705: PUSH
107706: LD_INT 1
107708: NONEQUAL
107709: PUSH
107710: LD_VAR 0 2
107714: PPUSH
107715: CALL_OW 311
107719: OR
107720: AND
107721: IFFALSE 107762
// begin ComCollect ( j , x , y ) ;
107723: LD_VAR 0 2
107727: PPUSH
107728: LD_VAR 0 6
107732: PPUSH
107733: LD_VAR 0 7
107737: PPUSH
107738: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
107742: LD_VAR 0 2
107746: PPUSH
107747: LD_VAR 0 8
107751: PPUSH
107752: CALL_OW 172
// exit ;
107756: POP
107757: POP
107758: POP
107759: POP
107760: GO 107770
// end ;
107762: GO 107652
107764: POP
107765: POP
// end ; end ;
107766: GO 107141
107768: POP
107769: POP
// end ; end_of_file
107770: PPOPN 9
107772: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
107773: LD_INT 0
107775: PPUSH
107776: PPUSH
107777: PPUSH
107778: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
107779: LD_VAR 0 1
107783: PPUSH
107784: CALL_OW 264
107788: PUSH
107789: LD_INT 91
107791: EQUAL
107792: IFFALSE 107864
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
107794: LD_INT 68
107796: PPUSH
107797: LD_VAR 0 1
107801: PPUSH
107802: CALL_OW 255
107806: PPUSH
107807: CALL_OW 321
107811: PUSH
107812: LD_INT 2
107814: EQUAL
107815: IFFALSE 107827
// eff := 70 else
107817: LD_ADDR_VAR 0 4
107821: PUSH
107822: LD_INT 70
107824: ST_TO_ADDR
107825: GO 107835
// eff := 30 ;
107827: LD_ADDR_VAR 0 4
107831: PUSH
107832: LD_INT 30
107834: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
107835: LD_VAR 0 1
107839: PPUSH
107840: CALL_OW 250
107844: PPUSH
107845: LD_VAR 0 1
107849: PPUSH
107850: CALL_OW 251
107854: PPUSH
107855: LD_VAR 0 4
107859: PPUSH
107860: CALL_OW 495
// end ; end ;
107864: LD_VAR 0 2
107868: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
107869: LD_INT 0
107871: PPUSH
// end ;
107872: LD_VAR 0 4
107876: RET
// export function SOS_Command ( cmd ) ; begin
107877: LD_INT 0
107879: PPUSH
// end ;
107880: LD_VAR 0 2
107884: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
107885: LD_INT 0
107887: PPUSH
// end ;
107888: LD_VAR 0 6
107892: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
107893: LD_INT 0
107895: PPUSH
107896: PPUSH
// if not vehicle or not factory then
107897: LD_VAR 0 1
107901: NOT
107902: PUSH
107903: LD_VAR 0 2
107907: NOT
107908: OR
107909: IFFALSE 107913
// exit ;
107911: GO 108144
// if factoryWaypoints >= factory then
107913: LD_EXP 154
107917: PUSH
107918: LD_VAR 0 2
107922: GREATEREQUAL
107923: IFFALSE 108144
// if factoryWaypoints [ factory ] then
107925: LD_EXP 154
107929: PUSH
107930: LD_VAR 0 2
107934: ARRAY
107935: IFFALSE 108144
// begin if GetControl ( vehicle ) = control_manual then
107937: LD_VAR 0 1
107941: PPUSH
107942: CALL_OW 263
107946: PUSH
107947: LD_INT 1
107949: EQUAL
107950: IFFALSE 108031
// begin driver := IsDrivenBy ( vehicle ) ;
107952: LD_ADDR_VAR 0 4
107956: PUSH
107957: LD_VAR 0 1
107961: PPUSH
107962: CALL_OW 311
107966: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
107967: LD_VAR 0 4
107971: PPUSH
107972: LD_EXP 154
107976: PUSH
107977: LD_VAR 0 2
107981: ARRAY
107982: PUSH
107983: LD_INT 3
107985: ARRAY
107986: PPUSH
107987: LD_EXP 154
107991: PUSH
107992: LD_VAR 0 2
107996: ARRAY
107997: PUSH
107998: LD_INT 4
108000: ARRAY
108001: PPUSH
108002: CALL_OW 171
// AddComExitVehicle ( driver ) ;
108006: LD_VAR 0 4
108010: PPUSH
108011: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
108015: LD_VAR 0 4
108019: PPUSH
108020: LD_VAR 0 2
108024: PPUSH
108025: CALL_OW 180
// end else
108029: GO 108144
// if GetControl ( vehicle ) = control_remote then
108031: LD_VAR 0 1
108035: PPUSH
108036: CALL_OW 263
108040: PUSH
108041: LD_INT 2
108043: EQUAL
108044: IFFALSE 108105
// begin wait ( 0 0$2 ) ;
108046: LD_INT 70
108048: PPUSH
108049: CALL_OW 67
// if Connect ( vehicle ) then
108053: LD_VAR 0 1
108057: PPUSH
108058: CALL 57491 0 1
108062: IFFALSE 108103
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
108064: LD_VAR 0 1
108068: PPUSH
108069: LD_EXP 154
108073: PUSH
108074: LD_VAR 0 2
108078: ARRAY
108079: PUSH
108080: LD_INT 3
108082: ARRAY
108083: PPUSH
108084: LD_EXP 154
108088: PUSH
108089: LD_VAR 0 2
108093: ARRAY
108094: PUSH
108095: LD_INT 4
108097: ARRAY
108098: PPUSH
108099: CALL_OW 171
// end else
108103: GO 108144
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
108105: LD_VAR 0 1
108109: PPUSH
108110: LD_EXP 154
108114: PUSH
108115: LD_VAR 0 2
108119: ARRAY
108120: PUSH
108121: LD_INT 3
108123: ARRAY
108124: PPUSH
108125: LD_EXP 154
108129: PUSH
108130: LD_VAR 0 2
108134: ARRAY
108135: PUSH
108136: LD_INT 4
108138: ARRAY
108139: PPUSH
108140: CALL_OW 171
// end ; end ;
108144: LD_VAR 0 3
108148: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
108149: LD_INT 0
108151: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
108152: LD_VAR 0 1
108156: PUSH
108157: LD_INT 250
108159: EQUAL
108160: PUSH
108161: LD_VAR 0 2
108165: PPUSH
108166: CALL_OW 264
108170: PUSH
108171: LD_INT 81
108173: EQUAL
108174: AND
108175: IFFALSE 108196
// MinerPlaceMine ( unit , x , y ) ;
108177: LD_VAR 0 2
108181: PPUSH
108182: LD_VAR 0 4
108186: PPUSH
108187: LD_VAR 0 5
108191: PPUSH
108192: CALL 111186 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
108196: LD_VAR 0 1
108200: PUSH
108201: LD_INT 251
108203: EQUAL
108204: PUSH
108205: LD_VAR 0 2
108209: PPUSH
108210: CALL_OW 264
108214: PUSH
108215: LD_INT 81
108217: EQUAL
108218: AND
108219: IFFALSE 108240
// MinerDetonateMine ( unit , x , y ) ;
108221: LD_VAR 0 2
108225: PPUSH
108226: LD_VAR 0 4
108230: PPUSH
108231: LD_VAR 0 5
108235: PPUSH
108236: CALL 111461 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
108240: LD_VAR 0 1
108244: PUSH
108245: LD_INT 252
108247: EQUAL
108248: PUSH
108249: LD_VAR 0 2
108253: PPUSH
108254: CALL_OW 264
108258: PUSH
108259: LD_INT 81
108261: EQUAL
108262: AND
108263: IFFALSE 108284
// MinerCreateMinefield ( unit , x , y ) ;
108265: LD_VAR 0 2
108269: PPUSH
108270: LD_VAR 0 4
108274: PPUSH
108275: LD_VAR 0 5
108279: PPUSH
108280: CALL 111878 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
108284: LD_VAR 0 1
108288: PUSH
108289: LD_INT 253
108291: EQUAL
108292: PUSH
108293: LD_VAR 0 2
108297: PPUSH
108298: CALL_OW 257
108302: PUSH
108303: LD_INT 5
108305: EQUAL
108306: AND
108307: IFFALSE 108328
// ComBinocular ( unit , x , y ) ;
108309: LD_VAR 0 2
108313: PPUSH
108314: LD_VAR 0 4
108318: PPUSH
108319: LD_VAR 0 5
108323: PPUSH
108324: CALL 112247 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
108328: LD_VAR 0 1
108332: PUSH
108333: LD_INT 254
108335: EQUAL
108336: PUSH
108337: LD_VAR 0 2
108341: PPUSH
108342: CALL_OW 264
108346: PUSH
108347: LD_INT 99
108349: EQUAL
108350: AND
108351: PUSH
108352: LD_VAR 0 3
108356: PPUSH
108357: CALL_OW 263
108361: PUSH
108362: LD_INT 3
108364: EQUAL
108365: AND
108366: IFFALSE 108382
// HackDestroyVehicle ( unit , selectedUnit ) ;
108368: LD_VAR 0 2
108372: PPUSH
108373: LD_VAR 0 3
108377: PPUSH
108378: CALL 110550 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
108382: LD_VAR 0 1
108386: PUSH
108387: LD_INT 255
108389: EQUAL
108390: PUSH
108391: LD_VAR 0 2
108395: PPUSH
108396: CALL_OW 264
108400: PUSH
108401: LD_INT 14
108403: PUSH
108404: LD_INT 53
108406: PUSH
108407: EMPTY
108408: LIST
108409: LIST
108410: IN
108411: AND
108412: PUSH
108413: LD_VAR 0 4
108417: PPUSH
108418: LD_VAR 0 5
108422: PPUSH
108423: CALL_OW 488
108427: AND
108428: IFFALSE 108452
// CutTreeXYR ( unit , x , y , 12 ) ;
108430: LD_VAR 0 2
108434: PPUSH
108435: LD_VAR 0 4
108439: PPUSH
108440: LD_VAR 0 5
108444: PPUSH
108445: LD_INT 12
108447: PPUSH
108448: CALL 108547 0 4
// if cmd = 256 then
108452: LD_VAR 0 1
108456: PUSH
108457: LD_INT 256
108459: EQUAL
108460: IFFALSE 108481
// SetFactoryWaypoint ( unit , x , y ) ;
108462: LD_VAR 0 2
108466: PPUSH
108467: LD_VAR 0 4
108471: PPUSH
108472: LD_VAR 0 5
108476: PPUSH
108477: CALL 106462 0 3
// if cmd = 257 then
108481: LD_VAR 0 1
108485: PUSH
108486: LD_INT 257
108488: EQUAL
108489: IFFALSE 108510
// SetWarehouseGatheringPoint ( unit , x , y ) ;
108491: LD_VAR 0 2
108495: PPUSH
108496: LD_VAR 0 4
108500: PPUSH
108501: LD_VAR 0 5
108505: PPUSH
108506: CALL 106824 0 3
// if cmd = 258 then
108510: LD_VAR 0 1
108514: PUSH
108515: LD_INT 258
108517: EQUAL
108518: IFFALSE 108542
// BurnTreeXYR ( unit , x , y , 8 ) ;
108520: LD_VAR 0 2
108524: PPUSH
108525: LD_VAR 0 4
108529: PPUSH
108530: LD_VAR 0 5
108534: PPUSH
108535: LD_INT 8
108537: PPUSH
108538: CALL 108941 0 4
// end ;
108542: LD_VAR 0 6
108546: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
108547: LD_INT 0
108549: PPUSH
108550: PPUSH
108551: PPUSH
108552: PPUSH
108553: PPUSH
108554: PPUSH
108555: PPUSH
108556: PPUSH
108557: PPUSH
// if not IsOk ( bulldozer ) or not ValidHex ( x , y ) or not r then
108558: LD_VAR 0 1
108562: PPUSH
108563: CALL_OW 302
108567: NOT
108568: PUSH
108569: LD_VAR 0 2
108573: PPUSH
108574: LD_VAR 0 3
108578: PPUSH
108579: CALL_OW 488
108583: NOT
108584: OR
108585: PUSH
108586: LD_VAR 0 4
108590: NOT
108591: OR
108592: IFFALSE 108596
// exit ;
108594: GO 108936
// list := [ ] ;
108596: LD_ADDR_VAR 0 13
108600: PUSH
108601: EMPTY
108602: ST_TO_ADDR
// if x - r < 0 then
108603: LD_VAR 0 2
108607: PUSH
108608: LD_VAR 0 4
108612: MINUS
108613: PUSH
108614: LD_INT 0
108616: LESS
108617: IFFALSE 108629
// min_x := 0 else
108619: LD_ADDR_VAR 0 7
108623: PUSH
108624: LD_INT 0
108626: ST_TO_ADDR
108627: GO 108645
// min_x := x - r ;
108629: LD_ADDR_VAR 0 7
108633: PUSH
108634: LD_VAR 0 2
108638: PUSH
108639: LD_VAR 0 4
108643: MINUS
108644: ST_TO_ADDR
// if y - r < 0 then
108645: LD_VAR 0 3
108649: PUSH
108650: LD_VAR 0 4
108654: MINUS
108655: PUSH
108656: LD_INT 0
108658: LESS
108659: IFFALSE 108671
// min_y := 0 else
108661: LD_ADDR_VAR 0 8
108665: PUSH
108666: LD_INT 0
108668: ST_TO_ADDR
108669: GO 108687
// min_y := y - r ;
108671: LD_ADDR_VAR 0 8
108675: PUSH
108676: LD_VAR 0 3
108680: PUSH
108681: LD_VAR 0 4
108685: MINUS
108686: ST_TO_ADDR
// max_x := x + r ;
108687: LD_ADDR_VAR 0 9
108691: PUSH
108692: LD_VAR 0 2
108696: PUSH
108697: LD_VAR 0 4
108701: PLUS
108702: ST_TO_ADDR
// max_y := y + r ;
108703: LD_ADDR_VAR 0 10
108707: PUSH
108708: LD_VAR 0 3
108712: PUSH
108713: LD_VAR 0 4
108717: PLUS
108718: ST_TO_ADDR
// for _x = min_x to max_x do
108719: LD_ADDR_VAR 0 11
108723: PUSH
108724: DOUBLE
108725: LD_VAR 0 7
108729: DEC
108730: ST_TO_ADDR
108731: LD_VAR 0 9
108735: PUSH
108736: FOR_TO
108737: IFFALSE 108854
// for _y = min_y to max_y do
108739: LD_ADDR_VAR 0 12
108743: PUSH
108744: DOUBLE
108745: LD_VAR 0 8
108749: DEC
108750: ST_TO_ADDR
108751: LD_VAR 0 10
108755: PUSH
108756: FOR_TO
108757: IFFALSE 108850
// begin if not ValidHex ( _x , _y ) then
108759: LD_VAR 0 11
108763: PPUSH
108764: LD_VAR 0 12
108768: PPUSH
108769: CALL_OW 488
108773: NOT
108774: IFFALSE 108778
// continue ;
108776: GO 108756
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
108778: LD_VAR 0 11
108782: PPUSH
108783: LD_VAR 0 12
108787: PPUSH
108788: CALL_OW 351
108792: PUSH
108793: LD_VAR 0 11
108797: PPUSH
108798: LD_VAR 0 12
108802: PPUSH
108803: CALL_OW 554
108807: AND
108808: IFFALSE 108848
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
108810: LD_ADDR_VAR 0 13
108814: PUSH
108815: LD_VAR 0 13
108819: PPUSH
108820: LD_VAR 0 13
108824: PUSH
108825: LD_INT 1
108827: PLUS
108828: PPUSH
108829: LD_VAR 0 11
108833: PUSH
108834: LD_VAR 0 12
108838: PUSH
108839: EMPTY
108840: LIST
108841: LIST
108842: PPUSH
108843: CALL_OW 2
108847: ST_TO_ADDR
// end ;
108848: GO 108756
108850: POP
108851: POP
108852: GO 108736
108854: POP
108855: POP
// if not list then
108856: LD_VAR 0 13
108860: NOT
108861: IFFALSE 108865
// exit ;
108863: GO 108936
// for i in list do
108865: LD_ADDR_VAR 0 6
108869: PUSH
108870: LD_VAR 0 13
108874: PUSH
108875: FOR_IN
108876: IFFALSE 108934
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
108878: LD_VAR 0 1
108882: PPUSH
108883: LD_STRING M
108885: PUSH
108886: LD_VAR 0 6
108890: PUSH
108891: LD_INT 1
108893: ARRAY
108894: PUSH
108895: LD_VAR 0 6
108899: PUSH
108900: LD_INT 2
108902: ARRAY
108903: PUSH
108904: LD_INT 0
108906: PUSH
108907: LD_INT 0
108909: PUSH
108910: LD_INT 0
108912: PUSH
108913: LD_INT 0
108915: PUSH
108916: EMPTY
108917: LIST
108918: LIST
108919: LIST
108920: LIST
108921: LIST
108922: LIST
108923: LIST
108924: PUSH
108925: EMPTY
108926: LIST
108927: PPUSH
108928: CALL_OW 447
108932: GO 108875
108934: POP
108935: POP
// end ;
108936: LD_VAR 0 5
108940: RET
// function BurnTreeXYR ( flame , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list , task ; begin
108941: LD_INT 0
108943: PPUSH
108944: PPUSH
108945: PPUSH
108946: PPUSH
108947: PPUSH
108948: PPUSH
108949: PPUSH
108950: PPUSH
108951: PPUSH
108952: PPUSH
// if not IsOk ( flame ) or not ValidHex ( x , y ) or not r then
108953: LD_VAR 0 1
108957: PPUSH
108958: CALL_OW 302
108962: NOT
108963: PUSH
108964: LD_VAR 0 2
108968: PPUSH
108969: LD_VAR 0 3
108973: PPUSH
108974: CALL_OW 488
108978: NOT
108979: OR
108980: PUSH
108981: LD_VAR 0 4
108985: NOT
108986: OR
108987: IFFALSE 108991
// exit ;
108989: GO 109504
// list := [ ] ;
108991: LD_ADDR_VAR 0 13
108995: PUSH
108996: EMPTY
108997: ST_TO_ADDR
// if x - r < 0 then
108998: LD_VAR 0 2
109002: PUSH
109003: LD_VAR 0 4
109007: MINUS
109008: PUSH
109009: LD_INT 0
109011: LESS
109012: IFFALSE 109024
// min_x := 0 else
109014: LD_ADDR_VAR 0 7
109018: PUSH
109019: LD_INT 0
109021: ST_TO_ADDR
109022: GO 109040
// min_x := x - r ;
109024: LD_ADDR_VAR 0 7
109028: PUSH
109029: LD_VAR 0 2
109033: PUSH
109034: LD_VAR 0 4
109038: MINUS
109039: ST_TO_ADDR
// if y - r < 0 then
109040: LD_VAR 0 3
109044: PUSH
109045: LD_VAR 0 4
109049: MINUS
109050: PUSH
109051: LD_INT 0
109053: LESS
109054: IFFALSE 109066
// min_y := 0 else
109056: LD_ADDR_VAR 0 8
109060: PUSH
109061: LD_INT 0
109063: ST_TO_ADDR
109064: GO 109082
// min_y := y - r ;
109066: LD_ADDR_VAR 0 8
109070: PUSH
109071: LD_VAR 0 3
109075: PUSH
109076: LD_VAR 0 4
109080: MINUS
109081: ST_TO_ADDR
// max_x := x + r ;
109082: LD_ADDR_VAR 0 9
109086: PUSH
109087: LD_VAR 0 2
109091: PUSH
109092: LD_VAR 0 4
109096: PLUS
109097: ST_TO_ADDR
// max_y := y + r ;
109098: LD_ADDR_VAR 0 10
109102: PUSH
109103: LD_VAR 0 3
109107: PUSH
109108: LD_VAR 0 4
109112: PLUS
109113: ST_TO_ADDR
// for _x = min_x to max_x do
109114: LD_ADDR_VAR 0 11
109118: PUSH
109119: DOUBLE
109120: LD_VAR 0 7
109124: DEC
109125: ST_TO_ADDR
109126: LD_VAR 0 9
109130: PUSH
109131: FOR_TO
109132: IFFALSE 109249
// for _y = min_y to max_y do
109134: LD_ADDR_VAR 0 12
109138: PUSH
109139: DOUBLE
109140: LD_VAR 0 8
109144: DEC
109145: ST_TO_ADDR
109146: LD_VAR 0 10
109150: PUSH
109151: FOR_TO
109152: IFFALSE 109245
// begin if not ValidHex ( _x , _y ) then
109154: LD_VAR 0 11
109158: PPUSH
109159: LD_VAR 0 12
109163: PPUSH
109164: CALL_OW 488
109168: NOT
109169: IFFALSE 109173
// continue ;
109171: GO 109151
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
109173: LD_VAR 0 11
109177: PPUSH
109178: LD_VAR 0 12
109182: PPUSH
109183: CALL_OW 351
109187: PUSH
109188: LD_VAR 0 11
109192: PPUSH
109193: LD_VAR 0 12
109197: PPUSH
109198: CALL_OW 554
109202: AND
109203: IFFALSE 109243
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
109205: LD_ADDR_VAR 0 13
109209: PUSH
109210: LD_VAR 0 13
109214: PPUSH
109215: LD_VAR 0 13
109219: PUSH
109220: LD_INT 1
109222: PLUS
109223: PPUSH
109224: LD_VAR 0 11
109228: PUSH
109229: LD_VAR 0 12
109233: PUSH
109234: EMPTY
109235: LIST
109236: LIST
109237: PPUSH
109238: CALL_OW 2
109242: ST_TO_ADDR
// end ;
109243: GO 109151
109245: POP
109246: POP
109247: GO 109131
109249: POP
109250: POP
// if not list then
109251: LD_VAR 0 13
109255: NOT
109256: IFFALSE 109260
// exit ;
109258: GO 109504
// list := SortHexesByDistanceFromUnit ( flame , list , true , true ) ;
109260: LD_ADDR_VAR 0 13
109264: PUSH
109265: LD_VAR 0 1
109269: PPUSH
109270: LD_VAR 0 13
109274: PPUSH
109275: LD_INT 1
109277: PPUSH
109278: LD_INT 1
109280: PPUSH
109281: CALL 54633 0 4
109285: ST_TO_ADDR
// ComStop ( flame ) ;
109286: LD_VAR 0 1
109290: PPUSH
109291: CALL_OW 141
// for i in list do
109295: LD_ADDR_VAR 0 6
109299: PUSH
109300: LD_VAR 0 13
109304: PUSH
109305: FOR_IN
109306: IFFALSE 109337
// AddComAttackPlace ( flame , i [ 1 ] , i [ 2 ] ) ;
109308: LD_VAR 0 1
109312: PPUSH
109313: LD_VAR 0 6
109317: PUSH
109318: LD_INT 1
109320: ARRAY
109321: PPUSH
109322: LD_VAR 0 6
109326: PUSH
109327: LD_INT 2
109329: ARRAY
109330: PPUSH
109331: CALL_OW 176
109335: GO 109305
109337: POP
109338: POP
// repeat wait ( 0 0$1 ) ;
109339: LD_INT 35
109341: PPUSH
109342: CALL_OW 67
// task := GetTaskList ( flame ) ;
109346: LD_ADDR_VAR 0 14
109350: PUSH
109351: LD_VAR 0 1
109355: PPUSH
109356: CALL_OW 437
109360: ST_TO_ADDR
// if not task then
109361: LD_VAR 0 14
109365: NOT
109366: IFFALSE 109370
// exit ;
109368: GO 109504
// if task [ 1 ] [ 1 ] <> | then
109370: LD_VAR 0 14
109374: PUSH
109375: LD_INT 1
109377: ARRAY
109378: PUSH
109379: LD_INT 1
109381: ARRAY
109382: PUSH
109383: LD_STRING |
109385: NONEQUAL
109386: IFFALSE 109390
// exit ;
109388: GO 109504
// _x := task [ 1 ] [ 2 ] ;
109390: LD_ADDR_VAR 0 11
109394: PUSH
109395: LD_VAR 0 14
109399: PUSH
109400: LD_INT 1
109402: ARRAY
109403: PUSH
109404: LD_INT 2
109406: ARRAY
109407: ST_TO_ADDR
// _y := task [ 1 ] [ 3 ] ;
109408: LD_ADDR_VAR 0 12
109412: PUSH
109413: LD_VAR 0 14
109417: PUSH
109418: LD_INT 1
109420: ARRAY
109421: PUSH
109422: LD_INT 3
109424: ARRAY
109425: ST_TO_ADDR
// if not IsEnvironment ( _x , _y ) or not IsEnvironmentDestroyable ( _x , _y ) then
109426: LD_VAR 0 11
109430: PPUSH
109431: LD_VAR 0 12
109435: PPUSH
109436: CALL_OW 351
109440: NOT
109441: PUSH
109442: LD_VAR 0 11
109446: PPUSH
109447: LD_VAR 0 12
109451: PPUSH
109452: CALL_OW 554
109456: NOT
109457: OR
109458: IFFALSE 109492
// begin task := Delete ( task , 1 ) ;
109460: LD_ADDR_VAR 0 14
109464: PUSH
109465: LD_VAR 0 14
109469: PPUSH
109470: LD_INT 1
109472: PPUSH
109473: CALL_OW 3
109477: ST_TO_ADDR
// SetTaskList ( flame , task ) ;
109478: LD_VAR 0 1
109482: PPUSH
109483: LD_VAR 0 14
109487: PPUSH
109488: CALL_OW 446
// end ; until not HasTask ( flame ) ;
109492: LD_VAR 0 1
109496: PPUSH
109497: CALL_OW 314
109501: NOT
109502: IFFALSE 109339
// end ;
109504: LD_VAR 0 5
109508: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
109509: LD_EXP 157
109513: NOT
109514: IFFALSE 109564
109516: GO 109518
109518: DISABLE
// begin initHack := true ;
109519: LD_ADDR_EXP 157
109523: PUSH
109524: LD_INT 1
109526: ST_TO_ADDR
// hackTanks := [ ] ;
109527: LD_ADDR_EXP 158
109531: PUSH
109532: EMPTY
109533: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
109534: LD_ADDR_EXP 159
109538: PUSH
109539: EMPTY
109540: ST_TO_ADDR
// hackLimit := 3 ;
109541: LD_ADDR_EXP 160
109545: PUSH
109546: LD_INT 3
109548: ST_TO_ADDR
// hackDist := 12 ;
109549: LD_ADDR_EXP 161
109553: PUSH
109554: LD_INT 12
109556: ST_TO_ADDR
// hackCounter := [ ] ;
109557: LD_ADDR_EXP 162
109561: PUSH
109562: EMPTY
109563: ST_TO_ADDR
// end ;
109564: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
109565: LD_EXP 157
109569: PUSH
109570: LD_INT 34
109572: PUSH
109573: LD_INT 99
109575: PUSH
109576: EMPTY
109577: LIST
109578: LIST
109579: PPUSH
109580: CALL_OW 69
109584: AND
109585: IFFALSE 109838
109587: GO 109589
109589: DISABLE
109590: LD_INT 0
109592: PPUSH
109593: PPUSH
// begin enable ;
109594: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
109595: LD_ADDR_VAR 0 1
109599: PUSH
109600: LD_INT 34
109602: PUSH
109603: LD_INT 99
109605: PUSH
109606: EMPTY
109607: LIST
109608: LIST
109609: PPUSH
109610: CALL_OW 69
109614: PUSH
109615: FOR_IN
109616: IFFALSE 109836
// begin if not i in hackTanks then
109618: LD_VAR 0 1
109622: PUSH
109623: LD_EXP 158
109627: IN
109628: NOT
109629: IFFALSE 109712
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
109631: LD_ADDR_EXP 158
109635: PUSH
109636: LD_EXP 158
109640: PPUSH
109641: LD_EXP 158
109645: PUSH
109646: LD_INT 1
109648: PLUS
109649: PPUSH
109650: LD_VAR 0 1
109654: PPUSH
109655: CALL_OW 1
109659: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
109660: LD_ADDR_EXP 159
109664: PUSH
109665: LD_EXP 159
109669: PPUSH
109670: LD_EXP 159
109674: PUSH
109675: LD_INT 1
109677: PLUS
109678: PPUSH
109679: EMPTY
109680: PPUSH
109681: CALL_OW 1
109685: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
109686: LD_ADDR_EXP 162
109690: PUSH
109691: LD_EXP 162
109695: PPUSH
109696: LD_EXP 162
109700: PUSH
109701: LD_INT 1
109703: PLUS
109704: PPUSH
109705: EMPTY
109706: PPUSH
109707: CALL_OW 1
109711: ST_TO_ADDR
// end ; if not IsOk ( i ) then
109712: LD_VAR 0 1
109716: PPUSH
109717: CALL_OW 302
109721: NOT
109722: IFFALSE 109735
// begin HackUnlinkAll ( i ) ;
109724: LD_VAR 0 1
109728: PPUSH
109729: CALL 109841 0 1
// continue ;
109733: GO 109615
// end ; HackCheckCapturedStatus ( i ) ;
109735: LD_VAR 0 1
109739: PPUSH
109740: CALL 110284 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
109744: LD_ADDR_VAR 0 2
109748: PUSH
109749: LD_INT 81
109751: PUSH
109752: LD_VAR 0 1
109756: PPUSH
109757: CALL_OW 255
109761: PUSH
109762: EMPTY
109763: LIST
109764: LIST
109765: PUSH
109766: LD_INT 33
109768: PUSH
109769: LD_INT 3
109771: PUSH
109772: EMPTY
109773: LIST
109774: LIST
109775: PUSH
109776: LD_INT 91
109778: PUSH
109779: LD_VAR 0 1
109783: PUSH
109784: LD_EXP 161
109788: PUSH
109789: EMPTY
109790: LIST
109791: LIST
109792: LIST
109793: PUSH
109794: LD_INT 50
109796: PUSH
109797: EMPTY
109798: LIST
109799: PUSH
109800: EMPTY
109801: LIST
109802: LIST
109803: LIST
109804: LIST
109805: PPUSH
109806: CALL_OW 69
109810: ST_TO_ADDR
// if not tmp then
109811: LD_VAR 0 2
109815: NOT
109816: IFFALSE 109820
// continue ;
109818: GO 109615
// HackLink ( i , tmp ) ;
109820: LD_VAR 0 1
109824: PPUSH
109825: LD_VAR 0 2
109829: PPUSH
109830: CALL 109977 0 2
// end ;
109834: GO 109615
109836: POP
109837: POP
// end ;
109838: PPOPN 2
109840: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
109841: LD_INT 0
109843: PPUSH
109844: PPUSH
109845: PPUSH
// if not hack in hackTanks then
109846: LD_VAR 0 1
109850: PUSH
109851: LD_EXP 158
109855: IN
109856: NOT
109857: IFFALSE 109861
// exit ;
109859: GO 109972
// index := GetElementIndex ( hackTanks , hack ) ;
109861: LD_ADDR_VAR 0 4
109865: PUSH
109866: LD_EXP 158
109870: PPUSH
109871: LD_VAR 0 1
109875: PPUSH
109876: CALL 53930 0 2
109880: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
109881: LD_EXP 159
109885: PUSH
109886: LD_VAR 0 4
109890: ARRAY
109891: IFFALSE 109972
// begin for i in hackTanksCaptured [ index ] do
109893: LD_ADDR_VAR 0 3
109897: PUSH
109898: LD_EXP 159
109902: PUSH
109903: LD_VAR 0 4
109907: ARRAY
109908: PUSH
109909: FOR_IN
109910: IFFALSE 109936
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
109912: LD_VAR 0 3
109916: PUSH
109917: LD_INT 1
109919: ARRAY
109920: PPUSH
109921: LD_VAR 0 3
109925: PUSH
109926: LD_INT 2
109928: ARRAY
109929: PPUSH
109930: CALL_OW 235
109934: GO 109909
109936: POP
109937: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
109938: LD_ADDR_EXP 159
109942: PUSH
109943: LD_EXP 159
109947: PPUSH
109948: LD_VAR 0 4
109952: PPUSH
109953: EMPTY
109954: PPUSH
109955: CALL_OW 1
109959: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
109960: LD_VAR 0 1
109964: PPUSH
109965: LD_INT 0
109967: PPUSH
109968: CALL_OW 505
// end ; end ;
109972: LD_VAR 0 2
109976: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
109977: LD_INT 0
109979: PPUSH
109980: PPUSH
109981: PPUSH
// if not hack in hackTanks or not vehicles then
109982: LD_VAR 0 1
109986: PUSH
109987: LD_EXP 158
109991: IN
109992: NOT
109993: PUSH
109994: LD_VAR 0 2
109998: NOT
109999: OR
110000: IFFALSE 110004
// exit ;
110002: GO 110279
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
110004: LD_ADDR_VAR 0 2
110008: PUSH
110009: LD_VAR 0 1
110013: PPUSH
110014: LD_VAR 0 2
110018: PPUSH
110019: LD_INT 1
110021: PPUSH
110022: LD_INT 1
110024: PPUSH
110025: CALL 54580 0 4
110029: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
110030: LD_ADDR_VAR 0 5
110034: PUSH
110035: LD_EXP 158
110039: PPUSH
110040: LD_VAR 0 1
110044: PPUSH
110045: CALL 53930 0 2
110049: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
110050: LD_EXP 159
110054: PUSH
110055: LD_VAR 0 5
110059: ARRAY
110060: PUSH
110061: LD_EXP 160
110065: LESS
110066: IFFALSE 110255
// begin for i := 1 to vehicles do
110068: LD_ADDR_VAR 0 4
110072: PUSH
110073: DOUBLE
110074: LD_INT 1
110076: DEC
110077: ST_TO_ADDR
110078: LD_VAR 0 2
110082: PUSH
110083: FOR_TO
110084: IFFALSE 110253
// begin if hackTanksCaptured [ index ] = hackLimit then
110086: LD_EXP 159
110090: PUSH
110091: LD_VAR 0 5
110095: ARRAY
110096: PUSH
110097: LD_EXP 160
110101: EQUAL
110102: IFFALSE 110106
// break ;
110104: GO 110253
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
110106: LD_ADDR_EXP 162
110110: PUSH
110111: LD_EXP 162
110115: PPUSH
110116: LD_VAR 0 5
110120: PPUSH
110121: LD_EXP 162
110125: PUSH
110126: LD_VAR 0 5
110130: ARRAY
110131: PUSH
110132: LD_INT 1
110134: PLUS
110135: PPUSH
110136: CALL_OW 1
110140: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
110141: LD_ADDR_EXP 159
110145: PUSH
110146: LD_EXP 159
110150: PPUSH
110151: LD_VAR 0 5
110155: PUSH
110156: LD_EXP 159
110160: PUSH
110161: LD_VAR 0 5
110165: ARRAY
110166: PUSH
110167: LD_INT 1
110169: PLUS
110170: PUSH
110171: EMPTY
110172: LIST
110173: LIST
110174: PPUSH
110175: LD_VAR 0 2
110179: PUSH
110180: LD_VAR 0 4
110184: ARRAY
110185: PUSH
110186: LD_VAR 0 2
110190: PUSH
110191: LD_VAR 0 4
110195: ARRAY
110196: PPUSH
110197: CALL_OW 255
110201: PUSH
110202: EMPTY
110203: LIST
110204: LIST
110205: PPUSH
110206: CALL 54145 0 3
110210: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
110211: LD_VAR 0 2
110215: PUSH
110216: LD_VAR 0 4
110220: ARRAY
110221: PPUSH
110222: LD_VAR 0 1
110226: PPUSH
110227: CALL_OW 255
110231: PPUSH
110232: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
110236: LD_VAR 0 2
110240: PUSH
110241: LD_VAR 0 4
110245: ARRAY
110246: PPUSH
110247: CALL_OW 141
// end ;
110251: GO 110083
110253: POP
110254: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
110255: LD_VAR 0 1
110259: PPUSH
110260: LD_EXP 159
110264: PUSH
110265: LD_VAR 0 5
110269: ARRAY
110270: PUSH
110271: LD_INT 0
110273: PLUS
110274: PPUSH
110275: CALL_OW 505
// end ;
110279: LD_VAR 0 3
110283: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
110284: LD_INT 0
110286: PPUSH
110287: PPUSH
110288: PPUSH
110289: PPUSH
// if not hack in hackTanks then
110290: LD_VAR 0 1
110294: PUSH
110295: LD_EXP 158
110299: IN
110300: NOT
110301: IFFALSE 110305
// exit ;
110303: GO 110545
// index := GetElementIndex ( hackTanks , hack ) ;
110305: LD_ADDR_VAR 0 4
110309: PUSH
110310: LD_EXP 158
110314: PPUSH
110315: LD_VAR 0 1
110319: PPUSH
110320: CALL 53930 0 2
110324: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
110325: LD_ADDR_VAR 0 3
110329: PUSH
110330: DOUBLE
110331: LD_EXP 159
110335: PUSH
110336: LD_VAR 0 4
110340: ARRAY
110341: INC
110342: ST_TO_ADDR
110343: LD_INT 1
110345: PUSH
110346: FOR_DOWNTO
110347: IFFALSE 110519
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
110349: LD_ADDR_VAR 0 5
110353: PUSH
110354: LD_EXP 159
110358: PUSH
110359: LD_VAR 0 4
110363: ARRAY
110364: PUSH
110365: LD_VAR 0 3
110369: ARRAY
110370: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
110371: LD_VAR 0 5
110375: PUSH
110376: LD_INT 1
110378: ARRAY
110379: PPUSH
110380: CALL_OW 302
110384: NOT
110385: PUSH
110386: LD_VAR 0 5
110390: PUSH
110391: LD_INT 1
110393: ARRAY
110394: PPUSH
110395: CALL_OW 255
110399: PUSH
110400: LD_VAR 0 1
110404: PPUSH
110405: CALL_OW 255
110409: NONEQUAL
110410: OR
110411: IFFALSE 110517
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
110413: LD_VAR 0 5
110417: PUSH
110418: LD_INT 1
110420: ARRAY
110421: PPUSH
110422: CALL_OW 305
110426: PUSH
110427: LD_VAR 0 5
110431: PUSH
110432: LD_INT 1
110434: ARRAY
110435: PPUSH
110436: CALL_OW 255
110440: PUSH
110441: LD_VAR 0 1
110445: PPUSH
110446: CALL_OW 255
110450: EQUAL
110451: AND
110452: IFFALSE 110476
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
110454: LD_VAR 0 5
110458: PUSH
110459: LD_INT 1
110461: ARRAY
110462: PPUSH
110463: LD_VAR 0 5
110467: PUSH
110468: LD_INT 2
110470: ARRAY
110471: PPUSH
110472: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
110476: LD_ADDR_EXP 159
110480: PUSH
110481: LD_EXP 159
110485: PPUSH
110486: LD_VAR 0 4
110490: PPUSH
110491: LD_EXP 159
110495: PUSH
110496: LD_VAR 0 4
110500: ARRAY
110501: PPUSH
110502: LD_VAR 0 3
110506: PPUSH
110507: CALL_OW 3
110511: PPUSH
110512: CALL_OW 1
110516: ST_TO_ADDR
// end ; end ;
110517: GO 110346
110519: POP
110520: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
110521: LD_VAR 0 1
110525: PPUSH
110526: LD_EXP 159
110530: PUSH
110531: LD_VAR 0 4
110535: ARRAY
110536: PUSH
110537: LD_INT 0
110539: PLUS
110540: PPUSH
110541: CALL_OW 505
// end ;
110545: LD_VAR 0 2
110549: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
110550: LD_INT 0
110552: PPUSH
110553: PPUSH
110554: PPUSH
110555: PPUSH
// if not hack in hackTanks then
110556: LD_VAR 0 1
110560: PUSH
110561: LD_EXP 158
110565: IN
110566: NOT
110567: IFFALSE 110571
// exit ;
110569: GO 110656
// index := GetElementIndex ( hackTanks , hack ) ;
110571: LD_ADDR_VAR 0 5
110575: PUSH
110576: LD_EXP 158
110580: PPUSH
110581: LD_VAR 0 1
110585: PPUSH
110586: CALL 53930 0 2
110590: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
110591: LD_ADDR_VAR 0 4
110595: PUSH
110596: DOUBLE
110597: LD_INT 1
110599: DEC
110600: ST_TO_ADDR
110601: LD_EXP 159
110605: PUSH
110606: LD_VAR 0 5
110610: ARRAY
110611: PUSH
110612: FOR_TO
110613: IFFALSE 110654
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
110615: LD_EXP 159
110619: PUSH
110620: LD_VAR 0 5
110624: ARRAY
110625: PUSH
110626: LD_VAR 0 4
110630: ARRAY
110631: PUSH
110632: LD_INT 1
110634: ARRAY
110635: PUSH
110636: LD_VAR 0 2
110640: EQUAL
110641: IFFALSE 110652
// KillUnit ( vehicle ) ;
110643: LD_VAR 0 2
110647: PPUSH
110648: CALL_OW 66
110652: GO 110612
110654: POP
110655: POP
// end ;
110656: LD_VAR 0 3
110660: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
110661: LD_EXP 163
110665: NOT
110666: IFFALSE 110701
110668: GO 110670
110670: DISABLE
// begin initMiner := true ;
110671: LD_ADDR_EXP 163
110675: PUSH
110676: LD_INT 1
110678: ST_TO_ADDR
// minersList := [ ] ;
110679: LD_ADDR_EXP 164
110683: PUSH
110684: EMPTY
110685: ST_TO_ADDR
// minerMinesList := [ ] ;
110686: LD_ADDR_EXP 165
110690: PUSH
110691: EMPTY
110692: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
110693: LD_ADDR_EXP 166
110697: PUSH
110698: LD_INT 5
110700: ST_TO_ADDR
// end ;
110701: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
110702: LD_EXP 163
110706: PUSH
110707: LD_INT 34
110709: PUSH
110710: LD_INT 81
110712: PUSH
110713: EMPTY
110714: LIST
110715: LIST
110716: PPUSH
110717: CALL_OW 69
110721: AND
110722: IFFALSE 111183
110724: GO 110726
110726: DISABLE
110727: LD_INT 0
110729: PPUSH
110730: PPUSH
110731: PPUSH
110732: PPUSH
// begin enable ;
110733: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
110734: LD_ADDR_VAR 0 1
110738: PUSH
110739: LD_INT 34
110741: PUSH
110742: LD_INT 81
110744: PUSH
110745: EMPTY
110746: LIST
110747: LIST
110748: PPUSH
110749: CALL_OW 69
110753: PUSH
110754: FOR_IN
110755: IFFALSE 110827
// begin if not i in minersList then
110757: LD_VAR 0 1
110761: PUSH
110762: LD_EXP 164
110766: IN
110767: NOT
110768: IFFALSE 110825
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
110770: LD_ADDR_EXP 164
110774: PUSH
110775: LD_EXP 164
110779: PPUSH
110780: LD_EXP 164
110784: PUSH
110785: LD_INT 1
110787: PLUS
110788: PPUSH
110789: LD_VAR 0 1
110793: PPUSH
110794: CALL_OW 1
110798: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
110799: LD_ADDR_EXP 165
110803: PUSH
110804: LD_EXP 165
110808: PPUSH
110809: LD_EXP 165
110813: PUSH
110814: LD_INT 1
110816: PLUS
110817: PPUSH
110818: EMPTY
110819: PPUSH
110820: CALL_OW 1
110824: ST_TO_ADDR
// end end ;
110825: GO 110754
110827: POP
110828: POP
// for i := minerMinesList downto 1 do
110829: LD_ADDR_VAR 0 1
110833: PUSH
110834: DOUBLE
110835: LD_EXP 165
110839: INC
110840: ST_TO_ADDR
110841: LD_INT 1
110843: PUSH
110844: FOR_DOWNTO
110845: IFFALSE 111181
// begin if IsLive ( minersList [ i ] ) then
110847: LD_EXP 164
110851: PUSH
110852: LD_VAR 0 1
110856: ARRAY
110857: PPUSH
110858: CALL_OW 300
110862: IFFALSE 110890
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
110864: LD_EXP 164
110868: PUSH
110869: LD_VAR 0 1
110873: ARRAY
110874: PPUSH
110875: LD_EXP 165
110879: PUSH
110880: LD_VAR 0 1
110884: ARRAY
110885: PPUSH
110886: CALL_OW 505
// if not minerMinesList [ i ] then
110890: LD_EXP 165
110894: PUSH
110895: LD_VAR 0 1
110899: ARRAY
110900: NOT
110901: IFFALSE 110905
// continue ;
110903: GO 110844
// for j := minerMinesList [ i ] downto 1 do
110905: LD_ADDR_VAR 0 2
110909: PUSH
110910: DOUBLE
110911: LD_EXP 165
110915: PUSH
110916: LD_VAR 0 1
110920: ARRAY
110921: INC
110922: ST_TO_ADDR
110923: LD_INT 1
110925: PUSH
110926: FOR_DOWNTO
110927: IFFALSE 111177
// begin side := GetSide ( minersList [ i ] ) ;
110929: LD_ADDR_VAR 0 3
110933: PUSH
110934: LD_EXP 164
110938: PUSH
110939: LD_VAR 0 1
110943: ARRAY
110944: PPUSH
110945: CALL_OW 255
110949: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
110950: LD_ADDR_VAR 0 4
110954: PUSH
110955: LD_EXP 165
110959: PUSH
110960: LD_VAR 0 1
110964: ARRAY
110965: PUSH
110966: LD_VAR 0 2
110970: ARRAY
110971: PUSH
110972: LD_INT 1
110974: ARRAY
110975: PPUSH
110976: LD_EXP 165
110980: PUSH
110981: LD_VAR 0 1
110985: ARRAY
110986: PUSH
110987: LD_VAR 0 2
110991: ARRAY
110992: PUSH
110993: LD_INT 2
110995: ARRAY
110996: PPUSH
110997: CALL_OW 428
111001: ST_TO_ADDR
// if not tmp then
111002: LD_VAR 0 4
111006: NOT
111007: IFFALSE 111011
// continue ;
111009: GO 110926
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
111011: LD_VAR 0 4
111015: PUSH
111016: LD_INT 81
111018: PUSH
111019: LD_VAR 0 3
111023: PUSH
111024: EMPTY
111025: LIST
111026: LIST
111027: PPUSH
111028: CALL_OW 69
111032: IN
111033: PUSH
111034: LD_EXP 165
111038: PUSH
111039: LD_VAR 0 1
111043: ARRAY
111044: PUSH
111045: LD_VAR 0 2
111049: ARRAY
111050: PUSH
111051: LD_INT 1
111053: ARRAY
111054: PPUSH
111055: LD_EXP 165
111059: PUSH
111060: LD_VAR 0 1
111064: ARRAY
111065: PUSH
111066: LD_VAR 0 2
111070: ARRAY
111071: PUSH
111072: LD_INT 2
111074: ARRAY
111075: PPUSH
111076: CALL_OW 458
111080: AND
111081: IFFALSE 111175
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
111083: LD_EXP 165
111087: PUSH
111088: LD_VAR 0 1
111092: ARRAY
111093: PUSH
111094: LD_VAR 0 2
111098: ARRAY
111099: PUSH
111100: LD_INT 1
111102: ARRAY
111103: PPUSH
111104: LD_EXP 165
111108: PUSH
111109: LD_VAR 0 1
111113: ARRAY
111114: PUSH
111115: LD_VAR 0 2
111119: ARRAY
111120: PUSH
111121: LD_INT 2
111123: ARRAY
111124: PPUSH
111125: LD_VAR 0 3
111129: PPUSH
111130: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
111134: LD_ADDR_EXP 165
111138: PUSH
111139: LD_EXP 165
111143: PPUSH
111144: LD_VAR 0 1
111148: PPUSH
111149: LD_EXP 165
111153: PUSH
111154: LD_VAR 0 1
111158: ARRAY
111159: PPUSH
111160: LD_VAR 0 2
111164: PPUSH
111165: CALL_OW 3
111169: PPUSH
111170: CALL_OW 1
111174: ST_TO_ADDR
// end ; end ;
111175: GO 110926
111177: POP
111178: POP
// end ;
111179: GO 110844
111181: POP
111182: POP
// end ;
111183: PPOPN 4
111185: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
111186: LD_INT 0
111188: PPUSH
111189: PPUSH
// result := false ;
111190: LD_ADDR_VAR 0 4
111194: PUSH
111195: LD_INT 0
111197: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
111198: LD_VAR 0 1
111202: PPUSH
111203: CALL_OW 264
111207: PUSH
111208: LD_INT 81
111210: EQUAL
111211: NOT
111212: IFFALSE 111216
// exit ;
111214: GO 111456
// index := GetElementIndex ( minersList , unit ) ;
111216: LD_ADDR_VAR 0 5
111220: PUSH
111221: LD_EXP 164
111225: PPUSH
111226: LD_VAR 0 1
111230: PPUSH
111231: CALL 53930 0 2
111235: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
111236: LD_EXP 165
111240: PUSH
111241: LD_VAR 0 5
111245: ARRAY
111246: PUSH
111247: LD_EXP 166
111251: GREATEREQUAL
111252: IFFALSE 111256
// exit ;
111254: GO 111456
// ComMoveXY ( unit , x , y ) ;
111256: LD_VAR 0 1
111260: PPUSH
111261: LD_VAR 0 2
111265: PPUSH
111266: LD_VAR 0 3
111270: PPUSH
111271: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
111275: LD_INT 35
111277: PPUSH
111278: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
111282: LD_VAR 0 1
111286: PPUSH
111287: LD_VAR 0 2
111291: PPUSH
111292: LD_VAR 0 3
111296: PPUSH
111297: CALL 85671 0 3
111301: NOT
111302: PUSH
111303: LD_VAR 0 1
111307: PPUSH
111308: CALL_OW 314
111312: AND
111313: IFFALSE 111317
// exit ;
111315: GO 111456
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
111317: LD_VAR 0 2
111321: PPUSH
111322: LD_VAR 0 3
111326: PPUSH
111327: CALL_OW 428
111331: PUSH
111332: LD_VAR 0 1
111336: EQUAL
111337: PUSH
111338: LD_VAR 0 1
111342: PPUSH
111343: CALL_OW 314
111347: NOT
111348: AND
111349: IFFALSE 111275
// PlaySoundXY ( x , y , PlantMine ) ;
111351: LD_VAR 0 2
111355: PPUSH
111356: LD_VAR 0 3
111360: PPUSH
111361: LD_STRING PlantMine
111363: PPUSH
111364: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
111368: LD_VAR 0 2
111372: PPUSH
111373: LD_VAR 0 3
111377: PPUSH
111378: LD_VAR 0 1
111382: PPUSH
111383: CALL_OW 255
111387: PPUSH
111388: LD_INT 0
111390: PPUSH
111391: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
111395: LD_ADDR_EXP 165
111399: PUSH
111400: LD_EXP 165
111404: PPUSH
111405: LD_VAR 0 5
111409: PUSH
111410: LD_EXP 165
111414: PUSH
111415: LD_VAR 0 5
111419: ARRAY
111420: PUSH
111421: LD_INT 1
111423: PLUS
111424: PUSH
111425: EMPTY
111426: LIST
111427: LIST
111428: PPUSH
111429: LD_VAR 0 2
111433: PUSH
111434: LD_VAR 0 3
111438: PUSH
111439: EMPTY
111440: LIST
111441: LIST
111442: PPUSH
111443: CALL 54145 0 3
111447: ST_TO_ADDR
// result := true ;
111448: LD_ADDR_VAR 0 4
111452: PUSH
111453: LD_INT 1
111455: ST_TO_ADDR
// end ;
111456: LD_VAR 0 4
111460: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
111461: LD_INT 0
111463: PPUSH
111464: PPUSH
111465: PPUSH
// if not unit in minersList then
111466: LD_VAR 0 1
111470: PUSH
111471: LD_EXP 164
111475: IN
111476: NOT
111477: IFFALSE 111481
// exit ;
111479: GO 111873
// index := GetElementIndex ( minersList , unit ) ;
111481: LD_ADDR_VAR 0 6
111485: PUSH
111486: LD_EXP 164
111490: PPUSH
111491: LD_VAR 0 1
111495: PPUSH
111496: CALL 53930 0 2
111500: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
111501: LD_ADDR_VAR 0 5
111505: PUSH
111506: DOUBLE
111507: LD_EXP 165
111511: PUSH
111512: LD_VAR 0 6
111516: ARRAY
111517: INC
111518: ST_TO_ADDR
111519: LD_INT 1
111521: PUSH
111522: FOR_DOWNTO
111523: IFFALSE 111684
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
111525: LD_EXP 165
111529: PUSH
111530: LD_VAR 0 6
111534: ARRAY
111535: PUSH
111536: LD_VAR 0 5
111540: ARRAY
111541: PUSH
111542: LD_INT 1
111544: ARRAY
111545: PUSH
111546: LD_VAR 0 2
111550: EQUAL
111551: PUSH
111552: LD_EXP 165
111556: PUSH
111557: LD_VAR 0 6
111561: ARRAY
111562: PUSH
111563: LD_VAR 0 5
111567: ARRAY
111568: PUSH
111569: LD_INT 2
111571: ARRAY
111572: PUSH
111573: LD_VAR 0 3
111577: EQUAL
111578: AND
111579: IFFALSE 111682
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
111581: LD_EXP 165
111585: PUSH
111586: LD_VAR 0 6
111590: ARRAY
111591: PUSH
111592: LD_VAR 0 5
111596: ARRAY
111597: PUSH
111598: LD_INT 1
111600: ARRAY
111601: PPUSH
111602: LD_EXP 165
111606: PUSH
111607: LD_VAR 0 6
111611: ARRAY
111612: PUSH
111613: LD_VAR 0 5
111617: ARRAY
111618: PUSH
111619: LD_INT 2
111621: ARRAY
111622: PPUSH
111623: LD_VAR 0 1
111627: PPUSH
111628: CALL_OW 255
111632: PPUSH
111633: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
111637: LD_ADDR_EXP 165
111641: PUSH
111642: LD_EXP 165
111646: PPUSH
111647: LD_VAR 0 6
111651: PPUSH
111652: LD_EXP 165
111656: PUSH
111657: LD_VAR 0 6
111661: ARRAY
111662: PPUSH
111663: LD_VAR 0 5
111667: PPUSH
111668: CALL_OW 3
111672: PPUSH
111673: CALL_OW 1
111677: ST_TO_ADDR
// exit ;
111678: POP
111679: POP
111680: GO 111873
// end ; end ;
111682: GO 111522
111684: POP
111685: POP
// for i := minerMinesList [ index ] downto 1 do
111686: LD_ADDR_VAR 0 5
111690: PUSH
111691: DOUBLE
111692: LD_EXP 165
111696: PUSH
111697: LD_VAR 0 6
111701: ARRAY
111702: INC
111703: ST_TO_ADDR
111704: LD_INT 1
111706: PUSH
111707: FOR_DOWNTO
111708: IFFALSE 111871
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
111710: LD_EXP 165
111714: PUSH
111715: LD_VAR 0 6
111719: ARRAY
111720: PUSH
111721: LD_VAR 0 5
111725: ARRAY
111726: PUSH
111727: LD_INT 1
111729: ARRAY
111730: PPUSH
111731: LD_EXP 165
111735: PUSH
111736: LD_VAR 0 6
111740: ARRAY
111741: PUSH
111742: LD_VAR 0 5
111746: ARRAY
111747: PUSH
111748: LD_INT 2
111750: ARRAY
111751: PPUSH
111752: LD_VAR 0 2
111756: PPUSH
111757: LD_VAR 0 3
111761: PPUSH
111762: CALL_OW 298
111766: PUSH
111767: LD_INT 6
111769: LESS
111770: IFFALSE 111869
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
111772: LD_EXP 165
111776: PUSH
111777: LD_VAR 0 6
111781: ARRAY
111782: PUSH
111783: LD_VAR 0 5
111787: ARRAY
111788: PUSH
111789: LD_INT 1
111791: ARRAY
111792: PPUSH
111793: LD_EXP 165
111797: PUSH
111798: LD_VAR 0 6
111802: ARRAY
111803: PUSH
111804: LD_VAR 0 5
111808: ARRAY
111809: PUSH
111810: LD_INT 2
111812: ARRAY
111813: PPUSH
111814: LD_VAR 0 1
111818: PPUSH
111819: CALL_OW 255
111823: PPUSH
111824: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
111828: LD_ADDR_EXP 165
111832: PUSH
111833: LD_EXP 165
111837: PPUSH
111838: LD_VAR 0 6
111842: PPUSH
111843: LD_EXP 165
111847: PUSH
111848: LD_VAR 0 6
111852: ARRAY
111853: PPUSH
111854: LD_VAR 0 5
111858: PPUSH
111859: CALL_OW 3
111863: PPUSH
111864: CALL_OW 1
111868: ST_TO_ADDR
// end ; end ;
111869: GO 111707
111871: POP
111872: POP
// end ;
111873: LD_VAR 0 4
111877: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
111878: LD_INT 0
111880: PPUSH
111881: PPUSH
111882: PPUSH
111883: PPUSH
111884: PPUSH
111885: PPUSH
111886: PPUSH
111887: PPUSH
111888: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
111889: LD_VAR 0 1
111893: PPUSH
111894: CALL_OW 264
111898: PUSH
111899: LD_INT 81
111901: EQUAL
111902: NOT
111903: PUSH
111904: LD_VAR 0 1
111908: PUSH
111909: LD_EXP 164
111913: IN
111914: NOT
111915: OR
111916: IFFALSE 111920
// exit ;
111918: GO 112242
// index := GetElementIndex ( minersList , unit ) ;
111920: LD_ADDR_VAR 0 6
111924: PUSH
111925: LD_EXP 164
111929: PPUSH
111930: LD_VAR 0 1
111934: PPUSH
111935: CALL 53930 0 2
111939: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
111940: LD_ADDR_VAR 0 8
111944: PUSH
111945: LD_EXP 166
111949: PUSH
111950: LD_EXP 165
111954: PUSH
111955: LD_VAR 0 6
111959: ARRAY
111960: MINUS
111961: ST_TO_ADDR
// if not minesFreeAmount then
111962: LD_VAR 0 8
111966: NOT
111967: IFFALSE 111971
// exit ;
111969: GO 112242
// tmp := [ ] ;
111971: LD_ADDR_VAR 0 7
111975: PUSH
111976: EMPTY
111977: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
111978: LD_ADDR_VAR 0 5
111982: PUSH
111983: DOUBLE
111984: LD_INT 1
111986: DEC
111987: ST_TO_ADDR
111988: LD_VAR 0 8
111992: PUSH
111993: FOR_TO
111994: IFFALSE 112189
// begin _d := rand ( 0 , 5 ) ;
111996: LD_ADDR_VAR 0 11
112000: PUSH
112001: LD_INT 0
112003: PPUSH
112004: LD_INT 5
112006: PPUSH
112007: CALL_OW 12
112011: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
112012: LD_ADDR_VAR 0 12
112016: PUSH
112017: LD_INT 2
112019: PPUSH
112020: LD_INT 6
112022: PPUSH
112023: CALL_OW 12
112027: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
112028: LD_ADDR_VAR 0 9
112032: PUSH
112033: LD_VAR 0 2
112037: PPUSH
112038: LD_VAR 0 11
112042: PPUSH
112043: LD_VAR 0 12
112047: PPUSH
112048: CALL_OW 272
112052: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
112053: LD_ADDR_VAR 0 10
112057: PUSH
112058: LD_VAR 0 3
112062: PPUSH
112063: LD_VAR 0 11
112067: PPUSH
112068: LD_VAR 0 12
112072: PPUSH
112073: CALL_OW 273
112077: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
112078: LD_VAR 0 9
112082: PPUSH
112083: LD_VAR 0 10
112087: PPUSH
112088: CALL_OW 488
112092: PUSH
112093: LD_VAR 0 9
112097: PUSH
112098: LD_VAR 0 10
112102: PUSH
112103: EMPTY
112104: LIST
112105: LIST
112106: PUSH
112107: LD_VAR 0 7
112111: IN
112112: NOT
112113: AND
112114: PUSH
112115: LD_VAR 0 9
112119: PPUSH
112120: LD_VAR 0 10
112124: PPUSH
112125: CALL_OW 458
112129: NOT
112130: AND
112131: IFFALSE 112173
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
112133: LD_ADDR_VAR 0 7
112137: PUSH
112138: LD_VAR 0 7
112142: PPUSH
112143: LD_VAR 0 7
112147: PUSH
112148: LD_INT 1
112150: PLUS
112151: PPUSH
112152: LD_VAR 0 9
112156: PUSH
112157: LD_VAR 0 10
112161: PUSH
112162: EMPTY
112163: LIST
112164: LIST
112165: PPUSH
112166: CALL_OW 1
112170: ST_TO_ADDR
112171: GO 112187
// i := i - 1 ;
112173: LD_ADDR_VAR 0 5
112177: PUSH
112178: LD_VAR 0 5
112182: PUSH
112183: LD_INT 1
112185: MINUS
112186: ST_TO_ADDR
// end ;
112187: GO 111993
112189: POP
112190: POP
// for i in tmp do
112191: LD_ADDR_VAR 0 5
112195: PUSH
112196: LD_VAR 0 7
112200: PUSH
112201: FOR_IN
112202: IFFALSE 112240
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
112204: LD_VAR 0 1
112208: PPUSH
112209: LD_VAR 0 5
112213: PUSH
112214: LD_INT 1
112216: ARRAY
112217: PPUSH
112218: LD_VAR 0 5
112222: PUSH
112223: LD_INT 2
112225: ARRAY
112226: PPUSH
112227: CALL 111186 0 3
112231: NOT
112232: IFFALSE 112238
// exit ;
112234: POP
112235: POP
112236: GO 112242
112238: GO 112201
112240: POP
112241: POP
// end ;
112242: LD_VAR 0 4
112246: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
112247: LD_INT 0
112249: PPUSH
112250: PPUSH
112251: PPUSH
112252: PPUSH
112253: PPUSH
112254: PPUSH
112255: PPUSH
// if not GetClass ( unit ) = class_sniper then
112256: LD_VAR 0 1
112260: PPUSH
112261: CALL_OW 257
112265: PUSH
112266: LD_INT 5
112268: EQUAL
112269: NOT
112270: IFFALSE 112274
// exit ;
112272: GO 112662
// dist := 8 ;
112274: LD_ADDR_VAR 0 5
112278: PUSH
112279: LD_INT 8
112281: ST_TO_ADDR
// viewRange := 12 ;
112282: LD_ADDR_VAR 0 7
112286: PUSH
112287: LD_INT 12
112289: ST_TO_ADDR
// side := GetSide ( unit ) ;
112290: LD_ADDR_VAR 0 6
112294: PUSH
112295: LD_VAR 0 1
112299: PPUSH
112300: CALL_OW 255
112304: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
112305: LD_INT 61
112307: PPUSH
112308: LD_VAR 0 6
112312: PPUSH
112313: CALL_OW 321
112317: PUSH
112318: LD_INT 2
112320: EQUAL
112321: IFFALSE 112331
// viewRange := 16 ;
112323: LD_ADDR_VAR 0 7
112327: PUSH
112328: LD_INT 16
112330: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
112331: LD_VAR 0 1
112335: PPUSH
112336: LD_VAR 0 2
112340: PPUSH
112341: LD_VAR 0 3
112345: PPUSH
112346: CALL_OW 297
112350: PUSH
112351: LD_VAR 0 5
112355: GREATER
112356: IFFALSE 112435
// begin ComMoveXY ( unit , x , y ) ;
112358: LD_VAR 0 1
112362: PPUSH
112363: LD_VAR 0 2
112367: PPUSH
112368: LD_VAR 0 3
112372: PPUSH
112373: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
112377: LD_INT 35
112379: PPUSH
112380: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
112384: LD_VAR 0 1
112388: PPUSH
112389: LD_VAR 0 2
112393: PPUSH
112394: LD_VAR 0 3
112398: PPUSH
112399: CALL 85671 0 3
112403: NOT
112404: IFFALSE 112408
// exit ;
112406: GO 112662
// until GetDistUnitXY ( unit , x , y ) < dist ;
112408: LD_VAR 0 1
112412: PPUSH
112413: LD_VAR 0 2
112417: PPUSH
112418: LD_VAR 0 3
112422: PPUSH
112423: CALL_OW 297
112427: PUSH
112428: LD_VAR 0 5
112432: LESS
112433: IFFALSE 112377
// end ; ComTurnXY ( unit , x , y ) ;
112435: LD_VAR 0 1
112439: PPUSH
112440: LD_VAR 0 2
112444: PPUSH
112445: LD_VAR 0 3
112449: PPUSH
112450: CALL_OW 118
// wait ( 5 ) ;
112454: LD_INT 5
112456: PPUSH
112457: CALL_OW 67
// _d := GetDir ( unit ) ;
112461: LD_ADDR_VAR 0 10
112465: PUSH
112466: LD_VAR 0 1
112470: PPUSH
112471: CALL_OW 254
112475: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
112476: LD_ADDR_VAR 0 8
112480: PUSH
112481: LD_VAR 0 1
112485: PPUSH
112486: CALL_OW 250
112490: PPUSH
112491: LD_VAR 0 10
112495: PPUSH
112496: LD_VAR 0 5
112500: PPUSH
112501: CALL_OW 272
112505: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
112506: LD_ADDR_VAR 0 9
112510: PUSH
112511: LD_VAR 0 1
112515: PPUSH
112516: CALL_OW 251
112520: PPUSH
112521: LD_VAR 0 10
112525: PPUSH
112526: LD_VAR 0 5
112530: PPUSH
112531: CALL_OW 273
112535: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
112536: LD_VAR 0 8
112540: PPUSH
112541: LD_VAR 0 9
112545: PPUSH
112546: CALL_OW 488
112550: NOT
112551: IFFALSE 112555
// exit ;
112553: GO 112662
// ComAnimCustom ( unit , 1 ) ;
112555: LD_VAR 0 1
112559: PPUSH
112560: LD_INT 1
112562: PPUSH
112563: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
112567: LD_VAR 0 8
112571: PPUSH
112572: LD_VAR 0 9
112576: PPUSH
112577: LD_VAR 0 6
112581: PPUSH
112582: LD_VAR 0 7
112586: PPUSH
112587: CALL_OW 330
// repeat wait ( 1 ) ;
112591: LD_INT 1
112593: PPUSH
112594: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
112598: LD_VAR 0 1
112602: PPUSH
112603: CALL_OW 316
112607: PUSH
112608: LD_VAR 0 1
112612: PPUSH
112613: CALL_OW 314
112617: OR
112618: PUSH
112619: LD_VAR 0 1
112623: PPUSH
112624: CALL_OW 302
112628: NOT
112629: OR
112630: PUSH
112631: LD_VAR 0 1
112635: PPUSH
112636: CALL_OW 301
112640: OR
112641: IFFALSE 112591
// RemoveSeeing ( _x , _y , side ) ;
112643: LD_VAR 0 8
112647: PPUSH
112648: LD_VAR 0 9
112652: PPUSH
112653: LD_VAR 0 6
112657: PPUSH
112658: CALL_OW 331
// end ; end_of_file
112662: LD_VAR 0 4
112666: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
112667: LD_INT 0
112669: PPUSH
112670: PPUSH
112671: PPUSH
112672: PPUSH
112673: PPUSH
112674: PPUSH
112675: PPUSH
112676: PPUSH
112677: PPUSH
112678: PPUSH
112679: PPUSH
112680: PPUSH
112681: PPUSH
112682: PPUSH
112683: PPUSH
112684: PPUSH
112685: PPUSH
112686: PPUSH
112687: PPUSH
112688: PPUSH
112689: PPUSH
112690: PPUSH
112691: PPUSH
112692: PPUSH
112693: PPUSH
112694: PPUSH
112695: PPUSH
112696: PPUSH
112697: PPUSH
112698: PPUSH
112699: PPUSH
112700: PPUSH
112701: PPUSH
112702: PPUSH
// if not list then
112703: LD_VAR 0 1
112707: NOT
112708: IFFALSE 112712
// exit ;
112710: GO 117371
// base := list [ 1 ] ;
112712: LD_ADDR_VAR 0 3
112716: PUSH
112717: LD_VAR 0 1
112721: PUSH
112722: LD_INT 1
112724: ARRAY
112725: ST_TO_ADDR
// group := list [ 2 ] ;
112726: LD_ADDR_VAR 0 4
112730: PUSH
112731: LD_VAR 0 1
112735: PUSH
112736: LD_INT 2
112738: ARRAY
112739: ST_TO_ADDR
// path := list [ 3 ] ;
112740: LD_ADDR_VAR 0 5
112744: PUSH
112745: LD_VAR 0 1
112749: PUSH
112750: LD_INT 3
112752: ARRAY
112753: ST_TO_ADDR
// flags := list [ 4 ] ;
112754: LD_ADDR_VAR 0 6
112758: PUSH
112759: LD_VAR 0 1
112763: PUSH
112764: LD_INT 4
112766: ARRAY
112767: ST_TO_ADDR
// mined := [ ] ;
112768: LD_ADDR_VAR 0 27
112772: PUSH
112773: EMPTY
112774: ST_TO_ADDR
// bombed := [ ] ;
112775: LD_ADDR_VAR 0 28
112779: PUSH
112780: EMPTY
112781: ST_TO_ADDR
// healers := [ ] ;
112782: LD_ADDR_VAR 0 31
112786: PUSH
112787: EMPTY
112788: ST_TO_ADDR
// to_heal := [ ] ;
112789: LD_ADDR_VAR 0 30
112793: PUSH
112794: EMPTY
112795: ST_TO_ADDR
// repairs := [ ] ;
112796: LD_ADDR_VAR 0 33
112800: PUSH
112801: EMPTY
112802: ST_TO_ADDR
// to_repair := [ ] ;
112803: LD_ADDR_VAR 0 32
112807: PUSH
112808: EMPTY
112809: ST_TO_ADDR
// if not group or not path then
112810: LD_VAR 0 4
112814: NOT
112815: PUSH
112816: LD_VAR 0 5
112820: NOT
112821: OR
112822: IFFALSE 112826
// exit ;
112824: GO 117371
// side := GetSide ( group [ 1 ] ) ;
112826: LD_ADDR_VAR 0 35
112830: PUSH
112831: LD_VAR 0 4
112835: PUSH
112836: LD_INT 1
112838: ARRAY
112839: PPUSH
112840: CALL_OW 255
112844: ST_TO_ADDR
// if flags then
112845: LD_VAR 0 6
112849: IFFALSE 112993
// begin f_ignore_area := flags [ 1 ] ;
112851: LD_ADDR_VAR 0 17
112855: PUSH
112856: LD_VAR 0 6
112860: PUSH
112861: LD_INT 1
112863: ARRAY
112864: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
112865: LD_ADDR_VAR 0 18
112869: PUSH
112870: LD_VAR 0 6
112874: PUSH
112875: LD_INT 2
112877: ARRAY
112878: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
112879: LD_ADDR_VAR 0 19
112883: PUSH
112884: LD_VAR 0 6
112888: PUSH
112889: LD_INT 3
112891: ARRAY
112892: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
112893: LD_ADDR_VAR 0 20
112897: PUSH
112898: LD_VAR 0 6
112902: PUSH
112903: LD_INT 4
112905: ARRAY
112906: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
112907: LD_ADDR_VAR 0 21
112911: PUSH
112912: LD_VAR 0 6
112916: PUSH
112917: LD_INT 5
112919: ARRAY
112920: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
112921: LD_ADDR_VAR 0 22
112925: PUSH
112926: LD_VAR 0 6
112930: PUSH
112931: LD_INT 6
112933: ARRAY
112934: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
112935: LD_ADDR_VAR 0 23
112939: PUSH
112940: LD_VAR 0 6
112944: PUSH
112945: LD_INT 7
112947: ARRAY
112948: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
112949: LD_ADDR_VAR 0 24
112953: PUSH
112954: LD_VAR 0 6
112958: PUSH
112959: LD_INT 8
112961: ARRAY
112962: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
112963: LD_ADDR_VAR 0 25
112967: PUSH
112968: LD_VAR 0 6
112972: PUSH
112973: LD_INT 9
112975: ARRAY
112976: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
112977: LD_ADDR_VAR 0 26
112981: PUSH
112982: LD_VAR 0 6
112986: PUSH
112987: LD_INT 10
112989: ARRAY
112990: ST_TO_ADDR
// end else
112991: GO 113073
// begin f_ignore_area := false ;
112993: LD_ADDR_VAR 0 17
112997: PUSH
112998: LD_INT 0
113000: ST_TO_ADDR
// f_capture := false ;
113001: LD_ADDR_VAR 0 18
113005: PUSH
113006: LD_INT 0
113008: ST_TO_ADDR
// f_ignore_civ := false ;
113009: LD_ADDR_VAR 0 19
113013: PUSH
113014: LD_INT 0
113016: ST_TO_ADDR
// f_murder := false ;
113017: LD_ADDR_VAR 0 20
113021: PUSH
113022: LD_INT 0
113024: ST_TO_ADDR
// f_mines := false ;
113025: LD_ADDR_VAR 0 21
113029: PUSH
113030: LD_INT 0
113032: ST_TO_ADDR
// f_repair := false ;
113033: LD_ADDR_VAR 0 22
113037: PUSH
113038: LD_INT 0
113040: ST_TO_ADDR
// f_heal := false ;
113041: LD_ADDR_VAR 0 23
113045: PUSH
113046: LD_INT 0
113048: ST_TO_ADDR
// f_spacetime := false ;
113049: LD_ADDR_VAR 0 24
113053: PUSH
113054: LD_INT 0
113056: ST_TO_ADDR
// f_attack_depot := false ;
113057: LD_ADDR_VAR 0 25
113061: PUSH
113062: LD_INT 0
113064: ST_TO_ADDR
// f_crawl := false ;
113065: LD_ADDR_VAR 0 26
113069: PUSH
113070: LD_INT 0
113072: ST_TO_ADDR
// end ; if f_heal then
113073: LD_VAR 0 23
113077: IFFALSE 113104
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
113079: LD_ADDR_VAR 0 31
113083: PUSH
113084: LD_VAR 0 4
113088: PPUSH
113089: LD_INT 25
113091: PUSH
113092: LD_INT 4
113094: PUSH
113095: EMPTY
113096: LIST
113097: LIST
113098: PPUSH
113099: CALL_OW 72
113103: ST_TO_ADDR
// if f_repair then
113104: LD_VAR 0 22
113108: IFFALSE 113135
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
113110: LD_ADDR_VAR 0 33
113114: PUSH
113115: LD_VAR 0 4
113119: PPUSH
113120: LD_INT 25
113122: PUSH
113123: LD_INT 3
113125: PUSH
113126: EMPTY
113127: LIST
113128: LIST
113129: PPUSH
113130: CALL_OW 72
113134: ST_TO_ADDR
// units_path := [ ] ;
113135: LD_ADDR_VAR 0 16
113139: PUSH
113140: EMPTY
113141: ST_TO_ADDR
// for i = 1 to group do
113142: LD_ADDR_VAR 0 7
113146: PUSH
113147: DOUBLE
113148: LD_INT 1
113150: DEC
113151: ST_TO_ADDR
113152: LD_VAR 0 4
113156: PUSH
113157: FOR_TO
113158: IFFALSE 113187
// units_path := Replace ( units_path , i , path ) ;
113160: LD_ADDR_VAR 0 16
113164: PUSH
113165: LD_VAR 0 16
113169: PPUSH
113170: LD_VAR 0 7
113174: PPUSH
113175: LD_VAR 0 5
113179: PPUSH
113180: CALL_OW 1
113184: ST_TO_ADDR
113185: GO 113157
113187: POP
113188: POP
// repeat for i = group downto 1 do
113189: LD_ADDR_VAR 0 7
113193: PUSH
113194: DOUBLE
113195: LD_VAR 0 4
113199: INC
113200: ST_TO_ADDR
113201: LD_INT 1
113203: PUSH
113204: FOR_DOWNTO
113205: IFFALSE 117327
// begin wait ( 5 ) ;
113207: LD_INT 5
113209: PPUSH
113210: CALL_OW 67
// tmp := [ ] ;
113214: LD_ADDR_VAR 0 14
113218: PUSH
113219: EMPTY
113220: ST_TO_ADDR
// attacking := false ;
113221: LD_ADDR_VAR 0 29
113225: PUSH
113226: LD_INT 0
113228: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
113229: LD_VAR 0 4
113233: PUSH
113234: LD_VAR 0 7
113238: ARRAY
113239: PPUSH
113240: CALL_OW 301
113244: PUSH
113245: LD_VAR 0 4
113249: PUSH
113250: LD_VAR 0 7
113254: ARRAY
113255: NOT
113256: OR
113257: IFFALSE 113366
// begin if GetType ( group [ i ] ) = unit_human then
113259: LD_VAR 0 4
113263: PUSH
113264: LD_VAR 0 7
113268: ARRAY
113269: PPUSH
113270: CALL_OW 247
113274: PUSH
113275: LD_INT 1
113277: EQUAL
113278: IFFALSE 113324
// begin to_heal := to_heal diff group [ i ] ;
113280: LD_ADDR_VAR 0 30
113284: PUSH
113285: LD_VAR 0 30
113289: PUSH
113290: LD_VAR 0 4
113294: PUSH
113295: LD_VAR 0 7
113299: ARRAY
113300: DIFF
113301: ST_TO_ADDR
// healers := healers diff group [ i ] ;
113302: LD_ADDR_VAR 0 31
113306: PUSH
113307: LD_VAR 0 31
113311: PUSH
113312: LD_VAR 0 4
113316: PUSH
113317: LD_VAR 0 7
113321: ARRAY
113322: DIFF
113323: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
113324: LD_ADDR_VAR 0 4
113328: PUSH
113329: LD_VAR 0 4
113333: PPUSH
113334: LD_VAR 0 7
113338: PPUSH
113339: CALL_OW 3
113343: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
113344: LD_ADDR_VAR 0 16
113348: PUSH
113349: LD_VAR 0 16
113353: PPUSH
113354: LD_VAR 0 7
113358: PPUSH
113359: CALL_OW 3
113363: ST_TO_ADDR
// continue ;
113364: GO 113204
// end ; if f_repair then
113366: LD_VAR 0 22
113370: IFFALSE 113859
// begin if GetType ( group [ i ] ) = unit_vehicle then
113372: LD_VAR 0 4
113376: PUSH
113377: LD_VAR 0 7
113381: ARRAY
113382: PPUSH
113383: CALL_OW 247
113387: PUSH
113388: LD_INT 2
113390: EQUAL
113391: IFFALSE 113581
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
113393: LD_VAR 0 4
113397: PUSH
113398: LD_VAR 0 7
113402: ARRAY
113403: PPUSH
113404: CALL_OW 256
113408: PUSH
113409: LD_INT 700
113411: LESS
113412: PUSH
113413: LD_VAR 0 4
113417: PUSH
113418: LD_VAR 0 7
113422: ARRAY
113423: PUSH
113424: LD_VAR 0 32
113428: IN
113429: NOT
113430: AND
113431: IFFALSE 113455
// to_repair := to_repair union group [ i ] ;
113433: LD_ADDR_VAR 0 32
113437: PUSH
113438: LD_VAR 0 32
113442: PUSH
113443: LD_VAR 0 4
113447: PUSH
113448: LD_VAR 0 7
113452: ARRAY
113453: UNION
113454: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
113455: LD_VAR 0 4
113459: PUSH
113460: LD_VAR 0 7
113464: ARRAY
113465: PPUSH
113466: CALL_OW 256
113470: PUSH
113471: LD_INT 1000
113473: EQUAL
113474: PUSH
113475: LD_VAR 0 4
113479: PUSH
113480: LD_VAR 0 7
113484: ARRAY
113485: PUSH
113486: LD_VAR 0 32
113490: IN
113491: AND
113492: IFFALSE 113516
// to_repair := to_repair diff group [ i ] ;
113494: LD_ADDR_VAR 0 32
113498: PUSH
113499: LD_VAR 0 32
113503: PUSH
113504: LD_VAR 0 4
113508: PUSH
113509: LD_VAR 0 7
113513: ARRAY
113514: DIFF
113515: ST_TO_ADDR
// if group [ i ] in to_repair then
113516: LD_VAR 0 4
113520: PUSH
113521: LD_VAR 0 7
113525: ARRAY
113526: PUSH
113527: LD_VAR 0 32
113531: IN
113532: IFFALSE 113579
// begin if not IsInArea ( group [ i ] , f_repair ) then
113534: LD_VAR 0 4
113538: PUSH
113539: LD_VAR 0 7
113543: ARRAY
113544: PPUSH
113545: LD_VAR 0 22
113549: PPUSH
113550: CALL_OW 308
113554: NOT
113555: IFFALSE 113577
// ComMoveToArea ( group [ i ] , f_repair ) ;
113557: LD_VAR 0 4
113561: PUSH
113562: LD_VAR 0 7
113566: ARRAY
113567: PPUSH
113568: LD_VAR 0 22
113572: PPUSH
113573: CALL_OW 113
// continue ;
113577: GO 113204
// end ; end else
113579: GO 113859
// if group [ i ] in repairs then
113581: LD_VAR 0 4
113585: PUSH
113586: LD_VAR 0 7
113590: ARRAY
113591: PUSH
113592: LD_VAR 0 33
113596: IN
113597: IFFALSE 113859
// begin if IsInUnit ( group [ i ] ) then
113599: LD_VAR 0 4
113603: PUSH
113604: LD_VAR 0 7
113608: ARRAY
113609: PPUSH
113610: CALL_OW 310
113614: IFFALSE 113682
// begin z := IsInUnit ( group [ i ] ) ;
113616: LD_ADDR_VAR 0 13
113620: PUSH
113621: LD_VAR 0 4
113625: PUSH
113626: LD_VAR 0 7
113630: ARRAY
113631: PPUSH
113632: CALL_OW 310
113636: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
113637: LD_VAR 0 13
113641: PUSH
113642: LD_VAR 0 32
113646: IN
113647: PUSH
113648: LD_VAR 0 13
113652: PPUSH
113653: LD_VAR 0 22
113657: PPUSH
113658: CALL_OW 308
113662: AND
113663: IFFALSE 113680
// ComExitVehicle ( group [ i ] ) ;
113665: LD_VAR 0 4
113669: PUSH
113670: LD_VAR 0 7
113674: ARRAY
113675: PPUSH
113676: CALL_OW 121
// end else
113680: GO 113859
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
113682: LD_ADDR_VAR 0 13
113686: PUSH
113687: LD_VAR 0 4
113691: PPUSH
113692: LD_INT 95
113694: PUSH
113695: LD_VAR 0 22
113699: PUSH
113700: EMPTY
113701: LIST
113702: LIST
113703: PUSH
113704: LD_INT 58
113706: PUSH
113707: EMPTY
113708: LIST
113709: PUSH
113710: EMPTY
113711: LIST
113712: LIST
113713: PPUSH
113714: CALL_OW 72
113718: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
113719: LD_VAR 0 4
113723: PUSH
113724: LD_VAR 0 7
113728: ARRAY
113729: PPUSH
113730: CALL_OW 314
113734: NOT
113735: IFFALSE 113857
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
113737: LD_ADDR_VAR 0 10
113741: PUSH
113742: LD_VAR 0 13
113746: PPUSH
113747: LD_VAR 0 4
113751: PUSH
113752: LD_VAR 0 7
113756: ARRAY
113757: PPUSH
113758: CALL_OW 74
113762: ST_TO_ADDR
// if not x then
113763: LD_VAR 0 10
113767: NOT
113768: IFFALSE 113772
// continue ;
113770: GO 113204
// if GetLives ( x ) < 1000 then
113772: LD_VAR 0 10
113776: PPUSH
113777: CALL_OW 256
113781: PUSH
113782: LD_INT 1000
113784: LESS
113785: IFFALSE 113809
// ComRepairVehicle ( group [ i ] , x ) else
113787: LD_VAR 0 4
113791: PUSH
113792: LD_VAR 0 7
113796: ARRAY
113797: PPUSH
113798: LD_VAR 0 10
113802: PPUSH
113803: CALL_OW 129
113807: GO 113857
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
113809: LD_VAR 0 23
113813: PUSH
113814: LD_VAR 0 4
113818: PUSH
113819: LD_VAR 0 7
113823: ARRAY
113824: PPUSH
113825: CALL_OW 256
113829: PUSH
113830: LD_INT 1000
113832: LESS
113833: AND
113834: NOT
113835: IFFALSE 113857
// ComEnterUnit ( group [ i ] , x ) ;
113837: LD_VAR 0 4
113841: PUSH
113842: LD_VAR 0 7
113846: ARRAY
113847: PPUSH
113848: LD_VAR 0 10
113852: PPUSH
113853: CALL_OW 120
// end ; continue ;
113857: GO 113204
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
113859: LD_VAR 0 23
113863: PUSH
113864: LD_VAR 0 4
113868: PUSH
113869: LD_VAR 0 7
113873: ARRAY
113874: PPUSH
113875: CALL_OW 247
113879: PUSH
113880: LD_INT 1
113882: EQUAL
113883: AND
113884: IFFALSE 114362
// begin if group [ i ] in healers then
113886: LD_VAR 0 4
113890: PUSH
113891: LD_VAR 0 7
113895: ARRAY
113896: PUSH
113897: LD_VAR 0 31
113901: IN
113902: IFFALSE 114175
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
113904: LD_VAR 0 4
113908: PUSH
113909: LD_VAR 0 7
113913: ARRAY
113914: PPUSH
113915: LD_VAR 0 23
113919: PPUSH
113920: CALL_OW 308
113924: NOT
113925: PUSH
113926: LD_VAR 0 4
113930: PUSH
113931: LD_VAR 0 7
113935: ARRAY
113936: PPUSH
113937: CALL_OW 314
113941: NOT
113942: AND
113943: IFFALSE 113967
// ComMoveToArea ( group [ i ] , f_heal ) else
113945: LD_VAR 0 4
113949: PUSH
113950: LD_VAR 0 7
113954: ARRAY
113955: PPUSH
113956: LD_VAR 0 23
113960: PPUSH
113961: CALL_OW 113
113965: GO 114173
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
113967: LD_VAR 0 4
113971: PUSH
113972: LD_VAR 0 7
113976: ARRAY
113977: PPUSH
113978: CALL 84254 0 1
113982: PPUSH
113983: CALL_OW 256
113987: PUSH
113988: LD_INT 1000
113990: EQUAL
113991: IFFALSE 114010
// ComStop ( group [ i ] ) else
113993: LD_VAR 0 4
113997: PUSH
113998: LD_VAR 0 7
114002: ARRAY
114003: PPUSH
114004: CALL_OW 141
114008: GO 114173
// if not HasTask ( group [ i ] ) and to_heal then
114010: LD_VAR 0 4
114014: PUSH
114015: LD_VAR 0 7
114019: ARRAY
114020: PPUSH
114021: CALL_OW 314
114025: NOT
114026: PUSH
114027: LD_VAR 0 30
114031: AND
114032: IFFALSE 114173
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
114034: LD_ADDR_VAR 0 13
114038: PUSH
114039: LD_VAR 0 30
114043: PPUSH
114044: LD_INT 3
114046: PUSH
114047: LD_INT 54
114049: PUSH
114050: EMPTY
114051: LIST
114052: PUSH
114053: EMPTY
114054: LIST
114055: LIST
114056: PPUSH
114057: CALL_OW 72
114061: PPUSH
114062: LD_VAR 0 4
114066: PUSH
114067: LD_VAR 0 7
114071: ARRAY
114072: PPUSH
114073: CALL_OW 74
114077: ST_TO_ADDR
// if z then
114078: LD_VAR 0 13
114082: IFFALSE 114173
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
114084: LD_INT 91
114086: PUSH
114087: LD_VAR 0 13
114091: PUSH
114092: LD_INT 10
114094: PUSH
114095: EMPTY
114096: LIST
114097: LIST
114098: LIST
114099: PUSH
114100: LD_INT 81
114102: PUSH
114103: LD_VAR 0 13
114107: PPUSH
114108: CALL_OW 255
114112: PUSH
114113: EMPTY
114114: LIST
114115: LIST
114116: PUSH
114117: EMPTY
114118: LIST
114119: LIST
114120: PPUSH
114121: CALL_OW 69
114125: PUSH
114126: LD_INT 0
114128: EQUAL
114129: IFFALSE 114153
// ComHeal ( group [ i ] , z ) else
114131: LD_VAR 0 4
114135: PUSH
114136: LD_VAR 0 7
114140: ARRAY
114141: PPUSH
114142: LD_VAR 0 13
114146: PPUSH
114147: CALL_OW 128
114151: GO 114173
// ComMoveToArea ( group [ i ] , f_heal ) ;
114153: LD_VAR 0 4
114157: PUSH
114158: LD_VAR 0 7
114162: ARRAY
114163: PPUSH
114164: LD_VAR 0 23
114168: PPUSH
114169: CALL_OW 113
// end ; continue ;
114173: GO 113204
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
114175: LD_VAR 0 4
114179: PUSH
114180: LD_VAR 0 7
114184: ARRAY
114185: PPUSH
114186: CALL_OW 256
114190: PUSH
114191: LD_INT 700
114193: LESS
114194: PUSH
114195: LD_VAR 0 4
114199: PUSH
114200: LD_VAR 0 7
114204: ARRAY
114205: PUSH
114206: LD_VAR 0 30
114210: IN
114211: NOT
114212: AND
114213: IFFALSE 114237
// to_heal := to_heal union group [ i ] ;
114215: LD_ADDR_VAR 0 30
114219: PUSH
114220: LD_VAR 0 30
114224: PUSH
114225: LD_VAR 0 4
114229: PUSH
114230: LD_VAR 0 7
114234: ARRAY
114235: UNION
114236: ST_TO_ADDR
// if group [ i ] in to_heal then
114237: LD_VAR 0 4
114241: PUSH
114242: LD_VAR 0 7
114246: ARRAY
114247: PUSH
114248: LD_VAR 0 30
114252: IN
114253: IFFALSE 114362
// begin if GetLives ( group [ i ] ) = 1000 then
114255: LD_VAR 0 4
114259: PUSH
114260: LD_VAR 0 7
114264: ARRAY
114265: PPUSH
114266: CALL_OW 256
114270: PUSH
114271: LD_INT 1000
114273: EQUAL
114274: IFFALSE 114300
// to_heal := to_heal diff group [ i ] else
114276: LD_ADDR_VAR 0 30
114280: PUSH
114281: LD_VAR 0 30
114285: PUSH
114286: LD_VAR 0 4
114290: PUSH
114291: LD_VAR 0 7
114295: ARRAY
114296: DIFF
114297: ST_TO_ADDR
114298: GO 114362
// begin if not IsInArea ( group [ i ] , to_heal ) then
114300: LD_VAR 0 4
114304: PUSH
114305: LD_VAR 0 7
114309: ARRAY
114310: PPUSH
114311: LD_VAR 0 30
114315: PPUSH
114316: CALL_OW 308
114320: NOT
114321: IFFALSE 114345
// ComMoveToArea ( group [ i ] , f_heal ) else
114323: LD_VAR 0 4
114327: PUSH
114328: LD_VAR 0 7
114332: ARRAY
114333: PPUSH
114334: LD_VAR 0 23
114338: PPUSH
114339: CALL_OW 113
114343: GO 114360
// ComHold ( group [ i ] ) ;
114345: LD_VAR 0 4
114349: PUSH
114350: LD_VAR 0 7
114354: ARRAY
114355: PPUSH
114356: CALL_OW 140
// continue ;
114360: GO 113204
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
114362: LD_VAR 0 4
114366: PUSH
114367: LD_VAR 0 7
114371: ARRAY
114372: PPUSH
114373: LD_INT 10
114375: PPUSH
114376: CALL 82036 0 2
114380: NOT
114381: PUSH
114382: LD_VAR 0 16
114386: PUSH
114387: LD_VAR 0 7
114391: ARRAY
114392: PUSH
114393: EMPTY
114394: EQUAL
114395: NOT
114396: AND
114397: IFFALSE 114663
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
114399: LD_VAR 0 4
114403: PUSH
114404: LD_VAR 0 7
114408: ARRAY
114409: PPUSH
114410: CALL_OW 262
114414: PUSH
114415: LD_INT 1
114417: PUSH
114418: LD_INT 2
114420: PUSH
114421: EMPTY
114422: LIST
114423: LIST
114424: IN
114425: IFFALSE 114466
// if GetFuel ( group [ i ] ) < 10 then
114427: LD_VAR 0 4
114431: PUSH
114432: LD_VAR 0 7
114436: ARRAY
114437: PPUSH
114438: CALL_OW 261
114442: PUSH
114443: LD_INT 10
114445: LESS
114446: IFFALSE 114466
// SetFuel ( group [ i ] , 12 ) ;
114448: LD_VAR 0 4
114452: PUSH
114453: LD_VAR 0 7
114457: ARRAY
114458: PPUSH
114459: LD_INT 12
114461: PPUSH
114462: CALL_OW 240
// if units_path [ i ] then
114466: LD_VAR 0 16
114470: PUSH
114471: LD_VAR 0 7
114475: ARRAY
114476: IFFALSE 114661
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
114478: LD_VAR 0 4
114482: PUSH
114483: LD_VAR 0 7
114487: ARRAY
114488: PPUSH
114489: LD_VAR 0 16
114493: PUSH
114494: LD_VAR 0 7
114498: ARRAY
114499: PUSH
114500: LD_INT 1
114502: ARRAY
114503: PUSH
114504: LD_INT 1
114506: ARRAY
114507: PPUSH
114508: LD_VAR 0 16
114512: PUSH
114513: LD_VAR 0 7
114517: ARRAY
114518: PUSH
114519: LD_INT 1
114521: ARRAY
114522: PUSH
114523: LD_INT 2
114525: ARRAY
114526: PPUSH
114527: CALL_OW 297
114531: PUSH
114532: LD_INT 6
114534: GREATER
114535: IFFALSE 114610
// begin if not HasTask ( group [ i ] ) then
114537: LD_VAR 0 4
114541: PUSH
114542: LD_VAR 0 7
114546: ARRAY
114547: PPUSH
114548: CALL_OW 314
114552: NOT
114553: IFFALSE 114608
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
114555: LD_VAR 0 4
114559: PUSH
114560: LD_VAR 0 7
114564: ARRAY
114565: PPUSH
114566: LD_VAR 0 16
114570: PUSH
114571: LD_VAR 0 7
114575: ARRAY
114576: PUSH
114577: LD_INT 1
114579: ARRAY
114580: PUSH
114581: LD_INT 1
114583: ARRAY
114584: PPUSH
114585: LD_VAR 0 16
114589: PUSH
114590: LD_VAR 0 7
114594: ARRAY
114595: PUSH
114596: LD_INT 1
114598: ARRAY
114599: PUSH
114600: LD_INT 2
114602: ARRAY
114603: PPUSH
114604: CALL_OW 114
// end else
114608: GO 114661
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
114610: LD_ADDR_VAR 0 15
114614: PUSH
114615: LD_VAR 0 16
114619: PUSH
114620: LD_VAR 0 7
114624: ARRAY
114625: PPUSH
114626: LD_INT 1
114628: PPUSH
114629: CALL_OW 3
114633: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
114634: LD_ADDR_VAR 0 16
114638: PUSH
114639: LD_VAR 0 16
114643: PPUSH
114644: LD_VAR 0 7
114648: PPUSH
114649: LD_VAR 0 15
114653: PPUSH
114654: CALL_OW 1
114658: ST_TO_ADDR
// continue ;
114659: GO 113204
// end ; end ; end else
114661: GO 117325
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
114663: LD_ADDR_VAR 0 14
114667: PUSH
114668: LD_INT 81
114670: PUSH
114671: LD_VAR 0 4
114675: PUSH
114676: LD_VAR 0 7
114680: ARRAY
114681: PPUSH
114682: CALL_OW 255
114686: PUSH
114687: EMPTY
114688: LIST
114689: LIST
114690: PPUSH
114691: CALL_OW 69
114695: ST_TO_ADDR
// if not tmp then
114696: LD_VAR 0 14
114700: NOT
114701: IFFALSE 114705
// continue ;
114703: GO 113204
// if f_ignore_area then
114705: LD_VAR 0 17
114709: IFFALSE 114797
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
114711: LD_ADDR_VAR 0 15
114715: PUSH
114716: LD_VAR 0 14
114720: PPUSH
114721: LD_INT 3
114723: PUSH
114724: LD_INT 92
114726: PUSH
114727: LD_VAR 0 17
114731: PUSH
114732: LD_INT 1
114734: ARRAY
114735: PUSH
114736: LD_VAR 0 17
114740: PUSH
114741: LD_INT 2
114743: ARRAY
114744: PUSH
114745: LD_VAR 0 17
114749: PUSH
114750: LD_INT 3
114752: ARRAY
114753: PUSH
114754: EMPTY
114755: LIST
114756: LIST
114757: LIST
114758: LIST
114759: PUSH
114760: EMPTY
114761: LIST
114762: LIST
114763: PPUSH
114764: CALL_OW 72
114768: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
114769: LD_VAR 0 14
114773: PUSH
114774: LD_VAR 0 15
114778: DIFF
114779: IFFALSE 114797
// tmp := tmp diff tmp2 ;
114781: LD_ADDR_VAR 0 14
114785: PUSH
114786: LD_VAR 0 14
114790: PUSH
114791: LD_VAR 0 15
114795: DIFF
114796: ST_TO_ADDR
// end ; if not f_murder then
114797: LD_VAR 0 20
114801: NOT
114802: IFFALSE 114860
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
114804: LD_ADDR_VAR 0 15
114808: PUSH
114809: LD_VAR 0 14
114813: PPUSH
114814: LD_INT 3
114816: PUSH
114817: LD_INT 50
114819: PUSH
114820: EMPTY
114821: LIST
114822: PUSH
114823: EMPTY
114824: LIST
114825: LIST
114826: PPUSH
114827: CALL_OW 72
114831: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
114832: LD_VAR 0 14
114836: PUSH
114837: LD_VAR 0 15
114841: DIFF
114842: IFFALSE 114860
// tmp := tmp diff tmp2 ;
114844: LD_ADDR_VAR 0 14
114848: PUSH
114849: LD_VAR 0 14
114853: PUSH
114854: LD_VAR 0 15
114858: DIFF
114859: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
114860: LD_ADDR_VAR 0 14
114864: PUSH
114865: LD_VAR 0 4
114869: PUSH
114870: LD_VAR 0 7
114874: ARRAY
114875: PPUSH
114876: LD_VAR 0 14
114880: PPUSH
114881: LD_INT 1
114883: PPUSH
114884: LD_INT 1
114886: PPUSH
114887: CALL 54580 0 4
114891: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
114892: LD_VAR 0 4
114896: PUSH
114897: LD_VAR 0 7
114901: ARRAY
114902: PPUSH
114903: CALL_OW 257
114907: PUSH
114908: LD_INT 1
114910: EQUAL
114911: IFFALSE 115359
// begin if WantPlant ( group [ i ] ) then
114913: LD_VAR 0 4
114917: PUSH
114918: LD_VAR 0 7
114922: ARRAY
114923: PPUSH
114924: CALL 54081 0 1
114928: IFFALSE 114932
// continue ;
114930: GO 113204
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
114932: LD_VAR 0 18
114936: PUSH
114937: LD_VAR 0 4
114941: PUSH
114942: LD_VAR 0 7
114946: ARRAY
114947: PPUSH
114948: CALL_OW 310
114952: NOT
114953: AND
114954: PUSH
114955: LD_VAR 0 14
114959: PUSH
114960: LD_INT 1
114962: ARRAY
114963: PUSH
114964: LD_VAR 0 14
114968: PPUSH
114969: LD_INT 21
114971: PUSH
114972: LD_INT 2
114974: PUSH
114975: EMPTY
114976: LIST
114977: LIST
114978: PUSH
114979: LD_INT 58
114981: PUSH
114982: EMPTY
114983: LIST
114984: PUSH
114985: EMPTY
114986: LIST
114987: LIST
114988: PPUSH
114989: CALL_OW 72
114993: IN
114994: AND
114995: IFFALSE 115031
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
114997: LD_VAR 0 4
115001: PUSH
115002: LD_VAR 0 7
115006: ARRAY
115007: PPUSH
115008: LD_VAR 0 14
115012: PUSH
115013: LD_INT 1
115015: ARRAY
115016: PPUSH
115017: CALL_OW 120
// attacking := true ;
115021: LD_ADDR_VAR 0 29
115025: PUSH
115026: LD_INT 1
115028: ST_TO_ADDR
// continue ;
115029: GO 113204
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
115031: LD_VAR 0 26
115035: PUSH
115036: LD_VAR 0 4
115040: PUSH
115041: LD_VAR 0 7
115045: ARRAY
115046: PPUSH
115047: CALL_OW 257
115051: PUSH
115052: LD_INT 1
115054: EQUAL
115055: AND
115056: PUSH
115057: LD_VAR 0 4
115061: PUSH
115062: LD_VAR 0 7
115066: ARRAY
115067: PPUSH
115068: CALL_OW 256
115072: PUSH
115073: LD_INT 800
115075: LESS
115076: AND
115077: PUSH
115078: LD_VAR 0 4
115082: PUSH
115083: LD_VAR 0 7
115087: ARRAY
115088: PPUSH
115089: CALL_OW 318
115093: NOT
115094: AND
115095: IFFALSE 115112
// ComCrawl ( group [ i ] ) ;
115097: LD_VAR 0 4
115101: PUSH
115102: LD_VAR 0 7
115106: ARRAY
115107: PPUSH
115108: CALL_OW 137
// if f_mines then
115112: LD_VAR 0 21
115116: IFFALSE 115359
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
115118: LD_VAR 0 14
115122: PUSH
115123: LD_INT 1
115125: ARRAY
115126: PPUSH
115127: CALL_OW 247
115131: PUSH
115132: LD_INT 3
115134: EQUAL
115135: PUSH
115136: LD_VAR 0 14
115140: PUSH
115141: LD_INT 1
115143: ARRAY
115144: PUSH
115145: LD_VAR 0 27
115149: IN
115150: NOT
115151: AND
115152: IFFALSE 115359
// begin x := GetX ( tmp [ 1 ] ) ;
115154: LD_ADDR_VAR 0 10
115158: PUSH
115159: LD_VAR 0 14
115163: PUSH
115164: LD_INT 1
115166: ARRAY
115167: PPUSH
115168: CALL_OW 250
115172: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
115173: LD_ADDR_VAR 0 11
115177: PUSH
115178: LD_VAR 0 14
115182: PUSH
115183: LD_INT 1
115185: ARRAY
115186: PPUSH
115187: CALL_OW 251
115191: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
115192: LD_ADDR_VAR 0 12
115196: PUSH
115197: LD_VAR 0 4
115201: PUSH
115202: LD_VAR 0 7
115206: ARRAY
115207: PPUSH
115208: CALL 82121 0 1
115212: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
115213: LD_VAR 0 4
115217: PUSH
115218: LD_VAR 0 7
115222: ARRAY
115223: PPUSH
115224: LD_VAR 0 10
115228: PPUSH
115229: LD_VAR 0 11
115233: PPUSH
115234: LD_VAR 0 14
115238: PUSH
115239: LD_INT 1
115241: ARRAY
115242: PPUSH
115243: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
115247: LD_VAR 0 4
115251: PUSH
115252: LD_VAR 0 7
115256: ARRAY
115257: PPUSH
115258: LD_VAR 0 10
115262: PPUSH
115263: LD_VAR 0 12
115267: PPUSH
115268: LD_INT 7
115270: PPUSH
115271: CALL_OW 272
115275: PPUSH
115276: LD_VAR 0 11
115280: PPUSH
115281: LD_VAR 0 12
115285: PPUSH
115286: LD_INT 7
115288: PPUSH
115289: CALL_OW 273
115293: PPUSH
115294: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
115298: LD_VAR 0 4
115302: PUSH
115303: LD_VAR 0 7
115307: ARRAY
115308: PPUSH
115309: LD_INT 71
115311: PPUSH
115312: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
115316: LD_ADDR_VAR 0 27
115320: PUSH
115321: LD_VAR 0 27
115325: PPUSH
115326: LD_VAR 0 27
115330: PUSH
115331: LD_INT 1
115333: PLUS
115334: PPUSH
115335: LD_VAR 0 14
115339: PUSH
115340: LD_INT 1
115342: ARRAY
115343: PPUSH
115344: CALL_OW 1
115348: ST_TO_ADDR
// attacking := true ;
115349: LD_ADDR_VAR 0 29
115353: PUSH
115354: LD_INT 1
115356: ST_TO_ADDR
// continue ;
115357: GO 113204
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
115359: LD_VAR 0 4
115363: PUSH
115364: LD_VAR 0 7
115368: ARRAY
115369: PPUSH
115370: CALL_OW 257
115374: PUSH
115375: LD_INT 17
115377: EQUAL
115378: PUSH
115379: LD_VAR 0 4
115383: PUSH
115384: LD_VAR 0 7
115388: ARRAY
115389: PPUSH
115390: CALL_OW 110
115394: PUSH
115395: LD_INT 71
115397: EQUAL
115398: NOT
115399: AND
115400: IFFALSE 115546
// begin attacking := false ;
115402: LD_ADDR_VAR 0 29
115406: PUSH
115407: LD_INT 0
115409: ST_TO_ADDR
// k := 5 ;
115410: LD_ADDR_VAR 0 9
115414: PUSH
115415: LD_INT 5
115417: ST_TO_ADDR
// if tmp < k then
115418: LD_VAR 0 14
115422: PUSH
115423: LD_VAR 0 9
115427: LESS
115428: IFFALSE 115440
// k := tmp ;
115430: LD_ADDR_VAR 0 9
115434: PUSH
115435: LD_VAR 0 14
115439: ST_TO_ADDR
// for j = 1 to k do
115440: LD_ADDR_VAR 0 8
115444: PUSH
115445: DOUBLE
115446: LD_INT 1
115448: DEC
115449: ST_TO_ADDR
115450: LD_VAR 0 9
115454: PUSH
115455: FOR_TO
115456: IFFALSE 115544
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
115458: LD_VAR 0 14
115462: PUSH
115463: LD_VAR 0 8
115467: ARRAY
115468: PUSH
115469: LD_VAR 0 14
115473: PPUSH
115474: LD_INT 58
115476: PUSH
115477: EMPTY
115478: LIST
115479: PPUSH
115480: CALL_OW 72
115484: IN
115485: NOT
115486: IFFALSE 115542
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
115488: LD_VAR 0 4
115492: PUSH
115493: LD_VAR 0 7
115497: ARRAY
115498: PPUSH
115499: LD_VAR 0 14
115503: PUSH
115504: LD_VAR 0 8
115508: ARRAY
115509: PPUSH
115510: CALL_OW 115
// attacking := true ;
115514: LD_ADDR_VAR 0 29
115518: PUSH
115519: LD_INT 1
115521: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
115522: LD_VAR 0 4
115526: PUSH
115527: LD_VAR 0 7
115531: ARRAY
115532: PPUSH
115533: LD_INT 71
115535: PPUSH
115536: CALL_OW 109
// continue ;
115540: GO 115455
// end ; end ;
115542: GO 115455
115544: POP
115545: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
115546: LD_VAR 0 4
115550: PUSH
115551: LD_VAR 0 7
115555: ARRAY
115556: PPUSH
115557: CALL_OW 257
115561: PUSH
115562: LD_INT 8
115564: EQUAL
115565: PUSH
115566: LD_VAR 0 4
115570: PUSH
115571: LD_VAR 0 7
115575: ARRAY
115576: PPUSH
115577: CALL_OW 264
115581: PUSH
115582: LD_INT 28
115584: PUSH
115585: LD_INT 45
115587: PUSH
115588: LD_INT 7
115590: PUSH
115591: LD_INT 47
115593: PUSH
115594: EMPTY
115595: LIST
115596: LIST
115597: LIST
115598: LIST
115599: IN
115600: OR
115601: IFFALSE 115857
// begin attacking := false ;
115603: LD_ADDR_VAR 0 29
115607: PUSH
115608: LD_INT 0
115610: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
115611: LD_VAR 0 14
115615: PUSH
115616: LD_INT 1
115618: ARRAY
115619: PPUSH
115620: CALL_OW 266
115624: PUSH
115625: LD_INT 32
115627: PUSH
115628: LD_INT 31
115630: PUSH
115631: LD_INT 33
115633: PUSH
115634: LD_INT 4
115636: PUSH
115637: LD_INT 5
115639: PUSH
115640: EMPTY
115641: LIST
115642: LIST
115643: LIST
115644: LIST
115645: LIST
115646: IN
115647: IFFALSE 115833
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
115649: LD_ADDR_VAR 0 9
115653: PUSH
115654: LD_VAR 0 14
115658: PUSH
115659: LD_INT 1
115661: ARRAY
115662: PPUSH
115663: CALL_OW 266
115667: PPUSH
115668: LD_VAR 0 14
115672: PUSH
115673: LD_INT 1
115675: ARRAY
115676: PPUSH
115677: CALL_OW 250
115681: PPUSH
115682: LD_VAR 0 14
115686: PUSH
115687: LD_INT 1
115689: ARRAY
115690: PPUSH
115691: CALL_OW 251
115695: PPUSH
115696: LD_VAR 0 14
115700: PUSH
115701: LD_INT 1
115703: ARRAY
115704: PPUSH
115705: CALL_OW 254
115709: PPUSH
115710: LD_VAR 0 14
115714: PUSH
115715: LD_INT 1
115717: ARRAY
115718: PPUSH
115719: CALL_OW 248
115723: PPUSH
115724: LD_INT 0
115726: PPUSH
115727: CALL 63491 0 6
115731: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
115732: LD_ADDR_VAR 0 8
115736: PUSH
115737: LD_VAR 0 4
115741: PUSH
115742: LD_VAR 0 7
115746: ARRAY
115747: PPUSH
115748: LD_VAR 0 9
115752: PPUSH
115753: CALL 82234 0 2
115757: ST_TO_ADDR
// if j then
115758: LD_VAR 0 8
115762: IFFALSE 115831
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
115764: LD_VAR 0 8
115768: PUSH
115769: LD_INT 1
115771: ARRAY
115772: PPUSH
115773: LD_VAR 0 8
115777: PUSH
115778: LD_INT 2
115780: ARRAY
115781: PPUSH
115782: CALL_OW 488
115786: IFFALSE 115831
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
115788: LD_VAR 0 4
115792: PUSH
115793: LD_VAR 0 7
115797: ARRAY
115798: PPUSH
115799: LD_VAR 0 8
115803: PUSH
115804: LD_INT 1
115806: ARRAY
115807: PPUSH
115808: LD_VAR 0 8
115812: PUSH
115813: LD_INT 2
115815: ARRAY
115816: PPUSH
115817: CALL_OW 116
// attacking := true ;
115821: LD_ADDR_VAR 0 29
115825: PUSH
115826: LD_INT 1
115828: ST_TO_ADDR
// continue ;
115829: GO 113204
// end ; end else
115831: GO 115857
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
115833: LD_VAR 0 4
115837: PUSH
115838: LD_VAR 0 7
115842: ARRAY
115843: PPUSH
115844: LD_VAR 0 14
115848: PUSH
115849: LD_INT 1
115851: ARRAY
115852: PPUSH
115853: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
115857: LD_VAR 0 4
115861: PUSH
115862: LD_VAR 0 7
115866: ARRAY
115867: PPUSH
115868: CALL_OW 265
115872: PUSH
115873: LD_INT 11
115875: EQUAL
115876: IFFALSE 116154
// begin k := 10 ;
115878: LD_ADDR_VAR 0 9
115882: PUSH
115883: LD_INT 10
115885: ST_TO_ADDR
// x := 0 ;
115886: LD_ADDR_VAR 0 10
115890: PUSH
115891: LD_INT 0
115893: ST_TO_ADDR
// if tmp < k then
115894: LD_VAR 0 14
115898: PUSH
115899: LD_VAR 0 9
115903: LESS
115904: IFFALSE 115916
// k := tmp ;
115906: LD_ADDR_VAR 0 9
115910: PUSH
115911: LD_VAR 0 14
115915: ST_TO_ADDR
// for j = k downto 1 do
115916: LD_ADDR_VAR 0 8
115920: PUSH
115921: DOUBLE
115922: LD_VAR 0 9
115926: INC
115927: ST_TO_ADDR
115928: LD_INT 1
115930: PUSH
115931: FOR_DOWNTO
115932: IFFALSE 116007
// begin if GetType ( tmp [ j ] ) = unit_human then
115934: LD_VAR 0 14
115938: PUSH
115939: LD_VAR 0 8
115943: ARRAY
115944: PPUSH
115945: CALL_OW 247
115949: PUSH
115950: LD_INT 1
115952: EQUAL
115953: IFFALSE 116005
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
115955: LD_VAR 0 4
115959: PUSH
115960: LD_VAR 0 7
115964: ARRAY
115965: PPUSH
115966: LD_VAR 0 14
115970: PUSH
115971: LD_VAR 0 8
115975: ARRAY
115976: PPUSH
115977: CALL 82488 0 2
// x := tmp [ j ] ;
115981: LD_ADDR_VAR 0 10
115985: PUSH
115986: LD_VAR 0 14
115990: PUSH
115991: LD_VAR 0 8
115995: ARRAY
115996: ST_TO_ADDR
// attacking := true ;
115997: LD_ADDR_VAR 0 29
116001: PUSH
116002: LD_INT 1
116004: ST_TO_ADDR
// end ; end ;
116005: GO 115931
116007: POP
116008: POP
// if not x then
116009: LD_VAR 0 10
116013: NOT
116014: IFFALSE 116154
// begin attacking := true ;
116016: LD_ADDR_VAR 0 29
116020: PUSH
116021: LD_INT 1
116023: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
116024: LD_VAR 0 4
116028: PUSH
116029: LD_VAR 0 7
116033: ARRAY
116034: PPUSH
116035: CALL_OW 250
116039: PPUSH
116040: LD_VAR 0 4
116044: PUSH
116045: LD_VAR 0 7
116049: ARRAY
116050: PPUSH
116051: CALL_OW 251
116055: PPUSH
116056: CALL_OW 546
116060: PUSH
116061: LD_INT 2
116063: ARRAY
116064: PUSH
116065: LD_VAR 0 14
116069: PUSH
116070: LD_INT 1
116072: ARRAY
116073: PPUSH
116074: CALL_OW 250
116078: PPUSH
116079: LD_VAR 0 14
116083: PUSH
116084: LD_INT 1
116086: ARRAY
116087: PPUSH
116088: CALL_OW 251
116092: PPUSH
116093: CALL_OW 546
116097: PUSH
116098: LD_INT 2
116100: ARRAY
116101: EQUAL
116102: IFFALSE 116130
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
116104: LD_VAR 0 4
116108: PUSH
116109: LD_VAR 0 7
116113: ARRAY
116114: PPUSH
116115: LD_VAR 0 14
116119: PUSH
116120: LD_INT 1
116122: ARRAY
116123: PPUSH
116124: CALL 82488 0 2
116128: GO 116154
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
116130: LD_VAR 0 4
116134: PUSH
116135: LD_VAR 0 7
116139: ARRAY
116140: PPUSH
116141: LD_VAR 0 14
116145: PUSH
116146: LD_INT 1
116148: ARRAY
116149: PPUSH
116150: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
116154: LD_VAR 0 4
116158: PUSH
116159: LD_VAR 0 7
116163: ARRAY
116164: PPUSH
116165: CALL_OW 264
116169: PUSH
116170: LD_INT 29
116172: EQUAL
116173: IFFALSE 116539
// begin if WantsToAttack ( group [ i ] ) in bombed then
116175: LD_VAR 0 4
116179: PUSH
116180: LD_VAR 0 7
116184: ARRAY
116185: PPUSH
116186: CALL_OW 319
116190: PUSH
116191: LD_VAR 0 28
116195: IN
116196: IFFALSE 116200
// continue ;
116198: GO 113204
// k := 8 ;
116200: LD_ADDR_VAR 0 9
116204: PUSH
116205: LD_INT 8
116207: ST_TO_ADDR
// x := 0 ;
116208: LD_ADDR_VAR 0 10
116212: PUSH
116213: LD_INT 0
116215: ST_TO_ADDR
// if tmp < k then
116216: LD_VAR 0 14
116220: PUSH
116221: LD_VAR 0 9
116225: LESS
116226: IFFALSE 116238
// k := tmp ;
116228: LD_ADDR_VAR 0 9
116232: PUSH
116233: LD_VAR 0 14
116237: ST_TO_ADDR
// for j = 1 to k do
116238: LD_ADDR_VAR 0 8
116242: PUSH
116243: DOUBLE
116244: LD_INT 1
116246: DEC
116247: ST_TO_ADDR
116248: LD_VAR 0 9
116252: PUSH
116253: FOR_TO
116254: IFFALSE 116386
// begin if GetType ( tmp [ j ] ) = unit_building then
116256: LD_VAR 0 14
116260: PUSH
116261: LD_VAR 0 8
116265: ARRAY
116266: PPUSH
116267: CALL_OW 247
116271: PUSH
116272: LD_INT 3
116274: EQUAL
116275: IFFALSE 116384
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
116277: LD_VAR 0 14
116281: PUSH
116282: LD_VAR 0 8
116286: ARRAY
116287: PUSH
116288: LD_VAR 0 28
116292: IN
116293: NOT
116294: PUSH
116295: LD_VAR 0 14
116299: PUSH
116300: LD_VAR 0 8
116304: ARRAY
116305: PPUSH
116306: CALL_OW 313
116310: AND
116311: IFFALSE 116384
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
116313: LD_VAR 0 4
116317: PUSH
116318: LD_VAR 0 7
116322: ARRAY
116323: PPUSH
116324: LD_VAR 0 14
116328: PUSH
116329: LD_VAR 0 8
116333: ARRAY
116334: PPUSH
116335: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
116339: LD_ADDR_VAR 0 28
116343: PUSH
116344: LD_VAR 0 28
116348: PPUSH
116349: LD_VAR 0 28
116353: PUSH
116354: LD_INT 1
116356: PLUS
116357: PPUSH
116358: LD_VAR 0 14
116362: PUSH
116363: LD_VAR 0 8
116367: ARRAY
116368: PPUSH
116369: CALL_OW 1
116373: ST_TO_ADDR
// attacking := true ;
116374: LD_ADDR_VAR 0 29
116378: PUSH
116379: LD_INT 1
116381: ST_TO_ADDR
// break ;
116382: GO 116386
// end ; end ;
116384: GO 116253
116386: POP
116387: POP
// if not attacking and f_attack_depot then
116388: LD_VAR 0 29
116392: NOT
116393: PUSH
116394: LD_VAR 0 25
116398: AND
116399: IFFALSE 116494
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
116401: LD_ADDR_VAR 0 13
116405: PUSH
116406: LD_VAR 0 14
116410: PPUSH
116411: LD_INT 2
116413: PUSH
116414: LD_INT 30
116416: PUSH
116417: LD_INT 0
116419: PUSH
116420: EMPTY
116421: LIST
116422: LIST
116423: PUSH
116424: LD_INT 30
116426: PUSH
116427: LD_INT 1
116429: PUSH
116430: EMPTY
116431: LIST
116432: LIST
116433: PUSH
116434: EMPTY
116435: LIST
116436: LIST
116437: LIST
116438: PPUSH
116439: CALL_OW 72
116443: ST_TO_ADDR
// if z then
116444: LD_VAR 0 13
116448: IFFALSE 116494
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
116450: LD_VAR 0 4
116454: PUSH
116455: LD_VAR 0 7
116459: ARRAY
116460: PPUSH
116461: LD_VAR 0 13
116465: PPUSH
116466: LD_VAR 0 4
116470: PUSH
116471: LD_VAR 0 7
116475: ARRAY
116476: PPUSH
116477: CALL_OW 74
116481: PPUSH
116482: CALL_OW 115
// attacking := true ;
116486: LD_ADDR_VAR 0 29
116490: PUSH
116491: LD_INT 1
116493: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
116494: LD_VAR 0 4
116498: PUSH
116499: LD_VAR 0 7
116503: ARRAY
116504: PPUSH
116505: CALL_OW 256
116509: PUSH
116510: LD_INT 500
116512: LESS
116513: IFFALSE 116539
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
116515: LD_VAR 0 4
116519: PUSH
116520: LD_VAR 0 7
116524: ARRAY
116525: PPUSH
116526: LD_VAR 0 14
116530: PUSH
116531: LD_INT 1
116533: ARRAY
116534: PPUSH
116535: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
116539: LD_VAR 0 4
116543: PUSH
116544: LD_VAR 0 7
116548: ARRAY
116549: PPUSH
116550: CALL_OW 264
116554: PUSH
116555: LD_INT 49
116557: EQUAL
116558: IFFALSE 116679
// begin if not HasTask ( group [ i ] ) then
116560: LD_VAR 0 4
116564: PUSH
116565: LD_VAR 0 7
116569: ARRAY
116570: PPUSH
116571: CALL_OW 314
116575: NOT
116576: IFFALSE 116679
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
116578: LD_ADDR_VAR 0 9
116582: PUSH
116583: LD_INT 81
116585: PUSH
116586: LD_VAR 0 4
116590: PUSH
116591: LD_VAR 0 7
116595: ARRAY
116596: PPUSH
116597: CALL_OW 255
116601: PUSH
116602: EMPTY
116603: LIST
116604: LIST
116605: PPUSH
116606: CALL_OW 69
116610: PPUSH
116611: LD_VAR 0 4
116615: PUSH
116616: LD_VAR 0 7
116620: ARRAY
116621: PPUSH
116622: CALL_OW 74
116626: ST_TO_ADDR
// if k then
116627: LD_VAR 0 9
116631: IFFALSE 116679
// if GetDistUnits ( group [ i ] , k ) > 10 then
116633: LD_VAR 0 4
116637: PUSH
116638: LD_VAR 0 7
116642: ARRAY
116643: PPUSH
116644: LD_VAR 0 9
116648: PPUSH
116649: CALL_OW 296
116653: PUSH
116654: LD_INT 10
116656: GREATER
116657: IFFALSE 116679
// ComMoveUnit ( group [ i ] , k ) ;
116659: LD_VAR 0 4
116663: PUSH
116664: LD_VAR 0 7
116668: ARRAY
116669: PPUSH
116670: LD_VAR 0 9
116674: PPUSH
116675: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
116679: LD_VAR 0 4
116683: PUSH
116684: LD_VAR 0 7
116688: ARRAY
116689: PPUSH
116690: CALL_OW 256
116694: PUSH
116695: LD_INT 250
116697: LESS
116698: PUSH
116699: LD_VAR 0 4
116703: PUSH
116704: LD_VAR 0 7
116708: ARRAY
116709: PUSH
116710: LD_INT 21
116712: PUSH
116713: LD_INT 2
116715: PUSH
116716: EMPTY
116717: LIST
116718: LIST
116719: PUSH
116720: LD_INT 23
116722: PUSH
116723: LD_INT 2
116725: PUSH
116726: EMPTY
116727: LIST
116728: LIST
116729: PUSH
116730: EMPTY
116731: LIST
116732: LIST
116733: PPUSH
116734: CALL_OW 69
116738: IN
116739: AND
116740: IFFALSE 116865
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
116742: LD_ADDR_VAR 0 9
116746: PUSH
116747: LD_OWVAR 3
116751: PUSH
116752: LD_VAR 0 4
116756: PUSH
116757: LD_VAR 0 7
116761: ARRAY
116762: DIFF
116763: PPUSH
116764: LD_VAR 0 4
116768: PUSH
116769: LD_VAR 0 7
116773: ARRAY
116774: PPUSH
116775: CALL_OW 74
116779: ST_TO_ADDR
// if not k then
116780: LD_VAR 0 9
116784: NOT
116785: IFFALSE 116789
// continue ;
116787: GO 113204
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
116789: LD_VAR 0 9
116793: PUSH
116794: LD_INT 81
116796: PUSH
116797: LD_VAR 0 4
116801: PUSH
116802: LD_VAR 0 7
116806: ARRAY
116807: PPUSH
116808: CALL_OW 255
116812: PUSH
116813: EMPTY
116814: LIST
116815: LIST
116816: PPUSH
116817: CALL_OW 69
116821: IN
116822: PUSH
116823: LD_VAR 0 9
116827: PPUSH
116828: LD_VAR 0 4
116832: PUSH
116833: LD_VAR 0 7
116837: ARRAY
116838: PPUSH
116839: CALL_OW 296
116843: PUSH
116844: LD_INT 5
116846: LESS
116847: AND
116848: IFFALSE 116865
// ComAutodestruct ( group [ i ] ) ;
116850: LD_VAR 0 4
116854: PUSH
116855: LD_VAR 0 7
116859: ARRAY
116860: PPUSH
116861: CALL 82386 0 1
// end ; if f_attack_depot then
116865: LD_VAR 0 25
116869: IFFALSE 116981
// begin k := 6 ;
116871: LD_ADDR_VAR 0 9
116875: PUSH
116876: LD_INT 6
116878: ST_TO_ADDR
// if tmp < k then
116879: LD_VAR 0 14
116883: PUSH
116884: LD_VAR 0 9
116888: LESS
116889: IFFALSE 116901
// k := tmp ;
116891: LD_ADDR_VAR 0 9
116895: PUSH
116896: LD_VAR 0 14
116900: ST_TO_ADDR
// for j = 1 to k do
116901: LD_ADDR_VAR 0 8
116905: PUSH
116906: DOUBLE
116907: LD_INT 1
116909: DEC
116910: ST_TO_ADDR
116911: LD_VAR 0 9
116915: PUSH
116916: FOR_TO
116917: IFFALSE 116979
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
116919: LD_VAR 0 8
116923: PPUSH
116924: CALL_OW 266
116928: PUSH
116929: LD_INT 0
116931: PUSH
116932: LD_INT 1
116934: PUSH
116935: EMPTY
116936: LIST
116937: LIST
116938: IN
116939: IFFALSE 116977
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
116941: LD_VAR 0 4
116945: PUSH
116946: LD_VAR 0 7
116950: ARRAY
116951: PPUSH
116952: LD_VAR 0 14
116956: PUSH
116957: LD_VAR 0 8
116961: ARRAY
116962: PPUSH
116963: CALL_OW 115
// attacking := true ;
116967: LD_ADDR_VAR 0 29
116971: PUSH
116972: LD_INT 1
116974: ST_TO_ADDR
// break ;
116975: GO 116979
// end ;
116977: GO 116916
116979: POP
116980: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
116981: LD_VAR 0 4
116985: PUSH
116986: LD_VAR 0 7
116990: ARRAY
116991: PPUSH
116992: CALL_OW 302
116996: PUSH
116997: LD_VAR 0 29
117001: NOT
117002: AND
117003: IFFALSE 117325
// begin if GetTag ( group [ i ] ) = 71 then
117005: LD_VAR 0 4
117009: PUSH
117010: LD_VAR 0 7
117014: ARRAY
117015: PPUSH
117016: CALL_OW 110
117020: PUSH
117021: LD_INT 71
117023: EQUAL
117024: IFFALSE 117065
// begin if HasTask ( group [ i ] ) then
117026: LD_VAR 0 4
117030: PUSH
117031: LD_VAR 0 7
117035: ARRAY
117036: PPUSH
117037: CALL_OW 314
117041: IFFALSE 117047
// continue else
117043: GO 113204
117045: GO 117065
// SetTag ( group [ i ] , 0 ) ;
117047: LD_VAR 0 4
117051: PUSH
117052: LD_VAR 0 7
117056: ARRAY
117057: PPUSH
117058: LD_INT 0
117060: PPUSH
117061: CALL_OW 109
// end ; k := 8 ;
117065: LD_ADDR_VAR 0 9
117069: PUSH
117070: LD_INT 8
117072: ST_TO_ADDR
// x := 0 ;
117073: LD_ADDR_VAR 0 10
117077: PUSH
117078: LD_INT 0
117080: ST_TO_ADDR
// if tmp < k then
117081: LD_VAR 0 14
117085: PUSH
117086: LD_VAR 0 9
117090: LESS
117091: IFFALSE 117103
// k := tmp ;
117093: LD_ADDR_VAR 0 9
117097: PUSH
117098: LD_VAR 0 14
117102: ST_TO_ADDR
// for j = 1 to k do
117103: LD_ADDR_VAR 0 8
117107: PUSH
117108: DOUBLE
117109: LD_INT 1
117111: DEC
117112: ST_TO_ADDR
117113: LD_VAR 0 9
117117: PUSH
117118: FOR_TO
117119: IFFALSE 117217
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
117121: LD_VAR 0 14
117125: PUSH
117126: LD_VAR 0 8
117130: ARRAY
117131: PPUSH
117132: CALL_OW 247
117136: PUSH
117137: LD_INT 1
117139: EQUAL
117140: PUSH
117141: LD_VAR 0 14
117145: PUSH
117146: LD_VAR 0 8
117150: ARRAY
117151: PPUSH
117152: CALL_OW 256
117156: PUSH
117157: LD_INT 250
117159: LESS
117160: PUSH
117161: LD_VAR 0 20
117165: AND
117166: PUSH
117167: LD_VAR 0 20
117171: NOT
117172: PUSH
117173: LD_VAR 0 14
117177: PUSH
117178: LD_VAR 0 8
117182: ARRAY
117183: PPUSH
117184: CALL_OW 256
117188: PUSH
117189: LD_INT 250
117191: GREATEREQUAL
117192: AND
117193: OR
117194: AND
117195: IFFALSE 117215
// begin x := tmp [ j ] ;
117197: LD_ADDR_VAR 0 10
117201: PUSH
117202: LD_VAR 0 14
117206: PUSH
117207: LD_VAR 0 8
117211: ARRAY
117212: ST_TO_ADDR
// break ;
117213: GO 117217
// end ;
117215: GO 117118
117217: POP
117218: POP
// if x then
117219: LD_VAR 0 10
117223: IFFALSE 117247
// ComAttackUnit ( group [ i ] , x ) else
117225: LD_VAR 0 4
117229: PUSH
117230: LD_VAR 0 7
117234: ARRAY
117235: PPUSH
117236: LD_VAR 0 10
117240: PPUSH
117241: CALL_OW 115
117245: GO 117271
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
117247: LD_VAR 0 4
117251: PUSH
117252: LD_VAR 0 7
117256: ARRAY
117257: PPUSH
117258: LD_VAR 0 14
117262: PUSH
117263: LD_INT 1
117265: ARRAY
117266: PPUSH
117267: CALL_OW 115
// if not HasTask ( group [ i ] ) then
117271: LD_VAR 0 4
117275: PUSH
117276: LD_VAR 0 7
117280: ARRAY
117281: PPUSH
117282: CALL_OW 314
117286: NOT
117287: IFFALSE 117325
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
117289: LD_VAR 0 4
117293: PUSH
117294: LD_VAR 0 7
117298: ARRAY
117299: PPUSH
117300: LD_VAR 0 14
117304: PPUSH
117305: LD_VAR 0 4
117309: PUSH
117310: LD_VAR 0 7
117314: ARRAY
117315: PPUSH
117316: CALL_OW 74
117320: PPUSH
117321: CALL_OW 115
// end ; end ; end ;
117325: GO 113204
117327: POP
117328: POP
// wait ( 0 0$2 ) ;
117329: LD_INT 70
117331: PPUSH
117332: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
117336: LD_VAR 0 4
117340: NOT
117341: PUSH
117342: LD_VAR 0 4
117346: PUSH
117347: EMPTY
117348: EQUAL
117349: OR
117350: PUSH
117351: LD_INT 81
117353: PUSH
117354: LD_VAR 0 35
117358: PUSH
117359: EMPTY
117360: LIST
117361: LIST
117362: PPUSH
117363: CALL_OW 69
117367: NOT
117368: OR
117369: IFFALSE 113189
// end ;
117371: LD_VAR 0 2
117375: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
117376: LD_INT 0
117378: PPUSH
117379: PPUSH
117380: PPUSH
117381: PPUSH
117382: PPUSH
117383: PPUSH
// if not base or not mc_bases [ base ] or not solds then
117384: LD_VAR 0 1
117388: NOT
117389: PUSH
117390: LD_EXP 50
117394: PUSH
117395: LD_VAR 0 1
117399: ARRAY
117400: NOT
117401: OR
117402: PUSH
117403: LD_VAR 0 2
117407: NOT
117408: OR
117409: IFFALSE 117413
// exit ;
117411: GO 117967
// side := mc_sides [ base ] ;
117413: LD_ADDR_VAR 0 6
117417: PUSH
117418: LD_EXP 76
117422: PUSH
117423: LD_VAR 0 1
117427: ARRAY
117428: ST_TO_ADDR
// if not side then
117429: LD_VAR 0 6
117433: NOT
117434: IFFALSE 117438
// exit ;
117436: GO 117967
// for i in solds do
117438: LD_ADDR_VAR 0 7
117442: PUSH
117443: LD_VAR 0 2
117447: PUSH
117448: FOR_IN
117449: IFFALSE 117510
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
117451: LD_VAR 0 7
117455: PPUSH
117456: CALL_OW 310
117460: PPUSH
117461: CALL_OW 266
117465: PUSH
117466: LD_INT 32
117468: PUSH
117469: LD_INT 31
117471: PUSH
117472: EMPTY
117473: LIST
117474: LIST
117475: IN
117476: IFFALSE 117496
// solds := solds diff i else
117478: LD_ADDR_VAR 0 2
117482: PUSH
117483: LD_VAR 0 2
117487: PUSH
117488: LD_VAR 0 7
117492: DIFF
117493: ST_TO_ADDR
117494: GO 117508
// SetTag ( i , 18 ) ;
117496: LD_VAR 0 7
117500: PPUSH
117501: LD_INT 18
117503: PPUSH
117504: CALL_OW 109
117508: GO 117448
117510: POP
117511: POP
// if not solds then
117512: LD_VAR 0 2
117516: NOT
117517: IFFALSE 117521
// exit ;
117519: GO 117967
// repeat wait ( 0 0$2 ) ;
117521: LD_INT 70
117523: PPUSH
117524: CALL_OW 67
// enemy := mc_scan [ base ] ;
117528: LD_ADDR_VAR 0 4
117532: PUSH
117533: LD_EXP 73
117537: PUSH
117538: LD_VAR 0 1
117542: ARRAY
117543: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
117544: LD_EXP 50
117548: PUSH
117549: LD_VAR 0 1
117553: ARRAY
117554: NOT
117555: PUSH
117556: LD_EXP 50
117560: PUSH
117561: LD_VAR 0 1
117565: ARRAY
117566: PUSH
117567: EMPTY
117568: EQUAL
117569: OR
117570: IFFALSE 117607
// begin for i in solds do
117572: LD_ADDR_VAR 0 7
117576: PUSH
117577: LD_VAR 0 2
117581: PUSH
117582: FOR_IN
117583: IFFALSE 117596
// ComStop ( i ) ;
117585: LD_VAR 0 7
117589: PPUSH
117590: CALL_OW 141
117594: GO 117582
117596: POP
117597: POP
// solds := [ ] ;
117598: LD_ADDR_VAR 0 2
117602: PUSH
117603: EMPTY
117604: ST_TO_ADDR
// exit ;
117605: GO 117967
// end ; for i in solds do
117607: LD_ADDR_VAR 0 7
117611: PUSH
117612: LD_VAR 0 2
117616: PUSH
117617: FOR_IN
117618: IFFALSE 117939
// begin if IsInUnit ( i ) then
117620: LD_VAR 0 7
117624: PPUSH
117625: CALL_OW 310
117629: IFFALSE 117640
// ComExitBuilding ( i ) ;
117631: LD_VAR 0 7
117635: PPUSH
117636: CALL_OW 122
// if GetLives ( i ) > 500 then
117640: LD_VAR 0 7
117644: PPUSH
117645: CALL_OW 256
117649: PUSH
117650: LD_INT 500
117652: GREATER
117653: IFFALSE 117706
// begin e := NearestUnitToUnit ( enemy , i ) ;
117655: LD_ADDR_VAR 0 5
117659: PUSH
117660: LD_VAR 0 4
117664: PPUSH
117665: LD_VAR 0 7
117669: PPUSH
117670: CALL_OW 74
117674: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
117675: LD_VAR 0 7
117679: PPUSH
117680: LD_VAR 0 5
117684: PPUSH
117685: CALL_OW 250
117689: PPUSH
117690: LD_VAR 0 5
117694: PPUSH
117695: CALL_OW 251
117699: PPUSH
117700: CALL_OW 114
// end else
117704: GO 117937
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
117706: LD_VAR 0 7
117710: PPUSH
117711: LD_EXP 50
117715: PUSH
117716: LD_VAR 0 1
117720: ARRAY
117721: PPUSH
117722: LD_INT 2
117724: PUSH
117725: LD_INT 30
117727: PUSH
117728: LD_INT 0
117730: PUSH
117731: EMPTY
117732: LIST
117733: LIST
117734: PUSH
117735: LD_INT 30
117737: PUSH
117738: LD_INT 1
117740: PUSH
117741: EMPTY
117742: LIST
117743: LIST
117744: PUSH
117745: LD_INT 30
117747: PUSH
117748: LD_INT 6
117750: PUSH
117751: EMPTY
117752: LIST
117753: LIST
117754: PUSH
117755: EMPTY
117756: LIST
117757: LIST
117758: LIST
117759: LIST
117760: PPUSH
117761: CALL_OW 72
117765: PPUSH
117766: LD_VAR 0 7
117770: PPUSH
117771: CALL_OW 74
117775: PPUSH
117776: CALL_OW 296
117780: PUSH
117781: LD_INT 10
117783: GREATER
117784: IFFALSE 117937
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
117786: LD_ADDR_VAR 0 8
117790: PUSH
117791: LD_EXP 50
117795: PUSH
117796: LD_VAR 0 1
117800: ARRAY
117801: PPUSH
117802: LD_INT 2
117804: PUSH
117805: LD_INT 30
117807: PUSH
117808: LD_INT 0
117810: PUSH
117811: EMPTY
117812: LIST
117813: LIST
117814: PUSH
117815: LD_INT 30
117817: PUSH
117818: LD_INT 1
117820: PUSH
117821: EMPTY
117822: LIST
117823: LIST
117824: PUSH
117825: LD_INT 30
117827: PUSH
117828: LD_INT 6
117830: PUSH
117831: EMPTY
117832: LIST
117833: LIST
117834: PUSH
117835: EMPTY
117836: LIST
117837: LIST
117838: LIST
117839: LIST
117840: PPUSH
117841: CALL_OW 72
117845: PPUSH
117846: LD_VAR 0 7
117850: PPUSH
117851: CALL_OW 74
117855: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
117856: LD_VAR 0 7
117860: PPUSH
117861: LD_VAR 0 8
117865: PPUSH
117866: CALL_OW 250
117870: PPUSH
117871: LD_INT 3
117873: PPUSH
117874: LD_INT 5
117876: PPUSH
117877: CALL_OW 272
117881: PPUSH
117882: LD_VAR 0 8
117886: PPUSH
117887: CALL_OW 251
117891: PPUSH
117892: LD_INT 3
117894: PPUSH
117895: LD_INT 5
117897: PPUSH
117898: CALL_OW 273
117902: PPUSH
117903: CALL_OW 111
// SetTag ( i , 0 ) ;
117907: LD_VAR 0 7
117911: PPUSH
117912: LD_INT 0
117914: PPUSH
117915: CALL_OW 109
// solds := solds diff i ;
117919: LD_ADDR_VAR 0 2
117923: PUSH
117924: LD_VAR 0 2
117928: PUSH
117929: LD_VAR 0 7
117933: DIFF
117934: ST_TO_ADDR
// continue ;
117935: GO 117617
// end ; end ;
117937: GO 117617
117939: POP
117940: POP
// until not solds or not enemy ;
117941: LD_VAR 0 2
117945: NOT
117946: PUSH
117947: LD_VAR 0 4
117951: NOT
117952: OR
117953: IFFALSE 117521
// MC_Reset ( base , 18 ) ;
117955: LD_VAR 0 1
117959: PPUSH
117960: LD_INT 18
117962: PPUSH
117963: CALL 22644 0 2
// end ;
117967: LD_VAR 0 3
117971: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
117972: LD_INT 0
117974: PPUSH
117975: PPUSH
117976: PPUSH
117977: PPUSH
117978: PPUSH
117979: PPUSH
117980: PPUSH
117981: PPUSH
117982: PPUSH
117983: PPUSH
117984: PPUSH
117985: PPUSH
117986: PPUSH
117987: PPUSH
117988: PPUSH
117989: PPUSH
117990: PPUSH
117991: PPUSH
117992: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
117993: LD_ADDR_VAR 0 12
117997: PUSH
117998: LD_EXP 50
118002: PUSH
118003: LD_VAR 0 1
118007: ARRAY
118008: PPUSH
118009: LD_INT 25
118011: PUSH
118012: LD_INT 3
118014: PUSH
118015: EMPTY
118016: LIST
118017: LIST
118018: PPUSH
118019: CALL_OW 72
118023: ST_TO_ADDR
// if mc_remote_driver [ base ] then
118024: LD_EXP 90
118028: PUSH
118029: LD_VAR 0 1
118033: ARRAY
118034: IFFALSE 118058
// mechs := mechs diff mc_remote_driver [ base ] ;
118036: LD_ADDR_VAR 0 12
118040: PUSH
118041: LD_VAR 0 12
118045: PUSH
118046: LD_EXP 90
118050: PUSH
118051: LD_VAR 0 1
118055: ARRAY
118056: DIFF
118057: ST_TO_ADDR
// for i in mechs do
118058: LD_ADDR_VAR 0 4
118062: PUSH
118063: LD_VAR 0 12
118067: PUSH
118068: FOR_IN
118069: IFFALSE 118104
// if GetTag ( i ) > 0 then
118071: LD_VAR 0 4
118075: PPUSH
118076: CALL_OW 110
118080: PUSH
118081: LD_INT 0
118083: GREATER
118084: IFFALSE 118102
// mechs := mechs diff i ;
118086: LD_ADDR_VAR 0 12
118090: PUSH
118091: LD_VAR 0 12
118095: PUSH
118096: LD_VAR 0 4
118100: DIFF
118101: ST_TO_ADDR
118102: GO 118068
118104: POP
118105: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
118106: LD_ADDR_VAR 0 8
118110: PUSH
118111: LD_EXP 50
118115: PUSH
118116: LD_VAR 0 1
118120: ARRAY
118121: PPUSH
118122: LD_INT 2
118124: PUSH
118125: LD_INT 25
118127: PUSH
118128: LD_INT 1
118130: PUSH
118131: EMPTY
118132: LIST
118133: LIST
118134: PUSH
118135: LD_INT 25
118137: PUSH
118138: LD_INT 5
118140: PUSH
118141: EMPTY
118142: LIST
118143: LIST
118144: PUSH
118145: LD_INT 25
118147: PUSH
118148: LD_INT 8
118150: PUSH
118151: EMPTY
118152: LIST
118153: LIST
118154: PUSH
118155: LD_INT 25
118157: PUSH
118158: LD_INT 9
118160: PUSH
118161: EMPTY
118162: LIST
118163: LIST
118164: PUSH
118165: EMPTY
118166: LIST
118167: LIST
118168: LIST
118169: LIST
118170: LIST
118171: PPUSH
118172: CALL_OW 72
118176: ST_TO_ADDR
// if not defenders and not solds then
118177: LD_VAR 0 2
118181: NOT
118182: PUSH
118183: LD_VAR 0 8
118187: NOT
118188: AND
118189: IFFALSE 118193
// exit ;
118191: GO 119963
// depot_under_attack := false ;
118193: LD_ADDR_VAR 0 16
118197: PUSH
118198: LD_INT 0
118200: ST_TO_ADDR
// sold_defenders := [ ] ;
118201: LD_ADDR_VAR 0 17
118205: PUSH
118206: EMPTY
118207: ST_TO_ADDR
// if mechs then
118208: LD_VAR 0 12
118212: IFFALSE 118365
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
118214: LD_ADDR_VAR 0 4
118218: PUSH
118219: LD_VAR 0 2
118223: PPUSH
118224: LD_INT 21
118226: PUSH
118227: LD_INT 2
118229: PUSH
118230: EMPTY
118231: LIST
118232: LIST
118233: PPUSH
118234: CALL_OW 72
118238: PUSH
118239: FOR_IN
118240: IFFALSE 118363
// begin if GetTag ( i ) <> 20 then
118242: LD_VAR 0 4
118246: PPUSH
118247: CALL_OW 110
118251: PUSH
118252: LD_INT 20
118254: NONEQUAL
118255: IFFALSE 118269
// SetTag ( i , 20 ) ;
118257: LD_VAR 0 4
118261: PPUSH
118262: LD_INT 20
118264: PPUSH
118265: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
118269: LD_VAR 0 4
118273: PPUSH
118274: CALL_OW 263
118278: PUSH
118279: LD_INT 1
118281: EQUAL
118282: PUSH
118283: LD_VAR 0 4
118287: PPUSH
118288: CALL_OW 311
118292: NOT
118293: AND
118294: IFFALSE 118361
// begin un := mechs [ 1 ] ;
118296: LD_ADDR_VAR 0 10
118300: PUSH
118301: LD_VAR 0 12
118305: PUSH
118306: LD_INT 1
118308: ARRAY
118309: ST_TO_ADDR
// ComExit ( un ) ;
118310: LD_VAR 0 10
118314: PPUSH
118315: CALL 87272 0 1
// AddComEnterUnit ( un , i ) ;
118319: LD_VAR 0 10
118323: PPUSH
118324: LD_VAR 0 4
118328: PPUSH
118329: CALL_OW 180
// SetTag ( un , 19 ) ;
118333: LD_VAR 0 10
118337: PPUSH
118338: LD_INT 19
118340: PPUSH
118341: CALL_OW 109
// mechs := mechs diff un ;
118345: LD_ADDR_VAR 0 12
118349: PUSH
118350: LD_VAR 0 12
118354: PUSH
118355: LD_VAR 0 10
118359: DIFF
118360: ST_TO_ADDR
// end ; end ;
118361: GO 118239
118363: POP
118364: POP
// if solds then
118365: LD_VAR 0 8
118369: IFFALSE 118428
// for i in solds do
118371: LD_ADDR_VAR 0 4
118375: PUSH
118376: LD_VAR 0 8
118380: PUSH
118381: FOR_IN
118382: IFFALSE 118426
// if not GetTag ( i ) then
118384: LD_VAR 0 4
118388: PPUSH
118389: CALL_OW 110
118393: NOT
118394: IFFALSE 118424
// begin defenders := defenders union i ;
118396: LD_ADDR_VAR 0 2
118400: PUSH
118401: LD_VAR 0 2
118405: PUSH
118406: LD_VAR 0 4
118410: UNION
118411: ST_TO_ADDR
// SetTag ( i , 18 ) ;
118412: LD_VAR 0 4
118416: PPUSH
118417: LD_INT 18
118419: PPUSH
118420: CALL_OW 109
// end ;
118424: GO 118381
118426: POP
118427: POP
// repeat wait ( 0 0$2 ) ;
118428: LD_INT 70
118430: PPUSH
118431: CALL_OW 67
// enemy := mc_scan [ base ] ;
118435: LD_ADDR_VAR 0 21
118439: PUSH
118440: LD_EXP 73
118444: PUSH
118445: LD_VAR 0 1
118449: ARRAY
118450: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
118451: LD_EXP 50
118455: PUSH
118456: LD_VAR 0 1
118460: ARRAY
118461: NOT
118462: PUSH
118463: LD_EXP 50
118467: PUSH
118468: LD_VAR 0 1
118472: ARRAY
118473: PUSH
118474: EMPTY
118475: EQUAL
118476: OR
118477: IFFALSE 118514
// begin for i in defenders do
118479: LD_ADDR_VAR 0 4
118483: PUSH
118484: LD_VAR 0 2
118488: PUSH
118489: FOR_IN
118490: IFFALSE 118503
// ComStop ( i ) ;
118492: LD_VAR 0 4
118496: PPUSH
118497: CALL_OW 141
118501: GO 118489
118503: POP
118504: POP
// defenders := [ ] ;
118505: LD_ADDR_VAR 0 2
118509: PUSH
118510: EMPTY
118511: ST_TO_ADDR
// exit ;
118512: GO 119963
// end ; for i in defenders do
118514: LD_ADDR_VAR 0 4
118518: PUSH
118519: LD_VAR 0 2
118523: PUSH
118524: FOR_IN
118525: IFFALSE 119423
// begin e := NearestUnitToUnit ( enemy , i ) ;
118527: LD_ADDR_VAR 0 13
118531: PUSH
118532: LD_VAR 0 21
118536: PPUSH
118537: LD_VAR 0 4
118541: PPUSH
118542: CALL_OW 74
118546: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
118547: LD_ADDR_VAR 0 7
118551: PUSH
118552: LD_EXP 50
118556: PUSH
118557: LD_VAR 0 1
118561: ARRAY
118562: PPUSH
118563: LD_INT 2
118565: PUSH
118566: LD_INT 30
118568: PUSH
118569: LD_INT 0
118571: PUSH
118572: EMPTY
118573: LIST
118574: LIST
118575: PUSH
118576: LD_INT 30
118578: PUSH
118579: LD_INT 1
118581: PUSH
118582: EMPTY
118583: LIST
118584: LIST
118585: PUSH
118586: EMPTY
118587: LIST
118588: LIST
118589: LIST
118590: PPUSH
118591: CALL_OW 72
118595: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
118596: LD_ADDR_VAR 0 16
118600: PUSH
118601: LD_VAR 0 7
118605: NOT
118606: PUSH
118607: LD_VAR 0 7
118611: PPUSH
118612: LD_INT 3
118614: PUSH
118615: LD_INT 24
118617: PUSH
118618: LD_INT 600
118620: PUSH
118621: EMPTY
118622: LIST
118623: LIST
118624: PUSH
118625: EMPTY
118626: LIST
118627: LIST
118628: PPUSH
118629: CALL_OW 72
118633: OR
118634: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
118635: LD_VAR 0 4
118639: PPUSH
118640: CALL_OW 247
118644: PUSH
118645: LD_INT 2
118647: DOUBLE
118648: EQUAL
118649: IFTRUE 118653
118651: GO 119049
118653: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
118654: LD_VAR 0 4
118658: PPUSH
118659: CALL_OW 256
118663: PUSH
118664: LD_INT 1000
118666: EQUAL
118667: PUSH
118668: LD_VAR 0 4
118672: PPUSH
118673: LD_VAR 0 13
118677: PPUSH
118678: CALL_OW 296
118682: PUSH
118683: LD_INT 40
118685: LESS
118686: PUSH
118687: LD_VAR 0 13
118691: PPUSH
118692: LD_EXP 75
118696: PUSH
118697: LD_VAR 0 1
118701: ARRAY
118702: PPUSH
118703: CALL_OW 308
118707: OR
118708: AND
118709: IFFALSE 118831
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
118711: LD_VAR 0 4
118715: PPUSH
118716: CALL_OW 262
118720: PUSH
118721: LD_INT 1
118723: EQUAL
118724: PUSH
118725: LD_VAR 0 4
118729: PPUSH
118730: CALL_OW 261
118734: PUSH
118735: LD_INT 30
118737: LESS
118738: AND
118739: PUSH
118740: LD_VAR 0 7
118744: AND
118745: IFFALSE 118815
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
118747: LD_VAR 0 4
118751: PPUSH
118752: LD_VAR 0 7
118756: PPUSH
118757: LD_VAR 0 4
118761: PPUSH
118762: CALL_OW 74
118766: PPUSH
118767: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
118771: LD_VAR 0 4
118775: PPUSH
118776: LD_VAR 0 7
118780: PPUSH
118781: LD_VAR 0 4
118785: PPUSH
118786: CALL_OW 74
118790: PPUSH
118791: CALL_OW 296
118795: PUSH
118796: LD_INT 6
118798: LESS
118799: IFFALSE 118813
// SetFuel ( i , 100 ) ;
118801: LD_VAR 0 4
118805: PPUSH
118806: LD_INT 100
118808: PPUSH
118809: CALL_OW 240
// end else
118813: GO 118829
// ComAttackUnit ( i , e ) ;
118815: LD_VAR 0 4
118819: PPUSH
118820: LD_VAR 0 13
118824: PPUSH
118825: CALL_OW 115
// end else
118829: GO 118932
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
118831: LD_VAR 0 13
118835: PPUSH
118836: LD_EXP 75
118840: PUSH
118841: LD_VAR 0 1
118845: ARRAY
118846: PPUSH
118847: CALL_OW 308
118851: NOT
118852: PUSH
118853: LD_VAR 0 4
118857: PPUSH
118858: LD_VAR 0 13
118862: PPUSH
118863: CALL_OW 296
118867: PUSH
118868: LD_INT 40
118870: GREATEREQUAL
118871: AND
118872: PUSH
118873: LD_VAR 0 4
118877: PPUSH
118878: CALL_OW 256
118882: PUSH
118883: LD_INT 650
118885: LESSEQUAL
118886: OR
118887: PUSH
118888: LD_VAR 0 4
118892: PPUSH
118893: LD_EXP 74
118897: PUSH
118898: LD_VAR 0 1
118902: ARRAY
118903: PPUSH
118904: CALL_OW 308
118908: NOT
118909: AND
118910: IFFALSE 118932
// ComMoveToArea ( i , mc_parking [ base ] ) ;
118912: LD_VAR 0 4
118916: PPUSH
118917: LD_EXP 74
118921: PUSH
118922: LD_VAR 0 1
118926: ARRAY
118927: PPUSH
118928: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
118932: LD_VAR 0 4
118936: PPUSH
118937: CALL_OW 256
118941: PUSH
118942: LD_INT 1000
118944: LESS
118945: PUSH
118946: LD_VAR 0 4
118950: PPUSH
118951: CALL_OW 263
118955: PUSH
118956: LD_INT 1
118958: EQUAL
118959: AND
118960: PUSH
118961: LD_VAR 0 4
118965: PPUSH
118966: CALL_OW 311
118970: AND
118971: PUSH
118972: LD_VAR 0 4
118976: PPUSH
118977: LD_EXP 74
118981: PUSH
118982: LD_VAR 0 1
118986: ARRAY
118987: PPUSH
118988: CALL_OW 308
118992: AND
118993: IFFALSE 119047
// begin mech := IsDrivenBy ( i ) ;
118995: LD_ADDR_VAR 0 9
118999: PUSH
119000: LD_VAR 0 4
119004: PPUSH
119005: CALL_OW 311
119009: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
119010: LD_VAR 0 9
119014: PPUSH
119015: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
119019: LD_VAR 0 9
119023: PPUSH
119024: LD_VAR 0 4
119028: PPUSH
119029: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
119033: LD_VAR 0 9
119037: PPUSH
119038: LD_VAR 0 4
119042: PPUSH
119043: CALL_OW 180
// end ; end ; unit_human :
119047: GO 119394
119049: LD_INT 1
119051: DOUBLE
119052: EQUAL
119053: IFTRUE 119057
119055: GO 119393
119057: POP
// begin b := IsInUnit ( i ) ;
119058: LD_ADDR_VAR 0 18
119062: PUSH
119063: LD_VAR 0 4
119067: PPUSH
119068: CALL_OW 310
119072: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
119073: LD_ADDR_VAR 0 19
119077: PUSH
119078: LD_VAR 0 18
119082: NOT
119083: PUSH
119084: LD_VAR 0 18
119088: PPUSH
119089: CALL_OW 266
119093: PUSH
119094: LD_INT 32
119096: PUSH
119097: LD_INT 31
119099: PUSH
119100: EMPTY
119101: LIST
119102: LIST
119103: IN
119104: OR
119105: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
119106: LD_VAR 0 18
119110: PPUSH
119111: CALL_OW 266
119115: PUSH
119116: LD_INT 5
119118: EQUAL
119119: PUSH
119120: LD_VAR 0 4
119124: PPUSH
119125: CALL_OW 257
119129: PUSH
119130: LD_INT 1
119132: PUSH
119133: LD_INT 2
119135: PUSH
119136: LD_INT 3
119138: PUSH
119139: LD_INT 4
119141: PUSH
119142: EMPTY
119143: LIST
119144: LIST
119145: LIST
119146: LIST
119147: IN
119148: AND
119149: IFFALSE 119186
// begin class := AllowSpecClass ( i ) ;
119151: LD_ADDR_VAR 0 20
119155: PUSH
119156: LD_VAR 0 4
119160: PPUSH
119161: CALL 50969 0 1
119165: ST_TO_ADDR
// if class then
119166: LD_VAR 0 20
119170: IFFALSE 119186
// ComChangeProfession ( i , class ) ;
119172: LD_VAR 0 4
119176: PPUSH
119177: LD_VAR 0 20
119181: PPUSH
119182: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
119186: LD_VAR 0 16
119190: PUSH
119191: LD_VAR 0 2
119195: PPUSH
119196: LD_INT 21
119198: PUSH
119199: LD_INT 2
119201: PUSH
119202: EMPTY
119203: LIST
119204: LIST
119205: PPUSH
119206: CALL_OW 72
119210: PUSH
119211: LD_INT 1
119213: LESSEQUAL
119214: OR
119215: PUSH
119216: LD_VAR 0 19
119220: AND
119221: PUSH
119222: LD_VAR 0 4
119226: PUSH
119227: LD_VAR 0 17
119231: IN
119232: NOT
119233: AND
119234: IFFALSE 119327
// begin if b then
119236: LD_VAR 0 18
119240: IFFALSE 119289
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
119242: LD_VAR 0 18
119246: PPUSH
119247: LD_VAR 0 21
119251: PPUSH
119252: LD_VAR 0 18
119256: PPUSH
119257: CALL_OW 74
119261: PPUSH
119262: CALL_OW 296
119266: PUSH
119267: LD_INT 10
119269: LESS
119270: PUSH
119271: LD_VAR 0 18
119275: PPUSH
119276: CALL_OW 461
119280: PUSH
119281: LD_INT 7
119283: NONEQUAL
119284: AND
119285: IFFALSE 119289
// continue ;
119287: GO 118524
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
119289: LD_ADDR_VAR 0 17
119293: PUSH
119294: LD_VAR 0 17
119298: PPUSH
119299: LD_VAR 0 17
119303: PUSH
119304: LD_INT 1
119306: PLUS
119307: PPUSH
119308: LD_VAR 0 4
119312: PPUSH
119313: CALL_OW 1
119317: ST_TO_ADDR
// ComExitBuilding ( i ) ;
119318: LD_VAR 0 4
119322: PPUSH
119323: CALL_OW 122
// end ; if sold_defenders then
119327: LD_VAR 0 17
119331: IFFALSE 119391
// if i in sold_defenders then
119333: LD_VAR 0 4
119337: PUSH
119338: LD_VAR 0 17
119342: IN
119343: IFFALSE 119391
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
119345: LD_VAR 0 4
119349: PPUSH
119350: CALL_OW 314
119354: NOT
119355: PUSH
119356: LD_VAR 0 4
119360: PPUSH
119361: LD_VAR 0 13
119365: PPUSH
119366: CALL_OW 296
119370: PUSH
119371: LD_INT 30
119373: LESS
119374: AND
119375: IFFALSE 119391
// ComAttackUnit ( i , e ) ;
119377: LD_VAR 0 4
119381: PPUSH
119382: LD_VAR 0 13
119386: PPUSH
119387: CALL_OW 115
// end ; end ; end ;
119391: GO 119394
119393: POP
// if IsDead ( i ) then
119394: LD_VAR 0 4
119398: PPUSH
119399: CALL_OW 301
119403: IFFALSE 119421
// defenders := defenders diff i ;
119405: LD_ADDR_VAR 0 2
119409: PUSH
119410: LD_VAR 0 2
119414: PUSH
119415: LD_VAR 0 4
119419: DIFF
119420: ST_TO_ADDR
// end ;
119421: GO 118524
119423: POP
119424: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
119425: LD_VAR 0 21
119429: NOT
119430: PUSH
119431: LD_VAR 0 2
119435: NOT
119436: OR
119437: PUSH
119438: LD_EXP 50
119442: PUSH
119443: LD_VAR 0 1
119447: ARRAY
119448: NOT
119449: OR
119450: IFFALSE 118428
// MC_Reset ( base , 18 ) ;
119452: LD_VAR 0 1
119456: PPUSH
119457: LD_INT 18
119459: PPUSH
119460: CALL 22644 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
119464: LD_ADDR_VAR 0 2
119468: PUSH
119469: LD_VAR 0 2
119473: PUSH
119474: LD_VAR 0 2
119478: PPUSH
119479: LD_INT 2
119481: PUSH
119482: LD_INT 25
119484: PUSH
119485: LD_INT 1
119487: PUSH
119488: EMPTY
119489: LIST
119490: LIST
119491: PUSH
119492: LD_INT 25
119494: PUSH
119495: LD_INT 5
119497: PUSH
119498: EMPTY
119499: LIST
119500: LIST
119501: PUSH
119502: LD_INT 25
119504: PUSH
119505: LD_INT 8
119507: PUSH
119508: EMPTY
119509: LIST
119510: LIST
119511: PUSH
119512: LD_INT 25
119514: PUSH
119515: LD_INT 9
119517: PUSH
119518: EMPTY
119519: LIST
119520: LIST
119521: PUSH
119522: EMPTY
119523: LIST
119524: LIST
119525: LIST
119526: LIST
119527: LIST
119528: PPUSH
119529: CALL_OW 72
119533: DIFF
119534: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
119535: LD_VAR 0 21
119539: NOT
119540: PUSH
119541: LD_VAR 0 2
119545: PPUSH
119546: LD_INT 21
119548: PUSH
119549: LD_INT 2
119551: PUSH
119552: EMPTY
119553: LIST
119554: LIST
119555: PPUSH
119556: CALL_OW 72
119560: AND
119561: IFFALSE 119899
// begin tmp := FilterByTag ( defenders , 19 ) ;
119563: LD_ADDR_VAR 0 11
119567: PUSH
119568: LD_VAR 0 2
119572: PPUSH
119573: LD_INT 19
119575: PPUSH
119576: CALL 84443 0 2
119580: ST_TO_ADDR
// if tmp then
119581: LD_VAR 0 11
119585: IFFALSE 119655
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
119587: LD_ADDR_VAR 0 11
119591: PUSH
119592: LD_VAR 0 11
119596: PPUSH
119597: LD_INT 25
119599: PUSH
119600: LD_INT 3
119602: PUSH
119603: EMPTY
119604: LIST
119605: LIST
119606: PPUSH
119607: CALL_OW 72
119611: ST_TO_ADDR
// if tmp then
119612: LD_VAR 0 11
119616: IFFALSE 119655
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
119618: LD_ADDR_EXP 62
119622: PUSH
119623: LD_EXP 62
119627: PPUSH
119628: LD_VAR 0 1
119632: PPUSH
119633: LD_EXP 62
119637: PUSH
119638: LD_VAR 0 1
119642: ARRAY
119643: PUSH
119644: LD_VAR 0 11
119648: UNION
119649: PPUSH
119650: CALL_OW 1
119654: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
119655: LD_VAR 0 1
119659: PPUSH
119660: LD_INT 19
119662: PPUSH
119663: CALL 22644 0 2
// repeat wait ( 0 0$1 ) ;
119667: LD_INT 35
119669: PPUSH
119670: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
119674: LD_EXP 50
119678: PUSH
119679: LD_VAR 0 1
119683: ARRAY
119684: NOT
119685: PUSH
119686: LD_EXP 50
119690: PUSH
119691: LD_VAR 0 1
119695: ARRAY
119696: PUSH
119697: EMPTY
119698: EQUAL
119699: OR
119700: IFFALSE 119737
// begin for i in defenders do
119702: LD_ADDR_VAR 0 4
119706: PUSH
119707: LD_VAR 0 2
119711: PUSH
119712: FOR_IN
119713: IFFALSE 119726
// ComStop ( i ) ;
119715: LD_VAR 0 4
119719: PPUSH
119720: CALL_OW 141
119724: GO 119712
119726: POP
119727: POP
// defenders := [ ] ;
119728: LD_ADDR_VAR 0 2
119732: PUSH
119733: EMPTY
119734: ST_TO_ADDR
// exit ;
119735: GO 119963
// end ; for i in defenders do
119737: LD_ADDR_VAR 0 4
119741: PUSH
119742: LD_VAR 0 2
119746: PUSH
119747: FOR_IN
119748: IFFALSE 119837
// begin if not IsInArea ( i , mc_parking [ base ] ) then
119750: LD_VAR 0 4
119754: PPUSH
119755: LD_EXP 74
119759: PUSH
119760: LD_VAR 0 1
119764: ARRAY
119765: PPUSH
119766: CALL_OW 308
119770: NOT
119771: IFFALSE 119795
// ComMoveToArea ( i , mc_parking [ base ] ) else
119773: LD_VAR 0 4
119777: PPUSH
119778: LD_EXP 74
119782: PUSH
119783: LD_VAR 0 1
119787: ARRAY
119788: PPUSH
119789: CALL_OW 113
119793: GO 119835
// if GetControl ( i ) = control_manual then
119795: LD_VAR 0 4
119799: PPUSH
119800: CALL_OW 263
119804: PUSH
119805: LD_INT 1
119807: EQUAL
119808: IFFALSE 119835
// if IsDrivenBy ( i ) then
119810: LD_VAR 0 4
119814: PPUSH
119815: CALL_OW 311
119819: IFFALSE 119835
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
119821: LD_VAR 0 4
119825: PPUSH
119826: CALL_OW 311
119830: PPUSH
119831: CALL_OW 121
// end ;
119835: GO 119747
119837: POP
119838: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
119839: LD_VAR 0 2
119843: PPUSH
119844: LD_INT 95
119846: PUSH
119847: LD_EXP 74
119851: PUSH
119852: LD_VAR 0 1
119856: ARRAY
119857: PUSH
119858: EMPTY
119859: LIST
119860: LIST
119861: PPUSH
119862: CALL_OW 72
119866: PUSH
119867: LD_VAR 0 2
119871: EQUAL
119872: PUSH
119873: LD_EXP 73
119877: PUSH
119878: LD_VAR 0 1
119882: ARRAY
119883: OR
119884: PUSH
119885: LD_EXP 50
119889: PUSH
119890: LD_VAR 0 1
119894: ARRAY
119895: NOT
119896: OR
119897: IFFALSE 119667
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
119899: LD_ADDR_EXP 72
119903: PUSH
119904: LD_EXP 72
119908: PPUSH
119909: LD_VAR 0 1
119913: PPUSH
119914: LD_VAR 0 2
119918: PPUSH
119919: LD_INT 21
119921: PUSH
119922: LD_INT 2
119924: PUSH
119925: EMPTY
119926: LIST
119927: LIST
119928: PPUSH
119929: CALL_OW 72
119933: PPUSH
119934: CALL_OW 1
119938: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
119939: LD_VAR 0 1
119943: PPUSH
119944: LD_INT 19
119946: PPUSH
119947: CALL 22644 0 2
// MC_Reset ( base , 20 ) ;
119951: LD_VAR 0 1
119955: PPUSH
119956: LD_INT 20
119958: PPUSH
119959: CALL 22644 0 2
// end ; end_of_file
119963: LD_VAR 0 3
119967: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
119968: LD_VAR 0 1
119972: PUSH
119973: LD_INT 200
119975: DOUBLE
119976: GREATEREQUAL
119977: IFFALSE 119985
119979: LD_INT 299
119981: DOUBLE
119982: LESSEQUAL
119983: IFTRUE 119987
119985: GO 120019
119987: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
119988: LD_VAR 0 1
119992: PPUSH
119993: LD_VAR 0 2
119997: PPUSH
119998: LD_VAR 0 3
120002: PPUSH
120003: LD_VAR 0 4
120007: PPUSH
120008: LD_VAR 0 5
120012: PPUSH
120013: CALL 108149 0 5
120017: GO 120096
120019: LD_INT 300
120021: DOUBLE
120022: GREATEREQUAL
120023: IFFALSE 120031
120025: LD_INT 399
120027: DOUBLE
120028: LESSEQUAL
120029: IFTRUE 120033
120031: GO 120095
120033: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
120034: LD_VAR 0 1
120038: PPUSH
120039: LD_VAR 0 2
120043: PPUSH
120044: LD_VAR 0 3
120048: PPUSH
120049: LD_VAR 0 4
120053: PPUSH
120054: LD_VAR 0 5
120058: PPUSH
120059: LD_VAR 0 6
120063: PPUSH
120064: LD_VAR 0 7
120068: PPUSH
120069: LD_VAR 0 8
120073: PPUSH
120074: LD_VAR 0 9
120078: PPUSH
120079: LD_VAR 0 10
120083: PPUSH
120084: LD_VAR 0 11
120088: PPUSH
120089: CALL 104474 0 11
120093: GO 120096
120095: POP
// end ;
120096: PPOPN 11
120098: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
120099: LD_VAR 0 1
120103: PPUSH
120104: LD_VAR 0 2
120108: PPUSH
120109: LD_VAR 0 3
120113: PPUSH
120114: LD_VAR 0 4
120118: PPUSH
120119: LD_VAR 0 5
120123: PPUSH
120124: CALL 107885 0 5
// end ; end_of_file
120128: PPOPN 5
120130: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
120131: LD_VAR 0 1
120135: PPUSH
120136: LD_VAR 0 2
120140: PPUSH
120141: LD_VAR 0 3
120145: PPUSH
120146: LD_VAR 0 4
120150: PPUSH
120151: LD_VAR 0 5
120155: PPUSH
120156: LD_VAR 0 6
120160: PPUSH
120161: CALL 92126 0 6
// end ;
120165: PPOPN 6
120167: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
120168: LD_INT 0
120170: PPUSH
// begin if not units then
120171: LD_VAR 0 1
120175: NOT
120176: IFFALSE 120180
// exit ;
120178: GO 120180
// end ;
120180: PPOPN 7
120182: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
120183: CALL 92013 0 0
// end ;
120187: PPOPN 1
120189: END
