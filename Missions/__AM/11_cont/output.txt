// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Randomize ;
  11: CALL_OW 10
// InitVariables ;
  15: CALL 94 0 0
// InitMacro ;
  19: CALL 17984 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// ChangeSideFog ( 8 , 1 ) ;
  36: LD_INT 8
  38: PPUSH
  39: LD_INT 1
  41: PPUSH
  42: CALL_OW 343
// PrepareNature ( 4 , 3 , 6 , 3 , 2 , 0 , 7 , natureArea , waterArea ) ;
  46: LD_INT 4
  48: PPUSH
  49: LD_INT 3
  51: PPUSH
  52: LD_INT 6
  54: PPUSH
  55: LD_INT 3
  57: PPUSH
  58: LD_INT 2
  60: PPUSH
  61: LD_INT 0
  63: PPUSH
  64: LD_INT 7
  66: PPUSH
  67: LD_INT 18
  69: PPUSH
  70: LD_INT 19
  72: PPUSH
  73: CALL 82851 0 9
// PrepareAmerican ;
  77: CALL 653 0 0
// PrepareArabian ;
  81: CALL 2605 0 0
// MC_Start ( ) ;
  85: CALL 20164 0 0
// Action ;
  89: CALL 8540 0 0
// end ;
  93: END
// export debug , game ; export mission_prefix , mission_prefix_prev ; export ar_run , base_captured , ar_patrol , us_scout , seen , can_kamikazed , kamikazed , artifact_stolen , artifact_get , artifact_oncargo , game_time , powell_warn , loses_counter , gensher_active , selected , am_veh_consturcted ; function InitVariables ; begin
  94: LD_INT 0
  96: PPUSH
// debug := false ;
  97: LD_ADDR_EXP 1
 101: PUSH
 102: LD_INT 0
 104: ST_TO_ADDR
// game := true ;
 105: LD_ADDR_EXP 2
 109: PUSH
 110: LD_INT 1
 112: ST_TO_ADDR
// mission_prefix := 11_ ;
 113: LD_ADDR_EXP 3
 117: PUSH
 118: LD_STRING 11_
 120: ST_TO_ADDR
// mission_prefix_prev := 10c_ ;
 121: LD_ADDR_EXP 4
 125: PUSH
 126: LD_STRING 10c_
 128: ST_TO_ADDR
// ar_run := false ;
 129: LD_ADDR_EXP 5
 133: PUSH
 134: LD_INT 0
 136: ST_TO_ADDR
// ar_patrol := false ;
 137: LD_ADDR_EXP 7
 141: PUSH
 142: LD_INT 0
 144: ST_TO_ADDR
// base_captured := false ;
 145: LD_ADDR_EXP 6
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// us_scout := 0 ;
 153: LD_ADDR_EXP 8
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// seen := [ 0 , 0 , 0 , 0 , 0 ] ;
 161: LD_ADDR_EXP 9
 165: PUSH
 166: LD_INT 0
 168: PUSH
 169: LD_INT 0
 171: PUSH
 172: LD_INT 0
 174: PUSH
 175: LD_INT 0
 177: PUSH
 178: LD_INT 0
 180: PUSH
 181: EMPTY
 182: LIST
 183: LIST
 184: LIST
 185: LIST
 186: LIST
 187: ST_TO_ADDR
// kamikazed := false ;
 188: LD_ADDR_EXP 11
 192: PUSH
 193: LD_INT 0
 195: ST_TO_ADDR
// artifact_stolen := false ;
 196: LD_ADDR_EXP 12
 200: PUSH
 201: LD_INT 0
 203: ST_TO_ADDR
// artifact_get := false ;
 204: LD_ADDR_EXP 13
 208: PUSH
 209: LD_INT 0
 211: ST_TO_ADDR
// game_time := [ 130 130$00 , 120 120$00 , 115 115$00 , 112 112$00 ] [ Difficulty ] ;
 212: LD_ADDR_EXP 15
 216: PUSH
 217: LD_INT 273000
 219: PUSH
 220: LD_INT 252000
 222: PUSH
 223: LD_INT 241500
 225: PUSH
 226: LD_INT 235200
 228: PUSH
 229: EMPTY
 230: LIST
 231: LIST
 232: LIST
 233: LIST
 234: PUSH
 235: LD_OWVAR 67
 239: ARRAY
 240: ST_TO_ADDR
// powell_warn := false ;
 241: LD_ADDR_EXP 16
 245: PUSH
 246: LD_INT 0
 248: ST_TO_ADDR
// loses_counter := 0 ;
 249: LD_ADDR_EXP 17
 253: PUSH
 254: LD_INT 0
 256: ST_TO_ADDR
// artifact_oncargo := false ;
 257: LD_ADDR_EXP 14
 261: PUSH
 262: LD_INT 0
 264: ST_TO_ADDR
// gensher_active := LoadVariable ( 10_GensherEscape_1 , debug ) ;
 265: LD_ADDR_EXP 18
 269: PUSH
 270: LD_STRING 10_GensherEscape_1
 272: PPUSH
 273: LD_EXP 1
 277: PPUSH
 278: CALL_OW 30
 282: ST_TO_ADDR
// can_kamikazed := false ;
 283: LD_ADDR_EXP 10
 287: PUSH
 288: LD_INT 0
 290: ST_TO_ADDR
// am_veh_consturcted := false ;
 291: LD_ADDR_EXP 20
 295: PUSH
 296: LD_INT 0
 298: ST_TO_ADDR
// end ;
 299: LD_VAR 0 1
 303: RET
// export function CustomInitMacro ; var i ; begin
 304: LD_INT 0
 306: PPUSH
 307: PPUSH
// mc_parking := [ parking_north , parking_west , parking_east ] ;
 308: LD_ADDR_EXP 74
 312: PUSH
 313: LD_INT 20
 315: PUSH
 316: LD_INT 21
 318: PUSH
 319: LD_INT 22
 321: PUSH
 322: EMPTY
 323: LIST
 324: LIST
 325: LIST
 326: ST_TO_ADDR
// mc_scan_area := [ base_north , base_west , base_east ] ;
 327: LD_ADDR_EXP 75
 331: PUSH
 332: LD_INT 28
 334: PUSH
 335: LD_INT 24
 337: PUSH
 338: LD_INT 26
 340: PUSH
 341: EMPTY
 342: LIST
 343: LIST
 344: LIST
 345: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield1_left ) ;
 346: LD_INT 1
 348: PPUSH
 349: LD_INT 4
 351: PUSH
 352: LD_INT 6
 354: PUSH
 355: LD_INT 8
 357: PUSH
 358: LD_INT 9
 360: PUSH
 361: EMPTY
 362: LIST
 363: LIST
 364: LIST
 365: LIST
 366: PUSH
 367: LD_OWVAR 67
 371: ARRAY
 372: PPUSH
 373: LD_INT 3
 375: PPUSH
 376: CALL 41902 0 3
// MC_SetMinesField ( 2 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield2_left ) ;
 380: LD_INT 2
 382: PPUSH
 383: LD_INT 4
 385: PUSH
 386: LD_INT 6
 388: PUSH
 389: LD_INT 8
 391: PUSH
 392: LD_INT 9
 394: PUSH
 395: EMPTY
 396: LIST
 397: LIST
 398: LIST
 399: LIST
 400: PUSH
 401: LD_OWVAR 67
 405: ARRAY
 406: PPUSH
 407: LD_INT 2
 409: PPUSH
 410: CALL 41902 0 3
// MC_SetMinesField ( 3 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield3_left ) ;
 414: LD_INT 3
 416: PPUSH
 417: LD_INT 4
 419: PUSH
 420: LD_INT 6
 422: PUSH
 423: LD_INT 8
 425: PUSH
 426: LD_INT 9
 428: PUSH
 429: EMPTY
 430: LIST
 431: LIST
 432: LIST
 433: LIST
 434: PUSH
 435: LD_OWVAR 67
 439: ARRAY
 440: PPUSH
 441: LD_INT 1
 443: PPUSH
 444: CALL 41902 0 3
// for i = 1 to mc_bases do
 448: LD_ADDR_VAR 0 2
 452: PUSH
 453: DOUBLE
 454: LD_INT 1
 456: DEC
 457: ST_TO_ADDR
 458: LD_EXP 50
 462: PUSH
 463: FOR_TO
 464: IFFALSE 488
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 466: LD_VAR 0 2
 470: PPUSH
 471: LD_EXP 43
 475: PUSH
 476: LD_VAR 0 2
 480: ARRAY
 481: PPUSH
 482: CALL 42328 0 2
 486: GO 463
 488: POP
 489: POP
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] , ] ) ;
 490: LD_INT 1
 492: PPUSH
 493: LD_INT 14
 495: PUSH
 496: LD_INT 1
 498: PUSH
 499: LD_INT 2
 501: PUSH
 502: LD_INT 88
 504: PUSH
 505: EMPTY
 506: LIST
 507: LIST
 508: LIST
 509: LIST
 510: PUSH
 511: LD_INT 14
 513: PUSH
 514: LD_INT 1
 516: PUSH
 517: LD_INT 2
 519: PUSH
 520: LD_INT 88
 522: PUSH
 523: EMPTY
 524: LIST
 525: LIST
 526: LIST
 527: LIST
 528: PUSH
 529: EMPTY
 530: LIST
 531: LIST
 532: PPUSH
 533: CALL 42220 0 2
// MC_SetProduceList ( 2 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 537: LD_INT 2
 539: PPUSH
 540: LD_INT 14
 542: PUSH
 543: LD_INT 1
 545: PUSH
 546: LD_INT 2
 548: PUSH
 549: LD_INT 88
 551: PUSH
 552: EMPTY
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: PUSH
 558: EMPTY
 559: LIST
 560: PPUSH
 561: CALL 42220 0 2
// end ;
 565: LD_VAR 0 1
 569: RET
// function Debuger ; var i ; begin
 570: LD_INT 0
 572: PPUSH
 573: PPUSH
// if not debug then
 574: LD_EXP 1
 578: NOT
 579: IFFALSE 583
// exit ;
 581: GO 619
// game_speed := 5 ;
 583: LD_ADDR_OWVAR 65
 587: PUSH
 588: LD_INT 5
 590: ST_TO_ADDR
// uc_side := 1 ;
 591: LD_ADDR_OWVAR 20
 595: PUSH
 596: LD_INT 1
 598: ST_TO_ADDR
// uc_nation := 1 ;
 599: LD_ADDR_OWVAR 21
 603: PUSH
 604: LD_INT 1
 606: ST_TO_ADDR
// SetSide ( ar_force_south , 1 ) ;
 607: LD_EXP 36
 611: PPUSH
 612: LD_INT 1
 614: PPUSH
 615: CALL_OW 235
// end ;
 619: LD_VAR 0 1
 623: RET
// every 0 0$1 trigger IsDead ( ar_dep_n ) and IsOk ( ar_dep_w ) do
 624: LD_INT 94
 626: PPUSH
 627: CALL_OW 301
 631: PUSH
 632: LD_INT 45
 634: PPUSH
 635: CALL_OW 302
 639: AND
 640: IFFALSE 652
 642: GO 644
 644: DISABLE
// SetAchievement ( ACH_EAST ) ; end_of_file
 645: LD_STRING ACH_EAST
 647: PPUSH
 648: CALL_OW 543
 652: END
// export JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Frank , Kikuchi ; export function PrepareAmerican ; var i , k , un , tmp , vehs , veh , others ; begin
 653: LD_INT 0
 655: PPUSH
 656: PPUSH
 657: PPUSH
 658: PPUSH
 659: PPUSH
 660: PPUSH
 661: PPUSH
 662: PPUSH
// uc_side := 4 ;
 663: LD_ADDR_OWVAR 20
 667: PUSH
 668: LD_INT 4
 670: ST_TO_ADDR
// uc_nation := 1 ;
 671: LD_ADDR_OWVAR 21
 675: PUSH
 676: LD_INT 1
 678: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
 679: LD_ADDR_EXP 30
 683: PUSH
 684: LD_STRING Powell
 686: PPUSH
 687: LD_INT 0
 689: PPUSH
 690: LD_STRING 
 692: PPUSH
 693: CALL 48694 0 3
 697: ST_TO_ADDR
// uc_side := 1 ;
 698: LD_ADDR_OWVAR 20
 702: PUSH
 703: LD_INT 1
 705: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , mission_prefix_prev ) ;
 706: LD_ADDR_EXP 21
 710: PUSH
 711: LD_STRING JMM
 713: PPUSH
 714: LD_EXP 1
 718: NOT
 719: PPUSH
 720: LD_EXP 4
 724: PPUSH
 725: CALL 48694 0 3
 729: ST_TO_ADDR
// if GetClass ( JMM ) > 4 then
 730: LD_EXP 21
 734: PPUSH
 735: CALL_OW 257
 739: PUSH
 740: LD_INT 4
 742: GREATER
 743: IFFALSE 757
// SetClass ( JMM , 1 ) ;
 745: LD_EXP 21
 749: PPUSH
 750: LD_INT 1
 752: PPUSH
 753: CALL_OW 336
// Lisa := PrepareUnit ( Lisa , ( not debug ) , mission_prefix_prev ) ;
 757: LD_ADDR_EXP 22
 761: PUSH
 762: LD_STRING Lisa
 764: PPUSH
 765: LD_EXP 1
 769: NOT
 770: PPUSH
 771: LD_EXP 4
 775: PPUSH
 776: CALL 48694 0 3
 780: ST_TO_ADDR
// if not Lisa then
 781: LD_EXP 22
 785: NOT
 786: IFFALSE 801
// Lisa := CreateCharacter ( 10_Lisa ) ;
 788: LD_ADDR_EXP 22
 792: PUSH
 793: LD_STRING 10_Lisa
 795: PPUSH
 796: CALL_OW 34
 800: ST_TO_ADDR
// if not Lisa then
 801: LD_EXP 22
 805: NOT
 806: IFFALSE 821
// Lisa := CreateCharacter ( 09_Lisa ) ;
 808: LD_ADDR_EXP 22
 812: PUSH
 813: LD_STRING 09_Lisa
 815: PPUSH
 816: CALL_OW 34
 820: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , mission_prefix_prev ) ;
 821: LD_ADDR_EXP 31
 825: PUSH
 826: LD_STRING Cornel
 828: PPUSH
 829: LD_EXP 1
 833: NOT
 834: PPUSH
 835: LD_EXP 4
 839: PPUSH
 840: CALL 48694 0 3
 844: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , mission_prefix_prev ) ;
 845: LD_ADDR_EXP 23
 849: PUSH
 850: LD_STRING Donaldson
 852: PPUSH
 853: LD_EXP 1
 857: NOT
 858: PPUSH
 859: LD_EXP 4
 863: PPUSH
 864: CALL 48694 0 3
 868: ST_TO_ADDR
// if not Donaldson then
 869: LD_EXP 23
 873: NOT
 874: IFFALSE 889
// Donaldson := CreateCharacter ( 10_Donaldson ) ;
 876: LD_ADDR_EXP 23
 880: PUSH
 881: LD_STRING 10_Donaldson
 883: PPUSH
 884: CALL_OW 34
 888: ST_TO_ADDR
// if not Donaldson then
 889: LD_EXP 23
 893: NOT
 894: IFFALSE 909
// Donaldson := CreateCharacter ( 09_Donaldson ) ;
 896: LD_ADDR_EXP 23
 900: PUSH
 901: LD_STRING 09_Donaldson
 903: PPUSH
 904: CALL_OW 34
 908: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , mission_prefix_prev ) ;
 909: LD_ADDR_EXP 24
 913: PUSH
 914: LD_STRING Bobby
 916: PPUSH
 917: LD_EXP 1
 921: NOT
 922: PPUSH
 923: LD_EXP 4
 927: PPUSH
 928: CALL 48694 0 3
 932: ST_TO_ADDR
// if not Bobby then
 933: LD_EXP 24
 937: NOT
 938: IFFALSE 953
// Bobby := CreateCharacter ( 10_Bobby ) ;
 940: LD_ADDR_EXP 24
 944: PUSH
 945: LD_STRING 10_Bobby
 947: PPUSH
 948: CALL_OW 34
 952: ST_TO_ADDR
// if not Bobby then
 953: LD_EXP 24
 957: NOT
 958: IFFALSE 973
// Bobby := CreateCharacter ( 09_Bobby ) ;
 960: LD_ADDR_EXP 24
 964: PUSH
 965: LD_STRING 09_Bobby
 967: PPUSH
 968: CALL_OW 34
 972: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , mission_prefix_prev ) ;
 973: LD_ADDR_EXP 25
 977: PUSH
 978: LD_STRING Cyrus
 980: PPUSH
 981: LD_EXP 1
 985: NOT
 986: PPUSH
 987: LD_EXP 4
 991: PPUSH
 992: CALL 48694 0 3
 996: ST_TO_ADDR
// if not Cyrus then
 997: LD_EXP 25
1001: NOT
1002: IFFALSE 1017
// Cyrus := CreateCharacter ( 10_Cyrus ) ;
1004: LD_ADDR_EXP 25
1008: PUSH
1009: LD_STRING 10_Cyrus
1011: PPUSH
1012: CALL_OW 34
1016: ST_TO_ADDR
// if not Cyrus then
1017: LD_EXP 25
1021: NOT
1022: IFFALSE 1037
// Cyrus := CreateCharacter ( 09_Cyrus ) ;
1024: LD_ADDR_EXP 25
1028: PUSH
1029: LD_STRING 09_Cyrus
1031: PPUSH
1032: CALL_OW 34
1036: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , mission_prefix_prev ) ;
1037: LD_ADDR_EXP 26
1041: PUSH
1042: LD_STRING Denis
1044: PPUSH
1045: LD_EXP 1
1049: NOT
1050: PPUSH
1051: LD_EXP 4
1055: PPUSH
1056: CALL 48694 0 3
1060: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , mission_prefix_prev ) ;
1061: LD_ADDR_EXP 27
1065: PUSH
1066: LD_STRING Brown
1068: PPUSH
1069: LD_EXP 1
1073: NOT
1074: PPUSH
1075: LD_EXP 4
1079: PPUSH
1080: CALL 48694 0 3
1084: ST_TO_ADDR
// if not Brown then
1085: LD_EXP 27
1089: NOT
1090: IFFALSE 1105
// Brown := CreateCharacter ( 10_Brown ) ;
1092: LD_ADDR_EXP 27
1096: PUSH
1097: LD_STRING 10_Brown
1099: PPUSH
1100: CALL_OW 34
1104: ST_TO_ADDR
// if not Brown then
1105: LD_EXP 27
1109: NOT
1110: IFFALSE 1125
// Brown := CreateCharacter ( 08_Brown ) ;
1112: LD_ADDR_EXP 27
1116: PUSH
1117: LD_STRING 08_Brown
1119: PPUSH
1120: CALL_OW 34
1124: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , mission_prefix_prev ) ;
1125: LD_ADDR_EXP 28
1129: PUSH
1130: LD_STRING Gladstone
1132: PPUSH
1133: LD_EXP 1
1137: NOT
1138: PPUSH
1139: LD_EXP 4
1143: PPUSH
1144: CALL 48694 0 3
1148: ST_TO_ADDR
// if not Gladstone then
1149: LD_EXP 28
1153: NOT
1154: IFFALSE 1169
// Gladstone := CreateCharacter ( 10_Gladstone ) ;
1156: LD_ADDR_EXP 28
1160: PUSH
1161: LD_STRING 10_Gladstone
1163: PPUSH
1164: CALL_OW 34
1168: ST_TO_ADDR
// if not Gladstone then
1169: LD_EXP 28
1173: NOT
1174: IFFALSE 1189
// Gladstone := CreateCharacter ( 08_Gladstone ) ;
1176: LD_ADDR_EXP 28
1180: PUSH
1181: LD_STRING 08_Gladstone
1183: PPUSH
1184: CALL_OW 34
1188: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , mission_prefix_prev ) ;
1189: LD_ADDR_EXP 29
1193: PUSH
1194: LD_STRING Houten
1196: PPUSH
1197: LD_EXP 1
1201: NOT
1202: PPUSH
1203: LD_EXP 4
1207: PPUSH
1208: CALL 48694 0 3
1212: ST_TO_ADDR
// if not Houten then
1213: LD_EXP 29
1217: NOT
1218: IFFALSE 1233
// Houten := CreateCharacter ( 10_Houten ) ;
1220: LD_ADDR_EXP 29
1224: PUSH
1225: LD_STRING 10_Houten
1227: PPUSH
1228: CALL_OW 34
1232: ST_TO_ADDR
// if not Houten then
1233: LD_EXP 29
1237: NOT
1238: IFFALSE 1253
// Houten := CreateCharacter ( 09_Houten ) ;
1240: LD_ADDR_EXP 29
1244: PUSH
1245: LD_STRING 09_Houten
1247: PPUSH
1248: CALL_OW 34
1252: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , ( not debug ) , mission_prefix_prev ) ;
1253: LD_ADDR_EXP 31
1257: PUSH
1258: LD_STRING Cornell
1260: PPUSH
1261: LD_EXP 1
1265: NOT
1266: PPUSH
1267: LD_EXP 4
1271: PPUSH
1272: CALL 48694 0 3
1276: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , mission_prefix_prev ) ;
1277: LD_ADDR_EXP 32
1281: PUSH
1282: LD_STRING Gary
1284: PPUSH
1285: LD_EXP 1
1289: NOT
1290: PPUSH
1291: LD_EXP 4
1295: PPUSH
1296: CALL 48694 0 3
1300: ST_TO_ADDR
// if not Gary then
1301: LD_EXP 32
1305: NOT
1306: IFFALSE 1321
// Gary := CreateCharacter ( 10_Gary ) ;
1308: LD_ADDR_EXP 32
1312: PUSH
1313: LD_STRING 10_Gary
1315: PPUSH
1316: CALL_OW 34
1320: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , mission_prefix_prev ) ;
1321: LD_ADDR_EXP 33
1325: PUSH
1326: LD_STRING Frank
1328: PPUSH
1329: LD_EXP 1
1333: NOT
1334: PPUSH
1335: LD_EXP 4
1339: PPUSH
1340: CALL 48694 0 3
1344: ST_TO_ADDR
// if not Frank then
1345: LD_EXP 33
1349: NOT
1350: IFFALSE 1365
// Frank := CreateCharacter ( 08_Frank ) ;
1352: LD_ADDR_EXP 33
1356: PUSH
1357: LD_STRING 08_Frank
1359: PPUSH
1360: CALL_OW 34
1364: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , mission_prefix_prev ) ;
1365: LD_ADDR_EXP 34
1369: PUSH
1370: LD_STRING Kikuchi
1372: PPUSH
1373: LD_EXP 1
1377: NOT
1378: PPUSH
1379: LD_EXP 4
1383: PPUSH
1384: CALL 48694 0 3
1388: ST_TO_ADDR
// if not Kikuchi then
1389: LD_EXP 34
1393: NOT
1394: IFFALSE 1409
// Kikuchi := CreateCharacter ( 08_Kikuchi ) ;
1396: LD_ADDR_EXP 34
1400: PUSH
1401: LD_STRING 08_Kikuchi
1403: PPUSH
1404: CALL_OW 34
1408: ST_TO_ADDR
// tmp := [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1409: LD_ADDR_VAR 0 5
1413: PUSH
1414: LD_EXP 22
1418: PUSH
1419: LD_EXP 23
1423: PUSH
1424: LD_EXP 24
1428: PUSH
1429: LD_EXP 25
1433: PUSH
1434: LD_EXP 26
1438: PUSH
1439: LD_EXP 27
1443: PUSH
1444: LD_EXP 28
1448: PUSH
1449: LD_EXP 29
1453: PUSH
1454: LD_EXP 31
1458: PUSH
1459: LD_EXP 32
1463: PUSH
1464: LD_EXP 33
1468: PUSH
1469: LD_EXP 34
1473: PUSH
1474: EMPTY
1475: LIST
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: LIST
1481: LIST
1482: LIST
1483: LIST
1484: LIST
1485: LIST
1486: LIST
1487: ST_TO_ADDR
// tmp := tmp diff 0 ;
1488: LD_ADDR_VAR 0 5
1492: PUSH
1493: LD_VAR 0 5
1497: PUSH
1498: LD_INT 0
1500: DIFF
1501: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10_lock ) ;
1502: LD_ADDR_VAR 0 5
1506: PUSH
1507: LD_VAR 0 5
1511: PUSH
1512: LD_STRING 10_lock
1514: PPUSH
1515: CALL_OW 31
1519: UNION
1520: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10c_lock ) ;
1521: LD_ADDR_VAR 0 5
1525: PUSH
1526: LD_VAR 0 5
1530: PUSH
1531: LD_STRING 10c_lock
1533: PPUSH
1534: CALL_OW 31
1538: UNION
1539: ST_TO_ADDR
// DeleteCharacters ( 10_lock ) ;
1540: LD_STRING 10_lock
1542: PPUSH
1543: CALL_OW 40
// DeleteCharacters ( 10c_lock ) ;
1547: LD_STRING 10c_lock
1549: PPUSH
1550: CALL_OW 40
// for i in tmp do
1554: LD_ADDR_VAR 0 2
1558: PUSH
1559: LD_VAR 0 5
1563: PUSH
1564: FOR_IN
1565: IFFALSE 1603
// if GetClass ( i ) in [ class_mortar , class_engineer ] then
1567: LD_VAR 0 2
1571: PPUSH
1572: CALL_OW 257
1576: PUSH
1577: LD_INT 8
1579: PUSH
1580: LD_INT 2
1582: PUSH
1583: EMPTY
1584: LIST
1585: LIST
1586: IN
1587: IFFALSE 1601
// SetClass ( i , class_soldier ) ;
1589: LD_VAR 0 2
1593: PPUSH
1594: LD_INT 1
1596: PPUSH
1597: CALL_OW 336
1601: GO 1564
1603: POP
1604: POP
// if tmp < 12 then
1605: LD_VAR 0 5
1609: PUSH
1610: LD_INT 12
1612: LESS
1613: IFFALSE 1707
// begin k := 16 - tmp ;
1615: LD_ADDR_VAR 0 3
1619: PUSH
1620: LD_INT 16
1622: PUSH
1623: LD_VAR 0 5
1627: MINUS
1628: ST_TO_ADDR
// for i = 1 to k do
1629: LD_ADDR_VAR 0 2
1633: PUSH
1634: DOUBLE
1635: LD_INT 1
1637: DEC
1638: ST_TO_ADDR
1639: LD_VAR 0 3
1643: PUSH
1644: FOR_TO
1645: IFFALSE 1705
// begin PrepareHuman ( false , [ 1 , 1 , 3 , 4 ] [ rand ( 1 , 4 ) ] , 6 ) ;
1647: LD_INT 0
1649: PPUSH
1650: LD_INT 1
1652: PUSH
1653: LD_INT 1
1655: PUSH
1656: LD_INT 3
1658: PUSH
1659: LD_INT 4
1661: PUSH
1662: EMPTY
1663: LIST
1664: LIST
1665: LIST
1666: LIST
1667: PUSH
1668: LD_INT 1
1670: PPUSH
1671: LD_INT 4
1673: PPUSH
1674: CALL_OW 12
1678: ARRAY
1679: PPUSH
1680: LD_INT 6
1682: PPUSH
1683: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
1687: LD_ADDR_VAR 0 5
1691: PUSH
1692: LD_VAR 0 5
1696: PUSH
1697: CALL_OW 44
1701: ADD
1702: ST_TO_ADDR
// end ;
1703: GO 1644
1705: POP
1706: POP
// end ; selected := CharacterSelection ( 1 , 12 , 12 , [ sel_change_class , JMM , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp ^ [ sel_dont_change_class , sel_not_changeable , Powell ] , [ [ class_soldier , 4 ] , [ class_mechanic , 0 , 5 ] , [ class_scientistic , 0 , 3 ] , [ class_sniper , 0 , 2 ] ] ) ;
1707: LD_ADDR_EXP 19
1711: PUSH
1712: LD_STRING 1
1714: PPUSH
1715: LD_INT 12
1717: PPUSH
1718: LD_INT 12
1720: PPUSH
1721: LD_INT -5
1723: PUSH
1724: LD_EXP 21
1728: PUSH
1729: LD_INT -2
1731: PUSH
1732: LD_INT -3
1734: PUSH
1735: LD_INT -5
1737: PUSH
1738: EMPTY
1739: LIST
1740: LIST
1741: LIST
1742: LIST
1743: LIST
1744: PUSH
1745: LD_VAR 0 5
1749: ADD
1750: PUSH
1751: LD_INT -6
1753: PUSH
1754: LD_INT -4
1756: PUSH
1757: LD_EXP 30
1761: PUSH
1762: EMPTY
1763: LIST
1764: LIST
1765: LIST
1766: ADD
1767: PPUSH
1768: LD_INT 1
1770: PUSH
1771: LD_INT 4
1773: PUSH
1774: EMPTY
1775: LIST
1776: LIST
1777: PUSH
1778: LD_INT 3
1780: PUSH
1781: LD_INT 0
1783: PUSH
1784: LD_INT 5
1786: PUSH
1787: EMPTY
1788: LIST
1789: LIST
1790: LIST
1791: PUSH
1792: LD_INT 4
1794: PUSH
1795: LD_INT 0
1797: PUSH
1798: LD_INT 3
1800: PUSH
1801: EMPTY
1802: LIST
1803: LIST
1804: LIST
1805: PUSH
1806: LD_INT 5
1808: PUSH
1809: LD_INT 0
1811: PUSH
1812: LD_INT 2
1814: PUSH
1815: EMPTY
1816: LIST
1817: LIST
1818: LIST
1819: PUSH
1820: EMPTY
1821: LIST
1822: LIST
1823: LIST
1824: LIST
1825: PPUSH
1826: CALL_OW 42
1830: ST_TO_ADDR
// others := tmp diff selected ;
1831: LD_ADDR_VAR 0 8
1835: PUSH
1836: LD_VAR 0 5
1840: PUSH
1841: LD_EXP 19
1845: DIFF
1846: ST_TO_ADDR
// others := others diff [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1847: LD_ADDR_VAR 0 8
1851: PUSH
1852: LD_VAR 0 8
1856: PUSH
1857: LD_EXP 22
1861: PUSH
1862: LD_EXP 23
1866: PUSH
1867: LD_EXP 24
1871: PUSH
1872: LD_EXP 25
1876: PUSH
1877: LD_EXP 26
1881: PUSH
1882: LD_EXP 27
1886: PUSH
1887: LD_EXP 28
1891: PUSH
1892: LD_EXP 29
1896: PUSH
1897: LD_EXP 31
1901: PUSH
1902: LD_EXP 32
1906: PUSH
1907: LD_EXP 33
1911: PUSH
1912: LD_EXP 34
1916: PUSH
1917: EMPTY
1918: LIST
1919: LIST
1920: LIST
1921: LIST
1922: LIST
1923: LIST
1924: LIST
1925: LIST
1926: LIST
1927: LIST
1928: LIST
1929: LIST
1930: DIFF
1931: ST_TO_ADDR
// if others then
1932: LD_VAR 0 8
1936: IFFALSE 1950
// SaveCharacters ( others , 11_others ) ;
1938: LD_VAR 0 8
1942: PPUSH
1943: LD_STRING 11_others
1945: PPUSH
1946: CALL_OW 38
// vehs := [ [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun ] , [ us_medium_wheeled , engine_siberite , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_medium_wheeled , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_siberite , control_manual , us_rocket_launcher ] ] ;
1950: LD_ADDR_VAR 0 6
1954: PUSH
1955: LD_INT 3
1957: PUSH
1958: LD_INT 1
1960: PUSH
1961: LD_INT 1
1963: PUSH
1964: LD_INT 4
1966: PUSH
1967: EMPTY
1968: LIST
1969: LIST
1970: LIST
1971: LIST
1972: PUSH
1973: LD_INT 2
1975: PUSH
1976: LD_INT 3
1978: PUSH
1979: LD_INT 1
1981: PUSH
1982: LD_INT 5
1984: PUSH
1985: EMPTY
1986: LIST
1987: LIST
1988: LIST
1989: LIST
1990: PUSH
1991: LD_INT 4
1993: PUSH
1994: LD_INT 1
1996: PUSH
1997: LD_INT 1
1999: PUSH
2000: LD_INT 5
2002: PUSH
2003: EMPTY
2004: LIST
2005: LIST
2006: LIST
2007: LIST
2008: PUSH
2009: LD_INT 2
2011: PUSH
2012: LD_INT 1
2014: PUSH
2015: LD_INT 1
2017: PUSH
2018: LD_INT 7
2020: PUSH
2021: EMPTY
2022: LIST
2023: LIST
2024: LIST
2025: LIST
2026: PUSH
2027: LD_INT 3
2029: PUSH
2030: LD_INT 3
2032: PUSH
2033: LD_INT 1
2035: PUSH
2036: LD_INT 7
2038: PUSH
2039: EMPTY
2040: LIST
2041: LIST
2042: LIST
2043: LIST
2044: PUSH
2045: EMPTY
2046: LIST
2047: LIST
2048: LIST
2049: LIST
2050: LIST
2051: ST_TO_ADDR
// for i in JMM ^ selected do
2052: LD_ADDR_VAR 0 2
2056: PUSH
2057: LD_EXP 21
2061: PUSH
2062: LD_EXP 19
2066: ADD
2067: PUSH
2068: FOR_IN
2069: IFFALSE 2259
// begin if GetClass ( i ) = 3 then
2071: LD_VAR 0 2
2075: PPUSH
2076: CALL_OW 257
2080: PUSH
2081: LD_INT 3
2083: EQUAL
2084: IFFALSE 2242
// begin vc_chassis := vehs [ 1 ] [ 1 ] ;
2086: LD_ADDR_OWVAR 37
2090: PUSH
2091: LD_VAR 0 6
2095: PUSH
2096: LD_INT 1
2098: ARRAY
2099: PUSH
2100: LD_INT 1
2102: ARRAY
2103: ST_TO_ADDR
// vc_engine := vehs [ 1 ] [ 2 ] ;
2104: LD_ADDR_OWVAR 39
2108: PUSH
2109: LD_VAR 0 6
2113: PUSH
2114: LD_INT 1
2116: ARRAY
2117: PUSH
2118: LD_INT 2
2120: ARRAY
2121: ST_TO_ADDR
// vc_control := vehs [ 1 ] [ 3 ] ;
2122: LD_ADDR_OWVAR 38
2126: PUSH
2127: LD_VAR 0 6
2131: PUSH
2132: LD_INT 1
2134: ARRAY
2135: PUSH
2136: LD_INT 3
2138: ARRAY
2139: ST_TO_ADDR
// vc_weapon := vehs [ 1 ] [ 4 ] ;
2140: LD_ADDR_OWVAR 40
2144: PUSH
2145: LD_VAR 0 6
2149: PUSH
2150: LD_INT 1
2152: ARRAY
2153: PUSH
2154: LD_INT 4
2156: ARRAY
2157: ST_TO_ADDR
// vehs := Delete ( vehs , 1 ) ;
2158: LD_ADDR_VAR 0 6
2162: PUSH
2163: LD_VAR 0 6
2167: PPUSH
2168: LD_INT 1
2170: PPUSH
2171: CALL_OW 3
2175: ST_TO_ADDR
// veh := CreateVehicle ;
2176: LD_ADDR_VAR 0 7
2180: PUSH
2181: CALL_OW 45
2185: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2186: LD_VAR 0 7
2190: PPUSH
2191: LD_INT 8
2193: PPUSH
2194: LD_INT 0
2196: PPUSH
2197: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
2201: LD_VAR 0 2
2205: PPUSH
2206: LD_VAR 0 7
2210: PPUSH
2211: CALL_OW 52
// if i = JMM then
2215: LD_VAR 0 2
2219: PUSH
2220: LD_EXP 21
2224: EQUAL
2225: IFFALSE 2240
// SetMark ( veh , - 1 ) ;
2227: LD_VAR 0 7
2231: PPUSH
2232: LD_INT 1
2234: NEG
2235: PPUSH
2236: CALL_OW 242
// end else
2240: GO 2257
// PlaceUnitArea ( i , am_hum_start , false ) ;
2242: LD_VAR 0 2
2246: PPUSH
2247: LD_INT 9
2249: PPUSH
2250: LD_INT 0
2252: PPUSH
2253: CALL_OW 49
// end ;
2257: GO 2068
2259: POP
2260: POP
// vc_chassis := us_medium_tracked ;
2261: LD_ADDR_OWVAR 37
2265: PUSH
2266: LD_INT 3
2268: ST_TO_ADDR
// vc_engine := engine_solar ;
2269: LD_ADDR_OWVAR 39
2273: PUSH
2274: LD_INT 2
2276: ST_TO_ADDR
// vc_control := control_computer ;
2277: LD_ADDR_OWVAR 38
2281: PUSH
2282: LD_INT 3
2284: ST_TO_ADDR
// vc_weapon := us_radar ;
2285: LD_ADDR_OWVAR 40
2289: PUSH
2290: LD_INT 11
2292: ST_TO_ADDR
// veh := CreateVehicle ;
2293: LD_ADDR_VAR 0 7
2297: PUSH
2298: CALL_OW 45
2302: ST_TO_ADDR
// PlaceUnitXY ( veh , 87 , 142 , false ) ;
2303: LD_VAR 0 7
2307: PPUSH
2308: LD_INT 87
2310: PPUSH
2311: LD_INT 142
2313: PPUSH
2314: LD_INT 0
2316: PPUSH
2317: CALL_OW 48
// end ;
2321: LD_VAR 0 1
2325: RET
// export function AmericanReinforcements ; var i , vehs , veh ; begin
2326: LD_INT 0
2328: PPUSH
2329: PPUSH
2330: PPUSH
2331: PPUSH
// uc_side := 1 ;
2332: LD_ADDR_OWVAR 20
2336: PUSH
2337: LD_INT 1
2339: ST_TO_ADDR
// uc_nation := 1 ;
2340: LD_ADDR_OWVAR 21
2344: PUSH
2345: LD_INT 1
2347: ST_TO_ADDR
// vehs := [ [ us_medium_tracked , engine_combustion , control_computer , us_double_gun ] , [ us_medium_tracked , engine_combustion , control_computer , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_computer , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_computer , us_radar ] , [ us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_computer , us_double_gun ] ] ;
2348: LD_ADDR_VAR 0 3
2352: PUSH
2353: LD_INT 3
2355: PUSH
2356: LD_INT 1
2358: PUSH
2359: LD_INT 3
2361: PUSH
2362: LD_INT 5
2364: PUSH
2365: EMPTY
2366: LIST
2367: LIST
2368: LIST
2369: LIST
2370: PUSH
2371: LD_INT 3
2373: PUSH
2374: LD_INT 1
2376: PUSH
2377: LD_INT 3
2379: PUSH
2380: LD_INT 7
2382: PUSH
2383: EMPTY
2384: LIST
2385: LIST
2386: LIST
2387: LIST
2388: PUSH
2389: LD_INT 3
2391: PUSH
2392: LD_INT 1
2394: PUSH
2395: LD_INT 3
2397: PUSH
2398: LD_INT 7
2400: PUSH
2401: EMPTY
2402: LIST
2403: LIST
2404: LIST
2405: LIST
2406: PUSH
2407: LD_INT 3
2409: PUSH
2410: LD_INT 1
2412: PUSH
2413: LD_INT 3
2415: PUSH
2416: LD_INT 11
2418: PUSH
2419: EMPTY
2420: LIST
2421: LIST
2422: LIST
2423: LIST
2424: PUSH
2425: LD_INT 4
2427: PUSH
2428: LD_INT 1
2430: PUSH
2431: LD_INT 3
2433: PUSH
2434: LD_INT 6
2436: PUSH
2437: EMPTY
2438: LIST
2439: LIST
2440: LIST
2441: LIST
2442: PUSH
2443: LD_INT 4
2445: PUSH
2446: LD_INT 1
2448: PUSH
2449: LD_INT 3
2451: PUSH
2452: LD_INT 5
2454: PUSH
2455: EMPTY
2456: LIST
2457: LIST
2458: LIST
2459: LIST
2460: PUSH
2461: EMPTY
2462: LIST
2463: LIST
2464: LIST
2465: LIST
2466: LIST
2467: LIST
2468: ST_TO_ADDR
// for i := 1 to 7 - Difficulty do
2469: LD_ADDR_VAR 0 2
2473: PUSH
2474: DOUBLE
2475: LD_INT 1
2477: DEC
2478: ST_TO_ADDR
2479: LD_INT 7
2481: PUSH
2482: LD_OWVAR 67
2486: MINUS
2487: PUSH
2488: FOR_TO
2489: IFFALSE 2598
// begin vc_chassis := vehs [ i ] [ 1 ] ;
2491: LD_ADDR_OWVAR 37
2495: PUSH
2496: LD_VAR 0 3
2500: PUSH
2501: LD_VAR 0 2
2505: ARRAY
2506: PUSH
2507: LD_INT 1
2509: ARRAY
2510: ST_TO_ADDR
// vc_engine := vehs [ i ] [ 2 ] ;
2511: LD_ADDR_OWVAR 39
2515: PUSH
2516: LD_VAR 0 3
2520: PUSH
2521: LD_VAR 0 2
2525: ARRAY
2526: PUSH
2527: LD_INT 2
2529: ARRAY
2530: ST_TO_ADDR
// vc_control := vehs [ i ] [ 3 ] ;
2531: LD_ADDR_OWVAR 38
2535: PUSH
2536: LD_VAR 0 3
2540: PUSH
2541: LD_VAR 0 2
2545: ARRAY
2546: PUSH
2547: LD_INT 3
2549: ARRAY
2550: ST_TO_ADDR
// vc_weapon := vehs [ i ] [ 4 ] ;
2551: LD_ADDR_OWVAR 40
2555: PUSH
2556: LD_VAR 0 3
2560: PUSH
2561: LD_VAR 0 2
2565: ARRAY
2566: PUSH
2567: LD_INT 4
2569: ARRAY
2570: ST_TO_ADDR
// veh := CreateVehicle ;
2571: LD_ADDR_VAR 0 4
2575: PUSH
2576: CALL_OW 45
2580: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2581: LD_VAR 0 4
2585: PPUSH
2586: LD_INT 8
2588: PPUSH
2589: LD_INT 0
2591: PPUSH
2592: CALL_OW 49
// end ;
2596: GO 2488
2598: POP
2599: POP
// end ; end_of_file
2600: LD_VAR 0 1
2604: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_north_2 , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_kamikadze , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ; var i , d , un , skill , tmp ; begin
2605: LD_INT 0
2607: PPUSH
2608: PPUSH
2609: PPUSH
2610: PPUSH
2611: PPUSH
2612: PPUSH
// if Difficulty = 1 then
2613: LD_OWVAR 67
2617: PUSH
2618: LD_INT 1
2620: EQUAL
2621: IFFALSE 2718
// begin tmp := [ [ 129 , 45 ] , [ 143 , 58 ] , [ 184 , 113 ] , [ 163 , 107 ] ] ;
2623: LD_ADDR_VAR 0 6
2627: PUSH
2628: LD_INT 129
2630: PUSH
2631: LD_INT 45
2633: PUSH
2634: EMPTY
2635: LIST
2636: LIST
2637: PUSH
2638: LD_INT 143
2640: PUSH
2641: LD_INT 58
2643: PUSH
2644: EMPTY
2645: LIST
2646: LIST
2647: PUSH
2648: LD_INT 184
2650: PUSH
2651: LD_INT 113
2653: PUSH
2654: EMPTY
2655: LIST
2656: LIST
2657: PUSH
2658: LD_INT 163
2660: PUSH
2661: LD_INT 107
2663: PUSH
2664: EMPTY
2665: LIST
2666: LIST
2667: PUSH
2668: EMPTY
2669: LIST
2670: LIST
2671: LIST
2672: LIST
2673: ST_TO_ADDR
// for i in tmp do
2674: LD_ADDR_VAR 0 2
2678: PUSH
2679: LD_VAR 0 6
2683: PUSH
2684: FOR_IN
2685: IFFALSE 2716
// RemoveUnit ( HexInfo ( i [ 1 ] , i [ 2 ] ) ) ;
2687: LD_VAR 0 2
2691: PUSH
2692: LD_INT 1
2694: ARRAY
2695: PPUSH
2696: LD_VAR 0 2
2700: PUSH
2701: LD_INT 2
2703: ARRAY
2704: PPUSH
2705: CALL_OW 428
2709: PPUSH
2710: CALL_OW 64
2714: GO 2684
2716: POP
2717: POP
// end ; for i in FilterAllUnits ( [ f_type , unit_building ] ) do
2718: LD_ADDR_VAR 0 2
2722: PUSH
2723: LD_INT 21
2725: PUSH
2726: LD_INT 3
2728: PUSH
2729: EMPTY
2730: LIST
2731: LIST
2732: PPUSH
2733: CALL_OW 69
2737: PUSH
2738: FOR_IN
2739: IFFALSE 2776
// SetBLevel ( i , [ 5 , 6 , 7 , 8 ] [ Difficulty ] ) ;
2741: LD_VAR 0 2
2745: PPUSH
2746: LD_INT 5
2748: PUSH
2749: LD_INT 6
2751: PUSH
2752: LD_INT 7
2754: PUSH
2755: LD_INT 8
2757: PUSH
2758: EMPTY
2759: LIST
2760: LIST
2761: LIST
2762: LIST
2763: PUSH
2764: LD_OWVAR 67
2768: ARRAY
2769: PPUSH
2770: CALL_OW 241
2774: GO 2738
2776: POP
2777: POP
// skill := [ 5 , 6 , 7 , 8 ] [ Difficulty ] ;
2778: LD_ADDR_VAR 0 5
2782: PUSH
2783: LD_INT 5
2785: PUSH
2786: LD_INT 6
2788: PUSH
2789: LD_INT 7
2791: PUSH
2792: LD_INT 8
2794: PUSH
2795: EMPTY
2796: LIST
2797: LIST
2798: LIST
2799: LIST
2800: PUSH
2801: LD_OWVAR 67
2805: ARRAY
2806: ST_TO_ADDR
// uc_side := 2 ;
2807: LD_ADDR_OWVAR 20
2811: PUSH
2812: LD_INT 2
2814: ST_TO_ADDR
// uc_nation := 2 ;
2815: LD_ADDR_OWVAR 21
2819: PUSH
2820: LD_INT 2
2822: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
2823: LD_ADDR_OWVAR 37
2827: PUSH
2828: LD_INT 14
2830: ST_TO_ADDR
// vc_engine := engine_siberite ;
2831: LD_ADDR_OWVAR 39
2835: PUSH
2836: LD_INT 3
2838: ST_TO_ADDR
// vc_control := control_manual ;
2839: LD_ADDR_OWVAR 38
2843: PUSH
2844: LD_INT 1
2846: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
2847: LD_ADDR_OWVAR 40
2851: PUSH
2852: LD_INT 31
2854: ST_TO_ADDR
// for i = 1 to 3 do
2855: LD_ADDR_VAR 0 2
2859: PUSH
2860: DOUBLE
2861: LD_INT 1
2863: DEC
2864: ST_TO_ADDR
2865: LD_INT 3
2867: PUSH
2868: FOR_TO
2869: IFFALSE 2953
// begin PrepareHuman ( false , class_mechanic , skill ) ;
2871: LD_INT 0
2873: PPUSH
2874: LD_INT 3
2876: PPUSH
2877: LD_VAR 0 5
2881: PPUSH
2882: CALL_OW 380
// un := CreateVehicle ;
2886: LD_ADDR_VAR 0 4
2890: PUSH
2891: CALL_OW 45
2895: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
2896: LD_VAR 0 4
2900: PPUSH
2901: LD_INT 0
2903: PPUSH
2904: LD_INT 5
2906: PPUSH
2907: CALL_OW 12
2911: PPUSH
2912: CALL_OW 233
// PlaceUnitXYR ( un , 156 , 15 , 6 , false ) ;
2916: LD_VAR 0 4
2920: PPUSH
2921: LD_INT 156
2923: PPUSH
2924: LD_INT 15
2926: PPUSH
2927: LD_INT 6
2929: PPUSH
2930: LD_INT 0
2932: PPUSH
2933: CALL_OW 50
// PlaceHumanInUnit ( CreateHuman , un ) ;
2937: CALL_OW 44
2941: PPUSH
2942: LD_VAR 0 4
2946: PPUSH
2947: CALL_OW 52
// end ;
2951: GO 2868
2953: POP
2954: POP
// ar_force_north := PrepareBase ( ar_dep_n , base_north , dammam , skill , [ 10000 , 1000 , 300 ] , [ 12 , [ 2 , 3 , 4 , 4 ] [ Difficulty ] , - 1 , 4 ] ) ;
2955: LD_ADDR_EXP 37
2959: PUSH
2960: LD_INT 94
2962: PPUSH
2963: LD_INT 28
2965: PPUSH
2966: LD_STRING dammam
2968: PPUSH
2969: LD_VAR 0 5
2973: PPUSH
2974: LD_INT 10000
2976: PUSH
2977: LD_INT 1000
2979: PUSH
2980: LD_INT 300
2982: PUSH
2983: EMPTY
2984: LIST
2985: LIST
2986: LIST
2987: PPUSH
2988: LD_INT 12
2990: PUSH
2991: LD_INT 2
2993: PUSH
2994: LD_INT 3
2996: PUSH
2997: LD_INT 4
2999: PUSH
3000: LD_INT 4
3002: PUSH
3003: EMPTY
3004: LIST
3005: LIST
3006: LIST
3007: LIST
3008: PUSH
3009: LD_OWVAR 67
3013: ARRAY
3014: PUSH
3015: LD_INT 1
3017: NEG
3018: PUSH
3019: LD_INT 4
3021: PUSH
3022: EMPTY
3023: LIST
3024: LIST
3025: LIST
3026: LIST
3027: PPUSH
3028: CALL 57153 0 6
3032: ST_TO_ADDR
// ar_force_north := ar_force_north union PrepareBase ( ar_dep_n2 , base_north_2 ,  , skill , [ 500 , 60 , 0 ] , [ 8 , [ 2 , 3 , 4 , 5 ] [ Difficulty ] , 2 , 0 ] ) ;
3033: LD_ADDR_EXP 37
3037: PUSH
3038: LD_EXP 37
3042: PUSH
3043: LD_INT 122
3045: PPUSH
3046: LD_INT 25
3048: PPUSH
3049: LD_STRING 
3051: PPUSH
3052: LD_VAR 0 5
3056: PPUSH
3057: LD_INT 500
3059: PUSH
3060: LD_INT 60
3062: PUSH
3063: LD_INT 0
3065: PUSH
3066: EMPTY
3067: LIST
3068: LIST
3069: LIST
3070: PPUSH
3071: LD_INT 8
3073: PUSH
3074: LD_INT 2
3076: PUSH
3077: LD_INT 3
3079: PUSH
3080: LD_INT 4
3082: PUSH
3083: LD_INT 5
3085: PUSH
3086: EMPTY
3087: LIST
3088: LIST
3089: LIST
3090: LIST
3091: PUSH
3092: LD_OWVAR 67
3096: ARRAY
3097: PUSH
3098: LD_INT 2
3100: PUSH
3101: LD_INT 0
3103: PUSH
3104: EMPTY
3105: LIST
3106: LIST
3107: LIST
3108: LIST
3109: PPUSH
3110: CALL 57153 0 6
3114: UNION
3115: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , base_west , jeddah , skill , [ 700 , 300 , 10 ] , [ 9 , 4 , 3 , 2 ] ) ;
3116: LD_ADDR_EXP 35
3120: PUSH
3121: LD_INT 45
3123: PPUSH
3124: LD_INT 24
3126: PPUSH
3127: LD_STRING jeddah
3129: PPUSH
3130: LD_VAR 0 5
3134: PPUSH
3135: LD_INT 700
3137: PUSH
3138: LD_INT 300
3140: PUSH
3141: LD_INT 10
3143: PUSH
3144: EMPTY
3145: LIST
3146: LIST
3147: LIST
3148: PPUSH
3149: LD_INT 9
3151: PUSH
3152: LD_INT 4
3154: PUSH
3155: LD_INT 3
3157: PUSH
3158: LD_INT 2
3160: PUSH
3161: EMPTY
3162: LIST
3163: LIST
3164: LIST
3165: LIST
3166: PPUSH
3167: CALL 57153 0 6
3171: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , base_south , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
3172: LD_ADDR_EXP 36
3176: PUSH
3177: LD_INT 7
3179: PPUSH
3180: LD_INT 27
3182: PPUSH
3183: LD_STRING riyadh
3185: PPUSH
3186: LD_VAR 0 5
3190: PPUSH
3191: LD_INT 500
3193: PUSH
3194: LD_INT 60
3196: PUSH
3197: LD_INT 0
3199: PUSH
3200: EMPTY
3201: LIST
3202: LIST
3203: LIST
3204: PPUSH
3205: LD_INT 4
3207: PUSH
3208: LD_INT 2
3210: PUSH
3211: LD_INT 3
3213: PUSH
3214: LD_INT 1
3216: PUSH
3217: EMPTY
3218: LIST
3219: LIST
3220: LIST
3221: LIST
3222: PPUSH
3223: CALL 57153 0 6
3227: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e , base_east ,  , skill , [ 500 , 50 , 0 ] , [ 9 , 2 , 3 , 1 ] ) ;
3228: LD_ADDR_EXP 39
3232: PUSH
3233: LD_INT 204
3235: PPUSH
3236: LD_INT 26
3238: PPUSH
3239: LD_STRING 
3241: PPUSH
3242: LD_VAR 0 5
3246: PPUSH
3247: LD_INT 500
3249: PUSH
3250: LD_INT 50
3252: PUSH
3253: LD_INT 0
3255: PUSH
3256: EMPTY
3257: LIST
3258: LIST
3259: LIST
3260: PPUSH
3261: LD_INT 9
3263: PUSH
3264: LD_INT 2
3266: PUSH
3267: LD_INT 3
3269: PUSH
3270: LD_INT 1
3272: PUSH
3273: EMPTY
3274: LIST
3275: LIST
3276: LIST
3277: LIST
3278: PPUSH
3279: CALL 57153 0 6
3283: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east ] ;
3284: LD_ADDR_EXP 50
3288: PUSH
3289: LD_EXP 37
3293: PUSH
3294: LD_EXP 35
3298: PUSH
3299: LD_EXP 39
3303: PUSH
3304: EMPTY
3305: LIST
3306: LIST
3307: LIST
3308: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
3309: LD_ADDR_VAR 0 2
3313: PUSH
3314: LD_INT 22
3316: PUSH
3317: LD_INT 2
3319: PUSH
3320: EMPTY
3321: LIST
3322: LIST
3323: PUSH
3324: LD_INT 30
3326: PUSH
3327: LD_INT 31
3329: PUSH
3330: EMPTY
3331: LIST
3332: LIST
3333: PUSH
3334: LD_INT 58
3336: PUSH
3337: EMPTY
3338: LIST
3339: PUSH
3340: EMPTY
3341: LIST
3342: LIST
3343: LIST
3344: PPUSH
3345: CALL_OW 69
3349: PUSH
3350: FOR_IN
3351: IFFALSE 3476
// begin if GetBase ( i ) then
3353: LD_VAR 0 2
3357: PPUSH
3358: CALL_OW 274
3362: IFFALSE 3366
// continue ;
3364: GO 3350
// d := GetDir ( i ) ;
3366: LD_ADDR_VAR 0 3
3370: PUSH
3371: LD_VAR 0 2
3375: PPUSH
3376: CALL_OW 254
3380: ST_TO_ADDR
// if d < 3 then
3381: LD_VAR 0 3
3385: PUSH
3386: LD_INT 3
3388: LESS
3389: IFFALSE 3407
// d := d + 3 else
3391: LD_ADDR_VAR 0 3
3395: PUSH
3396: LD_VAR 0 3
3400: PUSH
3401: LD_INT 3
3403: PLUS
3404: ST_TO_ADDR
3405: GO 3421
// d := d - 3 ;
3407: LD_ADDR_VAR 0 3
3411: PUSH
3412: LD_VAR 0 3
3416: PUSH
3417: LD_INT 3
3419: MINUS
3420: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
3421: LD_INT 0
3423: PPUSH
3424: LD_INT 8
3426: PPUSH
3427: LD_VAR 0 5
3431: PPUSH
3432: CALL_OW 380
// un := CreateHuman ;
3436: LD_ADDR_VAR 0 4
3440: PUSH
3441: CALL_OW 44
3445: ST_TO_ADDR
// SetDir ( un , d ) ;
3446: LD_VAR 0 4
3450: PPUSH
3451: LD_VAR 0 3
3455: PPUSH
3456: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
3460: LD_VAR 0 4
3464: PPUSH
3465: LD_VAR 0 2
3469: PPUSH
3470: CALL_OW 52
// end ;
3474: GO 3350
3476: POP
3477: POP
// if Difficulty > 1 then
3478: LD_OWVAR 67
3482: PUSH
3483: LD_INT 1
3485: GREATER
3486: IFFALSE 3857
// begin ar_kamikadze := [ ] ;
3488: LD_ADDR_EXP 42
3492: PUSH
3493: EMPTY
3494: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
3495: LD_INT 0
3497: PPUSH
3498: LD_INT 1
3500: PPUSH
3501: LD_VAR 0 5
3505: PPUSH
3506: CALL_OW 380
// un := CreateHuman ;
3510: LD_ADDR_VAR 0 4
3514: PUSH
3515: CALL_OW 44
3519: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3520: LD_VAR 0 4
3524: PPUSH
3525: LD_INT 3
3527: PPUSH
3528: CALL_OW 233
// PlaceUnitXY ( un , 23 , 44 , false ) ;
3532: LD_VAR 0 4
3536: PPUSH
3537: LD_INT 23
3539: PPUSH
3540: LD_INT 44
3542: PPUSH
3543: LD_INT 0
3545: PPUSH
3546: CALL_OW 48
// ComCrawl ( un ) ;
3550: LD_VAR 0 4
3554: PPUSH
3555: CALL_OW 137
// un := CreateHuman ;
3559: LD_ADDR_VAR 0 4
3563: PUSH
3564: CALL_OW 44
3568: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3569: LD_VAR 0 4
3573: PPUSH
3574: LD_INT 3
3576: PPUSH
3577: CALL_OW 233
// PlaceUnitXY ( un , 30 , 39 , false ) ;
3581: LD_VAR 0 4
3585: PPUSH
3586: LD_INT 30
3588: PPUSH
3589: LD_INT 39
3591: PPUSH
3592: LD_INT 0
3594: PPUSH
3595: CALL_OW 48
// ComCrawl ( un ) ;
3599: LD_VAR 0 4
3603: PPUSH
3604: CALL_OW 137
// PrepareHuman ( false , 17 , skill ) ;
3608: LD_INT 0
3610: PPUSH
3611: LD_INT 17
3613: PPUSH
3614: LD_VAR 0 5
3618: PPUSH
3619: CALL_OW 380
// un := CreateHuman ;
3623: LD_ADDR_VAR 0 4
3627: PUSH
3628: CALL_OW 44
3632: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3633: LD_VAR 0 4
3637: PPUSH
3638: LD_INT 3
3640: PPUSH
3641: CALL_OW 233
// PlaceUnitXY ( un , 45 , 86 , false ) ;
3645: LD_VAR 0 4
3649: PPUSH
3650: LD_INT 45
3652: PPUSH
3653: LD_INT 86
3655: PPUSH
3656: LD_INT 0
3658: PPUSH
3659: CALL_OW 48
// ComHold ( un ) ;
3663: LD_VAR 0 4
3667: PPUSH
3668: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3672: LD_ADDR_EXP 42
3676: PUSH
3677: LD_EXP 42
3681: PPUSH
3682: LD_EXP 42
3686: PUSH
3687: LD_INT 1
3689: PLUS
3690: PPUSH
3691: LD_VAR 0 4
3695: PPUSH
3696: CALL_OW 1
3700: ST_TO_ADDR
// un := CreateHuman ;
3701: LD_ADDR_VAR 0 4
3705: PUSH
3706: CALL_OW 44
3710: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3711: LD_VAR 0 4
3715: PPUSH
3716: LD_INT 3
3718: PPUSH
3719: CALL_OW 233
// PlaceUnitXY ( un , 60 , 85 , false ) ;
3723: LD_VAR 0 4
3727: PPUSH
3728: LD_INT 60
3730: PPUSH
3731: LD_INT 85
3733: PPUSH
3734: LD_INT 0
3736: PPUSH
3737: CALL_OW 48
// ComHold ( un ) ;
3741: LD_VAR 0 4
3745: PPUSH
3746: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3750: LD_ADDR_EXP 42
3754: PUSH
3755: LD_EXP 42
3759: PPUSH
3760: LD_EXP 42
3764: PUSH
3765: LD_INT 1
3767: PLUS
3768: PPUSH
3769: LD_VAR 0 4
3773: PPUSH
3774: CALL_OW 1
3778: ST_TO_ADDR
// un := CreateHuman ;
3779: LD_ADDR_VAR 0 4
3783: PUSH
3784: CALL_OW 44
3788: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3789: LD_VAR 0 4
3793: PPUSH
3794: LD_INT 3
3796: PPUSH
3797: CALL_OW 233
// PlaceUnitXY ( un , 222 , 166 , false ) ;
3801: LD_VAR 0 4
3805: PPUSH
3806: LD_INT 222
3808: PPUSH
3809: LD_INT 166
3811: PPUSH
3812: LD_INT 0
3814: PPUSH
3815: CALL_OW 48
// ComHold ( un ) ;
3819: LD_VAR 0 4
3823: PPUSH
3824: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3828: LD_ADDR_EXP 42
3832: PUSH
3833: LD_EXP 42
3837: PPUSH
3838: LD_EXP 42
3842: PUSH
3843: LD_INT 1
3845: PLUS
3846: PPUSH
3847: LD_VAR 0 4
3851: PPUSH
3852: CALL_OW 1
3856: ST_TO_ADDR
// end ; ar_force_tmp := [ ] ;
3857: LD_ADDR_EXP 40
3861: PUSH
3862: EMPTY
3863: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
3864: LD_INT 1
3866: PPUSH
3867: LD_INT 1
3869: PPUSH
3870: LD_VAR 0 5
3874: PPUSH
3875: CALL_OW 380
// hc_name := Pavel Grigorovic ;
3879: LD_ADDR_OWVAR 26
3883: PUSH
3884: LD_STRING Pavel Grigorovic
3886: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3887: LD_ADDR_OWVAR 33
3891: PUSH
3892: LD_STRING SecondCharsGal
3894: ST_TO_ADDR
// hc_face_number := 4 ;
3895: LD_ADDR_OWVAR 34
3899: PUSH
3900: LD_INT 4
3902: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
3903: LD_ADDR_EXP 40
3907: PUSH
3908: LD_EXP 40
3912: PPUSH
3913: LD_INT 1
3915: PPUSH
3916: CALL_OW 44
3920: PPUSH
3921: CALL_OW 1
3925: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3926: LD_INT 2
3928: PPUSH
3929: LD_INT 4
3931: PPUSH
3932: LD_INT 2
3934: PPUSH
3935: CALL_OW 380
// hc_name := Lucy Sebel ;
3939: LD_ADDR_OWVAR 26
3943: PUSH
3944: LD_STRING Lucy Sebel
3946: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3947: LD_ADDR_OWVAR 33
3951: PUSH
3952: LD_STRING SecondCharsGal
3954: ST_TO_ADDR
// hc_face_number := 15 ;
3955: LD_ADDR_OWVAR 34
3959: PUSH
3960: LD_INT 15
3962: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
3963: LD_ADDR_EXP 40
3967: PUSH
3968: LD_EXP 40
3972: PPUSH
3973: LD_INT 2
3975: PPUSH
3976: CALL_OW 44
3980: PPUSH
3981: CALL_OW 1
3985: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3986: LD_INT 2
3988: PPUSH
3989: LD_INT 4
3991: PPUSH
3992: LD_INT 2
3994: PPUSH
3995: CALL_OW 380
// hc_gallery :=  ;
3999: LD_ADDR_OWVAR 33
4003: PUSH
4004: LD_STRING 
4006: ST_TO_ADDR
// hc_name :=  ;
4007: LD_ADDR_OWVAR 26
4011: PUSH
4012: LD_STRING 
4014: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
4015: LD_ADDR_EXP 40
4019: PUSH
4020: LD_EXP 40
4024: PPUSH
4025: LD_INT 3
4027: PPUSH
4028: CALL_OW 44
4032: PPUSH
4033: CALL_OW 1
4037: ST_TO_ADDR
// hc_sex := sex_male ;
4038: LD_ADDR_OWVAR 27
4042: PUSH
4043: LD_INT 1
4045: ST_TO_ADDR
// hc_class = 11 ;
4046: LD_ADDR_OWVAR 28
4050: PUSH
4051: LD_INT 11
4053: ST_TO_ADDR
// hc_gallery = sandar ;
4054: LD_ADDR_OWVAR 33
4058: PUSH
4059: LD_STRING sandar
4061: ST_TO_ADDR
// hc_face_number = 33 ;
4062: LD_ADDR_OWVAR 34
4066: PUSH
4067: LD_INT 33
4069: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
4070: LD_ADDR_OWVAR 26
4074: PUSH
4075: LD_STRING Thabit Muhair Saliba
4077: ST_TO_ADDR
// hc_skills = [ 0 , 0 , 0 , 0 ] ;
4078: LD_ADDR_OWVAR 31
4082: PUSH
4083: LD_INT 0
4085: PUSH
4086: LD_INT 0
4088: PUSH
4089: LD_INT 0
4091: PUSH
4092: LD_INT 0
4094: PUSH
4095: EMPTY
4096: LIST
4097: LIST
4098: LIST
4099: LIST
4100: ST_TO_ADDR
// Saliba = CreateHuman ;
4101: LD_ADDR_EXP 44
4105: PUSH
4106: CALL_OW 44
4110: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
4111: LD_EXP 44
4115: PPUSH
4116: LD_INT 7
4118: PPUSH
4119: CALL_OW 52
// if gensher_active then
4123: LD_EXP 18
4127: IFFALSE 4154
// begin Gensher = NewCharacter ( Dietrich ) ;
4129: LD_ADDR_EXP 45
4133: PUSH
4134: LD_STRING Dietrich
4136: PPUSH
4137: CALL_OW 25
4141: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
4142: LD_EXP 45
4146: PPUSH
4147: LD_INT 94
4149: PPUSH
4150: CALL_OW 52
// end ; InitHc ;
4154: CALL_OW 19
// ar_vehicles_tmp := [ ] ;
4158: LD_ADDR_EXP 41
4162: PUSH
4163: EMPTY
4164: ST_TO_ADDR
// for i = 1 to 5 do
4165: LD_ADDR_VAR 0 2
4169: PUSH
4170: DOUBLE
4171: LD_INT 1
4173: DEC
4174: ST_TO_ADDR
4175: LD_INT 5
4177: PUSH
4178: FOR_TO
4179: IFFALSE 4351
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , [ engine_combustion , engine_solar ] [ rand ( 1 , 2 ) ] , control_manual , [ ar_gatling_gun , ar_gun , ar_flame_thrower ] [ rand ( 1 , 3 ) ] , rand ( 60 , 100 ) ) ;
4181: LD_INT 13
4183: PUSH
4184: LD_INT 14
4186: PUSH
4187: EMPTY
4188: LIST
4189: LIST
4190: PUSH
4191: LD_INT 1
4193: PPUSH
4194: LD_INT 2
4196: PPUSH
4197: CALL_OW 12
4201: ARRAY
4202: PPUSH
4203: LD_INT 1
4205: PUSH
4206: LD_INT 2
4208: PUSH
4209: EMPTY
4210: LIST
4211: LIST
4212: PUSH
4213: LD_INT 1
4215: PPUSH
4216: LD_INT 2
4218: PPUSH
4219: CALL_OW 12
4223: ARRAY
4224: PPUSH
4225: LD_INT 1
4227: PPUSH
4228: LD_INT 25
4230: PUSH
4231: LD_INT 27
4233: PUSH
4234: LD_INT 26
4236: PUSH
4237: EMPTY
4238: LIST
4239: LIST
4240: LIST
4241: PUSH
4242: LD_INT 1
4244: PPUSH
4245: LD_INT 3
4247: PPUSH
4248: CALL_OW 12
4252: ARRAY
4253: PPUSH
4254: LD_INT 60
4256: PPUSH
4257: LD_INT 100
4259: PPUSH
4260: CALL_OW 12
4264: PPUSH
4265: CALL 53709 0 5
// un := CreateVehicle ;
4269: LD_ADDR_VAR 0 4
4273: PUSH
4274: CALL_OW 45
4278: ST_TO_ADDR
// ar_vehicles_tmp := Replace ( ar_vehicles_tmp , ar_vehicles_tmp + 1 , un ) ;
4279: LD_ADDR_EXP 41
4283: PUSH
4284: LD_EXP 41
4288: PPUSH
4289: LD_EXP 41
4293: PUSH
4294: LD_INT 1
4296: PLUS
4297: PPUSH
4298: LD_VAR 0 4
4302: PPUSH
4303: CALL_OW 1
4307: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4308: LD_VAR 0 4
4312: PPUSH
4313: LD_INT 0
4315: PPUSH
4316: LD_INT 5
4318: PPUSH
4319: CALL_OW 12
4323: PPUSH
4324: CALL_OW 233
// PlaceUnitXYR ( un , 124 , 141 , 8 , false ) ;
4328: LD_VAR 0 4
4332: PPUSH
4333: LD_INT 124
4335: PPUSH
4336: LD_INT 141
4338: PPUSH
4339: LD_INT 8
4341: PPUSH
4342: LD_INT 0
4344: PPUSH
4345: CALL_OW 50
// end ;
4349: GO 4178
4351: POP
4352: POP
// ar_defenders_tmp := [ [ ] , [ ] , [ ] ] ;
4353: LD_ADDR_EXP 43
4357: PUSH
4358: EMPTY
4359: PUSH
4360: EMPTY
4361: PUSH
4362: EMPTY
4363: PUSH
4364: EMPTY
4365: LIST
4366: LIST
4367: LIST
4368: ST_TO_ADDR
// for d = 1 to [ 3 , 3 , 4 , 4 ] [ Difficulty ] do
4369: LD_ADDR_VAR 0 3
4373: PUSH
4374: DOUBLE
4375: LD_INT 1
4377: DEC
4378: ST_TO_ADDR
4379: LD_INT 3
4381: PUSH
4382: LD_INT 3
4384: PUSH
4385: LD_INT 4
4387: PUSH
4388: LD_INT 4
4390: PUSH
4391: EMPTY
4392: LIST
4393: LIST
4394: LIST
4395: LIST
4396: PUSH
4397: LD_OWVAR 67
4401: ARRAY
4402: PUSH
4403: FOR_TO
4404: IFFALSE 4618
// for i = 1 to 3 do
4406: LD_ADDR_VAR 0 2
4410: PUSH
4411: DOUBLE
4412: LD_INT 1
4414: DEC
4415: ST_TO_ADDR
4416: LD_INT 3
4418: PUSH
4419: FOR_TO
4420: IFFALSE 4614
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
4422: LD_INT 14
4424: PPUSH
4425: LD_INT 3
4427: PUSH
4428: LD_INT 2
4430: PUSH
4431: EMPTY
4432: LIST
4433: LIST
4434: PUSH
4435: LD_INT 1
4437: PPUSH
4438: LD_INT 2
4440: PPUSH
4441: CALL_OW 12
4445: ARRAY
4446: PPUSH
4447: LD_INT 1
4449: PUSH
4450: LD_INT 5
4452: PUSH
4453: EMPTY
4454: LIST
4455: LIST
4456: PUSH
4457: LD_INT 1
4459: PPUSH
4460: LD_INT 2
4462: PPUSH
4463: CALL_OW 12
4467: ARRAY
4468: PPUSH
4469: LD_INT 25
4471: PUSH
4472: LD_INT 27
4474: PUSH
4475: LD_INT 26
4477: PUSH
4478: LD_INT 28
4480: PUSH
4481: EMPTY
4482: LIST
4483: LIST
4484: LIST
4485: LIST
4486: PUSH
4487: LD_INT 1
4489: PPUSH
4490: LD_INT 4
4492: PPUSH
4493: CALL_OW 12
4497: ARRAY
4498: PPUSH
4499: LD_INT 100
4501: PPUSH
4502: CALL 53709 0 5
// un := CreateVehicle ;
4506: LD_ADDR_VAR 0 4
4510: PUSH
4511: CALL_OW 45
4515: ST_TO_ADDR
// ar_defenders_tmp := ReplaceIn ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
4516: LD_ADDR_EXP 43
4520: PUSH
4521: LD_EXP 43
4525: PPUSH
4526: LD_VAR 0 2
4530: PUSH
4531: LD_EXP 43
4535: PUSH
4536: LD_VAR 0 2
4540: ARRAY
4541: PUSH
4542: LD_INT 1
4544: PLUS
4545: PUSH
4546: EMPTY
4547: LIST
4548: LIST
4549: PPUSH
4550: LD_VAR 0 4
4554: PPUSH
4555: CALL 53831 0 3
4559: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4560: LD_VAR 0 4
4564: PPUSH
4565: LD_INT 0
4567: PPUSH
4568: LD_INT 5
4570: PPUSH
4571: CALL_OW 12
4575: PPUSH
4576: CALL_OW 233
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east ] [ i ] , false ) ;
4580: LD_VAR 0 4
4584: PPUSH
4585: LD_INT 20
4587: PUSH
4588: LD_INT 21
4590: PUSH
4591: LD_INT 22
4593: PUSH
4594: EMPTY
4595: LIST
4596: LIST
4597: LIST
4598: PUSH
4599: LD_VAR 0 2
4603: ARRAY
4604: PPUSH
4605: LD_INT 0
4607: PPUSH
4608: CALL_OW 49
// end ;
4612: GO 4419
4614: POP
4615: POP
4616: GO 4403
4618: POP
4619: POP
// InitHc ;
4620: CALL_OW 19
// CreateResourcesXY ( mat_artifact , 5 , 10 , 5 , false ) ;
4624: LD_INT 4
4626: PPUSH
4627: LD_INT 5
4629: PPUSH
4630: LD_INT 10
4632: PPUSH
4633: LD_INT 5
4635: PPUSH
4636: LD_INT 0
4638: PPUSH
4639: CALL_OW 58
// end ;
4643: LD_VAR 0 1
4647: RET
// every 0 0$1 trigger ar_kamikadze do var i ;
4648: LD_EXP 42
4652: IFFALSE 4726
4654: GO 4656
4656: DISABLE
4657: LD_INT 0
4659: PPUSH
// begin enable ;
4660: ENABLE
// for i in ar_kamikadze do
4661: LD_ADDR_VAR 0 1
4665: PUSH
4666: LD_EXP 42
4670: PUSH
4671: FOR_IN
4672: IFFALSE 4724
// if See ( 1 , i ) then
4674: LD_INT 1
4676: PPUSH
4677: LD_VAR 0 1
4681: PPUSH
4682: CALL_OW 292
4686: IFFALSE 4722
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
4688: LD_VAR 0 1
4692: PPUSH
4693: LD_INT 81
4695: PUSH
4696: LD_INT 2
4698: PUSH
4699: EMPTY
4700: LIST
4701: LIST
4702: PPUSH
4703: CALL_OW 69
4707: PPUSH
4708: LD_VAR 0 1
4712: PPUSH
4713: CALL_OW 74
4717: PPUSH
4718: CALL_OW 115
4722: GO 4671
4724: POP
4725: POP
// end ;
4726: PPOPN 1
4728: END
// every 5 5$20 trigger artifact_get do var i , cargo , tmp , pos ;
4729: LD_EXP 13
4733: IFFALSE 5050
4735: GO 4737
4737: DISABLE
4738: LD_INT 0
4740: PPUSH
4741: PPUSH
4742: PPUSH
4743: PPUSH
// begin repeat wait ( 0 0$1 ) ;
4744: LD_INT 35
4746: PPUSH
4747: CALL_OW 67
// until MC_GetProduceList ( 1 ) = 0 ;
4751: LD_INT 1
4753: PPUSH
4754: CALL 42616 0 1
4758: PUSH
4759: LD_INT 0
4761: EQUAL
4762: IFFALSE 4744
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
4764: LD_INT 1
4766: PPUSH
4767: LD_INT 14
4769: PUSH
4770: LD_INT 3
4772: PUSH
4773: LD_INT 2
4775: PUSH
4776: LD_INT 32
4778: PUSH
4779: EMPTY
4780: LIST
4781: LIST
4782: LIST
4783: LIST
4784: PUSH
4785: EMPTY
4786: LIST
4787: PPUSH
4788: CALL 42220 0 2
// repeat wait ( 0 0$1 ) ;
4792: LD_INT 35
4794: PPUSH
4795: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) ;
4799: LD_EXP 69
4803: PUSH
4804: LD_INT 1
4806: ARRAY
4807: PPUSH
4808: LD_INT 33
4810: PUSH
4811: LD_INT 2
4813: PUSH
4814: EMPTY
4815: LIST
4816: LIST
4817: PUSH
4818: LD_INT 34
4820: PUSH
4821: LD_INT 32
4823: PUSH
4824: EMPTY
4825: LIST
4826: LIST
4827: PUSH
4828: EMPTY
4829: LIST
4830: LIST
4831: PPUSH
4832: CALL_OW 72
4836: IFFALSE 4792
// cargo := UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) [ 1 ] ;
4838: LD_ADDR_VAR 0 2
4842: PUSH
4843: LD_EXP 69
4847: PUSH
4848: LD_INT 1
4850: ARRAY
4851: PPUSH
4852: LD_INT 33
4854: PUSH
4855: LD_INT 2
4857: PUSH
4858: EMPTY
4859: LIST
4860: LIST
4861: PUSH
4862: LD_INT 34
4864: PUSH
4865: LD_INT 32
4867: PUSH
4868: EMPTY
4869: LIST
4870: LIST
4871: PUSH
4872: EMPTY
4873: LIST
4874: LIST
4875: PPUSH
4876: CALL_OW 72
4880: PUSH
4881: LD_INT 1
4883: ARRAY
4884: ST_TO_ADDR
// pos := FindArtifact ( 5 ) ;
4885: LD_ADDR_VAR 0 4
4889: PUSH
4890: LD_INT 5
4892: PPUSH
4893: CALL_OW 469
4897: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4898: LD_INT 35
4900: PPUSH
4901: CALL_OW 67
// pos := FindArtifact ( 5 ) ;
4905: LD_ADDR_VAR 0 4
4909: PUSH
4910: LD_INT 5
4912: PPUSH
4913: CALL_OW 469
4917: ST_TO_ADDR
// tmp := 100 ;
4918: LD_ADDR_VAR 0 3
4922: PUSH
4923: LD_INT 100
4925: ST_TO_ADDR
// if pos then
4926: LD_VAR 0 4
4930: IFFALSE 4970
// tmp := DangerAtRangeXY ( 2 , pos [ 1 ] , pos [ 2 ] , 20 ) [ 4 ] ;
4932: LD_ADDR_VAR 0 3
4936: PUSH
4937: LD_INT 2
4939: PPUSH
4940: LD_VAR 0 4
4944: PUSH
4945: LD_INT 1
4947: ARRAY
4948: PPUSH
4949: LD_VAR 0 4
4953: PUSH
4954: LD_INT 2
4956: ARRAY
4957: PPUSH
4958: LD_INT 20
4960: PPUSH
4961: CALL 54727 0 4
4965: PUSH
4966: LD_INT 4
4968: ARRAY
4969: ST_TO_ADDR
// until pos and not artifact_oncargo and tmp < 10 ;
4970: LD_VAR 0 4
4974: PUSH
4975: LD_EXP 14
4979: NOT
4980: AND
4981: PUSH
4982: LD_VAR 0 3
4986: PUSH
4987: LD_INT 10
4989: LESS
4990: AND
4991: IFFALSE 4898
// ComGet ( cargo , pos [ 1 ] , pos [ 2 ] ) ;
4993: LD_VAR 0 2
4997: PPUSH
4998: LD_VAR 0 4
5002: PUSH
5003: LD_INT 1
5005: ARRAY
5006: PPUSH
5007: LD_VAR 0 4
5011: PUSH
5012: LD_INT 2
5014: ARRAY
5015: PPUSH
5016: CALL_OW 160
// AddComMoveXY ( cargo , 198 , 113 ) ;
5020: LD_VAR 0 2
5024: PPUSH
5025: LD_INT 198
5027: PPUSH
5028: LD_INT 113
5030: PPUSH
5031: CALL_OW 171
// AddComMoveXY ( cargo , 124 , 7 ) ;
5035: LD_VAR 0 2
5039: PPUSH
5040: LD_INT 124
5042: PPUSH
5043: LD_INT 7
5045: PPUSH
5046: CALL_OW 171
// end ;
5050: PPOPN 4
5052: END
// every 5 5$00 trigger base_captured do var i , un , tmp , skill , coords , flags , list ;
5053: LD_EXP 6
5057: IFFALSE 7020
5059: GO 5061
5061: DISABLE
5062: LD_INT 0
5064: PPUSH
5065: PPUSH
5066: PPUSH
5067: PPUSH
5068: PPUSH
5069: PPUSH
5070: PPUSH
// begin skill := [ 5 , 6 , 7 , 8 ] [ Difficulty ] ;
5071: LD_ADDR_VAR 0 4
5075: PUSH
5076: LD_INT 5
5078: PUSH
5079: LD_INT 6
5081: PUSH
5082: LD_INT 7
5084: PUSH
5085: LD_INT 8
5087: PUSH
5088: EMPTY
5089: LIST
5090: LIST
5091: LIST
5092: LIST
5093: PUSH
5094: LD_OWVAR 67
5098: ARRAY
5099: ST_TO_ADDR
// coords := [ ] ;
5100: LD_ADDR_VAR 0 5
5104: PUSH
5105: EMPTY
5106: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
5107: LD_ADDR_VAR 0 6
5111: PUSH
5112: LD_INT 0
5114: PUSH
5115: LD_INT 0
5117: PUSH
5118: LD_INT 0
5120: PUSH
5121: LD_INT 0
5123: PUSH
5124: LD_INT 1
5126: PUSH
5127: LD_INT 0
5129: PUSH
5130: LD_INT 0
5132: PUSH
5133: LD_INT 0
5135: PUSH
5136: LD_INT 1
5138: PUSH
5139: LD_INT 0
5141: PUSH
5142: EMPTY
5143: LIST
5144: LIST
5145: LIST
5146: LIST
5147: LIST
5148: LIST
5149: LIST
5150: LIST
5151: LIST
5152: LIST
5153: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ) ;
5154: LD_INT 1
5156: PPUSH
5157: LD_INT 14
5159: PUSH
5160: LD_INT 1
5162: PUSH
5163: LD_INT 2
5165: PUSH
5166: LD_INT 28
5168: PUSH
5169: EMPTY
5170: LIST
5171: LIST
5172: LIST
5173: LIST
5174: PUSH
5175: LD_INT 14
5177: PUSH
5178: LD_INT 1
5180: PUSH
5181: LD_INT 2
5183: PUSH
5184: LD_INT 25
5186: PUSH
5187: EMPTY
5188: LIST
5189: LIST
5190: LIST
5191: LIST
5192: PUSH
5193: LD_INT 14
5195: PUSH
5196: LD_INT 1
5198: PUSH
5199: LD_INT 2
5201: PUSH
5202: LD_INT 28
5204: PUSH
5205: EMPTY
5206: LIST
5207: LIST
5208: LIST
5209: LIST
5210: PUSH
5211: LD_INT 14
5213: PUSH
5214: LD_INT 1
5216: PUSH
5217: LD_INT 2
5219: PUSH
5220: LD_INT 29
5222: PUSH
5223: EMPTY
5224: LIST
5225: LIST
5226: LIST
5227: LIST
5228: PUSH
5229: EMPTY
5230: LIST
5231: LIST
5232: LIST
5233: LIST
5234: PPUSH
5235: CALL 42220 0 2
// wait ( [ 10 10$00 , 9 9$30 , 9 9$00 , 8 8$40 ] [ Difficulty ] ) ;
5239: LD_INT 21000
5241: PUSH
5242: LD_INT 19950
5244: PUSH
5245: LD_INT 18900
5247: PUSH
5248: LD_INT 18200
5250: PUSH
5251: EMPTY
5252: LIST
5253: LIST
5254: LIST
5255: LIST
5256: PUSH
5257: LD_OWVAR 67
5261: ARRAY
5262: PPUSH
5263: CALL_OW 67
// InitHc ;
5267: CALL_OW 19
// InitUc ;
5271: CALL_OW 18
// uc_side := 2 ;
5275: LD_ADDR_OWVAR 20
5279: PUSH
5280: LD_INT 2
5282: ST_TO_ADDR
// uc_nation := 2 ;
5283: LD_ADDR_OWVAR 21
5287: PUSH
5288: LD_INT 2
5290: ST_TO_ADDR
// tmp := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
5291: LD_ADDR_VAR 0 3
5295: PUSH
5296: EMPTY
5297: PUSH
5298: EMPTY
5299: PUSH
5300: EMPTY
5301: PUSH
5302: EMPTY
5303: PUSH
5304: EMPTY
5305: PUSH
5306: EMPTY
5307: LIST
5308: LIST
5309: LIST
5310: LIST
5311: LIST
5312: ST_TO_ADDR
// tmp := Replace ( tmp , 1 , mc_vehicles [ 1 ] diff FilterAllUnits ( [ f_or , [ f_weapon , ar_crane ] , [ f_weapon , ar_cargo_bay ] ] ) ) ;
5313: LD_ADDR_VAR 0 3
5317: PUSH
5318: LD_VAR 0 3
5322: PPUSH
5323: LD_INT 1
5325: PPUSH
5326: LD_EXP 69
5330: PUSH
5331: LD_INT 1
5333: ARRAY
5334: PUSH
5335: LD_INT 2
5337: PUSH
5338: LD_INT 34
5340: PUSH
5341: LD_INT 88
5343: PUSH
5344: EMPTY
5345: LIST
5346: LIST
5347: PUSH
5348: LD_INT 34
5350: PUSH
5351: LD_INT 32
5353: PUSH
5354: EMPTY
5355: LIST
5356: LIST
5357: PUSH
5358: EMPTY
5359: LIST
5360: LIST
5361: LIST
5362: PPUSH
5363: CALL_OW 69
5367: DIFF
5368: PPUSH
5369: CALL_OW 1
5373: ST_TO_ADDR
// for i = 1 to Difficulty do
5374: LD_ADDR_VAR 0 1
5378: PUSH
5379: DOUBLE
5380: LD_INT 1
5382: DEC
5383: ST_TO_ADDR
5384: LD_OWVAR 67
5388: PUSH
5389: FOR_TO
5390: IFFALSE 5528
// begin uc_side := 2 ;
5392: LD_ADDR_OWVAR 20
5396: PUSH
5397: LD_INT 2
5399: ST_TO_ADDR
// uc_nation := 2 ;
5400: LD_ADDR_OWVAR 21
5404: PUSH
5405: LD_INT 2
5407: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
5408: LD_INT 13
5410: PPUSH
5411: LD_INT 3
5413: PPUSH
5414: LD_INT 5
5416: PPUSH
5417: LD_INT 29
5419: PPUSH
5420: LD_INT 100
5422: PPUSH
5423: CALL 53709 0 5
// un := CreateVehicle ;
5427: LD_ADDR_VAR 0 2
5431: PUSH
5432: CALL_OW 45
5436: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 1 , tmp [ 1 ] + 1 ] , un ) ;
5437: LD_ADDR_VAR 0 3
5441: PUSH
5442: LD_VAR 0 3
5446: PPUSH
5447: LD_INT 1
5449: PUSH
5450: LD_VAR 0 3
5454: PUSH
5455: LD_INT 1
5457: ARRAY
5458: PUSH
5459: LD_INT 1
5461: PLUS
5462: PUSH
5463: EMPTY
5464: LIST
5465: LIST
5466: PPUSH
5467: LD_VAR 0 2
5471: PPUSH
5472: CALL 53831 0 3
5476: ST_TO_ADDR
// SetDir ( un , 3 ) ;
5477: LD_VAR 0 2
5481: PPUSH
5482: LD_INT 3
5484: PPUSH
5485: CALL_OW 233
// PlaceUnitArea ( un , north_attack_spawn , false ) ;
5489: LD_VAR 0 2
5493: PPUSH
5494: LD_INT 16
5496: PPUSH
5497: LD_INT 0
5499: PPUSH
5500: CALL_OW 49
// ComMoveXY ( un , 51 , 10 ) ;
5504: LD_VAR 0 2
5508: PPUSH
5509: LD_INT 51
5511: PPUSH
5512: LD_INT 10
5514: PPUSH
5515: CALL_OW 111
// wait ( 0 0$2 ) ;
5519: LD_INT 70
5521: PPUSH
5522: CALL_OW 67
// end ;
5526: GO 5389
5528: POP
5529: POP
// coords := [ [ 51 , 24 ] , [ 75 , 90 ] ] ;
5530: LD_ADDR_VAR 0 5
5534: PUSH
5535: LD_INT 51
5537: PUSH
5538: LD_INT 24
5540: PUSH
5541: EMPTY
5542: LIST
5543: LIST
5544: PUSH
5545: LD_INT 75
5547: PUSH
5548: LD_INT 90
5550: PUSH
5551: EMPTY
5552: LIST
5553: LIST
5554: PUSH
5555: EMPTY
5556: LIST
5557: LIST
5558: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 1 ] , coords , flags ) ;
5559: LD_INT 1
5561: PPUSH
5562: LD_VAR 0 3
5566: PUSH
5567: LD_INT 1
5569: ARRAY
5570: PPUSH
5571: LD_VAR 0 5
5575: PPUSH
5576: LD_VAR 0 6
5580: PPUSH
5581: CALL 42453 0 4
// for i = 1 to [ 1 , 3 , 4 , 5 ] [ Difficulty ] do
5585: LD_ADDR_VAR 0 1
5589: PUSH
5590: DOUBLE
5591: LD_INT 1
5593: DEC
5594: ST_TO_ADDR
5595: LD_INT 1
5597: PUSH
5598: LD_INT 3
5600: PUSH
5601: LD_INT 4
5603: PUSH
5604: LD_INT 5
5606: PUSH
5607: EMPTY
5608: LIST
5609: LIST
5610: LIST
5611: LIST
5612: PUSH
5613: LD_OWVAR 67
5617: ARRAY
5618: PUSH
5619: FOR_TO
5620: IFFALSE 5720
// begin uc_side := 2 ;
5622: LD_ADDR_OWVAR 20
5626: PUSH
5627: LD_INT 2
5629: ST_TO_ADDR
// uc_nation := 2 ;
5630: LD_ADDR_OWVAR 21
5634: PUSH
5635: LD_INT 2
5637: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5638: LD_INT 0
5640: PPUSH
5641: LD_INT 17
5643: PPUSH
5644: LD_VAR 0 4
5648: PPUSH
5649: CALL_OW 380
// un := CreateHuman ;
5653: LD_ADDR_VAR 0 2
5657: PUSH
5658: CALL_OW 44
5662: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5663: LD_ADDR_VAR 0 3
5667: PUSH
5668: LD_VAR 0 3
5672: PPUSH
5673: LD_INT 2
5675: PUSH
5676: LD_VAR 0 3
5680: PUSH
5681: LD_INT 2
5683: ARRAY
5684: PUSH
5685: LD_INT 1
5687: PLUS
5688: PUSH
5689: EMPTY
5690: LIST
5691: LIST
5692: PPUSH
5693: LD_VAR 0 2
5697: PPUSH
5698: CALL 53831 0 3
5702: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5703: LD_VAR 0 2
5707: PPUSH
5708: LD_INT 13
5710: PPUSH
5711: LD_INT 0
5713: PPUSH
5714: CALL_OW 49
// end ;
5718: GO 5619
5720: POP
5721: POP
// for i = 1 to [ 3 , 4 , 5 , 6 ] [ Difficulty ] do
5722: LD_ADDR_VAR 0 1
5726: PUSH
5727: DOUBLE
5728: LD_INT 1
5730: DEC
5731: ST_TO_ADDR
5732: LD_INT 3
5734: PUSH
5735: LD_INT 4
5737: PUSH
5738: LD_INT 5
5740: PUSH
5741: LD_INT 6
5743: PUSH
5744: EMPTY
5745: LIST
5746: LIST
5747: LIST
5748: LIST
5749: PUSH
5750: LD_OWVAR 67
5754: ARRAY
5755: PUSH
5756: FOR_TO
5757: IFFALSE 5878
// begin uc_side := 2 ;
5759: LD_ADDR_OWVAR 20
5763: PUSH
5764: LD_INT 2
5766: ST_TO_ADDR
// uc_nation := 2 ;
5767: LD_ADDR_OWVAR 21
5771: PUSH
5772: LD_INT 2
5774: ST_TO_ADDR
// PrepareHuman ( false , [ 1 , 8 ] [ i mod 2 + 1 ] , skill ) ;
5775: LD_INT 0
5777: PPUSH
5778: LD_INT 1
5780: PUSH
5781: LD_INT 8
5783: PUSH
5784: EMPTY
5785: LIST
5786: LIST
5787: PUSH
5788: LD_VAR 0 1
5792: PUSH
5793: LD_INT 2
5795: MOD
5796: PUSH
5797: LD_INT 1
5799: PLUS
5800: ARRAY
5801: PPUSH
5802: LD_VAR 0 4
5806: PPUSH
5807: CALL_OW 380
// un := CreateHuman ;
5811: LD_ADDR_VAR 0 2
5815: PUSH
5816: CALL_OW 44
5820: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5821: LD_ADDR_VAR 0 3
5825: PUSH
5826: LD_VAR 0 3
5830: PPUSH
5831: LD_INT 2
5833: PUSH
5834: LD_VAR 0 3
5838: PUSH
5839: LD_INT 2
5841: ARRAY
5842: PUSH
5843: LD_INT 1
5845: PLUS
5846: PUSH
5847: EMPTY
5848: LIST
5849: LIST
5850: PPUSH
5851: LD_VAR 0 2
5855: PPUSH
5856: CALL 53831 0 3
5860: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5861: LD_VAR 0 2
5865: PPUSH
5866: LD_INT 13
5868: PPUSH
5869: LD_INT 0
5871: PPUSH
5872: CALL_OW 49
// end ;
5876: GO 5756
5878: POP
5879: POP
// coords := [ [ 67 , 112 ] , [ 85 , 130 ] ] ;
5880: LD_ADDR_VAR 0 5
5884: PUSH
5885: LD_INT 67
5887: PUSH
5888: LD_INT 112
5890: PUSH
5891: EMPTY
5892: LIST
5893: LIST
5894: PUSH
5895: LD_INT 85
5897: PUSH
5898: LD_INT 130
5900: PUSH
5901: EMPTY
5902: LIST
5903: LIST
5904: PUSH
5905: EMPTY
5906: LIST
5907: LIST
5908: ST_TO_ADDR
// MC_PrepareAttack ( 2 , tmp [ 2 ] , coords , flags ) ;
5909: LD_INT 2
5911: PPUSH
5912: LD_VAR 0 3
5916: PUSH
5917: LD_INT 2
5919: ARRAY
5920: PPUSH
5921: LD_VAR 0 5
5925: PPUSH
5926: LD_VAR 0 6
5930: PPUSH
5931: CALL 42453 0 4
// for i = 1 to [ 1 , 2 , 3 , 5 ] [ Difficulty ] do
5935: LD_ADDR_VAR 0 1
5939: PUSH
5940: DOUBLE
5941: LD_INT 1
5943: DEC
5944: ST_TO_ADDR
5945: LD_INT 1
5947: PUSH
5948: LD_INT 2
5950: PUSH
5951: LD_INT 3
5953: PUSH
5954: LD_INT 5
5956: PUSH
5957: EMPTY
5958: LIST
5959: LIST
5960: LIST
5961: LIST
5962: PUSH
5963: LD_OWVAR 67
5967: ARRAY
5968: PUSH
5969: FOR_TO
5970: IFFALSE 6070
// begin uc_side := 2 ;
5972: LD_ADDR_OWVAR 20
5976: PUSH
5977: LD_INT 2
5979: ST_TO_ADDR
// uc_nation := 2 ;
5980: LD_ADDR_OWVAR 21
5984: PUSH
5985: LD_INT 2
5987: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5988: LD_INT 0
5990: PPUSH
5991: LD_INT 17
5993: PPUSH
5994: LD_VAR 0 4
5998: PPUSH
5999: CALL_OW 380
// un := CreateHuman ;
6003: LD_ADDR_VAR 0 2
6007: PUSH
6008: CALL_OW 44
6012: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 3 , tmp [ 3 ] + 1 ] , un ) ;
6013: LD_ADDR_VAR 0 3
6017: PUSH
6018: LD_VAR 0 3
6022: PPUSH
6023: LD_INT 3
6025: PUSH
6026: LD_VAR 0 3
6030: PUSH
6031: LD_INT 3
6033: ARRAY
6034: PUSH
6035: LD_INT 1
6037: PLUS
6038: PUSH
6039: EMPTY
6040: LIST
6041: LIST
6042: PPUSH
6043: LD_VAR 0 2
6047: PPUSH
6048: CALL 53831 0 3
6052: ST_TO_ADDR
// PlaceUnitArea ( un , south_attack_spawn , false ) ;
6053: LD_VAR 0 2
6057: PPUSH
6058: LD_INT 14
6060: PPUSH
6061: LD_INT 0
6063: PPUSH
6064: CALL_OW 49
// end ;
6068: GO 5969
6070: POP
6071: POP
// coords := [ [ 148 , 158 ] , [ 148 , 158 ] ] ;
6072: LD_ADDR_VAR 0 5
6076: PUSH
6077: LD_INT 148
6079: PUSH
6080: LD_INT 158
6082: PUSH
6083: EMPTY
6084: LIST
6085: LIST
6086: PUSH
6087: LD_INT 148
6089: PUSH
6090: LD_INT 158
6092: PUSH
6093: EMPTY
6094: LIST
6095: LIST
6096: PUSH
6097: EMPTY
6098: LIST
6099: LIST
6100: ST_TO_ADDR
// MC_PrepareAttack ( 3 , tmp [ 3 ] , coords , flags ) ;
6101: LD_INT 3
6103: PPUSH
6104: LD_VAR 0 3
6108: PUSH
6109: LD_INT 3
6111: ARRAY
6112: PPUSH
6113: LD_VAR 0 5
6117: PPUSH
6118: LD_VAR 0 6
6122: PPUSH
6123: CALL 42453 0 4
// for i = 1 to [ 2 , 3 , 4 , 5 ] [ Difficulty ] do
6127: LD_ADDR_VAR 0 1
6131: PUSH
6132: DOUBLE
6133: LD_INT 1
6135: DEC
6136: ST_TO_ADDR
6137: LD_INT 2
6139: PUSH
6140: LD_INT 3
6142: PUSH
6143: LD_INT 4
6145: PUSH
6146: LD_INT 5
6148: PUSH
6149: EMPTY
6150: LIST
6151: LIST
6152: LIST
6153: LIST
6154: PUSH
6155: LD_OWVAR 67
6159: ARRAY
6160: PUSH
6161: FOR_TO
6162: IFFALSE 6386
// begin uc_side := 2 ;
6164: LD_ADDR_OWVAR 20
6168: PUSH
6169: LD_INT 2
6171: ST_TO_ADDR
// uc_nation := 2 ;
6172: LD_ADDR_OWVAR 21
6176: PUSH
6177: LD_INT 2
6179: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 3 ) ] , 100 ) ;
6180: LD_INT 14
6182: PPUSH
6183: LD_INT 3
6185: PPUSH
6186: LD_INT 1
6188: PUSH
6189: LD_INT 5
6191: PUSH
6192: EMPTY
6193: LIST
6194: LIST
6195: PUSH
6196: LD_INT 1
6198: PPUSH
6199: LD_INT 2
6201: PPUSH
6202: CALL_OW 12
6206: ARRAY
6207: PPUSH
6208: LD_INT 27
6210: PUSH
6211: LD_INT 26
6213: PUSH
6214: LD_INT 28
6216: PUSH
6217: EMPTY
6218: LIST
6219: LIST
6220: LIST
6221: PUSH
6222: LD_INT 1
6224: PPUSH
6225: LD_INT 3
6227: PPUSH
6228: CALL_OW 12
6232: ARRAY
6233: PPUSH
6234: LD_INT 100
6236: PPUSH
6237: CALL 53709 0 5
// un := CreateVehicle ;
6241: LD_ADDR_VAR 0 2
6245: PUSH
6246: CALL_OW 45
6250: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , un ) ;
6251: LD_ADDR_VAR 0 3
6255: PUSH
6256: LD_VAR 0 3
6260: PPUSH
6261: LD_INT 4
6263: PUSH
6264: LD_VAR 0 3
6268: PUSH
6269: LD_INT 4
6271: ARRAY
6272: PUSH
6273: LD_INT 1
6275: PLUS
6276: PUSH
6277: EMPTY
6278: LIST
6279: LIST
6280: PPUSH
6281: LD_VAR 0 2
6285: PPUSH
6286: CALL 53831 0 3
6290: ST_TO_ADDR
// SetDir ( un , 5 ) ;
6291: LD_VAR 0 2
6295: PPUSH
6296: LD_INT 5
6298: PPUSH
6299: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
6303: LD_VAR 0 2
6307: PPUSH
6308: LD_INT 15
6310: PPUSH
6311: LD_INT 0
6313: PPUSH
6314: CALL_OW 49
// if GetControl ( un ) = control_manual then
6318: LD_VAR 0 2
6322: PPUSH
6323: CALL_OW 263
6327: PUSH
6328: LD_INT 1
6330: EQUAL
6331: IFFALSE 6362
// begin PrepareHuman ( false , 3 , skill ) ;
6333: LD_INT 0
6335: PPUSH
6336: LD_INT 3
6338: PPUSH
6339: LD_VAR 0 4
6343: PPUSH
6344: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
6348: CALL_OW 44
6352: PPUSH
6353: LD_VAR 0 2
6357: PPUSH
6358: CALL_OW 52
// end ; ComMoveXY ( un , 179 , 135 ) ;
6362: LD_VAR 0 2
6366: PPUSH
6367: LD_INT 179
6369: PPUSH
6370: LD_INT 135
6372: PPUSH
6373: CALL_OW 111
// wait ( 0 0$2 ) ;
6377: LD_INT 70
6379: PPUSH
6380: CALL_OW 67
// end ;
6384: GO 6161
6386: POP
6387: POP
// vc_chassis := 15 ;
6388: LD_ADDR_OWVAR 37
6392: PUSH
6393: LD_INT 15
6395: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateVehicle ) ;
6396: LD_ADDR_VAR 0 3
6400: PUSH
6401: LD_VAR 0 3
6405: PPUSH
6406: LD_INT 4
6408: PUSH
6409: LD_VAR 0 3
6413: PUSH
6414: LD_INT 4
6416: ARRAY
6417: PUSH
6418: LD_INT 1
6420: PLUS
6421: PUSH
6422: EMPTY
6423: LIST
6424: LIST
6425: PPUSH
6426: CALL_OW 45
6430: PPUSH
6431: CALL 53831 0 3
6435: ST_TO_ADDR
// PlaceUnitArea ( tmp [ 4 ] [ tmp [ 4 ] ] , east_attack_spawn , false ) ;
6436: LD_VAR 0 3
6440: PUSH
6441: LD_INT 4
6443: ARRAY
6444: PUSH
6445: LD_VAR 0 3
6449: PUSH
6450: LD_INT 4
6452: ARRAY
6453: ARRAY
6454: PPUSH
6455: LD_INT 15
6457: PPUSH
6458: LD_INT 0
6460: PPUSH
6461: CALL_OW 49
// PrepareHuman ( false , class_desert_warior , skill ) ;
6465: LD_INT 0
6467: PPUSH
6468: LD_INT 11
6470: PPUSH
6471: LD_VAR 0 4
6475: PPUSH
6476: CALL_OW 380
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateHuman ) ;
6480: LD_ADDR_VAR 0 3
6484: PUSH
6485: LD_VAR 0 3
6489: PPUSH
6490: LD_INT 4
6492: PUSH
6493: LD_VAR 0 3
6497: PUSH
6498: LD_INT 4
6500: ARRAY
6501: PUSH
6502: LD_INT 1
6504: PLUS
6505: PUSH
6506: EMPTY
6507: LIST
6508: LIST
6509: PPUSH
6510: CALL_OW 44
6514: PPUSH
6515: CALL 53831 0 3
6519: ST_TO_ADDR
// PlaceHumanInUnit ( tmp [ 4 ] [ tmp [ 4 ] ] , tmp [ 4 ] [ tmp [ 4 ] - 1 ] ) ;
6520: LD_VAR 0 3
6524: PUSH
6525: LD_INT 4
6527: ARRAY
6528: PUSH
6529: LD_VAR 0 3
6533: PUSH
6534: LD_INT 4
6536: ARRAY
6537: ARRAY
6538: PPUSH
6539: LD_VAR 0 3
6543: PUSH
6544: LD_INT 4
6546: ARRAY
6547: PUSH
6548: LD_VAR 0 3
6552: PUSH
6553: LD_INT 4
6555: ARRAY
6556: PUSH
6557: LD_INT 1
6559: MINUS
6560: ARRAY
6561: PPUSH
6562: CALL_OW 52
// coords := [ [ 148 , 140 ] ] ;
6566: LD_ADDR_VAR 0 5
6570: PUSH
6571: LD_INT 148
6573: PUSH
6574: LD_INT 140
6576: PUSH
6577: EMPTY
6578: LIST
6579: LIST
6580: PUSH
6581: EMPTY
6582: LIST
6583: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 4 ] , coords , flags ) ;
6584: LD_INT 1
6586: PPUSH
6587: LD_VAR 0 3
6591: PUSH
6592: LD_INT 4
6594: ARRAY
6595: PPUSH
6596: LD_VAR 0 5
6600: PPUSH
6601: LD_VAR 0 6
6605: PPUSH
6606: CALL 42453 0 4
// if gensher_active then
6610: LD_EXP 18
6614: IFFALSE 7020
// begin SayRadio ( Gensher , D10-Diet-1 ) ;
6616: LD_EXP 45
6620: PPUSH
6621: LD_STRING D10-Diet-1
6623: PPUSH
6624: CALL_OW 94
// for i = 1 to 2 do
6628: LD_ADDR_VAR 0 1
6632: PUSH
6633: DOUBLE
6634: LD_INT 1
6636: DEC
6637: ST_TO_ADDR
6638: LD_INT 2
6640: PUSH
6641: FOR_TO
6642: IFFALSE 6780
// begin uc_side := 2 ;
6644: LD_ADDR_OWVAR 20
6648: PUSH
6649: LD_INT 2
6651: ST_TO_ADDR
// uc_nation := 2 ;
6652: LD_ADDR_OWVAR 21
6656: PUSH
6657: LD_INT 2
6659: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
6660: LD_INT 13
6662: PPUSH
6663: LD_INT 3
6665: PPUSH
6666: LD_INT 5
6668: PPUSH
6669: LD_INT 29
6671: PPUSH
6672: LD_INT 100
6674: PPUSH
6675: CALL 53709 0 5
// un := CreateVehicle ;
6679: LD_ADDR_VAR 0 2
6683: PUSH
6684: CALL_OW 45
6688: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6689: LD_ADDR_VAR 0 3
6693: PUSH
6694: LD_VAR 0 3
6698: PPUSH
6699: LD_INT 5
6701: PUSH
6702: LD_VAR 0 3
6706: PUSH
6707: LD_INT 5
6709: ARRAY
6710: PUSH
6711: LD_INT 1
6713: PLUS
6714: PUSH
6715: EMPTY
6716: LIST
6717: LIST
6718: PPUSH
6719: LD_VAR 0 2
6723: PPUSH
6724: CALL 53831 0 3
6728: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6729: LD_VAR 0 2
6733: PPUSH
6734: LD_INT 0
6736: PPUSH
6737: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6741: LD_VAR 0 2
6745: PPUSH
6746: LD_INT 23
6748: PPUSH
6749: LD_INT 0
6751: PPUSH
6752: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6756: LD_VAR 0 2
6760: PPUSH
6761: LD_INT 85
6763: PPUSH
6764: LD_INT 152
6766: PPUSH
6767: CALL_OW 111
// wait ( 0 0$2 ) ;
6771: LD_INT 70
6773: PPUSH
6774: CALL_OW 67
// end ;
6778: GO 6641
6780: POP
6781: POP
// for i = 1 to [ 2 , 3 , 3 , 4 ] [ Difficulty ] do
6782: LD_ADDR_VAR 0 1
6786: PUSH
6787: DOUBLE
6788: LD_INT 1
6790: DEC
6791: ST_TO_ADDR
6792: LD_INT 2
6794: PUSH
6795: LD_INT 3
6797: PUSH
6798: LD_INT 3
6800: PUSH
6801: LD_INT 4
6803: PUSH
6804: EMPTY
6805: LIST
6806: LIST
6807: LIST
6808: LIST
6809: PUSH
6810: LD_OWVAR 67
6814: ARRAY
6815: PUSH
6816: FOR_TO
6817: IFFALSE 6974
// begin uc_side := 2 ;
6819: LD_ADDR_OWVAR 20
6823: PUSH
6824: LD_INT 2
6826: ST_TO_ADDR
// uc_nation := 2 ;
6827: LD_ADDR_OWVAR 21
6831: PUSH
6832: LD_INT 2
6834: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
6835: LD_INT 14
6837: PPUSH
6838: LD_INT 3
6840: PPUSH
6841: LD_INT 5
6843: PPUSH
6844: LD_INT 27
6846: PUSH
6847: LD_INT 28
6849: PUSH
6850: EMPTY
6851: LIST
6852: LIST
6853: PUSH
6854: LD_INT 1
6856: PPUSH
6857: LD_INT 2
6859: PPUSH
6860: CALL_OW 12
6864: ARRAY
6865: PPUSH
6866: LD_INT 100
6868: PPUSH
6869: CALL 53709 0 5
// un := CreateVehicle ;
6873: LD_ADDR_VAR 0 2
6877: PUSH
6878: CALL_OW 45
6882: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6883: LD_ADDR_VAR 0 3
6887: PUSH
6888: LD_VAR 0 3
6892: PPUSH
6893: LD_INT 5
6895: PUSH
6896: LD_VAR 0 3
6900: PUSH
6901: LD_INT 5
6903: ARRAY
6904: PUSH
6905: LD_INT 1
6907: PLUS
6908: PUSH
6909: EMPTY
6910: LIST
6911: LIST
6912: PPUSH
6913: LD_VAR 0 2
6917: PPUSH
6918: CALL 53831 0 3
6922: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6923: LD_VAR 0 2
6927: PPUSH
6928: LD_INT 0
6930: PPUSH
6931: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6935: LD_VAR 0 2
6939: PPUSH
6940: LD_INT 23
6942: PPUSH
6943: LD_INT 0
6945: PPUSH
6946: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6950: LD_VAR 0 2
6954: PPUSH
6955: LD_INT 85
6957: PPUSH
6958: LD_INT 152
6960: PPUSH
6961: CALL_OW 111
// wait ( 0 0$2 ) ;
6965: LD_INT 70
6967: PPUSH
6968: CALL_OW 67
// end ;
6972: GO 6816
6974: POP
6975: POP
// coords := [ [ 97 , 143 ] ] ;
6976: LD_ADDR_VAR 0 5
6980: PUSH
6981: LD_INT 97
6983: PUSH
6984: LD_INT 143
6986: PUSH
6987: EMPTY
6988: LIST
6989: LIST
6990: PUSH
6991: EMPTY
6992: LIST
6993: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 5 ] , coords , flags ) ;
6994: LD_INT 1
6996: PPUSH
6997: LD_VAR 0 3
7001: PUSH
7002: LD_INT 5
7004: ARRAY
7005: PPUSH
7006: LD_VAR 0 5
7010: PPUSH
7011: LD_VAR 0 6
7015: PPUSH
7016: CALL 42453 0 4
// end ; end ;
7020: PPOPN 7
7022: END
// every 10 10$0 + 20 20$0 do var i , tmp , tmp2 , coords , w , list ;
7023: GO 7025
7025: DISABLE
7026: LD_INT 0
7028: PPUSH
7029: PPUSH
7030: PPUSH
7031: PPUSH
7032: PPUSH
7033: PPUSH
// begin enable ;
7034: ENABLE
// tmp := [ ] ;
7035: LD_ADDR_VAR 0 2
7039: PUSH
7040: EMPTY
7041: ST_TO_ADDR
// w := rand ( 1 , 3 ) ;
7042: LD_ADDR_VAR 0 5
7046: PUSH
7047: LD_INT 1
7049: PPUSH
7050: LD_INT 3
7052: PPUSH
7053: CALL_OW 12
7057: ST_TO_ADDR
// if w = 3 then
7058: LD_VAR 0 5
7062: PUSH
7063: LD_INT 3
7065: EQUAL
7066: IFFALSE 7153
// list := [ [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] else
7068: LD_ADDR_VAR 0 6
7072: PUSH
7073: LD_INT 11
7075: PUSH
7076: LD_INT 1
7078: PUSH
7079: LD_INT 2
7081: PUSH
7082: LD_INT 24
7084: PUSH
7085: EMPTY
7086: LIST
7087: LIST
7088: LIST
7089: LIST
7090: PUSH
7091: LD_INT 11
7093: PUSH
7094: LD_INT 1
7096: PUSH
7097: LD_INT 2
7099: PUSH
7100: LD_INT 24
7102: PUSH
7103: EMPTY
7104: LIST
7105: LIST
7106: LIST
7107: LIST
7108: PUSH
7109: LD_INT 11
7111: PUSH
7112: LD_INT 1
7114: PUSH
7115: LD_INT 2
7117: PUSH
7118: LD_INT 24
7120: PUSH
7121: EMPTY
7122: LIST
7123: LIST
7124: LIST
7125: LIST
7126: PUSH
7127: LD_INT 11
7129: PUSH
7130: LD_INT 1
7132: PUSH
7133: LD_INT 2
7135: PUSH
7136: LD_INT 24
7138: PUSH
7139: EMPTY
7140: LIST
7141: LIST
7142: LIST
7143: LIST
7144: PUSH
7145: EMPTY
7146: LIST
7147: LIST
7148: LIST
7149: LIST
7150: ST_TO_ADDR
7151: GO 7236
// list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ;
7153: LD_ADDR_VAR 0 6
7157: PUSH
7158: LD_INT 14
7160: PUSH
7161: LD_INT 1
7163: PUSH
7164: LD_INT 2
7166: PUSH
7167: LD_INT 28
7169: PUSH
7170: EMPTY
7171: LIST
7172: LIST
7173: LIST
7174: LIST
7175: PUSH
7176: LD_INT 14
7178: PUSH
7179: LD_INT 1
7181: PUSH
7182: LD_INT 2
7184: PUSH
7185: LD_INT 25
7187: PUSH
7188: EMPTY
7189: LIST
7190: LIST
7191: LIST
7192: LIST
7193: PUSH
7194: LD_INT 14
7196: PUSH
7197: LD_INT 1
7199: PUSH
7200: LD_INT 2
7202: PUSH
7203: LD_INT 28
7205: PUSH
7206: EMPTY
7207: LIST
7208: LIST
7209: LIST
7210: LIST
7211: PUSH
7212: LD_INT 14
7214: PUSH
7215: LD_INT 1
7217: PUSH
7218: LD_INT 2
7220: PUSH
7221: LD_INT 29
7223: PUSH
7224: EMPTY
7225: LIST
7226: LIST
7227: LIST
7228: LIST
7229: PUSH
7230: EMPTY
7231: LIST
7232: LIST
7233: LIST
7234: LIST
7235: ST_TO_ADDR
// if w < 3 then
7236: LD_VAR 0 5
7240: PUSH
7241: LD_INT 3
7243: LESS
7244: IFFALSE 7320
// list := ReplaceIn ( list , [ 1 , list [ i ] + 1 ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gatling_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] ] ) ;
7246: LD_ADDR_VAR 0 6
7250: PUSH
7251: LD_VAR 0 6
7255: PPUSH
7256: LD_INT 1
7258: PUSH
7259: LD_VAR 0 6
7263: PUSH
7264: LD_VAR 0 1
7268: ARRAY
7269: PUSH
7270: LD_INT 1
7272: PLUS
7273: PUSH
7274: EMPTY
7275: LIST
7276: LIST
7277: PPUSH
7278: LD_INT 14
7280: PUSH
7281: LD_INT 1
7283: PUSH
7284: LD_INT 2
7286: PUSH
7287: LD_INT 25
7289: PUSH
7290: LD_INT 28
7292: PUSH
7293: EMPTY
7294: LIST
7295: LIST
7296: PUSH
7297: LD_INT 1
7299: PPUSH
7300: LD_INT 2
7302: PPUSH
7303: CALL_OW 12
7307: ARRAY
7308: PUSH
7309: EMPTY
7310: LIST
7311: LIST
7312: LIST
7313: LIST
7314: PPUSH
7315: CALL 53831 0 3
7319: ST_TO_ADDR
// MC_SetProduceList ( 1 , list ) ;
7320: LD_INT 1
7322: PPUSH
7323: LD_VAR 0 6
7327: PPUSH
7328: CALL 42220 0 2
// if GetSide ( ar_dep_w ) = 2 then
7332: LD_INT 45
7334: PPUSH
7335: CALL_OW 255
7339: PUSH
7340: LD_INT 2
7342: EQUAL
7343: IFFALSE 7428
// begin list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] ] ;
7345: LD_ADDR_VAR 0 6
7349: PUSH
7350: LD_INT 14
7352: PUSH
7353: LD_INT 1
7355: PUSH
7356: LD_INT 2
7358: PUSH
7359: LD_INT 28
7361: PUSH
7362: EMPTY
7363: LIST
7364: LIST
7365: LIST
7366: LIST
7367: PUSH
7368: LD_INT 14
7370: PUSH
7371: LD_INT 1
7373: PUSH
7374: LD_INT 2
7376: PUSH
7377: LD_INT 27
7379: PUSH
7380: EMPTY
7381: LIST
7382: LIST
7383: LIST
7384: LIST
7385: PUSH
7386: LD_INT 14
7388: PUSH
7389: LD_INT 1
7391: PUSH
7392: LD_INT 2
7394: PUSH
7395: LD_INT 27
7397: PUSH
7398: EMPTY
7399: LIST
7400: LIST
7401: LIST
7402: LIST
7403: PUSH
7404: EMPTY
7405: LIST
7406: LIST
7407: LIST
7408: ST_TO_ADDR
// MC_SetProduceList ( 2 , list ) ;
7409: LD_INT 2
7411: PPUSH
7412: LD_VAR 0 6
7416: PPUSH
7417: CALL 42220 0 2
// wait ( 0 0$20 ) ;
7421: LD_INT 700
7423: PPUSH
7424: CALL_OW 67
// end ; repeat wait ( 0 0$1 ) ;
7428: LD_INT 35
7430: PPUSH
7431: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ] ) >= 4 ;
7435: LD_EXP 69
7439: PUSH
7440: LD_INT 1
7442: ARRAY
7443: PPUSH
7444: LD_INT 3
7446: PUSH
7447: LD_INT 2
7449: PUSH
7450: LD_INT 34
7452: PUSH
7453: LD_INT 32
7455: PUSH
7456: EMPTY
7457: LIST
7458: LIST
7459: PUSH
7460: LD_INT 34
7462: PUSH
7463: LD_INT 88
7465: PUSH
7466: EMPTY
7467: LIST
7468: LIST
7469: PUSH
7470: EMPTY
7471: LIST
7472: LIST
7473: LIST
7474: PUSH
7475: EMPTY
7476: LIST
7477: LIST
7478: PPUSH
7479: CALL_OW 72
7483: PUSH
7484: LD_INT 4
7486: GREATEREQUAL
7487: IFFALSE 7428
// wait ( 0 0$10 ) ;
7489: LD_INT 350
7491: PPUSH
7492: CALL_OW 67
// tmp := UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ] ) ;
7496: LD_ADDR_VAR 0 2
7500: PUSH
7501: LD_EXP 69
7505: PUSH
7506: LD_INT 1
7508: ARRAY
7509: PPUSH
7510: LD_INT 3
7512: PUSH
7513: LD_INT 2
7515: PUSH
7516: LD_INT 34
7518: PUSH
7519: LD_INT 32
7521: PUSH
7522: EMPTY
7523: LIST
7524: LIST
7525: PUSH
7526: LD_INT 34
7528: PUSH
7529: LD_INT 88
7531: PUSH
7532: EMPTY
7533: LIST
7534: LIST
7535: PUSH
7536: EMPTY
7537: LIST
7538: LIST
7539: LIST
7540: PUSH
7541: EMPTY
7542: LIST
7543: LIST
7544: PPUSH
7545: CALL_OW 72
7549: ST_TO_ADDR
// tmp2 := UnitFilter ( mc_vehicles [ 2 ] , [ f_not , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ] ) ;
7550: LD_ADDR_VAR 0 3
7554: PUSH
7555: LD_EXP 69
7559: PUSH
7560: LD_INT 2
7562: ARRAY
7563: PPUSH
7564: LD_INT 3
7566: PUSH
7567: LD_INT 2
7569: PUSH
7570: LD_INT 34
7572: PUSH
7573: LD_INT 32
7575: PUSH
7576: EMPTY
7577: LIST
7578: LIST
7579: PUSH
7580: LD_INT 34
7582: PUSH
7583: LD_INT 88
7585: PUSH
7586: EMPTY
7587: LIST
7588: LIST
7589: PUSH
7590: EMPTY
7591: LIST
7592: LIST
7593: LIST
7594: PUSH
7595: EMPTY
7596: LIST
7597: LIST
7598: PPUSH
7599: CALL_OW 72
7603: ST_TO_ADDR
// if tmp2 then
7604: LD_VAR 0 3
7608: IFFALSE 7626
// tmp := tmp union tmp2 ;
7610: LD_ADDR_VAR 0 2
7614: PUSH
7615: LD_VAR 0 2
7619: PUSH
7620: LD_VAR 0 3
7624: UNION
7625: ST_TO_ADDR
// if Count ( tmp2 ) or Prob ( 50 ) then
7626: LD_VAR 0 3
7630: PPUSH
7631: CALL 50796 0 1
7635: PUSH
7636: LD_INT 50
7638: PPUSH
7639: CALL_OW 13
7643: OR
7644: IFFALSE 7677
// coords := [ [ 48 , 33 ] , [ 71 , 88 ] ] else
7646: LD_ADDR_VAR 0 4
7650: PUSH
7651: LD_INT 48
7653: PUSH
7654: LD_INT 33
7656: PUSH
7657: EMPTY
7658: LIST
7659: LIST
7660: PUSH
7661: LD_INT 71
7663: PUSH
7664: LD_INT 88
7666: PUSH
7667: EMPTY
7668: LIST
7669: LIST
7670: PUSH
7671: EMPTY
7672: LIST
7673: LIST
7674: ST_TO_ADDR
7675: GO 7706
// coords := [ [ 128 , 94 ] , [ 180 , 135 ] ] ;
7677: LD_ADDR_VAR 0 4
7681: PUSH
7682: LD_INT 128
7684: PUSH
7685: LD_INT 94
7687: PUSH
7688: EMPTY
7689: LIST
7690: LIST
7691: PUSH
7692: LD_INT 180
7694: PUSH
7695: LD_INT 135
7697: PUSH
7698: EMPTY
7699: LIST
7700: LIST
7701: PUSH
7702: EMPTY
7703: LIST
7704: LIST
7705: ST_TO_ADDR
// if w = 3 then
7706: LD_VAR 0 5
7710: PUSH
7711: LD_INT 3
7713: EQUAL
7714: IFFALSE 7745
// coords := [ [ 91 , 58 ] , [ 117 , 107 ] ] ;
7716: LD_ADDR_VAR 0 4
7720: PUSH
7721: LD_INT 91
7723: PUSH
7724: LD_INT 58
7726: PUSH
7727: EMPTY
7728: LIST
7729: LIST
7730: PUSH
7731: LD_INT 117
7733: PUSH
7734: LD_INT 107
7736: PUSH
7737: EMPTY
7738: LIST
7739: LIST
7740: PUSH
7741: EMPTY
7742: LIST
7743: LIST
7744: ST_TO_ADDR
// ComAgressiveMove ( tmp , coords [ 1 ] , coords [ 2 ] ) ;
7745: LD_VAR 0 2
7749: PPUSH
7750: LD_VAR 0 4
7754: PUSH
7755: LD_INT 1
7757: ARRAY
7758: PPUSH
7759: LD_VAR 0 4
7763: PUSH
7764: LD_INT 2
7766: ARRAY
7767: PPUSH
7768: CALL_OW 114
// repeat wait ( 0 0$1 ) ;
7772: LD_INT 35
7774: PPUSH
7775: CALL_OW 67
// until UnitFilter ( tmp , [ f_hastask ] ) = 0 ;
7779: LD_VAR 0 2
7783: PPUSH
7784: LD_INT 60
7786: PUSH
7787: EMPTY
7788: LIST
7789: PPUSH
7790: CALL_OW 72
7794: PUSH
7795: LD_INT 0
7797: EQUAL
7798: IFFALSE 7772
// repeat wait ( 0 0$2 ) ;
7800: LD_INT 70
7802: PPUSH
7803: CALL_OW 67
// for i in tmp do
7807: LD_ADDR_VAR 0 1
7811: PUSH
7812: LD_VAR 0 2
7816: PUSH
7817: FOR_IN
7818: IFFALSE 7907
// if GetChassis ( i ) = ar_hovercraft then
7820: LD_VAR 0 1
7824: PPUSH
7825: CALL_OW 265
7829: PUSH
7830: LD_INT 11
7832: EQUAL
7833: IFFALSE 7871
// AttackHovercraft ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) else
7835: LD_VAR 0 1
7839: PPUSH
7840: LD_INT 22
7842: PUSH
7843: LD_INT 1
7845: PUSH
7846: EMPTY
7847: LIST
7848: LIST
7849: PPUSH
7850: CALL_OW 69
7854: PPUSH
7855: LD_VAR 0 1
7859: PPUSH
7860: CALL_OW 74
7864: PPUSH
7865: CALL 81777 0 2
7869: GO 7905
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
7871: LD_VAR 0 1
7875: PPUSH
7876: LD_INT 22
7878: PUSH
7879: LD_INT 1
7881: PUSH
7882: EMPTY
7883: LIST
7884: LIST
7885: PPUSH
7886: CALL_OW 69
7890: PPUSH
7891: LD_VAR 0 1
7895: PPUSH
7896: CALL_OW 74
7900: PPUSH
7901: CALL_OW 115
7905: GO 7817
7907: POP
7908: POP
// until not tmp ;
7909: LD_VAR 0 2
7913: NOT
7914: IFFALSE 7800
// end ;
7916: PPOPN 6
7918: END
// every 28 28$00 trigger ar_dep_e do var i , tmp , un , x ;
7919: LD_INT 204
7921: IFFALSE 8387
7923: GO 7925
7925: DISABLE
7926: LD_INT 0
7928: PPUSH
7929: PPUSH
7930: PPUSH
7931: PPUSH
// begin enable ;
7932: ENABLE
// wait ( rand ( 0 0$1 , 0 0$34 ) ) ;
7933: LD_INT 35
7935: PPUSH
7936: LD_INT 1190
7938: PPUSH
7939: CALL_OW 12
7943: PPUSH
7944: CALL_OW 67
// tmp := [ ] ;
7948: LD_ADDR_VAR 0 2
7952: PUSH
7953: EMPTY
7954: ST_TO_ADDR
// uc_side := 8 ;
7955: LD_ADDR_OWVAR 20
7959: PUSH
7960: LD_INT 8
7962: ST_TO_ADDR
// uc_nation := 2 ;
7963: LD_ADDR_OWVAR 21
7967: PUSH
7968: LD_INT 2
7970: ST_TO_ADDR
// InitHc ;
7971: CALL_OW 19
// for i = 1 to 3 do
7975: LD_ADDR_VAR 0 1
7979: PUSH
7980: DOUBLE
7981: LD_INT 1
7983: DEC
7984: ST_TO_ADDR
7985: LD_INT 3
7987: PUSH
7988: FOR_TO
7989: IFFALSE 8116
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
7991: LD_INT 13
7993: PUSH
7994: LD_INT 14
7996: PUSH
7997: EMPTY
7998: LIST
7999: LIST
8000: PUSH
8001: LD_INT 1
8003: PPUSH
8004: LD_INT 2
8006: PPUSH
8007: CALL_OW 12
8011: ARRAY
8012: PPUSH
8013: LD_INT 3
8015: PPUSH
8016: LD_INT 5
8018: PPUSH
8019: LD_INT 27
8021: PUSH
8022: LD_INT 28
8024: PUSH
8025: EMPTY
8026: LIST
8027: LIST
8028: PUSH
8029: LD_INT 1
8031: PPUSH
8032: LD_INT 2
8034: PPUSH
8035: CALL_OW 12
8039: ARRAY
8040: PPUSH
8041: LD_INT 100
8043: PPUSH
8044: CALL 53709 0 5
// un := CreateVehicle ;
8048: LD_ADDR_VAR 0 3
8052: PUSH
8053: CALL_OW 45
8057: ST_TO_ADDR
// SetDir ( un , 4 ) ;
8058: LD_VAR 0 3
8062: PPUSH
8063: LD_INT 4
8065: PPUSH
8066: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
8070: LD_VAR 0 3
8074: PPUSH
8075: LD_INT 15
8077: PPUSH
8078: LD_INT 0
8080: PPUSH
8081: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8085: LD_ADDR_VAR 0 2
8089: PUSH
8090: LD_VAR 0 2
8094: PPUSH
8095: LD_VAR 0 2
8099: PUSH
8100: LD_INT 1
8102: PLUS
8103: PPUSH
8104: LD_VAR 0 3
8108: PPUSH
8109: CALL_OW 1
8113: ST_TO_ADDR
// end ;
8114: GO 7988
8116: POP
8117: POP
// for i = 1 to 4 do
8118: LD_ADDR_VAR 0 1
8122: PUSH
8123: DOUBLE
8124: LD_INT 1
8126: DEC
8127: ST_TO_ADDR
8128: LD_INT 4
8130: PUSH
8131: FOR_TO
8132: IFFALSE 8203
// begin PrepareHuman ( false , 1 , 6 ) ;
8134: LD_INT 0
8136: PPUSH
8137: LD_INT 1
8139: PPUSH
8140: LD_INT 6
8142: PPUSH
8143: CALL_OW 380
// un := CreateHuman ;
8147: LD_ADDR_VAR 0 3
8151: PUSH
8152: CALL_OW 44
8156: ST_TO_ADDR
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
8157: LD_VAR 0 3
8161: PPUSH
8162: LD_INT 15
8164: PPUSH
8165: LD_INT 0
8167: PPUSH
8168: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8172: LD_ADDR_VAR 0 2
8176: PUSH
8177: LD_VAR 0 2
8181: PPUSH
8182: LD_VAR 0 2
8186: PUSH
8187: LD_INT 1
8189: PLUS
8190: PPUSH
8191: LD_VAR 0 3
8195: PPUSH
8196: CALL_OW 1
8200: ST_TO_ADDR
// end ;
8201: GO 8131
8203: POP
8204: POP
// wait ( 0 0$3 ) ;
8205: LD_INT 105
8207: PPUSH
8208: CALL_OW 67
// for i in tmp do
8212: LD_ADDR_VAR 0 1
8216: PUSH
8217: LD_VAR 0 2
8221: PUSH
8222: FOR_IN
8223: IFFALSE 8291
// if GetClass ( i ) = 1 or GetType ( i ) = unit_vehicle then
8225: LD_VAR 0 1
8229: PPUSH
8230: CALL_OW 257
8234: PUSH
8235: LD_INT 1
8237: EQUAL
8238: PUSH
8239: LD_VAR 0 1
8243: PPUSH
8244: CALL_OW 247
8248: PUSH
8249: LD_INT 2
8251: EQUAL
8252: OR
8253: IFFALSE 8289
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
8255: LD_VAR 0 1
8259: PPUSH
8260: LD_INT 81
8262: PUSH
8263: LD_INT 8
8265: PUSH
8266: EMPTY
8267: LIST
8268: LIST
8269: PPUSH
8270: CALL_OW 69
8274: PPUSH
8275: LD_VAR 0 1
8279: PPUSH
8280: CALL_OW 74
8284: PPUSH
8285: CALL_OW 115
8289: GO 8222
8291: POP
8292: POP
// repeat AddComAgressiveMove ( tmp , 210 , 178 ) ;
8293: LD_VAR 0 2
8297: PPUSH
8298: LD_INT 210
8300: PPUSH
8301: LD_INT 178
8303: PPUSH
8304: CALL_OW 174
// x := FilterUnitsInArea ( escape_area , [ f_side , 8 ] ) ;
8308: LD_ADDR_VAR 0 4
8312: PUSH
8313: LD_INT 10
8315: PPUSH
8316: LD_INT 22
8318: PUSH
8319: LD_INT 8
8321: PUSH
8322: EMPTY
8323: LIST
8324: LIST
8325: PPUSH
8326: CALL_OW 70
8330: ST_TO_ADDR
// if x then
8331: LD_VAR 0 4
8335: IFFALSE 8363
// for i in x do
8337: LD_ADDR_VAR 0 1
8341: PUSH
8342: LD_VAR 0 4
8346: PUSH
8347: FOR_IN
8348: IFFALSE 8361
// RemoveUnit ( i ) ;
8350: LD_VAR 0 1
8354: PPUSH
8355: CALL_OW 64
8359: GO 8347
8361: POP
8362: POP
// wait ( 0 0$1 ) ;
8363: LD_INT 35
8365: PPUSH
8366: CALL_OW 67
// until not FilterAllUnits ( [ f_side , 8 ] ) ;
8370: LD_INT 22
8372: PUSH
8373: LD_INT 8
8375: PUSH
8376: EMPTY
8377: LIST
8378: LIST
8379: PPUSH
8380: CALL_OW 69
8384: NOT
8385: IFFALSE 8293
// end ;
8387: PPOPN 4
8389: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
8390: LD_INT 22
8392: PUSH
8393: LD_INT 2
8395: PUSH
8396: EMPTY
8397: LIST
8398: LIST
8399: PUSH
8400: LD_INT 34
8402: PUSH
8403: LD_INT 31
8405: PUSH
8406: EMPTY
8407: LIST
8408: LIST
8409: PUSH
8410: LD_INT 3
8412: PUSH
8413: LD_INT 24
8415: PUSH
8416: LD_INT 1000
8418: PUSH
8419: EMPTY
8420: LIST
8421: LIST
8422: PUSH
8423: EMPTY
8424: LIST
8425: LIST
8426: PUSH
8427: EMPTY
8428: LIST
8429: LIST
8430: LIST
8431: PPUSH
8432: CALL_OW 69
8436: IFFALSE 8539
8438: GO 8440
8440: DISABLE
// begin if IsOk ( ar_dep_w ) and GetSide ( ar_dep_w ) then
8441: LD_INT 45
8443: PPUSH
8444: CALL_OW 302
8448: PUSH
8449: LD_INT 45
8451: PPUSH
8452: CALL_OW 255
8456: AND
8457: IFFALSE 8500
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 18 , 8 ) else
8459: LD_INT 22
8461: PUSH
8462: LD_INT 2
8464: PUSH
8465: EMPTY
8466: LIST
8467: LIST
8468: PUSH
8469: LD_INT 34
8471: PUSH
8472: LD_INT 31
8474: PUSH
8475: EMPTY
8476: LIST
8477: LIST
8478: PUSH
8479: EMPTY
8480: LIST
8481: LIST
8482: PPUSH
8483: CALL_OW 69
8487: PPUSH
8488: LD_INT 18
8490: PPUSH
8491: LD_INT 8
8493: PPUSH
8494: CALL_OW 111
8498: GO 8539
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 106 , 14 ) ;
8500: LD_INT 22
8502: PUSH
8503: LD_INT 2
8505: PUSH
8506: EMPTY
8507: LIST
8508: LIST
8509: PUSH
8510: LD_INT 34
8512: PUSH
8513: LD_INT 31
8515: PUSH
8516: EMPTY
8517: LIST
8518: LIST
8519: PUSH
8520: EMPTY
8521: LIST
8522: LIST
8523: PPUSH
8524: CALL_OW 69
8528: PPUSH
8529: LD_INT 106
8531: PPUSH
8532: LD_INT 14
8534: PPUSH
8535: CALL_OW 111
// end ; end_of_file
8539: END
// export function Action ; var tmp , p , radar , sols , i ; begin
8540: LD_INT 0
8542: PPUSH
8543: PPUSH
8544: PPUSH
8545: PPUSH
8546: PPUSH
8547: PPUSH
// InGameOn ;
8548: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
8552: LD_EXP 21
8556: PPUSH
8557: CALL_OW 87
// SetAttitude ( 2 , 1 , att_friend , true ) ;
8561: LD_INT 2
8563: PPUSH
8564: LD_INT 1
8566: PPUSH
8567: LD_INT 1
8569: PPUSH
8570: LD_INT 1
8572: PPUSH
8573: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) ;
8577: LD_ADDR_VAR 0 2
8581: PUSH
8582: LD_INT 22
8584: PUSH
8585: LD_INT 1
8587: PUSH
8588: EMPTY
8589: LIST
8590: LIST
8591: PUSH
8592: LD_INT 25
8594: PUSH
8595: LD_INT 1
8597: PUSH
8598: EMPTY
8599: LIST
8600: LIST
8601: PUSH
8602: EMPTY
8603: LIST
8604: LIST
8605: PPUSH
8606: CALL_OW 69
8610: ST_TO_ADDR
// radar := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_radar ] ] ) [ 1 ] ;
8611: LD_ADDR_VAR 0 4
8615: PUSH
8616: LD_INT 22
8618: PUSH
8619: LD_INT 1
8621: PUSH
8622: EMPTY
8623: LIST
8624: LIST
8625: PUSH
8626: LD_INT 34
8628: PUSH
8629: LD_INT 11
8631: PUSH
8632: EMPTY
8633: LIST
8634: LIST
8635: PUSH
8636: EMPTY
8637: LIST
8638: LIST
8639: PPUSH
8640: CALL_OW 69
8644: PUSH
8645: LD_INT 1
8647: ARRAY
8648: ST_TO_ADDR
// for i = 1 to tmp do
8649: LD_ADDR_VAR 0 6
8653: PUSH
8654: DOUBLE
8655: LD_INT 1
8657: DEC
8658: ST_TO_ADDR
8659: LD_VAR 0 2
8663: PUSH
8664: FOR_TO
8665: IFFALSE 8712
// begin if i = 5 then
8667: LD_VAR 0 6
8671: PUSH
8672: LD_INT 5
8674: EQUAL
8675: IFFALSE 8679
// break ;
8677: GO 8712
// sols := Replace ( sols , i , tmp [ i ] ) ;
8679: LD_ADDR_VAR 0 5
8683: PUSH
8684: LD_VAR 0 5
8688: PPUSH
8689: LD_VAR 0 6
8693: PPUSH
8694: LD_VAR 0 2
8698: PUSH
8699: LD_VAR 0 6
8703: ARRAY
8704: PPUSH
8705: CALL_OW 1
8709: ST_TO_ADDR
// end ;
8710: GO 8664
8712: POP
8713: POP
// tmp := ar_force_tmp ;
8714: LD_ADDR_VAR 0 2
8718: PUSH
8719: LD_EXP 40
8723: ST_TO_ADDR
// PlaceUnitXY ( tmp [ 1 ] , 108 , 139 , false ) ;
8724: LD_VAR 0 2
8728: PUSH
8729: LD_INT 1
8731: ARRAY
8732: PPUSH
8733: LD_INT 108
8735: PPUSH
8736: LD_INT 139
8738: PPUSH
8739: LD_INT 0
8741: PPUSH
8742: CALL_OW 48
// ComTurnUnit ( tmp [ 1 ] , JMM ) ;
8746: LD_VAR 0 2
8750: PUSH
8751: LD_INT 1
8753: ARRAY
8754: PPUSH
8755: LD_EXP 21
8759: PPUSH
8760: CALL_OW 119
// PlaceUnitXY ( tmp [ 2 ] , 114 , 132 , false ) ;
8764: LD_VAR 0 2
8768: PUSH
8769: LD_INT 2
8771: ARRAY
8772: PPUSH
8773: LD_INT 114
8775: PPUSH
8776: LD_INT 132
8778: PPUSH
8779: LD_INT 0
8781: PPUSH
8782: CALL_OW 48
// PlaceUnitXY ( tmp [ 3 ] , 115 , 132 , false ) ;
8786: LD_VAR 0 2
8790: PUSH
8791: LD_INT 3
8793: ARRAY
8794: PPUSH
8795: LD_INT 115
8797: PPUSH
8798: LD_INT 132
8800: PPUSH
8801: LD_INT 0
8803: PPUSH
8804: CALL_OW 48
// ComHold ( [ tmp [ 2 ] , tmp [ 3 ] ] ) ;
8808: LD_VAR 0 2
8812: PUSH
8813: LD_INT 2
8815: ARRAY
8816: PUSH
8817: LD_VAR 0 2
8821: PUSH
8822: LD_INT 3
8824: ARRAY
8825: PUSH
8826: EMPTY
8827: LIST
8828: LIST
8829: PPUSH
8830: CALL_OW 140
// ComMoveXY ( radar , 83 , 123 ) ;
8834: LD_VAR 0 4
8838: PPUSH
8839: LD_INT 83
8841: PPUSH
8842: LD_INT 123
8844: PPUSH
8845: CALL_OW 111
// Wait ( 0 0$01 ) ;
8849: LD_INT 35
8851: PPUSH
8852: CALL_OW 67
// CenterOnXY ( 90 , 144 ) ;
8856: LD_INT 90
8858: PPUSH
8859: LD_INT 144
8861: PPUSH
8862: CALL_OW 84
// ComMoveXY ( sols , 88 , 129 ) ;
8866: LD_VAR 0 5
8870: PPUSH
8871: LD_INT 88
8873: PPUSH
8874: LD_INT 129
8876: PPUSH
8877: CALL_OW 111
// p := [ [ 92 , 131 ] , [ 88 , 127 ] , [ 91 , 132 ] , [ 92 , 134 ] ] ;
8881: LD_ADDR_VAR 0 3
8885: PUSH
8886: LD_INT 92
8888: PUSH
8889: LD_INT 131
8891: PUSH
8892: EMPTY
8893: LIST
8894: LIST
8895: PUSH
8896: LD_INT 88
8898: PUSH
8899: LD_INT 127
8901: PUSH
8902: EMPTY
8903: LIST
8904: LIST
8905: PUSH
8906: LD_INT 91
8908: PUSH
8909: LD_INT 132
8911: PUSH
8912: EMPTY
8913: LIST
8914: LIST
8915: PUSH
8916: LD_INT 92
8918: PUSH
8919: LD_INT 134
8921: PUSH
8922: EMPTY
8923: LIST
8924: LIST
8925: PUSH
8926: EMPTY
8927: LIST
8928: LIST
8929: LIST
8930: LIST
8931: ST_TO_ADDR
// for i = 1 to sols do
8932: LD_ADDR_VAR 0 6
8936: PUSH
8937: DOUBLE
8938: LD_INT 1
8940: DEC
8941: ST_TO_ADDR
8942: LD_VAR 0 5
8946: PUSH
8947: FOR_TO
8948: IFFALSE 9021
// begin AddComMoveXY ( sols [ i ] , p [ i ] [ 1 ] , p [ i ] [ 2 ] ) ;
8950: LD_VAR 0 5
8954: PUSH
8955: LD_VAR 0 6
8959: ARRAY
8960: PPUSH
8961: LD_VAR 0 3
8965: PUSH
8966: LD_VAR 0 6
8970: ARRAY
8971: PUSH
8972: LD_INT 1
8974: ARRAY
8975: PPUSH
8976: LD_VAR 0 3
8980: PUSH
8981: LD_VAR 0 6
8985: ARRAY
8986: PUSH
8987: LD_INT 2
8989: ARRAY
8990: PPUSH
8991: CALL_OW 171
// AddComCrawl ( sols [ i ] ) ;
8995: LD_VAR 0 5
8999: PUSH
9000: LD_VAR 0 6
9004: ARRAY
9005: PPUSH
9006: CALL_OW 197
// AddComHold ( sols ) ;
9010: LD_VAR 0 5
9014: PPUSH
9015: CALL_OW 200
// end ;
9019: GO 8947
9021: POP
9022: POP
// repeat wait ( 0 0$1 ) ;
9023: LD_INT 35
9025: PPUSH
9026: CALL_OW 67
// until GetDistUnitXY ( sols [ 1 ] , 92 , 131 ) < 4 ;
9030: LD_VAR 0 5
9034: PUSH
9035: LD_INT 1
9037: ARRAY
9038: PPUSH
9039: LD_INT 92
9041: PPUSH
9042: LD_INT 131
9044: PPUSH
9045: CALL_OW 297
9049: PUSH
9050: LD_INT 4
9052: LESS
9053: IFFALSE 9023
// CenterOnXY ( 96 , 139 ) ;
9055: LD_INT 96
9057: PPUSH
9058: LD_INT 139
9060: PPUSH
9061: CALL_OW 84
// wait ( 0 0$3 ) ;
9065: LD_INT 105
9067: PPUSH
9068: CALL_OW 67
// PlaceSeeing ( 111 , 135 , 1 , - 25 ) ;
9072: LD_INT 111
9074: PPUSH
9075: LD_INT 135
9077: PPUSH
9078: LD_INT 1
9080: PPUSH
9081: LD_INT 25
9083: NEG
9084: PPUSH
9085: CALL_OW 330
// ComMoveXY ( tmp [ 2 ] , GetX ( tmp [ 1 ] ) + 3 , GetY ( tmp [ 1 ] ) ) ;
9089: LD_VAR 0 2
9093: PUSH
9094: LD_INT 2
9096: ARRAY
9097: PPUSH
9098: LD_VAR 0 2
9102: PUSH
9103: LD_INT 1
9105: ARRAY
9106: PPUSH
9107: CALL_OW 250
9111: PUSH
9112: LD_INT 3
9114: PLUS
9115: PPUSH
9116: LD_VAR 0 2
9120: PUSH
9121: LD_INT 1
9123: ARRAY
9124: PPUSH
9125: CALL_OW 251
9129: PPUSH
9130: CALL_OW 111
// ComEnterUnit ( tmp [ 3 ] , ar_dep_s ) ;
9134: LD_VAR 0 2
9138: PUSH
9139: LD_INT 3
9141: ARRAY
9142: PPUSH
9143: LD_INT 7
9145: PPUSH
9146: CALL_OW 120
// AddComTurnUnit ( tmp [ 2 ] , tmp [ 1 ] ) ;
9150: LD_VAR 0 2
9154: PUSH
9155: LD_INT 2
9157: ARRAY
9158: PPUSH
9159: LD_VAR 0 2
9163: PUSH
9164: LD_INT 1
9166: ARRAY
9167: PPUSH
9168: CALL_OW 179
// repeat wait ( 0 0$1 ) ;
9172: LD_INT 35
9174: PPUSH
9175: CALL_OW 67
// until GetDistUnits ( tmp [ 1 ] , tmp [ 2 ] ) < 5 ;
9179: LD_VAR 0 2
9183: PUSH
9184: LD_INT 1
9186: ARRAY
9187: PPUSH
9188: LD_VAR 0 2
9192: PUSH
9193: LD_INT 2
9195: ARRAY
9196: PPUSH
9197: CALL_OW 296
9201: PUSH
9202: LD_INT 5
9204: LESS
9205: IFFALSE 9172
// ComTurnUnit ( tmp [ 1 ] , tmp [ 2 ] ) ;
9207: LD_VAR 0 2
9211: PUSH
9212: LD_INT 1
9214: ARRAY
9215: PPUSH
9216: LD_VAR 0 2
9220: PUSH
9221: LD_INT 2
9223: ARRAY
9224: PPUSH
9225: CALL_OW 119
// Say ( tmp [ 1 ] , D1a-Merc1-1 ) ;
9229: LD_VAR 0 2
9233: PUSH
9234: LD_INT 1
9236: ARRAY
9237: PPUSH
9238: LD_STRING D1a-Merc1-1
9240: PPUSH
9241: CALL_OW 88
// Say ( tmp [ 2 ] , D1a-FMerc2-1 ) ;
9245: LD_VAR 0 2
9249: PUSH
9250: LD_INT 2
9252: ARRAY
9253: PPUSH
9254: LD_STRING D1a-FMerc2-1
9256: PPUSH
9257: CALL_OW 88
// ComHeal ( tmp [ 2 ] , tmp [ 1 ] ) ;
9261: LD_VAR 0 2
9265: PUSH
9266: LD_INT 2
9268: ARRAY
9269: PPUSH
9270: LD_VAR 0 2
9274: PUSH
9275: LD_INT 1
9277: ARRAY
9278: PPUSH
9279: CALL_OW 128
// SetLives ( tmp [ 1 ] , 500 ) ;
9283: LD_VAR 0 2
9287: PUSH
9288: LD_INT 1
9290: ARRAY
9291: PPUSH
9292: LD_INT 500
9294: PPUSH
9295: CALL_OW 234
// wait ( 0 0$2 ) ;
9299: LD_INT 70
9301: PPUSH
9302: CALL_OW 67
// SetLives ( tmp [ 1 ] , 2 ) ;
9306: LD_VAR 0 2
9310: PUSH
9311: LD_INT 1
9313: ARRAY
9314: PPUSH
9315: LD_INT 2
9317: PPUSH
9318: CALL_OW 234
// wait ( 0 0$0.3 ) ;
9322: LD_INT 10
9324: PPUSH
9325: CALL_OW 67
// ForceSay ( tmp [ 1 ] , D1a-Merc1-2 ) ;
9329: LD_VAR 0 2
9333: PUSH
9334: LD_INT 1
9336: ARRAY
9337: PPUSH
9338: LD_STRING D1a-Merc1-2
9340: PPUSH
9341: CALL_OW 91
// wait ( 0 0$0.2 ) ;
9345: LD_INT 7
9347: PPUSH
9348: CALL_OW 67
// KillUnit ( tmp [ 1 ] ) ;
9352: LD_VAR 0 2
9356: PUSH
9357: LD_INT 1
9359: ARRAY
9360: PPUSH
9361: CALL_OW 66
// ComMoveToArea ( tmp [ 2 ] , escape_area ) ;
9365: LD_VAR 0 2
9369: PUSH
9370: LD_INT 2
9372: ARRAY
9373: PPUSH
9374: LD_INT 10
9376: PPUSH
9377: CALL_OW 113
// Say ( tmp [ 2 ] , D1a-FMerc2-2 ) ;
9381: LD_VAR 0 2
9385: PUSH
9386: LD_INT 2
9388: ARRAY
9389: PPUSH
9390: LD_STRING D1a-FMerc2-2
9392: PPUSH
9393: CALL_OW 88
// wait ( 0 0$1 ) ;
9397: LD_INT 35
9399: PPUSH
9400: CALL_OW 67
// CenterOnUnits ( ar_dep_s ) ;
9404: LD_INT 7
9406: PPUSH
9407: CALL_OW 85
// wait ( 0 0$2 ) ;
9411: LD_INT 70
9413: PPUSH
9414: CALL_OW 67
// ForceSay ( Saliba , D1a-Saliba-1 ) ;
9418: LD_EXP 44
9422: PPUSH
9423: LD_STRING D1a-Saliba-1
9425: PPUSH
9426: CALL_OW 91
// KillUnit ( Saliba ) ;
9430: LD_EXP 44
9434: PPUSH
9435: CALL_OW 66
// ComExitBuilding ( tmp [ 3 ] ) ;
9439: LD_VAR 0 2
9443: PUSH
9444: LD_INT 3
9446: ARRAY
9447: PPUSH
9448: CALL_OW 122
// CenterOnUnits ( JMM ) ;
9452: LD_EXP 21
9456: PPUSH
9457: CALL_OW 85
// wait ( 0 0$1 ) ;
9461: LD_INT 35
9463: PPUSH
9464: CALL_OW 67
// ComMoveXY ( sols , 88 , 141 ) ;
9468: LD_VAR 0 5
9472: PPUSH
9473: LD_INT 88
9475: PPUSH
9476: LD_INT 141
9478: PPUSH
9479: CALL_OW 111
// AddComWait ( sols , 0 0$2 ) ;
9483: LD_VAR 0 5
9487: PPUSH
9488: LD_INT 70
9490: PPUSH
9491: CALL_OW 202
// wait ( 0 0$2 ) ;
9495: LD_INT 70
9497: PPUSH
9498: CALL_OW 67
// SetAttitude ( 2 , 1 , att_enemy , true ) ;
9502: LD_INT 2
9504: PPUSH
9505: LD_INT 1
9507: PPUSH
9508: LD_INT 2
9510: PPUSH
9511: LD_INT 1
9513: PPUSH
9514: CALL_OW 80
// InGameOff ;
9518: CALL_OW 9
// ComWalk ( sols ) ;
9522: LD_VAR 0 5
9526: PPUSH
9527: CALL_OW 138
// ChangeMissionObjectives ( M1 ) ;
9531: LD_STRING M1
9533: PPUSH
9534: CALL_OW 337
// game_speed := 4 ;
9538: LD_ADDR_OWVAR 65
9542: PUSH
9543: LD_INT 4
9545: ST_TO_ADDR
// RemoveSeeing ( 111 , 135 , 1 ) ;
9546: LD_INT 111
9548: PPUSH
9549: LD_INT 135
9551: PPUSH
9552: LD_INT 1
9554: PPUSH
9555: CALL_OW 331
// SaveForQuickRestart ;
9559: CALL_OW 22
// ar_run := true ;
9563: LD_ADDR_EXP 5
9567: PUSH
9568: LD_INT 1
9570: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9571: LD_INT 35
9573: PPUSH
9574: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 1 ] , [ f_dist , ar_dep_s , 10 ] ] ) or GetLives ( ar_dep_s ) < 999 ;
9578: LD_INT 22
9580: PUSH
9581: LD_INT 1
9583: PUSH
9584: EMPTY
9585: LIST
9586: LIST
9587: PUSH
9588: LD_INT 91
9590: PUSH
9591: LD_INT 7
9593: PUSH
9594: LD_INT 10
9596: PUSH
9597: EMPTY
9598: LIST
9599: LIST
9600: LIST
9601: PUSH
9602: EMPTY
9603: LIST
9604: LIST
9605: PPUSH
9606: CALL_OW 69
9610: PUSH
9611: LD_INT 7
9613: PPUSH
9614: CALL_OW 256
9618: PUSH
9619: LD_INT 999
9621: LESS
9622: OR
9623: IFFALSE 9571
// if GetSide ( ar_dep_s ) = 2 then
9625: LD_INT 7
9627: PPUSH
9628: CALL_OW 255
9632: PUSH
9633: LD_INT 2
9635: EQUAL
9636: IFFALSE 9648
// SetSide ( ar_dep_s , 1 ) ;
9638: LD_INT 7
9640: PPUSH
9641: LD_INT 1
9643: PPUSH
9644: CALL_OW 235
// end ;
9648: LD_VAR 0 1
9652: RET
// every 0 0$2 trigger ar_run do var i , tmp , k ;
9653: LD_EXP 5
9657: IFFALSE 10017
9659: GO 9661
9661: DISABLE
9662: LD_INT 0
9664: PPUSH
9665: PPUSH
9666: PPUSH
// begin tmp := ar_force_tmp ^ UnitFilter ( ar_force_south , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ) ;
9667: LD_ADDR_VAR 0 2
9671: PUSH
9672: LD_EXP 40
9676: PUSH
9677: LD_EXP 36
9681: PPUSH
9682: LD_INT 2
9684: PUSH
9685: LD_INT 21
9687: PUSH
9688: LD_INT 2
9690: PUSH
9691: EMPTY
9692: LIST
9693: LIST
9694: PUSH
9695: LD_INT 21
9697: PUSH
9698: LD_INT 1
9700: PUSH
9701: EMPTY
9702: LIST
9703: LIST
9704: PUSH
9705: EMPTY
9706: LIST
9707: LIST
9708: LIST
9709: PPUSH
9710: CALL_OW 72
9714: ADD
9715: ST_TO_ADDR
// SetSide ( tmp , 5 ) ;
9716: LD_VAR 0 2
9720: PPUSH
9721: LD_INT 5
9723: PPUSH
9724: CALL_OW 235
// ChangeSideFog ( 5 , 1 ) ;
9728: LD_INT 5
9730: PPUSH
9731: LD_INT 1
9733: PPUSH
9734: CALL_OW 343
// k := 1 ;
9738: LD_ADDR_VAR 0 3
9742: PUSH
9743: LD_INT 1
9745: ST_TO_ADDR
// for i in tmp do
9746: LD_ADDR_VAR 0 1
9750: PUSH
9751: LD_VAR 0 2
9755: PUSH
9756: FOR_IN
9757: IFFALSE 9842
// begin if IsInUnit ( i ) then
9759: LD_VAR 0 1
9763: PPUSH
9764: CALL_OW 310
9768: IFFALSE 9779
// ComExitBuilding ( i ) ;
9770: LD_VAR 0 1
9774: PPUSH
9775: CALL_OW 122
// if GetClass ( i ) = 3 then
9779: LD_VAR 0 1
9783: PPUSH
9784: CALL_OW 257
9788: PUSH
9789: LD_INT 3
9791: EQUAL
9792: IFFALSE 9828
// begin AddComEnterUnit ( i , ar_vehicles_tmp [ k ] ) ;
9794: LD_VAR 0 1
9798: PPUSH
9799: LD_EXP 41
9803: PUSH
9804: LD_VAR 0 3
9808: ARRAY
9809: PPUSH
9810: CALL_OW 180
// k := k + 1 ;
9814: LD_ADDR_VAR 0 3
9818: PUSH
9819: LD_VAR 0 3
9823: PUSH
9824: LD_INT 1
9826: PLUS
9827: ST_TO_ADDR
// end ; AddComMoveToArea ( i , escape_area ) ;
9828: LD_VAR 0 1
9832: PPUSH
9833: LD_INT 10
9835: PPUSH
9836: CALL_OW 173
// end ;
9840: GO 9756
9842: POP
9843: POP
// ar_patrol := true ;
9844: LD_ADDR_EXP 7
9848: PUSH
9849: LD_INT 1
9851: ST_TO_ADDR
// repeat wait ( 0 0$0.3 ) ;
9852: LD_INT 10
9854: PPUSH
9855: CALL_OW 67
// for i in tmp do
9859: LD_ADDR_VAR 0 1
9863: PUSH
9864: LD_VAR 0 2
9868: PUSH
9869: FOR_IN
9870: IFFALSE 9898
// if not HasTask ( i ) then
9872: LD_VAR 0 1
9876: PPUSH
9877: CALL_OW 314
9881: NOT
9882: IFFALSE 9896
// ComMoveToArea ( i , escape_area ) ;
9884: LD_VAR 0 1
9888: PPUSH
9889: LD_INT 10
9891: PPUSH
9892: CALL_OW 113
9896: GO 9869
9898: POP
9899: POP
// k := UnitFilter ( tmp , [ f_inarea , escape_area ] ) ;
9900: LD_ADDR_VAR 0 3
9904: PUSH
9905: LD_VAR 0 2
9909: PPUSH
9910: LD_INT 95
9912: PUSH
9913: LD_INT 10
9915: PUSH
9916: EMPTY
9917: LIST
9918: LIST
9919: PPUSH
9920: CALL_OW 72
9924: ST_TO_ADDR
// if k then
9925: LD_VAR 0 3
9929: IFFALSE 9998
// for i in k do
9931: LD_ADDR_VAR 0 1
9935: PUSH
9936: LD_VAR 0 3
9940: PUSH
9941: FOR_IN
9942: IFFALSE 9996
// begin if IsInUnit ( i ) then
9944: LD_VAR 0 1
9948: PPUSH
9949: CALL_OW 310
9953: IFFALSE 9969
// RemoveUnit ( IsInUnit ( i ) ) ;
9955: LD_VAR 0 1
9959: PPUSH
9960: CALL_OW 310
9964: PPUSH
9965: CALL_OW 64
// RemoveUnit ( i ) ;
9969: LD_VAR 0 1
9973: PPUSH
9974: CALL_OW 64
// tmp := tmp diff i ;
9978: LD_ADDR_VAR 0 2
9982: PUSH
9983: LD_VAR 0 2
9987: PUSH
9988: LD_VAR 0 1
9992: DIFF
9993: ST_TO_ADDR
// end ;
9994: GO 9941
9996: POP
9997: POP
// until tmp = [ ] ;
9998: LD_VAR 0 2
10002: PUSH
10003: EMPTY
10004: EQUAL
10005: IFFALSE 9852
// ChangeSideFog ( 5 , 5 ) ;
10007: LD_INT 5
10009: PPUSH
10010: LD_INT 5
10012: PPUSH
10013: CALL_OW 343
// end ;
10017: PPOPN 3
10019: END
// every 0 0$03 trigger ar_patrol do var i , un , veh ;
10020: LD_EXP 7
10024: IFFALSE 10314
10026: GO 10028
10028: DISABLE
10029: LD_INT 0
10031: PPUSH
10032: PPUSH
10033: PPUSH
// begin uc_side := 2 ;
10034: LD_ADDR_OWVAR 20
10038: PUSH
10039: LD_INT 2
10041: ST_TO_ADDR
// uc_nation := 2 ;
10042: LD_ADDR_OWVAR 21
10046: PUSH
10047: LD_INT 2
10049: ST_TO_ADDR
// InitHc ;
10050: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
10054: LD_INT 1
10056: PPUSH
10057: LD_INT 1
10059: PPUSH
10060: LD_INT 6
10062: PPUSH
10063: CALL_OW 380
// un := CreateHuman ;
10067: LD_ADDR_VAR 0 2
10071: PUSH
10072: CALL_OW 44
10076: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_combustion , control_manual , ar_gun , 98 ) ;
10077: LD_INT 14
10079: PPUSH
10080: LD_INT 1
10082: PPUSH
10083: LD_INT 1
10085: PPUSH
10086: LD_INT 27
10088: PPUSH
10089: LD_INT 98
10091: PPUSH
10092: CALL 53709 0 5
// veh := CreateVehicle ;
10096: LD_ADDR_VAR 0 3
10100: PUSH
10101: CALL_OW 45
10105: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
10106: LD_VAR 0 3
10110: PPUSH
10111: LD_INT 4
10113: PPUSH
10114: CALL_OW 233
// PlaceUnitXY ( veh , 179 , 135 , false ) ;
10118: LD_VAR 0 3
10122: PPUSH
10123: LD_INT 179
10125: PPUSH
10126: LD_INT 135
10128: PPUSH
10129: LD_INT 0
10131: PPUSH
10132: CALL_OW 48
// PlaceHumanInUnit ( un , veh ) ;
10136: LD_VAR 0 2
10140: PPUSH
10141: LD_VAR 0 3
10145: PPUSH
10146: CALL_OW 52
// ComMoveXY ( un , 126 , 133 ) ;
10150: LD_VAR 0 2
10154: PPUSH
10155: LD_INT 126
10157: PPUSH
10158: LD_INT 133
10160: PPUSH
10161: CALL_OW 111
// repeat wait ( 0 0$0.3 ) ;
10165: LD_INT 10
10167: PPUSH
10168: CALL_OW 67
// until See ( 1 , veh ) or GetDistUnits ( veh , ar_dep_s ) < 9 ;
10172: LD_INT 1
10174: PPUSH
10175: LD_VAR 0 3
10179: PPUSH
10180: CALL_OW 292
10184: PUSH
10185: LD_VAR 0 3
10189: PPUSH
10190: LD_INT 7
10192: PPUSH
10193: CALL_OW 296
10197: PUSH
10198: LD_INT 9
10200: LESS
10201: OR
10202: IFFALSE 10165
// ComHold ( veh ) ;
10204: LD_VAR 0 3
10208: PPUSH
10209: CALL_OW 140
// Say ( un , D2aa-Ar1-1 ) ;
10213: LD_VAR 0 2
10217: PPUSH
10218: LD_STRING D2aa-Ar1-1
10220: PPUSH
10221: CALL_OW 88
// ComMoveXY ( un , 177 , 96 ) ;
10225: LD_VAR 0 2
10229: PPUSH
10230: LD_INT 177
10232: PPUSH
10233: LD_INT 96
10235: PPUSH
10236: CALL_OW 111
// AddComExitVehicle ( un ) ;
10240: LD_VAR 0 2
10244: PPUSH
10245: CALL_OW 181
// repeat wait ( 0 0$1 ) ;
10249: LD_INT 35
10251: PPUSH
10252: CALL_OW 67
// until GetDistUnits ( un , ar_dep_e ) < 15 ;
10256: LD_VAR 0 2
10260: PPUSH
10261: LD_INT 204
10263: PPUSH
10264: CALL_OW 296
10268: PUSH
10269: LD_INT 15
10271: LESS
10272: IFFALSE 10249
// mc_bases := ReplaceIn ( mc_bases , [ 3 , mc_bases [ 3 ] + 1 ] , un ) ;
10274: LD_ADDR_EXP 50
10278: PUSH
10279: LD_EXP 50
10283: PPUSH
10284: LD_INT 3
10286: PUSH
10287: LD_EXP 50
10291: PUSH
10292: LD_INT 3
10294: ARRAY
10295: PUSH
10296: LD_INT 1
10298: PLUS
10299: PUSH
10300: EMPTY
10301: LIST
10302: LIST
10303: PPUSH
10304: LD_VAR 0 2
10308: PPUSH
10309: CALL 53831 0 3
10313: ST_TO_ADDR
// end ;
10314: PPOPN 3
10316: END
// every 0 0$2 trigger GetSide ( ar_dep_s ) = 1 or IsDead ( ar_dep_s ) do var i , points ;
10317: LD_INT 7
10319: PPUSH
10320: CALL_OW 255
10324: PUSH
10325: LD_INT 1
10327: EQUAL
10328: PUSH
10329: LD_INT 7
10331: PPUSH
10332: CALL_OW 301
10336: OR
10337: IFFALSE 12742
10339: GO 10341
10341: DISABLE
10342: LD_INT 0
10344: PPUSH
10345: PPUSH
// begin for i in UnitFilter ( ar_force_south , [ f_type , unit_building ] ) do
10346: LD_ADDR_VAR 0 1
10350: PUSH
10351: LD_EXP 36
10355: PPUSH
10356: LD_INT 21
10358: PUSH
10359: LD_INT 3
10361: PUSH
10362: EMPTY
10363: LIST
10364: LIST
10365: PPUSH
10366: CALL_OW 72
10370: PUSH
10371: FOR_IN
10372: IFFALSE 10388
// SetSide ( i , 1 ) ;
10374: LD_VAR 0 1
10378: PPUSH
10379: LD_INT 1
10381: PPUSH
10382: CALL_OW 235
10386: GO 10371
10388: POP
10389: POP
// points := [ [ 46 , 41 ] , [ 50 , 25 ] , [ 57 , 75 ] , [ 75 , 89 ] , [ 51 , 45 ] , [ 95 , 95 ] , [ 84 , 77 ] , [ 101 , 76 ] , [ 118 , 81 ] , [ 139 , 97 ] , [ 129 , 114 ] , [ 154 , 111 ] ] ;
10390: LD_ADDR_VAR 0 2
10394: PUSH
10395: LD_INT 46
10397: PUSH
10398: LD_INT 41
10400: PUSH
10401: EMPTY
10402: LIST
10403: LIST
10404: PUSH
10405: LD_INT 50
10407: PUSH
10408: LD_INT 25
10410: PUSH
10411: EMPTY
10412: LIST
10413: LIST
10414: PUSH
10415: LD_INT 57
10417: PUSH
10418: LD_INT 75
10420: PUSH
10421: EMPTY
10422: LIST
10423: LIST
10424: PUSH
10425: LD_INT 75
10427: PUSH
10428: LD_INT 89
10430: PUSH
10431: EMPTY
10432: LIST
10433: LIST
10434: PUSH
10435: LD_INT 51
10437: PUSH
10438: LD_INT 45
10440: PUSH
10441: EMPTY
10442: LIST
10443: LIST
10444: PUSH
10445: LD_INT 95
10447: PUSH
10448: LD_INT 95
10450: PUSH
10451: EMPTY
10452: LIST
10453: LIST
10454: PUSH
10455: LD_INT 84
10457: PUSH
10458: LD_INT 77
10460: PUSH
10461: EMPTY
10462: LIST
10463: LIST
10464: PUSH
10465: LD_INT 101
10467: PUSH
10468: LD_INT 76
10470: PUSH
10471: EMPTY
10472: LIST
10473: LIST
10474: PUSH
10475: LD_INT 118
10477: PUSH
10478: LD_INT 81
10480: PUSH
10481: EMPTY
10482: LIST
10483: LIST
10484: PUSH
10485: LD_INT 139
10487: PUSH
10488: LD_INT 97
10490: PUSH
10491: EMPTY
10492: LIST
10493: LIST
10494: PUSH
10495: LD_INT 129
10497: PUSH
10498: LD_INT 114
10500: PUSH
10501: EMPTY
10502: LIST
10503: LIST
10504: PUSH
10505: LD_INT 154
10507: PUSH
10508: LD_INT 111
10510: PUSH
10511: EMPTY
10512: LIST
10513: LIST
10514: PUSH
10515: EMPTY
10516: LIST
10517: LIST
10518: LIST
10519: LIST
10520: LIST
10521: LIST
10522: LIST
10523: LIST
10524: LIST
10525: LIST
10526: LIST
10527: LIST
10528: ST_TO_ADDR
// base_captured := true ;
10529: LD_ADDR_EXP 6
10533: PUSH
10534: LD_INT 1
10536: ST_TO_ADDR
// DialogueOn ;
10537: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
10541: LD_EXP 21
10545: PPUSH
10546: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
10550: LD_EXP 21
10554: PPUSH
10555: LD_STRING D2-JMM-1
10557: PPUSH
10558: CALL_OW 88
// SayRadio ( Powell , D2-Pow-1 ) ;
10562: LD_EXP 30
10566: PPUSH
10567: LD_STRING D2-Pow-1
10569: PPUSH
10570: CALL_OW 94
// Say ( JMM , D2-JMM-2 ) ;
10574: LD_EXP 21
10578: PPUSH
10579: LD_STRING D2-JMM-2
10581: PPUSH
10582: CALL_OW 88
// SayRadio ( Powell , D2-Pow-2 ) ;
10586: LD_EXP 30
10590: PPUSH
10591: LD_STRING D2-Pow-2
10593: PPUSH
10594: CALL_OW 94
// Say ( JMM , D2-JMM-3 ) ;
10598: LD_EXP 21
10602: PPUSH
10603: LD_STRING D2-JMM-3
10605: PPUSH
10606: CALL_OW 88
// DialogueOff ;
10610: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
10614: LD_STRING M2
10616: PPUSH
10617: CALL_OW 337
// Wait ( 0 0$2 ) ;
10621: LD_INT 70
10623: PPUSH
10624: CALL_OW 67
// if IsOk ( Gary ) then
10628: LD_EXP 32
10632: PPUSH
10633: CALL_OW 302
10637: IFFALSE 10651
// Say ( Gary , D2a-Gary-1 ) ;
10639: LD_EXP 32
10643: PPUSH
10644: LD_STRING D2a-Gary-1
10646: PPUSH
10647: CALL_OW 88
// if IsOk ( Bobby ) then
10651: LD_EXP 24
10655: PPUSH
10656: CALL_OW 302
10660: IFFALSE 10674
// Say ( Bobby , D2a-Bobby-1 ) ;
10662: LD_EXP 24
10666: PPUSH
10667: LD_STRING D2a-Bobby-1
10669: PPUSH
10670: CALL_OW 88
// if IsOk ( Cyrus ) then
10674: LD_EXP 25
10678: PPUSH
10679: CALL_OW 302
10683: IFFALSE 10697
// Say ( Cyrus , D2a-Cyrus-1 ) ;
10685: LD_EXP 25
10689: PPUSH
10690: LD_STRING D2a-Cyrus-1
10692: PPUSH
10693: CALL_OW 88
// if IsOk ( Lisa ) then
10697: LD_EXP 22
10701: PPUSH
10702: CALL_OW 302
10706: IFFALSE 10720
// Say ( Lisa , D2a-Lisa-1 ) ;
10708: LD_EXP 22
10712: PPUSH
10713: LD_STRING D2a-Lisa-1
10715: PPUSH
10716: CALL_OW 88
// if IsOk ( Frank ) then
10720: LD_EXP 33
10724: PPUSH
10725: CALL_OW 302
10729: IFFALSE 10743
// Say ( Frank , D2a-Frank-1 ) ;
10731: LD_EXP 33
10735: PPUSH
10736: LD_STRING D2a-Frank-1
10738: PPUSH
10739: CALL_OW 88
// if IsOk ( Cornel ) then
10743: LD_EXP 31
10747: PPUSH
10748: CALL_OW 302
10752: IFFALSE 10766
// Say ( Cornel , D2a-Corn-1 ) ;
10754: LD_EXP 31
10758: PPUSH
10759: LD_STRING D2a-Corn-1
10761: PPUSH
10762: CALL_OW 88
// if IsOk ( Donaldson ) then
10766: LD_EXP 23
10770: PPUSH
10771: CALL_OW 302
10775: IFFALSE 10789
// Say ( Donaldson , D2a-Don-1 ) ;
10777: LD_EXP 23
10781: PPUSH
10782: LD_STRING D2a-Don-1
10784: PPUSH
10785: CALL_OW 88
// if IsOk ( Brown ) then
10789: LD_EXP 27
10793: PPUSH
10794: CALL_OW 302
10798: IFFALSE 10812
// Say ( Brown , D2a-Brown-1 ) ;
10800: LD_EXP 27
10804: PPUSH
10805: LD_STRING D2a-Brown-1
10807: PPUSH
10808: CALL_OW 88
// Wait ( 0 0$30 ) ;
10812: LD_INT 1050
10814: PPUSH
10815: CALL_OW 67
// if IsOk ( Frank ) then
10819: LD_EXP 33
10823: PPUSH
10824: CALL_OW 302
10828: IFFALSE 11808
// begin DialogueOn ;
10830: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Frank ] ) ;
10834: LD_EXP 21
10838: PUSH
10839: LD_EXP 33
10843: PUSH
10844: EMPTY
10845: LIST
10846: LIST
10847: PPUSH
10848: CALL_OW 87
// Say ( Frank , D3F-Frank-1 ) ;
10852: LD_EXP 33
10856: PPUSH
10857: LD_STRING D3F-Frank-1
10859: PPUSH
10860: CALL_OW 88
// Say ( JMM , D3F-JMM-1 ) ;
10864: LD_EXP 21
10868: PPUSH
10869: LD_STRING D3F-JMM-1
10871: PPUSH
10872: CALL_OW 88
// Say ( Frank , D3F-Frank-2 ) ;
10876: LD_EXP 33
10880: PPUSH
10881: LD_STRING D3F-Frank-2
10883: PPUSH
10884: CALL_OW 88
// case Query ( QFrank ) of 1 :
10888: LD_STRING QFrank
10890: PPUSH
10891: CALL_OW 97
10895: PUSH
10896: LD_INT 1
10898: DOUBLE
10899: EQUAL
10900: IFTRUE 10904
10902: GO 10927
10904: POP
// begin Say ( JMM , D3Fa-JMM-1 ) ;
10905: LD_EXP 21
10909: PPUSH
10910: LD_STRING D3Fa-JMM-1
10912: PPUSH
10913: CALL_OW 88
// us_scout := 1 ;
10917: LD_ADDR_EXP 8
10921: PUSH
10922: LD_INT 1
10924: ST_TO_ADDR
// end ; 2 :
10925: GO 11090
10927: LD_INT 2
10929: DOUBLE
10930: EQUAL
10931: IFTRUE 10935
10933: GO 11057
10935: POP
// begin Say ( JMM , D3Fb-JMM-1 ) ;
10936: LD_EXP 21
10940: PPUSH
10941: LD_STRING D3Fb-JMM-1
10943: PPUSH
10944: CALL_OW 88
// Say ( Frank , D3Fb-Frank-1 ) ;
10948: LD_EXP 33
10952: PPUSH
10953: LD_STRING D3Fb-Frank-1
10955: PPUSH
10956: CALL_OW 88
// case Query ( QFrank2 ) of 1 :
10960: LD_STRING QFrank2
10962: PPUSH
10963: CALL_OW 97
10967: PUSH
10968: LD_INT 1
10970: DOUBLE
10971: EQUAL
10972: IFTRUE 10976
10974: GO 11023
10976: POP
// begin us_scout := 2 ;
10977: LD_ADDR_EXP 8
10981: PUSH
10982: LD_INT 2
10984: ST_TO_ADDR
// Say ( JMM , D3Fba-JMM-1 ) ;
10985: LD_EXP 21
10989: PPUSH
10990: LD_STRING D3Fba-JMM-1
10992: PPUSH
10993: CALL_OW 88
// Say ( Frank , D3Fba-Frank-1 ) ;
10997: LD_EXP 33
11001: PPUSH
11002: LD_STRING D3Fba-Frank-1
11004: PPUSH
11005: CALL_OW 88
// Say ( JMM , D3Fba-JMM-2 ) ;
11009: LD_EXP 21
11013: PPUSH
11014: LD_STRING D3Fba-JMM-2
11016: PPUSH
11017: CALL_OW 88
// end ; 2 :
11021: GO 11055
11023: LD_INT 2
11025: DOUBLE
11026: EQUAL
11027: IFTRUE 11031
11029: GO 11054
11031: POP
// begin us_scout := 0 ;
11032: LD_ADDR_EXP 8
11036: PUSH
11037: LD_INT 0
11039: ST_TO_ADDR
// Say ( JMM , D3Fbb-JMM-1 ) ;
11040: LD_EXP 21
11044: PPUSH
11045: LD_STRING D3Fbb-JMM-1
11047: PPUSH
11048: CALL_OW 88
// end ; end ;
11052: GO 11055
11054: POP
// end ; 3 :
11055: GO 11090
11057: LD_INT 3
11059: DOUBLE
11060: EQUAL
11061: IFTRUE 11065
11063: GO 11089
11065: POP
// begin us_scout := - 1 ;
11066: LD_ADDR_EXP 8
11070: PUSH
11071: LD_INT 1
11073: NEG
11074: ST_TO_ADDR
// Say ( JMM , D3Fc-JMM-1 ) ;
11075: LD_EXP 21
11079: PPUSH
11080: LD_STRING D3Fc-JMM-1
11082: PPUSH
11083: CALL_OW 88
// end ; end ;
11087: GO 11090
11089: POP
// DialogueOff ;
11090: CALL_OW 7
// if us_scout in [ - 1 , 0 ] then
11094: LD_EXP 8
11098: PUSH
11099: LD_INT 1
11101: NEG
11102: PUSH
11103: LD_INT 0
11105: PUSH
11106: EMPTY
11107: LIST
11108: LIST
11109: IN
11110: IFFALSE 11114
// exit ;
11112: GO 12742
// if us_scout in [ 1 , 2 ] then
11114: LD_EXP 8
11118: PUSH
11119: LD_INT 1
11121: PUSH
11122: LD_INT 2
11124: PUSH
11125: EMPTY
11126: LIST
11127: LIST
11128: IN
11129: IFFALSE 11808
// begin if IsInUnit ( Frank ) then
11131: LD_EXP 33
11135: PPUSH
11136: CALL_OW 310
11140: IFFALSE 11151
// ComExit ( Frank ) ;
11142: LD_EXP 33
11146: PPUSH
11147: CALL 86560 0 1
// SetSide ( Frank , 4 ) ;
11151: LD_EXP 33
11155: PPUSH
11156: LD_INT 4
11158: PPUSH
11159: CALL_OW 235
// wait ( 0 0$1 ) ;
11163: LD_INT 35
11165: PPUSH
11166: CALL_OW 67
// if us_scout = 2 then
11170: LD_EXP 8
11174: PUSH
11175: LD_INT 2
11177: EQUAL
11178: IFFALSE 11546
// begin ComMoveXY ( Frank , 75 , 63 ) ;
11180: LD_EXP 33
11184: PPUSH
11185: LD_INT 75
11187: PPUSH
11188: LD_INT 63
11190: PPUSH
11191: CALL_OW 111
// AddComHold ( Frank ) ;
11195: LD_EXP 33
11199: PPUSH
11200: CALL_OW 200
// AddComWait ( Frank , 0 0$22 ) ;
11204: LD_EXP 33
11208: PPUSH
11209: LD_INT 770
11211: PPUSH
11212: CALL_OW 202
// AddComMoveXY ( Frank , 100 , 75 ) ;
11216: LD_EXP 33
11220: PPUSH
11221: LD_INT 100
11223: PPUSH
11224: LD_INT 75
11226: PPUSH
11227: CALL_OW 171
// AddComMoveXY ( Frank , 123 , 103 ) ;
11231: LD_EXP 33
11235: PPUSH
11236: LD_INT 123
11238: PPUSH
11239: LD_INT 103
11241: PPUSH
11242: CALL_OW 171
// AddComMoveXY ( Frank , 138 , 108 ) ;
11246: LD_EXP 33
11250: PPUSH
11251: LD_INT 138
11253: PPUSH
11254: LD_INT 108
11256: PPUSH
11257: CALL_OW 171
// AddComHold ( Frank ) ;
11261: LD_EXP 33
11265: PPUSH
11266: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
11270: LD_INT 35
11272: PPUSH
11273: CALL_OW 67
// until IsAt ( Frank , 138 , 108 ) ;
11277: LD_EXP 33
11281: PPUSH
11282: LD_INT 138
11284: PPUSH
11285: LD_INT 108
11287: PPUSH
11288: CALL_OW 307
11292: IFFALSE 11270
// AddComMoveXY ( Frank , 125 , 132 ) ;
11294: LD_EXP 33
11298: PPUSH
11299: LD_INT 125
11301: PPUSH
11302: LD_INT 132
11304: PPUSH
11305: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11309: LD_INT 35
11311: PPUSH
11312: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 7 ;
11316: LD_INT 1
11318: PPUSH
11319: LD_EXP 33
11323: PPUSH
11324: CALL_OW 292
11328: PUSH
11329: LD_EXP 33
11333: PPUSH
11334: LD_INT 7
11336: PPUSH
11337: CALL_OW 296
11341: PUSH
11342: LD_INT 7
11344: LESS
11345: OR
11346: IFFALSE 11309
// DialogueOn ;
11348: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11352: LD_EXP 33
11356: PPUSH
11357: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
11361: LD_INT 10
11363: PPUSH
11364: CALL_OW 68
// Say ( JMM , D4Fa-JMM-1 ) ;
11368: LD_EXP 21
11372: PPUSH
11373: LD_STRING D4Fa-JMM-1
11375: PPUSH
11376: CALL_OW 88
// for i in points do
11380: LD_ADDR_VAR 0 1
11384: PUSH
11385: LD_VAR 0 2
11389: PUSH
11390: FOR_IN
11391: IFFALSE 11449
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
11393: LD_VAR 0 1
11397: PUSH
11398: LD_INT 1
11400: ARRAY
11401: PPUSH
11402: LD_VAR 0 1
11406: PUSH
11407: LD_INT 2
11409: ARRAY
11410: PPUSH
11411: LD_INT 1
11413: PPUSH
11414: LD_INT 20
11416: NEG
11417: PPUSH
11418: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
11422: LD_VAR 0 1
11426: PUSH
11427: LD_INT 1
11429: ARRAY
11430: PPUSH
11431: LD_VAR 0 1
11435: PUSH
11436: LD_INT 2
11438: ARRAY
11439: PPUSH
11440: LD_INT 1
11442: PPUSH
11443: CALL_OW 331
// end ;
11447: GO 11390
11449: POP
11450: POP
// dwait ( 0 0$0.5 ) ;
11451: LD_INT 18
11453: PPUSH
11454: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
11458: LD_INT 42
11460: PPUSH
11461: LD_INT 27
11463: PPUSH
11464: CALL_OW 84
// Say ( Frank , D4Fa-Frank-1 ) ;
11468: LD_EXP 33
11472: PPUSH
11473: LD_STRING D4Fa-Frank-1
11475: PPUSH
11476: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
11480: LD_INT 18
11482: PPUSH
11483: CALL_OW 68
// Say ( JMM , D4Fa-JMM-2 ) ;
11487: LD_EXP 21
11491: PPUSH
11492: LD_STRING D4Fa-JMM-2
11494: PPUSH
11495: CALL_OW 88
// CenterNowOnXY ( 118 , 80 ) ;
11499: LD_INT 118
11501: PPUSH
11502: LD_INT 80
11504: PPUSH
11505: CALL_OW 86
// Say ( Frank , D4Fa-Frank-2 ) ;
11509: LD_EXP 33
11513: PPUSH
11514: LD_STRING D4Fa-Frank-2
11516: PPUSH
11517: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
11521: LD_INT 10
11523: PPUSH
11524: CALL_OW 68
// DialogueOff ;
11528: CALL_OW 7
// SetSide ( Frank , 1 ) ;
11532: LD_EXP 33
11536: PPUSH
11537: LD_INT 1
11539: PPUSH
11540: CALL_OW 235
// end else
11544: GO 11808
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
11546: LD_INT 2
11548: PPUSH
11549: LD_INT 4
11551: PPUSH
11552: LD_INT 2
11554: PPUSH
11555: LD_INT 1
11557: PPUSH
11558: CALL_OW 80
// ComMoveXY ( Frank , 75 , 63 ) ;
11562: LD_EXP 33
11566: PPUSH
11567: LD_INT 75
11569: PPUSH
11570: LD_INT 63
11572: PPUSH
11573: CALL_OW 111
// AddComWait ( Frank , 0 0$5 ) ;
11577: LD_EXP 33
11581: PPUSH
11582: LD_INT 175
11584: PPUSH
11585: CALL_OW 202
// AddComMoveXY ( Frank , 102 , 76 ) ;
11589: LD_EXP 33
11593: PPUSH
11594: LD_INT 102
11596: PPUSH
11597: LD_INT 76
11599: PPUSH
11600: CALL_OW 171
// AddComMoveXY ( Frank , 108 , 70 ) ;
11604: LD_EXP 33
11608: PPUSH
11609: LD_INT 108
11611: PPUSH
11612: LD_INT 70
11614: PPUSH
11615: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11619: LD_INT 35
11621: PPUSH
11622: CALL_OW 67
// until See ( 2 , Frank ) ;
11626: LD_INT 2
11628: PPUSH
11629: LD_EXP 33
11633: PPUSH
11634: CALL_OW 292
11638: IFFALSE 11619
// ComMoveXY ( Frank , 112 , 118 ) ;
11640: LD_EXP 33
11644: PPUSH
11645: LD_INT 112
11647: PPUSH
11648: LD_INT 118
11650: PPUSH
11651: CALL_OW 111
// if GetLives ( Frank ) >= 750 then
11655: LD_EXP 33
11659: PPUSH
11660: CALL_OW 256
11664: PUSH
11665: LD_INT 750
11667: GREATEREQUAL
11668: IFFALSE 11682
// SetLives ( Frank , 700 ) ;
11670: LD_EXP 33
11674: PPUSH
11675: LD_INT 700
11677: PPUSH
11678: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
11682: LD_INT 35
11684: PPUSH
11685: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 17 ;
11689: LD_INT 1
11691: PPUSH
11692: LD_EXP 33
11696: PPUSH
11697: CALL_OW 292
11701: PUSH
11702: LD_EXP 33
11706: PPUSH
11707: LD_INT 7
11709: PPUSH
11710: CALL_OW 296
11714: PUSH
11715: LD_INT 17
11717: LESS
11718: OR
11719: IFFALSE 11682
// DialogueOn ;
11721: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11725: LD_EXP 33
11729: PPUSH
11730: CALL_OW 87
// Say ( Frank , D4Fb-Frank-1 ) ;
11734: LD_EXP 33
11738: PPUSH
11739: LD_STRING D4Fb-Frank-1
11741: PPUSH
11742: CALL_OW 88
// Say ( JMM , D4Fb-JMM-1 ) ;
11746: LD_EXP 21
11750: PPUSH
11751: LD_STRING D4Fb-JMM-1
11753: PPUSH
11754: CALL_OW 88
// SayRand ( sex_female , D4Fb-FSci1-1 ) ;
11758: LD_INT 2
11760: PPUSH
11761: LD_STRING D4Fb-FSci1-1
11763: PPUSH
11764: CALL 16719 0 2
// Say ( Frank , D4Fb-Frank-2 ) ;
11768: LD_EXP 33
11772: PPUSH
11773: LD_STRING D4Fb-Frank-2
11775: PPUSH
11776: CALL_OW 88
// Say ( JMM , D4Fb-JMM-2 ) ;
11780: LD_EXP 21
11784: PPUSH
11785: LD_STRING D4Fb-JMM-2
11787: PPUSH
11788: CALL_OW 88
// DialogueOff ;
11792: CALL_OW 7
// SetSide ( Frank , 1 ) ;
11796: LD_EXP 33
11800: PPUSH
11801: LD_INT 1
11803: PPUSH
11804: CALL_OW 235
// end ; end ; end ; if IsOk ( Kikuchi ) and not IsOk ( Frank ) then
11808: LD_EXP 34
11812: PPUSH
11813: CALL_OW 302
11817: PUSH
11818: LD_EXP 33
11822: PPUSH
11823: CALL_OW 302
11827: NOT
11828: AND
11829: IFFALSE 12742
// begin DialogueOn ;
11831: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Kikuchi ] ) ;
11835: LD_EXP 21
11839: PUSH
11840: LD_EXP 34
11844: PUSH
11845: EMPTY
11846: LIST
11847: LIST
11848: PPUSH
11849: CALL_OW 87
// Say ( Kikuchi , D3Y-Yam-1 ) ;
11853: LD_EXP 34
11857: PPUSH
11858: LD_STRING D3Y-Yam-1
11860: PPUSH
11861: CALL_OW 88
// Say ( JMM , D3Y-JMM-1 ) ;
11865: LD_EXP 21
11869: PPUSH
11870: LD_STRING D3Y-JMM-1
11872: PPUSH
11873: CALL_OW 88
// Say ( Kikuchi , D3Y-Yam-2 ) ;
11877: LD_EXP 34
11881: PPUSH
11882: LD_STRING D3Y-Yam-2
11884: PPUSH
11885: CALL_OW 88
// case Query ( QYamoko ) of 1 :
11889: LD_STRING QYamoko
11891: PPUSH
11892: CALL_OW 97
11896: PUSH
11897: LD_INT 1
11899: DOUBLE
11900: EQUAL
11901: IFTRUE 11905
11903: GO 11940
11905: POP
// begin Say ( JMM , D3Ya-JMM-1 ) ;
11906: LD_EXP 21
11910: PPUSH
11911: LD_STRING D3Ya-JMM-1
11913: PPUSH
11914: CALL_OW 88
// Say ( Kikuchi , D3Ya-Yam-1 ) ;
11918: LD_EXP 34
11922: PPUSH
11923: LD_STRING D3Ya-Yam-1
11925: PPUSH
11926: CALL_OW 88
// us_scout := 1 ;
11930: LD_ADDR_EXP 8
11934: PUSH
11935: LD_INT 1
11937: ST_TO_ADDR
// end ; 2 :
11938: GO 11973
11940: LD_INT 2
11942: DOUBLE
11943: EQUAL
11944: IFTRUE 11948
11946: GO 11972
11948: POP
// begin us_scout := - 1 ;
11949: LD_ADDR_EXP 8
11953: PUSH
11954: LD_INT 1
11956: NEG
11957: ST_TO_ADDR
// Say ( JMM , D3Yb-JMM-1 ) ;
11958: LD_EXP 21
11962: PPUSH
11963: LD_STRING D3Yb-JMM-1
11965: PPUSH
11966: CALL_OW 88
// end ; end ;
11970: GO 11973
11972: POP
// DialogueOff ;
11973: CALL_OW 7
// if us_scout in [ - 1 , 0 ] then
11977: LD_EXP 8
11981: PUSH
11982: LD_INT 1
11984: NEG
11985: PUSH
11986: LD_INT 0
11988: PUSH
11989: EMPTY
11990: LIST
11991: LIST
11992: IN
11993: IFFALSE 11997
// exit ;
11995: GO 12742
// us_scout := [ 2 , 2 , 1 , 1 ] [ Difficulty ] ;
11997: LD_ADDR_EXP 8
12001: PUSH
12002: LD_INT 2
12004: PUSH
12005: LD_INT 2
12007: PUSH
12008: LD_INT 1
12010: PUSH
12011: LD_INT 1
12013: PUSH
12014: EMPTY
12015: LIST
12016: LIST
12017: LIST
12018: LIST
12019: PUSH
12020: LD_OWVAR 67
12024: ARRAY
12025: ST_TO_ADDR
// if us_scout in [ 1 , 2 ] then
12026: LD_EXP 8
12030: PUSH
12031: LD_INT 1
12033: PUSH
12034: LD_INT 2
12036: PUSH
12037: EMPTY
12038: LIST
12039: LIST
12040: IN
12041: IFFALSE 12742
// begin if IsInUnit ( Kikuchi ) then
12043: LD_EXP 34
12047: PPUSH
12048: CALL_OW 310
12052: IFFALSE 12063
// ComExitBuilding ( Kikuchi ) ;
12054: LD_EXP 34
12058: PPUSH
12059: CALL_OW 122
// if IsDrivenBy ( Kikuchi ) then
12063: LD_EXP 34
12067: PPUSH
12068: CALL_OW 311
12072: IFFALSE 12083
// ComExitVehicle ( Kikuchi ) ;
12074: LD_EXP 34
12078: PPUSH
12079: CALL_OW 121
// SetSide ( Kikuchi , 4 ) ;
12083: LD_EXP 34
12087: PPUSH
12088: LD_INT 4
12090: PPUSH
12091: CALL_OW 235
// wait ( 0 0$1 ) ;
12095: LD_INT 35
12097: PPUSH
12098: CALL_OW 67
// if us_scout = 2 then
12102: LD_EXP 8
12106: PUSH
12107: LD_INT 2
12109: EQUAL
12110: IFFALSE 12490
// begin ComMoveXY ( Kikuchi , 75 , 63 ) ;
12112: LD_EXP 34
12116: PPUSH
12117: LD_INT 75
12119: PPUSH
12120: LD_INT 63
12122: PPUSH
12123: CALL_OW 111
// AddComHold ( Kikuchi ) ;
12127: LD_EXP 34
12131: PPUSH
12132: CALL_OW 200
// AddComWait ( Kikuchi , 0 0$22 ) ;
12136: LD_EXP 34
12140: PPUSH
12141: LD_INT 770
12143: PPUSH
12144: CALL_OW 202
// AddComMoveXY ( Kikuchi , 100 , 75 ) ;
12148: LD_EXP 34
12152: PPUSH
12153: LD_INT 100
12155: PPUSH
12156: LD_INT 75
12158: PPUSH
12159: CALL_OW 171
// AddComMoveXY ( Kikuchi , 123 , 103 ) ;
12163: LD_EXP 34
12167: PPUSH
12168: LD_INT 123
12170: PPUSH
12171: LD_INT 103
12173: PPUSH
12174: CALL_OW 171
// AddComMoveXY ( Kikuchi , 138 , 108 ) ;
12178: LD_EXP 34
12182: PPUSH
12183: LD_INT 138
12185: PPUSH
12186: LD_INT 108
12188: PPUSH
12189: CALL_OW 171
// AddComHold ( Kikuchi ) ;
12193: LD_EXP 34
12197: PPUSH
12198: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
12202: LD_INT 35
12204: PPUSH
12205: CALL_OW 67
// until IsAt ( Kikuchi , 138 , 108 ) ;
12209: LD_EXP 34
12213: PPUSH
12214: LD_INT 138
12216: PPUSH
12217: LD_INT 108
12219: PPUSH
12220: CALL_OW 307
12224: IFFALSE 12202
// AddComMoveXY ( Kikuchi , 125 , 132 ) ;
12226: LD_EXP 34
12230: PPUSH
12231: LD_INT 125
12233: PPUSH
12234: LD_INT 132
12236: PPUSH
12237: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12241: LD_INT 35
12243: PPUSH
12244: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 7 ;
12248: LD_INT 1
12250: PPUSH
12251: LD_EXP 34
12255: PPUSH
12256: CALL_OW 292
12260: PUSH
12261: LD_EXP 34
12265: PPUSH
12266: LD_INT 7
12268: PPUSH
12269: CALL_OW 296
12273: PUSH
12274: LD_INT 7
12276: LESS
12277: OR
12278: IFFALSE 12241
// DialogueOn ;
12280: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12284: LD_EXP 34
12288: PPUSH
12289: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12293: LD_INT 10
12295: PPUSH
12296: CALL_OW 68
// Say ( Kikuchi , D4Ya-Yam-1 ) ;
12300: LD_EXP 34
12304: PPUSH
12305: LD_STRING D4Ya-Yam-1
12307: PPUSH
12308: CALL_OW 88
// Say ( JMM , D4Ya-JMM-1 ) ;
12312: LD_EXP 21
12316: PPUSH
12317: LD_STRING D4Ya-JMM-1
12319: PPUSH
12320: CALL_OW 88
// for i in points do
12324: LD_ADDR_VAR 0 1
12328: PUSH
12329: LD_VAR 0 2
12333: PUSH
12334: FOR_IN
12335: IFFALSE 12393
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
12337: LD_VAR 0 1
12341: PUSH
12342: LD_INT 1
12344: ARRAY
12345: PPUSH
12346: LD_VAR 0 1
12350: PUSH
12351: LD_INT 2
12353: ARRAY
12354: PPUSH
12355: LD_INT 1
12357: PPUSH
12358: LD_INT 20
12360: NEG
12361: PPUSH
12362: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
12366: LD_VAR 0 1
12370: PUSH
12371: LD_INT 1
12373: ARRAY
12374: PPUSH
12375: LD_VAR 0 1
12379: PUSH
12380: LD_INT 2
12382: ARRAY
12383: PPUSH
12384: LD_INT 1
12386: PPUSH
12387: CALL_OW 331
// end ;
12391: GO 12334
12393: POP
12394: POP
// dwait ( 0 0$0.5 ) ;
12395: LD_INT 18
12397: PPUSH
12398: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
12402: LD_INT 42
12404: PPUSH
12405: LD_INT 27
12407: PPUSH
12408: CALL_OW 84
// Say ( Kikuchi , D4Ya-Yam-2 ) ;
12412: LD_EXP 34
12416: PPUSH
12417: LD_STRING D4Ya-Yam-2
12419: PPUSH
12420: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
12424: LD_INT 18
12426: PPUSH
12427: CALL_OW 68
// CenterNowOnXY ( 118 , 80 ) ;
12431: LD_INT 118
12433: PPUSH
12434: LD_INT 80
12436: PPUSH
12437: CALL_OW 86
// Say ( JMM , D4Ya-JMM-2 ) ;
12441: LD_EXP 21
12445: PPUSH
12446: LD_STRING D4Ya-JMM-2
12448: PPUSH
12449: CALL_OW 88
// Say ( Kikuchi , D4Ya-Yam-3 ) ;
12453: LD_EXP 34
12457: PPUSH
12458: LD_STRING D4Ya-Yam-3
12460: PPUSH
12461: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
12465: LD_INT 10
12467: PPUSH
12468: CALL_OW 68
// DialogueOff ;
12472: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12476: LD_EXP 34
12480: PPUSH
12481: LD_INT 1
12483: PPUSH
12484: CALL_OW 235
// end else
12488: GO 12742
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
12490: LD_INT 2
12492: PPUSH
12493: LD_INT 4
12495: PPUSH
12496: LD_INT 2
12498: PPUSH
12499: LD_INT 1
12501: PPUSH
12502: CALL_OW 80
// ComMoveXY ( Kikuchi , 75 , 63 ) ;
12506: LD_EXP 34
12510: PPUSH
12511: LD_INT 75
12513: PPUSH
12514: LD_INT 63
12516: PPUSH
12517: CALL_OW 111
// AddComWait ( Kikuchi , 0 0$5 ) ;
12521: LD_EXP 34
12525: PPUSH
12526: LD_INT 175
12528: PPUSH
12529: CALL_OW 202
// AddComMoveXY ( Kikuchi , 102 , 76 ) ;
12533: LD_EXP 34
12537: PPUSH
12538: LD_INT 102
12540: PPUSH
12541: LD_INT 76
12543: PPUSH
12544: CALL_OW 171
// AddComMoveXY ( Kikuchi , 108 , 70 ) ;
12548: LD_EXP 34
12552: PPUSH
12553: LD_INT 108
12555: PPUSH
12556: LD_INT 70
12558: PPUSH
12559: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12563: LD_INT 35
12565: PPUSH
12566: CALL_OW 67
// until See ( 2 , Kikuchi ) ;
12570: LD_INT 2
12572: PPUSH
12573: LD_EXP 34
12577: PPUSH
12578: CALL_OW 292
12582: IFFALSE 12563
// ComMoveXY ( Kikuchi , 112 , 118 ) ;
12584: LD_EXP 34
12588: PPUSH
12589: LD_INT 112
12591: PPUSH
12592: LD_INT 118
12594: PPUSH
12595: CALL_OW 111
// if GetLives ( Kikuchi ) >= 750 then
12599: LD_EXP 34
12603: PPUSH
12604: CALL_OW 256
12608: PUSH
12609: LD_INT 750
12611: GREATEREQUAL
12612: IFFALSE 12626
// SetLives ( Kikuchi , 700 ) ;
12614: LD_EXP 34
12618: PPUSH
12619: LD_INT 700
12621: PPUSH
12622: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
12626: LD_INT 35
12628: PPUSH
12629: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 17 ;
12633: LD_INT 1
12635: PPUSH
12636: LD_EXP 34
12640: PPUSH
12641: CALL_OW 292
12645: PUSH
12646: LD_EXP 34
12650: PPUSH
12651: LD_INT 7
12653: PPUSH
12654: CALL_OW 296
12658: PUSH
12659: LD_INT 17
12661: LESS
12662: OR
12663: IFFALSE 12626
// DialogueOn ;
12665: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12669: LD_EXP 34
12673: PPUSH
12674: CALL_OW 87
// Say ( Kikuchi , D4Yb-Yam-1 ) ;
12678: LD_EXP 34
12682: PPUSH
12683: LD_STRING D4Yb-Yam-1
12685: PPUSH
12686: CALL_OW 88
// Say ( JMM , D4Yb-JMM-1 ) ;
12690: LD_EXP 21
12694: PPUSH
12695: LD_STRING D4Yb-JMM-1
12697: PPUSH
12698: CALL_OW 88
// Say ( Kikuchi , D4Yb-Yam-2 ) ;
12702: LD_EXP 34
12706: PPUSH
12707: LD_STRING D4Yb-Yam-2
12709: PPUSH
12710: CALL_OW 88
// Say ( JMM , D4Yb-JMM-2 ) ;
12714: LD_EXP 21
12718: PPUSH
12719: LD_STRING D4Yb-JMM-2
12721: PPUSH
12722: CALL_OW 88
// DialogueOff ;
12726: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12730: LD_EXP 34
12734: PPUSH
12735: LD_INT 1
12737: PPUSH
12738: CALL_OW 235
// end ; end ; end ; end ;
12742: PPOPN 2
12744: END
// every 0 0$01 trigger base_captured do var i , tmp , un , un2 ;
12745: LD_EXP 6
12749: IFFALSE 13782
12751: GO 12753
12753: DISABLE
12754: LD_INT 0
12756: PPUSH
12757: PPUSH
12758: PPUSH
12759: PPUSH
// begin enable ;
12760: ENABLE
// if not seen [ 1 ] then
12761: LD_EXP 9
12765: PUSH
12766: LD_INT 1
12768: ARRAY
12769: NOT
12770: IFFALSE 12950
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 11 ] , [ f_control , control_rider ] ] ] ) ;
12772: LD_ADDR_VAR 0 2
12776: PUSH
12777: LD_INT 22
12779: PUSH
12780: LD_INT 2
12782: PUSH
12783: EMPTY
12784: LIST
12785: LIST
12786: PUSH
12787: LD_INT 2
12789: PUSH
12790: LD_INT 25
12792: PUSH
12793: LD_INT 11
12795: PUSH
12796: EMPTY
12797: LIST
12798: LIST
12799: PUSH
12800: LD_INT 33
12802: PUSH
12803: LD_INT 4
12805: PUSH
12806: EMPTY
12807: LIST
12808: LIST
12809: PUSH
12810: EMPTY
12811: LIST
12812: LIST
12813: LIST
12814: PUSH
12815: EMPTY
12816: LIST
12817: LIST
12818: PPUSH
12819: CALL_OW 69
12823: ST_TO_ADDR
// if tmp then
12824: LD_VAR 0 2
12828: IFFALSE 12950
// for i in tmp do
12830: LD_ADDR_VAR 0 1
12834: PUSH
12835: LD_VAR 0 2
12839: PUSH
12840: FOR_IN
12841: IFFALSE 12948
// if See ( 1 , i ) then
12843: LD_INT 1
12845: PPUSH
12846: LD_VAR 0 1
12850: PPUSH
12851: CALL_OW 292
12855: IFFALSE 12946
// begin seen := Replace ( seen , 1 , true ) ;
12857: LD_ADDR_EXP 9
12861: PUSH
12862: LD_EXP 9
12866: PPUSH
12867: LD_INT 1
12869: PPUSH
12870: LD_INT 1
12872: PPUSH
12873: CALL_OW 1
12877: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12878: LD_INT 1
12880: PPUSH
12881: CALL 16541 0 1
12885: IFFALSE 12946
// begin DialogueOn ;
12887: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12891: LD_VAR 0 1
12895: PPUSH
12896: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12900: LD_INT 10
12902: PPUSH
12903: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol2-1 ) ;
12907: LD_ADDR_VAR 0 3
12911: PUSH
12912: LD_INT 1
12914: PPUSH
12915: LD_STRING D5a-Sol2-1
12917: PPUSH
12918: CALL 16719 0 2
12922: ST_TO_ADDR
// if not un then
12923: LD_VAR 0 3
12927: NOT
12928: IFFALSE 12940
// SayRand ( sex_female , D5a-FSol2-1 ) ;
12930: LD_INT 2
12932: PPUSH
12933: LD_STRING D5a-FSol2-1
12935: PPUSH
12936: CALL 16719 0 2
// DialogueOff ;
12940: CALL_OW 7
// break ;
12944: GO 12948
// end ; end ;
12946: GO 12840
12948: POP
12949: POP
// end ; if not seen [ 2 ] then
12950: LD_EXP 9
12954: PUSH
12955: LD_INT 2
12957: ARRAY
12958: NOT
12959: IFFALSE 13184
// begin can_kamikazed := true ;
12961: LD_ADDR_EXP 10
12965: PUSH
12966: LD_INT 1
12968: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 17 ] ] ) ;
12969: LD_ADDR_VAR 0 2
12973: PUSH
12974: LD_INT 22
12976: PUSH
12977: LD_INT 2
12979: PUSH
12980: EMPTY
12981: LIST
12982: LIST
12983: PUSH
12984: LD_INT 25
12986: PUSH
12987: LD_INT 17
12989: PUSH
12990: EMPTY
12991: LIST
12992: LIST
12993: PUSH
12994: EMPTY
12995: LIST
12996: LIST
12997: PPUSH
12998: CALL_OW 69
13002: ST_TO_ADDR
// if tmp then
13003: LD_VAR 0 2
13007: IFFALSE 13184
// for i in tmp do
13009: LD_ADDR_VAR 0 1
13013: PUSH
13014: LD_VAR 0 2
13018: PUSH
13019: FOR_IN
13020: IFFALSE 13182
// if See ( 1 , i ) then
13022: LD_INT 1
13024: PPUSH
13025: LD_VAR 0 1
13029: PPUSH
13030: CALL_OW 292
13034: IFFALSE 13180
// begin seen := Replace ( seen , 2 , true ) ;
13036: LD_ADDR_EXP 9
13040: PUSH
13041: LD_EXP 9
13045: PPUSH
13046: LD_INT 2
13048: PPUSH
13049: LD_INT 1
13051: PPUSH
13052: CALL_OW 1
13056: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13057: LD_INT 1
13059: PPUSH
13060: CALL 16541 0 1
13064: IFFALSE 13180
// begin DialogueOn ;
13066: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13070: LD_VAR 0 1
13074: PPUSH
13075: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13079: LD_INT 10
13081: PPUSH
13082: CALL_OW 68
// un := SayRand ( sex_male , D5b-Sol1-1 ) ;
13086: LD_ADDR_VAR 0 3
13090: PUSH
13091: LD_INT 1
13093: PPUSH
13094: LD_STRING D5b-Sol1-1
13096: PPUSH
13097: CALL 16719 0 2
13101: ST_TO_ADDR
// if not un then
13102: LD_VAR 0 3
13106: NOT
13107: IFFALSE 13125
// un := SayRand ( sex_female , D5b-FSol1-1 ) ;
13109: LD_ADDR_VAR 0 3
13113: PUSH
13114: LD_INT 2
13116: PPUSH
13117: LD_STRING D5b-FSol1-1
13119: PPUSH
13120: CALL 16719 0 2
13124: ST_TO_ADDR
// if un then
13125: LD_VAR 0 3
13129: IFFALSE 13174
// begin un2 := SayRand2 ( sex_male , D5b-Sol2-1 , un ) ;
13131: LD_ADDR_VAR 0 4
13135: PUSH
13136: LD_INT 1
13138: PPUSH
13139: LD_STRING D5b-Sol2-1
13141: PPUSH
13142: LD_VAR 0 3
13146: PPUSH
13147: CALL 16945 0 3
13151: ST_TO_ADDR
// if not un2 then
13152: LD_VAR 0 4
13156: NOT
13157: IFFALSE 13174
// SayRand2 ( sex_female , D5b-FSol2-1 , un ) ;
13159: LD_INT 2
13161: PPUSH
13162: LD_STRING D5b-FSol2-1
13164: PPUSH
13165: LD_VAR 0 3
13169: PPUSH
13170: CALL 16945 0 3
// end ; DialogueOff ;
13174: CALL_OW 7
// break ;
13178: GO 13182
// end ; end ;
13180: GO 13019
13182: POP
13183: POP
// end ; if not seen [ 3 ] then
13184: LD_EXP 9
13188: PUSH
13189: LD_INT 3
13191: ARRAY
13192: NOT
13193: IFFALSE 13367
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] ] ) ;
13195: LD_ADDR_VAR 0 2
13199: PUSH
13200: LD_INT 22
13202: PUSH
13203: LD_INT 2
13205: PUSH
13206: EMPTY
13207: LIST
13208: LIST
13209: PUSH
13210: LD_INT 33
13212: PUSH
13213: LD_INT 2
13215: PUSH
13216: EMPTY
13217: LIST
13218: LIST
13219: PUSH
13220: EMPTY
13221: LIST
13222: LIST
13223: PPUSH
13224: CALL_OW 69
13228: ST_TO_ADDR
// if tmp then
13229: LD_VAR 0 2
13233: IFFALSE 13367
// for i in tmp do
13235: LD_ADDR_VAR 0 1
13239: PUSH
13240: LD_VAR 0 2
13244: PUSH
13245: FOR_IN
13246: IFFALSE 13365
// if See ( 1 , i ) then
13248: LD_INT 1
13250: PPUSH
13251: LD_VAR 0 1
13255: PPUSH
13256: CALL_OW 292
13260: IFFALSE 13363
// begin seen := Replace ( seen , 3 , true ) ;
13262: LD_ADDR_EXP 9
13266: PUSH
13267: LD_EXP 9
13271: PPUSH
13272: LD_INT 3
13274: PPUSH
13275: LD_INT 1
13277: PPUSH
13278: CALL_OW 1
13282: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13283: LD_INT 1
13285: PPUSH
13286: CALL 16541 0 1
13290: IFFALSE 13363
// begin DialogueOn ;
13292: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13296: LD_VAR 0 1
13300: PPUSH
13301: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13305: LD_INT 10
13307: PPUSH
13308: CALL_OW 68
// un := SayRand ( sex_male , D8-Sol1-1 ) ;
13312: LD_ADDR_VAR 0 3
13316: PUSH
13317: LD_INT 1
13319: PPUSH
13320: LD_STRING D8-Sol1-1
13322: PPUSH
13323: CALL 16719 0 2
13327: ST_TO_ADDR
// if not un then
13328: LD_VAR 0 3
13332: NOT
13333: IFFALSE 13345
// SayRand ( sex_female , D8-FSol1-1 ) ;
13335: LD_INT 2
13337: PPUSH
13338: LD_STRING D8-FSol1-1
13340: PPUSH
13341: CALL 16719 0 2
// Say ( JMM , D8-JMM-1 ) ;
13345: LD_EXP 21
13349: PPUSH
13350: LD_STRING D8-JMM-1
13352: PPUSH
13353: CALL_OW 88
// DialogueOff ;
13357: CALL_OW 7
// break ;
13361: GO 13365
// end ; end ;
13363: GO 13245
13365: POP
13366: POP
// end ; if not seen [ 4 ] then
13367: LD_EXP 9
13371: PUSH
13372: LD_INT 4
13374: ARRAY
13375: NOT
13376: IFFALSE 13538
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] ] ) ;
13378: LD_ADDR_VAR 0 2
13382: PUSH
13383: LD_INT 22
13385: PUSH
13386: LD_INT 2
13388: PUSH
13389: EMPTY
13390: LIST
13391: LIST
13392: PUSH
13393: LD_INT 33
13395: PUSH
13396: LD_INT 5
13398: PUSH
13399: EMPTY
13400: LIST
13401: LIST
13402: PUSH
13403: EMPTY
13404: LIST
13405: LIST
13406: PPUSH
13407: CALL_OW 69
13411: ST_TO_ADDR
// if tmp then
13412: LD_VAR 0 2
13416: IFFALSE 13538
// for i in tmp do
13418: LD_ADDR_VAR 0 1
13422: PUSH
13423: LD_VAR 0 2
13427: PUSH
13428: FOR_IN
13429: IFFALSE 13536
// if See ( 1 , i ) then
13431: LD_INT 1
13433: PPUSH
13434: LD_VAR 0 1
13438: PPUSH
13439: CALL_OW 292
13443: IFFALSE 13534
// begin seen := Replace ( seen , 4 , true ) ;
13445: LD_ADDR_EXP 9
13449: PUSH
13450: LD_EXP 9
13454: PPUSH
13455: LD_INT 4
13457: PPUSH
13458: LD_INT 1
13460: PPUSH
13461: CALL_OW 1
13465: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13466: LD_INT 1
13468: PPUSH
13469: CALL 16541 0 1
13473: IFFALSE 13534
// begin DialogueOn ;
13475: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13479: LD_VAR 0 1
13483: PPUSH
13484: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13488: LD_INT 10
13490: PPUSH
13491: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol1-1 ) ;
13495: LD_ADDR_VAR 0 3
13499: PUSH
13500: LD_INT 1
13502: PPUSH
13503: LD_STRING D5a-Sol1-1
13505: PPUSH
13506: CALL 16719 0 2
13510: ST_TO_ADDR
// if not un then
13511: LD_VAR 0 3
13515: NOT
13516: IFFALSE 13528
// SayRand ( sex_female , D5a-FSol1-1 ) ;
13518: LD_INT 2
13520: PPUSH
13521: LD_STRING D5a-FSol1-1
13523: PPUSH
13524: CALL 16719 0 2
// DialogueOff ;
13528: CALL_OW 7
// break ;
13532: GO 13536
// end ; end ;
13534: GO 13428
13536: POP
13537: POP
// end ; if not seen [ 5 ] and seen [ 3 ] then
13538: LD_EXP 9
13542: PUSH
13543: LD_INT 5
13545: ARRAY
13546: NOT
13547: PUSH
13548: LD_EXP 9
13552: PUSH
13553: LD_INT 3
13555: ARRAY
13556: AND
13557: IFFALSE 13731
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) ;
13559: LD_ADDR_VAR 0 2
13563: PUSH
13564: LD_INT 22
13566: PUSH
13567: LD_INT 2
13569: PUSH
13570: EMPTY
13571: LIST
13572: LIST
13573: PUSH
13574: LD_INT 34
13576: PUSH
13577: LD_INT 31
13579: PUSH
13580: EMPTY
13581: LIST
13582: LIST
13583: PUSH
13584: EMPTY
13585: LIST
13586: LIST
13587: PPUSH
13588: CALL_OW 69
13592: ST_TO_ADDR
// if tmp then
13593: LD_VAR 0 2
13597: IFFALSE 13731
// for i in tmp do
13599: LD_ADDR_VAR 0 1
13603: PUSH
13604: LD_VAR 0 2
13608: PUSH
13609: FOR_IN
13610: IFFALSE 13729
// if See ( 1 , i ) then
13612: LD_INT 1
13614: PPUSH
13615: LD_VAR 0 1
13619: PPUSH
13620: CALL_OW 292
13624: IFFALSE 13727
// begin seen := Replace ( seen , 5 , true ) ;
13626: LD_ADDR_EXP 9
13630: PUSH
13631: LD_EXP 9
13635: PPUSH
13636: LD_INT 5
13638: PPUSH
13639: LD_INT 1
13641: PPUSH
13642: CALL_OW 1
13646: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13647: LD_INT 1
13649: PPUSH
13650: CALL 16541 0 1
13654: IFFALSE 13727
// begin DialogueOn ;
13656: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13660: LD_VAR 0 1
13664: PPUSH
13665: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13669: LD_INT 10
13671: PPUSH
13672: CALL_OW 68
// un := SayRand ( sex_male , D8a-Sol2-1 ) ;
13676: LD_ADDR_VAR 0 3
13680: PUSH
13681: LD_INT 1
13683: PPUSH
13684: LD_STRING D8a-Sol2-1
13686: PPUSH
13687: CALL 16719 0 2
13691: ST_TO_ADDR
// if not un then
13692: LD_VAR 0 3
13696: NOT
13697: IFFALSE 13709
// SayRand ( sex_female , D8a-FSol2-1 ) ;
13699: LD_INT 2
13701: PPUSH
13702: LD_STRING D8a-FSol2-1
13704: PPUSH
13705: CALL 16719 0 2
// Say ( JMM , D8a-JMM-1 ) ;
13709: LD_EXP 21
13713: PPUSH
13714: LD_STRING D8a-JMM-1
13716: PPUSH
13717: CALL_OW 88
// DialogueOff ;
13721: CALL_OW 7
// break ;
13725: GO 13729
// end ; end ;
13727: GO 13609
13729: POP
13730: POP
// end ; if seen [ 1 ] and seen [ 2 ] and seen [ 3 ] and seen [ 4 ] and seen [ 5 ] then
13731: LD_EXP 9
13735: PUSH
13736: LD_INT 1
13738: ARRAY
13739: PUSH
13740: LD_EXP 9
13744: PUSH
13745: LD_INT 2
13747: ARRAY
13748: AND
13749: PUSH
13750: LD_EXP 9
13754: PUSH
13755: LD_INT 3
13757: ARRAY
13758: AND
13759: PUSH
13760: LD_EXP 9
13764: PUSH
13765: LD_INT 4
13767: ARRAY
13768: AND
13769: PUSH
13770: LD_EXP 9
13774: PUSH
13775: LD_INT 5
13777: ARRAY
13778: AND
13779: IFFALSE 13782
// disable ;
13781: DISABLE
// end ;
13782: PPOPN 4
13784: END
// every 0 0$1 trigger can_kamikazed and kamikazed do var un ;
13785: LD_EXP 10
13789: PUSH
13790: LD_EXP 11
13794: AND
13795: IFFALSE 13993
13797: GO 13799
13799: DISABLE
13800: LD_INT 0
13802: PPUSH
// begin DialogueOn ;
13803: CALL_OW 6
// CenterNowOnUnits ( kamikazed ) ;
13807: LD_EXP 11
13811: PPUSH
13812: CALL_OW 87
// un := SayRand ( sex_male , D5c-Sol1-1 ) ;
13816: LD_ADDR_VAR 0 1
13820: PUSH
13821: LD_INT 1
13823: PPUSH
13824: LD_STRING D5c-Sol1-1
13826: PPUSH
13827: CALL 16719 0 2
13831: ST_TO_ADDR
// if not un then
13832: LD_VAR 0 1
13836: NOT
13837: IFFALSE 13855
// un := SayRand ( sex_female , D5c-FSol1-1 ) ;
13839: LD_ADDR_VAR 0 1
13843: PUSH
13844: LD_INT 2
13846: PPUSH
13847: LD_STRING D5c-FSol1-1
13849: PPUSH
13850: CALL 16719 0 2
13854: ST_TO_ADDR
// Say ( JMM , D5c-JMM-1 ) ;
13855: LD_EXP 21
13859: PPUSH
13860: LD_STRING D5c-JMM-1
13862: PPUSH
13863: CALL_OW 88
// if IsOk ( Lisa ) then
13867: LD_EXP 22
13871: PPUSH
13872: CALL_OW 302
13876: IFFALSE 13892
// Say ( Lisa , D5d-Lisa-1 ) else
13878: LD_EXP 22
13882: PPUSH
13883: LD_STRING D5d-Lisa-1
13885: PPUSH
13886: CALL_OW 88
13890: GO 13977
// if IsOk ( Cyrus ) then
13892: LD_EXP 25
13896: PPUSH
13897: CALL_OW 302
13901: IFFALSE 13917
// Say ( Cyrus , D5d-Cyrus-1 ) else
13903: LD_EXP 25
13907: PPUSH
13908: LD_STRING D5d-Cyrus-1
13910: PPUSH
13911: CALL_OW 88
13915: GO 13977
// if IsOk ( Gary ) then
13917: LD_EXP 32
13921: PPUSH
13922: CALL_OW 302
13926: IFFALSE 13942
// Say ( Gary , D5d-Gary-1 ) else
13928: LD_EXP 32
13932: PPUSH
13933: LD_STRING D5d-Gary-1
13935: PPUSH
13936: CALL_OW 88
13940: GO 13977
// if GetSex ( un ) = sex_male then
13942: LD_VAR 0 1
13946: PPUSH
13947: CALL_OW 258
13951: PUSH
13952: LD_INT 1
13954: EQUAL
13955: IFFALSE 13971
// Say ( un , D5d-Sol1-1 ) else
13957: LD_VAR 0 1
13961: PPUSH
13962: LD_STRING D5d-Sol1-1
13964: PPUSH
13965: CALL_OW 88
13969: GO 13977
// begin DialogueOff ;
13971: CALL_OW 7
// exit ;
13975: GO 13993
// end ; Say ( JMM , D5d-JMM-1 ) ;
13977: LD_EXP 21
13981: PPUSH
13982: LD_STRING D5d-JMM-1
13984: PPUSH
13985: CALL_OW 88
// DialogueOff ;
13989: CALL_OW 7
// end ;
13993: PPOPN 1
13995: END
// every 0 0$2 trigger SeeArea ( 1 , artifact_area ) >= 2 do var un ;
13996: LD_INT 1
13998: PPUSH
13999: LD_INT 17
14001: PPUSH
14002: CALL_OW 294
14006: PUSH
14007: LD_INT 2
14009: GREATEREQUAL
14010: IFFALSE 14142
14012: GO 14014
14014: DISABLE
14015: LD_INT 0
14017: PPUSH
// begin PlaceSeeing ( 10 , 5 , 1 , - 10 ) ;
14018: LD_INT 10
14020: PPUSH
14021: LD_INT 5
14023: PPUSH
14024: LD_INT 1
14026: PPUSH
14027: LD_INT 10
14029: NEG
14030: PPUSH
14031: CALL_OW 330
// RemoveSeeing ( 10 , 5 , 1 ) ;
14035: LD_INT 10
14037: PPUSH
14038: LD_INT 5
14040: PPUSH
14041: LD_INT 1
14043: PPUSH
14044: CALL_OW 331
// CenterNowOnXY ( 10 , 5 ) ;
14048: LD_INT 10
14050: PPUSH
14051: LD_INT 5
14053: PPUSH
14054: CALL_OW 86
// DialogueOn ;
14058: CALL_OW 6
// un := SayRand ( sex_male , D6-Sci1-1 ) ;
14062: LD_ADDR_VAR 0 1
14066: PUSH
14067: LD_INT 1
14069: PPUSH
14070: LD_STRING D6-Sci1-1
14072: PPUSH
14073: CALL 16719 0 2
14077: ST_TO_ADDR
// if un then
14078: LD_VAR 0 1
14082: IFFALSE 14120
// begin Say ( JMM , D6-JMM-1 ) ;
14084: LD_EXP 21
14088: PPUSH
14089: LD_STRING D6-JMM-1
14091: PPUSH
14092: CALL_OW 88
// Say ( un , D6-Sci1-2 ) ;
14096: LD_VAR 0 1
14100: PPUSH
14101: LD_STRING D6-Sci1-2
14103: PPUSH
14104: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
14108: LD_EXP 21
14112: PPUSH
14113: LD_STRING D6-JMM-2
14115: PPUSH
14116: CALL_OW 88
// end ; DialogueOff ;
14120: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
14124: LD_STRING M3
14126: PPUSH
14127: CALL_OW 337
// wait ( 0 0$30 ) ;
14131: LD_INT 1050
14133: PPUSH
14134: CALL_OW 67
// AmericanReinforcements ;
14138: CALL 2326 0 0
// end ;
14142: PPOPN 1
14144: END
// export ar_mechanic , ar_mechanic_friend ; every 0 0$20 trigger tick >= 20 20$00 and ( DangerAtRangeXY ( 2 , 169 , 90 , 10 ) [ 4 ] = 0 or IsDead ( ar_dep_w ) or GetSide ( ar_dep_w ) = 1 ) and not IsDead ( ar_dep_n ) do var un , i , cargo , tmp , escaped ;
14145: LD_OWVAR 1
14149: PUSH
14150: LD_INT 42000
14152: GREATEREQUAL
14153: PUSH
14154: LD_INT 2
14156: PPUSH
14157: LD_INT 169
14159: PPUSH
14160: LD_INT 90
14162: PPUSH
14163: LD_INT 10
14165: PPUSH
14166: CALL 54727 0 4
14170: PUSH
14171: LD_INT 4
14173: ARRAY
14174: PUSH
14175: LD_INT 0
14177: EQUAL
14178: PUSH
14179: LD_INT 45
14181: PPUSH
14182: CALL_OW 301
14186: OR
14187: PUSH
14188: LD_INT 45
14190: PPUSH
14191: CALL_OW 255
14195: PUSH
14196: LD_INT 1
14198: EQUAL
14199: OR
14200: AND
14201: PUSH
14202: LD_INT 94
14204: PPUSH
14205: CALL_OW 301
14209: NOT
14210: AND
14211: IFFALSE 15416
14213: GO 14215
14215: DISABLE
14216: LD_INT 0
14218: PPUSH
14219: PPUSH
14220: PPUSH
14221: PPUSH
14222: PPUSH
// begin uc_side := 5 ;
14223: LD_ADDR_OWVAR 20
14227: PUSH
14228: LD_INT 5
14230: ST_TO_ADDR
// uc_nation := 2 ;
14231: LD_ADDR_OWVAR 21
14235: PUSH
14236: LD_INT 2
14238: ST_TO_ADDR
// InitHc ;
14239: CALL_OW 19
// PrepareHuman ( sex_male , 3 , 8 ) ;
14243: LD_INT 1
14245: PPUSH
14246: LD_INT 3
14248: PPUSH
14249: LD_INT 8
14251: PPUSH
14252: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
14256: LD_ADDR_OWVAR 29
14260: PUSH
14261: LD_INT 12
14263: PUSH
14264: LD_INT 12
14266: PUSH
14267: EMPTY
14268: LIST
14269: LIST
14270: ST_TO_ADDR
// hc_name := Hans Fliege ;
14271: LD_ADDR_OWVAR 26
14275: PUSH
14276: LD_STRING Hans Fliege
14278: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
14279: LD_ADDR_OWVAR 33
14283: PUSH
14284: LD_STRING SecondCharsGal
14286: ST_TO_ADDR
// hc_face_number := 7 ;
14287: LD_ADDR_OWVAR 34
14291: PUSH
14292: LD_INT 7
14294: ST_TO_ADDR
// ar_mechanic := CreateHuman ;
14295: LD_ADDR_EXP 46
14299: PUSH
14300: CALL_OW 44
14304: ST_TO_ADDR
// InitHc ;
14305: CALL_OW 19
// PrepareHuman ( sex_male , 16 , 2 ) ;
14309: LD_INT 1
14311: PPUSH
14312: LD_INT 16
14314: PPUSH
14315: LD_INT 2
14317: PPUSH
14318: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
14322: LD_ADDR_OWVAR 29
14326: PUSH
14327: LD_INT 12
14329: PUSH
14330: LD_INT 12
14332: PUSH
14333: EMPTY
14334: LIST
14335: LIST
14336: ST_TO_ADDR
// hc_name :=  ;
14337: LD_ADDR_OWVAR 26
14341: PUSH
14342: LD_STRING 
14344: ST_TO_ADDR
// ar_mechanic_friend := CreateHuman ;
14345: LD_ADDR_EXP 47
14349: PUSH
14350: CALL_OW 44
14354: ST_TO_ADDR
// InitHc ;
14355: CALL_OW 19
// repeat wait ( 0 0$1 ) ;
14359: LD_INT 35
14361: PPUSH
14362: CALL_OW 67
// until not InBattle ( 1 ) ;
14366: LD_INT 1
14368: PPUSH
14369: CALL_OW 463
14373: NOT
14374: IFFALSE 14359
// wait ( 0 0$5 ) ;
14376: LD_INT 175
14378: PPUSH
14379: CALL_OW 67
// DialogueOn ;
14383: CALL_OW 6
// InGameOn ;
14387: CALL_OW 8
// un := UnitFilter ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , [ f_sex , sex_male ] ) [ 1 ] ;
14391: LD_ADDR_VAR 0 1
14395: PUSH
14396: LD_INT 22
14398: PUSH
14399: LD_INT 1
14401: PUSH
14402: EMPTY
14403: LIST
14404: LIST
14405: PUSH
14406: LD_INT 2
14408: PUSH
14409: LD_INT 25
14411: PUSH
14412: LD_INT 1
14414: PUSH
14415: EMPTY
14416: LIST
14417: LIST
14418: PUSH
14419: LD_INT 25
14421: PUSH
14422: LD_INT 2
14424: PUSH
14425: EMPTY
14426: LIST
14427: LIST
14428: PUSH
14429: LD_INT 25
14431: PUSH
14432: LD_INT 3
14434: PUSH
14435: EMPTY
14436: LIST
14437: LIST
14438: PUSH
14439: LD_INT 25
14441: PUSH
14442: LD_INT 4
14444: PUSH
14445: EMPTY
14446: LIST
14447: LIST
14448: PUSH
14449: LD_INT 25
14451: PUSH
14452: LD_INT 5
14454: PUSH
14455: EMPTY
14456: LIST
14457: LIST
14458: PUSH
14459: LD_INT 25
14461: PUSH
14462: LD_INT 8
14464: PUSH
14465: EMPTY
14466: LIST
14467: LIST
14468: PUSH
14469: EMPTY
14470: LIST
14471: LIST
14472: LIST
14473: LIST
14474: LIST
14475: LIST
14476: LIST
14477: PUSH
14478: EMPTY
14479: LIST
14480: LIST
14481: PPUSH
14482: CALL_OW 69
14486: PUSH
14487: LD_EXP 21
14491: PUSH
14492: LD_EXP 22
14496: PUSH
14497: LD_EXP 23
14501: PUSH
14502: LD_EXP 24
14506: PUSH
14507: LD_EXP 25
14511: PUSH
14512: LD_EXP 26
14516: PUSH
14517: LD_EXP 27
14521: PUSH
14522: LD_EXP 28
14526: PUSH
14527: LD_EXP 29
14531: PUSH
14532: LD_EXP 31
14536: PUSH
14537: LD_EXP 32
14541: PUSH
14542: LD_EXP 33
14546: PUSH
14547: LD_EXP 34
14551: PUSH
14552: EMPTY
14553: LIST
14554: LIST
14555: LIST
14556: LIST
14557: LIST
14558: LIST
14559: LIST
14560: LIST
14561: LIST
14562: LIST
14563: LIST
14564: LIST
14565: LIST
14566: DIFF
14567: PPUSH
14568: LD_INT 26
14570: PUSH
14571: LD_INT 1
14573: PUSH
14574: EMPTY
14575: LIST
14576: LIST
14577: PPUSH
14578: CALL_OW 72
14582: PUSH
14583: LD_INT 1
14585: ARRAY
14586: ST_TO_ADDR
// if Brown then
14587: LD_EXP 27
14591: IFFALSE 14603
// un := Brown ;
14593: LD_ADDR_VAR 0 1
14597: PUSH
14598: LD_EXP 27
14602: ST_TO_ADDR
// if un then
14603: LD_VAR 0 1
14607: IFFALSE 14633
// begin Say ( un , D7-Sol1-1 ) ;
14609: LD_VAR 0 1
14613: PPUSH
14614: LD_STRING D7-Sol1-1
14616: PPUSH
14617: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
14621: LD_EXP 21
14625: PPUSH
14626: LD_STRING D7-JMM-1
14628: PPUSH
14629: CALL_OW 88
// end ; SayRadio ( ar_mechanic , D7-Ar1-1 ) ;
14633: LD_EXP 46
14637: PPUSH
14638: LD_STRING D7-Ar1-1
14640: PPUSH
14641: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
14645: LD_EXP 21
14649: PPUSH
14650: LD_STRING D7-JMM-2
14652: PPUSH
14653: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-2 ) ;
14657: LD_EXP 46
14661: PPUSH
14662: LD_STRING D7-Ar1-2
14664: PPUSH
14665: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
14669: LD_EXP 21
14673: PPUSH
14674: LD_STRING D7-JMM-3
14676: PPUSH
14677: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-3 ) ;
14681: LD_EXP 46
14685: PPUSH
14686: LD_STRING D7-Ar1-3
14688: PPUSH
14689: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
14693: LD_EXP 21
14697: PPUSH
14698: LD_STRING D7-JMM-4
14700: PPUSH
14701: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-4 ) ;
14705: LD_EXP 46
14709: PPUSH
14710: LD_STRING D7-Ar1-4
14712: PPUSH
14713: CALL_OW 94
// InGameOff ;
14717: CALL_OW 9
// DialogueOff ;
14721: CALL_OW 7
// case Query ( QCameras ) of 1 :
14725: LD_STRING QCameras
14727: PPUSH
14728: CALL_OW 97
14732: PUSH
14733: LD_INT 1
14735: DOUBLE
14736: EQUAL
14737: IFTRUE 14741
14739: GO 14744
14741: POP
// ; 2 :
14742: GO 14758
14744: LD_INT 2
14746: DOUBLE
14747: EQUAL
14748: IFTRUE 14752
14750: GO 14757
14752: POP
// exit ; end ;
14753: GO 15416
14755: GO 14758
14757: POP
// ChangeMissionObjectives ( MCar ) ;
14758: LD_STRING MCar
14760: PPUSH
14761: CALL_OW 337
// PlaceSeeing ( 124 , 90 , 1 , - 6 ) ;
14765: LD_INT 124
14767: PPUSH
14768: LD_INT 90
14770: PPUSH
14771: LD_INT 1
14773: PPUSH
14774: LD_INT 6
14776: NEG
14777: PPUSH
14778: CALL_OW 330
// RemoveSeeing ( 124 , 90 , 1 ) ;
14782: LD_INT 124
14784: PPUSH
14785: LD_INT 90
14787: PPUSH
14788: LD_INT 1
14790: PPUSH
14791: CALL_OW 331
// SetAreaMapShow ( parking_marea , 1 ) ;
14795: LD_INT 12
14797: PPUSH
14798: LD_INT 1
14800: PPUSH
14801: CALL_OW 424
// wait ( 3 ) ;
14805: LD_INT 3
14807: PPUSH
14808: CALL_OW 67
// CenterNowOnXY ( 124 , 90 ) ;
14812: LD_INT 124
14814: PPUSH
14815: LD_INT 90
14817: PPUSH
14818: CALL_OW 86
// cargo := false ;
14822: LD_ADDR_VAR 0 3
14826: PUSH
14827: LD_INT 0
14829: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
14830: LD_INT 35
14832: PPUSH
14833: CALL_OW 67
// cargo := FilterUnitsInArea ( parking_marea , [ [ f_engine , engine_siberite ] , [ f_weapon , ar_cargo_bay ] , [ f_empty ] ] ) ;
14837: LD_ADDR_VAR 0 3
14841: PUSH
14842: LD_INT 12
14844: PPUSH
14845: LD_INT 32
14847: PUSH
14848: LD_INT 3
14850: PUSH
14851: EMPTY
14852: LIST
14853: LIST
14854: PUSH
14855: LD_INT 34
14857: PUSH
14858: LD_INT 32
14860: PUSH
14861: EMPTY
14862: LIST
14863: LIST
14864: PUSH
14865: LD_INT 58
14867: PUSH
14868: EMPTY
14869: LIST
14870: PUSH
14871: EMPTY
14872: LIST
14873: LIST
14874: LIST
14875: PPUSH
14876: CALL_OW 70
14880: ST_TO_ADDR
// until cargo ;
14881: LD_VAR 0 3
14885: IFFALSE 14830
// cargo := cargo [ 1 ] ;
14887: LD_ADDR_VAR 0 3
14891: PUSH
14892: LD_VAR 0 3
14896: PUSH
14897: LD_INT 1
14899: ARRAY
14900: ST_TO_ADDR
// SetSide ( cargo , 5 ) ;
14901: LD_VAR 0 3
14905: PPUSH
14906: LD_INT 5
14908: PPUSH
14909: CALL_OW 235
// SetAreaMapShow ( parking_marea , 0 ) ;
14913: LD_INT 12
14915: PPUSH
14916: LD_INT 0
14918: PPUSH
14919: CALL_OW 424
// PlaceUnitArea ( ar_mechanic , mechanic_spawn , false ) ;
14923: LD_EXP 46
14927: PPUSH
14928: LD_INT 11
14930: PPUSH
14931: LD_INT 0
14933: PPUSH
14934: CALL_OW 49
// PlaceUnitArea ( ar_mechanic_friend , mechanic_spawn , false ) ;
14938: LD_EXP 47
14942: PPUSH
14943: LD_INT 11
14945: PPUSH
14946: LD_INT 0
14948: PPUSH
14949: CALL_OW 49
// ComMoveToArea ( [ ar_mechanic , ar_mechanic_friend ] , parking_marea ) ;
14953: LD_EXP 46
14957: PUSH
14958: LD_EXP 47
14962: PUSH
14963: EMPTY
14964: LIST
14965: LIST
14966: PPUSH
14967: LD_INT 12
14969: PPUSH
14970: CALL_OW 113
// AddComEnterUnit ( ar_mechanic , cargo ) ;
14974: LD_EXP 46
14978: PPUSH
14979: LD_VAR 0 3
14983: PPUSH
14984: CALL_OW 180
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
14988: LD_EXP 46
14992: PUSH
14993: LD_EXP 47
14997: PUSH
14998: EMPTY
14999: LIST
15000: LIST
15001: PPUSH
15002: LD_INT 209
15004: PPUSH
15005: LD_INT 178
15007: PPUSH
15008: CALL_OW 171
// escaped := 0 ;
15012: LD_ADDR_VAR 0 5
15016: PUSH
15017: LD_INT 0
15019: ST_TO_ADDR
// while ( true ) do
15020: LD_INT 1
15022: IFFALSE 15238
// begin wait ( 0 0$1 ) ;
15024: LD_INT 35
15026: PPUSH
15027: CALL_OW 67
// if not HasTask ( ar_mechanic ) or not HasTask ( ar_mechanic_friend ) then
15031: LD_EXP 46
15035: PPUSH
15036: CALL_OW 314
15040: NOT
15041: PUSH
15042: LD_EXP 47
15046: PPUSH
15047: CALL_OW 314
15051: NOT
15052: OR
15053: IFFALSE 15079
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
15055: LD_EXP 46
15059: PUSH
15060: LD_EXP 47
15064: PUSH
15065: EMPTY
15066: LIST
15067: LIST
15068: PPUSH
15069: LD_INT 209
15071: PPUSH
15072: LD_INT 178
15074: PPUSH
15075: CALL_OW 171
// if IsInArea ( ar_mechanic , escape_area ) then
15079: LD_EXP 46
15083: PPUSH
15084: LD_INT 10
15086: PPUSH
15087: CALL_OW 308
15091: IFFALSE 15116
// begin RemoveUnit ( ar_mechanic ) ;
15093: LD_EXP 46
15097: PPUSH
15098: CALL_OW 64
// escaped := escaped + 1 ;
15102: LD_ADDR_VAR 0 5
15106: PUSH
15107: LD_VAR 0 5
15111: PUSH
15112: LD_INT 1
15114: PLUS
15115: ST_TO_ADDR
// end ; if IsInArea ( ar_mechanic_friend , escape_area ) then
15116: LD_EXP 47
15120: PPUSH
15121: LD_INT 10
15123: PPUSH
15124: CALL_OW 308
15128: IFFALSE 15153
// begin RemoveUnit ( ar_mechanic_friend ) ;
15130: LD_EXP 47
15134: PPUSH
15135: CALL_OW 64
// escaped := escaped + 1 ;
15139: LD_ADDR_VAR 0 5
15143: PUSH
15144: LD_VAR 0 5
15148: PUSH
15149: LD_INT 1
15151: PLUS
15152: ST_TO_ADDR
// end ; if IsInArea ( cargo , escape_area ) then
15153: LD_VAR 0 3
15157: PPUSH
15158: LD_INT 10
15160: PPUSH
15161: CALL_OW 308
15165: IFFALSE 15176
// RemoveUnit ( cargo ) ;
15167: LD_VAR 0 3
15171: PPUSH
15172: CALL_OW 64
// if not IsPlaced ( ar_mechanic ) and escaped >= 2 then
15176: LD_EXP 46
15180: PPUSH
15181: CALL_OW 305
15185: NOT
15186: PUSH
15187: LD_VAR 0 5
15191: PUSH
15192: LD_INT 2
15194: GREATEREQUAL
15195: AND
15196: IFFALSE 15200
// break ;
15198: GO 15238
// if not IsPlaced ( ar_mechanic ) and not IsPlaced ( ar_mechanic_friend ) and escaped < 2 then
15200: LD_EXP 46
15204: PPUSH
15205: CALL_OW 305
15209: NOT
15210: PUSH
15211: LD_EXP 47
15215: PPUSH
15216: CALL_OW 305
15220: NOT
15221: AND
15222: PUSH
15223: LD_VAR 0 5
15227: PUSH
15228: LD_INT 2
15230: LESS
15231: AND
15232: IFFALSE 15236
// exit ;
15234: GO 15416
// end ;
15236: GO 15020
// wait ( 0 0$2 ) ;
15238: LD_INT 70
15240: PPUSH
15241: CALL_OW 67
// SayRadio ( ar_mechanic , D7a-Ar1-1 ) ;
15245: LD_EXP 46
15249: PPUSH
15250: LD_STRING D7a-Ar1-1
15252: PPUSH
15253: CALL_OW 94
// tmp := [ [ 129 , 10 ] , [ 103 , 6 ] , [ 148 , 47 ] , [ 155 , 16 ] ] ;
15257: LD_ADDR_VAR 0 4
15261: PUSH
15262: LD_INT 129
15264: PUSH
15265: LD_INT 10
15267: PUSH
15268: EMPTY
15269: LIST
15270: LIST
15271: PUSH
15272: LD_INT 103
15274: PUSH
15275: LD_INT 6
15277: PUSH
15278: EMPTY
15279: LIST
15280: LIST
15281: PUSH
15282: LD_INT 148
15284: PUSH
15285: LD_INT 47
15287: PUSH
15288: EMPTY
15289: LIST
15290: LIST
15291: PUSH
15292: LD_INT 155
15294: PUSH
15295: LD_INT 16
15297: PUSH
15298: EMPTY
15299: LIST
15300: LIST
15301: PUSH
15302: EMPTY
15303: LIST
15304: LIST
15305: LIST
15306: LIST
15307: ST_TO_ADDR
// if Difficulty = 1 then
15308: LD_OWVAR 67
15312: PUSH
15313: LD_INT 1
15315: EQUAL
15316: IFFALSE 15353
// tmp := tmp ^ [ [ 78 , 7 ] , [ 104 , 43 ] ] ;
15318: LD_ADDR_VAR 0 4
15322: PUSH
15323: LD_VAR 0 4
15327: PUSH
15328: LD_INT 78
15330: PUSH
15331: LD_INT 7
15333: PUSH
15334: EMPTY
15335: LIST
15336: LIST
15337: PUSH
15338: LD_INT 104
15340: PUSH
15341: LD_INT 43
15343: PUSH
15344: EMPTY
15345: LIST
15346: LIST
15347: PUSH
15348: EMPTY
15349: LIST
15350: LIST
15351: ADD
15352: ST_TO_ADDR
// for i in tmp do
15353: LD_ADDR_VAR 0 2
15357: PUSH
15358: LD_VAR 0 4
15362: PUSH
15363: FOR_IN
15364: IFFALSE 15397
// PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 9 ) ;
15366: LD_VAR 0 2
15370: PUSH
15371: LD_INT 1
15373: ARRAY
15374: PPUSH
15375: LD_VAR 0 2
15379: PUSH
15380: LD_INT 2
15382: ARRAY
15383: PPUSH
15384: LD_INT 1
15386: PPUSH
15387: LD_INT 9
15389: NEG
15390: PPUSH
15391: CALL_OW 330
15395: GO 15363
15397: POP
15398: POP
// SetAchievement ( ACH_FRIEND ) ;
15399: LD_STRING ACH_FRIEND
15401: PPUSH
15402: CALL_OW 543
// CenterOnXY ( 129 , 10 ) ;
15406: LD_INT 129
15408: PPUSH
15409: LD_INT 10
15411: PPUSH
15412: CALL_OW 84
// end ;
15416: PPOPN 5
15418: END
// every 0 0$1 trigger game_time - 10 10$00 <= tick do
15419: LD_EXP 15
15423: PUSH
15424: LD_INT 21000
15426: MINUS
15427: PUSH
15428: LD_OWVAR 1
15432: LESSEQUAL
15433: IFFALSE 15473
15435: GO 15437
15437: DISABLE
// begin powell_warn := true ;
15438: LD_ADDR_EXP 16
15442: PUSH
15443: LD_INT 1
15445: ST_TO_ADDR
// DialogueOn ;
15446: CALL_OW 6
// SayRadio ( Powell , D9-Pow-1 ) ;
15450: LD_EXP 30
15454: PPUSH
15455: LD_STRING D9-Pow-1
15457: PPUSH
15458: CALL_OW 94
// dwait ( 0 0$0.3 ) ;
15462: LD_INT 10
15464: PPUSH
15465: CALL_OW 68
// DialogueOff ;
15469: CALL_OW 7
// end ;
15473: END
// every 0 0$1 trigger game_time <= tick do
15474: LD_EXP 15
15478: PUSH
15479: LD_OWVAR 1
15483: LESSEQUAL
15484: IFFALSE 15523
15486: GO 15488
15488: DISABLE
// begin DialogueOn ;
15489: CALL_OW 6
// SayRadio ( Powell , D9a-Pow-1 ) ;
15493: LD_EXP 30
15497: PPUSH
15498: LD_STRING D9a-Pow-1
15500: PPUSH
15501: CALL_OW 94
// dwait ( 0 0$2 ) ;
15505: LD_INT 70
15507: PPUSH
15508: CALL_OW 68
// DialogueOff ;
15512: CALL_OW 7
// YouLost ( Command ) ;
15516: LD_STRING Command
15518: PPUSH
15519: CALL_OW 104
// end ;
15523: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_warehouse ] ] ) = 0 and IsOk ( JMM ) do
15524: LD_INT 22
15526: PUSH
15527: LD_INT 2
15529: PUSH
15530: EMPTY
15531: LIST
15532: LIST
15533: PUSH
15534: LD_INT 30
15536: PUSH
15537: LD_INT 1
15539: PUSH
15540: EMPTY
15541: LIST
15542: LIST
15543: PUSH
15544: EMPTY
15545: LIST
15546: LIST
15547: PPUSH
15548: CALL_OW 69
15552: PUSH
15553: LD_INT 0
15555: EQUAL
15556: PUSH
15557: LD_EXP 21
15561: PPUSH
15562: CALL_OW 302
15566: AND
15567: IFFALSE 15615
15569: GO 15571
15571: DISABLE
// begin case Query ( QEndMission ) of 1 :
15572: LD_STRING QEndMission
15574: PPUSH
15575: CALL_OW 97
15579: PUSH
15580: LD_INT 1
15582: DOUBLE
15583: EQUAL
15584: IFTRUE 15588
15586: GO 15599
15588: POP
// end_the_mission_allowed := true ; 2 :
15589: LD_ADDR_OWVAR 57
15593: PUSH
15594: LD_INT 1
15596: ST_TO_ADDR
15597: GO 15615
15599: LD_INT 2
15601: DOUBLE
15602: EQUAL
15603: IFTRUE 15607
15605: GO 15614
15607: POP
// EndMission ; end ;
15608: CALL 15623 0 0
15612: GO 15615
15614: POP
// end ;
15615: END
// on EndTheMissionRaised ( p ) do begin EndMission ;
15616: CALL 15623 0 0
// end ;
15620: PPOPN 1
15622: END
// function EndMission ; var tmp , m1 , m2 , m3 ; begin
15623: LD_INT 0
15625: PPUSH
15626: PPUSH
15627: PPUSH
15628: PPUSH
15629: PPUSH
// m1 := false ;
15630: LD_ADDR_VAR 0 3
15634: PUSH
15635: LD_INT 0
15637: ST_TO_ADDR
// m2 := false ;
15638: LD_ADDR_VAR 0 4
15642: PUSH
15643: LD_INT 0
15645: ST_TO_ADDR
// m3 := false ;
15646: LD_ADDR_VAR 0 5
15650: PUSH
15651: LD_INT 0
15653: ST_TO_ADDR
// if not am_veh_consturcted then
15654: LD_EXP 20
15658: NOT
15659: IFFALSE 15668
// SetAchievement ( ACH_ARABTECH ) ;
15661: LD_STRING ACH_ARABTECH
15663: PPUSH
15664: CALL_OW 543
// if tick < [ 120 120$00 , 100 100$00 , 95 95$00 , 92 92$00 ] [ Difficulty ] then
15668: LD_OWVAR 1
15672: PUSH
15673: LD_INT 252000
15675: PUSH
15676: LD_INT 210000
15678: PUSH
15679: LD_INT 199500
15681: PUSH
15682: LD_INT 193200
15684: PUSH
15685: EMPTY
15686: LIST
15687: LIST
15688: LIST
15689: LIST
15690: PUSH
15691: LD_OWVAR 67
15695: ARRAY
15696: LESS
15697: IFFALSE 15719
// begin m3 := true ;
15699: LD_ADDR_VAR 0 5
15703: PUSH
15704: LD_INT 1
15706: ST_TO_ADDR
// AddMedal ( Time1 , 1 ) ;
15707: LD_STRING Time1
15709: PPUSH
15710: LD_INT 1
15712: PPUSH
15713: CALL_OW 101
// end else
15717: GO 15750
// if not powell_warn then
15719: LD_EXP 16
15723: NOT
15724: IFFALSE 15739
// AddMedal ( Time1 , - 1 ) else
15726: LD_STRING Time1
15728: PPUSH
15729: LD_INT 1
15731: NEG
15732: PPUSH
15733: CALL_OW 101
15737: GO 15750
// AddMedal ( Time1 , - 2 ) ;
15739: LD_STRING Time1
15741: PPUSH
15742: LD_INT 2
15744: NEG
15745: PPUSH
15746: CALL_OW 101
// if loses_counter >= [ 5 , 4 , 3 , 3 ] [ Difficulty ] then
15750: LD_EXP 17
15754: PUSH
15755: LD_INT 5
15757: PUSH
15758: LD_INT 4
15760: PUSH
15761: LD_INT 3
15763: PUSH
15764: LD_INT 3
15766: PUSH
15767: EMPTY
15768: LIST
15769: LIST
15770: LIST
15771: LIST
15772: PUSH
15773: LD_OWVAR 67
15777: ARRAY
15778: GREATEREQUAL
15779: IFFALSE 15794
// AddMedal ( Destroy , - 2 ) else
15781: LD_STRING Destroy
15783: PPUSH
15784: LD_INT 2
15786: NEG
15787: PPUSH
15788: CALL_OW 101
15792: GO 15927
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 25 then
15794: LD_INT 22
15796: PUSH
15797: LD_INT 2
15799: PUSH
15800: EMPTY
15801: LIST
15802: LIST
15803: PUSH
15804: LD_INT 21
15806: PUSH
15807: LD_INT 3
15809: PUSH
15810: EMPTY
15811: LIST
15812: LIST
15813: PUSH
15814: LD_INT 50
15816: PUSH
15817: EMPTY
15818: LIST
15819: PUSH
15820: EMPTY
15821: LIST
15822: LIST
15823: LIST
15824: PPUSH
15825: CALL_OW 69
15829: PUSH
15830: LD_INT 25
15832: GREATEREQUAL
15833: IFFALSE 15848
// AddMedal ( Destroy , - 1 ) else
15835: LD_STRING Destroy
15837: PPUSH
15838: LD_INT 1
15840: NEG
15841: PPUSH
15842: CALL_OW 101
15846: GO 15927
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 15 then
15848: LD_INT 22
15850: PUSH
15851: LD_INT 2
15853: PUSH
15854: EMPTY
15855: LIST
15856: LIST
15857: PUSH
15858: LD_INT 21
15860: PUSH
15861: LD_INT 3
15863: PUSH
15864: EMPTY
15865: LIST
15866: LIST
15867: PUSH
15868: LD_INT 50
15870: PUSH
15871: EMPTY
15872: LIST
15873: PUSH
15874: EMPTY
15875: LIST
15876: LIST
15877: LIST
15878: PPUSH
15879: CALL_OW 69
15883: PUSH
15884: LD_INT 15
15886: GREATEREQUAL
15887: IFFALSE 15909
// begin m1 := true ;
15889: LD_ADDR_VAR 0 3
15893: PUSH
15894: LD_INT 1
15896: ST_TO_ADDR
// AddMedal ( Destroy , 1 ) ;
15897: LD_STRING Destroy
15899: PPUSH
15900: LD_INT 1
15902: PPUSH
15903: CALL_OW 101
// end else
15907: GO 15927
// begin m1 := true ;
15909: LD_ADDR_VAR 0 3
15913: PUSH
15914: LD_INT 1
15916: ST_TO_ADDR
// AddMedal ( Destroy , 2 ) ;
15917: LD_STRING Destroy
15919: PPUSH
15920: LD_INT 2
15922: PPUSH
15923: CALL_OW 101
// end ; SaveVariable ( artifact_get , 11_artifact_captured ) ;
15927: LD_EXP 13
15931: PPUSH
15932: LD_STRING 11_artifact_captured
15934: PPUSH
15935: CALL_OW 39
// if artifact_get then
15939: LD_EXP 13
15943: IFFALSE 15965
// begin m2 := true ;
15945: LD_ADDR_VAR 0 4
15949: PUSH
15950: LD_INT 1
15952: ST_TO_ADDR
// AddMedal ( Artefact , 1 ) ;
15953: LD_STRING Artefact
15955: PPUSH
15956: LD_INT 1
15958: PPUSH
15959: CALL_OW 101
// end else
15963: GO 15976
// AddMedal ( Artefact , - 1 ) ;
15965: LD_STRING Artefact
15967: PPUSH
15968: LD_INT 1
15970: NEG
15971: PPUSH
15972: CALL_OW 101
// if m1 and m2 and m3 and Difficulty >= 3 then
15976: LD_VAR 0 3
15980: PUSH
15981: LD_VAR 0 4
15985: AND
15986: PUSH
15987: LD_VAR 0 5
15991: AND
15992: PUSH
15993: LD_OWVAR 67
15997: PUSH
15998: LD_INT 3
16000: GREATEREQUAL
16001: AND
16002: IFFALSE 16014
// SetAchievementEX ( ACH_AMER , 11 ) ;
16004: LD_STRING ACH_AMER
16006: PPUSH
16007: LD_INT 11
16009: PPUSH
16010: CALL_OW 564
// if m1 and m2 and m3 and loses_counter = 0 then
16014: LD_VAR 0 3
16018: PUSH
16019: LD_VAR 0 4
16023: AND
16024: PUSH
16025: LD_VAR 0 5
16029: AND
16030: PUSH
16031: LD_EXP 17
16035: PUSH
16036: LD_INT 0
16038: EQUAL
16039: AND
16040: IFFALSE 16056
// begin wait ( 3 ) ;
16042: LD_INT 3
16044: PPUSH
16045: CALL_OW 67
// SetAchievement ( ACH_GENERAL ) ;
16049: LD_STRING ACH_GENERAL
16051: PPUSH
16052: CALL_OW 543
// end ; if tick <= 100 100$00 then
16056: LD_OWVAR 1
16060: PUSH
16061: LD_INT 210000
16063: LESSEQUAL
16064: IFFALSE 16080
// begin wait ( 3 ) ;
16066: LD_INT 3
16068: PPUSH
16069: CALL_OW 67
// SetAchievement ( ACH_ASPEED_11 ) ;
16073: LD_STRING ACH_ASPEED_11
16075: PPUSH
16076: CALL_OW 543
// end ; GiveMedals ( MAIN ) ;
16080: LD_STRING MAIN
16082: PPUSH
16083: CALL_OW 102
// selected := UnitFilter ( selected , [ f_alive ] ) ;
16087: LD_ADDR_EXP 19
16091: PUSH
16092: LD_EXP 19
16096: PPUSH
16097: LD_INT 51
16099: PUSH
16100: EMPTY
16101: LIST
16102: PPUSH
16103: CALL_OW 72
16107: ST_TO_ADDR
// tmp := JMM ^ selected ;
16108: LD_ADDR_VAR 0 2
16112: PUSH
16113: LD_EXP 21
16117: PUSH
16118: LD_EXP 19
16122: ADD
16123: ST_TO_ADDR
// RewardPeople ( tmp ) ;
16124: LD_VAR 0 2
16128: PPUSH
16129: CALL_OW 43
// SaveCharacters ( tmp diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , 11c_others ) ;
16133: LD_VAR 0 2
16137: PUSH
16138: LD_EXP 21
16142: PUSH
16143: LD_EXP 22
16147: PUSH
16148: LD_EXP 23
16152: PUSH
16153: LD_EXP 24
16157: PUSH
16158: LD_EXP 25
16162: PUSH
16163: LD_EXP 26
16167: PUSH
16168: LD_EXP 27
16172: PUSH
16173: LD_EXP 28
16177: PUSH
16178: LD_EXP 29
16182: PUSH
16183: LD_EXP 31
16187: PUSH
16188: LD_EXP 32
16192: PUSH
16193: LD_EXP 33
16197: PUSH
16198: LD_EXP 34
16202: PUSH
16203: EMPTY
16204: LIST
16205: LIST
16206: LIST
16207: LIST
16208: LIST
16209: LIST
16210: LIST
16211: LIST
16212: LIST
16213: LIST
16214: LIST
16215: LIST
16216: LIST
16217: DIFF
16218: PPUSH
16219: LD_STRING 11c_others
16221: PPUSH
16222: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
16226: LD_EXP 21
16230: PPUSH
16231: LD_EXP 3
16235: PUSH
16236: LD_STRING JMM
16238: STR
16239: PPUSH
16240: CALL_OW 38
// if Lisa then
16244: LD_EXP 22
16248: IFFALSE 16268
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
16250: LD_EXP 22
16254: PPUSH
16255: LD_EXP 3
16259: PUSH
16260: LD_STRING Lisa
16262: STR
16263: PPUSH
16264: CALL_OW 38
// if Donaldson then
16268: LD_EXP 23
16272: IFFALSE 16292
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
16274: LD_EXP 23
16278: PPUSH
16279: LD_EXP 3
16283: PUSH
16284: LD_STRING Donaldson
16286: STR
16287: PPUSH
16288: CALL_OW 38
// if Bobby then
16292: LD_EXP 24
16296: IFFALSE 16316
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
16298: LD_EXP 24
16302: PPUSH
16303: LD_EXP 3
16307: PUSH
16308: LD_STRING Bobby
16310: STR
16311: PPUSH
16312: CALL_OW 38
// if Cyrus then
16316: LD_EXP 25
16320: IFFALSE 16340
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
16322: LD_EXP 25
16326: PPUSH
16327: LD_EXP 3
16331: PUSH
16332: LD_STRING Cyrus
16334: STR
16335: PPUSH
16336: CALL_OW 38
// if Denis then
16340: LD_EXP 26
16344: IFFALSE 16364
// SaveCharacters ( Denis , mission_prefix & Denis ) ;
16346: LD_EXP 26
16350: PPUSH
16351: LD_EXP 3
16355: PUSH
16356: LD_STRING Denis
16358: STR
16359: PPUSH
16360: CALL_OW 38
// if Brown then
16364: LD_EXP 27
16368: IFFALSE 16388
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
16370: LD_EXP 27
16374: PPUSH
16375: LD_EXP 3
16379: PUSH
16380: LD_STRING Brown
16382: STR
16383: PPUSH
16384: CALL_OW 38
// if Gladstone then
16388: LD_EXP 28
16392: IFFALSE 16412
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
16394: LD_EXP 28
16398: PPUSH
16399: LD_EXP 3
16403: PUSH
16404: LD_STRING Gladstone
16406: STR
16407: PPUSH
16408: CALL_OW 38
// if Houten then
16412: LD_EXP 29
16416: IFFALSE 16436
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
16418: LD_EXP 29
16422: PPUSH
16423: LD_EXP 3
16427: PUSH
16428: LD_STRING Houten
16430: STR
16431: PPUSH
16432: CALL_OW 38
// if Cornel then
16436: LD_EXP 31
16440: IFFALSE 16460
// SaveCharacters ( Cornel , mission_prefix & Cornell ) ;
16442: LD_EXP 31
16446: PPUSH
16447: LD_EXP 3
16451: PUSH
16452: LD_STRING Cornell
16454: STR
16455: PPUSH
16456: CALL_OW 38
// if Gary then
16460: LD_EXP 32
16464: IFFALSE 16484
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
16466: LD_EXP 32
16470: PPUSH
16471: LD_EXP 3
16475: PUSH
16476: LD_STRING Gary
16478: STR
16479: PPUSH
16480: CALL_OW 38
// if Frank then
16484: LD_EXP 33
16488: IFFALSE 16508
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
16490: LD_EXP 33
16494: PPUSH
16495: LD_EXP 3
16499: PUSH
16500: LD_STRING Frank
16502: STR
16503: PPUSH
16504: CALL_OW 38
// if Kikuchi then
16508: LD_EXP 34
16512: IFFALSE 16532
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
16514: LD_EXP 34
16518: PPUSH
16519: LD_EXP 3
16523: PUSH
16524: LD_STRING Kikuchi
16526: STR
16527: PPUSH
16528: CALL_OW 38
// YouWin ;
16532: CALL_OW 103
// end ;
16536: LD_VAR 0 1
16540: RET
// export function CanSayRand ( side ) ; begin
16541: LD_INT 0
16543: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16544: LD_ADDR_VAR 0 2
16548: PUSH
16549: LD_INT 52
16551: PUSH
16552: EMPTY
16553: LIST
16554: PUSH
16555: LD_INT 22
16557: PUSH
16558: LD_VAR 0 1
16562: PUSH
16563: EMPTY
16564: LIST
16565: LIST
16566: PUSH
16567: LD_INT 2
16569: PUSH
16570: LD_INT 25
16572: PUSH
16573: LD_INT 1
16575: PUSH
16576: EMPTY
16577: LIST
16578: LIST
16579: PUSH
16580: LD_INT 25
16582: PUSH
16583: LD_INT 2
16585: PUSH
16586: EMPTY
16587: LIST
16588: LIST
16589: PUSH
16590: LD_INT 25
16592: PUSH
16593: LD_INT 3
16595: PUSH
16596: EMPTY
16597: LIST
16598: LIST
16599: PUSH
16600: LD_INT 25
16602: PUSH
16603: LD_INT 4
16605: PUSH
16606: EMPTY
16607: LIST
16608: LIST
16609: PUSH
16610: EMPTY
16611: LIST
16612: LIST
16613: LIST
16614: LIST
16615: LIST
16616: PUSH
16617: EMPTY
16618: LIST
16619: LIST
16620: LIST
16621: PPUSH
16622: CALL_OW 69
16626: PUSH
16627: LD_EXP 21
16631: PUSH
16632: LD_EXP 33
16636: PUSH
16637: LD_EXP 22
16641: PUSH
16642: LD_EXP 23
16646: PUSH
16647: LD_EXP 24
16651: PUSH
16652: LD_EXP 25
16656: PUSH
16657: LD_EXP 26
16661: PUSH
16662: LD_EXP 27
16666: PUSH
16667: LD_EXP 28
16671: PUSH
16672: LD_EXP 29
16676: PUSH
16677: LD_EXP 30
16681: PUSH
16682: LD_EXP 31
16686: PUSH
16687: LD_EXP 32
16691: PUSH
16692: LD_EXP 34
16696: PUSH
16697: EMPTY
16698: LIST
16699: LIST
16700: LIST
16701: LIST
16702: LIST
16703: LIST
16704: LIST
16705: LIST
16706: LIST
16707: LIST
16708: LIST
16709: LIST
16710: LIST
16711: LIST
16712: DIFF
16713: ST_TO_ADDR
// end ;
16714: LD_VAR 0 2
16718: RET
// export function SayRand ( sex , dial ) ; begin
16719: LD_INT 0
16721: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16722: LD_ADDR_VAR 0 3
16726: PUSH
16727: LD_INT 52
16729: PUSH
16730: EMPTY
16731: LIST
16732: PUSH
16733: LD_INT 22
16735: PUSH
16736: LD_INT 1
16738: PUSH
16739: EMPTY
16740: LIST
16741: LIST
16742: PUSH
16743: LD_INT 26
16745: PUSH
16746: LD_VAR 0 1
16750: PUSH
16751: EMPTY
16752: LIST
16753: LIST
16754: PUSH
16755: LD_INT 2
16757: PUSH
16758: LD_INT 25
16760: PUSH
16761: LD_INT 1
16763: PUSH
16764: EMPTY
16765: LIST
16766: LIST
16767: PUSH
16768: LD_INT 25
16770: PUSH
16771: LD_INT 2
16773: PUSH
16774: EMPTY
16775: LIST
16776: LIST
16777: PUSH
16778: LD_INT 25
16780: PUSH
16781: LD_INT 3
16783: PUSH
16784: EMPTY
16785: LIST
16786: LIST
16787: PUSH
16788: LD_INT 25
16790: PUSH
16791: LD_INT 4
16793: PUSH
16794: EMPTY
16795: LIST
16796: LIST
16797: PUSH
16798: EMPTY
16799: LIST
16800: LIST
16801: LIST
16802: LIST
16803: LIST
16804: PUSH
16805: EMPTY
16806: LIST
16807: LIST
16808: LIST
16809: LIST
16810: PPUSH
16811: CALL_OW 69
16815: PUSH
16816: LD_EXP 21
16820: PUSH
16821: LD_EXP 33
16825: PUSH
16826: LD_EXP 22
16830: PUSH
16831: LD_EXP 23
16835: PUSH
16836: LD_EXP 24
16840: PUSH
16841: LD_EXP 25
16845: PUSH
16846: LD_EXP 26
16850: PUSH
16851: LD_EXP 27
16855: PUSH
16856: LD_EXP 28
16860: PUSH
16861: LD_EXP 29
16865: PUSH
16866: LD_EXP 30
16870: PUSH
16871: LD_EXP 31
16875: PUSH
16876: LD_EXP 32
16880: PUSH
16881: LD_EXP 34
16885: PUSH
16886: EMPTY
16887: LIST
16888: LIST
16889: LIST
16890: LIST
16891: LIST
16892: LIST
16893: LIST
16894: LIST
16895: LIST
16896: LIST
16897: LIST
16898: LIST
16899: LIST
16900: LIST
16901: DIFF
16902: ST_TO_ADDR
// if not result then
16903: LD_VAR 0 3
16907: NOT
16908: IFFALSE 16912
// exit ;
16910: GO 16940
// result := result [ 1 ] ;
16912: LD_ADDR_VAR 0 3
16916: PUSH
16917: LD_VAR 0 3
16921: PUSH
16922: LD_INT 1
16924: ARRAY
16925: ST_TO_ADDR
// Say ( result , dial ) ;
16926: LD_VAR 0 3
16930: PPUSH
16931: LD_VAR 0 2
16935: PPUSH
16936: CALL_OW 88
// end ;
16940: LD_VAR 0 3
16944: RET
// export function SayRand2 ( sex , dial , filter ) ; begin
16945: LD_INT 0
16947: PPUSH
// result := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ^ filter ;
16948: LD_ADDR_VAR 0 4
16952: PUSH
16953: LD_INT 22
16955: PUSH
16956: LD_INT 1
16958: PUSH
16959: EMPTY
16960: LIST
16961: LIST
16962: PUSH
16963: LD_INT 26
16965: PUSH
16966: LD_VAR 0 1
16970: PUSH
16971: EMPTY
16972: LIST
16973: LIST
16974: PUSH
16975: LD_INT 2
16977: PUSH
16978: LD_INT 25
16980: PUSH
16981: LD_INT 1
16983: PUSH
16984: EMPTY
16985: LIST
16986: LIST
16987: PUSH
16988: LD_INT 25
16990: PUSH
16991: LD_INT 2
16993: PUSH
16994: EMPTY
16995: LIST
16996: LIST
16997: PUSH
16998: LD_INT 25
17000: PUSH
17001: LD_INT 3
17003: PUSH
17004: EMPTY
17005: LIST
17006: LIST
17007: PUSH
17008: LD_INT 25
17010: PUSH
17011: LD_INT 4
17013: PUSH
17014: EMPTY
17015: LIST
17016: LIST
17017: PUSH
17018: EMPTY
17019: LIST
17020: LIST
17021: LIST
17022: LIST
17023: LIST
17024: PUSH
17025: EMPTY
17026: LIST
17027: LIST
17028: LIST
17029: PPUSH
17030: CALL_OW 69
17034: PUSH
17035: LD_EXP 21
17039: PUSH
17040: LD_EXP 33
17044: PUSH
17045: LD_EXP 22
17049: PUSH
17050: LD_EXP 23
17054: PUSH
17055: LD_EXP 24
17059: PUSH
17060: LD_EXP 25
17064: PUSH
17065: LD_EXP 26
17069: PUSH
17070: LD_EXP 27
17074: PUSH
17075: LD_EXP 28
17079: PUSH
17080: LD_EXP 29
17084: PUSH
17085: LD_EXP 30
17089: PUSH
17090: LD_EXP 31
17094: PUSH
17095: LD_EXP 32
17099: PUSH
17100: LD_EXP 34
17104: PUSH
17105: EMPTY
17106: LIST
17107: LIST
17108: LIST
17109: LIST
17110: LIST
17111: LIST
17112: LIST
17113: LIST
17114: LIST
17115: LIST
17116: LIST
17117: LIST
17118: LIST
17119: LIST
17120: PUSH
17121: LD_VAR 0 3
17125: ADD
17126: DIFF
17127: ST_TO_ADDR
// if not result then
17128: LD_VAR 0 4
17132: NOT
17133: IFFALSE 17137
// exit ;
17135: GO 17165
// result := result [ 1 ] ;
17137: LD_ADDR_VAR 0 4
17141: PUSH
17142: LD_VAR 0 4
17146: PUSH
17147: LD_INT 1
17149: ARRAY
17150: ST_TO_ADDR
// Say ( result , dial ) ;
17151: LD_VAR 0 4
17155: PPUSH
17156: LD_VAR 0 2
17160: PPUSH
17161: CALL_OW 88
// end ; end_of_file
17165: LD_VAR 0 4
17169: RET
// export function CustomEvent ( event ) ; begin
17170: LD_INT 0
17172: PPUSH
// end ;
17173: LD_VAR 0 2
17177: RET
// on ArtifactLoaded ( cargo , artifact ) do begin if GetSide ( cargo ) = 1 then
17178: LD_VAR 0 1
17182: PPUSH
17183: CALL_OW 255
17187: PUSH
17188: LD_INT 1
17190: EQUAL
17191: IFFALSE 17201
// artifact_get := true ;
17193: LD_ADDR_EXP 13
17197: PUSH
17198: LD_INT 1
17200: ST_TO_ADDR
// if GetSide ( cargo ) = 2 then
17201: LD_VAR 0 1
17205: PPUSH
17206: CALL_OW 255
17210: PUSH
17211: LD_INT 2
17213: EQUAL
17214: IFFALSE 17232
// begin artifact_get := false ;
17216: LD_ADDR_EXP 13
17220: PUSH
17221: LD_INT 0
17223: ST_TO_ADDR
// artifact_stolen := true ;
17224: LD_ADDR_EXP 12
17228: PUSH
17229: LD_INT 1
17231: ST_TO_ADDR
// end ; artifact_oncargo := true ;
17232: LD_ADDR_EXP 14
17236: PUSH
17237: LD_INT 1
17239: ST_TO_ADDR
// end ;
17240: PPOPN 2
17242: END
// on ArtifactUnloaded ( cargo , artifact ) do begin artifact_oncargo := false ;
17243: LD_ADDR_EXP 14
17247: PUSH
17248: LD_INT 0
17250: ST_TO_ADDR
// end ;
17251: PPOPN 2
17253: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
17254: LD_VAR 0 1
17258: PPUSH
17259: CALL 105909 0 1
// if un = JMM then
17263: LD_VAR 0 1
17267: PUSH
17268: LD_EXP 21
17272: EQUAL
17273: IFFALSE 17284
// begin YouLost ( JMM ) ;
17275: LD_STRING JMM
17277: PPUSH
17278: CALL_OW 104
// exit ;
17282: GO 17416
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) then
17284: LD_VAR 0 1
17288: PUSH
17289: LD_INT 22
17291: PUSH
17292: LD_INT 1
17294: PUSH
17295: EMPTY
17296: LIST
17297: LIST
17298: PUSH
17299: LD_INT 21
17301: PUSH
17302: LD_INT 1
17304: PUSH
17305: EMPTY
17306: LIST
17307: LIST
17308: PUSH
17309: LD_INT 2
17311: PUSH
17312: LD_INT 25
17314: PUSH
17315: LD_INT 1
17317: PUSH
17318: EMPTY
17319: LIST
17320: LIST
17321: PUSH
17322: LD_INT 25
17324: PUSH
17325: LD_INT 2
17327: PUSH
17328: EMPTY
17329: LIST
17330: LIST
17331: PUSH
17332: LD_INT 25
17334: PUSH
17335: LD_INT 3
17337: PUSH
17338: EMPTY
17339: LIST
17340: LIST
17341: PUSH
17342: LD_INT 25
17344: PUSH
17345: LD_INT 4
17347: PUSH
17348: EMPTY
17349: LIST
17350: LIST
17351: PUSH
17352: LD_INT 25
17354: PUSH
17355: LD_INT 5
17357: PUSH
17358: EMPTY
17359: LIST
17360: LIST
17361: PUSH
17362: LD_INT 25
17364: PUSH
17365: LD_INT 8
17367: PUSH
17368: EMPTY
17369: LIST
17370: LIST
17371: PUSH
17372: EMPTY
17373: LIST
17374: LIST
17375: LIST
17376: LIST
17377: LIST
17378: LIST
17379: LIST
17380: PUSH
17381: EMPTY
17382: LIST
17383: LIST
17384: LIST
17385: PPUSH
17386: CALL_OW 69
17390: IN
17391: IFFALSE 17407
// loses_counter := loses_counter + 1 ;
17393: LD_ADDR_EXP 17
17397: PUSH
17398: LD_EXP 17
17402: PUSH
17403: LD_INT 1
17405: PLUS
17406: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
17407: LD_VAR 0 1
17411: PPUSH
17412: CALL 45710 0 1
// end ;
17416: PPOPN 1
17418: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
17419: LD_VAR 0 1
17423: PPUSH
17424: LD_VAR 0 2
17428: PPUSH
17429: CALL 48042 0 2
// end ;
17433: PPOPN 2
17435: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
17436: LD_VAR 0 1
17440: PPUSH
17441: CALL 47351 0 1
// end ;
17445: PPOPN 1
17447: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
17448: LD_VAR 0 1
17452: PPUSH
17453: LD_VAR 0 2
17457: PPUSH
17458: LD_VAR 0 3
17462: PPUSH
17463: LD_VAR 0 4
17467: PPUSH
17468: LD_VAR 0 5
17472: PPUSH
17473: CALL 45026 0 5
// end ;
17477: PPOPN 5
17479: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
17480: LD_VAR 0 1
17484: PPUSH
17485: LD_VAR 0 2
17489: PPUSH
17490: CALL 106029 0 2
// if GetNation ( vehicle ) = nation_american then
17494: LD_VAR 0 1
17498: PPUSH
17499: CALL_OW 248
17503: PUSH
17504: LD_INT 1
17506: EQUAL
17507: IFFALSE 17517
// am_veh_consturcted := true ;
17509: LD_ADDR_EXP 20
17513: PUSH
17514: LD_INT 1
17516: ST_TO_ADDR
// MCE_VehicleConstructed ( vehicle , factory ) ;
17517: LD_VAR 0 1
17521: PPUSH
17522: LD_VAR 0 2
17526: PPUSH
17527: CALL 44579 0 2
// end ;
17531: PPOPN 2
17533: END
// on UnitKamikazed ( unit ) do begin if GetType ( unit ) = unit_vehicle then
17534: LD_VAR 0 1
17538: PPUSH
17539: CALL_OW 247
17543: PUSH
17544: LD_INT 2
17546: EQUAL
17547: IFFALSE 17551
// exit ;
17549: GO 17568
// if not kamikazed then
17551: LD_EXP 11
17555: NOT
17556: IFFALSE 17568
// kamikazed := unit ;
17558: LD_ADDR_EXP 11
17562: PUSH
17563: LD_VAR 0 1
17567: ST_TO_ADDR
// end ;
17568: PPOPN 1
17570: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do var i , tmp ;
17571: LD_INT 0
17573: PPUSH
17574: PPUSH
// begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
17575: LD_VAR 0 1
17579: PPUSH
17580: LD_VAR 0 2
17584: PPUSH
17585: LD_VAR 0 3
17589: PPUSH
17590: LD_VAR 0 4
17594: PPUSH
17595: CALL 44417 0 4
// end ;
17599: PPOPN 6
17601: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
17602: LD_VAR 0 1
17606: PPUSH
17607: LD_VAR 0 2
17611: PPUSH
17612: LD_VAR 0 3
17616: PPUSH
17617: CALL 44192 0 3
// end ;
17621: PPOPN 3
17623: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
17624: LD_VAR 0 1
17628: PPUSH
17629: LD_VAR 0 2
17633: PPUSH
17634: CALL 45406 0 2
// end ;
17638: PPOPN 2
17640: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
17641: LD_VAR 0 1
17645: PPUSH
17646: LD_VAR 0 2
17650: PPUSH
17651: CALL 43886 0 2
// end ;
17655: PPOPN 2
17657: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
17658: LD_VAR 0 1
17662: PPUSH
17663: LD_VAR 0 2
17667: PPUSH
17668: CALL 44077 0 2
// end ;
17672: PPOPN 2
17674: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
17675: LD_VAR 0 1
17679: PPUSH
17680: CALL 47110 0 1
// end ;
17684: PPOPN 1
17686: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
17687: LD_VAR 0 1
17691: PPUSH
17692: LD_VAR 0 2
17696: PPUSH
17697: CALL 48337 0 2
// end ;
17701: PPOPN 2
17703: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
17704: LD_VAR 0 1
17708: PPUSH
17709: LD_VAR 0 2
17713: PPUSH
17714: LD_VAR 0 3
17718: PPUSH
17719: LD_VAR 0 4
17723: PPUSH
17724: CALL 48553 0 4
// end ;
17728: PPOPN 4
17730: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
17731: LD_VAR 0 1
17735: PPUSH
17736: CALL 106013 0 1
// end ; end_of_file
17740: PPOPN 1
17742: END
// every 0 0$1 trigger game do
17743: LD_EXP 2
17747: IFFALSE 17777
17749: GO 17751
17751: DISABLE
// SpawnCrates ( [ crates_west , crates_east , crates_north_west , crates_east ] , 0 0$50 ) ;
17752: LD_INT 7
17754: PUSH
17755: LD_INT 6
17757: PUSH
17758: LD_INT 4
17760: PUSH
17761: LD_INT 6
17763: PUSH
17764: EMPTY
17765: LIST
17766: LIST
17767: LIST
17768: LIST
17769: PPUSH
17770: LD_INT 1750
17772: PPUSH
17773: CALL 17778 0 2
17777: END
// export function SpawnCrates ( areas , time ) ; var i , p ; begin
17778: LD_INT 0
17780: PPUSH
17781: PPUSH
17782: PPUSH
// if not areas then
17783: LD_VAR 0 1
17787: NOT
17788: IFFALSE 17792
// exit ;
17790: GO 17922
// repeat wait ( time ) ;
17792: LD_VAR 0 2
17796: PPUSH
17797: CALL_OW 67
// for i in areas do
17801: LD_ADDR_VAR 0 4
17805: PUSH
17806: LD_VAR 0 1
17810: PUSH
17811: FOR_IN
17812: IFFALSE 17881
// begin p := rand ( 1 , 90 ) ;
17814: LD_ADDR_VAR 0 5
17818: PUSH
17819: LD_INT 1
17821: PPUSH
17822: LD_INT 90
17824: PPUSH
17825: CALL_OW 12
17829: ST_TO_ADDR
// if Prob ( p ) then
17830: LD_VAR 0 5
17834: PPUSH
17835: CALL_OW 13
17839: IFFALSE 17879
// begin CreateCratesArea ( rand ( 2 , 5 ) , i , true ) ;
17841: LD_INT 2
17843: PPUSH
17844: LD_INT 5
17846: PPUSH
17847: CALL_OW 12
17851: PPUSH
17852: LD_VAR 0 4
17856: PPUSH
17857: LD_INT 1
17859: PPUSH
17860: CALL_OW 55
// wait ( rand ( 0 0$21 , 0 0$37 ) ) ;
17864: LD_INT 735
17866: PPUSH
17867: LD_INT 1295
17869: PPUSH
17870: CALL_OW 12
17874: PPUSH
17875: CALL_OW 67
// end ; end ;
17879: GO 17811
17881: POP
17882: POP
// time := time + 0 0$3 ;
17883: LD_ADDR_VAR 0 2
17887: PUSH
17888: LD_VAR 0 2
17892: PUSH
17893: LD_INT 105
17895: PLUS
17896: ST_TO_ADDR
// if time > 6 6$00 then
17897: LD_VAR 0 2
17901: PUSH
17902: LD_INT 12600
17904: GREATER
17905: IFFALSE 17915
// time := 0 0$40 ;
17907: LD_ADDR_VAR 0 2
17911: PUSH
17912: LD_INT 1400
17914: ST_TO_ADDR
// until not game ;
17915: LD_EXP 2
17919: NOT
17920: IFFALSE 17792
// end ;
17922: LD_VAR 0 3
17926: RET
// every 0 0$45 + 3 3$00 trigger tick < [ 40 40$00 , 35 35$00 , 30 30$00 , 25 25$00 ] [ Difficulty ] do
17927: LD_OWVAR 1
17931: PUSH
17932: LD_INT 84000
17934: PUSH
17935: LD_INT 73500
17937: PUSH
17938: LD_INT 63000
17940: PUSH
17941: LD_INT 52500
17943: PUSH
17944: EMPTY
17945: LIST
17946: LIST
17947: LIST
17948: LIST
17949: PUSH
17950: LD_OWVAR 67
17954: ARRAY
17955: LESS
17956: IFFALSE 17983
17958: GO 17960
17960: DISABLE
// begin enable ;
17961: ENABLE
// CreateCratesArea ( rand ( 1 , 5 ) , crates_west , true ) ;
17962: LD_INT 1
17964: PPUSH
17965: LD_INT 5
17967: PPUSH
17968: CALL_OW 12
17972: PPUSH
17973: LD_INT 7
17975: PPUSH
17976: LD_INT 1
17978: PPUSH
17979: CALL_OW 55
// end ; end_of_file
17983: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
17984: LD_INT 0
17986: PPUSH
17987: PPUSH
// skirmish := false ;
17988: LD_ADDR_EXP 48
17992: PUSH
17993: LD_INT 0
17995: ST_TO_ADDR
// debug_mc := false ;
17996: LD_ADDR_EXP 49
18000: PUSH
18001: LD_INT 0
18003: ST_TO_ADDR
// mc_bases := [ ] ;
18004: LD_ADDR_EXP 50
18008: PUSH
18009: EMPTY
18010: ST_TO_ADDR
// mc_sides := [ ] ;
18011: LD_ADDR_EXP 76
18015: PUSH
18016: EMPTY
18017: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
18018: LD_ADDR_EXP 51
18022: PUSH
18023: EMPTY
18024: ST_TO_ADDR
// mc_building_repairs := [ ] ;
18025: LD_ADDR_EXP 52
18029: PUSH
18030: EMPTY
18031: ST_TO_ADDR
// mc_need_heal := [ ] ;
18032: LD_ADDR_EXP 53
18036: PUSH
18037: EMPTY
18038: ST_TO_ADDR
// mc_healers := [ ] ;
18039: LD_ADDR_EXP 54
18043: PUSH
18044: EMPTY
18045: ST_TO_ADDR
// mc_build_list := [ ] ;
18046: LD_ADDR_EXP 55
18050: PUSH
18051: EMPTY
18052: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
18053: LD_ADDR_EXP 82
18057: PUSH
18058: EMPTY
18059: ST_TO_ADDR
// mc_builders := [ ] ;
18060: LD_ADDR_EXP 56
18064: PUSH
18065: EMPTY
18066: ST_TO_ADDR
// mc_construct_list := [ ] ;
18067: LD_ADDR_EXP 57
18071: PUSH
18072: EMPTY
18073: ST_TO_ADDR
// mc_turret_list := [ ] ;
18074: LD_ADDR_EXP 58
18078: PUSH
18079: EMPTY
18080: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
18081: LD_ADDR_EXP 59
18085: PUSH
18086: EMPTY
18087: ST_TO_ADDR
// mc_miners := [ ] ;
18088: LD_ADDR_EXP 64
18092: PUSH
18093: EMPTY
18094: ST_TO_ADDR
// mc_mines := [ ] ;
18095: LD_ADDR_EXP 63
18099: PUSH
18100: EMPTY
18101: ST_TO_ADDR
// mc_minefields := [ ] ;
18102: LD_ADDR_EXP 65
18106: PUSH
18107: EMPTY
18108: ST_TO_ADDR
// mc_crates := [ ] ;
18109: LD_ADDR_EXP 66
18113: PUSH
18114: EMPTY
18115: ST_TO_ADDR
// mc_crates_collector := [ ] ;
18116: LD_ADDR_EXP 67
18120: PUSH
18121: EMPTY
18122: ST_TO_ADDR
// mc_crates_area := [ ] ;
18123: LD_ADDR_EXP 68
18127: PUSH
18128: EMPTY
18129: ST_TO_ADDR
// mc_vehicles := [ ] ;
18130: LD_ADDR_EXP 69
18134: PUSH
18135: EMPTY
18136: ST_TO_ADDR
// mc_attack := [ ] ;
18137: LD_ADDR_EXP 70
18141: PUSH
18142: EMPTY
18143: ST_TO_ADDR
// mc_produce := [ ] ;
18144: LD_ADDR_EXP 71
18148: PUSH
18149: EMPTY
18150: ST_TO_ADDR
// mc_defender := [ ] ;
18151: LD_ADDR_EXP 72
18155: PUSH
18156: EMPTY
18157: ST_TO_ADDR
// mc_parking := [ ] ;
18158: LD_ADDR_EXP 74
18162: PUSH
18163: EMPTY
18164: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
18165: LD_ADDR_EXP 60
18169: PUSH
18170: EMPTY
18171: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
18172: LD_ADDR_EXP 62
18176: PUSH
18177: EMPTY
18178: ST_TO_ADDR
// mc_scan := [ ] ;
18179: LD_ADDR_EXP 73
18183: PUSH
18184: EMPTY
18185: ST_TO_ADDR
// mc_scan_area := [ ] ;
18186: LD_ADDR_EXP 75
18190: PUSH
18191: EMPTY
18192: ST_TO_ADDR
// mc_tech := [ ] ;
18193: LD_ADDR_EXP 77
18197: PUSH
18198: EMPTY
18199: ST_TO_ADDR
// mc_class := [ ] ;
18200: LD_ADDR_EXP 91
18204: PUSH
18205: EMPTY
18206: ST_TO_ADDR
// mc_class_case_use := [ ] ;
18207: LD_ADDR_EXP 92
18211: PUSH
18212: EMPTY
18213: ST_TO_ADDR
// mc_is_defending := [ ] ;
18214: LD_ADDR_EXP 93
18218: PUSH
18219: EMPTY
18220: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
18221: LD_ADDR_EXP 84
18225: PUSH
18226: EMPTY
18227: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
18228: LD_ADDR_EXP 94
18232: PUSH
18233: LD_INT 0
18235: ST_TO_ADDR
// end ;
18236: LD_VAR 0 1
18240: RET
// export function MC_Kill ( base ) ; begin
18241: LD_INT 0
18243: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
18244: LD_ADDR_EXP 50
18248: PUSH
18249: LD_EXP 50
18253: PPUSH
18254: LD_VAR 0 1
18258: PPUSH
18259: EMPTY
18260: PPUSH
18261: CALL_OW 1
18265: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
18266: LD_ADDR_EXP 51
18270: PUSH
18271: LD_EXP 51
18275: PPUSH
18276: LD_VAR 0 1
18280: PPUSH
18281: EMPTY
18282: PPUSH
18283: CALL_OW 1
18287: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
18288: LD_ADDR_EXP 52
18292: PUSH
18293: LD_EXP 52
18297: PPUSH
18298: LD_VAR 0 1
18302: PPUSH
18303: EMPTY
18304: PPUSH
18305: CALL_OW 1
18309: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
18310: LD_ADDR_EXP 53
18314: PUSH
18315: LD_EXP 53
18319: PPUSH
18320: LD_VAR 0 1
18324: PPUSH
18325: EMPTY
18326: PPUSH
18327: CALL_OW 1
18331: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
18332: LD_ADDR_EXP 54
18336: PUSH
18337: LD_EXP 54
18341: PPUSH
18342: LD_VAR 0 1
18346: PPUSH
18347: EMPTY
18348: PPUSH
18349: CALL_OW 1
18353: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
18354: LD_ADDR_EXP 55
18358: PUSH
18359: LD_EXP 55
18363: PPUSH
18364: LD_VAR 0 1
18368: PPUSH
18369: EMPTY
18370: PPUSH
18371: CALL_OW 1
18375: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
18376: LD_ADDR_EXP 56
18380: PUSH
18381: LD_EXP 56
18385: PPUSH
18386: LD_VAR 0 1
18390: PPUSH
18391: EMPTY
18392: PPUSH
18393: CALL_OW 1
18397: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
18398: LD_ADDR_EXP 57
18402: PUSH
18403: LD_EXP 57
18407: PPUSH
18408: LD_VAR 0 1
18412: PPUSH
18413: EMPTY
18414: PPUSH
18415: CALL_OW 1
18419: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
18420: LD_ADDR_EXP 58
18424: PUSH
18425: LD_EXP 58
18429: PPUSH
18430: LD_VAR 0 1
18434: PPUSH
18435: EMPTY
18436: PPUSH
18437: CALL_OW 1
18441: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
18442: LD_ADDR_EXP 59
18446: PUSH
18447: LD_EXP 59
18451: PPUSH
18452: LD_VAR 0 1
18456: PPUSH
18457: EMPTY
18458: PPUSH
18459: CALL_OW 1
18463: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
18464: LD_ADDR_EXP 60
18468: PUSH
18469: LD_EXP 60
18473: PPUSH
18474: LD_VAR 0 1
18478: PPUSH
18479: EMPTY
18480: PPUSH
18481: CALL_OW 1
18485: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
18486: LD_ADDR_EXP 61
18490: PUSH
18491: LD_EXP 61
18495: PPUSH
18496: LD_VAR 0 1
18500: PPUSH
18501: LD_INT 0
18503: PPUSH
18504: CALL_OW 1
18508: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
18509: LD_ADDR_EXP 62
18513: PUSH
18514: LD_EXP 62
18518: PPUSH
18519: LD_VAR 0 1
18523: PPUSH
18524: EMPTY
18525: PPUSH
18526: CALL_OW 1
18530: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
18531: LD_ADDR_EXP 63
18535: PUSH
18536: LD_EXP 63
18540: PPUSH
18541: LD_VAR 0 1
18545: PPUSH
18546: EMPTY
18547: PPUSH
18548: CALL_OW 1
18552: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
18553: LD_ADDR_EXP 64
18557: PUSH
18558: LD_EXP 64
18562: PPUSH
18563: LD_VAR 0 1
18567: PPUSH
18568: EMPTY
18569: PPUSH
18570: CALL_OW 1
18574: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
18575: LD_ADDR_EXP 65
18579: PUSH
18580: LD_EXP 65
18584: PPUSH
18585: LD_VAR 0 1
18589: PPUSH
18590: EMPTY
18591: PPUSH
18592: CALL_OW 1
18596: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
18597: LD_ADDR_EXP 66
18601: PUSH
18602: LD_EXP 66
18606: PPUSH
18607: LD_VAR 0 1
18611: PPUSH
18612: EMPTY
18613: PPUSH
18614: CALL_OW 1
18618: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
18619: LD_ADDR_EXP 67
18623: PUSH
18624: LD_EXP 67
18628: PPUSH
18629: LD_VAR 0 1
18633: PPUSH
18634: EMPTY
18635: PPUSH
18636: CALL_OW 1
18640: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
18641: LD_ADDR_EXP 68
18645: PUSH
18646: LD_EXP 68
18650: PPUSH
18651: LD_VAR 0 1
18655: PPUSH
18656: EMPTY
18657: PPUSH
18658: CALL_OW 1
18662: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
18663: LD_ADDR_EXP 69
18667: PUSH
18668: LD_EXP 69
18672: PPUSH
18673: LD_VAR 0 1
18677: PPUSH
18678: EMPTY
18679: PPUSH
18680: CALL_OW 1
18684: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
18685: LD_ADDR_EXP 70
18689: PUSH
18690: LD_EXP 70
18694: PPUSH
18695: LD_VAR 0 1
18699: PPUSH
18700: EMPTY
18701: PPUSH
18702: CALL_OW 1
18706: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
18707: LD_ADDR_EXP 71
18711: PUSH
18712: LD_EXP 71
18716: PPUSH
18717: LD_VAR 0 1
18721: PPUSH
18722: EMPTY
18723: PPUSH
18724: CALL_OW 1
18728: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
18729: LD_ADDR_EXP 72
18733: PUSH
18734: LD_EXP 72
18738: PPUSH
18739: LD_VAR 0 1
18743: PPUSH
18744: EMPTY
18745: PPUSH
18746: CALL_OW 1
18750: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
18751: LD_ADDR_EXP 73
18755: PUSH
18756: LD_EXP 73
18760: PPUSH
18761: LD_VAR 0 1
18765: PPUSH
18766: EMPTY
18767: PPUSH
18768: CALL_OW 1
18772: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
18773: LD_ADDR_EXP 74
18777: PUSH
18778: LD_EXP 74
18782: PPUSH
18783: LD_VAR 0 1
18787: PPUSH
18788: EMPTY
18789: PPUSH
18790: CALL_OW 1
18794: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
18795: LD_ADDR_EXP 75
18799: PUSH
18800: LD_EXP 75
18804: PPUSH
18805: LD_VAR 0 1
18809: PPUSH
18810: EMPTY
18811: PPUSH
18812: CALL_OW 1
18816: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
18817: LD_ADDR_EXP 77
18821: PUSH
18822: LD_EXP 77
18826: PPUSH
18827: LD_VAR 0 1
18831: PPUSH
18832: EMPTY
18833: PPUSH
18834: CALL_OW 1
18838: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
18839: LD_ADDR_EXP 79
18843: PUSH
18844: LD_EXP 79
18848: PPUSH
18849: LD_VAR 0 1
18853: PPUSH
18854: EMPTY
18855: PPUSH
18856: CALL_OW 1
18860: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
18861: LD_ADDR_EXP 80
18865: PUSH
18866: LD_EXP 80
18870: PPUSH
18871: LD_VAR 0 1
18875: PPUSH
18876: EMPTY
18877: PPUSH
18878: CALL_OW 1
18882: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
18883: LD_ADDR_EXP 81
18887: PUSH
18888: LD_EXP 81
18892: PPUSH
18893: LD_VAR 0 1
18897: PPUSH
18898: EMPTY
18899: PPUSH
18900: CALL_OW 1
18904: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
18905: LD_ADDR_EXP 82
18909: PUSH
18910: LD_EXP 82
18914: PPUSH
18915: LD_VAR 0 1
18919: PPUSH
18920: EMPTY
18921: PPUSH
18922: CALL_OW 1
18926: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
18927: LD_ADDR_EXP 83
18931: PUSH
18932: LD_EXP 83
18936: PPUSH
18937: LD_VAR 0 1
18941: PPUSH
18942: EMPTY
18943: PPUSH
18944: CALL_OW 1
18948: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
18949: LD_ADDR_EXP 84
18953: PUSH
18954: LD_EXP 84
18958: PPUSH
18959: LD_VAR 0 1
18963: PPUSH
18964: EMPTY
18965: PPUSH
18966: CALL_OW 1
18970: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
18971: LD_ADDR_EXP 85
18975: PUSH
18976: LD_EXP 85
18980: PPUSH
18981: LD_VAR 0 1
18985: PPUSH
18986: EMPTY
18987: PPUSH
18988: CALL_OW 1
18992: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
18993: LD_ADDR_EXP 86
18997: PUSH
18998: LD_EXP 86
19002: PPUSH
19003: LD_VAR 0 1
19007: PPUSH
19008: EMPTY
19009: PPUSH
19010: CALL_OW 1
19014: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
19015: LD_ADDR_EXP 87
19019: PUSH
19020: LD_EXP 87
19024: PPUSH
19025: LD_VAR 0 1
19029: PPUSH
19030: EMPTY
19031: PPUSH
19032: CALL_OW 1
19036: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
19037: LD_ADDR_EXP 88
19041: PUSH
19042: LD_EXP 88
19046: PPUSH
19047: LD_VAR 0 1
19051: PPUSH
19052: EMPTY
19053: PPUSH
19054: CALL_OW 1
19058: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
19059: LD_ADDR_EXP 89
19063: PUSH
19064: LD_EXP 89
19068: PPUSH
19069: LD_VAR 0 1
19073: PPUSH
19074: EMPTY
19075: PPUSH
19076: CALL_OW 1
19080: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
19081: LD_ADDR_EXP 90
19085: PUSH
19086: LD_EXP 90
19090: PPUSH
19091: LD_VAR 0 1
19095: PPUSH
19096: EMPTY
19097: PPUSH
19098: CALL_OW 1
19102: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
19103: LD_ADDR_EXP 91
19107: PUSH
19108: LD_EXP 91
19112: PPUSH
19113: LD_VAR 0 1
19117: PPUSH
19118: EMPTY
19119: PPUSH
19120: CALL_OW 1
19124: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
19125: LD_ADDR_EXP 92
19129: PUSH
19130: LD_EXP 92
19134: PPUSH
19135: LD_VAR 0 1
19139: PPUSH
19140: LD_INT 0
19142: PPUSH
19143: CALL_OW 1
19147: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
19148: LD_ADDR_EXP 93
19152: PUSH
19153: LD_EXP 93
19157: PPUSH
19158: LD_VAR 0 1
19162: PPUSH
19163: LD_INT 0
19165: PPUSH
19166: CALL_OW 1
19170: ST_TO_ADDR
// end ;
19171: LD_VAR 0 2
19175: RET
// export function MC_Add ( side , units ) ; var base ; begin
19176: LD_INT 0
19178: PPUSH
19179: PPUSH
// base := mc_bases + 1 ;
19180: LD_ADDR_VAR 0 4
19184: PUSH
19185: LD_EXP 50
19189: PUSH
19190: LD_INT 1
19192: PLUS
19193: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
19194: LD_ADDR_EXP 76
19198: PUSH
19199: LD_EXP 76
19203: PPUSH
19204: LD_VAR 0 4
19208: PPUSH
19209: LD_VAR 0 1
19213: PPUSH
19214: CALL_OW 1
19218: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
19219: LD_ADDR_EXP 50
19223: PUSH
19224: LD_EXP 50
19228: PPUSH
19229: LD_VAR 0 4
19233: PPUSH
19234: LD_VAR 0 2
19238: PPUSH
19239: CALL_OW 1
19243: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
19244: LD_ADDR_EXP 51
19248: PUSH
19249: LD_EXP 51
19253: PPUSH
19254: LD_VAR 0 4
19258: PPUSH
19259: EMPTY
19260: PPUSH
19261: CALL_OW 1
19265: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
19266: LD_ADDR_EXP 52
19270: PUSH
19271: LD_EXP 52
19275: PPUSH
19276: LD_VAR 0 4
19280: PPUSH
19281: EMPTY
19282: PPUSH
19283: CALL_OW 1
19287: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
19288: LD_ADDR_EXP 53
19292: PUSH
19293: LD_EXP 53
19297: PPUSH
19298: LD_VAR 0 4
19302: PPUSH
19303: EMPTY
19304: PPUSH
19305: CALL_OW 1
19309: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
19310: LD_ADDR_EXP 54
19314: PUSH
19315: LD_EXP 54
19319: PPUSH
19320: LD_VAR 0 4
19324: PPUSH
19325: EMPTY
19326: PPUSH
19327: CALL_OW 1
19331: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
19332: LD_ADDR_EXP 55
19336: PUSH
19337: LD_EXP 55
19341: PPUSH
19342: LD_VAR 0 4
19346: PPUSH
19347: EMPTY
19348: PPUSH
19349: CALL_OW 1
19353: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
19354: LD_ADDR_EXP 56
19358: PUSH
19359: LD_EXP 56
19363: PPUSH
19364: LD_VAR 0 4
19368: PPUSH
19369: EMPTY
19370: PPUSH
19371: CALL_OW 1
19375: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
19376: LD_ADDR_EXP 57
19380: PUSH
19381: LD_EXP 57
19385: PPUSH
19386: LD_VAR 0 4
19390: PPUSH
19391: EMPTY
19392: PPUSH
19393: CALL_OW 1
19397: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
19398: LD_ADDR_EXP 58
19402: PUSH
19403: LD_EXP 58
19407: PPUSH
19408: LD_VAR 0 4
19412: PPUSH
19413: EMPTY
19414: PPUSH
19415: CALL_OW 1
19419: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
19420: LD_ADDR_EXP 59
19424: PUSH
19425: LD_EXP 59
19429: PPUSH
19430: LD_VAR 0 4
19434: PPUSH
19435: EMPTY
19436: PPUSH
19437: CALL_OW 1
19441: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
19442: LD_ADDR_EXP 60
19446: PUSH
19447: LD_EXP 60
19451: PPUSH
19452: LD_VAR 0 4
19456: PPUSH
19457: EMPTY
19458: PPUSH
19459: CALL_OW 1
19463: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
19464: LD_ADDR_EXP 61
19468: PUSH
19469: LD_EXP 61
19473: PPUSH
19474: LD_VAR 0 4
19478: PPUSH
19479: LD_INT 0
19481: PPUSH
19482: CALL_OW 1
19486: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
19487: LD_ADDR_EXP 62
19491: PUSH
19492: LD_EXP 62
19496: PPUSH
19497: LD_VAR 0 4
19501: PPUSH
19502: EMPTY
19503: PPUSH
19504: CALL_OW 1
19508: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
19509: LD_ADDR_EXP 63
19513: PUSH
19514: LD_EXP 63
19518: PPUSH
19519: LD_VAR 0 4
19523: PPUSH
19524: EMPTY
19525: PPUSH
19526: CALL_OW 1
19530: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
19531: LD_ADDR_EXP 64
19535: PUSH
19536: LD_EXP 64
19540: PPUSH
19541: LD_VAR 0 4
19545: PPUSH
19546: EMPTY
19547: PPUSH
19548: CALL_OW 1
19552: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
19553: LD_ADDR_EXP 65
19557: PUSH
19558: LD_EXP 65
19562: PPUSH
19563: LD_VAR 0 4
19567: PPUSH
19568: EMPTY
19569: PPUSH
19570: CALL_OW 1
19574: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
19575: LD_ADDR_EXP 66
19579: PUSH
19580: LD_EXP 66
19584: PPUSH
19585: LD_VAR 0 4
19589: PPUSH
19590: EMPTY
19591: PPUSH
19592: CALL_OW 1
19596: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
19597: LD_ADDR_EXP 67
19601: PUSH
19602: LD_EXP 67
19606: PPUSH
19607: LD_VAR 0 4
19611: PPUSH
19612: EMPTY
19613: PPUSH
19614: CALL_OW 1
19618: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
19619: LD_ADDR_EXP 68
19623: PUSH
19624: LD_EXP 68
19628: PPUSH
19629: LD_VAR 0 4
19633: PPUSH
19634: EMPTY
19635: PPUSH
19636: CALL_OW 1
19640: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
19641: LD_ADDR_EXP 69
19645: PUSH
19646: LD_EXP 69
19650: PPUSH
19651: LD_VAR 0 4
19655: PPUSH
19656: EMPTY
19657: PPUSH
19658: CALL_OW 1
19662: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
19663: LD_ADDR_EXP 70
19667: PUSH
19668: LD_EXP 70
19672: PPUSH
19673: LD_VAR 0 4
19677: PPUSH
19678: EMPTY
19679: PPUSH
19680: CALL_OW 1
19684: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
19685: LD_ADDR_EXP 71
19689: PUSH
19690: LD_EXP 71
19694: PPUSH
19695: LD_VAR 0 4
19699: PPUSH
19700: EMPTY
19701: PPUSH
19702: CALL_OW 1
19706: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
19707: LD_ADDR_EXP 72
19711: PUSH
19712: LD_EXP 72
19716: PPUSH
19717: LD_VAR 0 4
19721: PPUSH
19722: EMPTY
19723: PPUSH
19724: CALL_OW 1
19728: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
19729: LD_ADDR_EXP 73
19733: PUSH
19734: LD_EXP 73
19738: PPUSH
19739: LD_VAR 0 4
19743: PPUSH
19744: EMPTY
19745: PPUSH
19746: CALL_OW 1
19750: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
19751: LD_ADDR_EXP 74
19755: PUSH
19756: LD_EXP 74
19760: PPUSH
19761: LD_VAR 0 4
19765: PPUSH
19766: EMPTY
19767: PPUSH
19768: CALL_OW 1
19772: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
19773: LD_ADDR_EXP 75
19777: PUSH
19778: LD_EXP 75
19782: PPUSH
19783: LD_VAR 0 4
19787: PPUSH
19788: EMPTY
19789: PPUSH
19790: CALL_OW 1
19794: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
19795: LD_ADDR_EXP 77
19799: PUSH
19800: LD_EXP 77
19804: PPUSH
19805: LD_VAR 0 4
19809: PPUSH
19810: EMPTY
19811: PPUSH
19812: CALL_OW 1
19816: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
19817: LD_ADDR_EXP 79
19821: PUSH
19822: LD_EXP 79
19826: PPUSH
19827: LD_VAR 0 4
19831: PPUSH
19832: EMPTY
19833: PPUSH
19834: CALL_OW 1
19838: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
19839: LD_ADDR_EXP 80
19843: PUSH
19844: LD_EXP 80
19848: PPUSH
19849: LD_VAR 0 4
19853: PPUSH
19854: EMPTY
19855: PPUSH
19856: CALL_OW 1
19860: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
19861: LD_ADDR_EXP 81
19865: PUSH
19866: LD_EXP 81
19870: PPUSH
19871: LD_VAR 0 4
19875: PPUSH
19876: EMPTY
19877: PPUSH
19878: CALL_OW 1
19882: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
19883: LD_ADDR_EXP 82
19887: PUSH
19888: LD_EXP 82
19892: PPUSH
19893: LD_VAR 0 4
19897: PPUSH
19898: EMPTY
19899: PPUSH
19900: CALL_OW 1
19904: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
19905: LD_ADDR_EXP 83
19909: PUSH
19910: LD_EXP 83
19914: PPUSH
19915: LD_VAR 0 4
19919: PPUSH
19920: EMPTY
19921: PPUSH
19922: CALL_OW 1
19926: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
19927: LD_ADDR_EXP 84
19931: PUSH
19932: LD_EXP 84
19936: PPUSH
19937: LD_VAR 0 4
19941: PPUSH
19942: EMPTY
19943: PPUSH
19944: CALL_OW 1
19948: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
19949: LD_ADDR_EXP 85
19953: PUSH
19954: LD_EXP 85
19958: PPUSH
19959: LD_VAR 0 4
19963: PPUSH
19964: EMPTY
19965: PPUSH
19966: CALL_OW 1
19970: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
19971: LD_ADDR_EXP 86
19975: PUSH
19976: LD_EXP 86
19980: PPUSH
19981: LD_VAR 0 4
19985: PPUSH
19986: EMPTY
19987: PPUSH
19988: CALL_OW 1
19992: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
19993: LD_ADDR_EXP 87
19997: PUSH
19998: LD_EXP 87
20002: PPUSH
20003: LD_VAR 0 4
20007: PPUSH
20008: EMPTY
20009: PPUSH
20010: CALL_OW 1
20014: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
20015: LD_ADDR_EXP 88
20019: PUSH
20020: LD_EXP 88
20024: PPUSH
20025: LD_VAR 0 4
20029: PPUSH
20030: EMPTY
20031: PPUSH
20032: CALL_OW 1
20036: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
20037: LD_ADDR_EXP 89
20041: PUSH
20042: LD_EXP 89
20046: PPUSH
20047: LD_VAR 0 4
20051: PPUSH
20052: EMPTY
20053: PPUSH
20054: CALL_OW 1
20058: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
20059: LD_ADDR_EXP 90
20063: PUSH
20064: LD_EXP 90
20068: PPUSH
20069: LD_VAR 0 4
20073: PPUSH
20074: EMPTY
20075: PPUSH
20076: CALL_OW 1
20080: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
20081: LD_ADDR_EXP 91
20085: PUSH
20086: LD_EXP 91
20090: PPUSH
20091: LD_VAR 0 4
20095: PPUSH
20096: EMPTY
20097: PPUSH
20098: CALL_OW 1
20102: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
20103: LD_ADDR_EXP 92
20107: PUSH
20108: LD_EXP 92
20112: PPUSH
20113: LD_VAR 0 4
20117: PPUSH
20118: LD_INT 0
20120: PPUSH
20121: CALL_OW 1
20125: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
20126: LD_ADDR_EXP 93
20130: PUSH
20131: LD_EXP 93
20135: PPUSH
20136: LD_VAR 0 4
20140: PPUSH
20141: LD_INT 0
20143: PPUSH
20144: CALL_OW 1
20148: ST_TO_ADDR
// result := base ;
20149: LD_ADDR_VAR 0 3
20153: PUSH
20154: LD_VAR 0 4
20158: ST_TO_ADDR
// end ;
20159: LD_VAR 0 3
20163: RET
// export function MC_Start ( ) ; var i ; begin
20164: LD_INT 0
20166: PPUSH
20167: PPUSH
// for i = 1 to mc_bases do
20168: LD_ADDR_VAR 0 2
20172: PUSH
20173: DOUBLE
20174: LD_INT 1
20176: DEC
20177: ST_TO_ADDR
20178: LD_EXP 50
20182: PUSH
20183: FOR_TO
20184: IFFALSE 21284
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
20186: LD_ADDR_EXP 50
20190: PUSH
20191: LD_EXP 50
20195: PPUSH
20196: LD_VAR 0 2
20200: PPUSH
20201: LD_EXP 50
20205: PUSH
20206: LD_VAR 0 2
20210: ARRAY
20211: PUSH
20212: LD_INT 0
20214: DIFF
20215: PPUSH
20216: CALL_OW 1
20220: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
20221: LD_ADDR_EXP 51
20225: PUSH
20226: LD_EXP 51
20230: PPUSH
20231: LD_VAR 0 2
20235: PPUSH
20236: EMPTY
20237: PPUSH
20238: CALL_OW 1
20242: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
20243: LD_ADDR_EXP 52
20247: PUSH
20248: LD_EXP 52
20252: PPUSH
20253: LD_VAR 0 2
20257: PPUSH
20258: EMPTY
20259: PPUSH
20260: CALL_OW 1
20264: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
20265: LD_ADDR_EXP 53
20269: PUSH
20270: LD_EXP 53
20274: PPUSH
20275: LD_VAR 0 2
20279: PPUSH
20280: EMPTY
20281: PPUSH
20282: CALL_OW 1
20286: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
20287: LD_ADDR_EXP 54
20291: PUSH
20292: LD_EXP 54
20296: PPUSH
20297: LD_VAR 0 2
20301: PPUSH
20302: EMPTY
20303: PUSH
20304: EMPTY
20305: PUSH
20306: EMPTY
20307: LIST
20308: LIST
20309: PPUSH
20310: CALL_OW 1
20314: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
20315: LD_ADDR_EXP 55
20319: PUSH
20320: LD_EXP 55
20324: PPUSH
20325: LD_VAR 0 2
20329: PPUSH
20330: EMPTY
20331: PPUSH
20332: CALL_OW 1
20336: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
20337: LD_ADDR_EXP 82
20341: PUSH
20342: LD_EXP 82
20346: PPUSH
20347: LD_VAR 0 2
20351: PPUSH
20352: EMPTY
20353: PPUSH
20354: CALL_OW 1
20358: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
20359: LD_ADDR_EXP 56
20363: PUSH
20364: LD_EXP 56
20368: PPUSH
20369: LD_VAR 0 2
20373: PPUSH
20374: EMPTY
20375: PPUSH
20376: CALL_OW 1
20380: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
20381: LD_ADDR_EXP 57
20385: PUSH
20386: LD_EXP 57
20390: PPUSH
20391: LD_VAR 0 2
20395: PPUSH
20396: EMPTY
20397: PPUSH
20398: CALL_OW 1
20402: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
20403: LD_ADDR_EXP 58
20407: PUSH
20408: LD_EXP 58
20412: PPUSH
20413: LD_VAR 0 2
20417: PPUSH
20418: LD_EXP 50
20422: PUSH
20423: LD_VAR 0 2
20427: ARRAY
20428: PPUSH
20429: LD_INT 2
20431: PUSH
20432: LD_INT 30
20434: PUSH
20435: LD_INT 32
20437: PUSH
20438: EMPTY
20439: LIST
20440: LIST
20441: PUSH
20442: LD_INT 30
20444: PUSH
20445: LD_INT 33
20447: PUSH
20448: EMPTY
20449: LIST
20450: LIST
20451: PUSH
20452: EMPTY
20453: LIST
20454: LIST
20455: LIST
20456: PPUSH
20457: CALL_OW 72
20461: PPUSH
20462: CALL_OW 1
20466: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
20467: LD_ADDR_EXP 59
20471: PUSH
20472: LD_EXP 59
20476: PPUSH
20477: LD_VAR 0 2
20481: PPUSH
20482: LD_EXP 50
20486: PUSH
20487: LD_VAR 0 2
20491: ARRAY
20492: PPUSH
20493: LD_INT 2
20495: PUSH
20496: LD_INT 30
20498: PUSH
20499: LD_INT 32
20501: PUSH
20502: EMPTY
20503: LIST
20504: LIST
20505: PUSH
20506: LD_INT 30
20508: PUSH
20509: LD_INT 31
20511: PUSH
20512: EMPTY
20513: LIST
20514: LIST
20515: PUSH
20516: EMPTY
20517: LIST
20518: LIST
20519: LIST
20520: PUSH
20521: LD_INT 58
20523: PUSH
20524: EMPTY
20525: LIST
20526: PUSH
20527: EMPTY
20528: LIST
20529: LIST
20530: PPUSH
20531: CALL_OW 72
20535: PPUSH
20536: CALL_OW 1
20540: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
20541: LD_ADDR_EXP 60
20545: PUSH
20546: LD_EXP 60
20550: PPUSH
20551: LD_VAR 0 2
20555: PPUSH
20556: EMPTY
20557: PPUSH
20558: CALL_OW 1
20562: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
20563: LD_ADDR_EXP 64
20567: PUSH
20568: LD_EXP 64
20572: PPUSH
20573: LD_VAR 0 2
20577: PPUSH
20578: EMPTY
20579: PPUSH
20580: CALL_OW 1
20584: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
20585: LD_ADDR_EXP 63
20589: PUSH
20590: LD_EXP 63
20594: PPUSH
20595: LD_VAR 0 2
20599: PPUSH
20600: EMPTY
20601: PPUSH
20602: CALL_OW 1
20606: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
20607: LD_ADDR_EXP 65
20611: PUSH
20612: LD_EXP 65
20616: PPUSH
20617: LD_VAR 0 2
20621: PPUSH
20622: EMPTY
20623: PPUSH
20624: CALL_OW 1
20628: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
20629: LD_ADDR_EXP 66
20633: PUSH
20634: LD_EXP 66
20638: PPUSH
20639: LD_VAR 0 2
20643: PPUSH
20644: EMPTY
20645: PPUSH
20646: CALL_OW 1
20650: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
20651: LD_ADDR_EXP 67
20655: PUSH
20656: LD_EXP 67
20660: PPUSH
20661: LD_VAR 0 2
20665: PPUSH
20666: EMPTY
20667: PPUSH
20668: CALL_OW 1
20672: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
20673: LD_ADDR_EXP 68
20677: PUSH
20678: LD_EXP 68
20682: PPUSH
20683: LD_VAR 0 2
20687: PPUSH
20688: EMPTY
20689: PPUSH
20690: CALL_OW 1
20694: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
20695: LD_ADDR_EXP 69
20699: PUSH
20700: LD_EXP 69
20704: PPUSH
20705: LD_VAR 0 2
20709: PPUSH
20710: EMPTY
20711: PPUSH
20712: CALL_OW 1
20716: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
20717: LD_ADDR_EXP 70
20721: PUSH
20722: LD_EXP 70
20726: PPUSH
20727: LD_VAR 0 2
20731: PPUSH
20732: EMPTY
20733: PPUSH
20734: CALL_OW 1
20738: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
20739: LD_ADDR_EXP 71
20743: PUSH
20744: LD_EXP 71
20748: PPUSH
20749: LD_VAR 0 2
20753: PPUSH
20754: EMPTY
20755: PPUSH
20756: CALL_OW 1
20760: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
20761: LD_ADDR_EXP 72
20765: PUSH
20766: LD_EXP 72
20770: PPUSH
20771: LD_VAR 0 2
20775: PPUSH
20776: EMPTY
20777: PPUSH
20778: CALL_OW 1
20782: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
20783: LD_ADDR_EXP 61
20787: PUSH
20788: LD_EXP 61
20792: PPUSH
20793: LD_VAR 0 2
20797: PPUSH
20798: LD_INT 0
20800: PPUSH
20801: CALL_OW 1
20805: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
20806: LD_ADDR_EXP 74
20810: PUSH
20811: LD_EXP 74
20815: PPUSH
20816: LD_VAR 0 2
20820: PPUSH
20821: LD_INT 0
20823: PPUSH
20824: CALL_OW 1
20828: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
20829: LD_ADDR_EXP 62
20833: PUSH
20834: LD_EXP 62
20838: PPUSH
20839: LD_VAR 0 2
20843: PPUSH
20844: EMPTY
20845: PPUSH
20846: CALL_OW 1
20850: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
20851: LD_ADDR_EXP 73
20855: PUSH
20856: LD_EXP 73
20860: PPUSH
20861: LD_VAR 0 2
20865: PPUSH
20866: LD_INT 0
20868: PPUSH
20869: CALL_OW 1
20873: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
20874: LD_ADDR_EXP 75
20878: PUSH
20879: LD_EXP 75
20883: PPUSH
20884: LD_VAR 0 2
20888: PPUSH
20889: EMPTY
20890: PPUSH
20891: CALL_OW 1
20895: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
20896: LD_ADDR_EXP 78
20900: PUSH
20901: LD_EXP 78
20905: PPUSH
20906: LD_VAR 0 2
20910: PPUSH
20911: LD_INT 0
20913: PPUSH
20914: CALL_OW 1
20918: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
20919: LD_ADDR_EXP 79
20923: PUSH
20924: LD_EXP 79
20928: PPUSH
20929: LD_VAR 0 2
20933: PPUSH
20934: EMPTY
20935: PPUSH
20936: CALL_OW 1
20940: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
20941: LD_ADDR_EXP 80
20945: PUSH
20946: LD_EXP 80
20950: PPUSH
20951: LD_VAR 0 2
20955: PPUSH
20956: EMPTY
20957: PPUSH
20958: CALL_OW 1
20962: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
20963: LD_ADDR_EXP 81
20967: PUSH
20968: LD_EXP 81
20972: PPUSH
20973: LD_VAR 0 2
20977: PPUSH
20978: EMPTY
20979: PPUSH
20980: CALL_OW 1
20984: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
20985: LD_ADDR_EXP 83
20989: PUSH
20990: LD_EXP 83
20994: PPUSH
20995: LD_VAR 0 2
20999: PPUSH
21000: LD_EXP 50
21004: PUSH
21005: LD_VAR 0 2
21009: ARRAY
21010: PPUSH
21011: LD_INT 2
21013: PUSH
21014: LD_INT 30
21016: PUSH
21017: LD_INT 6
21019: PUSH
21020: EMPTY
21021: LIST
21022: LIST
21023: PUSH
21024: LD_INT 30
21026: PUSH
21027: LD_INT 7
21029: PUSH
21030: EMPTY
21031: LIST
21032: LIST
21033: PUSH
21034: LD_INT 30
21036: PUSH
21037: LD_INT 8
21039: PUSH
21040: EMPTY
21041: LIST
21042: LIST
21043: PUSH
21044: EMPTY
21045: LIST
21046: LIST
21047: LIST
21048: LIST
21049: PPUSH
21050: CALL_OW 72
21054: PPUSH
21055: CALL_OW 1
21059: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
21060: LD_ADDR_EXP 84
21064: PUSH
21065: LD_EXP 84
21069: PPUSH
21070: LD_VAR 0 2
21074: PPUSH
21075: EMPTY
21076: PPUSH
21077: CALL_OW 1
21081: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
21082: LD_ADDR_EXP 85
21086: PUSH
21087: LD_EXP 85
21091: PPUSH
21092: LD_VAR 0 2
21096: PPUSH
21097: EMPTY
21098: PPUSH
21099: CALL_OW 1
21103: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
21104: LD_ADDR_EXP 86
21108: PUSH
21109: LD_EXP 86
21113: PPUSH
21114: LD_VAR 0 2
21118: PPUSH
21119: EMPTY
21120: PPUSH
21121: CALL_OW 1
21125: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
21126: LD_ADDR_EXP 87
21130: PUSH
21131: LD_EXP 87
21135: PPUSH
21136: LD_VAR 0 2
21140: PPUSH
21141: EMPTY
21142: PPUSH
21143: CALL_OW 1
21147: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
21148: LD_ADDR_EXP 88
21152: PUSH
21153: LD_EXP 88
21157: PPUSH
21158: LD_VAR 0 2
21162: PPUSH
21163: EMPTY
21164: PPUSH
21165: CALL_OW 1
21169: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
21170: LD_ADDR_EXP 89
21174: PUSH
21175: LD_EXP 89
21179: PPUSH
21180: LD_VAR 0 2
21184: PPUSH
21185: EMPTY
21186: PPUSH
21187: CALL_OW 1
21191: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
21192: LD_ADDR_EXP 90
21196: PUSH
21197: LD_EXP 90
21201: PPUSH
21202: LD_VAR 0 2
21206: PPUSH
21207: EMPTY
21208: PPUSH
21209: CALL_OW 1
21213: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
21214: LD_ADDR_EXP 91
21218: PUSH
21219: LD_EXP 91
21223: PPUSH
21224: LD_VAR 0 2
21228: PPUSH
21229: EMPTY
21230: PPUSH
21231: CALL_OW 1
21235: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
21236: LD_ADDR_EXP 92
21240: PUSH
21241: LD_EXP 92
21245: PPUSH
21246: LD_VAR 0 2
21250: PPUSH
21251: LD_INT 0
21253: PPUSH
21254: CALL_OW 1
21258: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
21259: LD_ADDR_EXP 93
21263: PUSH
21264: LD_EXP 93
21268: PPUSH
21269: LD_VAR 0 2
21273: PPUSH
21274: LD_INT 0
21276: PPUSH
21277: CALL_OW 1
21281: ST_TO_ADDR
// end ;
21282: GO 20183
21284: POP
21285: POP
// MC_InitSides ( ) ;
21286: CALL 21572 0 0
// MC_InitResearch ( ) ;
21290: CALL 21311 0 0
// CustomInitMacro ( ) ;
21294: CALL 304 0 0
// skirmish := true ;
21298: LD_ADDR_EXP 48
21302: PUSH
21303: LD_INT 1
21305: ST_TO_ADDR
// end ;
21306: LD_VAR 0 1
21310: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
21311: LD_INT 0
21313: PPUSH
21314: PPUSH
21315: PPUSH
21316: PPUSH
21317: PPUSH
21318: PPUSH
// if not mc_bases then
21319: LD_EXP 50
21323: NOT
21324: IFFALSE 21328
// exit ;
21326: GO 21567
// for i = 1 to 8 do
21328: LD_ADDR_VAR 0 2
21332: PUSH
21333: DOUBLE
21334: LD_INT 1
21336: DEC
21337: ST_TO_ADDR
21338: LD_INT 8
21340: PUSH
21341: FOR_TO
21342: IFFALSE 21368
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
21344: LD_ADDR_EXP 77
21348: PUSH
21349: LD_EXP 77
21353: PPUSH
21354: LD_VAR 0 2
21358: PPUSH
21359: EMPTY
21360: PPUSH
21361: CALL_OW 1
21365: ST_TO_ADDR
21366: GO 21341
21368: POP
21369: POP
// tmp := [ ] ;
21370: LD_ADDR_VAR 0 5
21374: PUSH
21375: EMPTY
21376: ST_TO_ADDR
// for i = 1 to mc_sides do
21377: LD_ADDR_VAR 0 2
21381: PUSH
21382: DOUBLE
21383: LD_INT 1
21385: DEC
21386: ST_TO_ADDR
21387: LD_EXP 76
21391: PUSH
21392: FOR_TO
21393: IFFALSE 21451
// if not mc_sides [ i ] in tmp then
21395: LD_EXP 76
21399: PUSH
21400: LD_VAR 0 2
21404: ARRAY
21405: PUSH
21406: LD_VAR 0 5
21410: IN
21411: NOT
21412: IFFALSE 21449
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
21414: LD_ADDR_VAR 0 5
21418: PUSH
21419: LD_VAR 0 5
21423: PPUSH
21424: LD_VAR 0 5
21428: PUSH
21429: LD_INT 1
21431: PLUS
21432: PPUSH
21433: LD_EXP 76
21437: PUSH
21438: LD_VAR 0 2
21442: ARRAY
21443: PPUSH
21444: CALL_OW 2
21448: ST_TO_ADDR
21449: GO 21392
21451: POP
21452: POP
// if not tmp then
21453: LD_VAR 0 5
21457: NOT
21458: IFFALSE 21462
// exit ;
21460: GO 21567
// for j in tmp do
21462: LD_ADDR_VAR 0 3
21466: PUSH
21467: LD_VAR 0 5
21471: PUSH
21472: FOR_IN
21473: IFFALSE 21565
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
21475: LD_ADDR_VAR 0 6
21479: PUSH
21480: LD_INT 22
21482: PUSH
21483: LD_VAR 0 3
21487: PUSH
21488: EMPTY
21489: LIST
21490: LIST
21491: PPUSH
21492: CALL_OW 69
21496: ST_TO_ADDR
// if not un then
21497: LD_VAR 0 6
21501: NOT
21502: IFFALSE 21506
// continue ;
21504: GO 21472
// nation := GetNation ( un [ 1 ] ) ;
21506: LD_ADDR_VAR 0 4
21510: PUSH
21511: LD_VAR 0 6
21515: PUSH
21516: LD_INT 1
21518: ARRAY
21519: PPUSH
21520: CALL_OW 248
21524: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
21525: LD_ADDR_EXP 77
21529: PUSH
21530: LD_EXP 77
21534: PPUSH
21535: LD_VAR 0 3
21539: PPUSH
21540: LD_VAR 0 3
21544: PPUSH
21545: LD_VAR 0 4
21549: PPUSH
21550: LD_INT 1
21552: PPUSH
21553: CALL 48757 0 3
21557: PPUSH
21558: CALL_OW 1
21562: ST_TO_ADDR
// end ;
21563: GO 21472
21565: POP
21566: POP
// end ;
21567: LD_VAR 0 1
21571: RET
// export function MC_InitSides ( ) ; var i ; begin
21572: LD_INT 0
21574: PPUSH
21575: PPUSH
// if not mc_bases then
21576: LD_EXP 50
21580: NOT
21581: IFFALSE 21585
// exit ;
21583: GO 21659
// for i = 1 to mc_bases do
21585: LD_ADDR_VAR 0 2
21589: PUSH
21590: DOUBLE
21591: LD_INT 1
21593: DEC
21594: ST_TO_ADDR
21595: LD_EXP 50
21599: PUSH
21600: FOR_TO
21601: IFFALSE 21657
// if mc_bases [ i ] then
21603: LD_EXP 50
21607: PUSH
21608: LD_VAR 0 2
21612: ARRAY
21613: IFFALSE 21655
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
21615: LD_ADDR_EXP 76
21619: PUSH
21620: LD_EXP 76
21624: PPUSH
21625: LD_VAR 0 2
21629: PPUSH
21630: LD_EXP 50
21634: PUSH
21635: LD_VAR 0 2
21639: ARRAY
21640: PUSH
21641: LD_INT 1
21643: ARRAY
21644: PPUSH
21645: CALL_OW 255
21649: PPUSH
21650: CALL_OW 1
21654: ST_TO_ADDR
21655: GO 21600
21657: POP
21658: POP
// end ;
21659: LD_VAR 0 1
21663: RET
// every 0 0$03 trigger skirmish do
21664: LD_EXP 48
21668: IFFALSE 21822
21670: GO 21672
21672: DISABLE
// begin enable ;
21673: ENABLE
// MC_CheckBuildings ( ) ;
21674: CALL 26320 0 0
// MC_CheckPeopleLife ( ) ;
21678: CALL 26481 0 0
// RaiseSailEvent ( 100 ) ;
21682: LD_INT 100
21684: PPUSH
21685: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
21689: LD_INT 103
21691: PPUSH
21692: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
21696: LD_INT 104
21698: PPUSH
21699: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
21703: LD_INT 105
21705: PPUSH
21706: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
21710: LD_INT 106
21712: PPUSH
21713: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
21717: LD_INT 107
21719: PPUSH
21720: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
21724: LD_INT 108
21726: PPUSH
21727: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
21731: LD_INT 109
21733: PPUSH
21734: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
21738: LD_INT 110
21740: PPUSH
21741: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
21745: LD_INT 111
21747: PPUSH
21748: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
21752: LD_INT 112
21754: PPUSH
21755: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
21759: LD_INT 113
21761: PPUSH
21762: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
21766: LD_INT 120
21768: PPUSH
21769: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
21773: LD_INT 121
21775: PPUSH
21776: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
21780: LD_INT 122
21782: PPUSH
21783: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
21787: LD_INT 123
21789: PPUSH
21790: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
21794: LD_INT 124
21796: PPUSH
21797: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
21801: LD_INT 125
21803: PPUSH
21804: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
21808: LD_INT 126
21810: PPUSH
21811: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
21815: LD_INT 200
21817: PPUSH
21818: CALL_OW 427
// end ;
21822: END
// on SailEvent ( event ) do begin if event < 100 then
21823: LD_VAR 0 1
21827: PUSH
21828: LD_INT 100
21830: LESS
21831: IFFALSE 21842
// CustomEvent ( event ) ;
21833: LD_VAR 0 1
21837: PPUSH
21838: CALL 17170 0 1
// if event = 100 then
21842: LD_VAR 0 1
21846: PUSH
21847: LD_INT 100
21849: EQUAL
21850: IFFALSE 21856
// MC_ClassManager ( ) ;
21852: CALL 22248 0 0
// if event = 101 then
21856: LD_VAR 0 1
21860: PUSH
21861: LD_INT 101
21863: EQUAL
21864: IFFALSE 21870
// MC_RepairBuildings ( ) ;
21866: CALL 27066 0 0
// if event = 102 then
21870: LD_VAR 0 1
21874: PUSH
21875: LD_INT 102
21877: EQUAL
21878: IFFALSE 21884
// MC_Heal ( ) ;
21880: CALL 28001 0 0
// if event = 103 then
21884: LD_VAR 0 1
21888: PUSH
21889: LD_INT 103
21891: EQUAL
21892: IFFALSE 21898
// MC_Build ( ) ;
21894: CALL 28423 0 0
// if event = 104 then
21898: LD_VAR 0 1
21902: PUSH
21903: LD_INT 104
21905: EQUAL
21906: IFFALSE 21912
// MC_TurretWeapon ( ) ;
21908: CALL 30057 0 0
// if event = 105 then
21912: LD_VAR 0 1
21916: PUSH
21917: LD_INT 105
21919: EQUAL
21920: IFFALSE 21926
// MC_BuildUpgrade ( ) ;
21922: CALL 29608 0 0
// if event = 106 then
21926: LD_VAR 0 1
21930: PUSH
21931: LD_INT 106
21933: EQUAL
21934: IFFALSE 21940
// MC_PlantMines ( ) ;
21936: CALL 30487 0 0
// if event = 107 then
21940: LD_VAR 0 1
21944: PUSH
21945: LD_INT 107
21947: EQUAL
21948: IFFALSE 21954
// MC_CollectCrates ( ) ;
21950: CALL 31278 0 0
// if event = 108 then
21954: LD_VAR 0 1
21958: PUSH
21959: LD_INT 108
21961: EQUAL
21962: IFFALSE 21968
// MC_LinkRemoteControl ( ) ;
21964: CALL 33128 0 0
// if event = 109 then
21968: LD_VAR 0 1
21972: PUSH
21973: LD_INT 109
21975: EQUAL
21976: IFFALSE 21982
// MC_ProduceVehicle ( ) ;
21978: CALL 33309 0 0
// if event = 110 then
21982: LD_VAR 0 1
21986: PUSH
21987: LD_INT 110
21989: EQUAL
21990: IFFALSE 21996
// MC_SendAttack ( ) ;
21992: CALL 33775 0 0
// if event = 111 then
21996: LD_VAR 0 1
22000: PUSH
22001: LD_INT 111
22003: EQUAL
22004: IFFALSE 22010
// MC_Defend ( ) ;
22006: CALL 33883 0 0
// if event = 112 then
22010: LD_VAR 0 1
22014: PUSH
22015: LD_INT 112
22017: EQUAL
22018: IFFALSE 22024
// MC_Research ( ) ;
22020: CALL 34763 0 0
// if event = 113 then
22024: LD_VAR 0 1
22028: PUSH
22029: LD_INT 113
22031: EQUAL
22032: IFFALSE 22038
// MC_MinesTrigger ( ) ;
22034: CALL 35877 0 0
// if event = 120 then
22038: LD_VAR 0 1
22042: PUSH
22043: LD_INT 120
22045: EQUAL
22046: IFFALSE 22052
// MC_RepairVehicle ( ) ;
22048: CALL 35976 0 0
// if event = 121 then
22052: LD_VAR 0 1
22056: PUSH
22057: LD_INT 121
22059: EQUAL
22060: IFFALSE 22066
// MC_TameApe ( ) ;
22062: CALL 36745 0 0
// if event = 122 then
22066: LD_VAR 0 1
22070: PUSH
22071: LD_INT 122
22073: EQUAL
22074: IFFALSE 22080
// MC_ChangeApeClass ( ) ;
22076: CALL 37574 0 0
// if event = 123 then
22080: LD_VAR 0 1
22084: PUSH
22085: LD_INT 123
22087: EQUAL
22088: IFFALSE 22094
// MC_Bazooka ( ) ;
22090: CALL 38224 0 0
// if event = 124 then
22094: LD_VAR 0 1
22098: PUSH
22099: LD_INT 124
22101: EQUAL
22102: IFFALSE 22108
// MC_TeleportExit ( ) ;
22104: CALL 38422 0 0
// if event = 125 then
22108: LD_VAR 0 1
22112: PUSH
22113: LD_INT 125
22115: EQUAL
22116: IFFALSE 22122
// MC_Deposits ( ) ;
22118: CALL 39069 0 0
// if event = 126 then
22122: LD_VAR 0 1
22126: PUSH
22127: LD_INT 126
22129: EQUAL
22130: IFFALSE 22136
// MC_RemoteDriver ( ) ;
22132: CALL 39694 0 0
// if event = 200 then
22136: LD_VAR 0 1
22140: PUSH
22141: LD_INT 200
22143: EQUAL
22144: IFFALSE 22150
// MC_Idle ( ) ;
22146: CALL 41643 0 0
// end ;
22150: PPOPN 1
22152: END
// export function MC_Reset ( base , tag ) ; var i ; begin
22153: LD_INT 0
22155: PPUSH
22156: PPUSH
// if not mc_bases [ base ] or not tag then
22157: LD_EXP 50
22161: PUSH
22162: LD_VAR 0 1
22166: ARRAY
22167: NOT
22168: PUSH
22169: LD_VAR 0 2
22173: NOT
22174: OR
22175: IFFALSE 22179
// exit ;
22177: GO 22243
// for i in mc_bases [ base ] union mc_ape [ base ] do
22179: LD_ADDR_VAR 0 4
22183: PUSH
22184: LD_EXP 50
22188: PUSH
22189: LD_VAR 0 1
22193: ARRAY
22194: PUSH
22195: LD_EXP 79
22199: PUSH
22200: LD_VAR 0 1
22204: ARRAY
22205: UNION
22206: PUSH
22207: FOR_IN
22208: IFFALSE 22241
// if GetTag ( i ) = tag then
22210: LD_VAR 0 4
22214: PPUSH
22215: CALL_OW 110
22219: PUSH
22220: LD_VAR 0 2
22224: EQUAL
22225: IFFALSE 22239
// SetTag ( i , 0 ) ;
22227: LD_VAR 0 4
22231: PPUSH
22232: LD_INT 0
22234: PPUSH
22235: CALL_OW 109
22239: GO 22207
22241: POP
22242: POP
// end ;
22243: LD_VAR 0 3
22247: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
22248: LD_INT 0
22250: PPUSH
22251: PPUSH
22252: PPUSH
22253: PPUSH
22254: PPUSH
22255: PPUSH
22256: PPUSH
22257: PPUSH
// if not mc_bases then
22258: LD_EXP 50
22262: NOT
22263: IFFALSE 22267
// exit ;
22265: GO 22725
// for i = 1 to mc_bases do
22267: LD_ADDR_VAR 0 2
22271: PUSH
22272: DOUBLE
22273: LD_INT 1
22275: DEC
22276: ST_TO_ADDR
22277: LD_EXP 50
22281: PUSH
22282: FOR_TO
22283: IFFALSE 22723
// begin tmp := MC_ClassCheckReq ( i ) ;
22285: LD_ADDR_VAR 0 4
22289: PUSH
22290: LD_VAR 0 2
22294: PPUSH
22295: CALL 22730 0 1
22299: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
22300: LD_ADDR_EXP 91
22304: PUSH
22305: LD_EXP 91
22309: PPUSH
22310: LD_VAR 0 2
22314: PPUSH
22315: LD_VAR 0 4
22319: PPUSH
22320: CALL_OW 1
22324: ST_TO_ADDR
// if not tmp then
22325: LD_VAR 0 4
22329: NOT
22330: IFFALSE 22334
// continue ;
22332: GO 22282
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
22334: LD_ADDR_VAR 0 6
22338: PUSH
22339: LD_EXP 50
22343: PUSH
22344: LD_VAR 0 2
22348: ARRAY
22349: PPUSH
22350: LD_INT 2
22352: PUSH
22353: LD_INT 30
22355: PUSH
22356: LD_INT 4
22358: PUSH
22359: EMPTY
22360: LIST
22361: LIST
22362: PUSH
22363: LD_INT 30
22365: PUSH
22366: LD_INT 5
22368: PUSH
22369: EMPTY
22370: LIST
22371: LIST
22372: PUSH
22373: EMPTY
22374: LIST
22375: LIST
22376: LIST
22377: PPUSH
22378: CALL_OW 72
22382: PUSH
22383: LD_EXP 50
22387: PUSH
22388: LD_VAR 0 2
22392: ARRAY
22393: PPUSH
22394: LD_INT 2
22396: PUSH
22397: LD_INT 30
22399: PUSH
22400: LD_INT 0
22402: PUSH
22403: EMPTY
22404: LIST
22405: LIST
22406: PUSH
22407: LD_INT 30
22409: PUSH
22410: LD_INT 1
22412: PUSH
22413: EMPTY
22414: LIST
22415: LIST
22416: PUSH
22417: EMPTY
22418: LIST
22419: LIST
22420: LIST
22421: PPUSH
22422: CALL_OW 72
22426: PUSH
22427: LD_EXP 50
22431: PUSH
22432: LD_VAR 0 2
22436: ARRAY
22437: PPUSH
22438: LD_INT 30
22440: PUSH
22441: LD_INT 3
22443: PUSH
22444: EMPTY
22445: LIST
22446: LIST
22447: PPUSH
22448: CALL_OW 72
22452: PUSH
22453: LD_EXP 50
22457: PUSH
22458: LD_VAR 0 2
22462: ARRAY
22463: PPUSH
22464: LD_INT 2
22466: PUSH
22467: LD_INT 30
22469: PUSH
22470: LD_INT 6
22472: PUSH
22473: EMPTY
22474: LIST
22475: LIST
22476: PUSH
22477: LD_INT 30
22479: PUSH
22480: LD_INT 7
22482: PUSH
22483: EMPTY
22484: LIST
22485: LIST
22486: PUSH
22487: LD_INT 30
22489: PUSH
22490: LD_INT 8
22492: PUSH
22493: EMPTY
22494: LIST
22495: LIST
22496: PUSH
22497: EMPTY
22498: LIST
22499: LIST
22500: LIST
22501: LIST
22502: PPUSH
22503: CALL_OW 72
22507: PUSH
22508: EMPTY
22509: LIST
22510: LIST
22511: LIST
22512: LIST
22513: ST_TO_ADDR
// for j = 1 to 4 do
22514: LD_ADDR_VAR 0 3
22518: PUSH
22519: DOUBLE
22520: LD_INT 1
22522: DEC
22523: ST_TO_ADDR
22524: LD_INT 4
22526: PUSH
22527: FOR_TO
22528: IFFALSE 22719
// begin if not tmp [ j ] then
22530: LD_VAR 0 4
22534: PUSH
22535: LD_VAR 0 3
22539: ARRAY
22540: NOT
22541: IFFALSE 22545
// continue ;
22543: GO 22527
// for p in tmp [ j ] do
22545: LD_ADDR_VAR 0 5
22549: PUSH
22550: LD_VAR 0 4
22554: PUSH
22555: LD_VAR 0 3
22559: ARRAY
22560: PUSH
22561: FOR_IN
22562: IFFALSE 22715
// begin if not b [ j ] then
22564: LD_VAR 0 6
22568: PUSH
22569: LD_VAR 0 3
22573: ARRAY
22574: NOT
22575: IFFALSE 22579
// break ;
22577: GO 22715
// e := 0 ;
22579: LD_ADDR_VAR 0 7
22583: PUSH
22584: LD_INT 0
22586: ST_TO_ADDR
// for k in b [ j ] do
22587: LD_ADDR_VAR 0 8
22591: PUSH
22592: LD_VAR 0 6
22596: PUSH
22597: LD_VAR 0 3
22601: ARRAY
22602: PUSH
22603: FOR_IN
22604: IFFALSE 22631
// if IsNotFull ( k ) then
22606: LD_VAR 0 8
22610: PPUSH
22611: CALL 50910 0 1
22615: IFFALSE 22629
// begin e := k ;
22617: LD_ADDR_VAR 0 7
22621: PUSH
22622: LD_VAR 0 8
22626: ST_TO_ADDR
// break ;
22627: GO 22631
// end ;
22629: GO 22603
22631: POP
22632: POP
// if e and not UnitGoingToBuilding ( p , e ) then
22633: LD_VAR 0 7
22637: PUSH
22638: LD_VAR 0 5
22642: PPUSH
22643: LD_VAR 0 7
22647: PPUSH
22648: CALL 84806 0 2
22652: NOT
22653: AND
22654: IFFALSE 22713
// begin if IsInUnit ( p ) then
22656: LD_VAR 0 5
22660: PPUSH
22661: CALL_OW 310
22665: IFFALSE 22676
// ComExitBuilding ( p ) ;
22667: LD_VAR 0 5
22671: PPUSH
22672: CALL_OW 122
// ComEnterUnit ( p , e ) ;
22676: LD_VAR 0 5
22680: PPUSH
22681: LD_VAR 0 7
22685: PPUSH
22686: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
22690: LD_VAR 0 5
22694: PPUSH
22695: LD_VAR 0 3
22699: PPUSH
22700: CALL_OW 183
// AddComExitBuilding ( p ) ;
22704: LD_VAR 0 5
22708: PPUSH
22709: CALL_OW 182
// end ; end ;
22713: GO 22561
22715: POP
22716: POP
// end ;
22717: GO 22527
22719: POP
22720: POP
// end ;
22721: GO 22282
22723: POP
22724: POP
// end ;
22725: LD_VAR 0 1
22729: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
22730: LD_INT 0
22732: PPUSH
22733: PPUSH
22734: PPUSH
22735: PPUSH
22736: PPUSH
22737: PPUSH
22738: PPUSH
22739: PPUSH
22740: PPUSH
22741: PPUSH
22742: PPUSH
22743: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
22744: LD_VAR 0 1
22748: NOT
22749: PUSH
22750: LD_EXP 50
22754: PUSH
22755: LD_VAR 0 1
22759: ARRAY
22760: NOT
22761: OR
22762: PUSH
22763: LD_EXP 50
22767: PUSH
22768: LD_VAR 0 1
22772: ARRAY
22773: PPUSH
22774: LD_INT 2
22776: PUSH
22777: LD_INT 30
22779: PUSH
22780: LD_INT 0
22782: PUSH
22783: EMPTY
22784: LIST
22785: LIST
22786: PUSH
22787: LD_INT 30
22789: PUSH
22790: LD_INT 1
22792: PUSH
22793: EMPTY
22794: LIST
22795: LIST
22796: PUSH
22797: EMPTY
22798: LIST
22799: LIST
22800: LIST
22801: PPUSH
22802: CALL_OW 72
22806: NOT
22807: OR
22808: IFFALSE 22812
// exit ;
22810: GO 26315
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
22812: LD_ADDR_VAR 0 4
22816: PUSH
22817: LD_EXP 50
22821: PUSH
22822: LD_VAR 0 1
22826: ARRAY
22827: PPUSH
22828: LD_INT 2
22830: PUSH
22831: LD_INT 25
22833: PUSH
22834: LD_INT 1
22836: PUSH
22837: EMPTY
22838: LIST
22839: LIST
22840: PUSH
22841: LD_INT 25
22843: PUSH
22844: LD_INT 2
22846: PUSH
22847: EMPTY
22848: LIST
22849: LIST
22850: PUSH
22851: LD_INT 25
22853: PUSH
22854: LD_INT 3
22856: PUSH
22857: EMPTY
22858: LIST
22859: LIST
22860: PUSH
22861: LD_INT 25
22863: PUSH
22864: LD_INT 4
22866: PUSH
22867: EMPTY
22868: LIST
22869: LIST
22870: PUSH
22871: LD_INT 25
22873: PUSH
22874: LD_INT 5
22876: PUSH
22877: EMPTY
22878: LIST
22879: LIST
22880: PUSH
22881: LD_INT 25
22883: PUSH
22884: LD_INT 8
22886: PUSH
22887: EMPTY
22888: LIST
22889: LIST
22890: PUSH
22891: LD_INT 25
22893: PUSH
22894: LD_INT 9
22896: PUSH
22897: EMPTY
22898: LIST
22899: LIST
22900: PUSH
22901: EMPTY
22902: LIST
22903: LIST
22904: LIST
22905: LIST
22906: LIST
22907: LIST
22908: LIST
22909: LIST
22910: PPUSH
22911: CALL_OW 72
22915: ST_TO_ADDR
// if not tmp then
22916: LD_VAR 0 4
22920: NOT
22921: IFFALSE 22925
// exit ;
22923: GO 26315
// for i in tmp do
22925: LD_ADDR_VAR 0 3
22929: PUSH
22930: LD_VAR 0 4
22934: PUSH
22935: FOR_IN
22936: IFFALSE 22967
// if GetTag ( i ) then
22938: LD_VAR 0 3
22942: PPUSH
22943: CALL_OW 110
22947: IFFALSE 22965
// tmp := tmp diff i ;
22949: LD_ADDR_VAR 0 4
22953: PUSH
22954: LD_VAR 0 4
22958: PUSH
22959: LD_VAR 0 3
22963: DIFF
22964: ST_TO_ADDR
22965: GO 22935
22967: POP
22968: POP
// if not tmp then
22969: LD_VAR 0 4
22973: NOT
22974: IFFALSE 22978
// exit ;
22976: GO 26315
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
22978: LD_ADDR_VAR 0 5
22982: PUSH
22983: LD_EXP 50
22987: PUSH
22988: LD_VAR 0 1
22992: ARRAY
22993: PPUSH
22994: LD_INT 2
22996: PUSH
22997: LD_INT 25
22999: PUSH
23000: LD_INT 1
23002: PUSH
23003: EMPTY
23004: LIST
23005: LIST
23006: PUSH
23007: LD_INT 25
23009: PUSH
23010: LD_INT 5
23012: PUSH
23013: EMPTY
23014: LIST
23015: LIST
23016: PUSH
23017: LD_INT 25
23019: PUSH
23020: LD_INT 8
23022: PUSH
23023: EMPTY
23024: LIST
23025: LIST
23026: PUSH
23027: LD_INT 25
23029: PUSH
23030: LD_INT 9
23032: PUSH
23033: EMPTY
23034: LIST
23035: LIST
23036: PUSH
23037: EMPTY
23038: LIST
23039: LIST
23040: LIST
23041: LIST
23042: LIST
23043: PPUSH
23044: CALL_OW 72
23048: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
23049: LD_ADDR_VAR 0 6
23053: PUSH
23054: LD_EXP 50
23058: PUSH
23059: LD_VAR 0 1
23063: ARRAY
23064: PPUSH
23065: LD_INT 25
23067: PUSH
23068: LD_INT 2
23070: PUSH
23071: EMPTY
23072: LIST
23073: LIST
23074: PPUSH
23075: CALL_OW 72
23079: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
23080: LD_ADDR_VAR 0 7
23084: PUSH
23085: LD_EXP 50
23089: PUSH
23090: LD_VAR 0 1
23094: ARRAY
23095: PPUSH
23096: LD_INT 25
23098: PUSH
23099: LD_INT 3
23101: PUSH
23102: EMPTY
23103: LIST
23104: LIST
23105: PPUSH
23106: CALL_OW 72
23110: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
23111: LD_ADDR_VAR 0 8
23115: PUSH
23116: LD_EXP 50
23120: PUSH
23121: LD_VAR 0 1
23125: ARRAY
23126: PPUSH
23127: LD_INT 25
23129: PUSH
23130: LD_INT 4
23132: PUSH
23133: EMPTY
23134: LIST
23135: LIST
23136: PUSH
23137: LD_INT 24
23139: PUSH
23140: LD_INT 251
23142: PUSH
23143: EMPTY
23144: LIST
23145: LIST
23146: PUSH
23147: EMPTY
23148: LIST
23149: LIST
23150: PPUSH
23151: CALL_OW 72
23155: ST_TO_ADDR
// if mc_is_defending [ base ] then
23156: LD_EXP 93
23160: PUSH
23161: LD_VAR 0 1
23165: ARRAY
23166: IFFALSE 23627
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
23168: LD_ADDR_EXP 92
23172: PUSH
23173: LD_EXP 92
23177: PPUSH
23178: LD_VAR 0 1
23182: PPUSH
23183: LD_INT 4
23185: PPUSH
23186: CALL_OW 1
23190: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
23191: LD_ADDR_VAR 0 12
23195: PUSH
23196: LD_EXP 50
23200: PUSH
23201: LD_VAR 0 1
23205: ARRAY
23206: PPUSH
23207: LD_INT 2
23209: PUSH
23210: LD_INT 30
23212: PUSH
23213: LD_INT 4
23215: PUSH
23216: EMPTY
23217: LIST
23218: LIST
23219: PUSH
23220: LD_INT 30
23222: PUSH
23223: LD_INT 5
23225: PUSH
23226: EMPTY
23227: LIST
23228: LIST
23229: PUSH
23230: EMPTY
23231: LIST
23232: LIST
23233: LIST
23234: PPUSH
23235: CALL_OW 72
23239: ST_TO_ADDR
// if not b then
23240: LD_VAR 0 12
23244: NOT
23245: IFFALSE 23249
// exit ;
23247: GO 26315
// p := [ ] ;
23249: LD_ADDR_VAR 0 11
23253: PUSH
23254: EMPTY
23255: ST_TO_ADDR
// if sci >= 2 then
23256: LD_VAR 0 8
23260: PUSH
23261: LD_INT 2
23263: GREATEREQUAL
23264: IFFALSE 23295
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
23266: LD_ADDR_VAR 0 8
23270: PUSH
23271: LD_VAR 0 8
23275: PUSH
23276: LD_INT 1
23278: ARRAY
23279: PUSH
23280: LD_VAR 0 8
23284: PUSH
23285: LD_INT 2
23287: ARRAY
23288: PUSH
23289: EMPTY
23290: LIST
23291: LIST
23292: ST_TO_ADDR
23293: GO 23356
// if sci = 1 then
23295: LD_VAR 0 8
23299: PUSH
23300: LD_INT 1
23302: EQUAL
23303: IFFALSE 23324
// sci := [ sci [ 1 ] ] else
23305: LD_ADDR_VAR 0 8
23309: PUSH
23310: LD_VAR 0 8
23314: PUSH
23315: LD_INT 1
23317: ARRAY
23318: PUSH
23319: EMPTY
23320: LIST
23321: ST_TO_ADDR
23322: GO 23356
// if sci = 0 then
23324: LD_VAR 0 8
23328: PUSH
23329: LD_INT 0
23331: EQUAL
23332: IFFALSE 23356
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
23334: LD_ADDR_VAR 0 11
23338: PUSH
23339: LD_VAR 0 4
23343: PPUSH
23344: LD_INT 4
23346: PPUSH
23347: CALL 84678 0 2
23351: PUSH
23352: LD_INT 1
23354: ARRAY
23355: ST_TO_ADDR
// if eng > 4 then
23356: LD_VAR 0 6
23360: PUSH
23361: LD_INT 4
23363: GREATER
23364: IFFALSE 23410
// for i = eng downto 4 do
23366: LD_ADDR_VAR 0 3
23370: PUSH
23371: DOUBLE
23372: LD_VAR 0 6
23376: INC
23377: ST_TO_ADDR
23378: LD_INT 4
23380: PUSH
23381: FOR_DOWNTO
23382: IFFALSE 23408
// eng := eng diff eng [ i ] ;
23384: LD_ADDR_VAR 0 6
23388: PUSH
23389: LD_VAR 0 6
23393: PUSH
23394: LD_VAR 0 6
23398: PUSH
23399: LD_VAR 0 3
23403: ARRAY
23404: DIFF
23405: ST_TO_ADDR
23406: GO 23381
23408: POP
23409: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
23410: LD_ADDR_VAR 0 4
23414: PUSH
23415: LD_VAR 0 4
23419: PUSH
23420: LD_VAR 0 5
23424: PUSH
23425: LD_VAR 0 6
23429: UNION
23430: PUSH
23431: LD_VAR 0 7
23435: UNION
23436: PUSH
23437: LD_VAR 0 8
23441: UNION
23442: DIFF
23443: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
23444: LD_ADDR_VAR 0 13
23448: PUSH
23449: LD_EXP 50
23453: PUSH
23454: LD_VAR 0 1
23458: ARRAY
23459: PPUSH
23460: LD_INT 2
23462: PUSH
23463: LD_INT 30
23465: PUSH
23466: LD_INT 32
23468: PUSH
23469: EMPTY
23470: LIST
23471: LIST
23472: PUSH
23473: LD_INT 30
23475: PUSH
23476: LD_INT 31
23478: PUSH
23479: EMPTY
23480: LIST
23481: LIST
23482: PUSH
23483: EMPTY
23484: LIST
23485: LIST
23486: LIST
23487: PPUSH
23488: CALL_OW 72
23492: PUSH
23493: LD_EXP 50
23497: PUSH
23498: LD_VAR 0 1
23502: ARRAY
23503: PPUSH
23504: LD_INT 2
23506: PUSH
23507: LD_INT 30
23509: PUSH
23510: LD_INT 4
23512: PUSH
23513: EMPTY
23514: LIST
23515: LIST
23516: PUSH
23517: LD_INT 30
23519: PUSH
23520: LD_INT 5
23522: PUSH
23523: EMPTY
23524: LIST
23525: LIST
23526: PUSH
23527: EMPTY
23528: LIST
23529: LIST
23530: LIST
23531: PPUSH
23532: CALL_OW 72
23536: PUSH
23537: LD_INT 6
23539: MUL
23540: PLUS
23541: ST_TO_ADDR
// if bcount < tmp then
23542: LD_VAR 0 13
23546: PUSH
23547: LD_VAR 0 4
23551: LESS
23552: IFFALSE 23598
// for i = tmp downto bcount do
23554: LD_ADDR_VAR 0 3
23558: PUSH
23559: DOUBLE
23560: LD_VAR 0 4
23564: INC
23565: ST_TO_ADDR
23566: LD_VAR 0 13
23570: PUSH
23571: FOR_DOWNTO
23572: IFFALSE 23596
// tmp := Delete ( tmp , tmp ) ;
23574: LD_ADDR_VAR 0 4
23578: PUSH
23579: LD_VAR 0 4
23583: PPUSH
23584: LD_VAR 0 4
23588: PPUSH
23589: CALL_OW 3
23593: ST_TO_ADDR
23594: GO 23571
23596: POP
23597: POP
// result := [ tmp , 0 , 0 , p ] ;
23598: LD_ADDR_VAR 0 2
23602: PUSH
23603: LD_VAR 0 4
23607: PUSH
23608: LD_INT 0
23610: PUSH
23611: LD_INT 0
23613: PUSH
23614: LD_VAR 0 11
23618: PUSH
23619: EMPTY
23620: LIST
23621: LIST
23622: LIST
23623: LIST
23624: ST_TO_ADDR
// exit ;
23625: GO 26315
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
23627: LD_EXP 50
23631: PUSH
23632: LD_VAR 0 1
23636: ARRAY
23637: PPUSH
23638: LD_INT 2
23640: PUSH
23641: LD_INT 30
23643: PUSH
23644: LD_INT 6
23646: PUSH
23647: EMPTY
23648: LIST
23649: LIST
23650: PUSH
23651: LD_INT 30
23653: PUSH
23654: LD_INT 7
23656: PUSH
23657: EMPTY
23658: LIST
23659: LIST
23660: PUSH
23661: LD_INT 30
23663: PUSH
23664: LD_INT 8
23666: PUSH
23667: EMPTY
23668: LIST
23669: LIST
23670: PUSH
23671: EMPTY
23672: LIST
23673: LIST
23674: LIST
23675: LIST
23676: PPUSH
23677: CALL_OW 72
23681: NOT
23682: PUSH
23683: LD_EXP 50
23687: PUSH
23688: LD_VAR 0 1
23692: ARRAY
23693: PPUSH
23694: LD_INT 30
23696: PUSH
23697: LD_INT 3
23699: PUSH
23700: EMPTY
23701: LIST
23702: LIST
23703: PPUSH
23704: CALL_OW 72
23708: NOT
23709: AND
23710: IFFALSE 23782
// begin if eng = tmp then
23712: LD_VAR 0 6
23716: PUSH
23717: LD_VAR 0 4
23721: EQUAL
23722: IFFALSE 23726
// exit ;
23724: GO 26315
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
23726: LD_ADDR_EXP 92
23730: PUSH
23731: LD_EXP 92
23735: PPUSH
23736: LD_VAR 0 1
23740: PPUSH
23741: LD_INT 1
23743: PPUSH
23744: CALL_OW 1
23748: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
23749: LD_ADDR_VAR 0 2
23753: PUSH
23754: LD_INT 0
23756: PUSH
23757: LD_VAR 0 4
23761: PUSH
23762: LD_VAR 0 6
23766: DIFF
23767: PUSH
23768: LD_INT 0
23770: PUSH
23771: LD_INT 0
23773: PUSH
23774: EMPTY
23775: LIST
23776: LIST
23777: LIST
23778: LIST
23779: ST_TO_ADDR
// exit ;
23780: GO 26315
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
23782: LD_EXP 77
23786: PUSH
23787: LD_EXP 76
23791: PUSH
23792: LD_VAR 0 1
23796: ARRAY
23797: ARRAY
23798: PUSH
23799: LD_EXP 50
23803: PUSH
23804: LD_VAR 0 1
23808: ARRAY
23809: PPUSH
23810: LD_INT 2
23812: PUSH
23813: LD_INT 30
23815: PUSH
23816: LD_INT 6
23818: PUSH
23819: EMPTY
23820: LIST
23821: LIST
23822: PUSH
23823: LD_INT 30
23825: PUSH
23826: LD_INT 7
23828: PUSH
23829: EMPTY
23830: LIST
23831: LIST
23832: PUSH
23833: LD_INT 30
23835: PUSH
23836: LD_INT 8
23838: PUSH
23839: EMPTY
23840: LIST
23841: LIST
23842: PUSH
23843: EMPTY
23844: LIST
23845: LIST
23846: LIST
23847: LIST
23848: PPUSH
23849: CALL_OW 72
23853: AND
23854: PUSH
23855: LD_EXP 50
23859: PUSH
23860: LD_VAR 0 1
23864: ARRAY
23865: PPUSH
23866: LD_INT 30
23868: PUSH
23869: LD_INT 3
23871: PUSH
23872: EMPTY
23873: LIST
23874: LIST
23875: PPUSH
23876: CALL_OW 72
23880: NOT
23881: AND
23882: IFFALSE 24096
// begin if sci >= 6 then
23884: LD_VAR 0 8
23888: PUSH
23889: LD_INT 6
23891: GREATEREQUAL
23892: IFFALSE 23896
// exit ;
23894: GO 26315
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
23896: LD_ADDR_EXP 92
23900: PUSH
23901: LD_EXP 92
23905: PPUSH
23906: LD_VAR 0 1
23910: PPUSH
23911: LD_INT 2
23913: PPUSH
23914: CALL_OW 1
23918: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
23919: LD_ADDR_VAR 0 9
23923: PUSH
23924: LD_VAR 0 4
23928: PUSH
23929: LD_VAR 0 8
23933: DIFF
23934: PPUSH
23935: LD_INT 4
23937: PPUSH
23938: CALL 84678 0 2
23942: ST_TO_ADDR
// p := [ ] ;
23943: LD_ADDR_VAR 0 11
23947: PUSH
23948: EMPTY
23949: ST_TO_ADDR
// if sci < 6 and sort > 6 then
23950: LD_VAR 0 8
23954: PUSH
23955: LD_INT 6
23957: LESS
23958: PUSH
23959: LD_VAR 0 9
23963: PUSH
23964: LD_INT 6
23966: GREATER
23967: AND
23968: IFFALSE 24049
// begin for i = 1 to 6 - sci do
23970: LD_ADDR_VAR 0 3
23974: PUSH
23975: DOUBLE
23976: LD_INT 1
23978: DEC
23979: ST_TO_ADDR
23980: LD_INT 6
23982: PUSH
23983: LD_VAR 0 8
23987: MINUS
23988: PUSH
23989: FOR_TO
23990: IFFALSE 24045
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
23992: LD_ADDR_VAR 0 11
23996: PUSH
23997: LD_VAR 0 11
24001: PPUSH
24002: LD_VAR 0 11
24006: PUSH
24007: LD_INT 1
24009: PLUS
24010: PPUSH
24011: LD_VAR 0 9
24015: PUSH
24016: LD_INT 1
24018: ARRAY
24019: PPUSH
24020: CALL_OW 2
24024: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
24025: LD_ADDR_VAR 0 9
24029: PUSH
24030: LD_VAR 0 9
24034: PPUSH
24035: LD_INT 1
24037: PPUSH
24038: CALL_OW 3
24042: ST_TO_ADDR
// end ;
24043: GO 23989
24045: POP
24046: POP
// end else
24047: GO 24069
// if sort then
24049: LD_VAR 0 9
24053: IFFALSE 24069
// p := sort [ 1 ] ;
24055: LD_ADDR_VAR 0 11
24059: PUSH
24060: LD_VAR 0 9
24064: PUSH
24065: LD_INT 1
24067: ARRAY
24068: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
24069: LD_ADDR_VAR 0 2
24073: PUSH
24074: LD_INT 0
24076: PUSH
24077: LD_INT 0
24079: PUSH
24080: LD_INT 0
24082: PUSH
24083: LD_VAR 0 11
24087: PUSH
24088: EMPTY
24089: LIST
24090: LIST
24091: LIST
24092: LIST
24093: ST_TO_ADDR
// exit ;
24094: GO 26315
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
24096: LD_EXP 77
24100: PUSH
24101: LD_EXP 76
24105: PUSH
24106: LD_VAR 0 1
24110: ARRAY
24111: ARRAY
24112: PUSH
24113: LD_EXP 50
24117: PUSH
24118: LD_VAR 0 1
24122: ARRAY
24123: PPUSH
24124: LD_INT 2
24126: PUSH
24127: LD_INT 30
24129: PUSH
24130: LD_INT 6
24132: PUSH
24133: EMPTY
24134: LIST
24135: LIST
24136: PUSH
24137: LD_INT 30
24139: PUSH
24140: LD_INT 7
24142: PUSH
24143: EMPTY
24144: LIST
24145: LIST
24146: PUSH
24147: LD_INT 30
24149: PUSH
24150: LD_INT 8
24152: PUSH
24153: EMPTY
24154: LIST
24155: LIST
24156: PUSH
24157: EMPTY
24158: LIST
24159: LIST
24160: LIST
24161: LIST
24162: PPUSH
24163: CALL_OW 72
24167: AND
24168: PUSH
24169: LD_EXP 50
24173: PUSH
24174: LD_VAR 0 1
24178: ARRAY
24179: PPUSH
24180: LD_INT 30
24182: PUSH
24183: LD_INT 3
24185: PUSH
24186: EMPTY
24187: LIST
24188: LIST
24189: PPUSH
24190: CALL_OW 72
24194: AND
24195: IFFALSE 24929
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
24197: LD_ADDR_EXP 92
24201: PUSH
24202: LD_EXP 92
24206: PPUSH
24207: LD_VAR 0 1
24211: PPUSH
24212: LD_INT 3
24214: PPUSH
24215: CALL_OW 1
24219: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
24220: LD_ADDR_VAR 0 2
24224: PUSH
24225: LD_INT 0
24227: PUSH
24228: LD_INT 0
24230: PUSH
24231: LD_INT 0
24233: PUSH
24234: LD_INT 0
24236: PUSH
24237: EMPTY
24238: LIST
24239: LIST
24240: LIST
24241: LIST
24242: ST_TO_ADDR
// if not eng then
24243: LD_VAR 0 6
24247: NOT
24248: IFFALSE 24311
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
24250: LD_ADDR_VAR 0 11
24254: PUSH
24255: LD_VAR 0 4
24259: PPUSH
24260: LD_INT 2
24262: PPUSH
24263: CALL 84678 0 2
24267: PUSH
24268: LD_INT 1
24270: ARRAY
24271: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
24272: LD_ADDR_VAR 0 2
24276: PUSH
24277: LD_VAR 0 2
24281: PPUSH
24282: LD_INT 2
24284: PPUSH
24285: LD_VAR 0 11
24289: PPUSH
24290: CALL_OW 1
24294: ST_TO_ADDR
// tmp := tmp diff p ;
24295: LD_ADDR_VAR 0 4
24299: PUSH
24300: LD_VAR 0 4
24304: PUSH
24305: LD_VAR 0 11
24309: DIFF
24310: ST_TO_ADDR
// end ; if tmp and sci < 6 then
24311: LD_VAR 0 4
24315: PUSH
24316: LD_VAR 0 8
24320: PUSH
24321: LD_INT 6
24323: LESS
24324: AND
24325: IFFALSE 24513
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
24327: LD_ADDR_VAR 0 9
24331: PUSH
24332: LD_VAR 0 4
24336: PUSH
24337: LD_VAR 0 8
24341: PUSH
24342: LD_VAR 0 7
24346: UNION
24347: DIFF
24348: PPUSH
24349: LD_INT 4
24351: PPUSH
24352: CALL 84678 0 2
24356: ST_TO_ADDR
// p := [ ] ;
24357: LD_ADDR_VAR 0 11
24361: PUSH
24362: EMPTY
24363: ST_TO_ADDR
// if sort then
24364: LD_VAR 0 9
24368: IFFALSE 24484
// for i = 1 to 6 - sci do
24370: LD_ADDR_VAR 0 3
24374: PUSH
24375: DOUBLE
24376: LD_INT 1
24378: DEC
24379: ST_TO_ADDR
24380: LD_INT 6
24382: PUSH
24383: LD_VAR 0 8
24387: MINUS
24388: PUSH
24389: FOR_TO
24390: IFFALSE 24482
// begin if i = sort then
24392: LD_VAR 0 3
24396: PUSH
24397: LD_VAR 0 9
24401: EQUAL
24402: IFFALSE 24406
// break ;
24404: GO 24482
// if GetClass ( i ) = 4 then
24406: LD_VAR 0 3
24410: PPUSH
24411: CALL_OW 257
24415: PUSH
24416: LD_INT 4
24418: EQUAL
24419: IFFALSE 24423
// continue ;
24421: GO 24389
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24423: LD_ADDR_VAR 0 11
24427: PUSH
24428: LD_VAR 0 11
24432: PPUSH
24433: LD_VAR 0 11
24437: PUSH
24438: LD_INT 1
24440: PLUS
24441: PPUSH
24442: LD_VAR 0 9
24446: PUSH
24447: LD_VAR 0 3
24451: ARRAY
24452: PPUSH
24453: CALL_OW 2
24457: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24458: LD_ADDR_VAR 0 4
24462: PUSH
24463: LD_VAR 0 4
24467: PUSH
24468: LD_VAR 0 9
24472: PUSH
24473: LD_VAR 0 3
24477: ARRAY
24478: DIFF
24479: ST_TO_ADDR
// end ;
24480: GO 24389
24482: POP
24483: POP
// if p then
24484: LD_VAR 0 11
24488: IFFALSE 24513
// result := Replace ( result , 4 , p ) ;
24490: LD_ADDR_VAR 0 2
24494: PUSH
24495: LD_VAR 0 2
24499: PPUSH
24500: LD_INT 4
24502: PPUSH
24503: LD_VAR 0 11
24507: PPUSH
24508: CALL_OW 1
24512: ST_TO_ADDR
// end ; if tmp and mech < 6 then
24513: LD_VAR 0 4
24517: PUSH
24518: LD_VAR 0 7
24522: PUSH
24523: LD_INT 6
24525: LESS
24526: AND
24527: IFFALSE 24715
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
24529: LD_ADDR_VAR 0 9
24533: PUSH
24534: LD_VAR 0 4
24538: PUSH
24539: LD_VAR 0 8
24543: PUSH
24544: LD_VAR 0 7
24548: UNION
24549: DIFF
24550: PPUSH
24551: LD_INT 3
24553: PPUSH
24554: CALL 84678 0 2
24558: ST_TO_ADDR
// p := [ ] ;
24559: LD_ADDR_VAR 0 11
24563: PUSH
24564: EMPTY
24565: ST_TO_ADDR
// if sort then
24566: LD_VAR 0 9
24570: IFFALSE 24686
// for i = 1 to 6 - mech do
24572: LD_ADDR_VAR 0 3
24576: PUSH
24577: DOUBLE
24578: LD_INT 1
24580: DEC
24581: ST_TO_ADDR
24582: LD_INT 6
24584: PUSH
24585: LD_VAR 0 7
24589: MINUS
24590: PUSH
24591: FOR_TO
24592: IFFALSE 24684
// begin if i = sort then
24594: LD_VAR 0 3
24598: PUSH
24599: LD_VAR 0 9
24603: EQUAL
24604: IFFALSE 24608
// break ;
24606: GO 24684
// if GetClass ( i ) = 3 then
24608: LD_VAR 0 3
24612: PPUSH
24613: CALL_OW 257
24617: PUSH
24618: LD_INT 3
24620: EQUAL
24621: IFFALSE 24625
// continue ;
24623: GO 24591
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24625: LD_ADDR_VAR 0 11
24629: PUSH
24630: LD_VAR 0 11
24634: PPUSH
24635: LD_VAR 0 11
24639: PUSH
24640: LD_INT 1
24642: PLUS
24643: PPUSH
24644: LD_VAR 0 9
24648: PUSH
24649: LD_VAR 0 3
24653: ARRAY
24654: PPUSH
24655: CALL_OW 2
24659: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24660: LD_ADDR_VAR 0 4
24664: PUSH
24665: LD_VAR 0 4
24669: PUSH
24670: LD_VAR 0 9
24674: PUSH
24675: LD_VAR 0 3
24679: ARRAY
24680: DIFF
24681: ST_TO_ADDR
// end ;
24682: GO 24591
24684: POP
24685: POP
// if p then
24686: LD_VAR 0 11
24690: IFFALSE 24715
// result := Replace ( result , 3 , p ) ;
24692: LD_ADDR_VAR 0 2
24696: PUSH
24697: LD_VAR 0 2
24701: PPUSH
24702: LD_INT 3
24704: PPUSH
24705: LD_VAR 0 11
24709: PPUSH
24710: CALL_OW 1
24714: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
24715: LD_VAR 0 4
24719: PUSH
24720: LD_INT 6
24722: GREATER
24723: PUSH
24724: LD_VAR 0 6
24728: PUSH
24729: LD_INT 6
24731: LESS
24732: AND
24733: IFFALSE 24927
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
24735: LD_ADDR_VAR 0 9
24739: PUSH
24740: LD_VAR 0 4
24744: PUSH
24745: LD_VAR 0 8
24749: PUSH
24750: LD_VAR 0 7
24754: UNION
24755: PUSH
24756: LD_VAR 0 6
24760: UNION
24761: DIFF
24762: PPUSH
24763: LD_INT 2
24765: PPUSH
24766: CALL 84678 0 2
24770: ST_TO_ADDR
// p := [ ] ;
24771: LD_ADDR_VAR 0 11
24775: PUSH
24776: EMPTY
24777: ST_TO_ADDR
// if sort then
24778: LD_VAR 0 9
24782: IFFALSE 24898
// for i = 1 to 6 - eng do
24784: LD_ADDR_VAR 0 3
24788: PUSH
24789: DOUBLE
24790: LD_INT 1
24792: DEC
24793: ST_TO_ADDR
24794: LD_INT 6
24796: PUSH
24797: LD_VAR 0 6
24801: MINUS
24802: PUSH
24803: FOR_TO
24804: IFFALSE 24896
// begin if i = sort then
24806: LD_VAR 0 3
24810: PUSH
24811: LD_VAR 0 9
24815: EQUAL
24816: IFFALSE 24820
// break ;
24818: GO 24896
// if GetClass ( i ) = 2 then
24820: LD_VAR 0 3
24824: PPUSH
24825: CALL_OW 257
24829: PUSH
24830: LD_INT 2
24832: EQUAL
24833: IFFALSE 24837
// continue ;
24835: GO 24803
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24837: LD_ADDR_VAR 0 11
24841: PUSH
24842: LD_VAR 0 11
24846: PPUSH
24847: LD_VAR 0 11
24851: PUSH
24852: LD_INT 1
24854: PLUS
24855: PPUSH
24856: LD_VAR 0 9
24860: PUSH
24861: LD_VAR 0 3
24865: ARRAY
24866: PPUSH
24867: CALL_OW 2
24871: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24872: LD_ADDR_VAR 0 4
24876: PUSH
24877: LD_VAR 0 4
24881: PUSH
24882: LD_VAR 0 9
24886: PUSH
24887: LD_VAR 0 3
24891: ARRAY
24892: DIFF
24893: ST_TO_ADDR
// end ;
24894: GO 24803
24896: POP
24897: POP
// if p then
24898: LD_VAR 0 11
24902: IFFALSE 24927
// result := Replace ( result , 2 , p ) ;
24904: LD_ADDR_VAR 0 2
24908: PUSH
24909: LD_VAR 0 2
24913: PPUSH
24914: LD_INT 2
24916: PPUSH
24917: LD_VAR 0 11
24921: PPUSH
24922: CALL_OW 1
24926: ST_TO_ADDR
// end ; exit ;
24927: GO 26315
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
24929: LD_EXP 77
24933: PUSH
24934: LD_EXP 76
24938: PUSH
24939: LD_VAR 0 1
24943: ARRAY
24944: ARRAY
24945: NOT
24946: PUSH
24947: LD_EXP 50
24951: PUSH
24952: LD_VAR 0 1
24956: ARRAY
24957: PPUSH
24958: LD_INT 30
24960: PUSH
24961: LD_INT 3
24963: PUSH
24964: EMPTY
24965: LIST
24966: LIST
24967: PPUSH
24968: CALL_OW 72
24972: AND
24973: PUSH
24974: LD_EXP 55
24978: PUSH
24979: LD_VAR 0 1
24983: ARRAY
24984: AND
24985: IFFALSE 25593
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
24987: LD_ADDR_EXP 92
24991: PUSH
24992: LD_EXP 92
24996: PPUSH
24997: LD_VAR 0 1
25001: PPUSH
25002: LD_INT 5
25004: PPUSH
25005: CALL_OW 1
25009: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
25010: LD_ADDR_VAR 0 2
25014: PUSH
25015: LD_INT 0
25017: PUSH
25018: LD_INT 0
25020: PUSH
25021: LD_INT 0
25023: PUSH
25024: LD_INT 0
25026: PUSH
25027: EMPTY
25028: LIST
25029: LIST
25030: LIST
25031: LIST
25032: ST_TO_ADDR
// if sci > 1 then
25033: LD_VAR 0 8
25037: PUSH
25038: LD_INT 1
25040: GREATER
25041: IFFALSE 25069
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
25043: LD_ADDR_VAR 0 4
25047: PUSH
25048: LD_VAR 0 4
25052: PUSH
25053: LD_VAR 0 8
25057: PUSH
25058: LD_VAR 0 8
25062: PUSH
25063: LD_INT 1
25065: ARRAY
25066: DIFF
25067: DIFF
25068: ST_TO_ADDR
// if tmp and not sci then
25069: LD_VAR 0 4
25073: PUSH
25074: LD_VAR 0 8
25078: NOT
25079: AND
25080: IFFALSE 25149
// begin sort := SortBySkill ( tmp , 4 ) ;
25082: LD_ADDR_VAR 0 9
25086: PUSH
25087: LD_VAR 0 4
25091: PPUSH
25092: LD_INT 4
25094: PPUSH
25095: CALL 84678 0 2
25099: ST_TO_ADDR
// if sort then
25100: LD_VAR 0 9
25104: IFFALSE 25120
// p := sort [ 1 ] ;
25106: LD_ADDR_VAR 0 11
25110: PUSH
25111: LD_VAR 0 9
25115: PUSH
25116: LD_INT 1
25118: ARRAY
25119: ST_TO_ADDR
// if p then
25120: LD_VAR 0 11
25124: IFFALSE 25149
// result := Replace ( result , 4 , p ) ;
25126: LD_ADDR_VAR 0 2
25130: PUSH
25131: LD_VAR 0 2
25135: PPUSH
25136: LD_INT 4
25138: PPUSH
25139: LD_VAR 0 11
25143: PPUSH
25144: CALL_OW 1
25148: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
25149: LD_ADDR_VAR 0 4
25153: PUSH
25154: LD_VAR 0 4
25158: PUSH
25159: LD_VAR 0 7
25163: DIFF
25164: ST_TO_ADDR
// if tmp and mech < 6 then
25165: LD_VAR 0 4
25169: PUSH
25170: LD_VAR 0 7
25174: PUSH
25175: LD_INT 6
25177: LESS
25178: AND
25179: IFFALSE 25367
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
25181: LD_ADDR_VAR 0 9
25185: PUSH
25186: LD_VAR 0 4
25190: PUSH
25191: LD_VAR 0 8
25195: PUSH
25196: LD_VAR 0 7
25200: UNION
25201: DIFF
25202: PPUSH
25203: LD_INT 3
25205: PPUSH
25206: CALL 84678 0 2
25210: ST_TO_ADDR
// p := [ ] ;
25211: LD_ADDR_VAR 0 11
25215: PUSH
25216: EMPTY
25217: ST_TO_ADDR
// if sort then
25218: LD_VAR 0 9
25222: IFFALSE 25338
// for i = 1 to 6 - mech do
25224: LD_ADDR_VAR 0 3
25228: PUSH
25229: DOUBLE
25230: LD_INT 1
25232: DEC
25233: ST_TO_ADDR
25234: LD_INT 6
25236: PUSH
25237: LD_VAR 0 7
25241: MINUS
25242: PUSH
25243: FOR_TO
25244: IFFALSE 25336
// begin if i = sort then
25246: LD_VAR 0 3
25250: PUSH
25251: LD_VAR 0 9
25255: EQUAL
25256: IFFALSE 25260
// break ;
25258: GO 25336
// if GetClass ( i ) = 3 then
25260: LD_VAR 0 3
25264: PPUSH
25265: CALL_OW 257
25269: PUSH
25270: LD_INT 3
25272: EQUAL
25273: IFFALSE 25277
// continue ;
25275: GO 25243
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25277: LD_ADDR_VAR 0 11
25281: PUSH
25282: LD_VAR 0 11
25286: PPUSH
25287: LD_VAR 0 11
25291: PUSH
25292: LD_INT 1
25294: PLUS
25295: PPUSH
25296: LD_VAR 0 9
25300: PUSH
25301: LD_VAR 0 3
25305: ARRAY
25306: PPUSH
25307: CALL_OW 2
25311: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25312: LD_ADDR_VAR 0 4
25316: PUSH
25317: LD_VAR 0 4
25321: PUSH
25322: LD_VAR 0 9
25326: PUSH
25327: LD_VAR 0 3
25331: ARRAY
25332: DIFF
25333: ST_TO_ADDR
// end ;
25334: GO 25243
25336: POP
25337: POP
// if p then
25338: LD_VAR 0 11
25342: IFFALSE 25367
// result := Replace ( result , 3 , p ) ;
25344: LD_ADDR_VAR 0 2
25348: PUSH
25349: LD_VAR 0 2
25353: PPUSH
25354: LD_INT 3
25356: PPUSH
25357: LD_VAR 0 11
25361: PPUSH
25362: CALL_OW 1
25366: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
25367: LD_ADDR_VAR 0 4
25371: PUSH
25372: LD_VAR 0 4
25376: PUSH
25377: LD_VAR 0 6
25381: DIFF
25382: ST_TO_ADDR
// if tmp and eng < 6 then
25383: LD_VAR 0 4
25387: PUSH
25388: LD_VAR 0 6
25392: PUSH
25393: LD_INT 6
25395: LESS
25396: AND
25397: IFFALSE 25591
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
25399: LD_ADDR_VAR 0 9
25403: PUSH
25404: LD_VAR 0 4
25408: PUSH
25409: LD_VAR 0 8
25413: PUSH
25414: LD_VAR 0 7
25418: UNION
25419: PUSH
25420: LD_VAR 0 6
25424: UNION
25425: DIFF
25426: PPUSH
25427: LD_INT 2
25429: PPUSH
25430: CALL 84678 0 2
25434: ST_TO_ADDR
// p := [ ] ;
25435: LD_ADDR_VAR 0 11
25439: PUSH
25440: EMPTY
25441: ST_TO_ADDR
// if sort then
25442: LD_VAR 0 9
25446: IFFALSE 25562
// for i = 1 to 6 - eng do
25448: LD_ADDR_VAR 0 3
25452: PUSH
25453: DOUBLE
25454: LD_INT 1
25456: DEC
25457: ST_TO_ADDR
25458: LD_INT 6
25460: PUSH
25461: LD_VAR 0 6
25465: MINUS
25466: PUSH
25467: FOR_TO
25468: IFFALSE 25560
// begin if i = sort then
25470: LD_VAR 0 3
25474: PUSH
25475: LD_VAR 0 9
25479: EQUAL
25480: IFFALSE 25484
// break ;
25482: GO 25560
// if GetClass ( i ) = 2 then
25484: LD_VAR 0 3
25488: PPUSH
25489: CALL_OW 257
25493: PUSH
25494: LD_INT 2
25496: EQUAL
25497: IFFALSE 25501
// continue ;
25499: GO 25467
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25501: LD_ADDR_VAR 0 11
25505: PUSH
25506: LD_VAR 0 11
25510: PPUSH
25511: LD_VAR 0 11
25515: PUSH
25516: LD_INT 1
25518: PLUS
25519: PPUSH
25520: LD_VAR 0 9
25524: PUSH
25525: LD_VAR 0 3
25529: ARRAY
25530: PPUSH
25531: CALL_OW 2
25535: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25536: LD_ADDR_VAR 0 4
25540: PUSH
25541: LD_VAR 0 4
25545: PUSH
25546: LD_VAR 0 9
25550: PUSH
25551: LD_VAR 0 3
25555: ARRAY
25556: DIFF
25557: ST_TO_ADDR
// end ;
25558: GO 25467
25560: POP
25561: POP
// if p then
25562: LD_VAR 0 11
25566: IFFALSE 25591
// result := Replace ( result , 2 , p ) ;
25568: LD_ADDR_VAR 0 2
25572: PUSH
25573: LD_VAR 0 2
25577: PPUSH
25578: LD_INT 2
25580: PPUSH
25581: LD_VAR 0 11
25585: PPUSH
25586: CALL_OW 1
25590: ST_TO_ADDR
// end ; exit ;
25591: GO 26315
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
25593: LD_EXP 77
25597: PUSH
25598: LD_EXP 76
25602: PUSH
25603: LD_VAR 0 1
25607: ARRAY
25608: ARRAY
25609: NOT
25610: PUSH
25611: LD_EXP 50
25615: PUSH
25616: LD_VAR 0 1
25620: ARRAY
25621: PPUSH
25622: LD_INT 30
25624: PUSH
25625: LD_INT 3
25627: PUSH
25628: EMPTY
25629: LIST
25630: LIST
25631: PPUSH
25632: CALL_OW 72
25636: AND
25637: PUSH
25638: LD_EXP 55
25642: PUSH
25643: LD_VAR 0 1
25647: ARRAY
25648: NOT
25649: AND
25650: IFFALSE 26315
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
25652: LD_ADDR_EXP 92
25656: PUSH
25657: LD_EXP 92
25661: PPUSH
25662: LD_VAR 0 1
25666: PPUSH
25667: LD_INT 6
25669: PPUSH
25670: CALL_OW 1
25674: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
25675: LD_ADDR_VAR 0 2
25679: PUSH
25680: LD_INT 0
25682: PUSH
25683: LD_INT 0
25685: PUSH
25686: LD_INT 0
25688: PUSH
25689: LD_INT 0
25691: PUSH
25692: EMPTY
25693: LIST
25694: LIST
25695: LIST
25696: LIST
25697: ST_TO_ADDR
// if sci >= 1 then
25698: LD_VAR 0 8
25702: PUSH
25703: LD_INT 1
25705: GREATEREQUAL
25706: IFFALSE 25728
// tmp := tmp diff sci [ 1 ] ;
25708: LD_ADDR_VAR 0 4
25712: PUSH
25713: LD_VAR 0 4
25717: PUSH
25718: LD_VAR 0 8
25722: PUSH
25723: LD_INT 1
25725: ARRAY
25726: DIFF
25727: ST_TO_ADDR
// if tmp and not sci then
25728: LD_VAR 0 4
25732: PUSH
25733: LD_VAR 0 8
25737: NOT
25738: AND
25739: IFFALSE 25808
// begin sort := SortBySkill ( tmp , 4 ) ;
25741: LD_ADDR_VAR 0 9
25745: PUSH
25746: LD_VAR 0 4
25750: PPUSH
25751: LD_INT 4
25753: PPUSH
25754: CALL 84678 0 2
25758: ST_TO_ADDR
// if sort then
25759: LD_VAR 0 9
25763: IFFALSE 25779
// p := sort [ 1 ] ;
25765: LD_ADDR_VAR 0 11
25769: PUSH
25770: LD_VAR 0 9
25774: PUSH
25775: LD_INT 1
25777: ARRAY
25778: ST_TO_ADDR
// if p then
25779: LD_VAR 0 11
25783: IFFALSE 25808
// result := Replace ( result , 4 , p ) ;
25785: LD_ADDR_VAR 0 2
25789: PUSH
25790: LD_VAR 0 2
25794: PPUSH
25795: LD_INT 4
25797: PPUSH
25798: LD_VAR 0 11
25802: PPUSH
25803: CALL_OW 1
25807: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
25808: LD_ADDR_VAR 0 4
25812: PUSH
25813: LD_VAR 0 4
25817: PUSH
25818: LD_VAR 0 7
25822: DIFF
25823: ST_TO_ADDR
// if tmp and mech < 6 then
25824: LD_VAR 0 4
25828: PUSH
25829: LD_VAR 0 7
25833: PUSH
25834: LD_INT 6
25836: LESS
25837: AND
25838: IFFALSE 26020
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
25840: LD_ADDR_VAR 0 9
25844: PUSH
25845: LD_VAR 0 4
25849: PUSH
25850: LD_VAR 0 7
25854: DIFF
25855: PPUSH
25856: LD_INT 3
25858: PPUSH
25859: CALL 84678 0 2
25863: ST_TO_ADDR
// p := [ ] ;
25864: LD_ADDR_VAR 0 11
25868: PUSH
25869: EMPTY
25870: ST_TO_ADDR
// if sort then
25871: LD_VAR 0 9
25875: IFFALSE 25991
// for i = 1 to 6 - mech do
25877: LD_ADDR_VAR 0 3
25881: PUSH
25882: DOUBLE
25883: LD_INT 1
25885: DEC
25886: ST_TO_ADDR
25887: LD_INT 6
25889: PUSH
25890: LD_VAR 0 7
25894: MINUS
25895: PUSH
25896: FOR_TO
25897: IFFALSE 25989
// begin if i = sort then
25899: LD_VAR 0 3
25903: PUSH
25904: LD_VAR 0 9
25908: EQUAL
25909: IFFALSE 25913
// break ;
25911: GO 25989
// if GetClass ( i ) = 3 then
25913: LD_VAR 0 3
25917: PPUSH
25918: CALL_OW 257
25922: PUSH
25923: LD_INT 3
25925: EQUAL
25926: IFFALSE 25930
// continue ;
25928: GO 25896
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25930: LD_ADDR_VAR 0 11
25934: PUSH
25935: LD_VAR 0 11
25939: PPUSH
25940: LD_VAR 0 11
25944: PUSH
25945: LD_INT 1
25947: PLUS
25948: PPUSH
25949: LD_VAR 0 9
25953: PUSH
25954: LD_VAR 0 3
25958: ARRAY
25959: PPUSH
25960: CALL_OW 2
25964: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25965: LD_ADDR_VAR 0 4
25969: PUSH
25970: LD_VAR 0 4
25974: PUSH
25975: LD_VAR 0 9
25979: PUSH
25980: LD_VAR 0 3
25984: ARRAY
25985: DIFF
25986: ST_TO_ADDR
// end ;
25987: GO 25896
25989: POP
25990: POP
// if p then
25991: LD_VAR 0 11
25995: IFFALSE 26020
// result := Replace ( result , 3 , p ) ;
25997: LD_ADDR_VAR 0 2
26001: PUSH
26002: LD_VAR 0 2
26006: PPUSH
26007: LD_INT 3
26009: PPUSH
26010: LD_VAR 0 11
26014: PPUSH
26015: CALL_OW 1
26019: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
26020: LD_ADDR_VAR 0 4
26024: PUSH
26025: LD_VAR 0 4
26029: PUSH
26030: LD_VAR 0 6
26034: DIFF
26035: ST_TO_ADDR
// if tmp and eng < 4 then
26036: LD_VAR 0 4
26040: PUSH
26041: LD_VAR 0 6
26045: PUSH
26046: LD_INT 4
26048: LESS
26049: AND
26050: IFFALSE 26240
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
26052: LD_ADDR_VAR 0 9
26056: PUSH
26057: LD_VAR 0 4
26061: PUSH
26062: LD_VAR 0 7
26066: PUSH
26067: LD_VAR 0 6
26071: UNION
26072: DIFF
26073: PPUSH
26074: LD_INT 2
26076: PPUSH
26077: CALL 84678 0 2
26081: ST_TO_ADDR
// p := [ ] ;
26082: LD_ADDR_VAR 0 11
26086: PUSH
26087: EMPTY
26088: ST_TO_ADDR
// if sort then
26089: LD_VAR 0 9
26093: IFFALSE 26209
// for i = 1 to 4 - eng do
26095: LD_ADDR_VAR 0 3
26099: PUSH
26100: DOUBLE
26101: LD_INT 1
26103: DEC
26104: ST_TO_ADDR
26105: LD_INT 4
26107: PUSH
26108: LD_VAR 0 6
26112: MINUS
26113: PUSH
26114: FOR_TO
26115: IFFALSE 26207
// begin if i = sort then
26117: LD_VAR 0 3
26121: PUSH
26122: LD_VAR 0 9
26126: EQUAL
26127: IFFALSE 26131
// break ;
26129: GO 26207
// if GetClass ( i ) = 2 then
26131: LD_VAR 0 3
26135: PPUSH
26136: CALL_OW 257
26140: PUSH
26141: LD_INT 2
26143: EQUAL
26144: IFFALSE 26148
// continue ;
26146: GO 26114
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26148: LD_ADDR_VAR 0 11
26152: PUSH
26153: LD_VAR 0 11
26157: PPUSH
26158: LD_VAR 0 11
26162: PUSH
26163: LD_INT 1
26165: PLUS
26166: PPUSH
26167: LD_VAR 0 9
26171: PUSH
26172: LD_VAR 0 3
26176: ARRAY
26177: PPUSH
26178: CALL_OW 2
26182: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26183: LD_ADDR_VAR 0 4
26187: PUSH
26188: LD_VAR 0 4
26192: PUSH
26193: LD_VAR 0 9
26197: PUSH
26198: LD_VAR 0 3
26202: ARRAY
26203: DIFF
26204: ST_TO_ADDR
// end ;
26205: GO 26114
26207: POP
26208: POP
// if p then
26209: LD_VAR 0 11
26213: IFFALSE 26238
// result := Replace ( result , 2 , p ) ;
26215: LD_ADDR_VAR 0 2
26219: PUSH
26220: LD_VAR 0 2
26224: PPUSH
26225: LD_INT 2
26227: PPUSH
26228: LD_VAR 0 11
26232: PPUSH
26233: CALL_OW 1
26237: ST_TO_ADDR
// end else
26238: GO 26284
// for i = eng downto 5 do
26240: LD_ADDR_VAR 0 3
26244: PUSH
26245: DOUBLE
26246: LD_VAR 0 6
26250: INC
26251: ST_TO_ADDR
26252: LD_INT 5
26254: PUSH
26255: FOR_DOWNTO
26256: IFFALSE 26282
// tmp := tmp union eng [ i ] ;
26258: LD_ADDR_VAR 0 4
26262: PUSH
26263: LD_VAR 0 4
26267: PUSH
26268: LD_VAR 0 6
26272: PUSH
26273: LD_VAR 0 3
26277: ARRAY
26278: UNION
26279: ST_TO_ADDR
26280: GO 26255
26282: POP
26283: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
26284: LD_ADDR_VAR 0 2
26288: PUSH
26289: LD_VAR 0 2
26293: PPUSH
26294: LD_INT 1
26296: PPUSH
26297: LD_VAR 0 4
26301: PUSH
26302: LD_VAR 0 5
26306: DIFF
26307: PPUSH
26308: CALL_OW 1
26312: ST_TO_ADDR
// exit ;
26313: GO 26315
// end ; end ;
26315: LD_VAR 0 2
26319: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
26320: LD_INT 0
26322: PPUSH
26323: PPUSH
26324: PPUSH
// if not mc_bases then
26325: LD_EXP 50
26329: NOT
26330: IFFALSE 26334
// exit ;
26332: GO 26476
// for i = 1 to mc_bases do
26334: LD_ADDR_VAR 0 2
26338: PUSH
26339: DOUBLE
26340: LD_INT 1
26342: DEC
26343: ST_TO_ADDR
26344: LD_EXP 50
26348: PUSH
26349: FOR_TO
26350: IFFALSE 26467
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
26352: LD_ADDR_VAR 0 3
26356: PUSH
26357: LD_EXP 50
26361: PUSH
26362: LD_VAR 0 2
26366: ARRAY
26367: PPUSH
26368: LD_INT 21
26370: PUSH
26371: LD_INT 3
26373: PUSH
26374: EMPTY
26375: LIST
26376: LIST
26377: PUSH
26378: LD_INT 3
26380: PUSH
26381: LD_INT 2
26383: PUSH
26384: LD_INT 30
26386: PUSH
26387: LD_INT 29
26389: PUSH
26390: EMPTY
26391: LIST
26392: LIST
26393: PUSH
26394: LD_INT 30
26396: PUSH
26397: LD_INT 30
26399: PUSH
26400: EMPTY
26401: LIST
26402: LIST
26403: PUSH
26404: EMPTY
26405: LIST
26406: LIST
26407: LIST
26408: PUSH
26409: EMPTY
26410: LIST
26411: LIST
26412: PUSH
26413: LD_INT 3
26415: PUSH
26416: LD_INT 24
26418: PUSH
26419: LD_INT 1000
26421: PUSH
26422: EMPTY
26423: LIST
26424: LIST
26425: PUSH
26426: EMPTY
26427: LIST
26428: LIST
26429: PUSH
26430: EMPTY
26431: LIST
26432: LIST
26433: LIST
26434: PPUSH
26435: CALL_OW 72
26439: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
26440: LD_ADDR_EXP 51
26444: PUSH
26445: LD_EXP 51
26449: PPUSH
26450: LD_VAR 0 2
26454: PPUSH
26455: LD_VAR 0 3
26459: PPUSH
26460: CALL_OW 1
26464: ST_TO_ADDR
// end ;
26465: GO 26349
26467: POP
26468: POP
// RaiseSailEvent ( 101 ) ;
26469: LD_INT 101
26471: PPUSH
26472: CALL_OW 427
// end ;
26476: LD_VAR 0 1
26480: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
26481: LD_INT 0
26483: PPUSH
26484: PPUSH
26485: PPUSH
26486: PPUSH
26487: PPUSH
26488: PPUSH
26489: PPUSH
// if not mc_bases then
26490: LD_EXP 50
26494: NOT
26495: IFFALSE 26499
// exit ;
26497: GO 27061
// for i = 1 to mc_bases do
26499: LD_ADDR_VAR 0 2
26503: PUSH
26504: DOUBLE
26505: LD_INT 1
26507: DEC
26508: ST_TO_ADDR
26509: LD_EXP 50
26513: PUSH
26514: FOR_TO
26515: IFFALSE 27052
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
26517: LD_ADDR_VAR 0 5
26521: PUSH
26522: LD_EXP 50
26526: PUSH
26527: LD_VAR 0 2
26531: ARRAY
26532: PUSH
26533: LD_EXP 79
26537: PUSH
26538: LD_VAR 0 2
26542: ARRAY
26543: UNION
26544: PPUSH
26545: LD_INT 21
26547: PUSH
26548: LD_INT 1
26550: PUSH
26551: EMPTY
26552: LIST
26553: LIST
26554: PUSH
26555: LD_INT 1
26557: PUSH
26558: LD_INT 3
26560: PUSH
26561: LD_INT 54
26563: PUSH
26564: EMPTY
26565: LIST
26566: PUSH
26567: EMPTY
26568: LIST
26569: LIST
26570: PUSH
26571: LD_INT 3
26573: PUSH
26574: LD_INT 24
26576: PUSH
26577: LD_INT 1000
26579: PUSH
26580: EMPTY
26581: LIST
26582: LIST
26583: PUSH
26584: EMPTY
26585: LIST
26586: LIST
26587: PUSH
26588: EMPTY
26589: LIST
26590: LIST
26591: LIST
26592: PUSH
26593: EMPTY
26594: LIST
26595: LIST
26596: PPUSH
26597: CALL_OW 72
26601: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
26602: LD_ADDR_VAR 0 6
26606: PUSH
26607: LD_EXP 50
26611: PUSH
26612: LD_VAR 0 2
26616: ARRAY
26617: PPUSH
26618: LD_INT 21
26620: PUSH
26621: LD_INT 1
26623: PUSH
26624: EMPTY
26625: LIST
26626: LIST
26627: PUSH
26628: LD_INT 1
26630: PUSH
26631: LD_INT 3
26633: PUSH
26634: LD_INT 54
26636: PUSH
26637: EMPTY
26638: LIST
26639: PUSH
26640: EMPTY
26641: LIST
26642: LIST
26643: PUSH
26644: LD_INT 3
26646: PUSH
26647: LD_INT 24
26649: PUSH
26650: LD_INT 250
26652: PUSH
26653: EMPTY
26654: LIST
26655: LIST
26656: PUSH
26657: EMPTY
26658: LIST
26659: LIST
26660: PUSH
26661: EMPTY
26662: LIST
26663: LIST
26664: LIST
26665: PUSH
26666: EMPTY
26667: LIST
26668: LIST
26669: PPUSH
26670: CALL_OW 72
26674: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
26675: LD_ADDR_VAR 0 7
26679: PUSH
26680: LD_VAR 0 5
26684: PUSH
26685: LD_VAR 0 6
26689: DIFF
26690: ST_TO_ADDR
// if not need_heal_1 then
26691: LD_VAR 0 6
26695: NOT
26696: IFFALSE 26729
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
26698: LD_ADDR_EXP 53
26702: PUSH
26703: LD_EXP 53
26707: PPUSH
26708: LD_VAR 0 2
26712: PUSH
26713: LD_INT 1
26715: PUSH
26716: EMPTY
26717: LIST
26718: LIST
26719: PPUSH
26720: EMPTY
26721: PPUSH
26722: CALL 53831 0 3
26726: ST_TO_ADDR
26727: GO 26799
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
26729: LD_ADDR_EXP 53
26733: PUSH
26734: LD_EXP 53
26738: PPUSH
26739: LD_VAR 0 2
26743: PUSH
26744: LD_INT 1
26746: PUSH
26747: EMPTY
26748: LIST
26749: LIST
26750: PPUSH
26751: LD_EXP 53
26755: PUSH
26756: LD_VAR 0 2
26760: ARRAY
26761: PUSH
26762: LD_INT 1
26764: ARRAY
26765: PPUSH
26766: LD_INT 3
26768: PUSH
26769: LD_INT 24
26771: PUSH
26772: LD_INT 1000
26774: PUSH
26775: EMPTY
26776: LIST
26777: LIST
26778: PUSH
26779: EMPTY
26780: LIST
26781: LIST
26782: PPUSH
26783: CALL_OW 72
26787: PUSH
26788: LD_VAR 0 6
26792: UNION
26793: PPUSH
26794: CALL 53831 0 3
26798: ST_TO_ADDR
// if not need_heal_2 then
26799: LD_VAR 0 7
26803: NOT
26804: IFFALSE 26837
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
26806: LD_ADDR_EXP 53
26810: PUSH
26811: LD_EXP 53
26815: PPUSH
26816: LD_VAR 0 2
26820: PUSH
26821: LD_INT 2
26823: PUSH
26824: EMPTY
26825: LIST
26826: LIST
26827: PPUSH
26828: EMPTY
26829: PPUSH
26830: CALL 53831 0 3
26834: ST_TO_ADDR
26835: GO 26869
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
26837: LD_ADDR_EXP 53
26841: PUSH
26842: LD_EXP 53
26846: PPUSH
26847: LD_VAR 0 2
26851: PUSH
26852: LD_INT 2
26854: PUSH
26855: EMPTY
26856: LIST
26857: LIST
26858: PPUSH
26859: LD_VAR 0 7
26863: PPUSH
26864: CALL 53831 0 3
26868: ST_TO_ADDR
// if need_heal_2 then
26869: LD_VAR 0 7
26873: IFFALSE 27034
// for j in need_heal_2 do
26875: LD_ADDR_VAR 0 3
26879: PUSH
26880: LD_VAR 0 7
26884: PUSH
26885: FOR_IN
26886: IFFALSE 27032
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
26888: LD_ADDR_VAR 0 5
26892: PUSH
26893: LD_EXP 50
26897: PUSH
26898: LD_VAR 0 2
26902: ARRAY
26903: PPUSH
26904: LD_INT 2
26906: PUSH
26907: LD_INT 30
26909: PUSH
26910: LD_INT 6
26912: PUSH
26913: EMPTY
26914: LIST
26915: LIST
26916: PUSH
26917: LD_INT 30
26919: PUSH
26920: LD_INT 7
26922: PUSH
26923: EMPTY
26924: LIST
26925: LIST
26926: PUSH
26927: LD_INT 30
26929: PUSH
26930: LD_INT 8
26932: PUSH
26933: EMPTY
26934: LIST
26935: LIST
26936: PUSH
26937: LD_INT 30
26939: PUSH
26940: LD_INT 0
26942: PUSH
26943: EMPTY
26944: LIST
26945: LIST
26946: PUSH
26947: LD_INT 30
26949: PUSH
26950: LD_INT 1
26952: PUSH
26953: EMPTY
26954: LIST
26955: LIST
26956: PUSH
26957: EMPTY
26958: LIST
26959: LIST
26960: LIST
26961: LIST
26962: LIST
26963: LIST
26964: PPUSH
26965: CALL_OW 72
26969: ST_TO_ADDR
// if tmp then
26970: LD_VAR 0 5
26974: IFFALSE 27030
// begin k := NearestUnitToUnit ( tmp , j ) ;
26976: LD_ADDR_VAR 0 4
26980: PUSH
26981: LD_VAR 0 5
26985: PPUSH
26986: LD_VAR 0 3
26990: PPUSH
26991: CALL_OW 74
26995: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
26996: LD_VAR 0 3
27000: PPUSH
27001: LD_VAR 0 4
27005: PPUSH
27006: CALL_OW 296
27010: PUSH
27011: LD_INT 5
27013: GREATER
27014: IFFALSE 27030
// ComMoveToNearbyEntrance ( j , k ) ;
27016: LD_VAR 0 3
27020: PPUSH
27021: LD_VAR 0 4
27025: PPUSH
27026: CALL 87039 0 2
// end ; end ;
27030: GO 26885
27032: POP
27033: POP
// if not need_heal_1 and not need_heal_2 then
27034: LD_VAR 0 6
27038: NOT
27039: PUSH
27040: LD_VAR 0 7
27044: NOT
27045: AND
27046: IFFALSE 27050
// continue ;
27048: GO 26514
// end ;
27050: GO 26514
27052: POP
27053: POP
// RaiseSailEvent ( 102 ) ;
27054: LD_INT 102
27056: PPUSH
27057: CALL_OW 427
// end ;
27061: LD_VAR 0 1
27065: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
27066: LD_INT 0
27068: PPUSH
27069: PPUSH
27070: PPUSH
27071: PPUSH
27072: PPUSH
27073: PPUSH
27074: PPUSH
27075: PPUSH
// if not mc_bases then
27076: LD_EXP 50
27080: NOT
27081: IFFALSE 27085
// exit ;
27083: GO 27996
// for i = 1 to mc_bases do
27085: LD_ADDR_VAR 0 2
27089: PUSH
27090: DOUBLE
27091: LD_INT 1
27093: DEC
27094: ST_TO_ADDR
27095: LD_EXP 50
27099: PUSH
27100: FOR_TO
27101: IFFALSE 27994
// begin if not mc_building_need_repair [ i ] then
27103: LD_EXP 51
27107: PUSH
27108: LD_VAR 0 2
27112: ARRAY
27113: NOT
27114: IFFALSE 27299
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
27116: LD_ADDR_VAR 0 6
27120: PUSH
27121: LD_EXP 69
27125: PUSH
27126: LD_VAR 0 2
27130: ARRAY
27131: PPUSH
27132: LD_INT 3
27134: PUSH
27135: LD_INT 24
27137: PUSH
27138: LD_INT 1000
27140: PUSH
27141: EMPTY
27142: LIST
27143: LIST
27144: PUSH
27145: EMPTY
27146: LIST
27147: LIST
27148: PUSH
27149: LD_INT 2
27151: PUSH
27152: LD_INT 34
27154: PUSH
27155: LD_INT 13
27157: PUSH
27158: EMPTY
27159: LIST
27160: LIST
27161: PUSH
27162: LD_INT 34
27164: PUSH
27165: LD_INT 52
27167: PUSH
27168: EMPTY
27169: LIST
27170: LIST
27171: PUSH
27172: LD_INT 34
27174: PUSH
27175: LD_INT 88
27177: PUSH
27178: EMPTY
27179: LIST
27180: LIST
27181: PUSH
27182: EMPTY
27183: LIST
27184: LIST
27185: LIST
27186: LIST
27187: PUSH
27188: EMPTY
27189: LIST
27190: LIST
27191: PPUSH
27192: CALL_OW 72
27196: ST_TO_ADDR
// if cranes then
27197: LD_VAR 0 6
27201: IFFALSE 27263
// for j in cranes do
27203: LD_ADDR_VAR 0 3
27207: PUSH
27208: LD_VAR 0 6
27212: PUSH
27213: FOR_IN
27214: IFFALSE 27261
// if not IsInArea ( j , mc_parking [ i ] ) then
27216: LD_VAR 0 3
27220: PPUSH
27221: LD_EXP 74
27225: PUSH
27226: LD_VAR 0 2
27230: ARRAY
27231: PPUSH
27232: CALL_OW 308
27236: NOT
27237: IFFALSE 27259
// ComMoveToArea ( j , mc_parking [ i ] ) ;
27239: LD_VAR 0 3
27243: PPUSH
27244: LD_EXP 74
27248: PUSH
27249: LD_VAR 0 2
27253: ARRAY
27254: PPUSH
27255: CALL_OW 113
27259: GO 27213
27261: POP
27262: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
27263: LD_ADDR_EXP 52
27267: PUSH
27268: LD_EXP 52
27272: PPUSH
27273: LD_VAR 0 2
27277: PPUSH
27278: EMPTY
27279: PPUSH
27280: CALL_OW 1
27284: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
27285: LD_VAR 0 2
27289: PPUSH
27290: LD_INT 101
27292: PPUSH
27293: CALL 22153 0 2
// continue ;
27297: GO 27100
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
27299: LD_ADDR_EXP 56
27303: PUSH
27304: LD_EXP 56
27308: PPUSH
27309: LD_VAR 0 2
27313: PPUSH
27314: EMPTY
27315: PPUSH
27316: CALL_OW 1
27320: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
27321: LD_VAR 0 2
27325: PPUSH
27326: LD_INT 103
27328: PPUSH
27329: CALL 22153 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
27333: LD_ADDR_VAR 0 5
27337: PUSH
27338: LD_EXP 50
27342: PUSH
27343: LD_VAR 0 2
27347: ARRAY
27348: PUSH
27349: LD_EXP 79
27353: PUSH
27354: LD_VAR 0 2
27358: ARRAY
27359: UNION
27360: PPUSH
27361: LD_INT 2
27363: PUSH
27364: LD_INT 25
27366: PUSH
27367: LD_INT 2
27369: PUSH
27370: EMPTY
27371: LIST
27372: LIST
27373: PUSH
27374: LD_INT 25
27376: PUSH
27377: LD_INT 16
27379: PUSH
27380: EMPTY
27381: LIST
27382: LIST
27383: PUSH
27384: EMPTY
27385: LIST
27386: LIST
27387: LIST
27388: PUSH
27389: EMPTY
27390: LIST
27391: PPUSH
27392: CALL_OW 72
27396: ST_TO_ADDR
// if mc_need_heal [ i ] then
27397: LD_EXP 53
27401: PUSH
27402: LD_VAR 0 2
27406: ARRAY
27407: IFFALSE 27451
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
27409: LD_ADDR_VAR 0 5
27413: PUSH
27414: LD_VAR 0 5
27418: PUSH
27419: LD_EXP 53
27423: PUSH
27424: LD_VAR 0 2
27428: ARRAY
27429: PUSH
27430: LD_INT 1
27432: ARRAY
27433: PUSH
27434: LD_EXP 53
27438: PUSH
27439: LD_VAR 0 2
27443: ARRAY
27444: PUSH
27445: LD_INT 2
27447: ARRAY
27448: UNION
27449: DIFF
27450: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
27451: LD_ADDR_VAR 0 6
27455: PUSH
27456: LD_EXP 69
27460: PUSH
27461: LD_VAR 0 2
27465: ARRAY
27466: PPUSH
27467: LD_INT 2
27469: PUSH
27470: LD_INT 34
27472: PUSH
27473: LD_INT 13
27475: PUSH
27476: EMPTY
27477: LIST
27478: LIST
27479: PUSH
27480: LD_INT 34
27482: PUSH
27483: LD_INT 52
27485: PUSH
27486: EMPTY
27487: LIST
27488: LIST
27489: PUSH
27490: LD_INT 34
27492: PUSH
27493: LD_INT 88
27495: PUSH
27496: EMPTY
27497: LIST
27498: LIST
27499: PUSH
27500: EMPTY
27501: LIST
27502: LIST
27503: LIST
27504: LIST
27505: PPUSH
27506: CALL_OW 72
27510: ST_TO_ADDR
// if cranes then
27511: LD_VAR 0 6
27515: IFFALSE 27683
// begin for j in cranes do
27517: LD_ADDR_VAR 0 3
27521: PUSH
27522: LD_VAR 0 6
27526: PUSH
27527: FOR_IN
27528: IFFALSE 27681
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
27530: LD_VAR 0 3
27534: PPUSH
27535: CALL_OW 256
27539: PUSH
27540: LD_INT 1000
27542: EQUAL
27543: PUSH
27544: LD_VAR 0 3
27548: PPUSH
27549: CALL_OW 314
27553: NOT
27554: AND
27555: IFFALSE 27621
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
27557: LD_ADDR_VAR 0 8
27561: PUSH
27562: LD_EXP 51
27566: PUSH
27567: LD_VAR 0 2
27571: ARRAY
27572: PPUSH
27573: LD_VAR 0 3
27577: PPUSH
27578: CALL_OW 74
27582: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
27583: LD_VAR 0 8
27587: PPUSH
27588: LD_INT 16
27590: PPUSH
27591: CALL 56428 0 2
27595: PUSH
27596: LD_INT 4
27598: ARRAY
27599: PUSH
27600: LD_INT 10
27602: LESS
27603: IFFALSE 27619
// ComRepairBuilding ( j , to_repair ) ;
27605: LD_VAR 0 3
27609: PPUSH
27610: LD_VAR 0 8
27614: PPUSH
27615: CALL_OW 130
// end else
27619: GO 27679
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
27621: LD_VAR 0 3
27625: PPUSH
27626: CALL_OW 256
27630: PUSH
27631: LD_INT 500
27633: LESS
27634: PUSH
27635: LD_VAR 0 3
27639: PPUSH
27640: LD_EXP 74
27644: PUSH
27645: LD_VAR 0 2
27649: ARRAY
27650: PPUSH
27651: CALL_OW 308
27655: NOT
27656: AND
27657: IFFALSE 27679
// ComMoveToArea ( j , mc_parking [ i ] ) ;
27659: LD_VAR 0 3
27663: PPUSH
27664: LD_EXP 74
27668: PUSH
27669: LD_VAR 0 2
27673: ARRAY
27674: PPUSH
27675: CALL_OW 113
// end ;
27679: GO 27527
27681: POP
27682: POP
// end ; if tmp > 3 then
27683: LD_VAR 0 5
27687: PUSH
27688: LD_INT 3
27690: GREATER
27691: IFFALSE 27711
// tmp := ShrinkArray ( tmp , 4 ) ;
27693: LD_ADDR_VAR 0 5
27697: PUSH
27698: LD_VAR 0 5
27702: PPUSH
27703: LD_INT 4
27705: PPUSH
27706: CALL 86477 0 2
27710: ST_TO_ADDR
// if not tmp then
27711: LD_VAR 0 5
27715: NOT
27716: IFFALSE 27720
// continue ;
27718: GO 27100
// for j in tmp do
27720: LD_ADDR_VAR 0 3
27724: PUSH
27725: LD_VAR 0 5
27729: PUSH
27730: FOR_IN
27731: IFFALSE 27990
// begin if IsInUnit ( j ) then
27733: LD_VAR 0 3
27737: PPUSH
27738: CALL_OW 310
27742: IFFALSE 27753
// ComExitBuilding ( j ) ;
27744: LD_VAR 0 3
27748: PPUSH
27749: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
27753: LD_VAR 0 3
27757: PUSH
27758: LD_EXP 52
27762: PUSH
27763: LD_VAR 0 2
27767: ARRAY
27768: IN
27769: NOT
27770: IFFALSE 27828
// begin SetTag ( j , 101 ) ;
27772: LD_VAR 0 3
27776: PPUSH
27777: LD_INT 101
27779: PPUSH
27780: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
27784: LD_ADDR_EXP 52
27788: PUSH
27789: LD_EXP 52
27793: PPUSH
27794: LD_VAR 0 2
27798: PUSH
27799: LD_EXP 52
27803: PUSH
27804: LD_VAR 0 2
27808: ARRAY
27809: PUSH
27810: LD_INT 1
27812: PLUS
27813: PUSH
27814: EMPTY
27815: LIST
27816: LIST
27817: PPUSH
27818: LD_VAR 0 3
27822: PPUSH
27823: CALL 53831 0 3
27827: ST_TO_ADDR
// end ; wait ( 1 ) ;
27828: LD_INT 1
27830: PPUSH
27831: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
27835: LD_ADDR_VAR 0 7
27839: PUSH
27840: LD_EXP 51
27844: PUSH
27845: LD_VAR 0 2
27849: ARRAY
27850: ST_TO_ADDR
// if mc_scan [ i ] then
27851: LD_EXP 73
27855: PUSH
27856: LD_VAR 0 2
27860: ARRAY
27861: IFFALSE 27923
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
27863: LD_ADDR_VAR 0 7
27867: PUSH
27868: LD_EXP 51
27872: PUSH
27873: LD_VAR 0 2
27877: ARRAY
27878: PPUSH
27879: LD_INT 3
27881: PUSH
27882: LD_INT 30
27884: PUSH
27885: LD_INT 32
27887: PUSH
27888: EMPTY
27889: LIST
27890: LIST
27891: PUSH
27892: LD_INT 30
27894: PUSH
27895: LD_INT 33
27897: PUSH
27898: EMPTY
27899: LIST
27900: LIST
27901: PUSH
27902: LD_INT 30
27904: PUSH
27905: LD_INT 31
27907: PUSH
27908: EMPTY
27909: LIST
27910: LIST
27911: PUSH
27912: EMPTY
27913: LIST
27914: LIST
27915: LIST
27916: LIST
27917: PPUSH
27918: CALL_OW 72
27922: ST_TO_ADDR
// if not to_repair_tmp then
27923: LD_VAR 0 7
27927: NOT
27928: IFFALSE 27932
// continue ;
27930: GO 27730
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
27932: LD_ADDR_VAR 0 8
27936: PUSH
27937: LD_VAR 0 7
27941: PPUSH
27942: LD_VAR 0 3
27946: PPUSH
27947: CALL_OW 74
27951: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
27952: LD_VAR 0 8
27956: PPUSH
27957: LD_INT 16
27959: PPUSH
27960: CALL 56428 0 2
27964: PUSH
27965: LD_INT 4
27967: ARRAY
27968: PUSH
27969: LD_INT 14
27971: LESS
27972: IFFALSE 27988
// ComRepairBuilding ( j , to_repair ) ;
27974: LD_VAR 0 3
27978: PPUSH
27979: LD_VAR 0 8
27983: PPUSH
27984: CALL_OW 130
// end ;
27988: GO 27730
27990: POP
27991: POP
// end ;
27992: GO 27100
27994: POP
27995: POP
// end ;
27996: LD_VAR 0 1
28000: RET
// export function MC_Heal ; var i , j , tmp ; begin
28001: LD_INT 0
28003: PPUSH
28004: PPUSH
28005: PPUSH
28006: PPUSH
// if not mc_bases then
28007: LD_EXP 50
28011: NOT
28012: IFFALSE 28016
// exit ;
28014: GO 28418
// for i = 1 to mc_bases do
28016: LD_ADDR_VAR 0 2
28020: PUSH
28021: DOUBLE
28022: LD_INT 1
28024: DEC
28025: ST_TO_ADDR
28026: LD_EXP 50
28030: PUSH
28031: FOR_TO
28032: IFFALSE 28416
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
28034: LD_EXP 53
28038: PUSH
28039: LD_VAR 0 2
28043: ARRAY
28044: PUSH
28045: LD_INT 1
28047: ARRAY
28048: NOT
28049: PUSH
28050: LD_EXP 53
28054: PUSH
28055: LD_VAR 0 2
28059: ARRAY
28060: PUSH
28061: LD_INT 2
28063: ARRAY
28064: NOT
28065: AND
28066: IFFALSE 28104
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
28068: LD_ADDR_EXP 54
28072: PUSH
28073: LD_EXP 54
28077: PPUSH
28078: LD_VAR 0 2
28082: PPUSH
28083: EMPTY
28084: PPUSH
28085: CALL_OW 1
28089: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
28090: LD_VAR 0 2
28094: PPUSH
28095: LD_INT 102
28097: PPUSH
28098: CALL 22153 0 2
// continue ;
28102: GO 28031
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
28104: LD_ADDR_VAR 0 4
28108: PUSH
28109: LD_EXP 50
28113: PUSH
28114: LD_VAR 0 2
28118: ARRAY
28119: PPUSH
28120: LD_INT 25
28122: PUSH
28123: LD_INT 4
28125: PUSH
28126: EMPTY
28127: LIST
28128: LIST
28129: PPUSH
28130: CALL_OW 72
28134: ST_TO_ADDR
// if not tmp then
28135: LD_VAR 0 4
28139: NOT
28140: IFFALSE 28144
// continue ;
28142: GO 28031
// if mc_taming [ i ] then
28144: LD_EXP 81
28148: PUSH
28149: LD_VAR 0 2
28153: ARRAY
28154: IFFALSE 28178
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
28156: LD_ADDR_EXP 81
28160: PUSH
28161: LD_EXP 81
28165: PPUSH
28166: LD_VAR 0 2
28170: PPUSH
28171: EMPTY
28172: PPUSH
28173: CALL_OW 1
28177: ST_TO_ADDR
// for j in tmp do
28178: LD_ADDR_VAR 0 3
28182: PUSH
28183: LD_VAR 0 4
28187: PUSH
28188: FOR_IN
28189: IFFALSE 28412
// begin if IsInUnit ( j ) then
28191: LD_VAR 0 3
28195: PPUSH
28196: CALL_OW 310
28200: IFFALSE 28211
// ComExitBuilding ( j ) ;
28202: LD_VAR 0 3
28206: PPUSH
28207: CALL_OW 122
// if not j in mc_healers [ i ] then
28211: LD_VAR 0 3
28215: PUSH
28216: LD_EXP 54
28220: PUSH
28221: LD_VAR 0 2
28225: ARRAY
28226: IN
28227: NOT
28228: IFFALSE 28274
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
28230: LD_ADDR_EXP 54
28234: PUSH
28235: LD_EXP 54
28239: PPUSH
28240: LD_VAR 0 2
28244: PUSH
28245: LD_EXP 54
28249: PUSH
28250: LD_VAR 0 2
28254: ARRAY
28255: PUSH
28256: LD_INT 1
28258: PLUS
28259: PUSH
28260: EMPTY
28261: LIST
28262: LIST
28263: PPUSH
28264: LD_VAR 0 3
28268: PPUSH
28269: CALL 53831 0 3
28273: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
28274: LD_VAR 0 3
28278: PPUSH
28279: CALL_OW 110
28283: PUSH
28284: LD_INT 102
28286: NONEQUAL
28287: IFFALSE 28301
// SetTag ( j , 102 ) ;
28289: LD_VAR 0 3
28293: PPUSH
28294: LD_INT 102
28296: PPUSH
28297: CALL_OW 109
// Wait ( 3 ) ;
28301: LD_INT 3
28303: PPUSH
28304: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
28308: LD_EXP 53
28312: PUSH
28313: LD_VAR 0 2
28317: ARRAY
28318: PUSH
28319: LD_INT 1
28321: ARRAY
28322: IFFALSE 28354
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
28324: LD_VAR 0 3
28328: PPUSH
28329: LD_EXP 53
28333: PUSH
28334: LD_VAR 0 2
28338: ARRAY
28339: PUSH
28340: LD_INT 1
28342: ARRAY
28343: PUSH
28344: LD_INT 1
28346: ARRAY
28347: PPUSH
28348: CALL_OW 128
28352: GO 28410
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
28354: LD_VAR 0 3
28358: PPUSH
28359: CALL_OW 314
28363: NOT
28364: PUSH
28365: LD_EXP 53
28369: PUSH
28370: LD_VAR 0 2
28374: ARRAY
28375: PUSH
28376: LD_INT 2
28378: ARRAY
28379: AND
28380: IFFALSE 28410
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
28382: LD_VAR 0 3
28386: PPUSH
28387: LD_EXP 53
28391: PUSH
28392: LD_VAR 0 2
28396: ARRAY
28397: PUSH
28398: LD_INT 2
28400: ARRAY
28401: PUSH
28402: LD_INT 1
28404: ARRAY
28405: PPUSH
28406: CALL_OW 128
// end ;
28410: GO 28188
28412: POP
28413: POP
// end ;
28414: GO 28031
28416: POP
28417: POP
// end ;
28418: LD_VAR 0 1
28422: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
28423: LD_INT 0
28425: PPUSH
28426: PPUSH
28427: PPUSH
28428: PPUSH
28429: PPUSH
28430: PPUSH
// if not mc_bases then
28431: LD_EXP 50
28435: NOT
28436: IFFALSE 28440
// exit ;
28438: GO 29603
// for i = 1 to mc_bases do
28440: LD_ADDR_VAR 0 2
28444: PUSH
28445: DOUBLE
28446: LD_INT 1
28448: DEC
28449: ST_TO_ADDR
28450: LD_EXP 50
28454: PUSH
28455: FOR_TO
28456: IFFALSE 29601
// begin if mc_scan [ i ] then
28458: LD_EXP 73
28462: PUSH
28463: LD_VAR 0 2
28467: ARRAY
28468: IFFALSE 28472
// continue ;
28470: GO 28455
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
28472: LD_EXP 55
28476: PUSH
28477: LD_VAR 0 2
28481: ARRAY
28482: NOT
28483: PUSH
28484: LD_EXP 57
28488: PUSH
28489: LD_VAR 0 2
28493: ARRAY
28494: NOT
28495: AND
28496: PUSH
28497: LD_EXP 56
28501: PUSH
28502: LD_VAR 0 2
28506: ARRAY
28507: AND
28508: IFFALSE 28546
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
28510: LD_ADDR_EXP 56
28514: PUSH
28515: LD_EXP 56
28519: PPUSH
28520: LD_VAR 0 2
28524: PPUSH
28525: EMPTY
28526: PPUSH
28527: CALL_OW 1
28531: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
28532: LD_VAR 0 2
28536: PPUSH
28537: LD_INT 103
28539: PPUSH
28540: CALL 22153 0 2
// continue ;
28544: GO 28455
// end ; if mc_construct_list [ i ] then
28546: LD_EXP 57
28550: PUSH
28551: LD_VAR 0 2
28555: ARRAY
28556: IFFALSE 28776
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
28558: LD_ADDR_VAR 0 5
28562: PUSH
28563: LD_EXP 50
28567: PUSH
28568: LD_VAR 0 2
28572: ARRAY
28573: PPUSH
28574: LD_INT 25
28576: PUSH
28577: LD_INT 2
28579: PUSH
28580: EMPTY
28581: LIST
28582: LIST
28583: PPUSH
28584: CALL_OW 72
28588: PUSH
28589: LD_EXP 52
28593: PUSH
28594: LD_VAR 0 2
28598: ARRAY
28599: DIFF
28600: ST_TO_ADDR
// if not tmp then
28601: LD_VAR 0 5
28605: NOT
28606: IFFALSE 28610
// continue ;
28608: GO 28455
// for j in tmp do
28610: LD_ADDR_VAR 0 3
28614: PUSH
28615: LD_VAR 0 5
28619: PUSH
28620: FOR_IN
28621: IFFALSE 28772
// begin if not mc_builders [ i ] then
28623: LD_EXP 56
28627: PUSH
28628: LD_VAR 0 2
28632: ARRAY
28633: NOT
28634: IFFALSE 28692
// begin SetTag ( j , 103 ) ;
28636: LD_VAR 0 3
28640: PPUSH
28641: LD_INT 103
28643: PPUSH
28644: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
28648: LD_ADDR_EXP 56
28652: PUSH
28653: LD_EXP 56
28657: PPUSH
28658: LD_VAR 0 2
28662: PUSH
28663: LD_EXP 56
28667: PUSH
28668: LD_VAR 0 2
28672: ARRAY
28673: PUSH
28674: LD_INT 1
28676: PLUS
28677: PUSH
28678: EMPTY
28679: LIST
28680: LIST
28681: PPUSH
28682: LD_VAR 0 3
28686: PPUSH
28687: CALL 53831 0 3
28691: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
28692: LD_VAR 0 3
28696: PPUSH
28697: CALL_OW 310
28701: IFFALSE 28712
// ComExitBuilding ( j ) ;
28703: LD_VAR 0 3
28707: PPUSH
28708: CALL_OW 122
// wait ( 3 ) ;
28712: LD_INT 3
28714: PPUSH
28715: CALL_OW 67
// if not mc_construct_list [ i ] then
28719: LD_EXP 57
28723: PUSH
28724: LD_VAR 0 2
28728: ARRAY
28729: NOT
28730: IFFALSE 28734
// break ;
28732: GO 28772
// if not HasTask ( j ) then
28734: LD_VAR 0 3
28738: PPUSH
28739: CALL_OW 314
28743: NOT
28744: IFFALSE 28770
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
28746: LD_VAR 0 3
28750: PPUSH
28751: LD_EXP 57
28755: PUSH
28756: LD_VAR 0 2
28760: ARRAY
28761: PUSH
28762: LD_INT 1
28764: ARRAY
28765: PPUSH
28766: CALL 56692 0 2
// end ;
28770: GO 28620
28772: POP
28773: POP
// end else
28774: GO 29599
// if mc_build_list [ i ] then
28776: LD_EXP 55
28780: PUSH
28781: LD_VAR 0 2
28785: ARRAY
28786: IFFALSE 29599
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
28788: LD_EXP 55
28792: PUSH
28793: LD_VAR 0 2
28797: ARRAY
28798: PUSH
28799: LD_INT 1
28801: ARRAY
28802: PUSH
28803: LD_INT 1
28805: ARRAY
28806: PPUSH
28807: CALL 56516 0 1
28811: PUSH
28812: LD_EXP 50
28816: PUSH
28817: LD_VAR 0 2
28821: ARRAY
28822: PPUSH
28823: LD_INT 2
28825: PUSH
28826: LD_INT 30
28828: PUSH
28829: LD_INT 2
28831: PUSH
28832: EMPTY
28833: LIST
28834: LIST
28835: PUSH
28836: LD_INT 30
28838: PUSH
28839: LD_INT 3
28841: PUSH
28842: EMPTY
28843: LIST
28844: LIST
28845: PUSH
28846: EMPTY
28847: LIST
28848: LIST
28849: LIST
28850: PPUSH
28851: CALL_OW 72
28855: NOT
28856: AND
28857: IFFALSE 28962
// begin for j = 1 to mc_build_list [ i ] do
28859: LD_ADDR_VAR 0 3
28863: PUSH
28864: DOUBLE
28865: LD_INT 1
28867: DEC
28868: ST_TO_ADDR
28869: LD_EXP 55
28873: PUSH
28874: LD_VAR 0 2
28878: ARRAY
28879: PUSH
28880: FOR_TO
28881: IFFALSE 28960
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
28883: LD_EXP 55
28887: PUSH
28888: LD_VAR 0 2
28892: ARRAY
28893: PUSH
28894: LD_VAR 0 3
28898: ARRAY
28899: PUSH
28900: LD_INT 1
28902: ARRAY
28903: PUSH
28904: LD_INT 2
28906: EQUAL
28907: IFFALSE 28958
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
28909: LD_ADDR_EXP 55
28913: PUSH
28914: LD_EXP 55
28918: PPUSH
28919: LD_VAR 0 2
28923: PPUSH
28924: LD_EXP 55
28928: PUSH
28929: LD_VAR 0 2
28933: ARRAY
28934: PPUSH
28935: LD_VAR 0 3
28939: PPUSH
28940: LD_INT 1
28942: PPUSH
28943: LD_INT 0
28945: PPUSH
28946: CALL 53249 0 4
28950: PPUSH
28951: CALL_OW 1
28955: ST_TO_ADDR
// break ;
28956: GO 28960
// end ;
28958: GO 28880
28960: POP
28961: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
28962: LD_ADDR_VAR 0 6
28966: PUSH
28967: LD_EXP 50
28971: PUSH
28972: LD_VAR 0 2
28976: ARRAY
28977: PPUSH
28978: LD_INT 2
28980: PUSH
28981: LD_INT 30
28983: PUSH
28984: LD_INT 0
28986: PUSH
28987: EMPTY
28988: LIST
28989: LIST
28990: PUSH
28991: LD_INT 30
28993: PUSH
28994: LD_INT 1
28996: PUSH
28997: EMPTY
28998: LIST
28999: LIST
29000: PUSH
29001: EMPTY
29002: LIST
29003: LIST
29004: LIST
29005: PPUSH
29006: CALL_OW 72
29010: ST_TO_ADDR
// for k := 1 to depot do
29011: LD_ADDR_VAR 0 4
29015: PUSH
29016: DOUBLE
29017: LD_INT 1
29019: DEC
29020: ST_TO_ADDR
29021: LD_VAR 0 6
29025: PUSH
29026: FOR_TO
29027: IFFALSE 29597
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
29029: LD_EXP 55
29033: PUSH
29034: LD_VAR 0 2
29038: ARRAY
29039: PUSH
29040: LD_INT 1
29042: ARRAY
29043: PUSH
29044: LD_INT 1
29046: ARRAY
29047: PUSH
29048: LD_INT 0
29050: EQUAL
29051: PUSH
29052: LD_VAR 0 6
29056: PUSH
29057: LD_VAR 0 4
29061: ARRAY
29062: PPUSH
29063: LD_EXP 55
29067: PUSH
29068: LD_VAR 0 2
29072: ARRAY
29073: PUSH
29074: LD_INT 1
29076: ARRAY
29077: PUSH
29078: LD_INT 1
29080: ARRAY
29081: PPUSH
29082: LD_EXP 55
29086: PUSH
29087: LD_VAR 0 2
29091: ARRAY
29092: PUSH
29093: LD_INT 1
29095: ARRAY
29096: PUSH
29097: LD_INT 2
29099: ARRAY
29100: PPUSH
29101: LD_EXP 55
29105: PUSH
29106: LD_VAR 0 2
29110: ARRAY
29111: PUSH
29112: LD_INT 1
29114: ARRAY
29115: PUSH
29116: LD_INT 3
29118: ARRAY
29119: PPUSH
29120: LD_EXP 55
29124: PUSH
29125: LD_VAR 0 2
29129: ARRAY
29130: PUSH
29131: LD_INT 1
29133: ARRAY
29134: PUSH
29135: LD_INT 4
29137: ARRAY
29138: PPUSH
29139: CALL 61928 0 5
29143: OR
29144: IFFALSE 29425
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
29146: LD_ADDR_VAR 0 5
29150: PUSH
29151: LD_EXP 50
29155: PUSH
29156: LD_VAR 0 2
29160: ARRAY
29161: PPUSH
29162: LD_INT 25
29164: PUSH
29165: LD_INT 2
29167: PUSH
29168: EMPTY
29169: LIST
29170: LIST
29171: PPUSH
29172: CALL_OW 72
29176: PUSH
29177: LD_EXP 52
29181: PUSH
29182: LD_VAR 0 2
29186: ARRAY
29187: DIFF
29188: ST_TO_ADDR
// if not tmp then
29189: LD_VAR 0 5
29193: NOT
29194: IFFALSE 29198
// continue ;
29196: GO 29026
// for j in tmp do
29198: LD_ADDR_VAR 0 3
29202: PUSH
29203: LD_VAR 0 5
29207: PUSH
29208: FOR_IN
29209: IFFALSE 29421
// begin if not mc_builders [ i ] then
29211: LD_EXP 56
29215: PUSH
29216: LD_VAR 0 2
29220: ARRAY
29221: NOT
29222: IFFALSE 29280
// begin SetTag ( j , 103 ) ;
29224: LD_VAR 0 3
29228: PPUSH
29229: LD_INT 103
29231: PPUSH
29232: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
29236: LD_ADDR_EXP 56
29240: PUSH
29241: LD_EXP 56
29245: PPUSH
29246: LD_VAR 0 2
29250: PUSH
29251: LD_EXP 56
29255: PUSH
29256: LD_VAR 0 2
29260: ARRAY
29261: PUSH
29262: LD_INT 1
29264: PLUS
29265: PUSH
29266: EMPTY
29267: LIST
29268: LIST
29269: PPUSH
29270: LD_VAR 0 3
29274: PPUSH
29275: CALL 53831 0 3
29279: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
29280: LD_VAR 0 3
29284: PPUSH
29285: CALL_OW 310
29289: IFFALSE 29300
// ComExitBuilding ( j ) ;
29291: LD_VAR 0 3
29295: PPUSH
29296: CALL_OW 122
// wait ( 3 ) ;
29300: LD_INT 3
29302: PPUSH
29303: CALL_OW 67
// if not mc_build_list [ i ] then
29307: LD_EXP 55
29311: PUSH
29312: LD_VAR 0 2
29316: ARRAY
29317: NOT
29318: IFFALSE 29322
// break ;
29320: GO 29421
// if not HasTask ( j ) then
29322: LD_VAR 0 3
29326: PPUSH
29327: CALL_OW 314
29331: NOT
29332: IFFALSE 29419
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
29334: LD_VAR 0 3
29338: PPUSH
29339: LD_EXP 55
29343: PUSH
29344: LD_VAR 0 2
29348: ARRAY
29349: PUSH
29350: LD_INT 1
29352: ARRAY
29353: PUSH
29354: LD_INT 1
29356: ARRAY
29357: PPUSH
29358: LD_EXP 55
29362: PUSH
29363: LD_VAR 0 2
29367: ARRAY
29368: PUSH
29369: LD_INT 1
29371: ARRAY
29372: PUSH
29373: LD_INT 2
29375: ARRAY
29376: PPUSH
29377: LD_EXP 55
29381: PUSH
29382: LD_VAR 0 2
29386: ARRAY
29387: PUSH
29388: LD_INT 1
29390: ARRAY
29391: PUSH
29392: LD_INT 3
29394: ARRAY
29395: PPUSH
29396: LD_EXP 55
29400: PUSH
29401: LD_VAR 0 2
29405: ARRAY
29406: PUSH
29407: LD_INT 1
29409: ARRAY
29410: PUSH
29411: LD_INT 4
29413: ARRAY
29414: PPUSH
29415: CALL_OW 145
// end ;
29419: GO 29208
29421: POP
29422: POP
// end else
29423: GO 29595
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
29425: LD_EXP 50
29429: PUSH
29430: LD_VAR 0 2
29434: ARRAY
29435: PPUSH
29436: LD_EXP 55
29440: PUSH
29441: LD_VAR 0 2
29445: ARRAY
29446: PUSH
29447: LD_INT 1
29449: ARRAY
29450: PUSH
29451: LD_INT 1
29453: ARRAY
29454: PPUSH
29455: LD_EXP 55
29459: PUSH
29460: LD_VAR 0 2
29464: ARRAY
29465: PUSH
29466: LD_INT 1
29468: ARRAY
29469: PUSH
29470: LD_INT 2
29472: ARRAY
29473: PPUSH
29474: LD_EXP 55
29478: PUSH
29479: LD_VAR 0 2
29483: ARRAY
29484: PUSH
29485: LD_INT 1
29487: ARRAY
29488: PUSH
29489: LD_INT 3
29491: ARRAY
29492: PPUSH
29493: LD_EXP 55
29497: PUSH
29498: LD_VAR 0 2
29502: ARRAY
29503: PUSH
29504: LD_INT 1
29506: ARRAY
29507: PUSH
29508: LD_INT 4
29510: ARRAY
29511: PPUSH
29512: LD_EXP 50
29516: PUSH
29517: LD_VAR 0 2
29521: ARRAY
29522: PPUSH
29523: LD_INT 21
29525: PUSH
29526: LD_INT 3
29528: PUSH
29529: EMPTY
29530: LIST
29531: LIST
29532: PPUSH
29533: CALL_OW 72
29537: PPUSH
29538: EMPTY
29539: PPUSH
29540: CALL 60682 0 7
29544: NOT
29545: IFFALSE 29595
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
29547: LD_ADDR_EXP 55
29551: PUSH
29552: LD_EXP 55
29556: PPUSH
29557: LD_VAR 0 2
29561: PPUSH
29562: LD_EXP 55
29566: PUSH
29567: LD_VAR 0 2
29571: ARRAY
29572: PPUSH
29573: LD_INT 1
29575: PPUSH
29576: LD_INT 1
29578: NEG
29579: PPUSH
29580: LD_INT 0
29582: PPUSH
29583: CALL 53249 0 4
29587: PPUSH
29588: CALL_OW 1
29592: ST_TO_ADDR
// continue ;
29593: GO 29026
// end ; end ;
29595: GO 29026
29597: POP
29598: POP
// end ; end ;
29599: GO 28455
29601: POP
29602: POP
// end ;
29603: LD_VAR 0 1
29607: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
29608: LD_INT 0
29610: PPUSH
29611: PPUSH
29612: PPUSH
29613: PPUSH
29614: PPUSH
29615: PPUSH
// if not mc_bases then
29616: LD_EXP 50
29620: NOT
29621: IFFALSE 29625
// exit ;
29623: GO 30052
// for i = 1 to mc_bases do
29625: LD_ADDR_VAR 0 2
29629: PUSH
29630: DOUBLE
29631: LD_INT 1
29633: DEC
29634: ST_TO_ADDR
29635: LD_EXP 50
29639: PUSH
29640: FOR_TO
29641: IFFALSE 30050
// begin tmp := mc_build_upgrade [ i ] ;
29643: LD_ADDR_VAR 0 4
29647: PUSH
29648: LD_EXP 82
29652: PUSH
29653: LD_VAR 0 2
29657: ARRAY
29658: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
29659: LD_ADDR_VAR 0 6
29663: PUSH
29664: LD_EXP 83
29668: PUSH
29669: LD_VAR 0 2
29673: ARRAY
29674: PPUSH
29675: LD_INT 2
29677: PUSH
29678: LD_INT 30
29680: PUSH
29681: LD_INT 6
29683: PUSH
29684: EMPTY
29685: LIST
29686: LIST
29687: PUSH
29688: LD_INT 30
29690: PUSH
29691: LD_INT 7
29693: PUSH
29694: EMPTY
29695: LIST
29696: LIST
29697: PUSH
29698: EMPTY
29699: LIST
29700: LIST
29701: LIST
29702: PPUSH
29703: CALL_OW 72
29707: ST_TO_ADDR
// if not tmp and not lab then
29708: LD_VAR 0 4
29712: NOT
29713: PUSH
29714: LD_VAR 0 6
29718: NOT
29719: AND
29720: IFFALSE 29724
// continue ;
29722: GO 29640
// if tmp then
29724: LD_VAR 0 4
29728: IFFALSE 29848
// for j in tmp do
29730: LD_ADDR_VAR 0 3
29734: PUSH
29735: LD_VAR 0 4
29739: PUSH
29740: FOR_IN
29741: IFFALSE 29846
// begin if UpgradeCost ( j ) then
29743: LD_VAR 0 3
29747: PPUSH
29748: CALL 60342 0 1
29752: IFFALSE 29844
// begin ComUpgrade ( j ) ;
29754: LD_VAR 0 3
29758: PPUSH
29759: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
29763: LD_ADDR_EXP 82
29767: PUSH
29768: LD_EXP 82
29772: PPUSH
29773: LD_VAR 0 2
29777: PPUSH
29778: LD_EXP 82
29782: PUSH
29783: LD_VAR 0 2
29787: ARRAY
29788: PUSH
29789: LD_VAR 0 3
29793: DIFF
29794: PPUSH
29795: CALL_OW 1
29799: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
29800: LD_ADDR_EXP 57
29804: PUSH
29805: LD_EXP 57
29809: PPUSH
29810: LD_VAR 0 2
29814: PUSH
29815: LD_EXP 57
29819: PUSH
29820: LD_VAR 0 2
29824: ARRAY
29825: PUSH
29826: LD_INT 1
29828: PLUS
29829: PUSH
29830: EMPTY
29831: LIST
29832: LIST
29833: PPUSH
29834: LD_VAR 0 3
29838: PPUSH
29839: CALL 53831 0 3
29843: ST_TO_ADDR
// end ; end ;
29844: GO 29740
29846: POP
29847: POP
// if not lab or not mc_lab_upgrade [ i ] then
29848: LD_VAR 0 6
29852: NOT
29853: PUSH
29854: LD_EXP 84
29858: PUSH
29859: LD_VAR 0 2
29863: ARRAY
29864: NOT
29865: OR
29866: IFFALSE 29870
// continue ;
29868: GO 29640
// for j in lab do
29870: LD_ADDR_VAR 0 3
29874: PUSH
29875: LD_VAR 0 6
29879: PUSH
29880: FOR_IN
29881: IFFALSE 30046
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
29883: LD_VAR 0 3
29887: PPUSH
29888: CALL_OW 266
29892: PUSH
29893: LD_INT 6
29895: PUSH
29896: LD_INT 7
29898: PUSH
29899: EMPTY
29900: LIST
29901: LIST
29902: IN
29903: PUSH
29904: LD_VAR 0 3
29908: PPUSH
29909: CALL_OW 461
29913: PUSH
29914: LD_INT 1
29916: NONEQUAL
29917: AND
29918: IFFALSE 30044
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
29920: LD_VAR 0 3
29924: PPUSH
29925: LD_EXP 84
29929: PUSH
29930: LD_VAR 0 2
29934: ARRAY
29935: PUSH
29936: LD_INT 1
29938: ARRAY
29939: PPUSH
29940: CALL 60547 0 2
29944: IFFALSE 30044
// begin ComCancel ( j ) ;
29946: LD_VAR 0 3
29950: PPUSH
29951: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
29955: LD_VAR 0 3
29959: PPUSH
29960: LD_EXP 84
29964: PUSH
29965: LD_VAR 0 2
29969: ARRAY
29970: PUSH
29971: LD_INT 1
29973: ARRAY
29974: PPUSH
29975: CALL_OW 207
// if not j in mc_construct_list [ i ] then
29979: LD_VAR 0 3
29983: PUSH
29984: LD_EXP 57
29988: PUSH
29989: LD_VAR 0 2
29993: ARRAY
29994: IN
29995: NOT
29996: IFFALSE 30042
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
29998: LD_ADDR_EXP 57
30002: PUSH
30003: LD_EXP 57
30007: PPUSH
30008: LD_VAR 0 2
30012: PUSH
30013: LD_EXP 57
30017: PUSH
30018: LD_VAR 0 2
30022: ARRAY
30023: PUSH
30024: LD_INT 1
30026: PLUS
30027: PUSH
30028: EMPTY
30029: LIST
30030: LIST
30031: PPUSH
30032: LD_VAR 0 3
30036: PPUSH
30037: CALL 53831 0 3
30041: ST_TO_ADDR
// break ;
30042: GO 30046
// end ; end ; end ;
30044: GO 29880
30046: POP
30047: POP
// end ;
30048: GO 29640
30050: POP
30051: POP
// end ;
30052: LD_VAR 0 1
30056: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
30057: LD_INT 0
30059: PPUSH
30060: PPUSH
30061: PPUSH
30062: PPUSH
30063: PPUSH
30064: PPUSH
30065: PPUSH
30066: PPUSH
30067: PPUSH
// if not mc_bases then
30068: LD_EXP 50
30072: NOT
30073: IFFALSE 30077
// exit ;
30075: GO 30482
// for i = 1 to mc_bases do
30077: LD_ADDR_VAR 0 2
30081: PUSH
30082: DOUBLE
30083: LD_INT 1
30085: DEC
30086: ST_TO_ADDR
30087: LD_EXP 50
30091: PUSH
30092: FOR_TO
30093: IFFALSE 30480
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
30095: LD_EXP 58
30099: PUSH
30100: LD_VAR 0 2
30104: ARRAY
30105: NOT
30106: PUSH
30107: LD_EXP 50
30111: PUSH
30112: LD_VAR 0 2
30116: ARRAY
30117: PPUSH
30118: LD_INT 30
30120: PUSH
30121: LD_INT 3
30123: PUSH
30124: EMPTY
30125: LIST
30126: LIST
30127: PPUSH
30128: CALL_OW 72
30132: NOT
30133: OR
30134: IFFALSE 30138
// continue ;
30136: GO 30092
// busy := false ;
30138: LD_ADDR_VAR 0 8
30142: PUSH
30143: LD_INT 0
30145: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
30146: LD_ADDR_VAR 0 4
30150: PUSH
30151: LD_EXP 50
30155: PUSH
30156: LD_VAR 0 2
30160: ARRAY
30161: PPUSH
30162: LD_INT 30
30164: PUSH
30165: LD_INT 3
30167: PUSH
30168: EMPTY
30169: LIST
30170: LIST
30171: PPUSH
30172: CALL_OW 72
30176: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
30177: LD_ADDR_VAR 0 6
30181: PUSH
30182: LD_EXP 58
30186: PUSH
30187: LD_VAR 0 2
30191: ARRAY
30192: PPUSH
30193: LD_INT 2
30195: PUSH
30196: LD_INT 30
30198: PUSH
30199: LD_INT 32
30201: PUSH
30202: EMPTY
30203: LIST
30204: LIST
30205: PUSH
30206: LD_INT 30
30208: PUSH
30209: LD_INT 33
30211: PUSH
30212: EMPTY
30213: LIST
30214: LIST
30215: PUSH
30216: EMPTY
30217: LIST
30218: LIST
30219: LIST
30220: PPUSH
30221: CALL_OW 72
30225: ST_TO_ADDR
// if not t then
30226: LD_VAR 0 6
30230: NOT
30231: IFFALSE 30235
// continue ;
30233: GO 30092
// for j in tmp do
30235: LD_ADDR_VAR 0 3
30239: PUSH
30240: LD_VAR 0 4
30244: PUSH
30245: FOR_IN
30246: IFFALSE 30276
// if not BuildingStatus ( j ) = bs_idle then
30248: LD_VAR 0 3
30252: PPUSH
30253: CALL_OW 461
30257: PUSH
30258: LD_INT 2
30260: EQUAL
30261: NOT
30262: IFFALSE 30274
// begin busy := true ;
30264: LD_ADDR_VAR 0 8
30268: PUSH
30269: LD_INT 1
30271: ST_TO_ADDR
// break ;
30272: GO 30276
// end ;
30274: GO 30245
30276: POP
30277: POP
// if busy then
30278: LD_VAR 0 8
30282: IFFALSE 30286
// continue ;
30284: GO 30092
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
30286: LD_ADDR_VAR 0 7
30290: PUSH
30291: LD_VAR 0 6
30295: PPUSH
30296: LD_INT 35
30298: PUSH
30299: LD_INT 0
30301: PUSH
30302: EMPTY
30303: LIST
30304: LIST
30305: PPUSH
30306: CALL_OW 72
30310: ST_TO_ADDR
// if tw then
30311: LD_VAR 0 7
30315: IFFALSE 30392
// begin tw := tw [ 1 ] ;
30317: LD_ADDR_VAR 0 7
30321: PUSH
30322: LD_VAR 0 7
30326: PUSH
30327: LD_INT 1
30329: ARRAY
30330: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
30331: LD_ADDR_VAR 0 9
30335: PUSH
30336: LD_VAR 0 7
30340: PPUSH
30341: LD_EXP 75
30345: PUSH
30346: LD_VAR 0 2
30350: ARRAY
30351: PPUSH
30352: CALL 58839 0 2
30356: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
30357: LD_EXP 89
30361: PUSH
30362: LD_VAR 0 2
30366: ARRAY
30367: IFFALSE 30390
// if not weapon in mc_allowed_tower_weapons [ i ] then
30369: LD_VAR 0 9
30373: PUSH
30374: LD_EXP 89
30378: PUSH
30379: LD_VAR 0 2
30383: ARRAY
30384: IN
30385: NOT
30386: IFFALSE 30390
// continue ;
30388: GO 30092
// end else
30390: GO 30455
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
30392: LD_ADDR_VAR 0 5
30396: PUSH
30397: LD_EXP 58
30401: PUSH
30402: LD_VAR 0 2
30406: ARRAY
30407: PPUSH
30408: LD_VAR 0 4
30412: PPUSH
30413: CALL 85710 0 2
30417: ST_TO_ADDR
// if not tmp2 then
30418: LD_VAR 0 5
30422: NOT
30423: IFFALSE 30427
// continue ;
30425: GO 30092
// tw := tmp2 [ 1 ] ;
30427: LD_ADDR_VAR 0 7
30431: PUSH
30432: LD_VAR 0 5
30436: PUSH
30437: LD_INT 1
30439: ARRAY
30440: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
30441: LD_ADDR_VAR 0 9
30445: PUSH
30446: LD_VAR 0 5
30450: PUSH
30451: LD_INT 2
30453: ARRAY
30454: ST_TO_ADDR
// end ; if not weapon then
30455: LD_VAR 0 9
30459: NOT
30460: IFFALSE 30464
// continue ;
30462: GO 30092
// ComPlaceWeapon ( tw , weapon ) ;
30464: LD_VAR 0 7
30468: PPUSH
30469: LD_VAR 0 9
30473: PPUSH
30474: CALL_OW 148
// end ;
30478: GO 30092
30480: POP
30481: POP
// end ;
30482: LD_VAR 0 1
30486: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
30487: LD_INT 0
30489: PPUSH
30490: PPUSH
30491: PPUSH
30492: PPUSH
30493: PPUSH
30494: PPUSH
30495: PPUSH
// if not mc_bases then
30496: LD_EXP 50
30500: NOT
30501: IFFALSE 30505
// exit ;
30503: GO 31273
// for i = 1 to mc_bases do
30505: LD_ADDR_VAR 0 2
30509: PUSH
30510: DOUBLE
30511: LD_INT 1
30513: DEC
30514: ST_TO_ADDR
30515: LD_EXP 50
30519: PUSH
30520: FOR_TO
30521: IFFALSE 31271
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
30523: LD_EXP 63
30527: PUSH
30528: LD_VAR 0 2
30532: ARRAY
30533: NOT
30534: PUSH
30535: LD_EXP 63
30539: PUSH
30540: LD_VAR 0 2
30544: ARRAY
30545: PUSH
30546: LD_EXP 64
30550: PUSH
30551: LD_VAR 0 2
30555: ARRAY
30556: EQUAL
30557: OR
30558: PUSH
30559: LD_EXP 73
30563: PUSH
30564: LD_VAR 0 2
30568: ARRAY
30569: OR
30570: IFFALSE 30574
// continue ;
30572: GO 30520
// if mc_miners [ i ] then
30574: LD_EXP 64
30578: PUSH
30579: LD_VAR 0 2
30583: ARRAY
30584: IFFALSE 30958
// begin for j = mc_miners [ i ] downto 1 do
30586: LD_ADDR_VAR 0 3
30590: PUSH
30591: DOUBLE
30592: LD_EXP 64
30596: PUSH
30597: LD_VAR 0 2
30601: ARRAY
30602: INC
30603: ST_TO_ADDR
30604: LD_INT 1
30606: PUSH
30607: FOR_DOWNTO
30608: IFFALSE 30956
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
30610: LD_EXP 64
30614: PUSH
30615: LD_VAR 0 2
30619: ARRAY
30620: PUSH
30621: LD_VAR 0 3
30625: ARRAY
30626: PPUSH
30627: CALL_OW 301
30631: PUSH
30632: LD_EXP 64
30636: PUSH
30637: LD_VAR 0 2
30641: ARRAY
30642: PUSH
30643: LD_VAR 0 3
30647: ARRAY
30648: PPUSH
30649: CALL_OW 257
30653: PUSH
30654: LD_INT 1
30656: NONEQUAL
30657: OR
30658: IFFALSE 30721
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
30660: LD_ADDR_VAR 0 5
30664: PUSH
30665: LD_EXP 64
30669: PUSH
30670: LD_VAR 0 2
30674: ARRAY
30675: PUSH
30676: LD_EXP 64
30680: PUSH
30681: LD_VAR 0 2
30685: ARRAY
30686: PUSH
30687: LD_VAR 0 3
30691: ARRAY
30692: DIFF
30693: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
30694: LD_ADDR_EXP 64
30698: PUSH
30699: LD_EXP 64
30703: PPUSH
30704: LD_VAR 0 2
30708: PPUSH
30709: LD_VAR 0 5
30713: PPUSH
30714: CALL_OW 1
30718: ST_TO_ADDR
// continue ;
30719: GO 30607
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
30721: LD_EXP 64
30725: PUSH
30726: LD_VAR 0 2
30730: ARRAY
30731: PUSH
30732: LD_VAR 0 3
30736: ARRAY
30737: PPUSH
30738: CALL_OW 257
30742: PUSH
30743: LD_INT 1
30745: EQUAL
30746: PUSH
30747: LD_EXP 64
30751: PUSH
30752: LD_VAR 0 2
30756: ARRAY
30757: PUSH
30758: LD_VAR 0 3
30762: ARRAY
30763: PPUSH
30764: CALL_OW 459
30768: NOT
30769: AND
30770: PUSH
30771: LD_EXP 64
30775: PUSH
30776: LD_VAR 0 2
30780: ARRAY
30781: PUSH
30782: LD_VAR 0 3
30786: ARRAY
30787: PPUSH
30788: CALL_OW 314
30792: NOT
30793: AND
30794: IFFALSE 30954
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
30796: LD_EXP 64
30800: PUSH
30801: LD_VAR 0 2
30805: ARRAY
30806: PUSH
30807: LD_VAR 0 3
30811: ARRAY
30812: PPUSH
30813: CALL_OW 310
30817: IFFALSE 30840
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
30819: LD_EXP 64
30823: PUSH
30824: LD_VAR 0 2
30828: ARRAY
30829: PUSH
30830: LD_VAR 0 3
30834: ARRAY
30835: PPUSH
30836: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
30840: LD_EXP 64
30844: PUSH
30845: LD_VAR 0 2
30849: ARRAY
30850: PUSH
30851: LD_VAR 0 3
30855: ARRAY
30856: PPUSH
30857: CALL_OW 314
30861: NOT
30862: IFFALSE 30954
// begin r := rand ( 1 , mc_mines [ i ] ) ;
30864: LD_ADDR_VAR 0 7
30868: PUSH
30869: LD_INT 1
30871: PPUSH
30872: LD_EXP 63
30876: PUSH
30877: LD_VAR 0 2
30881: ARRAY
30882: PPUSH
30883: CALL_OW 12
30887: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
30888: LD_EXP 64
30892: PUSH
30893: LD_VAR 0 2
30897: ARRAY
30898: PUSH
30899: LD_VAR 0 3
30903: ARRAY
30904: PPUSH
30905: LD_EXP 63
30909: PUSH
30910: LD_VAR 0 2
30914: ARRAY
30915: PUSH
30916: LD_VAR 0 7
30920: ARRAY
30921: PUSH
30922: LD_INT 1
30924: ARRAY
30925: PPUSH
30926: LD_EXP 63
30930: PUSH
30931: LD_VAR 0 2
30935: ARRAY
30936: PUSH
30937: LD_VAR 0 7
30941: ARRAY
30942: PUSH
30943: LD_INT 2
30945: ARRAY
30946: PPUSH
30947: LD_INT 0
30949: PPUSH
30950: CALL_OW 193
// end ; end ; end ;
30954: GO 30607
30956: POP
30957: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
30958: LD_ADDR_VAR 0 5
30962: PUSH
30963: LD_EXP 50
30967: PUSH
30968: LD_VAR 0 2
30972: ARRAY
30973: PPUSH
30974: LD_INT 2
30976: PUSH
30977: LD_INT 30
30979: PUSH
30980: LD_INT 4
30982: PUSH
30983: EMPTY
30984: LIST
30985: LIST
30986: PUSH
30987: LD_INT 30
30989: PUSH
30990: LD_INT 5
30992: PUSH
30993: EMPTY
30994: LIST
30995: LIST
30996: PUSH
30997: LD_INT 30
30999: PUSH
31000: LD_INT 32
31002: PUSH
31003: EMPTY
31004: LIST
31005: LIST
31006: PUSH
31007: EMPTY
31008: LIST
31009: LIST
31010: LIST
31011: LIST
31012: PPUSH
31013: CALL_OW 72
31017: ST_TO_ADDR
// if not tmp then
31018: LD_VAR 0 5
31022: NOT
31023: IFFALSE 31027
// continue ;
31025: GO 30520
// list := [ ] ;
31027: LD_ADDR_VAR 0 6
31031: PUSH
31032: EMPTY
31033: ST_TO_ADDR
// for j in tmp do
31034: LD_ADDR_VAR 0 3
31038: PUSH
31039: LD_VAR 0 5
31043: PUSH
31044: FOR_IN
31045: IFFALSE 31114
// begin for k in UnitsInside ( j ) do
31047: LD_ADDR_VAR 0 4
31051: PUSH
31052: LD_VAR 0 3
31056: PPUSH
31057: CALL_OW 313
31061: PUSH
31062: FOR_IN
31063: IFFALSE 31110
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
31065: LD_VAR 0 4
31069: PPUSH
31070: CALL_OW 257
31074: PUSH
31075: LD_INT 1
31077: EQUAL
31078: PUSH
31079: LD_VAR 0 4
31083: PPUSH
31084: CALL_OW 459
31088: NOT
31089: AND
31090: IFFALSE 31108
// list := list ^ k ;
31092: LD_ADDR_VAR 0 6
31096: PUSH
31097: LD_VAR 0 6
31101: PUSH
31102: LD_VAR 0 4
31106: ADD
31107: ST_TO_ADDR
31108: GO 31062
31110: POP
31111: POP
// end ;
31112: GO 31044
31114: POP
31115: POP
// list := list diff mc_miners [ i ] ;
31116: LD_ADDR_VAR 0 6
31120: PUSH
31121: LD_VAR 0 6
31125: PUSH
31126: LD_EXP 64
31130: PUSH
31131: LD_VAR 0 2
31135: ARRAY
31136: DIFF
31137: ST_TO_ADDR
// if not list then
31138: LD_VAR 0 6
31142: NOT
31143: IFFALSE 31147
// continue ;
31145: GO 30520
// k := mc_mines [ i ] - mc_miners [ i ] ;
31147: LD_ADDR_VAR 0 4
31151: PUSH
31152: LD_EXP 63
31156: PUSH
31157: LD_VAR 0 2
31161: ARRAY
31162: PUSH
31163: LD_EXP 64
31167: PUSH
31168: LD_VAR 0 2
31172: ARRAY
31173: MINUS
31174: ST_TO_ADDR
// if k > list then
31175: LD_VAR 0 4
31179: PUSH
31180: LD_VAR 0 6
31184: GREATER
31185: IFFALSE 31197
// k := list ;
31187: LD_ADDR_VAR 0 4
31191: PUSH
31192: LD_VAR 0 6
31196: ST_TO_ADDR
// for j = 1 to k do
31197: LD_ADDR_VAR 0 3
31201: PUSH
31202: DOUBLE
31203: LD_INT 1
31205: DEC
31206: ST_TO_ADDR
31207: LD_VAR 0 4
31211: PUSH
31212: FOR_TO
31213: IFFALSE 31267
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
31215: LD_ADDR_EXP 64
31219: PUSH
31220: LD_EXP 64
31224: PPUSH
31225: LD_VAR 0 2
31229: PUSH
31230: LD_EXP 64
31234: PUSH
31235: LD_VAR 0 2
31239: ARRAY
31240: PUSH
31241: LD_INT 1
31243: PLUS
31244: PUSH
31245: EMPTY
31246: LIST
31247: LIST
31248: PPUSH
31249: LD_VAR 0 6
31253: PUSH
31254: LD_VAR 0 3
31258: ARRAY
31259: PPUSH
31260: CALL 53831 0 3
31264: ST_TO_ADDR
31265: GO 31212
31267: POP
31268: POP
// end ;
31269: GO 30520
31271: POP
31272: POP
// end ;
31273: LD_VAR 0 1
31277: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
31278: LD_INT 0
31280: PPUSH
31281: PPUSH
31282: PPUSH
31283: PPUSH
31284: PPUSH
31285: PPUSH
31286: PPUSH
31287: PPUSH
31288: PPUSH
31289: PPUSH
31290: PPUSH
// if not mc_bases then
31291: LD_EXP 50
31295: NOT
31296: IFFALSE 31300
// exit ;
31298: GO 33123
// for i = 1 to mc_bases do
31300: LD_ADDR_VAR 0 2
31304: PUSH
31305: DOUBLE
31306: LD_INT 1
31308: DEC
31309: ST_TO_ADDR
31310: LD_EXP 50
31314: PUSH
31315: FOR_TO
31316: IFFALSE 33121
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
31318: LD_EXP 50
31322: PUSH
31323: LD_VAR 0 2
31327: ARRAY
31328: NOT
31329: PUSH
31330: LD_EXP 57
31334: PUSH
31335: LD_VAR 0 2
31339: ARRAY
31340: OR
31341: IFFALSE 31345
// continue ;
31343: GO 31315
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
31345: LD_EXP 66
31349: PUSH
31350: LD_VAR 0 2
31354: ARRAY
31355: NOT
31356: PUSH
31357: LD_EXP 67
31361: PUSH
31362: LD_VAR 0 2
31366: ARRAY
31367: AND
31368: IFFALSE 31406
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
31370: LD_ADDR_EXP 67
31374: PUSH
31375: LD_EXP 67
31379: PPUSH
31380: LD_VAR 0 2
31384: PPUSH
31385: EMPTY
31386: PPUSH
31387: CALL_OW 1
31391: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
31392: LD_VAR 0 2
31396: PPUSH
31397: LD_INT 107
31399: PPUSH
31400: CALL 22153 0 2
// continue ;
31404: GO 31315
// end ; target := [ ] ;
31406: LD_ADDR_VAR 0 7
31410: PUSH
31411: EMPTY
31412: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
31413: LD_ADDR_VAR 0 6
31417: PUSH
31418: LD_EXP 50
31422: PUSH
31423: LD_VAR 0 2
31427: ARRAY
31428: PUSH
31429: LD_INT 1
31431: ARRAY
31432: PPUSH
31433: CALL_OW 255
31437: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31438: LD_ADDR_VAR 0 9
31442: PUSH
31443: LD_EXP 50
31447: PUSH
31448: LD_VAR 0 2
31452: ARRAY
31453: PPUSH
31454: LD_INT 2
31456: PUSH
31457: LD_INT 30
31459: PUSH
31460: LD_INT 0
31462: PUSH
31463: EMPTY
31464: LIST
31465: LIST
31466: PUSH
31467: LD_INT 30
31469: PUSH
31470: LD_INT 1
31472: PUSH
31473: EMPTY
31474: LIST
31475: LIST
31476: PUSH
31477: EMPTY
31478: LIST
31479: LIST
31480: LIST
31481: PPUSH
31482: CALL_OW 72
31486: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
31487: LD_ADDR_VAR 0 3
31491: PUSH
31492: DOUBLE
31493: LD_EXP 66
31497: PUSH
31498: LD_VAR 0 2
31502: ARRAY
31503: INC
31504: ST_TO_ADDR
31505: LD_INT 1
31507: PUSH
31508: FOR_DOWNTO
31509: IFFALSE 31754
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
31511: LD_EXP 66
31515: PUSH
31516: LD_VAR 0 2
31520: ARRAY
31521: PUSH
31522: LD_VAR 0 3
31526: ARRAY
31527: PUSH
31528: LD_INT 2
31530: ARRAY
31531: PPUSH
31532: LD_EXP 66
31536: PUSH
31537: LD_VAR 0 2
31541: ARRAY
31542: PUSH
31543: LD_VAR 0 3
31547: ARRAY
31548: PUSH
31549: LD_INT 3
31551: ARRAY
31552: PPUSH
31553: CALL_OW 488
31557: PUSH
31558: LD_EXP 66
31562: PUSH
31563: LD_VAR 0 2
31567: ARRAY
31568: PUSH
31569: LD_VAR 0 3
31573: ARRAY
31574: PUSH
31575: LD_INT 2
31577: ARRAY
31578: PPUSH
31579: LD_EXP 66
31583: PUSH
31584: LD_VAR 0 2
31588: ARRAY
31589: PUSH
31590: LD_VAR 0 3
31594: ARRAY
31595: PUSH
31596: LD_INT 3
31598: ARRAY
31599: PPUSH
31600: CALL_OW 284
31604: PUSH
31605: LD_INT 0
31607: EQUAL
31608: AND
31609: IFFALSE 31664
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
31611: LD_ADDR_VAR 0 5
31615: PUSH
31616: LD_EXP 66
31620: PUSH
31621: LD_VAR 0 2
31625: ARRAY
31626: PPUSH
31627: LD_VAR 0 3
31631: PPUSH
31632: CALL_OW 3
31636: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
31637: LD_ADDR_EXP 66
31641: PUSH
31642: LD_EXP 66
31646: PPUSH
31647: LD_VAR 0 2
31651: PPUSH
31652: LD_VAR 0 5
31656: PPUSH
31657: CALL_OW 1
31661: ST_TO_ADDR
// continue ;
31662: GO 31508
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
31664: LD_VAR 0 6
31668: PPUSH
31669: LD_EXP 66
31673: PUSH
31674: LD_VAR 0 2
31678: ARRAY
31679: PUSH
31680: LD_VAR 0 3
31684: ARRAY
31685: PUSH
31686: LD_INT 2
31688: ARRAY
31689: PPUSH
31690: LD_EXP 66
31694: PUSH
31695: LD_VAR 0 2
31699: ARRAY
31700: PUSH
31701: LD_VAR 0 3
31705: ARRAY
31706: PUSH
31707: LD_INT 3
31709: ARRAY
31710: PPUSH
31711: LD_INT 30
31713: PPUSH
31714: CALL 54727 0 4
31718: PUSH
31719: LD_INT 4
31721: ARRAY
31722: PUSH
31723: LD_INT 0
31725: EQUAL
31726: IFFALSE 31752
// begin target := mc_crates [ i ] [ j ] ;
31728: LD_ADDR_VAR 0 7
31732: PUSH
31733: LD_EXP 66
31737: PUSH
31738: LD_VAR 0 2
31742: ARRAY
31743: PUSH
31744: LD_VAR 0 3
31748: ARRAY
31749: ST_TO_ADDR
// break ;
31750: GO 31754
// end ; end ;
31752: GO 31508
31754: POP
31755: POP
// if not target then
31756: LD_VAR 0 7
31760: NOT
31761: IFFALSE 31765
// continue ;
31763: GO 31315
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
31765: LD_ADDR_VAR 0 8
31769: PUSH
31770: LD_EXP 69
31774: PUSH
31775: LD_VAR 0 2
31779: ARRAY
31780: PPUSH
31781: LD_INT 2
31783: PUSH
31784: LD_INT 3
31786: PUSH
31787: LD_INT 58
31789: PUSH
31790: EMPTY
31791: LIST
31792: PUSH
31793: EMPTY
31794: LIST
31795: LIST
31796: PUSH
31797: LD_INT 61
31799: PUSH
31800: EMPTY
31801: LIST
31802: PUSH
31803: LD_INT 33
31805: PUSH
31806: LD_INT 5
31808: PUSH
31809: EMPTY
31810: LIST
31811: LIST
31812: PUSH
31813: LD_INT 33
31815: PUSH
31816: LD_INT 3
31818: PUSH
31819: EMPTY
31820: LIST
31821: LIST
31822: PUSH
31823: EMPTY
31824: LIST
31825: LIST
31826: LIST
31827: LIST
31828: LIST
31829: PUSH
31830: LD_INT 2
31832: PUSH
31833: LD_INT 34
31835: PUSH
31836: LD_INT 32
31838: PUSH
31839: EMPTY
31840: LIST
31841: LIST
31842: PUSH
31843: LD_INT 34
31845: PUSH
31846: LD_INT 51
31848: PUSH
31849: EMPTY
31850: LIST
31851: LIST
31852: PUSH
31853: LD_INT 34
31855: PUSH
31856: LD_INT 12
31858: PUSH
31859: EMPTY
31860: LIST
31861: LIST
31862: PUSH
31863: EMPTY
31864: LIST
31865: LIST
31866: LIST
31867: LIST
31868: PUSH
31869: EMPTY
31870: LIST
31871: LIST
31872: PPUSH
31873: CALL_OW 72
31877: ST_TO_ADDR
// if not cargo then
31878: LD_VAR 0 8
31882: NOT
31883: IFFALSE 32589
// begin if mc_crates_collector [ i ] < 5 then
31885: LD_EXP 67
31889: PUSH
31890: LD_VAR 0 2
31894: ARRAY
31895: PUSH
31896: LD_INT 5
31898: LESS
31899: IFFALSE 32265
// begin if mc_ape [ i ] then
31901: LD_EXP 79
31905: PUSH
31906: LD_VAR 0 2
31910: ARRAY
31911: IFFALSE 31958
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
31913: LD_ADDR_VAR 0 5
31917: PUSH
31918: LD_EXP 79
31922: PUSH
31923: LD_VAR 0 2
31927: ARRAY
31928: PPUSH
31929: LD_INT 25
31931: PUSH
31932: LD_INT 16
31934: PUSH
31935: EMPTY
31936: LIST
31937: LIST
31938: PUSH
31939: LD_INT 24
31941: PUSH
31942: LD_INT 750
31944: PUSH
31945: EMPTY
31946: LIST
31947: LIST
31948: PUSH
31949: EMPTY
31950: LIST
31951: LIST
31952: PPUSH
31953: CALL_OW 72
31957: ST_TO_ADDR
// if not tmp then
31958: LD_VAR 0 5
31962: NOT
31963: IFFALSE 32010
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
31965: LD_ADDR_VAR 0 5
31969: PUSH
31970: LD_EXP 50
31974: PUSH
31975: LD_VAR 0 2
31979: ARRAY
31980: PPUSH
31981: LD_INT 25
31983: PUSH
31984: LD_INT 2
31986: PUSH
31987: EMPTY
31988: LIST
31989: LIST
31990: PUSH
31991: LD_INT 24
31993: PUSH
31994: LD_INT 750
31996: PUSH
31997: EMPTY
31998: LIST
31999: LIST
32000: PUSH
32001: EMPTY
32002: LIST
32003: LIST
32004: PPUSH
32005: CALL_OW 72
32009: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
32010: LD_EXP 79
32014: PUSH
32015: LD_VAR 0 2
32019: ARRAY
32020: PUSH
32021: LD_EXP 50
32025: PUSH
32026: LD_VAR 0 2
32030: ARRAY
32031: PPUSH
32032: LD_INT 25
32034: PUSH
32035: LD_INT 2
32037: PUSH
32038: EMPTY
32039: LIST
32040: LIST
32041: PUSH
32042: LD_INT 24
32044: PUSH
32045: LD_INT 750
32047: PUSH
32048: EMPTY
32049: LIST
32050: LIST
32051: PUSH
32052: EMPTY
32053: LIST
32054: LIST
32055: PPUSH
32056: CALL_OW 72
32060: AND
32061: PUSH
32062: LD_VAR 0 5
32066: PUSH
32067: LD_INT 5
32069: LESS
32070: AND
32071: IFFALSE 32153
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
32073: LD_ADDR_VAR 0 3
32077: PUSH
32078: LD_EXP 50
32082: PUSH
32083: LD_VAR 0 2
32087: ARRAY
32088: PPUSH
32089: LD_INT 25
32091: PUSH
32092: LD_INT 2
32094: PUSH
32095: EMPTY
32096: LIST
32097: LIST
32098: PUSH
32099: LD_INT 24
32101: PUSH
32102: LD_INT 750
32104: PUSH
32105: EMPTY
32106: LIST
32107: LIST
32108: PUSH
32109: EMPTY
32110: LIST
32111: LIST
32112: PPUSH
32113: CALL_OW 72
32117: PUSH
32118: FOR_IN
32119: IFFALSE 32151
// begin tmp := tmp union j ;
32121: LD_ADDR_VAR 0 5
32125: PUSH
32126: LD_VAR 0 5
32130: PUSH
32131: LD_VAR 0 3
32135: UNION
32136: ST_TO_ADDR
// if tmp >= 5 then
32137: LD_VAR 0 5
32141: PUSH
32142: LD_INT 5
32144: GREATEREQUAL
32145: IFFALSE 32149
// break ;
32147: GO 32151
// end ;
32149: GO 32118
32151: POP
32152: POP
// end ; if not tmp then
32153: LD_VAR 0 5
32157: NOT
32158: IFFALSE 32162
// continue ;
32160: GO 31315
// for j in tmp do
32162: LD_ADDR_VAR 0 3
32166: PUSH
32167: LD_VAR 0 5
32171: PUSH
32172: FOR_IN
32173: IFFALSE 32263
// if not GetTag ( j ) then
32175: LD_VAR 0 3
32179: PPUSH
32180: CALL_OW 110
32184: NOT
32185: IFFALSE 32261
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
32187: LD_ADDR_EXP 67
32191: PUSH
32192: LD_EXP 67
32196: PPUSH
32197: LD_VAR 0 2
32201: PUSH
32202: LD_EXP 67
32206: PUSH
32207: LD_VAR 0 2
32211: ARRAY
32212: PUSH
32213: LD_INT 1
32215: PLUS
32216: PUSH
32217: EMPTY
32218: LIST
32219: LIST
32220: PPUSH
32221: LD_VAR 0 3
32225: PPUSH
32226: CALL 53831 0 3
32230: ST_TO_ADDR
// SetTag ( j , 107 ) ;
32231: LD_VAR 0 3
32235: PPUSH
32236: LD_INT 107
32238: PPUSH
32239: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
32243: LD_EXP 67
32247: PUSH
32248: LD_VAR 0 2
32252: ARRAY
32253: PUSH
32254: LD_INT 5
32256: GREATEREQUAL
32257: IFFALSE 32261
// break ;
32259: GO 32263
// end ;
32261: GO 32172
32263: POP
32264: POP
// end ; if mc_crates_collector [ i ] and target then
32265: LD_EXP 67
32269: PUSH
32270: LD_VAR 0 2
32274: ARRAY
32275: PUSH
32276: LD_VAR 0 7
32280: AND
32281: IFFALSE 32587
// begin if mc_crates_collector [ i ] < target [ 1 ] then
32283: LD_EXP 67
32287: PUSH
32288: LD_VAR 0 2
32292: ARRAY
32293: PUSH
32294: LD_VAR 0 7
32298: PUSH
32299: LD_INT 1
32301: ARRAY
32302: LESS
32303: IFFALSE 32323
// tmp := mc_crates_collector [ i ] else
32305: LD_ADDR_VAR 0 5
32309: PUSH
32310: LD_EXP 67
32314: PUSH
32315: LD_VAR 0 2
32319: ARRAY
32320: ST_TO_ADDR
32321: GO 32337
// tmp := target [ 1 ] ;
32323: LD_ADDR_VAR 0 5
32327: PUSH
32328: LD_VAR 0 7
32332: PUSH
32333: LD_INT 1
32335: ARRAY
32336: ST_TO_ADDR
// k := 0 ;
32337: LD_ADDR_VAR 0 4
32341: PUSH
32342: LD_INT 0
32344: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
32345: LD_ADDR_VAR 0 3
32349: PUSH
32350: LD_EXP 67
32354: PUSH
32355: LD_VAR 0 2
32359: ARRAY
32360: PUSH
32361: FOR_IN
32362: IFFALSE 32585
// begin k := k + 1 ;
32364: LD_ADDR_VAR 0 4
32368: PUSH
32369: LD_VAR 0 4
32373: PUSH
32374: LD_INT 1
32376: PLUS
32377: ST_TO_ADDR
// if k > tmp then
32378: LD_VAR 0 4
32382: PUSH
32383: LD_VAR 0 5
32387: GREATER
32388: IFFALSE 32392
// break ;
32390: GO 32585
// if not GetClass ( j ) in [ 2 , 16 ] then
32392: LD_VAR 0 3
32396: PPUSH
32397: CALL_OW 257
32401: PUSH
32402: LD_INT 2
32404: PUSH
32405: LD_INT 16
32407: PUSH
32408: EMPTY
32409: LIST
32410: LIST
32411: IN
32412: NOT
32413: IFFALSE 32466
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
32415: LD_ADDR_EXP 67
32419: PUSH
32420: LD_EXP 67
32424: PPUSH
32425: LD_VAR 0 2
32429: PPUSH
32430: LD_EXP 67
32434: PUSH
32435: LD_VAR 0 2
32439: ARRAY
32440: PUSH
32441: LD_VAR 0 3
32445: DIFF
32446: PPUSH
32447: CALL_OW 1
32451: ST_TO_ADDR
// SetTag ( j , 0 ) ;
32452: LD_VAR 0 3
32456: PPUSH
32457: LD_INT 0
32459: PPUSH
32460: CALL_OW 109
// continue ;
32464: GO 32361
// end ; if IsInUnit ( j ) then
32466: LD_VAR 0 3
32470: PPUSH
32471: CALL_OW 310
32475: IFFALSE 32486
// ComExitBuilding ( j ) ;
32477: LD_VAR 0 3
32481: PPUSH
32482: CALL_OW 122
// wait ( 3 ) ;
32486: LD_INT 3
32488: PPUSH
32489: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
32493: LD_VAR 0 3
32497: PPUSH
32498: CALL_OW 314
32502: PUSH
32503: LD_VAR 0 6
32507: PPUSH
32508: LD_VAR 0 7
32512: PUSH
32513: LD_INT 2
32515: ARRAY
32516: PPUSH
32517: LD_VAR 0 7
32521: PUSH
32522: LD_INT 3
32524: ARRAY
32525: PPUSH
32526: LD_INT 30
32528: PPUSH
32529: CALL 54727 0 4
32533: PUSH
32534: LD_INT 4
32536: ARRAY
32537: AND
32538: IFFALSE 32556
// ComStandNearbyBuilding ( j , depot ) else
32540: LD_VAR 0 3
32544: PPUSH
32545: LD_VAR 0 9
32549: PPUSH
32550: CALL 50258 0 2
32554: GO 32583
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
32556: LD_VAR 0 3
32560: PPUSH
32561: LD_VAR 0 7
32565: PUSH
32566: LD_INT 2
32568: ARRAY
32569: PPUSH
32570: LD_VAR 0 7
32574: PUSH
32575: LD_INT 3
32577: ARRAY
32578: PPUSH
32579: CALL_OW 117
// end ;
32583: GO 32361
32585: POP
32586: POP
// end ; end else
32587: GO 33119
// begin for j in cargo do
32589: LD_ADDR_VAR 0 3
32593: PUSH
32594: LD_VAR 0 8
32598: PUSH
32599: FOR_IN
32600: IFFALSE 33117
// begin if GetTag ( j ) <> 0 then
32602: LD_VAR 0 3
32606: PPUSH
32607: CALL_OW 110
32611: PUSH
32612: LD_INT 0
32614: NONEQUAL
32615: IFFALSE 32619
// continue ;
32617: GO 32599
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
32619: LD_VAR 0 3
32623: PPUSH
32624: CALL_OW 256
32628: PUSH
32629: LD_INT 1000
32631: LESS
32632: PUSH
32633: LD_VAR 0 3
32637: PPUSH
32638: LD_EXP 74
32642: PUSH
32643: LD_VAR 0 2
32647: ARRAY
32648: PPUSH
32649: CALL_OW 308
32653: NOT
32654: AND
32655: IFFALSE 32677
// ComMoveToArea ( j , mc_parking [ i ] ) ;
32657: LD_VAR 0 3
32661: PPUSH
32662: LD_EXP 74
32666: PUSH
32667: LD_VAR 0 2
32671: ARRAY
32672: PPUSH
32673: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
32677: LD_VAR 0 3
32681: PPUSH
32682: CALL_OW 256
32686: PUSH
32687: LD_INT 1000
32689: LESS
32690: PUSH
32691: LD_VAR 0 3
32695: PPUSH
32696: LD_EXP 74
32700: PUSH
32701: LD_VAR 0 2
32705: ARRAY
32706: PPUSH
32707: CALL_OW 308
32711: AND
32712: IFFALSE 32716
// continue ;
32714: GO 32599
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
32716: LD_VAR 0 3
32720: PPUSH
32721: CALL_OW 262
32725: PUSH
32726: LD_INT 2
32728: EQUAL
32729: PUSH
32730: LD_VAR 0 3
32734: PPUSH
32735: CALL_OW 261
32739: PUSH
32740: LD_INT 15
32742: LESS
32743: AND
32744: IFFALSE 32748
// continue ;
32746: GO 32599
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
32748: LD_VAR 0 3
32752: PPUSH
32753: CALL_OW 262
32757: PUSH
32758: LD_INT 1
32760: EQUAL
32761: PUSH
32762: LD_VAR 0 3
32766: PPUSH
32767: CALL_OW 261
32771: PUSH
32772: LD_INT 10
32774: LESS
32775: AND
32776: IFFALSE 33056
// begin if not depot then
32778: LD_VAR 0 9
32782: NOT
32783: IFFALSE 32787
// continue ;
32785: GO 32599
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
32787: LD_VAR 0 3
32791: PPUSH
32792: LD_VAR 0 9
32796: PPUSH
32797: LD_VAR 0 3
32801: PPUSH
32802: CALL_OW 74
32806: PPUSH
32807: CALL_OW 296
32811: PUSH
32812: LD_INT 6
32814: LESS
32815: IFFALSE 32831
// SetFuel ( j , 100 ) else
32817: LD_VAR 0 3
32821: PPUSH
32822: LD_INT 100
32824: PPUSH
32825: CALL_OW 240
32829: GO 33056
// if GetFuel ( j ) = 0 then
32831: LD_VAR 0 3
32835: PPUSH
32836: CALL_OW 261
32840: PUSH
32841: LD_INT 0
32843: EQUAL
32844: IFFALSE 33056
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
32846: LD_ADDR_EXP 69
32850: PUSH
32851: LD_EXP 69
32855: PPUSH
32856: LD_VAR 0 2
32860: PPUSH
32861: LD_EXP 69
32865: PUSH
32866: LD_VAR 0 2
32870: ARRAY
32871: PUSH
32872: LD_VAR 0 3
32876: DIFF
32877: PPUSH
32878: CALL_OW 1
32882: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
32883: LD_VAR 0 3
32887: PPUSH
32888: CALL_OW 263
32892: PUSH
32893: LD_INT 1
32895: EQUAL
32896: IFFALSE 32912
// ComExitVehicle ( IsInUnit ( j ) ) ;
32898: LD_VAR 0 3
32902: PPUSH
32903: CALL_OW 310
32907: PPUSH
32908: CALL_OW 121
// if GetControl ( j ) = control_remote then
32912: LD_VAR 0 3
32916: PPUSH
32917: CALL_OW 263
32921: PUSH
32922: LD_INT 2
32924: EQUAL
32925: IFFALSE 32936
// ComUnlink ( j ) ;
32927: LD_VAR 0 3
32931: PPUSH
32932: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
32936: LD_ADDR_VAR 0 10
32940: PUSH
32941: LD_VAR 0 2
32945: PPUSH
32946: LD_INT 3
32948: PPUSH
32949: CALL 42723 0 2
32953: ST_TO_ADDR
// if fac then
32954: LD_VAR 0 10
32958: IFFALSE 33054
// begin for k in fac do
32960: LD_ADDR_VAR 0 4
32964: PUSH
32965: LD_VAR 0 10
32969: PUSH
32970: FOR_IN
32971: IFFALSE 33052
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
32973: LD_ADDR_VAR 0 11
32977: PUSH
32978: LD_VAR 0 10
32982: PPUSH
32983: LD_VAR 0 3
32987: PPUSH
32988: CALL_OW 265
32992: PPUSH
32993: LD_VAR 0 3
32997: PPUSH
32998: CALL_OW 262
33002: PPUSH
33003: LD_VAR 0 3
33007: PPUSH
33008: CALL_OW 263
33012: PPUSH
33013: LD_VAR 0 3
33017: PPUSH
33018: CALL_OW 264
33022: PPUSH
33023: CALL 51329 0 5
33027: ST_TO_ADDR
// if components then
33028: LD_VAR 0 11
33032: IFFALSE 33050
// begin MC_InsertProduceList ( i , components ) ;
33034: LD_VAR 0 2
33038: PPUSH
33039: LD_VAR 0 11
33043: PPUSH
33044: CALL 42268 0 2
// break ;
33048: GO 33052
// end ; end ;
33050: GO 32970
33052: POP
33053: POP
// end ; continue ;
33054: GO 32599
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
33056: LD_VAR 0 3
33060: PPUSH
33061: LD_INT 1
33063: PPUSH
33064: CALL_OW 289
33068: PUSH
33069: LD_INT 100
33071: LESS
33072: PUSH
33073: LD_VAR 0 3
33077: PPUSH
33078: CALL_OW 314
33082: NOT
33083: AND
33084: IFFALSE 33113
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
33086: LD_VAR 0 3
33090: PPUSH
33091: LD_VAR 0 7
33095: PUSH
33096: LD_INT 2
33098: ARRAY
33099: PPUSH
33100: LD_VAR 0 7
33104: PUSH
33105: LD_INT 3
33107: ARRAY
33108: PPUSH
33109: CALL_OW 117
// break ;
33113: GO 33117
// end ;
33115: GO 32599
33117: POP
33118: POP
// end ; end ;
33119: GO 31315
33121: POP
33122: POP
// end ;
33123: LD_VAR 0 1
33127: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
33128: LD_INT 0
33130: PPUSH
33131: PPUSH
33132: PPUSH
33133: PPUSH
// if not mc_bases then
33134: LD_EXP 50
33138: NOT
33139: IFFALSE 33143
// exit ;
33141: GO 33304
// for i = 1 to mc_bases do
33143: LD_ADDR_VAR 0 2
33147: PUSH
33148: DOUBLE
33149: LD_INT 1
33151: DEC
33152: ST_TO_ADDR
33153: LD_EXP 50
33157: PUSH
33158: FOR_TO
33159: IFFALSE 33302
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
33161: LD_ADDR_VAR 0 4
33165: PUSH
33166: LD_EXP 69
33170: PUSH
33171: LD_VAR 0 2
33175: ARRAY
33176: PUSH
33177: LD_EXP 72
33181: PUSH
33182: LD_VAR 0 2
33186: ARRAY
33187: UNION
33188: PPUSH
33189: LD_INT 33
33191: PUSH
33192: LD_INT 2
33194: PUSH
33195: EMPTY
33196: LIST
33197: LIST
33198: PPUSH
33199: CALL_OW 72
33203: ST_TO_ADDR
// if tmp then
33204: LD_VAR 0 4
33208: IFFALSE 33300
// for j in tmp do
33210: LD_ADDR_VAR 0 3
33214: PUSH
33215: LD_VAR 0 4
33219: PUSH
33220: FOR_IN
33221: IFFALSE 33298
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
33223: LD_VAR 0 3
33227: PPUSH
33228: CALL_OW 312
33232: NOT
33233: PUSH
33234: LD_VAR 0 3
33238: PPUSH
33239: CALL_OW 256
33243: PUSH
33244: LD_INT 250
33246: GREATEREQUAL
33247: AND
33248: IFFALSE 33261
// Connect ( j ) else
33250: LD_VAR 0 3
33254: PPUSH
33255: CALL 56800 0 1
33259: GO 33296
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
33261: LD_VAR 0 3
33265: PPUSH
33266: CALL_OW 256
33270: PUSH
33271: LD_INT 250
33273: LESS
33274: PUSH
33275: LD_VAR 0 3
33279: PPUSH
33280: CALL_OW 312
33284: AND
33285: IFFALSE 33296
// ComUnlink ( j ) ;
33287: LD_VAR 0 3
33291: PPUSH
33292: CALL_OW 136
33296: GO 33220
33298: POP
33299: POP
// end ;
33300: GO 33158
33302: POP
33303: POP
// end ;
33304: LD_VAR 0 1
33308: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
33309: LD_INT 0
33311: PPUSH
33312: PPUSH
33313: PPUSH
33314: PPUSH
33315: PPUSH
// if not mc_bases then
33316: LD_EXP 50
33320: NOT
33321: IFFALSE 33325
// exit ;
33323: GO 33770
// for i = 1 to mc_bases do
33325: LD_ADDR_VAR 0 2
33329: PUSH
33330: DOUBLE
33331: LD_INT 1
33333: DEC
33334: ST_TO_ADDR
33335: LD_EXP 50
33339: PUSH
33340: FOR_TO
33341: IFFALSE 33768
// begin if not mc_produce [ i ] then
33343: LD_EXP 71
33347: PUSH
33348: LD_VAR 0 2
33352: ARRAY
33353: NOT
33354: IFFALSE 33358
// continue ;
33356: GO 33340
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
33358: LD_ADDR_VAR 0 5
33362: PUSH
33363: LD_EXP 50
33367: PUSH
33368: LD_VAR 0 2
33372: ARRAY
33373: PPUSH
33374: LD_INT 30
33376: PUSH
33377: LD_INT 3
33379: PUSH
33380: EMPTY
33381: LIST
33382: LIST
33383: PPUSH
33384: CALL_OW 72
33388: ST_TO_ADDR
// if not fac then
33389: LD_VAR 0 5
33393: NOT
33394: IFFALSE 33398
// continue ;
33396: GO 33340
// for j in fac do
33398: LD_ADDR_VAR 0 3
33402: PUSH
33403: LD_VAR 0 5
33407: PUSH
33408: FOR_IN
33409: IFFALSE 33764
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
33411: LD_VAR 0 3
33415: PPUSH
33416: CALL_OW 461
33420: PUSH
33421: LD_INT 2
33423: NONEQUAL
33424: PUSH
33425: LD_VAR 0 3
33429: PPUSH
33430: LD_INT 15
33432: PPUSH
33433: CALL 56428 0 2
33437: PUSH
33438: LD_INT 4
33440: ARRAY
33441: OR
33442: IFFALSE 33446
// continue ;
33444: GO 33408
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
33446: LD_VAR 0 3
33450: PPUSH
33451: LD_EXP 71
33455: PUSH
33456: LD_VAR 0 2
33460: ARRAY
33461: PUSH
33462: LD_INT 1
33464: ARRAY
33465: PUSH
33466: LD_INT 1
33468: ARRAY
33469: PPUSH
33470: LD_EXP 71
33474: PUSH
33475: LD_VAR 0 2
33479: ARRAY
33480: PUSH
33481: LD_INT 1
33483: ARRAY
33484: PUSH
33485: LD_INT 2
33487: ARRAY
33488: PPUSH
33489: LD_EXP 71
33493: PUSH
33494: LD_VAR 0 2
33498: ARRAY
33499: PUSH
33500: LD_INT 1
33502: ARRAY
33503: PUSH
33504: LD_INT 3
33506: ARRAY
33507: PPUSH
33508: LD_EXP 71
33512: PUSH
33513: LD_VAR 0 2
33517: ARRAY
33518: PUSH
33519: LD_INT 1
33521: ARRAY
33522: PUSH
33523: LD_INT 4
33525: ARRAY
33526: PPUSH
33527: CALL_OW 448
33531: PUSH
33532: LD_VAR 0 3
33536: PPUSH
33537: LD_EXP 71
33541: PUSH
33542: LD_VAR 0 2
33546: ARRAY
33547: PUSH
33548: LD_INT 1
33550: ARRAY
33551: PUSH
33552: LD_INT 1
33554: ARRAY
33555: PUSH
33556: LD_EXP 71
33560: PUSH
33561: LD_VAR 0 2
33565: ARRAY
33566: PUSH
33567: LD_INT 1
33569: ARRAY
33570: PUSH
33571: LD_INT 2
33573: ARRAY
33574: PUSH
33575: LD_EXP 71
33579: PUSH
33580: LD_VAR 0 2
33584: ARRAY
33585: PUSH
33586: LD_INT 1
33588: ARRAY
33589: PUSH
33590: LD_INT 3
33592: ARRAY
33593: PUSH
33594: LD_EXP 71
33598: PUSH
33599: LD_VAR 0 2
33603: ARRAY
33604: PUSH
33605: LD_INT 1
33607: ARRAY
33608: PUSH
33609: LD_INT 4
33611: ARRAY
33612: PUSH
33613: EMPTY
33614: LIST
33615: LIST
33616: LIST
33617: LIST
33618: PPUSH
33619: CALL 60195 0 2
33623: AND
33624: IFFALSE 33762
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
33626: LD_VAR 0 3
33630: PPUSH
33631: LD_EXP 71
33635: PUSH
33636: LD_VAR 0 2
33640: ARRAY
33641: PUSH
33642: LD_INT 1
33644: ARRAY
33645: PUSH
33646: LD_INT 1
33648: ARRAY
33649: PPUSH
33650: LD_EXP 71
33654: PUSH
33655: LD_VAR 0 2
33659: ARRAY
33660: PUSH
33661: LD_INT 1
33663: ARRAY
33664: PUSH
33665: LD_INT 2
33667: ARRAY
33668: PPUSH
33669: LD_EXP 71
33673: PUSH
33674: LD_VAR 0 2
33678: ARRAY
33679: PUSH
33680: LD_INT 1
33682: ARRAY
33683: PUSH
33684: LD_INT 3
33686: ARRAY
33687: PPUSH
33688: LD_EXP 71
33692: PUSH
33693: LD_VAR 0 2
33697: ARRAY
33698: PUSH
33699: LD_INT 1
33701: ARRAY
33702: PUSH
33703: LD_INT 4
33705: ARRAY
33706: PPUSH
33707: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
33711: LD_ADDR_VAR 0 4
33715: PUSH
33716: LD_EXP 71
33720: PUSH
33721: LD_VAR 0 2
33725: ARRAY
33726: PPUSH
33727: LD_INT 1
33729: PPUSH
33730: CALL_OW 3
33734: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
33735: LD_ADDR_EXP 71
33739: PUSH
33740: LD_EXP 71
33744: PPUSH
33745: LD_VAR 0 2
33749: PPUSH
33750: LD_VAR 0 4
33754: PPUSH
33755: CALL_OW 1
33759: ST_TO_ADDR
// break ;
33760: GO 33764
// end ; end ;
33762: GO 33408
33764: POP
33765: POP
// end ;
33766: GO 33340
33768: POP
33769: POP
// end ;
33770: LD_VAR 0 1
33774: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
33775: LD_INT 0
33777: PPUSH
33778: PPUSH
33779: PPUSH
// if not mc_bases then
33780: LD_EXP 50
33784: NOT
33785: IFFALSE 33789
// exit ;
33787: GO 33878
// for i = 1 to mc_bases do
33789: LD_ADDR_VAR 0 2
33793: PUSH
33794: DOUBLE
33795: LD_INT 1
33797: DEC
33798: ST_TO_ADDR
33799: LD_EXP 50
33803: PUSH
33804: FOR_TO
33805: IFFALSE 33876
// begin if mc_attack [ i ] then
33807: LD_EXP 70
33811: PUSH
33812: LD_VAR 0 2
33816: ARRAY
33817: IFFALSE 33874
// begin tmp := mc_attack [ i ] [ 1 ] ;
33819: LD_ADDR_VAR 0 3
33823: PUSH
33824: LD_EXP 70
33828: PUSH
33829: LD_VAR 0 2
33833: ARRAY
33834: PUSH
33835: LD_INT 1
33837: ARRAY
33838: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
33839: LD_ADDR_EXP 70
33843: PUSH
33844: LD_EXP 70
33848: PPUSH
33849: LD_VAR 0 2
33853: PPUSH
33854: EMPTY
33855: PPUSH
33856: CALL_OW 1
33860: ST_TO_ADDR
// Attack ( tmp ) ;
33861: LD_VAR 0 3
33865: PPUSH
33866: CALL 110198 0 1
// exit ;
33870: POP
33871: POP
33872: GO 33878
// end ; end ;
33874: GO 33804
33876: POP
33877: POP
// end ;
33878: LD_VAR 0 1
33882: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
33883: LD_INT 0
33885: PPUSH
33886: PPUSH
33887: PPUSH
33888: PPUSH
33889: PPUSH
33890: PPUSH
33891: PPUSH
// if not mc_bases then
33892: LD_EXP 50
33896: NOT
33897: IFFALSE 33901
// exit ;
33899: GO 34758
// for i = 1 to mc_bases do
33901: LD_ADDR_VAR 0 2
33905: PUSH
33906: DOUBLE
33907: LD_INT 1
33909: DEC
33910: ST_TO_ADDR
33911: LD_EXP 50
33915: PUSH
33916: FOR_TO
33917: IFFALSE 34756
// begin if not mc_bases [ i ] then
33919: LD_EXP 50
33923: PUSH
33924: LD_VAR 0 2
33928: ARRAY
33929: NOT
33930: IFFALSE 33934
// continue ;
33932: GO 33916
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
33934: LD_ADDR_VAR 0 7
33938: PUSH
33939: LD_EXP 50
33943: PUSH
33944: LD_VAR 0 2
33948: ARRAY
33949: PUSH
33950: LD_INT 1
33952: ARRAY
33953: PPUSH
33954: CALL 50480 0 1
33958: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
33959: LD_ADDR_EXP 73
33963: PUSH
33964: LD_EXP 73
33968: PPUSH
33969: LD_VAR 0 2
33973: PPUSH
33974: LD_EXP 50
33978: PUSH
33979: LD_VAR 0 2
33983: ARRAY
33984: PUSH
33985: LD_INT 1
33987: ARRAY
33988: PPUSH
33989: CALL_OW 255
33993: PPUSH
33994: LD_EXP 75
33998: PUSH
33999: LD_VAR 0 2
34003: ARRAY
34004: PPUSH
34005: CALL 50445 0 2
34009: PPUSH
34010: CALL_OW 1
34014: ST_TO_ADDR
// if not mc_scan [ i ] then
34015: LD_EXP 73
34019: PUSH
34020: LD_VAR 0 2
34024: ARRAY
34025: NOT
34026: IFFALSE 34204
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
34028: LD_ADDR_EXP 93
34032: PUSH
34033: LD_EXP 93
34037: PPUSH
34038: LD_VAR 0 2
34042: PPUSH
34043: LD_INT 0
34045: PPUSH
34046: CALL_OW 1
34050: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
34051: LD_ADDR_VAR 0 4
34055: PUSH
34056: LD_EXP 50
34060: PUSH
34061: LD_VAR 0 2
34065: ARRAY
34066: PPUSH
34067: LD_INT 2
34069: PUSH
34070: LD_INT 25
34072: PUSH
34073: LD_INT 5
34075: PUSH
34076: EMPTY
34077: LIST
34078: LIST
34079: PUSH
34080: LD_INT 25
34082: PUSH
34083: LD_INT 8
34085: PUSH
34086: EMPTY
34087: LIST
34088: LIST
34089: PUSH
34090: LD_INT 25
34092: PUSH
34093: LD_INT 9
34095: PUSH
34096: EMPTY
34097: LIST
34098: LIST
34099: PUSH
34100: EMPTY
34101: LIST
34102: LIST
34103: LIST
34104: LIST
34105: PPUSH
34106: CALL_OW 72
34110: ST_TO_ADDR
// if not tmp then
34111: LD_VAR 0 4
34115: NOT
34116: IFFALSE 34120
// continue ;
34118: GO 33916
// for j in tmp do
34120: LD_ADDR_VAR 0 3
34124: PUSH
34125: LD_VAR 0 4
34129: PUSH
34130: FOR_IN
34131: IFFALSE 34202
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
34133: LD_VAR 0 3
34137: PPUSH
34138: CALL_OW 310
34142: PPUSH
34143: CALL_OW 266
34147: PUSH
34148: LD_INT 5
34150: EQUAL
34151: PUSH
34152: LD_VAR 0 3
34156: PPUSH
34157: CALL_OW 257
34161: PUSH
34162: LD_INT 1
34164: EQUAL
34165: AND
34166: PUSH
34167: LD_VAR 0 3
34171: PPUSH
34172: CALL_OW 459
34176: NOT
34177: AND
34178: PUSH
34179: LD_VAR 0 7
34183: AND
34184: IFFALSE 34200
// ComChangeProfession ( j , class ) ;
34186: LD_VAR 0 3
34190: PPUSH
34191: LD_VAR 0 7
34195: PPUSH
34196: CALL_OW 123
34200: GO 34130
34202: POP
34203: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
34204: LD_EXP 73
34208: PUSH
34209: LD_VAR 0 2
34213: ARRAY
34214: PUSH
34215: LD_EXP 93
34219: PUSH
34220: LD_VAR 0 2
34224: ARRAY
34225: NOT
34226: AND
34227: PUSH
34228: LD_EXP 72
34232: PUSH
34233: LD_VAR 0 2
34237: ARRAY
34238: NOT
34239: AND
34240: PUSH
34241: LD_EXP 50
34245: PUSH
34246: LD_VAR 0 2
34250: ARRAY
34251: PPUSH
34252: LD_INT 50
34254: PUSH
34255: EMPTY
34256: LIST
34257: PUSH
34258: LD_INT 2
34260: PUSH
34261: LD_INT 30
34263: PUSH
34264: LD_INT 32
34266: PUSH
34267: EMPTY
34268: LIST
34269: LIST
34270: PUSH
34271: LD_INT 30
34273: PUSH
34274: LD_INT 33
34276: PUSH
34277: EMPTY
34278: LIST
34279: LIST
34280: PUSH
34281: LD_INT 30
34283: PUSH
34284: LD_INT 4
34286: PUSH
34287: EMPTY
34288: LIST
34289: LIST
34290: PUSH
34291: LD_INT 30
34293: PUSH
34294: LD_INT 5
34296: PUSH
34297: EMPTY
34298: LIST
34299: LIST
34300: PUSH
34301: EMPTY
34302: LIST
34303: LIST
34304: LIST
34305: LIST
34306: LIST
34307: PUSH
34308: EMPTY
34309: LIST
34310: LIST
34311: PPUSH
34312: CALL_OW 72
34316: PUSH
34317: LD_INT 4
34319: LESS
34320: PUSH
34321: LD_EXP 50
34325: PUSH
34326: LD_VAR 0 2
34330: ARRAY
34331: PPUSH
34332: LD_INT 3
34334: PUSH
34335: LD_INT 24
34337: PUSH
34338: LD_INT 1000
34340: PUSH
34341: EMPTY
34342: LIST
34343: LIST
34344: PUSH
34345: EMPTY
34346: LIST
34347: LIST
34348: PUSH
34349: LD_INT 2
34351: PUSH
34352: LD_INT 30
34354: PUSH
34355: LD_INT 0
34357: PUSH
34358: EMPTY
34359: LIST
34360: LIST
34361: PUSH
34362: LD_INT 30
34364: PUSH
34365: LD_INT 1
34367: PUSH
34368: EMPTY
34369: LIST
34370: LIST
34371: PUSH
34372: EMPTY
34373: LIST
34374: LIST
34375: LIST
34376: PUSH
34377: EMPTY
34378: LIST
34379: LIST
34380: PPUSH
34381: CALL_OW 72
34385: OR
34386: AND
34387: IFFALSE 34638
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
34389: LD_ADDR_EXP 93
34393: PUSH
34394: LD_EXP 93
34398: PPUSH
34399: LD_VAR 0 2
34403: PPUSH
34404: LD_INT 1
34406: PPUSH
34407: CALL_OW 1
34411: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
34412: LD_ADDR_VAR 0 4
34416: PUSH
34417: LD_EXP 50
34421: PUSH
34422: LD_VAR 0 2
34426: ARRAY
34427: PPUSH
34428: LD_INT 2
34430: PUSH
34431: LD_INT 25
34433: PUSH
34434: LD_INT 1
34436: PUSH
34437: EMPTY
34438: LIST
34439: LIST
34440: PUSH
34441: LD_INT 25
34443: PUSH
34444: LD_INT 5
34446: PUSH
34447: EMPTY
34448: LIST
34449: LIST
34450: PUSH
34451: LD_INT 25
34453: PUSH
34454: LD_INT 8
34456: PUSH
34457: EMPTY
34458: LIST
34459: LIST
34460: PUSH
34461: LD_INT 25
34463: PUSH
34464: LD_INT 9
34466: PUSH
34467: EMPTY
34468: LIST
34469: LIST
34470: PUSH
34471: EMPTY
34472: LIST
34473: LIST
34474: LIST
34475: LIST
34476: LIST
34477: PPUSH
34478: CALL_OW 72
34482: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
34483: LD_ADDR_VAR 0 4
34487: PUSH
34488: LD_VAR 0 4
34492: PUSH
34493: LD_VAR 0 4
34497: PPUSH
34498: LD_INT 18
34500: PPUSH
34501: CALL 83743 0 2
34505: DIFF
34506: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
34507: LD_VAR 0 4
34511: NOT
34512: PUSH
34513: LD_EXP 50
34517: PUSH
34518: LD_VAR 0 2
34522: ARRAY
34523: PPUSH
34524: LD_INT 2
34526: PUSH
34527: LD_INT 30
34529: PUSH
34530: LD_INT 4
34532: PUSH
34533: EMPTY
34534: LIST
34535: LIST
34536: PUSH
34537: LD_INT 30
34539: PUSH
34540: LD_INT 5
34542: PUSH
34543: EMPTY
34544: LIST
34545: LIST
34546: PUSH
34547: EMPTY
34548: LIST
34549: LIST
34550: LIST
34551: PPUSH
34552: CALL_OW 72
34556: NOT
34557: AND
34558: IFFALSE 34620
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
34560: LD_ADDR_VAR 0 4
34564: PUSH
34565: LD_EXP 50
34569: PUSH
34570: LD_VAR 0 2
34574: ARRAY
34575: PPUSH
34576: LD_INT 2
34578: PUSH
34579: LD_INT 25
34581: PUSH
34582: LD_INT 2
34584: PUSH
34585: EMPTY
34586: LIST
34587: LIST
34588: PUSH
34589: LD_INT 25
34591: PUSH
34592: LD_INT 3
34594: PUSH
34595: EMPTY
34596: LIST
34597: LIST
34598: PUSH
34599: LD_INT 25
34601: PUSH
34602: LD_INT 4
34604: PUSH
34605: EMPTY
34606: LIST
34607: LIST
34608: PUSH
34609: EMPTY
34610: LIST
34611: LIST
34612: LIST
34613: LIST
34614: PPUSH
34615: CALL_OW 72
34619: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
34620: LD_VAR 0 2
34624: PPUSH
34625: LD_VAR 0 4
34629: PPUSH
34630: CALL 114907 0 2
// exit ;
34634: POP
34635: POP
34636: GO 34758
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
34638: LD_EXP 73
34642: PUSH
34643: LD_VAR 0 2
34647: ARRAY
34648: PUSH
34649: LD_EXP 93
34653: PUSH
34654: LD_VAR 0 2
34658: ARRAY
34659: NOT
34660: AND
34661: PUSH
34662: LD_EXP 72
34666: PUSH
34667: LD_VAR 0 2
34671: ARRAY
34672: AND
34673: IFFALSE 34754
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
34675: LD_ADDR_EXP 93
34679: PUSH
34680: LD_EXP 93
34684: PPUSH
34685: LD_VAR 0 2
34689: PPUSH
34690: LD_INT 1
34692: PPUSH
34693: CALL_OW 1
34697: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
34698: LD_ADDR_VAR 0 4
34702: PUSH
34703: LD_EXP 72
34707: PUSH
34708: LD_VAR 0 2
34712: ARRAY
34713: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
34714: LD_ADDR_EXP 72
34718: PUSH
34719: LD_EXP 72
34723: PPUSH
34724: LD_VAR 0 2
34728: PPUSH
34729: EMPTY
34730: PPUSH
34731: CALL_OW 1
34735: ST_TO_ADDR
// Defend ( i , tmp ) ;
34736: LD_VAR 0 2
34740: PPUSH
34741: LD_VAR 0 4
34745: PPUSH
34746: CALL 115503 0 2
// exit ;
34750: POP
34751: POP
34752: GO 34758
// end ; end ;
34754: GO 33916
34756: POP
34757: POP
// end ;
34758: LD_VAR 0 1
34762: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
34763: LD_INT 0
34765: PPUSH
34766: PPUSH
34767: PPUSH
34768: PPUSH
34769: PPUSH
34770: PPUSH
34771: PPUSH
34772: PPUSH
34773: PPUSH
34774: PPUSH
34775: PPUSH
// if not mc_bases then
34776: LD_EXP 50
34780: NOT
34781: IFFALSE 34785
// exit ;
34783: GO 35872
// for i = 1 to mc_bases do
34785: LD_ADDR_VAR 0 2
34789: PUSH
34790: DOUBLE
34791: LD_INT 1
34793: DEC
34794: ST_TO_ADDR
34795: LD_EXP 50
34799: PUSH
34800: FOR_TO
34801: IFFALSE 35870
// begin tmp := mc_lab [ i ] ;
34803: LD_ADDR_VAR 0 6
34807: PUSH
34808: LD_EXP 83
34812: PUSH
34813: LD_VAR 0 2
34817: ARRAY
34818: ST_TO_ADDR
// if not tmp then
34819: LD_VAR 0 6
34823: NOT
34824: IFFALSE 34828
// continue ;
34826: GO 34800
// idle_lab := 0 ;
34828: LD_ADDR_VAR 0 11
34832: PUSH
34833: LD_INT 0
34835: ST_TO_ADDR
// for j in tmp do
34836: LD_ADDR_VAR 0 3
34840: PUSH
34841: LD_VAR 0 6
34845: PUSH
34846: FOR_IN
34847: IFFALSE 35866
// begin researching := false ;
34849: LD_ADDR_VAR 0 10
34853: PUSH
34854: LD_INT 0
34856: ST_TO_ADDR
// side := GetSide ( j ) ;
34857: LD_ADDR_VAR 0 4
34861: PUSH
34862: LD_VAR 0 3
34866: PPUSH
34867: CALL_OW 255
34871: ST_TO_ADDR
// if not mc_tech [ side ] then
34872: LD_EXP 77
34876: PUSH
34877: LD_VAR 0 4
34881: ARRAY
34882: NOT
34883: IFFALSE 34887
// continue ;
34885: GO 34846
// if BuildingStatus ( j ) = bs_idle then
34887: LD_VAR 0 3
34891: PPUSH
34892: CALL_OW 461
34896: PUSH
34897: LD_INT 2
34899: EQUAL
34900: IFFALSE 35088
// begin if idle_lab and UnitsInside ( j ) < 6 then
34902: LD_VAR 0 11
34906: PUSH
34907: LD_VAR 0 3
34911: PPUSH
34912: CALL_OW 313
34916: PUSH
34917: LD_INT 6
34919: LESS
34920: AND
34921: IFFALSE 34992
// begin tmp2 := UnitsInside ( idle_lab ) ;
34923: LD_ADDR_VAR 0 9
34927: PUSH
34928: LD_VAR 0 11
34932: PPUSH
34933: CALL_OW 313
34937: ST_TO_ADDR
// if tmp2 then
34938: LD_VAR 0 9
34942: IFFALSE 34984
// for x in tmp2 do
34944: LD_ADDR_VAR 0 7
34948: PUSH
34949: LD_VAR 0 9
34953: PUSH
34954: FOR_IN
34955: IFFALSE 34982
// begin ComExitBuilding ( x ) ;
34957: LD_VAR 0 7
34961: PPUSH
34962: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
34966: LD_VAR 0 7
34970: PPUSH
34971: LD_VAR 0 3
34975: PPUSH
34976: CALL_OW 180
// end ;
34980: GO 34954
34982: POP
34983: POP
// idle_lab := 0 ;
34984: LD_ADDR_VAR 0 11
34988: PUSH
34989: LD_INT 0
34991: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
34992: LD_ADDR_VAR 0 5
34996: PUSH
34997: LD_EXP 77
35001: PUSH
35002: LD_VAR 0 4
35006: ARRAY
35007: PUSH
35008: FOR_IN
35009: IFFALSE 35069
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
35011: LD_VAR 0 3
35015: PPUSH
35016: LD_VAR 0 5
35020: PPUSH
35021: CALL_OW 430
35025: PUSH
35026: LD_VAR 0 4
35030: PPUSH
35031: LD_VAR 0 5
35035: PPUSH
35036: CALL 49550 0 2
35040: AND
35041: IFFALSE 35067
// begin researching := true ;
35043: LD_ADDR_VAR 0 10
35047: PUSH
35048: LD_INT 1
35050: ST_TO_ADDR
// ComResearch ( j , t ) ;
35051: LD_VAR 0 3
35055: PPUSH
35056: LD_VAR 0 5
35060: PPUSH
35061: CALL_OW 124
// break ;
35065: GO 35069
// end ;
35067: GO 35008
35069: POP
35070: POP
// if not researching then
35071: LD_VAR 0 10
35075: NOT
35076: IFFALSE 35088
// idle_lab := j ;
35078: LD_ADDR_VAR 0 11
35082: PUSH
35083: LD_VAR 0 3
35087: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
35088: LD_VAR 0 3
35092: PPUSH
35093: CALL_OW 461
35097: PUSH
35098: LD_INT 10
35100: EQUAL
35101: IFFALSE 35689
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
35103: LD_EXP 79
35107: PUSH
35108: LD_VAR 0 2
35112: ARRAY
35113: NOT
35114: PUSH
35115: LD_EXP 80
35119: PUSH
35120: LD_VAR 0 2
35124: ARRAY
35125: NOT
35126: AND
35127: PUSH
35128: LD_EXP 77
35132: PUSH
35133: LD_VAR 0 4
35137: ARRAY
35138: PUSH
35139: LD_INT 1
35141: GREATER
35142: AND
35143: IFFALSE 35274
// begin ComCancel ( j ) ;
35145: LD_VAR 0 3
35149: PPUSH
35150: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
35154: LD_ADDR_EXP 77
35158: PUSH
35159: LD_EXP 77
35163: PPUSH
35164: LD_VAR 0 4
35168: PPUSH
35169: LD_EXP 77
35173: PUSH
35174: LD_VAR 0 4
35178: ARRAY
35179: PPUSH
35180: LD_EXP 77
35184: PUSH
35185: LD_VAR 0 4
35189: ARRAY
35190: PUSH
35191: LD_INT 1
35193: MINUS
35194: PPUSH
35195: LD_EXP 77
35199: PUSH
35200: LD_VAR 0 4
35204: ARRAY
35205: PPUSH
35206: LD_INT 0
35208: PPUSH
35209: CALL 53249 0 4
35213: PPUSH
35214: CALL_OW 1
35218: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
35219: LD_ADDR_EXP 77
35223: PUSH
35224: LD_EXP 77
35228: PPUSH
35229: LD_VAR 0 4
35233: PPUSH
35234: LD_EXP 77
35238: PUSH
35239: LD_VAR 0 4
35243: ARRAY
35244: PPUSH
35245: LD_EXP 77
35249: PUSH
35250: LD_VAR 0 4
35254: ARRAY
35255: PPUSH
35256: LD_INT 1
35258: PPUSH
35259: LD_INT 0
35261: PPUSH
35262: CALL 53249 0 4
35266: PPUSH
35267: CALL_OW 1
35271: ST_TO_ADDR
// continue ;
35272: GO 34846
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
35274: LD_EXP 79
35278: PUSH
35279: LD_VAR 0 2
35283: ARRAY
35284: PUSH
35285: LD_EXP 80
35289: PUSH
35290: LD_VAR 0 2
35294: ARRAY
35295: NOT
35296: AND
35297: IFFALSE 35424
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
35299: LD_ADDR_EXP 80
35303: PUSH
35304: LD_EXP 80
35308: PPUSH
35309: LD_VAR 0 2
35313: PUSH
35314: LD_EXP 80
35318: PUSH
35319: LD_VAR 0 2
35323: ARRAY
35324: PUSH
35325: LD_INT 1
35327: PLUS
35328: PUSH
35329: EMPTY
35330: LIST
35331: LIST
35332: PPUSH
35333: LD_EXP 79
35337: PUSH
35338: LD_VAR 0 2
35342: ARRAY
35343: PUSH
35344: LD_INT 1
35346: ARRAY
35347: PPUSH
35348: CALL 53831 0 3
35352: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
35353: LD_EXP 79
35357: PUSH
35358: LD_VAR 0 2
35362: ARRAY
35363: PUSH
35364: LD_INT 1
35366: ARRAY
35367: PPUSH
35368: LD_INT 112
35370: PPUSH
35371: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
35375: LD_ADDR_VAR 0 9
35379: PUSH
35380: LD_EXP 79
35384: PUSH
35385: LD_VAR 0 2
35389: ARRAY
35390: PPUSH
35391: LD_INT 1
35393: PPUSH
35394: CALL_OW 3
35398: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
35399: LD_ADDR_EXP 79
35403: PUSH
35404: LD_EXP 79
35408: PPUSH
35409: LD_VAR 0 2
35413: PPUSH
35414: LD_VAR 0 9
35418: PPUSH
35419: CALL_OW 1
35423: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
35424: LD_EXP 79
35428: PUSH
35429: LD_VAR 0 2
35433: ARRAY
35434: PUSH
35435: LD_EXP 80
35439: PUSH
35440: LD_VAR 0 2
35444: ARRAY
35445: AND
35446: PUSH
35447: LD_EXP 80
35451: PUSH
35452: LD_VAR 0 2
35456: ARRAY
35457: PUSH
35458: LD_INT 1
35460: ARRAY
35461: PPUSH
35462: CALL_OW 310
35466: NOT
35467: AND
35468: PUSH
35469: LD_VAR 0 3
35473: PPUSH
35474: CALL_OW 313
35478: PUSH
35479: LD_INT 6
35481: EQUAL
35482: AND
35483: IFFALSE 35539
// begin tmp2 := UnitsInside ( j ) ;
35485: LD_ADDR_VAR 0 9
35489: PUSH
35490: LD_VAR 0 3
35494: PPUSH
35495: CALL_OW 313
35499: ST_TO_ADDR
// if tmp2 = 6 then
35500: LD_VAR 0 9
35504: PUSH
35505: LD_INT 6
35507: EQUAL
35508: IFFALSE 35539
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
35510: LD_VAR 0 9
35514: PUSH
35515: LD_INT 1
35517: ARRAY
35518: PPUSH
35519: LD_INT 112
35521: PPUSH
35522: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
35526: LD_VAR 0 9
35530: PUSH
35531: LD_INT 1
35533: ARRAY
35534: PPUSH
35535: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
35539: LD_EXP 80
35543: PUSH
35544: LD_VAR 0 2
35548: ARRAY
35549: PUSH
35550: LD_EXP 80
35554: PUSH
35555: LD_VAR 0 2
35559: ARRAY
35560: PUSH
35561: LD_INT 1
35563: ARRAY
35564: PPUSH
35565: CALL_OW 314
35569: NOT
35570: AND
35571: PUSH
35572: LD_EXP 80
35576: PUSH
35577: LD_VAR 0 2
35581: ARRAY
35582: PUSH
35583: LD_INT 1
35585: ARRAY
35586: PPUSH
35587: CALL_OW 310
35591: NOT
35592: AND
35593: IFFALSE 35619
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
35595: LD_EXP 80
35599: PUSH
35600: LD_VAR 0 2
35604: ARRAY
35605: PUSH
35606: LD_INT 1
35608: ARRAY
35609: PPUSH
35610: LD_VAR 0 3
35614: PPUSH
35615: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
35619: LD_EXP 80
35623: PUSH
35624: LD_VAR 0 2
35628: ARRAY
35629: PUSH
35630: LD_INT 1
35632: ARRAY
35633: PPUSH
35634: CALL_OW 310
35638: PUSH
35639: LD_EXP 80
35643: PUSH
35644: LD_VAR 0 2
35648: ARRAY
35649: PUSH
35650: LD_INT 1
35652: ARRAY
35653: PPUSH
35654: CALL_OW 310
35658: PPUSH
35659: CALL_OW 461
35663: PUSH
35664: LD_INT 3
35666: NONEQUAL
35667: AND
35668: IFFALSE 35689
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
35670: LD_EXP 80
35674: PUSH
35675: LD_VAR 0 2
35679: ARRAY
35680: PUSH
35681: LD_INT 1
35683: ARRAY
35684: PPUSH
35685: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
35689: LD_VAR 0 3
35693: PPUSH
35694: CALL_OW 461
35698: PUSH
35699: LD_INT 6
35701: EQUAL
35702: PUSH
35703: LD_VAR 0 6
35707: PUSH
35708: LD_INT 1
35710: GREATER
35711: AND
35712: IFFALSE 35864
// begin sci := [ ] ;
35714: LD_ADDR_VAR 0 8
35718: PUSH
35719: EMPTY
35720: ST_TO_ADDR
// for x in ( tmp diff j ) do
35721: LD_ADDR_VAR 0 7
35725: PUSH
35726: LD_VAR 0 6
35730: PUSH
35731: LD_VAR 0 3
35735: DIFF
35736: PUSH
35737: FOR_IN
35738: IFFALSE 35790
// begin if sci = 6 then
35740: LD_VAR 0 8
35744: PUSH
35745: LD_INT 6
35747: EQUAL
35748: IFFALSE 35752
// break ;
35750: GO 35790
// if BuildingStatus ( x ) = bs_idle then
35752: LD_VAR 0 7
35756: PPUSH
35757: CALL_OW 461
35761: PUSH
35762: LD_INT 2
35764: EQUAL
35765: IFFALSE 35788
// sci := sci ^ UnitsInside ( x ) ;
35767: LD_ADDR_VAR 0 8
35771: PUSH
35772: LD_VAR 0 8
35776: PUSH
35777: LD_VAR 0 7
35781: PPUSH
35782: CALL_OW 313
35786: ADD
35787: ST_TO_ADDR
// end ;
35788: GO 35737
35790: POP
35791: POP
// if not sci then
35792: LD_VAR 0 8
35796: NOT
35797: IFFALSE 35801
// continue ;
35799: GO 34846
// for x in sci do
35801: LD_ADDR_VAR 0 7
35805: PUSH
35806: LD_VAR 0 8
35810: PUSH
35811: FOR_IN
35812: IFFALSE 35862
// if IsInUnit ( x ) and not HasTask ( x ) then
35814: LD_VAR 0 7
35818: PPUSH
35819: CALL_OW 310
35823: PUSH
35824: LD_VAR 0 7
35828: PPUSH
35829: CALL_OW 314
35833: NOT
35834: AND
35835: IFFALSE 35860
// begin ComExitBuilding ( x ) ;
35837: LD_VAR 0 7
35841: PPUSH
35842: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
35846: LD_VAR 0 7
35850: PPUSH
35851: LD_VAR 0 3
35855: PPUSH
35856: CALL_OW 180
// end ;
35860: GO 35811
35862: POP
35863: POP
// end ; end ;
35864: GO 34846
35866: POP
35867: POP
// end ;
35868: GO 34800
35870: POP
35871: POP
// end ;
35872: LD_VAR 0 1
35876: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
35877: LD_INT 0
35879: PPUSH
35880: PPUSH
// if not mc_bases then
35881: LD_EXP 50
35885: NOT
35886: IFFALSE 35890
// exit ;
35888: GO 35971
// for i = 1 to mc_bases do
35890: LD_ADDR_VAR 0 2
35894: PUSH
35895: DOUBLE
35896: LD_INT 1
35898: DEC
35899: ST_TO_ADDR
35900: LD_EXP 50
35904: PUSH
35905: FOR_TO
35906: IFFALSE 35969
// if mc_mines [ i ] and mc_miners [ i ] then
35908: LD_EXP 63
35912: PUSH
35913: LD_VAR 0 2
35917: ARRAY
35918: PUSH
35919: LD_EXP 64
35923: PUSH
35924: LD_VAR 0 2
35928: ARRAY
35929: AND
35930: IFFALSE 35967
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
35932: LD_EXP 64
35936: PUSH
35937: LD_VAR 0 2
35941: ARRAY
35942: PUSH
35943: LD_INT 1
35945: ARRAY
35946: PPUSH
35947: CALL_OW 255
35951: PPUSH
35952: LD_EXP 63
35956: PUSH
35957: LD_VAR 0 2
35961: ARRAY
35962: PPUSH
35963: CALL 50633 0 2
35967: GO 35905
35969: POP
35970: POP
// end ;
35971: LD_VAR 0 1
35975: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
35976: LD_INT 0
35978: PPUSH
35979: PPUSH
35980: PPUSH
35981: PPUSH
35982: PPUSH
35983: PPUSH
35984: PPUSH
35985: PPUSH
// if not mc_bases or not mc_parking then
35986: LD_EXP 50
35990: NOT
35991: PUSH
35992: LD_EXP 74
35996: NOT
35997: OR
35998: IFFALSE 36002
// exit ;
36000: GO 36740
// for i = 1 to mc_bases do
36002: LD_ADDR_VAR 0 2
36006: PUSH
36007: DOUBLE
36008: LD_INT 1
36010: DEC
36011: ST_TO_ADDR
36012: LD_EXP 50
36016: PUSH
36017: FOR_TO
36018: IFFALSE 36738
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
36020: LD_EXP 50
36024: PUSH
36025: LD_VAR 0 2
36029: ARRAY
36030: NOT
36031: PUSH
36032: LD_EXP 74
36036: PUSH
36037: LD_VAR 0 2
36041: ARRAY
36042: NOT
36043: OR
36044: IFFALSE 36048
// continue ;
36046: GO 36017
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
36048: LD_ADDR_VAR 0 5
36052: PUSH
36053: LD_EXP 50
36057: PUSH
36058: LD_VAR 0 2
36062: ARRAY
36063: PUSH
36064: LD_INT 1
36066: ARRAY
36067: PPUSH
36068: CALL_OW 255
36072: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
36073: LD_ADDR_VAR 0 6
36077: PUSH
36078: LD_EXP 50
36082: PUSH
36083: LD_VAR 0 2
36087: ARRAY
36088: PPUSH
36089: LD_INT 30
36091: PUSH
36092: LD_INT 3
36094: PUSH
36095: EMPTY
36096: LIST
36097: LIST
36098: PPUSH
36099: CALL_OW 72
36103: ST_TO_ADDR
// if not fac then
36104: LD_VAR 0 6
36108: NOT
36109: IFFALSE 36160
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
36111: LD_ADDR_VAR 0 6
36115: PUSH
36116: LD_EXP 50
36120: PUSH
36121: LD_VAR 0 2
36125: ARRAY
36126: PPUSH
36127: LD_INT 2
36129: PUSH
36130: LD_INT 30
36132: PUSH
36133: LD_INT 0
36135: PUSH
36136: EMPTY
36137: LIST
36138: LIST
36139: PUSH
36140: LD_INT 30
36142: PUSH
36143: LD_INT 1
36145: PUSH
36146: EMPTY
36147: LIST
36148: LIST
36149: PUSH
36150: EMPTY
36151: LIST
36152: LIST
36153: LIST
36154: PPUSH
36155: CALL_OW 72
36159: ST_TO_ADDR
// if not fac then
36160: LD_VAR 0 6
36164: NOT
36165: IFFALSE 36169
// continue ;
36167: GO 36017
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
36169: LD_ADDR_VAR 0 7
36173: PUSH
36174: LD_EXP 74
36178: PUSH
36179: LD_VAR 0 2
36183: ARRAY
36184: PPUSH
36185: LD_INT 22
36187: PUSH
36188: LD_VAR 0 5
36192: PUSH
36193: EMPTY
36194: LIST
36195: LIST
36196: PUSH
36197: LD_INT 21
36199: PUSH
36200: LD_INT 2
36202: PUSH
36203: EMPTY
36204: LIST
36205: LIST
36206: PUSH
36207: LD_INT 3
36209: PUSH
36210: LD_INT 60
36212: PUSH
36213: EMPTY
36214: LIST
36215: PUSH
36216: EMPTY
36217: LIST
36218: LIST
36219: PUSH
36220: LD_INT 3
36222: PUSH
36223: LD_INT 24
36225: PUSH
36226: LD_INT 1000
36228: PUSH
36229: EMPTY
36230: LIST
36231: LIST
36232: PUSH
36233: EMPTY
36234: LIST
36235: LIST
36236: PUSH
36237: EMPTY
36238: LIST
36239: LIST
36240: LIST
36241: LIST
36242: PPUSH
36243: CALL_OW 70
36247: ST_TO_ADDR
// for j in fac do
36248: LD_ADDR_VAR 0 3
36252: PUSH
36253: LD_VAR 0 6
36257: PUSH
36258: FOR_IN
36259: IFFALSE 36354
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
36261: LD_ADDR_VAR 0 7
36265: PUSH
36266: LD_VAR 0 7
36270: PUSH
36271: LD_INT 22
36273: PUSH
36274: LD_VAR 0 5
36278: PUSH
36279: EMPTY
36280: LIST
36281: LIST
36282: PUSH
36283: LD_INT 91
36285: PUSH
36286: LD_VAR 0 3
36290: PUSH
36291: LD_INT 15
36293: PUSH
36294: EMPTY
36295: LIST
36296: LIST
36297: LIST
36298: PUSH
36299: LD_INT 21
36301: PUSH
36302: LD_INT 2
36304: PUSH
36305: EMPTY
36306: LIST
36307: LIST
36308: PUSH
36309: LD_INT 3
36311: PUSH
36312: LD_INT 60
36314: PUSH
36315: EMPTY
36316: LIST
36317: PUSH
36318: EMPTY
36319: LIST
36320: LIST
36321: PUSH
36322: LD_INT 3
36324: PUSH
36325: LD_INT 24
36327: PUSH
36328: LD_INT 1000
36330: PUSH
36331: EMPTY
36332: LIST
36333: LIST
36334: PUSH
36335: EMPTY
36336: LIST
36337: LIST
36338: PUSH
36339: EMPTY
36340: LIST
36341: LIST
36342: LIST
36343: LIST
36344: LIST
36345: PPUSH
36346: CALL_OW 69
36350: UNION
36351: ST_TO_ADDR
36352: GO 36258
36354: POP
36355: POP
// if not vehs then
36356: LD_VAR 0 7
36360: NOT
36361: IFFALSE 36387
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
36363: LD_ADDR_EXP 62
36367: PUSH
36368: LD_EXP 62
36372: PPUSH
36373: LD_VAR 0 2
36377: PPUSH
36378: EMPTY
36379: PPUSH
36380: CALL_OW 1
36384: ST_TO_ADDR
// continue ;
36385: GO 36017
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
36387: LD_ADDR_VAR 0 8
36391: PUSH
36392: LD_EXP 50
36396: PUSH
36397: LD_VAR 0 2
36401: ARRAY
36402: PPUSH
36403: LD_INT 30
36405: PUSH
36406: LD_INT 3
36408: PUSH
36409: EMPTY
36410: LIST
36411: LIST
36412: PPUSH
36413: CALL_OW 72
36417: ST_TO_ADDR
// if tmp then
36418: LD_VAR 0 8
36422: IFFALSE 36525
// begin for j in tmp do
36424: LD_ADDR_VAR 0 3
36428: PUSH
36429: LD_VAR 0 8
36433: PUSH
36434: FOR_IN
36435: IFFALSE 36523
// for k in UnitsInside ( j ) do
36437: LD_ADDR_VAR 0 4
36441: PUSH
36442: LD_VAR 0 3
36446: PPUSH
36447: CALL_OW 313
36451: PUSH
36452: FOR_IN
36453: IFFALSE 36519
// if k then
36455: LD_VAR 0 4
36459: IFFALSE 36517
// if not k in mc_repair_vehicle [ i ] then
36461: LD_VAR 0 4
36465: PUSH
36466: LD_EXP 62
36470: PUSH
36471: LD_VAR 0 2
36475: ARRAY
36476: IN
36477: NOT
36478: IFFALSE 36517
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
36480: LD_ADDR_EXP 62
36484: PUSH
36485: LD_EXP 62
36489: PPUSH
36490: LD_VAR 0 2
36494: PPUSH
36495: LD_EXP 62
36499: PUSH
36500: LD_VAR 0 2
36504: ARRAY
36505: PUSH
36506: LD_VAR 0 4
36510: UNION
36511: PPUSH
36512: CALL_OW 1
36516: ST_TO_ADDR
36517: GO 36452
36519: POP
36520: POP
36521: GO 36434
36523: POP
36524: POP
// end ; if not mc_repair_vehicle [ i ] then
36525: LD_EXP 62
36529: PUSH
36530: LD_VAR 0 2
36534: ARRAY
36535: NOT
36536: IFFALSE 36540
// continue ;
36538: GO 36017
// for j in mc_repair_vehicle [ i ] do
36540: LD_ADDR_VAR 0 3
36544: PUSH
36545: LD_EXP 62
36549: PUSH
36550: LD_VAR 0 2
36554: ARRAY
36555: PUSH
36556: FOR_IN
36557: IFFALSE 36734
// begin if GetClass ( j ) <> 3 then
36559: LD_VAR 0 3
36563: PPUSH
36564: CALL_OW 257
36568: PUSH
36569: LD_INT 3
36571: NONEQUAL
36572: IFFALSE 36613
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
36574: LD_ADDR_EXP 62
36578: PUSH
36579: LD_EXP 62
36583: PPUSH
36584: LD_VAR 0 2
36588: PPUSH
36589: LD_EXP 62
36593: PUSH
36594: LD_VAR 0 2
36598: ARRAY
36599: PUSH
36600: LD_VAR 0 3
36604: DIFF
36605: PPUSH
36606: CALL_OW 1
36610: ST_TO_ADDR
// continue ;
36611: GO 36556
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
36613: LD_VAR 0 3
36617: PPUSH
36618: CALL_OW 311
36622: NOT
36623: PUSH
36624: LD_VAR 0 3
36628: PUSH
36629: LD_EXP 53
36633: PUSH
36634: LD_VAR 0 2
36638: ARRAY
36639: PUSH
36640: LD_INT 1
36642: ARRAY
36643: IN
36644: NOT
36645: AND
36646: PUSH
36647: LD_VAR 0 3
36651: PUSH
36652: LD_EXP 53
36656: PUSH
36657: LD_VAR 0 2
36661: ARRAY
36662: PUSH
36663: LD_INT 2
36665: ARRAY
36666: IN
36667: NOT
36668: AND
36669: IFFALSE 36732
// begin if IsInUnit ( j ) then
36671: LD_VAR 0 3
36675: PPUSH
36676: CALL_OW 310
36680: IFFALSE 36693
// ComExitBuilding ( j ) else
36682: LD_VAR 0 3
36686: PPUSH
36687: CALL_OW 122
36691: GO 36732
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
36693: LD_VAR 0 3
36697: PPUSH
36698: LD_VAR 0 7
36702: PUSH
36703: LD_INT 1
36705: ARRAY
36706: PPUSH
36707: CALL 88227 0 2
36711: NOT
36712: IFFALSE 36732
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
36714: LD_VAR 0 3
36718: PPUSH
36719: LD_VAR 0 7
36723: PUSH
36724: LD_INT 1
36726: ARRAY
36727: PPUSH
36728: CALL_OW 129
// end ; end ;
36732: GO 36556
36734: POP
36735: POP
// end ;
36736: GO 36017
36738: POP
36739: POP
// end ;
36740: LD_VAR 0 1
36744: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
36745: LD_INT 0
36747: PPUSH
36748: PPUSH
36749: PPUSH
36750: PPUSH
36751: PPUSH
36752: PPUSH
36753: PPUSH
36754: PPUSH
36755: PPUSH
36756: PPUSH
36757: PPUSH
// if not mc_bases then
36758: LD_EXP 50
36762: NOT
36763: IFFALSE 36767
// exit ;
36765: GO 37569
// for i = 1 to mc_bases do
36767: LD_ADDR_VAR 0 2
36771: PUSH
36772: DOUBLE
36773: LD_INT 1
36775: DEC
36776: ST_TO_ADDR
36777: LD_EXP 50
36781: PUSH
36782: FOR_TO
36783: IFFALSE 37567
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
36785: LD_EXP 78
36789: PUSH
36790: LD_VAR 0 2
36794: ARRAY
36795: NOT
36796: PUSH
36797: LD_EXP 53
36801: PUSH
36802: LD_VAR 0 2
36806: ARRAY
36807: PUSH
36808: LD_INT 1
36810: ARRAY
36811: OR
36812: PUSH
36813: LD_EXP 53
36817: PUSH
36818: LD_VAR 0 2
36822: ARRAY
36823: PUSH
36824: LD_INT 2
36826: ARRAY
36827: OR
36828: PUSH
36829: LD_EXP 76
36833: PUSH
36834: LD_VAR 0 2
36838: ARRAY
36839: PPUSH
36840: LD_INT 1
36842: PPUSH
36843: CALL_OW 325
36847: NOT
36848: OR
36849: PUSH
36850: LD_EXP 73
36854: PUSH
36855: LD_VAR 0 2
36859: ARRAY
36860: OR
36861: IFFALSE 36865
// continue ;
36863: GO 36782
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
36865: LD_ADDR_VAR 0 8
36869: PUSH
36870: LD_EXP 50
36874: PUSH
36875: LD_VAR 0 2
36879: ARRAY
36880: PPUSH
36881: LD_INT 25
36883: PUSH
36884: LD_INT 4
36886: PUSH
36887: EMPTY
36888: LIST
36889: LIST
36890: PUSH
36891: LD_INT 50
36893: PUSH
36894: EMPTY
36895: LIST
36896: PUSH
36897: LD_INT 3
36899: PUSH
36900: LD_INT 60
36902: PUSH
36903: EMPTY
36904: LIST
36905: PUSH
36906: EMPTY
36907: LIST
36908: LIST
36909: PUSH
36910: EMPTY
36911: LIST
36912: LIST
36913: LIST
36914: PPUSH
36915: CALL_OW 72
36919: PUSH
36920: LD_EXP 54
36924: PUSH
36925: LD_VAR 0 2
36929: ARRAY
36930: DIFF
36931: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
36932: LD_ADDR_VAR 0 9
36936: PUSH
36937: LD_EXP 50
36941: PUSH
36942: LD_VAR 0 2
36946: ARRAY
36947: PPUSH
36948: LD_INT 2
36950: PUSH
36951: LD_INT 30
36953: PUSH
36954: LD_INT 0
36956: PUSH
36957: EMPTY
36958: LIST
36959: LIST
36960: PUSH
36961: LD_INT 30
36963: PUSH
36964: LD_INT 1
36966: PUSH
36967: EMPTY
36968: LIST
36969: LIST
36970: PUSH
36971: EMPTY
36972: LIST
36973: LIST
36974: LIST
36975: PPUSH
36976: CALL_OW 72
36980: ST_TO_ADDR
// if not tmp or not dep then
36981: LD_VAR 0 8
36985: NOT
36986: PUSH
36987: LD_VAR 0 9
36991: NOT
36992: OR
36993: IFFALSE 36997
// continue ;
36995: GO 36782
// side := GetSide ( tmp [ 1 ] ) ;
36997: LD_ADDR_VAR 0 11
37001: PUSH
37002: LD_VAR 0 8
37006: PUSH
37007: LD_INT 1
37009: ARRAY
37010: PPUSH
37011: CALL_OW 255
37015: ST_TO_ADDR
// dep := dep [ 1 ] ;
37016: LD_ADDR_VAR 0 9
37020: PUSH
37021: LD_VAR 0 9
37025: PUSH
37026: LD_INT 1
37028: ARRAY
37029: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
37030: LD_ADDR_VAR 0 7
37034: PUSH
37035: LD_EXP 78
37039: PUSH
37040: LD_VAR 0 2
37044: ARRAY
37045: PPUSH
37046: LD_INT 22
37048: PUSH
37049: LD_INT 0
37051: PUSH
37052: EMPTY
37053: LIST
37054: LIST
37055: PUSH
37056: LD_INT 25
37058: PUSH
37059: LD_INT 12
37061: PUSH
37062: EMPTY
37063: LIST
37064: LIST
37065: PUSH
37066: EMPTY
37067: LIST
37068: LIST
37069: PPUSH
37070: CALL_OW 70
37074: PUSH
37075: LD_INT 22
37077: PUSH
37078: LD_INT 0
37080: PUSH
37081: EMPTY
37082: LIST
37083: LIST
37084: PUSH
37085: LD_INT 25
37087: PUSH
37088: LD_INT 12
37090: PUSH
37091: EMPTY
37092: LIST
37093: LIST
37094: PUSH
37095: LD_INT 91
37097: PUSH
37098: LD_VAR 0 9
37102: PUSH
37103: LD_INT 20
37105: PUSH
37106: EMPTY
37107: LIST
37108: LIST
37109: LIST
37110: PUSH
37111: EMPTY
37112: LIST
37113: LIST
37114: LIST
37115: PPUSH
37116: CALL_OW 69
37120: UNION
37121: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
37122: LD_ADDR_VAR 0 10
37126: PUSH
37127: LD_EXP 78
37131: PUSH
37132: LD_VAR 0 2
37136: ARRAY
37137: PPUSH
37138: LD_INT 81
37140: PUSH
37141: LD_VAR 0 11
37145: PUSH
37146: EMPTY
37147: LIST
37148: LIST
37149: PPUSH
37150: CALL_OW 70
37154: ST_TO_ADDR
// if not apes or danger_at_area then
37155: LD_VAR 0 7
37159: NOT
37160: PUSH
37161: LD_VAR 0 10
37165: OR
37166: IFFALSE 37216
// begin if mc_taming [ i ] then
37168: LD_EXP 81
37172: PUSH
37173: LD_VAR 0 2
37177: ARRAY
37178: IFFALSE 37214
// begin MC_Reset ( i , 121 ) ;
37180: LD_VAR 0 2
37184: PPUSH
37185: LD_INT 121
37187: PPUSH
37188: CALL 22153 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
37192: LD_ADDR_EXP 81
37196: PUSH
37197: LD_EXP 81
37201: PPUSH
37202: LD_VAR 0 2
37206: PPUSH
37207: EMPTY
37208: PPUSH
37209: CALL_OW 1
37213: ST_TO_ADDR
// end ; continue ;
37214: GO 36782
// end ; for j in tmp do
37216: LD_ADDR_VAR 0 3
37220: PUSH
37221: LD_VAR 0 8
37225: PUSH
37226: FOR_IN
37227: IFFALSE 37563
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
37229: LD_VAR 0 3
37233: PUSH
37234: LD_EXP 81
37238: PUSH
37239: LD_VAR 0 2
37243: ARRAY
37244: IN
37245: NOT
37246: PUSH
37247: LD_EXP 81
37251: PUSH
37252: LD_VAR 0 2
37256: ARRAY
37257: PUSH
37258: LD_INT 3
37260: LESS
37261: AND
37262: IFFALSE 37320
// begin SetTag ( j , 121 ) ;
37264: LD_VAR 0 3
37268: PPUSH
37269: LD_INT 121
37271: PPUSH
37272: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
37276: LD_ADDR_EXP 81
37280: PUSH
37281: LD_EXP 81
37285: PPUSH
37286: LD_VAR 0 2
37290: PUSH
37291: LD_EXP 81
37295: PUSH
37296: LD_VAR 0 2
37300: ARRAY
37301: PUSH
37302: LD_INT 1
37304: PLUS
37305: PUSH
37306: EMPTY
37307: LIST
37308: LIST
37309: PPUSH
37310: LD_VAR 0 3
37314: PPUSH
37315: CALL 53831 0 3
37319: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
37320: LD_VAR 0 3
37324: PUSH
37325: LD_EXP 81
37329: PUSH
37330: LD_VAR 0 2
37334: ARRAY
37335: IN
37336: IFFALSE 37561
// begin if GetClass ( j ) <> 4 then
37338: LD_VAR 0 3
37342: PPUSH
37343: CALL_OW 257
37347: PUSH
37348: LD_INT 4
37350: NONEQUAL
37351: IFFALSE 37404
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
37353: LD_ADDR_EXP 81
37357: PUSH
37358: LD_EXP 81
37362: PPUSH
37363: LD_VAR 0 2
37367: PPUSH
37368: LD_EXP 81
37372: PUSH
37373: LD_VAR 0 2
37377: ARRAY
37378: PUSH
37379: LD_VAR 0 3
37383: DIFF
37384: PPUSH
37385: CALL_OW 1
37389: ST_TO_ADDR
// SetTag ( j , 0 ) ;
37390: LD_VAR 0 3
37394: PPUSH
37395: LD_INT 0
37397: PPUSH
37398: CALL_OW 109
// continue ;
37402: GO 37226
// end ; if IsInUnit ( j ) then
37404: LD_VAR 0 3
37408: PPUSH
37409: CALL_OW 310
37413: IFFALSE 37424
// ComExitBuilding ( j ) ;
37415: LD_VAR 0 3
37419: PPUSH
37420: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
37424: LD_ADDR_VAR 0 6
37428: PUSH
37429: LD_VAR 0 7
37433: PPUSH
37434: LD_VAR 0 3
37438: PPUSH
37439: CALL_OW 74
37443: ST_TO_ADDR
// if not ape then
37444: LD_VAR 0 6
37448: NOT
37449: IFFALSE 37453
// break ;
37451: GO 37563
// x := GetX ( ape ) ;
37453: LD_ADDR_VAR 0 4
37457: PUSH
37458: LD_VAR 0 6
37462: PPUSH
37463: CALL_OW 250
37467: ST_TO_ADDR
// y := GetY ( ape ) ;
37468: LD_ADDR_VAR 0 5
37472: PUSH
37473: LD_VAR 0 6
37477: PPUSH
37478: CALL_OW 251
37482: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
37483: LD_VAR 0 4
37487: PPUSH
37488: LD_VAR 0 5
37492: PPUSH
37493: CALL_OW 488
37497: NOT
37498: PUSH
37499: LD_VAR 0 11
37503: PPUSH
37504: LD_VAR 0 4
37508: PPUSH
37509: LD_VAR 0 5
37513: PPUSH
37514: LD_INT 20
37516: PPUSH
37517: CALL 54727 0 4
37521: PUSH
37522: LD_INT 4
37524: ARRAY
37525: OR
37526: IFFALSE 37530
// break ;
37528: GO 37563
// if not HasTask ( j ) then
37530: LD_VAR 0 3
37534: PPUSH
37535: CALL_OW 314
37539: NOT
37540: IFFALSE 37561
// ComTameXY ( j , x , y ) ;
37542: LD_VAR 0 3
37546: PPUSH
37547: LD_VAR 0 4
37551: PPUSH
37552: LD_VAR 0 5
37556: PPUSH
37557: CALL_OW 131
// end ; end ;
37561: GO 37226
37563: POP
37564: POP
// end ;
37565: GO 36782
37567: POP
37568: POP
// end ;
37569: LD_VAR 0 1
37573: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
37574: LD_INT 0
37576: PPUSH
37577: PPUSH
37578: PPUSH
37579: PPUSH
37580: PPUSH
37581: PPUSH
37582: PPUSH
37583: PPUSH
// if not mc_bases then
37584: LD_EXP 50
37588: NOT
37589: IFFALSE 37593
// exit ;
37591: GO 38219
// for i = 1 to mc_bases do
37593: LD_ADDR_VAR 0 2
37597: PUSH
37598: DOUBLE
37599: LD_INT 1
37601: DEC
37602: ST_TO_ADDR
37603: LD_EXP 50
37607: PUSH
37608: FOR_TO
37609: IFFALSE 38217
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
37611: LD_EXP 79
37615: PUSH
37616: LD_VAR 0 2
37620: ARRAY
37621: NOT
37622: PUSH
37623: LD_EXP 79
37627: PUSH
37628: LD_VAR 0 2
37632: ARRAY
37633: PPUSH
37634: LD_INT 25
37636: PUSH
37637: LD_INT 12
37639: PUSH
37640: EMPTY
37641: LIST
37642: LIST
37643: PPUSH
37644: CALL_OW 72
37648: NOT
37649: OR
37650: IFFALSE 37654
// continue ;
37652: GO 37608
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
37654: LD_ADDR_VAR 0 5
37658: PUSH
37659: LD_EXP 79
37663: PUSH
37664: LD_VAR 0 2
37668: ARRAY
37669: PUSH
37670: LD_INT 1
37672: ARRAY
37673: PPUSH
37674: CALL_OW 255
37678: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
37679: LD_VAR 0 5
37683: PPUSH
37684: LD_INT 2
37686: PPUSH
37687: CALL_OW 325
37691: IFFALSE 37944
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
37693: LD_ADDR_VAR 0 4
37697: PUSH
37698: LD_EXP 79
37702: PUSH
37703: LD_VAR 0 2
37707: ARRAY
37708: PPUSH
37709: LD_INT 25
37711: PUSH
37712: LD_INT 16
37714: PUSH
37715: EMPTY
37716: LIST
37717: LIST
37718: PPUSH
37719: CALL_OW 72
37723: ST_TO_ADDR
// if tmp < 6 then
37724: LD_VAR 0 4
37728: PUSH
37729: LD_INT 6
37731: LESS
37732: IFFALSE 37944
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
37734: LD_ADDR_VAR 0 6
37738: PUSH
37739: LD_EXP 50
37743: PUSH
37744: LD_VAR 0 2
37748: ARRAY
37749: PPUSH
37750: LD_INT 2
37752: PUSH
37753: LD_INT 30
37755: PUSH
37756: LD_INT 0
37758: PUSH
37759: EMPTY
37760: LIST
37761: LIST
37762: PUSH
37763: LD_INT 30
37765: PUSH
37766: LD_INT 1
37768: PUSH
37769: EMPTY
37770: LIST
37771: LIST
37772: PUSH
37773: EMPTY
37774: LIST
37775: LIST
37776: LIST
37777: PPUSH
37778: CALL_OW 72
37782: ST_TO_ADDR
// if depot then
37783: LD_VAR 0 6
37787: IFFALSE 37944
// begin selected := 0 ;
37789: LD_ADDR_VAR 0 7
37793: PUSH
37794: LD_INT 0
37796: ST_TO_ADDR
// for j in depot do
37797: LD_ADDR_VAR 0 3
37801: PUSH
37802: LD_VAR 0 6
37806: PUSH
37807: FOR_IN
37808: IFFALSE 37839
// begin if UnitsInside ( j ) < 6 then
37810: LD_VAR 0 3
37814: PPUSH
37815: CALL_OW 313
37819: PUSH
37820: LD_INT 6
37822: LESS
37823: IFFALSE 37837
// begin selected := j ;
37825: LD_ADDR_VAR 0 7
37829: PUSH
37830: LD_VAR 0 3
37834: ST_TO_ADDR
// break ;
37835: GO 37839
// end ; end ;
37837: GO 37807
37839: POP
37840: POP
// if selected then
37841: LD_VAR 0 7
37845: IFFALSE 37944
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
37847: LD_ADDR_VAR 0 3
37851: PUSH
37852: LD_EXP 79
37856: PUSH
37857: LD_VAR 0 2
37861: ARRAY
37862: PPUSH
37863: LD_INT 25
37865: PUSH
37866: LD_INT 12
37868: PUSH
37869: EMPTY
37870: LIST
37871: LIST
37872: PPUSH
37873: CALL_OW 72
37877: PUSH
37878: FOR_IN
37879: IFFALSE 37942
// if not HasTask ( j ) then
37881: LD_VAR 0 3
37885: PPUSH
37886: CALL_OW 314
37890: NOT
37891: IFFALSE 37940
// begin if not IsInUnit ( j ) then
37893: LD_VAR 0 3
37897: PPUSH
37898: CALL_OW 310
37902: NOT
37903: IFFALSE 37919
// ComEnterUnit ( j , selected ) ;
37905: LD_VAR 0 3
37909: PPUSH
37910: LD_VAR 0 7
37914: PPUSH
37915: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
37919: LD_VAR 0 3
37923: PPUSH
37924: LD_INT 16
37926: PPUSH
37927: CALL_OW 183
// AddComExitBuilding ( j ) ;
37931: LD_VAR 0 3
37935: PPUSH
37936: CALL_OW 182
// end ;
37940: GO 37878
37942: POP
37943: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
37944: LD_VAR 0 5
37948: PPUSH
37949: LD_INT 11
37951: PPUSH
37952: CALL_OW 325
37956: IFFALSE 38215
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
37958: LD_ADDR_VAR 0 4
37962: PUSH
37963: LD_EXP 79
37967: PUSH
37968: LD_VAR 0 2
37972: ARRAY
37973: PPUSH
37974: LD_INT 25
37976: PUSH
37977: LD_INT 16
37979: PUSH
37980: EMPTY
37981: LIST
37982: LIST
37983: PPUSH
37984: CALL_OW 72
37988: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
37989: LD_VAR 0 4
37993: PUSH
37994: LD_INT 6
37996: GREATEREQUAL
37997: PUSH
37998: LD_VAR 0 5
38002: PPUSH
38003: LD_INT 2
38005: PPUSH
38006: CALL_OW 325
38010: NOT
38011: OR
38012: IFFALSE 38215
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
38014: LD_ADDR_VAR 0 8
38018: PUSH
38019: LD_EXP 50
38023: PUSH
38024: LD_VAR 0 2
38028: ARRAY
38029: PPUSH
38030: LD_INT 2
38032: PUSH
38033: LD_INT 30
38035: PUSH
38036: LD_INT 4
38038: PUSH
38039: EMPTY
38040: LIST
38041: LIST
38042: PUSH
38043: LD_INT 30
38045: PUSH
38046: LD_INT 5
38048: PUSH
38049: EMPTY
38050: LIST
38051: LIST
38052: PUSH
38053: EMPTY
38054: LIST
38055: LIST
38056: LIST
38057: PPUSH
38058: CALL_OW 72
38062: ST_TO_ADDR
// if barracks then
38063: LD_VAR 0 8
38067: IFFALSE 38215
// begin selected := 0 ;
38069: LD_ADDR_VAR 0 7
38073: PUSH
38074: LD_INT 0
38076: ST_TO_ADDR
// for j in barracks do
38077: LD_ADDR_VAR 0 3
38081: PUSH
38082: LD_VAR 0 8
38086: PUSH
38087: FOR_IN
38088: IFFALSE 38119
// begin if UnitsInside ( j ) < 6 then
38090: LD_VAR 0 3
38094: PPUSH
38095: CALL_OW 313
38099: PUSH
38100: LD_INT 6
38102: LESS
38103: IFFALSE 38117
// begin selected := j ;
38105: LD_ADDR_VAR 0 7
38109: PUSH
38110: LD_VAR 0 3
38114: ST_TO_ADDR
// break ;
38115: GO 38119
// end ; end ;
38117: GO 38087
38119: POP
38120: POP
// if selected then
38121: LD_VAR 0 7
38125: IFFALSE 38215
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
38127: LD_ADDR_VAR 0 3
38131: PUSH
38132: LD_EXP 79
38136: PUSH
38137: LD_VAR 0 2
38141: ARRAY
38142: PPUSH
38143: LD_INT 25
38145: PUSH
38146: LD_INT 12
38148: PUSH
38149: EMPTY
38150: LIST
38151: LIST
38152: PPUSH
38153: CALL_OW 72
38157: PUSH
38158: FOR_IN
38159: IFFALSE 38213
// if not IsInUnit ( j ) and not HasTask ( j ) then
38161: LD_VAR 0 3
38165: PPUSH
38166: CALL_OW 310
38170: NOT
38171: PUSH
38172: LD_VAR 0 3
38176: PPUSH
38177: CALL_OW 314
38181: NOT
38182: AND
38183: IFFALSE 38211
// begin ComEnterUnit ( j , selected ) ;
38185: LD_VAR 0 3
38189: PPUSH
38190: LD_VAR 0 7
38194: PPUSH
38195: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
38199: LD_VAR 0 3
38203: PPUSH
38204: LD_INT 15
38206: PPUSH
38207: CALL_OW 183
// end ;
38211: GO 38158
38213: POP
38214: POP
// end ; end ; end ; end ; end ;
38215: GO 37608
38217: POP
38218: POP
// end ;
38219: LD_VAR 0 1
38223: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
38224: LD_INT 0
38226: PPUSH
38227: PPUSH
38228: PPUSH
38229: PPUSH
// if not mc_bases then
38230: LD_EXP 50
38234: NOT
38235: IFFALSE 38239
// exit ;
38237: GO 38417
// for i = 1 to mc_bases do
38239: LD_ADDR_VAR 0 2
38243: PUSH
38244: DOUBLE
38245: LD_INT 1
38247: DEC
38248: ST_TO_ADDR
38249: LD_EXP 50
38253: PUSH
38254: FOR_TO
38255: IFFALSE 38415
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
38257: LD_ADDR_VAR 0 4
38261: PUSH
38262: LD_EXP 50
38266: PUSH
38267: LD_VAR 0 2
38271: ARRAY
38272: PPUSH
38273: LD_INT 25
38275: PUSH
38276: LD_INT 9
38278: PUSH
38279: EMPTY
38280: LIST
38281: LIST
38282: PPUSH
38283: CALL_OW 72
38287: ST_TO_ADDR
// if not tmp then
38288: LD_VAR 0 4
38292: NOT
38293: IFFALSE 38297
// continue ;
38295: GO 38254
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
38297: LD_EXP 76
38301: PUSH
38302: LD_VAR 0 2
38306: ARRAY
38307: PPUSH
38308: LD_INT 29
38310: PPUSH
38311: CALL_OW 325
38315: NOT
38316: PUSH
38317: LD_EXP 76
38321: PUSH
38322: LD_VAR 0 2
38326: ARRAY
38327: PPUSH
38328: LD_INT 28
38330: PPUSH
38331: CALL_OW 325
38335: NOT
38336: AND
38337: IFFALSE 38341
// continue ;
38339: GO 38254
// for j in tmp do
38341: LD_ADDR_VAR 0 3
38345: PUSH
38346: LD_VAR 0 4
38350: PUSH
38351: FOR_IN
38352: IFFALSE 38411
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
38354: LD_VAR 0 3
38358: PUSH
38359: LD_EXP 53
38363: PUSH
38364: LD_VAR 0 2
38368: ARRAY
38369: PUSH
38370: LD_INT 1
38372: ARRAY
38373: IN
38374: NOT
38375: PUSH
38376: LD_VAR 0 3
38380: PUSH
38381: LD_EXP 53
38385: PUSH
38386: LD_VAR 0 2
38390: ARRAY
38391: PUSH
38392: LD_INT 2
38394: ARRAY
38395: IN
38396: NOT
38397: AND
38398: IFFALSE 38409
// ComSpaceTimeShoot ( j ) ;
38400: LD_VAR 0 3
38404: PPUSH
38405: CALL 49641 0 1
38409: GO 38351
38411: POP
38412: POP
// end ;
38413: GO 38254
38415: POP
38416: POP
// end ;
38417: LD_VAR 0 1
38421: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
38422: LD_INT 0
38424: PPUSH
38425: PPUSH
38426: PPUSH
38427: PPUSH
38428: PPUSH
38429: PPUSH
38430: PPUSH
38431: PPUSH
38432: PPUSH
// if not mc_bases then
38433: LD_EXP 50
38437: NOT
38438: IFFALSE 38442
// exit ;
38440: GO 39064
// for i = 1 to mc_bases do
38442: LD_ADDR_VAR 0 2
38446: PUSH
38447: DOUBLE
38448: LD_INT 1
38450: DEC
38451: ST_TO_ADDR
38452: LD_EXP 50
38456: PUSH
38457: FOR_TO
38458: IFFALSE 39062
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
38460: LD_EXP 85
38464: PUSH
38465: LD_VAR 0 2
38469: ARRAY
38470: NOT
38471: PUSH
38472: LD_INT 38
38474: PPUSH
38475: LD_EXP 76
38479: PUSH
38480: LD_VAR 0 2
38484: ARRAY
38485: PPUSH
38486: CALL_OW 321
38490: PUSH
38491: LD_INT 2
38493: NONEQUAL
38494: OR
38495: IFFALSE 38499
// continue ;
38497: GO 38457
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
38499: LD_ADDR_VAR 0 8
38503: PUSH
38504: LD_EXP 50
38508: PUSH
38509: LD_VAR 0 2
38513: ARRAY
38514: PPUSH
38515: LD_INT 30
38517: PUSH
38518: LD_INT 34
38520: PUSH
38521: EMPTY
38522: LIST
38523: LIST
38524: PPUSH
38525: CALL_OW 72
38529: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
38530: LD_ADDR_VAR 0 9
38534: PUSH
38535: LD_EXP 50
38539: PUSH
38540: LD_VAR 0 2
38544: ARRAY
38545: PPUSH
38546: LD_INT 25
38548: PUSH
38549: LD_INT 4
38551: PUSH
38552: EMPTY
38553: LIST
38554: LIST
38555: PPUSH
38556: CALL_OW 72
38560: PPUSH
38561: LD_INT 0
38563: PPUSH
38564: CALL 83743 0 2
38568: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
38569: LD_VAR 0 9
38573: NOT
38574: PUSH
38575: LD_VAR 0 8
38579: NOT
38580: OR
38581: PUSH
38582: LD_EXP 50
38586: PUSH
38587: LD_VAR 0 2
38591: ARRAY
38592: PPUSH
38593: LD_INT 124
38595: PPUSH
38596: CALL 83743 0 2
38600: OR
38601: IFFALSE 38605
// continue ;
38603: GO 38457
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
38605: LD_EXP 86
38609: PUSH
38610: LD_VAR 0 2
38614: ARRAY
38615: PUSH
38616: LD_EXP 85
38620: PUSH
38621: LD_VAR 0 2
38625: ARRAY
38626: LESS
38627: PUSH
38628: LD_EXP 86
38632: PUSH
38633: LD_VAR 0 2
38637: ARRAY
38638: PUSH
38639: LD_VAR 0 8
38643: LESS
38644: AND
38645: IFFALSE 39060
// begin tmp := sci [ 1 ] ;
38647: LD_ADDR_VAR 0 7
38651: PUSH
38652: LD_VAR 0 9
38656: PUSH
38657: LD_INT 1
38659: ARRAY
38660: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
38661: LD_VAR 0 7
38665: PPUSH
38666: LD_INT 124
38668: PPUSH
38669: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
38673: LD_ADDR_VAR 0 3
38677: PUSH
38678: DOUBLE
38679: LD_EXP 85
38683: PUSH
38684: LD_VAR 0 2
38688: ARRAY
38689: INC
38690: ST_TO_ADDR
38691: LD_EXP 85
38695: PUSH
38696: LD_VAR 0 2
38700: ARRAY
38701: PUSH
38702: FOR_DOWNTO
38703: IFFALSE 39046
// begin if IsInUnit ( tmp ) then
38705: LD_VAR 0 7
38709: PPUSH
38710: CALL_OW 310
38714: IFFALSE 38725
// ComExitBuilding ( tmp ) ;
38716: LD_VAR 0 7
38720: PPUSH
38721: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
38725: LD_INT 35
38727: PPUSH
38728: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
38732: LD_VAR 0 7
38736: PPUSH
38737: CALL_OW 310
38741: NOT
38742: PUSH
38743: LD_VAR 0 7
38747: PPUSH
38748: CALL_OW 314
38752: NOT
38753: AND
38754: IFFALSE 38725
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
38756: LD_ADDR_VAR 0 6
38760: PUSH
38761: LD_VAR 0 7
38765: PPUSH
38766: CALL_OW 250
38770: PUSH
38771: LD_VAR 0 7
38775: PPUSH
38776: CALL_OW 251
38780: PUSH
38781: EMPTY
38782: LIST
38783: LIST
38784: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
38785: LD_INT 35
38787: PPUSH
38788: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
38792: LD_ADDR_VAR 0 4
38796: PUSH
38797: LD_EXP 85
38801: PUSH
38802: LD_VAR 0 2
38806: ARRAY
38807: PUSH
38808: LD_VAR 0 3
38812: ARRAY
38813: PUSH
38814: LD_INT 1
38816: ARRAY
38817: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
38818: LD_ADDR_VAR 0 5
38822: PUSH
38823: LD_EXP 85
38827: PUSH
38828: LD_VAR 0 2
38832: ARRAY
38833: PUSH
38834: LD_VAR 0 3
38838: ARRAY
38839: PUSH
38840: LD_INT 2
38842: ARRAY
38843: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
38844: LD_VAR 0 7
38848: PPUSH
38849: LD_INT 10
38851: PPUSH
38852: CALL 56428 0 2
38856: PUSH
38857: LD_INT 4
38859: ARRAY
38860: IFFALSE 38898
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
38862: LD_VAR 0 7
38866: PPUSH
38867: LD_VAR 0 6
38871: PUSH
38872: LD_INT 1
38874: ARRAY
38875: PPUSH
38876: LD_VAR 0 6
38880: PUSH
38881: LD_INT 2
38883: ARRAY
38884: PPUSH
38885: CALL_OW 111
// wait ( 0 0$10 ) ;
38889: LD_INT 350
38891: PPUSH
38892: CALL_OW 67
// end else
38896: GO 38924
// begin ComMoveXY ( tmp , x , y ) ;
38898: LD_VAR 0 7
38902: PPUSH
38903: LD_VAR 0 4
38907: PPUSH
38908: LD_VAR 0 5
38912: PPUSH
38913: CALL_OW 111
// wait ( 0 0$3 ) ;
38917: LD_INT 105
38919: PPUSH
38920: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
38924: LD_VAR 0 7
38928: PPUSH
38929: LD_VAR 0 4
38933: PPUSH
38934: LD_VAR 0 5
38938: PPUSH
38939: CALL_OW 307
38943: IFFALSE 38785
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
38945: LD_VAR 0 7
38949: PPUSH
38950: LD_VAR 0 4
38954: PPUSH
38955: LD_VAR 0 5
38959: PPUSH
38960: LD_VAR 0 8
38964: PUSH
38965: LD_VAR 0 3
38969: ARRAY
38970: PPUSH
38971: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
38975: LD_INT 35
38977: PPUSH
38978: CALL_OW 67
// until not HasTask ( tmp ) ;
38982: LD_VAR 0 7
38986: PPUSH
38987: CALL_OW 314
38991: NOT
38992: IFFALSE 38975
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
38994: LD_ADDR_EXP 86
38998: PUSH
38999: LD_EXP 86
39003: PPUSH
39004: LD_VAR 0 2
39008: PUSH
39009: LD_EXP 86
39013: PUSH
39014: LD_VAR 0 2
39018: ARRAY
39019: PUSH
39020: LD_INT 1
39022: PLUS
39023: PUSH
39024: EMPTY
39025: LIST
39026: LIST
39027: PPUSH
39028: LD_VAR 0 8
39032: PUSH
39033: LD_VAR 0 3
39037: ARRAY
39038: PPUSH
39039: CALL 53831 0 3
39043: ST_TO_ADDR
// end ;
39044: GO 38702
39046: POP
39047: POP
// MC_Reset ( i , 124 ) ;
39048: LD_VAR 0 2
39052: PPUSH
39053: LD_INT 124
39055: PPUSH
39056: CALL 22153 0 2
// end ; end ;
39060: GO 38457
39062: POP
39063: POP
// end ;
39064: LD_VAR 0 1
39068: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
39069: LD_INT 0
39071: PPUSH
39072: PPUSH
39073: PPUSH
// if not mc_bases then
39074: LD_EXP 50
39078: NOT
39079: IFFALSE 39083
// exit ;
39081: GO 39689
// for i = 1 to mc_bases do
39083: LD_ADDR_VAR 0 2
39087: PUSH
39088: DOUBLE
39089: LD_INT 1
39091: DEC
39092: ST_TO_ADDR
39093: LD_EXP 50
39097: PUSH
39098: FOR_TO
39099: IFFALSE 39687
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
39101: LD_ADDR_VAR 0 3
39105: PUSH
39106: LD_EXP 50
39110: PUSH
39111: LD_VAR 0 2
39115: ARRAY
39116: PPUSH
39117: LD_INT 25
39119: PUSH
39120: LD_INT 4
39122: PUSH
39123: EMPTY
39124: LIST
39125: LIST
39126: PPUSH
39127: CALL_OW 72
39131: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
39132: LD_VAR 0 3
39136: NOT
39137: PUSH
39138: LD_EXP 87
39142: PUSH
39143: LD_VAR 0 2
39147: ARRAY
39148: NOT
39149: OR
39150: PUSH
39151: LD_EXP 50
39155: PUSH
39156: LD_VAR 0 2
39160: ARRAY
39161: PPUSH
39162: LD_INT 2
39164: PUSH
39165: LD_INT 30
39167: PUSH
39168: LD_INT 0
39170: PUSH
39171: EMPTY
39172: LIST
39173: LIST
39174: PUSH
39175: LD_INT 30
39177: PUSH
39178: LD_INT 1
39180: PUSH
39181: EMPTY
39182: LIST
39183: LIST
39184: PUSH
39185: EMPTY
39186: LIST
39187: LIST
39188: LIST
39189: PPUSH
39190: CALL_OW 72
39194: NOT
39195: OR
39196: IFFALSE 39246
// begin if mc_deposits_finder [ i ] then
39198: LD_EXP 88
39202: PUSH
39203: LD_VAR 0 2
39207: ARRAY
39208: IFFALSE 39244
// begin MC_Reset ( i , 125 ) ;
39210: LD_VAR 0 2
39214: PPUSH
39215: LD_INT 125
39217: PPUSH
39218: CALL 22153 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
39222: LD_ADDR_EXP 88
39226: PUSH
39227: LD_EXP 88
39231: PPUSH
39232: LD_VAR 0 2
39236: PPUSH
39237: EMPTY
39238: PPUSH
39239: CALL_OW 1
39243: ST_TO_ADDR
// end ; continue ;
39244: GO 39098
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
39246: LD_EXP 87
39250: PUSH
39251: LD_VAR 0 2
39255: ARRAY
39256: PUSH
39257: LD_INT 1
39259: ARRAY
39260: PUSH
39261: LD_INT 3
39263: ARRAY
39264: PUSH
39265: LD_INT 1
39267: EQUAL
39268: PUSH
39269: LD_INT 20
39271: PPUSH
39272: LD_EXP 76
39276: PUSH
39277: LD_VAR 0 2
39281: ARRAY
39282: PPUSH
39283: CALL_OW 321
39287: PUSH
39288: LD_INT 2
39290: NONEQUAL
39291: AND
39292: IFFALSE 39342
// begin if mc_deposits_finder [ i ] then
39294: LD_EXP 88
39298: PUSH
39299: LD_VAR 0 2
39303: ARRAY
39304: IFFALSE 39340
// begin MC_Reset ( i , 125 ) ;
39306: LD_VAR 0 2
39310: PPUSH
39311: LD_INT 125
39313: PPUSH
39314: CALL 22153 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
39318: LD_ADDR_EXP 88
39322: PUSH
39323: LD_EXP 88
39327: PPUSH
39328: LD_VAR 0 2
39332: PPUSH
39333: EMPTY
39334: PPUSH
39335: CALL_OW 1
39339: ST_TO_ADDR
// end ; continue ;
39340: GO 39098
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
39342: LD_EXP 87
39346: PUSH
39347: LD_VAR 0 2
39351: ARRAY
39352: PUSH
39353: LD_INT 1
39355: ARRAY
39356: PUSH
39357: LD_INT 1
39359: ARRAY
39360: PPUSH
39361: LD_EXP 87
39365: PUSH
39366: LD_VAR 0 2
39370: ARRAY
39371: PUSH
39372: LD_INT 1
39374: ARRAY
39375: PUSH
39376: LD_INT 2
39378: ARRAY
39379: PPUSH
39380: LD_EXP 76
39384: PUSH
39385: LD_VAR 0 2
39389: ARRAY
39390: PPUSH
39391: CALL_OW 440
39395: IFFALSE 39438
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
39397: LD_ADDR_EXP 87
39401: PUSH
39402: LD_EXP 87
39406: PPUSH
39407: LD_VAR 0 2
39411: PPUSH
39412: LD_EXP 87
39416: PUSH
39417: LD_VAR 0 2
39421: ARRAY
39422: PPUSH
39423: LD_INT 1
39425: PPUSH
39426: CALL_OW 3
39430: PPUSH
39431: CALL_OW 1
39435: ST_TO_ADDR
39436: GO 39685
// begin if not mc_deposits_finder [ i ] then
39438: LD_EXP 88
39442: PUSH
39443: LD_VAR 0 2
39447: ARRAY
39448: NOT
39449: IFFALSE 39501
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
39451: LD_ADDR_EXP 88
39455: PUSH
39456: LD_EXP 88
39460: PPUSH
39461: LD_VAR 0 2
39465: PPUSH
39466: LD_VAR 0 3
39470: PUSH
39471: LD_INT 1
39473: ARRAY
39474: PUSH
39475: EMPTY
39476: LIST
39477: PPUSH
39478: CALL_OW 1
39482: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
39483: LD_VAR 0 3
39487: PUSH
39488: LD_INT 1
39490: ARRAY
39491: PPUSH
39492: LD_INT 125
39494: PPUSH
39495: CALL_OW 109
// end else
39499: GO 39685
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
39501: LD_EXP 88
39505: PUSH
39506: LD_VAR 0 2
39510: ARRAY
39511: PUSH
39512: LD_INT 1
39514: ARRAY
39515: PPUSH
39516: CALL_OW 310
39520: IFFALSE 39543
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
39522: LD_EXP 88
39526: PUSH
39527: LD_VAR 0 2
39531: ARRAY
39532: PUSH
39533: LD_INT 1
39535: ARRAY
39536: PPUSH
39537: CALL_OW 122
39541: GO 39685
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
39543: LD_EXP 88
39547: PUSH
39548: LD_VAR 0 2
39552: ARRAY
39553: PUSH
39554: LD_INT 1
39556: ARRAY
39557: PPUSH
39558: CALL_OW 314
39562: NOT
39563: PUSH
39564: LD_EXP 88
39568: PUSH
39569: LD_VAR 0 2
39573: ARRAY
39574: PUSH
39575: LD_INT 1
39577: ARRAY
39578: PPUSH
39579: LD_EXP 87
39583: PUSH
39584: LD_VAR 0 2
39588: ARRAY
39589: PUSH
39590: LD_INT 1
39592: ARRAY
39593: PUSH
39594: LD_INT 1
39596: ARRAY
39597: PPUSH
39598: LD_EXP 87
39602: PUSH
39603: LD_VAR 0 2
39607: ARRAY
39608: PUSH
39609: LD_INT 1
39611: ARRAY
39612: PUSH
39613: LD_INT 2
39615: ARRAY
39616: PPUSH
39617: CALL_OW 297
39621: PUSH
39622: LD_INT 6
39624: GREATER
39625: AND
39626: IFFALSE 39685
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
39628: LD_EXP 88
39632: PUSH
39633: LD_VAR 0 2
39637: ARRAY
39638: PUSH
39639: LD_INT 1
39641: ARRAY
39642: PPUSH
39643: LD_EXP 87
39647: PUSH
39648: LD_VAR 0 2
39652: ARRAY
39653: PUSH
39654: LD_INT 1
39656: ARRAY
39657: PUSH
39658: LD_INT 1
39660: ARRAY
39661: PPUSH
39662: LD_EXP 87
39666: PUSH
39667: LD_VAR 0 2
39671: ARRAY
39672: PUSH
39673: LD_INT 1
39675: ARRAY
39676: PUSH
39677: LD_INT 2
39679: ARRAY
39680: PPUSH
39681: CALL_OW 111
// end ; end ; end ;
39685: GO 39098
39687: POP
39688: POP
// end ;
39689: LD_VAR 0 1
39693: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
39694: LD_INT 0
39696: PPUSH
39697: PPUSH
39698: PPUSH
39699: PPUSH
39700: PPUSH
39701: PPUSH
39702: PPUSH
39703: PPUSH
39704: PPUSH
39705: PPUSH
39706: PPUSH
// if not mc_bases then
39707: LD_EXP 50
39711: NOT
39712: IFFALSE 39716
// exit ;
39714: GO 40656
// for i = 1 to mc_bases do
39716: LD_ADDR_VAR 0 2
39720: PUSH
39721: DOUBLE
39722: LD_INT 1
39724: DEC
39725: ST_TO_ADDR
39726: LD_EXP 50
39730: PUSH
39731: FOR_TO
39732: IFFALSE 40654
// begin if not mc_bases [ i ] or mc_scan [ i ] then
39734: LD_EXP 50
39738: PUSH
39739: LD_VAR 0 2
39743: ARRAY
39744: NOT
39745: PUSH
39746: LD_EXP 73
39750: PUSH
39751: LD_VAR 0 2
39755: ARRAY
39756: OR
39757: IFFALSE 39761
// continue ;
39759: GO 39731
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
39761: LD_ADDR_VAR 0 7
39765: PUSH
39766: LD_EXP 50
39770: PUSH
39771: LD_VAR 0 2
39775: ARRAY
39776: PUSH
39777: LD_INT 1
39779: ARRAY
39780: PPUSH
39781: CALL_OW 248
39785: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
39786: LD_VAR 0 7
39790: PUSH
39791: LD_INT 3
39793: EQUAL
39794: PUSH
39795: LD_EXP 69
39799: PUSH
39800: LD_VAR 0 2
39804: ARRAY
39805: PUSH
39806: LD_EXP 72
39810: PUSH
39811: LD_VAR 0 2
39815: ARRAY
39816: UNION
39817: PPUSH
39818: LD_INT 33
39820: PUSH
39821: LD_INT 2
39823: PUSH
39824: EMPTY
39825: LIST
39826: LIST
39827: PPUSH
39828: CALL_OW 72
39832: NOT
39833: OR
39834: IFFALSE 39838
// continue ;
39836: GO 39731
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
39838: LD_ADDR_VAR 0 9
39842: PUSH
39843: LD_EXP 50
39847: PUSH
39848: LD_VAR 0 2
39852: ARRAY
39853: PPUSH
39854: LD_INT 30
39856: PUSH
39857: LD_INT 36
39859: PUSH
39860: EMPTY
39861: LIST
39862: LIST
39863: PPUSH
39864: CALL_OW 72
39868: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
39869: LD_ADDR_VAR 0 10
39873: PUSH
39874: LD_EXP 69
39878: PUSH
39879: LD_VAR 0 2
39883: ARRAY
39884: PPUSH
39885: LD_INT 34
39887: PUSH
39888: LD_INT 31
39890: PUSH
39891: EMPTY
39892: LIST
39893: LIST
39894: PPUSH
39895: CALL_OW 72
39899: ST_TO_ADDR
// if not cts and not mcts then
39900: LD_VAR 0 9
39904: NOT
39905: PUSH
39906: LD_VAR 0 10
39910: NOT
39911: AND
39912: IFFALSE 39916
// continue ;
39914: GO 39731
// x := cts ;
39916: LD_ADDR_VAR 0 11
39920: PUSH
39921: LD_VAR 0 9
39925: ST_TO_ADDR
// if not x then
39926: LD_VAR 0 11
39930: NOT
39931: IFFALSE 39943
// x := mcts ;
39933: LD_ADDR_VAR 0 11
39937: PUSH
39938: LD_VAR 0 10
39942: ST_TO_ADDR
// if not x then
39943: LD_VAR 0 11
39947: NOT
39948: IFFALSE 39952
// continue ;
39950: GO 39731
// if mc_remote_driver [ i ] then
39952: LD_EXP 90
39956: PUSH
39957: LD_VAR 0 2
39961: ARRAY
39962: IFFALSE 40349
// for j in mc_remote_driver [ i ] do
39964: LD_ADDR_VAR 0 3
39968: PUSH
39969: LD_EXP 90
39973: PUSH
39974: LD_VAR 0 2
39978: ARRAY
39979: PUSH
39980: FOR_IN
39981: IFFALSE 40347
// begin if GetClass ( j ) <> 3 then
39983: LD_VAR 0 3
39987: PPUSH
39988: CALL_OW 257
39992: PUSH
39993: LD_INT 3
39995: NONEQUAL
39996: IFFALSE 40049
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
39998: LD_ADDR_EXP 90
40002: PUSH
40003: LD_EXP 90
40007: PPUSH
40008: LD_VAR 0 2
40012: PPUSH
40013: LD_EXP 90
40017: PUSH
40018: LD_VAR 0 2
40022: ARRAY
40023: PUSH
40024: LD_VAR 0 3
40028: DIFF
40029: PPUSH
40030: CALL_OW 1
40034: ST_TO_ADDR
// SetTag ( j , 0 ) ;
40035: LD_VAR 0 3
40039: PPUSH
40040: LD_INT 0
40042: PPUSH
40043: CALL_OW 109
// continue ;
40047: GO 39980
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
40049: LD_EXP 69
40053: PUSH
40054: LD_VAR 0 2
40058: ARRAY
40059: PPUSH
40060: LD_INT 34
40062: PUSH
40063: LD_INT 31
40065: PUSH
40066: EMPTY
40067: LIST
40068: LIST
40069: PUSH
40070: LD_INT 58
40072: PUSH
40073: EMPTY
40074: LIST
40075: PUSH
40076: EMPTY
40077: LIST
40078: LIST
40079: PPUSH
40080: CALL_OW 72
40084: PUSH
40085: LD_VAR 0 3
40089: PPUSH
40090: CALL 83778 0 1
40094: NOT
40095: AND
40096: IFFALSE 40167
// begin if IsInUnit ( j ) then
40098: LD_VAR 0 3
40102: PPUSH
40103: CALL_OW 310
40107: IFFALSE 40118
// ComExitBuilding ( j ) ;
40109: LD_VAR 0 3
40113: PPUSH
40114: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
40118: LD_VAR 0 3
40122: PPUSH
40123: LD_EXP 69
40127: PUSH
40128: LD_VAR 0 2
40132: ARRAY
40133: PPUSH
40134: LD_INT 34
40136: PUSH
40137: LD_INT 31
40139: PUSH
40140: EMPTY
40141: LIST
40142: LIST
40143: PUSH
40144: LD_INT 58
40146: PUSH
40147: EMPTY
40148: LIST
40149: PUSH
40150: EMPTY
40151: LIST
40152: LIST
40153: PPUSH
40154: CALL_OW 72
40158: PUSH
40159: LD_INT 1
40161: ARRAY
40162: PPUSH
40163: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
40167: LD_VAR 0 3
40171: PPUSH
40172: CALL_OW 310
40176: NOT
40177: PUSH
40178: LD_VAR 0 3
40182: PPUSH
40183: CALL_OW 310
40187: PPUSH
40188: CALL_OW 266
40192: PUSH
40193: LD_INT 36
40195: NONEQUAL
40196: PUSH
40197: LD_VAR 0 3
40201: PPUSH
40202: CALL 83778 0 1
40206: NOT
40207: AND
40208: OR
40209: IFFALSE 40345
// begin if IsInUnit ( j ) then
40211: LD_VAR 0 3
40215: PPUSH
40216: CALL_OW 310
40220: IFFALSE 40231
// ComExitBuilding ( j ) ;
40222: LD_VAR 0 3
40226: PPUSH
40227: CALL_OW 122
// ct := 0 ;
40231: LD_ADDR_VAR 0 8
40235: PUSH
40236: LD_INT 0
40238: ST_TO_ADDR
// for k in x do
40239: LD_ADDR_VAR 0 4
40243: PUSH
40244: LD_VAR 0 11
40248: PUSH
40249: FOR_IN
40250: IFFALSE 40323
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
40252: LD_VAR 0 4
40256: PPUSH
40257: CALL_OW 264
40261: PUSH
40262: LD_INT 31
40264: EQUAL
40265: PUSH
40266: LD_VAR 0 4
40270: PPUSH
40271: CALL_OW 311
40275: NOT
40276: AND
40277: PUSH
40278: LD_VAR 0 4
40282: PPUSH
40283: CALL_OW 266
40287: PUSH
40288: LD_INT 36
40290: EQUAL
40291: PUSH
40292: LD_VAR 0 4
40296: PPUSH
40297: CALL_OW 313
40301: PUSH
40302: LD_INT 3
40304: LESS
40305: AND
40306: OR
40307: IFFALSE 40321
// begin ct := k ;
40309: LD_ADDR_VAR 0 8
40313: PUSH
40314: LD_VAR 0 4
40318: ST_TO_ADDR
// break ;
40319: GO 40323
// end ;
40321: GO 40249
40323: POP
40324: POP
// if ct then
40325: LD_VAR 0 8
40329: IFFALSE 40345
// ComEnterUnit ( j , ct ) ;
40331: LD_VAR 0 3
40335: PPUSH
40336: LD_VAR 0 8
40340: PPUSH
40341: CALL_OW 120
// end ; end ;
40345: GO 39980
40347: POP
40348: POP
// places := 0 ;
40349: LD_ADDR_VAR 0 5
40353: PUSH
40354: LD_INT 0
40356: ST_TO_ADDR
// for j = 1 to x do
40357: LD_ADDR_VAR 0 3
40361: PUSH
40362: DOUBLE
40363: LD_INT 1
40365: DEC
40366: ST_TO_ADDR
40367: LD_VAR 0 11
40371: PUSH
40372: FOR_TO
40373: IFFALSE 40449
// if GetWeapon ( x [ j ] ) = ar_control_tower then
40375: LD_VAR 0 11
40379: PUSH
40380: LD_VAR 0 3
40384: ARRAY
40385: PPUSH
40386: CALL_OW 264
40390: PUSH
40391: LD_INT 31
40393: EQUAL
40394: IFFALSE 40412
// places := places + 1 else
40396: LD_ADDR_VAR 0 5
40400: PUSH
40401: LD_VAR 0 5
40405: PUSH
40406: LD_INT 1
40408: PLUS
40409: ST_TO_ADDR
40410: GO 40447
// if GetBType ( x [ j ] ) = b_control_tower then
40412: LD_VAR 0 11
40416: PUSH
40417: LD_VAR 0 3
40421: ARRAY
40422: PPUSH
40423: CALL_OW 266
40427: PUSH
40428: LD_INT 36
40430: EQUAL
40431: IFFALSE 40447
// places := places + 3 ;
40433: LD_ADDR_VAR 0 5
40437: PUSH
40438: LD_VAR 0 5
40442: PUSH
40443: LD_INT 3
40445: PLUS
40446: ST_TO_ADDR
40447: GO 40372
40449: POP
40450: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
40451: LD_VAR 0 5
40455: PUSH
40456: LD_INT 0
40458: EQUAL
40459: PUSH
40460: LD_VAR 0 5
40464: PUSH
40465: LD_EXP 90
40469: PUSH
40470: LD_VAR 0 2
40474: ARRAY
40475: LESSEQUAL
40476: OR
40477: IFFALSE 40481
// continue ;
40479: GO 39731
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
40481: LD_ADDR_VAR 0 6
40485: PUSH
40486: LD_EXP 50
40490: PUSH
40491: LD_VAR 0 2
40495: ARRAY
40496: PPUSH
40497: LD_INT 25
40499: PUSH
40500: LD_INT 3
40502: PUSH
40503: EMPTY
40504: LIST
40505: LIST
40506: PPUSH
40507: CALL_OW 72
40511: PUSH
40512: LD_EXP 90
40516: PUSH
40517: LD_VAR 0 2
40521: ARRAY
40522: DIFF
40523: PPUSH
40524: LD_INT 3
40526: PPUSH
40527: CALL 84678 0 2
40531: ST_TO_ADDR
// for j in tmp do
40532: LD_ADDR_VAR 0 3
40536: PUSH
40537: LD_VAR 0 6
40541: PUSH
40542: FOR_IN
40543: IFFALSE 40578
// if GetTag ( j ) > 0 then
40545: LD_VAR 0 3
40549: PPUSH
40550: CALL_OW 110
40554: PUSH
40555: LD_INT 0
40557: GREATER
40558: IFFALSE 40576
// tmp := tmp diff j ;
40560: LD_ADDR_VAR 0 6
40564: PUSH
40565: LD_VAR 0 6
40569: PUSH
40570: LD_VAR 0 3
40574: DIFF
40575: ST_TO_ADDR
40576: GO 40542
40578: POP
40579: POP
// if not tmp then
40580: LD_VAR 0 6
40584: NOT
40585: IFFALSE 40589
// continue ;
40587: GO 39731
// if places then
40589: LD_VAR 0 5
40593: IFFALSE 40652
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
40595: LD_ADDR_EXP 90
40599: PUSH
40600: LD_EXP 90
40604: PPUSH
40605: LD_VAR 0 2
40609: PPUSH
40610: LD_EXP 90
40614: PUSH
40615: LD_VAR 0 2
40619: ARRAY
40620: PUSH
40621: LD_VAR 0 6
40625: PUSH
40626: LD_INT 1
40628: ARRAY
40629: UNION
40630: PPUSH
40631: CALL_OW 1
40635: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
40636: LD_VAR 0 6
40640: PUSH
40641: LD_INT 1
40643: ARRAY
40644: PPUSH
40645: LD_INT 126
40647: PPUSH
40648: CALL_OW 109
// end ; end ;
40652: GO 39731
40654: POP
40655: POP
// end ;
40656: LD_VAR 0 1
40660: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
40661: LD_INT 0
40663: PPUSH
40664: PPUSH
40665: PPUSH
40666: PPUSH
40667: PPUSH
40668: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
40669: LD_VAR 0 1
40673: NOT
40674: PUSH
40675: LD_VAR 0 2
40679: NOT
40680: OR
40681: PUSH
40682: LD_VAR 0 3
40686: NOT
40687: OR
40688: PUSH
40689: LD_VAR 0 4
40693: PUSH
40694: LD_INT 1
40696: PUSH
40697: LD_INT 2
40699: PUSH
40700: LD_INT 3
40702: PUSH
40703: LD_INT 4
40705: PUSH
40706: LD_INT 5
40708: PUSH
40709: LD_INT 8
40711: PUSH
40712: LD_INT 9
40714: PUSH
40715: LD_INT 15
40717: PUSH
40718: LD_INT 16
40720: PUSH
40721: EMPTY
40722: LIST
40723: LIST
40724: LIST
40725: LIST
40726: LIST
40727: LIST
40728: LIST
40729: LIST
40730: LIST
40731: IN
40732: NOT
40733: OR
40734: IFFALSE 40738
// exit ;
40736: GO 41638
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
40738: LD_ADDR_VAR 0 2
40742: PUSH
40743: LD_VAR 0 2
40747: PPUSH
40748: LD_INT 21
40750: PUSH
40751: LD_INT 3
40753: PUSH
40754: EMPTY
40755: LIST
40756: LIST
40757: PUSH
40758: LD_INT 24
40760: PUSH
40761: LD_INT 250
40763: PUSH
40764: EMPTY
40765: LIST
40766: LIST
40767: PUSH
40768: EMPTY
40769: LIST
40770: LIST
40771: PPUSH
40772: CALL_OW 72
40776: ST_TO_ADDR
// case class of 1 , 15 :
40777: LD_VAR 0 4
40781: PUSH
40782: LD_INT 1
40784: DOUBLE
40785: EQUAL
40786: IFTRUE 40796
40788: LD_INT 15
40790: DOUBLE
40791: EQUAL
40792: IFTRUE 40796
40794: GO 40881
40796: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
40797: LD_ADDR_VAR 0 8
40801: PUSH
40802: LD_VAR 0 2
40806: PPUSH
40807: LD_INT 2
40809: PUSH
40810: LD_INT 30
40812: PUSH
40813: LD_INT 32
40815: PUSH
40816: EMPTY
40817: LIST
40818: LIST
40819: PUSH
40820: LD_INT 30
40822: PUSH
40823: LD_INT 31
40825: PUSH
40826: EMPTY
40827: LIST
40828: LIST
40829: PUSH
40830: EMPTY
40831: LIST
40832: LIST
40833: LIST
40834: PPUSH
40835: CALL_OW 72
40839: PUSH
40840: LD_VAR 0 2
40844: PPUSH
40845: LD_INT 2
40847: PUSH
40848: LD_INT 30
40850: PUSH
40851: LD_INT 4
40853: PUSH
40854: EMPTY
40855: LIST
40856: LIST
40857: PUSH
40858: LD_INT 30
40860: PUSH
40861: LD_INT 5
40863: PUSH
40864: EMPTY
40865: LIST
40866: LIST
40867: PUSH
40868: EMPTY
40869: LIST
40870: LIST
40871: LIST
40872: PPUSH
40873: CALL_OW 72
40877: ADD
40878: ST_TO_ADDR
40879: GO 41127
40881: LD_INT 2
40883: DOUBLE
40884: EQUAL
40885: IFTRUE 40895
40887: LD_INT 16
40889: DOUBLE
40890: EQUAL
40891: IFTRUE 40895
40893: GO 40941
40895: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
40896: LD_ADDR_VAR 0 8
40900: PUSH
40901: LD_VAR 0 2
40905: PPUSH
40906: LD_INT 2
40908: PUSH
40909: LD_INT 30
40911: PUSH
40912: LD_INT 0
40914: PUSH
40915: EMPTY
40916: LIST
40917: LIST
40918: PUSH
40919: LD_INT 30
40921: PUSH
40922: LD_INT 1
40924: PUSH
40925: EMPTY
40926: LIST
40927: LIST
40928: PUSH
40929: EMPTY
40930: LIST
40931: LIST
40932: LIST
40933: PPUSH
40934: CALL_OW 72
40938: ST_TO_ADDR
40939: GO 41127
40941: LD_INT 3
40943: DOUBLE
40944: EQUAL
40945: IFTRUE 40949
40947: GO 40995
40949: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
40950: LD_ADDR_VAR 0 8
40954: PUSH
40955: LD_VAR 0 2
40959: PPUSH
40960: LD_INT 2
40962: PUSH
40963: LD_INT 30
40965: PUSH
40966: LD_INT 2
40968: PUSH
40969: EMPTY
40970: LIST
40971: LIST
40972: PUSH
40973: LD_INT 30
40975: PUSH
40976: LD_INT 3
40978: PUSH
40979: EMPTY
40980: LIST
40981: LIST
40982: PUSH
40983: EMPTY
40984: LIST
40985: LIST
40986: LIST
40987: PPUSH
40988: CALL_OW 72
40992: ST_TO_ADDR
40993: GO 41127
40995: LD_INT 4
40997: DOUBLE
40998: EQUAL
40999: IFTRUE 41003
41001: GO 41060
41003: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
41004: LD_ADDR_VAR 0 8
41008: PUSH
41009: LD_VAR 0 2
41013: PPUSH
41014: LD_INT 2
41016: PUSH
41017: LD_INT 30
41019: PUSH
41020: LD_INT 6
41022: PUSH
41023: EMPTY
41024: LIST
41025: LIST
41026: PUSH
41027: LD_INT 30
41029: PUSH
41030: LD_INT 7
41032: PUSH
41033: EMPTY
41034: LIST
41035: LIST
41036: PUSH
41037: LD_INT 30
41039: PUSH
41040: LD_INT 8
41042: PUSH
41043: EMPTY
41044: LIST
41045: LIST
41046: PUSH
41047: EMPTY
41048: LIST
41049: LIST
41050: LIST
41051: LIST
41052: PPUSH
41053: CALL_OW 72
41057: ST_TO_ADDR
41058: GO 41127
41060: LD_INT 5
41062: DOUBLE
41063: EQUAL
41064: IFTRUE 41080
41066: LD_INT 8
41068: DOUBLE
41069: EQUAL
41070: IFTRUE 41080
41072: LD_INT 9
41074: DOUBLE
41075: EQUAL
41076: IFTRUE 41080
41078: GO 41126
41080: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
41081: LD_ADDR_VAR 0 8
41085: PUSH
41086: LD_VAR 0 2
41090: PPUSH
41091: LD_INT 2
41093: PUSH
41094: LD_INT 30
41096: PUSH
41097: LD_INT 4
41099: PUSH
41100: EMPTY
41101: LIST
41102: LIST
41103: PUSH
41104: LD_INT 30
41106: PUSH
41107: LD_INT 5
41109: PUSH
41110: EMPTY
41111: LIST
41112: LIST
41113: PUSH
41114: EMPTY
41115: LIST
41116: LIST
41117: LIST
41118: PPUSH
41119: CALL_OW 72
41123: ST_TO_ADDR
41124: GO 41127
41126: POP
// if not tmp then
41127: LD_VAR 0 8
41131: NOT
41132: IFFALSE 41136
// exit ;
41134: GO 41638
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
41136: LD_VAR 0 4
41140: PUSH
41141: LD_INT 1
41143: PUSH
41144: LD_INT 15
41146: PUSH
41147: EMPTY
41148: LIST
41149: LIST
41150: IN
41151: PUSH
41152: LD_EXP 59
41156: PUSH
41157: LD_VAR 0 1
41161: ARRAY
41162: AND
41163: IFFALSE 41319
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
41165: LD_ADDR_VAR 0 9
41169: PUSH
41170: LD_EXP 59
41174: PUSH
41175: LD_VAR 0 1
41179: ARRAY
41180: PUSH
41181: LD_INT 1
41183: ARRAY
41184: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
41185: LD_VAR 0 9
41189: PUSH
41190: LD_EXP 60
41194: PUSH
41195: LD_VAR 0 1
41199: ARRAY
41200: IN
41201: NOT
41202: IFFALSE 41317
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
41204: LD_ADDR_EXP 60
41208: PUSH
41209: LD_EXP 60
41213: PPUSH
41214: LD_VAR 0 1
41218: PUSH
41219: LD_EXP 60
41223: PUSH
41224: LD_VAR 0 1
41228: ARRAY
41229: PUSH
41230: LD_INT 1
41232: PLUS
41233: PUSH
41234: EMPTY
41235: LIST
41236: LIST
41237: PPUSH
41238: LD_VAR 0 9
41242: PPUSH
41243: CALL 53831 0 3
41247: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
41248: LD_ADDR_EXP 59
41252: PUSH
41253: LD_EXP 59
41257: PPUSH
41258: LD_VAR 0 1
41262: PPUSH
41263: LD_EXP 59
41267: PUSH
41268: LD_VAR 0 1
41272: ARRAY
41273: PUSH
41274: LD_VAR 0 9
41278: DIFF
41279: PPUSH
41280: CALL_OW 1
41284: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
41285: LD_VAR 0 3
41289: PPUSH
41290: LD_EXP 60
41294: PUSH
41295: LD_VAR 0 1
41299: ARRAY
41300: PUSH
41301: LD_EXP 60
41305: PUSH
41306: LD_VAR 0 1
41310: ARRAY
41311: ARRAY
41312: PPUSH
41313: CALL_OW 120
// end ; exit ;
41317: GO 41638
// end ; if tmp > 1 then
41319: LD_VAR 0 8
41323: PUSH
41324: LD_INT 1
41326: GREATER
41327: IFFALSE 41431
// for i = 2 to tmp do
41329: LD_ADDR_VAR 0 6
41333: PUSH
41334: DOUBLE
41335: LD_INT 2
41337: DEC
41338: ST_TO_ADDR
41339: LD_VAR 0 8
41343: PUSH
41344: FOR_TO
41345: IFFALSE 41429
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
41347: LD_VAR 0 8
41351: PUSH
41352: LD_VAR 0 6
41356: ARRAY
41357: PPUSH
41358: CALL_OW 461
41362: PUSH
41363: LD_INT 6
41365: EQUAL
41366: IFFALSE 41427
// begin x := tmp [ i ] ;
41368: LD_ADDR_VAR 0 9
41372: PUSH
41373: LD_VAR 0 8
41377: PUSH
41378: LD_VAR 0 6
41382: ARRAY
41383: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
41384: LD_ADDR_VAR 0 8
41388: PUSH
41389: LD_VAR 0 8
41393: PPUSH
41394: LD_VAR 0 6
41398: PPUSH
41399: CALL_OW 3
41403: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
41404: LD_ADDR_VAR 0 8
41408: PUSH
41409: LD_VAR 0 8
41413: PPUSH
41414: LD_INT 1
41416: PPUSH
41417: LD_VAR 0 9
41421: PPUSH
41422: CALL_OW 2
41426: ST_TO_ADDR
// end ;
41427: GO 41344
41429: POP
41430: POP
// for i in tmp do
41431: LD_ADDR_VAR 0 6
41435: PUSH
41436: LD_VAR 0 8
41440: PUSH
41441: FOR_IN
41442: IFFALSE 41511
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
41444: LD_VAR 0 6
41448: PPUSH
41449: CALL_OW 313
41453: PUSH
41454: LD_INT 6
41456: LESS
41457: PUSH
41458: LD_VAR 0 6
41462: PPUSH
41463: CALL_OW 266
41467: PUSH
41468: LD_INT 31
41470: PUSH
41471: LD_INT 32
41473: PUSH
41474: EMPTY
41475: LIST
41476: LIST
41477: IN
41478: NOT
41479: AND
41480: PUSH
41481: LD_VAR 0 6
41485: PPUSH
41486: CALL_OW 313
41490: PUSH
41491: LD_INT 0
41493: EQUAL
41494: OR
41495: IFFALSE 41509
// begin j := i ;
41497: LD_ADDR_VAR 0 7
41501: PUSH
41502: LD_VAR 0 6
41506: ST_TO_ADDR
// break ;
41507: GO 41511
// end ; end ;
41509: GO 41441
41511: POP
41512: POP
// if j then
41513: LD_VAR 0 7
41517: IFFALSE 41535
// ComEnterUnit ( unit , j ) else
41519: LD_VAR 0 3
41523: PPUSH
41524: LD_VAR 0 7
41528: PPUSH
41529: CALL_OW 120
41533: GO 41638
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
41535: LD_ADDR_VAR 0 10
41539: PUSH
41540: LD_VAR 0 2
41544: PPUSH
41545: LD_INT 2
41547: PUSH
41548: LD_INT 30
41550: PUSH
41551: LD_INT 0
41553: PUSH
41554: EMPTY
41555: LIST
41556: LIST
41557: PUSH
41558: LD_INT 30
41560: PUSH
41561: LD_INT 1
41563: PUSH
41564: EMPTY
41565: LIST
41566: LIST
41567: PUSH
41568: EMPTY
41569: LIST
41570: LIST
41571: LIST
41572: PPUSH
41573: CALL_OW 72
41577: ST_TO_ADDR
// if depot then
41578: LD_VAR 0 10
41582: IFFALSE 41638
// begin depot := NearestUnitToUnit ( depot , unit ) ;
41584: LD_ADDR_VAR 0 10
41588: PUSH
41589: LD_VAR 0 10
41593: PPUSH
41594: LD_VAR 0 3
41598: PPUSH
41599: CALL_OW 74
41603: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
41604: LD_VAR 0 3
41608: PPUSH
41609: LD_VAR 0 10
41613: PPUSH
41614: CALL_OW 296
41618: PUSH
41619: LD_INT 10
41621: GREATER
41622: IFFALSE 41638
// ComStandNearbyBuilding ( unit , depot ) ;
41624: LD_VAR 0 3
41628: PPUSH
41629: LD_VAR 0 10
41633: PPUSH
41634: CALL 50258 0 2
// end ; end ; end ;
41638: LD_VAR 0 5
41642: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
41643: LD_INT 0
41645: PPUSH
41646: PPUSH
41647: PPUSH
41648: PPUSH
// if not mc_bases then
41649: LD_EXP 50
41653: NOT
41654: IFFALSE 41658
// exit ;
41656: GO 41897
// for i = 1 to mc_bases do
41658: LD_ADDR_VAR 0 2
41662: PUSH
41663: DOUBLE
41664: LD_INT 1
41666: DEC
41667: ST_TO_ADDR
41668: LD_EXP 50
41672: PUSH
41673: FOR_TO
41674: IFFALSE 41895
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
41676: LD_ADDR_VAR 0 4
41680: PUSH
41681: LD_EXP 50
41685: PUSH
41686: LD_VAR 0 2
41690: ARRAY
41691: PPUSH
41692: LD_INT 21
41694: PUSH
41695: LD_INT 1
41697: PUSH
41698: EMPTY
41699: LIST
41700: LIST
41701: PPUSH
41702: CALL_OW 72
41706: PUSH
41707: LD_EXP 79
41711: PUSH
41712: LD_VAR 0 2
41716: ARRAY
41717: UNION
41718: ST_TO_ADDR
// if not tmp then
41719: LD_VAR 0 4
41723: NOT
41724: IFFALSE 41728
// continue ;
41726: GO 41673
// for j in tmp do
41728: LD_ADDR_VAR 0 3
41732: PUSH
41733: LD_VAR 0 4
41737: PUSH
41738: FOR_IN
41739: IFFALSE 41891
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
41741: LD_VAR 0 3
41745: PPUSH
41746: CALL_OW 110
41750: NOT
41751: PUSH
41752: LD_VAR 0 3
41756: PPUSH
41757: CALL_OW 314
41761: NOT
41762: AND
41763: PUSH
41764: LD_VAR 0 3
41768: PPUSH
41769: CALL_OW 311
41773: NOT
41774: AND
41775: PUSH
41776: LD_VAR 0 3
41780: PPUSH
41781: CALL_OW 310
41785: NOT
41786: AND
41787: PUSH
41788: LD_VAR 0 3
41792: PUSH
41793: LD_EXP 53
41797: PUSH
41798: LD_VAR 0 2
41802: ARRAY
41803: PUSH
41804: LD_INT 1
41806: ARRAY
41807: IN
41808: NOT
41809: AND
41810: PUSH
41811: LD_VAR 0 3
41815: PUSH
41816: LD_EXP 53
41820: PUSH
41821: LD_VAR 0 2
41825: ARRAY
41826: PUSH
41827: LD_INT 2
41829: ARRAY
41830: IN
41831: NOT
41832: AND
41833: PUSH
41834: LD_VAR 0 3
41838: PUSH
41839: LD_EXP 62
41843: PUSH
41844: LD_VAR 0 2
41848: ARRAY
41849: IN
41850: NOT
41851: AND
41852: IFFALSE 41889
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
41854: LD_VAR 0 2
41858: PPUSH
41859: LD_EXP 50
41863: PUSH
41864: LD_VAR 0 2
41868: ARRAY
41869: PPUSH
41870: LD_VAR 0 3
41874: PPUSH
41875: LD_VAR 0 3
41879: PPUSH
41880: CALL_OW 257
41884: PPUSH
41885: CALL 40661 0 4
// end ;
41889: GO 41738
41891: POP
41892: POP
// end ;
41893: GO 41673
41895: POP
41896: POP
// end ;
41897: LD_VAR 0 1
41901: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
41902: LD_INT 0
41904: PPUSH
41905: PPUSH
41906: PPUSH
41907: PPUSH
41908: PPUSH
41909: PPUSH
// if not mc_bases [ base ] then
41910: LD_EXP 50
41914: PUSH
41915: LD_VAR 0 1
41919: ARRAY
41920: NOT
41921: IFFALSE 41925
// exit ;
41923: GO 42107
// tmp := [ ] ;
41925: LD_ADDR_VAR 0 6
41929: PUSH
41930: EMPTY
41931: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
41932: LD_ADDR_VAR 0 7
41936: PUSH
41937: LD_VAR 0 3
41941: PPUSH
41942: LD_INT 0
41944: PPUSH
41945: CALL_OW 517
41949: ST_TO_ADDR
// if not list then
41950: LD_VAR 0 7
41954: NOT
41955: IFFALSE 41959
// exit ;
41957: GO 42107
// for i = 1 to amount do
41959: LD_ADDR_VAR 0 5
41963: PUSH
41964: DOUBLE
41965: LD_INT 1
41967: DEC
41968: ST_TO_ADDR
41969: LD_VAR 0 2
41973: PUSH
41974: FOR_TO
41975: IFFALSE 42055
// begin x := rand ( 1 , list [ 1 ] ) ;
41977: LD_ADDR_VAR 0 8
41981: PUSH
41982: LD_INT 1
41984: PPUSH
41985: LD_VAR 0 7
41989: PUSH
41990: LD_INT 1
41992: ARRAY
41993: PPUSH
41994: CALL_OW 12
41998: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
41999: LD_ADDR_VAR 0 6
42003: PUSH
42004: LD_VAR 0 6
42008: PPUSH
42009: LD_VAR 0 5
42013: PPUSH
42014: LD_VAR 0 7
42018: PUSH
42019: LD_INT 1
42021: ARRAY
42022: PUSH
42023: LD_VAR 0 8
42027: ARRAY
42028: PUSH
42029: LD_VAR 0 7
42033: PUSH
42034: LD_INT 2
42036: ARRAY
42037: PUSH
42038: LD_VAR 0 8
42042: ARRAY
42043: PUSH
42044: EMPTY
42045: LIST
42046: LIST
42047: PPUSH
42048: CALL_OW 1
42052: ST_TO_ADDR
// end ;
42053: GO 41974
42055: POP
42056: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
42057: LD_ADDR_EXP 63
42061: PUSH
42062: LD_EXP 63
42066: PPUSH
42067: LD_VAR 0 1
42071: PPUSH
42072: LD_VAR 0 6
42076: PPUSH
42077: CALL_OW 1
42081: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
42082: LD_ADDR_EXP 65
42086: PUSH
42087: LD_EXP 65
42091: PPUSH
42092: LD_VAR 0 1
42096: PPUSH
42097: LD_VAR 0 3
42101: PPUSH
42102: CALL_OW 1
42106: ST_TO_ADDR
// end ;
42107: LD_VAR 0 4
42111: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
42112: LD_INT 0
42114: PPUSH
// if not mc_bases [ base ] then
42115: LD_EXP 50
42119: PUSH
42120: LD_VAR 0 1
42124: ARRAY
42125: NOT
42126: IFFALSE 42130
// exit ;
42128: GO 42155
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
42130: LD_ADDR_EXP 55
42134: PUSH
42135: LD_EXP 55
42139: PPUSH
42140: LD_VAR 0 1
42144: PPUSH
42145: LD_VAR 0 2
42149: PPUSH
42150: CALL_OW 1
42154: ST_TO_ADDR
// end ;
42155: LD_VAR 0 3
42159: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
42160: LD_INT 0
42162: PPUSH
// if not mc_bases [ base ] then
42163: LD_EXP 50
42167: PUSH
42168: LD_VAR 0 1
42172: ARRAY
42173: NOT
42174: IFFALSE 42178
// exit ;
42176: GO 42215
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
42178: LD_ADDR_EXP 55
42182: PUSH
42183: LD_EXP 55
42187: PPUSH
42188: LD_VAR 0 1
42192: PPUSH
42193: LD_EXP 55
42197: PUSH
42198: LD_VAR 0 1
42202: ARRAY
42203: PUSH
42204: LD_VAR 0 2
42208: UNION
42209: PPUSH
42210: CALL_OW 1
42214: ST_TO_ADDR
// end ;
42215: LD_VAR 0 3
42219: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
42220: LD_INT 0
42222: PPUSH
// if not mc_bases [ base ] then
42223: LD_EXP 50
42227: PUSH
42228: LD_VAR 0 1
42232: ARRAY
42233: NOT
42234: IFFALSE 42238
// exit ;
42236: GO 42263
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
42238: LD_ADDR_EXP 71
42242: PUSH
42243: LD_EXP 71
42247: PPUSH
42248: LD_VAR 0 1
42252: PPUSH
42253: LD_VAR 0 2
42257: PPUSH
42258: CALL_OW 1
42262: ST_TO_ADDR
// end ;
42263: LD_VAR 0 3
42267: RET
// export function MC_InsertProduceList ( base , components ) ; begin
42268: LD_INT 0
42270: PPUSH
// if not mc_bases [ base ] then
42271: LD_EXP 50
42275: PUSH
42276: LD_VAR 0 1
42280: ARRAY
42281: NOT
42282: IFFALSE 42286
// exit ;
42284: GO 42323
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
42286: LD_ADDR_EXP 71
42290: PUSH
42291: LD_EXP 71
42295: PPUSH
42296: LD_VAR 0 1
42300: PPUSH
42301: LD_EXP 71
42305: PUSH
42306: LD_VAR 0 1
42310: ARRAY
42311: PUSH
42312: LD_VAR 0 2
42316: ADD
42317: PPUSH
42318: CALL_OW 1
42322: ST_TO_ADDR
// end ;
42323: LD_VAR 0 3
42327: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
42328: LD_INT 0
42330: PPUSH
// if not mc_bases [ base ] then
42331: LD_EXP 50
42335: PUSH
42336: LD_VAR 0 1
42340: ARRAY
42341: NOT
42342: IFFALSE 42346
// exit ;
42344: GO 42400
// mc_defender := Replace ( mc_defender , base , deflist ) ;
42346: LD_ADDR_EXP 72
42350: PUSH
42351: LD_EXP 72
42355: PPUSH
42356: LD_VAR 0 1
42360: PPUSH
42361: LD_VAR 0 2
42365: PPUSH
42366: CALL_OW 1
42370: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
42371: LD_ADDR_EXP 61
42375: PUSH
42376: LD_EXP 61
42380: PPUSH
42381: LD_VAR 0 1
42385: PPUSH
42386: LD_VAR 0 2
42390: PUSH
42391: LD_INT 0
42393: PLUS
42394: PPUSH
42395: CALL_OW 1
42399: ST_TO_ADDR
// end ;
42400: LD_VAR 0 3
42404: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
42405: LD_INT 0
42407: PPUSH
// if not mc_bases [ base ] then
42408: LD_EXP 50
42412: PUSH
42413: LD_VAR 0 1
42417: ARRAY
42418: NOT
42419: IFFALSE 42423
// exit ;
42421: GO 42448
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
42423: LD_ADDR_EXP 61
42427: PUSH
42428: LD_EXP 61
42432: PPUSH
42433: LD_VAR 0 1
42437: PPUSH
42438: LD_VAR 0 2
42442: PPUSH
42443: CALL_OW 1
42447: ST_TO_ADDR
// end ;
42448: LD_VAR 0 3
42452: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
42453: LD_INT 0
42455: PPUSH
42456: PPUSH
42457: PPUSH
42458: PPUSH
// if not mc_bases [ base ] then
42459: LD_EXP 50
42463: PUSH
42464: LD_VAR 0 1
42468: ARRAY
42469: NOT
42470: IFFALSE 42474
// exit ;
42472: GO 42539
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
42474: LD_ADDR_EXP 70
42478: PUSH
42479: LD_EXP 70
42483: PPUSH
42484: LD_VAR 0 1
42488: PUSH
42489: LD_EXP 70
42493: PUSH
42494: LD_VAR 0 1
42498: ARRAY
42499: PUSH
42500: LD_INT 1
42502: PLUS
42503: PUSH
42504: EMPTY
42505: LIST
42506: LIST
42507: PPUSH
42508: LD_VAR 0 1
42512: PUSH
42513: LD_VAR 0 2
42517: PUSH
42518: LD_VAR 0 3
42522: PUSH
42523: LD_VAR 0 4
42527: PUSH
42528: EMPTY
42529: LIST
42530: LIST
42531: LIST
42532: LIST
42533: PPUSH
42534: CALL 53831 0 3
42538: ST_TO_ADDR
// end ;
42539: LD_VAR 0 5
42543: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
42544: LD_INT 0
42546: PPUSH
// if not mc_bases [ base ] then
42547: LD_EXP 50
42551: PUSH
42552: LD_VAR 0 1
42556: ARRAY
42557: NOT
42558: IFFALSE 42562
// exit ;
42560: GO 42587
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
42562: LD_ADDR_EXP 87
42566: PUSH
42567: LD_EXP 87
42571: PPUSH
42572: LD_VAR 0 1
42576: PPUSH
42577: LD_VAR 0 2
42581: PPUSH
42582: CALL_OW 1
42586: ST_TO_ADDR
// end ;
42587: LD_VAR 0 3
42591: RET
// export function MC_GetMinesField ( base ) ; begin
42592: LD_INT 0
42594: PPUSH
// result := mc_mines [ base ] ;
42595: LD_ADDR_VAR 0 2
42599: PUSH
42600: LD_EXP 63
42604: PUSH
42605: LD_VAR 0 1
42609: ARRAY
42610: ST_TO_ADDR
// end ;
42611: LD_VAR 0 2
42615: RET
// export function MC_GetProduceList ( base ) ; begin
42616: LD_INT 0
42618: PPUSH
// result := mc_produce [ base ] ;
42619: LD_ADDR_VAR 0 2
42623: PUSH
42624: LD_EXP 71
42628: PUSH
42629: LD_VAR 0 1
42633: ARRAY
42634: ST_TO_ADDR
// end ;
42635: LD_VAR 0 2
42639: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
42640: LD_INT 0
42642: PPUSH
42643: PPUSH
// if not mc_bases then
42644: LD_EXP 50
42648: NOT
42649: IFFALSE 42653
// exit ;
42651: GO 42718
// if mc_bases [ base ] then
42653: LD_EXP 50
42657: PUSH
42658: LD_VAR 0 1
42662: ARRAY
42663: IFFALSE 42718
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
42665: LD_ADDR_VAR 0 3
42669: PUSH
42670: LD_EXP 50
42674: PUSH
42675: LD_VAR 0 1
42679: ARRAY
42680: PPUSH
42681: LD_INT 30
42683: PUSH
42684: LD_VAR 0 2
42688: PUSH
42689: EMPTY
42690: LIST
42691: LIST
42692: PPUSH
42693: CALL_OW 72
42697: ST_TO_ADDR
// if result then
42698: LD_VAR 0 3
42702: IFFALSE 42718
// result := result [ 1 ] ;
42704: LD_ADDR_VAR 0 3
42708: PUSH
42709: LD_VAR 0 3
42713: PUSH
42714: LD_INT 1
42716: ARRAY
42717: ST_TO_ADDR
// end ; end ;
42718: LD_VAR 0 3
42722: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
42723: LD_INT 0
42725: PPUSH
42726: PPUSH
// if not mc_bases then
42727: LD_EXP 50
42731: NOT
42732: IFFALSE 42736
// exit ;
42734: GO 42781
// if mc_bases [ base ] then
42736: LD_EXP 50
42740: PUSH
42741: LD_VAR 0 1
42745: ARRAY
42746: IFFALSE 42781
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
42748: LD_ADDR_VAR 0 3
42752: PUSH
42753: LD_EXP 50
42757: PUSH
42758: LD_VAR 0 1
42762: ARRAY
42763: PPUSH
42764: LD_INT 30
42766: PUSH
42767: LD_VAR 0 2
42771: PUSH
42772: EMPTY
42773: LIST
42774: LIST
42775: PPUSH
42776: CALL_OW 72
42780: ST_TO_ADDR
// end ;
42781: LD_VAR 0 3
42785: RET
// export function MC_SetTame ( base , area ) ; begin
42786: LD_INT 0
42788: PPUSH
// if not mc_bases or not base then
42789: LD_EXP 50
42793: NOT
42794: PUSH
42795: LD_VAR 0 1
42799: NOT
42800: OR
42801: IFFALSE 42805
// exit ;
42803: GO 42830
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
42805: LD_ADDR_EXP 78
42809: PUSH
42810: LD_EXP 78
42814: PPUSH
42815: LD_VAR 0 1
42819: PPUSH
42820: LD_VAR 0 2
42824: PPUSH
42825: CALL_OW 1
42829: ST_TO_ADDR
// end ;
42830: LD_VAR 0 3
42834: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
42835: LD_INT 0
42837: PPUSH
42838: PPUSH
// if not mc_bases or not base then
42839: LD_EXP 50
42843: NOT
42844: PUSH
42845: LD_VAR 0 1
42849: NOT
42850: OR
42851: IFFALSE 42855
// exit ;
42853: GO 42957
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
42855: LD_ADDR_VAR 0 4
42859: PUSH
42860: LD_EXP 50
42864: PUSH
42865: LD_VAR 0 1
42869: ARRAY
42870: PPUSH
42871: LD_INT 30
42873: PUSH
42874: LD_VAR 0 2
42878: PUSH
42879: EMPTY
42880: LIST
42881: LIST
42882: PPUSH
42883: CALL_OW 72
42887: ST_TO_ADDR
// if not tmp then
42888: LD_VAR 0 4
42892: NOT
42893: IFFALSE 42897
// exit ;
42895: GO 42957
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
42897: LD_ADDR_EXP 82
42901: PUSH
42902: LD_EXP 82
42906: PPUSH
42907: LD_VAR 0 1
42911: PPUSH
42912: LD_EXP 82
42916: PUSH
42917: LD_VAR 0 1
42921: ARRAY
42922: PPUSH
42923: LD_EXP 82
42927: PUSH
42928: LD_VAR 0 1
42932: ARRAY
42933: PUSH
42934: LD_INT 1
42936: PLUS
42937: PPUSH
42938: LD_VAR 0 4
42942: PUSH
42943: LD_INT 1
42945: ARRAY
42946: PPUSH
42947: CALL_OW 2
42951: PPUSH
42952: CALL_OW 1
42956: ST_TO_ADDR
// end ;
42957: LD_VAR 0 3
42961: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
42962: LD_INT 0
42964: PPUSH
42965: PPUSH
// if not mc_bases or not base or not kinds then
42966: LD_EXP 50
42970: NOT
42971: PUSH
42972: LD_VAR 0 1
42976: NOT
42977: OR
42978: PUSH
42979: LD_VAR 0 2
42983: NOT
42984: OR
42985: IFFALSE 42989
// exit ;
42987: GO 43050
// for i in kinds do
42989: LD_ADDR_VAR 0 4
42993: PUSH
42994: LD_VAR 0 2
42998: PUSH
42999: FOR_IN
43000: IFFALSE 43048
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
43002: LD_ADDR_EXP 84
43006: PUSH
43007: LD_EXP 84
43011: PPUSH
43012: LD_VAR 0 1
43016: PUSH
43017: LD_EXP 84
43021: PUSH
43022: LD_VAR 0 1
43026: ARRAY
43027: PUSH
43028: LD_INT 1
43030: PLUS
43031: PUSH
43032: EMPTY
43033: LIST
43034: LIST
43035: PPUSH
43036: LD_VAR 0 4
43040: PPUSH
43041: CALL 53831 0 3
43045: ST_TO_ADDR
43046: GO 42999
43048: POP
43049: POP
// end ;
43050: LD_VAR 0 3
43054: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
43055: LD_INT 0
43057: PPUSH
// if not mc_bases or not base or not areas then
43058: LD_EXP 50
43062: NOT
43063: PUSH
43064: LD_VAR 0 1
43068: NOT
43069: OR
43070: PUSH
43071: LD_VAR 0 2
43075: NOT
43076: OR
43077: IFFALSE 43081
// exit ;
43079: GO 43106
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
43081: LD_ADDR_EXP 68
43085: PUSH
43086: LD_EXP 68
43090: PPUSH
43091: LD_VAR 0 1
43095: PPUSH
43096: LD_VAR 0 2
43100: PPUSH
43101: CALL_OW 1
43105: ST_TO_ADDR
// end ;
43106: LD_VAR 0 3
43110: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
43111: LD_INT 0
43113: PPUSH
// if not mc_bases or not base or not teleports_exit then
43114: LD_EXP 50
43118: NOT
43119: PUSH
43120: LD_VAR 0 1
43124: NOT
43125: OR
43126: PUSH
43127: LD_VAR 0 2
43131: NOT
43132: OR
43133: IFFALSE 43137
// exit ;
43135: GO 43162
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
43137: LD_ADDR_EXP 85
43141: PUSH
43142: LD_EXP 85
43146: PPUSH
43147: LD_VAR 0 1
43151: PPUSH
43152: LD_VAR 0 2
43156: PPUSH
43157: CALL_OW 1
43161: ST_TO_ADDR
// end ;
43162: LD_VAR 0 3
43166: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
43167: LD_INT 0
43169: PPUSH
43170: PPUSH
43171: PPUSH
// if not mc_bases or not base or not ext_list then
43172: LD_EXP 50
43176: NOT
43177: PUSH
43178: LD_VAR 0 1
43182: NOT
43183: OR
43184: PUSH
43185: LD_VAR 0 5
43189: NOT
43190: OR
43191: IFFALSE 43195
// exit ;
43193: GO 43368
// tmp := GetFacExtXYD ( x , y , d ) ;
43195: LD_ADDR_VAR 0 8
43199: PUSH
43200: LD_VAR 0 2
43204: PPUSH
43205: LD_VAR 0 3
43209: PPUSH
43210: LD_VAR 0 4
43214: PPUSH
43215: CALL 83808 0 3
43219: ST_TO_ADDR
// if not tmp then
43220: LD_VAR 0 8
43224: NOT
43225: IFFALSE 43229
// exit ;
43227: GO 43368
// for i in tmp do
43229: LD_ADDR_VAR 0 7
43233: PUSH
43234: LD_VAR 0 8
43238: PUSH
43239: FOR_IN
43240: IFFALSE 43366
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
43242: LD_ADDR_EXP 55
43246: PUSH
43247: LD_EXP 55
43251: PPUSH
43252: LD_VAR 0 1
43256: PPUSH
43257: LD_EXP 55
43261: PUSH
43262: LD_VAR 0 1
43266: ARRAY
43267: PPUSH
43268: LD_EXP 55
43272: PUSH
43273: LD_VAR 0 1
43277: ARRAY
43278: PUSH
43279: LD_INT 1
43281: PLUS
43282: PPUSH
43283: LD_VAR 0 5
43287: PUSH
43288: LD_INT 1
43290: ARRAY
43291: PUSH
43292: LD_VAR 0 7
43296: PUSH
43297: LD_INT 1
43299: ARRAY
43300: PUSH
43301: LD_VAR 0 7
43305: PUSH
43306: LD_INT 2
43308: ARRAY
43309: PUSH
43310: LD_VAR 0 7
43314: PUSH
43315: LD_INT 3
43317: ARRAY
43318: PUSH
43319: EMPTY
43320: LIST
43321: LIST
43322: LIST
43323: LIST
43324: PPUSH
43325: CALL_OW 2
43329: PPUSH
43330: CALL_OW 1
43334: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
43335: LD_ADDR_VAR 0 5
43339: PUSH
43340: LD_VAR 0 5
43344: PPUSH
43345: LD_INT 1
43347: PPUSH
43348: CALL_OW 3
43352: ST_TO_ADDR
// if not ext_list then
43353: LD_VAR 0 5
43357: NOT
43358: IFFALSE 43364
// exit ;
43360: POP
43361: POP
43362: GO 43368
// end ;
43364: GO 43239
43366: POP
43367: POP
// end ;
43368: LD_VAR 0 6
43372: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
43373: LD_INT 0
43375: PPUSH
// if not mc_bases or not base or not weapon_list then
43376: LD_EXP 50
43380: NOT
43381: PUSH
43382: LD_VAR 0 1
43386: NOT
43387: OR
43388: PUSH
43389: LD_VAR 0 2
43393: NOT
43394: OR
43395: IFFALSE 43399
// exit ;
43397: GO 43424
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
43399: LD_ADDR_EXP 89
43403: PUSH
43404: LD_EXP 89
43408: PPUSH
43409: LD_VAR 0 1
43413: PPUSH
43414: LD_VAR 0 2
43418: PPUSH
43419: CALL_OW 1
43423: ST_TO_ADDR
// end ;
43424: LD_VAR 0 3
43428: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
43429: LD_INT 0
43431: PPUSH
// if not mc_bases or not base or not tech_list then
43432: LD_EXP 50
43436: NOT
43437: PUSH
43438: LD_VAR 0 1
43442: NOT
43443: OR
43444: PUSH
43445: LD_VAR 0 2
43449: NOT
43450: OR
43451: IFFALSE 43455
// exit ;
43453: GO 43480
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
43455: LD_ADDR_EXP 77
43459: PUSH
43460: LD_EXP 77
43464: PPUSH
43465: LD_VAR 0 1
43469: PPUSH
43470: LD_VAR 0 2
43474: PPUSH
43475: CALL_OW 1
43479: ST_TO_ADDR
// end ;
43480: LD_VAR 0 3
43484: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
43485: LD_INT 0
43487: PPUSH
// if not mc_bases or not parking_area or not base then
43488: LD_EXP 50
43492: NOT
43493: PUSH
43494: LD_VAR 0 2
43498: NOT
43499: OR
43500: PUSH
43501: LD_VAR 0 1
43505: NOT
43506: OR
43507: IFFALSE 43511
// exit ;
43509: GO 43536
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
43511: LD_ADDR_EXP 74
43515: PUSH
43516: LD_EXP 74
43520: PPUSH
43521: LD_VAR 0 1
43525: PPUSH
43526: LD_VAR 0 2
43530: PPUSH
43531: CALL_OW 1
43535: ST_TO_ADDR
// end ;
43536: LD_VAR 0 3
43540: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
43541: LD_INT 0
43543: PPUSH
// if not mc_bases or not base or not scan_area then
43544: LD_EXP 50
43548: NOT
43549: PUSH
43550: LD_VAR 0 1
43554: NOT
43555: OR
43556: PUSH
43557: LD_VAR 0 2
43561: NOT
43562: OR
43563: IFFALSE 43567
// exit ;
43565: GO 43592
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
43567: LD_ADDR_EXP 75
43571: PUSH
43572: LD_EXP 75
43576: PPUSH
43577: LD_VAR 0 1
43581: PPUSH
43582: LD_VAR 0 2
43586: PPUSH
43587: CALL_OW 1
43591: ST_TO_ADDR
// end ;
43592: LD_VAR 0 3
43596: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
43597: LD_INT 0
43599: PPUSH
43600: PPUSH
// if not mc_bases or not base then
43601: LD_EXP 50
43605: NOT
43606: PUSH
43607: LD_VAR 0 1
43611: NOT
43612: OR
43613: IFFALSE 43617
// exit ;
43615: GO 43681
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
43617: LD_ADDR_VAR 0 3
43621: PUSH
43622: LD_INT 1
43624: PUSH
43625: LD_INT 2
43627: PUSH
43628: LD_INT 3
43630: PUSH
43631: LD_INT 4
43633: PUSH
43634: LD_INT 11
43636: PUSH
43637: EMPTY
43638: LIST
43639: LIST
43640: LIST
43641: LIST
43642: LIST
43643: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
43644: LD_ADDR_EXP 77
43648: PUSH
43649: LD_EXP 77
43653: PPUSH
43654: LD_VAR 0 1
43658: PPUSH
43659: LD_EXP 77
43663: PUSH
43664: LD_VAR 0 1
43668: ARRAY
43669: PUSH
43670: LD_VAR 0 3
43674: DIFF
43675: PPUSH
43676: CALL_OW 1
43680: ST_TO_ADDR
// end ;
43681: LD_VAR 0 2
43685: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
43686: LD_INT 0
43688: PPUSH
// result := mc_vehicles [ base ] ;
43689: LD_ADDR_VAR 0 3
43693: PUSH
43694: LD_EXP 69
43698: PUSH
43699: LD_VAR 0 1
43703: ARRAY
43704: ST_TO_ADDR
// if onlyCombat then
43705: LD_VAR 0 2
43709: IFFALSE 43881
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
43711: LD_ADDR_VAR 0 3
43715: PUSH
43716: LD_VAR 0 3
43720: PUSH
43721: LD_VAR 0 3
43725: PPUSH
43726: LD_INT 2
43728: PUSH
43729: LD_INT 34
43731: PUSH
43732: LD_INT 12
43734: PUSH
43735: EMPTY
43736: LIST
43737: LIST
43738: PUSH
43739: LD_INT 34
43741: PUSH
43742: LD_INT 51
43744: PUSH
43745: EMPTY
43746: LIST
43747: LIST
43748: PUSH
43749: LD_INT 34
43751: PUSH
43752: LD_INT 89
43754: PUSH
43755: EMPTY
43756: LIST
43757: LIST
43758: PUSH
43759: LD_INT 34
43761: PUSH
43762: LD_INT 32
43764: PUSH
43765: EMPTY
43766: LIST
43767: LIST
43768: PUSH
43769: LD_INT 34
43771: PUSH
43772: LD_INT 13
43774: PUSH
43775: EMPTY
43776: LIST
43777: LIST
43778: PUSH
43779: LD_INT 34
43781: PUSH
43782: LD_INT 52
43784: PUSH
43785: EMPTY
43786: LIST
43787: LIST
43788: PUSH
43789: LD_INT 34
43791: PUSH
43792: LD_INT 88
43794: PUSH
43795: EMPTY
43796: LIST
43797: LIST
43798: PUSH
43799: LD_INT 34
43801: PUSH
43802: LD_INT 14
43804: PUSH
43805: EMPTY
43806: LIST
43807: LIST
43808: PUSH
43809: LD_INT 34
43811: PUSH
43812: LD_INT 53
43814: PUSH
43815: EMPTY
43816: LIST
43817: LIST
43818: PUSH
43819: LD_INT 34
43821: PUSH
43822: LD_INT 98
43824: PUSH
43825: EMPTY
43826: LIST
43827: LIST
43828: PUSH
43829: LD_INT 34
43831: PUSH
43832: LD_INT 31
43834: PUSH
43835: EMPTY
43836: LIST
43837: LIST
43838: PUSH
43839: LD_INT 34
43841: PUSH
43842: LD_INT 48
43844: PUSH
43845: EMPTY
43846: LIST
43847: LIST
43848: PUSH
43849: LD_INT 34
43851: PUSH
43852: LD_INT 8
43854: PUSH
43855: EMPTY
43856: LIST
43857: LIST
43858: PUSH
43859: EMPTY
43860: LIST
43861: LIST
43862: LIST
43863: LIST
43864: LIST
43865: LIST
43866: LIST
43867: LIST
43868: LIST
43869: LIST
43870: LIST
43871: LIST
43872: LIST
43873: LIST
43874: PPUSH
43875: CALL_OW 72
43879: DIFF
43880: ST_TO_ADDR
// end ; end_of_file
43881: LD_VAR 0 3
43885: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
43886: LD_INT 0
43888: PPUSH
43889: PPUSH
43890: PPUSH
// if not mc_bases or not skirmish then
43891: LD_EXP 50
43895: NOT
43896: PUSH
43897: LD_EXP 48
43901: NOT
43902: OR
43903: IFFALSE 43907
// exit ;
43905: GO 44072
// for i = 1 to mc_bases do
43907: LD_ADDR_VAR 0 4
43911: PUSH
43912: DOUBLE
43913: LD_INT 1
43915: DEC
43916: ST_TO_ADDR
43917: LD_EXP 50
43921: PUSH
43922: FOR_TO
43923: IFFALSE 44070
// begin if sci in mc_bases [ i ] then
43925: LD_VAR 0 2
43929: PUSH
43930: LD_EXP 50
43934: PUSH
43935: LD_VAR 0 4
43939: ARRAY
43940: IN
43941: IFFALSE 44068
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
43943: LD_ADDR_EXP 79
43947: PUSH
43948: LD_EXP 79
43952: PPUSH
43953: LD_VAR 0 4
43957: PUSH
43958: LD_EXP 79
43962: PUSH
43963: LD_VAR 0 4
43967: ARRAY
43968: PUSH
43969: LD_INT 1
43971: PLUS
43972: PUSH
43973: EMPTY
43974: LIST
43975: LIST
43976: PPUSH
43977: LD_VAR 0 1
43981: PPUSH
43982: CALL 53831 0 3
43986: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
43987: LD_ADDR_VAR 0 5
43991: PUSH
43992: LD_EXP 50
43996: PUSH
43997: LD_VAR 0 4
44001: ARRAY
44002: PPUSH
44003: LD_INT 2
44005: PUSH
44006: LD_INT 30
44008: PUSH
44009: LD_INT 0
44011: PUSH
44012: EMPTY
44013: LIST
44014: LIST
44015: PUSH
44016: LD_INT 30
44018: PUSH
44019: LD_INT 1
44021: PUSH
44022: EMPTY
44023: LIST
44024: LIST
44025: PUSH
44026: EMPTY
44027: LIST
44028: LIST
44029: LIST
44030: PPUSH
44031: CALL_OW 72
44035: PPUSH
44036: LD_VAR 0 1
44040: PPUSH
44041: CALL_OW 74
44045: ST_TO_ADDR
// if tmp then
44046: LD_VAR 0 5
44050: IFFALSE 44066
// ComStandNearbyBuilding ( ape , tmp ) ;
44052: LD_VAR 0 1
44056: PPUSH
44057: LD_VAR 0 5
44061: PPUSH
44062: CALL 50258 0 2
// break ;
44066: GO 44070
// end ; end ;
44068: GO 43922
44070: POP
44071: POP
// end ;
44072: LD_VAR 0 3
44076: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
44077: LD_INT 0
44079: PPUSH
44080: PPUSH
44081: PPUSH
// if not mc_bases or not skirmish then
44082: LD_EXP 50
44086: NOT
44087: PUSH
44088: LD_EXP 48
44092: NOT
44093: OR
44094: IFFALSE 44098
// exit ;
44096: GO 44187
// for i = 1 to mc_bases do
44098: LD_ADDR_VAR 0 4
44102: PUSH
44103: DOUBLE
44104: LD_INT 1
44106: DEC
44107: ST_TO_ADDR
44108: LD_EXP 50
44112: PUSH
44113: FOR_TO
44114: IFFALSE 44185
// begin if building in mc_busy_turret_list [ i ] then
44116: LD_VAR 0 1
44120: PUSH
44121: LD_EXP 60
44125: PUSH
44126: LD_VAR 0 4
44130: ARRAY
44131: IN
44132: IFFALSE 44183
// begin tmp := mc_busy_turret_list [ i ] diff building ;
44134: LD_ADDR_VAR 0 5
44138: PUSH
44139: LD_EXP 60
44143: PUSH
44144: LD_VAR 0 4
44148: ARRAY
44149: PUSH
44150: LD_VAR 0 1
44154: DIFF
44155: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
44156: LD_ADDR_EXP 60
44160: PUSH
44161: LD_EXP 60
44165: PPUSH
44166: LD_VAR 0 4
44170: PPUSH
44171: LD_VAR 0 5
44175: PPUSH
44176: CALL_OW 1
44180: ST_TO_ADDR
// break ;
44181: GO 44185
// end ; end ;
44183: GO 44113
44185: POP
44186: POP
// end ;
44187: LD_VAR 0 3
44191: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
44192: LD_INT 0
44194: PPUSH
44195: PPUSH
44196: PPUSH
// if not mc_bases or not skirmish then
44197: LD_EXP 50
44201: NOT
44202: PUSH
44203: LD_EXP 48
44207: NOT
44208: OR
44209: IFFALSE 44213
// exit ;
44211: GO 44412
// for i = 1 to mc_bases do
44213: LD_ADDR_VAR 0 5
44217: PUSH
44218: DOUBLE
44219: LD_INT 1
44221: DEC
44222: ST_TO_ADDR
44223: LD_EXP 50
44227: PUSH
44228: FOR_TO
44229: IFFALSE 44410
// if building in mc_bases [ i ] then
44231: LD_VAR 0 1
44235: PUSH
44236: LD_EXP 50
44240: PUSH
44241: LD_VAR 0 5
44245: ARRAY
44246: IN
44247: IFFALSE 44408
// begin tmp := mc_bases [ i ] diff building ;
44249: LD_ADDR_VAR 0 6
44253: PUSH
44254: LD_EXP 50
44258: PUSH
44259: LD_VAR 0 5
44263: ARRAY
44264: PUSH
44265: LD_VAR 0 1
44269: DIFF
44270: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
44271: LD_ADDR_EXP 50
44275: PUSH
44276: LD_EXP 50
44280: PPUSH
44281: LD_VAR 0 5
44285: PPUSH
44286: LD_VAR 0 6
44290: PPUSH
44291: CALL_OW 1
44295: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
44296: LD_VAR 0 1
44300: PUSH
44301: LD_EXP 58
44305: PUSH
44306: LD_VAR 0 5
44310: ARRAY
44311: IN
44312: IFFALSE 44351
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
44314: LD_ADDR_EXP 58
44318: PUSH
44319: LD_EXP 58
44323: PPUSH
44324: LD_VAR 0 5
44328: PPUSH
44329: LD_EXP 58
44333: PUSH
44334: LD_VAR 0 5
44338: ARRAY
44339: PUSH
44340: LD_VAR 0 1
44344: DIFF
44345: PPUSH
44346: CALL_OW 1
44350: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
44351: LD_VAR 0 1
44355: PUSH
44356: LD_EXP 59
44360: PUSH
44361: LD_VAR 0 5
44365: ARRAY
44366: IN
44367: IFFALSE 44406
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
44369: LD_ADDR_EXP 59
44373: PUSH
44374: LD_EXP 59
44378: PPUSH
44379: LD_VAR 0 5
44383: PPUSH
44384: LD_EXP 59
44388: PUSH
44389: LD_VAR 0 5
44393: ARRAY
44394: PUSH
44395: LD_VAR 0 1
44399: DIFF
44400: PPUSH
44401: CALL_OW 1
44405: ST_TO_ADDR
// break ;
44406: GO 44410
// end ;
44408: GO 44228
44410: POP
44411: POP
// end ;
44412: LD_VAR 0 4
44416: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
44417: LD_INT 0
44419: PPUSH
44420: PPUSH
44421: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
44422: LD_EXP 50
44426: NOT
44427: PUSH
44428: LD_EXP 48
44432: NOT
44433: OR
44434: PUSH
44435: LD_VAR 0 3
44439: PUSH
44440: LD_EXP 76
44444: IN
44445: NOT
44446: OR
44447: IFFALSE 44451
// exit ;
44449: GO 44574
// for i = 1 to mc_vehicles do
44451: LD_ADDR_VAR 0 6
44455: PUSH
44456: DOUBLE
44457: LD_INT 1
44459: DEC
44460: ST_TO_ADDR
44461: LD_EXP 69
44465: PUSH
44466: FOR_TO
44467: IFFALSE 44572
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
44469: LD_VAR 0 2
44473: PUSH
44474: LD_EXP 69
44478: PUSH
44479: LD_VAR 0 6
44483: ARRAY
44484: IN
44485: PUSH
44486: LD_VAR 0 1
44490: PUSH
44491: LD_EXP 69
44495: PUSH
44496: LD_VAR 0 6
44500: ARRAY
44501: IN
44502: OR
44503: IFFALSE 44570
// begin tmp := mc_vehicles [ i ] diff old ;
44505: LD_ADDR_VAR 0 7
44509: PUSH
44510: LD_EXP 69
44514: PUSH
44515: LD_VAR 0 6
44519: ARRAY
44520: PUSH
44521: LD_VAR 0 2
44525: DIFF
44526: ST_TO_ADDR
// tmp := tmp diff new ;
44527: LD_ADDR_VAR 0 7
44531: PUSH
44532: LD_VAR 0 7
44536: PUSH
44537: LD_VAR 0 1
44541: DIFF
44542: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
44543: LD_ADDR_EXP 69
44547: PUSH
44548: LD_EXP 69
44552: PPUSH
44553: LD_VAR 0 6
44557: PPUSH
44558: LD_VAR 0 7
44562: PPUSH
44563: CALL_OW 1
44567: ST_TO_ADDR
// break ;
44568: GO 44572
// end ;
44570: GO 44466
44572: POP
44573: POP
// end ;
44574: LD_VAR 0 5
44578: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
44579: LD_INT 0
44581: PPUSH
44582: PPUSH
44583: PPUSH
44584: PPUSH
// if not mc_bases or not skirmish then
44585: LD_EXP 50
44589: NOT
44590: PUSH
44591: LD_EXP 48
44595: NOT
44596: OR
44597: IFFALSE 44601
// exit ;
44599: GO 45021
// repeat wait ( 0 0$1 ) ;
44601: LD_INT 35
44603: PPUSH
44604: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
44608: LD_EXP 94
44612: NOT
44613: IFFALSE 44601
// mc_block_vehicle_constructed_thread := true ;
44615: LD_ADDR_EXP 94
44619: PUSH
44620: LD_INT 1
44622: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
44623: LD_ADDR_VAR 0 5
44627: PUSH
44628: LD_VAR 0 1
44632: PPUSH
44633: CALL_OW 255
44637: ST_TO_ADDR
// for i = 1 to mc_bases do
44638: LD_ADDR_VAR 0 4
44642: PUSH
44643: DOUBLE
44644: LD_INT 1
44646: DEC
44647: ST_TO_ADDR
44648: LD_EXP 50
44652: PUSH
44653: FOR_TO
44654: IFFALSE 45011
// begin if factory in mc_bases [ i ] then
44656: LD_VAR 0 2
44660: PUSH
44661: LD_EXP 50
44665: PUSH
44666: LD_VAR 0 4
44670: ARRAY
44671: IN
44672: IFFALSE 45009
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
44674: LD_EXP 72
44678: PUSH
44679: LD_VAR 0 4
44683: ARRAY
44684: PUSH
44685: LD_EXP 61
44689: PUSH
44690: LD_VAR 0 4
44694: ARRAY
44695: LESS
44696: PUSH
44697: LD_VAR 0 1
44701: PPUSH
44702: CALL_OW 264
44706: PUSH
44707: LD_INT 31
44709: PUSH
44710: LD_INT 32
44712: PUSH
44713: LD_INT 51
44715: PUSH
44716: LD_INT 89
44718: PUSH
44719: LD_INT 12
44721: PUSH
44722: LD_INT 30
44724: PUSH
44725: LD_INT 98
44727: PUSH
44728: LD_INT 11
44730: PUSH
44731: LD_INT 53
44733: PUSH
44734: LD_INT 14
44736: PUSH
44737: LD_INT 91
44739: PUSH
44740: LD_INT 29
44742: PUSH
44743: LD_INT 99
44745: PUSH
44746: LD_INT 13
44748: PUSH
44749: LD_INT 52
44751: PUSH
44752: LD_INT 88
44754: PUSH
44755: LD_INT 48
44757: PUSH
44758: LD_INT 8
44760: PUSH
44761: EMPTY
44762: LIST
44763: LIST
44764: LIST
44765: LIST
44766: LIST
44767: LIST
44768: LIST
44769: LIST
44770: LIST
44771: LIST
44772: LIST
44773: LIST
44774: LIST
44775: LIST
44776: LIST
44777: LIST
44778: LIST
44779: LIST
44780: IN
44781: NOT
44782: AND
44783: IFFALSE 44831
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
44785: LD_ADDR_EXP 72
44789: PUSH
44790: LD_EXP 72
44794: PPUSH
44795: LD_VAR 0 4
44799: PUSH
44800: LD_EXP 72
44804: PUSH
44805: LD_VAR 0 4
44809: ARRAY
44810: PUSH
44811: LD_INT 1
44813: PLUS
44814: PUSH
44815: EMPTY
44816: LIST
44817: LIST
44818: PPUSH
44819: LD_VAR 0 1
44823: PPUSH
44824: CALL 53831 0 3
44828: ST_TO_ADDR
44829: GO 44875
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
44831: LD_ADDR_EXP 69
44835: PUSH
44836: LD_EXP 69
44840: PPUSH
44841: LD_VAR 0 4
44845: PUSH
44846: LD_EXP 69
44850: PUSH
44851: LD_VAR 0 4
44855: ARRAY
44856: PUSH
44857: LD_INT 1
44859: PLUS
44860: PUSH
44861: EMPTY
44862: LIST
44863: LIST
44864: PPUSH
44865: LD_VAR 0 1
44869: PPUSH
44870: CALL 53831 0 3
44874: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
44875: LD_ADDR_EXP 94
44879: PUSH
44880: LD_INT 0
44882: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
44883: LD_VAR 0 1
44887: PPUSH
44888: CALL_OW 263
44892: PUSH
44893: LD_INT 2
44895: EQUAL
44896: IFFALSE 44925
// begin repeat wait ( 0 0$3 ) ;
44898: LD_INT 105
44900: PPUSH
44901: CALL_OW 67
// Connect ( vehicle ) ;
44905: LD_VAR 0 1
44909: PPUSH
44910: CALL 56800 0 1
// until IsControledBy ( vehicle ) ;
44914: LD_VAR 0 1
44918: PPUSH
44919: CALL_OW 312
44923: IFFALSE 44898
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
44925: LD_VAR 0 1
44929: PPUSH
44930: LD_EXP 74
44934: PUSH
44935: LD_VAR 0 4
44939: ARRAY
44940: PPUSH
44941: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
44945: LD_VAR 0 1
44949: PPUSH
44950: CALL_OW 263
44954: PUSH
44955: LD_INT 1
44957: NONEQUAL
44958: IFFALSE 44962
// break ;
44960: GO 45011
// repeat wait ( 0 0$1 ) ;
44962: LD_INT 35
44964: PPUSH
44965: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
44969: LD_VAR 0 1
44973: PPUSH
44974: LD_EXP 74
44978: PUSH
44979: LD_VAR 0 4
44983: ARRAY
44984: PPUSH
44985: CALL_OW 308
44989: IFFALSE 44962
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
44991: LD_VAR 0 1
44995: PPUSH
44996: CALL_OW 311
45000: PPUSH
45001: CALL_OW 121
// exit ;
45005: POP
45006: POP
45007: GO 45021
// end ; end ;
45009: GO 44653
45011: POP
45012: POP
// mc_block_vehicle_constructed_thread := false ;
45013: LD_ADDR_EXP 94
45017: PUSH
45018: LD_INT 0
45020: ST_TO_ADDR
// end ;
45021: LD_VAR 0 3
45025: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
45026: LD_INT 0
45028: PPUSH
45029: PPUSH
45030: PPUSH
45031: PPUSH
// if not mc_bases or not skirmish then
45032: LD_EXP 50
45036: NOT
45037: PUSH
45038: LD_EXP 48
45042: NOT
45043: OR
45044: IFFALSE 45048
// exit ;
45046: GO 45401
// repeat wait ( 0 0$1 ) ;
45048: LD_INT 35
45050: PPUSH
45051: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
45055: LD_VAR 0 2
45059: PPUSH
45060: LD_VAR 0 3
45064: PPUSH
45065: CALL_OW 284
45069: IFFALSE 45048
// if GetResourceTypeXY ( x , y ) = mat_artefact then
45071: LD_VAR 0 2
45075: PPUSH
45076: LD_VAR 0 3
45080: PPUSH
45081: CALL_OW 283
45085: PUSH
45086: LD_INT 4
45088: EQUAL
45089: IFFALSE 45093
// exit ;
45091: GO 45401
// for i = 1 to mc_bases do
45093: LD_ADDR_VAR 0 7
45097: PUSH
45098: DOUBLE
45099: LD_INT 1
45101: DEC
45102: ST_TO_ADDR
45103: LD_EXP 50
45107: PUSH
45108: FOR_TO
45109: IFFALSE 45399
// begin if mc_crates_area [ i ] then
45111: LD_EXP 68
45115: PUSH
45116: LD_VAR 0 7
45120: ARRAY
45121: IFFALSE 45232
// for j in mc_crates_area [ i ] do
45123: LD_ADDR_VAR 0 8
45127: PUSH
45128: LD_EXP 68
45132: PUSH
45133: LD_VAR 0 7
45137: ARRAY
45138: PUSH
45139: FOR_IN
45140: IFFALSE 45230
// if InArea ( x , y , j ) then
45142: LD_VAR 0 2
45146: PPUSH
45147: LD_VAR 0 3
45151: PPUSH
45152: LD_VAR 0 8
45156: PPUSH
45157: CALL_OW 309
45161: IFFALSE 45228
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
45163: LD_ADDR_EXP 66
45167: PUSH
45168: LD_EXP 66
45172: PPUSH
45173: LD_VAR 0 7
45177: PUSH
45178: LD_EXP 66
45182: PUSH
45183: LD_VAR 0 7
45187: ARRAY
45188: PUSH
45189: LD_INT 1
45191: PLUS
45192: PUSH
45193: EMPTY
45194: LIST
45195: LIST
45196: PPUSH
45197: LD_VAR 0 4
45201: PUSH
45202: LD_VAR 0 2
45206: PUSH
45207: LD_VAR 0 3
45211: PUSH
45212: EMPTY
45213: LIST
45214: LIST
45215: LIST
45216: PPUSH
45217: CALL 53831 0 3
45221: ST_TO_ADDR
// exit ;
45222: POP
45223: POP
45224: POP
45225: POP
45226: GO 45401
// end ;
45228: GO 45139
45230: POP
45231: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
45232: LD_ADDR_VAR 0 9
45236: PUSH
45237: LD_EXP 50
45241: PUSH
45242: LD_VAR 0 7
45246: ARRAY
45247: PPUSH
45248: LD_INT 2
45250: PUSH
45251: LD_INT 30
45253: PUSH
45254: LD_INT 0
45256: PUSH
45257: EMPTY
45258: LIST
45259: LIST
45260: PUSH
45261: LD_INT 30
45263: PUSH
45264: LD_INT 1
45266: PUSH
45267: EMPTY
45268: LIST
45269: LIST
45270: PUSH
45271: EMPTY
45272: LIST
45273: LIST
45274: LIST
45275: PPUSH
45276: CALL_OW 72
45280: ST_TO_ADDR
// if not depot then
45281: LD_VAR 0 9
45285: NOT
45286: IFFALSE 45290
// continue ;
45288: GO 45108
// for j in depot do
45290: LD_ADDR_VAR 0 8
45294: PUSH
45295: LD_VAR 0 9
45299: PUSH
45300: FOR_IN
45301: IFFALSE 45395
// if GetDistUnitXY ( j , x , y ) < 30 then
45303: LD_VAR 0 8
45307: PPUSH
45308: LD_VAR 0 2
45312: PPUSH
45313: LD_VAR 0 3
45317: PPUSH
45318: CALL_OW 297
45322: PUSH
45323: LD_INT 30
45325: LESS
45326: IFFALSE 45393
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
45328: LD_ADDR_EXP 66
45332: PUSH
45333: LD_EXP 66
45337: PPUSH
45338: LD_VAR 0 7
45342: PUSH
45343: LD_EXP 66
45347: PUSH
45348: LD_VAR 0 7
45352: ARRAY
45353: PUSH
45354: LD_INT 1
45356: PLUS
45357: PUSH
45358: EMPTY
45359: LIST
45360: LIST
45361: PPUSH
45362: LD_VAR 0 4
45366: PUSH
45367: LD_VAR 0 2
45371: PUSH
45372: LD_VAR 0 3
45376: PUSH
45377: EMPTY
45378: LIST
45379: LIST
45380: LIST
45381: PPUSH
45382: CALL 53831 0 3
45386: ST_TO_ADDR
// exit ;
45387: POP
45388: POP
45389: POP
45390: POP
45391: GO 45401
// end ;
45393: GO 45300
45395: POP
45396: POP
// end ;
45397: GO 45108
45399: POP
45400: POP
// end ;
45401: LD_VAR 0 6
45405: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
45406: LD_INT 0
45408: PPUSH
45409: PPUSH
45410: PPUSH
45411: PPUSH
// if not mc_bases or not skirmish then
45412: LD_EXP 50
45416: NOT
45417: PUSH
45418: LD_EXP 48
45422: NOT
45423: OR
45424: IFFALSE 45428
// exit ;
45426: GO 45705
// side := GetSide ( lab ) ;
45428: LD_ADDR_VAR 0 4
45432: PUSH
45433: LD_VAR 0 2
45437: PPUSH
45438: CALL_OW 255
45442: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
45443: LD_VAR 0 4
45447: PUSH
45448: LD_EXP 76
45452: IN
45453: NOT
45454: PUSH
45455: LD_EXP 77
45459: NOT
45460: OR
45461: PUSH
45462: LD_EXP 50
45466: NOT
45467: OR
45468: IFFALSE 45472
// exit ;
45470: GO 45705
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
45472: LD_ADDR_EXP 77
45476: PUSH
45477: LD_EXP 77
45481: PPUSH
45482: LD_VAR 0 4
45486: PPUSH
45487: LD_EXP 77
45491: PUSH
45492: LD_VAR 0 4
45496: ARRAY
45497: PUSH
45498: LD_VAR 0 1
45502: DIFF
45503: PPUSH
45504: CALL_OW 1
45508: ST_TO_ADDR
// for i = 1 to mc_bases do
45509: LD_ADDR_VAR 0 5
45513: PUSH
45514: DOUBLE
45515: LD_INT 1
45517: DEC
45518: ST_TO_ADDR
45519: LD_EXP 50
45523: PUSH
45524: FOR_TO
45525: IFFALSE 45703
// begin if lab in mc_bases [ i ] then
45527: LD_VAR 0 2
45531: PUSH
45532: LD_EXP 50
45536: PUSH
45537: LD_VAR 0 5
45541: ARRAY
45542: IN
45543: IFFALSE 45701
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
45545: LD_VAR 0 1
45549: PUSH
45550: LD_INT 11
45552: PUSH
45553: LD_INT 4
45555: PUSH
45556: LD_INT 3
45558: PUSH
45559: LD_INT 2
45561: PUSH
45562: EMPTY
45563: LIST
45564: LIST
45565: LIST
45566: LIST
45567: IN
45568: PUSH
45569: LD_EXP 80
45573: PUSH
45574: LD_VAR 0 5
45578: ARRAY
45579: AND
45580: IFFALSE 45701
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
45582: LD_ADDR_VAR 0 6
45586: PUSH
45587: LD_EXP 80
45591: PUSH
45592: LD_VAR 0 5
45596: ARRAY
45597: PUSH
45598: LD_INT 1
45600: ARRAY
45601: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
45602: LD_ADDR_EXP 80
45606: PUSH
45607: LD_EXP 80
45611: PPUSH
45612: LD_VAR 0 5
45616: PPUSH
45617: EMPTY
45618: PPUSH
45619: CALL_OW 1
45623: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
45624: LD_VAR 0 6
45628: PPUSH
45629: LD_INT 0
45631: PPUSH
45632: CALL_OW 109
// ComExitBuilding ( tmp ) ;
45636: LD_VAR 0 6
45640: PPUSH
45641: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
45645: LD_ADDR_EXP 79
45649: PUSH
45650: LD_EXP 79
45654: PPUSH
45655: LD_VAR 0 5
45659: PPUSH
45660: LD_EXP 79
45664: PUSH
45665: LD_VAR 0 5
45669: ARRAY
45670: PPUSH
45671: LD_INT 1
45673: PPUSH
45674: LD_VAR 0 6
45678: PPUSH
45679: CALL_OW 2
45683: PPUSH
45684: CALL_OW 1
45688: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
45689: LD_VAR 0 5
45693: PPUSH
45694: LD_INT 112
45696: PPUSH
45697: CALL 22153 0 2
// end ; end ; end ;
45701: GO 45524
45703: POP
45704: POP
// end ;
45705: LD_VAR 0 3
45709: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
45710: LD_INT 0
45712: PPUSH
45713: PPUSH
45714: PPUSH
45715: PPUSH
45716: PPUSH
45717: PPUSH
45718: PPUSH
45719: PPUSH
// if not mc_bases or not skirmish then
45720: LD_EXP 50
45724: NOT
45725: PUSH
45726: LD_EXP 48
45730: NOT
45731: OR
45732: IFFALSE 45736
// exit ;
45734: GO 47105
// for i = 1 to mc_bases do
45736: LD_ADDR_VAR 0 3
45740: PUSH
45741: DOUBLE
45742: LD_INT 1
45744: DEC
45745: ST_TO_ADDR
45746: LD_EXP 50
45750: PUSH
45751: FOR_TO
45752: IFFALSE 47103
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
45754: LD_VAR 0 1
45758: PUSH
45759: LD_EXP 50
45763: PUSH
45764: LD_VAR 0 3
45768: ARRAY
45769: IN
45770: PUSH
45771: LD_VAR 0 1
45775: PUSH
45776: LD_EXP 57
45780: PUSH
45781: LD_VAR 0 3
45785: ARRAY
45786: IN
45787: OR
45788: PUSH
45789: LD_VAR 0 1
45793: PUSH
45794: LD_EXP 72
45798: PUSH
45799: LD_VAR 0 3
45803: ARRAY
45804: IN
45805: OR
45806: PUSH
45807: LD_VAR 0 1
45811: PUSH
45812: LD_EXP 69
45816: PUSH
45817: LD_VAR 0 3
45821: ARRAY
45822: IN
45823: OR
45824: PUSH
45825: LD_VAR 0 1
45829: PUSH
45830: LD_EXP 79
45834: PUSH
45835: LD_VAR 0 3
45839: ARRAY
45840: IN
45841: OR
45842: PUSH
45843: LD_VAR 0 1
45847: PUSH
45848: LD_EXP 80
45852: PUSH
45853: LD_VAR 0 3
45857: ARRAY
45858: IN
45859: OR
45860: IFFALSE 47101
// begin if un in mc_ape [ i ] then
45862: LD_VAR 0 1
45866: PUSH
45867: LD_EXP 79
45871: PUSH
45872: LD_VAR 0 3
45876: ARRAY
45877: IN
45878: IFFALSE 45917
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
45880: LD_ADDR_EXP 79
45884: PUSH
45885: LD_EXP 79
45889: PPUSH
45890: LD_VAR 0 3
45894: PPUSH
45895: LD_EXP 79
45899: PUSH
45900: LD_VAR 0 3
45904: ARRAY
45905: PUSH
45906: LD_VAR 0 1
45910: DIFF
45911: PPUSH
45912: CALL_OW 1
45916: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
45917: LD_VAR 0 1
45921: PUSH
45922: LD_EXP 80
45926: PUSH
45927: LD_VAR 0 3
45931: ARRAY
45932: IN
45933: IFFALSE 45957
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
45935: LD_ADDR_EXP 80
45939: PUSH
45940: LD_EXP 80
45944: PPUSH
45945: LD_VAR 0 3
45949: PPUSH
45950: EMPTY
45951: PPUSH
45952: CALL_OW 1
45956: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
45957: LD_VAR 0 1
45961: PPUSH
45962: CALL_OW 247
45966: PUSH
45967: LD_INT 2
45969: EQUAL
45970: PUSH
45971: LD_VAR 0 1
45975: PPUSH
45976: CALL_OW 110
45980: PUSH
45981: LD_INT 20
45983: EQUAL
45984: PUSH
45985: LD_VAR 0 1
45989: PUSH
45990: LD_EXP 72
45994: PUSH
45995: LD_VAR 0 3
45999: ARRAY
46000: IN
46001: OR
46002: PUSH
46003: LD_VAR 0 1
46007: PPUSH
46008: CALL_OW 264
46012: PUSH
46013: LD_INT 12
46015: PUSH
46016: LD_INT 51
46018: PUSH
46019: LD_INT 89
46021: PUSH
46022: LD_INT 32
46024: PUSH
46025: LD_INT 13
46027: PUSH
46028: LD_INT 52
46030: PUSH
46031: LD_INT 31
46033: PUSH
46034: EMPTY
46035: LIST
46036: LIST
46037: LIST
46038: LIST
46039: LIST
46040: LIST
46041: LIST
46042: IN
46043: OR
46044: AND
46045: IFFALSE 46353
// begin if un in mc_defender [ i ] then
46047: LD_VAR 0 1
46051: PUSH
46052: LD_EXP 72
46056: PUSH
46057: LD_VAR 0 3
46061: ARRAY
46062: IN
46063: IFFALSE 46102
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
46065: LD_ADDR_EXP 72
46069: PUSH
46070: LD_EXP 72
46074: PPUSH
46075: LD_VAR 0 3
46079: PPUSH
46080: LD_EXP 72
46084: PUSH
46085: LD_VAR 0 3
46089: ARRAY
46090: PUSH
46091: LD_VAR 0 1
46095: DIFF
46096: PPUSH
46097: CALL_OW 1
46101: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
46102: LD_ADDR_VAR 0 8
46106: PUSH
46107: LD_VAR 0 3
46111: PPUSH
46112: LD_INT 3
46114: PPUSH
46115: CALL 42723 0 2
46119: ST_TO_ADDR
// if fac then
46120: LD_VAR 0 8
46124: IFFALSE 46353
// begin for j in fac do
46126: LD_ADDR_VAR 0 4
46130: PUSH
46131: LD_VAR 0 8
46135: PUSH
46136: FOR_IN
46137: IFFALSE 46351
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
46139: LD_ADDR_VAR 0 9
46143: PUSH
46144: LD_VAR 0 8
46148: PPUSH
46149: LD_VAR 0 1
46153: PPUSH
46154: CALL_OW 265
46158: PPUSH
46159: LD_VAR 0 1
46163: PPUSH
46164: CALL_OW 262
46168: PPUSH
46169: LD_VAR 0 1
46173: PPUSH
46174: CALL_OW 263
46178: PPUSH
46179: LD_VAR 0 1
46183: PPUSH
46184: CALL_OW 264
46188: PPUSH
46189: CALL 51329 0 5
46193: ST_TO_ADDR
// if components then
46194: LD_VAR 0 9
46198: IFFALSE 46349
// begin if GetWeapon ( un ) = ar_control_tower then
46200: LD_VAR 0 1
46204: PPUSH
46205: CALL_OW 264
46209: PUSH
46210: LD_INT 31
46212: EQUAL
46213: IFFALSE 46330
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
46215: LD_VAR 0 1
46219: PPUSH
46220: CALL_OW 311
46224: PPUSH
46225: LD_INT 0
46227: PPUSH
46228: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
46232: LD_ADDR_EXP 90
46236: PUSH
46237: LD_EXP 90
46241: PPUSH
46242: LD_VAR 0 3
46246: PPUSH
46247: LD_EXP 90
46251: PUSH
46252: LD_VAR 0 3
46256: ARRAY
46257: PUSH
46258: LD_VAR 0 1
46262: PPUSH
46263: CALL_OW 311
46267: DIFF
46268: PPUSH
46269: CALL_OW 1
46273: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
46274: LD_ADDR_VAR 0 7
46278: PUSH
46279: LD_EXP 71
46283: PUSH
46284: LD_VAR 0 3
46288: ARRAY
46289: PPUSH
46290: LD_INT 1
46292: PPUSH
46293: LD_VAR 0 9
46297: PPUSH
46298: CALL_OW 2
46302: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
46303: LD_ADDR_EXP 71
46307: PUSH
46308: LD_EXP 71
46312: PPUSH
46313: LD_VAR 0 3
46317: PPUSH
46318: LD_VAR 0 7
46322: PPUSH
46323: CALL_OW 1
46327: ST_TO_ADDR
// end else
46328: GO 46347
// MC_InsertProduceList ( i , [ components ] ) ;
46330: LD_VAR 0 3
46334: PPUSH
46335: LD_VAR 0 9
46339: PUSH
46340: EMPTY
46341: LIST
46342: PPUSH
46343: CALL 42268 0 2
// break ;
46347: GO 46351
// end ; end ;
46349: GO 46136
46351: POP
46352: POP
// end ; end ; if GetType ( un ) = unit_building then
46353: LD_VAR 0 1
46357: PPUSH
46358: CALL_OW 247
46362: PUSH
46363: LD_INT 3
46365: EQUAL
46366: IFFALSE 46769
// begin btype := GetBType ( un ) ;
46368: LD_ADDR_VAR 0 5
46372: PUSH
46373: LD_VAR 0 1
46377: PPUSH
46378: CALL_OW 266
46382: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
46383: LD_VAR 0 5
46387: PUSH
46388: LD_INT 29
46390: PUSH
46391: LD_INT 30
46393: PUSH
46394: EMPTY
46395: LIST
46396: LIST
46397: IN
46398: IFFALSE 46471
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
46400: LD_VAR 0 1
46404: PPUSH
46405: CALL_OW 250
46409: PPUSH
46410: LD_VAR 0 1
46414: PPUSH
46415: CALL_OW 251
46419: PPUSH
46420: LD_VAR 0 1
46424: PPUSH
46425: CALL_OW 255
46429: PPUSH
46430: CALL_OW 440
46434: NOT
46435: IFFALSE 46471
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
46437: LD_VAR 0 1
46441: PPUSH
46442: CALL_OW 250
46446: PPUSH
46447: LD_VAR 0 1
46451: PPUSH
46452: CALL_OW 251
46456: PPUSH
46457: LD_VAR 0 1
46461: PPUSH
46462: CALL_OW 255
46466: PPUSH
46467: CALL_OW 441
// end ; if btype = b_warehouse then
46471: LD_VAR 0 5
46475: PUSH
46476: LD_INT 1
46478: EQUAL
46479: IFFALSE 46497
// begin btype := b_depot ;
46481: LD_ADDR_VAR 0 5
46485: PUSH
46486: LD_INT 0
46488: ST_TO_ADDR
// pos := 1 ;
46489: LD_ADDR_VAR 0 6
46493: PUSH
46494: LD_INT 1
46496: ST_TO_ADDR
// end ; if btype = b_factory then
46497: LD_VAR 0 5
46501: PUSH
46502: LD_INT 3
46504: EQUAL
46505: IFFALSE 46523
// begin btype := b_workshop ;
46507: LD_ADDR_VAR 0 5
46511: PUSH
46512: LD_INT 2
46514: ST_TO_ADDR
// pos := 1 ;
46515: LD_ADDR_VAR 0 6
46519: PUSH
46520: LD_INT 1
46522: ST_TO_ADDR
// end ; if btype = b_barracks then
46523: LD_VAR 0 5
46527: PUSH
46528: LD_INT 5
46530: EQUAL
46531: IFFALSE 46541
// btype := b_armoury ;
46533: LD_ADDR_VAR 0 5
46537: PUSH
46538: LD_INT 4
46540: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
46541: LD_VAR 0 5
46545: PUSH
46546: LD_INT 7
46548: PUSH
46549: LD_INT 8
46551: PUSH
46552: EMPTY
46553: LIST
46554: LIST
46555: IN
46556: IFFALSE 46566
// btype := b_lab ;
46558: LD_ADDR_VAR 0 5
46562: PUSH
46563: LD_INT 6
46565: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
46566: LD_ADDR_EXP 55
46570: PUSH
46571: LD_EXP 55
46575: PPUSH
46576: LD_VAR 0 3
46580: PUSH
46581: LD_EXP 55
46585: PUSH
46586: LD_VAR 0 3
46590: ARRAY
46591: PUSH
46592: LD_INT 1
46594: PLUS
46595: PUSH
46596: EMPTY
46597: LIST
46598: LIST
46599: PPUSH
46600: LD_VAR 0 5
46604: PUSH
46605: LD_VAR 0 1
46609: PPUSH
46610: CALL_OW 250
46614: PUSH
46615: LD_VAR 0 1
46619: PPUSH
46620: CALL_OW 251
46624: PUSH
46625: LD_VAR 0 1
46629: PPUSH
46630: CALL_OW 254
46634: PUSH
46635: EMPTY
46636: LIST
46637: LIST
46638: LIST
46639: LIST
46640: PPUSH
46641: CALL 53831 0 3
46645: ST_TO_ADDR
// if pos = 1 then
46646: LD_VAR 0 6
46650: PUSH
46651: LD_INT 1
46653: EQUAL
46654: IFFALSE 46769
// begin tmp := mc_build_list [ i ] ;
46656: LD_ADDR_VAR 0 7
46660: PUSH
46661: LD_EXP 55
46665: PUSH
46666: LD_VAR 0 3
46670: ARRAY
46671: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
46672: LD_VAR 0 7
46676: PPUSH
46677: LD_INT 2
46679: PUSH
46680: LD_INT 30
46682: PUSH
46683: LD_INT 0
46685: PUSH
46686: EMPTY
46687: LIST
46688: LIST
46689: PUSH
46690: LD_INT 30
46692: PUSH
46693: LD_INT 1
46695: PUSH
46696: EMPTY
46697: LIST
46698: LIST
46699: PUSH
46700: EMPTY
46701: LIST
46702: LIST
46703: LIST
46704: PPUSH
46705: CALL_OW 72
46709: IFFALSE 46719
// pos := 2 ;
46711: LD_ADDR_VAR 0 6
46715: PUSH
46716: LD_INT 2
46718: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
46719: LD_ADDR_VAR 0 7
46723: PUSH
46724: LD_VAR 0 7
46728: PPUSH
46729: LD_VAR 0 6
46733: PPUSH
46734: LD_VAR 0 7
46738: PPUSH
46739: CALL 54157 0 3
46743: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
46744: LD_ADDR_EXP 55
46748: PUSH
46749: LD_EXP 55
46753: PPUSH
46754: LD_VAR 0 3
46758: PPUSH
46759: LD_VAR 0 7
46763: PPUSH
46764: CALL_OW 1
46768: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
46769: LD_VAR 0 1
46773: PUSH
46774: LD_EXP 50
46778: PUSH
46779: LD_VAR 0 3
46783: ARRAY
46784: IN
46785: IFFALSE 46824
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
46787: LD_ADDR_EXP 50
46791: PUSH
46792: LD_EXP 50
46796: PPUSH
46797: LD_VAR 0 3
46801: PPUSH
46802: LD_EXP 50
46806: PUSH
46807: LD_VAR 0 3
46811: ARRAY
46812: PUSH
46813: LD_VAR 0 1
46817: DIFF
46818: PPUSH
46819: CALL_OW 1
46823: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
46824: LD_VAR 0 1
46828: PUSH
46829: LD_EXP 57
46833: PUSH
46834: LD_VAR 0 3
46838: ARRAY
46839: IN
46840: IFFALSE 46879
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
46842: LD_ADDR_EXP 57
46846: PUSH
46847: LD_EXP 57
46851: PPUSH
46852: LD_VAR 0 3
46856: PPUSH
46857: LD_EXP 57
46861: PUSH
46862: LD_VAR 0 3
46866: ARRAY
46867: PUSH
46868: LD_VAR 0 1
46872: DIFF
46873: PPUSH
46874: CALL_OW 1
46878: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
46879: LD_VAR 0 1
46883: PUSH
46884: LD_EXP 69
46888: PUSH
46889: LD_VAR 0 3
46893: ARRAY
46894: IN
46895: IFFALSE 46934
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
46897: LD_ADDR_EXP 69
46901: PUSH
46902: LD_EXP 69
46906: PPUSH
46907: LD_VAR 0 3
46911: PPUSH
46912: LD_EXP 69
46916: PUSH
46917: LD_VAR 0 3
46921: ARRAY
46922: PUSH
46923: LD_VAR 0 1
46927: DIFF
46928: PPUSH
46929: CALL_OW 1
46933: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
46934: LD_VAR 0 1
46938: PUSH
46939: LD_EXP 72
46943: PUSH
46944: LD_VAR 0 3
46948: ARRAY
46949: IN
46950: IFFALSE 46989
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
46952: LD_ADDR_EXP 72
46956: PUSH
46957: LD_EXP 72
46961: PPUSH
46962: LD_VAR 0 3
46966: PPUSH
46967: LD_EXP 72
46971: PUSH
46972: LD_VAR 0 3
46976: ARRAY
46977: PUSH
46978: LD_VAR 0 1
46982: DIFF
46983: PPUSH
46984: CALL_OW 1
46988: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
46989: LD_VAR 0 1
46993: PUSH
46994: LD_EXP 59
46998: PUSH
46999: LD_VAR 0 3
47003: ARRAY
47004: IN
47005: IFFALSE 47044
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
47007: LD_ADDR_EXP 59
47011: PUSH
47012: LD_EXP 59
47016: PPUSH
47017: LD_VAR 0 3
47021: PPUSH
47022: LD_EXP 59
47026: PUSH
47027: LD_VAR 0 3
47031: ARRAY
47032: PUSH
47033: LD_VAR 0 1
47037: DIFF
47038: PPUSH
47039: CALL_OW 1
47043: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
47044: LD_VAR 0 1
47048: PUSH
47049: LD_EXP 58
47053: PUSH
47054: LD_VAR 0 3
47058: ARRAY
47059: IN
47060: IFFALSE 47099
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
47062: LD_ADDR_EXP 58
47066: PUSH
47067: LD_EXP 58
47071: PPUSH
47072: LD_VAR 0 3
47076: PPUSH
47077: LD_EXP 58
47081: PUSH
47082: LD_VAR 0 3
47086: ARRAY
47087: PUSH
47088: LD_VAR 0 1
47092: DIFF
47093: PPUSH
47094: CALL_OW 1
47098: ST_TO_ADDR
// end ; break ;
47099: GO 47103
// end ;
47101: GO 45751
47103: POP
47104: POP
// end ;
47105: LD_VAR 0 2
47109: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
47110: LD_INT 0
47112: PPUSH
47113: PPUSH
47114: PPUSH
// if not mc_bases or not skirmish then
47115: LD_EXP 50
47119: NOT
47120: PUSH
47121: LD_EXP 48
47125: NOT
47126: OR
47127: IFFALSE 47131
// exit ;
47129: GO 47346
// for i = 1 to mc_bases do
47131: LD_ADDR_VAR 0 3
47135: PUSH
47136: DOUBLE
47137: LD_INT 1
47139: DEC
47140: ST_TO_ADDR
47141: LD_EXP 50
47145: PUSH
47146: FOR_TO
47147: IFFALSE 47344
// begin if building in mc_construct_list [ i ] then
47149: LD_VAR 0 1
47153: PUSH
47154: LD_EXP 57
47158: PUSH
47159: LD_VAR 0 3
47163: ARRAY
47164: IN
47165: IFFALSE 47342
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
47167: LD_ADDR_EXP 57
47171: PUSH
47172: LD_EXP 57
47176: PPUSH
47177: LD_VAR 0 3
47181: PPUSH
47182: LD_EXP 57
47186: PUSH
47187: LD_VAR 0 3
47191: ARRAY
47192: PUSH
47193: LD_VAR 0 1
47197: DIFF
47198: PPUSH
47199: CALL_OW 1
47203: ST_TO_ADDR
// if building in mc_lab [ i ] then
47204: LD_VAR 0 1
47208: PUSH
47209: LD_EXP 83
47213: PUSH
47214: LD_VAR 0 3
47218: ARRAY
47219: IN
47220: IFFALSE 47275
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
47222: LD_ADDR_EXP 84
47226: PUSH
47227: LD_EXP 84
47231: PPUSH
47232: LD_VAR 0 3
47236: PPUSH
47237: LD_EXP 84
47241: PUSH
47242: LD_VAR 0 3
47246: ARRAY
47247: PPUSH
47248: LD_INT 1
47250: PPUSH
47251: LD_EXP 84
47255: PUSH
47256: LD_VAR 0 3
47260: ARRAY
47261: PPUSH
47262: LD_INT 0
47264: PPUSH
47265: CALL 53249 0 4
47269: PPUSH
47270: CALL_OW 1
47274: ST_TO_ADDR
// if not building in mc_bases [ i ] then
47275: LD_VAR 0 1
47279: PUSH
47280: LD_EXP 50
47284: PUSH
47285: LD_VAR 0 3
47289: ARRAY
47290: IN
47291: NOT
47292: IFFALSE 47338
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
47294: LD_ADDR_EXP 50
47298: PUSH
47299: LD_EXP 50
47303: PPUSH
47304: LD_VAR 0 3
47308: PUSH
47309: LD_EXP 50
47313: PUSH
47314: LD_VAR 0 3
47318: ARRAY
47319: PUSH
47320: LD_INT 1
47322: PLUS
47323: PUSH
47324: EMPTY
47325: LIST
47326: LIST
47327: PPUSH
47328: LD_VAR 0 1
47332: PPUSH
47333: CALL 53831 0 3
47337: ST_TO_ADDR
// exit ;
47338: POP
47339: POP
47340: GO 47346
// end ; end ;
47342: GO 47146
47344: POP
47345: POP
// end ;
47346: LD_VAR 0 2
47350: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
47351: LD_INT 0
47353: PPUSH
47354: PPUSH
47355: PPUSH
47356: PPUSH
47357: PPUSH
47358: PPUSH
47359: PPUSH
// if not mc_bases or not skirmish then
47360: LD_EXP 50
47364: NOT
47365: PUSH
47366: LD_EXP 48
47370: NOT
47371: OR
47372: IFFALSE 47376
// exit ;
47374: GO 48037
// for i = 1 to mc_bases do
47376: LD_ADDR_VAR 0 3
47380: PUSH
47381: DOUBLE
47382: LD_INT 1
47384: DEC
47385: ST_TO_ADDR
47386: LD_EXP 50
47390: PUSH
47391: FOR_TO
47392: IFFALSE 48035
// begin if building in mc_construct_list [ i ] then
47394: LD_VAR 0 1
47398: PUSH
47399: LD_EXP 57
47403: PUSH
47404: LD_VAR 0 3
47408: ARRAY
47409: IN
47410: IFFALSE 48033
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
47412: LD_ADDR_EXP 57
47416: PUSH
47417: LD_EXP 57
47421: PPUSH
47422: LD_VAR 0 3
47426: PPUSH
47427: LD_EXP 57
47431: PUSH
47432: LD_VAR 0 3
47436: ARRAY
47437: PUSH
47438: LD_VAR 0 1
47442: DIFF
47443: PPUSH
47444: CALL_OW 1
47448: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
47449: LD_ADDR_EXP 50
47453: PUSH
47454: LD_EXP 50
47458: PPUSH
47459: LD_VAR 0 3
47463: PUSH
47464: LD_EXP 50
47468: PUSH
47469: LD_VAR 0 3
47473: ARRAY
47474: PUSH
47475: LD_INT 1
47477: PLUS
47478: PUSH
47479: EMPTY
47480: LIST
47481: LIST
47482: PPUSH
47483: LD_VAR 0 1
47487: PPUSH
47488: CALL 53831 0 3
47492: ST_TO_ADDR
// btype := GetBType ( building ) ;
47493: LD_ADDR_VAR 0 5
47497: PUSH
47498: LD_VAR 0 1
47502: PPUSH
47503: CALL_OW 266
47507: ST_TO_ADDR
// side := GetSide ( building ) ;
47508: LD_ADDR_VAR 0 8
47512: PUSH
47513: LD_VAR 0 1
47517: PPUSH
47518: CALL_OW 255
47522: ST_TO_ADDR
// if btype = b_lab then
47523: LD_VAR 0 5
47527: PUSH
47528: LD_INT 6
47530: EQUAL
47531: IFFALSE 47581
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
47533: LD_ADDR_EXP 83
47537: PUSH
47538: LD_EXP 83
47542: PPUSH
47543: LD_VAR 0 3
47547: PUSH
47548: LD_EXP 83
47552: PUSH
47553: LD_VAR 0 3
47557: ARRAY
47558: PUSH
47559: LD_INT 1
47561: PLUS
47562: PUSH
47563: EMPTY
47564: LIST
47565: LIST
47566: PPUSH
47567: LD_VAR 0 1
47571: PPUSH
47572: CALL 53831 0 3
47576: ST_TO_ADDR
// exit ;
47577: POP
47578: POP
47579: GO 48037
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
47581: LD_VAR 0 5
47585: PUSH
47586: LD_INT 0
47588: PUSH
47589: LD_INT 2
47591: PUSH
47592: LD_INT 4
47594: PUSH
47595: EMPTY
47596: LIST
47597: LIST
47598: LIST
47599: IN
47600: IFFALSE 47724
// begin if btype = b_armoury then
47602: LD_VAR 0 5
47606: PUSH
47607: LD_INT 4
47609: EQUAL
47610: IFFALSE 47620
// btype := b_barracks ;
47612: LD_ADDR_VAR 0 5
47616: PUSH
47617: LD_INT 5
47619: ST_TO_ADDR
// if btype = b_depot then
47620: LD_VAR 0 5
47624: PUSH
47625: LD_INT 0
47627: EQUAL
47628: IFFALSE 47638
// btype := b_warehouse ;
47630: LD_ADDR_VAR 0 5
47634: PUSH
47635: LD_INT 1
47637: ST_TO_ADDR
// if btype = b_workshop then
47638: LD_VAR 0 5
47642: PUSH
47643: LD_INT 2
47645: EQUAL
47646: IFFALSE 47656
// btype := b_factory ;
47648: LD_ADDR_VAR 0 5
47652: PUSH
47653: LD_INT 3
47655: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
47656: LD_VAR 0 5
47660: PPUSH
47661: LD_VAR 0 8
47665: PPUSH
47666: CALL_OW 323
47670: PUSH
47671: LD_INT 1
47673: EQUAL
47674: IFFALSE 47720
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
47676: LD_ADDR_EXP 82
47680: PUSH
47681: LD_EXP 82
47685: PPUSH
47686: LD_VAR 0 3
47690: PUSH
47691: LD_EXP 82
47695: PUSH
47696: LD_VAR 0 3
47700: ARRAY
47701: PUSH
47702: LD_INT 1
47704: PLUS
47705: PUSH
47706: EMPTY
47707: LIST
47708: LIST
47709: PPUSH
47710: LD_VAR 0 1
47714: PPUSH
47715: CALL 53831 0 3
47719: ST_TO_ADDR
// exit ;
47720: POP
47721: POP
47722: GO 48037
// end ; if btype in [ b_bunker , b_turret ] then
47724: LD_VAR 0 5
47728: PUSH
47729: LD_INT 32
47731: PUSH
47732: LD_INT 33
47734: PUSH
47735: EMPTY
47736: LIST
47737: LIST
47738: IN
47739: IFFALSE 48029
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
47741: LD_ADDR_EXP 58
47745: PUSH
47746: LD_EXP 58
47750: PPUSH
47751: LD_VAR 0 3
47755: PUSH
47756: LD_EXP 58
47760: PUSH
47761: LD_VAR 0 3
47765: ARRAY
47766: PUSH
47767: LD_INT 1
47769: PLUS
47770: PUSH
47771: EMPTY
47772: LIST
47773: LIST
47774: PPUSH
47775: LD_VAR 0 1
47779: PPUSH
47780: CALL 53831 0 3
47784: ST_TO_ADDR
// if btype = b_bunker then
47785: LD_VAR 0 5
47789: PUSH
47790: LD_INT 32
47792: EQUAL
47793: IFFALSE 48029
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
47795: LD_ADDR_EXP 59
47799: PUSH
47800: LD_EXP 59
47804: PPUSH
47805: LD_VAR 0 3
47809: PUSH
47810: LD_EXP 59
47814: PUSH
47815: LD_VAR 0 3
47819: ARRAY
47820: PUSH
47821: LD_INT 1
47823: PLUS
47824: PUSH
47825: EMPTY
47826: LIST
47827: LIST
47828: PPUSH
47829: LD_VAR 0 1
47833: PPUSH
47834: CALL 53831 0 3
47838: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
47839: LD_ADDR_VAR 0 6
47843: PUSH
47844: LD_EXP 50
47848: PUSH
47849: LD_VAR 0 3
47853: ARRAY
47854: PPUSH
47855: LD_INT 25
47857: PUSH
47858: LD_INT 1
47860: PUSH
47861: EMPTY
47862: LIST
47863: LIST
47864: PUSH
47865: LD_INT 3
47867: PUSH
47868: LD_INT 54
47870: PUSH
47871: EMPTY
47872: LIST
47873: PUSH
47874: EMPTY
47875: LIST
47876: LIST
47877: PUSH
47878: EMPTY
47879: LIST
47880: LIST
47881: PPUSH
47882: CALL_OW 72
47886: ST_TO_ADDR
// if tmp then
47887: LD_VAR 0 6
47891: IFFALSE 47897
// exit ;
47893: POP
47894: POP
47895: GO 48037
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
47897: LD_ADDR_VAR 0 6
47901: PUSH
47902: LD_EXP 50
47906: PUSH
47907: LD_VAR 0 3
47911: ARRAY
47912: PPUSH
47913: LD_INT 2
47915: PUSH
47916: LD_INT 30
47918: PUSH
47919: LD_INT 4
47921: PUSH
47922: EMPTY
47923: LIST
47924: LIST
47925: PUSH
47926: LD_INT 30
47928: PUSH
47929: LD_INT 5
47931: PUSH
47932: EMPTY
47933: LIST
47934: LIST
47935: PUSH
47936: EMPTY
47937: LIST
47938: LIST
47939: LIST
47940: PPUSH
47941: CALL_OW 72
47945: ST_TO_ADDR
// if not tmp then
47946: LD_VAR 0 6
47950: NOT
47951: IFFALSE 47957
// exit ;
47953: POP
47954: POP
47955: GO 48037
// for j in tmp do
47957: LD_ADDR_VAR 0 4
47961: PUSH
47962: LD_VAR 0 6
47966: PUSH
47967: FOR_IN
47968: IFFALSE 48027
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
47970: LD_ADDR_VAR 0 7
47974: PUSH
47975: LD_VAR 0 4
47979: PPUSH
47980: CALL_OW 313
47984: PPUSH
47985: LD_INT 25
47987: PUSH
47988: LD_INT 1
47990: PUSH
47991: EMPTY
47992: LIST
47993: LIST
47994: PPUSH
47995: CALL_OW 72
47999: ST_TO_ADDR
// if units then
48000: LD_VAR 0 7
48004: IFFALSE 48025
// begin ComExitBuilding ( units [ 1 ] ) ;
48006: LD_VAR 0 7
48010: PUSH
48011: LD_INT 1
48013: ARRAY
48014: PPUSH
48015: CALL_OW 122
// exit ;
48019: POP
48020: POP
48021: POP
48022: POP
48023: GO 48037
// end ; end ;
48025: GO 47967
48027: POP
48028: POP
// end ; end ; exit ;
48029: POP
48030: POP
48031: GO 48037
// end ; end ;
48033: GO 47391
48035: POP
48036: POP
// end ;
48037: LD_VAR 0 2
48041: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
48042: LD_INT 0
48044: PPUSH
48045: PPUSH
48046: PPUSH
48047: PPUSH
48048: PPUSH
48049: PPUSH
48050: PPUSH
// if not mc_bases or not skirmish then
48051: LD_EXP 50
48055: NOT
48056: PUSH
48057: LD_EXP 48
48061: NOT
48062: OR
48063: IFFALSE 48067
// exit ;
48065: GO 48332
// btype := GetBType ( building ) ;
48067: LD_ADDR_VAR 0 6
48071: PUSH
48072: LD_VAR 0 1
48076: PPUSH
48077: CALL_OW 266
48081: ST_TO_ADDR
// x := GetX ( building ) ;
48082: LD_ADDR_VAR 0 7
48086: PUSH
48087: LD_VAR 0 1
48091: PPUSH
48092: CALL_OW 250
48096: ST_TO_ADDR
// y := GetY ( building ) ;
48097: LD_ADDR_VAR 0 8
48101: PUSH
48102: LD_VAR 0 1
48106: PPUSH
48107: CALL_OW 251
48111: ST_TO_ADDR
// d := GetDir ( building ) ;
48112: LD_ADDR_VAR 0 9
48116: PUSH
48117: LD_VAR 0 1
48121: PPUSH
48122: CALL_OW 254
48126: ST_TO_ADDR
// for i = 1 to mc_bases do
48127: LD_ADDR_VAR 0 4
48131: PUSH
48132: DOUBLE
48133: LD_INT 1
48135: DEC
48136: ST_TO_ADDR
48137: LD_EXP 50
48141: PUSH
48142: FOR_TO
48143: IFFALSE 48330
// begin if not mc_build_list [ i ] then
48145: LD_EXP 55
48149: PUSH
48150: LD_VAR 0 4
48154: ARRAY
48155: NOT
48156: IFFALSE 48160
// continue ;
48158: GO 48142
// for j := 1 to mc_build_list [ i ] do
48160: LD_ADDR_VAR 0 5
48164: PUSH
48165: DOUBLE
48166: LD_INT 1
48168: DEC
48169: ST_TO_ADDR
48170: LD_EXP 55
48174: PUSH
48175: LD_VAR 0 4
48179: ARRAY
48180: PUSH
48181: FOR_TO
48182: IFFALSE 48326
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
48184: LD_VAR 0 6
48188: PUSH
48189: LD_VAR 0 7
48193: PUSH
48194: LD_VAR 0 8
48198: PUSH
48199: LD_VAR 0 9
48203: PUSH
48204: EMPTY
48205: LIST
48206: LIST
48207: LIST
48208: LIST
48209: PPUSH
48210: LD_EXP 55
48214: PUSH
48215: LD_VAR 0 4
48219: ARRAY
48220: PUSH
48221: LD_VAR 0 5
48225: ARRAY
48226: PPUSH
48227: CALL 60011 0 2
48231: IFFALSE 48324
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
48233: LD_ADDR_EXP 55
48237: PUSH
48238: LD_EXP 55
48242: PPUSH
48243: LD_VAR 0 4
48247: PPUSH
48248: LD_EXP 55
48252: PUSH
48253: LD_VAR 0 4
48257: ARRAY
48258: PPUSH
48259: LD_VAR 0 5
48263: PPUSH
48264: CALL_OW 3
48268: PPUSH
48269: CALL_OW 1
48273: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
48274: LD_ADDR_EXP 57
48278: PUSH
48279: LD_EXP 57
48283: PPUSH
48284: LD_VAR 0 4
48288: PUSH
48289: LD_EXP 57
48293: PUSH
48294: LD_VAR 0 4
48298: ARRAY
48299: PUSH
48300: LD_INT 1
48302: PLUS
48303: PUSH
48304: EMPTY
48305: LIST
48306: LIST
48307: PPUSH
48308: LD_VAR 0 1
48312: PPUSH
48313: CALL 53831 0 3
48317: ST_TO_ADDR
// exit ;
48318: POP
48319: POP
48320: POP
48321: POP
48322: GO 48332
// end ;
48324: GO 48181
48326: POP
48327: POP
// end ;
48328: GO 48142
48330: POP
48331: POP
// end ;
48332: LD_VAR 0 3
48336: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
48337: LD_INT 0
48339: PPUSH
48340: PPUSH
48341: PPUSH
// if not mc_bases or not skirmish then
48342: LD_EXP 50
48346: NOT
48347: PUSH
48348: LD_EXP 48
48352: NOT
48353: OR
48354: IFFALSE 48358
// exit ;
48356: GO 48548
// for i = 1 to mc_bases do
48358: LD_ADDR_VAR 0 4
48362: PUSH
48363: DOUBLE
48364: LD_INT 1
48366: DEC
48367: ST_TO_ADDR
48368: LD_EXP 50
48372: PUSH
48373: FOR_TO
48374: IFFALSE 48461
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
48376: LD_VAR 0 1
48380: PUSH
48381: LD_EXP 58
48385: PUSH
48386: LD_VAR 0 4
48390: ARRAY
48391: IN
48392: PUSH
48393: LD_VAR 0 1
48397: PUSH
48398: LD_EXP 59
48402: PUSH
48403: LD_VAR 0 4
48407: ARRAY
48408: IN
48409: NOT
48410: AND
48411: IFFALSE 48459
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
48413: LD_ADDR_EXP 59
48417: PUSH
48418: LD_EXP 59
48422: PPUSH
48423: LD_VAR 0 4
48427: PUSH
48428: LD_EXP 59
48432: PUSH
48433: LD_VAR 0 4
48437: ARRAY
48438: PUSH
48439: LD_INT 1
48441: PLUS
48442: PUSH
48443: EMPTY
48444: LIST
48445: LIST
48446: PPUSH
48447: LD_VAR 0 1
48451: PPUSH
48452: CALL 53831 0 3
48456: ST_TO_ADDR
// break ;
48457: GO 48461
// end ; end ;
48459: GO 48373
48461: POP
48462: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
48463: LD_VAR 0 1
48467: PPUSH
48468: CALL_OW 257
48472: PUSH
48473: LD_EXP 76
48477: IN
48478: PUSH
48479: LD_VAR 0 1
48483: PPUSH
48484: CALL_OW 266
48488: PUSH
48489: LD_INT 5
48491: EQUAL
48492: AND
48493: PUSH
48494: LD_VAR 0 2
48498: PPUSH
48499: CALL_OW 110
48503: PUSH
48504: LD_INT 18
48506: NONEQUAL
48507: AND
48508: IFFALSE 48548
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
48510: LD_VAR 0 2
48514: PPUSH
48515: CALL_OW 257
48519: PUSH
48520: LD_INT 5
48522: PUSH
48523: LD_INT 8
48525: PUSH
48526: LD_INT 9
48528: PUSH
48529: EMPTY
48530: LIST
48531: LIST
48532: LIST
48533: IN
48534: IFFALSE 48548
// SetClass ( unit , 1 ) ;
48536: LD_VAR 0 2
48540: PPUSH
48541: LD_INT 1
48543: PPUSH
48544: CALL_OW 336
// end ;
48548: LD_VAR 0 3
48552: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
48553: LD_INT 0
48555: PPUSH
48556: PPUSH
// if not mc_bases or not skirmish then
48557: LD_EXP 50
48561: NOT
48562: PUSH
48563: LD_EXP 48
48567: NOT
48568: OR
48569: IFFALSE 48573
// exit ;
48571: GO 48689
// if GetLives ( abandoned_vehicle ) > 250 then
48573: LD_VAR 0 2
48577: PPUSH
48578: CALL_OW 256
48582: PUSH
48583: LD_INT 250
48585: GREATER
48586: IFFALSE 48590
// exit ;
48588: GO 48689
// for i = 1 to mc_bases do
48590: LD_ADDR_VAR 0 6
48594: PUSH
48595: DOUBLE
48596: LD_INT 1
48598: DEC
48599: ST_TO_ADDR
48600: LD_EXP 50
48604: PUSH
48605: FOR_TO
48606: IFFALSE 48687
// begin if driver in mc_bases [ i ] then
48608: LD_VAR 0 1
48612: PUSH
48613: LD_EXP 50
48617: PUSH
48618: LD_VAR 0 6
48622: ARRAY
48623: IN
48624: IFFALSE 48685
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
48626: LD_VAR 0 1
48630: PPUSH
48631: LD_EXP 50
48635: PUSH
48636: LD_VAR 0 6
48640: ARRAY
48641: PPUSH
48642: LD_INT 2
48644: PUSH
48645: LD_INT 30
48647: PUSH
48648: LD_INT 0
48650: PUSH
48651: EMPTY
48652: LIST
48653: LIST
48654: PUSH
48655: LD_INT 30
48657: PUSH
48658: LD_INT 1
48660: PUSH
48661: EMPTY
48662: LIST
48663: LIST
48664: PUSH
48665: EMPTY
48666: LIST
48667: LIST
48668: LIST
48669: PPUSH
48670: CALL_OW 72
48674: PUSH
48675: LD_INT 1
48677: ARRAY
48678: PPUSH
48679: CALL 87039 0 2
// break ;
48683: GO 48687
// end ; end ;
48685: GO 48605
48687: POP
48688: POP
// end ; end_of_file
48689: LD_VAR 0 5
48693: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
48694: LD_INT 0
48696: PPUSH
48697: PPUSH
// if exist_mode then
48698: LD_VAR 0 2
48702: IFFALSE 48727
// unit := CreateCharacter ( prefix & ident ) else
48704: LD_ADDR_VAR 0 5
48708: PUSH
48709: LD_VAR 0 3
48713: PUSH
48714: LD_VAR 0 1
48718: STR
48719: PPUSH
48720: CALL_OW 34
48724: ST_TO_ADDR
48725: GO 48742
// unit := NewCharacter ( ident ) ;
48727: LD_ADDR_VAR 0 5
48731: PUSH
48732: LD_VAR 0 1
48736: PPUSH
48737: CALL_OW 25
48741: ST_TO_ADDR
// result := unit ;
48742: LD_ADDR_VAR 0 4
48746: PUSH
48747: LD_VAR 0 5
48751: ST_TO_ADDR
// end ;
48752: LD_VAR 0 4
48756: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
48757: LD_INT 0
48759: PPUSH
48760: PPUSH
// if not side or not nation then
48761: LD_VAR 0 1
48765: NOT
48766: PUSH
48767: LD_VAR 0 2
48771: NOT
48772: OR
48773: IFFALSE 48777
// exit ;
48775: GO 49545
// case nation of nation_american :
48777: LD_VAR 0 2
48781: PUSH
48782: LD_INT 1
48784: DOUBLE
48785: EQUAL
48786: IFTRUE 48790
48788: GO 49004
48790: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
48791: LD_ADDR_VAR 0 4
48795: PUSH
48796: LD_INT 35
48798: PUSH
48799: LD_INT 45
48801: PUSH
48802: LD_INT 46
48804: PUSH
48805: LD_INT 47
48807: PUSH
48808: LD_INT 82
48810: PUSH
48811: LD_INT 83
48813: PUSH
48814: LD_INT 84
48816: PUSH
48817: LD_INT 85
48819: PUSH
48820: LD_INT 86
48822: PUSH
48823: LD_INT 1
48825: PUSH
48826: LD_INT 2
48828: PUSH
48829: LD_INT 6
48831: PUSH
48832: LD_INT 15
48834: PUSH
48835: LD_INT 16
48837: PUSH
48838: LD_INT 7
48840: PUSH
48841: LD_INT 12
48843: PUSH
48844: LD_INT 13
48846: PUSH
48847: LD_INT 10
48849: PUSH
48850: LD_INT 14
48852: PUSH
48853: LD_INT 20
48855: PUSH
48856: LD_INT 21
48858: PUSH
48859: LD_INT 22
48861: PUSH
48862: LD_INT 25
48864: PUSH
48865: LD_INT 32
48867: PUSH
48868: LD_INT 27
48870: PUSH
48871: LD_INT 36
48873: PUSH
48874: LD_INT 69
48876: PUSH
48877: LD_INT 39
48879: PUSH
48880: LD_INT 34
48882: PUSH
48883: LD_INT 40
48885: PUSH
48886: LD_INT 48
48888: PUSH
48889: LD_INT 49
48891: PUSH
48892: LD_INT 50
48894: PUSH
48895: LD_INT 51
48897: PUSH
48898: LD_INT 52
48900: PUSH
48901: LD_INT 53
48903: PUSH
48904: LD_INT 54
48906: PUSH
48907: LD_INT 55
48909: PUSH
48910: LD_INT 56
48912: PUSH
48913: LD_INT 57
48915: PUSH
48916: LD_INT 58
48918: PUSH
48919: LD_INT 59
48921: PUSH
48922: LD_INT 60
48924: PUSH
48925: LD_INT 61
48927: PUSH
48928: LD_INT 62
48930: PUSH
48931: LD_INT 80
48933: PUSH
48934: LD_INT 82
48936: PUSH
48937: LD_INT 83
48939: PUSH
48940: LD_INT 84
48942: PUSH
48943: LD_INT 85
48945: PUSH
48946: LD_INT 86
48948: PUSH
48949: EMPTY
48950: LIST
48951: LIST
48952: LIST
48953: LIST
48954: LIST
48955: LIST
48956: LIST
48957: LIST
48958: LIST
48959: LIST
48960: LIST
48961: LIST
48962: LIST
48963: LIST
48964: LIST
48965: LIST
48966: LIST
48967: LIST
48968: LIST
48969: LIST
48970: LIST
48971: LIST
48972: LIST
48973: LIST
48974: LIST
48975: LIST
48976: LIST
48977: LIST
48978: LIST
48979: LIST
48980: LIST
48981: LIST
48982: LIST
48983: LIST
48984: LIST
48985: LIST
48986: LIST
48987: LIST
48988: LIST
48989: LIST
48990: LIST
48991: LIST
48992: LIST
48993: LIST
48994: LIST
48995: LIST
48996: LIST
48997: LIST
48998: LIST
48999: LIST
49000: LIST
49001: ST_TO_ADDR
49002: GO 49469
49004: LD_INT 2
49006: DOUBLE
49007: EQUAL
49008: IFTRUE 49012
49010: GO 49238
49012: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
49013: LD_ADDR_VAR 0 4
49017: PUSH
49018: LD_INT 35
49020: PUSH
49021: LD_INT 45
49023: PUSH
49024: LD_INT 46
49026: PUSH
49027: LD_INT 47
49029: PUSH
49030: LD_INT 82
49032: PUSH
49033: LD_INT 83
49035: PUSH
49036: LD_INT 84
49038: PUSH
49039: LD_INT 85
49041: PUSH
49042: LD_INT 87
49044: PUSH
49045: LD_INT 70
49047: PUSH
49048: LD_INT 1
49050: PUSH
49051: LD_INT 11
49053: PUSH
49054: LD_INT 3
49056: PUSH
49057: LD_INT 4
49059: PUSH
49060: LD_INT 5
49062: PUSH
49063: LD_INT 6
49065: PUSH
49066: LD_INT 15
49068: PUSH
49069: LD_INT 18
49071: PUSH
49072: LD_INT 7
49074: PUSH
49075: LD_INT 17
49077: PUSH
49078: LD_INT 8
49080: PUSH
49081: LD_INT 20
49083: PUSH
49084: LD_INT 21
49086: PUSH
49087: LD_INT 22
49089: PUSH
49090: LD_INT 72
49092: PUSH
49093: LD_INT 26
49095: PUSH
49096: LD_INT 69
49098: PUSH
49099: LD_INT 39
49101: PUSH
49102: LD_INT 40
49104: PUSH
49105: LD_INT 41
49107: PUSH
49108: LD_INT 42
49110: PUSH
49111: LD_INT 43
49113: PUSH
49114: LD_INT 48
49116: PUSH
49117: LD_INT 49
49119: PUSH
49120: LD_INT 50
49122: PUSH
49123: LD_INT 51
49125: PUSH
49126: LD_INT 52
49128: PUSH
49129: LD_INT 53
49131: PUSH
49132: LD_INT 54
49134: PUSH
49135: LD_INT 55
49137: PUSH
49138: LD_INT 56
49140: PUSH
49141: LD_INT 60
49143: PUSH
49144: LD_INT 61
49146: PUSH
49147: LD_INT 62
49149: PUSH
49150: LD_INT 66
49152: PUSH
49153: LD_INT 67
49155: PUSH
49156: LD_INT 68
49158: PUSH
49159: LD_INT 81
49161: PUSH
49162: LD_INT 82
49164: PUSH
49165: LD_INT 83
49167: PUSH
49168: LD_INT 84
49170: PUSH
49171: LD_INT 85
49173: PUSH
49174: LD_INT 87
49176: PUSH
49177: LD_INT 88
49179: PUSH
49180: EMPTY
49181: LIST
49182: LIST
49183: LIST
49184: LIST
49185: LIST
49186: LIST
49187: LIST
49188: LIST
49189: LIST
49190: LIST
49191: LIST
49192: LIST
49193: LIST
49194: LIST
49195: LIST
49196: LIST
49197: LIST
49198: LIST
49199: LIST
49200: LIST
49201: LIST
49202: LIST
49203: LIST
49204: LIST
49205: LIST
49206: LIST
49207: LIST
49208: LIST
49209: LIST
49210: LIST
49211: LIST
49212: LIST
49213: LIST
49214: LIST
49215: LIST
49216: LIST
49217: LIST
49218: LIST
49219: LIST
49220: LIST
49221: LIST
49222: LIST
49223: LIST
49224: LIST
49225: LIST
49226: LIST
49227: LIST
49228: LIST
49229: LIST
49230: LIST
49231: LIST
49232: LIST
49233: LIST
49234: LIST
49235: ST_TO_ADDR
49236: GO 49469
49238: LD_INT 3
49240: DOUBLE
49241: EQUAL
49242: IFTRUE 49246
49244: GO 49468
49246: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
49247: LD_ADDR_VAR 0 4
49251: PUSH
49252: LD_INT 46
49254: PUSH
49255: LD_INT 47
49257: PUSH
49258: LD_INT 1
49260: PUSH
49261: LD_INT 2
49263: PUSH
49264: LD_INT 82
49266: PUSH
49267: LD_INT 83
49269: PUSH
49270: LD_INT 84
49272: PUSH
49273: LD_INT 85
49275: PUSH
49276: LD_INT 86
49278: PUSH
49279: LD_INT 11
49281: PUSH
49282: LD_INT 9
49284: PUSH
49285: LD_INT 20
49287: PUSH
49288: LD_INT 19
49290: PUSH
49291: LD_INT 21
49293: PUSH
49294: LD_INT 24
49296: PUSH
49297: LD_INT 22
49299: PUSH
49300: LD_INT 25
49302: PUSH
49303: LD_INT 28
49305: PUSH
49306: LD_INT 29
49308: PUSH
49309: LD_INT 30
49311: PUSH
49312: LD_INT 31
49314: PUSH
49315: LD_INT 37
49317: PUSH
49318: LD_INT 38
49320: PUSH
49321: LD_INT 32
49323: PUSH
49324: LD_INT 27
49326: PUSH
49327: LD_INT 33
49329: PUSH
49330: LD_INT 69
49332: PUSH
49333: LD_INT 39
49335: PUSH
49336: LD_INT 34
49338: PUSH
49339: LD_INT 40
49341: PUSH
49342: LD_INT 71
49344: PUSH
49345: LD_INT 23
49347: PUSH
49348: LD_INT 44
49350: PUSH
49351: LD_INT 48
49353: PUSH
49354: LD_INT 49
49356: PUSH
49357: LD_INT 50
49359: PUSH
49360: LD_INT 51
49362: PUSH
49363: LD_INT 52
49365: PUSH
49366: LD_INT 53
49368: PUSH
49369: LD_INT 54
49371: PUSH
49372: LD_INT 55
49374: PUSH
49375: LD_INT 56
49377: PUSH
49378: LD_INT 57
49380: PUSH
49381: LD_INT 58
49383: PUSH
49384: LD_INT 59
49386: PUSH
49387: LD_INT 63
49389: PUSH
49390: LD_INT 64
49392: PUSH
49393: LD_INT 65
49395: PUSH
49396: LD_INT 82
49398: PUSH
49399: LD_INT 83
49401: PUSH
49402: LD_INT 84
49404: PUSH
49405: LD_INT 85
49407: PUSH
49408: LD_INT 86
49410: PUSH
49411: EMPTY
49412: LIST
49413: LIST
49414: LIST
49415: LIST
49416: LIST
49417: LIST
49418: LIST
49419: LIST
49420: LIST
49421: LIST
49422: LIST
49423: LIST
49424: LIST
49425: LIST
49426: LIST
49427: LIST
49428: LIST
49429: LIST
49430: LIST
49431: LIST
49432: LIST
49433: LIST
49434: LIST
49435: LIST
49436: LIST
49437: LIST
49438: LIST
49439: LIST
49440: LIST
49441: LIST
49442: LIST
49443: LIST
49444: LIST
49445: LIST
49446: LIST
49447: LIST
49448: LIST
49449: LIST
49450: LIST
49451: LIST
49452: LIST
49453: LIST
49454: LIST
49455: LIST
49456: LIST
49457: LIST
49458: LIST
49459: LIST
49460: LIST
49461: LIST
49462: LIST
49463: LIST
49464: LIST
49465: ST_TO_ADDR
49466: GO 49469
49468: POP
// if state > - 1 and state < 3 then
49469: LD_VAR 0 3
49473: PUSH
49474: LD_INT 1
49476: NEG
49477: GREATER
49478: PUSH
49479: LD_VAR 0 3
49483: PUSH
49484: LD_INT 3
49486: LESS
49487: AND
49488: IFFALSE 49545
// for i in result do
49490: LD_ADDR_VAR 0 5
49494: PUSH
49495: LD_VAR 0 4
49499: PUSH
49500: FOR_IN
49501: IFFALSE 49543
// if GetTech ( i , side ) <> state then
49503: LD_VAR 0 5
49507: PPUSH
49508: LD_VAR 0 1
49512: PPUSH
49513: CALL_OW 321
49517: PUSH
49518: LD_VAR 0 3
49522: NONEQUAL
49523: IFFALSE 49541
// result := result diff i ;
49525: LD_ADDR_VAR 0 4
49529: PUSH
49530: LD_VAR 0 4
49534: PUSH
49535: LD_VAR 0 5
49539: DIFF
49540: ST_TO_ADDR
49541: GO 49500
49543: POP
49544: POP
// end ;
49545: LD_VAR 0 4
49549: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
49550: LD_INT 0
49552: PPUSH
49553: PPUSH
49554: PPUSH
// result := true ;
49555: LD_ADDR_VAR 0 3
49559: PUSH
49560: LD_INT 1
49562: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
49563: LD_ADDR_VAR 0 5
49567: PUSH
49568: LD_VAR 0 2
49572: PPUSH
49573: CALL_OW 480
49577: ST_TO_ADDR
// if not tmp then
49578: LD_VAR 0 5
49582: NOT
49583: IFFALSE 49587
// exit ;
49585: GO 49636
// for i in tmp do
49587: LD_ADDR_VAR 0 4
49591: PUSH
49592: LD_VAR 0 5
49596: PUSH
49597: FOR_IN
49598: IFFALSE 49634
// if GetTech ( i , side ) <> state_researched then
49600: LD_VAR 0 4
49604: PPUSH
49605: LD_VAR 0 1
49609: PPUSH
49610: CALL_OW 321
49614: PUSH
49615: LD_INT 2
49617: NONEQUAL
49618: IFFALSE 49632
// begin result := false ;
49620: LD_ADDR_VAR 0 3
49624: PUSH
49625: LD_INT 0
49627: ST_TO_ADDR
// exit ;
49628: POP
49629: POP
49630: GO 49636
// end ;
49632: GO 49597
49634: POP
49635: POP
// end ;
49636: LD_VAR 0 3
49640: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
49641: LD_INT 0
49643: PPUSH
49644: PPUSH
49645: PPUSH
49646: PPUSH
49647: PPUSH
49648: PPUSH
49649: PPUSH
49650: PPUSH
49651: PPUSH
49652: PPUSH
49653: PPUSH
49654: PPUSH
49655: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
49656: LD_VAR 0 1
49660: NOT
49661: PUSH
49662: LD_VAR 0 1
49666: PPUSH
49667: CALL_OW 257
49671: PUSH
49672: LD_INT 9
49674: NONEQUAL
49675: OR
49676: IFFALSE 49680
// exit ;
49678: GO 50253
// side := GetSide ( unit ) ;
49680: LD_ADDR_VAR 0 9
49684: PUSH
49685: LD_VAR 0 1
49689: PPUSH
49690: CALL_OW 255
49694: ST_TO_ADDR
// tech_space := tech_spacanom ;
49695: LD_ADDR_VAR 0 12
49699: PUSH
49700: LD_INT 29
49702: ST_TO_ADDR
// tech_time := tech_taurad ;
49703: LD_ADDR_VAR 0 13
49707: PUSH
49708: LD_INT 28
49710: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
49711: LD_ADDR_VAR 0 11
49715: PUSH
49716: LD_VAR 0 1
49720: PPUSH
49721: CALL_OW 310
49725: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
49726: LD_VAR 0 11
49730: PPUSH
49731: CALL_OW 247
49735: PUSH
49736: LD_INT 2
49738: EQUAL
49739: IFFALSE 49743
// exit ;
49741: GO 50253
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
49743: LD_ADDR_VAR 0 8
49747: PUSH
49748: LD_INT 81
49750: PUSH
49751: LD_VAR 0 9
49755: PUSH
49756: EMPTY
49757: LIST
49758: LIST
49759: PUSH
49760: LD_INT 3
49762: PUSH
49763: LD_INT 21
49765: PUSH
49766: LD_INT 3
49768: PUSH
49769: EMPTY
49770: LIST
49771: LIST
49772: PUSH
49773: EMPTY
49774: LIST
49775: LIST
49776: PUSH
49777: EMPTY
49778: LIST
49779: LIST
49780: PPUSH
49781: CALL_OW 69
49785: ST_TO_ADDR
// if not tmp then
49786: LD_VAR 0 8
49790: NOT
49791: IFFALSE 49795
// exit ;
49793: GO 50253
// if in_unit then
49795: LD_VAR 0 11
49799: IFFALSE 49823
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
49801: LD_ADDR_VAR 0 10
49805: PUSH
49806: LD_VAR 0 8
49810: PPUSH
49811: LD_VAR 0 11
49815: PPUSH
49816: CALL_OW 74
49820: ST_TO_ADDR
49821: GO 49843
// enemy := NearestUnitToUnit ( tmp , unit ) ;
49823: LD_ADDR_VAR 0 10
49827: PUSH
49828: LD_VAR 0 8
49832: PPUSH
49833: LD_VAR 0 1
49837: PPUSH
49838: CALL_OW 74
49842: ST_TO_ADDR
// if not enemy then
49843: LD_VAR 0 10
49847: NOT
49848: IFFALSE 49852
// exit ;
49850: GO 50253
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
49852: LD_VAR 0 11
49856: PUSH
49857: LD_VAR 0 11
49861: PPUSH
49862: LD_VAR 0 10
49866: PPUSH
49867: CALL_OW 296
49871: PUSH
49872: LD_INT 13
49874: GREATER
49875: AND
49876: PUSH
49877: LD_VAR 0 1
49881: PPUSH
49882: LD_VAR 0 10
49886: PPUSH
49887: CALL_OW 296
49891: PUSH
49892: LD_INT 12
49894: GREATER
49895: OR
49896: IFFALSE 49900
// exit ;
49898: GO 50253
// missile := [ 1 ] ;
49900: LD_ADDR_VAR 0 14
49904: PUSH
49905: LD_INT 1
49907: PUSH
49908: EMPTY
49909: LIST
49910: ST_TO_ADDR
// if Researched ( side , tech_space ) then
49911: LD_VAR 0 9
49915: PPUSH
49916: LD_VAR 0 12
49920: PPUSH
49921: CALL_OW 325
49925: IFFALSE 49954
// missile := Replace ( missile , missile + 1 , 2 ) ;
49927: LD_ADDR_VAR 0 14
49931: PUSH
49932: LD_VAR 0 14
49936: PPUSH
49937: LD_VAR 0 14
49941: PUSH
49942: LD_INT 1
49944: PLUS
49945: PPUSH
49946: LD_INT 2
49948: PPUSH
49949: CALL_OW 1
49953: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
49954: LD_VAR 0 9
49958: PPUSH
49959: LD_VAR 0 13
49963: PPUSH
49964: CALL_OW 325
49968: PUSH
49969: LD_VAR 0 10
49973: PPUSH
49974: CALL_OW 255
49978: PPUSH
49979: LD_VAR 0 13
49983: PPUSH
49984: CALL_OW 325
49988: NOT
49989: AND
49990: IFFALSE 50019
// missile := Replace ( missile , missile + 1 , 3 ) ;
49992: LD_ADDR_VAR 0 14
49996: PUSH
49997: LD_VAR 0 14
50001: PPUSH
50002: LD_VAR 0 14
50006: PUSH
50007: LD_INT 1
50009: PLUS
50010: PPUSH
50011: LD_INT 3
50013: PPUSH
50014: CALL_OW 1
50018: ST_TO_ADDR
// if missile < 2 then
50019: LD_VAR 0 14
50023: PUSH
50024: LD_INT 2
50026: LESS
50027: IFFALSE 50031
// exit ;
50029: GO 50253
// x := GetX ( enemy ) ;
50031: LD_ADDR_VAR 0 4
50035: PUSH
50036: LD_VAR 0 10
50040: PPUSH
50041: CALL_OW 250
50045: ST_TO_ADDR
// y := GetY ( enemy ) ;
50046: LD_ADDR_VAR 0 5
50050: PUSH
50051: LD_VAR 0 10
50055: PPUSH
50056: CALL_OW 251
50060: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
50061: LD_ADDR_VAR 0 6
50065: PUSH
50066: LD_VAR 0 4
50070: PUSH
50071: LD_INT 1
50073: NEG
50074: PPUSH
50075: LD_INT 1
50077: PPUSH
50078: CALL_OW 12
50082: PLUS
50083: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
50084: LD_ADDR_VAR 0 7
50088: PUSH
50089: LD_VAR 0 5
50093: PUSH
50094: LD_INT 1
50096: NEG
50097: PPUSH
50098: LD_INT 1
50100: PPUSH
50101: CALL_OW 12
50105: PLUS
50106: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
50107: LD_VAR 0 6
50111: PPUSH
50112: LD_VAR 0 7
50116: PPUSH
50117: CALL_OW 488
50121: NOT
50122: IFFALSE 50144
// begin _x := x ;
50124: LD_ADDR_VAR 0 6
50128: PUSH
50129: LD_VAR 0 4
50133: ST_TO_ADDR
// _y := y ;
50134: LD_ADDR_VAR 0 7
50138: PUSH
50139: LD_VAR 0 5
50143: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
50144: LD_ADDR_VAR 0 3
50148: PUSH
50149: LD_INT 1
50151: PPUSH
50152: LD_VAR 0 14
50156: PPUSH
50157: CALL_OW 12
50161: ST_TO_ADDR
// case i of 1 :
50162: LD_VAR 0 3
50166: PUSH
50167: LD_INT 1
50169: DOUBLE
50170: EQUAL
50171: IFTRUE 50175
50173: GO 50192
50175: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
50176: LD_VAR 0 1
50180: PPUSH
50181: LD_VAR 0 10
50185: PPUSH
50186: CALL_OW 115
50190: GO 50253
50192: LD_INT 2
50194: DOUBLE
50195: EQUAL
50196: IFTRUE 50200
50198: GO 50222
50200: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
50201: LD_VAR 0 1
50205: PPUSH
50206: LD_VAR 0 6
50210: PPUSH
50211: LD_VAR 0 7
50215: PPUSH
50216: CALL_OW 153
50220: GO 50253
50222: LD_INT 3
50224: DOUBLE
50225: EQUAL
50226: IFTRUE 50230
50228: GO 50252
50230: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
50231: LD_VAR 0 1
50235: PPUSH
50236: LD_VAR 0 6
50240: PPUSH
50241: LD_VAR 0 7
50245: PPUSH
50246: CALL_OW 154
50250: GO 50253
50252: POP
// end ;
50253: LD_VAR 0 2
50257: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
50258: LD_INT 0
50260: PPUSH
50261: PPUSH
50262: PPUSH
50263: PPUSH
50264: PPUSH
50265: PPUSH
// if not unit or not building then
50266: LD_VAR 0 1
50270: NOT
50271: PUSH
50272: LD_VAR 0 2
50276: NOT
50277: OR
50278: IFFALSE 50282
// exit ;
50280: GO 50440
// x := GetX ( building ) ;
50282: LD_ADDR_VAR 0 5
50286: PUSH
50287: LD_VAR 0 2
50291: PPUSH
50292: CALL_OW 250
50296: ST_TO_ADDR
// y := GetY ( building ) ;
50297: LD_ADDR_VAR 0 6
50301: PUSH
50302: LD_VAR 0 2
50306: PPUSH
50307: CALL_OW 251
50311: ST_TO_ADDR
// for i = 0 to 5 do
50312: LD_ADDR_VAR 0 4
50316: PUSH
50317: DOUBLE
50318: LD_INT 0
50320: DEC
50321: ST_TO_ADDR
50322: LD_INT 5
50324: PUSH
50325: FOR_TO
50326: IFFALSE 50438
// begin _x := ShiftX ( x , i , 3 ) ;
50328: LD_ADDR_VAR 0 7
50332: PUSH
50333: LD_VAR 0 5
50337: PPUSH
50338: LD_VAR 0 4
50342: PPUSH
50343: LD_INT 3
50345: PPUSH
50346: CALL_OW 272
50350: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
50351: LD_ADDR_VAR 0 8
50355: PUSH
50356: LD_VAR 0 6
50360: PPUSH
50361: LD_VAR 0 4
50365: PPUSH
50366: LD_INT 3
50368: PPUSH
50369: CALL_OW 273
50373: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
50374: LD_VAR 0 7
50378: PPUSH
50379: LD_VAR 0 8
50383: PPUSH
50384: CALL_OW 488
50388: NOT
50389: IFFALSE 50393
// continue ;
50391: GO 50325
// if HexInfo ( _x , _y ) = 0 then
50393: LD_VAR 0 7
50397: PPUSH
50398: LD_VAR 0 8
50402: PPUSH
50403: CALL_OW 428
50407: PUSH
50408: LD_INT 0
50410: EQUAL
50411: IFFALSE 50436
// begin ComMoveXY ( unit , _x , _y ) ;
50413: LD_VAR 0 1
50417: PPUSH
50418: LD_VAR 0 7
50422: PPUSH
50423: LD_VAR 0 8
50427: PPUSH
50428: CALL_OW 111
// exit ;
50432: POP
50433: POP
50434: GO 50440
// end ; end ;
50436: GO 50325
50438: POP
50439: POP
// end ;
50440: LD_VAR 0 3
50444: RET
// export function ScanBase ( side , base_area ) ; begin
50445: LD_INT 0
50447: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
50448: LD_ADDR_VAR 0 3
50452: PUSH
50453: LD_VAR 0 2
50457: PPUSH
50458: LD_INT 81
50460: PUSH
50461: LD_VAR 0 1
50465: PUSH
50466: EMPTY
50467: LIST
50468: LIST
50469: PPUSH
50470: CALL_OW 70
50474: ST_TO_ADDR
// end ;
50475: LD_VAR 0 3
50479: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
50480: LD_INT 0
50482: PPUSH
50483: PPUSH
50484: PPUSH
50485: PPUSH
// result := false ;
50486: LD_ADDR_VAR 0 2
50490: PUSH
50491: LD_INT 0
50493: ST_TO_ADDR
// side := GetSide ( unit ) ;
50494: LD_ADDR_VAR 0 3
50498: PUSH
50499: LD_VAR 0 1
50503: PPUSH
50504: CALL_OW 255
50508: ST_TO_ADDR
// nat := GetNation ( unit ) ;
50509: LD_ADDR_VAR 0 4
50513: PUSH
50514: LD_VAR 0 1
50518: PPUSH
50519: CALL_OW 248
50523: ST_TO_ADDR
// case nat of 1 :
50524: LD_VAR 0 4
50528: PUSH
50529: LD_INT 1
50531: DOUBLE
50532: EQUAL
50533: IFTRUE 50537
50535: GO 50548
50537: POP
// tech := tech_lassight ; 2 :
50538: LD_ADDR_VAR 0 5
50542: PUSH
50543: LD_INT 12
50545: ST_TO_ADDR
50546: GO 50587
50548: LD_INT 2
50550: DOUBLE
50551: EQUAL
50552: IFTRUE 50556
50554: GO 50567
50556: POP
// tech := tech_mortar ; 3 :
50557: LD_ADDR_VAR 0 5
50561: PUSH
50562: LD_INT 41
50564: ST_TO_ADDR
50565: GO 50587
50567: LD_INT 3
50569: DOUBLE
50570: EQUAL
50571: IFTRUE 50575
50573: GO 50586
50575: POP
// tech := tech_bazooka ; end ;
50576: LD_ADDR_VAR 0 5
50580: PUSH
50581: LD_INT 44
50583: ST_TO_ADDR
50584: GO 50587
50586: POP
// if Researched ( side , tech ) then
50587: LD_VAR 0 3
50591: PPUSH
50592: LD_VAR 0 5
50596: PPUSH
50597: CALL_OW 325
50601: IFFALSE 50628
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
50603: LD_ADDR_VAR 0 2
50607: PUSH
50608: LD_INT 5
50610: PUSH
50611: LD_INT 8
50613: PUSH
50614: LD_INT 9
50616: PUSH
50617: EMPTY
50618: LIST
50619: LIST
50620: LIST
50621: PUSH
50622: LD_VAR 0 4
50626: ARRAY
50627: ST_TO_ADDR
// end ;
50628: LD_VAR 0 2
50632: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
50633: LD_INT 0
50635: PPUSH
50636: PPUSH
50637: PPUSH
// if not mines then
50638: LD_VAR 0 2
50642: NOT
50643: IFFALSE 50647
// exit ;
50645: GO 50791
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
50647: LD_ADDR_VAR 0 5
50651: PUSH
50652: LD_INT 81
50654: PUSH
50655: LD_VAR 0 1
50659: PUSH
50660: EMPTY
50661: LIST
50662: LIST
50663: PUSH
50664: LD_INT 3
50666: PUSH
50667: LD_INT 21
50669: PUSH
50670: LD_INT 3
50672: PUSH
50673: EMPTY
50674: LIST
50675: LIST
50676: PUSH
50677: EMPTY
50678: LIST
50679: LIST
50680: PUSH
50681: EMPTY
50682: LIST
50683: LIST
50684: PPUSH
50685: CALL_OW 69
50689: ST_TO_ADDR
// for i in mines do
50690: LD_ADDR_VAR 0 4
50694: PUSH
50695: LD_VAR 0 2
50699: PUSH
50700: FOR_IN
50701: IFFALSE 50789
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
50703: LD_VAR 0 4
50707: PUSH
50708: LD_INT 1
50710: ARRAY
50711: PPUSH
50712: LD_VAR 0 4
50716: PUSH
50717: LD_INT 2
50719: ARRAY
50720: PPUSH
50721: CALL_OW 458
50725: NOT
50726: IFFALSE 50730
// continue ;
50728: GO 50700
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
50730: LD_VAR 0 4
50734: PUSH
50735: LD_INT 1
50737: ARRAY
50738: PPUSH
50739: LD_VAR 0 4
50743: PUSH
50744: LD_INT 2
50746: ARRAY
50747: PPUSH
50748: CALL_OW 428
50752: PUSH
50753: LD_VAR 0 5
50757: IN
50758: IFFALSE 50787
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
50760: LD_VAR 0 4
50764: PUSH
50765: LD_INT 1
50767: ARRAY
50768: PPUSH
50769: LD_VAR 0 4
50773: PUSH
50774: LD_INT 2
50776: ARRAY
50777: PPUSH
50778: LD_VAR 0 1
50782: PPUSH
50783: CALL_OW 456
// end ;
50787: GO 50700
50789: POP
50790: POP
// end ;
50791: LD_VAR 0 3
50795: RET
// export function Count ( array ) ; var i ; begin
50796: LD_INT 0
50798: PPUSH
50799: PPUSH
// result := 0 ;
50800: LD_ADDR_VAR 0 2
50804: PUSH
50805: LD_INT 0
50807: ST_TO_ADDR
// for i in array do
50808: LD_ADDR_VAR 0 3
50812: PUSH
50813: LD_VAR 0 1
50817: PUSH
50818: FOR_IN
50819: IFFALSE 50843
// if i then
50821: LD_VAR 0 3
50825: IFFALSE 50841
// result := result + 1 ;
50827: LD_ADDR_VAR 0 2
50831: PUSH
50832: LD_VAR 0 2
50836: PUSH
50837: LD_INT 1
50839: PLUS
50840: ST_TO_ADDR
50841: GO 50818
50843: POP
50844: POP
// end ;
50845: LD_VAR 0 2
50849: RET
// export function IsEmpty ( building ) ; begin
50850: LD_INT 0
50852: PPUSH
// if not building then
50853: LD_VAR 0 1
50857: NOT
50858: IFFALSE 50862
// exit ;
50860: GO 50905
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
50862: LD_ADDR_VAR 0 2
50866: PUSH
50867: LD_VAR 0 1
50871: PUSH
50872: LD_INT 22
50874: PUSH
50875: LD_VAR 0 1
50879: PPUSH
50880: CALL_OW 255
50884: PUSH
50885: EMPTY
50886: LIST
50887: LIST
50888: PUSH
50889: LD_INT 58
50891: PUSH
50892: EMPTY
50893: LIST
50894: PUSH
50895: EMPTY
50896: LIST
50897: LIST
50898: PPUSH
50899: CALL_OW 69
50903: IN
50904: ST_TO_ADDR
// end ;
50905: LD_VAR 0 2
50909: RET
// export function IsNotFull ( building ) ; var places ; begin
50910: LD_INT 0
50912: PPUSH
50913: PPUSH
// if not building then
50914: LD_VAR 0 1
50918: NOT
50919: IFFALSE 50923
// exit ;
50921: GO 51094
// result := false ;
50923: LD_ADDR_VAR 0 2
50927: PUSH
50928: LD_INT 0
50930: ST_TO_ADDR
// places := 0 ;
50931: LD_ADDR_VAR 0 3
50935: PUSH
50936: LD_INT 0
50938: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
50939: LD_VAR 0 1
50943: PPUSH
50944: CALL_OW 266
50948: PUSH
50949: LD_INT 0
50951: DOUBLE
50952: EQUAL
50953: IFTRUE 51011
50955: LD_INT 1
50957: DOUBLE
50958: EQUAL
50959: IFTRUE 51011
50961: LD_INT 6
50963: DOUBLE
50964: EQUAL
50965: IFTRUE 51011
50967: LD_INT 7
50969: DOUBLE
50970: EQUAL
50971: IFTRUE 51011
50973: LD_INT 8
50975: DOUBLE
50976: EQUAL
50977: IFTRUE 51011
50979: LD_INT 4
50981: DOUBLE
50982: EQUAL
50983: IFTRUE 51011
50985: LD_INT 5
50987: DOUBLE
50988: EQUAL
50989: IFTRUE 51011
50991: LD_INT 2
50993: DOUBLE
50994: EQUAL
50995: IFTRUE 51011
50997: LD_INT 3
50999: DOUBLE
51000: EQUAL
51001: IFTRUE 51011
51003: LD_INT 35
51005: DOUBLE
51006: EQUAL
51007: IFTRUE 51011
51009: GO 51022
51011: POP
// places := 6 ; b_bunker , b_breastwork :
51012: LD_ADDR_VAR 0 3
51016: PUSH
51017: LD_INT 6
51019: ST_TO_ADDR
51020: GO 51067
51022: LD_INT 32
51024: DOUBLE
51025: EQUAL
51026: IFTRUE 51036
51028: LD_INT 31
51030: DOUBLE
51031: EQUAL
51032: IFTRUE 51036
51034: GO 51047
51036: POP
// places := 1 ; b_control_tower :
51037: LD_ADDR_VAR 0 3
51041: PUSH
51042: LD_INT 1
51044: ST_TO_ADDR
51045: GO 51067
51047: LD_INT 36
51049: DOUBLE
51050: EQUAL
51051: IFTRUE 51055
51053: GO 51066
51055: POP
// places := 3 ; end ;
51056: LD_ADDR_VAR 0 3
51060: PUSH
51061: LD_INT 3
51063: ST_TO_ADDR
51064: GO 51067
51066: POP
// if places then
51067: LD_VAR 0 3
51071: IFFALSE 51094
// result := UnitsInside ( building ) < places ;
51073: LD_ADDR_VAR 0 2
51077: PUSH
51078: LD_VAR 0 1
51082: PPUSH
51083: CALL_OW 313
51087: PUSH
51088: LD_VAR 0 3
51092: LESS
51093: ST_TO_ADDR
// end ;
51094: LD_VAR 0 2
51098: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
51099: LD_INT 0
51101: PPUSH
51102: PPUSH
51103: PPUSH
51104: PPUSH
// tmp := [ ] ;
51105: LD_ADDR_VAR 0 3
51109: PUSH
51110: EMPTY
51111: ST_TO_ADDR
// list := [ ] ;
51112: LD_ADDR_VAR 0 5
51116: PUSH
51117: EMPTY
51118: ST_TO_ADDR
// for i = 16 to 25 do
51119: LD_ADDR_VAR 0 4
51123: PUSH
51124: DOUBLE
51125: LD_INT 16
51127: DEC
51128: ST_TO_ADDR
51129: LD_INT 25
51131: PUSH
51132: FOR_TO
51133: IFFALSE 51206
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
51135: LD_ADDR_VAR 0 3
51139: PUSH
51140: LD_VAR 0 3
51144: PUSH
51145: LD_INT 22
51147: PUSH
51148: LD_VAR 0 1
51152: PPUSH
51153: CALL_OW 255
51157: PUSH
51158: EMPTY
51159: LIST
51160: LIST
51161: PUSH
51162: LD_INT 91
51164: PUSH
51165: LD_VAR 0 1
51169: PUSH
51170: LD_INT 6
51172: PUSH
51173: EMPTY
51174: LIST
51175: LIST
51176: LIST
51177: PUSH
51178: LD_INT 30
51180: PUSH
51181: LD_VAR 0 4
51185: PUSH
51186: EMPTY
51187: LIST
51188: LIST
51189: PUSH
51190: EMPTY
51191: LIST
51192: LIST
51193: LIST
51194: PUSH
51195: EMPTY
51196: LIST
51197: PPUSH
51198: CALL_OW 69
51202: ADD
51203: ST_TO_ADDR
51204: GO 51132
51206: POP
51207: POP
// for i = 1 to tmp do
51208: LD_ADDR_VAR 0 4
51212: PUSH
51213: DOUBLE
51214: LD_INT 1
51216: DEC
51217: ST_TO_ADDR
51218: LD_VAR 0 3
51222: PUSH
51223: FOR_TO
51224: IFFALSE 51312
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
51226: LD_ADDR_VAR 0 5
51230: PUSH
51231: LD_VAR 0 5
51235: PUSH
51236: LD_VAR 0 3
51240: PUSH
51241: LD_VAR 0 4
51245: ARRAY
51246: PPUSH
51247: CALL_OW 266
51251: PUSH
51252: LD_VAR 0 3
51256: PUSH
51257: LD_VAR 0 4
51261: ARRAY
51262: PPUSH
51263: CALL_OW 250
51267: PUSH
51268: LD_VAR 0 3
51272: PUSH
51273: LD_VAR 0 4
51277: ARRAY
51278: PPUSH
51279: CALL_OW 251
51283: PUSH
51284: LD_VAR 0 3
51288: PUSH
51289: LD_VAR 0 4
51293: ARRAY
51294: PPUSH
51295: CALL_OW 254
51299: PUSH
51300: EMPTY
51301: LIST
51302: LIST
51303: LIST
51304: LIST
51305: PUSH
51306: EMPTY
51307: LIST
51308: ADD
51309: ST_TO_ADDR
51310: GO 51223
51312: POP
51313: POP
// result := list ;
51314: LD_ADDR_VAR 0 2
51318: PUSH
51319: LD_VAR 0 5
51323: ST_TO_ADDR
// end ;
51324: LD_VAR 0 2
51328: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
51329: LD_INT 0
51331: PPUSH
51332: PPUSH
51333: PPUSH
51334: PPUSH
51335: PPUSH
51336: PPUSH
51337: PPUSH
// if not factory then
51338: LD_VAR 0 1
51342: NOT
51343: IFFALSE 51347
// exit ;
51345: GO 51940
// if control = control_apeman then
51347: LD_VAR 0 4
51351: PUSH
51352: LD_INT 5
51354: EQUAL
51355: IFFALSE 51464
// begin tmp := UnitsInside ( factory ) ;
51357: LD_ADDR_VAR 0 8
51361: PUSH
51362: LD_VAR 0 1
51366: PPUSH
51367: CALL_OW 313
51371: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
51372: LD_VAR 0 8
51376: PPUSH
51377: LD_INT 25
51379: PUSH
51380: LD_INT 12
51382: PUSH
51383: EMPTY
51384: LIST
51385: LIST
51386: PPUSH
51387: CALL_OW 72
51391: NOT
51392: IFFALSE 51402
// control := control_manual ;
51394: LD_ADDR_VAR 0 4
51398: PUSH
51399: LD_INT 1
51401: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
51402: LD_ADDR_VAR 0 8
51406: PUSH
51407: LD_VAR 0 1
51411: PPUSH
51412: CALL 51099 0 1
51416: ST_TO_ADDR
// if tmp then
51417: LD_VAR 0 8
51421: IFFALSE 51464
// begin for i in tmp do
51423: LD_ADDR_VAR 0 7
51427: PUSH
51428: LD_VAR 0 8
51432: PUSH
51433: FOR_IN
51434: IFFALSE 51462
// if i [ 1 ] = b_ext_radio then
51436: LD_VAR 0 7
51440: PUSH
51441: LD_INT 1
51443: ARRAY
51444: PUSH
51445: LD_INT 22
51447: EQUAL
51448: IFFALSE 51460
// begin control := control_remote ;
51450: LD_ADDR_VAR 0 4
51454: PUSH
51455: LD_INT 2
51457: ST_TO_ADDR
// break ;
51458: GO 51462
// end ;
51460: GO 51433
51462: POP
51463: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
51464: LD_VAR 0 1
51468: PPUSH
51469: LD_VAR 0 2
51473: PPUSH
51474: LD_VAR 0 3
51478: PPUSH
51479: LD_VAR 0 4
51483: PPUSH
51484: LD_VAR 0 5
51488: PPUSH
51489: CALL_OW 448
51493: IFFALSE 51528
// begin result := [ chassis , engine , control , weapon ] ;
51495: LD_ADDR_VAR 0 6
51499: PUSH
51500: LD_VAR 0 2
51504: PUSH
51505: LD_VAR 0 3
51509: PUSH
51510: LD_VAR 0 4
51514: PUSH
51515: LD_VAR 0 5
51519: PUSH
51520: EMPTY
51521: LIST
51522: LIST
51523: LIST
51524: LIST
51525: ST_TO_ADDR
// exit ;
51526: GO 51940
// end ; _chassis := AvailableChassisList ( factory ) ;
51528: LD_ADDR_VAR 0 9
51532: PUSH
51533: LD_VAR 0 1
51537: PPUSH
51538: CALL_OW 475
51542: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
51543: LD_ADDR_VAR 0 11
51547: PUSH
51548: LD_VAR 0 1
51552: PPUSH
51553: CALL_OW 476
51557: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
51558: LD_ADDR_VAR 0 12
51562: PUSH
51563: LD_VAR 0 1
51567: PPUSH
51568: CALL_OW 477
51572: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
51573: LD_ADDR_VAR 0 10
51577: PUSH
51578: LD_VAR 0 1
51582: PPUSH
51583: CALL_OW 478
51587: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
51588: LD_VAR 0 9
51592: NOT
51593: PUSH
51594: LD_VAR 0 11
51598: NOT
51599: OR
51600: PUSH
51601: LD_VAR 0 12
51605: NOT
51606: OR
51607: PUSH
51608: LD_VAR 0 10
51612: NOT
51613: OR
51614: IFFALSE 51649
// begin result := [ chassis , engine , control , weapon ] ;
51616: LD_ADDR_VAR 0 6
51620: PUSH
51621: LD_VAR 0 2
51625: PUSH
51626: LD_VAR 0 3
51630: PUSH
51631: LD_VAR 0 4
51635: PUSH
51636: LD_VAR 0 5
51640: PUSH
51641: EMPTY
51642: LIST
51643: LIST
51644: LIST
51645: LIST
51646: ST_TO_ADDR
// exit ;
51647: GO 51940
// end ; if not chassis in _chassis then
51649: LD_VAR 0 2
51653: PUSH
51654: LD_VAR 0 9
51658: IN
51659: NOT
51660: IFFALSE 51686
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
51662: LD_ADDR_VAR 0 2
51666: PUSH
51667: LD_VAR 0 9
51671: PUSH
51672: LD_INT 1
51674: PPUSH
51675: LD_VAR 0 9
51679: PPUSH
51680: CALL_OW 12
51684: ARRAY
51685: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
51686: LD_VAR 0 2
51690: PPUSH
51691: LD_VAR 0 3
51695: PPUSH
51696: CALL 51945 0 2
51700: NOT
51701: IFFALSE 51760
// repeat engine := _engine [ 1 ] ;
51703: LD_ADDR_VAR 0 3
51707: PUSH
51708: LD_VAR 0 11
51712: PUSH
51713: LD_INT 1
51715: ARRAY
51716: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
51717: LD_ADDR_VAR 0 11
51721: PUSH
51722: LD_VAR 0 11
51726: PPUSH
51727: LD_INT 1
51729: PPUSH
51730: CALL_OW 3
51734: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
51735: LD_VAR 0 2
51739: PPUSH
51740: LD_VAR 0 3
51744: PPUSH
51745: CALL 51945 0 2
51749: PUSH
51750: LD_VAR 0 11
51754: PUSH
51755: EMPTY
51756: EQUAL
51757: OR
51758: IFFALSE 51703
// if not control in _control then
51760: LD_VAR 0 4
51764: PUSH
51765: LD_VAR 0 12
51769: IN
51770: NOT
51771: IFFALSE 51797
// control := _control [ rand ( 1 , _control ) ] ;
51773: LD_ADDR_VAR 0 4
51777: PUSH
51778: LD_VAR 0 12
51782: PUSH
51783: LD_INT 1
51785: PPUSH
51786: LD_VAR 0 12
51790: PPUSH
51791: CALL_OW 12
51795: ARRAY
51796: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
51797: LD_VAR 0 2
51801: PPUSH
51802: LD_VAR 0 5
51806: PPUSH
51807: CALL 52165 0 2
51811: NOT
51812: IFFALSE 51871
// repeat weapon := _weapon [ 1 ] ;
51814: LD_ADDR_VAR 0 5
51818: PUSH
51819: LD_VAR 0 10
51823: PUSH
51824: LD_INT 1
51826: ARRAY
51827: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
51828: LD_ADDR_VAR 0 10
51832: PUSH
51833: LD_VAR 0 10
51837: PPUSH
51838: LD_INT 1
51840: PPUSH
51841: CALL_OW 3
51845: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
51846: LD_VAR 0 2
51850: PPUSH
51851: LD_VAR 0 5
51855: PPUSH
51856: CALL 52165 0 2
51860: PUSH
51861: LD_VAR 0 10
51865: PUSH
51866: EMPTY
51867: EQUAL
51868: OR
51869: IFFALSE 51814
// result := [ ] ;
51871: LD_ADDR_VAR 0 6
51875: PUSH
51876: EMPTY
51877: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
51878: LD_VAR 0 1
51882: PPUSH
51883: LD_VAR 0 2
51887: PPUSH
51888: LD_VAR 0 3
51892: PPUSH
51893: LD_VAR 0 4
51897: PPUSH
51898: LD_VAR 0 5
51902: PPUSH
51903: CALL_OW 448
51907: IFFALSE 51940
// result := [ chassis , engine , control , weapon ] ;
51909: LD_ADDR_VAR 0 6
51913: PUSH
51914: LD_VAR 0 2
51918: PUSH
51919: LD_VAR 0 3
51923: PUSH
51924: LD_VAR 0 4
51928: PUSH
51929: LD_VAR 0 5
51933: PUSH
51934: EMPTY
51935: LIST
51936: LIST
51937: LIST
51938: LIST
51939: ST_TO_ADDR
// end ;
51940: LD_VAR 0 6
51944: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
51945: LD_INT 0
51947: PPUSH
// if not chassis or not engine then
51948: LD_VAR 0 1
51952: NOT
51953: PUSH
51954: LD_VAR 0 2
51958: NOT
51959: OR
51960: IFFALSE 51964
// exit ;
51962: GO 52160
// case engine of engine_solar :
51964: LD_VAR 0 2
51968: PUSH
51969: LD_INT 2
51971: DOUBLE
51972: EQUAL
51973: IFTRUE 51977
51975: GO 52015
51977: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
51978: LD_ADDR_VAR 0 3
51982: PUSH
51983: LD_INT 11
51985: PUSH
51986: LD_INT 12
51988: PUSH
51989: LD_INT 13
51991: PUSH
51992: LD_INT 14
51994: PUSH
51995: LD_INT 1
51997: PUSH
51998: LD_INT 2
52000: PUSH
52001: LD_INT 3
52003: PUSH
52004: EMPTY
52005: LIST
52006: LIST
52007: LIST
52008: LIST
52009: LIST
52010: LIST
52011: LIST
52012: ST_TO_ADDR
52013: GO 52144
52015: LD_INT 1
52017: DOUBLE
52018: EQUAL
52019: IFTRUE 52023
52021: GO 52085
52023: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
52024: LD_ADDR_VAR 0 3
52028: PUSH
52029: LD_INT 11
52031: PUSH
52032: LD_INT 12
52034: PUSH
52035: LD_INT 13
52037: PUSH
52038: LD_INT 14
52040: PUSH
52041: LD_INT 1
52043: PUSH
52044: LD_INT 2
52046: PUSH
52047: LD_INT 3
52049: PUSH
52050: LD_INT 4
52052: PUSH
52053: LD_INT 5
52055: PUSH
52056: LD_INT 21
52058: PUSH
52059: LD_INT 23
52061: PUSH
52062: LD_INT 22
52064: PUSH
52065: LD_INT 24
52067: PUSH
52068: EMPTY
52069: LIST
52070: LIST
52071: LIST
52072: LIST
52073: LIST
52074: LIST
52075: LIST
52076: LIST
52077: LIST
52078: LIST
52079: LIST
52080: LIST
52081: LIST
52082: ST_TO_ADDR
52083: GO 52144
52085: LD_INT 3
52087: DOUBLE
52088: EQUAL
52089: IFTRUE 52093
52091: GO 52143
52093: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
52094: LD_ADDR_VAR 0 3
52098: PUSH
52099: LD_INT 13
52101: PUSH
52102: LD_INT 14
52104: PUSH
52105: LD_INT 2
52107: PUSH
52108: LD_INT 3
52110: PUSH
52111: LD_INT 4
52113: PUSH
52114: LD_INT 5
52116: PUSH
52117: LD_INT 21
52119: PUSH
52120: LD_INT 22
52122: PUSH
52123: LD_INT 23
52125: PUSH
52126: LD_INT 24
52128: PUSH
52129: EMPTY
52130: LIST
52131: LIST
52132: LIST
52133: LIST
52134: LIST
52135: LIST
52136: LIST
52137: LIST
52138: LIST
52139: LIST
52140: ST_TO_ADDR
52141: GO 52144
52143: POP
// result := ( chassis in result ) ;
52144: LD_ADDR_VAR 0 3
52148: PUSH
52149: LD_VAR 0 1
52153: PUSH
52154: LD_VAR 0 3
52158: IN
52159: ST_TO_ADDR
// end ;
52160: LD_VAR 0 3
52164: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
52165: LD_INT 0
52167: PPUSH
// if not chassis or not weapon then
52168: LD_VAR 0 1
52172: NOT
52173: PUSH
52174: LD_VAR 0 2
52178: NOT
52179: OR
52180: IFFALSE 52184
// exit ;
52182: GO 53244
// case weapon of us_machine_gun :
52184: LD_VAR 0 2
52188: PUSH
52189: LD_INT 2
52191: DOUBLE
52192: EQUAL
52193: IFTRUE 52197
52195: GO 52227
52197: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
52198: LD_ADDR_VAR 0 3
52202: PUSH
52203: LD_INT 1
52205: PUSH
52206: LD_INT 2
52208: PUSH
52209: LD_INT 3
52211: PUSH
52212: LD_INT 4
52214: PUSH
52215: LD_INT 5
52217: PUSH
52218: EMPTY
52219: LIST
52220: LIST
52221: LIST
52222: LIST
52223: LIST
52224: ST_TO_ADDR
52225: GO 53228
52227: LD_INT 3
52229: DOUBLE
52230: EQUAL
52231: IFTRUE 52235
52233: GO 52265
52235: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
52236: LD_ADDR_VAR 0 3
52240: PUSH
52241: LD_INT 1
52243: PUSH
52244: LD_INT 2
52246: PUSH
52247: LD_INT 3
52249: PUSH
52250: LD_INT 4
52252: PUSH
52253: LD_INT 5
52255: PUSH
52256: EMPTY
52257: LIST
52258: LIST
52259: LIST
52260: LIST
52261: LIST
52262: ST_TO_ADDR
52263: GO 53228
52265: LD_INT 11
52267: DOUBLE
52268: EQUAL
52269: IFTRUE 52273
52271: GO 52303
52273: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
52274: LD_ADDR_VAR 0 3
52278: PUSH
52279: LD_INT 1
52281: PUSH
52282: LD_INT 2
52284: PUSH
52285: LD_INT 3
52287: PUSH
52288: LD_INT 4
52290: PUSH
52291: LD_INT 5
52293: PUSH
52294: EMPTY
52295: LIST
52296: LIST
52297: LIST
52298: LIST
52299: LIST
52300: ST_TO_ADDR
52301: GO 53228
52303: LD_INT 4
52305: DOUBLE
52306: EQUAL
52307: IFTRUE 52311
52309: GO 52337
52311: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
52312: LD_ADDR_VAR 0 3
52316: PUSH
52317: LD_INT 2
52319: PUSH
52320: LD_INT 3
52322: PUSH
52323: LD_INT 4
52325: PUSH
52326: LD_INT 5
52328: PUSH
52329: EMPTY
52330: LIST
52331: LIST
52332: LIST
52333: LIST
52334: ST_TO_ADDR
52335: GO 53228
52337: LD_INT 5
52339: DOUBLE
52340: EQUAL
52341: IFTRUE 52345
52343: GO 52371
52345: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
52346: LD_ADDR_VAR 0 3
52350: PUSH
52351: LD_INT 2
52353: PUSH
52354: LD_INT 3
52356: PUSH
52357: LD_INT 4
52359: PUSH
52360: LD_INT 5
52362: PUSH
52363: EMPTY
52364: LIST
52365: LIST
52366: LIST
52367: LIST
52368: ST_TO_ADDR
52369: GO 53228
52371: LD_INT 9
52373: DOUBLE
52374: EQUAL
52375: IFTRUE 52379
52377: GO 52405
52379: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
52380: LD_ADDR_VAR 0 3
52384: PUSH
52385: LD_INT 2
52387: PUSH
52388: LD_INT 3
52390: PUSH
52391: LD_INT 4
52393: PUSH
52394: LD_INT 5
52396: PUSH
52397: EMPTY
52398: LIST
52399: LIST
52400: LIST
52401: LIST
52402: ST_TO_ADDR
52403: GO 53228
52405: LD_INT 7
52407: DOUBLE
52408: EQUAL
52409: IFTRUE 52413
52411: GO 52439
52413: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
52414: LD_ADDR_VAR 0 3
52418: PUSH
52419: LD_INT 2
52421: PUSH
52422: LD_INT 3
52424: PUSH
52425: LD_INT 4
52427: PUSH
52428: LD_INT 5
52430: PUSH
52431: EMPTY
52432: LIST
52433: LIST
52434: LIST
52435: LIST
52436: ST_TO_ADDR
52437: GO 53228
52439: LD_INT 12
52441: DOUBLE
52442: EQUAL
52443: IFTRUE 52447
52445: GO 52473
52447: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
52448: LD_ADDR_VAR 0 3
52452: PUSH
52453: LD_INT 2
52455: PUSH
52456: LD_INT 3
52458: PUSH
52459: LD_INT 4
52461: PUSH
52462: LD_INT 5
52464: PUSH
52465: EMPTY
52466: LIST
52467: LIST
52468: LIST
52469: LIST
52470: ST_TO_ADDR
52471: GO 53228
52473: LD_INT 13
52475: DOUBLE
52476: EQUAL
52477: IFTRUE 52481
52479: GO 52507
52481: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
52482: LD_ADDR_VAR 0 3
52486: PUSH
52487: LD_INT 2
52489: PUSH
52490: LD_INT 3
52492: PUSH
52493: LD_INT 4
52495: PUSH
52496: LD_INT 5
52498: PUSH
52499: EMPTY
52500: LIST
52501: LIST
52502: LIST
52503: LIST
52504: ST_TO_ADDR
52505: GO 53228
52507: LD_INT 14
52509: DOUBLE
52510: EQUAL
52511: IFTRUE 52515
52513: GO 52533
52515: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
52516: LD_ADDR_VAR 0 3
52520: PUSH
52521: LD_INT 4
52523: PUSH
52524: LD_INT 5
52526: PUSH
52527: EMPTY
52528: LIST
52529: LIST
52530: ST_TO_ADDR
52531: GO 53228
52533: LD_INT 6
52535: DOUBLE
52536: EQUAL
52537: IFTRUE 52541
52539: GO 52559
52541: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
52542: LD_ADDR_VAR 0 3
52546: PUSH
52547: LD_INT 4
52549: PUSH
52550: LD_INT 5
52552: PUSH
52553: EMPTY
52554: LIST
52555: LIST
52556: ST_TO_ADDR
52557: GO 53228
52559: LD_INT 10
52561: DOUBLE
52562: EQUAL
52563: IFTRUE 52567
52565: GO 52585
52567: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
52568: LD_ADDR_VAR 0 3
52572: PUSH
52573: LD_INT 4
52575: PUSH
52576: LD_INT 5
52578: PUSH
52579: EMPTY
52580: LIST
52581: LIST
52582: ST_TO_ADDR
52583: GO 53228
52585: LD_INT 22
52587: DOUBLE
52588: EQUAL
52589: IFTRUE 52593
52591: GO 52619
52593: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
52594: LD_ADDR_VAR 0 3
52598: PUSH
52599: LD_INT 11
52601: PUSH
52602: LD_INT 12
52604: PUSH
52605: LD_INT 13
52607: PUSH
52608: LD_INT 14
52610: PUSH
52611: EMPTY
52612: LIST
52613: LIST
52614: LIST
52615: LIST
52616: ST_TO_ADDR
52617: GO 53228
52619: LD_INT 23
52621: DOUBLE
52622: EQUAL
52623: IFTRUE 52627
52625: GO 52653
52627: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
52628: LD_ADDR_VAR 0 3
52632: PUSH
52633: LD_INT 11
52635: PUSH
52636: LD_INT 12
52638: PUSH
52639: LD_INT 13
52641: PUSH
52642: LD_INT 14
52644: PUSH
52645: EMPTY
52646: LIST
52647: LIST
52648: LIST
52649: LIST
52650: ST_TO_ADDR
52651: GO 53228
52653: LD_INT 24
52655: DOUBLE
52656: EQUAL
52657: IFTRUE 52661
52659: GO 52687
52661: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
52662: LD_ADDR_VAR 0 3
52666: PUSH
52667: LD_INT 11
52669: PUSH
52670: LD_INT 12
52672: PUSH
52673: LD_INT 13
52675: PUSH
52676: LD_INT 14
52678: PUSH
52679: EMPTY
52680: LIST
52681: LIST
52682: LIST
52683: LIST
52684: ST_TO_ADDR
52685: GO 53228
52687: LD_INT 30
52689: DOUBLE
52690: EQUAL
52691: IFTRUE 52695
52693: GO 52721
52695: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
52696: LD_ADDR_VAR 0 3
52700: PUSH
52701: LD_INT 11
52703: PUSH
52704: LD_INT 12
52706: PUSH
52707: LD_INT 13
52709: PUSH
52710: LD_INT 14
52712: PUSH
52713: EMPTY
52714: LIST
52715: LIST
52716: LIST
52717: LIST
52718: ST_TO_ADDR
52719: GO 53228
52721: LD_INT 25
52723: DOUBLE
52724: EQUAL
52725: IFTRUE 52729
52727: GO 52747
52729: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
52730: LD_ADDR_VAR 0 3
52734: PUSH
52735: LD_INT 13
52737: PUSH
52738: LD_INT 14
52740: PUSH
52741: EMPTY
52742: LIST
52743: LIST
52744: ST_TO_ADDR
52745: GO 53228
52747: LD_INT 27
52749: DOUBLE
52750: EQUAL
52751: IFTRUE 52755
52753: GO 52773
52755: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
52756: LD_ADDR_VAR 0 3
52760: PUSH
52761: LD_INT 13
52763: PUSH
52764: LD_INT 14
52766: PUSH
52767: EMPTY
52768: LIST
52769: LIST
52770: ST_TO_ADDR
52771: GO 53228
52773: LD_INT 92
52775: DOUBLE
52776: EQUAL
52777: IFTRUE 52781
52779: GO 52807
52781: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
52782: LD_ADDR_VAR 0 3
52786: PUSH
52787: LD_INT 11
52789: PUSH
52790: LD_INT 12
52792: PUSH
52793: LD_INT 13
52795: PUSH
52796: LD_INT 14
52798: PUSH
52799: EMPTY
52800: LIST
52801: LIST
52802: LIST
52803: LIST
52804: ST_TO_ADDR
52805: GO 53228
52807: LD_INT 28
52809: DOUBLE
52810: EQUAL
52811: IFTRUE 52815
52813: GO 52833
52815: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
52816: LD_ADDR_VAR 0 3
52820: PUSH
52821: LD_INT 13
52823: PUSH
52824: LD_INT 14
52826: PUSH
52827: EMPTY
52828: LIST
52829: LIST
52830: ST_TO_ADDR
52831: GO 53228
52833: LD_INT 29
52835: DOUBLE
52836: EQUAL
52837: IFTRUE 52841
52839: GO 52859
52841: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
52842: LD_ADDR_VAR 0 3
52846: PUSH
52847: LD_INT 13
52849: PUSH
52850: LD_INT 14
52852: PUSH
52853: EMPTY
52854: LIST
52855: LIST
52856: ST_TO_ADDR
52857: GO 53228
52859: LD_INT 31
52861: DOUBLE
52862: EQUAL
52863: IFTRUE 52867
52865: GO 52885
52867: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
52868: LD_ADDR_VAR 0 3
52872: PUSH
52873: LD_INT 13
52875: PUSH
52876: LD_INT 14
52878: PUSH
52879: EMPTY
52880: LIST
52881: LIST
52882: ST_TO_ADDR
52883: GO 53228
52885: LD_INT 26
52887: DOUBLE
52888: EQUAL
52889: IFTRUE 52893
52891: GO 52911
52893: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
52894: LD_ADDR_VAR 0 3
52898: PUSH
52899: LD_INT 13
52901: PUSH
52902: LD_INT 14
52904: PUSH
52905: EMPTY
52906: LIST
52907: LIST
52908: ST_TO_ADDR
52909: GO 53228
52911: LD_INT 42
52913: DOUBLE
52914: EQUAL
52915: IFTRUE 52919
52917: GO 52945
52919: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
52920: LD_ADDR_VAR 0 3
52924: PUSH
52925: LD_INT 21
52927: PUSH
52928: LD_INT 22
52930: PUSH
52931: LD_INT 23
52933: PUSH
52934: LD_INT 24
52936: PUSH
52937: EMPTY
52938: LIST
52939: LIST
52940: LIST
52941: LIST
52942: ST_TO_ADDR
52943: GO 53228
52945: LD_INT 43
52947: DOUBLE
52948: EQUAL
52949: IFTRUE 52953
52951: GO 52979
52953: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
52954: LD_ADDR_VAR 0 3
52958: PUSH
52959: LD_INT 21
52961: PUSH
52962: LD_INT 22
52964: PUSH
52965: LD_INT 23
52967: PUSH
52968: LD_INT 24
52970: PUSH
52971: EMPTY
52972: LIST
52973: LIST
52974: LIST
52975: LIST
52976: ST_TO_ADDR
52977: GO 53228
52979: LD_INT 44
52981: DOUBLE
52982: EQUAL
52983: IFTRUE 52987
52985: GO 53013
52987: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
52988: LD_ADDR_VAR 0 3
52992: PUSH
52993: LD_INT 21
52995: PUSH
52996: LD_INT 22
52998: PUSH
52999: LD_INT 23
53001: PUSH
53002: LD_INT 24
53004: PUSH
53005: EMPTY
53006: LIST
53007: LIST
53008: LIST
53009: LIST
53010: ST_TO_ADDR
53011: GO 53228
53013: LD_INT 45
53015: DOUBLE
53016: EQUAL
53017: IFTRUE 53021
53019: GO 53047
53021: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
53022: LD_ADDR_VAR 0 3
53026: PUSH
53027: LD_INT 21
53029: PUSH
53030: LD_INT 22
53032: PUSH
53033: LD_INT 23
53035: PUSH
53036: LD_INT 24
53038: PUSH
53039: EMPTY
53040: LIST
53041: LIST
53042: LIST
53043: LIST
53044: ST_TO_ADDR
53045: GO 53228
53047: LD_INT 49
53049: DOUBLE
53050: EQUAL
53051: IFTRUE 53055
53053: GO 53081
53055: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
53056: LD_ADDR_VAR 0 3
53060: PUSH
53061: LD_INT 21
53063: PUSH
53064: LD_INT 22
53066: PUSH
53067: LD_INT 23
53069: PUSH
53070: LD_INT 24
53072: PUSH
53073: EMPTY
53074: LIST
53075: LIST
53076: LIST
53077: LIST
53078: ST_TO_ADDR
53079: GO 53228
53081: LD_INT 51
53083: DOUBLE
53084: EQUAL
53085: IFTRUE 53089
53087: GO 53115
53089: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
53090: LD_ADDR_VAR 0 3
53094: PUSH
53095: LD_INT 21
53097: PUSH
53098: LD_INT 22
53100: PUSH
53101: LD_INT 23
53103: PUSH
53104: LD_INT 24
53106: PUSH
53107: EMPTY
53108: LIST
53109: LIST
53110: LIST
53111: LIST
53112: ST_TO_ADDR
53113: GO 53228
53115: LD_INT 52
53117: DOUBLE
53118: EQUAL
53119: IFTRUE 53123
53121: GO 53149
53123: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
53124: LD_ADDR_VAR 0 3
53128: PUSH
53129: LD_INT 21
53131: PUSH
53132: LD_INT 22
53134: PUSH
53135: LD_INT 23
53137: PUSH
53138: LD_INT 24
53140: PUSH
53141: EMPTY
53142: LIST
53143: LIST
53144: LIST
53145: LIST
53146: ST_TO_ADDR
53147: GO 53228
53149: LD_INT 53
53151: DOUBLE
53152: EQUAL
53153: IFTRUE 53157
53155: GO 53175
53157: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
53158: LD_ADDR_VAR 0 3
53162: PUSH
53163: LD_INT 23
53165: PUSH
53166: LD_INT 24
53168: PUSH
53169: EMPTY
53170: LIST
53171: LIST
53172: ST_TO_ADDR
53173: GO 53228
53175: LD_INT 46
53177: DOUBLE
53178: EQUAL
53179: IFTRUE 53183
53181: GO 53201
53183: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
53184: LD_ADDR_VAR 0 3
53188: PUSH
53189: LD_INT 23
53191: PUSH
53192: LD_INT 24
53194: PUSH
53195: EMPTY
53196: LIST
53197: LIST
53198: ST_TO_ADDR
53199: GO 53228
53201: LD_INT 47
53203: DOUBLE
53204: EQUAL
53205: IFTRUE 53209
53207: GO 53227
53209: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
53210: LD_ADDR_VAR 0 3
53214: PUSH
53215: LD_INT 23
53217: PUSH
53218: LD_INT 24
53220: PUSH
53221: EMPTY
53222: LIST
53223: LIST
53224: ST_TO_ADDR
53225: GO 53228
53227: POP
// result := ( chassis in result ) ;
53228: LD_ADDR_VAR 0 3
53232: PUSH
53233: LD_VAR 0 1
53237: PUSH
53238: LD_VAR 0 3
53242: IN
53243: ST_TO_ADDR
// end ;
53244: LD_VAR 0 3
53248: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
53249: LD_INT 0
53251: PPUSH
53252: PPUSH
53253: PPUSH
53254: PPUSH
53255: PPUSH
53256: PPUSH
53257: PPUSH
// result := array ;
53258: LD_ADDR_VAR 0 5
53262: PUSH
53263: LD_VAR 0 1
53267: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
53268: LD_VAR 0 1
53272: NOT
53273: PUSH
53274: LD_VAR 0 2
53278: NOT
53279: OR
53280: PUSH
53281: LD_VAR 0 3
53285: NOT
53286: OR
53287: PUSH
53288: LD_VAR 0 2
53292: PUSH
53293: LD_VAR 0 1
53297: GREATER
53298: OR
53299: PUSH
53300: LD_VAR 0 3
53304: PUSH
53305: LD_VAR 0 1
53309: GREATER
53310: OR
53311: IFFALSE 53315
// exit ;
53313: GO 53611
// if direction then
53315: LD_VAR 0 4
53319: IFFALSE 53383
// begin d := 1 ;
53321: LD_ADDR_VAR 0 9
53325: PUSH
53326: LD_INT 1
53328: ST_TO_ADDR
// if i_from > i_to then
53329: LD_VAR 0 2
53333: PUSH
53334: LD_VAR 0 3
53338: GREATER
53339: IFFALSE 53365
// length := ( array - i_from ) + i_to else
53341: LD_ADDR_VAR 0 11
53345: PUSH
53346: LD_VAR 0 1
53350: PUSH
53351: LD_VAR 0 2
53355: MINUS
53356: PUSH
53357: LD_VAR 0 3
53361: PLUS
53362: ST_TO_ADDR
53363: GO 53381
// length := i_to - i_from ;
53365: LD_ADDR_VAR 0 11
53369: PUSH
53370: LD_VAR 0 3
53374: PUSH
53375: LD_VAR 0 2
53379: MINUS
53380: ST_TO_ADDR
// end else
53381: GO 53444
// begin d := - 1 ;
53383: LD_ADDR_VAR 0 9
53387: PUSH
53388: LD_INT 1
53390: NEG
53391: ST_TO_ADDR
// if i_from > i_to then
53392: LD_VAR 0 2
53396: PUSH
53397: LD_VAR 0 3
53401: GREATER
53402: IFFALSE 53422
// length := i_from - i_to else
53404: LD_ADDR_VAR 0 11
53408: PUSH
53409: LD_VAR 0 2
53413: PUSH
53414: LD_VAR 0 3
53418: MINUS
53419: ST_TO_ADDR
53420: GO 53444
// length := ( array - i_to ) + i_from ;
53422: LD_ADDR_VAR 0 11
53426: PUSH
53427: LD_VAR 0 1
53431: PUSH
53432: LD_VAR 0 3
53436: MINUS
53437: PUSH
53438: LD_VAR 0 2
53442: PLUS
53443: ST_TO_ADDR
// end ; if not length then
53444: LD_VAR 0 11
53448: NOT
53449: IFFALSE 53453
// exit ;
53451: GO 53611
// tmp := array ;
53453: LD_ADDR_VAR 0 10
53457: PUSH
53458: LD_VAR 0 1
53462: ST_TO_ADDR
// for i = 1 to length do
53463: LD_ADDR_VAR 0 6
53467: PUSH
53468: DOUBLE
53469: LD_INT 1
53471: DEC
53472: ST_TO_ADDR
53473: LD_VAR 0 11
53477: PUSH
53478: FOR_TO
53479: IFFALSE 53599
// begin for j = 1 to array do
53481: LD_ADDR_VAR 0 7
53485: PUSH
53486: DOUBLE
53487: LD_INT 1
53489: DEC
53490: ST_TO_ADDR
53491: LD_VAR 0 1
53495: PUSH
53496: FOR_TO
53497: IFFALSE 53585
// begin k := j + d ;
53499: LD_ADDR_VAR 0 8
53503: PUSH
53504: LD_VAR 0 7
53508: PUSH
53509: LD_VAR 0 9
53513: PLUS
53514: ST_TO_ADDR
// if k > array then
53515: LD_VAR 0 8
53519: PUSH
53520: LD_VAR 0 1
53524: GREATER
53525: IFFALSE 53535
// k := 1 ;
53527: LD_ADDR_VAR 0 8
53531: PUSH
53532: LD_INT 1
53534: ST_TO_ADDR
// if not k then
53535: LD_VAR 0 8
53539: NOT
53540: IFFALSE 53552
// k := array ;
53542: LD_ADDR_VAR 0 8
53546: PUSH
53547: LD_VAR 0 1
53551: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
53552: LD_ADDR_VAR 0 10
53556: PUSH
53557: LD_VAR 0 10
53561: PPUSH
53562: LD_VAR 0 8
53566: PPUSH
53567: LD_VAR 0 1
53571: PUSH
53572: LD_VAR 0 7
53576: ARRAY
53577: PPUSH
53578: CALL_OW 1
53582: ST_TO_ADDR
// end ;
53583: GO 53496
53585: POP
53586: POP
// array := tmp ;
53587: LD_ADDR_VAR 0 1
53591: PUSH
53592: LD_VAR 0 10
53596: ST_TO_ADDR
// end ;
53597: GO 53478
53599: POP
53600: POP
// result := array ;
53601: LD_ADDR_VAR 0 5
53605: PUSH
53606: LD_VAR 0 1
53610: ST_TO_ADDR
// end ;
53611: LD_VAR 0 5
53615: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
53616: LD_INT 0
53618: PPUSH
53619: PPUSH
// result := 0 ;
53620: LD_ADDR_VAR 0 3
53624: PUSH
53625: LD_INT 0
53627: ST_TO_ADDR
// if not array or not value in array then
53628: LD_VAR 0 1
53632: NOT
53633: PUSH
53634: LD_VAR 0 2
53638: PUSH
53639: LD_VAR 0 1
53643: IN
53644: NOT
53645: OR
53646: IFFALSE 53650
// exit ;
53648: GO 53704
// for i = 1 to array do
53650: LD_ADDR_VAR 0 4
53654: PUSH
53655: DOUBLE
53656: LD_INT 1
53658: DEC
53659: ST_TO_ADDR
53660: LD_VAR 0 1
53664: PUSH
53665: FOR_TO
53666: IFFALSE 53702
// if value = array [ i ] then
53668: LD_VAR 0 2
53672: PUSH
53673: LD_VAR 0 1
53677: PUSH
53678: LD_VAR 0 4
53682: ARRAY
53683: EQUAL
53684: IFFALSE 53700
// begin result := i ;
53686: LD_ADDR_VAR 0 3
53690: PUSH
53691: LD_VAR 0 4
53695: ST_TO_ADDR
// exit ;
53696: POP
53697: POP
53698: GO 53704
// end ;
53700: GO 53665
53702: POP
53703: POP
// end ;
53704: LD_VAR 0 3
53708: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
53709: LD_INT 0
53711: PPUSH
// vc_chassis := chassis ;
53712: LD_ADDR_OWVAR 37
53716: PUSH
53717: LD_VAR 0 1
53721: ST_TO_ADDR
// vc_engine := engine ;
53722: LD_ADDR_OWVAR 39
53726: PUSH
53727: LD_VAR 0 2
53731: ST_TO_ADDR
// vc_control := control ;
53732: LD_ADDR_OWVAR 38
53736: PUSH
53737: LD_VAR 0 3
53741: ST_TO_ADDR
// vc_weapon := weapon ;
53742: LD_ADDR_OWVAR 40
53746: PUSH
53747: LD_VAR 0 4
53751: ST_TO_ADDR
// vc_fuel_battery := fuel ;
53752: LD_ADDR_OWVAR 41
53756: PUSH
53757: LD_VAR 0 5
53761: ST_TO_ADDR
// end ;
53762: LD_VAR 0 6
53766: RET
// export function WantPlant ( unit ) ; var task ; begin
53767: LD_INT 0
53769: PPUSH
53770: PPUSH
// result := false ;
53771: LD_ADDR_VAR 0 2
53775: PUSH
53776: LD_INT 0
53778: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
53779: LD_ADDR_VAR 0 3
53783: PUSH
53784: LD_VAR 0 1
53788: PPUSH
53789: CALL_OW 437
53793: ST_TO_ADDR
// if task then
53794: LD_VAR 0 3
53798: IFFALSE 53826
// if task [ 1 ] [ 1 ] = p then
53800: LD_VAR 0 3
53804: PUSH
53805: LD_INT 1
53807: ARRAY
53808: PUSH
53809: LD_INT 1
53811: ARRAY
53812: PUSH
53813: LD_STRING p
53815: EQUAL
53816: IFFALSE 53826
// result := true ;
53818: LD_ADDR_VAR 0 2
53822: PUSH
53823: LD_INT 1
53825: ST_TO_ADDR
// end ;
53826: LD_VAR 0 2
53830: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
53831: LD_INT 0
53833: PPUSH
53834: PPUSH
53835: PPUSH
53836: PPUSH
// if pos < 1 then
53837: LD_VAR 0 2
53841: PUSH
53842: LD_INT 1
53844: LESS
53845: IFFALSE 53849
// exit ;
53847: GO 54152
// if pos = 1 then
53849: LD_VAR 0 2
53853: PUSH
53854: LD_INT 1
53856: EQUAL
53857: IFFALSE 53890
// result := Replace ( arr , pos [ 1 ] , value ) else
53859: LD_ADDR_VAR 0 4
53863: PUSH
53864: LD_VAR 0 1
53868: PPUSH
53869: LD_VAR 0 2
53873: PUSH
53874: LD_INT 1
53876: ARRAY
53877: PPUSH
53878: LD_VAR 0 3
53882: PPUSH
53883: CALL_OW 1
53887: ST_TO_ADDR
53888: GO 54152
// begin tmp := arr ;
53890: LD_ADDR_VAR 0 6
53894: PUSH
53895: LD_VAR 0 1
53899: ST_TO_ADDR
// s_arr := [ tmp ] ;
53900: LD_ADDR_VAR 0 7
53904: PUSH
53905: LD_VAR 0 6
53909: PUSH
53910: EMPTY
53911: LIST
53912: ST_TO_ADDR
// for i = 1 to pos - 1 do
53913: LD_ADDR_VAR 0 5
53917: PUSH
53918: DOUBLE
53919: LD_INT 1
53921: DEC
53922: ST_TO_ADDR
53923: LD_VAR 0 2
53927: PUSH
53928: LD_INT 1
53930: MINUS
53931: PUSH
53932: FOR_TO
53933: IFFALSE 53978
// begin tmp := tmp [ pos [ i ] ] ;
53935: LD_ADDR_VAR 0 6
53939: PUSH
53940: LD_VAR 0 6
53944: PUSH
53945: LD_VAR 0 2
53949: PUSH
53950: LD_VAR 0 5
53954: ARRAY
53955: ARRAY
53956: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
53957: LD_ADDR_VAR 0 7
53961: PUSH
53962: LD_VAR 0 7
53966: PUSH
53967: LD_VAR 0 6
53971: PUSH
53972: EMPTY
53973: LIST
53974: ADD
53975: ST_TO_ADDR
// end ;
53976: GO 53932
53978: POP
53979: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
53980: LD_ADDR_VAR 0 6
53984: PUSH
53985: LD_VAR 0 6
53989: PPUSH
53990: LD_VAR 0 2
53994: PUSH
53995: LD_VAR 0 2
53999: ARRAY
54000: PPUSH
54001: LD_VAR 0 3
54005: PPUSH
54006: CALL_OW 1
54010: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
54011: LD_ADDR_VAR 0 7
54015: PUSH
54016: LD_VAR 0 7
54020: PPUSH
54021: LD_VAR 0 7
54025: PPUSH
54026: LD_VAR 0 6
54030: PPUSH
54031: CALL_OW 1
54035: ST_TO_ADDR
// for i = s_arr downto 2 do
54036: LD_ADDR_VAR 0 5
54040: PUSH
54041: DOUBLE
54042: LD_VAR 0 7
54046: INC
54047: ST_TO_ADDR
54048: LD_INT 2
54050: PUSH
54051: FOR_DOWNTO
54052: IFFALSE 54136
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
54054: LD_ADDR_VAR 0 6
54058: PUSH
54059: LD_VAR 0 7
54063: PUSH
54064: LD_VAR 0 5
54068: PUSH
54069: LD_INT 1
54071: MINUS
54072: ARRAY
54073: PPUSH
54074: LD_VAR 0 2
54078: PUSH
54079: LD_VAR 0 5
54083: PUSH
54084: LD_INT 1
54086: MINUS
54087: ARRAY
54088: PPUSH
54089: LD_VAR 0 7
54093: PUSH
54094: LD_VAR 0 5
54098: ARRAY
54099: PPUSH
54100: CALL_OW 1
54104: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
54105: LD_ADDR_VAR 0 7
54109: PUSH
54110: LD_VAR 0 7
54114: PPUSH
54115: LD_VAR 0 5
54119: PUSH
54120: LD_INT 1
54122: MINUS
54123: PPUSH
54124: LD_VAR 0 6
54128: PPUSH
54129: CALL_OW 1
54133: ST_TO_ADDR
// end ;
54134: GO 54051
54136: POP
54137: POP
// result := s_arr [ 1 ] ;
54138: LD_ADDR_VAR 0 4
54142: PUSH
54143: LD_VAR 0 7
54147: PUSH
54148: LD_INT 1
54150: ARRAY
54151: ST_TO_ADDR
// end ; end ;
54152: LD_VAR 0 4
54156: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
54157: LD_INT 0
54159: PPUSH
54160: PPUSH
// if not list then
54161: LD_VAR 0 1
54165: NOT
54166: IFFALSE 54170
// exit ;
54168: GO 54261
// i := list [ pos1 ] ;
54170: LD_ADDR_VAR 0 5
54174: PUSH
54175: LD_VAR 0 1
54179: PUSH
54180: LD_VAR 0 2
54184: ARRAY
54185: ST_TO_ADDR
// if not i then
54186: LD_VAR 0 5
54190: NOT
54191: IFFALSE 54195
// exit ;
54193: GO 54261
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
54195: LD_ADDR_VAR 0 1
54199: PUSH
54200: LD_VAR 0 1
54204: PPUSH
54205: LD_VAR 0 2
54209: PPUSH
54210: LD_VAR 0 1
54214: PUSH
54215: LD_VAR 0 3
54219: ARRAY
54220: PPUSH
54221: CALL_OW 1
54225: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
54226: LD_ADDR_VAR 0 1
54230: PUSH
54231: LD_VAR 0 1
54235: PPUSH
54236: LD_VAR 0 3
54240: PPUSH
54241: LD_VAR 0 5
54245: PPUSH
54246: CALL_OW 1
54250: ST_TO_ADDR
// result := list ;
54251: LD_ADDR_VAR 0 4
54255: PUSH
54256: LD_VAR 0 1
54260: ST_TO_ADDR
// end ;
54261: LD_VAR 0 4
54265: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
54266: LD_INT 0
54268: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
54269: LD_ADDR_VAR 0 5
54273: PUSH
54274: LD_VAR 0 1
54278: PPUSH
54279: CALL_OW 250
54283: PPUSH
54284: LD_VAR 0 1
54288: PPUSH
54289: CALL_OW 251
54293: PPUSH
54294: LD_VAR 0 2
54298: PPUSH
54299: LD_VAR 0 3
54303: PPUSH
54304: LD_VAR 0 4
54308: PPUSH
54309: CALL 54319 0 5
54313: ST_TO_ADDR
// end ;
54314: LD_VAR 0 5
54318: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
54319: LD_INT 0
54321: PPUSH
54322: PPUSH
54323: PPUSH
54324: PPUSH
// if not list then
54325: LD_VAR 0 3
54329: NOT
54330: IFFALSE 54334
// exit ;
54332: GO 54722
// result := [ ] ;
54334: LD_ADDR_VAR 0 6
54338: PUSH
54339: EMPTY
54340: ST_TO_ADDR
// for i in list do
54341: LD_ADDR_VAR 0 7
54345: PUSH
54346: LD_VAR 0 3
54350: PUSH
54351: FOR_IN
54352: IFFALSE 54554
// begin tmp := GetDistUnitXY ( i , x , y ) ;
54354: LD_ADDR_VAR 0 9
54358: PUSH
54359: LD_VAR 0 7
54363: PPUSH
54364: LD_VAR 0 1
54368: PPUSH
54369: LD_VAR 0 2
54373: PPUSH
54374: CALL_OW 297
54378: ST_TO_ADDR
// if not result then
54379: LD_VAR 0 6
54383: NOT
54384: IFFALSE 54410
// result := [ [ i , tmp ] ] else
54386: LD_ADDR_VAR 0 6
54390: PUSH
54391: LD_VAR 0 7
54395: PUSH
54396: LD_VAR 0 9
54400: PUSH
54401: EMPTY
54402: LIST
54403: LIST
54404: PUSH
54405: EMPTY
54406: LIST
54407: ST_TO_ADDR
54408: GO 54552
// begin if result [ result ] [ 2 ] < tmp then
54410: LD_VAR 0 6
54414: PUSH
54415: LD_VAR 0 6
54419: ARRAY
54420: PUSH
54421: LD_INT 2
54423: ARRAY
54424: PUSH
54425: LD_VAR 0 9
54429: LESS
54430: IFFALSE 54472
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
54432: LD_ADDR_VAR 0 6
54436: PUSH
54437: LD_VAR 0 6
54441: PPUSH
54442: LD_VAR 0 6
54446: PUSH
54447: LD_INT 1
54449: PLUS
54450: PPUSH
54451: LD_VAR 0 7
54455: PUSH
54456: LD_VAR 0 9
54460: PUSH
54461: EMPTY
54462: LIST
54463: LIST
54464: PPUSH
54465: CALL_OW 2
54469: ST_TO_ADDR
54470: GO 54552
// for j = 1 to result do
54472: LD_ADDR_VAR 0 8
54476: PUSH
54477: DOUBLE
54478: LD_INT 1
54480: DEC
54481: ST_TO_ADDR
54482: LD_VAR 0 6
54486: PUSH
54487: FOR_TO
54488: IFFALSE 54550
// begin if tmp < result [ j ] [ 2 ] then
54490: LD_VAR 0 9
54494: PUSH
54495: LD_VAR 0 6
54499: PUSH
54500: LD_VAR 0 8
54504: ARRAY
54505: PUSH
54506: LD_INT 2
54508: ARRAY
54509: LESS
54510: IFFALSE 54548
// begin result := Insert ( result , j , [ i , tmp ] ) ;
54512: LD_ADDR_VAR 0 6
54516: PUSH
54517: LD_VAR 0 6
54521: PPUSH
54522: LD_VAR 0 8
54526: PPUSH
54527: LD_VAR 0 7
54531: PUSH
54532: LD_VAR 0 9
54536: PUSH
54537: EMPTY
54538: LIST
54539: LIST
54540: PPUSH
54541: CALL_OW 2
54545: ST_TO_ADDR
// break ;
54546: GO 54550
// end ; end ;
54548: GO 54487
54550: POP
54551: POP
// end ; end ;
54552: GO 54351
54554: POP
54555: POP
// if result and not asc then
54556: LD_VAR 0 6
54560: PUSH
54561: LD_VAR 0 4
54565: NOT
54566: AND
54567: IFFALSE 54642
// begin tmp := result ;
54569: LD_ADDR_VAR 0 9
54573: PUSH
54574: LD_VAR 0 6
54578: ST_TO_ADDR
// for i = tmp downto 1 do
54579: LD_ADDR_VAR 0 7
54583: PUSH
54584: DOUBLE
54585: LD_VAR 0 9
54589: INC
54590: ST_TO_ADDR
54591: LD_INT 1
54593: PUSH
54594: FOR_DOWNTO
54595: IFFALSE 54640
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
54597: LD_ADDR_VAR 0 6
54601: PUSH
54602: LD_VAR 0 6
54606: PPUSH
54607: LD_VAR 0 9
54611: PUSH
54612: LD_VAR 0 7
54616: MINUS
54617: PUSH
54618: LD_INT 1
54620: PLUS
54621: PPUSH
54622: LD_VAR 0 9
54626: PUSH
54627: LD_VAR 0 7
54631: ARRAY
54632: PPUSH
54633: CALL_OW 1
54637: ST_TO_ADDR
54638: GO 54594
54640: POP
54641: POP
// end ; tmp := [ ] ;
54642: LD_ADDR_VAR 0 9
54646: PUSH
54647: EMPTY
54648: ST_TO_ADDR
// if mode then
54649: LD_VAR 0 5
54653: IFFALSE 54722
// begin for i = 1 to result do
54655: LD_ADDR_VAR 0 7
54659: PUSH
54660: DOUBLE
54661: LD_INT 1
54663: DEC
54664: ST_TO_ADDR
54665: LD_VAR 0 6
54669: PUSH
54670: FOR_TO
54671: IFFALSE 54710
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
54673: LD_ADDR_VAR 0 9
54677: PUSH
54678: LD_VAR 0 9
54682: PPUSH
54683: LD_VAR 0 7
54687: PPUSH
54688: LD_VAR 0 6
54692: PUSH
54693: LD_VAR 0 7
54697: ARRAY
54698: PUSH
54699: LD_INT 1
54701: ARRAY
54702: PPUSH
54703: CALL_OW 1
54707: ST_TO_ADDR
54708: GO 54670
54710: POP
54711: POP
// result := tmp ;
54712: LD_ADDR_VAR 0 6
54716: PUSH
54717: LD_VAR 0 9
54721: ST_TO_ADDR
// end ; end ;
54722: LD_VAR 0 6
54726: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
54727: LD_INT 0
54729: PPUSH
54730: PPUSH
54731: PPUSH
54732: PPUSH
54733: PPUSH
54734: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
54735: LD_ADDR_VAR 0 5
54739: PUSH
54740: LD_INT 0
54742: PUSH
54743: LD_INT 0
54745: PUSH
54746: LD_INT 0
54748: PUSH
54749: EMPTY
54750: PUSH
54751: EMPTY
54752: LIST
54753: LIST
54754: LIST
54755: LIST
54756: ST_TO_ADDR
// if not x or not y then
54757: LD_VAR 0 2
54761: NOT
54762: PUSH
54763: LD_VAR 0 3
54767: NOT
54768: OR
54769: IFFALSE 54773
// exit ;
54771: GO 56423
// if not range then
54773: LD_VAR 0 4
54777: NOT
54778: IFFALSE 54788
// range := 10 ;
54780: LD_ADDR_VAR 0 4
54784: PUSH
54785: LD_INT 10
54787: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
54788: LD_ADDR_VAR 0 8
54792: PUSH
54793: LD_INT 81
54795: PUSH
54796: LD_VAR 0 1
54800: PUSH
54801: EMPTY
54802: LIST
54803: LIST
54804: PUSH
54805: LD_INT 92
54807: PUSH
54808: LD_VAR 0 2
54812: PUSH
54813: LD_VAR 0 3
54817: PUSH
54818: LD_VAR 0 4
54822: PUSH
54823: EMPTY
54824: LIST
54825: LIST
54826: LIST
54827: LIST
54828: PUSH
54829: LD_INT 3
54831: PUSH
54832: LD_INT 21
54834: PUSH
54835: LD_INT 3
54837: PUSH
54838: EMPTY
54839: LIST
54840: LIST
54841: PUSH
54842: EMPTY
54843: LIST
54844: LIST
54845: PUSH
54846: EMPTY
54847: LIST
54848: LIST
54849: LIST
54850: PPUSH
54851: CALL_OW 69
54855: ST_TO_ADDR
// if not tmp then
54856: LD_VAR 0 8
54860: NOT
54861: IFFALSE 54865
// exit ;
54863: GO 56423
// for i in tmp do
54865: LD_ADDR_VAR 0 6
54869: PUSH
54870: LD_VAR 0 8
54874: PUSH
54875: FOR_IN
54876: IFFALSE 56398
// begin points := [ 0 , 0 , 0 ] ;
54878: LD_ADDR_VAR 0 9
54882: PUSH
54883: LD_INT 0
54885: PUSH
54886: LD_INT 0
54888: PUSH
54889: LD_INT 0
54891: PUSH
54892: EMPTY
54893: LIST
54894: LIST
54895: LIST
54896: ST_TO_ADDR
// bpoints := 1 ;
54897: LD_ADDR_VAR 0 10
54901: PUSH
54902: LD_INT 1
54904: ST_TO_ADDR
// case GetType ( i ) of unit_human :
54905: LD_VAR 0 6
54909: PPUSH
54910: CALL_OW 247
54914: PUSH
54915: LD_INT 1
54917: DOUBLE
54918: EQUAL
54919: IFTRUE 54923
54921: GO 55501
54923: POP
// begin if GetClass ( i ) = 1 then
54924: LD_VAR 0 6
54928: PPUSH
54929: CALL_OW 257
54933: PUSH
54934: LD_INT 1
54936: EQUAL
54937: IFFALSE 54958
// points := [ 10 , 5 , 3 ] ;
54939: LD_ADDR_VAR 0 9
54943: PUSH
54944: LD_INT 10
54946: PUSH
54947: LD_INT 5
54949: PUSH
54950: LD_INT 3
54952: PUSH
54953: EMPTY
54954: LIST
54955: LIST
54956: LIST
54957: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
54958: LD_VAR 0 6
54962: PPUSH
54963: CALL_OW 257
54967: PUSH
54968: LD_INT 2
54970: PUSH
54971: LD_INT 3
54973: PUSH
54974: LD_INT 4
54976: PUSH
54977: EMPTY
54978: LIST
54979: LIST
54980: LIST
54981: IN
54982: IFFALSE 55003
// points := [ 3 , 2 , 1 ] ;
54984: LD_ADDR_VAR 0 9
54988: PUSH
54989: LD_INT 3
54991: PUSH
54992: LD_INT 2
54994: PUSH
54995: LD_INT 1
54997: PUSH
54998: EMPTY
54999: LIST
55000: LIST
55001: LIST
55002: ST_TO_ADDR
// if GetClass ( i ) = 5 then
55003: LD_VAR 0 6
55007: PPUSH
55008: CALL_OW 257
55012: PUSH
55013: LD_INT 5
55015: EQUAL
55016: IFFALSE 55037
// points := [ 130 , 5 , 2 ] ;
55018: LD_ADDR_VAR 0 9
55022: PUSH
55023: LD_INT 130
55025: PUSH
55026: LD_INT 5
55028: PUSH
55029: LD_INT 2
55031: PUSH
55032: EMPTY
55033: LIST
55034: LIST
55035: LIST
55036: ST_TO_ADDR
// if GetClass ( i ) = 8 then
55037: LD_VAR 0 6
55041: PPUSH
55042: CALL_OW 257
55046: PUSH
55047: LD_INT 8
55049: EQUAL
55050: IFFALSE 55071
// points := [ 35 , 35 , 30 ] ;
55052: LD_ADDR_VAR 0 9
55056: PUSH
55057: LD_INT 35
55059: PUSH
55060: LD_INT 35
55062: PUSH
55063: LD_INT 30
55065: PUSH
55066: EMPTY
55067: LIST
55068: LIST
55069: LIST
55070: ST_TO_ADDR
// if GetClass ( i ) = 9 then
55071: LD_VAR 0 6
55075: PPUSH
55076: CALL_OW 257
55080: PUSH
55081: LD_INT 9
55083: EQUAL
55084: IFFALSE 55105
// points := [ 20 , 55 , 40 ] ;
55086: LD_ADDR_VAR 0 9
55090: PUSH
55091: LD_INT 20
55093: PUSH
55094: LD_INT 55
55096: PUSH
55097: LD_INT 40
55099: PUSH
55100: EMPTY
55101: LIST
55102: LIST
55103: LIST
55104: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
55105: LD_VAR 0 6
55109: PPUSH
55110: CALL_OW 257
55114: PUSH
55115: LD_INT 12
55117: PUSH
55118: LD_INT 16
55120: PUSH
55121: EMPTY
55122: LIST
55123: LIST
55124: IN
55125: IFFALSE 55146
// points := [ 5 , 3 , 2 ] ;
55127: LD_ADDR_VAR 0 9
55131: PUSH
55132: LD_INT 5
55134: PUSH
55135: LD_INT 3
55137: PUSH
55138: LD_INT 2
55140: PUSH
55141: EMPTY
55142: LIST
55143: LIST
55144: LIST
55145: ST_TO_ADDR
// if GetClass ( i ) = 17 then
55146: LD_VAR 0 6
55150: PPUSH
55151: CALL_OW 257
55155: PUSH
55156: LD_INT 17
55158: EQUAL
55159: IFFALSE 55180
// points := [ 100 , 50 , 75 ] ;
55161: LD_ADDR_VAR 0 9
55165: PUSH
55166: LD_INT 100
55168: PUSH
55169: LD_INT 50
55171: PUSH
55172: LD_INT 75
55174: PUSH
55175: EMPTY
55176: LIST
55177: LIST
55178: LIST
55179: ST_TO_ADDR
// if GetClass ( i ) = 15 then
55180: LD_VAR 0 6
55184: PPUSH
55185: CALL_OW 257
55189: PUSH
55190: LD_INT 15
55192: EQUAL
55193: IFFALSE 55214
// points := [ 10 , 5 , 3 ] ;
55195: LD_ADDR_VAR 0 9
55199: PUSH
55200: LD_INT 10
55202: PUSH
55203: LD_INT 5
55205: PUSH
55206: LD_INT 3
55208: PUSH
55209: EMPTY
55210: LIST
55211: LIST
55212: LIST
55213: ST_TO_ADDR
// if GetClass ( i ) = 14 then
55214: LD_VAR 0 6
55218: PPUSH
55219: CALL_OW 257
55223: PUSH
55224: LD_INT 14
55226: EQUAL
55227: IFFALSE 55248
// points := [ 10 , 0 , 0 ] ;
55229: LD_ADDR_VAR 0 9
55233: PUSH
55234: LD_INT 10
55236: PUSH
55237: LD_INT 0
55239: PUSH
55240: LD_INT 0
55242: PUSH
55243: EMPTY
55244: LIST
55245: LIST
55246: LIST
55247: ST_TO_ADDR
// if GetClass ( i ) = 11 then
55248: LD_VAR 0 6
55252: PPUSH
55253: CALL_OW 257
55257: PUSH
55258: LD_INT 11
55260: EQUAL
55261: IFFALSE 55282
// points := [ 30 , 10 , 5 ] ;
55263: LD_ADDR_VAR 0 9
55267: PUSH
55268: LD_INT 30
55270: PUSH
55271: LD_INT 10
55273: PUSH
55274: LD_INT 5
55276: PUSH
55277: EMPTY
55278: LIST
55279: LIST
55280: LIST
55281: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
55282: LD_VAR 0 1
55286: PPUSH
55287: LD_INT 5
55289: PPUSH
55290: CALL_OW 321
55294: PUSH
55295: LD_INT 2
55297: EQUAL
55298: IFFALSE 55315
// bpoints := bpoints * 1.8 ;
55300: LD_ADDR_VAR 0 10
55304: PUSH
55305: LD_VAR 0 10
55309: PUSH
55310: LD_REAL  1.80000000000000E+0000
55313: MUL
55314: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
55315: LD_VAR 0 6
55319: PPUSH
55320: CALL_OW 257
55324: PUSH
55325: LD_INT 1
55327: PUSH
55328: LD_INT 2
55330: PUSH
55331: LD_INT 3
55333: PUSH
55334: LD_INT 4
55336: PUSH
55337: EMPTY
55338: LIST
55339: LIST
55340: LIST
55341: LIST
55342: IN
55343: PUSH
55344: LD_VAR 0 1
55348: PPUSH
55349: LD_INT 51
55351: PPUSH
55352: CALL_OW 321
55356: PUSH
55357: LD_INT 2
55359: EQUAL
55360: AND
55361: IFFALSE 55378
// bpoints := bpoints * 1.2 ;
55363: LD_ADDR_VAR 0 10
55367: PUSH
55368: LD_VAR 0 10
55372: PUSH
55373: LD_REAL  1.20000000000000E+0000
55376: MUL
55377: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
55378: LD_VAR 0 6
55382: PPUSH
55383: CALL_OW 257
55387: PUSH
55388: LD_INT 5
55390: PUSH
55391: LD_INT 7
55393: PUSH
55394: LD_INT 9
55396: PUSH
55397: EMPTY
55398: LIST
55399: LIST
55400: LIST
55401: IN
55402: PUSH
55403: LD_VAR 0 1
55407: PPUSH
55408: LD_INT 52
55410: PPUSH
55411: CALL_OW 321
55415: PUSH
55416: LD_INT 2
55418: EQUAL
55419: AND
55420: IFFALSE 55437
// bpoints := bpoints * 1.5 ;
55422: LD_ADDR_VAR 0 10
55426: PUSH
55427: LD_VAR 0 10
55431: PUSH
55432: LD_REAL  1.50000000000000E+0000
55435: MUL
55436: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
55437: LD_VAR 0 1
55441: PPUSH
55442: LD_INT 66
55444: PPUSH
55445: CALL_OW 321
55449: PUSH
55450: LD_INT 2
55452: EQUAL
55453: IFFALSE 55470
// bpoints := bpoints * 1.1 ;
55455: LD_ADDR_VAR 0 10
55459: PUSH
55460: LD_VAR 0 10
55464: PUSH
55465: LD_REAL  1.10000000000000E+0000
55468: MUL
55469: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
55470: LD_ADDR_VAR 0 10
55474: PUSH
55475: LD_VAR 0 10
55479: PUSH
55480: LD_VAR 0 6
55484: PPUSH
55485: LD_INT 1
55487: PPUSH
55488: CALL_OW 259
55492: PUSH
55493: LD_REAL  1.15000000000000E+0000
55496: MUL
55497: MUL
55498: ST_TO_ADDR
// end ; unit_vehicle :
55499: GO 56327
55501: LD_INT 2
55503: DOUBLE
55504: EQUAL
55505: IFTRUE 55509
55507: GO 56315
55509: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
55510: LD_VAR 0 6
55514: PPUSH
55515: CALL_OW 264
55519: PUSH
55520: LD_INT 2
55522: PUSH
55523: LD_INT 42
55525: PUSH
55526: LD_INT 24
55528: PUSH
55529: EMPTY
55530: LIST
55531: LIST
55532: LIST
55533: IN
55534: IFFALSE 55555
// points := [ 25 , 5 , 3 ] ;
55536: LD_ADDR_VAR 0 9
55540: PUSH
55541: LD_INT 25
55543: PUSH
55544: LD_INT 5
55546: PUSH
55547: LD_INT 3
55549: PUSH
55550: EMPTY
55551: LIST
55552: LIST
55553: LIST
55554: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
55555: LD_VAR 0 6
55559: PPUSH
55560: CALL_OW 264
55564: PUSH
55565: LD_INT 4
55567: PUSH
55568: LD_INT 43
55570: PUSH
55571: LD_INT 25
55573: PUSH
55574: EMPTY
55575: LIST
55576: LIST
55577: LIST
55578: IN
55579: IFFALSE 55600
// points := [ 40 , 15 , 5 ] ;
55581: LD_ADDR_VAR 0 9
55585: PUSH
55586: LD_INT 40
55588: PUSH
55589: LD_INT 15
55591: PUSH
55592: LD_INT 5
55594: PUSH
55595: EMPTY
55596: LIST
55597: LIST
55598: LIST
55599: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
55600: LD_VAR 0 6
55604: PPUSH
55605: CALL_OW 264
55609: PUSH
55610: LD_INT 3
55612: PUSH
55613: LD_INT 23
55615: PUSH
55616: EMPTY
55617: LIST
55618: LIST
55619: IN
55620: IFFALSE 55641
// points := [ 7 , 25 , 8 ] ;
55622: LD_ADDR_VAR 0 9
55626: PUSH
55627: LD_INT 7
55629: PUSH
55630: LD_INT 25
55632: PUSH
55633: LD_INT 8
55635: PUSH
55636: EMPTY
55637: LIST
55638: LIST
55639: LIST
55640: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
55641: LD_VAR 0 6
55645: PPUSH
55646: CALL_OW 264
55650: PUSH
55651: LD_INT 5
55653: PUSH
55654: LD_INT 27
55656: PUSH
55657: LD_INT 44
55659: PUSH
55660: EMPTY
55661: LIST
55662: LIST
55663: LIST
55664: IN
55665: IFFALSE 55686
// points := [ 14 , 50 , 16 ] ;
55667: LD_ADDR_VAR 0 9
55671: PUSH
55672: LD_INT 14
55674: PUSH
55675: LD_INT 50
55677: PUSH
55678: LD_INT 16
55680: PUSH
55681: EMPTY
55682: LIST
55683: LIST
55684: LIST
55685: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
55686: LD_VAR 0 6
55690: PPUSH
55691: CALL_OW 264
55695: PUSH
55696: LD_INT 6
55698: PUSH
55699: LD_INT 46
55701: PUSH
55702: EMPTY
55703: LIST
55704: LIST
55705: IN
55706: IFFALSE 55727
// points := [ 32 , 120 , 70 ] ;
55708: LD_ADDR_VAR 0 9
55712: PUSH
55713: LD_INT 32
55715: PUSH
55716: LD_INT 120
55718: PUSH
55719: LD_INT 70
55721: PUSH
55722: EMPTY
55723: LIST
55724: LIST
55725: LIST
55726: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
55727: LD_VAR 0 6
55731: PPUSH
55732: CALL_OW 264
55736: PUSH
55737: LD_INT 7
55739: PUSH
55740: LD_INT 28
55742: PUSH
55743: LD_INT 45
55745: PUSH
55746: LD_INT 92
55748: PUSH
55749: EMPTY
55750: LIST
55751: LIST
55752: LIST
55753: LIST
55754: IN
55755: IFFALSE 55776
// points := [ 35 , 20 , 45 ] ;
55757: LD_ADDR_VAR 0 9
55761: PUSH
55762: LD_INT 35
55764: PUSH
55765: LD_INT 20
55767: PUSH
55768: LD_INT 45
55770: PUSH
55771: EMPTY
55772: LIST
55773: LIST
55774: LIST
55775: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
55776: LD_VAR 0 6
55780: PPUSH
55781: CALL_OW 264
55785: PUSH
55786: LD_INT 47
55788: PUSH
55789: EMPTY
55790: LIST
55791: IN
55792: IFFALSE 55813
// points := [ 67 , 45 , 75 ] ;
55794: LD_ADDR_VAR 0 9
55798: PUSH
55799: LD_INT 67
55801: PUSH
55802: LD_INT 45
55804: PUSH
55805: LD_INT 75
55807: PUSH
55808: EMPTY
55809: LIST
55810: LIST
55811: LIST
55812: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
55813: LD_VAR 0 6
55817: PPUSH
55818: CALL_OW 264
55822: PUSH
55823: LD_INT 26
55825: PUSH
55826: EMPTY
55827: LIST
55828: IN
55829: IFFALSE 55850
// points := [ 120 , 30 , 80 ] ;
55831: LD_ADDR_VAR 0 9
55835: PUSH
55836: LD_INT 120
55838: PUSH
55839: LD_INT 30
55841: PUSH
55842: LD_INT 80
55844: PUSH
55845: EMPTY
55846: LIST
55847: LIST
55848: LIST
55849: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
55850: LD_VAR 0 6
55854: PPUSH
55855: CALL_OW 264
55859: PUSH
55860: LD_INT 22
55862: PUSH
55863: EMPTY
55864: LIST
55865: IN
55866: IFFALSE 55887
// points := [ 40 , 1 , 1 ] ;
55868: LD_ADDR_VAR 0 9
55872: PUSH
55873: LD_INT 40
55875: PUSH
55876: LD_INT 1
55878: PUSH
55879: LD_INT 1
55881: PUSH
55882: EMPTY
55883: LIST
55884: LIST
55885: LIST
55886: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
55887: LD_VAR 0 6
55891: PPUSH
55892: CALL_OW 264
55896: PUSH
55897: LD_INT 29
55899: PUSH
55900: EMPTY
55901: LIST
55902: IN
55903: IFFALSE 55924
// points := [ 70 , 200 , 400 ] ;
55905: LD_ADDR_VAR 0 9
55909: PUSH
55910: LD_INT 70
55912: PUSH
55913: LD_INT 200
55915: PUSH
55916: LD_INT 400
55918: PUSH
55919: EMPTY
55920: LIST
55921: LIST
55922: LIST
55923: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
55924: LD_VAR 0 6
55928: PPUSH
55929: CALL_OW 264
55933: PUSH
55934: LD_INT 14
55936: PUSH
55937: LD_INT 53
55939: PUSH
55940: EMPTY
55941: LIST
55942: LIST
55943: IN
55944: IFFALSE 55965
// points := [ 40 , 10 , 20 ] ;
55946: LD_ADDR_VAR 0 9
55950: PUSH
55951: LD_INT 40
55953: PUSH
55954: LD_INT 10
55956: PUSH
55957: LD_INT 20
55959: PUSH
55960: EMPTY
55961: LIST
55962: LIST
55963: LIST
55964: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
55965: LD_VAR 0 6
55969: PPUSH
55970: CALL_OW 264
55974: PUSH
55975: LD_INT 9
55977: PUSH
55978: EMPTY
55979: LIST
55980: IN
55981: IFFALSE 56002
// points := [ 5 , 70 , 20 ] ;
55983: LD_ADDR_VAR 0 9
55987: PUSH
55988: LD_INT 5
55990: PUSH
55991: LD_INT 70
55993: PUSH
55994: LD_INT 20
55996: PUSH
55997: EMPTY
55998: LIST
55999: LIST
56000: LIST
56001: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
56002: LD_VAR 0 6
56006: PPUSH
56007: CALL_OW 264
56011: PUSH
56012: LD_INT 10
56014: PUSH
56015: EMPTY
56016: LIST
56017: IN
56018: IFFALSE 56039
// points := [ 35 , 110 , 70 ] ;
56020: LD_ADDR_VAR 0 9
56024: PUSH
56025: LD_INT 35
56027: PUSH
56028: LD_INT 110
56030: PUSH
56031: LD_INT 70
56033: PUSH
56034: EMPTY
56035: LIST
56036: LIST
56037: LIST
56038: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
56039: LD_VAR 0 6
56043: PPUSH
56044: CALL_OW 265
56048: PUSH
56049: LD_INT 25
56051: EQUAL
56052: IFFALSE 56073
// points := [ 80 , 65 , 100 ] ;
56054: LD_ADDR_VAR 0 9
56058: PUSH
56059: LD_INT 80
56061: PUSH
56062: LD_INT 65
56064: PUSH
56065: LD_INT 100
56067: PUSH
56068: EMPTY
56069: LIST
56070: LIST
56071: LIST
56072: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
56073: LD_VAR 0 6
56077: PPUSH
56078: CALL_OW 263
56082: PUSH
56083: LD_INT 1
56085: EQUAL
56086: IFFALSE 56121
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
56088: LD_ADDR_VAR 0 10
56092: PUSH
56093: LD_VAR 0 10
56097: PUSH
56098: LD_VAR 0 6
56102: PPUSH
56103: CALL_OW 311
56107: PPUSH
56108: LD_INT 3
56110: PPUSH
56111: CALL_OW 259
56115: PUSH
56116: LD_INT 4
56118: MUL
56119: MUL
56120: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
56121: LD_VAR 0 6
56125: PPUSH
56126: CALL_OW 263
56130: PUSH
56131: LD_INT 2
56133: EQUAL
56134: IFFALSE 56185
// begin j := IsControledBy ( i ) ;
56136: LD_ADDR_VAR 0 7
56140: PUSH
56141: LD_VAR 0 6
56145: PPUSH
56146: CALL_OW 312
56150: ST_TO_ADDR
// if j then
56151: LD_VAR 0 7
56155: IFFALSE 56185
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
56157: LD_ADDR_VAR 0 10
56161: PUSH
56162: LD_VAR 0 10
56166: PUSH
56167: LD_VAR 0 7
56171: PPUSH
56172: LD_INT 3
56174: PPUSH
56175: CALL_OW 259
56179: PUSH
56180: LD_INT 3
56182: MUL
56183: MUL
56184: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
56185: LD_VAR 0 6
56189: PPUSH
56190: CALL_OW 264
56194: PUSH
56195: LD_INT 5
56197: PUSH
56198: LD_INT 6
56200: PUSH
56201: LD_INT 46
56203: PUSH
56204: LD_INT 44
56206: PUSH
56207: LD_INT 47
56209: PUSH
56210: LD_INT 45
56212: PUSH
56213: LD_INT 28
56215: PUSH
56216: LD_INT 7
56218: PUSH
56219: LD_INT 27
56221: PUSH
56222: LD_INT 29
56224: PUSH
56225: EMPTY
56226: LIST
56227: LIST
56228: LIST
56229: LIST
56230: LIST
56231: LIST
56232: LIST
56233: LIST
56234: LIST
56235: LIST
56236: IN
56237: PUSH
56238: LD_VAR 0 1
56242: PPUSH
56243: LD_INT 52
56245: PPUSH
56246: CALL_OW 321
56250: PUSH
56251: LD_INT 2
56253: EQUAL
56254: AND
56255: IFFALSE 56272
// bpoints := bpoints * 1.2 ;
56257: LD_ADDR_VAR 0 10
56261: PUSH
56262: LD_VAR 0 10
56266: PUSH
56267: LD_REAL  1.20000000000000E+0000
56270: MUL
56271: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
56272: LD_VAR 0 6
56276: PPUSH
56277: CALL_OW 264
56281: PUSH
56282: LD_INT 6
56284: PUSH
56285: LD_INT 46
56287: PUSH
56288: LD_INT 47
56290: PUSH
56291: EMPTY
56292: LIST
56293: LIST
56294: LIST
56295: IN
56296: IFFALSE 56313
// bpoints := bpoints * 1.2 ;
56298: LD_ADDR_VAR 0 10
56302: PUSH
56303: LD_VAR 0 10
56307: PUSH
56308: LD_REAL  1.20000000000000E+0000
56311: MUL
56312: ST_TO_ADDR
// end ; unit_building :
56313: GO 56327
56315: LD_INT 3
56317: DOUBLE
56318: EQUAL
56319: IFTRUE 56323
56321: GO 56326
56323: POP
// ; end ;
56324: GO 56327
56326: POP
// for j = 1 to 3 do
56327: LD_ADDR_VAR 0 7
56331: PUSH
56332: DOUBLE
56333: LD_INT 1
56335: DEC
56336: ST_TO_ADDR
56337: LD_INT 3
56339: PUSH
56340: FOR_TO
56341: IFFALSE 56394
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
56343: LD_ADDR_VAR 0 5
56347: PUSH
56348: LD_VAR 0 5
56352: PPUSH
56353: LD_VAR 0 7
56357: PPUSH
56358: LD_VAR 0 5
56362: PUSH
56363: LD_VAR 0 7
56367: ARRAY
56368: PUSH
56369: LD_VAR 0 9
56373: PUSH
56374: LD_VAR 0 7
56378: ARRAY
56379: PUSH
56380: LD_VAR 0 10
56384: MUL
56385: PLUS
56386: PPUSH
56387: CALL_OW 1
56391: ST_TO_ADDR
56392: GO 56340
56394: POP
56395: POP
// end ;
56396: GO 54875
56398: POP
56399: POP
// result := Replace ( result , 4 , tmp ) ;
56400: LD_ADDR_VAR 0 5
56404: PUSH
56405: LD_VAR 0 5
56409: PPUSH
56410: LD_INT 4
56412: PPUSH
56413: LD_VAR 0 8
56417: PPUSH
56418: CALL_OW 1
56422: ST_TO_ADDR
// end ;
56423: LD_VAR 0 5
56427: RET
// export function DangerAtRange ( unit , range ) ; begin
56428: LD_INT 0
56430: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
56431: LD_ADDR_VAR 0 3
56435: PUSH
56436: LD_VAR 0 1
56440: PPUSH
56441: CALL_OW 255
56445: PPUSH
56446: LD_VAR 0 1
56450: PPUSH
56451: CALL_OW 250
56455: PPUSH
56456: LD_VAR 0 1
56460: PPUSH
56461: CALL_OW 251
56465: PPUSH
56466: LD_VAR 0 2
56470: PPUSH
56471: CALL 54727 0 4
56475: ST_TO_ADDR
// end ;
56476: LD_VAR 0 3
56480: RET
// export function DangerInArea ( side , area ) ; begin
56481: LD_INT 0
56483: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
56484: LD_ADDR_VAR 0 3
56488: PUSH
56489: LD_VAR 0 2
56493: PPUSH
56494: LD_INT 81
56496: PUSH
56497: LD_VAR 0 1
56501: PUSH
56502: EMPTY
56503: LIST
56504: LIST
56505: PPUSH
56506: CALL_OW 70
56510: ST_TO_ADDR
// end ;
56511: LD_VAR 0 3
56515: RET
// export function IsExtension ( b ) ; begin
56516: LD_INT 0
56518: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
56519: LD_ADDR_VAR 0 2
56523: PUSH
56524: LD_VAR 0 1
56528: PUSH
56529: LD_INT 23
56531: PUSH
56532: LD_INT 20
56534: PUSH
56535: LD_INT 22
56537: PUSH
56538: LD_INT 17
56540: PUSH
56541: LD_INT 24
56543: PUSH
56544: LD_INT 21
56546: PUSH
56547: LD_INT 19
56549: PUSH
56550: LD_INT 16
56552: PUSH
56553: LD_INT 25
56555: PUSH
56556: LD_INT 18
56558: PUSH
56559: EMPTY
56560: LIST
56561: LIST
56562: LIST
56563: LIST
56564: LIST
56565: LIST
56566: LIST
56567: LIST
56568: LIST
56569: LIST
56570: IN
56571: ST_TO_ADDR
// end ;
56572: LD_VAR 0 2
56576: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
56577: LD_INT 0
56579: PPUSH
56580: PPUSH
56581: PPUSH
// result := [ ] ;
56582: LD_ADDR_VAR 0 4
56586: PUSH
56587: EMPTY
56588: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
56589: LD_ADDR_VAR 0 5
56593: PUSH
56594: LD_VAR 0 2
56598: PPUSH
56599: LD_INT 21
56601: PUSH
56602: LD_INT 3
56604: PUSH
56605: EMPTY
56606: LIST
56607: LIST
56608: PPUSH
56609: CALL_OW 70
56613: ST_TO_ADDR
// if not tmp then
56614: LD_VAR 0 5
56618: NOT
56619: IFFALSE 56623
// exit ;
56621: GO 56687
// if checkLink then
56623: LD_VAR 0 3
56627: IFFALSE 56677
// begin for i in tmp do
56629: LD_ADDR_VAR 0 6
56633: PUSH
56634: LD_VAR 0 5
56638: PUSH
56639: FOR_IN
56640: IFFALSE 56675
// if GetBase ( i ) <> base then
56642: LD_VAR 0 6
56646: PPUSH
56647: CALL_OW 274
56651: PUSH
56652: LD_VAR 0 1
56656: NONEQUAL
56657: IFFALSE 56673
// ComLinkToBase ( base , i ) ;
56659: LD_VAR 0 1
56663: PPUSH
56664: LD_VAR 0 6
56668: PPUSH
56669: CALL_OW 169
56673: GO 56639
56675: POP
56676: POP
// end ; result := tmp ;
56677: LD_ADDR_VAR 0 4
56681: PUSH
56682: LD_VAR 0 5
56686: ST_TO_ADDR
// end ;
56687: LD_VAR 0 4
56691: RET
// export function ComComplete ( units , b ) ; var i ; begin
56692: LD_INT 0
56694: PPUSH
56695: PPUSH
// if not units then
56696: LD_VAR 0 1
56700: NOT
56701: IFFALSE 56705
// exit ;
56703: GO 56795
// for i in units do
56705: LD_ADDR_VAR 0 4
56709: PUSH
56710: LD_VAR 0 1
56714: PUSH
56715: FOR_IN
56716: IFFALSE 56793
// if BuildingStatus ( b ) = bs_build then
56718: LD_VAR 0 2
56722: PPUSH
56723: CALL_OW 461
56727: PUSH
56728: LD_INT 1
56730: EQUAL
56731: IFFALSE 56791
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
56733: LD_VAR 0 4
56737: PPUSH
56738: LD_STRING h
56740: PUSH
56741: LD_VAR 0 2
56745: PPUSH
56746: CALL_OW 250
56750: PUSH
56751: LD_VAR 0 2
56755: PPUSH
56756: CALL_OW 251
56760: PUSH
56761: LD_VAR 0 2
56765: PUSH
56766: LD_INT 0
56768: PUSH
56769: LD_INT 0
56771: PUSH
56772: LD_INT 0
56774: PUSH
56775: EMPTY
56776: LIST
56777: LIST
56778: LIST
56779: LIST
56780: LIST
56781: LIST
56782: LIST
56783: PUSH
56784: EMPTY
56785: LIST
56786: PPUSH
56787: CALL_OW 446
56791: GO 56715
56793: POP
56794: POP
// end ;
56795: LD_VAR 0 3
56799: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
56800: LD_INT 0
56802: PPUSH
56803: PPUSH
56804: PPUSH
56805: PPUSH
56806: PPUSH
56807: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
56808: LD_VAR 0 1
56812: NOT
56813: PUSH
56814: LD_VAR 0 1
56818: PPUSH
56819: CALL_OW 263
56823: PUSH
56824: LD_INT 2
56826: NONEQUAL
56827: OR
56828: IFFALSE 56832
// exit ;
56830: GO 57148
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
56832: LD_ADDR_VAR 0 6
56836: PUSH
56837: LD_INT 22
56839: PUSH
56840: LD_VAR 0 1
56844: PPUSH
56845: CALL_OW 255
56849: PUSH
56850: EMPTY
56851: LIST
56852: LIST
56853: PUSH
56854: LD_INT 2
56856: PUSH
56857: LD_INT 30
56859: PUSH
56860: LD_INT 36
56862: PUSH
56863: EMPTY
56864: LIST
56865: LIST
56866: PUSH
56867: LD_INT 34
56869: PUSH
56870: LD_INT 31
56872: PUSH
56873: EMPTY
56874: LIST
56875: LIST
56876: PUSH
56877: EMPTY
56878: LIST
56879: LIST
56880: LIST
56881: PUSH
56882: EMPTY
56883: LIST
56884: LIST
56885: PPUSH
56886: CALL_OW 69
56890: ST_TO_ADDR
// if not tmp then
56891: LD_VAR 0 6
56895: NOT
56896: IFFALSE 56900
// exit ;
56898: GO 57148
// result := [ ] ;
56900: LD_ADDR_VAR 0 2
56904: PUSH
56905: EMPTY
56906: ST_TO_ADDR
// for i in tmp do
56907: LD_ADDR_VAR 0 3
56911: PUSH
56912: LD_VAR 0 6
56916: PUSH
56917: FOR_IN
56918: IFFALSE 56989
// begin t := UnitsInside ( i ) ;
56920: LD_ADDR_VAR 0 4
56924: PUSH
56925: LD_VAR 0 3
56929: PPUSH
56930: CALL_OW 313
56934: ST_TO_ADDR
// if t then
56935: LD_VAR 0 4
56939: IFFALSE 56987
// for j in t do
56941: LD_ADDR_VAR 0 7
56945: PUSH
56946: LD_VAR 0 4
56950: PUSH
56951: FOR_IN
56952: IFFALSE 56985
// result := Replace ( result , result + 1 , j ) ;
56954: LD_ADDR_VAR 0 2
56958: PUSH
56959: LD_VAR 0 2
56963: PPUSH
56964: LD_VAR 0 2
56968: PUSH
56969: LD_INT 1
56971: PLUS
56972: PPUSH
56973: LD_VAR 0 7
56977: PPUSH
56978: CALL_OW 1
56982: ST_TO_ADDR
56983: GO 56951
56985: POP
56986: POP
// end ;
56987: GO 56917
56989: POP
56990: POP
// if not result then
56991: LD_VAR 0 2
56995: NOT
56996: IFFALSE 57000
// exit ;
56998: GO 57148
// mech := result [ 1 ] ;
57000: LD_ADDR_VAR 0 5
57004: PUSH
57005: LD_VAR 0 2
57009: PUSH
57010: LD_INT 1
57012: ARRAY
57013: ST_TO_ADDR
// if result > 1 then
57014: LD_VAR 0 2
57018: PUSH
57019: LD_INT 1
57021: GREATER
57022: IFFALSE 57134
// begin for i = 2 to result do
57024: LD_ADDR_VAR 0 3
57028: PUSH
57029: DOUBLE
57030: LD_INT 2
57032: DEC
57033: ST_TO_ADDR
57034: LD_VAR 0 2
57038: PUSH
57039: FOR_TO
57040: IFFALSE 57132
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
57042: LD_ADDR_VAR 0 4
57046: PUSH
57047: LD_VAR 0 2
57051: PUSH
57052: LD_VAR 0 3
57056: ARRAY
57057: PPUSH
57058: LD_INT 3
57060: PPUSH
57061: CALL_OW 259
57065: PUSH
57066: LD_VAR 0 2
57070: PUSH
57071: LD_VAR 0 3
57075: ARRAY
57076: PPUSH
57077: CALL_OW 432
57081: MINUS
57082: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
57083: LD_VAR 0 4
57087: PUSH
57088: LD_VAR 0 5
57092: PPUSH
57093: LD_INT 3
57095: PPUSH
57096: CALL_OW 259
57100: PUSH
57101: LD_VAR 0 5
57105: PPUSH
57106: CALL_OW 432
57110: MINUS
57111: GREATEREQUAL
57112: IFFALSE 57130
// mech := result [ i ] ;
57114: LD_ADDR_VAR 0 5
57118: PUSH
57119: LD_VAR 0 2
57123: PUSH
57124: LD_VAR 0 3
57128: ARRAY
57129: ST_TO_ADDR
// end ;
57130: GO 57039
57132: POP
57133: POP
// end ; ComLinkTo ( vehicle , mech ) ;
57134: LD_VAR 0 1
57138: PPUSH
57139: LD_VAR 0 5
57143: PPUSH
57144: CALL_OW 135
// end ;
57148: LD_VAR 0 2
57152: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
57153: LD_INT 0
57155: PPUSH
57156: PPUSH
57157: PPUSH
57158: PPUSH
57159: PPUSH
57160: PPUSH
57161: PPUSH
57162: PPUSH
57163: PPUSH
57164: PPUSH
57165: PPUSH
57166: PPUSH
57167: PPUSH
// result := [ ] ;
57168: LD_ADDR_VAR 0 7
57172: PUSH
57173: EMPTY
57174: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
57175: LD_VAR 0 1
57179: PPUSH
57180: CALL_OW 266
57184: PUSH
57185: LD_INT 0
57187: PUSH
57188: LD_INT 1
57190: PUSH
57191: EMPTY
57192: LIST
57193: LIST
57194: IN
57195: NOT
57196: IFFALSE 57200
// exit ;
57198: GO 58834
// if name then
57200: LD_VAR 0 3
57204: IFFALSE 57220
// SetBName ( base_dep , name ) ;
57206: LD_VAR 0 1
57210: PPUSH
57211: LD_VAR 0 3
57215: PPUSH
57216: CALL_OW 500
// base := GetBase ( base_dep ) ;
57220: LD_ADDR_VAR 0 15
57224: PUSH
57225: LD_VAR 0 1
57229: PPUSH
57230: CALL_OW 274
57234: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
57235: LD_ADDR_VAR 0 16
57239: PUSH
57240: LD_VAR 0 1
57244: PPUSH
57245: CALL_OW 255
57249: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
57250: LD_ADDR_VAR 0 17
57254: PUSH
57255: LD_VAR 0 1
57259: PPUSH
57260: CALL_OW 248
57264: ST_TO_ADDR
// if sources then
57265: LD_VAR 0 5
57269: IFFALSE 57316
// for i = 1 to 3 do
57271: LD_ADDR_VAR 0 8
57275: PUSH
57276: DOUBLE
57277: LD_INT 1
57279: DEC
57280: ST_TO_ADDR
57281: LD_INT 3
57283: PUSH
57284: FOR_TO
57285: IFFALSE 57314
// AddResourceType ( base , i , sources [ i ] ) ;
57287: LD_VAR 0 15
57291: PPUSH
57292: LD_VAR 0 8
57296: PPUSH
57297: LD_VAR 0 5
57301: PUSH
57302: LD_VAR 0 8
57306: ARRAY
57307: PPUSH
57308: CALL_OW 276
57312: GO 57284
57314: POP
57315: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
57316: LD_ADDR_VAR 0 18
57320: PUSH
57321: LD_VAR 0 15
57325: PPUSH
57326: LD_VAR 0 2
57330: PPUSH
57331: LD_INT 1
57333: PPUSH
57334: CALL 56577 0 3
57338: ST_TO_ADDR
// InitHc ;
57339: CALL_OW 19
// InitUc ;
57343: CALL_OW 18
// uc_side := side ;
57347: LD_ADDR_OWVAR 20
57351: PUSH
57352: LD_VAR 0 16
57356: ST_TO_ADDR
// uc_nation := nation ;
57357: LD_ADDR_OWVAR 21
57361: PUSH
57362: LD_VAR 0 17
57366: ST_TO_ADDR
// if buildings then
57367: LD_VAR 0 18
57371: IFFALSE 58693
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
57373: LD_ADDR_VAR 0 19
57377: PUSH
57378: LD_VAR 0 18
57382: PPUSH
57383: LD_INT 2
57385: PUSH
57386: LD_INT 30
57388: PUSH
57389: LD_INT 29
57391: PUSH
57392: EMPTY
57393: LIST
57394: LIST
57395: PUSH
57396: LD_INT 30
57398: PUSH
57399: LD_INT 30
57401: PUSH
57402: EMPTY
57403: LIST
57404: LIST
57405: PUSH
57406: EMPTY
57407: LIST
57408: LIST
57409: LIST
57410: PPUSH
57411: CALL_OW 72
57415: ST_TO_ADDR
// if tmp then
57416: LD_VAR 0 19
57420: IFFALSE 57468
// for i in tmp do
57422: LD_ADDR_VAR 0 8
57426: PUSH
57427: LD_VAR 0 19
57431: PUSH
57432: FOR_IN
57433: IFFALSE 57466
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
57435: LD_VAR 0 8
57439: PPUSH
57440: CALL_OW 250
57444: PPUSH
57445: LD_VAR 0 8
57449: PPUSH
57450: CALL_OW 251
57454: PPUSH
57455: LD_VAR 0 16
57459: PPUSH
57460: CALL_OW 441
57464: GO 57432
57466: POP
57467: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
57468: LD_VAR 0 18
57472: PPUSH
57473: LD_INT 2
57475: PUSH
57476: LD_INT 30
57478: PUSH
57479: LD_INT 32
57481: PUSH
57482: EMPTY
57483: LIST
57484: LIST
57485: PUSH
57486: LD_INT 30
57488: PUSH
57489: LD_INT 33
57491: PUSH
57492: EMPTY
57493: LIST
57494: LIST
57495: PUSH
57496: EMPTY
57497: LIST
57498: LIST
57499: LIST
57500: PPUSH
57501: CALL_OW 72
57505: IFFALSE 57593
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
57507: LD_ADDR_VAR 0 8
57511: PUSH
57512: LD_VAR 0 18
57516: PPUSH
57517: LD_INT 2
57519: PUSH
57520: LD_INT 30
57522: PUSH
57523: LD_INT 32
57525: PUSH
57526: EMPTY
57527: LIST
57528: LIST
57529: PUSH
57530: LD_INT 30
57532: PUSH
57533: LD_INT 33
57535: PUSH
57536: EMPTY
57537: LIST
57538: LIST
57539: PUSH
57540: EMPTY
57541: LIST
57542: LIST
57543: LIST
57544: PPUSH
57545: CALL_OW 72
57549: PUSH
57550: FOR_IN
57551: IFFALSE 57591
// begin if not GetBWeapon ( i ) then
57553: LD_VAR 0 8
57557: PPUSH
57558: CALL_OW 269
57562: NOT
57563: IFFALSE 57589
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
57565: LD_VAR 0 8
57569: PPUSH
57570: LD_VAR 0 8
57574: PPUSH
57575: LD_VAR 0 2
57579: PPUSH
57580: CALL 58839 0 2
57584: PPUSH
57585: CALL_OW 431
// end ;
57589: GO 57550
57591: POP
57592: POP
// end ; for i = 1 to personel do
57593: LD_ADDR_VAR 0 8
57597: PUSH
57598: DOUBLE
57599: LD_INT 1
57601: DEC
57602: ST_TO_ADDR
57603: LD_VAR 0 6
57607: PUSH
57608: FOR_TO
57609: IFFALSE 58673
// begin if i > 4 then
57611: LD_VAR 0 8
57615: PUSH
57616: LD_INT 4
57618: GREATER
57619: IFFALSE 57623
// break ;
57621: GO 58673
// case i of 1 :
57623: LD_VAR 0 8
57627: PUSH
57628: LD_INT 1
57630: DOUBLE
57631: EQUAL
57632: IFTRUE 57636
57634: GO 57716
57636: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
57637: LD_ADDR_VAR 0 12
57641: PUSH
57642: LD_VAR 0 18
57646: PPUSH
57647: LD_INT 22
57649: PUSH
57650: LD_VAR 0 16
57654: PUSH
57655: EMPTY
57656: LIST
57657: LIST
57658: PUSH
57659: LD_INT 58
57661: PUSH
57662: EMPTY
57663: LIST
57664: PUSH
57665: LD_INT 2
57667: PUSH
57668: LD_INT 30
57670: PUSH
57671: LD_INT 32
57673: PUSH
57674: EMPTY
57675: LIST
57676: LIST
57677: PUSH
57678: LD_INT 30
57680: PUSH
57681: LD_INT 4
57683: PUSH
57684: EMPTY
57685: LIST
57686: LIST
57687: PUSH
57688: LD_INT 30
57690: PUSH
57691: LD_INT 5
57693: PUSH
57694: EMPTY
57695: LIST
57696: LIST
57697: PUSH
57698: EMPTY
57699: LIST
57700: LIST
57701: LIST
57702: LIST
57703: PUSH
57704: EMPTY
57705: LIST
57706: LIST
57707: LIST
57708: PPUSH
57709: CALL_OW 72
57713: ST_TO_ADDR
57714: GO 57938
57716: LD_INT 2
57718: DOUBLE
57719: EQUAL
57720: IFTRUE 57724
57722: GO 57786
57724: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
57725: LD_ADDR_VAR 0 12
57729: PUSH
57730: LD_VAR 0 18
57734: PPUSH
57735: LD_INT 22
57737: PUSH
57738: LD_VAR 0 16
57742: PUSH
57743: EMPTY
57744: LIST
57745: LIST
57746: PUSH
57747: LD_INT 2
57749: PUSH
57750: LD_INT 30
57752: PUSH
57753: LD_INT 0
57755: PUSH
57756: EMPTY
57757: LIST
57758: LIST
57759: PUSH
57760: LD_INT 30
57762: PUSH
57763: LD_INT 1
57765: PUSH
57766: EMPTY
57767: LIST
57768: LIST
57769: PUSH
57770: EMPTY
57771: LIST
57772: LIST
57773: LIST
57774: PUSH
57775: EMPTY
57776: LIST
57777: LIST
57778: PPUSH
57779: CALL_OW 72
57783: ST_TO_ADDR
57784: GO 57938
57786: LD_INT 3
57788: DOUBLE
57789: EQUAL
57790: IFTRUE 57794
57792: GO 57856
57794: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
57795: LD_ADDR_VAR 0 12
57799: PUSH
57800: LD_VAR 0 18
57804: PPUSH
57805: LD_INT 22
57807: PUSH
57808: LD_VAR 0 16
57812: PUSH
57813: EMPTY
57814: LIST
57815: LIST
57816: PUSH
57817: LD_INT 2
57819: PUSH
57820: LD_INT 30
57822: PUSH
57823: LD_INT 2
57825: PUSH
57826: EMPTY
57827: LIST
57828: LIST
57829: PUSH
57830: LD_INT 30
57832: PUSH
57833: LD_INT 3
57835: PUSH
57836: EMPTY
57837: LIST
57838: LIST
57839: PUSH
57840: EMPTY
57841: LIST
57842: LIST
57843: LIST
57844: PUSH
57845: EMPTY
57846: LIST
57847: LIST
57848: PPUSH
57849: CALL_OW 72
57853: ST_TO_ADDR
57854: GO 57938
57856: LD_INT 4
57858: DOUBLE
57859: EQUAL
57860: IFTRUE 57864
57862: GO 57937
57864: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
57865: LD_ADDR_VAR 0 12
57869: PUSH
57870: LD_VAR 0 18
57874: PPUSH
57875: LD_INT 22
57877: PUSH
57878: LD_VAR 0 16
57882: PUSH
57883: EMPTY
57884: LIST
57885: LIST
57886: PUSH
57887: LD_INT 2
57889: PUSH
57890: LD_INT 30
57892: PUSH
57893: LD_INT 6
57895: PUSH
57896: EMPTY
57897: LIST
57898: LIST
57899: PUSH
57900: LD_INT 30
57902: PUSH
57903: LD_INT 7
57905: PUSH
57906: EMPTY
57907: LIST
57908: LIST
57909: PUSH
57910: LD_INT 30
57912: PUSH
57913: LD_INT 8
57915: PUSH
57916: EMPTY
57917: LIST
57918: LIST
57919: PUSH
57920: EMPTY
57921: LIST
57922: LIST
57923: LIST
57924: LIST
57925: PUSH
57926: EMPTY
57927: LIST
57928: LIST
57929: PPUSH
57930: CALL_OW 72
57934: ST_TO_ADDR
57935: GO 57938
57937: POP
// if i = 1 then
57938: LD_VAR 0 8
57942: PUSH
57943: LD_INT 1
57945: EQUAL
57946: IFFALSE 58057
// begin tmp := [ ] ;
57948: LD_ADDR_VAR 0 19
57952: PUSH
57953: EMPTY
57954: ST_TO_ADDR
// for j in f do
57955: LD_ADDR_VAR 0 9
57959: PUSH
57960: LD_VAR 0 12
57964: PUSH
57965: FOR_IN
57966: IFFALSE 58039
// if GetBType ( j ) = b_bunker then
57968: LD_VAR 0 9
57972: PPUSH
57973: CALL_OW 266
57977: PUSH
57978: LD_INT 32
57980: EQUAL
57981: IFFALSE 58008
// tmp := Insert ( tmp , 1 , j ) else
57983: LD_ADDR_VAR 0 19
57987: PUSH
57988: LD_VAR 0 19
57992: PPUSH
57993: LD_INT 1
57995: PPUSH
57996: LD_VAR 0 9
58000: PPUSH
58001: CALL_OW 2
58005: ST_TO_ADDR
58006: GO 58037
// tmp := Insert ( tmp , tmp + 1 , j ) ;
58008: LD_ADDR_VAR 0 19
58012: PUSH
58013: LD_VAR 0 19
58017: PPUSH
58018: LD_VAR 0 19
58022: PUSH
58023: LD_INT 1
58025: PLUS
58026: PPUSH
58027: LD_VAR 0 9
58031: PPUSH
58032: CALL_OW 2
58036: ST_TO_ADDR
58037: GO 57965
58039: POP
58040: POP
// if tmp then
58041: LD_VAR 0 19
58045: IFFALSE 58057
// f := tmp ;
58047: LD_ADDR_VAR 0 12
58051: PUSH
58052: LD_VAR 0 19
58056: ST_TO_ADDR
// end ; x := personel [ i ] ;
58057: LD_ADDR_VAR 0 13
58061: PUSH
58062: LD_VAR 0 6
58066: PUSH
58067: LD_VAR 0 8
58071: ARRAY
58072: ST_TO_ADDR
// if x = - 1 then
58073: LD_VAR 0 13
58077: PUSH
58078: LD_INT 1
58080: NEG
58081: EQUAL
58082: IFFALSE 58291
// begin for j in f do
58084: LD_ADDR_VAR 0 9
58088: PUSH
58089: LD_VAR 0 12
58093: PUSH
58094: FOR_IN
58095: IFFALSE 58287
// repeat InitHc ;
58097: CALL_OW 19
// if GetBType ( j ) = b_barracks then
58101: LD_VAR 0 9
58105: PPUSH
58106: CALL_OW 266
58110: PUSH
58111: LD_INT 5
58113: EQUAL
58114: IFFALSE 58184
// begin if UnitsInside ( j ) < 3 then
58116: LD_VAR 0 9
58120: PPUSH
58121: CALL_OW 313
58125: PUSH
58126: LD_INT 3
58128: LESS
58129: IFFALSE 58165
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
58131: LD_INT 0
58133: PPUSH
58134: LD_INT 5
58136: PUSH
58137: LD_INT 8
58139: PUSH
58140: LD_INT 9
58142: PUSH
58143: EMPTY
58144: LIST
58145: LIST
58146: LIST
58147: PUSH
58148: LD_VAR 0 17
58152: ARRAY
58153: PPUSH
58154: LD_VAR 0 4
58158: PPUSH
58159: CALL_OW 380
58163: GO 58182
// PrepareHuman ( false , i , skill ) ;
58165: LD_INT 0
58167: PPUSH
58168: LD_VAR 0 8
58172: PPUSH
58173: LD_VAR 0 4
58177: PPUSH
58178: CALL_OW 380
// end else
58182: GO 58201
// PrepareHuman ( false , i , skill ) ;
58184: LD_INT 0
58186: PPUSH
58187: LD_VAR 0 8
58191: PPUSH
58192: LD_VAR 0 4
58196: PPUSH
58197: CALL_OW 380
// un := CreateHuman ;
58201: LD_ADDR_VAR 0 14
58205: PUSH
58206: CALL_OW 44
58210: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58211: LD_ADDR_VAR 0 7
58215: PUSH
58216: LD_VAR 0 7
58220: PPUSH
58221: LD_INT 1
58223: PPUSH
58224: LD_VAR 0 14
58228: PPUSH
58229: CALL_OW 2
58233: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
58234: LD_VAR 0 14
58238: PPUSH
58239: LD_VAR 0 9
58243: PPUSH
58244: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
58248: LD_VAR 0 9
58252: PPUSH
58253: CALL_OW 313
58257: PUSH
58258: LD_INT 6
58260: EQUAL
58261: PUSH
58262: LD_VAR 0 9
58266: PPUSH
58267: CALL_OW 266
58271: PUSH
58272: LD_INT 32
58274: PUSH
58275: LD_INT 31
58277: PUSH
58278: EMPTY
58279: LIST
58280: LIST
58281: IN
58282: OR
58283: IFFALSE 58097
58285: GO 58094
58287: POP
58288: POP
// end else
58289: GO 58671
// for j = 1 to x do
58291: LD_ADDR_VAR 0 9
58295: PUSH
58296: DOUBLE
58297: LD_INT 1
58299: DEC
58300: ST_TO_ADDR
58301: LD_VAR 0 13
58305: PUSH
58306: FOR_TO
58307: IFFALSE 58669
// begin InitHc ;
58309: CALL_OW 19
// if not f then
58313: LD_VAR 0 12
58317: NOT
58318: IFFALSE 58407
// begin PrepareHuman ( false , i , skill ) ;
58320: LD_INT 0
58322: PPUSH
58323: LD_VAR 0 8
58327: PPUSH
58328: LD_VAR 0 4
58332: PPUSH
58333: CALL_OW 380
// un := CreateHuman ;
58337: LD_ADDR_VAR 0 14
58341: PUSH
58342: CALL_OW 44
58346: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58347: LD_ADDR_VAR 0 7
58351: PUSH
58352: LD_VAR 0 7
58356: PPUSH
58357: LD_INT 1
58359: PPUSH
58360: LD_VAR 0 14
58364: PPUSH
58365: CALL_OW 2
58369: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
58370: LD_VAR 0 14
58374: PPUSH
58375: LD_VAR 0 1
58379: PPUSH
58380: CALL_OW 250
58384: PPUSH
58385: LD_VAR 0 1
58389: PPUSH
58390: CALL_OW 251
58394: PPUSH
58395: LD_INT 10
58397: PPUSH
58398: LD_INT 0
58400: PPUSH
58401: CALL_OW 50
// continue ;
58405: GO 58306
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
58407: LD_VAR 0 12
58411: PUSH
58412: LD_INT 1
58414: ARRAY
58415: PPUSH
58416: CALL_OW 313
58420: PUSH
58421: LD_VAR 0 12
58425: PUSH
58426: LD_INT 1
58428: ARRAY
58429: PPUSH
58430: CALL_OW 266
58434: PUSH
58435: LD_INT 32
58437: PUSH
58438: LD_INT 31
58440: PUSH
58441: EMPTY
58442: LIST
58443: LIST
58444: IN
58445: AND
58446: PUSH
58447: LD_VAR 0 12
58451: PUSH
58452: LD_INT 1
58454: ARRAY
58455: PPUSH
58456: CALL_OW 313
58460: PUSH
58461: LD_INT 6
58463: EQUAL
58464: OR
58465: IFFALSE 58485
// f := Delete ( f , 1 ) ;
58467: LD_ADDR_VAR 0 12
58471: PUSH
58472: LD_VAR 0 12
58476: PPUSH
58477: LD_INT 1
58479: PPUSH
58480: CALL_OW 3
58484: ST_TO_ADDR
// if not f then
58485: LD_VAR 0 12
58489: NOT
58490: IFFALSE 58508
// begin x := x + 2 ;
58492: LD_ADDR_VAR 0 13
58496: PUSH
58497: LD_VAR 0 13
58501: PUSH
58502: LD_INT 2
58504: PLUS
58505: ST_TO_ADDR
// continue ;
58506: GO 58306
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
58508: LD_VAR 0 12
58512: PUSH
58513: LD_INT 1
58515: ARRAY
58516: PPUSH
58517: CALL_OW 266
58521: PUSH
58522: LD_INT 5
58524: EQUAL
58525: IFFALSE 58599
// begin if UnitsInside ( f [ 1 ] ) < 3 then
58527: LD_VAR 0 12
58531: PUSH
58532: LD_INT 1
58534: ARRAY
58535: PPUSH
58536: CALL_OW 313
58540: PUSH
58541: LD_INT 3
58543: LESS
58544: IFFALSE 58580
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
58546: LD_INT 0
58548: PPUSH
58549: LD_INT 5
58551: PUSH
58552: LD_INT 8
58554: PUSH
58555: LD_INT 9
58557: PUSH
58558: EMPTY
58559: LIST
58560: LIST
58561: LIST
58562: PUSH
58563: LD_VAR 0 17
58567: ARRAY
58568: PPUSH
58569: LD_VAR 0 4
58573: PPUSH
58574: CALL_OW 380
58578: GO 58597
// PrepareHuman ( false , i , skill ) ;
58580: LD_INT 0
58582: PPUSH
58583: LD_VAR 0 8
58587: PPUSH
58588: LD_VAR 0 4
58592: PPUSH
58593: CALL_OW 380
// end else
58597: GO 58616
// PrepareHuman ( false , i , skill ) ;
58599: LD_INT 0
58601: PPUSH
58602: LD_VAR 0 8
58606: PPUSH
58607: LD_VAR 0 4
58611: PPUSH
58612: CALL_OW 380
// un := CreateHuman ;
58616: LD_ADDR_VAR 0 14
58620: PUSH
58621: CALL_OW 44
58625: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58626: LD_ADDR_VAR 0 7
58630: PUSH
58631: LD_VAR 0 7
58635: PPUSH
58636: LD_INT 1
58638: PPUSH
58639: LD_VAR 0 14
58643: PPUSH
58644: CALL_OW 2
58648: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
58649: LD_VAR 0 14
58653: PPUSH
58654: LD_VAR 0 12
58658: PUSH
58659: LD_INT 1
58661: ARRAY
58662: PPUSH
58663: CALL_OW 52
// end ;
58667: GO 58306
58669: POP
58670: POP
// end ;
58671: GO 57608
58673: POP
58674: POP
// result := result ^ buildings ;
58675: LD_ADDR_VAR 0 7
58679: PUSH
58680: LD_VAR 0 7
58684: PUSH
58685: LD_VAR 0 18
58689: ADD
58690: ST_TO_ADDR
// end else
58691: GO 58834
// begin for i = 1 to personel do
58693: LD_ADDR_VAR 0 8
58697: PUSH
58698: DOUBLE
58699: LD_INT 1
58701: DEC
58702: ST_TO_ADDR
58703: LD_VAR 0 6
58707: PUSH
58708: FOR_TO
58709: IFFALSE 58832
// begin if i > 4 then
58711: LD_VAR 0 8
58715: PUSH
58716: LD_INT 4
58718: GREATER
58719: IFFALSE 58723
// break ;
58721: GO 58832
// x := personel [ i ] ;
58723: LD_ADDR_VAR 0 13
58727: PUSH
58728: LD_VAR 0 6
58732: PUSH
58733: LD_VAR 0 8
58737: ARRAY
58738: ST_TO_ADDR
// if x = - 1 then
58739: LD_VAR 0 13
58743: PUSH
58744: LD_INT 1
58746: NEG
58747: EQUAL
58748: IFFALSE 58752
// continue ;
58750: GO 58708
// PrepareHuman ( false , i , skill ) ;
58752: LD_INT 0
58754: PPUSH
58755: LD_VAR 0 8
58759: PPUSH
58760: LD_VAR 0 4
58764: PPUSH
58765: CALL_OW 380
// un := CreateHuman ;
58769: LD_ADDR_VAR 0 14
58773: PUSH
58774: CALL_OW 44
58778: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
58779: LD_VAR 0 14
58783: PPUSH
58784: LD_VAR 0 1
58788: PPUSH
58789: CALL_OW 250
58793: PPUSH
58794: LD_VAR 0 1
58798: PPUSH
58799: CALL_OW 251
58803: PPUSH
58804: LD_INT 10
58806: PPUSH
58807: LD_INT 0
58809: PPUSH
58810: CALL_OW 50
// result := result ^ un ;
58814: LD_ADDR_VAR 0 7
58818: PUSH
58819: LD_VAR 0 7
58823: PUSH
58824: LD_VAR 0 14
58828: ADD
58829: ST_TO_ADDR
// end ;
58830: GO 58708
58832: POP
58833: POP
// end ; end ;
58834: LD_VAR 0 7
58838: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
58839: LD_INT 0
58841: PPUSH
58842: PPUSH
58843: PPUSH
58844: PPUSH
58845: PPUSH
58846: PPUSH
58847: PPUSH
58848: PPUSH
58849: PPUSH
58850: PPUSH
58851: PPUSH
58852: PPUSH
58853: PPUSH
58854: PPUSH
58855: PPUSH
58856: PPUSH
// result := false ;
58857: LD_ADDR_VAR 0 3
58861: PUSH
58862: LD_INT 0
58864: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
58865: LD_VAR 0 1
58869: NOT
58870: PUSH
58871: LD_VAR 0 1
58875: PPUSH
58876: CALL_OW 266
58880: PUSH
58881: LD_INT 32
58883: PUSH
58884: LD_INT 33
58886: PUSH
58887: EMPTY
58888: LIST
58889: LIST
58890: IN
58891: NOT
58892: OR
58893: IFFALSE 58897
// exit ;
58895: GO 60006
// nat := GetNation ( tower ) ;
58897: LD_ADDR_VAR 0 12
58901: PUSH
58902: LD_VAR 0 1
58906: PPUSH
58907: CALL_OW 248
58911: ST_TO_ADDR
// side := GetSide ( tower ) ;
58912: LD_ADDR_VAR 0 16
58916: PUSH
58917: LD_VAR 0 1
58921: PPUSH
58922: CALL_OW 255
58926: ST_TO_ADDR
// x := GetX ( tower ) ;
58927: LD_ADDR_VAR 0 10
58931: PUSH
58932: LD_VAR 0 1
58936: PPUSH
58937: CALL_OW 250
58941: ST_TO_ADDR
// y := GetY ( tower ) ;
58942: LD_ADDR_VAR 0 11
58946: PUSH
58947: LD_VAR 0 1
58951: PPUSH
58952: CALL_OW 251
58956: ST_TO_ADDR
// if not x or not y then
58957: LD_VAR 0 10
58961: NOT
58962: PUSH
58963: LD_VAR 0 11
58967: NOT
58968: OR
58969: IFFALSE 58973
// exit ;
58971: GO 60006
// weapon := 0 ;
58973: LD_ADDR_VAR 0 18
58977: PUSH
58978: LD_INT 0
58980: ST_TO_ADDR
// fac_list := [ ] ;
58981: LD_ADDR_VAR 0 17
58985: PUSH
58986: EMPTY
58987: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
58988: LD_ADDR_VAR 0 6
58992: PUSH
58993: LD_VAR 0 1
58997: PPUSH
58998: CALL_OW 274
59002: PPUSH
59003: LD_VAR 0 2
59007: PPUSH
59008: LD_INT 0
59010: PPUSH
59011: CALL 56577 0 3
59015: PPUSH
59016: LD_INT 30
59018: PUSH
59019: LD_INT 3
59021: PUSH
59022: EMPTY
59023: LIST
59024: LIST
59025: PPUSH
59026: CALL_OW 72
59030: ST_TO_ADDR
// if not factories then
59031: LD_VAR 0 6
59035: NOT
59036: IFFALSE 59040
// exit ;
59038: GO 60006
// for i in factories do
59040: LD_ADDR_VAR 0 8
59044: PUSH
59045: LD_VAR 0 6
59049: PUSH
59050: FOR_IN
59051: IFFALSE 59076
// fac_list := fac_list union AvailableWeaponList ( i ) ;
59053: LD_ADDR_VAR 0 17
59057: PUSH
59058: LD_VAR 0 17
59062: PUSH
59063: LD_VAR 0 8
59067: PPUSH
59068: CALL_OW 478
59072: UNION
59073: ST_TO_ADDR
59074: GO 59050
59076: POP
59077: POP
// if not fac_list then
59078: LD_VAR 0 17
59082: NOT
59083: IFFALSE 59087
// exit ;
59085: GO 60006
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
59087: LD_ADDR_VAR 0 5
59091: PUSH
59092: LD_INT 4
59094: PUSH
59095: LD_INT 5
59097: PUSH
59098: LD_INT 9
59100: PUSH
59101: LD_INT 10
59103: PUSH
59104: LD_INT 6
59106: PUSH
59107: LD_INT 7
59109: PUSH
59110: LD_INT 11
59112: PUSH
59113: EMPTY
59114: LIST
59115: LIST
59116: LIST
59117: LIST
59118: LIST
59119: LIST
59120: LIST
59121: PUSH
59122: LD_INT 27
59124: PUSH
59125: LD_INT 28
59127: PUSH
59128: LD_INT 26
59130: PUSH
59131: LD_INT 30
59133: PUSH
59134: EMPTY
59135: LIST
59136: LIST
59137: LIST
59138: LIST
59139: PUSH
59140: LD_INT 43
59142: PUSH
59143: LD_INT 44
59145: PUSH
59146: LD_INT 46
59148: PUSH
59149: LD_INT 45
59151: PUSH
59152: LD_INT 47
59154: PUSH
59155: LD_INT 49
59157: PUSH
59158: EMPTY
59159: LIST
59160: LIST
59161: LIST
59162: LIST
59163: LIST
59164: LIST
59165: PUSH
59166: EMPTY
59167: LIST
59168: LIST
59169: LIST
59170: PUSH
59171: LD_VAR 0 12
59175: ARRAY
59176: ST_TO_ADDR
// list := list isect fac_list ;
59177: LD_ADDR_VAR 0 5
59181: PUSH
59182: LD_VAR 0 5
59186: PUSH
59187: LD_VAR 0 17
59191: ISECT
59192: ST_TO_ADDR
// if not list then
59193: LD_VAR 0 5
59197: NOT
59198: IFFALSE 59202
// exit ;
59200: GO 60006
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
59202: LD_VAR 0 12
59206: PUSH
59207: LD_INT 3
59209: EQUAL
59210: PUSH
59211: LD_INT 49
59213: PUSH
59214: LD_VAR 0 5
59218: IN
59219: AND
59220: PUSH
59221: LD_INT 31
59223: PPUSH
59224: LD_VAR 0 16
59228: PPUSH
59229: CALL_OW 321
59233: PUSH
59234: LD_INT 2
59236: EQUAL
59237: AND
59238: IFFALSE 59298
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
59240: LD_INT 22
59242: PUSH
59243: LD_VAR 0 16
59247: PUSH
59248: EMPTY
59249: LIST
59250: LIST
59251: PUSH
59252: LD_INT 35
59254: PUSH
59255: LD_INT 49
59257: PUSH
59258: EMPTY
59259: LIST
59260: LIST
59261: PUSH
59262: LD_INT 91
59264: PUSH
59265: LD_VAR 0 1
59269: PUSH
59270: LD_INT 10
59272: PUSH
59273: EMPTY
59274: LIST
59275: LIST
59276: LIST
59277: PUSH
59278: EMPTY
59279: LIST
59280: LIST
59281: LIST
59282: PPUSH
59283: CALL_OW 69
59287: NOT
59288: IFFALSE 59298
// weapon := ru_time_lapser ;
59290: LD_ADDR_VAR 0 18
59294: PUSH
59295: LD_INT 49
59297: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
59298: LD_VAR 0 12
59302: PUSH
59303: LD_INT 1
59305: PUSH
59306: LD_INT 2
59308: PUSH
59309: EMPTY
59310: LIST
59311: LIST
59312: IN
59313: PUSH
59314: LD_INT 11
59316: PUSH
59317: LD_VAR 0 5
59321: IN
59322: PUSH
59323: LD_INT 30
59325: PUSH
59326: LD_VAR 0 5
59330: IN
59331: OR
59332: AND
59333: PUSH
59334: LD_INT 6
59336: PPUSH
59337: LD_VAR 0 16
59341: PPUSH
59342: CALL_OW 321
59346: PUSH
59347: LD_INT 2
59349: EQUAL
59350: AND
59351: IFFALSE 59516
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
59353: LD_INT 22
59355: PUSH
59356: LD_VAR 0 16
59360: PUSH
59361: EMPTY
59362: LIST
59363: LIST
59364: PUSH
59365: LD_INT 2
59367: PUSH
59368: LD_INT 35
59370: PUSH
59371: LD_INT 11
59373: PUSH
59374: EMPTY
59375: LIST
59376: LIST
59377: PUSH
59378: LD_INT 35
59380: PUSH
59381: LD_INT 30
59383: PUSH
59384: EMPTY
59385: LIST
59386: LIST
59387: PUSH
59388: EMPTY
59389: LIST
59390: LIST
59391: LIST
59392: PUSH
59393: LD_INT 91
59395: PUSH
59396: LD_VAR 0 1
59400: PUSH
59401: LD_INT 18
59403: PUSH
59404: EMPTY
59405: LIST
59406: LIST
59407: LIST
59408: PUSH
59409: EMPTY
59410: LIST
59411: LIST
59412: LIST
59413: PPUSH
59414: CALL_OW 69
59418: NOT
59419: PUSH
59420: LD_INT 22
59422: PUSH
59423: LD_VAR 0 16
59427: PUSH
59428: EMPTY
59429: LIST
59430: LIST
59431: PUSH
59432: LD_INT 2
59434: PUSH
59435: LD_INT 30
59437: PUSH
59438: LD_INT 32
59440: PUSH
59441: EMPTY
59442: LIST
59443: LIST
59444: PUSH
59445: LD_INT 30
59447: PUSH
59448: LD_INT 33
59450: PUSH
59451: EMPTY
59452: LIST
59453: LIST
59454: PUSH
59455: EMPTY
59456: LIST
59457: LIST
59458: LIST
59459: PUSH
59460: LD_INT 91
59462: PUSH
59463: LD_VAR 0 1
59467: PUSH
59468: LD_INT 12
59470: PUSH
59471: EMPTY
59472: LIST
59473: LIST
59474: LIST
59475: PUSH
59476: EMPTY
59477: LIST
59478: LIST
59479: LIST
59480: PUSH
59481: EMPTY
59482: LIST
59483: PPUSH
59484: CALL_OW 69
59488: PUSH
59489: LD_INT 2
59491: GREATER
59492: AND
59493: IFFALSE 59516
// weapon := [ us_radar , ar_radar ] [ nat ] ;
59495: LD_ADDR_VAR 0 18
59499: PUSH
59500: LD_INT 11
59502: PUSH
59503: LD_INT 30
59505: PUSH
59506: EMPTY
59507: LIST
59508: LIST
59509: PUSH
59510: LD_VAR 0 12
59514: ARRAY
59515: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
59516: LD_VAR 0 18
59520: NOT
59521: PUSH
59522: LD_INT 40
59524: PPUSH
59525: LD_VAR 0 16
59529: PPUSH
59530: CALL_OW 321
59534: PUSH
59535: LD_INT 2
59537: EQUAL
59538: AND
59539: PUSH
59540: LD_INT 7
59542: PUSH
59543: LD_VAR 0 5
59547: IN
59548: PUSH
59549: LD_INT 28
59551: PUSH
59552: LD_VAR 0 5
59556: IN
59557: OR
59558: PUSH
59559: LD_INT 45
59561: PUSH
59562: LD_VAR 0 5
59566: IN
59567: OR
59568: AND
59569: IFFALSE 59823
// begin hex := GetHexInfo ( x , y ) ;
59571: LD_ADDR_VAR 0 4
59575: PUSH
59576: LD_VAR 0 10
59580: PPUSH
59581: LD_VAR 0 11
59585: PPUSH
59586: CALL_OW 546
59590: ST_TO_ADDR
// if hex [ 1 ] then
59591: LD_VAR 0 4
59595: PUSH
59596: LD_INT 1
59598: ARRAY
59599: IFFALSE 59603
// exit ;
59601: GO 60006
// height := hex [ 2 ] ;
59603: LD_ADDR_VAR 0 15
59607: PUSH
59608: LD_VAR 0 4
59612: PUSH
59613: LD_INT 2
59615: ARRAY
59616: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
59617: LD_ADDR_VAR 0 14
59621: PUSH
59622: LD_INT 0
59624: PUSH
59625: LD_INT 2
59627: PUSH
59628: LD_INT 3
59630: PUSH
59631: LD_INT 5
59633: PUSH
59634: EMPTY
59635: LIST
59636: LIST
59637: LIST
59638: LIST
59639: ST_TO_ADDR
// for i in tmp do
59640: LD_ADDR_VAR 0 8
59644: PUSH
59645: LD_VAR 0 14
59649: PUSH
59650: FOR_IN
59651: IFFALSE 59821
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
59653: LD_ADDR_VAR 0 9
59657: PUSH
59658: LD_VAR 0 10
59662: PPUSH
59663: LD_VAR 0 8
59667: PPUSH
59668: LD_INT 5
59670: PPUSH
59671: CALL_OW 272
59675: PUSH
59676: LD_VAR 0 11
59680: PPUSH
59681: LD_VAR 0 8
59685: PPUSH
59686: LD_INT 5
59688: PPUSH
59689: CALL_OW 273
59693: PUSH
59694: EMPTY
59695: LIST
59696: LIST
59697: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
59698: LD_VAR 0 9
59702: PUSH
59703: LD_INT 1
59705: ARRAY
59706: PPUSH
59707: LD_VAR 0 9
59711: PUSH
59712: LD_INT 2
59714: ARRAY
59715: PPUSH
59716: CALL_OW 488
59720: IFFALSE 59819
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
59722: LD_ADDR_VAR 0 4
59726: PUSH
59727: LD_VAR 0 9
59731: PUSH
59732: LD_INT 1
59734: ARRAY
59735: PPUSH
59736: LD_VAR 0 9
59740: PUSH
59741: LD_INT 2
59743: ARRAY
59744: PPUSH
59745: CALL_OW 546
59749: ST_TO_ADDR
// if hex [ 1 ] then
59750: LD_VAR 0 4
59754: PUSH
59755: LD_INT 1
59757: ARRAY
59758: IFFALSE 59762
// continue ;
59760: GO 59650
// h := hex [ 2 ] ;
59762: LD_ADDR_VAR 0 13
59766: PUSH
59767: LD_VAR 0 4
59771: PUSH
59772: LD_INT 2
59774: ARRAY
59775: ST_TO_ADDR
// if h + 7 < height then
59776: LD_VAR 0 13
59780: PUSH
59781: LD_INT 7
59783: PLUS
59784: PUSH
59785: LD_VAR 0 15
59789: LESS
59790: IFFALSE 59819
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
59792: LD_ADDR_VAR 0 18
59796: PUSH
59797: LD_INT 7
59799: PUSH
59800: LD_INT 28
59802: PUSH
59803: LD_INT 45
59805: PUSH
59806: EMPTY
59807: LIST
59808: LIST
59809: LIST
59810: PUSH
59811: LD_VAR 0 12
59815: ARRAY
59816: ST_TO_ADDR
// break ;
59817: GO 59821
// end ; end ; end ;
59819: GO 59650
59821: POP
59822: POP
// end ; if not weapon then
59823: LD_VAR 0 18
59827: NOT
59828: IFFALSE 59888
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
59830: LD_ADDR_VAR 0 5
59834: PUSH
59835: LD_VAR 0 5
59839: PUSH
59840: LD_INT 11
59842: PUSH
59843: LD_INT 30
59845: PUSH
59846: LD_INT 49
59848: PUSH
59849: EMPTY
59850: LIST
59851: LIST
59852: LIST
59853: DIFF
59854: ST_TO_ADDR
// if not list then
59855: LD_VAR 0 5
59859: NOT
59860: IFFALSE 59864
// exit ;
59862: GO 60006
// weapon := list [ rand ( 1 , list ) ] ;
59864: LD_ADDR_VAR 0 18
59868: PUSH
59869: LD_VAR 0 5
59873: PUSH
59874: LD_INT 1
59876: PPUSH
59877: LD_VAR 0 5
59881: PPUSH
59882: CALL_OW 12
59886: ARRAY
59887: ST_TO_ADDR
// end ; if weapon then
59888: LD_VAR 0 18
59892: IFFALSE 60006
// begin tmp := CostOfWeapon ( weapon ) ;
59894: LD_ADDR_VAR 0 14
59898: PUSH
59899: LD_VAR 0 18
59903: PPUSH
59904: CALL_OW 451
59908: ST_TO_ADDR
// j := GetBase ( tower ) ;
59909: LD_ADDR_VAR 0 9
59913: PUSH
59914: LD_VAR 0 1
59918: PPUSH
59919: CALL_OW 274
59923: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
59924: LD_VAR 0 9
59928: PPUSH
59929: LD_INT 1
59931: PPUSH
59932: CALL_OW 275
59936: PUSH
59937: LD_VAR 0 14
59941: PUSH
59942: LD_INT 1
59944: ARRAY
59945: GREATEREQUAL
59946: PUSH
59947: LD_VAR 0 9
59951: PPUSH
59952: LD_INT 2
59954: PPUSH
59955: CALL_OW 275
59959: PUSH
59960: LD_VAR 0 14
59964: PUSH
59965: LD_INT 2
59967: ARRAY
59968: GREATEREQUAL
59969: AND
59970: PUSH
59971: LD_VAR 0 9
59975: PPUSH
59976: LD_INT 3
59978: PPUSH
59979: CALL_OW 275
59983: PUSH
59984: LD_VAR 0 14
59988: PUSH
59989: LD_INT 3
59991: ARRAY
59992: GREATEREQUAL
59993: AND
59994: IFFALSE 60006
// result := weapon ;
59996: LD_ADDR_VAR 0 3
60000: PUSH
60001: LD_VAR 0 18
60005: ST_TO_ADDR
// end ; end ;
60006: LD_VAR 0 3
60010: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
60011: LD_INT 0
60013: PPUSH
60014: PPUSH
// result := true ;
60015: LD_ADDR_VAR 0 3
60019: PUSH
60020: LD_INT 1
60022: ST_TO_ADDR
// if array1 = array2 then
60023: LD_VAR 0 1
60027: PUSH
60028: LD_VAR 0 2
60032: EQUAL
60033: IFFALSE 60093
// begin for i = 1 to array1 do
60035: LD_ADDR_VAR 0 4
60039: PUSH
60040: DOUBLE
60041: LD_INT 1
60043: DEC
60044: ST_TO_ADDR
60045: LD_VAR 0 1
60049: PUSH
60050: FOR_TO
60051: IFFALSE 60089
// if array1 [ i ] <> array2 [ i ] then
60053: LD_VAR 0 1
60057: PUSH
60058: LD_VAR 0 4
60062: ARRAY
60063: PUSH
60064: LD_VAR 0 2
60068: PUSH
60069: LD_VAR 0 4
60073: ARRAY
60074: NONEQUAL
60075: IFFALSE 60087
// begin result := false ;
60077: LD_ADDR_VAR 0 3
60081: PUSH
60082: LD_INT 0
60084: ST_TO_ADDR
// break ;
60085: GO 60089
// end ;
60087: GO 60050
60089: POP
60090: POP
// end else
60091: GO 60101
// result := false ;
60093: LD_ADDR_VAR 0 3
60097: PUSH
60098: LD_INT 0
60100: ST_TO_ADDR
// end ;
60101: LD_VAR 0 3
60105: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
60106: LD_INT 0
60108: PPUSH
60109: PPUSH
// if not array1 or not array2 then
60110: LD_VAR 0 1
60114: NOT
60115: PUSH
60116: LD_VAR 0 2
60120: NOT
60121: OR
60122: IFFALSE 60126
// exit ;
60124: GO 60190
// result := true ;
60126: LD_ADDR_VAR 0 3
60130: PUSH
60131: LD_INT 1
60133: ST_TO_ADDR
// for i = 1 to array1 do
60134: LD_ADDR_VAR 0 4
60138: PUSH
60139: DOUBLE
60140: LD_INT 1
60142: DEC
60143: ST_TO_ADDR
60144: LD_VAR 0 1
60148: PUSH
60149: FOR_TO
60150: IFFALSE 60188
// if array1 [ i ] <> array2 [ i ] then
60152: LD_VAR 0 1
60156: PUSH
60157: LD_VAR 0 4
60161: ARRAY
60162: PUSH
60163: LD_VAR 0 2
60167: PUSH
60168: LD_VAR 0 4
60172: ARRAY
60173: NONEQUAL
60174: IFFALSE 60186
// begin result := false ;
60176: LD_ADDR_VAR 0 3
60180: PUSH
60181: LD_INT 0
60183: ST_TO_ADDR
// break ;
60184: GO 60188
// end ;
60186: GO 60149
60188: POP
60189: POP
// end ;
60190: LD_VAR 0 3
60194: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
60195: LD_INT 0
60197: PPUSH
60198: PPUSH
60199: PPUSH
// pom := GetBase ( fac ) ;
60200: LD_ADDR_VAR 0 5
60204: PUSH
60205: LD_VAR 0 1
60209: PPUSH
60210: CALL_OW 274
60214: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
60215: LD_ADDR_VAR 0 4
60219: PUSH
60220: LD_VAR 0 2
60224: PUSH
60225: LD_INT 1
60227: ARRAY
60228: PPUSH
60229: LD_VAR 0 2
60233: PUSH
60234: LD_INT 2
60236: ARRAY
60237: PPUSH
60238: LD_VAR 0 2
60242: PUSH
60243: LD_INT 3
60245: ARRAY
60246: PPUSH
60247: LD_VAR 0 2
60251: PUSH
60252: LD_INT 4
60254: ARRAY
60255: PPUSH
60256: CALL_OW 449
60260: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60261: LD_ADDR_VAR 0 3
60265: PUSH
60266: LD_VAR 0 5
60270: PPUSH
60271: LD_INT 1
60273: PPUSH
60274: CALL_OW 275
60278: PUSH
60279: LD_VAR 0 4
60283: PUSH
60284: LD_INT 1
60286: ARRAY
60287: GREATEREQUAL
60288: PUSH
60289: LD_VAR 0 5
60293: PPUSH
60294: LD_INT 2
60296: PPUSH
60297: CALL_OW 275
60301: PUSH
60302: LD_VAR 0 4
60306: PUSH
60307: LD_INT 2
60309: ARRAY
60310: GREATEREQUAL
60311: AND
60312: PUSH
60313: LD_VAR 0 5
60317: PPUSH
60318: LD_INT 3
60320: PPUSH
60321: CALL_OW 275
60325: PUSH
60326: LD_VAR 0 4
60330: PUSH
60331: LD_INT 3
60333: ARRAY
60334: GREATEREQUAL
60335: AND
60336: ST_TO_ADDR
// end ;
60337: LD_VAR 0 3
60341: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
60342: LD_INT 0
60344: PPUSH
60345: PPUSH
60346: PPUSH
60347: PPUSH
// pom := GetBase ( building ) ;
60348: LD_ADDR_VAR 0 3
60352: PUSH
60353: LD_VAR 0 1
60357: PPUSH
60358: CALL_OW 274
60362: ST_TO_ADDR
// if not pom then
60363: LD_VAR 0 3
60367: NOT
60368: IFFALSE 60372
// exit ;
60370: GO 60542
// btype := GetBType ( building ) ;
60372: LD_ADDR_VAR 0 5
60376: PUSH
60377: LD_VAR 0 1
60381: PPUSH
60382: CALL_OW 266
60386: ST_TO_ADDR
// if btype = b_armoury then
60387: LD_VAR 0 5
60391: PUSH
60392: LD_INT 4
60394: EQUAL
60395: IFFALSE 60405
// btype := b_barracks ;
60397: LD_ADDR_VAR 0 5
60401: PUSH
60402: LD_INT 5
60404: ST_TO_ADDR
// if btype = b_depot then
60405: LD_VAR 0 5
60409: PUSH
60410: LD_INT 0
60412: EQUAL
60413: IFFALSE 60423
// btype := b_warehouse ;
60415: LD_ADDR_VAR 0 5
60419: PUSH
60420: LD_INT 1
60422: ST_TO_ADDR
// if btype = b_workshop then
60423: LD_VAR 0 5
60427: PUSH
60428: LD_INT 2
60430: EQUAL
60431: IFFALSE 60441
// btype := b_factory ;
60433: LD_ADDR_VAR 0 5
60437: PUSH
60438: LD_INT 3
60440: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
60441: LD_ADDR_VAR 0 4
60445: PUSH
60446: LD_VAR 0 5
60450: PPUSH
60451: LD_VAR 0 1
60455: PPUSH
60456: CALL_OW 248
60460: PPUSH
60461: CALL_OW 450
60465: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60466: LD_ADDR_VAR 0 2
60470: PUSH
60471: LD_VAR 0 3
60475: PPUSH
60476: LD_INT 1
60478: PPUSH
60479: CALL_OW 275
60483: PUSH
60484: LD_VAR 0 4
60488: PUSH
60489: LD_INT 1
60491: ARRAY
60492: GREATEREQUAL
60493: PUSH
60494: LD_VAR 0 3
60498: PPUSH
60499: LD_INT 2
60501: PPUSH
60502: CALL_OW 275
60506: PUSH
60507: LD_VAR 0 4
60511: PUSH
60512: LD_INT 2
60514: ARRAY
60515: GREATEREQUAL
60516: AND
60517: PUSH
60518: LD_VAR 0 3
60522: PPUSH
60523: LD_INT 3
60525: PPUSH
60526: CALL_OW 275
60530: PUSH
60531: LD_VAR 0 4
60535: PUSH
60536: LD_INT 3
60538: ARRAY
60539: GREATEREQUAL
60540: AND
60541: ST_TO_ADDR
// end ;
60542: LD_VAR 0 2
60546: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
60547: LD_INT 0
60549: PPUSH
60550: PPUSH
60551: PPUSH
// pom := GetBase ( building ) ;
60552: LD_ADDR_VAR 0 4
60556: PUSH
60557: LD_VAR 0 1
60561: PPUSH
60562: CALL_OW 274
60566: ST_TO_ADDR
// if not pom then
60567: LD_VAR 0 4
60571: NOT
60572: IFFALSE 60576
// exit ;
60574: GO 60677
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
60576: LD_ADDR_VAR 0 5
60580: PUSH
60581: LD_VAR 0 2
60585: PPUSH
60586: LD_VAR 0 1
60590: PPUSH
60591: CALL_OW 248
60595: PPUSH
60596: CALL_OW 450
60600: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60601: LD_ADDR_VAR 0 3
60605: PUSH
60606: LD_VAR 0 4
60610: PPUSH
60611: LD_INT 1
60613: PPUSH
60614: CALL_OW 275
60618: PUSH
60619: LD_VAR 0 5
60623: PUSH
60624: LD_INT 1
60626: ARRAY
60627: GREATEREQUAL
60628: PUSH
60629: LD_VAR 0 4
60633: PPUSH
60634: LD_INT 2
60636: PPUSH
60637: CALL_OW 275
60641: PUSH
60642: LD_VAR 0 5
60646: PUSH
60647: LD_INT 2
60649: ARRAY
60650: GREATEREQUAL
60651: AND
60652: PUSH
60653: LD_VAR 0 4
60657: PPUSH
60658: LD_INT 3
60660: PPUSH
60661: CALL_OW 275
60665: PUSH
60666: LD_VAR 0 5
60670: PUSH
60671: LD_INT 3
60673: ARRAY
60674: GREATEREQUAL
60675: AND
60676: ST_TO_ADDR
// end ;
60677: LD_VAR 0 3
60681: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
60682: LD_INT 0
60684: PPUSH
60685: PPUSH
60686: PPUSH
60687: PPUSH
60688: PPUSH
60689: PPUSH
60690: PPUSH
60691: PPUSH
60692: PPUSH
60693: PPUSH
60694: PPUSH
// result := false ;
60695: LD_ADDR_VAR 0 8
60699: PUSH
60700: LD_INT 0
60702: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
60703: LD_VAR 0 5
60707: NOT
60708: PUSH
60709: LD_VAR 0 1
60713: NOT
60714: OR
60715: PUSH
60716: LD_VAR 0 2
60720: NOT
60721: OR
60722: PUSH
60723: LD_VAR 0 3
60727: NOT
60728: OR
60729: IFFALSE 60733
// exit ;
60731: GO 61547
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
60733: LD_ADDR_VAR 0 14
60737: PUSH
60738: LD_VAR 0 1
60742: PPUSH
60743: LD_VAR 0 2
60747: PPUSH
60748: LD_VAR 0 3
60752: PPUSH
60753: LD_VAR 0 4
60757: PPUSH
60758: LD_VAR 0 5
60762: PUSH
60763: LD_INT 1
60765: ARRAY
60766: PPUSH
60767: CALL_OW 248
60771: PPUSH
60772: LD_INT 0
60774: PPUSH
60775: CALL 62780 0 6
60779: ST_TO_ADDR
// if not hexes then
60780: LD_VAR 0 14
60784: NOT
60785: IFFALSE 60789
// exit ;
60787: GO 61547
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
60789: LD_ADDR_VAR 0 17
60793: PUSH
60794: LD_VAR 0 5
60798: PPUSH
60799: LD_INT 22
60801: PUSH
60802: LD_VAR 0 13
60806: PPUSH
60807: CALL_OW 255
60811: PUSH
60812: EMPTY
60813: LIST
60814: LIST
60815: PUSH
60816: LD_INT 2
60818: PUSH
60819: LD_INT 30
60821: PUSH
60822: LD_INT 0
60824: PUSH
60825: EMPTY
60826: LIST
60827: LIST
60828: PUSH
60829: LD_INT 30
60831: PUSH
60832: LD_INT 1
60834: PUSH
60835: EMPTY
60836: LIST
60837: LIST
60838: PUSH
60839: EMPTY
60840: LIST
60841: LIST
60842: LIST
60843: PUSH
60844: EMPTY
60845: LIST
60846: LIST
60847: PPUSH
60848: CALL_OW 72
60852: ST_TO_ADDR
// for i = 1 to hexes do
60853: LD_ADDR_VAR 0 9
60857: PUSH
60858: DOUBLE
60859: LD_INT 1
60861: DEC
60862: ST_TO_ADDR
60863: LD_VAR 0 14
60867: PUSH
60868: FOR_TO
60869: IFFALSE 61545
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
60871: LD_ADDR_VAR 0 13
60875: PUSH
60876: LD_VAR 0 14
60880: PUSH
60881: LD_VAR 0 9
60885: ARRAY
60886: PUSH
60887: LD_INT 1
60889: ARRAY
60890: PPUSH
60891: LD_VAR 0 14
60895: PUSH
60896: LD_VAR 0 9
60900: ARRAY
60901: PUSH
60902: LD_INT 2
60904: ARRAY
60905: PPUSH
60906: CALL_OW 428
60910: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
60911: LD_VAR 0 14
60915: PUSH
60916: LD_VAR 0 9
60920: ARRAY
60921: PUSH
60922: LD_INT 1
60924: ARRAY
60925: PPUSH
60926: LD_VAR 0 14
60930: PUSH
60931: LD_VAR 0 9
60935: ARRAY
60936: PUSH
60937: LD_INT 2
60939: ARRAY
60940: PPUSH
60941: CALL_OW 351
60945: PUSH
60946: LD_VAR 0 14
60950: PUSH
60951: LD_VAR 0 9
60955: ARRAY
60956: PUSH
60957: LD_INT 1
60959: ARRAY
60960: PPUSH
60961: LD_VAR 0 14
60965: PUSH
60966: LD_VAR 0 9
60970: ARRAY
60971: PUSH
60972: LD_INT 2
60974: ARRAY
60975: PPUSH
60976: CALL_OW 488
60980: NOT
60981: OR
60982: PUSH
60983: LD_VAR 0 13
60987: PPUSH
60988: CALL_OW 247
60992: PUSH
60993: LD_INT 3
60995: EQUAL
60996: OR
60997: IFFALSE 61003
// exit ;
60999: POP
61000: POP
61001: GO 61547
// if not tmp then
61003: LD_VAR 0 13
61007: NOT
61008: IFFALSE 61012
// continue ;
61010: GO 60868
// result := true ;
61012: LD_ADDR_VAR 0 8
61016: PUSH
61017: LD_INT 1
61019: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
61020: LD_VAR 0 6
61024: PUSH
61025: LD_VAR 0 13
61029: PPUSH
61030: CALL_OW 247
61034: PUSH
61035: LD_INT 2
61037: EQUAL
61038: AND
61039: PUSH
61040: LD_VAR 0 13
61044: PPUSH
61045: CALL_OW 263
61049: PUSH
61050: LD_INT 1
61052: EQUAL
61053: AND
61054: IFFALSE 61218
// begin if IsDrivenBy ( tmp ) then
61056: LD_VAR 0 13
61060: PPUSH
61061: CALL_OW 311
61065: IFFALSE 61069
// continue ;
61067: GO 60868
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
61069: LD_VAR 0 6
61073: PPUSH
61074: LD_INT 3
61076: PUSH
61077: LD_INT 60
61079: PUSH
61080: EMPTY
61081: LIST
61082: PUSH
61083: EMPTY
61084: LIST
61085: LIST
61086: PUSH
61087: LD_INT 3
61089: PUSH
61090: LD_INT 55
61092: PUSH
61093: EMPTY
61094: LIST
61095: PUSH
61096: EMPTY
61097: LIST
61098: LIST
61099: PUSH
61100: EMPTY
61101: LIST
61102: LIST
61103: PPUSH
61104: CALL_OW 72
61108: IFFALSE 61216
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
61110: LD_ADDR_VAR 0 18
61114: PUSH
61115: LD_VAR 0 6
61119: PPUSH
61120: LD_INT 3
61122: PUSH
61123: LD_INT 60
61125: PUSH
61126: EMPTY
61127: LIST
61128: PUSH
61129: EMPTY
61130: LIST
61131: LIST
61132: PUSH
61133: LD_INT 3
61135: PUSH
61136: LD_INT 55
61138: PUSH
61139: EMPTY
61140: LIST
61141: PUSH
61142: EMPTY
61143: LIST
61144: LIST
61145: PUSH
61146: EMPTY
61147: LIST
61148: LIST
61149: PPUSH
61150: CALL_OW 72
61154: PUSH
61155: LD_INT 1
61157: ARRAY
61158: ST_TO_ADDR
// if IsInUnit ( driver ) then
61159: LD_VAR 0 18
61163: PPUSH
61164: CALL_OW 310
61168: IFFALSE 61179
// ComExit ( driver ) ;
61170: LD_VAR 0 18
61174: PPUSH
61175: CALL 86560 0 1
// AddComEnterUnit ( driver , tmp ) ;
61179: LD_VAR 0 18
61183: PPUSH
61184: LD_VAR 0 13
61188: PPUSH
61189: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
61193: LD_VAR 0 18
61197: PPUSH
61198: LD_VAR 0 7
61202: PPUSH
61203: CALL_OW 173
// AddComExitVehicle ( driver ) ;
61207: LD_VAR 0 18
61211: PPUSH
61212: CALL_OW 181
// end ; continue ;
61216: GO 60868
// end ; if not cleaners or not tmp in cleaners then
61218: LD_VAR 0 6
61222: NOT
61223: PUSH
61224: LD_VAR 0 13
61228: PUSH
61229: LD_VAR 0 6
61233: IN
61234: NOT
61235: OR
61236: IFFALSE 61543
// begin if dep then
61238: LD_VAR 0 17
61242: IFFALSE 61378
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
61244: LD_ADDR_VAR 0 16
61248: PUSH
61249: LD_VAR 0 17
61253: PUSH
61254: LD_INT 1
61256: ARRAY
61257: PPUSH
61258: CALL_OW 250
61262: PPUSH
61263: LD_VAR 0 17
61267: PUSH
61268: LD_INT 1
61270: ARRAY
61271: PPUSH
61272: CALL_OW 254
61276: PPUSH
61277: LD_INT 5
61279: PPUSH
61280: CALL_OW 272
61284: PUSH
61285: LD_VAR 0 17
61289: PUSH
61290: LD_INT 1
61292: ARRAY
61293: PPUSH
61294: CALL_OW 251
61298: PPUSH
61299: LD_VAR 0 17
61303: PUSH
61304: LD_INT 1
61306: ARRAY
61307: PPUSH
61308: CALL_OW 254
61312: PPUSH
61313: LD_INT 5
61315: PPUSH
61316: CALL_OW 273
61320: PUSH
61321: EMPTY
61322: LIST
61323: LIST
61324: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
61325: LD_VAR 0 16
61329: PUSH
61330: LD_INT 1
61332: ARRAY
61333: PPUSH
61334: LD_VAR 0 16
61338: PUSH
61339: LD_INT 2
61341: ARRAY
61342: PPUSH
61343: CALL_OW 488
61347: IFFALSE 61378
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
61349: LD_VAR 0 13
61353: PPUSH
61354: LD_VAR 0 16
61358: PUSH
61359: LD_INT 1
61361: ARRAY
61362: PPUSH
61363: LD_VAR 0 16
61367: PUSH
61368: LD_INT 2
61370: ARRAY
61371: PPUSH
61372: CALL_OW 111
// continue ;
61376: GO 60868
// end ; end ; r := GetDir ( tmp ) ;
61378: LD_ADDR_VAR 0 15
61382: PUSH
61383: LD_VAR 0 13
61387: PPUSH
61388: CALL_OW 254
61392: ST_TO_ADDR
// if r = 5 then
61393: LD_VAR 0 15
61397: PUSH
61398: LD_INT 5
61400: EQUAL
61401: IFFALSE 61411
// r := 0 ;
61403: LD_ADDR_VAR 0 15
61407: PUSH
61408: LD_INT 0
61410: ST_TO_ADDR
// for j = r to 5 do
61411: LD_ADDR_VAR 0 10
61415: PUSH
61416: DOUBLE
61417: LD_VAR 0 15
61421: DEC
61422: ST_TO_ADDR
61423: LD_INT 5
61425: PUSH
61426: FOR_TO
61427: IFFALSE 61541
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
61429: LD_ADDR_VAR 0 11
61433: PUSH
61434: LD_VAR 0 13
61438: PPUSH
61439: CALL_OW 250
61443: PPUSH
61444: LD_VAR 0 10
61448: PPUSH
61449: LD_INT 2
61451: PPUSH
61452: CALL_OW 272
61456: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
61457: LD_ADDR_VAR 0 12
61461: PUSH
61462: LD_VAR 0 13
61466: PPUSH
61467: CALL_OW 251
61471: PPUSH
61472: LD_VAR 0 10
61476: PPUSH
61477: LD_INT 2
61479: PPUSH
61480: CALL_OW 273
61484: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
61485: LD_VAR 0 11
61489: PPUSH
61490: LD_VAR 0 12
61494: PPUSH
61495: CALL_OW 488
61499: PUSH
61500: LD_VAR 0 11
61504: PPUSH
61505: LD_VAR 0 12
61509: PPUSH
61510: CALL_OW 428
61514: NOT
61515: AND
61516: IFFALSE 61539
// begin ComMoveXY ( tmp , _x , _y ) ;
61518: LD_VAR 0 13
61522: PPUSH
61523: LD_VAR 0 11
61527: PPUSH
61528: LD_VAR 0 12
61532: PPUSH
61533: CALL_OW 111
// break ;
61537: GO 61541
// end ; end ;
61539: GO 61426
61541: POP
61542: POP
// end ; end ;
61543: GO 60868
61545: POP
61546: POP
// end ;
61547: LD_VAR 0 8
61551: RET
// export function BuildingTechInvented ( side , btype ) ; begin
61552: LD_INT 0
61554: PPUSH
// result := true ;
61555: LD_ADDR_VAR 0 3
61559: PUSH
61560: LD_INT 1
61562: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
61563: LD_VAR 0 2
61567: PUSH
61568: LD_INT 24
61570: DOUBLE
61571: EQUAL
61572: IFTRUE 61582
61574: LD_INT 33
61576: DOUBLE
61577: EQUAL
61578: IFTRUE 61582
61580: GO 61607
61582: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
61583: LD_ADDR_VAR 0 3
61587: PUSH
61588: LD_INT 32
61590: PPUSH
61591: LD_VAR 0 1
61595: PPUSH
61596: CALL_OW 321
61600: PUSH
61601: LD_INT 2
61603: EQUAL
61604: ST_TO_ADDR
61605: GO 61923
61607: LD_INT 20
61609: DOUBLE
61610: EQUAL
61611: IFTRUE 61615
61613: GO 61640
61615: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
61616: LD_ADDR_VAR 0 3
61620: PUSH
61621: LD_INT 6
61623: PPUSH
61624: LD_VAR 0 1
61628: PPUSH
61629: CALL_OW 321
61633: PUSH
61634: LD_INT 2
61636: EQUAL
61637: ST_TO_ADDR
61638: GO 61923
61640: LD_INT 22
61642: DOUBLE
61643: EQUAL
61644: IFTRUE 61654
61646: LD_INT 36
61648: DOUBLE
61649: EQUAL
61650: IFTRUE 61654
61652: GO 61679
61654: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
61655: LD_ADDR_VAR 0 3
61659: PUSH
61660: LD_INT 15
61662: PPUSH
61663: LD_VAR 0 1
61667: PPUSH
61668: CALL_OW 321
61672: PUSH
61673: LD_INT 2
61675: EQUAL
61676: ST_TO_ADDR
61677: GO 61923
61679: LD_INT 30
61681: DOUBLE
61682: EQUAL
61683: IFTRUE 61687
61685: GO 61712
61687: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
61688: LD_ADDR_VAR 0 3
61692: PUSH
61693: LD_INT 20
61695: PPUSH
61696: LD_VAR 0 1
61700: PPUSH
61701: CALL_OW 321
61705: PUSH
61706: LD_INT 2
61708: EQUAL
61709: ST_TO_ADDR
61710: GO 61923
61712: LD_INT 28
61714: DOUBLE
61715: EQUAL
61716: IFTRUE 61726
61718: LD_INT 21
61720: DOUBLE
61721: EQUAL
61722: IFTRUE 61726
61724: GO 61751
61726: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
61727: LD_ADDR_VAR 0 3
61731: PUSH
61732: LD_INT 21
61734: PPUSH
61735: LD_VAR 0 1
61739: PPUSH
61740: CALL_OW 321
61744: PUSH
61745: LD_INT 2
61747: EQUAL
61748: ST_TO_ADDR
61749: GO 61923
61751: LD_INT 16
61753: DOUBLE
61754: EQUAL
61755: IFTRUE 61759
61757: GO 61784
61759: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
61760: LD_ADDR_VAR 0 3
61764: PUSH
61765: LD_INT 84
61767: PPUSH
61768: LD_VAR 0 1
61772: PPUSH
61773: CALL_OW 321
61777: PUSH
61778: LD_INT 2
61780: EQUAL
61781: ST_TO_ADDR
61782: GO 61923
61784: LD_INT 19
61786: DOUBLE
61787: EQUAL
61788: IFTRUE 61798
61790: LD_INT 23
61792: DOUBLE
61793: EQUAL
61794: IFTRUE 61798
61796: GO 61823
61798: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
61799: LD_ADDR_VAR 0 3
61803: PUSH
61804: LD_INT 83
61806: PPUSH
61807: LD_VAR 0 1
61811: PPUSH
61812: CALL_OW 321
61816: PUSH
61817: LD_INT 2
61819: EQUAL
61820: ST_TO_ADDR
61821: GO 61923
61823: LD_INT 17
61825: DOUBLE
61826: EQUAL
61827: IFTRUE 61831
61829: GO 61856
61831: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
61832: LD_ADDR_VAR 0 3
61836: PUSH
61837: LD_INT 39
61839: PPUSH
61840: LD_VAR 0 1
61844: PPUSH
61845: CALL_OW 321
61849: PUSH
61850: LD_INT 2
61852: EQUAL
61853: ST_TO_ADDR
61854: GO 61923
61856: LD_INT 18
61858: DOUBLE
61859: EQUAL
61860: IFTRUE 61864
61862: GO 61889
61864: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
61865: LD_ADDR_VAR 0 3
61869: PUSH
61870: LD_INT 40
61872: PPUSH
61873: LD_VAR 0 1
61877: PPUSH
61878: CALL_OW 321
61882: PUSH
61883: LD_INT 2
61885: EQUAL
61886: ST_TO_ADDR
61887: GO 61923
61889: LD_INT 27
61891: DOUBLE
61892: EQUAL
61893: IFTRUE 61897
61895: GO 61922
61897: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
61898: LD_ADDR_VAR 0 3
61902: PUSH
61903: LD_INT 35
61905: PPUSH
61906: LD_VAR 0 1
61910: PPUSH
61911: CALL_OW 321
61915: PUSH
61916: LD_INT 2
61918: EQUAL
61919: ST_TO_ADDR
61920: GO 61923
61922: POP
// end ;
61923: LD_VAR 0 3
61927: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
61928: LD_INT 0
61930: PPUSH
61931: PPUSH
61932: PPUSH
61933: PPUSH
61934: PPUSH
61935: PPUSH
61936: PPUSH
61937: PPUSH
61938: PPUSH
61939: PPUSH
61940: PPUSH
// result := false ;
61941: LD_ADDR_VAR 0 6
61945: PUSH
61946: LD_INT 0
61948: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
61949: LD_VAR 0 1
61953: NOT
61954: PUSH
61955: LD_VAR 0 1
61959: PPUSH
61960: CALL_OW 266
61964: PUSH
61965: LD_INT 0
61967: PUSH
61968: LD_INT 1
61970: PUSH
61971: EMPTY
61972: LIST
61973: LIST
61974: IN
61975: NOT
61976: OR
61977: PUSH
61978: LD_VAR 0 2
61982: NOT
61983: OR
61984: PUSH
61985: LD_VAR 0 5
61989: PUSH
61990: LD_INT 0
61992: PUSH
61993: LD_INT 1
61995: PUSH
61996: LD_INT 2
61998: PUSH
61999: LD_INT 3
62001: PUSH
62002: LD_INT 4
62004: PUSH
62005: LD_INT 5
62007: PUSH
62008: EMPTY
62009: LIST
62010: LIST
62011: LIST
62012: LIST
62013: LIST
62014: LIST
62015: IN
62016: NOT
62017: OR
62018: PUSH
62019: LD_VAR 0 3
62023: PPUSH
62024: LD_VAR 0 4
62028: PPUSH
62029: CALL_OW 488
62033: NOT
62034: OR
62035: IFFALSE 62039
// exit ;
62037: GO 62775
// side := GetSide ( depot ) ;
62039: LD_ADDR_VAR 0 9
62043: PUSH
62044: LD_VAR 0 1
62048: PPUSH
62049: CALL_OW 255
62053: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
62054: LD_VAR 0 9
62058: PPUSH
62059: LD_VAR 0 2
62063: PPUSH
62064: CALL 61552 0 2
62068: NOT
62069: IFFALSE 62073
// exit ;
62071: GO 62775
// pom := GetBase ( depot ) ;
62073: LD_ADDR_VAR 0 10
62077: PUSH
62078: LD_VAR 0 1
62082: PPUSH
62083: CALL_OW 274
62087: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
62088: LD_ADDR_VAR 0 11
62092: PUSH
62093: LD_VAR 0 2
62097: PPUSH
62098: LD_VAR 0 1
62102: PPUSH
62103: CALL_OW 248
62107: PPUSH
62108: CALL_OW 450
62112: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
62113: LD_VAR 0 10
62117: PPUSH
62118: LD_INT 1
62120: PPUSH
62121: CALL_OW 275
62125: PUSH
62126: LD_VAR 0 11
62130: PUSH
62131: LD_INT 1
62133: ARRAY
62134: GREATEREQUAL
62135: PUSH
62136: LD_VAR 0 10
62140: PPUSH
62141: LD_INT 2
62143: PPUSH
62144: CALL_OW 275
62148: PUSH
62149: LD_VAR 0 11
62153: PUSH
62154: LD_INT 2
62156: ARRAY
62157: GREATEREQUAL
62158: AND
62159: PUSH
62160: LD_VAR 0 10
62164: PPUSH
62165: LD_INT 3
62167: PPUSH
62168: CALL_OW 275
62172: PUSH
62173: LD_VAR 0 11
62177: PUSH
62178: LD_INT 3
62180: ARRAY
62181: GREATEREQUAL
62182: AND
62183: NOT
62184: IFFALSE 62188
// exit ;
62186: GO 62775
// if GetBType ( depot ) = b_depot then
62188: LD_VAR 0 1
62192: PPUSH
62193: CALL_OW 266
62197: PUSH
62198: LD_INT 0
62200: EQUAL
62201: IFFALSE 62213
// dist := 28 else
62203: LD_ADDR_VAR 0 14
62207: PUSH
62208: LD_INT 28
62210: ST_TO_ADDR
62211: GO 62221
// dist := 36 ;
62213: LD_ADDR_VAR 0 14
62217: PUSH
62218: LD_INT 36
62220: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
62221: LD_VAR 0 1
62225: PPUSH
62226: LD_VAR 0 3
62230: PPUSH
62231: LD_VAR 0 4
62235: PPUSH
62236: CALL_OW 297
62240: PUSH
62241: LD_VAR 0 14
62245: GREATER
62246: IFFALSE 62250
// exit ;
62248: GO 62775
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
62250: LD_ADDR_VAR 0 12
62254: PUSH
62255: LD_VAR 0 2
62259: PPUSH
62260: LD_VAR 0 3
62264: PPUSH
62265: LD_VAR 0 4
62269: PPUSH
62270: LD_VAR 0 5
62274: PPUSH
62275: LD_VAR 0 1
62279: PPUSH
62280: CALL_OW 248
62284: PPUSH
62285: LD_INT 0
62287: PPUSH
62288: CALL 62780 0 6
62292: ST_TO_ADDR
// if not hexes then
62293: LD_VAR 0 12
62297: NOT
62298: IFFALSE 62302
// exit ;
62300: GO 62775
// hex := GetHexInfo ( x , y ) ;
62302: LD_ADDR_VAR 0 15
62306: PUSH
62307: LD_VAR 0 3
62311: PPUSH
62312: LD_VAR 0 4
62316: PPUSH
62317: CALL_OW 546
62321: ST_TO_ADDR
// if hex [ 1 ] then
62322: LD_VAR 0 15
62326: PUSH
62327: LD_INT 1
62329: ARRAY
62330: IFFALSE 62334
// exit ;
62332: GO 62775
// height := hex [ 2 ] ;
62334: LD_ADDR_VAR 0 13
62338: PUSH
62339: LD_VAR 0 15
62343: PUSH
62344: LD_INT 2
62346: ARRAY
62347: ST_TO_ADDR
// for i = 1 to hexes do
62348: LD_ADDR_VAR 0 7
62352: PUSH
62353: DOUBLE
62354: LD_INT 1
62356: DEC
62357: ST_TO_ADDR
62358: LD_VAR 0 12
62362: PUSH
62363: FOR_TO
62364: IFFALSE 62694
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
62366: LD_VAR 0 12
62370: PUSH
62371: LD_VAR 0 7
62375: ARRAY
62376: PUSH
62377: LD_INT 1
62379: ARRAY
62380: PPUSH
62381: LD_VAR 0 12
62385: PUSH
62386: LD_VAR 0 7
62390: ARRAY
62391: PUSH
62392: LD_INT 2
62394: ARRAY
62395: PPUSH
62396: CALL_OW 488
62400: NOT
62401: PUSH
62402: LD_VAR 0 12
62406: PUSH
62407: LD_VAR 0 7
62411: ARRAY
62412: PUSH
62413: LD_INT 1
62415: ARRAY
62416: PPUSH
62417: LD_VAR 0 12
62421: PUSH
62422: LD_VAR 0 7
62426: ARRAY
62427: PUSH
62428: LD_INT 2
62430: ARRAY
62431: PPUSH
62432: CALL_OW 428
62436: PUSH
62437: LD_INT 0
62439: GREATER
62440: OR
62441: PUSH
62442: LD_VAR 0 12
62446: PUSH
62447: LD_VAR 0 7
62451: ARRAY
62452: PUSH
62453: LD_INT 1
62455: ARRAY
62456: PPUSH
62457: LD_VAR 0 12
62461: PUSH
62462: LD_VAR 0 7
62466: ARRAY
62467: PUSH
62468: LD_INT 2
62470: ARRAY
62471: PPUSH
62472: CALL_OW 351
62476: OR
62477: IFFALSE 62483
// exit ;
62479: POP
62480: POP
62481: GO 62775
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
62483: LD_ADDR_VAR 0 8
62487: PUSH
62488: LD_VAR 0 12
62492: PUSH
62493: LD_VAR 0 7
62497: ARRAY
62498: PUSH
62499: LD_INT 1
62501: ARRAY
62502: PPUSH
62503: LD_VAR 0 12
62507: PUSH
62508: LD_VAR 0 7
62512: ARRAY
62513: PUSH
62514: LD_INT 2
62516: ARRAY
62517: PPUSH
62518: CALL_OW 546
62522: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
62523: LD_VAR 0 8
62527: PUSH
62528: LD_INT 1
62530: ARRAY
62531: PUSH
62532: LD_VAR 0 8
62536: PUSH
62537: LD_INT 2
62539: ARRAY
62540: PUSH
62541: LD_VAR 0 13
62545: PUSH
62546: LD_INT 2
62548: PLUS
62549: GREATER
62550: OR
62551: PUSH
62552: LD_VAR 0 8
62556: PUSH
62557: LD_INT 2
62559: ARRAY
62560: PUSH
62561: LD_VAR 0 13
62565: PUSH
62566: LD_INT 2
62568: MINUS
62569: LESS
62570: OR
62571: PUSH
62572: LD_VAR 0 8
62576: PUSH
62577: LD_INT 3
62579: ARRAY
62580: PUSH
62581: LD_INT 0
62583: PUSH
62584: LD_INT 8
62586: PUSH
62587: LD_INT 9
62589: PUSH
62590: LD_INT 10
62592: PUSH
62593: LD_INT 11
62595: PUSH
62596: LD_INT 12
62598: PUSH
62599: LD_INT 13
62601: PUSH
62602: LD_INT 16
62604: PUSH
62605: LD_INT 17
62607: PUSH
62608: LD_INT 18
62610: PUSH
62611: LD_INT 19
62613: PUSH
62614: LD_INT 20
62616: PUSH
62617: LD_INT 21
62619: PUSH
62620: EMPTY
62621: LIST
62622: LIST
62623: LIST
62624: LIST
62625: LIST
62626: LIST
62627: LIST
62628: LIST
62629: LIST
62630: LIST
62631: LIST
62632: LIST
62633: LIST
62634: IN
62635: NOT
62636: OR
62637: PUSH
62638: LD_VAR 0 8
62642: PUSH
62643: LD_INT 5
62645: ARRAY
62646: NOT
62647: OR
62648: PUSH
62649: LD_VAR 0 8
62653: PUSH
62654: LD_INT 6
62656: ARRAY
62657: PUSH
62658: LD_INT 1
62660: PUSH
62661: LD_INT 2
62663: PUSH
62664: LD_INT 7
62666: PUSH
62667: LD_INT 9
62669: PUSH
62670: LD_INT 10
62672: PUSH
62673: LD_INT 11
62675: PUSH
62676: EMPTY
62677: LIST
62678: LIST
62679: LIST
62680: LIST
62681: LIST
62682: LIST
62683: IN
62684: NOT
62685: OR
62686: IFFALSE 62692
// exit ;
62688: POP
62689: POP
62690: GO 62775
// end ;
62692: GO 62363
62694: POP
62695: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
62696: LD_VAR 0 9
62700: PPUSH
62701: LD_VAR 0 3
62705: PPUSH
62706: LD_VAR 0 4
62710: PPUSH
62711: LD_INT 20
62713: PPUSH
62714: CALL 54727 0 4
62718: PUSH
62719: LD_INT 4
62721: ARRAY
62722: IFFALSE 62726
// exit ;
62724: GO 62775
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
62726: LD_VAR 0 2
62730: PUSH
62731: LD_INT 29
62733: PUSH
62734: LD_INT 30
62736: PUSH
62737: EMPTY
62738: LIST
62739: LIST
62740: IN
62741: PUSH
62742: LD_VAR 0 3
62746: PPUSH
62747: LD_VAR 0 4
62751: PPUSH
62752: LD_VAR 0 9
62756: PPUSH
62757: CALL_OW 440
62761: NOT
62762: AND
62763: IFFALSE 62767
// exit ;
62765: GO 62775
// result := true ;
62767: LD_ADDR_VAR 0 6
62771: PUSH
62772: LD_INT 1
62774: ST_TO_ADDR
// end ;
62775: LD_VAR 0 6
62779: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
62780: LD_INT 0
62782: PPUSH
62783: PPUSH
62784: PPUSH
62785: PPUSH
62786: PPUSH
62787: PPUSH
62788: PPUSH
62789: PPUSH
62790: PPUSH
62791: PPUSH
62792: PPUSH
62793: PPUSH
62794: PPUSH
62795: PPUSH
62796: PPUSH
62797: PPUSH
62798: PPUSH
62799: PPUSH
62800: PPUSH
62801: PPUSH
62802: PPUSH
62803: PPUSH
62804: PPUSH
62805: PPUSH
62806: PPUSH
62807: PPUSH
62808: PPUSH
62809: PPUSH
62810: PPUSH
62811: PPUSH
62812: PPUSH
62813: PPUSH
62814: PPUSH
62815: PPUSH
62816: PPUSH
62817: PPUSH
62818: PPUSH
62819: PPUSH
62820: PPUSH
62821: PPUSH
62822: PPUSH
62823: PPUSH
62824: PPUSH
62825: PPUSH
62826: PPUSH
62827: PPUSH
62828: PPUSH
62829: PPUSH
62830: PPUSH
62831: PPUSH
62832: PPUSH
62833: PPUSH
62834: PPUSH
62835: PPUSH
62836: PPUSH
62837: PPUSH
62838: PPUSH
62839: PPUSH
// result = [ ] ;
62840: LD_ADDR_VAR 0 7
62844: PUSH
62845: EMPTY
62846: ST_TO_ADDR
// temp_list = [ ] ;
62847: LD_ADDR_VAR 0 9
62851: PUSH
62852: EMPTY
62853: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
62854: LD_VAR 0 4
62858: PUSH
62859: LD_INT 0
62861: PUSH
62862: LD_INT 1
62864: PUSH
62865: LD_INT 2
62867: PUSH
62868: LD_INT 3
62870: PUSH
62871: LD_INT 4
62873: PUSH
62874: LD_INT 5
62876: PUSH
62877: EMPTY
62878: LIST
62879: LIST
62880: LIST
62881: LIST
62882: LIST
62883: LIST
62884: IN
62885: NOT
62886: PUSH
62887: LD_VAR 0 1
62891: PUSH
62892: LD_INT 0
62894: PUSH
62895: LD_INT 1
62897: PUSH
62898: EMPTY
62899: LIST
62900: LIST
62901: IN
62902: PUSH
62903: LD_VAR 0 5
62907: PUSH
62908: LD_INT 1
62910: PUSH
62911: LD_INT 2
62913: PUSH
62914: LD_INT 3
62916: PUSH
62917: EMPTY
62918: LIST
62919: LIST
62920: LIST
62921: IN
62922: NOT
62923: AND
62924: OR
62925: IFFALSE 62929
// exit ;
62927: GO 81320
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
62929: LD_VAR 0 1
62933: PUSH
62934: LD_INT 6
62936: PUSH
62937: LD_INT 7
62939: PUSH
62940: LD_INT 8
62942: PUSH
62943: LD_INT 13
62945: PUSH
62946: LD_INT 12
62948: PUSH
62949: LD_INT 15
62951: PUSH
62952: LD_INT 11
62954: PUSH
62955: LD_INT 14
62957: PUSH
62958: LD_INT 10
62960: PUSH
62961: EMPTY
62962: LIST
62963: LIST
62964: LIST
62965: LIST
62966: LIST
62967: LIST
62968: LIST
62969: LIST
62970: LIST
62971: IN
62972: IFFALSE 62982
// btype = b_lab ;
62974: LD_ADDR_VAR 0 1
62978: PUSH
62979: LD_INT 6
62981: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
62982: LD_VAR 0 6
62986: PUSH
62987: LD_INT 0
62989: PUSH
62990: LD_INT 1
62992: PUSH
62993: LD_INT 2
62995: PUSH
62996: EMPTY
62997: LIST
62998: LIST
62999: LIST
63000: IN
63001: NOT
63002: PUSH
63003: LD_VAR 0 1
63007: PUSH
63008: LD_INT 0
63010: PUSH
63011: LD_INT 1
63013: PUSH
63014: LD_INT 2
63016: PUSH
63017: LD_INT 3
63019: PUSH
63020: LD_INT 6
63022: PUSH
63023: LD_INT 36
63025: PUSH
63026: LD_INT 4
63028: PUSH
63029: LD_INT 5
63031: PUSH
63032: LD_INT 31
63034: PUSH
63035: LD_INT 32
63037: PUSH
63038: LD_INT 33
63040: PUSH
63041: EMPTY
63042: LIST
63043: LIST
63044: LIST
63045: LIST
63046: LIST
63047: LIST
63048: LIST
63049: LIST
63050: LIST
63051: LIST
63052: LIST
63053: IN
63054: NOT
63055: PUSH
63056: LD_VAR 0 6
63060: PUSH
63061: LD_INT 1
63063: EQUAL
63064: AND
63065: OR
63066: PUSH
63067: LD_VAR 0 1
63071: PUSH
63072: LD_INT 2
63074: PUSH
63075: LD_INT 3
63077: PUSH
63078: EMPTY
63079: LIST
63080: LIST
63081: IN
63082: NOT
63083: PUSH
63084: LD_VAR 0 6
63088: PUSH
63089: LD_INT 2
63091: EQUAL
63092: AND
63093: OR
63094: IFFALSE 63104
// mode = 0 ;
63096: LD_ADDR_VAR 0 6
63100: PUSH
63101: LD_INT 0
63103: ST_TO_ADDR
// case mode of 0 :
63104: LD_VAR 0 6
63108: PUSH
63109: LD_INT 0
63111: DOUBLE
63112: EQUAL
63113: IFTRUE 63117
63115: GO 74570
63117: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
63118: LD_ADDR_VAR 0 11
63122: PUSH
63123: LD_INT 0
63125: PUSH
63126: LD_INT 0
63128: PUSH
63129: EMPTY
63130: LIST
63131: LIST
63132: PUSH
63133: LD_INT 0
63135: PUSH
63136: LD_INT 1
63138: NEG
63139: PUSH
63140: EMPTY
63141: LIST
63142: LIST
63143: PUSH
63144: LD_INT 1
63146: PUSH
63147: LD_INT 0
63149: PUSH
63150: EMPTY
63151: LIST
63152: LIST
63153: PUSH
63154: LD_INT 1
63156: PUSH
63157: LD_INT 1
63159: PUSH
63160: EMPTY
63161: LIST
63162: LIST
63163: PUSH
63164: LD_INT 0
63166: PUSH
63167: LD_INT 1
63169: PUSH
63170: EMPTY
63171: LIST
63172: LIST
63173: PUSH
63174: LD_INT 1
63176: NEG
63177: PUSH
63178: LD_INT 0
63180: PUSH
63181: EMPTY
63182: LIST
63183: LIST
63184: PUSH
63185: LD_INT 1
63187: NEG
63188: PUSH
63189: LD_INT 1
63191: NEG
63192: PUSH
63193: EMPTY
63194: LIST
63195: LIST
63196: PUSH
63197: LD_INT 1
63199: NEG
63200: PUSH
63201: LD_INT 2
63203: NEG
63204: PUSH
63205: EMPTY
63206: LIST
63207: LIST
63208: PUSH
63209: LD_INT 0
63211: PUSH
63212: LD_INT 2
63214: NEG
63215: PUSH
63216: EMPTY
63217: LIST
63218: LIST
63219: PUSH
63220: LD_INT 1
63222: PUSH
63223: LD_INT 1
63225: NEG
63226: PUSH
63227: EMPTY
63228: LIST
63229: LIST
63230: PUSH
63231: LD_INT 1
63233: PUSH
63234: LD_INT 2
63236: PUSH
63237: EMPTY
63238: LIST
63239: LIST
63240: PUSH
63241: LD_INT 0
63243: PUSH
63244: LD_INT 2
63246: PUSH
63247: EMPTY
63248: LIST
63249: LIST
63250: PUSH
63251: LD_INT 1
63253: NEG
63254: PUSH
63255: LD_INT 1
63257: PUSH
63258: EMPTY
63259: LIST
63260: LIST
63261: PUSH
63262: LD_INT 1
63264: PUSH
63265: LD_INT 3
63267: PUSH
63268: EMPTY
63269: LIST
63270: LIST
63271: PUSH
63272: LD_INT 0
63274: PUSH
63275: LD_INT 3
63277: PUSH
63278: EMPTY
63279: LIST
63280: LIST
63281: PUSH
63282: LD_INT 1
63284: NEG
63285: PUSH
63286: LD_INT 2
63288: PUSH
63289: EMPTY
63290: LIST
63291: LIST
63292: PUSH
63293: EMPTY
63294: LIST
63295: LIST
63296: LIST
63297: LIST
63298: LIST
63299: LIST
63300: LIST
63301: LIST
63302: LIST
63303: LIST
63304: LIST
63305: LIST
63306: LIST
63307: LIST
63308: LIST
63309: LIST
63310: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
63311: LD_ADDR_VAR 0 12
63315: PUSH
63316: LD_INT 0
63318: PUSH
63319: LD_INT 0
63321: PUSH
63322: EMPTY
63323: LIST
63324: LIST
63325: PUSH
63326: LD_INT 0
63328: PUSH
63329: LD_INT 1
63331: NEG
63332: PUSH
63333: EMPTY
63334: LIST
63335: LIST
63336: PUSH
63337: LD_INT 1
63339: PUSH
63340: LD_INT 0
63342: PUSH
63343: EMPTY
63344: LIST
63345: LIST
63346: PUSH
63347: LD_INT 1
63349: PUSH
63350: LD_INT 1
63352: PUSH
63353: EMPTY
63354: LIST
63355: LIST
63356: PUSH
63357: LD_INT 0
63359: PUSH
63360: LD_INT 1
63362: PUSH
63363: EMPTY
63364: LIST
63365: LIST
63366: PUSH
63367: LD_INT 1
63369: NEG
63370: PUSH
63371: LD_INT 0
63373: PUSH
63374: EMPTY
63375: LIST
63376: LIST
63377: PUSH
63378: LD_INT 1
63380: NEG
63381: PUSH
63382: LD_INT 1
63384: NEG
63385: PUSH
63386: EMPTY
63387: LIST
63388: LIST
63389: PUSH
63390: LD_INT 1
63392: PUSH
63393: LD_INT 1
63395: NEG
63396: PUSH
63397: EMPTY
63398: LIST
63399: LIST
63400: PUSH
63401: LD_INT 2
63403: PUSH
63404: LD_INT 0
63406: PUSH
63407: EMPTY
63408: LIST
63409: LIST
63410: PUSH
63411: LD_INT 2
63413: PUSH
63414: LD_INT 1
63416: PUSH
63417: EMPTY
63418: LIST
63419: LIST
63420: PUSH
63421: LD_INT 1
63423: NEG
63424: PUSH
63425: LD_INT 1
63427: PUSH
63428: EMPTY
63429: LIST
63430: LIST
63431: PUSH
63432: LD_INT 2
63434: NEG
63435: PUSH
63436: LD_INT 0
63438: PUSH
63439: EMPTY
63440: LIST
63441: LIST
63442: PUSH
63443: LD_INT 2
63445: NEG
63446: PUSH
63447: LD_INT 1
63449: NEG
63450: PUSH
63451: EMPTY
63452: LIST
63453: LIST
63454: PUSH
63455: LD_INT 2
63457: NEG
63458: PUSH
63459: LD_INT 1
63461: PUSH
63462: EMPTY
63463: LIST
63464: LIST
63465: PUSH
63466: LD_INT 3
63468: NEG
63469: PUSH
63470: LD_INT 0
63472: PUSH
63473: EMPTY
63474: LIST
63475: LIST
63476: PUSH
63477: LD_INT 3
63479: NEG
63480: PUSH
63481: LD_INT 1
63483: NEG
63484: PUSH
63485: EMPTY
63486: LIST
63487: LIST
63488: PUSH
63489: EMPTY
63490: LIST
63491: LIST
63492: LIST
63493: LIST
63494: LIST
63495: LIST
63496: LIST
63497: LIST
63498: LIST
63499: LIST
63500: LIST
63501: LIST
63502: LIST
63503: LIST
63504: LIST
63505: LIST
63506: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
63507: LD_ADDR_VAR 0 13
63511: PUSH
63512: LD_INT 0
63514: PUSH
63515: LD_INT 0
63517: PUSH
63518: EMPTY
63519: LIST
63520: LIST
63521: PUSH
63522: LD_INT 0
63524: PUSH
63525: LD_INT 1
63527: NEG
63528: PUSH
63529: EMPTY
63530: LIST
63531: LIST
63532: PUSH
63533: LD_INT 1
63535: PUSH
63536: LD_INT 0
63538: PUSH
63539: EMPTY
63540: LIST
63541: LIST
63542: PUSH
63543: LD_INT 1
63545: PUSH
63546: LD_INT 1
63548: PUSH
63549: EMPTY
63550: LIST
63551: LIST
63552: PUSH
63553: LD_INT 0
63555: PUSH
63556: LD_INT 1
63558: PUSH
63559: EMPTY
63560: LIST
63561: LIST
63562: PUSH
63563: LD_INT 1
63565: NEG
63566: PUSH
63567: LD_INT 0
63569: PUSH
63570: EMPTY
63571: LIST
63572: LIST
63573: PUSH
63574: LD_INT 1
63576: NEG
63577: PUSH
63578: LD_INT 1
63580: NEG
63581: PUSH
63582: EMPTY
63583: LIST
63584: LIST
63585: PUSH
63586: LD_INT 1
63588: NEG
63589: PUSH
63590: LD_INT 2
63592: NEG
63593: PUSH
63594: EMPTY
63595: LIST
63596: LIST
63597: PUSH
63598: LD_INT 2
63600: PUSH
63601: LD_INT 1
63603: PUSH
63604: EMPTY
63605: LIST
63606: LIST
63607: PUSH
63608: LD_INT 2
63610: PUSH
63611: LD_INT 2
63613: PUSH
63614: EMPTY
63615: LIST
63616: LIST
63617: PUSH
63618: LD_INT 1
63620: PUSH
63621: LD_INT 2
63623: PUSH
63624: EMPTY
63625: LIST
63626: LIST
63627: PUSH
63628: LD_INT 2
63630: NEG
63631: PUSH
63632: LD_INT 1
63634: NEG
63635: PUSH
63636: EMPTY
63637: LIST
63638: LIST
63639: PUSH
63640: LD_INT 2
63642: NEG
63643: PUSH
63644: LD_INT 2
63646: NEG
63647: PUSH
63648: EMPTY
63649: LIST
63650: LIST
63651: PUSH
63652: LD_INT 2
63654: NEG
63655: PUSH
63656: LD_INT 3
63658: NEG
63659: PUSH
63660: EMPTY
63661: LIST
63662: LIST
63663: PUSH
63664: LD_INT 3
63666: NEG
63667: PUSH
63668: LD_INT 2
63670: NEG
63671: PUSH
63672: EMPTY
63673: LIST
63674: LIST
63675: PUSH
63676: LD_INT 3
63678: NEG
63679: PUSH
63680: LD_INT 3
63682: NEG
63683: PUSH
63684: EMPTY
63685: LIST
63686: LIST
63687: PUSH
63688: EMPTY
63689: LIST
63690: LIST
63691: LIST
63692: LIST
63693: LIST
63694: LIST
63695: LIST
63696: LIST
63697: LIST
63698: LIST
63699: LIST
63700: LIST
63701: LIST
63702: LIST
63703: LIST
63704: LIST
63705: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
63706: LD_ADDR_VAR 0 14
63710: PUSH
63711: LD_INT 0
63713: PUSH
63714: LD_INT 0
63716: PUSH
63717: EMPTY
63718: LIST
63719: LIST
63720: PUSH
63721: LD_INT 0
63723: PUSH
63724: LD_INT 1
63726: NEG
63727: PUSH
63728: EMPTY
63729: LIST
63730: LIST
63731: PUSH
63732: LD_INT 1
63734: PUSH
63735: LD_INT 0
63737: PUSH
63738: EMPTY
63739: LIST
63740: LIST
63741: PUSH
63742: LD_INT 1
63744: PUSH
63745: LD_INT 1
63747: PUSH
63748: EMPTY
63749: LIST
63750: LIST
63751: PUSH
63752: LD_INT 0
63754: PUSH
63755: LD_INT 1
63757: PUSH
63758: EMPTY
63759: LIST
63760: LIST
63761: PUSH
63762: LD_INT 1
63764: NEG
63765: PUSH
63766: LD_INT 0
63768: PUSH
63769: EMPTY
63770: LIST
63771: LIST
63772: PUSH
63773: LD_INT 1
63775: NEG
63776: PUSH
63777: LD_INT 1
63779: NEG
63780: PUSH
63781: EMPTY
63782: LIST
63783: LIST
63784: PUSH
63785: LD_INT 1
63787: NEG
63788: PUSH
63789: LD_INT 2
63791: NEG
63792: PUSH
63793: EMPTY
63794: LIST
63795: LIST
63796: PUSH
63797: LD_INT 0
63799: PUSH
63800: LD_INT 2
63802: NEG
63803: PUSH
63804: EMPTY
63805: LIST
63806: LIST
63807: PUSH
63808: LD_INT 1
63810: PUSH
63811: LD_INT 1
63813: NEG
63814: PUSH
63815: EMPTY
63816: LIST
63817: LIST
63818: PUSH
63819: LD_INT 1
63821: PUSH
63822: LD_INT 2
63824: PUSH
63825: EMPTY
63826: LIST
63827: LIST
63828: PUSH
63829: LD_INT 0
63831: PUSH
63832: LD_INT 2
63834: PUSH
63835: EMPTY
63836: LIST
63837: LIST
63838: PUSH
63839: LD_INT 1
63841: NEG
63842: PUSH
63843: LD_INT 1
63845: PUSH
63846: EMPTY
63847: LIST
63848: LIST
63849: PUSH
63850: LD_INT 1
63852: NEG
63853: PUSH
63854: LD_INT 3
63856: NEG
63857: PUSH
63858: EMPTY
63859: LIST
63860: LIST
63861: PUSH
63862: LD_INT 0
63864: PUSH
63865: LD_INT 3
63867: NEG
63868: PUSH
63869: EMPTY
63870: LIST
63871: LIST
63872: PUSH
63873: LD_INT 1
63875: PUSH
63876: LD_INT 2
63878: NEG
63879: PUSH
63880: EMPTY
63881: LIST
63882: LIST
63883: PUSH
63884: EMPTY
63885: LIST
63886: LIST
63887: LIST
63888: LIST
63889: LIST
63890: LIST
63891: LIST
63892: LIST
63893: LIST
63894: LIST
63895: LIST
63896: LIST
63897: LIST
63898: LIST
63899: LIST
63900: LIST
63901: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
63902: LD_ADDR_VAR 0 15
63906: PUSH
63907: LD_INT 0
63909: PUSH
63910: LD_INT 0
63912: PUSH
63913: EMPTY
63914: LIST
63915: LIST
63916: PUSH
63917: LD_INT 0
63919: PUSH
63920: LD_INT 1
63922: NEG
63923: PUSH
63924: EMPTY
63925: LIST
63926: LIST
63927: PUSH
63928: LD_INT 1
63930: PUSH
63931: LD_INT 0
63933: PUSH
63934: EMPTY
63935: LIST
63936: LIST
63937: PUSH
63938: LD_INT 1
63940: PUSH
63941: LD_INT 1
63943: PUSH
63944: EMPTY
63945: LIST
63946: LIST
63947: PUSH
63948: LD_INT 0
63950: PUSH
63951: LD_INT 1
63953: PUSH
63954: EMPTY
63955: LIST
63956: LIST
63957: PUSH
63958: LD_INT 1
63960: NEG
63961: PUSH
63962: LD_INT 0
63964: PUSH
63965: EMPTY
63966: LIST
63967: LIST
63968: PUSH
63969: LD_INT 1
63971: NEG
63972: PUSH
63973: LD_INT 1
63975: NEG
63976: PUSH
63977: EMPTY
63978: LIST
63979: LIST
63980: PUSH
63981: LD_INT 1
63983: PUSH
63984: LD_INT 1
63986: NEG
63987: PUSH
63988: EMPTY
63989: LIST
63990: LIST
63991: PUSH
63992: LD_INT 2
63994: PUSH
63995: LD_INT 0
63997: PUSH
63998: EMPTY
63999: LIST
64000: LIST
64001: PUSH
64002: LD_INT 2
64004: PUSH
64005: LD_INT 1
64007: PUSH
64008: EMPTY
64009: LIST
64010: LIST
64011: PUSH
64012: LD_INT 1
64014: NEG
64015: PUSH
64016: LD_INT 1
64018: PUSH
64019: EMPTY
64020: LIST
64021: LIST
64022: PUSH
64023: LD_INT 2
64025: NEG
64026: PUSH
64027: LD_INT 0
64029: PUSH
64030: EMPTY
64031: LIST
64032: LIST
64033: PUSH
64034: LD_INT 2
64036: NEG
64037: PUSH
64038: LD_INT 1
64040: NEG
64041: PUSH
64042: EMPTY
64043: LIST
64044: LIST
64045: PUSH
64046: LD_INT 2
64048: PUSH
64049: LD_INT 1
64051: NEG
64052: PUSH
64053: EMPTY
64054: LIST
64055: LIST
64056: PUSH
64057: LD_INT 3
64059: PUSH
64060: LD_INT 0
64062: PUSH
64063: EMPTY
64064: LIST
64065: LIST
64066: PUSH
64067: LD_INT 3
64069: PUSH
64070: LD_INT 1
64072: PUSH
64073: EMPTY
64074: LIST
64075: LIST
64076: PUSH
64077: EMPTY
64078: LIST
64079: LIST
64080: LIST
64081: LIST
64082: LIST
64083: LIST
64084: LIST
64085: LIST
64086: LIST
64087: LIST
64088: LIST
64089: LIST
64090: LIST
64091: LIST
64092: LIST
64093: LIST
64094: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
64095: LD_ADDR_VAR 0 16
64099: PUSH
64100: LD_INT 0
64102: PUSH
64103: LD_INT 0
64105: PUSH
64106: EMPTY
64107: LIST
64108: LIST
64109: PUSH
64110: LD_INT 0
64112: PUSH
64113: LD_INT 1
64115: NEG
64116: PUSH
64117: EMPTY
64118: LIST
64119: LIST
64120: PUSH
64121: LD_INT 1
64123: PUSH
64124: LD_INT 0
64126: PUSH
64127: EMPTY
64128: LIST
64129: LIST
64130: PUSH
64131: LD_INT 1
64133: PUSH
64134: LD_INT 1
64136: PUSH
64137: EMPTY
64138: LIST
64139: LIST
64140: PUSH
64141: LD_INT 0
64143: PUSH
64144: LD_INT 1
64146: PUSH
64147: EMPTY
64148: LIST
64149: LIST
64150: PUSH
64151: LD_INT 1
64153: NEG
64154: PUSH
64155: LD_INT 0
64157: PUSH
64158: EMPTY
64159: LIST
64160: LIST
64161: PUSH
64162: LD_INT 1
64164: NEG
64165: PUSH
64166: LD_INT 1
64168: NEG
64169: PUSH
64170: EMPTY
64171: LIST
64172: LIST
64173: PUSH
64174: LD_INT 1
64176: NEG
64177: PUSH
64178: LD_INT 2
64180: NEG
64181: PUSH
64182: EMPTY
64183: LIST
64184: LIST
64185: PUSH
64186: LD_INT 2
64188: PUSH
64189: LD_INT 1
64191: PUSH
64192: EMPTY
64193: LIST
64194: LIST
64195: PUSH
64196: LD_INT 2
64198: PUSH
64199: LD_INT 2
64201: PUSH
64202: EMPTY
64203: LIST
64204: LIST
64205: PUSH
64206: LD_INT 1
64208: PUSH
64209: LD_INT 2
64211: PUSH
64212: EMPTY
64213: LIST
64214: LIST
64215: PUSH
64216: LD_INT 2
64218: NEG
64219: PUSH
64220: LD_INT 1
64222: NEG
64223: PUSH
64224: EMPTY
64225: LIST
64226: LIST
64227: PUSH
64228: LD_INT 2
64230: NEG
64231: PUSH
64232: LD_INT 2
64234: NEG
64235: PUSH
64236: EMPTY
64237: LIST
64238: LIST
64239: PUSH
64240: LD_INT 3
64242: PUSH
64243: LD_INT 2
64245: PUSH
64246: EMPTY
64247: LIST
64248: LIST
64249: PUSH
64250: LD_INT 3
64252: PUSH
64253: LD_INT 3
64255: PUSH
64256: EMPTY
64257: LIST
64258: LIST
64259: PUSH
64260: LD_INT 2
64262: PUSH
64263: LD_INT 3
64265: PUSH
64266: EMPTY
64267: LIST
64268: LIST
64269: PUSH
64270: EMPTY
64271: LIST
64272: LIST
64273: LIST
64274: LIST
64275: LIST
64276: LIST
64277: LIST
64278: LIST
64279: LIST
64280: LIST
64281: LIST
64282: LIST
64283: LIST
64284: LIST
64285: LIST
64286: LIST
64287: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64288: LD_ADDR_VAR 0 17
64292: PUSH
64293: LD_INT 0
64295: PUSH
64296: LD_INT 0
64298: PUSH
64299: EMPTY
64300: LIST
64301: LIST
64302: PUSH
64303: LD_INT 0
64305: PUSH
64306: LD_INT 1
64308: NEG
64309: PUSH
64310: EMPTY
64311: LIST
64312: LIST
64313: PUSH
64314: LD_INT 1
64316: PUSH
64317: LD_INT 0
64319: PUSH
64320: EMPTY
64321: LIST
64322: LIST
64323: PUSH
64324: LD_INT 1
64326: PUSH
64327: LD_INT 1
64329: PUSH
64330: EMPTY
64331: LIST
64332: LIST
64333: PUSH
64334: LD_INT 0
64336: PUSH
64337: LD_INT 1
64339: PUSH
64340: EMPTY
64341: LIST
64342: LIST
64343: PUSH
64344: LD_INT 1
64346: NEG
64347: PUSH
64348: LD_INT 0
64350: PUSH
64351: EMPTY
64352: LIST
64353: LIST
64354: PUSH
64355: LD_INT 1
64357: NEG
64358: PUSH
64359: LD_INT 1
64361: NEG
64362: PUSH
64363: EMPTY
64364: LIST
64365: LIST
64366: PUSH
64367: LD_INT 1
64369: NEG
64370: PUSH
64371: LD_INT 2
64373: NEG
64374: PUSH
64375: EMPTY
64376: LIST
64377: LIST
64378: PUSH
64379: LD_INT 0
64381: PUSH
64382: LD_INT 2
64384: NEG
64385: PUSH
64386: EMPTY
64387: LIST
64388: LIST
64389: PUSH
64390: LD_INT 1
64392: PUSH
64393: LD_INT 1
64395: NEG
64396: PUSH
64397: EMPTY
64398: LIST
64399: LIST
64400: PUSH
64401: LD_INT 2
64403: PUSH
64404: LD_INT 0
64406: PUSH
64407: EMPTY
64408: LIST
64409: LIST
64410: PUSH
64411: LD_INT 2
64413: PUSH
64414: LD_INT 1
64416: PUSH
64417: EMPTY
64418: LIST
64419: LIST
64420: PUSH
64421: LD_INT 2
64423: PUSH
64424: LD_INT 2
64426: PUSH
64427: EMPTY
64428: LIST
64429: LIST
64430: PUSH
64431: LD_INT 1
64433: PUSH
64434: LD_INT 2
64436: PUSH
64437: EMPTY
64438: LIST
64439: LIST
64440: PUSH
64441: LD_INT 0
64443: PUSH
64444: LD_INT 2
64446: PUSH
64447: EMPTY
64448: LIST
64449: LIST
64450: PUSH
64451: LD_INT 1
64453: NEG
64454: PUSH
64455: LD_INT 1
64457: PUSH
64458: EMPTY
64459: LIST
64460: LIST
64461: PUSH
64462: LD_INT 2
64464: NEG
64465: PUSH
64466: LD_INT 0
64468: PUSH
64469: EMPTY
64470: LIST
64471: LIST
64472: PUSH
64473: LD_INT 2
64475: NEG
64476: PUSH
64477: LD_INT 1
64479: NEG
64480: PUSH
64481: EMPTY
64482: LIST
64483: LIST
64484: PUSH
64485: LD_INT 2
64487: NEG
64488: PUSH
64489: LD_INT 2
64491: NEG
64492: PUSH
64493: EMPTY
64494: LIST
64495: LIST
64496: PUSH
64497: EMPTY
64498: LIST
64499: LIST
64500: LIST
64501: LIST
64502: LIST
64503: LIST
64504: LIST
64505: LIST
64506: LIST
64507: LIST
64508: LIST
64509: LIST
64510: LIST
64511: LIST
64512: LIST
64513: LIST
64514: LIST
64515: LIST
64516: LIST
64517: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64518: LD_ADDR_VAR 0 18
64522: PUSH
64523: LD_INT 0
64525: PUSH
64526: LD_INT 0
64528: PUSH
64529: EMPTY
64530: LIST
64531: LIST
64532: PUSH
64533: LD_INT 0
64535: PUSH
64536: LD_INT 1
64538: NEG
64539: PUSH
64540: EMPTY
64541: LIST
64542: LIST
64543: PUSH
64544: LD_INT 1
64546: PUSH
64547: LD_INT 0
64549: PUSH
64550: EMPTY
64551: LIST
64552: LIST
64553: PUSH
64554: LD_INT 1
64556: PUSH
64557: LD_INT 1
64559: PUSH
64560: EMPTY
64561: LIST
64562: LIST
64563: PUSH
64564: LD_INT 0
64566: PUSH
64567: LD_INT 1
64569: PUSH
64570: EMPTY
64571: LIST
64572: LIST
64573: PUSH
64574: LD_INT 1
64576: NEG
64577: PUSH
64578: LD_INT 0
64580: PUSH
64581: EMPTY
64582: LIST
64583: LIST
64584: PUSH
64585: LD_INT 1
64587: NEG
64588: PUSH
64589: LD_INT 1
64591: NEG
64592: PUSH
64593: EMPTY
64594: LIST
64595: LIST
64596: PUSH
64597: LD_INT 1
64599: NEG
64600: PUSH
64601: LD_INT 2
64603: NEG
64604: PUSH
64605: EMPTY
64606: LIST
64607: LIST
64608: PUSH
64609: LD_INT 0
64611: PUSH
64612: LD_INT 2
64614: NEG
64615: PUSH
64616: EMPTY
64617: LIST
64618: LIST
64619: PUSH
64620: LD_INT 1
64622: PUSH
64623: LD_INT 1
64625: NEG
64626: PUSH
64627: EMPTY
64628: LIST
64629: LIST
64630: PUSH
64631: LD_INT 2
64633: PUSH
64634: LD_INT 0
64636: PUSH
64637: EMPTY
64638: LIST
64639: LIST
64640: PUSH
64641: LD_INT 2
64643: PUSH
64644: LD_INT 1
64646: PUSH
64647: EMPTY
64648: LIST
64649: LIST
64650: PUSH
64651: LD_INT 2
64653: PUSH
64654: LD_INT 2
64656: PUSH
64657: EMPTY
64658: LIST
64659: LIST
64660: PUSH
64661: LD_INT 1
64663: PUSH
64664: LD_INT 2
64666: PUSH
64667: EMPTY
64668: LIST
64669: LIST
64670: PUSH
64671: LD_INT 0
64673: PUSH
64674: LD_INT 2
64676: PUSH
64677: EMPTY
64678: LIST
64679: LIST
64680: PUSH
64681: LD_INT 1
64683: NEG
64684: PUSH
64685: LD_INT 1
64687: PUSH
64688: EMPTY
64689: LIST
64690: LIST
64691: PUSH
64692: LD_INT 2
64694: NEG
64695: PUSH
64696: LD_INT 0
64698: PUSH
64699: EMPTY
64700: LIST
64701: LIST
64702: PUSH
64703: LD_INT 2
64705: NEG
64706: PUSH
64707: LD_INT 1
64709: NEG
64710: PUSH
64711: EMPTY
64712: LIST
64713: LIST
64714: PUSH
64715: LD_INT 2
64717: NEG
64718: PUSH
64719: LD_INT 2
64721: NEG
64722: PUSH
64723: EMPTY
64724: LIST
64725: LIST
64726: PUSH
64727: EMPTY
64728: LIST
64729: LIST
64730: LIST
64731: LIST
64732: LIST
64733: LIST
64734: LIST
64735: LIST
64736: LIST
64737: LIST
64738: LIST
64739: LIST
64740: LIST
64741: LIST
64742: LIST
64743: LIST
64744: LIST
64745: LIST
64746: LIST
64747: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64748: LD_ADDR_VAR 0 19
64752: PUSH
64753: LD_INT 0
64755: PUSH
64756: LD_INT 0
64758: PUSH
64759: EMPTY
64760: LIST
64761: LIST
64762: PUSH
64763: LD_INT 0
64765: PUSH
64766: LD_INT 1
64768: NEG
64769: PUSH
64770: EMPTY
64771: LIST
64772: LIST
64773: PUSH
64774: LD_INT 1
64776: PUSH
64777: LD_INT 0
64779: PUSH
64780: EMPTY
64781: LIST
64782: LIST
64783: PUSH
64784: LD_INT 1
64786: PUSH
64787: LD_INT 1
64789: PUSH
64790: EMPTY
64791: LIST
64792: LIST
64793: PUSH
64794: LD_INT 0
64796: PUSH
64797: LD_INT 1
64799: PUSH
64800: EMPTY
64801: LIST
64802: LIST
64803: PUSH
64804: LD_INT 1
64806: NEG
64807: PUSH
64808: LD_INT 0
64810: PUSH
64811: EMPTY
64812: LIST
64813: LIST
64814: PUSH
64815: LD_INT 1
64817: NEG
64818: PUSH
64819: LD_INT 1
64821: NEG
64822: PUSH
64823: EMPTY
64824: LIST
64825: LIST
64826: PUSH
64827: LD_INT 1
64829: NEG
64830: PUSH
64831: LD_INT 2
64833: NEG
64834: PUSH
64835: EMPTY
64836: LIST
64837: LIST
64838: PUSH
64839: LD_INT 0
64841: PUSH
64842: LD_INT 2
64844: NEG
64845: PUSH
64846: EMPTY
64847: LIST
64848: LIST
64849: PUSH
64850: LD_INT 1
64852: PUSH
64853: LD_INT 1
64855: NEG
64856: PUSH
64857: EMPTY
64858: LIST
64859: LIST
64860: PUSH
64861: LD_INT 2
64863: PUSH
64864: LD_INT 0
64866: PUSH
64867: EMPTY
64868: LIST
64869: LIST
64870: PUSH
64871: LD_INT 2
64873: PUSH
64874: LD_INT 1
64876: PUSH
64877: EMPTY
64878: LIST
64879: LIST
64880: PUSH
64881: LD_INT 2
64883: PUSH
64884: LD_INT 2
64886: PUSH
64887: EMPTY
64888: LIST
64889: LIST
64890: PUSH
64891: LD_INT 1
64893: PUSH
64894: LD_INT 2
64896: PUSH
64897: EMPTY
64898: LIST
64899: LIST
64900: PUSH
64901: LD_INT 0
64903: PUSH
64904: LD_INT 2
64906: PUSH
64907: EMPTY
64908: LIST
64909: LIST
64910: PUSH
64911: LD_INT 1
64913: NEG
64914: PUSH
64915: LD_INT 1
64917: PUSH
64918: EMPTY
64919: LIST
64920: LIST
64921: PUSH
64922: LD_INT 2
64924: NEG
64925: PUSH
64926: LD_INT 0
64928: PUSH
64929: EMPTY
64930: LIST
64931: LIST
64932: PUSH
64933: LD_INT 2
64935: NEG
64936: PUSH
64937: LD_INT 1
64939: NEG
64940: PUSH
64941: EMPTY
64942: LIST
64943: LIST
64944: PUSH
64945: LD_INT 2
64947: NEG
64948: PUSH
64949: LD_INT 2
64951: NEG
64952: PUSH
64953: EMPTY
64954: LIST
64955: LIST
64956: PUSH
64957: EMPTY
64958: LIST
64959: LIST
64960: LIST
64961: LIST
64962: LIST
64963: LIST
64964: LIST
64965: LIST
64966: LIST
64967: LIST
64968: LIST
64969: LIST
64970: LIST
64971: LIST
64972: LIST
64973: LIST
64974: LIST
64975: LIST
64976: LIST
64977: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64978: LD_ADDR_VAR 0 20
64982: PUSH
64983: LD_INT 0
64985: PUSH
64986: LD_INT 0
64988: PUSH
64989: EMPTY
64990: LIST
64991: LIST
64992: PUSH
64993: LD_INT 0
64995: PUSH
64996: LD_INT 1
64998: NEG
64999: PUSH
65000: EMPTY
65001: LIST
65002: LIST
65003: PUSH
65004: LD_INT 1
65006: PUSH
65007: LD_INT 0
65009: PUSH
65010: EMPTY
65011: LIST
65012: LIST
65013: PUSH
65014: LD_INT 1
65016: PUSH
65017: LD_INT 1
65019: PUSH
65020: EMPTY
65021: LIST
65022: LIST
65023: PUSH
65024: LD_INT 0
65026: PUSH
65027: LD_INT 1
65029: PUSH
65030: EMPTY
65031: LIST
65032: LIST
65033: PUSH
65034: LD_INT 1
65036: NEG
65037: PUSH
65038: LD_INT 0
65040: PUSH
65041: EMPTY
65042: LIST
65043: LIST
65044: PUSH
65045: LD_INT 1
65047: NEG
65048: PUSH
65049: LD_INT 1
65051: NEG
65052: PUSH
65053: EMPTY
65054: LIST
65055: LIST
65056: PUSH
65057: LD_INT 1
65059: NEG
65060: PUSH
65061: LD_INT 2
65063: NEG
65064: PUSH
65065: EMPTY
65066: LIST
65067: LIST
65068: PUSH
65069: LD_INT 0
65071: PUSH
65072: LD_INT 2
65074: NEG
65075: PUSH
65076: EMPTY
65077: LIST
65078: LIST
65079: PUSH
65080: LD_INT 1
65082: PUSH
65083: LD_INT 1
65085: NEG
65086: PUSH
65087: EMPTY
65088: LIST
65089: LIST
65090: PUSH
65091: LD_INT 2
65093: PUSH
65094: LD_INT 0
65096: PUSH
65097: EMPTY
65098: LIST
65099: LIST
65100: PUSH
65101: LD_INT 2
65103: PUSH
65104: LD_INT 1
65106: PUSH
65107: EMPTY
65108: LIST
65109: LIST
65110: PUSH
65111: LD_INT 2
65113: PUSH
65114: LD_INT 2
65116: PUSH
65117: EMPTY
65118: LIST
65119: LIST
65120: PUSH
65121: LD_INT 1
65123: PUSH
65124: LD_INT 2
65126: PUSH
65127: EMPTY
65128: LIST
65129: LIST
65130: PUSH
65131: LD_INT 0
65133: PUSH
65134: LD_INT 2
65136: PUSH
65137: EMPTY
65138: LIST
65139: LIST
65140: PUSH
65141: LD_INT 1
65143: NEG
65144: PUSH
65145: LD_INT 1
65147: PUSH
65148: EMPTY
65149: LIST
65150: LIST
65151: PUSH
65152: LD_INT 2
65154: NEG
65155: PUSH
65156: LD_INT 0
65158: PUSH
65159: EMPTY
65160: LIST
65161: LIST
65162: PUSH
65163: LD_INT 2
65165: NEG
65166: PUSH
65167: LD_INT 1
65169: NEG
65170: PUSH
65171: EMPTY
65172: LIST
65173: LIST
65174: PUSH
65175: LD_INT 2
65177: NEG
65178: PUSH
65179: LD_INT 2
65181: NEG
65182: PUSH
65183: EMPTY
65184: LIST
65185: LIST
65186: PUSH
65187: EMPTY
65188: LIST
65189: LIST
65190: LIST
65191: LIST
65192: LIST
65193: LIST
65194: LIST
65195: LIST
65196: LIST
65197: LIST
65198: LIST
65199: LIST
65200: LIST
65201: LIST
65202: LIST
65203: LIST
65204: LIST
65205: LIST
65206: LIST
65207: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65208: LD_ADDR_VAR 0 21
65212: PUSH
65213: LD_INT 0
65215: PUSH
65216: LD_INT 0
65218: PUSH
65219: EMPTY
65220: LIST
65221: LIST
65222: PUSH
65223: LD_INT 0
65225: PUSH
65226: LD_INT 1
65228: NEG
65229: PUSH
65230: EMPTY
65231: LIST
65232: LIST
65233: PUSH
65234: LD_INT 1
65236: PUSH
65237: LD_INT 0
65239: PUSH
65240: EMPTY
65241: LIST
65242: LIST
65243: PUSH
65244: LD_INT 1
65246: PUSH
65247: LD_INT 1
65249: PUSH
65250: EMPTY
65251: LIST
65252: LIST
65253: PUSH
65254: LD_INT 0
65256: PUSH
65257: LD_INT 1
65259: PUSH
65260: EMPTY
65261: LIST
65262: LIST
65263: PUSH
65264: LD_INT 1
65266: NEG
65267: PUSH
65268: LD_INT 0
65270: PUSH
65271: EMPTY
65272: LIST
65273: LIST
65274: PUSH
65275: LD_INT 1
65277: NEG
65278: PUSH
65279: LD_INT 1
65281: NEG
65282: PUSH
65283: EMPTY
65284: LIST
65285: LIST
65286: PUSH
65287: LD_INT 1
65289: NEG
65290: PUSH
65291: LD_INT 2
65293: NEG
65294: PUSH
65295: EMPTY
65296: LIST
65297: LIST
65298: PUSH
65299: LD_INT 0
65301: PUSH
65302: LD_INT 2
65304: NEG
65305: PUSH
65306: EMPTY
65307: LIST
65308: LIST
65309: PUSH
65310: LD_INT 1
65312: PUSH
65313: LD_INT 1
65315: NEG
65316: PUSH
65317: EMPTY
65318: LIST
65319: LIST
65320: PUSH
65321: LD_INT 2
65323: PUSH
65324: LD_INT 0
65326: PUSH
65327: EMPTY
65328: LIST
65329: LIST
65330: PUSH
65331: LD_INT 2
65333: PUSH
65334: LD_INT 1
65336: PUSH
65337: EMPTY
65338: LIST
65339: LIST
65340: PUSH
65341: LD_INT 2
65343: PUSH
65344: LD_INT 2
65346: PUSH
65347: EMPTY
65348: LIST
65349: LIST
65350: PUSH
65351: LD_INT 1
65353: PUSH
65354: LD_INT 2
65356: PUSH
65357: EMPTY
65358: LIST
65359: LIST
65360: PUSH
65361: LD_INT 0
65363: PUSH
65364: LD_INT 2
65366: PUSH
65367: EMPTY
65368: LIST
65369: LIST
65370: PUSH
65371: LD_INT 1
65373: NEG
65374: PUSH
65375: LD_INT 1
65377: PUSH
65378: EMPTY
65379: LIST
65380: LIST
65381: PUSH
65382: LD_INT 2
65384: NEG
65385: PUSH
65386: LD_INT 0
65388: PUSH
65389: EMPTY
65390: LIST
65391: LIST
65392: PUSH
65393: LD_INT 2
65395: NEG
65396: PUSH
65397: LD_INT 1
65399: NEG
65400: PUSH
65401: EMPTY
65402: LIST
65403: LIST
65404: PUSH
65405: LD_INT 2
65407: NEG
65408: PUSH
65409: LD_INT 2
65411: NEG
65412: PUSH
65413: EMPTY
65414: LIST
65415: LIST
65416: PUSH
65417: EMPTY
65418: LIST
65419: LIST
65420: LIST
65421: LIST
65422: LIST
65423: LIST
65424: LIST
65425: LIST
65426: LIST
65427: LIST
65428: LIST
65429: LIST
65430: LIST
65431: LIST
65432: LIST
65433: LIST
65434: LIST
65435: LIST
65436: LIST
65437: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65438: LD_ADDR_VAR 0 22
65442: PUSH
65443: LD_INT 0
65445: PUSH
65446: LD_INT 0
65448: PUSH
65449: EMPTY
65450: LIST
65451: LIST
65452: PUSH
65453: LD_INT 0
65455: PUSH
65456: LD_INT 1
65458: NEG
65459: PUSH
65460: EMPTY
65461: LIST
65462: LIST
65463: PUSH
65464: LD_INT 1
65466: PUSH
65467: LD_INT 0
65469: PUSH
65470: EMPTY
65471: LIST
65472: LIST
65473: PUSH
65474: LD_INT 1
65476: PUSH
65477: LD_INT 1
65479: PUSH
65480: EMPTY
65481: LIST
65482: LIST
65483: PUSH
65484: LD_INT 0
65486: PUSH
65487: LD_INT 1
65489: PUSH
65490: EMPTY
65491: LIST
65492: LIST
65493: PUSH
65494: LD_INT 1
65496: NEG
65497: PUSH
65498: LD_INT 0
65500: PUSH
65501: EMPTY
65502: LIST
65503: LIST
65504: PUSH
65505: LD_INT 1
65507: NEG
65508: PUSH
65509: LD_INT 1
65511: NEG
65512: PUSH
65513: EMPTY
65514: LIST
65515: LIST
65516: PUSH
65517: LD_INT 1
65519: NEG
65520: PUSH
65521: LD_INT 2
65523: NEG
65524: PUSH
65525: EMPTY
65526: LIST
65527: LIST
65528: PUSH
65529: LD_INT 0
65531: PUSH
65532: LD_INT 2
65534: NEG
65535: PUSH
65536: EMPTY
65537: LIST
65538: LIST
65539: PUSH
65540: LD_INT 1
65542: PUSH
65543: LD_INT 1
65545: NEG
65546: PUSH
65547: EMPTY
65548: LIST
65549: LIST
65550: PUSH
65551: LD_INT 2
65553: PUSH
65554: LD_INT 0
65556: PUSH
65557: EMPTY
65558: LIST
65559: LIST
65560: PUSH
65561: LD_INT 2
65563: PUSH
65564: LD_INT 1
65566: PUSH
65567: EMPTY
65568: LIST
65569: LIST
65570: PUSH
65571: LD_INT 2
65573: PUSH
65574: LD_INT 2
65576: PUSH
65577: EMPTY
65578: LIST
65579: LIST
65580: PUSH
65581: LD_INT 1
65583: PUSH
65584: LD_INT 2
65586: PUSH
65587: EMPTY
65588: LIST
65589: LIST
65590: PUSH
65591: LD_INT 0
65593: PUSH
65594: LD_INT 2
65596: PUSH
65597: EMPTY
65598: LIST
65599: LIST
65600: PUSH
65601: LD_INT 1
65603: NEG
65604: PUSH
65605: LD_INT 1
65607: PUSH
65608: EMPTY
65609: LIST
65610: LIST
65611: PUSH
65612: LD_INT 2
65614: NEG
65615: PUSH
65616: LD_INT 0
65618: PUSH
65619: EMPTY
65620: LIST
65621: LIST
65622: PUSH
65623: LD_INT 2
65625: NEG
65626: PUSH
65627: LD_INT 1
65629: NEG
65630: PUSH
65631: EMPTY
65632: LIST
65633: LIST
65634: PUSH
65635: LD_INT 2
65637: NEG
65638: PUSH
65639: LD_INT 2
65641: NEG
65642: PUSH
65643: EMPTY
65644: LIST
65645: LIST
65646: PUSH
65647: EMPTY
65648: LIST
65649: LIST
65650: LIST
65651: LIST
65652: LIST
65653: LIST
65654: LIST
65655: LIST
65656: LIST
65657: LIST
65658: LIST
65659: LIST
65660: LIST
65661: LIST
65662: LIST
65663: LIST
65664: LIST
65665: LIST
65666: LIST
65667: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
65668: LD_ADDR_VAR 0 23
65672: PUSH
65673: LD_INT 0
65675: PUSH
65676: LD_INT 0
65678: PUSH
65679: EMPTY
65680: LIST
65681: LIST
65682: PUSH
65683: LD_INT 0
65685: PUSH
65686: LD_INT 1
65688: NEG
65689: PUSH
65690: EMPTY
65691: LIST
65692: LIST
65693: PUSH
65694: LD_INT 1
65696: PUSH
65697: LD_INT 0
65699: PUSH
65700: EMPTY
65701: LIST
65702: LIST
65703: PUSH
65704: LD_INT 1
65706: PUSH
65707: LD_INT 1
65709: PUSH
65710: EMPTY
65711: LIST
65712: LIST
65713: PUSH
65714: LD_INT 0
65716: PUSH
65717: LD_INT 1
65719: PUSH
65720: EMPTY
65721: LIST
65722: LIST
65723: PUSH
65724: LD_INT 1
65726: NEG
65727: PUSH
65728: LD_INT 0
65730: PUSH
65731: EMPTY
65732: LIST
65733: LIST
65734: PUSH
65735: LD_INT 1
65737: NEG
65738: PUSH
65739: LD_INT 1
65741: NEG
65742: PUSH
65743: EMPTY
65744: LIST
65745: LIST
65746: PUSH
65747: LD_INT 1
65749: NEG
65750: PUSH
65751: LD_INT 2
65753: NEG
65754: PUSH
65755: EMPTY
65756: LIST
65757: LIST
65758: PUSH
65759: LD_INT 0
65761: PUSH
65762: LD_INT 2
65764: NEG
65765: PUSH
65766: EMPTY
65767: LIST
65768: LIST
65769: PUSH
65770: LD_INT 1
65772: PUSH
65773: LD_INT 1
65775: NEG
65776: PUSH
65777: EMPTY
65778: LIST
65779: LIST
65780: PUSH
65781: LD_INT 2
65783: PUSH
65784: LD_INT 0
65786: PUSH
65787: EMPTY
65788: LIST
65789: LIST
65790: PUSH
65791: LD_INT 2
65793: PUSH
65794: LD_INT 1
65796: PUSH
65797: EMPTY
65798: LIST
65799: LIST
65800: PUSH
65801: LD_INT 2
65803: PUSH
65804: LD_INT 2
65806: PUSH
65807: EMPTY
65808: LIST
65809: LIST
65810: PUSH
65811: LD_INT 1
65813: PUSH
65814: LD_INT 2
65816: PUSH
65817: EMPTY
65818: LIST
65819: LIST
65820: PUSH
65821: LD_INT 0
65823: PUSH
65824: LD_INT 2
65826: PUSH
65827: EMPTY
65828: LIST
65829: LIST
65830: PUSH
65831: LD_INT 1
65833: NEG
65834: PUSH
65835: LD_INT 1
65837: PUSH
65838: EMPTY
65839: LIST
65840: LIST
65841: PUSH
65842: LD_INT 2
65844: NEG
65845: PUSH
65846: LD_INT 0
65848: PUSH
65849: EMPTY
65850: LIST
65851: LIST
65852: PUSH
65853: LD_INT 2
65855: NEG
65856: PUSH
65857: LD_INT 1
65859: NEG
65860: PUSH
65861: EMPTY
65862: LIST
65863: LIST
65864: PUSH
65865: LD_INT 2
65867: NEG
65868: PUSH
65869: LD_INT 2
65871: NEG
65872: PUSH
65873: EMPTY
65874: LIST
65875: LIST
65876: PUSH
65877: LD_INT 2
65879: NEG
65880: PUSH
65881: LD_INT 3
65883: NEG
65884: PUSH
65885: EMPTY
65886: LIST
65887: LIST
65888: PUSH
65889: LD_INT 1
65891: NEG
65892: PUSH
65893: LD_INT 3
65895: NEG
65896: PUSH
65897: EMPTY
65898: LIST
65899: LIST
65900: PUSH
65901: LD_INT 1
65903: PUSH
65904: LD_INT 2
65906: NEG
65907: PUSH
65908: EMPTY
65909: LIST
65910: LIST
65911: PUSH
65912: LD_INT 2
65914: PUSH
65915: LD_INT 1
65917: NEG
65918: PUSH
65919: EMPTY
65920: LIST
65921: LIST
65922: PUSH
65923: EMPTY
65924: LIST
65925: LIST
65926: LIST
65927: LIST
65928: LIST
65929: LIST
65930: LIST
65931: LIST
65932: LIST
65933: LIST
65934: LIST
65935: LIST
65936: LIST
65937: LIST
65938: LIST
65939: LIST
65940: LIST
65941: LIST
65942: LIST
65943: LIST
65944: LIST
65945: LIST
65946: LIST
65947: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
65948: LD_ADDR_VAR 0 24
65952: PUSH
65953: LD_INT 0
65955: PUSH
65956: LD_INT 0
65958: PUSH
65959: EMPTY
65960: LIST
65961: LIST
65962: PUSH
65963: LD_INT 0
65965: PUSH
65966: LD_INT 1
65968: NEG
65969: PUSH
65970: EMPTY
65971: LIST
65972: LIST
65973: PUSH
65974: LD_INT 1
65976: PUSH
65977: LD_INT 0
65979: PUSH
65980: EMPTY
65981: LIST
65982: LIST
65983: PUSH
65984: LD_INT 1
65986: PUSH
65987: LD_INT 1
65989: PUSH
65990: EMPTY
65991: LIST
65992: LIST
65993: PUSH
65994: LD_INT 0
65996: PUSH
65997: LD_INT 1
65999: PUSH
66000: EMPTY
66001: LIST
66002: LIST
66003: PUSH
66004: LD_INT 1
66006: NEG
66007: PUSH
66008: LD_INT 0
66010: PUSH
66011: EMPTY
66012: LIST
66013: LIST
66014: PUSH
66015: LD_INT 1
66017: NEG
66018: PUSH
66019: LD_INT 1
66021: NEG
66022: PUSH
66023: EMPTY
66024: LIST
66025: LIST
66026: PUSH
66027: LD_INT 1
66029: NEG
66030: PUSH
66031: LD_INT 2
66033: NEG
66034: PUSH
66035: EMPTY
66036: LIST
66037: LIST
66038: PUSH
66039: LD_INT 0
66041: PUSH
66042: LD_INT 2
66044: NEG
66045: PUSH
66046: EMPTY
66047: LIST
66048: LIST
66049: PUSH
66050: LD_INT 1
66052: PUSH
66053: LD_INT 1
66055: NEG
66056: PUSH
66057: EMPTY
66058: LIST
66059: LIST
66060: PUSH
66061: LD_INT 2
66063: PUSH
66064: LD_INT 0
66066: PUSH
66067: EMPTY
66068: LIST
66069: LIST
66070: PUSH
66071: LD_INT 2
66073: PUSH
66074: LD_INT 1
66076: PUSH
66077: EMPTY
66078: LIST
66079: LIST
66080: PUSH
66081: LD_INT 2
66083: PUSH
66084: LD_INT 2
66086: PUSH
66087: EMPTY
66088: LIST
66089: LIST
66090: PUSH
66091: LD_INT 1
66093: PUSH
66094: LD_INT 2
66096: PUSH
66097: EMPTY
66098: LIST
66099: LIST
66100: PUSH
66101: LD_INT 0
66103: PUSH
66104: LD_INT 2
66106: PUSH
66107: EMPTY
66108: LIST
66109: LIST
66110: PUSH
66111: LD_INT 1
66113: NEG
66114: PUSH
66115: LD_INT 1
66117: PUSH
66118: EMPTY
66119: LIST
66120: LIST
66121: PUSH
66122: LD_INT 2
66124: NEG
66125: PUSH
66126: LD_INT 0
66128: PUSH
66129: EMPTY
66130: LIST
66131: LIST
66132: PUSH
66133: LD_INT 2
66135: NEG
66136: PUSH
66137: LD_INT 1
66139: NEG
66140: PUSH
66141: EMPTY
66142: LIST
66143: LIST
66144: PUSH
66145: LD_INT 2
66147: NEG
66148: PUSH
66149: LD_INT 2
66151: NEG
66152: PUSH
66153: EMPTY
66154: LIST
66155: LIST
66156: PUSH
66157: LD_INT 1
66159: PUSH
66160: LD_INT 2
66162: NEG
66163: PUSH
66164: EMPTY
66165: LIST
66166: LIST
66167: PUSH
66168: LD_INT 2
66170: PUSH
66171: LD_INT 1
66173: NEG
66174: PUSH
66175: EMPTY
66176: LIST
66177: LIST
66178: PUSH
66179: LD_INT 3
66181: PUSH
66182: LD_INT 1
66184: PUSH
66185: EMPTY
66186: LIST
66187: LIST
66188: PUSH
66189: LD_INT 3
66191: PUSH
66192: LD_INT 2
66194: PUSH
66195: EMPTY
66196: LIST
66197: LIST
66198: PUSH
66199: EMPTY
66200: LIST
66201: LIST
66202: LIST
66203: LIST
66204: LIST
66205: LIST
66206: LIST
66207: LIST
66208: LIST
66209: LIST
66210: LIST
66211: LIST
66212: LIST
66213: LIST
66214: LIST
66215: LIST
66216: LIST
66217: LIST
66218: LIST
66219: LIST
66220: LIST
66221: LIST
66222: LIST
66223: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
66224: LD_ADDR_VAR 0 25
66228: PUSH
66229: LD_INT 0
66231: PUSH
66232: LD_INT 0
66234: PUSH
66235: EMPTY
66236: LIST
66237: LIST
66238: PUSH
66239: LD_INT 0
66241: PUSH
66242: LD_INT 1
66244: NEG
66245: PUSH
66246: EMPTY
66247: LIST
66248: LIST
66249: PUSH
66250: LD_INT 1
66252: PUSH
66253: LD_INT 0
66255: PUSH
66256: EMPTY
66257: LIST
66258: LIST
66259: PUSH
66260: LD_INT 1
66262: PUSH
66263: LD_INT 1
66265: PUSH
66266: EMPTY
66267: LIST
66268: LIST
66269: PUSH
66270: LD_INT 0
66272: PUSH
66273: LD_INT 1
66275: PUSH
66276: EMPTY
66277: LIST
66278: LIST
66279: PUSH
66280: LD_INT 1
66282: NEG
66283: PUSH
66284: LD_INT 0
66286: PUSH
66287: EMPTY
66288: LIST
66289: LIST
66290: PUSH
66291: LD_INT 1
66293: NEG
66294: PUSH
66295: LD_INT 1
66297: NEG
66298: PUSH
66299: EMPTY
66300: LIST
66301: LIST
66302: PUSH
66303: LD_INT 1
66305: NEG
66306: PUSH
66307: LD_INT 2
66309: NEG
66310: PUSH
66311: EMPTY
66312: LIST
66313: LIST
66314: PUSH
66315: LD_INT 0
66317: PUSH
66318: LD_INT 2
66320: NEG
66321: PUSH
66322: EMPTY
66323: LIST
66324: LIST
66325: PUSH
66326: LD_INT 1
66328: PUSH
66329: LD_INT 1
66331: NEG
66332: PUSH
66333: EMPTY
66334: LIST
66335: LIST
66336: PUSH
66337: LD_INT 2
66339: PUSH
66340: LD_INT 0
66342: PUSH
66343: EMPTY
66344: LIST
66345: LIST
66346: PUSH
66347: LD_INT 2
66349: PUSH
66350: LD_INT 1
66352: PUSH
66353: EMPTY
66354: LIST
66355: LIST
66356: PUSH
66357: LD_INT 2
66359: PUSH
66360: LD_INT 2
66362: PUSH
66363: EMPTY
66364: LIST
66365: LIST
66366: PUSH
66367: LD_INT 1
66369: PUSH
66370: LD_INT 2
66372: PUSH
66373: EMPTY
66374: LIST
66375: LIST
66376: PUSH
66377: LD_INT 0
66379: PUSH
66380: LD_INT 2
66382: PUSH
66383: EMPTY
66384: LIST
66385: LIST
66386: PUSH
66387: LD_INT 1
66389: NEG
66390: PUSH
66391: LD_INT 1
66393: PUSH
66394: EMPTY
66395: LIST
66396: LIST
66397: PUSH
66398: LD_INT 2
66400: NEG
66401: PUSH
66402: LD_INT 0
66404: PUSH
66405: EMPTY
66406: LIST
66407: LIST
66408: PUSH
66409: LD_INT 2
66411: NEG
66412: PUSH
66413: LD_INT 1
66415: NEG
66416: PUSH
66417: EMPTY
66418: LIST
66419: LIST
66420: PUSH
66421: LD_INT 2
66423: NEG
66424: PUSH
66425: LD_INT 2
66427: NEG
66428: PUSH
66429: EMPTY
66430: LIST
66431: LIST
66432: PUSH
66433: LD_INT 3
66435: PUSH
66436: LD_INT 1
66438: PUSH
66439: EMPTY
66440: LIST
66441: LIST
66442: PUSH
66443: LD_INT 3
66445: PUSH
66446: LD_INT 2
66448: PUSH
66449: EMPTY
66450: LIST
66451: LIST
66452: PUSH
66453: LD_INT 2
66455: PUSH
66456: LD_INT 3
66458: PUSH
66459: EMPTY
66460: LIST
66461: LIST
66462: PUSH
66463: LD_INT 1
66465: PUSH
66466: LD_INT 3
66468: PUSH
66469: EMPTY
66470: LIST
66471: LIST
66472: PUSH
66473: EMPTY
66474: LIST
66475: LIST
66476: LIST
66477: LIST
66478: LIST
66479: LIST
66480: LIST
66481: LIST
66482: LIST
66483: LIST
66484: LIST
66485: LIST
66486: LIST
66487: LIST
66488: LIST
66489: LIST
66490: LIST
66491: LIST
66492: LIST
66493: LIST
66494: LIST
66495: LIST
66496: LIST
66497: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
66498: LD_ADDR_VAR 0 26
66502: PUSH
66503: LD_INT 0
66505: PUSH
66506: LD_INT 0
66508: PUSH
66509: EMPTY
66510: LIST
66511: LIST
66512: PUSH
66513: LD_INT 0
66515: PUSH
66516: LD_INT 1
66518: NEG
66519: PUSH
66520: EMPTY
66521: LIST
66522: LIST
66523: PUSH
66524: LD_INT 1
66526: PUSH
66527: LD_INT 0
66529: PUSH
66530: EMPTY
66531: LIST
66532: LIST
66533: PUSH
66534: LD_INT 1
66536: PUSH
66537: LD_INT 1
66539: PUSH
66540: EMPTY
66541: LIST
66542: LIST
66543: PUSH
66544: LD_INT 0
66546: PUSH
66547: LD_INT 1
66549: PUSH
66550: EMPTY
66551: LIST
66552: LIST
66553: PUSH
66554: LD_INT 1
66556: NEG
66557: PUSH
66558: LD_INT 0
66560: PUSH
66561: EMPTY
66562: LIST
66563: LIST
66564: PUSH
66565: LD_INT 1
66567: NEG
66568: PUSH
66569: LD_INT 1
66571: NEG
66572: PUSH
66573: EMPTY
66574: LIST
66575: LIST
66576: PUSH
66577: LD_INT 1
66579: NEG
66580: PUSH
66581: LD_INT 2
66583: NEG
66584: PUSH
66585: EMPTY
66586: LIST
66587: LIST
66588: PUSH
66589: LD_INT 0
66591: PUSH
66592: LD_INT 2
66594: NEG
66595: PUSH
66596: EMPTY
66597: LIST
66598: LIST
66599: PUSH
66600: LD_INT 1
66602: PUSH
66603: LD_INT 1
66605: NEG
66606: PUSH
66607: EMPTY
66608: LIST
66609: LIST
66610: PUSH
66611: LD_INT 2
66613: PUSH
66614: LD_INT 0
66616: PUSH
66617: EMPTY
66618: LIST
66619: LIST
66620: PUSH
66621: LD_INT 2
66623: PUSH
66624: LD_INT 1
66626: PUSH
66627: EMPTY
66628: LIST
66629: LIST
66630: PUSH
66631: LD_INT 2
66633: PUSH
66634: LD_INT 2
66636: PUSH
66637: EMPTY
66638: LIST
66639: LIST
66640: PUSH
66641: LD_INT 1
66643: PUSH
66644: LD_INT 2
66646: PUSH
66647: EMPTY
66648: LIST
66649: LIST
66650: PUSH
66651: LD_INT 0
66653: PUSH
66654: LD_INT 2
66656: PUSH
66657: EMPTY
66658: LIST
66659: LIST
66660: PUSH
66661: LD_INT 1
66663: NEG
66664: PUSH
66665: LD_INT 1
66667: PUSH
66668: EMPTY
66669: LIST
66670: LIST
66671: PUSH
66672: LD_INT 2
66674: NEG
66675: PUSH
66676: LD_INT 0
66678: PUSH
66679: EMPTY
66680: LIST
66681: LIST
66682: PUSH
66683: LD_INT 2
66685: NEG
66686: PUSH
66687: LD_INT 1
66689: NEG
66690: PUSH
66691: EMPTY
66692: LIST
66693: LIST
66694: PUSH
66695: LD_INT 2
66697: NEG
66698: PUSH
66699: LD_INT 2
66701: NEG
66702: PUSH
66703: EMPTY
66704: LIST
66705: LIST
66706: PUSH
66707: LD_INT 2
66709: PUSH
66710: LD_INT 3
66712: PUSH
66713: EMPTY
66714: LIST
66715: LIST
66716: PUSH
66717: LD_INT 1
66719: PUSH
66720: LD_INT 3
66722: PUSH
66723: EMPTY
66724: LIST
66725: LIST
66726: PUSH
66727: LD_INT 1
66729: NEG
66730: PUSH
66731: LD_INT 2
66733: PUSH
66734: EMPTY
66735: LIST
66736: LIST
66737: PUSH
66738: LD_INT 2
66740: NEG
66741: PUSH
66742: LD_INT 1
66744: PUSH
66745: EMPTY
66746: LIST
66747: LIST
66748: PUSH
66749: EMPTY
66750: LIST
66751: LIST
66752: LIST
66753: LIST
66754: LIST
66755: LIST
66756: LIST
66757: LIST
66758: LIST
66759: LIST
66760: LIST
66761: LIST
66762: LIST
66763: LIST
66764: LIST
66765: LIST
66766: LIST
66767: LIST
66768: LIST
66769: LIST
66770: LIST
66771: LIST
66772: LIST
66773: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
66774: LD_ADDR_VAR 0 27
66778: PUSH
66779: LD_INT 0
66781: PUSH
66782: LD_INT 0
66784: PUSH
66785: EMPTY
66786: LIST
66787: LIST
66788: PUSH
66789: LD_INT 0
66791: PUSH
66792: LD_INT 1
66794: NEG
66795: PUSH
66796: EMPTY
66797: LIST
66798: LIST
66799: PUSH
66800: LD_INT 1
66802: PUSH
66803: LD_INT 0
66805: PUSH
66806: EMPTY
66807: LIST
66808: LIST
66809: PUSH
66810: LD_INT 1
66812: PUSH
66813: LD_INT 1
66815: PUSH
66816: EMPTY
66817: LIST
66818: LIST
66819: PUSH
66820: LD_INT 0
66822: PUSH
66823: LD_INT 1
66825: PUSH
66826: EMPTY
66827: LIST
66828: LIST
66829: PUSH
66830: LD_INT 1
66832: NEG
66833: PUSH
66834: LD_INT 0
66836: PUSH
66837: EMPTY
66838: LIST
66839: LIST
66840: PUSH
66841: LD_INT 1
66843: NEG
66844: PUSH
66845: LD_INT 1
66847: NEG
66848: PUSH
66849: EMPTY
66850: LIST
66851: LIST
66852: PUSH
66853: LD_INT 1
66855: NEG
66856: PUSH
66857: LD_INT 2
66859: NEG
66860: PUSH
66861: EMPTY
66862: LIST
66863: LIST
66864: PUSH
66865: LD_INT 0
66867: PUSH
66868: LD_INT 2
66870: NEG
66871: PUSH
66872: EMPTY
66873: LIST
66874: LIST
66875: PUSH
66876: LD_INT 1
66878: PUSH
66879: LD_INT 1
66881: NEG
66882: PUSH
66883: EMPTY
66884: LIST
66885: LIST
66886: PUSH
66887: LD_INT 2
66889: PUSH
66890: LD_INT 0
66892: PUSH
66893: EMPTY
66894: LIST
66895: LIST
66896: PUSH
66897: LD_INT 2
66899: PUSH
66900: LD_INT 1
66902: PUSH
66903: EMPTY
66904: LIST
66905: LIST
66906: PUSH
66907: LD_INT 2
66909: PUSH
66910: LD_INT 2
66912: PUSH
66913: EMPTY
66914: LIST
66915: LIST
66916: PUSH
66917: LD_INT 1
66919: PUSH
66920: LD_INT 2
66922: PUSH
66923: EMPTY
66924: LIST
66925: LIST
66926: PUSH
66927: LD_INT 0
66929: PUSH
66930: LD_INT 2
66932: PUSH
66933: EMPTY
66934: LIST
66935: LIST
66936: PUSH
66937: LD_INT 1
66939: NEG
66940: PUSH
66941: LD_INT 1
66943: PUSH
66944: EMPTY
66945: LIST
66946: LIST
66947: PUSH
66948: LD_INT 2
66950: NEG
66951: PUSH
66952: LD_INT 0
66954: PUSH
66955: EMPTY
66956: LIST
66957: LIST
66958: PUSH
66959: LD_INT 2
66961: NEG
66962: PUSH
66963: LD_INT 1
66965: NEG
66966: PUSH
66967: EMPTY
66968: LIST
66969: LIST
66970: PUSH
66971: LD_INT 2
66973: NEG
66974: PUSH
66975: LD_INT 2
66977: NEG
66978: PUSH
66979: EMPTY
66980: LIST
66981: LIST
66982: PUSH
66983: LD_INT 1
66985: NEG
66986: PUSH
66987: LD_INT 2
66989: PUSH
66990: EMPTY
66991: LIST
66992: LIST
66993: PUSH
66994: LD_INT 2
66996: NEG
66997: PUSH
66998: LD_INT 1
67000: PUSH
67001: EMPTY
67002: LIST
67003: LIST
67004: PUSH
67005: LD_INT 3
67007: NEG
67008: PUSH
67009: LD_INT 1
67011: NEG
67012: PUSH
67013: EMPTY
67014: LIST
67015: LIST
67016: PUSH
67017: LD_INT 3
67019: NEG
67020: PUSH
67021: LD_INT 2
67023: NEG
67024: PUSH
67025: EMPTY
67026: LIST
67027: LIST
67028: PUSH
67029: EMPTY
67030: LIST
67031: LIST
67032: LIST
67033: LIST
67034: LIST
67035: LIST
67036: LIST
67037: LIST
67038: LIST
67039: LIST
67040: LIST
67041: LIST
67042: LIST
67043: LIST
67044: LIST
67045: LIST
67046: LIST
67047: LIST
67048: LIST
67049: LIST
67050: LIST
67051: LIST
67052: LIST
67053: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
67054: LD_ADDR_VAR 0 28
67058: PUSH
67059: LD_INT 0
67061: PUSH
67062: LD_INT 0
67064: PUSH
67065: EMPTY
67066: LIST
67067: LIST
67068: PUSH
67069: LD_INT 0
67071: PUSH
67072: LD_INT 1
67074: NEG
67075: PUSH
67076: EMPTY
67077: LIST
67078: LIST
67079: PUSH
67080: LD_INT 1
67082: PUSH
67083: LD_INT 0
67085: PUSH
67086: EMPTY
67087: LIST
67088: LIST
67089: PUSH
67090: LD_INT 1
67092: PUSH
67093: LD_INT 1
67095: PUSH
67096: EMPTY
67097: LIST
67098: LIST
67099: PUSH
67100: LD_INT 0
67102: PUSH
67103: LD_INT 1
67105: PUSH
67106: EMPTY
67107: LIST
67108: LIST
67109: PUSH
67110: LD_INT 1
67112: NEG
67113: PUSH
67114: LD_INT 0
67116: PUSH
67117: EMPTY
67118: LIST
67119: LIST
67120: PUSH
67121: LD_INT 1
67123: NEG
67124: PUSH
67125: LD_INT 1
67127: NEG
67128: PUSH
67129: EMPTY
67130: LIST
67131: LIST
67132: PUSH
67133: LD_INT 1
67135: NEG
67136: PUSH
67137: LD_INT 2
67139: NEG
67140: PUSH
67141: EMPTY
67142: LIST
67143: LIST
67144: PUSH
67145: LD_INT 0
67147: PUSH
67148: LD_INT 2
67150: NEG
67151: PUSH
67152: EMPTY
67153: LIST
67154: LIST
67155: PUSH
67156: LD_INT 1
67158: PUSH
67159: LD_INT 1
67161: NEG
67162: PUSH
67163: EMPTY
67164: LIST
67165: LIST
67166: PUSH
67167: LD_INT 2
67169: PUSH
67170: LD_INT 0
67172: PUSH
67173: EMPTY
67174: LIST
67175: LIST
67176: PUSH
67177: LD_INT 2
67179: PUSH
67180: LD_INT 1
67182: PUSH
67183: EMPTY
67184: LIST
67185: LIST
67186: PUSH
67187: LD_INT 2
67189: PUSH
67190: LD_INT 2
67192: PUSH
67193: EMPTY
67194: LIST
67195: LIST
67196: PUSH
67197: LD_INT 1
67199: PUSH
67200: LD_INT 2
67202: PUSH
67203: EMPTY
67204: LIST
67205: LIST
67206: PUSH
67207: LD_INT 0
67209: PUSH
67210: LD_INT 2
67212: PUSH
67213: EMPTY
67214: LIST
67215: LIST
67216: PUSH
67217: LD_INT 1
67219: NEG
67220: PUSH
67221: LD_INT 1
67223: PUSH
67224: EMPTY
67225: LIST
67226: LIST
67227: PUSH
67228: LD_INT 2
67230: NEG
67231: PUSH
67232: LD_INT 0
67234: PUSH
67235: EMPTY
67236: LIST
67237: LIST
67238: PUSH
67239: LD_INT 2
67241: NEG
67242: PUSH
67243: LD_INT 1
67245: NEG
67246: PUSH
67247: EMPTY
67248: LIST
67249: LIST
67250: PUSH
67251: LD_INT 2
67253: NEG
67254: PUSH
67255: LD_INT 2
67257: NEG
67258: PUSH
67259: EMPTY
67260: LIST
67261: LIST
67262: PUSH
67263: LD_INT 2
67265: NEG
67266: PUSH
67267: LD_INT 3
67269: NEG
67270: PUSH
67271: EMPTY
67272: LIST
67273: LIST
67274: PUSH
67275: LD_INT 1
67277: NEG
67278: PUSH
67279: LD_INT 3
67281: NEG
67282: PUSH
67283: EMPTY
67284: LIST
67285: LIST
67286: PUSH
67287: LD_INT 3
67289: NEG
67290: PUSH
67291: LD_INT 1
67293: NEG
67294: PUSH
67295: EMPTY
67296: LIST
67297: LIST
67298: PUSH
67299: LD_INT 3
67301: NEG
67302: PUSH
67303: LD_INT 2
67305: NEG
67306: PUSH
67307: EMPTY
67308: LIST
67309: LIST
67310: PUSH
67311: EMPTY
67312: LIST
67313: LIST
67314: LIST
67315: LIST
67316: LIST
67317: LIST
67318: LIST
67319: LIST
67320: LIST
67321: LIST
67322: LIST
67323: LIST
67324: LIST
67325: LIST
67326: LIST
67327: LIST
67328: LIST
67329: LIST
67330: LIST
67331: LIST
67332: LIST
67333: LIST
67334: LIST
67335: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
67336: LD_ADDR_VAR 0 29
67340: PUSH
67341: LD_INT 0
67343: PUSH
67344: LD_INT 0
67346: PUSH
67347: EMPTY
67348: LIST
67349: LIST
67350: PUSH
67351: LD_INT 0
67353: PUSH
67354: LD_INT 1
67356: NEG
67357: PUSH
67358: EMPTY
67359: LIST
67360: LIST
67361: PUSH
67362: LD_INT 1
67364: PUSH
67365: LD_INT 0
67367: PUSH
67368: EMPTY
67369: LIST
67370: LIST
67371: PUSH
67372: LD_INT 1
67374: PUSH
67375: LD_INT 1
67377: PUSH
67378: EMPTY
67379: LIST
67380: LIST
67381: PUSH
67382: LD_INT 0
67384: PUSH
67385: LD_INT 1
67387: PUSH
67388: EMPTY
67389: LIST
67390: LIST
67391: PUSH
67392: LD_INT 1
67394: NEG
67395: PUSH
67396: LD_INT 0
67398: PUSH
67399: EMPTY
67400: LIST
67401: LIST
67402: PUSH
67403: LD_INT 1
67405: NEG
67406: PUSH
67407: LD_INT 1
67409: NEG
67410: PUSH
67411: EMPTY
67412: LIST
67413: LIST
67414: PUSH
67415: LD_INT 1
67417: NEG
67418: PUSH
67419: LD_INT 2
67421: NEG
67422: PUSH
67423: EMPTY
67424: LIST
67425: LIST
67426: PUSH
67427: LD_INT 0
67429: PUSH
67430: LD_INT 2
67432: NEG
67433: PUSH
67434: EMPTY
67435: LIST
67436: LIST
67437: PUSH
67438: LD_INT 1
67440: PUSH
67441: LD_INT 1
67443: NEG
67444: PUSH
67445: EMPTY
67446: LIST
67447: LIST
67448: PUSH
67449: LD_INT 2
67451: PUSH
67452: LD_INT 0
67454: PUSH
67455: EMPTY
67456: LIST
67457: LIST
67458: PUSH
67459: LD_INT 2
67461: PUSH
67462: LD_INT 1
67464: PUSH
67465: EMPTY
67466: LIST
67467: LIST
67468: PUSH
67469: LD_INT 1
67471: PUSH
67472: LD_INT 2
67474: PUSH
67475: EMPTY
67476: LIST
67477: LIST
67478: PUSH
67479: LD_INT 0
67481: PUSH
67482: LD_INT 2
67484: PUSH
67485: EMPTY
67486: LIST
67487: LIST
67488: PUSH
67489: LD_INT 1
67491: NEG
67492: PUSH
67493: LD_INT 1
67495: PUSH
67496: EMPTY
67497: LIST
67498: LIST
67499: PUSH
67500: LD_INT 2
67502: NEG
67503: PUSH
67504: LD_INT 1
67506: NEG
67507: PUSH
67508: EMPTY
67509: LIST
67510: LIST
67511: PUSH
67512: LD_INT 2
67514: NEG
67515: PUSH
67516: LD_INT 2
67518: NEG
67519: PUSH
67520: EMPTY
67521: LIST
67522: LIST
67523: PUSH
67524: LD_INT 2
67526: NEG
67527: PUSH
67528: LD_INT 3
67530: NEG
67531: PUSH
67532: EMPTY
67533: LIST
67534: LIST
67535: PUSH
67536: LD_INT 2
67538: PUSH
67539: LD_INT 1
67541: NEG
67542: PUSH
67543: EMPTY
67544: LIST
67545: LIST
67546: PUSH
67547: LD_INT 3
67549: PUSH
67550: LD_INT 1
67552: PUSH
67553: EMPTY
67554: LIST
67555: LIST
67556: PUSH
67557: LD_INT 1
67559: PUSH
67560: LD_INT 3
67562: PUSH
67563: EMPTY
67564: LIST
67565: LIST
67566: PUSH
67567: LD_INT 1
67569: NEG
67570: PUSH
67571: LD_INT 2
67573: PUSH
67574: EMPTY
67575: LIST
67576: LIST
67577: PUSH
67578: LD_INT 3
67580: NEG
67581: PUSH
67582: LD_INT 2
67584: NEG
67585: PUSH
67586: EMPTY
67587: LIST
67588: LIST
67589: PUSH
67590: EMPTY
67591: LIST
67592: LIST
67593: LIST
67594: LIST
67595: LIST
67596: LIST
67597: LIST
67598: LIST
67599: LIST
67600: LIST
67601: LIST
67602: LIST
67603: LIST
67604: LIST
67605: LIST
67606: LIST
67607: LIST
67608: LIST
67609: LIST
67610: LIST
67611: LIST
67612: LIST
67613: LIST
67614: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
67615: LD_ADDR_VAR 0 30
67619: PUSH
67620: LD_INT 0
67622: PUSH
67623: LD_INT 0
67625: PUSH
67626: EMPTY
67627: LIST
67628: LIST
67629: PUSH
67630: LD_INT 0
67632: PUSH
67633: LD_INT 1
67635: NEG
67636: PUSH
67637: EMPTY
67638: LIST
67639: LIST
67640: PUSH
67641: LD_INT 1
67643: PUSH
67644: LD_INT 0
67646: PUSH
67647: EMPTY
67648: LIST
67649: LIST
67650: PUSH
67651: LD_INT 1
67653: PUSH
67654: LD_INT 1
67656: PUSH
67657: EMPTY
67658: LIST
67659: LIST
67660: PUSH
67661: LD_INT 0
67663: PUSH
67664: LD_INT 1
67666: PUSH
67667: EMPTY
67668: LIST
67669: LIST
67670: PUSH
67671: LD_INT 1
67673: NEG
67674: PUSH
67675: LD_INT 0
67677: PUSH
67678: EMPTY
67679: LIST
67680: LIST
67681: PUSH
67682: LD_INT 1
67684: NEG
67685: PUSH
67686: LD_INT 1
67688: NEG
67689: PUSH
67690: EMPTY
67691: LIST
67692: LIST
67693: PUSH
67694: LD_INT 1
67696: NEG
67697: PUSH
67698: LD_INT 2
67700: NEG
67701: PUSH
67702: EMPTY
67703: LIST
67704: LIST
67705: PUSH
67706: LD_INT 0
67708: PUSH
67709: LD_INT 2
67711: NEG
67712: PUSH
67713: EMPTY
67714: LIST
67715: LIST
67716: PUSH
67717: LD_INT 1
67719: PUSH
67720: LD_INT 1
67722: NEG
67723: PUSH
67724: EMPTY
67725: LIST
67726: LIST
67727: PUSH
67728: LD_INT 2
67730: PUSH
67731: LD_INT 0
67733: PUSH
67734: EMPTY
67735: LIST
67736: LIST
67737: PUSH
67738: LD_INT 2
67740: PUSH
67741: LD_INT 1
67743: PUSH
67744: EMPTY
67745: LIST
67746: LIST
67747: PUSH
67748: LD_INT 2
67750: PUSH
67751: LD_INT 2
67753: PUSH
67754: EMPTY
67755: LIST
67756: LIST
67757: PUSH
67758: LD_INT 1
67760: PUSH
67761: LD_INT 2
67763: PUSH
67764: EMPTY
67765: LIST
67766: LIST
67767: PUSH
67768: LD_INT 1
67770: NEG
67771: PUSH
67772: LD_INT 1
67774: PUSH
67775: EMPTY
67776: LIST
67777: LIST
67778: PUSH
67779: LD_INT 2
67781: NEG
67782: PUSH
67783: LD_INT 0
67785: PUSH
67786: EMPTY
67787: LIST
67788: LIST
67789: PUSH
67790: LD_INT 2
67792: NEG
67793: PUSH
67794: LD_INT 1
67796: NEG
67797: PUSH
67798: EMPTY
67799: LIST
67800: LIST
67801: PUSH
67802: LD_INT 1
67804: NEG
67805: PUSH
67806: LD_INT 3
67808: NEG
67809: PUSH
67810: EMPTY
67811: LIST
67812: LIST
67813: PUSH
67814: LD_INT 1
67816: PUSH
67817: LD_INT 2
67819: NEG
67820: PUSH
67821: EMPTY
67822: LIST
67823: LIST
67824: PUSH
67825: LD_INT 3
67827: PUSH
67828: LD_INT 2
67830: PUSH
67831: EMPTY
67832: LIST
67833: LIST
67834: PUSH
67835: LD_INT 2
67837: PUSH
67838: LD_INT 3
67840: PUSH
67841: EMPTY
67842: LIST
67843: LIST
67844: PUSH
67845: LD_INT 2
67847: NEG
67848: PUSH
67849: LD_INT 1
67851: PUSH
67852: EMPTY
67853: LIST
67854: LIST
67855: PUSH
67856: LD_INT 3
67858: NEG
67859: PUSH
67860: LD_INT 1
67862: NEG
67863: PUSH
67864: EMPTY
67865: LIST
67866: LIST
67867: PUSH
67868: EMPTY
67869: LIST
67870: LIST
67871: LIST
67872: LIST
67873: LIST
67874: LIST
67875: LIST
67876: LIST
67877: LIST
67878: LIST
67879: LIST
67880: LIST
67881: LIST
67882: LIST
67883: LIST
67884: LIST
67885: LIST
67886: LIST
67887: LIST
67888: LIST
67889: LIST
67890: LIST
67891: LIST
67892: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
67893: LD_ADDR_VAR 0 31
67897: PUSH
67898: LD_INT 0
67900: PUSH
67901: LD_INT 0
67903: PUSH
67904: EMPTY
67905: LIST
67906: LIST
67907: PUSH
67908: LD_INT 0
67910: PUSH
67911: LD_INT 1
67913: NEG
67914: PUSH
67915: EMPTY
67916: LIST
67917: LIST
67918: PUSH
67919: LD_INT 1
67921: PUSH
67922: LD_INT 0
67924: PUSH
67925: EMPTY
67926: LIST
67927: LIST
67928: PUSH
67929: LD_INT 1
67931: PUSH
67932: LD_INT 1
67934: PUSH
67935: EMPTY
67936: LIST
67937: LIST
67938: PUSH
67939: LD_INT 0
67941: PUSH
67942: LD_INT 1
67944: PUSH
67945: EMPTY
67946: LIST
67947: LIST
67948: PUSH
67949: LD_INT 1
67951: NEG
67952: PUSH
67953: LD_INT 0
67955: PUSH
67956: EMPTY
67957: LIST
67958: LIST
67959: PUSH
67960: LD_INT 1
67962: NEG
67963: PUSH
67964: LD_INT 1
67966: NEG
67967: PUSH
67968: EMPTY
67969: LIST
67970: LIST
67971: PUSH
67972: LD_INT 1
67974: NEG
67975: PUSH
67976: LD_INT 2
67978: NEG
67979: PUSH
67980: EMPTY
67981: LIST
67982: LIST
67983: PUSH
67984: LD_INT 1
67986: PUSH
67987: LD_INT 1
67989: NEG
67990: PUSH
67991: EMPTY
67992: LIST
67993: LIST
67994: PUSH
67995: LD_INT 2
67997: PUSH
67998: LD_INT 0
68000: PUSH
68001: EMPTY
68002: LIST
68003: LIST
68004: PUSH
68005: LD_INT 2
68007: PUSH
68008: LD_INT 1
68010: PUSH
68011: EMPTY
68012: LIST
68013: LIST
68014: PUSH
68015: LD_INT 2
68017: PUSH
68018: LD_INT 2
68020: PUSH
68021: EMPTY
68022: LIST
68023: LIST
68024: PUSH
68025: LD_INT 1
68027: PUSH
68028: LD_INT 2
68030: PUSH
68031: EMPTY
68032: LIST
68033: LIST
68034: PUSH
68035: LD_INT 0
68037: PUSH
68038: LD_INT 2
68040: PUSH
68041: EMPTY
68042: LIST
68043: LIST
68044: PUSH
68045: LD_INT 1
68047: NEG
68048: PUSH
68049: LD_INT 1
68051: PUSH
68052: EMPTY
68053: LIST
68054: LIST
68055: PUSH
68056: LD_INT 2
68058: NEG
68059: PUSH
68060: LD_INT 1
68062: NEG
68063: PUSH
68064: EMPTY
68065: LIST
68066: LIST
68067: PUSH
68068: LD_INT 2
68070: NEG
68071: PUSH
68072: LD_INT 2
68074: NEG
68075: PUSH
68076: EMPTY
68077: LIST
68078: LIST
68079: PUSH
68080: LD_INT 2
68082: NEG
68083: PUSH
68084: LD_INT 3
68086: NEG
68087: PUSH
68088: EMPTY
68089: LIST
68090: LIST
68091: PUSH
68092: LD_INT 2
68094: PUSH
68095: LD_INT 1
68097: NEG
68098: PUSH
68099: EMPTY
68100: LIST
68101: LIST
68102: PUSH
68103: LD_INT 3
68105: PUSH
68106: LD_INT 1
68108: PUSH
68109: EMPTY
68110: LIST
68111: LIST
68112: PUSH
68113: LD_INT 1
68115: PUSH
68116: LD_INT 3
68118: PUSH
68119: EMPTY
68120: LIST
68121: LIST
68122: PUSH
68123: LD_INT 1
68125: NEG
68126: PUSH
68127: LD_INT 2
68129: PUSH
68130: EMPTY
68131: LIST
68132: LIST
68133: PUSH
68134: LD_INT 3
68136: NEG
68137: PUSH
68138: LD_INT 2
68140: NEG
68141: PUSH
68142: EMPTY
68143: LIST
68144: LIST
68145: PUSH
68146: EMPTY
68147: LIST
68148: LIST
68149: LIST
68150: LIST
68151: LIST
68152: LIST
68153: LIST
68154: LIST
68155: LIST
68156: LIST
68157: LIST
68158: LIST
68159: LIST
68160: LIST
68161: LIST
68162: LIST
68163: LIST
68164: LIST
68165: LIST
68166: LIST
68167: LIST
68168: LIST
68169: LIST
68170: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
68171: LD_ADDR_VAR 0 32
68175: PUSH
68176: LD_INT 0
68178: PUSH
68179: LD_INT 0
68181: PUSH
68182: EMPTY
68183: LIST
68184: LIST
68185: PUSH
68186: LD_INT 0
68188: PUSH
68189: LD_INT 1
68191: NEG
68192: PUSH
68193: EMPTY
68194: LIST
68195: LIST
68196: PUSH
68197: LD_INT 1
68199: PUSH
68200: LD_INT 0
68202: PUSH
68203: EMPTY
68204: LIST
68205: LIST
68206: PUSH
68207: LD_INT 1
68209: PUSH
68210: LD_INT 1
68212: PUSH
68213: EMPTY
68214: LIST
68215: LIST
68216: PUSH
68217: LD_INT 0
68219: PUSH
68220: LD_INT 1
68222: PUSH
68223: EMPTY
68224: LIST
68225: LIST
68226: PUSH
68227: LD_INT 1
68229: NEG
68230: PUSH
68231: LD_INT 0
68233: PUSH
68234: EMPTY
68235: LIST
68236: LIST
68237: PUSH
68238: LD_INT 1
68240: NEG
68241: PUSH
68242: LD_INT 1
68244: NEG
68245: PUSH
68246: EMPTY
68247: LIST
68248: LIST
68249: PUSH
68250: LD_INT 1
68252: NEG
68253: PUSH
68254: LD_INT 2
68256: NEG
68257: PUSH
68258: EMPTY
68259: LIST
68260: LIST
68261: PUSH
68262: LD_INT 0
68264: PUSH
68265: LD_INT 2
68267: NEG
68268: PUSH
68269: EMPTY
68270: LIST
68271: LIST
68272: PUSH
68273: LD_INT 1
68275: PUSH
68276: LD_INT 1
68278: NEG
68279: PUSH
68280: EMPTY
68281: LIST
68282: LIST
68283: PUSH
68284: LD_INT 2
68286: PUSH
68287: LD_INT 1
68289: PUSH
68290: EMPTY
68291: LIST
68292: LIST
68293: PUSH
68294: LD_INT 2
68296: PUSH
68297: LD_INT 2
68299: PUSH
68300: EMPTY
68301: LIST
68302: LIST
68303: PUSH
68304: LD_INT 1
68306: PUSH
68307: LD_INT 2
68309: PUSH
68310: EMPTY
68311: LIST
68312: LIST
68313: PUSH
68314: LD_INT 0
68316: PUSH
68317: LD_INT 2
68319: PUSH
68320: EMPTY
68321: LIST
68322: LIST
68323: PUSH
68324: LD_INT 1
68326: NEG
68327: PUSH
68328: LD_INT 1
68330: PUSH
68331: EMPTY
68332: LIST
68333: LIST
68334: PUSH
68335: LD_INT 2
68337: NEG
68338: PUSH
68339: LD_INT 0
68341: PUSH
68342: EMPTY
68343: LIST
68344: LIST
68345: PUSH
68346: LD_INT 2
68348: NEG
68349: PUSH
68350: LD_INT 1
68352: NEG
68353: PUSH
68354: EMPTY
68355: LIST
68356: LIST
68357: PUSH
68358: LD_INT 1
68360: NEG
68361: PUSH
68362: LD_INT 3
68364: NEG
68365: PUSH
68366: EMPTY
68367: LIST
68368: LIST
68369: PUSH
68370: LD_INT 1
68372: PUSH
68373: LD_INT 2
68375: NEG
68376: PUSH
68377: EMPTY
68378: LIST
68379: LIST
68380: PUSH
68381: LD_INT 3
68383: PUSH
68384: LD_INT 2
68386: PUSH
68387: EMPTY
68388: LIST
68389: LIST
68390: PUSH
68391: LD_INT 2
68393: PUSH
68394: LD_INT 3
68396: PUSH
68397: EMPTY
68398: LIST
68399: LIST
68400: PUSH
68401: LD_INT 2
68403: NEG
68404: PUSH
68405: LD_INT 1
68407: PUSH
68408: EMPTY
68409: LIST
68410: LIST
68411: PUSH
68412: LD_INT 3
68414: NEG
68415: PUSH
68416: LD_INT 1
68418: NEG
68419: PUSH
68420: EMPTY
68421: LIST
68422: LIST
68423: PUSH
68424: EMPTY
68425: LIST
68426: LIST
68427: LIST
68428: LIST
68429: LIST
68430: LIST
68431: LIST
68432: LIST
68433: LIST
68434: LIST
68435: LIST
68436: LIST
68437: LIST
68438: LIST
68439: LIST
68440: LIST
68441: LIST
68442: LIST
68443: LIST
68444: LIST
68445: LIST
68446: LIST
68447: LIST
68448: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
68449: LD_ADDR_VAR 0 33
68453: PUSH
68454: LD_INT 0
68456: PUSH
68457: LD_INT 0
68459: PUSH
68460: EMPTY
68461: LIST
68462: LIST
68463: PUSH
68464: LD_INT 0
68466: PUSH
68467: LD_INT 1
68469: NEG
68470: PUSH
68471: EMPTY
68472: LIST
68473: LIST
68474: PUSH
68475: LD_INT 1
68477: PUSH
68478: LD_INT 0
68480: PUSH
68481: EMPTY
68482: LIST
68483: LIST
68484: PUSH
68485: LD_INT 1
68487: PUSH
68488: LD_INT 1
68490: PUSH
68491: EMPTY
68492: LIST
68493: LIST
68494: PUSH
68495: LD_INT 0
68497: PUSH
68498: LD_INT 1
68500: PUSH
68501: EMPTY
68502: LIST
68503: LIST
68504: PUSH
68505: LD_INT 1
68507: NEG
68508: PUSH
68509: LD_INT 0
68511: PUSH
68512: EMPTY
68513: LIST
68514: LIST
68515: PUSH
68516: LD_INT 1
68518: NEG
68519: PUSH
68520: LD_INT 1
68522: NEG
68523: PUSH
68524: EMPTY
68525: LIST
68526: LIST
68527: PUSH
68528: LD_INT 1
68530: NEG
68531: PUSH
68532: LD_INT 2
68534: NEG
68535: PUSH
68536: EMPTY
68537: LIST
68538: LIST
68539: PUSH
68540: LD_INT 1
68542: PUSH
68543: LD_INT 1
68545: NEG
68546: PUSH
68547: EMPTY
68548: LIST
68549: LIST
68550: PUSH
68551: LD_INT 2
68553: PUSH
68554: LD_INT 0
68556: PUSH
68557: EMPTY
68558: LIST
68559: LIST
68560: PUSH
68561: LD_INT 2
68563: PUSH
68564: LD_INT 1
68566: PUSH
68567: EMPTY
68568: LIST
68569: LIST
68570: PUSH
68571: LD_INT 1
68573: PUSH
68574: LD_INT 2
68576: PUSH
68577: EMPTY
68578: LIST
68579: LIST
68580: PUSH
68581: LD_INT 0
68583: PUSH
68584: LD_INT 2
68586: PUSH
68587: EMPTY
68588: LIST
68589: LIST
68590: PUSH
68591: LD_INT 1
68593: NEG
68594: PUSH
68595: LD_INT 1
68597: PUSH
68598: EMPTY
68599: LIST
68600: LIST
68601: PUSH
68602: LD_INT 2
68604: NEG
68605: PUSH
68606: LD_INT 0
68608: PUSH
68609: EMPTY
68610: LIST
68611: LIST
68612: PUSH
68613: LD_INT 2
68615: NEG
68616: PUSH
68617: LD_INT 1
68619: NEG
68620: PUSH
68621: EMPTY
68622: LIST
68623: LIST
68624: PUSH
68625: LD_INT 2
68627: NEG
68628: PUSH
68629: LD_INT 2
68631: NEG
68632: PUSH
68633: EMPTY
68634: LIST
68635: LIST
68636: PUSH
68637: LD_INT 2
68639: NEG
68640: PUSH
68641: LD_INT 3
68643: NEG
68644: PUSH
68645: EMPTY
68646: LIST
68647: LIST
68648: PUSH
68649: LD_INT 2
68651: PUSH
68652: LD_INT 1
68654: NEG
68655: PUSH
68656: EMPTY
68657: LIST
68658: LIST
68659: PUSH
68660: LD_INT 3
68662: PUSH
68663: LD_INT 1
68665: PUSH
68666: EMPTY
68667: LIST
68668: LIST
68669: PUSH
68670: LD_INT 1
68672: PUSH
68673: LD_INT 3
68675: PUSH
68676: EMPTY
68677: LIST
68678: LIST
68679: PUSH
68680: LD_INT 1
68682: NEG
68683: PUSH
68684: LD_INT 2
68686: PUSH
68687: EMPTY
68688: LIST
68689: LIST
68690: PUSH
68691: LD_INT 3
68693: NEG
68694: PUSH
68695: LD_INT 2
68697: NEG
68698: PUSH
68699: EMPTY
68700: LIST
68701: LIST
68702: PUSH
68703: EMPTY
68704: LIST
68705: LIST
68706: LIST
68707: LIST
68708: LIST
68709: LIST
68710: LIST
68711: LIST
68712: LIST
68713: LIST
68714: LIST
68715: LIST
68716: LIST
68717: LIST
68718: LIST
68719: LIST
68720: LIST
68721: LIST
68722: LIST
68723: LIST
68724: LIST
68725: LIST
68726: LIST
68727: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
68728: LD_ADDR_VAR 0 34
68732: PUSH
68733: LD_INT 0
68735: PUSH
68736: LD_INT 0
68738: PUSH
68739: EMPTY
68740: LIST
68741: LIST
68742: PUSH
68743: LD_INT 0
68745: PUSH
68746: LD_INT 1
68748: NEG
68749: PUSH
68750: EMPTY
68751: LIST
68752: LIST
68753: PUSH
68754: LD_INT 1
68756: PUSH
68757: LD_INT 0
68759: PUSH
68760: EMPTY
68761: LIST
68762: LIST
68763: PUSH
68764: LD_INT 1
68766: PUSH
68767: LD_INT 1
68769: PUSH
68770: EMPTY
68771: LIST
68772: LIST
68773: PUSH
68774: LD_INT 0
68776: PUSH
68777: LD_INT 1
68779: PUSH
68780: EMPTY
68781: LIST
68782: LIST
68783: PUSH
68784: LD_INT 1
68786: NEG
68787: PUSH
68788: LD_INT 0
68790: PUSH
68791: EMPTY
68792: LIST
68793: LIST
68794: PUSH
68795: LD_INT 1
68797: NEG
68798: PUSH
68799: LD_INT 1
68801: NEG
68802: PUSH
68803: EMPTY
68804: LIST
68805: LIST
68806: PUSH
68807: LD_INT 1
68809: NEG
68810: PUSH
68811: LD_INT 2
68813: NEG
68814: PUSH
68815: EMPTY
68816: LIST
68817: LIST
68818: PUSH
68819: LD_INT 0
68821: PUSH
68822: LD_INT 2
68824: NEG
68825: PUSH
68826: EMPTY
68827: LIST
68828: LIST
68829: PUSH
68830: LD_INT 1
68832: PUSH
68833: LD_INT 1
68835: NEG
68836: PUSH
68837: EMPTY
68838: LIST
68839: LIST
68840: PUSH
68841: LD_INT 2
68843: PUSH
68844: LD_INT 1
68846: PUSH
68847: EMPTY
68848: LIST
68849: LIST
68850: PUSH
68851: LD_INT 2
68853: PUSH
68854: LD_INT 2
68856: PUSH
68857: EMPTY
68858: LIST
68859: LIST
68860: PUSH
68861: LD_INT 1
68863: PUSH
68864: LD_INT 2
68866: PUSH
68867: EMPTY
68868: LIST
68869: LIST
68870: PUSH
68871: LD_INT 1
68873: NEG
68874: PUSH
68875: LD_INT 1
68877: PUSH
68878: EMPTY
68879: LIST
68880: LIST
68881: PUSH
68882: LD_INT 2
68884: NEG
68885: PUSH
68886: LD_INT 0
68888: PUSH
68889: EMPTY
68890: LIST
68891: LIST
68892: PUSH
68893: LD_INT 2
68895: NEG
68896: PUSH
68897: LD_INT 1
68899: NEG
68900: PUSH
68901: EMPTY
68902: LIST
68903: LIST
68904: PUSH
68905: LD_INT 2
68907: NEG
68908: PUSH
68909: LD_INT 2
68911: NEG
68912: PUSH
68913: EMPTY
68914: LIST
68915: LIST
68916: PUSH
68917: LD_INT 1
68919: NEG
68920: PUSH
68921: LD_INT 3
68923: NEG
68924: PUSH
68925: EMPTY
68926: LIST
68927: LIST
68928: PUSH
68929: LD_INT 1
68931: PUSH
68932: LD_INT 2
68934: NEG
68935: PUSH
68936: EMPTY
68937: LIST
68938: LIST
68939: PUSH
68940: LD_INT 3
68942: PUSH
68943: LD_INT 2
68945: PUSH
68946: EMPTY
68947: LIST
68948: LIST
68949: PUSH
68950: LD_INT 2
68952: PUSH
68953: LD_INT 3
68955: PUSH
68956: EMPTY
68957: LIST
68958: LIST
68959: PUSH
68960: LD_INT 2
68962: NEG
68963: PUSH
68964: LD_INT 1
68966: PUSH
68967: EMPTY
68968: LIST
68969: LIST
68970: PUSH
68971: LD_INT 3
68973: NEG
68974: PUSH
68975: LD_INT 1
68977: NEG
68978: PUSH
68979: EMPTY
68980: LIST
68981: LIST
68982: PUSH
68983: EMPTY
68984: LIST
68985: LIST
68986: LIST
68987: LIST
68988: LIST
68989: LIST
68990: LIST
68991: LIST
68992: LIST
68993: LIST
68994: LIST
68995: LIST
68996: LIST
68997: LIST
68998: LIST
68999: LIST
69000: LIST
69001: LIST
69002: LIST
69003: LIST
69004: LIST
69005: LIST
69006: LIST
69007: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
69008: LD_ADDR_VAR 0 35
69012: PUSH
69013: LD_INT 0
69015: PUSH
69016: LD_INT 0
69018: PUSH
69019: EMPTY
69020: LIST
69021: LIST
69022: PUSH
69023: LD_INT 0
69025: PUSH
69026: LD_INT 1
69028: NEG
69029: PUSH
69030: EMPTY
69031: LIST
69032: LIST
69033: PUSH
69034: LD_INT 1
69036: PUSH
69037: LD_INT 0
69039: PUSH
69040: EMPTY
69041: LIST
69042: LIST
69043: PUSH
69044: LD_INT 1
69046: PUSH
69047: LD_INT 1
69049: PUSH
69050: EMPTY
69051: LIST
69052: LIST
69053: PUSH
69054: LD_INT 0
69056: PUSH
69057: LD_INT 1
69059: PUSH
69060: EMPTY
69061: LIST
69062: LIST
69063: PUSH
69064: LD_INT 1
69066: NEG
69067: PUSH
69068: LD_INT 0
69070: PUSH
69071: EMPTY
69072: LIST
69073: LIST
69074: PUSH
69075: LD_INT 1
69077: NEG
69078: PUSH
69079: LD_INT 1
69081: NEG
69082: PUSH
69083: EMPTY
69084: LIST
69085: LIST
69086: PUSH
69087: LD_INT 2
69089: PUSH
69090: LD_INT 1
69092: PUSH
69093: EMPTY
69094: LIST
69095: LIST
69096: PUSH
69097: LD_INT 2
69099: NEG
69100: PUSH
69101: LD_INT 1
69103: NEG
69104: PUSH
69105: EMPTY
69106: LIST
69107: LIST
69108: PUSH
69109: EMPTY
69110: LIST
69111: LIST
69112: LIST
69113: LIST
69114: LIST
69115: LIST
69116: LIST
69117: LIST
69118: LIST
69119: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
69120: LD_ADDR_VAR 0 36
69124: PUSH
69125: LD_INT 0
69127: PUSH
69128: LD_INT 0
69130: PUSH
69131: EMPTY
69132: LIST
69133: LIST
69134: PUSH
69135: LD_INT 0
69137: PUSH
69138: LD_INT 1
69140: NEG
69141: PUSH
69142: EMPTY
69143: LIST
69144: LIST
69145: PUSH
69146: LD_INT 1
69148: PUSH
69149: LD_INT 0
69151: PUSH
69152: EMPTY
69153: LIST
69154: LIST
69155: PUSH
69156: LD_INT 1
69158: PUSH
69159: LD_INT 1
69161: PUSH
69162: EMPTY
69163: LIST
69164: LIST
69165: PUSH
69166: LD_INT 0
69168: PUSH
69169: LD_INT 1
69171: PUSH
69172: EMPTY
69173: LIST
69174: LIST
69175: PUSH
69176: LD_INT 1
69178: NEG
69179: PUSH
69180: LD_INT 0
69182: PUSH
69183: EMPTY
69184: LIST
69185: LIST
69186: PUSH
69187: LD_INT 1
69189: NEG
69190: PUSH
69191: LD_INT 1
69193: NEG
69194: PUSH
69195: EMPTY
69196: LIST
69197: LIST
69198: PUSH
69199: LD_INT 1
69201: NEG
69202: PUSH
69203: LD_INT 2
69205: NEG
69206: PUSH
69207: EMPTY
69208: LIST
69209: LIST
69210: PUSH
69211: LD_INT 1
69213: PUSH
69214: LD_INT 2
69216: PUSH
69217: EMPTY
69218: LIST
69219: LIST
69220: PUSH
69221: EMPTY
69222: LIST
69223: LIST
69224: LIST
69225: LIST
69226: LIST
69227: LIST
69228: LIST
69229: LIST
69230: LIST
69231: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
69232: LD_ADDR_VAR 0 37
69236: PUSH
69237: LD_INT 0
69239: PUSH
69240: LD_INT 0
69242: PUSH
69243: EMPTY
69244: LIST
69245: LIST
69246: PUSH
69247: LD_INT 0
69249: PUSH
69250: LD_INT 1
69252: NEG
69253: PUSH
69254: EMPTY
69255: LIST
69256: LIST
69257: PUSH
69258: LD_INT 1
69260: PUSH
69261: LD_INT 0
69263: PUSH
69264: EMPTY
69265: LIST
69266: LIST
69267: PUSH
69268: LD_INT 1
69270: PUSH
69271: LD_INT 1
69273: PUSH
69274: EMPTY
69275: LIST
69276: LIST
69277: PUSH
69278: LD_INT 0
69280: PUSH
69281: LD_INT 1
69283: PUSH
69284: EMPTY
69285: LIST
69286: LIST
69287: PUSH
69288: LD_INT 1
69290: NEG
69291: PUSH
69292: LD_INT 0
69294: PUSH
69295: EMPTY
69296: LIST
69297: LIST
69298: PUSH
69299: LD_INT 1
69301: NEG
69302: PUSH
69303: LD_INT 1
69305: NEG
69306: PUSH
69307: EMPTY
69308: LIST
69309: LIST
69310: PUSH
69311: LD_INT 1
69313: PUSH
69314: LD_INT 1
69316: NEG
69317: PUSH
69318: EMPTY
69319: LIST
69320: LIST
69321: PUSH
69322: LD_INT 1
69324: NEG
69325: PUSH
69326: LD_INT 1
69328: PUSH
69329: EMPTY
69330: LIST
69331: LIST
69332: PUSH
69333: EMPTY
69334: LIST
69335: LIST
69336: LIST
69337: LIST
69338: LIST
69339: LIST
69340: LIST
69341: LIST
69342: LIST
69343: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
69344: LD_ADDR_VAR 0 38
69348: PUSH
69349: LD_INT 0
69351: PUSH
69352: LD_INT 0
69354: PUSH
69355: EMPTY
69356: LIST
69357: LIST
69358: PUSH
69359: LD_INT 0
69361: PUSH
69362: LD_INT 1
69364: NEG
69365: PUSH
69366: EMPTY
69367: LIST
69368: LIST
69369: PUSH
69370: LD_INT 1
69372: PUSH
69373: LD_INT 0
69375: PUSH
69376: EMPTY
69377: LIST
69378: LIST
69379: PUSH
69380: LD_INT 1
69382: PUSH
69383: LD_INT 1
69385: PUSH
69386: EMPTY
69387: LIST
69388: LIST
69389: PUSH
69390: LD_INT 0
69392: PUSH
69393: LD_INT 1
69395: PUSH
69396: EMPTY
69397: LIST
69398: LIST
69399: PUSH
69400: LD_INT 1
69402: NEG
69403: PUSH
69404: LD_INT 0
69406: PUSH
69407: EMPTY
69408: LIST
69409: LIST
69410: PUSH
69411: LD_INT 1
69413: NEG
69414: PUSH
69415: LD_INT 1
69417: NEG
69418: PUSH
69419: EMPTY
69420: LIST
69421: LIST
69422: PUSH
69423: LD_INT 2
69425: PUSH
69426: LD_INT 1
69428: PUSH
69429: EMPTY
69430: LIST
69431: LIST
69432: PUSH
69433: LD_INT 2
69435: NEG
69436: PUSH
69437: LD_INT 1
69439: NEG
69440: PUSH
69441: EMPTY
69442: LIST
69443: LIST
69444: PUSH
69445: EMPTY
69446: LIST
69447: LIST
69448: LIST
69449: LIST
69450: LIST
69451: LIST
69452: LIST
69453: LIST
69454: LIST
69455: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
69456: LD_ADDR_VAR 0 39
69460: PUSH
69461: LD_INT 0
69463: PUSH
69464: LD_INT 0
69466: PUSH
69467: EMPTY
69468: LIST
69469: LIST
69470: PUSH
69471: LD_INT 0
69473: PUSH
69474: LD_INT 1
69476: NEG
69477: PUSH
69478: EMPTY
69479: LIST
69480: LIST
69481: PUSH
69482: LD_INT 1
69484: PUSH
69485: LD_INT 0
69487: PUSH
69488: EMPTY
69489: LIST
69490: LIST
69491: PUSH
69492: LD_INT 1
69494: PUSH
69495: LD_INT 1
69497: PUSH
69498: EMPTY
69499: LIST
69500: LIST
69501: PUSH
69502: LD_INT 0
69504: PUSH
69505: LD_INT 1
69507: PUSH
69508: EMPTY
69509: LIST
69510: LIST
69511: PUSH
69512: LD_INT 1
69514: NEG
69515: PUSH
69516: LD_INT 0
69518: PUSH
69519: EMPTY
69520: LIST
69521: LIST
69522: PUSH
69523: LD_INT 1
69525: NEG
69526: PUSH
69527: LD_INT 1
69529: NEG
69530: PUSH
69531: EMPTY
69532: LIST
69533: LIST
69534: PUSH
69535: LD_INT 1
69537: NEG
69538: PUSH
69539: LD_INT 2
69541: NEG
69542: PUSH
69543: EMPTY
69544: LIST
69545: LIST
69546: PUSH
69547: LD_INT 1
69549: PUSH
69550: LD_INT 2
69552: PUSH
69553: EMPTY
69554: LIST
69555: LIST
69556: PUSH
69557: EMPTY
69558: LIST
69559: LIST
69560: LIST
69561: LIST
69562: LIST
69563: LIST
69564: LIST
69565: LIST
69566: LIST
69567: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
69568: LD_ADDR_VAR 0 40
69572: PUSH
69573: LD_INT 0
69575: PUSH
69576: LD_INT 0
69578: PUSH
69579: EMPTY
69580: LIST
69581: LIST
69582: PUSH
69583: LD_INT 0
69585: PUSH
69586: LD_INT 1
69588: NEG
69589: PUSH
69590: EMPTY
69591: LIST
69592: LIST
69593: PUSH
69594: LD_INT 1
69596: PUSH
69597: LD_INT 0
69599: PUSH
69600: EMPTY
69601: LIST
69602: LIST
69603: PUSH
69604: LD_INT 1
69606: PUSH
69607: LD_INT 1
69609: PUSH
69610: EMPTY
69611: LIST
69612: LIST
69613: PUSH
69614: LD_INT 0
69616: PUSH
69617: LD_INT 1
69619: PUSH
69620: EMPTY
69621: LIST
69622: LIST
69623: PUSH
69624: LD_INT 1
69626: NEG
69627: PUSH
69628: LD_INT 0
69630: PUSH
69631: EMPTY
69632: LIST
69633: LIST
69634: PUSH
69635: LD_INT 1
69637: NEG
69638: PUSH
69639: LD_INT 1
69641: NEG
69642: PUSH
69643: EMPTY
69644: LIST
69645: LIST
69646: PUSH
69647: LD_INT 1
69649: PUSH
69650: LD_INT 1
69652: NEG
69653: PUSH
69654: EMPTY
69655: LIST
69656: LIST
69657: PUSH
69658: LD_INT 1
69660: NEG
69661: PUSH
69662: LD_INT 1
69664: PUSH
69665: EMPTY
69666: LIST
69667: LIST
69668: PUSH
69669: EMPTY
69670: LIST
69671: LIST
69672: LIST
69673: LIST
69674: LIST
69675: LIST
69676: LIST
69677: LIST
69678: LIST
69679: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
69680: LD_ADDR_VAR 0 41
69684: PUSH
69685: LD_INT 0
69687: PUSH
69688: LD_INT 0
69690: PUSH
69691: EMPTY
69692: LIST
69693: LIST
69694: PUSH
69695: LD_INT 0
69697: PUSH
69698: LD_INT 1
69700: NEG
69701: PUSH
69702: EMPTY
69703: LIST
69704: LIST
69705: PUSH
69706: LD_INT 1
69708: PUSH
69709: LD_INT 0
69711: PUSH
69712: EMPTY
69713: LIST
69714: LIST
69715: PUSH
69716: LD_INT 1
69718: PUSH
69719: LD_INT 1
69721: PUSH
69722: EMPTY
69723: LIST
69724: LIST
69725: PUSH
69726: LD_INT 0
69728: PUSH
69729: LD_INT 1
69731: PUSH
69732: EMPTY
69733: LIST
69734: LIST
69735: PUSH
69736: LD_INT 1
69738: NEG
69739: PUSH
69740: LD_INT 0
69742: PUSH
69743: EMPTY
69744: LIST
69745: LIST
69746: PUSH
69747: LD_INT 1
69749: NEG
69750: PUSH
69751: LD_INT 1
69753: NEG
69754: PUSH
69755: EMPTY
69756: LIST
69757: LIST
69758: PUSH
69759: LD_INT 1
69761: NEG
69762: PUSH
69763: LD_INT 2
69765: NEG
69766: PUSH
69767: EMPTY
69768: LIST
69769: LIST
69770: PUSH
69771: LD_INT 1
69773: PUSH
69774: LD_INT 1
69776: NEG
69777: PUSH
69778: EMPTY
69779: LIST
69780: LIST
69781: PUSH
69782: LD_INT 2
69784: PUSH
69785: LD_INT 0
69787: PUSH
69788: EMPTY
69789: LIST
69790: LIST
69791: PUSH
69792: LD_INT 2
69794: PUSH
69795: LD_INT 1
69797: PUSH
69798: EMPTY
69799: LIST
69800: LIST
69801: PUSH
69802: LD_INT 2
69804: PUSH
69805: LD_INT 2
69807: PUSH
69808: EMPTY
69809: LIST
69810: LIST
69811: PUSH
69812: LD_INT 1
69814: PUSH
69815: LD_INT 2
69817: PUSH
69818: EMPTY
69819: LIST
69820: LIST
69821: PUSH
69822: LD_INT 1
69824: NEG
69825: PUSH
69826: LD_INT 1
69828: PUSH
69829: EMPTY
69830: LIST
69831: LIST
69832: PUSH
69833: LD_INT 2
69835: NEG
69836: PUSH
69837: LD_INT 0
69839: PUSH
69840: EMPTY
69841: LIST
69842: LIST
69843: PUSH
69844: LD_INT 2
69846: NEG
69847: PUSH
69848: LD_INT 1
69850: NEG
69851: PUSH
69852: EMPTY
69853: LIST
69854: LIST
69855: PUSH
69856: LD_INT 2
69858: NEG
69859: PUSH
69860: LD_INT 2
69862: NEG
69863: PUSH
69864: EMPTY
69865: LIST
69866: LIST
69867: PUSH
69868: LD_INT 2
69870: NEG
69871: PUSH
69872: LD_INT 3
69874: NEG
69875: PUSH
69876: EMPTY
69877: LIST
69878: LIST
69879: PUSH
69880: LD_INT 2
69882: PUSH
69883: LD_INT 1
69885: NEG
69886: PUSH
69887: EMPTY
69888: LIST
69889: LIST
69890: PUSH
69891: LD_INT 3
69893: PUSH
69894: LD_INT 0
69896: PUSH
69897: EMPTY
69898: LIST
69899: LIST
69900: PUSH
69901: LD_INT 3
69903: PUSH
69904: LD_INT 1
69906: PUSH
69907: EMPTY
69908: LIST
69909: LIST
69910: PUSH
69911: LD_INT 3
69913: PUSH
69914: LD_INT 2
69916: PUSH
69917: EMPTY
69918: LIST
69919: LIST
69920: PUSH
69921: LD_INT 3
69923: PUSH
69924: LD_INT 3
69926: PUSH
69927: EMPTY
69928: LIST
69929: LIST
69930: PUSH
69931: LD_INT 2
69933: PUSH
69934: LD_INT 3
69936: PUSH
69937: EMPTY
69938: LIST
69939: LIST
69940: PUSH
69941: LD_INT 2
69943: NEG
69944: PUSH
69945: LD_INT 1
69947: PUSH
69948: EMPTY
69949: LIST
69950: LIST
69951: PUSH
69952: LD_INT 3
69954: NEG
69955: PUSH
69956: LD_INT 0
69958: PUSH
69959: EMPTY
69960: LIST
69961: LIST
69962: PUSH
69963: LD_INT 3
69965: NEG
69966: PUSH
69967: LD_INT 1
69969: NEG
69970: PUSH
69971: EMPTY
69972: LIST
69973: LIST
69974: PUSH
69975: LD_INT 3
69977: NEG
69978: PUSH
69979: LD_INT 2
69981: NEG
69982: PUSH
69983: EMPTY
69984: LIST
69985: LIST
69986: PUSH
69987: LD_INT 3
69989: NEG
69990: PUSH
69991: LD_INT 3
69993: NEG
69994: PUSH
69995: EMPTY
69996: LIST
69997: LIST
69998: PUSH
69999: EMPTY
70000: LIST
70001: LIST
70002: LIST
70003: LIST
70004: LIST
70005: LIST
70006: LIST
70007: LIST
70008: LIST
70009: LIST
70010: LIST
70011: LIST
70012: LIST
70013: LIST
70014: LIST
70015: LIST
70016: LIST
70017: LIST
70018: LIST
70019: LIST
70020: LIST
70021: LIST
70022: LIST
70023: LIST
70024: LIST
70025: LIST
70026: LIST
70027: LIST
70028: LIST
70029: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70030: LD_ADDR_VAR 0 42
70034: PUSH
70035: LD_INT 0
70037: PUSH
70038: LD_INT 0
70040: PUSH
70041: EMPTY
70042: LIST
70043: LIST
70044: PUSH
70045: LD_INT 0
70047: PUSH
70048: LD_INT 1
70050: NEG
70051: PUSH
70052: EMPTY
70053: LIST
70054: LIST
70055: PUSH
70056: LD_INT 1
70058: PUSH
70059: LD_INT 0
70061: PUSH
70062: EMPTY
70063: LIST
70064: LIST
70065: PUSH
70066: LD_INT 1
70068: PUSH
70069: LD_INT 1
70071: PUSH
70072: EMPTY
70073: LIST
70074: LIST
70075: PUSH
70076: LD_INT 0
70078: PUSH
70079: LD_INT 1
70081: PUSH
70082: EMPTY
70083: LIST
70084: LIST
70085: PUSH
70086: LD_INT 1
70088: NEG
70089: PUSH
70090: LD_INT 0
70092: PUSH
70093: EMPTY
70094: LIST
70095: LIST
70096: PUSH
70097: LD_INT 1
70099: NEG
70100: PUSH
70101: LD_INT 1
70103: NEG
70104: PUSH
70105: EMPTY
70106: LIST
70107: LIST
70108: PUSH
70109: LD_INT 1
70111: NEG
70112: PUSH
70113: LD_INT 2
70115: NEG
70116: PUSH
70117: EMPTY
70118: LIST
70119: LIST
70120: PUSH
70121: LD_INT 0
70123: PUSH
70124: LD_INT 2
70126: NEG
70127: PUSH
70128: EMPTY
70129: LIST
70130: LIST
70131: PUSH
70132: LD_INT 1
70134: PUSH
70135: LD_INT 1
70137: NEG
70138: PUSH
70139: EMPTY
70140: LIST
70141: LIST
70142: PUSH
70143: LD_INT 2
70145: PUSH
70146: LD_INT 1
70148: PUSH
70149: EMPTY
70150: LIST
70151: LIST
70152: PUSH
70153: LD_INT 2
70155: PUSH
70156: LD_INT 2
70158: PUSH
70159: EMPTY
70160: LIST
70161: LIST
70162: PUSH
70163: LD_INT 1
70165: PUSH
70166: LD_INT 2
70168: PUSH
70169: EMPTY
70170: LIST
70171: LIST
70172: PUSH
70173: LD_INT 0
70175: PUSH
70176: LD_INT 2
70178: PUSH
70179: EMPTY
70180: LIST
70181: LIST
70182: PUSH
70183: LD_INT 1
70185: NEG
70186: PUSH
70187: LD_INT 1
70189: PUSH
70190: EMPTY
70191: LIST
70192: LIST
70193: PUSH
70194: LD_INT 2
70196: NEG
70197: PUSH
70198: LD_INT 1
70200: NEG
70201: PUSH
70202: EMPTY
70203: LIST
70204: LIST
70205: PUSH
70206: LD_INT 2
70208: NEG
70209: PUSH
70210: LD_INT 2
70212: NEG
70213: PUSH
70214: EMPTY
70215: LIST
70216: LIST
70217: PUSH
70218: LD_INT 2
70220: NEG
70221: PUSH
70222: LD_INT 3
70224: NEG
70225: PUSH
70226: EMPTY
70227: LIST
70228: LIST
70229: PUSH
70230: LD_INT 1
70232: NEG
70233: PUSH
70234: LD_INT 3
70236: NEG
70237: PUSH
70238: EMPTY
70239: LIST
70240: LIST
70241: PUSH
70242: LD_INT 0
70244: PUSH
70245: LD_INT 3
70247: NEG
70248: PUSH
70249: EMPTY
70250: LIST
70251: LIST
70252: PUSH
70253: LD_INT 1
70255: PUSH
70256: LD_INT 2
70258: NEG
70259: PUSH
70260: EMPTY
70261: LIST
70262: LIST
70263: PUSH
70264: LD_INT 3
70266: PUSH
70267: LD_INT 2
70269: PUSH
70270: EMPTY
70271: LIST
70272: LIST
70273: PUSH
70274: LD_INT 3
70276: PUSH
70277: LD_INT 3
70279: PUSH
70280: EMPTY
70281: LIST
70282: LIST
70283: PUSH
70284: LD_INT 2
70286: PUSH
70287: LD_INT 3
70289: PUSH
70290: EMPTY
70291: LIST
70292: LIST
70293: PUSH
70294: LD_INT 1
70296: PUSH
70297: LD_INT 3
70299: PUSH
70300: EMPTY
70301: LIST
70302: LIST
70303: PUSH
70304: LD_INT 0
70306: PUSH
70307: LD_INT 3
70309: PUSH
70310: EMPTY
70311: LIST
70312: LIST
70313: PUSH
70314: LD_INT 1
70316: NEG
70317: PUSH
70318: LD_INT 2
70320: PUSH
70321: EMPTY
70322: LIST
70323: LIST
70324: PUSH
70325: LD_INT 3
70327: NEG
70328: PUSH
70329: LD_INT 2
70331: NEG
70332: PUSH
70333: EMPTY
70334: LIST
70335: LIST
70336: PUSH
70337: LD_INT 3
70339: NEG
70340: PUSH
70341: LD_INT 3
70343: NEG
70344: PUSH
70345: EMPTY
70346: LIST
70347: LIST
70348: PUSH
70349: EMPTY
70350: LIST
70351: LIST
70352: LIST
70353: LIST
70354: LIST
70355: LIST
70356: LIST
70357: LIST
70358: LIST
70359: LIST
70360: LIST
70361: LIST
70362: LIST
70363: LIST
70364: LIST
70365: LIST
70366: LIST
70367: LIST
70368: LIST
70369: LIST
70370: LIST
70371: LIST
70372: LIST
70373: LIST
70374: LIST
70375: LIST
70376: LIST
70377: LIST
70378: LIST
70379: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
70380: LD_ADDR_VAR 0 43
70384: PUSH
70385: LD_INT 0
70387: PUSH
70388: LD_INT 0
70390: PUSH
70391: EMPTY
70392: LIST
70393: LIST
70394: PUSH
70395: LD_INT 0
70397: PUSH
70398: LD_INT 1
70400: NEG
70401: PUSH
70402: EMPTY
70403: LIST
70404: LIST
70405: PUSH
70406: LD_INT 1
70408: PUSH
70409: LD_INT 0
70411: PUSH
70412: EMPTY
70413: LIST
70414: LIST
70415: PUSH
70416: LD_INT 1
70418: PUSH
70419: LD_INT 1
70421: PUSH
70422: EMPTY
70423: LIST
70424: LIST
70425: PUSH
70426: LD_INT 0
70428: PUSH
70429: LD_INT 1
70431: PUSH
70432: EMPTY
70433: LIST
70434: LIST
70435: PUSH
70436: LD_INT 1
70438: NEG
70439: PUSH
70440: LD_INT 0
70442: PUSH
70443: EMPTY
70444: LIST
70445: LIST
70446: PUSH
70447: LD_INT 1
70449: NEG
70450: PUSH
70451: LD_INT 1
70453: NEG
70454: PUSH
70455: EMPTY
70456: LIST
70457: LIST
70458: PUSH
70459: LD_INT 1
70461: NEG
70462: PUSH
70463: LD_INT 2
70465: NEG
70466: PUSH
70467: EMPTY
70468: LIST
70469: LIST
70470: PUSH
70471: LD_INT 0
70473: PUSH
70474: LD_INT 2
70476: NEG
70477: PUSH
70478: EMPTY
70479: LIST
70480: LIST
70481: PUSH
70482: LD_INT 1
70484: PUSH
70485: LD_INT 1
70487: NEG
70488: PUSH
70489: EMPTY
70490: LIST
70491: LIST
70492: PUSH
70493: LD_INT 2
70495: PUSH
70496: LD_INT 0
70498: PUSH
70499: EMPTY
70500: LIST
70501: LIST
70502: PUSH
70503: LD_INT 2
70505: PUSH
70506: LD_INT 1
70508: PUSH
70509: EMPTY
70510: LIST
70511: LIST
70512: PUSH
70513: LD_INT 1
70515: PUSH
70516: LD_INT 2
70518: PUSH
70519: EMPTY
70520: LIST
70521: LIST
70522: PUSH
70523: LD_INT 0
70525: PUSH
70526: LD_INT 2
70528: PUSH
70529: EMPTY
70530: LIST
70531: LIST
70532: PUSH
70533: LD_INT 1
70535: NEG
70536: PUSH
70537: LD_INT 1
70539: PUSH
70540: EMPTY
70541: LIST
70542: LIST
70543: PUSH
70544: LD_INT 2
70546: NEG
70547: PUSH
70548: LD_INT 0
70550: PUSH
70551: EMPTY
70552: LIST
70553: LIST
70554: PUSH
70555: LD_INT 2
70557: NEG
70558: PUSH
70559: LD_INT 1
70561: NEG
70562: PUSH
70563: EMPTY
70564: LIST
70565: LIST
70566: PUSH
70567: LD_INT 1
70569: NEG
70570: PUSH
70571: LD_INT 3
70573: NEG
70574: PUSH
70575: EMPTY
70576: LIST
70577: LIST
70578: PUSH
70579: LD_INT 0
70581: PUSH
70582: LD_INT 3
70584: NEG
70585: PUSH
70586: EMPTY
70587: LIST
70588: LIST
70589: PUSH
70590: LD_INT 1
70592: PUSH
70593: LD_INT 2
70595: NEG
70596: PUSH
70597: EMPTY
70598: LIST
70599: LIST
70600: PUSH
70601: LD_INT 2
70603: PUSH
70604: LD_INT 1
70606: NEG
70607: PUSH
70608: EMPTY
70609: LIST
70610: LIST
70611: PUSH
70612: LD_INT 3
70614: PUSH
70615: LD_INT 0
70617: PUSH
70618: EMPTY
70619: LIST
70620: LIST
70621: PUSH
70622: LD_INT 3
70624: PUSH
70625: LD_INT 1
70627: PUSH
70628: EMPTY
70629: LIST
70630: LIST
70631: PUSH
70632: LD_INT 1
70634: PUSH
70635: LD_INT 3
70637: PUSH
70638: EMPTY
70639: LIST
70640: LIST
70641: PUSH
70642: LD_INT 0
70644: PUSH
70645: LD_INT 3
70647: PUSH
70648: EMPTY
70649: LIST
70650: LIST
70651: PUSH
70652: LD_INT 1
70654: NEG
70655: PUSH
70656: LD_INT 2
70658: PUSH
70659: EMPTY
70660: LIST
70661: LIST
70662: PUSH
70663: LD_INT 2
70665: NEG
70666: PUSH
70667: LD_INT 1
70669: PUSH
70670: EMPTY
70671: LIST
70672: LIST
70673: PUSH
70674: LD_INT 3
70676: NEG
70677: PUSH
70678: LD_INT 0
70680: PUSH
70681: EMPTY
70682: LIST
70683: LIST
70684: PUSH
70685: LD_INT 3
70687: NEG
70688: PUSH
70689: LD_INT 1
70691: NEG
70692: PUSH
70693: EMPTY
70694: LIST
70695: LIST
70696: PUSH
70697: EMPTY
70698: LIST
70699: LIST
70700: LIST
70701: LIST
70702: LIST
70703: LIST
70704: LIST
70705: LIST
70706: LIST
70707: LIST
70708: LIST
70709: LIST
70710: LIST
70711: LIST
70712: LIST
70713: LIST
70714: LIST
70715: LIST
70716: LIST
70717: LIST
70718: LIST
70719: LIST
70720: LIST
70721: LIST
70722: LIST
70723: LIST
70724: LIST
70725: LIST
70726: LIST
70727: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70728: LD_ADDR_VAR 0 44
70732: PUSH
70733: LD_INT 0
70735: PUSH
70736: LD_INT 0
70738: PUSH
70739: EMPTY
70740: LIST
70741: LIST
70742: PUSH
70743: LD_INT 0
70745: PUSH
70746: LD_INT 1
70748: NEG
70749: PUSH
70750: EMPTY
70751: LIST
70752: LIST
70753: PUSH
70754: LD_INT 1
70756: PUSH
70757: LD_INT 0
70759: PUSH
70760: EMPTY
70761: LIST
70762: LIST
70763: PUSH
70764: LD_INT 1
70766: PUSH
70767: LD_INT 1
70769: PUSH
70770: EMPTY
70771: LIST
70772: LIST
70773: PUSH
70774: LD_INT 0
70776: PUSH
70777: LD_INT 1
70779: PUSH
70780: EMPTY
70781: LIST
70782: LIST
70783: PUSH
70784: LD_INT 1
70786: NEG
70787: PUSH
70788: LD_INT 0
70790: PUSH
70791: EMPTY
70792: LIST
70793: LIST
70794: PUSH
70795: LD_INT 1
70797: NEG
70798: PUSH
70799: LD_INT 1
70801: NEG
70802: PUSH
70803: EMPTY
70804: LIST
70805: LIST
70806: PUSH
70807: LD_INT 1
70809: NEG
70810: PUSH
70811: LD_INT 2
70813: NEG
70814: PUSH
70815: EMPTY
70816: LIST
70817: LIST
70818: PUSH
70819: LD_INT 1
70821: PUSH
70822: LD_INT 1
70824: NEG
70825: PUSH
70826: EMPTY
70827: LIST
70828: LIST
70829: PUSH
70830: LD_INT 2
70832: PUSH
70833: LD_INT 0
70835: PUSH
70836: EMPTY
70837: LIST
70838: LIST
70839: PUSH
70840: LD_INT 2
70842: PUSH
70843: LD_INT 1
70845: PUSH
70846: EMPTY
70847: LIST
70848: LIST
70849: PUSH
70850: LD_INT 2
70852: PUSH
70853: LD_INT 2
70855: PUSH
70856: EMPTY
70857: LIST
70858: LIST
70859: PUSH
70860: LD_INT 1
70862: PUSH
70863: LD_INT 2
70865: PUSH
70866: EMPTY
70867: LIST
70868: LIST
70869: PUSH
70870: LD_INT 1
70872: NEG
70873: PUSH
70874: LD_INT 1
70876: PUSH
70877: EMPTY
70878: LIST
70879: LIST
70880: PUSH
70881: LD_INT 2
70883: NEG
70884: PUSH
70885: LD_INT 0
70887: PUSH
70888: EMPTY
70889: LIST
70890: LIST
70891: PUSH
70892: LD_INT 2
70894: NEG
70895: PUSH
70896: LD_INT 1
70898: NEG
70899: PUSH
70900: EMPTY
70901: LIST
70902: LIST
70903: PUSH
70904: LD_INT 2
70906: NEG
70907: PUSH
70908: LD_INT 2
70910: NEG
70911: PUSH
70912: EMPTY
70913: LIST
70914: LIST
70915: PUSH
70916: LD_INT 2
70918: NEG
70919: PUSH
70920: LD_INT 3
70922: NEG
70923: PUSH
70924: EMPTY
70925: LIST
70926: LIST
70927: PUSH
70928: LD_INT 2
70930: PUSH
70931: LD_INT 1
70933: NEG
70934: PUSH
70935: EMPTY
70936: LIST
70937: LIST
70938: PUSH
70939: LD_INT 3
70941: PUSH
70942: LD_INT 0
70944: PUSH
70945: EMPTY
70946: LIST
70947: LIST
70948: PUSH
70949: LD_INT 3
70951: PUSH
70952: LD_INT 1
70954: PUSH
70955: EMPTY
70956: LIST
70957: LIST
70958: PUSH
70959: LD_INT 3
70961: PUSH
70962: LD_INT 2
70964: PUSH
70965: EMPTY
70966: LIST
70967: LIST
70968: PUSH
70969: LD_INT 3
70971: PUSH
70972: LD_INT 3
70974: PUSH
70975: EMPTY
70976: LIST
70977: LIST
70978: PUSH
70979: LD_INT 2
70981: PUSH
70982: LD_INT 3
70984: PUSH
70985: EMPTY
70986: LIST
70987: LIST
70988: PUSH
70989: LD_INT 2
70991: NEG
70992: PUSH
70993: LD_INT 1
70995: PUSH
70996: EMPTY
70997: LIST
70998: LIST
70999: PUSH
71000: LD_INT 3
71002: NEG
71003: PUSH
71004: LD_INT 0
71006: PUSH
71007: EMPTY
71008: LIST
71009: LIST
71010: PUSH
71011: LD_INT 3
71013: NEG
71014: PUSH
71015: LD_INT 1
71017: NEG
71018: PUSH
71019: EMPTY
71020: LIST
71021: LIST
71022: PUSH
71023: LD_INT 3
71025: NEG
71026: PUSH
71027: LD_INT 2
71029: NEG
71030: PUSH
71031: EMPTY
71032: LIST
71033: LIST
71034: PUSH
71035: LD_INT 3
71037: NEG
71038: PUSH
71039: LD_INT 3
71041: NEG
71042: PUSH
71043: EMPTY
71044: LIST
71045: LIST
71046: PUSH
71047: EMPTY
71048: LIST
71049: LIST
71050: LIST
71051: LIST
71052: LIST
71053: LIST
71054: LIST
71055: LIST
71056: LIST
71057: LIST
71058: LIST
71059: LIST
71060: LIST
71061: LIST
71062: LIST
71063: LIST
71064: LIST
71065: LIST
71066: LIST
71067: LIST
71068: LIST
71069: LIST
71070: LIST
71071: LIST
71072: LIST
71073: LIST
71074: LIST
71075: LIST
71076: LIST
71077: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
71078: LD_ADDR_VAR 0 45
71082: PUSH
71083: LD_INT 0
71085: PUSH
71086: LD_INT 0
71088: PUSH
71089: EMPTY
71090: LIST
71091: LIST
71092: PUSH
71093: LD_INT 0
71095: PUSH
71096: LD_INT 1
71098: NEG
71099: PUSH
71100: EMPTY
71101: LIST
71102: LIST
71103: PUSH
71104: LD_INT 1
71106: PUSH
71107: LD_INT 0
71109: PUSH
71110: EMPTY
71111: LIST
71112: LIST
71113: PUSH
71114: LD_INT 1
71116: PUSH
71117: LD_INT 1
71119: PUSH
71120: EMPTY
71121: LIST
71122: LIST
71123: PUSH
71124: LD_INT 0
71126: PUSH
71127: LD_INT 1
71129: PUSH
71130: EMPTY
71131: LIST
71132: LIST
71133: PUSH
71134: LD_INT 1
71136: NEG
71137: PUSH
71138: LD_INT 0
71140: PUSH
71141: EMPTY
71142: LIST
71143: LIST
71144: PUSH
71145: LD_INT 1
71147: NEG
71148: PUSH
71149: LD_INT 1
71151: NEG
71152: PUSH
71153: EMPTY
71154: LIST
71155: LIST
71156: PUSH
71157: LD_INT 1
71159: NEG
71160: PUSH
71161: LD_INT 2
71163: NEG
71164: PUSH
71165: EMPTY
71166: LIST
71167: LIST
71168: PUSH
71169: LD_INT 0
71171: PUSH
71172: LD_INT 2
71174: NEG
71175: PUSH
71176: EMPTY
71177: LIST
71178: LIST
71179: PUSH
71180: LD_INT 1
71182: PUSH
71183: LD_INT 1
71185: NEG
71186: PUSH
71187: EMPTY
71188: LIST
71189: LIST
71190: PUSH
71191: LD_INT 2
71193: PUSH
71194: LD_INT 1
71196: PUSH
71197: EMPTY
71198: LIST
71199: LIST
71200: PUSH
71201: LD_INT 2
71203: PUSH
71204: LD_INT 2
71206: PUSH
71207: EMPTY
71208: LIST
71209: LIST
71210: PUSH
71211: LD_INT 1
71213: PUSH
71214: LD_INT 2
71216: PUSH
71217: EMPTY
71218: LIST
71219: LIST
71220: PUSH
71221: LD_INT 0
71223: PUSH
71224: LD_INT 2
71226: PUSH
71227: EMPTY
71228: LIST
71229: LIST
71230: PUSH
71231: LD_INT 1
71233: NEG
71234: PUSH
71235: LD_INT 1
71237: PUSH
71238: EMPTY
71239: LIST
71240: LIST
71241: PUSH
71242: LD_INT 2
71244: NEG
71245: PUSH
71246: LD_INT 1
71248: NEG
71249: PUSH
71250: EMPTY
71251: LIST
71252: LIST
71253: PUSH
71254: LD_INT 2
71256: NEG
71257: PUSH
71258: LD_INT 2
71260: NEG
71261: PUSH
71262: EMPTY
71263: LIST
71264: LIST
71265: PUSH
71266: LD_INT 2
71268: NEG
71269: PUSH
71270: LD_INT 3
71272: NEG
71273: PUSH
71274: EMPTY
71275: LIST
71276: LIST
71277: PUSH
71278: LD_INT 1
71280: NEG
71281: PUSH
71282: LD_INT 3
71284: NEG
71285: PUSH
71286: EMPTY
71287: LIST
71288: LIST
71289: PUSH
71290: LD_INT 0
71292: PUSH
71293: LD_INT 3
71295: NEG
71296: PUSH
71297: EMPTY
71298: LIST
71299: LIST
71300: PUSH
71301: LD_INT 1
71303: PUSH
71304: LD_INT 2
71306: NEG
71307: PUSH
71308: EMPTY
71309: LIST
71310: LIST
71311: PUSH
71312: LD_INT 3
71314: PUSH
71315: LD_INT 2
71317: PUSH
71318: EMPTY
71319: LIST
71320: LIST
71321: PUSH
71322: LD_INT 3
71324: PUSH
71325: LD_INT 3
71327: PUSH
71328: EMPTY
71329: LIST
71330: LIST
71331: PUSH
71332: LD_INT 2
71334: PUSH
71335: LD_INT 3
71337: PUSH
71338: EMPTY
71339: LIST
71340: LIST
71341: PUSH
71342: LD_INT 1
71344: PUSH
71345: LD_INT 3
71347: PUSH
71348: EMPTY
71349: LIST
71350: LIST
71351: PUSH
71352: LD_INT 0
71354: PUSH
71355: LD_INT 3
71357: PUSH
71358: EMPTY
71359: LIST
71360: LIST
71361: PUSH
71362: LD_INT 1
71364: NEG
71365: PUSH
71366: LD_INT 2
71368: PUSH
71369: EMPTY
71370: LIST
71371: LIST
71372: PUSH
71373: LD_INT 3
71375: NEG
71376: PUSH
71377: LD_INT 2
71379: NEG
71380: PUSH
71381: EMPTY
71382: LIST
71383: LIST
71384: PUSH
71385: LD_INT 3
71387: NEG
71388: PUSH
71389: LD_INT 3
71391: NEG
71392: PUSH
71393: EMPTY
71394: LIST
71395: LIST
71396: PUSH
71397: EMPTY
71398: LIST
71399: LIST
71400: LIST
71401: LIST
71402: LIST
71403: LIST
71404: LIST
71405: LIST
71406: LIST
71407: LIST
71408: LIST
71409: LIST
71410: LIST
71411: LIST
71412: LIST
71413: LIST
71414: LIST
71415: LIST
71416: LIST
71417: LIST
71418: LIST
71419: LIST
71420: LIST
71421: LIST
71422: LIST
71423: LIST
71424: LIST
71425: LIST
71426: LIST
71427: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
71428: LD_ADDR_VAR 0 46
71432: PUSH
71433: LD_INT 0
71435: PUSH
71436: LD_INT 0
71438: PUSH
71439: EMPTY
71440: LIST
71441: LIST
71442: PUSH
71443: LD_INT 0
71445: PUSH
71446: LD_INT 1
71448: NEG
71449: PUSH
71450: EMPTY
71451: LIST
71452: LIST
71453: PUSH
71454: LD_INT 1
71456: PUSH
71457: LD_INT 0
71459: PUSH
71460: EMPTY
71461: LIST
71462: LIST
71463: PUSH
71464: LD_INT 1
71466: PUSH
71467: LD_INT 1
71469: PUSH
71470: EMPTY
71471: LIST
71472: LIST
71473: PUSH
71474: LD_INT 0
71476: PUSH
71477: LD_INT 1
71479: PUSH
71480: EMPTY
71481: LIST
71482: LIST
71483: PUSH
71484: LD_INT 1
71486: NEG
71487: PUSH
71488: LD_INT 0
71490: PUSH
71491: EMPTY
71492: LIST
71493: LIST
71494: PUSH
71495: LD_INT 1
71497: NEG
71498: PUSH
71499: LD_INT 1
71501: NEG
71502: PUSH
71503: EMPTY
71504: LIST
71505: LIST
71506: PUSH
71507: LD_INT 1
71509: NEG
71510: PUSH
71511: LD_INT 2
71513: NEG
71514: PUSH
71515: EMPTY
71516: LIST
71517: LIST
71518: PUSH
71519: LD_INT 0
71521: PUSH
71522: LD_INT 2
71524: NEG
71525: PUSH
71526: EMPTY
71527: LIST
71528: LIST
71529: PUSH
71530: LD_INT 1
71532: PUSH
71533: LD_INT 1
71535: NEG
71536: PUSH
71537: EMPTY
71538: LIST
71539: LIST
71540: PUSH
71541: LD_INT 2
71543: PUSH
71544: LD_INT 0
71546: PUSH
71547: EMPTY
71548: LIST
71549: LIST
71550: PUSH
71551: LD_INT 2
71553: PUSH
71554: LD_INT 1
71556: PUSH
71557: EMPTY
71558: LIST
71559: LIST
71560: PUSH
71561: LD_INT 1
71563: PUSH
71564: LD_INT 2
71566: PUSH
71567: EMPTY
71568: LIST
71569: LIST
71570: PUSH
71571: LD_INT 0
71573: PUSH
71574: LD_INT 2
71576: PUSH
71577: EMPTY
71578: LIST
71579: LIST
71580: PUSH
71581: LD_INT 1
71583: NEG
71584: PUSH
71585: LD_INT 1
71587: PUSH
71588: EMPTY
71589: LIST
71590: LIST
71591: PUSH
71592: LD_INT 2
71594: NEG
71595: PUSH
71596: LD_INT 0
71598: PUSH
71599: EMPTY
71600: LIST
71601: LIST
71602: PUSH
71603: LD_INT 2
71605: NEG
71606: PUSH
71607: LD_INT 1
71609: NEG
71610: PUSH
71611: EMPTY
71612: LIST
71613: LIST
71614: PUSH
71615: LD_INT 1
71617: NEG
71618: PUSH
71619: LD_INT 3
71621: NEG
71622: PUSH
71623: EMPTY
71624: LIST
71625: LIST
71626: PUSH
71627: LD_INT 0
71629: PUSH
71630: LD_INT 3
71632: NEG
71633: PUSH
71634: EMPTY
71635: LIST
71636: LIST
71637: PUSH
71638: LD_INT 1
71640: PUSH
71641: LD_INT 2
71643: NEG
71644: PUSH
71645: EMPTY
71646: LIST
71647: LIST
71648: PUSH
71649: LD_INT 2
71651: PUSH
71652: LD_INT 1
71654: NEG
71655: PUSH
71656: EMPTY
71657: LIST
71658: LIST
71659: PUSH
71660: LD_INT 3
71662: PUSH
71663: LD_INT 0
71665: PUSH
71666: EMPTY
71667: LIST
71668: LIST
71669: PUSH
71670: LD_INT 3
71672: PUSH
71673: LD_INT 1
71675: PUSH
71676: EMPTY
71677: LIST
71678: LIST
71679: PUSH
71680: LD_INT 1
71682: PUSH
71683: LD_INT 3
71685: PUSH
71686: EMPTY
71687: LIST
71688: LIST
71689: PUSH
71690: LD_INT 0
71692: PUSH
71693: LD_INT 3
71695: PUSH
71696: EMPTY
71697: LIST
71698: LIST
71699: PUSH
71700: LD_INT 1
71702: NEG
71703: PUSH
71704: LD_INT 2
71706: PUSH
71707: EMPTY
71708: LIST
71709: LIST
71710: PUSH
71711: LD_INT 2
71713: NEG
71714: PUSH
71715: LD_INT 1
71717: PUSH
71718: EMPTY
71719: LIST
71720: LIST
71721: PUSH
71722: LD_INT 3
71724: NEG
71725: PUSH
71726: LD_INT 0
71728: PUSH
71729: EMPTY
71730: LIST
71731: LIST
71732: PUSH
71733: LD_INT 3
71735: NEG
71736: PUSH
71737: LD_INT 1
71739: NEG
71740: PUSH
71741: EMPTY
71742: LIST
71743: LIST
71744: PUSH
71745: EMPTY
71746: LIST
71747: LIST
71748: LIST
71749: LIST
71750: LIST
71751: LIST
71752: LIST
71753: LIST
71754: LIST
71755: LIST
71756: LIST
71757: LIST
71758: LIST
71759: LIST
71760: LIST
71761: LIST
71762: LIST
71763: LIST
71764: LIST
71765: LIST
71766: LIST
71767: LIST
71768: LIST
71769: LIST
71770: LIST
71771: LIST
71772: LIST
71773: LIST
71774: LIST
71775: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71776: LD_ADDR_VAR 0 47
71780: PUSH
71781: LD_INT 0
71783: PUSH
71784: LD_INT 0
71786: PUSH
71787: EMPTY
71788: LIST
71789: LIST
71790: PUSH
71791: LD_INT 0
71793: PUSH
71794: LD_INT 1
71796: NEG
71797: PUSH
71798: EMPTY
71799: LIST
71800: LIST
71801: PUSH
71802: LD_INT 1
71804: PUSH
71805: LD_INT 0
71807: PUSH
71808: EMPTY
71809: LIST
71810: LIST
71811: PUSH
71812: LD_INT 1
71814: PUSH
71815: LD_INT 1
71817: PUSH
71818: EMPTY
71819: LIST
71820: LIST
71821: PUSH
71822: LD_INT 0
71824: PUSH
71825: LD_INT 1
71827: PUSH
71828: EMPTY
71829: LIST
71830: LIST
71831: PUSH
71832: LD_INT 1
71834: NEG
71835: PUSH
71836: LD_INT 0
71838: PUSH
71839: EMPTY
71840: LIST
71841: LIST
71842: PUSH
71843: LD_INT 1
71845: NEG
71846: PUSH
71847: LD_INT 1
71849: NEG
71850: PUSH
71851: EMPTY
71852: LIST
71853: LIST
71854: PUSH
71855: LD_INT 1
71857: NEG
71858: PUSH
71859: LD_INT 2
71861: NEG
71862: PUSH
71863: EMPTY
71864: LIST
71865: LIST
71866: PUSH
71867: LD_INT 0
71869: PUSH
71870: LD_INT 2
71872: NEG
71873: PUSH
71874: EMPTY
71875: LIST
71876: LIST
71877: PUSH
71878: LD_INT 1
71880: PUSH
71881: LD_INT 1
71883: NEG
71884: PUSH
71885: EMPTY
71886: LIST
71887: LIST
71888: PUSH
71889: LD_INT 2
71891: NEG
71892: PUSH
71893: LD_INT 1
71895: NEG
71896: PUSH
71897: EMPTY
71898: LIST
71899: LIST
71900: PUSH
71901: LD_INT 2
71903: NEG
71904: PUSH
71905: LD_INT 2
71907: NEG
71908: PUSH
71909: EMPTY
71910: LIST
71911: LIST
71912: PUSH
71913: EMPTY
71914: LIST
71915: LIST
71916: LIST
71917: LIST
71918: LIST
71919: LIST
71920: LIST
71921: LIST
71922: LIST
71923: LIST
71924: LIST
71925: LIST
71926: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
71927: LD_ADDR_VAR 0 48
71931: PUSH
71932: LD_INT 0
71934: PUSH
71935: LD_INT 0
71937: PUSH
71938: EMPTY
71939: LIST
71940: LIST
71941: PUSH
71942: LD_INT 0
71944: PUSH
71945: LD_INT 1
71947: NEG
71948: PUSH
71949: EMPTY
71950: LIST
71951: LIST
71952: PUSH
71953: LD_INT 1
71955: PUSH
71956: LD_INT 0
71958: PUSH
71959: EMPTY
71960: LIST
71961: LIST
71962: PUSH
71963: LD_INT 1
71965: PUSH
71966: LD_INT 1
71968: PUSH
71969: EMPTY
71970: LIST
71971: LIST
71972: PUSH
71973: LD_INT 0
71975: PUSH
71976: LD_INT 1
71978: PUSH
71979: EMPTY
71980: LIST
71981: LIST
71982: PUSH
71983: LD_INT 1
71985: NEG
71986: PUSH
71987: LD_INT 0
71989: PUSH
71990: EMPTY
71991: LIST
71992: LIST
71993: PUSH
71994: LD_INT 1
71996: NEG
71997: PUSH
71998: LD_INT 1
72000: NEG
72001: PUSH
72002: EMPTY
72003: LIST
72004: LIST
72005: PUSH
72006: LD_INT 1
72008: NEG
72009: PUSH
72010: LD_INT 2
72012: NEG
72013: PUSH
72014: EMPTY
72015: LIST
72016: LIST
72017: PUSH
72018: LD_INT 0
72020: PUSH
72021: LD_INT 2
72023: NEG
72024: PUSH
72025: EMPTY
72026: LIST
72027: LIST
72028: PUSH
72029: LD_INT 1
72031: PUSH
72032: LD_INT 1
72034: NEG
72035: PUSH
72036: EMPTY
72037: LIST
72038: LIST
72039: PUSH
72040: LD_INT 2
72042: PUSH
72043: LD_INT 0
72045: PUSH
72046: EMPTY
72047: LIST
72048: LIST
72049: PUSH
72050: LD_INT 2
72052: PUSH
72053: LD_INT 1
72055: PUSH
72056: EMPTY
72057: LIST
72058: LIST
72059: PUSH
72060: EMPTY
72061: LIST
72062: LIST
72063: LIST
72064: LIST
72065: LIST
72066: LIST
72067: LIST
72068: LIST
72069: LIST
72070: LIST
72071: LIST
72072: LIST
72073: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
72074: LD_ADDR_VAR 0 49
72078: PUSH
72079: LD_INT 0
72081: PUSH
72082: LD_INT 0
72084: PUSH
72085: EMPTY
72086: LIST
72087: LIST
72088: PUSH
72089: LD_INT 0
72091: PUSH
72092: LD_INT 1
72094: NEG
72095: PUSH
72096: EMPTY
72097: LIST
72098: LIST
72099: PUSH
72100: LD_INT 1
72102: PUSH
72103: LD_INT 0
72105: PUSH
72106: EMPTY
72107: LIST
72108: LIST
72109: PUSH
72110: LD_INT 1
72112: PUSH
72113: LD_INT 1
72115: PUSH
72116: EMPTY
72117: LIST
72118: LIST
72119: PUSH
72120: LD_INT 0
72122: PUSH
72123: LD_INT 1
72125: PUSH
72126: EMPTY
72127: LIST
72128: LIST
72129: PUSH
72130: LD_INT 1
72132: NEG
72133: PUSH
72134: LD_INT 0
72136: PUSH
72137: EMPTY
72138: LIST
72139: LIST
72140: PUSH
72141: LD_INT 1
72143: NEG
72144: PUSH
72145: LD_INT 1
72147: NEG
72148: PUSH
72149: EMPTY
72150: LIST
72151: LIST
72152: PUSH
72153: LD_INT 1
72155: PUSH
72156: LD_INT 1
72158: NEG
72159: PUSH
72160: EMPTY
72161: LIST
72162: LIST
72163: PUSH
72164: LD_INT 2
72166: PUSH
72167: LD_INT 0
72169: PUSH
72170: EMPTY
72171: LIST
72172: LIST
72173: PUSH
72174: LD_INT 2
72176: PUSH
72177: LD_INT 1
72179: PUSH
72180: EMPTY
72181: LIST
72182: LIST
72183: PUSH
72184: LD_INT 2
72186: PUSH
72187: LD_INT 2
72189: PUSH
72190: EMPTY
72191: LIST
72192: LIST
72193: PUSH
72194: LD_INT 1
72196: PUSH
72197: LD_INT 2
72199: PUSH
72200: EMPTY
72201: LIST
72202: LIST
72203: PUSH
72204: EMPTY
72205: LIST
72206: LIST
72207: LIST
72208: LIST
72209: LIST
72210: LIST
72211: LIST
72212: LIST
72213: LIST
72214: LIST
72215: LIST
72216: LIST
72217: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
72218: LD_ADDR_VAR 0 50
72222: PUSH
72223: LD_INT 0
72225: PUSH
72226: LD_INT 0
72228: PUSH
72229: EMPTY
72230: LIST
72231: LIST
72232: PUSH
72233: LD_INT 0
72235: PUSH
72236: LD_INT 1
72238: NEG
72239: PUSH
72240: EMPTY
72241: LIST
72242: LIST
72243: PUSH
72244: LD_INT 1
72246: PUSH
72247: LD_INT 0
72249: PUSH
72250: EMPTY
72251: LIST
72252: LIST
72253: PUSH
72254: LD_INT 1
72256: PUSH
72257: LD_INT 1
72259: PUSH
72260: EMPTY
72261: LIST
72262: LIST
72263: PUSH
72264: LD_INT 0
72266: PUSH
72267: LD_INT 1
72269: PUSH
72270: EMPTY
72271: LIST
72272: LIST
72273: PUSH
72274: LD_INT 1
72276: NEG
72277: PUSH
72278: LD_INT 0
72280: PUSH
72281: EMPTY
72282: LIST
72283: LIST
72284: PUSH
72285: LD_INT 1
72287: NEG
72288: PUSH
72289: LD_INT 1
72291: NEG
72292: PUSH
72293: EMPTY
72294: LIST
72295: LIST
72296: PUSH
72297: LD_INT 2
72299: PUSH
72300: LD_INT 1
72302: PUSH
72303: EMPTY
72304: LIST
72305: LIST
72306: PUSH
72307: LD_INT 2
72309: PUSH
72310: LD_INT 2
72312: PUSH
72313: EMPTY
72314: LIST
72315: LIST
72316: PUSH
72317: LD_INT 1
72319: PUSH
72320: LD_INT 2
72322: PUSH
72323: EMPTY
72324: LIST
72325: LIST
72326: PUSH
72327: LD_INT 0
72329: PUSH
72330: LD_INT 2
72332: PUSH
72333: EMPTY
72334: LIST
72335: LIST
72336: PUSH
72337: LD_INT 1
72339: NEG
72340: PUSH
72341: LD_INT 1
72343: PUSH
72344: EMPTY
72345: LIST
72346: LIST
72347: PUSH
72348: EMPTY
72349: LIST
72350: LIST
72351: LIST
72352: LIST
72353: LIST
72354: LIST
72355: LIST
72356: LIST
72357: LIST
72358: LIST
72359: LIST
72360: LIST
72361: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
72362: LD_ADDR_VAR 0 51
72366: PUSH
72367: LD_INT 0
72369: PUSH
72370: LD_INT 0
72372: PUSH
72373: EMPTY
72374: LIST
72375: LIST
72376: PUSH
72377: LD_INT 0
72379: PUSH
72380: LD_INT 1
72382: NEG
72383: PUSH
72384: EMPTY
72385: LIST
72386: LIST
72387: PUSH
72388: LD_INT 1
72390: PUSH
72391: LD_INT 0
72393: PUSH
72394: EMPTY
72395: LIST
72396: LIST
72397: PUSH
72398: LD_INT 1
72400: PUSH
72401: LD_INT 1
72403: PUSH
72404: EMPTY
72405: LIST
72406: LIST
72407: PUSH
72408: LD_INT 0
72410: PUSH
72411: LD_INT 1
72413: PUSH
72414: EMPTY
72415: LIST
72416: LIST
72417: PUSH
72418: LD_INT 1
72420: NEG
72421: PUSH
72422: LD_INT 0
72424: PUSH
72425: EMPTY
72426: LIST
72427: LIST
72428: PUSH
72429: LD_INT 1
72431: NEG
72432: PUSH
72433: LD_INT 1
72435: NEG
72436: PUSH
72437: EMPTY
72438: LIST
72439: LIST
72440: PUSH
72441: LD_INT 1
72443: PUSH
72444: LD_INT 2
72446: PUSH
72447: EMPTY
72448: LIST
72449: LIST
72450: PUSH
72451: LD_INT 0
72453: PUSH
72454: LD_INT 2
72456: PUSH
72457: EMPTY
72458: LIST
72459: LIST
72460: PUSH
72461: LD_INT 1
72463: NEG
72464: PUSH
72465: LD_INT 1
72467: PUSH
72468: EMPTY
72469: LIST
72470: LIST
72471: PUSH
72472: LD_INT 2
72474: NEG
72475: PUSH
72476: LD_INT 0
72478: PUSH
72479: EMPTY
72480: LIST
72481: LIST
72482: PUSH
72483: LD_INT 2
72485: NEG
72486: PUSH
72487: LD_INT 1
72489: NEG
72490: PUSH
72491: EMPTY
72492: LIST
72493: LIST
72494: PUSH
72495: EMPTY
72496: LIST
72497: LIST
72498: LIST
72499: LIST
72500: LIST
72501: LIST
72502: LIST
72503: LIST
72504: LIST
72505: LIST
72506: LIST
72507: LIST
72508: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72509: LD_ADDR_VAR 0 52
72513: PUSH
72514: LD_INT 0
72516: PUSH
72517: LD_INT 0
72519: PUSH
72520: EMPTY
72521: LIST
72522: LIST
72523: PUSH
72524: LD_INT 0
72526: PUSH
72527: LD_INT 1
72529: NEG
72530: PUSH
72531: EMPTY
72532: LIST
72533: LIST
72534: PUSH
72535: LD_INT 1
72537: PUSH
72538: LD_INT 0
72540: PUSH
72541: EMPTY
72542: LIST
72543: LIST
72544: PUSH
72545: LD_INT 1
72547: PUSH
72548: LD_INT 1
72550: PUSH
72551: EMPTY
72552: LIST
72553: LIST
72554: PUSH
72555: LD_INT 0
72557: PUSH
72558: LD_INT 1
72560: PUSH
72561: EMPTY
72562: LIST
72563: LIST
72564: PUSH
72565: LD_INT 1
72567: NEG
72568: PUSH
72569: LD_INT 0
72571: PUSH
72572: EMPTY
72573: LIST
72574: LIST
72575: PUSH
72576: LD_INT 1
72578: NEG
72579: PUSH
72580: LD_INT 1
72582: NEG
72583: PUSH
72584: EMPTY
72585: LIST
72586: LIST
72587: PUSH
72588: LD_INT 1
72590: NEG
72591: PUSH
72592: LD_INT 2
72594: NEG
72595: PUSH
72596: EMPTY
72597: LIST
72598: LIST
72599: PUSH
72600: LD_INT 1
72602: NEG
72603: PUSH
72604: LD_INT 1
72606: PUSH
72607: EMPTY
72608: LIST
72609: LIST
72610: PUSH
72611: LD_INT 2
72613: NEG
72614: PUSH
72615: LD_INT 0
72617: PUSH
72618: EMPTY
72619: LIST
72620: LIST
72621: PUSH
72622: LD_INT 2
72624: NEG
72625: PUSH
72626: LD_INT 1
72628: NEG
72629: PUSH
72630: EMPTY
72631: LIST
72632: LIST
72633: PUSH
72634: LD_INT 2
72636: NEG
72637: PUSH
72638: LD_INT 2
72640: NEG
72641: PUSH
72642: EMPTY
72643: LIST
72644: LIST
72645: PUSH
72646: EMPTY
72647: LIST
72648: LIST
72649: LIST
72650: LIST
72651: LIST
72652: LIST
72653: LIST
72654: LIST
72655: LIST
72656: LIST
72657: LIST
72658: LIST
72659: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72660: LD_ADDR_VAR 0 53
72664: PUSH
72665: LD_INT 0
72667: PUSH
72668: LD_INT 0
72670: PUSH
72671: EMPTY
72672: LIST
72673: LIST
72674: PUSH
72675: LD_INT 0
72677: PUSH
72678: LD_INT 1
72680: NEG
72681: PUSH
72682: EMPTY
72683: LIST
72684: LIST
72685: PUSH
72686: LD_INT 1
72688: PUSH
72689: LD_INT 0
72691: PUSH
72692: EMPTY
72693: LIST
72694: LIST
72695: PUSH
72696: LD_INT 1
72698: PUSH
72699: LD_INT 1
72701: PUSH
72702: EMPTY
72703: LIST
72704: LIST
72705: PUSH
72706: LD_INT 0
72708: PUSH
72709: LD_INT 1
72711: PUSH
72712: EMPTY
72713: LIST
72714: LIST
72715: PUSH
72716: LD_INT 1
72718: NEG
72719: PUSH
72720: LD_INT 0
72722: PUSH
72723: EMPTY
72724: LIST
72725: LIST
72726: PUSH
72727: LD_INT 1
72729: NEG
72730: PUSH
72731: LD_INT 1
72733: NEG
72734: PUSH
72735: EMPTY
72736: LIST
72737: LIST
72738: PUSH
72739: LD_INT 1
72741: NEG
72742: PUSH
72743: LD_INT 2
72745: NEG
72746: PUSH
72747: EMPTY
72748: LIST
72749: LIST
72750: PUSH
72751: LD_INT 0
72753: PUSH
72754: LD_INT 2
72756: NEG
72757: PUSH
72758: EMPTY
72759: LIST
72760: LIST
72761: PUSH
72762: LD_INT 1
72764: PUSH
72765: LD_INT 1
72767: NEG
72768: PUSH
72769: EMPTY
72770: LIST
72771: LIST
72772: PUSH
72773: LD_INT 2
72775: PUSH
72776: LD_INT 0
72778: PUSH
72779: EMPTY
72780: LIST
72781: LIST
72782: PUSH
72783: LD_INT 2
72785: PUSH
72786: LD_INT 1
72788: PUSH
72789: EMPTY
72790: LIST
72791: LIST
72792: PUSH
72793: LD_INT 2
72795: PUSH
72796: LD_INT 2
72798: PUSH
72799: EMPTY
72800: LIST
72801: LIST
72802: PUSH
72803: LD_INT 1
72805: PUSH
72806: LD_INT 2
72808: PUSH
72809: EMPTY
72810: LIST
72811: LIST
72812: PUSH
72813: LD_INT 0
72815: PUSH
72816: LD_INT 2
72818: PUSH
72819: EMPTY
72820: LIST
72821: LIST
72822: PUSH
72823: LD_INT 1
72825: NEG
72826: PUSH
72827: LD_INT 1
72829: PUSH
72830: EMPTY
72831: LIST
72832: LIST
72833: PUSH
72834: LD_INT 2
72836: NEG
72837: PUSH
72838: LD_INT 0
72840: PUSH
72841: EMPTY
72842: LIST
72843: LIST
72844: PUSH
72845: LD_INT 2
72847: NEG
72848: PUSH
72849: LD_INT 1
72851: NEG
72852: PUSH
72853: EMPTY
72854: LIST
72855: LIST
72856: PUSH
72857: LD_INT 2
72859: NEG
72860: PUSH
72861: LD_INT 2
72863: NEG
72864: PUSH
72865: EMPTY
72866: LIST
72867: LIST
72868: PUSH
72869: EMPTY
72870: LIST
72871: LIST
72872: LIST
72873: LIST
72874: LIST
72875: LIST
72876: LIST
72877: LIST
72878: LIST
72879: LIST
72880: LIST
72881: LIST
72882: LIST
72883: LIST
72884: LIST
72885: LIST
72886: LIST
72887: LIST
72888: LIST
72889: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72890: LD_ADDR_VAR 0 54
72894: PUSH
72895: LD_INT 0
72897: PUSH
72898: LD_INT 0
72900: PUSH
72901: EMPTY
72902: LIST
72903: LIST
72904: PUSH
72905: LD_INT 0
72907: PUSH
72908: LD_INT 1
72910: NEG
72911: PUSH
72912: EMPTY
72913: LIST
72914: LIST
72915: PUSH
72916: LD_INT 1
72918: PUSH
72919: LD_INT 0
72921: PUSH
72922: EMPTY
72923: LIST
72924: LIST
72925: PUSH
72926: LD_INT 1
72928: PUSH
72929: LD_INT 1
72931: PUSH
72932: EMPTY
72933: LIST
72934: LIST
72935: PUSH
72936: LD_INT 0
72938: PUSH
72939: LD_INT 1
72941: PUSH
72942: EMPTY
72943: LIST
72944: LIST
72945: PUSH
72946: LD_INT 1
72948: NEG
72949: PUSH
72950: LD_INT 0
72952: PUSH
72953: EMPTY
72954: LIST
72955: LIST
72956: PUSH
72957: LD_INT 1
72959: NEG
72960: PUSH
72961: LD_INT 1
72963: NEG
72964: PUSH
72965: EMPTY
72966: LIST
72967: LIST
72968: PUSH
72969: LD_INT 1
72971: NEG
72972: PUSH
72973: LD_INT 2
72975: NEG
72976: PUSH
72977: EMPTY
72978: LIST
72979: LIST
72980: PUSH
72981: LD_INT 0
72983: PUSH
72984: LD_INT 2
72986: NEG
72987: PUSH
72988: EMPTY
72989: LIST
72990: LIST
72991: PUSH
72992: LD_INT 1
72994: PUSH
72995: LD_INT 1
72997: NEG
72998: PUSH
72999: EMPTY
73000: LIST
73001: LIST
73002: PUSH
73003: LD_INT 2
73005: PUSH
73006: LD_INT 0
73008: PUSH
73009: EMPTY
73010: LIST
73011: LIST
73012: PUSH
73013: LD_INT 2
73015: PUSH
73016: LD_INT 1
73018: PUSH
73019: EMPTY
73020: LIST
73021: LIST
73022: PUSH
73023: LD_INT 2
73025: PUSH
73026: LD_INT 2
73028: PUSH
73029: EMPTY
73030: LIST
73031: LIST
73032: PUSH
73033: LD_INT 1
73035: PUSH
73036: LD_INT 2
73038: PUSH
73039: EMPTY
73040: LIST
73041: LIST
73042: PUSH
73043: LD_INT 0
73045: PUSH
73046: LD_INT 2
73048: PUSH
73049: EMPTY
73050: LIST
73051: LIST
73052: PUSH
73053: LD_INT 1
73055: NEG
73056: PUSH
73057: LD_INT 1
73059: PUSH
73060: EMPTY
73061: LIST
73062: LIST
73063: PUSH
73064: LD_INT 2
73066: NEG
73067: PUSH
73068: LD_INT 0
73070: PUSH
73071: EMPTY
73072: LIST
73073: LIST
73074: PUSH
73075: LD_INT 2
73077: NEG
73078: PUSH
73079: LD_INT 1
73081: NEG
73082: PUSH
73083: EMPTY
73084: LIST
73085: LIST
73086: PUSH
73087: LD_INT 2
73089: NEG
73090: PUSH
73091: LD_INT 2
73093: NEG
73094: PUSH
73095: EMPTY
73096: LIST
73097: LIST
73098: PUSH
73099: EMPTY
73100: LIST
73101: LIST
73102: LIST
73103: LIST
73104: LIST
73105: LIST
73106: LIST
73107: LIST
73108: LIST
73109: LIST
73110: LIST
73111: LIST
73112: LIST
73113: LIST
73114: LIST
73115: LIST
73116: LIST
73117: LIST
73118: LIST
73119: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73120: LD_ADDR_VAR 0 55
73124: PUSH
73125: LD_INT 0
73127: PUSH
73128: LD_INT 0
73130: PUSH
73131: EMPTY
73132: LIST
73133: LIST
73134: PUSH
73135: LD_INT 0
73137: PUSH
73138: LD_INT 1
73140: NEG
73141: PUSH
73142: EMPTY
73143: LIST
73144: LIST
73145: PUSH
73146: LD_INT 1
73148: PUSH
73149: LD_INT 0
73151: PUSH
73152: EMPTY
73153: LIST
73154: LIST
73155: PUSH
73156: LD_INT 1
73158: PUSH
73159: LD_INT 1
73161: PUSH
73162: EMPTY
73163: LIST
73164: LIST
73165: PUSH
73166: LD_INT 0
73168: PUSH
73169: LD_INT 1
73171: PUSH
73172: EMPTY
73173: LIST
73174: LIST
73175: PUSH
73176: LD_INT 1
73178: NEG
73179: PUSH
73180: LD_INT 0
73182: PUSH
73183: EMPTY
73184: LIST
73185: LIST
73186: PUSH
73187: LD_INT 1
73189: NEG
73190: PUSH
73191: LD_INT 1
73193: NEG
73194: PUSH
73195: EMPTY
73196: LIST
73197: LIST
73198: PUSH
73199: LD_INT 1
73201: NEG
73202: PUSH
73203: LD_INT 2
73205: NEG
73206: PUSH
73207: EMPTY
73208: LIST
73209: LIST
73210: PUSH
73211: LD_INT 0
73213: PUSH
73214: LD_INT 2
73216: NEG
73217: PUSH
73218: EMPTY
73219: LIST
73220: LIST
73221: PUSH
73222: LD_INT 1
73224: PUSH
73225: LD_INT 1
73227: NEG
73228: PUSH
73229: EMPTY
73230: LIST
73231: LIST
73232: PUSH
73233: LD_INT 2
73235: PUSH
73236: LD_INT 0
73238: PUSH
73239: EMPTY
73240: LIST
73241: LIST
73242: PUSH
73243: LD_INT 2
73245: PUSH
73246: LD_INT 1
73248: PUSH
73249: EMPTY
73250: LIST
73251: LIST
73252: PUSH
73253: LD_INT 2
73255: PUSH
73256: LD_INT 2
73258: PUSH
73259: EMPTY
73260: LIST
73261: LIST
73262: PUSH
73263: LD_INT 1
73265: PUSH
73266: LD_INT 2
73268: PUSH
73269: EMPTY
73270: LIST
73271: LIST
73272: PUSH
73273: LD_INT 0
73275: PUSH
73276: LD_INT 2
73278: PUSH
73279: EMPTY
73280: LIST
73281: LIST
73282: PUSH
73283: LD_INT 1
73285: NEG
73286: PUSH
73287: LD_INT 1
73289: PUSH
73290: EMPTY
73291: LIST
73292: LIST
73293: PUSH
73294: LD_INT 2
73296: NEG
73297: PUSH
73298: LD_INT 0
73300: PUSH
73301: EMPTY
73302: LIST
73303: LIST
73304: PUSH
73305: LD_INT 2
73307: NEG
73308: PUSH
73309: LD_INT 1
73311: NEG
73312: PUSH
73313: EMPTY
73314: LIST
73315: LIST
73316: PUSH
73317: LD_INT 2
73319: NEG
73320: PUSH
73321: LD_INT 2
73323: NEG
73324: PUSH
73325: EMPTY
73326: LIST
73327: LIST
73328: PUSH
73329: EMPTY
73330: LIST
73331: LIST
73332: LIST
73333: LIST
73334: LIST
73335: LIST
73336: LIST
73337: LIST
73338: LIST
73339: LIST
73340: LIST
73341: LIST
73342: LIST
73343: LIST
73344: LIST
73345: LIST
73346: LIST
73347: LIST
73348: LIST
73349: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73350: LD_ADDR_VAR 0 56
73354: PUSH
73355: LD_INT 0
73357: PUSH
73358: LD_INT 0
73360: PUSH
73361: EMPTY
73362: LIST
73363: LIST
73364: PUSH
73365: LD_INT 0
73367: PUSH
73368: LD_INT 1
73370: NEG
73371: PUSH
73372: EMPTY
73373: LIST
73374: LIST
73375: PUSH
73376: LD_INT 1
73378: PUSH
73379: LD_INT 0
73381: PUSH
73382: EMPTY
73383: LIST
73384: LIST
73385: PUSH
73386: LD_INT 1
73388: PUSH
73389: LD_INT 1
73391: PUSH
73392: EMPTY
73393: LIST
73394: LIST
73395: PUSH
73396: LD_INT 0
73398: PUSH
73399: LD_INT 1
73401: PUSH
73402: EMPTY
73403: LIST
73404: LIST
73405: PUSH
73406: LD_INT 1
73408: NEG
73409: PUSH
73410: LD_INT 0
73412: PUSH
73413: EMPTY
73414: LIST
73415: LIST
73416: PUSH
73417: LD_INT 1
73419: NEG
73420: PUSH
73421: LD_INT 1
73423: NEG
73424: PUSH
73425: EMPTY
73426: LIST
73427: LIST
73428: PUSH
73429: LD_INT 1
73431: NEG
73432: PUSH
73433: LD_INT 2
73435: NEG
73436: PUSH
73437: EMPTY
73438: LIST
73439: LIST
73440: PUSH
73441: LD_INT 0
73443: PUSH
73444: LD_INT 2
73446: NEG
73447: PUSH
73448: EMPTY
73449: LIST
73450: LIST
73451: PUSH
73452: LD_INT 1
73454: PUSH
73455: LD_INT 1
73457: NEG
73458: PUSH
73459: EMPTY
73460: LIST
73461: LIST
73462: PUSH
73463: LD_INT 2
73465: PUSH
73466: LD_INT 0
73468: PUSH
73469: EMPTY
73470: LIST
73471: LIST
73472: PUSH
73473: LD_INT 2
73475: PUSH
73476: LD_INT 1
73478: PUSH
73479: EMPTY
73480: LIST
73481: LIST
73482: PUSH
73483: LD_INT 2
73485: PUSH
73486: LD_INT 2
73488: PUSH
73489: EMPTY
73490: LIST
73491: LIST
73492: PUSH
73493: LD_INT 1
73495: PUSH
73496: LD_INT 2
73498: PUSH
73499: EMPTY
73500: LIST
73501: LIST
73502: PUSH
73503: LD_INT 0
73505: PUSH
73506: LD_INT 2
73508: PUSH
73509: EMPTY
73510: LIST
73511: LIST
73512: PUSH
73513: LD_INT 1
73515: NEG
73516: PUSH
73517: LD_INT 1
73519: PUSH
73520: EMPTY
73521: LIST
73522: LIST
73523: PUSH
73524: LD_INT 2
73526: NEG
73527: PUSH
73528: LD_INT 0
73530: PUSH
73531: EMPTY
73532: LIST
73533: LIST
73534: PUSH
73535: LD_INT 2
73537: NEG
73538: PUSH
73539: LD_INT 1
73541: NEG
73542: PUSH
73543: EMPTY
73544: LIST
73545: LIST
73546: PUSH
73547: LD_INT 2
73549: NEG
73550: PUSH
73551: LD_INT 2
73553: NEG
73554: PUSH
73555: EMPTY
73556: LIST
73557: LIST
73558: PUSH
73559: EMPTY
73560: LIST
73561: LIST
73562: LIST
73563: LIST
73564: LIST
73565: LIST
73566: LIST
73567: LIST
73568: LIST
73569: LIST
73570: LIST
73571: LIST
73572: LIST
73573: LIST
73574: LIST
73575: LIST
73576: LIST
73577: LIST
73578: LIST
73579: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73580: LD_ADDR_VAR 0 57
73584: PUSH
73585: LD_INT 0
73587: PUSH
73588: LD_INT 0
73590: PUSH
73591: EMPTY
73592: LIST
73593: LIST
73594: PUSH
73595: LD_INT 0
73597: PUSH
73598: LD_INT 1
73600: NEG
73601: PUSH
73602: EMPTY
73603: LIST
73604: LIST
73605: PUSH
73606: LD_INT 1
73608: PUSH
73609: LD_INT 0
73611: PUSH
73612: EMPTY
73613: LIST
73614: LIST
73615: PUSH
73616: LD_INT 1
73618: PUSH
73619: LD_INT 1
73621: PUSH
73622: EMPTY
73623: LIST
73624: LIST
73625: PUSH
73626: LD_INT 0
73628: PUSH
73629: LD_INT 1
73631: PUSH
73632: EMPTY
73633: LIST
73634: LIST
73635: PUSH
73636: LD_INT 1
73638: NEG
73639: PUSH
73640: LD_INT 0
73642: PUSH
73643: EMPTY
73644: LIST
73645: LIST
73646: PUSH
73647: LD_INT 1
73649: NEG
73650: PUSH
73651: LD_INT 1
73653: NEG
73654: PUSH
73655: EMPTY
73656: LIST
73657: LIST
73658: PUSH
73659: LD_INT 1
73661: NEG
73662: PUSH
73663: LD_INT 2
73665: NEG
73666: PUSH
73667: EMPTY
73668: LIST
73669: LIST
73670: PUSH
73671: LD_INT 0
73673: PUSH
73674: LD_INT 2
73676: NEG
73677: PUSH
73678: EMPTY
73679: LIST
73680: LIST
73681: PUSH
73682: LD_INT 1
73684: PUSH
73685: LD_INT 1
73687: NEG
73688: PUSH
73689: EMPTY
73690: LIST
73691: LIST
73692: PUSH
73693: LD_INT 2
73695: PUSH
73696: LD_INT 0
73698: PUSH
73699: EMPTY
73700: LIST
73701: LIST
73702: PUSH
73703: LD_INT 2
73705: PUSH
73706: LD_INT 1
73708: PUSH
73709: EMPTY
73710: LIST
73711: LIST
73712: PUSH
73713: LD_INT 2
73715: PUSH
73716: LD_INT 2
73718: PUSH
73719: EMPTY
73720: LIST
73721: LIST
73722: PUSH
73723: LD_INT 1
73725: PUSH
73726: LD_INT 2
73728: PUSH
73729: EMPTY
73730: LIST
73731: LIST
73732: PUSH
73733: LD_INT 0
73735: PUSH
73736: LD_INT 2
73738: PUSH
73739: EMPTY
73740: LIST
73741: LIST
73742: PUSH
73743: LD_INT 1
73745: NEG
73746: PUSH
73747: LD_INT 1
73749: PUSH
73750: EMPTY
73751: LIST
73752: LIST
73753: PUSH
73754: LD_INT 2
73756: NEG
73757: PUSH
73758: LD_INT 0
73760: PUSH
73761: EMPTY
73762: LIST
73763: LIST
73764: PUSH
73765: LD_INT 2
73767: NEG
73768: PUSH
73769: LD_INT 1
73771: NEG
73772: PUSH
73773: EMPTY
73774: LIST
73775: LIST
73776: PUSH
73777: LD_INT 2
73779: NEG
73780: PUSH
73781: LD_INT 2
73783: NEG
73784: PUSH
73785: EMPTY
73786: LIST
73787: LIST
73788: PUSH
73789: EMPTY
73790: LIST
73791: LIST
73792: LIST
73793: LIST
73794: LIST
73795: LIST
73796: LIST
73797: LIST
73798: LIST
73799: LIST
73800: LIST
73801: LIST
73802: LIST
73803: LIST
73804: LIST
73805: LIST
73806: LIST
73807: LIST
73808: LIST
73809: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73810: LD_ADDR_VAR 0 58
73814: PUSH
73815: LD_INT 0
73817: PUSH
73818: LD_INT 0
73820: PUSH
73821: EMPTY
73822: LIST
73823: LIST
73824: PUSH
73825: LD_INT 0
73827: PUSH
73828: LD_INT 1
73830: NEG
73831: PUSH
73832: EMPTY
73833: LIST
73834: LIST
73835: PUSH
73836: LD_INT 1
73838: PUSH
73839: LD_INT 0
73841: PUSH
73842: EMPTY
73843: LIST
73844: LIST
73845: PUSH
73846: LD_INT 1
73848: PUSH
73849: LD_INT 1
73851: PUSH
73852: EMPTY
73853: LIST
73854: LIST
73855: PUSH
73856: LD_INT 0
73858: PUSH
73859: LD_INT 1
73861: PUSH
73862: EMPTY
73863: LIST
73864: LIST
73865: PUSH
73866: LD_INT 1
73868: NEG
73869: PUSH
73870: LD_INT 0
73872: PUSH
73873: EMPTY
73874: LIST
73875: LIST
73876: PUSH
73877: LD_INT 1
73879: NEG
73880: PUSH
73881: LD_INT 1
73883: NEG
73884: PUSH
73885: EMPTY
73886: LIST
73887: LIST
73888: PUSH
73889: LD_INT 1
73891: NEG
73892: PUSH
73893: LD_INT 2
73895: NEG
73896: PUSH
73897: EMPTY
73898: LIST
73899: LIST
73900: PUSH
73901: LD_INT 0
73903: PUSH
73904: LD_INT 2
73906: NEG
73907: PUSH
73908: EMPTY
73909: LIST
73910: LIST
73911: PUSH
73912: LD_INT 1
73914: PUSH
73915: LD_INT 1
73917: NEG
73918: PUSH
73919: EMPTY
73920: LIST
73921: LIST
73922: PUSH
73923: LD_INT 2
73925: PUSH
73926: LD_INT 0
73928: PUSH
73929: EMPTY
73930: LIST
73931: LIST
73932: PUSH
73933: LD_INT 2
73935: PUSH
73936: LD_INT 1
73938: PUSH
73939: EMPTY
73940: LIST
73941: LIST
73942: PUSH
73943: LD_INT 2
73945: PUSH
73946: LD_INT 2
73948: PUSH
73949: EMPTY
73950: LIST
73951: LIST
73952: PUSH
73953: LD_INT 1
73955: PUSH
73956: LD_INT 2
73958: PUSH
73959: EMPTY
73960: LIST
73961: LIST
73962: PUSH
73963: LD_INT 0
73965: PUSH
73966: LD_INT 2
73968: PUSH
73969: EMPTY
73970: LIST
73971: LIST
73972: PUSH
73973: LD_INT 1
73975: NEG
73976: PUSH
73977: LD_INT 1
73979: PUSH
73980: EMPTY
73981: LIST
73982: LIST
73983: PUSH
73984: LD_INT 2
73986: NEG
73987: PUSH
73988: LD_INT 0
73990: PUSH
73991: EMPTY
73992: LIST
73993: LIST
73994: PUSH
73995: LD_INT 2
73997: NEG
73998: PUSH
73999: LD_INT 1
74001: NEG
74002: PUSH
74003: EMPTY
74004: LIST
74005: LIST
74006: PUSH
74007: LD_INT 2
74009: NEG
74010: PUSH
74011: LD_INT 2
74013: NEG
74014: PUSH
74015: EMPTY
74016: LIST
74017: LIST
74018: PUSH
74019: EMPTY
74020: LIST
74021: LIST
74022: LIST
74023: LIST
74024: LIST
74025: LIST
74026: LIST
74027: LIST
74028: LIST
74029: LIST
74030: LIST
74031: LIST
74032: LIST
74033: LIST
74034: LIST
74035: LIST
74036: LIST
74037: LIST
74038: LIST
74039: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74040: LD_ADDR_VAR 0 59
74044: PUSH
74045: LD_INT 0
74047: PUSH
74048: LD_INT 0
74050: PUSH
74051: EMPTY
74052: LIST
74053: LIST
74054: PUSH
74055: LD_INT 0
74057: PUSH
74058: LD_INT 1
74060: NEG
74061: PUSH
74062: EMPTY
74063: LIST
74064: LIST
74065: PUSH
74066: LD_INT 1
74068: PUSH
74069: LD_INT 0
74071: PUSH
74072: EMPTY
74073: LIST
74074: LIST
74075: PUSH
74076: LD_INT 1
74078: PUSH
74079: LD_INT 1
74081: PUSH
74082: EMPTY
74083: LIST
74084: LIST
74085: PUSH
74086: LD_INT 0
74088: PUSH
74089: LD_INT 1
74091: PUSH
74092: EMPTY
74093: LIST
74094: LIST
74095: PUSH
74096: LD_INT 1
74098: NEG
74099: PUSH
74100: LD_INT 0
74102: PUSH
74103: EMPTY
74104: LIST
74105: LIST
74106: PUSH
74107: LD_INT 1
74109: NEG
74110: PUSH
74111: LD_INT 1
74113: NEG
74114: PUSH
74115: EMPTY
74116: LIST
74117: LIST
74118: PUSH
74119: EMPTY
74120: LIST
74121: LIST
74122: LIST
74123: LIST
74124: LIST
74125: LIST
74126: LIST
74127: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74128: LD_ADDR_VAR 0 60
74132: PUSH
74133: LD_INT 0
74135: PUSH
74136: LD_INT 0
74138: PUSH
74139: EMPTY
74140: LIST
74141: LIST
74142: PUSH
74143: LD_INT 0
74145: PUSH
74146: LD_INT 1
74148: NEG
74149: PUSH
74150: EMPTY
74151: LIST
74152: LIST
74153: PUSH
74154: LD_INT 1
74156: PUSH
74157: LD_INT 0
74159: PUSH
74160: EMPTY
74161: LIST
74162: LIST
74163: PUSH
74164: LD_INT 1
74166: PUSH
74167: LD_INT 1
74169: PUSH
74170: EMPTY
74171: LIST
74172: LIST
74173: PUSH
74174: LD_INT 0
74176: PUSH
74177: LD_INT 1
74179: PUSH
74180: EMPTY
74181: LIST
74182: LIST
74183: PUSH
74184: LD_INT 1
74186: NEG
74187: PUSH
74188: LD_INT 0
74190: PUSH
74191: EMPTY
74192: LIST
74193: LIST
74194: PUSH
74195: LD_INT 1
74197: NEG
74198: PUSH
74199: LD_INT 1
74201: NEG
74202: PUSH
74203: EMPTY
74204: LIST
74205: LIST
74206: PUSH
74207: EMPTY
74208: LIST
74209: LIST
74210: LIST
74211: LIST
74212: LIST
74213: LIST
74214: LIST
74215: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74216: LD_ADDR_VAR 0 61
74220: PUSH
74221: LD_INT 0
74223: PUSH
74224: LD_INT 0
74226: PUSH
74227: EMPTY
74228: LIST
74229: LIST
74230: PUSH
74231: LD_INT 0
74233: PUSH
74234: LD_INT 1
74236: NEG
74237: PUSH
74238: EMPTY
74239: LIST
74240: LIST
74241: PUSH
74242: LD_INT 1
74244: PUSH
74245: LD_INT 0
74247: PUSH
74248: EMPTY
74249: LIST
74250: LIST
74251: PUSH
74252: LD_INT 1
74254: PUSH
74255: LD_INT 1
74257: PUSH
74258: EMPTY
74259: LIST
74260: LIST
74261: PUSH
74262: LD_INT 0
74264: PUSH
74265: LD_INT 1
74267: PUSH
74268: EMPTY
74269: LIST
74270: LIST
74271: PUSH
74272: LD_INT 1
74274: NEG
74275: PUSH
74276: LD_INT 0
74278: PUSH
74279: EMPTY
74280: LIST
74281: LIST
74282: PUSH
74283: LD_INT 1
74285: NEG
74286: PUSH
74287: LD_INT 1
74289: NEG
74290: PUSH
74291: EMPTY
74292: LIST
74293: LIST
74294: PUSH
74295: EMPTY
74296: LIST
74297: LIST
74298: LIST
74299: LIST
74300: LIST
74301: LIST
74302: LIST
74303: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74304: LD_ADDR_VAR 0 62
74308: PUSH
74309: LD_INT 0
74311: PUSH
74312: LD_INT 0
74314: PUSH
74315: EMPTY
74316: LIST
74317: LIST
74318: PUSH
74319: LD_INT 0
74321: PUSH
74322: LD_INT 1
74324: NEG
74325: PUSH
74326: EMPTY
74327: LIST
74328: LIST
74329: PUSH
74330: LD_INT 1
74332: PUSH
74333: LD_INT 0
74335: PUSH
74336: EMPTY
74337: LIST
74338: LIST
74339: PUSH
74340: LD_INT 1
74342: PUSH
74343: LD_INT 1
74345: PUSH
74346: EMPTY
74347: LIST
74348: LIST
74349: PUSH
74350: LD_INT 0
74352: PUSH
74353: LD_INT 1
74355: PUSH
74356: EMPTY
74357: LIST
74358: LIST
74359: PUSH
74360: LD_INT 1
74362: NEG
74363: PUSH
74364: LD_INT 0
74366: PUSH
74367: EMPTY
74368: LIST
74369: LIST
74370: PUSH
74371: LD_INT 1
74373: NEG
74374: PUSH
74375: LD_INT 1
74377: NEG
74378: PUSH
74379: EMPTY
74380: LIST
74381: LIST
74382: PUSH
74383: EMPTY
74384: LIST
74385: LIST
74386: LIST
74387: LIST
74388: LIST
74389: LIST
74390: LIST
74391: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74392: LD_ADDR_VAR 0 63
74396: PUSH
74397: LD_INT 0
74399: PUSH
74400: LD_INT 0
74402: PUSH
74403: EMPTY
74404: LIST
74405: LIST
74406: PUSH
74407: LD_INT 0
74409: PUSH
74410: LD_INT 1
74412: NEG
74413: PUSH
74414: EMPTY
74415: LIST
74416: LIST
74417: PUSH
74418: LD_INT 1
74420: PUSH
74421: LD_INT 0
74423: PUSH
74424: EMPTY
74425: LIST
74426: LIST
74427: PUSH
74428: LD_INT 1
74430: PUSH
74431: LD_INT 1
74433: PUSH
74434: EMPTY
74435: LIST
74436: LIST
74437: PUSH
74438: LD_INT 0
74440: PUSH
74441: LD_INT 1
74443: PUSH
74444: EMPTY
74445: LIST
74446: LIST
74447: PUSH
74448: LD_INT 1
74450: NEG
74451: PUSH
74452: LD_INT 0
74454: PUSH
74455: EMPTY
74456: LIST
74457: LIST
74458: PUSH
74459: LD_INT 1
74461: NEG
74462: PUSH
74463: LD_INT 1
74465: NEG
74466: PUSH
74467: EMPTY
74468: LIST
74469: LIST
74470: PUSH
74471: EMPTY
74472: LIST
74473: LIST
74474: LIST
74475: LIST
74476: LIST
74477: LIST
74478: LIST
74479: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74480: LD_ADDR_VAR 0 64
74484: PUSH
74485: LD_INT 0
74487: PUSH
74488: LD_INT 0
74490: PUSH
74491: EMPTY
74492: LIST
74493: LIST
74494: PUSH
74495: LD_INT 0
74497: PUSH
74498: LD_INT 1
74500: NEG
74501: PUSH
74502: EMPTY
74503: LIST
74504: LIST
74505: PUSH
74506: LD_INT 1
74508: PUSH
74509: LD_INT 0
74511: PUSH
74512: EMPTY
74513: LIST
74514: LIST
74515: PUSH
74516: LD_INT 1
74518: PUSH
74519: LD_INT 1
74521: PUSH
74522: EMPTY
74523: LIST
74524: LIST
74525: PUSH
74526: LD_INT 0
74528: PUSH
74529: LD_INT 1
74531: PUSH
74532: EMPTY
74533: LIST
74534: LIST
74535: PUSH
74536: LD_INT 1
74538: NEG
74539: PUSH
74540: LD_INT 0
74542: PUSH
74543: EMPTY
74544: LIST
74545: LIST
74546: PUSH
74547: LD_INT 1
74549: NEG
74550: PUSH
74551: LD_INT 1
74553: NEG
74554: PUSH
74555: EMPTY
74556: LIST
74557: LIST
74558: PUSH
74559: EMPTY
74560: LIST
74561: LIST
74562: LIST
74563: LIST
74564: LIST
74565: LIST
74566: LIST
74567: ST_TO_ADDR
// end ; 1 :
74568: GO 80465
74570: LD_INT 1
74572: DOUBLE
74573: EQUAL
74574: IFTRUE 74578
74576: GO 77201
74578: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
74579: LD_ADDR_VAR 0 11
74583: PUSH
74584: LD_INT 1
74586: NEG
74587: PUSH
74588: LD_INT 3
74590: NEG
74591: PUSH
74592: EMPTY
74593: LIST
74594: LIST
74595: PUSH
74596: LD_INT 0
74598: PUSH
74599: LD_INT 3
74601: NEG
74602: PUSH
74603: EMPTY
74604: LIST
74605: LIST
74606: PUSH
74607: LD_INT 1
74609: PUSH
74610: LD_INT 2
74612: NEG
74613: PUSH
74614: EMPTY
74615: LIST
74616: LIST
74617: PUSH
74618: EMPTY
74619: LIST
74620: LIST
74621: LIST
74622: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
74623: LD_ADDR_VAR 0 12
74627: PUSH
74628: LD_INT 2
74630: PUSH
74631: LD_INT 1
74633: NEG
74634: PUSH
74635: EMPTY
74636: LIST
74637: LIST
74638: PUSH
74639: LD_INT 3
74641: PUSH
74642: LD_INT 0
74644: PUSH
74645: EMPTY
74646: LIST
74647: LIST
74648: PUSH
74649: LD_INT 3
74651: PUSH
74652: LD_INT 1
74654: PUSH
74655: EMPTY
74656: LIST
74657: LIST
74658: PUSH
74659: EMPTY
74660: LIST
74661: LIST
74662: LIST
74663: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
74664: LD_ADDR_VAR 0 13
74668: PUSH
74669: LD_INT 3
74671: PUSH
74672: LD_INT 2
74674: PUSH
74675: EMPTY
74676: LIST
74677: LIST
74678: PUSH
74679: LD_INT 3
74681: PUSH
74682: LD_INT 3
74684: PUSH
74685: EMPTY
74686: LIST
74687: LIST
74688: PUSH
74689: LD_INT 2
74691: PUSH
74692: LD_INT 3
74694: PUSH
74695: EMPTY
74696: LIST
74697: LIST
74698: PUSH
74699: EMPTY
74700: LIST
74701: LIST
74702: LIST
74703: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
74704: LD_ADDR_VAR 0 14
74708: PUSH
74709: LD_INT 1
74711: PUSH
74712: LD_INT 3
74714: PUSH
74715: EMPTY
74716: LIST
74717: LIST
74718: PUSH
74719: LD_INT 0
74721: PUSH
74722: LD_INT 3
74724: PUSH
74725: EMPTY
74726: LIST
74727: LIST
74728: PUSH
74729: LD_INT 1
74731: NEG
74732: PUSH
74733: LD_INT 2
74735: PUSH
74736: EMPTY
74737: LIST
74738: LIST
74739: PUSH
74740: EMPTY
74741: LIST
74742: LIST
74743: LIST
74744: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74745: LD_ADDR_VAR 0 15
74749: PUSH
74750: LD_INT 2
74752: NEG
74753: PUSH
74754: LD_INT 1
74756: PUSH
74757: EMPTY
74758: LIST
74759: LIST
74760: PUSH
74761: LD_INT 3
74763: NEG
74764: PUSH
74765: LD_INT 0
74767: PUSH
74768: EMPTY
74769: LIST
74770: LIST
74771: PUSH
74772: LD_INT 3
74774: NEG
74775: PUSH
74776: LD_INT 1
74778: NEG
74779: PUSH
74780: EMPTY
74781: LIST
74782: LIST
74783: PUSH
74784: EMPTY
74785: LIST
74786: LIST
74787: LIST
74788: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74789: LD_ADDR_VAR 0 16
74793: PUSH
74794: LD_INT 2
74796: NEG
74797: PUSH
74798: LD_INT 3
74800: NEG
74801: PUSH
74802: EMPTY
74803: LIST
74804: LIST
74805: PUSH
74806: LD_INT 3
74808: NEG
74809: PUSH
74810: LD_INT 2
74812: NEG
74813: PUSH
74814: EMPTY
74815: LIST
74816: LIST
74817: PUSH
74818: LD_INT 3
74820: NEG
74821: PUSH
74822: LD_INT 3
74824: NEG
74825: PUSH
74826: EMPTY
74827: LIST
74828: LIST
74829: PUSH
74830: EMPTY
74831: LIST
74832: LIST
74833: LIST
74834: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
74835: LD_ADDR_VAR 0 17
74839: PUSH
74840: LD_INT 1
74842: NEG
74843: PUSH
74844: LD_INT 3
74846: NEG
74847: PUSH
74848: EMPTY
74849: LIST
74850: LIST
74851: PUSH
74852: LD_INT 0
74854: PUSH
74855: LD_INT 3
74857: NEG
74858: PUSH
74859: EMPTY
74860: LIST
74861: LIST
74862: PUSH
74863: LD_INT 1
74865: PUSH
74866: LD_INT 2
74868: NEG
74869: PUSH
74870: EMPTY
74871: LIST
74872: LIST
74873: PUSH
74874: EMPTY
74875: LIST
74876: LIST
74877: LIST
74878: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
74879: LD_ADDR_VAR 0 18
74883: PUSH
74884: LD_INT 2
74886: PUSH
74887: LD_INT 1
74889: NEG
74890: PUSH
74891: EMPTY
74892: LIST
74893: LIST
74894: PUSH
74895: LD_INT 3
74897: PUSH
74898: LD_INT 0
74900: PUSH
74901: EMPTY
74902: LIST
74903: LIST
74904: PUSH
74905: LD_INT 3
74907: PUSH
74908: LD_INT 1
74910: PUSH
74911: EMPTY
74912: LIST
74913: LIST
74914: PUSH
74915: EMPTY
74916: LIST
74917: LIST
74918: LIST
74919: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
74920: LD_ADDR_VAR 0 19
74924: PUSH
74925: LD_INT 3
74927: PUSH
74928: LD_INT 2
74930: PUSH
74931: EMPTY
74932: LIST
74933: LIST
74934: PUSH
74935: LD_INT 3
74937: PUSH
74938: LD_INT 3
74940: PUSH
74941: EMPTY
74942: LIST
74943: LIST
74944: PUSH
74945: LD_INT 2
74947: PUSH
74948: LD_INT 3
74950: PUSH
74951: EMPTY
74952: LIST
74953: LIST
74954: PUSH
74955: EMPTY
74956: LIST
74957: LIST
74958: LIST
74959: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
74960: LD_ADDR_VAR 0 20
74964: PUSH
74965: LD_INT 1
74967: PUSH
74968: LD_INT 3
74970: PUSH
74971: EMPTY
74972: LIST
74973: LIST
74974: PUSH
74975: LD_INT 0
74977: PUSH
74978: LD_INT 3
74980: PUSH
74981: EMPTY
74982: LIST
74983: LIST
74984: PUSH
74985: LD_INT 1
74987: NEG
74988: PUSH
74989: LD_INT 2
74991: PUSH
74992: EMPTY
74993: LIST
74994: LIST
74995: PUSH
74996: EMPTY
74997: LIST
74998: LIST
74999: LIST
75000: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
75001: LD_ADDR_VAR 0 21
75005: PUSH
75006: LD_INT 2
75008: NEG
75009: PUSH
75010: LD_INT 1
75012: PUSH
75013: EMPTY
75014: LIST
75015: LIST
75016: PUSH
75017: LD_INT 3
75019: NEG
75020: PUSH
75021: LD_INT 0
75023: PUSH
75024: EMPTY
75025: LIST
75026: LIST
75027: PUSH
75028: LD_INT 3
75030: NEG
75031: PUSH
75032: LD_INT 1
75034: NEG
75035: PUSH
75036: EMPTY
75037: LIST
75038: LIST
75039: PUSH
75040: EMPTY
75041: LIST
75042: LIST
75043: LIST
75044: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75045: LD_ADDR_VAR 0 22
75049: PUSH
75050: LD_INT 2
75052: NEG
75053: PUSH
75054: LD_INT 3
75056: NEG
75057: PUSH
75058: EMPTY
75059: LIST
75060: LIST
75061: PUSH
75062: LD_INT 3
75064: NEG
75065: PUSH
75066: LD_INT 2
75068: NEG
75069: PUSH
75070: EMPTY
75071: LIST
75072: LIST
75073: PUSH
75074: LD_INT 3
75076: NEG
75077: PUSH
75078: LD_INT 3
75080: NEG
75081: PUSH
75082: EMPTY
75083: LIST
75084: LIST
75085: PUSH
75086: EMPTY
75087: LIST
75088: LIST
75089: LIST
75090: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
75091: LD_ADDR_VAR 0 23
75095: PUSH
75096: LD_INT 0
75098: PUSH
75099: LD_INT 3
75101: NEG
75102: PUSH
75103: EMPTY
75104: LIST
75105: LIST
75106: PUSH
75107: LD_INT 1
75109: NEG
75110: PUSH
75111: LD_INT 4
75113: NEG
75114: PUSH
75115: EMPTY
75116: LIST
75117: LIST
75118: PUSH
75119: LD_INT 1
75121: PUSH
75122: LD_INT 3
75124: NEG
75125: PUSH
75126: EMPTY
75127: LIST
75128: LIST
75129: PUSH
75130: EMPTY
75131: LIST
75132: LIST
75133: LIST
75134: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
75135: LD_ADDR_VAR 0 24
75139: PUSH
75140: LD_INT 3
75142: PUSH
75143: LD_INT 0
75145: PUSH
75146: EMPTY
75147: LIST
75148: LIST
75149: PUSH
75150: LD_INT 3
75152: PUSH
75153: LD_INT 1
75155: NEG
75156: PUSH
75157: EMPTY
75158: LIST
75159: LIST
75160: PUSH
75161: LD_INT 4
75163: PUSH
75164: LD_INT 1
75166: PUSH
75167: EMPTY
75168: LIST
75169: LIST
75170: PUSH
75171: EMPTY
75172: LIST
75173: LIST
75174: LIST
75175: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
75176: LD_ADDR_VAR 0 25
75180: PUSH
75181: LD_INT 3
75183: PUSH
75184: LD_INT 3
75186: PUSH
75187: EMPTY
75188: LIST
75189: LIST
75190: PUSH
75191: LD_INT 4
75193: PUSH
75194: LD_INT 3
75196: PUSH
75197: EMPTY
75198: LIST
75199: LIST
75200: PUSH
75201: LD_INT 3
75203: PUSH
75204: LD_INT 4
75206: PUSH
75207: EMPTY
75208: LIST
75209: LIST
75210: PUSH
75211: EMPTY
75212: LIST
75213: LIST
75214: LIST
75215: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
75216: LD_ADDR_VAR 0 26
75220: PUSH
75221: LD_INT 0
75223: PUSH
75224: LD_INT 3
75226: PUSH
75227: EMPTY
75228: LIST
75229: LIST
75230: PUSH
75231: LD_INT 1
75233: PUSH
75234: LD_INT 4
75236: PUSH
75237: EMPTY
75238: LIST
75239: LIST
75240: PUSH
75241: LD_INT 1
75243: NEG
75244: PUSH
75245: LD_INT 3
75247: PUSH
75248: EMPTY
75249: LIST
75250: LIST
75251: PUSH
75252: EMPTY
75253: LIST
75254: LIST
75255: LIST
75256: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
75257: LD_ADDR_VAR 0 27
75261: PUSH
75262: LD_INT 3
75264: NEG
75265: PUSH
75266: LD_INT 0
75268: PUSH
75269: EMPTY
75270: LIST
75271: LIST
75272: PUSH
75273: LD_INT 3
75275: NEG
75276: PUSH
75277: LD_INT 1
75279: PUSH
75280: EMPTY
75281: LIST
75282: LIST
75283: PUSH
75284: LD_INT 4
75286: NEG
75287: PUSH
75288: LD_INT 1
75290: NEG
75291: PUSH
75292: EMPTY
75293: LIST
75294: LIST
75295: PUSH
75296: EMPTY
75297: LIST
75298: LIST
75299: LIST
75300: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
75301: LD_ADDR_VAR 0 28
75305: PUSH
75306: LD_INT 3
75308: NEG
75309: PUSH
75310: LD_INT 3
75312: NEG
75313: PUSH
75314: EMPTY
75315: LIST
75316: LIST
75317: PUSH
75318: LD_INT 3
75320: NEG
75321: PUSH
75322: LD_INT 4
75324: NEG
75325: PUSH
75326: EMPTY
75327: LIST
75328: LIST
75329: PUSH
75330: LD_INT 4
75332: NEG
75333: PUSH
75334: LD_INT 3
75336: NEG
75337: PUSH
75338: EMPTY
75339: LIST
75340: LIST
75341: PUSH
75342: EMPTY
75343: LIST
75344: LIST
75345: LIST
75346: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
75347: LD_ADDR_VAR 0 29
75351: PUSH
75352: LD_INT 1
75354: NEG
75355: PUSH
75356: LD_INT 3
75358: NEG
75359: PUSH
75360: EMPTY
75361: LIST
75362: LIST
75363: PUSH
75364: LD_INT 0
75366: PUSH
75367: LD_INT 3
75369: NEG
75370: PUSH
75371: EMPTY
75372: LIST
75373: LIST
75374: PUSH
75375: LD_INT 1
75377: PUSH
75378: LD_INT 2
75380: NEG
75381: PUSH
75382: EMPTY
75383: LIST
75384: LIST
75385: PUSH
75386: LD_INT 1
75388: NEG
75389: PUSH
75390: LD_INT 4
75392: NEG
75393: PUSH
75394: EMPTY
75395: LIST
75396: LIST
75397: PUSH
75398: LD_INT 0
75400: PUSH
75401: LD_INT 4
75403: NEG
75404: PUSH
75405: EMPTY
75406: LIST
75407: LIST
75408: PUSH
75409: LD_INT 1
75411: PUSH
75412: LD_INT 3
75414: NEG
75415: PUSH
75416: EMPTY
75417: LIST
75418: LIST
75419: PUSH
75420: LD_INT 1
75422: NEG
75423: PUSH
75424: LD_INT 5
75426: NEG
75427: PUSH
75428: EMPTY
75429: LIST
75430: LIST
75431: PUSH
75432: LD_INT 0
75434: PUSH
75435: LD_INT 5
75437: NEG
75438: PUSH
75439: EMPTY
75440: LIST
75441: LIST
75442: PUSH
75443: LD_INT 1
75445: PUSH
75446: LD_INT 4
75448: NEG
75449: PUSH
75450: EMPTY
75451: LIST
75452: LIST
75453: PUSH
75454: LD_INT 1
75456: NEG
75457: PUSH
75458: LD_INT 6
75460: NEG
75461: PUSH
75462: EMPTY
75463: LIST
75464: LIST
75465: PUSH
75466: LD_INT 0
75468: PUSH
75469: LD_INT 6
75471: NEG
75472: PUSH
75473: EMPTY
75474: LIST
75475: LIST
75476: PUSH
75477: LD_INT 1
75479: PUSH
75480: LD_INT 5
75482: NEG
75483: PUSH
75484: EMPTY
75485: LIST
75486: LIST
75487: PUSH
75488: EMPTY
75489: LIST
75490: LIST
75491: LIST
75492: LIST
75493: LIST
75494: LIST
75495: LIST
75496: LIST
75497: LIST
75498: LIST
75499: LIST
75500: LIST
75501: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
75502: LD_ADDR_VAR 0 30
75506: PUSH
75507: LD_INT 2
75509: PUSH
75510: LD_INT 1
75512: NEG
75513: PUSH
75514: EMPTY
75515: LIST
75516: LIST
75517: PUSH
75518: LD_INT 3
75520: PUSH
75521: LD_INT 0
75523: PUSH
75524: EMPTY
75525: LIST
75526: LIST
75527: PUSH
75528: LD_INT 3
75530: PUSH
75531: LD_INT 1
75533: PUSH
75534: EMPTY
75535: LIST
75536: LIST
75537: PUSH
75538: LD_INT 3
75540: PUSH
75541: LD_INT 1
75543: NEG
75544: PUSH
75545: EMPTY
75546: LIST
75547: LIST
75548: PUSH
75549: LD_INT 4
75551: PUSH
75552: LD_INT 0
75554: PUSH
75555: EMPTY
75556: LIST
75557: LIST
75558: PUSH
75559: LD_INT 4
75561: PUSH
75562: LD_INT 1
75564: PUSH
75565: EMPTY
75566: LIST
75567: LIST
75568: PUSH
75569: LD_INT 4
75571: PUSH
75572: LD_INT 1
75574: NEG
75575: PUSH
75576: EMPTY
75577: LIST
75578: LIST
75579: PUSH
75580: LD_INT 5
75582: PUSH
75583: LD_INT 0
75585: PUSH
75586: EMPTY
75587: LIST
75588: LIST
75589: PUSH
75590: LD_INT 5
75592: PUSH
75593: LD_INT 1
75595: PUSH
75596: EMPTY
75597: LIST
75598: LIST
75599: PUSH
75600: LD_INT 5
75602: PUSH
75603: LD_INT 1
75605: NEG
75606: PUSH
75607: EMPTY
75608: LIST
75609: LIST
75610: PUSH
75611: LD_INT 6
75613: PUSH
75614: LD_INT 0
75616: PUSH
75617: EMPTY
75618: LIST
75619: LIST
75620: PUSH
75621: LD_INT 6
75623: PUSH
75624: LD_INT 1
75626: PUSH
75627: EMPTY
75628: LIST
75629: LIST
75630: PUSH
75631: EMPTY
75632: LIST
75633: LIST
75634: LIST
75635: LIST
75636: LIST
75637: LIST
75638: LIST
75639: LIST
75640: LIST
75641: LIST
75642: LIST
75643: LIST
75644: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
75645: LD_ADDR_VAR 0 31
75649: PUSH
75650: LD_INT 3
75652: PUSH
75653: LD_INT 2
75655: PUSH
75656: EMPTY
75657: LIST
75658: LIST
75659: PUSH
75660: LD_INT 3
75662: PUSH
75663: LD_INT 3
75665: PUSH
75666: EMPTY
75667: LIST
75668: LIST
75669: PUSH
75670: LD_INT 2
75672: PUSH
75673: LD_INT 3
75675: PUSH
75676: EMPTY
75677: LIST
75678: LIST
75679: PUSH
75680: LD_INT 4
75682: PUSH
75683: LD_INT 3
75685: PUSH
75686: EMPTY
75687: LIST
75688: LIST
75689: PUSH
75690: LD_INT 4
75692: PUSH
75693: LD_INT 4
75695: PUSH
75696: EMPTY
75697: LIST
75698: LIST
75699: PUSH
75700: LD_INT 3
75702: PUSH
75703: LD_INT 4
75705: PUSH
75706: EMPTY
75707: LIST
75708: LIST
75709: PUSH
75710: LD_INT 5
75712: PUSH
75713: LD_INT 4
75715: PUSH
75716: EMPTY
75717: LIST
75718: LIST
75719: PUSH
75720: LD_INT 5
75722: PUSH
75723: LD_INT 5
75725: PUSH
75726: EMPTY
75727: LIST
75728: LIST
75729: PUSH
75730: LD_INT 4
75732: PUSH
75733: LD_INT 5
75735: PUSH
75736: EMPTY
75737: LIST
75738: LIST
75739: PUSH
75740: LD_INT 6
75742: PUSH
75743: LD_INT 5
75745: PUSH
75746: EMPTY
75747: LIST
75748: LIST
75749: PUSH
75750: LD_INT 6
75752: PUSH
75753: LD_INT 6
75755: PUSH
75756: EMPTY
75757: LIST
75758: LIST
75759: PUSH
75760: LD_INT 5
75762: PUSH
75763: LD_INT 6
75765: PUSH
75766: EMPTY
75767: LIST
75768: LIST
75769: PUSH
75770: EMPTY
75771: LIST
75772: LIST
75773: LIST
75774: LIST
75775: LIST
75776: LIST
75777: LIST
75778: LIST
75779: LIST
75780: LIST
75781: LIST
75782: LIST
75783: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
75784: LD_ADDR_VAR 0 32
75788: PUSH
75789: LD_INT 1
75791: PUSH
75792: LD_INT 3
75794: PUSH
75795: EMPTY
75796: LIST
75797: LIST
75798: PUSH
75799: LD_INT 0
75801: PUSH
75802: LD_INT 3
75804: PUSH
75805: EMPTY
75806: LIST
75807: LIST
75808: PUSH
75809: LD_INT 1
75811: NEG
75812: PUSH
75813: LD_INT 2
75815: PUSH
75816: EMPTY
75817: LIST
75818: LIST
75819: PUSH
75820: LD_INT 1
75822: PUSH
75823: LD_INT 4
75825: PUSH
75826: EMPTY
75827: LIST
75828: LIST
75829: PUSH
75830: LD_INT 0
75832: PUSH
75833: LD_INT 4
75835: PUSH
75836: EMPTY
75837: LIST
75838: LIST
75839: PUSH
75840: LD_INT 1
75842: NEG
75843: PUSH
75844: LD_INT 3
75846: PUSH
75847: EMPTY
75848: LIST
75849: LIST
75850: PUSH
75851: LD_INT 1
75853: PUSH
75854: LD_INT 5
75856: PUSH
75857: EMPTY
75858: LIST
75859: LIST
75860: PUSH
75861: LD_INT 0
75863: PUSH
75864: LD_INT 5
75866: PUSH
75867: EMPTY
75868: LIST
75869: LIST
75870: PUSH
75871: LD_INT 1
75873: NEG
75874: PUSH
75875: LD_INT 4
75877: PUSH
75878: EMPTY
75879: LIST
75880: LIST
75881: PUSH
75882: LD_INT 1
75884: PUSH
75885: LD_INT 6
75887: PUSH
75888: EMPTY
75889: LIST
75890: LIST
75891: PUSH
75892: LD_INT 0
75894: PUSH
75895: LD_INT 6
75897: PUSH
75898: EMPTY
75899: LIST
75900: LIST
75901: PUSH
75902: LD_INT 1
75904: NEG
75905: PUSH
75906: LD_INT 5
75908: PUSH
75909: EMPTY
75910: LIST
75911: LIST
75912: PUSH
75913: EMPTY
75914: LIST
75915: LIST
75916: LIST
75917: LIST
75918: LIST
75919: LIST
75920: LIST
75921: LIST
75922: LIST
75923: LIST
75924: LIST
75925: LIST
75926: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
75927: LD_ADDR_VAR 0 33
75931: PUSH
75932: LD_INT 2
75934: NEG
75935: PUSH
75936: LD_INT 1
75938: PUSH
75939: EMPTY
75940: LIST
75941: LIST
75942: PUSH
75943: LD_INT 3
75945: NEG
75946: PUSH
75947: LD_INT 0
75949: PUSH
75950: EMPTY
75951: LIST
75952: LIST
75953: PUSH
75954: LD_INT 3
75956: NEG
75957: PUSH
75958: LD_INT 1
75960: NEG
75961: PUSH
75962: EMPTY
75963: LIST
75964: LIST
75965: PUSH
75966: LD_INT 3
75968: NEG
75969: PUSH
75970: LD_INT 1
75972: PUSH
75973: EMPTY
75974: LIST
75975: LIST
75976: PUSH
75977: LD_INT 4
75979: NEG
75980: PUSH
75981: LD_INT 0
75983: PUSH
75984: EMPTY
75985: LIST
75986: LIST
75987: PUSH
75988: LD_INT 4
75990: NEG
75991: PUSH
75992: LD_INT 1
75994: NEG
75995: PUSH
75996: EMPTY
75997: LIST
75998: LIST
75999: PUSH
76000: LD_INT 4
76002: NEG
76003: PUSH
76004: LD_INT 1
76006: PUSH
76007: EMPTY
76008: LIST
76009: LIST
76010: PUSH
76011: LD_INT 5
76013: NEG
76014: PUSH
76015: LD_INT 0
76017: PUSH
76018: EMPTY
76019: LIST
76020: LIST
76021: PUSH
76022: LD_INT 5
76024: NEG
76025: PUSH
76026: LD_INT 1
76028: NEG
76029: PUSH
76030: EMPTY
76031: LIST
76032: LIST
76033: PUSH
76034: LD_INT 5
76036: NEG
76037: PUSH
76038: LD_INT 1
76040: PUSH
76041: EMPTY
76042: LIST
76043: LIST
76044: PUSH
76045: LD_INT 6
76047: NEG
76048: PUSH
76049: LD_INT 0
76051: PUSH
76052: EMPTY
76053: LIST
76054: LIST
76055: PUSH
76056: LD_INT 6
76058: NEG
76059: PUSH
76060: LD_INT 1
76062: NEG
76063: PUSH
76064: EMPTY
76065: LIST
76066: LIST
76067: PUSH
76068: EMPTY
76069: LIST
76070: LIST
76071: LIST
76072: LIST
76073: LIST
76074: LIST
76075: LIST
76076: LIST
76077: LIST
76078: LIST
76079: LIST
76080: LIST
76081: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
76082: LD_ADDR_VAR 0 34
76086: PUSH
76087: LD_INT 2
76089: NEG
76090: PUSH
76091: LD_INT 3
76093: NEG
76094: PUSH
76095: EMPTY
76096: LIST
76097: LIST
76098: PUSH
76099: LD_INT 3
76101: NEG
76102: PUSH
76103: LD_INT 2
76105: NEG
76106: PUSH
76107: EMPTY
76108: LIST
76109: LIST
76110: PUSH
76111: LD_INT 3
76113: NEG
76114: PUSH
76115: LD_INT 3
76117: NEG
76118: PUSH
76119: EMPTY
76120: LIST
76121: LIST
76122: PUSH
76123: LD_INT 3
76125: NEG
76126: PUSH
76127: LD_INT 4
76129: NEG
76130: PUSH
76131: EMPTY
76132: LIST
76133: LIST
76134: PUSH
76135: LD_INT 4
76137: NEG
76138: PUSH
76139: LD_INT 3
76141: NEG
76142: PUSH
76143: EMPTY
76144: LIST
76145: LIST
76146: PUSH
76147: LD_INT 4
76149: NEG
76150: PUSH
76151: LD_INT 4
76153: NEG
76154: PUSH
76155: EMPTY
76156: LIST
76157: LIST
76158: PUSH
76159: LD_INT 4
76161: NEG
76162: PUSH
76163: LD_INT 5
76165: NEG
76166: PUSH
76167: EMPTY
76168: LIST
76169: LIST
76170: PUSH
76171: LD_INT 5
76173: NEG
76174: PUSH
76175: LD_INT 4
76177: NEG
76178: PUSH
76179: EMPTY
76180: LIST
76181: LIST
76182: PUSH
76183: LD_INT 5
76185: NEG
76186: PUSH
76187: LD_INT 5
76189: NEG
76190: PUSH
76191: EMPTY
76192: LIST
76193: LIST
76194: PUSH
76195: LD_INT 5
76197: NEG
76198: PUSH
76199: LD_INT 6
76201: NEG
76202: PUSH
76203: EMPTY
76204: LIST
76205: LIST
76206: PUSH
76207: LD_INT 6
76209: NEG
76210: PUSH
76211: LD_INT 5
76213: NEG
76214: PUSH
76215: EMPTY
76216: LIST
76217: LIST
76218: PUSH
76219: LD_INT 6
76221: NEG
76222: PUSH
76223: LD_INT 6
76225: NEG
76226: PUSH
76227: EMPTY
76228: LIST
76229: LIST
76230: PUSH
76231: EMPTY
76232: LIST
76233: LIST
76234: LIST
76235: LIST
76236: LIST
76237: LIST
76238: LIST
76239: LIST
76240: LIST
76241: LIST
76242: LIST
76243: LIST
76244: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
76245: LD_ADDR_VAR 0 41
76249: PUSH
76250: LD_INT 0
76252: PUSH
76253: LD_INT 2
76255: NEG
76256: PUSH
76257: EMPTY
76258: LIST
76259: LIST
76260: PUSH
76261: LD_INT 1
76263: NEG
76264: PUSH
76265: LD_INT 3
76267: NEG
76268: PUSH
76269: EMPTY
76270: LIST
76271: LIST
76272: PUSH
76273: LD_INT 1
76275: PUSH
76276: LD_INT 2
76278: NEG
76279: PUSH
76280: EMPTY
76281: LIST
76282: LIST
76283: PUSH
76284: EMPTY
76285: LIST
76286: LIST
76287: LIST
76288: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
76289: LD_ADDR_VAR 0 42
76293: PUSH
76294: LD_INT 2
76296: PUSH
76297: LD_INT 0
76299: PUSH
76300: EMPTY
76301: LIST
76302: LIST
76303: PUSH
76304: LD_INT 2
76306: PUSH
76307: LD_INT 1
76309: NEG
76310: PUSH
76311: EMPTY
76312: LIST
76313: LIST
76314: PUSH
76315: LD_INT 3
76317: PUSH
76318: LD_INT 1
76320: PUSH
76321: EMPTY
76322: LIST
76323: LIST
76324: PUSH
76325: EMPTY
76326: LIST
76327: LIST
76328: LIST
76329: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
76330: LD_ADDR_VAR 0 43
76334: PUSH
76335: LD_INT 2
76337: PUSH
76338: LD_INT 2
76340: PUSH
76341: EMPTY
76342: LIST
76343: LIST
76344: PUSH
76345: LD_INT 3
76347: PUSH
76348: LD_INT 2
76350: PUSH
76351: EMPTY
76352: LIST
76353: LIST
76354: PUSH
76355: LD_INT 2
76357: PUSH
76358: LD_INT 3
76360: PUSH
76361: EMPTY
76362: LIST
76363: LIST
76364: PUSH
76365: EMPTY
76366: LIST
76367: LIST
76368: LIST
76369: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
76370: LD_ADDR_VAR 0 44
76374: PUSH
76375: LD_INT 0
76377: PUSH
76378: LD_INT 2
76380: PUSH
76381: EMPTY
76382: LIST
76383: LIST
76384: PUSH
76385: LD_INT 1
76387: PUSH
76388: LD_INT 3
76390: PUSH
76391: EMPTY
76392: LIST
76393: LIST
76394: PUSH
76395: LD_INT 1
76397: NEG
76398: PUSH
76399: LD_INT 2
76401: PUSH
76402: EMPTY
76403: LIST
76404: LIST
76405: PUSH
76406: EMPTY
76407: LIST
76408: LIST
76409: LIST
76410: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
76411: LD_ADDR_VAR 0 45
76415: PUSH
76416: LD_INT 2
76418: NEG
76419: PUSH
76420: LD_INT 0
76422: PUSH
76423: EMPTY
76424: LIST
76425: LIST
76426: PUSH
76427: LD_INT 2
76429: NEG
76430: PUSH
76431: LD_INT 1
76433: PUSH
76434: EMPTY
76435: LIST
76436: LIST
76437: PUSH
76438: LD_INT 3
76440: NEG
76441: PUSH
76442: LD_INT 1
76444: NEG
76445: PUSH
76446: EMPTY
76447: LIST
76448: LIST
76449: PUSH
76450: EMPTY
76451: LIST
76452: LIST
76453: LIST
76454: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
76455: LD_ADDR_VAR 0 46
76459: PUSH
76460: LD_INT 2
76462: NEG
76463: PUSH
76464: LD_INT 2
76466: NEG
76467: PUSH
76468: EMPTY
76469: LIST
76470: LIST
76471: PUSH
76472: LD_INT 2
76474: NEG
76475: PUSH
76476: LD_INT 3
76478: NEG
76479: PUSH
76480: EMPTY
76481: LIST
76482: LIST
76483: PUSH
76484: LD_INT 3
76486: NEG
76487: PUSH
76488: LD_INT 2
76490: NEG
76491: PUSH
76492: EMPTY
76493: LIST
76494: LIST
76495: PUSH
76496: EMPTY
76497: LIST
76498: LIST
76499: LIST
76500: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
76501: LD_ADDR_VAR 0 47
76505: PUSH
76506: LD_INT 2
76508: NEG
76509: PUSH
76510: LD_INT 3
76512: NEG
76513: PUSH
76514: EMPTY
76515: LIST
76516: LIST
76517: PUSH
76518: LD_INT 1
76520: NEG
76521: PUSH
76522: LD_INT 3
76524: NEG
76525: PUSH
76526: EMPTY
76527: LIST
76528: LIST
76529: PUSH
76530: EMPTY
76531: LIST
76532: LIST
76533: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
76534: LD_ADDR_VAR 0 48
76538: PUSH
76539: LD_INT 1
76541: PUSH
76542: LD_INT 2
76544: NEG
76545: PUSH
76546: EMPTY
76547: LIST
76548: LIST
76549: PUSH
76550: LD_INT 2
76552: PUSH
76553: LD_INT 1
76555: NEG
76556: PUSH
76557: EMPTY
76558: LIST
76559: LIST
76560: PUSH
76561: EMPTY
76562: LIST
76563: LIST
76564: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
76565: LD_ADDR_VAR 0 49
76569: PUSH
76570: LD_INT 3
76572: PUSH
76573: LD_INT 1
76575: PUSH
76576: EMPTY
76577: LIST
76578: LIST
76579: PUSH
76580: LD_INT 3
76582: PUSH
76583: LD_INT 2
76585: PUSH
76586: EMPTY
76587: LIST
76588: LIST
76589: PUSH
76590: EMPTY
76591: LIST
76592: LIST
76593: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
76594: LD_ADDR_VAR 0 50
76598: PUSH
76599: LD_INT 2
76601: PUSH
76602: LD_INT 3
76604: PUSH
76605: EMPTY
76606: LIST
76607: LIST
76608: PUSH
76609: LD_INT 1
76611: PUSH
76612: LD_INT 3
76614: PUSH
76615: EMPTY
76616: LIST
76617: LIST
76618: PUSH
76619: EMPTY
76620: LIST
76621: LIST
76622: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
76623: LD_ADDR_VAR 0 51
76627: PUSH
76628: LD_INT 1
76630: NEG
76631: PUSH
76632: LD_INT 2
76634: PUSH
76635: EMPTY
76636: LIST
76637: LIST
76638: PUSH
76639: LD_INT 2
76641: NEG
76642: PUSH
76643: LD_INT 1
76645: PUSH
76646: EMPTY
76647: LIST
76648: LIST
76649: PUSH
76650: EMPTY
76651: LIST
76652: LIST
76653: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
76654: LD_ADDR_VAR 0 52
76658: PUSH
76659: LD_INT 3
76661: NEG
76662: PUSH
76663: LD_INT 1
76665: NEG
76666: PUSH
76667: EMPTY
76668: LIST
76669: LIST
76670: PUSH
76671: LD_INT 3
76673: NEG
76674: PUSH
76675: LD_INT 2
76677: NEG
76678: PUSH
76679: EMPTY
76680: LIST
76681: LIST
76682: PUSH
76683: EMPTY
76684: LIST
76685: LIST
76686: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
76687: LD_ADDR_VAR 0 53
76691: PUSH
76692: LD_INT 1
76694: NEG
76695: PUSH
76696: LD_INT 3
76698: NEG
76699: PUSH
76700: EMPTY
76701: LIST
76702: LIST
76703: PUSH
76704: LD_INT 0
76706: PUSH
76707: LD_INT 3
76709: NEG
76710: PUSH
76711: EMPTY
76712: LIST
76713: LIST
76714: PUSH
76715: LD_INT 1
76717: PUSH
76718: LD_INT 2
76720: NEG
76721: PUSH
76722: EMPTY
76723: LIST
76724: LIST
76725: PUSH
76726: EMPTY
76727: LIST
76728: LIST
76729: LIST
76730: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
76731: LD_ADDR_VAR 0 54
76735: PUSH
76736: LD_INT 2
76738: PUSH
76739: LD_INT 1
76741: NEG
76742: PUSH
76743: EMPTY
76744: LIST
76745: LIST
76746: PUSH
76747: LD_INT 3
76749: PUSH
76750: LD_INT 0
76752: PUSH
76753: EMPTY
76754: LIST
76755: LIST
76756: PUSH
76757: LD_INT 3
76759: PUSH
76760: LD_INT 1
76762: PUSH
76763: EMPTY
76764: LIST
76765: LIST
76766: PUSH
76767: EMPTY
76768: LIST
76769: LIST
76770: LIST
76771: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
76772: LD_ADDR_VAR 0 55
76776: PUSH
76777: LD_INT 3
76779: PUSH
76780: LD_INT 2
76782: PUSH
76783: EMPTY
76784: LIST
76785: LIST
76786: PUSH
76787: LD_INT 3
76789: PUSH
76790: LD_INT 3
76792: PUSH
76793: EMPTY
76794: LIST
76795: LIST
76796: PUSH
76797: LD_INT 2
76799: PUSH
76800: LD_INT 3
76802: PUSH
76803: EMPTY
76804: LIST
76805: LIST
76806: PUSH
76807: EMPTY
76808: LIST
76809: LIST
76810: LIST
76811: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
76812: LD_ADDR_VAR 0 56
76816: PUSH
76817: LD_INT 1
76819: PUSH
76820: LD_INT 3
76822: PUSH
76823: EMPTY
76824: LIST
76825: LIST
76826: PUSH
76827: LD_INT 0
76829: PUSH
76830: LD_INT 3
76832: PUSH
76833: EMPTY
76834: LIST
76835: LIST
76836: PUSH
76837: LD_INT 1
76839: NEG
76840: PUSH
76841: LD_INT 2
76843: PUSH
76844: EMPTY
76845: LIST
76846: LIST
76847: PUSH
76848: EMPTY
76849: LIST
76850: LIST
76851: LIST
76852: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
76853: LD_ADDR_VAR 0 57
76857: PUSH
76858: LD_INT 2
76860: NEG
76861: PUSH
76862: LD_INT 1
76864: PUSH
76865: EMPTY
76866: LIST
76867: LIST
76868: PUSH
76869: LD_INT 3
76871: NEG
76872: PUSH
76873: LD_INT 0
76875: PUSH
76876: EMPTY
76877: LIST
76878: LIST
76879: PUSH
76880: LD_INT 3
76882: NEG
76883: PUSH
76884: LD_INT 1
76886: NEG
76887: PUSH
76888: EMPTY
76889: LIST
76890: LIST
76891: PUSH
76892: EMPTY
76893: LIST
76894: LIST
76895: LIST
76896: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
76897: LD_ADDR_VAR 0 58
76901: PUSH
76902: LD_INT 2
76904: NEG
76905: PUSH
76906: LD_INT 3
76908: NEG
76909: PUSH
76910: EMPTY
76911: LIST
76912: LIST
76913: PUSH
76914: LD_INT 3
76916: NEG
76917: PUSH
76918: LD_INT 2
76920: NEG
76921: PUSH
76922: EMPTY
76923: LIST
76924: LIST
76925: PUSH
76926: LD_INT 3
76928: NEG
76929: PUSH
76930: LD_INT 3
76932: NEG
76933: PUSH
76934: EMPTY
76935: LIST
76936: LIST
76937: PUSH
76938: EMPTY
76939: LIST
76940: LIST
76941: LIST
76942: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
76943: LD_ADDR_VAR 0 59
76947: PUSH
76948: LD_INT 1
76950: NEG
76951: PUSH
76952: LD_INT 2
76954: NEG
76955: PUSH
76956: EMPTY
76957: LIST
76958: LIST
76959: PUSH
76960: LD_INT 0
76962: PUSH
76963: LD_INT 2
76965: NEG
76966: PUSH
76967: EMPTY
76968: LIST
76969: LIST
76970: PUSH
76971: LD_INT 1
76973: PUSH
76974: LD_INT 1
76976: NEG
76977: PUSH
76978: EMPTY
76979: LIST
76980: LIST
76981: PUSH
76982: EMPTY
76983: LIST
76984: LIST
76985: LIST
76986: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
76987: LD_ADDR_VAR 0 60
76991: PUSH
76992: LD_INT 1
76994: PUSH
76995: LD_INT 1
76997: NEG
76998: PUSH
76999: EMPTY
77000: LIST
77001: LIST
77002: PUSH
77003: LD_INT 2
77005: PUSH
77006: LD_INT 0
77008: PUSH
77009: EMPTY
77010: LIST
77011: LIST
77012: PUSH
77013: LD_INT 2
77015: PUSH
77016: LD_INT 1
77018: PUSH
77019: EMPTY
77020: LIST
77021: LIST
77022: PUSH
77023: EMPTY
77024: LIST
77025: LIST
77026: LIST
77027: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
77028: LD_ADDR_VAR 0 61
77032: PUSH
77033: LD_INT 2
77035: PUSH
77036: LD_INT 1
77038: PUSH
77039: EMPTY
77040: LIST
77041: LIST
77042: PUSH
77043: LD_INT 2
77045: PUSH
77046: LD_INT 2
77048: PUSH
77049: EMPTY
77050: LIST
77051: LIST
77052: PUSH
77053: LD_INT 1
77055: PUSH
77056: LD_INT 2
77058: PUSH
77059: EMPTY
77060: LIST
77061: LIST
77062: PUSH
77063: EMPTY
77064: LIST
77065: LIST
77066: LIST
77067: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
77068: LD_ADDR_VAR 0 62
77072: PUSH
77073: LD_INT 1
77075: PUSH
77076: LD_INT 2
77078: PUSH
77079: EMPTY
77080: LIST
77081: LIST
77082: PUSH
77083: LD_INT 0
77085: PUSH
77086: LD_INT 2
77088: PUSH
77089: EMPTY
77090: LIST
77091: LIST
77092: PUSH
77093: LD_INT 1
77095: NEG
77096: PUSH
77097: LD_INT 1
77099: PUSH
77100: EMPTY
77101: LIST
77102: LIST
77103: PUSH
77104: EMPTY
77105: LIST
77106: LIST
77107: LIST
77108: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
77109: LD_ADDR_VAR 0 63
77113: PUSH
77114: LD_INT 1
77116: NEG
77117: PUSH
77118: LD_INT 1
77120: PUSH
77121: EMPTY
77122: LIST
77123: LIST
77124: PUSH
77125: LD_INT 2
77127: NEG
77128: PUSH
77129: LD_INT 0
77131: PUSH
77132: EMPTY
77133: LIST
77134: LIST
77135: PUSH
77136: LD_INT 2
77138: NEG
77139: PUSH
77140: LD_INT 1
77142: NEG
77143: PUSH
77144: EMPTY
77145: LIST
77146: LIST
77147: PUSH
77148: EMPTY
77149: LIST
77150: LIST
77151: LIST
77152: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77153: LD_ADDR_VAR 0 64
77157: PUSH
77158: LD_INT 1
77160: NEG
77161: PUSH
77162: LD_INT 2
77164: NEG
77165: PUSH
77166: EMPTY
77167: LIST
77168: LIST
77169: PUSH
77170: LD_INT 2
77172: NEG
77173: PUSH
77174: LD_INT 1
77176: NEG
77177: PUSH
77178: EMPTY
77179: LIST
77180: LIST
77181: PUSH
77182: LD_INT 2
77184: NEG
77185: PUSH
77186: LD_INT 2
77188: NEG
77189: PUSH
77190: EMPTY
77191: LIST
77192: LIST
77193: PUSH
77194: EMPTY
77195: LIST
77196: LIST
77197: LIST
77198: ST_TO_ADDR
// end ; 2 :
77199: GO 80465
77201: LD_INT 2
77203: DOUBLE
77204: EQUAL
77205: IFTRUE 77209
77207: GO 80464
77209: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
77210: LD_ADDR_VAR 0 29
77214: PUSH
77215: LD_INT 4
77217: PUSH
77218: LD_INT 0
77220: PUSH
77221: EMPTY
77222: LIST
77223: LIST
77224: PUSH
77225: LD_INT 4
77227: PUSH
77228: LD_INT 1
77230: NEG
77231: PUSH
77232: EMPTY
77233: LIST
77234: LIST
77235: PUSH
77236: LD_INT 5
77238: PUSH
77239: LD_INT 0
77241: PUSH
77242: EMPTY
77243: LIST
77244: LIST
77245: PUSH
77246: LD_INT 5
77248: PUSH
77249: LD_INT 1
77251: PUSH
77252: EMPTY
77253: LIST
77254: LIST
77255: PUSH
77256: LD_INT 4
77258: PUSH
77259: LD_INT 1
77261: PUSH
77262: EMPTY
77263: LIST
77264: LIST
77265: PUSH
77266: LD_INT 3
77268: PUSH
77269: LD_INT 0
77271: PUSH
77272: EMPTY
77273: LIST
77274: LIST
77275: PUSH
77276: LD_INT 3
77278: PUSH
77279: LD_INT 1
77281: NEG
77282: PUSH
77283: EMPTY
77284: LIST
77285: LIST
77286: PUSH
77287: LD_INT 3
77289: PUSH
77290: LD_INT 2
77292: NEG
77293: PUSH
77294: EMPTY
77295: LIST
77296: LIST
77297: PUSH
77298: LD_INT 5
77300: PUSH
77301: LD_INT 2
77303: PUSH
77304: EMPTY
77305: LIST
77306: LIST
77307: PUSH
77308: LD_INT 3
77310: PUSH
77311: LD_INT 3
77313: PUSH
77314: EMPTY
77315: LIST
77316: LIST
77317: PUSH
77318: LD_INT 3
77320: PUSH
77321: LD_INT 2
77323: PUSH
77324: EMPTY
77325: LIST
77326: LIST
77327: PUSH
77328: LD_INT 4
77330: PUSH
77331: LD_INT 3
77333: PUSH
77334: EMPTY
77335: LIST
77336: LIST
77337: PUSH
77338: LD_INT 4
77340: PUSH
77341: LD_INT 4
77343: PUSH
77344: EMPTY
77345: LIST
77346: LIST
77347: PUSH
77348: LD_INT 3
77350: PUSH
77351: LD_INT 4
77353: PUSH
77354: EMPTY
77355: LIST
77356: LIST
77357: PUSH
77358: LD_INT 2
77360: PUSH
77361: LD_INT 3
77363: PUSH
77364: EMPTY
77365: LIST
77366: LIST
77367: PUSH
77368: LD_INT 2
77370: PUSH
77371: LD_INT 2
77373: PUSH
77374: EMPTY
77375: LIST
77376: LIST
77377: PUSH
77378: LD_INT 4
77380: PUSH
77381: LD_INT 2
77383: PUSH
77384: EMPTY
77385: LIST
77386: LIST
77387: PUSH
77388: LD_INT 2
77390: PUSH
77391: LD_INT 4
77393: PUSH
77394: EMPTY
77395: LIST
77396: LIST
77397: PUSH
77398: LD_INT 0
77400: PUSH
77401: LD_INT 4
77403: PUSH
77404: EMPTY
77405: LIST
77406: LIST
77407: PUSH
77408: LD_INT 0
77410: PUSH
77411: LD_INT 3
77413: PUSH
77414: EMPTY
77415: LIST
77416: LIST
77417: PUSH
77418: LD_INT 1
77420: PUSH
77421: LD_INT 4
77423: PUSH
77424: EMPTY
77425: LIST
77426: LIST
77427: PUSH
77428: LD_INT 1
77430: PUSH
77431: LD_INT 5
77433: PUSH
77434: EMPTY
77435: LIST
77436: LIST
77437: PUSH
77438: LD_INT 0
77440: PUSH
77441: LD_INT 5
77443: PUSH
77444: EMPTY
77445: LIST
77446: LIST
77447: PUSH
77448: LD_INT 1
77450: NEG
77451: PUSH
77452: LD_INT 4
77454: PUSH
77455: EMPTY
77456: LIST
77457: LIST
77458: PUSH
77459: LD_INT 1
77461: NEG
77462: PUSH
77463: LD_INT 3
77465: PUSH
77466: EMPTY
77467: LIST
77468: LIST
77469: PUSH
77470: LD_INT 2
77472: PUSH
77473: LD_INT 5
77475: PUSH
77476: EMPTY
77477: LIST
77478: LIST
77479: PUSH
77480: LD_INT 2
77482: NEG
77483: PUSH
77484: LD_INT 3
77486: PUSH
77487: EMPTY
77488: LIST
77489: LIST
77490: PUSH
77491: LD_INT 3
77493: NEG
77494: PUSH
77495: LD_INT 0
77497: PUSH
77498: EMPTY
77499: LIST
77500: LIST
77501: PUSH
77502: LD_INT 3
77504: NEG
77505: PUSH
77506: LD_INT 1
77508: NEG
77509: PUSH
77510: EMPTY
77511: LIST
77512: LIST
77513: PUSH
77514: LD_INT 2
77516: NEG
77517: PUSH
77518: LD_INT 0
77520: PUSH
77521: EMPTY
77522: LIST
77523: LIST
77524: PUSH
77525: LD_INT 2
77527: NEG
77528: PUSH
77529: LD_INT 1
77531: PUSH
77532: EMPTY
77533: LIST
77534: LIST
77535: PUSH
77536: LD_INT 3
77538: NEG
77539: PUSH
77540: LD_INT 1
77542: PUSH
77543: EMPTY
77544: LIST
77545: LIST
77546: PUSH
77547: LD_INT 4
77549: NEG
77550: PUSH
77551: LD_INT 0
77553: PUSH
77554: EMPTY
77555: LIST
77556: LIST
77557: PUSH
77558: LD_INT 4
77560: NEG
77561: PUSH
77562: LD_INT 1
77564: NEG
77565: PUSH
77566: EMPTY
77567: LIST
77568: LIST
77569: PUSH
77570: LD_INT 4
77572: NEG
77573: PUSH
77574: LD_INT 2
77576: NEG
77577: PUSH
77578: EMPTY
77579: LIST
77580: LIST
77581: PUSH
77582: LD_INT 2
77584: NEG
77585: PUSH
77586: LD_INT 2
77588: PUSH
77589: EMPTY
77590: LIST
77591: LIST
77592: PUSH
77593: LD_INT 4
77595: NEG
77596: PUSH
77597: LD_INT 4
77599: NEG
77600: PUSH
77601: EMPTY
77602: LIST
77603: LIST
77604: PUSH
77605: LD_INT 4
77607: NEG
77608: PUSH
77609: LD_INT 5
77611: NEG
77612: PUSH
77613: EMPTY
77614: LIST
77615: LIST
77616: PUSH
77617: LD_INT 3
77619: NEG
77620: PUSH
77621: LD_INT 4
77623: NEG
77624: PUSH
77625: EMPTY
77626: LIST
77627: LIST
77628: PUSH
77629: LD_INT 3
77631: NEG
77632: PUSH
77633: LD_INT 3
77635: NEG
77636: PUSH
77637: EMPTY
77638: LIST
77639: LIST
77640: PUSH
77641: LD_INT 4
77643: NEG
77644: PUSH
77645: LD_INT 3
77647: NEG
77648: PUSH
77649: EMPTY
77650: LIST
77651: LIST
77652: PUSH
77653: LD_INT 5
77655: NEG
77656: PUSH
77657: LD_INT 4
77659: NEG
77660: PUSH
77661: EMPTY
77662: LIST
77663: LIST
77664: PUSH
77665: LD_INT 5
77667: NEG
77668: PUSH
77669: LD_INT 5
77671: NEG
77672: PUSH
77673: EMPTY
77674: LIST
77675: LIST
77676: PUSH
77677: LD_INT 3
77679: NEG
77680: PUSH
77681: LD_INT 5
77683: NEG
77684: PUSH
77685: EMPTY
77686: LIST
77687: LIST
77688: PUSH
77689: LD_INT 5
77691: NEG
77692: PUSH
77693: LD_INT 3
77695: NEG
77696: PUSH
77697: EMPTY
77698: LIST
77699: LIST
77700: PUSH
77701: EMPTY
77702: LIST
77703: LIST
77704: LIST
77705: LIST
77706: LIST
77707: LIST
77708: LIST
77709: LIST
77710: LIST
77711: LIST
77712: LIST
77713: LIST
77714: LIST
77715: LIST
77716: LIST
77717: LIST
77718: LIST
77719: LIST
77720: LIST
77721: LIST
77722: LIST
77723: LIST
77724: LIST
77725: LIST
77726: LIST
77727: LIST
77728: LIST
77729: LIST
77730: LIST
77731: LIST
77732: LIST
77733: LIST
77734: LIST
77735: LIST
77736: LIST
77737: LIST
77738: LIST
77739: LIST
77740: LIST
77741: LIST
77742: LIST
77743: LIST
77744: LIST
77745: LIST
77746: LIST
77747: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
77748: LD_ADDR_VAR 0 30
77752: PUSH
77753: LD_INT 4
77755: PUSH
77756: LD_INT 4
77758: PUSH
77759: EMPTY
77760: LIST
77761: LIST
77762: PUSH
77763: LD_INT 4
77765: PUSH
77766: LD_INT 3
77768: PUSH
77769: EMPTY
77770: LIST
77771: LIST
77772: PUSH
77773: LD_INT 5
77775: PUSH
77776: LD_INT 4
77778: PUSH
77779: EMPTY
77780: LIST
77781: LIST
77782: PUSH
77783: LD_INT 5
77785: PUSH
77786: LD_INT 5
77788: PUSH
77789: EMPTY
77790: LIST
77791: LIST
77792: PUSH
77793: LD_INT 4
77795: PUSH
77796: LD_INT 5
77798: PUSH
77799: EMPTY
77800: LIST
77801: LIST
77802: PUSH
77803: LD_INT 3
77805: PUSH
77806: LD_INT 4
77808: PUSH
77809: EMPTY
77810: LIST
77811: LIST
77812: PUSH
77813: LD_INT 3
77815: PUSH
77816: LD_INT 3
77818: PUSH
77819: EMPTY
77820: LIST
77821: LIST
77822: PUSH
77823: LD_INT 5
77825: PUSH
77826: LD_INT 3
77828: PUSH
77829: EMPTY
77830: LIST
77831: LIST
77832: PUSH
77833: LD_INT 3
77835: PUSH
77836: LD_INT 5
77838: PUSH
77839: EMPTY
77840: LIST
77841: LIST
77842: PUSH
77843: LD_INT 0
77845: PUSH
77846: LD_INT 3
77848: PUSH
77849: EMPTY
77850: LIST
77851: LIST
77852: PUSH
77853: LD_INT 0
77855: PUSH
77856: LD_INT 2
77858: PUSH
77859: EMPTY
77860: LIST
77861: LIST
77862: PUSH
77863: LD_INT 1
77865: PUSH
77866: LD_INT 3
77868: PUSH
77869: EMPTY
77870: LIST
77871: LIST
77872: PUSH
77873: LD_INT 1
77875: PUSH
77876: LD_INT 4
77878: PUSH
77879: EMPTY
77880: LIST
77881: LIST
77882: PUSH
77883: LD_INT 0
77885: PUSH
77886: LD_INT 4
77888: PUSH
77889: EMPTY
77890: LIST
77891: LIST
77892: PUSH
77893: LD_INT 1
77895: NEG
77896: PUSH
77897: LD_INT 3
77899: PUSH
77900: EMPTY
77901: LIST
77902: LIST
77903: PUSH
77904: LD_INT 1
77906: NEG
77907: PUSH
77908: LD_INT 2
77910: PUSH
77911: EMPTY
77912: LIST
77913: LIST
77914: PUSH
77915: LD_INT 2
77917: PUSH
77918: LD_INT 4
77920: PUSH
77921: EMPTY
77922: LIST
77923: LIST
77924: PUSH
77925: LD_INT 2
77927: NEG
77928: PUSH
77929: LD_INT 2
77931: PUSH
77932: EMPTY
77933: LIST
77934: LIST
77935: PUSH
77936: LD_INT 4
77938: NEG
77939: PUSH
77940: LD_INT 0
77942: PUSH
77943: EMPTY
77944: LIST
77945: LIST
77946: PUSH
77947: LD_INT 4
77949: NEG
77950: PUSH
77951: LD_INT 1
77953: NEG
77954: PUSH
77955: EMPTY
77956: LIST
77957: LIST
77958: PUSH
77959: LD_INT 3
77961: NEG
77962: PUSH
77963: LD_INT 0
77965: PUSH
77966: EMPTY
77967: LIST
77968: LIST
77969: PUSH
77970: LD_INT 3
77972: NEG
77973: PUSH
77974: LD_INT 1
77976: PUSH
77977: EMPTY
77978: LIST
77979: LIST
77980: PUSH
77981: LD_INT 4
77983: NEG
77984: PUSH
77985: LD_INT 1
77987: PUSH
77988: EMPTY
77989: LIST
77990: LIST
77991: PUSH
77992: LD_INT 5
77994: NEG
77995: PUSH
77996: LD_INT 0
77998: PUSH
77999: EMPTY
78000: LIST
78001: LIST
78002: PUSH
78003: LD_INT 5
78005: NEG
78006: PUSH
78007: LD_INT 1
78009: NEG
78010: PUSH
78011: EMPTY
78012: LIST
78013: LIST
78014: PUSH
78015: LD_INT 5
78017: NEG
78018: PUSH
78019: LD_INT 2
78021: NEG
78022: PUSH
78023: EMPTY
78024: LIST
78025: LIST
78026: PUSH
78027: LD_INT 3
78029: NEG
78030: PUSH
78031: LD_INT 2
78033: PUSH
78034: EMPTY
78035: LIST
78036: LIST
78037: PUSH
78038: LD_INT 3
78040: NEG
78041: PUSH
78042: LD_INT 3
78044: NEG
78045: PUSH
78046: EMPTY
78047: LIST
78048: LIST
78049: PUSH
78050: LD_INT 3
78052: NEG
78053: PUSH
78054: LD_INT 4
78056: NEG
78057: PUSH
78058: EMPTY
78059: LIST
78060: LIST
78061: PUSH
78062: LD_INT 2
78064: NEG
78065: PUSH
78066: LD_INT 3
78068: NEG
78069: PUSH
78070: EMPTY
78071: LIST
78072: LIST
78073: PUSH
78074: LD_INT 2
78076: NEG
78077: PUSH
78078: LD_INT 2
78080: NEG
78081: PUSH
78082: EMPTY
78083: LIST
78084: LIST
78085: PUSH
78086: LD_INT 3
78088: NEG
78089: PUSH
78090: LD_INT 2
78092: NEG
78093: PUSH
78094: EMPTY
78095: LIST
78096: LIST
78097: PUSH
78098: LD_INT 4
78100: NEG
78101: PUSH
78102: LD_INT 3
78104: NEG
78105: PUSH
78106: EMPTY
78107: LIST
78108: LIST
78109: PUSH
78110: LD_INT 4
78112: NEG
78113: PUSH
78114: LD_INT 4
78116: NEG
78117: PUSH
78118: EMPTY
78119: LIST
78120: LIST
78121: PUSH
78122: LD_INT 2
78124: NEG
78125: PUSH
78126: LD_INT 4
78128: NEG
78129: PUSH
78130: EMPTY
78131: LIST
78132: LIST
78133: PUSH
78134: LD_INT 4
78136: NEG
78137: PUSH
78138: LD_INT 2
78140: NEG
78141: PUSH
78142: EMPTY
78143: LIST
78144: LIST
78145: PUSH
78146: LD_INT 0
78148: PUSH
78149: LD_INT 4
78151: NEG
78152: PUSH
78153: EMPTY
78154: LIST
78155: LIST
78156: PUSH
78157: LD_INT 0
78159: PUSH
78160: LD_INT 5
78162: NEG
78163: PUSH
78164: EMPTY
78165: LIST
78166: LIST
78167: PUSH
78168: LD_INT 1
78170: PUSH
78171: LD_INT 4
78173: NEG
78174: PUSH
78175: EMPTY
78176: LIST
78177: LIST
78178: PUSH
78179: LD_INT 1
78181: PUSH
78182: LD_INT 3
78184: NEG
78185: PUSH
78186: EMPTY
78187: LIST
78188: LIST
78189: PUSH
78190: LD_INT 0
78192: PUSH
78193: LD_INT 3
78195: NEG
78196: PUSH
78197: EMPTY
78198: LIST
78199: LIST
78200: PUSH
78201: LD_INT 1
78203: NEG
78204: PUSH
78205: LD_INT 4
78207: NEG
78208: PUSH
78209: EMPTY
78210: LIST
78211: LIST
78212: PUSH
78213: LD_INT 1
78215: NEG
78216: PUSH
78217: LD_INT 5
78219: NEG
78220: PUSH
78221: EMPTY
78222: LIST
78223: LIST
78224: PUSH
78225: LD_INT 2
78227: PUSH
78228: LD_INT 3
78230: NEG
78231: PUSH
78232: EMPTY
78233: LIST
78234: LIST
78235: PUSH
78236: LD_INT 2
78238: NEG
78239: PUSH
78240: LD_INT 5
78242: NEG
78243: PUSH
78244: EMPTY
78245: LIST
78246: LIST
78247: PUSH
78248: EMPTY
78249: LIST
78250: LIST
78251: LIST
78252: LIST
78253: LIST
78254: LIST
78255: LIST
78256: LIST
78257: LIST
78258: LIST
78259: LIST
78260: LIST
78261: LIST
78262: LIST
78263: LIST
78264: LIST
78265: LIST
78266: LIST
78267: LIST
78268: LIST
78269: LIST
78270: LIST
78271: LIST
78272: LIST
78273: LIST
78274: LIST
78275: LIST
78276: LIST
78277: LIST
78278: LIST
78279: LIST
78280: LIST
78281: LIST
78282: LIST
78283: LIST
78284: LIST
78285: LIST
78286: LIST
78287: LIST
78288: LIST
78289: LIST
78290: LIST
78291: LIST
78292: LIST
78293: LIST
78294: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
78295: LD_ADDR_VAR 0 31
78299: PUSH
78300: LD_INT 0
78302: PUSH
78303: LD_INT 4
78305: PUSH
78306: EMPTY
78307: LIST
78308: LIST
78309: PUSH
78310: LD_INT 0
78312: PUSH
78313: LD_INT 3
78315: PUSH
78316: EMPTY
78317: LIST
78318: LIST
78319: PUSH
78320: LD_INT 1
78322: PUSH
78323: LD_INT 4
78325: PUSH
78326: EMPTY
78327: LIST
78328: LIST
78329: PUSH
78330: LD_INT 1
78332: PUSH
78333: LD_INT 5
78335: PUSH
78336: EMPTY
78337: LIST
78338: LIST
78339: PUSH
78340: LD_INT 0
78342: PUSH
78343: LD_INT 5
78345: PUSH
78346: EMPTY
78347: LIST
78348: LIST
78349: PUSH
78350: LD_INT 1
78352: NEG
78353: PUSH
78354: LD_INT 4
78356: PUSH
78357: EMPTY
78358: LIST
78359: LIST
78360: PUSH
78361: LD_INT 1
78363: NEG
78364: PUSH
78365: LD_INT 3
78367: PUSH
78368: EMPTY
78369: LIST
78370: LIST
78371: PUSH
78372: LD_INT 2
78374: PUSH
78375: LD_INT 5
78377: PUSH
78378: EMPTY
78379: LIST
78380: LIST
78381: PUSH
78382: LD_INT 2
78384: NEG
78385: PUSH
78386: LD_INT 3
78388: PUSH
78389: EMPTY
78390: LIST
78391: LIST
78392: PUSH
78393: LD_INT 3
78395: NEG
78396: PUSH
78397: LD_INT 0
78399: PUSH
78400: EMPTY
78401: LIST
78402: LIST
78403: PUSH
78404: LD_INT 3
78406: NEG
78407: PUSH
78408: LD_INT 1
78410: NEG
78411: PUSH
78412: EMPTY
78413: LIST
78414: LIST
78415: PUSH
78416: LD_INT 2
78418: NEG
78419: PUSH
78420: LD_INT 0
78422: PUSH
78423: EMPTY
78424: LIST
78425: LIST
78426: PUSH
78427: LD_INT 2
78429: NEG
78430: PUSH
78431: LD_INT 1
78433: PUSH
78434: EMPTY
78435: LIST
78436: LIST
78437: PUSH
78438: LD_INT 3
78440: NEG
78441: PUSH
78442: LD_INT 1
78444: PUSH
78445: EMPTY
78446: LIST
78447: LIST
78448: PUSH
78449: LD_INT 4
78451: NEG
78452: PUSH
78453: LD_INT 0
78455: PUSH
78456: EMPTY
78457: LIST
78458: LIST
78459: PUSH
78460: LD_INT 4
78462: NEG
78463: PUSH
78464: LD_INT 1
78466: NEG
78467: PUSH
78468: EMPTY
78469: LIST
78470: LIST
78471: PUSH
78472: LD_INT 4
78474: NEG
78475: PUSH
78476: LD_INT 2
78478: NEG
78479: PUSH
78480: EMPTY
78481: LIST
78482: LIST
78483: PUSH
78484: LD_INT 2
78486: NEG
78487: PUSH
78488: LD_INT 2
78490: PUSH
78491: EMPTY
78492: LIST
78493: LIST
78494: PUSH
78495: LD_INT 4
78497: NEG
78498: PUSH
78499: LD_INT 4
78501: NEG
78502: PUSH
78503: EMPTY
78504: LIST
78505: LIST
78506: PUSH
78507: LD_INT 4
78509: NEG
78510: PUSH
78511: LD_INT 5
78513: NEG
78514: PUSH
78515: EMPTY
78516: LIST
78517: LIST
78518: PUSH
78519: LD_INT 3
78521: NEG
78522: PUSH
78523: LD_INT 4
78525: NEG
78526: PUSH
78527: EMPTY
78528: LIST
78529: LIST
78530: PUSH
78531: LD_INT 3
78533: NEG
78534: PUSH
78535: LD_INT 3
78537: NEG
78538: PUSH
78539: EMPTY
78540: LIST
78541: LIST
78542: PUSH
78543: LD_INT 4
78545: NEG
78546: PUSH
78547: LD_INT 3
78549: NEG
78550: PUSH
78551: EMPTY
78552: LIST
78553: LIST
78554: PUSH
78555: LD_INT 5
78557: NEG
78558: PUSH
78559: LD_INT 4
78561: NEG
78562: PUSH
78563: EMPTY
78564: LIST
78565: LIST
78566: PUSH
78567: LD_INT 5
78569: NEG
78570: PUSH
78571: LD_INT 5
78573: NEG
78574: PUSH
78575: EMPTY
78576: LIST
78577: LIST
78578: PUSH
78579: LD_INT 3
78581: NEG
78582: PUSH
78583: LD_INT 5
78585: NEG
78586: PUSH
78587: EMPTY
78588: LIST
78589: LIST
78590: PUSH
78591: LD_INT 5
78593: NEG
78594: PUSH
78595: LD_INT 3
78597: NEG
78598: PUSH
78599: EMPTY
78600: LIST
78601: LIST
78602: PUSH
78603: LD_INT 0
78605: PUSH
78606: LD_INT 3
78608: NEG
78609: PUSH
78610: EMPTY
78611: LIST
78612: LIST
78613: PUSH
78614: LD_INT 0
78616: PUSH
78617: LD_INT 4
78619: NEG
78620: PUSH
78621: EMPTY
78622: LIST
78623: LIST
78624: PUSH
78625: LD_INT 1
78627: PUSH
78628: LD_INT 3
78630: NEG
78631: PUSH
78632: EMPTY
78633: LIST
78634: LIST
78635: PUSH
78636: LD_INT 1
78638: PUSH
78639: LD_INT 2
78641: NEG
78642: PUSH
78643: EMPTY
78644: LIST
78645: LIST
78646: PUSH
78647: LD_INT 0
78649: PUSH
78650: LD_INT 2
78652: NEG
78653: PUSH
78654: EMPTY
78655: LIST
78656: LIST
78657: PUSH
78658: LD_INT 1
78660: NEG
78661: PUSH
78662: LD_INT 3
78664: NEG
78665: PUSH
78666: EMPTY
78667: LIST
78668: LIST
78669: PUSH
78670: LD_INT 1
78672: NEG
78673: PUSH
78674: LD_INT 4
78676: NEG
78677: PUSH
78678: EMPTY
78679: LIST
78680: LIST
78681: PUSH
78682: LD_INT 2
78684: PUSH
78685: LD_INT 2
78687: NEG
78688: PUSH
78689: EMPTY
78690: LIST
78691: LIST
78692: PUSH
78693: LD_INT 2
78695: NEG
78696: PUSH
78697: LD_INT 4
78699: NEG
78700: PUSH
78701: EMPTY
78702: LIST
78703: LIST
78704: PUSH
78705: LD_INT 4
78707: PUSH
78708: LD_INT 0
78710: PUSH
78711: EMPTY
78712: LIST
78713: LIST
78714: PUSH
78715: LD_INT 4
78717: PUSH
78718: LD_INT 1
78720: NEG
78721: PUSH
78722: EMPTY
78723: LIST
78724: LIST
78725: PUSH
78726: LD_INT 5
78728: PUSH
78729: LD_INT 0
78731: PUSH
78732: EMPTY
78733: LIST
78734: LIST
78735: PUSH
78736: LD_INT 5
78738: PUSH
78739: LD_INT 1
78741: PUSH
78742: EMPTY
78743: LIST
78744: LIST
78745: PUSH
78746: LD_INT 4
78748: PUSH
78749: LD_INT 1
78751: PUSH
78752: EMPTY
78753: LIST
78754: LIST
78755: PUSH
78756: LD_INT 3
78758: PUSH
78759: LD_INT 0
78761: PUSH
78762: EMPTY
78763: LIST
78764: LIST
78765: PUSH
78766: LD_INT 3
78768: PUSH
78769: LD_INT 1
78771: NEG
78772: PUSH
78773: EMPTY
78774: LIST
78775: LIST
78776: PUSH
78777: LD_INT 3
78779: PUSH
78780: LD_INT 2
78782: NEG
78783: PUSH
78784: EMPTY
78785: LIST
78786: LIST
78787: PUSH
78788: LD_INT 5
78790: PUSH
78791: LD_INT 2
78793: PUSH
78794: EMPTY
78795: LIST
78796: LIST
78797: PUSH
78798: EMPTY
78799: LIST
78800: LIST
78801: LIST
78802: LIST
78803: LIST
78804: LIST
78805: LIST
78806: LIST
78807: LIST
78808: LIST
78809: LIST
78810: LIST
78811: LIST
78812: LIST
78813: LIST
78814: LIST
78815: LIST
78816: LIST
78817: LIST
78818: LIST
78819: LIST
78820: LIST
78821: LIST
78822: LIST
78823: LIST
78824: LIST
78825: LIST
78826: LIST
78827: LIST
78828: LIST
78829: LIST
78830: LIST
78831: LIST
78832: LIST
78833: LIST
78834: LIST
78835: LIST
78836: LIST
78837: LIST
78838: LIST
78839: LIST
78840: LIST
78841: LIST
78842: LIST
78843: LIST
78844: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
78845: LD_ADDR_VAR 0 32
78849: PUSH
78850: LD_INT 4
78852: NEG
78853: PUSH
78854: LD_INT 0
78856: PUSH
78857: EMPTY
78858: LIST
78859: LIST
78860: PUSH
78861: LD_INT 4
78863: NEG
78864: PUSH
78865: LD_INT 1
78867: NEG
78868: PUSH
78869: EMPTY
78870: LIST
78871: LIST
78872: PUSH
78873: LD_INT 3
78875: NEG
78876: PUSH
78877: LD_INT 0
78879: PUSH
78880: EMPTY
78881: LIST
78882: LIST
78883: PUSH
78884: LD_INT 3
78886: NEG
78887: PUSH
78888: LD_INT 1
78890: PUSH
78891: EMPTY
78892: LIST
78893: LIST
78894: PUSH
78895: LD_INT 4
78897: NEG
78898: PUSH
78899: LD_INT 1
78901: PUSH
78902: EMPTY
78903: LIST
78904: LIST
78905: PUSH
78906: LD_INT 5
78908: NEG
78909: PUSH
78910: LD_INT 0
78912: PUSH
78913: EMPTY
78914: LIST
78915: LIST
78916: PUSH
78917: LD_INT 5
78919: NEG
78920: PUSH
78921: LD_INT 1
78923: NEG
78924: PUSH
78925: EMPTY
78926: LIST
78927: LIST
78928: PUSH
78929: LD_INT 5
78931: NEG
78932: PUSH
78933: LD_INT 2
78935: NEG
78936: PUSH
78937: EMPTY
78938: LIST
78939: LIST
78940: PUSH
78941: LD_INT 3
78943: NEG
78944: PUSH
78945: LD_INT 2
78947: PUSH
78948: EMPTY
78949: LIST
78950: LIST
78951: PUSH
78952: LD_INT 3
78954: NEG
78955: PUSH
78956: LD_INT 3
78958: NEG
78959: PUSH
78960: EMPTY
78961: LIST
78962: LIST
78963: PUSH
78964: LD_INT 3
78966: NEG
78967: PUSH
78968: LD_INT 4
78970: NEG
78971: PUSH
78972: EMPTY
78973: LIST
78974: LIST
78975: PUSH
78976: LD_INT 2
78978: NEG
78979: PUSH
78980: LD_INT 3
78982: NEG
78983: PUSH
78984: EMPTY
78985: LIST
78986: LIST
78987: PUSH
78988: LD_INT 2
78990: NEG
78991: PUSH
78992: LD_INT 2
78994: NEG
78995: PUSH
78996: EMPTY
78997: LIST
78998: LIST
78999: PUSH
79000: LD_INT 3
79002: NEG
79003: PUSH
79004: LD_INT 2
79006: NEG
79007: PUSH
79008: EMPTY
79009: LIST
79010: LIST
79011: PUSH
79012: LD_INT 4
79014: NEG
79015: PUSH
79016: LD_INT 3
79018: NEG
79019: PUSH
79020: EMPTY
79021: LIST
79022: LIST
79023: PUSH
79024: LD_INT 4
79026: NEG
79027: PUSH
79028: LD_INT 4
79030: NEG
79031: PUSH
79032: EMPTY
79033: LIST
79034: LIST
79035: PUSH
79036: LD_INT 2
79038: NEG
79039: PUSH
79040: LD_INT 4
79042: NEG
79043: PUSH
79044: EMPTY
79045: LIST
79046: LIST
79047: PUSH
79048: LD_INT 4
79050: NEG
79051: PUSH
79052: LD_INT 2
79054: NEG
79055: PUSH
79056: EMPTY
79057: LIST
79058: LIST
79059: PUSH
79060: LD_INT 0
79062: PUSH
79063: LD_INT 4
79065: NEG
79066: PUSH
79067: EMPTY
79068: LIST
79069: LIST
79070: PUSH
79071: LD_INT 0
79073: PUSH
79074: LD_INT 5
79076: NEG
79077: PUSH
79078: EMPTY
79079: LIST
79080: LIST
79081: PUSH
79082: LD_INT 1
79084: PUSH
79085: LD_INT 4
79087: NEG
79088: PUSH
79089: EMPTY
79090: LIST
79091: LIST
79092: PUSH
79093: LD_INT 1
79095: PUSH
79096: LD_INT 3
79098: NEG
79099: PUSH
79100: EMPTY
79101: LIST
79102: LIST
79103: PUSH
79104: LD_INT 0
79106: PUSH
79107: LD_INT 3
79109: NEG
79110: PUSH
79111: EMPTY
79112: LIST
79113: LIST
79114: PUSH
79115: LD_INT 1
79117: NEG
79118: PUSH
79119: LD_INT 4
79121: NEG
79122: PUSH
79123: EMPTY
79124: LIST
79125: LIST
79126: PUSH
79127: LD_INT 1
79129: NEG
79130: PUSH
79131: LD_INT 5
79133: NEG
79134: PUSH
79135: EMPTY
79136: LIST
79137: LIST
79138: PUSH
79139: LD_INT 2
79141: PUSH
79142: LD_INT 3
79144: NEG
79145: PUSH
79146: EMPTY
79147: LIST
79148: LIST
79149: PUSH
79150: LD_INT 2
79152: NEG
79153: PUSH
79154: LD_INT 5
79156: NEG
79157: PUSH
79158: EMPTY
79159: LIST
79160: LIST
79161: PUSH
79162: LD_INT 3
79164: PUSH
79165: LD_INT 0
79167: PUSH
79168: EMPTY
79169: LIST
79170: LIST
79171: PUSH
79172: LD_INT 3
79174: PUSH
79175: LD_INT 1
79177: NEG
79178: PUSH
79179: EMPTY
79180: LIST
79181: LIST
79182: PUSH
79183: LD_INT 4
79185: PUSH
79186: LD_INT 0
79188: PUSH
79189: EMPTY
79190: LIST
79191: LIST
79192: PUSH
79193: LD_INT 4
79195: PUSH
79196: LD_INT 1
79198: PUSH
79199: EMPTY
79200: LIST
79201: LIST
79202: PUSH
79203: LD_INT 3
79205: PUSH
79206: LD_INT 1
79208: PUSH
79209: EMPTY
79210: LIST
79211: LIST
79212: PUSH
79213: LD_INT 2
79215: PUSH
79216: LD_INT 0
79218: PUSH
79219: EMPTY
79220: LIST
79221: LIST
79222: PUSH
79223: LD_INT 2
79225: PUSH
79226: LD_INT 1
79228: NEG
79229: PUSH
79230: EMPTY
79231: LIST
79232: LIST
79233: PUSH
79234: LD_INT 2
79236: PUSH
79237: LD_INT 2
79239: NEG
79240: PUSH
79241: EMPTY
79242: LIST
79243: LIST
79244: PUSH
79245: LD_INT 4
79247: PUSH
79248: LD_INT 2
79250: PUSH
79251: EMPTY
79252: LIST
79253: LIST
79254: PUSH
79255: LD_INT 4
79257: PUSH
79258: LD_INT 4
79260: PUSH
79261: EMPTY
79262: LIST
79263: LIST
79264: PUSH
79265: LD_INT 4
79267: PUSH
79268: LD_INT 3
79270: PUSH
79271: EMPTY
79272: LIST
79273: LIST
79274: PUSH
79275: LD_INT 5
79277: PUSH
79278: LD_INT 4
79280: PUSH
79281: EMPTY
79282: LIST
79283: LIST
79284: PUSH
79285: LD_INT 5
79287: PUSH
79288: LD_INT 5
79290: PUSH
79291: EMPTY
79292: LIST
79293: LIST
79294: PUSH
79295: LD_INT 4
79297: PUSH
79298: LD_INT 5
79300: PUSH
79301: EMPTY
79302: LIST
79303: LIST
79304: PUSH
79305: LD_INT 3
79307: PUSH
79308: LD_INT 4
79310: PUSH
79311: EMPTY
79312: LIST
79313: LIST
79314: PUSH
79315: LD_INT 3
79317: PUSH
79318: LD_INT 3
79320: PUSH
79321: EMPTY
79322: LIST
79323: LIST
79324: PUSH
79325: LD_INT 5
79327: PUSH
79328: LD_INT 3
79330: PUSH
79331: EMPTY
79332: LIST
79333: LIST
79334: PUSH
79335: LD_INT 3
79337: PUSH
79338: LD_INT 5
79340: PUSH
79341: EMPTY
79342: LIST
79343: LIST
79344: PUSH
79345: EMPTY
79346: LIST
79347: LIST
79348: LIST
79349: LIST
79350: LIST
79351: LIST
79352: LIST
79353: LIST
79354: LIST
79355: LIST
79356: LIST
79357: LIST
79358: LIST
79359: LIST
79360: LIST
79361: LIST
79362: LIST
79363: LIST
79364: LIST
79365: LIST
79366: LIST
79367: LIST
79368: LIST
79369: LIST
79370: LIST
79371: LIST
79372: LIST
79373: LIST
79374: LIST
79375: LIST
79376: LIST
79377: LIST
79378: LIST
79379: LIST
79380: LIST
79381: LIST
79382: LIST
79383: LIST
79384: LIST
79385: LIST
79386: LIST
79387: LIST
79388: LIST
79389: LIST
79390: LIST
79391: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
79392: LD_ADDR_VAR 0 33
79396: PUSH
79397: LD_INT 4
79399: NEG
79400: PUSH
79401: LD_INT 4
79403: NEG
79404: PUSH
79405: EMPTY
79406: LIST
79407: LIST
79408: PUSH
79409: LD_INT 4
79411: NEG
79412: PUSH
79413: LD_INT 5
79415: NEG
79416: PUSH
79417: EMPTY
79418: LIST
79419: LIST
79420: PUSH
79421: LD_INT 3
79423: NEG
79424: PUSH
79425: LD_INT 4
79427: NEG
79428: PUSH
79429: EMPTY
79430: LIST
79431: LIST
79432: PUSH
79433: LD_INT 3
79435: NEG
79436: PUSH
79437: LD_INT 3
79439: NEG
79440: PUSH
79441: EMPTY
79442: LIST
79443: LIST
79444: PUSH
79445: LD_INT 4
79447: NEG
79448: PUSH
79449: LD_INT 3
79451: NEG
79452: PUSH
79453: EMPTY
79454: LIST
79455: LIST
79456: PUSH
79457: LD_INT 5
79459: NEG
79460: PUSH
79461: LD_INT 4
79463: NEG
79464: PUSH
79465: EMPTY
79466: LIST
79467: LIST
79468: PUSH
79469: LD_INT 5
79471: NEG
79472: PUSH
79473: LD_INT 5
79475: NEG
79476: PUSH
79477: EMPTY
79478: LIST
79479: LIST
79480: PUSH
79481: LD_INT 3
79483: NEG
79484: PUSH
79485: LD_INT 5
79487: NEG
79488: PUSH
79489: EMPTY
79490: LIST
79491: LIST
79492: PUSH
79493: LD_INT 5
79495: NEG
79496: PUSH
79497: LD_INT 3
79499: NEG
79500: PUSH
79501: EMPTY
79502: LIST
79503: LIST
79504: PUSH
79505: LD_INT 0
79507: PUSH
79508: LD_INT 3
79510: NEG
79511: PUSH
79512: EMPTY
79513: LIST
79514: LIST
79515: PUSH
79516: LD_INT 0
79518: PUSH
79519: LD_INT 4
79521: NEG
79522: PUSH
79523: EMPTY
79524: LIST
79525: LIST
79526: PUSH
79527: LD_INT 1
79529: PUSH
79530: LD_INT 3
79532: NEG
79533: PUSH
79534: EMPTY
79535: LIST
79536: LIST
79537: PUSH
79538: LD_INT 1
79540: PUSH
79541: LD_INT 2
79543: NEG
79544: PUSH
79545: EMPTY
79546: LIST
79547: LIST
79548: PUSH
79549: LD_INT 0
79551: PUSH
79552: LD_INT 2
79554: NEG
79555: PUSH
79556: EMPTY
79557: LIST
79558: LIST
79559: PUSH
79560: LD_INT 1
79562: NEG
79563: PUSH
79564: LD_INT 3
79566: NEG
79567: PUSH
79568: EMPTY
79569: LIST
79570: LIST
79571: PUSH
79572: LD_INT 1
79574: NEG
79575: PUSH
79576: LD_INT 4
79578: NEG
79579: PUSH
79580: EMPTY
79581: LIST
79582: LIST
79583: PUSH
79584: LD_INT 2
79586: PUSH
79587: LD_INT 2
79589: NEG
79590: PUSH
79591: EMPTY
79592: LIST
79593: LIST
79594: PUSH
79595: LD_INT 2
79597: NEG
79598: PUSH
79599: LD_INT 4
79601: NEG
79602: PUSH
79603: EMPTY
79604: LIST
79605: LIST
79606: PUSH
79607: LD_INT 4
79609: PUSH
79610: LD_INT 0
79612: PUSH
79613: EMPTY
79614: LIST
79615: LIST
79616: PUSH
79617: LD_INT 4
79619: PUSH
79620: LD_INT 1
79622: NEG
79623: PUSH
79624: EMPTY
79625: LIST
79626: LIST
79627: PUSH
79628: LD_INT 5
79630: PUSH
79631: LD_INT 0
79633: PUSH
79634: EMPTY
79635: LIST
79636: LIST
79637: PUSH
79638: LD_INT 5
79640: PUSH
79641: LD_INT 1
79643: PUSH
79644: EMPTY
79645: LIST
79646: LIST
79647: PUSH
79648: LD_INT 4
79650: PUSH
79651: LD_INT 1
79653: PUSH
79654: EMPTY
79655: LIST
79656: LIST
79657: PUSH
79658: LD_INT 3
79660: PUSH
79661: LD_INT 0
79663: PUSH
79664: EMPTY
79665: LIST
79666: LIST
79667: PUSH
79668: LD_INT 3
79670: PUSH
79671: LD_INT 1
79673: NEG
79674: PUSH
79675: EMPTY
79676: LIST
79677: LIST
79678: PUSH
79679: LD_INT 3
79681: PUSH
79682: LD_INT 2
79684: NEG
79685: PUSH
79686: EMPTY
79687: LIST
79688: LIST
79689: PUSH
79690: LD_INT 5
79692: PUSH
79693: LD_INT 2
79695: PUSH
79696: EMPTY
79697: LIST
79698: LIST
79699: PUSH
79700: LD_INT 3
79702: PUSH
79703: LD_INT 3
79705: PUSH
79706: EMPTY
79707: LIST
79708: LIST
79709: PUSH
79710: LD_INT 3
79712: PUSH
79713: LD_INT 2
79715: PUSH
79716: EMPTY
79717: LIST
79718: LIST
79719: PUSH
79720: LD_INT 4
79722: PUSH
79723: LD_INT 3
79725: PUSH
79726: EMPTY
79727: LIST
79728: LIST
79729: PUSH
79730: LD_INT 4
79732: PUSH
79733: LD_INT 4
79735: PUSH
79736: EMPTY
79737: LIST
79738: LIST
79739: PUSH
79740: LD_INT 3
79742: PUSH
79743: LD_INT 4
79745: PUSH
79746: EMPTY
79747: LIST
79748: LIST
79749: PUSH
79750: LD_INT 2
79752: PUSH
79753: LD_INT 3
79755: PUSH
79756: EMPTY
79757: LIST
79758: LIST
79759: PUSH
79760: LD_INT 2
79762: PUSH
79763: LD_INT 2
79765: PUSH
79766: EMPTY
79767: LIST
79768: LIST
79769: PUSH
79770: LD_INT 4
79772: PUSH
79773: LD_INT 2
79775: PUSH
79776: EMPTY
79777: LIST
79778: LIST
79779: PUSH
79780: LD_INT 2
79782: PUSH
79783: LD_INT 4
79785: PUSH
79786: EMPTY
79787: LIST
79788: LIST
79789: PUSH
79790: LD_INT 0
79792: PUSH
79793: LD_INT 4
79795: PUSH
79796: EMPTY
79797: LIST
79798: LIST
79799: PUSH
79800: LD_INT 0
79802: PUSH
79803: LD_INT 3
79805: PUSH
79806: EMPTY
79807: LIST
79808: LIST
79809: PUSH
79810: LD_INT 1
79812: PUSH
79813: LD_INT 4
79815: PUSH
79816: EMPTY
79817: LIST
79818: LIST
79819: PUSH
79820: LD_INT 1
79822: PUSH
79823: LD_INT 5
79825: PUSH
79826: EMPTY
79827: LIST
79828: LIST
79829: PUSH
79830: LD_INT 0
79832: PUSH
79833: LD_INT 5
79835: PUSH
79836: EMPTY
79837: LIST
79838: LIST
79839: PUSH
79840: LD_INT 1
79842: NEG
79843: PUSH
79844: LD_INT 4
79846: PUSH
79847: EMPTY
79848: LIST
79849: LIST
79850: PUSH
79851: LD_INT 1
79853: NEG
79854: PUSH
79855: LD_INT 3
79857: PUSH
79858: EMPTY
79859: LIST
79860: LIST
79861: PUSH
79862: LD_INT 2
79864: PUSH
79865: LD_INT 5
79867: PUSH
79868: EMPTY
79869: LIST
79870: LIST
79871: PUSH
79872: LD_INT 2
79874: NEG
79875: PUSH
79876: LD_INT 3
79878: PUSH
79879: EMPTY
79880: LIST
79881: LIST
79882: PUSH
79883: EMPTY
79884: LIST
79885: LIST
79886: LIST
79887: LIST
79888: LIST
79889: LIST
79890: LIST
79891: LIST
79892: LIST
79893: LIST
79894: LIST
79895: LIST
79896: LIST
79897: LIST
79898: LIST
79899: LIST
79900: LIST
79901: LIST
79902: LIST
79903: LIST
79904: LIST
79905: LIST
79906: LIST
79907: LIST
79908: LIST
79909: LIST
79910: LIST
79911: LIST
79912: LIST
79913: LIST
79914: LIST
79915: LIST
79916: LIST
79917: LIST
79918: LIST
79919: LIST
79920: LIST
79921: LIST
79922: LIST
79923: LIST
79924: LIST
79925: LIST
79926: LIST
79927: LIST
79928: LIST
79929: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
79930: LD_ADDR_VAR 0 34
79934: PUSH
79935: LD_INT 0
79937: PUSH
79938: LD_INT 4
79940: NEG
79941: PUSH
79942: EMPTY
79943: LIST
79944: LIST
79945: PUSH
79946: LD_INT 0
79948: PUSH
79949: LD_INT 5
79951: NEG
79952: PUSH
79953: EMPTY
79954: LIST
79955: LIST
79956: PUSH
79957: LD_INT 1
79959: PUSH
79960: LD_INT 4
79962: NEG
79963: PUSH
79964: EMPTY
79965: LIST
79966: LIST
79967: PUSH
79968: LD_INT 1
79970: PUSH
79971: LD_INT 3
79973: NEG
79974: PUSH
79975: EMPTY
79976: LIST
79977: LIST
79978: PUSH
79979: LD_INT 0
79981: PUSH
79982: LD_INT 3
79984: NEG
79985: PUSH
79986: EMPTY
79987: LIST
79988: LIST
79989: PUSH
79990: LD_INT 1
79992: NEG
79993: PUSH
79994: LD_INT 4
79996: NEG
79997: PUSH
79998: EMPTY
79999: LIST
80000: LIST
80001: PUSH
80002: LD_INT 1
80004: NEG
80005: PUSH
80006: LD_INT 5
80008: NEG
80009: PUSH
80010: EMPTY
80011: LIST
80012: LIST
80013: PUSH
80014: LD_INT 2
80016: PUSH
80017: LD_INT 3
80019: NEG
80020: PUSH
80021: EMPTY
80022: LIST
80023: LIST
80024: PUSH
80025: LD_INT 2
80027: NEG
80028: PUSH
80029: LD_INT 5
80031: NEG
80032: PUSH
80033: EMPTY
80034: LIST
80035: LIST
80036: PUSH
80037: LD_INT 3
80039: PUSH
80040: LD_INT 0
80042: PUSH
80043: EMPTY
80044: LIST
80045: LIST
80046: PUSH
80047: LD_INT 3
80049: PUSH
80050: LD_INT 1
80052: NEG
80053: PUSH
80054: EMPTY
80055: LIST
80056: LIST
80057: PUSH
80058: LD_INT 4
80060: PUSH
80061: LD_INT 0
80063: PUSH
80064: EMPTY
80065: LIST
80066: LIST
80067: PUSH
80068: LD_INT 4
80070: PUSH
80071: LD_INT 1
80073: PUSH
80074: EMPTY
80075: LIST
80076: LIST
80077: PUSH
80078: LD_INT 3
80080: PUSH
80081: LD_INT 1
80083: PUSH
80084: EMPTY
80085: LIST
80086: LIST
80087: PUSH
80088: LD_INT 2
80090: PUSH
80091: LD_INT 0
80093: PUSH
80094: EMPTY
80095: LIST
80096: LIST
80097: PUSH
80098: LD_INT 2
80100: PUSH
80101: LD_INT 1
80103: NEG
80104: PUSH
80105: EMPTY
80106: LIST
80107: LIST
80108: PUSH
80109: LD_INT 2
80111: PUSH
80112: LD_INT 2
80114: NEG
80115: PUSH
80116: EMPTY
80117: LIST
80118: LIST
80119: PUSH
80120: LD_INT 4
80122: PUSH
80123: LD_INT 2
80125: PUSH
80126: EMPTY
80127: LIST
80128: LIST
80129: PUSH
80130: LD_INT 4
80132: PUSH
80133: LD_INT 4
80135: PUSH
80136: EMPTY
80137: LIST
80138: LIST
80139: PUSH
80140: LD_INT 4
80142: PUSH
80143: LD_INT 3
80145: PUSH
80146: EMPTY
80147: LIST
80148: LIST
80149: PUSH
80150: LD_INT 5
80152: PUSH
80153: LD_INT 4
80155: PUSH
80156: EMPTY
80157: LIST
80158: LIST
80159: PUSH
80160: LD_INT 5
80162: PUSH
80163: LD_INT 5
80165: PUSH
80166: EMPTY
80167: LIST
80168: LIST
80169: PUSH
80170: LD_INT 4
80172: PUSH
80173: LD_INT 5
80175: PUSH
80176: EMPTY
80177: LIST
80178: LIST
80179: PUSH
80180: LD_INT 3
80182: PUSH
80183: LD_INT 4
80185: PUSH
80186: EMPTY
80187: LIST
80188: LIST
80189: PUSH
80190: LD_INT 3
80192: PUSH
80193: LD_INT 3
80195: PUSH
80196: EMPTY
80197: LIST
80198: LIST
80199: PUSH
80200: LD_INT 5
80202: PUSH
80203: LD_INT 3
80205: PUSH
80206: EMPTY
80207: LIST
80208: LIST
80209: PUSH
80210: LD_INT 3
80212: PUSH
80213: LD_INT 5
80215: PUSH
80216: EMPTY
80217: LIST
80218: LIST
80219: PUSH
80220: LD_INT 0
80222: PUSH
80223: LD_INT 3
80225: PUSH
80226: EMPTY
80227: LIST
80228: LIST
80229: PUSH
80230: LD_INT 0
80232: PUSH
80233: LD_INT 2
80235: PUSH
80236: EMPTY
80237: LIST
80238: LIST
80239: PUSH
80240: LD_INT 1
80242: PUSH
80243: LD_INT 3
80245: PUSH
80246: EMPTY
80247: LIST
80248: LIST
80249: PUSH
80250: LD_INT 1
80252: PUSH
80253: LD_INT 4
80255: PUSH
80256: EMPTY
80257: LIST
80258: LIST
80259: PUSH
80260: LD_INT 0
80262: PUSH
80263: LD_INT 4
80265: PUSH
80266: EMPTY
80267: LIST
80268: LIST
80269: PUSH
80270: LD_INT 1
80272: NEG
80273: PUSH
80274: LD_INT 3
80276: PUSH
80277: EMPTY
80278: LIST
80279: LIST
80280: PUSH
80281: LD_INT 1
80283: NEG
80284: PUSH
80285: LD_INT 2
80287: PUSH
80288: EMPTY
80289: LIST
80290: LIST
80291: PUSH
80292: LD_INT 2
80294: PUSH
80295: LD_INT 4
80297: PUSH
80298: EMPTY
80299: LIST
80300: LIST
80301: PUSH
80302: LD_INT 2
80304: NEG
80305: PUSH
80306: LD_INT 2
80308: PUSH
80309: EMPTY
80310: LIST
80311: LIST
80312: PUSH
80313: LD_INT 4
80315: NEG
80316: PUSH
80317: LD_INT 0
80319: PUSH
80320: EMPTY
80321: LIST
80322: LIST
80323: PUSH
80324: LD_INT 4
80326: NEG
80327: PUSH
80328: LD_INT 1
80330: NEG
80331: PUSH
80332: EMPTY
80333: LIST
80334: LIST
80335: PUSH
80336: LD_INT 3
80338: NEG
80339: PUSH
80340: LD_INT 0
80342: PUSH
80343: EMPTY
80344: LIST
80345: LIST
80346: PUSH
80347: LD_INT 3
80349: NEG
80350: PUSH
80351: LD_INT 1
80353: PUSH
80354: EMPTY
80355: LIST
80356: LIST
80357: PUSH
80358: LD_INT 4
80360: NEG
80361: PUSH
80362: LD_INT 1
80364: PUSH
80365: EMPTY
80366: LIST
80367: LIST
80368: PUSH
80369: LD_INT 5
80371: NEG
80372: PUSH
80373: LD_INT 0
80375: PUSH
80376: EMPTY
80377: LIST
80378: LIST
80379: PUSH
80380: LD_INT 5
80382: NEG
80383: PUSH
80384: LD_INT 1
80386: NEG
80387: PUSH
80388: EMPTY
80389: LIST
80390: LIST
80391: PUSH
80392: LD_INT 5
80394: NEG
80395: PUSH
80396: LD_INT 2
80398: NEG
80399: PUSH
80400: EMPTY
80401: LIST
80402: LIST
80403: PUSH
80404: LD_INT 3
80406: NEG
80407: PUSH
80408: LD_INT 2
80410: PUSH
80411: EMPTY
80412: LIST
80413: LIST
80414: PUSH
80415: EMPTY
80416: LIST
80417: LIST
80418: LIST
80419: LIST
80420: LIST
80421: LIST
80422: LIST
80423: LIST
80424: LIST
80425: LIST
80426: LIST
80427: LIST
80428: LIST
80429: LIST
80430: LIST
80431: LIST
80432: LIST
80433: LIST
80434: LIST
80435: LIST
80436: LIST
80437: LIST
80438: LIST
80439: LIST
80440: LIST
80441: LIST
80442: LIST
80443: LIST
80444: LIST
80445: LIST
80446: LIST
80447: LIST
80448: LIST
80449: LIST
80450: LIST
80451: LIST
80452: LIST
80453: LIST
80454: LIST
80455: LIST
80456: LIST
80457: LIST
80458: LIST
80459: LIST
80460: LIST
80461: ST_TO_ADDR
// end ; end ;
80462: GO 80465
80464: POP
// case btype of b_depot , b_warehouse :
80465: LD_VAR 0 1
80469: PUSH
80470: LD_INT 0
80472: DOUBLE
80473: EQUAL
80474: IFTRUE 80484
80476: LD_INT 1
80478: DOUBLE
80479: EQUAL
80480: IFTRUE 80484
80482: GO 80685
80484: POP
// case nation of nation_american :
80485: LD_VAR 0 5
80489: PUSH
80490: LD_INT 1
80492: DOUBLE
80493: EQUAL
80494: IFTRUE 80498
80496: GO 80554
80498: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
80499: LD_ADDR_VAR 0 9
80503: PUSH
80504: LD_VAR 0 11
80508: PUSH
80509: LD_VAR 0 12
80513: PUSH
80514: LD_VAR 0 13
80518: PUSH
80519: LD_VAR 0 14
80523: PUSH
80524: LD_VAR 0 15
80528: PUSH
80529: LD_VAR 0 16
80533: PUSH
80534: EMPTY
80535: LIST
80536: LIST
80537: LIST
80538: LIST
80539: LIST
80540: LIST
80541: PUSH
80542: LD_VAR 0 4
80546: PUSH
80547: LD_INT 1
80549: PLUS
80550: ARRAY
80551: ST_TO_ADDR
80552: GO 80683
80554: LD_INT 2
80556: DOUBLE
80557: EQUAL
80558: IFTRUE 80562
80560: GO 80618
80562: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
80563: LD_ADDR_VAR 0 9
80567: PUSH
80568: LD_VAR 0 17
80572: PUSH
80573: LD_VAR 0 18
80577: PUSH
80578: LD_VAR 0 19
80582: PUSH
80583: LD_VAR 0 20
80587: PUSH
80588: LD_VAR 0 21
80592: PUSH
80593: LD_VAR 0 22
80597: PUSH
80598: EMPTY
80599: LIST
80600: LIST
80601: LIST
80602: LIST
80603: LIST
80604: LIST
80605: PUSH
80606: LD_VAR 0 4
80610: PUSH
80611: LD_INT 1
80613: PLUS
80614: ARRAY
80615: ST_TO_ADDR
80616: GO 80683
80618: LD_INT 3
80620: DOUBLE
80621: EQUAL
80622: IFTRUE 80626
80624: GO 80682
80626: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
80627: LD_ADDR_VAR 0 9
80631: PUSH
80632: LD_VAR 0 23
80636: PUSH
80637: LD_VAR 0 24
80641: PUSH
80642: LD_VAR 0 25
80646: PUSH
80647: LD_VAR 0 26
80651: PUSH
80652: LD_VAR 0 27
80656: PUSH
80657: LD_VAR 0 28
80661: PUSH
80662: EMPTY
80663: LIST
80664: LIST
80665: LIST
80666: LIST
80667: LIST
80668: LIST
80669: PUSH
80670: LD_VAR 0 4
80674: PUSH
80675: LD_INT 1
80677: PLUS
80678: ARRAY
80679: ST_TO_ADDR
80680: GO 80683
80682: POP
80683: GO 81238
80685: LD_INT 2
80687: DOUBLE
80688: EQUAL
80689: IFTRUE 80699
80691: LD_INT 3
80693: DOUBLE
80694: EQUAL
80695: IFTRUE 80699
80697: GO 80755
80699: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
80700: LD_ADDR_VAR 0 9
80704: PUSH
80705: LD_VAR 0 29
80709: PUSH
80710: LD_VAR 0 30
80714: PUSH
80715: LD_VAR 0 31
80719: PUSH
80720: LD_VAR 0 32
80724: PUSH
80725: LD_VAR 0 33
80729: PUSH
80730: LD_VAR 0 34
80734: PUSH
80735: EMPTY
80736: LIST
80737: LIST
80738: LIST
80739: LIST
80740: LIST
80741: LIST
80742: PUSH
80743: LD_VAR 0 4
80747: PUSH
80748: LD_INT 1
80750: PLUS
80751: ARRAY
80752: ST_TO_ADDR
80753: GO 81238
80755: LD_INT 16
80757: DOUBLE
80758: EQUAL
80759: IFTRUE 80817
80761: LD_INT 17
80763: DOUBLE
80764: EQUAL
80765: IFTRUE 80817
80767: LD_INT 18
80769: DOUBLE
80770: EQUAL
80771: IFTRUE 80817
80773: LD_INT 19
80775: DOUBLE
80776: EQUAL
80777: IFTRUE 80817
80779: LD_INT 22
80781: DOUBLE
80782: EQUAL
80783: IFTRUE 80817
80785: LD_INT 20
80787: DOUBLE
80788: EQUAL
80789: IFTRUE 80817
80791: LD_INT 21
80793: DOUBLE
80794: EQUAL
80795: IFTRUE 80817
80797: LD_INT 23
80799: DOUBLE
80800: EQUAL
80801: IFTRUE 80817
80803: LD_INT 24
80805: DOUBLE
80806: EQUAL
80807: IFTRUE 80817
80809: LD_INT 25
80811: DOUBLE
80812: EQUAL
80813: IFTRUE 80817
80815: GO 80873
80817: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
80818: LD_ADDR_VAR 0 9
80822: PUSH
80823: LD_VAR 0 35
80827: PUSH
80828: LD_VAR 0 36
80832: PUSH
80833: LD_VAR 0 37
80837: PUSH
80838: LD_VAR 0 38
80842: PUSH
80843: LD_VAR 0 39
80847: PUSH
80848: LD_VAR 0 40
80852: PUSH
80853: EMPTY
80854: LIST
80855: LIST
80856: LIST
80857: LIST
80858: LIST
80859: LIST
80860: PUSH
80861: LD_VAR 0 4
80865: PUSH
80866: LD_INT 1
80868: PLUS
80869: ARRAY
80870: ST_TO_ADDR
80871: GO 81238
80873: LD_INT 6
80875: DOUBLE
80876: EQUAL
80877: IFTRUE 80929
80879: LD_INT 7
80881: DOUBLE
80882: EQUAL
80883: IFTRUE 80929
80885: LD_INT 8
80887: DOUBLE
80888: EQUAL
80889: IFTRUE 80929
80891: LD_INT 13
80893: DOUBLE
80894: EQUAL
80895: IFTRUE 80929
80897: LD_INT 12
80899: DOUBLE
80900: EQUAL
80901: IFTRUE 80929
80903: LD_INT 15
80905: DOUBLE
80906: EQUAL
80907: IFTRUE 80929
80909: LD_INT 11
80911: DOUBLE
80912: EQUAL
80913: IFTRUE 80929
80915: LD_INT 14
80917: DOUBLE
80918: EQUAL
80919: IFTRUE 80929
80921: LD_INT 10
80923: DOUBLE
80924: EQUAL
80925: IFTRUE 80929
80927: GO 80985
80929: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
80930: LD_ADDR_VAR 0 9
80934: PUSH
80935: LD_VAR 0 41
80939: PUSH
80940: LD_VAR 0 42
80944: PUSH
80945: LD_VAR 0 43
80949: PUSH
80950: LD_VAR 0 44
80954: PUSH
80955: LD_VAR 0 45
80959: PUSH
80960: LD_VAR 0 46
80964: PUSH
80965: EMPTY
80966: LIST
80967: LIST
80968: LIST
80969: LIST
80970: LIST
80971: LIST
80972: PUSH
80973: LD_VAR 0 4
80977: PUSH
80978: LD_INT 1
80980: PLUS
80981: ARRAY
80982: ST_TO_ADDR
80983: GO 81238
80985: LD_INT 36
80987: DOUBLE
80988: EQUAL
80989: IFTRUE 80993
80991: GO 81049
80993: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
80994: LD_ADDR_VAR 0 9
80998: PUSH
80999: LD_VAR 0 47
81003: PUSH
81004: LD_VAR 0 48
81008: PUSH
81009: LD_VAR 0 49
81013: PUSH
81014: LD_VAR 0 50
81018: PUSH
81019: LD_VAR 0 51
81023: PUSH
81024: LD_VAR 0 52
81028: PUSH
81029: EMPTY
81030: LIST
81031: LIST
81032: LIST
81033: LIST
81034: LIST
81035: LIST
81036: PUSH
81037: LD_VAR 0 4
81041: PUSH
81042: LD_INT 1
81044: PLUS
81045: ARRAY
81046: ST_TO_ADDR
81047: GO 81238
81049: LD_INT 4
81051: DOUBLE
81052: EQUAL
81053: IFTRUE 81075
81055: LD_INT 5
81057: DOUBLE
81058: EQUAL
81059: IFTRUE 81075
81061: LD_INT 34
81063: DOUBLE
81064: EQUAL
81065: IFTRUE 81075
81067: LD_INT 37
81069: DOUBLE
81070: EQUAL
81071: IFTRUE 81075
81073: GO 81131
81075: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
81076: LD_ADDR_VAR 0 9
81080: PUSH
81081: LD_VAR 0 53
81085: PUSH
81086: LD_VAR 0 54
81090: PUSH
81091: LD_VAR 0 55
81095: PUSH
81096: LD_VAR 0 56
81100: PUSH
81101: LD_VAR 0 57
81105: PUSH
81106: LD_VAR 0 58
81110: PUSH
81111: EMPTY
81112: LIST
81113: LIST
81114: LIST
81115: LIST
81116: LIST
81117: LIST
81118: PUSH
81119: LD_VAR 0 4
81123: PUSH
81124: LD_INT 1
81126: PLUS
81127: ARRAY
81128: ST_TO_ADDR
81129: GO 81238
81131: LD_INT 31
81133: DOUBLE
81134: EQUAL
81135: IFTRUE 81181
81137: LD_INT 32
81139: DOUBLE
81140: EQUAL
81141: IFTRUE 81181
81143: LD_INT 33
81145: DOUBLE
81146: EQUAL
81147: IFTRUE 81181
81149: LD_INT 27
81151: DOUBLE
81152: EQUAL
81153: IFTRUE 81181
81155: LD_INT 26
81157: DOUBLE
81158: EQUAL
81159: IFTRUE 81181
81161: LD_INT 28
81163: DOUBLE
81164: EQUAL
81165: IFTRUE 81181
81167: LD_INT 29
81169: DOUBLE
81170: EQUAL
81171: IFTRUE 81181
81173: LD_INT 30
81175: DOUBLE
81176: EQUAL
81177: IFTRUE 81181
81179: GO 81237
81181: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
81182: LD_ADDR_VAR 0 9
81186: PUSH
81187: LD_VAR 0 59
81191: PUSH
81192: LD_VAR 0 60
81196: PUSH
81197: LD_VAR 0 61
81201: PUSH
81202: LD_VAR 0 62
81206: PUSH
81207: LD_VAR 0 63
81211: PUSH
81212: LD_VAR 0 64
81216: PUSH
81217: EMPTY
81218: LIST
81219: LIST
81220: LIST
81221: LIST
81222: LIST
81223: LIST
81224: PUSH
81225: LD_VAR 0 4
81229: PUSH
81230: LD_INT 1
81232: PLUS
81233: ARRAY
81234: ST_TO_ADDR
81235: GO 81238
81237: POP
// temp_list2 = [ ] ;
81238: LD_ADDR_VAR 0 10
81242: PUSH
81243: EMPTY
81244: ST_TO_ADDR
// for i in temp_list do
81245: LD_ADDR_VAR 0 8
81249: PUSH
81250: LD_VAR 0 9
81254: PUSH
81255: FOR_IN
81256: IFFALSE 81308
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
81258: LD_ADDR_VAR 0 10
81262: PUSH
81263: LD_VAR 0 10
81267: PUSH
81268: LD_VAR 0 8
81272: PUSH
81273: LD_INT 1
81275: ARRAY
81276: PUSH
81277: LD_VAR 0 2
81281: PLUS
81282: PUSH
81283: LD_VAR 0 8
81287: PUSH
81288: LD_INT 2
81290: ARRAY
81291: PUSH
81292: LD_VAR 0 3
81296: PLUS
81297: PUSH
81298: EMPTY
81299: LIST
81300: LIST
81301: PUSH
81302: EMPTY
81303: LIST
81304: ADD
81305: ST_TO_ADDR
81306: GO 81255
81308: POP
81309: POP
// result = temp_list2 ;
81310: LD_ADDR_VAR 0 7
81314: PUSH
81315: LD_VAR 0 10
81319: ST_TO_ADDR
// end ;
81320: LD_VAR 0 7
81324: RET
// export function EnemyInRange ( unit , dist ) ; begin
81325: LD_INT 0
81327: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
81328: LD_ADDR_VAR 0 3
81332: PUSH
81333: LD_VAR 0 1
81337: PPUSH
81338: CALL_OW 255
81342: PPUSH
81343: LD_VAR 0 1
81347: PPUSH
81348: CALL_OW 250
81352: PPUSH
81353: LD_VAR 0 1
81357: PPUSH
81358: CALL_OW 251
81362: PPUSH
81363: LD_VAR 0 2
81367: PPUSH
81368: CALL 54727 0 4
81372: PUSH
81373: LD_INT 4
81375: ARRAY
81376: ST_TO_ADDR
// end ;
81377: LD_VAR 0 3
81381: RET
// export function PlayerSeeMe ( unit ) ; begin
81382: LD_INT 0
81384: PPUSH
// result := See ( your_side , unit ) ;
81385: LD_ADDR_VAR 0 2
81389: PUSH
81390: LD_OWVAR 2
81394: PPUSH
81395: LD_VAR 0 1
81399: PPUSH
81400: CALL_OW 292
81404: ST_TO_ADDR
// end ;
81405: LD_VAR 0 2
81409: RET
// export function ReverseDir ( unit ) ; begin
81410: LD_INT 0
81412: PPUSH
// if not unit then
81413: LD_VAR 0 1
81417: NOT
81418: IFFALSE 81422
// exit ;
81420: GO 81445
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
81422: LD_ADDR_VAR 0 2
81426: PUSH
81427: LD_VAR 0 1
81431: PPUSH
81432: CALL_OW 254
81436: PUSH
81437: LD_INT 3
81439: PLUS
81440: PUSH
81441: LD_INT 6
81443: MOD
81444: ST_TO_ADDR
// end ;
81445: LD_VAR 0 2
81449: RET
// export function ReverseArray ( array ) ; var i ; begin
81450: LD_INT 0
81452: PPUSH
81453: PPUSH
// if not array then
81454: LD_VAR 0 1
81458: NOT
81459: IFFALSE 81463
// exit ;
81461: GO 81518
// result := [ ] ;
81463: LD_ADDR_VAR 0 2
81467: PUSH
81468: EMPTY
81469: ST_TO_ADDR
// for i := array downto 1 do
81470: LD_ADDR_VAR 0 3
81474: PUSH
81475: DOUBLE
81476: LD_VAR 0 1
81480: INC
81481: ST_TO_ADDR
81482: LD_INT 1
81484: PUSH
81485: FOR_DOWNTO
81486: IFFALSE 81516
// result := Join ( result , array [ i ] ) ;
81488: LD_ADDR_VAR 0 2
81492: PUSH
81493: LD_VAR 0 2
81497: PPUSH
81498: LD_VAR 0 1
81502: PUSH
81503: LD_VAR 0 3
81507: ARRAY
81508: PPUSH
81509: CALL 86162 0 2
81513: ST_TO_ADDR
81514: GO 81485
81516: POP
81517: POP
// end ;
81518: LD_VAR 0 2
81522: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
81523: LD_INT 0
81525: PPUSH
81526: PPUSH
81527: PPUSH
81528: PPUSH
81529: PPUSH
81530: PPUSH
// if not unit or not hexes then
81531: LD_VAR 0 1
81535: NOT
81536: PUSH
81537: LD_VAR 0 2
81541: NOT
81542: OR
81543: IFFALSE 81547
// exit ;
81545: GO 81670
// dist := 9999 ;
81547: LD_ADDR_VAR 0 5
81551: PUSH
81552: LD_INT 9999
81554: ST_TO_ADDR
// for i = 1 to hexes do
81555: LD_ADDR_VAR 0 4
81559: PUSH
81560: DOUBLE
81561: LD_INT 1
81563: DEC
81564: ST_TO_ADDR
81565: LD_VAR 0 2
81569: PUSH
81570: FOR_TO
81571: IFFALSE 81658
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
81573: LD_ADDR_VAR 0 6
81577: PUSH
81578: LD_VAR 0 1
81582: PPUSH
81583: LD_VAR 0 2
81587: PUSH
81588: LD_VAR 0 4
81592: ARRAY
81593: PUSH
81594: LD_INT 1
81596: ARRAY
81597: PPUSH
81598: LD_VAR 0 2
81602: PUSH
81603: LD_VAR 0 4
81607: ARRAY
81608: PUSH
81609: LD_INT 2
81611: ARRAY
81612: PPUSH
81613: CALL_OW 297
81617: ST_TO_ADDR
// if tdist < dist then
81618: LD_VAR 0 6
81622: PUSH
81623: LD_VAR 0 5
81627: LESS
81628: IFFALSE 81656
// begin hex := hexes [ i ] ;
81630: LD_ADDR_VAR 0 8
81634: PUSH
81635: LD_VAR 0 2
81639: PUSH
81640: LD_VAR 0 4
81644: ARRAY
81645: ST_TO_ADDR
// dist := tdist ;
81646: LD_ADDR_VAR 0 5
81650: PUSH
81651: LD_VAR 0 6
81655: ST_TO_ADDR
// end ; end ;
81656: GO 81570
81658: POP
81659: POP
// result := hex ;
81660: LD_ADDR_VAR 0 3
81664: PUSH
81665: LD_VAR 0 8
81669: ST_TO_ADDR
// end ;
81670: LD_VAR 0 3
81674: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
81675: LD_INT 0
81677: PPUSH
81678: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
81679: LD_VAR 0 1
81683: NOT
81684: PUSH
81685: LD_VAR 0 1
81689: PUSH
81690: LD_INT 21
81692: PUSH
81693: LD_INT 2
81695: PUSH
81696: EMPTY
81697: LIST
81698: LIST
81699: PUSH
81700: LD_INT 23
81702: PUSH
81703: LD_INT 2
81705: PUSH
81706: EMPTY
81707: LIST
81708: LIST
81709: PUSH
81710: EMPTY
81711: LIST
81712: LIST
81713: PPUSH
81714: CALL_OW 69
81718: IN
81719: NOT
81720: OR
81721: IFFALSE 81725
// exit ;
81723: GO 81772
// for i = 1 to 3 do
81725: LD_ADDR_VAR 0 3
81729: PUSH
81730: DOUBLE
81731: LD_INT 1
81733: DEC
81734: ST_TO_ADDR
81735: LD_INT 3
81737: PUSH
81738: FOR_TO
81739: IFFALSE 81770
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
81741: LD_VAR 0 1
81745: PPUSH
81746: CALL_OW 250
81750: PPUSH
81751: LD_VAR 0 1
81755: PPUSH
81756: CALL_OW 251
81760: PPUSH
81761: LD_INT 1
81763: PPUSH
81764: CALL_OW 453
81768: GO 81738
81770: POP
81771: POP
// end ;
81772: LD_VAR 0 2
81776: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
81777: LD_INT 0
81779: PPUSH
81780: PPUSH
81781: PPUSH
81782: PPUSH
81783: PPUSH
81784: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
81785: LD_VAR 0 1
81789: NOT
81790: PUSH
81791: LD_VAR 0 2
81795: NOT
81796: OR
81797: PUSH
81798: LD_VAR 0 1
81802: PPUSH
81803: CALL_OW 314
81807: OR
81808: IFFALSE 81812
// exit ;
81810: GO 82279
// if GetLives ( i ) < 250 then
81812: LD_VAR 0 4
81816: PPUSH
81817: CALL_OW 256
81821: PUSH
81822: LD_INT 250
81824: LESS
81825: IFFALSE 81838
// begin ComAutodestruct ( i ) ;
81827: LD_VAR 0 4
81831: PPUSH
81832: CALL 81675 0 1
// exit ;
81836: GO 82279
// end ; x := GetX ( enemy_unit ) ;
81838: LD_ADDR_VAR 0 7
81842: PUSH
81843: LD_VAR 0 2
81847: PPUSH
81848: CALL_OW 250
81852: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
81853: LD_ADDR_VAR 0 8
81857: PUSH
81858: LD_VAR 0 2
81862: PPUSH
81863: CALL_OW 251
81867: ST_TO_ADDR
// if not x or not y then
81868: LD_VAR 0 7
81872: NOT
81873: PUSH
81874: LD_VAR 0 8
81878: NOT
81879: OR
81880: IFFALSE 81884
// exit ;
81882: GO 82279
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
81884: LD_ADDR_VAR 0 6
81888: PUSH
81889: LD_VAR 0 7
81893: PPUSH
81894: LD_INT 0
81896: PPUSH
81897: LD_INT 4
81899: PPUSH
81900: CALL_OW 272
81904: PUSH
81905: LD_VAR 0 8
81909: PPUSH
81910: LD_INT 0
81912: PPUSH
81913: LD_INT 4
81915: PPUSH
81916: CALL_OW 273
81920: PUSH
81921: EMPTY
81922: LIST
81923: LIST
81924: PUSH
81925: LD_VAR 0 7
81929: PPUSH
81930: LD_INT 1
81932: PPUSH
81933: LD_INT 4
81935: PPUSH
81936: CALL_OW 272
81940: PUSH
81941: LD_VAR 0 8
81945: PPUSH
81946: LD_INT 1
81948: PPUSH
81949: LD_INT 4
81951: PPUSH
81952: CALL_OW 273
81956: PUSH
81957: EMPTY
81958: LIST
81959: LIST
81960: PUSH
81961: LD_VAR 0 7
81965: PPUSH
81966: LD_INT 2
81968: PPUSH
81969: LD_INT 4
81971: PPUSH
81972: CALL_OW 272
81976: PUSH
81977: LD_VAR 0 8
81981: PPUSH
81982: LD_INT 2
81984: PPUSH
81985: LD_INT 4
81987: PPUSH
81988: CALL_OW 273
81992: PUSH
81993: EMPTY
81994: LIST
81995: LIST
81996: PUSH
81997: LD_VAR 0 7
82001: PPUSH
82002: LD_INT 3
82004: PPUSH
82005: LD_INT 4
82007: PPUSH
82008: CALL_OW 272
82012: PUSH
82013: LD_VAR 0 8
82017: PPUSH
82018: LD_INT 3
82020: PPUSH
82021: LD_INT 4
82023: PPUSH
82024: CALL_OW 273
82028: PUSH
82029: EMPTY
82030: LIST
82031: LIST
82032: PUSH
82033: LD_VAR 0 7
82037: PPUSH
82038: LD_INT 4
82040: PPUSH
82041: LD_INT 4
82043: PPUSH
82044: CALL_OW 272
82048: PUSH
82049: LD_VAR 0 8
82053: PPUSH
82054: LD_INT 4
82056: PPUSH
82057: LD_INT 4
82059: PPUSH
82060: CALL_OW 273
82064: PUSH
82065: EMPTY
82066: LIST
82067: LIST
82068: PUSH
82069: LD_VAR 0 7
82073: PPUSH
82074: LD_INT 5
82076: PPUSH
82077: LD_INT 4
82079: PPUSH
82080: CALL_OW 272
82084: PUSH
82085: LD_VAR 0 8
82089: PPUSH
82090: LD_INT 5
82092: PPUSH
82093: LD_INT 4
82095: PPUSH
82096: CALL_OW 273
82100: PUSH
82101: EMPTY
82102: LIST
82103: LIST
82104: PUSH
82105: EMPTY
82106: LIST
82107: LIST
82108: LIST
82109: LIST
82110: LIST
82111: LIST
82112: ST_TO_ADDR
// for i = tmp downto 1 do
82113: LD_ADDR_VAR 0 4
82117: PUSH
82118: DOUBLE
82119: LD_VAR 0 6
82123: INC
82124: ST_TO_ADDR
82125: LD_INT 1
82127: PUSH
82128: FOR_DOWNTO
82129: IFFALSE 82230
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
82131: LD_VAR 0 6
82135: PUSH
82136: LD_VAR 0 4
82140: ARRAY
82141: PUSH
82142: LD_INT 1
82144: ARRAY
82145: PPUSH
82146: LD_VAR 0 6
82150: PUSH
82151: LD_VAR 0 4
82155: ARRAY
82156: PUSH
82157: LD_INT 2
82159: ARRAY
82160: PPUSH
82161: CALL_OW 488
82165: NOT
82166: PUSH
82167: LD_VAR 0 6
82171: PUSH
82172: LD_VAR 0 4
82176: ARRAY
82177: PUSH
82178: LD_INT 1
82180: ARRAY
82181: PPUSH
82182: LD_VAR 0 6
82186: PUSH
82187: LD_VAR 0 4
82191: ARRAY
82192: PUSH
82193: LD_INT 2
82195: ARRAY
82196: PPUSH
82197: CALL_OW 428
82201: PUSH
82202: LD_INT 0
82204: NONEQUAL
82205: OR
82206: IFFALSE 82228
// tmp := Delete ( tmp , i ) ;
82208: LD_ADDR_VAR 0 6
82212: PUSH
82213: LD_VAR 0 6
82217: PPUSH
82218: LD_VAR 0 4
82222: PPUSH
82223: CALL_OW 3
82227: ST_TO_ADDR
82228: GO 82128
82230: POP
82231: POP
// j := GetClosestHex ( unit , tmp ) ;
82232: LD_ADDR_VAR 0 5
82236: PUSH
82237: LD_VAR 0 1
82241: PPUSH
82242: LD_VAR 0 6
82246: PPUSH
82247: CALL 81523 0 2
82251: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
82252: LD_VAR 0 1
82256: PPUSH
82257: LD_VAR 0 5
82261: PUSH
82262: LD_INT 1
82264: ARRAY
82265: PPUSH
82266: LD_VAR 0 5
82270: PUSH
82271: LD_INT 2
82273: ARRAY
82274: PPUSH
82275: CALL_OW 111
// end ;
82279: LD_VAR 0 3
82283: RET
// export function PrepareApemanSoldier ( ) ; begin
82284: LD_INT 0
82286: PPUSH
// uc_nation := 0 ;
82287: LD_ADDR_OWVAR 21
82291: PUSH
82292: LD_INT 0
82294: ST_TO_ADDR
// hc_sex := sex_male ;
82295: LD_ADDR_OWVAR 27
82299: PUSH
82300: LD_INT 1
82302: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
82303: LD_ADDR_OWVAR 28
82307: PUSH
82308: LD_INT 15
82310: ST_TO_ADDR
// hc_gallery :=  ;
82311: LD_ADDR_OWVAR 33
82315: PUSH
82316: LD_STRING 
82318: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
82319: LD_ADDR_OWVAR 31
82323: PUSH
82324: LD_INT 0
82326: PPUSH
82327: LD_INT 3
82329: PPUSH
82330: CALL_OW 12
82334: PUSH
82335: LD_INT 0
82337: PPUSH
82338: LD_INT 3
82340: PPUSH
82341: CALL_OW 12
82345: PUSH
82346: LD_INT 0
82348: PUSH
82349: LD_INT 0
82351: PUSH
82352: EMPTY
82353: LIST
82354: LIST
82355: LIST
82356: LIST
82357: ST_TO_ADDR
// end ;
82358: LD_VAR 0 1
82362: RET
// export function PrepareApemanEngineer ( ) ; begin
82363: LD_INT 0
82365: PPUSH
// uc_nation := 0 ;
82366: LD_ADDR_OWVAR 21
82370: PUSH
82371: LD_INT 0
82373: ST_TO_ADDR
// hc_sex := sex_male ;
82374: LD_ADDR_OWVAR 27
82378: PUSH
82379: LD_INT 1
82381: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
82382: LD_ADDR_OWVAR 28
82386: PUSH
82387: LD_INT 16
82389: ST_TO_ADDR
// hc_gallery :=  ;
82390: LD_ADDR_OWVAR 33
82394: PUSH
82395: LD_STRING 
82397: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
82398: LD_ADDR_OWVAR 31
82402: PUSH
82403: LD_INT 0
82405: PPUSH
82406: LD_INT 3
82408: PPUSH
82409: CALL_OW 12
82413: PUSH
82414: LD_INT 0
82416: PPUSH
82417: LD_INT 3
82419: PPUSH
82420: CALL_OW 12
82424: PUSH
82425: LD_INT 0
82427: PUSH
82428: LD_INT 0
82430: PUSH
82431: EMPTY
82432: LIST
82433: LIST
82434: LIST
82435: LIST
82436: ST_TO_ADDR
// end ;
82437: LD_VAR 0 1
82441: RET
// export function PrepareApeman ( agressivity ) ; begin
82442: LD_INT 0
82444: PPUSH
// uc_side := 0 ;
82445: LD_ADDR_OWVAR 20
82449: PUSH
82450: LD_INT 0
82452: ST_TO_ADDR
// uc_nation := 0 ;
82453: LD_ADDR_OWVAR 21
82457: PUSH
82458: LD_INT 0
82460: ST_TO_ADDR
// hc_sex := sex_male ;
82461: LD_ADDR_OWVAR 27
82465: PUSH
82466: LD_INT 1
82468: ST_TO_ADDR
// hc_class := class_apeman ;
82469: LD_ADDR_OWVAR 28
82473: PUSH
82474: LD_INT 12
82476: ST_TO_ADDR
// hc_gallery :=  ;
82477: LD_ADDR_OWVAR 33
82481: PUSH
82482: LD_STRING 
82484: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
82485: LD_ADDR_OWVAR 35
82489: PUSH
82490: LD_VAR 0 1
82494: NEG
82495: PPUSH
82496: LD_VAR 0 1
82500: PPUSH
82501: CALL_OW 12
82505: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
82506: LD_ADDR_OWVAR 31
82510: PUSH
82511: LD_INT 0
82513: PPUSH
82514: LD_INT 3
82516: PPUSH
82517: CALL_OW 12
82521: PUSH
82522: LD_INT 0
82524: PPUSH
82525: LD_INT 3
82527: PPUSH
82528: CALL_OW 12
82532: PUSH
82533: LD_INT 0
82535: PUSH
82536: LD_INT 0
82538: PUSH
82539: EMPTY
82540: LIST
82541: LIST
82542: LIST
82543: LIST
82544: ST_TO_ADDR
// end ;
82545: LD_VAR 0 2
82549: RET
// export function PrepareTiger ( agressivity ) ; begin
82550: LD_INT 0
82552: PPUSH
// uc_side := 0 ;
82553: LD_ADDR_OWVAR 20
82557: PUSH
82558: LD_INT 0
82560: ST_TO_ADDR
// uc_nation := 0 ;
82561: LD_ADDR_OWVAR 21
82565: PUSH
82566: LD_INT 0
82568: ST_TO_ADDR
// hc_class := class_tiger ;
82569: LD_ADDR_OWVAR 28
82573: PUSH
82574: LD_INT 14
82576: ST_TO_ADDR
// hc_gallery :=  ;
82577: LD_ADDR_OWVAR 33
82581: PUSH
82582: LD_STRING 
82584: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
82585: LD_ADDR_OWVAR 35
82589: PUSH
82590: LD_VAR 0 1
82594: NEG
82595: PPUSH
82596: LD_VAR 0 1
82600: PPUSH
82601: CALL_OW 12
82605: ST_TO_ADDR
// end ;
82606: LD_VAR 0 2
82610: RET
// export function PrepareEnchidna ( ) ; begin
82611: LD_INT 0
82613: PPUSH
// uc_side := 0 ;
82614: LD_ADDR_OWVAR 20
82618: PUSH
82619: LD_INT 0
82621: ST_TO_ADDR
// uc_nation := 0 ;
82622: LD_ADDR_OWVAR 21
82626: PUSH
82627: LD_INT 0
82629: ST_TO_ADDR
// hc_class := class_baggie ;
82630: LD_ADDR_OWVAR 28
82634: PUSH
82635: LD_INT 13
82637: ST_TO_ADDR
// hc_gallery :=  ;
82638: LD_ADDR_OWVAR 33
82642: PUSH
82643: LD_STRING 
82645: ST_TO_ADDR
// end ;
82646: LD_VAR 0 1
82650: RET
// export function PrepareFrog ( ) ; begin
82651: LD_INT 0
82653: PPUSH
// uc_side := 0 ;
82654: LD_ADDR_OWVAR 20
82658: PUSH
82659: LD_INT 0
82661: ST_TO_ADDR
// uc_nation := 0 ;
82662: LD_ADDR_OWVAR 21
82666: PUSH
82667: LD_INT 0
82669: ST_TO_ADDR
// hc_class := class_frog ;
82670: LD_ADDR_OWVAR 28
82674: PUSH
82675: LD_INT 19
82677: ST_TO_ADDR
// hc_gallery :=  ;
82678: LD_ADDR_OWVAR 33
82682: PUSH
82683: LD_STRING 
82685: ST_TO_ADDR
// end ;
82686: LD_VAR 0 1
82690: RET
// export function PrepareFish ( ) ; begin
82691: LD_INT 0
82693: PPUSH
// uc_side := 0 ;
82694: LD_ADDR_OWVAR 20
82698: PUSH
82699: LD_INT 0
82701: ST_TO_ADDR
// uc_nation := 0 ;
82702: LD_ADDR_OWVAR 21
82706: PUSH
82707: LD_INT 0
82709: ST_TO_ADDR
// hc_class := class_fish ;
82710: LD_ADDR_OWVAR 28
82714: PUSH
82715: LD_INT 20
82717: ST_TO_ADDR
// hc_gallery :=  ;
82718: LD_ADDR_OWVAR 33
82722: PUSH
82723: LD_STRING 
82725: ST_TO_ADDR
// end ;
82726: LD_VAR 0 1
82730: RET
// export function PrepareBird ( ) ; begin
82731: LD_INT 0
82733: PPUSH
// uc_side := 0 ;
82734: LD_ADDR_OWVAR 20
82738: PUSH
82739: LD_INT 0
82741: ST_TO_ADDR
// uc_nation := 0 ;
82742: LD_ADDR_OWVAR 21
82746: PUSH
82747: LD_INT 0
82749: ST_TO_ADDR
// hc_class := class_phororhacos ;
82750: LD_ADDR_OWVAR 28
82754: PUSH
82755: LD_INT 18
82757: ST_TO_ADDR
// hc_gallery :=  ;
82758: LD_ADDR_OWVAR 33
82762: PUSH
82763: LD_STRING 
82765: ST_TO_ADDR
// end ;
82766: LD_VAR 0 1
82770: RET
// export function PrepareHorse ( ) ; begin
82771: LD_INT 0
82773: PPUSH
// uc_side := 0 ;
82774: LD_ADDR_OWVAR 20
82778: PUSH
82779: LD_INT 0
82781: ST_TO_ADDR
// uc_nation := 0 ;
82782: LD_ADDR_OWVAR 21
82786: PUSH
82787: LD_INT 0
82789: ST_TO_ADDR
// hc_class := class_horse ;
82790: LD_ADDR_OWVAR 28
82794: PUSH
82795: LD_INT 21
82797: ST_TO_ADDR
// hc_gallery :=  ;
82798: LD_ADDR_OWVAR 33
82802: PUSH
82803: LD_STRING 
82805: ST_TO_ADDR
// end ;
82806: LD_VAR 0 1
82810: RET
// export function PrepareMastodont ( ) ; begin
82811: LD_INT 0
82813: PPUSH
// uc_side := 0 ;
82814: LD_ADDR_OWVAR 20
82818: PUSH
82819: LD_INT 0
82821: ST_TO_ADDR
// uc_nation := 0 ;
82822: LD_ADDR_OWVAR 21
82826: PUSH
82827: LD_INT 0
82829: ST_TO_ADDR
// vc_chassis := class_mastodont ;
82830: LD_ADDR_OWVAR 37
82834: PUSH
82835: LD_INT 31
82837: ST_TO_ADDR
// vc_control := control_rider ;
82838: LD_ADDR_OWVAR 38
82842: PUSH
82843: LD_INT 4
82845: ST_TO_ADDR
// end ;
82846: LD_VAR 0 1
82850: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
82851: LD_INT 0
82853: PPUSH
82854: PPUSH
82855: PPUSH
// uc_side = 0 ;
82856: LD_ADDR_OWVAR 20
82860: PUSH
82861: LD_INT 0
82863: ST_TO_ADDR
// uc_nation = 0 ;
82864: LD_ADDR_OWVAR 21
82868: PUSH
82869: LD_INT 0
82871: ST_TO_ADDR
// InitHc_All ( ) ;
82872: CALL_OW 584
// InitVc ;
82876: CALL_OW 20
// if mastodonts then
82880: LD_VAR 0 6
82884: IFFALSE 82951
// for i = 1 to mastodonts do
82886: LD_ADDR_VAR 0 11
82890: PUSH
82891: DOUBLE
82892: LD_INT 1
82894: DEC
82895: ST_TO_ADDR
82896: LD_VAR 0 6
82900: PUSH
82901: FOR_TO
82902: IFFALSE 82949
// begin vc_chassis := 31 ;
82904: LD_ADDR_OWVAR 37
82908: PUSH
82909: LD_INT 31
82911: ST_TO_ADDR
// vc_control := control_rider ;
82912: LD_ADDR_OWVAR 38
82916: PUSH
82917: LD_INT 4
82919: ST_TO_ADDR
// animal := CreateVehicle ;
82920: LD_ADDR_VAR 0 12
82924: PUSH
82925: CALL_OW 45
82929: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82930: LD_VAR 0 12
82934: PPUSH
82935: LD_VAR 0 8
82939: PPUSH
82940: LD_INT 0
82942: PPUSH
82943: CALL 85079 0 3
// end ;
82947: GO 82901
82949: POP
82950: POP
// if horses then
82951: LD_VAR 0 5
82955: IFFALSE 83022
// for i = 1 to horses do
82957: LD_ADDR_VAR 0 11
82961: PUSH
82962: DOUBLE
82963: LD_INT 1
82965: DEC
82966: ST_TO_ADDR
82967: LD_VAR 0 5
82971: PUSH
82972: FOR_TO
82973: IFFALSE 83020
// begin hc_class := 21 ;
82975: LD_ADDR_OWVAR 28
82979: PUSH
82980: LD_INT 21
82982: ST_TO_ADDR
// hc_gallery :=  ;
82983: LD_ADDR_OWVAR 33
82987: PUSH
82988: LD_STRING 
82990: ST_TO_ADDR
// animal := CreateHuman ;
82991: LD_ADDR_VAR 0 12
82995: PUSH
82996: CALL_OW 44
83000: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83001: LD_VAR 0 12
83005: PPUSH
83006: LD_VAR 0 8
83010: PPUSH
83011: LD_INT 0
83013: PPUSH
83014: CALL 85079 0 3
// end ;
83018: GO 82972
83020: POP
83021: POP
// if birds then
83022: LD_VAR 0 1
83026: IFFALSE 83093
// for i = 1 to birds do
83028: LD_ADDR_VAR 0 11
83032: PUSH
83033: DOUBLE
83034: LD_INT 1
83036: DEC
83037: ST_TO_ADDR
83038: LD_VAR 0 1
83042: PUSH
83043: FOR_TO
83044: IFFALSE 83091
// begin hc_class = 18 ;
83046: LD_ADDR_OWVAR 28
83050: PUSH
83051: LD_INT 18
83053: ST_TO_ADDR
// hc_gallery =  ;
83054: LD_ADDR_OWVAR 33
83058: PUSH
83059: LD_STRING 
83061: ST_TO_ADDR
// animal := CreateHuman ;
83062: LD_ADDR_VAR 0 12
83066: PUSH
83067: CALL_OW 44
83071: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83072: LD_VAR 0 12
83076: PPUSH
83077: LD_VAR 0 8
83081: PPUSH
83082: LD_INT 0
83084: PPUSH
83085: CALL 85079 0 3
// end ;
83089: GO 83043
83091: POP
83092: POP
// if tigers then
83093: LD_VAR 0 2
83097: IFFALSE 83181
// for i = 1 to tigers do
83099: LD_ADDR_VAR 0 11
83103: PUSH
83104: DOUBLE
83105: LD_INT 1
83107: DEC
83108: ST_TO_ADDR
83109: LD_VAR 0 2
83113: PUSH
83114: FOR_TO
83115: IFFALSE 83179
// begin hc_class = class_tiger ;
83117: LD_ADDR_OWVAR 28
83121: PUSH
83122: LD_INT 14
83124: ST_TO_ADDR
// hc_gallery =  ;
83125: LD_ADDR_OWVAR 33
83129: PUSH
83130: LD_STRING 
83132: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
83133: LD_ADDR_OWVAR 35
83137: PUSH
83138: LD_INT 7
83140: NEG
83141: PPUSH
83142: LD_INT 7
83144: PPUSH
83145: CALL_OW 12
83149: ST_TO_ADDR
// animal := CreateHuman ;
83150: LD_ADDR_VAR 0 12
83154: PUSH
83155: CALL_OW 44
83159: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83160: LD_VAR 0 12
83164: PPUSH
83165: LD_VAR 0 8
83169: PPUSH
83170: LD_INT 0
83172: PPUSH
83173: CALL 85079 0 3
// end ;
83177: GO 83114
83179: POP
83180: POP
// if apemans then
83181: LD_VAR 0 3
83185: IFFALSE 83308
// for i = 1 to apemans do
83187: LD_ADDR_VAR 0 11
83191: PUSH
83192: DOUBLE
83193: LD_INT 1
83195: DEC
83196: ST_TO_ADDR
83197: LD_VAR 0 3
83201: PUSH
83202: FOR_TO
83203: IFFALSE 83306
// begin hc_class = class_apeman ;
83205: LD_ADDR_OWVAR 28
83209: PUSH
83210: LD_INT 12
83212: ST_TO_ADDR
// hc_gallery =  ;
83213: LD_ADDR_OWVAR 33
83217: PUSH
83218: LD_STRING 
83220: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
83221: LD_ADDR_OWVAR 35
83225: PUSH
83226: LD_INT 2
83228: NEG
83229: PPUSH
83230: LD_INT 2
83232: PPUSH
83233: CALL_OW 12
83237: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
83238: LD_ADDR_OWVAR 31
83242: PUSH
83243: LD_INT 1
83245: PPUSH
83246: LD_INT 3
83248: PPUSH
83249: CALL_OW 12
83253: PUSH
83254: LD_INT 1
83256: PPUSH
83257: LD_INT 3
83259: PPUSH
83260: CALL_OW 12
83264: PUSH
83265: LD_INT 0
83267: PUSH
83268: LD_INT 0
83270: PUSH
83271: EMPTY
83272: LIST
83273: LIST
83274: LIST
83275: LIST
83276: ST_TO_ADDR
// animal := CreateHuman ;
83277: LD_ADDR_VAR 0 12
83281: PUSH
83282: CALL_OW 44
83286: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83287: LD_VAR 0 12
83291: PPUSH
83292: LD_VAR 0 8
83296: PPUSH
83297: LD_INT 0
83299: PPUSH
83300: CALL 85079 0 3
// end ;
83304: GO 83202
83306: POP
83307: POP
// if enchidnas then
83308: LD_VAR 0 4
83312: IFFALSE 83379
// for i = 1 to enchidnas do
83314: LD_ADDR_VAR 0 11
83318: PUSH
83319: DOUBLE
83320: LD_INT 1
83322: DEC
83323: ST_TO_ADDR
83324: LD_VAR 0 4
83328: PUSH
83329: FOR_TO
83330: IFFALSE 83377
// begin hc_class = 13 ;
83332: LD_ADDR_OWVAR 28
83336: PUSH
83337: LD_INT 13
83339: ST_TO_ADDR
// hc_gallery =  ;
83340: LD_ADDR_OWVAR 33
83344: PUSH
83345: LD_STRING 
83347: ST_TO_ADDR
// animal := CreateHuman ;
83348: LD_ADDR_VAR 0 12
83352: PUSH
83353: CALL_OW 44
83357: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83358: LD_VAR 0 12
83362: PPUSH
83363: LD_VAR 0 8
83367: PPUSH
83368: LD_INT 0
83370: PPUSH
83371: CALL 85079 0 3
// end ;
83375: GO 83329
83377: POP
83378: POP
// if fishes then
83379: LD_VAR 0 7
83383: IFFALSE 83450
// for i = 1 to fishes do
83385: LD_ADDR_VAR 0 11
83389: PUSH
83390: DOUBLE
83391: LD_INT 1
83393: DEC
83394: ST_TO_ADDR
83395: LD_VAR 0 7
83399: PUSH
83400: FOR_TO
83401: IFFALSE 83448
// begin hc_class = 20 ;
83403: LD_ADDR_OWVAR 28
83407: PUSH
83408: LD_INT 20
83410: ST_TO_ADDR
// hc_gallery =  ;
83411: LD_ADDR_OWVAR 33
83415: PUSH
83416: LD_STRING 
83418: ST_TO_ADDR
// animal := CreateHuman ;
83419: LD_ADDR_VAR 0 12
83423: PUSH
83424: CALL_OW 44
83428: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
83429: LD_VAR 0 12
83433: PPUSH
83434: LD_VAR 0 9
83438: PPUSH
83439: LD_INT 0
83441: PPUSH
83442: CALL 85079 0 3
// end ;
83446: GO 83400
83448: POP
83449: POP
// end ;
83450: LD_VAR 0 10
83454: RET
// export function WantHeal ( sci , unit ) ; begin
83455: LD_INT 0
83457: PPUSH
// if GetTaskList ( sci ) > 0 then
83458: LD_VAR 0 1
83462: PPUSH
83463: CALL_OW 437
83467: PUSH
83468: LD_INT 0
83470: GREATER
83471: IFFALSE 83541
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
83473: LD_VAR 0 1
83477: PPUSH
83478: CALL_OW 437
83482: PUSH
83483: LD_INT 1
83485: ARRAY
83486: PUSH
83487: LD_INT 1
83489: ARRAY
83490: PUSH
83491: LD_STRING l
83493: EQUAL
83494: PUSH
83495: LD_VAR 0 1
83499: PPUSH
83500: CALL_OW 437
83504: PUSH
83505: LD_INT 1
83507: ARRAY
83508: PUSH
83509: LD_INT 4
83511: ARRAY
83512: PUSH
83513: LD_VAR 0 2
83517: EQUAL
83518: AND
83519: IFFALSE 83531
// result := true else
83521: LD_ADDR_VAR 0 3
83525: PUSH
83526: LD_INT 1
83528: ST_TO_ADDR
83529: GO 83539
// result := false ;
83531: LD_ADDR_VAR 0 3
83535: PUSH
83536: LD_INT 0
83538: ST_TO_ADDR
// end else
83539: GO 83549
// result := false ;
83541: LD_ADDR_VAR 0 3
83545: PUSH
83546: LD_INT 0
83548: ST_TO_ADDR
// end ;
83549: LD_VAR 0 3
83553: RET
// export function HealTarget ( sci ) ; begin
83554: LD_INT 0
83556: PPUSH
// if not sci then
83557: LD_VAR 0 1
83561: NOT
83562: IFFALSE 83566
// exit ;
83564: GO 83631
// result := 0 ;
83566: LD_ADDR_VAR 0 2
83570: PUSH
83571: LD_INT 0
83573: ST_TO_ADDR
// if GetTaskList ( sci ) then
83574: LD_VAR 0 1
83578: PPUSH
83579: CALL_OW 437
83583: IFFALSE 83631
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
83585: LD_VAR 0 1
83589: PPUSH
83590: CALL_OW 437
83594: PUSH
83595: LD_INT 1
83597: ARRAY
83598: PUSH
83599: LD_INT 1
83601: ARRAY
83602: PUSH
83603: LD_STRING l
83605: EQUAL
83606: IFFALSE 83631
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
83608: LD_ADDR_VAR 0 2
83612: PUSH
83613: LD_VAR 0 1
83617: PPUSH
83618: CALL_OW 437
83622: PUSH
83623: LD_INT 1
83625: ARRAY
83626: PUSH
83627: LD_INT 4
83629: ARRAY
83630: ST_TO_ADDR
// end ;
83631: LD_VAR 0 2
83635: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
83636: LD_INT 0
83638: PPUSH
83639: PPUSH
83640: PPUSH
83641: PPUSH
// if not base_units then
83642: LD_VAR 0 1
83646: NOT
83647: IFFALSE 83651
// exit ;
83649: GO 83738
// result := false ;
83651: LD_ADDR_VAR 0 2
83655: PUSH
83656: LD_INT 0
83658: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
83659: LD_ADDR_VAR 0 5
83663: PUSH
83664: LD_VAR 0 1
83668: PPUSH
83669: LD_INT 21
83671: PUSH
83672: LD_INT 3
83674: PUSH
83675: EMPTY
83676: LIST
83677: LIST
83678: PPUSH
83679: CALL_OW 72
83683: ST_TO_ADDR
// if not tmp then
83684: LD_VAR 0 5
83688: NOT
83689: IFFALSE 83693
// exit ;
83691: GO 83738
// for i in tmp do
83693: LD_ADDR_VAR 0 3
83697: PUSH
83698: LD_VAR 0 5
83702: PUSH
83703: FOR_IN
83704: IFFALSE 83736
// begin result := EnemyInRange ( i , 22 ) ;
83706: LD_ADDR_VAR 0 2
83710: PUSH
83711: LD_VAR 0 3
83715: PPUSH
83716: LD_INT 22
83718: PPUSH
83719: CALL 81325 0 2
83723: ST_TO_ADDR
// if result then
83724: LD_VAR 0 2
83728: IFFALSE 83734
// exit ;
83730: POP
83731: POP
83732: GO 83738
// end ;
83734: GO 83703
83736: POP
83737: POP
// end ;
83738: LD_VAR 0 2
83742: RET
// export function FilterByTag ( units , tag ) ; begin
83743: LD_INT 0
83745: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
83746: LD_ADDR_VAR 0 3
83750: PUSH
83751: LD_VAR 0 1
83755: PPUSH
83756: LD_INT 120
83758: PUSH
83759: LD_VAR 0 2
83763: PUSH
83764: EMPTY
83765: LIST
83766: LIST
83767: PPUSH
83768: CALL_OW 72
83772: ST_TO_ADDR
// end ;
83773: LD_VAR 0 3
83777: RET
// export function IsDriver ( un ) ; begin
83778: LD_INT 0
83780: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
83781: LD_ADDR_VAR 0 2
83785: PUSH
83786: LD_VAR 0 1
83790: PUSH
83791: LD_INT 55
83793: PUSH
83794: EMPTY
83795: LIST
83796: PPUSH
83797: CALL_OW 69
83801: IN
83802: ST_TO_ADDR
// end ;
83803: LD_VAR 0 2
83807: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
83808: LD_INT 0
83810: PPUSH
83811: PPUSH
// list := [ ] ;
83812: LD_ADDR_VAR 0 5
83816: PUSH
83817: EMPTY
83818: ST_TO_ADDR
// case d of 0 :
83819: LD_VAR 0 3
83823: PUSH
83824: LD_INT 0
83826: DOUBLE
83827: EQUAL
83828: IFTRUE 83832
83830: GO 83965
83832: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
83833: LD_ADDR_VAR 0 5
83837: PUSH
83838: LD_VAR 0 1
83842: PUSH
83843: LD_INT 4
83845: MINUS
83846: PUSH
83847: LD_VAR 0 2
83851: PUSH
83852: LD_INT 4
83854: MINUS
83855: PUSH
83856: LD_INT 2
83858: PUSH
83859: EMPTY
83860: LIST
83861: LIST
83862: LIST
83863: PUSH
83864: LD_VAR 0 1
83868: PUSH
83869: LD_INT 3
83871: MINUS
83872: PUSH
83873: LD_VAR 0 2
83877: PUSH
83878: LD_INT 1
83880: PUSH
83881: EMPTY
83882: LIST
83883: LIST
83884: LIST
83885: PUSH
83886: LD_VAR 0 1
83890: PUSH
83891: LD_INT 4
83893: PLUS
83894: PUSH
83895: LD_VAR 0 2
83899: PUSH
83900: LD_INT 4
83902: PUSH
83903: EMPTY
83904: LIST
83905: LIST
83906: LIST
83907: PUSH
83908: LD_VAR 0 1
83912: PUSH
83913: LD_INT 3
83915: PLUS
83916: PUSH
83917: LD_VAR 0 2
83921: PUSH
83922: LD_INT 3
83924: PLUS
83925: PUSH
83926: LD_INT 5
83928: PUSH
83929: EMPTY
83930: LIST
83931: LIST
83932: LIST
83933: PUSH
83934: LD_VAR 0 1
83938: PUSH
83939: LD_VAR 0 2
83943: PUSH
83944: LD_INT 4
83946: PLUS
83947: PUSH
83948: LD_INT 0
83950: PUSH
83951: EMPTY
83952: LIST
83953: LIST
83954: LIST
83955: PUSH
83956: EMPTY
83957: LIST
83958: LIST
83959: LIST
83960: LIST
83961: LIST
83962: ST_TO_ADDR
// end ; 1 :
83963: GO 84663
83965: LD_INT 1
83967: DOUBLE
83968: EQUAL
83969: IFTRUE 83973
83971: GO 84106
83973: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
83974: LD_ADDR_VAR 0 5
83978: PUSH
83979: LD_VAR 0 1
83983: PUSH
83984: LD_VAR 0 2
83988: PUSH
83989: LD_INT 4
83991: MINUS
83992: PUSH
83993: LD_INT 3
83995: PUSH
83996: EMPTY
83997: LIST
83998: LIST
83999: LIST
84000: PUSH
84001: LD_VAR 0 1
84005: PUSH
84006: LD_INT 3
84008: MINUS
84009: PUSH
84010: LD_VAR 0 2
84014: PUSH
84015: LD_INT 3
84017: MINUS
84018: PUSH
84019: LD_INT 2
84021: PUSH
84022: EMPTY
84023: LIST
84024: LIST
84025: LIST
84026: PUSH
84027: LD_VAR 0 1
84031: PUSH
84032: LD_INT 4
84034: MINUS
84035: PUSH
84036: LD_VAR 0 2
84040: PUSH
84041: LD_INT 1
84043: PUSH
84044: EMPTY
84045: LIST
84046: LIST
84047: LIST
84048: PUSH
84049: LD_VAR 0 1
84053: PUSH
84054: LD_VAR 0 2
84058: PUSH
84059: LD_INT 3
84061: PLUS
84062: PUSH
84063: LD_INT 0
84065: PUSH
84066: EMPTY
84067: LIST
84068: LIST
84069: LIST
84070: PUSH
84071: LD_VAR 0 1
84075: PUSH
84076: LD_INT 4
84078: PLUS
84079: PUSH
84080: LD_VAR 0 2
84084: PUSH
84085: LD_INT 4
84087: PLUS
84088: PUSH
84089: LD_INT 5
84091: PUSH
84092: EMPTY
84093: LIST
84094: LIST
84095: LIST
84096: PUSH
84097: EMPTY
84098: LIST
84099: LIST
84100: LIST
84101: LIST
84102: LIST
84103: ST_TO_ADDR
// end ; 2 :
84104: GO 84663
84106: LD_INT 2
84108: DOUBLE
84109: EQUAL
84110: IFTRUE 84114
84112: GO 84243
84114: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
84115: LD_ADDR_VAR 0 5
84119: PUSH
84120: LD_VAR 0 1
84124: PUSH
84125: LD_VAR 0 2
84129: PUSH
84130: LD_INT 3
84132: MINUS
84133: PUSH
84134: LD_INT 3
84136: PUSH
84137: EMPTY
84138: LIST
84139: LIST
84140: LIST
84141: PUSH
84142: LD_VAR 0 1
84146: PUSH
84147: LD_INT 4
84149: PLUS
84150: PUSH
84151: LD_VAR 0 2
84155: PUSH
84156: LD_INT 4
84158: PUSH
84159: EMPTY
84160: LIST
84161: LIST
84162: LIST
84163: PUSH
84164: LD_VAR 0 1
84168: PUSH
84169: LD_VAR 0 2
84173: PUSH
84174: LD_INT 4
84176: PLUS
84177: PUSH
84178: LD_INT 0
84180: PUSH
84181: EMPTY
84182: LIST
84183: LIST
84184: LIST
84185: PUSH
84186: LD_VAR 0 1
84190: PUSH
84191: LD_INT 3
84193: MINUS
84194: PUSH
84195: LD_VAR 0 2
84199: PUSH
84200: LD_INT 1
84202: PUSH
84203: EMPTY
84204: LIST
84205: LIST
84206: LIST
84207: PUSH
84208: LD_VAR 0 1
84212: PUSH
84213: LD_INT 4
84215: MINUS
84216: PUSH
84217: LD_VAR 0 2
84221: PUSH
84222: LD_INT 4
84224: MINUS
84225: PUSH
84226: LD_INT 2
84228: PUSH
84229: EMPTY
84230: LIST
84231: LIST
84232: LIST
84233: PUSH
84234: EMPTY
84235: LIST
84236: LIST
84237: LIST
84238: LIST
84239: LIST
84240: ST_TO_ADDR
// end ; 3 :
84241: GO 84663
84243: LD_INT 3
84245: DOUBLE
84246: EQUAL
84247: IFTRUE 84251
84249: GO 84384
84251: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
84252: LD_ADDR_VAR 0 5
84256: PUSH
84257: LD_VAR 0 1
84261: PUSH
84262: LD_INT 3
84264: PLUS
84265: PUSH
84266: LD_VAR 0 2
84270: PUSH
84271: LD_INT 4
84273: PUSH
84274: EMPTY
84275: LIST
84276: LIST
84277: LIST
84278: PUSH
84279: LD_VAR 0 1
84283: PUSH
84284: LD_INT 4
84286: PLUS
84287: PUSH
84288: LD_VAR 0 2
84292: PUSH
84293: LD_INT 4
84295: PLUS
84296: PUSH
84297: LD_INT 5
84299: PUSH
84300: EMPTY
84301: LIST
84302: LIST
84303: LIST
84304: PUSH
84305: LD_VAR 0 1
84309: PUSH
84310: LD_INT 4
84312: MINUS
84313: PUSH
84314: LD_VAR 0 2
84318: PUSH
84319: LD_INT 1
84321: PUSH
84322: EMPTY
84323: LIST
84324: LIST
84325: LIST
84326: PUSH
84327: LD_VAR 0 1
84331: PUSH
84332: LD_VAR 0 2
84336: PUSH
84337: LD_INT 4
84339: MINUS
84340: PUSH
84341: LD_INT 3
84343: PUSH
84344: EMPTY
84345: LIST
84346: LIST
84347: LIST
84348: PUSH
84349: LD_VAR 0 1
84353: PUSH
84354: LD_INT 3
84356: MINUS
84357: PUSH
84358: LD_VAR 0 2
84362: PUSH
84363: LD_INT 3
84365: MINUS
84366: PUSH
84367: LD_INT 2
84369: PUSH
84370: EMPTY
84371: LIST
84372: LIST
84373: LIST
84374: PUSH
84375: EMPTY
84376: LIST
84377: LIST
84378: LIST
84379: LIST
84380: LIST
84381: ST_TO_ADDR
// end ; 4 :
84382: GO 84663
84384: LD_INT 4
84386: DOUBLE
84387: EQUAL
84388: IFTRUE 84392
84390: GO 84525
84392: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
84393: LD_ADDR_VAR 0 5
84397: PUSH
84398: LD_VAR 0 1
84402: PUSH
84403: LD_VAR 0 2
84407: PUSH
84408: LD_INT 4
84410: PLUS
84411: PUSH
84412: LD_INT 0
84414: PUSH
84415: EMPTY
84416: LIST
84417: LIST
84418: LIST
84419: PUSH
84420: LD_VAR 0 1
84424: PUSH
84425: LD_INT 3
84427: PLUS
84428: PUSH
84429: LD_VAR 0 2
84433: PUSH
84434: LD_INT 3
84436: PLUS
84437: PUSH
84438: LD_INT 5
84440: PUSH
84441: EMPTY
84442: LIST
84443: LIST
84444: LIST
84445: PUSH
84446: LD_VAR 0 1
84450: PUSH
84451: LD_INT 4
84453: PLUS
84454: PUSH
84455: LD_VAR 0 2
84459: PUSH
84460: LD_INT 4
84462: PUSH
84463: EMPTY
84464: LIST
84465: LIST
84466: LIST
84467: PUSH
84468: LD_VAR 0 1
84472: PUSH
84473: LD_VAR 0 2
84477: PUSH
84478: LD_INT 3
84480: MINUS
84481: PUSH
84482: LD_INT 3
84484: PUSH
84485: EMPTY
84486: LIST
84487: LIST
84488: LIST
84489: PUSH
84490: LD_VAR 0 1
84494: PUSH
84495: LD_INT 4
84497: MINUS
84498: PUSH
84499: LD_VAR 0 2
84503: PUSH
84504: LD_INT 4
84506: MINUS
84507: PUSH
84508: LD_INT 2
84510: PUSH
84511: EMPTY
84512: LIST
84513: LIST
84514: LIST
84515: PUSH
84516: EMPTY
84517: LIST
84518: LIST
84519: LIST
84520: LIST
84521: LIST
84522: ST_TO_ADDR
// end ; 5 :
84523: GO 84663
84525: LD_INT 5
84527: DOUBLE
84528: EQUAL
84529: IFTRUE 84533
84531: GO 84662
84533: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
84534: LD_ADDR_VAR 0 5
84538: PUSH
84539: LD_VAR 0 1
84543: PUSH
84544: LD_INT 4
84546: MINUS
84547: PUSH
84548: LD_VAR 0 2
84552: PUSH
84553: LD_INT 1
84555: PUSH
84556: EMPTY
84557: LIST
84558: LIST
84559: LIST
84560: PUSH
84561: LD_VAR 0 1
84565: PUSH
84566: LD_VAR 0 2
84570: PUSH
84571: LD_INT 4
84573: MINUS
84574: PUSH
84575: LD_INT 3
84577: PUSH
84578: EMPTY
84579: LIST
84580: LIST
84581: LIST
84582: PUSH
84583: LD_VAR 0 1
84587: PUSH
84588: LD_INT 4
84590: PLUS
84591: PUSH
84592: LD_VAR 0 2
84596: PUSH
84597: LD_INT 4
84599: PLUS
84600: PUSH
84601: LD_INT 5
84603: PUSH
84604: EMPTY
84605: LIST
84606: LIST
84607: LIST
84608: PUSH
84609: LD_VAR 0 1
84613: PUSH
84614: LD_INT 3
84616: PLUS
84617: PUSH
84618: LD_VAR 0 2
84622: PUSH
84623: LD_INT 4
84625: PUSH
84626: EMPTY
84627: LIST
84628: LIST
84629: LIST
84630: PUSH
84631: LD_VAR 0 1
84635: PUSH
84636: LD_VAR 0 2
84640: PUSH
84641: LD_INT 3
84643: PLUS
84644: PUSH
84645: LD_INT 0
84647: PUSH
84648: EMPTY
84649: LIST
84650: LIST
84651: LIST
84652: PUSH
84653: EMPTY
84654: LIST
84655: LIST
84656: LIST
84657: LIST
84658: LIST
84659: ST_TO_ADDR
// end ; end ;
84660: GO 84663
84662: POP
// result := list ;
84663: LD_ADDR_VAR 0 4
84667: PUSH
84668: LD_VAR 0 5
84672: ST_TO_ADDR
// end ;
84673: LD_VAR 0 4
84677: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
84678: LD_INT 0
84680: PPUSH
84681: PPUSH
84682: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
84683: LD_VAR 0 1
84687: NOT
84688: PUSH
84689: LD_VAR 0 2
84693: PUSH
84694: LD_INT 1
84696: PUSH
84697: LD_INT 2
84699: PUSH
84700: LD_INT 3
84702: PUSH
84703: LD_INT 4
84705: PUSH
84706: EMPTY
84707: LIST
84708: LIST
84709: LIST
84710: LIST
84711: IN
84712: NOT
84713: OR
84714: IFFALSE 84718
// exit ;
84716: GO 84801
// tmp := [ ] ;
84718: LD_ADDR_VAR 0 5
84722: PUSH
84723: EMPTY
84724: ST_TO_ADDR
// for i in units do
84725: LD_ADDR_VAR 0 4
84729: PUSH
84730: LD_VAR 0 1
84734: PUSH
84735: FOR_IN
84736: IFFALSE 84770
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
84738: LD_ADDR_VAR 0 5
84742: PUSH
84743: LD_VAR 0 5
84747: PPUSH
84748: LD_VAR 0 4
84752: PPUSH
84753: LD_VAR 0 2
84757: PPUSH
84758: CALL_OW 259
84762: PPUSH
84763: CALL 86162 0 2
84767: ST_TO_ADDR
84768: GO 84735
84770: POP
84771: POP
// if not tmp then
84772: LD_VAR 0 5
84776: NOT
84777: IFFALSE 84781
// exit ;
84779: GO 84801
// result := SortListByListDesc ( units , tmp ) ;
84781: LD_ADDR_VAR 0 3
84785: PUSH
84786: LD_VAR 0 1
84790: PPUSH
84791: LD_VAR 0 5
84795: PPUSH
84796: CALL_OW 77
84800: ST_TO_ADDR
// end ;
84801: LD_VAR 0 3
84805: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
84806: LD_INT 0
84808: PPUSH
84809: PPUSH
84810: PPUSH
// result := false ;
84811: LD_ADDR_VAR 0 3
84815: PUSH
84816: LD_INT 0
84818: ST_TO_ADDR
// if not building then
84819: LD_VAR 0 2
84823: NOT
84824: IFFALSE 84828
// exit ;
84826: GO 84966
// x := GetX ( building ) ;
84828: LD_ADDR_VAR 0 4
84832: PUSH
84833: LD_VAR 0 2
84837: PPUSH
84838: CALL_OW 250
84842: ST_TO_ADDR
// y := GetY ( building ) ;
84843: LD_ADDR_VAR 0 5
84847: PUSH
84848: LD_VAR 0 2
84852: PPUSH
84853: CALL_OW 251
84857: ST_TO_ADDR
// if not x or not y then
84858: LD_VAR 0 4
84862: NOT
84863: PUSH
84864: LD_VAR 0 5
84868: NOT
84869: OR
84870: IFFALSE 84874
// exit ;
84872: GO 84966
// if GetTaskList ( unit ) then
84874: LD_VAR 0 1
84878: PPUSH
84879: CALL_OW 437
84883: IFFALSE 84966
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
84885: LD_STRING e
84887: PUSH
84888: LD_VAR 0 1
84892: PPUSH
84893: CALL_OW 437
84897: PUSH
84898: LD_INT 1
84900: ARRAY
84901: PUSH
84902: LD_INT 1
84904: ARRAY
84905: EQUAL
84906: PUSH
84907: LD_VAR 0 4
84911: PUSH
84912: LD_VAR 0 1
84916: PPUSH
84917: CALL_OW 437
84921: PUSH
84922: LD_INT 1
84924: ARRAY
84925: PUSH
84926: LD_INT 2
84928: ARRAY
84929: EQUAL
84930: AND
84931: PUSH
84932: LD_VAR 0 5
84936: PUSH
84937: LD_VAR 0 1
84941: PPUSH
84942: CALL_OW 437
84946: PUSH
84947: LD_INT 1
84949: ARRAY
84950: PUSH
84951: LD_INT 3
84953: ARRAY
84954: EQUAL
84955: AND
84956: IFFALSE 84966
// result := true end ;
84958: LD_ADDR_VAR 0 3
84962: PUSH
84963: LD_INT 1
84965: ST_TO_ADDR
// end ;
84966: LD_VAR 0 3
84970: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
84971: LD_INT 0
84973: PPUSH
// result := false ;
84974: LD_ADDR_VAR 0 4
84978: PUSH
84979: LD_INT 0
84981: ST_TO_ADDR
// if GetTaskList ( unit ) then
84982: LD_VAR 0 1
84986: PPUSH
84987: CALL_OW 437
84991: IFFALSE 85074
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
84993: LD_STRING M
84995: PUSH
84996: LD_VAR 0 1
85000: PPUSH
85001: CALL_OW 437
85005: PUSH
85006: LD_INT 1
85008: ARRAY
85009: PUSH
85010: LD_INT 1
85012: ARRAY
85013: EQUAL
85014: PUSH
85015: LD_VAR 0 2
85019: PUSH
85020: LD_VAR 0 1
85024: PPUSH
85025: CALL_OW 437
85029: PUSH
85030: LD_INT 1
85032: ARRAY
85033: PUSH
85034: LD_INT 2
85036: ARRAY
85037: EQUAL
85038: AND
85039: PUSH
85040: LD_VAR 0 3
85044: PUSH
85045: LD_VAR 0 1
85049: PPUSH
85050: CALL_OW 437
85054: PUSH
85055: LD_INT 1
85057: ARRAY
85058: PUSH
85059: LD_INT 3
85061: ARRAY
85062: EQUAL
85063: AND
85064: IFFALSE 85074
// result := true ;
85066: LD_ADDR_VAR 0 4
85070: PUSH
85071: LD_INT 1
85073: ST_TO_ADDR
// end ; end ;
85074: LD_VAR 0 4
85078: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
85079: LD_INT 0
85081: PPUSH
85082: PPUSH
85083: PPUSH
85084: PPUSH
// if not unit or not area then
85085: LD_VAR 0 1
85089: NOT
85090: PUSH
85091: LD_VAR 0 2
85095: NOT
85096: OR
85097: IFFALSE 85101
// exit ;
85099: GO 85265
// tmp := AreaToList ( area , i ) ;
85101: LD_ADDR_VAR 0 6
85105: PUSH
85106: LD_VAR 0 2
85110: PPUSH
85111: LD_VAR 0 5
85115: PPUSH
85116: CALL_OW 517
85120: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
85121: LD_ADDR_VAR 0 5
85125: PUSH
85126: DOUBLE
85127: LD_INT 1
85129: DEC
85130: ST_TO_ADDR
85131: LD_VAR 0 6
85135: PUSH
85136: LD_INT 1
85138: ARRAY
85139: PUSH
85140: FOR_TO
85141: IFFALSE 85263
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
85143: LD_ADDR_VAR 0 7
85147: PUSH
85148: LD_VAR 0 6
85152: PUSH
85153: LD_INT 1
85155: ARRAY
85156: PUSH
85157: LD_VAR 0 5
85161: ARRAY
85162: PUSH
85163: LD_VAR 0 6
85167: PUSH
85168: LD_INT 2
85170: ARRAY
85171: PUSH
85172: LD_VAR 0 5
85176: ARRAY
85177: PUSH
85178: EMPTY
85179: LIST
85180: LIST
85181: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
85182: LD_VAR 0 7
85186: PUSH
85187: LD_INT 1
85189: ARRAY
85190: PPUSH
85191: LD_VAR 0 7
85195: PUSH
85196: LD_INT 2
85198: ARRAY
85199: PPUSH
85200: CALL_OW 428
85204: PUSH
85205: LD_INT 0
85207: EQUAL
85208: IFFALSE 85261
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
85210: LD_VAR 0 1
85214: PPUSH
85215: LD_VAR 0 7
85219: PUSH
85220: LD_INT 1
85222: ARRAY
85223: PPUSH
85224: LD_VAR 0 7
85228: PUSH
85229: LD_INT 2
85231: ARRAY
85232: PPUSH
85233: LD_VAR 0 3
85237: PPUSH
85238: CALL_OW 48
// result := IsPlaced ( unit ) ;
85242: LD_ADDR_VAR 0 4
85246: PUSH
85247: LD_VAR 0 1
85251: PPUSH
85252: CALL_OW 305
85256: ST_TO_ADDR
// exit ;
85257: POP
85258: POP
85259: GO 85265
// end ; end ;
85261: GO 85140
85263: POP
85264: POP
// end ;
85265: LD_VAR 0 4
85269: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
85270: LD_INT 0
85272: PPUSH
85273: PPUSH
85274: PPUSH
// if not side or side > 8 then
85275: LD_VAR 0 1
85279: NOT
85280: PUSH
85281: LD_VAR 0 1
85285: PUSH
85286: LD_INT 8
85288: GREATER
85289: OR
85290: IFFALSE 85294
// exit ;
85292: GO 85481
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
85294: LD_ADDR_VAR 0 4
85298: PUSH
85299: LD_INT 22
85301: PUSH
85302: LD_VAR 0 1
85306: PUSH
85307: EMPTY
85308: LIST
85309: LIST
85310: PUSH
85311: LD_INT 21
85313: PUSH
85314: LD_INT 3
85316: PUSH
85317: EMPTY
85318: LIST
85319: LIST
85320: PUSH
85321: EMPTY
85322: LIST
85323: LIST
85324: PPUSH
85325: CALL_OW 69
85329: ST_TO_ADDR
// if not tmp then
85330: LD_VAR 0 4
85334: NOT
85335: IFFALSE 85339
// exit ;
85337: GO 85481
// enable_addtolog := true ;
85339: LD_ADDR_OWVAR 81
85343: PUSH
85344: LD_INT 1
85346: ST_TO_ADDR
// AddToLog ( [ ) ;
85347: LD_STRING [
85349: PPUSH
85350: CALL_OW 561
// for i in tmp do
85354: LD_ADDR_VAR 0 3
85358: PUSH
85359: LD_VAR 0 4
85363: PUSH
85364: FOR_IN
85365: IFFALSE 85472
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
85367: LD_STRING [
85369: PUSH
85370: LD_VAR 0 3
85374: PPUSH
85375: CALL_OW 266
85379: STR
85380: PUSH
85381: LD_STRING , 
85383: STR
85384: PUSH
85385: LD_VAR 0 3
85389: PPUSH
85390: CALL_OW 250
85394: STR
85395: PUSH
85396: LD_STRING , 
85398: STR
85399: PUSH
85400: LD_VAR 0 3
85404: PPUSH
85405: CALL_OW 251
85409: STR
85410: PUSH
85411: LD_STRING , 
85413: STR
85414: PUSH
85415: LD_VAR 0 3
85419: PPUSH
85420: CALL_OW 254
85424: STR
85425: PUSH
85426: LD_STRING , 
85428: STR
85429: PUSH
85430: LD_VAR 0 3
85434: PPUSH
85435: LD_INT 1
85437: PPUSH
85438: CALL_OW 268
85442: STR
85443: PUSH
85444: LD_STRING , 
85446: STR
85447: PUSH
85448: LD_VAR 0 3
85452: PPUSH
85453: LD_INT 2
85455: PPUSH
85456: CALL_OW 268
85460: STR
85461: PUSH
85462: LD_STRING ],
85464: STR
85465: PPUSH
85466: CALL_OW 561
// end ;
85470: GO 85364
85472: POP
85473: POP
// AddToLog ( ]; ) ;
85474: LD_STRING ];
85476: PPUSH
85477: CALL_OW 561
// end ;
85481: LD_VAR 0 2
85485: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
85486: LD_INT 0
85488: PPUSH
85489: PPUSH
85490: PPUSH
85491: PPUSH
85492: PPUSH
// if not area or not rate or not max then
85493: LD_VAR 0 1
85497: NOT
85498: PUSH
85499: LD_VAR 0 2
85503: NOT
85504: OR
85505: PUSH
85506: LD_VAR 0 4
85510: NOT
85511: OR
85512: IFFALSE 85516
// exit ;
85514: GO 85705
// while 1 do
85516: LD_INT 1
85518: IFFALSE 85705
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
85520: LD_ADDR_VAR 0 9
85524: PUSH
85525: LD_VAR 0 1
85529: PPUSH
85530: LD_INT 1
85532: PPUSH
85533: CALL_OW 287
85537: PUSH
85538: LD_INT 10
85540: MUL
85541: ST_TO_ADDR
// r := rate / 10 ;
85542: LD_ADDR_VAR 0 7
85546: PUSH
85547: LD_VAR 0 2
85551: PUSH
85552: LD_INT 10
85554: DIVREAL
85555: ST_TO_ADDR
// time := 1 1$00 ;
85556: LD_ADDR_VAR 0 8
85560: PUSH
85561: LD_INT 2100
85563: ST_TO_ADDR
// if amount < min then
85564: LD_VAR 0 9
85568: PUSH
85569: LD_VAR 0 3
85573: LESS
85574: IFFALSE 85592
// r := r * 2 else
85576: LD_ADDR_VAR 0 7
85580: PUSH
85581: LD_VAR 0 7
85585: PUSH
85586: LD_INT 2
85588: MUL
85589: ST_TO_ADDR
85590: GO 85618
// if amount > max then
85592: LD_VAR 0 9
85596: PUSH
85597: LD_VAR 0 4
85601: GREATER
85602: IFFALSE 85618
// r := r / 2 ;
85604: LD_ADDR_VAR 0 7
85608: PUSH
85609: LD_VAR 0 7
85613: PUSH
85614: LD_INT 2
85616: DIVREAL
85617: ST_TO_ADDR
// time := time / r ;
85618: LD_ADDR_VAR 0 8
85622: PUSH
85623: LD_VAR 0 8
85627: PUSH
85628: LD_VAR 0 7
85632: DIVREAL
85633: ST_TO_ADDR
// if time < 0 then
85634: LD_VAR 0 8
85638: PUSH
85639: LD_INT 0
85641: LESS
85642: IFFALSE 85659
// time := time * - 1 ;
85644: LD_ADDR_VAR 0 8
85648: PUSH
85649: LD_VAR 0 8
85653: PUSH
85654: LD_INT 1
85656: NEG
85657: MUL
85658: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
85659: LD_VAR 0 8
85663: PUSH
85664: LD_INT 35
85666: PPUSH
85667: LD_INT 875
85669: PPUSH
85670: CALL_OW 12
85674: PLUS
85675: PPUSH
85676: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
85680: LD_INT 1
85682: PPUSH
85683: LD_INT 5
85685: PPUSH
85686: CALL_OW 12
85690: PPUSH
85691: LD_VAR 0 1
85695: PPUSH
85696: LD_INT 1
85698: PPUSH
85699: CALL_OW 55
// end ;
85703: GO 85516
// end ;
85705: LD_VAR 0 5
85709: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
85710: LD_INT 0
85712: PPUSH
85713: PPUSH
85714: PPUSH
85715: PPUSH
85716: PPUSH
85717: PPUSH
85718: PPUSH
85719: PPUSH
// if not turrets or not factories then
85720: LD_VAR 0 1
85724: NOT
85725: PUSH
85726: LD_VAR 0 2
85730: NOT
85731: OR
85732: IFFALSE 85736
// exit ;
85734: GO 86043
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
85736: LD_ADDR_VAR 0 10
85740: PUSH
85741: LD_INT 5
85743: PUSH
85744: LD_INT 6
85746: PUSH
85747: EMPTY
85748: LIST
85749: LIST
85750: PUSH
85751: LD_INT 2
85753: PUSH
85754: LD_INT 4
85756: PUSH
85757: EMPTY
85758: LIST
85759: LIST
85760: PUSH
85761: LD_INT 3
85763: PUSH
85764: LD_INT 5
85766: PUSH
85767: EMPTY
85768: LIST
85769: LIST
85770: PUSH
85771: EMPTY
85772: LIST
85773: LIST
85774: LIST
85775: PUSH
85776: LD_INT 24
85778: PUSH
85779: LD_INT 25
85781: PUSH
85782: EMPTY
85783: LIST
85784: LIST
85785: PUSH
85786: LD_INT 23
85788: PUSH
85789: LD_INT 27
85791: PUSH
85792: EMPTY
85793: LIST
85794: LIST
85795: PUSH
85796: EMPTY
85797: LIST
85798: LIST
85799: PUSH
85800: LD_INT 42
85802: PUSH
85803: LD_INT 43
85805: PUSH
85806: EMPTY
85807: LIST
85808: LIST
85809: PUSH
85810: LD_INT 44
85812: PUSH
85813: LD_INT 46
85815: PUSH
85816: EMPTY
85817: LIST
85818: LIST
85819: PUSH
85820: LD_INT 45
85822: PUSH
85823: LD_INT 47
85825: PUSH
85826: EMPTY
85827: LIST
85828: LIST
85829: PUSH
85830: EMPTY
85831: LIST
85832: LIST
85833: LIST
85834: PUSH
85835: EMPTY
85836: LIST
85837: LIST
85838: LIST
85839: ST_TO_ADDR
// result := [ ] ;
85840: LD_ADDR_VAR 0 3
85844: PUSH
85845: EMPTY
85846: ST_TO_ADDR
// for i in turrets do
85847: LD_ADDR_VAR 0 4
85851: PUSH
85852: LD_VAR 0 1
85856: PUSH
85857: FOR_IN
85858: IFFALSE 86041
// begin nat := GetNation ( i ) ;
85860: LD_ADDR_VAR 0 7
85864: PUSH
85865: LD_VAR 0 4
85869: PPUSH
85870: CALL_OW 248
85874: ST_TO_ADDR
// weapon := 0 ;
85875: LD_ADDR_VAR 0 8
85879: PUSH
85880: LD_INT 0
85882: ST_TO_ADDR
// if not nat then
85883: LD_VAR 0 7
85887: NOT
85888: IFFALSE 85892
// continue ;
85890: GO 85857
// for j in list [ nat ] do
85892: LD_ADDR_VAR 0 5
85896: PUSH
85897: LD_VAR 0 10
85901: PUSH
85902: LD_VAR 0 7
85906: ARRAY
85907: PUSH
85908: FOR_IN
85909: IFFALSE 85950
// if GetBWeapon ( i ) = j [ 1 ] then
85911: LD_VAR 0 4
85915: PPUSH
85916: CALL_OW 269
85920: PUSH
85921: LD_VAR 0 5
85925: PUSH
85926: LD_INT 1
85928: ARRAY
85929: EQUAL
85930: IFFALSE 85948
// begin weapon := j [ 2 ] ;
85932: LD_ADDR_VAR 0 8
85936: PUSH
85937: LD_VAR 0 5
85941: PUSH
85942: LD_INT 2
85944: ARRAY
85945: ST_TO_ADDR
// break ;
85946: GO 85950
// end ;
85948: GO 85908
85950: POP
85951: POP
// if not weapon then
85952: LD_VAR 0 8
85956: NOT
85957: IFFALSE 85961
// continue ;
85959: GO 85857
// for k in factories do
85961: LD_ADDR_VAR 0 6
85965: PUSH
85966: LD_VAR 0 2
85970: PUSH
85971: FOR_IN
85972: IFFALSE 86037
// begin weapons := AvailableWeaponList ( k ) ;
85974: LD_ADDR_VAR 0 9
85978: PUSH
85979: LD_VAR 0 6
85983: PPUSH
85984: CALL_OW 478
85988: ST_TO_ADDR
// if not weapons then
85989: LD_VAR 0 9
85993: NOT
85994: IFFALSE 85998
// continue ;
85996: GO 85971
// if weapon in weapons then
85998: LD_VAR 0 8
86002: PUSH
86003: LD_VAR 0 9
86007: IN
86008: IFFALSE 86035
// begin result := [ i , weapon ] ;
86010: LD_ADDR_VAR 0 3
86014: PUSH
86015: LD_VAR 0 4
86019: PUSH
86020: LD_VAR 0 8
86024: PUSH
86025: EMPTY
86026: LIST
86027: LIST
86028: ST_TO_ADDR
// exit ;
86029: POP
86030: POP
86031: POP
86032: POP
86033: GO 86043
// end ; end ;
86035: GO 85971
86037: POP
86038: POP
// end ;
86039: GO 85857
86041: POP
86042: POP
// end ;
86043: LD_VAR 0 3
86047: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
86048: LD_INT 0
86050: PPUSH
// if not side or side > 8 then
86051: LD_VAR 0 3
86055: NOT
86056: PUSH
86057: LD_VAR 0 3
86061: PUSH
86062: LD_INT 8
86064: GREATER
86065: OR
86066: IFFALSE 86070
// exit ;
86068: GO 86129
// if not range then
86070: LD_VAR 0 4
86074: NOT
86075: IFFALSE 86086
// range := - 12 ;
86077: LD_ADDR_VAR 0 4
86081: PUSH
86082: LD_INT 12
86084: NEG
86085: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
86086: LD_VAR 0 1
86090: PPUSH
86091: LD_VAR 0 2
86095: PPUSH
86096: LD_VAR 0 3
86100: PPUSH
86101: LD_VAR 0 4
86105: PPUSH
86106: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
86110: LD_VAR 0 1
86114: PPUSH
86115: LD_VAR 0 2
86119: PPUSH
86120: LD_VAR 0 3
86124: PPUSH
86125: CALL_OW 331
// end ;
86129: LD_VAR 0 5
86133: RET
// export function Video ( mode ) ; begin
86134: LD_INT 0
86136: PPUSH
// ingame_video = mode ;
86137: LD_ADDR_OWVAR 52
86141: PUSH
86142: LD_VAR 0 1
86146: ST_TO_ADDR
// interface_hidden = mode ;
86147: LD_ADDR_OWVAR 54
86151: PUSH
86152: LD_VAR 0 1
86156: ST_TO_ADDR
// end ;
86157: LD_VAR 0 2
86161: RET
// export function Join ( array , element ) ; begin
86162: LD_INT 0
86164: PPUSH
// result := Replace ( array , array + 1 , element ) ;
86165: LD_ADDR_VAR 0 3
86169: PUSH
86170: LD_VAR 0 1
86174: PPUSH
86175: LD_VAR 0 1
86179: PUSH
86180: LD_INT 1
86182: PLUS
86183: PPUSH
86184: LD_VAR 0 2
86188: PPUSH
86189: CALL_OW 1
86193: ST_TO_ADDR
// end ;
86194: LD_VAR 0 3
86198: RET
// export function JoinUnion ( array , element ) ; begin
86199: LD_INT 0
86201: PPUSH
// result := array union element ;
86202: LD_ADDR_VAR 0 3
86206: PUSH
86207: LD_VAR 0 1
86211: PUSH
86212: LD_VAR 0 2
86216: UNION
86217: ST_TO_ADDR
// end ;
86218: LD_VAR 0 3
86222: RET
// export function GetBehemoths ( side ) ; begin
86223: LD_INT 0
86225: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
86226: LD_ADDR_VAR 0 2
86230: PUSH
86231: LD_INT 22
86233: PUSH
86234: LD_VAR 0 1
86238: PUSH
86239: EMPTY
86240: LIST
86241: LIST
86242: PUSH
86243: LD_INT 31
86245: PUSH
86246: LD_INT 25
86248: PUSH
86249: EMPTY
86250: LIST
86251: LIST
86252: PUSH
86253: EMPTY
86254: LIST
86255: LIST
86256: PPUSH
86257: CALL_OW 69
86261: ST_TO_ADDR
// end ;
86262: LD_VAR 0 2
86266: RET
// export function Shuffle ( array ) ; var i , index ; begin
86267: LD_INT 0
86269: PPUSH
86270: PPUSH
86271: PPUSH
// result := [ ] ;
86272: LD_ADDR_VAR 0 2
86276: PUSH
86277: EMPTY
86278: ST_TO_ADDR
// if not array then
86279: LD_VAR 0 1
86283: NOT
86284: IFFALSE 86288
// exit ;
86286: GO 86387
// Randomize ;
86288: CALL_OW 10
// for i = array downto 1 do
86292: LD_ADDR_VAR 0 3
86296: PUSH
86297: DOUBLE
86298: LD_VAR 0 1
86302: INC
86303: ST_TO_ADDR
86304: LD_INT 1
86306: PUSH
86307: FOR_DOWNTO
86308: IFFALSE 86385
// begin index := rand ( 1 , array ) ;
86310: LD_ADDR_VAR 0 4
86314: PUSH
86315: LD_INT 1
86317: PPUSH
86318: LD_VAR 0 1
86322: PPUSH
86323: CALL_OW 12
86327: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
86328: LD_ADDR_VAR 0 2
86332: PUSH
86333: LD_VAR 0 2
86337: PPUSH
86338: LD_VAR 0 2
86342: PUSH
86343: LD_INT 1
86345: PLUS
86346: PPUSH
86347: LD_VAR 0 1
86351: PUSH
86352: LD_VAR 0 4
86356: ARRAY
86357: PPUSH
86358: CALL_OW 2
86362: ST_TO_ADDR
// array := Delete ( array , index ) ;
86363: LD_ADDR_VAR 0 1
86367: PUSH
86368: LD_VAR 0 1
86372: PPUSH
86373: LD_VAR 0 4
86377: PPUSH
86378: CALL_OW 3
86382: ST_TO_ADDR
// end ;
86383: GO 86307
86385: POP
86386: POP
// end ;
86387: LD_VAR 0 2
86391: RET
// export function GetBaseMaterials ( base ) ; begin
86392: LD_INT 0
86394: PPUSH
// result := [ 0 , 0 , 0 ] ;
86395: LD_ADDR_VAR 0 2
86399: PUSH
86400: LD_INT 0
86402: PUSH
86403: LD_INT 0
86405: PUSH
86406: LD_INT 0
86408: PUSH
86409: EMPTY
86410: LIST
86411: LIST
86412: LIST
86413: ST_TO_ADDR
// if not base then
86414: LD_VAR 0 1
86418: NOT
86419: IFFALSE 86423
// exit ;
86421: GO 86472
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
86423: LD_ADDR_VAR 0 2
86427: PUSH
86428: LD_VAR 0 1
86432: PPUSH
86433: LD_INT 1
86435: PPUSH
86436: CALL_OW 275
86440: PUSH
86441: LD_VAR 0 1
86445: PPUSH
86446: LD_INT 2
86448: PPUSH
86449: CALL_OW 275
86453: PUSH
86454: LD_VAR 0 1
86458: PPUSH
86459: LD_INT 3
86461: PPUSH
86462: CALL_OW 275
86466: PUSH
86467: EMPTY
86468: LIST
86469: LIST
86470: LIST
86471: ST_TO_ADDR
// end ;
86472: LD_VAR 0 2
86476: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
86477: LD_INT 0
86479: PPUSH
86480: PPUSH
// result := array ;
86481: LD_ADDR_VAR 0 3
86485: PUSH
86486: LD_VAR 0 1
86490: ST_TO_ADDR
// if size >= result then
86491: LD_VAR 0 2
86495: PUSH
86496: LD_VAR 0 3
86500: GREATEREQUAL
86501: IFFALSE 86505
// exit ;
86503: GO 86555
// if size then
86505: LD_VAR 0 2
86509: IFFALSE 86555
// for i := array downto size do
86511: LD_ADDR_VAR 0 4
86515: PUSH
86516: DOUBLE
86517: LD_VAR 0 1
86521: INC
86522: ST_TO_ADDR
86523: LD_VAR 0 2
86527: PUSH
86528: FOR_DOWNTO
86529: IFFALSE 86553
// result := Delete ( result , result ) ;
86531: LD_ADDR_VAR 0 3
86535: PUSH
86536: LD_VAR 0 3
86540: PPUSH
86541: LD_VAR 0 3
86545: PPUSH
86546: CALL_OW 3
86550: ST_TO_ADDR
86551: GO 86528
86553: POP
86554: POP
// end ;
86555: LD_VAR 0 3
86559: RET
// export function ComExit ( unit ) ; var tmp ; begin
86560: LD_INT 0
86562: PPUSH
86563: PPUSH
// if not IsInUnit ( unit ) then
86564: LD_VAR 0 1
86568: PPUSH
86569: CALL_OW 310
86573: NOT
86574: IFFALSE 86578
// exit ;
86576: GO 86638
// tmp := IsInUnit ( unit ) ;
86578: LD_ADDR_VAR 0 3
86582: PUSH
86583: LD_VAR 0 1
86587: PPUSH
86588: CALL_OW 310
86592: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
86593: LD_VAR 0 3
86597: PPUSH
86598: CALL_OW 247
86602: PUSH
86603: LD_INT 2
86605: EQUAL
86606: IFFALSE 86619
// ComExitVehicle ( unit ) else
86608: LD_VAR 0 1
86612: PPUSH
86613: CALL_OW 121
86617: GO 86628
// ComExitBuilding ( unit ) ;
86619: LD_VAR 0 1
86623: PPUSH
86624: CALL_OW 122
// result := tmp ;
86628: LD_ADDR_VAR 0 2
86632: PUSH
86633: LD_VAR 0 3
86637: ST_TO_ADDR
// end ;
86638: LD_VAR 0 2
86642: RET
// export function ComExitAll ( units ) ; var i ; begin
86643: LD_INT 0
86645: PPUSH
86646: PPUSH
// if not units then
86647: LD_VAR 0 1
86651: NOT
86652: IFFALSE 86656
// exit ;
86654: GO 86682
// for i in units do
86656: LD_ADDR_VAR 0 3
86660: PUSH
86661: LD_VAR 0 1
86665: PUSH
86666: FOR_IN
86667: IFFALSE 86680
// ComExit ( i ) ;
86669: LD_VAR 0 3
86673: PPUSH
86674: CALL 86560 0 1
86678: GO 86666
86680: POP
86681: POP
// end ;
86682: LD_VAR 0 2
86686: RET
// export function ResetHc ; begin
86687: LD_INT 0
86689: PPUSH
// InitHc ;
86690: CALL_OW 19
// hc_importance := 0 ;
86694: LD_ADDR_OWVAR 32
86698: PUSH
86699: LD_INT 0
86701: ST_TO_ADDR
// end ;
86702: LD_VAR 0 1
86706: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
86707: LD_INT 0
86709: PPUSH
86710: PPUSH
86711: PPUSH
// _x := ( x1 + x2 ) div 2 ;
86712: LD_ADDR_VAR 0 6
86716: PUSH
86717: LD_VAR 0 1
86721: PUSH
86722: LD_VAR 0 3
86726: PLUS
86727: PUSH
86728: LD_INT 2
86730: DIV
86731: ST_TO_ADDR
// if _x < 0 then
86732: LD_VAR 0 6
86736: PUSH
86737: LD_INT 0
86739: LESS
86740: IFFALSE 86757
// _x := _x * - 1 ;
86742: LD_ADDR_VAR 0 6
86746: PUSH
86747: LD_VAR 0 6
86751: PUSH
86752: LD_INT 1
86754: NEG
86755: MUL
86756: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
86757: LD_ADDR_VAR 0 7
86761: PUSH
86762: LD_VAR 0 2
86766: PUSH
86767: LD_VAR 0 4
86771: PLUS
86772: PUSH
86773: LD_INT 2
86775: DIV
86776: ST_TO_ADDR
// if _y < 0 then
86777: LD_VAR 0 7
86781: PUSH
86782: LD_INT 0
86784: LESS
86785: IFFALSE 86802
// _y := _y * - 1 ;
86787: LD_ADDR_VAR 0 7
86791: PUSH
86792: LD_VAR 0 7
86796: PUSH
86797: LD_INT 1
86799: NEG
86800: MUL
86801: ST_TO_ADDR
// result := [ _x , _y ] ;
86802: LD_ADDR_VAR 0 5
86806: PUSH
86807: LD_VAR 0 6
86811: PUSH
86812: LD_VAR 0 7
86816: PUSH
86817: EMPTY
86818: LIST
86819: LIST
86820: ST_TO_ADDR
// end ;
86821: LD_VAR 0 5
86825: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
86826: LD_INT 0
86828: PPUSH
86829: PPUSH
86830: PPUSH
86831: PPUSH
// task := GetTaskList ( unit ) ;
86832: LD_ADDR_VAR 0 7
86836: PUSH
86837: LD_VAR 0 1
86841: PPUSH
86842: CALL_OW 437
86846: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
86847: LD_VAR 0 7
86851: NOT
86852: PUSH
86853: LD_VAR 0 1
86857: PPUSH
86858: LD_VAR 0 2
86862: PPUSH
86863: CALL_OW 308
86867: NOT
86868: AND
86869: IFFALSE 86873
// exit ;
86871: GO 86991
// if IsInArea ( unit , area ) then
86873: LD_VAR 0 1
86877: PPUSH
86878: LD_VAR 0 2
86882: PPUSH
86883: CALL_OW 308
86887: IFFALSE 86905
// begin ComMoveToArea ( unit , goAway ) ;
86889: LD_VAR 0 1
86893: PPUSH
86894: LD_VAR 0 3
86898: PPUSH
86899: CALL_OW 113
// exit ;
86903: GO 86991
// end ; if task [ 1 ] [ 1 ] <> M then
86905: LD_VAR 0 7
86909: PUSH
86910: LD_INT 1
86912: ARRAY
86913: PUSH
86914: LD_INT 1
86916: ARRAY
86917: PUSH
86918: LD_STRING M
86920: NONEQUAL
86921: IFFALSE 86925
// exit ;
86923: GO 86991
// x := task [ 1 ] [ 2 ] ;
86925: LD_ADDR_VAR 0 5
86929: PUSH
86930: LD_VAR 0 7
86934: PUSH
86935: LD_INT 1
86937: ARRAY
86938: PUSH
86939: LD_INT 2
86941: ARRAY
86942: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
86943: LD_ADDR_VAR 0 6
86947: PUSH
86948: LD_VAR 0 7
86952: PUSH
86953: LD_INT 1
86955: ARRAY
86956: PUSH
86957: LD_INT 3
86959: ARRAY
86960: ST_TO_ADDR
// if InArea ( x , y , area ) then
86961: LD_VAR 0 5
86965: PPUSH
86966: LD_VAR 0 6
86970: PPUSH
86971: LD_VAR 0 2
86975: PPUSH
86976: CALL_OW 309
86980: IFFALSE 86991
// ComStop ( unit ) ;
86982: LD_VAR 0 1
86986: PPUSH
86987: CALL_OW 141
// end ;
86991: LD_VAR 0 4
86995: RET
// export function Abs ( value ) ; begin
86996: LD_INT 0
86998: PPUSH
// result := value ;
86999: LD_ADDR_VAR 0 2
87003: PUSH
87004: LD_VAR 0 1
87008: ST_TO_ADDR
// if value < 0 then
87009: LD_VAR 0 1
87013: PUSH
87014: LD_INT 0
87016: LESS
87017: IFFALSE 87034
// result := value * - 1 ;
87019: LD_ADDR_VAR 0 2
87023: PUSH
87024: LD_VAR 0 1
87028: PUSH
87029: LD_INT 1
87031: NEG
87032: MUL
87033: ST_TO_ADDR
// end ;
87034: LD_VAR 0 2
87038: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
87039: LD_INT 0
87041: PPUSH
87042: PPUSH
87043: PPUSH
87044: PPUSH
87045: PPUSH
87046: PPUSH
87047: PPUSH
87048: PPUSH
// if not unit or not building then
87049: LD_VAR 0 1
87053: NOT
87054: PUSH
87055: LD_VAR 0 2
87059: NOT
87060: OR
87061: IFFALSE 87065
// exit ;
87063: GO 87291
// x := GetX ( building ) ;
87065: LD_ADDR_VAR 0 4
87069: PUSH
87070: LD_VAR 0 2
87074: PPUSH
87075: CALL_OW 250
87079: ST_TO_ADDR
// y := GetY ( building ) ;
87080: LD_ADDR_VAR 0 6
87084: PUSH
87085: LD_VAR 0 2
87089: PPUSH
87090: CALL_OW 251
87094: ST_TO_ADDR
// d := GetDir ( building ) ;
87095: LD_ADDR_VAR 0 8
87099: PUSH
87100: LD_VAR 0 2
87104: PPUSH
87105: CALL_OW 254
87109: ST_TO_ADDR
// r := 4 ;
87110: LD_ADDR_VAR 0 9
87114: PUSH
87115: LD_INT 4
87117: ST_TO_ADDR
// for i := 1 to 5 do
87118: LD_ADDR_VAR 0 10
87122: PUSH
87123: DOUBLE
87124: LD_INT 1
87126: DEC
87127: ST_TO_ADDR
87128: LD_INT 5
87130: PUSH
87131: FOR_TO
87132: IFFALSE 87289
// begin _x := ShiftX ( x , d , r + i ) ;
87134: LD_ADDR_VAR 0 5
87138: PUSH
87139: LD_VAR 0 4
87143: PPUSH
87144: LD_VAR 0 8
87148: PPUSH
87149: LD_VAR 0 9
87153: PUSH
87154: LD_VAR 0 10
87158: PLUS
87159: PPUSH
87160: CALL_OW 272
87164: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
87165: LD_ADDR_VAR 0 7
87169: PUSH
87170: LD_VAR 0 6
87174: PPUSH
87175: LD_VAR 0 8
87179: PPUSH
87180: LD_VAR 0 9
87184: PUSH
87185: LD_VAR 0 10
87189: PLUS
87190: PPUSH
87191: CALL_OW 273
87195: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
87196: LD_VAR 0 5
87200: PPUSH
87201: LD_VAR 0 7
87205: PPUSH
87206: CALL_OW 488
87210: PUSH
87211: LD_VAR 0 5
87215: PPUSH
87216: LD_VAR 0 7
87220: PPUSH
87221: CALL_OW 428
87225: PPUSH
87226: CALL_OW 247
87230: PUSH
87231: LD_INT 3
87233: PUSH
87234: LD_INT 2
87236: PUSH
87237: EMPTY
87238: LIST
87239: LIST
87240: IN
87241: NOT
87242: AND
87243: IFFALSE 87287
// begin ComMoveXY ( unit , _x , _y ) ;
87245: LD_VAR 0 1
87249: PPUSH
87250: LD_VAR 0 5
87254: PPUSH
87255: LD_VAR 0 7
87259: PPUSH
87260: CALL_OW 111
// result := [ _x , _y ] ;
87264: LD_ADDR_VAR 0 3
87268: PUSH
87269: LD_VAR 0 5
87273: PUSH
87274: LD_VAR 0 7
87278: PUSH
87279: EMPTY
87280: LIST
87281: LIST
87282: ST_TO_ADDR
// exit ;
87283: POP
87284: POP
87285: GO 87291
// end ; end ;
87287: GO 87131
87289: POP
87290: POP
// end ;
87291: LD_VAR 0 3
87295: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
87296: LD_INT 0
87298: PPUSH
87299: PPUSH
87300: PPUSH
// result := 0 ;
87301: LD_ADDR_VAR 0 3
87305: PUSH
87306: LD_INT 0
87308: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
87309: LD_VAR 0 1
87313: PUSH
87314: LD_INT 0
87316: LESS
87317: PUSH
87318: LD_VAR 0 1
87322: PUSH
87323: LD_INT 8
87325: GREATER
87326: OR
87327: PUSH
87328: LD_VAR 0 2
87332: PUSH
87333: LD_INT 0
87335: LESS
87336: OR
87337: PUSH
87338: LD_VAR 0 2
87342: PUSH
87343: LD_INT 8
87345: GREATER
87346: OR
87347: IFFALSE 87351
// exit ;
87349: GO 87426
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
87351: LD_ADDR_VAR 0 4
87355: PUSH
87356: LD_INT 22
87358: PUSH
87359: LD_VAR 0 2
87363: PUSH
87364: EMPTY
87365: LIST
87366: LIST
87367: PPUSH
87368: CALL_OW 69
87372: PUSH
87373: FOR_IN
87374: IFFALSE 87424
// begin un := UnitShoot ( i ) ;
87376: LD_ADDR_VAR 0 5
87380: PUSH
87381: LD_VAR 0 4
87385: PPUSH
87386: CALL_OW 504
87390: ST_TO_ADDR
// if GetSide ( un ) = side1 then
87391: LD_VAR 0 5
87395: PPUSH
87396: CALL_OW 255
87400: PUSH
87401: LD_VAR 0 1
87405: EQUAL
87406: IFFALSE 87422
// begin result := un ;
87408: LD_ADDR_VAR 0 3
87412: PUSH
87413: LD_VAR 0 5
87417: ST_TO_ADDR
// exit ;
87418: POP
87419: POP
87420: GO 87426
// end ; end ;
87422: GO 87373
87424: POP
87425: POP
// end ;
87426: LD_VAR 0 3
87430: RET
// export function GetCargoBay ( units ) ; begin
87431: LD_INT 0
87433: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
87434: LD_ADDR_VAR 0 2
87438: PUSH
87439: LD_VAR 0 1
87443: PPUSH
87444: LD_INT 2
87446: PUSH
87447: LD_INT 34
87449: PUSH
87450: LD_INT 12
87452: PUSH
87453: EMPTY
87454: LIST
87455: LIST
87456: PUSH
87457: LD_INT 34
87459: PUSH
87460: LD_INT 51
87462: PUSH
87463: EMPTY
87464: LIST
87465: LIST
87466: PUSH
87467: LD_INT 34
87469: PUSH
87470: LD_INT 32
87472: PUSH
87473: EMPTY
87474: LIST
87475: LIST
87476: PUSH
87477: LD_INT 34
87479: PUSH
87480: LD_INT 89
87482: PUSH
87483: EMPTY
87484: LIST
87485: LIST
87486: PUSH
87487: EMPTY
87488: LIST
87489: LIST
87490: LIST
87491: LIST
87492: LIST
87493: PPUSH
87494: CALL_OW 72
87498: ST_TO_ADDR
// end ;
87499: LD_VAR 0 2
87503: RET
// export function Negate ( value ) ; begin
87504: LD_INT 0
87506: PPUSH
// result := not value ;
87507: LD_ADDR_VAR 0 2
87511: PUSH
87512: LD_VAR 0 1
87516: NOT
87517: ST_TO_ADDR
// end ;
87518: LD_VAR 0 2
87522: RET
// export function Inc ( value ) ; begin
87523: LD_INT 0
87525: PPUSH
// result := value + 1 ;
87526: LD_ADDR_VAR 0 2
87530: PUSH
87531: LD_VAR 0 1
87535: PUSH
87536: LD_INT 1
87538: PLUS
87539: ST_TO_ADDR
// end ;
87540: LD_VAR 0 2
87544: RET
// export function Dec ( value ) ; begin
87545: LD_INT 0
87547: PPUSH
// result := value - 1 ;
87548: LD_ADDR_VAR 0 2
87552: PUSH
87553: LD_VAR 0 1
87557: PUSH
87558: LD_INT 1
87560: MINUS
87561: ST_TO_ADDR
// end ;
87562: LD_VAR 0 2
87566: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
87567: LD_INT 0
87569: PPUSH
87570: PPUSH
87571: PPUSH
87572: PPUSH
87573: PPUSH
87574: PPUSH
87575: PPUSH
87576: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
87577: LD_VAR 0 1
87581: PPUSH
87582: LD_VAR 0 2
87586: PPUSH
87587: CALL_OW 488
87591: NOT
87592: PUSH
87593: LD_VAR 0 3
87597: PPUSH
87598: LD_VAR 0 4
87602: PPUSH
87603: CALL_OW 488
87607: NOT
87608: OR
87609: IFFALSE 87622
// begin result := - 1 ;
87611: LD_ADDR_VAR 0 5
87615: PUSH
87616: LD_INT 1
87618: NEG
87619: ST_TO_ADDR
// exit ;
87620: GO 87857
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
87622: LD_ADDR_VAR 0 12
87626: PUSH
87627: LD_VAR 0 1
87631: PPUSH
87632: LD_VAR 0 2
87636: PPUSH
87637: LD_VAR 0 3
87641: PPUSH
87642: LD_VAR 0 4
87646: PPUSH
87647: CALL 86707 0 4
87651: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
87652: LD_ADDR_VAR 0 11
87656: PUSH
87657: LD_VAR 0 1
87661: PPUSH
87662: LD_VAR 0 2
87666: PPUSH
87667: LD_VAR 0 12
87671: PUSH
87672: LD_INT 1
87674: ARRAY
87675: PPUSH
87676: LD_VAR 0 12
87680: PUSH
87681: LD_INT 2
87683: ARRAY
87684: PPUSH
87685: CALL_OW 298
87689: ST_TO_ADDR
// distance := 9999 ;
87690: LD_ADDR_VAR 0 10
87694: PUSH
87695: LD_INT 9999
87697: ST_TO_ADDR
// for i := 0 to 5 do
87698: LD_ADDR_VAR 0 6
87702: PUSH
87703: DOUBLE
87704: LD_INT 0
87706: DEC
87707: ST_TO_ADDR
87708: LD_INT 5
87710: PUSH
87711: FOR_TO
87712: IFFALSE 87855
// begin _x := ShiftX ( x1 , i , centerDist ) ;
87714: LD_ADDR_VAR 0 7
87718: PUSH
87719: LD_VAR 0 1
87723: PPUSH
87724: LD_VAR 0 6
87728: PPUSH
87729: LD_VAR 0 11
87733: PPUSH
87734: CALL_OW 272
87738: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
87739: LD_ADDR_VAR 0 8
87743: PUSH
87744: LD_VAR 0 2
87748: PPUSH
87749: LD_VAR 0 6
87753: PPUSH
87754: LD_VAR 0 11
87758: PPUSH
87759: CALL_OW 273
87763: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
87764: LD_VAR 0 7
87768: PPUSH
87769: LD_VAR 0 8
87773: PPUSH
87774: CALL_OW 488
87778: NOT
87779: IFFALSE 87783
// continue ;
87781: GO 87711
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
87783: LD_ADDR_VAR 0 9
87787: PUSH
87788: LD_VAR 0 12
87792: PUSH
87793: LD_INT 1
87795: ARRAY
87796: PPUSH
87797: LD_VAR 0 12
87801: PUSH
87802: LD_INT 2
87804: ARRAY
87805: PPUSH
87806: LD_VAR 0 7
87810: PPUSH
87811: LD_VAR 0 8
87815: PPUSH
87816: CALL_OW 298
87820: ST_TO_ADDR
// if tmp < distance then
87821: LD_VAR 0 9
87825: PUSH
87826: LD_VAR 0 10
87830: LESS
87831: IFFALSE 87853
// begin result := i ;
87833: LD_ADDR_VAR 0 5
87837: PUSH
87838: LD_VAR 0 6
87842: ST_TO_ADDR
// distance := tmp ;
87843: LD_ADDR_VAR 0 10
87847: PUSH
87848: LD_VAR 0 9
87852: ST_TO_ADDR
// end ; end ;
87853: GO 87711
87855: POP
87856: POP
// end ;
87857: LD_VAR 0 5
87861: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
87862: LD_INT 0
87864: PPUSH
87865: PPUSH
// if not driver or not IsInUnit ( driver ) then
87866: LD_VAR 0 1
87870: NOT
87871: PUSH
87872: LD_VAR 0 1
87876: PPUSH
87877: CALL_OW 310
87881: NOT
87882: OR
87883: IFFALSE 87887
// exit ;
87885: GO 87977
// vehicle := IsInUnit ( driver ) ;
87887: LD_ADDR_VAR 0 3
87891: PUSH
87892: LD_VAR 0 1
87896: PPUSH
87897: CALL_OW 310
87901: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
87902: LD_VAR 0 1
87906: PPUSH
87907: LD_STRING \
87909: PUSH
87910: LD_INT 0
87912: PUSH
87913: LD_INT 0
87915: PUSH
87916: LD_INT 0
87918: PUSH
87919: LD_INT 0
87921: PUSH
87922: LD_INT 0
87924: PUSH
87925: LD_INT 0
87927: PUSH
87928: EMPTY
87929: LIST
87930: LIST
87931: LIST
87932: LIST
87933: LIST
87934: LIST
87935: LIST
87936: PUSH
87937: LD_STRING E
87939: PUSH
87940: LD_INT 0
87942: PUSH
87943: LD_INT 0
87945: PUSH
87946: LD_VAR 0 3
87950: PUSH
87951: LD_INT 0
87953: PUSH
87954: LD_INT 0
87956: PUSH
87957: LD_INT 0
87959: PUSH
87960: EMPTY
87961: LIST
87962: LIST
87963: LIST
87964: LIST
87965: LIST
87966: LIST
87967: LIST
87968: PUSH
87969: EMPTY
87970: LIST
87971: LIST
87972: PPUSH
87973: CALL_OW 446
// end ;
87977: LD_VAR 0 2
87981: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
87982: LD_INT 0
87984: PPUSH
87985: PPUSH
// if not driver or not IsInUnit ( driver ) then
87986: LD_VAR 0 1
87990: NOT
87991: PUSH
87992: LD_VAR 0 1
87996: PPUSH
87997: CALL_OW 310
88001: NOT
88002: OR
88003: IFFALSE 88007
// exit ;
88005: GO 88097
// vehicle := IsInUnit ( driver ) ;
88007: LD_ADDR_VAR 0 3
88011: PUSH
88012: LD_VAR 0 1
88016: PPUSH
88017: CALL_OW 310
88021: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
88022: LD_VAR 0 1
88026: PPUSH
88027: LD_STRING \
88029: PUSH
88030: LD_INT 0
88032: PUSH
88033: LD_INT 0
88035: PUSH
88036: LD_INT 0
88038: PUSH
88039: LD_INT 0
88041: PUSH
88042: LD_INT 0
88044: PUSH
88045: LD_INT 0
88047: PUSH
88048: EMPTY
88049: LIST
88050: LIST
88051: LIST
88052: LIST
88053: LIST
88054: LIST
88055: LIST
88056: PUSH
88057: LD_STRING E
88059: PUSH
88060: LD_INT 0
88062: PUSH
88063: LD_INT 0
88065: PUSH
88066: LD_VAR 0 3
88070: PUSH
88071: LD_INT 0
88073: PUSH
88074: LD_INT 0
88076: PUSH
88077: LD_INT 0
88079: PUSH
88080: EMPTY
88081: LIST
88082: LIST
88083: LIST
88084: LIST
88085: LIST
88086: LIST
88087: LIST
88088: PUSH
88089: EMPTY
88090: LIST
88091: LIST
88092: PPUSH
88093: CALL_OW 447
// end ;
88097: LD_VAR 0 2
88101: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
88102: LD_INT 0
88104: PPUSH
88105: PPUSH
88106: PPUSH
// tmp := [ ] ;
88107: LD_ADDR_VAR 0 5
88111: PUSH
88112: EMPTY
88113: ST_TO_ADDR
// for i in units do
88114: LD_ADDR_VAR 0 4
88118: PUSH
88119: LD_VAR 0 1
88123: PUSH
88124: FOR_IN
88125: IFFALSE 88163
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
88127: LD_ADDR_VAR 0 5
88131: PUSH
88132: LD_VAR 0 5
88136: PPUSH
88137: LD_VAR 0 5
88141: PUSH
88142: LD_INT 1
88144: PLUS
88145: PPUSH
88146: LD_VAR 0 4
88150: PPUSH
88151: CALL_OW 256
88155: PPUSH
88156: CALL_OW 2
88160: ST_TO_ADDR
88161: GO 88124
88163: POP
88164: POP
// if not tmp then
88165: LD_VAR 0 5
88169: NOT
88170: IFFALSE 88174
// exit ;
88172: GO 88222
// if asc then
88174: LD_VAR 0 2
88178: IFFALSE 88202
// result := SortListByListAsc ( units , tmp ) else
88180: LD_ADDR_VAR 0 3
88184: PUSH
88185: LD_VAR 0 1
88189: PPUSH
88190: LD_VAR 0 5
88194: PPUSH
88195: CALL_OW 76
88199: ST_TO_ADDR
88200: GO 88222
// result := SortListByListDesc ( units , tmp ) ;
88202: LD_ADDR_VAR 0 3
88206: PUSH
88207: LD_VAR 0 1
88211: PPUSH
88212: LD_VAR 0 5
88216: PPUSH
88217: CALL_OW 77
88221: ST_TO_ADDR
// end ;
88222: LD_VAR 0 3
88226: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
88227: LD_INT 0
88229: PPUSH
88230: PPUSH
// task := GetTaskList ( mech ) ;
88231: LD_ADDR_VAR 0 4
88235: PUSH
88236: LD_VAR 0 1
88240: PPUSH
88241: CALL_OW 437
88245: ST_TO_ADDR
// if not task then
88246: LD_VAR 0 4
88250: NOT
88251: IFFALSE 88255
// exit ;
88253: GO 88297
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
88255: LD_ADDR_VAR 0 3
88259: PUSH
88260: LD_VAR 0 4
88264: PUSH
88265: LD_INT 1
88267: ARRAY
88268: PUSH
88269: LD_INT 1
88271: ARRAY
88272: PUSH
88273: LD_STRING r
88275: EQUAL
88276: PUSH
88277: LD_VAR 0 4
88281: PUSH
88282: LD_INT 1
88284: ARRAY
88285: PUSH
88286: LD_INT 4
88288: ARRAY
88289: PUSH
88290: LD_VAR 0 2
88294: EQUAL
88295: AND
88296: ST_TO_ADDR
// end ;
88297: LD_VAR 0 3
88301: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
88302: LD_INT 0
88304: PPUSH
// SetDir ( unit , d ) ;
88305: LD_VAR 0 1
88309: PPUSH
88310: LD_VAR 0 4
88314: PPUSH
88315: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
88319: LD_VAR 0 1
88323: PPUSH
88324: LD_VAR 0 2
88328: PPUSH
88329: LD_VAR 0 3
88333: PPUSH
88334: LD_VAR 0 5
88338: PPUSH
88339: CALL_OW 48
// end ;
88343: LD_VAR 0 6
88347: RET
// export function ToNaturalNumber ( number ) ; begin
88348: LD_INT 0
88350: PPUSH
// result := number div 1 ;
88351: LD_ADDR_VAR 0 2
88355: PUSH
88356: LD_VAR 0 1
88360: PUSH
88361: LD_INT 1
88363: DIV
88364: ST_TO_ADDR
// if number < 0 then
88365: LD_VAR 0 1
88369: PUSH
88370: LD_INT 0
88372: LESS
88373: IFFALSE 88383
// result := 0 ;
88375: LD_ADDR_VAR 0 2
88379: PUSH
88380: LD_INT 0
88382: ST_TO_ADDR
// end ;
88383: LD_VAR 0 2
88387: RET
// export function SortByClass ( units , class ) ; var un ; begin
88388: LD_INT 0
88390: PPUSH
88391: PPUSH
// if not units or not class then
88392: LD_VAR 0 1
88396: NOT
88397: PUSH
88398: LD_VAR 0 2
88402: NOT
88403: OR
88404: IFFALSE 88408
// exit ;
88406: GO 88503
// result := [ ] ;
88408: LD_ADDR_VAR 0 3
88412: PUSH
88413: EMPTY
88414: ST_TO_ADDR
// for un in units do
88415: LD_ADDR_VAR 0 4
88419: PUSH
88420: LD_VAR 0 1
88424: PUSH
88425: FOR_IN
88426: IFFALSE 88501
// if GetClass ( un ) = class then
88428: LD_VAR 0 4
88432: PPUSH
88433: CALL_OW 257
88437: PUSH
88438: LD_VAR 0 2
88442: EQUAL
88443: IFFALSE 88470
// result := Insert ( result , 1 , un ) else
88445: LD_ADDR_VAR 0 3
88449: PUSH
88450: LD_VAR 0 3
88454: PPUSH
88455: LD_INT 1
88457: PPUSH
88458: LD_VAR 0 4
88462: PPUSH
88463: CALL_OW 2
88467: ST_TO_ADDR
88468: GO 88499
// result := Replace ( result , result + 1 , un ) ;
88470: LD_ADDR_VAR 0 3
88474: PUSH
88475: LD_VAR 0 3
88479: PPUSH
88480: LD_VAR 0 3
88484: PUSH
88485: LD_INT 1
88487: PLUS
88488: PPUSH
88489: LD_VAR 0 4
88493: PPUSH
88494: CALL_OW 1
88498: ST_TO_ADDR
88499: GO 88425
88501: POP
88502: POP
// end ;
88503: LD_VAR 0 3
88507: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
88508: LD_INT 0
88510: PPUSH
88511: PPUSH
88512: PPUSH
88513: PPUSH
88514: PPUSH
88515: PPUSH
88516: PPUSH
// result := [ ] ;
88517: LD_ADDR_VAR 0 4
88521: PUSH
88522: EMPTY
88523: ST_TO_ADDR
// if x - r < 0 then
88524: LD_VAR 0 1
88528: PUSH
88529: LD_VAR 0 3
88533: MINUS
88534: PUSH
88535: LD_INT 0
88537: LESS
88538: IFFALSE 88550
// min_x := 0 else
88540: LD_ADDR_VAR 0 8
88544: PUSH
88545: LD_INT 0
88547: ST_TO_ADDR
88548: GO 88566
// min_x := x - r ;
88550: LD_ADDR_VAR 0 8
88554: PUSH
88555: LD_VAR 0 1
88559: PUSH
88560: LD_VAR 0 3
88564: MINUS
88565: ST_TO_ADDR
// if y - r < 0 then
88566: LD_VAR 0 2
88570: PUSH
88571: LD_VAR 0 3
88575: MINUS
88576: PUSH
88577: LD_INT 0
88579: LESS
88580: IFFALSE 88592
// min_y := 0 else
88582: LD_ADDR_VAR 0 7
88586: PUSH
88587: LD_INT 0
88589: ST_TO_ADDR
88590: GO 88608
// min_y := y - r ;
88592: LD_ADDR_VAR 0 7
88596: PUSH
88597: LD_VAR 0 2
88601: PUSH
88602: LD_VAR 0 3
88606: MINUS
88607: ST_TO_ADDR
// max_x := x + r ;
88608: LD_ADDR_VAR 0 9
88612: PUSH
88613: LD_VAR 0 1
88617: PUSH
88618: LD_VAR 0 3
88622: PLUS
88623: ST_TO_ADDR
// max_y := y + r ;
88624: LD_ADDR_VAR 0 10
88628: PUSH
88629: LD_VAR 0 2
88633: PUSH
88634: LD_VAR 0 3
88638: PLUS
88639: ST_TO_ADDR
// for _x = min_x to max_x do
88640: LD_ADDR_VAR 0 5
88644: PUSH
88645: DOUBLE
88646: LD_VAR 0 8
88650: DEC
88651: ST_TO_ADDR
88652: LD_VAR 0 9
88656: PUSH
88657: FOR_TO
88658: IFFALSE 88759
// for _y = min_y to max_y do
88660: LD_ADDR_VAR 0 6
88664: PUSH
88665: DOUBLE
88666: LD_VAR 0 7
88670: DEC
88671: ST_TO_ADDR
88672: LD_VAR 0 10
88676: PUSH
88677: FOR_TO
88678: IFFALSE 88755
// begin if not ValidHex ( _x , _y ) then
88680: LD_VAR 0 5
88684: PPUSH
88685: LD_VAR 0 6
88689: PPUSH
88690: CALL_OW 488
88694: NOT
88695: IFFALSE 88699
// continue ;
88697: GO 88677
// if GetResourceTypeXY ( _x , _y ) then
88699: LD_VAR 0 5
88703: PPUSH
88704: LD_VAR 0 6
88708: PPUSH
88709: CALL_OW 283
88713: IFFALSE 88753
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
88715: LD_ADDR_VAR 0 4
88719: PUSH
88720: LD_VAR 0 4
88724: PPUSH
88725: LD_VAR 0 4
88729: PUSH
88730: LD_INT 1
88732: PLUS
88733: PPUSH
88734: LD_VAR 0 5
88738: PUSH
88739: LD_VAR 0 6
88743: PUSH
88744: EMPTY
88745: LIST
88746: LIST
88747: PPUSH
88748: CALL_OW 1
88752: ST_TO_ADDR
// end ;
88753: GO 88677
88755: POP
88756: POP
88757: GO 88657
88759: POP
88760: POP
// end ;
88761: LD_VAR 0 4
88765: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
88766: LD_INT 0
88768: PPUSH
88769: PPUSH
88770: PPUSH
88771: PPUSH
88772: PPUSH
88773: PPUSH
88774: PPUSH
88775: PPUSH
// if not units then
88776: LD_VAR 0 1
88780: NOT
88781: IFFALSE 88785
// exit ;
88783: GO 89309
// result := UnitFilter ( units , [ f_ok ] ) ;
88785: LD_ADDR_VAR 0 3
88789: PUSH
88790: LD_VAR 0 1
88794: PPUSH
88795: LD_INT 50
88797: PUSH
88798: EMPTY
88799: LIST
88800: PPUSH
88801: CALL_OW 72
88805: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
88806: LD_ADDR_VAR 0 8
88810: PUSH
88811: LD_VAR 0 1
88815: PUSH
88816: LD_INT 1
88818: ARRAY
88819: PPUSH
88820: CALL_OW 255
88824: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
88825: LD_ADDR_VAR 0 10
88829: PUSH
88830: LD_INT 29
88832: PUSH
88833: LD_INT 91
88835: PUSH
88836: LD_INT 49
88838: PUSH
88839: EMPTY
88840: LIST
88841: LIST
88842: LIST
88843: ST_TO_ADDR
// if not result then
88844: LD_VAR 0 3
88848: NOT
88849: IFFALSE 88853
// exit ;
88851: GO 89309
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
88853: LD_ADDR_VAR 0 5
88857: PUSH
88858: LD_INT 81
88860: PUSH
88861: LD_VAR 0 8
88865: PUSH
88866: EMPTY
88867: LIST
88868: LIST
88869: PPUSH
88870: CALL_OW 69
88874: ST_TO_ADDR
// for i in result do
88875: LD_ADDR_VAR 0 4
88879: PUSH
88880: LD_VAR 0 3
88884: PUSH
88885: FOR_IN
88886: IFFALSE 89307
// begin tag := GetTag ( i ) + 1 ;
88888: LD_ADDR_VAR 0 9
88892: PUSH
88893: LD_VAR 0 4
88897: PPUSH
88898: CALL_OW 110
88902: PUSH
88903: LD_INT 1
88905: PLUS
88906: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
88907: LD_ADDR_VAR 0 7
88911: PUSH
88912: LD_VAR 0 4
88916: PPUSH
88917: CALL_OW 250
88921: PPUSH
88922: LD_VAR 0 4
88926: PPUSH
88927: CALL_OW 251
88931: PPUSH
88932: LD_INT 6
88934: PPUSH
88935: CALL 88508 0 3
88939: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
88940: LD_VAR 0 4
88944: PPUSH
88945: CALL_OW 247
88949: PUSH
88950: LD_INT 2
88952: EQUAL
88953: PUSH
88954: LD_VAR 0 7
88958: AND
88959: PUSH
88960: LD_VAR 0 4
88964: PPUSH
88965: CALL_OW 264
88969: PUSH
88970: LD_VAR 0 10
88974: IN
88975: NOT
88976: AND
88977: IFFALSE 89016
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
88979: LD_VAR 0 4
88983: PPUSH
88984: LD_VAR 0 7
88988: PUSH
88989: LD_INT 1
88991: ARRAY
88992: PUSH
88993: LD_INT 1
88995: ARRAY
88996: PPUSH
88997: LD_VAR 0 7
89001: PUSH
89002: LD_INT 1
89004: ARRAY
89005: PUSH
89006: LD_INT 2
89008: ARRAY
89009: PPUSH
89010: CALL_OW 116
89014: GO 89305
// if path > tag then
89016: LD_VAR 0 2
89020: PUSH
89021: LD_VAR 0 9
89025: GREATER
89026: IFFALSE 89234
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
89028: LD_ADDR_VAR 0 6
89032: PUSH
89033: LD_VAR 0 5
89037: PPUSH
89038: LD_INT 91
89040: PUSH
89041: LD_VAR 0 4
89045: PUSH
89046: LD_INT 8
89048: PUSH
89049: EMPTY
89050: LIST
89051: LIST
89052: LIST
89053: PPUSH
89054: CALL_OW 72
89058: ST_TO_ADDR
// if nearEnemy then
89059: LD_VAR 0 6
89063: IFFALSE 89132
// begin if GetWeapon ( i ) = ru_time_lapser then
89065: LD_VAR 0 4
89069: PPUSH
89070: CALL_OW 264
89074: PUSH
89075: LD_INT 49
89077: EQUAL
89078: IFFALSE 89106
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
89080: LD_VAR 0 4
89084: PPUSH
89085: LD_VAR 0 6
89089: PPUSH
89090: LD_VAR 0 4
89094: PPUSH
89095: CALL_OW 74
89099: PPUSH
89100: CALL_OW 112
89104: GO 89130
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
89106: LD_VAR 0 4
89110: PPUSH
89111: LD_VAR 0 6
89115: PPUSH
89116: LD_VAR 0 4
89120: PPUSH
89121: CALL_OW 74
89125: PPUSH
89126: CALL_OW 115
// end else
89130: GO 89232
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
89132: LD_VAR 0 4
89136: PPUSH
89137: LD_VAR 0 2
89141: PUSH
89142: LD_VAR 0 9
89146: ARRAY
89147: PUSH
89148: LD_INT 1
89150: ARRAY
89151: PPUSH
89152: LD_VAR 0 2
89156: PUSH
89157: LD_VAR 0 9
89161: ARRAY
89162: PUSH
89163: LD_INT 2
89165: ARRAY
89166: PPUSH
89167: CALL_OW 297
89171: PUSH
89172: LD_INT 6
89174: GREATER
89175: IFFALSE 89218
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
89177: LD_VAR 0 4
89181: PPUSH
89182: LD_VAR 0 2
89186: PUSH
89187: LD_VAR 0 9
89191: ARRAY
89192: PUSH
89193: LD_INT 1
89195: ARRAY
89196: PPUSH
89197: LD_VAR 0 2
89201: PUSH
89202: LD_VAR 0 9
89206: ARRAY
89207: PUSH
89208: LD_INT 2
89210: ARRAY
89211: PPUSH
89212: CALL_OW 114
89216: GO 89232
// SetTag ( i , tag ) ;
89218: LD_VAR 0 4
89222: PPUSH
89223: LD_VAR 0 9
89227: PPUSH
89228: CALL_OW 109
// end else
89232: GO 89305
// if enemy then
89234: LD_VAR 0 5
89238: IFFALSE 89305
// begin if GetWeapon ( i ) = ru_time_lapser then
89240: LD_VAR 0 4
89244: PPUSH
89245: CALL_OW 264
89249: PUSH
89250: LD_INT 49
89252: EQUAL
89253: IFFALSE 89281
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
89255: LD_VAR 0 4
89259: PPUSH
89260: LD_VAR 0 5
89264: PPUSH
89265: LD_VAR 0 4
89269: PPUSH
89270: CALL_OW 74
89274: PPUSH
89275: CALL_OW 112
89279: GO 89305
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
89281: LD_VAR 0 4
89285: PPUSH
89286: LD_VAR 0 5
89290: PPUSH
89291: LD_VAR 0 4
89295: PPUSH
89296: CALL_OW 74
89300: PPUSH
89301: CALL_OW 115
// end ; end ;
89305: GO 88885
89307: POP
89308: POP
// end ;
89309: LD_VAR 0 3
89313: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
89314: LD_INT 0
89316: PPUSH
89317: PPUSH
89318: PPUSH
// if not unit or IsInUnit ( unit ) then
89319: LD_VAR 0 1
89323: NOT
89324: PUSH
89325: LD_VAR 0 1
89329: PPUSH
89330: CALL_OW 310
89334: OR
89335: IFFALSE 89339
// exit ;
89337: GO 89430
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
89339: LD_ADDR_VAR 0 4
89343: PUSH
89344: LD_VAR 0 1
89348: PPUSH
89349: CALL_OW 250
89353: PPUSH
89354: LD_VAR 0 2
89358: PPUSH
89359: LD_INT 1
89361: PPUSH
89362: CALL_OW 272
89366: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
89367: LD_ADDR_VAR 0 5
89371: PUSH
89372: LD_VAR 0 1
89376: PPUSH
89377: CALL_OW 251
89381: PPUSH
89382: LD_VAR 0 2
89386: PPUSH
89387: LD_INT 1
89389: PPUSH
89390: CALL_OW 273
89394: ST_TO_ADDR
// if ValidHex ( x , y ) then
89395: LD_VAR 0 4
89399: PPUSH
89400: LD_VAR 0 5
89404: PPUSH
89405: CALL_OW 488
89409: IFFALSE 89430
// ComTurnXY ( unit , x , y ) ;
89411: LD_VAR 0 1
89415: PPUSH
89416: LD_VAR 0 4
89420: PPUSH
89421: LD_VAR 0 5
89425: PPUSH
89426: CALL_OW 118
// end ;
89430: LD_VAR 0 3
89434: RET
// export function SeeUnits ( side , units ) ; var i ; begin
89435: LD_INT 0
89437: PPUSH
89438: PPUSH
// result := false ;
89439: LD_ADDR_VAR 0 3
89443: PUSH
89444: LD_INT 0
89446: ST_TO_ADDR
// if not units then
89447: LD_VAR 0 2
89451: NOT
89452: IFFALSE 89456
// exit ;
89454: GO 89501
// for i in units do
89456: LD_ADDR_VAR 0 4
89460: PUSH
89461: LD_VAR 0 2
89465: PUSH
89466: FOR_IN
89467: IFFALSE 89499
// if See ( side , i ) then
89469: LD_VAR 0 1
89473: PPUSH
89474: LD_VAR 0 4
89478: PPUSH
89479: CALL_OW 292
89483: IFFALSE 89497
// begin result := true ;
89485: LD_ADDR_VAR 0 3
89489: PUSH
89490: LD_INT 1
89492: ST_TO_ADDR
// exit ;
89493: POP
89494: POP
89495: GO 89501
// end ;
89497: GO 89466
89499: POP
89500: POP
// end ;
89501: LD_VAR 0 3
89505: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
89506: LD_INT 0
89508: PPUSH
89509: PPUSH
89510: PPUSH
89511: PPUSH
// if not unit or not points then
89512: LD_VAR 0 1
89516: NOT
89517: PUSH
89518: LD_VAR 0 2
89522: NOT
89523: OR
89524: IFFALSE 89528
// exit ;
89526: GO 89618
// dist := 99999 ;
89528: LD_ADDR_VAR 0 5
89532: PUSH
89533: LD_INT 99999
89535: ST_TO_ADDR
// for i in points do
89536: LD_ADDR_VAR 0 4
89540: PUSH
89541: LD_VAR 0 2
89545: PUSH
89546: FOR_IN
89547: IFFALSE 89616
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
89549: LD_ADDR_VAR 0 6
89553: PUSH
89554: LD_VAR 0 1
89558: PPUSH
89559: LD_VAR 0 4
89563: PUSH
89564: LD_INT 1
89566: ARRAY
89567: PPUSH
89568: LD_VAR 0 4
89572: PUSH
89573: LD_INT 2
89575: ARRAY
89576: PPUSH
89577: CALL_OW 297
89581: ST_TO_ADDR
// if tmpDist < dist then
89582: LD_VAR 0 6
89586: PUSH
89587: LD_VAR 0 5
89591: LESS
89592: IFFALSE 89614
// begin result := i ;
89594: LD_ADDR_VAR 0 3
89598: PUSH
89599: LD_VAR 0 4
89603: ST_TO_ADDR
// dist := tmpDist ;
89604: LD_ADDR_VAR 0 5
89608: PUSH
89609: LD_VAR 0 6
89613: ST_TO_ADDR
// end ; end ;
89614: GO 89546
89616: POP
89617: POP
// end ;
89618: LD_VAR 0 3
89622: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
89623: LD_INT 0
89625: PPUSH
// uc_side := side ;
89626: LD_ADDR_OWVAR 20
89630: PUSH
89631: LD_VAR 0 1
89635: ST_TO_ADDR
// uc_nation := 3 ;
89636: LD_ADDR_OWVAR 21
89640: PUSH
89641: LD_INT 3
89643: ST_TO_ADDR
// vc_chassis := 25 ;
89644: LD_ADDR_OWVAR 37
89648: PUSH
89649: LD_INT 25
89651: ST_TO_ADDR
// vc_engine := engine_siberite ;
89652: LD_ADDR_OWVAR 39
89656: PUSH
89657: LD_INT 3
89659: ST_TO_ADDR
// vc_control := control_computer ;
89660: LD_ADDR_OWVAR 38
89664: PUSH
89665: LD_INT 3
89667: ST_TO_ADDR
// vc_weapon := 59 ;
89668: LD_ADDR_OWVAR 40
89672: PUSH
89673: LD_INT 59
89675: ST_TO_ADDR
// result := CreateVehicle ;
89676: LD_ADDR_VAR 0 5
89680: PUSH
89681: CALL_OW 45
89685: ST_TO_ADDR
// SetDir ( result , d ) ;
89686: LD_VAR 0 5
89690: PPUSH
89691: LD_VAR 0 4
89695: PPUSH
89696: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
89700: LD_VAR 0 5
89704: PPUSH
89705: LD_VAR 0 2
89709: PPUSH
89710: LD_VAR 0 3
89714: PPUSH
89715: LD_INT 0
89717: PPUSH
89718: CALL_OW 48
// end ;
89722: LD_VAR 0 5
89726: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
89727: LD_INT 0
89729: PPUSH
89730: PPUSH
89731: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
89732: LD_ADDR_VAR 0 2
89736: PUSH
89737: LD_INT 0
89739: PUSH
89740: LD_INT 0
89742: PUSH
89743: LD_INT 0
89745: PUSH
89746: LD_INT 0
89748: PUSH
89749: EMPTY
89750: LIST
89751: LIST
89752: LIST
89753: LIST
89754: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
89755: LD_VAR 0 1
89759: NOT
89760: PUSH
89761: LD_VAR 0 1
89765: PPUSH
89766: CALL_OW 264
89770: PUSH
89771: LD_INT 12
89773: PUSH
89774: LD_INT 51
89776: PUSH
89777: LD_INT 32
89779: PUSH
89780: LD_INT 89
89782: PUSH
89783: EMPTY
89784: LIST
89785: LIST
89786: LIST
89787: LIST
89788: IN
89789: NOT
89790: OR
89791: IFFALSE 89795
// exit ;
89793: GO 89893
// for i := 1 to 3 do
89795: LD_ADDR_VAR 0 3
89799: PUSH
89800: DOUBLE
89801: LD_INT 1
89803: DEC
89804: ST_TO_ADDR
89805: LD_INT 3
89807: PUSH
89808: FOR_TO
89809: IFFALSE 89891
// begin tmp := GetCargo ( cargo , i ) ;
89811: LD_ADDR_VAR 0 4
89815: PUSH
89816: LD_VAR 0 1
89820: PPUSH
89821: LD_VAR 0 3
89825: PPUSH
89826: CALL_OW 289
89830: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
89831: LD_ADDR_VAR 0 2
89835: PUSH
89836: LD_VAR 0 2
89840: PPUSH
89841: LD_VAR 0 3
89845: PPUSH
89846: LD_VAR 0 4
89850: PPUSH
89851: CALL_OW 1
89855: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
89856: LD_ADDR_VAR 0 2
89860: PUSH
89861: LD_VAR 0 2
89865: PPUSH
89866: LD_INT 4
89868: PPUSH
89869: LD_VAR 0 2
89873: PUSH
89874: LD_INT 4
89876: ARRAY
89877: PUSH
89878: LD_VAR 0 4
89882: PLUS
89883: PPUSH
89884: CALL_OW 1
89888: ST_TO_ADDR
// end ;
89889: GO 89808
89891: POP
89892: POP
// end ;
89893: LD_VAR 0 2
89897: RET
// export function Length ( array ) ; begin
89898: LD_INT 0
89900: PPUSH
// result := array + 0 ;
89901: LD_ADDR_VAR 0 2
89905: PUSH
89906: LD_VAR 0 1
89910: PUSH
89911: LD_INT 0
89913: PLUS
89914: ST_TO_ADDR
// end ;
89915: LD_VAR 0 2
89919: RET
// export function PrepareArray ( array ) ; begin
89920: LD_INT 0
89922: PPUSH
// result := array diff 0 ;
89923: LD_ADDR_VAR 0 2
89927: PUSH
89928: LD_VAR 0 1
89932: PUSH
89933: LD_INT 0
89935: DIFF
89936: ST_TO_ADDR
// if not result [ 1 ] then
89937: LD_VAR 0 2
89941: PUSH
89942: LD_INT 1
89944: ARRAY
89945: NOT
89946: IFFALSE 89966
// result := Delete ( result , 1 ) ;
89948: LD_ADDR_VAR 0 2
89952: PUSH
89953: LD_VAR 0 2
89957: PPUSH
89958: LD_INT 1
89960: PPUSH
89961: CALL_OW 3
89965: ST_TO_ADDR
// end ;
89966: LD_VAR 0 2
89970: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
89971: LD_INT 0
89973: PPUSH
89974: PPUSH
89975: PPUSH
89976: PPUSH
// sibRocketRange := 25 ;
89977: LD_ADDR_VAR 0 6
89981: PUSH
89982: LD_INT 25
89984: ST_TO_ADDR
// result := false ;
89985: LD_ADDR_VAR 0 4
89989: PUSH
89990: LD_INT 0
89992: ST_TO_ADDR
// for i := 0 to 5 do
89993: LD_ADDR_VAR 0 5
89997: PUSH
89998: DOUBLE
89999: LD_INT 0
90001: DEC
90002: ST_TO_ADDR
90003: LD_INT 5
90005: PUSH
90006: FOR_TO
90007: IFFALSE 90074
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
90009: LD_VAR 0 1
90013: PPUSH
90014: LD_VAR 0 5
90018: PPUSH
90019: LD_VAR 0 6
90023: PPUSH
90024: CALL_OW 272
90028: PPUSH
90029: LD_VAR 0 2
90033: PPUSH
90034: LD_VAR 0 5
90038: PPUSH
90039: LD_VAR 0 6
90043: PPUSH
90044: CALL_OW 273
90048: PPUSH
90049: LD_VAR 0 3
90053: PPUSH
90054: CALL_OW 309
90058: IFFALSE 90072
// begin result := true ;
90060: LD_ADDR_VAR 0 4
90064: PUSH
90065: LD_INT 1
90067: ST_TO_ADDR
// exit ;
90068: POP
90069: POP
90070: GO 90076
// end ;
90072: GO 90006
90074: POP
90075: POP
// end ;
90076: LD_VAR 0 4
90080: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
90081: LD_INT 0
90083: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
90084: LD_VAR 0 1
90088: PPUSH
90089: LD_VAR 0 2
90093: PPUSH
90094: LD_INT 0
90096: PPUSH
90097: LD_INT 0
90099: PPUSH
90100: LD_INT 1
90102: PPUSH
90103: LD_INT 0
90105: PPUSH
90106: CALL_OW 587
// end ; end_of_file end_of_file
90110: LD_VAR 0 3
90114: RET
// export globalGameSaveCounter ; every 0 0$1 do
90115: GO 90117
90117: DISABLE
// begin enable ;
90118: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
90119: LD_STRING updateTimer(
90121: PUSH
90122: LD_OWVAR 1
90126: STR
90127: PUSH
90128: LD_STRING );
90130: STR
90131: PPUSH
90132: CALL_OW 559
// end ;
90136: END
// every 0 0$1 do
90137: GO 90139
90139: DISABLE
// begin globalGameSaveCounter := 0 ;
90140: LD_ADDR_EXP 95
90144: PUSH
90145: LD_INT 0
90147: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
90148: LD_STRING setGameSaveCounter(0)
90150: PPUSH
90151: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
90155: LD_STRING initStreamRollete();
90157: PPUSH
90158: CALL_OW 559
// InitStreamMode ;
90162: CALL 91488 0 0
// DefineStreamItems ( false ) ;
90166: LD_INT 0
90168: PPUSH
90169: CALL 91952 0 1
// end ;
90173: END
// export function SOS_MapStart ( ) ; begin
90174: LD_INT 0
90176: PPUSH
// if streamModeActive then
90177: LD_EXP 96
90181: IFFALSE 90190
// DefineStreamItems ( true ) ;
90183: LD_INT 1
90185: PPUSH
90186: CALL 91952 0 1
// UpdateLuaVariables ( ) ;
90190: CALL 90207 0 0
// UpdateFactoryWaypoints ( ) ;
90194: CALL 104813 0 0
// UpdateWarehouseGatheringPoints ( ) ;
90198: CALL 105070 0 0
// end ;
90202: LD_VAR 0 1
90206: RET
// function UpdateLuaVariables ( ) ; begin
90207: LD_INT 0
90209: PPUSH
// if globalGameSaveCounter then
90210: LD_EXP 95
90214: IFFALSE 90248
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
90216: LD_ADDR_EXP 95
90220: PUSH
90221: LD_EXP 95
90225: PPUSH
90226: CALL 87523 0 1
90230: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
90231: LD_STRING setGameSaveCounter(
90233: PUSH
90234: LD_EXP 95
90238: STR
90239: PUSH
90240: LD_STRING )
90242: STR
90243: PPUSH
90244: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
90248: LD_STRING setGameDifficulty(
90250: PUSH
90251: LD_OWVAR 67
90255: STR
90256: PUSH
90257: LD_STRING )
90259: STR
90260: PPUSH
90261: CALL_OW 559
// end ;
90265: LD_VAR 0 1
90269: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
90270: LD_INT 0
90272: PPUSH
// if p2 = stream_mode then
90273: LD_VAR 0 2
90277: PUSH
90278: LD_INT 100
90280: EQUAL
90281: IFFALSE 91284
// begin if not StreamModeActive then
90283: LD_EXP 96
90287: NOT
90288: IFFALSE 90298
// StreamModeActive := true ;
90290: LD_ADDR_EXP 96
90294: PUSH
90295: LD_INT 1
90297: ST_TO_ADDR
// if p3 = 0 then
90298: LD_VAR 0 3
90302: PUSH
90303: LD_INT 0
90305: EQUAL
90306: IFFALSE 90312
// InitStreamMode ;
90308: CALL 91488 0 0
// if p3 = 1 then
90312: LD_VAR 0 3
90316: PUSH
90317: LD_INT 1
90319: EQUAL
90320: IFFALSE 90330
// sRocket := true ;
90322: LD_ADDR_EXP 101
90326: PUSH
90327: LD_INT 1
90329: ST_TO_ADDR
// if p3 = 2 then
90330: LD_VAR 0 3
90334: PUSH
90335: LD_INT 2
90337: EQUAL
90338: IFFALSE 90348
// sSpeed := true ;
90340: LD_ADDR_EXP 100
90344: PUSH
90345: LD_INT 1
90347: ST_TO_ADDR
// if p3 = 3 then
90348: LD_VAR 0 3
90352: PUSH
90353: LD_INT 3
90355: EQUAL
90356: IFFALSE 90366
// sEngine := true ;
90358: LD_ADDR_EXP 102
90362: PUSH
90363: LD_INT 1
90365: ST_TO_ADDR
// if p3 = 4 then
90366: LD_VAR 0 3
90370: PUSH
90371: LD_INT 4
90373: EQUAL
90374: IFFALSE 90384
// sSpec := true ;
90376: LD_ADDR_EXP 99
90380: PUSH
90381: LD_INT 1
90383: ST_TO_ADDR
// if p3 = 5 then
90384: LD_VAR 0 3
90388: PUSH
90389: LD_INT 5
90391: EQUAL
90392: IFFALSE 90402
// sLevel := true ;
90394: LD_ADDR_EXP 103
90398: PUSH
90399: LD_INT 1
90401: ST_TO_ADDR
// if p3 = 6 then
90402: LD_VAR 0 3
90406: PUSH
90407: LD_INT 6
90409: EQUAL
90410: IFFALSE 90420
// sArmoury := true ;
90412: LD_ADDR_EXP 104
90416: PUSH
90417: LD_INT 1
90419: ST_TO_ADDR
// if p3 = 7 then
90420: LD_VAR 0 3
90424: PUSH
90425: LD_INT 7
90427: EQUAL
90428: IFFALSE 90438
// sRadar := true ;
90430: LD_ADDR_EXP 105
90434: PUSH
90435: LD_INT 1
90437: ST_TO_ADDR
// if p3 = 8 then
90438: LD_VAR 0 3
90442: PUSH
90443: LD_INT 8
90445: EQUAL
90446: IFFALSE 90456
// sBunker := true ;
90448: LD_ADDR_EXP 106
90452: PUSH
90453: LD_INT 1
90455: ST_TO_ADDR
// if p3 = 9 then
90456: LD_VAR 0 3
90460: PUSH
90461: LD_INT 9
90463: EQUAL
90464: IFFALSE 90474
// sHack := true ;
90466: LD_ADDR_EXP 107
90470: PUSH
90471: LD_INT 1
90473: ST_TO_ADDR
// if p3 = 10 then
90474: LD_VAR 0 3
90478: PUSH
90479: LD_INT 10
90481: EQUAL
90482: IFFALSE 90492
// sFire := true ;
90484: LD_ADDR_EXP 108
90488: PUSH
90489: LD_INT 1
90491: ST_TO_ADDR
// if p3 = 11 then
90492: LD_VAR 0 3
90496: PUSH
90497: LD_INT 11
90499: EQUAL
90500: IFFALSE 90510
// sRefresh := true ;
90502: LD_ADDR_EXP 109
90506: PUSH
90507: LD_INT 1
90509: ST_TO_ADDR
// if p3 = 12 then
90510: LD_VAR 0 3
90514: PUSH
90515: LD_INT 12
90517: EQUAL
90518: IFFALSE 90528
// sExp := true ;
90520: LD_ADDR_EXP 110
90524: PUSH
90525: LD_INT 1
90527: ST_TO_ADDR
// if p3 = 13 then
90528: LD_VAR 0 3
90532: PUSH
90533: LD_INT 13
90535: EQUAL
90536: IFFALSE 90546
// sDepot := true ;
90538: LD_ADDR_EXP 111
90542: PUSH
90543: LD_INT 1
90545: ST_TO_ADDR
// if p3 = 14 then
90546: LD_VAR 0 3
90550: PUSH
90551: LD_INT 14
90553: EQUAL
90554: IFFALSE 90564
// sFlag := true ;
90556: LD_ADDR_EXP 112
90560: PUSH
90561: LD_INT 1
90563: ST_TO_ADDR
// if p3 = 15 then
90564: LD_VAR 0 3
90568: PUSH
90569: LD_INT 15
90571: EQUAL
90572: IFFALSE 90582
// sKamikadze := true ;
90574: LD_ADDR_EXP 120
90578: PUSH
90579: LD_INT 1
90581: ST_TO_ADDR
// if p3 = 16 then
90582: LD_VAR 0 3
90586: PUSH
90587: LD_INT 16
90589: EQUAL
90590: IFFALSE 90600
// sTroll := true ;
90592: LD_ADDR_EXP 121
90596: PUSH
90597: LD_INT 1
90599: ST_TO_ADDR
// if p3 = 17 then
90600: LD_VAR 0 3
90604: PUSH
90605: LD_INT 17
90607: EQUAL
90608: IFFALSE 90618
// sSlow := true ;
90610: LD_ADDR_EXP 122
90614: PUSH
90615: LD_INT 1
90617: ST_TO_ADDR
// if p3 = 18 then
90618: LD_VAR 0 3
90622: PUSH
90623: LD_INT 18
90625: EQUAL
90626: IFFALSE 90636
// sLack := true ;
90628: LD_ADDR_EXP 123
90632: PUSH
90633: LD_INT 1
90635: ST_TO_ADDR
// if p3 = 19 then
90636: LD_VAR 0 3
90640: PUSH
90641: LD_INT 19
90643: EQUAL
90644: IFFALSE 90654
// sTank := true ;
90646: LD_ADDR_EXP 125
90650: PUSH
90651: LD_INT 1
90653: ST_TO_ADDR
// if p3 = 20 then
90654: LD_VAR 0 3
90658: PUSH
90659: LD_INT 20
90661: EQUAL
90662: IFFALSE 90672
// sRemote := true ;
90664: LD_ADDR_EXP 126
90668: PUSH
90669: LD_INT 1
90671: ST_TO_ADDR
// if p3 = 21 then
90672: LD_VAR 0 3
90676: PUSH
90677: LD_INT 21
90679: EQUAL
90680: IFFALSE 90690
// sPowell := true ;
90682: LD_ADDR_EXP 127
90686: PUSH
90687: LD_INT 1
90689: ST_TO_ADDR
// if p3 = 22 then
90690: LD_VAR 0 3
90694: PUSH
90695: LD_INT 22
90697: EQUAL
90698: IFFALSE 90708
// sTeleport := true ;
90700: LD_ADDR_EXP 130
90704: PUSH
90705: LD_INT 1
90707: ST_TO_ADDR
// if p3 = 23 then
90708: LD_VAR 0 3
90712: PUSH
90713: LD_INT 23
90715: EQUAL
90716: IFFALSE 90726
// sOilTower := true ;
90718: LD_ADDR_EXP 132
90722: PUSH
90723: LD_INT 1
90725: ST_TO_ADDR
// if p3 = 24 then
90726: LD_VAR 0 3
90730: PUSH
90731: LD_INT 24
90733: EQUAL
90734: IFFALSE 90744
// sShovel := true ;
90736: LD_ADDR_EXP 133
90740: PUSH
90741: LD_INT 1
90743: ST_TO_ADDR
// if p3 = 25 then
90744: LD_VAR 0 3
90748: PUSH
90749: LD_INT 25
90751: EQUAL
90752: IFFALSE 90762
// sSheik := true ;
90754: LD_ADDR_EXP 134
90758: PUSH
90759: LD_INT 1
90761: ST_TO_ADDR
// if p3 = 26 then
90762: LD_VAR 0 3
90766: PUSH
90767: LD_INT 26
90769: EQUAL
90770: IFFALSE 90780
// sEarthquake := true ;
90772: LD_ADDR_EXP 136
90776: PUSH
90777: LD_INT 1
90779: ST_TO_ADDR
// if p3 = 27 then
90780: LD_VAR 0 3
90784: PUSH
90785: LD_INT 27
90787: EQUAL
90788: IFFALSE 90798
// sAI := true ;
90790: LD_ADDR_EXP 137
90794: PUSH
90795: LD_INT 1
90797: ST_TO_ADDR
// if p3 = 28 then
90798: LD_VAR 0 3
90802: PUSH
90803: LD_INT 28
90805: EQUAL
90806: IFFALSE 90816
// sCargo := true ;
90808: LD_ADDR_EXP 140
90812: PUSH
90813: LD_INT 1
90815: ST_TO_ADDR
// if p3 = 29 then
90816: LD_VAR 0 3
90820: PUSH
90821: LD_INT 29
90823: EQUAL
90824: IFFALSE 90834
// sDLaser := true ;
90826: LD_ADDR_EXP 141
90830: PUSH
90831: LD_INT 1
90833: ST_TO_ADDR
// if p3 = 30 then
90834: LD_VAR 0 3
90838: PUSH
90839: LD_INT 30
90841: EQUAL
90842: IFFALSE 90852
// sExchange := true ;
90844: LD_ADDR_EXP 142
90848: PUSH
90849: LD_INT 1
90851: ST_TO_ADDR
// if p3 = 31 then
90852: LD_VAR 0 3
90856: PUSH
90857: LD_INT 31
90859: EQUAL
90860: IFFALSE 90870
// sFac := true ;
90862: LD_ADDR_EXP 143
90866: PUSH
90867: LD_INT 1
90869: ST_TO_ADDR
// if p3 = 32 then
90870: LD_VAR 0 3
90874: PUSH
90875: LD_INT 32
90877: EQUAL
90878: IFFALSE 90888
// sPower := true ;
90880: LD_ADDR_EXP 144
90884: PUSH
90885: LD_INT 1
90887: ST_TO_ADDR
// if p3 = 33 then
90888: LD_VAR 0 3
90892: PUSH
90893: LD_INT 33
90895: EQUAL
90896: IFFALSE 90906
// sRandom := true ;
90898: LD_ADDR_EXP 145
90902: PUSH
90903: LD_INT 1
90905: ST_TO_ADDR
// if p3 = 34 then
90906: LD_VAR 0 3
90910: PUSH
90911: LD_INT 34
90913: EQUAL
90914: IFFALSE 90924
// sShield := true ;
90916: LD_ADDR_EXP 146
90920: PUSH
90921: LD_INT 1
90923: ST_TO_ADDR
// if p3 = 35 then
90924: LD_VAR 0 3
90928: PUSH
90929: LD_INT 35
90931: EQUAL
90932: IFFALSE 90942
// sTime := true ;
90934: LD_ADDR_EXP 147
90938: PUSH
90939: LD_INT 1
90941: ST_TO_ADDR
// if p3 = 36 then
90942: LD_VAR 0 3
90946: PUSH
90947: LD_INT 36
90949: EQUAL
90950: IFFALSE 90960
// sTools := true ;
90952: LD_ADDR_EXP 148
90956: PUSH
90957: LD_INT 1
90959: ST_TO_ADDR
// if p3 = 101 then
90960: LD_VAR 0 3
90964: PUSH
90965: LD_INT 101
90967: EQUAL
90968: IFFALSE 90978
// sSold := true ;
90970: LD_ADDR_EXP 113
90974: PUSH
90975: LD_INT 1
90977: ST_TO_ADDR
// if p3 = 102 then
90978: LD_VAR 0 3
90982: PUSH
90983: LD_INT 102
90985: EQUAL
90986: IFFALSE 90996
// sDiff := true ;
90988: LD_ADDR_EXP 114
90992: PUSH
90993: LD_INT 1
90995: ST_TO_ADDR
// if p3 = 103 then
90996: LD_VAR 0 3
91000: PUSH
91001: LD_INT 103
91003: EQUAL
91004: IFFALSE 91014
// sFog := true ;
91006: LD_ADDR_EXP 117
91010: PUSH
91011: LD_INT 1
91013: ST_TO_ADDR
// if p3 = 104 then
91014: LD_VAR 0 3
91018: PUSH
91019: LD_INT 104
91021: EQUAL
91022: IFFALSE 91032
// sReset := true ;
91024: LD_ADDR_EXP 118
91028: PUSH
91029: LD_INT 1
91031: ST_TO_ADDR
// if p3 = 105 then
91032: LD_VAR 0 3
91036: PUSH
91037: LD_INT 105
91039: EQUAL
91040: IFFALSE 91050
// sSun := true ;
91042: LD_ADDR_EXP 119
91046: PUSH
91047: LD_INT 1
91049: ST_TO_ADDR
// if p3 = 106 then
91050: LD_VAR 0 3
91054: PUSH
91055: LD_INT 106
91057: EQUAL
91058: IFFALSE 91068
// sTiger := true ;
91060: LD_ADDR_EXP 115
91064: PUSH
91065: LD_INT 1
91067: ST_TO_ADDR
// if p3 = 107 then
91068: LD_VAR 0 3
91072: PUSH
91073: LD_INT 107
91075: EQUAL
91076: IFFALSE 91086
// sBomb := true ;
91078: LD_ADDR_EXP 116
91082: PUSH
91083: LD_INT 1
91085: ST_TO_ADDR
// if p3 = 108 then
91086: LD_VAR 0 3
91090: PUSH
91091: LD_INT 108
91093: EQUAL
91094: IFFALSE 91104
// sWound := true ;
91096: LD_ADDR_EXP 124
91100: PUSH
91101: LD_INT 1
91103: ST_TO_ADDR
// if p3 = 109 then
91104: LD_VAR 0 3
91108: PUSH
91109: LD_INT 109
91111: EQUAL
91112: IFFALSE 91122
// sBetray := true ;
91114: LD_ADDR_EXP 128
91118: PUSH
91119: LD_INT 1
91121: ST_TO_ADDR
// if p3 = 110 then
91122: LD_VAR 0 3
91126: PUSH
91127: LD_INT 110
91129: EQUAL
91130: IFFALSE 91140
// sContamin := true ;
91132: LD_ADDR_EXP 129
91136: PUSH
91137: LD_INT 1
91139: ST_TO_ADDR
// if p3 = 111 then
91140: LD_VAR 0 3
91144: PUSH
91145: LD_INT 111
91147: EQUAL
91148: IFFALSE 91158
// sOil := true ;
91150: LD_ADDR_EXP 131
91154: PUSH
91155: LD_INT 1
91157: ST_TO_ADDR
// if p3 = 112 then
91158: LD_VAR 0 3
91162: PUSH
91163: LD_INT 112
91165: EQUAL
91166: IFFALSE 91176
// sStu := true ;
91168: LD_ADDR_EXP 135
91172: PUSH
91173: LD_INT 1
91175: ST_TO_ADDR
// if p3 = 113 then
91176: LD_VAR 0 3
91180: PUSH
91181: LD_INT 113
91183: EQUAL
91184: IFFALSE 91194
// sBazooka := true ;
91186: LD_ADDR_EXP 138
91190: PUSH
91191: LD_INT 1
91193: ST_TO_ADDR
// if p3 = 114 then
91194: LD_VAR 0 3
91198: PUSH
91199: LD_INT 114
91201: EQUAL
91202: IFFALSE 91212
// sMortar := true ;
91204: LD_ADDR_EXP 139
91208: PUSH
91209: LD_INT 1
91211: ST_TO_ADDR
// if p3 = 115 then
91212: LD_VAR 0 3
91216: PUSH
91217: LD_INT 115
91219: EQUAL
91220: IFFALSE 91230
// sRanger := true ;
91222: LD_ADDR_EXP 149
91226: PUSH
91227: LD_INT 1
91229: ST_TO_ADDR
// if p3 = 116 then
91230: LD_VAR 0 3
91234: PUSH
91235: LD_INT 116
91237: EQUAL
91238: IFFALSE 91248
// sComputer := true ;
91240: LD_ADDR_EXP 150
91244: PUSH
91245: LD_INT 1
91247: ST_TO_ADDR
// if p3 = 117 then
91248: LD_VAR 0 3
91252: PUSH
91253: LD_INT 117
91255: EQUAL
91256: IFFALSE 91266
// s30 := true ;
91258: LD_ADDR_EXP 151
91262: PUSH
91263: LD_INT 1
91265: ST_TO_ADDR
// if p3 = 118 then
91266: LD_VAR 0 3
91270: PUSH
91271: LD_INT 118
91273: EQUAL
91274: IFFALSE 91284
// s60 := true ;
91276: LD_ADDR_EXP 152
91280: PUSH
91281: LD_INT 1
91283: ST_TO_ADDR
// end ; if p2 = hack_mode then
91284: LD_VAR 0 2
91288: PUSH
91289: LD_INT 101
91291: EQUAL
91292: IFFALSE 91420
// begin case p3 of 1 :
91294: LD_VAR 0 3
91298: PUSH
91299: LD_INT 1
91301: DOUBLE
91302: EQUAL
91303: IFTRUE 91307
91305: GO 91314
91307: POP
// hHackUnlimitedResources ; 2 :
91308: CALL 103559 0 0
91312: GO 91420
91314: LD_INT 2
91316: DOUBLE
91317: EQUAL
91318: IFTRUE 91322
91320: GO 91329
91322: POP
// hHackSetLevel10 ; 3 :
91323: CALL 103692 0 0
91327: GO 91420
91329: LD_INT 3
91331: DOUBLE
91332: EQUAL
91333: IFTRUE 91337
91335: GO 91344
91337: POP
// hHackSetLevel10YourUnits ; 4 :
91338: CALL 103777 0 0
91342: GO 91420
91344: LD_INT 4
91346: DOUBLE
91347: EQUAL
91348: IFTRUE 91352
91350: GO 91359
91352: POP
// hHackInvincible ; 5 :
91353: CALL 104225 0 0
91357: GO 91420
91359: LD_INT 5
91361: DOUBLE
91362: EQUAL
91363: IFTRUE 91367
91365: GO 91374
91367: POP
// hHackInvisible ; 6 :
91368: CALL 104336 0 0
91372: GO 91420
91374: LD_INT 6
91376: DOUBLE
91377: EQUAL
91378: IFTRUE 91382
91380: GO 91389
91382: POP
// hHackChangeYourSide ; 7 :
91383: CALL 104393 0 0
91387: GO 91420
91389: LD_INT 7
91391: DOUBLE
91392: EQUAL
91393: IFTRUE 91397
91395: GO 91404
91397: POP
// hHackChangeUnitSide ; 8 :
91398: CALL 104435 0 0
91402: GO 91420
91404: LD_INT 8
91406: DOUBLE
91407: EQUAL
91408: IFTRUE 91412
91410: GO 91419
91412: POP
// hHackFog ; end ;
91413: CALL 104536 0 0
91417: GO 91420
91419: POP
// end ; if p2 = game_save_mode then
91420: LD_VAR 0 2
91424: PUSH
91425: LD_INT 102
91427: EQUAL
91428: IFFALSE 91483
// begin if p3 = 1 then
91430: LD_VAR 0 3
91434: PUSH
91435: LD_INT 1
91437: EQUAL
91438: IFFALSE 91450
// globalGameSaveCounter := p4 ;
91440: LD_ADDR_EXP 95
91444: PUSH
91445: LD_VAR 0 4
91449: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
91450: LD_VAR 0 3
91454: PUSH
91455: LD_INT 2
91457: EQUAL
91458: PUSH
91459: LD_EXP 95
91463: AND
91464: IFFALSE 91483
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
91466: LD_STRING setGameSaveCounter(
91468: PUSH
91469: LD_EXP 95
91473: STR
91474: PUSH
91475: LD_STRING )
91477: STR
91478: PPUSH
91479: CALL_OW 559
// end ; end ;
91483: LD_VAR 0 7
91487: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
91488: LD_INT 0
91490: PPUSH
// streamModeActive := false ;
91491: LD_ADDR_EXP 96
91495: PUSH
91496: LD_INT 0
91498: ST_TO_ADDR
// normalCounter := 36 ;
91499: LD_ADDR_EXP 97
91503: PUSH
91504: LD_INT 36
91506: ST_TO_ADDR
// hardcoreCounter := 18 ;
91507: LD_ADDR_EXP 98
91511: PUSH
91512: LD_INT 18
91514: ST_TO_ADDR
// sRocket := false ;
91515: LD_ADDR_EXP 101
91519: PUSH
91520: LD_INT 0
91522: ST_TO_ADDR
// sSpeed := false ;
91523: LD_ADDR_EXP 100
91527: PUSH
91528: LD_INT 0
91530: ST_TO_ADDR
// sEngine := false ;
91531: LD_ADDR_EXP 102
91535: PUSH
91536: LD_INT 0
91538: ST_TO_ADDR
// sSpec := false ;
91539: LD_ADDR_EXP 99
91543: PUSH
91544: LD_INT 0
91546: ST_TO_ADDR
// sLevel := false ;
91547: LD_ADDR_EXP 103
91551: PUSH
91552: LD_INT 0
91554: ST_TO_ADDR
// sArmoury := false ;
91555: LD_ADDR_EXP 104
91559: PUSH
91560: LD_INT 0
91562: ST_TO_ADDR
// sRadar := false ;
91563: LD_ADDR_EXP 105
91567: PUSH
91568: LD_INT 0
91570: ST_TO_ADDR
// sBunker := false ;
91571: LD_ADDR_EXP 106
91575: PUSH
91576: LD_INT 0
91578: ST_TO_ADDR
// sHack := false ;
91579: LD_ADDR_EXP 107
91583: PUSH
91584: LD_INT 0
91586: ST_TO_ADDR
// sFire := false ;
91587: LD_ADDR_EXP 108
91591: PUSH
91592: LD_INT 0
91594: ST_TO_ADDR
// sRefresh := false ;
91595: LD_ADDR_EXP 109
91599: PUSH
91600: LD_INT 0
91602: ST_TO_ADDR
// sExp := false ;
91603: LD_ADDR_EXP 110
91607: PUSH
91608: LD_INT 0
91610: ST_TO_ADDR
// sDepot := false ;
91611: LD_ADDR_EXP 111
91615: PUSH
91616: LD_INT 0
91618: ST_TO_ADDR
// sFlag := false ;
91619: LD_ADDR_EXP 112
91623: PUSH
91624: LD_INT 0
91626: ST_TO_ADDR
// sKamikadze := false ;
91627: LD_ADDR_EXP 120
91631: PUSH
91632: LD_INT 0
91634: ST_TO_ADDR
// sTroll := false ;
91635: LD_ADDR_EXP 121
91639: PUSH
91640: LD_INT 0
91642: ST_TO_ADDR
// sSlow := false ;
91643: LD_ADDR_EXP 122
91647: PUSH
91648: LD_INT 0
91650: ST_TO_ADDR
// sLack := false ;
91651: LD_ADDR_EXP 123
91655: PUSH
91656: LD_INT 0
91658: ST_TO_ADDR
// sTank := false ;
91659: LD_ADDR_EXP 125
91663: PUSH
91664: LD_INT 0
91666: ST_TO_ADDR
// sRemote := false ;
91667: LD_ADDR_EXP 126
91671: PUSH
91672: LD_INT 0
91674: ST_TO_ADDR
// sPowell := false ;
91675: LD_ADDR_EXP 127
91679: PUSH
91680: LD_INT 0
91682: ST_TO_ADDR
// sTeleport := false ;
91683: LD_ADDR_EXP 130
91687: PUSH
91688: LD_INT 0
91690: ST_TO_ADDR
// sOilTower := false ;
91691: LD_ADDR_EXP 132
91695: PUSH
91696: LD_INT 0
91698: ST_TO_ADDR
// sShovel := false ;
91699: LD_ADDR_EXP 133
91703: PUSH
91704: LD_INT 0
91706: ST_TO_ADDR
// sSheik := false ;
91707: LD_ADDR_EXP 134
91711: PUSH
91712: LD_INT 0
91714: ST_TO_ADDR
// sEarthquake := false ;
91715: LD_ADDR_EXP 136
91719: PUSH
91720: LD_INT 0
91722: ST_TO_ADDR
// sAI := false ;
91723: LD_ADDR_EXP 137
91727: PUSH
91728: LD_INT 0
91730: ST_TO_ADDR
// sCargo := false ;
91731: LD_ADDR_EXP 140
91735: PUSH
91736: LD_INT 0
91738: ST_TO_ADDR
// sDLaser := false ;
91739: LD_ADDR_EXP 141
91743: PUSH
91744: LD_INT 0
91746: ST_TO_ADDR
// sExchange := false ;
91747: LD_ADDR_EXP 142
91751: PUSH
91752: LD_INT 0
91754: ST_TO_ADDR
// sFac := false ;
91755: LD_ADDR_EXP 143
91759: PUSH
91760: LD_INT 0
91762: ST_TO_ADDR
// sPower := false ;
91763: LD_ADDR_EXP 144
91767: PUSH
91768: LD_INT 0
91770: ST_TO_ADDR
// sRandom := false ;
91771: LD_ADDR_EXP 145
91775: PUSH
91776: LD_INT 0
91778: ST_TO_ADDR
// sShield := false ;
91779: LD_ADDR_EXP 146
91783: PUSH
91784: LD_INT 0
91786: ST_TO_ADDR
// sTime := false ;
91787: LD_ADDR_EXP 147
91791: PUSH
91792: LD_INT 0
91794: ST_TO_ADDR
// sTools := false ;
91795: LD_ADDR_EXP 148
91799: PUSH
91800: LD_INT 0
91802: ST_TO_ADDR
// sSold := false ;
91803: LD_ADDR_EXP 113
91807: PUSH
91808: LD_INT 0
91810: ST_TO_ADDR
// sDiff := false ;
91811: LD_ADDR_EXP 114
91815: PUSH
91816: LD_INT 0
91818: ST_TO_ADDR
// sFog := false ;
91819: LD_ADDR_EXP 117
91823: PUSH
91824: LD_INT 0
91826: ST_TO_ADDR
// sReset := false ;
91827: LD_ADDR_EXP 118
91831: PUSH
91832: LD_INT 0
91834: ST_TO_ADDR
// sSun := false ;
91835: LD_ADDR_EXP 119
91839: PUSH
91840: LD_INT 0
91842: ST_TO_ADDR
// sTiger := false ;
91843: LD_ADDR_EXP 115
91847: PUSH
91848: LD_INT 0
91850: ST_TO_ADDR
// sBomb := false ;
91851: LD_ADDR_EXP 116
91855: PUSH
91856: LD_INT 0
91858: ST_TO_ADDR
// sWound := false ;
91859: LD_ADDR_EXP 124
91863: PUSH
91864: LD_INT 0
91866: ST_TO_ADDR
// sBetray := false ;
91867: LD_ADDR_EXP 128
91871: PUSH
91872: LD_INT 0
91874: ST_TO_ADDR
// sContamin := false ;
91875: LD_ADDR_EXP 129
91879: PUSH
91880: LD_INT 0
91882: ST_TO_ADDR
// sOil := false ;
91883: LD_ADDR_EXP 131
91887: PUSH
91888: LD_INT 0
91890: ST_TO_ADDR
// sStu := false ;
91891: LD_ADDR_EXP 135
91895: PUSH
91896: LD_INT 0
91898: ST_TO_ADDR
// sBazooka := false ;
91899: LD_ADDR_EXP 138
91903: PUSH
91904: LD_INT 0
91906: ST_TO_ADDR
// sMortar := false ;
91907: LD_ADDR_EXP 139
91911: PUSH
91912: LD_INT 0
91914: ST_TO_ADDR
// sRanger := false ;
91915: LD_ADDR_EXP 149
91919: PUSH
91920: LD_INT 0
91922: ST_TO_ADDR
// sComputer := false ;
91923: LD_ADDR_EXP 150
91927: PUSH
91928: LD_INT 0
91930: ST_TO_ADDR
// s30 := false ;
91931: LD_ADDR_EXP 151
91935: PUSH
91936: LD_INT 0
91938: ST_TO_ADDR
// s60 := false ;
91939: LD_ADDR_EXP 152
91943: PUSH
91944: LD_INT 0
91946: ST_TO_ADDR
// end ;
91947: LD_VAR 0 1
91951: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
91952: LD_INT 0
91954: PPUSH
91955: PPUSH
91956: PPUSH
91957: PPUSH
91958: PPUSH
91959: PPUSH
91960: PPUSH
// result := [ ] ;
91961: LD_ADDR_VAR 0 2
91965: PUSH
91966: EMPTY
91967: ST_TO_ADDR
// if campaign_id = 1 then
91968: LD_OWVAR 69
91972: PUSH
91973: LD_INT 1
91975: EQUAL
91976: IFFALSE 95142
// begin case mission_number of 1 :
91978: LD_OWVAR 70
91982: PUSH
91983: LD_INT 1
91985: DOUBLE
91986: EQUAL
91987: IFTRUE 91991
91989: GO 92067
91991: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
91992: LD_ADDR_VAR 0 2
91996: PUSH
91997: LD_INT 2
91999: PUSH
92000: LD_INT 4
92002: PUSH
92003: LD_INT 11
92005: PUSH
92006: LD_INT 12
92008: PUSH
92009: LD_INT 15
92011: PUSH
92012: LD_INT 16
92014: PUSH
92015: LD_INT 22
92017: PUSH
92018: LD_INT 23
92020: PUSH
92021: LD_INT 26
92023: PUSH
92024: EMPTY
92025: LIST
92026: LIST
92027: LIST
92028: LIST
92029: LIST
92030: LIST
92031: LIST
92032: LIST
92033: LIST
92034: PUSH
92035: LD_INT 101
92037: PUSH
92038: LD_INT 102
92040: PUSH
92041: LD_INT 106
92043: PUSH
92044: LD_INT 116
92046: PUSH
92047: LD_INT 117
92049: PUSH
92050: LD_INT 118
92052: PUSH
92053: EMPTY
92054: LIST
92055: LIST
92056: LIST
92057: LIST
92058: LIST
92059: LIST
92060: PUSH
92061: EMPTY
92062: LIST
92063: LIST
92064: ST_TO_ADDR
92065: GO 95140
92067: LD_INT 2
92069: DOUBLE
92070: EQUAL
92071: IFTRUE 92075
92073: GO 92159
92075: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
92076: LD_ADDR_VAR 0 2
92080: PUSH
92081: LD_INT 2
92083: PUSH
92084: LD_INT 4
92086: PUSH
92087: LD_INT 11
92089: PUSH
92090: LD_INT 12
92092: PUSH
92093: LD_INT 15
92095: PUSH
92096: LD_INT 16
92098: PUSH
92099: LD_INT 22
92101: PUSH
92102: LD_INT 23
92104: PUSH
92105: LD_INT 26
92107: PUSH
92108: EMPTY
92109: LIST
92110: LIST
92111: LIST
92112: LIST
92113: LIST
92114: LIST
92115: LIST
92116: LIST
92117: LIST
92118: PUSH
92119: LD_INT 101
92121: PUSH
92122: LD_INT 102
92124: PUSH
92125: LD_INT 105
92127: PUSH
92128: LD_INT 106
92130: PUSH
92131: LD_INT 108
92133: PUSH
92134: LD_INT 116
92136: PUSH
92137: LD_INT 117
92139: PUSH
92140: LD_INT 118
92142: PUSH
92143: EMPTY
92144: LIST
92145: LIST
92146: LIST
92147: LIST
92148: LIST
92149: LIST
92150: LIST
92151: LIST
92152: PUSH
92153: EMPTY
92154: LIST
92155: LIST
92156: ST_TO_ADDR
92157: GO 95140
92159: LD_INT 3
92161: DOUBLE
92162: EQUAL
92163: IFTRUE 92167
92165: GO 92255
92167: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
92168: LD_ADDR_VAR 0 2
92172: PUSH
92173: LD_INT 2
92175: PUSH
92176: LD_INT 4
92178: PUSH
92179: LD_INT 5
92181: PUSH
92182: LD_INT 11
92184: PUSH
92185: LD_INT 12
92187: PUSH
92188: LD_INT 15
92190: PUSH
92191: LD_INT 16
92193: PUSH
92194: LD_INT 22
92196: PUSH
92197: LD_INT 26
92199: PUSH
92200: LD_INT 36
92202: PUSH
92203: EMPTY
92204: LIST
92205: LIST
92206: LIST
92207: LIST
92208: LIST
92209: LIST
92210: LIST
92211: LIST
92212: LIST
92213: LIST
92214: PUSH
92215: LD_INT 101
92217: PUSH
92218: LD_INT 102
92220: PUSH
92221: LD_INT 105
92223: PUSH
92224: LD_INT 106
92226: PUSH
92227: LD_INT 108
92229: PUSH
92230: LD_INT 116
92232: PUSH
92233: LD_INT 117
92235: PUSH
92236: LD_INT 118
92238: PUSH
92239: EMPTY
92240: LIST
92241: LIST
92242: LIST
92243: LIST
92244: LIST
92245: LIST
92246: LIST
92247: LIST
92248: PUSH
92249: EMPTY
92250: LIST
92251: LIST
92252: ST_TO_ADDR
92253: GO 95140
92255: LD_INT 4
92257: DOUBLE
92258: EQUAL
92259: IFTRUE 92263
92261: GO 92359
92263: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
92264: LD_ADDR_VAR 0 2
92268: PUSH
92269: LD_INT 2
92271: PUSH
92272: LD_INT 4
92274: PUSH
92275: LD_INT 5
92277: PUSH
92278: LD_INT 8
92280: PUSH
92281: LD_INT 11
92283: PUSH
92284: LD_INT 12
92286: PUSH
92287: LD_INT 15
92289: PUSH
92290: LD_INT 16
92292: PUSH
92293: LD_INT 22
92295: PUSH
92296: LD_INT 23
92298: PUSH
92299: LD_INT 26
92301: PUSH
92302: LD_INT 36
92304: PUSH
92305: EMPTY
92306: LIST
92307: LIST
92308: LIST
92309: LIST
92310: LIST
92311: LIST
92312: LIST
92313: LIST
92314: LIST
92315: LIST
92316: LIST
92317: LIST
92318: PUSH
92319: LD_INT 101
92321: PUSH
92322: LD_INT 102
92324: PUSH
92325: LD_INT 105
92327: PUSH
92328: LD_INT 106
92330: PUSH
92331: LD_INT 108
92333: PUSH
92334: LD_INT 116
92336: PUSH
92337: LD_INT 117
92339: PUSH
92340: LD_INT 118
92342: PUSH
92343: EMPTY
92344: LIST
92345: LIST
92346: LIST
92347: LIST
92348: LIST
92349: LIST
92350: LIST
92351: LIST
92352: PUSH
92353: EMPTY
92354: LIST
92355: LIST
92356: ST_TO_ADDR
92357: GO 95140
92359: LD_INT 5
92361: DOUBLE
92362: EQUAL
92363: IFTRUE 92367
92365: GO 92479
92367: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
92368: LD_ADDR_VAR 0 2
92372: PUSH
92373: LD_INT 2
92375: PUSH
92376: LD_INT 4
92378: PUSH
92379: LD_INT 5
92381: PUSH
92382: LD_INT 6
92384: PUSH
92385: LD_INT 8
92387: PUSH
92388: LD_INT 11
92390: PUSH
92391: LD_INT 12
92393: PUSH
92394: LD_INT 15
92396: PUSH
92397: LD_INT 16
92399: PUSH
92400: LD_INT 22
92402: PUSH
92403: LD_INT 23
92405: PUSH
92406: LD_INT 25
92408: PUSH
92409: LD_INT 26
92411: PUSH
92412: LD_INT 36
92414: PUSH
92415: EMPTY
92416: LIST
92417: LIST
92418: LIST
92419: LIST
92420: LIST
92421: LIST
92422: LIST
92423: LIST
92424: LIST
92425: LIST
92426: LIST
92427: LIST
92428: LIST
92429: LIST
92430: PUSH
92431: LD_INT 101
92433: PUSH
92434: LD_INT 102
92436: PUSH
92437: LD_INT 105
92439: PUSH
92440: LD_INT 106
92442: PUSH
92443: LD_INT 108
92445: PUSH
92446: LD_INT 109
92448: PUSH
92449: LD_INT 112
92451: PUSH
92452: LD_INT 116
92454: PUSH
92455: LD_INT 117
92457: PUSH
92458: LD_INT 118
92460: PUSH
92461: EMPTY
92462: LIST
92463: LIST
92464: LIST
92465: LIST
92466: LIST
92467: LIST
92468: LIST
92469: LIST
92470: LIST
92471: LIST
92472: PUSH
92473: EMPTY
92474: LIST
92475: LIST
92476: ST_TO_ADDR
92477: GO 95140
92479: LD_INT 6
92481: DOUBLE
92482: EQUAL
92483: IFTRUE 92487
92485: GO 92619
92487: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
92488: LD_ADDR_VAR 0 2
92492: PUSH
92493: LD_INT 2
92495: PUSH
92496: LD_INT 4
92498: PUSH
92499: LD_INT 5
92501: PUSH
92502: LD_INT 6
92504: PUSH
92505: LD_INT 8
92507: PUSH
92508: LD_INT 11
92510: PUSH
92511: LD_INT 12
92513: PUSH
92514: LD_INT 15
92516: PUSH
92517: LD_INT 16
92519: PUSH
92520: LD_INT 20
92522: PUSH
92523: LD_INT 21
92525: PUSH
92526: LD_INT 22
92528: PUSH
92529: LD_INT 23
92531: PUSH
92532: LD_INT 25
92534: PUSH
92535: LD_INT 26
92537: PUSH
92538: LD_INT 30
92540: PUSH
92541: LD_INT 31
92543: PUSH
92544: LD_INT 32
92546: PUSH
92547: LD_INT 36
92549: PUSH
92550: EMPTY
92551: LIST
92552: LIST
92553: LIST
92554: LIST
92555: LIST
92556: LIST
92557: LIST
92558: LIST
92559: LIST
92560: LIST
92561: LIST
92562: LIST
92563: LIST
92564: LIST
92565: LIST
92566: LIST
92567: LIST
92568: LIST
92569: LIST
92570: PUSH
92571: LD_INT 101
92573: PUSH
92574: LD_INT 102
92576: PUSH
92577: LD_INT 105
92579: PUSH
92580: LD_INT 106
92582: PUSH
92583: LD_INT 108
92585: PUSH
92586: LD_INT 109
92588: PUSH
92589: LD_INT 112
92591: PUSH
92592: LD_INT 116
92594: PUSH
92595: LD_INT 117
92597: PUSH
92598: LD_INT 118
92600: PUSH
92601: EMPTY
92602: LIST
92603: LIST
92604: LIST
92605: LIST
92606: LIST
92607: LIST
92608: LIST
92609: LIST
92610: LIST
92611: LIST
92612: PUSH
92613: EMPTY
92614: LIST
92615: LIST
92616: ST_TO_ADDR
92617: GO 95140
92619: LD_INT 7
92621: DOUBLE
92622: EQUAL
92623: IFTRUE 92627
92625: GO 92739
92627: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
92628: LD_ADDR_VAR 0 2
92632: PUSH
92633: LD_INT 2
92635: PUSH
92636: LD_INT 4
92638: PUSH
92639: LD_INT 5
92641: PUSH
92642: LD_INT 7
92644: PUSH
92645: LD_INT 11
92647: PUSH
92648: LD_INT 12
92650: PUSH
92651: LD_INT 15
92653: PUSH
92654: LD_INT 16
92656: PUSH
92657: LD_INT 20
92659: PUSH
92660: LD_INT 21
92662: PUSH
92663: LD_INT 22
92665: PUSH
92666: LD_INT 23
92668: PUSH
92669: LD_INT 25
92671: PUSH
92672: LD_INT 26
92674: PUSH
92675: EMPTY
92676: LIST
92677: LIST
92678: LIST
92679: LIST
92680: LIST
92681: LIST
92682: LIST
92683: LIST
92684: LIST
92685: LIST
92686: LIST
92687: LIST
92688: LIST
92689: LIST
92690: PUSH
92691: LD_INT 101
92693: PUSH
92694: LD_INT 102
92696: PUSH
92697: LD_INT 103
92699: PUSH
92700: LD_INT 105
92702: PUSH
92703: LD_INT 106
92705: PUSH
92706: LD_INT 108
92708: PUSH
92709: LD_INT 112
92711: PUSH
92712: LD_INT 116
92714: PUSH
92715: LD_INT 117
92717: PUSH
92718: LD_INT 118
92720: PUSH
92721: EMPTY
92722: LIST
92723: LIST
92724: LIST
92725: LIST
92726: LIST
92727: LIST
92728: LIST
92729: LIST
92730: LIST
92731: LIST
92732: PUSH
92733: EMPTY
92734: LIST
92735: LIST
92736: ST_TO_ADDR
92737: GO 95140
92739: LD_INT 8
92741: DOUBLE
92742: EQUAL
92743: IFTRUE 92747
92745: GO 92887
92747: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
92748: LD_ADDR_VAR 0 2
92752: PUSH
92753: LD_INT 2
92755: PUSH
92756: LD_INT 4
92758: PUSH
92759: LD_INT 5
92761: PUSH
92762: LD_INT 6
92764: PUSH
92765: LD_INT 7
92767: PUSH
92768: LD_INT 8
92770: PUSH
92771: LD_INT 11
92773: PUSH
92774: LD_INT 12
92776: PUSH
92777: LD_INT 15
92779: PUSH
92780: LD_INT 16
92782: PUSH
92783: LD_INT 20
92785: PUSH
92786: LD_INT 21
92788: PUSH
92789: LD_INT 22
92791: PUSH
92792: LD_INT 23
92794: PUSH
92795: LD_INT 25
92797: PUSH
92798: LD_INT 26
92800: PUSH
92801: LD_INT 30
92803: PUSH
92804: LD_INT 31
92806: PUSH
92807: LD_INT 32
92809: PUSH
92810: LD_INT 36
92812: PUSH
92813: EMPTY
92814: LIST
92815: LIST
92816: LIST
92817: LIST
92818: LIST
92819: LIST
92820: LIST
92821: LIST
92822: LIST
92823: LIST
92824: LIST
92825: LIST
92826: LIST
92827: LIST
92828: LIST
92829: LIST
92830: LIST
92831: LIST
92832: LIST
92833: LIST
92834: PUSH
92835: LD_INT 101
92837: PUSH
92838: LD_INT 102
92840: PUSH
92841: LD_INT 103
92843: PUSH
92844: LD_INT 105
92846: PUSH
92847: LD_INT 106
92849: PUSH
92850: LD_INT 108
92852: PUSH
92853: LD_INT 109
92855: PUSH
92856: LD_INT 112
92858: PUSH
92859: LD_INT 116
92861: PUSH
92862: LD_INT 117
92864: PUSH
92865: LD_INT 118
92867: PUSH
92868: EMPTY
92869: LIST
92870: LIST
92871: LIST
92872: LIST
92873: LIST
92874: LIST
92875: LIST
92876: LIST
92877: LIST
92878: LIST
92879: LIST
92880: PUSH
92881: EMPTY
92882: LIST
92883: LIST
92884: ST_TO_ADDR
92885: GO 95140
92887: LD_INT 9
92889: DOUBLE
92890: EQUAL
92891: IFTRUE 92895
92893: GO 93043
92895: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
92896: LD_ADDR_VAR 0 2
92900: PUSH
92901: LD_INT 2
92903: PUSH
92904: LD_INT 4
92906: PUSH
92907: LD_INT 5
92909: PUSH
92910: LD_INT 6
92912: PUSH
92913: LD_INT 7
92915: PUSH
92916: LD_INT 8
92918: PUSH
92919: LD_INT 11
92921: PUSH
92922: LD_INT 12
92924: PUSH
92925: LD_INT 15
92927: PUSH
92928: LD_INT 16
92930: PUSH
92931: LD_INT 20
92933: PUSH
92934: LD_INT 21
92936: PUSH
92937: LD_INT 22
92939: PUSH
92940: LD_INT 23
92942: PUSH
92943: LD_INT 25
92945: PUSH
92946: LD_INT 26
92948: PUSH
92949: LD_INT 28
92951: PUSH
92952: LD_INT 30
92954: PUSH
92955: LD_INT 31
92957: PUSH
92958: LD_INT 32
92960: PUSH
92961: LD_INT 36
92963: PUSH
92964: EMPTY
92965: LIST
92966: LIST
92967: LIST
92968: LIST
92969: LIST
92970: LIST
92971: LIST
92972: LIST
92973: LIST
92974: LIST
92975: LIST
92976: LIST
92977: LIST
92978: LIST
92979: LIST
92980: LIST
92981: LIST
92982: LIST
92983: LIST
92984: LIST
92985: LIST
92986: PUSH
92987: LD_INT 101
92989: PUSH
92990: LD_INT 102
92992: PUSH
92993: LD_INT 103
92995: PUSH
92996: LD_INT 105
92998: PUSH
92999: LD_INT 106
93001: PUSH
93002: LD_INT 108
93004: PUSH
93005: LD_INT 109
93007: PUSH
93008: LD_INT 112
93010: PUSH
93011: LD_INT 114
93013: PUSH
93014: LD_INT 116
93016: PUSH
93017: LD_INT 117
93019: PUSH
93020: LD_INT 118
93022: PUSH
93023: EMPTY
93024: LIST
93025: LIST
93026: LIST
93027: LIST
93028: LIST
93029: LIST
93030: LIST
93031: LIST
93032: LIST
93033: LIST
93034: LIST
93035: LIST
93036: PUSH
93037: EMPTY
93038: LIST
93039: LIST
93040: ST_TO_ADDR
93041: GO 95140
93043: LD_INT 10
93045: DOUBLE
93046: EQUAL
93047: IFTRUE 93051
93049: GO 93247
93051: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
93052: LD_ADDR_VAR 0 2
93056: PUSH
93057: LD_INT 2
93059: PUSH
93060: LD_INT 4
93062: PUSH
93063: LD_INT 5
93065: PUSH
93066: LD_INT 6
93068: PUSH
93069: LD_INT 7
93071: PUSH
93072: LD_INT 8
93074: PUSH
93075: LD_INT 9
93077: PUSH
93078: LD_INT 10
93080: PUSH
93081: LD_INT 11
93083: PUSH
93084: LD_INT 12
93086: PUSH
93087: LD_INT 13
93089: PUSH
93090: LD_INT 14
93092: PUSH
93093: LD_INT 15
93095: PUSH
93096: LD_INT 16
93098: PUSH
93099: LD_INT 17
93101: PUSH
93102: LD_INT 18
93104: PUSH
93105: LD_INT 19
93107: PUSH
93108: LD_INT 20
93110: PUSH
93111: LD_INT 21
93113: PUSH
93114: LD_INT 22
93116: PUSH
93117: LD_INT 23
93119: PUSH
93120: LD_INT 24
93122: PUSH
93123: LD_INT 25
93125: PUSH
93126: LD_INT 26
93128: PUSH
93129: LD_INT 28
93131: PUSH
93132: LD_INT 30
93134: PUSH
93135: LD_INT 31
93137: PUSH
93138: LD_INT 32
93140: PUSH
93141: LD_INT 36
93143: PUSH
93144: EMPTY
93145: LIST
93146: LIST
93147: LIST
93148: LIST
93149: LIST
93150: LIST
93151: LIST
93152: LIST
93153: LIST
93154: LIST
93155: LIST
93156: LIST
93157: LIST
93158: LIST
93159: LIST
93160: LIST
93161: LIST
93162: LIST
93163: LIST
93164: LIST
93165: LIST
93166: LIST
93167: LIST
93168: LIST
93169: LIST
93170: LIST
93171: LIST
93172: LIST
93173: LIST
93174: PUSH
93175: LD_INT 101
93177: PUSH
93178: LD_INT 102
93180: PUSH
93181: LD_INT 103
93183: PUSH
93184: LD_INT 104
93186: PUSH
93187: LD_INT 105
93189: PUSH
93190: LD_INT 106
93192: PUSH
93193: LD_INT 107
93195: PUSH
93196: LD_INT 108
93198: PUSH
93199: LD_INT 109
93201: PUSH
93202: LD_INT 110
93204: PUSH
93205: LD_INT 111
93207: PUSH
93208: LD_INT 112
93210: PUSH
93211: LD_INT 114
93213: PUSH
93214: LD_INT 116
93216: PUSH
93217: LD_INT 117
93219: PUSH
93220: LD_INT 118
93222: PUSH
93223: EMPTY
93224: LIST
93225: LIST
93226: LIST
93227: LIST
93228: LIST
93229: LIST
93230: LIST
93231: LIST
93232: LIST
93233: LIST
93234: LIST
93235: LIST
93236: LIST
93237: LIST
93238: LIST
93239: LIST
93240: PUSH
93241: EMPTY
93242: LIST
93243: LIST
93244: ST_TO_ADDR
93245: GO 95140
93247: LD_INT 11
93249: DOUBLE
93250: EQUAL
93251: IFTRUE 93255
93253: GO 93459
93255: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
93256: LD_ADDR_VAR 0 2
93260: PUSH
93261: LD_INT 2
93263: PUSH
93264: LD_INT 3
93266: PUSH
93267: LD_INT 4
93269: PUSH
93270: LD_INT 5
93272: PUSH
93273: LD_INT 6
93275: PUSH
93276: LD_INT 7
93278: PUSH
93279: LD_INT 8
93281: PUSH
93282: LD_INT 9
93284: PUSH
93285: LD_INT 10
93287: PUSH
93288: LD_INT 11
93290: PUSH
93291: LD_INT 12
93293: PUSH
93294: LD_INT 13
93296: PUSH
93297: LD_INT 14
93299: PUSH
93300: LD_INT 15
93302: PUSH
93303: LD_INT 16
93305: PUSH
93306: LD_INT 17
93308: PUSH
93309: LD_INT 18
93311: PUSH
93312: LD_INT 19
93314: PUSH
93315: LD_INT 20
93317: PUSH
93318: LD_INT 21
93320: PUSH
93321: LD_INT 22
93323: PUSH
93324: LD_INT 23
93326: PUSH
93327: LD_INT 24
93329: PUSH
93330: LD_INT 25
93332: PUSH
93333: LD_INT 26
93335: PUSH
93336: LD_INT 28
93338: PUSH
93339: LD_INT 30
93341: PUSH
93342: LD_INT 31
93344: PUSH
93345: LD_INT 32
93347: PUSH
93348: LD_INT 34
93350: PUSH
93351: LD_INT 36
93353: PUSH
93354: EMPTY
93355: LIST
93356: LIST
93357: LIST
93358: LIST
93359: LIST
93360: LIST
93361: LIST
93362: LIST
93363: LIST
93364: LIST
93365: LIST
93366: LIST
93367: LIST
93368: LIST
93369: LIST
93370: LIST
93371: LIST
93372: LIST
93373: LIST
93374: LIST
93375: LIST
93376: LIST
93377: LIST
93378: LIST
93379: LIST
93380: LIST
93381: LIST
93382: LIST
93383: LIST
93384: LIST
93385: LIST
93386: PUSH
93387: LD_INT 101
93389: PUSH
93390: LD_INT 102
93392: PUSH
93393: LD_INT 103
93395: PUSH
93396: LD_INT 104
93398: PUSH
93399: LD_INT 105
93401: PUSH
93402: LD_INT 106
93404: PUSH
93405: LD_INT 107
93407: PUSH
93408: LD_INT 108
93410: PUSH
93411: LD_INT 109
93413: PUSH
93414: LD_INT 110
93416: PUSH
93417: LD_INT 111
93419: PUSH
93420: LD_INT 112
93422: PUSH
93423: LD_INT 114
93425: PUSH
93426: LD_INT 116
93428: PUSH
93429: LD_INT 117
93431: PUSH
93432: LD_INT 118
93434: PUSH
93435: EMPTY
93436: LIST
93437: LIST
93438: LIST
93439: LIST
93440: LIST
93441: LIST
93442: LIST
93443: LIST
93444: LIST
93445: LIST
93446: LIST
93447: LIST
93448: LIST
93449: LIST
93450: LIST
93451: LIST
93452: PUSH
93453: EMPTY
93454: LIST
93455: LIST
93456: ST_TO_ADDR
93457: GO 95140
93459: LD_INT 12
93461: DOUBLE
93462: EQUAL
93463: IFTRUE 93467
93465: GO 93687
93467: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
93468: LD_ADDR_VAR 0 2
93472: PUSH
93473: LD_INT 1
93475: PUSH
93476: LD_INT 2
93478: PUSH
93479: LD_INT 3
93481: PUSH
93482: LD_INT 4
93484: PUSH
93485: LD_INT 5
93487: PUSH
93488: LD_INT 6
93490: PUSH
93491: LD_INT 7
93493: PUSH
93494: LD_INT 8
93496: PUSH
93497: LD_INT 9
93499: PUSH
93500: LD_INT 10
93502: PUSH
93503: LD_INT 11
93505: PUSH
93506: LD_INT 12
93508: PUSH
93509: LD_INT 13
93511: PUSH
93512: LD_INT 14
93514: PUSH
93515: LD_INT 15
93517: PUSH
93518: LD_INT 16
93520: PUSH
93521: LD_INT 17
93523: PUSH
93524: LD_INT 18
93526: PUSH
93527: LD_INT 19
93529: PUSH
93530: LD_INT 20
93532: PUSH
93533: LD_INT 21
93535: PUSH
93536: LD_INT 22
93538: PUSH
93539: LD_INT 23
93541: PUSH
93542: LD_INT 24
93544: PUSH
93545: LD_INT 25
93547: PUSH
93548: LD_INT 26
93550: PUSH
93551: LD_INT 27
93553: PUSH
93554: LD_INT 28
93556: PUSH
93557: LD_INT 30
93559: PUSH
93560: LD_INT 31
93562: PUSH
93563: LD_INT 32
93565: PUSH
93566: LD_INT 33
93568: PUSH
93569: LD_INT 34
93571: PUSH
93572: LD_INT 36
93574: PUSH
93575: EMPTY
93576: LIST
93577: LIST
93578: LIST
93579: LIST
93580: LIST
93581: LIST
93582: LIST
93583: LIST
93584: LIST
93585: LIST
93586: LIST
93587: LIST
93588: LIST
93589: LIST
93590: LIST
93591: LIST
93592: LIST
93593: LIST
93594: LIST
93595: LIST
93596: LIST
93597: LIST
93598: LIST
93599: LIST
93600: LIST
93601: LIST
93602: LIST
93603: LIST
93604: LIST
93605: LIST
93606: LIST
93607: LIST
93608: LIST
93609: LIST
93610: PUSH
93611: LD_INT 101
93613: PUSH
93614: LD_INT 102
93616: PUSH
93617: LD_INT 103
93619: PUSH
93620: LD_INT 104
93622: PUSH
93623: LD_INT 105
93625: PUSH
93626: LD_INT 106
93628: PUSH
93629: LD_INT 107
93631: PUSH
93632: LD_INT 108
93634: PUSH
93635: LD_INT 109
93637: PUSH
93638: LD_INT 110
93640: PUSH
93641: LD_INT 111
93643: PUSH
93644: LD_INT 112
93646: PUSH
93647: LD_INT 113
93649: PUSH
93650: LD_INT 114
93652: PUSH
93653: LD_INT 116
93655: PUSH
93656: LD_INT 117
93658: PUSH
93659: LD_INT 118
93661: PUSH
93662: EMPTY
93663: LIST
93664: LIST
93665: LIST
93666: LIST
93667: LIST
93668: LIST
93669: LIST
93670: LIST
93671: LIST
93672: LIST
93673: LIST
93674: LIST
93675: LIST
93676: LIST
93677: LIST
93678: LIST
93679: LIST
93680: PUSH
93681: EMPTY
93682: LIST
93683: LIST
93684: ST_TO_ADDR
93685: GO 95140
93687: LD_INT 13
93689: DOUBLE
93690: EQUAL
93691: IFTRUE 93695
93693: GO 93903
93695: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
93696: LD_ADDR_VAR 0 2
93700: PUSH
93701: LD_INT 1
93703: PUSH
93704: LD_INT 2
93706: PUSH
93707: LD_INT 3
93709: PUSH
93710: LD_INT 4
93712: PUSH
93713: LD_INT 5
93715: PUSH
93716: LD_INT 8
93718: PUSH
93719: LD_INT 9
93721: PUSH
93722: LD_INT 10
93724: PUSH
93725: LD_INT 11
93727: PUSH
93728: LD_INT 12
93730: PUSH
93731: LD_INT 14
93733: PUSH
93734: LD_INT 15
93736: PUSH
93737: LD_INT 16
93739: PUSH
93740: LD_INT 17
93742: PUSH
93743: LD_INT 18
93745: PUSH
93746: LD_INT 19
93748: PUSH
93749: LD_INT 20
93751: PUSH
93752: LD_INT 21
93754: PUSH
93755: LD_INT 22
93757: PUSH
93758: LD_INT 23
93760: PUSH
93761: LD_INT 24
93763: PUSH
93764: LD_INT 25
93766: PUSH
93767: LD_INT 26
93769: PUSH
93770: LD_INT 27
93772: PUSH
93773: LD_INT 28
93775: PUSH
93776: LD_INT 30
93778: PUSH
93779: LD_INT 31
93781: PUSH
93782: LD_INT 32
93784: PUSH
93785: LD_INT 33
93787: PUSH
93788: LD_INT 34
93790: PUSH
93791: LD_INT 36
93793: PUSH
93794: EMPTY
93795: LIST
93796: LIST
93797: LIST
93798: LIST
93799: LIST
93800: LIST
93801: LIST
93802: LIST
93803: LIST
93804: LIST
93805: LIST
93806: LIST
93807: LIST
93808: LIST
93809: LIST
93810: LIST
93811: LIST
93812: LIST
93813: LIST
93814: LIST
93815: LIST
93816: LIST
93817: LIST
93818: LIST
93819: LIST
93820: LIST
93821: LIST
93822: LIST
93823: LIST
93824: LIST
93825: LIST
93826: PUSH
93827: LD_INT 101
93829: PUSH
93830: LD_INT 102
93832: PUSH
93833: LD_INT 103
93835: PUSH
93836: LD_INT 104
93838: PUSH
93839: LD_INT 105
93841: PUSH
93842: LD_INT 106
93844: PUSH
93845: LD_INT 107
93847: PUSH
93848: LD_INT 108
93850: PUSH
93851: LD_INT 109
93853: PUSH
93854: LD_INT 110
93856: PUSH
93857: LD_INT 111
93859: PUSH
93860: LD_INT 112
93862: PUSH
93863: LD_INT 113
93865: PUSH
93866: LD_INT 114
93868: PUSH
93869: LD_INT 116
93871: PUSH
93872: LD_INT 117
93874: PUSH
93875: LD_INT 118
93877: PUSH
93878: EMPTY
93879: LIST
93880: LIST
93881: LIST
93882: LIST
93883: LIST
93884: LIST
93885: LIST
93886: LIST
93887: LIST
93888: LIST
93889: LIST
93890: LIST
93891: LIST
93892: LIST
93893: LIST
93894: LIST
93895: LIST
93896: PUSH
93897: EMPTY
93898: LIST
93899: LIST
93900: ST_TO_ADDR
93901: GO 95140
93903: LD_INT 14
93905: DOUBLE
93906: EQUAL
93907: IFTRUE 93911
93909: GO 94135
93911: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
93912: LD_ADDR_VAR 0 2
93916: PUSH
93917: LD_INT 1
93919: PUSH
93920: LD_INT 2
93922: PUSH
93923: LD_INT 3
93925: PUSH
93926: LD_INT 4
93928: PUSH
93929: LD_INT 5
93931: PUSH
93932: LD_INT 6
93934: PUSH
93935: LD_INT 7
93937: PUSH
93938: LD_INT 8
93940: PUSH
93941: LD_INT 9
93943: PUSH
93944: LD_INT 10
93946: PUSH
93947: LD_INT 11
93949: PUSH
93950: LD_INT 12
93952: PUSH
93953: LD_INT 13
93955: PUSH
93956: LD_INT 14
93958: PUSH
93959: LD_INT 15
93961: PUSH
93962: LD_INT 16
93964: PUSH
93965: LD_INT 17
93967: PUSH
93968: LD_INT 18
93970: PUSH
93971: LD_INT 19
93973: PUSH
93974: LD_INT 20
93976: PUSH
93977: LD_INT 21
93979: PUSH
93980: LD_INT 22
93982: PUSH
93983: LD_INT 23
93985: PUSH
93986: LD_INT 24
93988: PUSH
93989: LD_INT 25
93991: PUSH
93992: LD_INT 26
93994: PUSH
93995: LD_INT 27
93997: PUSH
93998: LD_INT 28
94000: PUSH
94001: LD_INT 29
94003: PUSH
94004: LD_INT 30
94006: PUSH
94007: LD_INT 31
94009: PUSH
94010: LD_INT 32
94012: PUSH
94013: LD_INT 33
94015: PUSH
94016: LD_INT 34
94018: PUSH
94019: LD_INT 36
94021: PUSH
94022: EMPTY
94023: LIST
94024: LIST
94025: LIST
94026: LIST
94027: LIST
94028: LIST
94029: LIST
94030: LIST
94031: LIST
94032: LIST
94033: LIST
94034: LIST
94035: LIST
94036: LIST
94037: LIST
94038: LIST
94039: LIST
94040: LIST
94041: LIST
94042: LIST
94043: LIST
94044: LIST
94045: LIST
94046: LIST
94047: LIST
94048: LIST
94049: LIST
94050: LIST
94051: LIST
94052: LIST
94053: LIST
94054: LIST
94055: LIST
94056: LIST
94057: LIST
94058: PUSH
94059: LD_INT 101
94061: PUSH
94062: LD_INT 102
94064: PUSH
94065: LD_INT 103
94067: PUSH
94068: LD_INT 104
94070: PUSH
94071: LD_INT 105
94073: PUSH
94074: LD_INT 106
94076: PUSH
94077: LD_INT 107
94079: PUSH
94080: LD_INT 108
94082: PUSH
94083: LD_INT 109
94085: PUSH
94086: LD_INT 110
94088: PUSH
94089: LD_INT 111
94091: PUSH
94092: LD_INT 112
94094: PUSH
94095: LD_INT 113
94097: PUSH
94098: LD_INT 114
94100: PUSH
94101: LD_INT 116
94103: PUSH
94104: LD_INT 117
94106: PUSH
94107: LD_INT 118
94109: PUSH
94110: EMPTY
94111: LIST
94112: LIST
94113: LIST
94114: LIST
94115: LIST
94116: LIST
94117: LIST
94118: LIST
94119: LIST
94120: LIST
94121: LIST
94122: LIST
94123: LIST
94124: LIST
94125: LIST
94126: LIST
94127: LIST
94128: PUSH
94129: EMPTY
94130: LIST
94131: LIST
94132: ST_TO_ADDR
94133: GO 95140
94135: LD_INT 15
94137: DOUBLE
94138: EQUAL
94139: IFTRUE 94143
94141: GO 94367
94143: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
94144: LD_ADDR_VAR 0 2
94148: PUSH
94149: LD_INT 1
94151: PUSH
94152: LD_INT 2
94154: PUSH
94155: LD_INT 3
94157: PUSH
94158: LD_INT 4
94160: PUSH
94161: LD_INT 5
94163: PUSH
94164: LD_INT 6
94166: PUSH
94167: LD_INT 7
94169: PUSH
94170: LD_INT 8
94172: PUSH
94173: LD_INT 9
94175: PUSH
94176: LD_INT 10
94178: PUSH
94179: LD_INT 11
94181: PUSH
94182: LD_INT 12
94184: PUSH
94185: LD_INT 13
94187: PUSH
94188: LD_INT 14
94190: PUSH
94191: LD_INT 15
94193: PUSH
94194: LD_INT 16
94196: PUSH
94197: LD_INT 17
94199: PUSH
94200: LD_INT 18
94202: PUSH
94203: LD_INT 19
94205: PUSH
94206: LD_INT 20
94208: PUSH
94209: LD_INT 21
94211: PUSH
94212: LD_INT 22
94214: PUSH
94215: LD_INT 23
94217: PUSH
94218: LD_INT 24
94220: PUSH
94221: LD_INT 25
94223: PUSH
94224: LD_INT 26
94226: PUSH
94227: LD_INT 27
94229: PUSH
94230: LD_INT 28
94232: PUSH
94233: LD_INT 29
94235: PUSH
94236: LD_INT 30
94238: PUSH
94239: LD_INT 31
94241: PUSH
94242: LD_INT 32
94244: PUSH
94245: LD_INT 33
94247: PUSH
94248: LD_INT 34
94250: PUSH
94251: LD_INT 36
94253: PUSH
94254: EMPTY
94255: LIST
94256: LIST
94257: LIST
94258: LIST
94259: LIST
94260: LIST
94261: LIST
94262: LIST
94263: LIST
94264: LIST
94265: LIST
94266: LIST
94267: LIST
94268: LIST
94269: LIST
94270: LIST
94271: LIST
94272: LIST
94273: LIST
94274: LIST
94275: LIST
94276: LIST
94277: LIST
94278: LIST
94279: LIST
94280: LIST
94281: LIST
94282: LIST
94283: LIST
94284: LIST
94285: LIST
94286: LIST
94287: LIST
94288: LIST
94289: LIST
94290: PUSH
94291: LD_INT 101
94293: PUSH
94294: LD_INT 102
94296: PUSH
94297: LD_INT 103
94299: PUSH
94300: LD_INT 104
94302: PUSH
94303: LD_INT 105
94305: PUSH
94306: LD_INT 106
94308: PUSH
94309: LD_INT 107
94311: PUSH
94312: LD_INT 108
94314: PUSH
94315: LD_INT 109
94317: PUSH
94318: LD_INT 110
94320: PUSH
94321: LD_INT 111
94323: PUSH
94324: LD_INT 112
94326: PUSH
94327: LD_INT 113
94329: PUSH
94330: LD_INT 114
94332: PUSH
94333: LD_INT 116
94335: PUSH
94336: LD_INT 117
94338: PUSH
94339: LD_INT 118
94341: PUSH
94342: EMPTY
94343: LIST
94344: LIST
94345: LIST
94346: LIST
94347: LIST
94348: LIST
94349: LIST
94350: LIST
94351: LIST
94352: LIST
94353: LIST
94354: LIST
94355: LIST
94356: LIST
94357: LIST
94358: LIST
94359: LIST
94360: PUSH
94361: EMPTY
94362: LIST
94363: LIST
94364: ST_TO_ADDR
94365: GO 95140
94367: LD_INT 16
94369: DOUBLE
94370: EQUAL
94371: IFTRUE 94375
94373: GO 94511
94375: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
94376: LD_ADDR_VAR 0 2
94380: PUSH
94381: LD_INT 2
94383: PUSH
94384: LD_INT 4
94386: PUSH
94387: LD_INT 5
94389: PUSH
94390: LD_INT 7
94392: PUSH
94393: LD_INT 11
94395: PUSH
94396: LD_INT 12
94398: PUSH
94399: LD_INT 15
94401: PUSH
94402: LD_INT 16
94404: PUSH
94405: LD_INT 20
94407: PUSH
94408: LD_INT 21
94410: PUSH
94411: LD_INT 22
94413: PUSH
94414: LD_INT 23
94416: PUSH
94417: LD_INT 25
94419: PUSH
94420: LD_INT 26
94422: PUSH
94423: LD_INT 30
94425: PUSH
94426: LD_INT 31
94428: PUSH
94429: LD_INT 32
94431: PUSH
94432: LD_INT 33
94434: PUSH
94435: LD_INT 34
94437: PUSH
94438: EMPTY
94439: LIST
94440: LIST
94441: LIST
94442: LIST
94443: LIST
94444: LIST
94445: LIST
94446: LIST
94447: LIST
94448: LIST
94449: LIST
94450: LIST
94451: LIST
94452: LIST
94453: LIST
94454: LIST
94455: LIST
94456: LIST
94457: LIST
94458: PUSH
94459: LD_INT 101
94461: PUSH
94462: LD_INT 102
94464: PUSH
94465: LD_INT 103
94467: PUSH
94468: LD_INT 106
94470: PUSH
94471: LD_INT 108
94473: PUSH
94474: LD_INT 112
94476: PUSH
94477: LD_INT 113
94479: PUSH
94480: LD_INT 114
94482: PUSH
94483: LD_INT 116
94485: PUSH
94486: LD_INT 117
94488: PUSH
94489: LD_INT 118
94491: PUSH
94492: EMPTY
94493: LIST
94494: LIST
94495: LIST
94496: LIST
94497: LIST
94498: LIST
94499: LIST
94500: LIST
94501: LIST
94502: LIST
94503: LIST
94504: PUSH
94505: EMPTY
94506: LIST
94507: LIST
94508: ST_TO_ADDR
94509: GO 95140
94511: LD_INT 17
94513: DOUBLE
94514: EQUAL
94515: IFTRUE 94519
94517: GO 94743
94519: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
94520: LD_ADDR_VAR 0 2
94524: PUSH
94525: LD_INT 1
94527: PUSH
94528: LD_INT 2
94530: PUSH
94531: LD_INT 3
94533: PUSH
94534: LD_INT 4
94536: PUSH
94537: LD_INT 5
94539: PUSH
94540: LD_INT 6
94542: PUSH
94543: LD_INT 7
94545: PUSH
94546: LD_INT 8
94548: PUSH
94549: LD_INT 9
94551: PUSH
94552: LD_INT 10
94554: PUSH
94555: LD_INT 11
94557: PUSH
94558: LD_INT 12
94560: PUSH
94561: LD_INT 13
94563: PUSH
94564: LD_INT 14
94566: PUSH
94567: LD_INT 15
94569: PUSH
94570: LD_INT 16
94572: PUSH
94573: LD_INT 17
94575: PUSH
94576: LD_INT 18
94578: PUSH
94579: LD_INT 19
94581: PUSH
94582: LD_INT 20
94584: PUSH
94585: LD_INT 21
94587: PUSH
94588: LD_INT 22
94590: PUSH
94591: LD_INT 23
94593: PUSH
94594: LD_INT 24
94596: PUSH
94597: LD_INT 25
94599: PUSH
94600: LD_INT 26
94602: PUSH
94603: LD_INT 27
94605: PUSH
94606: LD_INT 28
94608: PUSH
94609: LD_INT 29
94611: PUSH
94612: LD_INT 30
94614: PUSH
94615: LD_INT 31
94617: PUSH
94618: LD_INT 32
94620: PUSH
94621: LD_INT 33
94623: PUSH
94624: LD_INT 34
94626: PUSH
94627: LD_INT 36
94629: PUSH
94630: EMPTY
94631: LIST
94632: LIST
94633: LIST
94634: LIST
94635: LIST
94636: LIST
94637: LIST
94638: LIST
94639: LIST
94640: LIST
94641: LIST
94642: LIST
94643: LIST
94644: LIST
94645: LIST
94646: LIST
94647: LIST
94648: LIST
94649: LIST
94650: LIST
94651: LIST
94652: LIST
94653: LIST
94654: LIST
94655: LIST
94656: LIST
94657: LIST
94658: LIST
94659: LIST
94660: LIST
94661: LIST
94662: LIST
94663: LIST
94664: LIST
94665: LIST
94666: PUSH
94667: LD_INT 101
94669: PUSH
94670: LD_INT 102
94672: PUSH
94673: LD_INT 103
94675: PUSH
94676: LD_INT 104
94678: PUSH
94679: LD_INT 105
94681: PUSH
94682: LD_INT 106
94684: PUSH
94685: LD_INT 107
94687: PUSH
94688: LD_INT 108
94690: PUSH
94691: LD_INT 109
94693: PUSH
94694: LD_INT 110
94696: PUSH
94697: LD_INT 111
94699: PUSH
94700: LD_INT 112
94702: PUSH
94703: LD_INT 113
94705: PUSH
94706: LD_INT 114
94708: PUSH
94709: LD_INT 116
94711: PUSH
94712: LD_INT 117
94714: PUSH
94715: LD_INT 118
94717: PUSH
94718: EMPTY
94719: LIST
94720: LIST
94721: LIST
94722: LIST
94723: LIST
94724: LIST
94725: LIST
94726: LIST
94727: LIST
94728: LIST
94729: LIST
94730: LIST
94731: LIST
94732: LIST
94733: LIST
94734: LIST
94735: LIST
94736: PUSH
94737: EMPTY
94738: LIST
94739: LIST
94740: ST_TO_ADDR
94741: GO 95140
94743: LD_INT 18
94745: DOUBLE
94746: EQUAL
94747: IFTRUE 94751
94749: GO 94899
94751: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
94752: LD_ADDR_VAR 0 2
94756: PUSH
94757: LD_INT 2
94759: PUSH
94760: LD_INT 4
94762: PUSH
94763: LD_INT 5
94765: PUSH
94766: LD_INT 7
94768: PUSH
94769: LD_INT 11
94771: PUSH
94772: LD_INT 12
94774: PUSH
94775: LD_INT 15
94777: PUSH
94778: LD_INT 16
94780: PUSH
94781: LD_INT 20
94783: PUSH
94784: LD_INT 21
94786: PUSH
94787: LD_INT 22
94789: PUSH
94790: LD_INT 23
94792: PUSH
94793: LD_INT 25
94795: PUSH
94796: LD_INT 26
94798: PUSH
94799: LD_INT 30
94801: PUSH
94802: LD_INT 31
94804: PUSH
94805: LD_INT 32
94807: PUSH
94808: LD_INT 33
94810: PUSH
94811: LD_INT 34
94813: PUSH
94814: LD_INT 35
94816: PUSH
94817: LD_INT 36
94819: PUSH
94820: EMPTY
94821: LIST
94822: LIST
94823: LIST
94824: LIST
94825: LIST
94826: LIST
94827: LIST
94828: LIST
94829: LIST
94830: LIST
94831: LIST
94832: LIST
94833: LIST
94834: LIST
94835: LIST
94836: LIST
94837: LIST
94838: LIST
94839: LIST
94840: LIST
94841: LIST
94842: PUSH
94843: LD_INT 101
94845: PUSH
94846: LD_INT 102
94848: PUSH
94849: LD_INT 103
94851: PUSH
94852: LD_INT 106
94854: PUSH
94855: LD_INT 108
94857: PUSH
94858: LD_INT 112
94860: PUSH
94861: LD_INT 113
94863: PUSH
94864: LD_INT 114
94866: PUSH
94867: LD_INT 115
94869: PUSH
94870: LD_INT 116
94872: PUSH
94873: LD_INT 117
94875: PUSH
94876: LD_INT 118
94878: PUSH
94879: EMPTY
94880: LIST
94881: LIST
94882: LIST
94883: LIST
94884: LIST
94885: LIST
94886: LIST
94887: LIST
94888: LIST
94889: LIST
94890: LIST
94891: LIST
94892: PUSH
94893: EMPTY
94894: LIST
94895: LIST
94896: ST_TO_ADDR
94897: GO 95140
94899: LD_INT 19
94901: DOUBLE
94902: EQUAL
94903: IFTRUE 94907
94905: GO 95139
94907: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
94908: LD_ADDR_VAR 0 2
94912: PUSH
94913: LD_INT 1
94915: PUSH
94916: LD_INT 2
94918: PUSH
94919: LD_INT 3
94921: PUSH
94922: LD_INT 4
94924: PUSH
94925: LD_INT 5
94927: PUSH
94928: LD_INT 6
94930: PUSH
94931: LD_INT 7
94933: PUSH
94934: LD_INT 8
94936: PUSH
94937: LD_INT 9
94939: PUSH
94940: LD_INT 10
94942: PUSH
94943: LD_INT 11
94945: PUSH
94946: LD_INT 12
94948: PUSH
94949: LD_INT 13
94951: PUSH
94952: LD_INT 14
94954: PUSH
94955: LD_INT 15
94957: PUSH
94958: LD_INT 16
94960: PUSH
94961: LD_INT 17
94963: PUSH
94964: LD_INT 18
94966: PUSH
94967: LD_INT 19
94969: PUSH
94970: LD_INT 20
94972: PUSH
94973: LD_INT 21
94975: PUSH
94976: LD_INT 22
94978: PUSH
94979: LD_INT 23
94981: PUSH
94982: LD_INT 24
94984: PUSH
94985: LD_INT 25
94987: PUSH
94988: LD_INT 26
94990: PUSH
94991: LD_INT 27
94993: PUSH
94994: LD_INT 28
94996: PUSH
94997: LD_INT 29
94999: PUSH
95000: LD_INT 30
95002: PUSH
95003: LD_INT 31
95005: PUSH
95006: LD_INT 32
95008: PUSH
95009: LD_INT 33
95011: PUSH
95012: LD_INT 34
95014: PUSH
95015: LD_INT 35
95017: PUSH
95018: LD_INT 36
95020: PUSH
95021: EMPTY
95022: LIST
95023: LIST
95024: LIST
95025: LIST
95026: LIST
95027: LIST
95028: LIST
95029: LIST
95030: LIST
95031: LIST
95032: LIST
95033: LIST
95034: LIST
95035: LIST
95036: LIST
95037: LIST
95038: LIST
95039: LIST
95040: LIST
95041: LIST
95042: LIST
95043: LIST
95044: LIST
95045: LIST
95046: LIST
95047: LIST
95048: LIST
95049: LIST
95050: LIST
95051: LIST
95052: LIST
95053: LIST
95054: LIST
95055: LIST
95056: LIST
95057: LIST
95058: PUSH
95059: LD_INT 101
95061: PUSH
95062: LD_INT 102
95064: PUSH
95065: LD_INT 103
95067: PUSH
95068: LD_INT 104
95070: PUSH
95071: LD_INT 105
95073: PUSH
95074: LD_INT 106
95076: PUSH
95077: LD_INT 107
95079: PUSH
95080: LD_INT 108
95082: PUSH
95083: LD_INT 109
95085: PUSH
95086: LD_INT 110
95088: PUSH
95089: LD_INT 111
95091: PUSH
95092: LD_INT 112
95094: PUSH
95095: LD_INT 113
95097: PUSH
95098: LD_INT 114
95100: PUSH
95101: LD_INT 115
95103: PUSH
95104: LD_INT 116
95106: PUSH
95107: LD_INT 117
95109: PUSH
95110: LD_INT 118
95112: PUSH
95113: EMPTY
95114: LIST
95115: LIST
95116: LIST
95117: LIST
95118: LIST
95119: LIST
95120: LIST
95121: LIST
95122: LIST
95123: LIST
95124: LIST
95125: LIST
95126: LIST
95127: LIST
95128: LIST
95129: LIST
95130: LIST
95131: LIST
95132: PUSH
95133: EMPTY
95134: LIST
95135: LIST
95136: ST_TO_ADDR
95137: GO 95140
95139: POP
// end else
95140: GO 95371
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
95142: LD_ADDR_VAR 0 2
95146: PUSH
95147: LD_INT 1
95149: PUSH
95150: LD_INT 2
95152: PUSH
95153: LD_INT 3
95155: PUSH
95156: LD_INT 4
95158: PUSH
95159: LD_INT 5
95161: PUSH
95162: LD_INT 6
95164: PUSH
95165: LD_INT 7
95167: PUSH
95168: LD_INT 8
95170: PUSH
95171: LD_INT 9
95173: PUSH
95174: LD_INT 10
95176: PUSH
95177: LD_INT 11
95179: PUSH
95180: LD_INT 12
95182: PUSH
95183: LD_INT 13
95185: PUSH
95186: LD_INT 14
95188: PUSH
95189: LD_INT 15
95191: PUSH
95192: LD_INT 16
95194: PUSH
95195: LD_INT 17
95197: PUSH
95198: LD_INT 18
95200: PUSH
95201: LD_INT 19
95203: PUSH
95204: LD_INT 20
95206: PUSH
95207: LD_INT 21
95209: PUSH
95210: LD_INT 22
95212: PUSH
95213: LD_INT 23
95215: PUSH
95216: LD_INT 24
95218: PUSH
95219: LD_INT 25
95221: PUSH
95222: LD_INT 26
95224: PUSH
95225: LD_INT 27
95227: PUSH
95228: LD_INT 28
95230: PUSH
95231: LD_INT 29
95233: PUSH
95234: LD_INT 30
95236: PUSH
95237: LD_INT 31
95239: PUSH
95240: LD_INT 32
95242: PUSH
95243: LD_INT 33
95245: PUSH
95246: LD_INT 34
95248: PUSH
95249: LD_INT 35
95251: PUSH
95252: LD_INT 36
95254: PUSH
95255: EMPTY
95256: LIST
95257: LIST
95258: LIST
95259: LIST
95260: LIST
95261: LIST
95262: LIST
95263: LIST
95264: LIST
95265: LIST
95266: LIST
95267: LIST
95268: LIST
95269: LIST
95270: LIST
95271: LIST
95272: LIST
95273: LIST
95274: LIST
95275: LIST
95276: LIST
95277: LIST
95278: LIST
95279: LIST
95280: LIST
95281: LIST
95282: LIST
95283: LIST
95284: LIST
95285: LIST
95286: LIST
95287: LIST
95288: LIST
95289: LIST
95290: LIST
95291: LIST
95292: PUSH
95293: LD_INT 101
95295: PUSH
95296: LD_INT 102
95298: PUSH
95299: LD_INT 103
95301: PUSH
95302: LD_INT 104
95304: PUSH
95305: LD_INT 105
95307: PUSH
95308: LD_INT 106
95310: PUSH
95311: LD_INT 107
95313: PUSH
95314: LD_INT 108
95316: PUSH
95317: LD_INT 109
95319: PUSH
95320: LD_INT 110
95322: PUSH
95323: LD_INT 111
95325: PUSH
95326: LD_INT 112
95328: PUSH
95329: LD_INT 113
95331: PUSH
95332: LD_INT 114
95334: PUSH
95335: LD_INT 115
95337: PUSH
95338: LD_INT 116
95340: PUSH
95341: LD_INT 117
95343: PUSH
95344: LD_INT 118
95346: PUSH
95347: EMPTY
95348: LIST
95349: LIST
95350: LIST
95351: LIST
95352: LIST
95353: LIST
95354: LIST
95355: LIST
95356: LIST
95357: LIST
95358: LIST
95359: LIST
95360: LIST
95361: LIST
95362: LIST
95363: LIST
95364: LIST
95365: LIST
95366: PUSH
95367: EMPTY
95368: LIST
95369: LIST
95370: ST_TO_ADDR
// if result then
95371: LD_VAR 0 2
95375: IFFALSE 96161
// begin normal :=  ;
95377: LD_ADDR_VAR 0 5
95381: PUSH
95382: LD_STRING 
95384: ST_TO_ADDR
// hardcore :=  ;
95385: LD_ADDR_VAR 0 6
95389: PUSH
95390: LD_STRING 
95392: ST_TO_ADDR
// active :=  ;
95393: LD_ADDR_VAR 0 7
95397: PUSH
95398: LD_STRING 
95400: ST_TO_ADDR
// for i = 1 to normalCounter do
95401: LD_ADDR_VAR 0 8
95405: PUSH
95406: DOUBLE
95407: LD_INT 1
95409: DEC
95410: ST_TO_ADDR
95411: LD_EXP 97
95415: PUSH
95416: FOR_TO
95417: IFFALSE 95518
// begin tmp := 0 ;
95419: LD_ADDR_VAR 0 3
95423: PUSH
95424: LD_STRING 0
95426: ST_TO_ADDR
// if result [ 1 ] then
95427: LD_VAR 0 2
95431: PUSH
95432: LD_INT 1
95434: ARRAY
95435: IFFALSE 95500
// if result [ 1 ] [ 1 ] = i then
95437: LD_VAR 0 2
95441: PUSH
95442: LD_INT 1
95444: ARRAY
95445: PUSH
95446: LD_INT 1
95448: ARRAY
95449: PUSH
95450: LD_VAR 0 8
95454: EQUAL
95455: IFFALSE 95500
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
95457: LD_ADDR_VAR 0 2
95461: PUSH
95462: LD_VAR 0 2
95466: PPUSH
95467: LD_INT 1
95469: PPUSH
95470: LD_VAR 0 2
95474: PUSH
95475: LD_INT 1
95477: ARRAY
95478: PPUSH
95479: LD_INT 1
95481: PPUSH
95482: CALL_OW 3
95486: PPUSH
95487: CALL_OW 1
95491: ST_TO_ADDR
// tmp := 1 ;
95492: LD_ADDR_VAR 0 3
95496: PUSH
95497: LD_STRING 1
95499: ST_TO_ADDR
// end ; normal := normal & tmp ;
95500: LD_ADDR_VAR 0 5
95504: PUSH
95505: LD_VAR 0 5
95509: PUSH
95510: LD_VAR 0 3
95514: STR
95515: ST_TO_ADDR
// end ;
95516: GO 95416
95518: POP
95519: POP
// for i = 1 to hardcoreCounter do
95520: LD_ADDR_VAR 0 8
95524: PUSH
95525: DOUBLE
95526: LD_INT 1
95528: DEC
95529: ST_TO_ADDR
95530: LD_EXP 98
95534: PUSH
95535: FOR_TO
95536: IFFALSE 95641
// begin tmp := 0 ;
95538: LD_ADDR_VAR 0 3
95542: PUSH
95543: LD_STRING 0
95545: ST_TO_ADDR
// if result [ 2 ] then
95546: LD_VAR 0 2
95550: PUSH
95551: LD_INT 2
95553: ARRAY
95554: IFFALSE 95623
// if result [ 2 ] [ 1 ] = 100 + i then
95556: LD_VAR 0 2
95560: PUSH
95561: LD_INT 2
95563: ARRAY
95564: PUSH
95565: LD_INT 1
95567: ARRAY
95568: PUSH
95569: LD_INT 100
95571: PUSH
95572: LD_VAR 0 8
95576: PLUS
95577: EQUAL
95578: IFFALSE 95623
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
95580: LD_ADDR_VAR 0 2
95584: PUSH
95585: LD_VAR 0 2
95589: PPUSH
95590: LD_INT 2
95592: PPUSH
95593: LD_VAR 0 2
95597: PUSH
95598: LD_INT 2
95600: ARRAY
95601: PPUSH
95602: LD_INT 1
95604: PPUSH
95605: CALL_OW 3
95609: PPUSH
95610: CALL_OW 1
95614: ST_TO_ADDR
// tmp := 1 ;
95615: LD_ADDR_VAR 0 3
95619: PUSH
95620: LD_STRING 1
95622: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
95623: LD_ADDR_VAR 0 6
95627: PUSH
95628: LD_VAR 0 6
95632: PUSH
95633: LD_VAR 0 3
95637: STR
95638: ST_TO_ADDR
// end ;
95639: GO 95535
95641: POP
95642: POP
// if isGameLoad then
95643: LD_VAR 0 1
95647: IFFALSE 96122
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
95649: LD_ADDR_VAR 0 4
95653: PUSH
95654: LD_EXP 101
95658: PUSH
95659: LD_EXP 100
95663: PUSH
95664: LD_EXP 102
95668: PUSH
95669: LD_EXP 99
95673: PUSH
95674: LD_EXP 103
95678: PUSH
95679: LD_EXP 104
95683: PUSH
95684: LD_EXP 105
95688: PUSH
95689: LD_EXP 106
95693: PUSH
95694: LD_EXP 107
95698: PUSH
95699: LD_EXP 108
95703: PUSH
95704: LD_EXP 109
95708: PUSH
95709: LD_EXP 110
95713: PUSH
95714: LD_EXP 111
95718: PUSH
95719: LD_EXP 112
95723: PUSH
95724: LD_EXP 120
95728: PUSH
95729: LD_EXP 121
95733: PUSH
95734: LD_EXP 122
95738: PUSH
95739: LD_EXP 123
95743: PUSH
95744: LD_EXP 125
95748: PUSH
95749: LD_EXP 126
95753: PUSH
95754: LD_EXP 127
95758: PUSH
95759: LD_EXP 130
95763: PUSH
95764: LD_EXP 132
95768: PUSH
95769: LD_EXP 133
95773: PUSH
95774: LD_EXP 134
95778: PUSH
95779: LD_EXP 136
95783: PUSH
95784: LD_EXP 137
95788: PUSH
95789: LD_EXP 140
95793: PUSH
95794: LD_EXP 141
95798: PUSH
95799: LD_EXP 142
95803: PUSH
95804: LD_EXP 143
95808: PUSH
95809: LD_EXP 144
95813: PUSH
95814: LD_EXP 145
95818: PUSH
95819: LD_EXP 146
95823: PUSH
95824: LD_EXP 147
95828: PUSH
95829: LD_EXP 148
95833: PUSH
95834: LD_EXP 113
95838: PUSH
95839: LD_EXP 114
95843: PUSH
95844: LD_EXP 117
95848: PUSH
95849: LD_EXP 118
95853: PUSH
95854: LD_EXP 119
95858: PUSH
95859: LD_EXP 115
95863: PUSH
95864: LD_EXP 116
95868: PUSH
95869: LD_EXP 124
95873: PUSH
95874: LD_EXP 128
95878: PUSH
95879: LD_EXP 129
95883: PUSH
95884: LD_EXP 131
95888: PUSH
95889: LD_EXP 135
95893: PUSH
95894: LD_EXP 138
95898: PUSH
95899: LD_EXP 139
95903: PUSH
95904: LD_EXP 149
95908: PUSH
95909: LD_EXP 150
95913: PUSH
95914: LD_EXP 151
95918: PUSH
95919: LD_EXP 152
95923: PUSH
95924: EMPTY
95925: LIST
95926: LIST
95927: LIST
95928: LIST
95929: LIST
95930: LIST
95931: LIST
95932: LIST
95933: LIST
95934: LIST
95935: LIST
95936: LIST
95937: LIST
95938: LIST
95939: LIST
95940: LIST
95941: LIST
95942: LIST
95943: LIST
95944: LIST
95945: LIST
95946: LIST
95947: LIST
95948: LIST
95949: LIST
95950: LIST
95951: LIST
95952: LIST
95953: LIST
95954: LIST
95955: LIST
95956: LIST
95957: LIST
95958: LIST
95959: LIST
95960: LIST
95961: LIST
95962: LIST
95963: LIST
95964: LIST
95965: LIST
95966: LIST
95967: LIST
95968: LIST
95969: LIST
95970: LIST
95971: LIST
95972: LIST
95973: LIST
95974: LIST
95975: LIST
95976: LIST
95977: LIST
95978: LIST
95979: ST_TO_ADDR
// tmp :=  ;
95980: LD_ADDR_VAR 0 3
95984: PUSH
95985: LD_STRING 
95987: ST_TO_ADDR
// for i = 1 to normalCounter do
95988: LD_ADDR_VAR 0 8
95992: PUSH
95993: DOUBLE
95994: LD_INT 1
95996: DEC
95997: ST_TO_ADDR
95998: LD_EXP 97
96002: PUSH
96003: FOR_TO
96004: IFFALSE 96040
// begin if flags [ i ] then
96006: LD_VAR 0 4
96010: PUSH
96011: LD_VAR 0 8
96015: ARRAY
96016: IFFALSE 96038
// tmp := tmp & i & ; ;
96018: LD_ADDR_VAR 0 3
96022: PUSH
96023: LD_VAR 0 3
96027: PUSH
96028: LD_VAR 0 8
96032: STR
96033: PUSH
96034: LD_STRING ;
96036: STR
96037: ST_TO_ADDR
// end ;
96038: GO 96003
96040: POP
96041: POP
// for i = 1 to hardcoreCounter do
96042: LD_ADDR_VAR 0 8
96046: PUSH
96047: DOUBLE
96048: LD_INT 1
96050: DEC
96051: ST_TO_ADDR
96052: LD_EXP 98
96056: PUSH
96057: FOR_TO
96058: IFFALSE 96104
// begin if flags [ normalCounter + i ] then
96060: LD_VAR 0 4
96064: PUSH
96065: LD_EXP 97
96069: PUSH
96070: LD_VAR 0 8
96074: PLUS
96075: ARRAY
96076: IFFALSE 96102
// tmp := tmp & ( 100 + i ) & ; ;
96078: LD_ADDR_VAR 0 3
96082: PUSH
96083: LD_VAR 0 3
96087: PUSH
96088: LD_INT 100
96090: PUSH
96091: LD_VAR 0 8
96095: PLUS
96096: STR
96097: PUSH
96098: LD_STRING ;
96100: STR
96101: ST_TO_ADDR
// end ;
96102: GO 96057
96104: POP
96105: POP
// if tmp then
96106: LD_VAR 0 3
96110: IFFALSE 96122
// active := tmp ;
96112: LD_ADDR_VAR 0 7
96116: PUSH
96117: LD_VAR 0 3
96121: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
96122: LD_STRING getStreamItemsFromMission("
96124: PUSH
96125: LD_VAR 0 5
96129: STR
96130: PUSH
96131: LD_STRING ","
96133: STR
96134: PUSH
96135: LD_VAR 0 6
96139: STR
96140: PUSH
96141: LD_STRING ","
96143: STR
96144: PUSH
96145: LD_VAR 0 7
96149: STR
96150: PUSH
96151: LD_STRING ")
96153: STR
96154: PPUSH
96155: CALL_OW 559
// end else
96159: GO 96168
// ToLua ( getStreamItemsFromMission("","","") ) ;
96161: LD_STRING getStreamItemsFromMission("","","")
96163: PPUSH
96164: CALL_OW 559
// end ;
96168: LD_VAR 0 2
96172: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
96173: LD_EXP 96
96177: PUSH
96178: LD_EXP 101
96182: AND
96183: IFFALSE 96307
96185: GO 96187
96187: DISABLE
96188: LD_INT 0
96190: PPUSH
96191: PPUSH
// begin enable ;
96192: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
96193: LD_ADDR_VAR 0 2
96197: PUSH
96198: LD_INT 22
96200: PUSH
96201: LD_OWVAR 2
96205: PUSH
96206: EMPTY
96207: LIST
96208: LIST
96209: PUSH
96210: LD_INT 2
96212: PUSH
96213: LD_INT 34
96215: PUSH
96216: LD_INT 7
96218: PUSH
96219: EMPTY
96220: LIST
96221: LIST
96222: PUSH
96223: LD_INT 34
96225: PUSH
96226: LD_INT 45
96228: PUSH
96229: EMPTY
96230: LIST
96231: LIST
96232: PUSH
96233: LD_INT 34
96235: PUSH
96236: LD_INT 28
96238: PUSH
96239: EMPTY
96240: LIST
96241: LIST
96242: PUSH
96243: LD_INT 34
96245: PUSH
96246: LD_INT 47
96248: PUSH
96249: EMPTY
96250: LIST
96251: LIST
96252: PUSH
96253: EMPTY
96254: LIST
96255: LIST
96256: LIST
96257: LIST
96258: LIST
96259: PUSH
96260: EMPTY
96261: LIST
96262: LIST
96263: PPUSH
96264: CALL_OW 69
96268: ST_TO_ADDR
// if not tmp then
96269: LD_VAR 0 2
96273: NOT
96274: IFFALSE 96278
// exit ;
96276: GO 96307
// for i in tmp do
96278: LD_ADDR_VAR 0 1
96282: PUSH
96283: LD_VAR 0 2
96287: PUSH
96288: FOR_IN
96289: IFFALSE 96305
// begin SetLives ( i , 0 ) ;
96291: LD_VAR 0 1
96295: PPUSH
96296: LD_INT 0
96298: PPUSH
96299: CALL_OW 234
// end ;
96303: GO 96288
96305: POP
96306: POP
// end ;
96307: PPOPN 2
96309: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
96310: LD_EXP 96
96314: PUSH
96315: LD_EXP 102
96319: AND
96320: IFFALSE 96404
96322: GO 96324
96324: DISABLE
96325: LD_INT 0
96327: PPUSH
96328: PPUSH
// begin enable ;
96329: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
96330: LD_ADDR_VAR 0 2
96334: PUSH
96335: LD_INT 22
96337: PUSH
96338: LD_OWVAR 2
96342: PUSH
96343: EMPTY
96344: LIST
96345: LIST
96346: PUSH
96347: LD_INT 32
96349: PUSH
96350: LD_INT 3
96352: PUSH
96353: EMPTY
96354: LIST
96355: LIST
96356: PUSH
96357: EMPTY
96358: LIST
96359: LIST
96360: PPUSH
96361: CALL_OW 69
96365: ST_TO_ADDR
// if not tmp then
96366: LD_VAR 0 2
96370: NOT
96371: IFFALSE 96375
// exit ;
96373: GO 96404
// for i in tmp do
96375: LD_ADDR_VAR 0 1
96379: PUSH
96380: LD_VAR 0 2
96384: PUSH
96385: FOR_IN
96386: IFFALSE 96402
// begin SetLives ( i , 0 ) ;
96388: LD_VAR 0 1
96392: PPUSH
96393: LD_INT 0
96395: PPUSH
96396: CALL_OW 234
// end ;
96400: GO 96385
96402: POP
96403: POP
// end ;
96404: PPOPN 2
96406: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
96407: LD_EXP 96
96411: PUSH
96412: LD_EXP 99
96416: AND
96417: IFFALSE 96510
96419: GO 96421
96421: DISABLE
96422: LD_INT 0
96424: PPUSH
// begin enable ;
96425: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
96426: LD_ADDR_VAR 0 1
96430: PUSH
96431: LD_INT 22
96433: PUSH
96434: LD_OWVAR 2
96438: PUSH
96439: EMPTY
96440: LIST
96441: LIST
96442: PUSH
96443: LD_INT 2
96445: PUSH
96446: LD_INT 25
96448: PUSH
96449: LD_INT 5
96451: PUSH
96452: EMPTY
96453: LIST
96454: LIST
96455: PUSH
96456: LD_INT 25
96458: PUSH
96459: LD_INT 9
96461: PUSH
96462: EMPTY
96463: LIST
96464: LIST
96465: PUSH
96466: LD_INT 25
96468: PUSH
96469: LD_INT 8
96471: PUSH
96472: EMPTY
96473: LIST
96474: LIST
96475: PUSH
96476: EMPTY
96477: LIST
96478: LIST
96479: LIST
96480: LIST
96481: PUSH
96482: EMPTY
96483: LIST
96484: LIST
96485: PPUSH
96486: CALL_OW 69
96490: PUSH
96491: FOR_IN
96492: IFFALSE 96508
// begin SetClass ( i , 1 ) ;
96494: LD_VAR 0 1
96498: PPUSH
96499: LD_INT 1
96501: PPUSH
96502: CALL_OW 336
// end ;
96506: GO 96491
96508: POP
96509: POP
// end ;
96510: PPOPN 1
96512: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
96513: LD_EXP 96
96517: PUSH
96518: LD_EXP 100
96522: AND
96523: PUSH
96524: LD_OWVAR 65
96528: PUSH
96529: LD_INT 7
96531: LESS
96532: AND
96533: IFFALSE 96547
96535: GO 96537
96537: DISABLE
// begin enable ;
96538: ENABLE
// game_speed := 7 ;
96539: LD_ADDR_OWVAR 65
96543: PUSH
96544: LD_INT 7
96546: ST_TO_ADDR
// end ;
96547: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
96548: LD_EXP 96
96552: PUSH
96553: LD_EXP 103
96557: AND
96558: IFFALSE 96760
96560: GO 96562
96562: DISABLE
96563: LD_INT 0
96565: PPUSH
96566: PPUSH
96567: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
96568: LD_ADDR_VAR 0 3
96572: PUSH
96573: LD_INT 81
96575: PUSH
96576: LD_OWVAR 2
96580: PUSH
96581: EMPTY
96582: LIST
96583: LIST
96584: PUSH
96585: LD_INT 21
96587: PUSH
96588: LD_INT 1
96590: PUSH
96591: EMPTY
96592: LIST
96593: LIST
96594: PUSH
96595: EMPTY
96596: LIST
96597: LIST
96598: PPUSH
96599: CALL_OW 69
96603: ST_TO_ADDR
// if not tmp then
96604: LD_VAR 0 3
96608: NOT
96609: IFFALSE 96613
// exit ;
96611: GO 96760
// if tmp > 5 then
96613: LD_VAR 0 3
96617: PUSH
96618: LD_INT 5
96620: GREATER
96621: IFFALSE 96633
// k := 5 else
96623: LD_ADDR_VAR 0 2
96627: PUSH
96628: LD_INT 5
96630: ST_TO_ADDR
96631: GO 96643
// k := tmp ;
96633: LD_ADDR_VAR 0 2
96637: PUSH
96638: LD_VAR 0 3
96642: ST_TO_ADDR
// for i := 1 to k do
96643: LD_ADDR_VAR 0 1
96647: PUSH
96648: DOUBLE
96649: LD_INT 1
96651: DEC
96652: ST_TO_ADDR
96653: LD_VAR 0 2
96657: PUSH
96658: FOR_TO
96659: IFFALSE 96758
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
96661: LD_VAR 0 3
96665: PUSH
96666: LD_VAR 0 1
96670: ARRAY
96671: PPUSH
96672: LD_VAR 0 1
96676: PUSH
96677: LD_INT 4
96679: MOD
96680: PUSH
96681: LD_INT 1
96683: PLUS
96684: PPUSH
96685: CALL_OW 259
96689: PUSH
96690: LD_INT 10
96692: LESS
96693: IFFALSE 96756
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
96695: LD_VAR 0 3
96699: PUSH
96700: LD_VAR 0 1
96704: ARRAY
96705: PPUSH
96706: LD_VAR 0 1
96710: PUSH
96711: LD_INT 4
96713: MOD
96714: PUSH
96715: LD_INT 1
96717: PLUS
96718: PPUSH
96719: LD_VAR 0 3
96723: PUSH
96724: LD_VAR 0 1
96728: ARRAY
96729: PPUSH
96730: LD_VAR 0 1
96734: PUSH
96735: LD_INT 4
96737: MOD
96738: PUSH
96739: LD_INT 1
96741: PLUS
96742: PPUSH
96743: CALL_OW 259
96747: PUSH
96748: LD_INT 1
96750: PLUS
96751: PPUSH
96752: CALL_OW 237
96756: GO 96658
96758: POP
96759: POP
// end ;
96760: PPOPN 3
96762: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
96763: LD_EXP 96
96767: PUSH
96768: LD_EXP 104
96772: AND
96773: IFFALSE 96793
96775: GO 96777
96777: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
96778: LD_INT 4
96780: PPUSH
96781: LD_OWVAR 2
96785: PPUSH
96786: LD_INT 0
96788: PPUSH
96789: CALL_OW 324
96793: END
// every 0 0$1 trigger StreamModeActive and sShovel do
96794: LD_EXP 96
96798: PUSH
96799: LD_EXP 133
96803: AND
96804: IFFALSE 96824
96806: GO 96808
96808: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
96809: LD_INT 19
96811: PPUSH
96812: LD_OWVAR 2
96816: PPUSH
96817: LD_INT 0
96819: PPUSH
96820: CALL_OW 324
96824: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
96825: LD_EXP 96
96829: PUSH
96830: LD_EXP 105
96834: AND
96835: IFFALSE 96937
96837: GO 96839
96839: DISABLE
96840: LD_INT 0
96842: PPUSH
96843: PPUSH
// begin enable ;
96844: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
96845: LD_ADDR_VAR 0 2
96849: PUSH
96850: LD_INT 22
96852: PUSH
96853: LD_OWVAR 2
96857: PUSH
96858: EMPTY
96859: LIST
96860: LIST
96861: PUSH
96862: LD_INT 2
96864: PUSH
96865: LD_INT 34
96867: PUSH
96868: LD_INT 11
96870: PUSH
96871: EMPTY
96872: LIST
96873: LIST
96874: PUSH
96875: LD_INT 34
96877: PUSH
96878: LD_INT 30
96880: PUSH
96881: EMPTY
96882: LIST
96883: LIST
96884: PUSH
96885: EMPTY
96886: LIST
96887: LIST
96888: LIST
96889: PUSH
96890: EMPTY
96891: LIST
96892: LIST
96893: PPUSH
96894: CALL_OW 69
96898: ST_TO_ADDR
// if not tmp then
96899: LD_VAR 0 2
96903: NOT
96904: IFFALSE 96908
// exit ;
96906: GO 96937
// for i in tmp do
96908: LD_ADDR_VAR 0 1
96912: PUSH
96913: LD_VAR 0 2
96917: PUSH
96918: FOR_IN
96919: IFFALSE 96935
// begin SetLives ( i , 0 ) ;
96921: LD_VAR 0 1
96925: PPUSH
96926: LD_INT 0
96928: PPUSH
96929: CALL_OW 234
// end ;
96933: GO 96918
96935: POP
96936: POP
// end ;
96937: PPOPN 2
96939: END
// every 0 0$1 trigger StreamModeActive and sBunker do
96940: LD_EXP 96
96944: PUSH
96945: LD_EXP 106
96949: AND
96950: IFFALSE 96970
96952: GO 96954
96954: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
96955: LD_INT 32
96957: PPUSH
96958: LD_OWVAR 2
96962: PPUSH
96963: LD_INT 0
96965: PPUSH
96966: CALL_OW 324
96970: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
96971: LD_EXP 96
96975: PUSH
96976: LD_EXP 107
96980: AND
96981: IFFALSE 97162
96983: GO 96985
96985: DISABLE
96986: LD_INT 0
96988: PPUSH
96989: PPUSH
96990: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
96991: LD_ADDR_VAR 0 2
96995: PUSH
96996: LD_INT 22
96998: PUSH
96999: LD_OWVAR 2
97003: PUSH
97004: EMPTY
97005: LIST
97006: LIST
97007: PUSH
97008: LD_INT 33
97010: PUSH
97011: LD_INT 3
97013: PUSH
97014: EMPTY
97015: LIST
97016: LIST
97017: PUSH
97018: EMPTY
97019: LIST
97020: LIST
97021: PPUSH
97022: CALL_OW 69
97026: ST_TO_ADDR
// if not tmp then
97027: LD_VAR 0 2
97031: NOT
97032: IFFALSE 97036
// exit ;
97034: GO 97162
// side := 0 ;
97036: LD_ADDR_VAR 0 3
97040: PUSH
97041: LD_INT 0
97043: ST_TO_ADDR
// for i := 1 to 8 do
97044: LD_ADDR_VAR 0 1
97048: PUSH
97049: DOUBLE
97050: LD_INT 1
97052: DEC
97053: ST_TO_ADDR
97054: LD_INT 8
97056: PUSH
97057: FOR_TO
97058: IFFALSE 97106
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
97060: LD_OWVAR 2
97064: PUSH
97065: LD_VAR 0 1
97069: NONEQUAL
97070: PUSH
97071: LD_OWVAR 2
97075: PPUSH
97076: LD_VAR 0 1
97080: PPUSH
97081: CALL_OW 81
97085: PUSH
97086: LD_INT 2
97088: EQUAL
97089: AND
97090: IFFALSE 97104
// begin side := i ;
97092: LD_ADDR_VAR 0 3
97096: PUSH
97097: LD_VAR 0 1
97101: ST_TO_ADDR
// break ;
97102: GO 97106
// end ;
97104: GO 97057
97106: POP
97107: POP
// if not side then
97108: LD_VAR 0 3
97112: NOT
97113: IFFALSE 97117
// exit ;
97115: GO 97162
// for i := 1 to tmp do
97117: LD_ADDR_VAR 0 1
97121: PUSH
97122: DOUBLE
97123: LD_INT 1
97125: DEC
97126: ST_TO_ADDR
97127: LD_VAR 0 2
97131: PUSH
97132: FOR_TO
97133: IFFALSE 97160
// if Prob ( 60 ) then
97135: LD_INT 60
97137: PPUSH
97138: CALL_OW 13
97142: IFFALSE 97158
// SetSide ( i , side ) ;
97144: LD_VAR 0 1
97148: PPUSH
97149: LD_VAR 0 3
97153: PPUSH
97154: CALL_OW 235
97158: GO 97132
97160: POP
97161: POP
// end ;
97162: PPOPN 3
97164: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
97165: LD_EXP 96
97169: PUSH
97170: LD_EXP 109
97174: AND
97175: IFFALSE 97294
97177: GO 97179
97179: DISABLE
97180: LD_INT 0
97182: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
97183: LD_ADDR_VAR 0 1
97187: PUSH
97188: LD_INT 22
97190: PUSH
97191: LD_OWVAR 2
97195: PUSH
97196: EMPTY
97197: LIST
97198: LIST
97199: PUSH
97200: LD_INT 21
97202: PUSH
97203: LD_INT 1
97205: PUSH
97206: EMPTY
97207: LIST
97208: LIST
97209: PUSH
97210: LD_INT 3
97212: PUSH
97213: LD_INT 23
97215: PUSH
97216: LD_INT 0
97218: PUSH
97219: EMPTY
97220: LIST
97221: LIST
97222: PUSH
97223: EMPTY
97224: LIST
97225: LIST
97226: PUSH
97227: EMPTY
97228: LIST
97229: LIST
97230: LIST
97231: PPUSH
97232: CALL_OW 69
97236: PUSH
97237: FOR_IN
97238: IFFALSE 97292
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
97240: LD_VAR 0 1
97244: PPUSH
97245: CALL_OW 257
97249: PUSH
97250: LD_INT 1
97252: PUSH
97253: LD_INT 2
97255: PUSH
97256: LD_INT 3
97258: PUSH
97259: LD_INT 4
97261: PUSH
97262: EMPTY
97263: LIST
97264: LIST
97265: LIST
97266: LIST
97267: IN
97268: IFFALSE 97290
// SetClass ( un , rand ( 1 , 4 ) ) ;
97270: LD_VAR 0 1
97274: PPUSH
97275: LD_INT 1
97277: PPUSH
97278: LD_INT 4
97280: PPUSH
97281: CALL_OW 12
97285: PPUSH
97286: CALL_OW 336
97290: GO 97237
97292: POP
97293: POP
// end ;
97294: PPOPN 1
97296: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
97297: LD_EXP 96
97301: PUSH
97302: LD_EXP 108
97306: AND
97307: IFFALSE 97386
97309: GO 97311
97311: DISABLE
97312: LD_INT 0
97314: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
97315: LD_ADDR_VAR 0 1
97319: PUSH
97320: LD_INT 22
97322: PUSH
97323: LD_OWVAR 2
97327: PUSH
97328: EMPTY
97329: LIST
97330: LIST
97331: PUSH
97332: LD_INT 21
97334: PUSH
97335: LD_INT 3
97337: PUSH
97338: EMPTY
97339: LIST
97340: LIST
97341: PUSH
97342: EMPTY
97343: LIST
97344: LIST
97345: PPUSH
97346: CALL_OW 69
97350: ST_TO_ADDR
// if not tmp then
97351: LD_VAR 0 1
97355: NOT
97356: IFFALSE 97360
// exit ;
97358: GO 97386
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
97360: LD_VAR 0 1
97364: PUSH
97365: LD_INT 1
97367: PPUSH
97368: LD_VAR 0 1
97372: PPUSH
97373: CALL_OW 12
97377: ARRAY
97378: PPUSH
97379: LD_INT 100
97381: PPUSH
97382: CALL_OW 234
// end ;
97386: PPOPN 1
97388: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
97389: LD_EXP 96
97393: PUSH
97394: LD_EXP 110
97398: AND
97399: IFFALSE 97497
97401: GO 97403
97403: DISABLE
97404: LD_INT 0
97406: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
97407: LD_ADDR_VAR 0 1
97411: PUSH
97412: LD_INT 22
97414: PUSH
97415: LD_OWVAR 2
97419: PUSH
97420: EMPTY
97421: LIST
97422: LIST
97423: PUSH
97424: LD_INT 21
97426: PUSH
97427: LD_INT 1
97429: PUSH
97430: EMPTY
97431: LIST
97432: LIST
97433: PUSH
97434: EMPTY
97435: LIST
97436: LIST
97437: PPUSH
97438: CALL_OW 69
97442: ST_TO_ADDR
// if not tmp then
97443: LD_VAR 0 1
97447: NOT
97448: IFFALSE 97452
// exit ;
97450: GO 97497
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
97452: LD_VAR 0 1
97456: PUSH
97457: LD_INT 1
97459: PPUSH
97460: LD_VAR 0 1
97464: PPUSH
97465: CALL_OW 12
97469: ARRAY
97470: PPUSH
97471: LD_INT 1
97473: PPUSH
97474: LD_INT 4
97476: PPUSH
97477: CALL_OW 12
97481: PPUSH
97482: LD_INT 3000
97484: PPUSH
97485: LD_INT 9000
97487: PPUSH
97488: CALL_OW 12
97492: PPUSH
97493: CALL_OW 492
// end ;
97497: PPOPN 1
97499: END
// every 0 0$1 trigger StreamModeActive and sDepot do
97500: LD_EXP 96
97504: PUSH
97505: LD_EXP 111
97509: AND
97510: IFFALSE 97530
97512: GO 97514
97514: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
97515: LD_INT 1
97517: PPUSH
97518: LD_OWVAR 2
97522: PPUSH
97523: LD_INT 0
97525: PPUSH
97526: CALL_OW 324
97530: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
97531: LD_EXP 96
97535: PUSH
97536: LD_EXP 112
97540: AND
97541: IFFALSE 97624
97543: GO 97545
97545: DISABLE
97546: LD_INT 0
97548: PPUSH
97549: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
97550: LD_ADDR_VAR 0 2
97554: PUSH
97555: LD_INT 22
97557: PUSH
97558: LD_OWVAR 2
97562: PUSH
97563: EMPTY
97564: LIST
97565: LIST
97566: PUSH
97567: LD_INT 21
97569: PUSH
97570: LD_INT 3
97572: PUSH
97573: EMPTY
97574: LIST
97575: LIST
97576: PUSH
97577: EMPTY
97578: LIST
97579: LIST
97580: PPUSH
97581: CALL_OW 69
97585: ST_TO_ADDR
// if not tmp then
97586: LD_VAR 0 2
97590: NOT
97591: IFFALSE 97595
// exit ;
97593: GO 97624
// for i in tmp do
97595: LD_ADDR_VAR 0 1
97599: PUSH
97600: LD_VAR 0 2
97604: PUSH
97605: FOR_IN
97606: IFFALSE 97622
// SetBLevel ( i , 10 ) ;
97608: LD_VAR 0 1
97612: PPUSH
97613: LD_INT 10
97615: PPUSH
97616: CALL_OW 241
97620: GO 97605
97622: POP
97623: POP
// end ;
97624: PPOPN 2
97626: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
97627: LD_EXP 96
97631: PUSH
97632: LD_EXP 113
97636: AND
97637: IFFALSE 97748
97639: GO 97641
97641: DISABLE
97642: LD_INT 0
97644: PPUSH
97645: PPUSH
97646: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
97647: LD_ADDR_VAR 0 3
97651: PUSH
97652: LD_INT 22
97654: PUSH
97655: LD_OWVAR 2
97659: PUSH
97660: EMPTY
97661: LIST
97662: LIST
97663: PUSH
97664: LD_INT 25
97666: PUSH
97667: LD_INT 1
97669: PUSH
97670: EMPTY
97671: LIST
97672: LIST
97673: PUSH
97674: EMPTY
97675: LIST
97676: LIST
97677: PPUSH
97678: CALL_OW 69
97682: ST_TO_ADDR
// if not tmp then
97683: LD_VAR 0 3
97687: NOT
97688: IFFALSE 97692
// exit ;
97690: GO 97748
// un := tmp [ rand ( 1 , tmp ) ] ;
97692: LD_ADDR_VAR 0 2
97696: PUSH
97697: LD_VAR 0 3
97701: PUSH
97702: LD_INT 1
97704: PPUSH
97705: LD_VAR 0 3
97709: PPUSH
97710: CALL_OW 12
97714: ARRAY
97715: ST_TO_ADDR
// if Crawls ( un ) then
97716: LD_VAR 0 2
97720: PPUSH
97721: CALL_OW 318
97725: IFFALSE 97736
// ComWalk ( un ) ;
97727: LD_VAR 0 2
97731: PPUSH
97732: CALL_OW 138
// SetClass ( un , class_sniper ) ;
97736: LD_VAR 0 2
97740: PPUSH
97741: LD_INT 5
97743: PPUSH
97744: CALL_OW 336
// end ;
97748: PPOPN 3
97750: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
97751: LD_EXP 96
97755: PUSH
97756: LD_EXP 114
97760: AND
97761: PUSH
97762: LD_OWVAR 67
97766: PUSH
97767: LD_INT 4
97769: LESS
97770: AND
97771: IFFALSE 97790
97773: GO 97775
97775: DISABLE
// begin Difficulty := Difficulty + 1 ;
97776: LD_ADDR_OWVAR 67
97780: PUSH
97781: LD_OWVAR 67
97785: PUSH
97786: LD_INT 1
97788: PLUS
97789: ST_TO_ADDR
// end ;
97790: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
97791: LD_EXP 96
97795: PUSH
97796: LD_EXP 115
97800: AND
97801: IFFALSE 97904
97803: GO 97805
97805: DISABLE
97806: LD_INT 0
97808: PPUSH
// begin for i := 1 to 5 do
97809: LD_ADDR_VAR 0 1
97813: PUSH
97814: DOUBLE
97815: LD_INT 1
97817: DEC
97818: ST_TO_ADDR
97819: LD_INT 5
97821: PUSH
97822: FOR_TO
97823: IFFALSE 97902
// begin uc_nation := nation_nature ;
97825: LD_ADDR_OWVAR 21
97829: PUSH
97830: LD_INT 0
97832: ST_TO_ADDR
// uc_side := 0 ;
97833: LD_ADDR_OWVAR 20
97837: PUSH
97838: LD_INT 0
97840: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
97841: LD_ADDR_OWVAR 29
97845: PUSH
97846: LD_INT 12
97848: PUSH
97849: LD_INT 12
97851: PUSH
97852: EMPTY
97853: LIST
97854: LIST
97855: ST_TO_ADDR
// hc_agressivity := 20 ;
97856: LD_ADDR_OWVAR 35
97860: PUSH
97861: LD_INT 20
97863: ST_TO_ADDR
// hc_class := class_tiger ;
97864: LD_ADDR_OWVAR 28
97868: PUSH
97869: LD_INT 14
97871: ST_TO_ADDR
// hc_gallery :=  ;
97872: LD_ADDR_OWVAR 33
97876: PUSH
97877: LD_STRING 
97879: ST_TO_ADDR
// hc_name :=  ;
97880: LD_ADDR_OWVAR 26
97884: PUSH
97885: LD_STRING 
97887: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
97888: CALL_OW 44
97892: PPUSH
97893: LD_INT 0
97895: PPUSH
97896: CALL_OW 51
// end ;
97900: GO 97822
97902: POP
97903: POP
// end ;
97904: PPOPN 1
97906: END
// every 0 0$1 trigger StreamModeActive and sBomb do
97907: LD_EXP 96
97911: PUSH
97912: LD_EXP 116
97916: AND
97917: IFFALSE 97926
97919: GO 97921
97921: DISABLE
// StreamSibBomb ;
97922: CALL 97927 0 0
97926: END
// export function StreamSibBomb ; var i , x , y ; begin
97927: LD_INT 0
97929: PPUSH
97930: PPUSH
97931: PPUSH
97932: PPUSH
// result := false ;
97933: LD_ADDR_VAR 0 1
97937: PUSH
97938: LD_INT 0
97940: ST_TO_ADDR
// for i := 1 to 16 do
97941: LD_ADDR_VAR 0 2
97945: PUSH
97946: DOUBLE
97947: LD_INT 1
97949: DEC
97950: ST_TO_ADDR
97951: LD_INT 16
97953: PUSH
97954: FOR_TO
97955: IFFALSE 98154
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
97957: LD_ADDR_VAR 0 3
97961: PUSH
97962: LD_INT 10
97964: PUSH
97965: LD_INT 20
97967: PUSH
97968: LD_INT 30
97970: PUSH
97971: LD_INT 40
97973: PUSH
97974: LD_INT 50
97976: PUSH
97977: LD_INT 60
97979: PUSH
97980: LD_INT 70
97982: PUSH
97983: LD_INT 80
97985: PUSH
97986: LD_INT 90
97988: PUSH
97989: LD_INT 100
97991: PUSH
97992: LD_INT 110
97994: PUSH
97995: LD_INT 120
97997: PUSH
97998: LD_INT 130
98000: PUSH
98001: LD_INT 140
98003: PUSH
98004: LD_INT 150
98006: PUSH
98007: EMPTY
98008: LIST
98009: LIST
98010: LIST
98011: LIST
98012: LIST
98013: LIST
98014: LIST
98015: LIST
98016: LIST
98017: LIST
98018: LIST
98019: LIST
98020: LIST
98021: LIST
98022: LIST
98023: PUSH
98024: LD_INT 1
98026: PPUSH
98027: LD_INT 15
98029: PPUSH
98030: CALL_OW 12
98034: ARRAY
98035: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
98036: LD_ADDR_VAR 0 4
98040: PUSH
98041: LD_INT 10
98043: PUSH
98044: LD_INT 20
98046: PUSH
98047: LD_INT 30
98049: PUSH
98050: LD_INT 40
98052: PUSH
98053: LD_INT 50
98055: PUSH
98056: LD_INT 60
98058: PUSH
98059: LD_INT 70
98061: PUSH
98062: LD_INT 80
98064: PUSH
98065: LD_INT 90
98067: PUSH
98068: LD_INT 100
98070: PUSH
98071: LD_INT 110
98073: PUSH
98074: LD_INT 120
98076: PUSH
98077: LD_INT 130
98079: PUSH
98080: LD_INT 140
98082: PUSH
98083: LD_INT 150
98085: PUSH
98086: EMPTY
98087: LIST
98088: LIST
98089: LIST
98090: LIST
98091: LIST
98092: LIST
98093: LIST
98094: LIST
98095: LIST
98096: LIST
98097: LIST
98098: LIST
98099: LIST
98100: LIST
98101: LIST
98102: PUSH
98103: LD_INT 1
98105: PPUSH
98106: LD_INT 15
98108: PPUSH
98109: CALL_OW 12
98113: ARRAY
98114: ST_TO_ADDR
// if ValidHex ( x , y ) then
98115: LD_VAR 0 3
98119: PPUSH
98120: LD_VAR 0 4
98124: PPUSH
98125: CALL_OW 488
98129: IFFALSE 98152
// begin result := [ x , y ] ;
98131: LD_ADDR_VAR 0 1
98135: PUSH
98136: LD_VAR 0 3
98140: PUSH
98141: LD_VAR 0 4
98145: PUSH
98146: EMPTY
98147: LIST
98148: LIST
98149: ST_TO_ADDR
// break ;
98150: GO 98154
// end ; end ;
98152: GO 97954
98154: POP
98155: POP
// if result then
98156: LD_VAR 0 1
98160: IFFALSE 98220
// begin ToLua ( playSibBomb() ) ;
98162: LD_STRING playSibBomb()
98164: PPUSH
98165: CALL_OW 559
// wait ( 0 0$14 ) ;
98169: LD_INT 490
98171: PPUSH
98172: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
98176: LD_VAR 0 1
98180: PUSH
98181: LD_INT 1
98183: ARRAY
98184: PPUSH
98185: LD_VAR 0 1
98189: PUSH
98190: LD_INT 2
98192: ARRAY
98193: PPUSH
98194: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
98198: LD_VAR 0 1
98202: PUSH
98203: LD_INT 1
98205: ARRAY
98206: PPUSH
98207: LD_VAR 0 1
98211: PUSH
98212: LD_INT 2
98214: ARRAY
98215: PPUSH
98216: CALL_OW 429
// end ; end ;
98220: LD_VAR 0 1
98224: RET
// every 0 0$1 trigger StreamModeActive and sReset do
98225: LD_EXP 96
98229: PUSH
98230: LD_EXP 118
98234: AND
98235: IFFALSE 98247
98237: GO 98239
98239: DISABLE
// YouLost (  ) ;
98240: LD_STRING 
98242: PPUSH
98243: CALL_OW 104
98247: END
// every 0 0$1 trigger StreamModeActive and sFog do
98248: LD_EXP 96
98252: PUSH
98253: LD_EXP 117
98257: AND
98258: IFFALSE 98272
98260: GO 98262
98262: DISABLE
// FogOff ( your_side ) ;
98263: LD_OWVAR 2
98267: PPUSH
98268: CALL_OW 344
98272: END
// every 0 0$1 trigger StreamModeActive and sSun do
98273: LD_EXP 96
98277: PUSH
98278: LD_EXP 119
98282: AND
98283: IFFALSE 98311
98285: GO 98287
98287: DISABLE
// begin solar_recharge_percent := 0 ;
98288: LD_ADDR_OWVAR 79
98292: PUSH
98293: LD_INT 0
98295: ST_TO_ADDR
// wait ( 5 5$00 ) ;
98296: LD_INT 10500
98298: PPUSH
98299: CALL_OW 67
// solar_recharge_percent := 100 ;
98303: LD_ADDR_OWVAR 79
98307: PUSH
98308: LD_INT 100
98310: ST_TO_ADDR
// end ;
98311: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
98312: LD_EXP 96
98316: PUSH
98317: LD_EXP 120
98321: AND
98322: IFFALSE 98561
98324: GO 98326
98326: DISABLE
98327: LD_INT 0
98329: PPUSH
98330: PPUSH
98331: PPUSH
// begin tmp := [ ] ;
98332: LD_ADDR_VAR 0 3
98336: PUSH
98337: EMPTY
98338: ST_TO_ADDR
// for i := 1 to 6 do
98339: LD_ADDR_VAR 0 1
98343: PUSH
98344: DOUBLE
98345: LD_INT 1
98347: DEC
98348: ST_TO_ADDR
98349: LD_INT 6
98351: PUSH
98352: FOR_TO
98353: IFFALSE 98458
// begin uc_nation := nation_nature ;
98355: LD_ADDR_OWVAR 21
98359: PUSH
98360: LD_INT 0
98362: ST_TO_ADDR
// uc_side := 0 ;
98363: LD_ADDR_OWVAR 20
98367: PUSH
98368: LD_INT 0
98370: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
98371: LD_ADDR_OWVAR 29
98375: PUSH
98376: LD_INT 12
98378: PUSH
98379: LD_INT 12
98381: PUSH
98382: EMPTY
98383: LIST
98384: LIST
98385: ST_TO_ADDR
// hc_agressivity := 20 ;
98386: LD_ADDR_OWVAR 35
98390: PUSH
98391: LD_INT 20
98393: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
98394: LD_ADDR_OWVAR 28
98398: PUSH
98399: LD_INT 17
98401: ST_TO_ADDR
// hc_gallery :=  ;
98402: LD_ADDR_OWVAR 33
98406: PUSH
98407: LD_STRING 
98409: ST_TO_ADDR
// hc_name :=  ;
98410: LD_ADDR_OWVAR 26
98414: PUSH
98415: LD_STRING 
98417: ST_TO_ADDR
// un := CreateHuman ;
98418: LD_ADDR_VAR 0 2
98422: PUSH
98423: CALL_OW 44
98427: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
98428: LD_VAR 0 2
98432: PPUSH
98433: LD_INT 1
98435: PPUSH
98436: CALL_OW 51
// tmp := tmp ^ un ;
98440: LD_ADDR_VAR 0 3
98444: PUSH
98445: LD_VAR 0 3
98449: PUSH
98450: LD_VAR 0 2
98454: ADD
98455: ST_TO_ADDR
// end ;
98456: GO 98352
98458: POP
98459: POP
// repeat wait ( 0 0$1 ) ;
98460: LD_INT 35
98462: PPUSH
98463: CALL_OW 67
// for un in tmp do
98467: LD_ADDR_VAR 0 2
98471: PUSH
98472: LD_VAR 0 3
98476: PUSH
98477: FOR_IN
98478: IFFALSE 98552
// begin if IsDead ( un ) then
98480: LD_VAR 0 2
98484: PPUSH
98485: CALL_OW 301
98489: IFFALSE 98509
// begin tmp := tmp diff un ;
98491: LD_ADDR_VAR 0 3
98495: PUSH
98496: LD_VAR 0 3
98500: PUSH
98501: LD_VAR 0 2
98505: DIFF
98506: ST_TO_ADDR
// continue ;
98507: GO 98477
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
98509: LD_VAR 0 2
98513: PPUSH
98514: LD_INT 3
98516: PUSH
98517: LD_INT 22
98519: PUSH
98520: LD_INT 0
98522: PUSH
98523: EMPTY
98524: LIST
98525: LIST
98526: PUSH
98527: EMPTY
98528: LIST
98529: LIST
98530: PPUSH
98531: CALL_OW 69
98535: PPUSH
98536: LD_VAR 0 2
98540: PPUSH
98541: CALL_OW 74
98545: PPUSH
98546: CALL_OW 115
// end ;
98550: GO 98477
98552: POP
98553: POP
// until not tmp ;
98554: LD_VAR 0 3
98558: NOT
98559: IFFALSE 98460
// end ;
98561: PPOPN 3
98563: END
// every 0 0$1 trigger StreamModeActive and sTroll do
98564: LD_EXP 96
98568: PUSH
98569: LD_EXP 121
98573: AND
98574: IFFALSE 98628
98576: GO 98578
98578: DISABLE
// begin ToLua ( displayTroll(); ) ;
98579: LD_STRING displayTroll();
98581: PPUSH
98582: CALL_OW 559
// wait ( 3 3$00 ) ;
98586: LD_INT 6300
98588: PPUSH
98589: CALL_OW 67
// ToLua ( hideTroll(); ) ;
98593: LD_STRING hideTroll();
98595: PPUSH
98596: CALL_OW 559
// wait ( 1 1$00 ) ;
98600: LD_INT 2100
98602: PPUSH
98603: CALL_OW 67
// ToLua ( displayTroll(); ) ;
98607: LD_STRING displayTroll();
98609: PPUSH
98610: CALL_OW 559
// wait ( 1 1$00 ) ;
98614: LD_INT 2100
98616: PPUSH
98617: CALL_OW 67
// ToLua ( hideTroll(); ) ;
98621: LD_STRING hideTroll();
98623: PPUSH
98624: CALL_OW 559
// end ;
98628: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
98629: LD_EXP 96
98633: PUSH
98634: LD_EXP 122
98638: AND
98639: IFFALSE 98702
98641: GO 98643
98643: DISABLE
98644: LD_INT 0
98646: PPUSH
// begin p := 0 ;
98647: LD_ADDR_VAR 0 1
98651: PUSH
98652: LD_INT 0
98654: ST_TO_ADDR
// repeat game_speed := 1 ;
98655: LD_ADDR_OWVAR 65
98659: PUSH
98660: LD_INT 1
98662: ST_TO_ADDR
// wait ( 0 0$1 ) ;
98663: LD_INT 35
98665: PPUSH
98666: CALL_OW 67
// p := p + 1 ;
98670: LD_ADDR_VAR 0 1
98674: PUSH
98675: LD_VAR 0 1
98679: PUSH
98680: LD_INT 1
98682: PLUS
98683: ST_TO_ADDR
// until p >= 60 ;
98684: LD_VAR 0 1
98688: PUSH
98689: LD_INT 60
98691: GREATEREQUAL
98692: IFFALSE 98655
// game_speed := 4 ;
98694: LD_ADDR_OWVAR 65
98698: PUSH
98699: LD_INT 4
98701: ST_TO_ADDR
// end ;
98702: PPOPN 1
98704: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
98705: LD_EXP 96
98709: PUSH
98710: LD_EXP 123
98714: AND
98715: IFFALSE 98861
98717: GO 98719
98719: DISABLE
98720: LD_INT 0
98722: PPUSH
98723: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
98724: LD_ADDR_VAR 0 1
98728: PUSH
98729: LD_INT 22
98731: PUSH
98732: LD_OWVAR 2
98736: PUSH
98737: EMPTY
98738: LIST
98739: LIST
98740: PUSH
98741: LD_INT 2
98743: PUSH
98744: LD_INT 30
98746: PUSH
98747: LD_INT 0
98749: PUSH
98750: EMPTY
98751: LIST
98752: LIST
98753: PUSH
98754: LD_INT 30
98756: PUSH
98757: LD_INT 1
98759: PUSH
98760: EMPTY
98761: LIST
98762: LIST
98763: PUSH
98764: EMPTY
98765: LIST
98766: LIST
98767: LIST
98768: PUSH
98769: EMPTY
98770: LIST
98771: LIST
98772: PPUSH
98773: CALL_OW 69
98777: ST_TO_ADDR
// if not depot then
98778: LD_VAR 0 1
98782: NOT
98783: IFFALSE 98787
// exit ;
98785: GO 98861
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
98787: LD_ADDR_VAR 0 2
98791: PUSH
98792: LD_VAR 0 1
98796: PUSH
98797: LD_INT 1
98799: PPUSH
98800: LD_VAR 0 1
98804: PPUSH
98805: CALL_OW 12
98809: ARRAY
98810: PPUSH
98811: CALL_OW 274
98815: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
98816: LD_VAR 0 2
98820: PPUSH
98821: LD_INT 1
98823: PPUSH
98824: LD_INT 0
98826: PPUSH
98827: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
98831: LD_VAR 0 2
98835: PPUSH
98836: LD_INT 2
98838: PPUSH
98839: LD_INT 0
98841: PPUSH
98842: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
98846: LD_VAR 0 2
98850: PPUSH
98851: LD_INT 3
98853: PPUSH
98854: LD_INT 0
98856: PPUSH
98857: CALL_OW 277
// end ;
98861: PPOPN 2
98863: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
98864: LD_EXP 96
98868: PUSH
98869: LD_EXP 124
98873: AND
98874: IFFALSE 98971
98876: GO 98878
98878: DISABLE
98879: LD_INT 0
98881: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
98882: LD_ADDR_VAR 0 1
98886: PUSH
98887: LD_INT 22
98889: PUSH
98890: LD_OWVAR 2
98894: PUSH
98895: EMPTY
98896: LIST
98897: LIST
98898: PUSH
98899: LD_INT 21
98901: PUSH
98902: LD_INT 1
98904: PUSH
98905: EMPTY
98906: LIST
98907: LIST
98908: PUSH
98909: LD_INT 3
98911: PUSH
98912: LD_INT 23
98914: PUSH
98915: LD_INT 0
98917: PUSH
98918: EMPTY
98919: LIST
98920: LIST
98921: PUSH
98922: EMPTY
98923: LIST
98924: LIST
98925: PUSH
98926: EMPTY
98927: LIST
98928: LIST
98929: LIST
98930: PPUSH
98931: CALL_OW 69
98935: ST_TO_ADDR
// if not tmp then
98936: LD_VAR 0 1
98940: NOT
98941: IFFALSE 98945
// exit ;
98943: GO 98971
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
98945: LD_VAR 0 1
98949: PUSH
98950: LD_INT 1
98952: PPUSH
98953: LD_VAR 0 1
98957: PPUSH
98958: CALL_OW 12
98962: ARRAY
98963: PPUSH
98964: LD_INT 200
98966: PPUSH
98967: CALL_OW 234
// end ;
98971: PPOPN 1
98973: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
98974: LD_EXP 96
98978: PUSH
98979: LD_EXP 125
98983: AND
98984: IFFALSE 99063
98986: GO 98988
98988: DISABLE
98989: LD_INT 0
98991: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
98992: LD_ADDR_VAR 0 1
98996: PUSH
98997: LD_INT 22
98999: PUSH
99000: LD_OWVAR 2
99004: PUSH
99005: EMPTY
99006: LIST
99007: LIST
99008: PUSH
99009: LD_INT 21
99011: PUSH
99012: LD_INT 2
99014: PUSH
99015: EMPTY
99016: LIST
99017: LIST
99018: PUSH
99019: EMPTY
99020: LIST
99021: LIST
99022: PPUSH
99023: CALL_OW 69
99027: ST_TO_ADDR
// if not tmp then
99028: LD_VAR 0 1
99032: NOT
99033: IFFALSE 99037
// exit ;
99035: GO 99063
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
99037: LD_VAR 0 1
99041: PUSH
99042: LD_INT 1
99044: PPUSH
99045: LD_VAR 0 1
99049: PPUSH
99050: CALL_OW 12
99054: ARRAY
99055: PPUSH
99056: LD_INT 60
99058: PPUSH
99059: CALL_OW 234
// end ;
99063: PPOPN 1
99065: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
99066: LD_EXP 96
99070: PUSH
99071: LD_EXP 126
99075: AND
99076: IFFALSE 99175
99078: GO 99080
99080: DISABLE
99081: LD_INT 0
99083: PPUSH
99084: PPUSH
// begin enable ;
99085: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
99086: LD_ADDR_VAR 0 1
99090: PUSH
99091: LD_INT 22
99093: PUSH
99094: LD_OWVAR 2
99098: PUSH
99099: EMPTY
99100: LIST
99101: LIST
99102: PUSH
99103: LD_INT 61
99105: PUSH
99106: EMPTY
99107: LIST
99108: PUSH
99109: LD_INT 33
99111: PUSH
99112: LD_INT 2
99114: PUSH
99115: EMPTY
99116: LIST
99117: LIST
99118: PUSH
99119: EMPTY
99120: LIST
99121: LIST
99122: LIST
99123: PPUSH
99124: CALL_OW 69
99128: ST_TO_ADDR
// if not tmp then
99129: LD_VAR 0 1
99133: NOT
99134: IFFALSE 99138
// exit ;
99136: GO 99175
// for i in tmp do
99138: LD_ADDR_VAR 0 2
99142: PUSH
99143: LD_VAR 0 1
99147: PUSH
99148: FOR_IN
99149: IFFALSE 99173
// if IsControledBy ( i ) then
99151: LD_VAR 0 2
99155: PPUSH
99156: CALL_OW 312
99160: IFFALSE 99171
// ComUnlink ( i ) ;
99162: LD_VAR 0 2
99166: PPUSH
99167: CALL_OW 136
99171: GO 99148
99173: POP
99174: POP
// end ;
99175: PPOPN 2
99177: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
99178: LD_EXP 96
99182: PUSH
99183: LD_EXP 127
99187: AND
99188: IFFALSE 99328
99190: GO 99192
99192: DISABLE
99193: LD_INT 0
99195: PPUSH
99196: PPUSH
// begin ToLua ( displayPowell(); ) ;
99197: LD_STRING displayPowell();
99199: PPUSH
99200: CALL_OW 559
// uc_side := 0 ;
99204: LD_ADDR_OWVAR 20
99208: PUSH
99209: LD_INT 0
99211: ST_TO_ADDR
// uc_nation := 2 ;
99212: LD_ADDR_OWVAR 21
99216: PUSH
99217: LD_INT 2
99219: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
99220: LD_ADDR_OWVAR 37
99224: PUSH
99225: LD_INT 14
99227: ST_TO_ADDR
// vc_engine := engine_siberite ;
99228: LD_ADDR_OWVAR 39
99232: PUSH
99233: LD_INT 3
99235: ST_TO_ADDR
// vc_control := control_apeman ;
99236: LD_ADDR_OWVAR 38
99240: PUSH
99241: LD_INT 5
99243: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
99244: LD_ADDR_OWVAR 40
99248: PUSH
99249: LD_INT 29
99251: ST_TO_ADDR
// un := CreateVehicle ;
99252: LD_ADDR_VAR 0 2
99256: PUSH
99257: CALL_OW 45
99261: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
99262: LD_VAR 0 2
99266: PPUSH
99267: LD_INT 1
99269: PPUSH
99270: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
99274: LD_INT 35
99276: PPUSH
99277: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
99281: LD_VAR 0 2
99285: PPUSH
99286: LD_INT 22
99288: PUSH
99289: LD_OWVAR 2
99293: PUSH
99294: EMPTY
99295: LIST
99296: LIST
99297: PPUSH
99298: CALL_OW 69
99302: PPUSH
99303: LD_VAR 0 2
99307: PPUSH
99308: CALL_OW 74
99312: PPUSH
99313: CALL_OW 115
// until IsDead ( un ) ;
99317: LD_VAR 0 2
99321: PPUSH
99322: CALL_OW 301
99326: IFFALSE 99274
// end ;
99328: PPOPN 2
99330: END
// every 0 0$1 trigger StreamModeActive and sStu do
99331: LD_EXP 96
99335: PUSH
99336: LD_EXP 135
99340: AND
99341: IFFALSE 99357
99343: GO 99345
99345: DISABLE
// begin ToLua ( displayStucuk(); ) ;
99346: LD_STRING displayStucuk();
99348: PPUSH
99349: CALL_OW 559
// ResetFog ;
99353: CALL_OW 335
// end ;
99357: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
99358: LD_EXP 96
99362: PUSH
99363: LD_EXP 128
99367: AND
99368: IFFALSE 99509
99370: GO 99372
99372: DISABLE
99373: LD_INT 0
99375: PPUSH
99376: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
99377: LD_ADDR_VAR 0 2
99381: PUSH
99382: LD_INT 22
99384: PUSH
99385: LD_OWVAR 2
99389: PUSH
99390: EMPTY
99391: LIST
99392: LIST
99393: PUSH
99394: LD_INT 21
99396: PUSH
99397: LD_INT 1
99399: PUSH
99400: EMPTY
99401: LIST
99402: LIST
99403: PUSH
99404: EMPTY
99405: LIST
99406: LIST
99407: PPUSH
99408: CALL_OW 69
99412: ST_TO_ADDR
// if not tmp then
99413: LD_VAR 0 2
99417: NOT
99418: IFFALSE 99422
// exit ;
99420: GO 99509
// un := tmp [ rand ( 1 , tmp ) ] ;
99422: LD_ADDR_VAR 0 1
99426: PUSH
99427: LD_VAR 0 2
99431: PUSH
99432: LD_INT 1
99434: PPUSH
99435: LD_VAR 0 2
99439: PPUSH
99440: CALL_OW 12
99444: ARRAY
99445: ST_TO_ADDR
// SetSide ( un , 0 ) ;
99446: LD_VAR 0 1
99450: PPUSH
99451: LD_INT 0
99453: PPUSH
99454: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
99458: LD_VAR 0 1
99462: PPUSH
99463: LD_OWVAR 3
99467: PUSH
99468: LD_VAR 0 1
99472: DIFF
99473: PPUSH
99474: LD_VAR 0 1
99478: PPUSH
99479: CALL_OW 74
99483: PPUSH
99484: CALL_OW 115
// wait ( 0 0$20 ) ;
99488: LD_INT 700
99490: PPUSH
99491: CALL_OW 67
// SetSide ( un , your_side ) ;
99495: LD_VAR 0 1
99499: PPUSH
99500: LD_OWVAR 2
99504: PPUSH
99505: CALL_OW 235
// end ;
99509: PPOPN 2
99511: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
99512: LD_EXP 96
99516: PUSH
99517: LD_EXP 129
99521: AND
99522: IFFALSE 99628
99524: GO 99526
99526: DISABLE
99527: LD_INT 0
99529: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
99530: LD_ADDR_VAR 0 1
99534: PUSH
99535: LD_INT 22
99537: PUSH
99538: LD_OWVAR 2
99542: PUSH
99543: EMPTY
99544: LIST
99545: LIST
99546: PUSH
99547: LD_INT 2
99549: PUSH
99550: LD_INT 30
99552: PUSH
99553: LD_INT 0
99555: PUSH
99556: EMPTY
99557: LIST
99558: LIST
99559: PUSH
99560: LD_INT 30
99562: PUSH
99563: LD_INT 1
99565: PUSH
99566: EMPTY
99567: LIST
99568: LIST
99569: PUSH
99570: EMPTY
99571: LIST
99572: LIST
99573: LIST
99574: PUSH
99575: EMPTY
99576: LIST
99577: LIST
99578: PPUSH
99579: CALL_OW 69
99583: ST_TO_ADDR
// if not depot then
99584: LD_VAR 0 1
99588: NOT
99589: IFFALSE 99593
// exit ;
99591: GO 99628
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
99593: LD_VAR 0 1
99597: PUSH
99598: LD_INT 1
99600: ARRAY
99601: PPUSH
99602: CALL_OW 250
99606: PPUSH
99607: LD_VAR 0 1
99611: PUSH
99612: LD_INT 1
99614: ARRAY
99615: PPUSH
99616: CALL_OW 251
99620: PPUSH
99621: LD_INT 70
99623: PPUSH
99624: CALL_OW 495
// end ;
99628: PPOPN 1
99630: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
99631: LD_EXP 96
99635: PUSH
99636: LD_EXP 130
99640: AND
99641: IFFALSE 99852
99643: GO 99645
99645: DISABLE
99646: LD_INT 0
99648: PPUSH
99649: PPUSH
99650: PPUSH
99651: PPUSH
99652: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
99653: LD_ADDR_VAR 0 5
99657: PUSH
99658: LD_INT 22
99660: PUSH
99661: LD_OWVAR 2
99665: PUSH
99666: EMPTY
99667: LIST
99668: LIST
99669: PUSH
99670: LD_INT 21
99672: PUSH
99673: LD_INT 1
99675: PUSH
99676: EMPTY
99677: LIST
99678: LIST
99679: PUSH
99680: EMPTY
99681: LIST
99682: LIST
99683: PPUSH
99684: CALL_OW 69
99688: ST_TO_ADDR
// if not tmp then
99689: LD_VAR 0 5
99693: NOT
99694: IFFALSE 99698
// exit ;
99696: GO 99852
// for i in tmp do
99698: LD_ADDR_VAR 0 1
99702: PUSH
99703: LD_VAR 0 5
99707: PUSH
99708: FOR_IN
99709: IFFALSE 99850
// begin d := rand ( 0 , 5 ) ;
99711: LD_ADDR_VAR 0 4
99715: PUSH
99716: LD_INT 0
99718: PPUSH
99719: LD_INT 5
99721: PPUSH
99722: CALL_OW 12
99726: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
99727: LD_ADDR_VAR 0 2
99731: PUSH
99732: LD_VAR 0 1
99736: PPUSH
99737: CALL_OW 250
99741: PPUSH
99742: LD_VAR 0 4
99746: PPUSH
99747: LD_INT 3
99749: PPUSH
99750: LD_INT 12
99752: PPUSH
99753: CALL_OW 12
99757: PPUSH
99758: CALL_OW 272
99762: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
99763: LD_ADDR_VAR 0 3
99767: PUSH
99768: LD_VAR 0 1
99772: PPUSH
99773: CALL_OW 251
99777: PPUSH
99778: LD_VAR 0 4
99782: PPUSH
99783: LD_INT 3
99785: PPUSH
99786: LD_INT 12
99788: PPUSH
99789: CALL_OW 12
99793: PPUSH
99794: CALL_OW 273
99798: ST_TO_ADDR
// if ValidHex ( x , y ) then
99799: LD_VAR 0 2
99803: PPUSH
99804: LD_VAR 0 3
99808: PPUSH
99809: CALL_OW 488
99813: IFFALSE 99848
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
99815: LD_VAR 0 1
99819: PPUSH
99820: LD_VAR 0 2
99824: PPUSH
99825: LD_VAR 0 3
99829: PPUSH
99830: LD_INT 3
99832: PPUSH
99833: LD_INT 6
99835: PPUSH
99836: CALL_OW 12
99840: PPUSH
99841: LD_INT 1
99843: PPUSH
99844: CALL_OW 483
// end ;
99848: GO 99708
99850: POP
99851: POP
// end ;
99852: PPOPN 5
99854: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
99855: LD_EXP 96
99859: PUSH
99860: LD_EXP 131
99864: AND
99865: IFFALSE 99959
99867: GO 99869
99869: DISABLE
99870: LD_INT 0
99872: PPUSH
99873: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
99874: LD_ADDR_VAR 0 2
99878: PUSH
99879: LD_INT 22
99881: PUSH
99882: LD_OWVAR 2
99886: PUSH
99887: EMPTY
99888: LIST
99889: LIST
99890: PUSH
99891: LD_INT 32
99893: PUSH
99894: LD_INT 1
99896: PUSH
99897: EMPTY
99898: LIST
99899: LIST
99900: PUSH
99901: LD_INT 21
99903: PUSH
99904: LD_INT 2
99906: PUSH
99907: EMPTY
99908: LIST
99909: LIST
99910: PUSH
99911: EMPTY
99912: LIST
99913: LIST
99914: LIST
99915: PPUSH
99916: CALL_OW 69
99920: ST_TO_ADDR
// if not tmp then
99921: LD_VAR 0 2
99925: NOT
99926: IFFALSE 99930
// exit ;
99928: GO 99959
// for i in tmp do
99930: LD_ADDR_VAR 0 1
99934: PUSH
99935: LD_VAR 0 2
99939: PUSH
99940: FOR_IN
99941: IFFALSE 99957
// SetFuel ( i , 0 ) ;
99943: LD_VAR 0 1
99947: PPUSH
99948: LD_INT 0
99950: PPUSH
99951: CALL_OW 240
99955: GO 99940
99957: POP
99958: POP
// end ;
99959: PPOPN 2
99961: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
99962: LD_EXP 96
99966: PUSH
99967: LD_EXP 132
99971: AND
99972: IFFALSE 100038
99974: GO 99976
99976: DISABLE
99977: LD_INT 0
99979: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
99980: LD_ADDR_VAR 0 1
99984: PUSH
99985: LD_INT 22
99987: PUSH
99988: LD_OWVAR 2
99992: PUSH
99993: EMPTY
99994: LIST
99995: LIST
99996: PUSH
99997: LD_INT 30
99999: PUSH
100000: LD_INT 29
100002: PUSH
100003: EMPTY
100004: LIST
100005: LIST
100006: PUSH
100007: EMPTY
100008: LIST
100009: LIST
100010: PPUSH
100011: CALL_OW 69
100015: ST_TO_ADDR
// if not tmp then
100016: LD_VAR 0 1
100020: NOT
100021: IFFALSE 100025
// exit ;
100023: GO 100038
// DestroyUnit ( tmp [ 1 ] ) ;
100025: LD_VAR 0 1
100029: PUSH
100030: LD_INT 1
100032: ARRAY
100033: PPUSH
100034: CALL_OW 65
// end ;
100038: PPOPN 1
100040: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
100041: LD_EXP 96
100045: PUSH
100046: LD_EXP 134
100050: AND
100051: IFFALSE 100180
100053: GO 100055
100055: DISABLE
100056: LD_INT 0
100058: PPUSH
// begin uc_side := 0 ;
100059: LD_ADDR_OWVAR 20
100063: PUSH
100064: LD_INT 0
100066: ST_TO_ADDR
// uc_nation := nation_arabian ;
100067: LD_ADDR_OWVAR 21
100071: PUSH
100072: LD_INT 2
100074: ST_TO_ADDR
// hc_gallery :=  ;
100075: LD_ADDR_OWVAR 33
100079: PUSH
100080: LD_STRING 
100082: ST_TO_ADDR
// hc_name :=  ;
100083: LD_ADDR_OWVAR 26
100087: PUSH
100088: LD_STRING 
100090: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
100091: LD_INT 1
100093: PPUSH
100094: LD_INT 11
100096: PPUSH
100097: LD_INT 10
100099: PPUSH
100100: CALL_OW 380
// un := CreateHuman ;
100104: LD_ADDR_VAR 0 1
100108: PUSH
100109: CALL_OW 44
100113: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
100114: LD_VAR 0 1
100118: PPUSH
100119: LD_INT 1
100121: PPUSH
100122: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
100126: LD_INT 35
100128: PPUSH
100129: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
100133: LD_VAR 0 1
100137: PPUSH
100138: LD_INT 22
100140: PUSH
100141: LD_OWVAR 2
100145: PUSH
100146: EMPTY
100147: LIST
100148: LIST
100149: PPUSH
100150: CALL_OW 69
100154: PPUSH
100155: LD_VAR 0 1
100159: PPUSH
100160: CALL_OW 74
100164: PPUSH
100165: CALL_OW 115
// until IsDead ( un ) ;
100169: LD_VAR 0 1
100173: PPUSH
100174: CALL_OW 301
100178: IFFALSE 100126
// end ;
100180: PPOPN 1
100182: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
100183: LD_EXP 96
100187: PUSH
100188: LD_EXP 136
100192: AND
100193: IFFALSE 100205
100195: GO 100197
100197: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
100198: LD_STRING earthquake(getX(game), 0, 32)
100200: PPUSH
100201: CALL_OW 559
100205: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
100206: LD_EXP 96
100210: PUSH
100211: LD_EXP 137
100215: AND
100216: IFFALSE 100307
100218: GO 100220
100220: DISABLE
100221: LD_INT 0
100223: PPUSH
// begin enable ;
100224: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
100225: LD_ADDR_VAR 0 1
100229: PUSH
100230: LD_INT 22
100232: PUSH
100233: LD_OWVAR 2
100237: PUSH
100238: EMPTY
100239: LIST
100240: LIST
100241: PUSH
100242: LD_INT 21
100244: PUSH
100245: LD_INT 2
100247: PUSH
100248: EMPTY
100249: LIST
100250: LIST
100251: PUSH
100252: LD_INT 33
100254: PUSH
100255: LD_INT 3
100257: PUSH
100258: EMPTY
100259: LIST
100260: LIST
100261: PUSH
100262: EMPTY
100263: LIST
100264: LIST
100265: LIST
100266: PPUSH
100267: CALL_OW 69
100271: ST_TO_ADDR
// if not tmp then
100272: LD_VAR 0 1
100276: NOT
100277: IFFALSE 100281
// exit ;
100279: GO 100307
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
100281: LD_VAR 0 1
100285: PUSH
100286: LD_INT 1
100288: PPUSH
100289: LD_VAR 0 1
100293: PPUSH
100294: CALL_OW 12
100298: ARRAY
100299: PPUSH
100300: LD_INT 1
100302: PPUSH
100303: CALL_OW 234
// end ;
100307: PPOPN 1
100309: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
100310: LD_EXP 96
100314: PUSH
100315: LD_EXP 138
100319: AND
100320: IFFALSE 100461
100322: GO 100324
100324: DISABLE
100325: LD_INT 0
100327: PPUSH
100328: PPUSH
100329: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
100330: LD_ADDR_VAR 0 3
100334: PUSH
100335: LD_INT 22
100337: PUSH
100338: LD_OWVAR 2
100342: PUSH
100343: EMPTY
100344: LIST
100345: LIST
100346: PUSH
100347: LD_INT 25
100349: PUSH
100350: LD_INT 1
100352: PUSH
100353: EMPTY
100354: LIST
100355: LIST
100356: PUSH
100357: EMPTY
100358: LIST
100359: LIST
100360: PPUSH
100361: CALL_OW 69
100365: ST_TO_ADDR
// if not tmp then
100366: LD_VAR 0 3
100370: NOT
100371: IFFALSE 100375
// exit ;
100373: GO 100461
// un := tmp [ rand ( 1 , tmp ) ] ;
100375: LD_ADDR_VAR 0 2
100379: PUSH
100380: LD_VAR 0 3
100384: PUSH
100385: LD_INT 1
100387: PPUSH
100388: LD_VAR 0 3
100392: PPUSH
100393: CALL_OW 12
100397: ARRAY
100398: ST_TO_ADDR
// if Crawls ( un ) then
100399: LD_VAR 0 2
100403: PPUSH
100404: CALL_OW 318
100408: IFFALSE 100419
// ComWalk ( un ) ;
100410: LD_VAR 0 2
100414: PPUSH
100415: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
100419: LD_VAR 0 2
100423: PPUSH
100424: LD_INT 9
100426: PPUSH
100427: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
100431: LD_INT 28
100433: PPUSH
100434: LD_OWVAR 2
100438: PPUSH
100439: LD_INT 2
100441: PPUSH
100442: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
100446: LD_INT 29
100448: PPUSH
100449: LD_OWVAR 2
100453: PPUSH
100454: LD_INT 2
100456: PPUSH
100457: CALL_OW 322
// end ;
100461: PPOPN 3
100463: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
100464: LD_EXP 96
100468: PUSH
100469: LD_EXP 139
100473: AND
100474: IFFALSE 100585
100476: GO 100478
100478: DISABLE
100479: LD_INT 0
100481: PPUSH
100482: PPUSH
100483: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
100484: LD_ADDR_VAR 0 3
100488: PUSH
100489: LD_INT 22
100491: PUSH
100492: LD_OWVAR 2
100496: PUSH
100497: EMPTY
100498: LIST
100499: LIST
100500: PUSH
100501: LD_INT 25
100503: PUSH
100504: LD_INT 1
100506: PUSH
100507: EMPTY
100508: LIST
100509: LIST
100510: PUSH
100511: EMPTY
100512: LIST
100513: LIST
100514: PPUSH
100515: CALL_OW 69
100519: ST_TO_ADDR
// if not tmp then
100520: LD_VAR 0 3
100524: NOT
100525: IFFALSE 100529
// exit ;
100527: GO 100585
// un := tmp [ rand ( 1 , tmp ) ] ;
100529: LD_ADDR_VAR 0 2
100533: PUSH
100534: LD_VAR 0 3
100538: PUSH
100539: LD_INT 1
100541: PPUSH
100542: LD_VAR 0 3
100546: PPUSH
100547: CALL_OW 12
100551: ARRAY
100552: ST_TO_ADDR
// if Crawls ( un ) then
100553: LD_VAR 0 2
100557: PPUSH
100558: CALL_OW 318
100562: IFFALSE 100573
// ComWalk ( un ) ;
100564: LD_VAR 0 2
100568: PPUSH
100569: CALL_OW 138
// SetClass ( un , class_mortar ) ;
100573: LD_VAR 0 2
100577: PPUSH
100578: LD_INT 8
100580: PPUSH
100581: CALL_OW 336
// end ;
100585: PPOPN 3
100587: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
100588: LD_EXP 96
100592: PUSH
100593: LD_EXP 140
100597: AND
100598: IFFALSE 100742
100600: GO 100602
100602: DISABLE
100603: LD_INT 0
100605: PPUSH
100606: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
100607: LD_ADDR_VAR 0 2
100611: PUSH
100612: LD_INT 22
100614: PUSH
100615: LD_OWVAR 2
100619: PUSH
100620: EMPTY
100621: LIST
100622: LIST
100623: PUSH
100624: LD_INT 21
100626: PUSH
100627: LD_INT 2
100629: PUSH
100630: EMPTY
100631: LIST
100632: LIST
100633: PUSH
100634: LD_INT 2
100636: PUSH
100637: LD_INT 34
100639: PUSH
100640: LD_INT 12
100642: PUSH
100643: EMPTY
100644: LIST
100645: LIST
100646: PUSH
100647: LD_INT 34
100649: PUSH
100650: LD_INT 51
100652: PUSH
100653: EMPTY
100654: LIST
100655: LIST
100656: PUSH
100657: LD_INT 34
100659: PUSH
100660: LD_INT 32
100662: PUSH
100663: EMPTY
100664: LIST
100665: LIST
100666: PUSH
100667: EMPTY
100668: LIST
100669: LIST
100670: LIST
100671: LIST
100672: PUSH
100673: EMPTY
100674: LIST
100675: LIST
100676: LIST
100677: PPUSH
100678: CALL_OW 69
100682: ST_TO_ADDR
// if not tmp then
100683: LD_VAR 0 2
100687: NOT
100688: IFFALSE 100692
// exit ;
100690: GO 100742
// for i in tmp do
100692: LD_ADDR_VAR 0 1
100696: PUSH
100697: LD_VAR 0 2
100701: PUSH
100702: FOR_IN
100703: IFFALSE 100740
// if GetCargo ( i , mat_artifact ) = 0 then
100705: LD_VAR 0 1
100709: PPUSH
100710: LD_INT 4
100712: PPUSH
100713: CALL_OW 289
100717: PUSH
100718: LD_INT 0
100720: EQUAL
100721: IFFALSE 100738
// SetCargo ( i , mat_siberit , 100 ) ;
100723: LD_VAR 0 1
100727: PPUSH
100728: LD_INT 3
100730: PPUSH
100731: LD_INT 100
100733: PPUSH
100734: CALL_OW 290
100738: GO 100702
100740: POP
100741: POP
// end ;
100742: PPOPN 2
100744: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
100745: LD_EXP 96
100749: PUSH
100750: LD_EXP 141
100754: AND
100755: IFFALSE 100938
100757: GO 100759
100759: DISABLE
100760: LD_INT 0
100762: PPUSH
100763: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
100764: LD_ADDR_VAR 0 2
100768: PUSH
100769: LD_INT 22
100771: PUSH
100772: LD_OWVAR 2
100776: PUSH
100777: EMPTY
100778: LIST
100779: LIST
100780: PPUSH
100781: CALL_OW 69
100785: ST_TO_ADDR
// if not tmp then
100786: LD_VAR 0 2
100790: NOT
100791: IFFALSE 100795
// exit ;
100793: GO 100938
// for i := 1 to 2 do
100795: LD_ADDR_VAR 0 1
100799: PUSH
100800: DOUBLE
100801: LD_INT 1
100803: DEC
100804: ST_TO_ADDR
100805: LD_INT 2
100807: PUSH
100808: FOR_TO
100809: IFFALSE 100936
// begin uc_side := your_side ;
100811: LD_ADDR_OWVAR 20
100815: PUSH
100816: LD_OWVAR 2
100820: ST_TO_ADDR
// uc_nation := nation_american ;
100821: LD_ADDR_OWVAR 21
100825: PUSH
100826: LD_INT 1
100828: ST_TO_ADDR
// vc_chassis := us_morphling ;
100829: LD_ADDR_OWVAR 37
100833: PUSH
100834: LD_INT 5
100836: ST_TO_ADDR
// vc_engine := engine_siberite ;
100837: LD_ADDR_OWVAR 39
100841: PUSH
100842: LD_INT 3
100844: ST_TO_ADDR
// vc_control := control_computer ;
100845: LD_ADDR_OWVAR 38
100849: PUSH
100850: LD_INT 3
100852: ST_TO_ADDR
// vc_weapon := us_double_laser ;
100853: LD_ADDR_OWVAR 40
100857: PUSH
100858: LD_INT 10
100860: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
100861: LD_VAR 0 2
100865: PUSH
100866: LD_INT 1
100868: ARRAY
100869: PPUSH
100870: CALL_OW 310
100874: NOT
100875: IFFALSE 100922
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
100877: CALL_OW 45
100881: PPUSH
100882: LD_VAR 0 2
100886: PUSH
100887: LD_INT 1
100889: ARRAY
100890: PPUSH
100891: CALL_OW 250
100895: PPUSH
100896: LD_VAR 0 2
100900: PUSH
100901: LD_INT 1
100903: ARRAY
100904: PPUSH
100905: CALL_OW 251
100909: PPUSH
100910: LD_INT 12
100912: PPUSH
100913: LD_INT 1
100915: PPUSH
100916: CALL_OW 50
100920: GO 100934
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
100922: CALL_OW 45
100926: PPUSH
100927: LD_INT 1
100929: PPUSH
100930: CALL_OW 51
// end ;
100934: GO 100808
100936: POP
100937: POP
// end ;
100938: PPOPN 2
100940: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
100941: LD_EXP 96
100945: PUSH
100946: LD_EXP 142
100950: AND
100951: IFFALSE 101173
100953: GO 100955
100955: DISABLE
100956: LD_INT 0
100958: PPUSH
100959: PPUSH
100960: PPUSH
100961: PPUSH
100962: PPUSH
100963: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
100964: LD_ADDR_VAR 0 6
100968: PUSH
100969: LD_INT 22
100971: PUSH
100972: LD_OWVAR 2
100976: PUSH
100977: EMPTY
100978: LIST
100979: LIST
100980: PUSH
100981: LD_INT 21
100983: PUSH
100984: LD_INT 1
100986: PUSH
100987: EMPTY
100988: LIST
100989: LIST
100990: PUSH
100991: LD_INT 3
100993: PUSH
100994: LD_INT 23
100996: PUSH
100997: LD_INT 0
100999: PUSH
101000: EMPTY
101001: LIST
101002: LIST
101003: PUSH
101004: EMPTY
101005: LIST
101006: LIST
101007: PUSH
101008: EMPTY
101009: LIST
101010: LIST
101011: LIST
101012: PPUSH
101013: CALL_OW 69
101017: ST_TO_ADDR
// if not tmp then
101018: LD_VAR 0 6
101022: NOT
101023: IFFALSE 101027
// exit ;
101025: GO 101173
// s1 := rand ( 1 , 4 ) ;
101027: LD_ADDR_VAR 0 2
101031: PUSH
101032: LD_INT 1
101034: PPUSH
101035: LD_INT 4
101037: PPUSH
101038: CALL_OW 12
101042: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
101043: LD_ADDR_VAR 0 4
101047: PUSH
101048: LD_VAR 0 6
101052: PUSH
101053: LD_INT 1
101055: ARRAY
101056: PPUSH
101057: LD_VAR 0 2
101061: PPUSH
101062: CALL_OW 259
101066: ST_TO_ADDR
// if s1 = 1 then
101067: LD_VAR 0 2
101071: PUSH
101072: LD_INT 1
101074: EQUAL
101075: IFFALSE 101095
// s2 := rand ( 2 , 4 ) else
101077: LD_ADDR_VAR 0 3
101081: PUSH
101082: LD_INT 2
101084: PPUSH
101085: LD_INT 4
101087: PPUSH
101088: CALL_OW 12
101092: ST_TO_ADDR
101093: GO 101103
// s2 := 1 ;
101095: LD_ADDR_VAR 0 3
101099: PUSH
101100: LD_INT 1
101102: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
101103: LD_ADDR_VAR 0 5
101107: PUSH
101108: LD_VAR 0 6
101112: PUSH
101113: LD_INT 1
101115: ARRAY
101116: PPUSH
101117: LD_VAR 0 3
101121: PPUSH
101122: CALL_OW 259
101126: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
101127: LD_VAR 0 6
101131: PUSH
101132: LD_INT 1
101134: ARRAY
101135: PPUSH
101136: LD_VAR 0 2
101140: PPUSH
101141: LD_VAR 0 5
101145: PPUSH
101146: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
101150: LD_VAR 0 6
101154: PUSH
101155: LD_INT 1
101157: ARRAY
101158: PPUSH
101159: LD_VAR 0 3
101163: PPUSH
101164: LD_VAR 0 4
101168: PPUSH
101169: CALL_OW 237
// end ;
101173: PPOPN 6
101175: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
101176: LD_EXP 96
101180: PUSH
101181: LD_EXP 143
101185: AND
101186: IFFALSE 101265
101188: GO 101190
101190: DISABLE
101191: LD_INT 0
101193: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
101194: LD_ADDR_VAR 0 1
101198: PUSH
101199: LD_INT 22
101201: PUSH
101202: LD_OWVAR 2
101206: PUSH
101207: EMPTY
101208: LIST
101209: LIST
101210: PUSH
101211: LD_INT 30
101213: PUSH
101214: LD_INT 3
101216: PUSH
101217: EMPTY
101218: LIST
101219: LIST
101220: PUSH
101221: EMPTY
101222: LIST
101223: LIST
101224: PPUSH
101225: CALL_OW 69
101229: ST_TO_ADDR
// if not tmp then
101230: LD_VAR 0 1
101234: NOT
101235: IFFALSE 101239
// exit ;
101237: GO 101265
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
101239: LD_VAR 0 1
101243: PUSH
101244: LD_INT 1
101246: PPUSH
101247: LD_VAR 0 1
101251: PPUSH
101252: CALL_OW 12
101256: ARRAY
101257: PPUSH
101258: LD_INT 1
101260: PPUSH
101261: CALL_OW 234
// end ;
101265: PPOPN 1
101267: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
101268: LD_EXP 96
101272: PUSH
101273: LD_EXP 144
101277: AND
101278: IFFALSE 101390
101280: GO 101282
101282: DISABLE
101283: LD_INT 0
101285: PPUSH
101286: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
101287: LD_ADDR_VAR 0 2
101291: PUSH
101292: LD_INT 22
101294: PUSH
101295: LD_OWVAR 2
101299: PUSH
101300: EMPTY
101301: LIST
101302: LIST
101303: PUSH
101304: LD_INT 2
101306: PUSH
101307: LD_INT 30
101309: PUSH
101310: LD_INT 27
101312: PUSH
101313: EMPTY
101314: LIST
101315: LIST
101316: PUSH
101317: LD_INT 30
101319: PUSH
101320: LD_INT 26
101322: PUSH
101323: EMPTY
101324: LIST
101325: LIST
101326: PUSH
101327: LD_INT 30
101329: PUSH
101330: LD_INT 28
101332: PUSH
101333: EMPTY
101334: LIST
101335: LIST
101336: PUSH
101337: EMPTY
101338: LIST
101339: LIST
101340: LIST
101341: LIST
101342: PUSH
101343: EMPTY
101344: LIST
101345: LIST
101346: PPUSH
101347: CALL_OW 69
101351: ST_TO_ADDR
// if not tmp then
101352: LD_VAR 0 2
101356: NOT
101357: IFFALSE 101361
// exit ;
101359: GO 101390
// for i in tmp do
101361: LD_ADDR_VAR 0 1
101365: PUSH
101366: LD_VAR 0 2
101370: PUSH
101371: FOR_IN
101372: IFFALSE 101388
// SetLives ( i , 1 ) ;
101374: LD_VAR 0 1
101378: PPUSH
101379: LD_INT 1
101381: PPUSH
101382: CALL_OW 234
101386: GO 101371
101388: POP
101389: POP
// end ;
101390: PPOPN 2
101392: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
101393: LD_EXP 96
101397: PUSH
101398: LD_EXP 145
101402: AND
101403: IFFALSE 101690
101405: GO 101407
101407: DISABLE
101408: LD_INT 0
101410: PPUSH
101411: PPUSH
101412: PPUSH
// begin i := rand ( 1 , 7 ) ;
101413: LD_ADDR_VAR 0 1
101417: PUSH
101418: LD_INT 1
101420: PPUSH
101421: LD_INT 7
101423: PPUSH
101424: CALL_OW 12
101428: ST_TO_ADDR
// case i of 1 :
101429: LD_VAR 0 1
101433: PUSH
101434: LD_INT 1
101436: DOUBLE
101437: EQUAL
101438: IFTRUE 101442
101440: GO 101452
101442: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
101443: LD_STRING earthquake(getX(game), 0, 32)
101445: PPUSH
101446: CALL_OW 559
101450: GO 101690
101452: LD_INT 2
101454: DOUBLE
101455: EQUAL
101456: IFTRUE 101460
101458: GO 101474
101460: POP
// begin ToLua ( displayStucuk(); ) ;
101461: LD_STRING displayStucuk();
101463: PPUSH
101464: CALL_OW 559
// ResetFog ;
101468: CALL_OW 335
// end ; 3 :
101472: GO 101690
101474: LD_INT 3
101476: DOUBLE
101477: EQUAL
101478: IFTRUE 101482
101480: GO 101586
101482: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
101483: LD_ADDR_VAR 0 2
101487: PUSH
101488: LD_INT 22
101490: PUSH
101491: LD_OWVAR 2
101495: PUSH
101496: EMPTY
101497: LIST
101498: LIST
101499: PUSH
101500: LD_INT 25
101502: PUSH
101503: LD_INT 1
101505: PUSH
101506: EMPTY
101507: LIST
101508: LIST
101509: PUSH
101510: EMPTY
101511: LIST
101512: LIST
101513: PPUSH
101514: CALL_OW 69
101518: ST_TO_ADDR
// if not tmp then
101519: LD_VAR 0 2
101523: NOT
101524: IFFALSE 101528
// exit ;
101526: GO 101690
// un := tmp [ rand ( 1 , tmp ) ] ;
101528: LD_ADDR_VAR 0 3
101532: PUSH
101533: LD_VAR 0 2
101537: PUSH
101538: LD_INT 1
101540: PPUSH
101541: LD_VAR 0 2
101545: PPUSH
101546: CALL_OW 12
101550: ARRAY
101551: ST_TO_ADDR
// if Crawls ( un ) then
101552: LD_VAR 0 3
101556: PPUSH
101557: CALL_OW 318
101561: IFFALSE 101572
// ComWalk ( un ) ;
101563: LD_VAR 0 3
101567: PPUSH
101568: CALL_OW 138
// SetClass ( un , class_mortar ) ;
101572: LD_VAR 0 3
101576: PPUSH
101577: LD_INT 8
101579: PPUSH
101580: CALL_OW 336
// end ; 4 :
101584: GO 101690
101586: LD_INT 4
101588: DOUBLE
101589: EQUAL
101590: IFTRUE 101594
101592: GO 101668
101594: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
101595: LD_ADDR_VAR 0 2
101599: PUSH
101600: LD_INT 22
101602: PUSH
101603: LD_OWVAR 2
101607: PUSH
101608: EMPTY
101609: LIST
101610: LIST
101611: PUSH
101612: LD_INT 30
101614: PUSH
101615: LD_INT 29
101617: PUSH
101618: EMPTY
101619: LIST
101620: LIST
101621: PUSH
101622: EMPTY
101623: LIST
101624: LIST
101625: PPUSH
101626: CALL_OW 69
101630: ST_TO_ADDR
// if not tmp then
101631: LD_VAR 0 2
101635: NOT
101636: IFFALSE 101640
// exit ;
101638: GO 101690
// CenterNowOnUnits ( tmp [ 1 ] ) ;
101640: LD_VAR 0 2
101644: PUSH
101645: LD_INT 1
101647: ARRAY
101648: PPUSH
101649: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
101653: LD_VAR 0 2
101657: PUSH
101658: LD_INT 1
101660: ARRAY
101661: PPUSH
101662: CALL_OW 65
// end ; 5 .. 7 :
101666: GO 101690
101668: LD_INT 5
101670: DOUBLE
101671: GREATEREQUAL
101672: IFFALSE 101680
101674: LD_INT 7
101676: DOUBLE
101677: LESSEQUAL
101678: IFTRUE 101682
101680: GO 101689
101682: POP
// StreamSibBomb ; end ;
101683: CALL 97927 0 0
101687: GO 101690
101689: POP
// end ;
101690: PPOPN 3
101692: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
101693: LD_EXP 96
101697: PUSH
101698: LD_EXP 146
101702: AND
101703: IFFALSE 101859
101705: GO 101707
101707: DISABLE
101708: LD_INT 0
101710: PPUSH
101711: PPUSH
101712: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
101713: LD_ADDR_VAR 0 2
101717: PUSH
101718: LD_INT 81
101720: PUSH
101721: LD_OWVAR 2
101725: PUSH
101726: EMPTY
101727: LIST
101728: LIST
101729: PUSH
101730: LD_INT 2
101732: PUSH
101733: LD_INT 21
101735: PUSH
101736: LD_INT 1
101738: PUSH
101739: EMPTY
101740: LIST
101741: LIST
101742: PUSH
101743: LD_INT 21
101745: PUSH
101746: LD_INT 2
101748: PUSH
101749: EMPTY
101750: LIST
101751: LIST
101752: PUSH
101753: EMPTY
101754: LIST
101755: LIST
101756: LIST
101757: PUSH
101758: EMPTY
101759: LIST
101760: LIST
101761: PPUSH
101762: CALL_OW 69
101766: ST_TO_ADDR
// if not tmp then
101767: LD_VAR 0 2
101771: NOT
101772: IFFALSE 101776
// exit ;
101774: GO 101859
// p := 0 ;
101776: LD_ADDR_VAR 0 3
101780: PUSH
101781: LD_INT 0
101783: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
101784: LD_INT 35
101786: PPUSH
101787: CALL_OW 67
// p := p + 1 ;
101791: LD_ADDR_VAR 0 3
101795: PUSH
101796: LD_VAR 0 3
101800: PUSH
101801: LD_INT 1
101803: PLUS
101804: ST_TO_ADDR
// for i in tmp do
101805: LD_ADDR_VAR 0 1
101809: PUSH
101810: LD_VAR 0 2
101814: PUSH
101815: FOR_IN
101816: IFFALSE 101847
// if GetLives ( i ) < 1000 then
101818: LD_VAR 0 1
101822: PPUSH
101823: CALL_OW 256
101827: PUSH
101828: LD_INT 1000
101830: LESS
101831: IFFALSE 101845
// SetLives ( i , 1000 ) ;
101833: LD_VAR 0 1
101837: PPUSH
101838: LD_INT 1000
101840: PPUSH
101841: CALL_OW 234
101845: GO 101815
101847: POP
101848: POP
// until p > 20 ;
101849: LD_VAR 0 3
101853: PUSH
101854: LD_INT 20
101856: GREATER
101857: IFFALSE 101784
// end ;
101859: PPOPN 3
101861: END
// every 0 0$1 trigger StreamModeActive and sTime do
101862: LD_EXP 96
101866: PUSH
101867: LD_EXP 147
101871: AND
101872: IFFALSE 101907
101874: GO 101876
101876: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
101877: LD_INT 28
101879: PPUSH
101880: LD_OWVAR 2
101884: PPUSH
101885: LD_INT 2
101887: PPUSH
101888: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
101892: LD_INT 30
101894: PPUSH
101895: LD_OWVAR 2
101899: PPUSH
101900: LD_INT 2
101902: PPUSH
101903: CALL_OW 322
// end ;
101907: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
101908: LD_EXP 96
101912: PUSH
101913: LD_EXP 148
101917: AND
101918: IFFALSE 102039
101920: GO 101922
101922: DISABLE
101923: LD_INT 0
101925: PPUSH
101926: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
101927: LD_ADDR_VAR 0 2
101931: PUSH
101932: LD_INT 22
101934: PUSH
101935: LD_OWVAR 2
101939: PUSH
101940: EMPTY
101941: LIST
101942: LIST
101943: PUSH
101944: LD_INT 21
101946: PUSH
101947: LD_INT 1
101949: PUSH
101950: EMPTY
101951: LIST
101952: LIST
101953: PUSH
101954: LD_INT 3
101956: PUSH
101957: LD_INT 23
101959: PUSH
101960: LD_INT 0
101962: PUSH
101963: EMPTY
101964: LIST
101965: LIST
101966: PUSH
101967: EMPTY
101968: LIST
101969: LIST
101970: PUSH
101971: EMPTY
101972: LIST
101973: LIST
101974: LIST
101975: PPUSH
101976: CALL_OW 69
101980: ST_TO_ADDR
// if not tmp then
101981: LD_VAR 0 2
101985: NOT
101986: IFFALSE 101990
// exit ;
101988: GO 102039
// for i in tmp do
101990: LD_ADDR_VAR 0 1
101994: PUSH
101995: LD_VAR 0 2
101999: PUSH
102000: FOR_IN
102001: IFFALSE 102037
// begin if Crawls ( i ) then
102003: LD_VAR 0 1
102007: PPUSH
102008: CALL_OW 318
102012: IFFALSE 102023
// ComWalk ( i ) ;
102014: LD_VAR 0 1
102018: PPUSH
102019: CALL_OW 138
// SetClass ( i , 2 ) ;
102023: LD_VAR 0 1
102027: PPUSH
102028: LD_INT 2
102030: PPUSH
102031: CALL_OW 336
// end ;
102035: GO 102000
102037: POP
102038: POP
// end ;
102039: PPOPN 2
102041: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
102042: LD_EXP 96
102046: PUSH
102047: LD_EXP 149
102051: AND
102052: IFFALSE 102340
102054: GO 102056
102056: DISABLE
102057: LD_INT 0
102059: PPUSH
102060: PPUSH
102061: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
102062: LD_OWVAR 2
102066: PPUSH
102067: LD_INT 9
102069: PPUSH
102070: LD_INT 1
102072: PPUSH
102073: LD_INT 1
102075: PPUSH
102076: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
102080: LD_INT 9
102082: PPUSH
102083: LD_OWVAR 2
102087: PPUSH
102088: CALL_OW 343
// uc_side := 9 ;
102092: LD_ADDR_OWVAR 20
102096: PUSH
102097: LD_INT 9
102099: ST_TO_ADDR
// uc_nation := 2 ;
102100: LD_ADDR_OWVAR 21
102104: PUSH
102105: LD_INT 2
102107: ST_TO_ADDR
// hc_name := Dark Warrior ;
102108: LD_ADDR_OWVAR 26
102112: PUSH
102113: LD_STRING Dark Warrior
102115: ST_TO_ADDR
// hc_gallery :=  ;
102116: LD_ADDR_OWVAR 33
102120: PUSH
102121: LD_STRING 
102123: ST_TO_ADDR
// hc_noskilllimit := true ;
102124: LD_ADDR_OWVAR 76
102128: PUSH
102129: LD_INT 1
102131: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
102132: LD_ADDR_OWVAR 31
102136: PUSH
102137: LD_INT 30
102139: PUSH
102140: LD_INT 30
102142: PUSH
102143: LD_INT 30
102145: PUSH
102146: LD_INT 30
102148: PUSH
102149: EMPTY
102150: LIST
102151: LIST
102152: LIST
102153: LIST
102154: ST_TO_ADDR
// un := CreateHuman ;
102155: LD_ADDR_VAR 0 3
102159: PUSH
102160: CALL_OW 44
102164: ST_TO_ADDR
// hc_noskilllimit := false ;
102165: LD_ADDR_OWVAR 76
102169: PUSH
102170: LD_INT 0
102172: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
102173: LD_VAR 0 3
102177: PPUSH
102178: LD_INT 1
102180: PPUSH
102181: CALL_OW 51
// ToLua ( playRanger() ) ;
102185: LD_STRING playRanger()
102187: PPUSH
102188: CALL_OW 559
// p := 0 ;
102192: LD_ADDR_VAR 0 2
102196: PUSH
102197: LD_INT 0
102199: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
102200: LD_INT 35
102202: PPUSH
102203: CALL_OW 67
// p := p + 1 ;
102207: LD_ADDR_VAR 0 2
102211: PUSH
102212: LD_VAR 0 2
102216: PUSH
102217: LD_INT 1
102219: PLUS
102220: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
102221: LD_VAR 0 3
102225: PPUSH
102226: CALL_OW 256
102230: PUSH
102231: LD_INT 1000
102233: LESS
102234: IFFALSE 102248
// SetLives ( un , 1000 ) ;
102236: LD_VAR 0 3
102240: PPUSH
102241: LD_INT 1000
102243: PPUSH
102244: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
102248: LD_VAR 0 3
102252: PPUSH
102253: LD_INT 81
102255: PUSH
102256: LD_OWVAR 2
102260: PUSH
102261: EMPTY
102262: LIST
102263: LIST
102264: PUSH
102265: LD_INT 91
102267: PUSH
102268: LD_VAR 0 3
102272: PUSH
102273: LD_INT 30
102275: PUSH
102276: EMPTY
102277: LIST
102278: LIST
102279: LIST
102280: PUSH
102281: EMPTY
102282: LIST
102283: LIST
102284: PPUSH
102285: CALL_OW 69
102289: PPUSH
102290: LD_VAR 0 3
102294: PPUSH
102295: CALL_OW 74
102299: PPUSH
102300: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
102304: LD_VAR 0 2
102308: PUSH
102309: LD_INT 80
102311: GREATER
102312: PUSH
102313: LD_VAR 0 3
102317: PPUSH
102318: CALL_OW 301
102322: OR
102323: IFFALSE 102200
// if un then
102325: LD_VAR 0 3
102329: IFFALSE 102340
// RemoveUnit ( un ) ;
102331: LD_VAR 0 3
102335: PPUSH
102336: CALL_OW 64
// end ;
102340: PPOPN 3
102342: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
102343: LD_EXP 150
102347: IFFALSE 102463
102349: GO 102351
102351: DISABLE
102352: LD_INT 0
102354: PPUSH
102355: PPUSH
102356: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
102357: LD_ADDR_VAR 0 2
102361: PUSH
102362: LD_INT 81
102364: PUSH
102365: LD_OWVAR 2
102369: PUSH
102370: EMPTY
102371: LIST
102372: LIST
102373: PUSH
102374: LD_INT 21
102376: PUSH
102377: LD_INT 1
102379: PUSH
102380: EMPTY
102381: LIST
102382: LIST
102383: PUSH
102384: EMPTY
102385: LIST
102386: LIST
102387: PPUSH
102388: CALL_OW 69
102392: ST_TO_ADDR
// ToLua ( playComputer() ) ;
102393: LD_STRING playComputer()
102395: PPUSH
102396: CALL_OW 559
// if not tmp then
102400: LD_VAR 0 2
102404: NOT
102405: IFFALSE 102409
// exit ;
102407: GO 102463
// for i in tmp do
102409: LD_ADDR_VAR 0 1
102413: PUSH
102414: LD_VAR 0 2
102418: PUSH
102419: FOR_IN
102420: IFFALSE 102461
// for j := 1 to 4 do
102422: LD_ADDR_VAR 0 3
102426: PUSH
102427: DOUBLE
102428: LD_INT 1
102430: DEC
102431: ST_TO_ADDR
102432: LD_INT 4
102434: PUSH
102435: FOR_TO
102436: IFFALSE 102457
// SetSkill ( i , j , 10 ) ;
102438: LD_VAR 0 1
102442: PPUSH
102443: LD_VAR 0 3
102447: PPUSH
102448: LD_INT 10
102450: PPUSH
102451: CALL_OW 237
102455: GO 102435
102457: POP
102458: POP
102459: GO 102419
102461: POP
102462: POP
// end ;
102463: PPOPN 3
102465: END
// every 0 0$1 trigger s30 do var i , tmp ;
102466: LD_EXP 151
102470: IFFALSE 102539
102472: GO 102474
102474: DISABLE
102475: LD_INT 0
102477: PPUSH
102478: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
102479: LD_ADDR_VAR 0 2
102483: PUSH
102484: LD_INT 22
102486: PUSH
102487: LD_OWVAR 2
102491: PUSH
102492: EMPTY
102493: LIST
102494: LIST
102495: PPUSH
102496: CALL_OW 69
102500: ST_TO_ADDR
// if not tmp then
102501: LD_VAR 0 2
102505: NOT
102506: IFFALSE 102510
// exit ;
102508: GO 102539
// for i in tmp do
102510: LD_ADDR_VAR 0 1
102514: PUSH
102515: LD_VAR 0 2
102519: PUSH
102520: FOR_IN
102521: IFFALSE 102537
// SetLives ( i , 300 ) ;
102523: LD_VAR 0 1
102527: PPUSH
102528: LD_INT 300
102530: PPUSH
102531: CALL_OW 234
102535: GO 102520
102537: POP
102538: POP
// end ;
102539: PPOPN 2
102541: END
// every 0 0$1 trigger s60 do var i , tmp ;
102542: LD_EXP 152
102546: IFFALSE 102615
102548: GO 102550
102550: DISABLE
102551: LD_INT 0
102553: PPUSH
102554: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
102555: LD_ADDR_VAR 0 2
102559: PUSH
102560: LD_INT 22
102562: PUSH
102563: LD_OWVAR 2
102567: PUSH
102568: EMPTY
102569: LIST
102570: LIST
102571: PPUSH
102572: CALL_OW 69
102576: ST_TO_ADDR
// if not tmp then
102577: LD_VAR 0 2
102581: NOT
102582: IFFALSE 102586
// exit ;
102584: GO 102615
// for i in tmp do
102586: LD_ADDR_VAR 0 1
102590: PUSH
102591: LD_VAR 0 2
102595: PUSH
102596: FOR_IN
102597: IFFALSE 102613
// SetLives ( i , 600 ) ;
102599: LD_VAR 0 1
102603: PPUSH
102604: LD_INT 600
102606: PPUSH
102607: CALL_OW 234
102611: GO 102596
102613: POP
102614: POP
// end ;
102615: PPOPN 2
102617: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
102618: LD_INT 0
102620: PPUSH
// case cmd of 301 :
102621: LD_VAR 0 1
102625: PUSH
102626: LD_INT 301
102628: DOUBLE
102629: EQUAL
102630: IFTRUE 102634
102632: GO 102666
102634: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
102635: LD_VAR 0 6
102639: PPUSH
102640: LD_VAR 0 7
102644: PPUSH
102645: LD_VAR 0 8
102649: PPUSH
102650: LD_VAR 0 4
102654: PPUSH
102655: LD_VAR 0 5
102659: PPUSH
102660: CALL 103867 0 5
102664: GO 102787
102666: LD_INT 302
102668: DOUBLE
102669: EQUAL
102670: IFTRUE 102674
102672: GO 102711
102674: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
102675: LD_VAR 0 6
102679: PPUSH
102680: LD_VAR 0 7
102684: PPUSH
102685: LD_VAR 0 8
102689: PPUSH
102690: LD_VAR 0 9
102694: PPUSH
102695: LD_VAR 0 4
102699: PPUSH
102700: LD_VAR 0 5
102704: PPUSH
102705: CALL 103958 0 6
102709: GO 102787
102711: LD_INT 303
102713: DOUBLE
102714: EQUAL
102715: IFTRUE 102719
102717: GO 102756
102719: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
102720: LD_VAR 0 6
102724: PPUSH
102725: LD_VAR 0 7
102729: PPUSH
102730: LD_VAR 0 8
102734: PPUSH
102735: LD_VAR 0 9
102739: PPUSH
102740: LD_VAR 0 4
102744: PPUSH
102745: LD_VAR 0 5
102749: PPUSH
102750: CALL 102792 0 6
102754: GO 102787
102756: LD_INT 304
102758: DOUBLE
102759: EQUAL
102760: IFTRUE 102764
102762: GO 102786
102764: POP
// hHackTeleport ( unit , x , y ) ; end ;
102765: LD_VAR 0 2
102769: PPUSH
102770: LD_VAR 0 4
102774: PPUSH
102775: LD_VAR 0 5
102779: PPUSH
102780: CALL 104551 0 3
102784: GO 102787
102786: POP
// end ;
102787: LD_VAR 0 12
102791: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
102792: LD_INT 0
102794: PPUSH
102795: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
102796: LD_VAR 0 1
102800: PUSH
102801: LD_INT 1
102803: LESS
102804: PUSH
102805: LD_VAR 0 1
102809: PUSH
102810: LD_INT 3
102812: GREATER
102813: OR
102814: PUSH
102815: LD_VAR 0 5
102819: PPUSH
102820: LD_VAR 0 6
102824: PPUSH
102825: CALL_OW 428
102829: OR
102830: IFFALSE 102834
// exit ;
102832: GO 103554
// uc_side := your_side ;
102834: LD_ADDR_OWVAR 20
102838: PUSH
102839: LD_OWVAR 2
102843: ST_TO_ADDR
// uc_nation := nation ;
102844: LD_ADDR_OWVAR 21
102848: PUSH
102849: LD_VAR 0 1
102853: ST_TO_ADDR
// bc_level = 1 ;
102854: LD_ADDR_OWVAR 43
102858: PUSH
102859: LD_INT 1
102861: ST_TO_ADDR
// case btype of 1 :
102862: LD_VAR 0 2
102866: PUSH
102867: LD_INT 1
102869: DOUBLE
102870: EQUAL
102871: IFTRUE 102875
102873: GO 102886
102875: POP
// bc_type := b_depot ; 2 :
102876: LD_ADDR_OWVAR 42
102880: PUSH
102881: LD_INT 0
102883: ST_TO_ADDR
102884: GO 103498
102886: LD_INT 2
102888: DOUBLE
102889: EQUAL
102890: IFTRUE 102894
102892: GO 102905
102894: POP
// bc_type := b_warehouse ; 3 :
102895: LD_ADDR_OWVAR 42
102899: PUSH
102900: LD_INT 1
102902: ST_TO_ADDR
102903: GO 103498
102905: LD_INT 3
102907: DOUBLE
102908: EQUAL
102909: IFTRUE 102913
102911: GO 102924
102913: POP
// bc_type := b_lab ; 4 .. 9 :
102914: LD_ADDR_OWVAR 42
102918: PUSH
102919: LD_INT 6
102921: ST_TO_ADDR
102922: GO 103498
102924: LD_INT 4
102926: DOUBLE
102927: GREATEREQUAL
102928: IFFALSE 102936
102930: LD_INT 9
102932: DOUBLE
102933: LESSEQUAL
102934: IFTRUE 102938
102936: GO 102990
102938: POP
// begin bc_type := b_lab_half ;
102939: LD_ADDR_OWVAR 42
102943: PUSH
102944: LD_INT 7
102946: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
102947: LD_ADDR_OWVAR 44
102951: PUSH
102952: LD_INT 10
102954: PUSH
102955: LD_INT 11
102957: PUSH
102958: LD_INT 12
102960: PUSH
102961: LD_INT 15
102963: PUSH
102964: LD_INT 14
102966: PUSH
102967: LD_INT 13
102969: PUSH
102970: EMPTY
102971: LIST
102972: LIST
102973: LIST
102974: LIST
102975: LIST
102976: LIST
102977: PUSH
102978: LD_VAR 0 2
102982: PUSH
102983: LD_INT 3
102985: MINUS
102986: ARRAY
102987: ST_TO_ADDR
// end ; 10 .. 13 :
102988: GO 103498
102990: LD_INT 10
102992: DOUBLE
102993: GREATEREQUAL
102994: IFFALSE 103002
102996: LD_INT 13
102998: DOUBLE
102999: LESSEQUAL
103000: IFTRUE 103004
103002: GO 103081
103004: POP
// begin bc_type := b_lab_full ;
103005: LD_ADDR_OWVAR 42
103009: PUSH
103010: LD_INT 8
103012: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
103013: LD_ADDR_OWVAR 44
103017: PUSH
103018: LD_INT 10
103020: PUSH
103021: LD_INT 12
103023: PUSH
103024: LD_INT 14
103026: PUSH
103027: LD_INT 13
103029: PUSH
103030: EMPTY
103031: LIST
103032: LIST
103033: LIST
103034: LIST
103035: PUSH
103036: LD_VAR 0 2
103040: PUSH
103041: LD_INT 9
103043: MINUS
103044: ARRAY
103045: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
103046: LD_ADDR_OWVAR 45
103050: PUSH
103051: LD_INT 11
103053: PUSH
103054: LD_INT 15
103056: PUSH
103057: LD_INT 12
103059: PUSH
103060: LD_INT 15
103062: PUSH
103063: EMPTY
103064: LIST
103065: LIST
103066: LIST
103067: LIST
103068: PUSH
103069: LD_VAR 0 2
103073: PUSH
103074: LD_INT 9
103076: MINUS
103077: ARRAY
103078: ST_TO_ADDR
// end ; 14 :
103079: GO 103498
103081: LD_INT 14
103083: DOUBLE
103084: EQUAL
103085: IFTRUE 103089
103087: GO 103100
103089: POP
// bc_type := b_workshop ; 15 :
103090: LD_ADDR_OWVAR 42
103094: PUSH
103095: LD_INT 2
103097: ST_TO_ADDR
103098: GO 103498
103100: LD_INT 15
103102: DOUBLE
103103: EQUAL
103104: IFTRUE 103108
103106: GO 103119
103108: POP
// bc_type := b_factory ; 16 :
103109: LD_ADDR_OWVAR 42
103113: PUSH
103114: LD_INT 3
103116: ST_TO_ADDR
103117: GO 103498
103119: LD_INT 16
103121: DOUBLE
103122: EQUAL
103123: IFTRUE 103127
103125: GO 103138
103127: POP
// bc_type := b_ext_gun ; 17 :
103128: LD_ADDR_OWVAR 42
103132: PUSH
103133: LD_INT 17
103135: ST_TO_ADDR
103136: GO 103498
103138: LD_INT 17
103140: DOUBLE
103141: EQUAL
103142: IFTRUE 103146
103144: GO 103174
103146: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
103147: LD_ADDR_OWVAR 42
103151: PUSH
103152: LD_INT 19
103154: PUSH
103155: LD_INT 23
103157: PUSH
103158: LD_INT 19
103160: PUSH
103161: EMPTY
103162: LIST
103163: LIST
103164: LIST
103165: PUSH
103166: LD_VAR 0 1
103170: ARRAY
103171: ST_TO_ADDR
103172: GO 103498
103174: LD_INT 18
103176: DOUBLE
103177: EQUAL
103178: IFTRUE 103182
103180: GO 103193
103182: POP
// bc_type := b_ext_radar ; 19 :
103183: LD_ADDR_OWVAR 42
103187: PUSH
103188: LD_INT 20
103190: ST_TO_ADDR
103191: GO 103498
103193: LD_INT 19
103195: DOUBLE
103196: EQUAL
103197: IFTRUE 103201
103199: GO 103212
103201: POP
// bc_type := b_ext_radio ; 20 :
103202: LD_ADDR_OWVAR 42
103206: PUSH
103207: LD_INT 22
103209: ST_TO_ADDR
103210: GO 103498
103212: LD_INT 20
103214: DOUBLE
103215: EQUAL
103216: IFTRUE 103220
103218: GO 103231
103220: POP
// bc_type := b_ext_siberium ; 21 :
103221: LD_ADDR_OWVAR 42
103225: PUSH
103226: LD_INT 21
103228: ST_TO_ADDR
103229: GO 103498
103231: LD_INT 21
103233: DOUBLE
103234: EQUAL
103235: IFTRUE 103239
103237: GO 103250
103239: POP
// bc_type := b_ext_computer ; 22 :
103240: LD_ADDR_OWVAR 42
103244: PUSH
103245: LD_INT 24
103247: ST_TO_ADDR
103248: GO 103498
103250: LD_INT 22
103252: DOUBLE
103253: EQUAL
103254: IFTRUE 103258
103256: GO 103269
103258: POP
// bc_type := b_ext_track ; 23 :
103259: LD_ADDR_OWVAR 42
103263: PUSH
103264: LD_INT 16
103266: ST_TO_ADDR
103267: GO 103498
103269: LD_INT 23
103271: DOUBLE
103272: EQUAL
103273: IFTRUE 103277
103275: GO 103288
103277: POP
// bc_type := b_ext_laser ; 24 :
103278: LD_ADDR_OWVAR 42
103282: PUSH
103283: LD_INT 25
103285: ST_TO_ADDR
103286: GO 103498
103288: LD_INT 24
103290: DOUBLE
103291: EQUAL
103292: IFTRUE 103296
103294: GO 103307
103296: POP
// bc_type := b_control_tower ; 25 :
103297: LD_ADDR_OWVAR 42
103301: PUSH
103302: LD_INT 36
103304: ST_TO_ADDR
103305: GO 103498
103307: LD_INT 25
103309: DOUBLE
103310: EQUAL
103311: IFTRUE 103315
103313: GO 103326
103315: POP
// bc_type := b_breastwork ; 26 :
103316: LD_ADDR_OWVAR 42
103320: PUSH
103321: LD_INT 31
103323: ST_TO_ADDR
103324: GO 103498
103326: LD_INT 26
103328: DOUBLE
103329: EQUAL
103330: IFTRUE 103334
103332: GO 103345
103334: POP
// bc_type := b_bunker ; 27 :
103335: LD_ADDR_OWVAR 42
103339: PUSH
103340: LD_INT 32
103342: ST_TO_ADDR
103343: GO 103498
103345: LD_INT 27
103347: DOUBLE
103348: EQUAL
103349: IFTRUE 103353
103351: GO 103364
103353: POP
// bc_type := b_turret ; 28 :
103354: LD_ADDR_OWVAR 42
103358: PUSH
103359: LD_INT 33
103361: ST_TO_ADDR
103362: GO 103498
103364: LD_INT 28
103366: DOUBLE
103367: EQUAL
103368: IFTRUE 103372
103370: GO 103383
103372: POP
// bc_type := b_armoury ; 29 :
103373: LD_ADDR_OWVAR 42
103377: PUSH
103378: LD_INT 4
103380: ST_TO_ADDR
103381: GO 103498
103383: LD_INT 29
103385: DOUBLE
103386: EQUAL
103387: IFTRUE 103391
103389: GO 103402
103391: POP
// bc_type := b_barracks ; 30 :
103392: LD_ADDR_OWVAR 42
103396: PUSH
103397: LD_INT 5
103399: ST_TO_ADDR
103400: GO 103498
103402: LD_INT 30
103404: DOUBLE
103405: EQUAL
103406: IFTRUE 103410
103408: GO 103421
103410: POP
// bc_type := b_solar_power ; 31 :
103411: LD_ADDR_OWVAR 42
103415: PUSH
103416: LD_INT 27
103418: ST_TO_ADDR
103419: GO 103498
103421: LD_INT 31
103423: DOUBLE
103424: EQUAL
103425: IFTRUE 103429
103427: GO 103440
103429: POP
// bc_type := b_oil_power ; 32 :
103430: LD_ADDR_OWVAR 42
103434: PUSH
103435: LD_INT 26
103437: ST_TO_ADDR
103438: GO 103498
103440: LD_INT 32
103442: DOUBLE
103443: EQUAL
103444: IFTRUE 103448
103446: GO 103459
103448: POP
// bc_type := b_siberite_power ; 33 :
103449: LD_ADDR_OWVAR 42
103453: PUSH
103454: LD_INT 28
103456: ST_TO_ADDR
103457: GO 103498
103459: LD_INT 33
103461: DOUBLE
103462: EQUAL
103463: IFTRUE 103467
103465: GO 103478
103467: POP
// bc_type := b_oil_mine ; 34 :
103468: LD_ADDR_OWVAR 42
103472: PUSH
103473: LD_INT 29
103475: ST_TO_ADDR
103476: GO 103498
103478: LD_INT 34
103480: DOUBLE
103481: EQUAL
103482: IFTRUE 103486
103484: GO 103497
103486: POP
// bc_type := b_siberite_mine ; end ;
103487: LD_ADDR_OWVAR 42
103491: PUSH
103492: LD_INT 30
103494: ST_TO_ADDR
103495: GO 103498
103497: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
103498: LD_ADDR_VAR 0 8
103502: PUSH
103503: LD_VAR 0 5
103507: PPUSH
103508: LD_VAR 0 6
103512: PPUSH
103513: LD_VAR 0 3
103517: PPUSH
103518: CALL_OW 47
103522: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
103523: LD_OWVAR 42
103527: PUSH
103528: LD_INT 32
103530: PUSH
103531: LD_INT 33
103533: PUSH
103534: EMPTY
103535: LIST
103536: LIST
103537: IN
103538: IFFALSE 103554
// PlaceWeaponTurret ( b , weapon ) ;
103540: LD_VAR 0 8
103544: PPUSH
103545: LD_VAR 0 4
103549: PPUSH
103550: CALL_OW 431
// end ;
103554: LD_VAR 0 7
103558: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
103559: LD_INT 0
103561: PPUSH
103562: PPUSH
103563: PPUSH
103564: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
103565: LD_ADDR_VAR 0 4
103569: PUSH
103570: LD_INT 22
103572: PUSH
103573: LD_OWVAR 2
103577: PUSH
103578: EMPTY
103579: LIST
103580: LIST
103581: PUSH
103582: LD_INT 2
103584: PUSH
103585: LD_INT 30
103587: PUSH
103588: LD_INT 0
103590: PUSH
103591: EMPTY
103592: LIST
103593: LIST
103594: PUSH
103595: LD_INT 30
103597: PUSH
103598: LD_INT 1
103600: PUSH
103601: EMPTY
103602: LIST
103603: LIST
103604: PUSH
103605: EMPTY
103606: LIST
103607: LIST
103608: LIST
103609: PUSH
103610: EMPTY
103611: LIST
103612: LIST
103613: PPUSH
103614: CALL_OW 69
103618: ST_TO_ADDR
// if not tmp then
103619: LD_VAR 0 4
103623: NOT
103624: IFFALSE 103628
// exit ;
103626: GO 103687
// for i in tmp do
103628: LD_ADDR_VAR 0 2
103632: PUSH
103633: LD_VAR 0 4
103637: PUSH
103638: FOR_IN
103639: IFFALSE 103685
// for j = 1 to 3 do
103641: LD_ADDR_VAR 0 3
103645: PUSH
103646: DOUBLE
103647: LD_INT 1
103649: DEC
103650: ST_TO_ADDR
103651: LD_INT 3
103653: PUSH
103654: FOR_TO
103655: IFFALSE 103681
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
103657: LD_VAR 0 2
103661: PPUSH
103662: CALL_OW 274
103666: PPUSH
103667: LD_VAR 0 3
103671: PPUSH
103672: LD_INT 99999
103674: PPUSH
103675: CALL_OW 277
103679: GO 103654
103681: POP
103682: POP
103683: GO 103638
103685: POP
103686: POP
// end ;
103687: LD_VAR 0 1
103691: RET
// export function hHackSetLevel10 ; var i , j ; begin
103692: LD_INT 0
103694: PPUSH
103695: PPUSH
103696: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
103697: LD_ADDR_VAR 0 2
103701: PUSH
103702: LD_INT 21
103704: PUSH
103705: LD_INT 1
103707: PUSH
103708: EMPTY
103709: LIST
103710: LIST
103711: PPUSH
103712: CALL_OW 69
103716: PUSH
103717: FOR_IN
103718: IFFALSE 103770
// if IsSelected ( i ) then
103720: LD_VAR 0 2
103724: PPUSH
103725: CALL_OW 306
103729: IFFALSE 103768
// begin for j := 1 to 4 do
103731: LD_ADDR_VAR 0 3
103735: PUSH
103736: DOUBLE
103737: LD_INT 1
103739: DEC
103740: ST_TO_ADDR
103741: LD_INT 4
103743: PUSH
103744: FOR_TO
103745: IFFALSE 103766
// SetSkill ( i , j , 10 ) ;
103747: LD_VAR 0 2
103751: PPUSH
103752: LD_VAR 0 3
103756: PPUSH
103757: LD_INT 10
103759: PPUSH
103760: CALL_OW 237
103764: GO 103744
103766: POP
103767: POP
// end ;
103768: GO 103717
103770: POP
103771: POP
// end ;
103772: LD_VAR 0 1
103776: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
103777: LD_INT 0
103779: PPUSH
103780: PPUSH
103781: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
103782: LD_ADDR_VAR 0 2
103786: PUSH
103787: LD_INT 22
103789: PUSH
103790: LD_OWVAR 2
103794: PUSH
103795: EMPTY
103796: LIST
103797: LIST
103798: PUSH
103799: LD_INT 21
103801: PUSH
103802: LD_INT 1
103804: PUSH
103805: EMPTY
103806: LIST
103807: LIST
103808: PUSH
103809: EMPTY
103810: LIST
103811: LIST
103812: PPUSH
103813: CALL_OW 69
103817: PUSH
103818: FOR_IN
103819: IFFALSE 103860
// begin for j := 1 to 4 do
103821: LD_ADDR_VAR 0 3
103825: PUSH
103826: DOUBLE
103827: LD_INT 1
103829: DEC
103830: ST_TO_ADDR
103831: LD_INT 4
103833: PUSH
103834: FOR_TO
103835: IFFALSE 103856
// SetSkill ( i , j , 10 ) ;
103837: LD_VAR 0 2
103841: PPUSH
103842: LD_VAR 0 3
103846: PPUSH
103847: LD_INT 10
103849: PPUSH
103850: CALL_OW 237
103854: GO 103834
103856: POP
103857: POP
// end ;
103858: GO 103818
103860: POP
103861: POP
// end ;
103862: LD_VAR 0 1
103866: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
103867: LD_INT 0
103869: PPUSH
// uc_side := your_side ;
103870: LD_ADDR_OWVAR 20
103874: PUSH
103875: LD_OWVAR 2
103879: ST_TO_ADDR
// uc_nation := nation ;
103880: LD_ADDR_OWVAR 21
103884: PUSH
103885: LD_VAR 0 1
103889: ST_TO_ADDR
// InitHc ;
103890: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
103894: LD_INT 0
103896: PPUSH
103897: LD_VAR 0 2
103901: PPUSH
103902: LD_VAR 0 3
103906: PPUSH
103907: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
103911: LD_VAR 0 4
103915: PPUSH
103916: LD_VAR 0 5
103920: PPUSH
103921: CALL_OW 428
103925: PUSH
103926: LD_INT 0
103928: EQUAL
103929: IFFALSE 103953
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
103931: CALL_OW 44
103935: PPUSH
103936: LD_VAR 0 4
103940: PPUSH
103941: LD_VAR 0 5
103945: PPUSH
103946: LD_INT 1
103948: PPUSH
103949: CALL_OW 48
// end ;
103953: LD_VAR 0 6
103957: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
103958: LD_INT 0
103960: PPUSH
103961: PPUSH
// uc_side := your_side ;
103962: LD_ADDR_OWVAR 20
103966: PUSH
103967: LD_OWVAR 2
103971: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
103972: LD_VAR 0 1
103976: PUSH
103977: LD_INT 1
103979: PUSH
103980: LD_INT 2
103982: PUSH
103983: LD_INT 3
103985: PUSH
103986: LD_INT 4
103988: PUSH
103989: LD_INT 5
103991: PUSH
103992: EMPTY
103993: LIST
103994: LIST
103995: LIST
103996: LIST
103997: LIST
103998: IN
103999: IFFALSE 104011
// uc_nation := nation_american else
104001: LD_ADDR_OWVAR 21
104005: PUSH
104006: LD_INT 1
104008: ST_TO_ADDR
104009: GO 104054
// if chassis in [ 11 , 12 , 13 , 14 ] then
104011: LD_VAR 0 1
104015: PUSH
104016: LD_INT 11
104018: PUSH
104019: LD_INT 12
104021: PUSH
104022: LD_INT 13
104024: PUSH
104025: LD_INT 14
104027: PUSH
104028: EMPTY
104029: LIST
104030: LIST
104031: LIST
104032: LIST
104033: IN
104034: IFFALSE 104046
// uc_nation := nation_arabian else
104036: LD_ADDR_OWVAR 21
104040: PUSH
104041: LD_INT 2
104043: ST_TO_ADDR
104044: GO 104054
// uc_nation := nation_russian ;
104046: LD_ADDR_OWVAR 21
104050: PUSH
104051: LD_INT 3
104053: ST_TO_ADDR
// vc_chassis := chassis ;
104054: LD_ADDR_OWVAR 37
104058: PUSH
104059: LD_VAR 0 1
104063: ST_TO_ADDR
// vc_engine := engine ;
104064: LD_ADDR_OWVAR 39
104068: PUSH
104069: LD_VAR 0 2
104073: ST_TO_ADDR
// vc_control := control ;
104074: LD_ADDR_OWVAR 38
104078: PUSH
104079: LD_VAR 0 3
104083: ST_TO_ADDR
// vc_weapon := weapon ;
104084: LD_ADDR_OWVAR 40
104088: PUSH
104089: LD_VAR 0 4
104093: ST_TO_ADDR
// un := CreateVehicle ;
104094: LD_ADDR_VAR 0 8
104098: PUSH
104099: CALL_OW 45
104103: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
104104: LD_VAR 0 8
104108: PPUSH
104109: LD_INT 0
104111: PPUSH
104112: LD_INT 5
104114: PPUSH
104115: CALL_OW 12
104119: PPUSH
104120: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
104124: LD_VAR 0 8
104128: PPUSH
104129: LD_VAR 0 5
104133: PPUSH
104134: LD_VAR 0 6
104138: PPUSH
104139: LD_INT 1
104141: PPUSH
104142: CALL_OW 48
// end ;
104146: LD_VAR 0 7
104150: RET
// export hInvincible ; every 1 do
104151: GO 104153
104153: DISABLE
// hInvincible := [ ] ;
104154: LD_ADDR_EXP 153
104158: PUSH
104159: EMPTY
104160: ST_TO_ADDR
104161: END
// every 10 do var i ;
104162: GO 104164
104164: DISABLE
104165: LD_INT 0
104167: PPUSH
// begin enable ;
104168: ENABLE
// if not hInvincible then
104169: LD_EXP 153
104173: NOT
104174: IFFALSE 104178
// exit ;
104176: GO 104222
// for i in hInvincible do
104178: LD_ADDR_VAR 0 1
104182: PUSH
104183: LD_EXP 153
104187: PUSH
104188: FOR_IN
104189: IFFALSE 104220
// if GetLives ( i ) < 1000 then
104191: LD_VAR 0 1
104195: PPUSH
104196: CALL_OW 256
104200: PUSH
104201: LD_INT 1000
104203: LESS
104204: IFFALSE 104218
// SetLives ( i , 1000 ) ;
104206: LD_VAR 0 1
104210: PPUSH
104211: LD_INT 1000
104213: PPUSH
104214: CALL_OW 234
104218: GO 104188
104220: POP
104221: POP
// end ;
104222: PPOPN 1
104224: END
// export function hHackInvincible ; var i ; begin
104225: LD_INT 0
104227: PPUSH
104228: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
104229: LD_ADDR_VAR 0 2
104233: PUSH
104234: LD_INT 2
104236: PUSH
104237: LD_INT 21
104239: PUSH
104240: LD_INT 1
104242: PUSH
104243: EMPTY
104244: LIST
104245: LIST
104246: PUSH
104247: LD_INT 21
104249: PUSH
104250: LD_INT 2
104252: PUSH
104253: EMPTY
104254: LIST
104255: LIST
104256: PUSH
104257: EMPTY
104258: LIST
104259: LIST
104260: LIST
104261: PPUSH
104262: CALL_OW 69
104266: PUSH
104267: FOR_IN
104268: IFFALSE 104329
// if IsSelected ( i ) then
104270: LD_VAR 0 2
104274: PPUSH
104275: CALL_OW 306
104279: IFFALSE 104327
// begin if i in hInvincible then
104281: LD_VAR 0 2
104285: PUSH
104286: LD_EXP 153
104290: IN
104291: IFFALSE 104311
// hInvincible := hInvincible diff i else
104293: LD_ADDR_EXP 153
104297: PUSH
104298: LD_EXP 153
104302: PUSH
104303: LD_VAR 0 2
104307: DIFF
104308: ST_TO_ADDR
104309: GO 104327
// hInvincible := hInvincible union i ;
104311: LD_ADDR_EXP 153
104315: PUSH
104316: LD_EXP 153
104320: PUSH
104321: LD_VAR 0 2
104325: UNION
104326: ST_TO_ADDR
// end ;
104327: GO 104267
104329: POP
104330: POP
// end ;
104331: LD_VAR 0 1
104335: RET
// export function hHackInvisible ; var i , j ; begin
104336: LD_INT 0
104338: PPUSH
104339: PPUSH
104340: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
104341: LD_ADDR_VAR 0 2
104345: PUSH
104346: LD_INT 21
104348: PUSH
104349: LD_INT 1
104351: PUSH
104352: EMPTY
104353: LIST
104354: LIST
104355: PPUSH
104356: CALL_OW 69
104360: PUSH
104361: FOR_IN
104362: IFFALSE 104386
// if IsSelected ( i ) then
104364: LD_VAR 0 2
104368: PPUSH
104369: CALL_OW 306
104373: IFFALSE 104384
// ComForceInvisible ( i ) ;
104375: LD_VAR 0 2
104379: PPUSH
104380: CALL_OW 496
104384: GO 104361
104386: POP
104387: POP
// end ;
104388: LD_VAR 0 1
104392: RET
// export function hHackChangeYourSide ; begin
104393: LD_INT 0
104395: PPUSH
// if your_side = 8 then
104396: LD_OWVAR 2
104400: PUSH
104401: LD_INT 8
104403: EQUAL
104404: IFFALSE 104416
// your_side := 0 else
104406: LD_ADDR_OWVAR 2
104410: PUSH
104411: LD_INT 0
104413: ST_TO_ADDR
104414: GO 104430
// your_side := your_side + 1 ;
104416: LD_ADDR_OWVAR 2
104420: PUSH
104421: LD_OWVAR 2
104425: PUSH
104426: LD_INT 1
104428: PLUS
104429: ST_TO_ADDR
// end ;
104430: LD_VAR 0 1
104434: RET
// export function hHackChangeUnitSide ; var i , j ; begin
104435: LD_INT 0
104437: PPUSH
104438: PPUSH
104439: PPUSH
// for i in all_units do
104440: LD_ADDR_VAR 0 2
104444: PUSH
104445: LD_OWVAR 3
104449: PUSH
104450: FOR_IN
104451: IFFALSE 104529
// if IsSelected ( i ) then
104453: LD_VAR 0 2
104457: PPUSH
104458: CALL_OW 306
104462: IFFALSE 104527
// begin j := GetSide ( i ) ;
104464: LD_ADDR_VAR 0 3
104468: PUSH
104469: LD_VAR 0 2
104473: PPUSH
104474: CALL_OW 255
104478: ST_TO_ADDR
// if j = 8 then
104479: LD_VAR 0 3
104483: PUSH
104484: LD_INT 8
104486: EQUAL
104487: IFFALSE 104499
// j := 0 else
104489: LD_ADDR_VAR 0 3
104493: PUSH
104494: LD_INT 0
104496: ST_TO_ADDR
104497: GO 104513
// j := j + 1 ;
104499: LD_ADDR_VAR 0 3
104503: PUSH
104504: LD_VAR 0 3
104508: PUSH
104509: LD_INT 1
104511: PLUS
104512: ST_TO_ADDR
// SetSide ( i , j ) ;
104513: LD_VAR 0 2
104517: PPUSH
104518: LD_VAR 0 3
104522: PPUSH
104523: CALL_OW 235
// end ;
104527: GO 104450
104529: POP
104530: POP
// end ;
104531: LD_VAR 0 1
104535: RET
// export function hHackFog ; begin
104536: LD_INT 0
104538: PPUSH
// FogOff ( true ) ;
104539: LD_INT 1
104541: PPUSH
104542: CALL_OW 344
// end ;
104546: LD_VAR 0 1
104550: RET
// export function hHackTeleport ( unit , x , y ) ; begin
104551: LD_INT 0
104553: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
104554: LD_VAR 0 1
104558: PPUSH
104559: LD_VAR 0 2
104563: PPUSH
104564: LD_VAR 0 3
104568: PPUSH
104569: LD_INT 1
104571: PPUSH
104572: LD_INT 1
104574: PPUSH
104575: CALL_OW 483
// CenterOnXY ( x , y ) ;
104579: LD_VAR 0 2
104583: PPUSH
104584: LD_VAR 0 3
104588: PPUSH
104589: CALL_OW 84
// end ;
104593: LD_VAR 0 4
104597: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
104598: LD_INT 0
104600: PPUSH
104601: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
104602: LD_VAR 0 1
104606: NOT
104607: PUSH
104608: LD_VAR 0 2
104612: PPUSH
104613: LD_VAR 0 3
104617: PPUSH
104618: CALL_OW 488
104622: NOT
104623: OR
104624: PUSH
104625: LD_VAR 0 1
104629: PPUSH
104630: CALL_OW 266
104634: PUSH
104635: LD_INT 3
104637: NONEQUAL
104638: PUSH
104639: LD_VAR 0 1
104643: PPUSH
104644: CALL_OW 247
104648: PUSH
104649: LD_INT 1
104651: EQUAL
104652: NOT
104653: AND
104654: OR
104655: IFFALSE 104659
// exit ;
104657: GO 104808
// if GetType ( factory ) = unit_human then
104659: LD_VAR 0 1
104663: PPUSH
104664: CALL_OW 247
104668: PUSH
104669: LD_INT 1
104671: EQUAL
104672: IFFALSE 104689
// factory := IsInUnit ( factory ) ;
104674: LD_ADDR_VAR 0 1
104678: PUSH
104679: LD_VAR 0 1
104683: PPUSH
104684: CALL_OW 310
104688: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
104689: LD_VAR 0 1
104693: PPUSH
104694: CALL_OW 266
104698: PUSH
104699: LD_INT 3
104701: NONEQUAL
104702: IFFALSE 104706
// exit ;
104704: GO 104808
// if HexInfo ( x , y ) = factory then
104706: LD_VAR 0 2
104710: PPUSH
104711: LD_VAR 0 3
104715: PPUSH
104716: CALL_OW 428
104720: PUSH
104721: LD_VAR 0 1
104725: EQUAL
104726: IFFALSE 104753
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
104728: LD_ADDR_EXP 154
104732: PUSH
104733: LD_EXP 154
104737: PPUSH
104738: LD_VAR 0 1
104742: PPUSH
104743: LD_INT 0
104745: PPUSH
104746: CALL_OW 1
104750: ST_TO_ADDR
104751: GO 104804
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
104753: LD_ADDR_EXP 154
104757: PUSH
104758: LD_EXP 154
104762: PPUSH
104763: LD_VAR 0 1
104767: PPUSH
104768: LD_VAR 0 1
104772: PPUSH
104773: CALL_OW 255
104777: PUSH
104778: LD_VAR 0 1
104782: PUSH
104783: LD_VAR 0 2
104787: PUSH
104788: LD_VAR 0 3
104792: PUSH
104793: EMPTY
104794: LIST
104795: LIST
104796: LIST
104797: LIST
104798: PPUSH
104799: CALL_OW 1
104803: ST_TO_ADDR
// UpdateFactoryWaypoints ;
104804: CALL 104813 0 0
// end ;
104808: LD_VAR 0 4
104812: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
104813: LD_INT 0
104815: PPUSH
104816: PPUSH
104817: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
104818: LD_STRING resetFactoryWaypoint();
104820: PPUSH
104821: CALL_OW 559
// if factoryWaypoints then
104825: LD_EXP 154
104829: IFFALSE 104955
// begin list := PrepareArray ( factoryWaypoints ) ;
104831: LD_ADDR_VAR 0 3
104835: PUSH
104836: LD_EXP 154
104840: PPUSH
104841: CALL 89920 0 1
104845: ST_TO_ADDR
// for i := 1 to list do
104846: LD_ADDR_VAR 0 2
104850: PUSH
104851: DOUBLE
104852: LD_INT 1
104854: DEC
104855: ST_TO_ADDR
104856: LD_VAR 0 3
104860: PUSH
104861: FOR_TO
104862: IFFALSE 104953
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
104864: LD_STRING setFactoryWaypointXY(
104866: PUSH
104867: LD_VAR 0 3
104871: PUSH
104872: LD_VAR 0 2
104876: ARRAY
104877: PUSH
104878: LD_INT 1
104880: ARRAY
104881: STR
104882: PUSH
104883: LD_STRING ,
104885: STR
104886: PUSH
104887: LD_VAR 0 3
104891: PUSH
104892: LD_VAR 0 2
104896: ARRAY
104897: PUSH
104898: LD_INT 2
104900: ARRAY
104901: STR
104902: PUSH
104903: LD_STRING ,
104905: STR
104906: PUSH
104907: LD_VAR 0 3
104911: PUSH
104912: LD_VAR 0 2
104916: ARRAY
104917: PUSH
104918: LD_INT 3
104920: ARRAY
104921: STR
104922: PUSH
104923: LD_STRING ,
104925: STR
104926: PUSH
104927: LD_VAR 0 3
104931: PUSH
104932: LD_VAR 0 2
104936: ARRAY
104937: PUSH
104938: LD_INT 4
104940: ARRAY
104941: STR
104942: PUSH
104943: LD_STRING )
104945: STR
104946: PPUSH
104947: CALL_OW 559
104951: GO 104861
104953: POP
104954: POP
// end ; end ;
104955: LD_VAR 0 1
104959: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
104960: LD_INT 0
104962: PPUSH
// if HexInfo ( x , y ) = warehouse then
104963: LD_VAR 0 2
104967: PPUSH
104968: LD_VAR 0 3
104972: PPUSH
104973: CALL_OW 428
104977: PUSH
104978: LD_VAR 0 1
104982: EQUAL
104983: IFFALSE 105010
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
104985: LD_ADDR_EXP 155
104989: PUSH
104990: LD_EXP 155
104994: PPUSH
104995: LD_VAR 0 1
104999: PPUSH
105000: LD_INT 0
105002: PPUSH
105003: CALL_OW 1
105007: ST_TO_ADDR
105008: GO 105061
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
105010: LD_ADDR_EXP 155
105014: PUSH
105015: LD_EXP 155
105019: PPUSH
105020: LD_VAR 0 1
105024: PPUSH
105025: LD_VAR 0 1
105029: PPUSH
105030: CALL_OW 255
105034: PUSH
105035: LD_VAR 0 1
105039: PUSH
105040: LD_VAR 0 2
105044: PUSH
105045: LD_VAR 0 3
105049: PUSH
105050: EMPTY
105051: LIST
105052: LIST
105053: LIST
105054: LIST
105055: PPUSH
105056: CALL_OW 1
105060: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
105061: CALL 105070 0 0
// end ;
105065: LD_VAR 0 4
105069: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
105070: LD_INT 0
105072: PPUSH
105073: PPUSH
105074: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
105075: LD_STRING resetWarehouseGatheringPoints();
105077: PPUSH
105078: CALL_OW 559
// if warehouseGatheringPoints then
105082: LD_EXP 155
105086: IFFALSE 105212
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
105088: LD_ADDR_VAR 0 3
105092: PUSH
105093: LD_EXP 155
105097: PPUSH
105098: CALL 89920 0 1
105102: ST_TO_ADDR
// for i := 1 to list do
105103: LD_ADDR_VAR 0 2
105107: PUSH
105108: DOUBLE
105109: LD_INT 1
105111: DEC
105112: ST_TO_ADDR
105113: LD_VAR 0 3
105117: PUSH
105118: FOR_TO
105119: IFFALSE 105210
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
105121: LD_STRING setWarehouseGatheringPointXY(
105123: PUSH
105124: LD_VAR 0 3
105128: PUSH
105129: LD_VAR 0 2
105133: ARRAY
105134: PUSH
105135: LD_INT 1
105137: ARRAY
105138: STR
105139: PUSH
105140: LD_STRING ,
105142: STR
105143: PUSH
105144: LD_VAR 0 3
105148: PUSH
105149: LD_VAR 0 2
105153: ARRAY
105154: PUSH
105155: LD_INT 2
105157: ARRAY
105158: STR
105159: PUSH
105160: LD_STRING ,
105162: STR
105163: PUSH
105164: LD_VAR 0 3
105168: PUSH
105169: LD_VAR 0 2
105173: ARRAY
105174: PUSH
105175: LD_INT 3
105177: ARRAY
105178: STR
105179: PUSH
105180: LD_STRING ,
105182: STR
105183: PUSH
105184: LD_VAR 0 3
105188: PUSH
105189: LD_VAR 0 2
105193: ARRAY
105194: PUSH
105195: LD_INT 4
105197: ARRAY
105198: STR
105199: PUSH
105200: LD_STRING )
105202: STR
105203: PPUSH
105204: CALL_OW 559
105208: GO 105118
105210: POP
105211: POP
// end ; end ;
105212: LD_VAR 0 1
105216: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
105217: LD_EXP 155
105221: IFFALSE 105906
105223: GO 105225
105225: DISABLE
105226: LD_INT 0
105228: PPUSH
105229: PPUSH
105230: PPUSH
105231: PPUSH
105232: PPUSH
105233: PPUSH
105234: PPUSH
105235: PPUSH
105236: PPUSH
// begin enable ;
105237: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
105238: LD_ADDR_VAR 0 3
105242: PUSH
105243: LD_EXP 155
105247: PPUSH
105248: CALL 89920 0 1
105252: ST_TO_ADDR
// if not list then
105253: LD_VAR 0 3
105257: NOT
105258: IFFALSE 105262
// exit ;
105260: GO 105906
// for i := 1 to list do
105262: LD_ADDR_VAR 0 1
105266: PUSH
105267: DOUBLE
105268: LD_INT 1
105270: DEC
105271: ST_TO_ADDR
105272: LD_VAR 0 3
105276: PUSH
105277: FOR_TO
105278: IFFALSE 105904
// begin depot := list [ i ] [ 2 ] ;
105280: LD_ADDR_VAR 0 8
105284: PUSH
105285: LD_VAR 0 3
105289: PUSH
105290: LD_VAR 0 1
105294: ARRAY
105295: PUSH
105296: LD_INT 2
105298: ARRAY
105299: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
105300: LD_ADDR_VAR 0 5
105304: PUSH
105305: LD_VAR 0 3
105309: PUSH
105310: LD_VAR 0 1
105314: ARRAY
105315: PUSH
105316: LD_INT 1
105318: ARRAY
105319: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
105320: LD_VAR 0 8
105324: PPUSH
105325: CALL_OW 301
105329: PUSH
105330: LD_VAR 0 5
105334: PUSH
105335: LD_VAR 0 8
105339: PPUSH
105340: CALL_OW 255
105344: NONEQUAL
105345: OR
105346: IFFALSE 105375
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
105348: LD_ADDR_EXP 155
105352: PUSH
105353: LD_EXP 155
105357: PPUSH
105358: LD_VAR 0 8
105362: PPUSH
105363: LD_INT 0
105365: PPUSH
105366: CALL_OW 1
105370: ST_TO_ADDR
// exit ;
105371: POP
105372: POP
105373: GO 105906
// end ; x := list [ i ] [ 3 ] ;
105375: LD_ADDR_VAR 0 6
105379: PUSH
105380: LD_VAR 0 3
105384: PUSH
105385: LD_VAR 0 1
105389: ARRAY
105390: PUSH
105391: LD_INT 3
105393: ARRAY
105394: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
105395: LD_ADDR_VAR 0 7
105399: PUSH
105400: LD_VAR 0 3
105404: PUSH
105405: LD_VAR 0 1
105409: ARRAY
105410: PUSH
105411: LD_INT 4
105413: ARRAY
105414: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
105415: LD_ADDR_VAR 0 9
105419: PUSH
105420: LD_VAR 0 6
105424: PPUSH
105425: LD_VAR 0 7
105429: PPUSH
105430: LD_INT 16
105432: PPUSH
105433: CALL 88508 0 3
105437: ST_TO_ADDR
// if not cratesNearbyPoint then
105438: LD_VAR 0 9
105442: NOT
105443: IFFALSE 105449
// exit ;
105445: POP
105446: POP
105447: GO 105906
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
105449: LD_ADDR_VAR 0 4
105453: PUSH
105454: LD_INT 22
105456: PUSH
105457: LD_VAR 0 5
105461: PUSH
105462: EMPTY
105463: LIST
105464: LIST
105465: PUSH
105466: LD_INT 3
105468: PUSH
105469: LD_INT 60
105471: PUSH
105472: EMPTY
105473: LIST
105474: PUSH
105475: EMPTY
105476: LIST
105477: LIST
105478: PUSH
105479: LD_INT 91
105481: PUSH
105482: LD_VAR 0 8
105486: PUSH
105487: LD_INT 6
105489: PUSH
105490: EMPTY
105491: LIST
105492: LIST
105493: LIST
105494: PUSH
105495: LD_INT 2
105497: PUSH
105498: LD_INT 25
105500: PUSH
105501: LD_INT 2
105503: PUSH
105504: EMPTY
105505: LIST
105506: LIST
105507: PUSH
105508: LD_INT 25
105510: PUSH
105511: LD_INT 16
105513: PUSH
105514: EMPTY
105515: LIST
105516: LIST
105517: PUSH
105518: EMPTY
105519: LIST
105520: LIST
105521: LIST
105522: PUSH
105523: EMPTY
105524: LIST
105525: LIST
105526: LIST
105527: LIST
105528: PPUSH
105529: CALL_OW 69
105533: PUSH
105534: LD_VAR 0 8
105538: PPUSH
105539: CALL_OW 313
105543: PPUSH
105544: LD_INT 3
105546: PUSH
105547: LD_INT 60
105549: PUSH
105550: EMPTY
105551: LIST
105552: PUSH
105553: EMPTY
105554: LIST
105555: LIST
105556: PUSH
105557: LD_INT 2
105559: PUSH
105560: LD_INT 25
105562: PUSH
105563: LD_INT 2
105565: PUSH
105566: EMPTY
105567: LIST
105568: LIST
105569: PUSH
105570: LD_INT 25
105572: PUSH
105573: LD_INT 16
105575: PUSH
105576: EMPTY
105577: LIST
105578: LIST
105579: PUSH
105580: EMPTY
105581: LIST
105582: LIST
105583: LIST
105584: PUSH
105585: EMPTY
105586: LIST
105587: LIST
105588: PPUSH
105589: CALL_OW 72
105593: UNION
105594: ST_TO_ADDR
// if tmp then
105595: LD_VAR 0 4
105599: IFFALSE 105679
// begin tmp := ShrinkArray ( tmp , 3 ) ;
105601: LD_ADDR_VAR 0 4
105605: PUSH
105606: LD_VAR 0 4
105610: PPUSH
105611: LD_INT 3
105613: PPUSH
105614: CALL 86477 0 2
105618: ST_TO_ADDR
// for j in tmp do
105619: LD_ADDR_VAR 0 2
105623: PUSH
105624: LD_VAR 0 4
105628: PUSH
105629: FOR_IN
105630: IFFALSE 105673
// begin if IsInUnit ( j ) then
105632: LD_VAR 0 2
105636: PPUSH
105637: CALL_OW 310
105641: IFFALSE 105652
// ComExit ( j ) ;
105643: LD_VAR 0 2
105647: PPUSH
105648: CALL 86560 0 1
// AddComCollect ( j , x , y ) ;
105652: LD_VAR 0 2
105656: PPUSH
105657: LD_VAR 0 6
105661: PPUSH
105662: LD_VAR 0 7
105666: PPUSH
105667: CALL_OW 177
// end ;
105671: GO 105629
105673: POP
105674: POP
// exit ;
105675: POP
105676: POP
105677: GO 105906
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
105679: LD_ADDR_VAR 0 4
105683: PUSH
105684: LD_INT 22
105686: PUSH
105687: LD_VAR 0 5
105691: PUSH
105692: EMPTY
105693: LIST
105694: LIST
105695: PUSH
105696: LD_INT 91
105698: PUSH
105699: LD_VAR 0 8
105703: PUSH
105704: LD_INT 8
105706: PUSH
105707: EMPTY
105708: LIST
105709: LIST
105710: LIST
105711: PUSH
105712: LD_INT 2
105714: PUSH
105715: LD_INT 34
105717: PUSH
105718: LD_INT 12
105720: PUSH
105721: EMPTY
105722: LIST
105723: LIST
105724: PUSH
105725: LD_INT 34
105727: PUSH
105728: LD_INT 51
105730: PUSH
105731: EMPTY
105732: LIST
105733: LIST
105734: PUSH
105735: LD_INT 34
105737: PUSH
105738: LD_INT 32
105740: PUSH
105741: EMPTY
105742: LIST
105743: LIST
105744: PUSH
105745: LD_INT 34
105747: PUSH
105748: LD_INT 89
105750: PUSH
105751: EMPTY
105752: LIST
105753: LIST
105754: PUSH
105755: EMPTY
105756: LIST
105757: LIST
105758: LIST
105759: LIST
105760: LIST
105761: PUSH
105762: EMPTY
105763: LIST
105764: LIST
105765: LIST
105766: PPUSH
105767: CALL_OW 69
105771: ST_TO_ADDR
// if tmp then
105772: LD_VAR 0 4
105776: IFFALSE 105902
// begin for j in tmp do
105778: LD_ADDR_VAR 0 2
105782: PUSH
105783: LD_VAR 0 4
105787: PUSH
105788: FOR_IN
105789: IFFALSE 105900
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
105791: LD_VAR 0 2
105795: PPUSH
105796: CALL_OW 262
105800: PUSH
105801: LD_INT 3
105803: EQUAL
105804: PUSH
105805: LD_VAR 0 2
105809: PPUSH
105810: CALL_OW 261
105814: PUSH
105815: LD_INT 20
105817: GREATER
105818: OR
105819: PUSH
105820: LD_VAR 0 2
105824: PPUSH
105825: CALL_OW 314
105829: NOT
105830: AND
105831: PUSH
105832: LD_VAR 0 2
105836: PPUSH
105837: CALL_OW 263
105841: PUSH
105842: LD_INT 1
105844: NONEQUAL
105845: PUSH
105846: LD_VAR 0 2
105850: PPUSH
105851: CALL_OW 311
105855: OR
105856: AND
105857: IFFALSE 105898
// begin ComCollect ( j , x , y ) ;
105859: LD_VAR 0 2
105863: PPUSH
105864: LD_VAR 0 6
105868: PPUSH
105869: LD_VAR 0 7
105873: PPUSH
105874: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
105878: LD_VAR 0 2
105882: PPUSH
105883: LD_VAR 0 8
105887: PPUSH
105888: CALL_OW 172
// exit ;
105892: POP
105893: POP
105894: POP
105895: POP
105896: GO 105906
// end ;
105898: GO 105788
105900: POP
105901: POP
// end ; end ;
105902: GO 105277
105904: POP
105905: POP
// end ; end_of_file
105906: PPOPN 9
105908: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
105909: LD_INT 0
105911: PPUSH
105912: PPUSH
105913: PPUSH
105914: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
105915: LD_VAR 0 1
105919: PPUSH
105920: CALL_OW 264
105924: PUSH
105925: LD_INT 91
105927: EQUAL
105928: IFFALSE 106000
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
105930: LD_INT 68
105932: PPUSH
105933: LD_VAR 0 1
105937: PPUSH
105938: CALL_OW 255
105942: PPUSH
105943: CALL_OW 321
105947: PUSH
105948: LD_INT 2
105950: EQUAL
105951: IFFALSE 105963
// eff := 70 else
105953: LD_ADDR_VAR 0 4
105957: PUSH
105958: LD_INT 70
105960: ST_TO_ADDR
105961: GO 105971
// eff := 30 ;
105963: LD_ADDR_VAR 0 4
105967: PUSH
105968: LD_INT 30
105970: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
105971: LD_VAR 0 1
105975: PPUSH
105976: CALL_OW 250
105980: PPUSH
105981: LD_VAR 0 1
105985: PPUSH
105986: CALL_OW 251
105990: PPUSH
105991: LD_VAR 0 4
105995: PPUSH
105996: CALL_OW 495
// end ; end ;
106000: LD_VAR 0 2
106004: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
106005: LD_INT 0
106007: PPUSH
// end ;
106008: LD_VAR 0 4
106012: RET
// export function SOS_Command ( cmd ) ; begin
106013: LD_INT 0
106015: PPUSH
// end ;
106016: LD_VAR 0 2
106020: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
106021: LD_INT 0
106023: PPUSH
// end ;
106024: LD_VAR 0 6
106028: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
106029: LD_INT 0
106031: PPUSH
106032: PPUSH
// if not vehicle or not factory then
106033: LD_VAR 0 1
106037: NOT
106038: PUSH
106039: LD_VAR 0 2
106043: NOT
106044: OR
106045: IFFALSE 106049
// exit ;
106047: GO 106280
// if factoryWaypoints >= factory then
106049: LD_EXP 154
106053: PUSH
106054: LD_VAR 0 2
106058: GREATEREQUAL
106059: IFFALSE 106280
// if factoryWaypoints [ factory ] then
106061: LD_EXP 154
106065: PUSH
106066: LD_VAR 0 2
106070: ARRAY
106071: IFFALSE 106280
// begin if GetControl ( vehicle ) = control_manual then
106073: LD_VAR 0 1
106077: PPUSH
106078: CALL_OW 263
106082: PUSH
106083: LD_INT 1
106085: EQUAL
106086: IFFALSE 106167
// begin driver := IsDrivenBy ( vehicle ) ;
106088: LD_ADDR_VAR 0 4
106092: PUSH
106093: LD_VAR 0 1
106097: PPUSH
106098: CALL_OW 311
106102: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
106103: LD_VAR 0 4
106107: PPUSH
106108: LD_EXP 154
106112: PUSH
106113: LD_VAR 0 2
106117: ARRAY
106118: PUSH
106119: LD_INT 3
106121: ARRAY
106122: PPUSH
106123: LD_EXP 154
106127: PUSH
106128: LD_VAR 0 2
106132: ARRAY
106133: PUSH
106134: LD_INT 4
106136: ARRAY
106137: PPUSH
106138: CALL_OW 171
// AddComExitVehicle ( driver ) ;
106142: LD_VAR 0 4
106146: PPUSH
106147: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
106151: LD_VAR 0 4
106155: PPUSH
106156: LD_VAR 0 2
106160: PPUSH
106161: CALL_OW 180
// end else
106165: GO 106280
// if GetControl ( vehicle ) = control_remote then
106167: LD_VAR 0 1
106171: PPUSH
106172: CALL_OW 263
106176: PUSH
106177: LD_INT 2
106179: EQUAL
106180: IFFALSE 106241
// begin wait ( 0 0$2 ) ;
106182: LD_INT 70
106184: PPUSH
106185: CALL_OW 67
// if Connect ( vehicle ) then
106189: LD_VAR 0 1
106193: PPUSH
106194: CALL 56800 0 1
106198: IFFALSE 106239
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
106200: LD_VAR 0 1
106204: PPUSH
106205: LD_EXP 154
106209: PUSH
106210: LD_VAR 0 2
106214: ARRAY
106215: PUSH
106216: LD_INT 3
106218: ARRAY
106219: PPUSH
106220: LD_EXP 154
106224: PUSH
106225: LD_VAR 0 2
106229: ARRAY
106230: PUSH
106231: LD_INT 4
106233: ARRAY
106234: PPUSH
106235: CALL_OW 171
// end else
106239: GO 106280
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
106241: LD_VAR 0 1
106245: PPUSH
106246: LD_EXP 154
106250: PUSH
106251: LD_VAR 0 2
106255: ARRAY
106256: PUSH
106257: LD_INT 3
106259: ARRAY
106260: PPUSH
106261: LD_EXP 154
106265: PUSH
106266: LD_VAR 0 2
106270: ARRAY
106271: PUSH
106272: LD_INT 4
106274: ARRAY
106275: PPUSH
106276: CALL_OW 171
// end ; end ;
106280: LD_VAR 0 3
106284: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
106285: LD_INT 0
106287: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
106288: LD_VAR 0 1
106292: PUSH
106293: LD_INT 250
106295: EQUAL
106296: PUSH
106297: LD_VAR 0 2
106301: PPUSH
106302: CALL_OW 264
106306: PUSH
106307: LD_INT 81
106309: EQUAL
106310: AND
106311: IFFALSE 106332
// MinerPlaceMine ( unit , x , y ) ;
106313: LD_VAR 0 2
106317: PPUSH
106318: LD_VAR 0 4
106322: PPUSH
106323: LD_VAR 0 5
106327: PPUSH
106328: CALL 108717 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
106332: LD_VAR 0 1
106336: PUSH
106337: LD_INT 251
106339: EQUAL
106340: PUSH
106341: LD_VAR 0 2
106345: PPUSH
106346: CALL_OW 264
106350: PUSH
106351: LD_INT 81
106353: EQUAL
106354: AND
106355: IFFALSE 106376
// MinerDetonateMine ( unit , x , y ) ;
106357: LD_VAR 0 2
106361: PPUSH
106362: LD_VAR 0 4
106366: PPUSH
106367: LD_VAR 0 5
106371: PPUSH
106372: CALL 108992 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
106376: LD_VAR 0 1
106380: PUSH
106381: LD_INT 252
106383: EQUAL
106384: PUSH
106385: LD_VAR 0 2
106389: PPUSH
106390: CALL_OW 264
106394: PUSH
106395: LD_INT 81
106397: EQUAL
106398: AND
106399: IFFALSE 106420
// MinerCreateMinefield ( unit , x , y ) ;
106401: LD_VAR 0 2
106405: PPUSH
106406: LD_VAR 0 4
106410: PPUSH
106411: LD_VAR 0 5
106415: PPUSH
106416: CALL 109409 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
106420: LD_VAR 0 1
106424: PUSH
106425: LD_INT 253
106427: EQUAL
106428: PUSH
106429: LD_VAR 0 2
106433: PPUSH
106434: CALL_OW 257
106438: PUSH
106439: LD_INT 5
106441: EQUAL
106442: AND
106443: IFFALSE 106464
// ComBinocular ( unit , x , y ) ;
106445: LD_VAR 0 2
106449: PPUSH
106450: LD_VAR 0 4
106454: PPUSH
106455: LD_VAR 0 5
106459: PPUSH
106460: CALL 109778 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
106464: LD_VAR 0 1
106468: PUSH
106469: LD_INT 254
106471: EQUAL
106472: PUSH
106473: LD_VAR 0 2
106477: PPUSH
106478: CALL_OW 264
106482: PUSH
106483: LD_INT 99
106485: EQUAL
106486: AND
106487: PUSH
106488: LD_VAR 0 3
106492: PPUSH
106493: CALL_OW 263
106497: PUSH
106498: LD_INT 3
106500: EQUAL
106501: AND
106502: IFFALSE 106518
// HackDestroyVehicle ( unit , selectedUnit ) ;
106504: LD_VAR 0 2
106508: PPUSH
106509: LD_VAR 0 3
106513: PPUSH
106514: CALL 108081 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
106518: LD_VAR 0 1
106522: PUSH
106523: LD_INT 255
106525: EQUAL
106526: PUSH
106527: LD_VAR 0 2
106531: PPUSH
106532: CALL_OW 264
106536: PUSH
106537: LD_INT 14
106539: PUSH
106540: LD_INT 53
106542: PUSH
106543: EMPTY
106544: LIST
106545: LIST
106546: IN
106547: AND
106548: PUSH
106549: LD_VAR 0 4
106553: PPUSH
106554: LD_VAR 0 5
106558: PPUSH
106559: CALL_OW 488
106563: AND
106564: IFFALSE 106588
// CutTreeXYR ( unit , x , y , 12 ) ;
106566: LD_VAR 0 2
106570: PPUSH
106571: LD_VAR 0 4
106575: PPUSH
106576: LD_VAR 0 5
106580: PPUSH
106581: LD_INT 12
106583: PPUSH
106584: CALL 106651 0 4
// if cmd = 256 then
106588: LD_VAR 0 1
106592: PUSH
106593: LD_INT 256
106595: EQUAL
106596: IFFALSE 106617
// SetFactoryWaypoint ( unit , x , y ) ;
106598: LD_VAR 0 2
106602: PPUSH
106603: LD_VAR 0 4
106607: PPUSH
106608: LD_VAR 0 5
106612: PPUSH
106613: CALL 104598 0 3
// if cmd = 257 then
106617: LD_VAR 0 1
106621: PUSH
106622: LD_INT 257
106624: EQUAL
106625: IFFALSE 106646
// SetWarehouseGatheringPoint ( unit , x , y ) ;
106627: LD_VAR 0 2
106631: PPUSH
106632: LD_VAR 0 4
106636: PPUSH
106637: LD_VAR 0 5
106641: PPUSH
106642: CALL 104960 0 3
// end ;
106646: LD_VAR 0 6
106650: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
106651: LD_INT 0
106653: PPUSH
106654: PPUSH
106655: PPUSH
106656: PPUSH
106657: PPUSH
106658: PPUSH
106659: PPUSH
106660: PPUSH
106661: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
106662: LD_VAR 0 1
106666: NOT
106667: PUSH
106668: LD_VAR 0 2
106672: PPUSH
106673: LD_VAR 0 3
106677: PPUSH
106678: CALL_OW 488
106682: NOT
106683: OR
106684: PUSH
106685: LD_VAR 0 4
106689: NOT
106690: OR
106691: IFFALSE 106695
// exit ;
106693: GO 107035
// list := [ ] ;
106695: LD_ADDR_VAR 0 13
106699: PUSH
106700: EMPTY
106701: ST_TO_ADDR
// if x - r < 0 then
106702: LD_VAR 0 2
106706: PUSH
106707: LD_VAR 0 4
106711: MINUS
106712: PUSH
106713: LD_INT 0
106715: LESS
106716: IFFALSE 106728
// min_x := 0 else
106718: LD_ADDR_VAR 0 7
106722: PUSH
106723: LD_INT 0
106725: ST_TO_ADDR
106726: GO 106744
// min_x := x - r ;
106728: LD_ADDR_VAR 0 7
106732: PUSH
106733: LD_VAR 0 2
106737: PUSH
106738: LD_VAR 0 4
106742: MINUS
106743: ST_TO_ADDR
// if y - r < 0 then
106744: LD_VAR 0 3
106748: PUSH
106749: LD_VAR 0 4
106753: MINUS
106754: PUSH
106755: LD_INT 0
106757: LESS
106758: IFFALSE 106770
// min_y := 0 else
106760: LD_ADDR_VAR 0 8
106764: PUSH
106765: LD_INT 0
106767: ST_TO_ADDR
106768: GO 106786
// min_y := y - r ;
106770: LD_ADDR_VAR 0 8
106774: PUSH
106775: LD_VAR 0 3
106779: PUSH
106780: LD_VAR 0 4
106784: MINUS
106785: ST_TO_ADDR
// max_x := x + r ;
106786: LD_ADDR_VAR 0 9
106790: PUSH
106791: LD_VAR 0 2
106795: PUSH
106796: LD_VAR 0 4
106800: PLUS
106801: ST_TO_ADDR
// max_y := y + r ;
106802: LD_ADDR_VAR 0 10
106806: PUSH
106807: LD_VAR 0 3
106811: PUSH
106812: LD_VAR 0 4
106816: PLUS
106817: ST_TO_ADDR
// for _x = min_x to max_x do
106818: LD_ADDR_VAR 0 11
106822: PUSH
106823: DOUBLE
106824: LD_VAR 0 7
106828: DEC
106829: ST_TO_ADDR
106830: LD_VAR 0 9
106834: PUSH
106835: FOR_TO
106836: IFFALSE 106953
// for _y = min_y to max_y do
106838: LD_ADDR_VAR 0 12
106842: PUSH
106843: DOUBLE
106844: LD_VAR 0 8
106848: DEC
106849: ST_TO_ADDR
106850: LD_VAR 0 10
106854: PUSH
106855: FOR_TO
106856: IFFALSE 106949
// begin if not ValidHex ( _x , _y ) then
106858: LD_VAR 0 11
106862: PPUSH
106863: LD_VAR 0 12
106867: PPUSH
106868: CALL_OW 488
106872: NOT
106873: IFFALSE 106877
// continue ;
106875: GO 106855
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
106877: LD_VAR 0 11
106881: PPUSH
106882: LD_VAR 0 12
106886: PPUSH
106887: CALL_OW 351
106891: PUSH
106892: LD_VAR 0 11
106896: PPUSH
106897: LD_VAR 0 12
106901: PPUSH
106902: CALL_OW 554
106906: AND
106907: IFFALSE 106947
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
106909: LD_ADDR_VAR 0 13
106913: PUSH
106914: LD_VAR 0 13
106918: PPUSH
106919: LD_VAR 0 13
106923: PUSH
106924: LD_INT 1
106926: PLUS
106927: PPUSH
106928: LD_VAR 0 11
106932: PUSH
106933: LD_VAR 0 12
106937: PUSH
106938: EMPTY
106939: LIST
106940: LIST
106941: PPUSH
106942: CALL_OW 2
106946: ST_TO_ADDR
// end ;
106947: GO 106855
106949: POP
106950: POP
106951: GO 106835
106953: POP
106954: POP
// if not list then
106955: LD_VAR 0 13
106959: NOT
106960: IFFALSE 106964
// exit ;
106962: GO 107035
// for i in list do
106964: LD_ADDR_VAR 0 6
106968: PUSH
106969: LD_VAR 0 13
106973: PUSH
106974: FOR_IN
106975: IFFALSE 107033
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
106977: LD_VAR 0 1
106981: PPUSH
106982: LD_STRING M
106984: PUSH
106985: LD_VAR 0 6
106989: PUSH
106990: LD_INT 1
106992: ARRAY
106993: PUSH
106994: LD_VAR 0 6
106998: PUSH
106999: LD_INT 2
107001: ARRAY
107002: PUSH
107003: LD_INT 0
107005: PUSH
107006: LD_INT 0
107008: PUSH
107009: LD_INT 0
107011: PUSH
107012: LD_INT 0
107014: PUSH
107015: EMPTY
107016: LIST
107017: LIST
107018: LIST
107019: LIST
107020: LIST
107021: LIST
107022: LIST
107023: PUSH
107024: EMPTY
107025: LIST
107026: PPUSH
107027: CALL_OW 447
107031: GO 106974
107033: POP
107034: POP
// end ;
107035: LD_VAR 0 5
107039: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
107040: LD_EXP 157
107044: NOT
107045: IFFALSE 107095
107047: GO 107049
107049: DISABLE
// begin initHack := true ;
107050: LD_ADDR_EXP 157
107054: PUSH
107055: LD_INT 1
107057: ST_TO_ADDR
// hackTanks := [ ] ;
107058: LD_ADDR_EXP 158
107062: PUSH
107063: EMPTY
107064: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
107065: LD_ADDR_EXP 159
107069: PUSH
107070: EMPTY
107071: ST_TO_ADDR
// hackLimit := 3 ;
107072: LD_ADDR_EXP 160
107076: PUSH
107077: LD_INT 3
107079: ST_TO_ADDR
// hackDist := 12 ;
107080: LD_ADDR_EXP 161
107084: PUSH
107085: LD_INT 12
107087: ST_TO_ADDR
// hackCounter := [ ] ;
107088: LD_ADDR_EXP 162
107092: PUSH
107093: EMPTY
107094: ST_TO_ADDR
// end ;
107095: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
107096: LD_EXP 157
107100: PUSH
107101: LD_INT 34
107103: PUSH
107104: LD_INT 99
107106: PUSH
107107: EMPTY
107108: LIST
107109: LIST
107110: PPUSH
107111: CALL_OW 69
107115: AND
107116: IFFALSE 107369
107118: GO 107120
107120: DISABLE
107121: LD_INT 0
107123: PPUSH
107124: PPUSH
// begin enable ;
107125: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
107126: LD_ADDR_VAR 0 1
107130: PUSH
107131: LD_INT 34
107133: PUSH
107134: LD_INT 99
107136: PUSH
107137: EMPTY
107138: LIST
107139: LIST
107140: PPUSH
107141: CALL_OW 69
107145: PUSH
107146: FOR_IN
107147: IFFALSE 107367
// begin if not i in hackTanks then
107149: LD_VAR 0 1
107153: PUSH
107154: LD_EXP 158
107158: IN
107159: NOT
107160: IFFALSE 107243
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
107162: LD_ADDR_EXP 158
107166: PUSH
107167: LD_EXP 158
107171: PPUSH
107172: LD_EXP 158
107176: PUSH
107177: LD_INT 1
107179: PLUS
107180: PPUSH
107181: LD_VAR 0 1
107185: PPUSH
107186: CALL_OW 1
107190: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
107191: LD_ADDR_EXP 159
107195: PUSH
107196: LD_EXP 159
107200: PPUSH
107201: LD_EXP 159
107205: PUSH
107206: LD_INT 1
107208: PLUS
107209: PPUSH
107210: EMPTY
107211: PPUSH
107212: CALL_OW 1
107216: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
107217: LD_ADDR_EXP 162
107221: PUSH
107222: LD_EXP 162
107226: PPUSH
107227: LD_EXP 162
107231: PUSH
107232: LD_INT 1
107234: PLUS
107235: PPUSH
107236: EMPTY
107237: PPUSH
107238: CALL_OW 1
107242: ST_TO_ADDR
// end ; if not IsOk ( i ) then
107243: LD_VAR 0 1
107247: PPUSH
107248: CALL_OW 302
107252: NOT
107253: IFFALSE 107266
// begin HackUnlinkAll ( i ) ;
107255: LD_VAR 0 1
107259: PPUSH
107260: CALL 107372 0 1
// continue ;
107264: GO 107146
// end ; HackCheckCapturedStatus ( i ) ;
107266: LD_VAR 0 1
107270: PPUSH
107271: CALL 107815 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
107275: LD_ADDR_VAR 0 2
107279: PUSH
107280: LD_INT 81
107282: PUSH
107283: LD_VAR 0 1
107287: PPUSH
107288: CALL_OW 255
107292: PUSH
107293: EMPTY
107294: LIST
107295: LIST
107296: PUSH
107297: LD_INT 33
107299: PUSH
107300: LD_INT 3
107302: PUSH
107303: EMPTY
107304: LIST
107305: LIST
107306: PUSH
107307: LD_INT 91
107309: PUSH
107310: LD_VAR 0 1
107314: PUSH
107315: LD_EXP 161
107319: PUSH
107320: EMPTY
107321: LIST
107322: LIST
107323: LIST
107324: PUSH
107325: LD_INT 50
107327: PUSH
107328: EMPTY
107329: LIST
107330: PUSH
107331: EMPTY
107332: LIST
107333: LIST
107334: LIST
107335: LIST
107336: PPUSH
107337: CALL_OW 69
107341: ST_TO_ADDR
// if not tmp then
107342: LD_VAR 0 2
107346: NOT
107347: IFFALSE 107351
// continue ;
107349: GO 107146
// HackLink ( i , tmp ) ;
107351: LD_VAR 0 1
107355: PPUSH
107356: LD_VAR 0 2
107360: PPUSH
107361: CALL 107508 0 2
// end ;
107365: GO 107146
107367: POP
107368: POP
// end ;
107369: PPOPN 2
107371: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
107372: LD_INT 0
107374: PPUSH
107375: PPUSH
107376: PPUSH
// if not hack in hackTanks then
107377: LD_VAR 0 1
107381: PUSH
107382: LD_EXP 158
107386: IN
107387: NOT
107388: IFFALSE 107392
// exit ;
107390: GO 107503
// index := GetElementIndex ( hackTanks , hack ) ;
107392: LD_ADDR_VAR 0 4
107396: PUSH
107397: LD_EXP 158
107401: PPUSH
107402: LD_VAR 0 1
107406: PPUSH
107407: CALL 53616 0 2
107411: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
107412: LD_EXP 159
107416: PUSH
107417: LD_VAR 0 4
107421: ARRAY
107422: IFFALSE 107503
// begin for i in hackTanksCaptured [ index ] do
107424: LD_ADDR_VAR 0 3
107428: PUSH
107429: LD_EXP 159
107433: PUSH
107434: LD_VAR 0 4
107438: ARRAY
107439: PUSH
107440: FOR_IN
107441: IFFALSE 107467
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
107443: LD_VAR 0 3
107447: PUSH
107448: LD_INT 1
107450: ARRAY
107451: PPUSH
107452: LD_VAR 0 3
107456: PUSH
107457: LD_INT 2
107459: ARRAY
107460: PPUSH
107461: CALL_OW 235
107465: GO 107440
107467: POP
107468: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
107469: LD_ADDR_EXP 159
107473: PUSH
107474: LD_EXP 159
107478: PPUSH
107479: LD_VAR 0 4
107483: PPUSH
107484: EMPTY
107485: PPUSH
107486: CALL_OW 1
107490: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
107491: LD_VAR 0 1
107495: PPUSH
107496: LD_INT 0
107498: PPUSH
107499: CALL_OW 505
// end ; end ;
107503: LD_VAR 0 2
107507: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
107508: LD_INT 0
107510: PPUSH
107511: PPUSH
107512: PPUSH
// if not hack in hackTanks or not vehicles then
107513: LD_VAR 0 1
107517: PUSH
107518: LD_EXP 158
107522: IN
107523: NOT
107524: PUSH
107525: LD_VAR 0 2
107529: NOT
107530: OR
107531: IFFALSE 107535
// exit ;
107533: GO 107810
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
107535: LD_ADDR_VAR 0 2
107539: PUSH
107540: LD_VAR 0 1
107544: PPUSH
107545: LD_VAR 0 2
107549: PPUSH
107550: LD_INT 1
107552: PPUSH
107553: LD_INT 1
107555: PPUSH
107556: CALL 54266 0 4
107560: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
107561: LD_ADDR_VAR 0 5
107565: PUSH
107566: LD_EXP 158
107570: PPUSH
107571: LD_VAR 0 1
107575: PPUSH
107576: CALL 53616 0 2
107580: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
107581: LD_EXP 159
107585: PUSH
107586: LD_VAR 0 5
107590: ARRAY
107591: PUSH
107592: LD_EXP 160
107596: LESS
107597: IFFALSE 107786
// begin for i := 1 to vehicles do
107599: LD_ADDR_VAR 0 4
107603: PUSH
107604: DOUBLE
107605: LD_INT 1
107607: DEC
107608: ST_TO_ADDR
107609: LD_VAR 0 2
107613: PUSH
107614: FOR_TO
107615: IFFALSE 107784
// begin if hackTanksCaptured [ index ] = hackLimit then
107617: LD_EXP 159
107621: PUSH
107622: LD_VAR 0 5
107626: ARRAY
107627: PUSH
107628: LD_EXP 160
107632: EQUAL
107633: IFFALSE 107637
// break ;
107635: GO 107784
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
107637: LD_ADDR_EXP 162
107641: PUSH
107642: LD_EXP 162
107646: PPUSH
107647: LD_VAR 0 5
107651: PPUSH
107652: LD_EXP 162
107656: PUSH
107657: LD_VAR 0 5
107661: ARRAY
107662: PUSH
107663: LD_INT 1
107665: PLUS
107666: PPUSH
107667: CALL_OW 1
107671: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
107672: LD_ADDR_EXP 159
107676: PUSH
107677: LD_EXP 159
107681: PPUSH
107682: LD_VAR 0 5
107686: PUSH
107687: LD_EXP 159
107691: PUSH
107692: LD_VAR 0 5
107696: ARRAY
107697: PUSH
107698: LD_INT 1
107700: PLUS
107701: PUSH
107702: EMPTY
107703: LIST
107704: LIST
107705: PPUSH
107706: LD_VAR 0 2
107710: PUSH
107711: LD_VAR 0 4
107715: ARRAY
107716: PUSH
107717: LD_VAR 0 2
107721: PUSH
107722: LD_VAR 0 4
107726: ARRAY
107727: PPUSH
107728: CALL_OW 255
107732: PUSH
107733: EMPTY
107734: LIST
107735: LIST
107736: PPUSH
107737: CALL 53831 0 3
107741: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
107742: LD_VAR 0 2
107746: PUSH
107747: LD_VAR 0 4
107751: ARRAY
107752: PPUSH
107753: LD_VAR 0 1
107757: PPUSH
107758: CALL_OW 255
107762: PPUSH
107763: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
107767: LD_VAR 0 2
107771: PUSH
107772: LD_VAR 0 4
107776: ARRAY
107777: PPUSH
107778: CALL_OW 141
// end ;
107782: GO 107614
107784: POP
107785: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
107786: LD_VAR 0 1
107790: PPUSH
107791: LD_EXP 159
107795: PUSH
107796: LD_VAR 0 5
107800: ARRAY
107801: PUSH
107802: LD_INT 0
107804: PLUS
107805: PPUSH
107806: CALL_OW 505
// end ;
107810: LD_VAR 0 3
107814: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
107815: LD_INT 0
107817: PPUSH
107818: PPUSH
107819: PPUSH
107820: PPUSH
// if not hack in hackTanks then
107821: LD_VAR 0 1
107825: PUSH
107826: LD_EXP 158
107830: IN
107831: NOT
107832: IFFALSE 107836
// exit ;
107834: GO 108076
// index := GetElementIndex ( hackTanks , hack ) ;
107836: LD_ADDR_VAR 0 4
107840: PUSH
107841: LD_EXP 158
107845: PPUSH
107846: LD_VAR 0 1
107850: PPUSH
107851: CALL 53616 0 2
107855: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
107856: LD_ADDR_VAR 0 3
107860: PUSH
107861: DOUBLE
107862: LD_EXP 159
107866: PUSH
107867: LD_VAR 0 4
107871: ARRAY
107872: INC
107873: ST_TO_ADDR
107874: LD_INT 1
107876: PUSH
107877: FOR_DOWNTO
107878: IFFALSE 108050
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
107880: LD_ADDR_VAR 0 5
107884: PUSH
107885: LD_EXP 159
107889: PUSH
107890: LD_VAR 0 4
107894: ARRAY
107895: PUSH
107896: LD_VAR 0 3
107900: ARRAY
107901: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
107902: LD_VAR 0 5
107906: PUSH
107907: LD_INT 1
107909: ARRAY
107910: PPUSH
107911: CALL_OW 302
107915: NOT
107916: PUSH
107917: LD_VAR 0 5
107921: PUSH
107922: LD_INT 1
107924: ARRAY
107925: PPUSH
107926: CALL_OW 255
107930: PUSH
107931: LD_VAR 0 1
107935: PPUSH
107936: CALL_OW 255
107940: NONEQUAL
107941: OR
107942: IFFALSE 108048
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
107944: LD_VAR 0 5
107948: PUSH
107949: LD_INT 1
107951: ARRAY
107952: PPUSH
107953: CALL_OW 305
107957: PUSH
107958: LD_VAR 0 5
107962: PUSH
107963: LD_INT 1
107965: ARRAY
107966: PPUSH
107967: CALL_OW 255
107971: PUSH
107972: LD_VAR 0 1
107976: PPUSH
107977: CALL_OW 255
107981: EQUAL
107982: AND
107983: IFFALSE 108007
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
107985: LD_VAR 0 5
107989: PUSH
107990: LD_INT 1
107992: ARRAY
107993: PPUSH
107994: LD_VAR 0 5
107998: PUSH
107999: LD_INT 2
108001: ARRAY
108002: PPUSH
108003: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
108007: LD_ADDR_EXP 159
108011: PUSH
108012: LD_EXP 159
108016: PPUSH
108017: LD_VAR 0 4
108021: PPUSH
108022: LD_EXP 159
108026: PUSH
108027: LD_VAR 0 4
108031: ARRAY
108032: PPUSH
108033: LD_VAR 0 3
108037: PPUSH
108038: CALL_OW 3
108042: PPUSH
108043: CALL_OW 1
108047: ST_TO_ADDR
// end ; end ;
108048: GO 107877
108050: POP
108051: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
108052: LD_VAR 0 1
108056: PPUSH
108057: LD_EXP 159
108061: PUSH
108062: LD_VAR 0 4
108066: ARRAY
108067: PUSH
108068: LD_INT 0
108070: PLUS
108071: PPUSH
108072: CALL_OW 505
// end ;
108076: LD_VAR 0 2
108080: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
108081: LD_INT 0
108083: PPUSH
108084: PPUSH
108085: PPUSH
108086: PPUSH
// if not hack in hackTanks then
108087: LD_VAR 0 1
108091: PUSH
108092: LD_EXP 158
108096: IN
108097: NOT
108098: IFFALSE 108102
// exit ;
108100: GO 108187
// index := GetElementIndex ( hackTanks , hack ) ;
108102: LD_ADDR_VAR 0 5
108106: PUSH
108107: LD_EXP 158
108111: PPUSH
108112: LD_VAR 0 1
108116: PPUSH
108117: CALL 53616 0 2
108121: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
108122: LD_ADDR_VAR 0 4
108126: PUSH
108127: DOUBLE
108128: LD_INT 1
108130: DEC
108131: ST_TO_ADDR
108132: LD_EXP 159
108136: PUSH
108137: LD_VAR 0 5
108141: ARRAY
108142: PUSH
108143: FOR_TO
108144: IFFALSE 108185
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
108146: LD_EXP 159
108150: PUSH
108151: LD_VAR 0 5
108155: ARRAY
108156: PUSH
108157: LD_VAR 0 4
108161: ARRAY
108162: PUSH
108163: LD_INT 1
108165: ARRAY
108166: PUSH
108167: LD_VAR 0 2
108171: EQUAL
108172: IFFALSE 108183
// KillUnit ( vehicle ) ;
108174: LD_VAR 0 2
108178: PPUSH
108179: CALL_OW 66
108183: GO 108143
108185: POP
108186: POP
// end ;
108187: LD_VAR 0 3
108191: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
108192: LD_EXP 163
108196: NOT
108197: IFFALSE 108232
108199: GO 108201
108201: DISABLE
// begin initMiner := true ;
108202: LD_ADDR_EXP 163
108206: PUSH
108207: LD_INT 1
108209: ST_TO_ADDR
// minersList := [ ] ;
108210: LD_ADDR_EXP 164
108214: PUSH
108215: EMPTY
108216: ST_TO_ADDR
// minerMinesList := [ ] ;
108217: LD_ADDR_EXP 165
108221: PUSH
108222: EMPTY
108223: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
108224: LD_ADDR_EXP 166
108228: PUSH
108229: LD_INT 5
108231: ST_TO_ADDR
// end ;
108232: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
108233: LD_EXP 163
108237: PUSH
108238: LD_INT 34
108240: PUSH
108241: LD_INT 81
108243: PUSH
108244: EMPTY
108245: LIST
108246: LIST
108247: PPUSH
108248: CALL_OW 69
108252: AND
108253: IFFALSE 108714
108255: GO 108257
108257: DISABLE
108258: LD_INT 0
108260: PPUSH
108261: PPUSH
108262: PPUSH
108263: PPUSH
// begin enable ;
108264: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
108265: LD_ADDR_VAR 0 1
108269: PUSH
108270: LD_INT 34
108272: PUSH
108273: LD_INT 81
108275: PUSH
108276: EMPTY
108277: LIST
108278: LIST
108279: PPUSH
108280: CALL_OW 69
108284: PUSH
108285: FOR_IN
108286: IFFALSE 108358
// begin if not i in minersList then
108288: LD_VAR 0 1
108292: PUSH
108293: LD_EXP 164
108297: IN
108298: NOT
108299: IFFALSE 108356
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
108301: LD_ADDR_EXP 164
108305: PUSH
108306: LD_EXP 164
108310: PPUSH
108311: LD_EXP 164
108315: PUSH
108316: LD_INT 1
108318: PLUS
108319: PPUSH
108320: LD_VAR 0 1
108324: PPUSH
108325: CALL_OW 1
108329: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
108330: LD_ADDR_EXP 165
108334: PUSH
108335: LD_EXP 165
108339: PPUSH
108340: LD_EXP 165
108344: PUSH
108345: LD_INT 1
108347: PLUS
108348: PPUSH
108349: EMPTY
108350: PPUSH
108351: CALL_OW 1
108355: ST_TO_ADDR
// end end ;
108356: GO 108285
108358: POP
108359: POP
// for i := minerMinesList downto 1 do
108360: LD_ADDR_VAR 0 1
108364: PUSH
108365: DOUBLE
108366: LD_EXP 165
108370: INC
108371: ST_TO_ADDR
108372: LD_INT 1
108374: PUSH
108375: FOR_DOWNTO
108376: IFFALSE 108712
// begin if IsLive ( minersList [ i ] ) then
108378: LD_EXP 164
108382: PUSH
108383: LD_VAR 0 1
108387: ARRAY
108388: PPUSH
108389: CALL_OW 300
108393: IFFALSE 108421
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
108395: LD_EXP 164
108399: PUSH
108400: LD_VAR 0 1
108404: ARRAY
108405: PPUSH
108406: LD_EXP 165
108410: PUSH
108411: LD_VAR 0 1
108415: ARRAY
108416: PPUSH
108417: CALL_OW 505
// if not minerMinesList [ i ] then
108421: LD_EXP 165
108425: PUSH
108426: LD_VAR 0 1
108430: ARRAY
108431: NOT
108432: IFFALSE 108436
// continue ;
108434: GO 108375
// for j := minerMinesList [ i ] downto 1 do
108436: LD_ADDR_VAR 0 2
108440: PUSH
108441: DOUBLE
108442: LD_EXP 165
108446: PUSH
108447: LD_VAR 0 1
108451: ARRAY
108452: INC
108453: ST_TO_ADDR
108454: LD_INT 1
108456: PUSH
108457: FOR_DOWNTO
108458: IFFALSE 108708
// begin side := GetSide ( minersList [ i ] ) ;
108460: LD_ADDR_VAR 0 3
108464: PUSH
108465: LD_EXP 164
108469: PUSH
108470: LD_VAR 0 1
108474: ARRAY
108475: PPUSH
108476: CALL_OW 255
108480: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
108481: LD_ADDR_VAR 0 4
108485: PUSH
108486: LD_EXP 165
108490: PUSH
108491: LD_VAR 0 1
108495: ARRAY
108496: PUSH
108497: LD_VAR 0 2
108501: ARRAY
108502: PUSH
108503: LD_INT 1
108505: ARRAY
108506: PPUSH
108507: LD_EXP 165
108511: PUSH
108512: LD_VAR 0 1
108516: ARRAY
108517: PUSH
108518: LD_VAR 0 2
108522: ARRAY
108523: PUSH
108524: LD_INT 2
108526: ARRAY
108527: PPUSH
108528: CALL_OW 428
108532: ST_TO_ADDR
// if not tmp then
108533: LD_VAR 0 4
108537: NOT
108538: IFFALSE 108542
// continue ;
108540: GO 108457
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
108542: LD_VAR 0 4
108546: PUSH
108547: LD_INT 81
108549: PUSH
108550: LD_VAR 0 3
108554: PUSH
108555: EMPTY
108556: LIST
108557: LIST
108558: PPUSH
108559: CALL_OW 69
108563: IN
108564: PUSH
108565: LD_EXP 165
108569: PUSH
108570: LD_VAR 0 1
108574: ARRAY
108575: PUSH
108576: LD_VAR 0 2
108580: ARRAY
108581: PUSH
108582: LD_INT 1
108584: ARRAY
108585: PPUSH
108586: LD_EXP 165
108590: PUSH
108591: LD_VAR 0 1
108595: ARRAY
108596: PUSH
108597: LD_VAR 0 2
108601: ARRAY
108602: PUSH
108603: LD_INT 2
108605: ARRAY
108606: PPUSH
108607: CALL_OW 458
108611: AND
108612: IFFALSE 108706
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
108614: LD_EXP 165
108618: PUSH
108619: LD_VAR 0 1
108623: ARRAY
108624: PUSH
108625: LD_VAR 0 2
108629: ARRAY
108630: PUSH
108631: LD_INT 1
108633: ARRAY
108634: PPUSH
108635: LD_EXP 165
108639: PUSH
108640: LD_VAR 0 1
108644: ARRAY
108645: PUSH
108646: LD_VAR 0 2
108650: ARRAY
108651: PUSH
108652: LD_INT 2
108654: ARRAY
108655: PPUSH
108656: LD_VAR 0 3
108660: PPUSH
108661: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
108665: LD_ADDR_EXP 165
108669: PUSH
108670: LD_EXP 165
108674: PPUSH
108675: LD_VAR 0 1
108679: PPUSH
108680: LD_EXP 165
108684: PUSH
108685: LD_VAR 0 1
108689: ARRAY
108690: PPUSH
108691: LD_VAR 0 2
108695: PPUSH
108696: CALL_OW 3
108700: PPUSH
108701: CALL_OW 1
108705: ST_TO_ADDR
// end ; end ;
108706: GO 108457
108708: POP
108709: POP
// end ;
108710: GO 108375
108712: POP
108713: POP
// end ;
108714: PPOPN 4
108716: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
108717: LD_INT 0
108719: PPUSH
108720: PPUSH
// result := false ;
108721: LD_ADDR_VAR 0 4
108725: PUSH
108726: LD_INT 0
108728: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
108729: LD_VAR 0 1
108733: PPUSH
108734: CALL_OW 264
108738: PUSH
108739: LD_INT 81
108741: EQUAL
108742: NOT
108743: IFFALSE 108747
// exit ;
108745: GO 108987
// index := GetElementIndex ( minersList , unit ) ;
108747: LD_ADDR_VAR 0 5
108751: PUSH
108752: LD_EXP 164
108756: PPUSH
108757: LD_VAR 0 1
108761: PPUSH
108762: CALL 53616 0 2
108766: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
108767: LD_EXP 165
108771: PUSH
108772: LD_VAR 0 5
108776: ARRAY
108777: PUSH
108778: LD_EXP 166
108782: GREATEREQUAL
108783: IFFALSE 108787
// exit ;
108785: GO 108987
// ComMoveXY ( unit , x , y ) ;
108787: LD_VAR 0 1
108791: PPUSH
108792: LD_VAR 0 2
108796: PPUSH
108797: LD_VAR 0 3
108801: PPUSH
108802: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
108806: LD_INT 35
108808: PPUSH
108809: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
108813: LD_VAR 0 1
108817: PPUSH
108818: LD_VAR 0 2
108822: PPUSH
108823: LD_VAR 0 3
108827: PPUSH
108828: CALL 84971 0 3
108832: NOT
108833: PUSH
108834: LD_VAR 0 1
108838: PPUSH
108839: CALL_OW 314
108843: AND
108844: IFFALSE 108848
// exit ;
108846: GO 108987
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
108848: LD_VAR 0 2
108852: PPUSH
108853: LD_VAR 0 3
108857: PPUSH
108858: CALL_OW 428
108862: PUSH
108863: LD_VAR 0 1
108867: EQUAL
108868: PUSH
108869: LD_VAR 0 1
108873: PPUSH
108874: CALL_OW 314
108878: NOT
108879: AND
108880: IFFALSE 108806
// PlaySoundXY ( x , y , PlantMine ) ;
108882: LD_VAR 0 2
108886: PPUSH
108887: LD_VAR 0 3
108891: PPUSH
108892: LD_STRING PlantMine
108894: PPUSH
108895: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
108899: LD_VAR 0 2
108903: PPUSH
108904: LD_VAR 0 3
108908: PPUSH
108909: LD_VAR 0 1
108913: PPUSH
108914: CALL_OW 255
108918: PPUSH
108919: LD_INT 0
108921: PPUSH
108922: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
108926: LD_ADDR_EXP 165
108930: PUSH
108931: LD_EXP 165
108935: PPUSH
108936: LD_VAR 0 5
108940: PUSH
108941: LD_EXP 165
108945: PUSH
108946: LD_VAR 0 5
108950: ARRAY
108951: PUSH
108952: LD_INT 1
108954: PLUS
108955: PUSH
108956: EMPTY
108957: LIST
108958: LIST
108959: PPUSH
108960: LD_VAR 0 2
108964: PUSH
108965: LD_VAR 0 3
108969: PUSH
108970: EMPTY
108971: LIST
108972: LIST
108973: PPUSH
108974: CALL 53831 0 3
108978: ST_TO_ADDR
// result := true ;
108979: LD_ADDR_VAR 0 4
108983: PUSH
108984: LD_INT 1
108986: ST_TO_ADDR
// end ;
108987: LD_VAR 0 4
108991: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
108992: LD_INT 0
108994: PPUSH
108995: PPUSH
108996: PPUSH
// if not unit in minersList then
108997: LD_VAR 0 1
109001: PUSH
109002: LD_EXP 164
109006: IN
109007: NOT
109008: IFFALSE 109012
// exit ;
109010: GO 109404
// index := GetElementIndex ( minersList , unit ) ;
109012: LD_ADDR_VAR 0 6
109016: PUSH
109017: LD_EXP 164
109021: PPUSH
109022: LD_VAR 0 1
109026: PPUSH
109027: CALL 53616 0 2
109031: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
109032: LD_ADDR_VAR 0 5
109036: PUSH
109037: DOUBLE
109038: LD_EXP 165
109042: PUSH
109043: LD_VAR 0 6
109047: ARRAY
109048: INC
109049: ST_TO_ADDR
109050: LD_INT 1
109052: PUSH
109053: FOR_DOWNTO
109054: IFFALSE 109215
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
109056: LD_EXP 165
109060: PUSH
109061: LD_VAR 0 6
109065: ARRAY
109066: PUSH
109067: LD_VAR 0 5
109071: ARRAY
109072: PUSH
109073: LD_INT 1
109075: ARRAY
109076: PUSH
109077: LD_VAR 0 2
109081: EQUAL
109082: PUSH
109083: LD_EXP 165
109087: PUSH
109088: LD_VAR 0 6
109092: ARRAY
109093: PUSH
109094: LD_VAR 0 5
109098: ARRAY
109099: PUSH
109100: LD_INT 2
109102: ARRAY
109103: PUSH
109104: LD_VAR 0 3
109108: EQUAL
109109: AND
109110: IFFALSE 109213
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
109112: LD_EXP 165
109116: PUSH
109117: LD_VAR 0 6
109121: ARRAY
109122: PUSH
109123: LD_VAR 0 5
109127: ARRAY
109128: PUSH
109129: LD_INT 1
109131: ARRAY
109132: PPUSH
109133: LD_EXP 165
109137: PUSH
109138: LD_VAR 0 6
109142: ARRAY
109143: PUSH
109144: LD_VAR 0 5
109148: ARRAY
109149: PUSH
109150: LD_INT 2
109152: ARRAY
109153: PPUSH
109154: LD_VAR 0 1
109158: PPUSH
109159: CALL_OW 255
109163: PPUSH
109164: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
109168: LD_ADDR_EXP 165
109172: PUSH
109173: LD_EXP 165
109177: PPUSH
109178: LD_VAR 0 6
109182: PPUSH
109183: LD_EXP 165
109187: PUSH
109188: LD_VAR 0 6
109192: ARRAY
109193: PPUSH
109194: LD_VAR 0 5
109198: PPUSH
109199: CALL_OW 3
109203: PPUSH
109204: CALL_OW 1
109208: ST_TO_ADDR
// exit ;
109209: POP
109210: POP
109211: GO 109404
// end ; end ;
109213: GO 109053
109215: POP
109216: POP
// for i := minerMinesList [ index ] downto 1 do
109217: LD_ADDR_VAR 0 5
109221: PUSH
109222: DOUBLE
109223: LD_EXP 165
109227: PUSH
109228: LD_VAR 0 6
109232: ARRAY
109233: INC
109234: ST_TO_ADDR
109235: LD_INT 1
109237: PUSH
109238: FOR_DOWNTO
109239: IFFALSE 109402
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
109241: LD_EXP 165
109245: PUSH
109246: LD_VAR 0 6
109250: ARRAY
109251: PUSH
109252: LD_VAR 0 5
109256: ARRAY
109257: PUSH
109258: LD_INT 1
109260: ARRAY
109261: PPUSH
109262: LD_EXP 165
109266: PUSH
109267: LD_VAR 0 6
109271: ARRAY
109272: PUSH
109273: LD_VAR 0 5
109277: ARRAY
109278: PUSH
109279: LD_INT 2
109281: ARRAY
109282: PPUSH
109283: LD_VAR 0 2
109287: PPUSH
109288: LD_VAR 0 3
109292: PPUSH
109293: CALL_OW 298
109297: PUSH
109298: LD_INT 6
109300: LESS
109301: IFFALSE 109400
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
109303: LD_EXP 165
109307: PUSH
109308: LD_VAR 0 6
109312: ARRAY
109313: PUSH
109314: LD_VAR 0 5
109318: ARRAY
109319: PUSH
109320: LD_INT 1
109322: ARRAY
109323: PPUSH
109324: LD_EXP 165
109328: PUSH
109329: LD_VAR 0 6
109333: ARRAY
109334: PUSH
109335: LD_VAR 0 5
109339: ARRAY
109340: PUSH
109341: LD_INT 2
109343: ARRAY
109344: PPUSH
109345: LD_VAR 0 1
109349: PPUSH
109350: CALL_OW 255
109354: PPUSH
109355: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
109359: LD_ADDR_EXP 165
109363: PUSH
109364: LD_EXP 165
109368: PPUSH
109369: LD_VAR 0 6
109373: PPUSH
109374: LD_EXP 165
109378: PUSH
109379: LD_VAR 0 6
109383: ARRAY
109384: PPUSH
109385: LD_VAR 0 5
109389: PPUSH
109390: CALL_OW 3
109394: PPUSH
109395: CALL_OW 1
109399: ST_TO_ADDR
// end ; end ;
109400: GO 109238
109402: POP
109403: POP
// end ;
109404: LD_VAR 0 4
109408: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
109409: LD_INT 0
109411: PPUSH
109412: PPUSH
109413: PPUSH
109414: PPUSH
109415: PPUSH
109416: PPUSH
109417: PPUSH
109418: PPUSH
109419: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
109420: LD_VAR 0 1
109424: PPUSH
109425: CALL_OW 264
109429: PUSH
109430: LD_INT 81
109432: EQUAL
109433: NOT
109434: PUSH
109435: LD_VAR 0 1
109439: PUSH
109440: LD_EXP 164
109444: IN
109445: NOT
109446: OR
109447: IFFALSE 109451
// exit ;
109449: GO 109773
// index := GetElementIndex ( minersList , unit ) ;
109451: LD_ADDR_VAR 0 6
109455: PUSH
109456: LD_EXP 164
109460: PPUSH
109461: LD_VAR 0 1
109465: PPUSH
109466: CALL 53616 0 2
109470: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
109471: LD_ADDR_VAR 0 8
109475: PUSH
109476: LD_EXP 166
109480: PUSH
109481: LD_EXP 165
109485: PUSH
109486: LD_VAR 0 6
109490: ARRAY
109491: MINUS
109492: ST_TO_ADDR
// if not minesFreeAmount then
109493: LD_VAR 0 8
109497: NOT
109498: IFFALSE 109502
// exit ;
109500: GO 109773
// tmp := [ ] ;
109502: LD_ADDR_VAR 0 7
109506: PUSH
109507: EMPTY
109508: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
109509: LD_ADDR_VAR 0 5
109513: PUSH
109514: DOUBLE
109515: LD_INT 1
109517: DEC
109518: ST_TO_ADDR
109519: LD_VAR 0 8
109523: PUSH
109524: FOR_TO
109525: IFFALSE 109720
// begin _d := rand ( 0 , 5 ) ;
109527: LD_ADDR_VAR 0 11
109531: PUSH
109532: LD_INT 0
109534: PPUSH
109535: LD_INT 5
109537: PPUSH
109538: CALL_OW 12
109542: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
109543: LD_ADDR_VAR 0 12
109547: PUSH
109548: LD_INT 2
109550: PPUSH
109551: LD_INT 6
109553: PPUSH
109554: CALL_OW 12
109558: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
109559: LD_ADDR_VAR 0 9
109563: PUSH
109564: LD_VAR 0 2
109568: PPUSH
109569: LD_VAR 0 11
109573: PPUSH
109574: LD_VAR 0 12
109578: PPUSH
109579: CALL_OW 272
109583: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
109584: LD_ADDR_VAR 0 10
109588: PUSH
109589: LD_VAR 0 3
109593: PPUSH
109594: LD_VAR 0 11
109598: PPUSH
109599: LD_VAR 0 12
109603: PPUSH
109604: CALL_OW 273
109608: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
109609: LD_VAR 0 9
109613: PPUSH
109614: LD_VAR 0 10
109618: PPUSH
109619: CALL_OW 488
109623: PUSH
109624: LD_VAR 0 9
109628: PUSH
109629: LD_VAR 0 10
109633: PUSH
109634: EMPTY
109635: LIST
109636: LIST
109637: PUSH
109638: LD_VAR 0 7
109642: IN
109643: NOT
109644: AND
109645: PUSH
109646: LD_VAR 0 9
109650: PPUSH
109651: LD_VAR 0 10
109655: PPUSH
109656: CALL_OW 458
109660: NOT
109661: AND
109662: IFFALSE 109704
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
109664: LD_ADDR_VAR 0 7
109668: PUSH
109669: LD_VAR 0 7
109673: PPUSH
109674: LD_VAR 0 7
109678: PUSH
109679: LD_INT 1
109681: PLUS
109682: PPUSH
109683: LD_VAR 0 9
109687: PUSH
109688: LD_VAR 0 10
109692: PUSH
109693: EMPTY
109694: LIST
109695: LIST
109696: PPUSH
109697: CALL_OW 1
109701: ST_TO_ADDR
109702: GO 109718
// i := i - 1 ;
109704: LD_ADDR_VAR 0 5
109708: PUSH
109709: LD_VAR 0 5
109713: PUSH
109714: LD_INT 1
109716: MINUS
109717: ST_TO_ADDR
// end ;
109718: GO 109524
109720: POP
109721: POP
// for i in tmp do
109722: LD_ADDR_VAR 0 5
109726: PUSH
109727: LD_VAR 0 7
109731: PUSH
109732: FOR_IN
109733: IFFALSE 109771
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
109735: LD_VAR 0 1
109739: PPUSH
109740: LD_VAR 0 5
109744: PUSH
109745: LD_INT 1
109747: ARRAY
109748: PPUSH
109749: LD_VAR 0 5
109753: PUSH
109754: LD_INT 2
109756: ARRAY
109757: PPUSH
109758: CALL 108717 0 3
109762: NOT
109763: IFFALSE 109769
// exit ;
109765: POP
109766: POP
109767: GO 109773
109769: GO 109732
109771: POP
109772: POP
// end ;
109773: LD_VAR 0 4
109777: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
109778: LD_INT 0
109780: PPUSH
109781: PPUSH
109782: PPUSH
109783: PPUSH
109784: PPUSH
109785: PPUSH
109786: PPUSH
// if not GetClass ( unit ) = class_sniper then
109787: LD_VAR 0 1
109791: PPUSH
109792: CALL_OW 257
109796: PUSH
109797: LD_INT 5
109799: EQUAL
109800: NOT
109801: IFFALSE 109805
// exit ;
109803: GO 110193
// dist := 8 ;
109805: LD_ADDR_VAR 0 5
109809: PUSH
109810: LD_INT 8
109812: ST_TO_ADDR
// viewRange := 12 ;
109813: LD_ADDR_VAR 0 7
109817: PUSH
109818: LD_INT 12
109820: ST_TO_ADDR
// side := GetSide ( unit ) ;
109821: LD_ADDR_VAR 0 6
109825: PUSH
109826: LD_VAR 0 1
109830: PPUSH
109831: CALL_OW 255
109835: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
109836: LD_INT 61
109838: PPUSH
109839: LD_VAR 0 6
109843: PPUSH
109844: CALL_OW 321
109848: PUSH
109849: LD_INT 2
109851: EQUAL
109852: IFFALSE 109862
// viewRange := 16 ;
109854: LD_ADDR_VAR 0 7
109858: PUSH
109859: LD_INT 16
109861: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
109862: LD_VAR 0 1
109866: PPUSH
109867: LD_VAR 0 2
109871: PPUSH
109872: LD_VAR 0 3
109876: PPUSH
109877: CALL_OW 297
109881: PUSH
109882: LD_VAR 0 5
109886: GREATER
109887: IFFALSE 109966
// begin ComMoveXY ( unit , x , y ) ;
109889: LD_VAR 0 1
109893: PPUSH
109894: LD_VAR 0 2
109898: PPUSH
109899: LD_VAR 0 3
109903: PPUSH
109904: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
109908: LD_INT 35
109910: PPUSH
109911: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
109915: LD_VAR 0 1
109919: PPUSH
109920: LD_VAR 0 2
109924: PPUSH
109925: LD_VAR 0 3
109929: PPUSH
109930: CALL 84971 0 3
109934: NOT
109935: IFFALSE 109939
// exit ;
109937: GO 110193
// until GetDistUnitXY ( unit , x , y ) < dist ;
109939: LD_VAR 0 1
109943: PPUSH
109944: LD_VAR 0 2
109948: PPUSH
109949: LD_VAR 0 3
109953: PPUSH
109954: CALL_OW 297
109958: PUSH
109959: LD_VAR 0 5
109963: LESS
109964: IFFALSE 109908
// end ; ComTurnXY ( unit , x , y ) ;
109966: LD_VAR 0 1
109970: PPUSH
109971: LD_VAR 0 2
109975: PPUSH
109976: LD_VAR 0 3
109980: PPUSH
109981: CALL_OW 118
// wait ( 5 ) ;
109985: LD_INT 5
109987: PPUSH
109988: CALL_OW 67
// _d := GetDir ( unit ) ;
109992: LD_ADDR_VAR 0 10
109996: PUSH
109997: LD_VAR 0 1
110001: PPUSH
110002: CALL_OW 254
110006: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
110007: LD_ADDR_VAR 0 8
110011: PUSH
110012: LD_VAR 0 1
110016: PPUSH
110017: CALL_OW 250
110021: PPUSH
110022: LD_VAR 0 10
110026: PPUSH
110027: LD_VAR 0 5
110031: PPUSH
110032: CALL_OW 272
110036: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
110037: LD_ADDR_VAR 0 9
110041: PUSH
110042: LD_VAR 0 1
110046: PPUSH
110047: CALL_OW 251
110051: PPUSH
110052: LD_VAR 0 10
110056: PPUSH
110057: LD_VAR 0 5
110061: PPUSH
110062: CALL_OW 273
110066: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
110067: LD_VAR 0 8
110071: PPUSH
110072: LD_VAR 0 9
110076: PPUSH
110077: CALL_OW 488
110081: NOT
110082: IFFALSE 110086
// exit ;
110084: GO 110193
// ComAnimCustom ( unit , 1 ) ;
110086: LD_VAR 0 1
110090: PPUSH
110091: LD_INT 1
110093: PPUSH
110094: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
110098: LD_VAR 0 8
110102: PPUSH
110103: LD_VAR 0 9
110107: PPUSH
110108: LD_VAR 0 6
110112: PPUSH
110113: LD_VAR 0 7
110117: PPUSH
110118: CALL_OW 330
// repeat wait ( 1 ) ;
110122: LD_INT 1
110124: PPUSH
110125: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
110129: LD_VAR 0 1
110133: PPUSH
110134: CALL_OW 316
110138: PUSH
110139: LD_VAR 0 1
110143: PPUSH
110144: CALL_OW 314
110148: OR
110149: PUSH
110150: LD_VAR 0 1
110154: PPUSH
110155: CALL_OW 302
110159: NOT
110160: OR
110161: PUSH
110162: LD_VAR 0 1
110166: PPUSH
110167: CALL_OW 301
110171: OR
110172: IFFALSE 110122
// RemoveSeeing ( _x , _y , side ) ;
110174: LD_VAR 0 8
110178: PPUSH
110179: LD_VAR 0 9
110183: PPUSH
110184: LD_VAR 0 6
110188: PPUSH
110189: CALL_OW 331
// end ; end_of_file
110193: LD_VAR 0 4
110197: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
110198: LD_INT 0
110200: PPUSH
110201: PPUSH
110202: PPUSH
110203: PPUSH
110204: PPUSH
110205: PPUSH
110206: PPUSH
110207: PPUSH
110208: PPUSH
110209: PPUSH
110210: PPUSH
110211: PPUSH
110212: PPUSH
110213: PPUSH
110214: PPUSH
110215: PPUSH
110216: PPUSH
110217: PPUSH
110218: PPUSH
110219: PPUSH
110220: PPUSH
110221: PPUSH
110222: PPUSH
110223: PPUSH
110224: PPUSH
110225: PPUSH
110226: PPUSH
110227: PPUSH
110228: PPUSH
110229: PPUSH
110230: PPUSH
110231: PPUSH
110232: PPUSH
110233: PPUSH
// if not list then
110234: LD_VAR 0 1
110238: NOT
110239: IFFALSE 110243
// exit ;
110241: GO 114902
// base := list [ 1 ] ;
110243: LD_ADDR_VAR 0 3
110247: PUSH
110248: LD_VAR 0 1
110252: PUSH
110253: LD_INT 1
110255: ARRAY
110256: ST_TO_ADDR
// group := list [ 2 ] ;
110257: LD_ADDR_VAR 0 4
110261: PUSH
110262: LD_VAR 0 1
110266: PUSH
110267: LD_INT 2
110269: ARRAY
110270: ST_TO_ADDR
// path := list [ 3 ] ;
110271: LD_ADDR_VAR 0 5
110275: PUSH
110276: LD_VAR 0 1
110280: PUSH
110281: LD_INT 3
110283: ARRAY
110284: ST_TO_ADDR
// flags := list [ 4 ] ;
110285: LD_ADDR_VAR 0 6
110289: PUSH
110290: LD_VAR 0 1
110294: PUSH
110295: LD_INT 4
110297: ARRAY
110298: ST_TO_ADDR
// mined := [ ] ;
110299: LD_ADDR_VAR 0 27
110303: PUSH
110304: EMPTY
110305: ST_TO_ADDR
// bombed := [ ] ;
110306: LD_ADDR_VAR 0 28
110310: PUSH
110311: EMPTY
110312: ST_TO_ADDR
// healers := [ ] ;
110313: LD_ADDR_VAR 0 31
110317: PUSH
110318: EMPTY
110319: ST_TO_ADDR
// to_heal := [ ] ;
110320: LD_ADDR_VAR 0 30
110324: PUSH
110325: EMPTY
110326: ST_TO_ADDR
// repairs := [ ] ;
110327: LD_ADDR_VAR 0 33
110331: PUSH
110332: EMPTY
110333: ST_TO_ADDR
// to_repair := [ ] ;
110334: LD_ADDR_VAR 0 32
110338: PUSH
110339: EMPTY
110340: ST_TO_ADDR
// if not group or not path then
110341: LD_VAR 0 4
110345: NOT
110346: PUSH
110347: LD_VAR 0 5
110351: NOT
110352: OR
110353: IFFALSE 110357
// exit ;
110355: GO 114902
// side := GetSide ( group [ 1 ] ) ;
110357: LD_ADDR_VAR 0 35
110361: PUSH
110362: LD_VAR 0 4
110366: PUSH
110367: LD_INT 1
110369: ARRAY
110370: PPUSH
110371: CALL_OW 255
110375: ST_TO_ADDR
// if flags then
110376: LD_VAR 0 6
110380: IFFALSE 110524
// begin f_ignore_area := flags [ 1 ] ;
110382: LD_ADDR_VAR 0 17
110386: PUSH
110387: LD_VAR 0 6
110391: PUSH
110392: LD_INT 1
110394: ARRAY
110395: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
110396: LD_ADDR_VAR 0 18
110400: PUSH
110401: LD_VAR 0 6
110405: PUSH
110406: LD_INT 2
110408: ARRAY
110409: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
110410: LD_ADDR_VAR 0 19
110414: PUSH
110415: LD_VAR 0 6
110419: PUSH
110420: LD_INT 3
110422: ARRAY
110423: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
110424: LD_ADDR_VAR 0 20
110428: PUSH
110429: LD_VAR 0 6
110433: PUSH
110434: LD_INT 4
110436: ARRAY
110437: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
110438: LD_ADDR_VAR 0 21
110442: PUSH
110443: LD_VAR 0 6
110447: PUSH
110448: LD_INT 5
110450: ARRAY
110451: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
110452: LD_ADDR_VAR 0 22
110456: PUSH
110457: LD_VAR 0 6
110461: PUSH
110462: LD_INT 6
110464: ARRAY
110465: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
110466: LD_ADDR_VAR 0 23
110470: PUSH
110471: LD_VAR 0 6
110475: PUSH
110476: LD_INT 7
110478: ARRAY
110479: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
110480: LD_ADDR_VAR 0 24
110484: PUSH
110485: LD_VAR 0 6
110489: PUSH
110490: LD_INT 8
110492: ARRAY
110493: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
110494: LD_ADDR_VAR 0 25
110498: PUSH
110499: LD_VAR 0 6
110503: PUSH
110504: LD_INT 9
110506: ARRAY
110507: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
110508: LD_ADDR_VAR 0 26
110512: PUSH
110513: LD_VAR 0 6
110517: PUSH
110518: LD_INT 10
110520: ARRAY
110521: ST_TO_ADDR
// end else
110522: GO 110604
// begin f_ignore_area := false ;
110524: LD_ADDR_VAR 0 17
110528: PUSH
110529: LD_INT 0
110531: ST_TO_ADDR
// f_capture := false ;
110532: LD_ADDR_VAR 0 18
110536: PUSH
110537: LD_INT 0
110539: ST_TO_ADDR
// f_ignore_civ := false ;
110540: LD_ADDR_VAR 0 19
110544: PUSH
110545: LD_INT 0
110547: ST_TO_ADDR
// f_murder := false ;
110548: LD_ADDR_VAR 0 20
110552: PUSH
110553: LD_INT 0
110555: ST_TO_ADDR
// f_mines := false ;
110556: LD_ADDR_VAR 0 21
110560: PUSH
110561: LD_INT 0
110563: ST_TO_ADDR
// f_repair := false ;
110564: LD_ADDR_VAR 0 22
110568: PUSH
110569: LD_INT 0
110571: ST_TO_ADDR
// f_heal := false ;
110572: LD_ADDR_VAR 0 23
110576: PUSH
110577: LD_INT 0
110579: ST_TO_ADDR
// f_spacetime := false ;
110580: LD_ADDR_VAR 0 24
110584: PUSH
110585: LD_INT 0
110587: ST_TO_ADDR
// f_attack_depot := false ;
110588: LD_ADDR_VAR 0 25
110592: PUSH
110593: LD_INT 0
110595: ST_TO_ADDR
// f_crawl := false ;
110596: LD_ADDR_VAR 0 26
110600: PUSH
110601: LD_INT 0
110603: ST_TO_ADDR
// end ; if f_heal then
110604: LD_VAR 0 23
110608: IFFALSE 110635
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
110610: LD_ADDR_VAR 0 31
110614: PUSH
110615: LD_VAR 0 4
110619: PPUSH
110620: LD_INT 25
110622: PUSH
110623: LD_INT 4
110625: PUSH
110626: EMPTY
110627: LIST
110628: LIST
110629: PPUSH
110630: CALL_OW 72
110634: ST_TO_ADDR
// if f_repair then
110635: LD_VAR 0 22
110639: IFFALSE 110666
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
110641: LD_ADDR_VAR 0 33
110645: PUSH
110646: LD_VAR 0 4
110650: PPUSH
110651: LD_INT 25
110653: PUSH
110654: LD_INT 3
110656: PUSH
110657: EMPTY
110658: LIST
110659: LIST
110660: PPUSH
110661: CALL_OW 72
110665: ST_TO_ADDR
// units_path := [ ] ;
110666: LD_ADDR_VAR 0 16
110670: PUSH
110671: EMPTY
110672: ST_TO_ADDR
// for i = 1 to group do
110673: LD_ADDR_VAR 0 7
110677: PUSH
110678: DOUBLE
110679: LD_INT 1
110681: DEC
110682: ST_TO_ADDR
110683: LD_VAR 0 4
110687: PUSH
110688: FOR_TO
110689: IFFALSE 110718
// units_path := Replace ( units_path , i , path ) ;
110691: LD_ADDR_VAR 0 16
110695: PUSH
110696: LD_VAR 0 16
110700: PPUSH
110701: LD_VAR 0 7
110705: PPUSH
110706: LD_VAR 0 5
110710: PPUSH
110711: CALL_OW 1
110715: ST_TO_ADDR
110716: GO 110688
110718: POP
110719: POP
// repeat for i = group downto 1 do
110720: LD_ADDR_VAR 0 7
110724: PUSH
110725: DOUBLE
110726: LD_VAR 0 4
110730: INC
110731: ST_TO_ADDR
110732: LD_INT 1
110734: PUSH
110735: FOR_DOWNTO
110736: IFFALSE 114858
// begin wait ( 5 ) ;
110738: LD_INT 5
110740: PPUSH
110741: CALL_OW 67
// tmp := [ ] ;
110745: LD_ADDR_VAR 0 14
110749: PUSH
110750: EMPTY
110751: ST_TO_ADDR
// attacking := false ;
110752: LD_ADDR_VAR 0 29
110756: PUSH
110757: LD_INT 0
110759: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
110760: LD_VAR 0 4
110764: PUSH
110765: LD_VAR 0 7
110769: ARRAY
110770: PPUSH
110771: CALL_OW 301
110775: PUSH
110776: LD_VAR 0 4
110780: PUSH
110781: LD_VAR 0 7
110785: ARRAY
110786: NOT
110787: OR
110788: IFFALSE 110897
// begin if GetType ( group [ i ] ) = unit_human then
110790: LD_VAR 0 4
110794: PUSH
110795: LD_VAR 0 7
110799: ARRAY
110800: PPUSH
110801: CALL_OW 247
110805: PUSH
110806: LD_INT 1
110808: EQUAL
110809: IFFALSE 110855
// begin to_heal := to_heal diff group [ i ] ;
110811: LD_ADDR_VAR 0 30
110815: PUSH
110816: LD_VAR 0 30
110820: PUSH
110821: LD_VAR 0 4
110825: PUSH
110826: LD_VAR 0 7
110830: ARRAY
110831: DIFF
110832: ST_TO_ADDR
// healers := healers diff group [ i ] ;
110833: LD_ADDR_VAR 0 31
110837: PUSH
110838: LD_VAR 0 31
110842: PUSH
110843: LD_VAR 0 4
110847: PUSH
110848: LD_VAR 0 7
110852: ARRAY
110853: DIFF
110854: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
110855: LD_ADDR_VAR 0 4
110859: PUSH
110860: LD_VAR 0 4
110864: PPUSH
110865: LD_VAR 0 7
110869: PPUSH
110870: CALL_OW 3
110874: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
110875: LD_ADDR_VAR 0 16
110879: PUSH
110880: LD_VAR 0 16
110884: PPUSH
110885: LD_VAR 0 7
110889: PPUSH
110890: CALL_OW 3
110894: ST_TO_ADDR
// continue ;
110895: GO 110735
// end ; if f_repair then
110897: LD_VAR 0 22
110901: IFFALSE 111390
// begin if GetType ( group [ i ] ) = unit_vehicle then
110903: LD_VAR 0 4
110907: PUSH
110908: LD_VAR 0 7
110912: ARRAY
110913: PPUSH
110914: CALL_OW 247
110918: PUSH
110919: LD_INT 2
110921: EQUAL
110922: IFFALSE 111112
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
110924: LD_VAR 0 4
110928: PUSH
110929: LD_VAR 0 7
110933: ARRAY
110934: PPUSH
110935: CALL_OW 256
110939: PUSH
110940: LD_INT 700
110942: LESS
110943: PUSH
110944: LD_VAR 0 4
110948: PUSH
110949: LD_VAR 0 7
110953: ARRAY
110954: PUSH
110955: LD_VAR 0 32
110959: IN
110960: NOT
110961: AND
110962: IFFALSE 110986
// to_repair := to_repair union group [ i ] ;
110964: LD_ADDR_VAR 0 32
110968: PUSH
110969: LD_VAR 0 32
110973: PUSH
110974: LD_VAR 0 4
110978: PUSH
110979: LD_VAR 0 7
110983: ARRAY
110984: UNION
110985: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
110986: LD_VAR 0 4
110990: PUSH
110991: LD_VAR 0 7
110995: ARRAY
110996: PPUSH
110997: CALL_OW 256
111001: PUSH
111002: LD_INT 1000
111004: EQUAL
111005: PUSH
111006: LD_VAR 0 4
111010: PUSH
111011: LD_VAR 0 7
111015: ARRAY
111016: PUSH
111017: LD_VAR 0 32
111021: IN
111022: AND
111023: IFFALSE 111047
// to_repair := to_repair diff group [ i ] ;
111025: LD_ADDR_VAR 0 32
111029: PUSH
111030: LD_VAR 0 32
111034: PUSH
111035: LD_VAR 0 4
111039: PUSH
111040: LD_VAR 0 7
111044: ARRAY
111045: DIFF
111046: ST_TO_ADDR
// if group [ i ] in to_repair then
111047: LD_VAR 0 4
111051: PUSH
111052: LD_VAR 0 7
111056: ARRAY
111057: PUSH
111058: LD_VAR 0 32
111062: IN
111063: IFFALSE 111110
// begin if not IsInArea ( group [ i ] , f_repair ) then
111065: LD_VAR 0 4
111069: PUSH
111070: LD_VAR 0 7
111074: ARRAY
111075: PPUSH
111076: LD_VAR 0 22
111080: PPUSH
111081: CALL_OW 308
111085: NOT
111086: IFFALSE 111108
// ComMoveToArea ( group [ i ] , f_repair ) ;
111088: LD_VAR 0 4
111092: PUSH
111093: LD_VAR 0 7
111097: ARRAY
111098: PPUSH
111099: LD_VAR 0 22
111103: PPUSH
111104: CALL_OW 113
// continue ;
111108: GO 110735
// end ; end else
111110: GO 111390
// if group [ i ] in repairs then
111112: LD_VAR 0 4
111116: PUSH
111117: LD_VAR 0 7
111121: ARRAY
111122: PUSH
111123: LD_VAR 0 33
111127: IN
111128: IFFALSE 111390
// begin if IsInUnit ( group [ i ] ) then
111130: LD_VAR 0 4
111134: PUSH
111135: LD_VAR 0 7
111139: ARRAY
111140: PPUSH
111141: CALL_OW 310
111145: IFFALSE 111213
// begin z := IsInUnit ( group [ i ] ) ;
111147: LD_ADDR_VAR 0 13
111151: PUSH
111152: LD_VAR 0 4
111156: PUSH
111157: LD_VAR 0 7
111161: ARRAY
111162: PPUSH
111163: CALL_OW 310
111167: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
111168: LD_VAR 0 13
111172: PUSH
111173: LD_VAR 0 32
111177: IN
111178: PUSH
111179: LD_VAR 0 13
111183: PPUSH
111184: LD_VAR 0 22
111188: PPUSH
111189: CALL_OW 308
111193: AND
111194: IFFALSE 111211
// ComExitVehicle ( group [ i ] ) ;
111196: LD_VAR 0 4
111200: PUSH
111201: LD_VAR 0 7
111205: ARRAY
111206: PPUSH
111207: CALL_OW 121
// end else
111211: GO 111390
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
111213: LD_ADDR_VAR 0 13
111217: PUSH
111218: LD_VAR 0 4
111222: PPUSH
111223: LD_INT 95
111225: PUSH
111226: LD_VAR 0 22
111230: PUSH
111231: EMPTY
111232: LIST
111233: LIST
111234: PUSH
111235: LD_INT 58
111237: PUSH
111238: EMPTY
111239: LIST
111240: PUSH
111241: EMPTY
111242: LIST
111243: LIST
111244: PPUSH
111245: CALL_OW 72
111249: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
111250: LD_VAR 0 4
111254: PUSH
111255: LD_VAR 0 7
111259: ARRAY
111260: PPUSH
111261: CALL_OW 314
111265: NOT
111266: IFFALSE 111388
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
111268: LD_ADDR_VAR 0 10
111272: PUSH
111273: LD_VAR 0 13
111277: PPUSH
111278: LD_VAR 0 4
111282: PUSH
111283: LD_VAR 0 7
111287: ARRAY
111288: PPUSH
111289: CALL_OW 74
111293: ST_TO_ADDR
// if not x then
111294: LD_VAR 0 10
111298: NOT
111299: IFFALSE 111303
// continue ;
111301: GO 110735
// if GetLives ( x ) < 1000 then
111303: LD_VAR 0 10
111307: PPUSH
111308: CALL_OW 256
111312: PUSH
111313: LD_INT 1000
111315: LESS
111316: IFFALSE 111340
// ComRepairVehicle ( group [ i ] , x ) else
111318: LD_VAR 0 4
111322: PUSH
111323: LD_VAR 0 7
111327: ARRAY
111328: PPUSH
111329: LD_VAR 0 10
111333: PPUSH
111334: CALL_OW 129
111338: GO 111388
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
111340: LD_VAR 0 23
111344: PUSH
111345: LD_VAR 0 4
111349: PUSH
111350: LD_VAR 0 7
111354: ARRAY
111355: PPUSH
111356: CALL_OW 256
111360: PUSH
111361: LD_INT 1000
111363: LESS
111364: AND
111365: NOT
111366: IFFALSE 111388
// ComEnterUnit ( group [ i ] , x ) ;
111368: LD_VAR 0 4
111372: PUSH
111373: LD_VAR 0 7
111377: ARRAY
111378: PPUSH
111379: LD_VAR 0 10
111383: PPUSH
111384: CALL_OW 120
// end ; continue ;
111388: GO 110735
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
111390: LD_VAR 0 23
111394: PUSH
111395: LD_VAR 0 4
111399: PUSH
111400: LD_VAR 0 7
111404: ARRAY
111405: PPUSH
111406: CALL_OW 247
111410: PUSH
111411: LD_INT 1
111413: EQUAL
111414: AND
111415: IFFALSE 111893
// begin if group [ i ] in healers then
111417: LD_VAR 0 4
111421: PUSH
111422: LD_VAR 0 7
111426: ARRAY
111427: PUSH
111428: LD_VAR 0 31
111432: IN
111433: IFFALSE 111706
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
111435: LD_VAR 0 4
111439: PUSH
111440: LD_VAR 0 7
111444: ARRAY
111445: PPUSH
111446: LD_VAR 0 23
111450: PPUSH
111451: CALL_OW 308
111455: NOT
111456: PUSH
111457: LD_VAR 0 4
111461: PUSH
111462: LD_VAR 0 7
111466: ARRAY
111467: PPUSH
111468: CALL_OW 314
111472: NOT
111473: AND
111474: IFFALSE 111498
// ComMoveToArea ( group [ i ] , f_heal ) else
111476: LD_VAR 0 4
111480: PUSH
111481: LD_VAR 0 7
111485: ARRAY
111486: PPUSH
111487: LD_VAR 0 23
111491: PPUSH
111492: CALL_OW 113
111496: GO 111704
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
111498: LD_VAR 0 4
111502: PUSH
111503: LD_VAR 0 7
111507: ARRAY
111508: PPUSH
111509: CALL 83554 0 1
111513: PPUSH
111514: CALL_OW 256
111518: PUSH
111519: LD_INT 1000
111521: EQUAL
111522: IFFALSE 111541
// ComStop ( group [ i ] ) else
111524: LD_VAR 0 4
111528: PUSH
111529: LD_VAR 0 7
111533: ARRAY
111534: PPUSH
111535: CALL_OW 141
111539: GO 111704
// if not HasTask ( group [ i ] ) and to_heal then
111541: LD_VAR 0 4
111545: PUSH
111546: LD_VAR 0 7
111550: ARRAY
111551: PPUSH
111552: CALL_OW 314
111556: NOT
111557: PUSH
111558: LD_VAR 0 30
111562: AND
111563: IFFALSE 111704
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
111565: LD_ADDR_VAR 0 13
111569: PUSH
111570: LD_VAR 0 30
111574: PPUSH
111575: LD_INT 3
111577: PUSH
111578: LD_INT 54
111580: PUSH
111581: EMPTY
111582: LIST
111583: PUSH
111584: EMPTY
111585: LIST
111586: LIST
111587: PPUSH
111588: CALL_OW 72
111592: PPUSH
111593: LD_VAR 0 4
111597: PUSH
111598: LD_VAR 0 7
111602: ARRAY
111603: PPUSH
111604: CALL_OW 74
111608: ST_TO_ADDR
// if z then
111609: LD_VAR 0 13
111613: IFFALSE 111704
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
111615: LD_INT 91
111617: PUSH
111618: LD_VAR 0 13
111622: PUSH
111623: LD_INT 10
111625: PUSH
111626: EMPTY
111627: LIST
111628: LIST
111629: LIST
111630: PUSH
111631: LD_INT 81
111633: PUSH
111634: LD_VAR 0 13
111638: PPUSH
111639: CALL_OW 255
111643: PUSH
111644: EMPTY
111645: LIST
111646: LIST
111647: PUSH
111648: EMPTY
111649: LIST
111650: LIST
111651: PPUSH
111652: CALL_OW 69
111656: PUSH
111657: LD_INT 0
111659: EQUAL
111660: IFFALSE 111684
// ComHeal ( group [ i ] , z ) else
111662: LD_VAR 0 4
111666: PUSH
111667: LD_VAR 0 7
111671: ARRAY
111672: PPUSH
111673: LD_VAR 0 13
111677: PPUSH
111678: CALL_OW 128
111682: GO 111704
// ComMoveToArea ( group [ i ] , f_heal ) ;
111684: LD_VAR 0 4
111688: PUSH
111689: LD_VAR 0 7
111693: ARRAY
111694: PPUSH
111695: LD_VAR 0 23
111699: PPUSH
111700: CALL_OW 113
// end ; continue ;
111704: GO 110735
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
111706: LD_VAR 0 4
111710: PUSH
111711: LD_VAR 0 7
111715: ARRAY
111716: PPUSH
111717: CALL_OW 256
111721: PUSH
111722: LD_INT 700
111724: LESS
111725: PUSH
111726: LD_VAR 0 4
111730: PUSH
111731: LD_VAR 0 7
111735: ARRAY
111736: PUSH
111737: LD_VAR 0 30
111741: IN
111742: NOT
111743: AND
111744: IFFALSE 111768
// to_heal := to_heal union group [ i ] ;
111746: LD_ADDR_VAR 0 30
111750: PUSH
111751: LD_VAR 0 30
111755: PUSH
111756: LD_VAR 0 4
111760: PUSH
111761: LD_VAR 0 7
111765: ARRAY
111766: UNION
111767: ST_TO_ADDR
// if group [ i ] in to_heal then
111768: LD_VAR 0 4
111772: PUSH
111773: LD_VAR 0 7
111777: ARRAY
111778: PUSH
111779: LD_VAR 0 30
111783: IN
111784: IFFALSE 111893
// begin if GetLives ( group [ i ] ) = 1000 then
111786: LD_VAR 0 4
111790: PUSH
111791: LD_VAR 0 7
111795: ARRAY
111796: PPUSH
111797: CALL_OW 256
111801: PUSH
111802: LD_INT 1000
111804: EQUAL
111805: IFFALSE 111831
// to_heal := to_heal diff group [ i ] else
111807: LD_ADDR_VAR 0 30
111811: PUSH
111812: LD_VAR 0 30
111816: PUSH
111817: LD_VAR 0 4
111821: PUSH
111822: LD_VAR 0 7
111826: ARRAY
111827: DIFF
111828: ST_TO_ADDR
111829: GO 111893
// begin if not IsInArea ( group [ i ] , to_heal ) then
111831: LD_VAR 0 4
111835: PUSH
111836: LD_VAR 0 7
111840: ARRAY
111841: PPUSH
111842: LD_VAR 0 30
111846: PPUSH
111847: CALL_OW 308
111851: NOT
111852: IFFALSE 111876
// ComMoveToArea ( group [ i ] , f_heal ) else
111854: LD_VAR 0 4
111858: PUSH
111859: LD_VAR 0 7
111863: ARRAY
111864: PPUSH
111865: LD_VAR 0 23
111869: PPUSH
111870: CALL_OW 113
111874: GO 111891
// ComHold ( group [ i ] ) ;
111876: LD_VAR 0 4
111880: PUSH
111881: LD_VAR 0 7
111885: ARRAY
111886: PPUSH
111887: CALL_OW 140
// continue ;
111891: GO 110735
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
111893: LD_VAR 0 4
111897: PUSH
111898: LD_VAR 0 7
111902: ARRAY
111903: PPUSH
111904: LD_INT 10
111906: PPUSH
111907: CALL 81325 0 2
111911: NOT
111912: PUSH
111913: LD_VAR 0 16
111917: PUSH
111918: LD_VAR 0 7
111922: ARRAY
111923: PUSH
111924: EMPTY
111925: EQUAL
111926: NOT
111927: AND
111928: IFFALSE 112194
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
111930: LD_VAR 0 4
111934: PUSH
111935: LD_VAR 0 7
111939: ARRAY
111940: PPUSH
111941: CALL_OW 262
111945: PUSH
111946: LD_INT 1
111948: PUSH
111949: LD_INT 2
111951: PUSH
111952: EMPTY
111953: LIST
111954: LIST
111955: IN
111956: IFFALSE 111997
// if GetFuel ( group [ i ] ) < 10 then
111958: LD_VAR 0 4
111962: PUSH
111963: LD_VAR 0 7
111967: ARRAY
111968: PPUSH
111969: CALL_OW 261
111973: PUSH
111974: LD_INT 10
111976: LESS
111977: IFFALSE 111997
// SetFuel ( group [ i ] , 12 ) ;
111979: LD_VAR 0 4
111983: PUSH
111984: LD_VAR 0 7
111988: ARRAY
111989: PPUSH
111990: LD_INT 12
111992: PPUSH
111993: CALL_OW 240
// if units_path [ i ] then
111997: LD_VAR 0 16
112001: PUSH
112002: LD_VAR 0 7
112006: ARRAY
112007: IFFALSE 112192
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
112009: LD_VAR 0 4
112013: PUSH
112014: LD_VAR 0 7
112018: ARRAY
112019: PPUSH
112020: LD_VAR 0 16
112024: PUSH
112025: LD_VAR 0 7
112029: ARRAY
112030: PUSH
112031: LD_INT 1
112033: ARRAY
112034: PUSH
112035: LD_INT 1
112037: ARRAY
112038: PPUSH
112039: LD_VAR 0 16
112043: PUSH
112044: LD_VAR 0 7
112048: ARRAY
112049: PUSH
112050: LD_INT 1
112052: ARRAY
112053: PUSH
112054: LD_INT 2
112056: ARRAY
112057: PPUSH
112058: CALL_OW 297
112062: PUSH
112063: LD_INT 6
112065: GREATER
112066: IFFALSE 112141
// begin if not HasTask ( group [ i ] ) then
112068: LD_VAR 0 4
112072: PUSH
112073: LD_VAR 0 7
112077: ARRAY
112078: PPUSH
112079: CALL_OW 314
112083: NOT
112084: IFFALSE 112139
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
112086: LD_VAR 0 4
112090: PUSH
112091: LD_VAR 0 7
112095: ARRAY
112096: PPUSH
112097: LD_VAR 0 16
112101: PUSH
112102: LD_VAR 0 7
112106: ARRAY
112107: PUSH
112108: LD_INT 1
112110: ARRAY
112111: PUSH
112112: LD_INT 1
112114: ARRAY
112115: PPUSH
112116: LD_VAR 0 16
112120: PUSH
112121: LD_VAR 0 7
112125: ARRAY
112126: PUSH
112127: LD_INT 1
112129: ARRAY
112130: PUSH
112131: LD_INT 2
112133: ARRAY
112134: PPUSH
112135: CALL_OW 114
// end else
112139: GO 112192
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
112141: LD_ADDR_VAR 0 15
112145: PUSH
112146: LD_VAR 0 16
112150: PUSH
112151: LD_VAR 0 7
112155: ARRAY
112156: PPUSH
112157: LD_INT 1
112159: PPUSH
112160: CALL_OW 3
112164: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
112165: LD_ADDR_VAR 0 16
112169: PUSH
112170: LD_VAR 0 16
112174: PPUSH
112175: LD_VAR 0 7
112179: PPUSH
112180: LD_VAR 0 15
112184: PPUSH
112185: CALL_OW 1
112189: ST_TO_ADDR
// continue ;
112190: GO 110735
// end ; end ; end else
112192: GO 114856
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
112194: LD_ADDR_VAR 0 14
112198: PUSH
112199: LD_INT 81
112201: PUSH
112202: LD_VAR 0 4
112206: PUSH
112207: LD_VAR 0 7
112211: ARRAY
112212: PPUSH
112213: CALL_OW 255
112217: PUSH
112218: EMPTY
112219: LIST
112220: LIST
112221: PPUSH
112222: CALL_OW 69
112226: ST_TO_ADDR
// if not tmp then
112227: LD_VAR 0 14
112231: NOT
112232: IFFALSE 112236
// continue ;
112234: GO 110735
// if f_ignore_area then
112236: LD_VAR 0 17
112240: IFFALSE 112328
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
112242: LD_ADDR_VAR 0 15
112246: PUSH
112247: LD_VAR 0 14
112251: PPUSH
112252: LD_INT 3
112254: PUSH
112255: LD_INT 92
112257: PUSH
112258: LD_VAR 0 17
112262: PUSH
112263: LD_INT 1
112265: ARRAY
112266: PUSH
112267: LD_VAR 0 17
112271: PUSH
112272: LD_INT 2
112274: ARRAY
112275: PUSH
112276: LD_VAR 0 17
112280: PUSH
112281: LD_INT 3
112283: ARRAY
112284: PUSH
112285: EMPTY
112286: LIST
112287: LIST
112288: LIST
112289: LIST
112290: PUSH
112291: EMPTY
112292: LIST
112293: LIST
112294: PPUSH
112295: CALL_OW 72
112299: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
112300: LD_VAR 0 14
112304: PUSH
112305: LD_VAR 0 15
112309: DIFF
112310: IFFALSE 112328
// tmp := tmp diff tmp2 ;
112312: LD_ADDR_VAR 0 14
112316: PUSH
112317: LD_VAR 0 14
112321: PUSH
112322: LD_VAR 0 15
112326: DIFF
112327: ST_TO_ADDR
// end ; if not f_murder then
112328: LD_VAR 0 20
112332: NOT
112333: IFFALSE 112391
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
112335: LD_ADDR_VAR 0 15
112339: PUSH
112340: LD_VAR 0 14
112344: PPUSH
112345: LD_INT 3
112347: PUSH
112348: LD_INT 50
112350: PUSH
112351: EMPTY
112352: LIST
112353: PUSH
112354: EMPTY
112355: LIST
112356: LIST
112357: PPUSH
112358: CALL_OW 72
112362: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
112363: LD_VAR 0 14
112367: PUSH
112368: LD_VAR 0 15
112372: DIFF
112373: IFFALSE 112391
// tmp := tmp diff tmp2 ;
112375: LD_ADDR_VAR 0 14
112379: PUSH
112380: LD_VAR 0 14
112384: PUSH
112385: LD_VAR 0 15
112389: DIFF
112390: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
112391: LD_ADDR_VAR 0 14
112395: PUSH
112396: LD_VAR 0 4
112400: PUSH
112401: LD_VAR 0 7
112405: ARRAY
112406: PPUSH
112407: LD_VAR 0 14
112411: PPUSH
112412: LD_INT 1
112414: PPUSH
112415: LD_INT 1
112417: PPUSH
112418: CALL 54266 0 4
112422: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
112423: LD_VAR 0 4
112427: PUSH
112428: LD_VAR 0 7
112432: ARRAY
112433: PPUSH
112434: CALL_OW 257
112438: PUSH
112439: LD_INT 1
112441: EQUAL
112442: IFFALSE 112890
// begin if WantPlant ( group [ i ] ) then
112444: LD_VAR 0 4
112448: PUSH
112449: LD_VAR 0 7
112453: ARRAY
112454: PPUSH
112455: CALL 53767 0 1
112459: IFFALSE 112463
// continue ;
112461: GO 110735
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
112463: LD_VAR 0 18
112467: PUSH
112468: LD_VAR 0 4
112472: PUSH
112473: LD_VAR 0 7
112477: ARRAY
112478: PPUSH
112479: CALL_OW 310
112483: NOT
112484: AND
112485: PUSH
112486: LD_VAR 0 14
112490: PUSH
112491: LD_INT 1
112493: ARRAY
112494: PUSH
112495: LD_VAR 0 14
112499: PPUSH
112500: LD_INT 21
112502: PUSH
112503: LD_INT 2
112505: PUSH
112506: EMPTY
112507: LIST
112508: LIST
112509: PUSH
112510: LD_INT 58
112512: PUSH
112513: EMPTY
112514: LIST
112515: PUSH
112516: EMPTY
112517: LIST
112518: LIST
112519: PPUSH
112520: CALL_OW 72
112524: IN
112525: AND
112526: IFFALSE 112562
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
112528: LD_VAR 0 4
112532: PUSH
112533: LD_VAR 0 7
112537: ARRAY
112538: PPUSH
112539: LD_VAR 0 14
112543: PUSH
112544: LD_INT 1
112546: ARRAY
112547: PPUSH
112548: CALL_OW 120
// attacking := true ;
112552: LD_ADDR_VAR 0 29
112556: PUSH
112557: LD_INT 1
112559: ST_TO_ADDR
// continue ;
112560: GO 110735
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
112562: LD_VAR 0 26
112566: PUSH
112567: LD_VAR 0 4
112571: PUSH
112572: LD_VAR 0 7
112576: ARRAY
112577: PPUSH
112578: CALL_OW 257
112582: PUSH
112583: LD_INT 1
112585: EQUAL
112586: AND
112587: PUSH
112588: LD_VAR 0 4
112592: PUSH
112593: LD_VAR 0 7
112597: ARRAY
112598: PPUSH
112599: CALL_OW 256
112603: PUSH
112604: LD_INT 800
112606: LESS
112607: AND
112608: PUSH
112609: LD_VAR 0 4
112613: PUSH
112614: LD_VAR 0 7
112618: ARRAY
112619: PPUSH
112620: CALL_OW 318
112624: NOT
112625: AND
112626: IFFALSE 112643
// ComCrawl ( group [ i ] ) ;
112628: LD_VAR 0 4
112632: PUSH
112633: LD_VAR 0 7
112637: ARRAY
112638: PPUSH
112639: CALL_OW 137
// if f_mines then
112643: LD_VAR 0 21
112647: IFFALSE 112890
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
112649: LD_VAR 0 14
112653: PUSH
112654: LD_INT 1
112656: ARRAY
112657: PPUSH
112658: CALL_OW 247
112662: PUSH
112663: LD_INT 3
112665: EQUAL
112666: PUSH
112667: LD_VAR 0 14
112671: PUSH
112672: LD_INT 1
112674: ARRAY
112675: PUSH
112676: LD_VAR 0 27
112680: IN
112681: NOT
112682: AND
112683: IFFALSE 112890
// begin x := GetX ( tmp [ 1 ] ) ;
112685: LD_ADDR_VAR 0 10
112689: PUSH
112690: LD_VAR 0 14
112694: PUSH
112695: LD_INT 1
112697: ARRAY
112698: PPUSH
112699: CALL_OW 250
112703: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
112704: LD_ADDR_VAR 0 11
112708: PUSH
112709: LD_VAR 0 14
112713: PUSH
112714: LD_INT 1
112716: ARRAY
112717: PPUSH
112718: CALL_OW 251
112722: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
112723: LD_ADDR_VAR 0 12
112727: PUSH
112728: LD_VAR 0 4
112732: PUSH
112733: LD_VAR 0 7
112737: ARRAY
112738: PPUSH
112739: CALL 81410 0 1
112743: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
112744: LD_VAR 0 4
112748: PUSH
112749: LD_VAR 0 7
112753: ARRAY
112754: PPUSH
112755: LD_VAR 0 10
112759: PPUSH
112760: LD_VAR 0 11
112764: PPUSH
112765: LD_VAR 0 14
112769: PUSH
112770: LD_INT 1
112772: ARRAY
112773: PPUSH
112774: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
112778: LD_VAR 0 4
112782: PUSH
112783: LD_VAR 0 7
112787: ARRAY
112788: PPUSH
112789: LD_VAR 0 10
112793: PPUSH
112794: LD_VAR 0 12
112798: PPUSH
112799: LD_INT 7
112801: PPUSH
112802: CALL_OW 272
112806: PPUSH
112807: LD_VAR 0 11
112811: PPUSH
112812: LD_VAR 0 12
112816: PPUSH
112817: LD_INT 7
112819: PPUSH
112820: CALL_OW 273
112824: PPUSH
112825: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
112829: LD_VAR 0 4
112833: PUSH
112834: LD_VAR 0 7
112838: ARRAY
112839: PPUSH
112840: LD_INT 71
112842: PPUSH
112843: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
112847: LD_ADDR_VAR 0 27
112851: PUSH
112852: LD_VAR 0 27
112856: PPUSH
112857: LD_VAR 0 27
112861: PUSH
112862: LD_INT 1
112864: PLUS
112865: PPUSH
112866: LD_VAR 0 14
112870: PUSH
112871: LD_INT 1
112873: ARRAY
112874: PPUSH
112875: CALL_OW 1
112879: ST_TO_ADDR
// attacking := true ;
112880: LD_ADDR_VAR 0 29
112884: PUSH
112885: LD_INT 1
112887: ST_TO_ADDR
// continue ;
112888: GO 110735
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
112890: LD_VAR 0 4
112894: PUSH
112895: LD_VAR 0 7
112899: ARRAY
112900: PPUSH
112901: CALL_OW 257
112905: PUSH
112906: LD_INT 17
112908: EQUAL
112909: PUSH
112910: LD_VAR 0 4
112914: PUSH
112915: LD_VAR 0 7
112919: ARRAY
112920: PPUSH
112921: CALL_OW 110
112925: PUSH
112926: LD_INT 71
112928: EQUAL
112929: NOT
112930: AND
112931: IFFALSE 113077
// begin attacking := false ;
112933: LD_ADDR_VAR 0 29
112937: PUSH
112938: LD_INT 0
112940: ST_TO_ADDR
// k := 5 ;
112941: LD_ADDR_VAR 0 9
112945: PUSH
112946: LD_INT 5
112948: ST_TO_ADDR
// if tmp < k then
112949: LD_VAR 0 14
112953: PUSH
112954: LD_VAR 0 9
112958: LESS
112959: IFFALSE 112971
// k := tmp ;
112961: LD_ADDR_VAR 0 9
112965: PUSH
112966: LD_VAR 0 14
112970: ST_TO_ADDR
// for j = 1 to k do
112971: LD_ADDR_VAR 0 8
112975: PUSH
112976: DOUBLE
112977: LD_INT 1
112979: DEC
112980: ST_TO_ADDR
112981: LD_VAR 0 9
112985: PUSH
112986: FOR_TO
112987: IFFALSE 113075
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
112989: LD_VAR 0 14
112993: PUSH
112994: LD_VAR 0 8
112998: ARRAY
112999: PUSH
113000: LD_VAR 0 14
113004: PPUSH
113005: LD_INT 58
113007: PUSH
113008: EMPTY
113009: LIST
113010: PPUSH
113011: CALL_OW 72
113015: IN
113016: NOT
113017: IFFALSE 113073
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
113019: LD_VAR 0 4
113023: PUSH
113024: LD_VAR 0 7
113028: ARRAY
113029: PPUSH
113030: LD_VAR 0 14
113034: PUSH
113035: LD_VAR 0 8
113039: ARRAY
113040: PPUSH
113041: CALL_OW 115
// attacking := true ;
113045: LD_ADDR_VAR 0 29
113049: PUSH
113050: LD_INT 1
113052: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
113053: LD_VAR 0 4
113057: PUSH
113058: LD_VAR 0 7
113062: ARRAY
113063: PPUSH
113064: LD_INT 71
113066: PPUSH
113067: CALL_OW 109
// continue ;
113071: GO 112986
// end ; end ;
113073: GO 112986
113075: POP
113076: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
113077: LD_VAR 0 4
113081: PUSH
113082: LD_VAR 0 7
113086: ARRAY
113087: PPUSH
113088: CALL_OW 257
113092: PUSH
113093: LD_INT 8
113095: EQUAL
113096: PUSH
113097: LD_VAR 0 4
113101: PUSH
113102: LD_VAR 0 7
113106: ARRAY
113107: PPUSH
113108: CALL_OW 264
113112: PUSH
113113: LD_INT 28
113115: PUSH
113116: LD_INT 45
113118: PUSH
113119: LD_INT 7
113121: PUSH
113122: LD_INT 47
113124: PUSH
113125: EMPTY
113126: LIST
113127: LIST
113128: LIST
113129: LIST
113130: IN
113131: OR
113132: IFFALSE 113388
// begin attacking := false ;
113134: LD_ADDR_VAR 0 29
113138: PUSH
113139: LD_INT 0
113141: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
113142: LD_VAR 0 14
113146: PUSH
113147: LD_INT 1
113149: ARRAY
113150: PPUSH
113151: CALL_OW 266
113155: PUSH
113156: LD_INT 32
113158: PUSH
113159: LD_INT 31
113161: PUSH
113162: LD_INT 33
113164: PUSH
113165: LD_INT 4
113167: PUSH
113168: LD_INT 5
113170: PUSH
113171: EMPTY
113172: LIST
113173: LIST
113174: LIST
113175: LIST
113176: LIST
113177: IN
113178: IFFALSE 113364
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
113180: LD_ADDR_VAR 0 9
113184: PUSH
113185: LD_VAR 0 14
113189: PUSH
113190: LD_INT 1
113192: ARRAY
113193: PPUSH
113194: CALL_OW 266
113198: PPUSH
113199: LD_VAR 0 14
113203: PUSH
113204: LD_INT 1
113206: ARRAY
113207: PPUSH
113208: CALL_OW 250
113212: PPUSH
113213: LD_VAR 0 14
113217: PUSH
113218: LD_INT 1
113220: ARRAY
113221: PPUSH
113222: CALL_OW 251
113226: PPUSH
113227: LD_VAR 0 14
113231: PUSH
113232: LD_INT 1
113234: ARRAY
113235: PPUSH
113236: CALL_OW 254
113240: PPUSH
113241: LD_VAR 0 14
113245: PUSH
113246: LD_INT 1
113248: ARRAY
113249: PPUSH
113250: CALL_OW 248
113254: PPUSH
113255: LD_INT 0
113257: PPUSH
113258: CALL 62780 0 6
113262: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
113263: LD_ADDR_VAR 0 8
113267: PUSH
113268: LD_VAR 0 4
113272: PUSH
113273: LD_VAR 0 7
113277: ARRAY
113278: PPUSH
113279: LD_VAR 0 9
113283: PPUSH
113284: CALL 81523 0 2
113288: ST_TO_ADDR
// if j then
113289: LD_VAR 0 8
113293: IFFALSE 113362
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
113295: LD_VAR 0 8
113299: PUSH
113300: LD_INT 1
113302: ARRAY
113303: PPUSH
113304: LD_VAR 0 8
113308: PUSH
113309: LD_INT 2
113311: ARRAY
113312: PPUSH
113313: CALL_OW 488
113317: IFFALSE 113362
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
113319: LD_VAR 0 4
113323: PUSH
113324: LD_VAR 0 7
113328: ARRAY
113329: PPUSH
113330: LD_VAR 0 8
113334: PUSH
113335: LD_INT 1
113337: ARRAY
113338: PPUSH
113339: LD_VAR 0 8
113343: PUSH
113344: LD_INT 2
113346: ARRAY
113347: PPUSH
113348: CALL_OW 116
// attacking := true ;
113352: LD_ADDR_VAR 0 29
113356: PUSH
113357: LD_INT 1
113359: ST_TO_ADDR
// continue ;
113360: GO 110735
// end ; end else
113362: GO 113388
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
113364: LD_VAR 0 4
113368: PUSH
113369: LD_VAR 0 7
113373: ARRAY
113374: PPUSH
113375: LD_VAR 0 14
113379: PUSH
113380: LD_INT 1
113382: ARRAY
113383: PPUSH
113384: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
113388: LD_VAR 0 4
113392: PUSH
113393: LD_VAR 0 7
113397: ARRAY
113398: PPUSH
113399: CALL_OW 265
113403: PUSH
113404: LD_INT 11
113406: EQUAL
113407: IFFALSE 113685
// begin k := 10 ;
113409: LD_ADDR_VAR 0 9
113413: PUSH
113414: LD_INT 10
113416: ST_TO_ADDR
// x := 0 ;
113417: LD_ADDR_VAR 0 10
113421: PUSH
113422: LD_INT 0
113424: ST_TO_ADDR
// if tmp < k then
113425: LD_VAR 0 14
113429: PUSH
113430: LD_VAR 0 9
113434: LESS
113435: IFFALSE 113447
// k := tmp ;
113437: LD_ADDR_VAR 0 9
113441: PUSH
113442: LD_VAR 0 14
113446: ST_TO_ADDR
// for j = k downto 1 do
113447: LD_ADDR_VAR 0 8
113451: PUSH
113452: DOUBLE
113453: LD_VAR 0 9
113457: INC
113458: ST_TO_ADDR
113459: LD_INT 1
113461: PUSH
113462: FOR_DOWNTO
113463: IFFALSE 113538
// begin if GetType ( tmp [ j ] ) = unit_human then
113465: LD_VAR 0 14
113469: PUSH
113470: LD_VAR 0 8
113474: ARRAY
113475: PPUSH
113476: CALL_OW 247
113480: PUSH
113481: LD_INT 1
113483: EQUAL
113484: IFFALSE 113536
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
113486: LD_VAR 0 4
113490: PUSH
113491: LD_VAR 0 7
113495: ARRAY
113496: PPUSH
113497: LD_VAR 0 14
113501: PUSH
113502: LD_VAR 0 8
113506: ARRAY
113507: PPUSH
113508: CALL 81777 0 2
// x := tmp [ j ] ;
113512: LD_ADDR_VAR 0 10
113516: PUSH
113517: LD_VAR 0 14
113521: PUSH
113522: LD_VAR 0 8
113526: ARRAY
113527: ST_TO_ADDR
// attacking := true ;
113528: LD_ADDR_VAR 0 29
113532: PUSH
113533: LD_INT 1
113535: ST_TO_ADDR
// end ; end ;
113536: GO 113462
113538: POP
113539: POP
// if not x then
113540: LD_VAR 0 10
113544: NOT
113545: IFFALSE 113685
// begin attacking := true ;
113547: LD_ADDR_VAR 0 29
113551: PUSH
113552: LD_INT 1
113554: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
113555: LD_VAR 0 4
113559: PUSH
113560: LD_VAR 0 7
113564: ARRAY
113565: PPUSH
113566: CALL_OW 250
113570: PPUSH
113571: LD_VAR 0 4
113575: PUSH
113576: LD_VAR 0 7
113580: ARRAY
113581: PPUSH
113582: CALL_OW 251
113586: PPUSH
113587: CALL_OW 546
113591: PUSH
113592: LD_INT 2
113594: ARRAY
113595: PUSH
113596: LD_VAR 0 14
113600: PUSH
113601: LD_INT 1
113603: ARRAY
113604: PPUSH
113605: CALL_OW 250
113609: PPUSH
113610: LD_VAR 0 14
113614: PUSH
113615: LD_INT 1
113617: ARRAY
113618: PPUSH
113619: CALL_OW 251
113623: PPUSH
113624: CALL_OW 546
113628: PUSH
113629: LD_INT 2
113631: ARRAY
113632: EQUAL
113633: IFFALSE 113661
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
113635: LD_VAR 0 4
113639: PUSH
113640: LD_VAR 0 7
113644: ARRAY
113645: PPUSH
113646: LD_VAR 0 14
113650: PUSH
113651: LD_INT 1
113653: ARRAY
113654: PPUSH
113655: CALL 81777 0 2
113659: GO 113685
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
113661: LD_VAR 0 4
113665: PUSH
113666: LD_VAR 0 7
113670: ARRAY
113671: PPUSH
113672: LD_VAR 0 14
113676: PUSH
113677: LD_INT 1
113679: ARRAY
113680: PPUSH
113681: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
113685: LD_VAR 0 4
113689: PUSH
113690: LD_VAR 0 7
113694: ARRAY
113695: PPUSH
113696: CALL_OW 264
113700: PUSH
113701: LD_INT 29
113703: EQUAL
113704: IFFALSE 114070
// begin if WantsToAttack ( group [ i ] ) in bombed then
113706: LD_VAR 0 4
113710: PUSH
113711: LD_VAR 0 7
113715: ARRAY
113716: PPUSH
113717: CALL_OW 319
113721: PUSH
113722: LD_VAR 0 28
113726: IN
113727: IFFALSE 113731
// continue ;
113729: GO 110735
// k := 8 ;
113731: LD_ADDR_VAR 0 9
113735: PUSH
113736: LD_INT 8
113738: ST_TO_ADDR
// x := 0 ;
113739: LD_ADDR_VAR 0 10
113743: PUSH
113744: LD_INT 0
113746: ST_TO_ADDR
// if tmp < k then
113747: LD_VAR 0 14
113751: PUSH
113752: LD_VAR 0 9
113756: LESS
113757: IFFALSE 113769
// k := tmp ;
113759: LD_ADDR_VAR 0 9
113763: PUSH
113764: LD_VAR 0 14
113768: ST_TO_ADDR
// for j = 1 to k do
113769: LD_ADDR_VAR 0 8
113773: PUSH
113774: DOUBLE
113775: LD_INT 1
113777: DEC
113778: ST_TO_ADDR
113779: LD_VAR 0 9
113783: PUSH
113784: FOR_TO
113785: IFFALSE 113917
// begin if GetType ( tmp [ j ] ) = unit_building then
113787: LD_VAR 0 14
113791: PUSH
113792: LD_VAR 0 8
113796: ARRAY
113797: PPUSH
113798: CALL_OW 247
113802: PUSH
113803: LD_INT 3
113805: EQUAL
113806: IFFALSE 113915
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
113808: LD_VAR 0 14
113812: PUSH
113813: LD_VAR 0 8
113817: ARRAY
113818: PUSH
113819: LD_VAR 0 28
113823: IN
113824: NOT
113825: PUSH
113826: LD_VAR 0 14
113830: PUSH
113831: LD_VAR 0 8
113835: ARRAY
113836: PPUSH
113837: CALL_OW 313
113841: AND
113842: IFFALSE 113915
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
113844: LD_VAR 0 4
113848: PUSH
113849: LD_VAR 0 7
113853: ARRAY
113854: PPUSH
113855: LD_VAR 0 14
113859: PUSH
113860: LD_VAR 0 8
113864: ARRAY
113865: PPUSH
113866: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
113870: LD_ADDR_VAR 0 28
113874: PUSH
113875: LD_VAR 0 28
113879: PPUSH
113880: LD_VAR 0 28
113884: PUSH
113885: LD_INT 1
113887: PLUS
113888: PPUSH
113889: LD_VAR 0 14
113893: PUSH
113894: LD_VAR 0 8
113898: ARRAY
113899: PPUSH
113900: CALL_OW 1
113904: ST_TO_ADDR
// attacking := true ;
113905: LD_ADDR_VAR 0 29
113909: PUSH
113910: LD_INT 1
113912: ST_TO_ADDR
// break ;
113913: GO 113917
// end ; end ;
113915: GO 113784
113917: POP
113918: POP
// if not attacking and f_attack_depot then
113919: LD_VAR 0 29
113923: NOT
113924: PUSH
113925: LD_VAR 0 25
113929: AND
113930: IFFALSE 114025
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
113932: LD_ADDR_VAR 0 13
113936: PUSH
113937: LD_VAR 0 14
113941: PPUSH
113942: LD_INT 2
113944: PUSH
113945: LD_INT 30
113947: PUSH
113948: LD_INT 0
113950: PUSH
113951: EMPTY
113952: LIST
113953: LIST
113954: PUSH
113955: LD_INT 30
113957: PUSH
113958: LD_INT 1
113960: PUSH
113961: EMPTY
113962: LIST
113963: LIST
113964: PUSH
113965: EMPTY
113966: LIST
113967: LIST
113968: LIST
113969: PPUSH
113970: CALL_OW 72
113974: ST_TO_ADDR
// if z then
113975: LD_VAR 0 13
113979: IFFALSE 114025
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
113981: LD_VAR 0 4
113985: PUSH
113986: LD_VAR 0 7
113990: ARRAY
113991: PPUSH
113992: LD_VAR 0 13
113996: PPUSH
113997: LD_VAR 0 4
114001: PUSH
114002: LD_VAR 0 7
114006: ARRAY
114007: PPUSH
114008: CALL_OW 74
114012: PPUSH
114013: CALL_OW 115
// attacking := true ;
114017: LD_ADDR_VAR 0 29
114021: PUSH
114022: LD_INT 1
114024: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
114025: LD_VAR 0 4
114029: PUSH
114030: LD_VAR 0 7
114034: ARRAY
114035: PPUSH
114036: CALL_OW 256
114040: PUSH
114041: LD_INT 500
114043: LESS
114044: IFFALSE 114070
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
114046: LD_VAR 0 4
114050: PUSH
114051: LD_VAR 0 7
114055: ARRAY
114056: PPUSH
114057: LD_VAR 0 14
114061: PUSH
114062: LD_INT 1
114064: ARRAY
114065: PPUSH
114066: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
114070: LD_VAR 0 4
114074: PUSH
114075: LD_VAR 0 7
114079: ARRAY
114080: PPUSH
114081: CALL_OW 264
114085: PUSH
114086: LD_INT 49
114088: EQUAL
114089: IFFALSE 114210
// begin if not HasTask ( group [ i ] ) then
114091: LD_VAR 0 4
114095: PUSH
114096: LD_VAR 0 7
114100: ARRAY
114101: PPUSH
114102: CALL_OW 314
114106: NOT
114107: IFFALSE 114210
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
114109: LD_ADDR_VAR 0 9
114113: PUSH
114114: LD_INT 81
114116: PUSH
114117: LD_VAR 0 4
114121: PUSH
114122: LD_VAR 0 7
114126: ARRAY
114127: PPUSH
114128: CALL_OW 255
114132: PUSH
114133: EMPTY
114134: LIST
114135: LIST
114136: PPUSH
114137: CALL_OW 69
114141: PPUSH
114142: LD_VAR 0 4
114146: PUSH
114147: LD_VAR 0 7
114151: ARRAY
114152: PPUSH
114153: CALL_OW 74
114157: ST_TO_ADDR
// if k then
114158: LD_VAR 0 9
114162: IFFALSE 114210
// if GetDistUnits ( group [ i ] , k ) > 10 then
114164: LD_VAR 0 4
114168: PUSH
114169: LD_VAR 0 7
114173: ARRAY
114174: PPUSH
114175: LD_VAR 0 9
114179: PPUSH
114180: CALL_OW 296
114184: PUSH
114185: LD_INT 10
114187: GREATER
114188: IFFALSE 114210
// ComMoveUnit ( group [ i ] , k ) ;
114190: LD_VAR 0 4
114194: PUSH
114195: LD_VAR 0 7
114199: ARRAY
114200: PPUSH
114201: LD_VAR 0 9
114205: PPUSH
114206: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
114210: LD_VAR 0 4
114214: PUSH
114215: LD_VAR 0 7
114219: ARRAY
114220: PPUSH
114221: CALL_OW 256
114225: PUSH
114226: LD_INT 250
114228: LESS
114229: PUSH
114230: LD_VAR 0 4
114234: PUSH
114235: LD_VAR 0 7
114239: ARRAY
114240: PUSH
114241: LD_INT 21
114243: PUSH
114244: LD_INT 2
114246: PUSH
114247: EMPTY
114248: LIST
114249: LIST
114250: PUSH
114251: LD_INT 23
114253: PUSH
114254: LD_INT 2
114256: PUSH
114257: EMPTY
114258: LIST
114259: LIST
114260: PUSH
114261: EMPTY
114262: LIST
114263: LIST
114264: PPUSH
114265: CALL_OW 69
114269: IN
114270: AND
114271: IFFALSE 114396
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
114273: LD_ADDR_VAR 0 9
114277: PUSH
114278: LD_OWVAR 3
114282: PUSH
114283: LD_VAR 0 4
114287: PUSH
114288: LD_VAR 0 7
114292: ARRAY
114293: DIFF
114294: PPUSH
114295: LD_VAR 0 4
114299: PUSH
114300: LD_VAR 0 7
114304: ARRAY
114305: PPUSH
114306: CALL_OW 74
114310: ST_TO_ADDR
// if not k then
114311: LD_VAR 0 9
114315: NOT
114316: IFFALSE 114320
// continue ;
114318: GO 110735
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
114320: LD_VAR 0 9
114324: PUSH
114325: LD_INT 81
114327: PUSH
114328: LD_VAR 0 4
114332: PUSH
114333: LD_VAR 0 7
114337: ARRAY
114338: PPUSH
114339: CALL_OW 255
114343: PUSH
114344: EMPTY
114345: LIST
114346: LIST
114347: PPUSH
114348: CALL_OW 69
114352: IN
114353: PUSH
114354: LD_VAR 0 9
114358: PPUSH
114359: LD_VAR 0 4
114363: PUSH
114364: LD_VAR 0 7
114368: ARRAY
114369: PPUSH
114370: CALL_OW 296
114374: PUSH
114375: LD_INT 5
114377: LESS
114378: AND
114379: IFFALSE 114396
// ComAutodestruct ( group [ i ] ) ;
114381: LD_VAR 0 4
114385: PUSH
114386: LD_VAR 0 7
114390: ARRAY
114391: PPUSH
114392: CALL 81675 0 1
// end ; if f_attack_depot then
114396: LD_VAR 0 25
114400: IFFALSE 114512
// begin k := 6 ;
114402: LD_ADDR_VAR 0 9
114406: PUSH
114407: LD_INT 6
114409: ST_TO_ADDR
// if tmp < k then
114410: LD_VAR 0 14
114414: PUSH
114415: LD_VAR 0 9
114419: LESS
114420: IFFALSE 114432
// k := tmp ;
114422: LD_ADDR_VAR 0 9
114426: PUSH
114427: LD_VAR 0 14
114431: ST_TO_ADDR
// for j = 1 to k do
114432: LD_ADDR_VAR 0 8
114436: PUSH
114437: DOUBLE
114438: LD_INT 1
114440: DEC
114441: ST_TO_ADDR
114442: LD_VAR 0 9
114446: PUSH
114447: FOR_TO
114448: IFFALSE 114510
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
114450: LD_VAR 0 8
114454: PPUSH
114455: CALL_OW 266
114459: PUSH
114460: LD_INT 0
114462: PUSH
114463: LD_INT 1
114465: PUSH
114466: EMPTY
114467: LIST
114468: LIST
114469: IN
114470: IFFALSE 114508
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
114472: LD_VAR 0 4
114476: PUSH
114477: LD_VAR 0 7
114481: ARRAY
114482: PPUSH
114483: LD_VAR 0 14
114487: PUSH
114488: LD_VAR 0 8
114492: ARRAY
114493: PPUSH
114494: CALL_OW 115
// attacking := true ;
114498: LD_ADDR_VAR 0 29
114502: PUSH
114503: LD_INT 1
114505: ST_TO_ADDR
// break ;
114506: GO 114510
// end ;
114508: GO 114447
114510: POP
114511: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
114512: LD_VAR 0 4
114516: PUSH
114517: LD_VAR 0 7
114521: ARRAY
114522: PPUSH
114523: CALL_OW 302
114527: PUSH
114528: LD_VAR 0 29
114532: NOT
114533: AND
114534: IFFALSE 114856
// begin if GetTag ( group [ i ] ) = 71 then
114536: LD_VAR 0 4
114540: PUSH
114541: LD_VAR 0 7
114545: ARRAY
114546: PPUSH
114547: CALL_OW 110
114551: PUSH
114552: LD_INT 71
114554: EQUAL
114555: IFFALSE 114596
// begin if HasTask ( group [ i ] ) then
114557: LD_VAR 0 4
114561: PUSH
114562: LD_VAR 0 7
114566: ARRAY
114567: PPUSH
114568: CALL_OW 314
114572: IFFALSE 114578
// continue else
114574: GO 110735
114576: GO 114596
// SetTag ( group [ i ] , 0 ) ;
114578: LD_VAR 0 4
114582: PUSH
114583: LD_VAR 0 7
114587: ARRAY
114588: PPUSH
114589: LD_INT 0
114591: PPUSH
114592: CALL_OW 109
// end ; k := 8 ;
114596: LD_ADDR_VAR 0 9
114600: PUSH
114601: LD_INT 8
114603: ST_TO_ADDR
// x := 0 ;
114604: LD_ADDR_VAR 0 10
114608: PUSH
114609: LD_INT 0
114611: ST_TO_ADDR
// if tmp < k then
114612: LD_VAR 0 14
114616: PUSH
114617: LD_VAR 0 9
114621: LESS
114622: IFFALSE 114634
// k := tmp ;
114624: LD_ADDR_VAR 0 9
114628: PUSH
114629: LD_VAR 0 14
114633: ST_TO_ADDR
// for j = 1 to k do
114634: LD_ADDR_VAR 0 8
114638: PUSH
114639: DOUBLE
114640: LD_INT 1
114642: DEC
114643: ST_TO_ADDR
114644: LD_VAR 0 9
114648: PUSH
114649: FOR_TO
114650: IFFALSE 114748
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
114652: LD_VAR 0 14
114656: PUSH
114657: LD_VAR 0 8
114661: ARRAY
114662: PPUSH
114663: CALL_OW 247
114667: PUSH
114668: LD_INT 1
114670: EQUAL
114671: PUSH
114672: LD_VAR 0 14
114676: PUSH
114677: LD_VAR 0 8
114681: ARRAY
114682: PPUSH
114683: CALL_OW 256
114687: PUSH
114688: LD_INT 250
114690: LESS
114691: PUSH
114692: LD_VAR 0 20
114696: AND
114697: PUSH
114698: LD_VAR 0 20
114702: NOT
114703: PUSH
114704: LD_VAR 0 14
114708: PUSH
114709: LD_VAR 0 8
114713: ARRAY
114714: PPUSH
114715: CALL_OW 256
114719: PUSH
114720: LD_INT 250
114722: GREATEREQUAL
114723: AND
114724: OR
114725: AND
114726: IFFALSE 114746
// begin x := tmp [ j ] ;
114728: LD_ADDR_VAR 0 10
114732: PUSH
114733: LD_VAR 0 14
114737: PUSH
114738: LD_VAR 0 8
114742: ARRAY
114743: ST_TO_ADDR
// break ;
114744: GO 114748
// end ;
114746: GO 114649
114748: POP
114749: POP
// if x then
114750: LD_VAR 0 10
114754: IFFALSE 114778
// ComAttackUnit ( group [ i ] , x ) else
114756: LD_VAR 0 4
114760: PUSH
114761: LD_VAR 0 7
114765: ARRAY
114766: PPUSH
114767: LD_VAR 0 10
114771: PPUSH
114772: CALL_OW 115
114776: GO 114802
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
114778: LD_VAR 0 4
114782: PUSH
114783: LD_VAR 0 7
114787: ARRAY
114788: PPUSH
114789: LD_VAR 0 14
114793: PUSH
114794: LD_INT 1
114796: ARRAY
114797: PPUSH
114798: CALL_OW 115
// if not HasTask ( group [ i ] ) then
114802: LD_VAR 0 4
114806: PUSH
114807: LD_VAR 0 7
114811: ARRAY
114812: PPUSH
114813: CALL_OW 314
114817: NOT
114818: IFFALSE 114856
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
114820: LD_VAR 0 4
114824: PUSH
114825: LD_VAR 0 7
114829: ARRAY
114830: PPUSH
114831: LD_VAR 0 14
114835: PPUSH
114836: LD_VAR 0 4
114840: PUSH
114841: LD_VAR 0 7
114845: ARRAY
114846: PPUSH
114847: CALL_OW 74
114851: PPUSH
114852: CALL_OW 115
// end ; end ; end ;
114856: GO 110735
114858: POP
114859: POP
// wait ( 0 0$2 ) ;
114860: LD_INT 70
114862: PPUSH
114863: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
114867: LD_VAR 0 4
114871: NOT
114872: PUSH
114873: LD_VAR 0 4
114877: PUSH
114878: EMPTY
114879: EQUAL
114880: OR
114881: PUSH
114882: LD_INT 81
114884: PUSH
114885: LD_VAR 0 35
114889: PUSH
114890: EMPTY
114891: LIST
114892: LIST
114893: PPUSH
114894: CALL_OW 69
114898: NOT
114899: OR
114900: IFFALSE 110720
// end ;
114902: LD_VAR 0 2
114906: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
114907: LD_INT 0
114909: PPUSH
114910: PPUSH
114911: PPUSH
114912: PPUSH
114913: PPUSH
114914: PPUSH
// if not base or not mc_bases [ base ] or not solds then
114915: LD_VAR 0 1
114919: NOT
114920: PUSH
114921: LD_EXP 50
114925: PUSH
114926: LD_VAR 0 1
114930: ARRAY
114931: NOT
114932: OR
114933: PUSH
114934: LD_VAR 0 2
114938: NOT
114939: OR
114940: IFFALSE 114944
// exit ;
114942: GO 115498
// side := mc_sides [ base ] ;
114944: LD_ADDR_VAR 0 6
114948: PUSH
114949: LD_EXP 76
114953: PUSH
114954: LD_VAR 0 1
114958: ARRAY
114959: ST_TO_ADDR
// if not side then
114960: LD_VAR 0 6
114964: NOT
114965: IFFALSE 114969
// exit ;
114967: GO 115498
// for i in solds do
114969: LD_ADDR_VAR 0 7
114973: PUSH
114974: LD_VAR 0 2
114978: PUSH
114979: FOR_IN
114980: IFFALSE 115041
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
114982: LD_VAR 0 7
114986: PPUSH
114987: CALL_OW 310
114991: PPUSH
114992: CALL_OW 266
114996: PUSH
114997: LD_INT 32
114999: PUSH
115000: LD_INT 31
115002: PUSH
115003: EMPTY
115004: LIST
115005: LIST
115006: IN
115007: IFFALSE 115027
// solds := solds diff i else
115009: LD_ADDR_VAR 0 2
115013: PUSH
115014: LD_VAR 0 2
115018: PUSH
115019: LD_VAR 0 7
115023: DIFF
115024: ST_TO_ADDR
115025: GO 115039
// SetTag ( i , 18 ) ;
115027: LD_VAR 0 7
115031: PPUSH
115032: LD_INT 18
115034: PPUSH
115035: CALL_OW 109
115039: GO 114979
115041: POP
115042: POP
// if not solds then
115043: LD_VAR 0 2
115047: NOT
115048: IFFALSE 115052
// exit ;
115050: GO 115498
// repeat wait ( 0 0$2 ) ;
115052: LD_INT 70
115054: PPUSH
115055: CALL_OW 67
// enemy := mc_scan [ base ] ;
115059: LD_ADDR_VAR 0 4
115063: PUSH
115064: LD_EXP 73
115068: PUSH
115069: LD_VAR 0 1
115073: ARRAY
115074: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
115075: LD_EXP 50
115079: PUSH
115080: LD_VAR 0 1
115084: ARRAY
115085: NOT
115086: PUSH
115087: LD_EXP 50
115091: PUSH
115092: LD_VAR 0 1
115096: ARRAY
115097: PUSH
115098: EMPTY
115099: EQUAL
115100: OR
115101: IFFALSE 115138
// begin for i in solds do
115103: LD_ADDR_VAR 0 7
115107: PUSH
115108: LD_VAR 0 2
115112: PUSH
115113: FOR_IN
115114: IFFALSE 115127
// ComStop ( i ) ;
115116: LD_VAR 0 7
115120: PPUSH
115121: CALL_OW 141
115125: GO 115113
115127: POP
115128: POP
// solds := [ ] ;
115129: LD_ADDR_VAR 0 2
115133: PUSH
115134: EMPTY
115135: ST_TO_ADDR
// exit ;
115136: GO 115498
// end ; for i in solds do
115138: LD_ADDR_VAR 0 7
115142: PUSH
115143: LD_VAR 0 2
115147: PUSH
115148: FOR_IN
115149: IFFALSE 115470
// begin if IsInUnit ( i ) then
115151: LD_VAR 0 7
115155: PPUSH
115156: CALL_OW 310
115160: IFFALSE 115171
// ComExitBuilding ( i ) ;
115162: LD_VAR 0 7
115166: PPUSH
115167: CALL_OW 122
// if GetLives ( i ) > 500 then
115171: LD_VAR 0 7
115175: PPUSH
115176: CALL_OW 256
115180: PUSH
115181: LD_INT 500
115183: GREATER
115184: IFFALSE 115237
// begin e := NearestUnitToUnit ( enemy , i ) ;
115186: LD_ADDR_VAR 0 5
115190: PUSH
115191: LD_VAR 0 4
115195: PPUSH
115196: LD_VAR 0 7
115200: PPUSH
115201: CALL_OW 74
115205: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
115206: LD_VAR 0 7
115210: PPUSH
115211: LD_VAR 0 5
115215: PPUSH
115216: CALL_OW 250
115220: PPUSH
115221: LD_VAR 0 5
115225: PPUSH
115226: CALL_OW 251
115230: PPUSH
115231: CALL_OW 114
// end else
115235: GO 115468
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
115237: LD_VAR 0 7
115241: PPUSH
115242: LD_EXP 50
115246: PUSH
115247: LD_VAR 0 1
115251: ARRAY
115252: PPUSH
115253: LD_INT 2
115255: PUSH
115256: LD_INT 30
115258: PUSH
115259: LD_INT 0
115261: PUSH
115262: EMPTY
115263: LIST
115264: LIST
115265: PUSH
115266: LD_INT 30
115268: PUSH
115269: LD_INT 1
115271: PUSH
115272: EMPTY
115273: LIST
115274: LIST
115275: PUSH
115276: LD_INT 30
115278: PUSH
115279: LD_INT 6
115281: PUSH
115282: EMPTY
115283: LIST
115284: LIST
115285: PUSH
115286: EMPTY
115287: LIST
115288: LIST
115289: LIST
115290: LIST
115291: PPUSH
115292: CALL_OW 72
115296: PPUSH
115297: LD_VAR 0 7
115301: PPUSH
115302: CALL_OW 74
115306: PPUSH
115307: CALL_OW 296
115311: PUSH
115312: LD_INT 10
115314: GREATER
115315: IFFALSE 115468
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
115317: LD_ADDR_VAR 0 8
115321: PUSH
115322: LD_EXP 50
115326: PUSH
115327: LD_VAR 0 1
115331: ARRAY
115332: PPUSH
115333: LD_INT 2
115335: PUSH
115336: LD_INT 30
115338: PUSH
115339: LD_INT 0
115341: PUSH
115342: EMPTY
115343: LIST
115344: LIST
115345: PUSH
115346: LD_INT 30
115348: PUSH
115349: LD_INT 1
115351: PUSH
115352: EMPTY
115353: LIST
115354: LIST
115355: PUSH
115356: LD_INT 30
115358: PUSH
115359: LD_INT 6
115361: PUSH
115362: EMPTY
115363: LIST
115364: LIST
115365: PUSH
115366: EMPTY
115367: LIST
115368: LIST
115369: LIST
115370: LIST
115371: PPUSH
115372: CALL_OW 72
115376: PPUSH
115377: LD_VAR 0 7
115381: PPUSH
115382: CALL_OW 74
115386: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
115387: LD_VAR 0 7
115391: PPUSH
115392: LD_VAR 0 8
115396: PPUSH
115397: CALL_OW 250
115401: PPUSH
115402: LD_INT 3
115404: PPUSH
115405: LD_INT 5
115407: PPUSH
115408: CALL_OW 272
115412: PPUSH
115413: LD_VAR 0 8
115417: PPUSH
115418: CALL_OW 251
115422: PPUSH
115423: LD_INT 3
115425: PPUSH
115426: LD_INT 5
115428: PPUSH
115429: CALL_OW 273
115433: PPUSH
115434: CALL_OW 111
// SetTag ( i , 0 ) ;
115438: LD_VAR 0 7
115442: PPUSH
115443: LD_INT 0
115445: PPUSH
115446: CALL_OW 109
// solds := solds diff i ;
115450: LD_ADDR_VAR 0 2
115454: PUSH
115455: LD_VAR 0 2
115459: PUSH
115460: LD_VAR 0 7
115464: DIFF
115465: ST_TO_ADDR
// continue ;
115466: GO 115148
// end ; end ;
115468: GO 115148
115470: POP
115471: POP
// until not solds or not enemy ;
115472: LD_VAR 0 2
115476: NOT
115477: PUSH
115478: LD_VAR 0 4
115482: NOT
115483: OR
115484: IFFALSE 115052
// MC_Reset ( base , 18 ) ;
115486: LD_VAR 0 1
115490: PPUSH
115491: LD_INT 18
115493: PPUSH
115494: CALL 22153 0 2
// end ;
115498: LD_VAR 0 3
115502: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
115503: LD_INT 0
115505: PPUSH
115506: PPUSH
115507: PPUSH
115508: PPUSH
115509: PPUSH
115510: PPUSH
115511: PPUSH
115512: PPUSH
115513: PPUSH
115514: PPUSH
115515: PPUSH
115516: PPUSH
115517: PPUSH
115518: PPUSH
115519: PPUSH
115520: PPUSH
115521: PPUSH
115522: PPUSH
115523: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
115524: LD_ADDR_VAR 0 12
115528: PUSH
115529: LD_EXP 50
115533: PUSH
115534: LD_VAR 0 1
115538: ARRAY
115539: PPUSH
115540: LD_INT 25
115542: PUSH
115543: LD_INT 3
115545: PUSH
115546: EMPTY
115547: LIST
115548: LIST
115549: PPUSH
115550: CALL_OW 72
115554: ST_TO_ADDR
// if mc_remote_driver [ base ] then
115555: LD_EXP 90
115559: PUSH
115560: LD_VAR 0 1
115564: ARRAY
115565: IFFALSE 115589
// mechs := mechs diff mc_remote_driver [ base ] ;
115567: LD_ADDR_VAR 0 12
115571: PUSH
115572: LD_VAR 0 12
115576: PUSH
115577: LD_EXP 90
115581: PUSH
115582: LD_VAR 0 1
115586: ARRAY
115587: DIFF
115588: ST_TO_ADDR
// for i in mechs do
115589: LD_ADDR_VAR 0 4
115593: PUSH
115594: LD_VAR 0 12
115598: PUSH
115599: FOR_IN
115600: IFFALSE 115635
// if GetTag ( i ) > 0 then
115602: LD_VAR 0 4
115606: PPUSH
115607: CALL_OW 110
115611: PUSH
115612: LD_INT 0
115614: GREATER
115615: IFFALSE 115633
// mechs := mechs diff i ;
115617: LD_ADDR_VAR 0 12
115621: PUSH
115622: LD_VAR 0 12
115626: PUSH
115627: LD_VAR 0 4
115631: DIFF
115632: ST_TO_ADDR
115633: GO 115599
115635: POP
115636: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
115637: LD_ADDR_VAR 0 8
115641: PUSH
115642: LD_EXP 50
115646: PUSH
115647: LD_VAR 0 1
115651: ARRAY
115652: PPUSH
115653: LD_INT 2
115655: PUSH
115656: LD_INT 25
115658: PUSH
115659: LD_INT 1
115661: PUSH
115662: EMPTY
115663: LIST
115664: LIST
115665: PUSH
115666: LD_INT 25
115668: PUSH
115669: LD_INT 5
115671: PUSH
115672: EMPTY
115673: LIST
115674: LIST
115675: PUSH
115676: LD_INT 25
115678: PUSH
115679: LD_INT 8
115681: PUSH
115682: EMPTY
115683: LIST
115684: LIST
115685: PUSH
115686: LD_INT 25
115688: PUSH
115689: LD_INT 9
115691: PUSH
115692: EMPTY
115693: LIST
115694: LIST
115695: PUSH
115696: EMPTY
115697: LIST
115698: LIST
115699: LIST
115700: LIST
115701: LIST
115702: PPUSH
115703: CALL_OW 72
115707: ST_TO_ADDR
// if not defenders and not solds then
115708: LD_VAR 0 2
115712: NOT
115713: PUSH
115714: LD_VAR 0 8
115718: NOT
115719: AND
115720: IFFALSE 115724
// exit ;
115722: GO 117494
// depot_under_attack := false ;
115724: LD_ADDR_VAR 0 16
115728: PUSH
115729: LD_INT 0
115731: ST_TO_ADDR
// sold_defenders := [ ] ;
115732: LD_ADDR_VAR 0 17
115736: PUSH
115737: EMPTY
115738: ST_TO_ADDR
// if mechs then
115739: LD_VAR 0 12
115743: IFFALSE 115896
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
115745: LD_ADDR_VAR 0 4
115749: PUSH
115750: LD_VAR 0 2
115754: PPUSH
115755: LD_INT 21
115757: PUSH
115758: LD_INT 2
115760: PUSH
115761: EMPTY
115762: LIST
115763: LIST
115764: PPUSH
115765: CALL_OW 72
115769: PUSH
115770: FOR_IN
115771: IFFALSE 115894
// begin if GetTag ( i ) <> 20 then
115773: LD_VAR 0 4
115777: PPUSH
115778: CALL_OW 110
115782: PUSH
115783: LD_INT 20
115785: NONEQUAL
115786: IFFALSE 115800
// SetTag ( i , 20 ) ;
115788: LD_VAR 0 4
115792: PPUSH
115793: LD_INT 20
115795: PPUSH
115796: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
115800: LD_VAR 0 4
115804: PPUSH
115805: CALL_OW 263
115809: PUSH
115810: LD_INT 1
115812: EQUAL
115813: PUSH
115814: LD_VAR 0 4
115818: PPUSH
115819: CALL_OW 311
115823: NOT
115824: AND
115825: IFFALSE 115892
// begin un := mechs [ 1 ] ;
115827: LD_ADDR_VAR 0 10
115831: PUSH
115832: LD_VAR 0 12
115836: PUSH
115837: LD_INT 1
115839: ARRAY
115840: ST_TO_ADDR
// ComExit ( un ) ;
115841: LD_VAR 0 10
115845: PPUSH
115846: CALL 86560 0 1
// AddComEnterUnit ( un , i ) ;
115850: LD_VAR 0 10
115854: PPUSH
115855: LD_VAR 0 4
115859: PPUSH
115860: CALL_OW 180
// SetTag ( un , 19 ) ;
115864: LD_VAR 0 10
115868: PPUSH
115869: LD_INT 19
115871: PPUSH
115872: CALL_OW 109
// mechs := mechs diff un ;
115876: LD_ADDR_VAR 0 12
115880: PUSH
115881: LD_VAR 0 12
115885: PUSH
115886: LD_VAR 0 10
115890: DIFF
115891: ST_TO_ADDR
// end ; end ;
115892: GO 115770
115894: POP
115895: POP
// if solds then
115896: LD_VAR 0 8
115900: IFFALSE 115959
// for i in solds do
115902: LD_ADDR_VAR 0 4
115906: PUSH
115907: LD_VAR 0 8
115911: PUSH
115912: FOR_IN
115913: IFFALSE 115957
// if not GetTag ( i ) then
115915: LD_VAR 0 4
115919: PPUSH
115920: CALL_OW 110
115924: NOT
115925: IFFALSE 115955
// begin defenders := defenders union i ;
115927: LD_ADDR_VAR 0 2
115931: PUSH
115932: LD_VAR 0 2
115936: PUSH
115937: LD_VAR 0 4
115941: UNION
115942: ST_TO_ADDR
// SetTag ( i , 18 ) ;
115943: LD_VAR 0 4
115947: PPUSH
115948: LD_INT 18
115950: PPUSH
115951: CALL_OW 109
// end ;
115955: GO 115912
115957: POP
115958: POP
// repeat wait ( 0 0$2 ) ;
115959: LD_INT 70
115961: PPUSH
115962: CALL_OW 67
// enemy := mc_scan [ base ] ;
115966: LD_ADDR_VAR 0 21
115970: PUSH
115971: LD_EXP 73
115975: PUSH
115976: LD_VAR 0 1
115980: ARRAY
115981: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
115982: LD_EXP 50
115986: PUSH
115987: LD_VAR 0 1
115991: ARRAY
115992: NOT
115993: PUSH
115994: LD_EXP 50
115998: PUSH
115999: LD_VAR 0 1
116003: ARRAY
116004: PUSH
116005: EMPTY
116006: EQUAL
116007: OR
116008: IFFALSE 116045
// begin for i in defenders do
116010: LD_ADDR_VAR 0 4
116014: PUSH
116015: LD_VAR 0 2
116019: PUSH
116020: FOR_IN
116021: IFFALSE 116034
// ComStop ( i ) ;
116023: LD_VAR 0 4
116027: PPUSH
116028: CALL_OW 141
116032: GO 116020
116034: POP
116035: POP
// defenders := [ ] ;
116036: LD_ADDR_VAR 0 2
116040: PUSH
116041: EMPTY
116042: ST_TO_ADDR
// exit ;
116043: GO 117494
// end ; for i in defenders do
116045: LD_ADDR_VAR 0 4
116049: PUSH
116050: LD_VAR 0 2
116054: PUSH
116055: FOR_IN
116056: IFFALSE 116954
// begin e := NearestUnitToUnit ( enemy , i ) ;
116058: LD_ADDR_VAR 0 13
116062: PUSH
116063: LD_VAR 0 21
116067: PPUSH
116068: LD_VAR 0 4
116072: PPUSH
116073: CALL_OW 74
116077: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
116078: LD_ADDR_VAR 0 7
116082: PUSH
116083: LD_EXP 50
116087: PUSH
116088: LD_VAR 0 1
116092: ARRAY
116093: PPUSH
116094: LD_INT 2
116096: PUSH
116097: LD_INT 30
116099: PUSH
116100: LD_INT 0
116102: PUSH
116103: EMPTY
116104: LIST
116105: LIST
116106: PUSH
116107: LD_INT 30
116109: PUSH
116110: LD_INT 1
116112: PUSH
116113: EMPTY
116114: LIST
116115: LIST
116116: PUSH
116117: EMPTY
116118: LIST
116119: LIST
116120: LIST
116121: PPUSH
116122: CALL_OW 72
116126: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
116127: LD_ADDR_VAR 0 16
116131: PUSH
116132: LD_VAR 0 7
116136: NOT
116137: PUSH
116138: LD_VAR 0 7
116142: PPUSH
116143: LD_INT 3
116145: PUSH
116146: LD_INT 24
116148: PUSH
116149: LD_INT 600
116151: PUSH
116152: EMPTY
116153: LIST
116154: LIST
116155: PUSH
116156: EMPTY
116157: LIST
116158: LIST
116159: PPUSH
116160: CALL_OW 72
116164: OR
116165: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
116166: LD_VAR 0 4
116170: PPUSH
116171: CALL_OW 247
116175: PUSH
116176: LD_INT 2
116178: DOUBLE
116179: EQUAL
116180: IFTRUE 116184
116182: GO 116580
116184: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
116185: LD_VAR 0 4
116189: PPUSH
116190: CALL_OW 256
116194: PUSH
116195: LD_INT 1000
116197: EQUAL
116198: PUSH
116199: LD_VAR 0 4
116203: PPUSH
116204: LD_VAR 0 13
116208: PPUSH
116209: CALL_OW 296
116213: PUSH
116214: LD_INT 40
116216: LESS
116217: PUSH
116218: LD_VAR 0 13
116222: PPUSH
116223: LD_EXP 75
116227: PUSH
116228: LD_VAR 0 1
116232: ARRAY
116233: PPUSH
116234: CALL_OW 308
116238: OR
116239: AND
116240: IFFALSE 116362
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
116242: LD_VAR 0 4
116246: PPUSH
116247: CALL_OW 262
116251: PUSH
116252: LD_INT 1
116254: EQUAL
116255: PUSH
116256: LD_VAR 0 4
116260: PPUSH
116261: CALL_OW 261
116265: PUSH
116266: LD_INT 30
116268: LESS
116269: AND
116270: PUSH
116271: LD_VAR 0 7
116275: AND
116276: IFFALSE 116346
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
116278: LD_VAR 0 4
116282: PPUSH
116283: LD_VAR 0 7
116287: PPUSH
116288: LD_VAR 0 4
116292: PPUSH
116293: CALL_OW 74
116297: PPUSH
116298: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
116302: LD_VAR 0 4
116306: PPUSH
116307: LD_VAR 0 7
116311: PPUSH
116312: LD_VAR 0 4
116316: PPUSH
116317: CALL_OW 74
116321: PPUSH
116322: CALL_OW 296
116326: PUSH
116327: LD_INT 6
116329: LESS
116330: IFFALSE 116344
// SetFuel ( i , 100 ) ;
116332: LD_VAR 0 4
116336: PPUSH
116337: LD_INT 100
116339: PPUSH
116340: CALL_OW 240
// end else
116344: GO 116360
// ComAttackUnit ( i , e ) ;
116346: LD_VAR 0 4
116350: PPUSH
116351: LD_VAR 0 13
116355: PPUSH
116356: CALL_OW 115
// end else
116360: GO 116463
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
116362: LD_VAR 0 13
116366: PPUSH
116367: LD_EXP 75
116371: PUSH
116372: LD_VAR 0 1
116376: ARRAY
116377: PPUSH
116378: CALL_OW 308
116382: NOT
116383: PUSH
116384: LD_VAR 0 4
116388: PPUSH
116389: LD_VAR 0 13
116393: PPUSH
116394: CALL_OW 296
116398: PUSH
116399: LD_INT 40
116401: GREATEREQUAL
116402: AND
116403: PUSH
116404: LD_VAR 0 4
116408: PPUSH
116409: CALL_OW 256
116413: PUSH
116414: LD_INT 650
116416: LESSEQUAL
116417: OR
116418: PUSH
116419: LD_VAR 0 4
116423: PPUSH
116424: LD_EXP 74
116428: PUSH
116429: LD_VAR 0 1
116433: ARRAY
116434: PPUSH
116435: CALL_OW 308
116439: NOT
116440: AND
116441: IFFALSE 116463
// ComMoveToArea ( i , mc_parking [ base ] ) ;
116443: LD_VAR 0 4
116447: PPUSH
116448: LD_EXP 74
116452: PUSH
116453: LD_VAR 0 1
116457: ARRAY
116458: PPUSH
116459: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
116463: LD_VAR 0 4
116467: PPUSH
116468: CALL_OW 256
116472: PUSH
116473: LD_INT 1000
116475: LESS
116476: PUSH
116477: LD_VAR 0 4
116481: PPUSH
116482: CALL_OW 263
116486: PUSH
116487: LD_INT 1
116489: EQUAL
116490: AND
116491: PUSH
116492: LD_VAR 0 4
116496: PPUSH
116497: CALL_OW 311
116501: AND
116502: PUSH
116503: LD_VAR 0 4
116507: PPUSH
116508: LD_EXP 74
116512: PUSH
116513: LD_VAR 0 1
116517: ARRAY
116518: PPUSH
116519: CALL_OW 308
116523: AND
116524: IFFALSE 116578
// begin mech := IsDrivenBy ( i ) ;
116526: LD_ADDR_VAR 0 9
116530: PUSH
116531: LD_VAR 0 4
116535: PPUSH
116536: CALL_OW 311
116540: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
116541: LD_VAR 0 9
116545: PPUSH
116546: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
116550: LD_VAR 0 9
116554: PPUSH
116555: LD_VAR 0 4
116559: PPUSH
116560: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
116564: LD_VAR 0 9
116568: PPUSH
116569: LD_VAR 0 4
116573: PPUSH
116574: CALL_OW 180
// end ; end ; unit_human :
116578: GO 116925
116580: LD_INT 1
116582: DOUBLE
116583: EQUAL
116584: IFTRUE 116588
116586: GO 116924
116588: POP
// begin b := IsInUnit ( i ) ;
116589: LD_ADDR_VAR 0 18
116593: PUSH
116594: LD_VAR 0 4
116598: PPUSH
116599: CALL_OW 310
116603: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
116604: LD_ADDR_VAR 0 19
116608: PUSH
116609: LD_VAR 0 18
116613: NOT
116614: PUSH
116615: LD_VAR 0 18
116619: PPUSH
116620: CALL_OW 266
116624: PUSH
116625: LD_INT 32
116627: PUSH
116628: LD_INT 31
116630: PUSH
116631: EMPTY
116632: LIST
116633: LIST
116634: IN
116635: OR
116636: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
116637: LD_VAR 0 18
116641: PPUSH
116642: CALL_OW 266
116646: PUSH
116647: LD_INT 5
116649: EQUAL
116650: PUSH
116651: LD_VAR 0 4
116655: PPUSH
116656: CALL_OW 257
116660: PUSH
116661: LD_INT 1
116663: PUSH
116664: LD_INT 2
116666: PUSH
116667: LD_INT 3
116669: PUSH
116670: LD_INT 4
116672: PUSH
116673: EMPTY
116674: LIST
116675: LIST
116676: LIST
116677: LIST
116678: IN
116679: AND
116680: IFFALSE 116717
// begin class := AllowSpecClass ( i ) ;
116682: LD_ADDR_VAR 0 20
116686: PUSH
116687: LD_VAR 0 4
116691: PPUSH
116692: CALL 50480 0 1
116696: ST_TO_ADDR
// if class then
116697: LD_VAR 0 20
116701: IFFALSE 116717
// ComChangeProfession ( i , class ) ;
116703: LD_VAR 0 4
116707: PPUSH
116708: LD_VAR 0 20
116712: PPUSH
116713: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
116717: LD_VAR 0 16
116721: PUSH
116722: LD_VAR 0 2
116726: PPUSH
116727: LD_INT 21
116729: PUSH
116730: LD_INT 2
116732: PUSH
116733: EMPTY
116734: LIST
116735: LIST
116736: PPUSH
116737: CALL_OW 72
116741: PUSH
116742: LD_INT 1
116744: LESSEQUAL
116745: OR
116746: PUSH
116747: LD_VAR 0 19
116751: AND
116752: PUSH
116753: LD_VAR 0 4
116757: PUSH
116758: LD_VAR 0 17
116762: IN
116763: NOT
116764: AND
116765: IFFALSE 116858
// begin if b then
116767: LD_VAR 0 18
116771: IFFALSE 116820
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
116773: LD_VAR 0 18
116777: PPUSH
116778: LD_VAR 0 21
116782: PPUSH
116783: LD_VAR 0 18
116787: PPUSH
116788: CALL_OW 74
116792: PPUSH
116793: CALL_OW 296
116797: PUSH
116798: LD_INT 10
116800: LESS
116801: PUSH
116802: LD_VAR 0 18
116806: PPUSH
116807: CALL_OW 461
116811: PUSH
116812: LD_INT 7
116814: NONEQUAL
116815: AND
116816: IFFALSE 116820
// continue ;
116818: GO 116055
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
116820: LD_ADDR_VAR 0 17
116824: PUSH
116825: LD_VAR 0 17
116829: PPUSH
116830: LD_VAR 0 17
116834: PUSH
116835: LD_INT 1
116837: PLUS
116838: PPUSH
116839: LD_VAR 0 4
116843: PPUSH
116844: CALL_OW 1
116848: ST_TO_ADDR
// ComExitBuilding ( i ) ;
116849: LD_VAR 0 4
116853: PPUSH
116854: CALL_OW 122
// end ; if sold_defenders then
116858: LD_VAR 0 17
116862: IFFALSE 116922
// if i in sold_defenders then
116864: LD_VAR 0 4
116868: PUSH
116869: LD_VAR 0 17
116873: IN
116874: IFFALSE 116922
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
116876: LD_VAR 0 4
116880: PPUSH
116881: CALL_OW 314
116885: NOT
116886: PUSH
116887: LD_VAR 0 4
116891: PPUSH
116892: LD_VAR 0 13
116896: PPUSH
116897: CALL_OW 296
116901: PUSH
116902: LD_INT 30
116904: LESS
116905: AND
116906: IFFALSE 116922
// ComAttackUnit ( i , e ) ;
116908: LD_VAR 0 4
116912: PPUSH
116913: LD_VAR 0 13
116917: PPUSH
116918: CALL_OW 115
// end ; end ; end ;
116922: GO 116925
116924: POP
// if IsDead ( i ) then
116925: LD_VAR 0 4
116929: PPUSH
116930: CALL_OW 301
116934: IFFALSE 116952
// defenders := defenders diff i ;
116936: LD_ADDR_VAR 0 2
116940: PUSH
116941: LD_VAR 0 2
116945: PUSH
116946: LD_VAR 0 4
116950: DIFF
116951: ST_TO_ADDR
// end ;
116952: GO 116055
116954: POP
116955: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
116956: LD_VAR 0 21
116960: NOT
116961: PUSH
116962: LD_VAR 0 2
116966: NOT
116967: OR
116968: PUSH
116969: LD_EXP 50
116973: PUSH
116974: LD_VAR 0 1
116978: ARRAY
116979: NOT
116980: OR
116981: IFFALSE 115959
// MC_Reset ( base , 18 ) ;
116983: LD_VAR 0 1
116987: PPUSH
116988: LD_INT 18
116990: PPUSH
116991: CALL 22153 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
116995: LD_ADDR_VAR 0 2
116999: PUSH
117000: LD_VAR 0 2
117004: PUSH
117005: LD_VAR 0 2
117009: PPUSH
117010: LD_INT 2
117012: PUSH
117013: LD_INT 25
117015: PUSH
117016: LD_INT 1
117018: PUSH
117019: EMPTY
117020: LIST
117021: LIST
117022: PUSH
117023: LD_INT 25
117025: PUSH
117026: LD_INT 5
117028: PUSH
117029: EMPTY
117030: LIST
117031: LIST
117032: PUSH
117033: LD_INT 25
117035: PUSH
117036: LD_INT 8
117038: PUSH
117039: EMPTY
117040: LIST
117041: LIST
117042: PUSH
117043: LD_INT 25
117045: PUSH
117046: LD_INT 9
117048: PUSH
117049: EMPTY
117050: LIST
117051: LIST
117052: PUSH
117053: EMPTY
117054: LIST
117055: LIST
117056: LIST
117057: LIST
117058: LIST
117059: PPUSH
117060: CALL_OW 72
117064: DIFF
117065: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
117066: LD_VAR 0 21
117070: NOT
117071: PUSH
117072: LD_VAR 0 2
117076: PPUSH
117077: LD_INT 21
117079: PUSH
117080: LD_INT 2
117082: PUSH
117083: EMPTY
117084: LIST
117085: LIST
117086: PPUSH
117087: CALL_OW 72
117091: AND
117092: IFFALSE 117430
// begin tmp := FilterByTag ( defenders , 19 ) ;
117094: LD_ADDR_VAR 0 11
117098: PUSH
117099: LD_VAR 0 2
117103: PPUSH
117104: LD_INT 19
117106: PPUSH
117107: CALL 83743 0 2
117111: ST_TO_ADDR
// if tmp then
117112: LD_VAR 0 11
117116: IFFALSE 117186
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
117118: LD_ADDR_VAR 0 11
117122: PUSH
117123: LD_VAR 0 11
117127: PPUSH
117128: LD_INT 25
117130: PUSH
117131: LD_INT 3
117133: PUSH
117134: EMPTY
117135: LIST
117136: LIST
117137: PPUSH
117138: CALL_OW 72
117142: ST_TO_ADDR
// if tmp then
117143: LD_VAR 0 11
117147: IFFALSE 117186
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
117149: LD_ADDR_EXP 62
117153: PUSH
117154: LD_EXP 62
117158: PPUSH
117159: LD_VAR 0 1
117163: PPUSH
117164: LD_EXP 62
117168: PUSH
117169: LD_VAR 0 1
117173: ARRAY
117174: PUSH
117175: LD_VAR 0 11
117179: UNION
117180: PPUSH
117181: CALL_OW 1
117185: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
117186: LD_VAR 0 1
117190: PPUSH
117191: LD_INT 19
117193: PPUSH
117194: CALL 22153 0 2
// repeat wait ( 0 0$1 ) ;
117198: LD_INT 35
117200: PPUSH
117201: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
117205: LD_EXP 50
117209: PUSH
117210: LD_VAR 0 1
117214: ARRAY
117215: NOT
117216: PUSH
117217: LD_EXP 50
117221: PUSH
117222: LD_VAR 0 1
117226: ARRAY
117227: PUSH
117228: EMPTY
117229: EQUAL
117230: OR
117231: IFFALSE 117268
// begin for i in defenders do
117233: LD_ADDR_VAR 0 4
117237: PUSH
117238: LD_VAR 0 2
117242: PUSH
117243: FOR_IN
117244: IFFALSE 117257
// ComStop ( i ) ;
117246: LD_VAR 0 4
117250: PPUSH
117251: CALL_OW 141
117255: GO 117243
117257: POP
117258: POP
// defenders := [ ] ;
117259: LD_ADDR_VAR 0 2
117263: PUSH
117264: EMPTY
117265: ST_TO_ADDR
// exit ;
117266: GO 117494
// end ; for i in defenders do
117268: LD_ADDR_VAR 0 4
117272: PUSH
117273: LD_VAR 0 2
117277: PUSH
117278: FOR_IN
117279: IFFALSE 117368
// begin if not IsInArea ( i , mc_parking [ base ] ) then
117281: LD_VAR 0 4
117285: PPUSH
117286: LD_EXP 74
117290: PUSH
117291: LD_VAR 0 1
117295: ARRAY
117296: PPUSH
117297: CALL_OW 308
117301: NOT
117302: IFFALSE 117326
// ComMoveToArea ( i , mc_parking [ base ] ) else
117304: LD_VAR 0 4
117308: PPUSH
117309: LD_EXP 74
117313: PUSH
117314: LD_VAR 0 1
117318: ARRAY
117319: PPUSH
117320: CALL_OW 113
117324: GO 117366
// if GetControl ( i ) = control_manual then
117326: LD_VAR 0 4
117330: PPUSH
117331: CALL_OW 263
117335: PUSH
117336: LD_INT 1
117338: EQUAL
117339: IFFALSE 117366
// if IsDrivenBy ( i ) then
117341: LD_VAR 0 4
117345: PPUSH
117346: CALL_OW 311
117350: IFFALSE 117366
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
117352: LD_VAR 0 4
117356: PPUSH
117357: CALL_OW 311
117361: PPUSH
117362: CALL_OW 121
// end ;
117366: GO 117278
117368: POP
117369: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
117370: LD_VAR 0 2
117374: PPUSH
117375: LD_INT 95
117377: PUSH
117378: LD_EXP 74
117382: PUSH
117383: LD_VAR 0 1
117387: ARRAY
117388: PUSH
117389: EMPTY
117390: LIST
117391: LIST
117392: PPUSH
117393: CALL_OW 72
117397: PUSH
117398: LD_VAR 0 2
117402: EQUAL
117403: PUSH
117404: LD_EXP 73
117408: PUSH
117409: LD_VAR 0 1
117413: ARRAY
117414: OR
117415: PUSH
117416: LD_EXP 50
117420: PUSH
117421: LD_VAR 0 1
117425: ARRAY
117426: NOT
117427: OR
117428: IFFALSE 117198
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
117430: LD_ADDR_EXP 72
117434: PUSH
117435: LD_EXP 72
117439: PPUSH
117440: LD_VAR 0 1
117444: PPUSH
117445: LD_VAR 0 2
117449: PPUSH
117450: LD_INT 21
117452: PUSH
117453: LD_INT 2
117455: PUSH
117456: EMPTY
117457: LIST
117458: LIST
117459: PPUSH
117460: CALL_OW 72
117464: PPUSH
117465: CALL_OW 1
117469: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
117470: LD_VAR 0 1
117474: PPUSH
117475: LD_INT 19
117477: PPUSH
117478: CALL 22153 0 2
// MC_Reset ( base , 20 ) ;
117482: LD_VAR 0 1
117486: PPUSH
117487: LD_INT 20
117489: PPUSH
117490: CALL 22153 0 2
// end ; end_of_file
117494: LD_VAR 0 3
117498: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
117499: LD_VAR 0 1
117503: PUSH
117504: LD_INT 200
117506: DOUBLE
117507: GREATEREQUAL
117508: IFFALSE 117516
117510: LD_INT 299
117512: DOUBLE
117513: LESSEQUAL
117514: IFTRUE 117518
117516: GO 117550
117518: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
117519: LD_VAR 0 1
117523: PPUSH
117524: LD_VAR 0 2
117528: PPUSH
117529: LD_VAR 0 3
117533: PPUSH
117534: LD_VAR 0 4
117538: PPUSH
117539: LD_VAR 0 5
117543: PPUSH
117544: CALL 106285 0 5
117548: GO 117627
117550: LD_INT 300
117552: DOUBLE
117553: GREATEREQUAL
117554: IFFALSE 117562
117556: LD_INT 399
117558: DOUBLE
117559: LESSEQUAL
117560: IFTRUE 117564
117562: GO 117626
117564: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
117565: LD_VAR 0 1
117569: PPUSH
117570: LD_VAR 0 2
117574: PPUSH
117575: LD_VAR 0 3
117579: PPUSH
117580: LD_VAR 0 4
117584: PPUSH
117585: LD_VAR 0 5
117589: PPUSH
117590: LD_VAR 0 6
117594: PPUSH
117595: LD_VAR 0 7
117599: PPUSH
117600: LD_VAR 0 8
117604: PPUSH
117605: LD_VAR 0 9
117609: PPUSH
117610: LD_VAR 0 10
117614: PPUSH
117615: LD_VAR 0 11
117619: PPUSH
117620: CALL 102618 0 11
117624: GO 117627
117626: POP
// end ;
117627: PPOPN 11
117629: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
117630: LD_VAR 0 1
117634: PPUSH
117635: LD_VAR 0 2
117639: PPUSH
117640: LD_VAR 0 3
117644: PPUSH
117645: LD_VAR 0 4
117649: PPUSH
117650: LD_VAR 0 5
117654: PPUSH
117655: CALL 106021 0 5
// end ; end_of_file
117659: PPOPN 5
117661: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
117662: LD_VAR 0 1
117666: PPUSH
117667: LD_VAR 0 2
117671: PPUSH
117672: LD_VAR 0 3
117676: PPUSH
117677: LD_VAR 0 4
117681: PPUSH
117682: LD_VAR 0 5
117686: PPUSH
117687: LD_VAR 0 6
117691: PPUSH
117692: CALL 90270 0 6
// end ;
117696: PPOPN 6
117698: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
117699: LD_INT 0
117701: PPUSH
// begin if not units then
117702: LD_VAR 0 1
117706: NOT
117707: IFFALSE 117711
// exit ;
117709: GO 117711
// end ;
117711: PPOPN 7
117713: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
117714: CALL 90174 0 0
// end ;
117718: PPOPN 1
117720: END
