// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Randomize ;
  11: CALL_OW 10
// InitVariables ;
  15: CALL 94 0 0
// InitMacro ;
  19: CALL 17096 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// ChangeSideFog ( 8 , 1 ) ;
  36: LD_INT 8
  38: PPUSH
  39: LD_INT 1
  41: PPUSH
  42: CALL_OW 343
// PrepareNature ( 4 , 3 , 6 , 3 , 2 , 0 , 7 , natureArea , waterArea ) ;
  46: LD_INT 4
  48: PPUSH
  49: LD_INT 3
  51: PPUSH
  52: LD_INT 6
  54: PPUSH
  55: LD_INT 3
  57: PPUSH
  58: LD_INT 2
  60: PPUSH
  61: LD_INT 0
  63: PPUSH
  64: LD_INT 7
  66: PPUSH
  67: LD_INT 18
  69: PPUSH
  70: LD_INT 19
  72: PPUSH
  73: CALL 82079 0 9
// PrepareAmerican ;
  77: CALL 562 0 0
// PrepareArabian ;
  81: CALL 2234 0 0
// MC_Start ( ) ;
  85: CALL 19208 0 0
// Action ;
  89: CALL 7865 0 0
// end ;
  93: END
// export debug , game ; export mission_prefix , mission_prefix_prev ; export ar_run , base_captured , ar_patrol , us_scout , seen , can_kamikazed , kamikazed , artifact_stolen , artifact_get , artifact_oncargo , game_time , powell_warn , loses_counter , gensher_active , selected , am_veh_consturcted ; function InitVariables ; begin
  94: LD_INT 0
  96: PPUSH
// debug := false ;
  97: LD_ADDR_EXP 1
 101: PUSH
 102: LD_INT 0
 104: ST_TO_ADDR
// game := true ;
 105: LD_ADDR_EXP 2
 109: PUSH
 110: LD_INT 1
 112: ST_TO_ADDR
// mission_prefix := 11_ ;
 113: LD_ADDR_EXP 3
 117: PUSH
 118: LD_STRING 11_
 120: ST_TO_ADDR
// mission_prefix_prev := 10c_ ;
 121: LD_ADDR_EXP 4
 125: PUSH
 126: LD_STRING 10c_
 128: ST_TO_ADDR
// ar_run := false ;
 129: LD_ADDR_EXP 5
 133: PUSH
 134: LD_INT 0
 136: ST_TO_ADDR
// ar_patrol := false ;
 137: LD_ADDR_EXP 7
 141: PUSH
 142: LD_INT 0
 144: ST_TO_ADDR
// base_captured := false ;
 145: LD_ADDR_EXP 6
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// us_scout := 0 ;
 153: LD_ADDR_EXP 8
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// seen := [ 0 , 0 , 0 , 0 , 0 ] ;
 161: LD_ADDR_EXP 9
 165: PUSH
 166: LD_INT 0
 168: PUSH
 169: LD_INT 0
 171: PUSH
 172: LD_INT 0
 174: PUSH
 175: LD_INT 0
 177: PUSH
 178: LD_INT 0
 180: PUSH
 181: EMPTY
 182: LIST
 183: LIST
 184: LIST
 185: LIST
 186: LIST
 187: ST_TO_ADDR
// kamikazed := false ;
 188: LD_ADDR_EXP 11
 192: PUSH
 193: LD_INT 0
 195: ST_TO_ADDR
// artifact_stolen := false ;
 196: LD_ADDR_EXP 12
 200: PUSH
 201: LD_INT 0
 203: ST_TO_ADDR
// artifact_get := false ;
 204: LD_ADDR_EXP 13
 208: PUSH
 209: LD_INT 0
 211: ST_TO_ADDR
// game_time := [ 130 130$00 , 120 120$00 , 115 115$00 ] [ Difficulty ] ;
 212: LD_ADDR_EXP 15
 216: PUSH
 217: LD_INT 273000
 219: PUSH
 220: LD_INT 252000
 222: PUSH
 223: LD_INT 241500
 225: PUSH
 226: EMPTY
 227: LIST
 228: LIST
 229: LIST
 230: PUSH
 231: LD_OWVAR 67
 235: ARRAY
 236: ST_TO_ADDR
// powell_warn := false ;
 237: LD_ADDR_EXP 16
 241: PUSH
 242: LD_INT 0
 244: ST_TO_ADDR
// loses_counter := 0 ;
 245: LD_ADDR_EXP 17
 249: PUSH
 250: LD_INT 0
 252: ST_TO_ADDR
// artifact_oncargo := false ;
 253: LD_ADDR_EXP 14
 257: PUSH
 258: LD_INT 0
 260: ST_TO_ADDR
// gensher_active := LoadVariable ( 10_GensherEscape_1 , debug ) ;
 261: LD_ADDR_EXP 18
 265: PUSH
 266: LD_STRING 10_GensherEscape_1
 268: PPUSH
 269: LD_EXP 1
 273: PPUSH
 274: CALL_OW 30
 278: ST_TO_ADDR
// can_kamikazed := false ;
 279: LD_ADDR_EXP 10
 283: PUSH
 284: LD_INT 0
 286: ST_TO_ADDR
// am_veh_consturcted := false ;
 287: LD_ADDR_EXP 20
 291: PUSH
 292: LD_INT 0
 294: ST_TO_ADDR
// end ;
 295: LD_VAR 0 1
 299: RET
// export function CustomInitMacro ; var i ; begin
 300: LD_INT 0
 302: PPUSH
 303: PPUSH
// mc_parking := [ parking_north , parking_west , parking_east ] ;
 304: LD_ADDR_EXP 74
 308: PUSH
 309: LD_INT 20
 311: PUSH
 312: LD_INT 21
 314: PUSH
 315: LD_INT 22
 317: PUSH
 318: EMPTY
 319: LIST
 320: LIST
 321: LIST
 322: ST_TO_ADDR
// mc_scan_area := [ base_north , base_west , base_east ] ;
 323: LD_ADDR_EXP 75
 327: PUSH
 328: LD_INT 28
 330: PUSH
 331: LD_INT 24
 333: PUSH
 334: LD_INT 26
 336: PUSH
 337: EMPTY
 338: LIST
 339: LIST
 340: LIST
 341: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 3 , 6 , 9 ] [ Difficulty ] , minefield1_left ) ;
 342: LD_INT 1
 344: PPUSH
 345: LD_INT 3
 347: PUSH
 348: LD_INT 6
 350: PUSH
 351: LD_INT 9
 353: PUSH
 354: EMPTY
 355: LIST
 356: LIST
 357: LIST
 358: PUSH
 359: LD_OWVAR 67
 363: ARRAY
 364: PPUSH
 365: LD_INT 3
 367: PPUSH
 368: CALL 40529 0 3
// MC_SetMinesField ( 2 , [ 3 , 6 , 9 ] [ Difficulty ] , minefield2_left ) ;
 372: LD_INT 2
 374: PPUSH
 375: LD_INT 3
 377: PUSH
 378: LD_INT 6
 380: PUSH
 381: LD_INT 9
 383: PUSH
 384: EMPTY
 385: LIST
 386: LIST
 387: LIST
 388: PUSH
 389: LD_OWVAR 67
 393: ARRAY
 394: PPUSH
 395: LD_INT 2
 397: PPUSH
 398: CALL 40529 0 3
// MC_SetMinesField ( 3 , [ 3 , 5 , 9 ] [ Difficulty ] , minefield3_left ) ;
 402: LD_INT 3
 404: PPUSH
 405: LD_INT 3
 407: PUSH
 408: LD_INT 5
 410: PUSH
 411: LD_INT 9
 413: PUSH
 414: EMPTY
 415: LIST
 416: LIST
 417: LIST
 418: PUSH
 419: LD_OWVAR 67
 423: ARRAY
 424: PPUSH
 425: LD_INT 1
 427: PPUSH
 428: CALL 40529 0 3
// for i = 1 to mc_bases do
 432: LD_ADDR_VAR 0 2
 436: PUSH
 437: DOUBLE
 438: LD_INT 1
 440: DEC
 441: ST_TO_ADDR
 442: LD_EXP 50
 446: PUSH
 447: FOR_TO
 448: IFFALSE 472
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 450: LD_VAR 0 2
 454: PPUSH
 455: LD_EXP 43
 459: PUSH
 460: LD_VAR 0 2
 464: ARRAY
 465: PPUSH
 466: CALL 40955 0 2
 470: GO 447
 472: POP
 473: POP
// end ;
 474: LD_VAR 0 1
 478: RET
// function Debuger ; var i ; begin
 479: LD_INT 0
 481: PPUSH
 482: PPUSH
// if not debug then
 483: LD_EXP 1
 487: NOT
 488: IFFALSE 492
// exit ;
 490: GO 528
// game_speed := 5 ;
 492: LD_ADDR_OWVAR 65
 496: PUSH
 497: LD_INT 5
 499: ST_TO_ADDR
// uc_side := 1 ;
 500: LD_ADDR_OWVAR 20
 504: PUSH
 505: LD_INT 1
 507: ST_TO_ADDR
// uc_nation := 1 ;
 508: LD_ADDR_OWVAR 21
 512: PUSH
 513: LD_INT 1
 515: ST_TO_ADDR
// SetSide ( ar_force_south , 1 ) ;
 516: LD_EXP 36
 520: PPUSH
 521: LD_INT 1
 523: PPUSH
 524: CALL_OW 235
// end ;
 528: LD_VAR 0 1
 532: RET
// every 0 0$1 trigger IsDead ( ar_dep_n ) and IsOk ( ar_dep_w ) do
 533: LD_INT 94
 535: PPUSH
 536: CALL_OW 301
 540: PUSH
 541: LD_INT 45
 543: PPUSH
 544: CALL_OW 302
 548: AND
 549: IFFALSE 561
 551: GO 553
 553: DISABLE
// SetAchievement ( ACH_EAST ) ; end_of_file
 554: LD_STRING ACH_EAST
 556: PPUSH
 557: CALL_OW 543
 561: END
// export JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Frank , Kikuchi ; export function PrepareAmerican ; var i , k , un , tmp , vehs , veh , others ; begin
 562: LD_INT 0
 564: PPUSH
 565: PPUSH
 566: PPUSH
 567: PPUSH
 568: PPUSH
 569: PPUSH
 570: PPUSH
 571: PPUSH
// uc_side := 4 ;
 572: LD_ADDR_OWVAR 20
 576: PUSH
 577: LD_INT 4
 579: ST_TO_ADDR
// uc_nation := 1 ;
 580: LD_ADDR_OWVAR 21
 584: PUSH
 585: LD_INT 1
 587: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
 588: LD_ADDR_EXP 30
 592: PUSH
 593: LD_STRING Powell
 595: PPUSH
 596: LD_INT 0
 598: PPUSH
 599: LD_STRING 
 601: PPUSH
 602: CALL 47239 0 3
 606: ST_TO_ADDR
// uc_side := 1 ;
 607: LD_ADDR_OWVAR 20
 611: PUSH
 612: LD_INT 1
 614: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , mission_prefix_prev ) ;
 615: LD_ADDR_EXP 21
 619: PUSH
 620: LD_STRING JMM
 622: PPUSH
 623: LD_EXP 1
 627: NOT
 628: PPUSH
 629: LD_EXP 4
 633: PPUSH
 634: CALL 47239 0 3
 638: ST_TO_ADDR
// if GetClass ( JMM ) > 4 then
 639: LD_EXP 21
 643: PPUSH
 644: CALL_OW 257
 648: PUSH
 649: LD_INT 4
 651: GREATER
 652: IFFALSE 666
// SetClass ( JMM , 1 ) ;
 654: LD_EXP 21
 658: PPUSH
 659: LD_INT 1
 661: PPUSH
 662: CALL_OW 336
// Lisa := PrepareUnit ( Lisa , ( not debug ) , mission_prefix_prev ) ;
 666: LD_ADDR_EXP 22
 670: PUSH
 671: LD_STRING Lisa
 673: PPUSH
 674: LD_EXP 1
 678: NOT
 679: PPUSH
 680: LD_EXP 4
 684: PPUSH
 685: CALL 47239 0 3
 689: ST_TO_ADDR
// if not Lisa then
 690: LD_EXP 22
 694: NOT
 695: IFFALSE 710
// Lisa := CreateCharacter ( 10_Lisa ) ;
 697: LD_ADDR_EXP 22
 701: PUSH
 702: LD_STRING 10_Lisa
 704: PPUSH
 705: CALL_OW 34
 709: ST_TO_ADDR
// if not Lisa then
 710: LD_EXP 22
 714: NOT
 715: IFFALSE 730
// Lisa := CreateCharacter ( 09_Lisa ) ;
 717: LD_ADDR_EXP 22
 721: PUSH
 722: LD_STRING 09_Lisa
 724: PPUSH
 725: CALL_OW 34
 729: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , mission_prefix_prev ) ;
 730: LD_ADDR_EXP 31
 734: PUSH
 735: LD_STRING Cornel
 737: PPUSH
 738: LD_EXP 1
 742: NOT
 743: PPUSH
 744: LD_EXP 4
 748: PPUSH
 749: CALL 47239 0 3
 753: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , mission_prefix_prev ) ;
 754: LD_ADDR_EXP 23
 758: PUSH
 759: LD_STRING Donaldson
 761: PPUSH
 762: LD_EXP 1
 766: NOT
 767: PPUSH
 768: LD_EXP 4
 772: PPUSH
 773: CALL 47239 0 3
 777: ST_TO_ADDR
// if not Donaldson then
 778: LD_EXP 23
 782: NOT
 783: IFFALSE 798
// Donaldson := CreateCharacter ( 10_Donaldson ) ;
 785: LD_ADDR_EXP 23
 789: PUSH
 790: LD_STRING 10_Donaldson
 792: PPUSH
 793: CALL_OW 34
 797: ST_TO_ADDR
// if not Donaldson then
 798: LD_EXP 23
 802: NOT
 803: IFFALSE 818
// Donaldson := CreateCharacter ( 09_Donaldson ) ;
 805: LD_ADDR_EXP 23
 809: PUSH
 810: LD_STRING 09_Donaldson
 812: PPUSH
 813: CALL_OW 34
 817: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , mission_prefix_prev ) ;
 818: LD_ADDR_EXP 24
 822: PUSH
 823: LD_STRING Bobby
 825: PPUSH
 826: LD_EXP 1
 830: NOT
 831: PPUSH
 832: LD_EXP 4
 836: PPUSH
 837: CALL 47239 0 3
 841: ST_TO_ADDR
// if not Bobby then
 842: LD_EXP 24
 846: NOT
 847: IFFALSE 862
// Bobby := CreateCharacter ( 10_Bobby ) ;
 849: LD_ADDR_EXP 24
 853: PUSH
 854: LD_STRING 10_Bobby
 856: PPUSH
 857: CALL_OW 34
 861: ST_TO_ADDR
// if not Bobby then
 862: LD_EXP 24
 866: NOT
 867: IFFALSE 882
// Bobby := CreateCharacter ( 09_Bobby ) ;
 869: LD_ADDR_EXP 24
 873: PUSH
 874: LD_STRING 09_Bobby
 876: PPUSH
 877: CALL_OW 34
 881: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , mission_prefix_prev ) ;
 882: LD_ADDR_EXP 25
 886: PUSH
 887: LD_STRING Cyrus
 889: PPUSH
 890: LD_EXP 1
 894: NOT
 895: PPUSH
 896: LD_EXP 4
 900: PPUSH
 901: CALL 47239 0 3
 905: ST_TO_ADDR
// if not Cyrus then
 906: LD_EXP 25
 910: NOT
 911: IFFALSE 926
// Cyrus := CreateCharacter ( 10_Cyrus ) ;
 913: LD_ADDR_EXP 25
 917: PUSH
 918: LD_STRING 10_Cyrus
 920: PPUSH
 921: CALL_OW 34
 925: ST_TO_ADDR
// if not Cyrus then
 926: LD_EXP 25
 930: NOT
 931: IFFALSE 946
// Cyrus := CreateCharacter ( 09_Cyrus ) ;
 933: LD_ADDR_EXP 25
 937: PUSH
 938: LD_STRING 09_Cyrus
 940: PPUSH
 941: CALL_OW 34
 945: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , mission_prefix_prev ) ;
 946: LD_ADDR_EXP 26
 950: PUSH
 951: LD_STRING Denis
 953: PPUSH
 954: LD_EXP 1
 958: NOT
 959: PPUSH
 960: LD_EXP 4
 964: PPUSH
 965: CALL 47239 0 3
 969: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , mission_prefix_prev ) ;
 970: LD_ADDR_EXP 27
 974: PUSH
 975: LD_STRING Brown
 977: PPUSH
 978: LD_EXP 1
 982: NOT
 983: PPUSH
 984: LD_EXP 4
 988: PPUSH
 989: CALL 47239 0 3
 993: ST_TO_ADDR
// if not Brown then
 994: LD_EXP 27
 998: NOT
 999: IFFALSE 1014
// Brown := CreateCharacter ( 10_Brown ) ;
1001: LD_ADDR_EXP 27
1005: PUSH
1006: LD_STRING 10_Brown
1008: PPUSH
1009: CALL_OW 34
1013: ST_TO_ADDR
// if not Brown then
1014: LD_EXP 27
1018: NOT
1019: IFFALSE 1034
// Brown := CreateCharacter ( 08_Brown ) ;
1021: LD_ADDR_EXP 27
1025: PUSH
1026: LD_STRING 08_Brown
1028: PPUSH
1029: CALL_OW 34
1033: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , mission_prefix_prev ) ;
1034: LD_ADDR_EXP 28
1038: PUSH
1039: LD_STRING Gladstone
1041: PPUSH
1042: LD_EXP 1
1046: NOT
1047: PPUSH
1048: LD_EXP 4
1052: PPUSH
1053: CALL 47239 0 3
1057: ST_TO_ADDR
// if not Gladstone then
1058: LD_EXP 28
1062: NOT
1063: IFFALSE 1078
// Gladstone := CreateCharacter ( 10_Gladstone ) ;
1065: LD_ADDR_EXP 28
1069: PUSH
1070: LD_STRING 10_Gladstone
1072: PPUSH
1073: CALL_OW 34
1077: ST_TO_ADDR
// if not Gladstone then
1078: LD_EXP 28
1082: NOT
1083: IFFALSE 1098
// Gladstone := CreateCharacter ( 08_Gladstone ) ;
1085: LD_ADDR_EXP 28
1089: PUSH
1090: LD_STRING 08_Gladstone
1092: PPUSH
1093: CALL_OW 34
1097: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , mission_prefix_prev ) ;
1098: LD_ADDR_EXP 29
1102: PUSH
1103: LD_STRING Houten
1105: PPUSH
1106: LD_EXP 1
1110: NOT
1111: PPUSH
1112: LD_EXP 4
1116: PPUSH
1117: CALL 47239 0 3
1121: ST_TO_ADDR
// if not Houten then
1122: LD_EXP 29
1126: NOT
1127: IFFALSE 1142
// Houten := CreateCharacter ( 10_Houten ) ;
1129: LD_ADDR_EXP 29
1133: PUSH
1134: LD_STRING 10_Houten
1136: PPUSH
1137: CALL_OW 34
1141: ST_TO_ADDR
// if not Houten then
1142: LD_EXP 29
1146: NOT
1147: IFFALSE 1162
// Houten := CreateCharacter ( 09_Houten ) ;
1149: LD_ADDR_EXP 29
1153: PUSH
1154: LD_STRING 09_Houten
1156: PPUSH
1157: CALL_OW 34
1161: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , ( not debug ) , mission_prefix_prev ) ;
1162: LD_ADDR_EXP 31
1166: PUSH
1167: LD_STRING Cornell
1169: PPUSH
1170: LD_EXP 1
1174: NOT
1175: PPUSH
1176: LD_EXP 4
1180: PPUSH
1181: CALL 47239 0 3
1185: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , mission_prefix_prev ) ;
1186: LD_ADDR_EXP 32
1190: PUSH
1191: LD_STRING Gary
1193: PPUSH
1194: LD_EXP 1
1198: NOT
1199: PPUSH
1200: LD_EXP 4
1204: PPUSH
1205: CALL 47239 0 3
1209: ST_TO_ADDR
// if not Gary then
1210: LD_EXP 32
1214: NOT
1215: IFFALSE 1230
// Gary := CreateCharacter ( 10_Gary ) ;
1217: LD_ADDR_EXP 32
1221: PUSH
1222: LD_STRING 10_Gary
1224: PPUSH
1225: CALL_OW 34
1229: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , mission_prefix_prev ) ;
1230: LD_ADDR_EXP 33
1234: PUSH
1235: LD_STRING Frank
1237: PPUSH
1238: LD_EXP 1
1242: NOT
1243: PPUSH
1244: LD_EXP 4
1248: PPUSH
1249: CALL 47239 0 3
1253: ST_TO_ADDR
// if not Frank then
1254: LD_EXP 33
1258: NOT
1259: IFFALSE 1274
// Frank := CreateCharacter ( 08_Frank ) ;
1261: LD_ADDR_EXP 33
1265: PUSH
1266: LD_STRING 08_Frank
1268: PPUSH
1269: CALL_OW 34
1273: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , mission_prefix_prev ) ;
1274: LD_ADDR_EXP 34
1278: PUSH
1279: LD_STRING Kikuchi
1281: PPUSH
1282: LD_EXP 1
1286: NOT
1287: PPUSH
1288: LD_EXP 4
1292: PPUSH
1293: CALL 47239 0 3
1297: ST_TO_ADDR
// if not Kikuchi then
1298: LD_EXP 34
1302: NOT
1303: IFFALSE 1318
// Kikuchi := CreateCharacter ( 08_Kikuchi ) ;
1305: LD_ADDR_EXP 34
1309: PUSH
1310: LD_STRING 08_Kikuchi
1312: PPUSH
1313: CALL_OW 34
1317: ST_TO_ADDR
// tmp := [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1318: LD_ADDR_VAR 0 5
1322: PUSH
1323: LD_EXP 22
1327: PUSH
1328: LD_EXP 23
1332: PUSH
1333: LD_EXP 24
1337: PUSH
1338: LD_EXP 25
1342: PUSH
1343: LD_EXP 26
1347: PUSH
1348: LD_EXP 27
1352: PUSH
1353: LD_EXP 28
1357: PUSH
1358: LD_EXP 29
1362: PUSH
1363: LD_EXP 31
1367: PUSH
1368: LD_EXP 32
1372: PUSH
1373: LD_EXP 33
1377: PUSH
1378: LD_EXP 34
1382: PUSH
1383: EMPTY
1384: LIST
1385: LIST
1386: LIST
1387: LIST
1388: LIST
1389: LIST
1390: LIST
1391: LIST
1392: LIST
1393: LIST
1394: LIST
1395: LIST
1396: ST_TO_ADDR
// tmp := tmp diff 0 ;
1397: LD_ADDR_VAR 0 5
1401: PUSH
1402: LD_VAR 0 5
1406: PUSH
1407: LD_INT 0
1409: DIFF
1410: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10_lock ) ;
1411: LD_ADDR_VAR 0 5
1415: PUSH
1416: LD_VAR 0 5
1420: PUSH
1421: LD_STRING 10_lock
1423: PPUSH
1424: CALL_OW 31
1428: UNION
1429: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10c_lock ) ;
1430: LD_ADDR_VAR 0 5
1434: PUSH
1435: LD_VAR 0 5
1439: PUSH
1440: LD_STRING 10c_lock
1442: PPUSH
1443: CALL_OW 31
1447: UNION
1448: ST_TO_ADDR
// DeleteCharacters ( 10_lock ) ;
1449: LD_STRING 10_lock
1451: PPUSH
1452: CALL_OW 40
// DeleteCharacters ( 10c_lock ) ;
1456: LD_STRING 10c_lock
1458: PPUSH
1459: CALL_OW 40
// for i in tmp do
1463: LD_ADDR_VAR 0 2
1467: PUSH
1468: LD_VAR 0 5
1472: PUSH
1473: FOR_IN
1474: IFFALSE 1512
// if GetClass ( i ) in [ class_mortar , class_engineer ] then
1476: LD_VAR 0 2
1480: PPUSH
1481: CALL_OW 257
1485: PUSH
1486: LD_INT 8
1488: PUSH
1489: LD_INT 2
1491: PUSH
1492: EMPTY
1493: LIST
1494: LIST
1495: IN
1496: IFFALSE 1510
// SetClass ( i , class_soldier ) ;
1498: LD_VAR 0 2
1502: PPUSH
1503: LD_INT 1
1505: PPUSH
1506: CALL_OW 336
1510: GO 1473
1512: POP
1513: POP
// if tmp < 12 then
1514: LD_VAR 0 5
1518: PUSH
1519: LD_INT 12
1521: LESS
1522: IFFALSE 1616
// begin k := 16 - tmp ;
1524: LD_ADDR_VAR 0 3
1528: PUSH
1529: LD_INT 16
1531: PUSH
1532: LD_VAR 0 5
1536: MINUS
1537: ST_TO_ADDR
// for i = 1 to k do
1538: LD_ADDR_VAR 0 2
1542: PUSH
1543: DOUBLE
1544: LD_INT 1
1546: DEC
1547: ST_TO_ADDR
1548: LD_VAR 0 3
1552: PUSH
1553: FOR_TO
1554: IFFALSE 1614
// begin PrepareHuman ( false , [ 1 , 1 , 3 , 4 ] [ rand ( 1 , 4 ) ] , 6 ) ;
1556: LD_INT 0
1558: PPUSH
1559: LD_INT 1
1561: PUSH
1562: LD_INT 1
1564: PUSH
1565: LD_INT 3
1567: PUSH
1568: LD_INT 4
1570: PUSH
1571: EMPTY
1572: LIST
1573: LIST
1574: LIST
1575: LIST
1576: PUSH
1577: LD_INT 1
1579: PPUSH
1580: LD_INT 4
1582: PPUSH
1583: CALL_OW 12
1587: ARRAY
1588: PPUSH
1589: LD_INT 6
1591: PPUSH
1592: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
1596: LD_ADDR_VAR 0 5
1600: PUSH
1601: LD_VAR 0 5
1605: PUSH
1606: CALL_OW 44
1610: ADD
1611: ST_TO_ADDR
// end ;
1612: GO 1553
1614: POP
1615: POP
// end ; selected := CharacterSelection ( 1 , 12 , 12 , [ sel_change_class , JMM , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp ^ [ sel_dont_change_class , sel_not_changeable , Powell ] , [ [ class_soldier , 4 ] , [ class_mechanic , 0 , 5 ] , [ class_scientistic , 0 , 3 ] , [ class_sniper , 0 , 2 ] ] ) ;
1616: LD_ADDR_EXP 19
1620: PUSH
1621: LD_STRING 1
1623: PPUSH
1624: LD_INT 12
1626: PPUSH
1627: LD_INT 12
1629: PPUSH
1630: LD_INT -5
1632: PUSH
1633: LD_EXP 21
1637: PUSH
1638: LD_INT -2
1640: PUSH
1641: LD_INT -3
1643: PUSH
1644: LD_INT -5
1646: PUSH
1647: EMPTY
1648: LIST
1649: LIST
1650: LIST
1651: LIST
1652: LIST
1653: PUSH
1654: LD_VAR 0 5
1658: ADD
1659: PUSH
1660: LD_INT -6
1662: PUSH
1663: LD_INT -4
1665: PUSH
1666: LD_EXP 30
1670: PUSH
1671: EMPTY
1672: LIST
1673: LIST
1674: LIST
1675: ADD
1676: PPUSH
1677: LD_INT 1
1679: PUSH
1680: LD_INT 4
1682: PUSH
1683: EMPTY
1684: LIST
1685: LIST
1686: PUSH
1687: LD_INT 3
1689: PUSH
1690: LD_INT 0
1692: PUSH
1693: LD_INT 5
1695: PUSH
1696: EMPTY
1697: LIST
1698: LIST
1699: LIST
1700: PUSH
1701: LD_INT 4
1703: PUSH
1704: LD_INT 0
1706: PUSH
1707: LD_INT 3
1709: PUSH
1710: EMPTY
1711: LIST
1712: LIST
1713: LIST
1714: PUSH
1715: LD_INT 5
1717: PUSH
1718: LD_INT 0
1720: PUSH
1721: LD_INT 2
1723: PUSH
1724: EMPTY
1725: LIST
1726: LIST
1727: LIST
1728: PUSH
1729: EMPTY
1730: LIST
1731: LIST
1732: LIST
1733: LIST
1734: PPUSH
1735: CALL_OW 42
1739: ST_TO_ADDR
// others := tmp diff selected ;
1740: LD_ADDR_VAR 0 8
1744: PUSH
1745: LD_VAR 0 5
1749: PUSH
1750: LD_EXP 19
1754: DIFF
1755: ST_TO_ADDR
// others := others diff [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1756: LD_ADDR_VAR 0 8
1760: PUSH
1761: LD_VAR 0 8
1765: PUSH
1766: LD_EXP 22
1770: PUSH
1771: LD_EXP 23
1775: PUSH
1776: LD_EXP 24
1780: PUSH
1781: LD_EXP 25
1785: PUSH
1786: LD_EXP 26
1790: PUSH
1791: LD_EXP 27
1795: PUSH
1796: LD_EXP 28
1800: PUSH
1801: LD_EXP 29
1805: PUSH
1806: LD_EXP 31
1810: PUSH
1811: LD_EXP 32
1815: PUSH
1816: LD_EXP 33
1820: PUSH
1821: LD_EXP 34
1825: PUSH
1826: EMPTY
1827: LIST
1828: LIST
1829: LIST
1830: LIST
1831: LIST
1832: LIST
1833: LIST
1834: LIST
1835: LIST
1836: LIST
1837: LIST
1838: LIST
1839: DIFF
1840: ST_TO_ADDR
// if others then
1841: LD_VAR 0 8
1845: IFFALSE 1859
// SaveCharacters ( others , 11_others ) ;
1847: LD_VAR 0 8
1851: PPUSH
1852: LD_STRING 11_others
1854: PPUSH
1855: CALL_OW 38
// vehs := [ [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun ] , [ us_medium_wheeled , engine_solar , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_medium_wheeled , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_solar , control_manual , us_rocket_launcher ] ] ;
1859: LD_ADDR_VAR 0 6
1863: PUSH
1864: LD_INT 3
1866: PUSH
1867: LD_INT 1
1869: PUSH
1870: LD_INT 1
1872: PUSH
1873: LD_INT 4
1875: PUSH
1876: EMPTY
1877: LIST
1878: LIST
1879: LIST
1880: LIST
1881: PUSH
1882: LD_INT 2
1884: PUSH
1885: LD_INT 2
1887: PUSH
1888: LD_INT 1
1890: PUSH
1891: LD_INT 5
1893: PUSH
1894: EMPTY
1895: LIST
1896: LIST
1897: LIST
1898: LIST
1899: PUSH
1900: LD_INT 4
1902: PUSH
1903: LD_INT 1
1905: PUSH
1906: LD_INT 1
1908: PUSH
1909: LD_INT 5
1911: PUSH
1912: EMPTY
1913: LIST
1914: LIST
1915: LIST
1916: LIST
1917: PUSH
1918: LD_INT 2
1920: PUSH
1921: LD_INT 1
1923: PUSH
1924: LD_INT 1
1926: PUSH
1927: LD_INT 7
1929: PUSH
1930: EMPTY
1931: LIST
1932: LIST
1933: LIST
1934: LIST
1935: PUSH
1936: LD_INT 3
1938: PUSH
1939: LD_INT 2
1941: PUSH
1942: LD_INT 1
1944: PUSH
1945: LD_INT 7
1947: PUSH
1948: EMPTY
1949: LIST
1950: LIST
1951: LIST
1952: LIST
1953: PUSH
1954: EMPTY
1955: LIST
1956: LIST
1957: LIST
1958: LIST
1959: LIST
1960: ST_TO_ADDR
// for i in JMM ^ selected do
1961: LD_ADDR_VAR 0 2
1965: PUSH
1966: LD_EXP 21
1970: PUSH
1971: LD_EXP 19
1975: ADD
1976: PUSH
1977: FOR_IN
1978: IFFALSE 2167
// begin if GetClass ( i ) = 3 then
1980: LD_VAR 0 2
1984: PPUSH
1985: CALL_OW 257
1989: PUSH
1990: LD_INT 3
1992: EQUAL
1993: IFFALSE 2150
// begin vc_chassis := vehs [ 1 ] [ 1 ] ;
1995: LD_ADDR_OWVAR 37
1999: PUSH
2000: LD_VAR 0 6
2004: PUSH
2005: LD_INT 1
2007: ARRAY
2008: PUSH
2009: LD_INT 1
2011: ARRAY
2012: ST_TO_ADDR
// vc_engine := vehs [ 1 ] [ 2 ] ;
2013: LD_ADDR_OWVAR 39
2017: PUSH
2018: LD_VAR 0 6
2022: PUSH
2023: LD_INT 1
2025: ARRAY
2026: PUSH
2027: LD_INT 2
2029: ARRAY
2030: ST_TO_ADDR
// vc_control := vehs [ 1 ] [ 3 ] ;
2031: LD_ADDR_OWVAR 38
2035: PUSH
2036: LD_VAR 0 6
2040: PUSH
2041: LD_INT 1
2043: ARRAY
2044: PUSH
2045: LD_INT 3
2047: ARRAY
2048: ST_TO_ADDR
// vc_weapon := vehs [ 1 ] [ 4 ] ;
2049: LD_ADDR_OWVAR 40
2053: PUSH
2054: LD_VAR 0 6
2058: PUSH
2059: LD_INT 1
2061: ARRAY
2062: PUSH
2063: LD_INT 4
2065: ARRAY
2066: ST_TO_ADDR
// vehs := Delete ( vehs , 1 ) ;
2067: LD_ADDR_VAR 0 6
2071: PUSH
2072: LD_VAR 0 6
2076: PPUSH
2077: LD_INT 1
2079: PPUSH
2080: CALL_OW 3
2084: ST_TO_ADDR
// veh := CreateVehicle ;
2085: LD_ADDR_VAR 0 7
2089: PUSH
2090: CALL_OW 45
2094: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2095: LD_VAR 0 7
2099: PPUSH
2100: LD_INT 8
2102: PPUSH
2103: LD_INT 0
2105: PPUSH
2106: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
2110: LD_VAR 0 2
2114: PPUSH
2115: LD_VAR 0 7
2119: PPUSH
2120: CALL_OW 52
// if i = JMM then
2124: LD_VAR 0 2
2128: PUSH
2129: LD_EXP 21
2133: EQUAL
2134: IFFALSE 2148
// SetMark ( veh , 1 ) ;
2136: LD_VAR 0 7
2140: PPUSH
2141: LD_INT 1
2143: PPUSH
2144: CALL_OW 242
// end else
2148: GO 2165
// PlaceUnitArea ( i , am_hum_start , false ) ;
2150: LD_VAR 0 2
2154: PPUSH
2155: LD_INT 9
2157: PPUSH
2158: LD_INT 0
2160: PPUSH
2161: CALL_OW 49
// end ;
2165: GO 1977
2167: POP
2168: POP
// vc_chassis := us_medium_tracked ;
2169: LD_ADDR_OWVAR 37
2173: PUSH
2174: LD_INT 3
2176: ST_TO_ADDR
// vc_engine := engine_solar ;
2177: LD_ADDR_OWVAR 39
2181: PUSH
2182: LD_INT 2
2184: ST_TO_ADDR
// vc_control := control_computer ;
2185: LD_ADDR_OWVAR 38
2189: PUSH
2190: LD_INT 3
2192: ST_TO_ADDR
// vc_weapon := us_radar ;
2193: LD_ADDR_OWVAR 40
2197: PUSH
2198: LD_INT 11
2200: ST_TO_ADDR
// veh := CreateVehicle ;
2201: LD_ADDR_VAR 0 7
2205: PUSH
2206: CALL_OW 45
2210: ST_TO_ADDR
// PlaceUnitXY ( veh , 87 , 142 , false ) ;
2211: LD_VAR 0 7
2215: PPUSH
2216: LD_INT 87
2218: PPUSH
2219: LD_INT 142
2221: PPUSH
2222: LD_INT 0
2224: PPUSH
2225: CALL_OW 48
// end ; end_of_file
2229: LD_VAR 0 1
2233: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_north_2 , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_kamikadze , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ; var i , d , un , skill , tmp ; begin
2234: LD_INT 0
2236: PPUSH
2237: PPUSH
2238: PPUSH
2239: PPUSH
2240: PPUSH
2241: PPUSH
// if Difficulty = 1 then
2242: LD_OWVAR 67
2246: PUSH
2247: LD_INT 1
2249: EQUAL
2250: IFFALSE 2347
// begin tmp := [ [ 129 , 45 ] , [ 143 , 58 ] , [ 184 , 113 ] , [ 163 , 107 ] ] ;
2252: LD_ADDR_VAR 0 6
2256: PUSH
2257: LD_INT 129
2259: PUSH
2260: LD_INT 45
2262: PUSH
2263: EMPTY
2264: LIST
2265: LIST
2266: PUSH
2267: LD_INT 143
2269: PUSH
2270: LD_INT 58
2272: PUSH
2273: EMPTY
2274: LIST
2275: LIST
2276: PUSH
2277: LD_INT 184
2279: PUSH
2280: LD_INT 113
2282: PUSH
2283: EMPTY
2284: LIST
2285: LIST
2286: PUSH
2287: LD_INT 163
2289: PUSH
2290: LD_INT 107
2292: PUSH
2293: EMPTY
2294: LIST
2295: LIST
2296: PUSH
2297: EMPTY
2298: LIST
2299: LIST
2300: LIST
2301: LIST
2302: ST_TO_ADDR
// for i in tmp do
2303: LD_ADDR_VAR 0 2
2307: PUSH
2308: LD_VAR 0 6
2312: PUSH
2313: FOR_IN
2314: IFFALSE 2345
// RemoveUnit ( HexInfo ( i [ 1 ] , i [ 2 ] ) ) ;
2316: LD_VAR 0 2
2320: PUSH
2321: LD_INT 1
2323: ARRAY
2324: PPUSH
2325: LD_VAR 0 2
2329: PUSH
2330: LD_INT 2
2332: ARRAY
2333: PPUSH
2334: CALL_OW 428
2338: PPUSH
2339: CALL_OW 64
2343: GO 2313
2345: POP
2346: POP
// end ; skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
2347: LD_ADDR_VAR 0 5
2351: PUSH
2352: LD_INT 5
2354: PUSH
2355: LD_INT 6
2357: PUSH
2358: LD_INT 7
2360: PUSH
2361: EMPTY
2362: LIST
2363: LIST
2364: LIST
2365: PUSH
2366: LD_OWVAR 67
2370: ARRAY
2371: ST_TO_ADDR
// uc_side := 2 ;
2372: LD_ADDR_OWVAR 20
2376: PUSH
2377: LD_INT 2
2379: ST_TO_ADDR
// uc_nation := 2 ;
2380: LD_ADDR_OWVAR 21
2384: PUSH
2385: LD_INT 2
2387: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
2388: LD_ADDR_OWVAR 37
2392: PUSH
2393: LD_INT 14
2395: ST_TO_ADDR
// vc_engine := engine_siberite ;
2396: LD_ADDR_OWVAR 39
2400: PUSH
2401: LD_INT 3
2403: ST_TO_ADDR
// vc_control := control_manual ;
2404: LD_ADDR_OWVAR 38
2408: PUSH
2409: LD_INT 1
2411: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
2412: LD_ADDR_OWVAR 40
2416: PUSH
2417: LD_INT 31
2419: ST_TO_ADDR
// for i = 1 to 3 do
2420: LD_ADDR_VAR 0 2
2424: PUSH
2425: DOUBLE
2426: LD_INT 1
2428: DEC
2429: ST_TO_ADDR
2430: LD_INT 3
2432: PUSH
2433: FOR_TO
2434: IFFALSE 2518
// begin PrepareHuman ( false , class_mechanic , skill ) ;
2436: LD_INT 0
2438: PPUSH
2439: LD_INT 3
2441: PPUSH
2442: LD_VAR 0 5
2446: PPUSH
2447: CALL_OW 380
// un := CreateVehicle ;
2451: LD_ADDR_VAR 0 4
2455: PUSH
2456: CALL_OW 45
2460: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
2461: LD_VAR 0 4
2465: PPUSH
2466: LD_INT 0
2468: PPUSH
2469: LD_INT 5
2471: PPUSH
2472: CALL_OW 12
2476: PPUSH
2477: CALL_OW 233
// PlaceUnitXYR ( un , 156 , 15 , 6 , false ) ;
2481: LD_VAR 0 4
2485: PPUSH
2486: LD_INT 156
2488: PPUSH
2489: LD_INT 15
2491: PPUSH
2492: LD_INT 6
2494: PPUSH
2495: LD_INT 0
2497: PPUSH
2498: CALL_OW 50
// PlaceHumanInUnit ( CreateHuman , un ) ;
2502: CALL_OW 44
2506: PPUSH
2507: LD_VAR 0 4
2511: PPUSH
2512: CALL_OW 52
// end ;
2516: GO 2433
2518: POP
2519: POP
// ar_force_north := PrepareBase ( ar_dep_n , base_north , dammam , skill , [ 10000 , 1000 , 300 ] , [ - 1 , [ 3 , 4 , 5 ] [ Difficulty ] , - 1 , 4 ] ) ;
2520: LD_ADDR_EXP 37
2524: PUSH
2525: LD_INT 94
2527: PPUSH
2528: LD_INT 28
2530: PPUSH
2531: LD_STRING dammam
2533: PPUSH
2534: LD_VAR 0 5
2538: PPUSH
2539: LD_INT 10000
2541: PUSH
2542: LD_INT 1000
2544: PUSH
2545: LD_INT 300
2547: PUSH
2548: EMPTY
2549: LIST
2550: LIST
2551: LIST
2552: PPUSH
2553: LD_INT 1
2555: NEG
2556: PUSH
2557: LD_INT 3
2559: PUSH
2560: LD_INT 4
2562: PUSH
2563: LD_INT 5
2565: PUSH
2566: EMPTY
2567: LIST
2568: LIST
2569: LIST
2570: PUSH
2571: LD_OWVAR 67
2575: ARRAY
2576: PUSH
2577: LD_INT 1
2579: NEG
2580: PUSH
2581: LD_INT 4
2583: PUSH
2584: EMPTY
2585: LIST
2586: LIST
2587: LIST
2588: LIST
2589: PPUSH
2590: CALL 57674 0 6
2594: ST_TO_ADDR
// ar_force_north := ar_force_north union PrepareBase ( ar_dep_n2 , base_north_2 ,  , skill , [ 500 , 60 , 0 ] , [ - 1 , [ 3 , 3 , 4 ] [ Difficulty ] , 2 , 0 ] ) ;
2595: LD_ADDR_EXP 37
2599: PUSH
2600: LD_EXP 37
2604: PUSH
2605: LD_INT 122
2607: PPUSH
2608: LD_INT 25
2610: PPUSH
2611: LD_STRING 
2613: PPUSH
2614: LD_VAR 0 5
2618: PPUSH
2619: LD_INT 500
2621: PUSH
2622: LD_INT 60
2624: PUSH
2625: LD_INT 0
2627: PUSH
2628: EMPTY
2629: LIST
2630: LIST
2631: LIST
2632: PPUSH
2633: LD_INT 1
2635: NEG
2636: PUSH
2637: LD_INT 3
2639: PUSH
2640: LD_INT 3
2642: PUSH
2643: LD_INT 4
2645: PUSH
2646: EMPTY
2647: LIST
2648: LIST
2649: LIST
2650: PUSH
2651: LD_OWVAR 67
2655: ARRAY
2656: PUSH
2657: LD_INT 2
2659: PUSH
2660: LD_INT 0
2662: PUSH
2663: EMPTY
2664: LIST
2665: LIST
2666: LIST
2667: LIST
2668: PPUSH
2669: CALL 57674 0 6
2673: UNION
2674: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , base_west , jeddah , skill , [ 700 , 300 , 10 ] , [ - 1 , 5 , 3 , 2 ] ) ;
2675: LD_ADDR_EXP 35
2679: PUSH
2680: LD_INT 45
2682: PPUSH
2683: LD_INT 24
2685: PPUSH
2686: LD_STRING jeddah
2688: PPUSH
2689: LD_VAR 0 5
2693: PPUSH
2694: LD_INT 700
2696: PUSH
2697: LD_INT 300
2699: PUSH
2700: LD_INT 10
2702: PUSH
2703: EMPTY
2704: LIST
2705: LIST
2706: LIST
2707: PPUSH
2708: LD_INT 1
2710: NEG
2711: PUSH
2712: LD_INT 5
2714: PUSH
2715: LD_INT 3
2717: PUSH
2718: LD_INT 2
2720: PUSH
2721: EMPTY
2722: LIST
2723: LIST
2724: LIST
2725: LIST
2726: PPUSH
2727: CALL 57674 0 6
2731: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , base_south , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
2732: LD_ADDR_EXP 36
2736: PUSH
2737: LD_INT 7
2739: PPUSH
2740: LD_INT 27
2742: PPUSH
2743: LD_STRING riyadh
2745: PPUSH
2746: LD_VAR 0 5
2750: PPUSH
2751: LD_INT 500
2753: PUSH
2754: LD_INT 60
2756: PUSH
2757: LD_INT 0
2759: PUSH
2760: EMPTY
2761: LIST
2762: LIST
2763: LIST
2764: PPUSH
2765: LD_INT 4
2767: PUSH
2768: LD_INT 2
2770: PUSH
2771: LD_INT 3
2773: PUSH
2774: LD_INT 1
2776: PUSH
2777: EMPTY
2778: LIST
2779: LIST
2780: LIST
2781: LIST
2782: PPUSH
2783: CALL 57674 0 6
2787: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e , base_east ,  , skill , [ 500 , 50 , 0 ] , [ - 1 , 3 , 3 , 2 ] ) ;
2788: LD_ADDR_EXP 39
2792: PUSH
2793: LD_INT 204
2795: PPUSH
2796: LD_INT 26
2798: PPUSH
2799: LD_STRING 
2801: PPUSH
2802: LD_VAR 0 5
2806: PPUSH
2807: LD_INT 500
2809: PUSH
2810: LD_INT 50
2812: PUSH
2813: LD_INT 0
2815: PUSH
2816: EMPTY
2817: LIST
2818: LIST
2819: LIST
2820: PPUSH
2821: LD_INT 1
2823: NEG
2824: PUSH
2825: LD_INT 3
2827: PUSH
2828: LD_INT 3
2830: PUSH
2831: LD_INT 2
2833: PUSH
2834: EMPTY
2835: LIST
2836: LIST
2837: LIST
2838: LIST
2839: PPUSH
2840: CALL 57674 0 6
2844: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east ] ;
2845: LD_ADDR_EXP 50
2849: PUSH
2850: LD_EXP 37
2854: PUSH
2855: LD_EXP 35
2859: PUSH
2860: LD_EXP 39
2864: PUSH
2865: EMPTY
2866: LIST
2867: LIST
2868: LIST
2869: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
2870: LD_ADDR_VAR 0 2
2874: PUSH
2875: LD_INT 22
2877: PUSH
2878: LD_INT 2
2880: PUSH
2881: EMPTY
2882: LIST
2883: LIST
2884: PUSH
2885: LD_INT 30
2887: PUSH
2888: LD_INT 31
2890: PUSH
2891: EMPTY
2892: LIST
2893: LIST
2894: PUSH
2895: LD_INT 58
2897: PUSH
2898: EMPTY
2899: LIST
2900: PUSH
2901: EMPTY
2902: LIST
2903: LIST
2904: LIST
2905: PPUSH
2906: CALL_OW 69
2910: PUSH
2911: FOR_IN
2912: IFFALSE 3037
// begin if GetBase ( i ) then
2914: LD_VAR 0 2
2918: PPUSH
2919: CALL_OW 274
2923: IFFALSE 2927
// continue ;
2925: GO 2911
// d := GetDir ( i ) ;
2927: LD_ADDR_VAR 0 3
2931: PUSH
2932: LD_VAR 0 2
2936: PPUSH
2937: CALL_OW 254
2941: ST_TO_ADDR
// if d < 3 then
2942: LD_VAR 0 3
2946: PUSH
2947: LD_INT 3
2949: LESS
2950: IFFALSE 2968
// d := d + 3 else
2952: LD_ADDR_VAR 0 3
2956: PUSH
2957: LD_VAR 0 3
2961: PUSH
2962: LD_INT 3
2964: PLUS
2965: ST_TO_ADDR
2966: GO 2982
// d := d - 3 ;
2968: LD_ADDR_VAR 0 3
2972: PUSH
2973: LD_VAR 0 3
2977: PUSH
2978: LD_INT 3
2980: MINUS
2981: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
2982: LD_INT 0
2984: PPUSH
2985: LD_INT 8
2987: PPUSH
2988: LD_VAR 0 5
2992: PPUSH
2993: CALL_OW 380
// un := CreateHuman ;
2997: LD_ADDR_VAR 0 4
3001: PUSH
3002: CALL_OW 44
3006: ST_TO_ADDR
// SetDir ( un , d ) ;
3007: LD_VAR 0 4
3011: PPUSH
3012: LD_VAR 0 3
3016: PPUSH
3017: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
3021: LD_VAR 0 4
3025: PPUSH
3026: LD_VAR 0 2
3030: PPUSH
3031: CALL_OW 52
// end ;
3035: GO 2911
3037: POP
3038: POP
// if Difficulty > 1 then
3039: LD_OWVAR 67
3043: PUSH
3044: LD_INT 1
3046: GREATER
3047: IFFALSE 3418
// begin ar_kamikadze := [ ] ;
3049: LD_ADDR_EXP 42
3053: PUSH
3054: EMPTY
3055: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
3056: LD_INT 0
3058: PPUSH
3059: LD_INT 1
3061: PPUSH
3062: LD_VAR 0 5
3066: PPUSH
3067: CALL_OW 380
// un := CreateHuman ;
3071: LD_ADDR_VAR 0 4
3075: PUSH
3076: CALL_OW 44
3080: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3081: LD_VAR 0 4
3085: PPUSH
3086: LD_INT 3
3088: PPUSH
3089: CALL_OW 233
// PlaceUnitXY ( un , 23 , 44 , false ) ;
3093: LD_VAR 0 4
3097: PPUSH
3098: LD_INT 23
3100: PPUSH
3101: LD_INT 44
3103: PPUSH
3104: LD_INT 0
3106: PPUSH
3107: CALL_OW 48
// ComCrawl ( un ) ;
3111: LD_VAR 0 4
3115: PPUSH
3116: CALL_OW 137
// un := CreateHuman ;
3120: LD_ADDR_VAR 0 4
3124: PUSH
3125: CALL_OW 44
3129: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3130: LD_VAR 0 4
3134: PPUSH
3135: LD_INT 3
3137: PPUSH
3138: CALL_OW 233
// PlaceUnitXY ( un , 30 , 39 , false ) ;
3142: LD_VAR 0 4
3146: PPUSH
3147: LD_INT 30
3149: PPUSH
3150: LD_INT 39
3152: PPUSH
3153: LD_INT 0
3155: PPUSH
3156: CALL_OW 48
// ComCrawl ( un ) ;
3160: LD_VAR 0 4
3164: PPUSH
3165: CALL_OW 137
// PrepareHuman ( false , 17 , skill ) ;
3169: LD_INT 0
3171: PPUSH
3172: LD_INT 17
3174: PPUSH
3175: LD_VAR 0 5
3179: PPUSH
3180: CALL_OW 380
// un := CreateHuman ;
3184: LD_ADDR_VAR 0 4
3188: PUSH
3189: CALL_OW 44
3193: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3194: LD_VAR 0 4
3198: PPUSH
3199: LD_INT 3
3201: PPUSH
3202: CALL_OW 233
// PlaceUnitXY ( un , 45 , 86 , false ) ;
3206: LD_VAR 0 4
3210: PPUSH
3211: LD_INT 45
3213: PPUSH
3214: LD_INT 86
3216: PPUSH
3217: LD_INT 0
3219: PPUSH
3220: CALL_OW 48
// ComHold ( un ) ;
3224: LD_VAR 0 4
3228: PPUSH
3229: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3233: LD_ADDR_EXP 42
3237: PUSH
3238: LD_EXP 42
3242: PPUSH
3243: LD_EXP 42
3247: PUSH
3248: LD_INT 1
3250: PLUS
3251: PPUSH
3252: LD_VAR 0 4
3256: PPUSH
3257: CALL_OW 1
3261: ST_TO_ADDR
// un := CreateHuman ;
3262: LD_ADDR_VAR 0 4
3266: PUSH
3267: CALL_OW 44
3271: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3272: LD_VAR 0 4
3276: PPUSH
3277: LD_INT 3
3279: PPUSH
3280: CALL_OW 233
// PlaceUnitXY ( un , 60 , 85 , false ) ;
3284: LD_VAR 0 4
3288: PPUSH
3289: LD_INT 60
3291: PPUSH
3292: LD_INT 85
3294: PPUSH
3295: LD_INT 0
3297: PPUSH
3298: CALL_OW 48
// ComHold ( un ) ;
3302: LD_VAR 0 4
3306: PPUSH
3307: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3311: LD_ADDR_EXP 42
3315: PUSH
3316: LD_EXP 42
3320: PPUSH
3321: LD_EXP 42
3325: PUSH
3326: LD_INT 1
3328: PLUS
3329: PPUSH
3330: LD_VAR 0 4
3334: PPUSH
3335: CALL_OW 1
3339: ST_TO_ADDR
// un := CreateHuman ;
3340: LD_ADDR_VAR 0 4
3344: PUSH
3345: CALL_OW 44
3349: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3350: LD_VAR 0 4
3354: PPUSH
3355: LD_INT 3
3357: PPUSH
3358: CALL_OW 233
// PlaceUnitXY ( un , 222 , 166 , false ) ;
3362: LD_VAR 0 4
3366: PPUSH
3367: LD_INT 222
3369: PPUSH
3370: LD_INT 166
3372: PPUSH
3373: LD_INT 0
3375: PPUSH
3376: CALL_OW 48
// ComHold ( un ) ;
3380: LD_VAR 0 4
3384: PPUSH
3385: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3389: LD_ADDR_EXP 42
3393: PUSH
3394: LD_EXP 42
3398: PPUSH
3399: LD_EXP 42
3403: PUSH
3404: LD_INT 1
3406: PLUS
3407: PPUSH
3408: LD_VAR 0 4
3412: PPUSH
3413: CALL_OW 1
3417: ST_TO_ADDR
// end ; ar_force_tmp := [ ] ;
3418: LD_ADDR_EXP 40
3422: PUSH
3423: EMPTY
3424: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
3425: LD_INT 1
3427: PPUSH
3428: LD_INT 1
3430: PPUSH
3431: LD_VAR 0 5
3435: PPUSH
3436: CALL_OW 380
// hc_name := Pavel Grigorovic ;
3440: LD_ADDR_OWVAR 26
3444: PUSH
3445: LD_STRING Pavel Grigorovic
3447: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3448: LD_ADDR_OWVAR 33
3452: PUSH
3453: LD_STRING SecondCharsGal
3455: ST_TO_ADDR
// hc_face_number := 4 ;
3456: LD_ADDR_OWVAR 34
3460: PUSH
3461: LD_INT 4
3463: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
3464: LD_ADDR_EXP 40
3468: PUSH
3469: LD_EXP 40
3473: PPUSH
3474: LD_INT 1
3476: PPUSH
3477: CALL_OW 44
3481: PPUSH
3482: CALL_OW 1
3486: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , skill ) ;
3487: LD_INT 2
3489: PPUSH
3490: LD_INT 4
3492: PPUSH
3493: LD_VAR 0 5
3497: PPUSH
3498: CALL_OW 380
// hc_name := Lucy Sebel ;
3502: LD_ADDR_OWVAR 26
3506: PUSH
3507: LD_STRING Lucy Sebel
3509: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3510: LD_ADDR_OWVAR 33
3514: PUSH
3515: LD_STRING SecondCharsGal
3517: ST_TO_ADDR
// hc_face_number := 15 ;
3518: LD_ADDR_OWVAR 34
3522: PUSH
3523: LD_INT 15
3525: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
3526: LD_ADDR_EXP 40
3530: PUSH
3531: LD_EXP 40
3535: PPUSH
3536: LD_INT 2
3538: PPUSH
3539: CALL_OW 44
3543: PPUSH
3544: CALL_OW 1
3548: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , skill ) ;
3549: LD_INT 2
3551: PPUSH
3552: LD_INT 4
3554: PPUSH
3555: LD_VAR 0 5
3559: PPUSH
3560: CALL_OW 380
// hc_gallery :=  ;
3564: LD_ADDR_OWVAR 33
3568: PUSH
3569: LD_STRING 
3571: ST_TO_ADDR
// hc_name :=  ;
3572: LD_ADDR_OWVAR 26
3576: PUSH
3577: LD_STRING 
3579: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
3580: LD_ADDR_EXP 40
3584: PUSH
3585: LD_EXP 40
3589: PPUSH
3590: LD_INT 3
3592: PPUSH
3593: CALL_OW 44
3597: PPUSH
3598: CALL_OW 1
3602: ST_TO_ADDR
// hc_sex := sex_male ;
3603: LD_ADDR_OWVAR 27
3607: PUSH
3608: LD_INT 1
3610: ST_TO_ADDR
// hc_class = 11 ;
3611: LD_ADDR_OWVAR 28
3615: PUSH
3616: LD_INT 11
3618: ST_TO_ADDR
// hc_gallery = sandar ;
3619: LD_ADDR_OWVAR 33
3623: PUSH
3624: LD_STRING sandar
3626: ST_TO_ADDR
// hc_face_number = 33 ;
3627: LD_ADDR_OWVAR 34
3631: PUSH
3632: LD_INT 33
3634: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
3635: LD_ADDR_OWVAR 26
3639: PUSH
3640: LD_STRING Thabit Muhair Saliba
3642: ST_TO_ADDR
// hc_skills = [ 0 , 0 , 0 , 0 ] ;
3643: LD_ADDR_OWVAR 31
3647: PUSH
3648: LD_INT 0
3650: PUSH
3651: LD_INT 0
3653: PUSH
3654: LD_INT 0
3656: PUSH
3657: LD_INT 0
3659: PUSH
3660: EMPTY
3661: LIST
3662: LIST
3663: LIST
3664: LIST
3665: ST_TO_ADDR
// Saliba = CreateHuman ;
3666: LD_ADDR_EXP 44
3670: PUSH
3671: CALL_OW 44
3675: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
3676: LD_EXP 44
3680: PPUSH
3681: LD_INT 7
3683: PPUSH
3684: CALL_OW 52
// if gensher_active then
3688: LD_EXP 18
3692: IFFALSE 3719
// begin Gensher = NewCharacter ( Dietrich ) ;
3694: LD_ADDR_EXP 45
3698: PUSH
3699: LD_STRING Dietrich
3701: PPUSH
3702: CALL_OW 25
3706: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
3707: LD_EXP 45
3711: PPUSH
3712: LD_INT 94
3714: PPUSH
3715: CALL_OW 52
// end ; InitHc ;
3719: CALL_OW 19
// ar_vehicles_tmp := [ ] ;
3723: LD_ADDR_EXP 41
3727: PUSH
3728: EMPTY
3729: ST_TO_ADDR
// for i = 1 to 5 do
3730: LD_ADDR_VAR 0 2
3734: PUSH
3735: DOUBLE
3736: LD_INT 1
3738: DEC
3739: ST_TO_ADDR
3740: LD_INT 5
3742: PUSH
3743: FOR_TO
3744: IFFALSE 3916
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , [ engine_combustion , engine_solar ] [ rand ( 1 , 2 ) ] , control_manual , [ ar_gatling_gun , ar_gun , ar_flame_thrower ] [ rand ( 1 , 3 ) ] , rand ( 60 , 100 ) ) ;
3746: LD_INT 13
3748: PUSH
3749: LD_INT 14
3751: PUSH
3752: EMPTY
3753: LIST
3754: LIST
3755: PUSH
3756: LD_INT 1
3758: PPUSH
3759: LD_INT 2
3761: PPUSH
3762: CALL_OW 12
3766: ARRAY
3767: PPUSH
3768: LD_INT 1
3770: PUSH
3771: LD_INT 2
3773: PUSH
3774: EMPTY
3775: LIST
3776: LIST
3777: PUSH
3778: LD_INT 1
3780: PPUSH
3781: LD_INT 2
3783: PPUSH
3784: CALL_OW 12
3788: ARRAY
3789: PPUSH
3790: LD_INT 1
3792: PPUSH
3793: LD_INT 25
3795: PUSH
3796: LD_INT 27
3798: PUSH
3799: LD_INT 26
3801: PUSH
3802: EMPTY
3803: LIST
3804: LIST
3805: LIST
3806: PUSH
3807: LD_INT 1
3809: PPUSH
3810: LD_INT 3
3812: PPUSH
3813: CALL_OW 12
3817: ARRAY
3818: PPUSH
3819: LD_INT 60
3821: PPUSH
3822: LD_INT 100
3824: PPUSH
3825: CALL_OW 12
3829: PPUSH
3830: CALL 54265 0 5
// un := CreateVehicle ;
3834: LD_ADDR_VAR 0 4
3838: PUSH
3839: CALL_OW 45
3843: ST_TO_ADDR
// ar_vehicles_tmp := Replace ( ar_vehicles_tmp , ar_vehicles_tmp + 1 , un ) ;
3844: LD_ADDR_EXP 41
3848: PUSH
3849: LD_EXP 41
3853: PPUSH
3854: LD_EXP 41
3858: PUSH
3859: LD_INT 1
3861: PLUS
3862: PPUSH
3863: LD_VAR 0 4
3867: PPUSH
3868: CALL_OW 1
3872: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
3873: LD_VAR 0 4
3877: PPUSH
3878: LD_INT 0
3880: PPUSH
3881: LD_INT 5
3883: PPUSH
3884: CALL_OW 12
3888: PPUSH
3889: CALL_OW 233
// PlaceUnitXYR ( un , 124 , 141 , 8 , false ) ;
3893: LD_VAR 0 4
3897: PPUSH
3898: LD_INT 124
3900: PPUSH
3901: LD_INT 141
3903: PPUSH
3904: LD_INT 8
3906: PPUSH
3907: LD_INT 0
3909: PPUSH
3910: CALL_OW 50
// end ;
3914: GO 3743
3916: POP
3917: POP
// ar_defenders_tmp := [ [ ] , [ ] , [ ] ] ;
3918: LD_ADDR_EXP 43
3922: PUSH
3923: EMPTY
3924: PUSH
3925: EMPTY
3926: PUSH
3927: EMPTY
3928: PUSH
3929: EMPTY
3930: LIST
3931: LIST
3932: LIST
3933: ST_TO_ADDR
// for d = 1 to [ 3 , 3 , 4 ] [ Difficulty ] do
3934: LD_ADDR_VAR 0 3
3938: PUSH
3939: DOUBLE
3940: LD_INT 1
3942: DEC
3943: ST_TO_ADDR
3944: LD_INT 3
3946: PUSH
3947: LD_INT 3
3949: PUSH
3950: LD_INT 4
3952: PUSH
3953: EMPTY
3954: LIST
3955: LIST
3956: LIST
3957: PUSH
3958: LD_OWVAR 67
3962: ARRAY
3963: PUSH
3964: FOR_TO
3965: IFFALSE 4179
// for i = 1 to 3 do
3967: LD_ADDR_VAR 0 2
3971: PUSH
3972: DOUBLE
3973: LD_INT 1
3975: DEC
3976: ST_TO_ADDR
3977: LD_INT 3
3979: PUSH
3980: FOR_TO
3981: IFFALSE 4175
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
3983: LD_INT 14
3985: PPUSH
3986: LD_INT 3
3988: PUSH
3989: LD_INT 2
3991: PUSH
3992: EMPTY
3993: LIST
3994: LIST
3995: PUSH
3996: LD_INT 1
3998: PPUSH
3999: LD_INT 2
4001: PPUSH
4002: CALL_OW 12
4006: ARRAY
4007: PPUSH
4008: LD_INT 1
4010: PUSH
4011: LD_INT 5
4013: PUSH
4014: EMPTY
4015: LIST
4016: LIST
4017: PUSH
4018: LD_INT 1
4020: PPUSH
4021: LD_INT 2
4023: PPUSH
4024: CALL_OW 12
4028: ARRAY
4029: PPUSH
4030: LD_INT 25
4032: PUSH
4033: LD_INT 27
4035: PUSH
4036: LD_INT 26
4038: PUSH
4039: LD_INT 28
4041: PUSH
4042: EMPTY
4043: LIST
4044: LIST
4045: LIST
4046: LIST
4047: PUSH
4048: LD_INT 1
4050: PPUSH
4051: LD_INT 4
4053: PPUSH
4054: CALL_OW 12
4058: ARRAY
4059: PPUSH
4060: LD_INT 100
4062: PPUSH
4063: CALL 54265 0 5
// un := CreateVehicle ;
4067: LD_ADDR_VAR 0 4
4071: PUSH
4072: CALL_OW 45
4076: ST_TO_ADDR
// ar_defenders_tmp := ReplaceIn ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
4077: LD_ADDR_EXP 43
4081: PUSH
4082: LD_EXP 43
4086: PPUSH
4087: LD_VAR 0 2
4091: PUSH
4092: LD_EXP 43
4096: PUSH
4097: LD_VAR 0 2
4101: ARRAY
4102: PUSH
4103: LD_INT 1
4105: PLUS
4106: PUSH
4107: EMPTY
4108: LIST
4109: LIST
4110: PPUSH
4111: LD_VAR 0 4
4115: PPUSH
4116: CALL 54387 0 3
4120: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4121: LD_VAR 0 4
4125: PPUSH
4126: LD_INT 0
4128: PPUSH
4129: LD_INT 5
4131: PPUSH
4132: CALL_OW 12
4136: PPUSH
4137: CALL_OW 233
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east ] [ i ] , false ) ;
4141: LD_VAR 0 4
4145: PPUSH
4146: LD_INT 20
4148: PUSH
4149: LD_INT 21
4151: PUSH
4152: LD_INT 22
4154: PUSH
4155: EMPTY
4156: LIST
4157: LIST
4158: LIST
4159: PUSH
4160: LD_VAR 0 2
4164: ARRAY
4165: PPUSH
4166: LD_INT 0
4168: PPUSH
4169: CALL_OW 49
// end ;
4173: GO 3980
4175: POP
4176: POP
4177: GO 3964
4179: POP
4180: POP
// InitHc ;
4181: CALL_OW 19
// CreateResourcesXY ( mat_artifact , 5 , 10 , 5 , false ) ;
4185: LD_INT 4
4187: PPUSH
4188: LD_INT 5
4190: PPUSH
4191: LD_INT 10
4193: PPUSH
4194: LD_INT 5
4196: PPUSH
4197: LD_INT 0
4199: PPUSH
4200: CALL_OW 58
// end ;
4204: LD_VAR 0 1
4208: RET
// every 0 0$1 trigger ar_kamikadze do var i ;
4209: LD_EXP 42
4213: IFFALSE 4287
4215: GO 4217
4217: DISABLE
4218: LD_INT 0
4220: PPUSH
// begin enable ;
4221: ENABLE
// for i in ar_kamikadze do
4222: LD_ADDR_VAR 0 1
4226: PUSH
4227: LD_EXP 42
4231: PUSH
4232: FOR_IN
4233: IFFALSE 4285
// if See ( 1 , i ) then
4235: LD_INT 1
4237: PPUSH
4238: LD_VAR 0 1
4242: PPUSH
4243: CALL_OW 292
4247: IFFALSE 4283
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
4249: LD_VAR 0 1
4253: PPUSH
4254: LD_INT 81
4256: PUSH
4257: LD_INT 2
4259: PUSH
4260: EMPTY
4261: LIST
4262: LIST
4263: PPUSH
4264: CALL_OW 69
4268: PPUSH
4269: LD_VAR 0 1
4273: PPUSH
4274: CALL_OW 74
4278: PPUSH
4279: CALL_OW 115
4283: GO 4232
4285: POP
4286: POP
// end ;
4287: PPOPN 1
4289: END
// every 5 5$20 trigger artifact_get do var i , cargo , tmp , pos ;
4290: LD_EXP 13
4294: IFFALSE 4611
4296: GO 4298
4298: DISABLE
4299: LD_INT 0
4301: PPUSH
4302: PPUSH
4303: PPUSH
4304: PPUSH
// begin repeat wait ( 0 0$1 ) ;
4305: LD_INT 35
4307: PPUSH
4308: CALL_OW 67
// until MC_GetProduceList ( 1 ) = 0 ;
4312: LD_INT 1
4314: PPUSH
4315: CALL 41243 0 1
4319: PUSH
4320: LD_INT 0
4322: EQUAL
4323: IFFALSE 4305
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
4325: LD_INT 1
4327: PPUSH
4328: LD_INT 14
4330: PUSH
4331: LD_INT 3
4333: PUSH
4334: LD_INT 2
4336: PUSH
4337: LD_INT 32
4339: PUSH
4340: EMPTY
4341: LIST
4342: LIST
4343: LIST
4344: LIST
4345: PUSH
4346: EMPTY
4347: LIST
4348: PPUSH
4349: CALL 40847 0 2
// repeat wait ( 0 0$1 ) ;
4353: LD_INT 35
4355: PPUSH
4356: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) ;
4360: LD_EXP 69
4364: PUSH
4365: LD_INT 1
4367: ARRAY
4368: PPUSH
4369: LD_INT 33
4371: PUSH
4372: LD_INT 2
4374: PUSH
4375: EMPTY
4376: LIST
4377: LIST
4378: PUSH
4379: LD_INT 34
4381: PUSH
4382: LD_INT 32
4384: PUSH
4385: EMPTY
4386: LIST
4387: LIST
4388: PUSH
4389: EMPTY
4390: LIST
4391: LIST
4392: PPUSH
4393: CALL_OW 72
4397: IFFALSE 4353
// cargo := UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) [ 1 ] ;
4399: LD_ADDR_VAR 0 2
4403: PUSH
4404: LD_EXP 69
4408: PUSH
4409: LD_INT 1
4411: ARRAY
4412: PPUSH
4413: LD_INT 33
4415: PUSH
4416: LD_INT 2
4418: PUSH
4419: EMPTY
4420: LIST
4421: LIST
4422: PUSH
4423: LD_INT 34
4425: PUSH
4426: LD_INT 32
4428: PUSH
4429: EMPTY
4430: LIST
4431: LIST
4432: PUSH
4433: EMPTY
4434: LIST
4435: LIST
4436: PPUSH
4437: CALL_OW 72
4441: PUSH
4442: LD_INT 1
4444: ARRAY
4445: ST_TO_ADDR
// pos := FindArtifact ( 5 ) ;
4446: LD_ADDR_VAR 0 4
4450: PUSH
4451: LD_INT 5
4453: PPUSH
4454: CALL_OW 469
4458: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4459: LD_INT 35
4461: PPUSH
4462: CALL_OW 67
// pos := FindArtifact ( 5 ) ;
4466: LD_ADDR_VAR 0 4
4470: PUSH
4471: LD_INT 5
4473: PPUSH
4474: CALL_OW 469
4478: ST_TO_ADDR
// tmp := 100 ;
4479: LD_ADDR_VAR 0 3
4483: PUSH
4484: LD_INT 100
4486: ST_TO_ADDR
// if pos then
4487: LD_VAR 0 4
4491: IFFALSE 4531
// tmp := DangerAtRangeXY ( 2 , pos [ 1 ] , pos [ 2 ] , 20 ) [ 4 ] ;
4493: LD_ADDR_VAR 0 3
4497: PUSH
4498: LD_INT 2
4500: PPUSH
4501: LD_VAR 0 4
4505: PUSH
4506: LD_INT 1
4508: ARRAY
4509: PPUSH
4510: LD_VAR 0 4
4514: PUSH
4515: LD_INT 2
4517: ARRAY
4518: PPUSH
4519: LD_INT 20
4521: PPUSH
4522: CALL 55283 0 4
4526: PUSH
4527: LD_INT 4
4529: ARRAY
4530: ST_TO_ADDR
// until pos and not artifact_oncargo and tmp < 10 ;
4531: LD_VAR 0 4
4535: PUSH
4536: LD_EXP 14
4540: NOT
4541: AND
4542: PUSH
4543: LD_VAR 0 3
4547: PUSH
4548: LD_INT 10
4550: LESS
4551: AND
4552: IFFALSE 4459
// ComGet ( cargo , pos [ 1 ] , pos [ 2 ] ) ;
4554: LD_VAR 0 2
4558: PPUSH
4559: LD_VAR 0 4
4563: PUSH
4564: LD_INT 1
4566: ARRAY
4567: PPUSH
4568: LD_VAR 0 4
4572: PUSH
4573: LD_INT 2
4575: ARRAY
4576: PPUSH
4577: CALL_OW 160
// AddComMoveXY ( cargo , 198 , 113 ) ;
4581: LD_VAR 0 2
4585: PPUSH
4586: LD_INT 198
4588: PPUSH
4589: LD_INT 113
4591: PPUSH
4592: CALL_OW 171
// AddComMoveXY ( cargo , 124 , 7 ) ;
4596: LD_VAR 0 2
4600: PPUSH
4601: LD_INT 124
4603: PPUSH
4604: LD_INT 7
4606: PPUSH
4607: CALL_OW 171
// end ;
4611: PPOPN 4
4613: END
// every 5 5$00 trigger base_captured do var i , un , tmp , skill , coords , flags , w , list ;
4614: LD_EXP 6
4618: IFFALSE 7292
4620: GO 4622
4622: DISABLE
4623: LD_INT 0
4625: PPUSH
4626: PPUSH
4627: PPUSH
4628: PPUSH
4629: PPUSH
4630: PPUSH
4631: PPUSH
4632: PPUSH
// begin skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
4633: LD_ADDR_VAR 0 4
4637: PUSH
4638: LD_INT 5
4640: PUSH
4641: LD_INT 6
4643: PUSH
4644: LD_INT 7
4646: PUSH
4647: EMPTY
4648: LIST
4649: LIST
4650: LIST
4651: PUSH
4652: LD_OWVAR 67
4656: ARRAY
4657: ST_TO_ADDR
// coords := [ ] ;
4658: LD_ADDR_VAR 0 5
4662: PUSH
4663: EMPTY
4664: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
4665: LD_ADDR_VAR 0 6
4669: PUSH
4670: LD_INT 0
4672: PUSH
4673: LD_INT 0
4675: PUSH
4676: LD_INT 0
4678: PUSH
4679: LD_INT 0
4681: PUSH
4682: LD_INT 1
4684: PUSH
4685: LD_INT 0
4687: PUSH
4688: LD_INT 0
4690: PUSH
4691: LD_INT 0
4693: PUSH
4694: LD_INT 1
4696: PUSH
4697: LD_INT 0
4699: PUSH
4700: EMPTY
4701: LIST
4702: LIST
4703: LIST
4704: LIST
4705: LIST
4706: LIST
4707: LIST
4708: LIST
4709: LIST
4710: LIST
4711: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ) ;
4712: LD_INT 1
4714: PPUSH
4715: LD_INT 14
4717: PUSH
4718: LD_INT 1
4720: PUSH
4721: LD_INT 2
4723: PUSH
4724: LD_INT 28
4726: PUSH
4727: EMPTY
4728: LIST
4729: LIST
4730: LIST
4731: LIST
4732: PUSH
4733: LD_INT 14
4735: PUSH
4736: LD_INT 1
4738: PUSH
4739: LD_INT 2
4741: PUSH
4742: LD_INT 25
4744: PUSH
4745: EMPTY
4746: LIST
4747: LIST
4748: LIST
4749: LIST
4750: PUSH
4751: LD_INT 14
4753: PUSH
4754: LD_INT 1
4756: PUSH
4757: LD_INT 2
4759: PUSH
4760: LD_INT 28
4762: PUSH
4763: EMPTY
4764: LIST
4765: LIST
4766: LIST
4767: LIST
4768: PUSH
4769: LD_INT 14
4771: PUSH
4772: LD_INT 1
4774: PUSH
4775: LD_INT 2
4777: PUSH
4778: LD_INT 29
4780: PUSH
4781: EMPTY
4782: LIST
4783: LIST
4784: LIST
4785: LIST
4786: PUSH
4787: EMPTY
4788: LIST
4789: LIST
4790: LIST
4791: LIST
4792: PPUSH
4793: CALL 40847 0 2
// wait ( [ 10 10$00 , 9 9$30 , 9 9$00 ] [ Difficulty ] ) ;
4797: LD_INT 21000
4799: PUSH
4800: LD_INT 19950
4802: PUSH
4803: LD_INT 18900
4805: PUSH
4806: EMPTY
4807: LIST
4808: LIST
4809: LIST
4810: PUSH
4811: LD_OWVAR 67
4815: ARRAY
4816: PPUSH
4817: CALL_OW 67
// InitHc ;
4821: CALL_OW 19
// InitUc ;
4825: CALL_OW 18
// uc_side := 2 ;
4829: LD_ADDR_OWVAR 20
4833: PUSH
4834: LD_INT 2
4836: ST_TO_ADDR
// uc_nation := 2 ;
4837: LD_ADDR_OWVAR 21
4841: PUSH
4842: LD_INT 2
4844: ST_TO_ADDR
// tmp := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
4845: LD_ADDR_VAR 0 3
4849: PUSH
4850: EMPTY
4851: PUSH
4852: EMPTY
4853: PUSH
4854: EMPTY
4855: PUSH
4856: EMPTY
4857: PUSH
4858: EMPTY
4859: PUSH
4860: EMPTY
4861: LIST
4862: LIST
4863: LIST
4864: LIST
4865: LIST
4866: ST_TO_ADDR
// tmp := Replace ( tmp , 1 , mc_vehicles [ 1 ] diff FilterAllUnits ( [ f_weapon , ar_cargo_bay ] ) ) ;
4867: LD_ADDR_VAR 0 3
4871: PUSH
4872: LD_VAR 0 3
4876: PPUSH
4877: LD_INT 1
4879: PPUSH
4880: LD_EXP 69
4884: PUSH
4885: LD_INT 1
4887: ARRAY
4888: PUSH
4889: LD_INT 34
4891: PUSH
4892: LD_INT 32
4894: PUSH
4895: EMPTY
4896: LIST
4897: LIST
4898: PPUSH
4899: CALL_OW 69
4903: DIFF
4904: PPUSH
4905: CALL_OW 1
4909: ST_TO_ADDR
// for i = 1 to Difficulty do
4910: LD_ADDR_VAR 0 1
4914: PUSH
4915: DOUBLE
4916: LD_INT 1
4918: DEC
4919: ST_TO_ADDR
4920: LD_OWVAR 67
4924: PUSH
4925: FOR_TO
4926: IFFALSE 5064
// begin uc_side := 2 ;
4928: LD_ADDR_OWVAR 20
4932: PUSH
4933: LD_INT 2
4935: ST_TO_ADDR
// uc_nation := 2 ;
4936: LD_ADDR_OWVAR 21
4940: PUSH
4941: LD_INT 2
4943: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
4944: LD_INT 13
4946: PPUSH
4947: LD_INT 3
4949: PPUSH
4950: LD_INT 5
4952: PPUSH
4953: LD_INT 29
4955: PPUSH
4956: LD_INT 100
4958: PPUSH
4959: CALL 54265 0 5
// un := CreateVehicle ;
4963: LD_ADDR_VAR 0 2
4967: PUSH
4968: CALL_OW 45
4972: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 1 , tmp [ 1 ] + 1 ] , un ) ;
4973: LD_ADDR_VAR 0 3
4977: PUSH
4978: LD_VAR 0 3
4982: PPUSH
4983: LD_INT 1
4985: PUSH
4986: LD_VAR 0 3
4990: PUSH
4991: LD_INT 1
4993: ARRAY
4994: PUSH
4995: LD_INT 1
4997: PLUS
4998: PUSH
4999: EMPTY
5000: LIST
5001: LIST
5002: PPUSH
5003: LD_VAR 0 2
5007: PPUSH
5008: CALL 54387 0 3
5012: ST_TO_ADDR
// SetDir ( un , 3 ) ;
5013: LD_VAR 0 2
5017: PPUSH
5018: LD_INT 3
5020: PPUSH
5021: CALL_OW 233
// PlaceUnitArea ( un , north_attack_spawn , false ) ;
5025: LD_VAR 0 2
5029: PPUSH
5030: LD_INT 16
5032: PPUSH
5033: LD_INT 0
5035: PPUSH
5036: CALL_OW 49
// ComMoveXY ( un , 51 , 10 ) ;
5040: LD_VAR 0 2
5044: PPUSH
5045: LD_INT 51
5047: PPUSH
5048: LD_INT 10
5050: PPUSH
5051: CALL_OW 111
// wait ( 0 0$2 ) ;
5055: LD_INT 70
5057: PPUSH
5058: CALL_OW 67
// end ;
5062: GO 4925
5064: POP
5065: POP
// coords := [ [ 51 , 24 ] , [ 75 , 90 ] ] ;
5066: LD_ADDR_VAR 0 5
5070: PUSH
5071: LD_INT 51
5073: PUSH
5074: LD_INT 24
5076: PUSH
5077: EMPTY
5078: LIST
5079: LIST
5080: PUSH
5081: LD_INT 75
5083: PUSH
5084: LD_INT 90
5086: PUSH
5087: EMPTY
5088: LIST
5089: LIST
5090: PUSH
5091: EMPTY
5092: LIST
5093: LIST
5094: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 1 ] , coords , flags ) ;
5095: LD_INT 1
5097: PPUSH
5098: LD_VAR 0 3
5102: PUSH
5103: LD_INT 1
5105: ARRAY
5106: PPUSH
5107: LD_VAR 0 5
5111: PPUSH
5112: LD_VAR 0 6
5116: PPUSH
5117: CALL 41080 0 4
// for i = 1 to [ 1 , 3 , 3 ] [ Difficulty ] do
5121: LD_ADDR_VAR 0 1
5125: PUSH
5126: DOUBLE
5127: LD_INT 1
5129: DEC
5130: ST_TO_ADDR
5131: LD_INT 1
5133: PUSH
5134: LD_INT 3
5136: PUSH
5137: LD_INT 3
5139: PUSH
5140: EMPTY
5141: LIST
5142: LIST
5143: LIST
5144: PUSH
5145: LD_OWVAR 67
5149: ARRAY
5150: PUSH
5151: FOR_TO
5152: IFFALSE 5252
// begin uc_side := 2 ;
5154: LD_ADDR_OWVAR 20
5158: PUSH
5159: LD_INT 2
5161: ST_TO_ADDR
// uc_nation := 2 ;
5162: LD_ADDR_OWVAR 21
5166: PUSH
5167: LD_INT 2
5169: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5170: LD_INT 0
5172: PPUSH
5173: LD_INT 17
5175: PPUSH
5176: LD_VAR 0 4
5180: PPUSH
5181: CALL_OW 380
// un := CreateHuman ;
5185: LD_ADDR_VAR 0 2
5189: PUSH
5190: CALL_OW 44
5194: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5195: LD_ADDR_VAR 0 3
5199: PUSH
5200: LD_VAR 0 3
5204: PPUSH
5205: LD_INT 2
5207: PUSH
5208: LD_VAR 0 3
5212: PUSH
5213: LD_INT 2
5215: ARRAY
5216: PUSH
5217: LD_INT 1
5219: PLUS
5220: PUSH
5221: EMPTY
5222: LIST
5223: LIST
5224: PPUSH
5225: LD_VAR 0 2
5229: PPUSH
5230: CALL 54387 0 3
5234: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5235: LD_VAR 0 2
5239: PPUSH
5240: LD_INT 13
5242: PPUSH
5243: LD_INT 0
5245: PPUSH
5246: CALL_OW 49
// end ;
5250: GO 5151
5252: POP
5253: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] do
5254: LD_ADDR_VAR 0 1
5258: PUSH
5259: DOUBLE
5260: LD_INT 1
5262: DEC
5263: ST_TO_ADDR
5264: LD_INT 2
5266: PUSH
5267: LD_INT 3
5269: PUSH
5270: LD_INT 3
5272: PUSH
5273: EMPTY
5274: LIST
5275: LIST
5276: LIST
5277: PUSH
5278: LD_OWVAR 67
5282: ARRAY
5283: PUSH
5284: FOR_TO
5285: IFFALSE 5404
// begin uc_side := 2 ;
5287: LD_ADDR_OWVAR 20
5291: PUSH
5292: LD_INT 2
5294: ST_TO_ADDR
// uc_nation := 2 ;
5295: LD_ADDR_OWVAR 21
5299: PUSH
5300: LD_INT 2
5302: ST_TO_ADDR
// PrepareHuman ( false , [ 1 , 8 ] [ rand ( 1 , 2 ) ] , skill ) ;
5303: LD_INT 0
5305: PPUSH
5306: LD_INT 1
5308: PUSH
5309: LD_INT 8
5311: PUSH
5312: EMPTY
5313: LIST
5314: LIST
5315: PUSH
5316: LD_INT 1
5318: PPUSH
5319: LD_INT 2
5321: PPUSH
5322: CALL_OW 12
5326: ARRAY
5327: PPUSH
5328: LD_VAR 0 4
5332: PPUSH
5333: CALL_OW 380
// un := CreateHuman ;
5337: LD_ADDR_VAR 0 2
5341: PUSH
5342: CALL_OW 44
5346: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5347: LD_ADDR_VAR 0 3
5351: PUSH
5352: LD_VAR 0 3
5356: PPUSH
5357: LD_INT 2
5359: PUSH
5360: LD_VAR 0 3
5364: PUSH
5365: LD_INT 2
5367: ARRAY
5368: PUSH
5369: LD_INT 1
5371: PLUS
5372: PUSH
5373: EMPTY
5374: LIST
5375: LIST
5376: PPUSH
5377: LD_VAR 0 2
5381: PPUSH
5382: CALL 54387 0 3
5386: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5387: LD_VAR 0 2
5391: PPUSH
5392: LD_INT 13
5394: PPUSH
5395: LD_INT 0
5397: PPUSH
5398: CALL_OW 49
// end ;
5402: GO 5284
5404: POP
5405: POP
// coords := [ [ 67 , 112 ] , [ 85 , 130 ] ] ;
5406: LD_ADDR_VAR 0 5
5410: PUSH
5411: LD_INT 67
5413: PUSH
5414: LD_INT 112
5416: PUSH
5417: EMPTY
5418: LIST
5419: LIST
5420: PUSH
5421: LD_INT 85
5423: PUSH
5424: LD_INT 130
5426: PUSH
5427: EMPTY
5428: LIST
5429: LIST
5430: PUSH
5431: EMPTY
5432: LIST
5433: LIST
5434: ST_TO_ADDR
// MC_PrepareAttack ( 2 , tmp [ 2 ] , coords , flags ) ;
5435: LD_INT 2
5437: PPUSH
5438: LD_VAR 0 3
5442: PUSH
5443: LD_INT 2
5445: ARRAY
5446: PPUSH
5447: LD_VAR 0 5
5451: PPUSH
5452: LD_VAR 0 6
5456: PPUSH
5457: CALL 41080 0 4
// for i = 1 to [ 1 , 2 , 3 ] [ Difficulty ] do
5461: LD_ADDR_VAR 0 1
5465: PUSH
5466: DOUBLE
5467: LD_INT 1
5469: DEC
5470: ST_TO_ADDR
5471: LD_INT 1
5473: PUSH
5474: LD_INT 2
5476: PUSH
5477: LD_INT 3
5479: PUSH
5480: EMPTY
5481: LIST
5482: LIST
5483: LIST
5484: PUSH
5485: LD_OWVAR 67
5489: ARRAY
5490: PUSH
5491: FOR_TO
5492: IFFALSE 5592
// begin uc_side := 2 ;
5494: LD_ADDR_OWVAR 20
5498: PUSH
5499: LD_INT 2
5501: ST_TO_ADDR
// uc_nation := 2 ;
5502: LD_ADDR_OWVAR 21
5506: PUSH
5507: LD_INT 2
5509: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5510: LD_INT 0
5512: PPUSH
5513: LD_INT 17
5515: PPUSH
5516: LD_VAR 0 4
5520: PPUSH
5521: CALL_OW 380
// un := CreateHuman ;
5525: LD_ADDR_VAR 0 2
5529: PUSH
5530: CALL_OW 44
5534: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 3 , tmp [ 3 ] + 1 ] , un ) ;
5535: LD_ADDR_VAR 0 3
5539: PUSH
5540: LD_VAR 0 3
5544: PPUSH
5545: LD_INT 3
5547: PUSH
5548: LD_VAR 0 3
5552: PUSH
5553: LD_INT 3
5555: ARRAY
5556: PUSH
5557: LD_INT 1
5559: PLUS
5560: PUSH
5561: EMPTY
5562: LIST
5563: LIST
5564: PPUSH
5565: LD_VAR 0 2
5569: PPUSH
5570: CALL 54387 0 3
5574: ST_TO_ADDR
// PlaceUnitArea ( un , south_attack_spawn , false ) ;
5575: LD_VAR 0 2
5579: PPUSH
5580: LD_INT 14
5582: PPUSH
5583: LD_INT 0
5585: PPUSH
5586: CALL_OW 49
// end ;
5590: GO 5491
5592: POP
5593: POP
// coords := [ [ 148 , 158 ] , [ 148 , 158 ] ] ;
5594: LD_ADDR_VAR 0 5
5598: PUSH
5599: LD_INT 148
5601: PUSH
5602: LD_INT 158
5604: PUSH
5605: EMPTY
5606: LIST
5607: LIST
5608: PUSH
5609: LD_INT 148
5611: PUSH
5612: LD_INT 158
5614: PUSH
5615: EMPTY
5616: LIST
5617: LIST
5618: PUSH
5619: EMPTY
5620: LIST
5621: LIST
5622: ST_TO_ADDR
// MC_PrepareAttack ( 3 , tmp [ 3 ] , coords , flags ) ;
5623: LD_INT 3
5625: PPUSH
5626: LD_VAR 0 3
5630: PUSH
5631: LD_INT 3
5633: ARRAY
5634: PPUSH
5635: LD_VAR 0 5
5639: PPUSH
5640: LD_VAR 0 6
5644: PPUSH
5645: CALL 41080 0 4
// for i = 1 to [ 2 , 4 , 4 ] [ Difficulty ] do
5649: LD_ADDR_VAR 0 1
5653: PUSH
5654: DOUBLE
5655: LD_INT 1
5657: DEC
5658: ST_TO_ADDR
5659: LD_INT 2
5661: PUSH
5662: LD_INT 4
5664: PUSH
5665: LD_INT 4
5667: PUSH
5668: EMPTY
5669: LIST
5670: LIST
5671: LIST
5672: PUSH
5673: LD_OWVAR 67
5677: ARRAY
5678: PUSH
5679: FOR_TO
5680: IFFALSE 5904
// begin uc_side := 2 ;
5682: LD_ADDR_OWVAR 20
5686: PUSH
5687: LD_INT 2
5689: ST_TO_ADDR
// uc_nation := 2 ;
5690: LD_ADDR_OWVAR 21
5694: PUSH
5695: LD_INT 2
5697: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 3 ) ] , 100 ) ;
5698: LD_INT 14
5700: PPUSH
5701: LD_INT 3
5703: PPUSH
5704: LD_INT 1
5706: PUSH
5707: LD_INT 5
5709: PUSH
5710: EMPTY
5711: LIST
5712: LIST
5713: PUSH
5714: LD_INT 1
5716: PPUSH
5717: LD_INT 2
5719: PPUSH
5720: CALL_OW 12
5724: ARRAY
5725: PPUSH
5726: LD_INT 27
5728: PUSH
5729: LD_INT 26
5731: PUSH
5732: LD_INT 28
5734: PUSH
5735: EMPTY
5736: LIST
5737: LIST
5738: LIST
5739: PUSH
5740: LD_INT 1
5742: PPUSH
5743: LD_INT 3
5745: PPUSH
5746: CALL_OW 12
5750: ARRAY
5751: PPUSH
5752: LD_INT 100
5754: PPUSH
5755: CALL 54265 0 5
// un := CreateVehicle ;
5759: LD_ADDR_VAR 0 2
5763: PUSH
5764: CALL_OW 45
5768: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , un ) ;
5769: LD_ADDR_VAR 0 3
5773: PUSH
5774: LD_VAR 0 3
5778: PPUSH
5779: LD_INT 4
5781: PUSH
5782: LD_VAR 0 3
5786: PUSH
5787: LD_INT 4
5789: ARRAY
5790: PUSH
5791: LD_INT 1
5793: PLUS
5794: PUSH
5795: EMPTY
5796: LIST
5797: LIST
5798: PPUSH
5799: LD_VAR 0 2
5803: PPUSH
5804: CALL 54387 0 3
5808: ST_TO_ADDR
// SetDir ( un , 5 ) ;
5809: LD_VAR 0 2
5813: PPUSH
5814: LD_INT 5
5816: PPUSH
5817: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
5821: LD_VAR 0 2
5825: PPUSH
5826: LD_INT 15
5828: PPUSH
5829: LD_INT 0
5831: PPUSH
5832: CALL_OW 49
// if GetControl ( un ) = control_manual then
5836: LD_VAR 0 2
5840: PPUSH
5841: CALL_OW 263
5845: PUSH
5846: LD_INT 1
5848: EQUAL
5849: IFFALSE 5880
// begin PrepareHuman ( false , 3 , skill ) ;
5851: LD_INT 0
5853: PPUSH
5854: LD_INT 3
5856: PPUSH
5857: LD_VAR 0 4
5861: PPUSH
5862: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
5866: CALL_OW 44
5870: PPUSH
5871: LD_VAR 0 2
5875: PPUSH
5876: CALL_OW 52
// end ; ComMoveXY ( un , 179 , 135 ) ;
5880: LD_VAR 0 2
5884: PPUSH
5885: LD_INT 179
5887: PPUSH
5888: LD_INT 135
5890: PPUSH
5891: CALL_OW 111
// wait ( 0 0$2 ) ;
5895: LD_INT 70
5897: PPUSH
5898: CALL_OW 67
// end ;
5902: GO 5679
5904: POP
5905: POP
// vc_chassis := 15 ;
5906: LD_ADDR_OWVAR 37
5910: PUSH
5911: LD_INT 15
5913: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateVehicle ) ;
5914: LD_ADDR_VAR 0 3
5918: PUSH
5919: LD_VAR 0 3
5923: PPUSH
5924: LD_INT 4
5926: PUSH
5927: LD_VAR 0 3
5931: PUSH
5932: LD_INT 4
5934: ARRAY
5935: PUSH
5936: LD_INT 1
5938: PLUS
5939: PUSH
5940: EMPTY
5941: LIST
5942: LIST
5943: PPUSH
5944: CALL_OW 45
5948: PPUSH
5949: CALL 54387 0 3
5953: ST_TO_ADDR
// PlaceUnitArea ( tmp [ 4 ] [ tmp [ 4 ] ] , east_attack_spawn , false ) ;
5954: LD_VAR 0 3
5958: PUSH
5959: LD_INT 4
5961: ARRAY
5962: PUSH
5963: LD_VAR 0 3
5967: PUSH
5968: LD_INT 4
5970: ARRAY
5971: ARRAY
5972: PPUSH
5973: LD_INT 15
5975: PPUSH
5976: LD_INT 0
5978: PPUSH
5979: CALL_OW 49
// PrepareHuman ( false , class_desert_warior , skill ) ;
5983: LD_INT 0
5985: PPUSH
5986: LD_INT 11
5988: PPUSH
5989: LD_VAR 0 4
5993: PPUSH
5994: CALL_OW 380
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateHuman ) ;
5998: LD_ADDR_VAR 0 3
6002: PUSH
6003: LD_VAR 0 3
6007: PPUSH
6008: LD_INT 4
6010: PUSH
6011: LD_VAR 0 3
6015: PUSH
6016: LD_INT 4
6018: ARRAY
6019: PUSH
6020: LD_INT 1
6022: PLUS
6023: PUSH
6024: EMPTY
6025: LIST
6026: LIST
6027: PPUSH
6028: CALL_OW 44
6032: PPUSH
6033: CALL 54387 0 3
6037: ST_TO_ADDR
// PlaceHumanInUnit ( tmp [ 4 ] [ tmp [ 4 ] ] , tmp [ 4 ] [ tmp [ 4 ] - 1 ] ) ;
6038: LD_VAR 0 3
6042: PUSH
6043: LD_INT 4
6045: ARRAY
6046: PUSH
6047: LD_VAR 0 3
6051: PUSH
6052: LD_INT 4
6054: ARRAY
6055: ARRAY
6056: PPUSH
6057: LD_VAR 0 3
6061: PUSH
6062: LD_INT 4
6064: ARRAY
6065: PUSH
6066: LD_VAR 0 3
6070: PUSH
6071: LD_INT 4
6073: ARRAY
6074: PUSH
6075: LD_INT 1
6077: MINUS
6078: ARRAY
6079: PPUSH
6080: CALL_OW 52
// coords := [ [ 148 , 140 ] ] ;
6084: LD_ADDR_VAR 0 5
6088: PUSH
6089: LD_INT 148
6091: PUSH
6092: LD_INT 140
6094: PUSH
6095: EMPTY
6096: LIST
6097: LIST
6098: PUSH
6099: EMPTY
6100: LIST
6101: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 4 ] , coords , flags ) ;
6102: LD_INT 1
6104: PPUSH
6105: LD_VAR 0 3
6109: PUSH
6110: LD_INT 4
6112: ARRAY
6113: PPUSH
6114: LD_VAR 0 5
6118: PPUSH
6119: LD_VAR 0 6
6123: PPUSH
6124: CALL 41080 0 4
// if gensher_active then
6128: LD_EXP 18
6132: IFFALSE 6534
// begin SayRadio ( Gensher , D10-Diet-1 ) ;
6134: LD_EXP 45
6138: PPUSH
6139: LD_STRING D10-Diet-1
6141: PPUSH
6142: CALL_OW 94
// for i = 1 to 2 do
6146: LD_ADDR_VAR 0 1
6150: PUSH
6151: DOUBLE
6152: LD_INT 1
6154: DEC
6155: ST_TO_ADDR
6156: LD_INT 2
6158: PUSH
6159: FOR_TO
6160: IFFALSE 6298
// begin uc_side := 2 ;
6162: LD_ADDR_OWVAR 20
6166: PUSH
6167: LD_INT 2
6169: ST_TO_ADDR
// uc_nation := 2 ;
6170: LD_ADDR_OWVAR 21
6174: PUSH
6175: LD_INT 2
6177: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
6178: LD_INT 13
6180: PPUSH
6181: LD_INT 3
6183: PPUSH
6184: LD_INT 5
6186: PPUSH
6187: LD_INT 29
6189: PPUSH
6190: LD_INT 100
6192: PPUSH
6193: CALL 54265 0 5
// un := CreateVehicle ;
6197: LD_ADDR_VAR 0 2
6201: PUSH
6202: CALL_OW 45
6206: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6207: LD_ADDR_VAR 0 3
6211: PUSH
6212: LD_VAR 0 3
6216: PPUSH
6217: LD_INT 5
6219: PUSH
6220: LD_VAR 0 3
6224: PUSH
6225: LD_INT 5
6227: ARRAY
6228: PUSH
6229: LD_INT 1
6231: PLUS
6232: PUSH
6233: EMPTY
6234: LIST
6235: LIST
6236: PPUSH
6237: LD_VAR 0 2
6241: PPUSH
6242: CALL 54387 0 3
6246: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6247: LD_VAR 0 2
6251: PPUSH
6252: LD_INT 0
6254: PPUSH
6255: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6259: LD_VAR 0 2
6263: PPUSH
6264: LD_INT 23
6266: PPUSH
6267: LD_INT 0
6269: PPUSH
6270: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6274: LD_VAR 0 2
6278: PPUSH
6279: LD_INT 85
6281: PPUSH
6282: LD_INT 152
6284: PPUSH
6285: CALL_OW 111
// wait ( 0 0$2 ) ;
6289: LD_INT 70
6291: PPUSH
6292: CALL_OW 67
// end ;
6296: GO 6159
6298: POP
6299: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] do
6300: LD_ADDR_VAR 0 1
6304: PUSH
6305: DOUBLE
6306: LD_INT 1
6308: DEC
6309: ST_TO_ADDR
6310: LD_INT 2
6312: PUSH
6313: LD_INT 3
6315: PUSH
6316: LD_INT 3
6318: PUSH
6319: EMPTY
6320: LIST
6321: LIST
6322: LIST
6323: PUSH
6324: LD_OWVAR 67
6328: ARRAY
6329: PUSH
6330: FOR_TO
6331: IFFALSE 6488
// begin uc_side := 2 ;
6333: LD_ADDR_OWVAR 20
6337: PUSH
6338: LD_INT 2
6340: ST_TO_ADDR
// uc_nation := 2 ;
6341: LD_ADDR_OWVAR 21
6345: PUSH
6346: LD_INT 2
6348: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
6349: LD_INT 14
6351: PPUSH
6352: LD_INT 3
6354: PPUSH
6355: LD_INT 5
6357: PPUSH
6358: LD_INT 27
6360: PUSH
6361: LD_INT 28
6363: PUSH
6364: EMPTY
6365: LIST
6366: LIST
6367: PUSH
6368: LD_INT 1
6370: PPUSH
6371: LD_INT 2
6373: PPUSH
6374: CALL_OW 12
6378: ARRAY
6379: PPUSH
6380: LD_INT 100
6382: PPUSH
6383: CALL 54265 0 5
// un := CreateVehicle ;
6387: LD_ADDR_VAR 0 2
6391: PUSH
6392: CALL_OW 45
6396: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6397: LD_ADDR_VAR 0 3
6401: PUSH
6402: LD_VAR 0 3
6406: PPUSH
6407: LD_INT 5
6409: PUSH
6410: LD_VAR 0 3
6414: PUSH
6415: LD_INT 5
6417: ARRAY
6418: PUSH
6419: LD_INT 1
6421: PLUS
6422: PUSH
6423: EMPTY
6424: LIST
6425: LIST
6426: PPUSH
6427: LD_VAR 0 2
6431: PPUSH
6432: CALL 54387 0 3
6436: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6437: LD_VAR 0 2
6441: PPUSH
6442: LD_INT 0
6444: PPUSH
6445: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6449: LD_VAR 0 2
6453: PPUSH
6454: LD_INT 23
6456: PPUSH
6457: LD_INT 0
6459: PPUSH
6460: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6464: LD_VAR 0 2
6468: PPUSH
6469: LD_INT 85
6471: PPUSH
6472: LD_INT 152
6474: PPUSH
6475: CALL_OW 111
// wait ( 0 0$2 ) ;
6479: LD_INT 70
6481: PPUSH
6482: CALL_OW 67
// end ;
6486: GO 6330
6488: POP
6489: POP
// coords := [ [ 97 , 143 ] ] ;
6490: LD_ADDR_VAR 0 5
6494: PUSH
6495: LD_INT 97
6497: PUSH
6498: LD_INT 143
6500: PUSH
6501: EMPTY
6502: LIST
6503: LIST
6504: PUSH
6505: EMPTY
6506: LIST
6507: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 5 ] , coords , flags ) ;
6508: LD_INT 1
6510: PPUSH
6511: LD_VAR 0 3
6515: PUSH
6516: LD_INT 5
6518: ARRAY
6519: PPUSH
6520: LD_VAR 0 5
6524: PPUSH
6525: LD_VAR 0 6
6529: PPUSH
6530: CALL 41080 0 4
// end ; Wait ( 13 13$00 ) ;
6534: LD_INT 27300
6536: PPUSH
6537: CALL_OW 67
// tmp := [ ] ;
6541: LD_ADDR_VAR 0 3
6545: PUSH
6546: EMPTY
6547: ST_TO_ADDR
// w := 1 ;
6548: LD_ADDR_VAR 0 7
6552: PUSH
6553: LD_INT 1
6555: ST_TO_ADDR
// repeat tmp := [ ] ;
6556: LD_ADDR_VAR 0 3
6560: PUSH
6561: EMPTY
6562: ST_TO_ADDR
// if w mod 4 = 0 then
6563: LD_VAR 0 7
6567: PUSH
6568: LD_INT 4
6570: MOD
6571: PUSH
6572: LD_INT 0
6574: EQUAL
6575: IFFALSE 6662
// list := [ [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] else
6577: LD_ADDR_VAR 0 8
6581: PUSH
6582: LD_INT 11
6584: PUSH
6585: LD_INT 1
6587: PUSH
6588: LD_INT 2
6590: PUSH
6591: LD_INT 24
6593: PUSH
6594: EMPTY
6595: LIST
6596: LIST
6597: LIST
6598: LIST
6599: PUSH
6600: LD_INT 11
6602: PUSH
6603: LD_INT 1
6605: PUSH
6606: LD_INT 2
6608: PUSH
6609: LD_INT 24
6611: PUSH
6612: EMPTY
6613: LIST
6614: LIST
6615: LIST
6616: LIST
6617: PUSH
6618: LD_INT 11
6620: PUSH
6621: LD_INT 1
6623: PUSH
6624: LD_INT 2
6626: PUSH
6627: LD_INT 24
6629: PUSH
6630: EMPTY
6631: LIST
6632: LIST
6633: LIST
6634: LIST
6635: PUSH
6636: LD_INT 11
6638: PUSH
6639: LD_INT 1
6641: PUSH
6642: LD_INT 2
6644: PUSH
6645: LD_INT 24
6647: PUSH
6648: EMPTY
6649: LIST
6650: LIST
6651: LIST
6652: LIST
6653: PUSH
6654: EMPTY
6655: LIST
6656: LIST
6657: LIST
6658: LIST
6659: ST_TO_ADDR
6660: GO 6764
// list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] ;
6662: LD_ADDR_VAR 0 8
6666: PUSH
6667: LD_INT 14
6669: PUSH
6670: LD_INT 1
6672: PUSH
6673: LD_INT 2
6675: PUSH
6676: LD_INT 28
6678: PUSH
6679: EMPTY
6680: LIST
6681: LIST
6682: LIST
6683: LIST
6684: PUSH
6685: LD_INT 14
6687: PUSH
6688: LD_INT 1
6690: PUSH
6691: LD_INT 2
6693: PUSH
6694: LD_INT 25
6696: PUSH
6697: EMPTY
6698: LIST
6699: LIST
6700: LIST
6701: LIST
6702: PUSH
6703: LD_INT 14
6705: PUSH
6706: LD_INT 1
6708: PUSH
6709: LD_INT 2
6711: PUSH
6712: LD_INT 28
6714: PUSH
6715: EMPTY
6716: LIST
6717: LIST
6718: LIST
6719: LIST
6720: PUSH
6721: LD_INT 14
6723: PUSH
6724: LD_INT 1
6726: PUSH
6727: LD_INT 2
6729: PUSH
6730: LD_INT 29
6732: PUSH
6733: EMPTY
6734: LIST
6735: LIST
6736: LIST
6737: LIST
6738: PUSH
6739: LD_INT 11
6741: PUSH
6742: LD_INT 1
6744: PUSH
6745: LD_INT 2
6747: PUSH
6748: LD_INT 24
6750: PUSH
6751: EMPTY
6752: LIST
6753: LIST
6754: LIST
6755: LIST
6756: PUSH
6757: EMPTY
6758: LIST
6759: LIST
6760: LIST
6761: LIST
6762: LIST
6763: ST_TO_ADDR
// if w mod 3 = 0 then
6764: LD_VAR 0 7
6768: PUSH
6769: LD_INT 3
6771: MOD
6772: PUSH
6773: LD_INT 0
6775: EQUAL
6776: IFFALSE 6852
// list := ReplaceIn ( list , [ 1 , list [ i ] + 1 ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gatling_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] ] ) ;
6778: LD_ADDR_VAR 0 8
6782: PUSH
6783: LD_VAR 0 8
6787: PPUSH
6788: LD_INT 1
6790: PUSH
6791: LD_VAR 0 8
6795: PUSH
6796: LD_VAR 0 1
6800: ARRAY
6801: PUSH
6802: LD_INT 1
6804: PLUS
6805: PUSH
6806: EMPTY
6807: LIST
6808: LIST
6809: PPUSH
6810: LD_INT 14
6812: PUSH
6813: LD_INT 1
6815: PUSH
6816: LD_INT 2
6818: PUSH
6819: LD_INT 25
6821: PUSH
6822: LD_INT 28
6824: PUSH
6825: EMPTY
6826: LIST
6827: LIST
6828: PUSH
6829: LD_INT 1
6831: PPUSH
6832: LD_INT 2
6834: PPUSH
6835: CALL_OW 12
6839: ARRAY
6840: PUSH
6841: EMPTY
6842: LIST
6843: LIST
6844: LIST
6845: LIST
6846: PPUSH
6847: CALL 54387 0 3
6851: ST_TO_ADDR
// MC_SetProduceList ( 1 , list ) ;
6852: LD_INT 1
6854: PPUSH
6855: LD_VAR 0 8
6859: PPUSH
6860: CALL 40847 0 2
// if GetSide ( ar_dep_w ) = 2 then
6864: LD_INT 45
6866: PPUSH
6867: CALL_OW 255
6871: PUSH
6872: LD_INT 2
6874: EQUAL
6875: IFFALSE 6960
// begin list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] ] ;
6877: LD_ADDR_VAR 0 8
6881: PUSH
6882: LD_INT 14
6884: PUSH
6885: LD_INT 1
6887: PUSH
6888: LD_INT 2
6890: PUSH
6891: LD_INT 28
6893: PUSH
6894: EMPTY
6895: LIST
6896: LIST
6897: LIST
6898: LIST
6899: PUSH
6900: LD_INT 14
6902: PUSH
6903: LD_INT 1
6905: PUSH
6906: LD_INT 2
6908: PUSH
6909: LD_INT 27
6911: PUSH
6912: EMPTY
6913: LIST
6914: LIST
6915: LIST
6916: LIST
6917: PUSH
6918: LD_INT 14
6920: PUSH
6921: LD_INT 1
6923: PUSH
6924: LD_INT 2
6926: PUSH
6927: LD_INT 27
6929: PUSH
6930: EMPTY
6931: LIST
6932: LIST
6933: LIST
6934: LIST
6935: PUSH
6936: EMPTY
6937: LIST
6938: LIST
6939: LIST
6940: ST_TO_ADDR
// MC_SetProduceList ( 2 , list ) ;
6941: LD_INT 2
6943: PPUSH
6944: LD_VAR 0 8
6948: PPUSH
6949: CALL 40847 0 2
// wait ( 0 0$50 ) ;
6953: LD_INT 1750
6955: PPUSH
6956: CALL_OW 67
// end ; repeat wait ( 0 0$1 ) ;
6960: LD_INT 35
6962: PPUSH
6963: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_weapon , ar_cargo_bay ] ] ) >= 4 ;
6967: LD_EXP 69
6971: PUSH
6972: LD_INT 1
6974: ARRAY
6975: PPUSH
6976: LD_INT 3
6978: PUSH
6979: LD_INT 34
6981: PUSH
6982: LD_INT 32
6984: PUSH
6985: EMPTY
6986: LIST
6987: LIST
6988: PUSH
6989: EMPTY
6990: LIST
6991: LIST
6992: PPUSH
6993: CALL_OW 72
6997: PUSH
6998: LD_INT 4
7000: GREATEREQUAL
7001: IFFALSE 6960
// wait ( 0 0$10 ) ;
7003: LD_INT 350
7005: PPUSH
7006: CALL_OW 67
// tmp := UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_weapon , ar_cargo_bay ] ] ) ;
7010: LD_ADDR_VAR 0 3
7014: PUSH
7015: LD_EXP 69
7019: PUSH
7020: LD_INT 1
7022: ARRAY
7023: PPUSH
7024: LD_INT 3
7026: PUSH
7027: LD_INT 34
7029: PUSH
7030: LD_INT 32
7032: PUSH
7033: EMPTY
7034: LIST
7035: LIST
7036: PUSH
7037: EMPTY
7038: LIST
7039: LIST
7040: PPUSH
7041: CALL_OW 72
7045: ST_TO_ADDR
// if Prob ( 100 ) < 50 then
7046: LD_INT 100
7048: PPUSH
7049: CALL_OW 13
7053: PUSH
7054: LD_INT 50
7056: LESS
7057: IFFALSE 7090
// coords := [ [ 55 , 7 ] , [ 75 , 90 ] ] else
7059: LD_ADDR_VAR 0 5
7063: PUSH
7064: LD_INT 55
7066: PUSH
7067: LD_INT 7
7069: PUSH
7070: EMPTY
7071: LIST
7072: LIST
7073: PUSH
7074: LD_INT 75
7076: PUSH
7077: LD_INT 90
7079: PUSH
7080: EMPTY
7081: LIST
7082: LIST
7083: PUSH
7084: EMPTY
7085: LIST
7086: LIST
7087: ST_TO_ADDR
7088: GO 7119
// coords := [ [ 128 , 94 ] , [ 180 , 135 ] ] ;
7090: LD_ADDR_VAR 0 5
7094: PUSH
7095: LD_INT 128
7097: PUSH
7098: LD_INT 94
7100: PUSH
7101: EMPTY
7102: LIST
7103: LIST
7104: PUSH
7105: LD_INT 180
7107: PUSH
7108: LD_INT 135
7110: PUSH
7111: EMPTY
7112: LIST
7113: LIST
7114: PUSH
7115: EMPTY
7116: LIST
7117: LIST
7118: ST_TO_ADDR
// if w mod 4 = 0 then
7119: LD_VAR 0 7
7123: PUSH
7124: LD_INT 4
7126: MOD
7127: PUSH
7128: LD_INT 0
7130: EQUAL
7131: IFFALSE 7162
// coords := [ [ 91 , 58 ] , [ 117 , 107 ] ] ;
7133: LD_ADDR_VAR 0 5
7137: PUSH
7138: LD_INT 91
7140: PUSH
7141: LD_INT 58
7143: PUSH
7144: EMPTY
7145: LIST
7146: LIST
7147: PUSH
7148: LD_INT 117
7150: PUSH
7151: LD_INT 107
7153: PUSH
7154: EMPTY
7155: LIST
7156: LIST
7157: PUSH
7158: EMPTY
7159: LIST
7160: LIST
7161: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp , coords , flags ) ;
7162: LD_INT 1
7164: PPUSH
7165: LD_VAR 0 3
7169: PPUSH
7170: LD_VAR 0 5
7174: PPUSH
7175: LD_VAR 0 6
7179: PPUSH
7180: CALL 41080 0 4
// if mc_vehicles [ 2 ] then
7184: LD_EXP 69
7188: PUSH
7189: LD_INT 2
7191: ARRAY
7192: IFFALSE 7228
// MC_PrepareAttack ( 2 , mc_vehicles [ 2 ] , [ [ 73 , 115 ] ] , flags ) ;
7194: LD_INT 2
7196: PPUSH
7197: LD_EXP 69
7201: PUSH
7202: LD_INT 2
7204: ARRAY
7205: PPUSH
7206: LD_INT 73
7208: PUSH
7209: LD_INT 115
7211: PUSH
7212: EMPTY
7213: LIST
7214: LIST
7215: PUSH
7216: EMPTY
7217: LIST
7218: PPUSH
7219: LD_VAR 0 6
7223: PPUSH
7224: CALL 41080 0 4
// wait ( rand ( 10 10$30 , 13 13$30 ) ) ;
7228: LD_INT 22050
7230: PPUSH
7231: LD_INT 28350
7233: PPUSH
7234: CALL_OW 12
7238: PPUSH
7239: CALL_OW 67
// w := w + 1 ;
7243: LD_ADDR_VAR 0 7
7247: PUSH
7248: LD_VAR 0 7
7252: PUSH
7253: LD_INT 1
7255: PLUS
7256: ST_TO_ADDR
// until IsDead ( ar_dep_n ) or not UnitFilter ( mc_bases [ 1 ] , [ f_btype , b_factory ] ) ;
7257: LD_INT 94
7259: PPUSH
7260: CALL_OW 301
7264: PUSH
7265: LD_EXP 50
7269: PUSH
7270: LD_INT 1
7272: ARRAY
7273: PPUSH
7274: LD_INT 30
7276: PUSH
7277: LD_INT 3
7279: PUSH
7280: EMPTY
7281: LIST
7282: LIST
7283: PPUSH
7284: CALL_OW 72
7288: NOT
7289: OR
7290: IFFALSE 6556
// end ;
7292: PPOPN 8
7294: END
// every 28 28$00 trigger ar_dep_e do var i , tmp , un , x ;
7295: LD_INT 204
7297: IFFALSE 7771
7299: GO 7301
7301: DISABLE
7302: LD_INT 0
7304: PPUSH
7305: PPUSH
7306: PPUSH
7307: PPUSH
// begin enable ;
7308: ENABLE
// wait ( rand ( 0 0$1 , 0 0$34 ) ) ;
7309: LD_INT 35
7311: PPUSH
7312: LD_INT 1190
7314: PPUSH
7315: CALL_OW 12
7319: PPUSH
7320: CALL_OW 67
// tmp := [ ] ;
7324: LD_ADDR_VAR 0 2
7328: PUSH
7329: EMPTY
7330: ST_TO_ADDR
// uc_side := 8 ;
7331: LD_ADDR_OWVAR 20
7335: PUSH
7336: LD_INT 8
7338: ST_TO_ADDR
// uc_nation := 2 ;
7339: LD_ADDR_OWVAR 21
7343: PUSH
7344: LD_INT 2
7346: ST_TO_ADDR
// InitHc ;
7347: CALL_OW 19
// for i = 1 to 3 do
7351: LD_ADDR_VAR 0 1
7355: PUSH
7356: DOUBLE
7357: LD_INT 1
7359: DEC
7360: ST_TO_ADDR
7361: LD_INT 3
7363: PUSH
7364: FOR_TO
7365: IFFALSE 7492
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
7367: LD_INT 13
7369: PUSH
7370: LD_INT 14
7372: PUSH
7373: EMPTY
7374: LIST
7375: LIST
7376: PUSH
7377: LD_INT 1
7379: PPUSH
7380: LD_INT 2
7382: PPUSH
7383: CALL_OW 12
7387: ARRAY
7388: PPUSH
7389: LD_INT 3
7391: PPUSH
7392: LD_INT 5
7394: PPUSH
7395: LD_INT 27
7397: PUSH
7398: LD_INT 28
7400: PUSH
7401: EMPTY
7402: LIST
7403: LIST
7404: PUSH
7405: LD_INT 1
7407: PPUSH
7408: LD_INT 2
7410: PPUSH
7411: CALL_OW 12
7415: ARRAY
7416: PPUSH
7417: LD_INT 100
7419: PPUSH
7420: CALL 54265 0 5
// un := CreateVehicle ;
7424: LD_ADDR_VAR 0 3
7428: PUSH
7429: CALL_OW 45
7433: ST_TO_ADDR
// SetDir ( un , 4 ) ;
7434: LD_VAR 0 3
7438: PPUSH
7439: LD_INT 4
7441: PPUSH
7442: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
7446: LD_VAR 0 3
7450: PPUSH
7451: LD_INT 15
7453: PPUSH
7454: LD_INT 0
7456: PPUSH
7457: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
7461: LD_ADDR_VAR 0 2
7465: PUSH
7466: LD_VAR 0 2
7470: PPUSH
7471: LD_VAR 0 2
7475: PUSH
7476: LD_INT 1
7478: PLUS
7479: PPUSH
7480: LD_VAR 0 3
7484: PPUSH
7485: CALL_OW 1
7489: ST_TO_ADDR
// end ;
7490: GO 7364
7492: POP
7493: POP
// for i = 1 to 4 do
7494: LD_ADDR_VAR 0 1
7498: PUSH
7499: DOUBLE
7500: LD_INT 1
7502: DEC
7503: ST_TO_ADDR
7504: LD_INT 4
7506: PUSH
7507: FOR_TO
7508: IFFALSE 7587
// begin PrepareHuman ( false , rand ( 1 , 4 ) , 6 ) ;
7510: LD_INT 0
7512: PPUSH
7513: LD_INT 1
7515: PPUSH
7516: LD_INT 4
7518: PPUSH
7519: CALL_OW 12
7523: PPUSH
7524: LD_INT 6
7526: PPUSH
7527: CALL_OW 380
// un := CreateHuman ;
7531: LD_ADDR_VAR 0 3
7535: PUSH
7536: CALL_OW 44
7540: ST_TO_ADDR
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
7541: LD_VAR 0 3
7545: PPUSH
7546: LD_INT 15
7548: PPUSH
7549: LD_INT 0
7551: PPUSH
7552: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
7556: LD_ADDR_VAR 0 2
7560: PUSH
7561: LD_VAR 0 2
7565: PPUSH
7566: LD_VAR 0 2
7570: PUSH
7571: LD_INT 1
7573: PLUS
7574: PPUSH
7575: LD_VAR 0 3
7579: PPUSH
7580: CALL_OW 1
7584: ST_TO_ADDR
// end ;
7585: GO 7507
7587: POP
7588: POP
// wait ( 0 0$3 ) ;
7589: LD_INT 105
7591: PPUSH
7592: CALL_OW 67
// for i in tmp do
7596: LD_ADDR_VAR 0 1
7600: PUSH
7601: LD_VAR 0 2
7605: PUSH
7606: FOR_IN
7607: IFFALSE 7675
// if GetClass ( i ) = 1 or GetType ( i ) = unit_vehicle then
7609: LD_VAR 0 1
7613: PPUSH
7614: CALL_OW 257
7618: PUSH
7619: LD_INT 1
7621: EQUAL
7622: PUSH
7623: LD_VAR 0 1
7627: PPUSH
7628: CALL_OW 247
7632: PUSH
7633: LD_INT 2
7635: EQUAL
7636: OR
7637: IFFALSE 7673
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
7639: LD_VAR 0 1
7643: PPUSH
7644: LD_INT 81
7646: PUSH
7647: LD_INT 8
7649: PUSH
7650: EMPTY
7651: LIST
7652: LIST
7653: PPUSH
7654: CALL_OW 69
7658: PPUSH
7659: LD_VAR 0 1
7663: PPUSH
7664: CALL_OW 74
7668: PPUSH
7669: CALL_OW 115
7673: GO 7606
7675: POP
7676: POP
// repeat AddComAgressiveMove ( tmp , 210 , 178 ) ;
7677: LD_VAR 0 2
7681: PPUSH
7682: LD_INT 210
7684: PPUSH
7685: LD_INT 178
7687: PPUSH
7688: CALL_OW 174
// x := FilterUnitsInArea ( escape_area , [ f_side , 8 ] ) ;
7692: LD_ADDR_VAR 0 4
7696: PUSH
7697: LD_INT 10
7699: PPUSH
7700: LD_INT 22
7702: PUSH
7703: LD_INT 8
7705: PUSH
7706: EMPTY
7707: LIST
7708: LIST
7709: PPUSH
7710: CALL_OW 70
7714: ST_TO_ADDR
// if x then
7715: LD_VAR 0 4
7719: IFFALSE 7747
// for i in x do
7721: LD_ADDR_VAR 0 1
7725: PUSH
7726: LD_VAR 0 4
7730: PUSH
7731: FOR_IN
7732: IFFALSE 7745
// RemoveUnit ( i ) ;
7734: LD_VAR 0 1
7738: PPUSH
7739: CALL_OW 64
7743: GO 7731
7745: POP
7746: POP
// wait ( 0 0$1 ) ;
7747: LD_INT 35
7749: PPUSH
7750: CALL_OW 67
// until not FilterAllUnits ( [ f_side , 8 ] ) ;
7754: LD_INT 22
7756: PUSH
7757: LD_INT 8
7759: PUSH
7760: EMPTY
7761: LIST
7762: LIST
7763: PPUSH
7764: CALL_OW 69
7768: NOT
7769: IFFALSE 7677
// end ;
7771: PPOPN 4
7773: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
7774: LD_INT 22
7776: PUSH
7777: LD_INT 2
7779: PUSH
7780: EMPTY
7781: LIST
7782: LIST
7783: PUSH
7784: LD_INT 34
7786: PUSH
7787: LD_INT 31
7789: PUSH
7790: EMPTY
7791: LIST
7792: LIST
7793: PUSH
7794: LD_INT 3
7796: PUSH
7797: LD_INT 24
7799: PUSH
7800: LD_INT 1000
7802: PUSH
7803: EMPTY
7804: LIST
7805: LIST
7806: PUSH
7807: EMPTY
7808: LIST
7809: LIST
7810: PUSH
7811: EMPTY
7812: LIST
7813: LIST
7814: LIST
7815: PPUSH
7816: CALL_OW 69
7820: IFFALSE 7864
7822: GO 7824
7824: DISABLE
// begin ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 106 , 14 ) ;
7825: LD_INT 22
7827: PUSH
7828: LD_INT 2
7830: PUSH
7831: EMPTY
7832: LIST
7833: LIST
7834: PUSH
7835: LD_INT 34
7837: PUSH
7838: LD_INT 31
7840: PUSH
7841: EMPTY
7842: LIST
7843: LIST
7844: PUSH
7845: EMPTY
7846: LIST
7847: LIST
7848: PPUSH
7849: CALL_OW 69
7853: PPUSH
7854: LD_INT 106
7856: PPUSH
7857: LD_INT 14
7859: PPUSH
7860: CALL_OW 111
// end ; end_of_file
7864: END
// export function Action ; var tmp , p , radar , sols , i ; begin
7865: LD_INT 0
7867: PPUSH
7868: PPUSH
7869: PPUSH
7870: PPUSH
7871: PPUSH
7872: PPUSH
// InGameOn ;
7873: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
7877: LD_EXP 21
7881: PPUSH
7882: CALL_OW 87
// SetAttitude ( 2 , 1 , att_friend , true ) ;
7886: LD_INT 2
7888: PPUSH
7889: LD_INT 1
7891: PPUSH
7892: LD_INT 1
7894: PPUSH
7895: LD_INT 1
7897: PPUSH
7898: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) ;
7902: LD_ADDR_VAR 0 2
7906: PUSH
7907: LD_INT 22
7909: PUSH
7910: LD_INT 1
7912: PUSH
7913: EMPTY
7914: LIST
7915: LIST
7916: PUSH
7917: LD_INT 25
7919: PUSH
7920: LD_INT 1
7922: PUSH
7923: EMPTY
7924: LIST
7925: LIST
7926: PUSH
7927: EMPTY
7928: LIST
7929: LIST
7930: PPUSH
7931: CALL_OW 69
7935: ST_TO_ADDR
// radar := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_radar ] ] ) [ 1 ] ;
7936: LD_ADDR_VAR 0 4
7940: PUSH
7941: LD_INT 22
7943: PUSH
7944: LD_INT 1
7946: PUSH
7947: EMPTY
7948: LIST
7949: LIST
7950: PUSH
7951: LD_INT 34
7953: PUSH
7954: LD_INT 11
7956: PUSH
7957: EMPTY
7958: LIST
7959: LIST
7960: PUSH
7961: EMPTY
7962: LIST
7963: LIST
7964: PPUSH
7965: CALL_OW 69
7969: PUSH
7970: LD_INT 1
7972: ARRAY
7973: ST_TO_ADDR
// for i = 1 to tmp do
7974: LD_ADDR_VAR 0 6
7978: PUSH
7979: DOUBLE
7980: LD_INT 1
7982: DEC
7983: ST_TO_ADDR
7984: LD_VAR 0 2
7988: PUSH
7989: FOR_TO
7990: IFFALSE 8037
// begin if i = 5 then
7992: LD_VAR 0 6
7996: PUSH
7997: LD_INT 5
7999: EQUAL
8000: IFFALSE 8004
// break ;
8002: GO 8037
// sols := Replace ( sols , i , tmp [ i ] ) ;
8004: LD_ADDR_VAR 0 5
8008: PUSH
8009: LD_VAR 0 5
8013: PPUSH
8014: LD_VAR 0 6
8018: PPUSH
8019: LD_VAR 0 2
8023: PUSH
8024: LD_VAR 0 6
8028: ARRAY
8029: PPUSH
8030: CALL_OW 1
8034: ST_TO_ADDR
// end ;
8035: GO 7989
8037: POP
8038: POP
// tmp := ar_force_tmp ;
8039: LD_ADDR_VAR 0 2
8043: PUSH
8044: LD_EXP 40
8048: ST_TO_ADDR
// PlaceUnitXY ( tmp [ 1 ] , 108 , 139 , false ) ;
8049: LD_VAR 0 2
8053: PUSH
8054: LD_INT 1
8056: ARRAY
8057: PPUSH
8058: LD_INT 108
8060: PPUSH
8061: LD_INT 139
8063: PPUSH
8064: LD_INT 0
8066: PPUSH
8067: CALL_OW 48
// ComTurnUnit ( tmp [ 1 ] , JMM ) ;
8071: LD_VAR 0 2
8075: PUSH
8076: LD_INT 1
8078: ARRAY
8079: PPUSH
8080: LD_EXP 21
8084: PPUSH
8085: CALL_OW 119
// PlaceUnitXY ( tmp [ 2 ] , 114 , 132 , false ) ;
8089: LD_VAR 0 2
8093: PUSH
8094: LD_INT 2
8096: ARRAY
8097: PPUSH
8098: LD_INT 114
8100: PPUSH
8101: LD_INT 132
8103: PPUSH
8104: LD_INT 0
8106: PPUSH
8107: CALL_OW 48
// PlaceUnitXY ( tmp [ 3 ] , 115 , 132 , false ) ;
8111: LD_VAR 0 2
8115: PUSH
8116: LD_INT 3
8118: ARRAY
8119: PPUSH
8120: LD_INT 115
8122: PPUSH
8123: LD_INT 132
8125: PPUSH
8126: LD_INT 0
8128: PPUSH
8129: CALL_OW 48
// ComHold ( [ tmp [ 2 ] , tmp [ 3 ] ] ) ;
8133: LD_VAR 0 2
8137: PUSH
8138: LD_INT 2
8140: ARRAY
8141: PUSH
8142: LD_VAR 0 2
8146: PUSH
8147: LD_INT 3
8149: ARRAY
8150: PUSH
8151: EMPTY
8152: LIST
8153: LIST
8154: PPUSH
8155: CALL_OW 140
// ComMoveXY ( radar , 83 , 123 ) ;
8159: LD_VAR 0 4
8163: PPUSH
8164: LD_INT 83
8166: PPUSH
8167: LD_INT 123
8169: PPUSH
8170: CALL_OW 111
// Wait ( 0 0$01 ) ;
8174: LD_INT 35
8176: PPUSH
8177: CALL_OW 67
// CenterOnXY ( 90 , 144 ) ;
8181: LD_INT 90
8183: PPUSH
8184: LD_INT 144
8186: PPUSH
8187: CALL_OW 84
// ComMoveXY ( sols , 88 , 129 ) ;
8191: LD_VAR 0 5
8195: PPUSH
8196: LD_INT 88
8198: PPUSH
8199: LD_INT 129
8201: PPUSH
8202: CALL_OW 111
// p := [ [ 92 , 131 ] , [ 88 , 127 ] , [ 91 , 132 ] , [ 92 , 134 ] ] ;
8206: LD_ADDR_VAR 0 3
8210: PUSH
8211: LD_INT 92
8213: PUSH
8214: LD_INT 131
8216: PUSH
8217: EMPTY
8218: LIST
8219: LIST
8220: PUSH
8221: LD_INT 88
8223: PUSH
8224: LD_INT 127
8226: PUSH
8227: EMPTY
8228: LIST
8229: LIST
8230: PUSH
8231: LD_INT 91
8233: PUSH
8234: LD_INT 132
8236: PUSH
8237: EMPTY
8238: LIST
8239: LIST
8240: PUSH
8241: LD_INT 92
8243: PUSH
8244: LD_INT 134
8246: PUSH
8247: EMPTY
8248: LIST
8249: LIST
8250: PUSH
8251: EMPTY
8252: LIST
8253: LIST
8254: LIST
8255: LIST
8256: ST_TO_ADDR
// for i = 1 to sols do
8257: LD_ADDR_VAR 0 6
8261: PUSH
8262: DOUBLE
8263: LD_INT 1
8265: DEC
8266: ST_TO_ADDR
8267: LD_VAR 0 5
8271: PUSH
8272: FOR_TO
8273: IFFALSE 8346
// begin AddComMoveXY ( sols [ i ] , p [ i ] [ 1 ] , p [ i ] [ 2 ] ) ;
8275: LD_VAR 0 5
8279: PUSH
8280: LD_VAR 0 6
8284: ARRAY
8285: PPUSH
8286: LD_VAR 0 3
8290: PUSH
8291: LD_VAR 0 6
8295: ARRAY
8296: PUSH
8297: LD_INT 1
8299: ARRAY
8300: PPUSH
8301: LD_VAR 0 3
8305: PUSH
8306: LD_VAR 0 6
8310: ARRAY
8311: PUSH
8312: LD_INT 2
8314: ARRAY
8315: PPUSH
8316: CALL_OW 171
// AddComCrawl ( sols [ i ] ) ;
8320: LD_VAR 0 5
8324: PUSH
8325: LD_VAR 0 6
8329: ARRAY
8330: PPUSH
8331: CALL_OW 197
// AddComHold ( sols ) ;
8335: LD_VAR 0 5
8339: PPUSH
8340: CALL_OW 200
// end ;
8344: GO 8272
8346: POP
8347: POP
// repeat wait ( 0 0$1 ) ;
8348: LD_INT 35
8350: PPUSH
8351: CALL_OW 67
// until GetDistUnitXY ( sols [ 1 ] , 92 , 131 ) < 4 ;
8355: LD_VAR 0 5
8359: PUSH
8360: LD_INT 1
8362: ARRAY
8363: PPUSH
8364: LD_INT 92
8366: PPUSH
8367: LD_INT 131
8369: PPUSH
8370: CALL_OW 297
8374: PUSH
8375: LD_INT 4
8377: LESS
8378: IFFALSE 8348
// CenterOnXY ( 96 , 139 ) ;
8380: LD_INT 96
8382: PPUSH
8383: LD_INT 139
8385: PPUSH
8386: CALL_OW 84
// wait ( 0 0$3 ) ;
8390: LD_INT 105
8392: PPUSH
8393: CALL_OW 67
// PlaceSeeing ( 111 , 135 , 1 , - 25 ) ;
8397: LD_INT 111
8399: PPUSH
8400: LD_INT 135
8402: PPUSH
8403: LD_INT 1
8405: PPUSH
8406: LD_INT 25
8408: NEG
8409: PPUSH
8410: CALL_OW 330
// ComMoveXY ( tmp [ 2 ] , GetX ( tmp [ 1 ] ) + 3 , GetY ( tmp [ 1 ] ) ) ;
8414: LD_VAR 0 2
8418: PUSH
8419: LD_INT 2
8421: ARRAY
8422: PPUSH
8423: LD_VAR 0 2
8427: PUSH
8428: LD_INT 1
8430: ARRAY
8431: PPUSH
8432: CALL_OW 250
8436: PUSH
8437: LD_INT 3
8439: PLUS
8440: PPUSH
8441: LD_VAR 0 2
8445: PUSH
8446: LD_INT 1
8448: ARRAY
8449: PPUSH
8450: CALL_OW 251
8454: PPUSH
8455: CALL_OW 111
// ComEnterUnit ( tmp [ 3 ] , ar_dep_s ) ;
8459: LD_VAR 0 2
8463: PUSH
8464: LD_INT 3
8466: ARRAY
8467: PPUSH
8468: LD_INT 7
8470: PPUSH
8471: CALL_OW 120
// AddComTurnUnit ( tmp [ 2 ] , tmp [ 1 ] ) ;
8475: LD_VAR 0 2
8479: PUSH
8480: LD_INT 2
8482: ARRAY
8483: PPUSH
8484: LD_VAR 0 2
8488: PUSH
8489: LD_INT 1
8491: ARRAY
8492: PPUSH
8493: CALL_OW 179
// repeat wait ( 0 0$1 ) ;
8497: LD_INT 35
8499: PPUSH
8500: CALL_OW 67
// until GetDistUnits ( tmp [ 1 ] , tmp [ 2 ] ) < 5 ;
8504: LD_VAR 0 2
8508: PUSH
8509: LD_INT 1
8511: ARRAY
8512: PPUSH
8513: LD_VAR 0 2
8517: PUSH
8518: LD_INT 2
8520: ARRAY
8521: PPUSH
8522: CALL_OW 296
8526: PUSH
8527: LD_INT 5
8529: LESS
8530: IFFALSE 8497
// ComTurnUnit ( tmp [ 1 ] , tmp [ 2 ] ) ;
8532: LD_VAR 0 2
8536: PUSH
8537: LD_INT 1
8539: ARRAY
8540: PPUSH
8541: LD_VAR 0 2
8545: PUSH
8546: LD_INT 2
8548: ARRAY
8549: PPUSH
8550: CALL_OW 119
// Say ( tmp [ 1 ] , D1a-Merc1-1 ) ;
8554: LD_VAR 0 2
8558: PUSH
8559: LD_INT 1
8561: ARRAY
8562: PPUSH
8563: LD_STRING D1a-Merc1-1
8565: PPUSH
8566: CALL_OW 88
// Say ( tmp [ 2 ] , D1a-FMerc2-1 ) ;
8570: LD_VAR 0 2
8574: PUSH
8575: LD_INT 2
8577: ARRAY
8578: PPUSH
8579: LD_STRING D1a-FMerc2-1
8581: PPUSH
8582: CALL_OW 88
// ComHeal ( tmp [ 2 ] , tmp [ 1 ] ) ;
8586: LD_VAR 0 2
8590: PUSH
8591: LD_INT 2
8593: ARRAY
8594: PPUSH
8595: LD_VAR 0 2
8599: PUSH
8600: LD_INT 1
8602: ARRAY
8603: PPUSH
8604: CALL_OW 128
// SetLives ( tmp [ 1 ] , 500 ) ;
8608: LD_VAR 0 2
8612: PUSH
8613: LD_INT 1
8615: ARRAY
8616: PPUSH
8617: LD_INT 500
8619: PPUSH
8620: CALL_OW 234
// wait ( 0 0$2 ) ;
8624: LD_INT 70
8626: PPUSH
8627: CALL_OW 67
// SetLives ( tmp [ 1 ] , 2 ) ;
8631: LD_VAR 0 2
8635: PUSH
8636: LD_INT 1
8638: ARRAY
8639: PPUSH
8640: LD_INT 2
8642: PPUSH
8643: CALL_OW 234
// wait ( 0 0$0.3 ) ;
8647: LD_INT 10
8649: PPUSH
8650: CALL_OW 67
// ForceSay ( tmp [ 1 ] , D1a-Merc1-2 ) ;
8654: LD_VAR 0 2
8658: PUSH
8659: LD_INT 1
8661: ARRAY
8662: PPUSH
8663: LD_STRING D1a-Merc1-2
8665: PPUSH
8666: CALL_OW 91
// wait ( 0 0$0.2 ) ;
8670: LD_INT 7
8672: PPUSH
8673: CALL_OW 67
// KillUnit ( tmp [ 1 ] ) ;
8677: LD_VAR 0 2
8681: PUSH
8682: LD_INT 1
8684: ARRAY
8685: PPUSH
8686: CALL_OW 66
// ComMoveToArea ( tmp [ 2 ] , escape_area ) ;
8690: LD_VAR 0 2
8694: PUSH
8695: LD_INT 2
8697: ARRAY
8698: PPUSH
8699: LD_INT 10
8701: PPUSH
8702: CALL_OW 113
// Say ( tmp [ 2 ] , D1a-FMerc2-2 ) ;
8706: LD_VAR 0 2
8710: PUSH
8711: LD_INT 2
8713: ARRAY
8714: PPUSH
8715: LD_STRING D1a-FMerc2-2
8717: PPUSH
8718: CALL_OW 88
// wait ( 0 0$1 ) ;
8722: LD_INT 35
8724: PPUSH
8725: CALL_OW 67
// CenterOnUnits ( ar_dep_s ) ;
8729: LD_INT 7
8731: PPUSH
8732: CALL_OW 85
// wait ( 0 0$2 ) ;
8736: LD_INT 70
8738: PPUSH
8739: CALL_OW 67
// ForceSay ( Saliba , D1a-Saliba-1 ) ;
8743: LD_EXP 44
8747: PPUSH
8748: LD_STRING D1a-Saliba-1
8750: PPUSH
8751: CALL_OW 91
// KillUnit ( Saliba ) ;
8755: LD_EXP 44
8759: PPUSH
8760: CALL_OW 66
// ComExitBuilding ( tmp [ 3 ] ) ;
8764: LD_VAR 0 2
8768: PUSH
8769: LD_INT 3
8771: ARRAY
8772: PPUSH
8773: CALL_OW 122
// CenterOnUnits ( JMM ) ;
8777: LD_EXP 21
8781: PPUSH
8782: CALL_OW 85
// wait ( 0 0$1 ) ;
8786: LD_INT 35
8788: PPUSH
8789: CALL_OW 67
// ComMoveXY ( sols , 88 , 141 ) ;
8793: LD_VAR 0 5
8797: PPUSH
8798: LD_INT 88
8800: PPUSH
8801: LD_INT 141
8803: PPUSH
8804: CALL_OW 111
// AddComWait ( sols , 0 0$2 ) ;
8808: LD_VAR 0 5
8812: PPUSH
8813: LD_INT 70
8815: PPUSH
8816: CALL_OW 202
// wait ( 0 0$2 ) ;
8820: LD_INT 70
8822: PPUSH
8823: CALL_OW 67
// SetAttitude ( 2 , 1 , att_enemy , true ) ;
8827: LD_INT 2
8829: PPUSH
8830: LD_INT 1
8832: PPUSH
8833: LD_INT 2
8835: PPUSH
8836: LD_INT 1
8838: PPUSH
8839: CALL_OW 80
// InGameOff ;
8843: CALL_OW 9
// ComWalk ( sols ) ;
8847: LD_VAR 0 5
8851: PPUSH
8852: CALL_OW 138
// ChangeMissionObjectives ( M1 ) ;
8856: LD_STRING M1
8858: PPUSH
8859: CALL_OW 337
// game_speed := 4 ;
8863: LD_ADDR_OWVAR 65
8867: PUSH
8868: LD_INT 4
8870: ST_TO_ADDR
// RemoveSeeing ( 111 , 135 , 1 ) ;
8871: LD_INT 111
8873: PPUSH
8874: LD_INT 135
8876: PPUSH
8877: LD_INT 1
8879: PPUSH
8880: CALL_OW 331
// SaveForQuickRestart ;
8884: CALL_OW 22
// ar_run := true ;
8888: LD_ADDR_EXP 5
8892: PUSH
8893: LD_INT 1
8895: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8896: LD_INT 35
8898: PPUSH
8899: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 1 ] , [ f_dist , ar_dep_s , 10 ] ] ) or GetLives ( ar_dep_s ) < 999 ;
8903: LD_INT 22
8905: PUSH
8906: LD_INT 1
8908: PUSH
8909: EMPTY
8910: LIST
8911: LIST
8912: PUSH
8913: LD_INT 91
8915: PUSH
8916: LD_INT 7
8918: PUSH
8919: LD_INT 10
8921: PUSH
8922: EMPTY
8923: LIST
8924: LIST
8925: LIST
8926: PUSH
8927: EMPTY
8928: LIST
8929: LIST
8930: PPUSH
8931: CALL_OW 69
8935: PUSH
8936: LD_INT 7
8938: PPUSH
8939: CALL_OW 256
8943: PUSH
8944: LD_INT 999
8946: LESS
8947: OR
8948: IFFALSE 8896
// if GetSide ( ar_dep_s ) = 2 then
8950: LD_INT 7
8952: PPUSH
8953: CALL_OW 255
8957: PUSH
8958: LD_INT 2
8960: EQUAL
8961: IFFALSE 8973
// SetSide ( ar_dep_s , 1 ) ;
8963: LD_INT 7
8965: PPUSH
8966: LD_INT 1
8968: PPUSH
8969: CALL_OW 235
// end ;
8973: LD_VAR 0 1
8977: RET
// every 0 0$2 trigger ar_run do var i , tmp , k ;
8978: LD_EXP 5
8982: IFFALSE 9342
8984: GO 8986
8986: DISABLE
8987: LD_INT 0
8989: PPUSH
8990: PPUSH
8991: PPUSH
// begin tmp := ar_force_tmp ^ UnitFilter ( ar_force_south , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ) ;
8992: LD_ADDR_VAR 0 2
8996: PUSH
8997: LD_EXP 40
9001: PUSH
9002: LD_EXP 36
9006: PPUSH
9007: LD_INT 2
9009: PUSH
9010: LD_INT 21
9012: PUSH
9013: LD_INT 2
9015: PUSH
9016: EMPTY
9017: LIST
9018: LIST
9019: PUSH
9020: LD_INT 21
9022: PUSH
9023: LD_INT 1
9025: PUSH
9026: EMPTY
9027: LIST
9028: LIST
9029: PUSH
9030: EMPTY
9031: LIST
9032: LIST
9033: LIST
9034: PPUSH
9035: CALL_OW 72
9039: ADD
9040: ST_TO_ADDR
// SetSide ( tmp , 5 ) ;
9041: LD_VAR 0 2
9045: PPUSH
9046: LD_INT 5
9048: PPUSH
9049: CALL_OW 235
// ChangeSideFog ( 5 , 1 ) ;
9053: LD_INT 5
9055: PPUSH
9056: LD_INT 1
9058: PPUSH
9059: CALL_OW 343
// k := 1 ;
9063: LD_ADDR_VAR 0 3
9067: PUSH
9068: LD_INT 1
9070: ST_TO_ADDR
// for i in tmp do
9071: LD_ADDR_VAR 0 1
9075: PUSH
9076: LD_VAR 0 2
9080: PUSH
9081: FOR_IN
9082: IFFALSE 9167
// begin if IsInUnit ( i ) then
9084: LD_VAR 0 1
9088: PPUSH
9089: CALL_OW 310
9093: IFFALSE 9104
// ComExitBuilding ( i ) ;
9095: LD_VAR 0 1
9099: PPUSH
9100: CALL_OW 122
// if GetClass ( i ) = 3 then
9104: LD_VAR 0 1
9108: PPUSH
9109: CALL_OW 257
9113: PUSH
9114: LD_INT 3
9116: EQUAL
9117: IFFALSE 9153
// begin AddComEnterUnit ( i , ar_vehicles_tmp [ k ] ) ;
9119: LD_VAR 0 1
9123: PPUSH
9124: LD_EXP 41
9128: PUSH
9129: LD_VAR 0 3
9133: ARRAY
9134: PPUSH
9135: CALL_OW 180
// k := k + 1 ;
9139: LD_ADDR_VAR 0 3
9143: PUSH
9144: LD_VAR 0 3
9148: PUSH
9149: LD_INT 1
9151: PLUS
9152: ST_TO_ADDR
// end ; AddComMoveToArea ( i , escape_area ) ;
9153: LD_VAR 0 1
9157: PPUSH
9158: LD_INT 10
9160: PPUSH
9161: CALL_OW 173
// end ;
9165: GO 9081
9167: POP
9168: POP
// ar_patrol := true ;
9169: LD_ADDR_EXP 7
9173: PUSH
9174: LD_INT 1
9176: ST_TO_ADDR
// repeat wait ( 0 0$0.3 ) ;
9177: LD_INT 10
9179: PPUSH
9180: CALL_OW 67
// for i in tmp do
9184: LD_ADDR_VAR 0 1
9188: PUSH
9189: LD_VAR 0 2
9193: PUSH
9194: FOR_IN
9195: IFFALSE 9223
// if not HasTask ( i ) then
9197: LD_VAR 0 1
9201: PPUSH
9202: CALL_OW 314
9206: NOT
9207: IFFALSE 9221
// ComMoveToArea ( i , escape_area ) ;
9209: LD_VAR 0 1
9213: PPUSH
9214: LD_INT 10
9216: PPUSH
9217: CALL_OW 113
9221: GO 9194
9223: POP
9224: POP
// k := UnitFilter ( tmp , [ f_inarea , escape_area ] ) ;
9225: LD_ADDR_VAR 0 3
9229: PUSH
9230: LD_VAR 0 2
9234: PPUSH
9235: LD_INT 95
9237: PUSH
9238: LD_INT 10
9240: PUSH
9241: EMPTY
9242: LIST
9243: LIST
9244: PPUSH
9245: CALL_OW 72
9249: ST_TO_ADDR
// if k then
9250: LD_VAR 0 3
9254: IFFALSE 9323
// for i in k do
9256: LD_ADDR_VAR 0 1
9260: PUSH
9261: LD_VAR 0 3
9265: PUSH
9266: FOR_IN
9267: IFFALSE 9321
// begin if IsInUnit ( i ) then
9269: LD_VAR 0 1
9273: PPUSH
9274: CALL_OW 310
9278: IFFALSE 9294
// RemoveUnit ( IsInUnit ( i ) ) ;
9280: LD_VAR 0 1
9284: PPUSH
9285: CALL_OW 310
9289: PPUSH
9290: CALL_OW 64
// RemoveUnit ( i ) ;
9294: LD_VAR 0 1
9298: PPUSH
9299: CALL_OW 64
// tmp := tmp diff i ;
9303: LD_ADDR_VAR 0 2
9307: PUSH
9308: LD_VAR 0 2
9312: PUSH
9313: LD_VAR 0 1
9317: DIFF
9318: ST_TO_ADDR
// end ;
9319: GO 9266
9321: POP
9322: POP
// until tmp = [ ] ;
9323: LD_VAR 0 2
9327: PUSH
9328: EMPTY
9329: EQUAL
9330: IFFALSE 9177
// ChangeSideFog ( 5 , 5 ) ;
9332: LD_INT 5
9334: PPUSH
9335: LD_INT 5
9337: PPUSH
9338: CALL_OW 343
// end ;
9342: PPOPN 3
9344: END
// every 0 0$03 trigger ar_patrol do var i , un , veh ;
9345: LD_EXP 7
9349: IFFALSE 9639
9351: GO 9353
9353: DISABLE
9354: LD_INT 0
9356: PPUSH
9357: PPUSH
9358: PPUSH
// begin uc_side := 2 ;
9359: LD_ADDR_OWVAR 20
9363: PUSH
9364: LD_INT 2
9366: ST_TO_ADDR
// uc_nation := 2 ;
9367: LD_ADDR_OWVAR 21
9371: PUSH
9372: LD_INT 2
9374: ST_TO_ADDR
// InitHc ;
9375: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
9379: LD_INT 1
9381: PPUSH
9382: LD_INT 1
9384: PPUSH
9385: LD_INT 6
9387: PPUSH
9388: CALL_OW 380
// un := CreateHuman ;
9392: LD_ADDR_VAR 0 2
9396: PUSH
9397: CALL_OW 44
9401: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_combustion , control_manual , ar_gun , 98 ) ;
9402: LD_INT 14
9404: PPUSH
9405: LD_INT 1
9407: PPUSH
9408: LD_INT 1
9410: PPUSH
9411: LD_INT 27
9413: PPUSH
9414: LD_INT 98
9416: PPUSH
9417: CALL 54265 0 5
// veh := CreateVehicle ;
9421: LD_ADDR_VAR 0 3
9425: PUSH
9426: CALL_OW 45
9430: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
9431: LD_VAR 0 3
9435: PPUSH
9436: LD_INT 4
9438: PPUSH
9439: CALL_OW 233
// PlaceUnitXY ( veh , 179 , 135 , false ) ;
9443: LD_VAR 0 3
9447: PPUSH
9448: LD_INT 179
9450: PPUSH
9451: LD_INT 135
9453: PPUSH
9454: LD_INT 0
9456: PPUSH
9457: CALL_OW 48
// PlaceHumanInUnit ( un , veh ) ;
9461: LD_VAR 0 2
9465: PPUSH
9466: LD_VAR 0 3
9470: PPUSH
9471: CALL_OW 52
// ComMoveXY ( un , 126 , 133 ) ;
9475: LD_VAR 0 2
9479: PPUSH
9480: LD_INT 126
9482: PPUSH
9483: LD_INT 133
9485: PPUSH
9486: CALL_OW 111
// repeat wait ( 0 0$0.3 ) ;
9490: LD_INT 10
9492: PPUSH
9493: CALL_OW 67
// until See ( 1 , veh ) or GetDistUnits ( veh , ar_dep_s ) < 9 ;
9497: LD_INT 1
9499: PPUSH
9500: LD_VAR 0 3
9504: PPUSH
9505: CALL_OW 292
9509: PUSH
9510: LD_VAR 0 3
9514: PPUSH
9515: LD_INT 7
9517: PPUSH
9518: CALL_OW 296
9522: PUSH
9523: LD_INT 9
9525: LESS
9526: OR
9527: IFFALSE 9490
// ComHold ( veh ) ;
9529: LD_VAR 0 3
9533: PPUSH
9534: CALL_OW 140
// Say ( un , D2aa-Ar1-1 ) ;
9538: LD_VAR 0 2
9542: PPUSH
9543: LD_STRING D2aa-Ar1-1
9545: PPUSH
9546: CALL_OW 88
// ComMoveXY ( un , 177 , 96 ) ;
9550: LD_VAR 0 2
9554: PPUSH
9555: LD_INT 177
9557: PPUSH
9558: LD_INT 96
9560: PPUSH
9561: CALL_OW 111
// AddComExitVehicle ( un ) ;
9565: LD_VAR 0 2
9569: PPUSH
9570: CALL_OW 181
// repeat wait ( 0 0$1 ) ;
9574: LD_INT 35
9576: PPUSH
9577: CALL_OW 67
// until GetDistUnits ( un , ar_dep_e ) < 15 ;
9581: LD_VAR 0 2
9585: PPUSH
9586: LD_INT 204
9588: PPUSH
9589: CALL_OW 296
9593: PUSH
9594: LD_INT 15
9596: LESS
9597: IFFALSE 9574
// mc_bases := ReplaceIn ( mc_bases , [ 3 , mc_bases [ 3 ] + 1 ] , un ) ;
9599: LD_ADDR_EXP 50
9603: PUSH
9604: LD_EXP 50
9608: PPUSH
9609: LD_INT 3
9611: PUSH
9612: LD_EXP 50
9616: PUSH
9617: LD_INT 3
9619: ARRAY
9620: PUSH
9621: LD_INT 1
9623: PLUS
9624: PUSH
9625: EMPTY
9626: LIST
9627: LIST
9628: PPUSH
9629: LD_VAR 0 2
9633: PPUSH
9634: CALL 54387 0 3
9638: ST_TO_ADDR
// end ;
9639: PPOPN 3
9641: END
// every 0 0$2 trigger GetSide ( ar_dep_s ) = 1 or IsDead ( ar_dep_s ) do var i , points ;
9642: LD_INT 7
9644: PPUSH
9645: CALL_OW 255
9649: PUSH
9650: LD_INT 1
9652: EQUAL
9653: PUSH
9654: LD_INT 7
9656: PPUSH
9657: CALL_OW 301
9661: OR
9662: IFFALSE 12086
9664: GO 9666
9666: DISABLE
9667: LD_INT 0
9669: PPUSH
9670: PPUSH
// begin for i in UnitFilter ( ar_force_south , [ f_type , unit_building ] ) do
9671: LD_ADDR_VAR 0 1
9675: PUSH
9676: LD_EXP 36
9680: PPUSH
9681: LD_INT 21
9683: PUSH
9684: LD_INT 3
9686: PUSH
9687: EMPTY
9688: LIST
9689: LIST
9690: PPUSH
9691: CALL_OW 72
9695: PUSH
9696: FOR_IN
9697: IFFALSE 9713
// SetSide ( i , 1 ) ;
9699: LD_VAR 0 1
9703: PPUSH
9704: LD_INT 1
9706: PPUSH
9707: CALL_OW 235
9711: GO 9696
9713: POP
9714: POP
// points := [ [ 46 , 41 ] , [ 50 , 25 ] , [ 57 , 75 ] , [ 75 , 89 ] , [ 51 , 45 ] , [ 95 , 95 ] , [ 84 , 77 ] , [ 101 , 76 ] , [ 118 , 81 ] , [ 139 , 97 ] , [ 129 , 114 ] , [ 154 , 111 ] ] ;
9715: LD_ADDR_VAR 0 2
9719: PUSH
9720: LD_INT 46
9722: PUSH
9723: LD_INT 41
9725: PUSH
9726: EMPTY
9727: LIST
9728: LIST
9729: PUSH
9730: LD_INT 50
9732: PUSH
9733: LD_INT 25
9735: PUSH
9736: EMPTY
9737: LIST
9738: LIST
9739: PUSH
9740: LD_INT 57
9742: PUSH
9743: LD_INT 75
9745: PUSH
9746: EMPTY
9747: LIST
9748: LIST
9749: PUSH
9750: LD_INT 75
9752: PUSH
9753: LD_INT 89
9755: PUSH
9756: EMPTY
9757: LIST
9758: LIST
9759: PUSH
9760: LD_INT 51
9762: PUSH
9763: LD_INT 45
9765: PUSH
9766: EMPTY
9767: LIST
9768: LIST
9769: PUSH
9770: LD_INT 95
9772: PUSH
9773: LD_INT 95
9775: PUSH
9776: EMPTY
9777: LIST
9778: LIST
9779: PUSH
9780: LD_INT 84
9782: PUSH
9783: LD_INT 77
9785: PUSH
9786: EMPTY
9787: LIST
9788: LIST
9789: PUSH
9790: LD_INT 101
9792: PUSH
9793: LD_INT 76
9795: PUSH
9796: EMPTY
9797: LIST
9798: LIST
9799: PUSH
9800: LD_INT 118
9802: PUSH
9803: LD_INT 81
9805: PUSH
9806: EMPTY
9807: LIST
9808: LIST
9809: PUSH
9810: LD_INT 139
9812: PUSH
9813: LD_INT 97
9815: PUSH
9816: EMPTY
9817: LIST
9818: LIST
9819: PUSH
9820: LD_INT 129
9822: PUSH
9823: LD_INT 114
9825: PUSH
9826: EMPTY
9827: LIST
9828: LIST
9829: PUSH
9830: LD_INT 154
9832: PUSH
9833: LD_INT 111
9835: PUSH
9836: EMPTY
9837: LIST
9838: LIST
9839: PUSH
9840: EMPTY
9841: LIST
9842: LIST
9843: LIST
9844: LIST
9845: LIST
9846: LIST
9847: LIST
9848: LIST
9849: LIST
9850: LIST
9851: LIST
9852: LIST
9853: ST_TO_ADDR
// base_captured := true ;
9854: LD_ADDR_EXP 6
9858: PUSH
9859: LD_INT 1
9861: ST_TO_ADDR
// DialogueOn ;
9862: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
9866: LD_EXP 21
9870: PPUSH
9871: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
9875: LD_EXP 21
9879: PPUSH
9880: LD_STRING D2-JMM-1
9882: PPUSH
9883: CALL_OW 88
// SayRadio ( Powell , D2-Pow-1 ) ;
9887: LD_EXP 30
9891: PPUSH
9892: LD_STRING D2-Pow-1
9894: PPUSH
9895: CALL_OW 94
// Say ( JMM , D2-JMM-2 ) ;
9899: LD_EXP 21
9903: PPUSH
9904: LD_STRING D2-JMM-2
9906: PPUSH
9907: CALL_OW 88
// SayRadio ( Powell , D2-Pow-2 ) ;
9911: LD_EXP 30
9915: PPUSH
9916: LD_STRING D2-Pow-2
9918: PPUSH
9919: CALL_OW 94
// Say ( JMM , D2-JMM-3 ) ;
9923: LD_EXP 21
9927: PPUSH
9928: LD_STRING D2-JMM-3
9930: PPUSH
9931: CALL_OW 88
// DialogueOff ;
9935: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
9939: LD_STRING M2
9941: PPUSH
9942: CALL_OW 337
// Wait ( 0 0$2 ) ;
9946: LD_INT 70
9948: PPUSH
9949: CALL_OW 67
// if IsOk ( Gary ) then
9953: LD_EXP 32
9957: PPUSH
9958: CALL_OW 302
9962: IFFALSE 9976
// Say ( Gary , D2a-Gary-1 ) ;
9964: LD_EXP 32
9968: PPUSH
9969: LD_STRING D2a-Gary-1
9971: PPUSH
9972: CALL_OW 88
// if IsOk ( Bobby ) then
9976: LD_EXP 24
9980: PPUSH
9981: CALL_OW 302
9985: IFFALSE 9999
// Say ( Bobby , D2a-Bobby-1 ) ;
9987: LD_EXP 24
9991: PPUSH
9992: LD_STRING D2a-Bobby-1
9994: PPUSH
9995: CALL_OW 88
// if IsOk ( Cyrus ) then
9999: LD_EXP 25
10003: PPUSH
10004: CALL_OW 302
10008: IFFALSE 10022
// Say ( Cyrus , D2a-Cyrus-1 ) ;
10010: LD_EXP 25
10014: PPUSH
10015: LD_STRING D2a-Cyrus-1
10017: PPUSH
10018: CALL_OW 88
// if IsOk ( Lisa ) then
10022: LD_EXP 22
10026: PPUSH
10027: CALL_OW 302
10031: IFFALSE 10045
// Say ( Lisa , D2a-Lisa-1 ) ;
10033: LD_EXP 22
10037: PPUSH
10038: LD_STRING D2a-Lisa-1
10040: PPUSH
10041: CALL_OW 88
// if IsOk ( Frank ) then
10045: LD_EXP 33
10049: PPUSH
10050: CALL_OW 302
10054: IFFALSE 10068
// Say ( Frank , D2a-Frank-1 ) ;
10056: LD_EXP 33
10060: PPUSH
10061: LD_STRING D2a-Frank-1
10063: PPUSH
10064: CALL_OW 88
// if IsOk ( Cornel ) then
10068: LD_EXP 31
10072: PPUSH
10073: CALL_OW 302
10077: IFFALSE 10091
// Say ( Cornel , D2a-Corn-1 ) ;
10079: LD_EXP 31
10083: PPUSH
10084: LD_STRING D2a-Corn-1
10086: PPUSH
10087: CALL_OW 88
// if IsOk ( Donaldson ) then
10091: LD_EXP 23
10095: PPUSH
10096: CALL_OW 302
10100: IFFALSE 10114
// Say ( Donaldson , D2a-Don-1 ) ;
10102: LD_EXP 23
10106: PPUSH
10107: LD_STRING D2a-Don-1
10109: PPUSH
10110: CALL_OW 88
// if IsOk ( Brown ) then
10114: LD_EXP 27
10118: PPUSH
10119: CALL_OW 302
10123: IFFALSE 10137
// Say ( Brown , D2a-Brown-1 ) ;
10125: LD_EXP 27
10129: PPUSH
10130: LD_STRING D2a-Brown-1
10132: PPUSH
10133: CALL_OW 88
// Wait ( 0 0$30 ) ;
10137: LD_INT 1050
10139: PPUSH
10140: CALL_OW 67
// if IsOk ( Frank ) then
10144: LD_EXP 33
10148: PPUSH
10149: CALL_OW 302
10153: IFFALSE 10419
// begin DialogueOn ;
10155: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Frank ] ) ;
10159: LD_EXP 21
10163: PUSH
10164: LD_EXP 33
10168: PUSH
10169: EMPTY
10170: LIST
10171: LIST
10172: PPUSH
10173: CALL_OW 87
// Say ( Frank , D3F-Frank-1 ) ;
10177: LD_EXP 33
10181: PPUSH
10182: LD_STRING D3F-Frank-1
10184: PPUSH
10185: CALL_OW 88
// Say ( JMM , D3F-JMM-1 ) ;
10189: LD_EXP 21
10193: PPUSH
10194: LD_STRING D3F-JMM-1
10196: PPUSH
10197: CALL_OW 88
// Say ( Frank , D3F-Frank-2 ) ;
10201: LD_EXP 33
10205: PPUSH
10206: LD_STRING D3F-Frank-2
10208: PPUSH
10209: CALL_OW 88
// case Query ( QFrank ) of 1 :
10213: LD_STRING QFrank
10215: PPUSH
10216: CALL_OW 97
10220: PUSH
10221: LD_INT 1
10223: DOUBLE
10224: EQUAL
10225: IFTRUE 10229
10227: GO 10252
10229: POP
// begin Say ( JMM , D3Fa-JMM-1 ) ;
10230: LD_EXP 21
10234: PPUSH
10235: LD_STRING D3Fa-JMM-1
10237: PPUSH
10238: CALL_OW 88
// us_scout := 1 ;
10242: LD_ADDR_EXP 8
10246: PUSH
10247: LD_INT 1
10249: ST_TO_ADDR
// end ; 2 :
10250: GO 10415
10252: LD_INT 2
10254: DOUBLE
10255: EQUAL
10256: IFTRUE 10260
10258: GO 10382
10260: POP
// begin Say ( JMM , D3Fb-JMM-1 ) ;
10261: LD_EXP 21
10265: PPUSH
10266: LD_STRING D3Fb-JMM-1
10268: PPUSH
10269: CALL_OW 88
// Say ( Frank , D3Fb-Frank-1 ) ;
10273: LD_EXP 33
10277: PPUSH
10278: LD_STRING D3Fb-Frank-1
10280: PPUSH
10281: CALL_OW 88
// case Query ( QFrank2 ) of 1 :
10285: LD_STRING QFrank2
10287: PPUSH
10288: CALL_OW 97
10292: PUSH
10293: LD_INT 1
10295: DOUBLE
10296: EQUAL
10297: IFTRUE 10301
10299: GO 10348
10301: POP
// begin us_scout := 2 ;
10302: LD_ADDR_EXP 8
10306: PUSH
10307: LD_INT 2
10309: ST_TO_ADDR
// Say ( JMM , D3Fba-JMM-1 ) ;
10310: LD_EXP 21
10314: PPUSH
10315: LD_STRING D3Fba-JMM-1
10317: PPUSH
10318: CALL_OW 88
// Say ( Frank , D3Fba-Frank-1 ) ;
10322: LD_EXP 33
10326: PPUSH
10327: LD_STRING D3Fba-Frank-1
10329: PPUSH
10330: CALL_OW 88
// Say ( JMM , D3Fba-JMM-2 ) ;
10334: LD_EXP 21
10338: PPUSH
10339: LD_STRING D3Fba-JMM-2
10341: PPUSH
10342: CALL_OW 88
// end ; 2 :
10346: GO 10380
10348: LD_INT 2
10350: DOUBLE
10351: EQUAL
10352: IFTRUE 10356
10354: GO 10379
10356: POP
// begin us_scout := 0 ;
10357: LD_ADDR_EXP 8
10361: PUSH
10362: LD_INT 0
10364: ST_TO_ADDR
// Say ( JMM , D3Fbb-JMM-1 ) ;
10365: LD_EXP 21
10369: PPUSH
10370: LD_STRING D3Fbb-JMM-1
10372: PPUSH
10373: CALL_OW 88
// end ; end ;
10377: GO 10380
10379: POP
// end ; 3 :
10380: GO 10415
10382: LD_INT 3
10384: DOUBLE
10385: EQUAL
10386: IFTRUE 10390
10388: GO 10414
10390: POP
// begin us_scout := - 1 ;
10391: LD_ADDR_EXP 8
10395: PUSH
10396: LD_INT 1
10398: NEG
10399: ST_TO_ADDR
// Say ( JMM , D3Fc-JMM-1 ) ;
10400: LD_EXP 21
10404: PPUSH
10405: LD_STRING D3Fc-JMM-1
10407: PPUSH
10408: CALL_OW 88
// end ; end ;
10412: GO 10415
10414: POP
// DialogueOff ;
10415: CALL_OW 7
// end ; if us_scout in [ - 1 , 0 ] then
10419: LD_EXP 8
10423: PUSH
10424: LD_INT 1
10426: NEG
10427: PUSH
10428: LD_INT 0
10430: PUSH
10431: EMPTY
10432: LIST
10433: LIST
10434: IN
10435: IFFALSE 10439
// exit ;
10437: GO 12086
// if us_scout in [ 1 , 2 ] then
10439: LD_EXP 8
10443: PUSH
10444: LD_INT 1
10446: PUSH
10447: LD_INT 2
10449: PUSH
10450: EMPTY
10451: LIST
10452: LIST
10453: IN
10454: IFFALSE 11153
// begin if IsInUnit ( Frank ) then
10456: LD_EXP 33
10460: PPUSH
10461: CALL_OW 310
10465: IFFALSE 10476
// ComExitBuilding ( Frank ) ;
10467: LD_EXP 33
10471: PPUSH
10472: CALL_OW 122
// if IsDrivenBy ( Frank ) then
10476: LD_EXP 33
10480: PPUSH
10481: CALL_OW 311
10485: IFFALSE 10496
// ComExitVehicle ( Frank ) ;
10487: LD_EXP 33
10491: PPUSH
10492: CALL_OW 121
// SetSide ( Frank , 4 ) ;
10496: LD_EXP 33
10500: PPUSH
10501: LD_INT 4
10503: PPUSH
10504: CALL_OW 235
// wait ( 0 0$1 ) ;
10508: LD_INT 35
10510: PPUSH
10511: CALL_OW 67
// if us_scout = 2 then
10515: LD_EXP 8
10519: PUSH
10520: LD_INT 2
10522: EQUAL
10523: IFFALSE 10891
// begin ComMoveXY ( Frank , 75 , 63 ) ;
10525: LD_EXP 33
10529: PPUSH
10530: LD_INT 75
10532: PPUSH
10533: LD_INT 63
10535: PPUSH
10536: CALL_OW 111
// AddComHold ( Frank ) ;
10540: LD_EXP 33
10544: PPUSH
10545: CALL_OW 200
// AddComWait ( Frank , 0 0$22 ) ;
10549: LD_EXP 33
10553: PPUSH
10554: LD_INT 770
10556: PPUSH
10557: CALL_OW 202
// AddComMoveXY ( Frank , 100 , 75 ) ;
10561: LD_EXP 33
10565: PPUSH
10566: LD_INT 100
10568: PPUSH
10569: LD_INT 75
10571: PPUSH
10572: CALL_OW 171
// AddComMoveXY ( Frank , 123 , 103 ) ;
10576: LD_EXP 33
10580: PPUSH
10581: LD_INT 123
10583: PPUSH
10584: LD_INT 103
10586: PPUSH
10587: CALL_OW 171
// AddComMoveXY ( Frank , 138 , 108 ) ;
10591: LD_EXP 33
10595: PPUSH
10596: LD_INT 138
10598: PPUSH
10599: LD_INT 108
10601: PPUSH
10602: CALL_OW 171
// AddComHold ( Frank ) ;
10606: LD_EXP 33
10610: PPUSH
10611: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
10615: LD_INT 35
10617: PPUSH
10618: CALL_OW 67
// until IsAt ( Frank , 138 , 108 ) ;
10622: LD_EXP 33
10626: PPUSH
10627: LD_INT 138
10629: PPUSH
10630: LD_INT 108
10632: PPUSH
10633: CALL_OW 307
10637: IFFALSE 10615
// AddComMoveXY ( Frank , 125 , 132 ) ;
10639: LD_EXP 33
10643: PPUSH
10644: LD_INT 125
10646: PPUSH
10647: LD_INT 132
10649: PPUSH
10650: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
10654: LD_INT 35
10656: PPUSH
10657: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 7 ;
10661: LD_INT 1
10663: PPUSH
10664: LD_EXP 33
10668: PPUSH
10669: CALL_OW 292
10673: PUSH
10674: LD_EXP 33
10678: PPUSH
10679: LD_INT 7
10681: PPUSH
10682: CALL_OW 296
10686: PUSH
10687: LD_INT 7
10689: LESS
10690: OR
10691: IFFALSE 10654
// DialogueOn ;
10693: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
10697: LD_EXP 33
10701: PPUSH
10702: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
10706: LD_INT 10
10708: PPUSH
10709: CALL_OW 68
// Say ( JMM , D4Fa-JMM-1 ) ;
10713: LD_EXP 21
10717: PPUSH
10718: LD_STRING D4Fa-JMM-1
10720: PPUSH
10721: CALL_OW 88
// for i in points do
10725: LD_ADDR_VAR 0 1
10729: PUSH
10730: LD_VAR 0 2
10734: PUSH
10735: FOR_IN
10736: IFFALSE 10794
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
10738: LD_VAR 0 1
10742: PUSH
10743: LD_INT 1
10745: ARRAY
10746: PPUSH
10747: LD_VAR 0 1
10751: PUSH
10752: LD_INT 2
10754: ARRAY
10755: PPUSH
10756: LD_INT 1
10758: PPUSH
10759: LD_INT 20
10761: NEG
10762: PPUSH
10763: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
10767: LD_VAR 0 1
10771: PUSH
10772: LD_INT 1
10774: ARRAY
10775: PPUSH
10776: LD_VAR 0 1
10780: PUSH
10781: LD_INT 2
10783: ARRAY
10784: PPUSH
10785: LD_INT 1
10787: PPUSH
10788: CALL_OW 331
// end ;
10792: GO 10735
10794: POP
10795: POP
// dwait ( 0 0$0.5 ) ;
10796: LD_INT 18
10798: PPUSH
10799: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
10803: LD_INT 42
10805: PPUSH
10806: LD_INT 27
10808: PPUSH
10809: CALL_OW 84
// Say ( Frank , D4Fa-Frank-1 ) ;
10813: LD_EXP 33
10817: PPUSH
10818: LD_STRING D4Fa-Frank-1
10820: PPUSH
10821: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
10825: LD_INT 18
10827: PPUSH
10828: CALL_OW 68
// Say ( JMM , D4Fa-JMM-2 ) ;
10832: LD_EXP 21
10836: PPUSH
10837: LD_STRING D4Fa-JMM-2
10839: PPUSH
10840: CALL_OW 88
// CenterNowOnXY ( 118 , 80 ) ;
10844: LD_INT 118
10846: PPUSH
10847: LD_INT 80
10849: PPUSH
10850: CALL_OW 86
// Say ( Frank , D4Fa-Frank-2 ) ;
10854: LD_EXP 33
10858: PPUSH
10859: LD_STRING D4Fa-Frank-2
10861: PPUSH
10862: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
10866: LD_INT 10
10868: PPUSH
10869: CALL_OW 68
// DialogueOff ;
10873: CALL_OW 7
// SetSide ( Frank , 1 ) ;
10877: LD_EXP 33
10881: PPUSH
10882: LD_INT 1
10884: PPUSH
10885: CALL_OW 235
// end else
10889: GO 11153
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
10891: LD_INT 2
10893: PPUSH
10894: LD_INT 4
10896: PPUSH
10897: LD_INT 2
10899: PPUSH
10900: LD_INT 1
10902: PPUSH
10903: CALL_OW 80
// ComMoveXY ( Frank , 75 , 63 ) ;
10907: LD_EXP 33
10911: PPUSH
10912: LD_INT 75
10914: PPUSH
10915: LD_INT 63
10917: PPUSH
10918: CALL_OW 111
// AddComWait ( Frank , 0 0$5 ) ;
10922: LD_EXP 33
10926: PPUSH
10927: LD_INT 175
10929: PPUSH
10930: CALL_OW 202
// AddComMoveXY ( Frank , 102 , 76 ) ;
10934: LD_EXP 33
10938: PPUSH
10939: LD_INT 102
10941: PPUSH
10942: LD_INT 76
10944: PPUSH
10945: CALL_OW 171
// AddComMoveXY ( Frank , 108 , 70 ) ;
10949: LD_EXP 33
10953: PPUSH
10954: LD_INT 108
10956: PPUSH
10957: LD_INT 70
10959: PPUSH
10960: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
10964: LD_INT 35
10966: PPUSH
10967: CALL_OW 67
// until See ( 2 , Frank ) ;
10971: LD_INT 2
10973: PPUSH
10974: LD_EXP 33
10978: PPUSH
10979: CALL_OW 292
10983: IFFALSE 10964
// ComMoveXY ( Frank , 112 , 118 ) ;
10985: LD_EXP 33
10989: PPUSH
10990: LD_INT 112
10992: PPUSH
10993: LD_INT 118
10995: PPUSH
10996: CALL_OW 111
// if GetLives ( Frank ) >= 750 then
11000: LD_EXP 33
11004: PPUSH
11005: CALL_OW 256
11009: PUSH
11010: LD_INT 750
11012: GREATEREQUAL
11013: IFFALSE 11027
// SetLives ( Frank , 700 ) ;
11015: LD_EXP 33
11019: PPUSH
11020: LD_INT 700
11022: PPUSH
11023: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
11027: LD_INT 35
11029: PPUSH
11030: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 17 ;
11034: LD_INT 1
11036: PPUSH
11037: LD_EXP 33
11041: PPUSH
11042: CALL_OW 292
11046: PUSH
11047: LD_EXP 33
11051: PPUSH
11052: LD_INT 7
11054: PPUSH
11055: CALL_OW 296
11059: PUSH
11060: LD_INT 17
11062: LESS
11063: OR
11064: IFFALSE 11027
// DialogueOn ;
11066: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11070: LD_EXP 33
11074: PPUSH
11075: CALL_OW 87
// Say ( Frank , D4Fb-Frank-1 ) ;
11079: LD_EXP 33
11083: PPUSH
11084: LD_STRING D4Fb-Frank-1
11086: PPUSH
11087: CALL_OW 88
// Say ( JMM , D4Fb-JMM-1 ) ;
11091: LD_EXP 21
11095: PPUSH
11096: LD_STRING D4Fb-JMM-1
11098: PPUSH
11099: CALL_OW 88
// SayRand ( sex_female , D4Fb-FSci1-1 ) ;
11103: LD_INT 2
11105: PPUSH
11106: LD_STRING D4Fb-FSci1-1
11108: PPUSH
11109: CALL 15911 0 2
// Say ( Frank , D4Fb-Frank-2 ) ;
11113: LD_EXP 33
11117: PPUSH
11118: LD_STRING D4Fb-Frank-2
11120: PPUSH
11121: CALL_OW 88
// Say ( JMM , D4Fb-JMM-2 ) ;
11125: LD_EXP 21
11129: PPUSH
11130: LD_STRING D4Fb-JMM-2
11132: PPUSH
11133: CALL_OW 88
// DialogueOff ;
11137: CALL_OW 7
// SetSide ( Frank , 1 ) ;
11141: LD_EXP 33
11145: PPUSH
11146: LD_INT 1
11148: PPUSH
11149: CALL_OW 235
// end ; end ; if IsOk ( Kikuchi ) and not Frank then
11153: LD_EXP 34
11157: PPUSH
11158: CALL_OW 302
11162: PUSH
11163: LD_EXP 33
11167: NOT
11168: AND
11169: IFFALSE 11317
// begin DialogueOn ;
11171: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Kikuchi ] ) ;
11175: LD_EXP 21
11179: PUSH
11180: LD_EXP 34
11184: PUSH
11185: EMPTY
11186: LIST
11187: LIST
11188: PPUSH
11189: CALL_OW 87
// Say ( Kikuchi , D3Y-Yam-1 ) ;
11193: LD_EXP 34
11197: PPUSH
11198: LD_STRING D3Y-Yam-1
11200: PPUSH
11201: CALL_OW 88
// Say ( JMM , D3Y-JMM-1 ) ;
11205: LD_EXP 21
11209: PPUSH
11210: LD_STRING D3Y-JMM-1
11212: PPUSH
11213: CALL_OW 88
// Say ( Kikuchi , D3Y-Yam-2 ) ;
11217: LD_EXP 34
11221: PPUSH
11222: LD_STRING D3Y-Yam-2
11224: PPUSH
11225: CALL_OW 88
// case Query ( QYamoko ) of 1 :
11229: LD_STRING QYamoko
11231: PPUSH
11232: CALL_OW 97
11236: PUSH
11237: LD_INT 1
11239: DOUBLE
11240: EQUAL
11241: IFTRUE 11245
11243: GO 11280
11245: POP
// begin Say ( JMM , D3Ya-JMM-1 ) ;
11246: LD_EXP 21
11250: PPUSH
11251: LD_STRING D3Ya-JMM-1
11253: PPUSH
11254: CALL_OW 88
// Say ( Kikuchi , D3Ya-Yam-1 ) ;
11258: LD_EXP 34
11262: PPUSH
11263: LD_STRING D3Ya-Yam-1
11265: PPUSH
11266: CALL_OW 88
// us_scout := 1 ;
11270: LD_ADDR_EXP 8
11274: PUSH
11275: LD_INT 1
11277: ST_TO_ADDR
// end ; 2 :
11278: GO 11313
11280: LD_INT 2
11282: DOUBLE
11283: EQUAL
11284: IFTRUE 11288
11286: GO 11312
11288: POP
// begin us_scout := - 1 ;
11289: LD_ADDR_EXP 8
11293: PUSH
11294: LD_INT 1
11296: NEG
11297: ST_TO_ADDR
// Say ( JMM , D3Yb-JMM-1 ) ;
11298: LD_EXP 21
11302: PPUSH
11303: LD_STRING D3Yb-JMM-1
11305: PPUSH
11306: CALL_OW 88
// end ; end ;
11310: GO 11313
11312: POP
// DialogueOff ;
11313: CALL_OW 7
// end ; if Frank then
11317: LD_EXP 33
11321: IFFALSE 11325
// exit ;
11323: GO 12086
// if us_scout in [ - 1 , 0 ] then
11325: LD_EXP 8
11329: PUSH
11330: LD_INT 1
11332: NEG
11333: PUSH
11334: LD_INT 0
11336: PUSH
11337: EMPTY
11338: LIST
11339: LIST
11340: IN
11341: IFFALSE 11345
// exit ;
11343: GO 12086
// us_scout := [ 2 , 2 , 1 ] [ Difficulty ] ;
11345: LD_ADDR_EXP 8
11349: PUSH
11350: LD_INT 2
11352: PUSH
11353: LD_INT 2
11355: PUSH
11356: LD_INT 1
11358: PUSH
11359: EMPTY
11360: LIST
11361: LIST
11362: LIST
11363: PUSH
11364: LD_OWVAR 67
11368: ARRAY
11369: ST_TO_ADDR
// if us_scout in [ 1 , 2 ] then
11370: LD_EXP 8
11374: PUSH
11375: LD_INT 1
11377: PUSH
11378: LD_INT 2
11380: PUSH
11381: EMPTY
11382: LIST
11383: LIST
11384: IN
11385: IFFALSE 12086
// begin if IsInUnit ( Kikuchi ) then
11387: LD_EXP 34
11391: PPUSH
11392: CALL_OW 310
11396: IFFALSE 11407
// ComExitBuilding ( Kikuchi ) ;
11398: LD_EXP 34
11402: PPUSH
11403: CALL_OW 122
// if IsDrivenBy ( Kikuchi ) then
11407: LD_EXP 34
11411: PPUSH
11412: CALL_OW 311
11416: IFFALSE 11427
// ComExitVehicle ( Kikuchi ) ;
11418: LD_EXP 34
11422: PPUSH
11423: CALL_OW 121
// SetSide ( Kikuchi , 4 ) ;
11427: LD_EXP 34
11431: PPUSH
11432: LD_INT 4
11434: PPUSH
11435: CALL_OW 235
// wait ( 0 0$1 ) ;
11439: LD_INT 35
11441: PPUSH
11442: CALL_OW 67
// if us_scout = 2 then
11446: LD_EXP 8
11450: PUSH
11451: LD_INT 2
11453: EQUAL
11454: IFFALSE 11834
// begin ComMoveXY ( Kikuchi , 75 , 63 ) ;
11456: LD_EXP 34
11460: PPUSH
11461: LD_INT 75
11463: PPUSH
11464: LD_INT 63
11466: PPUSH
11467: CALL_OW 111
// AddComHold ( Kikuchi ) ;
11471: LD_EXP 34
11475: PPUSH
11476: CALL_OW 200
// AddComWait ( Kikuchi , 0 0$22 ) ;
11480: LD_EXP 34
11484: PPUSH
11485: LD_INT 770
11487: PPUSH
11488: CALL_OW 202
// AddComMoveXY ( Kikuchi , 100 , 75 ) ;
11492: LD_EXP 34
11496: PPUSH
11497: LD_INT 100
11499: PPUSH
11500: LD_INT 75
11502: PPUSH
11503: CALL_OW 171
// AddComMoveXY ( Kikuchi , 123 , 103 ) ;
11507: LD_EXP 34
11511: PPUSH
11512: LD_INT 123
11514: PPUSH
11515: LD_INT 103
11517: PPUSH
11518: CALL_OW 171
// AddComMoveXY ( Kikuchi , 138 , 108 ) ;
11522: LD_EXP 34
11526: PPUSH
11527: LD_INT 138
11529: PPUSH
11530: LD_INT 108
11532: PPUSH
11533: CALL_OW 171
// AddComHold ( Kikuchi ) ;
11537: LD_EXP 34
11541: PPUSH
11542: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
11546: LD_INT 35
11548: PPUSH
11549: CALL_OW 67
// until IsAt ( Kikuchi , 138 , 108 ) ;
11553: LD_EXP 34
11557: PPUSH
11558: LD_INT 138
11560: PPUSH
11561: LD_INT 108
11563: PPUSH
11564: CALL_OW 307
11568: IFFALSE 11546
// AddComMoveXY ( Kikuchi , 125 , 132 ) ;
11570: LD_EXP 34
11574: PPUSH
11575: LD_INT 125
11577: PPUSH
11578: LD_INT 132
11580: PPUSH
11581: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11585: LD_INT 35
11587: PPUSH
11588: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 7 ;
11592: LD_INT 1
11594: PPUSH
11595: LD_EXP 34
11599: PPUSH
11600: CALL_OW 292
11604: PUSH
11605: LD_EXP 34
11609: PPUSH
11610: LD_INT 7
11612: PPUSH
11613: CALL_OW 296
11617: PUSH
11618: LD_INT 7
11620: LESS
11621: OR
11622: IFFALSE 11585
// DialogueOn ;
11624: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
11628: LD_EXP 34
11632: PPUSH
11633: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
11637: LD_INT 10
11639: PPUSH
11640: CALL_OW 68
// Say ( Kikuchi , D4Ya-Yam-1 ) ;
11644: LD_EXP 34
11648: PPUSH
11649: LD_STRING D4Ya-Yam-1
11651: PPUSH
11652: CALL_OW 88
// Say ( JMM , D4Ya-JMM-1 ) ;
11656: LD_EXP 21
11660: PPUSH
11661: LD_STRING D4Ya-JMM-1
11663: PPUSH
11664: CALL_OW 88
// for i in points do
11668: LD_ADDR_VAR 0 1
11672: PUSH
11673: LD_VAR 0 2
11677: PUSH
11678: FOR_IN
11679: IFFALSE 11737
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
11681: LD_VAR 0 1
11685: PUSH
11686: LD_INT 1
11688: ARRAY
11689: PPUSH
11690: LD_VAR 0 1
11694: PUSH
11695: LD_INT 2
11697: ARRAY
11698: PPUSH
11699: LD_INT 1
11701: PPUSH
11702: LD_INT 20
11704: NEG
11705: PPUSH
11706: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
11710: LD_VAR 0 1
11714: PUSH
11715: LD_INT 1
11717: ARRAY
11718: PPUSH
11719: LD_VAR 0 1
11723: PUSH
11724: LD_INT 2
11726: ARRAY
11727: PPUSH
11728: LD_INT 1
11730: PPUSH
11731: CALL_OW 331
// end ;
11735: GO 11678
11737: POP
11738: POP
// dwait ( 0 0$0.5 ) ;
11739: LD_INT 18
11741: PPUSH
11742: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
11746: LD_INT 42
11748: PPUSH
11749: LD_INT 27
11751: PPUSH
11752: CALL_OW 84
// Say ( Kikuchi , D4Ya-Yam-2 ) ;
11756: LD_EXP 34
11760: PPUSH
11761: LD_STRING D4Ya-Yam-2
11763: PPUSH
11764: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
11768: LD_INT 18
11770: PPUSH
11771: CALL_OW 68
// CenterNowOnXY ( 118 , 80 ) ;
11775: LD_INT 118
11777: PPUSH
11778: LD_INT 80
11780: PPUSH
11781: CALL_OW 86
// Say ( JMM , D4Ya-JMM-2 ) ;
11785: LD_EXP 21
11789: PPUSH
11790: LD_STRING D4Ya-JMM-2
11792: PPUSH
11793: CALL_OW 88
// Say ( Kikuchi , D4Ya-Yam-3 ) ;
11797: LD_EXP 34
11801: PPUSH
11802: LD_STRING D4Ya-Yam-3
11804: PPUSH
11805: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
11809: LD_INT 10
11811: PPUSH
11812: CALL_OW 68
// DialogueOff ;
11816: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
11820: LD_EXP 34
11824: PPUSH
11825: LD_INT 1
11827: PPUSH
11828: CALL_OW 235
// end else
11832: GO 12086
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
11834: LD_INT 2
11836: PPUSH
11837: LD_INT 4
11839: PPUSH
11840: LD_INT 2
11842: PPUSH
11843: LD_INT 1
11845: PPUSH
11846: CALL_OW 80
// ComMoveXY ( Kikuchi , 75 , 63 ) ;
11850: LD_EXP 34
11854: PPUSH
11855: LD_INT 75
11857: PPUSH
11858: LD_INT 63
11860: PPUSH
11861: CALL_OW 111
// AddComWait ( Kikuchi , 0 0$5 ) ;
11865: LD_EXP 34
11869: PPUSH
11870: LD_INT 175
11872: PPUSH
11873: CALL_OW 202
// AddComMoveXY ( Kikuchi , 102 , 76 ) ;
11877: LD_EXP 34
11881: PPUSH
11882: LD_INT 102
11884: PPUSH
11885: LD_INT 76
11887: PPUSH
11888: CALL_OW 171
// AddComMoveXY ( Kikuchi , 108 , 70 ) ;
11892: LD_EXP 34
11896: PPUSH
11897: LD_INT 108
11899: PPUSH
11900: LD_INT 70
11902: PPUSH
11903: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11907: LD_INT 35
11909: PPUSH
11910: CALL_OW 67
// until See ( 2 , Kikuchi ) ;
11914: LD_INT 2
11916: PPUSH
11917: LD_EXP 34
11921: PPUSH
11922: CALL_OW 292
11926: IFFALSE 11907
// ComMoveXY ( Kikuchi , 112 , 118 ) ;
11928: LD_EXP 34
11932: PPUSH
11933: LD_INT 112
11935: PPUSH
11936: LD_INT 118
11938: PPUSH
11939: CALL_OW 111
// if GetLives ( Kikuchi ) >= 750 then
11943: LD_EXP 34
11947: PPUSH
11948: CALL_OW 256
11952: PUSH
11953: LD_INT 750
11955: GREATEREQUAL
11956: IFFALSE 11970
// SetLives ( Kikuchi , 700 ) ;
11958: LD_EXP 34
11962: PPUSH
11963: LD_INT 700
11965: PPUSH
11966: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
11970: LD_INT 35
11972: PPUSH
11973: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 17 ;
11977: LD_INT 1
11979: PPUSH
11980: LD_EXP 34
11984: PPUSH
11985: CALL_OW 292
11989: PUSH
11990: LD_EXP 34
11994: PPUSH
11995: LD_INT 7
11997: PPUSH
11998: CALL_OW 296
12002: PUSH
12003: LD_INT 17
12005: LESS
12006: OR
12007: IFFALSE 11970
// DialogueOn ;
12009: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12013: LD_EXP 34
12017: PPUSH
12018: CALL_OW 87
// Say ( Kikuchi , D4Yb-Yam-1 ) ;
12022: LD_EXP 34
12026: PPUSH
12027: LD_STRING D4Yb-Yam-1
12029: PPUSH
12030: CALL_OW 88
// Say ( JMM , D4Yb-JMM-1 ) ;
12034: LD_EXP 21
12038: PPUSH
12039: LD_STRING D4Yb-JMM-1
12041: PPUSH
12042: CALL_OW 88
// Say ( Kikuchi , D4Yb-Yam-2 ) ;
12046: LD_EXP 34
12050: PPUSH
12051: LD_STRING D4Yb-Yam-2
12053: PPUSH
12054: CALL_OW 88
// Say ( JMM , D4Yb-JMM-2 ) ;
12058: LD_EXP 21
12062: PPUSH
12063: LD_STRING D4Yb-JMM-2
12065: PPUSH
12066: CALL_OW 88
// DialogueOff ;
12070: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12074: LD_EXP 34
12078: PPUSH
12079: LD_INT 1
12081: PPUSH
12082: CALL_OW 235
// end ; end ; end ;
12086: PPOPN 2
12088: END
// every 0 0$01 trigger base_captured do var i , tmp , un , un2 ;
12089: LD_EXP 6
12093: IFFALSE 13126
12095: GO 12097
12097: DISABLE
12098: LD_INT 0
12100: PPUSH
12101: PPUSH
12102: PPUSH
12103: PPUSH
// begin enable ;
12104: ENABLE
// if not seen [ 1 ] then
12105: LD_EXP 9
12109: PUSH
12110: LD_INT 1
12112: ARRAY
12113: NOT
12114: IFFALSE 12294
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 11 ] , [ f_control , control_rider ] ] ] ) ;
12116: LD_ADDR_VAR 0 2
12120: PUSH
12121: LD_INT 22
12123: PUSH
12124: LD_INT 2
12126: PUSH
12127: EMPTY
12128: LIST
12129: LIST
12130: PUSH
12131: LD_INT 2
12133: PUSH
12134: LD_INT 25
12136: PUSH
12137: LD_INT 11
12139: PUSH
12140: EMPTY
12141: LIST
12142: LIST
12143: PUSH
12144: LD_INT 33
12146: PUSH
12147: LD_INT 4
12149: PUSH
12150: EMPTY
12151: LIST
12152: LIST
12153: PUSH
12154: EMPTY
12155: LIST
12156: LIST
12157: LIST
12158: PUSH
12159: EMPTY
12160: LIST
12161: LIST
12162: PPUSH
12163: CALL_OW 69
12167: ST_TO_ADDR
// if tmp then
12168: LD_VAR 0 2
12172: IFFALSE 12294
// for i in tmp do
12174: LD_ADDR_VAR 0 1
12178: PUSH
12179: LD_VAR 0 2
12183: PUSH
12184: FOR_IN
12185: IFFALSE 12292
// if See ( 1 , i ) then
12187: LD_INT 1
12189: PPUSH
12190: LD_VAR 0 1
12194: PPUSH
12195: CALL_OW 292
12199: IFFALSE 12290
// begin seen := Replace ( seen , 1 , true ) ;
12201: LD_ADDR_EXP 9
12205: PUSH
12206: LD_EXP 9
12210: PPUSH
12211: LD_INT 1
12213: PPUSH
12214: LD_INT 1
12216: PPUSH
12217: CALL_OW 1
12221: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12222: LD_INT 1
12224: PPUSH
12225: CALL 15733 0 1
12229: IFFALSE 12290
// begin DialogueOn ;
12231: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12235: LD_VAR 0 1
12239: PPUSH
12240: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12244: LD_INT 10
12246: PPUSH
12247: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol2-1 ) ;
12251: LD_ADDR_VAR 0 3
12255: PUSH
12256: LD_INT 1
12258: PPUSH
12259: LD_STRING D5a-Sol2-1
12261: PPUSH
12262: CALL 15911 0 2
12266: ST_TO_ADDR
// if not un then
12267: LD_VAR 0 3
12271: NOT
12272: IFFALSE 12284
// SayRand ( sex_female , D5a-FSol2-1 ) ;
12274: LD_INT 2
12276: PPUSH
12277: LD_STRING D5a-FSol2-1
12279: PPUSH
12280: CALL 15911 0 2
// DialogueOff ;
12284: CALL_OW 7
// break ;
12288: GO 12292
// end ; end ;
12290: GO 12184
12292: POP
12293: POP
// end ; if not seen [ 2 ] then
12294: LD_EXP 9
12298: PUSH
12299: LD_INT 2
12301: ARRAY
12302: NOT
12303: IFFALSE 12528
// begin can_kamikazed := true ;
12305: LD_ADDR_EXP 10
12309: PUSH
12310: LD_INT 1
12312: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 17 ] ] ) ;
12313: LD_ADDR_VAR 0 2
12317: PUSH
12318: LD_INT 22
12320: PUSH
12321: LD_INT 2
12323: PUSH
12324: EMPTY
12325: LIST
12326: LIST
12327: PUSH
12328: LD_INT 25
12330: PUSH
12331: LD_INT 17
12333: PUSH
12334: EMPTY
12335: LIST
12336: LIST
12337: PUSH
12338: EMPTY
12339: LIST
12340: LIST
12341: PPUSH
12342: CALL_OW 69
12346: ST_TO_ADDR
// if tmp then
12347: LD_VAR 0 2
12351: IFFALSE 12528
// for i in tmp do
12353: LD_ADDR_VAR 0 1
12357: PUSH
12358: LD_VAR 0 2
12362: PUSH
12363: FOR_IN
12364: IFFALSE 12526
// if See ( 1 , i ) then
12366: LD_INT 1
12368: PPUSH
12369: LD_VAR 0 1
12373: PPUSH
12374: CALL_OW 292
12378: IFFALSE 12524
// begin seen := Replace ( seen , 2 , true ) ;
12380: LD_ADDR_EXP 9
12384: PUSH
12385: LD_EXP 9
12389: PPUSH
12390: LD_INT 2
12392: PPUSH
12393: LD_INT 1
12395: PPUSH
12396: CALL_OW 1
12400: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12401: LD_INT 1
12403: PPUSH
12404: CALL 15733 0 1
12408: IFFALSE 12524
// begin DialogueOn ;
12410: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12414: LD_VAR 0 1
12418: PPUSH
12419: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12423: LD_INT 10
12425: PPUSH
12426: CALL_OW 68
// un := SayRand ( sex_male , D5b-Sol1-1 ) ;
12430: LD_ADDR_VAR 0 3
12434: PUSH
12435: LD_INT 1
12437: PPUSH
12438: LD_STRING D5b-Sol1-1
12440: PPUSH
12441: CALL 15911 0 2
12445: ST_TO_ADDR
// if not un then
12446: LD_VAR 0 3
12450: NOT
12451: IFFALSE 12469
// un := SayRand ( sex_female , D5b-FSol1-1 ) ;
12453: LD_ADDR_VAR 0 3
12457: PUSH
12458: LD_INT 2
12460: PPUSH
12461: LD_STRING D5b-FSol1-1
12463: PPUSH
12464: CALL 15911 0 2
12468: ST_TO_ADDR
// if un then
12469: LD_VAR 0 3
12473: IFFALSE 12518
// begin un2 := SayRand2 ( sex_male , D5b-Sol2-1 , un ) ;
12475: LD_ADDR_VAR 0 4
12479: PUSH
12480: LD_INT 1
12482: PPUSH
12483: LD_STRING D5b-Sol2-1
12485: PPUSH
12486: LD_VAR 0 3
12490: PPUSH
12491: CALL 16137 0 3
12495: ST_TO_ADDR
// if not un2 then
12496: LD_VAR 0 4
12500: NOT
12501: IFFALSE 12518
// SayRand2 ( sex_female , D5b-FSol2-1 , un ) ;
12503: LD_INT 2
12505: PPUSH
12506: LD_STRING D5b-FSol2-1
12508: PPUSH
12509: LD_VAR 0 3
12513: PPUSH
12514: CALL 16137 0 3
// end ; DialogueOff ;
12518: CALL_OW 7
// break ;
12522: GO 12526
// end ; end ;
12524: GO 12363
12526: POP
12527: POP
// end ; if not seen [ 3 ] then
12528: LD_EXP 9
12532: PUSH
12533: LD_INT 3
12535: ARRAY
12536: NOT
12537: IFFALSE 12711
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] ] ) ;
12539: LD_ADDR_VAR 0 2
12543: PUSH
12544: LD_INT 22
12546: PUSH
12547: LD_INT 2
12549: PUSH
12550: EMPTY
12551: LIST
12552: LIST
12553: PUSH
12554: LD_INT 33
12556: PUSH
12557: LD_INT 2
12559: PUSH
12560: EMPTY
12561: LIST
12562: LIST
12563: PUSH
12564: EMPTY
12565: LIST
12566: LIST
12567: PPUSH
12568: CALL_OW 69
12572: ST_TO_ADDR
// if tmp then
12573: LD_VAR 0 2
12577: IFFALSE 12711
// for i in tmp do
12579: LD_ADDR_VAR 0 1
12583: PUSH
12584: LD_VAR 0 2
12588: PUSH
12589: FOR_IN
12590: IFFALSE 12709
// if See ( 1 , i ) then
12592: LD_INT 1
12594: PPUSH
12595: LD_VAR 0 1
12599: PPUSH
12600: CALL_OW 292
12604: IFFALSE 12707
// begin seen := Replace ( seen , 3 , true ) ;
12606: LD_ADDR_EXP 9
12610: PUSH
12611: LD_EXP 9
12615: PPUSH
12616: LD_INT 3
12618: PPUSH
12619: LD_INT 1
12621: PPUSH
12622: CALL_OW 1
12626: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12627: LD_INT 1
12629: PPUSH
12630: CALL 15733 0 1
12634: IFFALSE 12707
// begin DialogueOn ;
12636: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12640: LD_VAR 0 1
12644: PPUSH
12645: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12649: LD_INT 10
12651: PPUSH
12652: CALL_OW 68
// un := SayRand ( sex_male , D8-Sol1-1 ) ;
12656: LD_ADDR_VAR 0 3
12660: PUSH
12661: LD_INT 1
12663: PPUSH
12664: LD_STRING D8-Sol1-1
12666: PPUSH
12667: CALL 15911 0 2
12671: ST_TO_ADDR
// if not un then
12672: LD_VAR 0 3
12676: NOT
12677: IFFALSE 12689
// SayRand ( sex_female , D8-FSol1-1 ) ;
12679: LD_INT 2
12681: PPUSH
12682: LD_STRING D8-FSol1-1
12684: PPUSH
12685: CALL 15911 0 2
// Say ( JMM , D8-JMM-1 ) ;
12689: LD_EXP 21
12693: PPUSH
12694: LD_STRING D8-JMM-1
12696: PPUSH
12697: CALL_OW 88
// DialogueOff ;
12701: CALL_OW 7
// break ;
12705: GO 12709
// end ; end ;
12707: GO 12589
12709: POP
12710: POP
// end ; if not seen [ 4 ] then
12711: LD_EXP 9
12715: PUSH
12716: LD_INT 4
12718: ARRAY
12719: NOT
12720: IFFALSE 12882
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] ] ) ;
12722: LD_ADDR_VAR 0 2
12726: PUSH
12727: LD_INT 22
12729: PUSH
12730: LD_INT 2
12732: PUSH
12733: EMPTY
12734: LIST
12735: LIST
12736: PUSH
12737: LD_INT 33
12739: PUSH
12740: LD_INT 5
12742: PUSH
12743: EMPTY
12744: LIST
12745: LIST
12746: PUSH
12747: EMPTY
12748: LIST
12749: LIST
12750: PPUSH
12751: CALL_OW 69
12755: ST_TO_ADDR
// if tmp then
12756: LD_VAR 0 2
12760: IFFALSE 12882
// for i in tmp do
12762: LD_ADDR_VAR 0 1
12766: PUSH
12767: LD_VAR 0 2
12771: PUSH
12772: FOR_IN
12773: IFFALSE 12880
// if See ( 1 , i ) then
12775: LD_INT 1
12777: PPUSH
12778: LD_VAR 0 1
12782: PPUSH
12783: CALL_OW 292
12787: IFFALSE 12878
// begin seen := Replace ( seen , 4 , true ) ;
12789: LD_ADDR_EXP 9
12793: PUSH
12794: LD_EXP 9
12798: PPUSH
12799: LD_INT 4
12801: PPUSH
12802: LD_INT 1
12804: PPUSH
12805: CALL_OW 1
12809: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12810: LD_INT 1
12812: PPUSH
12813: CALL 15733 0 1
12817: IFFALSE 12878
// begin DialogueOn ;
12819: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12823: LD_VAR 0 1
12827: PPUSH
12828: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12832: LD_INT 10
12834: PPUSH
12835: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol1-1 ) ;
12839: LD_ADDR_VAR 0 3
12843: PUSH
12844: LD_INT 1
12846: PPUSH
12847: LD_STRING D5a-Sol1-1
12849: PPUSH
12850: CALL 15911 0 2
12854: ST_TO_ADDR
// if not un then
12855: LD_VAR 0 3
12859: NOT
12860: IFFALSE 12872
// SayRand ( sex_female , D5a-FSol1-1 ) ;
12862: LD_INT 2
12864: PPUSH
12865: LD_STRING D5a-FSol1-1
12867: PPUSH
12868: CALL 15911 0 2
// DialogueOff ;
12872: CALL_OW 7
// break ;
12876: GO 12880
// end ; end ;
12878: GO 12772
12880: POP
12881: POP
// end ; if not seen [ 5 ] and seen [ 3 ] then
12882: LD_EXP 9
12886: PUSH
12887: LD_INT 5
12889: ARRAY
12890: NOT
12891: PUSH
12892: LD_EXP 9
12896: PUSH
12897: LD_INT 3
12899: ARRAY
12900: AND
12901: IFFALSE 13075
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) ;
12903: LD_ADDR_VAR 0 2
12907: PUSH
12908: LD_INT 22
12910: PUSH
12911: LD_INT 2
12913: PUSH
12914: EMPTY
12915: LIST
12916: LIST
12917: PUSH
12918: LD_INT 34
12920: PUSH
12921: LD_INT 31
12923: PUSH
12924: EMPTY
12925: LIST
12926: LIST
12927: PUSH
12928: EMPTY
12929: LIST
12930: LIST
12931: PPUSH
12932: CALL_OW 69
12936: ST_TO_ADDR
// if tmp then
12937: LD_VAR 0 2
12941: IFFALSE 13075
// for i in tmp do
12943: LD_ADDR_VAR 0 1
12947: PUSH
12948: LD_VAR 0 2
12952: PUSH
12953: FOR_IN
12954: IFFALSE 13073
// if See ( 1 , i ) then
12956: LD_INT 1
12958: PPUSH
12959: LD_VAR 0 1
12963: PPUSH
12964: CALL_OW 292
12968: IFFALSE 13071
// begin seen := Replace ( seen , 5 , true ) ;
12970: LD_ADDR_EXP 9
12974: PUSH
12975: LD_EXP 9
12979: PPUSH
12980: LD_INT 5
12982: PPUSH
12983: LD_INT 1
12985: PPUSH
12986: CALL_OW 1
12990: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12991: LD_INT 1
12993: PPUSH
12994: CALL 15733 0 1
12998: IFFALSE 13071
// begin DialogueOn ;
13000: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13004: LD_VAR 0 1
13008: PPUSH
13009: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13013: LD_INT 10
13015: PPUSH
13016: CALL_OW 68
// un := SayRand ( sex_male , D8a-Sol2-1 ) ;
13020: LD_ADDR_VAR 0 3
13024: PUSH
13025: LD_INT 1
13027: PPUSH
13028: LD_STRING D8a-Sol2-1
13030: PPUSH
13031: CALL 15911 0 2
13035: ST_TO_ADDR
// if not un then
13036: LD_VAR 0 3
13040: NOT
13041: IFFALSE 13053
// SayRand ( sex_female , D8a-FSol2-1 ) ;
13043: LD_INT 2
13045: PPUSH
13046: LD_STRING D8a-FSol2-1
13048: PPUSH
13049: CALL 15911 0 2
// Say ( JMM , D8a-JMM-1 ) ;
13053: LD_EXP 21
13057: PPUSH
13058: LD_STRING D8a-JMM-1
13060: PPUSH
13061: CALL_OW 88
// DialogueOff ;
13065: CALL_OW 7
// break ;
13069: GO 13073
// end ; end ;
13071: GO 12953
13073: POP
13074: POP
// end ; if seen [ 1 ] and seen [ 2 ] and seen [ 3 ] and seen [ 4 ] and seen [ 5 ] then
13075: LD_EXP 9
13079: PUSH
13080: LD_INT 1
13082: ARRAY
13083: PUSH
13084: LD_EXP 9
13088: PUSH
13089: LD_INT 2
13091: ARRAY
13092: AND
13093: PUSH
13094: LD_EXP 9
13098: PUSH
13099: LD_INT 3
13101: ARRAY
13102: AND
13103: PUSH
13104: LD_EXP 9
13108: PUSH
13109: LD_INT 4
13111: ARRAY
13112: AND
13113: PUSH
13114: LD_EXP 9
13118: PUSH
13119: LD_INT 5
13121: ARRAY
13122: AND
13123: IFFALSE 13126
// disable ;
13125: DISABLE
// end ;
13126: PPOPN 4
13128: END
// every 0 0$1 trigger can_kamikazed and kamikazed do var un ;
13129: LD_EXP 10
13133: PUSH
13134: LD_EXP 11
13138: AND
13139: IFFALSE 13337
13141: GO 13143
13143: DISABLE
13144: LD_INT 0
13146: PPUSH
// begin DialogueOn ;
13147: CALL_OW 6
// CenterNowOnUnits ( kamikazed ) ;
13151: LD_EXP 11
13155: PPUSH
13156: CALL_OW 87
// un := SayRand ( sex_male , D5c-Sol1-1 ) ;
13160: LD_ADDR_VAR 0 1
13164: PUSH
13165: LD_INT 1
13167: PPUSH
13168: LD_STRING D5c-Sol1-1
13170: PPUSH
13171: CALL 15911 0 2
13175: ST_TO_ADDR
// if not un then
13176: LD_VAR 0 1
13180: NOT
13181: IFFALSE 13199
// un := SayRand ( sex_female , D5c-FSol1-1 ) ;
13183: LD_ADDR_VAR 0 1
13187: PUSH
13188: LD_INT 2
13190: PPUSH
13191: LD_STRING D5c-FSol1-1
13193: PPUSH
13194: CALL 15911 0 2
13198: ST_TO_ADDR
// Say ( JMM , D5c-JMM-1 ) ;
13199: LD_EXP 21
13203: PPUSH
13204: LD_STRING D5c-JMM-1
13206: PPUSH
13207: CALL_OW 88
// if IsOk ( Lisa ) then
13211: LD_EXP 22
13215: PPUSH
13216: CALL_OW 302
13220: IFFALSE 13236
// Say ( Lisa , D5d-Lisa-1 ) else
13222: LD_EXP 22
13226: PPUSH
13227: LD_STRING D5d-Lisa-1
13229: PPUSH
13230: CALL_OW 88
13234: GO 13321
// if IsOk ( Cyrus ) then
13236: LD_EXP 25
13240: PPUSH
13241: CALL_OW 302
13245: IFFALSE 13261
// Say ( Cyrus , D5d-Cyrus-1 ) else
13247: LD_EXP 25
13251: PPUSH
13252: LD_STRING D5d-Cyrus-1
13254: PPUSH
13255: CALL_OW 88
13259: GO 13321
// if IsOk ( Gary ) then
13261: LD_EXP 32
13265: PPUSH
13266: CALL_OW 302
13270: IFFALSE 13286
// Say ( Gary , D5d-Gary-1 ) else
13272: LD_EXP 32
13276: PPUSH
13277: LD_STRING D5d-Gary-1
13279: PPUSH
13280: CALL_OW 88
13284: GO 13321
// if GetSex ( un ) = sex_male then
13286: LD_VAR 0 1
13290: PPUSH
13291: CALL_OW 258
13295: PUSH
13296: LD_INT 1
13298: EQUAL
13299: IFFALSE 13315
// Say ( un , D5d-Sol1-1 ) else
13301: LD_VAR 0 1
13305: PPUSH
13306: LD_STRING D5d-Sol1-1
13308: PPUSH
13309: CALL_OW 88
13313: GO 13321
// begin DialogueOff ;
13315: CALL_OW 7
// exit ;
13319: GO 13337
// end ; Say ( JMM , D5d-JMM-1 ) ;
13321: LD_EXP 21
13325: PPUSH
13326: LD_STRING D5d-JMM-1
13328: PPUSH
13329: CALL_OW 88
// DialogueOff ;
13333: CALL_OW 7
// end ;
13337: PPOPN 1
13339: END
// every 0 0$2 trigger SeeArea ( 1 , artifact_area ) >= 2 do var un ;
13340: LD_INT 1
13342: PPUSH
13343: LD_INT 17
13345: PPUSH
13346: CALL_OW 294
13350: PUSH
13351: LD_INT 2
13353: GREATEREQUAL
13354: IFFALSE 13475
13356: GO 13358
13358: DISABLE
13359: LD_INT 0
13361: PPUSH
// begin PlaceSeeing ( 10 , 5 , 1 , - 10 ) ;
13362: LD_INT 10
13364: PPUSH
13365: LD_INT 5
13367: PPUSH
13368: LD_INT 1
13370: PPUSH
13371: LD_INT 10
13373: NEG
13374: PPUSH
13375: CALL_OW 330
// RemoveSeeing ( 10 , 5 , 1 ) ;
13379: LD_INT 10
13381: PPUSH
13382: LD_INT 5
13384: PPUSH
13385: LD_INT 1
13387: PPUSH
13388: CALL_OW 331
// CenterNowOnXY ( 10 , 5 ) ;
13392: LD_INT 10
13394: PPUSH
13395: LD_INT 5
13397: PPUSH
13398: CALL_OW 86
// DialogueOn ;
13402: CALL_OW 6
// un := SayRand ( sex_male , D6-Sci1-1 ) ;
13406: LD_ADDR_VAR 0 1
13410: PUSH
13411: LD_INT 1
13413: PPUSH
13414: LD_STRING D6-Sci1-1
13416: PPUSH
13417: CALL 15911 0 2
13421: ST_TO_ADDR
// if un then
13422: LD_VAR 0 1
13426: IFFALSE 13464
// begin Say ( JMM , D6-JMM-1 ) ;
13428: LD_EXP 21
13432: PPUSH
13433: LD_STRING D6-JMM-1
13435: PPUSH
13436: CALL_OW 88
// Say ( un , D6-Sci1-2 ) ;
13440: LD_VAR 0 1
13444: PPUSH
13445: LD_STRING D6-Sci1-2
13447: PPUSH
13448: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
13452: LD_EXP 21
13456: PPUSH
13457: LD_STRING D6-JMM-2
13459: PPUSH
13460: CALL_OW 88
// end ; DialogueOff ;
13464: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
13468: LD_STRING M3
13470: PPUSH
13471: CALL_OW 337
// end ;
13475: PPOPN 1
13477: END
// export ar_mechanic , ar_mechanic_friend ; every 0 0$20 trigger tick >= 20 20$00 and ( DangerAtRangeXY ( 2 , 169 , 90 , 10 ) [ 4 ] = 0 or IsDead ( ar_dep_w ) or GetSide ( ar_dep_w ) = 1 ) and not IsDead ( ar_dep_n ) do var un , i , cargo , tmp ;
13478: LD_OWVAR 1
13482: PUSH
13483: LD_INT 42000
13485: GREATEREQUAL
13486: PUSH
13487: LD_INT 2
13489: PPUSH
13490: LD_INT 169
13492: PPUSH
13493: LD_INT 90
13495: PPUSH
13496: LD_INT 10
13498: PPUSH
13499: CALL 55283 0 4
13503: PUSH
13504: LD_INT 4
13506: ARRAY
13507: PUSH
13508: LD_INT 0
13510: EQUAL
13511: PUSH
13512: LD_INT 45
13514: PPUSH
13515: CALL_OW 301
13519: OR
13520: PUSH
13521: LD_INT 45
13523: PPUSH
13524: CALL_OW 255
13528: PUSH
13529: LD_INT 1
13531: EQUAL
13532: OR
13533: AND
13534: PUSH
13535: LD_INT 94
13537: PPUSH
13538: CALL_OW 301
13542: NOT
13543: AND
13544: IFFALSE 14670
13546: GO 13548
13548: DISABLE
13549: LD_INT 0
13551: PPUSH
13552: PPUSH
13553: PPUSH
13554: PPUSH
// begin uc_side := 5 ;
13555: LD_ADDR_OWVAR 20
13559: PUSH
13560: LD_INT 5
13562: ST_TO_ADDR
// uc_nation := 2 ;
13563: LD_ADDR_OWVAR 21
13567: PUSH
13568: LD_INT 2
13570: ST_TO_ADDR
// InitHc ;
13571: CALL_OW 19
// PrepareHuman ( sex_male , 3 , 8 ) ;
13575: LD_INT 1
13577: PPUSH
13578: LD_INT 3
13580: PPUSH
13581: LD_INT 8
13583: PPUSH
13584: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
13588: LD_ADDR_OWVAR 29
13592: PUSH
13593: LD_INT 12
13595: PUSH
13596: LD_INT 12
13598: PUSH
13599: EMPTY
13600: LIST
13601: LIST
13602: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
13603: LD_ADDR_OWVAR 33
13607: PUSH
13608: LD_STRING SecondCharsGal
13610: ST_TO_ADDR
// hc_face_number := 7 ;
13611: LD_ADDR_OWVAR 34
13615: PUSH
13616: LD_INT 7
13618: ST_TO_ADDR
// ar_mechanic := CreateHuman ;
13619: LD_ADDR_EXP 46
13623: PUSH
13624: CALL_OW 44
13628: ST_TO_ADDR
// InitHc ;
13629: CALL_OW 19
// PrepareHuman ( sex_male , 16 , 2 ) ;
13633: LD_INT 1
13635: PPUSH
13636: LD_INT 16
13638: PPUSH
13639: LD_INT 2
13641: PPUSH
13642: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
13646: LD_ADDR_OWVAR 29
13650: PUSH
13651: LD_INT 12
13653: PUSH
13654: LD_INT 12
13656: PUSH
13657: EMPTY
13658: LIST
13659: LIST
13660: ST_TO_ADDR
// hc_name :=  ;
13661: LD_ADDR_OWVAR 26
13665: PUSH
13666: LD_STRING 
13668: ST_TO_ADDR
// ar_mechanic_friend := CreateHuman ;
13669: LD_ADDR_EXP 47
13673: PUSH
13674: CALL_OW 44
13678: ST_TO_ADDR
// InitHc ;
13679: CALL_OW 19
// repeat wait ( 0 0$1 ) ;
13683: LD_INT 35
13685: PPUSH
13686: CALL_OW 67
// until not InBattle ( 1 ) ;
13690: LD_INT 1
13692: PPUSH
13693: CALL_OW 463
13697: NOT
13698: IFFALSE 13683
// wait ( 0 0$5 ) ;
13700: LD_INT 175
13702: PPUSH
13703: CALL_OW 67
// DialogueOn ;
13707: CALL_OW 6
// InGameOn ;
13711: CALL_OW 8
// un := UnitFilter ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , [ f_sex , sex_male ] ) [ 1 ] ;
13715: LD_ADDR_VAR 0 1
13719: PUSH
13720: LD_INT 22
13722: PUSH
13723: LD_INT 1
13725: PUSH
13726: EMPTY
13727: LIST
13728: LIST
13729: PUSH
13730: LD_INT 2
13732: PUSH
13733: LD_INT 25
13735: PUSH
13736: LD_INT 1
13738: PUSH
13739: EMPTY
13740: LIST
13741: LIST
13742: PUSH
13743: LD_INT 25
13745: PUSH
13746: LD_INT 2
13748: PUSH
13749: EMPTY
13750: LIST
13751: LIST
13752: PUSH
13753: LD_INT 25
13755: PUSH
13756: LD_INT 3
13758: PUSH
13759: EMPTY
13760: LIST
13761: LIST
13762: PUSH
13763: LD_INT 25
13765: PUSH
13766: LD_INT 4
13768: PUSH
13769: EMPTY
13770: LIST
13771: LIST
13772: PUSH
13773: LD_INT 25
13775: PUSH
13776: LD_INT 5
13778: PUSH
13779: EMPTY
13780: LIST
13781: LIST
13782: PUSH
13783: LD_INT 25
13785: PUSH
13786: LD_INT 8
13788: PUSH
13789: EMPTY
13790: LIST
13791: LIST
13792: PUSH
13793: EMPTY
13794: LIST
13795: LIST
13796: LIST
13797: LIST
13798: LIST
13799: LIST
13800: LIST
13801: PUSH
13802: EMPTY
13803: LIST
13804: LIST
13805: PPUSH
13806: CALL_OW 69
13810: PUSH
13811: LD_EXP 21
13815: PUSH
13816: LD_EXP 22
13820: PUSH
13821: LD_EXP 23
13825: PUSH
13826: LD_EXP 24
13830: PUSH
13831: LD_EXP 25
13835: PUSH
13836: LD_EXP 26
13840: PUSH
13841: LD_EXP 27
13845: PUSH
13846: LD_EXP 28
13850: PUSH
13851: LD_EXP 29
13855: PUSH
13856: LD_EXP 31
13860: PUSH
13861: LD_EXP 32
13865: PUSH
13866: LD_EXP 33
13870: PUSH
13871: LD_EXP 34
13875: PUSH
13876: EMPTY
13877: LIST
13878: LIST
13879: LIST
13880: LIST
13881: LIST
13882: LIST
13883: LIST
13884: LIST
13885: LIST
13886: LIST
13887: LIST
13888: LIST
13889: LIST
13890: DIFF
13891: PPUSH
13892: LD_INT 26
13894: PUSH
13895: LD_INT 1
13897: PUSH
13898: EMPTY
13899: LIST
13900: LIST
13901: PPUSH
13902: CALL_OW 72
13906: PUSH
13907: LD_INT 1
13909: ARRAY
13910: ST_TO_ADDR
// if not un and Brown then
13911: LD_VAR 0 1
13915: NOT
13916: PUSH
13917: LD_EXP 27
13921: AND
13922: IFFALSE 13934
// un := Brown ;
13924: LD_ADDR_VAR 0 1
13928: PUSH
13929: LD_EXP 27
13933: ST_TO_ADDR
// if un then
13934: LD_VAR 0 1
13938: IFFALSE 13964
// begin Say ( un , D7-Sol1-1 ) ;
13940: LD_VAR 0 1
13944: PPUSH
13945: LD_STRING D7-Sol1-1
13947: PPUSH
13948: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
13952: LD_EXP 21
13956: PPUSH
13957: LD_STRING D7-JMM-1
13959: PPUSH
13960: CALL_OW 88
// end ; SayRadio ( ar_mechanic , D7-Ar1-1 ) ;
13964: LD_EXP 46
13968: PPUSH
13969: LD_STRING D7-Ar1-1
13971: PPUSH
13972: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
13976: LD_EXP 21
13980: PPUSH
13981: LD_STRING D7-JMM-2
13983: PPUSH
13984: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-2 ) ;
13988: LD_EXP 46
13992: PPUSH
13993: LD_STRING D7-Ar1-2
13995: PPUSH
13996: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
14000: LD_EXP 21
14004: PPUSH
14005: LD_STRING D7-JMM-3
14007: PPUSH
14008: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-3 ) ;
14012: LD_EXP 46
14016: PPUSH
14017: LD_STRING D7-Ar1-3
14019: PPUSH
14020: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
14024: LD_EXP 21
14028: PPUSH
14029: LD_STRING D7-JMM-4
14031: PPUSH
14032: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-4 ) ;
14036: LD_EXP 46
14040: PPUSH
14041: LD_STRING D7-Ar1-4
14043: PPUSH
14044: CALL_OW 94
// InGameOff ;
14048: CALL_OW 9
// DialogueOff ;
14052: CALL_OW 7
// case Query ( QCameras ) of 1 :
14056: LD_STRING QCameras
14058: PPUSH
14059: CALL_OW 97
14063: PUSH
14064: LD_INT 1
14066: DOUBLE
14067: EQUAL
14068: IFTRUE 14072
14070: GO 14075
14072: POP
// ; 2 :
14073: GO 14089
14075: LD_INT 2
14077: DOUBLE
14078: EQUAL
14079: IFTRUE 14083
14081: GO 14088
14083: POP
// exit ; end ;
14084: GO 14670
14086: GO 14089
14088: POP
// ChangeMissionObjectives ( MCar ) ;
14089: LD_STRING MCar
14091: PPUSH
14092: CALL_OW 337
// PlaceSeeing ( 124 , 90 , 1 , - 6 ) ;
14096: LD_INT 124
14098: PPUSH
14099: LD_INT 90
14101: PPUSH
14102: LD_INT 1
14104: PPUSH
14105: LD_INT 6
14107: NEG
14108: PPUSH
14109: CALL_OW 330
// RemoveSeeing ( 124 , 90 , 1 ) ;
14113: LD_INT 124
14115: PPUSH
14116: LD_INT 90
14118: PPUSH
14119: LD_INT 1
14121: PPUSH
14122: CALL_OW 331
// SetAreaMapShow ( parking_marea , 1 ) ;
14126: LD_INT 12
14128: PPUSH
14129: LD_INT 1
14131: PPUSH
14132: CALL_OW 424
// wait ( 3 ) ;
14136: LD_INT 3
14138: PPUSH
14139: CALL_OW 67
// CenterNowOnXY ( 124 , 90 ) ;
14143: LD_INT 124
14145: PPUSH
14146: LD_INT 90
14148: PPUSH
14149: CALL_OW 86
// cargo := false ;
14153: LD_ADDR_VAR 0 3
14157: PUSH
14158: LD_INT 0
14160: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
14161: LD_INT 35
14163: PPUSH
14164: CALL_OW 67
// cargo := FilterUnitsInArea ( parking_marea , [ [ f_engine , engine_siberite ] , [ f_weapon , ar_cargo_bay ] , [ f_empty ] ] ) ;
14168: LD_ADDR_VAR 0 3
14172: PUSH
14173: LD_INT 12
14175: PPUSH
14176: LD_INT 32
14178: PUSH
14179: LD_INT 3
14181: PUSH
14182: EMPTY
14183: LIST
14184: LIST
14185: PUSH
14186: LD_INT 34
14188: PUSH
14189: LD_INT 32
14191: PUSH
14192: EMPTY
14193: LIST
14194: LIST
14195: PUSH
14196: LD_INT 58
14198: PUSH
14199: EMPTY
14200: LIST
14201: PUSH
14202: EMPTY
14203: LIST
14204: LIST
14205: LIST
14206: PPUSH
14207: CALL_OW 70
14211: ST_TO_ADDR
// until cargo ;
14212: LD_VAR 0 3
14216: IFFALSE 14161
// cargo := cargo [ 1 ] ;
14218: LD_ADDR_VAR 0 3
14222: PUSH
14223: LD_VAR 0 3
14227: PUSH
14228: LD_INT 1
14230: ARRAY
14231: ST_TO_ADDR
// SetSide ( cargo , 5 ) ;
14232: LD_VAR 0 3
14236: PPUSH
14237: LD_INT 5
14239: PPUSH
14240: CALL_OW 235
// SetAreaMapShow ( parking_marea , 0 ) ;
14244: LD_INT 12
14246: PPUSH
14247: LD_INT 0
14249: PPUSH
14250: CALL_OW 424
// PlaceUnitArea ( ar_mechanic , mechanic_spawn , false ) ;
14254: LD_EXP 46
14258: PPUSH
14259: LD_INT 11
14261: PPUSH
14262: LD_INT 0
14264: PPUSH
14265: CALL_OW 49
// PlaceUnitArea ( ar_mechanic_friend , mechanic_spawn , false ) ;
14269: LD_EXP 47
14273: PPUSH
14274: LD_INT 11
14276: PPUSH
14277: LD_INT 0
14279: PPUSH
14280: CALL_OW 49
// ComMoveToArea ( [ ar_mechanic , ar_mechanic_friend ] , parking_marea ) ;
14284: LD_EXP 46
14288: PUSH
14289: LD_EXP 47
14293: PUSH
14294: EMPTY
14295: LIST
14296: LIST
14297: PPUSH
14298: LD_INT 12
14300: PPUSH
14301: CALL_OW 113
// AddComEnterUnit ( ar_mechanic , cargo ) ;
14305: LD_EXP 46
14309: PPUSH
14310: LD_VAR 0 3
14314: PPUSH
14315: CALL_OW 180
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
14319: LD_EXP 46
14323: PUSH
14324: LD_EXP 47
14328: PUSH
14329: EMPTY
14330: LIST
14331: LIST
14332: PPUSH
14333: LD_INT 209
14335: PPUSH
14336: LD_INT 178
14338: PPUSH
14339: CALL_OW 171
// while ( true ) do
14343: LD_INT 1
14345: IFFALSE 14499
// begin wait ( 0 0$1 ) ;
14347: LD_INT 35
14349: PPUSH
14350: CALL_OW 67
// if not HasTask ( ar_mechanic ) or not HasTask ( ar_mechanic_friend ) then
14354: LD_EXP 46
14358: PPUSH
14359: CALL_OW 314
14363: NOT
14364: PUSH
14365: LD_EXP 47
14369: PPUSH
14370: CALL_OW 314
14374: NOT
14375: OR
14376: IFFALSE 14402
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
14378: LD_EXP 46
14382: PUSH
14383: LD_EXP 47
14387: PUSH
14388: EMPTY
14389: LIST
14390: LIST
14391: PPUSH
14392: LD_INT 209
14394: PPUSH
14395: LD_INT 178
14397: PPUSH
14398: CALL_OW 171
// if IsInArea ( ar_mechanic , escape_area ) then
14402: LD_EXP 46
14406: PPUSH
14407: LD_INT 10
14409: PPUSH
14410: CALL_OW 308
14414: IFFALSE 14425
// RemoveUnit ( ar_mechanic ) ;
14416: LD_EXP 46
14420: PPUSH
14421: CALL_OW 64
// if IsInArea ( ar_mechanic_friend , escape_area ) then
14425: LD_EXP 47
14429: PPUSH
14430: LD_INT 10
14432: PPUSH
14433: CALL_OW 308
14437: IFFALSE 14448
// RemoveUnit ( ar_mechanic_friend ) ;
14439: LD_EXP 47
14443: PPUSH
14444: CALL_OW 64
// if IsInArea ( cargo , escape_area ) then
14448: LD_VAR 0 3
14452: PPUSH
14453: LD_INT 10
14455: PPUSH
14456: CALL_OW 308
14460: IFFALSE 14471
// RemoveUnit ( cargo ) ;
14462: LD_VAR 0 3
14466: PPUSH
14467: CALL_OW 64
// if not IsLive ( ar_mechanic ) and not IsLive ( ar_mechanic_friend ) then
14471: LD_EXP 46
14475: PPUSH
14476: CALL_OW 300
14480: NOT
14481: PUSH
14482: LD_EXP 47
14486: PPUSH
14487: CALL_OW 300
14491: NOT
14492: AND
14493: IFFALSE 14497
// break ;
14495: GO 14499
// end ;
14497: GO 14343
// wait ( 0 0$2 ) ;
14499: LD_INT 70
14501: PPUSH
14502: CALL_OW 67
// SayRadio ( ar_mechanic , D7a-Ar1-1 ) ;
14506: LD_EXP 46
14510: PPUSH
14511: LD_STRING D7a-Ar1-1
14513: PPUSH
14514: CALL_OW 94
// tmp := [ [ 129 , 10 ] , [ 103 , 6 ] , [ 148 , 47 ] , [ 155 , 16 ] ] ;
14518: LD_ADDR_VAR 0 4
14522: PUSH
14523: LD_INT 129
14525: PUSH
14526: LD_INT 10
14528: PUSH
14529: EMPTY
14530: LIST
14531: LIST
14532: PUSH
14533: LD_INT 103
14535: PUSH
14536: LD_INT 6
14538: PUSH
14539: EMPTY
14540: LIST
14541: LIST
14542: PUSH
14543: LD_INT 148
14545: PUSH
14546: LD_INT 47
14548: PUSH
14549: EMPTY
14550: LIST
14551: LIST
14552: PUSH
14553: LD_INT 155
14555: PUSH
14556: LD_INT 16
14558: PUSH
14559: EMPTY
14560: LIST
14561: LIST
14562: PUSH
14563: EMPTY
14564: LIST
14565: LIST
14566: LIST
14567: LIST
14568: ST_TO_ADDR
// if Difficulty = 1 then
14569: LD_OWVAR 67
14573: PUSH
14574: LD_INT 1
14576: EQUAL
14577: IFFALSE 14614
// tmp := tmp ^ [ [ 78 , 7 ] , [ 104 , 43 ] ] ;
14579: LD_ADDR_VAR 0 4
14583: PUSH
14584: LD_VAR 0 4
14588: PUSH
14589: LD_INT 78
14591: PUSH
14592: LD_INT 7
14594: PUSH
14595: EMPTY
14596: LIST
14597: LIST
14598: PUSH
14599: LD_INT 104
14601: PUSH
14602: LD_INT 43
14604: PUSH
14605: EMPTY
14606: LIST
14607: LIST
14608: PUSH
14609: EMPTY
14610: LIST
14611: LIST
14612: ADD
14613: ST_TO_ADDR
// for i in tmp do
14614: LD_ADDR_VAR 0 2
14618: PUSH
14619: LD_VAR 0 4
14623: PUSH
14624: FOR_IN
14625: IFFALSE 14658
// PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 9 ) ;
14627: LD_VAR 0 2
14631: PUSH
14632: LD_INT 1
14634: ARRAY
14635: PPUSH
14636: LD_VAR 0 2
14640: PUSH
14641: LD_INT 2
14643: ARRAY
14644: PPUSH
14645: LD_INT 1
14647: PPUSH
14648: LD_INT 9
14650: NEG
14651: PPUSH
14652: CALL_OW 330
14656: GO 14624
14658: POP
14659: POP
// CenterOnXY ( 129 , 10 ) ;
14660: LD_INT 129
14662: PPUSH
14663: LD_INT 10
14665: PPUSH
14666: CALL_OW 84
// end ;
14670: PPOPN 4
14672: END
// every 0 0$1 trigger game_time - 10 10$00 <= tick do
14673: LD_EXP 15
14677: PUSH
14678: LD_INT 21000
14680: MINUS
14681: PUSH
14682: LD_OWVAR 1
14686: LESSEQUAL
14687: IFFALSE 14727
14689: GO 14691
14691: DISABLE
// begin powell_warn := true ;
14692: LD_ADDR_EXP 16
14696: PUSH
14697: LD_INT 1
14699: ST_TO_ADDR
// DialogueOn ;
14700: CALL_OW 6
// SayRadio ( Powell , D9-Pow-1 ) ;
14704: LD_EXP 30
14708: PPUSH
14709: LD_STRING D9-Pow-1
14711: PPUSH
14712: CALL_OW 94
// dwait ( 0 0$0.3 ) ;
14716: LD_INT 10
14718: PPUSH
14719: CALL_OW 68
// DialogueOff ;
14723: CALL_OW 7
// end ;
14727: END
// every 0 0$1 trigger game_time <= tick do
14728: LD_EXP 15
14732: PUSH
14733: LD_OWVAR 1
14737: LESSEQUAL
14738: IFFALSE 14777
14740: GO 14742
14742: DISABLE
// begin DialogueOn ;
14743: CALL_OW 6
// SayRadio ( Powell , D9a-Pow-1 ) ;
14747: LD_EXP 30
14751: PPUSH
14752: LD_STRING D9a-Pow-1
14754: PPUSH
14755: CALL_OW 94
// dwait ( 0 0$2 ) ;
14759: LD_INT 70
14761: PPUSH
14762: CALL_OW 68
// DialogueOff ;
14766: CALL_OW 7
// YouLost ( Command ) ;
14770: LD_STRING Command
14772: PPUSH
14773: CALL_OW 104
// end ;
14777: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_warehouse ] ] ) = 0 and IsOk ( JMM ) do var tmp , m1 , m2 , m3 ;
14778: LD_INT 22
14780: PUSH
14781: LD_INT 2
14783: PUSH
14784: EMPTY
14785: LIST
14786: LIST
14787: PUSH
14788: LD_INT 30
14790: PUSH
14791: LD_INT 1
14793: PUSH
14794: EMPTY
14795: LIST
14796: LIST
14797: PUSH
14798: EMPTY
14799: LIST
14800: LIST
14801: PPUSH
14802: CALL_OW 69
14806: PUSH
14807: LD_INT 0
14809: EQUAL
14810: PUSH
14811: LD_EXP 21
14815: PPUSH
14816: CALL_OW 302
14820: AND
14821: IFFALSE 15730
14823: GO 14825
14825: DISABLE
14826: LD_INT 0
14828: PPUSH
14829: PPUSH
14830: PPUSH
14831: PPUSH
// begin m1 := false ;
14832: LD_ADDR_VAR 0 2
14836: PUSH
14837: LD_INT 0
14839: ST_TO_ADDR
// m2 := false ;
14840: LD_ADDR_VAR 0 3
14844: PUSH
14845: LD_INT 0
14847: ST_TO_ADDR
// m3 := false ;
14848: LD_ADDR_VAR 0 4
14852: PUSH
14853: LD_INT 0
14855: ST_TO_ADDR
// if not am_veh_consturcted then
14856: LD_EXP 20
14860: NOT
14861: IFFALSE 14870
// SetAchievement ( ACH_ARABTECH ) ;
14863: LD_STRING ACH_ARABTECH
14865: PPUSH
14866: CALL_OW 543
// if tick < [ 120 120$00 , 100 100$00 , 95 95$00 ] [ Difficulty ] then
14870: LD_OWVAR 1
14874: PUSH
14875: LD_INT 252000
14877: PUSH
14878: LD_INT 210000
14880: PUSH
14881: LD_INT 199500
14883: PUSH
14884: EMPTY
14885: LIST
14886: LIST
14887: LIST
14888: PUSH
14889: LD_OWVAR 67
14893: ARRAY
14894: LESS
14895: IFFALSE 14917
// begin m3 := true ;
14897: LD_ADDR_VAR 0 4
14901: PUSH
14902: LD_INT 1
14904: ST_TO_ADDR
// AddMedal ( Time1 , 1 ) ;
14905: LD_STRING Time1
14907: PPUSH
14908: LD_INT 1
14910: PPUSH
14911: CALL_OW 101
// end else
14915: GO 14948
// if not powell_warn then
14917: LD_EXP 16
14921: NOT
14922: IFFALSE 14937
// AddMedal ( Time1 , - 1 ) else
14924: LD_STRING Time1
14926: PPUSH
14927: LD_INT 1
14929: NEG
14930: PPUSH
14931: CALL_OW 101
14935: GO 14948
// AddMedal ( Time1 , - 2 ) ;
14937: LD_STRING Time1
14939: PPUSH
14940: LD_INT 2
14942: NEG
14943: PPUSH
14944: CALL_OW 101
// if loses_counter >= [ 5 , 4 , 3 ] [ Difficulty ] then
14948: LD_EXP 17
14952: PUSH
14953: LD_INT 5
14955: PUSH
14956: LD_INT 4
14958: PUSH
14959: LD_INT 3
14961: PUSH
14962: EMPTY
14963: LIST
14964: LIST
14965: LIST
14966: PUSH
14967: LD_OWVAR 67
14971: ARRAY
14972: GREATEREQUAL
14973: IFFALSE 14988
// AddMedal ( Destroy , - 2 ) else
14975: LD_STRING Destroy
14977: PPUSH
14978: LD_INT 2
14980: NEG
14981: PPUSH
14982: CALL_OW 101
14986: GO 15121
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 25 then
14988: LD_INT 22
14990: PUSH
14991: LD_INT 2
14993: PUSH
14994: EMPTY
14995: LIST
14996: LIST
14997: PUSH
14998: LD_INT 21
15000: PUSH
15001: LD_INT 3
15003: PUSH
15004: EMPTY
15005: LIST
15006: LIST
15007: PUSH
15008: LD_INT 50
15010: PUSH
15011: EMPTY
15012: LIST
15013: PUSH
15014: EMPTY
15015: LIST
15016: LIST
15017: LIST
15018: PPUSH
15019: CALL_OW 69
15023: PUSH
15024: LD_INT 25
15026: GREATEREQUAL
15027: IFFALSE 15042
// AddMedal ( Destroy , - 1 ) else
15029: LD_STRING Destroy
15031: PPUSH
15032: LD_INT 1
15034: NEG
15035: PPUSH
15036: CALL_OW 101
15040: GO 15121
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 15 then
15042: LD_INT 22
15044: PUSH
15045: LD_INT 2
15047: PUSH
15048: EMPTY
15049: LIST
15050: LIST
15051: PUSH
15052: LD_INT 21
15054: PUSH
15055: LD_INT 3
15057: PUSH
15058: EMPTY
15059: LIST
15060: LIST
15061: PUSH
15062: LD_INT 50
15064: PUSH
15065: EMPTY
15066: LIST
15067: PUSH
15068: EMPTY
15069: LIST
15070: LIST
15071: LIST
15072: PPUSH
15073: CALL_OW 69
15077: PUSH
15078: LD_INT 15
15080: GREATEREQUAL
15081: IFFALSE 15103
// begin m1 := true ;
15083: LD_ADDR_VAR 0 2
15087: PUSH
15088: LD_INT 1
15090: ST_TO_ADDR
// AddMedal ( Destroy , 1 ) ;
15091: LD_STRING Destroy
15093: PPUSH
15094: LD_INT 1
15096: PPUSH
15097: CALL_OW 101
// end else
15101: GO 15121
// begin m1 := true ;
15103: LD_ADDR_VAR 0 2
15107: PUSH
15108: LD_INT 1
15110: ST_TO_ADDR
// AddMedal ( Destroy , 2 ) ;
15111: LD_STRING Destroy
15113: PPUSH
15114: LD_INT 2
15116: PPUSH
15117: CALL_OW 101
// end ; SaveVariable ( artifact_get , 11_artifact_captured ) ;
15121: LD_EXP 13
15125: PPUSH
15126: LD_STRING 11_artifact_captured
15128: PPUSH
15129: CALL_OW 39
// if artifact_get then
15133: LD_EXP 13
15137: IFFALSE 15159
// begin m2 := true ;
15139: LD_ADDR_VAR 0 3
15143: PUSH
15144: LD_INT 1
15146: ST_TO_ADDR
// AddMedal ( Artefact , 1 ) ;
15147: LD_STRING Artefact
15149: PPUSH
15150: LD_INT 1
15152: PPUSH
15153: CALL_OW 101
// end else
15157: GO 15170
// AddMedal ( Artefact , - 1 ) ;
15159: LD_STRING Artefact
15161: PPUSH
15162: LD_INT 1
15164: NEG
15165: PPUSH
15166: CALL_OW 101
// if m1 and m2 and m3 and Difficulty = 3 then
15170: LD_VAR 0 2
15174: PUSH
15175: LD_VAR 0 3
15179: AND
15180: PUSH
15181: LD_VAR 0 4
15185: AND
15186: PUSH
15187: LD_OWVAR 67
15191: PUSH
15192: LD_INT 3
15194: EQUAL
15195: AND
15196: IFFALSE 15208
// SetAchievementEX ( ACH_AMER , 11 ) ;
15198: LD_STRING ACH_AMER
15200: PPUSH
15201: LD_INT 11
15203: PPUSH
15204: CALL_OW 564
// if m1 and m2 and m3 and loses_counter = 0 then
15208: LD_VAR 0 2
15212: PUSH
15213: LD_VAR 0 3
15217: AND
15218: PUSH
15219: LD_VAR 0 4
15223: AND
15224: PUSH
15225: LD_EXP 17
15229: PUSH
15230: LD_INT 0
15232: EQUAL
15233: AND
15234: IFFALSE 15250
// begin wait ( 3 ) ;
15236: LD_INT 3
15238: PPUSH
15239: CALL_OW 67
// SetAchievement ( ACH_GENERAL ) ;
15243: LD_STRING ACH_GENERAL
15245: PPUSH
15246: CALL_OW 543
// end ; if tick <= 100 100$00 then
15250: LD_OWVAR 1
15254: PUSH
15255: LD_INT 210000
15257: LESSEQUAL
15258: IFFALSE 15274
// begin wait ( 3 ) ;
15260: LD_INT 3
15262: PPUSH
15263: CALL_OW 67
// SetAchievement ( ACH_ASPEED_11 ) ;
15267: LD_STRING ACH_ASPEED_11
15269: PPUSH
15270: CALL_OW 543
// end ; GiveMedals ( MAIN ) ;
15274: LD_STRING MAIN
15276: PPUSH
15277: CALL_OW 102
// selected := UnitFilter ( selected , [ f_alive ] ) ;
15281: LD_ADDR_EXP 19
15285: PUSH
15286: LD_EXP 19
15290: PPUSH
15291: LD_INT 51
15293: PUSH
15294: EMPTY
15295: LIST
15296: PPUSH
15297: CALL_OW 72
15301: ST_TO_ADDR
// tmp := JMM ^ selected ;
15302: LD_ADDR_VAR 0 1
15306: PUSH
15307: LD_EXP 21
15311: PUSH
15312: LD_EXP 19
15316: ADD
15317: ST_TO_ADDR
// RewardPeople ( tmp ) ;
15318: LD_VAR 0 1
15322: PPUSH
15323: CALL_OW 43
// SaveCharacters ( tmp diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , 11c_others ) ;
15327: LD_VAR 0 1
15331: PUSH
15332: LD_EXP 21
15336: PUSH
15337: LD_EXP 22
15341: PUSH
15342: LD_EXP 23
15346: PUSH
15347: LD_EXP 24
15351: PUSH
15352: LD_EXP 25
15356: PUSH
15357: LD_EXP 26
15361: PUSH
15362: LD_EXP 27
15366: PUSH
15367: LD_EXP 28
15371: PUSH
15372: LD_EXP 29
15376: PUSH
15377: LD_EXP 31
15381: PUSH
15382: LD_EXP 32
15386: PUSH
15387: LD_EXP 33
15391: PUSH
15392: LD_EXP 34
15396: PUSH
15397: EMPTY
15398: LIST
15399: LIST
15400: LIST
15401: LIST
15402: LIST
15403: LIST
15404: LIST
15405: LIST
15406: LIST
15407: LIST
15408: LIST
15409: LIST
15410: LIST
15411: DIFF
15412: PPUSH
15413: LD_STRING 11c_others
15415: PPUSH
15416: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
15420: LD_EXP 21
15424: PPUSH
15425: LD_EXP 3
15429: PUSH
15430: LD_STRING JMM
15432: STR
15433: PPUSH
15434: CALL_OW 38
// if Lisa then
15438: LD_EXP 22
15442: IFFALSE 15462
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
15444: LD_EXP 22
15448: PPUSH
15449: LD_EXP 3
15453: PUSH
15454: LD_STRING Lisa
15456: STR
15457: PPUSH
15458: CALL_OW 38
// if Donaldson then
15462: LD_EXP 23
15466: IFFALSE 15486
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
15468: LD_EXP 23
15472: PPUSH
15473: LD_EXP 3
15477: PUSH
15478: LD_STRING Donaldson
15480: STR
15481: PPUSH
15482: CALL_OW 38
// if Bobby then
15486: LD_EXP 24
15490: IFFALSE 15510
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
15492: LD_EXP 24
15496: PPUSH
15497: LD_EXP 3
15501: PUSH
15502: LD_STRING Bobby
15504: STR
15505: PPUSH
15506: CALL_OW 38
// if Cyrus then
15510: LD_EXP 25
15514: IFFALSE 15534
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
15516: LD_EXP 25
15520: PPUSH
15521: LD_EXP 3
15525: PUSH
15526: LD_STRING Cyrus
15528: STR
15529: PPUSH
15530: CALL_OW 38
// if Denis then
15534: LD_EXP 26
15538: IFFALSE 15558
// SaveCharacters ( Denis , mission_prefix & Denis ) ;
15540: LD_EXP 26
15544: PPUSH
15545: LD_EXP 3
15549: PUSH
15550: LD_STRING Denis
15552: STR
15553: PPUSH
15554: CALL_OW 38
// if Brown then
15558: LD_EXP 27
15562: IFFALSE 15582
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
15564: LD_EXP 27
15568: PPUSH
15569: LD_EXP 3
15573: PUSH
15574: LD_STRING Brown
15576: STR
15577: PPUSH
15578: CALL_OW 38
// if Gladstone then
15582: LD_EXP 28
15586: IFFALSE 15606
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
15588: LD_EXP 28
15592: PPUSH
15593: LD_EXP 3
15597: PUSH
15598: LD_STRING Gladstone
15600: STR
15601: PPUSH
15602: CALL_OW 38
// if Houten then
15606: LD_EXP 29
15610: IFFALSE 15630
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
15612: LD_EXP 29
15616: PPUSH
15617: LD_EXP 3
15621: PUSH
15622: LD_STRING Houten
15624: STR
15625: PPUSH
15626: CALL_OW 38
// if Cornel then
15630: LD_EXP 31
15634: IFFALSE 15654
// SaveCharacters ( Cornel , mission_prefix & Cornell ) ;
15636: LD_EXP 31
15640: PPUSH
15641: LD_EXP 3
15645: PUSH
15646: LD_STRING Cornell
15648: STR
15649: PPUSH
15650: CALL_OW 38
// if Gary then
15654: LD_EXP 32
15658: IFFALSE 15678
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
15660: LD_EXP 32
15664: PPUSH
15665: LD_EXP 3
15669: PUSH
15670: LD_STRING Gary
15672: STR
15673: PPUSH
15674: CALL_OW 38
// if Frank then
15678: LD_EXP 33
15682: IFFALSE 15702
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
15684: LD_EXP 33
15688: PPUSH
15689: LD_EXP 3
15693: PUSH
15694: LD_STRING Frank
15696: STR
15697: PPUSH
15698: CALL_OW 38
// if Kikuchi then
15702: LD_EXP 34
15706: IFFALSE 15726
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
15708: LD_EXP 34
15712: PPUSH
15713: LD_EXP 3
15717: PUSH
15718: LD_STRING Kikuchi
15720: STR
15721: PPUSH
15722: CALL_OW 38
// YouWin ;
15726: CALL_OW 103
// end ;
15730: PPOPN 4
15732: END
// export function CanSayRand ( side ) ; begin
15733: LD_INT 0
15735: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
15736: LD_ADDR_VAR 0 2
15740: PUSH
15741: LD_INT 52
15743: PUSH
15744: EMPTY
15745: LIST
15746: PUSH
15747: LD_INT 22
15749: PUSH
15750: LD_VAR 0 1
15754: PUSH
15755: EMPTY
15756: LIST
15757: LIST
15758: PUSH
15759: LD_INT 2
15761: PUSH
15762: LD_INT 25
15764: PUSH
15765: LD_INT 1
15767: PUSH
15768: EMPTY
15769: LIST
15770: LIST
15771: PUSH
15772: LD_INT 25
15774: PUSH
15775: LD_INT 2
15777: PUSH
15778: EMPTY
15779: LIST
15780: LIST
15781: PUSH
15782: LD_INT 25
15784: PUSH
15785: LD_INT 3
15787: PUSH
15788: EMPTY
15789: LIST
15790: LIST
15791: PUSH
15792: LD_INT 25
15794: PUSH
15795: LD_INT 4
15797: PUSH
15798: EMPTY
15799: LIST
15800: LIST
15801: PUSH
15802: EMPTY
15803: LIST
15804: LIST
15805: LIST
15806: LIST
15807: LIST
15808: PUSH
15809: EMPTY
15810: LIST
15811: LIST
15812: LIST
15813: PPUSH
15814: CALL_OW 69
15818: PUSH
15819: LD_EXP 21
15823: PUSH
15824: LD_EXP 33
15828: PUSH
15829: LD_EXP 22
15833: PUSH
15834: LD_EXP 23
15838: PUSH
15839: LD_EXP 24
15843: PUSH
15844: LD_EXP 25
15848: PUSH
15849: LD_EXP 26
15853: PUSH
15854: LD_EXP 27
15858: PUSH
15859: LD_EXP 28
15863: PUSH
15864: LD_EXP 29
15868: PUSH
15869: LD_EXP 30
15873: PUSH
15874: LD_EXP 31
15878: PUSH
15879: LD_EXP 32
15883: PUSH
15884: LD_EXP 34
15888: PUSH
15889: EMPTY
15890: LIST
15891: LIST
15892: LIST
15893: LIST
15894: LIST
15895: LIST
15896: LIST
15897: LIST
15898: LIST
15899: LIST
15900: LIST
15901: LIST
15902: LIST
15903: LIST
15904: DIFF
15905: ST_TO_ADDR
// end ;
15906: LD_VAR 0 2
15910: RET
// export function SayRand ( sex , dial ) ; begin
15911: LD_INT 0
15913: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
15914: LD_ADDR_VAR 0 3
15918: PUSH
15919: LD_INT 52
15921: PUSH
15922: EMPTY
15923: LIST
15924: PUSH
15925: LD_INT 22
15927: PUSH
15928: LD_INT 1
15930: PUSH
15931: EMPTY
15932: LIST
15933: LIST
15934: PUSH
15935: LD_INT 26
15937: PUSH
15938: LD_VAR 0 1
15942: PUSH
15943: EMPTY
15944: LIST
15945: LIST
15946: PUSH
15947: LD_INT 2
15949: PUSH
15950: LD_INT 25
15952: PUSH
15953: LD_INT 1
15955: PUSH
15956: EMPTY
15957: LIST
15958: LIST
15959: PUSH
15960: LD_INT 25
15962: PUSH
15963: LD_INT 2
15965: PUSH
15966: EMPTY
15967: LIST
15968: LIST
15969: PUSH
15970: LD_INT 25
15972: PUSH
15973: LD_INT 3
15975: PUSH
15976: EMPTY
15977: LIST
15978: LIST
15979: PUSH
15980: LD_INT 25
15982: PUSH
15983: LD_INT 4
15985: PUSH
15986: EMPTY
15987: LIST
15988: LIST
15989: PUSH
15990: EMPTY
15991: LIST
15992: LIST
15993: LIST
15994: LIST
15995: LIST
15996: PUSH
15997: EMPTY
15998: LIST
15999: LIST
16000: LIST
16001: LIST
16002: PPUSH
16003: CALL_OW 69
16007: PUSH
16008: LD_EXP 21
16012: PUSH
16013: LD_EXP 33
16017: PUSH
16018: LD_EXP 22
16022: PUSH
16023: LD_EXP 23
16027: PUSH
16028: LD_EXP 24
16032: PUSH
16033: LD_EXP 25
16037: PUSH
16038: LD_EXP 26
16042: PUSH
16043: LD_EXP 27
16047: PUSH
16048: LD_EXP 28
16052: PUSH
16053: LD_EXP 29
16057: PUSH
16058: LD_EXP 30
16062: PUSH
16063: LD_EXP 31
16067: PUSH
16068: LD_EXP 32
16072: PUSH
16073: LD_EXP 34
16077: PUSH
16078: EMPTY
16079: LIST
16080: LIST
16081: LIST
16082: LIST
16083: LIST
16084: LIST
16085: LIST
16086: LIST
16087: LIST
16088: LIST
16089: LIST
16090: LIST
16091: LIST
16092: LIST
16093: DIFF
16094: ST_TO_ADDR
// if not result then
16095: LD_VAR 0 3
16099: NOT
16100: IFFALSE 16104
// exit ;
16102: GO 16132
// result := result [ 1 ] ;
16104: LD_ADDR_VAR 0 3
16108: PUSH
16109: LD_VAR 0 3
16113: PUSH
16114: LD_INT 1
16116: ARRAY
16117: ST_TO_ADDR
// Say ( result , dial ) ;
16118: LD_VAR 0 3
16122: PPUSH
16123: LD_VAR 0 2
16127: PPUSH
16128: CALL_OW 88
// end ;
16132: LD_VAR 0 3
16136: RET
// export function SayRand2 ( sex , dial , filter ) ; begin
16137: LD_INT 0
16139: PPUSH
// result := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ^ filter ;
16140: LD_ADDR_VAR 0 4
16144: PUSH
16145: LD_INT 22
16147: PUSH
16148: LD_INT 1
16150: PUSH
16151: EMPTY
16152: LIST
16153: LIST
16154: PUSH
16155: LD_INT 26
16157: PUSH
16158: LD_VAR 0 1
16162: PUSH
16163: EMPTY
16164: LIST
16165: LIST
16166: PUSH
16167: LD_INT 2
16169: PUSH
16170: LD_INT 25
16172: PUSH
16173: LD_INT 1
16175: PUSH
16176: EMPTY
16177: LIST
16178: LIST
16179: PUSH
16180: LD_INT 25
16182: PUSH
16183: LD_INT 2
16185: PUSH
16186: EMPTY
16187: LIST
16188: LIST
16189: PUSH
16190: LD_INT 25
16192: PUSH
16193: LD_INT 3
16195: PUSH
16196: EMPTY
16197: LIST
16198: LIST
16199: PUSH
16200: LD_INT 25
16202: PUSH
16203: LD_INT 4
16205: PUSH
16206: EMPTY
16207: LIST
16208: LIST
16209: PUSH
16210: EMPTY
16211: LIST
16212: LIST
16213: LIST
16214: LIST
16215: LIST
16216: PUSH
16217: EMPTY
16218: LIST
16219: LIST
16220: LIST
16221: PPUSH
16222: CALL_OW 69
16226: PUSH
16227: LD_EXP 21
16231: PUSH
16232: LD_EXP 33
16236: PUSH
16237: LD_EXP 22
16241: PUSH
16242: LD_EXP 23
16246: PUSH
16247: LD_EXP 24
16251: PUSH
16252: LD_EXP 25
16256: PUSH
16257: LD_EXP 26
16261: PUSH
16262: LD_EXP 27
16266: PUSH
16267: LD_EXP 28
16271: PUSH
16272: LD_EXP 29
16276: PUSH
16277: LD_EXP 30
16281: PUSH
16282: LD_EXP 31
16286: PUSH
16287: LD_EXP 32
16291: PUSH
16292: LD_EXP 34
16296: PUSH
16297: EMPTY
16298: LIST
16299: LIST
16300: LIST
16301: LIST
16302: LIST
16303: LIST
16304: LIST
16305: LIST
16306: LIST
16307: LIST
16308: LIST
16309: LIST
16310: LIST
16311: LIST
16312: PUSH
16313: LD_VAR 0 3
16317: ADD
16318: DIFF
16319: ST_TO_ADDR
// if not result then
16320: LD_VAR 0 4
16324: NOT
16325: IFFALSE 16329
// exit ;
16327: GO 16357
// result := result [ 1 ] ;
16329: LD_ADDR_VAR 0 4
16333: PUSH
16334: LD_VAR 0 4
16338: PUSH
16339: LD_INT 1
16341: ARRAY
16342: ST_TO_ADDR
// Say ( result , dial ) ;
16343: LD_VAR 0 4
16347: PPUSH
16348: LD_VAR 0 2
16352: PPUSH
16353: CALL_OW 88
// end ; end_of_file
16357: LD_VAR 0 4
16361: RET
// export function CustomEvent ( event ) ; begin
16362: LD_INT 0
16364: PPUSH
// end ;
16365: LD_VAR 0 2
16369: RET
// on ArtifactLoaded ( cargo , artifact ) do begin if GetSide ( cargo ) = 1 then
16370: LD_VAR 0 1
16374: PPUSH
16375: CALL_OW 255
16379: PUSH
16380: LD_INT 1
16382: EQUAL
16383: IFFALSE 16393
// artifact_get := true ;
16385: LD_ADDR_EXP 13
16389: PUSH
16390: LD_INT 1
16392: ST_TO_ADDR
// if GetSide ( cargo ) = 2 then
16393: LD_VAR 0 1
16397: PPUSH
16398: CALL_OW 255
16402: PUSH
16403: LD_INT 2
16405: EQUAL
16406: IFFALSE 16424
// begin artifact_get := false ;
16408: LD_ADDR_EXP 13
16412: PUSH
16413: LD_INT 0
16415: ST_TO_ADDR
// artifact_stolen := true ;
16416: LD_ADDR_EXP 12
16420: PUSH
16421: LD_INT 1
16423: ST_TO_ADDR
// end ; artifact_oncargo := true ;
16424: LD_ADDR_EXP 14
16428: PUSH
16429: LD_INT 1
16431: ST_TO_ADDR
// end ;
16432: PPOPN 2
16434: END
// on ArtifactUnloaded ( cargo , artifact ) do begin artifact_oncargo := false ;
16435: LD_ADDR_EXP 14
16439: PUSH
16440: LD_INT 0
16442: ST_TO_ADDR
// end ;
16443: PPOPN 2
16445: END
// on UnitDestroyed ( un ) do begin if un = JMM then
16446: LD_VAR 0 1
16450: PUSH
16451: LD_EXP 21
16455: EQUAL
16456: IFFALSE 16467
// begin YouLost ( JMM ) ;
16458: LD_STRING JMM
16460: PPUSH
16461: CALL_OW 104
// exit ;
16465: GO 16599
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) then
16467: LD_VAR 0 1
16471: PUSH
16472: LD_INT 22
16474: PUSH
16475: LD_INT 1
16477: PUSH
16478: EMPTY
16479: LIST
16480: LIST
16481: PUSH
16482: LD_INT 21
16484: PUSH
16485: LD_INT 1
16487: PUSH
16488: EMPTY
16489: LIST
16490: LIST
16491: PUSH
16492: LD_INT 2
16494: PUSH
16495: LD_INT 25
16497: PUSH
16498: LD_INT 1
16500: PUSH
16501: EMPTY
16502: LIST
16503: LIST
16504: PUSH
16505: LD_INT 25
16507: PUSH
16508: LD_INT 2
16510: PUSH
16511: EMPTY
16512: LIST
16513: LIST
16514: PUSH
16515: LD_INT 25
16517: PUSH
16518: LD_INT 3
16520: PUSH
16521: EMPTY
16522: LIST
16523: LIST
16524: PUSH
16525: LD_INT 25
16527: PUSH
16528: LD_INT 4
16530: PUSH
16531: EMPTY
16532: LIST
16533: LIST
16534: PUSH
16535: LD_INT 25
16537: PUSH
16538: LD_INT 5
16540: PUSH
16541: EMPTY
16542: LIST
16543: LIST
16544: PUSH
16545: LD_INT 25
16547: PUSH
16548: LD_INT 8
16550: PUSH
16551: EMPTY
16552: LIST
16553: LIST
16554: PUSH
16555: EMPTY
16556: LIST
16557: LIST
16558: LIST
16559: LIST
16560: LIST
16561: LIST
16562: LIST
16563: PUSH
16564: EMPTY
16565: LIST
16566: LIST
16567: LIST
16568: PPUSH
16569: CALL_OW 69
16573: IN
16574: IFFALSE 16590
// loses_counter := loses_counter + 1 ;
16576: LD_ADDR_EXP 17
16580: PUSH
16581: LD_EXP 17
16585: PUSH
16586: LD_INT 1
16588: PLUS
16589: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
16590: LD_VAR 0 1
16594: PPUSH
16595: CALL 44287 0 1
// end ;
16599: PPOPN 1
16601: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
16602: LD_VAR 0 1
16606: PPUSH
16607: LD_VAR 0 2
16611: PPUSH
16612: CALL 46621 0 2
// end ;
16616: PPOPN 2
16618: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
16619: LD_VAR 0 1
16623: PPUSH
16624: CALL 45930 0 1
// end ;
16628: PPOPN 1
16630: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
16631: LD_VAR 0 1
16635: PPUSH
16636: LD_VAR 0 2
16640: PPUSH
16641: LD_VAR 0 3
16645: PPUSH
16646: LD_VAR 0 4
16650: PPUSH
16651: LD_VAR 0 5
16655: PPUSH
16656: CALL 43603 0 5
// end ;
16660: PPOPN 5
16662: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetNation ( vehicle ) = nation_american then
16663: LD_VAR 0 1
16667: PPUSH
16668: CALL_OW 248
16672: PUSH
16673: LD_INT 1
16675: EQUAL
16676: IFFALSE 16686
// am_veh_consturcted := true ;
16678: LD_ADDR_EXP 20
16682: PUSH
16683: LD_INT 1
16685: ST_TO_ADDR
// MCE_VehicleConstructed ( vehicle , factory ) ;
16686: LD_VAR 0 1
16690: PPUSH
16691: LD_VAR 0 2
16695: PPUSH
16696: CALL 43199 0 2
// end ;
16700: PPOPN 2
16702: END
// on UnitKamikazed ( unit ) do begin if GetType ( unit ) = unit_vehicle then
16703: LD_VAR 0 1
16707: PPUSH
16708: CALL_OW 247
16712: PUSH
16713: LD_INT 2
16715: EQUAL
16716: IFFALSE 16720
// exit ;
16718: GO 16737
// if not kamikazed then
16720: LD_EXP 11
16724: NOT
16725: IFFALSE 16737
// kamikazed := unit ;
16727: LD_ADDR_EXP 11
16731: PUSH
16732: LD_VAR 0 1
16736: ST_TO_ADDR
// end ;
16737: PPOPN 1
16739: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do var i , tmp ;
16740: LD_INT 0
16742: PPUSH
16743: PPUSH
// begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
16744: LD_VAR 0 1
16748: PPUSH
16749: LD_VAR 0 2
16753: PPUSH
16754: LD_VAR 0 3
16758: PPUSH
16759: LD_VAR 0 4
16763: PPUSH
16764: CALL 43037 0 4
// end ;
16768: PPOPN 6
16770: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
16771: LD_VAR 0 1
16775: PPUSH
16776: LD_VAR 0 2
16780: PPUSH
16781: LD_VAR 0 3
16785: PPUSH
16786: CALL 42812 0 3
// end ;
16790: PPOPN 3
16792: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
16793: LD_VAR 0 1
16797: PPUSH
16798: LD_VAR 0 2
16802: PPUSH
16803: CALL 43983 0 2
// end ;
16807: PPOPN 2
16809: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
16810: LD_VAR 0 1
16814: PPUSH
16815: LD_VAR 0 2
16819: PPUSH
16820: CALL 42506 0 2
// end ;
16824: PPOPN 2
16826: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
16827: LD_VAR 0 1
16831: PPUSH
16832: LD_VAR 0 2
16836: PPUSH
16837: CALL 42697 0 2
// end ;
16841: PPOPN 2
16843: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
16844: LD_VAR 0 1
16848: PPUSH
16849: CALL 45689 0 1
// end ;
16853: PPOPN 1
16855: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
16856: LD_VAR 0 1
16860: PPUSH
16861: LD_VAR 0 2
16865: PPUSH
16866: CALL 46882 0 2
// end ;
16870: PPOPN 2
16872: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
16873: LD_VAR 0 1
16877: PPUSH
16878: LD_VAR 0 2
16882: PPUSH
16883: LD_VAR 0 3
16887: PPUSH
16888: LD_VAR 0 4
16892: PPUSH
16893: CALL 47098 0 4
// end ;
16897: PPOPN 4
16899: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
16900: LD_VAR 0 1
16904: PPUSH
16905: CALL 90454 0 1
// end ; end_of_file
16909: PPOPN 1
16911: END
// every 0 0$1 trigger game do
16912: LD_EXP 2
16916: IFFALSE 16946
16918: GO 16920
16920: DISABLE
// SpawnCrates ( [ crates_west , crates_east , crates_north_west , crates_east ] , 0 0$50 ) ;
16921: LD_INT 7
16923: PUSH
16924: LD_INT 6
16926: PUSH
16927: LD_INT 4
16929: PUSH
16930: LD_INT 6
16932: PUSH
16933: EMPTY
16934: LIST
16935: LIST
16936: LIST
16937: LIST
16938: PPUSH
16939: LD_INT 1750
16941: PPUSH
16942: CALL 16947 0 2
16946: END
// export function SpawnCrates ( areas , time ) ; var i , p ; begin
16947: LD_INT 0
16949: PPUSH
16950: PPUSH
16951: PPUSH
// if not areas then
16952: LD_VAR 0 1
16956: NOT
16957: IFFALSE 16961
// exit ;
16959: GO 17091
// repeat wait ( time ) ;
16961: LD_VAR 0 2
16965: PPUSH
16966: CALL_OW 67
// p := rand ( 1 , 90 ) ;
16970: LD_ADDR_VAR 0 5
16974: PUSH
16975: LD_INT 1
16977: PPUSH
16978: LD_INT 90
16980: PPUSH
16981: CALL_OW 12
16985: ST_TO_ADDR
// for i in areas do
16986: LD_ADDR_VAR 0 4
16990: PUSH
16991: LD_VAR 0 1
16995: PUSH
16996: FOR_IN
16997: IFFALSE 17050
// begin if Prob ( p ) then
16999: LD_VAR 0 5
17003: PPUSH
17004: CALL_OW 13
17008: IFFALSE 17048
// begin CreateCratesArea ( rand ( 1 , 5 ) , i , true ) ;
17010: LD_INT 1
17012: PPUSH
17013: LD_INT 5
17015: PPUSH
17016: CALL_OW 12
17020: PPUSH
17021: LD_VAR 0 4
17025: PPUSH
17026: LD_INT 1
17028: PPUSH
17029: CALL_OW 55
// wait ( rand ( 0 0$11 , 0 0$17 ) ) ;
17033: LD_INT 385
17035: PPUSH
17036: LD_INT 595
17038: PPUSH
17039: CALL_OW 12
17043: PPUSH
17044: CALL_OW 67
// end ; end ;
17048: GO 16996
17050: POP
17051: POP
// time := time + 0 0$3 ;
17052: LD_ADDR_VAR 0 2
17056: PUSH
17057: LD_VAR 0 2
17061: PUSH
17062: LD_INT 105
17064: PLUS
17065: ST_TO_ADDR
// if time > 7 7$00 then
17066: LD_VAR 0 2
17070: PUSH
17071: LD_INT 14700
17073: GREATER
17074: IFFALSE 17084
// time := 0 0$40 ;
17076: LD_ADDR_VAR 0 2
17080: PUSH
17081: LD_INT 1400
17083: ST_TO_ADDR
// until not game ;
17084: LD_EXP 2
17088: NOT
17089: IFFALSE 16961
// end ; end_of_file
17091: LD_VAR 0 3
17095: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
17096: LD_INT 0
17098: PPUSH
17099: PPUSH
// skirmish := false ;
17100: LD_ADDR_EXP 48
17104: PUSH
17105: LD_INT 0
17107: ST_TO_ADDR
// debug_mc := false ;
17108: LD_ADDR_EXP 49
17112: PUSH
17113: LD_INT 0
17115: ST_TO_ADDR
// mc_bases := [ ] ;
17116: LD_ADDR_EXP 50
17120: PUSH
17121: EMPTY
17122: ST_TO_ADDR
// mc_sides := [ ] ;
17123: LD_ADDR_EXP 76
17127: PUSH
17128: EMPTY
17129: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
17130: LD_ADDR_EXP 51
17134: PUSH
17135: EMPTY
17136: ST_TO_ADDR
// mc_building_repairs := [ ] ;
17137: LD_ADDR_EXP 52
17141: PUSH
17142: EMPTY
17143: ST_TO_ADDR
// mc_need_heal := [ ] ;
17144: LD_ADDR_EXP 53
17148: PUSH
17149: EMPTY
17150: ST_TO_ADDR
// mc_healers := [ ] ;
17151: LD_ADDR_EXP 54
17155: PUSH
17156: EMPTY
17157: ST_TO_ADDR
// mc_build_list := [ ] ;
17158: LD_ADDR_EXP 55
17162: PUSH
17163: EMPTY
17164: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
17165: LD_ADDR_EXP 82
17169: PUSH
17170: EMPTY
17171: ST_TO_ADDR
// mc_builders := [ ] ;
17172: LD_ADDR_EXP 56
17176: PUSH
17177: EMPTY
17178: ST_TO_ADDR
// mc_construct_list := [ ] ;
17179: LD_ADDR_EXP 57
17183: PUSH
17184: EMPTY
17185: ST_TO_ADDR
// mc_turret_list := [ ] ;
17186: LD_ADDR_EXP 58
17190: PUSH
17191: EMPTY
17192: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
17193: LD_ADDR_EXP 59
17197: PUSH
17198: EMPTY
17199: ST_TO_ADDR
// mc_miners := [ ] ;
17200: LD_ADDR_EXP 64
17204: PUSH
17205: EMPTY
17206: ST_TO_ADDR
// mc_mines := [ ] ;
17207: LD_ADDR_EXP 63
17211: PUSH
17212: EMPTY
17213: ST_TO_ADDR
// mc_minefields := [ ] ;
17214: LD_ADDR_EXP 65
17218: PUSH
17219: EMPTY
17220: ST_TO_ADDR
// mc_crates := [ ] ;
17221: LD_ADDR_EXP 66
17225: PUSH
17226: EMPTY
17227: ST_TO_ADDR
// mc_crates_collector := [ ] ;
17228: LD_ADDR_EXP 67
17232: PUSH
17233: EMPTY
17234: ST_TO_ADDR
// mc_crates_area := [ ] ;
17235: LD_ADDR_EXP 68
17239: PUSH
17240: EMPTY
17241: ST_TO_ADDR
// mc_vehicles := [ ] ;
17242: LD_ADDR_EXP 69
17246: PUSH
17247: EMPTY
17248: ST_TO_ADDR
// mc_attack := [ ] ;
17249: LD_ADDR_EXP 70
17253: PUSH
17254: EMPTY
17255: ST_TO_ADDR
// mc_produce := [ ] ;
17256: LD_ADDR_EXP 71
17260: PUSH
17261: EMPTY
17262: ST_TO_ADDR
// mc_defender := [ ] ;
17263: LD_ADDR_EXP 72
17267: PUSH
17268: EMPTY
17269: ST_TO_ADDR
// mc_parking := [ ] ;
17270: LD_ADDR_EXP 74
17274: PUSH
17275: EMPTY
17276: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
17277: LD_ADDR_EXP 60
17281: PUSH
17282: EMPTY
17283: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
17284: LD_ADDR_EXP 62
17288: PUSH
17289: EMPTY
17290: ST_TO_ADDR
// mc_scan := [ ] ;
17291: LD_ADDR_EXP 73
17295: PUSH
17296: EMPTY
17297: ST_TO_ADDR
// mc_scan_area := [ ] ;
17298: LD_ADDR_EXP 75
17302: PUSH
17303: EMPTY
17304: ST_TO_ADDR
// mc_tech := [ ] ;
17305: LD_ADDR_EXP 77
17309: PUSH
17310: EMPTY
17311: ST_TO_ADDR
// mc_class := [ ] ;
17312: LD_ADDR_EXP 91
17316: PUSH
17317: EMPTY
17318: ST_TO_ADDR
// mc_class_case_use := [ ] ;
17319: LD_ADDR_EXP 92
17323: PUSH
17324: EMPTY
17325: ST_TO_ADDR
// end ;
17326: LD_VAR 0 1
17330: RET
// export function MC_Kill ( base ) ; begin
17331: LD_INT 0
17333: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
17334: LD_ADDR_EXP 50
17338: PUSH
17339: LD_EXP 50
17343: PPUSH
17344: LD_VAR 0 1
17348: PPUSH
17349: EMPTY
17350: PPUSH
17351: CALL_OW 1
17355: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
17356: LD_ADDR_EXP 51
17360: PUSH
17361: LD_EXP 51
17365: PPUSH
17366: LD_VAR 0 1
17370: PPUSH
17371: EMPTY
17372: PPUSH
17373: CALL_OW 1
17377: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
17378: LD_ADDR_EXP 52
17382: PUSH
17383: LD_EXP 52
17387: PPUSH
17388: LD_VAR 0 1
17392: PPUSH
17393: EMPTY
17394: PPUSH
17395: CALL_OW 1
17399: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
17400: LD_ADDR_EXP 53
17404: PUSH
17405: LD_EXP 53
17409: PPUSH
17410: LD_VAR 0 1
17414: PPUSH
17415: EMPTY
17416: PPUSH
17417: CALL_OW 1
17421: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
17422: LD_ADDR_EXP 54
17426: PUSH
17427: LD_EXP 54
17431: PPUSH
17432: LD_VAR 0 1
17436: PPUSH
17437: EMPTY
17438: PPUSH
17439: CALL_OW 1
17443: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
17444: LD_ADDR_EXP 55
17448: PUSH
17449: LD_EXP 55
17453: PPUSH
17454: LD_VAR 0 1
17458: PPUSH
17459: EMPTY
17460: PPUSH
17461: CALL_OW 1
17465: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
17466: LD_ADDR_EXP 56
17470: PUSH
17471: LD_EXP 56
17475: PPUSH
17476: LD_VAR 0 1
17480: PPUSH
17481: EMPTY
17482: PPUSH
17483: CALL_OW 1
17487: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
17488: LD_ADDR_EXP 57
17492: PUSH
17493: LD_EXP 57
17497: PPUSH
17498: LD_VAR 0 1
17502: PPUSH
17503: EMPTY
17504: PPUSH
17505: CALL_OW 1
17509: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
17510: LD_ADDR_EXP 58
17514: PUSH
17515: LD_EXP 58
17519: PPUSH
17520: LD_VAR 0 1
17524: PPUSH
17525: EMPTY
17526: PPUSH
17527: CALL_OW 1
17531: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
17532: LD_ADDR_EXP 59
17536: PUSH
17537: LD_EXP 59
17541: PPUSH
17542: LD_VAR 0 1
17546: PPUSH
17547: EMPTY
17548: PPUSH
17549: CALL_OW 1
17553: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
17554: LD_ADDR_EXP 60
17558: PUSH
17559: LD_EXP 60
17563: PPUSH
17564: LD_VAR 0 1
17568: PPUSH
17569: EMPTY
17570: PPUSH
17571: CALL_OW 1
17575: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
17576: LD_ADDR_EXP 61
17580: PUSH
17581: LD_EXP 61
17585: PPUSH
17586: LD_VAR 0 1
17590: PPUSH
17591: LD_INT 0
17593: PPUSH
17594: CALL_OW 1
17598: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
17599: LD_ADDR_EXP 62
17603: PUSH
17604: LD_EXP 62
17608: PPUSH
17609: LD_VAR 0 1
17613: PPUSH
17614: EMPTY
17615: PPUSH
17616: CALL_OW 1
17620: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
17621: LD_ADDR_EXP 63
17625: PUSH
17626: LD_EXP 63
17630: PPUSH
17631: LD_VAR 0 1
17635: PPUSH
17636: EMPTY
17637: PPUSH
17638: CALL_OW 1
17642: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
17643: LD_ADDR_EXP 64
17647: PUSH
17648: LD_EXP 64
17652: PPUSH
17653: LD_VAR 0 1
17657: PPUSH
17658: EMPTY
17659: PPUSH
17660: CALL_OW 1
17664: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
17665: LD_ADDR_EXP 65
17669: PUSH
17670: LD_EXP 65
17674: PPUSH
17675: LD_VAR 0 1
17679: PPUSH
17680: EMPTY
17681: PPUSH
17682: CALL_OW 1
17686: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
17687: LD_ADDR_EXP 66
17691: PUSH
17692: LD_EXP 66
17696: PPUSH
17697: LD_VAR 0 1
17701: PPUSH
17702: EMPTY
17703: PPUSH
17704: CALL_OW 1
17708: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
17709: LD_ADDR_EXP 67
17713: PUSH
17714: LD_EXP 67
17718: PPUSH
17719: LD_VAR 0 1
17723: PPUSH
17724: EMPTY
17725: PPUSH
17726: CALL_OW 1
17730: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
17731: LD_ADDR_EXP 68
17735: PUSH
17736: LD_EXP 68
17740: PPUSH
17741: LD_VAR 0 1
17745: PPUSH
17746: EMPTY
17747: PPUSH
17748: CALL_OW 1
17752: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
17753: LD_ADDR_EXP 69
17757: PUSH
17758: LD_EXP 69
17762: PPUSH
17763: LD_VAR 0 1
17767: PPUSH
17768: EMPTY
17769: PPUSH
17770: CALL_OW 1
17774: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
17775: LD_ADDR_EXP 70
17779: PUSH
17780: LD_EXP 70
17784: PPUSH
17785: LD_VAR 0 1
17789: PPUSH
17790: EMPTY
17791: PPUSH
17792: CALL_OW 1
17796: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
17797: LD_ADDR_EXP 71
17801: PUSH
17802: LD_EXP 71
17806: PPUSH
17807: LD_VAR 0 1
17811: PPUSH
17812: EMPTY
17813: PPUSH
17814: CALL_OW 1
17818: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
17819: LD_ADDR_EXP 72
17823: PUSH
17824: LD_EXP 72
17828: PPUSH
17829: LD_VAR 0 1
17833: PPUSH
17834: EMPTY
17835: PPUSH
17836: CALL_OW 1
17840: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
17841: LD_ADDR_EXP 73
17845: PUSH
17846: LD_EXP 73
17850: PPUSH
17851: LD_VAR 0 1
17855: PPUSH
17856: EMPTY
17857: PPUSH
17858: CALL_OW 1
17862: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
17863: LD_ADDR_EXP 74
17867: PUSH
17868: LD_EXP 74
17872: PPUSH
17873: LD_VAR 0 1
17877: PPUSH
17878: EMPTY
17879: PPUSH
17880: CALL_OW 1
17884: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
17885: LD_ADDR_EXP 75
17889: PUSH
17890: LD_EXP 75
17894: PPUSH
17895: LD_VAR 0 1
17899: PPUSH
17900: EMPTY
17901: PPUSH
17902: CALL_OW 1
17906: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
17907: LD_ADDR_EXP 77
17911: PUSH
17912: LD_EXP 77
17916: PPUSH
17917: LD_VAR 0 1
17921: PPUSH
17922: EMPTY
17923: PPUSH
17924: CALL_OW 1
17928: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
17929: LD_ADDR_EXP 79
17933: PUSH
17934: LD_EXP 79
17938: PPUSH
17939: LD_VAR 0 1
17943: PPUSH
17944: EMPTY
17945: PPUSH
17946: CALL_OW 1
17950: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
17951: LD_ADDR_EXP 80
17955: PUSH
17956: LD_EXP 80
17960: PPUSH
17961: LD_VAR 0 1
17965: PPUSH
17966: EMPTY
17967: PPUSH
17968: CALL_OW 1
17972: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
17973: LD_ADDR_EXP 81
17977: PUSH
17978: LD_EXP 81
17982: PPUSH
17983: LD_VAR 0 1
17987: PPUSH
17988: EMPTY
17989: PPUSH
17990: CALL_OW 1
17994: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
17995: LD_ADDR_EXP 82
17999: PUSH
18000: LD_EXP 82
18004: PPUSH
18005: LD_VAR 0 1
18009: PPUSH
18010: EMPTY
18011: PPUSH
18012: CALL_OW 1
18016: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
18017: LD_ADDR_EXP 83
18021: PUSH
18022: LD_EXP 83
18026: PPUSH
18027: LD_VAR 0 1
18031: PPUSH
18032: EMPTY
18033: PPUSH
18034: CALL_OW 1
18038: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
18039: LD_ADDR_EXP 84
18043: PUSH
18044: LD_EXP 84
18048: PPUSH
18049: LD_VAR 0 1
18053: PPUSH
18054: EMPTY
18055: PPUSH
18056: CALL_OW 1
18060: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
18061: LD_ADDR_EXP 85
18065: PUSH
18066: LD_EXP 85
18070: PPUSH
18071: LD_VAR 0 1
18075: PPUSH
18076: EMPTY
18077: PPUSH
18078: CALL_OW 1
18082: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
18083: LD_ADDR_EXP 86
18087: PUSH
18088: LD_EXP 86
18092: PPUSH
18093: LD_VAR 0 1
18097: PPUSH
18098: EMPTY
18099: PPUSH
18100: CALL_OW 1
18104: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
18105: LD_ADDR_EXP 87
18109: PUSH
18110: LD_EXP 87
18114: PPUSH
18115: LD_VAR 0 1
18119: PPUSH
18120: EMPTY
18121: PPUSH
18122: CALL_OW 1
18126: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
18127: LD_ADDR_EXP 88
18131: PUSH
18132: LD_EXP 88
18136: PPUSH
18137: LD_VAR 0 1
18141: PPUSH
18142: EMPTY
18143: PPUSH
18144: CALL_OW 1
18148: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
18149: LD_ADDR_EXP 89
18153: PUSH
18154: LD_EXP 89
18158: PPUSH
18159: LD_VAR 0 1
18163: PPUSH
18164: EMPTY
18165: PPUSH
18166: CALL_OW 1
18170: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
18171: LD_ADDR_EXP 90
18175: PUSH
18176: LD_EXP 90
18180: PPUSH
18181: LD_VAR 0 1
18185: PPUSH
18186: EMPTY
18187: PPUSH
18188: CALL_OW 1
18192: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
18193: LD_ADDR_EXP 91
18197: PUSH
18198: LD_EXP 91
18202: PPUSH
18203: LD_VAR 0 1
18207: PPUSH
18208: EMPTY
18209: PPUSH
18210: CALL_OW 1
18214: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
18215: LD_ADDR_EXP 92
18219: PUSH
18220: LD_EXP 92
18224: PPUSH
18225: LD_VAR 0 1
18229: PPUSH
18230: LD_INT 0
18232: PPUSH
18233: CALL_OW 1
18237: ST_TO_ADDR
// end ;
18238: LD_VAR 0 2
18242: RET
// export function MC_Add ( side , units ) ; var base ; begin
18243: LD_INT 0
18245: PPUSH
18246: PPUSH
// base := mc_bases + 1 ;
18247: LD_ADDR_VAR 0 4
18251: PUSH
18252: LD_EXP 50
18256: PUSH
18257: LD_INT 1
18259: PLUS
18260: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
18261: LD_ADDR_EXP 76
18265: PUSH
18266: LD_EXP 76
18270: PPUSH
18271: LD_VAR 0 4
18275: PPUSH
18276: LD_VAR 0 1
18280: PPUSH
18281: CALL_OW 1
18285: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
18286: LD_ADDR_EXP 50
18290: PUSH
18291: LD_EXP 50
18295: PPUSH
18296: LD_VAR 0 4
18300: PPUSH
18301: LD_VAR 0 2
18305: PPUSH
18306: CALL_OW 1
18310: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
18311: LD_ADDR_EXP 51
18315: PUSH
18316: LD_EXP 51
18320: PPUSH
18321: LD_VAR 0 4
18325: PPUSH
18326: EMPTY
18327: PPUSH
18328: CALL_OW 1
18332: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
18333: LD_ADDR_EXP 52
18337: PUSH
18338: LD_EXP 52
18342: PPUSH
18343: LD_VAR 0 4
18347: PPUSH
18348: EMPTY
18349: PPUSH
18350: CALL_OW 1
18354: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
18355: LD_ADDR_EXP 53
18359: PUSH
18360: LD_EXP 53
18364: PPUSH
18365: LD_VAR 0 4
18369: PPUSH
18370: EMPTY
18371: PPUSH
18372: CALL_OW 1
18376: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
18377: LD_ADDR_EXP 54
18381: PUSH
18382: LD_EXP 54
18386: PPUSH
18387: LD_VAR 0 4
18391: PPUSH
18392: EMPTY
18393: PPUSH
18394: CALL_OW 1
18398: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
18399: LD_ADDR_EXP 55
18403: PUSH
18404: LD_EXP 55
18408: PPUSH
18409: LD_VAR 0 4
18413: PPUSH
18414: EMPTY
18415: PPUSH
18416: CALL_OW 1
18420: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
18421: LD_ADDR_EXP 56
18425: PUSH
18426: LD_EXP 56
18430: PPUSH
18431: LD_VAR 0 4
18435: PPUSH
18436: EMPTY
18437: PPUSH
18438: CALL_OW 1
18442: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
18443: LD_ADDR_EXP 57
18447: PUSH
18448: LD_EXP 57
18452: PPUSH
18453: LD_VAR 0 4
18457: PPUSH
18458: EMPTY
18459: PPUSH
18460: CALL_OW 1
18464: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
18465: LD_ADDR_EXP 58
18469: PUSH
18470: LD_EXP 58
18474: PPUSH
18475: LD_VAR 0 4
18479: PPUSH
18480: EMPTY
18481: PPUSH
18482: CALL_OW 1
18486: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
18487: LD_ADDR_EXP 59
18491: PUSH
18492: LD_EXP 59
18496: PPUSH
18497: LD_VAR 0 4
18501: PPUSH
18502: EMPTY
18503: PPUSH
18504: CALL_OW 1
18508: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
18509: LD_ADDR_EXP 60
18513: PUSH
18514: LD_EXP 60
18518: PPUSH
18519: LD_VAR 0 4
18523: PPUSH
18524: EMPTY
18525: PPUSH
18526: CALL_OW 1
18530: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
18531: LD_ADDR_EXP 61
18535: PUSH
18536: LD_EXP 61
18540: PPUSH
18541: LD_VAR 0 4
18545: PPUSH
18546: LD_INT 0
18548: PPUSH
18549: CALL_OW 1
18553: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
18554: LD_ADDR_EXP 62
18558: PUSH
18559: LD_EXP 62
18563: PPUSH
18564: LD_VAR 0 4
18568: PPUSH
18569: EMPTY
18570: PPUSH
18571: CALL_OW 1
18575: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
18576: LD_ADDR_EXP 63
18580: PUSH
18581: LD_EXP 63
18585: PPUSH
18586: LD_VAR 0 4
18590: PPUSH
18591: EMPTY
18592: PPUSH
18593: CALL_OW 1
18597: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
18598: LD_ADDR_EXP 64
18602: PUSH
18603: LD_EXP 64
18607: PPUSH
18608: LD_VAR 0 4
18612: PPUSH
18613: EMPTY
18614: PPUSH
18615: CALL_OW 1
18619: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
18620: LD_ADDR_EXP 65
18624: PUSH
18625: LD_EXP 65
18629: PPUSH
18630: LD_VAR 0 4
18634: PPUSH
18635: EMPTY
18636: PPUSH
18637: CALL_OW 1
18641: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
18642: LD_ADDR_EXP 66
18646: PUSH
18647: LD_EXP 66
18651: PPUSH
18652: LD_VAR 0 4
18656: PPUSH
18657: EMPTY
18658: PPUSH
18659: CALL_OW 1
18663: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
18664: LD_ADDR_EXP 67
18668: PUSH
18669: LD_EXP 67
18673: PPUSH
18674: LD_VAR 0 4
18678: PPUSH
18679: EMPTY
18680: PPUSH
18681: CALL_OW 1
18685: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
18686: LD_ADDR_EXP 68
18690: PUSH
18691: LD_EXP 68
18695: PPUSH
18696: LD_VAR 0 4
18700: PPUSH
18701: EMPTY
18702: PPUSH
18703: CALL_OW 1
18707: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
18708: LD_ADDR_EXP 69
18712: PUSH
18713: LD_EXP 69
18717: PPUSH
18718: LD_VAR 0 4
18722: PPUSH
18723: EMPTY
18724: PPUSH
18725: CALL_OW 1
18729: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
18730: LD_ADDR_EXP 70
18734: PUSH
18735: LD_EXP 70
18739: PPUSH
18740: LD_VAR 0 4
18744: PPUSH
18745: EMPTY
18746: PPUSH
18747: CALL_OW 1
18751: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
18752: LD_ADDR_EXP 71
18756: PUSH
18757: LD_EXP 71
18761: PPUSH
18762: LD_VAR 0 4
18766: PPUSH
18767: EMPTY
18768: PPUSH
18769: CALL_OW 1
18773: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
18774: LD_ADDR_EXP 72
18778: PUSH
18779: LD_EXP 72
18783: PPUSH
18784: LD_VAR 0 4
18788: PPUSH
18789: EMPTY
18790: PPUSH
18791: CALL_OW 1
18795: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
18796: LD_ADDR_EXP 73
18800: PUSH
18801: LD_EXP 73
18805: PPUSH
18806: LD_VAR 0 4
18810: PPUSH
18811: EMPTY
18812: PPUSH
18813: CALL_OW 1
18817: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
18818: LD_ADDR_EXP 74
18822: PUSH
18823: LD_EXP 74
18827: PPUSH
18828: LD_VAR 0 4
18832: PPUSH
18833: EMPTY
18834: PPUSH
18835: CALL_OW 1
18839: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
18840: LD_ADDR_EXP 75
18844: PUSH
18845: LD_EXP 75
18849: PPUSH
18850: LD_VAR 0 4
18854: PPUSH
18855: EMPTY
18856: PPUSH
18857: CALL_OW 1
18861: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
18862: LD_ADDR_EXP 77
18866: PUSH
18867: LD_EXP 77
18871: PPUSH
18872: LD_VAR 0 4
18876: PPUSH
18877: EMPTY
18878: PPUSH
18879: CALL_OW 1
18883: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
18884: LD_ADDR_EXP 79
18888: PUSH
18889: LD_EXP 79
18893: PPUSH
18894: LD_VAR 0 4
18898: PPUSH
18899: EMPTY
18900: PPUSH
18901: CALL_OW 1
18905: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
18906: LD_ADDR_EXP 80
18910: PUSH
18911: LD_EXP 80
18915: PPUSH
18916: LD_VAR 0 4
18920: PPUSH
18921: EMPTY
18922: PPUSH
18923: CALL_OW 1
18927: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
18928: LD_ADDR_EXP 81
18932: PUSH
18933: LD_EXP 81
18937: PPUSH
18938: LD_VAR 0 4
18942: PPUSH
18943: EMPTY
18944: PPUSH
18945: CALL_OW 1
18949: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
18950: LD_ADDR_EXP 82
18954: PUSH
18955: LD_EXP 82
18959: PPUSH
18960: LD_VAR 0 4
18964: PPUSH
18965: EMPTY
18966: PPUSH
18967: CALL_OW 1
18971: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
18972: LD_ADDR_EXP 83
18976: PUSH
18977: LD_EXP 83
18981: PPUSH
18982: LD_VAR 0 4
18986: PPUSH
18987: EMPTY
18988: PPUSH
18989: CALL_OW 1
18993: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
18994: LD_ADDR_EXP 84
18998: PUSH
18999: LD_EXP 84
19003: PPUSH
19004: LD_VAR 0 4
19008: PPUSH
19009: EMPTY
19010: PPUSH
19011: CALL_OW 1
19015: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
19016: LD_ADDR_EXP 85
19020: PUSH
19021: LD_EXP 85
19025: PPUSH
19026: LD_VAR 0 4
19030: PPUSH
19031: EMPTY
19032: PPUSH
19033: CALL_OW 1
19037: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
19038: LD_ADDR_EXP 86
19042: PUSH
19043: LD_EXP 86
19047: PPUSH
19048: LD_VAR 0 4
19052: PPUSH
19053: EMPTY
19054: PPUSH
19055: CALL_OW 1
19059: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
19060: LD_ADDR_EXP 87
19064: PUSH
19065: LD_EXP 87
19069: PPUSH
19070: LD_VAR 0 4
19074: PPUSH
19075: EMPTY
19076: PPUSH
19077: CALL_OW 1
19081: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
19082: LD_ADDR_EXP 88
19086: PUSH
19087: LD_EXP 88
19091: PPUSH
19092: LD_VAR 0 4
19096: PPUSH
19097: EMPTY
19098: PPUSH
19099: CALL_OW 1
19103: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
19104: LD_ADDR_EXP 89
19108: PUSH
19109: LD_EXP 89
19113: PPUSH
19114: LD_VAR 0 4
19118: PPUSH
19119: EMPTY
19120: PPUSH
19121: CALL_OW 1
19125: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
19126: LD_ADDR_EXP 90
19130: PUSH
19131: LD_EXP 90
19135: PPUSH
19136: LD_VAR 0 4
19140: PPUSH
19141: EMPTY
19142: PPUSH
19143: CALL_OW 1
19147: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
19148: LD_ADDR_EXP 91
19152: PUSH
19153: LD_EXP 91
19157: PPUSH
19158: LD_VAR 0 4
19162: PPUSH
19163: EMPTY
19164: PPUSH
19165: CALL_OW 1
19169: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
19170: LD_ADDR_EXP 92
19174: PUSH
19175: LD_EXP 92
19179: PPUSH
19180: LD_VAR 0 4
19184: PPUSH
19185: LD_INT 0
19187: PPUSH
19188: CALL_OW 1
19192: ST_TO_ADDR
// result := base ;
19193: LD_ADDR_VAR 0 3
19197: PUSH
19198: LD_VAR 0 4
19202: ST_TO_ADDR
// end ;
19203: LD_VAR 0 3
19207: RET
// export function MC_Start ( ) ; var i ; begin
19208: LD_INT 0
19210: PPUSH
19211: PPUSH
// for i = 1 to mc_bases do
19212: LD_ADDR_VAR 0 2
19216: PUSH
19217: DOUBLE
19218: LD_INT 1
19220: DEC
19221: ST_TO_ADDR
19222: LD_EXP 50
19226: PUSH
19227: FOR_TO
19228: IFFALSE 20305
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
19230: LD_ADDR_EXP 50
19234: PUSH
19235: LD_EXP 50
19239: PPUSH
19240: LD_VAR 0 2
19244: PPUSH
19245: LD_EXP 50
19249: PUSH
19250: LD_VAR 0 2
19254: ARRAY
19255: PUSH
19256: LD_INT 0
19258: DIFF
19259: PPUSH
19260: CALL_OW 1
19264: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
19265: LD_ADDR_EXP 51
19269: PUSH
19270: LD_EXP 51
19274: PPUSH
19275: LD_VAR 0 2
19279: PPUSH
19280: EMPTY
19281: PPUSH
19282: CALL_OW 1
19286: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
19287: LD_ADDR_EXP 52
19291: PUSH
19292: LD_EXP 52
19296: PPUSH
19297: LD_VAR 0 2
19301: PPUSH
19302: EMPTY
19303: PPUSH
19304: CALL_OW 1
19308: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
19309: LD_ADDR_EXP 53
19313: PUSH
19314: LD_EXP 53
19318: PPUSH
19319: LD_VAR 0 2
19323: PPUSH
19324: EMPTY
19325: PPUSH
19326: CALL_OW 1
19330: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
19331: LD_ADDR_EXP 54
19335: PUSH
19336: LD_EXP 54
19340: PPUSH
19341: LD_VAR 0 2
19345: PPUSH
19346: EMPTY
19347: PUSH
19348: EMPTY
19349: PUSH
19350: EMPTY
19351: LIST
19352: LIST
19353: PPUSH
19354: CALL_OW 1
19358: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
19359: LD_ADDR_EXP 55
19363: PUSH
19364: LD_EXP 55
19368: PPUSH
19369: LD_VAR 0 2
19373: PPUSH
19374: EMPTY
19375: PPUSH
19376: CALL_OW 1
19380: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
19381: LD_ADDR_EXP 82
19385: PUSH
19386: LD_EXP 82
19390: PPUSH
19391: LD_VAR 0 2
19395: PPUSH
19396: EMPTY
19397: PPUSH
19398: CALL_OW 1
19402: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
19403: LD_ADDR_EXP 56
19407: PUSH
19408: LD_EXP 56
19412: PPUSH
19413: LD_VAR 0 2
19417: PPUSH
19418: EMPTY
19419: PPUSH
19420: CALL_OW 1
19424: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
19425: LD_ADDR_EXP 57
19429: PUSH
19430: LD_EXP 57
19434: PPUSH
19435: LD_VAR 0 2
19439: PPUSH
19440: EMPTY
19441: PPUSH
19442: CALL_OW 1
19446: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
19447: LD_ADDR_EXP 58
19451: PUSH
19452: LD_EXP 58
19456: PPUSH
19457: LD_VAR 0 2
19461: PPUSH
19462: LD_EXP 50
19466: PUSH
19467: LD_VAR 0 2
19471: ARRAY
19472: PPUSH
19473: LD_INT 2
19475: PUSH
19476: LD_INT 30
19478: PUSH
19479: LD_INT 32
19481: PUSH
19482: EMPTY
19483: LIST
19484: LIST
19485: PUSH
19486: LD_INT 30
19488: PUSH
19489: LD_INT 33
19491: PUSH
19492: EMPTY
19493: LIST
19494: LIST
19495: PUSH
19496: EMPTY
19497: LIST
19498: LIST
19499: LIST
19500: PPUSH
19501: CALL_OW 72
19505: PPUSH
19506: CALL_OW 1
19510: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
19511: LD_ADDR_EXP 59
19515: PUSH
19516: LD_EXP 59
19520: PPUSH
19521: LD_VAR 0 2
19525: PPUSH
19526: LD_EXP 50
19530: PUSH
19531: LD_VAR 0 2
19535: ARRAY
19536: PPUSH
19537: LD_INT 2
19539: PUSH
19540: LD_INT 30
19542: PUSH
19543: LD_INT 32
19545: PUSH
19546: EMPTY
19547: LIST
19548: LIST
19549: PUSH
19550: LD_INT 30
19552: PUSH
19553: LD_INT 31
19555: PUSH
19556: EMPTY
19557: LIST
19558: LIST
19559: PUSH
19560: EMPTY
19561: LIST
19562: LIST
19563: LIST
19564: PUSH
19565: LD_INT 58
19567: PUSH
19568: EMPTY
19569: LIST
19570: PUSH
19571: EMPTY
19572: LIST
19573: LIST
19574: PPUSH
19575: CALL_OW 72
19579: PPUSH
19580: CALL_OW 1
19584: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
19585: LD_ADDR_EXP 60
19589: PUSH
19590: LD_EXP 60
19594: PPUSH
19595: LD_VAR 0 2
19599: PPUSH
19600: EMPTY
19601: PPUSH
19602: CALL_OW 1
19606: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
19607: LD_ADDR_EXP 64
19611: PUSH
19612: LD_EXP 64
19616: PPUSH
19617: LD_VAR 0 2
19621: PPUSH
19622: EMPTY
19623: PPUSH
19624: CALL_OW 1
19628: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
19629: LD_ADDR_EXP 63
19633: PUSH
19634: LD_EXP 63
19638: PPUSH
19639: LD_VAR 0 2
19643: PPUSH
19644: EMPTY
19645: PPUSH
19646: CALL_OW 1
19650: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
19651: LD_ADDR_EXP 65
19655: PUSH
19656: LD_EXP 65
19660: PPUSH
19661: LD_VAR 0 2
19665: PPUSH
19666: EMPTY
19667: PPUSH
19668: CALL_OW 1
19672: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
19673: LD_ADDR_EXP 66
19677: PUSH
19678: LD_EXP 66
19682: PPUSH
19683: LD_VAR 0 2
19687: PPUSH
19688: EMPTY
19689: PPUSH
19690: CALL_OW 1
19694: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
19695: LD_ADDR_EXP 67
19699: PUSH
19700: LD_EXP 67
19704: PPUSH
19705: LD_VAR 0 2
19709: PPUSH
19710: EMPTY
19711: PPUSH
19712: CALL_OW 1
19716: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
19717: LD_ADDR_EXP 68
19721: PUSH
19722: LD_EXP 68
19726: PPUSH
19727: LD_VAR 0 2
19731: PPUSH
19732: EMPTY
19733: PPUSH
19734: CALL_OW 1
19738: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
19739: LD_ADDR_EXP 69
19743: PUSH
19744: LD_EXP 69
19748: PPUSH
19749: LD_VAR 0 2
19753: PPUSH
19754: EMPTY
19755: PPUSH
19756: CALL_OW 1
19760: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
19761: LD_ADDR_EXP 70
19765: PUSH
19766: LD_EXP 70
19770: PPUSH
19771: LD_VAR 0 2
19775: PPUSH
19776: EMPTY
19777: PPUSH
19778: CALL_OW 1
19782: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
19783: LD_ADDR_EXP 71
19787: PUSH
19788: LD_EXP 71
19792: PPUSH
19793: LD_VAR 0 2
19797: PPUSH
19798: EMPTY
19799: PPUSH
19800: CALL_OW 1
19804: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
19805: LD_ADDR_EXP 72
19809: PUSH
19810: LD_EXP 72
19814: PPUSH
19815: LD_VAR 0 2
19819: PPUSH
19820: EMPTY
19821: PPUSH
19822: CALL_OW 1
19826: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
19827: LD_ADDR_EXP 61
19831: PUSH
19832: LD_EXP 61
19836: PPUSH
19837: LD_VAR 0 2
19841: PPUSH
19842: LD_INT 0
19844: PPUSH
19845: CALL_OW 1
19849: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
19850: LD_ADDR_EXP 74
19854: PUSH
19855: LD_EXP 74
19859: PPUSH
19860: LD_VAR 0 2
19864: PPUSH
19865: LD_INT 0
19867: PPUSH
19868: CALL_OW 1
19872: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
19873: LD_ADDR_EXP 62
19877: PUSH
19878: LD_EXP 62
19882: PPUSH
19883: LD_VAR 0 2
19887: PPUSH
19888: EMPTY
19889: PPUSH
19890: CALL_OW 1
19894: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
19895: LD_ADDR_EXP 73
19899: PUSH
19900: LD_EXP 73
19904: PPUSH
19905: LD_VAR 0 2
19909: PPUSH
19910: LD_INT 0
19912: PPUSH
19913: CALL_OW 1
19917: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
19918: LD_ADDR_EXP 75
19922: PUSH
19923: LD_EXP 75
19927: PPUSH
19928: LD_VAR 0 2
19932: PPUSH
19933: EMPTY
19934: PPUSH
19935: CALL_OW 1
19939: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
19940: LD_ADDR_EXP 78
19944: PUSH
19945: LD_EXP 78
19949: PPUSH
19950: LD_VAR 0 2
19954: PPUSH
19955: LD_INT 0
19957: PPUSH
19958: CALL_OW 1
19962: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
19963: LD_ADDR_EXP 79
19967: PUSH
19968: LD_EXP 79
19972: PPUSH
19973: LD_VAR 0 2
19977: PPUSH
19978: EMPTY
19979: PPUSH
19980: CALL_OW 1
19984: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
19985: LD_ADDR_EXP 80
19989: PUSH
19990: LD_EXP 80
19994: PPUSH
19995: LD_VAR 0 2
19999: PPUSH
20000: EMPTY
20001: PPUSH
20002: CALL_OW 1
20006: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
20007: LD_ADDR_EXP 81
20011: PUSH
20012: LD_EXP 81
20016: PPUSH
20017: LD_VAR 0 2
20021: PPUSH
20022: EMPTY
20023: PPUSH
20024: CALL_OW 1
20028: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
20029: LD_ADDR_EXP 83
20033: PUSH
20034: LD_EXP 83
20038: PPUSH
20039: LD_VAR 0 2
20043: PPUSH
20044: LD_EXP 50
20048: PUSH
20049: LD_VAR 0 2
20053: ARRAY
20054: PPUSH
20055: LD_INT 2
20057: PUSH
20058: LD_INT 30
20060: PUSH
20061: LD_INT 6
20063: PUSH
20064: EMPTY
20065: LIST
20066: LIST
20067: PUSH
20068: LD_INT 30
20070: PUSH
20071: LD_INT 7
20073: PUSH
20074: EMPTY
20075: LIST
20076: LIST
20077: PUSH
20078: LD_INT 30
20080: PUSH
20081: LD_INT 8
20083: PUSH
20084: EMPTY
20085: LIST
20086: LIST
20087: PUSH
20088: EMPTY
20089: LIST
20090: LIST
20091: LIST
20092: LIST
20093: PPUSH
20094: CALL_OW 72
20098: PPUSH
20099: CALL_OW 1
20103: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
20104: LD_ADDR_EXP 84
20108: PUSH
20109: LD_EXP 84
20113: PPUSH
20114: LD_VAR 0 2
20118: PPUSH
20119: EMPTY
20120: PPUSH
20121: CALL_OW 1
20125: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
20126: LD_ADDR_EXP 85
20130: PUSH
20131: LD_EXP 85
20135: PPUSH
20136: LD_VAR 0 2
20140: PPUSH
20141: EMPTY
20142: PPUSH
20143: CALL_OW 1
20147: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
20148: LD_ADDR_EXP 86
20152: PUSH
20153: LD_EXP 86
20157: PPUSH
20158: LD_VAR 0 2
20162: PPUSH
20163: EMPTY
20164: PPUSH
20165: CALL_OW 1
20169: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
20170: LD_ADDR_EXP 87
20174: PUSH
20175: LD_EXP 87
20179: PPUSH
20180: LD_VAR 0 2
20184: PPUSH
20185: EMPTY
20186: PPUSH
20187: CALL_OW 1
20191: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
20192: LD_ADDR_EXP 88
20196: PUSH
20197: LD_EXP 88
20201: PPUSH
20202: LD_VAR 0 2
20206: PPUSH
20207: EMPTY
20208: PPUSH
20209: CALL_OW 1
20213: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
20214: LD_ADDR_EXP 89
20218: PUSH
20219: LD_EXP 89
20223: PPUSH
20224: LD_VAR 0 2
20228: PPUSH
20229: EMPTY
20230: PPUSH
20231: CALL_OW 1
20235: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
20236: LD_ADDR_EXP 90
20240: PUSH
20241: LD_EXP 90
20245: PPUSH
20246: LD_VAR 0 2
20250: PPUSH
20251: EMPTY
20252: PPUSH
20253: CALL_OW 1
20257: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
20258: LD_ADDR_EXP 91
20262: PUSH
20263: LD_EXP 91
20267: PPUSH
20268: LD_VAR 0 2
20272: PPUSH
20273: EMPTY
20274: PPUSH
20275: CALL_OW 1
20279: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
20280: LD_ADDR_EXP 92
20284: PUSH
20285: LD_EXP 92
20289: PPUSH
20290: LD_VAR 0 2
20294: PPUSH
20295: LD_INT 0
20297: PPUSH
20298: CALL_OW 1
20302: ST_TO_ADDR
// end ;
20303: GO 19227
20305: POP
20306: POP
// MC_InitSides ( ) ;
20307: CALL 20593 0 0
// MC_InitResearch ( ) ;
20311: CALL 20332 0 0
// CustomInitMacro ( ) ;
20315: CALL 300 0 0
// skirmish := true ;
20319: LD_ADDR_EXP 48
20323: PUSH
20324: LD_INT 1
20326: ST_TO_ADDR
// end ;
20327: LD_VAR 0 1
20331: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
20332: LD_INT 0
20334: PPUSH
20335: PPUSH
20336: PPUSH
20337: PPUSH
20338: PPUSH
20339: PPUSH
// if not mc_bases then
20340: LD_EXP 50
20344: NOT
20345: IFFALSE 20349
// exit ;
20347: GO 20588
// for i = 1 to 8 do
20349: LD_ADDR_VAR 0 2
20353: PUSH
20354: DOUBLE
20355: LD_INT 1
20357: DEC
20358: ST_TO_ADDR
20359: LD_INT 8
20361: PUSH
20362: FOR_TO
20363: IFFALSE 20389
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
20365: LD_ADDR_EXP 77
20369: PUSH
20370: LD_EXP 77
20374: PPUSH
20375: LD_VAR 0 2
20379: PPUSH
20380: EMPTY
20381: PPUSH
20382: CALL_OW 1
20386: ST_TO_ADDR
20387: GO 20362
20389: POP
20390: POP
// tmp := [ ] ;
20391: LD_ADDR_VAR 0 5
20395: PUSH
20396: EMPTY
20397: ST_TO_ADDR
// for i = 1 to mc_sides do
20398: LD_ADDR_VAR 0 2
20402: PUSH
20403: DOUBLE
20404: LD_INT 1
20406: DEC
20407: ST_TO_ADDR
20408: LD_EXP 76
20412: PUSH
20413: FOR_TO
20414: IFFALSE 20472
// if not mc_sides [ i ] in tmp then
20416: LD_EXP 76
20420: PUSH
20421: LD_VAR 0 2
20425: ARRAY
20426: PUSH
20427: LD_VAR 0 5
20431: IN
20432: NOT
20433: IFFALSE 20470
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
20435: LD_ADDR_VAR 0 5
20439: PUSH
20440: LD_VAR 0 5
20444: PPUSH
20445: LD_VAR 0 5
20449: PUSH
20450: LD_INT 1
20452: PLUS
20453: PPUSH
20454: LD_EXP 76
20458: PUSH
20459: LD_VAR 0 2
20463: ARRAY
20464: PPUSH
20465: CALL_OW 2
20469: ST_TO_ADDR
20470: GO 20413
20472: POP
20473: POP
// if not tmp then
20474: LD_VAR 0 5
20478: NOT
20479: IFFALSE 20483
// exit ;
20481: GO 20588
// for j in tmp do
20483: LD_ADDR_VAR 0 3
20487: PUSH
20488: LD_VAR 0 5
20492: PUSH
20493: FOR_IN
20494: IFFALSE 20586
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
20496: LD_ADDR_VAR 0 6
20500: PUSH
20501: LD_INT 22
20503: PUSH
20504: LD_VAR 0 3
20508: PUSH
20509: EMPTY
20510: LIST
20511: LIST
20512: PPUSH
20513: CALL_OW 69
20517: ST_TO_ADDR
// if not un then
20518: LD_VAR 0 6
20522: NOT
20523: IFFALSE 20527
// continue ;
20525: GO 20493
// nation := GetNation ( un [ 1 ] ) ;
20527: LD_ADDR_VAR 0 4
20531: PUSH
20532: LD_VAR 0 6
20536: PUSH
20537: LD_INT 1
20539: ARRAY
20540: PPUSH
20541: CALL_OW 248
20545: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
20546: LD_ADDR_EXP 77
20550: PUSH
20551: LD_EXP 77
20555: PPUSH
20556: LD_VAR 0 3
20560: PPUSH
20561: LD_VAR 0 3
20565: PPUSH
20566: LD_VAR 0 4
20570: PPUSH
20571: LD_INT 1
20573: PPUSH
20574: CALL 47302 0 3
20578: PPUSH
20579: CALL_OW 1
20583: ST_TO_ADDR
// end ;
20584: GO 20493
20586: POP
20587: POP
// end ;
20588: LD_VAR 0 1
20592: RET
// export function MC_InitSides ( ) ; var i ; begin
20593: LD_INT 0
20595: PPUSH
20596: PPUSH
// if not mc_bases then
20597: LD_EXP 50
20601: NOT
20602: IFFALSE 20606
// exit ;
20604: GO 20680
// for i = 1 to mc_bases do
20606: LD_ADDR_VAR 0 2
20610: PUSH
20611: DOUBLE
20612: LD_INT 1
20614: DEC
20615: ST_TO_ADDR
20616: LD_EXP 50
20620: PUSH
20621: FOR_TO
20622: IFFALSE 20678
// if mc_bases [ i ] then
20624: LD_EXP 50
20628: PUSH
20629: LD_VAR 0 2
20633: ARRAY
20634: IFFALSE 20676
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
20636: LD_ADDR_EXP 76
20640: PUSH
20641: LD_EXP 76
20645: PPUSH
20646: LD_VAR 0 2
20650: PPUSH
20651: LD_EXP 50
20655: PUSH
20656: LD_VAR 0 2
20660: ARRAY
20661: PUSH
20662: LD_INT 1
20664: ARRAY
20665: PPUSH
20666: CALL_OW 255
20670: PPUSH
20671: CALL_OW 1
20675: ST_TO_ADDR
20676: GO 20621
20678: POP
20679: POP
// end ;
20680: LD_VAR 0 1
20684: RET
// every 0 0$01 trigger skirmish do
20685: LD_EXP 48
20689: IFFALSE 20843
20691: GO 20693
20693: DISABLE
// begin enable ;
20694: ENABLE
// MC_CheckBuildings ( ) ;
20695: CALL 25341 0 0
// MC_CheckPeopleLife ( ) ;
20699: CALL 25466 0 0
// RaiseSailEvent ( 100 ) ;
20703: LD_INT 100
20705: PPUSH
20706: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
20710: LD_INT 103
20712: PPUSH
20713: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
20717: LD_INT 104
20719: PPUSH
20720: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
20724: LD_INT 105
20726: PPUSH
20727: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
20731: LD_INT 106
20733: PPUSH
20734: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
20738: LD_INT 107
20740: PPUSH
20741: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
20745: LD_INT 108
20747: PPUSH
20748: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
20752: LD_INT 109
20754: PPUSH
20755: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
20759: LD_INT 110
20761: PPUSH
20762: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
20766: LD_INT 111
20768: PPUSH
20769: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
20773: LD_INT 112
20775: PPUSH
20776: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
20780: LD_INT 113
20782: PPUSH
20783: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
20787: LD_INT 120
20789: PPUSH
20790: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
20794: LD_INT 121
20796: PPUSH
20797: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
20801: LD_INT 122
20803: PPUSH
20804: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
20808: LD_INT 123
20810: PPUSH
20811: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
20815: LD_INT 124
20817: PPUSH
20818: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
20822: LD_INT 125
20824: PPUSH
20825: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
20829: LD_INT 126
20831: PPUSH
20832: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
20836: LD_INT 200
20838: PPUSH
20839: CALL_OW 427
// end ;
20843: END
// on SailEvent ( event ) do begin if event < 100 then
20844: LD_VAR 0 1
20848: PUSH
20849: LD_INT 100
20851: LESS
20852: IFFALSE 20863
// CustomEvent ( event ) ;
20854: LD_VAR 0 1
20858: PPUSH
20859: CALL 16362 0 1
// if event = 100 then
20863: LD_VAR 0 1
20867: PUSH
20868: LD_INT 100
20870: EQUAL
20871: IFFALSE 20877
// MC_ClassManager ( ) ;
20873: CALL 21269 0 0
// if event = 101 then
20877: LD_VAR 0 1
20881: PUSH
20882: LD_INT 101
20884: EQUAL
20885: IFFALSE 20891
// MC_RepairBuildings ( ) ;
20887: CALL 26062 0 0
// if event = 102 then
20891: LD_VAR 0 1
20895: PUSH
20896: LD_INT 102
20898: EQUAL
20899: IFFALSE 20905
// MC_Heal ( ) ;
20901: CALL 26794 0 0
// if event = 103 then
20905: LD_VAR 0 1
20909: PUSH
20910: LD_INT 103
20912: EQUAL
20913: IFFALSE 20919
// MC_Build ( ) ;
20915: CALL 27216 0 0
// if event = 104 then
20919: LD_VAR 0 1
20923: PUSH
20924: LD_INT 104
20926: EQUAL
20927: IFFALSE 20933
// MC_TurretWeapon ( ) ;
20929: CALL 28829 0 0
// if event = 105 then
20933: LD_VAR 0 1
20937: PUSH
20938: LD_INT 105
20940: EQUAL
20941: IFFALSE 20947
// MC_BuildUpgrade ( ) ;
20943: CALL 28380 0 0
// if event = 106 then
20947: LD_VAR 0 1
20951: PUSH
20952: LD_INT 106
20954: EQUAL
20955: IFFALSE 20961
// MC_PlantMines ( ) ;
20957: CALL 29259 0 0
// if event = 107 then
20961: LD_VAR 0 1
20965: PUSH
20966: LD_INT 107
20968: EQUAL
20969: IFFALSE 20975
// MC_CollectCrates ( ) ;
20971: CALL 30293 0 0
// if event = 108 then
20975: LD_VAR 0 1
20979: PUSH
20980: LD_INT 108
20982: EQUAL
20983: IFFALSE 20989
// MC_LinkRemoteControl ( ) ;
20985: CALL 32069 0 0
// if event = 109 then
20989: LD_VAR 0 1
20993: PUSH
20994: LD_INT 109
20996: EQUAL
20997: IFFALSE 21003
// MC_ProduceVehicle ( ) ;
20999: CALL 32250 0 0
// if event = 110 then
21003: LD_VAR 0 1
21007: PUSH
21008: LD_INT 110
21010: EQUAL
21011: IFFALSE 21017
// MC_SendAttack ( ) ;
21013: CALL 32716 0 0
// if event = 111 then
21017: LD_VAR 0 1
21021: PUSH
21022: LD_INT 111
21024: EQUAL
21025: IFFALSE 21031
// MC_Defend ( ) ;
21027: CALL 32824 0 0
// if event = 112 then
21031: LD_VAR 0 1
21035: PUSH
21036: LD_INT 112
21038: EQUAL
21039: IFFALSE 21045
// MC_Research ( ) ;
21041: CALL 33429 0 0
// if event = 113 then
21045: LD_VAR 0 1
21049: PUSH
21050: LD_INT 113
21052: EQUAL
21053: IFFALSE 21059
// MC_MinesTrigger ( ) ;
21055: CALL 34543 0 0
// if event = 120 then
21059: LD_VAR 0 1
21063: PUSH
21064: LD_INT 120
21066: EQUAL
21067: IFFALSE 21073
// MC_RepairVehicle ( ) ;
21069: CALL 34642 0 0
// if event = 121 then
21073: LD_VAR 0 1
21077: PUSH
21078: LD_INT 121
21080: EQUAL
21081: IFFALSE 21087
// MC_TameApe ( ) ;
21083: CALL 35372 0 0
// if event = 122 then
21087: LD_VAR 0 1
21091: PUSH
21092: LD_INT 122
21094: EQUAL
21095: IFFALSE 21101
// MC_ChangeApeClass ( ) ;
21097: CALL 36201 0 0
// if event = 123 then
21101: LD_VAR 0 1
21105: PUSH
21106: LD_INT 123
21108: EQUAL
21109: IFFALSE 21115
// MC_Bazooka ( ) ;
21111: CALL 36851 0 0
// if event = 124 then
21115: LD_VAR 0 1
21119: PUSH
21120: LD_INT 124
21122: EQUAL
21123: IFFALSE 21129
// MC_TeleportExit ( ) ;
21125: CALL 37049 0 0
// if event = 125 then
21129: LD_VAR 0 1
21133: PUSH
21134: LD_INT 125
21136: EQUAL
21137: IFFALSE 21143
// MC_Deposits ( ) ;
21139: CALL 37696 0 0
// if event = 126 then
21143: LD_VAR 0 1
21147: PUSH
21148: LD_INT 126
21150: EQUAL
21151: IFFALSE 21157
// MC_RemoteDriver ( ) ;
21153: CALL 38321 0 0
// if event = 200 then
21157: LD_VAR 0 1
21161: PUSH
21162: LD_INT 200
21164: EQUAL
21165: IFFALSE 21171
// MC_Idle ( ) ;
21167: CALL 40270 0 0
// end ;
21171: PPOPN 1
21173: END
// export function MC_Reset ( base , tag ) ; var i ; begin
21174: LD_INT 0
21176: PPUSH
21177: PPUSH
// if not mc_bases [ base ] or not tag then
21178: LD_EXP 50
21182: PUSH
21183: LD_VAR 0 1
21187: ARRAY
21188: NOT
21189: PUSH
21190: LD_VAR 0 2
21194: NOT
21195: OR
21196: IFFALSE 21200
// exit ;
21198: GO 21264
// for i in mc_bases [ base ] union mc_ape [ base ] do
21200: LD_ADDR_VAR 0 4
21204: PUSH
21205: LD_EXP 50
21209: PUSH
21210: LD_VAR 0 1
21214: ARRAY
21215: PUSH
21216: LD_EXP 79
21220: PUSH
21221: LD_VAR 0 1
21225: ARRAY
21226: UNION
21227: PUSH
21228: FOR_IN
21229: IFFALSE 21262
// if GetTag ( i ) = tag then
21231: LD_VAR 0 4
21235: PPUSH
21236: CALL_OW 110
21240: PUSH
21241: LD_VAR 0 2
21245: EQUAL
21246: IFFALSE 21260
// SetTag ( i , 0 ) ;
21248: LD_VAR 0 4
21252: PPUSH
21253: LD_INT 0
21255: PPUSH
21256: CALL_OW 109
21260: GO 21228
21262: POP
21263: POP
// end ;
21264: LD_VAR 0 3
21268: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
21269: LD_INT 0
21271: PPUSH
21272: PPUSH
21273: PPUSH
21274: PPUSH
21275: PPUSH
21276: PPUSH
21277: PPUSH
21278: PPUSH
// if not mc_bases then
21279: LD_EXP 50
21283: NOT
21284: IFFALSE 21288
// exit ;
21286: GO 21746
// for i = 1 to mc_bases do
21288: LD_ADDR_VAR 0 2
21292: PUSH
21293: DOUBLE
21294: LD_INT 1
21296: DEC
21297: ST_TO_ADDR
21298: LD_EXP 50
21302: PUSH
21303: FOR_TO
21304: IFFALSE 21744
// begin tmp := MC_ClassCheckReq ( i ) ;
21306: LD_ADDR_VAR 0 4
21310: PUSH
21311: LD_VAR 0 2
21315: PPUSH
21316: CALL 21751 0 1
21320: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
21321: LD_ADDR_EXP 91
21325: PUSH
21326: LD_EXP 91
21330: PPUSH
21331: LD_VAR 0 2
21335: PPUSH
21336: LD_VAR 0 4
21340: PPUSH
21341: CALL_OW 1
21345: ST_TO_ADDR
// if not tmp then
21346: LD_VAR 0 4
21350: NOT
21351: IFFALSE 21355
// continue ;
21353: GO 21303
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
21355: LD_ADDR_VAR 0 6
21359: PUSH
21360: LD_EXP 50
21364: PUSH
21365: LD_VAR 0 2
21369: ARRAY
21370: PPUSH
21371: LD_INT 2
21373: PUSH
21374: LD_INT 30
21376: PUSH
21377: LD_INT 4
21379: PUSH
21380: EMPTY
21381: LIST
21382: LIST
21383: PUSH
21384: LD_INT 30
21386: PUSH
21387: LD_INT 5
21389: PUSH
21390: EMPTY
21391: LIST
21392: LIST
21393: PUSH
21394: EMPTY
21395: LIST
21396: LIST
21397: LIST
21398: PPUSH
21399: CALL_OW 72
21403: PUSH
21404: LD_EXP 50
21408: PUSH
21409: LD_VAR 0 2
21413: ARRAY
21414: PPUSH
21415: LD_INT 2
21417: PUSH
21418: LD_INT 30
21420: PUSH
21421: LD_INT 0
21423: PUSH
21424: EMPTY
21425: LIST
21426: LIST
21427: PUSH
21428: LD_INT 30
21430: PUSH
21431: LD_INT 1
21433: PUSH
21434: EMPTY
21435: LIST
21436: LIST
21437: PUSH
21438: EMPTY
21439: LIST
21440: LIST
21441: LIST
21442: PPUSH
21443: CALL_OW 72
21447: PUSH
21448: LD_EXP 50
21452: PUSH
21453: LD_VAR 0 2
21457: ARRAY
21458: PPUSH
21459: LD_INT 30
21461: PUSH
21462: LD_INT 3
21464: PUSH
21465: EMPTY
21466: LIST
21467: LIST
21468: PPUSH
21469: CALL_OW 72
21473: PUSH
21474: LD_EXP 50
21478: PUSH
21479: LD_VAR 0 2
21483: ARRAY
21484: PPUSH
21485: LD_INT 2
21487: PUSH
21488: LD_INT 30
21490: PUSH
21491: LD_INT 6
21493: PUSH
21494: EMPTY
21495: LIST
21496: LIST
21497: PUSH
21498: LD_INT 30
21500: PUSH
21501: LD_INT 7
21503: PUSH
21504: EMPTY
21505: LIST
21506: LIST
21507: PUSH
21508: LD_INT 30
21510: PUSH
21511: LD_INT 8
21513: PUSH
21514: EMPTY
21515: LIST
21516: LIST
21517: PUSH
21518: EMPTY
21519: LIST
21520: LIST
21521: LIST
21522: LIST
21523: PPUSH
21524: CALL_OW 72
21528: PUSH
21529: EMPTY
21530: LIST
21531: LIST
21532: LIST
21533: LIST
21534: ST_TO_ADDR
// for j = 1 to 4 do
21535: LD_ADDR_VAR 0 3
21539: PUSH
21540: DOUBLE
21541: LD_INT 1
21543: DEC
21544: ST_TO_ADDR
21545: LD_INT 4
21547: PUSH
21548: FOR_TO
21549: IFFALSE 21740
// begin if not tmp [ j ] then
21551: LD_VAR 0 4
21555: PUSH
21556: LD_VAR 0 3
21560: ARRAY
21561: NOT
21562: IFFALSE 21566
// continue ;
21564: GO 21548
// for p in tmp [ j ] do
21566: LD_ADDR_VAR 0 5
21570: PUSH
21571: LD_VAR 0 4
21575: PUSH
21576: LD_VAR 0 3
21580: ARRAY
21581: PUSH
21582: FOR_IN
21583: IFFALSE 21736
// begin if not b [ j ] then
21585: LD_VAR 0 6
21589: PUSH
21590: LD_VAR 0 3
21594: ARRAY
21595: NOT
21596: IFFALSE 21600
// break ;
21598: GO 21736
// e := 0 ;
21600: LD_ADDR_VAR 0 7
21604: PUSH
21605: LD_INT 0
21607: ST_TO_ADDR
// for k in b [ j ] do
21608: LD_ADDR_VAR 0 8
21612: PUSH
21613: LD_VAR 0 6
21617: PUSH
21618: LD_VAR 0 3
21622: ARRAY
21623: PUSH
21624: FOR_IN
21625: IFFALSE 21652
// if IsNotFull ( k ) then
21627: LD_VAR 0 8
21631: PPUSH
21632: CALL 51653 0 1
21636: IFFALSE 21650
// begin e := k ;
21638: LD_ADDR_VAR 0 7
21642: PUSH
21643: LD_VAR 0 8
21647: ST_TO_ADDR
// break ;
21648: GO 21652
// end ;
21650: GO 21624
21652: POP
21653: POP
// if e and not UnitGoingToBuilding ( p , e ) then
21654: LD_VAR 0 7
21658: PUSH
21659: LD_VAR 0 5
21663: PPUSH
21664: LD_VAR 0 7
21668: PPUSH
21669: CALL 88772 0 2
21673: NOT
21674: AND
21675: IFFALSE 21734
// begin if IsInUnit ( p ) then
21677: LD_VAR 0 5
21681: PPUSH
21682: CALL_OW 310
21686: IFFALSE 21697
// ComExitBuilding ( p ) ;
21688: LD_VAR 0 5
21692: PPUSH
21693: CALL_OW 122
// ComEnterUnit ( p , e ) ;
21697: LD_VAR 0 5
21701: PPUSH
21702: LD_VAR 0 7
21706: PPUSH
21707: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
21711: LD_VAR 0 5
21715: PPUSH
21716: LD_VAR 0 3
21720: PPUSH
21721: CALL_OW 183
// AddComExitBuilding ( p ) ;
21725: LD_VAR 0 5
21729: PPUSH
21730: CALL_OW 182
// end ; end ;
21734: GO 21582
21736: POP
21737: POP
// end ;
21738: GO 21548
21740: POP
21741: POP
// end ;
21742: GO 21303
21744: POP
21745: POP
// end ;
21746: LD_VAR 0 1
21750: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
21751: LD_INT 0
21753: PPUSH
21754: PPUSH
21755: PPUSH
21756: PPUSH
21757: PPUSH
21758: PPUSH
21759: PPUSH
21760: PPUSH
21761: PPUSH
21762: PPUSH
21763: PPUSH
21764: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
21765: LD_VAR 0 1
21769: NOT
21770: PUSH
21771: LD_EXP 50
21775: PUSH
21776: LD_VAR 0 1
21780: ARRAY
21781: NOT
21782: OR
21783: PUSH
21784: LD_EXP 50
21788: PUSH
21789: LD_VAR 0 1
21793: ARRAY
21794: PPUSH
21795: LD_INT 2
21797: PUSH
21798: LD_INT 30
21800: PUSH
21801: LD_INT 0
21803: PUSH
21804: EMPTY
21805: LIST
21806: LIST
21807: PUSH
21808: LD_INT 30
21810: PUSH
21811: LD_INT 1
21813: PUSH
21814: EMPTY
21815: LIST
21816: LIST
21817: PUSH
21818: EMPTY
21819: LIST
21820: LIST
21821: LIST
21822: PPUSH
21823: CALL_OW 72
21827: NOT
21828: OR
21829: IFFALSE 21833
// exit ;
21831: GO 25336
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
21833: LD_ADDR_VAR 0 4
21837: PUSH
21838: LD_EXP 50
21842: PUSH
21843: LD_VAR 0 1
21847: ARRAY
21848: PPUSH
21849: LD_INT 2
21851: PUSH
21852: LD_INT 25
21854: PUSH
21855: LD_INT 1
21857: PUSH
21858: EMPTY
21859: LIST
21860: LIST
21861: PUSH
21862: LD_INT 25
21864: PUSH
21865: LD_INT 2
21867: PUSH
21868: EMPTY
21869: LIST
21870: LIST
21871: PUSH
21872: LD_INT 25
21874: PUSH
21875: LD_INT 3
21877: PUSH
21878: EMPTY
21879: LIST
21880: LIST
21881: PUSH
21882: LD_INT 25
21884: PUSH
21885: LD_INT 4
21887: PUSH
21888: EMPTY
21889: LIST
21890: LIST
21891: PUSH
21892: LD_INT 25
21894: PUSH
21895: LD_INT 5
21897: PUSH
21898: EMPTY
21899: LIST
21900: LIST
21901: PUSH
21902: LD_INT 25
21904: PUSH
21905: LD_INT 8
21907: PUSH
21908: EMPTY
21909: LIST
21910: LIST
21911: PUSH
21912: LD_INT 25
21914: PUSH
21915: LD_INT 9
21917: PUSH
21918: EMPTY
21919: LIST
21920: LIST
21921: PUSH
21922: EMPTY
21923: LIST
21924: LIST
21925: LIST
21926: LIST
21927: LIST
21928: LIST
21929: LIST
21930: LIST
21931: PPUSH
21932: CALL_OW 72
21936: ST_TO_ADDR
// if not tmp then
21937: LD_VAR 0 4
21941: NOT
21942: IFFALSE 21946
// exit ;
21944: GO 25336
// for i in tmp do
21946: LD_ADDR_VAR 0 3
21950: PUSH
21951: LD_VAR 0 4
21955: PUSH
21956: FOR_IN
21957: IFFALSE 21988
// if GetTag ( i ) then
21959: LD_VAR 0 3
21963: PPUSH
21964: CALL_OW 110
21968: IFFALSE 21986
// tmp := tmp diff i ;
21970: LD_ADDR_VAR 0 4
21974: PUSH
21975: LD_VAR 0 4
21979: PUSH
21980: LD_VAR 0 3
21984: DIFF
21985: ST_TO_ADDR
21986: GO 21956
21988: POP
21989: POP
// if not tmp then
21990: LD_VAR 0 4
21994: NOT
21995: IFFALSE 21999
// exit ;
21997: GO 25336
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
21999: LD_ADDR_VAR 0 5
22003: PUSH
22004: LD_EXP 50
22008: PUSH
22009: LD_VAR 0 1
22013: ARRAY
22014: PPUSH
22015: LD_INT 2
22017: PUSH
22018: LD_INT 25
22020: PUSH
22021: LD_INT 1
22023: PUSH
22024: EMPTY
22025: LIST
22026: LIST
22027: PUSH
22028: LD_INT 25
22030: PUSH
22031: LD_INT 5
22033: PUSH
22034: EMPTY
22035: LIST
22036: LIST
22037: PUSH
22038: LD_INT 25
22040: PUSH
22041: LD_INT 8
22043: PUSH
22044: EMPTY
22045: LIST
22046: LIST
22047: PUSH
22048: LD_INT 25
22050: PUSH
22051: LD_INT 9
22053: PUSH
22054: EMPTY
22055: LIST
22056: LIST
22057: PUSH
22058: EMPTY
22059: LIST
22060: LIST
22061: LIST
22062: LIST
22063: LIST
22064: PPUSH
22065: CALL_OW 72
22069: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
22070: LD_ADDR_VAR 0 6
22074: PUSH
22075: LD_EXP 50
22079: PUSH
22080: LD_VAR 0 1
22084: ARRAY
22085: PPUSH
22086: LD_INT 25
22088: PUSH
22089: LD_INT 2
22091: PUSH
22092: EMPTY
22093: LIST
22094: LIST
22095: PPUSH
22096: CALL_OW 72
22100: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
22101: LD_ADDR_VAR 0 7
22105: PUSH
22106: LD_EXP 50
22110: PUSH
22111: LD_VAR 0 1
22115: ARRAY
22116: PPUSH
22117: LD_INT 25
22119: PUSH
22120: LD_INT 3
22122: PUSH
22123: EMPTY
22124: LIST
22125: LIST
22126: PPUSH
22127: CALL_OW 72
22131: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
22132: LD_ADDR_VAR 0 8
22136: PUSH
22137: LD_EXP 50
22141: PUSH
22142: LD_VAR 0 1
22146: ARRAY
22147: PPUSH
22148: LD_INT 25
22150: PUSH
22151: LD_INT 4
22153: PUSH
22154: EMPTY
22155: LIST
22156: LIST
22157: PUSH
22158: LD_INT 24
22160: PUSH
22161: LD_INT 251
22163: PUSH
22164: EMPTY
22165: LIST
22166: LIST
22167: PUSH
22168: EMPTY
22169: LIST
22170: LIST
22171: PPUSH
22172: CALL_OW 72
22176: ST_TO_ADDR
// if mc_scan [ base ] then
22177: LD_EXP 73
22181: PUSH
22182: LD_VAR 0 1
22186: ARRAY
22187: IFFALSE 22648
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
22189: LD_ADDR_EXP 92
22193: PUSH
22194: LD_EXP 92
22198: PPUSH
22199: LD_VAR 0 1
22203: PPUSH
22204: LD_INT 4
22206: PPUSH
22207: CALL_OW 1
22211: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
22212: LD_ADDR_VAR 0 12
22216: PUSH
22217: LD_EXP 50
22221: PUSH
22222: LD_VAR 0 1
22226: ARRAY
22227: PPUSH
22228: LD_INT 2
22230: PUSH
22231: LD_INT 30
22233: PUSH
22234: LD_INT 4
22236: PUSH
22237: EMPTY
22238: LIST
22239: LIST
22240: PUSH
22241: LD_INT 30
22243: PUSH
22244: LD_INT 5
22246: PUSH
22247: EMPTY
22248: LIST
22249: LIST
22250: PUSH
22251: EMPTY
22252: LIST
22253: LIST
22254: LIST
22255: PPUSH
22256: CALL_OW 72
22260: ST_TO_ADDR
// if not b then
22261: LD_VAR 0 12
22265: NOT
22266: IFFALSE 22270
// exit ;
22268: GO 25336
// p := [ ] ;
22270: LD_ADDR_VAR 0 11
22274: PUSH
22275: EMPTY
22276: ST_TO_ADDR
// if sci >= 2 then
22277: LD_VAR 0 8
22281: PUSH
22282: LD_INT 2
22284: GREATEREQUAL
22285: IFFALSE 22316
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
22287: LD_ADDR_VAR 0 8
22291: PUSH
22292: LD_VAR 0 8
22296: PUSH
22297: LD_INT 1
22299: ARRAY
22300: PUSH
22301: LD_VAR 0 8
22305: PUSH
22306: LD_INT 2
22308: ARRAY
22309: PUSH
22310: EMPTY
22311: LIST
22312: LIST
22313: ST_TO_ADDR
22314: GO 22377
// if sci = 1 then
22316: LD_VAR 0 8
22320: PUSH
22321: LD_INT 1
22323: EQUAL
22324: IFFALSE 22345
// sci := [ sci [ 1 ] ] else
22326: LD_ADDR_VAR 0 8
22330: PUSH
22331: LD_VAR 0 8
22335: PUSH
22336: LD_INT 1
22338: ARRAY
22339: PUSH
22340: EMPTY
22341: LIST
22342: ST_TO_ADDR
22343: GO 22377
// if sci = 0 then
22345: LD_VAR 0 8
22349: PUSH
22350: LD_INT 0
22352: EQUAL
22353: IFFALSE 22377
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
22355: LD_ADDR_VAR 0 11
22359: PUSH
22360: LD_VAR 0 4
22364: PPUSH
22365: LD_INT 4
22367: PPUSH
22368: CALL 88635 0 2
22372: PUSH
22373: LD_INT 1
22375: ARRAY
22376: ST_TO_ADDR
// if eng > 4 then
22377: LD_VAR 0 6
22381: PUSH
22382: LD_INT 4
22384: GREATER
22385: IFFALSE 22431
// for i = eng downto 4 do
22387: LD_ADDR_VAR 0 3
22391: PUSH
22392: DOUBLE
22393: LD_VAR 0 6
22397: INC
22398: ST_TO_ADDR
22399: LD_INT 4
22401: PUSH
22402: FOR_DOWNTO
22403: IFFALSE 22429
// eng := eng diff eng [ i ] ;
22405: LD_ADDR_VAR 0 6
22409: PUSH
22410: LD_VAR 0 6
22414: PUSH
22415: LD_VAR 0 6
22419: PUSH
22420: LD_VAR 0 3
22424: ARRAY
22425: DIFF
22426: ST_TO_ADDR
22427: GO 22402
22429: POP
22430: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
22431: LD_ADDR_VAR 0 4
22435: PUSH
22436: LD_VAR 0 4
22440: PUSH
22441: LD_VAR 0 5
22445: PUSH
22446: LD_VAR 0 6
22450: UNION
22451: PUSH
22452: LD_VAR 0 7
22456: UNION
22457: PUSH
22458: LD_VAR 0 8
22462: UNION
22463: DIFF
22464: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
22465: LD_ADDR_VAR 0 13
22469: PUSH
22470: LD_EXP 50
22474: PUSH
22475: LD_VAR 0 1
22479: ARRAY
22480: PPUSH
22481: LD_INT 2
22483: PUSH
22484: LD_INT 30
22486: PUSH
22487: LD_INT 32
22489: PUSH
22490: EMPTY
22491: LIST
22492: LIST
22493: PUSH
22494: LD_INT 30
22496: PUSH
22497: LD_INT 31
22499: PUSH
22500: EMPTY
22501: LIST
22502: LIST
22503: PUSH
22504: EMPTY
22505: LIST
22506: LIST
22507: LIST
22508: PPUSH
22509: CALL_OW 72
22513: PUSH
22514: LD_EXP 50
22518: PUSH
22519: LD_VAR 0 1
22523: ARRAY
22524: PPUSH
22525: LD_INT 2
22527: PUSH
22528: LD_INT 30
22530: PUSH
22531: LD_INT 4
22533: PUSH
22534: EMPTY
22535: LIST
22536: LIST
22537: PUSH
22538: LD_INT 30
22540: PUSH
22541: LD_INT 5
22543: PUSH
22544: EMPTY
22545: LIST
22546: LIST
22547: PUSH
22548: EMPTY
22549: LIST
22550: LIST
22551: LIST
22552: PPUSH
22553: CALL_OW 72
22557: PUSH
22558: LD_INT 6
22560: MUL
22561: PLUS
22562: ST_TO_ADDR
// if bcount < tmp then
22563: LD_VAR 0 13
22567: PUSH
22568: LD_VAR 0 4
22572: LESS
22573: IFFALSE 22619
// for i = tmp downto bcount do
22575: LD_ADDR_VAR 0 3
22579: PUSH
22580: DOUBLE
22581: LD_VAR 0 4
22585: INC
22586: ST_TO_ADDR
22587: LD_VAR 0 13
22591: PUSH
22592: FOR_DOWNTO
22593: IFFALSE 22617
// tmp := Delete ( tmp , tmp ) ;
22595: LD_ADDR_VAR 0 4
22599: PUSH
22600: LD_VAR 0 4
22604: PPUSH
22605: LD_VAR 0 4
22609: PPUSH
22610: CALL_OW 3
22614: ST_TO_ADDR
22615: GO 22592
22617: POP
22618: POP
// result := [ tmp , 0 , 0 , p ] ;
22619: LD_ADDR_VAR 0 2
22623: PUSH
22624: LD_VAR 0 4
22628: PUSH
22629: LD_INT 0
22631: PUSH
22632: LD_INT 0
22634: PUSH
22635: LD_VAR 0 11
22639: PUSH
22640: EMPTY
22641: LIST
22642: LIST
22643: LIST
22644: LIST
22645: ST_TO_ADDR
// exit ;
22646: GO 25336
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
22648: LD_EXP 50
22652: PUSH
22653: LD_VAR 0 1
22657: ARRAY
22658: PPUSH
22659: LD_INT 2
22661: PUSH
22662: LD_INT 30
22664: PUSH
22665: LD_INT 6
22667: PUSH
22668: EMPTY
22669: LIST
22670: LIST
22671: PUSH
22672: LD_INT 30
22674: PUSH
22675: LD_INT 7
22677: PUSH
22678: EMPTY
22679: LIST
22680: LIST
22681: PUSH
22682: LD_INT 30
22684: PUSH
22685: LD_INT 8
22687: PUSH
22688: EMPTY
22689: LIST
22690: LIST
22691: PUSH
22692: EMPTY
22693: LIST
22694: LIST
22695: LIST
22696: LIST
22697: PPUSH
22698: CALL_OW 72
22702: NOT
22703: PUSH
22704: LD_EXP 50
22708: PUSH
22709: LD_VAR 0 1
22713: ARRAY
22714: PPUSH
22715: LD_INT 30
22717: PUSH
22718: LD_INT 3
22720: PUSH
22721: EMPTY
22722: LIST
22723: LIST
22724: PPUSH
22725: CALL_OW 72
22729: NOT
22730: AND
22731: IFFALSE 22803
// begin if eng = tmp then
22733: LD_VAR 0 6
22737: PUSH
22738: LD_VAR 0 4
22742: EQUAL
22743: IFFALSE 22747
// exit ;
22745: GO 25336
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
22747: LD_ADDR_EXP 92
22751: PUSH
22752: LD_EXP 92
22756: PPUSH
22757: LD_VAR 0 1
22761: PPUSH
22762: LD_INT 1
22764: PPUSH
22765: CALL_OW 1
22769: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
22770: LD_ADDR_VAR 0 2
22774: PUSH
22775: LD_INT 0
22777: PUSH
22778: LD_VAR 0 4
22782: PUSH
22783: LD_VAR 0 6
22787: DIFF
22788: PUSH
22789: LD_INT 0
22791: PUSH
22792: LD_INT 0
22794: PUSH
22795: EMPTY
22796: LIST
22797: LIST
22798: LIST
22799: LIST
22800: ST_TO_ADDR
// exit ;
22801: GO 25336
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
22803: LD_EXP 77
22807: PUSH
22808: LD_EXP 76
22812: PUSH
22813: LD_VAR 0 1
22817: ARRAY
22818: ARRAY
22819: PUSH
22820: LD_EXP 50
22824: PUSH
22825: LD_VAR 0 1
22829: ARRAY
22830: PPUSH
22831: LD_INT 2
22833: PUSH
22834: LD_INT 30
22836: PUSH
22837: LD_INT 6
22839: PUSH
22840: EMPTY
22841: LIST
22842: LIST
22843: PUSH
22844: LD_INT 30
22846: PUSH
22847: LD_INT 7
22849: PUSH
22850: EMPTY
22851: LIST
22852: LIST
22853: PUSH
22854: LD_INT 30
22856: PUSH
22857: LD_INT 8
22859: PUSH
22860: EMPTY
22861: LIST
22862: LIST
22863: PUSH
22864: EMPTY
22865: LIST
22866: LIST
22867: LIST
22868: LIST
22869: PPUSH
22870: CALL_OW 72
22874: AND
22875: PUSH
22876: LD_EXP 50
22880: PUSH
22881: LD_VAR 0 1
22885: ARRAY
22886: PPUSH
22887: LD_INT 30
22889: PUSH
22890: LD_INT 3
22892: PUSH
22893: EMPTY
22894: LIST
22895: LIST
22896: PPUSH
22897: CALL_OW 72
22901: NOT
22902: AND
22903: IFFALSE 23117
// begin if sci >= 6 then
22905: LD_VAR 0 8
22909: PUSH
22910: LD_INT 6
22912: GREATEREQUAL
22913: IFFALSE 22917
// exit ;
22915: GO 25336
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
22917: LD_ADDR_EXP 92
22921: PUSH
22922: LD_EXP 92
22926: PPUSH
22927: LD_VAR 0 1
22931: PPUSH
22932: LD_INT 2
22934: PPUSH
22935: CALL_OW 1
22939: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
22940: LD_ADDR_VAR 0 9
22944: PUSH
22945: LD_VAR 0 4
22949: PUSH
22950: LD_VAR 0 8
22954: DIFF
22955: PPUSH
22956: LD_INT 4
22958: PPUSH
22959: CALL 88635 0 2
22963: ST_TO_ADDR
// p := [ ] ;
22964: LD_ADDR_VAR 0 11
22968: PUSH
22969: EMPTY
22970: ST_TO_ADDR
// if sci < 6 and sort > 6 then
22971: LD_VAR 0 8
22975: PUSH
22976: LD_INT 6
22978: LESS
22979: PUSH
22980: LD_VAR 0 9
22984: PUSH
22985: LD_INT 6
22987: GREATER
22988: AND
22989: IFFALSE 23070
// begin for i = 1 to 6 - sci do
22991: LD_ADDR_VAR 0 3
22995: PUSH
22996: DOUBLE
22997: LD_INT 1
22999: DEC
23000: ST_TO_ADDR
23001: LD_INT 6
23003: PUSH
23004: LD_VAR 0 8
23008: MINUS
23009: PUSH
23010: FOR_TO
23011: IFFALSE 23066
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
23013: LD_ADDR_VAR 0 11
23017: PUSH
23018: LD_VAR 0 11
23022: PPUSH
23023: LD_VAR 0 11
23027: PUSH
23028: LD_INT 1
23030: PLUS
23031: PPUSH
23032: LD_VAR 0 9
23036: PUSH
23037: LD_INT 1
23039: ARRAY
23040: PPUSH
23041: CALL_OW 2
23045: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
23046: LD_ADDR_VAR 0 9
23050: PUSH
23051: LD_VAR 0 9
23055: PPUSH
23056: LD_INT 1
23058: PPUSH
23059: CALL_OW 3
23063: ST_TO_ADDR
// end ;
23064: GO 23010
23066: POP
23067: POP
// end else
23068: GO 23090
// if sort then
23070: LD_VAR 0 9
23074: IFFALSE 23090
// p := sort [ 1 ] ;
23076: LD_ADDR_VAR 0 11
23080: PUSH
23081: LD_VAR 0 9
23085: PUSH
23086: LD_INT 1
23088: ARRAY
23089: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
23090: LD_ADDR_VAR 0 2
23094: PUSH
23095: LD_INT 0
23097: PUSH
23098: LD_INT 0
23100: PUSH
23101: LD_INT 0
23103: PUSH
23104: LD_VAR 0 11
23108: PUSH
23109: EMPTY
23110: LIST
23111: LIST
23112: LIST
23113: LIST
23114: ST_TO_ADDR
// exit ;
23115: GO 25336
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
23117: LD_EXP 77
23121: PUSH
23122: LD_EXP 76
23126: PUSH
23127: LD_VAR 0 1
23131: ARRAY
23132: ARRAY
23133: PUSH
23134: LD_EXP 50
23138: PUSH
23139: LD_VAR 0 1
23143: ARRAY
23144: PPUSH
23145: LD_INT 2
23147: PUSH
23148: LD_INT 30
23150: PUSH
23151: LD_INT 6
23153: PUSH
23154: EMPTY
23155: LIST
23156: LIST
23157: PUSH
23158: LD_INT 30
23160: PUSH
23161: LD_INT 7
23163: PUSH
23164: EMPTY
23165: LIST
23166: LIST
23167: PUSH
23168: LD_INT 30
23170: PUSH
23171: LD_INT 8
23173: PUSH
23174: EMPTY
23175: LIST
23176: LIST
23177: PUSH
23178: EMPTY
23179: LIST
23180: LIST
23181: LIST
23182: LIST
23183: PPUSH
23184: CALL_OW 72
23188: AND
23189: PUSH
23190: LD_EXP 50
23194: PUSH
23195: LD_VAR 0 1
23199: ARRAY
23200: PPUSH
23201: LD_INT 30
23203: PUSH
23204: LD_INT 3
23206: PUSH
23207: EMPTY
23208: LIST
23209: LIST
23210: PPUSH
23211: CALL_OW 72
23215: AND
23216: IFFALSE 23950
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
23218: LD_ADDR_EXP 92
23222: PUSH
23223: LD_EXP 92
23227: PPUSH
23228: LD_VAR 0 1
23232: PPUSH
23233: LD_INT 3
23235: PPUSH
23236: CALL_OW 1
23240: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
23241: LD_ADDR_VAR 0 2
23245: PUSH
23246: LD_INT 0
23248: PUSH
23249: LD_INT 0
23251: PUSH
23252: LD_INT 0
23254: PUSH
23255: LD_INT 0
23257: PUSH
23258: EMPTY
23259: LIST
23260: LIST
23261: LIST
23262: LIST
23263: ST_TO_ADDR
// if not eng then
23264: LD_VAR 0 6
23268: NOT
23269: IFFALSE 23332
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
23271: LD_ADDR_VAR 0 11
23275: PUSH
23276: LD_VAR 0 4
23280: PPUSH
23281: LD_INT 2
23283: PPUSH
23284: CALL 88635 0 2
23288: PUSH
23289: LD_INT 1
23291: ARRAY
23292: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
23293: LD_ADDR_VAR 0 2
23297: PUSH
23298: LD_VAR 0 2
23302: PPUSH
23303: LD_INT 2
23305: PPUSH
23306: LD_VAR 0 11
23310: PPUSH
23311: CALL_OW 1
23315: ST_TO_ADDR
// tmp := tmp diff p ;
23316: LD_ADDR_VAR 0 4
23320: PUSH
23321: LD_VAR 0 4
23325: PUSH
23326: LD_VAR 0 11
23330: DIFF
23331: ST_TO_ADDR
// end ; if tmp and sci < 6 then
23332: LD_VAR 0 4
23336: PUSH
23337: LD_VAR 0 8
23341: PUSH
23342: LD_INT 6
23344: LESS
23345: AND
23346: IFFALSE 23534
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
23348: LD_ADDR_VAR 0 9
23352: PUSH
23353: LD_VAR 0 4
23357: PUSH
23358: LD_VAR 0 8
23362: PUSH
23363: LD_VAR 0 7
23367: UNION
23368: DIFF
23369: PPUSH
23370: LD_INT 4
23372: PPUSH
23373: CALL 88635 0 2
23377: ST_TO_ADDR
// p := [ ] ;
23378: LD_ADDR_VAR 0 11
23382: PUSH
23383: EMPTY
23384: ST_TO_ADDR
// if sort then
23385: LD_VAR 0 9
23389: IFFALSE 23505
// for i = 1 to 6 - sci do
23391: LD_ADDR_VAR 0 3
23395: PUSH
23396: DOUBLE
23397: LD_INT 1
23399: DEC
23400: ST_TO_ADDR
23401: LD_INT 6
23403: PUSH
23404: LD_VAR 0 8
23408: MINUS
23409: PUSH
23410: FOR_TO
23411: IFFALSE 23503
// begin if i = sort then
23413: LD_VAR 0 3
23417: PUSH
23418: LD_VAR 0 9
23422: EQUAL
23423: IFFALSE 23427
// break ;
23425: GO 23503
// if GetClass ( i ) = 4 then
23427: LD_VAR 0 3
23431: PPUSH
23432: CALL_OW 257
23436: PUSH
23437: LD_INT 4
23439: EQUAL
23440: IFFALSE 23444
// continue ;
23442: GO 23410
// p := Insert ( p , p + 1 , sort [ i ] ) ;
23444: LD_ADDR_VAR 0 11
23448: PUSH
23449: LD_VAR 0 11
23453: PPUSH
23454: LD_VAR 0 11
23458: PUSH
23459: LD_INT 1
23461: PLUS
23462: PPUSH
23463: LD_VAR 0 9
23467: PUSH
23468: LD_VAR 0 3
23472: ARRAY
23473: PPUSH
23474: CALL_OW 2
23478: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
23479: LD_ADDR_VAR 0 4
23483: PUSH
23484: LD_VAR 0 4
23488: PUSH
23489: LD_VAR 0 9
23493: PUSH
23494: LD_VAR 0 3
23498: ARRAY
23499: DIFF
23500: ST_TO_ADDR
// end ;
23501: GO 23410
23503: POP
23504: POP
// if p then
23505: LD_VAR 0 11
23509: IFFALSE 23534
// result := Replace ( result , 4 , p ) ;
23511: LD_ADDR_VAR 0 2
23515: PUSH
23516: LD_VAR 0 2
23520: PPUSH
23521: LD_INT 4
23523: PPUSH
23524: LD_VAR 0 11
23528: PPUSH
23529: CALL_OW 1
23533: ST_TO_ADDR
// end ; if tmp and mech < 6 then
23534: LD_VAR 0 4
23538: PUSH
23539: LD_VAR 0 7
23543: PUSH
23544: LD_INT 6
23546: LESS
23547: AND
23548: IFFALSE 23736
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
23550: LD_ADDR_VAR 0 9
23554: PUSH
23555: LD_VAR 0 4
23559: PUSH
23560: LD_VAR 0 8
23564: PUSH
23565: LD_VAR 0 7
23569: UNION
23570: DIFF
23571: PPUSH
23572: LD_INT 3
23574: PPUSH
23575: CALL 88635 0 2
23579: ST_TO_ADDR
// p := [ ] ;
23580: LD_ADDR_VAR 0 11
23584: PUSH
23585: EMPTY
23586: ST_TO_ADDR
// if sort then
23587: LD_VAR 0 9
23591: IFFALSE 23707
// for i = 1 to 6 - mech do
23593: LD_ADDR_VAR 0 3
23597: PUSH
23598: DOUBLE
23599: LD_INT 1
23601: DEC
23602: ST_TO_ADDR
23603: LD_INT 6
23605: PUSH
23606: LD_VAR 0 7
23610: MINUS
23611: PUSH
23612: FOR_TO
23613: IFFALSE 23705
// begin if i = sort then
23615: LD_VAR 0 3
23619: PUSH
23620: LD_VAR 0 9
23624: EQUAL
23625: IFFALSE 23629
// break ;
23627: GO 23705
// if GetClass ( i ) = 3 then
23629: LD_VAR 0 3
23633: PPUSH
23634: CALL_OW 257
23638: PUSH
23639: LD_INT 3
23641: EQUAL
23642: IFFALSE 23646
// continue ;
23644: GO 23612
// p := Insert ( p , p + 1 , sort [ i ] ) ;
23646: LD_ADDR_VAR 0 11
23650: PUSH
23651: LD_VAR 0 11
23655: PPUSH
23656: LD_VAR 0 11
23660: PUSH
23661: LD_INT 1
23663: PLUS
23664: PPUSH
23665: LD_VAR 0 9
23669: PUSH
23670: LD_VAR 0 3
23674: ARRAY
23675: PPUSH
23676: CALL_OW 2
23680: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
23681: LD_ADDR_VAR 0 4
23685: PUSH
23686: LD_VAR 0 4
23690: PUSH
23691: LD_VAR 0 9
23695: PUSH
23696: LD_VAR 0 3
23700: ARRAY
23701: DIFF
23702: ST_TO_ADDR
// end ;
23703: GO 23612
23705: POP
23706: POP
// if p then
23707: LD_VAR 0 11
23711: IFFALSE 23736
// result := Replace ( result , 3 , p ) ;
23713: LD_ADDR_VAR 0 2
23717: PUSH
23718: LD_VAR 0 2
23722: PPUSH
23723: LD_INT 3
23725: PPUSH
23726: LD_VAR 0 11
23730: PPUSH
23731: CALL_OW 1
23735: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
23736: LD_VAR 0 4
23740: PUSH
23741: LD_INT 6
23743: GREATER
23744: PUSH
23745: LD_VAR 0 6
23749: PUSH
23750: LD_INT 6
23752: LESS
23753: AND
23754: IFFALSE 23948
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
23756: LD_ADDR_VAR 0 9
23760: PUSH
23761: LD_VAR 0 4
23765: PUSH
23766: LD_VAR 0 8
23770: PUSH
23771: LD_VAR 0 7
23775: UNION
23776: PUSH
23777: LD_VAR 0 6
23781: UNION
23782: DIFF
23783: PPUSH
23784: LD_INT 2
23786: PPUSH
23787: CALL 88635 0 2
23791: ST_TO_ADDR
// p := [ ] ;
23792: LD_ADDR_VAR 0 11
23796: PUSH
23797: EMPTY
23798: ST_TO_ADDR
// if sort then
23799: LD_VAR 0 9
23803: IFFALSE 23919
// for i = 1 to 6 - eng do
23805: LD_ADDR_VAR 0 3
23809: PUSH
23810: DOUBLE
23811: LD_INT 1
23813: DEC
23814: ST_TO_ADDR
23815: LD_INT 6
23817: PUSH
23818: LD_VAR 0 6
23822: MINUS
23823: PUSH
23824: FOR_TO
23825: IFFALSE 23917
// begin if i = sort then
23827: LD_VAR 0 3
23831: PUSH
23832: LD_VAR 0 9
23836: EQUAL
23837: IFFALSE 23841
// break ;
23839: GO 23917
// if GetClass ( i ) = 2 then
23841: LD_VAR 0 3
23845: PPUSH
23846: CALL_OW 257
23850: PUSH
23851: LD_INT 2
23853: EQUAL
23854: IFFALSE 23858
// continue ;
23856: GO 23824
// p := Insert ( p , p + 1 , sort [ i ] ) ;
23858: LD_ADDR_VAR 0 11
23862: PUSH
23863: LD_VAR 0 11
23867: PPUSH
23868: LD_VAR 0 11
23872: PUSH
23873: LD_INT 1
23875: PLUS
23876: PPUSH
23877: LD_VAR 0 9
23881: PUSH
23882: LD_VAR 0 3
23886: ARRAY
23887: PPUSH
23888: CALL_OW 2
23892: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
23893: LD_ADDR_VAR 0 4
23897: PUSH
23898: LD_VAR 0 4
23902: PUSH
23903: LD_VAR 0 9
23907: PUSH
23908: LD_VAR 0 3
23912: ARRAY
23913: DIFF
23914: ST_TO_ADDR
// end ;
23915: GO 23824
23917: POP
23918: POP
// if p then
23919: LD_VAR 0 11
23923: IFFALSE 23948
// result := Replace ( result , 2 , p ) ;
23925: LD_ADDR_VAR 0 2
23929: PUSH
23930: LD_VAR 0 2
23934: PPUSH
23935: LD_INT 2
23937: PPUSH
23938: LD_VAR 0 11
23942: PPUSH
23943: CALL_OW 1
23947: ST_TO_ADDR
// end ; exit ;
23948: GO 25336
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
23950: LD_EXP 77
23954: PUSH
23955: LD_EXP 76
23959: PUSH
23960: LD_VAR 0 1
23964: ARRAY
23965: ARRAY
23966: NOT
23967: PUSH
23968: LD_EXP 50
23972: PUSH
23973: LD_VAR 0 1
23977: ARRAY
23978: PPUSH
23979: LD_INT 30
23981: PUSH
23982: LD_INT 3
23984: PUSH
23985: EMPTY
23986: LIST
23987: LIST
23988: PPUSH
23989: CALL_OW 72
23993: AND
23994: PUSH
23995: LD_EXP 55
23999: PUSH
24000: LD_VAR 0 1
24004: ARRAY
24005: AND
24006: IFFALSE 24614
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
24008: LD_ADDR_EXP 92
24012: PUSH
24013: LD_EXP 92
24017: PPUSH
24018: LD_VAR 0 1
24022: PPUSH
24023: LD_INT 5
24025: PPUSH
24026: CALL_OW 1
24030: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
24031: LD_ADDR_VAR 0 2
24035: PUSH
24036: LD_INT 0
24038: PUSH
24039: LD_INT 0
24041: PUSH
24042: LD_INT 0
24044: PUSH
24045: LD_INT 0
24047: PUSH
24048: EMPTY
24049: LIST
24050: LIST
24051: LIST
24052: LIST
24053: ST_TO_ADDR
// if sci > 1 then
24054: LD_VAR 0 8
24058: PUSH
24059: LD_INT 1
24061: GREATER
24062: IFFALSE 24090
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
24064: LD_ADDR_VAR 0 4
24068: PUSH
24069: LD_VAR 0 4
24073: PUSH
24074: LD_VAR 0 8
24078: PUSH
24079: LD_VAR 0 8
24083: PUSH
24084: LD_INT 1
24086: ARRAY
24087: DIFF
24088: DIFF
24089: ST_TO_ADDR
// if tmp and not sci then
24090: LD_VAR 0 4
24094: PUSH
24095: LD_VAR 0 8
24099: NOT
24100: AND
24101: IFFALSE 24170
// begin sort := SortBySkill ( tmp , 4 ) ;
24103: LD_ADDR_VAR 0 9
24107: PUSH
24108: LD_VAR 0 4
24112: PPUSH
24113: LD_INT 4
24115: PPUSH
24116: CALL 88635 0 2
24120: ST_TO_ADDR
// if sort then
24121: LD_VAR 0 9
24125: IFFALSE 24141
// p := sort [ 1 ] ;
24127: LD_ADDR_VAR 0 11
24131: PUSH
24132: LD_VAR 0 9
24136: PUSH
24137: LD_INT 1
24139: ARRAY
24140: ST_TO_ADDR
// if p then
24141: LD_VAR 0 11
24145: IFFALSE 24170
// result := Replace ( result , 4 , p ) ;
24147: LD_ADDR_VAR 0 2
24151: PUSH
24152: LD_VAR 0 2
24156: PPUSH
24157: LD_INT 4
24159: PPUSH
24160: LD_VAR 0 11
24164: PPUSH
24165: CALL_OW 1
24169: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
24170: LD_ADDR_VAR 0 4
24174: PUSH
24175: LD_VAR 0 4
24179: PUSH
24180: LD_VAR 0 7
24184: DIFF
24185: ST_TO_ADDR
// if tmp and mech < 6 then
24186: LD_VAR 0 4
24190: PUSH
24191: LD_VAR 0 7
24195: PUSH
24196: LD_INT 6
24198: LESS
24199: AND
24200: IFFALSE 24388
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
24202: LD_ADDR_VAR 0 9
24206: PUSH
24207: LD_VAR 0 4
24211: PUSH
24212: LD_VAR 0 8
24216: PUSH
24217: LD_VAR 0 7
24221: UNION
24222: DIFF
24223: PPUSH
24224: LD_INT 3
24226: PPUSH
24227: CALL 88635 0 2
24231: ST_TO_ADDR
// p := [ ] ;
24232: LD_ADDR_VAR 0 11
24236: PUSH
24237: EMPTY
24238: ST_TO_ADDR
// if sort then
24239: LD_VAR 0 9
24243: IFFALSE 24359
// for i = 1 to 6 - mech do
24245: LD_ADDR_VAR 0 3
24249: PUSH
24250: DOUBLE
24251: LD_INT 1
24253: DEC
24254: ST_TO_ADDR
24255: LD_INT 6
24257: PUSH
24258: LD_VAR 0 7
24262: MINUS
24263: PUSH
24264: FOR_TO
24265: IFFALSE 24357
// begin if i = sort then
24267: LD_VAR 0 3
24271: PUSH
24272: LD_VAR 0 9
24276: EQUAL
24277: IFFALSE 24281
// break ;
24279: GO 24357
// if GetClass ( i ) = 3 then
24281: LD_VAR 0 3
24285: PPUSH
24286: CALL_OW 257
24290: PUSH
24291: LD_INT 3
24293: EQUAL
24294: IFFALSE 24298
// continue ;
24296: GO 24264
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24298: LD_ADDR_VAR 0 11
24302: PUSH
24303: LD_VAR 0 11
24307: PPUSH
24308: LD_VAR 0 11
24312: PUSH
24313: LD_INT 1
24315: PLUS
24316: PPUSH
24317: LD_VAR 0 9
24321: PUSH
24322: LD_VAR 0 3
24326: ARRAY
24327: PPUSH
24328: CALL_OW 2
24332: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24333: LD_ADDR_VAR 0 4
24337: PUSH
24338: LD_VAR 0 4
24342: PUSH
24343: LD_VAR 0 9
24347: PUSH
24348: LD_VAR 0 3
24352: ARRAY
24353: DIFF
24354: ST_TO_ADDR
// end ;
24355: GO 24264
24357: POP
24358: POP
// if p then
24359: LD_VAR 0 11
24363: IFFALSE 24388
// result := Replace ( result , 3 , p ) ;
24365: LD_ADDR_VAR 0 2
24369: PUSH
24370: LD_VAR 0 2
24374: PPUSH
24375: LD_INT 3
24377: PPUSH
24378: LD_VAR 0 11
24382: PPUSH
24383: CALL_OW 1
24387: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
24388: LD_ADDR_VAR 0 4
24392: PUSH
24393: LD_VAR 0 4
24397: PUSH
24398: LD_VAR 0 6
24402: DIFF
24403: ST_TO_ADDR
// if tmp and eng < 6 then
24404: LD_VAR 0 4
24408: PUSH
24409: LD_VAR 0 6
24413: PUSH
24414: LD_INT 6
24416: LESS
24417: AND
24418: IFFALSE 24612
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
24420: LD_ADDR_VAR 0 9
24424: PUSH
24425: LD_VAR 0 4
24429: PUSH
24430: LD_VAR 0 8
24434: PUSH
24435: LD_VAR 0 7
24439: UNION
24440: PUSH
24441: LD_VAR 0 6
24445: UNION
24446: DIFF
24447: PPUSH
24448: LD_INT 2
24450: PPUSH
24451: CALL 88635 0 2
24455: ST_TO_ADDR
// p := [ ] ;
24456: LD_ADDR_VAR 0 11
24460: PUSH
24461: EMPTY
24462: ST_TO_ADDR
// if sort then
24463: LD_VAR 0 9
24467: IFFALSE 24583
// for i = 1 to 6 - eng do
24469: LD_ADDR_VAR 0 3
24473: PUSH
24474: DOUBLE
24475: LD_INT 1
24477: DEC
24478: ST_TO_ADDR
24479: LD_INT 6
24481: PUSH
24482: LD_VAR 0 6
24486: MINUS
24487: PUSH
24488: FOR_TO
24489: IFFALSE 24581
// begin if i = sort then
24491: LD_VAR 0 3
24495: PUSH
24496: LD_VAR 0 9
24500: EQUAL
24501: IFFALSE 24505
// break ;
24503: GO 24581
// if GetClass ( i ) = 2 then
24505: LD_VAR 0 3
24509: PPUSH
24510: CALL_OW 257
24514: PUSH
24515: LD_INT 2
24517: EQUAL
24518: IFFALSE 24522
// continue ;
24520: GO 24488
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24522: LD_ADDR_VAR 0 11
24526: PUSH
24527: LD_VAR 0 11
24531: PPUSH
24532: LD_VAR 0 11
24536: PUSH
24537: LD_INT 1
24539: PLUS
24540: PPUSH
24541: LD_VAR 0 9
24545: PUSH
24546: LD_VAR 0 3
24550: ARRAY
24551: PPUSH
24552: CALL_OW 2
24556: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24557: LD_ADDR_VAR 0 4
24561: PUSH
24562: LD_VAR 0 4
24566: PUSH
24567: LD_VAR 0 9
24571: PUSH
24572: LD_VAR 0 3
24576: ARRAY
24577: DIFF
24578: ST_TO_ADDR
// end ;
24579: GO 24488
24581: POP
24582: POP
// if p then
24583: LD_VAR 0 11
24587: IFFALSE 24612
// result := Replace ( result , 2 , p ) ;
24589: LD_ADDR_VAR 0 2
24593: PUSH
24594: LD_VAR 0 2
24598: PPUSH
24599: LD_INT 2
24601: PPUSH
24602: LD_VAR 0 11
24606: PPUSH
24607: CALL_OW 1
24611: ST_TO_ADDR
// end ; exit ;
24612: GO 25336
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
24614: LD_EXP 77
24618: PUSH
24619: LD_EXP 76
24623: PUSH
24624: LD_VAR 0 1
24628: ARRAY
24629: ARRAY
24630: NOT
24631: PUSH
24632: LD_EXP 50
24636: PUSH
24637: LD_VAR 0 1
24641: ARRAY
24642: PPUSH
24643: LD_INT 30
24645: PUSH
24646: LD_INT 3
24648: PUSH
24649: EMPTY
24650: LIST
24651: LIST
24652: PPUSH
24653: CALL_OW 72
24657: AND
24658: PUSH
24659: LD_EXP 55
24663: PUSH
24664: LD_VAR 0 1
24668: ARRAY
24669: NOT
24670: AND
24671: IFFALSE 25336
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
24673: LD_ADDR_EXP 92
24677: PUSH
24678: LD_EXP 92
24682: PPUSH
24683: LD_VAR 0 1
24687: PPUSH
24688: LD_INT 6
24690: PPUSH
24691: CALL_OW 1
24695: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
24696: LD_ADDR_VAR 0 2
24700: PUSH
24701: LD_INT 0
24703: PUSH
24704: LD_INT 0
24706: PUSH
24707: LD_INT 0
24709: PUSH
24710: LD_INT 0
24712: PUSH
24713: EMPTY
24714: LIST
24715: LIST
24716: LIST
24717: LIST
24718: ST_TO_ADDR
// if sci >= 1 then
24719: LD_VAR 0 8
24723: PUSH
24724: LD_INT 1
24726: GREATEREQUAL
24727: IFFALSE 24749
// tmp := tmp diff sci [ 1 ] ;
24729: LD_ADDR_VAR 0 4
24733: PUSH
24734: LD_VAR 0 4
24738: PUSH
24739: LD_VAR 0 8
24743: PUSH
24744: LD_INT 1
24746: ARRAY
24747: DIFF
24748: ST_TO_ADDR
// if tmp and not sci then
24749: LD_VAR 0 4
24753: PUSH
24754: LD_VAR 0 8
24758: NOT
24759: AND
24760: IFFALSE 24829
// begin sort := SortBySkill ( tmp , 4 ) ;
24762: LD_ADDR_VAR 0 9
24766: PUSH
24767: LD_VAR 0 4
24771: PPUSH
24772: LD_INT 4
24774: PPUSH
24775: CALL 88635 0 2
24779: ST_TO_ADDR
// if sort then
24780: LD_VAR 0 9
24784: IFFALSE 24800
// p := sort [ 1 ] ;
24786: LD_ADDR_VAR 0 11
24790: PUSH
24791: LD_VAR 0 9
24795: PUSH
24796: LD_INT 1
24798: ARRAY
24799: ST_TO_ADDR
// if p then
24800: LD_VAR 0 11
24804: IFFALSE 24829
// result := Replace ( result , 4 , p ) ;
24806: LD_ADDR_VAR 0 2
24810: PUSH
24811: LD_VAR 0 2
24815: PPUSH
24816: LD_INT 4
24818: PPUSH
24819: LD_VAR 0 11
24823: PPUSH
24824: CALL_OW 1
24828: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
24829: LD_ADDR_VAR 0 4
24833: PUSH
24834: LD_VAR 0 4
24838: PUSH
24839: LD_VAR 0 7
24843: DIFF
24844: ST_TO_ADDR
// if tmp and mech < 6 then
24845: LD_VAR 0 4
24849: PUSH
24850: LD_VAR 0 7
24854: PUSH
24855: LD_INT 6
24857: LESS
24858: AND
24859: IFFALSE 25041
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
24861: LD_ADDR_VAR 0 9
24865: PUSH
24866: LD_VAR 0 4
24870: PUSH
24871: LD_VAR 0 7
24875: DIFF
24876: PPUSH
24877: LD_INT 3
24879: PPUSH
24880: CALL 88635 0 2
24884: ST_TO_ADDR
// p := [ ] ;
24885: LD_ADDR_VAR 0 11
24889: PUSH
24890: EMPTY
24891: ST_TO_ADDR
// if sort then
24892: LD_VAR 0 9
24896: IFFALSE 25012
// for i = 1 to 6 - mech do
24898: LD_ADDR_VAR 0 3
24902: PUSH
24903: DOUBLE
24904: LD_INT 1
24906: DEC
24907: ST_TO_ADDR
24908: LD_INT 6
24910: PUSH
24911: LD_VAR 0 7
24915: MINUS
24916: PUSH
24917: FOR_TO
24918: IFFALSE 25010
// begin if i = sort then
24920: LD_VAR 0 3
24924: PUSH
24925: LD_VAR 0 9
24929: EQUAL
24930: IFFALSE 24934
// break ;
24932: GO 25010
// if GetClass ( i ) = 3 then
24934: LD_VAR 0 3
24938: PPUSH
24939: CALL_OW 257
24943: PUSH
24944: LD_INT 3
24946: EQUAL
24947: IFFALSE 24951
// continue ;
24949: GO 24917
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24951: LD_ADDR_VAR 0 11
24955: PUSH
24956: LD_VAR 0 11
24960: PPUSH
24961: LD_VAR 0 11
24965: PUSH
24966: LD_INT 1
24968: PLUS
24969: PPUSH
24970: LD_VAR 0 9
24974: PUSH
24975: LD_VAR 0 3
24979: ARRAY
24980: PPUSH
24981: CALL_OW 2
24985: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24986: LD_ADDR_VAR 0 4
24990: PUSH
24991: LD_VAR 0 4
24995: PUSH
24996: LD_VAR 0 9
25000: PUSH
25001: LD_VAR 0 3
25005: ARRAY
25006: DIFF
25007: ST_TO_ADDR
// end ;
25008: GO 24917
25010: POP
25011: POP
// if p then
25012: LD_VAR 0 11
25016: IFFALSE 25041
// result := Replace ( result , 3 , p ) ;
25018: LD_ADDR_VAR 0 2
25022: PUSH
25023: LD_VAR 0 2
25027: PPUSH
25028: LD_INT 3
25030: PPUSH
25031: LD_VAR 0 11
25035: PPUSH
25036: CALL_OW 1
25040: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
25041: LD_ADDR_VAR 0 4
25045: PUSH
25046: LD_VAR 0 4
25050: PUSH
25051: LD_VAR 0 6
25055: DIFF
25056: ST_TO_ADDR
// if tmp and eng < 4 then
25057: LD_VAR 0 4
25061: PUSH
25062: LD_VAR 0 6
25066: PUSH
25067: LD_INT 4
25069: LESS
25070: AND
25071: IFFALSE 25261
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
25073: LD_ADDR_VAR 0 9
25077: PUSH
25078: LD_VAR 0 4
25082: PUSH
25083: LD_VAR 0 7
25087: PUSH
25088: LD_VAR 0 6
25092: UNION
25093: DIFF
25094: PPUSH
25095: LD_INT 2
25097: PPUSH
25098: CALL 88635 0 2
25102: ST_TO_ADDR
// p := [ ] ;
25103: LD_ADDR_VAR 0 11
25107: PUSH
25108: EMPTY
25109: ST_TO_ADDR
// if sort then
25110: LD_VAR 0 9
25114: IFFALSE 25230
// for i = 1 to 4 - eng do
25116: LD_ADDR_VAR 0 3
25120: PUSH
25121: DOUBLE
25122: LD_INT 1
25124: DEC
25125: ST_TO_ADDR
25126: LD_INT 4
25128: PUSH
25129: LD_VAR 0 6
25133: MINUS
25134: PUSH
25135: FOR_TO
25136: IFFALSE 25228
// begin if i = sort then
25138: LD_VAR 0 3
25142: PUSH
25143: LD_VAR 0 9
25147: EQUAL
25148: IFFALSE 25152
// break ;
25150: GO 25228
// if GetClass ( i ) = 2 then
25152: LD_VAR 0 3
25156: PPUSH
25157: CALL_OW 257
25161: PUSH
25162: LD_INT 2
25164: EQUAL
25165: IFFALSE 25169
// continue ;
25167: GO 25135
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25169: LD_ADDR_VAR 0 11
25173: PUSH
25174: LD_VAR 0 11
25178: PPUSH
25179: LD_VAR 0 11
25183: PUSH
25184: LD_INT 1
25186: PLUS
25187: PPUSH
25188: LD_VAR 0 9
25192: PUSH
25193: LD_VAR 0 3
25197: ARRAY
25198: PPUSH
25199: CALL_OW 2
25203: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25204: LD_ADDR_VAR 0 4
25208: PUSH
25209: LD_VAR 0 4
25213: PUSH
25214: LD_VAR 0 9
25218: PUSH
25219: LD_VAR 0 3
25223: ARRAY
25224: DIFF
25225: ST_TO_ADDR
// end ;
25226: GO 25135
25228: POP
25229: POP
// if p then
25230: LD_VAR 0 11
25234: IFFALSE 25259
// result := Replace ( result , 2 , p ) ;
25236: LD_ADDR_VAR 0 2
25240: PUSH
25241: LD_VAR 0 2
25245: PPUSH
25246: LD_INT 2
25248: PPUSH
25249: LD_VAR 0 11
25253: PPUSH
25254: CALL_OW 1
25258: ST_TO_ADDR
// end else
25259: GO 25305
// for i = eng downto 5 do
25261: LD_ADDR_VAR 0 3
25265: PUSH
25266: DOUBLE
25267: LD_VAR 0 6
25271: INC
25272: ST_TO_ADDR
25273: LD_INT 5
25275: PUSH
25276: FOR_DOWNTO
25277: IFFALSE 25303
// tmp := tmp union eng [ i ] ;
25279: LD_ADDR_VAR 0 4
25283: PUSH
25284: LD_VAR 0 4
25288: PUSH
25289: LD_VAR 0 6
25293: PUSH
25294: LD_VAR 0 3
25298: ARRAY
25299: UNION
25300: ST_TO_ADDR
25301: GO 25276
25303: POP
25304: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
25305: LD_ADDR_VAR 0 2
25309: PUSH
25310: LD_VAR 0 2
25314: PPUSH
25315: LD_INT 1
25317: PPUSH
25318: LD_VAR 0 4
25322: PUSH
25323: LD_VAR 0 5
25327: DIFF
25328: PPUSH
25329: CALL_OW 1
25333: ST_TO_ADDR
// exit ;
25334: GO 25336
// end ; end ;
25336: LD_VAR 0 2
25340: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
25341: LD_INT 0
25343: PPUSH
25344: PPUSH
25345: PPUSH
// if not mc_bases then
25346: LD_EXP 50
25350: NOT
25351: IFFALSE 25355
// exit ;
25353: GO 25461
// for i = 1 to mc_bases do
25355: LD_ADDR_VAR 0 2
25359: PUSH
25360: DOUBLE
25361: LD_INT 1
25363: DEC
25364: ST_TO_ADDR
25365: LD_EXP 50
25369: PUSH
25370: FOR_TO
25371: IFFALSE 25452
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
25373: LD_ADDR_VAR 0 3
25377: PUSH
25378: LD_EXP 50
25382: PUSH
25383: LD_VAR 0 2
25387: ARRAY
25388: PPUSH
25389: LD_INT 21
25391: PUSH
25392: LD_INT 3
25394: PUSH
25395: EMPTY
25396: LIST
25397: LIST
25398: PUSH
25399: LD_INT 3
25401: PUSH
25402: LD_INT 24
25404: PUSH
25405: LD_INT 1000
25407: PUSH
25408: EMPTY
25409: LIST
25410: LIST
25411: PUSH
25412: EMPTY
25413: LIST
25414: LIST
25415: PUSH
25416: EMPTY
25417: LIST
25418: LIST
25419: PPUSH
25420: CALL_OW 72
25424: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
25425: LD_ADDR_EXP 51
25429: PUSH
25430: LD_EXP 51
25434: PPUSH
25435: LD_VAR 0 2
25439: PPUSH
25440: LD_VAR 0 3
25444: PPUSH
25445: CALL_OW 1
25449: ST_TO_ADDR
// end ;
25450: GO 25370
25452: POP
25453: POP
// RaiseSailEvent ( 101 ) ;
25454: LD_INT 101
25456: PPUSH
25457: CALL_OW 427
// end ;
25461: LD_VAR 0 1
25465: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
25466: LD_INT 0
25468: PPUSH
25469: PPUSH
25470: PPUSH
25471: PPUSH
25472: PPUSH
25473: PPUSH
25474: PPUSH
// if not mc_bases then
25475: LD_EXP 50
25479: NOT
25480: IFFALSE 25484
// exit ;
25482: GO 26057
// for i = 1 to mc_bases do
25484: LD_ADDR_VAR 0 2
25488: PUSH
25489: DOUBLE
25490: LD_INT 1
25492: DEC
25493: ST_TO_ADDR
25494: LD_EXP 50
25498: PUSH
25499: FOR_TO
25500: IFFALSE 26048
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
25502: LD_ADDR_VAR 0 5
25506: PUSH
25507: LD_EXP 50
25511: PUSH
25512: LD_VAR 0 2
25516: ARRAY
25517: PUSH
25518: LD_EXP 79
25522: PUSH
25523: LD_VAR 0 2
25527: ARRAY
25528: UNION
25529: PPUSH
25530: LD_INT 21
25532: PUSH
25533: LD_INT 1
25535: PUSH
25536: EMPTY
25537: LIST
25538: LIST
25539: PUSH
25540: LD_INT 1
25542: PUSH
25543: LD_INT 3
25545: PUSH
25546: LD_INT 54
25548: PUSH
25549: EMPTY
25550: LIST
25551: PUSH
25552: EMPTY
25553: LIST
25554: LIST
25555: PUSH
25556: LD_INT 3
25558: PUSH
25559: LD_INT 24
25561: PUSH
25562: LD_INT 800
25564: PUSH
25565: EMPTY
25566: LIST
25567: LIST
25568: PUSH
25569: EMPTY
25570: LIST
25571: LIST
25572: PUSH
25573: EMPTY
25574: LIST
25575: LIST
25576: LIST
25577: PUSH
25578: EMPTY
25579: LIST
25580: LIST
25581: PPUSH
25582: CALL_OW 72
25586: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
25587: LD_ADDR_VAR 0 6
25591: PUSH
25592: LD_EXP 50
25596: PUSH
25597: LD_VAR 0 2
25601: ARRAY
25602: PPUSH
25603: LD_INT 21
25605: PUSH
25606: LD_INT 1
25608: PUSH
25609: EMPTY
25610: LIST
25611: LIST
25612: PUSH
25613: LD_INT 1
25615: PUSH
25616: LD_INT 3
25618: PUSH
25619: LD_INT 54
25621: PUSH
25622: EMPTY
25623: LIST
25624: PUSH
25625: EMPTY
25626: LIST
25627: LIST
25628: PUSH
25629: LD_INT 3
25631: PUSH
25632: LD_INT 24
25634: PUSH
25635: LD_INT 250
25637: PUSH
25638: EMPTY
25639: LIST
25640: LIST
25641: PUSH
25642: EMPTY
25643: LIST
25644: LIST
25645: PUSH
25646: EMPTY
25647: LIST
25648: LIST
25649: LIST
25650: PUSH
25651: EMPTY
25652: LIST
25653: LIST
25654: PPUSH
25655: CALL_OW 72
25659: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
25660: LD_ADDR_VAR 0 7
25664: PUSH
25665: LD_VAR 0 5
25669: PUSH
25670: LD_VAR 0 6
25674: DIFF
25675: ST_TO_ADDR
// if not need_heal_1 then
25676: LD_VAR 0 6
25680: NOT
25681: IFFALSE 25714
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
25683: LD_ADDR_EXP 53
25687: PUSH
25688: LD_EXP 53
25692: PPUSH
25693: LD_VAR 0 2
25697: PUSH
25698: LD_INT 1
25700: PUSH
25701: EMPTY
25702: LIST
25703: LIST
25704: PPUSH
25705: EMPTY
25706: PPUSH
25707: CALL 54387 0 3
25711: ST_TO_ADDR
25712: GO 25784
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
25714: LD_ADDR_EXP 53
25718: PUSH
25719: LD_EXP 53
25723: PPUSH
25724: LD_VAR 0 2
25728: PUSH
25729: LD_INT 1
25731: PUSH
25732: EMPTY
25733: LIST
25734: LIST
25735: PPUSH
25736: LD_EXP 53
25740: PUSH
25741: LD_VAR 0 2
25745: ARRAY
25746: PUSH
25747: LD_INT 1
25749: ARRAY
25750: PPUSH
25751: LD_INT 3
25753: PUSH
25754: LD_INT 24
25756: PUSH
25757: LD_INT 1000
25759: PUSH
25760: EMPTY
25761: LIST
25762: LIST
25763: PUSH
25764: EMPTY
25765: LIST
25766: LIST
25767: PPUSH
25768: CALL_OW 72
25772: PUSH
25773: LD_VAR 0 6
25777: UNION
25778: PPUSH
25779: CALL 54387 0 3
25783: ST_TO_ADDR
// if not need_heal_2 then
25784: LD_VAR 0 7
25788: NOT
25789: IFFALSE 25822
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
25791: LD_ADDR_EXP 53
25795: PUSH
25796: LD_EXP 53
25800: PPUSH
25801: LD_VAR 0 2
25805: PUSH
25806: LD_INT 2
25808: PUSH
25809: EMPTY
25810: LIST
25811: LIST
25812: PPUSH
25813: EMPTY
25814: PPUSH
25815: CALL 54387 0 3
25819: ST_TO_ADDR
25820: GO 25854
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
25822: LD_ADDR_EXP 53
25826: PUSH
25827: LD_EXP 53
25831: PPUSH
25832: LD_VAR 0 2
25836: PUSH
25837: LD_INT 2
25839: PUSH
25840: EMPTY
25841: LIST
25842: LIST
25843: PPUSH
25844: LD_VAR 0 7
25848: PPUSH
25849: CALL 54387 0 3
25853: ST_TO_ADDR
// if need_heal_2 then
25854: LD_VAR 0 7
25858: IFFALSE 26030
// for j in need_heal_2 do
25860: LD_ADDR_VAR 0 3
25864: PUSH
25865: LD_VAR 0 7
25869: PUSH
25870: FOR_IN
25871: IFFALSE 26028
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
25873: LD_ADDR_VAR 0 5
25877: PUSH
25878: LD_EXP 50
25882: PUSH
25883: LD_VAR 0 2
25887: ARRAY
25888: PPUSH
25889: LD_INT 2
25891: PUSH
25892: LD_INT 30
25894: PUSH
25895: LD_INT 6
25897: PUSH
25898: EMPTY
25899: LIST
25900: LIST
25901: PUSH
25902: LD_INT 30
25904: PUSH
25905: LD_INT 7
25907: PUSH
25908: EMPTY
25909: LIST
25910: LIST
25911: PUSH
25912: LD_INT 30
25914: PUSH
25915: LD_INT 8
25917: PUSH
25918: EMPTY
25919: LIST
25920: LIST
25921: PUSH
25922: LD_INT 30
25924: PUSH
25925: LD_INT 0
25927: PUSH
25928: EMPTY
25929: LIST
25930: LIST
25931: PUSH
25932: LD_INT 30
25934: PUSH
25935: LD_INT 1
25937: PUSH
25938: EMPTY
25939: LIST
25940: LIST
25941: PUSH
25942: LD_INT 25
25944: PUSH
25945: LD_INT 4
25947: PUSH
25948: EMPTY
25949: LIST
25950: LIST
25951: PUSH
25952: EMPTY
25953: LIST
25954: LIST
25955: LIST
25956: LIST
25957: LIST
25958: LIST
25959: LIST
25960: PPUSH
25961: CALL_OW 72
25965: ST_TO_ADDR
// if tmp then
25966: LD_VAR 0 5
25970: IFFALSE 26026
// begin k := NearestUnitToUnit ( tmp , j ) ;
25972: LD_ADDR_VAR 0 4
25976: PUSH
25977: LD_VAR 0 5
25981: PPUSH
25982: LD_VAR 0 3
25986: PPUSH
25987: CALL_OW 74
25991: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
25992: LD_VAR 0 3
25996: PPUSH
25997: LD_VAR 0 4
26001: PPUSH
26002: CALL_OW 296
26006: PUSH
26007: LD_INT 7
26009: GREATER
26010: IFFALSE 26026
// ComMoveUnit ( j , k ) ;
26012: LD_VAR 0 3
26016: PPUSH
26017: LD_VAR 0 4
26021: PPUSH
26022: CALL_OW 112
// end ; end ;
26026: GO 25870
26028: POP
26029: POP
// if not need_heal_1 and not need_heal_2 then
26030: LD_VAR 0 6
26034: NOT
26035: PUSH
26036: LD_VAR 0 7
26040: NOT
26041: AND
26042: IFFALSE 26046
// continue ;
26044: GO 25499
// end ;
26046: GO 25499
26048: POP
26049: POP
// RaiseSailEvent ( 102 ) ;
26050: LD_INT 102
26052: PPUSH
26053: CALL_OW 427
// end ;
26057: LD_VAR 0 1
26061: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes ; begin
26062: LD_INT 0
26064: PPUSH
26065: PPUSH
26066: PPUSH
26067: PPUSH
26068: PPUSH
26069: PPUSH
// if not mc_bases then
26070: LD_EXP 50
26074: NOT
26075: IFFALSE 26079
// exit ;
26077: GO 26789
// for i = 1 to mc_bases do
26079: LD_ADDR_VAR 0 2
26083: PUSH
26084: DOUBLE
26085: LD_INT 1
26087: DEC
26088: ST_TO_ADDR
26089: LD_EXP 50
26093: PUSH
26094: FOR_TO
26095: IFFALSE 26787
// begin if not mc_building_need_repair [ i ] then
26097: LD_EXP 51
26101: PUSH
26102: LD_VAR 0 2
26106: ARRAY
26107: NOT
26108: IFFALSE 26282
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
26110: LD_ADDR_VAR 0 6
26114: PUSH
26115: LD_EXP 69
26119: PUSH
26120: LD_VAR 0 2
26124: ARRAY
26125: PPUSH
26126: LD_INT 3
26128: PUSH
26129: LD_INT 24
26131: PUSH
26132: LD_INT 1000
26134: PUSH
26135: EMPTY
26136: LIST
26137: LIST
26138: PUSH
26139: EMPTY
26140: LIST
26141: LIST
26142: PUSH
26143: LD_INT 2
26145: PUSH
26146: LD_INT 34
26148: PUSH
26149: LD_INT 13
26151: PUSH
26152: EMPTY
26153: LIST
26154: LIST
26155: PUSH
26156: LD_INT 34
26158: PUSH
26159: LD_INT 52
26161: PUSH
26162: EMPTY
26163: LIST
26164: LIST
26165: PUSH
26166: EMPTY
26167: LIST
26168: LIST
26169: LIST
26170: PUSH
26171: EMPTY
26172: LIST
26173: LIST
26174: PPUSH
26175: CALL_OW 72
26179: ST_TO_ADDR
// if cranes then
26180: LD_VAR 0 6
26184: IFFALSE 26246
// for j in cranes do
26186: LD_ADDR_VAR 0 3
26190: PUSH
26191: LD_VAR 0 6
26195: PUSH
26196: FOR_IN
26197: IFFALSE 26244
// if not IsInArea ( j , mc_parking [ i ] ) then
26199: LD_VAR 0 3
26203: PPUSH
26204: LD_EXP 74
26208: PUSH
26209: LD_VAR 0 2
26213: ARRAY
26214: PPUSH
26215: CALL_OW 308
26219: NOT
26220: IFFALSE 26242
// ComMoveToArea ( j , mc_parking [ i ] ) ;
26222: LD_VAR 0 3
26226: PPUSH
26227: LD_EXP 74
26231: PUSH
26232: LD_VAR 0 2
26236: ARRAY
26237: PPUSH
26238: CALL_OW 113
26242: GO 26196
26244: POP
26245: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
26246: LD_ADDR_EXP 52
26250: PUSH
26251: LD_EXP 52
26255: PPUSH
26256: LD_VAR 0 2
26260: PPUSH
26261: EMPTY
26262: PPUSH
26263: CALL_OW 1
26267: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
26268: LD_VAR 0 2
26272: PPUSH
26273: LD_INT 101
26275: PPUSH
26276: CALL 21174 0 2
// continue ;
26280: GO 26094
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
26282: LD_ADDR_EXP 56
26286: PUSH
26287: LD_EXP 56
26291: PPUSH
26292: LD_VAR 0 2
26296: PPUSH
26297: EMPTY
26298: PPUSH
26299: CALL_OW 1
26303: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
26304: LD_VAR 0 2
26308: PPUSH
26309: LD_INT 103
26311: PPUSH
26312: CALL 21174 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
26316: LD_ADDR_VAR 0 5
26320: PUSH
26321: LD_EXP 50
26325: PUSH
26326: LD_VAR 0 2
26330: ARRAY
26331: PUSH
26332: LD_EXP 79
26336: PUSH
26337: LD_VAR 0 2
26341: ARRAY
26342: UNION
26343: PPUSH
26344: LD_INT 2
26346: PUSH
26347: LD_INT 25
26349: PUSH
26350: LD_INT 2
26352: PUSH
26353: EMPTY
26354: LIST
26355: LIST
26356: PUSH
26357: LD_INT 25
26359: PUSH
26360: LD_INT 16
26362: PUSH
26363: EMPTY
26364: LIST
26365: LIST
26366: PUSH
26367: EMPTY
26368: LIST
26369: LIST
26370: LIST
26371: PUSH
26372: EMPTY
26373: LIST
26374: PPUSH
26375: CALL_OW 72
26379: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
26380: LD_ADDR_VAR 0 6
26384: PUSH
26385: LD_EXP 69
26389: PUSH
26390: LD_VAR 0 2
26394: ARRAY
26395: PPUSH
26396: LD_INT 2
26398: PUSH
26399: LD_INT 34
26401: PUSH
26402: LD_INT 13
26404: PUSH
26405: EMPTY
26406: LIST
26407: LIST
26408: PUSH
26409: LD_INT 34
26411: PUSH
26412: LD_INT 52
26414: PUSH
26415: EMPTY
26416: LIST
26417: LIST
26418: PUSH
26419: EMPTY
26420: LIST
26421: LIST
26422: LIST
26423: PPUSH
26424: CALL_OW 72
26428: ST_TO_ADDR
// if cranes then
26429: LD_VAR 0 6
26433: IFFALSE 26569
// begin for j in cranes do
26435: LD_ADDR_VAR 0 3
26439: PUSH
26440: LD_VAR 0 6
26444: PUSH
26445: FOR_IN
26446: IFFALSE 26567
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
26448: LD_VAR 0 3
26452: PPUSH
26453: CALL_OW 256
26457: PUSH
26458: LD_INT 500
26460: GREATEREQUAL
26461: PUSH
26462: LD_VAR 0 3
26466: PPUSH
26467: CALL_OW 314
26471: NOT
26472: AND
26473: IFFALSE 26507
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
26475: LD_VAR 0 3
26479: PPUSH
26480: LD_EXP 51
26484: PUSH
26485: LD_VAR 0 2
26489: ARRAY
26490: PPUSH
26491: LD_VAR 0 3
26495: PPUSH
26496: CALL_OW 74
26500: PPUSH
26501: CALL_OW 130
26505: GO 26565
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
26507: LD_VAR 0 3
26511: PPUSH
26512: CALL_OW 256
26516: PUSH
26517: LD_INT 500
26519: LESS
26520: PUSH
26521: LD_VAR 0 3
26525: PPUSH
26526: LD_EXP 74
26530: PUSH
26531: LD_VAR 0 2
26535: ARRAY
26536: PPUSH
26537: CALL_OW 308
26541: NOT
26542: AND
26543: IFFALSE 26565
// ComMoveToArea ( j , mc_parking [ i ] ) ;
26545: LD_VAR 0 3
26549: PPUSH
26550: LD_EXP 74
26554: PUSH
26555: LD_VAR 0 2
26559: ARRAY
26560: PPUSH
26561: CALL_OW 113
26565: GO 26445
26567: POP
26568: POP
// end ; if not tmp then
26569: LD_VAR 0 5
26573: NOT
26574: IFFALSE 26578
// continue ;
26576: GO 26094
// for j in tmp do
26578: LD_ADDR_VAR 0 3
26582: PUSH
26583: LD_VAR 0 5
26587: PUSH
26588: FOR_IN
26589: IFFALSE 26783
// begin if mc_need_heal [ i ] then
26591: LD_EXP 53
26595: PUSH
26596: LD_VAR 0 2
26600: ARRAY
26601: IFFALSE 26649
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
26603: LD_VAR 0 3
26607: PUSH
26608: LD_EXP 53
26612: PUSH
26613: LD_VAR 0 2
26617: ARRAY
26618: PUSH
26619: LD_INT 1
26621: ARRAY
26622: IN
26623: PUSH
26624: LD_VAR 0 3
26628: PUSH
26629: LD_EXP 53
26633: PUSH
26634: LD_VAR 0 2
26638: ARRAY
26639: PUSH
26640: LD_INT 2
26642: ARRAY
26643: IN
26644: OR
26645: IFFALSE 26649
// continue ;
26647: GO 26588
// if IsInUnit ( j ) then
26649: LD_VAR 0 3
26653: PPUSH
26654: CALL_OW 310
26658: IFFALSE 26669
// ComExitBuilding ( j ) ;
26660: LD_VAR 0 3
26664: PPUSH
26665: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
26669: LD_VAR 0 3
26673: PUSH
26674: LD_EXP 52
26678: PUSH
26679: LD_VAR 0 2
26683: ARRAY
26684: IN
26685: NOT
26686: IFFALSE 26744
// begin SetTag ( j , 101 ) ;
26688: LD_VAR 0 3
26692: PPUSH
26693: LD_INT 101
26695: PPUSH
26696: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
26700: LD_ADDR_EXP 52
26704: PUSH
26705: LD_EXP 52
26709: PPUSH
26710: LD_VAR 0 2
26714: PUSH
26715: LD_EXP 52
26719: PUSH
26720: LD_VAR 0 2
26724: ARRAY
26725: PUSH
26726: LD_INT 1
26728: PLUS
26729: PUSH
26730: EMPTY
26731: LIST
26732: LIST
26733: PPUSH
26734: LD_VAR 0 3
26738: PPUSH
26739: CALL 54387 0 3
26743: ST_TO_ADDR
// end ; wait ( 1 ) ;
26744: LD_INT 1
26746: PPUSH
26747: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
26751: LD_VAR 0 3
26755: PPUSH
26756: LD_EXP 51
26760: PUSH
26761: LD_VAR 0 2
26765: ARRAY
26766: PPUSH
26767: LD_VAR 0 3
26771: PPUSH
26772: CALL_OW 74
26776: PPUSH
26777: CALL_OW 130
// end ;
26781: GO 26588
26783: POP
26784: POP
// end ;
26785: GO 26094
26787: POP
26788: POP
// end ;
26789: LD_VAR 0 1
26793: RET
// export function MC_Heal ; var i , j , tmp ; begin
26794: LD_INT 0
26796: PPUSH
26797: PPUSH
26798: PPUSH
26799: PPUSH
// if not mc_bases then
26800: LD_EXP 50
26804: NOT
26805: IFFALSE 26809
// exit ;
26807: GO 27211
// for i = 1 to mc_bases do
26809: LD_ADDR_VAR 0 2
26813: PUSH
26814: DOUBLE
26815: LD_INT 1
26817: DEC
26818: ST_TO_ADDR
26819: LD_EXP 50
26823: PUSH
26824: FOR_TO
26825: IFFALSE 27209
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
26827: LD_EXP 53
26831: PUSH
26832: LD_VAR 0 2
26836: ARRAY
26837: PUSH
26838: LD_INT 1
26840: ARRAY
26841: NOT
26842: PUSH
26843: LD_EXP 53
26847: PUSH
26848: LD_VAR 0 2
26852: ARRAY
26853: PUSH
26854: LD_INT 2
26856: ARRAY
26857: NOT
26858: AND
26859: IFFALSE 26897
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
26861: LD_ADDR_EXP 54
26865: PUSH
26866: LD_EXP 54
26870: PPUSH
26871: LD_VAR 0 2
26875: PPUSH
26876: EMPTY
26877: PPUSH
26878: CALL_OW 1
26882: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
26883: LD_VAR 0 2
26887: PPUSH
26888: LD_INT 102
26890: PPUSH
26891: CALL 21174 0 2
// continue ;
26895: GO 26824
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
26897: LD_ADDR_VAR 0 4
26901: PUSH
26902: LD_EXP 50
26906: PUSH
26907: LD_VAR 0 2
26911: ARRAY
26912: PPUSH
26913: LD_INT 25
26915: PUSH
26916: LD_INT 4
26918: PUSH
26919: EMPTY
26920: LIST
26921: LIST
26922: PPUSH
26923: CALL_OW 72
26927: ST_TO_ADDR
// if not tmp then
26928: LD_VAR 0 4
26932: NOT
26933: IFFALSE 26937
// continue ;
26935: GO 26824
// if mc_taming [ i ] then
26937: LD_EXP 81
26941: PUSH
26942: LD_VAR 0 2
26946: ARRAY
26947: IFFALSE 26971
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
26949: LD_ADDR_EXP 81
26953: PUSH
26954: LD_EXP 81
26958: PPUSH
26959: LD_VAR 0 2
26963: PPUSH
26964: EMPTY
26965: PPUSH
26966: CALL_OW 1
26970: ST_TO_ADDR
// for j in tmp do
26971: LD_ADDR_VAR 0 3
26975: PUSH
26976: LD_VAR 0 4
26980: PUSH
26981: FOR_IN
26982: IFFALSE 27205
// begin if IsInUnit ( j ) then
26984: LD_VAR 0 3
26988: PPUSH
26989: CALL_OW 310
26993: IFFALSE 27004
// ComExitBuilding ( j ) ;
26995: LD_VAR 0 3
26999: PPUSH
27000: CALL_OW 122
// if not j in mc_healers [ i ] then
27004: LD_VAR 0 3
27008: PUSH
27009: LD_EXP 54
27013: PUSH
27014: LD_VAR 0 2
27018: ARRAY
27019: IN
27020: NOT
27021: IFFALSE 27067
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
27023: LD_ADDR_EXP 54
27027: PUSH
27028: LD_EXP 54
27032: PPUSH
27033: LD_VAR 0 2
27037: PUSH
27038: LD_EXP 54
27042: PUSH
27043: LD_VAR 0 2
27047: ARRAY
27048: PUSH
27049: LD_INT 1
27051: PLUS
27052: PUSH
27053: EMPTY
27054: LIST
27055: LIST
27056: PPUSH
27057: LD_VAR 0 3
27061: PPUSH
27062: CALL 54387 0 3
27066: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
27067: LD_VAR 0 3
27071: PPUSH
27072: CALL_OW 110
27076: PUSH
27077: LD_INT 102
27079: NONEQUAL
27080: IFFALSE 27094
// SetTag ( j , 102 ) ;
27082: LD_VAR 0 3
27086: PPUSH
27087: LD_INT 102
27089: PPUSH
27090: CALL_OW 109
// Wait ( 3 ) ;
27094: LD_INT 3
27096: PPUSH
27097: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
27101: LD_EXP 53
27105: PUSH
27106: LD_VAR 0 2
27110: ARRAY
27111: PUSH
27112: LD_INT 1
27114: ARRAY
27115: IFFALSE 27147
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
27117: LD_VAR 0 3
27121: PPUSH
27122: LD_EXP 53
27126: PUSH
27127: LD_VAR 0 2
27131: ARRAY
27132: PUSH
27133: LD_INT 1
27135: ARRAY
27136: PUSH
27137: LD_INT 1
27139: ARRAY
27140: PPUSH
27141: CALL_OW 128
27145: GO 27203
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
27147: LD_VAR 0 3
27151: PPUSH
27152: CALL_OW 314
27156: NOT
27157: PUSH
27158: LD_EXP 53
27162: PUSH
27163: LD_VAR 0 2
27167: ARRAY
27168: PUSH
27169: LD_INT 2
27171: ARRAY
27172: AND
27173: IFFALSE 27203
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
27175: LD_VAR 0 3
27179: PPUSH
27180: LD_EXP 53
27184: PUSH
27185: LD_VAR 0 2
27189: ARRAY
27190: PUSH
27191: LD_INT 2
27193: ARRAY
27194: PUSH
27195: LD_INT 1
27197: ARRAY
27198: PPUSH
27199: CALL_OW 128
// end ;
27203: GO 26981
27205: POP
27206: POP
// end ;
27207: GO 26824
27209: POP
27210: POP
// end ;
27211: LD_VAR 0 1
27215: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
27216: LD_INT 0
27218: PPUSH
27219: PPUSH
27220: PPUSH
27221: PPUSH
27222: PPUSH
// if not mc_bases then
27223: LD_EXP 50
27227: NOT
27228: IFFALSE 27232
// exit ;
27230: GO 28375
// for i = 1 to mc_bases do
27232: LD_ADDR_VAR 0 2
27236: PUSH
27237: DOUBLE
27238: LD_INT 1
27240: DEC
27241: ST_TO_ADDR
27242: LD_EXP 50
27246: PUSH
27247: FOR_TO
27248: IFFALSE 28373
// begin if mc_scan [ i ] then
27250: LD_EXP 73
27254: PUSH
27255: LD_VAR 0 2
27259: ARRAY
27260: IFFALSE 27264
// continue ;
27262: GO 27247
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
27264: LD_EXP 55
27268: PUSH
27269: LD_VAR 0 2
27273: ARRAY
27274: NOT
27275: PUSH
27276: LD_EXP 57
27280: PUSH
27281: LD_VAR 0 2
27285: ARRAY
27286: NOT
27287: AND
27288: PUSH
27289: LD_EXP 56
27293: PUSH
27294: LD_VAR 0 2
27298: ARRAY
27299: AND
27300: IFFALSE 27338
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
27302: LD_ADDR_EXP 56
27306: PUSH
27307: LD_EXP 56
27311: PPUSH
27312: LD_VAR 0 2
27316: PPUSH
27317: EMPTY
27318: PPUSH
27319: CALL_OW 1
27323: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
27324: LD_VAR 0 2
27328: PPUSH
27329: LD_INT 103
27331: PPUSH
27332: CALL 21174 0 2
// continue ;
27336: GO 27247
// end ; if mc_construct_list [ i ] then
27338: LD_EXP 57
27342: PUSH
27343: LD_VAR 0 2
27347: ARRAY
27348: IFFALSE 27568
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
27350: LD_ADDR_VAR 0 4
27354: PUSH
27355: LD_EXP 50
27359: PUSH
27360: LD_VAR 0 2
27364: ARRAY
27365: PPUSH
27366: LD_INT 25
27368: PUSH
27369: LD_INT 2
27371: PUSH
27372: EMPTY
27373: LIST
27374: LIST
27375: PPUSH
27376: CALL_OW 72
27380: PUSH
27381: LD_EXP 52
27385: PUSH
27386: LD_VAR 0 2
27390: ARRAY
27391: DIFF
27392: ST_TO_ADDR
// if not tmp then
27393: LD_VAR 0 4
27397: NOT
27398: IFFALSE 27402
// continue ;
27400: GO 27247
// for j in tmp do
27402: LD_ADDR_VAR 0 3
27406: PUSH
27407: LD_VAR 0 4
27411: PUSH
27412: FOR_IN
27413: IFFALSE 27564
// begin if not mc_builders [ i ] then
27415: LD_EXP 56
27419: PUSH
27420: LD_VAR 0 2
27424: ARRAY
27425: NOT
27426: IFFALSE 27484
// begin SetTag ( j , 103 ) ;
27428: LD_VAR 0 3
27432: PPUSH
27433: LD_INT 103
27435: PPUSH
27436: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
27440: LD_ADDR_EXP 56
27444: PUSH
27445: LD_EXP 56
27449: PPUSH
27450: LD_VAR 0 2
27454: PUSH
27455: LD_EXP 56
27459: PUSH
27460: LD_VAR 0 2
27464: ARRAY
27465: PUSH
27466: LD_INT 1
27468: PLUS
27469: PUSH
27470: EMPTY
27471: LIST
27472: LIST
27473: PPUSH
27474: LD_VAR 0 3
27478: PPUSH
27479: CALL 54387 0 3
27483: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
27484: LD_VAR 0 3
27488: PPUSH
27489: CALL_OW 310
27493: IFFALSE 27504
// ComExitBuilding ( j ) ;
27495: LD_VAR 0 3
27499: PPUSH
27500: CALL_OW 122
// wait ( 3 ) ;
27504: LD_INT 3
27506: PPUSH
27507: CALL_OW 67
// if not mc_construct_list [ i ] then
27511: LD_EXP 57
27515: PUSH
27516: LD_VAR 0 2
27520: ARRAY
27521: NOT
27522: IFFALSE 27526
// break ;
27524: GO 27564
// if not HasTask ( j ) then
27526: LD_VAR 0 3
27530: PPUSH
27531: CALL_OW 314
27535: NOT
27536: IFFALSE 27562
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
27538: LD_VAR 0 3
27542: PPUSH
27543: LD_EXP 57
27547: PUSH
27548: LD_VAR 0 2
27552: ARRAY
27553: PUSH
27554: LD_INT 1
27556: ARRAY
27557: PPUSH
27558: CALL 57238 0 2
// end ;
27562: GO 27412
27564: POP
27565: POP
// end else
27566: GO 28371
// if mc_build_list [ i ] then
27568: LD_EXP 55
27572: PUSH
27573: LD_VAR 0 2
27577: ARRAY
27578: IFFALSE 28371
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
27580: LD_ADDR_VAR 0 5
27584: PUSH
27585: LD_EXP 50
27589: PUSH
27590: LD_VAR 0 2
27594: ARRAY
27595: PPUSH
27596: LD_INT 2
27598: PUSH
27599: LD_INT 30
27601: PUSH
27602: LD_INT 0
27604: PUSH
27605: EMPTY
27606: LIST
27607: LIST
27608: PUSH
27609: LD_INT 30
27611: PUSH
27612: LD_INT 1
27614: PUSH
27615: EMPTY
27616: LIST
27617: LIST
27618: PUSH
27619: EMPTY
27620: LIST
27621: LIST
27622: LIST
27623: PPUSH
27624: CALL_OW 72
27628: ST_TO_ADDR
// if depot then
27629: LD_VAR 0 5
27633: IFFALSE 27651
// depot := depot [ 1 ] else
27635: LD_ADDR_VAR 0 5
27639: PUSH
27640: LD_VAR 0 5
27644: PUSH
27645: LD_INT 1
27647: ARRAY
27648: ST_TO_ADDR
27649: GO 27659
// depot := 0 ;
27651: LD_ADDR_VAR 0 5
27655: PUSH
27656: LD_INT 0
27658: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
27659: LD_EXP 55
27663: PUSH
27664: LD_VAR 0 2
27668: ARRAY
27669: PUSH
27670: LD_INT 1
27672: ARRAY
27673: PUSH
27674: LD_INT 1
27676: ARRAY
27677: PPUSH
27678: CALL 57068 0 1
27682: PUSH
27683: LD_EXP 50
27687: PUSH
27688: LD_VAR 0 2
27692: ARRAY
27693: PPUSH
27694: LD_INT 2
27696: PUSH
27697: LD_INT 30
27699: PUSH
27700: LD_INT 2
27702: PUSH
27703: EMPTY
27704: LIST
27705: LIST
27706: PUSH
27707: LD_INT 30
27709: PUSH
27710: LD_INT 3
27712: PUSH
27713: EMPTY
27714: LIST
27715: LIST
27716: PUSH
27717: EMPTY
27718: LIST
27719: LIST
27720: LIST
27721: PPUSH
27722: CALL_OW 72
27726: NOT
27727: AND
27728: IFFALSE 27833
// begin for j = 1 to mc_build_list [ i ] do
27730: LD_ADDR_VAR 0 3
27734: PUSH
27735: DOUBLE
27736: LD_INT 1
27738: DEC
27739: ST_TO_ADDR
27740: LD_EXP 55
27744: PUSH
27745: LD_VAR 0 2
27749: ARRAY
27750: PUSH
27751: FOR_TO
27752: IFFALSE 27831
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
27754: LD_EXP 55
27758: PUSH
27759: LD_VAR 0 2
27763: ARRAY
27764: PUSH
27765: LD_VAR 0 3
27769: ARRAY
27770: PUSH
27771: LD_INT 1
27773: ARRAY
27774: PUSH
27775: LD_INT 2
27777: EQUAL
27778: IFFALSE 27829
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
27780: LD_ADDR_EXP 55
27784: PUSH
27785: LD_EXP 55
27789: PPUSH
27790: LD_VAR 0 2
27794: PPUSH
27795: LD_EXP 55
27799: PUSH
27800: LD_VAR 0 2
27804: ARRAY
27805: PPUSH
27806: LD_VAR 0 3
27810: PPUSH
27811: LD_INT 1
27813: PPUSH
27814: LD_INT 0
27816: PPUSH
27817: CALL 53805 0 4
27821: PPUSH
27822: CALL_OW 1
27826: ST_TO_ADDR
// break ;
27827: GO 27831
// end ;
27829: GO 27751
27831: POP
27832: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
27833: LD_EXP 55
27837: PUSH
27838: LD_VAR 0 2
27842: ARRAY
27843: PUSH
27844: LD_INT 1
27846: ARRAY
27847: PUSH
27848: LD_INT 1
27850: ARRAY
27851: PUSH
27852: LD_INT 0
27854: EQUAL
27855: PUSH
27856: LD_VAR 0 5
27860: PUSH
27861: LD_VAR 0 5
27865: PPUSH
27866: LD_EXP 55
27870: PUSH
27871: LD_VAR 0 2
27875: ARRAY
27876: PUSH
27877: LD_INT 1
27879: ARRAY
27880: PUSH
27881: LD_INT 1
27883: ARRAY
27884: PPUSH
27885: LD_EXP 55
27889: PUSH
27890: LD_VAR 0 2
27894: ARRAY
27895: PUSH
27896: LD_INT 1
27898: ARRAY
27899: PUSH
27900: LD_INT 2
27902: ARRAY
27903: PPUSH
27904: LD_EXP 55
27908: PUSH
27909: LD_VAR 0 2
27913: ARRAY
27914: PUSH
27915: LD_INT 1
27917: ARRAY
27918: PUSH
27919: LD_INT 3
27921: ARRAY
27922: PPUSH
27923: LD_EXP 55
27927: PUSH
27928: LD_VAR 0 2
27932: ARRAY
27933: PUSH
27934: LD_INT 1
27936: ARRAY
27937: PUSH
27938: LD_INT 4
27940: ARRAY
27941: PPUSH
27942: CALL 61802 0 5
27946: AND
27947: OR
27948: IFFALSE 28229
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
27950: LD_ADDR_VAR 0 4
27954: PUSH
27955: LD_EXP 50
27959: PUSH
27960: LD_VAR 0 2
27964: ARRAY
27965: PPUSH
27966: LD_INT 25
27968: PUSH
27969: LD_INT 2
27971: PUSH
27972: EMPTY
27973: LIST
27974: LIST
27975: PPUSH
27976: CALL_OW 72
27980: PUSH
27981: LD_EXP 52
27985: PUSH
27986: LD_VAR 0 2
27990: ARRAY
27991: DIFF
27992: ST_TO_ADDR
// if not tmp then
27993: LD_VAR 0 4
27997: NOT
27998: IFFALSE 28002
// continue ;
28000: GO 27247
// for j in tmp do
28002: LD_ADDR_VAR 0 3
28006: PUSH
28007: LD_VAR 0 4
28011: PUSH
28012: FOR_IN
28013: IFFALSE 28225
// begin if not mc_builders [ i ] then
28015: LD_EXP 56
28019: PUSH
28020: LD_VAR 0 2
28024: ARRAY
28025: NOT
28026: IFFALSE 28084
// begin SetTag ( j , 103 ) ;
28028: LD_VAR 0 3
28032: PPUSH
28033: LD_INT 103
28035: PPUSH
28036: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
28040: LD_ADDR_EXP 56
28044: PUSH
28045: LD_EXP 56
28049: PPUSH
28050: LD_VAR 0 2
28054: PUSH
28055: LD_EXP 56
28059: PUSH
28060: LD_VAR 0 2
28064: ARRAY
28065: PUSH
28066: LD_INT 1
28068: PLUS
28069: PUSH
28070: EMPTY
28071: LIST
28072: LIST
28073: PPUSH
28074: LD_VAR 0 3
28078: PPUSH
28079: CALL 54387 0 3
28083: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
28084: LD_VAR 0 3
28088: PPUSH
28089: CALL_OW 310
28093: IFFALSE 28104
// ComExitBuilding ( j ) ;
28095: LD_VAR 0 3
28099: PPUSH
28100: CALL_OW 122
// wait ( 3 ) ;
28104: LD_INT 3
28106: PPUSH
28107: CALL_OW 67
// if not mc_build_list [ i ] then
28111: LD_EXP 55
28115: PUSH
28116: LD_VAR 0 2
28120: ARRAY
28121: NOT
28122: IFFALSE 28126
// break ;
28124: GO 28225
// if not HasTask ( j ) then
28126: LD_VAR 0 3
28130: PPUSH
28131: CALL_OW 314
28135: NOT
28136: IFFALSE 28223
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
28138: LD_VAR 0 3
28142: PPUSH
28143: LD_EXP 55
28147: PUSH
28148: LD_VAR 0 2
28152: ARRAY
28153: PUSH
28154: LD_INT 1
28156: ARRAY
28157: PUSH
28158: LD_INT 1
28160: ARRAY
28161: PPUSH
28162: LD_EXP 55
28166: PUSH
28167: LD_VAR 0 2
28171: ARRAY
28172: PUSH
28173: LD_INT 1
28175: ARRAY
28176: PUSH
28177: LD_INT 2
28179: ARRAY
28180: PPUSH
28181: LD_EXP 55
28185: PUSH
28186: LD_VAR 0 2
28190: ARRAY
28191: PUSH
28192: LD_INT 1
28194: ARRAY
28195: PUSH
28196: LD_INT 3
28198: ARRAY
28199: PPUSH
28200: LD_EXP 55
28204: PUSH
28205: LD_VAR 0 2
28209: ARRAY
28210: PUSH
28211: LD_INT 1
28213: ARRAY
28214: PUSH
28215: LD_INT 4
28217: ARRAY
28218: PPUSH
28219: CALL_OW 145
// end ;
28223: GO 28012
28225: POP
28226: POP
// end else
28227: GO 28371
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
28229: LD_EXP 50
28233: PUSH
28234: LD_VAR 0 2
28238: ARRAY
28239: PPUSH
28240: LD_EXP 55
28244: PUSH
28245: LD_VAR 0 2
28249: ARRAY
28250: PUSH
28251: LD_INT 1
28253: ARRAY
28254: PUSH
28255: LD_INT 1
28257: ARRAY
28258: PPUSH
28259: LD_EXP 55
28263: PUSH
28264: LD_VAR 0 2
28268: ARRAY
28269: PUSH
28270: LD_INT 1
28272: ARRAY
28273: PUSH
28274: LD_INT 2
28276: ARRAY
28277: PPUSH
28278: LD_EXP 55
28282: PUSH
28283: LD_VAR 0 2
28287: ARRAY
28288: PUSH
28289: LD_INT 1
28291: ARRAY
28292: PUSH
28293: LD_INT 3
28295: ARRAY
28296: PPUSH
28297: LD_EXP 55
28301: PUSH
28302: LD_VAR 0 2
28306: ARRAY
28307: PUSH
28308: LD_INT 1
28310: ARRAY
28311: PUSH
28312: LD_INT 4
28314: ARRAY
28315: PPUSH
28316: CALL 61138 0 5
28320: NOT
28321: IFFALSE 28371
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
28323: LD_ADDR_EXP 55
28327: PUSH
28328: LD_EXP 55
28332: PPUSH
28333: LD_VAR 0 2
28337: PPUSH
28338: LD_EXP 55
28342: PUSH
28343: LD_VAR 0 2
28347: ARRAY
28348: PPUSH
28349: LD_INT 1
28351: PPUSH
28352: LD_INT 1
28354: NEG
28355: PPUSH
28356: LD_INT 0
28358: PPUSH
28359: CALL 53805 0 4
28363: PPUSH
28364: CALL_OW 1
28368: ST_TO_ADDR
// continue ;
28369: GO 27247
// end ; end ; end ;
28371: GO 27247
28373: POP
28374: POP
// end ;
28375: LD_VAR 0 1
28379: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
28380: LD_INT 0
28382: PPUSH
28383: PPUSH
28384: PPUSH
28385: PPUSH
28386: PPUSH
28387: PPUSH
// if not mc_bases then
28388: LD_EXP 50
28392: NOT
28393: IFFALSE 28397
// exit ;
28395: GO 28824
// for i = 1 to mc_bases do
28397: LD_ADDR_VAR 0 2
28401: PUSH
28402: DOUBLE
28403: LD_INT 1
28405: DEC
28406: ST_TO_ADDR
28407: LD_EXP 50
28411: PUSH
28412: FOR_TO
28413: IFFALSE 28822
// begin tmp := mc_build_upgrade [ i ] ;
28415: LD_ADDR_VAR 0 4
28419: PUSH
28420: LD_EXP 82
28424: PUSH
28425: LD_VAR 0 2
28429: ARRAY
28430: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
28431: LD_ADDR_VAR 0 6
28435: PUSH
28436: LD_EXP 83
28440: PUSH
28441: LD_VAR 0 2
28445: ARRAY
28446: PPUSH
28447: LD_INT 2
28449: PUSH
28450: LD_INT 30
28452: PUSH
28453: LD_INT 6
28455: PUSH
28456: EMPTY
28457: LIST
28458: LIST
28459: PUSH
28460: LD_INT 30
28462: PUSH
28463: LD_INT 7
28465: PUSH
28466: EMPTY
28467: LIST
28468: LIST
28469: PUSH
28470: EMPTY
28471: LIST
28472: LIST
28473: LIST
28474: PPUSH
28475: CALL_OW 72
28479: ST_TO_ADDR
// if not tmp and not lab then
28480: LD_VAR 0 4
28484: NOT
28485: PUSH
28486: LD_VAR 0 6
28490: NOT
28491: AND
28492: IFFALSE 28496
// continue ;
28494: GO 28412
// if tmp then
28496: LD_VAR 0 4
28500: IFFALSE 28620
// for j in tmp do
28502: LD_ADDR_VAR 0 3
28506: PUSH
28507: LD_VAR 0 4
28511: PUSH
28512: FOR_IN
28513: IFFALSE 28618
// begin if UpgradeCost ( j ) then
28515: LD_VAR 0 3
28519: PPUSH
28520: CALL 60798 0 1
28524: IFFALSE 28616
// begin ComUpgrade ( j ) ;
28526: LD_VAR 0 3
28530: PPUSH
28531: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
28535: LD_ADDR_EXP 82
28539: PUSH
28540: LD_EXP 82
28544: PPUSH
28545: LD_VAR 0 2
28549: PPUSH
28550: LD_EXP 82
28554: PUSH
28555: LD_VAR 0 2
28559: ARRAY
28560: PUSH
28561: LD_VAR 0 3
28565: DIFF
28566: PPUSH
28567: CALL_OW 1
28571: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
28572: LD_ADDR_EXP 57
28576: PUSH
28577: LD_EXP 57
28581: PPUSH
28582: LD_VAR 0 2
28586: PUSH
28587: LD_EXP 57
28591: PUSH
28592: LD_VAR 0 2
28596: ARRAY
28597: PUSH
28598: LD_INT 1
28600: PLUS
28601: PUSH
28602: EMPTY
28603: LIST
28604: LIST
28605: PPUSH
28606: LD_VAR 0 3
28610: PPUSH
28611: CALL 54387 0 3
28615: ST_TO_ADDR
// end ; end ;
28616: GO 28512
28618: POP
28619: POP
// if not lab or not mc_lab_upgrade [ i ] then
28620: LD_VAR 0 6
28624: NOT
28625: PUSH
28626: LD_EXP 84
28630: PUSH
28631: LD_VAR 0 2
28635: ARRAY
28636: NOT
28637: OR
28638: IFFALSE 28642
// continue ;
28640: GO 28412
// for j in lab do
28642: LD_ADDR_VAR 0 3
28646: PUSH
28647: LD_VAR 0 6
28651: PUSH
28652: FOR_IN
28653: IFFALSE 28818
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
28655: LD_VAR 0 3
28659: PPUSH
28660: CALL_OW 266
28664: PUSH
28665: LD_INT 6
28667: PUSH
28668: LD_INT 7
28670: PUSH
28671: EMPTY
28672: LIST
28673: LIST
28674: IN
28675: PUSH
28676: LD_VAR 0 3
28680: PPUSH
28681: CALL_OW 461
28685: PUSH
28686: LD_INT 1
28688: NONEQUAL
28689: AND
28690: IFFALSE 28816
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
28692: LD_VAR 0 3
28696: PPUSH
28697: LD_EXP 84
28701: PUSH
28702: LD_VAR 0 2
28706: ARRAY
28707: PUSH
28708: LD_INT 1
28710: ARRAY
28711: PPUSH
28712: CALL 61003 0 2
28716: IFFALSE 28816
// begin ComCancel ( j ) ;
28718: LD_VAR 0 3
28722: PPUSH
28723: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
28727: LD_VAR 0 3
28731: PPUSH
28732: LD_EXP 84
28736: PUSH
28737: LD_VAR 0 2
28741: ARRAY
28742: PUSH
28743: LD_INT 1
28745: ARRAY
28746: PPUSH
28747: CALL_OW 207
// if not j in mc_construct_list [ i ] then
28751: LD_VAR 0 3
28755: PUSH
28756: LD_EXP 57
28760: PUSH
28761: LD_VAR 0 2
28765: ARRAY
28766: IN
28767: NOT
28768: IFFALSE 28814
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
28770: LD_ADDR_EXP 57
28774: PUSH
28775: LD_EXP 57
28779: PPUSH
28780: LD_VAR 0 2
28784: PUSH
28785: LD_EXP 57
28789: PUSH
28790: LD_VAR 0 2
28794: ARRAY
28795: PUSH
28796: LD_INT 1
28798: PLUS
28799: PUSH
28800: EMPTY
28801: LIST
28802: LIST
28803: PPUSH
28804: LD_VAR 0 3
28808: PPUSH
28809: CALL 54387 0 3
28813: ST_TO_ADDR
// break ;
28814: GO 28818
// end ; end ; end ;
28816: GO 28652
28818: POP
28819: POP
// end ;
28820: GO 28412
28822: POP
28823: POP
// end ;
28824: LD_VAR 0 1
28828: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
28829: LD_INT 0
28831: PPUSH
28832: PPUSH
28833: PPUSH
28834: PPUSH
28835: PPUSH
28836: PPUSH
28837: PPUSH
28838: PPUSH
28839: PPUSH
// if not mc_bases then
28840: LD_EXP 50
28844: NOT
28845: IFFALSE 28849
// exit ;
28847: GO 29254
// for i = 1 to mc_bases do
28849: LD_ADDR_VAR 0 2
28853: PUSH
28854: DOUBLE
28855: LD_INT 1
28857: DEC
28858: ST_TO_ADDR
28859: LD_EXP 50
28863: PUSH
28864: FOR_TO
28865: IFFALSE 29252
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
28867: LD_EXP 58
28871: PUSH
28872: LD_VAR 0 2
28876: ARRAY
28877: NOT
28878: PUSH
28879: LD_EXP 50
28883: PUSH
28884: LD_VAR 0 2
28888: ARRAY
28889: PPUSH
28890: LD_INT 30
28892: PUSH
28893: LD_INT 3
28895: PUSH
28896: EMPTY
28897: LIST
28898: LIST
28899: PPUSH
28900: CALL_OW 72
28904: NOT
28905: OR
28906: IFFALSE 28910
// continue ;
28908: GO 28864
// busy := false ;
28910: LD_ADDR_VAR 0 8
28914: PUSH
28915: LD_INT 0
28917: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
28918: LD_ADDR_VAR 0 4
28922: PUSH
28923: LD_EXP 50
28927: PUSH
28928: LD_VAR 0 2
28932: ARRAY
28933: PPUSH
28934: LD_INT 30
28936: PUSH
28937: LD_INT 3
28939: PUSH
28940: EMPTY
28941: LIST
28942: LIST
28943: PPUSH
28944: CALL_OW 72
28948: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
28949: LD_ADDR_VAR 0 6
28953: PUSH
28954: LD_EXP 58
28958: PUSH
28959: LD_VAR 0 2
28963: ARRAY
28964: PPUSH
28965: LD_INT 2
28967: PUSH
28968: LD_INT 30
28970: PUSH
28971: LD_INT 32
28973: PUSH
28974: EMPTY
28975: LIST
28976: LIST
28977: PUSH
28978: LD_INT 30
28980: PUSH
28981: LD_INT 33
28983: PUSH
28984: EMPTY
28985: LIST
28986: LIST
28987: PUSH
28988: EMPTY
28989: LIST
28990: LIST
28991: LIST
28992: PPUSH
28993: CALL_OW 72
28997: ST_TO_ADDR
// if not t then
28998: LD_VAR 0 6
29002: NOT
29003: IFFALSE 29007
// continue ;
29005: GO 28864
// for j in tmp do
29007: LD_ADDR_VAR 0 3
29011: PUSH
29012: LD_VAR 0 4
29016: PUSH
29017: FOR_IN
29018: IFFALSE 29048
// if not BuildingStatus ( j ) = bs_idle then
29020: LD_VAR 0 3
29024: PPUSH
29025: CALL_OW 461
29029: PUSH
29030: LD_INT 2
29032: EQUAL
29033: NOT
29034: IFFALSE 29046
// begin busy := true ;
29036: LD_ADDR_VAR 0 8
29040: PUSH
29041: LD_INT 1
29043: ST_TO_ADDR
// break ;
29044: GO 29048
// end ;
29046: GO 29017
29048: POP
29049: POP
// if busy then
29050: LD_VAR 0 8
29054: IFFALSE 29058
// continue ;
29056: GO 28864
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
29058: LD_ADDR_VAR 0 7
29062: PUSH
29063: LD_VAR 0 6
29067: PPUSH
29068: LD_INT 35
29070: PUSH
29071: LD_INT 0
29073: PUSH
29074: EMPTY
29075: LIST
29076: LIST
29077: PPUSH
29078: CALL_OW 72
29082: ST_TO_ADDR
// if tw then
29083: LD_VAR 0 7
29087: IFFALSE 29164
// begin tw := tw [ 1 ] ;
29089: LD_ADDR_VAR 0 7
29093: PUSH
29094: LD_VAR 0 7
29098: PUSH
29099: LD_INT 1
29101: ARRAY
29102: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
29103: LD_ADDR_VAR 0 9
29107: PUSH
29108: LD_VAR 0 7
29112: PPUSH
29113: LD_EXP 75
29117: PUSH
29118: LD_VAR 0 2
29122: ARRAY
29123: PPUSH
29124: CALL 59357 0 2
29128: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
29129: LD_EXP 89
29133: PUSH
29134: LD_VAR 0 2
29138: ARRAY
29139: IFFALSE 29162
// if not weapon in mc_allowed_tower_weapons [ i ] then
29141: LD_VAR 0 9
29145: PUSH
29146: LD_EXP 89
29150: PUSH
29151: LD_VAR 0 2
29155: ARRAY
29156: IN
29157: NOT
29158: IFFALSE 29162
// continue ;
29160: GO 28864
// end else
29162: GO 29227
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
29164: LD_ADDR_VAR 0 5
29168: PUSH
29169: LD_EXP 58
29173: PUSH
29174: LD_VAR 0 2
29178: ARRAY
29179: PPUSH
29180: LD_VAR 0 4
29184: PPUSH
29185: CALL 89558 0 2
29189: ST_TO_ADDR
// if not tmp2 then
29190: LD_VAR 0 5
29194: NOT
29195: IFFALSE 29199
// continue ;
29197: GO 28864
// tw := tmp2 [ 1 ] ;
29199: LD_ADDR_VAR 0 7
29203: PUSH
29204: LD_VAR 0 5
29208: PUSH
29209: LD_INT 1
29211: ARRAY
29212: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
29213: LD_ADDR_VAR 0 9
29217: PUSH
29218: LD_VAR 0 5
29222: PUSH
29223: LD_INT 2
29225: ARRAY
29226: ST_TO_ADDR
// end ; if not weapon then
29227: LD_VAR 0 9
29231: NOT
29232: IFFALSE 29236
// continue ;
29234: GO 28864
// ComPlaceWeapon ( tw , weapon ) ;
29236: LD_VAR 0 7
29240: PPUSH
29241: LD_VAR 0 9
29245: PPUSH
29246: CALL_OW 148
// end ;
29250: GO 28864
29252: POP
29253: POP
// end ;
29254: LD_VAR 0 1
29258: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
29259: LD_INT 0
29261: PPUSH
29262: PPUSH
29263: PPUSH
29264: PPUSH
29265: PPUSH
29266: PPUSH
// if not mc_bases then
29267: LD_EXP 50
29271: NOT
29272: IFFALSE 29276
// exit ;
29274: GO 30288
// for i = 1 to mc_bases do
29276: LD_ADDR_VAR 0 2
29280: PUSH
29281: DOUBLE
29282: LD_INT 1
29284: DEC
29285: ST_TO_ADDR
29286: LD_EXP 50
29290: PUSH
29291: FOR_TO
29292: IFFALSE 30286
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
29294: LD_EXP 63
29298: PUSH
29299: LD_VAR 0 2
29303: ARRAY
29304: NOT
29305: PUSH
29306: LD_EXP 63
29310: PUSH
29311: LD_VAR 0 2
29315: ARRAY
29316: PUSH
29317: LD_EXP 64
29321: PUSH
29322: LD_VAR 0 2
29326: ARRAY
29327: EQUAL
29328: OR
29329: IFFALSE 29333
// continue ;
29331: GO 29291
// if mc_miners [ i ] then
29333: LD_EXP 64
29337: PUSH
29338: LD_VAR 0 2
29342: ARRAY
29343: IFFALSE 29973
// begin k := 1 ;
29345: LD_ADDR_VAR 0 4
29349: PUSH
29350: LD_INT 1
29352: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
29353: LD_ADDR_VAR 0 3
29357: PUSH
29358: DOUBLE
29359: LD_EXP 64
29363: PUSH
29364: LD_VAR 0 2
29368: ARRAY
29369: INC
29370: ST_TO_ADDR
29371: LD_INT 1
29373: PUSH
29374: FOR_DOWNTO
29375: IFFALSE 29971
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
29377: LD_EXP 64
29381: PUSH
29382: LD_VAR 0 2
29386: ARRAY
29387: PUSH
29388: LD_VAR 0 3
29392: ARRAY
29393: PPUSH
29394: CALL_OW 301
29398: PUSH
29399: LD_EXP 64
29403: PUSH
29404: LD_VAR 0 2
29408: ARRAY
29409: PUSH
29410: LD_VAR 0 3
29414: ARRAY
29415: PPUSH
29416: CALL_OW 257
29420: PUSH
29421: LD_INT 1
29423: NONEQUAL
29424: OR
29425: IFFALSE 29488
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
29427: LD_ADDR_VAR 0 5
29431: PUSH
29432: LD_EXP 64
29436: PUSH
29437: LD_VAR 0 2
29441: ARRAY
29442: PUSH
29443: LD_EXP 64
29447: PUSH
29448: LD_VAR 0 2
29452: ARRAY
29453: PUSH
29454: LD_VAR 0 3
29458: ARRAY
29459: DIFF
29460: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
29461: LD_ADDR_EXP 64
29465: PUSH
29466: LD_EXP 64
29470: PPUSH
29471: LD_VAR 0 2
29475: PPUSH
29476: LD_VAR 0 5
29480: PPUSH
29481: CALL_OW 1
29485: ST_TO_ADDR
// continue ;
29486: GO 29374
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
29488: LD_EXP 64
29492: PUSH
29493: LD_VAR 0 2
29497: ARRAY
29498: PUSH
29499: LD_VAR 0 3
29503: ARRAY
29504: PPUSH
29505: CALL 54323 0 1
29509: PUSH
29510: LD_EXP 64
29514: PUSH
29515: LD_VAR 0 2
29519: ARRAY
29520: PUSH
29521: LD_VAR 0 3
29525: ARRAY
29526: PPUSH
29527: CALL_OW 255
29531: PPUSH
29532: LD_EXP 63
29536: PUSH
29537: LD_VAR 0 2
29541: ARRAY
29542: PUSH
29543: LD_VAR 0 4
29547: ARRAY
29548: PUSH
29549: LD_INT 1
29551: ARRAY
29552: PPUSH
29553: LD_EXP 63
29557: PUSH
29558: LD_VAR 0 2
29562: ARRAY
29563: PUSH
29564: LD_VAR 0 4
29568: ARRAY
29569: PUSH
29570: LD_INT 2
29572: ARRAY
29573: PPUSH
29574: LD_INT 15
29576: PPUSH
29577: CALL 55283 0 4
29581: PUSH
29582: LD_INT 4
29584: ARRAY
29585: PUSH
29586: LD_EXP 64
29590: PUSH
29591: LD_VAR 0 2
29595: ARRAY
29596: PUSH
29597: LD_VAR 0 3
29601: ARRAY
29602: PPUSH
29603: LD_INT 10
29605: PPUSH
29606: CALL 56980 0 2
29610: PUSH
29611: LD_INT 4
29613: ARRAY
29614: OR
29615: AND
29616: IFFALSE 29639
// ComStop ( mc_miners [ i ] [ j ] ) ;
29618: LD_EXP 64
29622: PUSH
29623: LD_VAR 0 2
29627: ARRAY
29628: PUSH
29629: LD_VAR 0 3
29633: ARRAY
29634: PPUSH
29635: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
29639: LD_EXP 64
29643: PUSH
29644: LD_VAR 0 2
29648: ARRAY
29649: PUSH
29650: LD_VAR 0 3
29654: ARRAY
29655: PPUSH
29656: CALL_OW 257
29660: PUSH
29661: LD_INT 1
29663: EQUAL
29664: PUSH
29665: LD_EXP 64
29669: PUSH
29670: LD_VAR 0 2
29674: ARRAY
29675: PUSH
29676: LD_VAR 0 3
29680: ARRAY
29681: PPUSH
29682: CALL_OW 459
29686: NOT
29687: AND
29688: PUSH
29689: LD_EXP 64
29693: PUSH
29694: LD_VAR 0 2
29698: ARRAY
29699: PUSH
29700: LD_VAR 0 3
29704: ARRAY
29705: PPUSH
29706: CALL_OW 255
29710: PPUSH
29711: LD_EXP 63
29715: PUSH
29716: LD_VAR 0 2
29720: ARRAY
29721: PUSH
29722: LD_VAR 0 4
29726: ARRAY
29727: PUSH
29728: LD_INT 1
29730: ARRAY
29731: PPUSH
29732: LD_EXP 63
29736: PUSH
29737: LD_VAR 0 2
29741: ARRAY
29742: PUSH
29743: LD_VAR 0 4
29747: ARRAY
29748: PUSH
29749: LD_INT 2
29751: ARRAY
29752: PPUSH
29753: LD_INT 15
29755: PPUSH
29756: CALL 55283 0 4
29760: PUSH
29761: LD_INT 4
29763: ARRAY
29764: PUSH
29765: LD_INT 0
29767: EQUAL
29768: AND
29769: PUSH
29770: LD_EXP 64
29774: PUSH
29775: LD_VAR 0 2
29779: ARRAY
29780: PUSH
29781: LD_VAR 0 3
29785: ARRAY
29786: PPUSH
29787: CALL_OW 314
29791: NOT
29792: AND
29793: IFFALSE 29969
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
29795: LD_EXP 64
29799: PUSH
29800: LD_VAR 0 2
29804: ARRAY
29805: PUSH
29806: LD_VAR 0 3
29810: ARRAY
29811: PPUSH
29812: CALL_OW 310
29816: IFFALSE 29839
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
29818: LD_EXP 64
29822: PUSH
29823: LD_VAR 0 2
29827: ARRAY
29828: PUSH
29829: LD_VAR 0 3
29833: ARRAY
29834: PPUSH
29835: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
29839: LD_EXP 64
29843: PUSH
29844: LD_VAR 0 2
29848: ARRAY
29849: PUSH
29850: LD_VAR 0 3
29854: ARRAY
29855: PPUSH
29856: CALL_OW 314
29860: NOT
29861: IFFALSE 29929
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
29863: LD_EXP 64
29867: PUSH
29868: LD_VAR 0 2
29872: ARRAY
29873: PUSH
29874: LD_VAR 0 3
29878: ARRAY
29879: PPUSH
29880: LD_EXP 63
29884: PUSH
29885: LD_VAR 0 2
29889: ARRAY
29890: PUSH
29891: LD_VAR 0 4
29895: ARRAY
29896: PUSH
29897: LD_INT 1
29899: ARRAY
29900: PPUSH
29901: LD_EXP 63
29905: PUSH
29906: LD_VAR 0 2
29910: ARRAY
29911: PUSH
29912: LD_VAR 0 4
29916: ARRAY
29917: PUSH
29918: LD_INT 2
29920: ARRAY
29921: PPUSH
29922: LD_INT 0
29924: PPUSH
29925: CALL_OW 193
// k := k + 1 ;
29929: LD_ADDR_VAR 0 4
29933: PUSH
29934: LD_VAR 0 4
29938: PUSH
29939: LD_INT 1
29941: PLUS
29942: ST_TO_ADDR
// if k > mc_mines [ i ] then
29943: LD_VAR 0 4
29947: PUSH
29948: LD_EXP 63
29952: PUSH
29953: LD_VAR 0 2
29957: ARRAY
29958: GREATER
29959: IFFALSE 29969
// k := 1 ;
29961: LD_ADDR_VAR 0 4
29965: PUSH
29966: LD_INT 1
29968: ST_TO_ADDR
// end ; end ;
29969: GO 29374
29971: POP
29972: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
29973: LD_ADDR_VAR 0 5
29977: PUSH
29978: LD_EXP 50
29982: PUSH
29983: LD_VAR 0 2
29987: ARRAY
29988: PPUSH
29989: LD_INT 2
29991: PUSH
29992: LD_INT 30
29994: PUSH
29995: LD_INT 4
29997: PUSH
29998: EMPTY
29999: LIST
30000: LIST
30001: PUSH
30002: LD_INT 30
30004: PUSH
30005: LD_INT 5
30007: PUSH
30008: EMPTY
30009: LIST
30010: LIST
30011: PUSH
30012: LD_INT 30
30014: PUSH
30015: LD_INT 32
30017: PUSH
30018: EMPTY
30019: LIST
30020: LIST
30021: PUSH
30022: EMPTY
30023: LIST
30024: LIST
30025: LIST
30026: LIST
30027: PPUSH
30028: CALL_OW 72
30032: ST_TO_ADDR
// if not tmp then
30033: LD_VAR 0 5
30037: NOT
30038: IFFALSE 30042
// continue ;
30040: GO 29291
// list := [ ] ;
30042: LD_ADDR_VAR 0 6
30046: PUSH
30047: EMPTY
30048: ST_TO_ADDR
// for j in tmp do
30049: LD_ADDR_VAR 0 3
30053: PUSH
30054: LD_VAR 0 5
30058: PUSH
30059: FOR_IN
30060: IFFALSE 30129
// begin for k in UnitsInside ( j ) do
30062: LD_ADDR_VAR 0 4
30066: PUSH
30067: LD_VAR 0 3
30071: PPUSH
30072: CALL_OW 313
30076: PUSH
30077: FOR_IN
30078: IFFALSE 30125
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
30080: LD_VAR 0 4
30084: PPUSH
30085: CALL_OW 257
30089: PUSH
30090: LD_INT 1
30092: EQUAL
30093: PUSH
30094: LD_VAR 0 4
30098: PPUSH
30099: CALL_OW 459
30103: NOT
30104: AND
30105: IFFALSE 30123
// list := list ^ k ;
30107: LD_ADDR_VAR 0 6
30111: PUSH
30112: LD_VAR 0 6
30116: PUSH
30117: LD_VAR 0 4
30121: ADD
30122: ST_TO_ADDR
30123: GO 30077
30125: POP
30126: POP
// end ;
30127: GO 30059
30129: POP
30130: POP
// list := list diff mc_miners [ i ] ;
30131: LD_ADDR_VAR 0 6
30135: PUSH
30136: LD_VAR 0 6
30140: PUSH
30141: LD_EXP 64
30145: PUSH
30146: LD_VAR 0 2
30150: ARRAY
30151: DIFF
30152: ST_TO_ADDR
// if not list then
30153: LD_VAR 0 6
30157: NOT
30158: IFFALSE 30162
// continue ;
30160: GO 29291
// k := mc_mines [ i ] - mc_miners [ i ] ;
30162: LD_ADDR_VAR 0 4
30166: PUSH
30167: LD_EXP 63
30171: PUSH
30172: LD_VAR 0 2
30176: ARRAY
30177: PUSH
30178: LD_EXP 64
30182: PUSH
30183: LD_VAR 0 2
30187: ARRAY
30188: MINUS
30189: ST_TO_ADDR
// if k > list then
30190: LD_VAR 0 4
30194: PUSH
30195: LD_VAR 0 6
30199: GREATER
30200: IFFALSE 30212
// k := list ;
30202: LD_ADDR_VAR 0 4
30206: PUSH
30207: LD_VAR 0 6
30211: ST_TO_ADDR
// for j = 1 to k do
30212: LD_ADDR_VAR 0 3
30216: PUSH
30217: DOUBLE
30218: LD_INT 1
30220: DEC
30221: ST_TO_ADDR
30222: LD_VAR 0 4
30226: PUSH
30227: FOR_TO
30228: IFFALSE 30282
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
30230: LD_ADDR_EXP 64
30234: PUSH
30235: LD_EXP 64
30239: PPUSH
30240: LD_VAR 0 2
30244: PUSH
30245: LD_EXP 64
30249: PUSH
30250: LD_VAR 0 2
30254: ARRAY
30255: PUSH
30256: LD_INT 1
30258: PLUS
30259: PUSH
30260: EMPTY
30261: LIST
30262: LIST
30263: PPUSH
30264: LD_VAR 0 6
30268: PUSH
30269: LD_VAR 0 3
30273: ARRAY
30274: PPUSH
30275: CALL 54387 0 3
30279: ST_TO_ADDR
30280: GO 30227
30282: POP
30283: POP
// end ;
30284: GO 29291
30286: POP
30287: POP
// end ;
30288: LD_VAR 0 1
30292: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
30293: LD_INT 0
30295: PPUSH
30296: PPUSH
30297: PPUSH
30298: PPUSH
30299: PPUSH
30300: PPUSH
30301: PPUSH
30302: PPUSH
30303: PPUSH
30304: PPUSH
// if not mc_bases then
30305: LD_EXP 50
30309: NOT
30310: IFFALSE 30314
// exit ;
30312: GO 32064
// for i = 1 to mc_bases do
30314: LD_ADDR_VAR 0 2
30318: PUSH
30319: DOUBLE
30320: LD_INT 1
30322: DEC
30323: ST_TO_ADDR
30324: LD_EXP 50
30328: PUSH
30329: FOR_TO
30330: IFFALSE 32062
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
30332: LD_EXP 50
30336: PUSH
30337: LD_VAR 0 2
30341: ARRAY
30342: NOT
30343: PUSH
30344: LD_EXP 57
30348: PUSH
30349: LD_VAR 0 2
30353: ARRAY
30354: OR
30355: IFFALSE 30359
// continue ;
30357: GO 30329
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
30359: LD_EXP 66
30363: PUSH
30364: LD_VAR 0 2
30368: ARRAY
30369: NOT
30370: PUSH
30371: LD_EXP 67
30375: PUSH
30376: LD_VAR 0 2
30380: ARRAY
30381: AND
30382: IFFALSE 30420
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
30384: LD_ADDR_EXP 67
30388: PUSH
30389: LD_EXP 67
30393: PPUSH
30394: LD_VAR 0 2
30398: PPUSH
30399: EMPTY
30400: PPUSH
30401: CALL_OW 1
30405: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
30406: LD_VAR 0 2
30410: PPUSH
30411: LD_INT 107
30413: PPUSH
30414: CALL 21174 0 2
// continue ;
30418: GO 30329
// end ; target := [ ] ;
30420: LD_ADDR_VAR 0 6
30424: PUSH
30425: EMPTY
30426: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
30427: LD_ADDR_VAR 0 3
30431: PUSH
30432: DOUBLE
30433: LD_EXP 66
30437: PUSH
30438: LD_VAR 0 2
30442: ARRAY
30443: INC
30444: ST_TO_ADDR
30445: LD_INT 1
30447: PUSH
30448: FOR_DOWNTO
30449: IFFALSE 30709
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
30451: LD_EXP 66
30455: PUSH
30456: LD_VAR 0 2
30460: ARRAY
30461: PUSH
30462: LD_VAR 0 3
30466: ARRAY
30467: PUSH
30468: LD_INT 2
30470: ARRAY
30471: PPUSH
30472: LD_EXP 66
30476: PUSH
30477: LD_VAR 0 2
30481: ARRAY
30482: PUSH
30483: LD_VAR 0 3
30487: ARRAY
30488: PUSH
30489: LD_INT 3
30491: ARRAY
30492: PPUSH
30493: CALL_OW 488
30497: PUSH
30498: LD_EXP 66
30502: PUSH
30503: LD_VAR 0 2
30507: ARRAY
30508: PUSH
30509: LD_VAR 0 3
30513: ARRAY
30514: PUSH
30515: LD_INT 2
30517: ARRAY
30518: PPUSH
30519: LD_EXP 66
30523: PUSH
30524: LD_VAR 0 2
30528: ARRAY
30529: PUSH
30530: LD_VAR 0 3
30534: ARRAY
30535: PUSH
30536: LD_INT 3
30538: ARRAY
30539: PPUSH
30540: CALL_OW 284
30544: PUSH
30545: LD_INT 0
30547: EQUAL
30548: AND
30549: IFFALSE 30604
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
30551: LD_ADDR_VAR 0 5
30555: PUSH
30556: LD_EXP 66
30560: PUSH
30561: LD_VAR 0 2
30565: ARRAY
30566: PPUSH
30567: LD_VAR 0 3
30571: PPUSH
30572: CALL_OW 3
30576: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
30577: LD_ADDR_EXP 66
30581: PUSH
30582: LD_EXP 66
30586: PPUSH
30587: LD_VAR 0 2
30591: PPUSH
30592: LD_VAR 0 5
30596: PPUSH
30597: CALL_OW 1
30601: ST_TO_ADDR
// continue ;
30602: GO 30448
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
30604: LD_EXP 50
30608: PUSH
30609: LD_VAR 0 2
30613: ARRAY
30614: PUSH
30615: LD_INT 1
30617: ARRAY
30618: PPUSH
30619: CALL_OW 255
30623: PPUSH
30624: LD_EXP 66
30628: PUSH
30629: LD_VAR 0 2
30633: ARRAY
30634: PUSH
30635: LD_VAR 0 3
30639: ARRAY
30640: PUSH
30641: LD_INT 2
30643: ARRAY
30644: PPUSH
30645: LD_EXP 66
30649: PUSH
30650: LD_VAR 0 2
30654: ARRAY
30655: PUSH
30656: LD_VAR 0 3
30660: ARRAY
30661: PUSH
30662: LD_INT 3
30664: ARRAY
30665: PPUSH
30666: LD_INT 30
30668: PPUSH
30669: CALL 55283 0 4
30673: PUSH
30674: LD_INT 4
30676: ARRAY
30677: PUSH
30678: LD_INT 0
30680: EQUAL
30681: IFFALSE 30707
// begin target := mc_crates [ i ] [ j ] ;
30683: LD_ADDR_VAR 0 6
30687: PUSH
30688: LD_EXP 66
30692: PUSH
30693: LD_VAR 0 2
30697: ARRAY
30698: PUSH
30699: LD_VAR 0 3
30703: ARRAY
30704: ST_TO_ADDR
// break ;
30705: GO 30709
// end ; end ;
30707: GO 30448
30709: POP
30710: POP
// if not target then
30711: LD_VAR 0 6
30715: NOT
30716: IFFALSE 30720
// continue ;
30718: GO 30329
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
30720: LD_ADDR_VAR 0 7
30724: PUSH
30725: LD_EXP 69
30729: PUSH
30730: LD_VAR 0 2
30734: ARRAY
30735: PPUSH
30736: LD_INT 2
30738: PUSH
30739: LD_INT 3
30741: PUSH
30742: LD_INT 58
30744: PUSH
30745: EMPTY
30746: LIST
30747: PUSH
30748: EMPTY
30749: LIST
30750: LIST
30751: PUSH
30752: LD_INT 61
30754: PUSH
30755: EMPTY
30756: LIST
30757: PUSH
30758: LD_INT 33
30760: PUSH
30761: LD_INT 5
30763: PUSH
30764: EMPTY
30765: LIST
30766: LIST
30767: PUSH
30768: LD_INT 33
30770: PUSH
30771: LD_INT 3
30773: PUSH
30774: EMPTY
30775: LIST
30776: LIST
30777: PUSH
30778: EMPTY
30779: LIST
30780: LIST
30781: LIST
30782: LIST
30783: LIST
30784: PUSH
30785: LD_INT 2
30787: PUSH
30788: LD_INT 34
30790: PUSH
30791: LD_INT 32
30793: PUSH
30794: EMPTY
30795: LIST
30796: LIST
30797: PUSH
30798: LD_INT 34
30800: PUSH
30801: LD_INT 51
30803: PUSH
30804: EMPTY
30805: LIST
30806: LIST
30807: PUSH
30808: LD_INT 34
30810: PUSH
30811: LD_INT 12
30813: PUSH
30814: EMPTY
30815: LIST
30816: LIST
30817: PUSH
30818: EMPTY
30819: LIST
30820: LIST
30821: LIST
30822: LIST
30823: PUSH
30824: EMPTY
30825: LIST
30826: LIST
30827: PPUSH
30828: CALL_OW 72
30832: ST_TO_ADDR
// if not cargo then
30833: LD_VAR 0 7
30837: NOT
30838: IFFALSE 31481
// begin if mc_crates_collector [ i ] < 5 then
30840: LD_EXP 67
30844: PUSH
30845: LD_VAR 0 2
30849: ARRAY
30850: PUSH
30851: LD_INT 5
30853: LESS
30854: IFFALSE 31220
// begin if mc_ape [ i ] then
30856: LD_EXP 79
30860: PUSH
30861: LD_VAR 0 2
30865: ARRAY
30866: IFFALSE 30913
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
30868: LD_ADDR_VAR 0 5
30872: PUSH
30873: LD_EXP 79
30877: PUSH
30878: LD_VAR 0 2
30882: ARRAY
30883: PPUSH
30884: LD_INT 25
30886: PUSH
30887: LD_INT 16
30889: PUSH
30890: EMPTY
30891: LIST
30892: LIST
30893: PUSH
30894: LD_INT 24
30896: PUSH
30897: LD_INT 750
30899: PUSH
30900: EMPTY
30901: LIST
30902: LIST
30903: PUSH
30904: EMPTY
30905: LIST
30906: LIST
30907: PPUSH
30908: CALL_OW 72
30912: ST_TO_ADDR
// if not tmp then
30913: LD_VAR 0 5
30917: NOT
30918: IFFALSE 30965
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
30920: LD_ADDR_VAR 0 5
30924: PUSH
30925: LD_EXP 50
30929: PUSH
30930: LD_VAR 0 2
30934: ARRAY
30935: PPUSH
30936: LD_INT 25
30938: PUSH
30939: LD_INT 2
30941: PUSH
30942: EMPTY
30943: LIST
30944: LIST
30945: PUSH
30946: LD_INT 24
30948: PUSH
30949: LD_INT 750
30951: PUSH
30952: EMPTY
30953: LIST
30954: LIST
30955: PUSH
30956: EMPTY
30957: LIST
30958: LIST
30959: PPUSH
30960: CALL_OW 72
30964: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
30965: LD_EXP 79
30969: PUSH
30970: LD_VAR 0 2
30974: ARRAY
30975: PUSH
30976: LD_EXP 50
30980: PUSH
30981: LD_VAR 0 2
30985: ARRAY
30986: PPUSH
30987: LD_INT 25
30989: PUSH
30990: LD_INT 2
30992: PUSH
30993: EMPTY
30994: LIST
30995: LIST
30996: PUSH
30997: LD_INT 24
30999: PUSH
31000: LD_INT 750
31002: PUSH
31003: EMPTY
31004: LIST
31005: LIST
31006: PUSH
31007: EMPTY
31008: LIST
31009: LIST
31010: PPUSH
31011: CALL_OW 72
31015: AND
31016: PUSH
31017: LD_VAR 0 5
31021: PUSH
31022: LD_INT 5
31024: LESS
31025: AND
31026: IFFALSE 31108
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
31028: LD_ADDR_VAR 0 3
31032: PUSH
31033: LD_EXP 50
31037: PUSH
31038: LD_VAR 0 2
31042: ARRAY
31043: PPUSH
31044: LD_INT 25
31046: PUSH
31047: LD_INT 2
31049: PUSH
31050: EMPTY
31051: LIST
31052: LIST
31053: PUSH
31054: LD_INT 24
31056: PUSH
31057: LD_INT 750
31059: PUSH
31060: EMPTY
31061: LIST
31062: LIST
31063: PUSH
31064: EMPTY
31065: LIST
31066: LIST
31067: PPUSH
31068: CALL_OW 72
31072: PUSH
31073: FOR_IN
31074: IFFALSE 31106
// begin tmp := tmp union j ;
31076: LD_ADDR_VAR 0 5
31080: PUSH
31081: LD_VAR 0 5
31085: PUSH
31086: LD_VAR 0 3
31090: UNION
31091: ST_TO_ADDR
// if tmp >= 5 then
31092: LD_VAR 0 5
31096: PUSH
31097: LD_INT 5
31099: GREATEREQUAL
31100: IFFALSE 31104
// break ;
31102: GO 31106
// end ;
31104: GO 31073
31106: POP
31107: POP
// end ; if not tmp then
31108: LD_VAR 0 5
31112: NOT
31113: IFFALSE 31117
// continue ;
31115: GO 30329
// for j in tmp do
31117: LD_ADDR_VAR 0 3
31121: PUSH
31122: LD_VAR 0 5
31126: PUSH
31127: FOR_IN
31128: IFFALSE 31218
// if not GetTag ( j ) then
31130: LD_VAR 0 3
31134: PPUSH
31135: CALL_OW 110
31139: NOT
31140: IFFALSE 31216
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
31142: LD_ADDR_EXP 67
31146: PUSH
31147: LD_EXP 67
31151: PPUSH
31152: LD_VAR 0 2
31156: PUSH
31157: LD_EXP 67
31161: PUSH
31162: LD_VAR 0 2
31166: ARRAY
31167: PUSH
31168: LD_INT 1
31170: PLUS
31171: PUSH
31172: EMPTY
31173: LIST
31174: LIST
31175: PPUSH
31176: LD_VAR 0 3
31180: PPUSH
31181: CALL 54387 0 3
31185: ST_TO_ADDR
// SetTag ( j , 107 ) ;
31186: LD_VAR 0 3
31190: PPUSH
31191: LD_INT 107
31193: PPUSH
31194: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
31198: LD_EXP 67
31202: PUSH
31203: LD_VAR 0 2
31207: ARRAY
31208: PUSH
31209: LD_INT 5
31211: GREATEREQUAL
31212: IFFALSE 31216
// break ;
31214: GO 31218
// end ;
31216: GO 31127
31218: POP
31219: POP
// end ; if mc_crates_collector [ i ] and target then
31220: LD_EXP 67
31224: PUSH
31225: LD_VAR 0 2
31229: ARRAY
31230: PUSH
31231: LD_VAR 0 6
31235: AND
31236: IFFALSE 31479
// begin if mc_crates_collector [ i ] < target [ 1 ] then
31238: LD_EXP 67
31242: PUSH
31243: LD_VAR 0 2
31247: ARRAY
31248: PUSH
31249: LD_VAR 0 6
31253: PUSH
31254: LD_INT 1
31256: ARRAY
31257: LESS
31258: IFFALSE 31278
// tmp := mc_crates_collector [ i ] else
31260: LD_ADDR_VAR 0 5
31264: PUSH
31265: LD_EXP 67
31269: PUSH
31270: LD_VAR 0 2
31274: ARRAY
31275: ST_TO_ADDR
31276: GO 31292
// tmp := target [ 1 ] ;
31278: LD_ADDR_VAR 0 5
31282: PUSH
31283: LD_VAR 0 6
31287: PUSH
31288: LD_INT 1
31290: ARRAY
31291: ST_TO_ADDR
// k := 0 ;
31292: LD_ADDR_VAR 0 4
31296: PUSH
31297: LD_INT 0
31299: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
31300: LD_ADDR_VAR 0 3
31304: PUSH
31305: LD_EXP 67
31309: PUSH
31310: LD_VAR 0 2
31314: ARRAY
31315: PUSH
31316: FOR_IN
31317: IFFALSE 31477
// begin k := k + 1 ;
31319: LD_ADDR_VAR 0 4
31323: PUSH
31324: LD_VAR 0 4
31328: PUSH
31329: LD_INT 1
31331: PLUS
31332: ST_TO_ADDR
// if k > tmp then
31333: LD_VAR 0 4
31337: PUSH
31338: LD_VAR 0 5
31342: GREATER
31343: IFFALSE 31347
// break ;
31345: GO 31477
// if not GetClass ( j ) in [ 2 , 16 ] then
31347: LD_VAR 0 3
31351: PPUSH
31352: CALL_OW 257
31356: PUSH
31357: LD_INT 2
31359: PUSH
31360: LD_INT 16
31362: PUSH
31363: EMPTY
31364: LIST
31365: LIST
31366: IN
31367: NOT
31368: IFFALSE 31421
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
31370: LD_ADDR_EXP 67
31374: PUSH
31375: LD_EXP 67
31379: PPUSH
31380: LD_VAR 0 2
31384: PPUSH
31385: LD_EXP 67
31389: PUSH
31390: LD_VAR 0 2
31394: ARRAY
31395: PUSH
31396: LD_VAR 0 3
31400: DIFF
31401: PPUSH
31402: CALL_OW 1
31406: ST_TO_ADDR
// SetTag ( j , 0 ) ;
31407: LD_VAR 0 3
31411: PPUSH
31412: LD_INT 0
31414: PPUSH
31415: CALL_OW 109
// continue ;
31419: GO 31316
// end ; if IsInUnit ( j ) then
31421: LD_VAR 0 3
31425: PPUSH
31426: CALL_OW 310
31430: IFFALSE 31441
// ComExitBuilding ( j ) ;
31432: LD_VAR 0 3
31436: PPUSH
31437: CALL_OW 122
// wait ( 3 ) ;
31441: LD_INT 3
31443: PPUSH
31444: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
31448: LD_VAR 0 3
31452: PPUSH
31453: LD_VAR 0 6
31457: PUSH
31458: LD_INT 2
31460: ARRAY
31461: PPUSH
31462: LD_VAR 0 6
31466: PUSH
31467: LD_INT 3
31469: ARRAY
31470: PPUSH
31471: CALL_OW 117
// end ;
31475: GO 31316
31477: POP
31478: POP
// end ; end else
31479: GO 32060
// begin for j in cargo do
31481: LD_ADDR_VAR 0 3
31485: PUSH
31486: LD_VAR 0 7
31490: PUSH
31491: FOR_IN
31492: IFFALSE 32058
// begin if GetTag ( j ) <> 0 then
31494: LD_VAR 0 3
31498: PPUSH
31499: CALL_OW 110
31503: PUSH
31504: LD_INT 0
31506: NONEQUAL
31507: IFFALSE 31511
// continue ;
31509: GO 31491
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
31511: LD_VAR 0 3
31515: PPUSH
31516: CALL_OW 256
31520: PUSH
31521: LD_INT 1000
31523: LESS
31524: PUSH
31525: LD_VAR 0 3
31529: PPUSH
31530: LD_EXP 74
31534: PUSH
31535: LD_VAR 0 2
31539: ARRAY
31540: PPUSH
31541: CALL_OW 308
31545: NOT
31546: AND
31547: IFFALSE 31569
// ComMoveToArea ( j , mc_parking [ i ] ) ;
31549: LD_VAR 0 3
31553: PPUSH
31554: LD_EXP 74
31558: PUSH
31559: LD_VAR 0 2
31563: ARRAY
31564: PPUSH
31565: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
31569: LD_VAR 0 3
31573: PPUSH
31574: CALL_OW 256
31578: PUSH
31579: LD_INT 1000
31581: LESS
31582: PUSH
31583: LD_VAR 0 3
31587: PPUSH
31588: LD_EXP 74
31592: PUSH
31593: LD_VAR 0 2
31597: ARRAY
31598: PPUSH
31599: CALL_OW 308
31603: AND
31604: IFFALSE 31608
// continue ;
31606: GO 31491
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
31608: LD_VAR 0 3
31612: PPUSH
31613: CALL_OW 262
31617: PUSH
31618: LD_INT 2
31620: EQUAL
31621: PUSH
31622: LD_VAR 0 3
31626: PPUSH
31627: CALL_OW 261
31631: PUSH
31632: LD_INT 15
31634: LESS
31635: AND
31636: IFFALSE 31640
// continue ;
31638: GO 31491
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
31640: LD_VAR 0 3
31644: PPUSH
31645: CALL_OW 262
31649: PUSH
31650: LD_INT 1
31652: EQUAL
31653: PUSH
31654: LD_VAR 0 3
31658: PPUSH
31659: CALL_OW 261
31663: PUSH
31664: LD_INT 10
31666: LESS
31667: AND
31668: IFFALSE 31997
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31670: LD_ADDR_VAR 0 8
31674: PUSH
31675: LD_EXP 50
31679: PUSH
31680: LD_VAR 0 2
31684: ARRAY
31685: PPUSH
31686: LD_INT 2
31688: PUSH
31689: LD_INT 30
31691: PUSH
31692: LD_INT 0
31694: PUSH
31695: EMPTY
31696: LIST
31697: LIST
31698: PUSH
31699: LD_INT 30
31701: PUSH
31702: LD_INT 1
31704: PUSH
31705: EMPTY
31706: LIST
31707: LIST
31708: PUSH
31709: EMPTY
31710: LIST
31711: LIST
31712: LIST
31713: PPUSH
31714: CALL_OW 72
31718: ST_TO_ADDR
// if not depot then
31719: LD_VAR 0 8
31723: NOT
31724: IFFALSE 31728
// continue ;
31726: GO 31491
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
31728: LD_VAR 0 3
31732: PPUSH
31733: LD_VAR 0 8
31737: PPUSH
31738: LD_VAR 0 3
31742: PPUSH
31743: CALL_OW 74
31747: PPUSH
31748: CALL_OW 296
31752: PUSH
31753: LD_INT 6
31755: LESS
31756: IFFALSE 31772
// SetFuel ( j , 100 ) else
31758: LD_VAR 0 3
31762: PPUSH
31763: LD_INT 100
31765: PPUSH
31766: CALL_OW 240
31770: GO 31997
// if GetFuel ( j ) = 0 then
31772: LD_VAR 0 3
31776: PPUSH
31777: CALL_OW 261
31781: PUSH
31782: LD_INT 0
31784: EQUAL
31785: IFFALSE 31997
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
31787: LD_ADDR_EXP 69
31791: PUSH
31792: LD_EXP 69
31796: PPUSH
31797: LD_VAR 0 2
31801: PPUSH
31802: LD_EXP 69
31806: PUSH
31807: LD_VAR 0 2
31811: ARRAY
31812: PUSH
31813: LD_VAR 0 3
31817: DIFF
31818: PPUSH
31819: CALL_OW 1
31823: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
31824: LD_VAR 0 3
31828: PPUSH
31829: CALL_OW 263
31833: PUSH
31834: LD_INT 1
31836: EQUAL
31837: IFFALSE 31853
// ComExitVehicle ( IsInUnit ( j ) ) ;
31839: LD_VAR 0 3
31843: PPUSH
31844: CALL_OW 310
31848: PPUSH
31849: CALL_OW 121
// if GetControl ( j ) = control_remote then
31853: LD_VAR 0 3
31857: PPUSH
31858: CALL_OW 263
31862: PUSH
31863: LD_INT 2
31865: EQUAL
31866: IFFALSE 31877
// ComUnlink ( j ) ;
31868: LD_VAR 0 3
31872: PPUSH
31873: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
31877: LD_ADDR_VAR 0 9
31881: PUSH
31882: LD_VAR 0 2
31886: PPUSH
31887: LD_INT 3
31889: PPUSH
31890: CALL 41350 0 2
31894: ST_TO_ADDR
// if fac then
31895: LD_VAR 0 9
31899: IFFALSE 31995
// begin for k in fac do
31901: LD_ADDR_VAR 0 4
31905: PUSH
31906: LD_VAR 0 9
31910: PUSH
31911: FOR_IN
31912: IFFALSE 31993
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
31914: LD_ADDR_VAR 0 10
31918: PUSH
31919: LD_VAR 0 9
31923: PPUSH
31924: LD_VAR 0 3
31928: PPUSH
31929: CALL_OW 265
31933: PPUSH
31934: LD_VAR 0 3
31938: PPUSH
31939: CALL_OW 262
31943: PPUSH
31944: LD_VAR 0 3
31948: PPUSH
31949: CALL_OW 263
31953: PPUSH
31954: LD_VAR 0 3
31958: PPUSH
31959: CALL_OW 264
31963: PPUSH
31964: CALL 51919 0 5
31968: ST_TO_ADDR
// if components then
31969: LD_VAR 0 10
31973: IFFALSE 31991
// begin MC_InsertProduceList ( i , components ) ;
31975: LD_VAR 0 2
31979: PPUSH
31980: LD_VAR 0 10
31984: PPUSH
31985: CALL 40895 0 2
// break ;
31989: GO 31993
// end ; end ;
31991: GO 31911
31993: POP
31994: POP
// end ; continue ;
31995: GO 31491
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
31997: LD_VAR 0 3
32001: PPUSH
32002: LD_INT 1
32004: PPUSH
32005: CALL_OW 289
32009: PUSH
32010: LD_INT 100
32012: LESS
32013: PUSH
32014: LD_VAR 0 3
32018: PPUSH
32019: CALL_OW 314
32023: NOT
32024: AND
32025: IFFALSE 32054
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
32027: LD_VAR 0 3
32031: PPUSH
32032: LD_VAR 0 6
32036: PUSH
32037: LD_INT 2
32039: ARRAY
32040: PPUSH
32041: LD_VAR 0 6
32045: PUSH
32046: LD_INT 3
32048: ARRAY
32049: PPUSH
32050: CALL_OW 117
// break ;
32054: GO 32058
// end ;
32056: GO 31491
32058: POP
32059: POP
// end ; end ;
32060: GO 30329
32062: POP
32063: POP
// end ;
32064: LD_VAR 0 1
32068: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
32069: LD_INT 0
32071: PPUSH
32072: PPUSH
32073: PPUSH
32074: PPUSH
// if not mc_bases then
32075: LD_EXP 50
32079: NOT
32080: IFFALSE 32084
// exit ;
32082: GO 32245
// for i = 1 to mc_bases do
32084: LD_ADDR_VAR 0 2
32088: PUSH
32089: DOUBLE
32090: LD_INT 1
32092: DEC
32093: ST_TO_ADDR
32094: LD_EXP 50
32098: PUSH
32099: FOR_TO
32100: IFFALSE 32243
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
32102: LD_ADDR_VAR 0 4
32106: PUSH
32107: LD_EXP 69
32111: PUSH
32112: LD_VAR 0 2
32116: ARRAY
32117: PUSH
32118: LD_EXP 72
32122: PUSH
32123: LD_VAR 0 2
32127: ARRAY
32128: UNION
32129: PPUSH
32130: LD_INT 33
32132: PUSH
32133: LD_INT 2
32135: PUSH
32136: EMPTY
32137: LIST
32138: LIST
32139: PPUSH
32140: CALL_OW 72
32144: ST_TO_ADDR
// if tmp then
32145: LD_VAR 0 4
32149: IFFALSE 32241
// for j in tmp do
32151: LD_ADDR_VAR 0 3
32155: PUSH
32156: LD_VAR 0 4
32160: PUSH
32161: FOR_IN
32162: IFFALSE 32239
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
32164: LD_VAR 0 3
32168: PPUSH
32169: CALL_OW 312
32173: NOT
32174: PUSH
32175: LD_VAR 0 3
32179: PPUSH
32180: CALL_OW 256
32184: PUSH
32185: LD_INT 250
32187: GREATEREQUAL
32188: AND
32189: IFFALSE 32202
// Connect ( j ) else
32191: LD_VAR 0 3
32195: PPUSH
32196: CALL 57320 0 1
32200: GO 32237
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
32202: LD_VAR 0 3
32206: PPUSH
32207: CALL_OW 256
32211: PUSH
32212: LD_INT 250
32214: LESS
32215: PUSH
32216: LD_VAR 0 3
32220: PPUSH
32221: CALL_OW 312
32225: AND
32226: IFFALSE 32237
// ComUnlink ( j ) ;
32228: LD_VAR 0 3
32232: PPUSH
32233: CALL_OW 136
32237: GO 32161
32239: POP
32240: POP
// end ;
32241: GO 32099
32243: POP
32244: POP
// end ;
32245: LD_VAR 0 1
32249: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
32250: LD_INT 0
32252: PPUSH
32253: PPUSH
32254: PPUSH
32255: PPUSH
32256: PPUSH
// if not mc_bases then
32257: LD_EXP 50
32261: NOT
32262: IFFALSE 32266
// exit ;
32264: GO 32711
// for i = 1 to mc_bases do
32266: LD_ADDR_VAR 0 2
32270: PUSH
32271: DOUBLE
32272: LD_INT 1
32274: DEC
32275: ST_TO_ADDR
32276: LD_EXP 50
32280: PUSH
32281: FOR_TO
32282: IFFALSE 32709
// begin if not mc_produce [ i ] then
32284: LD_EXP 71
32288: PUSH
32289: LD_VAR 0 2
32293: ARRAY
32294: NOT
32295: IFFALSE 32299
// continue ;
32297: GO 32281
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
32299: LD_ADDR_VAR 0 5
32303: PUSH
32304: LD_EXP 50
32308: PUSH
32309: LD_VAR 0 2
32313: ARRAY
32314: PPUSH
32315: LD_INT 30
32317: PUSH
32318: LD_INT 3
32320: PUSH
32321: EMPTY
32322: LIST
32323: LIST
32324: PPUSH
32325: CALL_OW 72
32329: ST_TO_ADDR
// if not fac then
32330: LD_VAR 0 5
32334: NOT
32335: IFFALSE 32339
// continue ;
32337: GO 32281
// for j in fac do
32339: LD_ADDR_VAR 0 3
32343: PUSH
32344: LD_VAR 0 5
32348: PUSH
32349: FOR_IN
32350: IFFALSE 32705
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
32352: LD_VAR 0 3
32356: PPUSH
32357: CALL_OW 461
32361: PUSH
32362: LD_INT 2
32364: NONEQUAL
32365: PUSH
32366: LD_VAR 0 3
32370: PPUSH
32371: LD_INT 15
32373: PPUSH
32374: CALL 56980 0 2
32378: PUSH
32379: LD_INT 4
32381: ARRAY
32382: OR
32383: IFFALSE 32387
// continue ;
32385: GO 32349
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
32387: LD_VAR 0 3
32391: PPUSH
32392: LD_EXP 71
32396: PUSH
32397: LD_VAR 0 2
32401: ARRAY
32402: PUSH
32403: LD_INT 1
32405: ARRAY
32406: PUSH
32407: LD_INT 1
32409: ARRAY
32410: PPUSH
32411: LD_EXP 71
32415: PUSH
32416: LD_VAR 0 2
32420: ARRAY
32421: PUSH
32422: LD_INT 1
32424: ARRAY
32425: PUSH
32426: LD_INT 2
32428: ARRAY
32429: PPUSH
32430: LD_EXP 71
32434: PUSH
32435: LD_VAR 0 2
32439: ARRAY
32440: PUSH
32441: LD_INT 1
32443: ARRAY
32444: PUSH
32445: LD_INT 3
32447: ARRAY
32448: PPUSH
32449: LD_EXP 71
32453: PUSH
32454: LD_VAR 0 2
32458: ARRAY
32459: PUSH
32460: LD_INT 1
32462: ARRAY
32463: PUSH
32464: LD_INT 4
32466: ARRAY
32467: PPUSH
32468: CALL_OW 448
32472: PUSH
32473: LD_VAR 0 3
32477: PPUSH
32478: LD_EXP 71
32482: PUSH
32483: LD_VAR 0 2
32487: ARRAY
32488: PUSH
32489: LD_INT 1
32491: ARRAY
32492: PUSH
32493: LD_INT 1
32495: ARRAY
32496: PUSH
32497: LD_EXP 71
32501: PUSH
32502: LD_VAR 0 2
32506: ARRAY
32507: PUSH
32508: LD_INT 1
32510: ARRAY
32511: PUSH
32512: LD_INT 2
32514: ARRAY
32515: PUSH
32516: LD_EXP 71
32520: PUSH
32521: LD_VAR 0 2
32525: ARRAY
32526: PUSH
32527: LD_INT 1
32529: ARRAY
32530: PUSH
32531: LD_INT 3
32533: ARRAY
32534: PUSH
32535: LD_EXP 71
32539: PUSH
32540: LD_VAR 0 2
32544: ARRAY
32545: PUSH
32546: LD_INT 1
32548: ARRAY
32549: PUSH
32550: LD_INT 4
32552: ARRAY
32553: PUSH
32554: EMPTY
32555: LIST
32556: LIST
32557: LIST
32558: LIST
32559: PPUSH
32560: CALL 60651 0 2
32564: AND
32565: IFFALSE 32703
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
32567: LD_VAR 0 3
32571: PPUSH
32572: LD_EXP 71
32576: PUSH
32577: LD_VAR 0 2
32581: ARRAY
32582: PUSH
32583: LD_INT 1
32585: ARRAY
32586: PUSH
32587: LD_INT 1
32589: ARRAY
32590: PPUSH
32591: LD_EXP 71
32595: PUSH
32596: LD_VAR 0 2
32600: ARRAY
32601: PUSH
32602: LD_INT 1
32604: ARRAY
32605: PUSH
32606: LD_INT 2
32608: ARRAY
32609: PPUSH
32610: LD_EXP 71
32614: PUSH
32615: LD_VAR 0 2
32619: ARRAY
32620: PUSH
32621: LD_INT 1
32623: ARRAY
32624: PUSH
32625: LD_INT 3
32627: ARRAY
32628: PPUSH
32629: LD_EXP 71
32633: PUSH
32634: LD_VAR 0 2
32638: ARRAY
32639: PUSH
32640: LD_INT 1
32642: ARRAY
32643: PUSH
32644: LD_INT 4
32646: ARRAY
32647: PPUSH
32648: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
32652: LD_ADDR_VAR 0 4
32656: PUSH
32657: LD_EXP 71
32661: PUSH
32662: LD_VAR 0 2
32666: ARRAY
32667: PPUSH
32668: LD_INT 1
32670: PPUSH
32671: CALL_OW 3
32675: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
32676: LD_ADDR_EXP 71
32680: PUSH
32681: LD_EXP 71
32685: PPUSH
32686: LD_VAR 0 2
32690: PPUSH
32691: LD_VAR 0 4
32695: PPUSH
32696: CALL_OW 1
32700: ST_TO_ADDR
// break ;
32701: GO 32705
// end ; end ;
32703: GO 32349
32705: POP
32706: POP
// end ;
32707: GO 32281
32709: POP
32710: POP
// end ;
32711: LD_VAR 0 1
32715: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
32716: LD_INT 0
32718: PPUSH
32719: PPUSH
32720: PPUSH
// if not mc_bases then
32721: LD_EXP 50
32725: NOT
32726: IFFALSE 32730
// exit ;
32728: GO 32819
// for i = 1 to mc_bases do
32730: LD_ADDR_VAR 0 2
32734: PUSH
32735: DOUBLE
32736: LD_INT 1
32738: DEC
32739: ST_TO_ADDR
32740: LD_EXP 50
32744: PUSH
32745: FOR_TO
32746: IFFALSE 32817
// begin if mc_attack [ i ] then
32748: LD_EXP 70
32752: PUSH
32753: LD_VAR 0 2
32757: ARRAY
32758: IFFALSE 32815
// begin tmp := mc_attack [ i ] [ 1 ] ;
32760: LD_ADDR_VAR 0 3
32764: PUSH
32765: LD_EXP 70
32769: PUSH
32770: LD_VAR 0 2
32774: ARRAY
32775: PUSH
32776: LD_INT 1
32778: ARRAY
32779: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
32780: LD_ADDR_EXP 70
32784: PUSH
32785: LD_EXP 70
32789: PPUSH
32790: LD_VAR 0 2
32794: PPUSH
32795: EMPTY
32796: PPUSH
32797: CALL_OW 1
32801: ST_TO_ADDR
// Attack ( tmp ) ;
32802: LD_VAR 0 3
32806: PPUSH
32807: CALL 82864 0 1
// exit ;
32811: POP
32812: POP
32813: GO 32819
// end ; end ;
32815: GO 32745
32817: POP
32818: POP
// end ;
32819: LD_VAR 0 1
32823: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
32824: LD_INT 0
32826: PPUSH
32827: PPUSH
32828: PPUSH
32829: PPUSH
32830: PPUSH
32831: PPUSH
32832: PPUSH
// if not mc_bases then
32833: LD_EXP 50
32837: NOT
32838: IFFALSE 32842
// exit ;
32840: GO 33424
// for i = 1 to mc_bases do
32842: LD_ADDR_VAR 0 2
32846: PUSH
32847: DOUBLE
32848: LD_INT 1
32850: DEC
32851: ST_TO_ADDR
32852: LD_EXP 50
32856: PUSH
32857: FOR_TO
32858: IFFALSE 33422
// begin if not mc_bases [ i ] then
32860: LD_EXP 50
32864: PUSH
32865: LD_VAR 0 2
32869: ARRAY
32870: NOT
32871: IFFALSE 32875
// continue ;
32873: GO 32857
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
32875: LD_ADDR_VAR 0 7
32879: PUSH
32880: LD_EXP 50
32884: PUSH
32885: LD_VAR 0 2
32889: ARRAY
32890: PUSH
32891: LD_INT 1
32893: ARRAY
32894: PPUSH
32895: CALL 51223 0 1
32899: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
32900: LD_ADDR_EXP 73
32904: PUSH
32905: LD_EXP 73
32909: PPUSH
32910: LD_VAR 0 2
32914: PPUSH
32915: LD_EXP 50
32919: PUSH
32920: LD_VAR 0 2
32924: ARRAY
32925: PUSH
32926: LD_INT 1
32928: ARRAY
32929: PPUSH
32930: CALL_OW 255
32934: PPUSH
32935: LD_EXP 75
32939: PUSH
32940: LD_VAR 0 2
32944: ARRAY
32945: PPUSH
32946: CALL 48866 0 2
32950: PPUSH
32951: CALL_OW 1
32955: ST_TO_ADDR
// if not mc_scan [ i ] then
32956: LD_EXP 73
32960: PUSH
32961: LD_VAR 0 2
32965: ARRAY
32966: NOT
32967: IFFALSE 33122
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
32969: LD_ADDR_VAR 0 4
32973: PUSH
32974: LD_EXP 50
32978: PUSH
32979: LD_VAR 0 2
32983: ARRAY
32984: PPUSH
32985: LD_INT 2
32987: PUSH
32988: LD_INT 25
32990: PUSH
32991: LD_INT 5
32993: PUSH
32994: EMPTY
32995: LIST
32996: LIST
32997: PUSH
32998: LD_INT 25
33000: PUSH
33001: LD_INT 8
33003: PUSH
33004: EMPTY
33005: LIST
33006: LIST
33007: PUSH
33008: LD_INT 25
33010: PUSH
33011: LD_INT 9
33013: PUSH
33014: EMPTY
33015: LIST
33016: LIST
33017: PUSH
33018: EMPTY
33019: LIST
33020: LIST
33021: LIST
33022: LIST
33023: PPUSH
33024: CALL_OW 72
33028: ST_TO_ADDR
// if not tmp then
33029: LD_VAR 0 4
33033: NOT
33034: IFFALSE 33038
// continue ;
33036: GO 32857
// for j in tmp do
33038: LD_ADDR_VAR 0 3
33042: PUSH
33043: LD_VAR 0 4
33047: PUSH
33048: FOR_IN
33049: IFFALSE 33120
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
33051: LD_VAR 0 3
33055: PPUSH
33056: CALL_OW 310
33060: PPUSH
33061: CALL_OW 266
33065: PUSH
33066: LD_INT 5
33068: EQUAL
33069: PUSH
33070: LD_VAR 0 3
33074: PPUSH
33075: CALL_OW 257
33079: PUSH
33080: LD_INT 1
33082: EQUAL
33083: AND
33084: PUSH
33085: LD_VAR 0 3
33089: PPUSH
33090: CALL_OW 459
33094: NOT
33095: AND
33096: PUSH
33097: LD_VAR 0 7
33101: AND
33102: IFFALSE 33118
// ComChangeProfession ( j , class ) ;
33104: LD_VAR 0 3
33108: PPUSH
33109: LD_VAR 0 7
33113: PPUSH
33114: CALL_OW 123
33118: GO 33048
33120: POP
33121: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
33122: LD_EXP 73
33126: PUSH
33127: LD_VAR 0 2
33131: ARRAY
33132: PUSH
33133: LD_EXP 72
33137: PUSH
33138: LD_VAR 0 2
33142: ARRAY
33143: NOT
33144: AND
33145: PUSH
33146: LD_EXP 50
33150: PUSH
33151: LD_VAR 0 2
33155: ARRAY
33156: PPUSH
33157: LD_INT 30
33159: PUSH
33160: LD_INT 32
33162: PUSH
33163: EMPTY
33164: LIST
33165: LIST
33166: PPUSH
33167: CALL_OW 72
33171: NOT
33172: AND
33173: PUSH
33174: LD_EXP 50
33178: PUSH
33179: LD_VAR 0 2
33183: ARRAY
33184: PPUSH
33185: LD_INT 2
33187: PUSH
33188: LD_INT 30
33190: PUSH
33191: LD_INT 4
33193: PUSH
33194: EMPTY
33195: LIST
33196: LIST
33197: PUSH
33198: LD_INT 30
33200: PUSH
33201: LD_INT 5
33203: PUSH
33204: EMPTY
33205: LIST
33206: LIST
33207: PUSH
33208: EMPTY
33209: LIST
33210: LIST
33211: LIST
33212: PPUSH
33213: CALL_OW 72
33217: NOT
33218: AND
33219: IFFALSE 33351
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
33221: LD_ADDR_VAR 0 4
33225: PUSH
33226: LD_EXP 50
33230: PUSH
33231: LD_VAR 0 2
33235: ARRAY
33236: PPUSH
33237: LD_INT 2
33239: PUSH
33240: LD_INT 25
33242: PUSH
33243: LD_INT 1
33245: PUSH
33246: EMPTY
33247: LIST
33248: LIST
33249: PUSH
33250: LD_INT 25
33252: PUSH
33253: LD_INT 5
33255: PUSH
33256: EMPTY
33257: LIST
33258: LIST
33259: PUSH
33260: LD_INT 25
33262: PUSH
33263: LD_INT 8
33265: PUSH
33266: EMPTY
33267: LIST
33268: LIST
33269: PUSH
33270: LD_INT 25
33272: PUSH
33273: LD_INT 9
33275: PUSH
33276: EMPTY
33277: LIST
33278: LIST
33279: PUSH
33280: EMPTY
33281: LIST
33282: LIST
33283: LIST
33284: LIST
33285: LIST
33286: PPUSH
33287: CALL_OW 72
33291: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
33292: LD_ADDR_VAR 0 4
33296: PUSH
33297: LD_VAR 0 4
33301: PUSH
33302: LD_VAR 0 4
33306: PPUSH
33307: LD_INT 18
33309: PPUSH
33310: CALL 87647 0 2
33314: DIFF
33315: ST_TO_ADDR
// if tmp then
33316: LD_VAR 0 4
33320: IFFALSE 33351
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
33322: LD_VAR 0 2
33326: PPUSH
33327: LD_VAR 0 4
33331: PPUSH
33332: LD_EXP 75
33336: PUSH
33337: LD_VAR 0 2
33341: ARRAY
33342: PPUSH
33343: CALL 48901 0 3
// exit ;
33347: POP
33348: POP
33349: GO 33424
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
33351: LD_EXP 73
33355: PUSH
33356: LD_VAR 0 2
33360: ARRAY
33361: PUSH
33362: LD_EXP 72
33366: PUSH
33367: LD_VAR 0 2
33371: ARRAY
33372: AND
33373: IFFALSE 33420
// begin tmp := mc_defender [ i ] ;
33375: LD_ADDR_VAR 0 4
33379: PUSH
33380: LD_EXP 72
33384: PUSH
33385: LD_VAR 0 2
33389: ARRAY
33390: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
33391: LD_VAR 0 2
33395: PPUSH
33396: LD_VAR 0 4
33400: PPUSH
33401: LD_EXP 73
33405: PUSH
33406: LD_VAR 0 2
33410: ARRAY
33411: PPUSH
33412: CALL 49462 0 3
// exit ;
33416: POP
33417: POP
33418: GO 33424
// end ; end ;
33420: GO 32857
33422: POP
33423: POP
// end ;
33424: LD_VAR 0 1
33428: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
33429: LD_INT 0
33431: PPUSH
33432: PPUSH
33433: PPUSH
33434: PPUSH
33435: PPUSH
33436: PPUSH
33437: PPUSH
33438: PPUSH
33439: PPUSH
33440: PPUSH
33441: PPUSH
// if not mc_bases then
33442: LD_EXP 50
33446: NOT
33447: IFFALSE 33451
// exit ;
33449: GO 34538
// for i = 1 to mc_bases do
33451: LD_ADDR_VAR 0 2
33455: PUSH
33456: DOUBLE
33457: LD_INT 1
33459: DEC
33460: ST_TO_ADDR
33461: LD_EXP 50
33465: PUSH
33466: FOR_TO
33467: IFFALSE 34536
// begin tmp := mc_lab [ i ] ;
33469: LD_ADDR_VAR 0 6
33473: PUSH
33474: LD_EXP 83
33478: PUSH
33479: LD_VAR 0 2
33483: ARRAY
33484: ST_TO_ADDR
// if not tmp then
33485: LD_VAR 0 6
33489: NOT
33490: IFFALSE 33494
// continue ;
33492: GO 33466
// idle_lab := 0 ;
33494: LD_ADDR_VAR 0 11
33498: PUSH
33499: LD_INT 0
33501: ST_TO_ADDR
// for j in tmp do
33502: LD_ADDR_VAR 0 3
33506: PUSH
33507: LD_VAR 0 6
33511: PUSH
33512: FOR_IN
33513: IFFALSE 34532
// begin researching := false ;
33515: LD_ADDR_VAR 0 10
33519: PUSH
33520: LD_INT 0
33522: ST_TO_ADDR
// side := GetSide ( j ) ;
33523: LD_ADDR_VAR 0 4
33527: PUSH
33528: LD_VAR 0 3
33532: PPUSH
33533: CALL_OW 255
33537: ST_TO_ADDR
// if not mc_tech [ side ] then
33538: LD_EXP 77
33542: PUSH
33543: LD_VAR 0 4
33547: ARRAY
33548: NOT
33549: IFFALSE 33553
// continue ;
33551: GO 33512
// if BuildingStatus ( j ) = bs_idle then
33553: LD_VAR 0 3
33557: PPUSH
33558: CALL_OW 461
33562: PUSH
33563: LD_INT 2
33565: EQUAL
33566: IFFALSE 33754
// begin if idle_lab and UnitsInside ( j ) < 6 then
33568: LD_VAR 0 11
33572: PUSH
33573: LD_VAR 0 3
33577: PPUSH
33578: CALL_OW 313
33582: PUSH
33583: LD_INT 6
33585: LESS
33586: AND
33587: IFFALSE 33658
// begin tmp2 := UnitsInside ( idle_lab ) ;
33589: LD_ADDR_VAR 0 9
33593: PUSH
33594: LD_VAR 0 11
33598: PPUSH
33599: CALL_OW 313
33603: ST_TO_ADDR
// if tmp2 then
33604: LD_VAR 0 9
33608: IFFALSE 33650
// for x in tmp2 do
33610: LD_ADDR_VAR 0 7
33614: PUSH
33615: LD_VAR 0 9
33619: PUSH
33620: FOR_IN
33621: IFFALSE 33648
// begin ComExitBuilding ( x ) ;
33623: LD_VAR 0 7
33627: PPUSH
33628: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
33632: LD_VAR 0 7
33636: PPUSH
33637: LD_VAR 0 3
33641: PPUSH
33642: CALL_OW 180
// end ;
33646: GO 33620
33648: POP
33649: POP
// idle_lab := 0 ;
33650: LD_ADDR_VAR 0 11
33654: PUSH
33655: LD_INT 0
33657: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
33658: LD_ADDR_VAR 0 5
33662: PUSH
33663: LD_EXP 77
33667: PUSH
33668: LD_VAR 0 4
33672: ARRAY
33673: PUSH
33674: FOR_IN
33675: IFFALSE 33735
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
33677: LD_VAR 0 3
33681: PPUSH
33682: LD_VAR 0 5
33686: PPUSH
33687: CALL_OW 430
33691: PUSH
33692: LD_VAR 0 4
33696: PPUSH
33697: LD_VAR 0 5
33701: PPUSH
33702: CALL 47971 0 2
33706: AND
33707: IFFALSE 33733
// begin researching := true ;
33709: LD_ADDR_VAR 0 10
33713: PUSH
33714: LD_INT 1
33716: ST_TO_ADDR
// ComResearch ( j , t ) ;
33717: LD_VAR 0 3
33721: PPUSH
33722: LD_VAR 0 5
33726: PPUSH
33727: CALL_OW 124
// break ;
33731: GO 33735
// end ;
33733: GO 33674
33735: POP
33736: POP
// if not researching then
33737: LD_VAR 0 10
33741: NOT
33742: IFFALSE 33754
// idle_lab := j ;
33744: LD_ADDR_VAR 0 11
33748: PUSH
33749: LD_VAR 0 3
33753: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
33754: LD_VAR 0 3
33758: PPUSH
33759: CALL_OW 461
33763: PUSH
33764: LD_INT 10
33766: EQUAL
33767: IFFALSE 34355
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
33769: LD_EXP 79
33773: PUSH
33774: LD_VAR 0 2
33778: ARRAY
33779: NOT
33780: PUSH
33781: LD_EXP 80
33785: PUSH
33786: LD_VAR 0 2
33790: ARRAY
33791: NOT
33792: AND
33793: PUSH
33794: LD_EXP 77
33798: PUSH
33799: LD_VAR 0 4
33803: ARRAY
33804: PUSH
33805: LD_INT 1
33807: GREATER
33808: AND
33809: IFFALSE 33940
// begin ComCancel ( j ) ;
33811: LD_VAR 0 3
33815: PPUSH
33816: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
33820: LD_ADDR_EXP 77
33824: PUSH
33825: LD_EXP 77
33829: PPUSH
33830: LD_VAR 0 4
33834: PPUSH
33835: LD_EXP 77
33839: PUSH
33840: LD_VAR 0 4
33844: ARRAY
33845: PPUSH
33846: LD_EXP 77
33850: PUSH
33851: LD_VAR 0 4
33855: ARRAY
33856: PUSH
33857: LD_INT 1
33859: MINUS
33860: PPUSH
33861: LD_EXP 77
33865: PUSH
33866: LD_VAR 0 4
33870: ARRAY
33871: PPUSH
33872: LD_INT 0
33874: PPUSH
33875: CALL 53805 0 4
33879: PPUSH
33880: CALL_OW 1
33884: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
33885: LD_ADDR_EXP 77
33889: PUSH
33890: LD_EXP 77
33894: PPUSH
33895: LD_VAR 0 4
33899: PPUSH
33900: LD_EXP 77
33904: PUSH
33905: LD_VAR 0 4
33909: ARRAY
33910: PPUSH
33911: LD_EXP 77
33915: PUSH
33916: LD_VAR 0 4
33920: ARRAY
33921: PPUSH
33922: LD_INT 1
33924: PPUSH
33925: LD_INT 0
33927: PPUSH
33928: CALL 53805 0 4
33932: PPUSH
33933: CALL_OW 1
33937: ST_TO_ADDR
// continue ;
33938: GO 33512
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
33940: LD_EXP 79
33944: PUSH
33945: LD_VAR 0 2
33949: ARRAY
33950: PUSH
33951: LD_EXP 80
33955: PUSH
33956: LD_VAR 0 2
33960: ARRAY
33961: NOT
33962: AND
33963: IFFALSE 34090
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
33965: LD_ADDR_EXP 80
33969: PUSH
33970: LD_EXP 80
33974: PPUSH
33975: LD_VAR 0 2
33979: PUSH
33980: LD_EXP 80
33984: PUSH
33985: LD_VAR 0 2
33989: ARRAY
33990: PUSH
33991: LD_INT 1
33993: PLUS
33994: PUSH
33995: EMPTY
33996: LIST
33997: LIST
33998: PPUSH
33999: LD_EXP 79
34003: PUSH
34004: LD_VAR 0 2
34008: ARRAY
34009: PUSH
34010: LD_INT 1
34012: ARRAY
34013: PPUSH
34014: CALL 54387 0 3
34018: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
34019: LD_EXP 79
34023: PUSH
34024: LD_VAR 0 2
34028: ARRAY
34029: PUSH
34030: LD_INT 1
34032: ARRAY
34033: PPUSH
34034: LD_INT 112
34036: PPUSH
34037: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
34041: LD_ADDR_VAR 0 9
34045: PUSH
34046: LD_EXP 79
34050: PUSH
34051: LD_VAR 0 2
34055: ARRAY
34056: PPUSH
34057: LD_INT 1
34059: PPUSH
34060: CALL_OW 3
34064: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
34065: LD_ADDR_EXP 79
34069: PUSH
34070: LD_EXP 79
34074: PPUSH
34075: LD_VAR 0 2
34079: PPUSH
34080: LD_VAR 0 9
34084: PPUSH
34085: CALL_OW 1
34089: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
34090: LD_EXP 79
34094: PUSH
34095: LD_VAR 0 2
34099: ARRAY
34100: PUSH
34101: LD_EXP 80
34105: PUSH
34106: LD_VAR 0 2
34110: ARRAY
34111: AND
34112: PUSH
34113: LD_EXP 80
34117: PUSH
34118: LD_VAR 0 2
34122: ARRAY
34123: PUSH
34124: LD_INT 1
34126: ARRAY
34127: PPUSH
34128: CALL_OW 310
34132: NOT
34133: AND
34134: PUSH
34135: LD_VAR 0 3
34139: PPUSH
34140: CALL_OW 313
34144: PUSH
34145: LD_INT 6
34147: EQUAL
34148: AND
34149: IFFALSE 34205
// begin tmp2 := UnitsInside ( j ) ;
34151: LD_ADDR_VAR 0 9
34155: PUSH
34156: LD_VAR 0 3
34160: PPUSH
34161: CALL_OW 313
34165: ST_TO_ADDR
// if tmp2 = 6 then
34166: LD_VAR 0 9
34170: PUSH
34171: LD_INT 6
34173: EQUAL
34174: IFFALSE 34205
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
34176: LD_VAR 0 9
34180: PUSH
34181: LD_INT 1
34183: ARRAY
34184: PPUSH
34185: LD_INT 112
34187: PPUSH
34188: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
34192: LD_VAR 0 9
34196: PUSH
34197: LD_INT 1
34199: ARRAY
34200: PPUSH
34201: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
34205: LD_EXP 80
34209: PUSH
34210: LD_VAR 0 2
34214: ARRAY
34215: PUSH
34216: LD_EXP 80
34220: PUSH
34221: LD_VAR 0 2
34225: ARRAY
34226: PUSH
34227: LD_INT 1
34229: ARRAY
34230: PPUSH
34231: CALL_OW 314
34235: NOT
34236: AND
34237: PUSH
34238: LD_EXP 80
34242: PUSH
34243: LD_VAR 0 2
34247: ARRAY
34248: PUSH
34249: LD_INT 1
34251: ARRAY
34252: PPUSH
34253: CALL_OW 310
34257: NOT
34258: AND
34259: IFFALSE 34285
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
34261: LD_EXP 80
34265: PUSH
34266: LD_VAR 0 2
34270: ARRAY
34271: PUSH
34272: LD_INT 1
34274: ARRAY
34275: PPUSH
34276: LD_VAR 0 3
34280: PPUSH
34281: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
34285: LD_EXP 80
34289: PUSH
34290: LD_VAR 0 2
34294: ARRAY
34295: PUSH
34296: LD_INT 1
34298: ARRAY
34299: PPUSH
34300: CALL_OW 310
34304: PUSH
34305: LD_EXP 80
34309: PUSH
34310: LD_VAR 0 2
34314: ARRAY
34315: PUSH
34316: LD_INT 1
34318: ARRAY
34319: PPUSH
34320: CALL_OW 310
34324: PPUSH
34325: CALL_OW 461
34329: PUSH
34330: LD_INT 3
34332: NONEQUAL
34333: AND
34334: IFFALSE 34355
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
34336: LD_EXP 80
34340: PUSH
34341: LD_VAR 0 2
34345: ARRAY
34346: PUSH
34347: LD_INT 1
34349: ARRAY
34350: PPUSH
34351: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
34355: LD_VAR 0 3
34359: PPUSH
34360: CALL_OW 461
34364: PUSH
34365: LD_INT 6
34367: EQUAL
34368: PUSH
34369: LD_VAR 0 6
34373: PUSH
34374: LD_INT 1
34376: GREATER
34377: AND
34378: IFFALSE 34530
// begin sci := [ ] ;
34380: LD_ADDR_VAR 0 8
34384: PUSH
34385: EMPTY
34386: ST_TO_ADDR
// for x in ( tmp diff j ) do
34387: LD_ADDR_VAR 0 7
34391: PUSH
34392: LD_VAR 0 6
34396: PUSH
34397: LD_VAR 0 3
34401: DIFF
34402: PUSH
34403: FOR_IN
34404: IFFALSE 34456
// begin if sci = 6 then
34406: LD_VAR 0 8
34410: PUSH
34411: LD_INT 6
34413: EQUAL
34414: IFFALSE 34418
// break ;
34416: GO 34456
// if BuildingStatus ( x ) = bs_idle then
34418: LD_VAR 0 7
34422: PPUSH
34423: CALL_OW 461
34427: PUSH
34428: LD_INT 2
34430: EQUAL
34431: IFFALSE 34454
// sci := sci ^ UnitsInside ( x ) ;
34433: LD_ADDR_VAR 0 8
34437: PUSH
34438: LD_VAR 0 8
34442: PUSH
34443: LD_VAR 0 7
34447: PPUSH
34448: CALL_OW 313
34452: ADD
34453: ST_TO_ADDR
// end ;
34454: GO 34403
34456: POP
34457: POP
// if not sci then
34458: LD_VAR 0 8
34462: NOT
34463: IFFALSE 34467
// continue ;
34465: GO 33512
// for x in sci do
34467: LD_ADDR_VAR 0 7
34471: PUSH
34472: LD_VAR 0 8
34476: PUSH
34477: FOR_IN
34478: IFFALSE 34528
// if IsInUnit ( x ) and not HasTask ( x ) then
34480: LD_VAR 0 7
34484: PPUSH
34485: CALL_OW 310
34489: PUSH
34490: LD_VAR 0 7
34494: PPUSH
34495: CALL_OW 314
34499: NOT
34500: AND
34501: IFFALSE 34526
// begin ComExitBuilding ( x ) ;
34503: LD_VAR 0 7
34507: PPUSH
34508: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
34512: LD_VAR 0 7
34516: PPUSH
34517: LD_VAR 0 3
34521: PPUSH
34522: CALL_OW 180
// end ;
34526: GO 34477
34528: POP
34529: POP
// end ; end ;
34530: GO 33512
34532: POP
34533: POP
// end ;
34534: GO 33466
34536: POP
34537: POP
// end ;
34538: LD_VAR 0 1
34542: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
34543: LD_INT 0
34545: PPUSH
34546: PPUSH
// if not mc_bases then
34547: LD_EXP 50
34551: NOT
34552: IFFALSE 34556
// exit ;
34554: GO 34637
// for i = 1 to mc_bases do
34556: LD_ADDR_VAR 0 2
34560: PUSH
34561: DOUBLE
34562: LD_INT 1
34564: DEC
34565: ST_TO_ADDR
34566: LD_EXP 50
34570: PUSH
34571: FOR_TO
34572: IFFALSE 34635
// if mc_mines [ i ] and mc_miners [ i ] then
34574: LD_EXP 63
34578: PUSH
34579: LD_VAR 0 2
34583: ARRAY
34584: PUSH
34585: LD_EXP 64
34589: PUSH
34590: LD_VAR 0 2
34594: ARRAY
34595: AND
34596: IFFALSE 34633
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
34598: LD_EXP 64
34602: PUSH
34603: LD_VAR 0 2
34607: ARRAY
34608: PUSH
34609: LD_INT 1
34611: ARRAY
34612: PPUSH
34613: CALL_OW 255
34617: PPUSH
34618: LD_EXP 63
34622: PUSH
34623: LD_VAR 0 2
34627: ARRAY
34628: PPUSH
34629: CALL 51376 0 2
34633: GO 34571
34635: POP
34636: POP
// end ;
34637: LD_VAR 0 1
34641: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
34642: LD_INT 0
34644: PPUSH
34645: PPUSH
34646: PPUSH
34647: PPUSH
34648: PPUSH
34649: PPUSH
34650: PPUSH
34651: PPUSH
// if not mc_bases or not mc_parking then
34652: LD_EXP 50
34656: NOT
34657: PUSH
34658: LD_EXP 74
34662: NOT
34663: OR
34664: IFFALSE 34668
// exit ;
34666: GO 35367
// for i = 1 to mc_bases do
34668: LD_ADDR_VAR 0 2
34672: PUSH
34673: DOUBLE
34674: LD_INT 1
34676: DEC
34677: ST_TO_ADDR
34678: LD_EXP 50
34682: PUSH
34683: FOR_TO
34684: IFFALSE 35365
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
34686: LD_EXP 50
34690: PUSH
34691: LD_VAR 0 2
34695: ARRAY
34696: NOT
34697: PUSH
34698: LD_EXP 74
34702: PUSH
34703: LD_VAR 0 2
34707: ARRAY
34708: NOT
34709: OR
34710: IFFALSE 34714
// continue ;
34712: GO 34683
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
34714: LD_ADDR_VAR 0 5
34718: PUSH
34719: LD_EXP 50
34723: PUSH
34724: LD_VAR 0 2
34728: ARRAY
34729: PUSH
34730: LD_INT 1
34732: ARRAY
34733: PPUSH
34734: CALL_OW 255
34738: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
34739: LD_ADDR_VAR 0 6
34743: PUSH
34744: LD_EXP 50
34748: PUSH
34749: LD_VAR 0 2
34753: ARRAY
34754: PPUSH
34755: LD_INT 30
34757: PUSH
34758: LD_INT 3
34760: PUSH
34761: EMPTY
34762: LIST
34763: LIST
34764: PPUSH
34765: CALL_OW 72
34769: ST_TO_ADDR
// if not fac then
34770: LD_VAR 0 6
34774: NOT
34775: IFFALSE 34826
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
34777: LD_ADDR_VAR 0 6
34781: PUSH
34782: LD_EXP 50
34786: PUSH
34787: LD_VAR 0 2
34791: ARRAY
34792: PPUSH
34793: LD_INT 2
34795: PUSH
34796: LD_INT 30
34798: PUSH
34799: LD_INT 0
34801: PUSH
34802: EMPTY
34803: LIST
34804: LIST
34805: PUSH
34806: LD_INT 30
34808: PUSH
34809: LD_INT 1
34811: PUSH
34812: EMPTY
34813: LIST
34814: LIST
34815: PUSH
34816: EMPTY
34817: LIST
34818: LIST
34819: LIST
34820: PPUSH
34821: CALL_OW 72
34825: ST_TO_ADDR
// if not fac then
34826: LD_VAR 0 6
34830: NOT
34831: IFFALSE 34835
// continue ;
34833: GO 34683
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
34835: LD_ADDR_VAR 0 7
34839: PUSH
34840: LD_EXP 74
34844: PUSH
34845: LD_VAR 0 2
34849: ARRAY
34850: PPUSH
34851: LD_INT 22
34853: PUSH
34854: LD_VAR 0 5
34858: PUSH
34859: EMPTY
34860: LIST
34861: LIST
34862: PUSH
34863: LD_INT 21
34865: PUSH
34866: LD_INT 2
34868: PUSH
34869: EMPTY
34870: LIST
34871: LIST
34872: PUSH
34873: LD_INT 3
34875: PUSH
34876: LD_INT 24
34878: PUSH
34879: LD_INT 1000
34881: PUSH
34882: EMPTY
34883: LIST
34884: LIST
34885: PUSH
34886: EMPTY
34887: LIST
34888: LIST
34889: PUSH
34890: EMPTY
34891: LIST
34892: LIST
34893: LIST
34894: PPUSH
34895: CALL_OW 70
34899: ST_TO_ADDR
// for j in fac do
34900: LD_ADDR_VAR 0 3
34904: PUSH
34905: LD_VAR 0 6
34909: PUSH
34910: FOR_IN
34911: IFFALSE 34992
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
34913: LD_ADDR_VAR 0 7
34917: PUSH
34918: LD_VAR 0 7
34922: PUSH
34923: LD_INT 22
34925: PUSH
34926: LD_VAR 0 5
34930: PUSH
34931: EMPTY
34932: LIST
34933: LIST
34934: PUSH
34935: LD_INT 91
34937: PUSH
34938: LD_VAR 0 3
34942: PUSH
34943: LD_INT 15
34945: PUSH
34946: EMPTY
34947: LIST
34948: LIST
34949: LIST
34950: PUSH
34951: LD_INT 21
34953: PUSH
34954: LD_INT 2
34956: PUSH
34957: EMPTY
34958: LIST
34959: LIST
34960: PUSH
34961: LD_INT 3
34963: PUSH
34964: LD_INT 24
34966: PUSH
34967: LD_INT 1000
34969: PUSH
34970: EMPTY
34971: LIST
34972: LIST
34973: PUSH
34974: EMPTY
34975: LIST
34976: LIST
34977: PUSH
34978: EMPTY
34979: LIST
34980: LIST
34981: LIST
34982: LIST
34983: PPUSH
34984: CALL_OW 69
34988: UNION
34989: ST_TO_ADDR
34990: GO 34910
34992: POP
34993: POP
// if not vehs then
34994: LD_VAR 0 7
34998: NOT
34999: IFFALSE 35025
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
35001: LD_ADDR_EXP 62
35005: PUSH
35006: LD_EXP 62
35010: PPUSH
35011: LD_VAR 0 2
35015: PPUSH
35016: EMPTY
35017: PPUSH
35018: CALL_OW 1
35022: ST_TO_ADDR
// continue ;
35023: GO 34683
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
35025: LD_ADDR_VAR 0 8
35029: PUSH
35030: LD_EXP 50
35034: PUSH
35035: LD_VAR 0 2
35039: ARRAY
35040: PPUSH
35041: LD_INT 30
35043: PUSH
35044: LD_INT 3
35046: PUSH
35047: EMPTY
35048: LIST
35049: LIST
35050: PPUSH
35051: CALL_OW 72
35055: ST_TO_ADDR
// if tmp then
35056: LD_VAR 0 8
35060: IFFALSE 35163
// begin for j in tmp do
35062: LD_ADDR_VAR 0 3
35066: PUSH
35067: LD_VAR 0 8
35071: PUSH
35072: FOR_IN
35073: IFFALSE 35161
// for k in UnitsInside ( j ) do
35075: LD_ADDR_VAR 0 4
35079: PUSH
35080: LD_VAR 0 3
35084: PPUSH
35085: CALL_OW 313
35089: PUSH
35090: FOR_IN
35091: IFFALSE 35157
// if k then
35093: LD_VAR 0 4
35097: IFFALSE 35155
// if not k in mc_repair_vehicle [ i ] then
35099: LD_VAR 0 4
35103: PUSH
35104: LD_EXP 62
35108: PUSH
35109: LD_VAR 0 2
35113: ARRAY
35114: IN
35115: NOT
35116: IFFALSE 35155
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
35118: LD_ADDR_EXP 62
35122: PUSH
35123: LD_EXP 62
35127: PPUSH
35128: LD_VAR 0 2
35132: PPUSH
35133: LD_EXP 62
35137: PUSH
35138: LD_VAR 0 2
35142: ARRAY
35143: PUSH
35144: LD_VAR 0 4
35148: UNION
35149: PPUSH
35150: CALL_OW 1
35154: ST_TO_ADDR
35155: GO 35090
35157: POP
35158: POP
35159: GO 35072
35161: POP
35162: POP
// end ; if not mc_repair_vehicle [ i ] then
35163: LD_EXP 62
35167: PUSH
35168: LD_VAR 0 2
35172: ARRAY
35173: NOT
35174: IFFALSE 35178
// continue ;
35176: GO 34683
// for j in mc_repair_vehicle [ i ] do
35178: LD_ADDR_VAR 0 3
35182: PUSH
35183: LD_EXP 62
35187: PUSH
35188: LD_VAR 0 2
35192: ARRAY
35193: PUSH
35194: FOR_IN
35195: IFFALSE 35361
// begin if GetClass ( j ) <> 3 then
35197: LD_VAR 0 3
35201: PPUSH
35202: CALL_OW 257
35206: PUSH
35207: LD_INT 3
35209: NONEQUAL
35210: IFFALSE 35251
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
35212: LD_ADDR_EXP 62
35216: PUSH
35217: LD_EXP 62
35221: PPUSH
35222: LD_VAR 0 2
35226: PPUSH
35227: LD_EXP 62
35231: PUSH
35232: LD_VAR 0 2
35236: ARRAY
35237: PUSH
35238: LD_VAR 0 3
35242: DIFF
35243: PPUSH
35244: CALL_OW 1
35248: ST_TO_ADDR
// continue ;
35249: GO 35194
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
35251: LD_VAR 0 3
35255: PPUSH
35256: CALL_OW 311
35260: NOT
35261: PUSH
35262: LD_VAR 0 3
35266: PUSH
35267: LD_EXP 53
35271: PUSH
35272: LD_VAR 0 2
35276: ARRAY
35277: PUSH
35278: LD_INT 1
35280: ARRAY
35281: IN
35282: NOT
35283: AND
35284: PUSH
35285: LD_VAR 0 3
35289: PUSH
35290: LD_EXP 53
35294: PUSH
35295: LD_VAR 0 2
35299: ARRAY
35300: PUSH
35301: LD_INT 2
35303: ARRAY
35304: IN
35305: NOT
35306: AND
35307: IFFALSE 35359
// begin if IsInUnit ( j ) then
35309: LD_VAR 0 3
35313: PPUSH
35314: CALL_OW 310
35318: IFFALSE 35329
// ComExitBuilding ( j ) ;
35320: LD_VAR 0 3
35324: PPUSH
35325: CALL_OW 122
// if not HasTask ( j ) then
35329: LD_VAR 0 3
35333: PPUSH
35334: CALL_OW 314
35338: NOT
35339: IFFALSE 35359
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
35341: LD_VAR 0 3
35345: PPUSH
35346: LD_VAR 0 7
35350: PUSH
35351: LD_INT 1
35353: ARRAY
35354: PPUSH
35355: CALL_OW 189
// end ; end ;
35359: GO 35194
35361: POP
35362: POP
// end ;
35363: GO 34683
35365: POP
35366: POP
// end ;
35367: LD_VAR 0 1
35371: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
35372: LD_INT 0
35374: PPUSH
35375: PPUSH
35376: PPUSH
35377: PPUSH
35378: PPUSH
35379: PPUSH
35380: PPUSH
35381: PPUSH
35382: PPUSH
35383: PPUSH
35384: PPUSH
// if not mc_bases then
35385: LD_EXP 50
35389: NOT
35390: IFFALSE 35394
// exit ;
35392: GO 36196
// for i = 1 to mc_bases do
35394: LD_ADDR_VAR 0 2
35398: PUSH
35399: DOUBLE
35400: LD_INT 1
35402: DEC
35403: ST_TO_ADDR
35404: LD_EXP 50
35408: PUSH
35409: FOR_TO
35410: IFFALSE 36194
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
35412: LD_EXP 78
35416: PUSH
35417: LD_VAR 0 2
35421: ARRAY
35422: NOT
35423: PUSH
35424: LD_EXP 53
35428: PUSH
35429: LD_VAR 0 2
35433: ARRAY
35434: PUSH
35435: LD_INT 1
35437: ARRAY
35438: OR
35439: PUSH
35440: LD_EXP 53
35444: PUSH
35445: LD_VAR 0 2
35449: ARRAY
35450: PUSH
35451: LD_INT 2
35453: ARRAY
35454: OR
35455: PUSH
35456: LD_EXP 76
35460: PUSH
35461: LD_VAR 0 2
35465: ARRAY
35466: PPUSH
35467: LD_INT 1
35469: PPUSH
35470: CALL_OW 325
35474: NOT
35475: OR
35476: PUSH
35477: LD_EXP 73
35481: PUSH
35482: LD_VAR 0 2
35486: ARRAY
35487: OR
35488: IFFALSE 35492
// continue ;
35490: GO 35409
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
35492: LD_ADDR_VAR 0 8
35496: PUSH
35497: LD_EXP 50
35501: PUSH
35502: LD_VAR 0 2
35506: ARRAY
35507: PPUSH
35508: LD_INT 25
35510: PUSH
35511: LD_INT 4
35513: PUSH
35514: EMPTY
35515: LIST
35516: LIST
35517: PUSH
35518: LD_INT 50
35520: PUSH
35521: EMPTY
35522: LIST
35523: PUSH
35524: LD_INT 3
35526: PUSH
35527: LD_INT 60
35529: PUSH
35530: EMPTY
35531: LIST
35532: PUSH
35533: EMPTY
35534: LIST
35535: LIST
35536: PUSH
35537: EMPTY
35538: LIST
35539: LIST
35540: LIST
35541: PPUSH
35542: CALL_OW 72
35546: PUSH
35547: LD_EXP 54
35551: PUSH
35552: LD_VAR 0 2
35556: ARRAY
35557: DIFF
35558: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
35559: LD_ADDR_VAR 0 9
35563: PUSH
35564: LD_EXP 50
35568: PUSH
35569: LD_VAR 0 2
35573: ARRAY
35574: PPUSH
35575: LD_INT 2
35577: PUSH
35578: LD_INT 30
35580: PUSH
35581: LD_INT 0
35583: PUSH
35584: EMPTY
35585: LIST
35586: LIST
35587: PUSH
35588: LD_INT 30
35590: PUSH
35591: LD_INT 1
35593: PUSH
35594: EMPTY
35595: LIST
35596: LIST
35597: PUSH
35598: EMPTY
35599: LIST
35600: LIST
35601: LIST
35602: PPUSH
35603: CALL_OW 72
35607: ST_TO_ADDR
// if not tmp or not dep then
35608: LD_VAR 0 8
35612: NOT
35613: PUSH
35614: LD_VAR 0 9
35618: NOT
35619: OR
35620: IFFALSE 35624
// continue ;
35622: GO 35409
// side := GetSide ( tmp [ 1 ] ) ;
35624: LD_ADDR_VAR 0 11
35628: PUSH
35629: LD_VAR 0 8
35633: PUSH
35634: LD_INT 1
35636: ARRAY
35637: PPUSH
35638: CALL_OW 255
35642: ST_TO_ADDR
// dep := dep [ 1 ] ;
35643: LD_ADDR_VAR 0 9
35647: PUSH
35648: LD_VAR 0 9
35652: PUSH
35653: LD_INT 1
35655: ARRAY
35656: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
35657: LD_ADDR_VAR 0 7
35661: PUSH
35662: LD_EXP 78
35666: PUSH
35667: LD_VAR 0 2
35671: ARRAY
35672: PPUSH
35673: LD_INT 22
35675: PUSH
35676: LD_INT 0
35678: PUSH
35679: EMPTY
35680: LIST
35681: LIST
35682: PUSH
35683: LD_INT 25
35685: PUSH
35686: LD_INT 12
35688: PUSH
35689: EMPTY
35690: LIST
35691: LIST
35692: PUSH
35693: EMPTY
35694: LIST
35695: LIST
35696: PPUSH
35697: CALL_OW 70
35701: PUSH
35702: LD_INT 22
35704: PUSH
35705: LD_INT 0
35707: PUSH
35708: EMPTY
35709: LIST
35710: LIST
35711: PUSH
35712: LD_INT 25
35714: PUSH
35715: LD_INT 12
35717: PUSH
35718: EMPTY
35719: LIST
35720: LIST
35721: PUSH
35722: LD_INT 91
35724: PUSH
35725: LD_VAR 0 9
35729: PUSH
35730: LD_INT 20
35732: PUSH
35733: EMPTY
35734: LIST
35735: LIST
35736: LIST
35737: PUSH
35738: EMPTY
35739: LIST
35740: LIST
35741: LIST
35742: PPUSH
35743: CALL_OW 69
35747: UNION
35748: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
35749: LD_ADDR_VAR 0 10
35753: PUSH
35754: LD_EXP 78
35758: PUSH
35759: LD_VAR 0 2
35763: ARRAY
35764: PPUSH
35765: LD_INT 81
35767: PUSH
35768: LD_VAR 0 11
35772: PUSH
35773: EMPTY
35774: LIST
35775: LIST
35776: PPUSH
35777: CALL_OW 70
35781: ST_TO_ADDR
// if not apes or danger_at_area then
35782: LD_VAR 0 7
35786: NOT
35787: PUSH
35788: LD_VAR 0 10
35792: OR
35793: IFFALSE 35843
// begin if mc_taming [ i ] then
35795: LD_EXP 81
35799: PUSH
35800: LD_VAR 0 2
35804: ARRAY
35805: IFFALSE 35841
// begin MC_Reset ( i , 121 ) ;
35807: LD_VAR 0 2
35811: PPUSH
35812: LD_INT 121
35814: PPUSH
35815: CALL 21174 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
35819: LD_ADDR_EXP 81
35823: PUSH
35824: LD_EXP 81
35828: PPUSH
35829: LD_VAR 0 2
35833: PPUSH
35834: EMPTY
35835: PPUSH
35836: CALL_OW 1
35840: ST_TO_ADDR
// end ; continue ;
35841: GO 35409
// end ; for j in tmp do
35843: LD_ADDR_VAR 0 3
35847: PUSH
35848: LD_VAR 0 8
35852: PUSH
35853: FOR_IN
35854: IFFALSE 36190
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
35856: LD_VAR 0 3
35860: PUSH
35861: LD_EXP 81
35865: PUSH
35866: LD_VAR 0 2
35870: ARRAY
35871: IN
35872: NOT
35873: PUSH
35874: LD_EXP 81
35878: PUSH
35879: LD_VAR 0 2
35883: ARRAY
35884: PUSH
35885: LD_INT 3
35887: LESS
35888: AND
35889: IFFALSE 35947
// begin SetTag ( j , 121 ) ;
35891: LD_VAR 0 3
35895: PPUSH
35896: LD_INT 121
35898: PPUSH
35899: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
35903: LD_ADDR_EXP 81
35907: PUSH
35908: LD_EXP 81
35912: PPUSH
35913: LD_VAR 0 2
35917: PUSH
35918: LD_EXP 81
35922: PUSH
35923: LD_VAR 0 2
35927: ARRAY
35928: PUSH
35929: LD_INT 1
35931: PLUS
35932: PUSH
35933: EMPTY
35934: LIST
35935: LIST
35936: PPUSH
35937: LD_VAR 0 3
35941: PPUSH
35942: CALL 54387 0 3
35946: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
35947: LD_VAR 0 3
35951: PUSH
35952: LD_EXP 81
35956: PUSH
35957: LD_VAR 0 2
35961: ARRAY
35962: IN
35963: IFFALSE 36188
// begin if GetClass ( j ) <> 4 then
35965: LD_VAR 0 3
35969: PPUSH
35970: CALL_OW 257
35974: PUSH
35975: LD_INT 4
35977: NONEQUAL
35978: IFFALSE 36031
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
35980: LD_ADDR_EXP 81
35984: PUSH
35985: LD_EXP 81
35989: PPUSH
35990: LD_VAR 0 2
35994: PPUSH
35995: LD_EXP 81
35999: PUSH
36000: LD_VAR 0 2
36004: ARRAY
36005: PUSH
36006: LD_VAR 0 3
36010: DIFF
36011: PPUSH
36012: CALL_OW 1
36016: ST_TO_ADDR
// SetTag ( j , 0 ) ;
36017: LD_VAR 0 3
36021: PPUSH
36022: LD_INT 0
36024: PPUSH
36025: CALL_OW 109
// continue ;
36029: GO 35853
// end ; if IsInUnit ( j ) then
36031: LD_VAR 0 3
36035: PPUSH
36036: CALL_OW 310
36040: IFFALSE 36051
// ComExitBuilding ( j ) ;
36042: LD_VAR 0 3
36046: PPUSH
36047: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
36051: LD_ADDR_VAR 0 6
36055: PUSH
36056: LD_VAR 0 7
36060: PPUSH
36061: LD_VAR 0 3
36065: PPUSH
36066: CALL_OW 74
36070: ST_TO_ADDR
// if not ape then
36071: LD_VAR 0 6
36075: NOT
36076: IFFALSE 36080
// break ;
36078: GO 36190
// x := GetX ( ape ) ;
36080: LD_ADDR_VAR 0 4
36084: PUSH
36085: LD_VAR 0 6
36089: PPUSH
36090: CALL_OW 250
36094: ST_TO_ADDR
// y := GetY ( ape ) ;
36095: LD_ADDR_VAR 0 5
36099: PUSH
36100: LD_VAR 0 6
36104: PPUSH
36105: CALL_OW 251
36109: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
36110: LD_VAR 0 4
36114: PPUSH
36115: LD_VAR 0 5
36119: PPUSH
36120: CALL_OW 488
36124: NOT
36125: PUSH
36126: LD_VAR 0 11
36130: PPUSH
36131: LD_VAR 0 4
36135: PPUSH
36136: LD_VAR 0 5
36140: PPUSH
36141: LD_INT 20
36143: PPUSH
36144: CALL 55283 0 4
36148: PUSH
36149: LD_INT 4
36151: ARRAY
36152: OR
36153: IFFALSE 36157
// break ;
36155: GO 36190
// if not HasTask ( j ) then
36157: LD_VAR 0 3
36161: PPUSH
36162: CALL_OW 314
36166: NOT
36167: IFFALSE 36188
// ComTameXY ( j , x , y ) ;
36169: LD_VAR 0 3
36173: PPUSH
36174: LD_VAR 0 4
36178: PPUSH
36179: LD_VAR 0 5
36183: PPUSH
36184: CALL_OW 131
// end ; end ;
36188: GO 35853
36190: POP
36191: POP
// end ;
36192: GO 35409
36194: POP
36195: POP
// end ;
36196: LD_VAR 0 1
36200: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
36201: LD_INT 0
36203: PPUSH
36204: PPUSH
36205: PPUSH
36206: PPUSH
36207: PPUSH
36208: PPUSH
36209: PPUSH
36210: PPUSH
// if not mc_bases then
36211: LD_EXP 50
36215: NOT
36216: IFFALSE 36220
// exit ;
36218: GO 36846
// for i = 1 to mc_bases do
36220: LD_ADDR_VAR 0 2
36224: PUSH
36225: DOUBLE
36226: LD_INT 1
36228: DEC
36229: ST_TO_ADDR
36230: LD_EXP 50
36234: PUSH
36235: FOR_TO
36236: IFFALSE 36844
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
36238: LD_EXP 79
36242: PUSH
36243: LD_VAR 0 2
36247: ARRAY
36248: NOT
36249: PUSH
36250: LD_EXP 79
36254: PUSH
36255: LD_VAR 0 2
36259: ARRAY
36260: PPUSH
36261: LD_INT 25
36263: PUSH
36264: LD_INT 12
36266: PUSH
36267: EMPTY
36268: LIST
36269: LIST
36270: PPUSH
36271: CALL_OW 72
36275: NOT
36276: OR
36277: IFFALSE 36281
// continue ;
36279: GO 36235
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
36281: LD_ADDR_VAR 0 5
36285: PUSH
36286: LD_EXP 79
36290: PUSH
36291: LD_VAR 0 2
36295: ARRAY
36296: PUSH
36297: LD_INT 1
36299: ARRAY
36300: PPUSH
36301: CALL_OW 255
36305: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
36306: LD_VAR 0 5
36310: PPUSH
36311: LD_INT 2
36313: PPUSH
36314: CALL_OW 325
36318: IFFALSE 36571
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
36320: LD_ADDR_VAR 0 4
36324: PUSH
36325: LD_EXP 79
36329: PUSH
36330: LD_VAR 0 2
36334: ARRAY
36335: PPUSH
36336: LD_INT 25
36338: PUSH
36339: LD_INT 16
36341: PUSH
36342: EMPTY
36343: LIST
36344: LIST
36345: PPUSH
36346: CALL_OW 72
36350: ST_TO_ADDR
// if tmp < 6 then
36351: LD_VAR 0 4
36355: PUSH
36356: LD_INT 6
36358: LESS
36359: IFFALSE 36571
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
36361: LD_ADDR_VAR 0 6
36365: PUSH
36366: LD_EXP 50
36370: PUSH
36371: LD_VAR 0 2
36375: ARRAY
36376: PPUSH
36377: LD_INT 2
36379: PUSH
36380: LD_INT 30
36382: PUSH
36383: LD_INT 0
36385: PUSH
36386: EMPTY
36387: LIST
36388: LIST
36389: PUSH
36390: LD_INT 30
36392: PUSH
36393: LD_INT 1
36395: PUSH
36396: EMPTY
36397: LIST
36398: LIST
36399: PUSH
36400: EMPTY
36401: LIST
36402: LIST
36403: LIST
36404: PPUSH
36405: CALL_OW 72
36409: ST_TO_ADDR
// if depot then
36410: LD_VAR 0 6
36414: IFFALSE 36571
// begin selected := 0 ;
36416: LD_ADDR_VAR 0 7
36420: PUSH
36421: LD_INT 0
36423: ST_TO_ADDR
// for j in depot do
36424: LD_ADDR_VAR 0 3
36428: PUSH
36429: LD_VAR 0 6
36433: PUSH
36434: FOR_IN
36435: IFFALSE 36466
// begin if UnitsInside ( j ) < 6 then
36437: LD_VAR 0 3
36441: PPUSH
36442: CALL_OW 313
36446: PUSH
36447: LD_INT 6
36449: LESS
36450: IFFALSE 36464
// begin selected := j ;
36452: LD_ADDR_VAR 0 7
36456: PUSH
36457: LD_VAR 0 3
36461: ST_TO_ADDR
// break ;
36462: GO 36466
// end ; end ;
36464: GO 36434
36466: POP
36467: POP
// if selected then
36468: LD_VAR 0 7
36472: IFFALSE 36571
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
36474: LD_ADDR_VAR 0 3
36478: PUSH
36479: LD_EXP 79
36483: PUSH
36484: LD_VAR 0 2
36488: ARRAY
36489: PPUSH
36490: LD_INT 25
36492: PUSH
36493: LD_INT 12
36495: PUSH
36496: EMPTY
36497: LIST
36498: LIST
36499: PPUSH
36500: CALL_OW 72
36504: PUSH
36505: FOR_IN
36506: IFFALSE 36569
// if not HasTask ( j ) then
36508: LD_VAR 0 3
36512: PPUSH
36513: CALL_OW 314
36517: NOT
36518: IFFALSE 36567
// begin if not IsInUnit ( j ) then
36520: LD_VAR 0 3
36524: PPUSH
36525: CALL_OW 310
36529: NOT
36530: IFFALSE 36546
// ComEnterUnit ( j , selected ) ;
36532: LD_VAR 0 3
36536: PPUSH
36537: LD_VAR 0 7
36541: PPUSH
36542: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
36546: LD_VAR 0 3
36550: PPUSH
36551: LD_INT 16
36553: PPUSH
36554: CALL_OW 183
// AddComExitBuilding ( j ) ;
36558: LD_VAR 0 3
36562: PPUSH
36563: CALL_OW 182
// end ;
36567: GO 36505
36569: POP
36570: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
36571: LD_VAR 0 5
36575: PPUSH
36576: LD_INT 11
36578: PPUSH
36579: CALL_OW 325
36583: IFFALSE 36842
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
36585: LD_ADDR_VAR 0 4
36589: PUSH
36590: LD_EXP 79
36594: PUSH
36595: LD_VAR 0 2
36599: ARRAY
36600: PPUSH
36601: LD_INT 25
36603: PUSH
36604: LD_INT 16
36606: PUSH
36607: EMPTY
36608: LIST
36609: LIST
36610: PPUSH
36611: CALL_OW 72
36615: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
36616: LD_VAR 0 4
36620: PUSH
36621: LD_INT 6
36623: GREATEREQUAL
36624: PUSH
36625: LD_VAR 0 5
36629: PPUSH
36630: LD_INT 2
36632: PPUSH
36633: CALL_OW 325
36637: NOT
36638: OR
36639: IFFALSE 36842
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
36641: LD_ADDR_VAR 0 8
36645: PUSH
36646: LD_EXP 50
36650: PUSH
36651: LD_VAR 0 2
36655: ARRAY
36656: PPUSH
36657: LD_INT 2
36659: PUSH
36660: LD_INT 30
36662: PUSH
36663: LD_INT 4
36665: PUSH
36666: EMPTY
36667: LIST
36668: LIST
36669: PUSH
36670: LD_INT 30
36672: PUSH
36673: LD_INT 5
36675: PUSH
36676: EMPTY
36677: LIST
36678: LIST
36679: PUSH
36680: EMPTY
36681: LIST
36682: LIST
36683: LIST
36684: PPUSH
36685: CALL_OW 72
36689: ST_TO_ADDR
// if barracks then
36690: LD_VAR 0 8
36694: IFFALSE 36842
// begin selected := 0 ;
36696: LD_ADDR_VAR 0 7
36700: PUSH
36701: LD_INT 0
36703: ST_TO_ADDR
// for j in barracks do
36704: LD_ADDR_VAR 0 3
36708: PUSH
36709: LD_VAR 0 8
36713: PUSH
36714: FOR_IN
36715: IFFALSE 36746
// begin if UnitsInside ( j ) < 6 then
36717: LD_VAR 0 3
36721: PPUSH
36722: CALL_OW 313
36726: PUSH
36727: LD_INT 6
36729: LESS
36730: IFFALSE 36744
// begin selected := j ;
36732: LD_ADDR_VAR 0 7
36736: PUSH
36737: LD_VAR 0 3
36741: ST_TO_ADDR
// break ;
36742: GO 36746
// end ; end ;
36744: GO 36714
36746: POP
36747: POP
// if selected then
36748: LD_VAR 0 7
36752: IFFALSE 36842
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
36754: LD_ADDR_VAR 0 3
36758: PUSH
36759: LD_EXP 79
36763: PUSH
36764: LD_VAR 0 2
36768: ARRAY
36769: PPUSH
36770: LD_INT 25
36772: PUSH
36773: LD_INT 12
36775: PUSH
36776: EMPTY
36777: LIST
36778: LIST
36779: PPUSH
36780: CALL_OW 72
36784: PUSH
36785: FOR_IN
36786: IFFALSE 36840
// if not IsInUnit ( j ) and not HasTask ( j ) then
36788: LD_VAR 0 3
36792: PPUSH
36793: CALL_OW 310
36797: NOT
36798: PUSH
36799: LD_VAR 0 3
36803: PPUSH
36804: CALL_OW 314
36808: NOT
36809: AND
36810: IFFALSE 36838
// begin ComEnterUnit ( j , selected ) ;
36812: LD_VAR 0 3
36816: PPUSH
36817: LD_VAR 0 7
36821: PPUSH
36822: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
36826: LD_VAR 0 3
36830: PPUSH
36831: LD_INT 15
36833: PPUSH
36834: CALL_OW 183
// end ;
36838: GO 36785
36840: POP
36841: POP
// end ; end ; end ; end ; end ;
36842: GO 36235
36844: POP
36845: POP
// end ;
36846: LD_VAR 0 1
36850: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
36851: LD_INT 0
36853: PPUSH
36854: PPUSH
36855: PPUSH
36856: PPUSH
// if not mc_bases then
36857: LD_EXP 50
36861: NOT
36862: IFFALSE 36866
// exit ;
36864: GO 37044
// for i = 1 to mc_bases do
36866: LD_ADDR_VAR 0 2
36870: PUSH
36871: DOUBLE
36872: LD_INT 1
36874: DEC
36875: ST_TO_ADDR
36876: LD_EXP 50
36880: PUSH
36881: FOR_TO
36882: IFFALSE 37042
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
36884: LD_ADDR_VAR 0 4
36888: PUSH
36889: LD_EXP 50
36893: PUSH
36894: LD_VAR 0 2
36898: ARRAY
36899: PPUSH
36900: LD_INT 25
36902: PUSH
36903: LD_INT 9
36905: PUSH
36906: EMPTY
36907: LIST
36908: LIST
36909: PPUSH
36910: CALL_OW 72
36914: ST_TO_ADDR
// if not tmp then
36915: LD_VAR 0 4
36919: NOT
36920: IFFALSE 36924
// continue ;
36922: GO 36881
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
36924: LD_EXP 76
36928: PUSH
36929: LD_VAR 0 2
36933: ARRAY
36934: PPUSH
36935: LD_INT 29
36937: PPUSH
36938: CALL_OW 325
36942: NOT
36943: PUSH
36944: LD_EXP 76
36948: PUSH
36949: LD_VAR 0 2
36953: ARRAY
36954: PPUSH
36955: LD_INT 28
36957: PPUSH
36958: CALL_OW 325
36962: NOT
36963: AND
36964: IFFALSE 36968
// continue ;
36966: GO 36881
// for j in tmp do
36968: LD_ADDR_VAR 0 3
36972: PUSH
36973: LD_VAR 0 4
36977: PUSH
36978: FOR_IN
36979: IFFALSE 37038
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
36981: LD_VAR 0 3
36985: PUSH
36986: LD_EXP 53
36990: PUSH
36991: LD_VAR 0 2
36995: ARRAY
36996: PUSH
36997: LD_INT 1
36999: ARRAY
37000: IN
37001: NOT
37002: PUSH
37003: LD_VAR 0 3
37007: PUSH
37008: LD_EXP 53
37012: PUSH
37013: LD_VAR 0 2
37017: ARRAY
37018: PUSH
37019: LD_INT 2
37021: ARRAY
37022: IN
37023: NOT
37024: AND
37025: IFFALSE 37036
// ComSpaceTimeShoot ( j ) ;
37027: LD_VAR 0 3
37031: PPUSH
37032: CALL 48062 0 1
37036: GO 36978
37038: POP
37039: POP
// end ;
37040: GO 36881
37042: POP
37043: POP
// end ;
37044: LD_VAR 0 1
37048: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
37049: LD_INT 0
37051: PPUSH
37052: PPUSH
37053: PPUSH
37054: PPUSH
37055: PPUSH
37056: PPUSH
37057: PPUSH
37058: PPUSH
37059: PPUSH
// if not mc_bases then
37060: LD_EXP 50
37064: NOT
37065: IFFALSE 37069
// exit ;
37067: GO 37691
// for i = 1 to mc_bases do
37069: LD_ADDR_VAR 0 2
37073: PUSH
37074: DOUBLE
37075: LD_INT 1
37077: DEC
37078: ST_TO_ADDR
37079: LD_EXP 50
37083: PUSH
37084: FOR_TO
37085: IFFALSE 37689
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
37087: LD_EXP 85
37091: PUSH
37092: LD_VAR 0 2
37096: ARRAY
37097: NOT
37098: PUSH
37099: LD_INT 38
37101: PPUSH
37102: LD_EXP 76
37106: PUSH
37107: LD_VAR 0 2
37111: ARRAY
37112: PPUSH
37113: CALL_OW 321
37117: PUSH
37118: LD_INT 2
37120: NONEQUAL
37121: OR
37122: IFFALSE 37126
// continue ;
37124: GO 37084
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
37126: LD_ADDR_VAR 0 8
37130: PUSH
37131: LD_EXP 50
37135: PUSH
37136: LD_VAR 0 2
37140: ARRAY
37141: PPUSH
37142: LD_INT 30
37144: PUSH
37145: LD_INT 34
37147: PUSH
37148: EMPTY
37149: LIST
37150: LIST
37151: PPUSH
37152: CALL_OW 72
37156: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
37157: LD_ADDR_VAR 0 9
37161: PUSH
37162: LD_EXP 50
37166: PUSH
37167: LD_VAR 0 2
37171: ARRAY
37172: PPUSH
37173: LD_INT 25
37175: PUSH
37176: LD_INT 4
37178: PUSH
37179: EMPTY
37180: LIST
37181: LIST
37182: PPUSH
37183: CALL_OW 72
37187: PPUSH
37188: LD_INT 0
37190: PPUSH
37191: CALL 87647 0 2
37195: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
37196: LD_VAR 0 9
37200: NOT
37201: PUSH
37202: LD_VAR 0 8
37206: NOT
37207: OR
37208: PUSH
37209: LD_EXP 50
37213: PUSH
37214: LD_VAR 0 2
37218: ARRAY
37219: PPUSH
37220: LD_INT 124
37222: PPUSH
37223: CALL 87647 0 2
37227: OR
37228: IFFALSE 37232
// continue ;
37230: GO 37084
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
37232: LD_EXP 86
37236: PUSH
37237: LD_VAR 0 2
37241: ARRAY
37242: PUSH
37243: LD_EXP 85
37247: PUSH
37248: LD_VAR 0 2
37252: ARRAY
37253: LESS
37254: PUSH
37255: LD_EXP 86
37259: PUSH
37260: LD_VAR 0 2
37264: ARRAY
37265: PUSH
37266: LD_VAR 0 8
37270: LESS
37271: AND
37272: IFFALSE 37687
// begin tmp := sci [ 1 ] ;
37274: LD_ADDR_VAR 0 7
37278: PUSH
37279: LD_VAR 0 9
37283: PUSH
37284: LD_INT 1
37286: ARRAY
37287: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
37288: LD_VAR 0 7
37292: PPUSH
37293: LD_INT 124
37295: PPUSH
37296: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
37300: LD_ADDR_VAR 0 3
37304: PUSH
37305: DOUBLE
37306: LD_EXP 85
37310: PUSH
37311: LD_VAR 0 2
37315: ARRAY
37316: INC
37317: ST_TO_ADDR
37318: LD_EXP 85
37322: PUSH
37323: LD_VAR 0 2
37327: ARRAY
37328: PUSH
37329: FOR_DOWNTO
37330: IFFALSE 37673
// begin if IsInUnit ( tmp ) then
37332: LD_VAR 0 7
37336: PPUSH
37337: CALL_OW 310
37341: IFFALSE 37352
// ComExitBuilding ( tmp ) ;
37343: LD_VAR 0 7
37347: PPUSH
37348: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
37352: LD_INT 35
37354: PPUSH
37355: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
37359: LD_VAR 0 7
37363: PPUSH
37364: CALL_OW 310
37368: NOT
37369: PUSH
37370: LD_VAR 0 7
37374: PPUSH
37375: CALL_OW 314
37379: NOT
37380: AND
37381: IFFALSE 37352
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
37383: LD_ADDR_VAR 0 6
37387: PUSH
37388: LD_VAR 0 7
37392: PPUSH
37393: CALL_OW 250
37397: PUSH
37398: LD_VAR 0 7
37402: PPUSH
37403: CALL_OW 251
37407: PUSH
37408: EMPTY
37409: LIST
37410: LIST
37411: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
37412: LD_INT 35
37414: PPUSH
37415: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
37419: LD_ADDR_VAR 0 4
37423: PUSH
37424: LD_EXP 85
37428: PUSH
37429: LD_VAR 0 2
37433: ARRAY
37434: PUSH
37435: LD_VAR 0 3
37439: ARRAY
37440: PUSH
37441: LD_INT 1
37443: ARRAY
37444: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
37445: LD_ADDR_VAR 0 5
37449: PUSH
37450: LD_EXP 85
37454: PUSH
37455: LD_VAR 0 2
37459: ARRAY
37460: PUSH
37461: LD_VAR 0 3
37465: ARRAY
37466: PUSH
37467: LD_INT 2
37469: ARRAY
37470: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
37471: LD_VAR 0 7
37475: PPUSH
37476: LD_INT 10
37478: PPUSH
37479: CALL 56980 0 2
37483: PUSH
37484: LD_INT 4
37486: ARRAY
37487: IFFALSE 37525
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
37489: LD_VAR 0 7
37493: PPUSH
37494: LD_VAR 0 6
37498: PUSH
37499: LD_INT 1
37501: ARRAY
37502: PPUSH
37503: LD_VAR 0 6
37507: PUSH
37508: LD_INT 2
37510: ARRAY
37511: PPUSH
37512: CALL_OW 111
// wait ( 0 0$10 ) ;
37516: LD_INT 350
37518: PPUSH
37519: CALL_OW 67
// end else
37523: GO 37551
// begin ComMoveXY ( tmp , x , y ) ;
37525: LD_VAR 0 7
37529: PPUSH
37530: LD_VAR 0 4
37534: PPUSH
37535: LD_VAR 0 5
37539: PPUSH
37540: CALL_OW 111
// wait ( 0 0$3 ) ;
37544: LD_INT 105
37546: PPUSH
37547: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
37551: LD_VAR 0 7
37555: PPUSH
37556: LD_VAR 0 4
37560: PPUSH
37561: LD_VAR 0 5
37565: PPUSH
37566: CALL_OW 307
37570: IFFALSE 37412
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
37572: LD_VAR 0 7
37576: PPUSH
37577: LD_VAR 0 4
37581: PPUSH
37582: LD_VAR 0 5
37586: PPUSH
37587: LD_VAR 0 8
37591: PUSH
37592: LD_VAR 0 3
37596: ARRAY
37597: PPUSH
37598: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
37602: LD_INT 35
37604: PPUSH
37605: CALL_OW 67
// until not HasTask ( tmp ) ;
37609: LD_VAR 0 7
37613: PPUSH
37614: CALL_OW 314
37618: NOT
37619: IFFALSE 37602
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
37621: LD_ADDR_EXP 86
37625: PUSH
37626: LD_EXP 86
37630: PPUSH
37631: LD_VAR 0 2
37635: PUSH
37636: LD_EXP 86
37640: PUSH
37641: LD_VAR 0 2
37645: ARRAY
37646: PUSH
37647: LD_INT 1
37649: PLUS
37650: PUSH
37651: EMPTY
37652: LIST
37653: LIST
37654: PPUSH
37655: LD_VAR 0 8
37659: PUSH
37660: LD_VAR 0 3
37664: ARRAY
37665: PPUSH
37666: CALL 54387 0 3
37670: ST_TO_ADDR
// end ;
37671: GO 37329
37673: POP
37674: POP
// MC_Reset ( i , 124 ) ;
37675: LD_VAR 0 2
37679: PPUSH
37680: LD_INT 124
37682: PPUSH
37683: CALL 21174 0 2
// end ; end ;
37687: GO 37084
37689: POP
37690: POP
// end ;
37691: LD_VAR 0 1
37695: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
37696: LD_INT 0
37698: PPUSH
37699: PPUSH
37700: PPUSH
// if not mc_bases then
37701: LD_EXP 50
37705: NOT
37706: IFFALSE 37710
// exit ;
37708: GO 38316
// for i = 1 to mc_bases do
37710: LD_ADDR_VAR 0 2
37714: PUSH
37715: DOUBLE
37716: LD_INT 1
37718: DEC
37719: ST_TO_ADDR
37720: LD_EXP 50
37724: PUSH
37725: FOR_TO
37726: IFFALSE 38314
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
37728: LD_ADDR_VAR 0 3
37732: PUSH
37733: LD_EXP 50
37737: PUSH
37738: LD_VAR 0 2
37742: ARRAY
37743: PPUSH
37744: LD_INT 25
37746: PUSH
37747: LD_INT 4
37749: PUSH
37750: EMPTY
37751: LIST
37752: LIST
37753: PPUSH
37754: CALL_OW 72
37758: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
37759: LD_VAR 0 3
37763: NOT
37764: PUSH
37765: LD_EXP 87
37769: PUSH
37770: LD_VAR 0 2
37774: ARRAY
37775: NOT
37776: OR
37777: PUSH
37778: LD_EXP 50
37782: PUSH
37783: LD_VAR 0 2
37787: ARRAY
37788: PPUSH
37789: LD_INT 2
37791: PUSH
37792: LD_INT 30
37794: PUSH
37795: LD_INT 0
37797: PUSH
37798: EMPTY
37799: LIST
37800: LIST
37801: PUSH
37802: LD_INT 30
37804: PUSH
37805: LD_INT 1
37807: PUSH
37808: EMPTY
37809: LIST
37810: LIST
37811: PUSH
37812: EMPTY
37813: LIST
37814: LIST
37815: LIST
37816: PPUSH
37817: CALL_OW 72
37821: NOT
37822: OR
37823: IFFALSE 37873
// begin if mc_deposits_finder [ i ] then
37825: LD_EXP 88
37829: PUSH
37830: LD_VAR 0 2
37834: ARRAY
37835: IFFALSE 37871
// begin MC_Reset ( i , 125 ) ;
37837: LD_VAR 0 2
37841: PPUSH
37842: LD_INT 125
37844: PPUSH
37845: CALL 21174 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
37849: LD_ADDR_EXP 88
37853: PUSH
37854: LD_EXP 88
37858: PPUSH
37859: LD_VAR 0 2
37863: PPUSH
37864: EMPTY
37865: PPUSH
37866: CALL_OW 1
37870: ST_TO_ADDR
// end ; continue ;
37871: GO 37725
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
37873: LD_EXP 87
37877: PUSH
37878: LD_VAR 0 2
37882: ARRAY
37883: PUSH
37884: LD_INT 1
37886: ARRAY
37887: PUSH
37888: LD_INT 3
37890: ARRAY
37891: PUSH
37892: LD_INT 1
37894: EQUAL
37895: PUSH
37896: LD_INT 20
37898: PPUSH
37899: LD_EXP 76
37903: PUSH
37904: LD_VAR 0 2
37908: ARRAY
37909: PPUSH
37910: CALL_OW 321
37914: PUSH
37915: LD_INT 2
37917: NONEQUAL
37918: AND
37919: IFFALSE 37969
// begin if mc_deposits_finder [ i ] then
37921: LD_EXP 88
37925: PUSH
37926: LD_VAR 0 2
37930: ARRAY
37931: IFFALSE 37967
// begin MC_Reset ( i , 125 ) ;
37933: LD_VAR 0 2
37937: PPUSH
37938: LD_INT 125
37940: PPUSH
37941: CALL 21174 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
37945: LD_ADDR_EXP 88
37949: PUSH
37950: LD_EXP 88
37954: PPUSH
37955: LD_VAR 0 2
37959: PPUSH
37960: EMPTY
37961: PPUSH
37962: CALL_OW 1
37966: ST_TO_ADDR
// end ; continue ;
37967: GO 37725
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
37969: LD_EXP 87
37973: PUSH
37974: LD_VAR 0 2
37978: ARRAY
37979: PUSH
37980: LD_INT 1
37982: ARRAY
37983: PUSH
37984: LD_INT 1
37986: ARRAY
37987: PPUSH
37988: LD_EXP 87
37992: PUSH
37993: LD_VAR 0 2
37997: ARRAY
37998: PUSH
37999: LD_INT 1
38001: ARRAY
38002: PUSH
38003: LD_INT 2
38005: ARRAY
38006: PPUSH
38007: LD_EXP 76
38011: PUSH
38012: LD_VAR 0 2
38016: ARRAY
38017: PPUSH
38018: CALL_OW 440
38022: IFFALSE 38065
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
38024: LD_ADDR_EXP 87
38028: PUSH
38029: LD_EXP 87
38033: PPUSH
38034: LD_VAR 0 2
38038: PPUSH
38039: LD_EXP 87
38043: PUSH
38044: LD_VAR 0 2
38048: ARRAY
38049: PPUSH
38050: LD_INT 1
38052: PPUSH
38053: CALL_OW 3
38057: PPUSH
38058: CALL_OW 1
38062: ST_TO_ADDR
38063: GO 38312
// begin if not mc_deposits_finder [ i ] then
38065: LD_EXP 88
38069: PUSH
38070: LD_VAR 0 2
38074: ARRAY
38075: NOT
38076: IFFALSE 38128
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
38078: LD_ADDR_EXP 88
38082: PUSH
38083: LD_EXP 88
38087: PPUSH
38088: LD_VAR 0 2
38092: PPUSH
38093: LD_VAR 0 3
38097: PUSH
38098: LD_INT 1
38100: ARRAY
38101: PUSH
38102: EMPTY
38103: LIST
38104: PPUSH
38105: CALL_OW 1
38109: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
38110: LD_VAR 0 3
38114: PUSH
38115: LD_INT 1
38117: ARRAY
38118: PPUSH
38119: LD_INT 125
38121: PPUSH
38122: CALL_OW 109
// end else
38126: GO 38312
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
38128: LD_EXP 88
38132: PUSH
38133: LD_VAR 0 2
38137: ARRAY
38138: PUSH
38139: LD_INT 1
38141: ARRAY
38142: PPUSH
38143: CALL_OW 310
38147: IFFALSE 38170
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
38149: LD_EXP 88
38153: PUSH
38154: LD_VAR 0 2
38158: ARRAY
38159: PUSH
38160: LD_INT 1
38162: ARRAY
38163: PPUSH
38164: CALL_OW 122
38168: GO 38312
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
38170: LD_EXP 88
38174: PUSH
38175: LD_VAR 0 2
38179: ARRAY
38180: PUSH
38181: LD_INT 1
38183: ARRAY
38184: PPUSH
38185: CALL_OW 314
38189: NOT
38190: PUSH
38191: LD_EXP 88
38195: PUSH
38196: LD_VAR 0 2
38200: ARRAY
38201: PUSH
38202: LD_INT 1
38204: ARRAY
38205: PPUSH
38206: LD_EXP 87
38210: PUSH
38211: LD_VAR 0 2
38215: ARRAY
38216: PUSH
38217: LD_INT 1
38219: ARRAY
38220: PUSH
38221: LD_INT 1
38223: ARRAY
38224: PPUSH
38225: LD_EXP 87
38229: PUSH
38230: LD_VAR 0 2
38234: ARRAY
38235: PUSH
38236: LD_INT 1
38238: ARRAY
38239: PUSH
38240: LD_INT 2
38242: ARRAY
38243: PPUSH
38244: CALL_OW 297
38248: PUSH
38249: LD_INT 6
38251: GREATER
38252: AND
38253: IFFALSE 38312
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
38255: LD_EXP 88
38259: PUSH
38260: LD_VAR 0 2
38264: ARRAY
38265: PUSH
38266: LD_INT 1
38268: ARRAY
38269: PPUSH
38270: LD_EXP 87
38274: PUSH
38275: LD_VAR 0 2
38279: ARRAY
38280: PUSH
38281: LD_INT 1
38283: ARRAY
38284: PUSH
38285: LD_INT 1
38287: ARRAY
38288: PPUSH
38289: LD_EXP 87
38293: PUSH
38294: LD_VAR 0 2
38298: ARRAY
38299: PUSH
38300: LD_INT 1
38302: ARRAY
38303: PUSH
38304: LD_INT 2
38306: ARRAY
38307: PPUSH
38308: CALL_OW 111
// end ; end ; end ;
38312: GO 37725
38314: POP
38315: POP
// end ;
38316: LD_VAR 0 1
38320: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
38321: LD_INT 0
38323: PPUSH
38324: PPUSH
38325: PPUSH
38326: PPUSH
38327: PPUSH
38328: PPUSH
38329: PPUSH
38330: PPUSH
38331: PPUSH
38332: PPUSH
38333: PPUSH
// if not mc_bases then
38334: LD_EXP 50
38338: NOT
38339: IFFALSE 38343
// exit ;
38341: GO 39283
// for i = 1 to mc_bases do
38343: LD_ADDR_VAR 0 2
38347: PUSH
38348: DOUBLE
38349: LD_INT 1
38351: DEC
38352: ST_TO_ADDR
38353: LD_EXP 50
38357: PUSH
38358: FOR_TO
38359: IFFALSE 39281
// begin if not mc_bases [ i ] or mc_scan [ i ] then
38361: LD_EXP 50
38365: PUSH
38366: LD_VAR 0 2
38370: ARRAY
38371: NOT
38372: PUSH
38373: LD_EXP 73
38377: PUSH
38378: LD_VAR 0 2
38382: ARRAY
38383: OR
38384: IFFALSE 38388
// continue ;
38386: GO 38358
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
38388: LD_ADDR_VAR 0 7
38392: PUSH
38393: LD_EXP 50
38397: PUSH
38398: LD_VAR 0 2
38402: ARRAY
38403: PUSH
38404: LD_INT 1
38406: ARRAY
38407: PPUSH
38408: CALL_OW 248
38412: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
38413: LD_VAR 0 7
38417: PUSH
38418: LD_INT 3
38420: EQUAL
38421: PUSH
38422: LD_EXP 69
38426: PUSH
38427: LD_VAR 0 2
38431: ARRAY
38432: PUSH
38433: LD_EXP 72
38437: PUSH
38438: LD_VAR 0 2
38442: ARRAY
38443: UNION
38444: PPUSH
38445: LD_INT 33
38447: PUSH
38448: LD_INT 2
38450: PUSH
38451: EMPTY
38452: LIST
38453: LIST
38454: PPUSH
38455: CALL_OW 72
38459: NOT
38460: OR
38461: IFFALSE 38465
// continue ;
38463: GO 38358
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
38465: LD_ADDR_VAR 0 9
38469: PUSH
38470: LD_EXP 50
38474: PUSH
38475: LD_VAR 0 2
38479: ARRAY
38480: PPUSH
38481: LD_INT 30
38483: PUSH
38484: LD_INT 36
38486: PUSH
38487: EMPTY
38488: LIST
38489: LIST
38490: PPUSH
38491: CALL_OW 72
38495: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
38496: LD_ADDR_VAR 0 10
38500: PUSH
38501: LD_EXP 69
38505: PUSH
38506: LD_VAR 0 2
38510: ARRAY
38511: PPUSH
38512: LD_INT 34
38514: PUSH
38515: LD_INT 31
38517: PUSH
38518: EMPTY
38519: LIST
38520: LIST
38521: PPUSH
38522: CALL_OW 72
38526: ST_TO_ADDR
// if not cts and not mcts then
38527: LD_VAR 0 9
38531: NOT
38532: PUSH
38533: LD_VAR 0 10
38537: NOT
38538: AND
38539: IFFALSE 38543
// continue ;
38541: GO 38358
// x := cts ;
38543: LD_ADDR_VAR 0 11
38547: PUSH
38548: LD_VAR 0 9
38552: ST_TO_ADDR
// if not x then
38553: LD_VAR 0 11
38557: NOT
38558: IFFALSE 38570
// x := mcts ;
38560: LD_ADDR_VAR 0 11
38564: PUSH
38565: LD_VAR 0 10
38569: ST_TO_ADDR
// if not x then
38570: LD_VAR 0 11
38574: NOT
38575: IFFALSE 38579
// continue ;
38577: GO 38358
// if mc_remote_driver [ i ] then
38579: LD_EXP 90
38583: PUSH
38584: LD_VAR 0 2
38588: ARRAY
38589: IFFALSE 38976
// for j in mc_remote_driver [ i ] do
38591: LD_ADDR_VAR 0 3
38595: PUSH
38596: LD_EXP 90
38600: PUSH
38601: LD_VAR 0 2
38605: ARRAY
38606: PUSH
38607: FOR_IN
38608: IFFALSE 38974
// begin if GetClass ( j ) <> 3 then
38610: LD_VAR 0 3
38614: PPUSH
38615: CALL_OW 257
38619: PUSH
38620: LD_INT 3
38622: NONEQUAL
38623: IFFALSE 38676
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
38625: LD_ADDR_EXP 90
38629: PUSH
38630: LD_EXP 90
38634: PPUSH
38635: LD_VAR 0 2
38639: PPUSH
38640: LD_EXP 90
38644: PUSH
38645: LD_VAR 0 2
38649: ARRAY
38650: PUSH
38651: LD_VAR 0 3
38655: DIFF
38656: PPUSH
38657: CALL_OW 1
38661: ST_TO_ADDR
// SetTag ( j , 0 ) ;
38662: LD_VAR 0 3
38666: PPUSH
38667: LD_INT 0
38669: PPUSH
38670: CALL_OW 109
// continue ;
38674: GO 38607
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
38676: LD_EXP 69
38680: PUSH
38681: LD_VAR 0 2
38685: ARRAY
38686: PPUSH
38687: LD_INT 34
38689: PUSH
38690: LD_INT 31
38692: PUSH
38693: EMPTY
38694: LIST
38695: LIST
38696: PUSH
38697: LD_INT 58
38699: PUSH
38700: EMPTY
38701: LIST
38702: PUSH
38703: EMPTY
38704: LIST
38705: LIST
38706: PPUSH
38707: CALL_OW 72
38711: PUSH
38712: LD_VAR 0 3
38716: PPUSH
38717: CALL 87735 0 1
38721: NOT
38722: AND
38723: IFFALSE 38794
// begin if IsInUnit ( j ) then
38725: LD_VAR 0 3
38729: PPUSH
38730: CALL_OW 310
38734: IFFALSE 38745
// ComExitBuilding ( j ) ;
38736: LD_VAR 0 3
38740: PPUSH
38741: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
38745: LD_VAR 0 3
38749: PPUSH
38750: LD_EXP 69
38754: PUSH
38755: LD_VAR 0 2
38759: ARRAY
38760: PPUSH
38761: LD_INT 34
38763: PUSH
38764: LD_INT 31
38766: PUSH
38767: EMPTY
38768: LIST
38769: LIST
38770: PUSH
38771: LD_INT 58
38773: PUSH
38774: EMPTY
38775: LIST
38776: PUSH
38777: EMPTY
38778: LIST
38779: LIST
38780: PPUSH
38781: CALL_OW 72
38785: PUSH
38786: LD_INT 1
38788: ARRAY
38789: PPUSH
38790: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
38794: LD_VAR 0 3
38798: PPUSH
38799: CALL_OW 310
38803: NOT
38804: PUSH
38805: LD_VAR 0 3
38809: PPUSH
38810: CALL_OW 310
38814: PPUSH
38815: CALL_OW 266
38819: PUSH
38820: LD_INT 36
38822: NONEQUAL
38823: PUSH
38824: LD_VAR 0 3
38828: PPUSH
38829: CALL 87735 0 1
38833: NOT
38834: AND
38835: OR
38836: IFFALSE 38972
// begin if IsInUnit ( j ) then
38838: LD_VAR 0 3
38842: PPUSH
38843: CALL_OW 310
38847: IFFALSE 38858
// ComExitBuilding ( j ) ;
38849: LD_VAR 0 3
38853: PPUSH
38854: CALL_OW 122
// ct := 0 ;
38858: LD_ADDR_VAR 0 8
38862: PUSH
38863: LD_INT 0
38865: ST_TO_ADDR
// for k in x do
38866: LD_ADDR_VAR 0 4
38870: PUSH
38871: LD_VAR 0 11
38875: PUSH
38876: FOR_IN
38877: IFFALSE 38950
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
38879: LD_VAR 0 4
38883: PPUSH
38884: CALL_OW 264
38888: PUSH
38889: LD_INT 31
38891: EQUAL
38892: PUSH
38893: LD_VAR 0 4
38897: PPUSH
38898: CALL_OW 311
38902: NOT
38903: AND
38904: PUSH
38905: LD_VAR 0 4
38909: PPUSH
38910: CALL_OW 266
38914: PUSH
38915: LD_INT 36
38917: EQUAL
38918: PUSH
38919: LD_VAR 0 4
38923: PPUSH
38924: CALL_OW 313
38928: PUSH
38929: LD_INT 3
38931: LESS
38932: AND
38933: OR
38934: IFFALSE 38948
// begin ct := k ;
38936: LD_ADDR_VAR 0 8
38940: PUSH
38941: LD_VAR 0 4
38945: ST_TO_ADDR
// break ;
38946: GO 38950
// end ;
38948: GO 38876
38950: POP
38951: POP
// if ct then
38952: LD_VAR 0 8
38956: IFFALSE 38972
// ComEnterUnit ( j , ct ) ;
38958: LD_VAR 0 3
38962: PPUSH
38963: LD_VAR 0 8
38967: PPUSH
38968: CALL_OW 120
// end ; end ;
38972: GO 38607
38974: POP
38975: POP
// places := 0 ;
38976: LD_ADDR_VAR 0 5
38980: PUSH
38981: LD_INT 0
38983: ST_TO_ADDR
// for j = 1 to x do
38984: LD_ADDR_VAR 0 3
38988: PUSH
38989: DOUBLE
38990: LD_INT 1
38992: DEC
38993: ST_TO_ADDR
38994: LD_VAR 0 11
38998: PUSH
38999: FOR_TO
39000: IFFALSE 39076
// if GetWeapon ( x [ j ] ) = ar_control_tower then
39002: LD_VAR 0 11
39006: PUSH
39007: LD_VAR 0 3
39011: ARRAY
39012: PPUSH
39013: CALL_OW 264
39017: PUSH
39018: LD_INT 31
39020: EQUAL
39021: IFFALSE 39039
// places := places + 1 else
39023: LD_ADDR_VAR 0 5
39027: PUSH
39028: LD_VAR 0 5
39032: PUSH
39033: LD_INT 1
39035: PLUS
39036: ST_TO_ADDR
39037: GO 39074
// if GetBType ( x [ j ] ) = b_control_tower then
39039: LD_VAR 0 11
39043: PUSH
39044: LD_VAR 0 3
39048: ARRAY
39049: PPUSH
39050: CALL_OW 266
39054: PUSH
39055: LD_INT 36
39057: EQUAL
39058: IFFALSE 39074
// places := places + 3 ;
39060: LD_ADDR_VAR 0 5
39064: PUSH
39065: LD_VAR 0 5
39069: PUSH
39070: LD_INT 3
39072: PLUS
39073: ST_TO_ADDR
39074: GO 38999
39076: POP
39077: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
39078: LD_VAR 0 5
39082: PUSH
39083: LD_INT 0
39085: EQUAL
39086: PUSH
39087: LD_VAR 0 5
39091: PUSH
39092: LD_EXP 90
39096: PUSH
39097: LD_VAR 0 2
39101: ARRAY
39102: LESSEQUAL
39103: OR
39104: IFFALSE 39108
// continue ;
39106: GO 38358
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
39108: LD_ADDR_VAR 0 6
39112: PUSH
39113: LD_EXP 50
39117: PUSH
39118: LD_VAR 0 2
39122: ARRAY
39123: PPUSH
39124: LD_INT 25
39126: PUSH
39127: LD_INT 3
39129: PUSH
39130: EMPTY
39131: LIST
39132: LIST
39133: PPUSH
39134: CALL_OW 72
39138: PUSH
39139: LD_EXP 90
39143: PUSH
39144: LD_VAR 0 2
39148: ARRAY
39149: DIFF
39150: PPUSH
39151: LD_INT 3
39153: PPUSH
39154: CALL 88635 0 2
39158: ST_TO_ADDR
// for j in tmp do
39159: LD_ADDR_VAR 0 3
39163: PUSH
39164: LD_VAR 0 6
39168: PUSH
39169: FOR_IN
39170: IFFALSE 39205
// if GetTag ( j ) > 0 then
39172: LD_VAR 0 3
39176: PPUSH
39177: CALL_OW 110
39181: PUSH
39182: LD_INT 0
39184: GREATER
39185: IFFALSE 39203
// tmp := tmp diff j ;
39187: LD_ADDR_VAR 0 6
39191: PUSH
39192: LD_VAR 0 6
39196: PUSH
39197: LD_VAR 0 3
39201: DIFF
39202: ST_TO_ADDR
39203: GO 39169
39205: POP
39206: POP
// if not tmp then
39207: LD_VAR 0 6
39211: NOT
39212: IFFALSE 39216
// continue ;
39214: GO 38358
// if places then
39216: LD_VAR 0 5
39220: IFFALSE 39279
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
39222: LD_ADDR_EXP 90
39226: PUSH
39227: LD_EXP 90
39231: PPUSH
39232: LD_VAR 0 2
39236: PPUSH
39237: LD_EXP 90
39241: PUSH
39242: LD_VAR 0 2
39246: ARRAY
39247: PUSH
39248: LD_VAR 0 6
39252: PUSH
39253: LD_INT 1
39255: ARRAY
39256: UNION
39257: PPUSH
39258: CALL_OW 1
39262: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
39263: LD_VAR 0 6
39267: PUSH
39268: LD_INT 1
39270: ARRAY
39271: PPUSH
39272: LD_INT 126
39274: PPUSH
39275: CALL_OW 109
// end ; end ;
39279: GO 38358
39281: POP
39282: POP
// end ;
39283: LD_VAR 0 1
39287: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
39288: LD_INT 0
39290: PPUSH
39291: PPUSH
39292: PPUSH
39293: PPUSH
39294: PPUSH
39295: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
39296: LD_VAR 0 1
39300: NOT
39301: PUSH
39302: LD_VAR 0 2
39306: NOT
39307: OR
39308: PUSH
39309: LD_VAR 0 3
39313: NOT
39314: OR
39315: PUSH
39316: LD_VAR 0 4
39320: PUSH
39321: LD_INT 1
39323: PUSH
39324: LD_INT 2
39326: PUSH
39327: LD_INT 3
39329: PUSH
39330: LD_INT 4
39332: PUSH
39333: LD_INT 5
39335: PUSH
39336: LD_INT 8
39338: PUSH
39339: LD_INT 9
39341: PUSH
39342: LD_INT 15
39344: PUSH
39345: LD_INT 16
39347: PUSH
39348: EMPTY
39349: LIST
39350: LIST
39351: LIST
39352: LIST
39353: LIST
39354: LIST
39355: LIST
39356: LIST
39357: LIST
39358: IN
39359: NOT
39360: OR
39361: IFFALSE 39365
// exit ;
39363: GO 40265
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
39365: LD_ADDR_VAR 0 2
39369: PUSH
39370: LD_VAR 0 2
39374: PPUSH
39375: LD_INT 21
39377: PUSH
39378: LD_INT 3
39380: PUSH
39381: EMPTY
39382: LIST
39383: LIST
39384: PUSH
39385: LD_INT 24
39387: PUSH
39388: LD_INT 250
39390: PUSH
39391: EMPTY
39392: LIST
39393: LIST
39394: PUSH
39395: EMPTY
39396: LIST
39397: LIST
39398: PPUSH
39399: CALL_OW 72
39403: ST_TO_ADDR
// case class of 1 , 15 :
39404: LD_VAR 0 4
39408: PUSH
39409: LD_INT 1
39411: DOUBLE
39412: EQUAL
39413: IFTRUE 39423
39415: LD_INT 15
39417: DOUBLE
39418: EQUAL
39419: IFTRUE 39423
39421: GO 39508
39423: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
39424: LD_ADDR_VAR 0 8
39428: PUSH
39429: LD_VAR 0 2
39433: PPUSH
39434: LD_INT 2
39436: PUSH
39437: LD_INT 30
39439: PUSH
39440: LD_INT 32
39442: PUSH
39443: EMPTY
39444: LIST
39445: LIST
39446: PUSH
39447: LD_INT 30
39449: PUSH
39450: LD_INT 31
39452: PUSH
39453: EMPTY
39454: LIST
39455: LIST
39456: PUSH
39457: EMPTY
39458: LIST
39459: LIST
39460: LIST
39461: PPUSH
39462: CALL_OW 72
39466: PUSH
39467: LD_VAR 0 2
39471: PPUSH
39472: LD_INT 2
39474: PUSH
39475: LD_INT 30
39477: PUSH
39478: LD_INT 4
39480: PUSH
39481: EMPTY
39482: LIST
39483: LIST
39484: PUSH
39485: LD_INT 30
39487: PUSH
39488: LD_INT 5
39490: PUSH
39491: EMPTY
39492: LIST
39493: LIST
39494: PUSH
39495: EMPTY
39496: LIST
39497: LIST
39498: LIST
39499: PPUSH
39500: CALL_OW 72
39504: ADD
39505: ST_TO_ADDR
39506: GO 39754
39508: LD_INT 2
39510: DOUBLE
39511: EQUAL
39512: IFTRUE 39522
39514: LD_INT 16
39516: DOUBLE
39517: EQUAL
39518: IFTRUE 39522
39520: GO 39568
39522: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
39523: LD_ADDR_VAR 0 8
39527: PUSH
39528: LD_VAR 0 2
39532: PPUSH
39533: LD_INT 2
39535: PUSH
39536: LD_INT 30
39538: PUSH
39539: LD_INT 0
39541: PUSH
39542: EMPTY
39543: LIST
39544: LIST
39545: PUSH
39546: LD_INT 30
39548: PUSH
39549: LD_INT 1
39551: PUSH
39552: EMPTY
39553: LIST
39554: LIST
39555: PUSH
39556: EMPTY
39557: LIST
39558: LIST
39559: LIST
39560: PPUSH
39561: CALL_OW 72
39565: ST_TO_ADDR
39566: GO 39754
39568: LD_INT 3
39570: DOUBLE
39571: EQUAL
39572: IFTRUE 39576
39574: GO 39622
39576: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
39577: LD_ADDR_VAR 0 8
39581: PUSH
39582: LD_VAR 0 2
39586: PPUSH
39587: LD_INT 2
39589: PUSH
39590: LD_INT 30
39592: PUSH
39593: LD_INT 2
39595: PUSH
39596: EMPTY
39597: LIST
39598: LIST
39599: PUSH
39600: LD_INT 30
39602: PUSH
39603: LD_INT 3
39605: PUSH
39606: EMPTY
39607: LIST
39608: LIST
39609: PUSH
39610: EMPTY
39611: LIST
39612: LIST
39613: LIST
39614: PPUSH
39615: CALL_OW 72
39619: ST_TO_ADDR
39620: GO 39754
39622: LD_INT 4
39624: DOUBLE
39625: EQUAL
39626: IFTRUE 39630
39628: GO 39687
39630: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
39631: LD_ADDR_VAR 0 8
39635: PUSH
39636: LD_VAR 0 2
39640: PPUSH
39641: LD_INT 2
39643: PUSH
39644: LD_INT 30
39646: PUSH
39647: LD_INT 6
39649: PUSH
39650: EMPTY
39651: LIST
39652: LIST
39653: PUSH
39654: LD_INT 30
39656: PUSH
39657: LD_INT 7
39659: PUSH
39660: EMPTY
39661: LIST
39662: LIST
39663: PUSH
39664: LD_INT 30
39666: PUSH
39667: LD_INT 8
39669: PUSH
39670: EMPTY
39671: LIST
39672: LIST
39673: PUSH
39674: EMPTY
39675: LIST
39676: LIST
39677: LIST
39678: LIST
39679: PPUSH
39680: CALL_OW 72
39684: ST_TO_ADDR
39685: GO 39754
39687: LD_INT 5
39689: DOUBLE
39690: EQUAL
39691: IFTRUE 39707
39693: LD_INT 8
39695: DOUBLE
39696: EQUAL
39697: IFTRUE 39707
39699: LD_INT 9
39701: DOUBLE
39702: EQUAL
39703: IFTRUE 39707
39705: GO 39753
39707: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
39708: LD_ADDR_VAR 0 8
39712: PUSH
39713: LD_VAR 0 2
39717: PPUSH
39718: LD_INT 2
39720: PUSH
39721: LD_INT 30
39723: PUSH
39724: LD_INT 4
39726: PUSH
39727: EMPTY
39728: LIST
39729: LIST
39730: PUSH
39731: LD_INT 30
39733: PUSH
39734: LD_INT 5
39736: PUSH
39737: EMPTY
39738: LIST
39739: LIST
39740: PUSH
39741: EMPTY
39742: LIST
39743: LIST
39744: LIST
39745: PPUSH
39746: CALL_OW 72
39750: ST_TO_ADDR
39751: GO 39754
39753: POP
// if not tmp then
39754: LD_VAR 0 8
39758: NOT
39759: IFFALSE 39763
// exit ;
39761: GO 40265
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
39763: LD_VAR 0 4
39767: PUSH
39768: LD_INT 1
39770: PUSH
39771: LD_INT 15
39773: PUSH
39774: EMPTY
39775: LIST
39776: LIST
39777: IN
39778: PUSH
39779: LD_EXP 59
39783: PUSH
39784: LD_VAR 0 1
39788: ARRAY
39789: AND
39790: IFFALSE 39946
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
39792: LD_ADDR_VAR 0 9
39796: PUSH
39797: LD_EXP 59
39801: PUSH
39802: LD_VAR 0 1
39806: ARRAY
39807: PUSH
39808: LD_INT 1
39810: ARRAY
39811: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
39812: LD_VAR 0 9
39816: PUSH
39817: LD_EXP 60
39821: PUSH
39822: LD_VAR 0 1
39826: ARRAY
39827: IN
39828: NOT
39829: IFFALSE 39944
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
39831: LD_ADDR_EXP 60
39835: PUSH
39836: LD_EXP 60
39840: PPUSH
39841: LD_VAR 0 1
39845: PUSH
39846: LD_EXP 60
39850: PUSH
39851: LD_VAR 0 1
39855: ARRAY
39856: PUSH
39857: LD_INT 1
39859: PLUS
39860: PUSH
39861: EMPTY
39862: LIST
39863: LIST
39864: PPUSH
39865: LD_VAR 0 9
39869: PPUSH
39870: CALL 54387 0 3
39874: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
39875: LD_ADDR_EXP 59
39879: PUSH
39880: LD_EXP 59
39884: PPUSH
39885: LD_VAR 0 1
39889: PPUSH
39890: LD_EXP 59
39894: PUSH
39895: LD_VAR 0 1
39899: ARRAY
39900: PUSH
39901: LD_VAR 0 9
39905: DIFF
39906: PPUSH
39907: CALL_OW 1
39911: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
39912: LD_VAR 0 3
39916: PPUSH
39917: LD_EXP 60
39921: PUSH
39922: LD_VAR 0 1
39926: ARRAY
39927: PUSH
39928: LD_EXP 60
39932: PUSH
39933: LD_VAR 0 1
39937: ARRAY
39938: ARRAY
39939: PPUSH
39940: CALL_OW 120
// end ; exit ;
39944: GO 40265
// end ; if tmp > 1 then
39946: LD_VAR 0 8
39950: PUSH
39951: LD_INT 1
39953: GREATER
39954: IFFALSE 40058
// for i = 2 to tmp do
39956: LD_ADDR_VAR 0 6
39960: PUSH
39961: DOUBLE
39962: LD_INT 2
39964: DEC
39965: ST_TO_ADDR
39966: LD_VAR 0 8
39970: PUSH
39971: FOR_TO
39972: IFFALSE 40056
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
39974: LD_VAR 0 8
39978: PUSH
39979: LD_VAR 0 6
39983: ARRAY
39984: PPUSH
39985: CALL_OW 461
39989: PUSH
39990: LD_INT 6
39992: EQUAL
39993: IFFALSE 40054
// begin x := tmp [ i ] ;
39995: LD_ADDR_VAR 0 9
39999: PUSH
40000: LD_VAR 0 8
40004: PUSH
40005: LD_VAR 0 6
40009: ARRAY
40010: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
40011: LD_ADDR_VAR 0 8
40015: PUSH
40016: LD_VAR 0 8
40020: PPUSH
40021: LD_VAR 0 6
40025: PPUSH
40026: CALL_OW 3
40030: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
40031: LD_ADDR_VAR 0 8
40035: PUSH
40036: LD_VAR 0 8
40040: PPUSH
40041: LD_INT 1
40043: PPUSH
40044: LD_VAR 0 9
40048: PPUSH
40049: CALL_OW 2
40053: ST_TO_ADDR
// end ;
40054: GO 39971
40056: POP
40057: POP
// for i in tmp do
40058: LD_ADDR_VAR 0 6
40062: PUSH
40063: LD_VAR 0 8
40067: PUSH
40068: FOR_IN
40069: IFFALSE 40138
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
40071: LD_VAR 0 6
40075: PPUSH
40076: CALL_OW 313
40080: PUSH
40081: LD_INT 6
40083: LESS
40084: PUSH
40085: LD_VAR 0 6
40089: PPUSH
40090: CALL_OW 266
40094: PUSH
40095: LD_INT 31
40097: PUSH
40098: LD_INT 32
40100: PUSH
40101: EMPTY
40102: LIST
40103: LIST
40104: IN
40105: NOT
40106: AND
40107: PUSH
40108: LD_VAR 0 6
40112: PPUSH
40113: CALL_OW 313
40117: PUSH
40118: LD_INT 0
40120: EQUAL
40121: OR
40122: IFFALSE 40136
// begin j := i ;
40124: LD_ADDR_VAR 0 7
40128: PUSH
40129: LD_VAR 0 6
40133: ST_TO_ADDR
// break ;
40134: GO 40138
// end ; end ;
40136: GO 40068
40138: POP
40139: POP
// if j then
40140: LD_VAR 0 7
40144: IFFALSE 40162
// ComEnterUnit ( unit , j ) else
40146: LD_VAR 0 3
40150: PPUSH
40151: LD_VAR 0 7
40155: PPUSH
40156: CALL_OW 120
40160: GO 40265
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
40162: LD_ADDR_VAR 0 10
40166: PUSH
40167: LD_VAR 0 2
40171: PPUSH
40172: LD_INT 2
40174: PUSH
40175: LD_INT 30
40177: PUSH
40178: LD_INT 0
40180: PUSH
40181: EMPTY
40182: LIST
40183: LIST
40184: PUSH
40185: LD_INT 30
40187: PUSH
40188: LD_INT 1
40190: PUSH
40191: EMPTY
40192: LIST
40193: LIST
40194: PUSH
40195: EMPTY
40196: LIST
40197: LIST
40198: LIST
40199: PPUSH
40200: CALL_OW 72
40204: ST_TO_ADDR
// if depot then
40205: LD_VAR 0 10
40209: IFFALSE 40265
// begin depot := NearestUnitToUnit ( depot , unit ) ;
40211: LD_ADDR_VAR 0 10
40215: PUSH
40216: LD_VAR 0 10
40220: PPUSH
40221: LD_VAR 0 3
40225: PPUSH
40226: CALL_OW 74
40230: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
40231: LD_VAR 0 3
40235: PPUSH
40236: LD_VAR 0 10
40240: PPUSH
40241: CALL_OW 296
40245: PUSH
40246: LD_INT 10
40248: GREATER
40249: IFFALSE 40265
// ComStandNearbyBuilding ( unit , depot ) ;
40251: LD_VAR 0 3
40255: PPUSH
40256: LD_VAR 0 10
40260: PPUSH
40261: CALL 48679 0 2
// end ; end ; end ;
40265: LD_VAR 0 5
40269: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
40270: LD_INT 0
40272: PPUSH
40273: PPUSH
40274: PPUSH
40275: PPUSH
// if not mc_bases then
40276: LD_EXP 50
40280: NOT
40281: IFFALSE 40285
// exit ;
40283: GO 40524
// for i = 1 to mc_bases do
40285: LD_ADDR_VAR 0 2
40289: PUSH
40290: DOUBLE
40291: LD_INT 1
40293: DEC
40294: ST_TO_ADDR
40295: LD_EXP 50
40299: PUSH
40300: FOR_TO
40301: IFFALSE 40522
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
40303: LD_ADDR_VAR 0 4
40307: PUSH
40308: LD_EXP 50
40312: PUSH
40313: LD_VAR 0 2
40317: ARRAY
40318: PPUSH
40319: LD_INT 21
40321: PUSH
40322: LD_INT 1
40324: PUSH
40325: EMPTY
40326: LIST
40327: LIST
40328: PPUSH
40329: CALL_OW 72
40333: PUSH
40334: LD_EXP 79
40338: PUSH
40339: LD_VAR 0 2
40343: ARRAY
40344: UNION
40345: ST_TO_ADDR
// if not tmp then
40346: LD_VAR 0 4
40350: NOT
40351: IFFALSE 40355
// continue ;
40353: GO 40300
// for j in tmp do
40355: LD_ADDR_VAR 0 3
40359: PUSH
40360: LD_VAR 0 4
40364: PUSH
40365: FOR_IN
40366: IFFALSE 40518
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
40368: LD_VAR 0 3
40372: PPUSH
40373: CALL_OW 110
40377: NOT
40378: PUSH
40379: LD_VAR 0 3
40383: PPUSH
40384: CALL_OW 314
40388: NOT
40389: AND
40390: PUSH
40391: LD_VAR 0 3
40395: PPUSH
40396: CALL_OW 311
40400: NOT
40401: AND
40402: PUSH
40403: LD_VAR 0 3
40407: PPUSH
40408: CALL_OW 310
40412: NOT
40413: AND
40414: PUSH
40415: LD_VAR 0 3
40419: PUSH
40420: LD_EXP 53
40424: PUSH
40425: LD_VAR 0 2
40429: ARRAY
40430: PUSH
40431: LD_INT 1
40433: ARRAY
40434: IN
40435: NOT
40436: AND
40437: PUSH
40438: LD_VAR 0 3
40442: PUSH
40443: LD_EXP 53
40447: PUSH
40448: LD_VAR 0 2
40452: ARRAY
40453: PUSH
40454: LD_INT 2
40456: ARRAY
40457: IN
40458: NOT
40459: AND
40460: PUSH
40461: LD_VAR 0 3
40465: PUSH
40466: LD_EXP 62
40470: PUSH
40471: LD_VAR 0 2
40475: ARRAY
40476: IN
40477: NOT
40478: AND
40479: IFFALSE 40516
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
40481: LD_VAR 0 2
40485: PPUSH
40486: LD_EXP 50
40490: PUSH
40491: LD_VAR 0 2
40495: ARRAY
40496: PPUSH
40497: LD_VAR 0 3
40501: PPUSH
40502: LD_VAR 0 3
40506: PPUSH
40507: CALL_OW 257
40511: PPUSH
40512: CALL 39288 0 4
// end ;
40516: GO 40365
40518: POP
40519: POP
// end ;
40520: GO 40300
40522: POP
40523: POP
// end ;
40524: LD_VAR 0 1
40528: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
40529: LD_INT 0
40531: PPUSH
40532: PPUSH
40533: PPUSH
40534: PPUSH
40535: PPUSH
40536: PPUSH
// if not mc_bases [ base ] then
40537: LD_EXP 50
40541: PUSH
40542: LD_VAR 0 1
40546: ARRAY
40547: NOT
40548: IFFALSE 40552
// exit ;
40550: GO 40734
// tmp := [ ] ;
40552: LD_ADDR_VAR 0 6
40556: PUSH
40557: EMPTY
40558: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
40559: LD_ADDR_VAR 0 7
40563: PUSH
40564: LD_VAR 0 3
40568: PPUSH
40569: LD_INT 0
40571: PPUSH
40572: CALL_OW 517
40576: ST_TO_ADDR
// if not list then
40577: LD_VAR 0 7
40581: NOT
40582: IFFALSE 40586
// exit ;
40584: GO 40734
// for i = 1 to amount do
40586: LD_ADDR_VAR 0 5
40590: PUSH
40591: DOUBLE
40592: LD_INT 1
40594: DEC
40595: ST_TO_ADDR
40596: LD_VAR 0 2
40600: PUSH
40601: FOR_TO
40602: IFFALSE 40682
// begin x := rand ( 1 , list [ 1 ] ) ;
40604: LD_ADDR_VAR 0 8
40608: PUSH
40609: LD_INT 1
40611: PPUSH
40612: LD_VAR 0 7
40616: PUSH
40617: LD_INT 1
40619: ARRAY
40620: PPUSH
40621: CALL_OW 12
40625: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
40626: LD_ADDR_VAR 0 6
40630: PUSH
40631: LD_VAR 0 6
40635: PPUSH
40636: LD_VAR 0 5
40640: PPUSH
40641: LD_VAR 0 7
40645: PUSH
40646: LD_INT 1
40648: ARRAY
40649: PUSH
40650: LD_VAR 0 8
40654: ARRAY
40655: PUSH
40656: LD_VAR 0 7
40660: PUSH
40661: LD_INT 2
40663: ARRAY
40664: PUSH
40665: LD_VAR 0 8
40669: ARRAY
40670: PUSH
40671: EMPTY
40672: LIST
40673: LIST
40674: PPUSH
40675: CALL_OW 1
40679: ST_TO_ADDR
// end ;
40680: GO 40601
40682: POP
40683: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
40684: LD_ADDR_EXP 63
40688: PUSH
40689: LD_EXP 63
40693: PPUSH
40694: LD_VAR 0 1
40698: PPUSH
40699: LD_VAR 0 6
40703: PPUSH
40704: CALL_OW 1
40708: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
40709: LD_ADDR_EXP 65
40713: PUSH
40714: LD_EXP 65
40718: PPUSH
40719: LD_VAR 0 1
40723: PPUSH
40724: LD_VAR 0 3
40728: PPUSH
40729: CALL_OW 1
40733: ST_TO_ADDR
// end ;
40734: LD_VAR 0 4
40738: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
40739: LD_INT 0
40741: PPUSH
// if not mc_bases [ base ] then
40742: LD_EXP 50
40746: PUSH
40747: LD_VAR 0 1
40751: ARRAY
40752: NOT
40753: IFFALSE 40757
// exit ;
40755: GO 40782
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
40757: LD_ADDR_EXP 55
40761: PUSH
40762: LD_EXP 55
40766: PPUSH
40767: LD_VAR 0 1
40771: PPUSH
40772: LD_VAR 0 2
40776: PPUSH
40777: CALL_OW 1
40781: ST_TO_ADDR
// end ;
40782: LD_VAR 0 3
40786: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
40787: LD_INT 0
40789: PPUSH
// if not mc_bases [ base ] then
40790: LD_EXP 50
40794: PUSH
40795: LD_VAR 0 1
40799: ARRAY
40800: NOT
40801: IFFALSE 40805
// exit ;
40803: GO 40842
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
40805: LD_ADDR_EXP 55
40809: PUSH
40810: LD_EXP 55
40814: PPUSH
40815: LD_VAR 0 1
40819: PPUSH
40820: LD_EXP 55
40824: PUSH
40825: LD_VAR 0 1
40829: ARRAY
40830: PUSH
40831: LD_VAR 0 2
40835: UNION
40836: PPUSH
40837: CALL_OW 1
40841: ST_TO_ADDR
// end ;
40842: LD_VAR 0 3
40846: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
40847: LD_INT 0
40849: PPUSH
// if not mc_bases [ base ] then
40850: LD_EXP 50
40854: PUSH
40855: LD_VAR 0 1
40859: ARRAY
40860: NOT
40861: IFFALSE 40865
// exit ;
40863: GO 40890
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
40865: LD_ADDR_EXP 71
40869: PUSH
40870: LD_EXP 71
40874: PPUSH
40875: LD_VAR 0 1
40879: PPUSH
40880: LD_VAR 0 2
40884: PPUSH
40885: CALL_OW 1
40889: ST_TO_ADDR
// end ;
40890: LD_VAR 0 3
40894: RET
// export function MC_InsertProduceList ( base , components ) ; begin
40895: LD_INT 0
40897: PPUSH
// if not mc_bases [ base ] then
40898: LD_EXP 50
40902: PUSH
40903: LD_VAR 0 1
40907: ARRAY
40908: NOT
40909: IFFALSE 40913
// exit ;
40911: GO 40950
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
40913: LD_ADDR_EXP 71
40917: PUSH
40918: LD_EXP 71
40922: PPUSH
40923: LD_VAR 0 1
40927: PPUSH
40928: LD_EXP 71
40932: PUSH
40933: LD_VAR 0 1
40937: ARRAY
40938: PUSH
40939: LD_VAR 0 2
40943: ADD
40944: PPUSH
40945: CALL_OW 1
40949: ST_TO_ADDR
// end ;
40950: LD_VAR 0 3
40954: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
40955: LD_INT 0
40957: PPUSH
// if not mc_bases [ base ] then
40958: LD_EXP 50
40962: PUSH
40963: LD_VAR 0 1
40967: ARRAY
40968: NOT
40969: IFFALSE 40973
// exit ;
40971: GO 41027
// mc_defender := Replace ( mc_defender , base , deflist ) ;
40973: LD_ADDR_EXP 72
40977: PUSH
40978: LD_EXP 72
40982: PPUSH
40983: LD_VAR 0 1
40987: PPUSH
40988: LD_VAR 0 2
40992: PPUSH
40993: CALL_OW 1
40997: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
40998: LD_ADDR_EXP 61
41002: PUSH
41003: LD_EXP 61
41007: PPUSH
41008: LD_VAR 0 1
41012: PPUSH
41013: LD_VAR 0 2
41017: PUSH
41018: LD_INT 0
41020: PLUS
41021: PPUSH
41022: CALL_OW 1
41026: ST_TO_ADDR
// end ;
41027: LD_VAR 0 3
41031: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
41032: LD_INT 0
41034: PPUSH
// if not mc_bases [ base ] then
41035: LD_EXP 50
41039: PUSH
41040: LD_VAR 0 1
41044: ARRAY
41045: NOT
41046: IFFALSE 41050
// exit ;
41048: GO 41075
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
41050: LD_ADDR_EXP 61
41054: PUSH
41055: LD_EXP 61
41059: PPUSH
41060: LD_VAR 0 1
41064: PPUSH
41065: LD_VAR 0 2
41069: PPUSH
41070: CALL_OW 1
41074: ST_TO_ADDR
// end ;
41075: LD_VAR 0 3
41079: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
41080: LD_INT 0
41082: PPUSH
41083: PPUSH
41084: PPUSH
41085: PPUSH
// if not mc_bases [ base ] then
41086: LD_EXP 50
41090: PUSH
41091: LD_VAR 0 1
41095: ARRAY
41096: NOT
41097: IFFALSE 41101
// exit ;
41099: GO 41166
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
41101: LD_ADDR_EXP 70
41105: PUSH
41106: LD_EXP 70
41110: PPUSH
41111: LD_VAR 0 1
41115: PUSH
41116: LD_EXP 70
41120: PUSH
41121: LD_VAR 0 1
41125: ARRAY
41126: PUSH
41127: LD_INT 1
41129: PLUS
41130: PUSH
41131: EMPTY
41132: LIST
41133: LIST
41134: PPUSH
41135: LD_VAR 0 1
41139: PUSH
41140: LD_VAR 0 2
41144: PUSH
41145: LD_VAR 0 3
41149: PUSH
41150: LD_VAR 0 4
41154: PUSH
41155: EMPTY
41156: LIST
41157: LIST
41158: LIST
41159: LIST
41160: PPUSH
41161: CALL 54387 0 3
41165: ST_TO_ADDR
// end ;
41166: LD_VAR 0 5
41170: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
41171: LD_INT 0
41173: PPUSH
// if not mc_bases [ base ] then
41174: LD_EXP 50
41178: PUSH
41179: LD_VAR 0 1
41183: ARRAY
41184: NOT
41185: IFFALSE 41189
// exit ;
41187: GO 41214
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
41189: LD_ADDR_EXP 87
41193: PUSH
41194: LD_EXP 87
41198: PPUSH
41199: LD_VAR 0 1
41203: PPUSH
41204: LD_VAR 0 2
41208: PPUSH
41209: CALL_OW 1
41213: ST_TO_ADDR
// end ;
41214: LD_VAR 0 3
41218: RET
// export function MC_GetMinesField ( base ) ; begin
41219: LD_INT 0
41221: PPUSH
// result := mc_mines [ base ] ;
41222: LD_ADDR_VAR 0 2
41226: PUSH
41227: LD_EXP 63
41231: PUSH
41232: LD_VAR 0 1
41236: ARRAY
41237: ST_TO_ADDR
// end ;
41238: LD_VAR 0 2
41242: RET
// export function MC_GetProduceList ( base ) ; begin
41243: LD_INT 0
41245: PPUSH
// result := mc_produce [ base ] ;
41246: LD_ADDR_VAR 0 2
41250: PUSH
41251: LD_EXP 71
41255: PUSH
41256: LD_VAR 0 1
41260: ARRAY
41261: ST_TO_ADDR
// end ;
41262: LD_VAR 0 2
41266: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
41267: LD_INT 0
41269: PPUSH
41270: PPUSH
// if not mc_bases then
41271: LD_EXP 50
41275: NOT
41276: IFFALSE 41280
// exit ;
41278: GO 41345
// if mc_bases [ base ] then
41280: LD_EXP 50
41284: PUSH
41285: LD_VAR 0 1
41289: ARRAY
41290: IFFALSE 41345
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
41292: LD_ADDR_VAR 0 3
41296: PUSH
41297: LD_EXP 50
41301: PUSH
41302: LD_VAR 0 1
41306: ARRAY
41307: PPUSH
41308: LD_INT 30
41310: PUSH
41311: LD_VAR 0 2
41315: PUSH
41316: EMPTY
41317: LIST
41318: LIST
41319: PPUSH
41320: CALL_OW 72
41324: ST_TO_ADDR
// if result then
41325: LD_VAR 0 3
41329: IFFALSE 41345
// result := result [ 1 ] ;
41331: LD_ADDR_VAR 0 3
41335: PUSH
41336: LD_VAR 0 3
41340: PUSH
41341: LD_INT 1
41343: ARRAY
41344: ST_TO_ADDR
// end ; end ;
41345: LD_VAR 0 3
41349: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
41350: LD_INT 0
41352: PPUSH
41353: PPUSH
// if not mc_bases then
41354: LD_EXP 50
41358: NOT
41359: IFFALSE 41363
// exit ;
41361: GO 41408
// if mc_bases [ base ] then
41363: LD_EXP 50
41367: PUSH
41368: LD_VAR 0 1
41372: ARRAY
41373: IFFALSE 41408
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
41375: LD_ADDR_VAR 0 3
41379: PUSH
41380: LD_EXP 50
41384: PUSH
41385: LD_VAR 0 1
41389: ARRAY
41390: PPUSH
41391: LD_INT 30
41393: PUSH
41394: LD_VAR 0 2
41398: PUSH
41399: EMPTY
41400: LIST
41401: LIST
41402: PPUSH
41403: CALL_OW 72
41407: ST_TO_ADDR
// end ;
41408: LD_VAR 0 3
41412: RET
// export function MC_SetTame ( base , area ) ; begin
41413: LD_INT 0
41415: PPUSH
// if not mc_bases or not base then
41416: LD_EXP 50
41420: NOT
41421: PUSH
41422: LD_VAR 0 1
41426: NOT
41427: OR
41428: IFFALSE 41432
// exit ;
41430: GO 41457
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
41432: LD_ADDR_EXP 78
41436: PUSH
41437: LD_EXP 78
41441: PPUSH
41442: LD_VAR 0 1
41446: PPUSH
41447: LD_VAR 0 2
41451: PPUSH
41452: CALL_OW 1
41456: ST_TO_ADDR
// end ;
41457: LD_VAR 0 3
41461: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
41462: LD_INT 0
41464: PPUSH
41465: PPUSH
// if not mc_bases or not base then
41466: LD_EXP 50
41470: NOT
41471: PUSH
41472: LD_VAR 0 1
41476: NOT
41477: OR
41478: IFFALSE 41482
// exit ;
41480: GO 41584
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
41482: LD_ADDR_VAR 0 4
41486: PUSH
41487: LD_EXP 50
41491: PUSH
41492: LD_VAR 0 1
41496: ARRAY
41497: PPUSH
41498: LD_INT 30
41500: PUSH
41501: LD_VAR 0 2
41505: PUSH
41506: EMPTY
41507: LIST
41508: LIST
41509: PPUSH
41510: CALL_OW 72
41514: ST_TO_ADDR
// if not tmp then
41515: LD_VAR 0 4
41519: NOT
41520: IFFALSE 41524
// exit ;
41522: GO 41584
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
41524: LD_ADDR_EXP 82
41528: PUSH
41529: LD_EXP 82
41533: PPUSH
41534: LD_VAR 0 1
41538: PPUSH
41539: LD_EXP 82
41543: PUSH
41544: LD_VAR 0 1
41548: ARRAY
41549: PPUSH
41550: LD_EXP 82
41554: PUSH
41555: LD_VAR 0 1
41559: ARRAY
41560: PUSH
41561: LD_INT 1
41563: PLUS
41564: PPUSH
41565: LD_VAR 0 4
41569: PUSH
41570: LD_INT 1
41572: ARRAY
41573: PPUSH
41574: CALL_OW 2
41578: PPUSH
41579: CALL_OW 1
41583: ST_TO_ADDR
// end ;
41584: LD_VAR 0 3
41588: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
41589: LD_INT 0
41591: PPUSH
41592: PPUSH
// if not mc_bases or not base or not kinds then
41593: LD_EXP 50
41597: NOT
41598: PUSH
41599: LD_VAR 0 1
41603: NOT
41604: OR
41605: PUSH
41606: LD_VAR 0 2
41610: NOT
41611: OR
41612: IFFALSE 41616
// exit ;
41614: GO 41677
// for i in kinds do
41616: LD_ADDR_VAR 0 4
41620: PUSH
41621: LD_VAR 0 2
41625: PUSH
41626: FOR_IN
41627: IFFALSE 41675
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
41629: LD_ADDR_EXP 84
41633: PUSH
41634: LD_EXP 84
41638: PPUSH
41639: LD_VAR 0 1
41643: PUSH
41644: LD_EXP 84
41648: PUSH
41649: LD_VAR 0 1
41653: ARRAY
41654: PUSH
41655: LD_INT 1
41657: PLUS
41658: PUSH
41659: EMPTY
41660: LIST
41661: LIST
41662: PPUSH
41663: LD_VAR 0 4
41667: PPUSH
41668: CALL 54387 0 3
41672: ST_TO_ADDR
41673: GO 41626
41675: POP
41676: POP
// end ;
41677: LD_VAR 0 3
41681: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
41682: LD_INT 0
41684: PPUSH
// if not mc_bases or not base or not areas then
41685: LD_EXP 50
41689: NOT
41690: PUSH
41691: LD_VAR 0 1
41695: NOT
41696: OR
41697: PUSH
41698: LD_VAR 0 2
41702: NOT
41703: OR
41704: IFFALSE 41708
// exit ;
41706: GO 41733
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
41708: LD_ADDR_EXP 68
41712: PUSH
41713: LD_EXP 68
41717: PPUSH
41718: LD_VAR 0 1
41722: PPUSH
41723: LD_VAR 0 2
41727: PPUSH
41728: CALL_OW 1
41732: ST_TO_ADDR
// end ;
41733: LD_VAR 0 3
41737: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
41738: LD_INT 0
41740: PPUSH
// if not mc_bases or not base or not teleports_exit then
41741: LD_EXP 50
41745: NOT
41746: PUSH
41747: LD_VAR 0 1
41751: NOT
41752: OR
41753: PUSH
41754: LD_VAR 0 2
41758: NOT
41759: OR
41760: IFFALSE 41764
// exit ;
41762: GO 41789
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
41764: LD_ADDR_EXP 85
41768: PUSH
41769: LD_EXP 85
41773: PPUSH
41774: LD_VAR 0 1
41778: PPUSH
41779: LD_VAR 0 2
41783: PPUSH
41784: CALL_OW 1
41788: ST_TO_ADDR
// end ;
41789: LD_VAR 0 3
41793: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
41794: LD_INT 0
41796: PPUSH
41797: PPUSH
41798: PPUSH
// if not mc_bases or not base or not ext_list then
41799: LD_EXP 50
41803: NOT
41804: PUSH
41805: LD_VAR 0 1
41809: NOT
41810: OR
41811: PUSH
41812: LD_VAR 0 5
41816: NOT
41817: OR
41818: IFFALSE 41822
// exit ;
41820: GO 41995
// tmp := GetFacExtXYD ( x , y , d ) ;
41822: LD_ADDR_VAR 0 8
41826: PUSH
41827: LD_VAR 0 2
41831: PPUSH
41832: LD_VAR 0 3
41836: PPUSH
41837: LD_VAR 0 4
41841: PPUSH
41842: CALL 87765 0 3
41846: ST_TO_ADDR
// if not tmp then
41847: LD_VAR 0 8
41851: NOT
41852: IFFALSE 41856
// exit ;
41854: GO 41995
// for i in tmp do
41856: LD_ADDR_VAR 0 7
41860: PUSH
41861: LD_VAR 0 8
41865: PUSH
41866: FOR_IN
41867: IFFALSE 41993
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
41869: LD_ADDR_EXP 55
41873: PUSH
41874: LD_EXP 55
41878: PPUSH
41879: LD_VAR 0 1
41883: PPUSH
41884: LD_EXP 55
41888: PUSH
41889: LD_VAR 0 1
41893: ARRAY
41894: PPUSH
41895: LD_EXP 55
41899: PUSH
41900: LD_VAR 0 1
41904: ARRAY
41905: PUSH
41906: LD_INT 1
41908: PLUS
41909: PPUSH
41910: LD_VAR 0 5
41914: PUSH
41915: LD_INT 1
41917: ARRAY
41918: PUSH
41919: LD_VAR 0 7
41923: PUSH
41924: LD_INT 1
41926: ARRAY
41927: PUSH
41928: LD_VAR 0 7
41932: PUSH
41933: LD_INT 2
41935: ARRAY
41936: PUSH
41937: LD_VAR 0 7
41941: PUSH
41942: LD_INT 3
41944: ARRAY
41945: PUSH
41946: EMPTY
41947: LIST
41948: LIST
41949: LIST
41950: LIST
41951: PPUSH
41952: CALL_OW 2
41956: PPUSH
41957: CALL_OW 1
41961: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
41962: LD_ADDR_VAR 0 5
41966: PUSH
41967: LD_VAR 0 5
41971: PPUSH
41972: LD_INT 1
41974: PPUSH
41975: CALL_OW 3
41979: ST_TO_ADDR
// if not ext_list then
41980: LD_VAR 0 5
41984: NOT
41985: IFFALSE 41991
// exit ;
41987: POP
41988: POP
41989: GO 41995
// end ;
41991: GO 41866
41993: POP
41994: POP
// end ;
41995: LD_VAR 0 6
41999: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
42000: LD_INT 0
42002: PPUSH
// if not mc_bases or not base or not weapon_list then
42003: LD_EXP 50
42007: NOT
42008: PUSH
42009: LD_VAR 0 1
42013: NOT
42014: OR
42015: PUSH
42016: LD_VAR 0 2
42020: NOT
42021: OR
42022: IFFALSE 42026
// exit ;
42024: GO 42051
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
42026: LD_ADDR_EXP 89
42030: PUSH
42031: LD_EXP 89
42035: PPUSH
42036: LD_VAR 0 1
42040: PPUSH
42041: LD_VAR 0 2
42045: PPUSH
42046: CALL_OW 1
42050: ST_TO_ADDR
// end ;
42051: LD_VAR 0 3
42055: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
42056: LD_INT 0
42058: PPUSH
// if not mc_bases or not base or not tech_list then
42059: LD_EXP 50
42063: NOT
42064: PUSH
42065: LD_VAR 0 1
42069: NOT
42070: OR
42071: PUSH
42072: LD_VAR 0 2
42076: NOT
42077: OR
42078: IFFALSE 42082
// exit ;
42080: GO 42107
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
42082: LD_ADDR_EXP 77
42086: PUSH
42087: LD_EXP 77
42091: PPUSH
42092: LD_VAR 0 1
42096: PPUSH
42097: LD_VAR 0 2
42101: PPUSH
42102: CALL_OW 1
42106: ST_TO_ADDR
// end ;
42107: LD_VAR 0 3
42111: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
42112: LD_INT 0
42114: PPUSH
// if not mc_bases or not parking_area or not base then
42115: LD_EXP 50
42119: NOT
42120: PUSH
42121: LD_VAR 0 2
42125: NOT
42126: OR
42127: PUSH
42128: LD_VAR 0 1
42132: NOT
42133: OR
42134: IFFALSE 42138
// exit ;
42136: GO 42163
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
42138: LD_ADDR_EXP 74
42142: PUSH
42143: LD_EXP 74
42147: PPUSH
42148: LD_VAR 0 1
42152: PPUSH
42153: LD_VAR 0 2
42157: PPUSH
42158: CALL_OW 1
42162: ST_TO_ADDR
// end ;
42163: LD_VAR 0 3
42167: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
42168: LD_INT 0
42170: PPUSH
// if not mc_bases or not base or not scan_area then
42171: LD_EXP 50
42175: NOT
42176: PUSH
42177: LD_VAR 0 1
42181: NOT
42182: OR
42183: PUSH
42184: LD_VAR 0 2
42188: NOT
42189: OR
42190: IFFALSE 42194
// exit ;
42192: GO 42219
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
42194: LD_ADDR_EXP 75
42198: PUSH
42199: LD_EXP 75
42203: PPUSH
42204: LD_VAR 0 1
42208: PPUSH
42209: LD_VAR 0 2
42213: PPUSH
42214: CALL_OW 1
42218: ST_TO_ADDR
// end ;
42219: LD_VAR 0 3
42223: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
42224: LD_INT 0
42226: PPUSH
42227: PPUSH
// if not mc_bases or not base then
42228: LD_EXP 50
42232: NOT
42233: PUSH
42234: LD_VAR 0 1
42238: NOT
42239: OR
42240: IFFALSE 42244
// exit ;
42242: GO 42308
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
42244: LD_ADDR_VAR 0 3
42248: PUSH
42249: LD_INT 1
42251: PUSH
42252: LD_INT 2
42254: PUSH
42255: LD_INT 3
42257: PUSH
42258: LD_INT 4
42260: PUSH
42261: LD_INT 11
42263: PUSH
42264: EMPTY
42265: LIST
42266: LIST
42267: LIST
42268: LIST
42269: LIST
42270: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
42271: LD_ADDR_EXP 77
42275: PUSH
42276: LD_EXP 77
42280: PPUSH
42281: LD_VAR 0 1
42285: PPUSH
42286: LD_EXP 77
42290: PUSH
42291: LD_VAR 0 1
42295: ARRAY
42296: PUSH
42297: LD_VAR 0 3
42301: DIFF
42302: PPUSH
42303: CALL_OW 1
42307: ST_TO_ADDR
// end ;
42308: LD_VAR 0 2
42312: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
42313: LD_INT 0
42315: PPUSH
// result := mc_vehicles [ base ] ;
42316: LD_ADDR_VAR 0 3
42320: PUSH
42321: LD_EXP 69
42325: PUSH
42326: LD_VAR 0 1
42330: ARRAY
42331: ST_TO_ADDR
// if onlyCombat then
42332: LD_VAR 0 2
42336: IFFALSE 42501
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
42338: LD_ADDR_VAR 0 3
42342: PUSH
42343: LD_VAR 0 3
42347: PUSH
42348: LD_VAR 0 3
42352: PPUSH
42353: LD_INT 2
42355: PUSH
42356: LD_INT 34
42358: PUSH
42359: LD_INT 12
42361: PUSH
42362: EMPTY
42363: LIST
42364: LIST
42365: PUSH
42366: LD_INT 34
42368: PUSH
42369: LD_INT 51
42371: PUSH
42372: EMPTY
42373: LIST
42374: LIST
42375: PUSH
42376: LD_INT 34
42378: PUSH
42379: LD_EXP 94
42383: PUSH
42384: EMPTY
42385: LIST
42386: LIST
42387: PUSH
42388: LD_INT 34
42390: PUSH
42391: LD_INT 32
42393: PUSH
42394: EMPTY
42395: LIST
42396: LIST
42397: PUSH
42398: LD_INT 34
42400: PUSH
42401: LD_INT 13
42403: PUSH
42404: EMPTY
42405: LIST
42406: LIST
42407: PUSH
42408: LD_INT 34
42410: PUSH
42411: LD_INT 52
42413: PUSH
42414: EMPTY
42415: LIST
42416: LIST
42417: PUSH
42418: LD_INT 34
42420: PUSH
42421: LD_INT 14
42423: PUSH
42424: EMPTY
42425: LIST
42426: LIST
42427: PUSH
42428: LD_INT 34
42430: PUSH
42431: LD_INT 53
42433: PUSH
42434: EMPTY
42435: LIST
42436: LIST
42437: PUSH
42438: LD_INT 34
42440: PUSH
42441: LD_EXP 93
42445: PUSH
42446: EMPTY
42447: LIST
42448: LIST
42449: PUSH
42450: LD_INT 34
42452: PUSH
42453: LD_INT 31
42455: PUSH
42456: EMPTY
42457: LIST
42458: LIST
42459: PUSH
42460: LD_INT 34
42462: PUSH
42463: LD_INT 48
42465: PUSH
42466: EMPTY
42467: LIST
42468: LIST
42469: PUSH
42470: LD_INT 34
42472: PUSH
42473: LD_INT 8
42475: PUSH
42476: EMPTY
42477: LIST
42478: LIST
42479: PUSH
42480: EMPTY
42481: LIST
42482: LIST
42483: LIST
42484: LIST
42485: LIST
42486: LIST
42487: LIST
42488: LIST
42489: LIST
42490: LIST
42491: LIST
42492: LIST
42493: LIST
42494: PPUSH
42495: CALL_OW 72
42499: DIFF
42500: ST_TO_ADDR
// end ; end_of_file
42501: LD_VAR 0 3
42505: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
42506: LD_INT 0
42508: PPUSH
42509: PPUSH
42510: PPUSH
// if not mc_bases or not skirmish then
42511: LD_EXP 50
42515: NOT
42516: PUSH
42517: LD_EXP 48
42521: NOT
42522: OR
42523: IFFALSE 42527
// exit ;
42525: GO 42692
// for i = 1 to mc_bases do
42527: LD_ADDR_VAR 0 4
42531: PUSH
42532: DOUBLE
42533: LD_INT 1
42535: DEC
42536: ST_TO_ADDR
42537: LD_EXP 50
42541: PUSH
42542: FOR_TO
42543: IFFALSE 42690
// begin if sci in mc_bases [ i ] then
42545: LD_VAR 0 2
42549: PUSH
42550: LD_EXP 50
42554: PUSH
42555: LD_VAR 0 4
42559: ARRAY
42560: IN
42561: IFFALSE 42688
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
42563: LD_ADDR_EXP 79
42567: PUSH
42568: LD_EXP 79
42572: PPUSH
42573: LD_VAR 0 4
42577: PUSH
42578: LD_EXP 79
42582: PUSH
42583: LD_VAR 0 4
42587: ARRAY
42588: PUSH
42589: LD_INT 1
42591: PLUS
42592: PUSH
42593: EMPTY
42594: LIST
42595: LIST
42596: PPUSH
42597: LD_VAR 0 1
42601: PPUSH
42602: CALL 54387 0 3
42606: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
42607: LD_ADDR_VAR 0 5
42611: PUSH
42612: LD_EXP 50
42616: PUSH
42617: LD_VAR 0 4
42621: ARRAY
42622: PPUSH
42623: LD_INT 2
42625: PUSH
42626: LD_INT 30
42628: PUSH
42629: LD_INT 0
42631: PUSH
42632: EMPTY
42633: LIST
42634: LIST
42635: PUSH
42636: LD_INT 30
42638: PUSH
42639: LD_INT 1
42641: PUSH
42642: EMPTY
42643: LIST
42644: LIST
42645: PUSH
42646: EMPTY
42647: LIST
42648: LIST
42649: LIST
42650: PPUSH
42651: CALL_OW 72
42655: PPUSH
42656: LD_VAR 0 1
42660: PPUSH
42661: CALL_OW 74
42665: ST_TO_ADDR
// if tmp then
42666: LD_VAR 0 5
42670: IFFALSE 42686
// ComStandNearbyBuilding ( ape , tmp ) ;
42672: LD_VAR 0 1
42676: PPUSH
42677: LD_VAR 0 5
42681: PPUSH
42682: CALL 48679 0 2
// break ;
42686: GO 42690
// end ; end ;
42688: GO 42542
42690: POP
42691: POP
// end ;
42692: LD_VAR 0 3
42696: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
42697: LD_INT 0
42699: PPUSH
42700: PPUSH
42701: PPUSH
// if not mc_bases or not skirmish then
42702: LD_EXP 50
42706: NOT
42707: PUSH
42708: LD_EXP 48
42712: NOT
42713: OR
42714: IFFALSE 42718
// exit ;
42716: GO 42807
// for i = 1 to mc_bases do
42718: LD_ADDR_VAR 0 4
42722: PUSH
42723: DOUBLE
42724: LD_INT 1
42726: DEC
42727: ST_TO_ADDR
42728: LD_EXP 50
42732: PUSH
42733: FOR_TO
42734: IFFALSE 42805
// begin if building in mc_busy_turret_list [ i ] then
42736: LD_VAR 0 1
42740: PUSH
42741: LD_EXP 60
42745: PUSH
42746: LD_VAR 0 4
42750: ARRAY
42751: IN
42752: IFFALSE 42803
// begin tmp := mc_busy_turret_list [ i ] diff building ;
42754: LD_ADDR_VAR 0 5
42758: PUSH
42759: LD_EXP 60
42763: PUSH
42764: LD_VAR 0 4
42768: ARRAY
42769: PUSH
42770: LD_VAR 0 1
42774: DIFF
42775: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
42776: LD_ADDR_EXP 60
42780: PUSH
42781: LD_EXP 60
42785: PPUSH
42786: LD_VAR 0 4
42790: PPUSH
42791: LD_VAR 0 5
42795: PPUSH
42796: CALL_OW 1
42800: ST_TO_ADDR
// break ;
42801: GO 42805
// end ; end ;
42803: GO 42733
42805: POP
42806: POP
// end ;
42807: LD_VAR 0 3
42811: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
42812: LD_INT 0
42814: PPUSH
42815: PPUSH
42816: PPUSH
// if not mc_bases or not skirmish then
42817: LD_EXP 50
42821: NOT
42822: PUSH
42823: LD_EXP 48
42827: NOT
42828: OR
42829: IFFALSE 42833
// exit ;
42831: GO 43032
// for i = 1 to mc_bases do
42833: LD_ADDR_VAR 0 5
42837: PUSH
42838: DOUBLE
42839: LD_INT 1
42841: DEC
42842: ST_TO_ADDR
42843: LD_EXP 50
42847: PUSH
42848: FOR_TO
42849: IFFALSE 43030
// if building in mc_bases [ i ] then
42851: LD_VAR 0 1
42855: PUSH
42856: LD_EXP 50
42860: PUSH
42861: LD_VAR 0 5
42865: ARRAY
42866: IN
42867: IFFALSE 43028
// begin tmp := mc_bases [ i ] diff building ;
42869: LD_ADDR_VAR 0 6
42873: PUSH
42874: LD_EXP 50
42878: PUSH
42879: LD_VAR 0 5
42883: ARRAY
42884: PUSH
42885: LD_VAR 0 1
42889: DIFF
42890: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
42891: LD_ADDR_EXP 50
42895: PUSH
42896: LD_EXP 50
42900: PPUSH
42901: LD_VAR 0 5
42905: PPUSH
42906: LD_VAR 0 6
42910: PPUSH
42911: CALL_OW 1
42915: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
42916: LD_VAR 0 1
42920: PUSH
42921: LD_EXP 58
42925: PUSH
42926: LD_VAR 0 5
42930: ARRAY
42931: IN
42932: IFFALSE 42971
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
42934: LD_ADDR_EXP 58
42938: PUSH
42939: LD_EXP 58
42943: PPUSH
42944: LD_VAR 0 5
42948: PPUSH
42949: LD_EXP 58
42953: PUSH
42954: LD_VAR 0 5
42958: ARRAY
42959: PUSH
42960: LD_VAR 0 1
42964: DIFF
42965: PPUSH
42966: CALL_OW 1
42970: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
42971: LD_VAR 0 1
42975: PUSH
42976: LD_EXP 59
42980: PUSH
42981: LD_VAR 0 5
42985: ARRAY
42986: IN
42987: IFFALSE 43026
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
42989: LD_ADDR_EXP 59
42993: PUSH
42994: LD_EXP 59
42998: PPUSH
42999: LD_VAR 0 5
43003: PPUSH
43004: LD_EXP 59
43008: PUSH
43009: LD_VAR 0 5
43013: ARRAY
43014: PUSH
43015: LD_VAR 0 1
43019: DIFF
43020: PPUSH
43021: CALL_OW 1
43025: ST_TO_ADDR
// break ;
43026: GO 43030
// end ;
43028: GO 42848
43030: POP
43031: POP
// end ;
43032: LD_VAR 0 4
43036: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
43037: LD_INT 0
43039: PPUSH
43040: PPUSH
43041: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
43042: LD_EXP 50
43046: NOT
43047: PUSH
43048: LD_EXP 48
43052: NOT
43053: OR
43054: PUSH
43055: LD_VAR 0 3
43059: PUSH
43060: LD_EXP 76
43064: IN
43065: NOT
43066: OR
43067: IFFALSE 43071
// exit ;
43069: GO 43194
// for i = 1 to mc_vehicles do
43071: LD_ADDR_VAR 0 6
43075: PUSH
43076: DOUBLE
43077: LD_INT 1
43079: DEC
43080: ST_TO_ADDR
43081: LD_EXP 69
43085: PUSH
43086: FOR_TO
43087: IFFALSE 43192
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
43089: LD_VAR 0 2
43093: PUSH
43094: LD_EXP 69
43098: PUSH
43099: LD_VAR 0 6
43103: ARRAY
43104: IN
43105: PUSH
43106: LD_VAR 0 1
43110: PUSH
43111: LD_EXP 69
43115: PUSH
43116: LD_VAR 0 6
43120: ARRAY
43121: IN
43122: OR
43123: IFFALSE 43190
// begin tmp := mc_vehicles [ i ] diff old ;
43125: LD_ADDR_VAR 0 7
43129: PUSH
43130: LD_EXP 69
43134: PUSH
43135: LD_VAR 0 6
43139: ARRAY
43140: PUSH
43141: LD_VAR 0 2
43145: DIFF
43146: ST_TO_ADDR
// tmp := tmp diff new ;
43147: LD_ADDR_VAR 0 7
43151: PUSH
43152: LD_VAR 0 7
43156: PUSH
43157: LD_VAR 0 1
43161: DIFF
43162: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
43163: LD_ADDR_EXP 69
43167: PUSH
43168: LD_EXP 69
43172: PPUSH
43173: LD_VAR 0 6
43177: PPUSH
43178: LD_VAR 0 7
43182: PPUSH
43183: CALL_OW 1
43187: ST_TO_ADDR
// break ;
43188: GO 43192
// end ;
43190: GO 43086
43192: POP
43193: POP
// end ;
43194: LD_VAR 0 5
43198: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
43199: LD_INT 0
43201: PPUSH
43202: PPUSH
43203: PPUSH
43204: PPUSH
// if not mc_bases or not skirmish then
43205: LD_EXP 50
43209: NOT
43210: PUSH
43211: LD_EXP 48
43215: NOT
43216: OR
43217: IFFALSE 43221
// exit ;
43219: GO 43598
// side := GetSide ( vehicle ) ;
43221: LD_ADDR_VAR 0 5
43225: PUSH
43226: LD_VAR 0 1
43230: PPUSH
43231: CALL_OW 255
43235: ST_TO_ADDR
// for i = 1 to mc_bases do
43236: LD_ADDR_VAR 0 4
43240: PUSH
43241: DOUBLE
43242: LD_INT 1
43244: DEC
43245: ST_TO_ADDR
43246: LD_EXP 50
43250: PUSH
43251: FOR_TO
43252: IFFALSE 43596
// begin if factory in mc_bases [ i ] then
43254: LD_VAR 0 2
43258: PUSH
43259: LD_EXP 50
43263: PUSH
43264: LD_VAR 0 4
43268: ARRAY
43269: IN
43270: IFFALSE 43594
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
43272: LD_EXP 72
43276: PUSH
43277: LD_VAR 0 4
43281: ARRAY
43282: PUSH
43283: LD_EXP 61
43287: PUSH
43288: LD_VAR 0 4
43292: ARRAY
43293: LESS
43294: PUSH
43295: LD_VAR 0 1
43299: PPUSH
43300: CALL_OW 264
43304: PUSH
43305: LD_INT 31
43307: PUSH
43308: LD_INT 32
43310: PUSH
43311: LD_INT 51
43313: PUSH
43314: LD_EXP 94
43318: PUSH
43319: LD_INT 12
43321: PUSH
43322: LD_INT 30
43324: PUSH
43325: LD_EXP 93
43329: PUSH
43330: LD_INT 11
43332: PUSH
43333: LD_INT 53
43335: PUSH
43336: LD_INT 14
43338: PUSH
43339: LD_EXP 97
43343: PUSH
43344: LD_INT 29
43346: PUSH
43347: LD_EXP 95
43351: PUSH
43352: LD_INT 13
43354: PUSH
43355: LD_INT 52
43357: PUSH
43358: LD_INT 48
43360: PUSH
43361: LD_INT 8
43363: PUSH
43364: EMPTY
43365: LIST
43366: LIST
43367: LIST
43368: LIST
43369: LIST
43370: LIST
43371: LIST
43372: LIST
43373: LIST
43374: LIST
43375: LIST
43376: LIST
43377: LIST
43378: LIST
43379: LIST
43380: LIST
43381: LIST
43382: IN
43383: NOT
43384: AND
43385: IFFALSE 43433
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
43387: LD_ADDR_EXP 72
43391: PUSH
43392: LD_EXP 72
43396: PPUSH
43397: LD_VAR 0 4
43401: PUSH
43402: LD_EXP 72
43406: PUSH
43407: LD_VAR 0 4
43411: ARRAY
43412: PUSH
43413: LD_INT 1
43415: PLUS
43416: PUSH
43417: EMPTY
43418: LIST
43419: LIST
43420: PPUSH
43421: LD_VAR 0 1
43425: PPUSH
43426: CALL 54387 0 3
43430: ST_TO_ADDR
43431: GO 43477
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
43433: LD_ADDR_EXP 69
43437: PUSH
43438: LD_EXP 69
43442: PPUSH
43443: LD_VAR 0 4
43447: PUSH
43448: LD_EXP 69
43452: PUSH
43453: LD_VAR 0 4
43457: ARRAY
43458: PUSH
43459: LD_INT 1
43461: PLUS
43462: PUSH
43463: EMPTY
43464: LIST
43465: LIST
43466: PPUSH
43467: LD_VAR 0 1
43471: PPUSH
43472: CALL 54387 0 3
43476: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
43477: LD_VAR 0 1
43481: PPUSH
43482: CALL_OW 263
43486: PUSH
43487: LD_INT 2
43489: EQUAL
43490: IFFALSE 43510
// begin repeat wait ( 0 0$1 ) ;
43492: LD_INT 35
43494: PPUSH
43495: CALL_OW 67
// until IsControledBy ( vehicle ) ;
43499: LD_VAR 0 1
43503: PPUSH
43504: CALL_OW 312
43508: IFFALSE 43492
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
43510: LD_VAR 0 1
43514: PPUSH
43515: LD_EXP 74
43519: PUSH
43520: LD_VAR 0 4
43524: ARRAY
43525: PPUSH
43526: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
43530: LD_VAR 0 1
43534: PPUSH
43535: CALL_OW 263
43539: PUSH
43540: LD_INT 1
43542: NONEQUAL
43543: IFFALSE 43547
// break ;
43545: GO 43596
// repeat wait ( 0 0$1 ) ;
43547: LD_INT 35
43549: PPUSH
43550: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
43554: LD_VAR 0 1
43558: PPUSH
43559: LD_EXP 74
43563: PUSH
43564: LD_VAR 0 4
43568: ARRAY
43569: PPUSH
43570: CALL_OW 308
43574: IFFALSE 43547
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
43576: LD_VAR 0 1
43580: PPUSH
43581: CALL_OW 311
43585: PPUSH
43586: CALL_OW 121
// exit ;
43590: POP
43591: POP
43592: GO 43598
// end ; end ;
43594: GO 43251
43596: POP
43597: POP
// end ;
43598: LD_VAR 0 3
43602: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
43603: LD_INT 0
43605: PPUSH
43606: PPUSH
43607: PPUSH
43608: PPUSH
// if not mc_bases or not skirmish then
43609: LD_EXP 50
43613: NOT
43614: PUSH
43615: LD_EXP 48
43619: NOT
43620: OR
43621: IFFALSE 43625
// exit ;
43623: GO 43978
// repeat wait ( 0 0$1 ) ;
43625: LD_INT 35
43627: PPUSH
43628: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
43632: LD_VAR 0 2
43636: PPUSH
43637: LD_VAR 0 3
43641: PPUSH
43642: CALL_OW 284
43646: IFFALSE 43625
// if GetResourceTypeXY ( x , y ) = mat_artefact then
43648: LD_VAR 0 2
43652: PPUSH
43653: LD_VAR 0 3
43657: PPUSH
43658: CALL_OW 283
43662: PUSH
43663: LD_INT 4
43665: EQUAL
43666: IFFALSE 43670
// exit ;
43668: GO 43978
// for i = 1 to mc_bases do
43670: LD_ADDR_VAR 0 7
43674: PUSH
43675: DOUBLE
43676: LD_INT 1
43678: DEC
43679: ST_TO_ADDR
43680: LD_EXP 50
43684: PUSH
43685: FOR_TO
43686: IFFALSE 43976
// begin if mc_crates_area [ i ] then
43688: LD_EXP 68
43692: PUSH
43693: LD_VAR 0 7
43697: ARRAY
43698: IFFALSE 43809
// for j in mc_crates_area [ i ] do
43700: LD_ADDR_VAR 0 8
43704: PUSH
43705: LD_EXP 68
43709: PUSH
43710: LD_VAR 0 7
43714: ARRAY
43715: PUSH
43716: FOR_IN
43717: IFFALSE 43807
// if InArea ( x , y , j ) then
43719: LD_VAR 0 2
43723: PPUSH
43724: LD_VAR 0 3
43728: PPUSH
43729: LD_VAR 0 8
43733: PPUSH
43734: CALL_OW 309
43738: IFFALSE 43805
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
43740: LD_ADDR_EXP 66
43744: PUSH
43745: LD_EXP 66
43749: PPUSH
43750: LD_VAR 0 7
43754: PUSH
43755: LD_EXP 66
43759: PUSH
43760: LD_VAR 0 7
43764: ARRAY
43765: PUSH
43766: LD_INT 1
43768: PLUS
43769: PUSH
43770: EMPTY
43771: LIST
43772: LIST
43773: PPUSH
43774: LD_VAR 0 4
43778: PUSH
43779: LD_VAR 0 2
43783: PUSH
43784: LD_VAR 0 3
43788: PUSH
43789: EMPTY
43790: LIST
43791: LIST
43792: LIST
43793: PPUSH
43794: CALL 54387 0 3
43798: ST_TO_ADDR
// exit ;
43799: POP
43800: POP
43801: POP
43802: POP
43803: GO 43978
// end ;
43805: GO 43716
43807: POP
43808: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
43809: LD_ADDR_VAR 0 9
43813: PUSH
43814: LD_EXP 50
43818: PUSH
43819: LD_VAR 0 7
43823: ARRAY
43824: PPUSH
43825: LD_INT 2
43827: PUSH
43828: LD_INT 30
43830: PUSH
43831: LD_INT 0
43833: PUSH
43834: EMPTY
43835: LIST
43836: LIST
43837: PUSH
43838: LD_INT 30
43840: PUSH
43841: LD_INT 1
43843: PUSH
43844: EMPTY
43845: LIST
43846: LIST
43847: PUSH
43848: EMPTY
43849: LIST
43850: LIST
43851: LIST
43852: PPUSH
43853: CALL_OW 72
43857: ST_TO_ADDR
// if not depot then
43858: LD_VAR 0 9
43862: NOT
43863: IFFALSE 43867
// continue ;
43865: GO 43685
// for j in depot do
43867: LD_ADDR_VAR 0 8
43871: PUSH
43872: LD_VAR 0 9
43876: PUSH
43877: FOR_IN
43878: IFFALSE 43972
// if GetDistUnitXY ( j , x , y ) < 30 then
43880: LD_VAR 0 8
43884: PPUSH
43885: LD_VAR 0 2
43889: PPUSH
43890: LD_VAR 0 3
43894: PPUSH
43895: CALL_OW 297
43899: PUSH
43900: LD_INT 30
43902: LESS
43903: IFFALSE 43970
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
43905: LD_ADDR_EXP 66
43909: PUSH
43910: LD_EXP 66
43914: PPUSH
43915: LD_VAR 0 7
43919: PUSH
43920: LD_EXP 66
43924: PUSH
43925: LD_VAR 0 7
43929: ARRAY
43930: PUSH
43931: LD_INT 1
43933: PLUS
43934: PUSH
43935: EMPTY
43936: LIST
43937: LIST
43938: PPUSH
43939: LD_VAR 0 4
43943: PUSH
43944: LD_VAR 0 2
43948: PUSH
43949: LD_VAR 0 3
43953: PUSH
43954: EMPTY
43955: LIST
43956: LIST
43957: LIST
43958: PPUSH
43959: CALL 54387 0 3
43963: ST_TO_ADDR
// exit ;
43964: POP
43965: POP
43966: POP
43967: POP
43968: GO 43978
// end ;
43970: GO 43877
43972: POP
43973: POP
// end ;
43974: GO 43685
43976: POP
43977: POP
// end ;
43978: LD_VAR 0 6
43982: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
43983: LD_INT 0
43985: PPUSH
43986: PPUSH
43987: PPUSH
43988: PPUSH
// if not mc_bases or not skirmish then
43989: LD_EXP 50
43993: NOT
43994: PUSH
43995: LD_EXP 48
43999: NOT
44000: OR
44001: IFFALSE 44005
// exit ;
44003: GO 44282
// side := GetSide ( lab ) ;
44005: LD_ADDR_VAR 0 4
44009: PUSH
44010: LD_VAR 0 2
44014: PPUSH
44015: CALL_OW 255
44019: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
44020: LD_VAR 0 4
44024: PUSH
44025: LD_EXP 76
44029: IN
44030: NOT
44031: PUSH
44032: LD_EXP 77
44036: NOT
44037: OR
44038: PUSH
44039: LD_EXP 50
44043: NOT
44044: OR
44045: IFFALSE 44049
// exit ;
44047: GO 44282
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
44049: LD_ADDR_EXP 77
44053: PUSH
44054: LD_EXP 77
44058: PPUSH
44059: LD_VAR 0 4
44063: PPUSH
44064: LD_EXP 77
44068: PUSH
44069: LD_VAR 0 4
44073: ARRAY
44074: PUSH
44075: LD_VAR 0 1
44079: DIFF
44080: PPUSH
44081: CALL_OW 1
44085: ST_TO_ADDR
// for i = 1 to mc_bases do
44086: LD_ADDR_VAR 0 5
44090: PUSH
44091: DOUBLE
44092: LD_INT 1
44094: DEC
44095: ST_TO_ADDR
44096: LD_EXP 50
44100: PUSH
44101: FOR_TO
44102: IFFALSE 44280
// begin if lab in mc_bases [ i ] then
44104: LD_VAR 0 2
44108: PUSH
44109: LD_EXP 50
44113: PUSH
44114: LD_VAR 0 5
44118: ARRAY
44119: IN
44120: IFFALSE 44278
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
44122: LD_VAR 0 1
44126: PUSH
44127: LD_INT 11
44129: PUSH
44130: LD_INT 4
44132: PUSH
44133: LD_INT 3
44135: PUSH
44136: LD_INT 2
44138: PUSH
44139: EMPTY
44140: LIST
44141: LIST
44142: LIST
44143: LIST
44144: IN
44145: PUSH
44146: LD_EXP 80
44150: PUSH
44151: LD_VAR 0 5
44155: ARRAY
44156: AND
44157: IFFALSE 44278
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
44159: LD_ADDR_VAR 0 6
44163: PUSH
44164: LD_EXP 80
44168: PUSH
44169: LD_VAR 0 5
44173: ARRAY
44174: PUSH
44175: LD_INT 1
44177: ARRAY
44178: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
44179: LD_ADDR_EXP 80
44183: PUSH
44184: LD_EXP 80
44188: PPUSH
44189: LD_VAR 0 5
44193: PPUSH
44194: EMPTY
44195: PPUSH
44196: CALL_OW 1
44200: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
44201: LD_VAR 0 6
44205: PPUSH
44206: LD_INT 0
44208: PPUSH
44209: CALL_OW 109
// ComExitBuilding ( tmp ) ;
44213: LD_VAR 0 6
44217: PPUSH
44218: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
44222: LD_ADDR_EXP 79
44226: PUSH
44227: LD_EXP 79
44231: PPUSH
44232: LD_VAR 0 5
44236: PPUSH
44237: LD_EXP 79
44241: PUSH
44242: LD_VAR 0 5
44246: ARRAY
44247: PPUSH
44248: LD_INT 1
44250: PPUSH
44251: LD_VAR 0 6
44255: PPUSH
44256: CALL_OW 2
44260: PPUSH
44261: CALL_OW 1
44265: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
44266: LD_VAR 0 5
44270: PPUSH
44271: LD_INT 112
44273: PPUSH
44274: CALL 21174 0 2
// end ; end ; end ;
44278: GO 44101
44280: POP
44281: POP
// end ;
44282: LD_VAR 0 3
44286: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
44287: LD_INT 0
44289: PPUSH
44290: PPUSH
44291: PPUSH
44292: PPUSH
44293: PPUSH
44294: PPUSH
44295: PPUSH
44296: PPUSH
// if not mc_bases or not skirmish then
44297: LD_EXP 50
44301: NOT
44302: PUSH
44303: LD_EXP 48
44307: NOT
44308: OR
44309: IFFALSE 44313
// exit ;
44311: GO 45684
// for i = 1 to mc_bases do
44313: LD_ADDR_VAR 0 3
44317: PUSH
44318: DOUBLE
44319: LD_INT 1
44321: DEC
44322: ST_TO_ADDR
44323: LD_EXP 50
44327: PUSH
44328: FOR_TO
44329: IFFALSE 45682
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
44331: LD_VAR 0 1
44335: PUSH
44336: LD_EXP 50
44340: PUSH
44341: LD_VAR 0 3
44345: ARRAY
44346: IN
44347: PUSH
44348: LD_VAR 0 1
44352: PUSH
44353: LD_EXP 57
44357: PUSH
44358: LD_VAR 0 3
44362: ARRAY
44363: IN
44364: OR
44365: PUSH
44366: LD_VAR 0 1
44370: PUSH
44371: LD_EXP 72
44375: PUSH
44376: LD_VAR 0 3
44380: ARRAY
44381: IN
44382: OR
44383: PUSH
44384: LD_VAR 0 1
44388: PUSH
44389: LD_EXP 69
44393: PUSH
44394: LD_VAR 0 3
44398: ARRAY
44399: IN
44400: OR
44401: PUSH
44402: LD_VAR 0 1
44406: PUSH
44407: LD_EXP 79
44411: PUSH
44412: LD_VAR 0 3
44416: ARRAY
44417: IN
44418: OR
44419: PUSH
44420: LD_VAR 0 1
44424: PUSH
44425: LD_EXP 80
44429: PUSH
44430: LD_VAR 0 3
44434: ARRAY
44435: IN
44436: OR
44437: IFFALSE 45680
// begin if un in mc_ape [ i ] then
44439: LD_VAR 0 1
44443: PUSH
44444: LD_EXP 79
44448: PUSH
44449: LD_VAR 0 3
44453: ARRAY
44454: IN
44455: IFFALSE 44494
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
44457: LD_ADDR_EXP 79
44461: PUSH
44462: LD_EXP 79
44466: PPUSH
44467: LD_VAR 0 3
44471: PPUSH
44472: LD_EXP 79
44476: PUSH
44477: LD_VAR 0 3
44481: ARRAY
44482: PUSH
44483: LD_VAR 0 1
44487: DIFF
44488: PPUSH
44489: CALL_OW 1
44493: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
44494: LD_VAR 0 1
44498: PUSH
44499: LD_EXP 80
44503: PUSH
44504: LD_VAR 0 3
44508: ARRAY
44509: IN
44510: IFFALSE 44534
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
44512: LD_ADDR_EXP 80
44516: PUSH
44517: LD_EXP 80
44521: PPUSH
44522: LD_VAR 0 3
44526: PPUSH
44527: EMPTY
44528: PPUSH
44529: CALL_OW 1
44533: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
44534: LD_VAR 0 1
44538: PPUSH
44539: CALL_OW 247
44543: PUSH
44544: LD_INT 2
44546: EQUAL
44547: PUSH
44548: LD_VAR 0 1
44552: PPUSH
44553: CALL_OW 110
44557: PUSH
44558: LD_INT 20
44560: EQUAL
44561: PUSH
44562: LD_VAR 0 1
44566: PUSH
44567: LD_EXP 72
44571: PUSH
44572: LD_VAR 0 3
44576: ARRAY
44577: IN
44578: OR
44579: PUSH
44580: LD_VAR 0 1
44584: PPUSH
44585: CALL_OW 264
44589: PUSH
44590: LD_INT 12
44592: PUSH
44593: LD_INT 51
44595: PUSH
44596: LD_EXP 94
44600: PUSH
44601: LD_INT 32
44603: PUSH
44604: LD_INT 13
44606: PUSH
44607: LD_INT 52
44609: PUSH
44610: LD_INT 31
44612: PUSH
44613: EMPTY
44614: LIST
44615: LIST
44616: LIST
44617: LIST
44618: LIST
44619: LIST
44620: LIST
44621: IN
44622: OR
44623: AND
44624: IFFALSE 44932
// begin if un in mc_defender [ i ] then
44626: LD_VAR 0 1
44630: PUSH
44631: LD_EXP 72
44635: PUSH
44636: LD_VAR 0 3
44640: ARRAY
44641: IN
44642: IFFALSE 44681
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
44644: LD_ADDR_EXP 72
44648: PUSH
44649: LD_EXP 72
44653: PPUSH
44654: LD_VAR 0 3
44658: PPUSH
44659: LD_EXP 72
44663: PUSH
44664: LD_VAR 0 3
44668: ARRAY
44669: PUSH
44670: LD_VAR 0 1
44674: DIFF
44675: PPUSH
44676: CALL_OW 1
44680: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
44681: LD_ADDR_VAR 0 8
44685: PUSH
44686: LD_VAR 0 3
44690: PPUSH
44691: LD_INT 3
44693: PPUSH
44694: CALL 41350 0 2
44698: ST_TO_ADDR
// if fac then
44699: LD_VAR 0 8
44703: IFFALSE 44932
// begin for j in fac do
44705: LD_ADDR_VAR 0 4
44709: PUSH
44710: LD_VAR 0 8
44714: PUSH
44715: FOR_IN
44716: IFFALSE 44930
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
44718: LD_ADDR_VAR 0 9
44722: PUSH
44723: LD_VAR 0 8
44727: PPUSH
44728: LD_VAR 0 1
44732: PPUSH
44733: CALL_OW 265
44737: PPUSH
44738: LD_VAR 0 1
44742: PPUSH
44743: CALL_OW 262
44747: PPUSH
44748: LD_VAR 0 1
44752: PPUSH
44753: CALL_OW 263
44757: PPUSH
44758: LD_VAR 0 1
44762: PPUSH
44763: CALL_OW 264
44767: PPUSH
44768: CALL 51919 0 5
44772: ST_TO_ADDR
// if components then
44773: LD_VAR 0 9
44777: IFFALSE 44928
// begin if GetWeapon ( un ) = ar_control_tower then
44779: LD_VAR 0 1
44783: PPUSH
44784: CALL_OW 264
44788: PUSH
44789: LD_INT 31
44791: EQUAL
44792: IFFALSE 44909
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
44794: LD_VAR 0 1
44798: PPUSH
44799: CALL_OW 311
44803: PPUSH
44804: LD_INT 0
44806: PPUSH
44807: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
44811: LD_ADDR_EXP 90
44815: PUSH
44816: LD_EXP 90
44820: PPUSH
44821: LD_VAR 0 3
44825: PPUSH
44826: LD_EXP 90
44830: PUSH
44831: LD_VAR 0 3
44835: ARRAY
44836: PUSH
44837: LD_VAR 0 1
44841: PPUSH
44842: CALL_OW 311
44846: DIFF
44847: PPUSH
44848: CALL_OW 1
44852: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
44853: LD_ADDR_VAR 0 7
44857: PUSH
44858: LD_EXP 71
44862: PUSH
44863: LD_VAR 0 3
44867: ARRAY
44868: PPUSH
44869: LD_INT 1
44871: PPUSH
44872: LD_VAR 0 9
44876: PPUSH
44877: CALL_OW 2
44881: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
44882: LD_ADDR_EXP 71
44886: PUSH
44887: LD_EXP 71
44891: PPUSH
44892: LD_VAR 0 3
44896: PPUSH
44897: LD_VAR 0 7
44901: PPUSH
44902: CALL_OW 1
44906: ST_TO_ADDR
// end else
44907: GO 44926
// MC_InsertProduceList ( i , [ components ] ) ;
44909: LD_VAR 0 3
44913: PPUSH
44914: LD_VAR 0 9
44918: PUSH
44919: EMPTY
44920: LIST
44921: PPUSH
44922: CALL 40895 0 2
// break ;
44926: GO 44930
// end ; end ;
44928: GO 44715
44930: POP
44931: POP
// end ; end ; if GetType ( un ) = unit_building then
44932: LD_VAR 0 1
44936: PPUSH
44937: CALL_OW 247
44941: PUSH
44942: LD_INT 3
44944: EQUAL
44945: IFFALSE 45348
// begin btype := GetBType ( un ) ;
44947: LD_ADDR_VAR 0 5
44951: PUSH
44952: LD_VAR 0 1
44956: PPUSH
44957: CALL_OW 266
44961: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
44962: LD_VAR 0 5
44966: PUSH
44967: LD_INT 29
44969: PUSH
44970: LD_INT 30
44972: PUSH
44973: EMPTY
44974: LIST
44975: LIST
44976: IN
44977: IFFALSE 45050
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
44979: LD_VAR 0 1
44983: PPUSH
44984: CALL_OW 250
44988: PPUSH
44989: LD_VAR 0 1
44993: PPUSH
44994: CALL_OW 251
44998: PPUSH
44999: LD_VAR 0 1
45003: PPUSH
45004: CALL_OW 255
45008: PPUSH
45009: CALL_OW 440
45013: NOT
45014: IFFALSE 45050
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
45016: LD_VAR 0 1
45020: PPUSH
45021: CALL_OW 250
45025: PPUSH
45026: LD_VAR 0 1
45030: PPUSH
45031: CALL_OW 251
45035: PPUSH
45036: LD_VAR 0 1
45040: PPUSH
45041: CALL_OW 255
45045: PPUSH
45046: CALL_OW 441
// end ; if btype = b_warehouse then
45050: LD_VAR 0 5
45054: PUSH
45055: LD_INT 1
45057: EQUAL
45058: IFFALSE 45076
// begin btype := b_depot ;
45060: LD_ADDR_VAR 0 5
45064: PUSH
45065: LD_INT 0
45067: ST_TO_ADDR
// pos := 1 ;
45068: LD_ADDR_VAR 0 6
45072: PUSH
45073: LD_INT 1
45075: ST_TO_ADDR
// end ; if btype = b_factory then
45076: LD_VAR 0 5
45080: PUSH
45081: LD_INT 3
45083: EQUAL
45084: IFFALSE 45102
// begin btype := b_workshop ;
45086: LD_ADDR_VAR 0 5
45090: PUSH
45091: LD_INT 2
45093: ST_TO_ADDR
// pos := 1 ;
45094: LD_ADDR_VAR 0 6
45098: PUSH
45099: LD_INT 1
45101: ST_TO_ADDR
// end ; if btype = b_barracks then
45102: LD_VAR 0 5
45106: PUSH
45107: LD_INT 5
45109: EQUAL
45110: IFFALSE 45120
// btype := b_armoury ;
45112: LD_ADDR_VAR 0 5
45116: PUSH
45117: LD_INT 4
45119: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
45120: LD_VAR 0 5
45124: PUSH
45125: LD_INT 7
45127: PUSH
45128: LD_INT 8
45130: PUSH
45131: EMPTY
45132: LIST
45133: LIST
45134: IN
45135: IFFALSE 45145
// btype := b_lab ;
45137: LD_ADDR_VAR 0 5
45141: PUSH
45142: LD_INT 6
45144: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
45145: LD_ADDR_EXP 55
45149: PUSH
45150: LD_EXP 55
45154: PPUSH
45155: LD_VAR 0 3
45159: PUSH
45160: LD_EXP 55
45164: PUSH
45165: LD_VAR 0 3
45169: ARRAY
45170: PUSH
45171: LD_INT 1
45173: PLUS
45174: PUSH
45175: EMPTY
45176: LIST
45177: LIST
45178: PPUSH
45179: LD_VAR 0 5
45183: PUSH
45184: LD_VAR 0 1
45188: PPUSH
45189: CALL_OW 250
45193: PUSH
45194: LD_VAR 0 1
45198: PPUSH
45199: CALL_OW 251
45203: PUSH
45204: LD_VAR 0 1
45208: PPUSH
45209: CALL_OW 254
45213: PUSH
45214: EMPTY
45215: LIST
45216: LIST
45217: LIST
45218: LIST
45219: PPUSH
45220: CALL 54387 0 3
45224: ST_TO_ADDR
// if pos = 1 then
45225: LD_VAR 0 6
45229: PUSH
45230: LD_INT 1
45232: EQUAL
45233: IFFALSE 45348
// begin tmp := mc_build_list [ i ] ;
45235: LD_ADDR_VAR 0 7
45239: PUSH
45240: LD_EXP 55
45244: PUSH
45245: LD_VAR 0 3
45249: ARRAY
45250: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
45251: LD_VAR 0 7
45255: PPUSH
45256: LD_INT 2
45258: PUSH
45259: LD_INT 30
45261: PUSH
45262: LD_INT 0
45264: PUSH
45265: EMPTY
45266: LIST
45267: LIST
45268: PUSH
45269: LD_INT 30
45271: PUSH
45272: LD_INT 1
45274: PUSH
45275: EMPTY
45276: LIST
45277: LIST
45278: PUSH
45279: EMPTY
45280: LIST
45281: LIST
45282: LIST
45283: PPUSH
45284: CALL_OW 72
45288: IFFALSE 45298
// pos := 2 ;
45290: LD_ADDR_VAR 0 6
45294: PUSH
45295: LD_INT 2
45297: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
45298: LD_ADDR_VAR 0 7
45302: PUSH
45303: LD_VAR 0 7
45307: PPUSH
45308: LD_VAR 0 6
45312: PPUSH
45313: LD_VAR 0 7
45317: PPUSH
45318: CALL 54713 0 3
45322: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
45323: LD_ADDR_EXP 55
45327: PUSH
45328: LD_EXP 55
45332: PPUSH
45333: LD_VAR 0 3
45337: PPUSH
45338: LD_VAR 0 7
45342: PPUSH
45343: CALL_OW 1
45347: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
45348: LD_VAR 0 1
45352: PUSH
45353: LD_EXP 50
45357: PUSH
45358: LD_VAR 0 3
45362: ARRAY
45363: IN
45364: IFFALSE 45403
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
45366: LD_ADDR_EXP 50
45370: PUSH
45371: LD_EXP 50
45375: PPUSH
45376: LD_VAR 0 3
45380: PPUSH
45381: LD_EXP 50
45385: PUSH
45386: LD_VAR 0 3
45390: ARRAY
45391: PUSH
45392: LD_VAR 0 1
45396: DIFF
45397: PPUSH
45398: CALL_OW 1
45402: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
45403: LD_VAR 0 1
45407: PUSH
45408: LD_EXP 57
45412: PUSH
45413: LD_VAR 0 3
45417: ARRAY
45418: IN
45419: IFFALSE 45458
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
45421: LD_ADDR_EXP 57
45425: PUSH
45426: LD_EXP 57
45430: PPUSH
45431: LD_VAR 0 3
45435: PPUSH
45436: LD_EXP 57
45440: PUSH
45441: LD_VAR 0 3
45445: ARRAY
45446: PUSH
45447: LD_VAR 0 1
45451: DIFF
45452: PPUSH
45453: CALL_OW 1
45457: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
45458: LD_VAR 0 1
45462: PUSH
45463: LD_EXP 69
45467: PUSH
45468: LD_VAR 0 3
45472: ARRAY
45473: IN
45474: IFFALSE 45513
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
45476: LD_ADDR_EXP 69
45480: PUSH
45481: LD_EXP 69
45485: PPUSH
45486: LD_VAR 0 3
45490: PPUSH
45491: LD_EXP 69
45495: PUSH
45496: LD_VAR 0 3
45500: ARRAY
45501: PUSH
45502: LD_VAR 0 1
45506: DIFF
45507: PPUSH
45508: CALL_OW 1
45512: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
45513: LD_VAR 0 1
45517: PUSH
45518: LD_EXP 72
45522: PUSH
45523: LD_VAR 0 3
45527: ARRAY
45528: IN
45529: IFFALSE 45568
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
45531: LD_ADDR_EXP 72
45535: PUSH
45536: LD_EXP 72
45540: PPUSH
45541: LD_VAR 0 3
45545: PPUSH
45546: LD_EXP 72
45550: PUSH
45551: LD_VAR 0 3
45555: ARRAY
45556: PUSH
45557: LD_VAR 0 1
45561: DIFF
45562: PPUSH
45563: CALL_OW 1
45567: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
45568: LD_VAR 0 1
45572: PUSH
45573: LD_EXP 59
45577: PUSH
45578: LD_VAR 0 3
45582: ARRAY
45583: IN
45584: IFFALSE 45623
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
45586: LD_ADDR_EXP 59
45590: PUSH
45591: LD_EXP 59
45595: PPUSH
45596: LD_VAR 0 3
45600: PPUSH
45601: LD_EXP 59
45605: PUSH
45606: LD_VAR 0 3
45610: ARRAY
45611: PUSH
45612: LD_VAR 0 1
45616: DIFF
45617: PPUSH
45618: CALL_OW 1
45622: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
45623: LD_VAR 0 1
45627: PUSH
45628: LD_EXP 58
45632: PUSH
45633: LD_VAR 0 3
45637: ARRAY
45638: IN
45639: IFFALSE 45678
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
45641: LD_ADDR_EXP 58
45645: PUSH
45646: LD_EXP 58
45650: PPUSH
45651: LD_VAR 0 3
45655: PPUSH
45656: LD_EXP 58
45660: PUSH
45661: LD_VAR 0 3
45665: ARRAY
45666: PUSH
45667: LD_VAR 0 1
45671: DIFF
45672: PPUSH
45673: CALL_OW 1
45677: ST_TO_ADDR
// end ; break ;
45678: GO 45682
// end ;
45680: GO 44328
45682: POP
45683: POP
// end ;
45684: LD_VAR 0 2
45688: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
45689: LD_INT 0
45691: PPUSH
45692: PPUSH
45693: PPUSH
// if not mc_bases or not skirmish then
45694: LD_EXP 50
45698: NOT
45699: PUSH
45700: LD_EXP 48
45704: NOT
45705: OR
45706: IFFALSE 45710
// exit ;
45708: GO 45925
// for i = 1 to mc_bases do
45710: LD_ADDR_VAR 0 3
45714: PUSH
45715: DOUBLE
45716: LD_INT 1
45718: DEC
45719: ST_TO_ADDR
45720: LD_EXP 50
45724: PUSH
45725: FOR_TO
45726: IFFALSE 45923
// begin if building in mc_construct_list [ i ] then
45728: LD_VAR 0 1
45732: PUSH
45733: LD_EXP 57
45737: PUSH
45738: LD_VAR 0 3
45742: ARRAY
45743: IN
45744: IFFALSE 45921
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
45746: LD_ADDR_EXP 57
45750: PUSH
45751: LD_EXP 57
45755: PPUSH
45756: LD_VAR 0 3
45760: PPUSH
45761: LD_EXP 57
45765: PUSH
45766: LD_VAR 0 3
45770: ARRAY
45771: PUSH
45772: LD_VAR 0 1
45776: DIFF
45777: PPUSH
45778: CALL_OW 1
45782: ST_TO_ADDR
// if building in mc_lab [ i ] then
45783: LD_VAR 0 1
45787: PUSH
45788: LD_EXP 83
45792: PUSH
45793: LD_VAR 0 3
45797: ARRAY
45798: IN
45799: IFFALSE 45854
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
45801: LD_ADDR_EXP 84
45805: PUSH
45806: LD_EXP 84
45810: PPUSH
45811: LD_VAR 0 3
45815: PPUSH
45816: LD_EXP 84
45820: PUSH
45821: LD_VAR 0 3
45825: ARRAY
45826: PPUSH
45827: LD_INT 1
45829: PPUSH
45830: LD_EXP 84
45834: PUSH
45835: LD_VAR 0 3
45839: ARRAY
45840: PPUSH
45841: LD_INT 0
45843: PPUSH
45844: CALL 53805 0 4
45848: PPUSH
45849: CALL_OW 1
45853: ST_TO_ADDR
// if not building in mc_bases [ i ] then
45854: LD_VAR 0 1
45858: PUSH
45859: LD_EXP 50
45863: PUSH
45864: LD_VAR 0 3
45868: ARRAY
45869: IN
45870: NOT
45871: IFFALSE 45917
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
45873: LD_ADDR_EXP 50
45877: PUSH
45878: LD_EXP 50
45882: PPUSH
45883: LD_VAR 0 3
45887: PUSH
45888: LD_EXP 50
45892: PUSH
45893: LD_VAR 0 3
45897: ARRAY
45898: PUSH
45899: LD_INT 1
45901: PLUS
45902: PUSH
45903: EMPTY
45904: LIST
45905: LIST
45906: PPUSH
45907: LD_VAR 0 1
45911: PPUSH
45912: CALL 54387 0 3
45916: ST_TO_ADDR
// exit ;
45917: POP
45918: POP
45919: GO 45925
// end ; end ;
45921: GO 45725
45923: POP
45924: POP
// end ;
45925: LD_VAR 0 2
45929: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
45930: LD_INT 0
45932: PPUSH
45933: PPUSH
45934: PPUSH
45935: PPUSH
45936: PPUSH
45937: PPUSH
45938: PPUSH
// if not mc_bases or not skirmish then
45939: LD_EXP 50
45943: NOT
45944: PUSH
45945: LD_EXP 48
45949: NOT
45950: OR
45951: IFFALSE 45955
// exit ;
45953: GO 46616
// for i = 1 to mc_bases do
45955: LD_ADDR_VAR 0 3
45959: PUSH
45960: DOUBLE
45961: LD_INT 1
45963: DEC
45964: ST_TO_ADDR
45965: LD_EXP 50
45969: PUSH
45970: FOR_TO
45971: IFFALSE 46614
// begin if building in mc_construct_list [ i ] then
45973: LD_VAR 0 1
45977: PUSH
45978: LD_EXP 57
45982: PUSH
45983: LD_VAR 0 3
45987: ARRAY
45988: IN
45989: IFFALSE 46612
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
45991: LD_ADDR_EXP 57
45995: PUSH
45996: LD_EXP 57
46000: PPUSH
46001: LD_VAR 0 3
46005: PPUSH
46006: LD_EXP 57
46010: PUSH
46011: LD_VAR 0 3
46015: ARRAY
46016: PUSH
46017: LD_VAR 0 1
46021: DIFF
46022: PPUSH
46023: CALL_OW 1
46027: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
46028: LD_ADDR_EXP 50
46032: PUSH
46033: LD_EXP 50
46037: PPUSH
46038: LD_VAR 0 3
46042: PUSH
46043: LD_EXP 50
46047: PUSH
46048: LD_VAR 0 3
46052: ARRAY
46053: PUSH
46054: LD_INT 1
46056: PLUS
46057: PUSH
46058: EMPTY
46059: LIST
46060: LIST
46061: PPUSH
46062: LD_VAR 0 1
46066: PPUSH
46067: CALL 54387 0 3
46071: ST_TO_ADDR
// btype := GetBType ( building ) ;
46072: LD_ADDR_VAR 0 5
46076: PUSH
46077: LD_VAR 0 1
46081: PPUSH
46082: CALL_OW 266
46086: ST_TO_ADDR
// side := GetSide ( building ) ;
46087: LD_ADDR_VAR 0 8
46091: PUSH
46092: LD_VAR 0 1
46096: PPUSH
46097: CALL_OW 255
46101: ST_TO_ADDR
// if btype = b_lab then
46102: LD_VAR 0 5
46106: PUSH
46107: LD_INT 6
46109: EQUAL
46110: IFFALSE 46160
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
46112: LD_ADDR_EXP 83
46116: PUSH
46117: LD_EXP 83
46121: PPUSH
46122: LD_VAR 0 3
46126: PUSH
46127: LD_EXP 83
46131: PUSH
46132: LD_VAR 0 3
46136: ARRAY
46137: PUSH
46138: LD_INT 1
46140: PLUS
46141: PUSH
46142: EMPTY
46143: LIST
46144: LIST
46145: PPUSH
46146: LD_VAR 0 1
46150: PPUSH
46151: CALL 54387 0 3
46155: ST_TO_ADDR
// exit ;
46156: POP
46157: POP
46158: GO 46616
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
46160: LD_VAR 0 5
46164: PUSH
46165: LD_INT 0
46167: PUSH
46168: LD_INT 2
46170: PUSH
46171: LD_INT 4
46173: PUSH
46174: EMPTY
46175: LIST
46176: LIST
46177: LIST
46178: IN
46179: IFFALSE 46303
// begin if btype = b_armoury then
46181: LD_VAR 0 5
46185: PUSH
46186: LD_INT 4
46188: EQUAL
46189: IFFALSE 46199
// btype := b_barracks ;
46191: LD_ADDR_VAR 0 5
46195: PUSH
46196: LD_INT 5
46198: ST_TO_ADDR
// if btype = b_depot then
46199: LD_VAR 0 5
46203: PUSH
46204: LD_INT 0
46206: EQUAL
46207: IFFALSE 46217
// btype := b_warehouse ;
46209: LD_ADDR_VAR 0 5
46213: PUSH
46214: LD_INT 1
46216: ST_TO_ADDR
// if btype = b_workshop then
46217: LD_VAR 0 5
46221: PUSH
46222: LD_INT 2
46224: EQUAL
46225: IFFALSE 46235
// btype := b_factory ;
46227: LD_ADDR_VAR 0 5
46231: PUSH
46232: LD_INT 3
46234: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
46235: LD_VAR 0 5
46239: PPUSH
46240: LD_VAR 0 8
46244: PPUSH
46245: CALL_OW 323
46249: PUSH
46250: LD_INT 1
46252: EQUAL
46253: IFFALSE 46299
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
46255: LD_ADDR_EXP 82
46259: PUSH
46260: LD_EXP 82
46264: PPUSH
46265: LD_VAR 0 3
46269: PUSH
46270: LD_EXP 82
46274: PUSH
46275: LD_VAR 0 3
46279: ARRAY
46280: PUSH
46281: LD_INT 1
46283: PLUS
46284: PUSH
46285: EMPTY
46286: LIST
46287: LIST
46288: PPUSH
46289: LD_VAR 0 1
46293: PPUSH
46294: CALL 54387 0 3
46298: ST_TO_ADDR
// exit ;
46299: POP
46300: POP
46301: GO 46616
// end ; if btype in [ b_bunker , b_turret ] then
46303: LD_VAR 0 5
46307: PUSH
46308: LD_INT 32
46310: PUSH
46311: LD_INT 33
46313: PUSH
46314: EMPTY
46315: LIST
46316: LIST
46317: IN
46318: IFFALSE 46608
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
46320: LD_ADDR_EXP 58
46324: PUSH
46325: LD_EXP 58
46329: PPUSH
46330: LD_VAR 0 3
46334: PUSH
46335: LD_EXP 58
46339: PUSH
46340: LD_VAR 0 3
46344: ARRAY
46345: PUSH
46346: LD_INT 1
46348: PLUS
46349: PUSH
46350: EMPTY
46351: LIST
46352: LIST
46353: PPUSH
46354: LD_VAR 0 1
46358: PPUSH
46359: CALL 54387 0 3
46363: ST_TO_ADDR
// if btype = b_bunker then
46364: LD_VAR 0 5
46368: PUSH
46369: LD_INT 32
46371: EQUAL
46372: IFFALSE 46608
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
46374: LD_ADDR_EXP 59
46378: PUSH
46379: LD_EXP 59
46383: PPUSH
46384: LD_VAR 0 3
46388: PUSH
46389: LD_EXP 59
46393: PUSH
46394: LD_VAR 0 3
46398: ARRAY
46399: PUSH
46400: LD_INT 1
46402: PLUS
46403: PUSH
46404: EMPTY
46405: LIST
46406: LIST
46407: PPUSH
46408: LD_VAR 0 1
46412: PPUSH
46413: CALL 54387 0 3
46417: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
46418: LD_ADDR_VAR 0 6
46422: PUSH
46423: LD_EXP 50
46427: PUSH
46428: LD_VAR 0 3
46432: ARRAY
46433: PPUSH
46434: LD_INT 25
46436: PUSH
46437: LD_INT 1
46439: PUSH
46440: EMPTY
46441: LIST
46442: LIST
46443: PUSH
46444: LD_INT 3
46446: PUSH
46447: LD_INT 54
46449: PUSH
46450: EMPTY
46451: LIST
46452: PUSH
46453: EMPTY
46454: LIST
46455: LIST
46456: PUSH
46457: EMPTY
46458: LIST
46459: LIST
46460: PPUSH
46461: CALL_OW 72
46465: ST_TO_ADDR
// if tmp then
46466: LD_VAR 0 6
46470: IFFALSE 46476
// exit ;
46472: POP
46473: POP
46474: GO 46616
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
46476: LD_ADDR_VAR 0 6
46480: PUSH
46481: LD_EXP 50
46485: PUSH
46486: LD_VAR 0 3
46490: ARRAY
46491: PPUSH
46492: LD_INT 2
46494: PUSH
46495: LD_INT 30
46497: PUSH
46498: LD_INT 4
46500: PUSH
46501: EMPTY
46502: LIST
46503: LIST
46504: PUSH
46505: LD_INT 30
46507: PUSH
46508: LD_INT 5
46510: PUSH
46511: EMPTY
46512: LIST
46513: LIST
46514: PUSH
46515: EMPTY
46516: LIST
46517: LIST
46518: LIST
46519: PPUSH
46520: CALL_OW 72
46524: ST_TO_ADDR
// if not tmp then
46525: LD_VAR 0 6
46529: NOT
46530: IFFALSE 46536
// exit ;
46532: POP
46533: POP
46534: GO 46616
// for j in tmp do
46536: LD_ADDR_VAR 0 4
46540: PUSH
46541: LD_VAR 0 6
46545: PUSH
46546: FOR_IN
46547: IFFALSE 46606
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
46549: LD_ADDR_VAR 0 7
46553: PUSH
46554: LD_VAR 0 4
46558: PPUSH
46559: CALL_OW 313
46563: PPUSH
46564: LD_INT 25
46566: PUSH
46567: LD_INT 1
46569: PUSH
46570: EMPTY
46571: LIST
46572: LIST
46573: PPUSH
46574: CALL_OW 72
46578: ST_TO_ADDR
// if units then
46579: LD_VAR 0 7
46583: IFFALSE 46604
// begin ComExitBuilding ( units [ 1 ] ) ;
46585: LD_VAR 0 7
46589: PUSH
46590: LD_INT 1
46592: ARRAY
46593: PPUSH
46594: CALL_OW 122
// exit ;
46598: POP
46599: POP
46600: POP
46601: POP
46602: GO 46616
// end ; end ;
46604: GO 46546
46606: POP
46607: POP
// end ; end ; exit ;
46608: POP
46609: POP
46610: GO 46616
// end ; end ;
46612: GO 45970
46614: POP
46615: POP
// end ;
46616: LD_VAR 0 2
46620: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
46621: LD_INT 0
46623: PPUSH
46624: PPUSH
46625: PPUSH
46626: PPUSH
46627: PPUSH
46628: PPUSH
46629: PPUSH
// if not mc_bases or not skirmish then
46630: LD_EXP 50
46634: NOT
46635: PUSH
46636: LD_EXP 48
46640: NOT
46641: OR
46642: IFFALSE 46646
// exit ;
46644: GO 46877
// btype := GetBType ( building ) ;
46646: LD_ADDR_VAR 0 6
46650: PUSH
46651: LD_VAR 0 1
46655: PPUSH
46656: CALL_OW 266
46660: ST_TO_ADDR
// x := GetX ( building ) ;
46661: LD_ADDR_VAR 0 7
46665: PUSH
46666: LD_VAR 0 1
46670: PPUSH
46671: CALL_OW 250
46675: ST_TO_ADDR
// y := GetY ( building ) ;
46676: LD_ADDR_VAR 0 8
46680: PUSH
46681: LD_VAR 0 1
46685: PPUSH
46686: CALL_OW 251
46690: ST_TO_ADDR
// d := GetDir ( building ) ;
46691: LD_ADDR_VAR 0 9
46695: PUSH
46696: LD_VAR 0 1
46700: PPUSH
46701: CALL_OW 254
46705: ST_TO_ADDR
// for i = 1 to mc_bases do
46706: LD_ADDR_VAR 0 4
46710: PUSH
46711: DOUBLE
46712: LD_INT 1
46714: DEC
46715: ST_TO_ADDR
46716: LD_EXP 50
46720: PUSH
46721: FOR_TO
46722: IFFALSE 46875
// begin if not mc_build_list [ i ] then
46724: LD_EXP 55
46728: PUSH
46729: LD_VAR 0 4
46733: ARRAY
46734: NOT
46735: IFFALSE 46739
// continue ;
46737: GO 46721
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
46739: LD_VAR 0 6
46743: PUSH
46744: LD_VAR 0 7
46748: PUSH
46749: LD_VAR 0 8
46753: PUSH
46754: LD_VAR 0 9
46758: PUSH
46759: EMPTY
46760: LIST
46761: LIST
46762: LIST
46763: LIST
46764: PPUSH
46765: LD_EXP 55
46769: PUSH
46770: LD_VAR 0 4
46774: ARRAY
46775: PUSH
46776: LD_INT 1
46778: ARRAY
46779: PPUSH
46780: CALL 60556 0 2
46784: IFFALSE 46873
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
46786: LD_ADDR_EXP 55
46790: PUSH
46791: LD_EXP 55
46795: PPUSH
46796: LD_VAR 0 4
46800: PPUSH
46801: LD_EXP 55
46805: PUSH
46806: LD_VAR 0 4
46810: ARRAY
46811: PPUSH
46812: LD_INT 1
46814: PPUSH
46815: CALL_OW 3
46819: PPUSH
46820: CALL_OW 1
46824: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
46825: LD_ADDR_EXP 57
46829: PUSH
46830: LD_EXP 57
46834: PPUSH
46835: LD_VAR 0 4
46839: PUSH
46840: LD_EXP 57
46844: PUSH
46845: LD_VAR 0 4
46849: ARRAY
46850: PUSH
46851: LD_INT 1
46853: PLUS
46854: PUSH
46855: EMPTY
46856: LIST
46857: LIST
46858: PPUSH
46859: LD_VAR 0 1
46863: PPUSH
46864: CALL 54387 0 3
46868: ST_TO_ADDR
// exit ;
46869: POP
46870: POP
46871: GO 46877
// end ; end ;
46873: GO 46721
46875: POP
46876: POP
// end ;
46877: LD_VAR 0 3
46881: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
46882: LD_INT 0
46884: PPUSH
46885: PPUSH
46886: PPUSH
// if not mc_bases or not skirmish then
46887: LD_EXP 50
46891: NOT
46892: PUSH
46893: LD_EXP 48
46897: NOT
46898: OR
46899: IFFALSE 46903
// exit ;
46901: GO 47093
// for i = 1 to mc_bases do
46903: LD_ADDR_VAR 0 4
46907: PUSH
46908: DOUBLE
46909: LD_INT 1
46911: DEC
46912: ST_TO_ADDR
46913: LD_EXP 50
46917: PUSH
46918: FOR_TO
46919: IFFALSE 47006
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
46921: LD_VAR 0 1
46925: PUSH
46926: LD_EXP 58
46930: PUSH
46931: LD_VAR 0 4
46935: ARRAY
46936: IN
46937: PUSH
46938: LD_VAR 0 1
46942: PUSH
46943: LD_EXP 59
46947: PUSH
46948: LD_VAR 0 4
46952: ARRAY
46953: IN
46954: NOT
46955: AND
46956: IFFALSE 47004
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
46958: LD_ADDR_EXP 59
46962: PUSH
46963: LD_EXP 59
46967: PPUSH
46968: LD_VAR 0 4
46972: PUSH
46973: LD_EXP 59
46977: PUSH
46978: LD_VAR 0 4
46982: ARRAY
46983: PUSH
46984: LD_INT 1
46986: PLUS
46987: PUSH
46988: EMPTY
46989: LIST
46990: LIST
46991: PPUSH
46992: LD_VAR 0 1
46996: PPUSH
46997: CALL 54387 0 3
47001: ST_TO_ADDR
// break ;
47002: GO 47006
// end ; end ;
47004: GO 46918
47006: POP
47007: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
47008: LD_VAR 0 1
47012: PPUSH
47013: CALL_OW 257
47017: PUSH
47018: LD_EXP 76
47022: IN
47023: PUSH
47024: LD_VAR 0 1
47028: PPUSH
47029: CALL_OW 266
47033: PUSH
47034: LD_INT 5
47036: EQUAL
47037: AND
47038: PUSH
47039: LD_VAR 0 2
47043: PPUSH
47044: CALL_OW 110
47048: PUSH
47049: LD_INT 18
47051: NONEQUAL
47052: AND
47053: IFFALSE 47093
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
47055: LD_VAR 0 2
47059: PPUSH
47060: CALL_OW 257
47064: PUSH
47065: LD_INT 5
47067: PUSH
47068: LD_INT 8
47070: PUSH
47071: LD_INT 9
47073: PUSH
47074: EMPTY
47075: LIST
47076: LIST
47077: LIST
47078: IN
47079: IFFALSE 47093
// SetClass ( unit , 1 ) ;
47081: LD_VAR 0 2
47085: PPUSH
47086: LD_INT 1
47088: PPUSH
47089: CALL_OW 336
// end ;
47093: LD_VAR 0 3
47097: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
47098: LD_INT 0
47100: PPUSH
47101: PPUSH
// if not mc_bases or not skirmish then
47102: LD_EXP 50
47106: NOT
47107: PUSH
47108: LD_EXP 48
47112: NOT
47113: OR
47114: IFFALSE 47118
// exit ;
47116: GO 47234
// if GetLives ( abandoned_vehicle ) > 250 then
47118: LD_VAR 0 2
47122: PPUSH
47123: CALL_OW 256
47127: PUSH
47128: LD_INT 250
47130: GREATER
47131: IFFALSE 47135
// exit ;
47133: GO 47234
// for i = 1 to mc_bases do
47135: LD_ADDR_VAR 0 6
47139: PUSH
47140: DOUBLE
47141: LD_INT 1
47143: DEC
47144: ST_TO_ADDR
47145: LD_EXP 50
47149: PUSH
47150: FOR_TO
47151: IFFALSE 47232
// begin if driver in mc_bases [ i ] then
47153: LD_VAR 0 1
47157: PUSH
47158: LD_EXP 50
47162: PUSH
47163: LD_VAR 0 6
47167: ARRAY
47168: IN
47169: IFFALSE 47230
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
47171: LD_VAR 0 1
47175: PPUSH
47176: LD_EXP 50
47180: PUSH
47181: LD_VAR 0 6
47185: ARRAY
47186: PPUSH
47187: LD_INT 2
47189: PUSH
47190: LD_INT 30
47192: PUSH
47193: LD_INT 0
47195: PUSH
47196: EMPTY
47197: LIST
47198: LIST
47199: PUSH
47200: LD_INT 30
47202: PUSH
47203: LD_INT 1
47205: PUSH
47206: EMPTY
47207: LIST
47208: LIST
47209: PUSH
47210: EMPTY
47211: LIST
47212: LIST
47213: LIST
47214: PPUSH
47215: CALL_OW 72
47219: PUSH
47220: LD_INT 1
47222: ARRAY
47223: PPUSH
47224: CALL_OW 112
// break ;
47228: GO 47232
// end ; end ;
47230: GO 47150
47232: POP
47233: POP
// end ; end_of_file
47234: LD_VAR 0 5
47238: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
47239: LD_INT 0
47241: PPUSH
47242: PPUSH
// if exist_mode then
47243: LD_VAR 0 2
47247: IFFALSE 47272
// unit := CreateCharacter ( prefix & ident ) else
47249: LD_ADDR_VAR 0 5
47253: PUSH
47254: LD_VAR 0 3
47258: PUSH
47259: LD_VAR 0 1
47263: STR
47264: PPUSH
47265: CALL_OW 34
47269: ST_TO_ADDR
47270: GO 47287
// unit := NewCharacter ( ident ) ;
47272: LD_ADDR_VAR 0 5
47276: PUSH
47277: LD_VAR 0 1
47281: PPUSH
47282: CALL_OW 25
47286: ST_TO_ADDR
// result := unit ;
47287: LD_ADDR_VAR 0 4
47291: PUSH
47292: LD_VAR 0 5
47296: ST_TO_ADDR
// end ;
47297: LD_VAR 0 4
47301: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
47302: LD_INT 0
47304: PPUSH
47305: PPUSH
// if not side or not nation then
47306: LD_VAR 0 1
47310: NOT
47311: PUSH
47312: LD_VAR 0 2
47316: NOT
47317: OR
47318: IFFALSE 47322
// exit ;
47320: GO 47966
// case nation of nation_american :
47322: LD_VAR 0 2
47326: PUSH
47327: LD_INT 1
47329: DOUBLE
47330: EQUAL
47331: IFTRUE 47335
47333: GO 47509
47335: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 ] ; nation_arabian :
47336: LD_ADDR_VAR 0 4
47340: PUSH
47341: LD_INT 35
47343: PUSH
47344: LD_INT 45
47346: PUSH
47347: LD_INT 46
47349: PUSH
47350: LD_INT 47
47352: PUSH
47353: LD_INT 1
47355: PUSH
47356: LD_INT 2
47358: PUSH
47359: LD_INT 6
47361: PUSH
47362: LD_INT 15
47364: PUSH
47365: LD_INT 16
47367: PUSH
47368: LD_INT 7
47370: PUSH
47371: LD_INT 12
47373: PUSH
47374: LD_INT 13
47376: PUSH
47377: LD_INT 10
47379: PUSH
47380: LD_INT 14
47382: PUSH
47383: LD_INT 20
47385: PUSH
47386: LD_INT 21
47388: PUSH
47389: LD_INT 22
47391: PUSH
47392: LD_INT 25
47394: PUSH
47395: LD_INT 32
47397: PUSH
47398: LD_INT 27
47400: PUSH
47401: LD_INT 36
47403: PUSH
47404: LD_INT 69
47406: PUSH
47407: LD_INT 39
47409: PUSH
47410: LD_INT 34
47412: PUSH
47413: LD_INT 40
47415: PUSH
47416: LD_INT 48
47418: PUSH
47419: LD_INT 49
47421: PUSH
47422: LD_INT 50
47424: PUSH
47425: LD_INT 51
47427: PUSH
47428: LD_INT 52
47430: PUSH
47431: LD_INT 53
47433: PUSH
47434: LD_INT 54
47436: PUSH
47437: LD_INT 55
47439: PUSH
47440: LD_INT 56
47442: PUSH
47443: LD_INT 57
47445: PUSH
47446: LD_INT 58
47448: PUSH
47449: LD_INT 59
47451: PUSH
47452: LD_INT 60
47454: PUSH
47455: LD_INT 61
47457: PUSH
47458: LD_INT 62
47460: PUSH
47461: LD_INT 80
47463: PUSH
47464: EMPTY
47465: LIST
47466: LIST
47467: LIST
47468: LIST
47469: LIST
47470: LIST
47471: LIST
47472: LIST
47473: LIST
47474: LIST
47475: LIST
47476: LIST
47477: LIST
47478: LIST
47479: LIST
47480: LIST
47481: LIST
47482: LIST
47483: LIST
47484: LIST
47485: LIST
47486: LIST
47487: LIST
47488: LIST
47489: LIST
47490: LIST
47491: LIST
47492: LIST
47493: LIST
47494: LIST
47495: LIST
47496: LIST
47497: LIST
47498: LIST
47499: LIST
47500: LIST
47501: LIST
47502: LIST
47503: LIST
47504: LIST
47505: LIST
47506: ST_TO_ADDR
47507: GO 47890
47509: LD_INT 2
47511: DOUBLE
47512: EQUAL
47513: IFTRUE 47517
47515: GO 47699
47517: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 ] ; nation_russian :
47518: LD_ADDR_VAR 0 4
47522: PUSH
47523: LD_INT 35
47525: PUSH
47526: LD_INT 45
47528: PUSH
47529: LD_INT 46
47531: PUSH
47532: LD_INT 47
47534: PUSH
47535: LD_INT 70
47537: PUSH
47538: LD_INT 1
47540: PUSH
47541: LD_INT 11
47543: PUSH
47544: LD_INT 3
47546: PUSH
47547: LD_INT 4
47549: PUSH
47550: LD_INT 5
47552: PUSH
47553: LD_INT 6
47555: PUSH
47556: LD_INT 15
47558: PUSH
47559: LD_INT 18
47561: PUSH
47562: LD_INT 7
47564: PUSH
47565: LD_INT 17
47567: PUSH
47568: LD_INT 8
47570: PUSH
47571: LD_INT 20
47573: PUSH
47574: LD_INT 21
47576: PUSH
47577: LD_INT 22
47579: PUSH
47580: LD_INT 72
47582: PUSH
47583: LD_INT 26
47585: PUSH
47586: LD_INT 69
47588: PUSH
47589: LD_INT 39
47591: PUSH
47592: LD_INT 40
47594: PUSH
47595: LD_INT 41
47597: PUSH
47598: LD_INT 42
47600: PUSH
47601: LD_INT 43
47603: PUSH
47604: LD_INT 48
47606: PUSH
47607: LD_INT 49
47609: PUSH
47610: LD_INT 50
47612: PUSH
47613: LD_INT 51
47615: PUSH
47616: LD_INT 52
47618: PUSH
47619: LD_INT 53
47621: PUSH
47622: LD_INT 54
47624: PUSH
47625: LD_INT 55
47627: PUSH
47628: LD_INT 56
47630: PUSH
47631: LD_INT 60
47633: PUSH
47634: LD_INT 61
47636: PUSH
47637: LD_INT 62
47639: PUSH
47640: LD_INT 66
47642: PUSH
47643: LD_INT 67
47645: PUSH
47646: LD_INT 68
47648: PUSH
47649: LD_INT 81
47651: PUSH
47652: EMPTY
47653: LIST
47654: LIST
47655: LIST
47656: LIST
47657: LIST
47658: LIST
47659: LIST
47660: LIST
47661: LIST
47662: LIST
47663: LIST
47664: LIST
47665: LIST
47666: LIST
47667: LIST
47668: LIST
47669: LIST
47670: LIST
47671: LIST
47672: LIST
47673: LIST
47674: LIST
47675: LIST
47676: LIST
47677: LIST
47678: LIST
47679: LIST
47680: LIST
47681: LIST
47682: LIST
47683: LIST
47684: LIST
47685: LIST
47686: LIST
47687: LIST
47688: LIST
47689: LIST
47690: LIST
47691: LIST
47692: LIST
47693: LIST
47694: LIST
47695: LIST
47696: ST_TO_ADDR
47697: GO 47890
47699: LD_INT 3
47701: DOUBLE
47702: EQUAL
47703: IFTRUE 47707
47705: GO 47889
47707: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
47708: LD_ADDR_VAR 0 4
47712: PUSH
47713: LD_INT 46
47715: PUSH
47716: LD_INT 47
47718: PUSH
47719: LD_INT 1
47721: PUSH
47722: LD_INT 2
47724: PUSH
47725: LD_INT 11
47727: PUSH
47728: LD_INT 9
47730: PUSH
47731: LD_INT 20
47733: PUSH
47734: LD_INT 19
47736: PUSH
47737: LD_INT 21
47739: PUSH
47740: LD_INT 24
47742: PUSH
47743: LD_INT 22
47745: PUSH
47746: LD_INT 25
47748: PUSH
47749: LD_INT 28
47751: PUSH
47752: LD_INT 29
47754: PUSH
47755: LD_INT 30
47757: PUSH
47758: LD_INT 31
47760: PUSH
47761: LD_INT 37
47763: PUSH
47764: LD_INT 38
47766: PUSH
47767: LD_INT 32
47769: PUSH
47770: LD_INT 27
47772: PUSH
47773: LD_INT 33
47775: PUSH
47776: LD_INT 69
47778: PUSH
47779: LD_INT 39
47781: PUSH
47782: LD_INT 34
47784: PUSH
47785: LD_INT 40
47787: PUSH
47788: LD_INT 71
47790: PUSH
47791: LD_INT 23
47793: PUSH
47794: LD_INT 44
47796: PUSH
47797: LD_INT 48
47799: PUSH
47800: LD_INT 49
47802: PUSH
47803: LD_INT 50
47805: PUSH
47806: LD_INT 51
47808: PUSH
47809: LD_INT 52
47811: PUSH
47812: LD_INT 53
47814: PUSH
47815: LD_INT 54
47817: PUSH
47818: LD_INT 55
47820: PUSH
47821: LD_INT 56
47823: PUSH
47824: LD_INT 57
47826: PUSH
47827: LD_INT 58
47829: PUSH
47830: LD_INT 59
47832: PUSH
47833: LD_INT 63
47835: PUSH
47836: LD_INT 64
47838: PUSH
47839: LD_INT 65
47841: PUSH
47842: EMPTY
47843: LIST
47844: LIST
47845: LIST
47846: LIST
47847: LIST
47848: LIST
47849: LIST
47850: LIST
47851: LIST
47852: LIST
47853: LIST
47854: LIST
47855: LIST
47856: LIST
47857: LIST
47858: LIST
47859: LIST
47860: LIST
47861: LIST
47862: LIST
47863: LIST
47864: LIST
47865: LIST
47866: LIST
47867: LIST
47868: LIST
47869: LIST
47870: LIST
47871: LIST
47872: LIST
47873: LIST
47874: LIST
47875: LIST
47876: LIST
47877: LIST
47878: LIST
47879: LIST
47880: LIST
47881: LIST
47882: LIST
47883: LIST
47884: LIST
47885: LIST
47886: ST_TO_ADDR
47887: GO 47890
47889: POP
// if state > - 1 and state < 3 then
47890: LD_VAR 0 3
47894: PUSH
47895: LD_INT 1
47897: NEG
47898: GREATER
47899: PUSH
47900: LD_VAR 0 3
47904: PUSH
47905: LD_INT 3
47907: LESS
47908: AND
47909: IFFALSE 47966
// for i in result do
47911: LD_ADDR_VAR 0 5
47915: PUSH
47916: LD_VAR 0 4
47920: PUSH
47921: FOR_IN
47922: IFFALSE 47964
// if GetTech ( i , side ) <> state then
47924: LD_VAR 0 5
47928: PPUSH
47929: LD_VAR 0 1
47933: PPUSH
47934: CALL_OW 321
47938: PUSH
47939: LD_VAR 0 3
47943: NONEQUAL
47944: IFFALSE 47962
// result := result diff i ;
47946: LD_ADDR_VAR 0 4
47950: PUSH
47951: LD_VAR 0 4
47955: PUSH
47956: LD_VAR 0 5
47960: DIFF
47961: ST_TO_ADDR
47962: GO 47921
47964: POP
47965: POP
// end ;
47966: LD_VAR 0 4
47970: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
47971: LD_INT 0
47973: PPUSH
47974: PPUSH
47975: PPUSH
// result := true ;
47976: LD_ADDR_VAR 0 3
47980: PUSH
47981: LD_INT 1
47983: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
47984: LD_ADDR_VAR 0 5
47988: PUSH
47989: LD_VAR 0 2
47993: PPUSH
47994: CALL_OW 480
47998: ST_TO_ADDR
// if not tmp then
47999: LD_VAR 0 5
48003: NOT
48004: IFFALSE 48008
// exit ;
48006: GO 48057
// for i in tmp do
48008: LD_ADDR_VAR 0 4
48012: PUSH
48013: LD_VAR 0 5
48017: PUSH
48018: FOR_IN
48019: IFFALSE 48055
// if GetTech ( i , side ) <> state_researched then
48021: LD_VAR 0 4
48025: PPUSH
48026: LD_VAR 0 1
48030: PPUSH
48031: CALL_OW 321
48035: PUSH
48036: LD_INT 2
48038: NONEQUAL
48039: IFFALSE 48053
// begin result := false ;
48041: LD_ADDR_VAR 0 3
48045: PUSH
48046: LD_INT 0
48048: ST_TO_ADDR
// exit ;
48049: POP
48050: POP
48051: GO 48057
// end ;
48053: GO 48018
48055: POP
48056: POP
// end ;
48057: LD_VAR 0 3
48061: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
48062: LD_INT 0
48064: PPUSH
48065: PPUSH
48066: PPUSH
48067: PPUSH
48068: PPUSH
48069: PPUSH
48070: PPUSH
48071: PPUSH
48072: PPUSH
48073: PPUSH
48074: PPUSH
48075: PPUSH
48076: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
48077: LD_VAR 0 1
48081: NOT
48082: PUSH
48083: LD_VAR 0 1
48087: PPUSH
48088: CALL_OW 257
48092: PUSH
48093: LD_INT 9
48095: NONEQUAL
48096: OR
48097: IFFALSE 48101
// exit ;
48099: GO 48674
// side := GetSide ( unit ) ;
48101: LD_ADDR_VAR 0 9
48105: PUSH
48106: LD_VAR 0 1
48110: PPUSH
48111: CALL_OW 255
48115: ST_TO_ADDR
// tech_space := tech_spacanom ;
48116: LD_ADDR_VAR 0 12
48120: PUSH
48121: LD_INT 29
48123: ST_TO_ADDR
// tech_time := tech_taurad ;
48124: LD_ADDR_VAR 0 13
48128: PUSH
48129: LD_INT 28
48131: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
48132: LD_ADDR_VAR 0 11
48136: PUSH
48137: LD_VAR 0 1
48141: PPUSH
48142: CALL_OW 310
48146: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
48147: LD_VAR 0 11
48151: PPUSH
48152: CALL_OW 247
48156: PUSH
48157: LD_INT 2
48159: EQUAL
48160: IFFALSE 48164
// exit ;
48162: GO 48674
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
48164: LD_ADDR_VAR 0 8
48168: PUSH
48169: LD_INT 81
48171: PUSH
48172: LD_VAR 0 9
48176: PUSH
48177: EMPTY
48178: LIST
48179: LIST
48180: PUSH
48181: LD_INT 3
48183: PUSH
48184: LD_INT 21
48186: PUSH
48187: LD_INT 3
48189: PUSH
48190: EMPTY
48191: LIST
48192: LIST
48193: PUSH
48194: EMPTY
48195: LIST
48196: LIST
48197: PUSH
48198: EMPTY
48199: LIST
48200: LIST
48201: PPUSH
48202: CALL_OW 69
48206: ST_TO_ADDR
// if not tmp then
48207: LD_VAR 0 8
48211: NOT
48212: IFFALSE 48216
// exit ;
48214: GO 48674
// if in_unit then
48216: LD_VAR 0 11
48220: IFFALSE 48244
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
48222: LD_ADDR_VAR 0 10
48226: PUSH
48227: LD_VAR 0 8
48231: PPUSH
48232: LD_VAR 0 11
48236: PPUSH
48237: CALL_OW 74
48241: ST_TO_ADDR
48242: GO 48264
// enemy := NearestUnitToUnit ( tmp , unit ) ;
48244: LD_ADDR_VAR 0 10
48248: PUSH
48249: LD_VAR 0 8
48253: PPUSH
48254: LD_VAR 0 1
48258: PPUSH
48259: CALL_OW 74
48263: ST_TO_ADDR
// if not enemy then
48264: LD_VAR 0 10
48268: NOT
48269: IFFALSE 48273
// exit ;
48271: GO 48674
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
48273: LD_VAR 0 11
48277: PUSH
48278: LD_VAR 0 11
48282: PPUSH
48283: LD_VAR 0 10
48287: PPUSH
48288: CALL_OW 296
48292: PUSH
48293: LD_INT 13
48295: GREATER
48296: AND
48297: PUSH
48298: LD_VAR 0 1
48302: PPUSH
48303: LD_VAR 0 10
48307: PPUSH
48308: CALL_OW 296
48312: PUSH
48313: LD_INT 12
48315: GREATER
48316: OR
48317: IFFALSE 48321
// exit ;
48319: GO 48674
// missile := [ 1 ] ;
48321: LD_ADDR_VAR 0 14
48325: PUSH
48326: LD_INT 1
48328: PUSH
48329: EMPTY
48330: LIST
48331: ST_TO_ADDR
// if Researched ( side , tech_space ) then
48332: LD_VAR 0 9
48336: PPUSH
48337: LD_VAR 0 12
48341: PPUSH
48342: CALL_OW 325
48346: IFFALSE 48375
// missile := Insert ( missile , missile + 1 , 2 ) ;
48348: LD_ADDR_VAR 0 14
48352: PUSH
48353: LD_VAR 0 14
48357: PPUSH
48358: LD_VAR 0 14
48362: PUSH
48363: LD_INT 1
48365: PLUS
48366: PPUSH
48367: LD_INT 2
48369: PPUSH
48370: CALL_OW 2
48374: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
48375: LD_VAR 0 9
48379: PPUSH
48380: LD_VAR 0 13
48384: PPUSH
48385: CALL_OW 325
48389: PUSH
48390: LD_VAR 0 10
48394: PPUSH
48395: CALL_OW 255
48399: PPUSH
48400: LD_VAR 0 13
48404: PPUSH
48405: CALL_OW 325
48409: NOT
48410: AND
48411: IFFALSE 48440
// missile := Insert ( missile , missile + 1 , 3 ) ;
48413: LD_ADDR_VAR 0 14
48417: PUSH
48418: LD_VAR 0 14
48422: PPUSH
48423: LD_VAR 0 14
48427: PUSH
48428: LD_INT 1
48430: PLUS
48431: PPUSH
48432: LD_INT 3
48434: PPUSH
48435: CALL_OW 2
48439: ST_TO_ADDR
// if missile < 2 then
48440: LD_VAR 0 14
48444: PUSH
48445: LD_INT 2
48447: LESS
48448: IFFALSE 48452
// exit ;
48450: GO 48674
// x := GetX ( enemy ) ;
48452: LD_ADDR_VAR 0 4
48456: PUSH
48457: LD_VAR 0 10
48461: PPUSH
48462: CALL_OW 250
48466: ST_TO_ADDR
// y := GetY ( enemy ) ;
48467: LD_ADDR_VAR 0 5
48471: PUSH
48472: LD_VAR 0 10
48476: PPUSH
48477: CALL_OW 251
48481: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
48482: LD_ADDR_VAR 0 6
48486: PUSH
48487: LD_VAR 0 4
48491: PUSH
48492: LD_INT 1
48494: NEG
48495: PPUSH
48496: LD_INT 1
48498: PPUSH
48499: CALL_OW 12
48503: PLUS
48504: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
48505: LD_ADDR_VAR 0 7
48509: PUSH
48510: LD_VAR 0 5
48514: PUSH
48515: LD_INT 1
48517: NEG
48518: PPUSH
48519: LD_INT 1
48521: PPUSH
48522: CALL_OW 12
48526: PLUS
48527: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
48528: LD_VAR 0 6
48532: PPUSH
48533: LD_VAR 0 7
48537: PPUSH
48538: CALL_OW 488
48542: NOT
48543: IFFALSE 48565
// begin _x := x ;
48545: LD_ADDR_VAR 0 6
48549: PUSH
48550: LD_VAR 0 4
48554: ST_TO_ADDR
// _y := y ;
48555: LD_ADDR_VAR 0 7
48559: PUSH
48560: LD_VAR 0 5
48564: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
48565: LD_ADDR_VAR 0 3
48569: PUSH
48570: LD_INT 1
48572: PPUSH
48573: LD_VAR 0 14
48577: PPUSH
48578: CALL_OW 12
48582: ST_TO_ADDR
// case i of 1 :
48583: LD_VAR 0 3
48587: PUSH
48588: LD_INT 1
48590: DOUBLE
48591: EQUAL
48592: IFTRUE 48596
48594: GO 48613
48596: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
48597: LD_VAR 0 1
48601: PPUSH
48602: LD_VAR 0 10
48606: PPUSH
48607: CALL_OW 115
48611: GO 48674
48613: LD_INT 2
48615: DOUBLE
48616: EQUAL
48617: IFTRUE 48621
48619: GO 48643
48621: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
48622: LD_VAR 0 1
48626: PPUSH
48627: LD_VAR 0 6
48631: PPUSH
48632: LD_VAR 0 7
48636: PPUSH
48637: CALL_OW 153
48641: GO 48674
48643: LD_INT 3
48645: DOUBLE
48646: EQUAL
48647: IFTRUE 48651
48649: GO 48673
48651: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
48652: LD_VAR 0 1
48656: PPUSH
48657: LD_VAR 0 6
48661: PPUSH
48662: LD_VAR 0 7
48666: PPUSH
48667: CALL_OW 154
48671: GO 48674
48673: POP
// end ;
48674: LD_VAR 0 2
48678: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
48679: LD_INT 0
48681: PPUSH
48682: PPUSH
48683: PPUSH
48684: PPUSH
48685: PPUSH
48686: PPUSH
// if not unit or not building then
48687: LD_VAR 0 1
48691: NOT
48692: PUSH
48693: LD_VAR 0 2
48697: NOT
48698: OR
48699: IFFALSE 48703
// exit ;
48701: GO 48861
// x := GetX ( building ) ;
48703: LD_ADDR_VAR 0 5
48707: PUSH
48708: LD_VAR 0 2
48712: PPUSH
48713: CALL_OW 250
48717: ST_TO_ADDR
// y := GetY ( building ) ;
48718: LD_ADDR_VAR 0 6
48722: PUSH
48723: LD_VAR 0 2
48727: PPUSH
48728: CALL_OW 251
48732: ST_TO_ADDR
// for i = 0 to 5 do
48733: LD_ADDR_VAR 0 4
48737: PUSH
48738: DOUBLE
48739: LD_INT 0
48741: DEC
48742: ST_TO_ADDR
48743: LD_INT 5
48745: PUSH
48746: FOR_TO
48747: IFFALSE 48859
// begin _x := ShiftX ( x , i , 3 ) ;
48749: LD_ADDR_VAR 0 7
48753: PUSH
48754: LD_VAR 0 5
48758: PPUSH
48759: LD_VAR 0 4
48763: PPUSH
48764: LD_INT 3
48766: PPUSH
48767: CALL_OW 272
48771: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
48772: LD_ADDR_VAR 0 8
48776: PUSH
48777: LD_VAR 0 6
48781: PPUSH
48782: LD_VAR 0 4
48786: PPUSH
48787: LD_INT 3
48789: PPUSH
48790: CALL_OW 273
48794: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
48795: LD_VAR 0 7
48799: PPUSH
48800: LD_VAR 0 8
48804: PPUSH
48805: CALL_OW 488
48809: NOT
48810: IFFALSE 48814
// continue ;
48812: GO 48746
// if HexInfo ( _x , _y ) = 0 then
48814: LD_VAR 0 7
48818: PPUSH
48819: LD_VAR 0 8
48823: PPUSH
48824: CALL_OW 428
48828: PUSH
48829: LD_INT 0
48831: EQUAL
48832: IFFALSE 48857
// begin ComMoveXY ( unit , _x , _y ) ;
48834: LD_VAR 0 1
48838: PPUSH
48839: LD_VAR 0 7
48843: PPUSH
48844: LD_VAR 0 8
48848: PPUSH
48849: CALL_OW 111
// exit ;
48853: POP
48854: POP
48855: GO 48861
// end ; end ;
48857: GO 48746
48859: POP
48860: POP
// end ;
48861: LD_VAR 0 3
48865: RET
// export function ScanBase ( side , base_area ) ; begin
48866: LD_INT 0
48868: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
48869: LD_ADDR_VAR 0 3
48873: PUSH
48874: LD_VAR 0 2
48878: PPUSH
48879: LD_INT 81
48881: PUSH
48882: LD_VAR 0 1
48886: PUSH
48887: EMPTY
48888: LIST
48889: LIST
48890: PPUSH
48891: CALL_OW 70
48895: ST_TO_ADDR
// end ;
48896: LD_VAR 0 3
48900: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
48901: LD_INT 0
48903: PPUSH
48904: PPUSH
48905: PPUSH
48906: PPUSH
48907: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
48908: LD_VAR 0 1
48912: NOT
48913: PUSH
48914: LD_EXP 50
48918: PUSH
48919: LD_VAR 0 1
48923: ARRAY
48924: NOT
48925: OR
48926: PUSH
48927: LD_VAR 0 2
48931: NOT
48932: OR
48933: PUSH
48934: LD_VAR 0 3
48938: NOT
48939: OR
48940: IFFALSE 48944
// exit ;
48942: GO 49457
// side := mc_sides [ base ] ;
48944: LD_ADDR_VAR 0 6
48948: PUSH
48949: LD_EXP 76
48953: PUSH
48954: LD_VAR 0 1
48958: ARRAY
48959: ST_TO_ADDR
// if not side then
48960: LD_VAR 0 6
48964: NOT
48965: IFFALSE 48969
// exit ;
48967: GO 49457
// for i in solds do
48969: LD_ADDR_VAR 0 7
48973: PUSH
48974: LD_VAR 0 2
48978: PUSH
48979: FOR_IN
48980: IFFALSE 49041
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
48982: LD_VAR 0 7
48986: PPUSH
48987: CALL_OW 310
48991: PPUSH
48992: CALL_OW 266
48996: PUSH
48997: LD_INT 32
48999: PUSH
49000: LD_INT 31
49002: PUSH
49003: EMPTY
49004: LIST
49005: LIST
49006: IN
49007: IFFALSE 49027
// solds := solds diff i else
49009: LD_ADDR_VAR 0 2
49013: PUSH
49014: LD_VAR 0 2
49018: PUSH
49019: LD_VAR 0 7
49023: DIFF
49024: ST_TO_ADDR
49025: GO 49039
// SetTag ( i , 18 ) ;
49027: LD_VAR 0 7
49031: PPUSH
49032: LD_INT 18
49034: PPUSH
49035: CALL_OW 109
49039: GO 48979
49041: POP
49042: POP
// if not solds then
49043: LD_VAR 0 2
49047: NOT
49048: IFFALSE 49052
// exit ;
49050: GO 49457
// repeat wait ( 0 0$1 ) ;
49052: LD_INT 35
49054: PPUSH
49055: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
49059: LD_ADDR_VAR 0 5
49063: PUSH
49064: LD_VAR 0 6
49068: PPUSH
49069: LD_VAR 0 3
49073: PPUSH
49074: CALL 48866 0 2
49078: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
49079: LD_EXP 50
49083: PUSH
49084: LD_VAR 0 1
49088: ARRAY
49089: NOT
49090: PUSH
49091: LD_EXP 50
49095: PUSH
49096: LD_VAR 0 1
49100: ARRAY
49101: PUSH
49102: EMPTY
49103: EQUAL
49104: OR
49105: IFFALSE 49142
// begin for i in solds do
49107: LD_ADDR_VAR 0 7
49111: PUSH
49112: LD_VAR 0 2
49116: PUSH
49117: FOR_IN
49118: IFFALSE 49131
// ComStop ( i ) ;
49120: LD_VAR 0 7
49124: PPUSH
49125: CALL_OW 141
49129: GO 49117
49131: POP
49132: POP
// solds := [ ] ;
49133: LD_ADDR_VAR 0 2
49137: PUSH
49138: EMPTY
49139: ST_TO_ADDR
// exit ;
49140: GO 49457
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
49142: LD_VAR 0 5
49146: NOT
49147: PUSH
49148: LD_VAR 0 5
49152: PUSH
49153: LD_INT 3
49155: GREATER
49156: OR
49157: PUSH
49158: LD_EXP 72
49162: PUSH
49163: LD_VAR 0 1
49167: ARRAY
49168: OR
49169: IFFALSE 49210
// begin for i in solds do
49171: LD_ADDR_VAR 0 7
49175: PUSH
49176: LD_VAR 0 2
49180: PUSH
49181: FOR_IN
49182: IFFALSE 49206
// if HasTask ( i ) then
49184: LD_VAR 0 7
49188: PPUSH
49189: CALL_OW 314
49193: IFFALSE 49204
// ComStop ( i ) ;
49195: LD_VAR 0 7
49199: PPUSH
49200: CALL_OW 141
49204: GO 49181
49206: POP
49207: POP
// break ;
49208: GO 49445
// end ; for i in solds do
49210: LD_ADDR_VAR 0 7
49214: PUSH
49215: LD_VAR 0 2
49219: PUSH
49220: FOR_IN
49221: IFFALSE 49437
// begin if IsInUnit ( i ) then
49223: LD_VAR 0 7
49227: PPUSH
49228: CALL_OW 310
49232: IFFALSE 49243
// ComExitBuilding ( i ) ;
49234: LD_VAR 0 7
49238: PPUSH
49239: CALL_OW 122
// if GetLives ( i ) > 333 then
49243: LD_VAR 0 7
49247: PPUSH
49248: CALL_OW 256
49252: PUSH
49253: LD_INT 333
49255: GREATER
49256: IFFALSE 49284
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
49258: LD_VAR 0 7
49262: PPUSH
49263: LD_VAR 0 5
49267: PPUSH
49268: LD_VAR 0 7
49272: PPUSH
49273: CALL_OW 74
49277: PPUSH
49278: CALL_OW 115
49282: GO 49435
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
49284: LD_ADDR_VAR 0 8
49288: PUSH
49289: LD_EXP 50
49293: PUSH
49294: LD_VAR 0 1
49298: ARRAY
49299: PPUSH
49300: LD_INT 2
49302: PUSH
49303: LD_INT 30
49305: PUSH
49306: LD_INT 0
49308: PUSH
49309: EMPTY
49310: LIST
49311: LIST
49312: PUSH
49313: LD_INT 30
49315: PUSH
49316: LD_INT 1
49318: PUSH
49319: EMPTY
49320: LIST
49321: LIST
49322: PUSH
49323: LD_INT 30
49325: PUSH
49326: LD_INT 6
49328: PUSH
49329: EMPTY
49330: LIST
49331: LIST
49332: PUSH
49333: EMPTY
49334: LIST
49335: LIST
49336: LIST
49337: LIST
49338: PPUSH
49339: CALL_OW 72
49343: PPUSH
49344: LD_VAR 0 7
49348: PPUSH
49349: CALL_OW 74
49353: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
49354: LD_VAR 0 7
49358: PPUSH
49359: LD_VAR 0 8
49363: PPUSH
49364: CALL_OW 250
49368: PPUSH
49369: LD_INT 3
49371: PPUSH
49372: LD_INT 5
49374: PPUSH
49375: CALL_OW 272
49379: PPUSH
49380: LD_VAR 0 8
49384: PPUSH
49385: CALL_OW 251
49389: PPUSH
49390: LD_INT 3
49392: PPUSH
49393: LD_INT 5
49395: PPUSH
49396: CALL_OW 273
49400: PPUSH
49401: CALL_OW 111
// SetTag ( i , 0 ) ;
49405: LD_VAR 0 7
49409: PPUSH
49410: LD_INT 0
49412: PPUSH
49413: CALL_OW 109
// solds := solds diff i ;
49417: LD_ADDR_VAR 0 2
49421: PUSH
49422: LD_VAR 0 2
49426: PUSH
49427: LD_VAR 0 7
49431: DIFF
49432: ST_TO_ADDR
// continue ;
49433: GO 49220
// end ; end ;
49435: GO 49220
49437: POP
49438: POP
// until solds ;
49439: LD_VAR 0 2
49443: IFFALSE 49052
// MC_Reset ( base , 18 ) ;
49445: LD_VAR 0 1
49449: PPUSH
49450: LD_INT 18
49452: PPUSH
49453: CALL 21174 0 2
// end ;
49457: LD_VAR 0 4
49461: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
49462: LD_INT 0
49464: PPUSH
49465: PPUSH
49466: PPUSH
49467: PPUSH
49468: PPUSH
49469: PPUSH
49470: PPUSH
49471: PPUSH
49472: PPUSH
49473: PPUSH
49474: PPUSH
49475: PPUSH
49476: PPUSH
49477: PPUSH
49478: PPUSH
49479: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
49480: LD_ADDR_VAR 0 12
49484: PUSH
49485: LD_EXP 50
49489: PUSH
49490: LD_VAR 0 1
49494: ARRAY
49495: PPUSH
49496: LD_INT 25
49498: PUSH
49499: LD_INT 3
49501: PUSH
49502: EMPTY
49503: LIST
49504: LIST
49505: PPUSH
49506: CALL_OW 72
49510: ST_TO_ADDR
// if mc_remote_driver [ base ] then
49511: LD_EXP 90
49515: PUSH
49516: LD_VAR 0 1
49520: ARRAY
49521: IFFALSE 49545
// mechs := mechs diff mc_remote_driver [ base ] ;
49523: LD_ADDR_VAR 0 12
49527: PUSH
49528: LD_VAR 0 12
49532: PUSH
49533: LD_EXP 90
49537: PUSH
49538: LD_VAR 0 1
49542: ARRAY
49543: DIFF
49544: ST_TO_ADDR
// for i in mechs do
49545: LD_ADDR_VAR 0 5
49549: PUSH
49550: LD_VAR 0 12
49554: PUSH
49555: FOR_IN
49556: IFFALSE 49591
// if GetTag ( i ) > 0 then
49558: LD_VAR 0 5
49562: PPUSH
49563: CALL_OW 110
49567: PUSH
49568: LD_INT 0
49570: GREATER
49571: IFFALSE 49589
// mechs := mechs diff i ;
49573: LD_ADDR_VAR 0 12
49577: PUSH
49578: LD_VAR 0 12
49582: PUSH
49583: LD_VAR 0 5
49587: DIFF
49588: ST_TO_ADDR
49589: GO 49555
49591: POP
49592: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
49593: LD_ADDR_VAR 0 8
49597: PUSH
49598: LD_EXP 50
49602: PUSH
49603: LD_VAR 0 1
49607: ARRAY
49608: PPUSH
49609: LD_INT 2
49611: PUSH
49612: LD_INT 25
49614: PUSH
49615: LD_INT 1
49617: PUSH
49618: EMPTY
49619: LIST
49620: LIST
49621: PUSH
49622: LD_INT 25
49624: PUSH
49625: LD_INT 5
49627: PUSH
49628: EMPTY
49629: LIST
49630: LIST
49631: PUSH
49632: LD_INT 25
49634: PUSH
49635: LD_INT 8
49637: PUSH
49638: EMPTY
49639: LIST
49640: LIST
49641: PUSH
49642: LD_INT 25
49644: PUSH
49645: LD_INT 9
49647: PUSH
49648: EMPTY
49649: LIST
49650: LIST
49651: PUSH
49652: EMPTY
49653: LIST
49654: LIST
49655: LIST
49656: LIST
49657: LIST
49658: PPUSH
49659: CALL_OW 72
49663: ST_TO_ADDR
// if not defenders and not solds then
49664: LD_VAR 0 2
49668: NOT
49669: PUSH
49670: LD_VAR 0 8
49674: NOT
49675: AND
49676: IFFALSE 49680
// exit ;
49678: GO 51218
// depot_under_attack := false ;
49680: LD_ADDR_VAR 0 16
49684: PUSH
49685: LD_INT 0
49687: ST_TO_ADDR
// sold_defenders := [ ] ;
49688: LD_ADDR_VAR 0 17
49692: PUSH
49693: EMPTY
49694: ST_TO_ADDR
// if mechs then
49695: LD_VAR 0 12
49699: IFFALSE 49828
// for i in defenders do
49701: LD_ADDR_VAR 0 5
49705: PUSH
49706: LD_VAR 0 2
49710: PUSH
49711: FOR_IN
49712: IFFALSE 49826
// begin SetTag ( i , 20 ) ;
49714: LD_VAR 0 5
49718: PPUSH
49719: LD_INT 20
49721: PPUSH
49722: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
49726: LD_VAR 0 5
49730: PPUSH
49731: CALL_OW 263
49735: PUSH
49736: LD_INT 1
49738: EQUAL
49739: PUSH
49740: LD_VAR 0 5
49744: PPUSH
49745: CALL_OW 311
49749: NOT
49750: AND
49751: PUSH
49752: LD_VAR 0 12
49756: AND
49757: IFFALSE 49824
// begin un := mechs [ 1 ] ;
49759: LD_ADDR_VAR 0 10
49763: PUSH
49764: LD_VAR 0 12
49768: PUSH
49769: LD_INT 1
49771: ARRAY
49772: ST_TO_ADDR
// ComExitBuilding ( un ) ;
49773: LD_VAR 0 10
49777: PPUSH
49778: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
49782: LD_VAR 0 10
49786: PPUSH
49787: LD_VAR 0 5
49791: PPUSH
49792: CALL_OW 180
// SetTag ( un , 19 ) ;
49796: LD_VAR 0 10
49800: PPUSH
49801: LD_INT 19
49803: PPUSH
49804: CALL_OW 109
// mechs := mechs diff un ;
49808: LD_ADDR_VAR 0 12
49812: PUSH
49813: LD_VAR 0 12
49817: PUSH
49818: LD_VAR 0 10
49822: DIFF
49823: ST_TO_ADDR
// end ; end ;
49824: GO 49711
49826: POP
49827: POP
// if solds then
49828: LD_VAR 0 8
49832: IFFALSE 49891
// for i in solds do
49834: LD_ADDR_VAR 0 5
49838: PUSH
49839: LD_VAR 0 8
49843: PUSH
49844: FOR_IN
49845: IFFALSE 49889
// if not GetTag ( i ) then
49847: LD_VAR 0 5
49851: PPUSH
49852: CALL_OW 110
49856: NOT
49857: IFFALSE 49887
// begin defenders := defenders union i ;
49859: LD_ADDR_VAR 0 2
49863: PUSH
49864: LD_VAR 0 2
49868: PUSH
49869: LD_VAR 0 5
49873: UNION
49874: ST_TO_ADDR
// SetTag ( i , 18 ) ;
49875: LD_VAR 0 5
49879: PPUSH
49880: LD_INT 18
49882: PPUSH
49883: CALL_OW 109
// end ;
49887: GO 49844
49889: POP
49890: POP
// repeat wait ( 0 0$1 ) ;
49891: LD_INT 35
49893: PPUSH
49894: CALL_OW 67
// enemy := mc_scan [ base ] ;
49898: LD_ADDR_VAR 0 3
49902: PUSH
49903: LD_EXP 73
49907: PUSH
49908: LD_VAR 0 1
49912: ARRAY
49913: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
49914: LD_EXP 50
49918: PUSH
49919: LD_VAR 0 1
49923: ARRAY
49924: NOT
49925: PUSH
49926: LD_EXP 50
49930: PUSH
49931: LD_VAR 0 1
49935: ARRAY
49936: PUSH
49937: EMPTY
49938: EQUAL
49939: OR
49940: IFFALSE 49977
// begin for i in defenders do
49942: LD_ADDR_VAR 0 5
49946: PUSH
49947: LD_VAR 0 2
49951: PUSH
49952: FOR_IN
49953: IFFALSE 49966
// ComStop ( i ) ;
49955: LD_VAR 0 5
49959: PPUSH
49960: CALL_OW 141
49964: GO 49952
49966: POP
49967: POP
// defenders := [ ] ;
49968: LD_ADDR_VAR 0 2
49972: PUSH
49973: EMPTY
49974: ST_TO_ADDR
// exit ;
49975: GO 51218
// end ; for i in defenders do
49977: LD_ADDR_VAR 0 5
49981: PUSH
49982: LD_VAR 0 2
49986: PUSH
49987: FOR_IN
49988: IFFALSE 50718
// begin e := NearestUnitToUnit ( enemy , i ) ;
49990: LD_ADDR_VAR 0 13
49994: PUSH
49995: LD_VAR 0 3
49999: PPUSH
50000: LD_VAR 0 5
50004: PPUSH
50005: CALL_OW 74
50009: ST_TO_ADDR
// depot_under_attack := ( not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) or GetLives ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ) < 600 ) ;
50010: LD_ADDR_VAR 0 16
50014: PUSH
50015: LD_EXP 50
50019: PUSH
50020: LD_VAR 0 1
50024: ARRAY
50025: PPUSH
50026: LD_INT 2
50028: PUSH
50029: LD_INT 30
50031: PUSH
50032: LD_INT 0
50034: PUSH
50035: EMPTY
50036: LIST
50037: LIST
50038: PUSH
50039: LD_INT 30
50041: PUSH
50042: LD_INT 1
50044: PUSH
50045: EMPTY
50046: LIST
50047: LIST
50048: PUSH
50049: EMPTY
50050: LIST
50051: LIST
50052: LIST
50053: PPUSH
50054: CALL_OW 72
50058: NOT
50059: PUSH
50060: LD_EXP 50
50064: PUSH
50065: LD_VAR 0 1
50069: ARRAY
50070: PPUSH
50071: LD_INT 2
50073: PUSH
50074: LD_INT 30
50076: PUSH
50077: LD_INT 0
50079: PUSH
50080: EMPTY
50081: LIST
50082: LIST
50083: PUSH
50084: LD_INT 30
50086: PUSH
50087: LD_INT 1
50089: PUSH
50090: EMPTY
50091: LIST
50092: LIST
50093: PUSH
50094: EMPTY
50095: LIST
50096: LIST
50097: LIST
50098: PPUSH
50099: CALL_OW 72
50103: PPUSH
50104: CALL_OW 256
50108: PUSH
50109: LD_INT 600
50111: LESS
50112: OR
50113: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
50114: LD_VAR 0 5
50118: PPUSH
50119: CALL_OW 247
50123: PUSH
50124: LD_INT 2
50126: DOUBLE
50127: EQUAL
50128: IFTRUE 50132
50130: GO 50424
50132: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
50133: LD_VAR 0 5
50137: PPUSH
50138: CALL_OW 256
50142: PUSH
50143: LD_INT 650
50145: GREATER
50146: PUSH
50147: LD_VAR 0 5
50151: PPUSH
50152: LD_VAR 0 13
50156: PPUSH
50157: CALL_OW 296
50161: PUSH
50162: LD_INT 40
50164: LESS
50165: PUSH
50166: LD_VAR 0 13
50170: PPUSH
50171: LD_EXP 75
50175: PUSH
50176: LD_VAR 0 1
50180: ARRAY
50181: PPUSH
50182: CALL_OW 308
50186: OR
50187: AND
50188: IFFALSE 50206
// ComAttackUnit ( i , e ) else
50190: LD_VAR 0 5
50194: PPUSH
50195: LD_VAR 0 13
50199: PPUSH
50200: CALL_OW 115
50204: GO 50307
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
50206: LD_VAR 0 13
50210: PPUSH
50211: LD_EXP 75
50215: PUSH
50216: LD_VAR 0 1
50220: ARRAY
50221: PPUSH
50222: CALL_OW 308
50226: NOT
50227: PUSH
50228: LD_VAR 0 5
50232: PPUSH
50233: LD_VAR 0 13
50237: PPUSH
50238: CALL_OW 296
50242: PUSH
50243: LD_INT 40
50245: GREATEREQUAL
50246: AND
50247: PUSH
50248: LD_VAR 0 5
50252: PPUSH
50253: CALL_OW 256
50257: PUSH
50258: LD_INT 650
50260: LESSEQUAL
50261: OR
50262: PUSH
50263: LD_VAR 0 5
50267: PPUSH
50268: LD_EXP 74
50272: PUSH
50273: LD_VAR 0 1
50277: ARRAY
50278: PPUSH
50279: CALL_OW 308
50283: NOT
50284: AND
50285: IFFALSE 50307
// ComMoveToArea ( i , mc_parking [ base ] ) ;
50287: LD_VAR 0 5
50291: PPUSH
50292: LD_EXP 74
50296: PUSH
50297: LD_VAR 0 1
50301: ARRAY
50302: PPUSH
50303: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
50307: LD_VAR 0 5
50311: PPUSH
50312: CALL_OW 256
50316: PUSH
50317: LD_INT 998
50319: LESS
50320: PUSH
50321: LD_VAR 0 5
50325: PPUSH
50326: CALL_OW 263
50330: PUSH
50331: LD_INT 1
50333: EQUAL
50334: AND
50335: PUSH
50336: LD_VAR 0 5
50340: PPUSH
50341: CALL_OW 311
50345: AND
50346: PUSH
50347: LD_VAR 0 5
50351: PPUSH
50352: LD_EXP 74
50356: PUSH
50357: LD_VAR 0 1
50361: ARRAY
50362: PPUSH
50363: CALL_OW 308
50367: AND
50368: IFFALSE 50422
// begin mech := IsDrivenBy ( i ) ;
50370: LD_ADDR_VAR 0 9
50374: PUSH
50375: LD_VAR 0 5
50379: PPUSH
50380: CALL_OW 311
50384: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
50385: LD_VAR 0 9
50389: PPUSH
50390: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
50394: LD_VAR 0 9
50398: PPUSH
50399: LD_VAR 0 5
50403: PPUSH
50404: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
50408: LD_VAR 0 9
50412: PPUSH
50413: LD_VAR 0 5
50417: PPUSH
50418: CALL_OW 180
// end ; end ; unit_human :
50422: GO 50689
50424: LD_INT 1
50426: DOUBLE
50427: EQUAL
50428: IFTRUE 50432
50430: GO 50688
50432: POP
// begin b := IsInUnit ( i ) ;
50433: LD_ADDR_VAR 0 18
50437: PUSH
50438: LD_VAR 0 5
50442: PPUSH
50443: CALL_OW 310
50447: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
50448: LD_ADDR_VAR 0 19
50452: PUSH
50453: LD_VAR 0 18
50457: NOT
50458: PUSH
50459: LD_VAR 0 18
50463: PPUSH
50464: CALL_OW 266
50468: PUSH
50469: LD_INT 32
50471: PUSH
50472: LD_INT 31
50474: PUSH
50475: EMPTY
50476: LIST
50477: LIST
50478: IN
50479: OR
50480: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
50481: LD_VAR 0 16
50485: PUSH
50486: LD_VAR 0 2
50490: PPUSH
50491: LD_INT 21
50493: PUSH
50494: LD_INT 2
50496: PUSH
50497: EMPTY
50498: LIST
50499: LIST
50500: PPUSH
50501: CALL_OW 72
50505: PUSH
50506: LD_INT 1
50508: LESSEQUAL
50509: OR
50510: PUSH
50511: LD_VAR 0 19
50515: AND
50516: PUSH
50517: LD_VAR 0 5
50521: PUSH
50522: LD_VAR 0 17
50526: IN
50527: NOT
50528: AND
50529: IFFALSE 50622
// begin if b then
50531: LD_VAR 0 18
50535: IFFALSE 50584
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
50537: LD_VAR 0 18
50541: PPUSH
50542: LD_VAR 0 3
50546: PPUSH
50547: LD_VAR 0 18
50551: PPUSH
50552: CALL_OW 74
50556: PPUSH
50557: CALL_OW 296
50561: PUSH
50562: LD_INT 10
50564: LESS
50565: PUSH
50566: LD_VAR 0 18
50570: PPUSH
50571: CALL_OW 461
50575: PUSH
50576: LD_INT 7
50578: NONEQUAL
50579: AND
50580: IFFALSE 50584
// continue ;
50582: GO 49987
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
50584: LD_ADDR_VAR 0 17
50588: PUSH
50589: LD_VAR 0 17
50593: PPUSH
50594: LD_VAR 0 17
50598: PUSH
50599: LD_INT 1
50601: PLUS
50602: PPUSH
50603: LD_VAR 0 5
50607: PPUSH
50608: CALL_OW 1
50612: ST_TO_ADDR
// ComExitBuilding ( i ) ;
50613: LD_VAR 0 5
50617: PPUSH
50618: CALL_OW 122
// end ; if sold_defenders then
50622: LD_VAR 0 17
50626: IFFALSE 50686
// if i in sold_defenders then
50628: LD_VAR 0 5
50632: PUSH
50633: LD_VAR 0 17
50637: IN
50638: IFFALSE 50686
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
50640: LD_VAR 0 5
50644: PPUSH
50645: CALL_OW 314
50649: NOT
50650: PUSH
50651: LD_VAR 0 5
50655: PPUSH
50656: LD_VAR 0 13
50660: PPUSH
50661: CALL_OW 296
50665: PUSH
50666: LD_INT 30
50668: LESS
50669: AND
50670: IFFALSE 50686
// ComAttackUnit ( i , e ) ;
50672: LD_VAR 0 5
50676: PPUSH
50677: LD_VAR 0 13
50681: PPUSH
50682: CALL_OW 115
// end ; end ; end ;
50686: GO 50689
50688: POP
// if IsDead ( i ) then
50689: LD_VAR 0 5
50693: PPUSH
50694: CALL_OW 301
50698: IFFALSE 50716
// defenders := defenders diff i ;
50700: LD_ADDR_VAR 0 2
50704: PUSH
50705: LD_VAR 0 2
50709: PUSH
50710: LD_VAR 0 5
50714: DIFF
50715: ST_TO_ADDR
// end ;
50716: GO 49987
50718: POP
50719: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
50720: LD_VAR 0 3
50724: NOT
50725: PUSH
50726: LD_VAR 0 2
50730: NOT
50731: OR
50732: PUSH
50733: LD_EXP 50
50737: PUSH
50738: LD_VAR 0 1
50742: ARRAY
50743: NOT
50744: OR
50745: IFFALSE 49891
// MC_Reset ( base , 18 ) ;
50747: LD_VAR 0 1
50751: PPUSH
50752: LD_INT 18
50754: PPUSH
50755: CALL 21174 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
50759: LD_ADDR_VAR 0 2
50763: PUSH
50764: LD_VAR 0 2
50768: PUSH
50769: LD_VAR 0 2
50773: PPUSH
50774: LD_INT 2
50776: PUSH
50777: LD_INT 25
50779: PUSH
50780: LD_INT 1
50782: PUSH
50783: EMPTY
50784: LIST
50785: LIST
50786: PUSH
50787: LD_INT 25
50789: PUSH
50790: LD_INT 5
50792: PUSH
50793: EMPTY
50794: LIST
50795: LIST
50796: PUSH
50797: LD_INT 25
50799: PUSH
50800: LD_INT 8
50802: PUSH
50803: EMPTY
50804: LIST
50805: LIST
50806: PUSH
50807: LD_INT 25
50809: PUSH
50810: LD_INT 9
50812: PUSH
50813: EMPTY
50814: LIST
50815: LIST
50816: PUSH
50817: EMPTY
50818: LIST
50819: LIST
50820: LIST
50821: LIST
50822: LIST
50823: PPUSH
50824: CALL_OW 72
50828: DIFF
50829: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
50830: LD_VAR 0 3
50834: NOT
50835: PUSH
50836: LD_VAR 0 2
50840: PPUSH
50841: LD_INT 21
50843: PUSH
50844: LD_INT 2
50846: PUSH
50847: EMPTY
50848: LIST
50849: LIST
50850: PPUSH
50851: CALL_OW 72
50855: AND
50856: IFFALSE 51194
// begin tmp := FilterByTag ( defenders , 19 ) ;
50858: LD_ADDR_VAR 0 11
50862: PUSH
50863: LD_VAR 0 2
50867: PPUSH
50868: LD_INT 19
50870: PPUSH
50871: CALL 87647 0 2
50875: ST_TO_ADDR
// if tmp then
50876: LD_VAR 0 11
50880: IFFALSE 50950
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
50882: LD_ADDR_VAR 0 11
50886: PUSH
50887: LD_VAR 0 11
50891: PPUSH
50892: LD_INT 25
50894: PUSH
50895: LD_INT 3
50897: PUSH
50898: EMPTY
50899: LIST
50900: LIST
50901: PPUSH
50902: CALL_OW 72
50906: ST_TO_ADDR
// if tmp then
50907: LD_VAR 0 11
50911: IFFALSE 50950
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
50913: LD_ADDR_EXP 62
50917: PUSH
50918: LD_EXP 62
50922: PPUSH
50923: LD_VAR 0 1
50927: PPUSH
50928: LD_EXP 62
50932: PUSH
50933: LD_VAR 0 1
50937: ARRAY
50938: PUSH
50939: LD_VAR 0 11
50943: UNION
50944: PPUSH
50945: CALL_OW 1
50949: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
50950: LD_VAR 0 1
50954: PPUSH
50955: LD_INT 19
50957: PPUSH
50958: CALL 21174 0 2
// repeat wait ( 0 0$1 ) ;
50962: LD_INT 35
50964: PPUSH
50965: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
50969: LD_EXP 50
50973: PUSH
50974: LD_VAR 0 1
50978: ARRAY
50979: NOT
50980: PUSH
50981: LD_EXP 50
50985: PUSH
50986: LD_VAR 0 1
50990: ARRAY
50991: PUSH
50992: EMPTY
50993: EQUAL
50994: OR
50995: IFFALSE 51032
// begin for i in defenders do
50997: LD_ADDR_VAR 0 5
51001: PUSH
51002: LD_VAR 0 2
51006: PUSH
51007: FOR_IN
51008: IFFALSE 51021
// ComStop ( i ) ;
51010: LD_VAR 0 5
51014: PPUSH
51015: CALL_OW 141
51019: GO 51007
51021: POP
51022: POP
// defenders := [ ] ;
51023: LD_ADDR_VAR 0 2
51027: PUSH
51028: EMPTY
51029: ST_TO_ADDR
// exit ;
51030: GO 51218
// end ; for i in defenders do
51032: LD_ADDR_VAR 0 5
51036: PUSH
51037: LD_VAR 0 2
51041: PUSH
51042: FOR_IN
51043: IFFALSE 51132
// begin if not IsInArea ( i , mc_parking [ base ] ) then
51045: LD_VAR 0 5
51049: PPUSH
51050: LD_EXP 74
51054: PUSH
51055: LD_VAR 0 1
51059: ARRAY
51060: PPUSH
51061: CALL_OW 308
51065: NOT
51066: IFFALSE 51090
// ComMoveToArea ( i , mc_parking [ base ] ) else
51068: LD_VAR 0 5
51072: PPUSH
51073: LD_EXP 74
51077: PUSH
51078: LD_VAR 0 1
51082: ARRAY
51083: PPUSH
51084: CALL_OW 113
51088: GO 51130
// if GetControl ( i ) = control_manual then
51090: LD_VAR 0 5
51094: PPUSH
51095: CALL_OW 263
51099: PUSH
51100: LD_INT 1
51102: EQUAL
51103: IFFALSE 51130
// if IsDrivenBy ( i ) then
51105: LD_VAR 0 5
51109: PPUSH
51110: CALL_OW 311
51114: IFFALSE 51130
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
51116: LD_VAR 0 5
51120: PPUSH
51121: CALL_OW 311
51125: PPUSH
51126: CALL_OW 121
// end ;
51130: GO 51042
51132: POP
51133: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
51134: LD_VAR 0 2
51138: PPUSH
51139: LD_INT 95
51141: PUSH
51142: LD_EXP 74
51146: PUSH
51147: LD_VAR 0 1
51151: ARRAY
51152: PUSH
51153: EMPTY
51154: LIST
51155: LIST
51156: PPUSH
51157: CALL_OW 72
51161: PUSH
51162: LD_VAR 0 2
51166: EQUAL
51167: PUSH
51168: LD_EXP 73
51172: PUSH
51173: LD_VAR 0 1
51177: ARRAY
51178: OR
51179: PUSH
51180: LD_EXP 50
51184: PUSH
51185: LD_VAR 0 1
51189: ARRAY
51190: NOT
51191: OR
51192: IFFALSE 50962
// end ; MC_Reset ( base , 19 ) ;
51194: LD_VAR 0 1
51198: PPUSH
51199: LD_INT 19
51201: PPUSH
51202: CALL 21174 0 2
// MC_Reset ( base , 20 ) ;
51206: LD_VAR 0 1
51210: PPUSH
51211: LD_INT 20
51213: PPUSH
51214: CALL 21174 0 2
// end ;
51218: LD_VAR 0 4
51222: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
51223: LD_INT 0
51225: PPUSH
51226: PPUSH
51227: PPUSH
51228: PPUSH
// result := false ;
51229: LD_ADDR_VAR 0 2
51233: PUSH
51234: LD_INT 0
51236: ST_TO_ADDR
// side := GetSide ( unit ) ;
51237: LD_ADDR_VAR 0 3
51241: PUSH
51242: LD_VAR 0 1
51246: PPUSH
51247: CALL_OW 255
51251: ST_TO_ADDR
// nat := GetNation ( unit ) ;
51252: LD_ADDR_VAR 0 4
51256: PUSH
51257: LD_VAR 0 1
51261: PPUSH
51262: CALL_OW 248
51266: ST_TO_ADDR
// case nat of 1 :
51267: LD_VAR 0 4
51271: PUSH
51272: LD_INT 1
51274: DOUBLE
51275: EQUAL
51276: IFTRUE 51280
51278: GO 51291
51280: POP
// tech := tech_lassight ; 2 :
51281: LD_ADDR_VAR 0 5
51285: PUSH
51286: LD_INT 12
51288: ST_TO_ADDR
51289: GO 51330
51291: LD_INT 2
51293: DOUBLE
51294: EQUAL
51295: IFTRUE 51299
51297: GO 51310
51299: POP
// tech := tech_mortar ; 3 :
51300: LD_ADDR_VAR 0 5
51304: PUSH
51305: LD_INT 41
51307: ST_TO_ADDR
51308: GO 51330
51310: LD_INT 3
51312: DOUBLE
51313: EQUAL
51314: IFTRUE 51318
51316: GO 51329
51318: POP
// tech := tech_bazooka ; end ;
51319: LD_ADDR_VAR 0 5
51323: PUSH
51324: LD_INT 44
51326: ST_TO_ADDR
51327: GO 51330
51329: POP
// if Researched ( side , tech ) then
51330: LD_VAR 0 3
51334: PPUSH
51335: LD_VAR 0 5
51339: PPUSH
51340: CALL_OW 325
51344: IFFALSE 51371
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
51346: LD_ADDR_VAR 0 2
51350: PUSH
51351: LD_INT 5
51353: PUSH
51354: LD_INT 8
51356: PUSH
51357: LD_INT 9
51359: PUSH
51360: EMPTY
51361: LIST
51362: LIST
51363: LIST
51364: PUSH
51365: LD_VAR 0 4
51369: ARRAY
51370: ST_TO_ADDR
// end ;
51371: LD_VAR 0 2
51375: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
51376: LD_INT 0
51378: PPUSH
51379: PPUSH
51380: PPUSH
// if not mines then
51381: LD_VAR 0 2
51385: NOT
51386: IFFALSE 51390
// exit ;
51388: GO 51534
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
51390: LD_ADDR_VAR 0 5
51394: PUSH
51395: LD_INT 81
51397: PUSH
51398: LD_VAR 0 1
51402: PUSH
51403: EMPTY
51404: LIST
51405: LIST
51406: PUSH
51407: LD_INT 3
51409: PUSH
51410: LD_INT 21
51412: PUSH
51413: LD_INT 3
51415: PUSH
51416: EMPTY
51417: LIST
51418: LIST
51419: PUSH
51420: EMPTY
51421: LIST
51422: LIST
51423: PUSH
51424: EMPTY
51425: LIST
51426: LIST
51427: PPUSH
51428: CALL_OW 69
51432: ST_TO_ADDR
// for i in mines do
51433: LD_ADDR_VAR 0 4
51437: PUSH
51438: LD_VAR 0 2
51442: PUSH
51443: FOR_IN
51444: IFFALSE 51532
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
51446: LD_VAR 0 4
51450: PUSH
51451: LD_INT 1
51453: ARRAY
51454: PPUSH
51455: LD_VAR 0 4
51459: PUSH
51460: LD_INT 2
51462: ARRAY
51463: PPUSH
51464: CALL_OW 458
51468: NOT
51469: IFFALSE 51473
// continue ;
51471: GO 51443
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
51473: LD_VAR 0 4
51477: PUSH
51478: LD_INT 1
51480: ARRAY
51481: PPUSH
51482: LD_VAR 0 4
51486: PUSH
51487: LD_INT 2
51489: ARRAY
51490: PPUSH
51491: CALL_OW 428
51495: PUSH
51496: LD_VAR 0 5
51500: IN
51501: IFFALSE 51530
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
51503: LD_VAR 0 4
51507: PUSH
51508: LD_INT 1
51510: ARRAY
51511: PPUSH
51512: LD_VAR 0 4
51516: PUSH
51517: LD_INT 2
51519: ARRAY
51520: PPUSH
51521: LD_VAR 0 1
51525: PPUSH
51526: CALL_OW 456
// end ;
51530: GO 51443
51532: POP
51533: POP
// end ;
51534: LD_VAR 0 3
51538: RET
// export function Count ( array ) ; var i ; begin
51539: LD_INT 0
51541: PPUSH
51542: PPUSH
// result := 0 ;
51543: LD_ADDR_VAR 0 2
51547: PUSH
51548: LD_INT 0
51550: ST_TO_ADDR
// for i in array do
51551: LD_ADDR_VAR 0 3
51555: PUSH
51556: LD_VAR 0 1
51560: PUSH
51561: FOR_IN
51562: IFFALSE 51586
// if i then
51564: LD_VAR 0 3
51568: IFFALSE 51584
// result := result + 1 ;
51570: LD_ADDR_VAR 0 2
51574: PUSH
51575: LD_VAR 0 2
51579: PUSH
51580: LD_INT 1
51582: PLUS
51583: ST_TO_ADDR
51584: GO 51561
51586: POP
51587: POP
// end ;
51588: LD_VAR 0 2
51592: RET
// export function IsEmpty ( building ) ; begin
51593: LD_INT 0
51595: PPUSH
// if not building then
51596: LD_VAR 0 1
51600: NOT
51601: IFFALSE 51605
// exit ;
51603: GO 51648
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
51605: LD_ADDR_VAR 0 2
51609: PUSH
51610: LD_VAR 0 1
51614: PUSH
51615: LD_INT 22
51617: PUSH
51618: LD_VAR 0 1
51622: PPUSH
51623: CALL_OW 255
51627: PUSH
51628: EMPTY
51629: LIST
51630: LIST
51631: PUSH
51632: LD_INT 58
51634: PUSH
51635: EMPTY
51636: LIST
51637: PUSH
51638: EMPTY
51639: LIST
51640: LIST
51641: PPUSH
51642: CALL_OW 69
51646: IN
51647: ST_TO_ADDR
// end ;
51648: LD_VAR 0 2
51652: RET
// export function IsNotFull ( building ) ; begin
51653: LD_INT 0
51655: PPUSH
// if not building then
51656: LD_VAR 0 1
51660: NOT
51661: IFFALSE 51665
// exit ;
51663: GO 51684
// result := UnitsInside ( building ) < 6 ;
51665: LD_ADDR_VAR 0 2
51669: PUSH
51670: LD_VAR 0 1
51674: PPUSH
51675: CALL_OW 313
51679: PUSH
51680: LD_INT 6
51682: LESS
51683: ST_TO_ADDR
// end ;
51684: LD_VAR 0 2
51688: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
51689: LD_INT 0
51691: PPUSH
51692: PPUSH
51693: PPUSH
51694: PPUSH
// tmp := [ ] ;
51695: LD_ADDR_VAR 0 3
51699: PUSH
51700: EMPTY
51701: ST_TO_ADDR
// list := [ ] ;
51702: LD_ADDR_VAR 0 5
51706: PUSH
51707: EMPTY
51708: ST_TO_ADDR
// for i = 16 to 25 do
51709: LD_ADDR_VAR 0 4
51713: PUSH
51714: DOUBLE
51715: LD_INT 16
51717: DEC
51718: ST_TO_ADDR
51719: LD_INT 25
51721: PUSH
51722: FOR_TO
51723: IFFALSE 51796
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
51725: LD_ADDR_VAR 0 3
51729: PUSH
51730: LD_VAR 0 3
51734: PUSH
51735: LD_INT 22
51737: PUSH
51738: LD_VAR 0 1
51742: PPUSH
51743: CALL_OW 255
51747: PUSH
51748: EMPTY
51749: LIST
51750: LIST
51751: PUSH
51752: LD_INT 91
51754: PUSH
51755: LD_VAR 0 1
51759: PUSH
51760: LD_INT 6
51762: PUSH
51763: EMPTY
51764: LIST
51765: LIST
51766: LIST
51767: PUSH
51768: LD_INT 30
51770: PUSH
51771: LD_VAR 0 4
51775: PUSH
51776: EMPTY
51777: LIST
51778: LIST
51779: PUSH
51780: EMPTY
51781: LIST
51782: LIST
51783: LIST
51784: PUSH
51785: EMPTY
51786: LIST
51787: PPUSH
51788: CALL_OW 69
51792: ADD
51793: ST_TO_ADDR
51794: GO 51722
51796: POP
51797: POP
// for i = 1 to tmp do
51798: LD_ADDR_VAR 0 4
51802: PUSH
51803: DOUBLE
51804: LD_INT 1
51806: DEC
51807: ST_TO_ADDR
51808: LD_VAR 0 3
51812: PUSH
51813: FOR_TO
51814: IFFALSE 51902
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
51816: LD_ADDR_VAR 0 5
51820: PUSH
51821: LD_VAR 0 5
51825: PUSH
51826: LD_VAR 0 3
51830: PUSH
51831: LD_VAR 0 4
51835: ARRAY
51836: PPUSH
51837: CALL_OW 266
51841: PUSH
51842: LD_VAR 0 3
51846: PUSH
51847: LD_VAR 0 4
51851: ARRAY
51852: PPUSH
51853: CALL_OW 250
51857: PUSH
51858: LD_VAR 0 3
51862: PUSH
51863: LD_VAR 0 4
51867: ARRAY
51868: PPUSH
51869: CALL_OW 251
51873: PUSH
51874: LD_VAR 0 3
51878: PUSH
51879: LD_VAR 0 4
51883: ARRAY
51884: PPUSH
51885: CALL_OW 254
51889: PUSH
51890: EMPTY
51891: LIST
51892: LIST
51893: LIST
51894: LIST
51895: PUSH
51896: EMPTY
51897: LIST
51898: ADD
51899: ST_TO_ADDR
51900: GO 51813
51902: POP
51903: POP
// result := list ;
51904: LD_ADDR_VAR 0 2
51908: PUSH
51909: LD_VAR 0 5
51913: ST_TO_ADDR
// end ;
51914: LD_VAR 0 2
51918: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
51919: LD_INT 0
51921: PPUSH
51922: PPUSH
51923: PPUSH
51924: PPUSH
51925: PPUSH
51926: PPUSH
51927: PPUSH
// if not factory then
51928: LD_VAR 0 1
51932: NOT
51933: IFFALSE 51937
// exit ;
51935: GO 52530
// if control = control_apeman then
51937: LD_VAR 0 4
51941: PUSH
51942: LD_INT 5
51944: EQUAL
51945: IFFALSE 52054
// begin tmp := UnitsInside ( factory ) ;
51947: LD_ADDR_VAR 0 8
51951: PUSH
51952: LD_VAR 0 1
51956: PPUSH
51957: CALL_OW 313
51961: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
51962: LD_VAR 0 8
51966: PPUSH
51967: LD_INT 25
51969: PUSH
51970: LD_INT 12
51972: PUSH
51973: EMPTY
51974: LIST
51975: LIST
51976: PPUSH
51977: CALL_OW 72
51981: NOT
51982: IFFALSE 51992
// control := control_manual ;
51984: LD_ADDR_VAR 0 4
51988: PUSH
51989: LD_INT 1
51991: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
51992: LD_ADDR_VAR 0 8
51996: PUSH
51997: LD_VAR 0 1
52001: PPUSH
52002: CALL 51689 0 1
52006: ST_TO_ADDR
// if tmp then
52007: LD_VAR 0 8
52011: IFFALSE 52054
// begin for i in tmp do
52013: LD_ADDR_VAR 0 7
52017: PUSH
52018: LD_VAR 0 8
52022: PUSH
52023: FOR_IN
52024: IFFALSE 52052
// if i [ 1 ] = b_ext_radio then
52026: LD_VAR 0 7
52030: PUSH
52031: LD_INT 1
52033: ARRAY
52034: PUSH
52035: LD_INT 22
52037: EQUAL
52038: IFFALSE 52050
// begin control := control_remote ;
52040: LD_ADDR_VAR 0 4
52044: PUSH
52045: LD_INT 2
52047: ST_TO_ADDR
// break ;
52048: GO 52052
// end ;
52050: GO 52023
52052: POP
52053: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
52054: LD_VAR 0 1
52058: PPUSH
52059: LD_VAR 0 2
52063: PPUSH
52064: LD_VAR 0 3
52068: PPUSH
52069: LD_VAR 0 4
52073: PPUSH
52074: LD_VAR 0 5
52078: PPUSH
52079: CALL_OW 448
52083: IFFALSE 52118
// begin result := [ chassis , engine , control , weapon ] ;
52085: LD_ADDR_VAR 0 6
52089: PUSH
52090: LD_VAR 0 2
52094: PUSH
52095: LD_VAR 0 3
52099: PUSH
52100: LD_VAR 0 4
52104: PUSH
52105: LD_VAR 0 5
52109: PUSH
52110: EMPTY
52111: LIST
52112: LIST
52113: LIST
52114: LIST
52115: ST_TO_ADDR
// exit ;
52116: GO 52530
// end ; _chassis := AvailableChassisList ( factory ) ;
52118: LD_ADDR_VAR 0 9
52122: PUSH
52123: LD_VAR 0 1
52127: PPUSH
52128: CALL_OW 475
52132: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
52133: LD_ADDR_VAR 0 11
52137: PUSH
52138: LD_VAR 0 1
52142: PPUSH
52143: CALL_OW 476
52147: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
52148: LD_ADDR_VAR 0 12
52152: PUSH
52153: LD_VAR 0 1
52157: PPUSH
52158: CALL_OW 477
52162: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
52163: LD_ADDR_VAR 0 10
52167: PUSH
52168: LD_VAR 0 1
52172: PPUSH
52173: CALL_OW 478
52177: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
52178: LD_VAR 0 9
52182: NOT
52183: PUSH
52184: LD_VAR 0 11
52188: NOT
52189: OR
52190: PUSH
52191: LD_VAR 0 12
52195: NOT
52196: OR
52197: PUSH
52198: LD_VAR 0 10
52202: NOT
52203: OR
52204: IFFALSE 52239
// begin result := [ chassis , engine , control , weapon ] ;
52206: LD_ADDR_VAR 0 6
52210: PUSH
52211: LD_VAR 0 2
52215: PUSH
52216: LD_VAR 0 3
52220: PUSH
52221: LD_VAR 0 4
52225: PUSH
52226: LD_VAR 0 5
52230: PUSH
52231: EMPTY
52232: LIST
52233: LIST
52234: LIST
52235: LIST
52236: ST_TO_ADDR
// exit ;
52237: GO 52530
// end ; if not chassis in _chassis then
52239: LD_VAR 0 2
52243: PUSH
52244: LD_VAR 0 9
52248: IN
52249: NOT
52250: IFFALSE 52276
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
52252: LD_ADDR_VAR 0 2
52256: PUSH
52257: LD_VAR 0 9
52261: PUSH
52262: LD_INT 1
52264: PPUSH
52265: LD_VAR 0 9
52269: PPUSH
52270: CALL_OW 12
52274: ARRAY
52275: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
52276: LD_VAR 0 2
52280: PPUSH
52281: LD_VAR 0 3
52285: PPUSH
52286: CALL 52535 0 2
52290: NOT
52291: IFFALSE 52350
// repeat engine := _engine [ 1 ] ;
52293: LD_ADDR_VAR 0 3
52297: PUSH
52298: LD_VAR 0 11
52302: PUSH
52303: LD_INT 1
52305: ARRAY
52306: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
52307: LD_ADDR_VAR 0 11
52311: PUSH
52312: LD_VAR 0 11
52316: PPUSH
52317: LD_INT 1
52319: PPUSH
52320: CALL_OW 3
52324: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
52325: LD_VAR 0 2
52329: PPUSH
52330: LD_VAR 0 3
52334: PPUSH
52335: CALL 52535 0 2
52339: PUSH
52340: LD_VAR 0 11
52344: PUSH
52345: EMPTY
52346: EQUAL
52347: OR
52348: IFFALSE 52293
// if not control in _control then
52350: LD_VAR 0 4
52354: PUSH
52355: LD_VAR 0 12
52359: IN
52360: NOT
52361: IFFALSE 52387
// control := _control [ rand ( 1 , _control ) ] ;
52363: LD_ADDR_VAR 0 4
52367: PUSH
52368: LD_VAR 0 12
52372: PUSH
52373: LD_INT 1
52375: PPUSH
52376: LD_VAR 0 12
52380: PPUSH
52381: CALL_OW 12
52385: ARRAY
52386: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
52387: LD_VAR 0 2
52391: PPUSH
52392: LD_VAR 0 5
52396: PPUSH
52397: CALL 52755 0 2
52401: NOT
52402: IFFALSE 52461
// repeat weapon := _weapon [ 1 ] ;
52404: LD_ADDR_VAR 0 5
52408: PUSH
52409: LD_VAR 0 10
52413: PUSH
52414: LD_INT 1
52416: ARRAY
52417: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
52418: LD_ADDR_VAR 0 10
52422: PUSH
52423: LD_VAR 0 10
52427: PPUSH
52428: LD_INT 1
52430: PPUSH
52431: CALL_OW 3
52435: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
52436: LD_VAR 0 2
52440: PPUSH
52441: LD_VAR 0 5
52445: PPUSH
52446: CALL 52755 0 2
52450: PUSH
52451: LD_VAR 0 10
52455: PUSH
52456: EMPTY
52457: EQUAL
52458: OR
52459: IFFALSE 52404
// result := [ ] ;
52461: LD_ADDR_VAR 0 6
52465: PUSH
52466: EMPTY
52467: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
52468: LD_VAR 0 1
52472: PPUSH
52473: LD_VAR 0 2
52477: PPUSH
52478: LD_VAR 0 3
52482: PPUSH
52483: LD_VAR 0 4
52487: PPUSH
52488: LD_VAR 0 5
52492: PPUSH
52493: CALL_OW 448
52497: IFFALSE 52530
// result := [ chassis , engine , control , weapon ] ;
52499: LD_ADDR_VAR 0 6
52503: PUSH
52504: LD_VAR 0 2
52508: PUSH
52509: LD_VAR 0 3
52513: PUSH
52514: LD_VAR 0 4
52518: PUSH
52519: LD_VAR 0 5
52523: PUSH
52524: EMPTY
52525: LIST
52526: LIST
52527: LIST
52528: LIST
52529: ST_TO_ADDR
// end ;
52530: LD_VAR 0 6
52534: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
52535: LD_INT 0
52537: PPUSH
// if not chassis or not engine then
52538: LD_VAR 0 1
52542: NOT
52543: PUSH
52544: LD_VAR 0 2
52548: NOT
52549: OR
52550: IFFALSE 52554
// exit ;
52552: GO 52750
// case engine of engine_solar :
52554: LD_VAR 0 2
52558: PUSH
52559: LD_INT 2
52561: DOUBLE
52562: EQUAL
52563: IFTRUE 52567
52565: GO 52605
52567: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
52568: LD_ADDR_VAR 0 3
52572: PUSH
52573: LD_INT 11
52575: PUSH
52576: LD_INT 12
52578: PUSH
52579: LD_INT 13
52581: PUSH
52582: LD_INT 14
52584: PUSH
52585: LD_INT 1
52587: PUSH
52588: LD_INT 2
52590: PUSH
52591: LD_INT 3
52593: PUSH
52594: EMPTY
52595: LIST
52596: LIST
52597: LIST
52598: LIST
52599: LIST
52600: LIST
52601: LIST
52602: ST_TO_ADDR
52603: GO 52734
52605: LD_INT 1
52607: DOUBLE
52608: EQUAL
52609: IFTRUE 52613
52611: GO 52675
52613: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
52614: LD_ADDR_VAR 0 3
52618: PUSH
52619: LD_INT 11
52621: PUSH
52622: LD_INT 12
52624: PUSH
52625: LD_INT 13
52627: PUSH
52628: LD_INT 14
52630: PUSH
52631: LD_INT 1
52633: PUSH
52634: LD_INT 2
52636: PUSH
52637: LD_INT 3
52639: PUSH
52640: LD_INT 4
52642: PUSH
52643: LD_INT 5
52645: PUSH
52646: LD_INT 21
52648: PUSH
52649: LD_INT 23
52651: PUSH
52652: LD_INT 22
52654: PUSH
52655: LD_INT 24
52657: PUSH
52658: EMPTY
52659: LIST
52660: LIST
52661: LIST
52662: LIST
52663: LIST
52664: LIST
52665: LIST
52666: LIST
52667: LIST
52668: LIST
52669: LIST
52670: LIST
52671: LIST
52672: ST_TO_ADDR
52673: GO 52734
52675: LD_INT 3
52677: DOUBLE
52678: EQUAL
52679: IFTRUE 52683
52681: GO 52733
52683: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
52684: LD_ADDR_VAR 0 3
52688: PUSH
52689: LD_INT 13
52691: PUSH
52692: LD_INT 14
52694: PUSH
52695: LD_INT 2
52697: PUSH
52698: LD_INT 3
52700: PUSH
52701: LD_INT 4
52703: PUSH
52704: LD_INT 5
52706: PUSH
52707: LD_INT 21
52709: PUSH
52710: LD_INT 22
52712: PUSH
52713: LD_INT 23
52715: PUSH
52716: LD_INT 24
52718: PUSH
52719: EMPTY
52720: LIST
52721: LIST
52722: LIST
52723: LIST
52724: LIST
52725: LIST
52726: LIST
52727: LIST
52728: LIST
52729: LIST
52730: ST_TO_ADDR
52731: GO 52734
52733: POP
// result := ( chassis in result ) ;
52734: LD_ADDR_VAR 0 3
52738: PUSH
52739: LD_VAR 0 1
52743: PUSH
52744: LD_VAR 0 3
52748: IN
52749: ST_TO_ADDR
// end ;
52750: LD_VAR 0 3
52754: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
52755: LD_INT 0
52757: PPUSH
// if not chassis or not weapon then
52758: LD_VAR 0 1
52762: NOT
52763: PUSH
52764: LD_VAR 0 2
52768: NOT
52769: OR
52770: IFFALSE 52774
// exit ;
52772: GO 53800
// case weapon of us_machine_gun :
52774: LD_VAR 0 2
52778: PUSH
52779: LD_INT 2
52781: DOUBLE
52782: EQUAL
52783: IFTRUE 52787
52785: GO 52817
52787: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
52788: LD_ADDR_VAR 0 3
52792: PUSH
52793: LD_INT 1
52795: PUSH
52796: LD_INT 2
52798: PUSH
52799: LD_INT 3
52801: PUSH
52802: LD_INT 4
52804: PUSH
52805: LD_INT 5
52807: PUSH
52808: EMPTY
52809: LIST
52810: LIST
52811: LIST
52812: LIST
52813: LIST
52814: ST_TO_ADDR
52815: GO 53784
52817: LD_INT 3
52819: DOUBLE
52820: EQUAL
52821: IFTRUE 52825
52823: GO 52855
52825: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
52826: LD_ADDR_VAR 0 3
52830: PUSH
52831: LD_INT 1
52833: PUSH
52834: LD_INT 2
52836: PUSH
52837: LD_INT 3
52839: PUSH
52840: LD_INT 4
52842: PUSH
52843: LD_INT 5
52845: PUSH
52846: EMPTY
52847: LIST
52848: LIST
52849: LIST
52850: LIST
52851: LIST
52852: ST_TO_ADDR
52853: GO 53784
52855: LD_INT 11
52857: DOUBLE
52858: EQUAL
52859: IFTRUE 52863
52861: GO 52893
52863: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
52864: LD_ADDR_VAR 0 3
52868: PUSH
52869: LD_INT 1
52871: PUSH
52872: LD_INT 2
52874: PUSH
52875: LD_INT 3
52877: PUSH
52878: LD_INT 4
52880: PUSH
52881: LD_INT 5
52883: PUSH
52884: EMPTY
52885: LIST
52886: LIST
52887: LIST
52888: LIST
52889: LIST
52890: ST_TO_ADDR
52891: GO 53784
52893: LD_INT 4
52895: DOUBLE
52896: EQUAL
52897: IFTRUE 52901
52899: GO 52927
52901: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
52902: LD_ADDR_VAR 0 3
52906: PUSH
52907: LD_INT 2
52909: PUSH
52910: LD_INT 3
52912: PUSH
52913: LD_INT 4
52915: PUSH
52916: LD_INT 5
52918: PUSH
52919: EMPTY
52920: LIST
52921: LIST
52922: LIST
52923: LIST
52924: ST_TO_ADDR
52925: GO 53784
52927: LD_INT 5
52929: DOUBLE
52930: EQUAL
52931: IFTRUE 52935
52933: GO 52961
52935: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
52936: LD_ADDR_VAR 0 3
52940: PUSH
52941: LD_INT 2
52943: PUSH
52944: LD_INT 3
52946: PUSH
52947: LD_INT 4
52949: PUSH
52950: LD_INT 5
52952: PUSH
52953: EMPTY
52954: LIST
52955: LIST
52956: LIST
52957: LIST
52958: ST_TO_ADDR
52959: GO 53784
52961: LD_INT 9
52963: DOUBLE
52964: EQUAL
52965: IFTRUE 52969
52967: GO 52995
52969: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
52970: LD_ADDR_VAR 0 3
52974: PUSH
52975: LD_INT 2
52977: PUSH
52978: LD_INT 3
52980: PUSH
52981: LD_INT 4
52983: PUSH
52984: LD_INT 5
52986: PUSH
52987: EMPTY
52988: LIST
52989: LIST
52990: LIST
52991: LIST
52992: ST_TO_ADDR
52993: GO 53784
52995: LD_INT 7
52997: DOUBLE
52998: EQUAL
52999: IFTRUE 53003
53001: GO 53029
53003: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
53004: LD_ADDR_VAR 0 3
53008: PUSH
53009: LD_INT 2
53011: PUSH
53012: LD_INT 3
53014: PUSH
53015: LD_INT 4
53017: PUSH
53018: LD_INT 5
53020: PUSH
53021: EMPTY
53022: LIST
53023: LIST
53024: LIST
53025: LIST
53026: ST_TO_ADDR
53027: GO 53784
53029: LD_INT 12
53031: DOUBLE
53032: EQUAL
53033: IFTRUE 53037
53035: GO 53063
53037: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
53038: LD_ADDR_VAR 0 3
53042: PUSH
53043: LD_INT 2
53045: PUSH
53046: LD_INT 3
53048: PUSH
53049: LD_INT 4
53051: PUSH
53052: LD_INT 5
53054: PUSH
53055: EMPTY
53056: LIST
53057: LIST
53058: LIST
53059: LIST
53060: ST_TO_ADDR
53061: GO 53784
53063: LD_INT 13
53065: DOUBLE
53066: EQUAL
53067: IFTRUE 53071
53069: GO 53097
53071: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
53072: LD_ADDR_VAR 0 3
53076: PUSH
53077: LD_INT 2
53079: PUSH
53080: LD_INT 3
53082: PUSH
53083: LD_INT 4
53085: PUSH
53086: LD_INT 5
53088: PUSH
53089: EMPTY
53090: LIST
53091: LIST
53092: LIST
53093: LIST
53094: ST_TO_ADDR
53095: GO 53784
53097: LD_INT 14
53099: DOUBLE
53100: EQUAL
53101: IFTRUE 53105
53103: GO 53123
53105: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
53106: LD_ADDR_VAR 0 3
53110: PUSH
53111: LD_INT 4
53113: PUSH
53114: LD_INT 5
53116: PUSH
53117: EMPTY
53118: LIST
53119: LIST
53120: ST_TO_ADDR
53121: GO 53784
53123: LD_INT 6
53125: DOUBLE
53126: EQUAL
53127: IFTRUE 53131
53129: GO 53149
53131: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
53132: LD_ADDR_VAR 0 3
53136: PUSH
53137: LD_INT 4
53139: PUSH
53140: LD_INT 5
53142: PUSH
53143: EMPTY
53144: LIST
53145: LIST
53146: ST_TO_ADDR
53147: GO 53784
53149: LD_INT 10
53151: DOUBLE
53152: EQUAL
53153: IFTRUE 53157
53155: GO 53175
53157: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
53158: LD_ADDR_VAR 0 3
53162: PUSH
53163: LD_INT 4
53165: PUSH
53166: LD_INT 5
53168: PUSH
53169: EMPTY
53170: LIST
53171: LIST
53172: ST_TO_ADDR
53173: GO 53784
53175: LD_INT 22
53177: DOUBLE
53178: EQUAL
53179: IFTRUE 53183
53181: GO 53209
53183: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
53184: LD_ADDR_VAR 0 3
53188: PUSH
53189: LD_INT 11
53191: PUSH
53192: LD_INT 12
53194: PUSH
53195: LD_INT 13
53197: PUSH
53198: LD_INT 14
53200: PUSH
53201: EMPTY
53202: LIST
53203: LIST
53204: LIST
53205: LIST
53206: ST_TO_ADDR
53207: GO 53784
53209: LD_INT 23
53211: DOUBLE
53212: EQUAL
53213: IFTRUE 53217
53215: GO 53243
53217: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
53218: LD_ADDR_VAR 0 3
53222: PUSH
53223: LD_INT 11
53225: PUSH
53226: LD_INT 12
53228: PUSH
53229: LD_INT 13
53231: PUSH
53232: LD_INT 14
53234: PUSH
53235: EMPTY
53236: LIST
53237: LIST
53238: LIST
53239: LIST
53240: ST_TO_ADDR
53241: GO 53784
53243: LD_INT 24
53245: DOUBLE
53246: EQUAL
53247: IFTRUE 53251
53249: GO 53277
53251: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
53252: LD_ADDR_VAR 0 3
53256: PUSH
53257: LD_INT 11
53259: PUSH
53260: LD_INT 12
53262: PUSH
53263: LD_INT 13
53265: PUSH
53266: LD_INT 14
53268: PUSH
53269: EMPTY
53270: LIST
53271: LIST
53272: LIST
53273: LIST
53274: ST_TO_ADDR
53275: GO 53784
53277: LD_INT 30
53279: DOUBLE
53280: EQUAL
53281: IFTRUE 53285
53283: GO 53311
53285: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
53286: LD_ADDR_VAR 0 3
53290: PUSH
53291: LD_INT 11
53293: PUSH
53294: LD_INT 12
53296: PUSH
53297: LD_INT 13
53299: PUSH
53300: LD_INT 14
53302: PUSH
53303: EMPTY
53304: LIST
53305: LIST
53306: LIST
53307: LIST
53308: ST_TO_ADDR
53309: GO 53784
53311: LD_INT 25
53313: DOUBLE
53314: EQUAL
53315: IFTRUE 53319
53317: GO 53337
53319: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
53320: LD_ADDR_VAR 0 3
53324: PUSH
53325: LD_INT 13
53327: PUSH
53328: LD_INT 14
53330: PUSH
53331: EMPTY
53332: LIST
53333: LIST
53334: ST_TO_ADDR
53335: GO 53784
53337: LD_INT 27
53339: DOUBLE
53340: EQUAL
53341: IFTRUE 53345
53343: GO 53363
53345: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
53346: LD_ADDR_VAR 0 3
53350: PUSH
53351: LD_INT 13
53353: PUSH
53354: LD_INT 14
53356: PUSH
53357: EMPTY
53358: LIST
53359: LIST
53360: ST_TO_ADDR
53361: GO 53784
53363: LD_INT 28
53365: DOUBLE
53366: EQUAL
53367: IFTRUE 53371
53369: GO 53389
53371: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
53372: LD_ADDR_VAR 0 3
53376: PUSH
53377: LD_INT 13
53379: PUSH
53380: LD_INT 14
53382: PUSH
53383: EMPTY
53384: LIST
53385: LIST
53386: ST_TO_ADDR
53387: GO 53784
53389: LD_INT 29
53391: DOUBLE
53392: EQUAL
53393: IFTRUE 53397
53395: GO 53415
53397: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
53398: LD_ADDR_VAR 0 3
53402: PUSH
53403: LD_INT 13
53405: PUSH
53406: LD_INT 14
53408: PUSH
53409: EMPTY
53410: LIST
53411: LIST
53412: ST_TO_ADDR
53413: GO 53784
53415: LD_INT 31
53417: DOUBLE
53418: EQUAL
53419: IFTRUE 53423
53421: GO 53441
53423: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
53424: LD_ADDR_VAR 0 3
53428: PUSH
53429: LD_INT 13
53431: PUSH
53432: LD_INT 14
53434: PUSH
53435: EMPTY
53436: LIST
53437: LIST
53438: ST_TO_ADDR
53439: GO 53784
53441: LD_INT 26
53443: DOUBLE
53444: EQUAL
53445: IFTRUE 53449
53447: GO 53467
53449: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
53450: LD_ADDR_VAR 0 3
53454: PUSH
53455: LD_INT 13
53457: PUSH
53458: LD_INT 14
53460: PUSH
53461: EMPTY
53462: LIST
53463: LIST
53464: ST_TO_ADDR
53465: GO 53784
53467: LD_INT 42
53469: DOUBLE
53470: EQUAL
53471: IFTRUE 53475
53473: GO 53501
53475: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
53476: LD_ADDR_VAR 0 3
53480: PUSH
53481: LD_INT 21
53483: PUSH
53484: LD_INT 22
53486: PUSH
53487: LD_INT 23
53489: PUSH
53490: LD_INT 24
53492: PUSH
53493: EMPTY
53494: LIST
53495: LIST
53496: LIST
53497: LIST
53498: ST_TO_ADDR
53499: GO 53784
53501: LD_INT 43
53503: DOUBLE
53504: EQUAL
53505: IFTRUE 53509
53507: GO 53535
53509: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
53510: LD_ADDR_VAR 0 3
53514: PUSH
53515: LD_INT 21
53517: PUSH
53518: LD_INT 22
53520: PUSH
53521: LD_INT 23
53523: PUSH
53524: LD_INT 24
53526: PUSH
53527: EMPTY
53528: LIST
53529: LIST
53530: LIST
53531: LIST
53532: ST_TO_ADDR
53533: GO 53784
53535: LD_INT 44
53537: DOUBLE
53538: EQUAL
53539: IFTRUE 53543
53541: GO 53569
53543: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
53544: LD_ADDR_VAR 0 3
53548: PUSH
53549: LD_INT 21
53551: PUSH
53552: LD_INT 22
53554: PUSH
53555: LD_INT 23
53557: PUSH
53558: LD_INT 24
53560: PUSH
53561: EMPTY
53562: LIST
53563: LIST
53564: LIST
53565: LIST
53566: ST_TO_ADDR
53567: GO 53784
53569: LD_INT 45
53571: DOUBLE
53572: EQUAL
53573: IFTRUE 53577
53575: GO 53603
53577: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
53578: LD_ADDR_VAR 0 3
53582: PUSH
53583: LD_INT 21
53585: PUSH
53586: LD_INT 22
53588: PUSH
53589: LD_INT 23
53591: PUSH
53592: LD_INT 24
53594: PUSH
53595: EMPTY
53596: LIST
53597: LIST
53598: LIST
53599: LIST
53600: ST_TO_ADDR
53601: GO 53784
53603: LD_INT 49
53605: DOUBLE
53606: EQUAL
53607: IFTRUE 53611
53609: GO 53637
53611: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
53612: LD_ADDR_VAR 0 3
53616: PUSH
53617: LD_INT 21
53619: PUSH
53620: LD_INT 22
53622: PUSH
53623: LD_INT 23
53625: PUSH
53626: LD_INT 24
53628: PUSH
53629: EMPTY
53630: LIST
53631: LIST
53632: LIST
53633: LIST
53634: ST_TO_ADDR
53635: GO 53784
53637: LD_INT 51
53639: DOUBLE
53640: EQUAL
53641: IFTRUE 53645
53643: GO 53671
53645: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
53646: LD_ADDR_VAR 0 3
53650: PUSH
53651: LD_INT 21
53653: PUSH
53654: LD_INT 22
53656: PUSH
53657: LD_INT 23
53659: PUSH
53660: LD_INT 24
53662: PUSH
53663: EMPTY
53664: LIST
53665: LIST
53666: LIST
53667: LIST
53668: ST_TO_ADDR
53669: GO 53784
53671: LD_INT 52
53673: DOUBLE
53674: EQUAL
53675: IFTRUE 53679
53677: GO 53705
53679: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
53680: LD_ADDR_VAR 0 3
53684: PUSH
53685: LD_INT 21
53687: PUSH
53688: LD_INT 22
53690: PUSH
53691: LD_INT 23
53693: PUSH
53694: LD_INT 24
53696: PUSH
53697: EMPTY
53698: LIST
53699: LIST
53700: LIST
53701: LIST
53702: ST_TO_ADDR
53703: GO 53784
53705: LD_INT 53
53707: DOUBLE
53708: EQUAL
53709: IFTRUE 53713
53711: GO 53731
53713: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
53714: LD_ADDR_VAR 0 3
53718: PUSH
53719: LD_INT 23
53721: PUSH
53722: LD_INT 24
53724: PUSH
53725: EMPTY
53726: LIST
53727: LIST
53728: ST_TO_ADDR
53729: GO 53784
53731: LD_INT 46
53733: DOUBLE
53734: EQUAL
53735: IFTRUE 53739
53737: GO 53757
53739: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
53740: LD_ADDR_VAR 0 3
53744: PUSH
53745: LD_INT 23
53747: PUSH
53748: LD_INT 24
53750: PUSH
53751: EMPTY
53752: LIST
53753: LIST
53754: ST_TO_ADDR
53755: GO 53784
53757: LD_INT 47
53759: DOUBLE
53760: EQUAL
53761: IFTRUE 53765
53763: GO 53783
53765: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
53766: LD_ADDR_VAR 0 3
53770: PUSH
53771: LD_INT 23
53773: PUSH
53774: LD_INT 24
53776: PUSH
53777: EMPTY
53778: LIST
53779: LIST
53780: ST_TO_ADDR
53781: GO 53784
53783: POP
// result := ( chassis in result ) ;
53784: LD_ADDR_VAR 0 3
53788: PUSH
53789: LD_VAR 0 1
53793: PUSH
53794: LD_VAR 0 3
53798: IN
53799: ST_TO_ADDR
// end ;
53800: LD_VAR 0 3
53804: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
53805: LD_INT 0
53807: PPUSH
53808: PPUSH
53809: PPUSH
53810: PPUSH
53811: PPUSH
53812: PPUSH
53813: PPUSH
// result := array ;
53814: LD_ADDR_VAR 0 5
53818: PUSH
53819: LD_VAR 0 1
53823: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
53824: LD_VAR 0 1
53828: NOT
53829: PUSH
53830: LD_VAR 0 2
53834: NOT
53835: OR
53836: PUSH
53837: LD_VAR 0 3
53841: NOT
53842: OR
53843: PUSH
53844: LD_VAR 0 2
53848: PUSH
53849: LD_VAR 0 1
53853: GREATER
53854: OR
53855: PUSH
53856: LD_VAR 0 3
53860: PUSH
53861: LD_VAR 0 1
53865: GREATER
53866: OR
53867: IFFALSE 53871
// exit ;
53869: GO 54167
// if direction then
53871: LD_VAR 0 4
53875: IFFALSE 53939
// begin d := 1 ;
53877: LD_ADDR_VAR 0 9
53881: PUSH
53882: LD_INT 1
53884: ST_TO_ADDR
// if i_from > i_to then
53885: LD_VAR 0 2
53889: PUSH
53890: LD_VAR 0 3
53894: GREATER
53895: IFFALSE 53921
// length := ( array - i_from ) + i_to else
53897: LD_ADDR_VAR 0 11
53901: PUSH
53902: LD_VAR 0 1
53906: PUSH
53907: LD_VAR 0 2
53911: MINUS
53912: PUSH
53913: LD_VAR 0 3
53917: PLUS
53918: ST_TO_ADDR
53919: GO 53937
// length := i_to - i_from ;
53921: LD_ADDR_VAR 0 11
53925: PUSH
53926: LD_VAR 0 3
53930: PUSH
53931: LD_VAR 0 2
53935: MINUS
53936: ST_TO_ADDR
// end else
53937: GO 54000
// begin d := - 1 ;
53939: LD_ADDR_VAR 0 9
53943: PUSH
53944: LD_INT 1
53946: NEG
53947: ST_TO_ADDR
// if i_from > i_to then
53948: LD_VAR 0 2
53952: PUSH
53953: LD_VAR 0 3
53957: GREATER
53958: IFFALSE 53978
// length := i_from - i_to else
53960: LD_ADDR_VAR 0 11
53964: PUSH
53965: LD_VAR 0 2
53969: PUSH
53970: LD_VAR 0 3
53974: MINUS
53975: ST_TO_ADDR
53976: GO 54000
// length := ( array - i_to ) + i_from ;
53978: LD_ADDR_VAR 0 11
53982: PUSH
53983: LD_VAR 0 1
53987: PUSH
53988: LD_VAR 0 3
53992: MINUS
53993: PUSH
53994: LD_VAR 0 2
53998: PLUS
53999: ST_TO_ADDR
// end ; if not length then
54000: LD_VAR 0 11
54004: NOT
54005: IFFALSE 54009
// exit ;
54007: GO 54167
// tmp := array ;
54009: LD_ADDR_VAR 0 10
54013: PUSH
54014: LD_VAR 0 1
54018: ST_TO_ADDR
// for i = 1 to length do
54019: LD_ADDR_VAR 0 6
54023: PUSH
54024: DOUBLE
54025: LD_INT 1
54027: DEC
54028: ST_TO_ADDR
54029: LD_VAR 0 11
54033: PUSH
54034: FOR_TO
54035: IFFALSE 54155
// begin for j = 1 to array do
54037: LD_ADDR_VAR 0 7
54041: PUSH
54042: DOUBLE
54043: LD_INT 1
54045: DEC
54046: ST_TO_ADDR
54047: LD_VAR 0 1
54051: PUSH
54052: FOR_TO
54053: IFFALSE 54141
// begin k := j + d ;
54055: LD_ADDR_VAR 0 8
54059: PUSH
54060: LD_VAR 0 7
54064: PUSH
54065: LD_VAR 0 9
54069: PLUS
54070: ST_TO_ADDR
// if k > array then
54071: LD_VAR 0 8
54075: PUSH
54076: LD_VAR 0 1
54080: GREATER
54081: IFFALSE 54091
// k := 1 ;
54083: LD_ADDR_VAR 0 8
54087: PUSH
54088: LD_INT 1
54090: ST_TO_ADDR
// if not k then
54091: LD_VAR 0 8
54095: NOT
54096: IFFALSE 54108
// k := array ;
54098: LD_ADDR_VAR 0 8
54102: PUSH
54103: LD_VAR 0 1
54107: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
54108: LD_ADDR_VAR 0 10
54112: PUSH
54113: LD_VAR 0 10
54117: PPUSH
54118: LD_VAR 0 8
54122: PPUSH
54123: LD_VAR 0 1
54127: PUSH
54128: LD_VAR 0 7
54132: ARRAY
54133: PPUSH
54134: CALL_OW 1
54138: ST_TO_ADDR
// end ;
54139: GO 54052
54141: POP
54142: POP
// array := tmp ;
54143: LD_ADDR_VAR 0 1
54147: PUSH
54148: LD_VAR 0 10
54152: ST_TO_ADDR
// end ;
54153: GO 54034
54155: POP
54156: POP
// result := array ;
54157: LD_ADDR_VAR 0 5
54161: PUSH
54162: LD_VAR 0 1
54166: ST_TO_ADDR
// end ;
54167: LD_VAR 0 5
54171: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
54172: LD_INT 0
54174: PPUSH
54175: PPUSH
// result := 0 ;
54176: LD_ADDR_VAR 0 3
54180: PUSH
54181: LD_INT 0
54183: ST_TO_ADDR
// if not array or not value in array then
54184: LD_VAR 0 1
54188: NOT
54189: PUSH
54190: LD_VAR 0 2
54194: PUSH
54195: LD_VAR 0 1
54199: IN
54200: NOT
54201: OR
54202: IFFALSE 54206
// exit ;
54204: GO 54260
// for i = 1 to array do
54206: LD_ADDR_VAR 0 4
54210: PUSH
54211: DOUBLE
54212: LD_INT 1
54214: DEC
54215: ST_TO_ADDR
54216: LD_VAR 0 1
54220: PUSH
54221: FOR_TO
54222: IFFALSE 54258
// if value = array [ i ] then
54224: LD_VAR 0 2
54228: PUSH
54229: LD_VAR 0 1
54233: PUSH
54234: LD_VAR 0 4
54238: ARRAY
54239: EQUAL
54240: IFFALSE 54256
// begin result := i ;
54242: LD_ADDR_VAR 0 3
54246: PUSH
54247: LD_VAR 0 4
54251: ST_TO_ADDR
// exit ;
54252: POP
54253: POP
54254: GO 54260
// end ;
54256: GO 54221
54258: POP
54259: POP
// end ;
54260: LD_VAR 0 3
54264: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
54265: LD_INT 0
54267: PPUSH
// vc_chassis := chassis ;
54268: LD_ADDR_OWVAR 37
54272: PUSH
54273: LD_VAR 0 1
54277: ST_TO_ADDR
// vc_engine := engine ;
54278: LD_ADDR_OWVAR 39
54282: PUSH
54283: LD_VAR 0 2
54287: ST_TO_ADDR
// vc_control := control ;
54288: LD_ADDR_OWVAR 38
54292: PUSH
54293: LD_VAR 0 3
54297: ST_TO_ADDR
// vc_weapon := weapon ;
54298: LD_ADDR_OWVAR 40
54302: PUSH
54303: LD_VAR 0 4
54307: ST_TO_ADDR
// vc_fuel_battery := fuel ;
54308: LD_ADDR_OWVAR 41
54312: PUSH
54313: LD_VAR 0 5
54317: ST_TO_ADDR
// end ;
54318: LD_VAR 0 6
54322: RET
// export function WantPlant ( unit ) ; var task ; begin
54323: LD_INT 0
54325: PPUSH
54326: PPUSH
// result := false ;
54327: LD_ADDR_VAR 0 2
54331: PUSH
54332: LD_INT 0
54334: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
54335: LD_ADDR_VAR 0 3
54339: PUSH
54340: LD_VAR 0 1
54344: PPUSH
54345: CALL_OW 437
54349: ST_TO_ADDR
// if task then
54350: LD_VAR 0 3
54354: IFFALSE 54382
// if task [ 1 ] [ 1 ] = p then
54356: LD_VAR 0 3
54360: PUSH
54361: LD_INT 1
54363: ARRAY
54364: PUSH
54365: LD_INT 1
54367: ARRAY
54368: PUSH
54369: LD_STRING p
54371: EQUAL
54372: IFFALSE 54382
// result := true ;
54374: LD_ADDR_VAR 0 2
54378: PUSH
54379: LD_INT 1
54381: ST_TO_ADDR
// end ;
54382: LD_VAR 0 2
54386: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
54387: LD_INT 0
54389: PPUSH
54390: PPUSH
54391: PPUSH
54392: PPUSH
// if pos < 1 then
54393: LD_VAR 0 2
54397: PUSH
54398: LD_INT 1
54400: LESS
54401: IFFALSE 54405
// exit ;
54403: GO 54708
// if pos = 1 then
54405: LD_VAR 0 2
54409: PUSH
54410: LD_INT 1
54412: EQUAL
54413: IFFALSE 54446
// result := Replace ( arr , pos [ 1 ] , value ) else
54415: LD_ADDR_VAR 0 4
54419: PUSH
54420: LD_VAR 0 1
54424: PPUSH
54425: LD_VAR 0 2
54429: PUSH
54430: LD_INT 1
54432: ARRAY
54433: PPUSH
54434: LD_VAR 0 3
54438: PPUSH
54439: CALL_OW 1
54443: ST_TO_ADDR
54444: GO 54708
// begin tmp := arr ;
54446: LD_ADDR_VAR 0 6
54450: PUSH
54451: LD_VAR 0 1
54455: ST_TO_ADDR
// s_arr := [ tmp ] ;
54456: LD_ADDR_VAR 0 7
54460: PUSH
54461: LD_VAR 0 6
54465: PUSH
54466: EMPTY
54467: LIST
54468: ST_TO_ADDR
// for i = 1 to pos - 1 do
54469: LD_ADDR_VAR 0 5
54473: PUSH
54474: DOUBLE
54475: LD_INT 1
54477: DEC
54478: ST_TO_ADDR
54479: LD_VAR 0 2
54483: PUSH
54484: LD_INT 1
54486: MINUS
54487: PUSH
54488: FOR_TO
54489: IFFALSE 54534
// begin tmp := tmp [ pos [ i ] ] ;
54491: LD_ADDR_VAR 0 6
54495: PUSH
54496: LD_VAR 0 6
54500: PUSH
54501: LD_VAR 0 2
54505: PUSH
54506: LD_VAR 0 5
54510: ARRAY
54511: ARRAY
54512: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
54513: LD_ADDR_VAR 0 7
54517: PUSH
54518: LD_VAR 0 7
54522: PUSH
54523: LD_VAR 0 6
54527: PUSH
54528: EMPTY
54529: LIST
54530: ADD
54531: ST_TO_ADDR
// end ;
54532: GO 54488
54534: POP
54535: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
54536: LD_ADDR_VAR 0 6
54540: PUSH
54541: LD_VAR 0 6
54545: PPUSH
54546: LD_VAR 0 2
54550: PUSH
54551: LD_VAR 0 2
54555: ARRAY
54556: PPUSH
54557: LD_VAR 0 3
54561: PPUSH
54562: CALL_OW 1
54566: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
54567: LD_ADDR_VAR 0 7
54571: PUSH
54572: LD_VAR 0 7
54576: PPUSH
54577: LD_VAR 0 7
54581: PPUSH
54582: LD_VAR 0 6
54586: PPUSH
54587: CALL_OW 1
54591: ST_TO_ADDR
// for i = s_arr downto 2 do
54592: LD_ADDR_VAR 0 5
54596: PUSH
54597: DOUBLE
54598: LD_VAR 0 7
54602: INC
54603: ST_TO_ADDR
54604: LD_INT 2
54606: PUSH
54607: FOR_DOWNTO
54608: IFFALSE 54692
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
54610: LD_ADDR_VAR 0 6
54614: PUSH
54615: LD_VAR 0 7
54619: PUSH
54620: LD_VAR 0 5
54624: PUSH
54625: LD_INT 1
54627: MINUS
54628: ARRAY
54629: PPUSH
54630: LD_VAR 0 2
54634: PUSH
54635: LD_VAR 0 5
54639: PUSH
54640: LD_INT 1
54642: MINUS
54643: ARRAY
54644: PPUSH
54645: LD_VAR 0 7
54649: PUSH
54650: LD_VAR 0 5
54654: ARRAY
54655: PPUSH
54656: CALL_OW 1
54660: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
54661: LD_ADDR_VAR 0 7
54665: PUSH
54666: LD_VAR 0 7
54670: PPUSH
54671: LD_VAR 0 5
54675: PUSH
54676: LD_INT 1
54678: MINUS
54679: PPUSH
54680: LD_VAR 0 6
54684: PPUSH
54685: CALL_OW 1
54689: ST_TO_ADDR
// end ;
54690: GO 54607
54692: POP
54693: POP
// result := s_arr [ 1 ] ;
54694: LD_ADDR_VAR 0 4
54698: PUSH
54699: LD_VAR 0 7
54703: PUSH
54704: LD_INT 1
54706: ARRAY
54707: ST_TO_ADDR
// end ; end ;
54708: LD_VAR 0 4
54712: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
54713: LD_INT 0
54715: PPUSH
54716: PPUSH
// if not list then
54717: LD_VAR 0 1
54721: NOT
54722: IFFALSE 54726
// exit ;
54724: GO 54817
// i := list [ pos1 ] ;
54726: LD_ADDR_VAR 0 5
54730: PUSH
54731: LD_VAR 0 1
54735: PUSH
54736: LD_VAR 0 2
54740: ARRAY
54741: ST_TO_ADDR
// if not i then
54742: LD_VAR 0 5
54746: NOT
54747: IFFALSE 54751
// exit ;
54749: GO 54817
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
54751: LD_ADDR_VAR 0 1
54755: PUSH
54756: LD_VAR 0 1
54760: PPUSH
54761: LD_VAR 0 2
54765: PPUSH
54766: LD_VAR 0 1
54770: PUSH
54771: LD_VAR 0 3
54775: ARRAY
54776: PPUSH
54777: CALL_OW 1
54781: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
54782: LD_ADDR_VAR 0 1
54786: PUSH
54787: LD_VAR 0 1
54791: PPUSH
54792: LD_VAR 0 3
54796: PPUSH
54797: LD_VAR 0 5
54801: PPUSH
54802: CALL_OW 1
54806: ST_TO_ADDR
// result := list ;
54807: LD_ADDR_VAR 0 4
54811: PUSH
54812: LD_VAR 0 1
54816: ST_TO_ADDR
// end ;
54817: LD_VAR 0 4
54821: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
54822: LD_INT 0
54824: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
54825: LD_ADDR_VAR 0 5
54829: PUSH
54830: LD_VAR 0 1
54834: PPUSH
54835: CALL_OW 250
54839: PPUSH
54840: LD_VAR 0 1
54844: PPUSH
54845: CALL_OW 251
54849: PPUSH
54850: LD_VAR 0 2
54854: PPUSH
54855: LD_VAR 0 3
54859: PPUSH
54860: LD_VAR 0 4
54864: PPUSH
54865: CALL 54875 0 5
54869: ST_TO_ADDR
// end ;
54870: LD_VAR 0 5
54874: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
54875: LD_INT 0
54877: PPUSH
54878: PPUSH
54879: PPUSH
54880: PPUSH
// if not list then
54881: LD_VAR 0 3
54885: NOT
54886: IFFALSE 54890
// exit ;
54888: GO 55278
// result := [ ] ;
54890: LD_ADDR_VAR 0 6
54894: PUSH
54895: EMPTY
54896: ST_TO_ADDR
// for i in list do
54897: LD_ADDR_VAR 0 7
54901: PUSH
54902: LD_VAR 0 3
54906: PUSH
54907: FOR_IN
54908: IFFALSE 55110
// begin tmp := GetDistUnitXY ( i , x , y ) ;
54910: LD_ADDR_VAR 0 9
54914: PUSH
54915: LD_VAR 0 7
54919: PPUSH
54920: LD_VAR 0 1
54924: PPUSH
54925: LD_VAR 0 2
54929: PPUSH
54930: CALL_OW 297
54934: ST_TO_ADDR
// if not result then
54935: LD_VAR 0 6
54939: NOT
54940: IFFALSE 54966
// result := [ [ i , tmp ] ] else
54942: LD_ADDR_VAR 0 6
54946: PUSH
54947: LD_VAR 0 7
54951: PUSH
54952: LD_VAR 0 9
54956: PUSH
54957: EMPTY
54958: LIST
54959: LIST
54960: PUSH
54961: EMPTY
54962: LIST
54963: ST_TO_ADDR
54964: GO 55108
// begin if result [ result ] [ 2 ] < tmp then
54966: LD_VAR 0 6
54970: PUSH
54971: LD_VAR 0 6
54975: ARRAY
54976: PUSH
54977: LD_INT 2
54979: ARRAY
54980: PUSH
54981: LD_VAR 0 9
54985: LESS
54986: IFFALSE 55028
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
54988: LD_ADDR_VAR 0 6
54992: PUSH
54993: LD_VAR 0 6
54997: PPUSH
54998: LD_VAR 0 6
55002: PUSH
55003: LD_INT 1
55005: PLUS
55006: PPUSH
55007: LD_VAR 0 7
55011: PUSH
55012: LD_VAR 0 9
55016: PUSH
55017: EMPTY
55018: LIST
55019: LIST
55020: PPUSH
55021: CALL_OW 2
55025: ST_TO_ADDR
55026: GO 55108
// for j = 1 to result do
55028: LD_ADDR_VAR 0 8
55032: PUSH
55033: DOUBLE
55034: LD_INT 1
55036: DEC
55037: ST_TO_ADDR
55038: LD_VAR 0 6
55042: PUSH
55043: FOR_TO
55044: IFFALSE 55106
// begin if tmp < result [ j ] [ 2 ] then
55046: LD_VAR 0 9
55050: PUSH
55051: LD_VAR 0 6
55055: PUSH
55056: LD_VAR 0 8
55060: ARRAY
55061: PUSH
55062: LD_INT 2
55064: ARRAY
55065: LESS
55066: IFFALSE 55104
// begin result := Insert ( result , j , [ i , tmp ] ) ;
55068: LD_ADDR_VAR 0 6
55072: PUSH
55073: LD_VAR 0 6
55077: PPUSH
55078: LD_VAR 0 8
55082: PPUSH
55083: LD_VAR 0 7
55087: PUSH
55088: LD_VAR 0 9
55092: PUSH
55093: EMPTY
55094: LIST
55095: LIST
55096: PPUSH
55097: CALL_OW 2
55101: ST_TO_ADDR
// break ;
55102: GO 55106
// end ; end ;
55104: GO 55043
55106: POP
55107: POP
// end ; end ;
55108: GO 54907
55110: POP
55111: POP
// if result and not asc then
55112: LD_VAR 0 6
55116: PUSH
55117: LD_VAR 0 4
55121: NOT
55122: AND
55123: IFFALSE 55198
// begin tmp := result ;
55125: LD_ADDR_VAR 0 9
55129: PUSH
55130: LD_VAR 0 6
55134: ST_TO_ADDR
// for i = tmp downto 1 do
55135: LD_ADDR_VAR 0 7
55139: PUSH
55140: DOUBLE
55141: LD_VAR 0 9
55145: INC
55146: ST_TO_ADDR
55147: LD_INT 1
55149: PUSH
55150: FOR_DOWNTO
55151: IFFALSE 55196
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
55153: LD_ADDR_VAR 0 6
55157: PUSH
55158: LD_VAR 0 6
55162: PPUSH
55163: LD_VAR 0 9
55167: PUSH
55168: LD_VAR 0 7
55172: MINUS
55173: PUSH
55174: LD_INT 1
55176: PLUS
55177: PPUSH
55178: LD_VAR 0 9
55182: PUSH
55183: LD_VAR 0 7
55187: ARRAY
55188: PPUSH
55189: CALL_OW 1
55193: ST_TO_ADDR
55194: GO 55150
55196: POP
55197: POP
// end ; tmp := [ ] ;
55198: LD_ADDR_VAR 0 9
55202: PUSH
55203: EMPTY
55204: ST_TO_ADDR
// if mode then
55205: LD_VAR 0 5
55209: IFFALSE 55278
// begin for i = 1 to result do
55211: LD_ADDR_VAR 0 7
55215: PUSH
55216: DOUBLE
55217: LD_INT 1
55219: DEC
55220: ST_TO_ADDR
55221: LD_VAR 0 6
55225: PUSH
55226: FOR_TO
55227: IFFALSE 55266
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
55229: LD_ADDR_VAR 0 9
55233: PUSH
55234: LD_VAR 0 9
55238: PPUSH
55239: LD_VAR 0 7
55243: PPUSH
55244: LD_VAR 0 6
55248: PUSH
55249: LD_VAR 0 7
55253: ARRAY
55254: PUSH
55255: LD_INT 1
55257: ARRAY
55258: PPUSH
55259: CALL_OW 1
55263: ST_TO_ADDR
55264: GO 55226
55266: POP
55267: POP
// result := tmp ;
55268: LD_ADDR_VAR 0 6
55272: PUSH
55273: LD_VAR 0 9
55277: ST_TO_ADDR
// end ; end ;
55278: LD_VAR 0 6
55282: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
55283: LD_INT 0
55285: PPUSH
55286: PPUSH
55287: PPUSH
55288: PPUSH
55289: PPUSH
55290: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
55291: LD_ADDR_VAR 0 5
55295: PUSH
55296: LD_INT 0
55298: PUSH
55299: LD_INT 0
55301: PUSH
55302: LD_INT 0
55304: PUSH
55305: EMPTY
55306: PUSH
55307: EMPTY
55308: LIST
55309: LIST
55310: LIST
55311: LIST
55312: ST_TO_ADDR
// if not x or not y then
55313: LD_VAR 0 2
55317: NOT
55318: PUSH
55319: LD_VAR 0 3
55323: NOT
55324: OR
55325: IFFALSE 55329
// exit ;
55327: GO 56975
// if not range then
55329: LD_VAR 0 4
55333: NOT
55334: IFFALSE 55344
// range := 10 ;
55336: LD_ADDR_VAR 0 4
55340: PUSH
55341: LD_INT 10
55343: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
55344: LD_ADDR_VAR 0 8
55348: PUSH
55349: LD_INT 81
55351: PUSH
55352: LD_VAR 0 1
55356: PUSH
55357: EMPTY
55358: LIST
55359: LIST
55360: PUSH
55361: LD_INT 92
55363: PUSH
55364: LD_VAR 0 2
55368: PUSH
55369: LD_VAR 0 3
55373: PUSH
55374: LD_VAR 0 4
55378: PUSH
55379: EMPTY
55380: LIST
55381: LIST
55382: LIST
55383: LIST
55384: PUSH
55385: LD_INT 3
55387: PUSH
55388: LD_INT 21
55390: PUSH
55391: LD_INT 3
55393: PUSH
55394: EMPTY
55395: LIST
55396: LIST
55397: PUSH
55398: EMPTY
55399: LIST
55400: LIST
55401: PUSH
55402: EMPTY
55403: LIST
55404: LIST
55405: LIST
55406: PPUSH
55407: CALL_OW 69
55411: ST_TO_ADDR
// if not tmp then
55412: LD_VAR 0 8
55416: NOT
55417: IFFALSE 55421
// exit ;
55419: GO 56975
// for i in tmp do
55421: LD_ADDR_VAR 0 6
55425: PUSH
55426: LD_VAR 0 8
55430: PUSH
55431: FOR_IN
55432: IFFALSE 56950
// begin points := [ 0 , 0 , 0 ] ;
55434: LD_ADDR_VAR 0 9
55438: PUSH
55439: LD_INT 0
55441: PUSH
55442: LD_INT 0
55444: PUSH
55445: LD_INT 0
55447: PUSH
55448: EMPTY
55449: LIST
55450: LIST
55451: LIST
55452: ST_TO_ADDR
// bpoints := 1 ;
55453: LD_ADDR_VAR 0 10
55457: PUSH
55458: LD_INT 1
55460: ST_TO_ADDR
// case GetType ( i ) of unit_human :
55461: LD_VAR 0 6
55465: PPUSH
55466: CALL_OW 247
55470: PUSH
55471: LD_INT 1
55473: DOUBLE
55474: EQUAL
55475: IFTRUE 55479
55477: GO 56057
55479: POP
// begin if GetClass ( i ) = 1 then
55480: LD_VAR 0 6
55484: PPUSH
55485: CALL_OW 257
55489: PUSH
55490: LD_INT 1
55492: EQUAL
55493: IFFALSE 55514
// points := [ 10 , 5 , 3 ] ;
55495: LD_ADDR_VAR 0 9
55499: PUSH
55500: LD_INT 10
55502: PUSH
55503: LD_INT 5
55505: PUSH
55506: LD_INT 3
55508: PUSH
55509: EMPTY
55510: LIST
55511: LIST
55512: LIST
55513: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
55514: LD_VAR 0 6
55518: PPUSH
55519: CALL_OW 257
55523: PUSH
55524: LD_INT 2
55526: PUSH
55527: LD_INT 3
55529: PUSH
55530: LD_INT 4
55532: PUSH
55533: EMPTY
55534: LIST
55535: LIST
55536: LIST
55537: IN
55538: IFFALSE 55559
// points := [ 3 , 2 , 1 ] ;
55540: LD_ADDR_VAR 0 9
55544: PUSH
55545: LD_INT 3
55547: PUSH
55548: LD_INT 2
55550: PUSH
55551: LD_INT 1
55553: PUSH
55554: EMPTY
55555: LIST
55556: LIST
55557: LIST
55558: ST_TO_ADDR
// if GetClass ( i ) = 5 then
55559: LD_VAR 0 6
55563: PPUSH
55564: CALL_OW 257
55568: PUSH
55569: LD_INT 5
55571: EQUAL
55572: IFFALSE 55593
// points := [ 130 , 5 , 2 ] ;
55574: LD_ADDR_VAR 0 9
55578: PUSH
55579: LD_INT 130
55581: PUSH
55582: LD_INT 5
55584: PUSH
55585: LD_INT 2
55587: PUSH
55588: EMPTY
55589: LIST
55590: LIST
55591: LIST
55592: ST_TO_ADDR
// if GetClass ( i ) = 8 then
55593: LD_VAR 0 6
55597: PPUSH
55598: CALL_OW 257
55602: PUSH
55603: LD_INT 8
55605: EQUAL
55606: IFFALSE 55627
// points := [ 35 , 35 , 30 ] ;
55608: LD_ADDR_VAR 0 9
55612: PUSH
55613: LD_INT 35
55615: PUSH
55616: LD_INT 35
55618: PUSH
55619: LD_INT 30
55621: PUSH
55622: EMPTY
55623: LIST
55624: LIST
55625: LIST
55626: ST_TO_ADDR
// if GetClass ( i ) = 9 then
55627: LD_VAR 0 6
55631: PPUSH
55632: CALL_OW 257
55636: PUSH
55637: LD_INT 9
55639: EQUAL
55640: IFFALSE 55661
// points := [ 20 , 55 , 40 ] ;
55642: LD_ADDR_VAR 0 9
55646: PUSH
55647: LD_INT 20
55649: PUSH
55650: LD_INT 55
55652: PUSH
55653: LD_INT 40
55655: PUSH
55656: EMPTY
55657: LIST
55658: LIST
55659: LIST
55660: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
55661: LD_VAR 0 6
55665: PPUSH
55666: CALL_OW 257
55670: PUSH
55671: LD_INT 12
55673: PUSH
55674: LD_INT 16
55676: PUSH
55677: EMPTY
55678: LIST
55679: LIST
55680: IN
55681: IFFALSE 55702
// points := [ 5 , 3 , 2 ] ;
55683: LD_ADDR_VAR 0 9
55687: PUSH
55688: LD_INT 5
55690: PUSH
55691: LD_INT 3
55693: PUSH
55694: LD_INT 2
55696: PUSH
55697: EMPTY
55698: LIST
55699: LIST
55700: LIST
55701: ST_TO_ADDR
// if GetClass ( i ) = 17 then
55702: LD_VAR 0 6
55706: PPUSH
55707: CALL_OW 257
55711: PUSH
55712: LD_INT 17
55714: EQUAL
55715: IFFALSE 55736
// points := [ 100 , 50 , 75 ] ;
55717: LD_ADDR_VAR 0 9
55721: PUSH
55722: LD_INT 100
55724: PUSH
55725: LD_INT 50
55727: PUSH
55728: LD_INT 75
55730: PUSH
55731: EMPTY
55732: LIST
55733: LIST
55734: LIST
55735: ST_TO_ADDR
// if GetClass ( i ) = 15 then
55736: LD_VAR 0 6
55740: PPUSH
55741: CALL_OW 257
55745: PUSH
55746: LD_INT 15
55748: EQUAL
55749: IFFALSE 55770
// points := [ 10 , 5 , 3 ] ;
55751: LD_ADDR_VAR 0 9
55755: PUSH
55756: LD_INT 10
55758: PUSH
55759: LD_INT 5
55761: PUSH
55762: LD_INT 3
55764: PUSH
55765: EMPTY
55766: LIST
55767: LIST
55768: LIST
55769: ST_TO_ADDR
// if GetClass ( i ) = 14 then
55770: LD_VAR 0 6
55774: PPUSH
55775: CALL_OW 257
55779: PUSH
55780: LD_INT 14
55782: EQUAL
55783: IFFALSE 55804
// points := [ 10 , 0 , 0 ] ;
55785: LD_ADDR_VAR 0 9
55789: PUSH
55790: LD_INT 10
55792: PUSH
55793: LD_INT 0
55795: PUSH
55796: LD_INT 0
55798: PUSH
55799: EMPTY
55800: LIST
55801: LIST
55802: LIST
55803: ST_TO_ADDR
// if GetClass ( i ) = 11 then
55804: LD_VAR 0 6
55808: PPUSH
55809: CALL_OW 257
55813: PUSH
55814: LD_INT 11
55816: EQUAL
55817: IFFALSE 55838
// points := [ 30 , 10 , 5 ] ;
55819: LD_ADDR_VAR 0 9
55823: PUSH
55824: LD_INT 30
55826: PUSH
55827: LD_INT 10
55829: PUSH
55830: LD_INT 5
55832: PUSH
55833: EMPTY
55834: LIST
55835: LIST
55836: LIST
55837: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
55838: LD_VAR 0 1
55842: PPUSH
55843: LD_INT 5
55845: PPUSH
55846: CALL_OW 321
55850: PUSH
55851: LD_INT 2
55853: EQUAL
55854: IFFALSE 55871
// bpoints := bpoints * 1.8 ;
55856: LD_ADDR_VAR 0 10
55860: PUSH
55861: LD_VAR 0 10
55865: PUSH
55866: LD_REAL  1.80000000000000E+0000
55869: MUL
55870: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
55871: LD_VAR 0 6
55875: PPUSH
55876: CALL_OW 257
55880: PUSH
55881: LD_INT 1
55883: PUSH
55884: LD_INT 2
55886: PUSH
55887: LD_INT 3
55889: PUSH
55890: LD_INT 4
55892: PUSH
55893: EMPTY
55894: LIST
55895: LIST
55896: LIST
55897: LIST
55898: IN
55899: PUSH
55900: LD_VAR 0 1
55904: PPUSH
55905: LD_INT 51
55907: PPUSH
55908: CALL_OW 321
55912: PUSH
55913: LD_INT 2
55915: EQUAL
55916: AND
55917: IFFALSE 55934
// bpoints := bpoints * 1.2 ;
55919: LD_ADDR_VAR 0 10
55923: PUSH
55924: LD_VAR 0 10
55928: PUSH
55929: LD_REAL  1.20000000000000E+0000
55932: MUL
55933: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
55934: LD_VAR 0 6
55938: PPUSH
55939: CALL_OW 257
55943: PUSH
55944: LD_INT 5
55946: PUSH
55947: LD_INT 7
55949: PUSH
55950: LD_INT 9
55952: PUSH
55953: EMPTY
55954: LIST
55955: LIST
55956: LIST
55957: IN
55958: PUSH
55959: LD_VAR 0 1
55963: PPUSH
55964: LD_INT 52
55966: PPUSH
55967: CALL_OW 321
55971: PUSH
55972: LD_INT 2
55974: EQUAL
55975: AND
55976: IFFALSE 55993
// bpoints := bpoints * 1.5 ;
55978: LD_ADDR_VAR 0 10
55982: PUSH
55983: LD_VAR 0 10
55987: PUSH
55988: LD_REAL  1.50000000000000E+0000
55991: MUL
55992: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
55993: LD_VAR 0 1
55997: PPUSH
55998: LD_INT 66
56000: PPUSH
56001: CALL_OW 321
56005: PUSH
56006: LD_INT 2
56008: EQUAL
56009: IFFALSE 56026
// bpoints := bpoints * 1.1 ;
56011: LD_ADDR_VAR 0 10
56015: PUSH
56016: LD_VAR 0 10
56020: PUSH
56021: LD_REAL  1.10000000000000E+0000
56024: MUL
56025: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
56026: LD_ADDR_VAR 0 10
56030: PUSH
56031: LD_VAR 0 10
56035: PUSH
56036: LD_VAR 0 6
56040: PPUSH
56041: LD_INT 1
56043: PPUSH
56044: CALL_OW 259
56048: PUSH
56049: LD_REAL  1.15000000000000E+0000
56052: MUL
56053: MUL
56054: ST_TO_ADDR
// end ; unit_vehicle :
56055: GO 56879
56057: LD_INT 2
56059: DOUBLE
56060: EQUAL
56061: IFTRUE 56065
56063: GO 56867
56065: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
56066: LD_VAR 0 6
56070: PPUSH
56071: CALL_OW 264
56075: PUSH
56076: LD_INT 2
56078: PUSH
56079: LD_INT 42
56081: PUSH
56082: LD_INT 24
56084: PUSH
56085: EMPTY
56086: LIST
56087: LIST
56088: LIST
56089: IN
56090: IFFALSE 56111
// points := [ 25 , 5 , 3 ] ;
56092: LD_ADDR_VAR 0 9
56096: PUSH
56097: LD_INT 25
56099: PUSH
56100: LD_INT 5
56102: PUSH
56103: LD_INT 3
56105: PUSH
56106: EMPTY
56107: LIST
56108: LIST
56109: LIST
56110: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
56111: LD_VAR 0 6
56115: PPUSH
56116: CALL_OW 264
56120: PUSH
56121: LD_INT 4
56123: PUSH
56124: LD_INT 43
56126: PUSH
56127: LD_INT 25
56129: PUSH
56130: EMPTY
56131: LIST
56132: LIST
56133: LIST
56134: IN
56135: IFFALSE 56156
// points := [ 40 , 15 , 5 ] ;
56137: LD_ADDR_VAR 0 9
56141: PUSH
56142: LD_INT 40
56144: PUSH
56145: LD_INT 15
56147: PUSH
56148: LD_INT 5
56150: PUSH
56151: EMPTY
56152: LIST
56153: LIST
56154: LIST
56155: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
56156: LD_VAR 0 6
56160: PPUSH
56161: CALL_OW 264
56165: PUSH
56166: LD_INT 3
56168: PUSH
56169: LD_INT 23
56171: PUSH
56172: EMPTY
56173: LIST
56174: LIST
56175: IN
56176: IFFALSE 56197
// points := [ 7 , 25 , 8 ] ;
56178: LD_ADDR_VAR 0 9
56182: PUSH
56183: LD_INT 7
56185: PUSH
56186: LD_INT 25
56188: PUSH
56189: LD_INT 8
56191: PUSH
56192: EMPTY
56193: LIST
56194: LIST
56195: LIST
56196: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
56197: LD_VAR 0 6
56201: PPUSH
56202: CALL_OW 264
56206: PUSH
56207: LD_INT 5
56209: PUSH
56210: LD_INT 27
56212: PUSH
56213: LD_INT 44
56215: PUSH
56216: EMPTY
56217: LIST
56218: LIST
56219: LIST
56220: IN
56221: IFFALSE 56242
// points := [ 14 , 50 , 16 ] ;
56223: LD_ADDR_VAR 0 9
56227: PUSH
56228: LD_INT 14
56230: PUSH
56231: LD_INT 50
56233: PUSH
56234: LD_INT 16
56236: PUSH
56237: EMPTY
56238: LIST
56239: LIST
56240: LIST
56241: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
56242: LD_VAR 0 6
56246: PPUSH
56247: CALL_OW 264
56251: PUSH
56252: LD_INT 6
56254: PUSH
56255: LD_INT 46
56257: PUSH
56258: EMPTY
56259: LIST
56260: LIST
56261: IN
56262: IFFALSE 56283
// points := [ 32 , 120 , 70 ] ;
56264: LD_ADDR_VAR 0 9
56268: PUSH
56269: LD_INT 32
56271: PUSH
56272: LD_INT 120
56274: PUSH
56275: LD_INT 70
56277: PUSH
56278: EMPTY
56279: LIST
56280: LIST
56281: LIST
56282: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
56283: LD_VAR 0 6
56287: PPUSH
56288: CALL_OW 264
56292: PUSH
56293: LD_INT 7
56295: PUSH
56296: LD_INT 28
56298: PUSH
56299: LD_INT 45
56301: PUSH
56302: EMPTY
56303: LIST
56304: LIST
56305: LIST
56306: IN
56307: IFFALSE 56328
// points := [ 35 , 20 , 45 ] ;
56309: LD_ADDR_VAR 0 9
56313: PUSH
56314: LD_INT 35
56316: PUSH
56317: LD_INT 20
56319: PUSH
56320: LD_INT 45
56322: PUSH
56323: EMPTY
56324: LIST
56325: LIST
56326: LIST
56327: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
56328: LD_VAR 0 6
56332: PPUSH
56333: CALL_OW 264
56337: PUSH
56338: LD_INT 47
56340: PUSH
56341: EMPTY
56342: LIST
56343: IN
56344: IFFALSE 56365
// points := [ 67 , 45 , 75 ] ;
56346: LD_ADDR_VAR 0 9
56350: PUSH
56351: LD_INT 67
56353: PUSH
56354: LD_INT 45
56356: PUSH
56357: LD_INT 75
56359: PUSH
56360: EMPTY
56361: LIST
56362: LIST
56363: LIST
56364: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
56365: LD_VAR 0 6
56369: PPUSH
56370: CALL_OW 264
56374: PUSH
56375: LD_INT 26
56377: PUSH
56378: EMPTY
56379: LIST
56380: IN
56381: IFFALSE 56402
// points := [ 120 , 30 , 80 ] ;
56383: LD_ADDR_VAR 0 9
56387: PUSH
56388: LD_INT 120
56390: PUSH
56391: LD_INT 30
56393: PUSH
56394: LD_INT 80
56396: PUSH
56397: EMPTY
56398: LIST
56399: LIST
56400: LIST
56401: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
56402: LD_VAR 0 6
56406: PPUSH
56407: CALL_OW 264
56411: PUSH
56412: LD_INT 22
56414: PUSH
56415: EMPTY
56416: LIST
56417: IN
56418: IFFALSE 56439
// points := [ 40 , 1 , 1 ] ;
56420: LD_ADDR_VAR 0 9
56424: PUSH
56425: LD_INT 40
56427: PUSH
56428: LD_INT 1
56430: PUSH
56431: LD_INT 1
56433: PUSH
56434: EMPTY
56435: LIST
56436: LIST
56437: LIST
56438: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
56439: LD_VAR 0 6
56443: PPUSH
56444: CALL_OW 264
56448: PUSH
56449: LD_INT 29
56451: PUSH
56452: EMPTY
56453: LIST
56454: IN
56455: IFFALSE 56476
// points := [ 70 , 200 , 400 ] ;
56457: LD_ADDR_VAR 0 9
56461: PUSH
56462: LD_INT 70
56464: PUSH
56465: LD_INT 200
56467: PUSH
56468: LD_INT 400
56470: PUSH
56471: EMPTY
56472: LIST
56473: LIST
56474: LIST
56475: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
56476: LD_VAR 0 6
56480: PPUSH
56481: CALL_OW 264
56485: PUSH
56486: LD_INT 14
56488: PUSH
56489: LD_INT 53
56491: PUSH
56492: EMPTY
56493: LIST
56494: LIST
56495: IN
56496: IFFALSE 56517
// points := [ 40 , 10 , 20 ] ;
56498: LD_ADDR_VAR 0 9
56502: PUSH
56503: LD_INT 40
56505: PUSH
56506: LD_INT 10
56508: PUSH
56509: LD_INT 20
56511: PUSH
56512: EMPTY
56513: LIST
56514: LIST
56515: LIST
56516: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
56517: LD_VAR 0 6
56521: PPUSH
56522: CALL_OW 264
56526: PUSH
56527: LD_INT 9
56529: PUSH
56530: EMPTY
56531: LIST
56532: IN
56533: IFFALSE 56554
// points := [ 5 , 70 , 20 ] ;
56535: LD_ADDR_VAR 0 9
56539: PUSH
56540: LD_INT 5
56542: PUSH
56543: LD_INT 70
56545: PUSH
56546: LD_INT 20
56548: PUSH
56549: EMPTY
56550: LIST
56551: LIST
56552: LIST
56553: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
56554: LD_VAR 0 6
56558: PPUSH
56559: CALL_OW 264
56563: PUSH
56564: LD_INT 10
56566: PUSH
56567: EMPTY
56568: LIST
56569: IN
56570: IFFALSE 56591
// points := [ 35 , 110 , 70 ] ;
56572: LD_ADDR_VAR 0 9
56576: PUSH
56577: LD_INT 35
56579: PUSH
56580: LD_INT 110
56582: PUSH
56583: LD_INT 70
56585: PUSH
56586: EMPTY
56587: LIST
56588: LIST
56589: LIST
56590: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
56591: LD_VAR 0 6
56595: PPUSH
56596: CALL_OW 265
56600: PUSH
56601: LD_INT 25
56603: EQUAL
56604: IFFALSE 56625
// points := [ 80 , 65 , 100 ] ;
56606: LD_ADDR_VAR 0 9
56610: PUSH
56611: LD_INT 80
56613: PUSH
56614: LD_INT 65
56616: PUSH
56617: LD_INT 100
56619: PUSH
56620: EMPTY
56621: LIST
56622: LIST
56623: LIST
56624: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
56625: LD_VAR 0 6
56629: PPUSH
56630: CALL_OW 263
56634: PUSH
56635: LD_INT 1
56637: EQUAL
56638: IFFALSE 56673
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
56640: LD_ADDR_VAR 0 10
56644: PUSH
56645: LD_VAR 0 10
56649: PUSH
56650: LD_VAR 0 6
56654: PPUSH
56655: CALL_OW 311
56659: PPUSH
56660: LD_INT 3
56662: PPUSH
56663: CALL_OW 259
56667: PUSH
56668: LD_INT 4
56670: MUL
56671: MUL
56672: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
56673: LD_VAR 0 6
56677: PPUSH
56678: CALL_OW 263
56682: PUSH
56683: LD_INT 2
56685: EQUAL
56686: IFFALSE 56737
// begin j := IsControledBy ( i ) ;
56688: LD_ADDR_VAR 0 7
56692: PUSH
56693: LD_VAR 0 6
56697: PPUSH
56698: CALL_OW 312
56702: ST_TO_ADDR
// if j then
56703: LD_VAR 0 7
56707: IFFALSE 56737
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
56709: LD_ADDR_VAR 0 10
56713: PUSH
56714: LD_VAR 0 10
56718: PUSH
56719: LD_VAR 0 7
56723: PPUSH
56724: LD_INT 3
56726: PPUSH
56727: CALL_OW 259
56731: PUSH
56732: LD_INT 3
56734: MUL
56735: MUL
56736: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
56737: LD_VAR 0 6
56741: PPUSH
56742: CALL_OW 264
56746: PUSH
56747: LD_INT 5
56749: PUSH
56750: LD_INT 6
56752: PUSH
56753: LD_INT 46
56755: PUSH
56756: LD_INT 44
56758: PUSH
56759: LD_INT 47
56761: PUSH
56762: LD_INT 45
56764: PUSH
56765: LD_INT 28
56767: PUSH
56768: LD_INT 7
56770: PUSH
56771: LD_INT 27
56773: PUSH
56774: LD_INT 29
56776: PUSH
56777: EMPTY
56778: LIST
56779: LIST
56780: LIST
56781: LIST
56782: LIST
56783: LIST
56784: LIST
56785: LIST
56786: LIST
56787: LIST
56788: IN
56789: PUSH
56790: LD_VAR 0 1
56794: PPUSH
56795: LD_INT 52
56797: PPUSH
56798: CALL_OW 321
56802: PUSH
56803: LD_INT 2
56805: EQUAL
56806: AND
56807: IFFALSE 56824
// bpoints := bpoints * 1.2 ;
56809: LD_ADDR_VAR 0 10
56813: PUSH
56814: LD_VAR 0 10
56818: PUSH
56819: LD_REAL  1.20000000000000E+0000
56822: MUL
56823: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
56824: LD_VAR 0 6
56828: PPUSH
56829: CALL_OW 264
56833: PUSH
56834: LD_INT 6
56836: PUSH
56837: LD_INT 46
56839: PUSH
56840: LD_INT 47
56842: PUSH
56843: EMPTY
56844: LIST
56845: LIST
56846: LIST
56847: IN
56848: IFFALSE 56865
// bpoints := bpoints * 1.2 ;
56850: LD_ADDR_VAR 0 10
56854: PUSH
56855: LD_VAR 0 10
56859: PUSH
56860: LD_REAL  1.20000000000000E+0000
56863: MUL
56864: ST_TO_ADDR
// end ; unit_building :
56865: GO 56879
56867: LD_INT 3
56869: DOUBLE
56870: EQUAL
56871: IFTRUE 56875
56873: GO 56878
56875: POP
// ; end ;
56876: GO 56879
56878: POP
// for j = 1 to 3 do
56879: LD_ADDR_VAR 0 7
56883: PUSH
56884: DOUBLE
56885: LD_INT 1
56887: DEC
56888: ST_TO_ADDR
56889: LD_INT 3
56891: PUSH
56892: FOR_TO
56893: IFFALSE 56946
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
56895: LD_ADDR_VAR 0 5
56899: PUSH
56900: LD_VAR 0 5
56904: PPUSH
56905: LD_VAR 0 7
56909: PPUSH
56910: LD_VAR 0 5
56914: PUSH
56915: LD_VAR 0 7
56919: ARRAY
56920: PUSH
56921: LD_VAR 0 9
56925: PUSH
56926: LD_VAR 0 7
56930: ARRAY
56931: PUSH
56932: LD_VAR 0 10
56936: MUL
56937: PLUS
56938: PPUSH
56939: CALL_OW 1
56943: ST_TO_ADDR
56944: GO 56892
56946: POP
56947: POP
// end ;
56948: GO 55431
56950: POP
56951: POP
// result := Replace ( result , 4 , tmp ) ;
56952: LD_ADDR_VAR 0 5
56956: PUSH
56957: LD_VAR 0 5
56961: PPUSH
56962: LD_INT 4
56964: PPUSH
56965: LD_VAR 0 8
56969: PPUSH
56970: CALL_OW 1
56974: ST_TO_ADDR
// end ;
56975: LD_VAR 0 5
56979: RET
// export function DangerAtRange ( unit , range ) ; begin
56980: LD_INT 0
56982: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
56983: LD_ADDR_VAR 0 3
56987: PUSH
56988: LD_VAR 0 1
56992: PPUSH
56993: CALL_OW 255
56997: PPUSH
56998: LD_VAR 0 1
57002: PPUSH
57003: CALL_OW 250
57007: PPUSH
57008: LD_VAR 0 1
57012: PPUSH
57013: CALL_OW 251
57017: PPUSH
57018: LD_VAR 0 2
57022: PPUSH
57023: CALL 55283 0 4
57027: ST_TO_ADDR
// end ;
57028: LD_VAR 0 3
57032: RET
// export function DangerInArea ( side , area ) ; begin
57033: LD_INT 0
57035: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
57036: LD_ADDR_VAR 0 3
57040: PUSH
57041: LD_VAR 0 2
57045: PPUSH
57046: LD_INT 81
57048: PUSH
57049: LD_VAR 0 1
57053: PUSH
57054: EMPTY
57055: LIST
57056: LIST
57057: PPUSH
57058: CALL_OW 70
57062: ST_TO_ADDR
// end ;
57063: LD_VAR 0 3
57067: RET
// export function IsExtension ( b ) ; begin
57068: LD_INT 0
57070: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
57071: LD_ADDR_VAR 0 2
57075: PUSH
57076: LD_VAR 0 1
57080: PUSH
57081: LD_INT 23
57083: PUSH
57084: LD_INT 20
57086: PUSH
57087: LD_INT 22
57089: PUSH
57090: LD_INT 17
57092: PUSH
57093: LD_INT 24
57095: PUSH
57096: LD_INT 21
57098: PUSH
57099: LD_INT 19
57101: PUSH
57102: LD_INT 16
57104: PUSH
57105: LD_INT 25
57107: PUSH
57108: LD_INT 18
57110: PUSH
57111: EMPTY
57112: LIST
57113: LIST
57114: LIST
57115: LIST
57116: LIST
57117: LIST
57118: LIST
57119: LIST
57120: LIST
57121: LIST
57122: IN
57123: ST_TO_ADDR
// end ;
57124: LD_VAR 0 2
57128: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
57129: LD_INT 0
57131: PPUSH
57132: PPUSH
57133: PPUSH
// result := [ ] ;
57134: LD_ADDR_VAR 0 3
57138: PUSH
57139: EMPTY
57140: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
57141: LD_ADDR_VAR 0 4
57145: PUSH
57146: LD_VAR 0 2
57150: PPUSH
57151: LD_INT 21
57153: PUSH
57154: LD_INT 3
57156: PUSH
57157: EMPTY
57158: LIST
57159: LIST
57160: PPUSH
57161: CALL_OW 70
57165: ST_TO_ADDR
// if not tmp then
57166: LD_VAR 0 4
57170: NOT
57171: IFFALSE 57175
// exit ;
57173: GO 57233
// for i in tmp do
57175: LD_ADDR_VAR 0 5
57179: PUSH
57180: LD_VAR 0 4
57184: PUSH
57185: FOR_IN
57186: IFFALSE 57221
// if GetBase ( i ) <> base then
57188: LD_VAR 0 5
57192: PPUSH
57193: CALL_OW 274
57197: PUSH
57198: LD_VAR 0 1
57202: NONEQUAL
57203: IFFALSE 57219
// ComLinkToBase ( base , i ) ;
57205: LD_VAR 0 1
57209: PPUSH
57210: LD_VAR 0 5
57214: PPUSH
57215: CALL_OW 169
57219: GO 57185
57221: POP
57222: POP
// result := tmp ;
57223: LD_ADDR_VAR 0 3
57227: PUSH
57228: LD_VAR 0 4
57232: ST_TO_ADDR
// end ;
57233: LD_VAR 0 3
57237: RET
// export function ComComplete ( unit , b ) ; var i ; begin
57238: LD_INT 0
57240: PPUSH
57241: PPUSH
// if BuildingStatus ( b ) = bs_build then
57242: LD_VAR 0 2
57246: PPUSH
57247: CALL_OW 461
57251: PUSH
57252: LD_INT 1
57254: EQUAL
57255: IFFALSE 57315
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
57257: LD_VAR 0 1
57261: PPUSH
57262: LD_STRING h
57264: PUSH
57265: LD_VAR 0 2
57269: PPUSH
57270: CALL_OW 250
57274: PUSH
57275: LD_VAR 0 2
57279: PPUSH
57280: CALL_OW 251
57284: PUSH
57285: LD_VAR 0 2
57289: PUSH
57290: LD_INT 0
57292: PUSH
57293: LD_INT 0
57295: PUSH
57296: LD_INT 0
57298: PUSH
57299: EMPTY
57300: LIST
57301: LIST
57302: LIST
57303: LIST
57304: LIST
57305: LIST
57306: LIST
57307: PUSH
57308: EMPTY
57309: LIST
57310: PPUSH
57311: CALL_OW 446
// end ;
57315: LD_VAR 0 3
57319: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
57320: LD_INT 0
57322: PPUSH
57323: PPUSH
57324: PPUSH
57325: PPUSH
57326: PPUSH
57327: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
57328: LD_VAR 0 1
57332: NOT
57333: PUSH
57334: LD_VAR 0 1
57338: PPUSH
57339: CALL_OW 263
57343: PUSH
57344: LD_INT 2
57346: EQUAL
57347: NOT
57348: OR
57349: IFFALSE 57353
// exit ;
57351: GO 57669
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
57353: LD_ADDR_VAR 0 6
57357: PUSH
57358: LD_INT 22
57360: PUSH
57361: LD_VAR 0 1
57365: PPUSH
57366: CALL_OW 255
57370: PUSH
57371: EMPTY
57372: LIST
57373: LIST
57374: PUSH
57375: LD_INT 2
57377: PUSH
57378: LD_INT 30
57380: PUSH
57381: LD_INT 36
57383: PUSH
57384: EMPTY
57385: LIST
57386: LIST
57387: PUSH
57388: LD_INT 34
57390: PUSH
57391: LD_INT 31
57393: PUSH
57394: EMPTY
57395: LIST
57396: LIST
57397: PUSH
57398: EMPTY
57399: LIST
57400: LIST
57401: LIST
57402: PUSH
57403: EMPTY
57404: LIST
57405: LIST
57406: PPUSH
57407: CALL_OW 69
57411: ST_TO_ADDR
// if not tmp then
57412: LD_VAR 0 6
57416: NOT
57417: IFFALSE 57421
// exit ;
57419: GO 57669
// result := [ ] ;
57421: LD_ADDR_VAR 0 2
57425: PUSH
57426: EMPTY
57427: ST_TO_ADDR
// for i in tmp do
57428: LD_ADDR_VAR 0 3
57432: PUSH
57433: LD_VAR 0 6
57437: PUSH
57438: FOR_IN
57439: IFFALSE 57510
// begin t := UnitsInside ( i ) ;
57441: LD_ADDR_VAR 0 4
57445: PUSH
57446: LD_VAR 0 3
57450: PPUSH
57451: CALL_OW 313
57455: ST_TO_ADDR
// if t then
57456: LD_VAR 0 4
57460: IFFALSE 57508
// for j in t do
57462: LD_ADDR_VAR 0 7
57466: PUSH
57467: LD_VAR 0 4
57471: PUSH
57472: FOR_IN
57473: IFFALSE 57506
// result := Insert ( result , result + 1 , j ) ;
57475: LD_ADDR_VAR 0 2
57479: PUSH
57480: LD_VAR 0 2
57484: PPUSH
57485: LD_VAR 0 2
57489: PUSH
57490: LD_INT 1
57492: PLUS
57493: PPUSH
57494: LD_VAR 0 7
57498: PPUSH
57499: CALL_OW 2
57503: ST_TO_ADDR
57504: GO 57472
57506: POP
57507: POP
// end ;
57508: GO 57438
57510: POP
57511: POP
// if not result then
57512: LD_VAR 0 2
57516: NOT
57517: IFFALSE 57521
// exit ;
57519: GO 57669
// mech := result [ 1 ] ;
57521: LD_ADDR_VAR 0 5
57525: PUSH
57526: LD_VAR 0 2
57530: PUSH
57531: LD_INT 1
57533: ARRAY
57534: ST_TO_ADDR
// if result > 1 then
57535: LD_VAR 0 2
57539: PUSH
57540: LD_INT 1
57542: GREATER
57543: IFFALSE 57655
// for i = 2 to result do
57545: LD_ADDR_VAR 0 3
57549: PUSH
57550: DOUBLE
57551: LD_INT 2
57553: DEC
57554: ST_TO_ADDR
57555: LD_VAR 0 2
57559: PUSH
57560: FOR_TO
57561: IFFALSE 57653
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
57563: LD_ADDR_VAR 0 4
57567: PUSH
57568: LD_VAR 0 2
57572: PUSH
57573: LD_VAR 0 3
57577: ARRAY
57578: PPUSH
57579: LD_INT 3
57581: PPUSH
57582: CALL_OW 259
57586: PUSH
57587: LD_VAR 0 2
57591: PUSH
57592: LD_VAR 0 3
57596: ARRAY
57597: PPUSH
57598: CALL_OW 432
57602: MINUS
57603: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
57604: LD_VAR 0 4
57608: PUSH
57609: LD_VAR 0 5
57613: PPUSH
57614: LD_INT 3
57616: PPUSH
57617: CALL_OW 259
57621: PUSH
57622: LD_VAR 0 5
57626: PPUSH
57627: CALL_OW 432
57631: MINUS
57632: GREATEREQUAL
57633: IFFALSE 57651
// mech := result [ i ] ;
57635: LD_ADDR_VAR 0 5
57639: PUSH
57640: LD_VAR 0 2
57644: PUSH
57645: LD_VAR 0 3
57649: ARRAY
57650: ST_TO_ADDR
// end ;
57651: GO 57560
57653: POP
57654: POP
// ComLinkTo ( vehicle , mech ) ;
57655: LD_VAR 0 1
57659: PPUSH
57660: LD_VAR 0 5
57664: PPUSH
57665: CALL_OW 135
// end ;
57669: LD_VAR 0 2
57673: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
57674: LD_INT 0
57676: PPUSH
57677: PPUSH
57678: PPUSH
57679: PPUSH
57680: PPUSH
57681: PPUSH
57682: PPUSH
57683: PPUSH
57684: PPUSH
57685: PPUSH
57686: PPUSH
57687: PPUSH
57688: PPUSH
// result := [ ] ;
57689: LD_ADDR_VAR 0 7
57693: PUSH
57694: EMPTY
57695: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
57696: LD_VAR 0 1
57700: PPUSH
57701: CALL_OW 266
57705: PUSH
57706: LD_INT 0
57708: PUSH
57709: LD_INT 1
57711: PUSH
57712: EMPTY
57713: LIST
57714: LIST
57715: IN
57716: NOT
57717: IFFALSE 57721
// exit ;
57719: GO 59352
// if name then
57721: LD_VAR 0 3
57725: IFFALSE 57741
// SetBName ( base_dep , name ) ;
57727: LD_VAR 0 1
57731: PPUSH
57732: LD_VAR 0 3
57736: PPUSH
57737: CALL_OW 500
// base := GetBase ( base_dep ) ;
57741: LD_ADDR_VAR 0 15
57745: PUSH
57746: LD_VAR 0 1
57750: PPUSH
57751: CALL_OW 274
57755: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
57756: LD_ADDR_VAR 0 16
57760: PUSH
57761: LD_VAR 0 1
57765: PPUSH
57766: CALL_OW 255
57770: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
57771: LD_ADDR_VAR 0 17
57775: PUSH
57776: LD_VAR 0 1
57780: PPUSH
57781: CALL_OW 248
57785: ST_TO_ADDR
// if sources then
57786: LD_VAR 0 5
57790: IFFALSE 57837
// for i = 1 to 3 do
57792: LD_ADDR_VAR 0 8
57796: PUSH
57797: DOUBLE
57798: LD_INT 1
57800: DEC
57801: ST_TO_ADDR
57802: LD_INT 3
57804: PUSH
57805: FOR_TO
57806: IFFALSE 57835
// AddResourceType ( base , i , sources [ i ] ) ;
57808: LD_VAR 0 15
57812: PPUSH
57813: LD_VAR 0 8
57817: PPUSH
57818: LD_VAR 0 5
57822: PUSH
57823: LD_VAR 0 8
57827: ARRAY
57828: PPUSH
57829: CALL_OW 276
57833: GO 57805
57835: POP
57836: POP
// buildings := GetBaseBuildings ( base , area ) ;
57837: LD_ADDR_VAR 0 18
57841: PUSH
57842: LD_VAR 0 15
57846: PPUSH
57847: LD_VAR 0 2
57851: PPUSH
57852: CALL 57129 0 2
57856: ST_TO_ADDR
// InitHc ;
57857: CALL_OW 19
// InitUc ;
57861: CALL_OW 18
// uc_side := side ;
57865: LD_ADDR_OWVAR 20
57869: PUSH
57870: LD_VAR 0 16
57874: ST_TO_ADDR
// uc_nation := nation ;
57875: LD_ADDR_OWVAR 21
57879: PUSH
57880: LD_VAR 0 17
57884: ST_TO_ADDR
// if buildings then
57885: LD_VAR 0 18
57889: IFFALSE 59211
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
57891: LD_ADDR_VAR 0 19
57895: PUSH
57896: LD_VAR 0 18
57900: PPUSH
57901: LD_INT 2
57903: PUSH
57904: LD_INT 30
57906: PUSH
57907: LD_INT 29
57909: PUSH
57910: EMPTY
57911: LIST
57912: LIST
57913: PUSH
57914: LD_INT 30
57916: PUSH
57917: LD_INT 30
57919: PUSH
57920: EMPTY
57921: LIST
57922: LIST
57923: PUSH
57924: EMPTY
57925: LIST
57926: LIST
57927: LIST
57928: PPUSH
57929: CALL_OW 72
57933: ST_TO_ADDR
// if tmp then
57934: LD_VAR 0 19
57938: IFFALSE 57986
// for i in tmp do
57940: LD_ADDR_VAR 0 8
57944: PUSH
57945: LD_VAR 0 19
57949: PUSH
57950: FOR_IN
57951: IFFALSE 57984
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
57953: LD_VAR 0 8
57957: PPUSH
57958: CALL_OW 250
57962: PPUSH
57963: LD_VAR 0 8
57967: PPUSH
57968: CALL_OW 251
57972: PPUSH
57973: LD_VAR 0 16
57977: PPUSH
57978: CALL_OW 441
57982: GO 57950
57984: POP
57985: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
57986: LD_VAR 0 18
57990: PPUSH
57991: LD_INT 2
57993: PUSH
57994: LD_INT 30
57996: PUSH
57997: LD_INT 32
57999: PUSH
58000: EMPTY
58001: LIST
58002: LIST
58003: PUSH
58004: LD_INT 30
58006: PUSH
58007: LD_INT 33
58009: PUSH
58010: EMPTY
58011: LIST
58012: LIST
58013: PUSH
58014: EMPTY
58015: LIST
58016: LIST
58017: LIST
58018: PPUSH
58019: CALL_OW 72
58023: IFFALSE 58111
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
58025: LD_ADDR_VAR 0 8
58029: PUSH
58030: LD_VAR 0 18
58034: PPUSH
58035: LD_INT 2
58037: PUSH
58038: LD_INT 30
58040: PUSH
58041: LD_INT 32
58043: PUSH
58044: EMPTY
58045: LIST
58046: LIST
58047: PUSH
58048: LD_INT 30
58050: PUSH
58051: LD_INT 33
58053: PUSH
58054: EMPTY
58055: LIST
58056: LIST
58057: PUSH
58058: EMPTY
58059: LIST
58060: LIST
58061: LIST
58062: PPUSH
58063: CALL_OW 72
58067: PUSH
58068: FOR_IN
58069: IFFALSE 58109
// begin if not GetBWeapon ( i ) then
58071: LD_VAR 0 8
58075: PPUSH
58076: CALL_OW 269
58080: NOT
58081: IFFALSE 58107
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
58083: LD_VAR 0 8
58087: PPUSH
58088: LD_VAR 0 8
58092: PPUSH
58093: LD_VAR 0 2
58097: PPUSH
58098: CALL 59357 0 2
58102: PPUSH
58103: CALL_OW 431
// end ;
58107: GO 58068
58109: POP
58110: POP
// end ; for i = 1 to personel do
58111: LD_ADDR_VAR 0 8
58115: PUSH
58116: DOUBLE
58117: LD_INT 1
58119: DEC
58120: ST_TO_ADDR
58121: LD_VAR 0 6
58125: PUSH
58126: FOR_TO
58127: IFFALSE 59191
// begin if i > 4 then
58129: LD_VAR 0 8
58133: PUSH
58134: LD_INT 4
58136: GREATER
58137: IFFALSE 58141
// break ;
58139: GO 59191
// case i of 1 :
58141: LD_VAR 0 8
58145: PUSH
58146: LD_INT 1
58148: DOUBLE
58149: EQUAL
58150: IFTRUE 58154
58152: GO 58234
58154: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
58155: LD_ADDR_VAR 0 12
58159: PUSH
58160: LD_VAR 0 18
58164: PPUSH
58165: LD_INT 22
58167: PUSH
58168: LD_VAR 0 16
58172: PUSH
58173: EMPTY
58174: LIST
58175: LIST
58176: PUSH
58177: LD_INT 58
58179: PUSH
58180: EMPTY
58181: LIST
58182: PUSH
58183: LD_INT 2
58185: PUSH
58186: LD_INT 30
58188: PUSH
58189: LD_INT 32
58191: PUSH
58192: EMPTY
58193: LIST
58194: LIST
58195: PUSH
58196: LD_INT 30
58198: PUSH
58199: LD_INT 4
58201: PUSH
58202: EMPTY
58203: LIST
58204: LIST
58205: PUSH
58206: LD_INT 30
58208: PUSH
58209: LD_INT 5
58211: PUSH
58212: EMPTY
58213: LIST
58214: LIST
58215: PUSH
58216: EMPTY
58217: LIST
58218: LIST
58219: LIST
58220: LIST
58221: PUSH
58222: EMPTY
58223: LIST
58224: LIST
58225: LIST
58226: PPUSH
58227: CALL_OW 72
58231: ST_TO_ADDR
58232: GO 58456
58234: LD_INT 2
58236: DOUBLE
58237: EQUAL
58238: IFTRUE 58242
58240: GO 58304
58242: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
58243: LD_ADDR_VAR 0 12
58247: PUSH
58248: LD_VAR 0 18
58252: PPUSH
58253: LD_INT 22
58255: PUSH
58256: LD_VAR 0 16
58260: PUSH
58261: EMPTY
58262: LIST
58263: LIST
58264: PUSH
58265: LD_INT 2
58267: PUSH
58268: LD_INT 30
58270: PUSH
58271: LD_INT 0
58273: PUSH
58274: EMPTY
58275: LIST
58276: LIST
58277: PUSH
58278: LD_INT 30
58280: PUSH
58281: LD_INT 1
58283: PUSH
58284: EMPTY
58285: LIST
58286: LIST
58287: PUSH
58288: EMPTY
58289: LIST
58290: LIST
58291: LIST
58292: PUSH
58293: EMPTY
58294: LIST
58295: LIST
58296: PPUSH
58297: CALL_OW 72
58301: ST_TO_ADDR
58302: GO 58456
58304: LD_INT 3
58306: DOUBLE
58307: EQUAL
58308: IFTRUE 58312
58310: GO 58374
58312: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
58313: LD_ADDR_VAR 0 12
58317: PUSH
58318: LD_VAR 0 18
58322: PPUSH
58323: LD_INT 22
58325: PUSH
58326: LD_VAR 0 16
58330: PUSH
58331: EMPTY
58332: LIST
58333: LIST
58334: PUSH
58335: LD_INT 2
58337: PUSH
58338: LD_INT 30
58340: PUSH
58341: LD_INT 2
58343: PUSH
58344: EMPTY
58345: LIST
58346: LIST
58347: PUSH
58348: LD_INT 30
58350: PUSH
58351: LD_INT 3
58353: PUSH
58354: EMPTY
58355: LIST
58356: LIST
58357: PUSH
58358: EMPTY
58359: LIST
58360: LIST
58361: LIST
58362: PUSH
58363: EMPTY
58364: LIST
58365: LIST
58366: PPUSH
58367: CALL_OW 72
58371: ST_TO_ADDR
58372: GO 58456
58374: LD_INT 4
58376: DOUBLE
58377: EQUAL
58378: IFTRUE 58382
58380: GO 58455
58382: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
58383: LD_ADDR_VAR 0 12
58387: PUSH
58388: LD_VAR 0 18
58392: PPUSH
58393: LD_INT 22
58395: PUSH
58396: LD_VAR 0 16
58400: PUSH
58401: EMPTY
58402: LIST
58403: LIST
58404: PUSH
58405: LD_INT 2
58407: PUSH
58408: LD_INT 30
58410: PUSH
58411: LD_INT 6
58413: PUSH
58414: EMPTY
58415: LIST
58416: LIST
58417: PUSH
58418: LD_INT 30
58420: PUSH
58421: LD_INT 7
58423: PUSH
58424: EMPTY
58425: LIST
58426: LIST
58427: PUSH
58428: LD_INT 30
58430: PUSH
58431: LD_INT 8
58433: PUSH
58434: EMPTY
58435: LIST
58436: LIST
58437: PUSH
58438: EMPTY
58439: LIST
58440: LIST
58441: LIST
58442: LIST
58443: PUSH
58444: EMPTY
58445: LIST
58446: LIST
58447: PPUSH
58448: CALL_OW 72
58452: ST_TO_ADDR
58453: GO 58456
58455: POP
// if i = 1 then
58456: LD_VAR 0 8
58460: PUSH
58461: LD_INT 1
58463: EQUAL
58464: IFFALSE 58575
// begin tmp := [ ] ;
58466: LD_ADDR_VAR 0 19
58470: PUSH
58471: EMPTY
58472: ST_TO_ADDR
// for j in f do
58473: LD_ADDR_VAR 0 9
58477: PUSH
58478: LD_VAR 0 12
58482: PUSH
58483: FOR_IN
58484: IFFALSE 58557
// if GetBType ( j ) = b_bunker then
58486: LD_VAR 0 9
58490: PPUSH
58491: CALL_OW 266
58495: PUSH
58496: LD_INT 32
58498: EQUAL
58499: IFFALSE 58526
// tmp := Insert ( tmp , 1 , j ) else
58501: LD_ADDR_VAR 0 19
58505: PUSH
58506: LD_VAR 0 19
58510: PPUSH
58511: LD_INT 1
58513: PPUSH
58514: LD_VAR 0 9
58518: PPUSH
58519: CALL_OW 2
58523: ST_TO_ADDR
58524: GO 58555
// tmp := Insert ( tmp , tmp + 1 , j ) ;
58526: LD_ADDR_VAR 0 19
58530: PUSH
58531: LD_VAR 0 19
58535: PPUSH
58536: LD_VAR 0 19
58540: PUSH
58541: LD_INT 1
58543: PLUS
58544: PPUSH
58545: LD_VAR 0 9
58549: PPUSH
58550: CALL_OW 2
58554: ST_TO_ADDR
58555: GO 58483
58557: POP
58558: POP
// if tmp then
58559: LD_VAR 0 19
58563: IFFALSE 58575
// f := tmp ;
58565: LD_ADDR_VAR 0 12
58569: PUSH
58570: LD_VAR 0 19
58574: ST_TO_ADDR
// end ; x := personel [ i ] ;
58575: LD_ADDR_VAR 0 13
58579: PUSH
58580: LD_VAR 0 6
58584: PUSH
58585: LD_VAR 0 8
58589: ARRAY
58590: ST_TO_ADDR
// if x = - 1 then
58591: LD_VAR 0 13
58595: PUSH
58596: LD_INT 1
58598: NEG
58599: EQUAL
58600: IFFALSE 58809
// begin for j in f do
58602: LD_ADDR_VAR 0 9
58606: PUSH
58607: LD_VAR 0 12
58611: PUSH
58612: FOR_IN
58613: IFFALSE 58805
// repeat InitHc ;
58615: CALL_OW 19
// if GetBType ( j ) = b_barracks then
58619: LD_VAR 0 9
58623: PPUSH
58624: CALL_OW 266
58628: PUSH
58629: LD_INT 5
58631: EQUAL
58632: IFFALSE 58702
// begin if UnitsInside ( j ) < 3 then
58634: LD_VAR 0 9
58638: PPUSH
58639: CALL_OW 313
58643: PUSH
58644: LD_INT 3
58646: LESS
58647: IFFALSE 58683
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
58649: LD_INT 0
58651: PPUSH
58652: LD_INT 5
58654: PUSH
58655: LD_INT 8
58657: PUSH
58658: LD_INT 9
58660: PUSH
58661: EMPTY
58662: LIST
58663: LIST
58664: LIST
58665: PUSH
58666: LD_VAR 0 17
58670: ARRAY
58671: PPUSH
58672: LD_VAR 0 4
58676: PPUSH
58677: CALL_OW 380
58681: GO 58700
// PrepareHuman ( false , i , skill ) ;
58683: LD_INT 0
58685: PPUSH
58686: LD_VAR 0 8
58690: PPUSH
58691: LD_VAR 0 4
58695: PPUSH
58696: CALL_OW 380
// end else
58700: GO 58719
// PrepareHuman ( false , i , skill ) ;
58702: LD_INT 0
58704: PPUSH
58705: LD_VAR 0 8
58709: PPUSH
58710: LD_VAR 0 4
58714: PPUSH
58715: CALL_OW 380
// un := CreateHuman ;
58719: LD_ADDR_VAR 0 14
58723: PUSH
58724: CALL_OW 44
58728: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58729: LD_ADDR_VAR 0 7
58733: PUSH
58734: LD_VAR 0 7
58738: PPUSH
58739: LD_INT 1
58741: PPUSH
58742: LD_VAR 0 14
58746: PPUSH
58747: CALL_OW 2
58751: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
58752: LD_VAR 0 14
58756: PPUSH
58757: LD_VAR 0 9
58761: PPUSH
58762: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
58766: LD_VAR 0 9
58770: PPUSH
58771: CALL_OW 313
58775: PUSH
58776: LD_INT 6
58778: EQUAL
58779: PUSH
58780: LD_VAR 0 9
58784: PPUSH
58785: CALL_OW 266
58789: PUSH
58790: LD_INT 32
58792: PUSH
58793: LD_INT 31
58795: PUSH
58796: EMPTY
58797: LIST
58798: LIST
58799: IN
58800: OR
58801: IFFALSE 58615
58803: GO 58612
58805: POP
58806: POP
// end else
58807: GO 59189
// for j = 1 to x do
58809: LD_ADDR_VAR 0 9
58813: PUSH
58814: DOUBLE
58815: LD_INT 1
58817: DEC
58818: ST_TO_ADDR
58819: LD_VAR 0 13
58823: PUSH
58824: FOR_TO
58825: IFFALSE 59187
// begin InitHc ;
58827: CALL_OW 19
// if not f then
58831: LD_VAR 0 12
58835: NOT
58836: IFFALSE 58925
// begin PrepareHuman ( false , i , skill ) ;
58838: LD_INT 0
58840: PPUSH
58841: LD_VAR 0 8
58845: PPUSH
58846: LD_VAR 0 4
58850: PPUSH
58851: CALL_OW 380
// un := CreateHuman ;
58855: LD_ADDR_VAR 0 14
58859: PUSH
58860: CALL_OW 44
58864: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58865: LD_ADDR_VAR 0 7
58869: PUSH
58870: LD_VAR 0 7
58874: PPUSH
58875: LD_INT 1
58877: PPUSH
58878: LD_VAR 0 14
58882: PPUSH
58883: CALL_OW 2
58887: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
58888: LD_VAR 0 14
58892: PPUSH
58893: LD_VAR 0 1
58897: PPUSH
58898: CALL_OW 250
58902: PPUSH
58903: LD_VAR 0 1
58907: PPUSH
58908: CALL_OW 251
58912: PPUSH
58913: LD_INT 10
58915: PPUSH
58916: LD_INT 0
58918: PPUSH
58919: CALL_OW 50
// continue ;
58923: GO 58824
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
58925: LD_VAR 0 12
58929: PUSH
58930: LD_INT 1
58932: ARRAY
58933: PPUSH
58934: CALL_OW 313
58938: PUSH
58939: LD_VAR 0 12
58943: PUSH
58944: LD_INT 1
58946: ARRAY
58947: PPUSH
58948: CALL_OW 266
58952: PUSH
58953: LD_INT 32
58955: PUSH
58956: LD_INT 31
58958: PUSH
58959: EMPTY
58960: LIST
58961: LIST
58962: IN
58963: AND
58964: PUSH
58965: LD_VAR 0 12
58969: PUSH
58970: LD_INT 1
58972: ARRAY
58973: PPUSH
58974: CALL_OW 313
58978: PUSH
58979: LD_INT 6
58981: EQUAL
58982: OR
58983: IFFALSE 59003
// f := Delete ( f , 1 ) ;
58985: LD_ADDR_VAR 0 12
58989: PUSH
58990: LD_VAR 0 12
58994: PPUSH
58995: LD_INT 1
58997: PPUSH
58998: CALL_OW 3
59002: ST_TO_ADDR
// if not f then
59003: LD_VAR 0 12
59007: NOT
59008: IFFALSE 59026
// begin x := x + 2 ;
59010: LD_ADDR_VAR 0 13
59014: PUSH
59015: LD_VAR 0 13
59019: PUSH
59020: LD_INT 2
59022: PLUS
59023: ST_TO_ADDR
// continue ;
59024: GO 58824
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
59026: LD_VAR 0 12
59030: PUSH
59031: LD_INT 1
59033: ARRAY
59034: PPUSH
59035: CALL_OW 266
59039: PUSH
59040: LD_INT 5
59042: EQUAL
59043: IFFALSE 59117
// begin if UnitsInside ( f [ 1 ] ) < 3 then
59045: LD_VAR 0 12
59049: PUSH
59050: LD_INT 1
59052: ARRAY
59053: PPUSH
59054: CALL_OW 313
59058: PUSH
59059: LD_INT 3
59061: LESS
59062: IFFALSE 59098
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
59064: LD_INT 0
59066: PPUSH
59067: LD_INT 5
59069: PUSH
59070: LD_INT 8
59072: PUSH
59073: LD_INT 9
59075: PUSH
59076: EMPTY
59077: LIST
59078: LIST
59079: LIST
59080: PUSH
59081: LD_VAR 0 17
59085: ARRAY
59086: PPUSH
59087: LD_VAR 0 4
59091: PPUSH
59092: CALL_OW 380
59096: GO 59115
// PrepareHuman ( false , i , skill ) ;
59098: LD_INT 0
59100: PPUSH
59101: LD_VAR 0 8
59105: PPUSH
59106: LD_VAR 0 4
59110: PPUSH
59111: CALL_OW 380
// end else
59115: GO 59134
// PrepareHuman ( false , i , skill ) ;
59117: LD_INT 0
59119: PPUSH
59120: LD_VAR 0 8
59124: PPUSH
59125: LD_VAR 0 4
59129: PPUSH
59130: CALL_OW 380
// un := CreateHuman ;
59134: LD_ADDR_VAR 0 14
59138: PUSH
59139: CALL_OW 44
59143: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
59144: LD_ADDR_VAR 0 7
59148: PUSH
59149: LD_VAR 0 7
59153: PPUSH
59154: LD_INT 1
59156: PPUSH
59157: LD_VAR 0 14
59161: PPUSH
59162: CALL_OW 2
59166: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
59167: LD_VAR 0 14
59171: PPUSH
59172: LD_VAR 0 12
59176: PUSH
59177: LD_INT 1
59179: ARRAY
59180: PPUSH
59181: CALL_OW 52
// end ;
59185: GO 58824
59187: POP
59188: POP
// end ;
59189: GO 58126
59191: POP
59192: POP
// result := result ^ buildings ;
59193: LD_ADDR_VAR 0 7
59197: PUSH
59198: LD_VAR 0 7
59202: PUSH
59203: LD_VAR 0 18
59207: ADD
59208: ST_TO_ADDR
// end else
59209: GO 59352
// begin for i = 1 to personel do
59211: LD_ADDR_VAR 0 8
59215: PUSH
59216: DOUBLE
59217: LD_INT 1
59219: DEC
59220: ST_TO_ADDR
59221: LD_VAR 0 6
59225: PUSH
59226: FOR_TO
59227: IFFALSE 59350
// begin if i > 4 then
59229: LD_VAR 0 8
59233: PUSH
59234: LD_INT 4
59236: GREATER
59237: IFFALSE 59241
// break ;
59239: GO 59350
// x := personel [ i ] ;
59241: LD_ADDR_VAR 0 13
59245: PUSH
59246: LD_VAR 0 6
59250: PUSH
59251: LD_VAR 0 8
59255: ARRAY
59256: ST_TO_ADDR
// if x = - 1 then
59257: LD_VAR 0 13
59261: PUSH
59262: LD_INT 1
59264: NEG
59265: EQUAL
59266: IFFALSE 59270
// continue ;
59268: GO 59226
// PrepareHuman ( false , i , skill ) ;
59270: LD_INT 0
59272: PPUSH
59273: LD_VAR 0 8
59277: PPUSH
59278: LD_VAR 0 4
59282: PPUSH
59283: CALL_OW 380
// un := CreateHuman ;
59287: LD_ADDR_VAR 0 14
59291: PUSH
59292: CALL_OW 44
59296: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
59297: LD_VAR 0 14
59301: PPUSH
59302: LD_VAR 0 1
59306: PPUSH
59307: CALL_OW 250
59311: PPUSH
59312: LD_VAR 0 1
59316: PPUSH
59317: CALL_OW 251
59321: PPUSH
59322: LD_INT 10
59324: PPUSH
59325: LD_INT 0
59327: PPUSH
59328: CALL_OW 50
// result := result ^ un ;
59332: LD_ADDR_VAR 0 7
59336: PUSH
59337: LD_VAR 0 7
59341: PUSH
59342: LD_VAR 0 14
59346: ADD
59347: ST_TO_ADDR
// end ;
59348: GO 59226
59350: POP
59351: POP
// end ; end ;
59352: LD_VAR 0 7
59356: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
59357: LD_INT 0
59359: PPUSH
59360: PPUSH
59361: PPUSH
59362: PPUSH
59363: PPUSH
59364: PPUSH
59365: PPUSH
59366: PPUSH
59367: PPUSH
59368: PPUSH
59369: PPUSH
59370: PPUSH
59371: PPUSH
59372: PPUSH
59373: PPUSH
59374: PPUSH
// result := false ;
59375: LD_ADDR_VAR 0 3
59379: PUSH
59380: LD_INT 0
59382: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
59383: LD_VAR 0 1
59387: NOT
59388: PUSH
59389: LD_VAR 0 1
59393: PPUSH
59394: CALL_OW 266
59398: PUSH
59399: LD_INT 32
59401: PUSH
59402: LD_INT 33
59404: PUSH
59405: EMPTY
59406: LIST
59407: LIST
59408: IN
59409: NOT
59410: OR
59411: IFFALSE 59415
// exit ;
59413: GO 60551
// nat := GetNation ( tower ) ;
59415: LD_ADDR_VAR 0 12
59419: PUSH
59420: LD_VAR 0 1
59424: PPUSH
59425: CALL_OW 248
59429: ST_TO_ADDR
// side := GetSide ( tower ) ;
59430: LD_ADDR_VAR 0 16
59434: PUSH
59435: LD_VAR 0 1
59439: PPUSH
59440: CALL_OW 255
59444: ST_TO_ADDR
// x := GetX ( tower ) ;
59445: LD_ADDR_VAR 0 10
59449: PUSH
59450: LD_VAR 0 1
59454: PPUSH
59455: CALL_OW 250
59459: ST_TO_ADDR
// y := GetY ( tower ) ;
59460: LD_ADDR_VAR 0 11
59464: PUSH
59465: LD_VAR 0 1
59469: PPUSH
59470: CALL_OW 251
59474: ST_TO_ADDR
// if not x or not y then
59475: LD_VAR 0 10
59479: NOT
59480: PUSH
59481: LD_VAR 0 11
59485: NOT
59486: OR
59487: IFFALSE 59491
// exit ;
59489: GO 60551
// weapon := 0 ;
59491: LD_ADDR_VAR 0 18
59495: PUSH
59496: LD_INT 0
59498: ST_TO_ADDR
// fac_list := [ ] ;
59499: LD_ADDR_VAR 0 17
59503: PUSH
59504: EMPTY
59505: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
59506: LD_ADDR_VAR 0 6
59510: PUSH
59511: LD_VAR 0 1
59515: PPUSH
59516: CALL_OW 274
59520: PPUSH
59521: LD_VAR 0 2
59525: PPUSH
59526: CALL 57129 0 2
59530: PPUSH
59531: LD_INT 30
59533: PUSH
59534: LD_INT 3
59536: PUSH
59537: EMPTY
59538: LIST
59539: LIST
59540: PPUSH
59541: CALL_OW 72
59545: ST_TO_ADDR
// if not factories then
59546: LD_VAR 0 6
59550: NOT
59551: IFFALSE 59555
// exit ;
59553: GO 60551
// for i in factories do
59555: LD_ADDR_VAR 0 8
59559: PUSH
59560: LD_VAR 0 6
59564: PUSH
59565: FOR_IN
59566: IFFALSE 59591
// fac_list := fac_list union AvailableWeaponList ( i ) ;
59568: LD_ADDR_VAR 0 17
59572: PUSH
59573: LD_VAR 0 17
59577: PUSH
59578: LD_VAR 0 8
59582: PPUSH
59583: CALL_OW 478
59587: UNION
59588: ST_TO_ADDR
59589: GO 59565
59591: POP
59592: POP
// if not fac_list then
59593: LD_VAR 0 17
59597: NOT
59598: IFFALSE 59602
// exit ;
59600: GO 60551
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
59602: LD_ADDR_VAR 0 5
59606: PUSH
59607: LD_INT 4
59609: PUSH
59610: LD_INT 5
59612: PUSH
59613: LD_INT 9
59615: PUSH
59616: LD_INT 10
59618: PUSH
59619: LD_INT 6
59621: PUSH
59622: LD_INT 7
59624: PUSH
59625: LD_INT 11
59627: PUSH
59628: EMPTY
59629: LIST
59630: LIST
59631: LIST
59632: LIST
59633: LIST
59634: LIST
59635: LIST
59636: PUSH
59637: LD_INT 27
59639: PUSH
59640: LD_INT 28
59642: PUSH
59643: LD_INT 26
59645: PUSH
59646: LD_INT 30
59648: PUSH
59649: EMPTY
59650: LIST
59651: LIST
59652: LIST
59653: LIST
59654: PUSH
59655: LD_INT 43
59657: PUSH
59658: LD_INT 44
59660: PUSH
59661: LD_INT 46
59663: PUSH
59664: LD_INT 45
59666: PUSH
59667: LD_INT 47
59669: PUSH
59670: LD_INT 49
59672: PUSH
59673: EMPTY
59674: LIST
59675: LIST
59676: LIST
59677: LIST
59678: LIST
59679: LIST
59680: PUSH
59681: EMPTY
59682: LIST
59683: LIST
59684: LIST
59685: PUSH
59686: LD_VAR 0 12
59690: ARRAY
59691: ST_TO_ADDR
// for i in list do
59692: LD_ADDR_VAR 0 8
59696: PUSH
59697: LD_VAR 0 5
59701: PUSH
59702: FOR_IN
59703: IFFALSE 59736
// if not i in fac_list then
59705: LD_VAR 0 8
59709: PUSH
59710: LD_VAR 0 17
59714: IN
59715: NOT
59716: IFFALSE 59734
// list := list diff i ;
59718: LD_ADDR_VAR 0 5
59722: PUSH
59723: LD_VAR 0 5
59727: PUSH
59728: LD_VAR 0 8
59732: DIFF
59733: ST_TO_ADDR
59734: GO 59702
59736: POP
59737: POP
// if not list then
59738: LD_VAR 0 5
59742: NOT
59743: IFFALSE 59747
// exit ;
59745: GO 60551
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
59747: LD_VAR 0 12
59751: PUSH
59752: LD_INT 3
59754: EQUAL
59755: PUSH
59756: LD_INT 49
59758: PUSH
59759: LD_VAR 0 5
59763: IN
59764: AND
59765: PUSH
59766: LD_INT 31
59768: PPUSH
59769: LD_VAR 0 16
59773: PPUSH
59774: CALL_OW 321
59778: PUSH
59779: LD_INT 2
59781: EQUAL
59782: AND
59783: IFFALSE 59843
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
59785: LD_INT 22
59787: PUSH
59788: LD_VAR 0 16
59792: PUSH
59793: EMPTY
59794: LIST
59795: LIST
59796: PUSH
59797: LD_INT 35
59799: PUSH
59800: LD_INT 49
59802: PUSH
59803: EMPTY
59804: LIST
59805: LIST
59806: PUSH
59807: LD_INT 91
59809: PUSH
59810: LD_VAR 0 1
59814: PUSH
59815: LD_INT 10
59817: PUSH
59818: EMPTY
59819: LIST
59820: LIST
59821: LIST
59822: PUSH
59823: EMPTY
59824: LIST
59825: LIST
59826: LIST
59827: PPUSH
59828: CALL_OW 69
59832: NOT
59833: IFFALSE 59843
// weapon := ru_time_lapser ;
59835: LD_ADDR_VAR 0 18
59839: PUSH
59840: LD_INT 49
59842: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
59843: LD_VAR 0 12
59847: PUSH
59848: LD_INT 1
59850: PUSH
59851: LD_INT 2
59853: PUSH
59854: EMPTY
59855: LIST
59856: LIST
59857: IN
59858: PUSH
59859: LD_INT 11
59861: PUSH
59862: LD_VAR 0 5
59866: IN
59867: PUSH
59868: LD_INT 30
59870: PUSH
59871: LD_VAR 0 5
59875: IN
59876: OR
59877: AND
59878: PUSH
59879: LD_INT 6
59881: PPUSH
59882: LD_VAR 0 16
59886: PPUSH
59887: CALL_OW 321
59891: PUSH
59892: LD_INT 2
59894: EQUAL
59895: AND
59896: IFFALSE 60061
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
59898: LD_INT 22
59900: PUSH
59901: LD_VAR 0 16
59905: PUSH
59906: EMPTY
59907: LIST
59908: LIST
59909: PUSH
59910: LD_INT 2
59912: PUSH
59913: LD_INT 35
59915: PUSH
59916: LD_INT 11
59918: PUSH
59919: EMPTY
59920: LIST
59921: LIST
59922: PUSH
59923: LD_INT 35
59925: PUSH
59926: LD_INT 30
59928: PUSH
59929: EMPTY
59930: LIST
59931: LIST
59932: PUSH
59933: EMPTY
59934: LIST
59935: LIST
59936: LIST
59937: PUSH
59938: LD_INT 91
59940: PUSH
59941: LD_VAR 0 1
59945: PUSH
59946: LD_INT 18
59948: PUSH
59949: EMPTY
59950: LIST
59951: LIST
59952: LIST
59953: PUSH
59954: EMPTY
59955: LIST
59956: LIST
59957: LIST
59958: PPUSH
59959: CALL_OW 69
59963: NOT
59964: PUSH
59965: LD_INT 22
59967: PUSH
59968: LD_VAR 0 16
59972: PUSH
59973: EMPTY
59974: LIST
59975: LIST
59976: PUSH
59977: LD_INT 2
59979: PUSH
59980: LD_INT 30
59982: PUSH
59983: LD_INT 32
59985: PUSH
59986: EMPTY
59987: LIST
59988: LIST
59989: PUSH
59990: LD_INT 30
59992: PUSH
59993: LD_INT 33
59995: PUSH
59996: EMPTY
59997: LIST
59998: LIST
59999: PUSH
60000: EMPTY
60001: LIST
60002: LIST
60003: LIST
60004: PUSH
60005: LD_INT 91
60007: PUSH
60008: LD_VAR 0 1
60012: PUSH
60013: LD_INT 12
60015: PUSH
60016: EMPTY
60017: LIST
60018: LIST
60019: LIST
60020: PUSH
60021: EMPTY
60022: LIST
60023: LIST
60024: LIST
60025: PUSH
60026: EMPTY
60027: LIST
60028: PPUSH
60029: CALL_OW 69
60033: PUSH
60034: LD_INT 2
60036: GREATER
60037: AND
60038: IFFALSE 60061
// weapon := [ us_radar , ar_radar ] [ nat ] ;
60040: LD_ADDR_VAR 0 18
60044: PUSH
60045: LD_INT 11
60047: PUSH
60048: LD_INT 30
60050: PUSH
60051: EMPTY
60052: LIST
60053: LIST
60054: PUSH
60055: LD_VAR 0 12
60059: ARRAY
60060: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
60061: LD_VAR 0 18
60065: NOT
60066: PUSH
60067: LD_INT 40
60069: PPUSH
60070: LD_VAR 0 16
60074: PPUSH
60075: CALL_OW 321
60079: PUSH
60080: LD_INT 2
60082: EQUAL
60083: AND
60084: PUSH
60085: LD_INT 7
60087: PUSH
60088: LD_VAR 0 5
60092: IN
60093: PUSH
60094: LD_INT 28
60096: PUSH
60097: LD_VAR 0 5
60101: IN
60102: OR
60103: PUSH
60104: LD_INT 45
60106: PUSH
60107: LD_VAR 0 5
60111: IN
60112: OR
60113: AND
60114: IFFALSE 60368
// begin hex := GetHexInfo ( x , y ) ;
60116: LD_ADDR_VAR 0 4
60120: PUSH
60121: LD_VAR 0 10
60125: PPUSH
60126: LD_VAR 0 11
60130: PPUSH
60131: CALL_OW 546
60135: ST_TO_ADDR
// if hex [ 1 ] then
60136: LD_VAR 0 4
60140: PUSH
60141: LD_INT 1
60143: ARRAY
60144: IFFALSE 60148
// exit ;
60146: GO 60551
// height := hex [ 2 ] ;
60148: LD_ADDR_VAR 0 15
60152: PUSH
60153: LD_VAR 0 4
60157: PUSH
60158: LD_INT 2
60160: ARRAY
60161: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
60162: LD_ADDR_VAR 0 14
60166: PUSH
60167: LD_INT 0
60169: PUSH
60170: LD_INT 2
60172: PUSH
60173: LD_INT 3
60175: PUSH
60176: LD_INT 5
60178: PUSH
60179: EMPTY
60180: LIST
60181: LIST
60182: LIST
60183: LIST
60184: ST_TO_ADDR
// for i in tmp do
60185: LD_ADDR_VAR 0 8
60189: PUSH
60190: LD_VAR 0 14
60194: PUSH
60195: FOR_IN
60196: IFFALSE 60366
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
60198: LD_ADDR_VAR 0 9
60202: PUSH
60203: LD_VAR 0 10
60207: PPUSH
60208: LD_VAR 0 8
60212: PPUSH
60213: LD_INT 5
60215: PPUSH
60216: CALL_OW 272
60220: PUSH
60221: LD_VAR 0 11
60225: PPUSH
60226: LD_VAR 0 8
60230: PPUSH
60231: LD_INT 5
60233: PPUSH
60234: CALL_OW 273
60238: PUSH
60239: EMPTY
60240: LIST
60241: LIST
60242: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
60243: LD_VAR 0 9
60247: PUSH
60248: LD_INT 1
60250: ARRAY
60251: PPUSH
60252: LD_VAR 0 9
60256: PUSH
60257: LD_INT 2
60259: ARRAY
60260: PPUSH
60261: CALL_OW 488
60265: IFFALSE 60364
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
60267: LD_ADDR_VAR 0 4
60271: PUSH
60272: LD_VAR 0 9
60276: PUSH
60277: LD_INT 1
60279: ARRAY
60280: PPUSH
60281: LD_VAR 0 9
60285: PUSH
60286: LD_INT 2
60288: ARRAY
60289: PPUSH
60290: CALL_OW 546
60294: ST_TO_ADDR
// if hex [ 1 ] then
60295: LD_VAR 0 4
60299: PUSH
60300: LD_INT 1
60302: ARRAY
60303: IFFALSE 60307
// continue ;
60305: GO 60195
// h := hex [ 2 ] ;
60307: LD_ADDR_VAR 0 13
60311: PUSH
60312: LD_VAR 0 4
60316: PUSH
60317: LD_INT 2
60319: ARRAY
60320: ST_TO_ADDR
// if h + 7 < height then
60321: LD_VAR 0 13
60325: PUSH
60326: LD_INT 7
60328: PLUS
60329: PUSH
60330: LD_VAR 0 15
60334: LESS
60335: IFFALSE 60364
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
60337: LD_ADDR_VAR 0 18
60341: PUSH
60342: LD_INT 7
60344: PUSH
60345: LD_INT 28
60347: PUSH
60348: LD_INT 45
60350: PUSH
60351: EMPTY
60352: LIST
60353: LIST
60354: LIST
60355: PUSH
60356: LD_VAR 0 12
60360: ARRAY
60361: ST_TO_ADDR
// break ;
60362: GO 60366
// end ; end ; end ;
60364: GO 60195
60366: POP
60367: POP
// end ; if not weapon then
60368: LD_VAR 0 18
60372: NOT
60373: IFFALSE 60433
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
60375: LD_ADDR_VAR 0 5
60379: PUSH
60380: LD_VAR 0 5
60384: PUSH
60385: LD_INT 11
60387: PUSH
60388: LD_INT 30
60390: PUSH
60391: LD_INT 49
60393: PUSH
60394: EMPTY
60395: LIST
60396: LIST
60397: LIST
60398: DIFF
60399: ST_TO_ADDR
// if not list then
60400: LD_VAR 0 5
60404: NOT
60405: IFFALSE 60409
// exit ;
60407: GO 60551
// weapon := list [ rand ( 1 , list ) ] ;
60409: LD_ADDR_VAR 0 18
60413: PUSH
60414: LD_VAR 0 5
60418: PUSH
60419: LD_INT 1
60421: PPUSH
60422: LD_VAR 0 5
60426: PPUSH
60427: CALL_OW 12
60431: ARRAY
60432: ST_TO_ADDR
// end ; if weapon then
60433: LD_VAR 0 18
60437: IFFALSE 60551
// begin tmp := CostOfWeapon ( weapon ) ;
60439: LD_ADDR_VAR 0 14
60443: PUSH
60444: LD_VAR 0 18
60448: PPUSH
60449: CALL_OW 451
60453: ST_TO_ADDR
// j := GetBase ( tower ) ;
60454: LD_ADDR_VAR 0 9
60458: PUSH
60459: LD_VAR 0 1
60463: PPUSH
60464: CALL_OW 274
60468: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
60469: LD_VAR 0 9
60473: PPUSH
60474: LD_INT 1
60476: PPUSH
60477: CALL_OW 275
60481: PUSH
60482: LD_VAR 0 14
60486: PUSH
60487: LD_INT 1
60489: ARRAY
60490: GREATEREQUAL
60491: PUSH
60492: LD_VAR 0 9
60496: PPUSH
60497: LD_INT 2
60499: PPUSH
60500: CALL_OW 275
60504: PUSH
60505: LD_VAR 0 14
60509: PUSH
60510: LD_INT 2
60512: ARRAY
60513: GREATEREQUAL
60514: AND
60515: PUSH
60516: LD_VAR 0 9
60520: PPUSH
60521: LD_INT 3
60523: PPUSH
60524: CALL_OW 275
60528: PUSH
60529: LD_VAR 0 14
60533: PUSH
60534: LD_INT 3
60536: ARRAY
60537: GREATEREQUAL
60538: AND
60539: IFFALSE 60551
// result := weapon ;
60541: LD_ADDR_VAR 0 3
60545: PUSH
60546: LD_VAR 0 18
60550: ST_TO_ADDR
// end ; end ;
60551: LD_VAR 0 3
60555: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
60556: LD_INT 0
60558: PPUSH
60559: PPUSH
// result := true ;
60560: LD_ADDR_VAR 0 3
60564: PUSH
60565: LD_INT 1
60567: ST_TO_ADDR
// if array1 = array2 then
60568: LD_VAR 0 1
60572: PUSH
60573: LD_VAR 0 2
60577: EQUAL
60578: IFFALSE 60638
// begin for i = 1 to array1 do
60580: LD_ADDR_VAR 0 4
60584: PUSH
60585: DOUBLE
60586: LD_INT 1
60588: DEC
60589: ST_TO_ADDR
60590: LD_VAR 0 1
60594: PUSH
60595: FOR_TO
60596: IFFALSE 60634
// if array1 [ i ] <> array2 [ i ] then
60598: LD_VAR 0 1
60602: PUSH
60603: LD_VAR 0 4
60607: ARRAY
60608: PUSH
60609: LD_VAR 0 2
60613: PUSH
60614: LD_VAR 0 4
60618: ARRAY
60619: NONEQUAL
60620: IFFALSE 60632
// begin result := false ;
60622: LD_ADDR_VAR 0 3
60626: PUSH
60627: LD_INT 0
60629: ST_TO_ADDR
// break ;
60630: GO 60634
// end ;
60632: GO 60595
60634: POP
60635: POP
// end else
60636: GO 60646
// result := false ;
60638: LD_ADDR_VAR 0 3
60642: PUSH
60643: LD_INT 0
60645: ST_TO_ADDR
// end ;
60646: LD_VAR 0 3
60650: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
60651: LD_INT 0
60653: PPUSH
60654: PPUSH
60655: PPUSH
// pom := GetBase ( fac ) ;
60656: LD_ADDR_VAR 0 5
60660: PUSH
60661: LD_VAR 0 1
60665: PPUSH
60666: CALL_OW 274
60670: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
60671: LD_ADDR_VAR 0 4
60675: PUSH
60676: LD_VAR 0 2
60680: PUSH
60681: LD_INT 1
60683: ARRAY
60684: PPUSH
60685: LD_VAR 0 2
60689: PUSH
60690: LD_INT 2
60692: ARRAY
60693: PPUSH
60694: LD_VAR 0 2
60698: PUSH
60699: LD_INT 3
60701: ARRAY
60702: PPUSH
60703: LD_VAR 0 2
60707: PUSH
60708: LD_INT 4
60710: ARRAY
60711: PPUSH
60712: CALL_OW 449
60716: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60717: LD_ADDR_VAR 0 3
60721: PUSH
60722: LD_VAR 0 5
60726: PPUSH
60727: LD_INT 1
60729: PPUSH
60730: CALL_OW 275
60734: PUSH
60735: LD_VAR 0 4
60739: PUSH
60740: LD_INT 1
60742: ARRAY
60743: GREATEREQUAL
60744: PUSH
60745: LD_VAR 0 5
60749: PPUSH
60750: LD_INT 2
60752: PPUSH
60753: CALL_OW 275
60757: PUSH
60758: LD_VAR 0 4
60762: PUSH
60763: LD_INT 2
60765: ARRAY
60766: GREATEREQUAL
60767: AND
60768: PUSH
60769: LD_VAR 0 5
60773: PPUSH
60774: LD_INT 3
60776: PPUSH
60777: CALL_OW 275
60781: PUSH
60782: LD_VAR 0 4
60786: PUSH
60787: LD_INT 3
60789: ARRAY
60790: GREATEREQUAL
60791: AND
60792: ST_TO_ADDR
// end ;
60793: LD_VAR 0 3
60797: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
60798: LD_INT 0
60800: PPUSH
60801: PPUSH
60802: PPUSH
60803: PPUSH
// pom := GetBase ( building ) ;
60804: LD_ADDR_VAR 0 3
60808: PUSH
60809: LD_VAR 0 1
60813: PPUSH
60814: CALL_OW 274
60818: ST_TO_ADDR
// if not pom then
60819: LD_VAR 0 3
60823: NOT
60824: IFFALSE 60828
// exit ;
60826: GO 60998
// btype := GetBType ( building ) ;
60828: LD_ADDR_VAR 0 5
60832: PUSH
60833: LD_VAR 0 1
60837: PPUSH
60838: CALL_OW 266
60842: ST_TO_ADDR
// if btype = b_armoury then
60843: LD_VAR 0 5
60847: PUSH
60848: LD_INT 4
60850: EQUAL
60851: IFFALSE 60861
// btype := b_barracks ;
60853: LD_ADDR_VAR 0 5
60857: PUSH
60858: LD_INT 5
60860: ST_TO_ADDR
// if btype = b_depot then
60861: LD_VAR 0 5
60865: PUSH
60866: LD_INT 0
60868: EQUAL
60869: IFFALSE 60879
// btype := b_warehouse ;
60871: LD_ADDR_VAR 0 5
60875: PUSH
60876: LD_INT 1
60878: ST_TO_ADDR
// if btype = b_workshop then
60879: LD_VAR 0 5
60883: PUSH
60884: LD_INT 2
60886: EQUAL
60887: IFFALSE 60897
// btype := b_factory ;
60889: LD_ADDR_VAR 0 5
60893: PUSH
60894: LD_INT 3
60896: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
60897: LD_ADDR_VAR 0 4
60901: PUSH
60902: LD_VAR 0 5
60906: PPUSH
60907: LD_VAR 0 1
60911: PPUSH
60912: CALL_OW 248
60916: PPUSH
60917: CALL_OW 450
60921: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60922: LD_ADDR_VAR 0 2
60926: PUSH
60927: LD_VAR 0 3
60931: PPUSH
60932: LD_INT 1
60934: PPUSH
60935: CALL_OW 275
60939: PUSH
60940: LD_VAR 0 4
60944: PUSH
60945: LD_INT 1
60947: ARRAY
60948: GREATEREQUAL
60949: PUSH
60950: LD_VAR 0 3
60954: PPUSH
60955: LD_INT 2
60957: PPUSH
60958: CALL_OW 275
60962: PUSH
60963: LD_VAR 0 4
60967: PUSH
60968: LD_INT 2
60970: ARRAY
60971: GREATEREQUAL
60972: AND
60973: PUSH
60974: LD_VAR 0 3
60978: PPUSH
60979: LD_INT 3
60981: PPUSH
60982: CALL_OW 275
60986: PUSH
60987: LD_VAR 0 4
60991: PUSH
60992: LD_INT 3
60994: ARRAY
60995: GREATEREQUAL
60996: AND
60997: ST_TO_ADDR
// end ;
60998: LD_VAR 0 2
61002: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
61003: LD_INT 0
61005: PPUSH
61006: PPUSH
61007: PPUSH
// pom := GetBase ( building ) ;
61008: LD_ADDR_VAR 0 4
61012: PUSH
61013: LD_VAR 0 1
61017: PPUSH
61018: CALL_OW 274
61022: ST_TO_ADDR
// if not pom then
61023: LD_VAR 0 4
61027: NOT
61028: IFFALSE 61032
// exit ;
61030: GO 61133
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
61032: LD_ADDR_VAR 0 5
61036: PUSH
61037: LD_VAR 0 2
61041: PPUSH
61042: LD_VAR 0 1
61046: PPUSH
61047: CALL_OW 248
61051: PPUSH
61052: CALL_OW 450
61056: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
61057: LD_ADDR_VAR 0 3
61061: PUSH
61062: LD_VAR 0 4
61066: PPUSH
61067: LD_INT 1
61069: PPUSH
61070: CALL_OW 275
61074: PUSH
61075: LD_VAR 0 5
61079: PUSH
61080: LD_INT 1
61082: ARRAY
61083: GREATEREQUAL
61084: PUSH
61085: LD_VAR 0 4
61089: PPUSH
61090: LD_INT 2
61092: PPUSH
61093: CALL_OW 275
61097: PUSH
61098: LD_VAR 0 5
61102: PUSH
61103: LD_INT 2
61105: ARRAY
61106: GREATEREQUAL
61107: AND
61108: PUSH
61109: LD_VAR 0 4
61113: PPUSH
61114: LD_INT 3
61116: PPUSH
61117: CALL_OW 275
61121: PUSH
61122: LD_VAR 0 5
61126: PUSH
61127: LD_INT 3
61129: ARRAY
61130: GREATEREQUAL
61131: AND
61132: ST_TO_ADDR
// end ;
61133: LD_VAR 0 3
61137: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
61138: LD_INT 0
61140: PPUSH
61141: PPUSH
61142: PPUSH
61143: PPUSH
61144: PPUSH
61145: PPUSH
61146: PPUSH
61147: PPUSH
61148: PPUSH
61149: PPUSH
// result := false ;
61150: LD_ADDR_VAR 0 6
61154: PUSH
61155: LD_INT 0
61157: ST_TO_ADDR
// if not base or not btype or not x or not y then
61158: LD_VAR 0 1
61162: NOT
61163: PUSH
61164: LD_VAR 0 2
61168: NOT
61169: OR
61170: PUSH
61171: LD_VAR 0 3
61175: NOT
61176: OR
61177: PUSH
61178: LD_VAR 0 4
61182: NOT
61183: OR
61184: IFFALSE 61188
// exit ;
61186: GO 61797
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
61188: LD_ADDR_VAR 0 12
61192: PUSH
61193: LD_VAR 0 2
61197: PPUSH
61198: LD_VAR 0 3
61202: PPUSH
61203: LD_VAR 0 4
61207: PPUSH
61208: LD_VAR 0 5
61212: PPUSH
61213: LD_VAR 0 1
61217: PUSH
61218: LD_INT 1
61220: ARRAY
61221: PPUSH
61222: CALL_OW 248
61226: PPUSH
61227: LD_INT 0
61229: PPUSH
61230: CALL 62634 0 6
61234: ST_TO_ADDR
// if not hexes then
61235: LD_VAR 0 12
61239: NOT
61240: IFFALSE 61244
// exit ;
61242: GO 61797
// for i = 1 to hexes do
61244: LD_ADDR_VAR 0 7
61248: PUSH
61249: DOUBLE
61250: LD_INT 1
61252: DEC
61253: ST_TO_ADDR
61254: LD_VAR 0 12
61258: PUSH
61259: FOR_TO
61260: IFFALSE 61795
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
61262: LD_ADDR_VAR 0 11
61266: PUSH
61267: LD_VAR 0 12
61271: PUSH
61272: LD_VAR 0 7
61276: ARRAY
61277: PUSH
61278: LD_INT 1
61280: ARRAY
61281: PPUSH
61282: LD_VAR 0 12
61286: PUSH
61287: LD_VAR 0 7
61291: ARRAY
61292: PUSH
61293: LD_INT 2
61295: ARRAY
61296: PPUSH
61297: CALL_OW 428
61301: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
61302: LD_VAR 0 12
61306: PUSH
61307: LD_VAR 0 7
61311: ARRAY
61312: PUSH
61313: LD_INT 1
61315: ARRAY
61316: PPUSH
61317: LD_VAR 0 12
61321: PUSH
61322: LD_VAR 0 7
61326: ARRAY
61327: PUSH
61328: LD_INT 2
61330: ARRAY
61331: PPUSH
61332: CALL_OW 351
61336: PUSH
61337: LD_VAR 0 12
61341: PUSH
61342: LD_VAR 0 7
61346: ARRAY
61347: PUSH
61348: LD_INT 1
61350: ARRAY
61351: PPUSH
61352: LD_VAR 0 12
61356: PUSH
61357: LD_VAR 0 7
61361: ARRAY
61362: PUSH
61363: LD_INT 2
61365: ARRAY
61366: PPUSH
61367: CALL_OW 488
61371: NOT
61372: OR
61373: PUSH
61374: LD_VAR 0 11
61378: PPUSH
61379: CALL_OW 247
61383: PUSH
61384: LD_INT 3
61386: EQUAL
61387: OR
61388: IFFALSE 61394
// exit ;
61390: POP
61391: POP
61392: GO 61797
// if not tmp or not tmp in base then
61394: LD_VAR 0 11
61398: NOT
61399: PUSH
61400: LD_VAR 0 11
61404: PUSH
61405: LD_VAR 0 1
61409: IN
61410: NOT
61411: OR
61412: IFFALSE 61416
// continue ;
61414: GO 61259
// result := true ;
61416: LD_ADDR_VAR 0 6
61420: PUSH
61421: LD_INT 1
61423: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
61424: LD_ADDR_VAR 0 15
61428: PUSH
61429: LD_VAR 0 1
61433: PPUSH
61434: LD_INT 22
61436: PUSH
61437: LD_VAR 0 11
61441: PPUSH
61442: CALL_OW 255
61446: PUSH
61447: EMPTY
61448: LIST
61449: LIST
61450: PUSH
61451: LD_INT 2
61453: PUSH
61454: LD_INT 30
61456: PUSH
61457: LD_INT 0
61459: PUSH
61460: EMPTY
61461: LIST
61462: LIST
61463: PUSH
61464: LD_INT 30
61466: PUSH
61467: LD_INT 1
61469: PUSH
61470: EMPTY
61471: LIST
61472: LIST
61473: PUSH
61474: EMPTY
61475: LIST
61476: LIST
61477: LIST
61478: PUSH
61479: EMPTY
61480: LIST
61481: LIST
61482: PPUSH
61483: CALL_OW 72
61487: ST_TO_ADDR
// if dep then
61488: LD_VAR 0 15
61492: IFFALSE 61628
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
61494: LD_ADDR_VAR 0 14
61498: PUSH
61499: LD_VAR 0 15
61503: PUSH
61504: LD_INT 1
61506: ARRAY
61507: PPUSH
61508: CALL_OW 250
61512: PPUSH
61513: LD_VAR 0 15
61517: PUSH
61518: LD_INT 1
61520: ARRAY
61521: PPUSH
61522: CALL_OW 254
61526: PPUSH
61527: LD_INT 5
61529: PPUSH
61530: CALL_OW 272
61534: PUSH
61535: LD_VAR 0 15
61539: PUSH
61540: LD_INT 1
61542: ARRAY
61543: PPUSH
61544: CALL_OW 251
61548: PPUSH
61549: LD_VAR 0 15
61553: PUSH
61554: LD_INT 1
61556: ARRAY
61557: PPUSH
61558: CALL_OW 254
61562: PPUSH
61563: LD_INT 5
61565: PPUSH
61566: CALL_OW 273
61570: PUSH
61571: EMPTY
61572: LIST
61573: LIST
61574: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
61575: LD_VAR 0 14
61579: PUSH
61580: LD_INT 1
61582: ARRAY
61583: PPUSH
61584: LD_VAR 0 14
61588: PUSH
61589: LD_INT 2
61591: ARRAY
61592: PPUSH
61593: CALL_OW 488
61597: IFFALSE 61628
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
61599: LD_VAR 0 11
61603: PPUSH
61604: LD_VAR 0 14
61608: PUSH
61609: LD_INT 1
61611: ARRAY
61612: PPUSH
61613: LD_VAR 0 14
61617: PUSH
61618: LD_INT 2
61620: ARRAY
61621: PPUSH
61622: CALL_OW 111
// continue ;
61626: GO 61259
// end ; end ; r := GetDir ( tmp ) ;
61628: LD_ADDR_VAR 0 13
61632: PUSH
61633: LD_VAR 0 11
61637: PPUSH
61638: CALL_OW 254
61642: ST_TO_ADDR
// if r = 5 then
61643: LD_VAR 0 13
61647: PUSH
61648: LD_INT 5
61650: EQUAL
61651: IFFALSE 61661
// r := 0 ;
61653: LD_ADDR_VAR 0 13
61657: PUSH
61658: LD_INT 0
61660: ST_TO_ADDR
// for j = r to 5 do
61661: LD_ADDR_VAR 0 8
61665: PUSH
61666: DOUBLE
61667: LD_VAR 0 13
61671: DEC
61672: ST_TO_ADDR
61673: LD_INT 5
61675: PUSH
61676: FOR_TO
61677: IFFALSE 61791
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
61679: LD_ADDR_VAR 0 9
61683: PUSH
61684: LD_VAR 0 11
61688: PPUSH
61689: CALL_OW 250
61693: PPUSH
61694: LD_VAR 0 8
61698: PPUSH
61699: LD_INT 2
61701: PPUSH
61702: CALL_OW 272
61706: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
61707: LD_ADDR_VAR 0 10
61711: PUSH
61712: LD_VAR 0 11
61716: PPUSH
61717: CALL_OW 251
61721: PPUSH
61722: LD_VAR 0 8
61726: PPUSH
61727: LD_INT 2
61729: PPUSH
61730: CALL_OW 273
61734: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
61735: LD_VAR 0 9
61739: PPUSH
61740: LD_VAR 0 10
61744: PPUSH
61745: CALL_OW 488
61749: PUSH
61750: LD_VAR 0 9
61754: PPUSH
61755: LD_VAR 0 10
61759: PPUSH
61760: CALL_OW 428
61764: NOT
61765: AND
61766: IFFALSE 61789
// begin ComMoveXY ( tmp , _x , _y ) ;
61768: LD_VAR 0 11
61772: PPUSH
61773: LD_VAR 0 9
61777: PPUSH
61778: LD_VAR 0 10
61782: PPUSH
61783: CALL_OW 111
// break ;
61787: GO 61791
// end ; end ;
61789: GO 61676
61791: POP
61792: POP
// end ;
61793: GO 61259
61795: POP
61796: POP
// end ;
61797: LD_VAR 0 6
61801: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
61802: LD_INT 0
61804: PPUSH
61805: PPUSH
61806: PPUSH
61807: PPUSH
61808: PPUSH
61809: PPUSH
61810: PPUSH
61811: PPUSH
61812: PPUSH
61813: PPUSH
// result := false ;
61814: LD_ADDR_VAR 0 6
61818: PUSH
61819: LD_INT 0
61821: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
61822: LD_VAR 0 1
61826: NOT
61827: PUSH
61828: LD_VAR 0 1
61832: PPUSH
61833: CALL_OW 266
61837: PUSH
61838: LD_INT 0
61840: PUSH
61841: LD_INT 1
61843: PUSH
61844: EMPTY
61845: LIST
61846: LIST
61847: IN
61848: NOT
61849: OR
61850: PUSH
61851: LD_VAR 0 2
61855: NOT
61856: OR
61857: PUSH
61858: LD_VAR 0 5
61862: PUSH
61863: LD_INT 0
61865: PUSH
61866: LD_INT 1
61868: PUSH
61869: LD_INT 2
61871: PUSH
61872: LD_INT 3
61874: PUSH
61875: LD_INT 4
61877: PUSH
61878: LD_INT 5
61880: PUSH
61881: EMPTY
61882: LIST
61883: LIST
61884: LIST
61885: LIST
61886: LIST
61887: LIST
61888: IN
61889: NOT
61890: OR
61891: PUSH
61892: LD_VAR 0 3
61896: PPUSH
61897: LD_VAR 0 4
61901: PPUSH
61902: CALL_OW 488
61906: NOT
61907: OR
61908: IFFALSE 61912
// exit ;
61910: GO 62629
// pom := GetBase ( depot ) ;
61912: LD_ADDR_VAR 0 10
61916: PUSH
61917: LD_VAR 0 1
61921: PPUSH
61922: CALL_OW 274
61926: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
61927: LD_ADDR_VAR 0 11
61931: PUSH
61932: LD_VAR 0 2
61936: PPUSH
61937: LD_VAR 0 1
61941: PPUSH
61942: CALL_OW 248
61946: PPUSH
61947: CALL_OW 450
61951: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
61952: LD_VAR 0 10
61956: PPUSH
61957: LD_INT 1
61959: PPUSH
61960: CALL_OW 275
61964: PUSH
61965: LD_VAR 0 11
61969: PUSH
61970: LD_INT 1
61972: ARRAY
61973: GREATEREQUAL
61974: PUSH
61975: LD_VAR 0 10
61979: PPUSH
61980: LD_INT 2
61982: PPUSH
61983: CALL_OW 275
61987: PUSH
61988: LD_VAR 0 11
61992: PUSH
61993: LD_INT 2
61995: ARRAY
61996: GREATEREQUAL
61997: AND
61998: PUSH
61999: LD_VAR 0 10
62003: PPUSH
62004: LD_INT 3
62006: PPUSH
62007: CALL_OW 275
62011: PUSH
62012: LD_VAR 0 11
62016: PUSH
62017: LD_INT 3
62019: ARRAY
62020: GREATEREQUAL
62021: AND
62022: NOT
62023: IFFALSE 62027
// exit ;
62025: GO 62629
// if GetBType ( depot ) = b_depot then
62027: LD_VAR 0 1
62031: PPUSH
62032: CALL_OW 266
62036: PUSH
62037: LD_INT 0
62039: EQUAL
62040: IFFALSE 62052
// dist := 28 else
62042: LD_ADDR_VAR 0 14
62046: PUSH
62047: LD_INT 28
62049: ST_TO_ADDR
62050: GO 62060
// dist := 36 ;
62052: LD_ADDR_VAR 0 14
62056: PUSH
62057: LD_INT 36
62059: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
62060: LD_VAR 0 1
62064: PPUSH
62065: LD_VAR 0 3
62069: PPUSH
62070: LD_VAR 0 4
62074: PPUSH
62075: CALL_OW 297
62079: PUSH
62080: LD_VAR 0 14
62084: GREATER
62085: IFFALSE 62089
// exit ;
62087: GO 62629
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
62089: LD_ADDR_VAR 0 12
62093: PUSH
62094: LD_VAR 0 2
62098: PPUSH
62099: LD_VAR 0 3
62103: PPUSH
62104: LD_VAR 0 4
62108: PPUSH
62109: LD_VAR 0 5
62113: PPUSH
62114: LD_VAR 0 1
62118: PPUSH
62119: CALL_OW 248
62123: PPUSH
62124: LD_INT 0
62126: PPUSH
62127: CALL 62634 0 6
62131: ST_TO_ADDR
// if not hexes then
62132: LD_VAR 0 12
62136: NOT
62137: IFFALSE 62141
// exit ;
62139: GO 62629
// hex := GetHexInfo ( x , y ) ;
62141: LD_ADDR_VAR 0 15
62145: PUSH
62146: LD_VAR 0 3
62150: PPUSH
62151: LD_VAR 0 4
62155: PPUSH
62156: CALL_OW 546
62160: ST_TO_ADDR
// if hex [ 1 ] then
62161: LD_VAR 0 15
62165: PUSH
62166: LD_INT 1
62168: ARRAY
62169: IFFALSE 62173
// exit ;
62171: GO 62629
// height := hex [ 2 ] ;
62173: LD_ADDR_VAR 0 13
62177: PUSH
62178: LD_VAR 0 15
62182: PUSH
62183: LD_INT 2
62185: ARRAY
62186: ST_TO_ADDR
// for i = 1 to hexes do
62187: LD_ADDR_VAR 0 7
62191: PUSH
62192: DOUBLE
62193: LD_INT 1
62195: DEC
62196: ST_TO_ADDR
62197: LD_VAR 0 12
62201: PUSH
62202: FOR_TO
62203: IFFALSE 62533
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
62205: LD_VAR 0 12
62209: PUSH
62210: LD_VAR 0 7
62214: ARRAY
62215: PUSH
62216: LD_INT 1
62218: ARRAY
62219: PPUSH
62220: LD_VAR 0 12
62224: PUSH
62225: LD_VAR 0 7
62229: ARRAY
62230: PUSH
62231: LD_INT 2
62233: ARRAY
62234: PPUSH
62235: CALL_OW 488
62239: NOT
62240: PUSH
62241: LD_VAR 0 12
62245: PUSH
62246: LD_VAR 0 7
62250: ARRAY
62251: PUSH
62252: LD_INT 1
62254: ARRAY
62255: PPUSH
62256: LD_VAR 0 12
62260: PUSH
62261: LD_VAR 0 7
62265: ARRAY
62266: PUSH
62267: LD_INT 2
62269: ARRAY
62270: PPUSH
62271: CALL_OW 428
62275: PUSH
62276: LD_INT 0
62278: GREATER
62279: OR
62280: PUSH
62281: LD_VAR 0 12
62285: PUSH
62286: LD_VAR 0 7
62290: ARRAY
62291: PUSH
62292: LD_INT 1
62294: ARRAY
62295: PPUSH
62296: LD_VAR 0 12
62300: PUSH
62301: LD_VAR 0 7
62305: ARRAY
62306: PUSH
62307: LD_INT 2
62309: ARRAY
62310: PPUSH
62311: CALL_OW 351
62315: OR
62316: IFFALSE 62322
// exit ;
62318: POP
62319: POP
62320: GO 62629
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
62322: LD_ADDR_VAR 0 8
62326: PUSH
62327: LD_VAR 0 12
62331: PUSH
62332: LD_VAR 0 7
62336: ARRAY
62337: PUSH
62338: LD_INT 1
62340: ARRAY
62341: PPUSH
62342: LD_VAR 0 12
62346: PUSH
62347: LD_VAR 0 7
62351: ARRAY
62352: PUSH
62353: LD_INT 2
62355: ARRAY
62356: PPUSH
62357: CALL_OW 546
62361: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
62362: LD_VAR 0 8
62366: PUSH
62367: LD_INT 1
62369: ARRAY
62370: PUSH
62371: LD_VAR 0 8
62375: PUSH
62376: LD_INT 2
62378: ARRAY
62379: PUSH
62380: LD_VAR 0 13
62384: PUSH
62385: LD_INT 2
62387: PLUS
62388: GREATER
62389: OR
62390: PUSH
62391: LD_VAR 0 8
62395: PUSH
62396: LD_INT 2
62398: ARRAY
62399: PUSH
62400: LD_VAR 0 13
62404: PUSH
62405: LD_INT 2
62407: MINUS
62408: LESS
62409: OR
62410: PUSH
62411: LD_VAR 0 8
62415: PUSH
62416: LD_INT 3
62418: ARRAY
62419: PUSH
62420: LD_INT 0
62422: PUSH
62423: LD_INT 8
62425: PUSH
62426: LD_INT 9
62428: PUSH
62429: LD_INT 10
62431: PUSH
62432: LD_INT 11
62434: PUSH
62435: LD_INT 12
62437: PUSH
62438: LD_INT 13
62440: PUSH
62441: LD_INT 16
62443: PUSH
62444: LD_INT 17
62446: PUSH
62447: LD_INT 18
62449: PUSH
62450: LD_INT 19
62452: PUSH
62453: LD_INT 20
62455: PUSH
62456: LD_INT 21
62458: PUSH
62459: EMPTY
62460: LIST
62461: LIST
62462: LIST
62463: LIST
62464: LIST
62465: LIST
62466: LIST
62467: LIST
62468: LIST
62469: LIST
62470: LIST
62471: LIST
62472: LIST
62473: IN
62474: NOT
62475: OR
62476: PUSH
62477: LD_VAR 0 8
62481: PUSH
62482: LD_INT 5
62484: ARRAY
62485: NOT
62486: OR
62487: PUSH
62488: LD_VAR 0 8
62492: PUSH
62493: LD_INT 6
62495: ARRAY
62496: PUSH
62497: LD_INT 1
62499: PUSH
62500: LD_INT 2
62502: PUSH
62503: LD_INT 7
62505: PUSH
62506: LD_INT 9
62508: PUSH
62509: LD_INT 10
62511: PUSH
62512: LD_INT 11
62514: PUSH
62515: EMPTY
62516: LIST
62517: LIST
62518: LIST
62519: LIST
62520: LIST
62521: LIST
62522: IN
62523: NOT
62524: OR
62525: IFFALSE 62531
// exit ;
62527: POP
62528: POP
62529: GO 62629
// end ;
62531: GO 62202
62533: POP
62534: POP
// side := GetSide ( depot ) ;
62535: LD_ADDR_VAR 0 9
62539: PUSH
62540: LD_VAR 0 1
62544: PPUSH
62545: CALL_OW 255
62549: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
62550: LD_VAR 0 9
62554: PPUSH
62555: LD_VAR 0 3
62559: PPUSH
62560: LD_VAR 0 4
62564: PPUSH
62565: LD_INT 20
62567: PPUSH
62568: CALL 55283 0 4
62572: PUSH
62573: LD_INT 4
62575: ARRAY
62576: IFFALSE 62580
// exit ;
62578: GO 62629
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
62580: LD_VAR 0 2
62584: PUSH
62585: LD_INT 29
62587: PUSH
62588: LD_INT 30
62590: PUSH
62591: EMPTY
62592: LIST
62593: LIST
62594: IN
62595: PUSH
62596: LD_VAR 0 3
62600: PPUSH
62601: LD_VAR 0 4
62605: PPUSH
62606: LD_VAR 0 9
62610: PPUSH
62611: CALL_OW 440
62615: NOT
62616: AND
62617: IFFALSE 62621
// exit ;
62619: GO 62629
// result := true ;
62621: LD_ADDR_VAR 0 6
62625: PUSH
62626: LD_INT 1
62628: ST_TO_ADDR
// end ;
62629: LD_VAR 0 6
62633: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
62634: LD_INT 0
62636: PPUSH
62637: PPUSH
62638: PPUSH
62639: PPUSH
62640: PPUSH
62641: PPUSH
62642: PPUSH
62643: PPUSH
62644: PPUSH
62645: PPUSH
62646: PPUSH
62647: PPUSH
62648: PPUSH
62649: PPUSH
62650: PPUSH
62651: PPUSH
62652: PPUSH
62653: PPUSH
62654: PPUSH
62655: PPUSH
62656: PPUSH
62657: PPUSH
62658: PPUSH
62659: PPUSH
62660: PPUSH
62661: PPUSH
62662: PPUSH
62663: PPUSH
62664: PPUSH
62665: PPUSH
62666: PPUSH
62667: PPUSH
62668: PPUSH
62669: PPUSH
62670: PPUSH
62671: PPUSH
62672: PPUSH
62673: PPUSH
62674: PPUSH
62675: PPUSH
62676: PPUSH
62677: PPUSH
62678: PPUSH
62679: PPUSH
62680: PPUSH
62681: PPUSH
62682: PPUSH
62683: PPUSH
62684: PPUSH
62685: PPUSH
62686: PPUSH
62687: PPUSH
62688: PPUSH
62689: PPUSH
62690: PPUSH
62691: PPUSH
62692: PPUSH
62693: PPUSH
// result = [ ] ;
62694: LD_ADDR_VAR 0 7
62698: PUSH
62699: EMPTY
62700: ST_TO_ADDR
// temp_list = [ ] ;
62701: LD_ADDR_VAR 0 9
62705: PUSH
62706: EMPTY
62707: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
62708: LD_VAR 0 4
62712: PUSH
62713: LD_INT 0
62715: PUSH
62716: LD_INT 1
62718: PUSH
62719: LD_INT 2
62721: PUSH
62722: LD_INT 3
62724: PUSH
62725: LD_INT 4
62727: PUSH
62728: LD_INT 5
62730: PUSH
62731: EMPTY
62732: LIST
62733: LIST
62734: LIST
62735: LIST
62736: LIST
62737: LIST
62738: IN
62739: NOT
62740: PUSH
62741: LD_VAR 0 1
62745: PUSH
62746: LD_INT 0
62748: PUSH
62749: LD_INT 1
62751: PUSH
62752: EMPTY
62753: LIST
62754: LIST
62755: IN
62756: PUSH
62757: LD_VAR 0 5
62761: PUSH
62762: LD_INT 1
62764: PUSH
62765: LD_INT 2
62767: PUSH
62768: LD_INT 3
62770: PUSH
62771: EMPTY
62772: LIST
62773: LIST
62774: LIST
62775: IN
62776: NOT
62777: AND
62778: OR
62779: IFFALSE 62783
// exit ;
62781: GO 81174
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
62783: LD_VAR 0 1
62787: PUSH
62788: LD_INT 6
62790: PUSH
62791: LD_INT 7
62793: PUSH
62794: LD_INT 8
62796: PUSH
62797: LD_INT 13
62799: PUSH
62800: LD_INT 12
62802: PUSH
62803: LD_INT 15
62805: PUSH
62806: LD_INT 11
62808: PUSH
62809: LD_INT 14
62811: PUSH
62812: LD_INT 10
62814: PUSH
62815: EMPTY
62816: LIST
62817: LIST
62818: LIST
62819: LIST
62820: LIST
62821: LIST
62822: LIST
62823: LIST
62824: LIST
62825: IN
62826: IFFALSE 62836
// btype = b_lab ;
62828: LD_ADDR_VAR 0 1
62832: PUSH
62833: LD_INT 6
62835: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
62836: LD_VAR 0 6
62840: PUSH
62841: LD_INT 0
62843: PUSH
62844: LD_INT 1
62846: PUSH
62847: LD_INT 2
62849: PUSH
62850: EMPTY
62851: LIST
62852: LIST
62853: LIST
62854: IN
62855: NOT
62856: PUSH
62857: LD_VAR 0 1
62861: PUSH
62862: LD_INT 0
62864: PUSH
62865: LD_INT 1
62867: PUSH
62868: LD_INT 2
62870: PUSH
62871: LD_INT 3
62873: PUSH
62874: LD_INT 6
62876: PUSH
62877: LD_INT 36
62879: PUSH
62880: LD_INT 4
62882: PUSH
62883: LD_INT 5
62885: PUSH
62886: LD_INT 31
62888: PUSH
62889: LD_INT 32
62891: PUSH
62892: LD_INT 33
62894: PUSH
62895: EMPTY
62896: LIST
62897: LIST
62898: LIST
62899: LIST
62900: LIST
62901: LIST
62902: LIST
62903: LIST
62904: LIST
62905: LIST
62906: LIST
62907: IN
62908: NOT
62909: PUSH
62910: LD_VAR 0 6
62914: PUSH
62915: LD_INT 1
62917: EQUAL
62918: AND
62919: OR
62920: PUSH
62921: LD_VAR 0 1
62925: PUSH
62926: LD_INT 2
62928: PUSH
62929: LD_INT 3
62931: PUSH
62932: EMPTY
62933: LIST
62934: LIST
62935: IN
62936: NOT
62937: PUSH
62938: LD_VAR 0 6
62942: PUSH
62943: LD_INT 2
62945: EQUAL
62946: AND
62947: OR
62948: IFFALSE 62958
// mode = 0 ;
62950: LD_ADDR_VAR 0 6
62954: PUSH
62955: LD_INT 0
62957: ST_TO_ADDR
// case mode of 0 :
62958: LD_VAR 0 6
62962: PUSH
62963: LD_INT 0
62965: DOUBLE
62966: EQUAL
62967: IFTRUE 62971
62969: GO 74424
62971: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
62972: LD_ADDR_VAR 0 11
62976: PUSH
62977: LD_INT 0
62979: PUSH
62980: LD_INT 0
62982: PUSH
62983: EMPTY
62984: LIST
62985: LIST
62986: PUSH
62987: LD_INT 0
62989: PUSH
62990: LD_INT 1
62992: NEG
62993: PUSH
62994: EMPTY
62995: LIST
62996: LIST
62997: PUSH
62998: LD_INT 1
63000: PUSH
63001: LD_INT 0
63003: PUSH
63004: EMPTY
63005: LIST
63006: LIST
63007: PUSH
63008: LD_INT 1
63010: PUSH
63011: LD_INT 1
63013: PUSH
63014: EMPTY
63015: LIST
63016: LIST
63017: PUSH
63018: LD_INT 0
63020: PUSH
63021: LD_INT 1
63023: PUSH
63024: EMPTY
63025: LIST
63026: LIST
63027: PUSH
63028: LD_INT 1
63030: NEG
63031: PUSH
63032: LD_INT 0
63034: PUSH
63035: EMPTY
63036: LIST
63037: LIST
63038: PUSH
63039: LD_INT 1
63041: NEG
63042: PUSH
63043: LD_INT 1
63045: NEG
63046: PUSH
63047: EMPTY
63048: LIST
63049: LIST
63050: PUSH
63051: LD_INT 1
63053: NEG
63054: PUSH
63055: LD_INT 2
63057: NEG
63058: PUSH
63059: EMPTY
63060: LIST
63061: LIST
63062: PUSH
63063: LD_INT 0
63065: PUSH
63066: LD_INT 2
63068: NEG
63069: PUSH
63070: EMPTY
63071: LIST
63072: LIST
63073: PUSH
63074: LD_INT 1
63076: PUSH
63077: LD_INT 1
63079: NEG
63080: PUSH
63081: EMPTY
63082: LIST
63083: LIST
63084: PUSH
63085: LD_INT 1
63087: PUSH
63088: LD_INT 2
63090: PUSH
63091: EMPTY
63092: LIST
63093: LIST
63094: PUSH
63095: LD_INT 0
63097: PUSH
63098: LD_INT 2
63100: PUSH
63101: EMPTY
63102: LIST
63103: LIST
63104: PUSH
63105: LD_INT 1
63107: NEG
63108: PUSH
63109: LD_INT 1
63111: PUSH
63112: EMPTY
63113: LIST
63114: LIST
63115: PUSH
63116: LD_INT 1
63118: PUSH
63119: LD_INT 3
63121: PUSH
63122: EMPTY
63123: LIST
63124: LIST
63125: PUSH
63126: LD_INT 0
63128: PUSH
63129: LD_INT 3
63131: PUSH
63132: EMPTY
63133: LIST
63134: LIST
63135: PUSH
63136: LD_INT 1
63138: NEG
63139: PUSH
63140: LD_INT 2
63142: PUSH
63143: EMPTY
63144: LIST
63145: LIST
63146: PUSH
63147: EMPTY
63148: LIST
63149: LIST
63150: LIST
63151: LIST
63152: LIST
63153: LIST
63154: LIST
63155: LIST
63156: LIST
63157: LIST
63158: LIST
63159: LIST
63160: LIST
63161: LIST
63162: LIST
63163: LIST
63164: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
63165: LD_ADDR_VAR 0 12
63169: PUSH
63170: LD_INT 0
63172: PUSH
63173: LD_INT 0
63175: PUSH
63176: EMPTY
63177: LIST
63178: LIST
63179: PUSH
63180: LD_INT 0
63182: PUSH
63183: LD_INT 1
63185: NEG
63186: PUSH
63187: EMPTY
63188: LIST
63189: LIST
63190: PUSH
63191: LD_INT 1
63193: PUSH
63194: LD_INT 0
63196: PUSH
63197: EMPTY
63198: LIST
63199: LIST
63200: PUSH
63201: LD_INT 1
63203: PUSH
63204: LD_INT 1
63206: PUSH
63207: EMPTY
63208: LIST
63209: LIST
63210: PUSH
63211: LD_INT 0
63213: PUSH
63214: LD_INT 1
63216: PUSH
63217: EMPTY
63218: LIST
63219: LIST
63220: PUSH
63221: LD_INT 1
63223: NEG
63224: PUSH
63225: LD_INT 0
63227: PUSH
63228: EMPTY
63229: LIST
63230: LIST
63231: PUSH
63232: LD_INT 1
63234: NEG
63235: PUSH
63236: LD_INT 1
63238: NEG
63239: PUSH
63240: EMPTY
63241: LIST
63242: LIST
63243: PUSH
63244: LD_INT 1
63246: PUSH
63247: LD_INT 1
63249: NEG
63250: PUSH
63251: EMPTY
63252: LIST
63253: LIST
63254: PUSH
63255: LD_INT 2
63257: PUSH
63258: LD_INT 0
63260: PUSH
63261: EMPTY
63262: LIST
63263: LIST
63264: PUSH
63265: LD_INT 2
63267: PUSH
63268: LD_INT 1
63270: PUSH
63271: EMPTY
63272: LIST
63273: LIST
63274: PUSH
63275: LD_INT 1
63277: NEG
63278: PUSH
63279: LD_INT 1
63281: PUSH
63282: EMPTY
63283: LIST
63284: LIST
63285: PUSH
63286: LD_INT 2
63288: NEG
63289: PUSH
63290: LD_INT 0
63292: PUSH
63293: EMPTY
63294: LIST
63295: LIST
63296: PUSH
63297: LD_INT 2
63299: NEG
63300: PUSH
63301: LD_INT 1
63303: NEG
63304: PUSH
63305: EMPTY
63306: LIST
63307: LIST
63308: PUSH
63309: LD_INT 2
63311: NEG
63312: PUSH
63313: LD_INT 1
63315: PUSH
63316: EMPTY
63317: LIST
63318: LIST
63319: PUSH
63320: LD_INT 3
63322: NEG
63323: PUSH
63324: LD_INT 0
63326: PUSH
63327: EMPTY
63328: LIST
63329: LIST
63330: PUSH
63331: LD_INT 3
63333: NEG
63334: PUSH
63335: LD_INT 1
63337: NEG
63338: PUSH
63339: EMPTY
63340: LIST
63341: LIST
63342: PUSH
63343: EMPTY
63344: LIST
63345: LIST
63346: LIST
63347: LIST
63348: LIST
63349: LIST
63350: LIST
63351: LIST
63352: LIST
63353: LIST
63354: LIST
63355: LIST
63356: LIST
63357: LIST
63358: LIST
63359: LIST
63360: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
63361: LD_ADDR_VAR 0 13
63365: PUSH
63366: LD_INT 0
63368: PUSH
63369: LD_INT 0
63371: PUSH
63372: EMPTY
63373: LIST
63374: LIST
63375: PUSH
63376: LD_INT 0
63378: PUSH
63379: LD_INT 1
63381: NEG
63382: PUSH
63383: EMPTY
63384: LIST
63385: LIST
63386: PUSH
63387: LD_INT 1
63389: PUSH
63390: LD_INT 0
63392: PUSH
63393: EMPTY
63394: LIST
63395: LIST
63396: PUSH
63397: LD_INT 1
63399: PUSH
63400: LD_INT 1
63402: PUSH
63403: EMPTY
63404: LIST
63405: LIST
63406: PUSH
63407: LD_INT 0
63409: PUSH
63410: LD_INT 1
63412: PUSH
63413: EMPTY
63414: LIST
63415: LIST
63416: PUSH
63417: LD_INT 1
63419: NEG
63420: PUSH
63421: LD_INT 0
63423: PUSH
63424: EMPTY
63425: LIST
63426: LIST
63427: PUSH
63428: LD_INT 1
63430: NEG
63431: PUSH
63432: LD_INT 1
63434: NEG
63435: PUSH
63436: EMPTY
63437: LIST
63438: LIST
63439: PUSH
63440: LD_INT 1
63442: NEG
63443: PUSH
63444: LD_INT 2
63446: NEG
63447: PUSH
63448: EMPTY
63449: LIST
63450: LIST
63451: PUSH
63452: LD_INT 2
63454: PUSH
63455: LD_INT 1
63457: PUSH
63458: EMPTY
63459: LIST
63460: LIST
63461: PUSH
63462: LD_INT 2
63464: PUSH
63465: LD_INT 2
63467: PUSH
63468: EMPTY
63469: LIST
63470: LIST
63471: PUSH
63472: LD_INT 1
63474: PUSH
63475: LD_INT 2
63477: PUSH
63478: EMPTY
63479: LIST
63480: LIST
63481: PUSH
63482: LD_INT 2
63484: NEG
63485: PUSH
63486: LD_INT 1
63488: NEG
63489: PUSH
63490: EMPTY
63491: LIST
63492: LIST
63493: PUSH
63494: LD_INT 2
63496: NEG
63497: PUSH
63498: LD_INT 2
63500: NEG
63501: PUSH
63502: EMPTY
63503: LIST
63504: LIST
63505: PUSH
63506: LD_INT 2
63508: NEG
63509: PUSH
63510: LD_INT 3
63512: NEG
63513: PUSH
63514: EMPTY
63515: LIST
63516: LIST
63517: PUSH
63518: LD_INT 3
63520: NEG
63521: PUSH
63522: LD_INT 2
63524: NEG
63525: PUSH
63526: EMPTY
63527: LIST
63528: LIST
63529: PUSH
63530: LD_INT 3
63532: NEG
63533: PUSH
63534: LD_INT 3
63536: NEG
63537: PUSH
63538: EMPTY
63539: LIST
63540: LIST
63541: PUSH
63542: EMPTY
63543: LIST
63544: LIST
63545: LIST
63546: LIST
63547: LIST
63548: LIST
63549: LIST
63550: LIST
63551: LIST
63552: LIST
63553: LIST
63554: LIST
63555: LIST
63556: LIST
63557: LIST
63558: LIST
63559: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
63560: LD_ADDR_VAR 0 14
63564: PUSH
63565: LD_INT 0
63567: PUSH
63568: LD_INT 0
63570: PUSH
63571: EMPTY
63572: LIST
63573: LIST
63574: PUSH
63575: LD_INT 0
63577: PUSH
63578: LD_INT 1
63580: NEG
63581: PUSH
63582: EMPTY
63583: LIST
63584: LIST
63585: PUSH
63586: LD_INT 1
63588: PUSH
63589: LD_INT 0
63591: PUSH
63592: EMPTY
63593: LIST
63594: LIST
63595: PUSH
63596: LD_INT 1
63598: PUSH
63599: LD_INT 1
63601: PUSH
63602: EMPTY
63603: LIST
63604: LIST
63605: PUSH
63606: LD_INT 0
63608: PUSH
63609: LD_INT 1
63611: PUSH
63612: EMPTY
63613: LIST
63614: LIST
63615: PUSH
63616: LD_INT 1
63618: NEG
63619: PUSH
63620: LD_INT 0
63622: PUSH
63623: EMPTY
63624: LIST
63625: LIST
63626: PUSH
63627: LD_INT 1
63629: NEG
63630: PUSH
63631: LD_INT 1
63633: NEG
63634: PUSH
63635: EMPTY
63636: LIST
63637: LIST
63638: PUSH
63639: LD_INT 1
63641: NEG
63642: PUSH
63643: LD_INT 2
63645: NEG
63646: PUSH
63647: EMPTY
63648: LIST
63649: LIST
63650: PUSH
63651: LD_INT 0
63653: PUSH
63654: LD_INT 2
63656: NEG
63657: PUSH
63658: EMPTY
63659: LIST
63660: LIST
63661: PUSH
63662: LD_INT 1
63664: PUSH
63665: LD_INT 1
63667: NEG
63668: PUSH
63669: EMPTY
63670: LIST
63671: LIST
63672: PUSH
63673: LD_INT 1
63675: PUSH
63676: LD_INT 2
63678: PUSH
63679: EMPTY
63680: LIST
63681: LIST
63682: PUSH
63683: LD_INT 0
63685: PUSH
63686: LD_INT 2
63688: PUSH
63689: EMPTY
63690: LIST
63691: LIST
63692: PUSH
63693: LD_INT 1
63695: NEG
63696: PUSH
63697: LD_INT 1
63699: PUSH
63700: EMPTY
63701: LIST
63702: LIST
63703: PUSH
63704: LD_INT 1
63706: NEG
63707: PUSH
63708: LD_INT 3
63710: NEG
63711: PUSH
63712: EMPTY
63713: LIST
63714: LIST
63715: PUSH
63716: LD_INT 0
63718: PUSH
63719: LD_INT 3
63721: NEG
63722: PUSH
63723: EMPTY
63724: LIST
63725: LIST
63726: PUSH
63727: LD_INT 1
63729: PUSH
63730: LD_INT 2
63732: NEG
63733: PUSH
63734: EMPTY
63735: LIST
63736: LIST
63737: PUSH
63738: EMPTY
63739: LIST
63740: LIST
63741: LIST
63742: LIST
63743: LIST
63744: LIST
63745: LIST
63746: LIST
63747: LIST
63748: LIST
63749: LIST
63750: LIST
63751: LIST
63752: LIST
63753: LIST
63754: LIST
63755: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
63756: LD_ADDR_VAR 0 15
63760: PUSH
63761: LD_INT 0
63763: PUSH
63764: LD_INT 0
63766: PUSH
63767: EMPTY
63768: LIST
63769: LIST
63770: PUSH
63771: LD_INT 0
63773: PUSH
63774: LD_INT 1
63776: NEG
63777: PUSH
63778: EMPTY
63779: LIST
63780: LIST
63781: PUSH
63782: LD_INT 1
63784: PUSH
63785: LD_INT 0
63787: PUSH
63788: EMPTY
63789: LIST
63790: LIST
63791: PUSH
63792: LD_INT 1
63794: PUSH
63795: LD_INT 1
63797: PUSH
63798: EMPTY
63799: LIST
63800: LIST
63801: PUSH
63802: LD_INT 0
63804: PUSH
63805: LD_INT 1
63807: PUSH
63808: EMPTY
63809: LIST
63810: LIST
63811: PUSH
63812: LD_INT 1
63814: NEG
63815: PUSH
63816: LD_INT 0
63818: PUSH
63819: EMPTY
63820: LIST
63821: LIST
63822: PUSH
63823: LD_INT 1
63825: NEG
63826: PUSH
63827: LD_INT 1
63829: NEG
63830: PUSH
63831: EMPTY
63832: LIST
63833: LIST
63834: PUSH
63835: LD_INT 1
63837: PUSH
63838: LD_INT 1
63840: NEG
63841: PUSH
63842: EMPTY
63843: LIST
63844: LIST
63845: PUSH
63846: LD_INT 2
63848: PUSH
63849: LD_INT 0
63851: PUSH
63852: EMPTY
63853: LIST
63854: LIST
63855: PUSH
63856: LD_INT 2
63858: PUSH
63859: LD_INT 1
63861: PUSH
63862: EMPTY
63863: LIST
63864: LIST
63865: PUSH
63866: LD_INT 1
63868: NEG
63869: PUSH
63870: LD_INT 1
63872: PUSH
63873: EMPTY
63874: LIST
63875: LIST
63876: PUSH
63877: LD_INT 2
63879: NEG
63880: PUSH
63881: LD_INT 0
63883: PUSH
63884: EMPTY
63885: LIST
63886: LIST
63887: PUSH
63888: LD_INT 2
63890: NEG
63891: PUSH
63892: LD_INT 1
63894: NEG
63895: PUSH
63896: EMPTY
63897: LIST
63898: LIST
63899: PUSH
63900: LD_INT 2
63902: PUSH
63903: LD_INT 1
63905: NEG
63906: PUSH
63907: EMPTY
63908: LIST
63909: LIST
63910: PUSH
63911: LD_INT 3
63913: PUSH
63914: LD_INT 0
63916: PUSH
63917: EMPTY
63918: LIST
63919: LIST
63920: PUSH
63921: LD_INT 3
63923: PUSH
63924: LD_INT 1
63926: PUSH
63927: EMPTY
63928: LIST
63929: LIST
63930: PUSH
63931: EMPTY
63932: LIST
63933: LIST
63934: LIST
63935: LIST
63936: LIST
63937: LIST
63938: LIST
63939: LIST
63940: LIST
63941: LIST
63942: LIST
63943: LIST
63944: LIST
63945: LIST
63946: LIST
63947: LIST
63948: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
63949: LD_ADDR_VAR 0 16
63953: PUSH
63954: LD_INT 0
63956: PUSH
63957: LD_INT 0
63959: PUSH
63960: EMPTY
63961: LIST
63962: LIST
63963: PUSH
63964: LD_INT 0
63966: PUSH
63967: LD_INT 1
63969: NEG
63970: PUSH
63971: EMPTY
63972: LIST
63973: LIST
63974: PUSH
63975: LD_INT 1
63977: PUSH
63978: LD_INT 0
63980: PUSH
63981: EMPTY
63982: LIST
63983: LIST
63984: PUSH
63985: LD_INT 1
63987: PUSH
63988: LD_INT 1
63990: PUSH
63991: EMPTY
63992: LIST
63993: LIST
63994: PUSH
63995: LD_INT 0
63997: PUSH
63998: LD_INT 1
64000: PUSH
64001: EMPTY
64002: LIST
64003: LIST
64004: PUSH
64005: LD_INT 1
64007: NEG
64008: PUSH
64009: LD_INT 0
64011: PUSH
64012: EMPTY
64013: LIST
64014: LIST
64015: PUSH
64016: LD_INT 1
64018: NEG
64019: PUSH
64020: LD_INT 1
64022: NEG
64023: PUSH
64024: EMPTY
64025: LIST
64026: LIST
64027: PUSH
64028: LD_INT 1
64030: NEG
64031: PUSH
64032: LD_INT 2
64034: NEG
64035: PUSH
64036: EMPTY
64037: LIST
64038: LIST
64039: PUSH
64040: LD_INT 2
64042: PUSH
64043: LD_INT 1
64045: PUSH
64046: EMPTY
64047: LIST
64048: LIST
64049: PUSH
64050: LD_INT 2
64052: PUSH
64053: LD_INT 2
64055: PUSH
64056: EMPTY
64057: LIST
64058: LIST
64059: PUSH
64060: LD_INT 1
64062: PUSH
64063: LD_INT 2
64065: PUSH
64066: EMPTY
64067: LIST
64068: LIST
64069: PUSH
64070: LD_INT 2
64072: NEG
64073: PUSH
64074: LD_INT 1
64076: NEG
64077: PUSH
64078: EMPTY
64079: LIST
64080: LIST
64081: PUSH
64082: LD_INT 2
64084: NEG
64085: PUSH
64086: LD_INT 2
64088: NEG
64089: PUSH
64090: EMPTY
64091: LIST
64092: LIST
64093: PUSH
64094: LD_INT 3
64096: PUSH
64097: LD_INT 2
64099: PUSH
64100: EMPTY
64101: LIST
64102: LIST
64103: PUSH
64104: LD_INT 3
64106: PUSH
64107: LD_INT 3
64109: PUSH
64110: EMPTY
64111: LIST
64112: LIST
64113: PUSH
64114: LD_INT 2
64116: PUSH
64117: LD_INT 3
64119: PUSH
64120: EMPTY
64121: LIST
64122: LIST
64123: PUSH
64124: EMPTY
64125: LIST
64126: LIST
64127: LIST
64128: LIST
64129: LIST
64130: LIST
64131: LIST
64132: LIST
64133: LIST
64134: LIST
64135: LIST
64136: LIST
64137: LIST
64138: LIST
64139: LIST
64140: LIST
64141: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64142: LD_ADDR_VAR 0 17
64146: PUSH
64147: LD_INT 0
64149: PUSH
64150: LD_INT 0
64152: PUSH
64153: EMPTY
64154: LIST
64155: LIST
64156: PUSH
64157: LD_INT 0
64159: PUSH
64160: LD_INT 1
64162: NEG
64163: PUSH
64164: EMPTY
64165: LIST
64166: LIST
64167: PUSH
64168: LD_INT 1
64170: PUSH
64171: LD_INT 0
64173: PUSH
64174: EMPTY
64175: LIST
64176: LIST
64177: PUSH
64178: LD_INT 1
64180: PUSH
64181: LD_INT 1
64183: PUSH
64184: EMPTY
64185: LIST
64186: LIST
64187: PUSH
64188: LD_INT 0
64190: PUSH
64191: LD_INT 1
64193: PUSH
64194: EMPTY
64195: LIST
64196: LIST
64197: PUSH
64198: LD_INT 1
64200: NEG
64201: PUSH
64202: LD_INT 0
64204: PUSH
64205: EMPTY
64206: LIST
64207: LIST
64208: PUSH
64209: LD_INT 1
64211: NEG
64212: PUSH
64213: LD_INT 1
64215: NEG
64216: PUSH
64217: EMPTY
64218: LIST
64219: LIST
64220: PUSH
64221: LD_INT 1
64223: NEG
64224: PUSH
64225: LD_INT 2
64227: NEG
64228: PUSH
64229: EMPTY
64230: LIST
64231: LIST
64232: PUSH
64233: LD_INT 0
64235: PUSH
64236: LD_INT 2
64238: NEG
64239: PUSH
64240: EMPTY
64241: LIST
64242: LIST
64243: PUSH
64244: LD_INT 1
64246: PUSH
64247: LD_INT 1
64249: NEG
64250: PUSH
64251: EMPTY
64252: LIST
64253: LIST
64254: PUSH
64255: LD_INT 2
64257: PUSH
64258: LD_INT 0
64260: PUSH
64261: EMPTY
64262: LIST
64263: LIST
64264: PUSH
64265: LD_INT 2
64267: PUSH
64268: LD_INT 1
64270: PUSH
64271: EMPTY
64272: LIST
64273: LIST
64274: PUSH
64275: LD_INT 2
64277: PUSH
64278: LD_INT 2
64280: PUSH
64281: EMPTY
64282: LIST
64283: LIST
64284: PUSH
64285: LD_INT 1
64287: PUSH
64288: LD_INT 2
64290: PUSH
64291: EMPTY
64292: LIST
64293: LIST
64294: PUSH
64295: LD_INT 0
64297: PUSH
64298: LD_INT 2
64300: PUSH
64301: EMPTY
64302: LIST
64303: LIST
64304: PUSH
64305: LD_INT 1
64307: NEG
64308: PUSH
64309: LD_INT 1
64311: PUSH
64312: EMPTY
64313: LIST
64314: LIST
64315: PUSH
64316: LD_INT 2
64318: NEG
64319: PUSH
64320: LD_INT 0
64322: PUSH
64323: EMPTY
64324: LIST
64325: LIST
64326: PUSH
64327: LD_INT 2
64329: NEG
64330: PUSH
64331: LD_INT 1
64333: NEG
64334: PUSH
64335: EMPTY
64336: LIST
64337: LIST
64338: PUSH
64339: LD_INT 2
64341: NEG
64342: PUSH
64343: LD_INT 2
64345: NEG
64346: PUSH
64347: EMPTY
64348: LIST
64349: LIST
64350: PUSH
64351: EMPTY
64352: LIST
64353: LIST
64354: LIST
64355: LIST
64356: LIST
64357: LIST
64358: LIST
64359: LIST
64360: LIST
64361: LIST
64362: LIST
64363: LIST
64364: LIST
64365: LIST
64366: LIST
64367: LIST
64368: LIST
64369: LIST
64370: LIST
64371: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64372: LD_ADDR_VAR 0 18
64376: PUSH
64377: LD_INT 0
64379: PUSH
64380: LD_INT 0
64382: PUSH
64383: EMPTY
64384: LIST
64385: LIST
64386: PUSH
64387: LD_INT 0
64389: PUSH
64390: LD_INT 1
64392: NEG
64393: PUSH
64394: EMPTY
64395: LIST
64396: LIST
64397: PUSH
64398: LD_INT 1
64400: PUSH
64401: LD_INT 0
64403: PUSH
64404: EMPTY
64405: LIST
64406: LIST
64407: PUSH
64408: LD_INT 1
64410: PUSH
64411: LD_INT 1
64413: PUSH
64414: EMPTY
64415: LIST
64416: LIST
64417: PUSH
64418: LD_INT 0
64420: PUSH
64421: LD_INT 1
64423: PUSH
64424: EMPTY
64425: LIST
64426: LIST
64427: PUSH
64428: LD_INT 1
64430: NEG
64431: PUSH
64432: LD_INT 0
64434: PUSH
64435: EMPTY
64436: LIST
64437: LIST
64438: PUSH
64439: LD_INT 1
64441: NEG
64442: PUSH
64443: LD_INT 1
64445: NEG
64446: PUSH
64447: EMPTY
64448: LIST
64449: LIST
64450: PUSH
64451: LD_INT 1
64453: NEG
64454: PUSH
64455: LD_INT 2
64457: NEG
64458: PUSH
64459: EMPTY
64460: LIST
64461: LIST
64462: PUSH
64463: LD_INT 0
64465: PUSH
64466: LD_INT 2
64468: NEG
64469: PUSH
64470: EMPTY
64471: LIST
64472: LIST
64473: PUSH
64474: LD_INT 1
64476: PUSH
64477: LD_INT 1
64479: NEG
64480: PUSH
64481: EMPTY
64482: LIST
64483: LIST
64484: PUSH
64485: LD_INT 2
64487: PUSH
64488: LD_INT 0
64490: PUSH
64491: EMPTY
64492: LIST
64493: LIST
64494: PUSH
64495: LD_INT 2
64497: PUSH
64498: LD_INT 1
64500: PUSH
64501: EMPTY
64502: LIST
64503: LIST
64504: PUSH
64505: LD_INT 2
64507: PUSH
64508: LD_INT 2
64510: PUSH
64511: EMPTY
64512: LIST
64513: LIST
64514: PUSH
64515: LD_INT 1
64517: PUSH
64518: LD_INT 2
64520: PUSH
64521: EMPTY
64522: LIST
64523: LIST
64524: PUSH
64525: LD_INT 0
64527: PUSH
64528: LD_INT 2
64530: PUSH
64531: EMPTY
64532: LIST
64533: LIST
64534: PUSH
64535: LD_INT 1
64537: NEG
64538: PUSH
64539: LD_INT 1
64541: PUSH
64542: EMPTY
64543: LIST
64544: LIST
64545: PUSH
64546: LD_INT 2
64548: NEG
64549: PUSH
64550: LD_INT 0
64552: PUSH
64553: EMPTY
64554: LIST
64555: LIST
64556: PUSH
64557: LD_INT 2
64559: NEG
64560: PUSH
64561: LD_INT 1
64563: NEG
64564: PUSH
64565: EMPTY
64566: LIST
64567: LIST
64568: PUSH
64569: LD_INT 2
64571: NEG
64572: PUSH
64573: LD_INT 2
64575: NEG
64576: PUSH
64577: EMPTY
64578: LIST
64579: LIST
64580: PUSH
64581: EMPTY
64582: LIST
64583: LIST
64584: LIST
64585: LIST
64586: LIST
64587: LIST
64588: LIST
64589: LIST
64590: LIST
64591: LIST
64592: LIST
64593: LIST
64594: LIST
64595: LIST
64596: LIST
64597: LIST
64598: LIST
64599: LIST
64600: LIST
64601: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64602: LD_ADDR_VAR 0 19
64606: PUSH
64607: LD_INT 0
64609: PUSH
64610: LD_INT 0
64612: PUSH
64613: EMPTY
64614: LIST
64615: LIST
64616: PUSH
64617: LD_INT 0
64619: PUSH
64620: LD_INT 1
64622: NEG
64623: PUSH
64624: EMPTY
64625: LIST
64626: LIST
64627: PUSH
64628: LD_INT 1
64630: PUSH
64631: LD_INT 0
64633: PUSH
64634: EMPTY
64635: LIST
64636: LIST
64637: PUSH
64638: LD_INT 1
64640: PUSH
64641: LD_INT 1
64643: PUSH
64644: EMPTY
64645: LIST
64646: LIST
64647: PUSH
64648: LD_INT 0
64650: PUSH
64651: LD_INT 1
64653: PUSH
64654: EMPTY
64655: LIST
64656: LIST
64657: PUSH
64658: LD_INT 1
64660: NEG
64661: PUSH
64662: LD_INT 0
64664: PUSH
64665: EMPTY
64666: LIST
64667: LIST
64668: PUSH
64669: LD_INT 1
64671: NEG
64672: PUSH
64673: LD_INT 1
64675: NEG
64676: PUSH
64677: EMPTY
64678: LIST
64679: LIST
64680: PUSH
64681: LD_INT 1
64683: NEG
64684: PUSH
64685: LD_INT 2
64687: NEG
64688: PUSH
64689: EMPTY
64690: LIST
64691: LIST
64692: PUSH
64693: LD_INT 0
64695: PUSH
64696: LD_INT 2
64698: NEG
64699: PUSH
64700: EMPTY
64701: LIST
64702: LIST
64703: PUSH
64704: LD_INT 1
64706: PUSH
64707: LD_INT 1
64709: NEG
64710: PUSH
64711: EMPTY
64712: LIST
64713: LIST
64714: PUSH
64715: LD_INT 2
64717: PUSH
64718: LD_INT 0
64720: PUSH
64721: EMPTY
64722: LIST
64723: LIST
64724: PUSH
64725: LD_INT 2
64727: PUSH
64728: LD_INT 1
64730: PUSH
64731: EMPTY
64732: LIST
64733: LIST
64734: PUSH
64735: LD_INT 2
64737: PUSH
64738: LD_INT 2
64740: PUSH
64741: EMPTY
64742: LIST
64743: LIST
64744: PUSH
64745: LD_INT 1
64747: PUSH
64748: LD_INT 2
64750: PUSH
64751: EMPTY
64752: LIST
64753: LIST
64754: PUSH
64755: LD_INT 0
64757: PUSH
64758: LD_INT 2
64760: PUSH
64761: EMPTY
64762: LIST
64763: LIST
64764: PUSH
64765: LD_INT 1
64767: NEG
64768: PUSH
64769: LD_INT 1
64771: PUSH
64772: EMPTY
64773: LIST
64774: LIST
64775: PUSH
64776: LD_INT 2
64778: NEG
64779: PUSH
64780: LD_INT 0
64782: PUSH
64783: EMPTY
64784: LIST
64785: LIST
64786: PUSH
64787: LD_INT 2
64789: NEG
64790: PUSH
64791: LD_INT 1
64793: NEG
64794: PUSH
64795: EMPTY
64796: LIST
64797: LIST
64798: PUSH
64799: LD_INT 2
64801: NEG
64802: PUSH
64803: LD_INT 2
64805: NEG
64806: PUSH
64807: EMPTY
64808: LIST
64809: LIST
64810: PUSH
64811: EMPTY
64812: LIST
64813: LIST
64814: LIST
64815: LIST
64816: LIST
64817: LIST
64818: LIST
64819: LIST
64820: LIST
64821: LIST
64822: LIST
64823: LIST
64824: LIST
64825: LIST
64826: LIST
64827: LIST
64828: LIST
64829: LIST
64830: LIST
64831: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64832: LD_ADDR_VAR 0 20
64836: PUSH
64837: LD_INT 0
64839: PUSH
64840: LD_INT 0
64842: PUSH
64843: EMPTY
64844: LIST
64845: LIST
64846: PUSH
64847: LD_INT 0
64849: PUSH
64850: LD_INT 1
64852: NEG
64853: PUSH
64854: EMPTY
64855: LIST
64856: LIST
64857: PUSH
64858: LD_INT 1
64860: PUSH
64861: LD_INT 0
64863: PUSH
64864: EMPTY
64865: LIST
64866: LIST
64867: PUSH
64868: LD_INT 1
64870: PUSH
64871: LD_INT 1
64873: PUSH
64874: EMPTY
64875: LIST
64876: LIST
64877: PUSH
64878: LD_INT 0
64880: PUSH
64881: LD_INT 1
64883: PUSH
64884: EMPTY
64885: LIST
64886: LIST
64887: PUSH
64888: LD_INT 1
64890: NEG
64891: PUSH
64892: LD_INT 0
64894: PUSH
64895: EMPTY
64896: LIST
64897: LIST
64898: PUSH
64899: LD_INT 1
64901: NEG
64902: PUSH
64903: LD_INT 1
64905: NEG
64906: PUSH
64907: EMPTY
64908: LIST
64909: LIST
64910: PUSH
64911: LD_INT 1
64913: NEG
64914: PUSH
64915: LD_INT 2
64917: NEG
64918: PUSH
64919: EMPTY
64920: LIST
64921: LIST
64922: PUSH
64923: LD_INT 0
64925: PUSH
64926: LD_INT 2
64928: NEG
64929: PUSH
64930: EMPTY
64931: LIST
64932: LIST
64933: PUSH
64934: LD_INT 1
64936: PUSH
64937: LD_INT 1
64939: NEG
64940: PUSH
64941: EMPTY
64942: LIST
64943: LIST
64944: PUSH
64945: LD_INT 2
64947: PUSH
64948: LD_INT 0
64950: PUSH
64951: EMPTY
64952: LIST
64953: LIST
64954: PUSH
64955: LD_INT 2
64957: PUSH
64958: LD_INT 1
64960: PUSH
64961: EMPTY
64962: LIST
64963: LIST
64964: PUSH
64965: LD_INT 2
64967: PUSH
64968: LD_INT 2
64970: PUSH
64971: EMPTY
64972: LIST
64973: LIST
64974: PUSH
64975: LD_INT 1
64977: PUSH
64978: LD_INT 2
64980: PUSH
64981: EMPTY
64982: LIST
64983: LIST
64984: PUSH
64985: LD_INT 0
64987: PUSH
64988: LD_INT 2
64990: PUSH
64991: EMPTY
64992: LIST
64993: LIST
64994: PUSH
64995: LD_INT 1
64997: NEG
64998: PUSH
64999: LD_INT 1
65001: PUSH
65002: EMPTY
65003: LIST
65004: LIST
65005: PUSH
65006: LD_INT 2
65008: NEG
65009: PUSH
65010: LD_INT 0
65012: PUSH
65013: EMPTY
65014: LIST
65015: LIST
65016: PUSH
65017: LD_INT 2
65019: NEG
65020: PUSH
65021: LD_INT 1
65023: NEG
65024: PUSH
65025: EMPTY
65026: LIST
65027: LIST
65028: PUSH
65029: LD_INT 2
65031: NEG
65032: PUSH
65033: LD_INT 2
65035: NEG
65036: PUSH
65037: EMPTY
65038: LIST
65039: LIST
65040: PUSH
65041: EMPTY
65042: LIST
65043: LIST
65044: LIST
65045: LIST
65046: LIST
65047: LIST
65048: LIST
65049: LIST
65050: LIST
65051: LIST
65052: LIST
65053: LIST
65054: LIST
65055: LIST
65056: LIST
65057: LIST
65058: LIST
65059: LIST
65060: LIST
65061: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65062: LD_ADDR_VAR 0 21
65066: PUSH
65067: LD_INT 0
65069: PUSH
65070: LD_INT 0
65072: PUSH
65073: EMPTY
65074: LIST
65075: LIST
65076: PUSH
65077: LD_INT 0
65079: PUSH
65080: LD_INT 1
65082: NEG
65083: PUSH
65084: EMPTY
65085: LIST
65086: LIST
65087: PUSH
65088: LD_INT 1
65090: PUSH
65091: LD_INT 0
65093: PUSH
65094: EMPTY
65095: LIST
65096: LIST
65097: PUSH
65098: LD_INT 1
65100: PUSH
65101: LD_INT 1
65103: PUSH
65104: EMPTY
65105: LIST
65106: LIST
65107: PUSH
65108: LD_INT 0
65110: PUSH
65111: LD_INT 1
65113: PUSH
65114: EMPTY
65115: LIST
65116: LIST
65117: PUSH
65118: LD_INT 1
65120: NEG
65121: PUSH
65122: LD_INT 0
65124: PUSH
65125: EMPTY
65126: LIST
65127: LIST
65128: PUSH
65129: LD_INT 1
65131: NEG
65132: PUSH
65133: LD_INT 1
65135: NEG
65136: PUSH
65137: EMPTY
65138: LIST
65139: LIST
65140: PUSH
65141: LD_INT 1
65143: NEG
65144: PUSH
65145: LD_INT 2
65147: NEG
65148: PUSH
65149: EMPTY
65150: LIST
65151: LIST
65152: PUSH
65153: LD_INT 0
65155: PUSH
65156: LD_INT 2
65158: NEG
65159: PUSH
65160: EMPTY
65161: LIST
65162: LIST
65163: PUSH
65164: LD_INT 1
65166: PUSH
65167: LD_INT 1
65169: NEG
65170: PUSH
65171: EMPTY
65172: LIST
65173: LIST
65174: PUSH
65175: LD_INT 2
65177: PUSH
65178: LD_INT 0
65180: PUSH
65181: EMPTY
65182: LIST
65183: LIST
65184: PUSH
65185: LD_INT 2
65187: PUSH
65188: LD_INT 1
65190: PUSH
65191: EMPTY
65192: LIST
65193: LIST
65194: PUSH
65195: LD_INT 2
65197: PUSH
65198: LD_INT 2
65200: PUSH
65201: EMPTY
65202: LIST
65203: LIST
65204: PUSH
65205: LD_INT 1
65207: PUSH
65208: LD_INT 2
65210: PUSH
65211: EMPTY
65212: LIST
65213: LIST
65214: PUSH
65215: LD_INT 0
65217: PUSH
65218: LD_INT 2
65220: PUSH
65221: EMPTY
65222: LIST
65223: LIST
65224: PUSH
65225: LD_INT 1
65227: NEG
65228: PUSH
65229: LD_INT 1
65231: PUSH
65232: EMPTY
65233: LIST
65234: LIST
65235: PUSH
65236: LD_INT 2
65238: NEG
65239: PUSH
65240: LD_INT 0
65242: PUSH
65243: EMPTY
65244: LIST
65245: LIST
65246: PUSH
65247: LD_INT 2
65249: NEG
65250: PUSH
65251: LD_INT 1
65253: NEG
65254: PUSH
65255: EMPTY
65256: LIST
65257: LIST
65258: PUSH
65259: LD_INT 2
65261: NEG
65262: PUSH
65263: LD_INT 2
65265: NEG
65266: PUSH
65267: EMPTY
65268: LIST
65269: LIST
65270: PUSH
65271: EMPTY
65272: LIST
65273: LIST
65274: LIST
65275: LIST
65276: LIST
65277: LIST
65278: LIST
65279: LIST
65280: LIST
65281: LIST
65282: LIST
65283: LIST
65284: LIST
65285: LIST
65286: LIST
65287: LIST
65288: LIST
65289: LIST
65290: LIST
65291: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65292: LD_ADDR_VAR 0 22
65296: PUSH
65297: LD_INT 0
65299: PUSH
65300: LD_INT 0
65302: PUSH
65303: EMPTY
65304: LIST
65305: LIST
65306: PUSH
65307: LD_INT 0
65309: PUSH
65310: LD_INT 1
65312: NEG
65313: PUSH
65314: EMPTY
65315: LIST
65316: LIST
65317: PUSH
65318: LD_INT 1
65320: PUSH
65321: LD_INT 0
65323: PUSH
65324: EMPTY
65325: LIST
65326: LIST
65327: PUSH
65328: LD_INT 1
65330: PUSH
65331: LD_INT 1
65333: PUSH
65334: EMPTY
65335: LIST
65336: LIST
65337: PUSH
65338: LD_INT 0
65340: PUSH
65341: LD_INT 1
65343: PUSH
65344: EMPTY
65345: LIST
65346: LIST
65347: PUSH
65348: LD_INT 1
65350: NEG
65351: PUSH
65352: LD_INT 0
65354: PUSH
65355: EMPTY
65356: LIST
65357: LIST
65358: PUSH
65359: LD_INT 1
65361: NEG
65362: PUSH
65363: LD_INT 1
65365: NEG
65366: PUSH
65367: EMPTY
65368: LIST
65369: LIST
65370: PUSH
65371: LD_INT 1
65373: NEG
65374: PUSH
65375: LD_INT 2
65377: NEG
65378: PUSH
65379: EMPTY
65380: LIST
65381: LIST
65382: PUSH
65383: LD_INT 0
65385: PUSH
65386: LD_INT 2
65388: NEG
65389: PUSH
65390: EMPTY
65391: LIST
65392: LIST
65393: PUSH
65394: LD_INT 1
65396: PUSH
65397: LD_INT 1
65399: NEG
65400: PUSH
65401: EMPTY
65402: LIST
65403: LIST
65404: PUSH
65405: LD_INT 2
65407: PUSH
65408: LD_INT 0
65410: PUSH
65411: EMPTY
65412: LIST
65413: LIST
65414: PUSH
65415: LD_INT 2
65417: PUSH
65418: LD_INT 1
65420: PUSH
65421: EMPTY
65422: LIST
65423: LIST
65424: PUSH
65425: LD_INT 2
65427: PUSH
65428: LD_INT 2
65430: PUSH
65431: EMPTY
65432: LIST
65433: LIST
65434: PUSH
65435: LD_INT 1
65437: PUSH
65438: LD_INT 2
65440: PUSH
65441: EMPTY
65442: LIST
65443: LIST
65444: PUSH
65445: LD_INT 0
65447: PUSH
65448: LD_INT 2
65450: PUSH
65451: EMPTY
65452: LIST
65453: LIST
65454: PUSH
65455: LD_INT 1
65457: NEG
65458: PUSH
65459: LD_INT 1
65461: PUSH
65462: EMPTY
65463: LIST
65464: LIST
65465: PUSH
65466: LD_INT 2
65468: NEG
65469: PUSH
65470: LD_INT 0
65472: PUSH
65473: EMPTY
65474: LIST
65475: LIST
65476: PUSH
65477: LD_INT 2
65479: NEG
65480: PUSH
65481: LD_INT 1
65483: NEG
65484: PUSH
65485: EMPTY
65486: LIST
65487: LIST
65488: PUSH
65489: LD_INT 2
65491: NEG
65492: PUSH
65493: LD_INT 2
65495: NEG
65496: PUSH
65497: EMPTY
65498: LIST
65499: LIST
65500: PUSH
65501: EMPTY
65502: LIST
65503: LIST
65504: LIST
65505: LIST
65506: LIST
65507: LIST
65508: LIST
65509: LIST
65510: LIST
65511: LIST
65512: LIST
65513: LIST
65514: LIST
65515: LIST
65516: LIST
65517: LIST
65518: LIST
65519: LIST
65520: LIST
65521: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
65522: LD_ADDR_VAR 0 23
65526: PUSH
65527: LD_INT 0
65529: PUSH
65530: LD_INT 0
65532: PUSH
65533: EMPTY
65534: LIST
65535: LIST
65536: PUSH
65537: LD_INT 0
65539: PUSH
65540: LD_INT 1
65542: NEG
65543: PUSH
65544: EMPTY
65545: LIST
65546: LIST
65547: PUSH
65548: LD_INT 1
65550: PUSH
65551: LD_INT 0
65553: PUSH
65554: EMPTY
65555: LIST
65556: LIST
65557: PUSH
65558: LD_INT 1
65560: PUSH
65561: LD_INT 1
65563: PUSH
65564: EMPTY
65565: LIST
65566: LIST
65567: PUSH
65568: LD_INT 0
65570: PUSH
65571: LD_INT 1
65573: PUSH
65574: EMPTY
65575: LIST
65576: LIST
65577: PUSH
65578: LD_INT 1
65580: NEG
65581: PUSH
65582: LD_INT 0
65584: PUSH
65585: EMPTY
65586: LIST
65587: LIST
65588: PUSH
65589: LD_INT 1
65591: NEG
65592: PUSH
65593: LD_INT 1
65595: NEG
65596: PUSH
65597: EMPTY
65598: LIST
65599: LIST
65600: PUSH
65601: LD_INT 1
65603: NEG
65604: PUSH
65605: LD_INT 2
65607: NEG
65608: PUSH
65609: EMPTY
65610: LIST
65611: LIST
65612: PUSH
65613: LD_INT 0
65615: PUSH
65616: LD_INT 2
65618: NEG
65619: PUSH
65620: EMPTY
65621: LIST
65622: LIST
65623: PUSH
65624: LD_INT 1
65626: PUSH
65627: LD_INT 1
65629: NEG
65630: PUSH
65631: EMPTY
65632: LIST
65633: LIST
65634: PUSH
65635: LD_INT 2
65637: PUSH
65638: LD_INT 0
65640: PUSH
65641: EMPTY
65642: LIST
65643: LIST
65644: PUSH
65645: LD_INT 2
65647: PUSH
65648: LD_INT 1
65650: PUSH
65651: EMPTY
65652: LIST
65653: LIST
65654: PUSH
65655: LD_INT 2
65657: PUSH
65658: LD_INT 2
65660: PUSH
65661: EMPTY
65662: LIST
65663: LIST
65664: PUSH
65665: LD_INT 1
65667: PUSH
65668: LD_INT 2
65670: PUSH
65671: EMPTY
65672: LIST
65673: LIST
65674: PUSH
65675: LD_INT 0
65677: PUSH
65678: LD_INT 2
65680: PUSH
65681: EMPTY
65682: LIST
65683: LIST
65684: PUSH
65685: LD_INT 1
65687: NEG
65688: PUSH
65689: LD_INT 1
65691: PUSH
65692: EMPTY
65693: LIST
65694: LIST
65695: PUSH
65696: LD_INT 2
65698: NEG
65699: PUSH
65700: LD_INT 0
65702: PUSH
65703: EMPTY
65704: LIST
65705: LIST
65706: PUSH
65707: LD_INT 2
65709: NEG
65710: PUSH
65711: LD_INT 1
65713: NEG
65714: PUSH
65715: EMPTY
65716: LIST
65717: LIST
65718: PUSH
65719: LD_INT 2
65721: NEG
65722: PUSH
65723: LD_INT 2
65725: NEG
65726: PUSH
65727: EMPTY
65728: LIST
65729: LIST
65730: PUSH
65731: LD_INT 2
65733: NEG
65734: PUSH
65735: LD_INT 3
65737: NEG
65738: PUSH
65739: EMPTY
65740: LIST
65741: LIST
65742: PUSH
65743: LD_INT 1
65745: NEG
65746: PUSH
65747: LD_INT 3
65749: NEG
65750: PUSH
65751: EMPTY
65752: LIST
65753: LIST
65754: PUSH
65755: LD_INT 1
65757: PUSH
65758: LD_INT 2
65760: NEG
65761: PUSH
65762: EMPTY
65763: LIST
65764: LIST
65765: PUSH
65766: LD_INT 2
65768: PUSH
65769: LD_INT 1
65771: NEG
65772: PUSH
65773: EMPTY
65774: LIST
65775: LIST
65776: PUSH
65777: EMPTY
65778: LIST
65779: LIST
65780: LIST
65781: LIST
65782: LIST
65783: LIST
65784: LIST
65785: LIST
65786: LIST
65787: LIST
65788: LIST
65789: LIST
65790: LIST
65791: LIST
65792: LIST
65793: LIST
65794: LIST
65795: LIST
65796: LIST
65797: LIST
65798: LIST
65799: LIST
65800: LIST
65801: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
65802: LD_ADDR_VAR 0 24
65806: PUSH
65807: LD_INT 0
65809: PUSH
65810: LD_INT 0
65812: PUSH
65813: EMPTY
65814: LIST
65815: LIST
65816: PUSH
65817: LD_INT 0
65819: PUSH
65820: LD_INT 1
65822: NEG
65823: PUSH
65824: EMPTY
65825: LIST
65826: LIST
65827: PUSH
65828: LD_INT 1
65830: PUSH
65831: LD_INT 0
65833: PUSH
65834: EMPTY
65835: LIST
65836: LIST
65837: PUSH
65838: LD_INT 1
65840: PUSH
65841: LD_INT 1
65843: PUSH
65844: EMPTY
65845: LIST
65846: LIST
65847: PUSH
65848: LD_INT 0
65850: PUSH
65851: LD_INT 1
65853: PUSH
65854: EMPTY
65855: LIST
65856: LIST
65857: PUSH
65858: LD_INT 1
65860: NEG
65861: PUSH
65862: LD_INT 0
65864: PUSH
65865: EMPTY
65866: LIST
65867: LIST
65868: PUSH
65869: LD_INT 1
65871: NEG
65872: PUSH
65873: LD_INT 1
65875: NEG
65876: PUSH
65877: EMPTY
65878: LIST
65879: LIST
65880: PUSH
65881: LD_INT 1
65883: NEG
65884: PUSH
65885: LD_INT 2
65887: NEG
65888: PUSH
65889: EMPTY
65890: LIST
65891: LIST
65892: PUSH
65893: LD_INT 0
65895: PUSH
65896: LD_INT 2
65898: NEG
65899: PUSH
65900: EMPTY
65901: LIST
65902: LIST
65903: PUSH
65904: LD_INT 1
65906: PUSH
65907: LD_INT 1
65909: NEG
65910: PUSH
65911: EMPTY
65912: LIST
65913: LIST
65914: PUSH
65915: LD_INT 2
65917: PUSH
65918: LD_INT 0
65920: PUSH
65921: EMPTY
65922: LIST
65923: LIST
65924: PUSH
65925: LD_INT 2
65927: PUSH
65928: LD_INT 1
65930: PUSH
65931: EMPTY
65932: LIST
65933: LIST
65934: PUSH
65935: LD_INT 2
65937: PUSH
65938: LD_INT 2
65940: PUSH
65941: EMPTY
65942: LIST
65943: LIST
65944: PUSH
65945: LD_INT 1
65947: PUSH
65948: LD_INT 2
65950: PUSH
65951: EMPTY
65952: LIST
65953: LIST
65954: PUSH
65955: LD_INT 0
65957: PUSH
65958: LD_INT 2
65960: PUSH
65961: EMPTY
65962: LIST
65963: LIST
65964: PUSH
65965: LD_INT 1
65967: NEG
65968: PUSH
65969: LD_INT 1
65971: PUSH
65972: EMPTY
65973: LIST
65974: LIST
65975: PUSH
65976: LD_INT 2
65978: NEG
65979: PUSH
65980: LD_INT 0
65982: PUSH
65983: EMPTY
65984: LIST
65985: LIST
65986: PUSH
65987: LD_INT 2
65989: NEG
65990: PUSH
65991: LD_INT 1
65993: NEG
65994: PUSH
65995: EMPTY
65996: LIST
65997: LIST
65998: PUSH
65999: LD_INT 2
66001: NEG
66002: PUSH
66003: LD_INT 2
66005: NEG
66006: PUSH
66007: EMPTY
66008: LIST
66009: LIST
66010: PUSH
66011: LD_INT 1
66013: PUSH
66014: LD_INT 2
66016: NEG
66017: PUSH
66018: EMPTY
66019: LIST
66020: LIST
66021: PUSH
66022: LD_INT 2
66024: PUSH
66025: LD_INT 1
66027: NEG
66028: PUSH
66029: EMPTY
66030: LIST
66031: LIST
66032: PUSH
66033: LD_INT 3
66035: PUSH
66036: LD_INT 1
66038: PUSH
66039: EMPTY
66040: LIST
66041: LIST
66042: PUSH
66043: LD_INT 3
66045: PUSH
66046: LD_INT 2
66048: PUSH
66049: EMPTY
66050: LIST
66051: LIST
66052: PUSH
66053: EMPTY
66054: LIST
66055: LIST
66056: LIST
66057: LIST
66058: LIST
66059: LIST
66060: LIST
66061: LIST
66062: LIST
66063: LIST
66064: LIST
66065: LIST
66066: LIST
66067: LIST
66068: LIST
66069: LIST
66070: LIST
66071: LIST
66072: LIST
66073: LIST
66074: LIST
66075: LIST
66076: LIST
66077: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
66078: LD_ADDR_VAR 0 25
66082: PUSH
66083: LD_INT 0
66085: PUSH
66086: LD_INT 0
66088: PUSH
66089: EMPTY
66090: LIST
66091: LIST
66092: PUSH
66093: LD_INT 0
66095: PUSH
66096: LD_INT 1
66098: NEG
66099: PUSH
66100: EMPTY
66101: LIST
66102: LIST
66103: PUSH
66104: LD_INT 1
66106: PUSH
66107: LD_INT 0
66109: PUSH
66110: EMPTY
66111: LIST
66112: LIST
66113: PUSH
66114: LD_INT 1
66116: PUSH
66117: LD_INT 1
66119: PUSH
66120: EMPTY
66121: LIST
66122: LIST
66123: PUSH
66124: LD_INT 0
66126: PUSH
66127: LD_INT 1
66129: PUSH
66130: EMPTY
66131: LIST
66132: LIST
66133: PUSH
66134: LD_INT 1
66136: NEG
66137: PUSH
66138: LD_INT 0
66140: PUSH
66141: EMPTY
66142: LIST
66143: LIST
66144: PUSH
66145: LD_INT 1
66147: NEG
66148: PUSH
66149: LD_INT 1
66151: NEG
66152: PUSH
66153: EMPTY
66154: LIST
66155: LIST
66156: PUSH
66157: LD_INT 1
66159: NEG
66160: PUSH
66161: LD_INT 2
66163: NEG
66164: PUSH
66165: EMPTY
66166: LIST
66167: LIST
66168: PUSH
66169: LD_INT 0
66171: PUSH
66172: LD_INT 2
66174: NEG
66175: PUSH
66176: EMPTY
66177: LIST
66178: LIST
66179: PUSH
66180: LD_INT 1
66182: PUSH
66183: LD_INT 1
66185: NEG
66186: PUSH
66187: EMPTY
66188: LIST
66189: LIST
66190: PUSH
66191: LD_INT 2
66193: PUSH
66194: LD_INT 0
66196: PUSH
66197: EMPTY
66198: LIST
66199: LIST
66200: PUSH
66201: LD_INT 2
66203: PUSH
66204: LD_INT 1
66206: PUSH
66207: EMPTY
66208: LIST
66209: LIST
66210: PUSH
66211: LD_INT 2
66213: PUSH
66214: LD_INT 2
66216: PUSH
66217: EMPTY
66218: LIST
66219: LIST
66220: PUSH
66221: LD_INT 1
66223: PUSH
66224: LD_INT 2
66226: PUSH
66227: EMPTY
66228: LIST
66229: LIST
66230: PUSH
66231: LD_INT 0
66233: PUSH
66234: LD_INT 2
66236: PUSH
66237: EMPTY
66238: LIST
66239: LIST
66240: PUSH
66241: LD_INT 1
66243: NEG
66244: PUSH
66245: LD_INT 1
66247: PUSH
66248: EMPTY
66249: LIST
66250: LIST
66251: PUSH
66252: LD_INT 2
66254: NEG
66255: PUSH
66256: LD_INT 0
66258: PUSH
66259: EMPTY
66260: LIST
66261: LIST
66262: PUSH
66263: LD_INT 2
66265: NEG
66266: PUSH
66267: LD_INT 1
66269: NEG
66270: PUSH
66271: EMPTY
66272: LIST
66273: LIST
66274: PUSH
66275: LD_INT 2
66277: NEG
66278: PUSH
66279: LD_INT 2
66281: NEG
66282: PUSH
66283: EMPTY
66284: LIST
66285: LIST
66286: PUSH
66287: LD_INT 3
66289: PUSH
66290: LD_INT 1
66292: PUSH
66293: EMPTY
66294: LIST
66295: LIST
66296: PUSH
66297: LD_INT 3
66299: PUSH
66300: LD_INT 2
66302: PUSH
66303: EMPTY
66304: LIST
66305: LIST
66306: PUSH
66307: LD_INT 2
66309: PUSH
66310: LD_INT 3
66312: PUSH
66313: EMPTY
66314: LIST
66315: LIST
66316: PUSH
66317: LD_INT 1
66319: PUSH
66320: LD_INT 3
66322: PUSH
66323: EMPTY
66324: LIST
66325: LIST
66326: PUSH
66327: EMPTY
66328: LIST
66329: LIST
66330: LIST
66331: LIST
66332: LIST
66333: LIST
66334: LIST
66335: LIST
66336: LIST
66337: LIST
66338: LIST
66339: LIST
66340: LIST
66341: LIST
66342: LIST
66343: LIST
66344: LIST
66345: LIST
66346: LIST
66347: LIST
66348: LIST
66349: LIST
66350: LIST
66351: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
66352: LD_ADDR_VAR 0 26
66356: PUSH
66357: LD_INT 0
66359: PUSH
66360: LD_INT 0
66362: PUSH
66363: EMPTY
66364: LIST
66365: LIST
66366: PUSH
66367: LD_INT 0
66369: PUSH
66370: LD_INT 1
66372: NEG
66373: PUSH
66374: EMPTY
66375: LIST
66376: LIST
66377: PUSH
66378: LD_INT 1
66380: PUSH
66381: LD_INT 0
66383: PUSH
66384: EMPTY
66385: LIST
66386: LIST
66387: PUSH
66388: LD_INT 1
66390: PUSH
66391: LD_INT 1
66393: PUSH
66394: EMPTY
66395: LIST
66396: LIST
66397: PUSH
66398: LD_INT 0
66400: PUSH
66401: LD_INT 1
66403: PUSH
66404: EMPTY
66405: LIST
66406: LIST
66407: PUSH
66408: LD_INT 1
66410: NEG
66411: PUSH
66412: LD_INT 0
66414: PUSH
66415: EMPTY
66416: LIST
66417: LIST
66418: PUSH
66419: LD_INT 1
66421: NEG
66422: PUSH
66423: LD_INT 1
66425: NEG
66426: PUSH
66427: EMPTY
66428: LIST
66429: LIST
66430: PUSH
66431: LD_INT 1
66433: NEG
66434: PUSH
66435: LD_INT 2
66437: NEG
66438: PUSH
66439: EMPTY
66440: LIST
66441: LIST
66442: PUSH
66443: LD_INT 0
66445: PUSH
66446: LD_INT 2
66448: NEG
66449: PUSH
66450: EMPTY
66451: LIST
66452: LIST
66453: PUSH
66454: LD_INT 1
66456: PUSH
66457: LD_INT 1
66459: NEG
66460: PUSH
66461: EMPTY
66462: LIST
66463: LIST
66464: PUSH
66465: LD_INT 2
66467: PUSH
66468: LD_INT 0
66470: PUSH
66471: EMPTY
66472: LIST
66473: LIST
66474: PUSH
66475: LD_INT 2
66477: PUSH
66478: LD_INT 1
66480: PUSH
66481: EMPTY
66482: LIST
66483: LIST
66484: PUSH
66485: LD_INT 2
66487: PUSH
66488: LD_INT 2
66490: PUSH
66491: EMPTY
66492: LIST
66493: LIST
66494: PUSH
66495: LD_INT 1
66497: PUSH
66498: LD_INT 2
66500: PUSH
66501: EMPTY
66502: LIST
66503: LIST
66504: PUSH
66505: LD_INT 0
66507: PUSH
66508: LD_INT 2
66510: PUSH
66511: EMPTY
66512: LIST
66513: LIST
66514: PUSH
66515: LD_INT 1
66517: NEG
66518: PUSH
66519: LD_INT 1
66521: PUSH
66522: EMPTY
66523: LIST
66524: LIST
66525: PUSH
66526: LD_INT 2
66528: NEG
66529: PUSH
66530: LD_INT 0
66532: PUSH
66533: EMPTY
66534: LIST
66535: LIST
66536: PUSH
66537: LD_INT 2
66539: NEG
66540: PUSH
66541: LD_INT 1
66543: NEG
66544: PUSH
66545: EMPTY
66546: LIST
66547: LIST
66548: PUSH
66549: LD_INT 2
66551: NEG
66552: PUSH
66553: LD_INT 2
66555: NEG
66556: PUSH
66557: EMPTY
66558: LIST
66559: LIST
66560: PUSH
66561: LD_INT 2
66563: PUSH
66564: LD_INT 3
66566: PUSH
66567: EMPTY
66568: LIST
66569: LIST
66570: PUSH
66571: LD_INT 1
66573: PUSH
66574: LD_INT 3
66576: PUSH
66577: EMPTY
66578: LIST
66579: LIST
66580: PUSH
66581: LD_INT 1
66583: NEG
66584: PUSH
66585: LD_INT 2
66587: PUSH
66588: EMPTY
66589: LIST
66590: LIST
66591: PUSH
66592: LD_INT 2
66594: NEG
66595: PUSH
66596: LD_INT 1
66598: PUSH
66599: EMPTY
66600: LIST
66601: LIST
66602: PUSH
66603: EMPTY
66604: LIST
66605: LIST
66606: LIST
66607: LIST
66608: LIST
66609: LIST
66610: LIST
66611: LIST
66612: LIST
66613: LIST
66614: LIST
66615: LIST
66616: LIST
66617: LIST
66618: LIST
66619: LIST
66620: LIST
66621: LIST
66622: LIST
66623: LIST
66624: LIST
66625: LIST
66626: LIST
66627: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
66628: LD_ADDR_VAR 0 27
66632: PUSH
66633: LD_INT 0
66635: PUSH
66636: LD_INT 0
66638: PUSH
66639: EMPTY
66640: LIST
66641: LIST
66642: PUSH
66643: LD_INT 0
66645: PUSH
66646: LD_INT 1
66648: NEG
66649: PUSH
66650: EMPTY
66651: LIST
66652: LIST
66653: PUSH
66654: LD_INT 1
66656: PUSH
66657: LD_INT 0
66659: PUSH
66660: EMPTY
66661: LIST
66662: LIST
66663: PUSH
66664: LD_INT 1
66666: PUSH
66667: LD_INT 1
66669: PUSH
66670: EMPTY
66671: LIST
66672: LIST
66673: PUSH
66674: LD_INT 0
66676: PUSH
66677: LD_INT 1
66679: PUSH
66680: EMPTY
66681: LIST
66682: LIST
66683: PUSH
66684: LD_INT 1
66686: NEG
66687: PUSH
66688: LD_INT 0
66690: PUSH
66691: EMPTY
66692: LIST
66693: LIST
66694: PUSH
66695: LD_INT 1
66697: NEG
66698: PUSH
66699: LD_INT 1
66701: NEG
66702: PUSH
66703: EMPTY
66704: LIST
66705: LIST
66706: PUSH
66707: LD_INT 1
66709: NEG
66710: PUSH
66711: LD_INT 2
66713: NEG
66714: PUSH
66715: EMPTY
66716: LIST
66717: LIST
66718: PUSH
66719: LD_INT 0
66721: PUSH
66722: LD_INT 2
66724: NEG
66725: PUSH
66726: EMPTY
66727: LIST
66728: LIST
66729: PUSH
66730: LD_INT 1
66732: PUSH
66733: LD_INT 1
66735: NEG
66736: PUSH
66737: EMPTY
66738: LIST
66739: LIST
66740: PUSH
66741: LD_INT 2
66743: PUSH
66744: LD_INT 0
66746: PUSH
66747: EMPTY
66748: LIST
66749: LIST
66750: PUSH
66751: LD_INT 2
66753: PUSH
66754: LD_INT 1
66756: PUSH
66757: EMPTY
66758: LIST
66759: LIST
66760: PUSH
66761: LD_INT 2
66763: PUSH
66764: LD_INT 2
66766: PUSH
66767: EMPTY
66768: LIST
66769: LIST
66770: PUSH
66771: LD_INT 1
66773: PUSH
66774: LD_INT 2
66776: PUSH
66777: EMPTY
66778: LIST
66779: LIST
66780: PUSH
66781: LD_INT 0
66783: PUSH
66784: LD_INT 2
66786: PUSH
66787: EMPTY
66788: LIST
66789: LIST
66790: PUSH
66791: LD_INT 1
66793: NEG
66794: PUSH
66795: LD_INT 1
66797: PUSH
66798: EMPTY
66799: LIST
66800: LIST
66801: PUSH
66802: LD_INT 2
66804: NEG
66805: PUSH
66806: LD_INT 0
66808: PUSH
66809: EMPTY
66810: LIST
66811: LIST
66812: PUSH
66813: LD_INT 2
66815: NEG
66816: PUSH
66817: LD_INT 1
66819: NEG
66820: PUSH
66821: EMPTY
66822: LIST
66823: LIST
66824: PUSH
66825: LD_INT 2
66827: NEG
66828: PUSH
66829: LD_INT 2
66831: NEG
66832: PUSH
66833: EMPTY
66834: LIST
66835: LIST
66836: PUSH
66837: LD_INT 1
66839: NEG
66840: PUSH
66841: LD_INT 2
66843: PUSH
66844: EMPTY
66845: LIST
66846: LIST
66847: PUSH
66848: LD_INT 2
66850: NEG
66851: PUSH
66852: LD_INT 1
66854: PUSH
66855: EMPTY
66856: LIST
66857: LIST
66858: PUSH
66859: LD_INT 3
66861: NEG
66862: PUSH
66863: LD_INT 1
66865: NEG
66866: PUSH
66867: EMPTY
66868: LIST
66869: LIST
66870: PUSH
66871: LD_INT 3
66873: NEG
66874: PUSH
66875: LD_INT 2
66877: NEG
66878: PUSH
66879: EMPTY
66880: LIST
66881: LIST
66882: PUSH
66883: EMPTY
66884: LIST
66885: LIST
66886: LIST
66887: LIST
66888: LIST
66889: LIST
66890: LIST
66891: LIST
66892: LIST
66893: LIST
66894: LIST
66895: LIST
66896: LIST
66897: LIST
66898: LIST
66899: LIST
66900: LIST
66901: LIST
66902: LIST
66903: LIST
66904: LIST
66905: LIST
66906: LIST
66907: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
66908: LD_ADDR_VAR 0 28
66912: PUSH
66913: LD_INT 0
66915: PUSH
66916: LD_INT 0
66918: PUSH
66919: EMPTY
66920: LIST
66921: LIST
66922: PUSH
66923: LD_INT 0
66925: PUSH
66926: LD_INT 1
66928: NEG
66929: PUSH
66930: EMPTY
66931: LIST
66932: LIST
66933: PUSH
66934: LD_INT 1
66936: PUSH
66937: LD_INT 0
66939: PUSH
66940: EMPTY
66941: LIST
66942: LIST
66943: PUSH
66944: LD_INT 1
66946: PUSH
66947: LD_INT 1
66949: PUSH
66950: EMPTY
66951: LIST
66952: LIST
66953: PUSH
66954: LD_INT 0
66956: PUSH
66957: LD_INT 1
66959: PUSH
66960: EMPTY
66961: LIST
66962: LIST
66963: PUSH
66964: LD_INT 1
66966: NEG
66967: PUSH
66968: LD_INT 0
66970: PUSH
66971: EMPTY
66972: LIST
66973: LIST
66974: PUSH
66975: LD_INT 1
66977: NEG
66978: PUSH
66979: LD_INT 1
66981: NEG
66982: PUSH
66983: EMPTY
66984: LIST
66985: LIST
66986: PUSH
66987: LD_INT 1
66989: NEG
66990: PUSH
66991: LD_INT 2
66993: NEG
66994: PUSH
66995: EMPTY
66996: LIST
66997: LIST
66998: PUSH
66999: LD_INT 0
67001: PUSH
67002: LD_INT 2
67004: NEG
67005: PUSH
67006: EMPTY
67007: LIST
67008: LIST
67009: PUSH
67010: LD_INT 1
67012: PUSH
67013: LD_INT 1
67015: NEG
67016: PUSH
67017: EMPTY
67018: LIST
67019: LIST
67020: PUSH
67021: LD_INT 2
67023: PUSH
67024: LD_INT 0
67026: PUSH
67027: EMPTY
67028: LIST
67029: LIST
67030: PUSH
67031: LD_INT 2
67033: PUSH
67034: LD_INT 1
67036: PUSH
67037: EMPTY
67038: LIST
67039: LIST
67040: PUSH
67041: LD_INT 2
67043: PUSH
67044: LD_INT 2
67046: PUSH
67047: EMPTY
67048: LIST
67049: LIST
67050: PUSH
67051: LD_INT 1
67053: PUSH
67054: LD_INT 2
67056: PUSH
67057: EMPTY
67058: LIST
67059: LIST
67060: PUSH
67061: LD_INT 0
67063: PUSH
67064: LD_INT 2
67066: PUSH
67067: EMPTY
67068: LIST
67069: LIST
67070: PUSH
67071: LD_INT 1
67073: NEG
67074: PUSH
67075: LD_INT 1
67077: PUSH
67078: EMPTY
67079: LIST
67080: LIST
67081: PUSH
67082: LD_INT 2
67084: NEG
67085: PUSH
67086: LD_INT 0
67088: PUSH
67089: EMPTY
67090: LIST
67091: LIST
67092: PUSH
67093: LD_INT 2
67095: NEG
67096: PUSH
67097: LD_INT 1
67099: NEG
67100: PUSH
67101: EMPTY
67102: LIST
67103: LIST
67104: PUSH
67105: LD_INT 2
67107: NEG
67108: PUSH
67109: LD_INT 2
67111: NEG
67112: PUSH
67113: EMPTY
67114: LIST
67115: LIST
67116: PUSH
67117: LD_INT 2
67119: NEG
67120: PUSH
67121: LD_INT 3
67123: NEG
67124: PUSH
67125: EMPTY
67126: LIST
67127: LIST
67128: PUSH
67129: LD_INT 1
67131: NEG
67132: PUSH
67133: LD_INT 3
67135: NEG
67136: PUSH
67137: EMPTY
67138: LIST
67139: LIST
67140: PUSH
67141: LD_INT 3
67143: NEG
67144: PUSH
67145: LD_INT 1
67147: NEG
67148: PUSH
67149: EMPTY
67150: LIST
67151: LIST
67152: PUSH
67153: LD_INT 3
67155: NEG
67156: PUSH
67157: LD_INT 2
67159: NEG
67160: PUSH
67161: EMPTY
67162: LIST
67163: LIST
67164: PUSH
67165: EMPTY
67166: LIST
67167: LIST
67168: LIST
67169: LIST
67170: LIST
67171: LIST
67172: LIST
67173: LIST
67174: LIST
67175: LIST
67176: LIST
67177: LIST
67178: LIST
67179: LIST
67180: LIST
67181: LIST
67182: LIST
67183: LIST
67184: LIST
67185: LIST
67186: LIST
67187: LIST
67188: LIST
67189: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
67190: LD_ADDR_VAR 0 29
67194: PUSH
67195: LD_INT 0
67197: PUSH
67198: LD_INT 0
67200: PUSH
67201: EMPTY
67202: LIST
67203: LIST
67204: PUSH
67205: LD_INT 0
67207: PUSH
67208: LD_INT 1
67210: NEG
67211: PUSH
67212: EMPTY
67213: LIST
67214: LIST
67215: PUSH
67216: LD_INT 1
67218: PUSH
67219: LD_INT 0
67221: PUSH
67222: EMPTY
67223: LIST
67224: LIST
67225: PUSH
67226: LD_INT 1
67228: PUSH
67229: LD_INT 1
67231: PUSH
67232: EMPTY
67233: LIST
67234: LIST
67235: PUSH
67236: LD_INT 0
67238: PUSH
67239: LD_INT 1
67241: PUSH
67242: EMPTY
67243: LIST
67244: LIST
67245: PUSH
67246: LD_INT 1
67248: NEG
67249: PUSH
67250: LD_INT 0
67252: PUSH
67253: EMPTY
67254: LIST
67255: LIST
67256: PUSH
67257: LD_INT 1
67259: NEG
67260: PUSH
67261: LD_INT 1
67263: NEG
67264: PUSH
67265: EMPTY
67266: LIST
67267: LIST
67268: PUSH
67269: LD_INT 1
67271: NEG
67272: PUSH
67273: LD_INT 2
67275: NEG
67276: PUSH
67277: EMPTY
67278: LIST
67279: LIST
67280: PUSH
67281: LD_INT 0
67283: PUSH
67284: LD_INT 2
67286: NEG
67287: PUSH
67288: EMPTY
67289: LIST
67290: LIST
67291: PUSH
67292: LD_INT 1
67294: PUSH
67295: LD_INT 1
67297: NEG
67298: PUSH
67299: EMPTY
67300: LIST
67301: LIST
67302: PUSH
67303: LD_INT 2
67305: PUSH
67306: LD_INT 0
67308: PUSH
67309: EMPTY
67310: LIST
67311: LIST
67312: PUSH
67313: LD_INT 2
67315: PUSH
67316: LD_INT 1
67318: PUSH
67319: EMPTY
67320: LIST
67321: LIST
67322: PUSH
67323: LD_INT 1
67325: PUSH
67326: LD_INT 2
67328: PUSH
67329: EMPTY
67330: LIST
67331: LIST
67332: PUSH
67333: LD_INT 0
67335: PUSH
67336: LD_INT 2
67338: PUSH
67339: EMPTY
67340: LIST
67341: LIST
67342: PUSH
67343: LD_INT 1
67345: NEG
67346: PUSH
67347: LD_INT 1
67349: PUSH
67350: EMPTY
67351: LIST
67352: LIST
67353: PUSH
67354: LD_INT 2
67356: NEG
67357: PUSH
67358: LD_INT 1
67360: NEG
67361: PUSH
67362: EMPTY
67363: LIST
67364: LIST
67365: PUSH
67366: LD_INT 2
67368: NEG
67369: PUSH
67370: LD_INT 2
67372: NEG
67373: PUSH
67374: EMPTY
67375: LIST
67376: LIST
67377: PUSH
67378: LD_INT 2
67380: NEG
67381: PUSH
67382: LD_INT 3
67384: NEG
67385: PUSH
67386: EMPTY
67387: LIST
67388: LIST
67389: PUSH
67390: LD_INT 2
67392: PUSH
67393: LD_INT 1
67395: NEG
67396: PUSH
67397: EMPTY
67398: LIST
67399: LIST
67400: PUSH
67401: LD_INT 3
67403: PUSH
67404: LD_INT 1
67406: PUSH
67407: EMPTY
67408: LIST
67409: LIST
67410: PUSH
67411: LD_INT 1
67413: PUSH
67414: LD_INT 3
67416: PUSH
67417: EMPTY
67418: LIST
67419: LIST
67420: PUSH
67421: LD_INT 1
67423: NEG
67424: PUSH
67425: LD_INT 2
67427: PUSH
67428: EMPTY
67429: LIST
67430: LIST
67431: PUSH
67432: LD_INT 3
67434: NEG
67435: PUSH
67436: LD_INT 2
67438: NEG
67439: PUSH
67440: EMPTY
67441: LIST
67442: LIST
67443: PUSH
67444: EMPTY
67445: LIST
67446: LIST
67447: LIST
67448: LIST
67449: LIST
67450: LIST
67451: LIST
67452: LIST
67453: LIST
67454: LIST
67455: LIST
67456: LIST
67457: LIST
67458: LIST
67459: LIST
67460: LIST
67461: LIST
67462: LIST
67463: LIST
67464: LIST
67465: LIST
67466: LIST
67467: LIST
67468: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
67469: LD_ADDR_VAR 0 30
67473: PUSH
67474: LD_INT 0
67476: PUSH
67477: LD_INT 0
67479: PUSH
67480: EMPTY
67481: LIST
67482: LIST
67483: PUSH
67484: LD_INT 0
67486: PUSH
67487: LD_INT 1
67489: NEG
67490: PUSH
67491: EMPTY
67492: LIST
67493: LIST
67494: PUSH
67495: LD_INT 1
67497: PUSH
67498: LD_INT 0
67500: PUSH
67501: EMPTY
67502: LIST
67503: LIST
67504: PUSH
67505: LD_INT 1
67507: PUSH
67508: LD_INT 1
67510: PUSH
67511: EMPTY
67512: LIST
67513: LIST
67514: PUSH
67515: LD_INT 0
67517: PUSH
67518: LD_INT 1
67520: PUSH
67521: EMPTY
67522: LIST
67523: LIST
67524: PUSH
67525: LD_INT 1
67527: NEG
67528: PUSH
67529: LD_INT 0
67531: PUSH
67532: EMPTY
67533: LIST
67534: LIST
67535: PUSH
67536: LD_INT 1
67538: NEG
67539: PUSH
67540: LD_INT 1
67542: NEG
67543: PUSH
67544: EMPTY
67545: LIST
67546: LIST
67547: PUSH
67548: LD_INT 1
67550: NEG
67551: PUSH
67552: LD_INT 2
67554: NEG
67555: PUSH
67556: EMPTY
67557: LIST
67558: LIST
67559: PUSH
67560: LD_INT 0
67562: PUSH
67563: LD_INT 2
67565: NEG
67566: PUSH
67567: EMPTY
67568: LIST
67569: LIST
67570: PUSH
67571: LD_INT 1
67573: PUSH
67574: LD_INT 1
67576: NEG
67577: PUSH
67578: EMPTY
67579: LIST
67580: LIST
67581: PUSH
67582: LD_INT 2
67584: PUSH
67585: LD_INT 0
67587: PUSH
67588: EMPTY
67589: LIST
67590: LIST
67591: PUSH
67592: LD_INT 2
67594: PUSH
67595: LD_INT 1
67597: PUSH
67598: EMPTY
67599: LIST
67600: LIST
67601: PUSH
67602: LD_INT 2
67604: PUSH
67605: LD_INT 2
67607: PUSH
67608: EMPTY
67609: LIST
67610: LIST
67611: PUSH
67612: LD_INT 1
67614: PUSH
67615: LD_INT 2
67617: PUSH
67618: EMPTY
67619: LIST
67620: LIST
67621: PUSH
67622: LD_INT 1
67624: NEG
67625: PUSH
67626: LD_INT 1
67628: PUSH
67629: EMPTY
67630: LIST
67631: LIST
67632: PUSH
67633: LD_INT 2
67635: NEG
67636: PUSH
67637: LD_INT 0
67639: PUSH
67640: EMPTY
67641: LIST
67642: LIST
67643: PUSH
67644: LD_INT 2
67646: NEG
67647: PUSH
67648: LD_INT 1
67650: NEG
67651: PUSH
67652: EMPTY
67653: LIST
67654: LIST
67655: PUSH
67656: LD_INT 1
67658: NEG
67659: PUSH
67660: LD_INT 3
67662: NEG
67663: PUSH
67664: EMPTY
67665: LIST
67666: LIST
67667: PUSH
67668: LD_INT 1
67670: PUSH
67671: LD_INT 2
67673: NEG
67674: PUSH
67675: EMPTY
67676: LIST
67677: LIST
67678: PUSH
67679: LD_INT 3
67681: PUSH
67682: LD_INT 2
67684: PUSH
67685: EMPTY
67686: LIST
67687: LIST
67688: PUSH
67689: LD_INT 2
67691: PUSH
67692: LD_INT 3
67694: PUSH
67695: EMPTY
67696: LIST
67697: LIST
67698: PUSH
67699: LD_INT 2
67701: NEG
67702: PUSH
67703: LD_INT 1
67705: PUSH
67706: EMPTY
67707: LIST
67708: LIST
67709: PUSH
67710: LD_INT 3
67712: NEG
67713: PUSH
67714: LD_INT 1
67716: NEG
67717: PUSH
67718: EMPTY
67719: LIST
67720: LIST
67721: PUSH
67722: EMPTY
67723: LIST
67724: LIST
67725: LIST
67726: LIST
67727: LIST
67728: LIST
67729: LIST
67730: LIST
67731: LIST
67732: LIST
67733: LIST
67734: LIST
67735: LIST
67736: LIST
67737: LIST
67738: LIST
67739: LIST
67740: LIST
67741: LIST
67742: LIST
67743: LIST
67744: LIST
67745: LIST
67746: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
67747: LD_ADDR_VAR 0 31
67751: PUSH
67752: LD_INT 0
67754: PUSH
67755: LD_INT 0
67757: PUSH
67758: EMPTY
67759: LIST
67760: LIST
67761: PUSH
67762: LD_INT 0
67764: PUSH
67765: LD_INT 1
67767: NEG
67768: PUSH
67769: EMPTY
67770: LIST
67771: LIST
67772: PUSH
67773: LD_INT 1
67775: PUSH
67776: LD_INT 0
67778: PUSH
67779: EMPTY
67780: LIST
67781: LIST
67782: PUSH
67783: LD_INT 1
67785: PUSH
67786: LD_INT 1
67788: PUSH
67789: EMPTY
67790: LIST
67791: LIST
67792: PUSH
67793: LD_INT 0
67795: PUSH
67796: LD_INT 1
67798: PUSH
67799: EMPTY
67800: LIST
67801: LIST
67802: PUSH
67803: LD_INT 1
67805: NEG
67806: PUSH
67807: LD_INT 0
67809: PUSH
67810: EMPTY
67811: LIST
67812: LIST
67813: PUSH
67814: LD_INT 1
67816: NEG
67817: PUSH
67818: LD_INT 1
67820: NEG
67821: PUSH
67822: EMPTY
67823: LIST
67824: LIST
67825: PUSH
67826: LD_INT 1
67828: NEG
67829: PUSH
67830: LD_INT 2
67832: NEG
67833: PUSH
67834: EMPTY
67835: LIST
67836: LIST
67837: PUSH
67838: LD_INT 1
67840: PUSH
67841: LD_INT 1
67843: NEG
67844: PUSH
67845: EMPTY
67846: LIST
67847: LIST
67848: PUSH
67849: LD_INT 2
67851: PUSH
67852: LD_INT 0
67854: PUSH
67855: EMPTY
67856: LIST
67857: LIST
67858: PUSH
67859: LD_INT 2
67861: PUSH
67862: LD_INT 1
67864: PUSH
67865: EMPTY
67866: LIST
67867: LIST
67868: PUSH
67869: LD_INT 2
67871: PUSH
67872: LD_INT 2
67874: PUSH
67875: EMPTY
67876: LIST
67877: LIST
67878: PUSH
67879: LD_INT 1
67881: PUSH
67882: LD_INT 2
67884: PUSH
67885: EMPTY
67886: LIST
67887: LIST
67888: PUSH
67889: LD_INT 0
67891: PUSH
67892: LD_INT 2
67894: PUSH
67895: EMPTY
67896: LIST
67897: LIST
67898: PUSH
67899: LD_INT 1
67901: NEG
67902: PUSH
67903: LD_INT 1
67905: PUSH
67906: EMPTY
67907: LIST
67908: LIST
67909: PUSH
67910: LD_INT 2
67912: NEG
67913: PUSH
67914: LD_INT 1
67916: NEG
67917: PUSH
67918: EMPTY
67919: LIST
67920: LIST
67921: PUSH
67922: LD_INT 2
67924: NEG
67925: PUSH
67926: LD_INT 2
67928: NEG
67929: PUSH
67930: EMPTY
67931: LIST
67932: LIST
67933: PUSH
67934: LD_INT 2
67936: NEG
67937: PUSH
67938: LD_INT 3
67940: NEG
67941: PUSH
67942: EMPTY
67943: LIST
67944: LIST
67945: PUSH
67946: LD_INT 2
67948: PUSH
67949: LD_INT 1
67951: NEG
67952: PUSH
67953: EMPTY
67954: LIST
67955: LIST
67956: PUSH
67957: LD_INT 3
67959: PUSH
67960: LD_INT 1
67962: PUSH
67963: EMPTY
67964: LIST
67965: LIST
67966: PUSH
67967: LD_INT 1
67969: PUSH
67970: LD_INT 3
67972: PUSH
67973: EMPTY
67974: LIST
67975: LIST
67976: PUSH
67977: LD_INT 1
67979: NEG
67980: PUSH
67981: LD_INT 2
67983: PUSH
67984: EMPTY
67985: LIST
67986: LIST
67987: PUSH
67988: LD_INT 3
67990: NEG
67991: PUSH
67992: LD_INT 2
67994: NEG
67995: PUSH
67996: EMPTY
67997: LIST
67998: LIST
67999: PUSH
68000: EMPTY
68001: LIST
68002: LIST
68003: LIST
68004: LIST
68005: LIST
68006: LIST
68007: LIST
68008: LIST
68009: LIST
68010: LIST
68011: LIST
68012: LIST
68013: LIST
68014: LIST
68015: LIST
68016: LIST
68017: LIST
68018: LIST
68019: LIST
68020: LIST
68021: LIST
68022: LIST
68023: LIST
68024: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
68025: LD_ADDR_VAR 0 32
68029: PUSH
68030: LD_INT 0
68032: PUSH
68033: LD_INT 0
68035: PUSH
68036: EMPTY
68037: LIST
68038: LIST
68039: PUSH
68040: LD_INT 0
68042: PUSH
68043: LD_INT 1
68045: NEG
68046: PUSH
68047: EMPTY
68048: LIST
68049: LIST
68050: PUSH
68051: LD_INT 1
68053: PUSH
68054: LD_INT 0
68056: PUSH
68057: EMPTY
68058: LIST
68059: LIST
68060: PUSH
68061: LD_INT 1
68063: PUSH
68064: LD_INT 1
68066: PUSH
68067: EMPTY
68068: LIST
68069: LIST
68070: PUSH
68071: LD_INT 0
68073: PUSH
68074: LD_INT 1
68076: PUSH
68077: EMPTY
68078: LIST
68079: LIST
68080: PUSH
68081: LD_INT 1
68083: NEG
68084: PUSH
68085: LD_INT 0
68087: PUSH
68088: EMPTY
68089: LIST
68090: LIST
68091: PUSH
68092: LD_INT 1
68094: NEG
68095: PUSH
68096: LD_INT 1
68098: NEG
68099: PUSH
68100: EMPTY
68101: LIST
68102: LIST
68103: PUSH
68104: LD_INT 1
68106: NEG
68107: PUSH
68108: LD_INT 2
68110: NEG
68111: PUSH
68112: EMPTY
68113: LIST
68114: LIST
68115: PUSH
68116: LD_INT 0
68118: PUSH
68119: LD_INT 2
68121: NEG
68122: PUSH
68123: EMPTY
68124: LIST
68125: LIST
68126: PUSH
68127: LD_INT 1
68129: PUSH
68130: LD_INT 1
68132: NEG
68133: PUSH
68134: EMPTY
68135: LIST
68136: LIST
68137: PUSH
68138: LD_INT 2
68140: PUSH
68141: LD_INT 1
68143: PUSH
68144: EMPTY
68145: LIST
68146: LIST
68147: PUSH
68148: LD_INT 2
68150: PUSH
68151: LD_INT 2
68153: PUSH
68154: EMPTY
68155: LIST
68156: LIST
68157: PUSH
68158: LD_INT 1
68160: PUSH
68161: LD_INT 2
68163: PUSH
68164: EMPTY
68165: LIST
68166: LIST
68167: PUSH
68168: LD_INT 0
68170: PUSH
68171: LD_INT 2
68173: PUSH
68174: EMPTY
68175: LIST
68176: LIST
68177: PUSH
68178: LD_INT 1
68180: NEG
68181: PUSH
68182: LD_INT 1
68184: PUSH
68185: EMPTY
68186: LIST
68187: LIST
68188: PUSH
68189: LD_INT 2
68191: NEG
68192: PUSH
68193: LD_INT 0
68195: PUSH
68196: EMPTY
68197: LIST
68198: LIST
68199: PUSH
68200: LD_INT 2
68202: NEG
68203: PUSH
68204: LD_INT 1
68206: NEG
68207: PUSH
68208: EMPTY
68209: LIST
68210: LIST
68211: PUSH
68212: LD_INT 1
68214: NEG
68215: PUSH
68216: LD_INT 3
68218: NEG
68219: PUSH
68220: EMPTY
68221: LIST
68222: LIST
68223: PUSH
68224: LD_INT 1
68226: PUSH
68227: LD_INT 2
68229: NEG
68230: PUSH
68231: EMPTY
68232: LIST
68233: LIST
68234: PUSH
68235: LD_INT 3
68237: PUSH
68238: LD_INT 2
68240: PUSH
68241: EMPTY
68242: LIST
68243: LIST
68244: PUSH
68245: LD_INT 2
68247: PUSH
68248: LD_INT 3
68250: PUSH
68251: EMPTY
68252: LIST
68253: LIST
68254: PUSH
68255: LD_INT 2
68257: NEG
68258: PUSH
68259: LD_INT 1
68261: PUSH
68262: EMPTY
68263: LIST
68264: LIST
68265: PUSH
68266: LD_INT 3
68268: NEG
68269: PUSH
68270: LD_INT 1
68272: NEG
68273: PUSH
68274: EMPTY
68275: LIST
68276: LIST
68277: PUSH
68278: EMPTY
68279: LIST
68280: LIST
68281: LIST
68282: LIST
68283: LIST
68284: LIST
68285: LIST
68286: LIST
68287: LIST
68288: LIST
68289: LIST
68290: LIST
68291: LIST
68292: LIST
68293: LIST
68294: LIST
68295: LIST
68296: LIST
68297: LIST
68298: LIST
68299: LIST
68300: LIST
68301: LIST
68302: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
68303: LD_ADDR_VAR 0 33
68307: PUSH
68308: LD_INT 0
68310: PUSH
68311: LD_INT 0
68313: PUSH
68314: EMPTY
68315: LIST
68316: LIST
68317: PUSH
68318: LD_INT 0
68320: PUSH
68321: LD_INT 1
68323: NEG
68324: PUSH
68325: EMPTY
68326: LIST
68327: LIST
68328: PUSH
68329: LD_INT 1
68331: PUSH
68332: LD_INT 0
68334: PUSH
68335: EMPTY
68336: LIST
68337: LIST
68338: PUSH
68339: LD_INT 1
68341: PUSH
68342: LD_INT 1
68344: PUSH
68345: EMPTY
68346: LIST
68347: LIST
68348: PUSH
68349: LD_INT 0
68351: PUSH
68352: LD_INT 1
68354: PUSH
68355: EMPTY
68356: LIST
68357: LIST
68358: PUSH
68359: LD_INT 1
68361: NEG
68362: PUSH
68363: LD_INT 0
68365: PUSH
68366: EMPTY
68367: LIST
68368: LIST
68369: PUSH
68370: LD_INT 1
68372: NEG
68373: PUSH
68374: LD_INT 1
68376: NEG
68377: PUSH
68378: EMPTY
68379: LIST
68380: LIST
68381: PUSH
68382: LD_INT 1
68384: NEG
68385: PUSH
68386: LD_INT 2
68388: NEG
68389: PUSH
68390: EMPTY
68391: LIST
68392: LIST
68393: PUSH
68394: LD_INT 1
68396: PUSH
68397: LD_INT 1
68399: NEG
68400: PUSH
68401: EMPTY
68402: LIST
68403: LIST
68404: PUSH
68405: LD_INT 2
68407: PUSH
68408: LD_INT 0
68410: PUSH
68411: EMPTY
68412: LIST
68413: LIST
68414: PUSH
68415: LD_INT 2
68417: PUSH
68418: LD_INT 1
68420: PUSH
68421: EMPTY
68422: LIST
68423: LIST
68424: PUSH
68425: LD_INT 1
68427: PUSH
68428: LD_INT 2
68430: PUSH
68431: EMPTY
68432: LIST
68433: LIST
68434: PUSH
68435: LD_INT 0
68437: PUSH
68438: LD_INT 2
68440: PUSH
68441: EMPTY
68442: LIST
68443: LIST
68444: PUSH
68445: LD_INT 1
68447: NEG
68448: PUSH
68449: LD_INT 1
68451: PUSH
68452: EMPTY
68453: LIST
68454: LIST
68455: PUSH
68456: LD_INT 2
68458: NEG
68459: PUSH
68460: LD_INT 0
68462: PUSH
68463: EMPTY
68464: LIST
68465: LIST
68466: PUSH
68467: LD_INT 2
68469: NEG
68470: PUSH
68471: LD_INT 1
68473: NEG
68474: PUSH
68475: EMPTY
68476: LIST
68477: LIST
68478: PUSH
68479: LD_INT 2
68481: NEG
68482: PUSH
68483: LD_INT 2
68485: NEG
68486: PUSH
68487: EMPTY
68488: LIST
68489: LIST
68490: PUSH
68491: LD_INT 2
68493: NEG
68494: PUSH
68495: LD_INT 3
68497: NEG
68498: PUSH
68499: EMPTY
68500: LIST
68501: LIST
68502: PUSH
68503: LD_INT 2
68505: PUSH
68506: LD_INT 1
68508: NEG
68509: PUSH
68510: EMPTY
68511: LIST
68512: LIST
68513: PUSH
68514: LD_INT 3
68516: PUSH
68517: LD_INT 1
68519: PUSH
68520: EMPTY
68521: LIST
68522: LIST
68523: PUSH
68524: LD_INT 1
68526: PUSH
68527: LD_INT 3
68529: PUSH
68530: EMPTY
68531: LIST
68532: LIST
68533: PUSH
68534: LD_INT 1
68536: NEG
68537: PUSH
68538: LD_INT 2
68540: PUSH
68541: EMPTY
68542: LIST
68543: LIST
68544: PUSH
68545: LD_INT 3
68547: NEG
68548: PUSH
68549: LD_INT 2
68551: NEG
68552: PUSH
68553: EMPTY
68554: LIST
68555: LIST
68556: PUSH
68557: EMPTY
68558: LIST
68559: LIST
68560: LIST
68561: LIST
68562: LIST
68563: LIST
68564: LIST
68565: LIST
68566: LIST
68567: LIST
68568: LIST
68569: LIST
68570: LIST
68571: LIST
68572: LIST
68573: LIST
68574: LIST
68575: LIST
68576: LIST
68577: LIST
68578: LIST
68579: LIST
68580: LIST
68581: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
68582: LD_ADDR_VAR 0 34
68586: PUSH
68587: LD_INT 0
68589: PUSH
68590: LD_INT 0
68592: PUSH
68593: EMPTY
68594: LIST
68595: LIST
68596: PUSH
68597: LD_INT 0
68599: PUSH
68600: LD_INT 1
68602: NEG
68603: PUSH
68604: EMPTY
68605: LIST
68606: LIST
68607: PUSH
68608: LD_INT 1
68610: PUSH
68611: LD_INT 0
68613: PUSH
68614: EMPTY
68615: LIST
68616: LIST
68617: PUSH
68618: LD_INT 1
68620: PUSH
68621: LD_INT 1
68623: PUSH
68624: EMPTY
68625: LIST
68626: LIST
68627: PUSH
68628: LD_INT 0
68630: PUSH
68631: LD_INT 1
68633: PUSH
68634: EMPTY
68635: LIST
68636: LIST
68637: PUSH
68638: LD_INT 1
68640: NEG
68641: PUSH
68642: LD_INT 0
68644: PUSH
68645: EMPTY
68646: LIST
68647: LIST
68648: PUSH
68649: LD_INT 1
68651: NEG
68652: PUSH
68653: LD_INT 1
68655: NEG
68656: PUSH
68657: EMPTY
68658: LIST
68659: LIST
68660: PUSH
68661: LD_INT 1
68663: NEG
68664: PUSH
68665: LD_INT 2
68667: NEG
68668: PUSH
68669: EMPTY
68670: LIST
68671: LIST
68672: PUSH
68673: LD_INT 0
68675: PUSH
68676: LD_INT 2
68678: NEG
68679: PUSH
68680: EMPTY
68681: LIST
68682: LIST
68683: PUSH
68684: LD_INT 1
68686: PUSH
68687: LD_INT 1
68689: NEG
68690: PUSH
68691: EMPTY
68692: LIST
68693: LIST
68694: PUSH
68695: LD_INT 2
68697: PUSH
68698: LD_INT 1
68700: PUSH
68701: EMPTY
68702: LIST
68703: LIST
68704: PUSH
68705: LD_INT 2
68707: PUSH
68708: LD_INT 2
68710: PUSH
68711: EMPTY
68712: LIST
68713: LIST
68714: PUSH
68715: LD_INT 1
68717: PUSH
68718: LD_INT 2
68720: PUSH
68721: EMPTY
68722: LIST
68723: LIST
68724: PUSH
68725: LD_INT 1
68727: NEG
68728: PUSH
68729: LD_INT 1
68731: PUSH
68732: EMPTY
68733: LIST
68734: LIST
68735: PUSH
68736: LD_INT 2
68738: NEG
68739: PUSH
68740: LD_INT 0
68742: PUSH
68743: EMPTY
68744: LIST
68745: LIST
68746: PUSH
68747: LD_INT 2
68749: NEG
68750: PUSH
68751: LD_INT 1
68753: NEG
68754: PUSH
68755: EMPTY
68756: LIST
68757: LIST
68758: PUSH
68759: LD_INT 2
68761: NEG
68762: PUSH
68763: LD_INT 2
68765: NEG
68766: PUSH
68767: EMPTY
68768: LIST
68769: LIST
68770: PUSH
68771: LD_INT 1
68773: NEG
68774: PUSH
68775: LD_INT 3
68777: NEG
68778: PUSH
68779: EMPTY
68780: LIST
68781: LIST
68782: PUSH
68783: LD_INT 1
68785: PUSH
68786: LD_INT 2
68788: NEG
68789: PUSH
68790: EMPTY
68791: LIST
68792: LIST
68793: PUSH
68794: LD_INT 3
68796: PUSH
68797: LD_INT 2
68799: PUSH
68800: EMPTY
68801: LIST
68802: LIST
68803: PUSH
68804: LD_INT 2
68806: PUSH
68807: LD_INT 3
68809: PUSH
68810: EMPTY
68811: LIST
68812: LIST
68813: PUSH
68814: LD_INT 2
68816: NEG
68817: PUSH
68818: LD_INT 1
68820: PUSH
68821: EMPTY
68822: LIST
68823: LIST
68824: PUSH
68825: LD_INT 3
68827: NEG
68828: PUSH
68829: LD_INT 1
68831: NEG
68832: PUSH
68833: EMPTY
68834: LIST
68835: LIST
68836: PUSH
68837: EMPTY
68838: LIST
68839: LIST
68840: LIST
68841: LIST
68842: LIST
68843: LIST
68844: LIST
68845: LIST
68846: LIST
68847: LIST
68848: LIST
68849: LIST
68850: LIST
68851: LIST
68852: LIST
68853: LIST
68854: LIST
68855: LIST
68856: LIST
68857: LIST
68858: LIST
68859: LIST
68860: LIST
68861: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
68862: LD_ADDR_VAR 0 35
68866: PUSH
68867: LD_INT 0
68869: PUSH
68870: LD_INT 0
68872: PUSH
68873: EMPTY
68874: LIST
68875: LIST
68876: PUSH
68877: LD_INT 0
68879: PUSH
68880: LD_INT 1
68882: NEG
68883: PUSH
68884: EMPTY
68885: LIST
68886: LIST
68887: PUSH
68888: LD_INT 1
68890: PUSH
68891: LD_INT 0
68893: PUSH
68894: EMPTY
68895: LIST
68896: LIST
68897: PUSH
68898: LD_INT 1
68900: PUSH
68901: LD_INT 1
68903: PUSH
68904: EMPTY
68905: LIST
68906: LIST
68907: PUSH
68908: LD_INT 0
68910: PUSH
68911: LD_INT 1
68913: PUSH
68914: EMPTY
68915: LIST
68916: LIST
68917: PUSH
68918: LD_INT 1
68920: NEG
68921: PUSH
68922: LD_INT 0
68924: PUSH
68925: EMPTY
68926: LIST
68927: LIST
68928: PUSH
68929: LD_INT 1
68931: NEG
68932: PUSH
68933: LD_INT 1
68935: NEG
68936: PUSH
68937: EMPTY
68938: LIST
68939: LIST
68940: PUSH
68941: LD_INT 2
68943: PUSH
68944: LD_INT 1
68946: PUSH
68947: EMPTY
68948: LIST
68949: LIST
68950: PUSH
68951: LD_INT 2
68953: NEG
68954: PUSH
68955: LD_INT 1
68957: NEG
68958: PUSH
68959: EMPTY
68960: LIST
68961: LIST
68962: PUSH
68963: EMPTY
68964: LIST
68965: LIST
68966: LIST
68967: LIST
68968: LIST
68969: LIST
68970: LIST
68971: LIST
68972: LIST
68973: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
68974: LD_ADDR_VAR 0 36
68978: PUSH
68979: LD_INT 0
68981: PUSH
68982: LD_INT 0
68984: PUSH
68985: EMPTY
68986: LIST
68987: LIST
68988: PUSH
68989: LD_INT 0
68991: PUSH
68992: LD_INT 1
68994: NEG
68995: PUSH
68996: EMPTY
68997: LIST
68998: LIST
68999: PUSH
69000: LD_INT 1
69002: PUSH
69003: LD_INT 0
69005: PUSH
69006: EMPTY
69007: LIST
69008: LIST
69009: PUSH
69010: LD_INT 1
69012: PUSH
69013: LD_INT 1
69015: PUSH
69016: EMPTY
69017: LIST
69018: LIST
69019: PUSH
69020: LD_INT 0
69022: PUSH
69023: LD_INT 1
69025: PUSH
69026: EMPTY
69027: LIST
69028: LIST
69029: PUSH
69030: LD_INT 1
69032: NEG
69033: PUSH
69034: LD_INT 0
69036: PUSH
69037: EMPTY
69038: LIST
69039: LIST
69040: PUSH
69041: LD_INT 1
69043: NEG
69044: PUSH
69045: LD_INT 1
69047: NEG
69048: PUSH
69049: EMPTY
69050: LIST
69051: LIST
69052: PUSH
69053: LD_INT 1
69055: NEG
69056: PUSH
69057: LD_INT 2
69059: NEG
69060: PUSH
69061: EMPTY
69062: LIST
69063: LIST
69064: PUSH
69065: LD_INT 1
69067: PUSH
69068: LD_INT 2
69070: PUSH
69071: EMPTY
69072: LIST
69073: LIST
69074: PUSH
69075: EMPTY
69076: LIST
69077: LIST
69078: LIST
69079: LIST
69080: LIST
69081: LIST
69082: LIST
69083: LIST
69084: LIST
69085: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
69086: LD_ADDR_VAR 0 37
69090: PUSH
69091: LD_INT 0
69093: PUSH
69094: LD_INT 0
69096: PUSH
69097: EMPTY
69098: LIST
69099: LIST
69100: PUSH
69101: LD_INT 0
69103: PUSH
69104: LD_INT 1
69106: NEG
69107: PUSH
69108: EMPTY
69109: LIST
69110: LIST
69111: PUSH
69112: LD_INT 1
69114: PUSH
69115: LD_INT 0
69117: PUSH
69118: EMPTY
69119: LIST
69120: LIST
69121: PUSH
69122: LD_INT 1
69124: PUSH
69125: LD_INT 1
69127: PUSH
69128: EMPTY
69129: LIST
69130: LIST
69131: PUSH
69132: LD_INT 0
69134: PUSH
69135: LD_INT 1
69137: PUSH
69138: EMPTY
69139: LIST
69140: LIST
69141: PUSH
69142: LD_INT 1
69144: NEG
69145: PUSH
69146: LD_INT 0
69148: PUSH
69149: EMPTY
69150: LIST
69151: LIST
69152: PUSH
69153: LD_INT 1
69155: NEG
69156: PUSH
69157: LD_INT 1
69159: NEG
69160: PUSH
69161: EMPTY
69162: LIST
69163: LIST
69164: PUSH
69165: LD_INT 1
69167: PUSH
69168: LD_INT 1
69170: NEG
69171: PUSH
69172: EMPTY
69173: LIST
69174: LIST
69175: PUSH
69176: LD_INT 1
69178: NEG
69179: PUSH
69180: LD_INT 1
69182: PUSH
69183: EMPTY
69184: LIST
69185: LIST
69186: PUSH
69187: EMPTY
69188: LIST
69189: LIST
69190: LIST
69191: LIST
69192: LIST
69193: LIST
69194: LIST
69195: LIST
69196: LIST
69197: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
69198: LD_ADDR_VAR 0 38
69202: PUSH
69203: LD_INT 0
69205: PUSH
69206: LD_INT 0
69208: PUSH
69209: EMPTY
69210: LIST
69211: LIST
69212: PUSH
69213: LD_INT 0
69215: PUSH
69216: LD_INT 1
69218: NEG
69219: PUSH
69220: EMPTY
69221: LIST
69222: LIST
69223: PUSH
69224: LD_INT 1
69226: PUSH
69227: LD_INT 0
69229: PUSH
69230: EMPTY
69231: LIST
69232: LIST
69233: PUSH
69234: LD_INT 1
69236: PUSH
69237: LD_INT 1
69239: PUSH
69240: EMPTY
69241: LIST
69242: LIST
69243: PUSH
69244: LD_INT 0
69246: PUSH
69247: LD_INT 1
69249: PUSH
69250: EMPTY
69251: LIST
69252: LIST
69253: PUSH
69254: LD_INT 1
69256: NEG
69257: PUSH
69258: LD_INT 0
69260: PUSH
69261: EMPTY
69262: LIST
69263: LIST
69264: PUSH
69265: LD_INT 1
69267: NEG
69268: PUSH
69269: LD_INT 1
69271: NEG
69272: PUSH
69273: EMPTY
69274: LIST
69275: LIST
69276: PUSH
69277: LD_INT 2
69279: PUSH
69280: LD_INT 1
69282: PUSH
69283: EMPTY
69284: LIST
69285: LIST
69286: PUSH
69287: LD_INT 2
69289: NEG
69290: PUSH
69291: LD_INT 1
69293: NEG
69294: PUSH
69295: EMPTY
69296: LIST
69297: LIST
69298: PUSH
69299: EMPTY
69300: LIST
69301: LIST
69302: LIST
69303: LIST
69304: LIST
69305: LIST
69306: LIST
69307: LIST
69308: LIST
69309: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
69310: LD_ADDR_VAR 0 39
69314: PUSH
69315: LD_INT 0
69317: PUSH
69318: LD_INT 0
69320: PUSH
69321: EMPTY
69322: LIST
69323: LIST
69324: PUSH
69325: LD_INT 0
69327: PUSH
69328: LD_INT 1
69330: NEG
69331: PUSH
69332: EMPTY
69333: LIST
69334: LIST
69335: PUSH
69336: LD_INT 1
69338: PUSH
69339: LD_INT 0
69341: PUSH
69342: EMPTY
69343: LIST
69344: LIST
69345: PUSH
69346: LD_INT 1
69348: PUSH
69349: LD_INT 1
69351: PUSH
69352: EMPTY
69353: LIST
69354: LIST
69355: PUSH
69356: LD_INT 0
69358: PUSH
69359: LD_INT 1
69361: PUSH
69362: EMPTY
69363: LIST
69364: LIST
69365: PUSH
69366: LD_INT 1
69368: NEG
69369: PUSH
69370: LD_INT 0
69372: PUSH
69373: EMPTY
69374: LIST
69375: LIST
69376: PUSH
69377: LD_INT 1
69379: NEG
69380: PUSH
69381: LD_INT 1
69383: NEG
69384: PUSH
69385: EMPTY
69386: LIST
69387: LIST
69388: PUSH
69389: LD_INT 1
69391: NEG
69392: PUSH
69393: LD_INT 2
69395: NEG
69396: PUSH
69397: EMPTY
69398: LIST
69399: LIST
69400: PUSH
69401: LD_INT 1
69403: PUSH
69404: LD_INT 2
69406: PUSH
69407: EMPTY
69408: LIST
69409: LIST
69410: PUSH
69411: EMPTY
69412: LIST
69413: LIST
69414: LIST
69415: LIST
69416: LIST
69417: LIST
69418: LIST
69419: LIST
69420: LIST
69421: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
69422: LD_ADDR_VAR 0 40
69426: PUSH
69427: LD_INT 0
69429: PUSH
69430: LD_INT 0
69432: PUSH
69433: EMPTY
69434: LIST
69435: LIST
69436: PUSH
69437: LD_INT 0
69439: PUSH
69440: LD_INT 1
69442: NEG
69443: PUSH
69444: EMPTY
69445: LIST
69446: LIST
69447: PUSH
69448: LD_INT 1
69450: PUSH
69451: LD_INT 0
69453: PUSH
69454: EMPTY
69455: LIST
69456: LIST
69457: PUSH
69458: LD_INT 1
69460: PUSH
69461: LD_INT 1
69463: PUSH
69464: EMPTY
69465: LIST
69466: LIST
69467: PUSH
69468: LD_INT 0
69470: PUSH
69471: LD_INT 1
69473: PUSH
69474: EMPTY
69475: LIST
69476: LIST
69477: PUSH
69478: LD_INT 1
69480: NEG
69481: PUSH
69482: LD_INT 0
69484: PUSH
69485: EMPTY
69486: LIST
69487: LIST
69488: PUSH
69489: LD_INT 1
69491: NEG
69492: PUSH
69493: LD_INT 1
69495: NEG
69496: PUSH
69497: EMPTY
69498: LIST
69499: LIST
69500: PUSH
69501: LD_INT 1
69503: PUSH
69504: LD_INT 1
69506: NEG
69507: PUSH
69508: EMPTY
69509: LIST
69510: LIST
69511: PUSH
69512: LD_INT 1
69514: NEG
69515: PUSH
69516: LD_INT 1
69518: PUSH
69519: EMPTY
69520: LIST
69521: LIST
69522: PUSH
69523: EMPTY
69524: LIST
69525: LIST
69526: LIST
69527: LIST
69528: LIST
69529: LIST
69530: LIST
69531: LIST
69532: LIST
69533: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
69534: LD_ADDR_VAR 0 41
69538: PUSH
69539: LD_INT 0
69541: PUSH
69542: LD_INT 0
69544: PUSH
69545: EMPTY
69546: LIST
69547: LIST
69548: PUSH
69549: LD_INT 0
69551: PUSH
69552: LD_INT 1
69554: NEG
69555: PUSH
69556: EMPTY
69557: LIST
69558: LIST
69559: PUSH
69560: LD_INT 1
69562: PUSH
69563: LD_INT 0
69565: PUSH
69566: EMPTY
69567: LIST
69568: LIST
69569: PUSH
69570: LD_INT 1
69572: PUSH
69573: LD_INT 1
69575: PUSH
69576: EMPTY
69577: LIST
69578: LIST
69579: PUSH
69580: LD_INT 0
69582: PUSH
69583: LD_INT 1
69585: PUSH
69586: EMPTY
69587: LIST
69588: LIST
69589: PUSH
69590: LD_INT 1
69592: NEG
69593: PUSH
69594: LD_INT 0
69596: PUSH
69597: EMPTY
69598: LIST
69599: LIST
69600: PUSH
69601: LD_INT 1
69603: NEG
69604: PUSH
69605: LD_INT 1
69607: NEG
69608: PUSH
69609: EMPTY
69610: LIST
69611: LIST
69612: PUSH
69613: LD_INT 1
69615: NEG
69616: PUSH
69617: LD_INT 2
69619: NEG
69620: PUSH
69621: EMPTY
69622: LIST
69623: LIST
69624: PUSH
69625: LD_INT 1
69627: PUSH
69628: LD_INT 1
69630: NEG
69631: PUSH
69632: EMPTY
69633: LIST
69634: LIST
69635: PUSH
69636: LD_INT 2
69638: PUSH
69639: LD_INT 0
69641: PUSH
69642: EMPTY
69643: LIST
69644: LIST
69645: PUSH
69646: LD_INT 2
69648: PUSH
69649: LD_INT 1
69651: PUSH
69652: EMPTY
69653: LIST
69654: LIST
69655: PUSH
69656: LD_INT 2
69658: PUSH
69659: LD_INT 2
69661: PUSH
69662: EMPTY
69663: LIST
69664: LIST
69665: PUSH
69666: LD_INT 1
69668: PUSH
69669: LD_INT 2
69671: PUSH
69672: EMPTY
69673: LIST
69674: LIST
69675: PUSH
69676: LD_INT 1
69678: NEG
69679: PUSH
69680: LD_INT 1
69682: PUSH
69683: EMPTY
69684: LIST
69685: LIST
69686: PUSH
69687: LD_INT 2
69689: NEG
69690: PUSH
69691: LD_INT 0
69693: PUSH
69694: EMPTY
69695: LIST
69696: LIST
69697: PUSH
69698: LD_INT 2
69700: NEG
69701: PUSH
69702: LD_INT 1
69704: NEG
69705: PUSH
69706: EMPTY
69707: LIST
69708: LIST
69709: PUSH
69710: LD_INT 2
69712: NEG
69713: PUSH
69714: LD_INT 2
69716: NEG
69717: PUSH
69718: EMPTY
69719: LIST
69720: LIST
69721: PUSH
69722: LD_INT 2
69724: NEG
69725: PUSH
69726: LD_INT 3
69728: NEG
69729: PUSH
69730: EMPTY
69731: LIST
69732: LIST
69733: PUSH
69734: LD_INT 2
69736: PUSH
69737: LD_INT 1
69739: NEG
69740: PUSH
69741: EMPTY
69742: LIST
69743: LIST
69744: PUSH
69745: LD_INT 3
69747: PUSH
69748: LD_INT 0
69750: PUSH
69751: EMPTY
69752: LIST
69753: LIST
69754: PUSH
69755: LD_INT 3
69757: PUSH
69758: LD_INT 1
69760: PUSH
69761: EMPTY
69762: LIST
69763: LIST
69764: PUSH
69765: LD_INT 3
69767: PUSH
69768: LD_INT 2
69770: PUSH
69771: EMPTY
69772: LIST
69773: LIST
69774: PUSH
69775: LD_INT 3
69777: PUSH
69778: LD_INT 3
69780: PUSH
69781: EMPTY
69782: LIST
69783: LIST
69784: PUSH
69785: LD_INT 2
69787: PUSH
69788: LD_INT 3
69790: PUSH
69791: EMPTY
69792: LIST
69793: LIST
69794: PUSH
69795: LD_INT 2
69797: NEG
69798: PUSH
69799: LD_INT 1
69801: PUSH
69802: EMPTY
69803: LIST
69804: LIST
69805: PUSH
69806: LD_INT 3
69808: NEG
69809: PUSH
69810: LD_INT 0
69812: PUSH
69813: EMPTY
69814: LIST
69815: LIST
69816: PUSH
69817: LD_INT 3
69819: NEG
69820: PUSH
69821: LD_INT 1
69823: NEG
69824: PUSH
69825: EMPTY
69826: LIST
69827: LIST
69828: PUSH
69829: LD_INT 3
69831: NEG
69832: PUSH
69833: LD_INT 2
69835: NEG
69836: PUSH
69837: EMPTY
69838: LIST
69839: LIST
69840: PUSH
69841: LD_INT 3
69843: NEG
69844: PUSH
69845: LD_INT 3
69847: NEG
69848: PUSH
69849: EMPTY
69850: LIST
69851: LIST
69852: PUSH
69853: EMPTY
69854: LIST
69855: LIST
69856: LIST
69857: LIST
69858: LIST
69859: LIST
69860: LIST
69861: LIST
69862: LIST
69863: LIST
69864: LIST
69865: LIST
69866: LIST
69867: LIST
69868: LIST
69869: LIST
69870: LIST
69871: LIST
69872: LIST
69873: LIST
69874: LIST
69875: LIST
69876: LIST
69877: LIST
69878: LIST
69879: LIST
69880: LIST
69881: LIST
69882: LIST
69883: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
69884: LD_ADDR_VAR 0 42
69888: PUSH
69889: LD_INT 0
69891: PUSH
69892: LD_INT 0
69894: PUSH
69895: EMPTY
69896: LIST
69897: LIST
69898: PUSH
69899: LD_INT 0
69901: PUSH
69902: LD_INT 1
69904: NEG
69905: PUSH
69906: EMPTY
69907: LIST
69908: LIST
69909: PUSH
69910: LD_INT 1
69912: PUSH
69913: LD_INT 0
69915: PUSH
69916: EMPTY
69917: LIST
69918: LIST
69919: PUSH
69920: LD_INT 1
69922: PUSH
69923: LD_INT 1
69925: PUSH
69926: EMPTY
69927: LIST
69928: LIST
69929: PUSH
69930: LD_INT 0
69932: PUSH
69933: LD_INT 1
69935: PUSH
69936: EMPTY
69937: LIST
69938: LIST
69939: PUSH
69940: LD_INT 1
69942: NEG
69943: PUSH
69944: LD_INT 0
69946: PUSH
69947: EMPTY
69948: LIST
69949: LIST
69950: PUSH
69951: LD_INT 1
69953: NEG
69954: PUSH
69955: LD_INT 1
69957: NEG
69958: PUSH
69959: EMPTY
69960: LIST
69961: LIST
69962: PUSH
69963: LD_INT 1
69965: NEG
69966: PUSH
69967: LD_INT 2
69969: NEG
69970: PUSH
69971: EMPTY
69972: LIST
69973: LIST
69974: PUSH
69975: LD_INT 0
69977: PUSH
69978: LD_INT 2
69980: NEG
69981: PUSH
69982: EMPTY
69983: LIST
69984: LIST
69985: PUSH
69986: LD_INT 1
69988: PUSH
69989: LD_INT 1
69991: NEG
69992: PUSH
69993: EMPTY
69994: LIST
69995: LIST
69996: PUSH
69997: LD_INT 2
69999: PUSH
70000: LD_INT 1
70002: PUSH
70003: EMPTY
70004: LIST
70005: LIST
70006: PUSH
70007: LD_INT 2
70009: PUSH
70010: LD_INT 2
70012: PUSH
70013: EMPTY
70014: LIST
70015: LIST
70016: PUSH
70017: LD_INT 1
70019: PUSH
70020: LD_INT 2
70022: PUSH
70023: EMPTY
70024: LIST
70025: LIST
70026: PUSH
70027: LD_INT 0
70029: PUSH
70030: LD_INT 2
70032: PUSH
70033: EMPTY
70034: LIST
70035: LIST
70036: PUSH
70037: LD_INT 1
70039: NEG
70040: PUSH
70041: LD_INT 1
70043: PUSH
70044: EMPTY
70045: LIST
70046: LIST
70047: PUSH
70048: LD_INT 2
70050: NEG
70051: PUSH
70052: LD_INT 1
70054: NEG
70055: PUSH
70056: EMPTY
70057: LIST
70058: LIST
70059: PUSH
70060: LD_INT 2
70062: NEG
70063: PUSH
70064: LD_INT 2
70066: NEG
70067: PUSH
70068: EMPTY
70069: LIST
70070: LIST
70071: PUSH
70072: LD_INT 2
70074: NEG
70075: PUSH
70076: LD_INT 3
70078: NEG
70079: PUSH
70080: EMPTY
70081: LIST
70082: LIST
70083: PUSH
70084: LD_INT 1
70086: NEG
70087: PUSH
70088: LD_INT 3
70090: NEG
70091: PUSH
70092: EMPTY
70093: LIST
70094: LIST
70095: PUSH
70096: LD_INT 0
70098: PUSH
70099: LD_INT 3
70101: NEG
70102: PUSH
70103: EMPTY
70104: LIST
70105: LIST
70106: PUSH
70107: LD_INT 1
70109: PUSH
70110: LD_INT 2
70112: NEG
70113: PUSH
70114: EMPTY
70115: LIST
70116: LIST
70117: PUSH
70118: LD_INT 3
70120: PUSH
70121: LD_INT 2
70123: PUSH
70124: EMPTY
70125: LIST
70126: LIST
70127: PUSH
70128: LD_INT 3
70130: PUSH
70131: LD_INT 3
70133: PUSH
70134: EMPTY
70135: LIST
70136: LIST
70137: PUSH
70138: LD_INT 2
70140: PUSH
70141: LD_INT 3
70143: PUSH
70144: EMPTY
70145: LIST
70146: LIST
70147: PUSH
70148: LD_INT 1
70150: PUSH
70151: LD_INT 3
70153: PUSH
70154: EMPTY
70155: LIST
70156: LIST
70157: PUSH
70158: LD_INT 0
70160: PUSH
70161: LD_INT 3
70163: PUSH
70164: EMPTY
70165: LIST
70166: LIST
70167: PUSH
70168: LD_INT 1
70170: NEG
70171: PUSH
70172: LD_INT 2
70174: PUSH
70175: EMPTY
70176: LIST
70177: LIST
70178: PUSH
70179: LD_INT 3
70181: NEG
70182: PUSH
70183: LD_INT 2
70185: NEG
70186: PUSH
70187: EMPTY
70188: LIST
70189: LIST
70190: PUSH
70191: LD_INT 3
70193: NEG
70194: PUSH
70195: LD_INT 3
70197: NEG
70198: PUSH
70199: EMPTY
70200: LIST
70201: LIST
70202: PUSH
70203: EMPTY
70204: LIST
70205: LIST
70206: LIST
70207: LIST
70208: LIST
70209: LIST
70210: LIST
70211: LIST
70212: LIST
70213: LIST
70214: LIST
70215: LIST
70216: LIST
70217: LIST
70218: LIST
70219: LIST
70220: LIST
70221: LIST
70222: LIST
70223: LIST
70224: LIST
70225: LIST
70226: LIST
70227: LIST
70228: LIST
70229: LIST
70230: LIST
70231: LIST
70232: LIST
70233: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
70234: LD_ADDR_VAR 0 43
70238: PUSH
70239: LD_INT 0
70241: PUSH
70242: LD_INT 0
70244: PUSH
70245: EMPTY
70246: LIST
70247: LIST
70248: PUSH
70249: LD_INT 0
70251: PUSH
70252: LD_INT 1
70254: NEG
70255: PUSH
70256: EMPTY
70257: LIST
70258: LIST
70259: PUSH
70260: LD_INT 1
70262: PUSH
70263: LD_INT 0
70265: PUSH
70266: EMPTY
70267: LIST
70268: LIST
70269: PUSH
70270: LD_INT 1
70272: PUSH
70273: LD_INT 1
70275: PUSH
70276: EMPTY
70277: LIST
70278: LIST
70279: PUSH
70280: LD_INT 0
70282: PUSH
70283: LD_INT 1
70285: PUSH
70286: EMPTY
70287: LIST
70288: LIST
70289: PUSH
70290: LD_INT 1
70292: NEG
70293: PUSH
70294: LD_INT 0
70296: PUSH
70297: EMPTY
70298: LIST
70299: LIST
70300: PUSH
70301: LD_INT 1
70303: NEG
70304: PUSH
70305: LD_INT 1
70307: NEG
70308: PUSH
70309: EMPTY
70310: LIST
70311: LIST
70312: PUSH
70313: LD_INT 1
70315: NEG
70316: PUSH
70317: LD_INT 2
70319: NEG
70320: PUSH
70321: EMPTY
70322: LIST
70323: LIST
70324: PUSH
70325: LD_INT 0
70327: PUSH
70328: LD_INT 2
70330: NEG
70331: PUSH
70332: EMPTY
70333: LIST
70334: LIST
70335: PUSH
70336: LD_INT 1
70338: PUSH
70339: LD_INT 1
70341: NEG
70342: PUSH
70343: EMPTY
70344: LIST
70345: LIST
70346: PUSH
70347: LD_INT 2
70349: PUSH
70350: LD_INT 0
70352: PUSH
70353: EMPTY
70354: LIST
70355: LIST
70356: PUSH
70357: LD_INT 2
70359: PUSH
70360: LD_INT 1
70362: PUSH
70363: EMPTY
70364: LIST
70365: LIST
70366: PUSH
70367: LD_INT 1
70369: PUSH
70370: LD_INT 2
70372: PUSH
70373: EMPTY
70374: LIST
70375: LIST
70376: PUSH
70377: LD_INT 0
70379: PUSH
70380: LD_INT 2
70382: PUSH
70383: EMPTY
70384: LIST
70385: LIST
70386: PUSH
70387: LD_INT 1
70389: NEG
70390: PUSH
70391: LD_INT 1
70393: PUSH
70394: EMPTY
70395: LIST
70396: LIST
70397: PUSH
70398: LD_INT 2
70400: NEG
70401: PUSH
70402: LD_INT 0
70404: PUSH
70405: EMPTY
70406: LIST
70407: LIST
70408: PUSH
70409: LD_INT 2
70411: NEG
70412: PUSH
70413: LD_INT 1
70415: NEG
70416: PUSH
70417: EMPTY
70418: LIST
70419: LIST
70420: PUSH
70421: LD_INT 1
70423: NEG
70424: PUSH
70425: LD_INT 3
70427: NEG
70428: PUSH
70429: EMPTY
70430: LIST
70431: LIST
70432: PUSH
70433: LD_INT 0
70435: PUSH
70436: LD_INT 3
70438: NEG
70439: PUSH
70440: EMPTY
70441: LIST
70442: LIST
70443: PUSH
70444: LD_INT 1
70446: PUSH
70447: LD_INT 2
70449: NEG
70450: PUSH
70451: EMPTY
70452: LIST
70453: LIST
70454: PUSH
70455: LD_INT 2
70457: PUSH
70458: LD_INT 1
70460: NEG
70461: PUSH
70462: EMPTY
70463: LIST
70464: LIST
70465: PUSH
70466: LD_INT 3
70468: PUSH
70469: LD_INT 0
70471: PUSH
70472: EMPTY
70473: LIST
70474: LIST
70475: PUSH
70476: LD_INT 3
70478: PUSH
70479: LD_INT 1
70481: PUSH
70482: EMPTY
70483: LIST
70484: LIST
70485: PUSH
70486: LD_INT 1
70488: PUSH
70489: LD_INT 3
70491: PUSH
70492: EMPTY
70493: LIST
70494: LIST
70495: PUSH
70496: LD_INT 0
70498: PUSH
70499: LD_INT 3
70501: PUSH
70502: EMPTY
70503: LIST
70504: LIST
70505: PUSH
70506: LD_INT 1
70508: NEG
70509: PUSH
70510: LD_INT 2
70512: PUSH
70513: EMPTY
70514: LIST
70515: LIST
70516: PUSH
70517: LD_INT 2
70519: NEG
70520: PUSH
70521: LD_INT 1
70523: PUSH
70524: EMPTY
70525: LIST
70526: LIST
70527: PUSH
70528: LD_INT 3
70530: NEG
70531: PUSH
70532: LD_INT 0
70534: PUSH
70535: EMPTY
70536: LIST
70537: LIST
70538: PUSH
70539: LD_INT 3
70541: NEG
70542: PUSH
70543: LD_INT 1
70545: NEG
70546: PUSH
70547: EMPTY
70548: LIST
70549: LIST
70550: PUSH
70551: EMPTY
70552: LIST
70553: LIST
70554: LIST
70555: LIST
70556: LIST
70557: LIST
70558: LIST
70559: LIST
70560: LIST
70561: LIST
70562: LIST
70563: LIST
70564: LIST
70565: LIST
70566: LIST
70567: LIST
70568: LIST
70569: LIST
70570: LIST
70571: LIST
70572: LIST
70573: LIST
70574: LIST
70575: LIST
70576: LIST
70577: LIST
70578: LIST
70579: LIST
70580: LIST
70581: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70582: LD_ADDR_VAR 0 44
70586: PUSH
70587: LD_INT 0
70589: PUSH
70590: LD_INT 0
70592: PUSH
70593: EMPTY
70594: LIST
70595: LIST
70596: PUSH
70597: LD_INT 0
70599: PUSH
70600: LD_INT 1
70602: NEG
70603: PUSH
70604: EMPTY
70605: LIST
70606: LIST
70607: PUSH
70608: LD_INT 1
70610: PUSH
70611: LD_INT 0
70613: PUSH
70614: EMPTY
70615: LIST
70616: LIST
70617: PUSH
70618: LD_INT 1
70620: PUSH
70621: LD_INT 1
70623: PUSH
70624: EMPTY
70625: LIST
70626: LIST
70627: PUSH
70628: LD_INT 0
70630: PUSH
70631: LD_INT 1
70633: PUSH
70634: EMPTY
70635: LIST
70636: LIST
70637: PUSH
70638: LD_INT 1
70640: NEG
70641: PUSH
70642: LD_INT 0
70644: PUSH
70645: EMPTY
70646: LIST
70647: LIST
70648: PUSH
70649: LD_INT 1
70651: NEG
70652: PUSH
70653: LD_INT 1
70655: NEG
70656: PUSH
70657: EMPTY
70658: LIST
70659: LIST
70660: PUSH
70661: LD_INT 1
70663: NEG
70664: PUSH
70665: LD_INT 2
70667: NEG
70668: PUSH
70669: EMPTY
70670: LIST
70671: LIST
70672: PUSH
70673: LD_INT 1
70675: PUSH
70676: LD_INT 1
70678: NEG
70679: PUSH
70680: EMPTY
70681: LIST
70682: LIST
70683: PUSH
70684: LD_INT 2
70686: PUSH
70687: LD_INT 0
70689: PUSH
70690: EMPTY
70691: LIST
70692: LIST
70693: PUSH
70694: LD_INT 2
70696: PUSH
70697: LD_INT 1
70699: PUSH
70700: EMPTY
70701: LIST
70702: LIST
70703: PUSH
70704: LD_INT 2
70706: PUSH
70707: LD_INT 2
70709: PUSH
70710: EMPTY
70711: LIST
70712: LIST
70713: PUSH
70714: LD_INT 1
70716: PUSH
70717: LD_INT 2
70719: PUSH
70720: EMPTY
70721: LIST
70722: LIST
70723: PUSH
70724: LD_INT 1
70726: NEG
70727: PUSH
70728: LD_INT 1
70730: PUSH
70731: EMPTY
70732: LIST
70733: LIST
70734: PUSH
70735: LD_INT 2
70737: NEG
70738: PUSH
70739: LD_INT 0
70741: PUSH
70742: EMPTY
70743: LIST
70744: LIST
70745: PUSH
70746: LD_INT 2
70748: NEG
70749: PUSH
70750: LD_INT 1
70752: NEG
70753: PUSH
70754: EMPTY
70755: LIST
70756: LIST
70757: PUSH
70758: LD_INT 2
70760: NEG
70761: PUSH
70762: LD_INT 2
70764: NEG
70765: PUSH
70766: EMPTY
70767: LIST
70768: LIST
70769: PUSH
70770: LD_INT 2
70772: NEG
70773: PUSH
70774: LD_INT 3
70776: NEG
70777: PUSH
70778: EMPTY
70779: LIST
70780: LIST
70781: PUSH
70782: LD_INT 2
70784: PUSH
70785: LD_INT 1
70787: NEG
70788: PUSH
70789: EMPTY
70790: LIST
70791: LIST
70792: PUSH
70793: LD_INT 3
70795: PUSH
70796: LD_INT 0
70798: PUSH
70799: EMPTY
70800: LIST
70801: LIST
70802: PUSH
70803: LD_INT 3
70805: PUSH
70806: LD_INT 1
70808: PUSH
70809: EMPTY
70810: LIST
70811: LIST
70812: PUSH
70813: LD_INT 3
70815: PUSH
70816: LD_INT 2
70818: PUSH
70819: EMPTY
70820: LIST
70821: LIST
70822: PUSH
70823: LD_INT 3
70825: PUSH
70826: LD_INT 3
70828: PUSH
70829: EMPTY
70830: LIST
70831: LIST
70832: PUSH
70833: LD_INT 2
70835: PUSH
70836: LD_INT 3
70838: PUSH
70839: EMPTY
70840: LIST
70841: LIST
70842: PUSH
70843: LD_INT 2
70845: NEG
70846: PUSH
70847: LD_INT 1
70849: PUSH
70850: EMPTY
70851: LIST
70852: LIST
70853: PUSH
70854: LD_INT 3
70856: NEG
70857: PUSH
70858: LD_INT 0
70860: PUSH
70861: EMPTY
70862: LIST
70863: LIST
70864: PUSH
70865: LD_INT 3
70867: NEG
70868: PUSH
70869: LD_INT 1
70871: NEG
70872: PUSH
70873: EMPTY
70874: LIST
70875: LIST
70876: PUSH
70877: LD_INT 3
70879: NEG
70880: PUSH
70881: LD_INT 2
70883: NEG
70884: PUSH
70885: EMPTY
70886: LIST
70887: LIST
70888: PUSH
70889: LD_INT 3
70891: NEG
70892: PUSH
70893: LD_INT 3
70895: NEG
70896: PUSH
70897: EMPTY
70898: LIST
70899: LIST
70900: PUSH
70901: EMPTY
70902: LIST
70903: LIST
70904: LIST
70905: LIST
70906: LIST
70907: LIST
70908: LIST
70909: LIST
70910: LIST
70911: LIST
70912: LIST
70913: LIST
70914: LIST
70915: LIST
70916: LIST
70917: LIST
70918: LIST
70919: LIST
70920: LIST
70921: LIST
70922: LIST
70923: LIST
70924: LIST
70925: LIST
70926: LIST
70927: LIST
70928: LIST
70929: LIST
70930: LIST
70931: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70932: LD_ADDR_VAR 0 45
70936: PUSH
70937: LD_INT 0
70939: PUSH
70940: LD_INT 0
70942: PUSH
70943: EMPTY
70944: LIST
70945: LIST
70946: PUSH
70947: LD_INT 0
70949: PUSH
70950: LD_INT 1
70952: NEG
70953: PUSH
70954: EMPTY
70955: LIST
70956: LIST
70957: PUSH
70958: LD_INT 1
70960: PUSH
70961: LD_INT 0
70963: PUSH
70964: EMPTY
70965: LIST
70966: LIST
70967: PUSH
70968: LD_INT 1
70970: PUSH
70971: LD_INT 1
70973: PUSH
70974: EMPTY
70975: LIST
70976: LIST
70977: PUSH
70978: LD_INT 0
70980: PUSH
70981: LD_INT 1
70983: PUSH
70984: EMPTY
70985: LIST
70986: LIST
70987: PUSH
70988: LD_INT 1
70990: NEG
70991: PUSH
70992: LD_INT 0
70994: PUSH
70995: EMPTY
70996: LIST
70997: LIST
70998: PUSH
70999: LD_INT 1
71001: NEG
71002: PUSH
71003: LD_INT 1
71005: NEG
71006: PUSH
71007: EMPTY
71008: LIST
71009: LIST
71010: PUSH
71011: LD_INT 1
71013: NEG
71014: PUSH
71015: LD_INT 2
71017: NEG
71018: PUSH
71019: EMPTY
71020: LIST
71021: LIST
71022: PUSH
71023: LD_INT 0
71025: PUSH
71026: LD_INT 2
71028: NEG
71029: PUSH
71030: EMPTY
71031: LIST
71032: LIST
71033: PUSH
71034: LD_INT 1
71036: PUSH
71037: LD_INT 1
71039: NEG
71040: PUSH
71041: EMPTY
71042: LIST
71043: LIST
71044: PUSH
71045: LD_INT 2
71047: PUSH
71048: LD_INT 1
71050: PUSH
71051: EMPTY
71052: LIST
71053: LIST
71054: PUSH
71055: LD_INT 2
71057: PUSH
71058: LD_INT 2
71060: PUSH
71061: EMPTY
71062: LIST
71063: LIST
71064: PUSH
71065: LD_INT 1
71067: PUSH
71068: LD_INT 2
71070: PUSH
71071: EMPTY
71072: LIST
71073: LIST
71074: PUSH
71075: LD_INT 0
71077: PUSH
71078: LD_INT 2
71080: PUSH
71081: EMPTY
71082: LIST
71083: LIST
71084: PUSH
71085: LD_INT 1
71087: NEG
71088: PUSH
71089: LD_INT 1
71091: PUSH
71092: EMPTY
71093: LIST
71094: LIST
71095: PUSH
71096: LD_INT 2
71098: NEG
71099: PUSH
71100: LD_INT 1
71102: NEG
71103: PUSH
71104: EMPTY
71105: LIST
71106: LIST
71107: PUSH
71108: LD_INT 2
71110: NEG
71111: PUSH
71112: LD_INT 2
71114: NEG
71115: PUSH
71116: EMPTY
71117: LIST
71118: LIST
71119: PUSH
71120: LD_INT 2
71122: NEG
71123: PUSH
71124: LD_INT 3
71126: NEG
71127: PUSH
71128: EMPTY
71129: LIST
71130: LIST
71131: PUSH
71132: LD_INT 1
71134: NEG
71135: PUSH
71136: LD_INT 3
71138: NEG
71139: PUSH
71140: EMPTY
71141: LIST
71142: LIST
71143: PUSH
71144: LD_INT 0
71146: PUSH
71147: LD_INT 3
71149: NEG
71150: PUSH
71151: EMPTY
71152: LIST
71153: LIST
71154: PUSH
71155: LD_INT 1
71157: PUSH
71158: LD_INT 2
71160: NEG
71161: PUSH
71162: EMPTY
71163: LIST
71164: LIST
71165: PUSH
71166: LD_INT 3
71168: PUSH
71169: LD_INT 2
71171: PUSH
71172: EMPTY
71173: LIST
71174: LIST
71175: PUSH
71176: LD_INT 3
71178: PUSH
71179: LD_INT 3
71181: PUSH
71182: EMPTY
71183: LIST
71184: LIST
71185: PUSH
71186: LD_INT 2
71188: PUSH
71189: LD_INT 3
71191: PUSH
71192: EMPTY
71193: LIST
71194: LIST
71195: PUSH
71196: LD_INT 1
71198: PUSH
71199: LD_INT 3
71201: PUSH
71202: EMPTY
71203: LIST
71204: LIST
71205: PUSH
71206: LD_INT 0
71208: PUSH
71209: LD_INT 3
71211: PUSH
71212: EMPTY
71213: LIST
71214: LIST
71215: PUSH
71216: LD_INT 1
71218: NEG
71219: PUSH
71220: LD_INT 2
71222: PUSH
71223: EMPTY
71224: LIST
71225: LIST
71226: PUSH
71227: LD_INT 3
71229: NEG
71230: PUSH
71231: LD_INT 2
71233: NEG
71234: PUSH
71235: EMPTY
71236: LIST
71237: LIST
71238: PUSH
71239: LD_INT 3
71241: NEG
71242: PUSH
71243: LD_INT 3
71245: NEG
71246: PUSH
71247: EMPTY
71248: LIST
71249: LIST
71250: PUSH
71251: EMPTY
71252: LIST
71253: LIST
71254: LIST
71255: LIST
71256: LIST
71257: LIST
71258: LIST
71259: LIST
71260: LIST
71261: LIST
71262: LIST
71263: LIST
71264: LIST
71265: LIST
71266: LIST
71267: LIST
71268: LIST
71269: LIST
71270: LIST
71271: LIST
71272: LIST
71273: LIST
71274: LIST
71275: LIST
71276: LIST
71277: LIST
71278: LIST
71279: LIST
71280: LIST
71281: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
71282: LD_ADDR_VAR 0 46
71286: PUSH
71287: LD_INT 0
71289: PUSH
71290: LD_INT 0
71292: PUSH
71293: EMPTY
71294: LIST
71295: LIST
71296: PUSH
71297: LD_INT 0
71299: PUSH
71300: LD_INT 1
71302: NEG
71303: PUSH
71304: EMPTY
71305: LIST
71306: LIST
71307: PUSH
71308: LD_INT 1
71310: PUSH
71311: LD_INT 0
71313: PUSH
71314: EMPTY
71315: LIST
71316: LIST
71317: PUSH
71318: LD_INT 1
71320: PUSH
71321: LD_INT 1
71323: PUSH
71324: EMPTY
71325: LIST
71326: LIST
71327: PUSH
71328: LD_INT 0
71330: PUSH
71331: LD_INT 1
71333: PUSH
71334: EMPTY
71335: LIST
71336: LIST
71337: PUSH
71338: LD_INT 1
71340: NEG
71341: PUSH
71342: LD_INT 0
71344: PUSH
71345: EMPTY
71346: LIST
71347: LIST
71348: PUSH
71349: LD_INT 1
71351: NEG
71352: PUSH
71353: LD_INT 1
71355: NEG
71356: PUSH
71357: EMPTY
71358: LIST
71359: LIST
71360: PUSH
71361: LD_INT 1
71363: NEG
71364: PUSH
71365: LD_INT 2
71367: NEG
71368: PUSH
71369: EMPTY
71370: LIST
71371: LIST
71372: PUSH
71373: LD_INT 0
71375: PUSH
71376: LD_INT 2
71378: NEG
71379: PUSH
71380: EMPTY
71381: LIST
71382: LIST
71383: PUSH
71384: LD_INT 1
71386: PUSH
71387: LD_INT 1
71389: NEG
71390: PUSH
71391: EMPTY
71392: LIST
71393: LIST
71394: PUSH
71395: LD_INT 2
71397: PUSH
71398: LD_INT 0
71400: PUSH
71401: EMPTY
71402: LIST
71403: LIST
71404: PUSH
71405: LD_INT 2
71407: PUSH
71408: LD_INT 1
71410: PUSH
71411: EMPTY
71412: LIST
71413: LIST
71414: PUSH
71415: LD_INT 1
71417: PUSH
71418: LD_INT 2
71420: PUSH
71421: EMPTY
71422: LIST
71423: LIST
71424: PUSH
71425: LD_INT 0
71427: PUSH
71428: LD_INT 2
71430: PUSH
71431: EMPTY
71432: LIST
71433: LIST
71434: PUSH
71435: LD_INT 1
71437: NEG
71438: PUSH
71439: LD_INT 1
71441: PUSH
71442: EMPTY
71443: LIST
71444: LIST
71445: PUSH
71446: LD_INT 2
71448: NEG
71449: PUSH
71450: LD_INT 0
71452: PUSH
71453: EMPTY
71454: LIST
71455: LIST
71456: PUSH
71457: LD_INT 2
71459: NEG
71460: PUSH
71461: LD_INT 1
71463: NEG
71464: PUSH
71465: EMPTY
71466: LIST
71467: LIST
71468: PUSH
71469: LD_INT 1
71471: NEG
71472: PUSH
71473: LD_INT 3
71475: NEG
71476: PUSH
71477: EMPTY
71478: LIST
71479: LIST
71480: PUSH
71481: LD_INT 0
71483: PUSH
71484: LD_INT 3
71486: NEG
71487: PUSH
71488: EMPTY
71489: LIST
71490: LIST
71491: PUSH
71492: LD_INT 1
71494: PUSH
71495: LD_INT 2
71497: NEG
71498: PUSH
71499: EMPTY
71500: LIST
71501: LIST
71502: PUSH
71503: LD_INT 2
71505: PUSH
71506: LD_INT 1
71508: NEG
71509: PUSH
71510: EMPTY
71511: LIST
71512: LIST
71513: PUSH
71514: LD_INT 3
71516: PUSH
71517: LD_INT 0
71519: PUSH
71520: EMPTY
71521: LIST
71522: LIST
71523: PUSH
71524: LD_INT 3
71526: PUSH
71527: LD_INT 1
71529: PUSH
71530: EMPTY
71531: LIST
71532: LIST
71533: PUSH
71534: LD_INT 1
71536: PUSH
71537: LD_INT 3
71539: PUSH
71540: EMPTY
71541: LIST
71542: LIST
71543: PUSH
71544: LD_INT 0
71546: PUSH
71547: LD_INT 3
71549: PUSH
71550: EMPTY
71551: LIST
71552: LIST
71553: PUSH
71554: LD_INT 1
71556: NEG
71557: PUSH
71558: LD_INT 2
71560: PUSH
71561: EMPTY
71562: LIST
71563: LIST
71564: PUSH
71565: LD_INT 2
71567: NEG
71568: PUSH
71569: LD_INT 1
71571: PUSH
71572: EMPTY
71573: LIST
71574: LIST
71575: PUSH
71576: LD_INT 3
71578: NEG
71579: PUSH
71580: LD_INT 0
71582: PUSH
71583: EMPTY
71584: LIST
71585: LIST
71586: PUSH
71587: LD_INT 3
71589: NEG
71590: PUSH
71591: LD_INT 1
71593: NEG
71594: PUSH
71595: EMPTY
71596: LIST
71597: LIST
71598: PUSH
71599: EMPTY
71600: LIST
71601: LIST
71602: LIST
71603: LIST
71604: LIST
71605: LIST
71606: LIST
71607: LIST
71608: LIST
71609: LIST
71610: LIST
71611: LIST
71612: LIST
71613: LIST
71614: LIST
71615: LIST
71616: LIST
71617: LIST
71618: LIST
71619: LIST
71620: LIST
71621: LIST
71622: LIST
71623: LIST
71624: LIST
71625: LIST
71626: LIST
71627: LIST
71628: LIST
71629: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71630: LD_ADDR_VAR 0 47
71634: PUSH
71635: LD_INT 0
71637: PUSH
71638: LD_INT 0
71640: PUSH
71641: EMPTY
71642: LIST
71643: LIST
71644: PUSH
71645: LD_INT 0
71647: PUSH
71648: LD_INT 1
71650: NEG
71651: PUSH
71652: EMPTY
71653: LIST
71654: LIST
71655: PUSH
71656: LD_INT 1
71658: PUSH
71659: LD_INT 0
71661: PUSH
71662: EMPTY
71663: LIST
71664: LIST
71665: PUSH
71666: LD_INT 1
71668: PUSH
71669: LD_INT 1
71671: PUSH
71672: EMPTY
71673: LIST
71674: LIST
71675: PUSH
71676: LD_INT 0
71678: PUSH
71679: LD_INT 1
71681: PUSH
71682: EMPTY
71683: LIST
71684: LIST
71685: PUSH
71686: LD_INT 1
71688: NEG
71689: PUSH
71690: LD_INT 0
71692: PUSH
71693: EMPTY
71694: LIST
71695: LIST
71696: PUSH
71697: LD_INT 1
71699: NEG
71700: PUSH
71701: LD_INT 1
71703: NEG
71704: PUSH
71705: EMPTY
71706: LIST
71707: LIST
71708: PUSH
71709: LD_INT 1
71711: NEG
71712: PUSH
71713: LD_INT 2
71715: NEG
71716: PUSH
71717: EMPTY
71718: LIST
71719: LIST
71720: PUSH
71721: LD_INT 0
71723: PUSH
71724: LD_INT 2
71726: NEG
71727: PUSH
71728: EMPTY
71729: LIST
71730: LIST
71731: PUSH
71732: LD_INT 1
71734: PUSH
71735: LD_INT 1
71737: NEG
71738: PUSH
71739: EMPTY
71740: LIST
71741: LIST
71742: PUSH
71743: LD_INT 2
71745: NEG
71746: PUSH
71747: LD_INT 1
71749: NEG
71750: PUSH
71751: EMPTY
71752: LIST
71753: LIST
71754: PUSH
71755: LD_INT 2
71757: NEG
71758: PUSH
71759: LD_INT 2
71761: NEG
71762: PUSH
71763: EMPTY
71764: LIST
71765: LIST
71766: PUSH
71767: EMPTY
71768: LIST
71769: LIST
71770: LIST
71771: LIST
71772: LIST
71773: LIST
71774: LIST
71775: LIST
71776: LIST
71777: LIST
71778: LIST
71779: LIST
71780: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
71781: LD_ADDR_VAR 0 48
71785: PUSH
71786: LD_INT 0
71788: PUSH
71789: LD_INT 0
71791: PUSH
71792: EMPTY
71793: LIST
71794: LIST
71795: PUSH
71796: LD_INT 0
71798: PUSH
71799: LD_INT 1
71801: NEG
71802: PUSH
71803: EMPTY
71804: LIST
71805: LIST
71806: PUSH
71807: LD_INT 1
71809: PUSH
71810: LD_INT 0
71812: PUSH
71813: EMPTY
71814: LIST
71815: LIST
71816: PUSH
71817: LD_INT 1
71819: PUSH
71820: LD_INT 1
71822: PUSH
71823: EMPTY
71824: LIST
71825: LIST
71826: PUSH
71827: LD_INT 0
71829: PUSH
71830: LD_INT 1
71832: PUSH
71833: EMPTY
71834: LIST
71835: LIST
71836: PUSH
71837: LD_INT 1
71839: NEG
71840: PUSH
71841: LD_INT 0
71843: PUSH
71844: EMPTY
71845: LIST
71846: LIST
71847: PUSH
71848: LD_INT 1
71850: NEG
71851: PUSH
71852: LD_INT 1
71854: NEG
71855: PUSH
71856: EMPTY
71857: LIST
71858: LIST
71859: PUSH
71860: LD_INT 1
71862: NEG
71863: PUSH
71864: LD_INT 2
71866: NEG
71867: PUSH
71868: EMPTY
71869: LIST
71870: LIST
71871: PUSH
71872: LD_INT 0
71874: PUSH
71875: LD_INT 2
71877: NEG
71878: PUSH
71879: EMPTY
71880: LIST
71881: LIST
71882: PUSH
71883: LD_INT 1
71885: PUSH
71886: LD_INT 1
71888: NEG
71889: PUSH
71890: EMPTY
71891: LIST
71892: LIST
71893: PUSH
71894: LD_INT 2
71896: PUSH
71897: LD_INT 0
71899: PUSH
71900: EMPTY
71901: LIST
71902: LIST
71903: PUSH
71904: LD_INT 2
71906: PUSH
71907: LD_INT 1
71909: PUSH
71910: EMPTY
71911: LIST
71912: LIST
71913: PUSH
71914: EMPTY
71915: LIST
71916: LIST
71917: LIST
71918: LIST
71919: LIST
71920: LIST
71921: LIST
71922: LIST
71923: LIST
71924: LIST
71925: LIST
71926: LIST
71927: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
71928: LD_ADDR_VAR 0 49
71932: PUSH
71933: LD_INT 0
71935: PUSH
71936: LD_INT 0
71938: PUSH
71939: EMPTY
71940: LIST
71941: LIST
71942: PUSH
71943: LD_INT 0
71945: PUSH
71946: LD_INT 1
71948: NEG
71949: PUSH
71950: EMPTY
71951: LIST
71952: LIST
71953: PUSH
71954: LD_INT 1
71956: PUSH
71957: LD_INT 0
71959: PUSH
71960: EMPTY
71961: LIST
71962: LIST
71963: PUSH
71964: LD_INT 1
71966: PUSH
71967: LD_INT 1
71969: PUSH
71970: EMPTY
71971: LIST
71972: LIST
71973: PUSH
71974: LD_INT 0
71976: PUSH
71977: LD_INT 1
71979: PUSH
71980: EMPTY
71981: LIST
71982: LIST
71983: PUSH
71984: LD_INT 1
71986: NEG
71987: PUSH
71988: LD_INT 0
71990: PUSH
71991: EMPTY
71992: LIST
71993: LIST
71994: PUSH
71995: LD_INT 1
71997: NEG
71998: PUSH
71999: LD_INT 1
72001: NEG
72002: PUSH
72003: EMPTY
72004: LIST
72005: LIST
72006: PUSH
72007: LD_INT 1
72009: PUSH
72010: LD_INT 1
72012: NEG
72013: PUSH
72014: EMPTY
72015: LIST
72016: LIST
72017: PUSH
72018: LD_INT 2
72020: PUSH
72021: LD_INT 0
72023: PUSH
72024: EMPTY
72025: LIST
72026: LIST
72027: PUSH
72028: LD_INT 2
72030: PUSH
72031: LD_INT 1
72033: PUSH
72034: EMPTY
72035: LIST
72036: LIST
72037: PUSH
72038: LD_INT 2
72040: PUSH
72041: LD_INT 2
72043: PUSH
72044: EMPTY
72045: LIST
72046: LIST
72047: PUSH
72048: LD_INT 1
72050: PUSH
72051: LD_INT 2
72053: PUSH
72054: EMPTY
72055: LIST
72056: LIST
72057: PUSH
72058: EMPTY
72059: LIST
72060: LIST
72061: LIST
72062: LIST
72063: LIST
72064: LIST
72065: LIST
72066: LIST
72067: LIST
72068: LIST
72069: LIST
72070: LIST
72071: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
72072: LD_ADDR_VAR 0 50
72076: PUSH
72077: LD_INT 0
72079: PUSH
72080: LD_INT 0
72082: PUSH
72083: EMPTY
72084: LIST
72085: LIST
72086: PUSH
72087: LD_INT 0
72089: PUSH
72090: LD_INT 1
72092: NEG
72093: PUSH
72094: EMPTY
72095: LIST
72096: LIST
72097: PUSH
72098: LD_INT 1
72100: PUSH
72101: LD_INT 0
72103: PUSH
72104: EMPTY
72105: LIST
72106: LIST
72107: PUSH
72108: LD_INT 1
72110: PUSH
72111: LD_INT 1
72113: PUSH
72114: EMPTY
72115: LIST
72116: LIST
72117: PUSH
72118: LD_INT 0
72120: PUSH
72121: LD_INT 1
72123: PUSH
72124: EMPTY
72125: LIST
72126: LIST
72127: PUSH
72128: LD_INT 1
72130: NEG
72131: PUSH
72132: LD_INT 0
72134: PUSH
72135: EMPTY
72136: LIST
72137: LIST
72138: PUSH
72139: LD_INT 1
72141: NEG
72142: PUSH
72143: LD_INT 1
72145: NEG
72146: PUSH
72147: EMPTY
72148: LIST
72149: LIST
72150: PUSH
72151: LD_INT 2
72153: PUSH
72154: LD_INT 1
72156: PUSH
72157: EMPTY
72158: LIST
72159: LIST
72160: PUSH
72161: LD_INT 2
72163: PUSH
72164: LD_INT 2
72166: PUSH
72167: EMPTY
72168: LIST
72169: LIST
72170: PUSH
72171: LD_INT 1
72173: PUSH
72174: LD_INT 2
72176: PUSH
72177: EMPTY
72178: LIST
72179: LIST
72180: PUSH
72181: LD_INT 0
72183: PUSH
72184: LD_INT 2
72186: PUSH
72187: EMPTY
72188: LIST
72189: LIST
72190: PUSH
72191: LD_INT 1
72193: NEG
72194: PUSH
72195: LD_INT 1
72197: PUSH
72198: EMPTY
72199: LIST
72200: LIST
72201: PUSH
72202: EMPTY
72203: LIST
72204: LIST
72205: LIST
72206: LIST
72207: LIST
72208: LIST
72209: LIST
72210: LIST
72211: LIST
72212: LIST
72213: LIST
72214: LIST
72215: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
72216: LD_ADDR_VAR 0 51
72220: PUSH
72221: LD_INT 0
72223: PUSH
72224: LD_INT 0
72226: PUSH
72227: EMPTY
72228: LIST
72229: LIST
72230: PUSH
72231: LD_INT 0
72233: PUSH
72234: LD_INT 1
72236: NEG
72237: PUSH
72238: EMPTY
72239: LIST
72240: LIST
72241: PUSH
72242: LD_INT 1
72244: PUSH
72245: LD_INT 0
72247: PUSH
72248: EMPTY
72249: LIST
72250: LIST
72251: PUSH
72252: LD_INT 1
72254: PUSH
72255: LD_INT 1
72257: PUSH
72258: EMPTY
72259: LIST
72260: LIST
72261: PUSH
72262: LD_INT 0
72264: PUSH
72265: LD_INT 1
72267: PUSH
72268: EMPTY
72269: LIST
72270: LIST
72271: PUSH
72272: LD_INT 1
72274: NEG
72275: PUSH
72276: LD_INT 0
72278: PUSH
72279: EMPTY
72280: LIST
72281: LIST
72282: PUSH
72283: LD_INT 1
72285: NEG
72286: PUSH
72287: LD_INT 1
72289: NEG
72290: PUSH
72291: EMPTY
72292: LIST
72293: LIST
72294: PUSH
72295: LD_INT 1
72297: PUSH
72298: LD_INT 2
72300: PUSH
72301: EMPTY
72302: LIST
72303: LIST
72304: PUSH
72305: LD_INT 0
72307: PUSH
72308: LD_INT 2
72310: PUSH
72311: EMPTY
72312: LIST
72313: LIST
72314: PUSH
72315: LD_INT 1
72317: NEG
72318: PUSH
72319: LD_INT 1
72321: PUSH
72322: EMPTY
72323: LIST
72324: LIST
72325: PUSH
72326: LD_INT 2
72328: NEG
72329: PUSH
72330: LD_INT 0
72332: PUSH
72333: EMPTY
72334: LIST
72335: LIST
72336: PUSH
72337: LD_INT 2
72339: NEG
72340: PUSH
72341: LD_INT 1
72343: NEG
72344: PUSH
72345: EMPTY
72346: LIST
72347: LIST
72348: PUSH
72349: EMPTY
72350: LIST
72351: LIST
72352: LIST
72353: LIST
72354: LIST
72355: LIST
72356: LIST
72357: LIST
72358: LIST
72359: LIST
72360: LIST
72361: LIST
72362: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72363: LD_ADDR_VAR 0 52
72367: PUSH
72368: LD_INT 0
72370: PUSH
72371: LD_INT 0
72373: PUSH
72374: EMPTY
72375: LIST
72376: LIST
72377: PUSH
72378: LD_INT 0
72380: PUSH
72381: LD_INT 1
72383: NEG
72384: PUSH
72385: EMPTY
72386: LIST
72387: LIST
72388: PUSH
72389: LD_INT 1
72391: PUSH
72392: LD_INT 0
72394: PUSH
72395: EMPTY
72396: LIST
72397: LIST
72398: PUSH
72399: LD_INT 1
72401: PUSH
72402: LD_INT 1
72404: PUSH
72405: EMPTY
72406: LIST
72407: LIST
72408: PUSH
72409: LD_INT 0
72411: PUSH
72412: LD_INT 1
72414: PUSH
72415: EMPTY
72416: LIST
72417: LIST
72418: PUSH
72419: LD_INT 1
72421: NEG
72422: PUSH
72423: LD_INT 0
72425: PUSH
72426: EMPTY
72427: LIST
72428: LIST
72429: PUSH
72430: LD_INT 1
72432: NEG
72433: PUSH
72434: LD_INT 1
72436: NEG
72437: PUSH
72438: EMPTY
72439: LIST
72440: LIST
72441: PUSH
72442: LD_INT 1
72444: NEG
72445: PUSH
72446: LD_INT 2
72448: NEG
72449: PUSH
72450: EMPTY
72451: LIST
72452: LIST
72453: PUSH
72454: LD_INT 1
72456: NEG
72457: PUSH
72458: LD_INT 1
72460: PUSH
72461: EMPTY
72462: LIST
72463: LIST
72464: PUSH
72465: LD_INT 2
72467: NEG
72468: PUSH
72469: LD_INT 0
72471: PUSH
72472: EMPTY
72473: LIST
72474: LIST
72475: PUSH
72476: LD_INT 2
72478: NEG
72479: PUSH
72480: LD_INT 1
72482: NEG
72483: PUSH
72484: EMPTY
72485: LIST
72486: LIST
72487: PUSH
72488: LD_INT 2
72490: NEG
72491: PUSH
72492: LD_INT 2
72494: NEG
72495: PUSH
72496: EMPTY
72497: LIST
72498: LIST
72499: PUSH
72500: EMPTY
72501: LIST
72502: LIST
72503: LIST
72504: LIST
72505: LIST
72506: LIST
72507: LIST
72508: LIST
72509: LIST
72510: LIST
72511: LIST
72512: LIST
72513: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72514: LD_ADDR_VAR 0 53
72518: PUSH
72519: LD_INT 0
72521: PUSH
72522: LD_INT 0
72524: PUSH
72525: EMPTY
72526: LIST
72527: LIST
72528: PUSH
72529: LD_INT 0
72531: PUSH
72532: LD_INT 1
72534: NEG
72535: PUSH
72536: EMPTY
72537: LIST
72538: LIST
72539: PUSH
72540: LD_INT 1
72542: PUSH
72543: LD_INT 0
72545: PUSH
72546: EMPTY
72547: LIST
72548: LIST
72549: PUSH
72550: LD_INT 1
72552: PUSH
72553: LD_INT 1
72555: PUSH
72556: EMPTY
72557: LIST
72558: LIST
72559: PUSH
72560: LD_INT 0
72562: PUSH
72563: LD_INT 1
72565: PUSH
72566: EMPTY
72567: LIST
72568: LIST
72569: PUSH
72570: LD_INT 1
72572: NEG
72573: PUSH
72574: LD_INT 0
72576: PUSH
72577: EMPTY
72578: LIST
72579: LIST
72580: PUSH
72581: LD_INT 1
72583: NEG
72584: PUSH
72585: LD_INT 1
72587: NEG
72588: PUSH
72589: EMPTY
72590: LIST
72591: LIST
72592: PUSH
72593: LD_INT 1
72595: NEG
72596: PUSH
72597: LD_INT 2
72599: NEG
72600: PUSH
72601: EMPTY
72602: LIST
72603: LIST
72604: PUSH
72605: LD_INT 0
72607: PUSH
72608: LD_INT 2
72610: NEG
72611: PUSH
72612: EMPTY
72613: LIST
72614: LIST
72615: PUSH
72616: LD_INT 1
72618: PUSH
72619: LD_INT 1
72621: NEG
72622: PUSH
72623: EMPTY
72624: LIST
72625: LIST
72626: PUSH
72627: LD_INT 2
72629: PUSH
72630: LD_INT 0
72632: PUSH
72633: EMPTY
72634: LIST
72635: LIST
72636: PUSH
72637: LD_INT 2
72639: PUSH
72640: LD_INT 1
72642: PUSH
72643: EMPTY
72644: LIST
72645: LIST
72646: PUSH
72647: LD_INT 2
72649: PUSH
72650: LD_INT 2
72652: PUSH
72653: EMPTY
72654: LIST
72655: LIST
72656: PUSH
72657: LD_INT 1
72659: PUSH
72660: LD_INT 2
72662: PUSH
72663: EMPTY
72664: LIST
72665: LIST
72666: PUSH
72667: LD_INT 0
72669: PUSH
72670: LD_INT 2
72672: PUSH
72673: EMPTY
72674: LIST
72675: LIST
72676: PUSH
72677: LD_INT 1
72679: NEG
72680: PUSH
72681: LD_INT 1
72683: PUSH
72684: EMPTY
72685: LIST
72686: LIST
72687: PUSH
72688: LD_INT 2
72690: NEG
72691: PUSH
72692: LD_INT 0
72694: PUSH
72695: EMPTY
72696: LIST
72697: LIST
72698: PUSH
72699: LD_INT 2
72701: NEG
72702: PUSH
72703: LD_INT 1
72705: NEG
72706: PUSH
72707: EMPTY
72708: LIST
72709: LIST
72710: PUSH
72711: LD_INT 2
72713: NEG
72714: PUSH
72715: LD_INT 2
72717: NEG
72718: PUSH
72719: EMPTY
72720: LIST
72721: LIST
72722: PUSH
72723: EMPTY
72724: LIST
72725: LIST
72726: LIST
72727: LIST
72728: LIST
72729: LIST
72730: LIST
72731: LIST
72732: LIST
72733: LIST
72734: LIST
72735: LIST
72736: LIST
72737: LIST
72738: LIST
72739: LIST
72740: LIST
72741: LIST
72742: LIST
72743: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72744: LD_ADDR_VAR 0 54
72748: PUSH
72749: LD_INT 0
72751: PUSH
72752: LD_INT 0
72754: PUSH
72755: EMPTY
72756: LIST
72757: LIST
72758: PUSH
72759: LD_INT 0
72761: PUSH
72762: LD_INT 1
72764: NEG
72765: PUSH
72766: EMPTY
72767: LIST
72768: LIST
72769: PUSH
72770: LD_INT 1
72772: PUSH
72773: LD_INT 0
72775: PUSH
72776: EMPTY
72777: LIST
72778: LIST
72779: PUSH
72780: LD_INT 1
72782: PUSH
72783: LD_INT 1
72785: PUSH
72786: EMPTY
72787: LIST
72788: LIST
72789: PUSH
72790: LD_INT 0
72792: PUSH
72793: LD_INT 1
72795: PUSH
72796: EMPTY
72797: LIST
72798: LIST
72799: PUSH
72800: LD_INT 1
72802: NEG
72803: PUSH
72804: LD_INT 0
72806: PUSH
72807: EMPTY
72808: LIST
72809: LIST
72810: PUSH
72811: LD_INT 1
72813: NEG
72814: PUSH
72815: LD_INT 1
72817: NEG
72818: PUSH
72819: EMPTY
72820: LIST
72821: LIST
72822: PUSH
72823: LD_INT 1
72825: NEG
72826: PUSH
72827: LD_INT 2
72829: NEG
72830: PUSH
72831: EMPTY
72832: LIST
72833: LIST
72834: PUSH
72835: LD_INT 0
72837: PUSH
72838: LD_INT 2
72840: NEG
72841: PUSH
72842: EMPTY
72843: LIST
72844: LIST
72845: PUSH
72846: LD_INT 1
72848: PUSH
72849: LD_INT 1
72851: NEG
72852: PUSH
72853: EMPTY
72854: LIST
72855: LIST
72856: PUSH
72857: LD_INT 2
72859: PUSH
72860: LD_INT 0
72862: PUSH
72863: EMPTY
72864: LIST
72865: LIST
72866: PUSH
72867: LD_INT 2
72869: PUSH
72870: LD_INT 1
72872: PUSH
72873: EMPTY
72874: LIST
72875: LIST
72876: PUSH
72877: LD_INT 2
72879: PUSH
72880: LD_INT 2
72882: PUSH
72883: EMPTY
72884: LIST
72885: LIST
72886: PUSH
72887: LD_INT 1
72889: PUSH
72890: LD_INT 2
72892: PUSH
72893: EMPTY
72894: LIST
72895: LIST
72896: PUSH
72897: LD_INT 0
72899: PUSH
72900: LD_INT 2
72902: PUSH
72903: EMPTY
72904: LIST
72905: LIST
72906: PUSH
72907: LD_INT 1
72909: NEG
72910: PUSH
72911: LD_INT 1
72913: PUSH
72914: EMPTY
72915: LIST
72916: LIST
72917: PUSH
72918: LD_INT 2
72920: NEG
72921: PUSH
72922: LD_INT 0
72924: PUSH
72925: EMPTY
72926: LIST
72927: LIST
72928: PUSH
72929: LD_INT 2
72931: NEG
72932: PUSH
72933: LD_INT 1
72935: NEG
72936: PUSH
72937: EMPTY
72938: LIST
72939: LIST
72940: PUSH
72941: LD_INT 2
72943: NEG
72944: PUSH
72945: LD_INT 2
72947: NEG
72948: PUSH
72949: EMPTY
72950: LIST
72951: LIST
72952: PUSH
72953: EMPTY
72954: LIST
72955: LIST
72956: LIST
72957: LIST
72958: LIST
72959: LIST
72960: LIST
72961: LIST
72962: LIST
72963: LIST
72964: LIST
72965: LIST
72966: LIST
72967: LIST
72968: LIST
72969: LIST
72970: LIST
72971: LIST
72972: LIST
72973: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72974: LD_ADDR_VAR 0 55
72978: PUSH
72979: LD_INT 0
72981: PUSH
72982: LD_INT 0
72984: PUSH
72985: EMPTY
72986: LIST
72987: LIST
72988: PUSH
72989: LD_INT 0
72991: PUSH
72992: LD_INT 1
72994: NEG
72995: PUSH
72996: EMPTY
72997: LIST
72998: LIST
72999: PUSH
73000: LD_INT 1
73002: PUSH
73003: LD_INT 0
73005: PUSH
73006: EMPTY
73007: LIST
73008: LIST
73009: PUSH
73010: LD_INT 1
73012: PUSH
73013: LD_INT 1
73015: PUSH
73016: EMPTY
73017: LIST
73018: LIST
73019: PUSH
73020: LD_INT 0
73022: PUSH
73023: LD_INT 1
73025: PUSH
73026: EMPTY
73027: LIST
73028: LIST
73029: PUSH
73030: LD_INT 1
73032: NEG
73033: PUSH
73034: LD_INT 0
73036: PUSH
73037: EMPTY
73038: LIST
73039: LIST
73040: PUSH
73041: LD_INT 1
73043: NEG
73044: PUSH
73045: LD_INT 1
73047: NEG
73048: PUSH
73049: EMPTY
73050: LIST
73051: LIST
73052: PUSH
73053: LD_INT 1
73055: NEG
73056: PUSH
73057: LD_INT 2
73059: NEG
73060: PUSH
73061: EMPTY
73062: LIST
73063: LIST
73064: PUSH
73065: LD_INT 0
73067: PUSH
73068: LD_INT 2
73070: NEG
73071: PUSH
73072: EMPTY
73073: LIST
73074: LIST
73075: PUSH
73076: LD_INT 1
73078: PUSH
73079: LD_INT 1
73081: NEG
73082: PUSH
73083: EMPTY
73084: LIST
73085: LIST
73086: PUSH
73087: LD_INT 2
73089: PUSH
73090: LD_INT 0
73092: PUSH
73093: EMPTY
73094: LIST
73095: LIST
73096: PUSH
73097: LD_INT 2
73099: PUSH
73100: LD_INT 1
73102: PUSH
73103: EMPTY
73104: LIST
73105: LIST
73106: PUSH
73107: LD_INT 2
73109: PUSH
73110: LD_INT 2
73112: PUSH
73113: EMPTY
73114: LIST
73115: LIST
73116: PUSH
73117: LD_INT 1
73119: PUSH
73120: LD_INT 2
73122: PUSH
73123: EMPTY
73124: LIST
73125: LIST
73126: PUSH
73127: LD_INT 0
73129: PUSH
73130: LD_INT 2
73132: PUSH
73133: EMPTY
73134: LIST
73135: LIST
73136: PUSH
73137: LD_INT 1
73139: NEG
73140: PUSH
73141: LD_INT 1
73143: PUSH
73144: EMPTY
73145: LIST
73146: LIST
73147: PUSH
73148: LD_INT 2
73150: NEG
73151: PUSH
73152: LD_INT 0
73154: PUSH
73155: EMPTY
73156: LIST
73157: LIST
73158: PUSH
73159: LD_INT 2
73161: NEG
73162: PUSH
73163: LD_INT 1
73165: NEG
73166: PUSH
73167: EMPTY
73168: LIST
73169: LIST
73170: PUSH
73171: LD_INT 2
73173: NEG
73174: PUSH
73175: LD_INT 2
73177: NEG
73178: PUSH
73179: EMPTY
73180: LIST
73181: LIST
73182: PUSH
73183: EMPTY
73184: LIST
73185: LIST
73186: LIST
73187: LIST
73188: LIST
73189: LIST
73190: LIST
73191: LIST
73192: LIST
73193: LIST
73194: LIST
73195: LIST
73196: LIST
73197: LIST
73198: LIST
73199: LIST
73200: LIST
73201: LIST
73202: LIST
73203: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73204: LD_ADDR_VAR 0 56
73208: PUSH
73209: LD_INT 0
73211: PUSH
73212: LD_INT 0
73214: PUSH
73215: EMPTY
73216: LIST
73217: LIST
73218: PUSH
73219: LD_INT 0
73221: PUSH
73222: LD_INT 1
73224: NEG
73225: PUSH
73226: EMPTY
73227: LIST
73228: LIST
73229: PUSH
73230: LD_INT 1
73232: PUSH
73233: LD_INT 0
73235: PUSH
73236: EMPTY
73237: LIST
73238: LIST
73239: PUSH
73240: LD_INT 1
73242: PUSH
73243: LD_INT 1
73245: PUSH
73246: EMPTY
73247: LIST
73248: LIST
73249: PUSH
73250: LD_INT 0
73252: PUSH
73253: LD_INT 1
73255: PUSH
73256: EMPTY
73257: LIST
73258: LIST
73259: PUSH
73260: LD_INT 1
73262: NEG
73263: PUSH
73264: LD_INT 0
73266: PUSH
73267: EMPTY
73268: LIST
73269: LIST
73270: PUSH
73271: LD_INT 1
73273: NEG
73274: PUSH
73275: LD_INT 1
73277: NEG
73278: PUSH
73279: EMPTY
73280: LIST
73281: LIST
73282: PUSH
73283: LD_INT 1
73285: NEG
73286: PUSH
73287: LD_INT 2
73289: NEG
73290: PUSH
73291: EMPTY
73292: LIST
73293: LIST
73294: PUSH
73295: LD_INT 0
73297: PUSH
73298: LD_INT 2
73300: NEG
73301: PUSH
73302: EMPTY
73303: LIST
73304: LIST
73305: PUSH
73306: LD_INT 1
73308: PUSH
73309: LD_INT 1
73311: NEG
73312: PUSH
73313: EMPTY
73314: LIST
73315: LIST
73316: PUSH
73317: LD_INT 2
73319: PUSH
73320: LD_INT 0
73322: PUSH
73323: EMPTY
73324: LIST
73325: LIST
73326: PUSH
73327: LD_INT 2
73329: PUSH
73330: LD_INT 1
73332: PUSH
73333: EMPTY
73334: LIST
73335: LIST
73336: PUSH
73337: LD_INT 2
73339: PUSH
73340: LD_INT 2
73342: PUSH
73343: EMPTY
73344: LIST
73345: LIST
73346: PUSH
73347: LD_INT 1
73349: PUSH
73350: LD_INT 2
73352: PUSH
73353: EMPTY
73354: LIST
73355: LIST
73356: PUSH
73357: LD_INT 0
73359: PUSH
73360: LD_INT 2
73362: PUSH
73363: EMPTY
73364: LIST
73365: LIST
73366: PUSH
73367: LD_INT 1
73369: NEG
73370: PUSH
73371: LD_INT 1
73373: PUSH
73374: EMPTY
73375: LIST
73376: LIST
73377: PUSH
73378: LD_INT 2
73380: NEG
73381: PUSH
73382: LD_INT 0
73384: PUSH
73385: EMPTY
73386: LIST
73387: LIST
73388: PUSH
73389: LD_INT 2
73391: NEG
73392: PUSH
73393: LD_INT 1
73395: NEG
73396: PUSH
73397: EMPTY
73398: LIST
73399: LIST
73400: PUSH
73401: LD_INT 2
73403: NEG
73404: PUSH
73405: LD_INT 2
73407: NEG
73408: PUSH
73409: EMPTY
73410: LIST
73411: LIST
73412: PUSH
73413: EMPTY
73414: LIST
73415: LIST
73416: LIST
73417: LIST
73418: LIST
73419: LIST
73420: LIST
73421: LIST
73422: LIST
73423: LIST
73424: LIST
73425: LIST
73426: LIST
73427: LIST
73428: LIST
73429: LIST
73430: LIST
73431: LIST
73432: LIST
73433: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73434: LD_ADDR_VAR 0 57
73438: PUSH
73439: LD_INT 0
73441: PUSH
73442: LD_INT 0
73444: PUSH
73445: EMPTY
73446: LIST
73447: LIST
73448: PUSH
73449: LD_INT 0
73451: PUSH
73452: LD_INT 1
73454: NEG
73455: PUSH
73456: EMPTY
73457: LIST
73458: LIST
73459: PUSH
73460: LD_INT 1
73462: PUSH
73463: LD_INT 0
73465: PUSH
73466: EMPTY
73467: LIST
73468: LIST
73469: PUSH
73470: LD_INT 1
73472: PUSH
73473: LD_INT 1
73475: PUSH
73476: EMPTY
73477: LIST
73478: LIST
73479: PUSH
73480: LD_INT 0
73482: PUSH
73483: LD_INT 1
73485: PUSH
73486: EMPTY
73487: LIST
73488: LIST
73489: PUSH
73490: LD_INT 1
73492: NEG
73493: PUSH
73494: LD_INT 0
73496: PUSH
73497: EMPTY
73498: LIST
73499: LIST
73500: PUSH
73501: LD_INT 1
73503: NEG
73504: PUSH
73505: LD_INT 1
73507: NEG
73508: PUSH
73509: EMPTY
73510: LIST
73511: LIST
73512: PUSH
73513: LD_INT 1
73515: NEG
73516: PUSH
73517: LD_INT 2
73519: NEG
73520: PUSH
73521: EMPTY
73522: LIST
73523: LIST
73524: PUSH
73525: LD_INT 0
73527: PUSH
73528: LD_INT 2
73530: NEG
73531: PUSH
73532: EMPTY
73533: LIST
73534: LIST
73535: PUSH
73536: LD_INT 1
73538: PUSH
73539: LD_INT 1
73541: NEG
73542: PUSH
73543: EMPTY
73544: LIST
73545: LIST
73546: PUSH
73547: LD_INT 2
73549: PUSH
73550: LD_INT 0
73552: PUSH
73553: EMPTY
73554: LIST
73555: LIST
73556: PUSH
73557: LD_INT 2
73559: PUSH
73560: LD_INT 1
73562: PUSH
73563: EMPTY
73564: LIST
73565: LIST
73566: PUSH
73567: LD_INT 2
73569: PUSH
73570: LD_INT 2
73572: PUSH
73573: EMPTY
73574: LIST
73575: LIST
73576: PUSH
73577: LD_INT 1
73579: PUSH
73580: LD_INT 2
73582: PUSH
73583: EMPTY
73584: LIST
73585: LIST
73586: PUSH
73587: LD_INT 0
73589: PUSH
73590: LD_INT 2
73592: PUSH
73593: EMPTY
73594: LIST
73595: LIST
73596: PUSH
73597: LD_INT 1
73599: NEG
73600: PUSH
73601: LD_INT 1
73603: PUSH
73604: EMPTY
73605: LIST
73606: LIST
73607: PUSH
73608: LD_INT 2
73610: NEG
73611: PUSH
73612: LD_INT 0
73614: PUSH
73615: EMPTY
73616: LIST
73617: LIST
73618: PUSH
73619: LD_INT 2
73621: NEG
73622: PUSH
73623: LD_INT 1
73625: NEG
73626: PUSH
73627: EMPTY
73628: LIST
73629: LIST
73630: PUSH
73631: LD_INT 2
73633: NEG
73634: PUSH
73635: LD_INT 2
73637: NEG
73638: PUSH
73639: EMPTY
73640: LIST
73641: LIST
73642: PUSH
73643: EMPTY
73644: LIST
73645: LIST
73646: LIST
73647: LIST
73648: LIST
73649: LIST
73650: LIST
73651: LIST
73652: LIST
73653: LIST
73654: LIST
73655: LIST
73656: LIST
73657: LIST
73658: LIST
73659: LIST
73660: LIST
73661: LIST
73662: LIST
73663: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73664: LD_ADDR_VAR 0 58
73668: PUSH
73669: LD_INT 0
73671: PUSH
73672: LD_INT 0
73674: PUSH
73675: EMPTY
73676: LIST
73677: LIST
73678: PUSH
73679: LD_INT 0
73681: PUSH
73682: LD_INT 1
73684: NEG
73685: PUSH
73686: EMPTY
73687: LIST
73688: LIST
73689: PUSH
73690: LD_INT 1
73692: PUSH
73693: LD_INT 0
73695: PUSH
73696: EMPTY
73697: LIST
73698: LIST
73699: PUSH
73700: LD_INT 1
73702: PUSH
73703: LD_INT 1
73705: PUSH
73706: EMPTY
73707: LIST
73708: LIST
73709: PUSH
73710: LD_INT 0
73712: PUSH
73713: LD_INT 1
73715: PUSH
73716: EMPTY
73717: LIST
73718: LIST
73719: PUSH
73720: LD_INT 1
73722: NEG
73723: PUSH
73724: LD_INT 0
73726: PUSH
73727: EMPTY
73728: LIST
73729: LIST
73730: PUSH
73731: LD_INT 1
73733: NEG
73734: PUSH
73735: LD_INT 1
73737: NEG
73738: PUSH
73739: EMPTY
73740: LIST
73741: LIST
73742: PUSH
73743: LD_INT 1
73745: NEG
73746: PUSH
73747: LD_INT 2
73749: NEG
73750: PUSH
73751: EMPTY
73752: LIST
73753: LIST
73754: PUSH
73755: LD_INT 0
73757: PUSH
73758: LD_INT 2
73760: NEG
73761: PUSH
73762: EMPTY
73763: LIST
73764: LIST
73765: PUSH
73766: LD_INT 1
73768: PUSH
73769: LD_INT 1
73771: NEG
73772: PUSH
73773: EMPTY
73774: LIST
73775: LIST
73776: PUSH
73777: LD_INT 2
73779: PUSH
73780: LD_INT 0
73782: PUSH
73783: EMPTY
73784: LIST
73785: LIST
73786: PUSH
73787: LD_INT 2
73789: PUSH
73790: LD_INT 1
73792: PUSH
73793: EMPTY
73794: LIST
73795: LIST
73796: PUSH
73797: LD_INT 2
73799: PUSH
73800: LD_INT 2
73802: PUSH
73803: EMPTY
73804: LIST
73805: LIST
73806: PUSH
73807: LD_INT 1
73809: PUSH
73810: LD_INT 2
73812: PUSH
73813: EMPTY
73814: LIST
73815: LIST
73816: PUSH
73817: LD_INT 0
73819: PUSH
73820: LD_INT 2
73822: PUSH
73823: EMPTY
73824: LIST
73825: LIST
73826: PUSH
73827: LD_INT 1
73829: NEG
73830: PUSH
73831: LD_INT 1
73833: PUSH
73834: EMPTY
73835: LIST
73836: LIST
73837: PUSH
73838: LD_INT 2
73840: NEG
73841: PUSH
73842: LD_INT 0
73844: PUSH
73845: EMPTY
73846: LIST
73847: LIST
73848: PUSH
73849: LD_INT 2
73851: NEG
73852: PUSH
73853: LD_INT 1
73855: NEG
73856: PUSH
73857: EMPTY
73858: LIST
73859: LIST
73860: PUSH
73861: LD_INT 2
73863: NEG
73864: PUSH
73865: LD_INT 2
73867: NEG
73868: PUSH
73869: EMPTY
73870: LIST
73871: LIST
73872: PUSH
73873: EMPTY
73874: LIST
73875: LIST
73876: LIST
73877: LIST
73878: LIST
73879: LIST
73880: LIST
73881: LIST
73882: LIST
73883: LIST
73884: LIST
73885: LIST
73886: LIST
73887: LIST
73888: LIST
73889: LIST
73890: LIST
73891: LIST
73892: LIST
73893: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
73894: LD_ADDR_VAR 0 59
73898: PUSH
73899: LD_INT 0
73901: PUSH
73902: LD_INT 0
73904: PUSH
73905: EMPTY
73906: LIST
73907: LIST
73908: PUSH
73909: LD_INT 0
73911: PUSH
73912: LD_INT 1
73914: NEG
73915: PUSH
73916: EMPTY
73917: LIST
73918: LIST
73919: PUSH
73920: LD_INT 1
73922: PUSH
73923: LD_INT 0
73925: PUSH
73926: EMPTY
73927: LIST
73928: LIST
73929: PUSH
73930: LD_INT 1
73932: PUSH
73933: LD_INT 1
73935: PUSH
73936: EMPTY
73937: LIST
73938: LIST
73939: PUSH
73940: LD_INT 0
73942: PUSH
73943: LD_INT 1
73945: PUSH
73946: EMPTY
73947: LIST
73948: LIST
73949: PUSH
73950: LD_INT 1
73952: NEG
73953: PUSH
73954: LD_INT 0
73956: PUSH
73957: EMPTY
73958: LIST
73959: LIST
73960: PUSH
73961: LD_INT 1
73963: NEG
73964: PUSH
73965: LD_INT 1
73967: NEG
73968: PUSH
73969: EMPTY
73970: LIST
73971: LIST
73972: PUSH
73973: EMPTY
73974: LIST
73975: LIST
73976: LIST
73977: LIST
73978: LIST
73979: LIST
73980: LIST
73981: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
73982: LD_ADDR_VAR 0 60
73986: PUSH
73987: LD_INT 0
73989: PUSH
73990: LD_INT 0
73992: PUSH
73993: EMPTY
73994: LIST
73995: LIST
73996: PUSH
73997: LD_INT 0
73999: PUSH
74000: LD_INT 1
74002: NEG
74003: PUSH
74004: EMPTY
74005: LIST
74006: LIST
74007: PUSH
74008: LD_INT 1
74010: PUSH
74011: LD_INT 0
74013: PUSH
74014: EMPTY
74015: LIST
74016: LIST
74017: PUSH
74018: LD_INT 1
74020: PUSH
74021: LD_INT 1
74023: PUSH
74024: EMPTY
74025: LIST
74026: LIST
74027: PUSH
74028: LD_INT 0
74030: PUSH
74031: LD_INT 1
74033: PUSH
74034: EMPTY
74035: LIST
74036: LIST
74037: PUSH
74038: LD_INT 1
74040: NEG
74041: PUSH
74042: LD_INT 0
74044: PUSH
74045: EMPTY
74046: LIST
74047: LIST
74048: PUSH
74049: LD_INT 1
74051: NEG
74052: PUSH
74053: LD_INT 1
74055: NEG
74056: PUSH
74057: EMPTY
74058: LIST
74059: LIST
74060: PUSH
74061: EMPTY
74062: LIST
74063: LIST
74064: LIST
74065: LIST
74066: LIST
74067: LIST
74068: LIST
74069: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74070: LD_ADDR_VAR 0 61
74074: PUSH
74075: LD_INT 0
74077: PUSH
74078: LD_INT 0
74080: PUSH
74081: EMPTY
74082: LIST
74083: LIST
74084: PUSH
74085: LD_INT 0
74087: PUSH
74088: LD_INT 1
74090: NEG
74091: PUSH
74092: EMPTY
74093: LIST
74094: LIST
74095: PUSH
74096: LD_INT 1
74098: PUSH
74099: LD_INT 0
74101: PUSH
74102: EMPTY
74103: LIST
74104: LIST
74105: PUSH
74106: LD_INT 1
74108: PUSH
74109: LD_INT 1
74111: PUSH
74112: EMPTY
74113: LIST
74114: LIST
74115: PUSH
74116: LD_INT 0
74118: PUSH
74119: LD_INT 1
74121: PUSH
74122: EMPTY
74123: LIST
74124: LIST
74125: PUSH
74126: LD_INT 1
74128: NEG
74129: PUSH
74130: LD_INT 0
74132: PUSH
74133: EMPTY
74134: LIST
74135: LIST
74136: PUSH
74137: LD_INT 1
74139: NEG
74140: PUSH
74141: LD_INT 1
74143: NEG
74144: PUSH
74145: EMPTY
74146: LIST
74147: LIST
74148: PUSH
74149: EMPTY
74150: LIST
74151: LIST
74152: LIST
74153: LIST
74154: LIST
74155: LIST
74156: LIST
74157: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74158: LD_ADDR_VAR 0 62
74162: PUSH
74163: LD_INT 0
74165: PUSH
74166: LD_INT 0
74168: PUSH
74169: EMPTY
74170: LIST
74171: LIST
74172: PUSH
74173: LD_INT 0
74175: PUSH
74176: LD_INT 1
74178: NEG
74179: PUSH
74180: EMPTY
74181: LIST
74182: LIST
74183: PUSH
74184: LD_INT 1
74186: PUSH
74187: LD_INT 0
74189: PUSH
74190: EMPTY
74191: LIST
74192: LIST
74193: PUSH
74194: LD_INT 1
74196: PUSH
74197: LD_INT 1
74199: PUSH
74200: EMPTY
74201: LIST
74202: LIST
74203: PUSH
74204: LD_INT 0
74206: PUSH
74207: LD_INT 1
74209: PUSH
74210: EMPTY
74211: LIST
74212: LIST
74213: PUSH
74214: LD_INT 1
74216: NEG
74217: PUSH
74218: LD_INT 0
74220: PUSH
74221: EMPTY
74222: LIST
74223: LIST
74224: PUSH
74225: LD_INT 1
74227: NEG
74228: PUSH
74229: LD_INT 1
74231: NEG
74232: PUSH
74233: EMPTY
74234: LIST
74235: LIST
74236: PUSH
74237: EMPTY
74238: LIST
74239: LIST
74240: LIST
74241: LIST
74242: LIST
74243: LIST
74244: LIST
74245: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74246: LD_ADDR_VAR 0 63
74250: PUSH
74251: LD_INT 0
74253: PUSH
74254: LD_INT 0
74256: PUSH
74257: EMPTY
74258: LIST
74259: LIST
74260: PUSH
74261: LD_INT 0
74263: PUSH
74264: LD_INT 1
74266: NEG
74267: PUSH
74268: EMPTY
74269: LIST
74270: LIST
74271: PUSH
74272: LD_INT 1
74274: PUSH
74275: LD_INT 0
74277: PUSH
74278: EMPTY
74279: LIST
74280: LIST
74281: PUSH
74282: LD_INT 1
74284: PUSH
74285: LD_INT 1
74287: PUSH
74288: EMPTY
74289: LIST
74290: LIST
74291: PUSH
74292: LD_INT 0
74294: PUSH
74295: LD_INT 1
74297: PUSH
74298: EMPTY
74299: LIST
74300: LIST
74301: PUSH
74302: LD_INT 1
74304: NEG
74305: PUSH
74306: LD_INT 0
74308: PUSH
74309: EMPTY
74310: LIST
74311: LIST
74312: PUSH
74313: LD_INT 1
74315: NEG
74316: PUSH
74317: LD_INT 1
74319: NEG
74320: PUSH
74321: EMPTY
74322: LIST
74323: LIST
74324: PUSH
74325: EMPTY
74326: LIST
74327: LIST
74328: LIST
74329: LIST
74330: LIST
74331: LIST
74332: LIST
74333: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74334: LD_ADDR_VAR 0 64
74338: PUSH
74339: LD_INT 0
74341: PUSH
74342: LD_INT 0
74344: PUSH
74345: EMPTY
74346: LIST
74347: LIST
74348: PUSH
74349: LD_INT 0
74351: PUSH
74352: LD_INT 1
74354: NEG
74355: PUSH
74356: EMPTY
74357: LIST
74358: LIST
74359: PUSH
74360: LD_INT 1
74362: PUSH
74363: LD_INT 0
74365: PUSH
74366: EMPTY
74367: LIST
74368: LIST
74369: PUSH
74370: LD_INT 1
74372: PUSH
74373: LD_INT 1
74375: PUSH
74376: EMPTY
74377: LIST
74378: LIST
74379: PUSH
74380: LD_INT 0
74382: PUSH
74383: LD_INT 1
74385: PUSH
74386: EMPTY
74387: LIST
74388: LIST
74389: PUSH
74390: LD_INT 1
74392: NEG
74393: PUSH
74394: LD_INT 0
74396: PUSH
74397: EMPTY
74398: LIST
74399: LIST
74400: PUSH
74401: LD_INT 1
74403: NEG
74404: PUSH
74405: LD_INT 1
74407: NEG
74408: PUSH
74409: EMPTY
74410: LIST
74411: LIST
74412: PUSH
74413: EMPTY
74414: LIST
74415: LIST
74416: LIST
74417: LIST
74418: LIST
74419: LIST
74420: LIST
74421: ST_TO_ADDR
// end ; 1 :
74422: GO 80319
74424: LD_INT 1
74426: DOUBLE
74427: EQUAL
74428: IFTRUE 74432
74430: GO 77055
74432: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
74433: LD_ADDR_VAR 0 11
74437: PUSH
74438: LD_INT 1
74440: NEG
74441: PUSH
74442: LD_INT 3
74444: NEG
74445: PUSH
74446: EMPTY
74447: LIST
74448: LIST
74449: PUSH
74450: LD_INT 0
74452: PUSH
74453: LD_INT 3
74455: NEG
74456: PUSH
74457: EMPTY
74458: LIST
74459: LIST
74460: PUSH
74461: LD_INT 1
74463: PUSH
74464: LD_INT 2
74466: NEG
74467: PUSH
74468: EMPTY
74469: LIST
74470: LIST
74471: PUSH
74472: EMPTY
74473: LIST
74474: LIST
74475: LIST
74476: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
74477: LD_ADDR_VAR 0 12
74481: PUSH
74482: LD_INT 2
74484: PUSH
74485: LD_INT 1
74487: NEG
74488: PUSH
74489: EMPTY
74490: LIST
74491: LIST
74492: PUSH
74493: LD_INT 3
74495: PUSH
74496: LD_INT 0
74498: PUSH
74499: EMPTY
74500: LIST
74501: LIST
74502: PUSH
74503: LD_INT 3
74505: PUSH
74506: LD_INT 1
74508: PUSH
74509: EMPTY
74510: LIST
74511: LIST
74512: PUSH
74513: EMPTY
74514: LIST
74515: LIST
74516: LIST
74517: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
74518: LD_ADDR_VAR 0 13
74522: PUSH
74523: LD_INT 3
74525: PUSH
74526: LD_INT 2
74528: PUSH
74529: EMPTY
74530: LIST
74531: LIST
74532: PUSH
74533: LD_INT 3
74535: PUSH
74536: LD_INT 3
74538: PUSH
74539: EMPTY
74540: LIST
74541: LIST
74542: PUSH
74543: LD_INT 2
74545: PUSH
74546: LD_INT 3
74548: PUSH
74549: EMPTY
74550: LIST
74551: LIST
74552: PUSH
74553: EMPTY
74554: LIST
74555: LIST
74556: LIST
74557: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
74558: LD_ADDR_VAR 0 14
74562: PUSH
74563: LD_INT 1
74565: PUSH
74566: LD_INT 3
74568: PUSH
74569: EMPTY
74570: LIST
74571: LIST
74572: PUSH
74573: LD_INT 0
74575: PUSH
74576: LD_INT 3
74578: PUSH
74579: EMPTY
74580: LIST
74581: LIST
74582: PUSH
74583: LD_INT 1
74585: NEG
74586: PUSH
74587: LD_INT 2
74589: PUSH
74590: EMPTY
74591: LIST
74592: LIST
74593: PUSH
74594: EMPTY
74595: LIST
74596: LIST
74597: LIST
74598: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74599: LD_ADDR_VAR 0 15
74603: PUSH
74604: LD_INT 2
74606: NEG
74607: PUSH
74608: LD_INT 1
74610: PUSH
74611: EMPTY
74612: LIST
74613: LIST
74614: PUSH
74615: LD_INT 3
74617: NEG
74618: PUSH
74619: LD_INT 0
74621: PUSH
74622: EMPTY
74623: LIST
74624: LIST
74625: PUSH
74626: LD_INT 3
74628: NEG
74629: PUSH
74630: LD_INT 1
74632: NEG
74633: PUSH
74634: EMPTY
74635: LIST
74636: LIST
74637: PUSH
74638: EMPTY
74639: LIST
74640: LIST
74641: LIST
74642: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74643: LD_ADDR_VAR 0 16
74647: PUSH
74648: LD_INT 2
74650: NEG
74651: PUSH
74652: LD_INT 3
74654: NEG
74655: PUSH
74656: EMPTY
74657: LIST
74658: LIST
74659: PUSH
74660: LD_INT 3
74662: NEG
74663: PUSH
74664: LD_INT 2
74666: NEG
74667: PUSH
74668: EMPTY
74669: LIST
74670: LIST
74671: PUSH
74672: LD_INT 3
74674: NEG
74675: PUSH
74676: LD_INT 3
74678: NEG
74679: PUSH
74680: EMPTY
74681: LIST
74682: LIST
74683: PUSH
74684: EMPTY
74685: LIST
74686: LIST
74687: LIST
74688: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
74689: LD_ADDR_VAR 0 17
74693: PUSH
74694: LD_INT 1
74696: NEG
74697: PUSH
74698: LD_INT 3
74700: NEG
74701: PUSH
74702: EMPTY
74703: LIST
74704: LIST
74705: PUSH
74706: LD_INT 0
74708: PUSH
74709: LD_INT 3
74711: NEG
74712: PUSH
74713: EMPTY
74714: LIST
74715: LIST
74716: PUSH
74717: LD_INT 1
74719: PUSH
74720: LD_INT 2
74722: NEG
74723: PUSH
74724: EMPTY
74725: LIST
74726: LIST
74727: PUSH
74728: EMPTY
74729: LIST
74730: LIST
74731: LIST
74732: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
74733: LD_ADDR_VAR 0 18
74737: PUSH
74738: LD_INT 2
74740: PUSH
74741: LD_INT 1
74743: NEG
74744: PUSH
74745: EMPTY
74746: LIST
74747: LIST
74748: PUSH
74749: LD_INT 3
74751: PUSH
74752: LD_INT 0
74754: PUSH
74755: EMPTY
74756: LIST
74757: LIST
74758: PUSH
74759: LD_INT 3
74761: PUSH
74762: LD_INT 1
74764: PUSH
74765: EMPTY
74766: LIST
74767: LIST
74768: PUSH
74769: EMPTY
74770: LIST
74771: LIST
74772: LIST
74773: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
74774: LD_ADDR_VAR 0 19
74778: PUSH
74779: LD_INT 3
74781: PUSH
74782: LD_INT 2
74784: PUSH
74785: EMPTY
74786: LIST
74787: LIST
74788: PUSH
74789: LD_INT 3
74791: PUSH
74792: LD_INT 3
74794: PUSH
74795: EMPTY
74796: LIST
74797: LIST
74798: PUSH
74799: LD_INT 2
74801: PUSH
74802: LD_INT 3
74804: PUSH
74805: EMPTY
74806: LIST
74807: LIST
74808: PUSH
74809: EMPTY
74810: LIST
74811: LIST
74812: LIST
74813: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
74814: LD_ADDR_VAR 0 20
74818: PUSH
74819: LD_INT 1
74821: PUSH
74822: LD_INT 3
74824: PUSH
74825: EMPTY
74826: LIST
74827: LIST
74828: PUSH
74829: LD_INT 0
74831: PUSH
74832: LD_INT 3
74834: PUSH
74835: EMPTY
74836: LIST
74837: LIST
74838: PUSH
74839: LD_INT 1
74841: NEG
74842: PUSH
74843: LD_INT 2
74845: PUSH
74846: EMPTY
74847: LIST
74848: LIST
74849: PUSH
74850: EMPTY
74851: LIST
74852: LIST
74853: LIST
74854: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74855: LD_ADDR_VAR 0 21
74859: PUSH
74860: LD_INT 2
74862: NEG
74863: PUSH
74864: LD_INT 1
74866: PUSH
74867: EMPTY
74868: LIST
74869: LIST
74870: PUSH
74871: LD_INT 3
74873: NEG
74874: PUSH
74875: LD_INT 0
74877: PUSH
74878: EMPTY
74879: LIST
74880: LIST
74881: PUSH
74882: LD_INT 3
74884: NEG
74885: PUSH
74886: LD_INT 1
74888: NEG
74889: PUSH
74890: EMPTY
74891: LIST
74892: LIST
74893: PUSH
74894: EMPTY
74895: LIST
74896: LIST
74897: LIST
74898: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74899: LD_ADDR_VAR 0 22
74903: PUSH
74904: LD_INT 2
74906: NEG
74907: PUSH
74908: LD_INT 3
74910: NEG
74911: PUSH
74912: EMPTY
74913: LIST
74914: LIST
74915: PUSH
74916: LD_INT 3
74918: NEG
74919: PUSH
74920: LD_INT 2
74922: NEG
74923: PUSH
74924: EMPTY
74925: LIST
74926: LIST
74927: PUSH
74928: LD_INT 3
74930: NEG
74931: PUSH
74932: LD_INT 3
74934: NEG
74935: PUSH
74936: EMPTY
74937: LIST
74938: LIST
74939: PUSH
74940: EMPTY
74941: LIST
74942: LIST
74943: LIST
74944: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
74945: LD_ADDR_VAR 0 23
74949: PUSH
74950: LD_INT 0
74952: PUSH
74953: LD_INT 3
74955: NEG
74956: PUSH
74957: EMPTY
74958: LIST
74959: LIST
74960: PUSH
74961: LD_INT 1
74963: NEG
74964: PUSH
74965: LD_INT 4
74967: NEG
74968: PUSH
74969: EMPTY
74970: LIST
74971: LIST
74972: PUSH
74973: LD_INT 1
74975: PUSH
74976: LD_INT 3
74978: NEG
74979: PUSH
74980: EMPTY
74981: LIST
74982: LIST
74983: PUSH
74984: EMPTY
74985: LIST
74986: LIST
74987: LIST
74988: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
74989: LD_ADDR_VAR 0 24
74993: PUSH
74994: LD_INT 3
74996: PUSH
74997: LD_INT 0
74999: PUSH
75000: EMPTY
75001: LIST
75002: LIST
75003: PUSH
75004: LD_INT 3
75006: PUSH
75007: LD_INT 1
75009: NEG
75010: PUSH
75011: EMPTY
75012: LIST
75013: LIST
75014: PUSH
75015: LD_INT 4
75017: PUSH
75018: LD_INT 1
75020: PUSH
75021: EMPTY
75022: LIST
75023: LIST
75024: PUSH
75025: EMPTY
75026: LIST
75027: LIST
75028: LIST
75029: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
75030: LD_ADDR_VAR 0 25
75034: PUSH
75035: LD_INT 3
75037: PUSH
75038: LD_INT 3
75040: PUSH
75041: EMPTY
75042: LIST
75043: LIST
75044: PUSH
75045: LD_INT 4
75047: PUSH
75048: LD_INT 3
75050: PUSH
75051: EMPTY
75052: LIST
75053: LIST
75054: PUSH
75055: LD_INT 3
75057: PUSH
75058: LD_INT 4
75060: PUSH
75061: EMPTY
75062: LIST
75063: LIST
75064: PUSH
75065: EMPTY
75066: LIST
75067: LIST
75068: LIST
75069: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
75070: LD_ADDR_VAR 0 26
75074: PUSH
75075: LD_INT 0
75077: PUSH
75078: LD_INT 3
75080: PUSH
75081: EMPTY
75082: LIST
75083: LIST
75084: PUSH
75085: LD_INT 1
75087: PUSH
75088: LD_INT 4
75090: PUSH
75091: EMPTY
75092: LIST
75093: LIST
75094: PUSH
75095: LD_INT 1
75097: NEG
75098: PUSH
75099: LD_INT 3
75101: PUSH
75102: EMPTY
75103: LIST
75104: LIST
75105: PUSH
75106: EMPTY
75107: LIST
75108: LIST
75109: LIST
75110: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
75111: LD_ADDR_VAR 0 27
75115: PUSH
75116: LD_INT 3
75118: NEG
75119: PUSH
75120: LD_INT 0
75122: PUSH
75123: EMPTY
75124: LIST
75125: LIST
75126: PUSH
75127: LD_INT 3
75129: NEG
75130: PUSH
75131: LD_INT 1
75133: PUSH
75134: EMPTY
75135: LIST
75136: LIST
75137: PUSH
75138: LD_INT 4
75140: NEG
75141: PUSH
75142: LD_INT 1
75144: NEG
75145: PUSH
75146: EMPTY
75147: LIST
75148: LIST
75149: PUSH
75150: EMPTY
75151: LIST
75152: LIST
75153: LIST
75154: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
75155: LD_ADDR_VAR 0 28
75159: PUSH
75160: LD_INT 3
75162: NEG
75163: PUSH
75164: LD_INT 3
75166: NEG
75167: PUSH
75168: EMPTY
75169: LIST
75170: LIST
75171: PUSH
75172: LD_INT 3
75174: NEG
75175: PUSH
75176: LD_INT 4
75178: NEG
75179: PUSH
75180: EMPTY
75181: LIST
75182: LIST
75183: PUSH
75184: LD_INT 4
75186: NEG
75187: PUSH
75188: LD_INT 3
75190: NEG
75191: PUSH
75192: EMPTY
75193: LIST
75194: LIST
75195: PUSH
75196: EMPTY
75197: LIST
75198: LIST
75199: LIST
75200: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
75201: LD_ADDR_VAR 0 29
75205: PUSH
75206: LD_INT 1
75208: NEG
75209: PUSH
75210: LD_INT 3
75212: NEG
75213: PUSH
75214: EMPTY
75215: LIST
75216: LIST
75217: PUSH
75218: LD_INT 0
75220: PUSH
75221: LD_INT 3
75223: NEG
75224: PUSH
75225: EMPTY
75226: LIST
75227: LIST
75228: PUSH
75229: LD_INT 1
75231: PUSH
75232: LD_INT 2
75234: NEG
75235: PUSH
75236: EMPTY
75237: LIST
75238: LIST
75239: PUSH
75240: LD_INT 1
75242: NEG
75243: PUSH
75244: LD_INT 4
75246: NEG
75247: PUSH
75248: EMPTY
75249: LIST
75250: LIST
75251: PUSH
75252: LD_INT 0
75254: PUSH
75255: LD_INT 4
75257: NEG
75258: PUSH
75259: EMPTY
75260: LIST
75261: LIST
75262: PUSH
75263: LD_INT 1
75265: PUSH
75266: LD_INT 3
75268: NEG
75269: PUSH
75270: EMPTY
75271: LIST
75272: LIST
75273: PUSH
75274: LD_INT 1
75276: NEG
75277: PUSH
75278: LD_INT 5
75280: NEG
75281: PUSH
75282: EMPTY
75283: LIST
75284: LIST
75285: PUSH
75286: LD_INT 0
75288: PUSH
75289: LD_INT 5
75291: NEG
75292: PUSH
75293: EMPTY
75294: LIST
75295: LIST
75296: PUSH
75297: LD_INT 1
75299: PUSH
75300: LD_INT 4
75302: NEG
75303: PUSH
75304: EMPTY
75305: LIST
75306: LIST
75307: PUSH
75308: LD_INT 1
75310: NEG
75311: PUSH
75312: LD_INT 6
75314: NEG
75315: PUSH
75316: EMPTY
75317: LIST
75318: LIST
75319: PUSH
75320: LD_INT 0
75322: PUSH
75323: LD_INT 6
75325: NEG
75326: PUSH
75327: EMPTY
75328: LIST
75329: LIST
75330: PUSH
75331: LD_INT 1
75333: PUSH
75334: LD_INT 5
75336: NEG
75337: PUSH
75338: EMPTY
75339: LIST
75340: LIST
75341: PUSH
75342: EMPTY
75343: LIST
75344: LIST
75345: LIST
75346: LIST
75347: LIST
75348: LIST
75349: LIST
75350: LIST
75351: LIST
75352: LIST
75353: LIST
75354: LIST
75355: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
75356: LD_ADDR_VAR 0 30
75360: PUSH
75361: LD_INT 2
75363: PUSH
75364: LD_INT 1
75366: NEG
75367: PUSH
75368: EMPTY
75369: LIST
75370: LIST
75371: PUSH
75372: LD_INT 3
75374: PUSH
75375: LD_INT 0
75377: PUSH
75378: EMPTY
75379: LIST
75380: LIST
75381: PUSH
75382: LD_INT 3
75384: PUSH
75385: LD_INT 1
75387: PUSH
75388: EMPTY
75389: LIST
75390: LIST
75391: PUSH
75392: LD_INT 3
75394: PUSH
75395: LD_INT 1
75397: NEG
75398: PUSH
75399: EMPTY
75400: LIST
75401: LIST
75402: PUSH
75403: LD_INT 4
75405: PUSH
75406: LD_INT 0
75408: PUSH
75409: EMPTY
75410: LIST
75411: LIST
75412: PUSH
75413: LD_INT 4
75415: PUSH
75416: LD_INT 1
75418: PUSH
75419: EMPTY
75420: LIST
75421: LIST
75422: PUSH
75423: LD_INT 4
75425: PUSH
75426: LD_INT 1
75428: NEG
75429: PUSH
75430: EMPTY
75431: LIST
75432: LIST
75433: PUSH
75434: LD_INT 5
75436: PUSH
75437: LD_INT 0
75439: PUSH
75440: EMPTY
75441: LIST
75442: LIST
75443: PUSH
75444: LD_INT 5
75446: PUSH
75447: LD_INT 1
75449: PUSH
75450: EMPTY
75451: LIST
75452: LIST
75453: PUSH
75454: LD_INT 5
75456: PUSH
75457: LD_INT 1
75459: NEG
75460: PUSH
75461: EMPTY
75462: LIST
75463: LIST
75464: PUSH
75465: LD_INT 6
75467: PUSH
75468: LD_INT 0
75470: PUSH
75471: EMPTY
75472: LIST
75473: LIST
75474: PUSH
75475: LD_INT 6
75477: PUSH
75478: LD_INT 1
75480: PUSH
75481: EMPTY
75482: LIST
75483: LIST
75484: PUSH
75485: EMPTY
75486: LIST
75487: LIST
75488: LIST
75489: LIST
75490: LIST
75491: LIST
75492: LIST
75493: LIST
75494: LIST
75495: LIST
75496: LIST
75497: LIST
75498: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
75499: LD_ADDR_VAR 0 31
75503: PUSH
75504: LD_INT 3
75506: PUSH
75507: LD_INT 2
75509: PUSH
75510: EMPTY
75511: LIST
75512: LIST
75513: PUSH
75514: LD_INT 3
75516: PUSH
75517: LD_INT 3
75519: PUSH
75520: EMPTY
75521: LIST
75522: LIST
75523: PUSH
75524: LD_INT 2
75526: PUSH
75527: LD_INT 3
75529: PUSH
75530: EMPTY
75531: LIST
75532: LIST
75533: PUSH
75534: LD_INT 4
75536: PUSH
75537: LD_INT 3
75539: PUSH
75540: EMPTY
75541: LIST
75542: LIST
75543: PUSH
75544: LD_INT 4
75546: PUSH
75547: LD_INT 4
75549: PUSH
75550: EMPTY
75551: LIST
75552: LIST
75553: PUSH
75554: LD_INT 3
75556: PUSH
75557: LD_INT 4
75559: PUSH
75560: EMPTY
75561: LIST
75562: LIST
75563: PUSH
75564: LD_INT 5
75566: PUSH
75567: LD_INT 4
75569: PUSH
75570: EMPTY
75571: LIST
75572: LIST
75573: PUSH
75574: LD_INT 5
75576: PUSH
75577: LD_INT 5
75579: PUSH
75580: EMPTY
75581: LIST
75582: LIST
75583: PUSH
75584: LD_INT 4
75586: PUSH
75587: LD_INT 5
75589: PUSH
75590: EMPTY
75591: LIST
75592: LIST
75593: PUSH
75594: LD_INT 6
75596: PUSH
75597: LD_INT 5
75599: PUSH
75600: EMPTY
75601: LIST
75602: LIST
75603: PUSH
75604: LD_INT 6
75606: PUSH
75607: LD_INT 6
75609: PUSH
75610: EMPTY
75611: LIST
75612: LIST
75613: PUSH
75614: LD_INT 5
75616: PUSH
75617: LD_INT 6
75619: PUSH
75620: EMPTY
75621: LIST
75622: LIST
75623: PUSH
75624: EMPTY
75625: LIST
75626: LIST
75627: LIST
75628: LIST
75629: LIST
75630: LIST
75631: LIST
75632: LIST
75633: LIST
75634: LIST
75635: LIST
75636: LIST
75637: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
75638: LD_ADDR_VAR 0 32
75642: PUSH
75643: LD_INT 1
75645: PUSH
75646: LD_INT 3
75648: PUSH
75649: EMPTY
75650: LIST
75651: LIST
75652: PUSH
75653: LD_INT 0
75655: PUSH
75656: LD_INT 3
75658: PUSH
75659: EMPTY
75660: LIST
75661: LIST
75662: PUSH
75663: LD_INT 1
75665: NEG
75666: PUSH
75667: LD_INT 2
75669: PUSH
75670: EMPTY
75671: LIST
75672: LIST
75673: PUSH
75674: LD_INT 1
75676: PUSH
75677: LD_INT 4
75679: PUSH
75680: EMPTY
75681: LIST
75682: LIST
75683: PUSH
75684: LD_INT 0
75686: PUSH
75687: LD_INT 4
75689: PUSH
75690: EMPTY
75691: LIST
75692: LIST
75693: PUSH
75694: LD_INT 1
75696: NEG
75697: PUSH
75698: LD_INT 3
75700: PUSH
75701: EMPTY
75702: LIST
75703: LIST
75704: PUSH
75705: LD_INT 1
75707: PUSH
75708: LD_INT 5
75710: PUSH
75711: EMPTY
75712: LIST
75713: LIST
75714: PUSH
75715: LD_INT 0
75717: PUSH
75718: LD_INT 5
75720: PUSH
75721: EMPTY
75722: LIST
75723: LIST
75724: PUSH
75725: LD_INT 1
75727: NEG
75728: PUSH
75729: LD_INT 4
75731: PUSH
75732: EMPTY
75733: LIST
75734: LIST
75735: PUSH
75736: LD_INT 1
75738: PUSH
75739: LD_INT 6
75741: PUSH
75742: EMPTY
75743: LIST
75744: LIST
75745: PUSH
75746: LD_INT 0
75748: PUSH
75749: LD_INT 6
75751: PUSH
75752: EMPTY
75753: LIST
75754: LIST
75755: PUSH
75756: LD_INT 1
75758: NEG
75759: PUSH
75760: LD_INT 5
75762: PUSH
75763: EMPTY
75764: LIST
75765: LIST
75766: PUSH
75767: EMPTY
75768: LIST
75769: LIST
75770: LIST
75771: LIST
75772: LIST
75773: LIST
75774: LIST
75775: LIST
75776: LIST
75777: LIST
75778: LIST
75779: LIST
75780: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
75781: LD_ADDR_VAR 0 33
75785: PUSH
75786: LD_INT 2
75788: NEG
75789: PUSH
75790: LD_INT 1
75792: PUSH
75793: EMPTY
75794: LIST
75795: LIST
75796: PUSH
75797: LD_INT 3
75799: NEG
75800: PUSH
75801: LD_INT 0
75803: PUSH
75804: EMPTY
75805: LIST
75806: LIST
75807: PUSH
75808: LD_INT 3
75810: NEG
75811: PUSH
75812: LD_INT 1
75814: NEG
75815: PUSH
75816: EMPTY
75817: LIST
75818: LIST
75819: PUSH
75820: LD_INT 3
75822: NEG
75823: PUSH
75824: LD_INT 1
75826: PUSH
75827: EMPTY
75828: LIST
75829: LIST
75830: PUSH
75831: LD_INT 4
75833: NEG
75834: PUSH
75835: LD_INT 0
75837: PUSH
75838: EMPTY
75839: LIST
75840: LIST
75841: PUSH
75842: LD_INT 4
75844: NEG
75845: PUSH
75846: LD_INT 1
75848: NEG
75849: PUSH
75850: EMPTY
75851: LIST
75852: LIST
75853: PUSH
75854: LD_INT 4
75856: NEG
75857: PUSH
75858: LD_INT 1
75860: PUSH
75861: EMPTY
75862: LIST
75863: LIST
75864: PUSH
75865: LD_INT 5
75867: NEG
75868: PUSH
75869: LD_INT 0
75871: PUSH
75872: EMPTY
75873: LIST
75874: LIST
75875: PUSH
75876: LD_INT 5
75878: NEG
75879: PUSH
75880: LD_INT 1
75882: NEG
75883: PUSH
75884: EMPTY
75885: LIST
75886: LIST
75887: PUSH
75888: LD_INT 5
75890: NEG
75891: PUSH
75892: LD_INT 1
75894: PUSH
75895: EMPTY
75896: LIST
75897: LIST
75898: PUSH
75899: LD_INT 6
75901: NEG
75902: PUSH
75903: LD_INT 0
75905: PUSH
75906: EMPTY
75907: LIST
75908: LIST
75909: PUSH
75910: LD_INT 6
75912: NEG
75913: PUSH
75914: LD_INT 1
75916: NEG
75917: PUSH
75918: EMPTY
75919: LIST
75920: LIST
75921: PUSH
75922: EMPTY
75923: LIST
75924: LIST
75925: LIST
75926: LIST
75927: LIST
75928: LIST
75929: LIST
75930: LIST
75931: LIST
75932: LIST
75933: LIST
75934: LIST
75935: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
75936: LD_ADDR_VAR 0 34
75940: PUSH
75941: LD_INT 2
75943: NEG
75944: PUSH
75945: LD_INT 3
75947: NEG
75948: PUSH
75949: EMPTY
75950: LIST
75951: LIST
75952: PUSH
75953: LD_INT 3
75955: NEG
75956: PUSH
75957: LD_INT 2
75959: NEG
75960: PUSH
75961: EMPTY
75962: LIST
75963: LIST
75964: PUSH
75965: LD_INT 3
75967: NEG
75968: PUSH
75969: LD_INT 3
75971: NEG
75972: PUSH
75973: EMPTY
75974: LIST
75975: LIST
75976: PUSH
75977: LD_INT 3
75979: NEG
75980: PUSH
75981: LD_INT 4
75983: NEG
75984: PUSH
75985: EMPTY
75986: LIST
75987: LIST
75988: PUSH
75989: LD_INT 4
75991: NEG
75992: PUSH
75993: LD_INT 3
75995: NEG
75996: PUSH
75997: EMPTY
75998: LIST
75999: LIST
76000: PUSH
76001: LD_INT 4
76003: NEG
76004: PUSH
76005: LD_INT 4
76007: NEG
76008: PUSH
76009: EMPTY
76010: LIST
76011: LIST
76012: PUSH
76013: LD_INT 4
76015: NEG
76016: PUSH
76017: LD_INT 5
76019: NEG
76020: PUSH
76021: EMPTY
76022: LIST
76023: LIST
76024: PUSH
76025: LD_INT 5
76027: NEG
76028: PUSH
76029: LD_INT 4
76031: NEG
76032: PUSH
76033: EMPTY
76034: LIST
76035: LIST
76036: PUSH
76037: LD_INT 5
76039: NEG
76040: PUSH
76041: LD_INT 5
76043: NEG
76044: PUSH
76045: EMPTY
76046: LIST
76047: LIST
76048: PUSH
76049: LD_INT 5
76051: NEG
76052: PUSH
76053: LD_INT 6
76055: NEG
76056: PUSH
76057: EMPTY
76058: LIST
76059: LIST
76060: PUSH
76061: LD_INT 6
76063: NEG
76064: PUSH
76065: LD_INT 5
76067: NEG
76068: PUSH
76069: EMPTY
76070: LIST
76071: LIST
76072: PUSH
76073: LD_INT 6
76075: NEG
76076: PUSH
76077: LD_INT 6
76079: NEG
76080: PUSH
76081: EMPTY
76082: LIST
76083: LIST
76084: PUSH
76085: EMPTY
76086: LIST
76087: LIST
76088: LIST
76089: LIST
76090: LIST
76091: LIST
76092: LIST
76093: LIST
76094: LIST
76095: LIST
76096: LIST
76097: LIST
76098: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
76099: LD_ADDR_VAR 0 41
76103: PUSH
76104: LD_INT 0
76106: PUSH
76107: LD_INT 2
76109: NEG
76110: PUSH
76111: EMPTY
76112: LIST
76113: LIST
76114: PUSH
76115: LD_INT 1
76117: NEG
76118: PUSH
76119: LD_INT 3
76121: NEG
76122: PUSH
76123: EMPTY
76124: LIST
76125: LIST
76126: PUSH
76127: LD_INT 1
76129: PUSH
76130: LD_INT 2
76132: NEG
76133: PUSH
76134: EMPTY
76135: LIST
76136: LIST
76137: PUSH
76138: EMPTY
76139: LIST
76140: LIST
76141: LIST
76142: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
76143: LD_ADDR_VAR 0 42
76147: PUSH
76148: LD_INT 2
76150: PUSH
76151: LD_INT 0
76153: PUSH
76154: EMPTY
76155: LIST
76156: LIST
76157: PUSH
76158: LD_INT 2
76160: PUSH
76161: LD_INT 1
76163: NEG
76164: PUSH
76165: EMPTY
76166: LIST
76167: LIST
76168: PUSH
76169: LD_INT 3
76171: PUSH
76172: LD_INT 1
76174: PUSH
76175: EMPTY
76176: LIST
76177: LIST
76178: PUSH
76179: EMPTY
76180: LIST
76181: LIST
76182: LIST
76183: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
76184: LD_ADDR_VAR 0 43
76188: PUSH
76189: LD_INT 2
76191: PUSH
76192: LD_INT 2
76194: PUSH
76195: EMPTY
76196: LIST
76197: LIST
76198: PUSH
76199: LD_INT 3
76201: PUSH
76202: LD_INT 2
76204: PUSH
76205: EMPTY
76206: LIST
76207: LIST
76208: PUSH
76209: LD_INT 2
76211: PUSH
76212: LD_INT 3
76214: PUSH
76215: EMPTY
76216: LIST
76217: LIST
76218: PUSH
76219: EMPTY
76220: LIST
76221: LIST
76222: LIST
76223: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
76224: LD_ADDR_VAR 0 44
76228: PUSH
76229: LD_INT 0
76231: PUSH
76232: LD_INT 2
76234: PUSH
76235: EMPTY
76236: LIST
76237: LIST
76238: PUSH
76239: LD_INT 1
76241: PUSH
76242: LD_INT 3
76244: PUSH
76245: EMPTY
76246: LIST
76247: LIST
76248: PUSH
76249: LD_INT 1
76251: NEG
76252: PUSH
76253: LD_INT 2
76255: PUSH
76256: EMPTY
76257: LIST
76258: LIST
76259: PUSH
76260: EMPTY
76261: LIST
76262: LIST
76263: LIST
76264: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
76265: LD_ADDR_VAR 0 45
76269: PUSH
76270: LD_INT 2
76272: NEG
76273: PUSH
76274: LD_INT 0
76276: PUSH
76277: EMPTY
76278: LIST
76279: LIST
76280: PUSH
76281: LD_INT 2
76283: NEG
76284: PUSH
76285: LD_INT 1
76287: PUSH
76288: EMPTY
76289: LIST
76290: LIST
76291: PUSH
76292: LD_INT 3
76294: NEG
76295: PUSH
76296: LD_INT 1
76298: NEG
76299: PUSH
76300: EMPTY
76301: LIST
76302: LIST
76303: PUSH
76304: EMPTY
76305: LIST
76306: LIST
76307: LIST
76308: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
76309: LD_ADDR_VAR 0 46
76313: PUSH
76314: LD_INT 2
76316: NEG
76317: PUSH
76318: LD_INT 2
76320: NEG
76321: PUSH
76322: EMPTY
76323: LIST
76324: LIST
76325: PUSH
76326: LD_INT 2
76328: NEG
76329: PUSH
76330: LD_INT 3
76332: NEG
76333: PUSH
76334: EMPTY
76335: LIST
76336: LIST
76337: PUSH
76338: LD_INT 3
76340: NEG
76341: PUSH
76342: LD_INT 2
76344: NEG
76345: PUSH
76346: EMPTY
76347: LIST
76348: LIST
76349: PUSH
76350: EMPTY
76351: LIST
76352: LIST
76353: LIST
76354: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
76355: LD_ADDR_VAR 0 47
76359: PUSH
76360: LD_INT 2
76362: NEG
76363: PUSH
76364: LD_INT 3
76366: NEG
76367: PUSH
76368: EMPTY
76369: LIST
76370: LIST
76371: PUSH
76372: LD_INT 1
76374: NEG
76375: PUSH
76376: LD_INT 3
76378: NEG
76379: PUSH
76380: EMPTY
76381: LIST
76382: LIST
76383: PUSH
76384: EMPTY
76385: LIST
76386: LIST
76387: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
76388: LD_ADDR_VAR 0 48
76392: PUSH
76393: LD_INT 1
76395: PUSH
76396: LD_INT 2
76398: NEG
76399: PUSH
76400: EMPTY
76401: LIST
76402: LIST
76403: PUSH
76404: LD_INT 2
76406: PUSH
76407: LD_INT 1
76409: NEG
76410: PUSH
76411: EMPTY
76412: LIST
76413: LIST
76414: PUSH
76415: EMPTY
76416: LIST
76417: LIST
76418: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
76419: LD_ADDR_VAR 0 49
76423: PUSH
76424: LD_INT 3
76426: PUSH
76427: LD_INT 1
76429: PUSH
76430: EMPTY
76431: LIST
76432: LIST
76433: PUSH
76434: LD_INT 3
76436: PUSH
76437: LD_INT 2
76439: PUSH
76440: EMPTY
76441: LIST
76442: LIST
76443: PUSH
76444: EMPTY
76445: LIST
76446: LIST
76447: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
76448: LD_ADDR_VAR 0 50
76452: PUSH
76453: LD_INT 2
76455: PUSH
76456: LD_INT 3
76458: PUSH
76459: EMPTY
76460: LIST
76461: LIST
76462: PUSH
76463: LD_INT 1
76465: PUSH
76466: LD_INT 3
76468: PUSH
76469: EMPTY
76470: LIST
76471: LIST
76472: PUSH
76473: EMPTY
76474: LIST
76475: LIST
76476: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
76477: LD_ADDR_VAR 0 51
76481: PUSH
76482: LD_INT 1
76484: NEG
76485: PUSH
76486: LD_INT 2
76488: PUSH
76489: EMPTY
76490: LIST
76491: LIST
76492: PUSH
76493: LD_INT 2
76495: NEG
76496: PUSH
76497: LD_INT 1
76499: PUSH
76500: EMPTY
76501: LIST
76502: LIST
76503: PUSH
76504: EMPTY
76505: LIST
76506: LIST
76507: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
76508: LD_ADDR_VAR 0 52
76512: PUSH
76513: LD_INT 3
76515: NEG
76516: PUSH
76517: LD_INT 1
76519: NEG
76520: PUSH
76521: EMPTY
76522: LIST
76523: LIST
76524: PUSH
76525: LD_INT 3
76527: NEG
76528: PUSH
76529: LD_INT 2
76531: NEG
76532: PUSH
76533: EMPTY
76534: LIST
76535: LIST
76536: PUSH
76537: EMPTY
76538: LIST
76539: LIST
76540: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
76541: LD_ADDR_VAR 0 53
76545: PUSH
76546: LD_INT 1
76548: NEG
76549: PUSH
76550: LD_INT 3
76552: NEG
76553: PUSH
76554: EMPTY
76555: LIST
76556: LIST
76557: PUSH
76558: LD_INT 0
76560: PUSH
76561: LD_INT 3
76563: NEG
76564: PUSH
76565: EMPTY
76566: LIST
76567: LIST
76568: PUSH
76569: LD_INT 1
76571: PUSH
76572: LD_INT 2
76574: NEG
76575: PUSH
76576: EMPTY
76577: LIST
76578: LIST
76579: PUSH
76580: EMPTY
76581: LIST
76582: LIST
76583: LIST
76584: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
76585: LD_ADDR_VAR 0 54
76589: PUSH
76590: LD_INT 2
76592: PUSH
76593: LD_INT 1
76595: NEG
76596: PUSH
76597: EMPTY
76598: LIST
76599: LIST
76600: PUSH
76601: LD_INT 3
76603: PUSH
76604: LD_INT 0
76606: PUSH
76607: EMPTY
76608: LIST
76609: LIST
76610: PUSH
76611: LD_INT 3
76613: PUSH
76614: LD_INT 1
76616: PUSH
76617: EMPTY
76618: LIST
76619: LIST
76620: PUSH
76621: EMPTY
76622: LIST
76623: LIST
76624: LIST
76625: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
76626: LD_ADDR_VAR 0 55
76630: PUSH
76631: LD_INT 3
76633: PUSH
76634: LD_INT 2
76636: PUSH
76637: EMPTY
76638: LIST
76639: LIST
76640: PUSH
76641: LD_INT 3
76643: PUSH
76644: LD_INT 3
76646: PUSH
76647: EMPTY
76648: LIST
76649: LIST
76650: PUSH
76651: LD_INT 2
76653: PUSH
76654: LD_INT 3
76656: PUSH
76657: EMPTY
76658: LIST
76659: LIST
76660: PUSH
76661: EMPTY
76662: LIST
76663: LIST
76664: LIST
76665: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
76666: LD_ADDR_VAR 0 56
76670: PUSH
76671: LD_INT 1
76673: PUSH
76674: LD_INT 3
76676: PUSH
76677: EMPTY
76678: LIST
76679: LIST
76680: PUSH
76681: LD_INT 0
76683: PUSH
76684: LD_INT 3
76686: PUSH
76687: EMPTY
76688: LIST
76689: LIST
76690: PUSH
76691: LD_INT 1
76693: NEG
76694: PUSH
76695: LD_INT 2
76697: PUSH
76698: EMPTY
76699: LIST
76700: LIST
76701: PUSH
76702: EMPTY
76703: LIST
76704: LIST
76705: LIST
76706: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
76707: LD_ADDR_VAR 0 57
76711: PUSH
76712: LD_INT 2
76714: NEG
76715: PUSH
76716: LD_INT 1
76718: PUSH
76719: EMPTY
76720: LIST
76721: LIST
76722: PUSH
76723: LD_INT 3
76725: NEG
76726: PUSH
76727: LD_INT 0
76729: PUSH
76730: EMPTY
76731: LIST
76732: LIST
76733: PUSH
76734: LD_INT 3
76736: NEG
76737: PUSH
76738: LD_INT 1
76740: NEG
76741: PUSH
76742: EMPTY
76743: LIST
76744: LIST
76745: PUSH
76746: EMPTY
76747: LIST
76748: LIST
76749: LIST
76750: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
76751: LD_ADDR_VAR 0 58
76755: PUSH
76756: LD_INT 2
76758: NEG
76759: PUSH
76760: LD_INT 3
76762: NEG
76763: PUSH
76764: EMPTY
76765: LIST
76766: LIST
76767: PUSH
76768: LD_INT 3
76770: NEG
76771: PUSH
76772: LD_INT 2
76774: NEG
76775: PUSH
76776: EMPTY
76777: LIST
76778: LIST
76779: PUSH
76780: LD_INT 3
76782: NEG
76783: PUSH
76784: LD_INT 3
76786: NEG
76787: PUSH
76788: EMPTY
76789: LIST
76790: LIST
76791: PUSH
76792: EMPTY
76793: LIST
76794: LIST
76795: LIST
76796: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
76797: LD_ADDR_VAR 0 59
76801: PUSH
76802: LD_INT 1
76804: NEG
76805: PUSH
76806: LD_INT 2
76808: NEG
76809: PUSH
76810: EMPTY
76811: LIST
76812: LIST
76813: PUSH
76814: LD_INT 0
76816: PUSH
76817: LD_INT 2
76819: NEG
76820: PUSH
76821: EMPTY
76822: LIST
76823: LIST
76824: PUSH
76825: LD_INT 1
76827: PUSH
76828: LD_INT 1
76830: NEG
76831: PUSH
76832: EMPTY
76833: LIST
76834: LIST
76835: PUSH
76836: EMPTY
76837: LIST
76838: LIST
76839: LIST
76840: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
76841: LD_ADDR_VAR 0 60
76845: PUSH
76846: LD_INT 1
76848: PUSH
76849: LD_INT 1
76851: NEG
76852: PUSH
76853: EMPTY
76854: LIST
76855: LIST
76856: PUSH
76857: LD_INT 2
76859: PUSH
76860: LD_INT 0
76862: PUSH
76863: EMPTY
76864: LIST
76865: LIST
76866: PUSH
76867: LD_INT 2
76869: PUSH
76870: LD_INT 1
76872: PUSH
76873: EMPTY
76874: LIST
76875: LIST
76876: PUSH
76877: EMPTY
76878: LIST
76879: LIST
76880: LIST
76881: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
76882: LD_ADDR_VAR 0 61
76886: PUSH
76887: LD_INT 2
76889: PUSH
76890: LD_INT 1
76892: PUSH
76893: EMPTY
76894: LIST
76895: LIST
76896: PUSH
76897: LD_INT 2
76899: PUSH
76900: LD_INT 2
76902: PUSH
76903: EMPTY
76904: LIST
76905: LIST
76906: PUSH
76907: LD_INT 1
76909: PUSH
76910: LD_INT 2
76912: PUSH
76913: EMPTY
76914: LIST
76915: LIST
76916: PUSH
76917: EMPTY
76918: LIST
76919: LIST
76920: LIST
76921: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
76922: LD_ADDR_VAR 0 62
76926: PUSH
76927: LD_INT 1
76929: PUSH
76930: LD_INT 2
76932: PUSH
76933: EMPTY
76934: LIST
76935: LIST
76936: PUSH
76937: LD_INT 0
76939: PUSH
76940: LD_INT 2
76942: PUSH
76943: EMPTY
76944: LIST
76945: LIST
76946: PUSH
76947: LD_INT 1
76949: NEG
76950: PUSH
76951: LD_INT 1
76953: PUSH
76954: EMPTY
76955: LIST
76956: LIST
76957: PUSH
76958: EMPTY
76959: LIST
76960: LIST
76961: LIST
76962: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
76963: LD_ADDR_VAR 0 63
76967: PUSH
76968: LD_INT 1
76970: NEG
76971: PUSH
76972: LD_INT 1
76974: PUSH
76975: EMPTY
76976: LIST
76977: LIST
76978: PUSH
76979: LD_INT 2
76981: NEG
76982: PUSH
76983: LD_INT 0
76985: PUSH
76986: EMPTY
76987: LIST
76988: LIST
76989: PUSH
76990: LD_INT 2
76992: NEG
76993: PUSH
76994: LD_INT 1
76996: NEG
76997: PUSH
76998: EMPTY
76999: LIST
77000: LIST
77001: PUSH
77002: EMPTY
77003: LIST
77004: LIST
77005: LIST
77006: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77007: LD_ADDR_VAR 0 64
77011: PUSH
77012: LD_INT 1
77014: NEG
77015: PUSH
77016: LD_INT 2
77018: NEG
77019: PUSH
77020: EMPTY
77021: LIST
77022: LIST
77023: PUSH
77024: LD_INT 2
77026: NEG
77027: PUSH
77028: LD_INT 1
77030: NEG
77031: PUSH
77032: EMPTY
77033: LIST
77034: LIST
77035: PUSH
77036: LD_INT 2
77038: NEG
77039: PUSH
77040: LD_INT 2
77042: NEG
77043: PUSH
77044: EMPTY
77045: LIST
77046: LIST
77047: PUSH
77048: EMPTY
77049: LIST
77050: LIST
77051: LIST
77052: ST_TO_ADDR
// end ; 2 :
77053: GO 80319
77055: LD_INT 2
77057: DOUBLE
77058: EQUAL
77059: IFTRUE 77063
77061: GO 80318
77063: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
77064: LD_ADDR_VAR 0 29
77068: PUSH
77069: LD_INT 4
77071: PUSH
77072: LD_INT 0
77074: PUSH
77075: EMPTY
77076: LIST
77077: LIST
77078: PUSH
77079: LD_INT 4
77081: PUSH
77082: LD_INT 1
77084: NEG
77085: PUSH
77086: EMPTY
77087: LIST
77088: LIST
77089: PUSH
77090: LD_INT 5
77092: PUSH
77093: LD_INT 0
77095: PUSH
77096: EMPTY
77097: LIST
77098: LIST
77099: PUSH
77100: LD_INT 5
77102: PUSH
77103: LD_INT 1
77105: PUSH
77106: EMPTY
77107: LIST
77108: LIST
77109: PUSH
77110: LD_INT 4
77112: PUSH
77113: LD_INT 1
77115: PUSH
77116: EMPTY
77117: LIST
77118: LIST
77119: PUSH
77120: LD_INT 3
77122: PUSH
77123: LD_INT 0
77125: PUSH
77126: EMPTY
77127: LIST
77128: LIST
77129: PUSH
77130: LD_INT 3
77132: PUSH
77133: LD_INT 1
77135: NEG
77136: PUSH
77137: EMPTY
77138: LIST
77139: LIST
77140: PUSH
77141: LD_INT 3
77143: PUSH
77144: LD_INT 2
77146: NEG
77147: PUSH
77148: EMPTY
77149: LIST
77150: LIST
77151: PUSH
77152: LD_INT 5
77154: PUSH
77155: LD_INT 2
77157: PUSH
77158: EMPTY
77159: LIST
77160: LIST
77161: PUSH
77162: LD_INT 3
77164: PUSH
77165: LD_INT 3
77167: PUSH
77168: EMPTY
77169: LIST
77170: LIST
77171: PUSH
77172: LD_INT 3
77174: PUSH
77175: LD_INT 2
77177: PUSH
77178: EMPTY
77179: LIST
77180: LIST
77181: PUSH
77182: LD_INT 4
77184: PUSH
77185: LD_INT 3
77187: PUSH
77188: EMPTY
77189: LIST
77190: LIST
77191: PUSH
77192: LD_INT 4
77194: PUSH
77195: LD_INT 4
77197: PUSH
77198: EMPTY
77199: LIST
77200: LIST
77201: PUSH
77202: LD_INT 3
77204: PUSH
77205: LD_INT 4
77207: PUSH
77208: EMPTY
77209: LIST
77210: LIST
77211: PUSH
77212: LD_INT 2
77214: PUSH
77215: LD_INT 3
77217: PUSH
77218: EMPTY
77219: LIST
77220: LIST
77221: PUSH
77222: LD_INT 2
77224: PUSH
77225: LD_INT 2
77227: PUSH
77228: EMPTY
77229: LIST
77230: LIST
77231: PUSH
77232: LD_INT 4
77234: PUSH
77235: LD_INT 2
77237: PUSH
77238: EMPTY
77239: LIST
77240: LIST
77241: PUSH
77242: LD_INT 2
77244: PUSH
77245: LD_INT 4
77247: PUSH
77248: EMPTY
77249: LIST
77250: LIST
77251: PUSH
77252: LD_INT 0
77254: PUSH
77255: LD_INT 4
77257: PUSH
77258: EMPTY
77259: LIST
77260: LIST
77261: PUSH
77262: LD_INT 0
77264: PUSH
77265: LD_INT 3
77267: PUSH
77268: EMPTY
77269: LIST
77270: LIST
77271: PUSH
77272: LD_INT 1
77274: PUSH
77275: LD_INT 4
77277: PUSH
77278: EMPTY
77279: LIST
77280: LIST
77281: PUSH
77282: LD_INT 1
77284: PUSH
77285: LD_INT 5
77287: PUSH
77288: EMPTY
77289: LIST
77290: LIST
77291: PUSH
77292: LD_INT 0
77294: PUSH
77295: LD_INT 5
77297: PUSH
77298: EMPTY
77299: LIST
77300: LIST
77301: PUSH
77302: LD_INT 1
77304: NEG
77305: PUSH
77306: LD_INT 4
77308: PUSH
77309: EMPTY
77310: LIST
77311: LIST
77312: PUSH
77313: LD_INT 1
77315: NEG
77316: PUSH
77317: LD_INT 3
77319: PUSH
77320: EMPTY
77321: LIST
77322: LIST
77323: PUSH
77324: LD_INT 2
77326: PUSH
77327: LD_INT 5
77329: PUSH
77330: EMPTY
77331: LIST
77332: LIST
77333: PUSH
77334: LD_INT 2
77336: NEG
77337: PUSH
77338: LD_INT 3
77340: PUSH
77341: EMPTY
77342: LIST
77343: LIST
77344: PUSH
77345: LD_INT 3
77347: NEG
77348: PUSH
77349: LD_INT 0
77351: PUSH
77352: EMPTY
77353: LIST
77354: LIST
77355: PUSH
77356: LD_INT 3
77358: NEG
77359: PUSH
77360: LD_INT 1
77362: NEG
77363: PUSH
77364: EMPTY
77365: LIST
77366: LIST
77367: PUSH
77368: LD_INT 2
77370: NEG
77371: PUSH
77372: LD_INT 0
77374: PUSH
77375: EMPTY
77376: LIST
77377: LIST
77378: PUSH
77379: LD_INT 2
77381: NEG
77382: PUSH
77383: LD_INT 1
77385: PUSH
77386: EMPTY
77387: LIST
77388: LIST
77389: PUSH
77390: LD_INT 3
77392: NEG
77393: PUSH
77394: LD_INT 1
77396: PUSH
77397: EMPTY
77398: LIST
77399: LIST
77400: PUSH
77401: LD_INT 4
77403: NEG
77404: PUSH
77405: LD_INT 0
77407: PUSH
77408: EMPTY
77409: LIST
77410: LIST
77411: PUSH
77412: LD_INT 4
77414: NEG
77415: PUSH
77416: LD_INT 1
77418: NEG
77419: PUSH
77420: EMPTY
77421: LIST
77422: LIST
77423: PUSH
77424: LD_INT 4
77426: NEG
77427: PUSH
77428: LD_INT 2
77430: NEG
77431: PUSH
77432: EMPTY
77433: LIST
77434: LIST
77435: PUSH
77436: LD_INT 2
77438: NEG
77439: PUSH
77440: LD_INT 2
77442: PUSH
77443: EMPTY
77444: LIST
77445: LIST
77446: PUSH
77447: LD_INT 4
77449: NEG
77450: PUSH
77451: LD_INT 4
77453: NEG
77454: PUSH
77455: EMPTY
77456: LIST
77457: LIST
77458: PUSH
77459: LD_INT 4
77461: NEG
77462: PUSH
77463: LD_INT 5
77465: NEG
77466: PUSH
77467: EMPTY
77468: LIST
77469: LIST
77470: PUSH
77471: LD_INT 3
77473: NEG
77474: PUSH
77475: LD_INT 4
77477: NEG
77478: PUSH
77479: EMPTY
77480: LIST
77481: LIST
77482: PUSH
77483: LD_INT 3
77485: NEG
77486: PUSH
77487: LD_INT 3
77489: NEG
77490: PUSH
77491: EMPTY
77492: LIST
77493: LIST
77494: PUSH
77495: LD_INT 4
77497: NEG
77498: PUSH
77499: LD_INT 3
77501: NEG
77502: PUSH
77503: EMPTY
77504: LIST
77505: LIST
77506: PUSH
77507: LD_INT 5
77509: NEG
77510: PUSH
77511: LD_INT 4
77513: NEG
77514: PUSH
77515: EMPTY
77516: LIST
77517: LIST
77518: PUSH
77519: LD_INT 5
77521: NEG
77522: PUSH
77523: LD_INT 5
77525: NEG
77526: PUSH
77527: EMPTY
77528: LIST
77529: LIST
77530: PUSH
77531: LD_INT 3
77533: NEG
77534: PUSH
77535: LD_INT 5
77537: NEG
77538: PUSH
77539: EMPTY
77540: LIST
77541: LIST
77542: PUSH
77543: LD_INT 5
77545: NEG
77546: PUSH
77547: LD_INT 3
77549: NEG
77550: PUSH
77551: EMPTY
77552: LIST
77553: LIST
77554: PUSH
77555: EMPTY
77556: LIST
77557: LIST
77558: LIST
77559: LIST
77560: LIST
77561: LIST
77562: LIST
77563: LIST
77564: LIST
77565: LIST
77566: LIST
77567: LIST
77568: LIST
77569: LIST
77570: LIST
77571: LIST
77572: LIST
77573: LIST
77574: LIST
77575: LIST
77576: LIST
77577: LIST
77578: LIST
77579: LIST
77580: LIST
77581: LIST
77582: LIST
77583: LIST
77584: LIST
77585: LIST
77586: LIST
77587: LIST
77588: LIST
77589: LIST
77590: LIST
77591: LIST
77592: LIST
77593: LIST
77594: LIST
77595: LIST
77596: LIST
77597: LIST
77598: LIST
77599: LIST
77600: LIST
77601: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
77602: LD_ADDR_VAR 0 30
77606: PUSH
77607: LD_INT 4
77609: PUSH
77610: LD_INT 4
77612: PUSH
77613: EMPTY
77614: LIST
77615: LIST
77616: PUSH
77617: LD_INT 4
77619: PUSH
77620: LD_INT 3
77622: PUSH
77623: EMPTY
77624: LIST
77625: LIST
77626: PUSH
77627: LD_INT 5
77629: PUSH
77630: LD_INT 4
77632: PUSH
77633: EMPTY
77634: LIST
77635: LIST
77636: PUSH
77637: LD_INT 5
77639: PUSH
77640: LD_INT 5
77642: PUSH
77643: EMPTY
77644: LIST
77645: LIST
77646: PUSH
77647: LD_INT 4
77649: PUSH
77650: LD_INT 5
77652: PUSH
77653: EMPTY
77654: LIST
77655: LIST
77656: PUSH
77657: LD_INT 3
77659: PUSH
77660: LD_INT 4
77662: PUSH
77663: EMPTY
77664: LIST
77665: LIST
77666: PUSH
77667: LD_INT 3
77669: PUSH
77670: LD_INT 3
77672: PUSH
77673: EMPTY
77674: LIST
77675: LIST
77676: PUSH
77677: LD_INT 5
77679: PUSH
77680: LD_INT 3
77682: PUSH
77683: EMPTY
77684: LIST
77685: LIST
77686: PUSH
77687: LD_INT 3
77689: PUSH
77690: LD_INT 5
77692: PUSH
77693: EMPTY
77694: LIST
77695: LIST
77696: PUSH
77697: LD_INT 0
77699: PUSH
77700: LD_INT 3
77702: PUSH
77703: EMPTY
77704: LIST
77705: LIST
77706: PUSH
77707: LD_INT 0
77709: PUSH
77710: LD_INT 2
77712: PUSH
77713: EMPTY
77714: LIST
77715: LIST
77716: PUSH
77717: LD_INT 1
77719: PUSH
77720: LD_INT 3
77722: PUSH
77723: EMPTY
77724: LIST
77725: LIST
77726: PUSH
77727: LD_INT 1
77729: PUSH
77730: LD_INT 4
77732: PUSH
77733: EMPTY
77734: LIST
77735: LIST
77736: PUSH
77737: LD_INT 0
77739: PUSH
77740: LD_INT 4
77742: PUSH
77743: EMPTY
77744: LIST
77745: LIST
77746: PUSH
77747: LD_INT 1
77749: NEG
77750: PUSH
77751: LD_INT 3
77753: PUSH
77754: EMPTY
77755: LIST
77756: LIST
77757: PUSH
77758: LD_INT 1
77760: NEG
77761: PUSH
77762: LD_INT 2
77764: PUSH
77765: EMPTY
77766: LIST
77767: LIST
77768: PUSH
77769: LD_INT 2
77771: PUSH
77772: LD_INT 4
77774: PUSH
77775: EMPTY
77776: LIST
77777: LIST
77778: PUSH
77779: LD_INT 2
77781: NEG
77782: PUSH
77783: LD_INT 2
77785: PUSH
77786: EMPTY
77787: LIST
77788: LIST
77789: PUSH
77790: LD_INT 4
77792: NEG
77793: PUSH
77794: LD_INT 0
77796: PUSH
77797: EMPTY
77798: LIST
77799: LIST
77800: PUSH
77801: LD_INT 4
77803: NEG
77804: PUSH
77805: LD_INT 1
77807: NEG
77808: PUSH
77809: EMPTY
77810: LIST
77811: LIST
77812: PUSH
77813: LD_INT 3
77815: NEG
77816: PUSH
77817: LD_INT 0
77819: PUSH
77820: EMPTY
77821: LIST
77822: LIST
77823: PUSH
77824: LD_INT 3
77826: NEG
77827: PUSH
77828: LD_INT 1
77830: PUSH
77831: EMPTY
77832: LIST
77833: LIST
77834: PUSH
77835: LD_INT 4
77837: NEG
77838: PUSH
77839: LD_INT 1
77841: PUSH
77842: EMPTY
77843: LIST
77844: LIST
77845: PUSH
77846: LD_INT 5
77848: NEG
77849: PUSH
77850: LD_INT 0
77852: PUSH
77853: EMPTY
77854: LIST
77855: LIST
77856: PUSH
77857: LD_INT 5
77859: NEG
77860: PUSH
77861: LD_INT 1
77863: NEG
77864: PUSH
77865: EMPTY
77866: LIST
77867: LIST
77868: PUSH
77869: LD_INT 5
77871: NEG
77872: PUSH
77873: LD_INT 2
77875: NEG
77876: PUSH
77877: EMPTY
77878: LIST
77879: LIST
77880: PUSH
77881: LD_INT 3
77883: NEG
77884: PUSH
77885: LD_INT 2
77887: PUSH
77888: EMPTY
77889: LIST
77890: LIST
77891: PUSH
77892: LD_INT 3
77894: NEG
77895: PUSH
77896: LD_INT 3
77898: NEG
77899: PUSH
77900: EMPTY
77901: LIST
77902: LIST
77903: PUSH
77904: LD_INT 3
77906: NEG
77907: PUSH
77908: LD_INT 4
77910: NEG
77911: PUSH
77912: EMPTY
77913: LIST
77914: LIST
77915: PUSH
77916: LD_INT 2
77918: NEG
77919: PUSH
77920: LD_INT 3
77922: NEG
77923: PUSH
77924: EMPTY
77925: LIST
77926: LIST
77927: PUSH
77928: LD_INT 2
77930: NEG
77931: PUSH
77932: LD_INT 2
77934: NEG
77935: PUSH
77936: EMPTY
77937: LIST
77938: LIST
77939: PUSH
77940: LD_INT 3
77942: NEG
77943: PUSH
77944: LD_INT 2
77946: NEG
77947: PUSH
77948: EMPTY
77949: LIST
77950: LIST
77951: PUSH
77952: LD_INT 4
77954: NEG
77955: PUSH
77956: LD_INT 3
77958: NEG
77959: PUSH
77960: EMPTY
77961: LIST
77962: LIST
77963: PUSH
77964: LD_INT 4
77966: NEG
77967: PUSH
77968: LD_INT 4
77970: NEG
77971: PUSH
77972: EMPTY
77973: LIST
77974: LIST
77975: PUSH
77976: LD_INT 2
77978: NEG
77979: PUSH
77980: LD_INT 4
77982: NEG
77983: PUSH
77984: EMPTY
77985: LIST
77986: LIST
77987: PUSH
77988: LD_INT 4
77990: NEG
77991: PUSH
77992: LD_INT 2
77994: NEG
77995: PUSH
77996: EMPTY
77997: LIST
77998: LIST
77999: PUSH
78000: LD_INT 0
78002: PUSH
78003: LD_INT 4
78005: NEG
78006: PUSH
78007: EMPTY
78008: LIST
78009: LIST
78010: PUSH
78011: LD_INT 0
78013: PUSH
78014: LD_INT 5
78016: NEG
78017: PUSH
78018: EMPTY
78019: LIST
78020: LIST
78021: PUSH
78022: LD_INT 1
78024: PUSH
78025: LD_INT 4
78027: NEG
78028: PUSH
78029: EMPTY
78030: LIST
78031: LIST
78032: PUSH
78033: LD_INT 1
78035: PUSH
78036: LD_INT 3
78038: NEG
78039: PUSH
78040: EMPTY
78041: LIST
78042: LIST
78043: PUSH
78044: LD_INT 0
78046: PUSH
78047: LD_INT 3
78049: NEG
78050: PUSH
78051: EMPTY
78052: LIST
78053: LIST
78054: PUSH
78055: LD_INT 1
78057: NEG
78058: PUSH
78059: LD_INT 4
78061: NEG
78062: PUSH
78063: EMPTY
78064: LIST
78065: LIST
78066: PUSH
78067: LD_INT 1
78069: NEG
78070: PUSH
78071: LD_INT 5
78073: NEG
78074: PUSH
78075: EMPTY
78076: LIST
78077: LIST
78078: PUSH
78079: LD_INT 2
78081: PUSH
78082: LD_INT 3
78084: NEG
78085: PUSH
78086: EMPTY
78087: LIST
78088: LIST
78089: PUSH
78090: LD_INT 2
78092: NEG
78093: PUSH
78094: LD_INT 5
78096: NEG
78097: PUSH
78098: EMPTY
78099: LIST
78100: LIST
78101: PUSH
78102: EMPTY
78103: LIST
78104: LIST
78105: LIST
78106: LIST
78107: LIST
78108: LIST
78109: LIST
78110: LIST
78111: LIST
78112: LIST
78113: LIST
78114: LIST
78115: LIST
78116: LIST
78117: LIST
78118: LIST
78119: LIST
78120: LIST
78121: LIST
78122: LIST
78123: LIST
78124: LIST
78125: LIST
78126: LIST
78127: LIST
78128: LIST
78129: LIST
78130: LIST
78131: LIST
78132: LIST
78133: LIST
78134: LIST
78135: LIST
78136: LIST
78137: LIST
78138: LIST
78139: LIST
78140: LIST
78141: LIST
78142: LIST
78143: LIST
78144: LIST
78145: LIST
78146: LIST
78147: LIST
78148: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
78149: LD_ADDR_VAR 0 31
78153: PUSH
78154: LD_INT 0
78156: PUSH
78157: LD_INT 4
78159: PUSH
78160: EMPTY
78161: LIST
78162: LIST
78163: PUSH
78164: LD_INT 0
78166: PUSH
78167: LD_INT 3
78169: PUSH
78170: EMPTY
78171: LIST
78172: LIST
78173: PUSH
78174: LD_INT 1
78176: PUSH
78177: LD_INT 4
78179: PUSH
78180: EMPTY
78181: LIST
78182: LIST
78183: PUSH
78184: LD_INT 1
78186: PUSH
78187: LD_INT 5
78189: PUSH
78190: EMPTY
78191: LIST
78192: LIST
78193: PUSH
78194: LD_INT 0
78196: PUSH
78197: LD_INT 5
78199: PUSH
78200: EMPTY
78201: LIST
78202: LIST
78203: PUSH
78204: LD_INT 1
78206: NEG
78207: PUSH
78208: LD_INT 4
78210: PUSH
78211: EMPTY
78212: LIST
78213: LIST
78214: PUSH
78215: LD_INT 1
78217: NEG
78218: PUSH
78219: LD_INT 3
78221: PUSH
78222: EMPTY
78223: LIST
78224: LIST
78225: PUSH
78226: LD_INT 2
78228: PUSH
78229: LD_INT 5
78231: PUSH
78232: EMPTY
78233: LIST
78234: LIST
78235: PUSH
78236: LD_INT 2
78238: NEG
78239: PUSH
78240: LD_INT 3
78242: PUSH
78243: EMPTY
78244: LIST
78245: LIST
78246: PUSH
78247: LD_INT 3
78249: NEG
78250: PUSH
78251: LD_INT 0
78253: PUSH
78254: EMPTY
78255: LIST
78256: LIST
78257: PUSH
78258: LD_INT 3
78260: NEG
78261: PUSH
78262: LD_INT 1
78264: NEG
78265: PUSH
78266: EMPTY
78267: LIST
78268: LIST
78269: PUSH
78270: LD_INT 2
78272: NEG
78273: PUSH
78274: LD_INT 0
78276: PUSH
78277: EMPTY
78278: LIST
78279: LIST
78280: PUSH
78281: LD_INT 2
78283: NEG
78284: PUSH
78285: LD_INT 1
78287: PUSH
78288: EMPTY
78289: LIST
78290: LIST
78291: PUSH
78292: LD_INT 3
78294: NEG
78295: PUSH
78296: LD_INT 1
78298: PUSH
78299: EMPTY
78300: LIST
78301: LIST
78302: PUSH
78303: LD_INT 4
78305: NEG
78306: PUSH
78307: LD_INT 0
78309: PUSH
78310: EMPTY
78311: LIST
78312: LIST
78313: PUSH
78314: LD_INT 4
78316: NEG
78317: PUSH
78318: LD_INT 1
78320: NEG
78321: PUSH
78322: EMPTY
78323: LIST
78324: LIST
78325: PUSH
78326: LD_INT 4
78328: NEG
78329: PUSH
78330: LD_INT 2
78332: NEG
78333: PUSH
78334: EMPTY
78335: LIST
78336: LIST
78337: PUSH
78338: LD_INT 2
78340: NEG
78341: PUSH
78342: LD_INT 2
78344: PUSH
78345: EMPTY
78346: LIST
78347: LIST
78348: PUSH
78349: LD_INT 4
78351: NEG
78352: PUSH
78353: LD_INT 4
78355: NEG
78356: PUSH
78357: EMPTY
78358: LIST
78359: LIST
78360: PUSH
78361: LD_INT 4
78363: NEG
78364: PUSH
78365: LD_INT 5
78367: NEG
78368: PUSH
78369: EMPTY
78370: LIST
78371: LIST
78372: PUSH
78373: LD_INT 3
78375: NEG
78376: PUSH
78377: LD_INT 4
78379: NEG
78380: PUSH
78381: EMPTY
78382: LIST
78383: LIST
78384: PUSH
78385: LD_INT 3
78387: NEG
78388: PUSH
78389: LD_INT 3
78391: NEG
78392: PUSH
78393: EMPTY
78394: LIST
78395: LIST
78396: PUSH
78397: LD_INT 4
78399: NEG
78400: PUSH
78401: LD_INT 3
78403: NEG
78404: PUSH
78405: EMPTY
78406: LIST
78407: LIST
78408: PUSH
78409: LD_INT 5
78411: NEG
78412: PUSH
78413: LD_INT 4
78415: NEG
78416: PUSH
78417: EMPTY
78418: LIST
78419: LIST
78420: PUSH
78421: LD_INT 5
78423: NEG
78424: PUSH
78425: LD_INT 5
78427: NEG
78428: PUSH
78429: EMPTY
78430: LIST
78431: LIST
78432: PUSH
78433: LD_INT 3
78435: NEG
78436: PUSH
78437: LD_INT 5
78439: NEG
78440: PUSH
78441: EMPTY
78442: LIST
78443: LIST
78444: PUSH
78445: LD_INT 5
78447: NEG
78448: PUSH
78449: LD_INT 3
78451: NEG
78452: PUSH
78453: EMPTY
78454: LIST
78455: LIST
78456: PUSH
78457: LD_INT 0
78459: PUSH
78460: LD_INT 3
78462: NEG
78463: PUSH
78464: EMPTY
78465: LIST
78466: LIST
78467: PUSH
78468: LD_INT 0
78470: PUSH
78471: LD_INT 4
78473: NEG
78474: PUSH
78475: EMPTY
78476: LIST
78477: LIST
78478: PUSH
78479: LD_INT 1
78481: PUSH
78482: LD_INT 3
78484: NEG
78485: PUSH
78486: EMPTY
78487: LIST
78488: LIST
78489: PUSH
78490: LD_INT 1
78492: PUSH
78493: LD_INT 2
78495: NEG
78496: PUSH
78497: EMPTY
78498: LIST
78499: LIST
78500: PUSH
78501: LD_INT 0
78503: PUSH
78504: LD_INT 2
78506: NEG
78507: PUSH
78508: EMPTY
78509: LIST
78510: LIST
78511: PUSH
78512: LD_INT 1
78514: NEG
78515: PUSH
78516: LD_INT 3
78518: NEG
78519: PUSH
78520: EMPTY
78521: LIST
78522: LIST
78523: PUSH
78524: LD_INT 1
78526: NEG
78527: PUSH
78528: LD_INT 4
78530: NEG
78531: PUSH
78532: EMPTY
78533: LIST
78534: LIST
78535: PUSH
78536: LD_INT 2
78538: PUSH
78539: LD_INT 2
78541: NEG
78542: PUSH
78543: EMPTY
78544: LIST
78545: LIST
78546: PUSH
78547: LD_INT 2
78549: NEG
78550: PUSH
78551: LD_INT 4
78553: NEG
78554: PUSH
78555: EMPTY
78556: LIST
78557: LIST
78558: PUSH
78559: LD_INT 4
78561: PUSH
78562: LD_INT 0
78564: PUSH
78565: EMPTY
78566: LIST
78567: LIST
78568: PUSH
78569: LD_INT 4
78571: PUSH
78572: LD_INT 1
78574: NEG
78575: PUSH
78576: EMPTY
78577: LIST
78578: LIST
78579: PUSH
78580: LD_INT 5
78582: PUSH
78583: LD_INT 0
78585: PUSH
78586: EMPTY
78587: LIST
78588: LIST
78589: PUSH
78590: LD_INT 5
78592: PUSH
78593: LD_INT 1
78595: PUSH
78596: EMPTY
78597: LIST
78598: LIST
78599: PUSH
78600: LD_INT 4
78602: PUSH
78603: LD_INT 1
78605: PUSH
78606: EMPTY
78607: LIST
78608: LIST
78609: PUSH
78610: LD_INT 3
78612: PUSH
78613: LD_INT 0
78615: PUSH
78616: EMPTY
78617: LIST
78618: LIST
78619: PUSH
78620: LD_INT 3
78622: PUSH
78623: LD_INT 1
78625: NEG
78626: PUSH
78627: EMPTY
78628: LIST
78629: LIST
78630: PUSH
78631: LD_INT 3
78633: PUSH
78634: LD_INT 2
78636: NEG
78637: PUSH
78638: EMPTY
78639: LIST
78640: LIST
78641: PUSH
78642: LD_INT 5
78644: PUSH
78645: LD_INT 2
78647: PUSH
78648: EMPTY
78649: LIST
78650: LIST
78651: PUSH
78652: EMPTY
78653: LIST
78654: LIST
78655: LIST
78656: LIST
78657: LIST
78658: LIST
78659: LIST
78660: LIST
78661: LIST
78662: LIST
78663: LIST
78664: LIST
78665: LIST
78666: LIST
78667: LIST
78668: LIST
78669: LIST
78670: LIST
78671: LIST
78672: LIST
78673: LIST
78674: LIST
78675: LIST
78676: LIST
78677: LIST
78678: LIST
78679: LIST
78680: LIST
78681: LIST
78682: LIST
78683: LIST
78684: LIST
78685: LIST
78686: LIST
78687: LIST
78688: LIST
78689: LIST
78690: LIST
78691: LIST
78692: LIST
78693: LIST
78694: LIST
78695: LIST
78696: LIST
78697: LIST
78698: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
78699: LD_ADDR_VAR 0 32
78703: PUSH
78704: LD_INT 4
78706: NEG
78707: PUSH
78708: LD_INT 0
78710: PUSH
78711: EMPTY
78712: LIST
78713: LIST
78714: PUSH
78715: LD_INT 4
78717: NEG
78718: PUSH
78719: LD_INT 1
78721: NEG
78722: PUSH
78723: EMPTY
78724: LIST
78725: LIST
78726: PUSH
78727: LD_INT 3
78729: NEG
78730: PUSH
78731: LD_INT 0
78733: PUSH
78734: EMPTY
78735: LIST
78736: LIST
78737: PUSH
78738: LD_INT 3
78740: NEG
78741: PUSH
78742: LD_INT 1
78744: PUSH
78745: EMPTY
78746: LIST
78747: LIST
78748: PUSH
78749: LD_INT 4
78751: NEG
78752: PUSH
78753: LD_INT 1
78755: PUSH
78756: EMPTY
78757: LIST
78758: LIST
78759: PUSH
78760: LD_INT 5
78762: NEG
78763: PUSH
78764: LD_INT 0
78766: PUSH
78767: EMPTY
78768: LIST
78769: LIST
78770: PUSH
78771: LD_INT 5
78773: NEG
78774: PUSH
78775: LD_INT 1
78777: NEG
78778: PUSH
78779: EMPTY
78780: LIST
78781: LIST
78782: PUSH
78783: LD_INT 5
78785: NEG
78786: PUSH
78787: LD_INT 2
78789: NEG
78790: PUSH
78791: EMPTY
78792: LIST
78793: LIST
78794: PUSH
78795: LD_INT 3
78797: NEG
78798: PUSH
78799: LD_INT 2
78801: PUSH
78802: EMPTY
78803: LIST
78804: LIST
78805: PUSH
78806: LD_INT 3
78808: NEG
78809: PUSH
78810: LD_INT 3
78812: NEG
78813: PUSH
78814: EMPTY
78815: LIST
78816: LIST
78817: PUSH
78818: LD_INT 3
78820: NEG
78821: PUSH
78822: LD_INT 4
78824: NEG
78825: PUSH
78826: EMPTY
78827: LIST
78828: LIST
78829: PUSH
78830: LD_INT 2
78832: NEG
78833: PUSH
78834: LD_INT 3
78836: NEG
78837: PUSH
78838: EMPTY
78839: LIST
78840: LIST
78841: PUSH
78842: LD_INT 2
78844: NEG
78845: PUSH
78846: LD_INT 2
78848: NEG
78849: PUSH
78850: EMPTY
78851: LIST
78852: LIST
78853: PUSH
78854: LD_INT 3
78856: NEG
78857: PUSH
78858: LD_INT 2
78860: NEG
78861: PUSH
78862: EMPTY
78863: LIST
78864: LIST
78865: PUSH
78866: LD_INT 4
78868: NEG
78869: PUSH
78870: LD_INT 3
78872: NEG
78873: PUSH
78874: EMPTY
78875: LIST
78876: LIST
78877: PUSH
78878: LD_INT 4
78880: NEG
78881: PUSH
78882: LD_INT 4
78884: NEG
78885: PUSH
78886: EMPTY
78887: LIST
78888: LIST
78889: PUSH
78890: LD_INT 2
78892: NEG
78893: PUSH
78894: LD_INT 4
78896: NEG
78897: PUSH
78898: EMPTY
78899: LIST
78900: LIST
78901: PUSH
78902: LD_INT 4
78904: NEG
78905: PUSH
78906: LD_INT 2
78908: NEG
78909: PUSH
78910: EMPTY
78911: LIST
78912: LIST
78913: PUSH
78914: LD_INT 0
78916: PUSH
78917: LD_INT 4
78919: NEG
78920: PUSH
78921: EMPTY
78922: LIST
78923: LIST
78924: PUSH
78925: LD_INT 0
78927: PUSH
78928: LD_INT 5
78930: NEG
78931: PUSH
78932: EMPTY
78933: LIST
78934: LIST
78935: PUSH
78936: LD_INT 1
78938: PUSH
78939: LD_INT 4
78941: NEG
78942: PUSH
78943: EMPTY
78944: LIST
78945: LIST
78946: PUSH
78947: LD_INT 1
78949: PUSH
78950: LD_INT 3
78952: NEG
78953: PUSH
78954: EMPTY
78955: LIST
78956: LIST
78957: PUSH
78958: LD_INT 0
78960: PUSH
78961: LD_INT 3
78963: NEG
78964: PUSH
78965: EMPTY
78966: LIST
78967: LIST
78968: PUSH
78969: LD_INT 1
78971: NEG
78972: PUSH
78973: LD_INT 4
78975: NEG
78976: PUSH
78977: EMPTY
78978: LIST
78979: LIST
78980: PUSH
78981: LD_INT 1
78983: NEG
78984: PUSH
78985: LD_INT 5
78987: NEG
78988: PUSH
78989: EMPTY
78990: LIST
78991: LIST
78992: PUSH
78993: LD_INT 2
78995: PUSH
78996: LD_INT 3
78998: NEG
78999: PUSH
79000: EMPTY
79001: LIST
79002: LIST
79003: PUSH
79004: LD_INT 2
79006: NEG
79007: PUSH
79008: LD_INT 5
79010: NEG
79011: PUSH
79012: EMPTY
79013: LIST
79014: LIST
79015: PUSH
79016: LD_INT 3
79018: PUSH
79019: LD_INT 0
79021: PUSH
79022: EMPTY
79023: LIST
79024: LIST
79025: PUSH
79026: LD_INT 3
79028: PUSH
79029: LD_INT 1
79031: NEG
79032: PUSH
79033: EMPTY
79034: LIST
79035: LIST
79036: PUSH
79037: LD_INT 4
79039: PUSH
79040: LD_INT 0
79042: PUSH
79043: EMPTY
79044: LIST
79045: LIST
79046: PUSH
79047: LD_INT 4
79049: PUSH
79050: LD_INT 1
79052: PUSH
79053: EMPTY
79054: LIST
79055: LIST
79056: PUSH
79057: LD_INT 3
79059: PUSH
79060: LD_INT 1
79062: PUSH
79063: EMPTY
79064: LIST
79065: LIST
79066: PUSH
79067: LD_INT 2
79069: PUSH
79070: LD_INT 0
79072: PUSH
79073: EMPTY
79074: LIST
79075: LIST
79076: PUSH
79077: LD_INT 2
79079: PUSH
79080: LD_INT 1
79082: NEG
79083: PUSH
79084: EMPTY
79085: LIST
79086: LIST
79087: PUSH
79088: LD_INT 2
79090: PUSH
79091: LD_INT 2
79093: NEG
79094: PUSH
79095: EMPTY
79096: LIST
79097: LIST
79098: PUSH
79099: LD_INT 4
79101: PUSH
79102: LD_INT 2
79104: PUSH
79105: EMPTY
79106: LIST
79107: LIST
79108: PUSH
79109: LD_INT 4
79111: PUSH
79112: LD_INT 4
79114: PUSH
79115: EMPTY
79116: LIST
79117: LIST
79118: PUSH
79119: LD_INT 4
79121: PUSH
79122: LD_INT 3
79124: PUSH
79125: EMPTY
79126: LIST
79127: LIST
79128: PUSH
79129: LD_INT 5
79131: PUSH
79132: LD_INT 4
79134: PUSH
79135: EMPTY
79136: LIST
79137: LIST
79138: PUSH
79139: LD_INT 5
79141: PUSH
79142: LD_INT 5
79144: PUSH
79145: EMPTY
79146: LIST
79147: LIST
79148: PUSH
79149: LD_INT 4
79151: PUSH
79152: LD_INT 5
79154: PUSH
79155: EMPTY
79156: LIST
79157: LIST
79158: PUSH
79159: LD_INT 3
79161: PUSH
79162: LD_INT 4
79164: PUSH
79165: EMPTY
79166: LIST
79167: LIST
79168: PUSH
79169: LD_INT 3
79171: PUSH
79172: LD_INT 3
79174: PUSH
79175: EMPTY
79176: LIST
79177: LIST
79178: PUSH
79179: LD_INT 5
79181: PUSH
79182: LD_INT 3
79184: PUSH
79185: EMPTY
79186: LIST
79187: LIST
79188: PUSH
79189: LD_INT 3
79191: PUSH
79192: LD_INT 5
79194: PUSH
79195: EMPTY
79196: LIST
79197: LIST
79198: PUSH
79199: EMPTY
79200: LIST
79201: LIST
79202: LIST
79203: LIST
79204: LIST
79205: LIST
79206: LIST
79207: LIST
79208: LIST
79209: LIST
79210: LIST
79211: LIST
79212: LIST
79213: LIST
79214: LIST
79215: LIST
79216: LIST
79217: LIST
79218: LIST
79219: LIST
79220: LIST
79221: LIST
79222: LIST
79223: LIST
79224: LIST
79225: LIST
79226: LIST
79227: LIST
79228: LIST
79229: LIST
79230: LIST
79231: LIST
79232: LIST
79233: LIST
79234: LIST
79235: LIST
79236: LIST
79237: LIST
79238: LIST
79239: LIST
79240: LIST
79241: LIST
79242: LIST
79243: LIST
79244: LIST
79245: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
79246: LD_ADDR_VAR 0 33
79250: PUSH
79251: LD_INT 4
79253: NEG
79254: PUSH
79255: LD_INT 4
79257: NEG
79258: PUSH
79259: EMPTY
79260: LIST
79261: LIST
79262: PUSH
79263: LD_INT 4
79265: NEG
79266: PUSH
79267: LD_INT 5
79269: NEG
79270: PUSH
79271: EMPTY
79272: LIST
79273: LIST
79274: PUSH
79275: LD_INT 3
79277: NEG
79278: PUSH
79279: LD_INT 4
79281: NEG
79282: PUSH
79283: EMPTY
79284: LIST
79285: LIST
79286: PUSH
79287: LD_INT 3
79289: NEG
79290: PUSH
79291: LD_INT 3
79293: NEG
79294: PUSH
79295: EMPTY
79296: LIST
79297: LIST
79298: PUSH
79299: LD_INT 4
79301: NEG
79302: PUSH
79303: LD_INT 3
79305: NEG
79306: PUSH
79307: EMPTY
79308: LIST
79309: LIST
79310: PUSH
79311: LD_INT 5
79313: NEG
79314: PUSH
79315: LD_INT 4
79317: NEG
79318: PUSH
79319: EMPTY
79320: LIST
79321: LIST
79322: PUSH
79323: LD_INT 5
79325: NEG
79326: PUSH
79327: LD_INT 5
79329: NEG
79330: PUSH
79331: EMPTY
79332: LIST
79333: LIST
79334: PUSH
79335: LD_INT 3
79337: NEG
79338: PUSH
79339: LD_INT 5
79341: NEG
79342: PUSH
79343: EMPTY
79344: LIST
79345: LIST
79346: PUSH
79347: LD_INT 5
79349: NEG
79350: PUSH
79351: LD_INT 3
79353: NEG
79354: PUSH
79355: EMPTY
79356: LIST
79357: LIST
79358: PUSH
79359: LD_INT 0
79361: PUSH
79362: LD_INT 3
79364: NEG
79365: PUSH
79366: EMPTY
79367: LIST
79368: LIST
79369: PUSH
79370: LD_INT 0
79372: PUSH
79373: LD_INT 4
79375: NEG
79376: PUSH
79377: EMPTY
79378: LIST
79379: LIST
79380: PUSH
79381: LD_INT 1
79383: PUSH
79384: LD_INT 3
79386: NEG
79387: PUSH
79388: EMPTY
79389: LIST
79390: LIST
79391: PUSH
79392: LD_INT 1
79394: PUSH
79395: LD_INT 2
79397: NEG
79398: PUSH
79399: EMPTY
79400: LIST
79401: LIST
79402: PUSH
79403: LD_INT 0
79405: PUSH
79406: LD_INT 2
79408: NEG
79409: PUSH
79410: EMPTY
79411: LIST
79412: LIST
79413: PUSH
79414: LD_INT 1
79416: NEG
79417: PUSH
79418: LD_INT 3
79420: NEG
79421: PUSH
79422: EMPTY
79423: LIST
79424: LIST
79425: PUSH
79426: LD_INT 1
79428: NEG
79429: PUSH
79430: LD_INT 4
79432: NEG
79433: PUSH
79434: EMPTY
79435: LIST
79436: LIST
79437: PUSH
79438: LD_INT 2
79440: PUSH
79441: LD_INT 2
79443: NEG
79444: PUSH
79445: EMPTY
79446: LIST
79447: LIST
79448: PUSH
79449: LD_INT 2
79451: NEG
79452: PUSH
79453: LD_INT 4
79455: NEG
79456: PUSH
79457: EMPTY
79458: LIST
79459: LIST
79460: PUSH
79461: LD_INT 4
79463: PUSH
79464: LD_INT 0
79466: PUSH
79467: EMPTY
79468: LIST
79469: LIST
79470: PUSH
79471: LD_INT 4
79473: PUSH
79474: LD_INT 1
79476: NEG
79477: PUSH
79478: EMPTY
79479: LIST
79480: LIST
79481: PUSH
79482: LD_INT 5
79484: PUSH
79485: LD_INT 0
79487: PUSH
79488: EMPTY
79489: LIST
79490: LIST
79491: PUSH
79492: LD_INT 5
79494: PUSH
79495: LD_INT 1
79497: PUSH
79498: EMPTY
79499: LIST
79500: LIST
79501: PUSH
79502: LD_INT 4
79504: PUSH
79505: LD_INT 1
79507: PUSH
79508: EMPTY
79509: LIST
79510: LIST
79511: PUSH
79512: LD_INT 3
79514: PUSH
79515: LD_INT 0
79517: PUSH
79518: EMPTY
79519: LIST
79520: LIST
79521: PUSH
79522: LD_INT 3
79524: PUSH
79525: LD_INT 1
79527: NEG
79528: PUSH
79529: EMPTY
79530: LIST
79531: LIST
79532: PUSH
79533: LD_INT 3
79535: PUSH
79536: LD_INT 2
79538: NEG
79539: PUSH
79540: EMPTY
79541: LIST
79542: LIST
79543: PUSH
79544: LD_INT 5
79546: PUSH
79547: LD_INT 2
79549: PUSH
79550: EMPTY
79551: LIST
79552: LIST
79553: PUSH
79554: LD_INT 3
79556: PUSH
79557: LD_INT 3
79559: PUSH
79560: EMPTY
79561: LIST
79562: LIST
79563: PUSH
79564: LD_INT 3
79566: PUSH
79567: LD_INT 2
79569: PUSH
79570: EMPTY
79571: LIST
79572: LIST
79573: PUSH
79574: LD_INT 4
79576: PUSH
79577: LD_INT 3
79579: PUSH
79580: EMPTY
79581: LIST
79582: LIST
79583: PUSH
79584: LD_INT 4
79586: PUSH
79587: LD_INT 4
79589: PUSH
79590: EMPTY
79591: LIST
79592: LIST
79593: PUSH
79594: LD_INT 3
79596: PUSH
79597: LD_INT 4
79599: PUSH
79600: EMPTY
79601: LIST
79602: LIST
79603: PUSH
79604: LD_INT 2
79606: PUSH
79607: LD_INT 3
79609: PUSH
79610: EMPTY
79611: LIST
79612: LIST
79613: PUSH
79614: LD_INT 2
79616: PUSH
79617: LD_INT 2
79619: PUSH
79620: EMPTY
79621: LIST
79622: LIST
79623: PUSH
79624: LD_INT 4
79626: PUSH
79627: LD_INT 2
79629: PUSH
79630: EMPTY
79631: LIST
79632: LIST
79633: PUSH
79634: LD_INT 2
79636: PUSH
79637: LD_INT 4
79639: PUSH
79640: EMPTY
79641: LIST
79642: LIST
79643: PUSH
79644: LD_INT 0
79646: PUSH
79647: LD_INT 4
79649: PUSH
79650: EMPTY
79651: LIST
79652: LIST
79653: PUSH
79654: LD_INT 0
79656: PUSH
79657: LD_INT 3
79659: PUSH
79660: EMPTY
79661: LIST
79662: LIST
79663: PUSH
79664: LD_INT 1
79666: PUSH
79667: LD_INT 4
79669: PUSH
79670: EMPTY
79671: LIST
79672: LIST
79673: PUSH
79674: LD_INT 1
79676: PUSH
79677: LD_INT 5
79679: PUSH
79680: EMPTY
79681: LIST
79682: LIST
79683: PUSH
79684: LD_INT 0
79686: PUSH
79687: LD_INT 5
79689: PUSH
79690: EMPTY
79691: LIST
79692: LIST
79693: PUSH
79694: LD_INT 1
79696: NEG
79697: PUSH
79698: LD_INT 4
79700: PUSH
79701: EMPTY
79702: LIST
79703: LIST
79704: PUSH
79705: LD_INT 1
79707: NEG
79708: PUSH
79709: LD_INT 3
79711: PUSH
79712: EMPTY
79713: LIST
79714: LIST
79715: PUSH
79716: LD_INT 2
79718: PUSH
79719: LD_INT 5
79721: PUSH
79722: EMPTY
79723: LIST
79724: LIST
79725: PUSH
79726: LD_INT 2
79728: NEG
79729: PUSH
79730: LD_INT 3
79732: PUSH
79733: EMPTY
79734: LIST
79735: LIST
79736: PUSH
79737: EMPTY
79738: LIST
79739: LIST
79740: LIST
79741: LIST
79742: LIST
79743: LIST
79744: LIST
79745: LIST
79746: LIST
79747: LIST
79748: LIST
79749: LIST
79750: LIST
79751: LIST
79752: LIST
79753: LIST
79754: LIST
79755: LIST
79756: LIST
79757: LIST
79758: LIST
79759: LIST
79760: LIST
79761: LIST
79762: LIST
79763: LIST
79764: LIST
79765: LIST
79766: LIST
79767: LIST
79768: LIST
79769: LIST
79770: LIST
79771: LIST
79772: LIST
79773: LIST
79774: LIST
79775: LIST
79776: LIST
79777: LIST
79778: LIST
79779: LIST
79780: LIST
79781: LIST
79782: LIST
79783: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
79784: LD_ADDR_VAR 0 34
79788: PUSH
79789: LD_INT 0
79791: PUSH
79792: LD_INT 4
79794: NEG
79795: PUSH
79796: EMPTY
79797: LIST
79798: LIST
79799: PUSH
79800: LD_INT 0
79802: PUSH
79803: LD_INT 5
79805: NEG
79806: PUSH
79807: EMPTY
79808: LIST
79809: LIST
79810: PUSH
79811: LD_INT 1
79813: PUSH
79814: LD_INT 4
79816: NEG
79817: PUSH
79818: EMPTY
79819: LIST
79820: LIST
79821: PUSH
79822: LD_INT 1
79824: PUSH
79825: LD_INT 3
79827: NEG
79828: PUSH
79829: EMPTY
79830: LIST
79831: LIST
79832: PUSH
79833: LD_INT 0
79835: PUSH
79836: LD_INT 3
79838: NEG
79839: PUSH
79840: EMPTY
79841: LIST
79842: LIST
79843: PUSH
79844: LD_INT 1
79846: NEG
79847: PUSH
79848: LD_INT 4
79850: NEG
79851: PUSH
79852: EMPTY
79853: LIST
79854: LIST
79855: PUSH
79856: LD_INT 1
79858: NEG
79859: PUSH
79860: LD_INT 5
79862: NEG
79863: PUSH
79864: EMPTY
79865: LIST
79866: LIST
79867: PUSH
79868: LD_INT 2
79870: PUSH
79871: LD_INT 3
79873: NEG
79874: PUSH
79875: EMPTY
79876: LIST
79877: LIST
79878: PUSH
79879: LD_INT 2
79881: NEG
79882: PUSH
79883: LD_INT 5
79885: NEG
79886: PUSH
79887: EMPTY
79888: LIST
79889: LIST
79890: PUSH
79891: LD_INT 3
79893: PUSH
79894: LD_INT 0
79896: PUSH
79897: EMPTY
79898: LIST
79899: LIST
79900: PUSH
79901: LD_INT 3
79903: PUSH
79904: LD_INT 1
79906: NEG
79907: PUSH
79908: EMPTY
79909: LIST
79910: LIST
79911: PUSH
79912: LD_INT 4
79914: PUSH
79915: LD_INT 0
79917: PUSH
79918: EMPTY
79919: LIST
79920: LIST
79921: PUSH
79922: LD_INT 4
79924: PUSH
79925: LD_INT 1
79927: PUSH
79928: EMPTY
79929: LIST
79930: LIST
79931: PUSH
79932: LD_INT 3
79934: PUSH
79935: LD_INT 1
79937: PUSH
79938: EMPTY
79939: LIST
79940: LIST
79941: PUSH
79942: LD_INT 2
79944: PUSH
79945: LD_INT 0
79947: PUSH
79948: EMPTY
79949: LIST
79950: LIST
79951: PUSH
79952: LD_INT 2
79954: PUSH
79955: LD_INT 1
79957: NEG
79958: PUSH
79959: EMPTY
79960: LIST
79961: LIST
79962: PUSH
79963: LD_INT 2
79965: PUSH
79966: LD_INT 2
79968: NEG
79969: PUSH
79970: EMPTY
79971: LIST
79972: LIST
79973: PUSH
79974: LD_INT 4
79976: PUSH
79977: LD_INT 2
79979: PUSH
79980: EMPTY
79981: LIST
79982: LIST
79983: PUSH
79984: LD_INT 4
79986: PUSH
79987: LD_INT 4
79989: PUSH
79990: EMPTY
79991: LIST
79992: LIST
79993: PUSH
79994: LD_INT 4
79996: PUSH
79997: LD_INT 3
79999: PUSH
80000: EMPTY
80001: LIST
80002: LIST
80003: PUSH
80004: LD_INT 5
80006: PUSH
80007: LD_INT 4
80009: PUSH
80010: EMPTY
80011: LIST
80012: LIST
80013: PUSH
80014: LD_INT 5
80016: PUSH
80017: LD_INT 5
80019: PUSH
80020: EMPTY
80021: LIST
80022: LIST
80023: PUSH
80024: LD_INT 4
80026: PUSH
80027: LD_INT 5
80029: PUSH
80030: EMPTY
80031: LIST
80032: LIST
80033: PUSH
80034: LD_INT 3
80036: PUSH
80037: LD_INT 4
80039: PUSH
80040: EMPTY
80041: LIST
80042: LIST
80043: PUSH
80044: LD_INT 3
80046: PUSH
80047: LD_INT 3
80049: PUSH
80050: EMPTY
80051: LIST
80052: LIST
80053: PUSH
80054: LD_INT 5
80056: PUSH
80057: LD_INT 3
80059: PUSH
80060: EMPTY
80061: LIST
80062: LIST
80063: PUSH
80064: LD_INT 3
80066: PUSH
80067: LD_INT 5
80069: PUSH
80070: EMPTY
80071: LIST
80072: LIST
80073: PUSH
80074: LD_INT 0
80076: PUSH
80077: LD_INT 3
80079: PUSH
80080: EMPTY
80081: LIST
80082: LIST
80083: PUSH
80084: LD_INT 0
80086: PUSH
80087: LD_INT 2
80089: PUSH
80090: EMPTY
80091: LIST
80092: LIST
80093: PUSH
80094: LD_INT 1
80096: PUSH
80097: LD_INT 3
80099: PUSH
80100: EMPTY
80101: LIST
80102: LIST
80103: PUSH
80104: LD_INT 1
80106: PUSH
80107: LD_INT 4
80109: PUSH
80110: EMPTY
80111: LIST
80112: LIST
80113: PUSH
80114: LD_INT 0
80116: PUSH
80117: LD_INT 4
80119: PUSH
80120: EMPTY
80121: LIST
80122: LIST
80123: PUSH
80124: LD_INT 1
80126: NEG
80127: PUSH
80128: LD_INT 3
80130: PUSH
80131: EMPTY
80132: LIST
80133: LIST
80134: PUSH
80135: LD_INT 1
80137: NEG
80138: PUSH
80139: LD_INT 2
80141: PUSH
80142: EMPTY
80143: LIST
80144: LIST
80145: PUSH
80146: LD_INT 2
80148: PUSH
80149: LD_INT 4
80151: PUSH
80152: EMPTY
80153: LIST
80154: LIST
80155: PUSH
80156: LD_INT 2
80158: NEG
80159: PUSH
80160: LD_INT 2
80162: PUSH
80163: EMPTY
80164: LIST
80165: LIST
80166: PUSH
80167: LD_INT 4
80169: NEG
80170: PUSH
80171: LD_INT 0
80173: PUSH
80174: EMPTY
80175: LIST
80176: LIST
80177: PUSH
80178: LD_INT 4
80180: NEG
80181: PUSH
80182: LD_INT 1
80184: NEG
80185: PUSH
80186: EMPTY
80187: LIST
80188: LIST
80189: PUSH
80190: LD_INT 3
80192: NEG
80193: PUSH
80194: LD_INT 0
80196: PUSH
80197: EMPTY
80198: LIST
80199: LIST
80200: PUSH
80201: LD_INT 3
80203: NEG
80204: PUSH
80205: LD_INT 1
80207: PUSH
80208: EMPTY
80209: LIST
80210: LIST
80211: PUSH
80212: LD_INT 4
80214: NEG
80215: PUSH
80216: LD_INT 1
80218: PUSH
80219: EMPTY
80220: LIST
80221: LIST
80222: PUSH
80223: LD_INT 5
80225: NEG
80226: PUSH
80227: LD_INT 0
80229: PUSH
80230: EMPTY
80231: LIST
80232: LIST
80233: PUSH
80234: LD_INT 5
80236: NEG
80237: PUSH
80238: LD_INT 1
80240: NEG
80241: PUSH
80242: EMPTY
80243: LIST
80244: LIST
80245: PUSH
80246: LD_INT 5
80248: NEG
80249: PUSH
80250: LD_INT 2
80252: NEG
80253: PUSH
80254: EMPTY
80255: LIST
80256: LIST
80257: PUSH
80258: LD_INT 3
80260: NEG
80261: PUSH
80262: LD_INT 2
80264: PUSH
80265: EMPTY
80266: LIST
80267: LIST
80268: PUSH
80269: EMPTY
80270: LIST
80271: LIST
80272: LIST
80273: LIST
80274: LIST
80275: LIST
80276: LIST
80277: LIST
80278: LIST
80279: LIST
80280: LIST
80281: LIST
80282: LIST
80283: LIST
80284: LIST
80285: LIST
80286: LIST
80287: LIST
80288: LIST
80289: LIST
80290: LIST
80291: LIST
80292: LIST
80293: LIST
80294: LIST
80295: LIST
80296: LIST
80297: LIST
80298: LIST
80299: LIST
80300: LIST
80301: LIST
80302: LIST
80303: LIST
80304: LIST
80305: LIST
80306: LIST
80307: LIST
80308: LIST
80309: LIST
80310: LIST
80311: LIST
80312: LIST
80313: LIST
80314: LIST
80315: ST_TO_ADDR
// end ; end ;
80316: GO 80319
80318: POP
// case btype of b_depot , b_warehouse :
80319: LD_VAR 0 1
80323: PUSH
80324: LD_INT 0
80326: DOUBLE
80327: EQUAL
80328: IFTRUE 80338
80330: LD_INT 1
80332: DOUBLE
80333: EQUAL
80334: IFTRUE 80338
80336: GO 80539
80338: POP
// case nation of nation_american :
80339: LD_VAR 0 5
80343: PUSH
80344: LD_INT 1
80346: DOUBLE
80347: EQUAL
80348: IFTRUE 80352
80350: GO 80408
80352: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
80353: LD_ADDR_VAR 0 9
80357: PUSH
80358: LD_VAR 0 11
80362: PUSH
80363: LD_VAR 0 12
80367: PUSH
80368: LD_VAR 0 13
80372: PUSH
80373: LD_VAR 0 14
80377: PUSH
80378: LD_VAR 0 15
80382: PUSH
80383: LD_VAR 0 16
80387: PUSH
80388: EMPTY
80389: LIST
80390: LIST
80391: LIST
80392: LIST
80393: LIST
80394: LIST
80395: PUSH
80396: LD_VAR 0 4
80400: PUSH
80401: LD_INT 1
80403: PLUS
80404: ARRAY
80405: ST_TO_ADDR
80406: GO 80537
80408: LD_INT 2
80410: DOUBLE
80411: EQUAL
80412: IFTRUE 80416
80414: GO 80472
80416: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
80417: LD_ADDR_VAR 0 9
80421: PUSH
80422: LD_VAR 0 17
80426: PUSH
80427: LD_VAR 0 18
80431: PUSH
80432: LD_VAR 0 19
80436: PUSH
80437: LD_VAR 0 20
80441: PUSH
80442: LD_VAR 0 21
80446: PUSH
80447: LD_VAR 0 22
80451: PUSH
80452: EMPTY
80453: LIST
80454: LIST
80455: LIST
80456: LIST
80457: LIST
80458: LIST
80459: PUSH
80460: LD_VAR 0 4
80464: PUSH
80465: LD_INT 1
80467: PLUS
80468: ARRAY
80469: ST_TO_ADDR
80470: GO 80537
80472: LD_INT 3
80474: DOUBLE
80475: EQUAL
80476: IFTRUE 80480
80478: GO 80536
80480: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
80481: LD_ADDR_VAR 0 9
80485: PUSH
80486: LD_VAR 0 23
80490: PUSH
80491: LD_VAR 0 24
80495: PUSH
80496: LD_VAR 0 25
80500: PUSH
80501: LD_VAR 0 26
80505: PUSH
80506: LD_VAR 0 27
80510: PUSH
80511: LD_VAR 0 28
80515: PUSH
80516: EMPTY
80517: LIST
80518: LIST
80519: LIST
80520: LIST
80521: LIST
80522: LIST
80523: PUSH
80524: LD_VAR 0 4
80528: PUSH
80529: LD_INT 1
80531: PLUS
80532: ARRAY
80533: ST_TO_ADDR
80534: GO 80537
80536: POP
80537: GO 81092
80539: LD_INT 2
80541: DOUBLE
80542: EQUAL
80543: IFTRUE 80553
80545: LD_INT 3
80547: DOUBLE
80548: EQUAL
80549: IFTRUE 80553
80551: GO 80609
80553: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
80554: LD_ADDR_VAR 0 9
80558: PUSH
80559: LD_VAR 0 29
80563: PUSH
80564: LD_VAR 0 30
80568: PUSH
80569: LD_VAR 0 31
80573: PUSH
80574: LD_VAR 0 32
80578: PUSH
80579: LD_VAR 0 33
80583: PUSH
80584: LD_VAR 0 34
80588: PUSH
80589: EMPTY
80590: LIST
80591: LIST
80592: LIST
80593: LIST
80594: LIST
80595: LIST
80596: PUSH
80597: LD_VAR 0 4
80601: PUSH
80602: LD_INT 1
80604: PLUS
80605: ARRAY
80606: ST_TO_ADDR
80607: GO 81092
80609: LD_INT 16
80611: DOUBLE
80612: EQUAL
80613: IFTRUE 80671
80615: LD_INT 17
80617: DOUBLE
80618: EQUAL
80619: IFTRUE 80671
80621: LD_INT 18
80623: DOUBLE
80624: EQUAL
80625: IFTRUE 80671
80627: LD_INT 19
80629: DOUBLE
80630: EQUAL
80631: IFTRUE 80671
80633: LD_INT 22
80635: DOUBLE
80636: EQUAL
80637: IFTRUE 80671
80639: LD_INT 20
80641: DOUBLE
80642: EQUAL
80643: IFTRUE 80671
80645: LD_INT 21
80647: DOUBLE
80648: EQUAL
80649: IFTRUE 80671
80651: LD_INT 23
80653: DOUBLE
80654: EQUAL
80655: IFTRUE 80671
80657: LD_INT 24
80659: DOUBLE
80660: EQUAL
80661: IFTRUE 80671
80663: LD_INT 25
80665: DOUBLE
80666: EQUAL
80667: IFTRUE 80671
80669: GO 80727
80671: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
80672: LD_ADDR_VAR 0 9
80676: PUSH
80677: LD_VAR 0 35
80681: PUSH
80682: LD_VAR 0 36
80686: PUSH
80687: LD_VAR 0 37
80691: PUSH
80692: LD_VAR 0 38
80696: PUSH
80697: LD_VAR 0 39
80701: PUSH
80702: LD_VAR 0 40
80706: PUSH
80707: EMPTY
80708: LIST
80709: LIST
80710: LIST
80711: LIST
80712: LIST
80713: LIST
80714: PUSH
80715: LD_VAR 0 4
80719: PUSH
80720: LD_INT 1
80722: PLUS
80723: ARRAY
80724: ST_TO_ADDR
80725: GO 81092
80727: LD_INT 6
80729: DOUBLE
80730: EQUAL
80731: IFTRUE 80783
80733: LD_INT 7
80735: DOUBLE
80736: EQUAL
80737: IFTRUE 80783
80739: LD_INT 8
80741: DOUBLE
80742: EQUAL
80743: IFTRUE 80783
80745: LD_INT 13
80747: DOUBLE
80748: EQUAL
80749: IFTRUE 80783
80751: LD_INT 12
80753: DOUBLE
80754: EQUAL
80755: IFTRUE 80783
80757: LD_INT 15
80759: DOUBLE
80760: EQUAL
80761: IFTRUE 80783
80763: LD_INT 11
80765: DOUBLE
80766: EQUAL
80767: IFTRUE 80783
80769: LD_INT 14
80771: DOUBLE
80772: EQUAL
80773: IFTRUE 80783
80775: LD_INT 10
80777: DOUBLE
80778: EQUAL
80779: IFTRUE 80783
80781: GO 80839
80783: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
80784: LD_ADDR_VAR 0 9
80788: PUSH
80789: LD_VAR 0 41
80793: PUSH
80794: LD_VAR 0 42
80798: PUSH
80799: LD_VAR 0 43
80803: PUSH
80804: LD_VAR 0 44
80808: PUSH
80809: LD_VAR 0 45
80813: PUSH
80814: LD_VAR 0 46
80818: PUSH
80819: EMPTY
80820: LIST
80821: LIST
80822: LIST
80823: LIST
80824: LIST
80825: LIST
80826: PUSH
80827: LD_VAR 0 4
80831: PUSH
80832: LD_INT 1
80834: PLUS
80835: ARRAY
80836: ST_TO_ADDR
80837: GO 81092
80839: LD_INT 36
80841: DOUBLE
80842: EQUAL
80843: IFTRUE 80847
80845: GO 80903
80847: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
80848: LD_ADDR_VAR 0 9
80852: PUSH
80853: LD_VAR 0 47
80857: PUSH
80858: LD_VAR 0 48
80862: PUSH
80863: LD_VAR 0 49
80867: PUSH
80868: LD_VAR 0 50
80872: PUSH
80873: LD_VAR 0 51
80877: PUSH
80878: LD_VAR 0 52
80882: PUSH
80883: EMPTY
80884: LIST
80885: LIST
80886: LIST
80887: LIST
80888: LIST
80889: LIST
80890: PUSH
80891: LD_VAR 0 4
80895: PUSH
80896: LD_INT 1
80898: PLUS
80899: ARRAY
80900: ST_TO_ADDR
80901: GO 81092
80903: LD_INT 4
80905: DOUBLE
80906: EQUAL
80907: IFTRUE 80929
80909: LD_INT 5
80911: DOUBLE
80912: EQUAL
80913: IFTRUE 80929
80915: LD_INT 34
80917: DOUBLE
80918: EQUAL
80919: IFTRUE 80929
80921: LD_INT 37
80923: DOUBLE
80924: EQUAL
80925: IFTRUE 80929
80927: GO 80985
80929: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
80930: LD_ADDR_VAR 0 9
80934: PUSH
80935: LD_VAR 0 53
80939: PUSH
80940: LD_VAR 0 54
80944: PUSH
80945: LD_VAR 0 55
80949: PUSH
80950: LD_VAR 0 56
80954: PUSH
80955: LD_VAR 0 57
80959: PUSH
80960: LD_VAR 0 58
80964: PUSH
80965: EMPTY
80966: LIST
80967: LIST
80968: LIST
80969: LIST
80970: LIST
80971: LIST
80972: PUSH
80973: LD_VAR 0 4
80977: PUSH
80978: LD_INT 1
80980: PLUS
80981: ARRAY
80982: ST_TO_ADDR
80983: GO 81092
80985: LD_INT 31
80987: DOUBLE
80988: EQUAL
80989: IFTRUE 81035
80991: LD_INT 32
80993: DOUBLE
80994: EQUAL
80995: IFTRUE 81035
80997: LD_INT 33
80999: DOUBLE
81000: EQUAL
81001: IFTRUE 81035
81003: LD_INT 27
81005: DOUBLE
81006: EQUAL
81007: IFTRUE 81035
81009: LD_INT 26
81011: DOUBLE
81012: EQUAL
81013: IFTRUE 81035
81015: LD_INT 28
81017: DOUBLE
81018: EQUAL
81019: IFTRUE 81035
81021: LD_INT 29
81023: DOUBLE
81024: EQUAL
81025: IFTRUE 81035
81027: LD_INT 30
81029: DOUBLE
81030: EQUAL
81031: IFTRUE 81035
81033: GO 81091
81035: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
81036: LD_ADDR_VAR 0 9
81040: PUSH
81041: LD_VAR 0 59
81045: PUSH
81046: LD_VAR 0 60
81050: PUSH
81051: LD_VAR 0 61
81055: PUSH
81056: LD_VAR 0 62
81060: PUSH
81061: LD_VAR 0 63
81065: PUSH
81066: LD_VAR 0 64
81070: PUSH
81071: EMPTY
81072: LIST
81073: LIST
81074: LIST
81075: LIST
81076: LIST
81077: LIST
81078: PUSH
81079: LD_VAR 0 4
81083: PUSH
81084: LD_INT 1
81086: PLUS
81087: ARRAY
81088: ST_TO_ADDR
81089: GO 81092
81091: POP
// temp_list2 = [ ] ;
81092: LD_ADDR_VAR 0 10
81096: PUSH
81097: EMPTY
81098: ST_TO_ADDR
// for i in temp_list do
81099: LD_ADDR_VAR 0 8
81103: PUSH
81104: LD_VAR 0 9
81108: PUSH
81109: FOR_IN
81110: IFFALSE 81162
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
81112: LD_ADDR_VAR 0 10
81116: PUSH
81117: LD_VAR 0 10
81121: PUSH
81122: LD_VAR 0 8
81126: PUSH
81127: LD_INT 1
81129: ARRAY
81130: PUSH
81131: LD_VAR 0 2
81135: PLUS
81136: PUSH
81137: LD_VAR 0 8
81141: PUSH
81142: LD_INT 2
81144: ARRAY
81145: PUSH
81146: LD_VAR 0 3
81150: PLUS
81151: PUSH
81152: EMPTY
81153: LIST
81154: LIST
81155: PUSH
81156: EMPTY
81157: LIST
81158: ADD
81159: ST_TO_ADDR
81160: GO 81109
81162: POP
81163: POP
// result = temp_list2 ;
81164: LD_ADDR_VAR 0 7
81168: PUSH
81169: LD_VAR 0 10
81173: ST_TO_ADDR
// end ;
81174: LD_VAR 0 7
81178: RET
// export function EnemyInRange ( unit , dist ) ; begin
81179: LD_INT 0
81181: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
81182: LD_ADDR_VAR 0 3
81186: PUSH
81187: LD_VAR 0 1
81191: PPUSH
81192: CALL_OW 255
81196: PPUSH
81197: LD_VAR 0 1
81201: PPUSH
81202: CALL_OW 250
81206: PPUSH
81207: LD_VAR 0 1
81211: PPUSH
81212: CALL_OW 251
81216: PPUSH
81217: LD_VAR 0 2
81221: PPUSH
81222: CALL 55283 0 4
81226: PUSH
81227: LD_INT 4
81229: ARRAY
81230: ST_TO_ADDR
// end ;
81231: LD_VAR 0 3
81235: RET
// export function PlayerSeeMe ( unit ) ; begin
81236: LD_INT 0
81238: PPUSH
// result := See ( your_side , unit ) ;
81239: LD_ADDR_VAR 0 2
81243: PUSH
81244: LD_OWVAR 2
81248: PPUSH
81249: LD_VAR 0 1
81253: PPUSH
81254: CALL_OW 292
81258: ST_TO_ADDR
// end ;
81259: LD_VAR 0 2
81263: RET
// export function ReverseDir ( unit ) ; begin
81264: LD_INT 0
81266: PPUSH
// if not unit then
81267: LD_VAR 0 1
81271: NOT
81272: IFFALSE 81276
// exit ;
81274: GO 81322
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
81276: LD_ADDR_VAR 0 2
81280: PUSH
81281: LD_INT 3
81283: PUSH
81284: LD_INT 4
81286: PUSH
81287: LD_INT 5
81289: PUSH
81290: LD_INT 0
81292: PUSH
81293: LD_INT 1
81295: PUSH
81296: LD_INT 2
81298: PUSH
81299: EMPTY
81300: LIST
81301: LIST
81302: LIST
81303: LIST
81304: LIST
81305: LIST
81306: PUSH
81307: LD_VAR 0 1
81311: PPUSH
81312: CALL_OW 254
81316: PUSH
81317: LD_INT 1
81319: PLUS
81320: ARRAY
81321: ST_TO_ADDR
// end ;
81322: LD_VAR 0 2
81326: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
81327: LD_INT 0
81329: PPUSH
81330: PPUSH
81331: PPUSH
81332: PPUSH
81333: PPUSH
// if not hexes then
81334: LD_VAR 0 2
81338: NOT
81339: IFFALSE 81343
// exit ;
81341: GO 81491
// dist := 9999 ;
81343: LD_ADDR_VAR 0 5
81347: PUSH
81348: LD_INT 9999
81350: ST_TO_ADDR
// for i = 1 to hexes do
81351: LD_ADDR_VAR 0 4
81355: PUSH
81356: DOUBLE
81357: LD_INT 1
81359: DEC
81360: ST_TO_ADDR
81361: LD_VAR 0 2
81365: PUSH
81366: FOR_TO
81367: IFFALSE 81479
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
81369: LD_VAR 0 1
81373: PPUSH
81374: LD_VAR 0 2
81378: PUSH
81379: LD_VAR 0 4
81383: ARRAY
81384: PUSH
81385: LD_INT 1
81387: ARRAY
81388: PPUSH
81389: LD_VAR 0 2
81393: PUSH
81394: LD_VAR 0 4
81398: ARRAY
81399: PUSH
81400: LD_INT 2
81402: ARRAY
81403: PPUSH
81404: CALL_OW 297
81408: PUSH
81409: LD_VAR 0 5
81413: LESS
81414: IFFALSE 81477
// begin hex := hexes [ i ] ;
81416: LD_ADDR_VAR 0 7
81420: PUSH
81421: LD_VAR 0 2
81425: PUSH
81426: LD_VAR 0 4
81430: ARRAY
81431: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
81432: LD_ADDR_VAR 0 5
81436: PUSH
81437: LD_VAR 0 1
81441: PPUSH
81442: LD_VAR 0 2
81446: PUSH
81447: LD_VAR 0 4
81451: ARRAY
81452: PUSH
81453: LD_INT 1
81455: ARRAY
81456: PPUSH
81457: LD_VAR 0 2
81461: PUSH
81462: LD_VAR 0 4
81466: ARRAY
81467: PUSH
81468: LD_INT 2
81470: ARRAY
81471: PPUSH
81472: CALL_OW 297
81476: ST_TO_ADDR
// end ; end ;
81477: GO 81366
81479: POP
81480: POP
// result := hex ;
81481: LD_ADDR_VAR 0 3
81485: PUSH
81486: LD_VAR 0 7
81490: ST_TO_ADDR
// end ;
81491: LD_VAR 0 3
81495: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
81496: LD_INT 0
81498: PPUSH
81499: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
81500: LD_VAR 0 1
81504: NOT
81505: PUSH
81506: LD_VAR 0 1
81510: PUSH
81511: LD_INT 21
81513: PUSH
81514: LD_INT 2
81516: PUSH
81517: EMPTY
81518: LIST
81519: LIST
81520: PUSH
81521: LD_INT 23
81523: PUSH
81524: LD_INT 2
81526: PUSH
81527: EMPTY
81528: LIST
81529: LIST
81530: PUSH
81531: EMPTY
81532: LIST
81533: LIST
81534: PPUSH
81535: CALL_OW 69
81539: IN
81540: NOT
81541: OR
81542: IFFALSE 81546
// exit ;
81544: GO 81593
// for i = 1 to 3 do
81546: LD_ADDR_VAR 0 3
81550: PUSH
81551: DOUBLE
81552: LD_INT 1
81554: DEC
81555: ST_TO_ADDR
81556: LD_INT 3
81558: PUSH
81559: FOR_TO
81560: IFFALSE 81591
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
81562: LD_VAR 0 1
81566: PPUSH
81567: CALL_OW 250
81571: PPUSH
81572: LD_VAR 0 1
81576: PPUSH
81577: CALL_OW 251
81581: PPUSH
81582: LD_INT 1
81584: PPUSH
81585: CALL_OW 453
81589: GO 81559
81591: POP
81592: POP
// end ;
81593: LD_VAR 0 2
81597: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
81598: LD_INT 0
81600: PPUSH
81601: PPUSH
81602: PPUSH
81603: PPUSH
81604: PPUSH
81605: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
81606: LD_VAR 0 1
81610: NOT
81611: PUSH
81612: LD_VAR 0 2
81616: NOT
81617: OR
81618: PUSH
81619: LD_VAR 0 1
81623: PPUSH
81624: CALL_OW 314
81628: OR
81629: IFFALSE 81633
// exit ;
81631: GO 82074
// x := GetX ( enemy_unit ) ;
81633: LD_ADDR_VAR 0 7
81637: PUSH
81638: LD_VAR 0 2
81642: PPUSH
81643: CALL_OW 250
81647: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
81648: LD_ADDR_VAR 0 8
81652: PUSH
81653: LD_VAR 0 2
81657: PPUSH
81658: CALL_OW 251
81662: ST_TO_ADDR
// if not x or not y then
81663: LD_VAR 0 7
81667: NOT
81668: PUSH
81669: LD_VAR 0 8
81673: NOT
81674: OR
81675: IFFALSE 81679
// exit ;
81677: GO 82074
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
81679: LD_ADDR_VAR 0 6
81683: PUSH
81684: LD_VAR 0 7
81688: PPUSH
81689: LD_INT 0
81691: PPUSH
81692: LD_INT 4
81694: PPUSH
81695: CALL_OW 272
81699: PUSH
81700: LD_VAR 0 8
81704: PPUSH
81705: LD_INT 0
81707: PPUSH
81708: LD_INT 4
81710: PPUSH
81711: CALL_OW 273
81715: PUSH
81716: EMPTY
81717: LIST
81718: LIST
81719: PUSH
81720: LD_VAR 0 7
81724: PPUSH
81725: LD_INT 1
81727: PPUSH
81728: LD_INT 4
81730: PPUSH
81731: CALL_OW 272
81735: PUSH
81736: LD_VAR 0 8
81740: PPUSH
81741: LD_INT 1
81743: PPUSH
81744: LD_INT 4
81746: PPUSH
81747: CALL_OW 273
81751: PUSH
81752: EMPTY
81753: LIST
81754: LIST
81755: PUSH
81756: LD_VAR 0 7
81760: PPUSH
81761: LD_INT 2
81763: PPUSH
81764: LD_INT 4
81766: PPUSH
81767: CALL_OW 272
81771: PUSH
81772: LD_VAR 0 8
81776: PPUSH
81777: LD_INT 2
81779: PPUSH
81780: LD_INT 4
81782: PPUSH
81783: CALL_OW 273
81787: PUSH
81788: EMPTY
81789: LIST
81790: LIST
81791: PUSH
81792: LD_VAR 0 7
81796: PPUSH
81797: LD_INT 3
81799: PPUSH
81800: LD_INT 4
81802: PPUSH
81803: CALL_OW 272
81807: PUSH
81808: LD_VAR 0 8
81812: PPUSH
81813: LD_INT 3
81815: PPUSH
81816: LD_INT 4
81818: PPUSH
81819: CALL_OW 273
81823: PUSH
81824: EMPTY
81825: LIST
81826: LIST
81827: PUSH
81828: LD_VAR 0 7
81832: PPUSH
81833: LD_INT 4
81835: PPUSH
81836: LD_INT 4
81838: PPUSH
81839: CALL_OW 272
81843: PUSH
81844: LD_VAR 0 8
81848: PPUSH
81849: LD_INT 4
81851: PPUSH
81852: LD_INT 4
81854: PPUSH
81855: CALL_OW 273
81859: PUSH
81860: EMPTY
81861: LIST
81862: LIST
81863: PUSH
81864: LD_VAR 0 7
81868: PPUSH
81869: LD_INT 5
81871: PPUSH
81872: LD_INT 4
81874: PPUSH
81875: CALL_OW 272
81879: PUSH
81880: LD_VAR 0 8
81884: PPUSH
81885: LD_INT 5
81887: PPUSH
81888: LD_INT 4
81890: PPUSH
81891: CALL_OW 273
81895: PUSH
81896: EMPTY
81897: LIST
81898: LIST
81899: PUSH
81900: EMPTY
81901: LIST
81902: LIST
81903: LIST
81904: LIST
81905: LIST
81906: LIST
81907: ST_TO_ADDR
// for i = tmp downto 1 do
81908: LD_ADDR_VAR 0 4
81912: PUSH
81913: DOUBLE
81914: LD_VAR 0 6
81918: INC
81919: ST_TO_ADDR
81920: LD_INT 1
81922: PUSH
81923: FOR_DOWNTO
81924: IFFALSE 82025
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
81926: LD_VAR 0 6
81930: PUSH
81931: LD_VAR 0 4
81935: ARRAY
81936: PUSH
81937: LD_INT 1
81939: ARRAY
81940: PPUSH
81941: LD_VAR 0 6
81945: PUSH
81946: LD_VAR 0 4
81950: ARRAY
81951: PUSH
81952: LD_INT 2
81954: ARRAY
81955: PPUSH
81956: CALL_OW 488
81960: NOT
81961: PUSH
81962: LD_VAR 0 6
81966: PUSH
81967: LD_VAR 0 4
81971: ARRAY
81972: PUSH
81973: LD_INT 1
81975: ARRAY
81976: PPUSH
81977: LD_VAR 0 6
81981: PUSH
81982: LD_VAR 0 4
81986: ARRAY
81987: PUSH
81988: LD_INT 2
81990: ARRAY
81991: PPUSH
81992: CALL_OW 428
81996: PUSH
81997: LD_INT 0
81999: NONEQUAL
82000: OR
82001: IFFALSE 82023
// tmp := Delete ( tmp , i ) ;
82003: LD_ADDR_VAR 0 6
82007: PUSH
82008: LD_VAR 0 6
82012: PPUSH
82013: LD_VAR 0 4
82017: PPUSH
82018: CALL_OW 3
82022: ST_TO_ADDR
82023: GO 81923
82025: POP
82026: POP
// j := GetClosestHex ( unit , tmp ) ;
82027: LD_ADDR_VAR 0 5
82031: PUSH
82032: LD_VAR 0 1
82036: PPUSH
82037: LD_VAR 0 6
82041: PPUSH
82042: CALL 81327 0 2
82046: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
82047: LD_VAR 0 1
82051: PPUSH
82052: LD_VAR 0 5
82056: PUSH
82057: LD_INT 1
82059: ARRAY
82060: PPUSH
82061: LD_VAR 0 5
82065: PUSH
82066: LD_INT 2
82068: ARRAY
82069: PPUSH
82070: CALL_OW 111
// end ;
82074: LD_VAR 0 3
82078: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
82079: LD_INT 0
82081: PPUSH
82082: PPUSH
82083: PPUSH
// uc_side = 0 ;
82084: LD_ADDR_OWVAR 20
82088: PUSH
82089: LD_INT 0
82091: ST_TO_ADDR
// uc_nation = 0 ;
82092: LD_ADDR_OWVAR 21
82096: PUSH
82097: LD_INT 0
82099: ST_TO_ADDR
// InitHc ;
82100: CALL_OW 19
// InitVc ;
82104: CALL_OW 20
// if mastodonts then
82108: LD_VAR 0 6
82112: IFFALSE 82179
// for i = 1 to mastodonts do
82114: LD_ADDR_VAR 0 11
82118: PUSH
82119: DOUBLE
82120: LD_INT 1
82122: DEC
82123: ST_TO_ADDR
82124: LD_VAR 0 6
82128: PUSH
82129: FOR_TO
82130: IFFALSE 82177
// begin vc_chassis := 31 ;
82132: LD_ADDR_OWVAR 37
82136: PUSH
82137: LD_INT 31
82139: ST_TO_ADDR
// vc_control := control_rider ;
82140: LD_ADDR_OWVAR 38
82144: PUSH
82145: LD_INT 4
82147: ST_TO_ADDR
// animal := CreateVehicle ;
82148: LD_ADDR_VAR 0 12
82152: PUSH
82153: CALL_OW 45
82157: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82158: LD_VAR 0 12
82162: PPUSH
82163: LD_VAR 0 8
82167: PPUSH
82168: LD_INT 0
82170: PPUSH
82171: CALL 88924 0 3
// end ;
82175: GO 82129
82177: POP
82178: POP
// if horses then
82179: LD_VAR 0 5
82183: IFFALSE 82250
// for i = 1 to horses do
82185: LD_ADDR_VAR 0 11
82189: PUSH
82190: DOUBLE
82191: LD_INT 1
82193: DEC
82194: ST_TO_ADDR
82195: LD_VAR 0 5
82199: PUSH
82200: FOR_TO
82201: IFFALSE 82248
// begin hc_class := 21 ;
82203: LD_ADDR_OWVAR 28
82207: PUSH
82208: LD_INT 21
82210: ST_TO_ADDR
// hc_gallery :=  ;
82211: LD_ADDR_OWVAR 33
82215: PUSH
82216: LD_STRING 
82218: ST_TO_ADDR
// animal := CreateHuman ;
82219: LD_ADDR_VAR 0 12
82223: PUSH
82224: CALL_OW 44
82228: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82229: LD_VAR 0 12
82233: PPUSH
82234: LD_VAR 0 8
82238: PPUSH
82239: LD_INT 0
82241: PPUSH
82242: CALL 88924 0 3
// end ;
82246: GO 82200
82248: POP
82249: POP
// if birds then
82250: LD_VAR 0 1
82254: IFFALSE 82321
// for i = 1 to birds do
82256: LD_ADDR_VAR 0 11
82260: PUSH
82261: DOUBLE
82262: LD_INT 1
82264: DEC
82265: ST_TO_ADDR
82266: LD_VAR 0 1
82270: PUSH
82271: FOR_TO
82272: IFFALSE 82319
// begin hc_class = 18 ;
82274: LD_ADDR_OWVAR 28
82278: PUSH
82279: LD_INT 18
82281: ST_TO_ADDR
// hc_gallery =  ;
82282: LD_ADDR_OWVAR 33
82286: PUSH
82287: LD_STRING 
82289: ST_TO_ADDR
// animal := CreateHuman ;
82290: LD_ADDR_VAR 0 12
82294: PUSH
82295: CALL_OW 44
82299: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82300: LD_VAR 0 12
82304: PPUSH
82305: LD_VAR 0 8
82309: PPUSH
82310: LD_INT 0
82312: PPUSH
82313: CALL 88924 0 3
// end ;
82317: GO 82271
82319: POP
82320: POP
// if tigers then
82321: LD_VAR 0 2
82325: IFFALSE 82409
// for i = 1 to tigers do
82327: LD_ADDR_VAR 0 11
82331: PUSH
82332: DOUBLE
82333: LD_INT 1
82335: DEC
82336: ST_TO_ADDR
82337: LD_VAR 0 2
82341: PUSH
82342: FOR_TO
82343: IFFALSE 82407
// begin hc_class = class_tiger ;
82345: LD_ADDR_OWVAR 28
82349: PUSH
82350: LD_INT 14
82352: ST_TO_ADDR
// hc_gallery =  ;
82353: LD_ADDR_OWVAR 33
82357: PUSH
82358: LD_STRING 
82360: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
82361: LD_ADDR_OWVAR 35
82365: PUSH
82366: LD_INT 7
82368: NEG
82369: PPUSH
82370: LD_INT 7
82372: PPUSH
82373: CALL_OW 12
82377: ST_TO_ADDR
// animal := CreateHuman ;
82378: LD_ADDR_VAR 0 12
82382: PUSH
82383: CALL_OW 44
82387: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82388: LD_VAR 0 12
82392: PPUSH
82393: LD_VAR 0 8
82397: PPUSH
82398: LD_INT 0
82400: PPUSH
82401: CALL 88924 0 3
// end ;
82405: GO 82342
82407: POP
82408: POP
// if apemans then
82409: LD_VAR 0 3
82413: IFFALSE 82536
// for i = 1 to apemans do
82415: LD_ADDR_VAR 0 11
82419: PUSH
82420: DOUBLE
82421: LD_INT 1
82423: DEC
82424: ST_TO_ADDR
82425: LD_VAR 0 3
82429: PUSH
82430: FOR_TO
82431: IFFALSE 82534
// begin hc_class = class_apeman ;
82433: LD_ADDR_OWVAR 28
82437: PUSH
82438: LD_INT 12
82440: ST_TO_ADDR
// hc_gallery =  ;
82441: LD_ADDR_OWVAR 33
82445: PUSH
82446: LD_STRING 
82448: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
82449: LD_ADDR_OWVAR 35
82453: PUSH
82454: LD_INT 5
82456: NEG
82457: PPUSH
82458: LD_INT 5
82460: PPUSH
82461: CALL_OW 12
82465: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
82466: LD_ADDR_OWVAR 31
82470: PUSH
82471: LD_INT 1
82473: PPUSH
82474: LD_INT 3
82476: PPUSH
82477: CALL_OW 12
82481: PUSH
82482: LD_INT 1
82484: PPUSH
82485: LD_INT 3
82487: PPUSH
82488: CALL_OW 12
82492: PUSH
82493: LD_INT 0
82495: PUSH
82496: LD_INT 0
82498: PUSH
82499: EMPTY
82500: LIST
82501: LIST
82502: LIST
82503: LIST
82504: ST_TO_ADDR
// animal := CreateHuman ;
82505: LD_ADDR_VAR 0 12
82509: PUSH
82510: CALL_OW 44
82514: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82515: LD_VAR 0 12
82519: PPUSH
82520: LD_VAR 0 8
82524: PPUSH
82525: LD_INT 0
82527: PPUSH
82528: CALL 88924 0 3
// end ;
82532: GO 82430
82534: POP
82535: POP
// if enchidnas then
82536: LD_VAR 0 4
82540: IFFALSE 82607
// for i = 1 to enchidnas do
82542: LD_ADDR_VAR 0 11
82546: PUSH
82547: DOUBLE
82548: LD_INT 1
82550: DEC
82551: ST_TO_ADDR
82552: LD_VAR 0 4
82556: PUSH
82557: FOR_TO
82558: IFFALSE 82605
// begin hc_class = 13 ;
82560: LD_ADDR_OWVAR 28
82564: PUSH
82565: LD_INT 13
82567: ST_TO_ADDR
// hc_gallery =  ;
82568: LD_ADDR_OWVAR 33
82572: PUSH
82573: LD_STRING 
82575: ST_TO_ADDR
// animal := CreateHuman ;
82576: LD_ADDR_VAR 0 12
82580: PUSH
82581: CALL_OW 44
82585: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82586: LD_VAR 0 12
82590: PPUSH
82591: LD_VAR 0 8
82595: PPUSH
82596: LD_INT 0
82598: PPUSH
82599: CALL 88924 0 3
// end ;
82603: GO 82557
82605: POP
82606: POP
// if fishes then
82607: LD_VAR 0 7
82611: IFFALSE 82678
// for i = 1 to fishes do
82613: LD_ADDR_VAR 0 11
82617: PUSH
82618: DOUBLE
82619: LD_INT 1
82621: DEC
82622: ST_TO_ADDR
82623: LD_VAR 0 7
82627: PUSH
82628: FOR_TO
82629: IFFALSE 82676
// begin hc_class = 20 ;
82631: LD_ADDR_OWVAR 28
82635: PUSH
82636: LD_INT 20
82638: ST_TO_ADDR
// hc_gallery =  ;
82639: LD_ADDR_OWVAR 33
82643: PUSH
82644: LD_STRING 
82646: ST_TO_ADDR
// animal := CreateHuman ;
82647: LD_ADDR_VAR 0 12
82651: PUSH
82652: CALL_OW 44
82656: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
82657: LD_VAR 0 12
82661: PPUSH
82662: LD_VAR 0 9
82666: PPUSH
82667: LD_INT 0
82669: PPUSH
82670: CALL 88924 0 3
// end ;
82674: GO 82628
82676: POP
82677: POP
// end ;
82678: LD_VAR 0 10
82682: RET
// export function WantHeal ( sci , unit ) ; begin
82683: LD_INT 0
82685: PPUSH
// if GetTaskList ( sci ) > 0 then
82686: LD_VAR 0 1
82690: PPUSH
82691: CALL_OW 437
82695: PUSH
82696: LD_INT 0
82698: GREATER
82699: IFFALSE 82769
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
82701: LD_VAR 0 1
82705: PPUSH
82706: CALL_OW 437
82710: PUSH
82711: LD_INT 1
82713: ARRAY
82714: PUSH
82715: LD_INT 1
82717: ARRAY
82718: PUSH
82719: LD_STRING l
82721: EQUAL
82722: PUSH
82723: LD_VAR 0 1
82727: PPUSH
82728: CALL_OW 437
82732: PUSH
82733: LD_INT 1
82735: ARRAY
82736: PUSH
82737: LD_INT 4
82739: ARRAY
82740: PUSH
82741: LD_VAR 0 2
82745: EQUAL
82746: AND
82747: IFFALSE 82759
// result := true else
82749: LD_ADDR_VAR 0 3
82753: PUSH
82754: LD_INT 1
82756: ST_TO_ADDR
82757: GO 82767
// result := false ;
82759: LD_ADDR_VAR 0 3
82763: PUSH
82764: LD_INT 0
82766: ST_TO_ADDR
// end else
82767: GO 82777
// result := false ;
82769: LD_ADDR_VAR 0 3
82773: PUSH
82774: LD_INT 0
82776: ST_TO_ADDR
// end ;
82777: LD_VAR 0 3
82781: RET
// export function HealTarget ( sci ) ; begin
82782: LD_INT 0
82784: PPUSH
// if not sci then
82785: LD_VAR 0 1
82789: NOT
82790: IFFALSE 82794
// exit ;
82792: GO 82859
// result := 0 ;
82794: LD_ADDR_VAR 0 2
82798: PUSH
82799: LD_INT 0
82801: ST_TO_ADDR
// if GetTaskList ( sci ) then
82802: LD_VAR 0 1
82806: PPUSH
82807: CALL_OW 437
82811: IFFALSE 82859
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
82813: LD_VAR 0 1
82817: PPUSH
82818: CALL_OW 437
82822: PUSH
82823: LD_INT 1
82825: ARRAY
82826: PUSH
82827: LD_INT 1
82829: ARRAY
82830: PUSH
82831: LD_STRING l
82833: EQUAL
82834: IFFALSE 82859
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
82836: LD_ADDR_VAR 0 2
82840: PUSH
82841: LD_VAR 0 1
82845: PPUSH
82846: CALL_OW 437
82850: PUSH
82851: LD_INT 1
82853: ARRAY
82854: PUSH
82855: LD_INT 4
82857: ARRAY
82858: ST_TO_ADDR
// end ;
82859: LD_VAR 0 2
82863: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
82864: LD_INT 0
82866: PPUSH
82867: PPUSH
82868: PPUSH
82869: PPUSH
82870: PPUSH
82871: PPUSH
82872: PPUSH
82873: PPUSH
82874: PPUSH
82875: PPUSH
82876: PPUSH
82877: PPUSH
82878: PPUSH
82879: PPUSH
82880: PPUSH
82881: PPUSH
82882: PPUSH
82883: PPUSH
82884: PPUSH
82885: PPUSH
82886: PPUSH
82887: PPUSH
82888: PPUSH
82889: PPUSH
82890: PPUSH
82891: PPUSH
82892: PPUSH
82893: PPUSH
82894: PPUSH
82895: PPUSH
82896: PPUSH
82897: PPUSH
82898: PPUSH
82899: PPUSH
// if not list then
82900: LD_VAR 0 1
82904: NOT
82905: IFFALSE 82909
// exit ;
82907: GO 87535
// base := list [ 1 ] ;
82909: LD_ADDR_VAR 0 3
82913: PUSH
82914: LD_VAR 0 1
82918: PUSH
82919: LD_INT 1
82921: ARRAY
82922: ST_TO_ADDR
// group := list [ 2 ] ;
82923: LD_ADDR_VAR 0 4
82927: PUSH
82928: LD_VAR 0 1
82932: PUSH
82933: LD_INT 2
82935: ARRAY
82936: ST_TO_ADDR
// path := list [ 3 ] ;
82937: LD_ADDR_VAR 0 5
82941: PUSH
82942: LD_VAR 0 1
82946: PUSH
82947: LD_INT 3
82949: ARRAY
82950: ST_TO_ADDR
// flags := list [ 4 ] ;
82951: LD_ADDR_VAR 0 6
82955: PUSH
82956: LD_VAR 0 1
82960: PUSH
82961: LD_INT 4
82963: ARRAY
82964: ST_TO_ADDR
// mined := [ ] ;
82965: LD_ADDR_VAR 0 27
82969: PUSH
82970: EMPTY
82971: ST_TO_ADDR
// bombed := [ ] ;
82972: LD_ADDR_VAR 0 28
82976: PUSH
82977: EMPTY
82978: ST_TO_ADDR
// healers := [ ] ;
82979: LD_ADDR_VAR 0 31
82983: PUSH
82984: EMPTY
82985: ST_TO_ADDR
// to_heal := [ ] ;
82986: LD_ADDR_VAR 0 30
82990: PUSH
82991: EMPTY
82992: ST_TO_ADDR
// repairs := [ ] ;
82993: LD_ADDR_VAR 0 33
82997: PUSH
82998: EMPTY
82999: ST_TO_ADDR
// to_repair := [ ] ;
83000: LD_ADDR_VAR 0 32
83004: PUSH
83005: EMPTY
83006: ST_TO_ADDR
// if not group or not path then
83007: LD_VAR 0 4
83011: NOT
83012: PUSH
83013: LD_VAR 0 5
83017: NOT
83018: OR
83019: IFFALSE 83023
// exit ;
83021: GO 87535
// side := GetSide ( group [ 1 ] ) ;
83023: LD_ADDR_VAR 0 35
83027: PUSH
83028: LD_VAR 0 4
83032: PUSH
83033: LD_INT 1
83035: ARRAY
83036: PPUSH
83037: CALL_OW 255
83041: ST_TO_ADDR
// if flags then
83042: LD_VAR 0 6
83046: IFFALSE 83190
// begin f_ignore_area := flags [ 1 ] ;
83048: LD_ADDR_VAR 0 17
83052: PUSH
83053: LD_VAR 0 6
83057: PUSH
83058: LD_INT 1
83060: ARRAY
83061: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
83062: LD_ADDR_VAR 0 18
83066: PUSH
83067: LD_VAR 0 6
83071: PUSH
83072: LD_INT 2
83074: ARRAY
83075: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
83076: LD_ADDR_VAR 0 19
83080: PUSH
83081: LD_VAR 0 6
83085: PUSH
83086: LD_INT 3
83088: ARRAY
83089: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
83090: LD_ADDR_VAR 0 20
83094: PUSH
83095: LD_VAR 0 6
83099: PUSH
83100: LD_INT 4
83102: ARRAY
83103: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
83104: LD_ADDR_VAR 0 21
83108: PUSH
83109: LD_VAR 0 6
83113: PUSH
83114: LD_INT 5
83116: ARRAY
83117: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
83118: LD_ADDR_VAR 0 22
83122: PUSH
83123: LD_VAR 0 6
83127: PUSH
83128: LD_INT 6
83130: ARRAY
83131: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
83132: LD_ADDR_VAR 0 23
83136: PUSH
83137: LD_VAR 0 6
83141: PUSH
83142: LD_INT 7
83144: ARRAY
83145: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
83146: LD_ADDR_VAR 0 24
83150: PUSH
83151: LD_VAR 0 6
83155: PUSH
83156: LD_INT 8
83158: ARRAY
83159: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
83160: LD_ADDR_VAR 0 25
83164: PUSH
83165: LD_VAR 0 6
83169: PUSH
83170: LD_INT 9
83172: ARRAY
83173: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
83174: LD_ADDR_VAR 0 26
83178: PUSH
83179: LD_VAR 0 6
83183: PUSH
83184: LD_INT 10
83186: ARRAY
83187: ST_TO_ADDR
// end else
83188: GO 83270
// begin f_ignore_area := false ;
83190: LD_ADDR_VAR 0 17
83194: PUSH
83195: LD_INT 0
83197: ST_TO_ADDR
// f_capture := false ;
83198: LD_ADDR_VAR 0 18
83202: PUSH
83203: LD_INT 0
83205: ST_TO_ADDR
// f_ignore_civ := false ;
83206: LD_ADDR_VAR 0 19
83210: PUSH
83211: LD_INT 0
83213: ST_TO_ADDR
// f_murder := false ;
83214: LD_ADDR_VAR 0 20
83218: PUSH
83219: LD_INT 0
83221: ST_TO_ADDR
// f_mines := false ;
83222: LD_ADDR_VAR 0 21
83226: PUSH
83227: LD_INT 0
83229: ST_TO_ADDR
// f_repair := false ;
83230: LD_ADDR_VAR 0 22
83234: PUSH
83235: LD_INT 0
83237: ST_TO_ADDR
// f_heal := false ;
83238: LD_ADDR_VAR 0 23
83242: PUSH
83243: LD_INT 0
83245: ST_TO_ADDR
// f_spacetime := false ;
83246: LD_ADDR_VAR 0 24
83250: PUSH
83251: LD_INT 0
83253: ST_TO_ADDR
// f_attack_depot := false ;
83254: LD_ADDR_VAR 0 25
83258: PUSH
83259: LD_INT 0
83261: ST_TO_ADDR
// f_crawl := false ;
83262: LD_ADDR_VAR 0 26
83266: PUSH
83267: LD_INT 0
83269: ST_TO_ADDR
// end ; if f_heal then
83270: LD_VAR 0 23
83274: IFFALSE 83301
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
83276: LD_ADDR_VAR 0 31
83280: PUSH
83281: LD_VAR 0 4
83285: PPUSH
83286: LD_INT 25
83288: PUSH
83289: LD_INT 4
83291: PUSH
83292: EMPTY
83293: LIST
83294: LIST
83295: PPUSH
83296: CALL_OW 72
83300: ST_TO_ADDR
// if f_repair then
83301: LD_VAR 0 22
83305: IFFALSE 83332
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
83307: LD_ADDR_VAR 0 33
83311: PUSH
83312: LD_VAR 0 4
83316: PPUSH
83317: LD_INT 25
83319: PUSH
83320: LD_INT 3
83322: PUSH
83323: EMPTY
83324: LIST
83325: LIST
83326: PPUSH
83327: CALL_OW 72
83331: ST_TO_ADDR
// units_path := [ ] ;
83332: LD_ADDR_VAR 0 16
83336: PUSH
83337: EMPTY
83338: ST_TO_ADDR
// for i = 1 to group do
83339: LD_ADDR_VAR 0 7
83343: PUSH
83344: DOUBLE
83345: LD_INT 1
83347: DEC
83348: ST_TO_ADDR
83349: LD_VAR 0 4
83353: PUSH
83354: FOR_TO
83355: IFFALSE 83384
// units_path := Replace ( units_path , i , path ) ;
83357: LD_ADDR_VAR 0 16
83361: PUSH
83362: LD_VAR 0 16
83366: PPUSH
83367: LD_VAR 0 7
83371: PPUSH
83372: LD_VAR 0 5
83376: PPUSH
83377: CALL_OW 1
83381: ST_TO_ADDR
83382: GO 83354
83384: POP
83385: POP
// repeat for i = group downto 1 do
83386: LD_ADDR_VAR 0 7
83390: PUSH
83391: DOUBLE
83392: LD_VAR 0 4
83396: INC
83397: ST_TO_ADDR
83398: LD_INT 1
83400: PUSH
83401: FOR_DOWNTO
83402: IFFALSE 87498
// begin wait ( 5 ) ;
83404: LD_INT 5
83406: PPUSH
83407: CALL_OW 67
// tmp := [ ] ;
83411: LD_ADDR_VAR 0 14
83415: PUSH
83416: EMPTY
83417: ST_TO_ADDR
// attacking := false ;
83418: LD_ADDR_VAR 0 29
83422: PUSH
83423: LD_INT 0
83425: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
83426: LD_VAR 0 4
83430: PUSH
83431: LD_VAR 0 7
83435: ARRAY
83436: PPUSH
83437: CALL_OW 301
83441: PUSH
83442: LD_VAR 0 4
83446: PUSH
83447: LD_VAR 0 7
83451: ARRAY
83452: NOT
83453: OR
83454: IFFALSE 83563
// begin if GetType ( group [ i ] ) = unit_human then
83456: LD_VAR 0 4
83460: PUSH
83461: LD_VAR 0 7
83465: ARRAY
83466: PPUSH
83467: CALL_OW 247
83471: PUSH
83472: LD_INT 1
83474: EQUAL
83475: IFFALSE 83521
// begin to_heal := to_heal diff group [ i ] ;
83477: LD_ADDR_VAR 0 30
83481: PUSH
83482: LD_VAR 0 30
83486: PUSH
83487: LD_VAR 0 4
83491: PUSH
83492: LD_VAR 0 7
83496: ARRAY
83497: DIFF
83498: ST_TO_ADDR
// healers := healers diff group [ i ] ;
83499: LD_ADDR_VAR 0 31
83503: PUSH
83504: LD_VAR 0 31
83508: PUSH
83509: LD_VAR 0 4
83513: PUSH
83514: LD_VAR 0 7
83518: ARRAY
83519: DIFF
83520: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
83521: LD_ADDR_VAR 0 4
83525: PUSH
83526: LD_VAR 0 4
83530: PPUSH
83531: LD_VAR 0 7
83535: PPUSH
83536: CALL_OW 3
83540: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
83541: LD_ADDR_VAR 0 16
83545: PUSH
83546: LD_VAR 0 16
83550: PPUSH
83551: LD_VAR 0 7
83555: PPUSH
83556: CALL_OW 3
83560: ST_TO_ADDR
// continue ;
83561: GO 83401
// end ; if f_repair then
83563: LD_VAR 0 22
83567: IFFALSE 84056
// begin if GetType ( group [ i ] ) = unit_vehicle then
83569: LD_VAR 0 4
83573: PUSH
83574: LD_VAR 0 7
83578: ARRAY
83579: PPUSH
83580: CALL_OW 247
83584: PUSH
83585: LD_INT 2
83587: EQUAL
83588: IFFALSE 83778
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
83590: LD_VAR 0 4
83594: PUSH
83595: LD_VAR 0 7
83599: ARRAY
83600: PPUSH
83601: CALL_OW 256
83605: PUSH
83606: LD_INT 700
83608: LESS
83609: PUSH
83610: LD_VAR 0 4
83614: PUSH
83615: LD_VAR 0 7
83619: ARRAY
83620: PUSH
83621: LD_VAR 0 32
83625: IN
83626: NOT
83627: AND
83628: IFFALSE 83652
// to_repair := to_repair union group [ i ] ;
83630: LD_ADDR_VAR 0 32
83634: PUSH
83635: LD_VAR 0 32
83639: PUSH
83640: LD_VAR 0 4
83644: PUSH
83645: LD_VAR 0 7
83649: ARRAY
83650: UNION
83651: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
83652: LD_VAR 0 4
83656: PUSH
83657: LD_VAR 0 7
83661: ARRAY
83662: PPUSH
83663: CALL_OW 256
83667: PUSH
83668: LD_INT 1000
83670: EQUAL
83671: PUSH
83672: LD_VAR 0 4
83676: PUSH
83677: LD_VAR 0 7
83681: ARRAY
83682: PUSH
83683: LD_VAR 0 32
83687: IN
83688: AND
83689: IFFALSE 83713
// to_repair := to_repair diff group [ i ] ;
83691: LD_ADDR_VAR 0 32
83695: PUSH
83696: LD_VAR 0 32
83700: PUSH
83701: LD_VAR 0 4
83705: PUSH
83706: LD_VAR 0 7
83710: ARRAY
83711: DIFF
83712: ST_TO_ADDR
// if group [ i ] in to_repair then
83713: LD_VAR 0 4
83717: PUSH
83718: LD_VAR 0 7
83722: ARRAY
83723: PUSH
83724: LD_VAR 0 32
83728: IN
83729: IFFALSE 83776
// begin if not IsInArea ( group [ i ] , f_repair ) then
83731: LD_VAR 0 4
83735: PUSH
83736: LD_VAR 0 7
83740: ARRAY
83741: PPUSH
83742: LD_VAR 0 22
83746: PPUSH
83747: CALL_OW 308
83751: NOT
83752: IFFALSE 83774
// ComMoveToArea ( group [ i ] , f_repair ) ;
83754: LD_VAR 0 4
83758: PUSH
83759: LD_VAR 0 7
83763: ARRAY
83764: PPUSH
83765: LD_VAR 0 22
83769: PPUSH
83770: CALL_OW 113
// continue ;
83774: GO 83401
// end ; end else
83776: GO 84056
// if group [ i ] in repairs then
83778: LD_VAR 0 4
83782: PUSH
83783: LD_VAR 0 7
83787: ARRAY
83788: PUSH
83789: LD_VAR 0 33
83793: IN
83794: IFFALSE 84056
// begin if IsInUnit ( group [ i ] ) then
83796: LD_VAR 0 4
83800: PUSH
83801: LD_VAR 0 7
83805: ARRAY
83806: PPUSH
83807: CALL_OW 310
83811: IFFALSE 83879
// begin z := IsInUnit ( group [ i ] ) ;
83813: LD_ADDR_VAR 0 13
83817: PUSH
83818: LD_VAR 0 4
83822: PUSH
83823: LD_VAR 0 7
83827: ARRAY
83828: PPUSH
83829: CALL_OW 310
83833: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
83834: LD_VAR 0 13
83838: PUSH
83839: LD_VAR 0 32
83843: IN
83844: PUSH
83845: LD_VAR 0 13
83849: PPUSH
83850: LD_VAR 0 22
83854: PPUSH
83855: CALL_OW 308
83859: AND
83860: IFFALSE 83877
// ComExitVehicle ( group [ i ] ) ;
83862: LD_VAR 0 4
83866: PUSH
83867: LD_VAR 0 7
83871: ARRAY
83872: PPUSH
83873: CALL_OW 121
// end else
83877: GO 84056
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
83879: LD_ADDR_VAR 0 13
83883: PUSH
83884: LD_VAR 0 4
83888: PPUSH
83889: LD_INT 95
83891: PUSH
83892: LD_VAR 0 22
83896: PUSH
83897: EMPTY
83898: LIST
83899: LIST
83900: PUSH
83901: LD_INT 58
83903: PUSH
83904: EMPTY
83905: LIST
83906: PUSH
83907: EMPTY
83908: LIST
83909: LIST
83910: PPUSH
83911: CALL_OW 72
83915: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
83916: LD_VAR 0 4
83920: PUSH
83921: LD_VAR 0 7
83925: ARRAY
83926: PPUSH
83927: CALL_OW 314
83931: NOT
83932: IFFALSE 84054
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
83934: LD_ADDR_VAR 0 10
83938: PUSH
83939: LD_VAR 0 13
83943: PPUSH
83944: LD_VAR 0 4
83948: PUSH
83949: LD_VAR 0 7
83953: ARRAY
83954: PPUSH
83955: CALL_OW 74
83959: ST_TO_ADDR
// if not x then
83960: LD_VAR 0 10
83964: NOT
83965: IFFALSE 83969
// continue ;
83967: GO 83401
// if GetLives ( x ) < 1000 then
83969: LD_VAR 0 10
83973: PPUSH
83974: CALL_OW 256
83978: PUSH
83979: LD_INT 1000
83981: LESS
83982: IFFALSE 84006
// ComRepairVehicle ( group [ i ] , x ) else
83984: LD_VAR 0 4
83988: PUSH
83989: LD_VAR 0 7
83993: ARRAY
83994: PPUSH
83995: LD_VAR 0 10
83999: PPUSH
84000: CALL_OW 129
84004: GO 84054
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
84006: LD_VAR 0 23
84010: PUSH
84011: LD_VAR 0 4
84015: PUSH
84016: LD_VAR 0 7
84020: ARRAY
84021: PPUSH
84022: CALL_OW 256
84026: PUSH
84027: LD_INT 1000
84029: LESS
84030: AND
84031: NOT
84032: IFFALSE 84054
// ComEnterUnit ( group [ i ] , x ) ;
84034: LD_VAR 0 4
84038: PUSH
84039: LD_VAR 0 7
84043: ARRAY
84044: PPUSH
84045: LD_VAR 0 10
84049: PPUSH
84050: CALL_OW 120
// end ; continue ;
84054: GO 83401
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
84056: LD_VAR 0 23
84060: PUSH
84061: LD_VAR 0 4
84065: PUSH
84066: LD_VAR 0 7
84070: ARRAY
84071: PPUSH
84072: CALL_OW 247
84076: PUSH
84077: LD_INT 1
84079: EQUAL
84080: AND
84081: IFFALSE 84559
// begin if group [ i ] in healers then
84083: LD_VAR 0 4
84087: PUSH
84088: LD_VAR 0 7
84092: ARRAY
84093: PUSH
84094: LD_VAR 0 31
84098: IN
84099: IFFALSE 84372
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
84101: LD_VAR 0 4
84105: PUSH
84106: LD_VAR 0 7
84110: ARRAY
84111: PPUSH
84112: LD_VAR 0 23
84116: PPUSH
84117: CALL_OW 308
84121: NOT
84122: PUSH
84123: LD_VAR 0 4
84127: PUSH
84128: LD_VAR 0 7
84132: ARRAY
84133: PPUSH
84134: CALL_OW 314
84138: NOT
84139: AND
84140: IFFALSE 84164
// ComMoveToArea ( group [ i ] , f_heal ) else
84142: LD_VAR 0 4
84146: PUSH
84147: LD_VAR 0 7
84151: ARRAY
84152: PPUSH
84153: LD_VAR 0 23
84157: PPUSH
84158: CALL_OW 113
84162: GO 84370
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
84164: LD_VAR 0 4
84168: PUSH
84169: LD_VAR 0 7
84173: ARRAY
84174: PPUSH
84175: CALL 82782 0 1
84179: PPUSH
84180: CALL_OW 256
84184: PUSH
84185: LD_INT 1000
84187: EQUAL
84188: IFFALSE 84207
// ComStop ( group [ i ] ) else
84190: LD_VAR 0 4
84194: PUSH
84195: LD_VAR 0 7
84199: ARRAY
84200: PPUSH
84201: CALL_OW 141
84205: GO 84370
// if not HasTask ( group [ i ] ) and to_heal then
84207: LD_VAR 0 4
84211: PUSH
84212: LD_VAR 0 7
84216: ARRAY
84217: PPUSH
84218: CALL_OW 314
84222: NOT
84223: PUSH
84224: LD_VAR 0 30
84228: AND
84229: IFFALSE 84370
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
84231: LD_ADDR_VAR 0 13
84235: PUSH
84236: LD_VAR 0 30
84240: PPUSH
84241: LD_INT 3
84243: PUSH
84244: LD_INT 54
84246: PUSH
84247: EMPTY
84248: LIST
84249: PUSH
84250: EMPTY
84251: LIST
84252: LIST
84253: PPUSH
84254: CALL_OW 72
84258: PPUSH
84259: LD_VAR 0 4
84263: PUSH
84264: LD_VAR 0 7
84268: ARRAY
84269: PPUSH
84270: CALL_OW 74
84274: ST_TO_ADDR
// if z then
84275: LD_VAR 0 13
84279: IFFALSE 84370
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
84281: LD_INT 91
84283: PUSH
84284: LD_VAR 0 13
84288: PUSH
84289: LD_INT 10
84291: PUSH
84292: EMPTY
84293: LIST
84294: LIST
84295: LIST
84296: PUSH
84297: LD_INT 81
84299: PUSH
84300: LD_VAR 0 13
84304: PPUSH
84305: CALL_OW 255
84309: PUSH
84310: EMPTY
84311: LIST
84312: LIST
84313: PUSH
84314: EMPTY
84315: LIST
84316: LIST
84317: PPUSH
84318: CALL_OW 69
84322: PUSH
84323: LD_INT 0
84325: EQUAL
84326: IFFALSE 84350
// ComHeal ( group [ i ] , z ) else
84328: LD_VAR 0 4
84332: PUSH
84333: LD_VAR 0 7
84337: ARRAY
84338: PPUSH
84339: LD_VAR 0 13
84343: PPUSH
84344: CALL_OW 128
84348: GO 84370
// ComMoveToArea ( group [ i ] , f_heal ) ;
84350: LD_VAR 0 4
84354: PUSH
84355: LD_VAR 0 7
84359: ARRAY
84360: PPUSH
84361: LD_VAR 0 23
84365: PPUSH
84366: CALL_OW 113
// end ; continue ;
84370: GO 83401
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
84372: LD_VAR 0 4
84376: PUSH
84377: LD_VAR 0 7
84381: ARRAY
84382: PPUSH
84383: CALL_OW 256
84387: PUSH
84388: LD_INT 700
84390: LESS
84391: PUSH
84392: LD_VAR 0 4
84396: PUSH
84397: LD_VAR 0 7
84401: ARRAY
84402: PUSH
84403: LD_VAR 0 30
84407: IN
84408: NOT
84409: AND
84410: IFFALSE 84434
// to_heal := to_heal union group [ i ] ;
84412: LD_ADDR_VAR 0 30
84416: PUSH
84417: LD_VAR 0 30
84421: PUSH
84422: LD_VAR 0 4
84426: PUSH
84427: LD_VAR 0 7
84431: ARRAY
84432: UNION
84433: ST_TO_ADDR
// if group [ i ] in to_heal then
84434: LD_VAR 0 4
84438: PUSH
84439: LD_VAR 0 7
84443: ARRAY
84444: PUSH
84445: LD_VAR 0 30
84449: IN
84450: IFFALSE 84559
// begin if GetLives ( group [ i ] ) = 1000 then
84452: LD_VAR 0 4
84456: PUSH
84457: LD_VAR 0 7
84461: ARRAY
84462: PPUSH
84463: CALL_OW 256
84467: PUSH
84468: LD_INT 1000
84470: EQUAL
84471: IFFALSE 84497
// to_heal := to_heal diff group [ i ] else
84473: LD_ADDR_VAR 0 30
84477: PUSH
84478: LD_VAR 0 30
84482: PUSH
84483: LD_VAR 0 4
84487: PUSH
84488: LD_VAR 0 7
84492: ARRAY
84493: DIFF
84494: ST_TO_ADDR
84495: GO 84559
// begin if not IsInArea ( group [ i ] , to_heal ) then
84497: LD_VAR 0 4
84501: PUSH
84502: LD_VAR 0 7
84506: ARRAY
84507: PPUSH
84508: LD_VAR 0 30
84512: PPUSH
84513: CALL_OW 308
84517: NOT
84518: IFFALSE 84542
// ComMoveToArea ( group [ i ] , f_heal ) else
84520: LD_VAR 0 4
84524: PUSH
84525: LD_VAR 0 7
84529: ARRAY
84530: PPUSH
84531: LD_VAR 0 23
84535: PPUSH
84536: CALL_OW 113
84540: GO 84557
// ComHold ( group [ i ] ) ;
84542: LD_VAR 0 4
84546: PUSH
84547: LD_VAR 0 7
84551: ARRAY
84552: PPUSH
84553: CALL_OW 140
// continue ;
84557: GO 83401
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
84559: LD_VAR 0 4
84563: PUSH
84564: LD_VAR 0 7
84568: ARRAY
84569: PPUSH
84570: LD_INT 10
84572: PPUSH
84573: CALL 81179 0 2
84577: NOT
84578: PUSH
84579: LD_VAR 0 16
84583: PUSH
84584: LD_VAR 0 7
84588: ARRAY
84589: PUSH
84590: EMPTY
84591: EQUAL
84592: NOT
84593: AND
84594: IFFALSE 84860
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
84596: LD_VAR 0 4
84600: PUSH
84601: LD_VAR 0 7
84605: ARRAY
84606: PPUSH
84607: CALL_OW 262
84611: PUSH
84612: LD_INT 1
84614: PUSH
84615: LD_INT 2
84617: PUSH
84618: EMPTY
84619: LIST
84620: LIST
84621: IN
84622: IFFALSE 84663
// if GetFuel ( group [ i ] ) < 10 then
84624: LD_VAR 0 4
84628: PUSH
84629: LD_VAR 0 7
84633: ARRAY
84634: PPUSH
84635: CALL_OW 261
84639: PUSH
84640: LD_INT 10
84642: LESS
84643: IFFALSE 84663
// SetFuel ( group [ i ] , 12 ) ;
84645: LD_VAR 0 4
84649: PUSH
84650: LD_VAR 0 7
84654: ARRAY
84655: PPUSH
84656: LD_INT 12
84658: PPUSH
84659: CALL_OW 240
// if units_path [ i ] then
84663: LD_VAR 0 16
84667: PUSH
84668: LD_VAR 0 7
84672: ARRAY
84673: IFFALSE 84858
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
84675: LD_VAR 0 4
84679: PUSH
84680: LD_VAR 0 7
84684: ARRAY
84685: PPUSH
84686: LD_VAR 0 16
84690: PUSH
84691: LD_VAR 0 7
84695: ARRAY
84696: PUSH
84697: LD_INT 1
84699: ARRAY
84700: PUSH
84701: LD_INT 1
84703: ARRAY
84704: PPUSH
84705: LD_VAR 0 16
84709: PUSH
84710: LD_VAR 0 7
84714: ARRAY
84715: PUSH
84716: LD_INT 1
84718: ARRAY
84719: PUSH
84720: LD_INT 2
84722: ARRAY
84723: PPUSH
84724: CALL_OW 297
84728: PUSH
84729: LD_INT 6
84731: GREATER
84732: IFFALSE 84807
// begin if not HasTask ( group [ i ] ) then
84734: LD_VAR 0 4
84738: PUSH
84739: LD_VAR 0 7
84743: ARRAY
84744: PPUSH
84745: CALL_OW 314
84749: NOT
84750: IFFALSE 84805
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
84752: LD_VAR 0 4
84756: PUSH
84757: LD_VAR 0 7
84761: ARRAY
84762: PPUSH
84763: LD_VAR 0 16
84767: PUSH
84768: LD_VAR 0 7
84772: ARRAY
84773: PUSH
84774: LD_INT 1
84776: ARRAY
84777: PUSH
84778: LD_INT 1
84780: ARRAY
84781: PPUSH
84782: LD_VAR 0 16
84786: PUSH
84787: LD_VAR 0 7
84791: ARRAY
84792: PUSH
84793: LD_INT 1
84795: ARRAY
84796: PUSH
84797: LD_INT 2
84799: ARRAY
84800: PPUSH
84801: CALL_OW 114
// end else
84805: GO 84858
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
84807: LD_ADDR_VAR 0 15
84811: PUSH
84812: LD_VAR 0 16
84816: PUSH
84817: LD_VAR 0 7
84821: ARRAY
84822: PPUSH
84823: LD_INT 1
84825: PPUSH
84826: CALL_OW 3
84830: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
84831: LD_ADDR_VAR 0 16
84835: PUSH
84836: LD_VAR 0 16
84840: PPUSH
84841: LD_VAR 0 7
84845: PPUSH
84846: LD_VAR 0 15
84850: PPUSH
84851: CALL_OW 1
84855: ST_TO_ADDR
// continue ;
84856: GO 83401
// end ; end ; end else
84858: GO 87496
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
84860: LD_ADDR_VAR 0 14
84864: PUSH
84865: LD_INT 81
84867: PUSH
84868: LD_VAR 0 4
84872: PUSH
84873: LD_VAR 0 7
84877: ARRAY
84878: PPUSH
84879: CALL_OW 255
84883: PUSH
84884: EMPTY
84885: LIST
84886: LIST
84887: PPUSH
84888: CALL_OW 69
84892: ST_TO_ADDR
// if not tmp then
84893: LD_VAR 0 14
84897: NOT
84898: IFFALSE 84902
// continue ;
84900: GO 83401
// if f_ignore_area then
84902: LD_VAR 0 17
84906: IFFALSE 84994
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
84908: LD_ADDR_VAR 0 15
84912: PUSH
84913: LD_VAR 0 14
84917: PPUSH
84918: LD_INT 3
84920: PUSH
84921: LD_INT 92
84923: PUSH
84924: LD_VAR 0 17
84928: PUSH
84929: LD_INT 1
84931: ARRAY
84932: PUSH
84933: LD_VAR 0 17
84937: PUSH
84938: LD_INT 2
84940: ARRAY
84941: PUSH
84942: LD_VAR 0 17
84946: PUSH
84947: LD_INT 3
84949: ARRAY
84950: PUSH
84951: EMPTY
84952: LIST
84953: LIST
84954: LIST
84955: LIST
84956: PUSH
84957: EMPTY
84958: LIST
84959: LIST
84960: PPUSH
84961: CALL_OW 72
84965: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
84966: LD_VAR 0 14
84970: PUSH
84971: LD_VAR 0 15
84975: DIFF
84976: IFFALSE 84994
// tmp := tmp diff tmp2 ;
84978: LD_ADDR_VAR 0 14
84982: PUSH
84983: LD_VAR 0 14
84987: PUSH
84988: LD_VAR 0 15
84992: DIFF
84993: ST_TO_ADDR
// end ; if not f_murder then
84994: LD_VAR 0 20
84998: NOT
84999: IFFALSE 85057
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
85001: LD_ADDR_VAR 0 15
85005: PUSH
85006: LD_VAR 0 14
85010: PPUSH
85011: LD_INT 3
85013: PUSH
85014: LD_INT 50
85016: PUSH
85017: EMPTY
85018: LIST
85019: PUSH
85020: EMPTY
85021: LIST
85022: LIST
85023: PPUSH
85024: CALL_OW 72
85028: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
85029: LD_VAR 0 14
85033: PUSH
85034: LD_VAR 0 15
85038: DIFF
85039: IFFALSE 85057
// tmp := tmp diff tmp2 ;
85041: LD_ADDR_VAR 0 14
85045: PUSH
85046: LD_VAR 0 14
85050: PUSH
85051: LD_VAR 0 15
85055: DIFF
85056: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
85057: LD_ADDR_VAR 0 14
85061: PUSH
85062: LD_VAR 0 4
85066: PUSH
85067: LD_VAR 0 7
85071: ARRAY
85072: PPUSH
85073: LD_VAR 0 14
85077: PPUSH
85078: LD_INT 1
85080: PPUSH
85081: LD_INT 1
85083: PPUSH
85084: CALL 54822 0 4
85088: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
85089: LD_VAR 0 4
85093: PUSH
85094: LD_VAR 0 7
85098: ARRAY
85099: PPUSH
85100: CALL_OW 257
85104: PUSH
85105: LD_INT 1
85107: EQUAL
85108: IFFALSE 85556
// begin if WantPlant ( group [ i ] ) then
85110: LD_VAR 0 4
85114: PUSH
85115: LD_VAR 0 7
85119: ARRAY
85120: PPUSH
85121: CALL 54323 0 1
85125: IFFALSE 85129
// continue ;
85127: GO 83401
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
85129: LD_VAR 0 18
85133: PUSH
85134: LD_VAR 0 4
85138: PUSH
85139: LD_VAR 0 7
85143: ARRAY
85144: PPUSH
85145: CALL_OW 310
85149: NOT
85150: AND
85151: PUSH
85152: LD_VAR 0 14
85156: PUSH
85157: LD_INT 1
85159: ARRAY
85160: PUSH
85161: LD_VAR 0 14
85165: PPUSH
85166: LD_INT 21
85168: PUSH
85169: LD_INT 2
85171: PUSH
85172: EMPTY
85173: LIST
85174: LIST
85175: PUSH
85176: LD_INT 58
85178: PUSH
85179: EMPTY
85180: LIST
85181: PUSH
85182: EMPTY
85183: LIST
85184: LIST
85185: PPUSH
85186: CALL_OW 72
85190: IN
85191: AND
85192: IFFALSE 85228
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
85194: LD_VAR 0 4
85198: PUSH
85199: LD_VAR 0 7
85203: ARRAY
85204: PPUSH
85205: LD_VAR 0 14
85209: PUSH
85210: LD_INT 1
85212: ARRAY
85213: PPUSH
85214: CALL_OW 120
// attacking := true ;
85218: LD_ADDR_VAR 0 29
85222: PUSH
85223: LD_INT 1
85225: ST_TO_ADDR
// continue ;
85226: GO 83401
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
85228: LD_VAR 0 26
85232: PUSH
85233: LD_VAR 0 4
85237: PUSH
85238: LD_VAR 0 7
85242: ARRAY
85243: PPUSH
85244: CALL_OW 257
85248: PUSH
85249: LD_INT 1
85251: EQUAL
85252: AND
85253: PUSH
85254: LD_VAR 0 4
85258: PUSH
85259: LD_VAR 0 7
85263: ARRAY
85264: PPUSH
85265: CALL_OW 256
85269: PUSH
85270: LD_INT 800
85272: LESS
85273: AND
85274: PUSH
85275: LD_VAR 0 4
85279: PUSH
85280: LD_VAR 0 7
85284: ARRAY
85285: PPUSH
85286: CALL_OW 318
85290: NOT
85291: AND
85292: IFFALSE 85309
// ComCrawl ( group [ i ] ) ;
85294: LD_VAR 0 4
85298: PUSH
85299: LD_VAR 0 7
85303: ARRAY
85304: PPUSH
85305: CALL_OW 137
// if f_mines then
85309: LD_VAR 0 21
85313: IFFALSE 85556
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
85315: LD_VAR 0 14
85319: PUSH
85320: LD_INT 1
85322: ARRAY
85323: PPUSH
85324: CALL_OW 247
85328: PUSH
85329: LD_INT 3
85331: EQUAL
85332: PUSH
85333: LD_VAR 0 14
85337: PUSH
85338: LD_INT 1
85340: ARRAY
85341: PUSH
85342: LD_VAR 0 27
85346: IN
85347: NOT
85348: AND
85349: IFFALSE 85556
// begin x := GetX ( tmp [ 1 ] ) ;
85351: LD_ADDR_VAR 0 10
85355: PUSH
85356: LD_VAR 0 14
85360: PUSH
85361: LD_INT 1
85363: ARRAY
85364: PPUSH
85365: CALL_OW 250
85369: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
85370: LD_ADDR_VAR 0 11
85374: PUSH
85375: LD_VAR 0 14
85379: PUSH
85380: LD_INT 1
85382: ARRAY
85383: PPUSH
85384: CALL_OW 251
85388: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
85389: LD_ADDR_VAR 0 12
85393: PUSH
85394: LD_VAR 0 4
85398: PUSH
85399: LD_VAR 0 7
85403: ARRAY
85404: PPUSH
85405: CALL 81264 0 1
85409: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
85410: LD_VAR 0 4
85414: PUSH
85415: LD_VAR 0 7
85419: ARRAY
85420: PPUSH
85421: LD_VAR 0 10
85425: PPUSH
85426: LD_VAR 0 11
85430: PPUSH
85431: LD_VAR 0 14
85435: PUSH
85436: LD_INT 1
85438: ARRAY
85439: PPUSH
85440: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
85444: LD_VAR 0 4
85448: PUSH
85449: LD_VAR 0 7
85453: ARRAY
85454: PPUSH
85455: LD_VAR 0 10
85459: PPUSH
85460: LD_VAR 0 12
85464: PPUSH
85465: LD_INT 7
85467: PPUSH
85468: CALL_OW 272
85472: PPUSH
85473: LD_VAR 0 11
85477: PPUSH
85478: LD_VAR 0 12
85482: PPUSH
85483: LD_INT 7
85485: PPUSH
85486: CALL_OW 273
85490: PPUSH
85491: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
85495: LD_VAR 0 4
85499: PUSH
85500: LD_VAR 0 7
85504: ARRAY
85505: PPUSH
85506: LD_INT 71
85508: PPUSH
85509: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
85513: LD_ADDR_VAR 0 27
85517: PUSH
85518: LD_VAR 0 27
85522: PPUSH
85523: LD_VAR 0 27
85527: PUSH
85528: LD_INT 1
85530: PLUS
85531: PPUSH
85532: LD_VAR 0 14
85536: PUSH
85537: LD_INT 1
85539: ARRAY
85540: PPUSH
85541: CALL_OW 1
85545: ST_TO_ADDR
// attacking := true ;
85546: LD_ADDR_VAR 0 29
85550: PUSH
85551: LD_INT 1
85553: ST_TO_ADDR
// continue ;
85554: GO 83401
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
85556: LD_VAR 0 4
85560: PUSH
85561: LD_VAR 0 7
85565: ARRAY
85566: PPUSH
85567: CALL_OW 257
85571: PUSH
85572: LD_INT 17
85574: EQUAL
85575: PUSH
85576: LD_VAR 0 4
85580: PUSH
85581: LD_VAR 0 7
85585: ARRAY
85586: PPUSH
85587: CALL_OW 110
85591: PUSH
85592: LD_INT 71
85594: EQUAL
85595: NOT
85596: AND
85597: IFFALSE 85743
// begin attacking := false ;
85599: LD_ADDR_VAR 0 29
85603: PUSH
85604: LD_INT 0
85606: ST_TO_ADDR
// k := 5 ;
85607: LD_ADDR_VAR 0 9
85611: PUSH
85612: LD_INT 5
85614: ST_TO_ADDR
// if tmp < k then
85615: LD_VAR 0 14
85619: PUSH
85620: LD_VAR 0 9
85624: LESS
85625: IFFALSE 85637
// k := tmp ;
85627: LD_ADDR_VAR 0 9
85631: PUSH
85632: LD_VAR 0 14
85636: ST_TO_ADDR
// for j = 1 to k do
85637: LD_ADDR_VAR 0 8
85641: PUSH
85642: DOUBLE
85643: LD_INT 1
85645: DEC
85646: ST_TO_ADDR
85647: LD_VAR 0 9
85651: PUSH
85652: FOR_TO
85653: IFFALSE 85741
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
85655: LD_VAR 0 14
85659: PUSH
85660: LD_VAR 0 8
85664: ARRAY
85665: PUSH
85666: LD_VAR 0 14
85670: PPUSH
85671: LD_INT 58
85673: PUSH
85674: EMPTY
85675: LIST
85676: PPUSH
85677: CALL_OW 72
85681: IN
85682: NOT
85683: IFFALSE 85739
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
85685: LD_VAR 0 4
85689: PUSH
85690: LD_VAR 0 7
85694: ARRAY
85695: PPUSH
85696: LD_VAR 0 14
85700: PUSH
85701: LD_VAR 0 8
85705: ARRAY
85706: PPUSH
85707: CALL_OW 115
// attacking := true ;
85711: LD_ADDR_VAR 0 29
85715: PUSH
85716: LD_INT 1
85718: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
85719: LD_VAR 0 4
85723: PUSH
85724: LD_VAR 0 7
85728: ARRAY
85729: PPUSH
85730: LD_INT 71
85732: PPUSH
85733: CALL_OW 109
// continue ;
85737: GO 85652
// end ; end ;
85739: GO 85652
85741: POP
85742: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
85743: LD_VAR 0 4
85747: PUSH
85748: LD_VAR 0 7
85752: ARRAY
85753: PPUSH
85754: CALL_OW 257
85758: PUSH
85759: LD_INT 8
85761: EQUAL
85762: PUSH
85763: LD_VAR 0 4
85767: PUSH
85768: LD_VAR 0 7
85772: ARRAY
85773: PPUSH
85774: CALL_OW 264
85778: PUSH
85779: LD_INT 28
85781: PUSH
85782: LD_INT 45
85784: PUSH
85785: LD_INT 7
85787: PUSH
85788: LD_INT 47
85790: PUSH
85791: EMPTY
85792: LIST
85793: LIST
85794: LIST
85795: LIST
85796: IN
85797: OR
85798: IFFALSE 86028
// begin attacking := false ;
85800: LD_ADDR_VAR 0 29
85804: PUSH
85805: LD_INT 0
85807: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
85808: LD_VAR 0 14
85812: PUSH
85813: LD_INT 1
85815: ARRAY
85816: PPUSH
85817: CALL_OW 266
85821: PUSH
85822: LD_INT 32
85824: PUSH
85825: LD_INT 31
85827: PUSH
85828: LD_INT 33
85830: PUSH
85831: LD_INT 4
85833: PUSH
85834: LD_INT 5
85836: PUSH
85837: EMPTY
85838: LIST
85839: LIST
85840: LIST
85841: LIST
85842: LIST
85843: IN
85844: IFFALSE 86028
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
85846: LD_ADDR_VAR 0 9
85850: PUSH
85851: LD_VAR 0 14
85855: PUSH
85856: LD_INT 1
85858: ARRAY
85859: PPUSH
85860: CALL_OW 266
85864: PPUSH
85865: LD_VAR 0 14
85869: PUSH
85870: LD_INT 1
85872: ARRAY
85873: PPUSH
85874: CALL_OW 250
85878: PPUSH
85879: LD_VAR 0 14
85883: PUSH
85884: LD_INT 1
85886: ARRAY
85887: PPUSH
85888: CALL_OW 251
85892: PPUSH
85893: LD_VAR 0 14
85897: PUSH
85898: LD_INT 1
85900: ARRAY
85901: PPUSH
85902: CALL_OW 254
85906: PPUSH
85907: LD_VAR 0 14
85911: PUSH
85912: LD_INT 1
85914: ARRAY
85915: PPUSH
85916: CALL_OW 248
85920: PPUSH
85921: LD_INT 0
85923: PPUSH
85924: CALL 62634 0 6
85928: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
85929: LD_ADDR_VAR 0 8
85933: PUSH
85934: LD_VAR 0 4
85938: PUSH
85939: LD_VAR 0 7
85943: ARRAY
85944: PPUSH
85945: LD_VAR 0 9
85949: PPUSH
85950: CALL 81327 0 2
85954: ST_TO_ADDR
// if j then
85955: LD_VAR 0 8
85959: IFFALSE 86028
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
85961: LD_VAR 0 8
85965: PUSH
85966: LD_INT 1
85968: ARRAY
85969: PPUSH
85970: LD_VAR 0 8
85974: PUSH
85975: LD_INT 2
85977: ARRAY
85978: PPUSH
85979: CALL_OW 488
85983: IFFALSE 86028
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
85985: LD_VAR 0 4
85989: PUSH
85990: LD_VAR 0 7
85994: ARRAY
85995: PPUSH
85996: LD_VAR 0 8
86000: PUSH
86001: LD_INT 1
86003: ARRAY
86004: PPUSH
86005: LD_VAR 0 8
86009: PUSH
86010: LD_INT 2
86012: ARRAY
86013: PPUSH
86014: CALL_OW 116
// attacking := true ;
86018: LD_ADDR_VAR 0 29
86022: PUSH
86023: LD_INT 1
86025: ST_TO_ADDR
// continue ;
86026: GO 83401
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
86028: LD_VAR 0 4
86032: PUSH
86033: LD_VAR 0 7
86037: ARRAY
86038: PPUSH
86039: CALL_OW 265
86043: PUSH
86044: LD_INT 11
86046: EQUAL
86047: IFFALSE 86325
// begin k := 10 ;
86049: LD_ADDR_VAR 0 9
86053: PUSH
86054: LD_INT 10
86056: ST_TO_ADDR
// x := 0 ;
86057: LD_ADDR_VAR 0 10
86061: PUSH
86062: LD_INT 0
86064: ST_TO_ADDR
// if tmp < k then
86065: LD_VAR 0 14
86069: PUSH
86070: LD_VAR 0 9
86074: LESS
86075: IFFALSE 86087
// k := tmp ;
86077: LD_ADDR_VAR 0 9
86081: PUSH
86082: LD_VAR 0 14
86086: ST_TO_ADDR
// for j = k downto 1 do
86087: LD_ADDR_VAR 0 8
86091: PUSH
86092: DOUBLE
86093: LD_VAR 0 9
86097: INC
86098: ST_TO_ADDR
86099: LD_INT 1
86101: PUSH
86102: FOR_DOWNTO
86103: IFFALSE 86178
// begin if GetType ( tmp [ j ] ) = unit_human then
86105: LD_VAR 0 14
86109: PUSH
86110: LD_VAR 0 8
86114: ARRAY
86115: PPUSH
86116: CALL_OW 247
86120: PUSH
86121: LD_INT 1
86123: EQUAL
86124: IFFALSE 86176
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
86126: LD_VAR 0 4
86130: PUSH
86131: LD_VAR 0 7
86135: ARRAY
86136: PPUSH
86137: LD_VAR 0 14
86141: PUSH
86142: LD_VAR 0 8
86146: ARRAY
86147: PPUSH
86148: CALL 81598 0 2
// x := tmp [ j ] ;
86152: LD_ADDR_VAR 0 10
86156: PUSH
86157: LD_VAR 0 14
86161: PUSH
86162: LD_VAR 0 8
86166: ARRAY
86167: ST_TO_ADDR
// attacking := true ;
86168: LD_ADDR_VAR 0 29
86172: PUSH
86173: LD_INT 1
86175: ST_TO_ADDR
// end ; end ;
86176: GO 86102
86178: POP
86179: POP
// if not x then
86180: LD_VAR 0 10
86184: NOT
86185: IFFALSE 86325
// begin attacking := true ;
86187: LD_ADDR_VAR 0 29
86191: PUSH
86192: LD_INT 1
86194: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
86195: LD_VAR 0 4
86199: PUSH
86200: LD_VAR 0 7
86204: ARRAY
86205: PPUSH
86206: CALL_OW 250
86210: PPUSH
86211: LD_VAR 0 4
86215: PUSH
86216: LD_VAR 0 7
86220: ARRAY
86221: PPUSH
86222: CALL_OW 251
86226: PPUSH
86227: CALL_OW 546
86231: PUSH
86232: LD_INT 2
86234: ARRAY
86235: PUSH
86236: LD_VAR 0 14
86240: PUSH
86241: LD_INT 1
86243: ARRAY
86244: PPUSH
86245: CALL_OW 250
86249: PPUSH
86250: LD_VAR 0 14
86254: PUSH
86255: LD_INT 1
86257: ARRAY
86258: PPUSH
86259: CALL_OW 251
86263: PPUSH
86264: CALL_OW 546
86268: PUSH
86269: LD_INT 2
86271: ARRAY
86272: EQUAL
86273: IFFALSE 86301
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
86275: LD_VAR 0 4
86279: PUSH
86280: LD_VAR 0 7
86284: ARRAY
86285: PPUSH
86286: LD_VAR 0 14
86290: PUSH
86291: LD_INT 1
86293: ARRAY
86294: PPUSH
86295: CALL 81598 0 2
86299: GO 86325
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
86301: LD_VAR 0 4
86305: PUSH
86306: LD_VAR 0 7
86310: ARRAY
86311: PPUSH
86312: LD_VAR 0 14
86316: PUSH
86317: LD_INT 1
86319: ARRAY
86320: PPUSH
86321: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
86325: LD_VAR 0 4
86329: PUSH
86330: LD_VAR 0 7
86334: ARRAY
86335: PPUSH
86336: CALL_OW 264
86340: PUSH
86341: LD_INT 29
86343: EQUAL
86344: IFFALSE 86710
// begin if WantsToAttack ( group [ i ] ) in bombed then
86346: LD_VAR 0 4
86350: PUSH
86351: LD_VAR 0 7
86355: ARRAY
86356: PPUSH
86357: CALL_OW 319
86361: PUSH
86362: LD_VAR 0 28
86366: IN
86367: IFFALSE 86371
// continue ;
86369: GO 83401
// k := 8 ;
86371: LD_ADDR_VAR 0 9
86375: PUSH
86376: LD_INT 8
86378: ST_TO_ADDR
// x := 0 ;
86379: LD_ADDR_VAR 0 10
86383: PUSH
86384: LD_INT 0
86386: ST_TO_ADDR
// if tmp < k then
86387: LD_VAR 0 14
86391: PUSH
86392: LD_VAR 0 9
86396: LESS
86397: IFFALSE 86409
// k := tmp ;
86399: LD_ADDR_VAR 0 9
86403: PUSH
86404: LD_VAR 0 14
86408: ST_TO_ADDR
// for j = 1 to k do
86409: LD_ADDR_VAR 0 8
86413: PUSH
86414: DOUBLE
86415: LD_INT 1
86417: DEC
86418: ST_TO_ADDR
86419: LD_VAR 0 9
86423: PUSH
86424: FOR_TO
86425: IFFALSE 86557
// begin if GetType ( tmp [ j ] ) = unit_building then
86427: LD_VAR 0 14
86431: PUSH
86432: LD_VAR 0 8
86436: ARRAY
86437: PPUSH
86438: CALL_OW 247
86442: PUSH
86443: LD_INT 3
86445: EQUAL
86446: IFFALSE 86555
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
86448: LD_VAR 0 14
86452: PUSH
86453: LD_VAR 0 8
86457: ARRAY
86458: PUSH
86459: LD_VAR 0 28
86463: IN
86464: NOT
86465: PUSH
86466: LD_VAR 0 14
86470: PUSH
86471: LD_VAR 0 8
86475: ARRAY
86476: PPUSH
86477: CALL_OW 313
86481: AND
86482: IFFALSE 86555
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
86484: LD_VAR 0 4
86488: PUSH
86489: LD_VAR 0 7
86493: ARRAY
86494: PPUSH
86495: LD_VAR 0 14
86499: PUSH
86500: LD_VAR 0 8
86504: ARRAY
86505: PPUSH
86506: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
86510: LD_ADDR_VAR 0 28
86514: PUSH
86515: LD_VAR 0 28
86519: PPUSH
86520: LD_VAR 0 28
86524: PUSH
86525: LD_INT 1
86527: PLUS
86528: PPUSH
86529: LD_VAR 0 14
86533: PUSH
86534: LD_VAR 0 8
86538: ARRAY
86539: PPUSH
86540: CALL_OW 1
86544: ST_TO_ADDR
// attacking := true ;
86545: LD_ADDR_VAR 0 29
86549: PUSH
86550: LD_INT 1
86552: ST_TO_ADDR
// break ;
86553: GO 86557
// end ; end ;
86555: GO 86424
86557: POP
86558: POP
// if not attacking and f_attack_depot then
86559: LD_VAR 0 29
86563: NOT
86564: PUSH
86565: LD_VAR 0 25
86569: AND
86570: IFFALSE 86665
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
86572: LD_ADDR_VAR 0 13
86576: PUSH
86577: LD_VAR 0 14
86581: PPUSH
86582: LD_INT 2
86584: PUSH
86585: LD_INT 30
86587: PUSH
86588: LD_INT 0
86590: PUSH
86591: EMPTY
86592: LIST
86593: LIST
86594: PUSH
86595: LD_INT 30
86597: PUSH
86598: LD_INT 1
86600: PUSH
86601: EMPTY
86602: LIST
86603: LIST
86604: PUSH
86605: EMPTY
86606: LIST
86607: LIST
86608: LIST
86609: PPUSH
86610: CALL_OW 72
86614: ST_TO_ADDR
// if z then
86615: LD_VAR 0 13
86619: IFFALSE 86665
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
86621: LD_VAR 0 4
86625: PUSH
86626: LD_VAR 0 7
86630: ARRAY
86631: PPUSH
86632: LD_VAR 0 13
86636: PPUSH
86637: LD_VAR 0 4
86641: PUSH
86642: LD_VAR 0 7
86646: ARRAY
86647: PPUSH
86648: CALL_OW 74
86652: PPUSH
86653: CALL_OW 115
// attacking := true ;
86657: LD_ADDR_VAR 0 29
86661: PUSH
86662: LD_INT 1
86664: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
86665: LD_VAR 0 4
86669: PUSH
86670: LD_VAR 0 7
86674: ARRAY
86675: PPUSH
86676: CALL_OW 256
86680: PUSH
86681: LD_INT 500
86683: LESS
86684: IFFALSE 86710
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
86686: LD_VAR 0 4
86690: PUSH
86691: LD_VAR 0 7
86695: ARRAY
86696: PPUSH
86697: LD_VAR 0 14
86701: PUSH
86702: LD_INT 1
86704: ARRAY
86705: PPUSH
86706: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
86710: LD_VAR 0 4
86714: PUSH
86715: LD_VAR 0 7
86719: ARRAY
86720: PPUSH
86721: CALL_OW 264
86725: PUSH
86726: LD_INT 49
86728: EQUAL
86729: IFFALSE 86850
// begin if not HasTask ( group [ i ] ) then
86731: LD_VAR 0 4
86735: PUSH
86736: LD_VAR 0 7
86740: ARRAY
86741: PPUSH
86742: CALL_OW 314
86746: NOT
86747: IFFALSE 86850
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
86749: LD_ADDR_VAR 0 9
86753: PUSH
86754: LD_INT 81
86756: PUSH
86757: LD_VAR 0 4
86761: PUSH
86762: LD_VAR 0 7
86766: ARRAY
86767: PPUSH
86768: CALL_OW 255
86772: PUSH
86773: EMPTY
86774: LIST
86775: LIST
86776: PPUSH
86777: CALL_OW 69
86781: PPUSH
86782: LD_VAR 0 4
86786: PUSH
86787: LD_VAR 0 7
86791: ARRAY
86792: PPUSH
86793: CALL_OW 74
86797: ST_TO_ADDR
// if k then
86798: LD_VAR 0 9
86802: IFFALSE 86850
// if GetDistUnits ( group [ i ] , k ) > 10 then
86804: LD_VAR 0 4
86808: PUSH
86809: LD_VAR 0 7
86813: ARRAY
86814: PPUSH
86815: LD_VAR 0 9
86819: PPUSH
86820: CALL_OW 296
86824: PUSH
86825: LD_INT 10
86827: GREATER
86828: IFFALSE 86850
// ComMoveUnit ( group [ i ] , k ) ;
86830: LD_VAR 0 4
86834: PUSH
86835: LD_VAR 0 7
86839: ARRAY
86840: PPUSH
86841: LD_VAR 0 9
86845: PPUSH
86846: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
86850: LD_VAR 0 4
86854: PUSH
86855: LD_VAR 0 7
86859: ARRAY
86860: PPUSH
86861: CALL_OW 256
86865: PUSH
86866: LD_INT 250
86868: LESS
86869: PUSH
86870: LD_VAR 0 4
86874: PUSH
86875: LD_VAR 0 7
86879: ARRAY
86880: PUSH
86881: LD_INT 21
86883: PUSH
86884: LD_INT 2
86886: PUSH
86887: EMPTY
86888: LIST
86889: LIST
86890: PUSH
86891: LD_INT 23
86893: PUSH
86894: LD_INT 2
86896: PUSH
86897: EMPTY
86898: LIST
86899: LIST
86900: PUSH
86901: EMPTY
86902: LIST
86903: LIST
86904: PPUSH
86905: CALL_OW 69
86909: IN
86910: AND
86911: IFFALSE 87036
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
86913: LD_ADDR_VAR 0 9
86917: PUSH
86918: LD_OWVAR 3
86922: PUSH
86923: LD_VAR 0 4
86927: PUSH
86928: LD_VAR 0 7
86932: ARRAY
86933: DIFF
86934: PPUSH
86935: LD_VAR 0 4
86939: PUSH
86940: LD_VAR 0 7
86944: ARRAY
86945: PPUSH
86946: CALL_OW 74
86950: ST_TO_ADDR
// if not k then
86951: LD_VAR 0 9
86955: NOT
86956: IFFALSE 86960
// continue ;
86958: GO 83401
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
86960: LD_VAR 0 9
86964: PUSH
86965: LD_INT 81
86967: PUSH
86968: LD_VAR 0 4
86972: PUSH
86973: LD_VAR 0 7
86977: ARRAY
86978: PPUSH
86979: CALL_OW 255
86983: PUSH
86984: EMPTY
86985: LIST
86986: LIST
86987: PPUSH
86988: CALL_OW 69
86992: IN
86993: PUSH
86994: LD_VAR 0 9
86998: PPUSH
86999: LD_VAR 0 4
87003: PUSH
87004: LD_VAR 0 7
87008: ARRAY
87009: PPUSH
87010: CALL_OW 296
87014: PUSH
87015: LD_INT 5
87017: LESS
87018: AND
87019: IFFALSE 87036
// ComAutodestruct ( group [ i ] ) ;
87021: LD_VAR 0 4
87025: PUSH
87026: LD_VAR 0 7
87030: ARRAY
87031: PPUSH
87032: CALL 81496 0 1
// end ; if f_attack_depot then
87036: LD_VAR 0 25
87040: IFFALSE 87152
// begin k := 6 ;
87042: LD_ADDR_VAR 0 9
87046: PUSH
87047: LD_INT 6
87049: ST_TO_ADDR
// if tmp < k then
87050: LD_VAR 0 14
87054: PUSH
87055: LD_VAR 0 9
87059: LESS
87060: IFFALSE 87072
// k := tmp ;
87062: LD_ADDR_VAR 0 9
87066: PUSH
87067: LD_VAR 0 14
87071: ST_TO_ADDR
// for j = 1 to k do
87072: LD_ADDR_VAR 0 8
87076: PUSH
87077: DOUBLE
87078: LD_INT 1
87080: DEC
87081: ST_TO_ADDR
87082: LD_VAR 0 9
87086: PUSH
87087: FOR_TO
87088: IFFALSE 87150
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
87090: LD_VAR 0 8
87094: PPUSH
87095: CALL_OW 266
87099: PUSH
87100: LD_INT 0
87102: PUSH
87103: LD_INT 1
87105: PUSH
87106: EMPTY
87107: LIST
87108: LIST
87109: IN
87110: IFFALSE 87148
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
87112: LD_VAR 0 4
87116: PUSH
87117: LD_VAR 0 7
87121: ARRAY
87122: PPUSH
87123: LD_VAR 0 14
87127: PUSH
87128: LD_VAR 0 8
87132: ARRAY
87133: PPUSH
87134: CALL_OW 115
// attacking := true ;
87138: LD_ADDR_VAR 0 29
87142: PUSH
87143: LD_INT 1
87145: ST_TO_ADDR
// break ;
87146: GO 87150
// end ;
87148: GO 87087
87150: POP
87151: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
87152: LD_VAR 0 4
87156: PUSH
87157: LD_VAR 0 7
87161: ARRAY
87162: PPUSH
87163: CALL_OW 302
87167: PUSH
87168: LD_VAR 0 29
87172: NOT
87173: AND
87174: IFFALSE 87496
// begin if GetTag ( group [ i ] ) = 71 then
87176: LD_VAR 0 4
87180: PUSH
87181: LD_VAR 0 7
87185: ARRAY
87186: PPUSH
87187: CALL_OW 110
87191: PUSH
87192: LD_INT 71
87194: EQUAL
87195: IFFALSE 87236
// begin if HasTask ( group [ i ] ) then
87197: LD_VAR 0 4
87201: PUSH
87202: LD_VAR 0 7
87206: ARRAY
87207: PPUSH
87208: CALL_OW 314
87212: IFFALSE 87218
// continue else
87214: GO 83401
87216: GO 87236
// SetTag ( group [ i ] , 0 ) ;
87218: LD_VAR 0 4
87222: PUSH
87223: LD_VAR 0 7
87227: ARRAY
87228: PPUSH
87229: LD_INT 0
87231: PPUSH
87232: CALL_OW 109
// end ; k := 8 ;
87236: LD_ADDR_VAR 0 9
87240: PUSH
87241: LD_INT 8
87243: ST_TO_ADDR
// x := 0 ;
87244: LD_ADDR_VAR 0 10
87248: PUSH
87249: LD_INT 0
87251: ST_TO_ADDR
// if tmp < k then
87252: LD_VAR 0 14
87256: PUSH
87257: LD_VAR 0 9
87261: LESS
87262: IFFALSE 87274
// k := tmp ;
87264: LD_ADDR_VAR 0 9
87268: PUSH
87269: LD_VAR 0 14
87273: ST_TO_ADDR
// for j = 1 to k do
87274: LD_ADDR_VAR 0 8
87278: PUSH
87279: DOUBLE
87280: LD_INT 1
87282: DEC
87283: ST_TO_ADDR
87284: LD_VAR 0 9
87288: PUSH
87289: FOR_TO
87290: IFFALSE 87388
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
87292: LD_VAR 0 14
87296: PUSH
87297: LD_VAR 0 8
87301: ARRAY
87302: PPUSH
87303: CALL_OW 247
87307: PUSH
87308: LD_INT 1
87310: EQUAL
87311: PUSH
87312: LD_VAR 0 14
87316: PUSH
87317: LD_VAR 0 8
87321: ARRAY
87322: PPUSH
87323: CALL_OW 256
87327: PUSH
87328: LD_INT 250
87330: LESS
87331: PUSH
87332: LD_VAR 0 20
87336: AND
87337: PUSH
87338: LD_VAR 0 20
87342: NOT
87343: PUSH
87344: LD_VAR 0 14
87348: PUSH
87349: LD_VAR 0 8
87353: ARRAY
87354: PPUSH
87355: CALL_OW 256
87359: PUSH
87360: LD_INT 250
87362: GREATEREQUAL
87363: AND
87364: OR
87365: AND
87366: IFFALSE 87386
// begin x := tmp [ j ] ;
87368: LD_ADDR_VAR 0 10
87372: PUSH
87373: LD_VAR 0 14
87377: PUSH
87378: LD_VAR 0 8
87382: ARRAY
87383: ST_TO_ADDR
// break ;
87384: GO 87388
// end ;
87386: GO 87289
87388: POP
87389: POP
// if x then
87390: LD_VAR 0 10
87394: IFFALSE 87418
// ComAttackUnit ( group [ i ] , x ) else
87396: LD_VAR 0 4
87400: PUSH
87401: LD_VAR 0 7
87405: ARRAY
87406: PPUSH
87407: LD_VAR 0 10
87411: PPUSH
87412: CALL_OW 115
87416: GO 87442
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
87418: LD_VAR 0 4
87422: PUSH
87423: LD_VAR 0 7
87427: ARRAY
87428: PPUSH
87429: LD_VAR 0 14
87433: PUSH
87434: LD_INT 1
87436: ARRAY
87437: PPUSH
87438: CALL_OW 115
// if not HasTask ( group [ i ] ) then
87442: LD_VAR 0 4
87446: PUSH
87447: LD_VAR 0 7
87451: ARRAY
87452: PPUSH
87453: CALL_OW 314
87457: NOT
87458: IFFALSE 87496
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
87460: LD_VAR 0 4
87464: PUSH
87465: LD_VAR 0 7
87469: ARRAY
87470: PPUSH
87471: LD_VAR 0 14
87475: PPUSH
87476: LD_VAR 0 4
87480: PUSH
87481: LD_VAR 0 7
87485: ARRAY
87486: PPUSH
87487: CALL_OW 74
87491: PPUSH
87492: CALL_OW 115
// end ; end ; end ;
87496: GO 83401
87498: POP
87499: POP
// wait ( 0 0$1 ) ;
87500: LD_INT 35
87502: PPUSH
87503: CALL_OW 67
// until group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
87507: LD_VAR 0 4
87511: PUSH
87512: EMPTY
87513: EQUAL
87514: PUSH
87515: LD_INT 81
87517: PUSH
87518: LD_VAR 0 35
87522: PUSH
87523: EMPTY
87524: LIST
87525: LIST
87526: PPUSH
87527: CALL_OW 69
87531: NOT
87532: OR
87533: IFFALSE 83386
// end ;
87535: LD_VAR 0 2
87539: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
87540: LD_INT 0
87542: PPUSH
87543: PPUSH
87544: PPUSH
87545: PPUSH
// if not base_units then
87546: LD_VAR 0 1
87550: NOT
87551: IFFALSE 87555
// exit ;
87553: GO 87642
// result := false ;
87555: LD_ADDR_VAR 0 2
87559: PUSH
87560: LD_INT 0
87562: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
87563: LD_ADDR_VAR 0 5
87567: PUSH
87568: LD_VAR 0 1
87572: PPUSH
87573: LD_INT 21
87575: PUSH
87576: LD_INT 3
87578: PUSH
87579: EMPTY
87580: LIST
87581: LIST
87582: PPUSH
87583: CALL_OW 72
87587: ST_TO_ADDR
// if not tmp then
87588: LD_VAR 0 5
87592: NOT
87593: IFFALSE 87597
// exit ;
87595: GO 87642
// for i in tmp do
87597: LD_ADDR_VAR 0 3
87601: PUSH
87602: LD_VAR 0 5
87606: PUSH
87607: FOR_IN
87608: IFFALSE 87640
// begin result := EnemyInRange ( i , 22 ) ;
87610: LD_ADDR_VAR 0 2
87614: PUSH
87615: LD_VAR 0 3
87619: PPUSH
87620: LD_INT 22
87622: PPUSH
87623: CALL 81179 0 2
87627: ST_TO_ADDR
// if result then
87628: LD_VAR 0 2
87632: IFFALSE 87638
// exit ;
87634: POP
87635: POP
87636: GO 87642
// end ;
87638: GO 87607
87640: POP
87641: POP
// end ;
87642: LD_VAR 0 2
87646: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
87647: LD_INT 0
87649: PPUSH
87650: PPUSH
// if not units then
87651: LD_VAR 0 1
87655: NOT
87656: IFFALSE 87660
// exit ;
87658: GO 87730
// result := [ ] ;
87660: LD_ADDR_VAR 0 3
87664: PUSH
87665: EMPTY
87666: ST_TO_ADDR
// for i in units do
87667: LD_ADDR_VAR 0 4
87671: PUSH
87672: LD_VAR 0 1
87676: PUSH
87677: FOR_IN
87678: IFFALSE 87728
// if GetTag ( i ) = tag then
87680: LD_VAR 0 4
87684: PPUSH
87685: CALL_OW 110
87689: PUSH
87690: LD_VAR 0 2
87694: EQUAL
87695: IFFALSE 87726
// result := Insert ( result , result + 1 , i ) ;
87697: LD_ADDR_VAR 0 3
87701: PUSH
87702: LD_VAR 0 3
87706: PPUSH
87707: LD_VAR 0 3
87711: PUSH
87712: LD_INT 1
87714: PLUS
87715: PPUSH
87716: LD_VAR 0 4
87720: PPUSH
87721: CALL_OW 2
87725: ST_TO_ADDR
87726: GO 87677
87728: POP
87729: POP
// end ;
87730: LD_VAR 0 3
87734: RET
// export function IsDriver ( un ) ; begin
87735: LD_INT 0
87737: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
87738: LD_ADDR_VAR 0 2
87742: PUSH
87743: LD_VAR 0 1
87747: PUSH
87748: LD_INT 55
87750: PUSH
87751: EMPTY
87752: LIST
87753: PPUSH
87754: CALL_OW 69
87758: IN
87759: ST_TO_ADDR
// end ;
87760: LD_VAR 0 2
87764: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
87765: LD_INT 0
87767: PPUSH
87768: PPUSH
// list := [ ] ;
87769: LD_ADDR_VAR 0 5
87773: PUSH
87774: EMPTY
87775: ST_TO_ADDR
// case d of 0 :
87776: LD_VAR 0 3
87780: PUSH
87781: LD_INT 0
87783: DOUBLE
87784: EQUAL
87785: IFTRUE 87789
87787: GO 87922
87789: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
87790: LD_ADDR_VAR 0 5
87794: PUSH
87795: LD_VAR 0 1
87799: PUSH
87800: LD_INT 4
87802: MINUS
87803: PUSH
87804: LD_VAR 0 2
87808: PUSH
87809: LD_INT 4
87811: MINUS
87812: PUSH
87813: LD_INT 2
87815: PUSH
87816: EMPTY
87817: LIST
87818: LIST
87819: LIST
87820: PUSH
87821: LD_VAR 0 1
87825: PUSH
87826: LD_INT 3
87828: MINUS
87829: PUSH
87830: LD_VAR 0 2
87834: PUSH
87835: LD_INT 1
87837: PUSH
87838: EMPTY
87839: LIST
87840: LIST
87841: LIST
87842: PUSH
87843: LD_VAR 0 1
87847: PUSH
87848: LD_INT 4
87850: PLUS
87851: PUSH
87852: LD_VAR 0 2
87856: PUSH
87857: LD_INT 4
87859: PUSH
87860: EMPTY
87861: LIST
87862: LIST
87863: LIST
87864: PUSH
87865: LD_VAR 0 1
87869: PUSH
87870: LD_INT 3
87872: PLUS
87873: PUSH
87874: LD_VAR 0 2
87878: PUSH
87879: LD_INT 3
87881: PLUS
87882: PUSH
87883: LD_INT 5
87885: PUSH
87886: EMPTY
87887: LIST
87888: LIST
87889: LIST
87890: PUSH
87891: LD_VAR 0 1
87895: PUSH
87896: LD_VAR 0 2
87900: PUSH
87901: LD_INT 4
87903: PLUS
87904: PUSH
87905: LD_INT 0
87907: PUSH
87908: EMPTY
87909: LIST
87910: LIST
87911: LIST
87912: PUSH
87913: EMPTY
87914: LIST
87915: LIST
87916: LIST
87917: LIST
87918: LIST
87919: ST_TO_ADDR
// end ; 1 :
87920: GO 88620
87922: LD_INT 1
87924: DOUBLE
87925: EQUAL
87926: IFTRUE 87930
87928: GO 88063
87930: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
87931: LD_ADDR_VAR 0 5
87935: PUSH
87936: LD_VAR 0 1
87940: PUSH
87941: LD_VAR 0 2
87945: PUSH
87946: LD_INT 4
87948: MINUS
87949: PUSH
87950: LD_INT 3
87952: PUSH
87953: EMPTY
87954: LIST
87955: LIST
87956: LIST
87957: PUSH
87958: LD_VAR 0 1
87962: PUSH
87963: LD_INT 3
87965: MINUS
87966: PUSH
87967: LD_VAR 0 2
87971: PUSH
87972: LD_INT 3
87974: MINUS
87975: PUSH
87976: LD_INT 2
87978: PUSH
87979: EMPTY
87980: LIST
87981: LIST
87982: LIST
87983: PUSH
87984: LD_VAR 0 1
87988: PUSH
87989: LD_INT 4
87991: MINUS
87992: PUSH
87993: LD_VAR 0 2
87997: PUSH
87998: LD_INT 1
88000: PUSH
88001: EMPTY
88002: LIST
88003: LIST
88004: LIST
88005: PUSH
88006: LD_VAR 0 1
88010: PUSH
88011: LD_VAR 0 2
88015: PUSH
88016: LD_INT 3
88018: PLUS
88019: PUSH
88020: LD_INT 0
88022: PUSH
88023: EMPTY
88024: LIST
88025: LIST
88026: LIST
88027: PUSH
88028: LD_VAR 0 1
88032: PUSH
88033: LD_INT 4
88035: PLUS
88036: PUSH
88037: LD_VAR 0 2
88041: PUSH
88042: LD_INT 4
88044: PLUS
88045: PUSH
88046: LD_INT 5
88048: PUSH
88049: EMPTY
88050: LIST
88051: LIST
88052: LIST
88053: PUSH
88054: EMPTY
88055: LIST
88056: LIST
88057: LIST
88058: LIST
88059: LIST
88060: ST_TO_ADDR
// end ; 2 :
88061: GO 88620
88063: LD_INT 2
88065: DOUBLE
88066: EQUAL
88067: IFTRUE 88071
88069: GO 88200
88071: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
88072: LD_ADDR_VAR 0 5
88076: PUSH
88077: LD_VAR 0 1
88081: PUSH
88082: LD_VAR 0 2
88086: PUSH
88087: LD_INT 3
88089: MINUS
88090: PUSH
88091: LD_INT 3
88093: PUSH
88094: EMPTY
88095: LIST
88096: LIST
88097: LIST
88098: PUSH
88099: LD_VAR 0 1
88103: PUSH
88104: LD_INT 4
88106: PLUS
88107: PUSH
88108: LD_VAR 0 2
88112: PUSH
88113: LD_INT 4
88115: PUSH
88116: EMPTY
88117: LIST
88118: LIST
88119: LIST
88120: PUSH
88121: LD_VAR 0 1
88125: PUSH
88126: LD_VAR 0 2
88130: PUSH
88131: LD_INT 4
88133: PLUS
88134: PUSH
88135: LD_INT 0
88137: PUSH
88138: EMPTY
88139: LIST
88140: LIST
88141: LIST
88142: PUSH
88143: LD_VAR 0 1
88147: PUSH
88148: LD_INT 3
88150: MINUS
88151: PUSH
88152: LD_VAR 0 2
88156: PUSH
88157: LD_INT 1
88159: PUSH
88160: EMPTY
88161: LIST
88162: LIST
88163: LIST
88164: PUSH
88165: LD_VAR 0 1
88169: PUSH
88170: LD_INT 4
88172: MINUS
88173: PUSH
88174: LD_VAR 0 2
88178: PUSH
88179: LD_INT 4
88181: MINUS
88182: PUSH
88183: LD_INT 2
88185: PUSH
88186: EMPTY
88187: LIST
88188: LIST
88189: LIST
88190: PUSH
88191: EMPTY
88192: LIST
88193: LIST
88194: LIST
88195: LIST
88196: LIST
88197: ST_TO_ADDR
// end ; 3 :
88198: GO 88620
88200: LD_INT 3
88202: DOUBLE
88203: EQUAL
88204: IFTRUE 88208
88206: GO 88341
88208: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
88209: LD_ADDR_VAR 0 5
88213: PUSH
88214: LD_VAR 0 1
88218: PUSH
88219: LD_INT 3
88221: PLUS
88222: PUSH
88223: LD_VAR 0 2
88227: PUSH
88228: LD_INT 4
88230: PUSH
88231: EMPTY
88232: LIST
88233: LIST
88234: LIST
88235: PUSH
88236: LD_VAR 0 1
88240: PUSH
88241: LD_INT 4
88243: PLUS
88244: PUSH
88245: LD_VAR 0 2
88249: PUSH
88250: LD_INT 4
88252: PLUS
88253: PUSH
88254: LD_INT 5
88256: PUSH
88257: EMPTY
88258: LIST
88259: LIST
88260: LIST
88261: PUSH
88262: LD_VAR 0 1
88266: PUSH
88267: LD_INT 4
88269: MINUS
88270: PUSH
88271: LD_VAR 0 2
88275: PUSH
88276: LD_INT 1
88278: PUSH
88279: EMPTY
88280: LIST
88281: LIST
88282: LIST
88283: PUSH
88284: LD_VAR 0 1
88288: PUSH
88289: LD_VAR 0 2
88293: PUSH
88294: LD_INT 4
88296: MINUS
88297: PUSH
88298: LD_INT 3
88300: PUSH
88301: EMPTY
88302: LIST
88303: LIST
88304: LIST
88305: PUSH
88306: LD_VAR 0 1
88310: PUSH
88311: LD_INT 3
88313: MINUS
88314: PUSH
88315: LD_VAR 0 2
88319: PUSH
88320: LD_INT 3
88322: MINUS
88323: PUSH
88324: LD_INT 2
88326: PUSH
88327: EMPTY
88328: LIST
88329: LIST
88330: LIST
88331: PUSH
88332: EMPTY
88333: LIST
88334: LIST
88335: LIST
88336: LIST
88337: LIST
88338: ST_TO_ADDR
// end ; 4 :
88339: GO 88620
88341: LD_INT 4
88343: DOUBLE
88344: EQUAL
88345: IFTRUE 88349
88347: GO 88482
88349: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
88350: LD_ADDR_VAR 0 5
88354: PUSH
88355: LD_VAR 0 1
88359: PUSH
88360: LD_VAR 0 2
88364: PUSH
88365: LD_INT 4
88367: PLUS
88368: PUSH
88369: LD_INT 0
88371: PUSH
88372: EMPTY
88373: LIST
88374: LIST
88375: LIST
88376: PUSH
88377: LD_VAR 0 1
88381: PUSH
88382: LD_INT 3
88384: PLUS
88385: PUSH
88386: LD_VAR 0 2
88390: PUSH
88391: LD_INT 3
88393: PLUS
88394: PUSH
88395: LD_INT 5
88397: PUSH
88398: EMPTY
88399: LIST
88400: LIST
88401: LIST
88402: PUSH
88403: LD_VAR 0 1
88407: PUSH
88408: LD_INT 4
88410: PLUS
88411: PUSH
88412: LD_VAR 0 2
88416: PUSH
88417: LD_INT 4
88419: PUSH
88420: EMPTY
88421: LIST
88422: LIST
88423: LIST
88424: PUSH
88425: LD_VAR 0 1
88429: PUSH
88430: LD_VAR 0 2
88434: PUSH
88435: LD_INT 3
88437: MINUS
88438: PUSH
88439: LD_INT 3
88441: PUSH
88442: EMPTY
88443: LIST
88444: LIST
88445: LIST
88446: PUSH
88447: LD_VAR 0 1
88451: PUSH
88452: LD_INT 4
88454: MINUS
88455: PUSH
88456: LD_VAR 0 2
88460: PUSH
88461: LD_INT 4
88463: MINUS
88464: PUSH
88465: LD_INT 2
88467: PUSH
88468: EMPTY
88469: LIST
88470: LIST
88471: LIST
88472: PUSH
88473: EMPTY
88474: LIST
88475: LIST
88476: LIST
88477: LIST
88478: LIST
88479: ST_TO_ADDR
// end ; 5 :
88480: GO 88620
88482: LD_INT 5
88484: DOUBLE
88485: EQUAL
88486: IFTRUE 88490
88488: GO 88619
88490: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
88491: LD_ADDR_VAR 0 5
88495: PUSH
88496: LD_VAR 0 1
88500: PUSH
88501: LD_INT 4
88503: MINUS
88504: PUSH
88505: LD_VAR 0 2
88509: PUSH
88510: LD_INT 1
88512: PUSH
88513: EMPTY
88514: LIST
88515: LIST
88516: LIST
88517: PUSH
88518: LD_VAR 0 1
88522: PUSH
88523: LD_VAR 0 2
88527: PUSH
88528: LD_INT 4
88530: MINUS
88531: PUSH
88532: LD_INT 3
88534: PUSH
88535: EMPTY
88536: LIST
88537: LIST
88538: LIST
88539: PUSH
88540: LD_VAR 0 1
88544: PUSH
88545: LD_INT 4
88547: PLUS
88548: PUSH
88549: LD_VAR 0 2
88553: PUSH
88554: LD_INT 4
88556: PLUS
88557: PUSH
88558: LD_INT 5
88560: PUSH
88561: EMPTY
88562: LIST
88563: LIST
88564: LIST
88565: PUSH
88566: LD_VAR 0 1
88570: PUSH
88571: LD_INT 3
88573: PLUS
88574: PUSH
88575: LD_VAR 0 2
88579: PUSH
88580: LD_INT 4
88582: PUSH
88583: EMPTY
88584: LIST
88585: LIST
88586: LIST
88587: PUSH
88588: LD_VAR 0 1
88592: PUSH
88593: LD_VAR 0 2
88597: PUSH
88598: LD_INT 3
88600: PLUS
88601: PUSH
88602: LD_INT 0
88604: PUSH
88605: EMPTY
88606: LIST
88607: LIST
88608: LIST
88609: PUSH
88610: EMPTY
88611: LIST
88612: LIST
88613: LIST
88614: LIST
88615: LIST
88616: ST_TO_ADDR
// end ; end ;
88617: GO 88620
88619: POP
// result := list ;
88620: LD_ADDR_VAR 0 4
88624: PUSH
88625: LD_VAR 0 5
88629: ST_TO_ADDR
// end ;
88630: LD_VAR 0 4
88634: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
88635: LD_INT 0
88637: PPUSH
88638: PPUSH
88639: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
88640: LD_VAR 0 1
88644: NOT
88645: PUSH
88646: LD_VAR 0 2
88650: PUSH
88651: LD_INT 1
88653: PUSH
88654: LD_INT 2
88656: PUSH
88657: LD_INT 3
88659: PUSH
88660: LD_INT 4
88662: PUSH
88663: EMPTY
88664: LIST
88665: LIST
88666: LIST
88667: LIST
88668: IN
88669: NOT
88670: OR
88671: IFFALSE 88675
// exit ;
88673: GO 88767
// tmp := [ ] ;
88675: LD_ADDR_VAR 0 5
88679: PUSH
88680: EMPTY
88681: ST_TO_ADDR
// for i in units do
88682: LD_ADDR_VAR 0 4
88686: PUSH
88687: LD_VAR 0 1
88691: PUSH
88692: FOR_IN
88693: IFFALSE 88736
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
88695: LD_ADDR_VAR 0 5
88699: PUSH
88700: LD_VAR 0 5
88704: PPUSH
88705: LD_VAR 0 5
88709: PUSH
88710: LD_INT 1
88712: PLUS
88713: PPUSH
88714: LD_VAR 0 4
88718: PPUSH
88719: LD_VAR 0 2
88723: PPUSH
88724: CALL_OW 259
88728: PPUSH
88729: CALL_OW 2
88733: ST_TO_ADDR
88734: GO 88692
88736: POP
88737: POP
// if not tmp then
88738: LD_VAR 0 5
88742: NOT
88743: IFFALSE 88747
// exit ;
88745: GO 88767
// result := SortListByListDesc ( units , tmp ) ;
88747: LD_ADDR_VAR 0 3
88751: PUSH
88752: LD_VAR 0 1
88756: PPUSH
88757: LD_VAR 0 5
88761: PPUSH
88762: CALL_OW 77
88766: ST_TO_ADDR
// end ;
88767: LD_VAR 0 3
88771: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
88772: LD_INT 0
88774: PPUSH
88775: PPUSH
88776: PPUSH
// x := GetX ( building ) ;
88777: LD_ADDR_VAR 0 4
88781: PUSH
88782: LD_VAR 0 2
88786: PPUSH
88787: CALL_OW 250
88791: ST_TO_ADDR
// y := GetY ( building ) ;
88792: LD_ADDR_VAR 0 5
88796: PUSH
88797: LD_VAR 0 2
88801: PPUSH
88802: CALL_OW 251
88806: ST_TO_ADDR
// if GetTaskList ( unit ) then
88807: LD_VAR 0 1
88811: PPUSH
88812: CALL_OW 437
88816: IFFALSE 88911
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
88818: LD_STRING e
88820: PUSH
88821: LD_VAR 0 1
88825: PPUSH
88826: CALL_OW 437
88830: PUSH
88831: LD_INT 1
88833: ARRAY
88834: PUSH
88835: LD_INT 1
88837: ARRAY
88838: EQUAL
88839: PUSH
88840: LD_VAR 0 4
88844: PUSH
88845: LD_VAR 0 1
88849: PPUSH
88850: CALL_OW 437
88854: PUSH
88855: LD_INT 1
88857: ARRAY
88858: PUSH
88859: LD_INT 2
88861: ARRAY
88862: EQUAL
88863: AND
88864: PUSH
88865: LD_VAR 0 5
88869: PUSH
88870: LD_VAR 0 1
88874: PPUSH
88875: CALL_OW 437
88879: PUSH
88880: LD_INT 1
88882: ARRAY
88883: PUSH
88884: LD_INT 3
88886: ARRAY
88887: EQUAL
88888: AND
88889: IFFALSE 88901
// result := true else
88891: LD_ADDR_VAR 0 3
88895: PUSH
88896: LD_INT 1
88898: ST_TO_ADDR
88899: GO 88909
// result := false ;
88901: LD_ADDR_VAR 0 3
88905: PUSH
88906: LD_INT 0
88908: ST_TO_ADDR
// end else
88909: GO 88919
// result := false ;
88911: LD_ADDR_VAR 0 3
88915: PUSH
88916: LD_INT 0
88918: ST_TO_ADDR
// end ;
88919: LD_VAR 0 3
88923: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
88924: LD_INT 0
88926: PPUSH
88927: PPUSH
88928: PPUSH
88929: PPUSH
// if not unit or not area then
88930: LD_VAR 0 1
88934: NOT
88935: PUSH
88936: LD_VAR 0 2
88940: NOT
88941: OR
88942: IFFALSE 88946
// exit ;
88944: GO 89110
// tmp := AreaToList ( area , i ) ;
88946: LD_ADDR_VAR 0 6
88950: PUSH
88951: LD_VAR 0 2
88955: PPUSH
88956: LD_VAR 0 5
88960: PPUSH
88961: CALL_OW 517
88965: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
88966: LD_ADDR_VAR 0 5
88970: PUSH
88971: DOUBLE
88972: LD_INT 1
88974: DEC
88975: ST_TO_ADDR
88976: LD_VAR 0 6
88980: PUSH
88981: LD_INT 1
88983: ARRAY
88984: PUSH
88985: FOR_TO
88986: IFFALSE 89108
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
88988: LD_ADDR_VAR 0 7
88992: PUSH
88993: LD_VAR 0 6
88997: PUSH
88998: LD_INT 1
89000: ARRAY
89001: PUSH
89002: LD_VAR 0 5
89006: ARRAY
89007: PUSH
89008: LD_VAR 0 6
89012: PUSH
89013: LD_INT 2
89015: ARRAY
89016: PUSH
89017: LD_VAR 0 5
89021: ARRAY
89022: PUSH
89023: EMPTY
89024: LIST
89025: LIST
89026: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
89027: LD_VAR 0 7
89031: PUSH
89032: LD_INT 1
89034: ARRAY
89035: PPUSH
89036: LD_VAR 0 7
89040: PUSH
89041: LD_INT 2
89043: ARRAY
89044: PPUSH
89045: CALL_OW 428
89049: PUSH
89050: LD_INT 0
89052: EQUAL
89053: IFFALSE 89106
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
89055: LD_VAR 0 1
89059: PPUSH
89060: LD_VAR 0 7
89064: PUSH
89065: LD_INT 1
89067: ARRAY
89068: PPUSH
89069: LD_VAR 0 7
89073: PUSH
89074: LD_INT 2
89076: ARRAY
89077: PPUSH
89078: LD_VAR 0 3
89082: PPUSH
89083: CALL_OW 48
// result := IsPlaced ( unit ) ;
89087: LD_ADDR_VAR 0 4
89091: PUSH
89092: LD_VAR 0 1
89096: PPUSH
89097: CALL_OW 305
89101: ST_TO_ADDR
// exit ;
89102: POP
89103: POP
89104: GO 89110
// end ; end ;
89106: GO 88985
89108: POP
89109: POP
// end ;
89110: LD_VAR 0 4
89114: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
89115: LD_INT 0
89117: PPUSH
89118: PPUSH
89119: PPUSH
// if not side or side > 8 then
89120: LD_VAR 0 1
89124: NOT
89125: PUSH
89126: LD_VAR 0 1
89130: PUSH
89131: LD_INT 8
89133: GREATER
89134: OR
89135: IFFALSE 89139
// exit ;
89137: GO 89326
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
89139: LD_ADDR_VAR 0 4
89143: PUSH
89144: LD_INT 22
89146: PUSH
89147: LD_VAR 0 1
89151: PUSH
89152: EMPTY
89153: LIST
89154: LIST
89155: PUSH
89156: LD_INT 21
89158: PUSH
89159: LD_INT 3
89161: PUSH
89162: EMPTY
89163: LIST
89164: LIST
89165: PUSH
89166: EMPTY
89167: LIST
89168: LIST
89169: PPUSH
89170: CALL_OW 69
89174: ST_TO_ADDR
// if not tmp then
89175: LD_VAR 0 4
89179: NOT
89180: IFFALSE 89184
// exit ;
89182: GO 89326
// enable_addtolog := true ;
89184: LD_ADDR_OWVAR 81
89188: PUSH
89189: LD_INT 1
89191: ST_TO_ADDR
// AddToLog ( [ ) ;
89192: LD_STRING [
89194: PPUSH
89195: CALL_OW 561
// for i in tmp do
89199: LD_ADDR_VAR 0 3
89203: PUSH
89204: LD_VAR 0 4
89208: PUSH
89209: FOR_IN
89210: IFFALSE 89317
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
89212: LD_STRING [
89214: PUSH
89215: LD_VAR 0 3
89219: PPUSH
89220: CALL_OW 266
89224: STR
89225: PUSH
89226: LD_STRING , 
89228: STR
89229: PUSH
89230: LD_VAR 0 3
89234: PPUSH
89235: CALL_OW 250
89239: STR
89240: PUSH
89241: LD_STRING , 
89243: STR
89244: PUSH
89245: LD_VAR 0 3
89249: PPUSH
89250: CALL_OW 251
89254: STR
89255: PUSH
89256: LD_STRING , 
89258: STR
89259: PUSH
89260: LD_VAR 0 3
89264: PPUSH
89265: CALL_OW 254
89269: STR
89270: PUSH
89271: LD_STRING , 
89273: STR
89274: PUSH
89275: LD_VAR 0 3
89279: PPUSH
89280: LD_INT 1
89282: PPUSH
89283: CALL_OW 268
89287: STR
89288: PUSH
89289: LD_STRING , 
89291: STR
89292: PUSH
89293: LD_VAR 0 3
89297: PPUSH
89298: LD_INT 2
89300: PPUSH
89301: CALL_OW 268
89305: STR
89306: PUSH
89307: LD_STRING ],
89309: STR
89310: PPUSH
89311: CALL_OW 561
// end ;
89315: GO 89209
89317: POP
89318: POP
// AddToLog ( ]; ) ;
89319: LD_STRING ];
89321: PPUSH
89322: CALL_OW 561
// end ;
89326: LD_VAR 0 2
89330: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
89331: LD_INT 0
89333: PPUSH
89334: PPUSH
89335: PPUSH
89336: PPUSH
89337: PPUSH
// if not area or not rate or not max then
89338: LD_VAR 0 1
89342: NOT
89343: PUSH
89344: LD_VAR 0 2
89348: NOT
89349: OR
89350: PUSH
89351: LD_VAR 0 4
89355: NOT
89356: OR
89357: IFFALSE 89361
// exit ;
89359: GO 89553
// while 1 do
89361: LD_INT 1
89363: IFFALSE 89553
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
89365: LD_ADDR_VAR 0 9
89369: PUSH
89370: LD_VAR 0 1
89374: PPUSH
89375: LD_INT 1
89377: PPUSH
89378: CALL_OW 287
89382: PUSH
89383: LD_INT 10
89385: MUL
89386: ST_TO_ADDR
// r := rate / 10 ;
89387: LD_ADDR_VAR 0 7
89391: PUSH
89392: LD_VAR 0 2
89396: PUSH
89397: LD_INT 10
89399: DIVREAL
89400: ST_TO_ADDR
// time := 1 1$00 ;
89401: LD_ADDR_VAR 0 8
89405: PUSH
89406: LD_INT 2100
89408: ST_TO_ADDR
// if amount < min then
89409: LD_VAR 0 9
89413: PUSH
89414: LD_VAR 0 3
89418: LESS
89419: IFFALSE 89437
// r := r * 2 else
89421: LD_ADDR_VAR 0 7
89425: PUSH
89426: LD_VAR 0 7
89430: PUSH
89431: LD_INT 2
89433: MUL
89434: ST_TO_ADDR
89435: GO 89463
// if amount > max then
89437: LD_VAR 0 9
89441: PUSH
89442: LD_VAR 0 4
89446: GREATER
89447: IFFALSE 89463
// r := r / 2 ;
89449: LD_ADDR_VAR 0 7
89453: PUSH
89454: LD_VAR 0 7
89458: PUSH
89459: LD_INT 2
89461: DIVREAL
89462: ST_TO_ADDR
// time := time / r ;
89463: LD_ADDR_VAR 0 8
89467: PUSH
89468: LD_VAR 0 8
89472: PUSH
89473: LD_VAR 0 7
89477: DIVREAL
89478: ST_TO_ADDR
// if time < 0 then
89479: LD_VAR 0 8
89483: PUSH
89484: LD_INT 0
89486: LESS
89487: IFFALSE 89504
// time := time * - 1 ;
89489: LD_ADDR_VAR 0 8
89493: PUSH
89494: LD_VAR 0 8
89498: PUSH
89499: LD_INT 1
89501: NEG
89502: MUL
89503: ST_TO_ADDR
// wait ( time ) ;
89504: LD_VAR 0 8
89508: PPUSH
89509: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
89513: LD_INT 35
89515: PPUSH
89516: LD_INT 875
89518: PPUSH
89519: CALL_OW 12
89523: PPUSH
89524: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
89528: LD_INT 1
89530: PPUSH
89531: LD_INT 5
89533: PPUSH
89534: CALL_OW 12
89538: PPUSH
89539: LD_VAR 0 1
89543: PPUSH
89544: LD_INT 1
89546: PPUSH
89547: CALL_OW 55
// end ;
89551: GO 89361
// end ;
89553: LD_VAR 0 5
89557: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
89558: LD_INT 0
89560: PPUSH
89561: PPUSH
89562: PPUSH
89563: PPUSH
89564: PPUSH
89565: PPUSH
89566: PPUSH
89567: PPUSH
// if not turrets or not factories then
89568: LD_VAR 0 1
89572: NOT
89573: PUSH
89574: LD_VAR 0 2
89578: NOT
89579: OR
89580: IFFALSE 89584
// exit ;
89582: GO 89891
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
89584: LD_ADDR_VAR 0 10
89588: PUSH
89589: LD_INT 5
89591: PUSH
89592: LD_INT 6
89594: PUSH
89595: EMPTY
89596: LIST
89597: LIST
89598: PUSH
89599: LD_INT 2
89601: PUSH
89602: LD_INT 4
89604: PUSH
89605: EMPTY
89606: LIST
89607: LIST
89608: PUSH
89609: LD_INT 3
89611: PUSH
89612: LD_INT 5
89614: PUSH
89615: EMPTY
89616: LIST
89617: LIST
89618: PUSH
89619: EMPTY
89620: LIST
89621: LIST
89622: LIST
89623: PUSH
89624: LD_INT 24
89626: PUSH
89627: LD_INT 25
89629: PUSH
89630: EMPTY
89631: LIST
89632: LIST
89633: PUSH
89634: LD_INT 23
89636: PUSH
89637: LD_INT 27
89639: PUSH
89640: EMPTY
89641: LIST
89642: LIST
89643: PUSH
89644: EMPTY
89645: LIST
89646: LIST
89647: PUSH
89648: LD_INT 42
89650: PUSH
89651: LD_INT 43
89653: PUSH
89654: EMPTY
89655: LIST
89656: LIST
89657: PUSH
89658: LD_INT 44
89660: PUSH
89661: LD_INT 46
89663: PUSH
89664: EMPTY
89665: LIST
89666: LIST
89667: PUSH
89668: LD_INT 45
89670: PUSH
89671: LD_INT 47
89673: PUSH
89674: EMPTY
89675: LIST
89676: LIST
89677: PUSH
89678: EMPTY
89679: LIST
89680: LIST
89681: LIST
89682: PUSH
89683: EMPTY
89684: LIST
89685: LIST
89686: LIST
89687: ST_TO_ADDR
// result := [ ] ;
89688: LD_ADDR_VAR 0 3
89692: PUSH
89693: EMPTY
89694: ST_TO_ADDR
// for i in turrets do
89695: LD_ADDR_VAR 0 4
89699: PUSH
89700: LD_VAR 0 1
89704: PUSH
89705: FOR_IN
89706: IFFALSE 89889
// begin nat := GetNation ( i ) ;
89708: LD_ADDR_VAR 0 7
89712: PUSH
89713: LD_VAR 0 4
89717: PPUSH
89718: CALL_OW 248
89722: ST_TO_ADDR
// weapon := 0 ;
89723: LD_ADDR_VAR 0 8
89727: PUSH
89728: LD_INT 0
89730: ST_TO_ADDR
// if not nat then
89731: LD_VAR 0 7
89735: NOT
89736: IFFALSE 89740
// continue ;
89738: GO 89705
// for j in list [ nat ] do
89740: LD_ADDR_VAR 0 5
89744: PUSH
89745: LD_VAR 0 10
89749: PUSH
89750: LD_VAR 0 7
89754: ARRAY
89755: PUSH
89756: FOR_IN
89757: IFFALSE 89798
// if GetBWeapon ( i ) = j [ 1 ] then
89759: LD_VAR 0 4
89763: PPUSH
89764: CALL_OW 269
89768: PUSH
89769: LD_VAR 0 5
89773: PUSH
89774: LD_INT 1
89776: ARRAY
89777: EQUAL
89778: IFFALSE 89796
// begin weapon := j [ 2 ] ;
89780: LD_ADDR_VAR 0 8
89784: PUSH
89785: LD_VAR 0 5
89789: PUSH
89790: LD_INT 2
89792: ARRAY
89793: ST_TO_ADDR
// break ;
89794: GO 89798
// end ;
89796: GO 89756
89798: POP
89799: POP
// if not weapon then
89800: LD_VAR 0 8
89804: NOT
89805: IFFALSE 89809
// continue ;
89807: GO 89705
// for k in factories do
89809: LD_ADDR_VAR 0 6
89813: PUSH
89814: LD_VAR 0 2
89818: PUSH
89819: FOR_IN
89820: IFFALSE 89885
// begin weapons := AvailableWeaponList ( k ) ;
89822: LD_ADDR_VAR 0 9
89826: PUSH
89827: LD_VAR 0 6
89831: PPUSH
89832: CALL_OW 478
89836: ST_TO_ADDR
// if not weapons then
89837: LD_VAR 0 9
89841: NOT
89842: IFFALSE 89846
// continue ;
89844: GO 89819
// if weapon in weapons then
89846: LD_VAR 0 8
89850: PUSH
89851: LD_VAR 0 9
89855: IN
89856: IFFALSE 89883
// begin result := [ i , weapon ] ;
89858: LD_ADDR_VAR 0 3
89862: PUSH
89863: LD_VAR 0 4
89867: PUSH
89868: LD_VAR 0 8
89872: PUSH
89873: EMPTY
89874: LIST
89875: LIST
89876: ST_TO_ADDR
// exit ;
89877: POP
89878: POP
89879: POP
89880: POP
89881: GO 89891
// end ; end ;
89883: GO 89819
89885: POP
89886: POP
// end ;
89887: GO 89705
89889: POP
89890: POP
// end ;
89891: LD_VAR 0 3
89895: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
89896: LD_INT 0
89898: PPUSH
// if not side or side > 8 then
89899: LD_VAR 0 3
89903: NOT
89904: PUSH
89905: LD_VAR 0 3
89909: PUSH
89910: LD_INT 8
89912: GREATER
89913: OR
89914: IFFALSE 89918
// exit ;
89916: GO 89977
// if not range then
89918: LD_VAR 0 4
89922: NOT
89923: IFFALSE 89934
// range := - 12 ;
89925: LD_ADDR_VAR 0 4
89929: PUSH
89930: LD_INT 12
89932: NEG
89933: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
89934: LD_VAR 0 1
89938: PPUSH
89939: LD_VAR 0 2
89943: PPUSH
89944: LD_VAR 0 3
89948: PPUSH
89949: LD_VAR 0 4
89953: PPUSH
89954: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
89958: LD_VAR 0 1
89962: PPUSH
89963: LD_VAR 0 2
89967: PPUSH
89968: LD_VAR 0 3
89972: PPUSH
89973: CALL_OW 331
// end ;
89977: LD_VAR 0 5
89981: RET
// export function Video ( mode ) ; begin
89982: LD_INT 0
89984: PPUSH
// ingame_video = mode ;
89985: LD_ADDR_OWVAR 52
89989: PUSH
89990: LD_VAR 0 1
89994: ST_TO_ADDR
// interface_hidden = mode ;
89995: LD_ADDR_OWVAR 54
89999: PUSH
90000: LD_VAR 0 1
90004: ST_TO_ADDR
// end ;
90005: LD_VAR 0 2
90009: RET
// export function Join ( array , element ) ; begin
90010: LD_INT 0
90012: PPUSH
// result := array ^ element ;
90013: LD_ADDR_VAR 0 3
90017: PUSH
90018: LD_VAR 0 1
90022: PUSH
90023: LD_VAR 0 2
90027: ADD
90028: ST_TO_ADDR
// end ;
90029: LD_VAR 0 3
90033: RET
// export function JoinUnion ( array , element ) ; begin
90034: LD_INT 0
90036: PPUSH
// result := array union element ;
90037: LD_ADDR_VAR 0 3
90041: PUSH
90042: LD_VAR 0 1
90046: PUSH
90047: LD_VAR 0 2
90051: UNION
90052: ST_TO_ADDR
// end ;
90053: LD_VAR 0 3
90057: RET
// export function GetBehemoths ( side ) ; begin
90058: LD_INT 0
90060: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
90061: LD_ADDR_VAR 0 2
90065: PUSH
90066: LD_INT 22
90068: PUSH
90069: LD_VAR 0 1
90073: PUSH
90074: EMPTY
90075: LIST
90076: LIST
90077: PUSH
90078: LD_INT 31
90080: PUSH
90081: LD_INT 25
90083: PUSH
90084: EMPTY
90085: LIST
90086: LIST
90087: PUSH
90088: EMPTY
90089: LIST
90090: LIST
90091: PPUSH
90092: CALL_OW 69
90096: ST_TO_ADDR
// end ;
90097: LD_VAR 0 2
90101: RET
// export function Shuffle ( array ) ; var i , index ; begin
90102: LD_INT 0
90104: PPUSH
90105: PPUSH
90106: PPUSH
// result := [ ] ;
90107: LD_ADDR_VAR 0 2
90111: PUSH
90112: EMPTY
90113: ST_TO_ADDR
// if not array then
90114: LD_VAR 0 1
90118: NOT
90119: IFFALSE 90123
// exit ;
90121: GO 90222
// Randomize ;
90123: CALL_OW 10
// for i = array downto 1 do
90127: LD_ADDR_VAR 0 3
90131: PUSH
90132: DOUBLE
90133: LD_VAR 0 1
90137: INC
90138: ST_TO_ADDR
90139: LD_INT 1
90141: PUSH
90142: FOR_DOWNTO
90143: IFFALSE 90220
// begin index := rand ( 1 , array ) ;
90145: LD_ADDR_VAR 0 4
90149: PUSH
90150: LD_INT 1
90152: PPUSH
90153: LD_VAR 0 1
90157: PPUSH
90158: CALL_OW 12
90162: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
90163: LD_ADDR_VAR 0 2
90167: PUSH
90168: LD_VAR 0 2
90172: PPUSH
90173: LD_VAR 0 2
90177: PUSH
90178: LD_INT 1
90180: PLUS
90181: PPUSH
90182: LD_VAR 0 1
90186: PUSH
90187: LD_VAR 0 4
90191: ARRAY
90192: PPUSH
90193: CALL_OW 2
90197: ST_TO_ADDR
// array := Delete ( array , index ) ;
90198: LD_ADDR_VAR 0 1
90202: PUSH
90203: LD_VAR 0 1
90207: PPUSH
90208: LD_VAR 0 4
90212: PPUSH
90213: CALL_OW 3
90217: ST_TO_ADDR
// end ;
90218: GO 90142
90220: POP
90221: POP
// end ;
90222: LD_VAR 0 2
90226: RET
// export function GetBaseMaterials ( base ) ; begin
90227: LD_INT 0
90229: PPUSH
// result := [ 0 , 0 , 0 ] ;
90230: LD_ADDR_VAR 0 2
90234: PUSH
90235: LD_INT 0
90237: PUSH
90238: LD_INT 0
90240: PUSH
90241: LD_INT 0
90243: PUSH
90244: EMPTY
90245: LIST
90246: LIST
90247: LIST
90248: ST_TO_ADDR
// if not base then
90249: LD_VAR 0 1
90253: NOT
90254: IFFALSE 90258
// exit ;
90256: GO 90307
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
90258: LD_ADDR_VAR 0 2
90262: PUSH
90263: LD_VAR 0 1
90267: PPUSH
90268: LD_INT 1
90270: PPUSH
90271: CALL_OW 275
90275: PUSH
90276: LD_VAR 0 1
90280: PPUSH
90281: LD_INT 2
90283: PPUSH
90284: CALL_OW 275
90288: PUSH
90289: LD_VAR 0 1
90293: PPUSH
90294: LD_INT 3
90296: PPUSH
90297: CALL_OW 275
90301: PUSH
90302: EMPTY
90303: LIST
90304: LIST
90305: LIST
90306: ST_TO_ADDR
// end ; end_of_file
90307: LD_VAR 0 2
90311: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
90312: GO 90314
90314: DISABLE
// begin ru_radar := 98 ;
90315: LD_ADDR_EXP 93
90319: PUSH
90320: LD_INT 98
90322: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
90323: LD_ADDR_EXP 94
90327: PUSH
90328: LD_INT 89
90330: ST_TO_ADDR
// us_hack := 99 ;
90331: LD_ADDR_EXP 95
90335: PUSH
90336: LD_INT 99
90338: ST_TO_ADDR
// us_artillery := 97 ;
90339: LD_ADDR_EXP 96
90343: PUSH
90344: LD_INT 97
90346: ST_TO_ADDR
// ar_bio_bomb := 91 ;
90347: LD_ADDR_EXP 97
90351: PUSH
90352: LD_INT 91
90354: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
90355: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
90356: LD_INT 0
90358: PPUSH
90359: PPUSH
90360: PPUSH
90361: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
90362: LD_VAR 0 1
90366: PPUSH
90367: CALL_OW 264
90371: PUSH
90372: LD_EXP 97
90376: EQUAL
90377: IFFALSE 90449
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
90379: LD_INT 68
90381: PPUSH
90382: LD_VAR 0 1
90386: PPUSH
90387: CALL_OW 255
90391: PPUSH
90392: CALL_OW 321
90396: PUSH
90397: LD_INT 2
90399: EQUAL
90400: IFFALSE 90412
// eff := 70 else
90402: LD_ADDR_VAR 0 6
90406: PUSH
90407: LD_INT 70
90409: ST_TO_ADDR
90410: GO 90420
// eff := 30 ;
90412: LD_ADDR_VAR 0 6
90416: PUSH
90417: LD_INT 30
90419: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
90420: LD_VAR 0 1
90424: PPUSH
90425: CALL_OW 250
90429: PPUSH
90430: LD_VAR 0 1
90434: PPUSH
90435: CALL_OW 251
90439: PPUSH
90440: LD_VAR 0 6
90444: PPUSH
90445: CALL_OW 495
// end ; end ;
90449: LD_VAR 0 4
90453: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
90454: LD_INT 0
90456: PPUSH
90457: PPUSH
90458: PPUSH
90459: PPUSH
90460: PPUSH
90461: PPUSH
// if cmd = 124 then
90462: LD_VAR 0 1
90466: PUSH
90467: LD_INT 124
90469: EQUAL
90470: IFFALSE 90676
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
90472: LD_ADDR_VAR 0 5
90476: PUSH
90477: LD_INT 2
90479: PUSH
90480: LD_INT 34
90482: PUSH
90483: LD_INT 53
90485: PUSH
90486: EMPTY
90487: LIST
90488: LIST
90489: PUSH
90490: LD_INT 34
90492: PUSH
90493: LD_INT 14
90495: PUSH
90496: EMPTY
90497: LIST
90498: LIST
90499: PUSH
90500: EMPTY
90501: LIST
90502: LIST
90503: LIST
90504: PPUSH
90505: CALL_OW 69
90509: ST_TO_ADDR
// if not tmp then
90510: LD_VAR 0 5
90514: NOT
90515: IFFALSE 90519
// exit ;
90517: GO 90676
// for i in tmp do
90519: LD_ADDR_VAR 0 3
90523: PUSH
90524: LD_VAR 0 5
90528: PUSH
90529: FOR_IN
90530: IFFALSE 90674
// begin taskList := GetTaskList ( i ) ;
90532: LD_ADDR_VAR 0 6
90536: PUSH
90537: LD_VAR 0 3
90541: PPUSH
90542: CALL_OW 437
90546: ST_TO_ADDR
// if not taskList then
90547: LD_VAR 0 6
90551: NOT
90552: IFFALSE 90556
// continue ;
90554: GO 90529
// for j = 1 to taskList do
90556: LD_ADDR_VAR 0 4
90560: PUSH
90561: DOUBLE
90562: LD_INT 1
90564: DEC
90565: ST_TO_ADDR
90566: LD_VAR 0 6
90570: PUSH
90571: FOR_TO
90572: IFFALSE 90670
// if taskList [ j ] [ 1 ] = | then
90574: LD_VAR 0 6
90578: PUSH
90579: LD_VAR 0 4
90583: ARRAY
90584: PUSH
90585: LD_INT 1
90587: ARRAY
90588: PUSH
90589: LD_STRING |
90591: EQUAL
90592: IFFALSE 90668
// begin _taskList := Delete ( taskList , 1 ) ;
90594: LD_ADDR_VAR 0 7
90598: PUSH
90599: LD_VAR 0 6
90603: PPUSH
90604: LD_INT 1
90606: PPUSH
90607: CALL_OW 3
90611: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
90612: LD_VAR 0 3
90616: PPUSH
90617: LD_VAR 0 7
90621: PPUSH
90622: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
90626: LD_VAR 0 3
90630: PPUSH
90631: LD_VAR 0 6
90635: PUSH
90636: LD_VAR 0 4
90640: ARRAY
90641: PUSH
90642: LD_INT 2
90644: ARRAY
90645: PPUSH
90646: LD_VAR 0 6
90650: PUSH
90651: LD_VAR 0 4
90655: ARRAY
90656: PUSH
90657: LD_INT 3
90659: ARRAY
90660: PPUSH
90661: LD_INT 8
90663: PPUSH
90664: CALL 90681 0 4
// end ;
90668: GO 90571
90670: POP
90671: POP
// end ;
90672: GO 90529
90674: POP
90675: POP
// end ; end ;
90676: LD_VAR 0 2
90680: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
90681: LD_INT 0
90683: PPUSH
90684: PPUSH
90685: PPUSH
90686: PPUSH
90687: PPUSH
90688: PPUSH
90689: PPUSH
90690: PPUSH
90691: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
90692: LD_VAR 0 1
90696: NOT
90697: PUSH
90698: LD_VAR 0 2
90702: PPUSH
90703: LD_VAR 0 3
90707: PPUSH
90708: CALL_OW 488
90712: NOT
90713: OR
90714: PUSH
90715: LD_VAR 0 4
90719: NOT
90720: OR
90721: IFFALSE 90725
// exit ;
90723: GO 91065
// list := [ ] ;
90725: LD_ADDR_VAR 0 13
90729: PUSH
90730: EMPTY
90731: ST_TO_ADDR
// if x - r < 0 then
90732: LD_VAR 0 2
90736: PUSH
90737: LD_VAR 0 4
90741: MINUS
90742: PUSH
90743: LD_INT 0
90745: LESS
90746: IFFALSE 90758
// min_x := 0 else
90748: LD_ADDR_VAR 0 7
90752: PUSH
90753: LD_INT 0
90755: ST_TO_ADDR
90756: GO 90774
// min_x := x - r ;
90758: LD_ADDR_VAR 0 7
90762: PUSH
90763: LD_VAR 0 2
90767: PUSH
90768: LD_VAR 0 4
90772: MINUS
90773: ST_TO_ADDR
// if y - r < 0 then
90774: LD_VAR 0 3
90778: PUSH
90779: LD_VAR 0 4
90783: MINUS
90784: PUSH
90785: LD_INT 0
90787: LESS
90788: IFFALSE 90800
// min_y := 0 else
90790: LD_ADDR_VAR 0 8
90794: PUSH
90795: LD_INT 0
90797: ST_TO_ADDR
90798: GO 90816
// min_y := y - r ;
90800: LD_ADDR_VAR 0 8
90804: PUSH
90805: LD_VAR 0 3
90809: PUSH
90810: LD_VAR 0 4
90814: MINUS
90815: ST_TO_ADDR
// max_x := x + r ;
90816: LD_ADDR_VAR 0 9
90820: PUSH
90821: LD_VAR 0 2
90825: PUSH
90826: LD_VAR 0 4
90830: PLUS
90831: ST_TO_ADDR
// max_y := y + r ;
90832: LD_ADDR_VAR 0 10
90836: PUSH
90837: LD_VAR 0 3
90841: PUSH
90842: LD_VAR 0 4
90846: PLUS
90847: ST_TO_ADDR
// for _x = min_x to max_x do
90848: LD_ADDR_VAR 0 11
90852: PUSH
90853: DOUBLE
90854: LD_VAR 0 7
90858: DEC
90859: ST_TO_ADDR
90860: LD_VAR 0 9
90864: PUSH
90865: FOR_TO
90866: IFFALSE 90983
// for _y = min_y to max_y do
90868: LD_ADDR_VAR 0 12
90872: PUSH
90873: DOUBLE
90874: LD_VAR 0 8
90878: DEC
90879: ST_TO_ADDR
90880: LD_VAR 0 10
90884: PUSH
90885: FOR_TO
90886: IFFALSE 90979
// begin if not ValidHex ( _x , _y ) then
90888: LD_VAR 0 11
90892: PPUSH
90893: LD_VAR 0 12
90897: PPUSH
90898: CALL_OW 488
90902: NOT
90903: IFFALSE 90907
// continue ;
90905: GO 90885
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
90907: LD_VAR 0 11
90911: PPUSH
90912: LD_VAR 0 12
90916: PPUSH
90917: CALL_OW 351
90921: PUSH
90922: LD_VAR 0 11
90926: PPUSH
90927: LD_VAR 0 12
90931: PPUSH
90932: CALL_OW 554
90936: AND
90937: IFFALSE 90977
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
90939: LD_ADDR_VAR 0 13
90943: PUSH
90944: LD_VAR 0 13
90948: PPUSH
90949: LD_VAR 0 13
90953: PUSH
90954: LD_INT 1
90956: PLUS
90957: PPUSH
90958: LD_VAR 0 11
90962: PUSH
90963: LD_VAR 0 12
90967: PUSH
90968: EMPTY
90969: LIST
90970: LIST
90971: PPUSH
90972: CALL_OW 2
90976: ST_TO_ADDR
// end ;
90977: GO 90885
90979: POP
90980: POP
90981: GO 90865
90983: POP
90984: POP
// if not list then
90985: LD_VAR 0 13
90989: NOT
90990: IFFALSE 90994
// exit ;
90992: GO 91065
// for i in list do
90994: LD_ADDR_VAR 0 6
90998: PUSH
90999: LD_VAR 0 13
91003: PUSH
91004: FOR_IN
91005: IFFALSE 91063
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
91007: LD_VAR 0 1
91011: PPUSH
91012: LD_STRING M
91014: PUSH
91015: LD_VAR 0 6
91019: PUSH
91020: LD_INT 1
91022: ARRAY
91023: PUSH
91024: LD_VAR 0 6
91028: PUSH
91029: LD_INT 2
91031: ARRAY
91032: PUSH
91033: LD_INT 0
91035: PUSH
91036: LD_INT 0
91038: PUSH
91039: LD_INT 0
91041: PUSH
91042: LD_INT 0
91044: PUSH
91045: EMPTY
91046: LIST
91047: LIST
91048: LIST
91049: LIST
91050: LIST
91051: LIST
91052: LIST
91053: PUSH
91054: EMPTY
91055: LIST
91056: PPUSH
91057: CALL_OW 447
91061: GO 91004
91063: POP
91064: POP
// end ;
91065: LD_VAR 0 5
91069: RET
