// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Randomize ;
  11: CALL_OW 10
// InitVariables ;
  15: CALL 94 0 0
// InitMacro ;
  19: CALL 17279 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// ChangeSideFog ( 8 , 1 ) ;
  36: LD_INT 8
  38: PPUSH
  39: LD_INT 1
  41: PPUSH
  42: CALL_OW 343
// PrepareNature ( 4 , 3 , 6 , 3 , 2 , 0 , 7 , natureArea , waterArea ) ;
  46: LD_INT 4
  48: PPUSH
  49: LD_INT 3
  51: PPUSH
  52: LD_INT 6
  54: PPUSH
  55: LD_INT 3
  57: PPUSH
  58: LD_INT 2
  60: PPUSH
  61: LD_INT 0
  63: PPUSH
  64: LD_INT 7
  66: PPUSH
  67: LD_INT 18
  69: PPUSH
  70: LD_INT 19
  72: PPUSH
  73: CALL 82224 0 9
// PrepareAmerican ;
  77: CALL 562 0 0
// PrepareArabian ;
  81: CALL 2234 0 0
// MC_Start ( ) ;
  85: CALL 19391 0 0
// Action ;
  89: CALL 7969 0 0
// end ;
  93: END
// export debug , game ; export mission_prefix , mission_prefix_prev ; export ar_run , base_captured , ar_patrol , us_scout , seen , can_kamikazed , kamikazed , artifact_stolen , artifact_get , artifact_oncargo , game_time , powell_warn , loses_counter , gensher_active , selected , am_veh_consturcted ; function InitVariables ; begin
  94: LD_INT 0
  96: PPUSH
// debug := 1 ;
  97: LD_ADDR_EXP 1
 101: PUSH
 102: LD_INT 1
 104: ST_TO_ADDR
// game := true ;
 105: LD_ADDR_EXP 2
 109: PUSH
 110: LD_INT 1
 112: ST_TO_ADDR
// mission_prefix := 11_ ;
 113: LD_ADDR_EXP 3
 117: PUSH
 118: LD_STRING 11_
 120: ST_TO_ADDR
// mission_prefix_prev := 10c_ ;
 121: LD_ADDR_EXP 4
 125: PUSH
 126: LD_STRING 10c_
 128: ST_TO_ADDR
// ar_run := false ;
 129: LD_ADDR_EXP 5
 133: PUSH
 134: LD_INT 0
 136: ST_TO_ADDR
// ar_patrol := false ;
 137: LD_ADDR_EXP 7
 141: PUSH
 142: LD_INT 0
 144: ST_TO_ADDR
// base_captured := false ;
 145: LD_ADDR_EXP 6
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// us_scout := 0 ;
 153: LD_ADDR_EXP 8
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// seen := [ 0 , 0 , 0 , 0 , 0 ] ;
 161: LD_ADDR_EXP 9
 165: PUSH
 166: LD_INT 0
 168: PUSH
 169: LD_INT 0
 171: PUSH
 172: LD_INT 0
 174: PUSH
 175: LD_INT 0
 177: PUSH
 178: LD_INT 0
 180: PUSH
 181: EMPTY
 182: LIST
 183: LIST
 184: LIST
 185: LIST
 186: LIST
 187: ST_TO_ADDR
// kamikazed := false ;
 188: LD_ADDR_EXP 11
 192: PUSH
 193: LD_INT 0
 195: ST_TO_ADDR
// artifact_stolen := false ;
 196: LD_ADDR_EXP 12
 200: PUSH
 201: LD_INT 0
 203: ST_TO_ADDR
// artifact_get := false ;
 204: LD_ADDR_EXP 13
 208: PUSH
 209: LD_INT 0
 211: ST_TO_ADDR
// game_time := [ 130 130$00 , 120 120$00 , 115 115$00 ] [ Difficulty ] ;
 212: LD_ADDR_EXP 15
 216: PUSH
 217: LD_INT 273000
 219: PUSH
 220: LD_INT 252000
 222: PUSH
 223: LD_INT 241500
 225: PUSH
 226: EMPTY
 227: LIST
 228: LIST
 229: LIST
 230: PUSH
 231: LD_OWVAR 67
 235: ARRAY
 236: ST_TO_ADDR
// powell_warn := false ;
 237: LD_ADDR_EXP 16
 241: PUSH
 242: LD_INT 0
 244: ST_TO_ADDR
// loses_counter := 0 ;
 245: LD_ADDR_EXP 17
 249: PUSH
 250: LD_INT 0
 252: ST_TO_ADDR
// artifact_oncargo := false ;
 253: LD_ADDR_EXP 14
 257: PUSH
 258: LD_INT 0
 260: ST_TO_ADDR
// gensher_active := LoadVariable ( 10_GensherEscape_1 , debug ) ;
 261: LD_ADDR_EXP 18
 265: PUSH
 266: LD_STRING 10_GensherEscape_1
 268: PPUSH
 269: LD_EXP 1
 273: PPUSH
 274: CALL_OW 30
 278: ST_TO_ADDR
// can_kamikazed := false ;
 279: LD_ADDR_EXP 10
 283: PUSH
 284: LD_INT 0
 286: ST_TO_ADDR
// am_veh_consturcted := false ;
 287: LD_ADDR_EXP 20
 291: PUSH
 292: LD_INT 0
 294: ST_TO_ADDR
// end ;
 295: LD_VAR 0 1
 299: RET
// export function CustomInitMacro ; var i ; begin
 300: LD_INT 0
 302: PPUSH
 303: PPUSH
// mc_parking := [ parking_north , parking_west , parking_east ] ;
 304: LD_ADDR_EXP 74
 308: PUSH
 309: LD_INT 20
 311: PUSH
 312: LD_INT 21
 314: PUSH
 315: LD_INT 22
 317: PUSH
 318: EMPTY
 319: LIST
 320: LIST
 321: LIST
 322: ST_TO_ADDR
// mc_scan_area := [ base_north , base_west , base_east ] ;
 323: LD_ADDR_EXP 75
 327: PUSH
 328: LD_INT 28
 330: PUSH
 331: LD_INT 24
 333: PUSH
 334: LD_INT 26
 336: PUSH
 337: EMPTY
 338: LIST
 339: LIST
 340: LIST
 341: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 4 , 6 , 9 ] [ Difficulty ] , minefield1_left ) ;
 342: LD_INT 1
 344: PPUSH
 345: LD_INT 4
 347: PUSH
 348: LD_INT 6
 350: PUSH
 351: LD_INT 9
 353: PUSH
 354: EMPTY
 355: LIST
 356: LIST
 357: LIST
 358: PUSH
 359: LD_OWVAR 67
 363: ARRAY
 364: PPUSH
 365: LD_INT 3
 367: PPUSH
 368: CALL 40608 0 3
// MC_SetMinesField ( 2 , [ 4 , 6 , 9 ] [ Difficulty ] , minefield2_left ) ;
 372: LD_INT 2
 374: PPUSH
 375: LD_INT 4
 377: PUSH
 378: LD_INT 6
 380: PUSH
 381: LD_INT 9
 383: PUSH
 384: EMPTY
 385: LIST
 386: LIST
 387: LIST
 388: PUSH
 389: LD_OWVAR 67
 393: ARRAY
 394: PPUSH
 395: LD_INT 2
 397: PPUSH
 398: CALL 40608 0 3
// MC_SetMinesField ( 3 , [ 4 , 6 , 9 ] [ Difficulty ] , minefield3_left ) ;
 402: LD_INT 3
 404: PPUSH
 405: LD_INT 4
 407: PUSH
 408: LD_INT 6
 410: PUSH
 411: LD_INT 9
 413: PUSH
 414: EMPTY
 415: LIST
 416: LIST
 417: LIST
 418: PUSH
 419: LD_OWVAR 67
 423: ARRAY
 424: PPUSH
 425: LD_INT 1
 427: PPUSH
 428: CALL 40608 0 3
// for i = 1 to mc_bases do
 432: LD_ADDR_VAR 0 2
 436: PUSH
 437: DOUBLE
 438: LD_INT 1
 440: DEC
 441: ST_TO_ADDR
 442: LD_EXP 50
 446: PUSH
 447: FOR_TO
 448: IFFALSE 472
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 450: LD_VAR 0 2
 454: PPUSH
 455: LD_EXP 43
 459: PUSH
 460: LD_VAR 0 2
 464: ARRAY
 465: PPUSH
 466: CALL 41034 0 2
 470: GO 447
 472: POP
 473: POP
// end ;
 474: LD_VAR 0 1
 478: RET
// function Debuger ; var i ; begin
 479: LD_INT 0
 481: PPUSH
 482: PPUSH
// if not debug then
 483: LD_EXP 1
 487: NOT
 488: IFFALSE 492
// exit ;
 490: GO 528
// game_speed := 5 ;
 492: LD_ADDR_OWVAR 65
 496: PUSH
 497: LD_INT 5
 499: ST_TO_ADDR
// uc_side := 1 ;
 500: LD_ADDR_OWVAR 20
 504: PUSH
 505: LD_INT 1
 507: ST_TO_ADDR
// uc_nation := 1 ;
 508: LD_ADDR_OWVAR 21
 512: PUSH
 513: LD_INT 1
 515: ST_TO_ADDR
// SetSide ( ar_force_south , 1 ) ;
 516: LD_EXP 36
 520: PPUSH
 521: LD_INT 1
 523: PPUSH
 524: CALL_OW 235
// end ;
 528: LD_VAR 0 1
 532: RET
// every 0 0$1 trigger IsDead ( ar_dep_n ) and IsOk ( ar_dep_w ) do
 533: LD_INT 94
 535: PPUSH
 536: CALL_OW 301
 540: PUSH
 541: LD_INT 45
 543: PPUSH
 544: CALL_OW 302
 548: AND
 549: IFFALSE 561
 551: GO 553
 553: DISABLE
// SetAchievement ( ACH_EAST ) ; end_of_file
 554: LD_STRING ACH_EAST
 556: PPUSH
 557: CALL_OW 543
 561: END
// export JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Frank , Kikuchi ; export function PrepareAmerican ; var i , k , un , tmp , vehs , veh , others ; begin
 562: LD_INT 0
 564: PPUSH
 565: PPUSH
 566: PPUSH
 567: PPUSH
 568: PPUSH
 569: PPUSH
 570: PPUSH
 571: PPUSH
// uc_side := 4 ;
 572: LD_ADDR_OWVAR 20
 576: PUSH
 577: LD_INT 4
 579: ST_TO_ADDR
// uc_nation := 1 ;
 580: LD_ADDR_OWVAR 21
 584: PUSH
 585: LD_INT 1
 587: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
 588: LD_ADDR_EXP 30
 592: PUSH
 593: LD_STRING Powell
 595: PPUSH
 596: LD_INT 0
 598: PPUSH
 599: LD_STRING 
 601: PPUSH
 602: CALL 47318 0 3
 606: ST_TO_ADDR
// uc_side := 1 ;
 607: LD_ADDR_OWVAR 20
 611: PUSH
 612: LD_INT 1
 614: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , mission_prefix_prev ) ;
 615: LD_ADDR_EXP 21
 619: PUSH
 620: LD_STRING JMM
 622: PPUSH
 623: LD_EXP 1
 627: NOT
 628: PPUSH
 629: LD_EXP 4
 633: PPUSH
 634: CALL 47318 0 3
 638: ST_TO_ADDR
// if GetClass ( JMM ) > 4 then
 639: LD_EXP 21
 643: PPUSH
 644: CALL_OW 257
 648: PUSH
 649: LD_INT 4
 651: GREATER
 652: IFFALSE 666
// SetClass ( JMM , 1 ) ;
 654: LD_EXP 21
 658: PPUSH
 659: LD_INT 1
 661: PPUSH
 662: CALL_OW 336
// Lisa := PrepareUnit ( Lisa , ( not debug ) , mission_prefix_prev ) ;
 666: LD_ADDR_EXP 22
 670: PUSH
 671: LD_STRING Lisa
 673: PPUSH
 674: LD_EXP 1
 678: NOT
 679: PPUSH
 680: LD_EXP 4
 684: PPUSH
 685: CALL 47318 0 3
 689: ST_TO_ADDR
// if not Lisa then
 690: LD_EXP 22
 694: NOT
 695: IFFALSE 710
// Lisa := CreateCharacter ( 10_Lisa ) ;
 697: LD_ADDR_EXP 22
 701: PUSH
 702: LD_STRING 10_Lisa
 704: PPUSH
 705: CALL_OW 34
 709: ST_TO_ADDR
// if not Lisa then
 710: LD_EXP 22
 714: NOT
 715: IFFALSE 730
// Lisa := CreateCharacter ( 09_Lisa ) ;
 717: LD_ADDR_EXP 22
 721: PUSH
 722: LD_STRING 09_Lisa
 724: PPUSH
 725: CALL_OW 34
 729: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , mission_prefix_prev ) ;
 730: LD_ADDR_EXP 31
 734: PUSH
 735: LD_STRING Cornel
 737: PPUSH
 738: LD_EXP 1
 742: NOT
 743: PPUSH
 744: LD_EXP 4
 748: PPUSH
 749: CALL 47318 0 3
 753: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , mission_prefix_prev ) ;
 754: LD_ADDR_EXP 23
 758: PUSH
 759: LD_STRING Donaldson
 761: PPUSH
 762: LD_EXP 1
 766: NOT
 767: PPUSH
 768: LD_EXP 4
 772: PPUSH
 773: CALL 47318 0 3
 777: ST_TO_ADDR
// if not Donaldson then
 778: LD_EXP 23
 782: NOT
 783: IFFALSE 798
// Donaldson := CreateCharacter ( 10_Donaldson ) ;
 785: LD_ADDR_EXP 23
 789: PUSH
 790: LD_STRING 10_Donaldson
 792: PPUSH
 793: CALL_OW 34
 797: ST_TO_ADDR
// if not Donaldson then
 798: LD_EXP 23
 802: NOT
 803: IFFALSE 818
// Donaldson := CreateCharacter ( 09_Donaldson ) ;
 805: LD_ADDR_EXP 23
 809: PUSH
 810: LD_STRING 09_Donaldson
 812: PPUSH
 813: CALL_OW 34
 817: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , mission_prefix_prev ) ;
 818: LD_ADDR_EXP 24
 822: PUSH
 823: LD_STRING Bobby
 825: PPUSH
 826: LD_EXP 1
 830: NOT
 831: PPUSH
 832: LD_EXP 4
 836: PPUSH
 837: CALL 47318 0 3
 841: ST_TO_ADDR
// if not Bobby then
 842: LD_EXP 24
 846: NOT
 847: IFFALSE 862
// Bobby := CreateCharacter ( 10_Bobby ) ;
 849: LD_ADDR_EXP 24
 853: PUSH
 854: LD_STRING 10_Bobby
 856: PPUSH
 857: CALL_OW 34
 861: ST_TO_ADDR
// if not Bobby then
 862: LD_EXP 24
 866: NOT
 867: IFFALSE 882
// Bobby := CreateCharacter ( 09_Bobby ) ;
 869: LD_ADDR_EXP 24
 873: PUSH
 874: LD_STRING 09_Bobby
 876: PPUSH
 877: CALL_OW 34
 881: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , mission_prefix_prev ) ;
 882: LD_ADDR_EXP 25
 886: PUSH
 887: LD_STRING Cyrus
 889: PPUSH
 890: LD_EXP 1
 894: NOT
 895: PPUSH
 896: LD_EXP 4
 900: PPUSH
 901: CALL 47318 0 3
 905: ST_TO_ADDR
// if not Cyrus then
 906: LD_EXP 25
 910: NOT
 911: IFFALSE 926
// Cyrus := CreateCharacter ( 10_Cyrus ) ;
 913: LD_ADDR_EXP 25
 917: PUSH
 918: LD_STRING 10_Cyrus
 920: PPUSH
 921: CALL_OW 34
 925: ST_TO_ADDR
// if not Cyrus then
 926: LD_EXP 25
 930: NOT
 931: IFFALSE 946
// Cyrus := CreateCharacter ( 09_Cyrus ) ;
 933: LD_ADDR_EXP 25
 937: PUSH
 938: LD_STRING 09_Cyrus
 940: PPUSH
 941: CALL_OW 34
 945: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , mission_prefix_prev ) ;
 946: LD_ADDR_EXP 26
 950: PUSH
 951: LD_STRING Denis
 953: PPUSH
 954: LD_EXP 1
 958: NOT
 959: PPUSH
 960: LD_EXP 4
 964: PPUSH
 965: CALL 47318 0 3
 969: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , mission_prefix_prev ) ;
 970: LD_ADDR_EXP 27
 974: PUSH
 975: LD_STRING Brown
 977: PPUSH
 978: LD_EXP 1
 982: NOT
 983: PPUSH
 984: LD_EXP 4
 988: PPUSH
 989: CALL 47318 0 3
 993: ST_TO_ADDR
// if not Brown then
 994: LD_EXP 27
 998: NOT
 999: IFFALSE 1014
// Brown := CreateCharacter ( 10_Brown ) ;
1001: LD_ADDR_EXP 27
1005: PUSH
1006: LD_STRING 10_Brown
1008: PPUSH
1009: CALL_OW 34
1013: ST_TO_ADDR
// if not Brown then
1014: LD_EXP 27
1018: NOT
1019: IFFALSE 1034
// Brown := CreateCharacter ( 08_Brown ) ;
1021: LD_ADDR_EXP 27
1025: PUSH
1026: LD_STRING 08_Brown
1028: PPUSH
1029: CALL_OW 34
1033: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , mission_prefix_prev ) ;
1034: LD_ADDR_EXP 28
1038: PUSH
1039: LD_STRING Gladstone
1041: PPUSH
1042: LD_EXP 1
1046: NOT
1047: PPUSH
1048: LD_EXP 4
1052: PPUSH
1053: CALL 47318 0 3
1057: ST_TO_ADDR
// if not Gladstone then
1058: LD_EXP 28
1062: NOT
1063: IFFALSE 1078
// Gladstone := CreateCharacter ( 10_Gladstone ) ;
1065: LD_ADDR_EXP 28
1069: PUSH
1070: LD_STRING 10_Gladstone
1072: PPUSH
1073: CALL_OW 34
1077: ST_TO_ADDR
// if not Gladstone then
1078: LD_EXP 28
1082: NOT
1083: IFFALSE 1098
// Gladstone := CreateCharacter ( 08_Gladstone ) ;
1085: LD_ADDR_EXP 28
1089: PUSH
1090: LD_STRING 08_Gladstone
1092: PPUSH
1093: CALL_OW 34
1097: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , mission_prefix_prev ) ;
1098: LD_ADDR_EXP 29
1102: PUSH
1103: LD_STRING Houten
1105: PPUSH
1106: LD_EXP 1
1110: NOT
1111: PPUSH
1112: LD_EXP 4
1116: PPUSH
1117: CALL 47318 0 3
1121: ST_TO_ADDR
// if not Houten then
1122: LD_EXP 29
1126: NOT
1127: IFFALSE 1142
// Houten := CreateCharacter ( 10_Houten ) ;
1129: LD_ADDR_EXP 29
1133: PUSH
1134: LD_STRING 10_Houten
1136: PPUSH
1137: CALL_OW 34
1141: ST_TO_ADDR
// if not Houten then
1142: LD_EXP 29
1146: NOT
1147: IFFALSE 1162
// Houten := CreateCharacter ( 09_Houten ) ;
1149: LD_ADDR_EXP 29
1153: PUSH
1154: LD_STRING 09_Houten
1156: PPUSH
1157: CALL_OW 34
1161: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , ( not debug ) , mission_prefix_prev ) ;
1162: LD_ADDR_EXP 31
1166: PUSH
1167: LD_STRING Cornell
1169: PPUSH
1170: LD_EXP 1
1174: NOT
1175: PPUSH
1176: LD_EXP 4
1180: PPUSH
1181: CALL 47318 0 3
1185: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , mission_prefix_prev ) ;
1186: LD_ADDR_EXP 32
1190: PUSH
1191: LD_STRING Gary
1193: PPUSH
1194: LD_EXP 1
1198: NOT
1199: PPUSH
1200: LD_EXP 4
1204: PPUSH
1205: CALL 47318 0 3
1209: ST_TO_ADDR
// if not Gary then
1210: LD_EXP 32
1214: NOT
1215: IFFALSE 1230
// Gary := CreateCharacter ( 10_Gary ) ;
1217: LD_ADDR_EXP 32
1221: PUSH
1222: LD_STRING 10_Gary
1224: PPUSH
1225: CALL_OW 34
1229: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , mission_prefix_prev ) ;
1230: LD_ADDR_EXP 33
1234: PUSH
1235: LD_STRING Frank
1237: PPUSH
1238: LD_EXP 1
1242: NOT
1243: PPUSH
1244: LD_EXP 4
1248: PPUSH
1249: CALL 47318 0 3
1253: ST_TO_ADDR
// if not Frank then
1254: LD_EXP 33
1258: NOT
1259: IFFALSE 1274
// Frank := CreateCharacter ( 08_Frank ) ;
1261: LD_ADDR_EXP 33
1265: PUSH
1266: LD_STRING 08_Frank
1268: PPUSH
1269: CALL_OW 34
1273: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , mission_prefix_prev ) ;
1274: LD_ADDR_EXP 34
1278: PUSH
1279: LD_STRING Kikuchi
1281: PPUSH
1282: LD_EXP 1
1286: NOT
1287: PPUSH
1288: LD_EXP 4
1292: PPUSH
1293: CALL 47318 0 3
1297: ST_TO_ADDR
// if not Kikuchi then
1298: LD_EXP 34
1302: NOT
1303: IFFALSE 1318
// Kikuchi := CreateCharacter ( 08_Kikuchi ) ;
1305: LD_ADDR_EXP 34
1309: PUSH
1310: LD_STRING 08_Kikuchi
1312: PPUSH
1313: CALL_OW 34
1317: ST_TO_ADDR
// tmp := [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1318: LD_ADDR_VAR 0 5
1322: PUSH
1323: LD_EXP 22
1327: PUSH
1328: LD_EXP 23
1332: PUSH
1333: LD_EXP 24
1337: PUSH
1338: LD_EXP 25
1342: PUSH
1343: LD_EXP 26
1347: PUSH
1348: LD_EXP 27
1352: PUSH
1353: LD_EXP 28
1357: PUSH
1358: LD_EXP 29
1362: PUSH
1363: LD_EXP 31
1367: PUSH
1368: LD_EXP 32
1372: PUSH
1373: LD_EXP 33
1377: PUSH
1378: LD_EXP 34
1382: PUSH
1383: EMPTY
1384: LIST
1385: LIST
1386: LIST
1387: LIST
1388: LIST
1389: LIST
1390: LIST
1391: LIST
1392: LIST
1393: LIST
1394: LIST
1395: LIST
1396: ST_TO_ADDR
// tmp := tmp diff 0 ;
1397: LD_ADDR_VAR 0 5
1401: PUSH
1402: LD_VAR 0 5
1406: PUSH
1407: LD_INT 0
1409: DIFF
1410: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10_lock ) ;
1411: LD_ADDR_VAR 0 5
1415: PUSH
1416: LD_VAR 0 5
1420: PUSH
1421: LD_STRING 10_lock
1423: PPUSH
1424: CALL_OW 31
1428: UNION
1429: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10c_lock ) ;
1430: LD_ADDR_VAR 0 5
1434: PUSH
1435: LD_VAR 0 5
1439: PUSH
1440: LD_STRING 10c_lock
1442: PPUSH
1443: CALL_OW 31
1447: UNION
1448: ST_TO_ADDR
// DeleteCharacters ( 10_lock ) ;
1449: LD_STRING 10_lock
1451: PPUSH
1452: CALL_OW 40
// DeleteCharacters ( 10c_lock ) ;
1456: LD_STRING 10c_lock
1458: PPUSH
1459: CALL_OW 40
// for i in tmp do
1463: LD_ADDR_VAR 0 2
1467: PUSH
1468: LD_VAR 0 5
1472: PUSH
1473: FOR_IN
1474: IFFALSE 1512
// if GetClass ( i ) in [ class_mortar , class_engineer ] then
1476: LD_VAR 0 2
1480: PPUSH
1481: CALL_OW 257
1485: PUSH
1486: LD_INT 8
1488: PUSH
1489: LD_INT 2
1491: PUSH
1492: EMPTY
1493: LIST
1494: LIST
1495: IN
1496: IFFALSE 1510
// SetClass ( i , class_soldier ) ;
1498: LD_VAR 0 2
1502: PPUSH
1503: LD_INT 1
1505: PPUSH
1506: CALL_OW 336
1510: GO 1473
1512: POP
1513: POP
// if tmp < 12 then
1514: LD_VAR 0 5
1518: PUSH
1519: LD_INT 12
1521: LESS
1522: IFFALSE 1616
// begin k := 16 - tmp ;
1524: LD_ADDR_VAR 0 3
1528: PUSH
1529: LD_INT 16
1531: PUSH
1532: LD_VAR 0 5
1536: MINUS
1537: ST_TO_ADDR
// for i = 1 to k do
1538: LD_ADDR_VAR 0 2
1542: PUSH
1543: DOUBLE
1544: LD_INT 1
1546: DEC
1547: ST_TO_ADDR
1548: LD_VAR 0 3
1552: PUSH
1553: FOR_TO
1554: IFFALSE 1614
// begin PrepareHuman ( false , [ 1 , 1 , 3 , 4 ] [ rand ( 1 , 4 ) ] , 6 ) ;
1556: LD_INT 0
1558: PPUSH
1559: LD_INT 1
1561: PUSH
1562: LD_INT 1
1564: PUSH
1565: LD_INT 3
1567: PUSH
1568: LD_INT 4
1570: PUSH
1571: EMPTY
1572: LIST
1573: LIST
1574: LIST
1575: LIST
1576: PUSH
1577: LD_INT 1
1579: PPUSH
1580: LD_INT 4
1582: PPUSH
1583: CALL_OW 12
1587: ARRAY
1588: PPUSH
1589: LD_INT 6
1591: PPUSH
1592: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
1596: LD_ADDR_VAR 0 5
1600: PUSH
1601: LD_VAR 0 5
1605: PUSH
1606: CALL_OW 44
1610: ADD
1611: ST_TO_ADDR
// end ;
1612: GO 1553
1614: POP
1615: POP
// end ; selected := CharacterSelection ( 1 , 12 , 12 , [ sel_change_class , JMM , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp ^ [ sel_dont_change_class , sel_not_changeable , Powell ] , [ [ class_soldier , 4 ] , [ class_mechanic , 0 , 5 ] , [ class_scientistic , 0 , 3 ] , [ class_sniper , 0 , 2 ] ] ) ;
1616: LD_ADDR_EXP 19
1620: PUSH
1621: LD_STRING 1
1623: PPUSH
1624: LD_INT 12
1626: PPUSH
1627: LD_INT 12
1629: PPUSH
1630: LD_INT -5
1632: PUSH
1633: LD_EXP 21
1637: PUSH
1638: LD_INT -2
1640: PUSH
1641: LD_INT -3
1643: PUSH
1644: LD_INT -5
1646: PUSH
1647: EMPTY
1648: LIST
1649: LIST
1650: LIST
1651: LIST
1652: LIST
1653: PUSH
1654: LD_VAR 0 5
1658: ADD
1659: PUSH
1660: LD_INT -6
1662: PUSH
1663: LD_INT -4
1665: PUSH
1666: LD_EXP 30
1670: PUSH
1671: EMPTY
1672: LIST
1673: LIST
1674: LIST
1675: ADD
1676: PPUSH
1677: LD_INT 1
1679: PUSH
1680: LD_INT 4
1682: PUSH
1683: EMPTY
1684: LIST
1685: LIST
1686: PUSH
1687: LD_INT 3
1689: PUSH
1690: LD_INT 0
1692: PUSH
1693: LD_INT 5
1695: PUSH
1696: EMPTY
1697: LIST
1698: LIST
1699: LIST
1700: PUSH
1701: LD_INT 4
1703: PUSH
1704: LD_INT 0
1706: PUSH
1707: LD_INT 3
1709: PUSH
1710: EMPTY
1711: LIST
1712: LIST
1713: LIST
1714: PUSH
1715: LD_INT 5
1717: PUSH
1718: LD_INT 0
1720: PUSH
1721: LD_INT 2
1723: PUSH
1724: EMPTY
1725: LIST
1726: LIST
1727: LIST
1728: PUSH
1729: EMPTY
1730: LIST
1731: LIST
1732: LIST
1733: LIST
1734: PPUSH
1735: CALL_OW 42
1739: ST_TO_ADDR
// others := tmp diff selected ;
1740: LD_ADDR_VAR 0 8
1744: PUSH
1745: LD_VAR 0 5
1749: PUSH
1750: LD_EXP 19
1754: DIFF
1755: ST_TO_ADDR
// others := others diff [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1756: LD_ADDR_VAR 0 8
1760: PUSH
1761: LD_VAR 0 8
1765: PUSH
1766: LD_EXP 22
1770: PUSH
1771: LD_EXP 23
1775: PUSH
1776: LD_EXP 24
1780: PUSH
1781: LD_EXP 25
1785: PUSH
1786: LD_EXP 26
1790: PUSH
1791: LD_EXP 27
1795: PUSH
1796: LD_EXP 28
1800: PUSH
1801: LD_EXP 29
1805: PUSH
1806: LD_EXP 31
1810: PUSH
1811: LD_EXP 32
1815: PUSH
1816: LD_EXP 33
1820: PUSH
1821: LD_EXP 34
1825: PUSH
1826: EMPTY
1827: LIST
1828: LIST
1829: LIST
1830: LIST
1831: LIST
1832: LIST
1833: LIST
1834: LIST
1835: LIST
1836: LIST
1837: LIST
1838: LIST
1839: DIFF
1840: ST_TO_ADDR
// if others then
1841: LD_VAR 0 8
1845: IFFALSE 1859
// SaveCharacters ( others , 11_others ) ;
1847: LD_VAR 0 8
1851: PPUSH
1852: LD_STRING 11_others
1854: PPUSH
1855: CALL_OW 38
// vehs := [ [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun ] , [ us_medium_wheeled , engine_solar , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_medium_wheeled , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_solar , control_manual , us_rocket_launcher ] ] ;
1859: LD_ADDR_VAR 0 6
1863: PUSH
1864: LD_INT 3
1866: PUSH
1867: LD_INT 1
1869: PUSH
1870: LD_INT 1
1872: PUSH
1873: LD_INT 4
1875: PUSH
1876: EMPTY
1877: LIST
1878: LIST
1879: LIST
1880: LIST
1881: PUSH
1882: LD_INT 2
1884: PUSH
1885: LD_INT 2
1887: PUSH
1888: LD_INT 1
1890: PUSH
1891: LD_INT 5
1893: PUSH
1894: EMPTY
1895: LIST
1896: LIST
1897: LIST
1898: LIST
1899: PUSH
1900: LD_INT 4
1902: PUSH
1903: LD_INT 1
1905: PUSH
1906: LD_INT 1
1908: PUSH
1909: LD_INT 5
1911: PUSH
1912: EMPTY
1913: LIST
1914: LIST
1915: LIST
1916: LIST
1917: PUSH
1918: LD_INT 2
1920: PUSH
1921: LD_INT 1
1923: PUSH
1924: LD_INT 1
1926: PUSH
1927: LD_INT 7
1929: PUSH
1930: EMPTY
1931: LIST
1932: LIST
1933: LIST
1934: LIST
1935: PUSH
1936: LD_INT 3
1938: PUSH
1939: LD_INT 2
1941: PUSH
1942: LD_INT 1
1944: PUSH
1945: LD_INT 7
1947: PUSH
1948: EMPTY
1949: LIST
1950: LIST
1951: LIST
1952: LIST
1953: PUSH
1954: EMPTY
1955: LIST
1956: LIST
1957: LIST
1958: LIST
1959: LIST
1960: ST_TO_ADDR
// for i in JMM ^ selected do
1961: LD_ADDR_VAR 0 2
1965: PUSH
1966: LD_EXP 21
1970: PUSH
1971: LD_EXP 19
1975: ADD
1976: PUSH
1977: FOR_IN
1978: IFFALSE 2167
// begin if GetClass ( i ) = 3 then
1980: LD_VAR 0 2
1984: PPUSH
1985: CALL_OW 257
1989: PUSH
1990: LD_INT 3
1992: EQUAL
1993: IFFALSE 2150
// begin vc_chassis := vehs [ 1 ] [ 1 ] ;
1995: LD_ADDR_OWVAR 37
1999: PUSH
2000: LD_VAR 0 6
2004: PUSH
2005: LD_INT 1
2007: ARRAY
2008: PUSH
2009: LD_INT 1
2011: ARRAY
2012: ST_TO_ADDR
// vc_engine := vehs [ 1 ] [ 2 ] ;
2013: LD_ADDR_OWVAR 39
2017: PUSH
2018: LD_VAR 0 6
2022: PUSH
2023: LD_INT 1
2025: ARRAY
2026: PUSH
2027: LD_INT 2
2029: ARRAY
2030: ST_TO_ADDR
// vc_control := vehs [ 1 ] [ 3 ] ;
2031: LD_ADDR_OWVAR 38
2035: PUSH
2036: LD_VAR 0 6
2040: PUSH
2041: LD_INT 1
2043: ARRAY
2044: PUSH
2045: LD_INT 3
2047: ARRAY
2048: ST_TO_ADDR
// vc_weapon := vehs [ 1 ] [ 4 ] ;
2049: LD_ADDR_OWVAR 40
2053: PUSH
2054: LD_VAR 0 6
2058: PUSH
2059: LD_INT 1
2061: ARRAY
2062: PUSH
2063: LD_INT 4
2065: ARRAY
2066: ST_TO_ADDR
// vehs := Delete ( vehs , 1 ) ;
2067: LD_ADDR_VAR 0 6
2071: PUSH
2072: LD_VAR 0 6
2076: PPUSH
2077: LD_INT 1
2079: PPUSH
2080: CALL_OW 3
2084: ST_TO_ADDR
// veh := CreateVehicle ;
2085: LD_ADDR_VAR 0 7
2089: PUSH
2090: CALL_OW 45
2094: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2095: LD_VAR 0 7
2099: PPUSH
2100: LD_INT 8
2102: PPUSH
2103: LD_INT 0
2105: PPUSH
2106: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
2110: LD_VAR 0 2
2114: PPUSH
2115: LD_VAR 0 7
2119: PPUSH
2120: CALL_OW 52
// if i = JMM then
2124: LD_VAR 0 2
2128: PUSH
2129: LD_EXP 21
2133: EQUAL
2134: IFFALSE 2148
// SetMark ( veh , 1 ) ;
2136: LD_VAR 0 7
2140: PPUSH
2141: LD_INT 1
2143: PPUSH
2144: CALL_OW 242
// end else
2148: GO 2165
// PlaceUnitArea ( i , am_hum_start , false ) ;
2150: LD_VAR 0 2
2154: PPUSH
2155: LD_INT 9
2157: PPUSH
2158: LD_INT 0
2160: PPUSH
2161: CALL_OW 49
// end ;
2165: GO 1977
2167: POP
2168: POP
// vc_chassis := us_medium_tracked ;
2169: LD_ADDR_OWVAR 37
2173: PUSH
2174: LD_INT 3
2176: ST_TO_ADDR
// vc_engine := engine_solar ;
2177: LD_ADDR_OWVAR 39
2181: PUSH
2182: LD_INT 2
2184: ST_TO_ADDR
// vc_control := control_computer ;
2185: LD_ADDR_OWVAR 38
2189: PUSH
2190: LD_INT 3
2192: ST_TO_ADDR
// vc_weapon := us_radar ;
2193: LD_ADDR_OWVAR 40
2197: PUSH
2198: LD_INT 11
2200: ST_TO_ADDR
// veh := CreateVehicle ;
2201: LD_ADDR_VAR 0 7
2205: PUSH
2206: CALL_OW 45
2210: ST_TO_ADDR
// PlaceUnitXY ( veh , 87 , 142 , false ) ;
2211: LD_VAR 0 7
2215: PPUSH
2216: LD_INT 87
2218: PPUSH
2219: LD_INT 142
2221: PPUSH
2222: LD_INT 0
2224: PPUSH
2225: CALL_OW 48
// end ; end_of_file
2229: LD_VAR 0 1
2233: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_north_2 , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_kamikadze , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ; var i , d , un , skill , tmp ; begin
2234: LD_INT 0
2236: PPUSH
2237: PPUSH
2238: PPUSH
2239: PPUSH
2240: PPUSH
2241: PPUSH
// if Difficulty = 1 then
2242: LD_OWVAR 67
2246: PUSH
2247: LD_INT 1
2249: EQUAL
2250: IFFALSE 2347
// begin tmp := [ [ 129 , 45 ] , [ 143 , 58 ] , [ 184 , 113 ] , [ 163 , 107 ] ] ;
2252: LD_ADDR_VAR 0 6
2256: PUSH
2257: LD_INT 129
2259: PUSH
2260: LD_INT 45
2262: PUSH
2263: EMPTY
2264: LIST
2265: LIST
2266: PUSH
2267: LD_INT 143
2269: PUSH
2270: LD_INT 58
2272: PUSH
2273: EMPTY
2274: LIST
2275: LIST
2276: PUSH
2277: LD_INT 184
2279: PUSH
2280: LD_INT 113
2282: PUSH
2283: EMPTY
2284: LIST
2285: LIST
2286: PUSH
2287: LD_INT 163
2289: PUSH
2290: LD_INT 107
2292: PUSH
2293: EMPTY
2294: LIST
2295: LIST
2296: PUSH
2297: EMPTY
2298: LIST
2299: LIST
2300: LIST
2301: LIST
2302: ST_TO_ADDR
// for i in tmp do
2303: LD_ADDR_VAR 0 2
2307: PUSH
2308: LD_VAR 0 6
2312: PUSH
2313: FOR_IN
2314: IFFALSE 2345
// RemoveUnit ( HexInfo ( i [ 1 ] , i [ 2 ] ) ) ;
2316: LD_VAR 0 2
2320: PUSH
2321: LD_INT 1
2323: ARRAY
2324: PPUSH
2325: LD_VAR 0 2
2329: PUSH
2330: LD_INT 2
2332: ARRAY
2333: PPUSH
2334: CALL_OW 428
2338: PPUSH
2339: CALL_OW 64
2343: GO 2313
2345: POP
2346: POP
// end ; for i in FilterAllUnits ( [ f_type , unit_building ] ) do
2347: LD_ADDR_VAR 0 2
2351: PUSH
2352: LD_INT 21
2354: PUSH
2355: LD_INT 3
2357: PUSH
2358: EMPTY
2359: LIST
2360: LIST
2361: PPUSH
2362: CALL_OW 69
2366: PUSH
2367: FOR_IN
2368: IFFALSE 2401
// SetBLevel ( i , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
2370: LD_VAR 0 2
2374: PPUSH
2375: LD_INT 5
2377: PUSH
2378: LD_INT 6
2380: PUSH
2381: LD_INT 7
2383: PUSH
2384: EMPTY
2385: LIST
2386: LIST
2387: LIST
2388: PUSH
2389: LD_OWVAR 67
2393: ARRAY
2394: PPUSH
2395: CALL_OW 241
2399: GO 2367
2401: POP
2402: POP
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
2403: LD_ADDR_VAR 0 5
2407: PUSH
2408: LD_INT 5
2410: PUSH
2411: LD_INT 6
2413: PUSH
2414: LD_INT 7
2416: PUSH
2417: EMPTY
2418: LIST
2419: LIST
2420: LIST
2421: PUSH
2422: LD_OWVAR 67
2426: ARRAY
2427: ST_TO_ADDR
// uc_side := 2 ;
2428: LD_ADDR_OWVAR 20
2432: PUSH
2433: LD_INT 2
2435: ST_TO_ADDR
// uc_nation := 2 ;
2436: LD_ADDR_OWVAR 21
2440: PUSH
2441: LD_INT 2
2443: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
2444: LD_ADDR_OWVAR 37
2448: PUSH
2449: LD_INT 14
2451: ST_TO_ADDR
// vc_engine := engine_siberite ;
2452: LD_ADDR_OWVAR 39
2456: PUSH
2457: LD_INT 3
2459: ST_TO_ADDR
// vc_control := control_manual ;
2460: LD_ADDR_OWVAR 38
2464: PUSH
2465: LD_INT 1
2467: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
2468: LD_ADDR_OWVAR 40
2472: PUSH
2473: LD_INT 31
2475: ST_TO_ADDR
// for i = 1 to 3 do
2476: LD_ADDR_VAR 0 2
2480: PUSH
2481: DOUBLE
2482: LD_INT 1
2484: DEC
2485: ST_TO_ADDR
2486: LD_INT 3
2488: PUSH
2489: FOR_TO
2490: IFFALSE 2574
// begin PrepareHuman ( false , class_mechanic , skill ) ;
2492: LD_INT 0
2494: PPUSH
2495: LD_INT 3
2497: PPUSH
2498: LD_VAR 0 5
2502: PPUSH
2503: CALL_OW 380
// un := CreateVehicle ;
2507: LD_ADDR_VAR 0 4
2511: PUSH
2512: CALL_OW 45
2516: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
2517: LD_VAR 0 4
2521: PPUSH
2522: LD_INT 0
2524: PPUSH
2525: LD_INT 5
2527: PPUSH
2528: CALL_OW 12
2532: PPUSH
2533: CALL_OW 233
// PlaceUnitXYR ( un , 156 , 15 , 6 , false ) ;
2537: LD_VAR 0 4
2541: PPUSH
2542: LD_INT 156
2544: PPUSH
2545: LD_INT 15
2547: PPUSH
2548: LD_INT 6
2550: PPUSH
2551: LD_INT 0
2553: PPUSH
2554: CALL_OW 50
// PlaceHumanInUnit ( CreateHuman , un ) ;
2558: CALL_OW 44
2562: PPUSH
2563: LD_VAR 0 4
2567: PPUSH
2568: CALL_OW 52
// end ;
2572: GO 2489
2574: POP
2575: POP
// ar_force_north := PrepareBase ( ar_dep_n , base_north , dammam , skill , [ 10000 , 1000 , 300 ] , [ - 1 , [ 3 , 4 , 5 ] [ Difficulty ] , - 1 , 4 ] ) ;
2576: LD_ADDR_EXP 37
2580: PUSH
2581: LD_INT 94
2583: PPUSH
2584: LD_INT 28
2586: PPUSH
2587: LD_STRING dammam
2589: PPUSH
2590: LD_VAR 0 5
2594: PPUSH
2595: LD_INT 10000
2597: PUSH
2598: LD_INT 1000
2600: PUSH
2601: LD_INT 300
2603: PUSH
2604: EMPTY
2605: LIST
2606: LIST
2607: LIST
2608: PPUSH
2609: LD_INT 1
2611: NEG
2612: PUSH
2613: LD_INT 3
2615: PUSH
2616: LD_INT 4
2618: PUSH
2619: LD_INT 5
2621: PUSH
2622: EMPTY
2623: LIST
2624: LIST
2625: LIST
2626: PUSH
2627: LD_OWVAR 67
2631: ARRAY
2632: PUSH
2633: LD_INT 1
2635: NEG
2636: PUSH
2637: LD_INT 4
2639: PUSH
2640: EMPTY
2641: LIST
2642: LIST
2643: LIST
2644: LIST
2645: PPUSH
2646: CALL 57842 0 6
2650: ST_TO_ADDR
// ar_force_north := ar_force_north union PrepareBase ( ar_dep_n2 , base_north_2 ,  , skill , [ 500 , 60 , 0 ] , [ - 1 , [ 3 , 3 , 4 ] [ Difficulty ] , 2 , 0 ] ) ;
2651: LD_ADDR_EXP 37
2655: PUSH
2656: LD_EXP 37
2660: PUSH
2661: LD_INT 122
2663: PPUSH
2664: LD_INT 25
2666: PPUSH
2667: LD_STRING 
2669: PPUSH
2670: LD_VAR 0 5
2674: PPUSH
2675: LD_INT 500
2677: PUSH
2678: LD_INT 60
2680: PUSH
2681: LD_INT 0
2683: PUSH
2684: EMPTY
2685: LIST
2686: LIST
2687: LIST
2688: PPUSH
2689: LD_INT 1
2691: NEG
2692: PUSH
2693: LD_INT 3
2695: PUSH
2696: LD_INT 3
2698: PUSH
2699: LD_INT 4
2701: PUSH
2702: EMPTY
2703: LIST
2704: LIST
2705: LIST
2706: PUSH
2707: LD_OWVAR 67
2711: ARRAY
2712: PUSH
2713: LD_INT 2
2715: PUSH
2716: LD_INT 0
2718: PUSH
2719: EMPTY
2720: LIST
2721: LIST
2722: LIST
2723: LIST
2724: PPUSH
2725: CALL 57842 0 6
2729: UNION
2730: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , base_west , jeddah , skill , [ 700 , 300 , 10 ] , [ - 1 , 5 , 3 , 2 ] ) ;
2731: LD_ADDR_EXP 35
2735: PUSH
2736: LD_INT 45
2738: PPUSH
2739: LD_INT 24
2741: PPUSH
2742: LD_STRING jeddah
2744: PPUSH
2745: LD_VAR 0 5
2749: PPUSH
2750: LD_INT 700
2752: PUSH
2753: LD_INT 300
2755: PUSH
2756: LD_INT 10
2758: PUSH
2759: EMPTY
2760: LIST
2761: LIST
2762: LIST
2763: PPUSH
2764: LD_INT 1
2766: NEG
2767: PUSH
2768: LD_INT 5
2770: PUSH
2771: LD_INT 3
2773: PUSH
2774: LD_INT 2
2776: PUSH
2777: EMPTY
2778: LIST
2779: LIST
2780: LIST
2781: LIST
2782: PPUSH
2783: CALL 57842 0 6
2787: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , base_south , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
2788: LD_ADDR_EXP 36
2792: PUSH
2793: LD_INT 7
2795: PPUSH
2796: LD_INT 27
2798: PPUSH
2799: LD_STRING riyadh
2801: PPUSH
2802: LD_VAR 0 5
2806: PPUSH
2807: LD_INT 500
2809: PUSH
2810: LD_INT 60
2812: PUSH
2813: LD_INT 0
2815: PUSH
2816: EMPTY
2817: LIST
2818: LIST
2819: LIST
2820: PPUSH
2821: LD_INT 4
2823: PUSH
2824: LD_INT 2
2826: PUSH
2827: LD_INT 3
2829: PUSH
2830: LD_INT 1
2832: PUSH
2833: EMPTY
2834: LIST
2835: LIST
2836: LIST
2837: LIST
2838: PPUSH
2839: CALL 57842 0 6
2843: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e , base_east ,  , skill , [ 500 , 50 , 0 ] , [ 12 , 3 , 3 , 2 ] ) ;
2844: LD_ADDR_EXP 39
2848: PUSH
2849: LD_INT 204
2851: PPUSH
2852: LD_INT 26
2854: PPUSH
2855: LD_STRING 
2857: PPUSH
2858: LD_VAR 0 5
2862: PPUSH
2863: LD_INT 500
2865: PUSH
2866: LD_INT 50
2868: PUSH
2869: LD_INT 0
2871: PUSH
2872: EMPTY
2873: LIST
2874: LIST
2875: LIST
2876: PPUSH
2877: LD_INT 12
2879: PUSH
2880: LD_INT 3
2882: PUSH
2883: LD_INT 3
2885: PUSH
2886: LD_INT 2
2888: PUSH
2889: EMPTY
2890: LIST
2891: LIST
2892: LIST
2893: LIST
2894: PPUSH
2895: CALL 57842 0 6
2899: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east ] ;
2900: LD_ADDR_EXP 50
2904: PUSH
2905: LD_EXP 37
2909: PUSH
2910: LD_EXP 35
2914: PUSH
2915: LD_EXP 39
2919: PUSH
2920: EMPTY
2921: LIST
2922: LIST
2923: LIST
2924: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
2925: LD_ADDR_VAR 0 2
2929: PUSH
2930: LD_INT 22
2932: PUSH
2933: LD_INT 2
2935: PUSH
2936: EMPTY
2937: LIST
2938: LIST
2939: PUSH
2940: LD_INT 30
2942: PUSH
2943: LD_INT 31
2945: PUSH
2946: EMPTY
2947: LIST
2948: LIST
2949: PUSH
2950: LD_INT 58
2952: PUSH
2953: EMPTY
2954: LIST
2955: PUSH
2956: EMPTY
2957: LIST
2958: LIST
2959: LIST
2960: PPUSH
2961: CALL_OW 69
2965: PUSH
2966: FOR_IN
2967: IFFALSE 3092
// begin if GetBase ( i ) then
2969: LD_VAR 0 2
2973: PPUSH
2974: CALL_OW 274
2978: IFFALSE 2982
// continue ;
2980: GO 2966
// d := GetDir ( i ) ;
2982: LD_ADDR_VAR 0 3
2986: PUSH
2987: LD_VAR 0 2
2991: PPUSH
2992: CALL_OW 254
2996: ST_TO_ADDR
// if d < 3 then
2997: LD_VAR 0 3
3001: PUSH
3002: LD_INT 3
3004: LESS
3005: IFFALSE 3023
// d := d + 3 else
3007: LD_ADDR_VAR 0 3
3011: PUSH
3012: LD_VAR 0 3
3016: PUSH
3017: LD_INT 3
3019: PLUS
3020: ST_TO_ADDR
3021: GO 3037
// d := d - 3 ;
3023: LD_ADDR_VAR 0 3
3027: PUSH
3028: LD_VAR 0 3
3032: PUSH
3033: LD_INT 3
3035: MINUS
3036: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
3037: LD_INT 0
3039: PPUSH
3040: LD_INT 8
3042: PPUSH
3043: LD_VAR 0 5
3047: PPUSH
3048: CALL_OW 380
// un := CreateHuman ;
3052: LD_ADDR_VAR 0 4
3056: PUSH
3057: CALL_OW 44
3061: ST_TO_ADDR
// SetDir ( un , d ) ;
3062: LD_VAR 0 4
3066: PPUSH
3067: LD_VAR 0 3
3071: PPUSH
3072: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
3076: LD_VAR 0 4
3080: PPUSH
3081: LD_VAR 0 2
3085: PPUSH
3086: CALL_OW 52
// end ;
3090: GO 2966
3092: POP
3093: POP
// if Difficulty > 1 then
3094: LD_OWVAR 67
3098: PUSH
3099: LD_INT 1
3101: GREATER
3102: IFFALSE 3473
// begin ar_kamikadze := [ ] ;
3104: LD_ADDR_EXP 42
3108: PUSH
3109: EMPTY
3110: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
3111: LD_INT 0
3113: PPUSH
3114: LD_INT 1
3116: PPUSH
3117: LD_VAR 0 5
3121: PPUSH
3122: CALL_OW 380
// un := CreateHuman ;
3126: LD_ADDR_VAR 0 4
3130: PUSH
3131: CALL_OW 44
3135: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3136: LD_VAR 0 4
3140: PPUSH
3141: LD_INT 3
3143: PPUSH
3144: CALL_OW 233
// PlaceUnitXY ( un , 23 , 44 , false ) ;
3148: LD_VAR 0 4
3152: PPUSH
3153: LD_INT 23
3155: PPUSH
3156: LD_INT 44
3158: PPUSH
3159: LD_INT 0
3161: PPUSH
3162: CALL_OW 48
// ComCrawl ( un ) ;
3166: LD_VAR 0 4
3170: PPUSH
3171: CALL_OW 137
// un := CreateHuman ;
3175: LD_ADDR_VAR 0 4
3179: PUSH
3180: CALL_OW 44
3184: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3185: LD_VAR 0 4
3189: PPUSH
3190: LD_INT 3
3192: PPUSH
3193: CALL_OW 233
// PlaceUnitXY ( un , 30 , 39 , false ) ;
3197: LD_VAR 0 4
3201: PPUSH
3202: LD_INT 30
3204: PPUSH
3205: LD_INT 39
3207: PPUSH
3208: LD_INT 0
3210: PPUSH
3211: CALL_OW 48
// ComCrawl ( un ) ;
3215: LD_VAR 0 4
3219: PPUSH
3220: CALL_OW 137
// PrepareHuman ( false , 17 , skill ) ;
3224: LD_INT 0
3226: PPUSH
3227: LD_INT 17
3229: PPUSH
3230: LD_VAR 0 5
3234: PPUSH
3235: CALL_OW 380
// un := CreateHuman ;
3239: LD_ADDR_VAR 0 4
3243: PUSH
3244: CALL_OW 44
3248: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3249: LD_VAR 0 4
3253: PPUSH
3254: LD_INT 3
3256: PPUSH
3257: CALL_OW 233
// PlaceUnitXY ( un , 45 , 86 , false ) ;
3261: LD_VAR 0 4
3265: PPUSH
3266: LD_INT 45
3268: PPUSH
3269: LD_INT 86
3271: PPUSH
3272: LD_INT 0
3274: PPUSH
3275: CALL_OW 48
// ComHold ( un ) ;
3279: LD_VAR 0 4
3283: PPUSH
3284: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3288: LD_ADDR_EXP 42
3292: PUSH
3293: LD_EXP 42
3297: PPUSH
3298: LD_EXP 42
3302: PUSH
3303: LD_INT 1
3305: PLUS
3306: PPUSH
3307: LD_VAR 0 4
3311: PPUSH
3312: CALL_OW 1
3316: ST_TO_ADDR
// un := CreateHuman ;
3317: LD_ADDR_VAR 0 4
3321: PUSH
3322: CALL_OW 44
3326: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3327: LD_VAR 0 4
3331: PPUSH
3332: LD_INT 3
3334: PPUSH
3335: CALL_OW 233
// PlaceUnitXY ( un , 60 , 85 , false ) ;
3339: LD_VAR 0 4
3343: PPUSH
3344: LD_INT 60
3346: PPUSH
3347: LD_INT 85
3349: PPUSH
3350: LD_INT 0
3352: PPUSH
3353: CALL_OW 48
// ComHold ( un ) ;
3357: LD_VAR 0 4
3361: PPUSH
3362: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3366: LD_ADDR_EXP 42
3370: PUSH
3371: LD_EXP 42
3375: PPUSH
3376: LD_EXP 42
3380: PUSH
3381: LD_INT 1
3383: PLUS
3384: PPUSH
3385: LD_VAR 0 4
3389: PPUSH
3390: CALL_OW 1
3394: ST_TO_ADDR
// un := CreateHuman ;
3395: LD_ADDR_VAR 0 4
3399: PUSH
3400: CALL_OW 44
3404: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3405: LD_VAR 0 4
3409: PPUSH
3410: LD_INT 3
3412: PPUSH
3413: CALL_OW 233
// PlaceUnitXY ( un , 222 , 166 , false ) ;
3417: LD_VAR 0 4
3421: PPUSH
3422: LD_INT 222
3424: PPUSH
3425: LD_INT 166
3427: PPUSH
3428: LD_INT 0
3430: PPUSH
3431: CALL_OW 48
// ComHold ( un ) ;
3435: LD_VAR 0 4
3439: PPUSH
3440: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3444: LD_ADDR_EXP 42
3448: PUSH
3449: LD_EXP 42
3453: PPUSH
3454: LD_EXP 42
3458: PUSH
3459: LD_INT 1
3461: PLUS
3462: PPUSH
3463: LD_VAR 0 4
3467: PPUSH
3468: CALL_OW 1
3472: ST_TO_ADDR
// end ; ar_force_tmp := [ ] ;
3473: LD_ADDR_EXP 40
3477: PUSH
3478: EMPTY
3479: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
3480: LD_INT 1
3482: PPUSH
3483: LD_INT 1
3485: PPUSH
3486: LD_VAR 0 5
3490: PPUSH
3491: CALL_OW 380
// hc_name := Pavel Grigorovic ;
3495: LD_ADDR_OWVAR 26
3499: PUSH
3500: LD_STRING Pavel Grigorovic
3502: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3503: LD_ADDR_OWVAR 33
3507: PUSH
3508: LD_STRING SecondCharsGal
3510: ST_TO_ADDR
// hc_face_number := 4 ;
3511: LD_ADDR_OWVAR 34
3515: PUSH
3516: LD_INT 4
3518: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
3519: LD_ADDR_EXP 40
3523: PUSH
3524: LD_EXP 40
3528: PPUSH
3529: LD_INT 1
3531: PPUSH
3532: CALL_OW 44
3536: PPUSH
3537: CALL_OW 1
3541: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3542: LD_INT 2
3544: PPUSH
3545: LD_INT 4
3547: PPUSH
3548: LD_INT 2
3550: PPUSH
3551: CALL_OW 380
// hc_name := Lucy Sebel ;
3555: LD_ADDR_OWVAR 26
3559: PUSH
3560: LD_STRING Lucy Sebel
3562: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3563: LD_ADDR_OWVAR 33
3567: PUSH
3568: LD_STRING SecondCharsGal
3570: ST_TO_ADDR
// hc_face_number := 15 ;
3571: LD_ADDR_OWVAR 34
3575: PUSH
3576: LD_INT 15
3578: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
3579: LD_ADDR_EXP 40
3583: PUSH
3584: LD_EXP 40
3588: PPUSH
3589: LD_INT 2
3591: PPUSH
3592: CALL_OW 44
3596: PPUSH
3597: CALL_OW 1
3601: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3602: LD_INT 2
3604: PPUSH
3605: LD_INT 4
3607: PPUSH
3608: LD_INT 2
3610: PPUSH
3611: CALL_OW 380
// hc_gallery :=  ;
3615: LD_ADDR_OWVAR 33
3619: PUSH
3620: LD_STRING 
3622: ST_TO_ADDR
// hc_name :=  ;
3623: LD_ADDR_OWVAR 26
3627: PUSH
3628: LD_STRING 
3630: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
3631: LD_ADDR_EXP 40
3635: PUSH
3636: LD_EXP 40
3640: PPUSH
3641: LD_INT 3
3643: PPUSH
3644: CALL_OW 44
3648: PPUSH
3649: CALL_OW 1
3653: ST_TO_ADDR
// hc_sex := sex_male ;
3654: LD_ADDR_OWVAR 27
3658: PUSH
3659: LD_INT 1
3661: ST_TO_ADDR
// hc_class = 11 ;
3662: LD_ADDR_OWVAR 28
3666: PUSH
3667: LD_INT 11
3669: ST_TO_ADDR
// hc_gallery = sandar ;
3670: LD_ADDR_OWVAR 33
3674: PUSH
3675: LD_STRING sandar
3677: ST_TO_ADDR
// hc_face_number = 33 ;
3678: LD_ADDR_OWVAR 34
3682: PUSH
3683: LD_INT 33
3685: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
3686: LD_ADDR_OWVAR 26
3690: PUSH
3691: LD_STRING Thabit Muhair Saliba
3693: ST_TO_ADDR
// hc_skills = [ 0 , 0 , 0 , 0 ] ;
3694: LD_ADDR_OWVAR 31
3698: PUSH
3699: LD_INT 0
3701: PUSH
3702: LD_INT 0
3704: PUSH
3705: LD_INT 0
3707: PUSH
3708: LD_INT 0
3710: PUSH
3711: EMPTY
3712: LIST
3713: LIST
3714: LIST
3715: LIST
3716: ST_TO_ADDR
// Saliba = CreateHuman ;
3717: LD_ADDR_EXP 44
3721: PUSH
3722: CALL_OW 44
3726: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
3727: LD_EXP 44
3731: PPUSH
3732: LD_INT 7
3734: PPUSH
3735: CALL_OW 52
// if gensher_active then
3739: LD_EXP 18
3743: IFFALSE 3770
// begin Gensher = NewCharacter ( Dietrich ) ;
3745: LD_ADDR_EXP 45
3749: PUSH
3750: LD_STRING Dietrich
3752: PPUSH
3753: CALL_OW 25
3757: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
3758: LD_EXP 45
3762: PPUSH
3763: LD_INT 94
3765: PPUSH
3766: CALL_OW 52
// end ; InitHc ;
3770: CALL_OW 19
// ar_vehicles_tmp := [ ] ;
3774: LD_ADDR_EXP 41
3778: PUSH
3779: EMPTY
3780: ST_TO_ADDR
// for i = 1 to 5 do
3781: LD_ADDR_VAR 0 2
3785: PUSH
3786: DOUBLE
3787: LD_INT 1
3789: DEC
3790: ST_TO_ADDR
3791: LD_INT 5
3793: PUSH
3794: FOR_TO
3795: IFFALSE 3967
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , [ engine_combustion , engine_solar ] [ rand ( 1 , 2 ) ] , control_manual , [ ar_gatling_gun , ar_gun , ar_flame_thrower ] [ rand ( 1 , 3 ) ] , rand ( 60 , 100 ) ) ;
3797: LD_INT 13
3799: PUSH
3800: LD_INT 14
3802: PUSH
3803: EMPTY
3804: LIST
3805: LIST
3806: PUSH
3807: LD_INT 1
3809: PPUSH
3810: LD_INT 2
3812: PPUSH
3813: CALL_OW 12
3817: ARRAY
3818: PPUSH
3819: LD_INT 1
3821: PUSH
3822: LD_INT 2
3824: PUSH
3825: EMPTY
3826: LIST
3827: LIST
3828: PUSH
3829: LD_INT 1
3831: PPUSH
3832: LD_INT 2
3834: PPUSH
3835: CALL_OW 12
3839: ARRAY
3840: PPUSH
3841: LD_INT 1
3843: PPUSH
3844: LD_INT 25
3846: PUSH
3847: LD_INT 27
3849: PUSH
3850: LD_INT 26
3852: PUSH
3853: EMPTY
3854: LIST
3855: LIST
3856: LIST
3857: PUSH
3858: LD_INT 1
3860: PPUSH
3861: LD_INT 3
3863: PPUSH
3864: CALL_OW 12
3868: ARRAY
3869: PPUSH
3870: LD_INT 60
3872: PPUSH
3873: LD_INT 100
3875: PPUSH
3876: CALL_OW 12
3880: PPUSH
3881: CALL 54433 0 5
// un := CreateVehicle ;
3885: LD_ADDR_VAR 0 4
3889: PUSH
3890: CALL_OW 45
3894: ST_TO_ADDR
// ar_vehicles_tmp := Replace ( ar_vehicles_tmp , ar_vehicles_tmp + 1 , un ) ;
3895: LD_ADDR_EXP 41
3899: PUSH
3900: LD_EXP 41
3904: PPUSH
3905: LD_EXP 41
3909: PUSH
3910: LD_INT 1
3912: PLUS
3913: PPUSH
3914: LD_VAR 0 4
3918: PPUSH
3919: CALL_OW 1
3923: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
3924: LD_VAR 0 4
3928: PPUSH
3929: LD_INT 0
3931: PPUSH
3932: LD_INT 5
3934: PPUSH
3935: CALL_OW 12
3939: PPUSH
3940: CALL_OW 233
// PlaceUnitXYR ( un , 124 , 141 , 8 , false ) ;
3944: LD_VAR 0 4
3948: PPUSH
3949: LD_INT 124
3951: PPUSH
3952: LD_INT 141
3954: PPUSH
3955: LD_INT 8
3957: PPUSH
3958: LD_INT 0
3960: PPUSH
3961: CALL_OW 50
// end ;
3965: GO 3794
3967: POP
3968: POP
// ar_defenders_tmp := [ [ ] , [ ] , [ ] ] ;
3969: LD_ADDR_EXP 43
3973: PUSH
3974: EMPTY
3975: PUSH
3976: EMPTY
3977: PUSH
3978: EMPTY
3979: PUSH
3980: EMPTY
3981: LIST
3982: LIST
3983: LIST
3984: ST_TO_ADDR
// for d = 1 to [ 3 , 3 , 4 ] [ Difficulty ] do
3985: LD_ADDR_VAR 0 3
3989: PUSH
3990: DOUBLE
3991: LD_INT 1
3993: DEC
3994: ST_TO_ADDR
3995: LD_INT 3
3997: PUSH
3998: LD_INT 3
4000: PUSH
4001: LD_INT 4
4003: PUSH
4004: EMPTY
4005: LIST
4006: LIST
4007: LIST
4008: PUSH
4009: LD_OWVAR 67
4013: ARRAY
4014: PUSH
4015: FOR_TO
4016: IFFALSE 4230
// for i = 1 to 3 do
4018: LD_ADDR_VAR 0 2
4022: PUSH
4023: DOUBLE
4024: LD_INT 1
4026: DEC
4027: ST_TO_ADDR
4028: LD_INT 3
4030: PUSH
4031: FOR_TO
4032: IFFALSE 4226
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
4034: LD_INT 14
4036: PPUSH
4037: LD_INT 3
4039: PUSH
4040: LD_INT 2
4042: PUSH
4043: EMPTY
4044: LIST
4045: LIST
4046: PUSH
4047: LD_INT 1
4049: PPUSH
4050: LD_INT 2
4052: PPUSH
4053: CALL_OW 12
4057: ARRAY
4058: PPUSH
4059: LD_INT 1
4061: PUSH
4062: LD_INT 5
4064: PUSH
4065: EMPTY
4066: LIST
4067: LIST
4068: PUSH
4069: LD_INT 1
4071: PPUSH
4072: LD_INT 2
4074: PPUSH
4075: CALL_OW 12
4079: ARRAY
4080: PPUSH
4081: LD_INT 25
4083: PUSH
4084: LD_INT 27
4086: PUSH
4087: LD_INT 26
4089: PUSH
4090: LD_INT 28
4092: PUSH
4093: EMPTY
4094: LIST
4095: LIST
4096: LIST
4097: LIST
4098: PUSH
4099: LD_INT 1
4101: PPUSH
4102: LD_INT 4
4104: PPUSH
4105: CALL_OW 12
4109: ARRAY
4110: PPUSH
4111: LD_INT 100
4113: PPUSH
4114: CALL 54433 0 5
// un := CreateVehicle ;
4118: LD_ADDR_VAR 0 4
4122: PUSH
4123: CALL_OW 45
4127: ST_TO_ADDR
// ar_defenders_tmp := ReplaceIn ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
4128: LD_ADDR_EXP 43
4132: PUSH
4133: LD_EXP 43
4137: PPUSH
4138: LD_VAR 0 2
4142: PUSH
4143: LD_EXP 43
4147: PUSH
4148: LD_VAR 0 2
4152: ARRAY
4153: PUSH
4154: LD_INT 1
4156: PLUS
4157: PUSH
4158: EMPTY
4159: LIST
4160: LIST
4161: PPUSH
4162: LD_VAR 0 4
4166: PPUSH
4167: CALL 54555 0 3
4171: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4172: LD_VAR 0 4
4176: PPUSH
4177: LD_INT 0
4179: PPUSH
4180: LD_INT 5
4182: PPUSH
4183: CALL_OW 12
4187: PPUSH
4188: CALL_OW 233
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east ] [ i ] , false ) ;
4192: LD_VAR 0 4
4196: PPUSH
4197: LD_INT 20
4199: PUSH
4200: LD_INT 21
4202: PUSH
4203: LD_INT 22
4205: PUSH
4206: EMPTY
4207: LIST
4208: LIST
4209: LIST
4210: PUSH
4211: LD_VAR 0 2
4215: ARRAY
4216: PPUSH
4217: LD_INT 0
4219: PPUSH
4220: CALL_OW 49
// end ;
4224: GO 4031
4226: POP
4227: POP
4228: GO 4015
4230: POP
4231: POP
// InitHc ;
4232: CALL_OW 19
// CreateResourcesXY ( mat_artifact , 5 , 10 , 5 , false ) ;
4236: LD_INT 4
4238: PPUSH
4239: LD_INT 5
4241: PPUSH
4242: LD_INT 10
4244: PPUSH
4245: LD_INT 5
4247: PPUSH
4248: LD_INT 0
4250: PPUSH
4251: CALL_OW 58
// end ;
4255: LD_VAR 0 1
4259: RET
// every 0 0$1 trigger ar_kamikadze do var i ;
4260: LD_EXP 42
4264: IFFALSE 4338
4266: GO 4268
4268: DISABLE
4269: LD_INT 0
4271: PPUSH
// begin enable ;
4272: ENABLE
// for i in ar_kamikadze do
4273: LD_ADDR_VAR 0 1
4277: PUSH
4278: LD_EXP 42
4282: PUSH
4283: FOR_IN
4284: IFFALSE 4336
// if See ( 1 , i ) then
4286: LD_INT 1
4288: PPUSH
4289: LD_VAR 0 1
4293: PPUSH
4294: CALL_OW 292
4298: IFFALSE 4334
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
4300: LD_VAR 0 1
4304: PPUSH
4305: LD_INT 81
4307: PUSH
4308: LD_INT 2
4310: PUSH
4311: EMPTY
4312: LIST
4313: LIST
4314: PPUSH
4315: CALL_OW 69
4319: PPUSH
4320: LD_VAR 0 1
4324: PPUSH
4325: CALL_OW 74
4329: PPUSH
4330: CALL_OW 115
4334: GO 4283
4336: POP
4337: POP
// end ;
4338: PPOPN 1
4340: END
// every 5 5$20 trigger artifact_get do var i , cargo , tmp , pos ;
4341: LD_EXP 13
4345: IFFALSE 4662
4347: GO 4349
4349: DISABLE
4350: LD_INT 0
4352: PPUSH
4353: PPUSH
4354: PPUSH
4355: PPUSH
// begin repeat wait ( 0 0$1 ) ;
4356: LD_INT 35
4358: PPUSH
4359: CALL_OW 67
// until MC_GetProduceList ( 1 ) = 0 ;
4363: LD_INT 1
4365: PPUSH
4366: CALL 41322 0 1
4370: PUSH
4371: LD_INT 0
4373: EQUAL
4374: IFFALSE 4356
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
4376: LD_INT 1
4378: PPUSH
4379: LD_INT 14
4381: PUSH
4382: LD_INT 3
4384: PUSH
4385: LD_INT 2
4387: PUSH
4388: LD_INT 32
4390: PUSH
4391: EMPTY
4392: LIST
4393: LIST
4394: LIST
4395: LIST
4396: PUSH
4397: EMPTY
4398: LIST
4399: PPUSH
4400: CALL 40926 0 2
// repeat wait ( 0 0$1 ) ;
4404: LD_INT 35
4406: PPUSH
4407: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) ;
4411: LD_EXP 69
4415: PUSH
4416: LD_INT 1
4418: ARRAY
4419: PPUSH
4420: LD_INT 33
4422: PUSH
4423: LD_INT 2
4425: PUSH
4426: EMPTY
4427: LIST
4428: LIST
4429: PUSH
4430: LD_INT 34
4432: PUSH
4433: LD_INT 32
4435: PUSH
4436: EMPTY
4437: LIST
4438: LIST
4439: PUSH
4440: EMPTY
4441: LIST
4442: LIST
4443: PPUSH
4444: CALL_OW 72
4448: IFFALSE 4404
// cargo := UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) [ 1 ] ;
4450: LD_ADDR_VAR 0 2
4454: PUSH
4455: LD_EXP 69
4459: PUSH
4460: LD_INT 1
4462: ARRAY
4463: PPUSH
4464: LD_INT 33
4466: PUSH
4467: LD_INT 2
4469: PUSH
4470: EMPTY
4471: LIST
4472: LIST
4473: PUSH
4474: LD_INT 34
4476: PUSH
4477: LD_INT 32
4479: PUSH
4480: EMPTY
4481: LIST
4482: LIST
4483: PUSH
4484: EMPTY
4485: LIST
4486: LIST
4487: PPUSH
4488: CALL_OW 72
4492: PUSH
4493: LD_INT 1
4495: ARRAY
4496: ST_TO_ADDR
// pos := FindArtifact ( 5 ) ;
4497: LD_ADDR_VAR 0 4
4501: PUSH
4502: LD_INT 5
4504: PPUSH
4505: CALL_OW 469
4509: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4510: LD_INT 35
4512: PPUSH
4513: CALL_OW 67
// pos := FindArtifact ( 5 ) ;
4517: LD_ADDR_VAR 0 4
4521: PUSH
4522: LD_INT 5
4524: PPUSH
4525: CALL_OW 469
4529: ST_TO_ADDR
// tmp := 100 ;
4530: LD_ADDR_VAR 0 3
4534: PUSH
4535: LD_INT 100
4537: ST_TO_ADDR
// if pos then
4538: LD_VAR 0 4
4542: IFFALSE 4582
// tmp := DangerAtRangeXY ( 2 , pos [ 1 ] , pos [ 2 ] , 20 ) [ 4 ] ;
4544: LD_ADDR_VAR 0 3
4548: PUSH
4549: LD_INT 2
4551: PPUSH
4552: LD_VAR 0 4
4556: PUSH
4557: LD_INT 1
4559: ARRAY
4560: PPUSH
4561: LD_VAR 0 4
4565: PUSH
4566: LD_INT 2
4568: ARRAY
4569: PPUSH
4570: LD_INT 20
4572: PPUSH
4573: CALL 55451 0 4
4577: PUSH
4578: LD_INT 4
4580: ARRAY
4581: ST_TO_ADDR
// until pos and not artifact_oncargo and tmp < 10 ;
4582: LD_VAR 0 4
4586: PUSH
4587: LD_EXP 14
4591: NOT
4592: AND
4593: PUSH
4594: LD_VAR 0 3
4598: PUSH
4599: LD_INT 10
4601: LESS
4602: AND
4603: IFFALSE 4510
// ComGet ( cargo , pos [ 1 ] , pos [ 2 ] ) ;
4605: LD_VAR 0 2
4609: PPUSH
4610: LD_VAR 0 4
4614: PUSH
4615: LD_INT 1
4617: ARRAY
4618: PPUSH
4619: LD_VAR 0 4
4623: PUSH
4624: LD_INT 2
4626: ARRAY
4627: PPUSH
4628: CALL_OW 160
// AddComMoveXY ( cargo , 198 , 113 ) ;
4632: LD_VAR 0 2
4636: PPUSH
4637: LD_INT 198
4639: PPUSH
4640: LD_INT 113
4642: PPUSH
4643: CALL_OW 171
// AddComMoveXY ( cargo , 124 , 7 ) ;
4647: LD_VAR 0 2
4651: PPUSH
4652: LD_INT 124
4654: PPUSH
4655: LD_INT 7
4657: PPUSH
4658: CALL_OW 171
// end ;
4662: PPOPN 4
4664: END
// every 5 5$00 trigger base_captured do var i , un , tmp , skill , coords , flags , w , list ;
4665: LD_EXP 6
4669: IFFALSE 7345
4671: GO 4673
4673: DISABLE
4674: LD_INT 0
4676: PPUSH
4677: PPUSH
4678: PPUSH
4679: PPUSH
4680: PPUSH
4681: PPUSH
4682: PPUSH
4683: PPUSH
// begin skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
4684: LD_ADDR_VAR 0 4
4688: PUSH
4689: LD_INT 5
4691: PUSH
4692: LD_INT 6
4694: PUSH
4695: LD_INT 7
4697: PUSH
4698: EMPTY
4699: LIST
4700: LIST
4701: LIST
4702: PUSH
4703: LD_OWVAR 67
4707: ARRAY
4708: ST_TO_ADDR
// coords := [ ] ;
4709: LD_ADDR_VAR 0 5
4713: PUSH
4714: EMPTY
4715: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
4716: LD_ADDR_VAR 0 6
4720: PUSH
4721: LD_INT 0
4723: PUSH
4724: LD_INT 0
4726: PUSH
4727: LD_INT 0
4729: PUSH
4730: LD_INT 0
4732: PUSH
4733: LD_INT 1
4735: PUSH
4736: LD_INT 0
4738: PUSH
4739: LD_INT 0
4741: PUSH
4742: LD_INT 0
4744: PUSH
4745: LD_INT 1
4747: PUSH
4748: LD_INT 0
4750: PUSH
4751: EMPTY
4752: LIST
4753: LIST
4754: LIST
4755: LIST
4756: LIST
4757: LIST
4758: LIST
4759: LIST
4760: LIST
4761: LIST
4762: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ) ;
4763: LD_INT 1
4765: PPUSH
4766: LD_INT 14
4768: PUSH
4769: LD_INT 1
4771: PUSH
4772: LD_INT 2
4774: PUSH
4775: LD_INT 28
4777: PUSH
4778: EMPTY
4779: LIST
4780: LIST
4781: LIST
4782: LIST
4783: PUSH
4784: LD_INT 14
4786: PUSH
4787: LD_INT 1
4789: PUSH
4790: LD_INT 2
4792: PUSH
4793: LD_INT 25
4795: PUSH
4796: EMPTY
4797: LIST
4798: LIST
4799: LIST
4800: LIST
4801: PUSH
4802: LD_INT 14
4804: PUSH
4805: LD_INT 1
4807: PUSH
4808: LD_INT 2
4810: PUSH
4811: LD_INT 28
4813: PUSH
4814: EMPTY
4815: LIST
4816: LIST
4817: LIST
4818: LIST
4819: PUSH
4820: LD_INT 14
4822: PUSH
4823: LD_INT 1
4825: PUSH
4826: LD_INT 2
4828: PUSH
4829: LD_INT 29
4831: PUSH
4832: EMPTY
4833: LIST
4834: LIST
4835: LIST
4836: LIST
4837: PUSH
4838: EMPTY
4839: LIST
4840: LIST
4841: LIST
4842: LIST
4843: PPUSH
4844: CALL 40926 0 2
// wait ( [ 10 10$00 , 9 9$30 , 9 9$00 ] [ Difficulty ] ) ;
4848: LD_INT 21000
4850: PUSH
4851: LD_INT 19950
4853: PUSH
4854: LD_INT 18900
4856: PUSH
4857: EMPTY
4858: LIST
4859: LIST
4860: LIST
4861: PUSH
4862: LD_OWVAR 67
4866: ARRAY
4867: PPUSH
4868: CALL_OW 67
// InitHc ;
4872: CALL_OW 19
// InitUc ;
4876: CALL_OW 18
// uc_side := 2 ;
4880: LD_ADDR_OWVAR 20
4884: PUSH
4885: LD_INT 2
4887: ST_TO_ADDR
// uc_nation := 2 ;
4888: LD_ADDR_OWVAR 21
4892: PUSH
4893: LD_INT 2
4895: ST_TO_ADDR
// tmp := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
4896: LD_ADDR_VAR 0 3
4900: PUSH
4901: EMPTY
4902: PUSH
4903: EMPTY
4904: PUSH
4905: EMPTY
4906: PUSH
4907: EMPTY
4908: PUSH
4909: EMPTY
4910: PUSH
4911: EMPTY
4912: LIST
4913: LIST
4914: LIST
4915: LIST
4916: LIST
4917: ST_TO_ADDR
// tmp := Replace ( tmp , 1 , mc_vehicles [ 1 ] diff FilterAllUnits ( [ f_weapon , ar_cargo_bay ] ) ) ;
4918: LD_ADDR_VAR 0 3
4922: PUSH
4923: LD_VAR 0 3
4927: PPUSH
4928: LD_INT 1
4930: PPUSH
4931: LD_EXP 69
4935: PUSH
4936: LD_INT 1
4938: ARRAY
4939: PUSH
4940: LD_INT 34
4942: PUSH
4943: LD_INT 32
4945: PUSH
4946: EMPTY
4947: LIST
4948: LIST
4949: PPUSH
4950: CALL_OW 69
4954: DIFF
4955: PPUSH
4956: CALL_OW 1
4960: ST_TO_ADDR
// for i = 1 to Difficulty do
4961: LD_ADDR_VAR 0 1
4965: PUSH
4966: DOUBLE
4967: LD_INT 1
4969: DEC
4970: ST_TO_ADDR
4971: LD_OWVAR 67
4975: PUSH
4976: FOR_TO
4977: IFFALSE 5115
// begin uc_side := 2 ;
4979: LD_ADDR_OWVAR 20
4983: PUSH
4984: LD_INT 2
4986: ST_TO_ADDR
// uc_nation := 2 ;
4987: LD_ADDR_OWVAR 21
4991: PUSH
4992: LD_INT 2
4994: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
4995: LD_INT 13
4997: PPUSH
4998: LD_INT 3
5000: PPUSH
5001: LD_INT 5
5003: PPUSH
5004: LD_INT 29
5006: PPUSH
5007: LD_INT 100
5009: PPUSH
5010: CALL 54433 0 5
// un := CreateVehicle ;
5014: LD_ADDR_VAR 0 2
5018: PUSH
5019: CALL_OW 45
5023: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 1 , tmp [ 1 ] + 1 ] , un ) ;
5024: LD_ADDR_VAR 0 3
5028: PUSH
5029: LD_VAR 0 3
5033: PPUSH
5034: LD_INT 1
5036: PUSH
5037: LD_VAR 0 3
5041: PUSH
5042: LD_INT 1
5044: ARRAY
5045: PUSH
5046: LD_INT 1
5048: PLUS
5049: PUSH
5050: EMPTY
5051: LIST
5052: LIST
5053: PPUSH
5054: LD_VAR 0 2
5058: PPUSH
5059: CALL 54555 0 3
5063: ST_TO_ADDR
// SetDir ( un , 3 ) ;
5064: LD_VAR 0 2
5068: PPUSH
5069: LD_INT 3
5071: PPUSH
5072: CALL_OW 233
// PlaceUnitArea ( un , north_attack_spawn , false ) ;
5076: LD_VAR 0 2
5080: PPUSH
5081: LD_INT 16
5083: PPUSH
5084: LD_INT 0
5086: PPUSH
5087: CALL_OW 49
// ComMoveXY ( un , 51 , 10 ) ;
5091: LD_VAR 0 2
5095: PPUSH
5096: LD_INT 51
5098: PPUSH
5099: LD_INT 10
5101: PPUSH
5102: CALL_OW 111
// wait ( 0 0$2 ) ;
5106: LD_INT 70
5108: PPUSH
5109: CALL_OW 67
// end ;
5113: GO 4976
5115: POP
5116: POP
// coords := [ [ 51 , 24 ] , [ 75 , 90 ] ] ;
5117: LD_ADDR_VAR 0 5
5121: PUSH
5122: LD_INT 51
5124: PUSH
5125: LD_INT 24
5127: PUSH
5128: EMPTY
5129: LIST
5130: LIST
5131: PUSH
5132: LD_INT 75
5134: PUSH
5135: LD_INT 90
5137: PUSH
5138: EMPTY
5139: LIST
5140: LIST
5141: PUSH
5142: EMPTY
5143: LIST
5144: LIST
5145: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 1 ] , coords , flags ) ;
5146: LD_INT 1
5148: PPUSH
5149: LD_VAR 0 3
5153: PUSH
5154: LD_INT 1
5156: ARRAY
5157: PPUSH
5158: LD_VAR 0 5
5162: PPUSH
5163: LD_VAR 0 6
5167: PPUSH
5168: CALL 41159 0 4
// for i = 1 to [ 1 , 3 , 3 ] [ Difficulty ] do
5172: LD_ADDR_VAR 0 1
5176: PUSH
5177: DOUBLE
5178: LD_INT 1
5180: DEC
5181: ST_TO_ADDR
5182: LD_INT 1
5184: PUSH
5185: LD_INT 3
5187: PUSH
5188: LD_INT 3
5190: PUSH
5191: EMPTY
5192: LIST
5193: LIST
5194: LIST
5195: PUSH
5196: LD_OWVAR 67
5200: ARRAY
5201: PUSH
5202: FOR_TO
5203: IFFALSE 5303
// begin uc_side := 2 ;
5205: LD_ADDR_OWVAR 20
5209: PUSH
5210: LD_INT 2
5212: ST_TO_ADDR
// uc_nation := 2 ;
5213: LD_ADDR_OWVAR 21
5217: PUSH
5218: LD_INT 2
5220: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5221: LD_INT 0
5223: PPUSH
5224: LD_INT 17
5226: PPUSH
5227: LD_VAR 0 4
5231: PPUSH
5232: CALL_OW 380
// un := CreateHuman ;
5236: LD_ADDR_VAR 0 2
5240: PUSH
5241: CALL_OW 44
5245: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5246: LD_ADDR_VAR 0 3
5250: PUSH
5251: LD_VAR 0 3
5255: PPUSH
5256: LD_INT 2
5258: PUSH
5259: LD_VAR 0 3
5263: PUSH
5264: LD_INT 2
5266: ARRAY
5267: PUSH
5268: LD_INT 1
5270: PLUS
5271: PUSH
5272: EMPTY
5273: LIST
5274: LIST
5275: PPUSH
5276: LD_VAR 0 2
5280: PPUSH
5281: CALL 54555 0 3
5285: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5286: LD_VAR 0 2
5290: PPUSH
5291: LD_INT 13
5293: PPUSH
5294: LD_INT 0
5296: PPUSH
5297: CALL_OW 49
// end ;
5301: GO 5202
5303: POP
5304: POP
// for i = 1 to [ 3 , 4 , 4 ] [ Difficulty ] do
5305: LD_ADDR_VAR 0 1
5309: PUSH
5310: DOUBLE
5311: LD_INT 1
5313: DEC
5314: ST_TO_ADDR
5315: LD_INT 3
5317: PUSH
5318: LD_INT 4
5320: PUSH
5321: LD_INT 4
5323: PUSH
5324: EMPTY
5325: LIST
5326: LIST
5327: LIST
5328: PUSH
5329: LD_OWVAR 67
5333: ARRAY
5334: PUSH
5335: FOR_TO
5336: IFFALSE 5457
// begin uc_side := 2 ;
5338: LD_ADDR_OWVAR 20
5342: PUSH
5343: LD_INT 2
5345: ST_TO_ADDR
// uc_nation := 2 ;
5346: LD_ADDR_OWVAR 21
5350: PUSH
5351: LD_INT 2
5353: ST_TO_ADDR
// PrepareHuman ( false , [ 1 , 8 ] [ i mod 2 + 1 ] , skill ) ;
5354: LD_INT 0
5356: PPUSH
5357: LD_INT 1
5359: PUSH
5360: LD_INT 8
5362: PUSH
5363: EMPTY
5364: LIST
5365: LIST
5366: PUSH
5367: LD_VAR 0 1
5371: PUSH
5372: LD_INT 2
5374: MOD
5375: PUSH
5376: LD_INT 1
5378: PLUS
5379: ARRAY
5380: PPUSH
5381: LD_VAR 0 4
5385: PPUSH
5386: CALL_OW 380
// un := CreateHuman ;
5390: LD_ADDR_VAR 0 2
5394: PUSH
5395: CALL_OW 44
5399: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5400: LD_ADDR_VAR 0 3
5404: PUSH
5405: LD_VAR 0 3
5409: PPUSH
5410: LD_INT 2
5412: PUSH
5413: LD_VAR 0 3
5417: PUSH
5418: LD_INT 2
5420: ARRAY
5421: PUSH
5422: LD_INT 1
5424: PLUS
5425: PUSH
5426: EMPTY
5427: LIST
5428: LIST
5429: PPUSH
5430: LD_VAR 0 2
5434: PPUSH
5435: CALL 54555 0 3
5439: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5440: LD_VAR 0 2
5444: PPUSH
5445: LD_INT 13
5447: PPUSH
5448: LD_INT 0
5450: PPUSH
5451: CALL_OW 49
// end ;
5455: GO 5335
5457: POP
5458: POP
// coords := [ [ 67 , 112 ] , [ 85 , 130 ] ] ;
5459: LD_ADDR_VAR 0 5
5463: PUSH
5464: LD_INT 67
5466: PUSH
5467: LD_INT 112
5469: PUSH
5470: EMPTY
5471: LIST
5472: LIST
5473: PUSH
5474: LD_INT 85
5476: PUSH
5477: LD_INT 130
5479: PUSH
5480: EMPTY
5481: LIST
5482: LIST
5483: PUSH
5484: EMPTY
5485: LIST
5486: LIST
5487: ST_TO_ADDR
// MC_PrepareAttack ( 2 , tmp [ 2 ] , coords , flags ) ;
5488: LD_INT 2
5490: PPUSH
5491: LD_VAR 0 3
5495: PUSH
5496: LD_INT 2
5498: ARRAY
5499: PPUSH
5500: LD_VAR 0 5
5504: PPUSH
5505: LD_VAR 0 6
5509: PPUSH
5510: CALL 41159 0 4
// for i = 1 to [ 1 , 2 , 3 ] [ Difficulty ] do
5514: LD_ADDR_VAR 0 1
5518: PUSH
5519: DOUBLE
5520: LD_INT 1
5522: DEC
5523: ST_TO_ADDR
5524: LD_INT 1
5526: PUSH
5527: LD_INT 2
5529: PUSH
5530: LD_INT 3
5532: PUSH
5533: EMPTY
5534: LIST
5535: LIST
5536: LIST
5537: PUSH
5538: LD_OWVAR 67
5542: ARRAY
5543: PUSH
5544: FOR_TO
5545: IFFALSE 5645
// begin uc_side := 2 ;
5547: LD_ADDR_OWVAR 20
5551: PUSH
5552: LD_INT 2
5554: ST_TO_ADDR
// uc_nation := 2 ;
5555: LD_ADDR_OWVAR 21
5559: PUSH
5560: LD_INT 2
5562: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5563: LD_INT 0
5565: PPUSH
5566: LD_INT 17
5568: PPUSH
5569: LD_VAR 0 4
5573: PPUSH
5574: CALL_OW 380
// un := CreateHuman ;
5578: LD_ADDR_VAR 0 2
5582: PUSH
5583: CALL_OW 44
5587: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 3 , tmp [ 3 ] + 1 ] , un ) ;
5588: LD_ADDR_VAR 0 3
5592: PUSH
5593: LD_VAR 0 3
5597: PPUSH
5598: LD_INT 3
5600: PUSH
5601: LD_VAR 0 3
5605: PUSH
5606: LD_INT 3
5608: ARRAY
5609: PUSH
5610: LD_INT 1
5612: PLUS
5613: PUSH
5614: EMPTY
5615: LIST
5616: LIST
5617: PPUSH
5618: LD_VAR 0 2
5622: PPUSH
5623: CALL 54555 0 3
5627: ST_TO_ADDR
// PlaceUnitArea ( un , south_attack_spawn , false ) ;
5628: LD_VAR 0 2
5632: PPUSH
5633: LD_INT 14
5635: PPUSH
5636: LD_INT 0
5638: PPUSH
5639: CALL_OW 49
// end ;
5643: GO 5544
5645: POP
5646: POP
// coords := [ [ 148 , 158 ] , [ 148 , 158 ] ] ;
5647: LD_ADDR_VAR 0 5
5651: PUSH
5652: LD_INT 148
5654: PUSH
5655: LD_INT 158
5657: PUSH
5658: EMPTY
5659: LIST
5660: LIST
5661: PUSH
5662: LD_INT 148
5664: PUSH
5665: LD_INT 158
5667: PUSH
5668: EMPTY
5669: LIST
5670: LIST
5671: PUSH
5672: EMPTY
5673: LIST
5674: LIST
5675: ST_TO_ADDR
// MC_PrepareAttack ( 3 , tmp [ 3 ] , coords , flags ) ;
5676: LD_INT 3
5678: PPUSH
5679: LD_VAR 0 3
5683: PUSH
5684: LD_INT 3
5686: ARRAY
5687: PPUSH
5688: LD_VAR 0 5
5692: PPUSH
5693: LD_VAR 0 6
5697: PPUSH
5698: CALL 41159 0 4
// for i = 1 to [ 2 , 4 , 4 ] [ Difficulty ] do
5702: LD_ADDR_VAR 0 1
5706: PUSH
5707: DOUBLE
5708: LD_INT 1
5710: DEC
5711: ST_TO_ADDR
5712: LD_INT 2
5714: PUSH
5715: LD_INT 4
5717: PUSH
5718: LD_INT 4
5720: PUSH
5721: EMPTY
5722: LIST
5723: LIST
5724: LIST
5725: PUSH
5726: LD_OWVAR 67
5730: ARRAY
5731: PUSH
5732: FOR_TO
5733: IFFALSE 5957
// begin uc_side := 2 ;
5735: LD_ADDR_OWVAR 20
5739: PUSH
5740: LD_INT 2
5742: ST_TO_ADDR
// uc_nation := 2 ;
5743: LD_ADDR_OWVAR 21
5747: PUSH
5748: LD_INT 2
5750: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 3 ) ] , 100 ) ;
5751: LD_INT 14
5753: PPUSH
5754: LD_INT 3
5756: PPUSH
5757: LD_INT 1
5759: PUSH
5760: LD_INT 5
5762: PUSH
5763: EMPTY
5764: LIST
5765: LIST
5766: PUSH
5767: LD_INT 1
5769: PPUSH
5770: LD_INT 2
5772: PPUSH
5773: CALL_OW 12
5777: ARRAY
5778: PPUSH
5779: LD_INT 27
5781: PUSH
5782: LD_INT 26
5784: PUSH
5785: LD_INT 28
5787: PUSH
5788: EMPTY
5789: LIST
5790: LIST
5791: LIST
5792: PUSH
5793: LD_INT 1
5795: PPUSH
5796: LD_INT 3
5798: PPUSH
5799: CALL_OW 12
5803: ARRAY
5804: PPUSH
5805: LD_INT 100
5807: PPUSH
5808: CALL 54433 0 5
// un := CreateVehicle ;
5812: LD_ADDR_VAR 0 2
5816: PUSH
5817: CALL_OW 45
5821: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , un ) ;
5822: LD_ADDR_VAR 0 3
5826: PUSH
5827: LD_VAR 0 3
5831: PPUSH
5832: LD_INT 4
5834: PUSH
5835: LD_VAR 0 3
5839: PUSH
5840: LD_INT 4
5842: ARRAY
5843: PUSH
5844: LD_INT 1
5846: PLUS
5847: PUSH
5848: EMPTY
5849: LIST
5850: LIST
5851: PPUSH
5852: LD_VAR 0 2
5856: PPUSH
5857: CALL 54555 0 3
5861: ST_TO_ADDR
// SetDir ( un , 5 ) ;
5862: LD_VAR 0 2
5866: PPUSH
5867: LD_INT 5
5869: PPUSH
5870: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
5874: LD_VAR 0 2
5878: PPUSH
5879: LD_INT 15
5881: PPUSH
5882: LD_INT 0
5884: PPUSH
5885: CALL_OW 49
// if GetControl ( un ) = control_manual then
5889: LD_VAR 0 2
5893: PPUSH
5894: CALL_OW 263
5898: PUSH
5899: LD_INT 1
5901: EQUAL
5902: IFFALSE 5933
// begin PrepareHuman ( false , 3 , skill ) ;
5904: LD_INT 0
5906: PPUSH
5907: LD_INT 3
5909: PPUSH
5910: LD_VAR 0 4
5914: PPUSH
5915: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
5919: CALL_OW 44
5923: PPUSH
5924: LD_VAR 0 2
5928: PPUSH
5929: CALL_OW 52
// end ; ComMoveXY ( un , 179 , 135 ) ;
5933: LD_VAR 0 2
5937: PPUSH
5938: LD_INT 179
5940: PPUSH
5941: LD_INT 135
5943: PPUSH
5944: CALL_OW 111
// wait ( 0 0$2 ) ;
5948: LD_INT 70
5950: PPUSH
5951: CALL_OW 67
// end ;
5955: GO 5732
5957: POP
5958: POP
// vc_chassis := 15 ;
5959: LD_ADDR_OWVAR 37
5963: PUSH
5964: LD_INT 15
5966: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateVehicle ) ;
5967: LD_ADDR_VAR 0 3
5971: PUSH
5972: LD_VAR 0 3
5976: PPUSH
5977: LD_INT 4
5979: PUSH
5980: LD_VAR 0 3
5984: PUSH
5985: LD_INT 4
5987: ARRAY
5988: PUSH
5989: LD_INT 1
5991: PLUS
5992: PUSH
5993: EMPTY
5994: LIST
5995: LIST
5996: PPUSH
5997: CALL_OW 45
6001: PPUSH
6002: CALL 54555 0 3
6006: ST_TO_ADDR
// PlaceUnitArea ( tmp [ 4 ] [ tmp [ 4 ] ] , east_attack_spawn , false ) ;
6007: LD_VAR 0 3
6011: PUSH
6012: LD_INT 4
6014: ARRAY
6015: PUSH
6016: LD_VAR 0 3
6020: PUSH
6021: LD_INT 4
6023: ARRAY
6024: ARRAY
6025: PPUSH
6026: LD_INT 15
6028: PPUSH
6029: LD_INT 0
6031: PPUSH
6032: CALL_OW 49
// PrepareHuman ( false , class_desert_warior , skill ) ;
6036: LD_INT 0
6038: PPUSH
6039: LD_INT 11
6041: PPUSH
6042: LD_VAR 0 4
6046: PPUSH
6047: CALL_OW 380
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateHuman ) ;
6051: LD_ADDR_VAR 0 3
6055: PUSH
6056: LD_VAR 0 3
6060: PPUSH
6061: LD_INT 4
6063: PUSH
6064: LD_VAR 0 3
6068: PUSH
6069: LD_INT 4
6071: ARRAY
6072: PUSH
6073: LD_INT 1
6075: PLUS
6076: PUSH
6077: EMPTY
6078: LIST
6079: LIST
6080: PPUSH
6081: CALL_OW 44
6085: PPUSH
6086: CALL 54555 0 3
6090: ST_TO_ADDR
// PlaceHumanInUnit ( tmp [ 4 ] [ tmp [ 4 ] ] , tmp [ 4 ] [ tmp [ 4 ] - 1 ] ) ;
6091: LD_VAR 0 3
6095: PUSH
6096: LD_INT 4
6098: ARRAY
6099: PUSH
6100: LD_VAR 0 3
6104: PUSH
6105: LD_INT 4
6107: ARRAY
6108: ARRAY
6109: PPUSH
6110: LD_VAR 0 3
6114: PUSH
6115: LD_INT 4
6117: ARRAY
6118: PUSH
6119: LD_VAR 0 3
6123: PUSH
6124: LD_INT 4
6126: ARRAY
6127: PUSH
6128: LD_INT 1
6130: MINUS
6131: ARRAY
6132: PPUSH
6133: CALL_OW 52
// coords := [ [ 148 , 140 ] ] ;
6137: LD_ADDR_VAR 0 5
6141: PUSH
6142: LD_INT 148
6144: PUSH
6145: LD_INT 140
6147: PUSH
6148: EMPTY
6149: LIST
6150: LIST
6151: PUSH
6152: EMPTY
6153: LIST
6154: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 4 ] , coords , flags ) ;
6155: LD_INT 1
6157: PPUSH
6158: LD_VAR 0 3
6162: PUSH
6163: LD_INT 4
6165: ARRAY
6166: PPUSH
6167: LD_VAR 0 5
6171: PPUSH
6172: LD_VAR 0 6
6176: PPUSH
6177: CALL 41159 0 4
// if gensher_active then
6181: LD_EXP 18
6185: IFFALSE 6587
// begin SayRadio ( Gensher , D10-Diet-1 ) ;
6187: LD_EXP 45
6191: PPUSH
6192: LD_STRING D10-Diet-1
6194: PPUSH
6195: CALL_OW 94
// for i = 1 to 2 do
6199: LD_ADDR_VAR 0 1
6203: PUSH
6204: DOUBLE
6205: LD_INT 1
6207: DEC
6208: ST_TO_ADDR
6209: LD_INT 2
6211: PUSH
6212: FOR_TO
6213: IFFALSE 6351
// begin uc_side := 2 ;
6215: LD_ADDR_OWVAR 20
6219: PUSH
6220: LD_INT 2
6222: ST_TO_ADDR
// uc_nation := 2 ;
6223: LD_ADDR_OWVAR 21
6227: PUSH
6228: LD_INT 2
6230: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
6231: LD_INT 13
6233: PPUSH
6234: LD_INT 3
6236: PPUSH
6237: LD_INT 5
6239: PPUSH
6240: LD_INT 29
6242: PPUSH
6243: LD_INT 100
6245: PPUSH
6246: CALL 54433 0 5
// un := CreateVehicle ;
6250: LD_ADDR_VAR 0 2
6254: PUSH
6255: CALL_OW 45
6259: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6260: LD_ADDR_VAR 0 3
6264: PUSH
6265: LD_VAR 0 3
6269: PPUSH
6270: LD_INT 5
6272: PUSH
6273: LD_VAR 0 3
6277: PUSH
6278: LD_INT 5
6280: ARRAY
6281: PUSH
6282: LD_INT 1
6284: PLUS
6285: PUSH
6286: EMPTY
6287: LIST
6288: LIST
6289: PPUSH
6290: LD_VAR 0 2
6294: PPUSH
6295: CALL 54555 0 3
6299: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6300: LD_VAR 0 2
6304: PPUSH
6305: LD_INT 0
6307: PPUSH
6308: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6312: LD_VAR 0 2
6316: PPUSH
6317: LD_INT 23
6319: PPUSH
6320: LD_INT 0
6322: PPUSH
6323: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6327: LD_VAR 0 2
6331: PPUSH
6332: LD_INT 85
6334: PPUSH
6335: LD_INT 152
6337: PPUSH
6338: CALL_OW 111
// wait ( 0 0$2 ) ;
6342: LD_INT 70
6344: PPUSH
6345: CALL_OW 67
// end ;
6349: GO 6212
6351: POP
6352: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] do
6353: LD_ADDR_VAR 0 1
6357: PUSH
6358: DOUBLE
6359: LD_INT 1
6361: DEC
6362: ST_TO_ADDR
6363: LD_INT 2
6365: PUSH
6366: LD_INT 3
6368: PUSH
6369: LD_INT 3
6371: PUSH
6372: EMPTY
6373: LIST
6374: LIST
6375: LIST
6376: PUSH
6377: LD_OWVAR 67
6381: ARRAY
6382: PUSH
6383: FOR_TO
6384: IFFALSE 6541
// begin uc_side := 2 ;
6386: LD_ADDR_OWVAR 20
6390: PUSH
6391: LD_INT 2
6393: ST_TO_ADDR
// uc_nation := 2 ;
6394: LD_ADDR_OWVAR 21
6398: PUSH
6399: LD_INT 2
6401: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
6402: LD_INT 14
6404: PPUSH
6405: LD_INT 3
6407: PPUSH
6408: LD_INT 5
6410: PPUSH
6411: LD_INT 27
6413: PUSH
6414: LD_INT 28
6416: PUSH
6417: EMPTY
6418: LIST
6419: LIST
6420: PUSH
6421: LD_INT 1
6423: PPUSH
6424: LD_INT 2
6426: PPUSH
6427: CALL_OW 12
6431: ARRAY
6432: PPUSH
6433: LD_INT 100
6435: PPUSH
6436: CALL 54433 0 5
// un := CreateVehicle ;
6440: LD_ADDR_VAR 0 2
6444: PUSH
6445: CALL_OW 45
6449: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6450: LD_ADDR_VAR 0 3
6454: PUSH
6455: LD_VAR 0 3
6459: PPUSH
6460: LD_INT 5
6462: PUSH
6463: LD_VAR 0 3
6467: PUSH
6468: LD_INT 5
6470: ARRAY
6471: PUSH
6472: LD_INT 1
6474: PLUS
6475: PUSH
6476: EMPTY
6477: LIST
6478: LIST
6479: PPUSH
6480: LD_VAR 0 2
6484: PPUSH
6485: CALL 54555 0 3
6489: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6490: LD_VAR 0 2
6494: PPUSH
6495: LD_INT 0
6497: PPUSH
6498: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6502: LD_VAR 0 2
6506: PPUSH
6507: LD_INT 23
6509: PPUSH
6510: LD_INT 0
6512: PPUSH
6513: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6517: LD_VAR 0 2
6521: PPUSH
6522: LD_INT 85
6524: PPUSH
6525: LD_INT 152
6527: PPUSH
6528: CALL_OW 111
// wait ( 0 0$2 ) ;
6532: LD_INT 70
6534: PPUSH
6535: CALL_OW 67
// end ;
6539: GO 6383
6541: POP
6542: POP
// coords := [ [ 97 , 143 ] ] ;
6543: LD_ADDR_VAR 0 5
6547: PUSH
6548: LD_INT 97
6550: PUSH
6551: LD_INT 143
6553: PUSH
6554: EMPTY
6555: LIST
6556: LIST
6557: PUSH
6558: EMPTY
6559: LIST
6560: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 5 ] , coords , flags ) ;
6561: LD_INT 1
6563: PPUSH
6564: LD_VAR 0 3
6568: PUSH
6569: LD_INT 5
6571: ARRAY
6572: PPUSH
6573: LD_VAR 0 5
6577: PPUSH
6578: LD_VAR 0 6
6582: PPUSH
6583: CALL 41159 0 4
// end ; Wait ( 13 13$00 ) ;
6587: LD_INT 27300
6589: PPUSH
6590: CALL_OW 67
// tmp := [ ] ;
6594: LD_ADDR_VAR 0 3
6598: PUSH
6599: EMPTY
6600: ST_TO_ADDR
// w := 1 ;
6601: LD_ADDR_VAR 0 7
6605: PUSH
6606: LD_INT 1
6608: ST_TO_ADDR
// repeat tmp := [ ] ;
6609: LD_ADDR_VAR 0 3
6613: PUSH
6614: EMPTY
6615: ST_TO_ADDR
// if w mod 4 = 0 then
6616: LD_VAR 0 7
6620: PUSH
6621: LD_INT 4
6623: MOD
6624: PUSH
6625: LD_INT 0
6627: EQUAL
6628: IFFALSE 6715
// list := [ [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] else
6630: LD_ADDR_VAR 0 8
6634: PUSH
6635: LD_INT 11
6637: PUSH
6638: LD_INT 1
6640: PUSH
6641: LD_INT 2
6643: PUSH
6644: LD_INT 24
6646: PUSH
6647: EMPTY
6648: LIST
6649: LIST
6650: LIST
6651: LIST
6652: PUSH
6653: LD_INT 11
6655: PUSH
6656: LD_INT 1
6658: PUSH
6659: LD_INT 2
6661: PUSH
6662: LD_INT 24
6664: PUSH
6665: EMPTY
6666: LIST
6667: LIST
6668: LIST
6669: LIST
6670: PUSH
6671: LD_INT 11
6673: PUSH
6674: LD_INT 1
6676: PUSH
6677: LD_INT 2
6679: PUSH
6680: LD_INT 24
6682: PUSH
6683: EMPTY
6684: LIST
6685: LIST
6686: LIST
6687: LIST
6688: PUSH
6689: LD_INT 11
6691: PUSH
6692: LD_INT 1
6694: PUSH
6695: LD_INT 2
6697: PUSH
6698: LD_INT 24
6700: PUSH
6701: EMPTY
6702: LIST
6703: LIST
6704: LIST
6705: LIST
6706: PUSH
6707: EMPTY
6708: LIST
6709: LIST
6710: LIST
6711: LIST
6712: ST_TO_ADDR
6713: GO 6817
// list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] ;
6715: LD_ADDR_VAR 0 8
6719: PUSH
6720: LD_INT 14
6722: PUSH
6723: LD_INT 1
6725: PUSH
6726: LD_INT 2
6728: PUSH
6729: LD_INT 28
6731: PUSH
6732: EMPTY
6733: LIST
6734: LIST
6735: LIST
6736: LIST
6737: PUSH
6738: LD_INT 14
6740: PUSH
6741: LD_INT 1
6743: PUSH
6744: LD_INT 2
6746: PUSH
6747: LD_INT 25
6749: PUSH
6750: EMPTY
6751: LIST
6752: LIST
6753: LIST
6754: LIST
6755: PUSH
6756: LD_INT 14
6758: PUSH
6759: LD_INT 1
6761: PUSH
6762: LD_INT 2
6764: PUSH
6765: LD_INT 28
6767: PUSH
6768: EMPTY
6769: LIST
6770: LIST
6771: LIST
6772: LIST
6773: PUSH
6774: LD_INT 14
6776: PUSH
6777: LD_INT 1
6779: PUSH
6780: LD_INT 2
6782: PUSH
6783: LD_INT 29
6785: PUSH
6786: EMPTY
6787: LIST
6788: LIST
6789: LIST
6790: LIST
6791: PUSH
6792: LD_INT 11
6794: PUSH
6795: LD_INT 1
6797: PUSH
6798: LD_INT 2
6800: PUSH
6801: LD_INT 24
6803: PUSH
6804: EMPTY
6805: LIST
6806: LIST
6807: LIST
6808: LIST
6809: PUSH
6810: EMPTY
6811: LIST
6812: LIST
6813: LIST
6814: LIST
6815: LIST
6816: ST_TO_ADDR
// if w mod 3 = 0 then
6817: LD_VAR 0 7
6821: PUSH
6822: LD_INT 3
6824: MOD
6825: PUSH
6826: LD_INT 0
6828: EQUAL
6829: IFFALSE 6905
// list := ReplaceIn ( list , [ 1 , list [ i ] + 1 ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gatling_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] ] ) ;
6831: LD_ADDR_VAR 0 8
6835: PUSH
6836: LD_VAR 0 8
6840: PPUSH
6841: LD_INT 1
6843: PUSH
6844: LD_VAR 0 8
6848: PUSH
6849: LD_VAR 0 1
6853: ARRAY
6854: PUSH
6855: LD_INT 1
6857: PLUS
6858: PUSH
6859: EMPTY
6860: LIST
6861: LIST
6862: PPUSH
6863: LD_INT 14
6865: PUSH
6866: LD_INT 1
6868: PUSH
6869: LD_INT 2
6871: PUSH
6872: LD_INT 25
6874: PUSH
6875: LD_INT 28
6877: PUSH
6878: EMPTY
6879: LIST
6880: LIST
6881: PUSH
6882: LD_INT 1
6884: PPUSH
6885: LD_INT 2
6887: PPUSH
6888: CALL_OW 12
6892: ARRAY
6893: PUSH
6894: EMPTY
6895: LIST
6896: LIST
6897: LIST
6898: LIST
6899: PPUSH
6900: CALL 54555 0 3
6904: ST_TO_ADDR
// MC_SetProduceList ( 1 , list ) ;
6905: LD_INT 1
6907: PPUSH
6908: LD_VAR 0 8
6912: PPUSH
6913: CALL 40926 0 2
// if GetSide ( ar_dep_w ) = 2 then
6917: LD_INT 45
6919: PPUSH
6920: CALL_OW 255
6924: PUSH
6925: LD_INT 2
6927: EQUAL
6928: IFFALSE 7013
// begin list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] ] ;
6930: LD_ADDR_VAR 0 8
6934: PUSH
6935: LD_INT 14
6937: PUSH
6938: LD_INT 1
6940: PUSH
6941: LD_INT 2
6943: PUSH
6944: LD_INT 28
6946: PUSH
6947: EMPTY
6948: LIST
6949: LIST
6950: LIST
6951: LIST
6952: PUSH
6953: LD_INT 14
6955: PUSH
6956: LD_INT 1
6958: PUSH
6959: LD_INT 2
6961: PUSH
6962: LD_INT 27
6964: PUSH
6965: EMPTY
6966: LIST
6967: LIST
6968: LIST
6969: LIST
6970: PUSH
6971: LD_INT 14
6973: PUSH
6974: LD_INT 1
6976: PUSH
6977: LD_INT 2
6979: PUSH
6980: LD_INT 27
6982: PUSH
6983: EMPTY
6984: LIST
6985: LIST
6986: LIST
6987: LIST
6988: PUSH
6989: EMPTY
6990: LIST
6991: LIST
6992: LIST
6993: ST_TO_ADDR
// MC_SetProduceList ( 2 , list ) ;
6994: LD_INT 2
6996: PPUSH
6997: LD_VAR 0 8
7001: PPUSH
7002: CALL 40926 0 2
// wait ( 0 0$50 ) ;
7006: LD_INT 1750
7008: PPUSH
7009: CALL_OW 67
// end ; repeat wait ( 0 0$1 ) ;
7013: LD_INT 35
7015: PPUSH
7016: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_weapon , ar_cargo_bay ] ] ) >= 4 ;
7020: LD_EXP 69
7024: PUSH
7025: LD_INT 1
7027: ARRAY
7028: PPUSH
7029: LD_INT 3
7031: PUSH
7032: LD_INT 34
7034: PUSH
7035: LD_INT 32
7037: PUSH
7038: EMPTY
7039: LIST
7040: LIST
7041: PUSH
7042: EMPTY
7043: LIST
7044: LIST
7045: PPUSH
7046: CALL_OW 72
7050: PUSH
7051: LD_INT 4
7053: GREATEREQUAL
7054: IFFALSE 7013
// wait ( 0 0$10 ) ;
7056: LD_INT 350
7058: PPUSH
7059: CALL_OW 67
// tmp := UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_weapon , ar_cargo_bay ] ] ) ;
7063: LD_ADDR_VAR 0 3
7067: PUSH
7068: LD_EXP 69
7072: PUSH
7073: LD_INT 1
7075: ARRAY
7076: PPUSH
7077: LD_INT 3
7079: PUSH
7080: LD_INT 34
7082: PUSH
7083: LD_INT 32
7085: PUSH
7086: EMPTY
7087: LIST
7088: LIST
7089: PUSH
7090: EMPTY
7091: LIST
7092: LIST
7093: PPUSH
7094: CALL_OW 72
7098: ST_TO_ADDR
// if Prob ( 100 ) < 50 then
7099: LD_INT 100
7101: PPUSH
7102: CALL_OW 13
7106: PUSH
7107: LD_INT 50
7109: LESS
7110: IFFALSE 7143
// coords := [ [ 55 , 7 ] , [ 75 , 90 ] ] else
7112: LD_ADDR_VAR 0 5
7116: PUSH
7117: LD_INT 55
7119: PUSH
7120: LD_INT 7
7122: PUSH
7123: EMPTY
7124: LIST
7125: LIST
7126: PUSH
7127: LD_INT 75
7129: PUSH
7130: LD_INT 90
7132: PUSH
7133: EMPTY
7134: LIST
7135: LIST
7136: PUSH
7137: EMPTY
7138: LIST
7139: LIST
7140: ST_TO_ADDR
7141: GO 7172
// coords := [ [ 128 , 94 ] , [ 180 , 135 ] ] ;
7143: LD_ADDR_VAR 0 5
7147: PUSH
7148: LD_INT 128
7150: PUSH
7151: LD_INT 94
7153: PUSH
7154: EMPTY
7155: LIST
7156: LIST
7157: PUSH
7158: LD_INT 180
7160: PUSH
7161: LD_INT 135
7163: PUSH
7164: EMPTY
7165: LIST
7166: LIST
7167: PUSH
7168: EMPTY
7169: LIST
7170: LIST
7171: ST_TO_ADDR
// if w mod 4 = 0 then
7172: LD_VAR 0 7
7176: PUSH
7177: LD_INT 4
7179: MOD
7180: PUSH
7181: LD_INT 0
7183: EQUAL
7184: IFFALSE 7215
// coords := [ [ 91 , 58 ] , [ 117 , 107 ] ] ;
7186: LD_ADDR_VAR 0 5
7190: PUSH
7191: LD_INT 91
7193: PUSH
7194: LD_INT 58
7196: PUSH
7197: EMPTY
7198: LIST
7199: LIST
7200: PUSH
7201: LD_INT 117
7203: PUSH
7204: LD_INT 107
7206: PUSH
7207: EMPTY
7208: LIST
7209: LIST
7210: PUSH
7211: EMPTY
7212: LIST
7213: LIST
7214: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp , coords , flags ) ;
7215: LD_INT 1
7217: PPUSH
7218: LD_VAR 0 3
7222: PPUSH
7223: LD_VAR 0 5
7227: PPUSH
7228: LD_VAR 0 6
7232: PPUSH
7233: CALL 41159 0 4
// if mc_vehicles [ 2 ] then
7237: LD_EXP 69
7241: PUSH
7242: LD_INT 2
7244: ARRAY
7245: IFFALSE 7281
// MC_PrepareAttack ( 2 , mc_vehicles [ 2 ] , [ [ 73 , 115 ] ] , flags ) ;
7247: LD_INT 2
7249: PPUSH
7250: LD_EXP 69
7254: PUSH
7255: LD_INT 2
7257: ARRAY
7258: PPUSH
7259: LD_INT 73
7261: PUSH
7262: LD_INT 115
7264: PUSH
7265: EMPTY
7266: LIST
7267: LIST
7268: PUSH
7269: EMPTY
7270: LIST
7271: PPUSH
7272: LD_VAR 0 6
7276: PPUSH
7277: CALL 41159 0 4
// wait ( rand ( 10 10$30 , 13 13$30 ) ) ;
7281: LD_INT 22050
7283: PPUSH
7284: LD_INT 28350
7286: PPUSH
7287: CALL_OW 12
7291: PPUSH
7292: CALL_OW 67
// w := w + 1 ;
7296: LD_ADDR_VAR 0 7
7300: PUSH
7301: LD_VAR 0 7
7305: PUSH
7306: LD_INT 1
7308: PLUS
7309: ST_TO_ADDR
// until IsDead ( ar_dep_n ) or not UnitFilter ( mc_bases [ 1 ] , [ f_btype , b_factory ] ) ;
7310: LD_INT 94
7312: PPUSH
7313: CALL_OW 301
7317: PUSH
7318: LD_EXP 50
7322: PUSH
7323: LD_INT 1
7325: ARRAY
7326: PPUSH
7327: LD_INT 30
7329: PUSH
7330: LD_INT 3
7332: PUSH
7333: EMPTY
7334: LIST
7335: LIST
7336: PPUSH
7337: CALL_OW 72
7341: NOT
7342: OR
7343: IFFALSE 6609
// end ;
7345: PPOPN 8
7347: END
// every 28 28$00 trigger ar_dep_e do var i , tmp , un , x ;
7348: LD_INT 204
7350: IFFALSE 7816
7352: GO 7354
7354: DISABLE
7355: LD_INT 0
7357: PPUSH
7358: PPUSH
7359: PPUSH
7360: PPUSH
// begin enable ;
7361: ENABLE
// wait ( rand ( 0 0$1 , 0 0$34 ) ) ;
7362: LD_INT 35
7364: PPUSH
7365: LD_INT 1190
7367: PPUSH
7368: CALL_OW 12
7372: PPUSH
7373: CALL_OW 67
// tmp := [ ] ;
7377: LD_ADDR_VAR 0 2
7381: PUSH
7382: EMPTY
7383: ST_TO_ADDR
// uc_side := 8 ;
7384: LD_ADDR_OWVAR 20
7388: PUSH
7389: LD_INT 8
7391: ST_TO_ADDR
// uc_nation := 2 ;
7392: LD_ADDR_OWVAR 21
7396: PUSH
7397: LD_INT 2
7399: ST_TO_ADDR
// InitHc ;
7400: CALL_OW 19
// for i = 1 to 3 do
7404: LD_ADDR_VAR 0 1
7408: PUSH
7409: DOUBLE
7410: LD_INT 1
7412: DEC
7413: ST_TO_ADDR
7414: LD_INT 3
7416: PUSH
7417: FOR_TO
7418: IFFALSE 7545
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
7420: LD_INT 13
7422: PUSH
7423: LD_INT 14
7425: PUSH
7426: EMPTY
7427: LIST
7428: LIST
7429: PUSH
7430: LD_INT 1
7432: PPUSH
7433: LD_INT 2
7435: PPUSH
7436: CALL_OW 12
7440: ARRAY
7441: PPUSH
7442: LD_INT 3
7444: PPUSH
7445: LD_INT 5
7447: PPUSH
7448: LD_INT 27
7450: PUSH
7451: LD_INT 28
7453: PUSH
7454: EMPTY
7455: LIST
7456: LIST
7457: PUSH
7458: LD_INT 1
7460: PPUSH
7461: LD_INT 2
7463: PPUSH
7464: CALL_OW 12
7468: ARRAY
7469: PPUSH
7470: LD_INT 100
7472: PPUSH
7473: CALL 54433 0 5
// un := CreateVehicle ;
7477: LD_ADDR_VAR 0 3
7481: PUSH
7482: CALL_OW 45
7486: ST_TO_ADDR
// SetDir ( un , 4 ) ;
7487: LD_VAR 0 3
7491: PPUSH
7492: LD_INT 4
7494: PPUSH
7495: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
7499: LD_VAR 0 3
7503: PPUSH
7504: LD_INT 15
7506: PPUSH
7507: LD_INT 0
7509: PPUSH
7510: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
7514: LD_ADDR_VAR 0 2
7518: PUSH
7519: LD_VAR 0 2
7523: PPUSH
7524: LD_VAR 0 2
7528: PUSH
7529: LD_INT 1
7531: PLUS
7532: PPUSH
7533: LD_VAR 0 3
7537: PPUSH
7538: CALL_OW 1
7542: ST_TO_ADDR
// end ;
7543: GO 7417
7545: POP
7546: POP
// for i = 1 to 4 do
7547: LD_ADDR_VAR 0 1
7551: PUSH
7552: DOUBLE
7553: LD_INT 1
7555: DEC
7556: ST_TO_ADDR
7557: LD_INT 4
7559: PUSH
7560: FOR_TO
7561: IFFALSE 7632
// begin PrepareHuman ( false , 1 , 6 ) ;
7563: LD_INT 0
7565: PPUSH
7566: LD_INT 1
7568: PPUSH
7569: LD_INT 6
7571: PPUSH
7572: CALL_OW 380
// un := CreateHuman ;
7576: LD_ADDR_VAR 0 3
7580: PUSH
7581: CALL_OW 44
7585: ST_TO_ADDR
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
7586: LD_VAR 0 3
7590: PPUSH
7591: LD_INT 15
7593: PPUSH
7594: LD_INT 0
7596: PPUSH
7597: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
7601: LD_ADDR_VAR 0 2
7605: PUSH
7606: LD_VAR 0 2
7610: PPUSH
7611: LD_VAR 0 2
7615: PUSH
7616: LD_INT 1
7618: PLUS
7619: PPUSH
7620: LD_VAR 0 3
7624: PPUSH
7625: CALL_OW 1
7629: ST_TO_ADDR
// end ;
7630: GO 7560
7632: POP
7633: POP
// wait ( 0 0$3 ) ;
7634: LD_INT 105
7636: PPUSH
7637: CALL_OW 67
// for i in tmp do
7641: LD_ADDR_VAR 0 1
7645: PUSH
7646: LD_VAR 0 2
7650: PUSH
7651: FOR_IN
7652: IFFALSE 7720
// if GetClass ( i ) = 1 or GetType ( i ) = unit_vehicle then
7654: LD_VAR 0 1
7658: PPUSH
7659: CALL_OW 257
7663: PUSH
7664: LD_INT 1
7666: EQUAL
7667: PUSH
7668: LD_VAR 0 1
7672: PPUSH
7673: CALL_OW 247
7677: PUSH
7678: LD_INT 2
7680: EQUAL
7681: OR
7682: IFFALSE 7718
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
7684: LD_VAR 0 1
7688: PPUSH
7689: LD_INT 81
7691: PUSH
7692: LD_INT 8
7694: PUSH
7695: EMPTY
7696: LIST
7697: LIST
7698: PPUSH
7699: CALL_OW 69
7703: PPUSH
7704: LD_VAR 0 1
7708: PPUSH
7709: CALL_OW 74
7713: PPUSH
7714: CALL_OW 115
7718: GO 7651
7720: POP
7721: POP
// repeat AddComAgressiveMove ( tmp , 210 , 178 ) ;
7722: LD_VAR 0 2
7726: PPUSH
7727: LD_INT 210
7729: PPUSH
7730: LD_INT 178
7732: PPUSH
7733: CALL_OW 174
// x := FilterUnitsInArea ( escape_area , [ f_side , 8 ] ) ;
7737: LD_ADDR_VAR 0 4
7741: PUSH
7742: LD_INT 10
7744: PPUSH
7745: LD_INT 22
7747: PUSH
7748: LD_INT 8
7750: PUSH
7751: EMPTY
7752: LIST
7753: LIST
7754: PPUSH
7755: CALL_OW 70
7759: ST_TO_ADDR
// if x then
7760: LD_VAR 0 4
7764: IFFALSE 7792
// for i in x do
7766: LD_ADDR_VAR 0 1
7770: PUSH
7771: LD_VAR 0 4
7775: PUSH
7776: FOR_IN
7777: IFFALSE 7790
// RemoveUnit ( i ) ;
7779: LD_VAR 0 1
7783: PPUSH
7784: CALL_OW 64
7788: GO 7776
7790: POP
7791: POP
// wait ( 0 0$1 ) ;
7792: LD_INT 35
7794: PPUSH
7795: CALL_OW 67
// until not FilterAllUnits ( [ f_side , 8 ] ) ;
7799: LD_INT 22
7801: PUSH
7802: LD_INT 8
7804: PUSH
7805: EMPTY
7806: LIST
7807: LIST
7808: PPUSH
7809: CALL_OW 69
7813: NOT
7814: IFFALSE 7722
// end ;
7816: PPOPN 4
7818: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
7819: LD_INT 22
7821: PUSH
7822: LD_INT 2
7824: PUSH
7825: EMPTY
7826: LIST
7827: LIST
7828: PUSH
7829: LD_INT 34
7831: PUSH
7832: LD_INT 31
7834: PUSH
7835: EMPTY
7836: LIST
7837: LIST
7838: PUSH
7839: LD_INT 3
7841: PUSH
7842: LD_INT 24
7844: PUSH
7845: LD_INT 1000
7847: PUSH
7848: EMPTY
7849: LIST
7850: LIST
7851: PUSH
7852: EMPTY
7853: LIST
7854: LIST
7855: PUSH
7856: EMPTY
7857: LIST
7858: LIST
7859: LIST
7860: PPUSH
7861: CALL_OW 69
7865: IFFALSE 7968
7867: GO 7869
7869: DISABLE
// begin if IsOk ( ar_dep_w ) and GetSide ( ar_dep_w ) then
7870: LD_INT 45
7872: PPUSH
7873: CALL_OW 302
7877: PUSH
7878: LD_INT 45
7880: PPUSH
7881: CALL_OW 255
7885: AND
7886: IFFALSE 7929
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 18 , 8 ) else
7888: LD_INT 22
7890: PUSH
7891: LD_INT 2
7893: PUSH
7894: EMPTY
7895: LIST
7896: LIST
7897: PUSH
7898: LD_INT 34
7900: PUSH
7901: LD_INT 31
7903: PUSH
7904: EMPTY
7905: LIST
7906: LIST
7907: PUSH
7908: EMPTY
7909: LIST
7910: LIST
7911: PPUSH
7912: CALL_OW 69
7916: PPUSH
7917: LD_INT 18
7919: PPUSH
7920: LD_INT 8
7922: PPUSH
7923: CALL_OW 111
7927: GO 7968
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 106 , 14 ) ;
7929: LD_INT 22
7931: PUSH
7932: LD_INT 2
7934: PUSH
7935: EMPTY
7936: LIST
7937: LIST
7938: PUSH
7939: LD_INT 34
7941: PUSH
7942: LD_INT 31
7944: PUSH
7945: EMPTY
7946: LIST
7947: LIST
7948: PUSH
7949: EMPTY
7950: LIST
7951: LIST
7952: PPUSH
7953: CALL_OW 69
7957: PPUSH
7958: LD_INT 106
7960: PPUSH
7961: LD_INT 14
7963: PPUSH
7964: CALL_OW 111
// end ; end_of_file
7968: END
// export function Action ; var tmp , p , radar , sols , i ; begin
7969: LD_INT 0
7971: PPUSH
7972: PPUSH
7973: PPUSH
7974: PPUSH
7975: PPUSH
7976: PPUSH
// InGameOn ;
7977: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
7981: LD_EXP 21
7985: PPUSH
7986: CALL_OW 87
// SetAttitude ( 2 , 1 , att_friend , true ) ;
7990: LD_INT 2
7992: PPUSH
7993: LD_INT 1
7995: PPUSH
7996: LD_INT 1
7998: PPUSH
7999: LD_INT 1
8001: PPUSH
8002: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) ;
8006: LD_ADDR_VAR 0 2
8010: PUSH
8011: LD_INT 22
8013: PUSH
8014: LD_INT 1
8016: PUSH
8017: EMPTY
8018: LIST
8019: LIST
8020: PUSH
8021: LD_INT 25
8023: PUSH
8024: LD_INT 1
8026: PUSH
8027: EMPTY
8028: LIST
8029: LIST
8030: PUSH
8031: EMPTY
8032: LIST
8033: LIST
8034: PPUSH
8035: CALL_OW 69
8039: ST_TO_ADDR
// radar := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_radar ] ] ) [ 1 ] ;
8040: LD_ADDR_VAR 0 4
8044: PUSH
8045: LD_INT 22
8047: PUSH
8048: LD_INT 1
8050: PUSH
8051: EMPTY
8052: LIST
8053: LIST
8054: PUSH
8055: LD_INT 34
8057: PUSH
8058: LD_INT 11
8060: PUSH
8061: EMPTY
8062: LIST
8063: LIST
8064: PUSH
8065: EMPTY
8066: LIST
8067: LIST
8068: PPUSH
8069: CALL_OW 69
8073: PUSH
8074: LD_INT 1
8076: ARRAY
8077: ST_TO_ADDR
// for i = 1 to tmp do
8078: LD_ADDR_VAR 0 6
8082: PUSH
8083: DOUBLE
8084: LD_INT 1
8086: DEC
8087: ST_TO_ADDR
8088: LD_VAR 0 2
8092: PUSH
8093: FOR_TO
8094: IFFALSE 8141
// begin if i = 5 then
8096: LD_VAR 0 6
8100: PUSH
8101: LD_INT 5
8103: EQUAL
8104: IFFALSE 8108
// break ;
8106: GO 8141
// sols := Replace ( sols , i , tmp [ i ] ) ;
8108: LD_ADDR_VAR 0 5
8112: PUSH
8113: LD_VAR 0 5
8117: PPUSH
8118: LD_VAR 0 6
8122: PPUSH
8123: LD_VAR 0 2
8127: PUSH
8128: LD_VAR 0 6
8132: ARRAY
8133: PPUSH
8134: CALL_OW 1
8138: ST_TO_ADDR
// end ;
8139: GO 8093
8141: POP
8142: POP
// tmp := ar_force_tmp ;
8143: LD_ADDR_VAR 0 2
8147: PUSH
8148: LD_EXP 40
8152: ST_TO_ADDR
// PlaceUnitXY ( tmp [ 1 ] , 108 , 139 , false ) ;
8153: LD_VAR 0 2
8157: PUSH
8158: LD_INT 1
8160: ARRAY
8161: PPUSH
8162: LD_INT 108
8164: PPUSH
8165: LD_INT 139
8167: PPUSH
8168: LD_INT 0
8170: PPUSH
8171: CALL_OW 48
// ComTurnUnit ( tmp [ 1 ] , JMM ) ;
8175: LD_VAR 0 2
8179: PUSH
8180: LD_INT 1
8182: ARRAY
8183: PPUSH
8184: LD_EXP 21
8188: PPUSH
8189: CALL_OW 119
// PlaceUnitXY ( tmp [ 2 ] , 114 , 132 , false ) ;
8193: LD_VAR 0 2
8197: PUSH
8198: LD_INT 2
8200: ARRAY
8201: PPUSH
8202: LD_INT 114
8204: PPUSH
8205: LD_INT 132
8207: PPUSH
8208: LD_INT 0
8210: PPUSH
8211: CALL_OW 48
// PlaceUnitXY ( tmp [ 3 ] , 115 , 132 , false ) ;
8215: LD_VAR 0 2
8219: PUSH
8220: LD_INT 3
8222: ARRAY
8223: PPUSH
8224: LD_INT 115
8226: PPUSH
8227: LD_INT 132
8229: PPUSH
8230: LD_INT 0
8232: PPUSH
8233: CALL_OW 48
// ComHold ( [ tmp [ 2 ] , tmp [ 3 ] ] ) ;
8237: LD_VAR 0 2
8241: PUSH
8242: LD_INT 2
8244: ARRAY
8245: PUSH
8246: LD_VAR 0 2
8250: PUSH
8251: LD_INT 3
8253: ARRAY
8254: PUSH
8255: EMPTY
8256: LIST
8257: LIST
8258: PPUSH
8259: CALL_OW 140
// ComMoveXY ( radar , 83 , 123 ) ;
8263: LD_VAR 0 4
8267: PPUSH
8268: LD_INT 83
8270: PPUSH
8271: LD_INT 123
8273: PPUSH
8274: CALL_OW 111
// Wait ( 0 0$01 ) ;
8278: LD_INT 35
8280: PPUSH
8281: CALL_OW 67
// CenterOnXY ( 90 , 144 ) ;
8285: LD_INT 90
8287: PPUSH
8288: LD_INT 144
8290: PPUSH
8291: CALL_OW 84
// ComMoveXY ( sols , 88 , 129 ) ;
8295: LD_VAR 0 5
8299: PPUSH
8300: LD_INT 88
8302: PPUSH
8303: LD_INT 129
8305: PPUSH
8306: CALL_OW 111
// p := [ [ 92 , 131 ] , [ 88 , 127 ] , [ 91 , 132 ] , [ 92 , 134 ] ] ;
8310: LD_ADDR_VAR 0 3
8314: PUSH
8315: LD_INT 92
8317: PUSH
8318: LD_INT 131
8320: PUSH
8321: EMPTY
8322: LIST
8323: LIST
8324: PUSH
8325: LD_INT 88
8327: PUSH
8328: LD_INT 127
8330: PUSH
8331: EMPTY
8332: LIST
8333: LIST
8334: PUSH
8335: LD_INT 91
8337: PUSH
8338: LD_INT 132
8340: PUSH
8341: EMPTY
8342: LIST
8343: LIST
8344: PUSH
8345: LD_INT 92
8347: PUSH
8348: LD_INT 134
8350: PUSH
8351: EMPTY
8352: LIST
8353: LIST
8354: PUSH
8355: EMPTY
8356: LIST
8357: LIST
8358: LIST
8359: LIST
8360: ST_TO_ADDR
// for i = 1 to sols do
8361: LD_ADDR_VAR 0 6
8365: PUSH
8366: DOUBLE
8367: LD_INT 1
8369: DEC
8370: ST_TO_ADDR
8371: LD_VAR 0 5
8375: PUSH
8376: FOR_TO
8377: IFFALSE 8450
// begin AddComMoveXY ( sols [ i ] , p [ i ] [ 1 ] , p [ i ] [ 2 ] ) ;
8379: LD_VAR 0 5
8383: PUSH
8384: LD_VAR 0 6
8388: ARRAY
8389: PPUSH
8390: LD_VAR 0 3
8394: PUSH
8395: LD_VAR 0 6
8399: ARRAY
8400: PUSH
8401: LD_INT 1
8403: ARRAY
8404: PPUSH
8405: LD_VAR 0 3
8409: PUSH
8410: LD_VAR 0 6
8414: ARRAY
8415: PUSH
8416: LD_INT 2
8418: ARRAY
8419: PPUSH
8420: CALL_OW 171
// AddComCrawl ( sols [ i ] ) ;
8424: LD_VAR 0 5
8428: PUSH
8429: LD_VAR 0 6
8433: ARRAY
8434: PPUSH
8435: CALL_OW 197
// AddComHold ( sols ) ;
8439: LD_VAR 0 5
8443: PPUSH
8444: CALL_OW 200
// end ;
8448: GO 8376
8450: POP
8451: POP
// repeat wait ( 0 0$1 ) ;
8452: LD_INT 35
8454: PPUSH
8455: CALL_OW 67
// until GetDistUnitXY ( sols [ 1 ] , 92 , 131 ) < 4 ;
8459: LD_VAR 0 5
8463: PUSH
8464: LD_INT 1
8466: ARRAY
8467: PPUSH
8468: LD_INT 92
8470: PPUSH
8471: LD_INT 131
8473: PPUSH
8474: CALL_OW 297
8478: PUSH
8479: LD_INT 4
8481: LESS
8482: IFFALSE 8452
// CenterOnXY ( 96 , 139 ) ;
8484: LD_INT 96
8486: PPUSH
8487: LD_INT 139
8489: PPUSH
8490: CALL_OW 84
// wait ( 0 0$3 ) ;
8494: LD_INT 105
8496: PPUSH
8497: CALL_OW 67
// PlaceSeeing ( 111 , 135 , 1 , - 25 ) ;
8501: LD_INT 111
8503: PPUSH
8504: LD_INT 135
8506: PPUSH
8507: LD_INT 1
8509: PPUSH
8510: LD_INT 25
8512: NEG
8513: PPUSH
8514: CALL_OW 330
// ComMoveXY ( tmp [ 2 ] , GetX ( tmp [ 1 ] ) + 3 , GetY ( tmp [ 1 ] ) ) ;
8518: LD_VAR 0 2
8522: PUSH
8523: LD_INT 2
8525: ARRAY
8526: PPUSH
8527: LD_VAR 0 2
8531: PUSH
8532: LD_INT 1
8534: ARRAY
8535: PPUSH
8536: CALL_OW 250
8540: PUSH
8541: LD_INT 3
8543: PLUS
8544: PPUSH
8545: LD_VAR 0 2
8549: PUSH
8550: LD_INT 1
8552: ARRAY
8553: PPUSH
8554: CALL_OW 251
8558: PPUSH
8559: CALL_OW 111
// ComEnterUnit ( tmp [ 3 ] , ar_dep_s ) ;
8563: LD_VAR 0 2
8567: PUSH
8568: LD_INT 3
8570: ARRAY
8571: PPUSH
8572: LD_INT 7
8574: PPUSH
8575: CALL_OW 120
// AddComTurnUnit ( tmp [ 2 ] , tmp [ 1 ] ) ;
8579: LD_VAR 0 2
8583: PUSH
8584: LD_INT 2
8586: ARRAY
8587: PPUSH
8588: LD_VAR 0 2
8592: PUSH
8593: LD_INT 1
8595: ARRAY
8596: PPUSH
8597: CALL_OW 179
// repeat wait ( 0 0$1 ) ;
8601: LD_INT 35
8603: PPUSH
8604: CALL_OW 67
// until GetDistUnits ( tmp [ 1 ] , tmp [ 2 ] ) < 5 ;
8608: LD_VAR 0 2
8612: PUSH
8613: LD_INT 1
8615: ARRAY
8616: PPUSH
8617: LD_VAR 0 2
8621: PUSH
8622: LD_INT 2
8624: ARRAY
8625: PPUSH
8626: CALL_OW 296
8630: PUSH
8631: LD_INT 5
8633: LESS
8634: IFFALSE 8601
// ComTurnUnit ( tmp [ 1 ] , tmp [ 2 ] ) ;
8636: LD_VAR 0 2
8640: PUSH
8641: LD_INT 1
8643: ARRAY
8644: PPUSH
8645: LD_VAR 0 2
8649: PUSH
8650: LD_INT 2
8652: ARRAY
8653: PPUSH
8654: CALL_OW 119
// Say ( tmp [ 1 ] , D1a-Merc1-1 ) ;
8658: LD_VAR 0 2
8662: PUSH
8663: LD_INT 1
8665: ARRAY
8666: PPUSH
8667: LD_STRING D1a-Merc1-1
8669: PPUSH
8670: CALL_OW 88
// Say ( tmp [ 2 ] , D1a-FMerc2-1 ) ;
8674: LD_VAR 0 2
8678: PUSH
8679: LD_INT 2
8681: ARRAY
8682: PPUSH
8683: LD_STRING D1a-FMerc2-1
8685: PPUSH
8686: CALL_OW 88
// ComHeal ( tmp [ 2 ] , tmp [ 1 ] ) ;
8690: LD_VAR 0 2
8694: PUSH
8695: LD_INT 2
8697: ARRAY
8698: PPUSH
8699: LD_VAR 0 2
8703: PUSH
8704: LD_INT 1
8706: ARRAY
8707: PPUSH
8708: CALL_OW 128
// SetLives ( tmp [ 1 ] , 500 ) ;
8712: LD_VAR 0 2
8716: PUSH
8717: LD_INT 1
8719: ARRAY
8720: PPUSH
8721: LD_INT 500
8723: PPUSH
8724: CALL_OW 234
// wait ( 0 0$2 ) ;
8728: LD_INT 70
8730: PPUSH
8731: CALL_OW 67
// SetLives ( tmp [ 1 ] , 2 ) ;
8735: LD_VAR 0 2
8739: PUSH
8740: LD_INT 1
8742: ARRAY
8743: PPUSH
8744: LD_INT 2
8746: PPUSH
8747: CALL_OW 234
// wait ( 0 0$0.3 ) ;
8751: LD_INT 10
8753: PPUSH
8754: CALL_OW 67
// ForceSay ( tmp [ 1 ] , D1a-Merc1-2 ) ;
8758: LD_VAR 0 2
8762: PUSH
8763: LD_INT 1
8765: ARRAY
8766: PPUSH
8767: LD_STRING D1a-Merc1-2
8769: PPUSH
8770: CALL_OW 91
// wait ( 0 0$0.2 ) ;
8774: LD_INT 7
8776: PPUSH
8777: CALL_OW 67
// KillUnit ( tmp [ 1 ] ) ;
8781: LD_VAR 0 2
8785: PUSH
8786: LD_INT 1
8788: ARRAY
8789: PPUSH
8790: CALL_OW 66
// ComMoveToArea ( tmp [ 2 ] , escape_area ) ;
8794: LD_VAR 0 2
8798: PUSH
8799: LD_INT 2
8801: ARRAY
8802: PPUSH
8803: LD_INT 10
8805: PPUSH
8806: CALL_OW 113
// Say ( tmp [ 2 ] , D1a-FMerc2-2 ) ;
8810: LD_VAR 0 2
8814: PUSH
8815: LD_INT 2
8817: ARRAY
8818: PPUSH
8819: LD_STRING D1a-FMerc2-2
8821: PPUSH
8822: CALL_OW 88
// wait ( 0 0$1 ) ;
8826: LD_INT 35
8828: PPUSH
8829: CALL_OW 67
// CenterOnUnits ( ar_dep_s ) ;
8833: LD_INT 7
8835: PPUSH
8836: CALL_OW 85
// wait ( 0 0$2 ) ;
8840: LD_INT 70
8842: PPUSH
8843: CALL_OW 67
// ForceSay ( Saliba , D1a-Saliba-1 ) ;
8847: LD_EXP 44
8851: PPUSH
8852: LD_STRING D1a-Saliba-1
8854: PPUSH
8855: CALL_OW 91
// KillUnit ( Saliba ) ;
8859: LD_EXP 44
8863: PPUSH
8864: CALL_OW 66
// ComExitBuilding ( tmp [ 3 ] ) ;
8868: LD_VAR 0 2
8872: PUSH
8873: LD_INT 3
8875: ARRAY
8876: PPUSH
8877: CALL_OW 122
// CenterOnUnits ( JMM ) ;
8881: LD_EXP 21
8885: PPUSH
8886: CALL_OW 85
// wait ( 0 0$1 ) ;
8890: LD_INT 35
8892: PPUSH
8893: CALL_OW 67
// ComMoveXY ( sols , 88 , 141 ) ;
8897: LD_VAR 0 5
8901: PPUSH
8902: LD_INT 88
8904: PPUSH
8905: LD_INT 141
8907: PPUSH
8908: CALL_OW 111
// AddComWait ( sols , 0 0$2 ) ;
8912: LD_VAR 0 5
8916: PPUSH
8917: LD_INT 70
8919: PPUSH
8920: CALL_OW 202
// wait ( 0 0$2 ) ;
8924: LD_INT 70
8926: PPUSH
8927: CALL_OW 67
// SetAttitude ( 2 , 1 , att_enemy , true ) ;
8931: LD_INT 2
8933: PPUSH
8934: LD_INT 1
8936: PPUSH
8937: LD_INT 2
8939: PPUSH
8940: LD_INT 1
8942: PPUSH
8943: CALL_OW 80
// InGameOff ;
8947: CALL_OW 9
// ComWalk ( sols ) ;
8951: LD_VAR 0 5
8955: PPUSH
8956: CALL_OW 138
// ChangeMissionObjectives ( M1 ) ;
8960: LD_STRING M1
8962: PPUSH
8963: CALL_OW 337
// game_speed := 4 ;
8967: LD_ADDR_OWVAR 65
8971: PUSH
8972: LD_INT 4
8974: ST_TO_ADDR
// RemoveSeeing ( 111 , 135 , 1 ) ;
8975: LD_INT 111
8977: PPUSH
8978: LD_INT 135
8980: PPUSH
8981: LD_INT 1
8983: PPUSH
8984: CALL_OW 331
// SaveForQuickRestart ;
8988: CALL_OW 22
// ar_run := true ;
8992: LD_ADDR_EXP 5
8996: PUSH
8997: LD_INT 1
8999: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9000: LD_INT 35
9002: PPUSH
9003: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 1 ] , [ f_dist , ar_dep_s , 10 ] ] ) or GetLives ( ar_dep_s ) < 999 ;
9007: LD_INT 22
9009: PUSH
9010: LD_INT 1
9012: PUSH
9013: EMPTY
9014: LIST
9015: LIST
9016: PUSH
9017: LD_INT 91
9019: PUSH
9020: LD_INT 7
9022: PUSH
9023: LD_INT 10
9025: PUSH
9026: EMPTY
9027: LIST
9028: LIST
9029: LIST
9030: PUSH
9031: EMPTY
9032: LIST
9033: LIST
9034: PPUSH
9035: CALL_OW 69
9039: PUSH
9040: LD_INT 7
9042: PPUSH
9043: CALL_OW 256
9047: PUSH
9048: LD_INT 999
9050: LESS
9051: OR
9052: IFFALSE 9000
// if GetSide ( ar_dep_s ) = 2 then
9054: LD_INT 7
9056: PPUSH
9057: CALL_OW 255
9061: PUSH
9062: LD_INT 2
9064: EQUAL
9065: IFFALSE 9077
// SetSide ( ar_dep_s , 1 ) ;
9067: LD_INT 7
9069: PPUSH
9070: LD_INT 1
9072: PPUSH
9073: CALL_OW 235
// end ;
9077: LD_VAR 0 1
9081: RET
// every 0 0$2 trigger ar_run do var i , tmp , k ;
9082: LD_EXP 5
9086: IFFALSE 9446
9088: GO 9090
9090: DISABLE
9091: LD_INT 0
9093: PPUSH
9094: PPUSH
9095: PPUSH
// begin tmp := ar_force_tmp ^ UnitFilter ( ar_force_south , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ) ;
9096: LD_ADDR_VAR 0 2
9100: PUSH
9101: LD_EXP 40
9105: PUSH
9106: LD_EXP 36
9110: PPUSH
9111: LD_INT 2
9113: PUSH
9114: LD_INT 21
9116: PUSH
9117: LD_INT 2
9119: PUSH
9120: EMPTY
9121: LIST
9122: LIST
9123: PUSH
9124: LD_INT 21
9126: PUSH
9127: LD_INT 1
9129: PUSH
9130: EMPTY
9131: LIST
9132: LIST
9133: PUSH
9134: EMPTY
9135: LIST
9136: LIST
9137: LIST
9138: PPUSH
9139: CALL_OW 72
9143: ADD
9144: ST_TO_ADDR
// SetSide ( tmp , 5 ) ;
9145: LD_VAR 0 2
9149: PPUSH
9150: LD_INT 5
9152: PPUSH
9153: CALL_OW 235
// ChangeSideFog ( 5 , 1 ) ;
9157: LD_INT 5
9159: PPUSH
9160: LD_INT 1
9162: PPUSH
9163: CALL_OW 343
// k := 1 ;
9167: LD_ADDR_VAR 0 3
9171: PUSH
9172: LD_INT 1
9174: ST_TO_ADDR
// for i in tmp do
9175: LD_ADDR_VAR 0 1
9179: PUSH
9180: LD_VAR 0 2
9184: PUSH
9185: FOR_IN
9186: IFFALSE 9271
// begin if IsInUnit ( i ) then
9188: LD_VAR 0 1
9192: PPUSH
9193: CALL_OW 310
9197: IFFALSE 9208
// ComExitBuilding ( i ) ;
9199: LD_VAR 0 1
9203: PPUSH
9204: CALL_OW 122
// if GetClass ( i ) = 3 then
9208: LD_VAR 0 1
9212: PPUSH
9213: CALL_OW 257
9217: PUSH
9218: LD_INT 3
9220: EQUAL
9221: IFFALSE 9257
// begin AddComEnterUnit ( i , ar_vehicles_tmp [ k ] ) ;
9223: LD_VAR 0 1
9227: PPUSH
9228: LD_EXP 41
9232: PUSH
9233: LD_VAR 0 3
9237: ARRAY
9238: PPUSH
9239: CALL_OW 180
// k := k + 1 ;
9243: LD_ADDR_VAR 0 3
9247: PUSH
9248: LD_VAR 0 3
9252: PUSH
9253: LD_INT 1
9255: PLUS
9256: ST_TO_ADDR
// end ; AddComMoveToArea ( i , escape_area ) ;
9257: LD_VAR 0 1
9261: PPUSH
9262: LD_INT 10
9264: PPUSH
9265: CALL_OW 173
// end ;
9269: GO 9185
9271: POP
9272: POP
// ar_patrol := true ;
9273: LD_ADDR_EXP 7
9277: PUSH
9278: LD_INT 1
9280: ST_TO_ADDR
// repeat wait ( 0 0$0.3 ) ;
9281: LD_INT 10
9283: PPUSH
9284: CALL_OW 67
// for i in tmp do
9288: LD_ADDR_VAR 0 1
9292: PUSH
9293: LD_VAR 0 2
9297: PUSH
9298: FOR_IN
9299: IFFALSE 9327
// if not HasTask ( i ) then
9301: LD_VAR 0 1
9305: PPUSH
9306: CALL_OW 314
9310: NOT
9311: IFFALSE 9325
// ComMoveToArea ( i , escape_area ) ;
9313: LD_VAR 0 1
9317: PPUSH
9318: LD_INT 10
9320: PPUSH
9321: CALL_OW 113
9325: GO 9298
9327: POP
9328: POP
// k := UnitFilter ( tmp , [ f_inarea , escape_area ] ) ;
9329: LD_ADDR_VAR 0 3
9333: PUSH
9334: LD_VAR 0 2
9338: PPUSH
9339: LD_INT 95
9341: PUSH
9342: LD_INT 10
9344: PUSH
9345: EMPTY
9346: LIST
9347: LIST
9348: PPUSH
9349: CALL_OW 72
9353: ST_TO_ADDR
// if k then
9354: LD_VAR 0 3
9358: IFFALSE 9427
// for i in k do
9360: LD_ADDR_VAR 0 1
9364: PUSH
9365: LD_VAR 0 3
9369: PUSH
9370: FOR_IN
9371: IFFALSE 9425
// begin if IsInUnit ( i ) then
9373: LD_VAR 0 1
9377: PPUSH
9378: CALL_OW 310
9382: IFFALSE 9398
// RemoveUnit ( IsInUnit ( i ) ) ;
9384: LD_VAR 0 1
9388: PPUSH
9389: CALL_OW 310
9393: PPUSH
9394: CALL_OW 64
// RemoveUnit ( i ) ;
9398: LD_VAR 0 1
9402: PPUSH
9403: CALL_OW 64
// tmp := tmp diff i ;
9407: LD_ADDR_VAR 0 2
9411: PUSH
9412: LD_VAR 0 2
9416: PUSH
9417: LD_VAR 0 1
9421: DIFF
9422: ST_TO_ADDR
// end ;
9423: GO 9370
9425: POP
9426: POP
// until tmp = [ ] ;
9427: LD_VAR 0 2
9431: PUSH
9432: EMPTY
9433: EQUAL
9434: IFFALSE 9281
// ChangeSideFog ( 5 , 5 ) ;
9436: LD_INT 5
9438: PPUSH
9439: LD_INT 5
9441: PPUSH
9442: CALL_OW 343
// end ;
9446: PPOPN 3
9448: END
// every 0 0$03 trigger ar_patrol do var i , un , veh ;
9449: LD_EXP 7
9453: IFFALSE 9743
9455: GO 9457
9457: DISABLE
9458: LD_INT 0
9460: PPUSH
9461: PPUSH
9462: PPUSH
// begin uc_side := 2 ;
9463: LD_ADDR_OWVAR 20
9467: PUSH
9468: LD_INT 2
9470: ST_TO_ADDR
// uc_nation := 2 ;
9471: LD_ADDR_OWVAR 21
9475: PUSH
9476: LD_INT 2
9478: ST_TO_ADDR
// InitHc ;
9479: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
9483: LD_INT 1
9485: PPUSH
9486: LD_INT 1
9488: PPUSH
9489: LD_INT 6
9491: PPUSH
9492: CALL_OW 380
// un := CreateHuman ;
9496: LD_ADDR_VAR 0 2
9500: PUSH
9501: CALL_OW 44
9505: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_combustion , control_manual , ar_gun , 98 ) ;
9506: LD_INT 14
9508: PPUSH
9509: LD_INT 1
9511: PPUSH
9512: LD_INT 1
9514: PPUSH
9515: LD_INT 27
9517: PPUSH
9518: LD_INT 98
9520: PPUSH
9521: CALL 54433 0 5
// veh := CreateVehicle ;
9525: LD_ADDR_VAR 0 3
9529: PUSH
9530: CALL_OW 45
9534: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
9535: LD_VAR 0 3
9539: PPUSH
9540: LD_INT 4
9542: PPUSH
9543: CALL_OW 233
// PlaceUnitXY ( veh , 179 , 135 , false ) ;
9547: LD_VAR 0 3
9551: PPUSH
9552: LD_INT 179
9554: PPUSH
9555: LD_INT 135
9557: PPUSH
9558: LD_INT 0
9560: PPUSH
9561: CALL_OW 48
// PlaceHumanInUnit ( un , veh ) ;
9565: LD_VAR 0 2
9569: PPUSH
9570: LD_VAR 0 3
9574: PPUSH
9575: CALL_OW 52
// ComMoveXY ( un , 126 , 133 ) ;
9579: LD_VAR 0 2
9583: PPUSH
9584: LD_INT 126
9586: PPUSH
9587: LD_INT 133
9589: PPUSH
9590: CALL_OW 111
// repeat wait ( 0 0$0.3 ) ;
9594: LD_INT 10
9596: PPUSH
9597: CALL_OW 67
// until See ( 1 , veh ) or GetDistUnits ( veh , ar_dep_s ) < 9 ;
9601: LD_INT 1
9603: PPUSH
9604: LD_VAR 0 3
9608: PPUSH
9609: CALL_OW 292
9613: PUSH
9614: LD_VAR 0 3
9618: PPUSH
9619: LD_INT 7
9621: PPUSH
9622: CALL_OW 296
9626: PUSH
9627: LD_INT 9
9629: LESS
9630: OR
9631: IFFALSE 9594
// ComHold ( veh ) ;
9633: LD_VAR 0 3
9637: PPUSH
9638: CALL_OW 140
// Say ( un , D2aa-Ar1-1 ) ;
9642: LD_VAR 0 2
9646: PPUSH
9647: LD_STRING D2aa-Ar1-1
9649: PPUSH
9650: CALL_OW 88
// ComMoveXY ( un , 177 , 96 ) ;
9654: LD_VAR 0 2
9658: PPUSH
9659: LD_INT 177
9661: PPUSH
9662: LD_INT 96
9664: PPUSH
9665: CALL_OW 111
// AddComExitVehicle ( un ) ;
9669: LD_VAR 0 2
9673: PPUSH
9674: CALL_OW 181
// repeat wait ( 0 0$1 ) ;
9678: LD_INT 35
9680: PPUSH
9681: CALL_OW 67
// until GetDistUnits ( un , ar_dep_e ) < 15 ;
9685: LD_VAR 0 2
9689: PPUSH
9690: LD_INT 204
9692: PPUSH
9693: CALL_OW 296
9697: PUSH
9698: LD_INT 15
9700: LESS
9701: IFFALSE 9678
// mc_bases := ReplaceIn ( mc_bases , [ 3 , mc_bases [ 3 ] + 1 ] , un ) ;
9703: LD_ADDR_EXP 50
9707: PUSH
9708: LD_EXP 50
9712: PPUSH
9713: LD_INT 3
9715: PUSH
9716: LD_EXP 50
9720: PUSH
9721: LD_INT 3
9723: ARRAY
9724: PUSH
9725: LD_INT 1
9727: PLUS
9728: PUSH
9729: EMPTY
9730: LIST
9731: LIST
9732: PPUSH
9733: LD_VAR 0 2
9737: PPUSH
9738: CALL 54555 0 3
9742: ST_TO_ADDR
// end ;
9743: PPOPN 3
9745: END
// every 0 0$2 trigger GetSide ( ar_dep_s ) = 1 or IsDead ( ar_dep_s ) do var i , points ;
9746: LD_INT 7
9748: PPUSH
9749: CALL_OW 255
9753: PUSH
9754: LD_INT 1
9756: EQUAL
9757: PUSH
9758: LD_INT 7
9760: PPUSH
9761: CALL_OW 301
9765: OR
9766: IFFALSE 12190
9768: GO 9770
9770: DISABLE
9771: LD_INT 0
9773: PPUSH
9774: PPUSH
// begin for i in UnitFilter ( ar_force_south , [ f_type , unit_building ] ) do
9775: LD_ADDR_VAR 0 1
9779: PUSH
9780: LD_EXP 36
9784: PPUSH
9785: LD_INT 21
9787: PUSH
9788: LD_INT 3
9790: PUSH
9791: EMPTY
9792: LIST
9793: LIST
9794: PPUSH
9795: CALL_OW 72
9799: PUSH
9800: FOR_IN
9801: IFFALSE 9817
// SetSide ( i , 1 ) ;
9803: LD_VAR 0 1
9807: PPUSH
9808: LD_INT 1
9810: PPUSH
9811: CALL_OW 235
9815: GO 9800
9817: POP
9818: POP
// points := [ [ 46 , 41 ] , [ 50 , 25 ] , [ 57 , 75 ] , [ 75 , 89 ] , [ 51 , 45 ] , [ 95 , 95 ] , [ 84 , 77 ] , [ 101 , 76 ] , [ 118 , 81 ] , [ 139 , 97 ] , [ 129 , 114 ] , [ 154 , 111 ] ] ;
9819: LD_ADDR_VAR 0 2
9823: PUSH
9824: LD_INT 46
9826: PUSH
9827: LD_INT 41
9829: PUSH
9830: EMPTY
9831: LIST
9832: LIST
9833: PUSH
9834: LD_INT 50
9836: PUSH
9837: LD_INT 25
9839: PUSH
9840: EMPTY
9841: LIST
9842: LIST
9843: PUSH
9844: LD_INT 57
9846: PUSH
9847: LD_INT 75
9849: PUSH
9850: EMPTY
9851: LIST
9852: LIST
9853: PUSH
9854: LD_INT 75
9856: PUSH
9857: LD_INT 89
9859: PUSH
9860: EMPTY
9861: LIST
9862: LIST
9863: PUSH
9864: LD_INT 51
9866: PUSH
9867: LD_INT 45
9869: PUSH
9870: EMPTY
9871: LIST
9872: LIST
9873: PUSH
9874: LD_INT 95
9876: PUSH
9877: LD_INT 95
9879: PUSH
9880: EMPTY
9881: LIST
9882: LIST
9883: PUSH
9884: LD_INT 84
9886: PUSH
9887: LD_INT 77
9889: PUSH
9890: EMPTY
9891: LIST
9892: LIST
9893: PUSH
9894: LD_INT 101
9896: PUSH
9897: LD_INT 76
9899: PUSH
9900: EMPTY
9901: LIST
9902: LIST
9903: PUSH
9904: LD_INT 118
9906: PUSH
9907: LD_INT 81
9909: PUSH
9910: EMPTY
9911: LIST
9912: LIST
9913: PUSH
9914: LD_INT 139
9916: PUSH
9917: LD_INT 97
9919: PUSH
9920: EMPTY
9921: LIST
9922: LIST
9923: PUSH
9924: LD_INT 129
9926: PUSH
9927: LD_INT 114
9929: PUSH
9930: EMPTY
9931: LIST
9932: LIST
9933: PUSH
9934: LD_INT 154
9936: PUSH
9937: LD_INT 111
9939: PUSH
9940: EMPTY
9941: LIST
9942: LIST
9943: PUSH
9944: EMPTY
9945: LIST
9946: LIST
9947: LIST
9948: LIST
9949: LIST
9950: LIST
9951: LIST
9952: LIST
9953: LIST
9954: LIST
9955: LIST
9956: LIST
9957: ST_TO_ADDR
// base_captured := true ;
9958: LD_ADDR_EXP 6
9962: PUSH
9963: LD_INT 1
9965: ST_TO_ADDR
// DialogueOn ;
9966: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
9970: LD_EXP 21
9974: PPUSH
9975: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
9979: LD_EXP 21
9983: PPUSH
9984: LD_STRING D2-JMM-1
9986: PPUSH
9987: CALL_OW 88
// SayRadio ( Powell , D2-Pow-1 ) ;
9991: LD_EXP 30
9995: PPUSH
9996: LD_STRING D2-Pow-1
9998: PPUSH
9999: CALL_OW 94
// Say ( JMM , D2-JMM-2 ) ;
10003: LD_EXP 21
10007: PPUSH
10008: LD_STRING D2-JMM-2
10010: PPUSH
10011: CALL_OW 88
// SayRadio ( Powell , D2-Pow-2 ) ;
10015: LD_EXP 30
10019: PPUSH
10020: LD_STRING D2-Pow-2
10022: PPUSH
10023: CALL_OW 94
// Say ( JMM , D2-JMM-3 ) ;
10027: LD_EXP 21
10031: PPUSH
10032: LD_STRING D2-JMM-3
10034: PPUSH
10035: CALL_OW 88
// DialogueOff ;
10039: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
10043: LD_STRING M2
10045: PPUSH
10046: CALL_OW 337
// Wait ( 0 0$2 ) ;
10050: LD_INT 70
10052: PPUSH
10053: CALL_OW 67
// if IsOk ( Gary ) then
10057: LD_EXP 32
10061: PPUSH
10062: CALL_OW 302
10066: IFFALSE 10080
// Say ( Gary , D2a-Gary-1 ) ;
10068: LD_EXP 32
10072: PPUSH
10073: LD_STRING D2a-Gary-1
10075: PPUSH
10076: CALL_OW 88
// if IsOk ( Bobby ) then
10080: LD_EXP 24
10084: PPUSH
10085: CALL_OW 302
10089: IFFALSE 10103
// Say ( Bobby , D2a-Bobby-1 ) ;
10091: LD_EXP 24
10095: PPUSH
10096: LD_STRING D2a-Bobby-1
10098: PPUSH
10099: CALL_OW 88
// if IsOk ( Cyrus ) then
10103: LD_EXP 25
10107: PPUSH
10108: CALL_OW 302
10112: IFFALSE 10126
// Say ( Cyrus , D2a-Cyrus-1 ) ;
10114: LD_EXP 25
10118: PPUSH
10119: LD_STRING D2a-Cyrus-1
10121: PPUSH
10122: CALL_OW 88
// if IsOk ( Lisa ) then
10126: LD_EXP 22
10130: PPUSH
10131: CALL_OW 302
10135: IFFALSE 10149
// Say ( Lisa , D2a-Lisa-1 ) ;
10137: LD_EXP 22
10141: PPUSH
10142: LD_STRING D2a-Lisa-1
10144: PPUSH
10145: CALL_OW 88
// if IsOk ( Frank ) then
10149: LD_EXP 33
10153: PPUSH
10154: CALL_OW 302
10158: IFFALSE 10172
// Say ( Frank , D2a-Frank-1 ) ;
10160: LD_EXP 33
10164: PPUSH
10165: LD_STRING D2a-Frank-1
10167: PPUSH
10168: CALL_OW 88
// if IsOk ( Cornel ) then
10172: LD_EXP 31
10176: PPUSH
10177: CALL_OW 302
10181: IFFALSE 10195
// Say ( Cornel , D2a-Corn-1 ) ;
10183: LD_EXP 31
10187: PPUSH
10188: LD_STRING D2a-Corn-1
10190: PPUSH
10191: CALL_OW 88
// if IsOk ( Donaldson ) then
10195: LD_EXP 23
10199: PPUSH
10200: CALL_OW 302
10204: IFFALSE 10218
// Say ( Donaldson , D2a-Don-1 ) ;
10206: LD_EXP 23
10210: PPUSH
10211: LD_STRING D2a-Don-1
10213: PPUSH
10214: CALL_OW 88
// if IsOk ( Brown ) then
10218: LD_EXP 27
10222: PPUSH
10223: CALL_OW 302
10227: IFFALSE 10241
// Say ( Brown , D2a-Brown-1 ) ;
10229: LD_EXP 27
10233: PPUSH
10234: LD_STRING D2a-Brown-1
10236: PPUSH
10237: CALL_OW 88
// Wait ( 0 0$30 ) ;
10241: LD_INT 1050
10243: PPUSH
10244: CALL_OW 67
// if IsOk ( Frank ) then
10248: LD_EXP 33
10252: PPUSH
10253: CALL_OW 302
10257: IFFALSE 10523
// begin DialogueOn ;
10259: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Frank ] ) ;
10263: LD_EXP 21
10267: PUSH
10268: LD_EXP 33
10272: PUSH
10273: EMPTY
10274: LIST
10275: LIST
10276: PPUSH
10277: CALL_OW 87
// Say ( Frank , D3F-Frank-1 ) ;
10281: LD_EXP 33
10285: PPUSH
10286: LD_STRING D3F-Frank-1
10288: PPUSH
10289: CALL_OW 88
// Say ( JMM , D3F-JMM-1 ) ;
10293: LD_EXP 21
10297: PPUSH
10298: LD_STRING D3F-JMM-1
10300: PPUSH
10301: CALL_OW 88
// Say ( Frank , D3F-Frank-2 ) ;
10305: LD_EXP 33
10309: PPUSH
10310: LD_STRING D3F-Frank-2
10312: PPUSH
10313: CALL_OW 88
// case Query ( QFrank ) of 1 :
10317: LD_STRING QFrank
10319: PPUSH
10320: CALL_OW 97
10324: PUSH
10325: LD_INT 1
10327: DOUBLE
10328: EQUAL
10329: IFTRUE 10333
10331: GO 10356
10333: POP
// begin Say ( JMM , D3Fa-JMM-1 ) ;
10334: LD_EXP 21
10338: PPUSH
10339: LD_STRING D3Fa-JMM-1
10341: PPUSH
10342: CALL_OW 88
// us_scout := 1 ;
10346: LD_ADDR_EXP 8
10350: PUSH
10351: LD_INT 1
10353: ST_TO_ADDR
// end ; 2 :
10354: GO 10519
10356: LD_INT 2
10358: DOUBLE
10359: EQUAL
10360: IFTRUE 10364
10362: GO 10486
10364: POP
// begin Say ( JMM , D3Fb-JMM-1 ) ;
10365: LD_EXP 21
10369: PPUSH
10370: LD_STRING D3Fb-JMM-1
10372: PPUSH
10373: CALL_OW 88
// Say ( Frank , D3Fb-Frank-1 ) ;
10377: LD_EXP 33
10381: PPUSH
10382: LD_STRING D3Fb-Frank-1
10384: PPUSH
10385: CALL_OW 88
// case Query ( QFrank2 ) of 1 :
10389: LD_STRING QFrank2
10391: PPUSH
10392: CALL_OW 97
10396: PUSH
10397: LD_INT 1
10399: DOUBLE
10400: EQUAL
10401: IFTRUE 10405
10403: GO 10452
10405: POP
// begin us_scout := 2 ;
10406: LD_ADDR_EXP 8
10410: PUSH
10411: LD_INT 2
10413: ST_TO_ADDR
// Say ( JMM , D3Fba-JMM-1 ) ;
10414: LD_EXP 21
10418: PPUSH
10419: LD_STRING D3Fba-JMM-1
10421: PPUSH
10422: CALL_OW 88
// Say ( Frank , D3Fba-Frank-1 ) ;
10426: LD_EXP 33
10430: PPUSH
10431: LD_STRING D3Fba-Frank-1
10433: PPUSH
10434: CALL_OW 88
// Say ( JMM , D3Fba-JMM-2 ) ;
10438: LD_EXP 21
10442: PPUSH
10443: LD_STRING D3Fba-JMM-2
10445: PPUSH
10446: CALL_OW 88
// end ; 2 :
10450: GO 10484
10452: LD_INT 2
10454: DOUBLE
10455: EQUAL
10456: IFTRUE 10460
10458: GO 10483
10460: POP
// begin us_scout := 0 ;
10461: LD_ADDR_EXP 8
10465: PUSH
10466: LD_INT 0
10468: ST_TO_ADDR
// Say ( JMM , D3Fbb-JMM-1 ) ;
10469: LD_EXP 21
10473: PPUSH
10474: LD_STRING D3Fbb-JMM-1
10476: PPUSH
10477: CALL_OW 88
// end ; end ;
10481: GO 10484
10483: POP
// end ; 3 :
10484: GO 10519
10486: LD_INT 3
10488: DOUBLE
10489: EQUAL
10490: IFTRUE 10494
10492: GO 10518
10494: POP
// begin us_scout := - 1 ;
10495: LD_ADDR_EXP 8
10499: PUSH
10500: LD_INT 1
10502: NEG
10503: ST_TO_ADDR
// Say ( JMM , D3Fc-JMM-1 ) ;
10504: LD_EXP 21
10508: PPUSH
10509: LD_STRING D3Fc-JMM-1
10511: PPUSH
10512: CALL_OW 88
// end ; end ;
10516: GO 10519
10518: POP
// DialogueOff ;
10519: CALL_OW 7
// end ; if us_scout in [ - 1 , 0 ] then
10523: LD_EXP 8
10527: PUSH
10528: LD_INT 1
10530: NEG
10531: PUSH
10532: LD_INT 0
10534: PUSH
10535: EMPTY
10536: LIST
10537: LIST
10538: IN
10539: IFFALSE 10543
// exit ;
10541: GO 12190
// if us_scout in [ 1 , 2 ] then
10543: LD_EXP 8
10547: PUSH
10548: LD_INT 1
10550: PUSH
10551: LD_INT 2
10553: PUSH
10554: EMPTY
10555: LIST
10556: LIST
10557: IN
10558: IFFALSE 11257
// begin if IsInUnit ( Frank ) then
10560: LD_EXP 33
10564: PPUSH
10565: CALL_OW 310
10569: IFFALSE 10580
// ComExitBuilding ( Frank ) ;
10571: LD_EXP 33
10575: PPUSH
10576: CALL_OW 122
// if IsDrivenBy ( Frank ) then
10580: LD_EXP 33
10584: PPUSH
10585: CALL_OW 311
10589: IFFALSE 10600
// ComExitVehicle ( Frank ) ;
10591: LD_EXP 33
10595: PPUSH
10596: CALL_OW 121
// SetSide ( Frank , 4 ) ;
10600: LD_EXP 33
10604: PPUSH
10605: LD_INT 4
10607: PPUSH
10608: CALL_OW 235
// wait ( 0 0$1 ) ;
10612: LD_INT 35
10614: PPUSH
10615: CALL_OW 67
// if us_scout = 2 then
10619: LD_EXP 8
10623: PUSH
10624: LD_INT 2
10626: EQUAL
10627: IFFALSE 10995
// begin ComMoveXY ( Frank , 75 , 63 ) ;
10629: LD_EXP 33
10633: PPUSH
10634: LD_INT 75
10636: PPUSH
10637: LD_INT 63
10639: PPUSH
10640: CALL_OW 111
// AddComHold ( Frank ) ;
10644: LD_EXP 33
10648: PPUSH
10649: CALL_OW 200
// AddComWait ( Frank , 0 0$22 ) ;
10653: LD_EXP 33
10657: PPUSH
10658: LD_INT 770
10660: PPUSH
10661: CALL_OW 202
// AddComMoveXY ( Frank , 100 , 75 ) ;
10665: LD_EXP 33
10669: PPUSH
10670: LD_INT 100
10672: PPUSH
10673: LD_INT 75
10675: PPUSH
10676: CALL_OW 171
// AddComMoveXY ( Frank , 123 , 103 ) ;
10680: LD_EXP 33
10684: PPUSH
10685: LD_INT 123
10687: PPUSH
10688: LD_INT 103
10690: PPUSH
10691: CALL_OW 171
// AddComMoveXY ( Frank , 138 , 108 ) ;
10695: LD_EXP 33
10699: PPUSH
10700: LD_INT 138
10702: PPUSH
10703: LD_INT 108
10705: PPUSH
10706: CALL_OW 171
// AddComHold ( Frank ) ;
10710: LD_EXP 33
10714: PPUSH
10715: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
10719: LD_INT 35
10721: PPUSH
10722: CALL_OW 67
// until IsAt ( Frank , 138 , 108 ) ;
10726: LD_EXP 33
10730: PPUSH
10731: LD_INT 138
10733: PPUSH
10734: LD_INT 108
10736: PPUSH
10737: CALL_OW 307
10741: IFFALSE 10719
// AddComMoveXY ( Frank , 125 , 132 ) ;
10743: LD_EXP 33
10747: PPUSH
10748: LD_INT 125
10750: PPUSH
10751: LD_INT 132
10753: PPUSH
10754: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
10758: LD_INT 35
10760: PPUSH
10761: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 7 ;
10765: LD_INT 1
10767: PPUSH
10768: LD_EXP 33
10772: PPUSH
10773: CALL_OW 292
10777: PUSH
10778: LD_EXP 33
10782: PPUSH
10783: LD_INT 7
10785: PPUSH
10786: CALL_OW 296
10790: PUSH
10791: LD_INT 7
10793: LESS
10794: OR
10795: IFFALSE 10758
// DialogueOn ;
10797: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
10801: LD_EXP 33
10805: PPUSH
10806: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
10810: LD_INT 10
10812: PPUSH
10813: CALL_OW 68
// Say ( JMM , D4Fa-JMM-1 ) ;
10817: LD_EXP 21
10821: PPUSH
10822: LD_STRING D4Fa-JMM-1
10824: PPUSH
10825: CALL_OW 88
// for i in points do
10829: LD_ADDR_VAR 0 1
10833: PUSH
10834: LD_VAR 0 2
10838: PUSH
10839: FOR_IN
10840: IFFALSE 10898
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
10842: LD_VAR 0 1
10846: PUSH
10847: LD_INT 1
10849: ARRAY
10850: PPUSH
10851: LD_VAR 0 1
10855: PUSH
10856: LD_INT 2
10858: ARRAY
10859: PPUSH
10860: LD_INT 1
10862: PPUSH
10863: LD_INT 20
10865: NEG
10866: PPUSH
10867: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
10871: LD_VAR 0 1
10875: PUSH
10876: LD_INT 1
10878: ARRAY
10879: PPUSH
10880: LD_VAR 0 1
10884: PUSH
10885: LD_INT 2
10887: ARRAY
10888: PPUSH
10889: LD_INT 1
10891: PPUSH
10892: CALL_OW 331
// end ;
10896: GO 10839
10898: POP
10899: POP
// dwait ( 0 0$0.5 ) ;
10900: LD_INT 18
10902: PPUSH
10903: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
10907: LD_INT 42
10909: PPUSH
10910: LD_INT 27
10912: PPUSH
10913: CALL_OW 84
// Say ( Frank , D4Fa-Frank-1 ) ;
10917: LD_EXP 33
10921: PPUSH
10922: LD_STRING D4Fa-Frank-1
10924: PPUSH
10925: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
10929: LD_INT 18
10931: PPUSH
10932: CALL_OW 68
// Say ( JMM , D4Fa-JMM-2 ) ;
10936: LD_EXP 21
10940: PPUSH
10941: LD_STRING D4Fa-JMM-2
10943: PPUSH
10944: CALL_OW 88
// CenterNowOnXY ( 118 , 80 ) ;
10948: LD_INT 118
10950: PPUSH
10951: LD_INT 80
10953: PPUSH
10954: CALL_OW 86
// Say ( Frank , D4Fa-Frank-2 ) ;
10958: LD_EXP 33
10962: PPUSH
10963: LD_STRING D4Fa-Frank-2
10965: PPUSH
10966: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
10970: LD_INT 10
10972: PPUSH
10973: CALL_OW 68
// DialogueOff ;
10977: CALL_OW 7
// SetSide ( Frank , 1 ) ;
10981: LD_EXP 33
10985: PPUSH
10986: LD_INT 1
10988: PPUSH
10989: CALL_OW 235
// end else
10993: GO 11257
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
10995: LD_INT 2
10997: PPUSH
10998: LD_INT 4
11000: PPUSH
11001: LD_INT 2
11003: PPUSH
11004: LD_INT 1
11006: PPUSH
11007: CALL_OW 80
// ComMoveXY ( Frank , 75 , 63 ) ;
11011: LD_EXP 33
11015: PPUSH
11016: LD_INT 75
11018: PPUSH
11019: LD_INT 63
11021: PPUSH
11022: CALL_OW 111
// AddComWait ( Frank , 0 0$5 ) ;
11026: LD_EXP 33
11030: PPUSH
11031: LD_INT 175
11033: PPUSH
11034: CALL_OW 202
// AddComMoveXY ( Frank , 102 , 76 ) ;
11038: LD_EXP 33
11042: PPUSH
11043: LD_INT 102
11045: PPUSH
11046: LD_INT 76
11048: PPUSH
11049: CALL_OW 171
// AddComMoveXY ( Frank , 108 , 70 ) ;
11053: LD_EXP 33
11057: PPUSH
11058: LD_INT 108
11060: PPUSH
11061: LD_INT 70
11063: PPUSH
11064: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11068: LD_INT 35
11070: PPUSH
11071: CALL_OW 67
// until See ( 2 , Frank ) ;
11075: LD_INT 2
11077: PPUSH
11078: LD_EXP 33
11082: PPUSH
11083: CALL_OW 292
11087: IFFALSE 11068
// ComMoveXY ( Frank , 112 , 118 ) ;
11089: LD_EXP 33
11093: PPUSH
11094: LD_INT 112
11096: PPUSH
11097: LD_INT 118
11099: PPUSH
11100: CALL_OW 111
// if GetLives ( Frank ) >= 750 then
11104: LD_EXP 33
11108: PPUSH
11109: CALL_OW 256
11113: PUSH
11114: LD_INT 750
11116: GREATEREQUAL
11117: IFFALSE 11131
// SetLives ( Frank , 700 ) ;
11119: LD_EXP 33
11123: PPUSH
11124: LD_INT 700
11126: PPUSH
11127: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
11131: LD_INT 35
11133: PPUSH
11134: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 17 ;
11138: LD_INT 1
11140: PPUSH
11141: LD_EXP 33
11145: PPUSH
11146: CALL_OW 292
11150: PUSH
11151: LD_EXP 33
11155: PPUSH
11156: LD_INT 7
11158: PPUSH
11159: CALL_OW 296
11163: PUSH
11164: LD_INT 17
11166: LESS
11167: OR
11168: IFFALSE 11131
// DialogueOn ;
11170: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11174: LD_EXP 33
11178: PPUSH
11179: CALL_OW 87
// Say ( Frank , D4Fb-Frank-1 ) ;
11183: LD_EXP 33
11187: PPUSH
11188: LD_STRING D4Fb-Frank-1
11190: PPUSH
11191: CALL_OW 88
// Say ( JMM , D4Fb-JMM-1 ) ;
11195: LD_EXP 21
11199: PPUSH
11200: LD_STRING D4Fb-JMM-1
11202: PPUSH
11203: CALL_OW 88
// SayRand ( sex_female , D4Fb-FSci1-1 ) ;
11207: LD_INT 2
11209: PPUSH
11210: LD_STRING D4Fb-FSci1-1
11212: PPUSH
11213: CALL 16094 0 2
// Say ( Frank , D4Fb-Frank-2 ) ;
11217: LD_EXP 33
11221: PPUSH
11222: LD_STRING D4Fb-Frank-2
11224: PPUSH
11225: CALL_OW 88
// Say ( JMM , D4Fb-JMM-2 ) ;
11229: LD_EXP 21
11233: PPUSH
11234: LD_STRING D4Fb-JMM-2
11236: PPUSH
11237: CALL_OW 88
// DialogueOff ;
11241: CALL_OW 7
// SetSide ( Frank , 1 ) ;
11245: LD_EXP 33
11249: PPUSH
11250: LD_INT 1
11252: PPUSH
11253: CALL_OW 235
// end ; end ; if IsOk ( Kikuchi ) and not Frank then
11257: LD_EXP 34
11261: PPUSH
11262: CALL_OW 302
11266: PUSH
11267: LD_EXP 33
11271: NOT
11272: AND
11273: IFFALSE 11421
// begin DialogueOn ;
11275: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Kikuchi ] ) ;
11279: LD_EXP 21
11283: PUSH
11284: LD_EXP 34
11288: PUSH
11289: EMPTY
11290: LIST
11291: LIST
11292: PPUSH
11293: CALL_OW 87
// Say ( Kikuchi , D3Y-Yam-1 ) ;
11297: LD_EXP 34
11301: PPUSH
11302: LD_STRING D3Y-Yam-1
11304: PPUSH
11305: CALL_OW 88
// Say ( JMM , D3Y-JMM-1 ) ;
11309: LD_EXP 21
11313: PPUSH
11314: LD_STRING D3Y-JMM-1
11316: PPUSH
11317: CALL_OW 88
// Say ( Kikuchi , D3Y-Yam-2 ) ;
11321: LD_EXP 34
11325: PPUSH
11326: LD_STRING D3Y-Yam-2
11328: PPUSH
11329: CALL_OW 88
// case Query ( QYamoko ) of 1 :
11333: LD_STRING QYamoko
11335: PPUSH
11336: CALL_OW 97
11340: PUSH
11341: LD_INT 1
11343: DOUBLE
11344: EQUAL
11345: IFTRUE 11349
11347: GO 11384
11349: POP
// begin Say ( JMM , D3Ya-JMM-1 ) ;
11350: LD_EXP 21
11354: PPUSH
11355: LD_STRING D3Ya-JMM-1
11357: PPUSH
11358: CALL_OW 88
// Say ( Kikuchi , D3Ya-Yam-1 ) ;
11362: LD_EXP 34
11366: PPUSH
11367: LD_STRING D3Ya-Yam-1
11369: PPUSH
11370: CALL_OW 88
// us_scout := 1 ;
11374: LD_ADDR_EXP 8
11378: PUSH
11379: LD_INT 1
11381: ST_TO_ADDR
// end ; 2 :
11382: GO 11417
11384: LD_INT 2
11386: DOUBLE
11387: EQUAL
11388: IFTRUE 11392
11390: GO 11416
11392: POP
// begin us_scout := - 1 ;
11393: LD_ADDR_EXP 8
11397: PUSH
11398: LD_INT 1
11400: NEG
11401: ST_TO_ADDR
// Say ( JMM , D3Yb-JMM-1 ) ;
11402: LD_EXP 21
11406: PPUSH
11407: LD_STRING D3Yb-JMM-1
11409: PPUSH
11410: CALL_OW 88
// end ; end ;
11414: GO 11417
11416: POP
// DialogueOff ;
11417: CALL_OW 7
// end ; if Frank then
11421: LD_EXP 33
11425: IFFALSE 11429
// exit ;
11427: GO 12190
// if us_scout in [ - 1 , 0 ] then
11429: LD_EXP 8
11433: PUSH
11434: LD_INT 1
11436: NEG
11437: PUSH
11438: LD_INT 0
11440: PUSH
11441: EMPTY
11442: LIST
11443: LIST
11444: IN
11445: IFFALSE 11449
// exit ;
11447: GO 12190
// us_scout := [ 2 , 2 , 1 ] [ Difficulty ] ;
11449: LD_ADDR_EXP 8
11453: PUSH
11454: LD_INT 2
11456: PUSH
11457: LD_INT 2
11459: PUSH
11460: LD_INT 1
11462: PUSH
11463: EMPTY
11464: LIST
11465: LIST
11466: LIST
11467: PUSH
11468: LD_OWVAR 67
11472: ARRAY
11473: ST_TO_ADDR
// if us_scout in [ 1 , 2 ] then
11474: LD_EXP 8
11478: PUSH
11479: LD_INT 1
11481: PUSH
11482: LD_INT 2
11484: PUSH
11485: EMPTY
11486: LIST
11487: LIST
11488: IN
11489: IFFALSE 12190
// begin if IsInUnit ( Kikuchi ) then
11491: LD_EXP 34
11495: PPUSH
11496: CALL_OW 310
11500: IFFALSE 11511
// ComExitBuilding ( Kikuchi ) ;
11502: LD_EXP 34
11506: PPUSH
11507: CALL_OW 122
// if IsDrivenBy ( Kikuchi ) then
11511: LD_EXP 34
11515: PPUSH
11516: CALL_OW 311
11520: IFFALSE 11531
// ComExitVehicle ( Kikuchi ) ;
11522: LD_EXP 34
11526: PPUSH
11527: CALL_OW 121
// SetSide ( Kikuchi , 4 ) ;
11531: LD_EXP 34
11535: PPUSH
11536: LD_INT 4
11538: PPUSH
11539: CALL_OW 235
// wait ( 0 0$1 ) ;
11543: LD_INT 35
11545: PPUSH
11546: CALL_OW 67
// if us_scout = 2 then
11550: LD_EXP 8
11554: PUSH
11555: LD_INT 2
11557: EQUAL
11558: IFFALSE 11938
// begin ComMoveXY ( Kikuchi , 75 , 63 ) ;
11560: LD_EXP 34
11564: PPUSH
11565: LD_INT 75
11567: PPUSH
11568: LD_INT 63
11570: PPUSH
11571: CALL_OW 111
// AddComHold ( Kikuchi ) ;
11575: LD_EXP 34
11579: PPUSH
11580: CALL_OW 200
// AddComWait ( Kikuchi , 0 0$22 ) ;
11584: LD_EXP 34
11588: PPUSH
11589: LD_INT 770
11591: PPUSH
11592: CALL_OW 202
// AddComMoveXY ( Kikuchi , 100 , 75 ) ;
11596: LD_EXP 34
11600: PPUSH
11601: LD_INT 100
11603: PPUSH
11604: LD_INT 75
11606: PPUSH
11607: CALL_OW 171
// AddComMoveXY ( Kikuchi , 123 , 103 ) ;
11611: LD_EXP 34
11615: PPUSH
11616: LD_INT 123
11618: PPUSH
11619: LD_INT 103
11621: PPUSH
11622: CALL_OW 171
// AddComMoveXY ( Kikuchi , 138 , 108 ) ;
11626: LD_EXP 34
11630: PPUSH
11631: LD_INT 138
11633: PPUSH
11634: LD_INT 108
11636: PPUSH
11637: CALL_OW 171
// AddComHold ( Kikuchi ) ;
11641: LD_EXP 34
11645: PPUSH
11646: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
11650: LD_INT 35
11652: PPUSH
11653: CALL_OW 67
// until IsAt ( Kikuchi , 138 , 108 ) ;
11657: LD_EXP 34
11661: PPUSH
11662: LD_INT 138
11664: PPUSH
11665: LD_INT 108
11667: PPUSH
11668: CALL_OW 307
11672: IFFALSE 11650
// AddComMoveXY ( Kikuchi , 125 , 132 ) ;
11674: LD_EXP 34
11678: PPUSH
11679: LD_INT 125
11681: PPUSH
11682: LD_INT 132
11684: PPUSH
11685: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11689: LD_INT 35
11691: PPUSH
11692: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 7 ;
11696: LD_INT 1
11698: PPUSH
11699: LD_EXP 34
11703: PPUSH
11704: CALL_OW 292
11708: PUSH
11709: LD_EXP 34
11713: PPUSH
11714: LD_INT 7
11716: PPUSH
11717: CALL_OW 296
11721: PUSH
11722: LD_INT 7
11724: LESS
11725: OR
11726: IFFALSE 11689
// DialogueOn ;
11728: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
11732: LD_EXP 34
11736: PPUSH
11737: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
11741: LD_INT 10
11743: PPUSH
11744: CALL_OW 68
// Say ( Kikuchi , D4Ya-Yam-1 ) ;
11748: LD_EXP 34
11752: PPUSH
11753: LD_STRING D4Ya-Yam-1
11755: PPUSH
11756: CALL_OW 88
// Say ( JMM , D4Ya-JMM-1 ) ;
11760: LD_EXP 21
11764: PPUSH
11765: LD_STRING D4Ya-JMM-1
11767: PPUSH
11768: CALL_OW 88
// for i in points do
11772: LD_ADDR_VAR 0 1
11776: PUSH
11777: LD_VAR 0 2
11781: PUSH
11782: FOR_IN
11783: IFFALSE 11841
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
11785: LD_VAR 0 1
11789: PUSH
11790: LD_INT 1
11792: ARRAY
11793: PPUSH
11794: LD_VAR 0 1
11798: PUSH
11799: LD_INT 2
11801: ARRAY
11802: PPUSH
11803: LD_INT 1
11805: PPUSH
11806: LD_INT 20
11808: NEG
11809: PPUSH
11810: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
11814: LD_VAR 0 1
11818: PUSH
11819: LD_INT 1
11821: ARRAY
11822: PPUSH
11823: LD_VAR 0 1
11827: PUSH
11828: LD_INT 2
11830: ARRAY
11831: PPUSH
11832: LD_INT 1
11834: PPUSH
11835: CALL_OW 331
// end ;
11839: GO 11782
11841: POP
11842: POP
// dwait ( 0 0$0.5 ) ;
11843: LD_INT 18
11845: PPUSH
11846: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
11850: LD_INT 42
11852: PPUSH
11853: LD_INT 27
11855: PPUSH
11856: CALL_OW 84
// Say ( Kikuchi , D4Ya-Yam-2 ) ;
11860: LD_EXP 34
11864: PPUSH
11865: LD_STRING D4Ya-Yam-2
11867: PPUSH
11868: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
11872: LD_INT 18
11874: PPUSH
11875: CALL_OW 68
// CenterNowOnXY ( 118 , 80 ) ;
11879: LD_INT 118
11881: PPUSH
11882: LD_INT 80
11884: PPUSH
11885: CALL_OW 86
// Say ( JMM , D4Ya-JMM-2 ) ;
11889: LD_EXP 21
11893: PPUSH
11894: LD_STRING D4Ya-JMM-2
11896: PPUSH
11897: CALL_OW 88
// Say ( Kikuchi , D4Ya-Yam-3 ) ;
11901: LD_EXP 34
11905: PPUSH
11906: LD_STRING D4Ya-Yam-3
11908: PPUSH
11909: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
11913: LD_INT 10
11915: PPUSH
11916: CALL_OW 68
// DialogueOff ;
11920: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
11924: LD_EXP 34
11928: PPUSH
11929: LD_INT 1
11931: PPUSH
11932: CALL_OW 235
// end else
11936: GO 12190
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
11938: LD_INT 2
11940: PPUSH
11941: LD_INT 4
11943: PPUSH
11944: LD_INT 2
11946: PPUSH
11947: LD_INT 1
11949: PPUSH
11950: CALL_OW 80
// ComMoveXY ( Kikuchi , 75 , 63 ) ;
11954: LD_EXP 34
11958: PPUSH
11959: LD_INT 75
11961: PPUSH
11962: LD_INT 63
11964: PPUSH
11965: CALL_OW 111
// AddComWait ( Kikuchi , 0 0$5 ) ;
11969: LD_EXP 34
11973: PPUSH
11974: LD_INT 175
11976: PPUSH
11977: CALL_OW 202
// AddComMoveXY ( Kikuchi , 102 , 76 ) ;
11981: LD_EXP 34
11985: PPUSH
11986: LD_INT 102
11988: PPUSH
11989: LD_INT 76
11991: PPUSH
11992: CALL_OW 171
// AddComMoveXY ( Kikuchi , 108 , 70 ) ;
11996: LD_EXP 34
12000: PPUSH
12001: LD_INT 108
12003: PPUSH
12004: LD_INT 70
12006: PPUSH
12007: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12011: LD_INT 35
12013: PPUSH
12014: CALL_OW 67
// until See ( 2 , Kikuchi ) ;
12018: LD_INT 2
12020: PPUSH
12021: LD_EXP 34
12025: PPUSH
12026: CALL_OW 292
12030: IFFALSE 12011
// ComMoveXY ( Kikuchi , 112 , 118 ) ;
12032: LD_EXP 34
12036: PPUSH
12037: LD_INT 112
12039: PPUSH
12040: LD_INT 118
12042: PPUSH
12043: CALL_OW 111
// if GetLives ( Kikuchi ) >= 750 then
12047: LD_EXP 34
12051: PPUSH
12052: CALL_OW 256
12056: PUSH
12057: LD_INT 750
12059: GREATEREQUAL
12060: IFFALSE 12074
// SetLives ( Kikuchi , 700 ) ;
12062: LD_EXP 34
12066: PPUSH
12067: LD_INT 700
12069: PPUSH
12070: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
12074: LD_INT 35
12076: PPUSH
12077: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 17 ;
12081: LD_INT 1
12083: PPUSH
12084: LD_EXP 34
12088: PPUSH
12089: CALL_OW 292
12093: PUSH
12094: LD_EXP 34
12098: PPUSH
12099: LD_INT 7
12101: PPUSH
12102: CALL_OW 296
12106: PUSH
12107: LD_INT 17
12109: LESS
12110: OR
12111: IFFALSE 12074
// DialogueOn ;
12113: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12117: LD_EXP 34
12121: PPUSH
12122: CALL_OW 87
// Say ( Kikuchi , D4Yb-Yam-1 ) ;
12126: LD_EXP 34
12130: PPUSH
12131: LD_STRING D4Yb-Yam-1
12133: PPUSH
12134: CALL_OW 88
// Say ( JMM , D4Yb-JMM-1 ) ;
12138: LD_EXP 21
12142: PPUSH
12143: LD_STRING D4Yb-JMM-1
12145: PPUSH
12146: CALL_OW 88
// Say ( Kikuchi , D4Yb-Yam-2 ) ;
12150: LD_EXP 34
12154: PPUSH
12155: LD_STRING D4Yb-Yam-2
12157: PPUSH
12158: CALL_OW 88
// Say ( JMM , D4Yb-JMM-2 ) ;
12162: LD_EXP 21
12166: PPUSH
12167: LD_STRING D4Yb-JMM-2
12169: PPUSH
12170: CALL_OW 88
// DialogueOff ;
12174: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12178: LD_EXP 34
12182: PPUSH
12183: LD_INT 1
12185: PPUSH
12186: CALL_OW 235
// end ; end ; end ;
12190: PPOPN 2
12192: END
// every 0 0$01 trigger base_captured do var i , tmp , un , un2 ;
12193: LD_EXP 6
12197: IFFALSE 13230
12199: GO 12201
12201: DISABLE
12202: LD_INT 0
12204: PPUSH
12205: PPUSH
12206: PPUSH
12207: PPUSH
// begin enable ;
12208: ENABLE
// if not seen [ 1 ] then
12209: LD_EXP 9
12213: PUSH
12214: LD_INT 1
12216: ARRAY
12217: NOT
12218: IFFALSE 12398
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 11 ] , [ f_control , control_rider ] ] ] ) ;
12220: LD_ADDR_VAR 0 2
12224: PUSH
12225: LD_INT 22
12227: PUSH
12228: LD_INT 2
12230: PUSH
12231: EMPTY
12232: LIST
12233: LIST
12234: PUSH
12235: LD_INT 2
12237: PUSH
12238: LD_INT 25
12240: PUSH
12241: LD_INT 11
12243: PUSH
12244: EMPTY
12245: LIST
12246: LIST
12247: PUSH
12248: LD_INT 33
12250: PUSH
12251: LD_INT 4
12253: PUSH
12254: EMPTY
12255: LIST
12256: LIST
12257: PUSH
12258: EMPTY
12259: LIST
12260: LIST
12261: LIST
12262: PUSH
12263: EMPTY
12264: LIST
12265: LIST
12266: PPUSH
12267: CALL_OW 69
12271: ST_TO_ADDR
// if tmp then
12272: LD_VAR 0 2
12276: IFFALSE 12398
// for i in tmp do
12278: LD_ADDR_VAR 0 1
12282: PUSH
12283: LD_VAR 0 2
12287: PUSH
12288: FOR_IN
12289: IFFALSE 12396
// if See ( 1 , i ) then
12291: LD_INT 1
12293: PPUSH
12294: LD_VAR 0 1
12298: PPUSH
12299: CALL_OW 292
12303: IFFALSE 12394
// begin seen := Replace ( seen , 1 , true ) ;
12305: LD_ADDR_EXP 9
12309: PUSH
12310: LD_EXP 9
12314: PPUSH
12315: LD_INT 1
12317: PPUSH
12318: LD_INT 1
12320: PPUSH
12321: CALL_OW 1
12325: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12326: LD_INT 1
12328: PPUSH
12329: CALL 15916 0 1
12333: IFFALSE 12394
// begin DialogueOn ;
12335: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12339: LD_VAR 0 1
12343: PPUSH
12344: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12348: LD_INT 10
12350: PPUSH
12351: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol2-1 ) ;
12355: LD_ADDR_VAR 0 3
12359: PUSH
12360: LD_INT 1
12362: PPUSH
12363: LD_STRING D5a-Sol2-1
12365: PPUSH
12366: CALL 16094 0 2
12370: ST_TO_ADDR
// if not un then
12371: LD_VAR 0 3
12375: NOT
12376: IFFALSE 12388
// SayRand ( sex_female , D5a-FSol2-1 ) ;
12378: LD_INT 2
12380: PPUSH
12381: LD_STRING D5a-FSol2-1
12383: PPUSH
12384: CALL 16094 0 2
// DialogueOff ;
12388: CALL_OW 7
// break ;
12392: GO 12396
// end ; end ;
12394: GO 12288
12396: POP
12397: POP
// end ; if not seen [ 2 ] then
12398: LD_EXP 9
12402: PUSH
12403: LD_INT 2
12405: ARRAY
12406: NOT
12407: IFFALSE 12632
// begin can_kamikazed := true ;
12409: LD_ADDR_EXP 10
12413: PUSH
12414: LD_INT 1
12416: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 17 ] ] ) ;
12417: LD_ADDR_VAR 0 2
12421: PUSH
12422: LD_INT 22
12424: PUSH
12425: LD_INT 2
12427: PUSH
12428: EMPTY
12429: LIST
12430: LIST
12431: PUSH
12432: LD_INT 25
12434: PUSH
12435: LD_INT 17
12437: PUSH
12438: EMPTY
12439: LIST
12440: LIST
12441: PUSH
12442: EMPTY
12443: LIST
12444: LIST
12445: PPUSH
12446: CALL_OW 69
12450: ST_TO_ADDR
// if tmp then
12451: LD_VAR 0 2
12455: IFFALSE 12632
// for i in tmp do
12457: LD_ADDR_VAR 0 1
12461: PUSH
12462: LD_VAR 0 2
12466: PUSH
12467: FOR_IN
12468: IFFALSE 12630
// if See ( 1 , i ) then
12470: LD_INT 1
12472: PPUSH
12473: LD_VAR 0 1
12477: PPUSH
12478: CALL_OW 292
12482: IFFALSE 12628
// begin seen := Replace ( seen , 2 , true ) ;
12484: LD_ADDR_EXP 9
12488: PUSH
12489: LD_EXP 9
12493: PPUSH
12494: LD_INT 2
12496: PPUSH
12497: LD_INT 1
12499: PPUSH
12500: CALL_OW 1
12504: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12505: LD_INT 1
12507: PPUSH
12508: CALL 15916 0 1
12512: IFFALSE 12628
// begin DialogueOn ;
12514: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12518: LD_VAR 0 1
12522: PPUSH
12523: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12527: LD_INT 10
12529: PPUSH
12530: CALL_OW 68
// un := SayRand ( sex_male , D5b-Sol1-1 ) ;
12534: LD_ADDR_VAR 0 3
12538: PUSH
12539: LD_INT 1
12541: PPUSH
12542: LD_STRING D5b-Sol1-1
12544: PPUSH
12545: CALL 16094 0 2
12549: ST_TO_ADDR
// if not un then
12550: LD_VAR 0 3
12554: NOT
12555: IFFALSE 12573
// un := SayRand ( sex_female , D5b-FSol1-1 ) ;
12557: LD_ADDR_VAR 0 3
12561: PUSH
12562: LD_INT 2
12564: PPUSH
12565: LD_STRING D5b-FSol1-1
12567: PPUSH
12568: CALL 16094 0 2
12572: ST_TO_ADDR
// if un then
12573: LD_VAR 0 3
12577: IFFALSE 12622
// begin un2 := SayRand2 ( sex_male , D5b-Sol2-1 , un ) ;
12579: LD_ADDR_VAR 0 4
12583: PUSH
12584: LD_INT 1
12586: PPUSH
12587: LD_STRING D5b-Sol2-1
12589: PPUSH
12590: LD_VAR 0 3
12594: PPUSH
12595: CALL 16320 0 3
12599: ST_TO_ADDR
// if not un2 then
12600: LD_VAR 0 4
12604: NOT
12605: IFFALSE 12622
// SayRand2 ( sex_female , D5b-FSol2-1 , un ) ;
12607: LD_INT 2
12609: PPUSH
12610: LD_STRING D5b-FSol2-1
12612: PPUSH
12613: LD_VAR 0 3
12617: PPUSH
12618: CALL 16320 0 3
// end ; DialogueOff ;
12622: CALL_OW 7
// break ;
12626: GO 12630
// end ; end ;
12628: GO 12467
12630: POP
12631: POP
// end ; if not seen [ 3 ] then
12632: LD_EXP 9
12636: PUSH
12637: LD_INT 3
12639: ARRAY
12640: NOT
12641: IFFALSE 12815
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] ] ) ;
12643: LD_ADDR_VAR 0 2
12647: PUSH
12648: LD_INT 22
12650: PUSH
12651: LD_INT 2
12653: PUSH
12654: EMPTY
12655: LIST
12656: LIST
12657: PUSH
12658: LD_INT 33
12660: PUSH
12661: LD_INT 2
12663: PUSH
12664: EMPTY
12665: LIST
12666: LIST
12667: PUSH
12668: EMPTY
12669: LIST
12670: LIST
12671: PPUSH
12672: CALL_OW 69
12676: ST_TO_ADDR
// if tmp then
12677: LD_VAR 0 2
12681: IFFALSE 12815
// for i in tmp do
12683: LD_ADDR_VAR 0 1
12687: PUSH
12688: LD_VAR 0 2
12692: PUSH
12693: FOR_IN
12694: IFFALSE 12813
// if See ( 1 , i ) then
12696: LD_INT 1
12698: PPUSH
12699: LD_VAR 0 1
12703: PPUSH
12704: CALL_OW 292
12708: IFFALSE 12811
// begin seen := Replace ( seen , 3 , true ) ;
12710: LD_ADDR_EXP 9
12714: PUSH
12715: LD_EXP 9
12719: PPUSH
12720: LD_INT 3
12722: PPUSH
12723: LD_INT 1
12725: PPUSH
12726: CALL_OW 1
12730: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12731: LD_INT 1
12733: PPUSH
12734: CALL 15916 0 1
12738: IFFALSE 12811
// begin DialogueOn ;
12740: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12744: LD_VAR 0 1
12748: PPUSH
12749: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12753: LD_INT 10
12755: PPUSH
12756: CALL_OW 68
// un := SayRand ( sex_male , D8-Sol1-1 ) ;
12760: LD_ADDR_VAR 0 3
12764: PUSH
12765: LD_INT 1
12767: PPUSH
12768: LD_STRING D8-Sol1-1
12770: PPUSH
12771: CALL 16094 0 2
12775: ST_TO_ADDR
// if not un then
12776: LD_VAR 0 3
12780: NOT
12781: IFFALSE 12793
// SayRand ( sex_female , D8-FSol1-1 ) ;
12783: LD_INT 2
12785: PPUSH
12786: LD_STRING D8-FSol1-1
12788: PPUSH
12789: CALL 16094 0 2
// Say ( JMM , D8-JMM-1 ) ;
12793: LD_EXP 21
12797: PPUSH
12798: LD_STRING D8-JMM-1
12800: PPUSH
12801: CALL_OW 88
// DialogueOff ;
12805: CALL_OW 7
// break ;
12809: GO 12813
// end ; end ;
12811: GO 12693
12813: POP
12814: POP
// end ; if not seen [ 4 ] then
12815: LD_EXP 9
12819: PUSH
12820: LD_INT 4
12822: ARRAY
12823: NOT
12824: IFFALSE 12986
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] ] ) ;
12826: LD_ADDR_VAR 0 2
12830: PUSH
12831: LD_INT 22
12833: PUSH
12834: LD_INT 2
12836: PUSH
12837: EMPTY
12838: LIST
12839: LIST
12840: PUSH
12841: LD_INT 33
12843: PUSH
12844: LD_INT 5
12846: PUSH
12847: EMPTY
12848: LIST
12849: LIST
12850: PUSH
12851: EMPTY
12852: LIST
12853: LIST
12854: PPUSH
12855: CALL_OW 69
12859: ST_TO_ADDR
// if tmp then
12860: LD_VAR 0 2
12864: IFFALSE 12986
// for i in tmp do
12866: LD_ADDR_VAR 0 1
12870: PUSH
12871: LD_VAR 0 2
12875: PUSH
12876: FOR_IN
12877: IFFALSE 12984
// if See ( 1 , i ) then
12879: LD_INT 1
12881: PPUSH
12882: LD_VAR 0 1
12886: PPUSH
12887: CALL_OW 292
12891: IFFALSE 12982
// begin seen := Replace ( seen , 4 , true ) ;
12893: LD_ADDR_EXP 9
12897: PUSH
12898: LD_EXP 9
12902: PPUSH
12903: LD_INT 4
12905: PPUSH
12906: LD_INT 1
12908: PPUSH
12909: CALL_OW 1
12913: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12914: LD_INT 1
12916: PPUSH
12917: CALL 15916 0 1
12921: IFFALSE 12982
// begin DialogueOn ;
12923: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12927: LD_VAR 0 1
12931: PPUSH
12932: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12936: LD_INT 10
12938: PPUSH
12939: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol1-1 ) ;
12943: LD_ADDR_VAR 0 3
12947: PUSH
12948: LD_INT 1
12950: PPUSH
12951: LD_STRING D5a-Sol1-1
12953: PPUSH
12954: CALL 16094 0 2
12958: ST_TO_ADDR
// if not un then
12959: LD_VAR 0 3
12963: NOT
12964: IFFALSE 12976
// SayRand ( sex_female , D5a-FSol1-1 ) ;
12966: LD_INT 2
12968: PPUSH
12969: LD_STRING D5a-FSol1-1
12971: PPUSH
12972: CALL 16094 0 2
// DialogueOff ;
12976: CALL_OW 7
// break ;
12980: GO 12984
// end ; end ;
12982: GO 12876
12984: POP
12985: POP
// end ; if not seen [ 5 ] and seen [ 3 ] then
12986: LD_EXP 9
12990: PUSH
12991: LD_INT 5
12993: ARRAY
12994: NOT
12995: PUSH
12996: LD_EXP 9
13000: PUSH
13001: LD_INT 3
13003: ARRAY
13004: AND
13005: IFFALSE 13179
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) ;
13007: LD_ADDR_VAR 0 2
13011: PUSH
13012: LD_INT 22
13014: PUSH
13015: LD_INT 2
13017: PUSH
13018: EMPTY
13019: LIST
13020: LIST
13021: PUSH
13022: LD_INT 34
13024: PUSH
13025: LD_INT 31
13027: PUSH
13028: EMPTY
13029: LIST
13030: LIST
13031: PUSH
13032: EMPTY
13033: LIST
13034: LIST
13035: PPUSH
13036: CALL_OW 69
13040: ST_TO_ADDR
// if tmp then
13041: LD_VAR 0 2
13045: IFFALSE 13179
// for i in tmp do
13047: LD_ADDR_VAR 0 1
13051: PUSH
13052: LD_VAR 0 2
13056: PUSH
13057: FOR_IN
13058: IFFALSE 13177
// if See ( 1 , i ) then
13060: LD_INT 1
13062: PPUSH
13063: LD_VAR 0 1
13067: PPUSH
13068: CALL_OW 292
13072: IFFALSE 13175
// begin seen := Replace ( seen , 5 , true ) ;
13074: LD_ADDR_EXP 9
13078: PUSH
13079: LD_EXP 9
13083: PPUSH
13084: LD_INT 5
13086: PPUSH
13087: LD_INT 1
13089: PPUSH
13090: CALL_OW 1
13094: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13095: LD_INT 1
13097: PPUSH
13098: CALL 15916 0 1
13102: IFFALSE 13175
// begin DialogueOn ;
13104: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13108: LD_VAR 0 1
13112: PPUSH
13113: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13117: LD_INT 10
13119: PPUSH
13120: CALL_OW 68
// un := SayRand ( sex_male , D8a-Sol2-1 ) ;
13124: LD_ADDR_VAR 0 3
13128: PUSH
13129: LD_INT 1
13131: PPUSH
13132: LD_STRING D8a-Sol2-1
13134: PPUSH
13135: CALL 16094 0 2
13139: ST_TO_ADDR
// if not un then
13140: LD_VAR 0 3
13144: NOT
13145: IFFALSE 13157
// SayRand ( sex_female , D8a-FSol2-1 ) ;
13147: LD_INT 2
13149: PPUSH
13150: LD_STRING D8a-FSol2-1
13152: PPUSH
13153: CALL 16094 0 2
// Say ( JMM , D8a-JMM-1 ) ;
13157: LD_EXP 21
13161: PPUSH
13162: LD_STRING D8a-JMM-1
13164: PPUSH
13165: CALL_OW 88
// DialogueOff ;
13169: CALL_OW 7
// break ;
13173: GO 13177
// end ; end ;
13175: GO 13057
13177: POP
13178: POP
// end ; if seen [ 1 ] and seen [ 2 ] and seen [ 3 ] and seen [ 4 ] and seen [ 5 ] then
13179: LD_EXP 9
13183: PUSH
13184: LD_INT 1
13186: ARRAY
13187: PUSH
13188: LD_EXP 9
13192: PUSH
13193: LD_INT 2
13195: ARRAY
13196: AND
13197: PUSH
13198: LD_EXP 9
13202: PUSH
13203: LD_INT 3
13205: ARRAY
13206: AND
13207: PUSH
13208: LD_EXP 9
13212: PUSH
13213: LD_INT 4
13215: ARRAY
13216: AND
13217: PUSH
13218: LD_EXP 9
13222: PUSH
13223: LD_INT 5
13225: ARRAY
13226: AND
13227: IFFALSE 13230
// disable ;
13229: DISABLE
// end ;
13230: PPOPN 4
13232: END
// every 0 0$1 trigger can_kamikazed and kamikazed do var un ;
13233: LD_EXP 10
13237: PUSH
13238: LD_EXP 11
13242: AND
13243: IFFALSE 13441
13245: GO 13247
13247: DISABLE
13248: LD_INT 0
13250: PPUSH
// begin DialogueOn ;
13251: CALL_OW 6
// CenterNowOnUnits ( kamikazed ) ;
13255: LD_EXP 11
13259: PPUSH
13260: CALL_OW 87
// un := SayRand ( sex_male , D5c-Sol1-1 ) ;
13264: LD_ADDR_VAR 0 1
13268: PUSH
13269: LD_INT 1
13271: PPUSH
13272: LD_STRING D5c-Sol1-1
13274: PPUSH
13275: CALL 16094 0 2
13279: ST_TO_ADDR
// if not un then
13280: LD_VAR 0 1
13284: NOT
13285: IFFALSE 13303
// un := SayRand ( sex_female , D5c-FSol1-1 ) ;
13287: LD_ADDR_VAR 0 1
13291: PUSH
13292: LD_INT 2
13294: PPUSH
13295: LD_STRING D5c-FSol1-1
13297: PPUSH
13298: CALL 16094 0 2
13302: ST_TO_ADDR
// Say ( JMM , D5c-JMM-1 ) ;
13303: LD_EXP 21
13307: PPUSH
13308: LD_STRING D5c-JMM-1
13310: PPUSH
13311: CALL_OW 88
// if IsOk ( Lisa ) then
13315: LD_EXP 22
13319: PPUSH
13320: CALL_OW 302
13324: IFFALSE 13340
// Say ( Lisa , D5d-Lisa-1 ) else
13326: LD_EXP 22
13330: PPUSH
13331: LD_STRING D5d-Lisa-1
13333: PPUSH
13334: CALL_OW 88
13338: GO 13425
// if IsOk ( Cyrus ) then
13340: LD_EXP 25
13344: PPUSH
13345: CALL_OW 302
13349: IFFALSE 13365
// Say ( Cyrus , D5d-Cyrus-1 ) else
13351: LD_EXP 25
13355: PPUSH
13356: LD_STRING D5d-Cyrus-1
13358: PPUSH
13359: CALL_OW 88
13363: GO 13425
// if IsOk ( Gary ) then
13365: LD_EXP 32
13369: PPUSH
13370: CALL_OW 302
13374: IFFALSE 13390
// Say ( Gary , D5d-Gary-1 ) else
13376: LD_EXP 32
13380: PPUSH
13381: LD_STRING D5d-Gary-1
13383: PPUSH
13384: CALL_OW 88
13388: GO 13425
// if GetSex ( un ) = sex_male then
13390: LD_VAR 0 1
13394: PPUSH
13395: CALL_OW 258
13399: PUSH
13400: LD_INT 1
13402: EQUAL
13403: IFFALSE 13419
// Say ( un , D5d-Sol1-1 ) else
13405: LD_VAR 0 1
13409: PPUSH
13410: LD_STRING D5d-Sol1-1
13412: PPUSH
13413: CALL_OW 88
13417: GO 13425
// begin DialogueOff ;
13419: CALL_OW 7
// exit ;
13423: GO 13441
// end ; Say ( JMM , D5d-JMM-1 ) ;
13425: LD_EXP 21
13429: PPUSH
13430: LD_STRING D5d-JMM-1
13432: PPUSH
13433: CALL_OW 88
// DialogueOff ;
13437: CALL_OW 7
// end ;
13441: PPOPN 1
13443: END
// every 0 0$2 trigger SeeArea ( 1 , artifact_area ) >= 2 do var un ;
13444: LD_INT 1
13446: PPUSH
13447: LD_INT 17
13449: PPUSH
13450: CALL_OW 294
13454: PUSH
13455: LD_INT 2
13457: GREATEREQUAL
13458: IFFALSE 13579
13460: GO 13462
13462: DISABLE
13463: LD_INT 0
13465: PPUSH
// begin PlaceSeeing ( 10 , 5 , 1 , - 10 ) ;
13466: LD_INT 10
13468: PPUSH
13469: LD_INT 5
13471: PPUSH
13472: LD_INT 1
13474: PPUSH
13475: LD_INT 10
13477: NEG
13478: PPUSH
13479: CALL_OW 330
// RemoveSeeing ( 10 , 5 , 1 ) ;
13483: LD_INT 10
13485: PPUSH
13486: LD_INT 5
13488: PPUSH
13489: LD_INT 1
13491: PPUSH
13492: CALL_OW 331
// CenterNowOnXY ( 10 , 5 ) ;
13496: LD_INT 10
13498: PPUSH
13499: LD_INT 5
13501: PPUSH
13502: CALL_OW 86
// DialogueOn ;
13506: CALL_OW 6
// un := SayRand ( sex_male , D6-Sci1-1 ) ;
13510: LD_ADDR_VAR 0 1
13514: PUSH
13515: LD_INT 1
13517: PPUSH
13518: LD_STRING D6-Sci1-1
13520: PPUSH
13521: CALL 16094 0 2
13525: ST_TO_ADDR
// if un then
13526: LD_VAR 0 1
13530: IFFALSE 13568
// begin Say ( JMM , D6-JMM-1 ) ;
13532: LD_EXP 21
13536: PPUSH
13537: LD_STRING D6-JMM-1
13539: PPUSH
13540: CALL_OW 88
// Say ( un , D6-Sci1-2 ) ;
13544: LD_VAR 0 1
13548: PPUSH
13549: LD_STRING D6-Sci1-2
13551: PPUSH
13552: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
13556: LD_EXP 21
13560: PPUSH
13561: LD_STRING D6-JMM-2
13563: PPUSH
13564: CALL_OW 88
// end ; DialogueOff ;
13568: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
13572: LD_STRING M3
13574: PPUSH
13575: CALL_OW 337
// end ;
13579: PPOPN 1
13581: END
// export ar_mechanic , ar_mechanic_friend ; every 0 0$20 trigger tick >= 20 20$00 and ( DangerAtRangeXY ( 2 , 169 , 90 , 10 ) [ 4 ] = 0 or IsDead ( ar_dep_w ) or GetSide ( ar_dep_w ) = 1 ) and not IsDead ( ar_dep_n ) do var un , i , cargo , tmp , escaped ;
13582: LD_OWVAR 1
13586: PUSH
13587: LD_INT 42000
13589: GREATEREQUAL
13590: PUSH
13591: LD_INT 2
13593: PPUSH
13594: LD_INT 169
13596: PPUSH
13597: LD_INT 90
13599: PPUSH
13600: LD_INT 10
13602: PPUSH
13603: CALL 55451 0 4
13607: PUSH
13608: LD_INT 4
13610: ARRAY
13611: PUSH
13612: LD_INT 0
13614: EQUAL
13615: PUSH
13616: LD_INT 45
13618: PPUSH
13619: CALL_OW 301
13623: OR
13624: PUSH
13625: LD_INT 45
13627: PPUSH
13628: CALL_OW 255
13632: PUSH
13633: LD_INT 1
13635: EQUAL
13636: OR
13637: AND
13638: PUSH
13639: LD_INT 94
13641: PPUSH
13642: CALL_OW 301
13646: NOT
13647: AND
13648: IFFALSE 14853
13650: GO 13652
13652: DISABLE
13653: LD_INT 0
13655: PPUSH
13656: PPUSH
13657: PPUSH
13658: PPUSH
13659: PPUSH
// begin uc_side := 5 ;
13660: LD_ADDR_OWVAR 20
13664: PUSH
13665: LD_INT 5
13667: ST_TO_ADDR
// uc_nation := 2 ;
13668: LD_ADDR_OWVAR 21
13672: PUSH
13673: LD_INT 2
13675: ST_TO_ADDR
// InitHc ;
13676: CALL_OW 19
// PrepareHuman ( sex_male , 3 , 8 ) ;
13680: LD_INT 1
13682: PPUSH
13683: LD_INT 3
13685: PPUSH
13686: LD_INT 8
13688: PPUSH
13689: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
13693: LD_ADDR_OWVAR 29
13697: PUSH
13698: LD_INT 12
13700: PUSH
13701: LD_INT 12
13703: PUSH
13704: EMPTY
13705: LIST
13706: LIST
13707: ST_TO_ADDR
// hc_name := Hans Felige ;
13708: LD_ADDR_OWVAR 26
13712: PUSH
13713: LD_STRING Hans Felige
13715: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
13716: LD_ADDR_OWVAR 33
13720: PUSH
13721: LD_STRING SecondCharsGal
13723: ST_TO_ADDR
// hc_face_number := 7 ;
13724: LD_ADDR_OWVAR 34
13728: PUSH
13729: LD_INT 7
13731: ST_TO_ADDR
// ar_mechanic := CreateHuman ;
13732: LD_ADDR_EXP 46
13736: PUSH
13737: CALL_OW 44
13741: ST_TO_ADDR
// InitHc ;
13742: CALL_OW 19
// PrepareHuman ( sex_male , 16 , 2 ) ;
13746: LD_INT 1
13748: PPUSH
13749: LD_INT 16
13751: PPUSH
13752: LD_INT 2
13754: PPUSH
13755: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
13759: LD_ADDR_OWVAR 29
13763: PUSH
13764: LD_INT 12
13766: PUSH
13767: LD_INT 12
13769: PUSH
13770: EMPTY
13771: LIST
13772: LIST
13773: ST_TO_ADDR
// hc_name :=  ;
13774: LD_ADDR_OWVAR 26
13778: PUSH
13779: LD_STRING 
13781: ST_TO_ADDR
// ar_mechanic_friend := CreateHuman ;
13782: LD_ADDR_EXP 47
13786: PUSH
13787: CALL_OW 44
13791: ST_TO_ADDR
// InitHc ;
13792: CALL_OW 19
// repeat wait ( 0 0$1 ) ;
13796: LD_INT 35
13798: PPUSH
13799: CALL_OW 67
// until not InBattle ( 1 ) ;
13803: LD_INT 1
13805: PPUSH
13806: CALL_OW 463
13810: NOT
13811: IFFALSE 13796
// wait ( 0 0$5 ) ;
13813: LD_INT 175
13815: PPUSH
13816: CALL_OW 67
// DialogueOn ;
13820: CALL_OW 6
// InGameOn ;
13824: CALL_OW 8
// un := UnitFilter ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , [ f_sex , sex_male ] ) [ 1 ] ;
13828: LD_ADDR_VAR 0 1
13832: PUSH
13833: LD_INT 22
13835: PUSH
13836: LD_INT 1
13838: PUSH
13839: EMPTY
13840: LIST
13841: LIST
13842: PUSH
13843: LD_INT 2
13845: PUSH
13846: LD_INT 25
13848: PUSH
13849: LD_INT 1
13851: PUSH
13852: EMPTY
13853: LIST
13854: LIST
13855: PUSH
13856: LD_INT 25
13858: PUSH
13859: LD_INT 2
13861: PUSH
13862: EMPTY
13863: LIST
13864: LIST
13865: PUSH
13866: LD_INT 25
13868: PUSH
13869: LD_INT 3
13871: PUSH
13872: EMPTY
13873: LIST
13874: LIST
13875: PUSH
13876: LD_INT 25
13878: PUSH
13879: LD_INT 4
13881: PUSH
13882: EMPTY
13883: LIST
13884: LIST
13885: PUSH
13886: LD_INT 25
13888: PUSH
13889: LD_INT 5
13891: PUSH
13892: EMPTY
13893: LIST
13894: LIST
13895: PUSH
13896: LD_INT 25
13898: PUSH
13899: LD_INT 8
13901: PUSH
13902: EMPTY
13903: LIST
13904: LIST
13905: PUSH
13906: EMPTY
13907: LIST
13908: LIST
13909: LIST
13910: LIST
13911: LIST
13912: LIST
13913: LIST
13914: PUSH
13915: EMPTY
13916: LIST
13917: LIST
13918: PPUSH
13919: CALL_OW 69
13923: PUSH
13924: LD_EXP 21
13928: PUSH
13929: LD_EXP 22
13933: PUSH
13934: LD_EXP 23
13938: PUSH
13939: LD_EXP 24
13943: PUSH
13944: LD_EXP 25
13948: PUSH
13949: LD_EXP 26
13953: PUSH
13954: LD_EXP 27
13958: PUSH
13959: LD_EXP 28
13963: PUSH
13964: LD_EXP 29
13968: PUSH
13969: LD_EXP 31
13973: PUSH
13974: LD_EXP 32
13978: PUSH
13979: LD_EXP 33
13983: PUSH
13984: LD_EXP 34
13988: PUSH
13989: EMPTY
13990: LIST
13991: LIST
13992: LIST
13993: LIST
13994: LIST
13995: LIST
13996: LIST
13997: LIST
13998: LIST
13999: LIST
14000: LIST
14001: LIST
14002: LIST
14003: DIFF
14004: PPUSH
14005: LD_INT 26
14007: PUSH
14008: LD_INT 1
14010: PUSH
14011: EMPTY
14012: LIST
14013: LIST
14014: PPUSH
14015: CALL_OW 72
14019: PUSH
14020: LD_INT 1
14022: ARRAY
14023: ST_TO_ADDR
// if Brown then
14024: LD_EXP 27
14028: IFFALSE 14040
// un := Brown ;
14030: LD_ADDR_VAR 0 1
14034: PUSH
14035: LD_EXP 27
14039: ST_TO_ADDR
// if un then
14040: LD_VAR 0 1
14044: IFFALSE 14070
// begin Say ( un , D7-Sol1-1 ) ;
14046: LD_VAR 0 1
14050: PPUSH
14051: LD_STRING D7-Sol1-1
14053: PPUSH
14054: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
14058: LD_EXP 21
14062: PPUSH
14063: LD_STRING D7-JMM-1
14065: PPUSH
14066: CALL_OW 88
// end ; SayRadio ( ar_mechanic , D7-Ar1-1 ) ;
14070: LD_EXP 46
14074: PPUSH
14075: LD_STRING D7-Ar1-1
14077: PPUSH
14078: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
14082: LD_EXP 21
14086: PPUSH
14087: LD_STRING D7-JMM-2
14089: PPUSH
14090: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-2 ) ;
14094: LD_EXP 46
14098: PPUSH
14099: LD_STRING D7-Ar1-2
14101: PPUSH
14102: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
14106: LD_EXP 21
14110: PPUSH
14111: LD_STRING D7-JMM-3
14113: PPUSH
14114: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-3 ) ;
14118: LD_EXP 46
14122: PPUSH
14123: LD_STRING D7-Ar1-3
14125: PPUSH
14126: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
14130: LD_EXP 21
14134: PPUSH
14135: LD_STRING D7-JMM-4
14137: PPUSH
14138: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-4 ) ;
14142: LD_EXP 46
14146: PPUSH
14147: LD_STRING D7-Ar1-4
14149: PPUSH
14150: CALL_OW 94
// InGameOff ;
14154: CALL_OW 9
// DialogueOff ;
14158: CALL_OW 7
// case Query ( QCameras ) of 1 :
14162: LD_STRING QCameras
14164: PPUSH
14165: CALL_OW 97
14169: PUSH
14170: LD_INT 1
14172: DOUBLE
14173: EQUAL
14174: IFTRUE 14178
14176: GO 14181
14178: POP
// ; 2 :
14179: GO 14195
14181: LD_INT 2
14183: DOUBLE
14184: EQUAL
14185: IFTRUE 14189
14187: GO 14194
14189: POP
// exit ; end ;
14190: GO 14853
14192: GO 14195
14194: POP
// ChangeMissionObjectives ( MCar ) ;
14195: LD_STRING MCar
14197: PPUSH
14198: CALL_OW 337
// PlaceSeeing ( 124 , 90 , 1 , - 6 ) ;
14202: LD_INT 124
14204: PPUSH
14205: LD_INT 90
14207: PPUSH
14208: LD_INT 1
14210: PPUSH
14211: LD_INT 6
14213: NEG
14214: PPUSH
14215: CALL_OW 330
// RemoveSeeing ( 124 , 90 , 1 ) ;
14219: LD_INT 124
14221: PPUSH
14222: LD_INT 90
14224: PPUSH
14225: LD_INT 1
14227: PPUSH
14228: CALL_OW 331
// SetAreaMapShow ( parking_marea , 1 ) ;
14232: LD_INT 12
14234: PPUSH
14235: LD_INT 1
14237: PPUSH
14238: CALL_OW 424
// wait ( 3 ) ;
14242: LD_INT 3
14244: PPUSH
14245: CALL_OW 67
// CenterNowOnXY ( 124 , 90 ) ;
14249: LD_INT 124
14251: PPUSH
14252: LD_INT 90
14254: PPUSH
14255: CALL_OW 86
// cargo := false ;
14259: LD_ADDR_VAR 0 3
14263: PUSH
14264: LD_INT 0
14266: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
14267: LD_INT 35
14269: PPUSH
14270: CALL_OW 67
// cargo := FilterUnitsInArea ( parking_marea , [ [ f_engine , engine_siberite ] , [ f_weapon , ar_cargo_bay ] , [ f_empty ] ] ) ;
14274: LD_ADDR_VAR 0 3
14278: PUSH
14279: LD_INT 12
14281: PPUSH
14282: LD_INT 32
14284: PUSH
14285: LD_INT 3
14287: PUSH
14288: EMPTY
14289: LIST
14290: LIST
14291: PUSH
14292: LD_INT 34
14294: PUSH
14295: LD_INT 32
14297: PUSH
14298: EMPTY
14299: LIST
14300: LIST
14301: PUSH
14302: LD_INT 58
14304: PUSH
14305: EMPTY
14306: LIST
14307: PUSH
14308: EMPTY
14309: LIST
14310: LIST
14311: LIST
14312: PPUSH
14313: CALL_OW 70
14317: ST_TO_ADDR
// until cargo ;
14318: LD_VAR 0 3
14322: IFFALSE 14267
// cargo := cargo [ 1 ] ;
14324: LD_ADDR_VAR 0 3
14328: PUSH
14329: LD_VAR 0 3
14333: PUSH
14334: LD_INT 1
14336: ARRAY
14337: ST_TO_ADDR
// SetSide ( cargo , 5 ) ;
14338: LD_VAR 0 3
14342: PPUSH
14343: LD_INT 5
14345: PPUSH
14346: CALL_OW 235
// SetAreaMapShow ( parking_marea , 0 ) ;
14350: LD_INT 12
14352: PPUSH
14353: LD_INT 0
14355: PPUSH
14356: CALL_OW 424
// PlaceUnitArea ( ar_mechanic , mechanic_spawn , false ) ;
14360: LD_EXP 46
14364: PPUSH
14365: LD_INT 11
14367: PPUSH
14368: LD_INT 0
14370: PPUSH
14371: CALL_OW 49
// PlaceUnitArea ( ar_mechanic_friend , mechanic_spawn , false ) ;
14375: LD_EXP 47
14379: PPUSH
14380: LD_INT 11
14382: PPUSH
14383: LD_INT 0
14385: PPUSH
14386: CALL_OW 49
// ComMoveToArea ( [ ar_mechanic , ar_mechanic_friend ] , parking_marea ) ;
14390: LD_EXP 46
14394: PUSH
14395: LD_EXP 47
14399: PUSH
14400: EMPTY
14401: LIST
14402: LIST
14403: PPUSH
14404: LD_INT 12
14406: PPUSH
14407: CALL_OW 113
// AddComEnterUnit ( ar_mechanic , cargo ) ;
14411: LD_EXP 46
14415: PPUSH
14416: LD_VAR 0 3
14420: PPUSH
14421: CALL_OW 180
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
14425: LD_EXP 46
14429: PUSH
14430: LD_EXP 47
14434: PUSH
14435: EMPTY
14436: LIST
14437: LIST
14438: PPUSH
14439: LD_INT 209
14441: PPUSH
14442: LD_INT 178
14444: PPUSH
14445: CALL_OW 171
// escaped := 0 ;
14449: LD_ADDR_VAR 0 5
14453: PUSH
14454: LD_INT 0
14456: ST_TO_ADDR
// while ( true ) do
14457: LD_INT 1
14459: IFFALSE 14675
// begin wait ( 0 0$1 ) ;
14461: LD_INT 35
14463: PPUSH
14464: CALL_OW 67
// if not HasTask ( ar_mechanic ) or not HasTask ( ar_mechanic_friend ) then
14468: LD_EXP 46
14472: PPUSH
14473: CALL_OW 314
14477: NOT
14478: PUSH
14479: LD_EXP 47
14483: PPUSH
14484: CALL_OW 314
14488: NOT
14489: OR
14490: IFFALSE 14516
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
14492: LD_EXP 46
14496: PUSH
14497: LD_EXP 47
14501: PUSH
14502: EMPTY
14503: LIST
14504: LIST
14505: PPUSH
14506: LD_INT 209
14508: PPUSH
14509: LD_INT 178
14511: PPUSH
14512: CALL_OW 171
// if IsInArea ( ar_mechanic , escape_area ) then
14516: LD_EXP 46
14520: PPUSH
14521: LD_INT 10
14523: PPUSH
14524: CALL_OW 308
14528: IFFALSE 14553
// begin RemoveUnit ( ar_mechanic ) ;
14530: LD_EXP 46
14534: PPUSH
14535: CALL_OW 64
// escaped := escaped + 1 ;
14539: LD_ADDR_VAR 0 5
14543: PUSH
14544: LD_VAR 0 5
14548: PUSH
14549: LD_INT 1
14551: PLUS
14552: ST_TO_ADDR
// end ; if IsInArea ( ar_mechanic_friend , escape_area ) then
14553: LD_EXP 47
14557: PPUSH
14558: LD_INT 10
14560: PPUSH
14561: CALL_OW 308
14565: IFFALSE 14590
// begin RemoveUnit ( ar_mechanic_friend ) ;
14567: LD_EXP 47
14571: PPUSH
14572: CALL_OW 64
// escaped := escaped + 1 ;
14576: LD_ADDR_VAR 0 5
14580: PUSH
14581: LD_VAR 0 5
14585: PUSH
14586: LD_INT 1
14588: PLUS
14589: ST_TO_ADDR
// end ; if IsInArea ( cargo , escape_area ) then
14590: LD_VAR 0 3
14594: PPUSH
14595: LD_INT 10
14597: PPUSH
14598: CALL_OW 308
14602: IFFALSE 14613
// RemoveUnit ( cargo ) ;
14604: LD_VAR 0 3
14608: PPUSH
14609: CALL_OW 64
// if not IsPlaced ( ar_mechanic ) and escaped >= 2 then
14613: LD_EXP 46
14617: PPUSH
14618: CALL_OW 305
14622: NOT
14623: PUSH
14624: LD_VAR 0 5
14628: PUSH
14629: LD_INT 2
14631: GREATEREQUAL
14632: AND
14633: IFFALSE 14637
// break ;
14635: GO 14675
// if not IsPlaced ( ar_mechanic ) and not IsPlaced ( ar_mechanic_friend ) and escaped < 2 then
14637: LD_EXP 46
14641: PPUSH
14642: CALL_OW 305
14646: NOT
14647: PUSH
14648: LD_EXP 47
14652: PPUSH
14653: CALL_OW 305
14657: NOT
14658: AND
14659: PUSH
14660: LD_VAR 0 5
14664: PUSH
14665: LD_INT 2
14667: LESS
14668: AND
14669: IFFALSE 14673
// exit ;
14671: GO 14853
// end ;
14673: GO 14457
// wait ( 0 0$2 ) ;
14675: LD_INT 70
14677: PPUSH
14678: CALL_OW 67
// SayRadio ( ar_mechanic , D7a-Ar1-1 ) ;
14682: LD_EXP 46
14686: PPUSH
14687: LD_STRING D7a-Ar1-1
14689: PPUSH
14690: CALL_OW 94
// tmp := [ [ 129 , 10 ] , [ 103 , 6 ] , [ 148 , 47 ] , [ 155 , 16 ] ] ;
14694: LD_ADDR_VAR 0 4
14698: PUSH
14699: LD_INT 129
14701: PUSH
14702: LD_INT 10
14704: PUSH
14705: EMPTY
14706: LIST
14707: LIST
14708: PUSH
14709: LD_INT 103
14711: PUSH
14712: LD_INT 6
14714: PUSH
14715: EMPTY
14716: LIST
14717: LIST
14718: PUSH
14719: LD_INT 148
14721: PUSH
14722: LD_INT 47
14724: PUSH
14725: EMPTY
14726: LIST
14727: LIST
14728: PUSH
14729: LD_INT 155
14731: PUSH
14732: LD_INT 16
14734: PUSH
14735: EMPTY
14736: LIST
14737: LIST
14738: PUSH
14739: EMPTY
14740: LIST
14741: LIST
14742: LIST
14743: LIST
14744: ST_TO_ADDR
// if Difficulty = 1 then
14745: LD_OWVAR 67
14749: PUSH
14750: LD_INT 1
14752: EQUAL
14753: IFFALSE 14790
// tmp := tmp ^ [ [ 78 , 7 ] , [ 104 , 43 ] ] ;
14755: LD_ADDR_VAR 0 4
14759: PUSH
14760: LD_VAR 0 4
14764: PUSH
14765: LD_INT 78
14767: PUSH
14768: LD_INT 7
14770: PUSH
14771: EMPTY
14772: LIST
14773: LIST
14774: PUSH
14775: LD_INT 104
14777: PUSH
14778: LD_INT 43
14780: PUSH
14781: EMPTY
14782: LIST
14783: LIST
14784: PUSH
14785: EMPTY
14786: LIST
14787: LIST
14788: ADD
14789: ST_TO_ADDR
// for i in tmp do
14790: LD_ADDR_VAR 0 2
14794: PUSH
14795: LD_VAR 0 4
14799: PUSH
14800: FOR_IN
14801: IFFALSE 14834
// PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 9 ) ;
14803: LD_VAR 0 2
14807: PUSH
14808: LD_INT 1
14810: ARRAY
14811: PPUSH
14812: LD_VAR 0 2
14816: PUSH
14817: LD_INT 2
14819: ARRAY
14820: PPUSH
14821: LD_INT 1
14823: PPUSH
14824: LD_INT 9
14826: NEG
14827: PPUSH
14828: CALL_OW 330
14832: GO 14800
14834: POP
14835: POP
// SetAchievement ( ACH_FRIEND ) ;
14836: LD_STRING ACH_FRIEND
14838: PPUSH
14839: CALL_OW 543
// CenterOnXY ( 129 , 10 ) ;
14843: LD_INT 129
14845: PPUSH
14846: LD_INT 10
14848: PPUSH
14849: CALL_OW 84
// end ;
14853: PPOPN 5
14855: END
// every 0 0$1 trigger game_time - 10 10$00 <= tick do
14856: LD_EXP 15
14860: PUSH
14861: LD_INT 21000
14863: MINUS
14864: PUSH
14865: LD_OWVAR 1
14869: LESSEQUAL
14870: IFFALSE 14910
14872: GO 14874
14874: DISABLE
// begin powell_warn := true ;
14875: LD_ADDR_EXP 16
14879: PUSH
14880: LD_INT 1
14882: ST_TO_ADDR
// DialogueOn ;
14883: CALL_OW 6
// SayRadio ( Powell , D9-Pow-1 ) ;
14887: LD_EXP 30
14891: PPUSH
14892: LD_STRING D9-Pow-1
14894: PPUSH
14895: CALL_OW 94
// dwait ( 0 0$0.3 ) ;
14899: LD_INT 10
14901: PPUSH
14902: CALL_OW 68
// DialogueOff ;
14906: CALL_OW 7
// end ;
14910: END
// every 0 0$1 trigger game_time <= tick do
14911: LD_EXP 15
14915: PUSH
14916: LD_OWVAR 1
14920: LESSEQUAL
14921: IFFALSE 14960
14923: GO 14925
14925: DISABLE
// begin DialogueOn ;
14926: CALL_OW 6
// SayRadio ( Powell , D9a-Pow-1 ) ;
14930: LD_EXP 30
14934: PPUSH
14935: LD_STRING D9a-Pow-1
14937: PPUSH
14938: CALL_OW 94
// dwait ( 0 0$2 ) ;
14942: LD_INT 70
14944: PPUSH
14945: CALL_OW 68
// DialogueOff ;
14949: CALL_OW 7
// YouLost ( Command ) ;
14953: LD_STRING Command
14955: PPUSH
14956: CALL_OW 104
// end ;
14960: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_warehouse ] ] ) = 0 and IsOk ( JMM ) do var tmp , m1 , m2 , m3 ;
14961: LD_INT 22
14963: PUSH
14964: LD_INT 2
14966: PUSH
14967: EMPTY
14968: LIST
14969: LIST
14970: PUSH
14971: LD_INT 30
14973: PUSH
14974: LD_INT 1
14976: PUSH
14977: EMPTY
14978: LIST
14979: LIST
14980: PUSH
14981: EMPTY
14982: LIST
14983: LIST
14984: PPUSH
14985: CALL_OW 69
14989: PUSH
14990: LD_INT 0
14992: EQUAL
14993: PUSH
14994: LD_EXP 21
14998: PPUSH
14999: CALL_OW 302
15003: AND
15004: IFFALSE 15913
15006: GO 15008
15008: DISABLE
15009: LD_INT 0
15011: PPUSH
15012: PPUSH
15013: PPUSH
15014: PPUSH
// begin m1 := false ;
15015: LD_ADDR_VAR 0 2
15019: PUSH
15020: LD_INT 0
15022: ST_TO_ADDR
// m2 := false ;
15023: LD_ADDR_VAR 0 3
15027: PUSH
15028: LD_INT 0
15030: ST_TO_ADDR
// m3 := false ;
15031: LD_ADDR_VAR 0 4
15035: PUSH
15036: LD_INT 0
15038: ST_TO_ADDR
// if not am_veh_consturcted then
15039: LD_EXP 20
15043: NOT
15044: IFFALSE 15053
// SetAchievement ( ACH_ARABTECH ) ;
15046: LD_STRING ACH_ARABTECH
15048: PPUSH
15049: CALL_OW 543
// if tick < [ 120 120$00 , 100 100$00 , 95 95$00 ] [ Difficulty ] then
15053: LD_OWVAR 1
15057: PUSH
15058: LD_INT 252000
15060: PUSH
15061: LD_INT 210000
15063: PUSH
15064: LD_INT 199500
15066: PUSH
15067: EMPTY
15068: LIST
15069: LIST
15070: LIST
15071: PUSH
15072: LD_OWVAR 67
15076: ARRAY
15077: LESS
15078: IFFALSE 15100
// begin m3 := true ;
15080: LD_ADDR_VAR 0 4
15084: PUSH
15085: LD_INT 1
15087: ST_TO_ADDR
// AddMedal ( Time1 , 1 ) ;
15088: LD_STRING Time1
15090: PPUSH
15091: LD_INT 1
15093: PPUSH
15094: CALL_OW 101
// end else
15098: GO 15131
// if not powell_warn then
15100: LD_EXP 16
15104: NOT
15105: IFFALSE 15120
// AddMedal ( Time1 , - 1 ) else
15107: LD_STRING Time1
15109: PPUSH
15110: LD_INT 1
15112: NEG
15113: PPUSH
15114: CALL_OW 101
15118: GO 15131
// AddMedal ( Time1 , - 2 ) ;
15120: LD_STRING Time1
15122: PPUSH
15123: LD_INT 2
15125: NEG
15126: PPUSH
15127: CALL_OW 101
// if loses_counter >= [ 5 , 4 , 3 ] [ Difficulty ] then
15131: LD_EXP 17
15135: PUSH
15136: LD_INT 5
15138: PUSH
15139: LD_INT 4
15141: PUSH
15142: LD_INT 3
15144: PUSH
15145: EMPTY
15146: LIST
15147: LIST
15148: LIST
15149: PUSH
15150: LD_OWVAR 67
15154: ARRAY
15155: GREATEREQUAL
15156: IFFALSE 15171
// AddMedal ( Destroy , - 2 ) else
15158: LD_STRING Destroy
15160: PPUSH
15161: LD_INT 2
15163: NEG
15164: PPUSH
15165: CALL_OW 101
15169: GO 15304
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 25 then
15171: LD_INT 22
15173: PUSH
15174: LD_INT 2
15176: PUSH
15177: EMPTY
15178: LIST
15179: LIST
15180: PUSH
15181: LD_INT 21
15183: PUSH
15184: LD_INT 3
15186: PUSH
15187: EMPTY
15188: LIST
15189: LIST
15190: PUSH
15191: LD_INT 50
15193: PUSH
15194: EMPTY
15195: LIST
15196: PUSH
15197: EMPTY
15198: LIST
15199: LIST
15200: LIST
15201: PPUSH
15202: CALL_OW 69
15206: PUSH
15207: LD_INT 25
15209: GREATEREQUAL
15210: IFFALSE 15225
// AddMedal ( Destroy , - 1 ) else
15212: LD_STRING Destroy
15214: PPUSH
15215: LD_INT 1
15217: NEG
15218: PPUSH
15219: CALL_OW 101
15223: GO 15304
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 15 then
15225: LD_INT 22
15227: PUSH
15228: LD_INT 2
15230: PUSH
15231: EMPTY
15232: LIST
15233: LIST
15234: PUSH
15235: LD_INT 21
15237: PUSH
15238: LD_INT 3
15240: PUSH
15241: EMPTY
15242: LIST
15243: LIST
15244: PUSH
15245: LD_INT 50
15247: PUSH
15248: EMPTY
15249: LIST
15250: PUSH
15251: EMPTY
15252: LIST
15253: LIST
15254: LIST
15255: PPUSH
15256: CALL_OW 69
15260: PUSH
15261: LD_INT 15
15263: GREATEREQUAL
15264: IFFALSE 15286
// begin m1 := true ;
15266: LD_ADDR_VAR 0 2
15270: PUSH
15271: LD_INT 1
15273: ST_TO_ADDR
// AddMedal ( Destroy , 1 ) ;
15274: LD_STRING Destroy
15276: PPUSH
15277: LD_INT 1
15279: PPUSH
15280: CALL_OW 101
// end else
15284: GO 15304
// begin m1 := true ;
15286: LD_ADDR_VAR 0 2
15290: PUSH
15291: LD_INT 1
15293: ST_TO_ADDR
// AddMedal ( Destroy , 2 ) ;
15294: LD_STRING Destroy
15296: PPUSH
15297: LD_INT 2
15299: PPUSH
15300: CALL_OW 101
// end ; SaveVariable ( artifact_get , 11_artifact_captured ) ;
15304: LD_EXP 13
15308: PPUSH
15309: LD_STRING 11_artifact_captured
15311: PPUSH
15312: CALL_OW 39
// if artifact_get then
15316: LD_EXP 13
15320: IFFALSE 15342
// begin m2 := true ;
15322: LD_ADDR_VAR 0 3
15326: PUSH
15327: LD_INT 1
15329: ST_TO_ADDR
// AddMedal ( Artefact , 1 ) ;
15330: LD_STRING Artefact
15332: PPUSH
15333: LD_INT 1
15335: PPUSH
15336: CALL_OW 101
// end else
15340: GO 15353
// AddMedal ( Artefact , - 1 ) ;
15342: LD_STRING Artefact
15344: PPUSH
15345: LD_INT 1
15347: NEG
15348: PPUSH
15349: CALL_OW 101
// if m1 and m2 and m3 and Difficulty = 3 then
15353: LD_VAR 0 2
15357: PUSH
15358: LD_VAR 0 3
15362: AND
15363: PUSH
15364: LD_VAR 0 4
15368: AND
15369: PUSH
15370: LD_OWVAR 67
15374: PUSH
15375: LD_INT 3
15377: EQUAL
15378: AND
15379: IFFALSE 15391
// SetAchievementEX ( ACH_AMER , 11 ) ;
15381: LD_STRING ACH_AMER
15383: PPUSH
15384: LD_INT 11
15386: PPUSH
15387: CALL_OW 564
// if m1 and m2 and m3 and loses_counter = 0 then
15391: LD_VAR 0 2
15395: PUSH
15396: LD_VAR 0 3
15400: AND
15401: PUSH
15402: LD_VAR 0 4
15406: AND
15407: PUSH
15408: LD_EXP 17
15412: PUSH
15413: LD_INT 0
15415: EQUAL
15416: AND
15417: IFFALSE 15433
// begin wait ( 3 ) ;
15419: LD_INT 3
15421: PPUSH
15422: CALL_OW 67
// SetAchievement ( ACH_GENERAL ) ;
15426: LD_STRING ACH_GENERAL
15428: PPUSH
15429: CALL_OW 543
// end ; if tick <= 100 100$00 then
15433: LD_OWVAR 1
15437: PUSH
15438: LD_INT 210000
15440: LESSEQUAL
15441: IFFALSE 15457
// begin wait ( 3 ) ;
15443: LD_INT 3
15445: PPUSH
15446: CALL_OW 67
// SetAchievement ( ACH_ASPEED_11 ) ;
15450: LD_STRING ACH_ASPEED_11
15452: PPUSH
15453: CALL_OW 543
// end ; GiveMedals ( MAIN ) ;
15457: LD_STRING MAIN
15459: PPUSH
15460: CALL_OW 102
// selected := UnitFilter ( selected , [ f_alive ] ) ;
15464: LD_ADDR_EXP 19
15468: PUSH
15469: LD_EXP 19
15473: PPUSH
15474: LD_INT 51
15476: PUSH
15477: EMPTY
15478: LIST
15479: PPUSH
15480: CALL_OW 72
15484: ST_TO_ADDR
// tmp := JMM ^ selected ;
15485: LD_ADDR_VAR 0 1
15489: PUSH
15490: LD_EXP 21
15494: PUSH
15495: LD_EXP 19
15499: ADD
15500: ST_TO_ADDR
// RewardPeople ( tmp ) ;
15501: LD_VAR 0 1
15505: PPUSH
15506: CALL_OW 43
// SaveCharacters ( tmp diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , 11c_others ) ;
15510: LD_VAR 0 1
15514: PUSH
15515: LD_EXP 21
15519: PUSH
15520: LD_EXP 22
15524: PUSH
15525: LD_EXP 23
15529: PUSH
15530: LD_EXP 24
15534: PUSH
15535: LD_EXP 25
15539: PUSH
15540: LD_EXP 26
15544: PUSH
15545: LD_EXP 27
15549: PUSH
15550: LD_EXP 28
15554: PUSH
15555: LD_EXP 29
15559: PUSH
15560: LD_EXP 31
15564: PUSH
15565: LD_EXP 32
15569: PUSH
15570: LD_EXP 33
15574: PUSH
15575: LD_EXP 34
15579: PUSH
15580: EMPTY
15581: LIST
15582: LIST
15583: LIST
15584: LIST
15585: LIST
15586: LIST
15587: LIST
15588: LIST
15589: LIST
15590: LIST
15591: LIST
15592: LIST
15593: LIST
15594: DIFF
15595: PPUSH
15596: LD_STRING 11c_others
15598: PPUSH
15599: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
15603: LD_EXP 21
15607: PPUSH
15608: LD_EXP 3
15612: PUSH
15613: LD_STRING JMM
15615: STR
15616: PPUSH
15617: CALL_OW 38
// if Lisa then
15621: LD_EXP 22
15625: IFFALSE 15645
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
15627: LD_EXP 22
15631: PPUSH
15632: LD_EXP 3
15636: PUSH
15637: LD_STRING Lisa
15639: STR
15640: PPUSH
15641: CALL_OW 38
// if Donaldson then
15645: LD_EXP 23
15649: IFFALSE 15669
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
15651: LD_EXP 23
15655: PPUSH
15656: LD_EXP 3
15660: PUSH
15661: LD_STRING Donaldson
15663: STR
15664: PPUSH
15665: CALL_OW 38
// if Bobby then
15669: LD_EXP 24
15673: IFFALSE 15693
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
15675: LD_EXP 24
15679: PPUSH
15680: LD_EXP 3
15684: PUSH
15685: LD_STRING Bobby
15687: STR
15688: PPUSH
15689: CALL_OW 38
// if Cyrus then
15693: LD_EXP 25
15697: IFFALSE 15717
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
15699: LD_EXP 25
15703: PPUSH
15704: LD_EXP 3
15708: PUSH
15709: LD_STRING Cyrus
15711: STR
15712: PPUSH
15713: CALL_OW 38
// if Denis then
15717: LD_EXP 26
15721: IFFALSE 15741
// SaveCharacters ( Denis , mission_prefix & Denis ) ;
15723: LD_EXP 26
15727: PPUSH
15728: LD_EXP 3
15732: PUSH
15733: LD_STRING Denis
15735: STR
15736: PPUSH
15737: CALL_OW 38
// if Brown then
15741: LD_EXP 27
15745: IFFALSE 15765
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
15747: LD_EXP 27
15751: PPUSH
15752: LD_EXP 3
15756: PUSH
15757: LD_STRING Brown
15759: STR
15760: PPUSH
15761: CALL_OW 38
// if Gladstone then
15765: LD_EXP 28
15769: IFFALSE 15789
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
15771: LD_EXP 28
15775: PPUSH
15776: LD_EXP 3
15780: PUSH
15781: LD_STRING Gladstone
15783: STR
15784: PPUSH
15785: CALL_OW 38
// if Houten then
15789: LD_EXP 29
15793: IFFALSE 15813
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
15795: LD_EXP 29
15799: PPUSH
15800: LD_EXP 3
15804: PUSH
15805: LD_STRING Houten
15807: STR
15808: PPUSH
15809: CALL_OW 38
// if Cornel then
15813: LD_EXP 31
15817: IFFALSE 15837
// SaveCharacters ( Cornel , mission_prefix & Cornell ) ;
15819: LD_EXP 31
15823: PPUSH
15824: LD_EXP 3
15828: PUSH
15829: LD_STRING Cornell
15831: STR
15832: PPUSH
15833: CALL_OW 38
// if Gary then
15837: LD_EXP 32
15841: IFFALSE 15861
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
15843: LD_EXP 32
15847: PPUSH
15848: LD_EXP 3
15852: PUSH
15853: LD_STRING Gary
15855: STR
15856: PPUSH
15857: CALL_OW 38
// if Frank then
15861: LD_EXP 33
15865: IFFALSE 15885
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
15867: LD_EXP 33
15871: PPUSH
15872: LD_EXP 3
15876: PUSH
15877: LD_STRING Frank
15879: STR
15880: PPUSH
15881: CALL_OW 38
// if Kikuchi then
15885: LD_EXP 34
15889: IFFALSE 15909
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
15891: LD_EXP 34
15895: PPUSH
15896: LD_EXP 3
15900: PUSH
15901: LD_STRING Kikuchi
15903: STR
15904: PPUSH
15905: CALL_OW 38
// YouWin ;
15909: CALL_OW 103
// end ;
15913: PPOPN 4
15915: END
// export function CanSayRand ( side ) ; begin
15916: LD_INT 0
15918: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
15919: LD_ADDR_VAR 0 2
15923: PUSH
15924: LD_INT 52
15926: PUSH
15927: EMPTY
15928: LIST
15929: PUSH
15930: LD_INT 22
15932: PUSH
15933: LD_VAR 0 1
15937: PUSH
15938: EMPTY
15939: LIST
15940: LIST
15941: PUSH
15942: LD_INT 2
15944: PUSH
15945: LD_INT 25
15947: PUSH
15948: LD_INT 1
15950: PUSH
15951: EMPTY
15952: LIST
15953: LIST
15954: PUSH
15955: LD_INT 25
15957: PUSH
15958: LD_INT 2
15960: PUSH
15961: EMPTY
15962: LIST
15963: LIST
15964: PUSH
15965: LD_INT 25
15967: PUSH
15968: LD_INT 3
15970: PUSH
15971: EMPTY
15972: LIST
15973: LIST
15974: PUSH
15975: LD_INT 25
15977: PUSH
15978: LD_INT 4
15980: PUSH
15981: EMPTY
15982: LIST
15983: LIST
15984: PUSH
15985: EMPTY
15986: LIST
15987: LIST
15988: LIST
15989: LIST
15990: LIST
15991: PUSH
15992: EMPTY
15993: LIST
15994: LIST
15995: LIST
15996: PPUSH
15997: CALL_OW 69
16001: PUSH
16002: LD_EXP 21
16006: PUSH
16007: LD_EXP 33
16011: PUSH
16012: LD_EXP 22
16016: PUSH
16017: LD_EXP 23
16021: PUSH
16022: LD_EXP 24
16026: PUSH
16027: LD_EXP 25
16031: PUSH
16032: LD_EXP 26
16036: PUSH
16037: LD_EXP 27
16041: PUSH
16042: LD_EXP 28
16046: PUSH
16047: LD_EXP 29
16051: PUSH
16052: LD_EXP 30
16056: PUSH
16057: LD_EXP 31
16061: PUSH
16062: LD_EXP 32
16066: PUSH
16067: LD_EXP 34
16071: PUSH
16072: EMPTY
16073: LIST
16074: LIST
16075: LIST
16076: LIST
16077: LIST
16078: LIST
16079: LIST
16080: LIST
16081: LIST
16082: LIST
16083: LIST
16084: LIST
16085: LIST
16086: LIST
16087: DIFF
16088: ST_TO_ADDR
// end ;
16089: LD_VAR 0 2
16093: RET
// export function SayRand ( sex , dial ) ; begin
16094: LD_INT 0
16096: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16097: LD_ADDR_VAR 0 3
16101: PUSH
16102: LD_INT 52
16104: PUSH
16105: EMPTY
16106: LIST
16107: PUSH
16108: LD_INT 22
16110: PUSH
16111: LD_INT 1
16113: PUSH
16114: EMPTY
16115: LIST
16116: LIST
16117: PUSH
16118: LD_INT 26
16120: PUSH
16121: LD_VAR 0 1
16125: PUSH
16126: EMPTY
16127: LIST
16128: LIST
16129: PUSH
16130: LD_INT 2
16132: PUSH
16133: LD_INT 25
16135: PUSH
16136: LD_INT 1
16138: PUSH
16139: EMPTY
16140: LIST
16141: LIST
16142: PUSH
16143: LD_INT 25
16145: PUSH
16146: LD_INT 2
16148: PUSH
16149: EMPTY
16150: LIST
16151: LIST
16152: PUSH
16153: LD_INT 25
16155: PUSH
16156: LD_INT 3
16158: PUSH
16159: EMPTY
16160: LIST
16161: LIST
16162: PUSH
16163: LD_INT 25
16165: PUSH
16166: LD_INT 4
16168: PUSH
16169: EMPTY
16170: LIST
16171: LIST
16172: PUSH
16173: EMPTY
16174: LIST
16175: LIST
16176: LIST
16177: LIST
16178: LIST
16179: PUSH
16180: EMPTY
16181: LIST
16182: LIST
16183: LIST
16184: LIST
16185: PPUSH
16186: CALL_OW 69
16190: PUSH
16191: LD_EXP 21
16195: PUSH
16196: LD_EXP 33
16200: PUSH
16201: LD_EXP 22
16205: PUSH
16206: LD_EXP 23
16210: PUSH
16211: LD_EXP 24
16215: PUSH
16216: LD_EXP 25
16220: PUSH
16221: LD_EXP 26
16225: PUSH
16226: LD_EXP 27
16230: PUSH
16231: LD_EXP 28
16235: PUSH
16236: LD_EXP 29
16240: PUSH
16241: LD_EXP 30
16245: PUSH
16246: LD_EXP 31
16250: PUSH
16251: LD_EXP 32
16255: PUSH
16256: LD_EXP 34
16260: PUSH
16261: EMPTY
16262: LIST
16263: LIST
16264: LIST
16265: LIST
16266: LIST
16267: LIST
16268: LIST
16269: LIST
16270: LIST
16271: LIST
16272: LIST
16273: LIST
16274: LIST
16275: LIST
16276: DIFF
16277: ST_TO_ADDR
// if not result then
16278: LD_VAR 0 3
16282: NOT
16283: IFFALSE 16287
// exit ;
16285: GO 16315
// result := result [ 1 ] ;
16287: LD_ADDR_VAR 0 3
16291: PUSH
16292: LD_VAR 0 3
16296: PUSH
16297: LD_INT 1
16299: ARRAY
16300: ST_TO_ADDR
// Say ( result , dial ) ;
16301: LD_VAR 0 3
16305: PPUSH
16306: LD_VAR 0 2
16310: PPUSH
16311: CALL_OW 88
// end ;
16315: LD_VAR 0 3
16319: RET
// export function SayRand2 ( sex , dial , filter ) ; begin
16320: LD_INT 0
16322: PPUSH
// result := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ^ filter ;
16323: LD_ADDR_VAR 0 4
16327: PUSH
16328: LD_INT 22
16330: PUSH
16331: LD_INT 1
16333: PUSH
16334: EMPTY
16335: LIST
16336: LIST
16337: PUSH
16338: LD_INT 26
16340: PUSH
16341: LD_VAR 0 1
16345: PUSH
16346: EMPTY
16347: LIST
16348: LIST
16349: PUSH
16350: LD_INT 2
16352: PUSH
16353: LD_INT 25
16355: PUSH
16356: LD_INT 1
16358: PUSH
16359: EMPTY
16360: LIST
16361: LIST
16362: PUSH
16363: LD_INT 25
16365: PUSH
16366: LD_INT 2
16368: PUSH
16369: EMPTY
16370: LIST
16371: LIST
16372: PUSH
16373: LD_INT 25
16375: PUSH
16376: LD_INT 3
16378: PUSH
16379: EMPTY
16380: LIST
16381: LIST
16382: PUSH
16383: LD_INT 25
16385: PUSH
16386: LD_INT 4
16388: PUSH
16389: EMPTY
16390: LIST
16391: LIST
16392: PUSH
16393: EMPTY
16394: LIST
16395: LIST
16396: LIST
16397: LIST
16398: LIST
16399: PUSH
16400: EMPTY
16401: LIST
16402: LIST
16403: LIST
16404: PPUSH
16405: CALL_OW 69
16409: PUSH
16410: LD_EXP 21
16414: PUSH
16415: LD_EXP 33
16419: PUSH
16420: LD_EXP 22
16424: PUSH
16425: LD_EXP 23
16429: PUSH
16430: LD_EXP 24
16434: PUSH
16435: LD_EXP 25
16439: PUSH
16440: LD_EXP 26
16444: PUSH
16445: LD_EXP 27
16449: PUSH
16450: LD_EXP 28
16454: PUSH
16455: LD_EXP 29
16459: PUSH
16460: LD_EXP 30
16464: PUSH
16465: LD_EXP 31
16469: PUSH
16470: LD_EXP 32
16474: PUSH
16475: LD_EXP 34
16479: PUSH
16480: EMPTY
16481: LIST
16482: LIST
16483: LIST
16484: LIST
16485: LIST
16486: LIST
16487: LIST
16488: LIST
16489: LIST
16490: LIST
16491: LIST
16492: LIST
16493: LIST
16494: LIST
16495: PUSH
16496: LD_VAR 0 3
16500: ADD
16501: DIFF
16502: ST_TO_ADDR
// if not result then
16503: LD_VAR 0 4
16507: NOT
16508: IFFALSE 16512
// exit ;
16510: GO 16540
// result := result [ 1 ] ;
16512: LD_ADDR_VAR 0 4
16516: PUSH
16517: LD_VAR 0 4
16521: PUSH
16522: LD_INT 1
16524: ARRAY
16525: ST_TO_ADDR
// Say ( result , dial ) ;
16526: LD_VAR 0 4
16530: PPUSH
16531: LD_VAR 0 2
16535: PPUSH
16536: CALL_OW 88
// end ; end_of_file
16540: LD_VAR 0 4
16544: RET
// export function CustomEvent ( event ) ; begin
16545: LD_INT 0
16547: PPUSH
// end ;
16548: LD_VAR 0 2
16552: RET
// on ArtifactLoaded ( cargo , artifact ) do begin if GetSide ( cargo ) = 1 then
16553: LD_VAR 0 1
16557: PPUSH
16558: CALL_OW 255
16562: PUSH
16563: LD_INT 1
16565: EQUAL
16566: IFFALSE 16576
// artifact_get := true ;
16568: LD_ADDR_EXP 13
16572: PUSH
16573: LD_INT 1
16575: ST_TO_ADDR
// if GetSide ( cargo ) = 2 then
16576: LD_VAR 0 1
16580: PPUSH
16581: CALL_OW 255
16585: PUSH
16586: LD_INT 2
16588: EQUAL
16589: IFFALSE 16607
// begin artifact_get := false ;
16591: LD_ADDR_EXP 13
16595: PUSH
16596: LD_INT 0
16598: ST_TO_ADDR
// artifact_stolen := true ;
16599: LD_ADDR_EXP 12
16603: PUSH
16604: LD_INT 1
16606: ST_TO_ADDR
// end ; artifact_oncargo := true ;
16607: LD_ADDR_EXP 14
16611: PUSH
16612: LD_INT 1
16614: ST_TO_ADDR
// end ;
16615: PPOPN 2
16617: END
// on ArtifactUnloaded ( cargo , artifact ) do begin artifact_oncargo := false ;
16618: LD_ADDR_EXP 14
16622: PUSH
16623: LD_INT 0
16625: ST_TO_ADDR
// end ;
16626: PPOPN 2
16628: END
// on UnitDestroyed ( un ) do begin if un = JMM then
16629: LD_VAR 0 1
16633: PUSH
16634: LD_EXP 21
16638: EQUAL
16639: IFFALSE 16650
// begin YouLost ( JMM ) ;
16641: LD_STRING JMM
16643: PPUSH
16644: CALL_OW 104
// exit ;
16648: GO 16782
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) then
16650: LD_VAR 0 1
16654: PUSH
16655: LD_INT 22
16657: PUSH
16658: LD_INT 1
16660: PUSH
16661: EMPTY
16662: LIST
16663: LIST
16664: PUSH
16665: LD_INT 21
16667: PUSH
16668: LD_INT 1
16670: PUSH
16671: EMPTY
16672: LIST
16673: LIST
16674: PUSH
16675: LD_INT 2
16677: PUSH
16678: LD_INT 25
16680: PUSH
16681: LD_INT 1
16683: PUSH
16684: EMPTY
16685: LIST
16686: LIST
16687: PUSH
16688: LD_INT 25
16690: PUSH
16691: LD_INT 2
16693: PUSH
16694: EMPTY
16695: LIST
16696: LIST
16697: PUSH
16698: LD_INT 25
16700: PUSH
16701: LD_INT 3
16703: PUSH
16704: EMPTY
16705: LIST
16706: LIST
16707: PUSH
16708: LD_INT 25
16710: PUSH
16711: LD_INT 4
16713: PUSH
16714: EMPTY
16715: LIST
16716: LIST
16717: PUSH
16718: LD_INT 25
16720: PUSH
16721: LD_INT 5
16723: PUSH
16724: EMPTY
16725: LIST
16726: LIST
16727: PUSH
16728: LD_INT 25
16730: PUSH
16731: LD_INT 8
16733: PUSH
16734: EMPTY
16735: LIST
16736: LIST
16737: PUSH
16738: EMPTY
16739: LIST
16740: LIST
16741: LIST
16742: LIST
16743: LIST
16744: LIST
16745: LIST
16746: PUSH
16747: EMPTY
16748: LIST
16749: LIST
16750: LIST
16751: PPUSH
16752: CALL_OW 69
16756: IN
16757: IFFALSE 16773
// loses_counter := loses_counter + 1 ;
16759: LD_ADDR_EXP 17
16763: PUSH
16764: LD_EXP 17
16768: PUSH
16769: LD_INT 1
16771: PLUS
16772: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
16773: LD_VAR 0 1
16777: PPUSH
16778: CALL 44366 0 1
// end ;
16782: PPOPN 1
16784: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
16785: LD_VAR 0 1
16789: PPUSH
16790: LD_VAR 0 2
16794: PPUSH
16795: CALL 46700 0 2
// end ;
16799: PPOPN 2
16801: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
16802: LD_VAR 0 1
16806: PPUSH
16807: CALL 46009 0 1
// end ;
16811: PPOPN 1
16813: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
16814: LD_VAR 0 1
16818: PPUSH
16819: LD_VAR 0 2
16823: PPUSH
16824: LD_VAR 0 3
16828: PPUSH
16829: LD_VAR 0 4
16833: PPUSH
16834: LD_VAR 0 5
16838: PPUSH
16839: CALL 43682 0 5
// end ;
16843: PPOPN 5
16845: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetNation ( vehicle ) = nation_american then
16846: LD_VAR 0 1
16850: PPUSH
16851: CALL_OW 248
16855: PUSH
16856: LD_INT 1
16858: EQUAL
16859: IFFALSE 16869
// am_veh_consturcted := true ;
16861: LD_ADDR_EXP 20
16865: PUSH
16866: LD_INT 1
16868: ST_TO_ADDR
// MCE_VehicleConstructed ( vehicle , factory ) ;
16869: LD_VAR 0 1
16873: PPUSH
16874: LD_VAR 0 2
16878: PPUSH
16879: CALL 43278 0 2
// end ;
16883: PPOPN 2
16885: END
// on UnitKamikazed ( unit ) do begin if GetType ( unit ) = unit_vehicle then
16886: LD_VAR 0 1
16890: PPUSH
16891: CALL_OW 247
16895: PUSH
16896: LD_INT 2
16898: EQUAL
16899: IFFALSE 16903
// exit ;
16901: GO 16920
// if not kamikazed then
16903: LD_EXP 11
16907: NOT
16908: IFFALSE 16920
// kamikazed := unit ;
16910: LD_ADDR_EXP 11
16914: PUSH
16915: LD_VAR 0 1
16919: ST_TO_ADDR
// end ;
16920: PPOPN 1
16922: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do var i , tmp ;
16923: LD_INT 0
16925: PPUSH
16926: PPUSH
// begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
16927: LD_VAR 0 1
16931: PPUSH
16932: LD_VAR 0 2
16936: PPUSH
16937: LD_VAR 0 3
16941: PPUSH
16942: LD_VAR 0 4
16946: PPUSH
16947: CALL 43116 0 4
// end ;
16951: PPOPN 6
16953: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
16954: LD_VAR 0 1
16958: PPUSH
16959: LD_VAR 0 2
16963: PPUSH
16964: LD_VAR 0 3
16968: PPUSH
16969: CALL 42891 0 3
// end ;
16973: PPOPN 3
16975: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
16976: LD_VAR 0 1
16980: PPUSH
16981: LD_VAR 0 2
16985: PPUSH
16986: CALL 44062 0 2
// end ;
16990: PPOPN 2
16992: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
16993: LD_VAR 0 1
16997: PPUSH
16998: LD_VAR 0 2
17002: PPUSH
17003: CALL 42585 0 2
// end ;
17007: PPOPN 2
17009: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
17010: LD_VAR 0 1
17014: PPUSH
17015: LD_VAR 0 2
17019: PPUSH
17020: CALL 42776 0 2
// end ;
17024: PPOPN 2
17026: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
17027: LD_VAR 0 1
17031: PPUSH
17032: CALL 45768 0 1
// end ;
17036: PPOPN 1
17038: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
17039: LD_VAR 0 1
17043: PPUSH
17044: LD_VAR 0 2
17048: PPUSH
17049: CALL 46961 0 2
// end ;
17053: PPOPN 2
17055: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
17056: LD_VAR 0 1
17060: PPUSH
17061: LD_VAR 0 2
17065: PPUSH
17066: LD_VAR 0 3
17070: PPUSH
17071: LD_VAR 0 4
17075: PPUSH
17076: CALL 47177 0 4
// end ;
17080: PPOPN 4
17082: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
17083: LD_VAR 0 1
17087: PPUSH
17088: CALL 92896 0 1
// end ; end_of_file
17092: PPOPN 1
17094: END
// every 0 0$1 trigger game do
17095: LD_EXP 2
17099: IFFALSE 17129
17101: GO 17103
17103: DISABLE
// SpawnCrates ( [ crates_west , crates_east , crates_north_west , crates_east ] , 0 0$50 ) ;
17104: LD_INT 7
17106: PUSH
17107: LD_INT 6
17109: PUSH
17110: LD_INT 4
17112: PUSH
17113: LD_INT 6
17115: PUSH
17116: EMPTY
17117: LIST
17118: LIST
17119: LIST
17120: LIST
17121: PPUSH
17122: LD_INT 1750
17124: PPUSH
17125: CALL 17130 0 2
17129: END
// export function SpawnCrates ( areas , time ) ; var i , p ; begin
17130: LD_INT 0
17132: PPUSH
17133: PPUSH
17134: PPUSH
// if not areas then
17135: LD_VAR 0 1
17139: NOT
17140: IFFALSE 17144
// exit ;
17142: GO 17274
// repeat wait ( time ) ;
17144: LD_VAR 0 2
17148: PPUSH
17149: CALL_OW 67
// p := rand ( 1 , 90 ) ;
17153: LD_ADDR_VAR 0 5
17157: PUSH
17158: LD_INT 1
17160: PPUSH
17161: LD_INT 90
17163: PPUSH
17164: CALL_OW 12
17168: ST_TO_ADDR
// for i in areas do
17169: LD_ADDR_VAR 0 4
17173: PUSH
17174: LD_VAR 0 1
17178: PUSH
17179: FOR_IN
17180: IFFALSE 17233
// begin if Prob ( p ) then
17182: LD_VAR 0 5
17186: PPUSH
17187: CALL_OW 13
17191: IFFALSE 17231
// begin CreateCratesArea ( rand ( 1 , 5 ) , i , true ) ;
17193: LD_INT 1
17195: PPUSH
17196: LD_INT 5
17198: PPUSH
17199: CALL_OW 12
17203: PPUSH
17204: LD_VAR 0 4
17208: PPUSH
17209: LD_INT 1
17211: PPUSH
17212: CALL_OW 55
// wait ( rand ( 0 0$11 , 0 0$17 ) ) ;
17216: LD_INT 385
17218: PPUSH
17219: LD_INT 595
17221: PPUSH
17222: CALL_OW 12
17226: PPUSH
17227: CALL_OW 67
// end ; end ;
17231: GO 17179
17233: POP
17234: POP
// time := time + 0 0$3 ;
17235: LD_ADDR_VAR 0 2
17239: PUSH
17240: LD_VAR 0 2
17244: PUSH
17245: LD_INT 105
17247: PLUS
17248: ST_TO_ADDR
// if time > 7 7$00 then
17249: LD_VAR 0 2
17253: PUSH
17254: LD_INT 14700
17256: GREATER
17257: IFFALSE 17267
// time := 0 0$40 ;
17259: LD_ADDR_VAR 0 2
17263: PUSH
17264: LD_INT 1400
17266: ST_TO_ADDR
// until not game ;
17267: LD_EXP 2
17271: NOT
17272: IFFALSE 17144
// end ; end_of_file
17274: LD_VAR 0 3
17278: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
17279: LD_INT 0
17281: PPUSH
17282: PPUSH
// skirmish := false ;
17283: LD_ADDR_EXP 48
17287: PUSH
17288: LD_INT 0
17290: ST_TO_ADDR
// debug_mc := false ;
17291: LD_ADDR_EXP 49
17295: PUSH
17296: LD_INT 0
17298: ST_TO_ADDR
// mc_bases := [ ] ;
17299: LD_ADDR_EXP 50
17303: PUSH
17304: EMPTY
17305: ST_TO_ADDR
// mc_sides := [ ] ;
17306: LD_ADDR_EXP 76
17310: PUSH
17311: EMPTY
17312: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
17313: LD_ADDR_EXP 51
17317: PUSH
17318: EMPTY
17319: ST_TO_ADDR
// mc_building_repairs := [ ] ;
17320: LD_ADDR_EXP 52
17324: PUSH
17325: EMPTY
17326: ST_TO_ADDR
// mc_need_heal := [ ] ;
17327: LD_ADDR_EXP 53
17331: PUSH
17332: EMPTY
17333: ST_TO_ADDR
// mc_healers := [ ] ;
17334: LD_ADDR_EXP 54
17338: PUSH
17339: EMPTY
17340: ST_TO_ADDR
// mc_build_list := [ ] ;
17341: LD_ADDR_EXP 55
17345: PUSH
17346: EMPTY
17347: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
17348: LD_ADDR_EXP 82
17352: PUSH
17353: EMPTY
17354: ST_TO_ADDR
// mc_builders := [ ] ;
17355: LD_ADDR_EXP 56
17359: PUSH
17360: EMPTY
17361: ST_TO_ADDR
// mc_construct_list := [ ] ;
17362: LD_ADDR_EXP 57
17366: PUSH
17367: EMPTY
17368: ST_TO_ADDR
// mc_turret_list := [ ] ;
17369: LD_ADDR_EXP 58
17373: PUSH
17374: EMPTY
17375: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
17376: LD_ADDR_EXP 59
17380: PUSH
17381: EMPTY
17382: ST_TO_ADDR
// mc_miners := [ ] ;
17383: LD_ADDR_EXP 64
17387: PUSH
17388: EMPTY
17389: ST_TO_ADDR
// mc_mines := [ ] ;
17390: LD_ADDR_EXP 63
17394: PUSH
17395: EMPTY
17396: ST_TO_ADDR
// mc_minefields := [ ] ;
17397: LD_ADDR_EXP 65
17401: PUSH
17402: EMPTY
17403: ST_TO_ADDR
// mc_crates := [ ] ;
17404: LD_ADDR_EXP 66
17408: PUSH
17409: EMPTY
17410: ST_TO_ADDR
// mc_crates_collector := [ ] ;
17411: LD_ADDR_EXP 67
17415: PUSH
17416: EMPTY
17417: ST_TO_ADDR
// mc_crates_area := [ ] ;
17418: LD_ADDR_EXP 68
17422: PUSH
17423: EMPTY
17424: ST_TO_ADDR
// mc_vehicles := [ ] ;
17425: LD_ADDR_EXP 69
17429: PUSH
17430: EMPTY
17431: ST_TO_ADDR
// mc_attack := [ ] ;
17432: LD_ADDR_EXP 70
17436: PUSH
17437: EMPTY
17438: ST_TO_ADDR
// mc_produce := [ ] ;
17439: LD_ADDR_EXP 71
17443: PUSH
17444: EMPTY
17445: ST_TO_ADDR
// mc_defender := [ ] ;
17446: LD_ADDR_EXP 72
17450: PUSH
17451: EMPTY
17452: ST_TO_ADDR
// mc_parking := [ ] ;
17453: LD_ADDR_EXP 74
17457: PUSH
17458: EMPTY
17459: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
17460: LD_ADDR_EXP 60
17464: PUSH
17465: EMPTY
17466: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
17467: LD_ADDR_EXP 62
17471: PUSH
17472: EMPTY
17473: ST_TO_ADDR
// mc_scan := [ ] ;
17474: LD_ADDR_EXP 73
17478: PUSH
17479: EMPTY
17480: ST_TO_ADDR
// mc_scan_area := [ ] ;
17481: LD_ADDR_EXP 75
17485: PUSH
17486: EMPTY
17487: ST_TO_ADDR
// mc_tech := [ ] ;
17488: LD_ADDR_EXP 77
17492: PUSH
17493: EMPTY
17494: ST_TO_ADDR
// mc_class := [ ] ;
17495: LD_ADDR_EXP 91
17499: PUSH
17500: EMPTY
17501: ST_TO_ADDR
// mc_class_case_use := [ ] ;
17502: LD_ADDR_EXP 92
17506: PUSH
17507: EMPTY
17508: ST_TO_ADDR
// end ;
17509: LD_VAR 0 1
17513: RET
// export function MC_Kill ( base ) ; begin
17514: LD_INT 0
17516: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
17517: LD_ADDR_EXP 50
17521: PUSH
17522: LD_EXP 50
17526: PPUSH
17527: LD_VAR 0 1
17531: PPUSH
17532: EMPTY
17533: PPUSH
17534: CALL_OW 1
17538: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
17539: LD_ADDR_EXP 51
17543: PUSH
17544: LD_EXP 51
17548: PPUSH
17549: LD_VAR 0 1
17553: PPUSH
17554: EMPTY
17555: PPUSH
17556: CALL_OW 1
17560: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
17561: LD_ADDR_EXP 52
17565: PUSH
17566: LD_EXP 52
17570: PPUSH
17571: LD_VAR 0 1
17575: PPUSH
17576: EMPTY
17577: PPUSH
17578: CALL_OW 1
17582: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
17583: LD_ADDR_EXP 53
17587: PUSH
17588: LD_EXP 53
17592: PPUSH
17593: LD_VAR 0 1
17597: PPUSH
17598: EMPTY
17599: PPUSH
17600: CALL_OW 1
17604: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
17605: LD_ADDR_EXP 54
17609: PUSH
17610: LD_EXP 54
17614: PPUSH
17615: LD_VAR 0 1
17619: PPUSH
17620: EMPTY
17621: PPUSH
17622: CALL_OW 1
17626: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
17627: LD_ADDR_EXP 55
17631: PUSH
17632: LD_EXP 55
17636: PPUSH
17637: LD_VAR 0 1
17641: PPUSH
17642: EMPTY
17643: PPUSH
17644: CALL_OW 1
17648: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
17649: LD_ADDR_EXP 56
17653: PUSH
17654: LD_EXP 56
17658: PPUSH
17659: LD_VAR 0 1
17663: PPUSH
17664: EMPTY
17665: PPUSH
17666: CALL_OW 1
17670: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
17671: LD_ADDR_EXP 57
17675: PUSH
17676: LD_EXP 57
17680: PPUSH
17681: LD_VAR 0 1
17685: PPUSH
17686: EMPTY
17687: PPUSH
17688: CALL_OW 1
17692: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
17693: LD_ADDR_EXP 58
17697: PUSH
17698: LD_EXP 58
17702: PPUSH
17703: LD_VAR 0 1
17707: PPUSH
17708: EMPTY
17709: PPUSH
17710: CALL_OW 1
17714: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
17715: LD_ADDR_EXP 59
17719: PUSH
17720: LD_EXP 59
17724: PPUSH
17725: LD_VAR 0 1
17729: PPUSH
17730: EMPTY
17731: PPUSH
17732: CALL_OW 1
17736: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
17737: LD_ADDR_EXP 60
17741: PUSH
17742: LD_EXP 60
17746: PPUSH
17747: LD_VAR 0 1
17751: PPUSH
17752: EMPTY
17753: PPUSH
17754: CALL_OW 1
17758: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
17759: LD_ADDR_EXP 61
17763: PUSH
17764: LD_EXP 61
17768: PPUSH
17769: LD_VAR 0 1
17773: PPUSH
17774: LD_INT 0
17776: PPUSH
17777: CALL_OW 1
17781: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
17782: LD_ADDR_EXP 62
17786: PUSH
17787: LD_EXP 62
17791: PPUSH
17792: LD_VAR 0 1
17796: PPUSH
17797: EMPTY
17798: PPUSH
17799: CALL_OW 1
17803: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
17804: LD_ADDR_EXP 63
17808: PUSH
17809: LD_EXP 63
17813: PPUSH
17814: LD_VAR 0 1
17818: PPUSH
17819: EMPTY
17820: PPUSH
17821: CALL_OW 1
17825: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
17826: LD_ADDR_EXP 64
17830: PUSH
17831: LD_EXP 64
17835: PPUSH
17836: LD_VAR 0 1
17840: PPUSH
17841: EMPTY
17842: PPUSH
17843: CALL_OW 1
17847: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
17848: LD_ADDR_EXP 65
17852: PUSH
17853: LD_EXP 65
17857: PPUSH
17858: LD_VAR 0 1
17862: PPUSH
17863: EMPTY
17864: PPUSH
17865: CALL_OW 1
17869: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
17870: LD_ADDR_EXP 66
17874: PUSH
17875: LD_EXP 66
17879: PPUSH
17880: LD_VAR 0 1
17884: PPUSH
17885: EMPTY
17886: PPUSH
17887: CALL_OW 1
17891: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
17892: LD_ADDR_EXP 67
17896: PUSH
17897: LD_EXP 67
17901: PPUSH
17902: LD_VAR 0 1
17906: PPUSH
17907: EMPTY
17908: PPUSH
17909: CALL_OW 1
17913: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
17914: LD_ADDR_EXP 68
17918: PUSH
17919: LD_EXP 68
17923: PPUSH
17924: LD_VAR 0 1
17928: PPUSH
17929: EMPTY
17930: PPUSH
17931: CALL_OW 1
17935: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
17936: LD_ADDR_EXP 69
17940: PUSH
17941: LD_EXP 69
17945: PPUSH
17946: LD_VAR 0 1
17950: PPUSH
17951: EMPTY
17952: PPUSH
17953: CALL_OW 1
17957: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
17958: LD_ADDR_EXP 70
17962: PUSH
17963: LD_EXP 70
17967: PPUSH
17968: LD_VAR 0 1
17972: PPUSH
17973: EMPTY
17974: PPUSH
17975: CALL_OW 1
17979: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
17980: LD_ADDR_EXP 71
17984: PUSH
17985: LD_EXP 71
17989: PPUSH
17990: LD_VAR 0 1
17994: PPUSH
17995: EMPTY
17996: PPUSH
17997: CALL_OW 1
18001: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
18002: LD_ADDR_EXP 72
18006: PUSH
18007: LD_EXP 72
18011: PPUSH
18012: LD_VAR 0 1
18016: PPUSH
18017: EMPTY
18018: PPUSH
18019: CALL_OW 1
18023: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
18024: LD_ADDR_EXP 73
18028: PUSH
18029: LD_EXP 73
18033: PPUSH
18034: LD_VAR 0 1
18038: PPUSH
18039: EMPTY
18040: PPUSH
18041: CALL_OW 1
18045: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
18046: LD_ADDR_EXP 74
18050: PUSH
18051: LD_EXP 74
18055: PPUSH
18056: LD_VAR 0 1
18060: PPUSH
18061: EMPTY
18062: PPUSH
18063: CALL_OW 1
18067: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
18068: LD_ADDR_EXP 75
18072: PUSH
18073: LD_EXP 75
18077: PPUSH
18078: LD_VAR 0 1
18082: PPUSH
18083: EMPTY
18084: PPUSH
18085: CALL_OW 1
18089: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
18090: LD_ADDR_EXP 77
18094: PUSH
18095: LD_EXP 77
18099: PPUSH
18100: LD_VAR 0 1
18104: PPUSH
18105: EMPTY
18106: PPUSH
18107: CALL_OW 1
18111: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
18112: LD_ADDR_EXP 79
18116: PUSH
18117: LD_EXP 79
18121: PPUSH
18122: LD_VAR 0 1
18126: PPUSH
18127: EMPTY
18128: PPUSH
18129: CALL_OW 1
18133: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
18134: LD_ADDR_EXP 80
18138: PUSH
18139: LD_EXP 80
18143: PPUSH
18144: LD_VAR 0 1
18148: PPUSH
18149: EMPTY
18150: PPUSH
18151: CALL_OW 1
18155: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
18156: LD_ADDR_EXP 81
18160: PUSH
18161: LD_EXP 81
18165: PPUSH
18166: LD_VAR 0 1
18170: PPUSH
18171: EMPTY
18172: PPUSH
18173: CALL_OW 1
18177: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
18178: LD_ADDR_EXP 82
18182: PUSH
18183: LD_EXP 82
18187: PPUSH
18188: LD_VAR 0 1
18192: PPUSH
18193: EMPTY
18194: PPUSH
18195: CALL_OW 1
18199: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
18200: LD_ADDR_EXP 83
18204: PUSH
18205: LD_EXP 83
18209: PPUSH
18210: LD_VAR 0 1
18214: PPUSH
18215: EMPTY
18216: PPUSH
18217: CALL_OW 1
18221: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
18222: LD_ADDR_EXP 84
18226: PUSH
18227: LD_EXP 84
18231: PPUSH
18232: LD_VAR 0 1
18236: PPUSH
18237: EMPTY
18238: PPUSH
18239: CALL_OW 1
18243: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
18244: LD_ADDR_EXP 85
18248: PUSH
18249: LD_EXP 85
18253: PPUSH
18254: LD_VAR 0 1
18258: PPUSH
18259: EMPTY
18260: PPUSH
18261: CALL_OW 1
18265: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
18266: LD_ADDR_EXP 86
18270: PUSH
18271: LD_EXP 86
18275: PPUSH
18276: LD_VAR 0 1
18280: PPUSH
18281: EMPTY
18282: PPUSH
18283: CALL_OW 1
18287: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
18288: LD_ADDR_EXP 87
18292: PUSH
18293: LD_EXP 87
18297: PPUSH
18298: LD_VAR 0 1
18302: PPUSH
18303: EMPTY
18304: PPUSH
18305: CALL_OW 1
18309: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
18310: LD_ADDR_EXP 88
18314: PUSH
18315: LD_EXP 88
18319: PPUSH
18320: LD_VAR 0 1
18324: PPUSH
18325: EMPTY
18326: PPUSH
18327: CALL_OW 1
18331: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
18332: LD_ADDR_EXP 89
18336: PUSH
18337: LD_EXP 89
18341: PPUSH
18342: LD_VAR 0 1
18346: PPUSH
18347: EMPTY
18348: PPUSH
18349: CALL_OW 1
18353: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
18354: LD_ADDR_EXP 90
18358: PUSH
18359: LD_EXP 90
18363: PPUSH
18364: LD_VAR 0 1
18368: PPUSH
18369: EMPTY
18370: PPUSH
18371: CALL_OW 1
18375: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
18376: LD_ADDR_EXP 91
18380: PUSH
18381: LD_EXP 91
18385: PPUSH
18386: LD_VAR 0 1
18390: PPUSH
18391: EMPTY
18392: PPUSH
18393: CALL_OW 1
18397: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
18398: LD_ADDR_EXP 92
18402: PUSH
18403: LD_EXP 92
18407: PPUSH
18408: LD_VAR 0 1
18412: PPUSH
18413: LD_INT 0
18415: PPUSH
18416: CALL_OW 1
18420: ST_TO_ADDR
// end ;
18421: LD_VAR 0 2
18425: RET
// export function MC_Add ( side , units ) ; var base ; begin
18426: LD_INT 0
18428: PPUSH
18429: PPUSH
// base := mc_bases + 1 ;
18430: LD_ADDR_VAR 0 4
18434: PUSH
18435: LD_EXP 50
18439: PUSH
18440: LD_INT 1
18442: PLUS
18443: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
18444: LD_ADDR_EXP 76
18448: PUSH
18449: LD_EXP 76
18453: PPUSH
18454: LD_VAR 0 4
18458: PPUSH
18459: LD_VAR 0 1
18463: PPUSH
18464: CALL_OW 1
18468: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
18469: LD_ADDR_EXP 50
18473: PUSH
18474: LD_EXP 50
18478: PPUSH
18479: LD_VAR 0 4
18483: PPUSH
18484: LD_VAR 0 2
18488: PPUSH
18489: CALL_OW 1
18493: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
18494: LD_ADDR_EXP 51
18498: PUSH
18499: LD_EXP 51
18503: PPUSH
18504: LD_VAR 0 4
18508: PPUSH
18509: EMPTY
18510: PPUSH
18511: CALL_OW 1
18515: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
18516: LD_ADDR_EXP 52
18520: PUSH
18521: LD_EXP 52
18525: PPUSH
18526: LD_VAR 0 4
18530: PPUSH
18531: EMPTY
18532: PPUSH
18533: CALL_OW 1
18537: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
18538: LD_ADDR_EXP 53
18542: PUSH
18543: LD_EXP 53
18547: PPUSH
18548: LD_VAR 0 4
18552: PPUSH
18553: EMPTY
18554: PPUSH
18555: CALL_OW 1
18559: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
18560: LD_ADDR_EXP 54
18564: PUSH
18565: LD_EXP 54
18569: PPUSH
18570: LD_VAR 0 4
18574: PPUSH
18575: EMPTY
18576: PPUSH
18577: CALL_OW 1
18581: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
18582: LD_ADDR_EXP 55
18586: PUSH
18587: LD_EXP 55
18591: PPUSH
18592: LD_VAR 0 4
18596: PPUSH
18597: EMPTY
18598: PPUSH
18599: CALL_OW 1
18603: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
18604: LD_ADDR_EXP 56
18608: PUSH
18609: LD_EXP 56
18613: PPUSH
18614: LD_VAR 0 4
18618: PPUSH
18619: EMPTY
18620: PPUSH
18621: CALL_OW 1
18625: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
18626: LD_ADDR_EXP 57
18630: PUSH
18631: LD_EXP 57
18635: PPUSH
18636: LD_VAR 0 4
18640: PPUSH
18641: EMPTY
18642: PPUSH
18643: CALL_OW 1
18647: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
18648: LD_ADDR_EXP 58
18652: PUSH
18653: LD_EXP 58
18657: PPUSH
18658: LD_VAR 0 4
18662: PPUSH
18663: EMPTY
18664: PPUSH
18665: CALL_OW 1
18669: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
18670: LD_ADDR_EXP 59
18674: PUSH
18675: LD_EXP 59
18679: PPUSH
18680: LD_VAR 0 4
18684: PPUSH
18685: EMPTY
18686: PPUSH
18687: CALL_OW 1
18691: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
18692: LD_ADDR_EXP 60
18696: PUSH
18697: LD_EXP 60
18701: PPUSH
18702: LD_VAR 0 4
18706: PPUSH
18707: EMPTY
18708: PPUSH
18709: CALL_OW 1
18713: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
18714: LD_ADDR_EXP 61
18718: PUSH
18719: LD_EXP 61
18723: PPUSH
18724: LD_VAR 0 4
18728: PPUSH
18729: LD_INT 0
18731: PPUSH
18732: CALL_OW 1
18736: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
18737: LD_ADDR_EXP 62
18741: PUSH
18742: LD_EXP 62
18746: PPUSH
18747: LD_VAR 0 4
18751: PPUSH
18752: EMPTY
18753: PPUSH
18754: CALL_OW 1
18758: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
18759: LD_ADDR_EXP 63
18763: PUSH
18764: LD_EXP 63
18768: PPUSH
18769: LD_VAR 0 4
18773: PPUSH
18774: EMPTY
18775: PPUSH
18776: CALL_OW 1
18780: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
18781: LD_ADDR_EXP 64
18785: PUSH
18786: LD_EXP 64
18790: PPUSH
18791: LD_VAR 0 4
18795: PPUSH
18796: EMPTY
18797: PPUSH
18798: CALL_OW 1
18802: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
18803: LD_ADDR_EXP 65
18807: PUSH
18808: LD_EXP 65
18812: PPUSH
18813: LD_VAR 0 4
18817: PPUSH
18818: EMPTY
18819: PPUSH
18820: CALL_OW 1
18824: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
18825: LD_ADDR_EXP 66
18829: PUSH
18830: LD_EXP 66
18834: PPUSH
18835: LD_VAR 0 4
18839: PPUSH
18840: EMPTY
18841: PPUSH
18842: CALL_OW 1
18846: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
18847: LD_ADDR_EXP 67
18851: PUSH
18852: LD_EXP 67
18856: PPUSH
18857: LD_VAR 0 4
18861: PPUSH
18862: EMPTY
18863: PPUSH
18864: CALL_OW 1
18868: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
18869: LD_ADDR_EXP 68
18873: PUSH
18874: LD_EXP 68
18878: PPUSH
18879: LD_VAR 0 4
18883: PPUSH
18884: EMPTY
18885: PPUSH
18886: CALL_OW 1
18890: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
18891: LD_ADDR_EXP 69
18895: PUSH
18896: LD_EXP 69
18900: PPUSH
18901: LD_VAR 0 4
18905: PPUSH
18906: EMPTY
18907: PPUSH
18908: CALL_OW 1
18912: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
18913: LD_ADDR_EXP 70
18917: PUSH
18918: LD_EXP 70
18922: PPUSH
18923: LD_VAR 0 4
18927: PPUSH
18928: EMPTY
18929: PPUSH
18930: CALL_OW 1
18934: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
18935: LD_ADDR_EXP 71
18939: PUSH
18940: LD_EXP 71
18944: PPUSH
18945: LD_VAR 0 4
18949: PPUSH
18950: EMPTY
18951: PPUSH
18952: CALL_OW 1
18956: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
18957: LD_ADDR_EXP 72
18961: PUSH
18962: LD_EXP 72
18966: PPUSH
18967: LD_VAR 0 4
18971: PPUSH
18972: EMPTY
18973: PPUSH
18974: CALL_OW 1
18978: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
18979: LD_ADDR_EXP 73
18983: PUSH
18984: LD_EXP 73
18988: PPUSH
18989: LD_VAR 0 4
18993: PPUSH
18994: EMPTY
18995: PPUSH
18996: CALL_OW 1
19000: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
19001: LD_ADDR_EXP 74
19005: PUSH
19006: LD_EXP 74
19010: PPUSH
19011: LD_VAR 0 4
19015: PPUSH
19016: EMPTY
19017: PPUSH
19018: CALL_OW 1
19022: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
19023: LD_ADDR_EXP 75
19027: PUSH
19028: LD_EXP 75
19032: PPUSH
19033: LD_VAR 0 4
19037: PPUSH
19038: EMPTY
19039: PPUSH
19040: CALL_OW 1
19044: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
19045: LD_ADDR_EXP 77
19049: PUSH
19050: LD_EXP 77
19054: PPUSH
19055: LD_VAR 0 4
19059: PPUSH
19060: EMPTY
19061: PPUSH
19062: CALL_OW 1
19066: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
19067: LD_ADDR_EXP 79
19071: PUSH
19072: LD_EXP 79
19076: PPUSH
19077: LD_VAR 0 4
19081: PPUSH
19082: EMPTY
19083: PPUSH
19084: CALL_OW 1
19088: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
19089: LD_ADDR_EXP 80
19093: PUSH
19094: LD_EXP 80
19098: PPUSH
19099: LD_VAR 0 4
19103: PPUSH
19104: EMPTY
19105: PPUSH
19106: CALL_OW 1
19110: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
19111: LD_ADDR_EXP 81
19115: PUSH
19116: LD_EXP 81
19120: PPUSH
19121: LD_VAR 0 4
19125: PPUSH
19126: EMPTY
19127: PPUSH
19128: CALL_OW 1
19132: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
19133: LD_ADDR_EXP 82
19137: PUSH
19138: LD_EXP 82
19142: PPUSH
19143: LD_VAR 0 4
19147: PPUSH
19148: EMPTY
19149: PPUSH
19150: CALL_OW 1
19154: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
19155: LD_ADDR_EXP 83
19159: PUSH
19160: LD_EXP 83
19164: PPUSH
19165: LD_VAR 0 4
19169: PPUSH
19170: EMPTY
19171: PPUSH
19172: CALL_OW 1
19176: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
19177: LD_ADDR_EXP 84
19181: PUSH
19182: LD_EXP 84
19186: PPUSH
19187: LD_VAR 0 4
19191: PPUSH
19192: EMPTY
19193: PPUSH
19194: CALL_OW 1
19198: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
19199: LD_ADDR_EXP 85
19203: PUSH
19204: LD_EXP 85
19208: PPUSH
19209: LD_VAR 0 4
19213: PPUSH
19214: EMPTY
19215: PPUSH
19216: CALL_OW 1
19220: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
19221: LD_ADDR_EXP 86
19225: PUSH
19226: LD_EXP 86
19230: PPUSH
19231: LD_VAR 0 4
19235: PPUSH
19236: EMPTY
19237: PPUSH
19238: CALL_OW 1
19242: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
19243: LD_ADDR_EXP 87
19247: PUSH
19248: LD_EXP 87
19252: PPUSH
19253: LD_VAR 0 4
19257: PPUSH
19258: EMPTY
19259: PPUSH
19260: CALL_OW 1
19264: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
19265: LD_ADDR_EXP 88
19269: PUSH
19270: LD_EXP 88
19274: PPUSH
19275: LD_VAR 0 4
19279: PPUSH
19280: EMPTY
19281: PPUSH
19282: CALL_OW 1
19286: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
19287: LD_ADDR_EXP 89
19291: PUSH
19292: LD_EXP 89
19296: PPUSH
19297: LD_VAR 0 4
19301: PPUSH
19302: EMPTY
19303: PPUSH
19304: CALL_OW 1
19308: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
19309: LD_ADDR_EXP 90
19313: PUSH
19314: LD_EXP 90
19318: PPUSH
19319: LD_VAR 0 4
19323: PPUSH
19324: EMPTY
19325: PPUSH
19326: CALL_OW 1
19330: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
19331: LD_ADDR_EXP 91
19335: PUSH
19336: LD_EXP 91
19340: PPUSH
19341: LD_VAR 0 4
19345: PPUSH
19346: EMPTY
19347: PPUSH
19348: CALL_OW 1
19352: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
19353: LD_ADDR_EXP 92
19357: PUSH
19358: LD_EXP 92
19362: PPUSH
19363: LD_VAR 0 4
19367: PPUSH
19368: LD_INT 0
19370: PPUSH
19371: CALL_OW 1
19375: ST_TO_ADDR
// result := base ;
19376: LD_ADDR_VAR 0 3
19380: PUSH
19381: LD_VAR 0 4
19385: ST_TO_ADDR
// end ;
19386: LD_VAR 0 3
19390: RET
// export function MC_Start ( ) ; var i ; begin
19391: LD_INT 0
19393: PPUSH
19394: PPUSH
// for i = 1 to mc_bases do
19395: LD_ADDR_VAR 0 2
19399: PUSH
19400: DOUBLE
19401: LD_INT 1
19403: DEC
19404: ST_TO_ADDR
19405: LD_EXP 50
19409: PUSH
19410: FOR_TO
19411: IFFALSE 20488
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
19413: LD_ADDR_EXP 50
19417: PUSH
19418: LD_EXP 50
19422: PPUSH
19423: LD_VAR 0 2
19427: PPUSH
19428: LD_EXP 50
19432: PUSH
19433: LD_VAR 0 2
19437: ARRAY
19438: PUSH
19439: LD_INT 0
19441: DIFF
19442: PPUSH
19443: CALL_OW 1
19447: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
19448: LD_ADDR_EXP 51
19452: PUSH
19453: LD_EXP 51
19457: PPUSH
19458: LD_VAR 0 2
19462: PPUSH
19463: EMPTY
19464: PPUSH
19465: CALL_OW 1
19469: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
19470: LD_ADDR_EXP 52
19474: PUSH
19475: LD_EXP 52
19479: PPUSH
19480: LD_VAR 0 2
19484: PPUSH
19485: EMPTY
19486: PPUSH
19487: CALL_OW 1
19491: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
19492: LD_ADDR_EXP 53
19496: PUSH
19497: LD_EXP 53
19501: PPUSH
19502: LD_VAR 0 2
19506: PPUSH
19507: EMPTY
19508: PPUSH
19509: CALL_OW 1
19513: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
19514: LD_ADDR_EXP 54
19518: PUSH
19519: LD_EXP 54
19523: PPUSH
19524: LD_VAR 0 2
19528: PPUSH
19529: EMPTY
19530: PUSH
19531: EMPTY
19532: PUSH
19533: EMPTY
19534: LIST
19535: LIST
19536: PPUSH
19537: CALL_OW 1
19541: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
19542: LD_ADDR_EXP 55
19546: PUSH
19547: LD_EXP 55
19551: PPUSH
19552: LD_VAR 0 2
19556: PPUSH
19557: EMPTY
19558: PPUSH
19559: CALL_OW 1
19563: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
19564: LD_ADDR_EXP 82
19568: PUSH
19569: LD_EXP 82
19573: PPUSH
19574: LD_VAR 0 2
19578: PPUSH
19579: EMPTY
19580: PPUSH
19581: CALL_OW 1
19585: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
19586: LD_ADDR_EXP 56
19590: PUSH
19591: LD_EXP 56
19595: PPUSH
19596: LD_VAR 0 2
19600: PPUSH
19601: EMPTY
19602: PPUSH
19603: CALL_OW 1
19607: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
19608: LD_ADDR_EXP 57
19612: PUSH
19613: LD_EXP 57
19617: PPUSH
19618: LD_VAR 0 2
19622: PPUSH
19623: EMPTY
19624: PPUSH
19625: CALL_OW 1
19629: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
19630: LD_ADDR_EXP 58
19634: PUSH
19635: LD_EXP 58
19639: PPUSH
19640: LD_VAR 0 2
19644: PPUSH
19645: LD_EXP 50
19649: PUSH
19650: LD_VAR 0 2
19654: ARRAY
19655: PPUSH
19656: LD_INT 2
19658: PUSH
19659: LD_INT 30
19661: PUSH
19662: LD_INT 32
19664: PUSH
19665: EMPTY
19666: LIST
19667: LIST
19668: PUSH
19669: LD_INT 30
19671: PUSH
19672: LD_INT 33
19674: PUSH
19675: EMPTY
19676: LIST
19677: LIST
19678: PUSH
19679: EMPTY
19680: LIST
19681: LIST
19682: LIST
19683: PPUSH
19684: CALL_OW 72
19688: PPUSH
19689: CALL_OW 1
19693: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
19694: LD_ADDR_EXP 59
19698: PUSH
19699: LD_EXP 59
19703: PPUSH
19704: LD_VAR 0 2
19708: PPUSH
19709: LD_EXP 50
19713: PUSH
19714: LD_VAR 0 2
19718: ARRAY
19719: PPUSH
19720: LD_INT 2
19722: PUSH
19723: LD_INT 30
19725: PUSH
19726: LD_INT 32
19728: PUSH
19729: EMPTY
19730: LIST
19731: LIST
19732: PUSH
19733: LD_INT 30
19735: PUSH
19736: LD_INT 31
19738: PUSH
19739: EMPTY
19740: LIST
19741: LIST
19742: PUSH
19743: EMPTY
19744: LIST
19745: LIST
19746: LIST
19747: PUSH
19748: LD_INT 58
19750: PUSH
19751: EMPTY
19752: LIST
19753: PUSH
19754: EMPTY
19755: LIST
19756: LIST
19757: PPUSH
19758: CALL_OW 72
19762: PPUSH
19763: CALL_OW 1
19767: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
19768: LD_ADDR_EXP 60
19772: PUSH
19773: LD_EXP 60
19777: PPUSH
19778: LD_VAR 0 2
19782: PPUSH
19783: EMPTY
19784: PPUSH
19785: CALL_OW 1
19789: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
19790: LD_ADDR_EXP 64
19794: PUSH
19795: LD_EXP 64
19799: PPUSH
19800: LD_VAR 0 2
19804: PPUSH
19805: EMPTY
19806: PPUSH
19807: CALL_OW 1
19811: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
19812: LD_ADDR_EXP 63
19816: PUSH
19817: LD_EXP 63
19821: PPUSH
19822: LD_VAR 0 2
19826: PPUSH
19827: EMPTY
19828: PPUSH
19829: CALL_OW 1
19833: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
19834: LD_ADDR_EXP 65
19838: PUSH
19839: LD_EXP 65
19843: PPUSH
19844: LD_VAR 0 2
19848: PPUSH
19849: EMPTY
19850: PPUSH
19851: CALL_OW 1
19855: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
19856: LD_ADDR_EXP 66
19860: PUSH
19861: LD_EXP 66
19865: PPUSH
19866: LD_VAR 0 2
19870: PPUSH
19871: EMPTY
19872: PPUSH
19873: CALL_OW 1
19877: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
19878: LD_ADDR_EXP 67
19882: PUSH
19883: LD_EXP 67
19887: PPUSH
19888: LD_VAR 0 2
19892: PPUSH
19893: EMPTY
19894: PPUSH
19895: CALL_OW 1
19899: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
19900: LD_ADDR_EXP 68
19904: PUSH
19905: LD_EXP 68
19909: PPUSH
19910: LD_VAR 0 2
19914: PPUSH
19915: EMPTY
19916: PPUSH
19917: CALL_OW 1
19921: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
19922: LD_ADDR_EXP 69
19926: PUSH
19927: LD_EXP 69
19931: PPUSH
19932: LD_VAR 0 2
19936: PPUSH
19937: EMPTY
19938: PPUSH
19939: CALL_OW 1
19943: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
19944: LD_ADDR_EXP 70
19948: PUSH
19949: LD_EXP 70
19953: PPUSH
19954: LD_VAR 0 2
19958: PPUSH
19959: EMPTY
19960: PPUSH
19961: CALL_OW 1
19965: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
19966: LD_ADDR_EXP 71
19970: PUSH
19971: LD_EXP 71
19975: PPUSH
19976: LD_VAR 0 2
19980: PPUSH
19981: EMPTY
19982: PPUSH
19983: CALL_OW 1
19987: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
19988: LD_ADDR_EXP 72
19992: PUSH
19993: LD_EXP 72
19997: PPUSH
19998: LD_VAR 0 2
20002: PPUSH
20003: EMPTY
20004: PPUSH
20005: CALL_OW 1
20009: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
20010: LD_ADDR_EXP 61
20014: PUSH
20015: LD_EXP 61
20019: PPUSH
20020: LD_VAR 0 2
20024: PPUSH
20025: LD_INT 0
20027: PPUSH
20028: CALL_OW 1
20032: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
20033: LD_ADDR_EXP 74
20037: PUSH
20038: LD_EXP 74
20042: PPUSH
20043: LD_VAR 0 2
20047: PPUSH
20048: LD_INT 0
20050: PPUSH
20051: CALL_OW 1
20055: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
20056: LD_ADDR_EXP 62
20060: PUSH
20061: LD_EXP 62
20065: PPUSH
20066: LD_VAR 0 2
20070: PPUSH
20071: EMPTY
20072: PPUSH
20073: CALL_OW 1
20077: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
20078: LD_ADDR_EXP 73
20082: PUSH
20083: LD_EXP 73
20087: PPUSH
20088: LD_VAR 0 2
20092: PPUSH
20093: LD_INT 0
20095: PPUSH
20096: CALL_OW 1
20100: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
20101: LD_ADDR_EXP 75
20105: PUSH
20106: LD_EXP 75
20110: PPUSH
20111: LD_VAR 0 2
20115: PPUSH
20116: EMPTY
20117: PPUSH
20118: CALL_OW 1
20122: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
20123: LD_ADDR_EXP 78
20127: PUSH
20128: LD_EXP 78
20132: PPUSH
20133: LD_VAR 0 2
20137: PPUSH
20138: LD_INT 0
20140: PPUSH
20141: CALL_OW 1
20145: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
20146: LD_ADDR_EXP 79
20150: PUSH
20151: LD_EXP 79
20155: PPUSH
20156: LD_VAR 0 2
20160: PPUSH
20161: EMPTY
20162: PPUSH
20163: CALL_OW 1
20167: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
20168: LD_ADDR_EXP 80
20172: PUSH
20173: LD_EXP 80
20177: PPUSH
20178: LD_VAR 0 2
20182: PPUSH
20183: EMPTY
20184: PPUSH
20185: CALL_OW 1
20189: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
20190: LD_ADDR_EXP 81
20194: PUSH
20195: LD_EXP 81
20199: PPUSH
20200: LD_VAR 0 2
20204: PPUSH
20205: EMPTY
20206: PPUSH
20207: CALL_OW 1
20211: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
20212: LD_ADDR_EXP 83
20216: PUSH
20217: LD_EXP 83
20221: PPUSH
20222: LD_VAR 0 2
20226: PPUSH
20227: LD_EXP 50
20231: PUSH
20232: LD_VAR 0 2
20236: ARRAY
20237: PPUSH
20238: LD_INT 2
20240: PUSH
20241: LD_INT 30
20243: PUSH
20244: LD_INT 6
20246: PUSH
20247: EMPTY
20248: LIST
20249: LIST
20250: PUSH
20251: LD_INT 30
20253: PUSH
20254: LD_INT 7
20256: PUSH
20257: EMPTY
20258: LIST
20259: LIST
20260: PUSH
20261: LD_INT 30
20263: PUSH
20264: LD_INT 8
20266: PUSH
20267: EMPTY
20268: LIST
20269: LIST
20270: PUSH
20271: EMPTY
20272: LIST
20273: LIST
20274: LIST
20275: LIST
20276: PPUSH
20277: CALL_OW 72
20281: PPUSH
20282: CALL_OW 1
20286: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
20287: LD_ADDR_EXP 84
20291: PUSH
20292: LD_EXP 84
20296: PPUSH
20297: LD_VAR 0 2
20301: PPUSH
20302: EMPTY
20303: PPUSH
20304: CALL_OW 1
20308: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
20309: LD_ADDR_EXP 85
20313: PUSH
20314: LD_EXP 85
20318: PPUSH
20319: LD_VAR 0 2
20323: PPUSH
20324: EMPTY
20325: PPUSH
20326: CALL_OW 1
20330: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
20331: LD_ADDR_EXP 86
20335: PUSH
20336: LD_EXP 86
20340: PPUSH
20341: LD_VAR 0 2
20345: PPUSH
20346: EMPTY
20347: PPUSH
20348: CALL_OW 1
20352: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
20353: LD_ADDR_EXP 87
20357: PUSH
20358: LD_EXP 87
20362: PPUSH
20363: LD_VAR 0 2
20367: PPUSH
20368: EMPTY
20369: PPUSH
20370: CALL_OW 1
20374: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
20375: LD_ADDR_EXP 88
20379: PUSH
20380: LD_EXP 88
20384: PPUSH
20385: LD_VAR 0 2
20389: PPUSH
20390: EMPTY
20391: PPUSH
20392: CALL_OW 1
20396: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
20397: LD_ADDR_EXP 89
20401: PUSH
20402: LD_EXP 89
20406: PPUSH
20407: LD_VAR 0 2
20411: PPUSH
20412: EMPTY
20413: PPUSH
20414: CALL_OW 1
20418: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
20419: LD_ADDR_EXP 90
20423: PUSH
20424: LD_EXP 90
20428: PPUSH
20429: LD_VAR 0 2
20433: PPUSH
20434: EMPTY
20435: PPUSH
20436: CALL_OW 1
20440: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
20441: LD_ADDR_EXP 91
20445: PUSH
20446: LD_EXP 91
20450: PPUSH
20451: LD_VAR 0 2
20455: PPUSH
20456: EMPTY
20457: PPUSH
20458: CALL_OW 1
20462: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
20463: LD_ADDR_EXP 92
20467: PUSH
20468: LD_EXP 92
20472: PPUSH
20473: LD_VAR 0 2
20477: PPUSH
20478: LD_INT 0
20480: PPUSH
20481: CALL_OW 1
20485: ST_TO_ADDR
// end ;
20486: GO 19410
20488: POP
20489: POP
// MC_InitSides ( ) ;
20490: CALL 20776 0 0
// MC_InitResearch ( ) ;
20494: CALL 20515 0 0
// CustomInitMacro ( ) ;
20498: CALL 300 0 0
// skirmish := true ;
20502: LD_ADDR_EXP 48
20506: PUSH
20507: LD_INT 1
20509: ST_TO_ADDR
// end ;
20510: LD_VAR 0 1
20514: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
20515: LD_INT 0
20517: PPUSH
20518: PPUSH
20519: PPUSH
20520: PPUSH
20521: PPUSH
20522: PPUSH
// if not mc_bases then
20523: LD_EXP 50
20527: NOT
20528: IFFALSE 20532
// exit ;
20530: GO 20771
// for i = 1 to 8 do
20532: LD_ADDR_VAR 0 2
20536: PUSH
20537: DOUBLE
20538: LD_INT 1
20540: DEC
20541: ST_TO_ADDR
20542: LD_INT 8
20544: PUSH
20545: FOR_TO
20546: IFFALSE 20572
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
20548: LD_ADDR_EXP 77
20552: PUSH
20553: LD_EXP 77
20557: PPUSH
20558: LD_VAR 0 2
20562: PPUSH
20563: EMPTY
20564: PPUSH
20565: CALL_OW 1
20569: ST_TO_ADDR
20570: GO 20545
20572: POP
20573: POP
// tmp := [ ] ;
20574: LD_ADDR_VAR 0 5
20578: PUSH
20579: EMPTY
20580: ST_TO_ADDR
// for i = 1 to mc_sides do
20581: LD_ADDR_VAR 0 2
20585: PUSH
20586: DOUBLE
20587: LD_INT 1
20589: DEC
20590: ST_TO_ADDR
20591: LD_EXP 76
20595: PUSH
20596: FOR_TO
20597: IFFALSE 20655
// if not mc_sides [ i ] in tmp then
20599: LD_EXP 76
20603: PUSH
20604: LD_VAR 0 2
20608: ARRAY
20609: PUSH
20610: LD_VAR 0 5
20614: IN
20615: NOT
20616: IFFALSE 20653
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
20618: LD_ADDR_VAR 0 5
20622: PUSH
20623: LD_VAR 0 5
20627: PPUSH
20628: LD_VAR 0 5
20632: PUSH
20633: LD_INT 1
20635: PLUS
20636: PPUSH
20637: LD_EXP 76
20641: PUSH
20642: LD_VAR 0 2
20646: ARRAY
20647: PPUSH
20648: CALL_OW 2
20652: ST_TO_ADDR
20653: GO 20596
20655: POP
20656: POP
// if not tmp then
20657: LD_VAR 0 5
20661: NOT
20662: IFFALSE 20666
// exit ;
20664: GO 20771
// for j in tmp do
20666: LD_ADDR_VAR 0 3
20670: PUSH
20671: LD_VAR 0 5
20675: PUSH
20676: FOR_IN
20677: IFFALSE 20769
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
20679: LD_ADDR_VAR 0 6
20683: PUSH
20684: LD_INT 22
20686: PUSH
20687: LD_VAR 0 3
20691: PUSH
20692: EMPTY
20693: LIST
20694: LIST
20695: PPUSH
20696: CALL_OW 69
20700: ST_TO_ADDR
// if not un then
20701: LD_VAR 0 6
20705: NOT
20706: IFFALSE 20710
// continue ;
20708: GO 20676
// nation := GetNation ( un [ 1 ] ) ;
20710: LD_ADDR_VAR 0 4
20714: PUSH
20715: LD_VAR 0 6
20719: PUSH
20720: LD_INT 1
20722: ARRAY
20723: PPUSH
20724: CALL_OW 248
20728: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
20729: LD_ADDR_EXP 77
20733: PUSH
20734: LD_EXP 77
20738: PPUSH
20739: LD_VAR 0 3
20743: PPUSH
20744: LD_VAR 0 3
20748: PPUSH
20749: LD_VAR 0 4
20753: PPUSH
20754: LD_INT 1
20756: PPUSH
20757: CALL 47381 0 3
20761: PPUSH
20762: CALL_OW 1
20766: ST_TO_ADDR
// end ;
20767: GO 20676
20769: POP
20770: POP
// end ;
20771: LD_VAR 0 1
20775: RET
// export function MC_InitSides ( ) ; var i ; begin
20776: LD_INT 0
20778: PPUSH
20779: PPUSH
// if not mc_bases then
20780: LD_EXP 50
20784: NOT
20785: IFFALSE 20789
// exit ;
20787: GO 20863
// for i = 1 to mc_bases do
20789: LD_ADDR_VAR 0 2
20793: PUSH
20794: DOUBLE
20795: LD_INT 1
20797: DEC
20798: ST_TO_ADDR
20799: LD_EXP 50
20803: PUSH
20804: FOR_TO
20805: IFFALSE 20861
// if mc_bases [ i ] then
20807: LD_EXP 50
20811: PUSH
20812: LD_VAR 0 2
20816: ARRAY
20817: IFFALSE 20859
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
20819: LD_ADDR_EXP 76
20823: PUSH
20824: LD_EXP 76
20828: PPUSH
20829: LD_VAR 0 2
20833: PPUSH
20834: LD_EXP 50
20838: PUSH
20839: LD_VAR 0 2
20843: ARRAY
20844: PUSH
20845: LD_INT 1
20847: ARRAY
20848: PPUSH
20849: CALL_OW 255
20853: PPUSH
20854: CALL_OW 1
20858: ST_TO_ADDR
20859: GO 20804
20861: POP
20862: POP
// end ;
20863: LD_VAR 0 1
20867: RET
// every 0 0$01 trigger skirmish do
20868: LD_EXP 48
20872: IFFALSE 21026
20874: GO 20876
20876: DISABLE
// begin enable ;
20877: ENABLE
// MC_CheckBuildings ( ) ;
20878: CALL 25524 0 0
// MC_CheckPeopleLife ( ) ;
20882: CALL 25649 0 0
// RaiseSailEvent ( 100 ) ;
20886: LD_INT 100
20888: PPUSH
20889: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
20893: LD_INT 103
20895: PPUSH
20896: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
20900: LD_INT 104
20902: PPUSH
20903: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
20907: LD_INT 105
20909: PPUSH
20910: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
20914: LD_INT 106
20916: PPUSH
20917: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
20921: LD_INT 107
20923: PPUSH
20924: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
20928: LD_INT 108
20930: PPUSH
20931: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
20935: LD_INT 109
20937: PPUSH
20938: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
20942: LD_INT 110
20944: PPUSH
20945: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
20949: LD_INT 111
20951: PPUSH
20952: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
20956: LD_INT 112
20958: PPUSH
20959: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
20963: LD_INT 113
20965: PPUSH
20966: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
20970: LD_INT 120
20972: PPUSH
20973: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
20977: LD_INT 121
20979: PPUSH
20980: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
20984: LD_INT 122
20986: PPUSH
20987: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
20991: LD_INT 123
20993: PPUSH
20994: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
20998: LD_INT 124
21000: PPUSH
21001: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
21005: LD_INT 125
21007: PPUSH
21008: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
21012: LD_INT 126
21014: PPUSH
21015: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
21019: LD_INT 200
21021: PPUSH
21022: CALL_OW 427
// end ;
21026: END
// on SailEvent ( event ) do begin if event < 100 then
21027: LD_VAR 0 1
21031: PUSH
21032: LD_INT 100
21034: LESS
21035: IFFALSE 21046
// CustomEvent ( event ) ;
21037: LD_VAR 0 1
21041: PPUSH
21042: CALL 16545 0 1
// if event = 100 then
21046: LD_VAR 0 1
21050: PUSH
21051: LD_INT 100
21053: EQUAL
21054: IFFALSE 21060
// MC_ClassManager ( ) ;
21056: CALL 21452 0 0
// if event = 101 then
21060: LD_VAR 0 1
21064: PUSH
21065: LD_INT 101
21067: EQUAL
21068: IFFALSE 21074
// MC_RepairBuildings ( ) ;
21070: CALL 26245 0 0
// if event = 102 then
21074: LD_VAR 0 1
21078: PUSH
21079: LD_INT 102
21081: EQUAL
21082: IFFALSE 21088
// MC_Heal ( ) ;
21084: CALL 27109 0 0
// if event = 103 then
21088: LD_VAR 0 1
21092: PUSH
21093: LD_INT 103
21095: EQUAL
21096: IFFALSE 21102
// MC_Build ( ) ;
21098: CALL 27531 0 0
// if event = 104 then
21102: LD_VAR 0 1
21106: PUSH
21107: LD_INT 104
21109: EQUAL
21110: IFFALSE 21116
// MC_TurretWeapon ( ) ;
21112: CALL 29144 0 0
// if event = 105 then
21116: LD_VAR 0 1
21120: PUSH
21121: LD_INT 105
21123: EQUAL
21124: IFFALSE 21130
// MC_BuildUpgrade ( ) ;
21126: CALL 28695 0 0
// if event = 106 then
21130: LD_VAR 0 1
21134: PUSH
21135: LD_INT 106
21137: EQUAL
21138: IFFALSE 21144
// MC_PlantMines ( ) ;
21140: CALL 29574 0 0
// if event = 107 then
21144: LD_VAR 0 1
21148: PUSH
21149: LD_INT 107
21151: EQUAL
21152: IFFALSE 21158
// MC_CollectCrates ( ) ;
21154: CALL 30372 0 0
// if event = 108 then
21158: LD_VAR 0 1
21162: PUSH
21163: LD_INT 108
21165: EQUAL
21166: IFFALSE 21172
// MC_LinkRemoteControl ( ) ;
21168: CALL 32148 0 0
// if event = 109 then
21172: LD_VAR 0 1
21176: PUSH
21177: LD_INT 109
21179: EQUAL
21180: IFFALSE 21186
// MC_ProduceVehicle ( ) ;
21182: CALL 32329 0 0
// if event = 110 then
21186: LD_VAR 0 1
21190: PUSH
21191: LD_INT 110
21193: EQUAL
21194: IFFALSE 21200
// MC_SendAttack ( ) ;
21196: CALL 32795 0 0
// if event = 111 then
21200: LD_VAR 0 1
21204: PUSH
21205: LD_INT 111
21207: EQUAL
21208: IFFALSE 21214
// MC_Defend ( ) ;
21210: CALL 32903 0 0
// if event = 112 then
21214: LD_VAR 0 1
21218: PUSH
21219: LD_INT 112
21221: EQUAL
21222: IFFALSE 21228
// MC_Research ( ) ;
21224: CALL 33508 0 0
// if event = 113 then
21228: LD_VAR 0 1
21232: PUSH
21233: LD_INT 113
21235: EQUAL
21236: IFFALSE 21242
// MC_MinesTrigger ( ) ;
21238: CALL 34622 0 0
// if event = 120 then
21242: LD_VAR 0 1
21246: PUSH
21247: LD_INT 120
21249: EQUAL
21250: IFFALSE 21256
// MC_RepairVehicle ( ) ;
21252: CALL 34721 0 0
// if event = 121 then
21256: LD_VAR 0 1
21260: PUSH
21261: LD_INT 121
21263: EQUAL
21264: IFFALSE 21270
// MC_TameApe ( ) ;
21266: CALL 35451 0 0
// if event = 122 then
21270: LD_VAR 0 1
21274: PUSH
21275: LD_INT 122
21277: EQUAL
21278: IFFALSE 21284
// MC_ChangeApeClass ( ) ;
21280: CALL 36280 0 0
// if event = 123 then
21284: LD_VAR 0 1
21288: PUSH
21289: LD_INT 123
21291: EQUAL
21292: IFFALSE 21298
// MC_Bazooka ( ) ;
21294: CALL 36930 0 0
// if event = 124 then
21298: LD_VAR 0 1
21302: PUSH
21303: LD_INT 124
21305: EQUAL
21306: IFFALSE 21312
// MC_TeleportExit ( ) ;
21308: CALL 37128 0 0
// if event = 125 then
21312: LD_VAR 0 1
21316: PUSH
21317: LD_INT 125
21319: EQUAL
21320: IFFALSE 21326
// MC_Deposits ( ) ;
21322: CALL 37775 0 0
// if event = 126 then
21326: LD_VAR 0 1
21330: PUSH
21331: LD_INT 126
21333: EQUAL
21334: IFFALSE 21340
// MC_RemoteDriver ( ) ;
21336: CALL 38400 0 0
// if event = 200 then
21340: LD_VAR 0 1
21344: PUSH
21345: LD_INT 200
21347: EQUAL
21348: IFFALSE 21354
// MC_Idle ( ) ;
21350: CALL 40349 0 0
// end ;
21354: PPOPN 1
21356: END
// export function MC_Reset ( base , tag ) ; var i ; begin
21357: LD_INT 0
21359: PPUSH
21360: PPUSH
// if not mc_bases [ base ] or not tag then
21361: LD_EXP 50
21365: PUSH
21366: LD_VAR 0 1
21370: ARRAY
21371: NOT
21372: PUSH
21373: LD_VAR 0 2
21377: NOT
21378: OR
21379: IFFALSE 21383
// exit ;
21381: GO 21447
// for i in mc_bases [ base ] union mc_ape [ base ] do
21383: LD_ADDR_VAR 0 4
21387: PUSH
21388: LD_EXP 50
21392: PUSH
21393: LD_VAR 0 1
21397: ARRAY
21398: PUSH
21399: LD_EXP 79
21403: PUSH
21404: LD_VAR 0 1
21408: ARRAY
21409: UNION
21410: PUSH
21411: FOR_IN
21412: IFFALSE 21445
// if GetTag ( i ) = tag then
21414: LD_VAR 0 4
21418: PPUSH
21419: CALL_OW 110
21423: PUSH
21424: LD_VAR 0 2
21428: EQUAL
21429: IFFALSE 21443
// SetTag ( i , 0 ) ;
21431: LD_VAR 0 4
21435: PPUSH
21436: LD_INT 0
21438: PPUSH
21439: CALL_OW 109
21443: GO 21411
21445: POP
21446: POP
// end ;
21447: LD_VAR 0 3
21451: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
21452: LD_INT 0
21454: PPUSH
21455: PPUSH
21456: PPUSH
21457: PPUSH
21458: PPUSH
21459: PPUSH
21460: PPUSH
21461: PPUSH
// if not mc_bases then
21462: LD_EXP 50
21466: NOT
21467: IFFALSE 21471
// exit ;
21469: GO 21929
// for i = 1 to mc_bases do
21471: LD_ADDR_VAR 0 2
21475: PUSH
21476: DOUBLE
21477: LD_INT 1
21479: DEC
21480: ST_TO_ADDR
21481: LD_EXP 50
21485: PUSH
21486: FOR_TO
21487: IFFALSE 21927
// begin tmp := MC_ClassCheckReq ( i ) ;
21489: LD_ADDR_VAR 0 4
21493: PUSH
21494: LD_VAR 0 2
21498: PPUSH
21499: CALL 21934 0 1
21503: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
21504: LD_ADDR_EXP 91
21508: PUSH
21509: LD_EXP 91
21513: PPUSH
21514: LD_VAR 0 2
21518: PPUSH
21519: LD_VAR 0 4
21523: PPUSH
21524: CALL_OW 1
21528: ST_TO_ADDR
// if not tmp then
21529: LD_VAR 0 4
21533: NOT
21534: IFFALSE 21538
// continue ;
21536: GO 21486
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
21538: LD_ADDR_VAR 0 6
21542: PUSH
21543: LD_EXP 50
21547: PUSH
21548: LD_VAR 0 2
21552: ARRAY
21553: PPUSH
21554: LD_INT 2
21556: PUSH
21557: LD_INT 30
21559: PUSH
21560: LD_INT 4
21562: PUSH
21563: EMPTY
21564: LIST
21565: LIST
21566: PUSH
21567: LD_INT 30
21569: PUSH
21570: LD_INT 5
21572: PUSH
21573: EMPTY
21574: LIST
21575: LIST
21576: PUSH
21577: EMPTY
21578: LIST
21579: LIST
21580: LIST
21581: PPUSH
21582: CALL_OW 72
21586: PUSH
21587: LD_EXP 50
21591: PUSH
21592: LD_VAR 0 2
21596: ARRAY
21597: PPUSH
21598: LD_INT 2
21600: PUSH
21601: LD_INT 30
21603: PUSH
21604: LD_INT 0
21606: PUSH
21607: EMPTY
21608: LIST
21609: LIST
21610: PUSH
21611: LD_INT 30
21613: PUSH
21614: LD_INT 1
21616: PUSH
21617: EMPTY
21618: LIST
21619: LIST
21620: PUSH
21621: EMPTY
21622: LIST
21623: LIST
21624: LIST
21625: PPUSH
21626: CALL_OW 72
21630: PUSH
21631: LD_EXP 50
21635: PUSH
21636: LD_VAR 0 2
21640: ARRAY
21641: PPUSH
21642: LD_INT 30
21644: PUSH
21645: LD_INT 3
21647: PUSH
21648: EMPTY
21649: LIST
21650: LIST
21651: PPUSH
21652: CALL_OW 72
21656: PUSH
21657: LD_EXP 50
21661: PUSH
21662: LD_VAR 0 2
21666: ARRAY
21667: PPUSH
21668: LD_INT 2
21670: PUSH
21671: LD_INT 30
21673: PUSH
21674: LD_INT 6
21676: PUSH
21677: EMPTY
21678: LIST
21679: LIST
21680: PUSH
21681: LD_INT 30
21683: PUSH
21684: LD_INT 7
21686: PUSH
21687: EMPTY
21688: LIST
21689: LIST
21690: PUSH
21691: LD_INT 30
21693: PUSH
21694: LD_INT 8
21696: PUSH
21697: EMPTY
21698: LIST
21699: LIST
21700: PUSH
21701: EMPTY
21702: LIST
21703: LIST
21704: LIST
21705: LIST
21706: PPUSH
21707: CALL_OW 72
21711: PUSH
21712: EMPTY
21713: LIST
21714: LIST
21715: LIST
21716: LIST
21717: ST_TO_ADDR
// for j = 1 to 4 do
21718: LD_ADDR_VAR 0 3
21722: PUSH
21723: DOUBLE
21724: LD_INT 1
21726: DEC
21727: ST_TO_ADDR
21728: LD_INT 4
21730: PUSH
21731: FOR_TO
21732: IFFALSE 21923
// begin if not tmp [ j ] then
21734: LD_VAR 0 4
21738: PUSH
21739: LD_VAR 0 3
21743: ARRAY
21744: NOT
21745: IFFALSE 21749
// continue ;
21747: GO 21731
// for p in tmp [ j ] do
21749: LD_ADDR_VAR 0 5
21753: PUSH
21754: LD_VAR 0 4
21758: PUSH
21759: LD_VAR 0 3
21763: ARRAY
21764: PUSH
21765: FOR_IN
21766: IFFALSE 21919
// begin if not b [ j ] then
21768: LD_VAR 0 6
21772: PUSH
21773: LD_VAR 0 3
21777: ARRAY
21778: NOT
21779: IFFALSE 21783
// break ;
21781: GO 21919
// e := 0 ;
21783: LD_ADDR_VAR 0 7
21787: PUSH
21788: LD_INT 0
21790: ST_TO_ADDR
// for k in b [ j ] do
21791: LD_ADDR_VAR 0 8
21795: PUSH
21796: LD_VAR 0 6
21800: PUSH
21801: LD_VAR 0 3
21805: ARRAY
21806: PUSH
21807: FOR_IN
21808: IFFALSE 21835
// if IsNotFull ( k ) then
21810: LD_VAR 0 8
21814: PPUSH
21815: CALL 51821 0 1
21819: IFFALSE 21833
// begin e := k ;
21821: LD_ADDR_VAR 0 7
21825: PUSH
21826: LD_VAR 0 8
21830: ST_TO_ADDR
// break ;
21831: GO 21835
// end ;
21833: GO 21807
21835: POP
21836: POP
// if e and not UnitGoingToBuilding ( p , e ) then
21837: LD_VAR 0 7
21841: PUSH
21842: LD_VAR 0 5
21846: PPUSH
21847: LD_VAR 0 7
21851: PPUSH
21852: CALL 88950 0 2
21856: NOT
21857: AND
21858: IFFALSE 21917
// begin if IsInUnit ( p ) then
21860: LD_VAR 0 5
21864: PPUSH
21865: CALL_OW 310
21869: IFFALSE 21880
// ComExitBuilding ( p ) ;
21871: LD_VAR 0 5
21875: PPUSH
21876: CALL_OW 122
// ComEnterUnit ( p , e ) ;
21880: LD_VAR 0 5
21884: PPUSH
21885: LD_VAR 0 7
21889: PPUSH
21890: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
21894: LD_VAR 0 5
21898: PPUSH
21899: LD_VAR 0 3
21903: PPUSH
21904: CALL_OW 183
// AddComExitBuilding ( p ) ;
21908: LD_VAR 0 5
21912: PPUSH
21913: CALL_OW 182
// end ; end ;
21917: GO 21765
21919: POP
21920: POP
// end ;
21921: GO 21731
21923: POP
21924: POP
// end ;
21925: GO 21486
21927: POP
21928: POP
// end ;
21929: LD_VAR 0 1
21933: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
21934: LD_INT 0
21936: PPUSH
21937: PPUSH
21938: PPUSH
21939: PPUSH
21940: PPUSH
21941: PPUSH
21942: PPUSH
21943: PPUSH
21944: PPUSH
21945: PPUSH
21946: PPUSH
21947: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
21948: LD_VAR 0 1
21952: NOT
21953: PUSH
21954: LD_EXP 50
21958: PUSH
21959: LD_VAR 0 1
21963: ARRAY
21964: NOT
21965: OR
21966: PUSH
21967: LD_EXP 50
21971: PUSH
21972: LD_VAR 0 1
21976: ARRAY
21977: PPUSH
21978: LD_INT 2
21980: PUSH
21981: LD_INT 30
21983: PUSH
21984: LD_INT 0
21986: PUSH
21987: EMPTY
21988: LIST
21989: LIST
21990: PUSH
21991: LD_INT 30
21993: PUSH
21994: LD_INT 1
21996: PUSH
21997: EMPTY
21998: LIST
21999: LIST
22000: PUSH
22001: EMPTY
22002: LIST
22003: LIST
22004: LIST
22005: PPUSH
22006: CALL_OW 72
22010: NOT
22011: OR
22012: IFFALSE 22016
// exit ;
22014: GO 25519
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
22016: LD_ADDR_VAR 0 4
22020: PUSH
22021: LD_EXP 50
22025: PUSH
22026: LD_VAR 0 1
22030: ARRAY
22031: PPUSH
22032: LD_INT 2
22034: PUSH
22035: LD_INT 25
22037: PUSH
22038: LD_INT 1
22040: PUSH
22041: EMPTY
22042: LIST
22043: LIST
22044: PUSH
22045: LD_INT 25
22047: PUSH
22048: LD_INT 2
22050: PUSH
22051: EMPTY
22052: LIST
22053: LIST
22054: PUSH
22055: LD_INT 25
22057: PUSH
22058: LD_INT 3
22060: PUSH
22061: EMPTY
22062: LIST
22063: LIST
22064: PUSH
22065: LD_INT 25
22067: PUSH
22068: LD_INT 4
22070: PUSH
22071: EMPTY
22072: LIST
22073: LIST
22074: PUSH
22075: LD_INT 25
22077: PUSH
22078: LD_INT 5
22080: PUSH
22081: EMPTY
22082: LIST
22083: LIST
22084: PUSH
22085: LD_INT 25
22087: PUSH
22088: LD_INT 8
22090: PUSH
22091: EMPTY
22092: LIST
22093: LIST
22094: PUSH
22095: LD_INT 25
22097: PUSH
22098: LD_INT 9
22100: PUSH
22101: EMPTY
22102: LIST
22103: LIST
22104: PUSH
22105: EMPTY
22106: LIST
22107: LIST
22108: LIST
22109: LIST
22110: LIST
22111: LIST
22112: LIST
22113: LIST
22114: PPUSH
22115: CALL_OW 72
22119: ST_TO_ADDR
// if not tmp then
22120: LD_VAR 0 4
22124: NOT
22125: IFFALSE 22129
// exit ;
22127: GO 25519
// for i in tmp do
22129: LD_ADDR_VAR 0 3
22133: PUSH
22134: LD_VAR 0 4
22138: PUSH
22139: FOR_IN
22140: IFFALSE 22171
// if GetTag ( i ) then
22142: LD_VAR 0 3
22146: PPUSH
22147: CALL_OW 110
22151: IFFALSE 22169
// tmp := tmp diff i ;
22153: LD_ADDR_VAR 0 4
22157: PUSH
22158: LD_VAR 0 4
22162: PUSH
22163: LD_VAR 0 3
22167: DIFF
22168: ST_TO_ADDR
22169: GO 22139
22171: POP
22172: POP
// if not tmp then
22173: LD_VAR 0 4
22177: NOT
22178: IFFALSE 22182
// exit ;
22180: GO 25519
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
22182: LD_ADDR_VAR 0 5
22186: PUSH
22187: LD_EXP 50
22191: PUSH
22192: LD_VAR 0 1
22196: ARRAY
22197: PPUSH
22198: LD_INT 2
22200: PUSH
22201: LD_INT 25
22203: PUSH
22204: LD_INT 1
22206: PUSH
22207: EMPTY
22208: LIST
22209: LIST
22210: PUSH
22211: LD_INT 25
22213: PUSH
22214: LD_INT 5
22216: PUSH
22217: EMPTY
22218: LIST
22219: LIST
22220: PUSH
22221: LD_INT 25
22223: PUSH
22224: LD_INT 8
22226: PUSH
22227: EMPTY
22228: LIST
22229: LIST
22230: PUSH
22231: LD_INT 25
22233: PUSH
22234: LD_INT 9
22236: PUSH
22237: EMPTY
22238: LIST
22239: LIST
22240: PUSH
22241: EMPTY
22242: LIST
22243: LIST
22244: LIST
22245: LIST
22246: LIST
22247: PPUSH
22248: CALL_OW 72
22252: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
22253: LD_ADDR_VAR 0 6
22257: PUSH
22258: LD_EXP 50
22262: PUSH
22263: LD_VAR 0 1
22267: ARRAY
22268: PPUSH
22269: LD_INT 25
22271: PUSH
22272: LD_INT 2
22274: PUSH
22275: EMPTY
22276: LIST
22277: LIST
22278: PPUSH
22279: CALL_OW 72
22283: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
22284: LD_ADDR_VAR 0 7
22288: PUSH
22289: LD_EXP 50
22293: PUSH
22294: LD_VAR 0 1
22298: ARRAY
22299: PPUSH
22300: LD_INT 25
22302: PUSH
22303: LD_INT 3
22305: PUSH
22306: EMPTY
22307: LIST
22308: LIST
22309: PPUSH
22310: CALL_OW 72
22314: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
22315: LD_ADDR_VAR 0 8
22319: PUSH
22320: LD_EXP 50
22324: PUSH
22325: LD_VAR 0 1
22329: ARRAY
22330: PPUSH
22331: LD_INT 25
22333: PUSH
22334: LD_INT 4
22336: PUSH
22337: EMPTY
22338: LIST
22339: LIST
22340: PUSH
22341: LD_INT 24
22343: PUSH
22344: LD_INT 251
22346: PUSH
22347: EMPTY
22348: LIST
22349: LIST
22350: PUSH
22351: EMPTY
22352: LIST
22353: LIST
22354: PPUSH
22355: CALL_OW 72
22359: ST_TO_ADDR
// if mc_scan [ base ] then
22360: LD_EXP 73
22364: PUSH
22365: LD_VAR 0 1
22369: ARRAY
22370: IFFALSE 22831
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
22372: LD_ADDR_EXP 92
22376: PUSH
22377: LD_EXP 92
22381: PPUSH
22382: LD_VAR 0 1
22386: PPUSH
22387: LD_INT 4
22389: PPUSH
22390: CALL_OW 1
22394: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
22395: LD_ADDR_VAR 0 12
22399: PUSH
22400: LD_EXP 50
22404: PUSH
22405: LD_VAR 0 1
22409: ARRAY
22410: PPUSH
22411: LD_INT 2
22413: PUSH
22414: LD_INT 30
22416: PUSH
22417: LD_INT 4
22419: PUSH
22420: EMPTY
22421: LIST
22422: LIST
22423: PUSH
22424: LD_INT 30
22426: PUSH
22427: LD_INT 5
22429: PUSH
22430: EMPTY
22431: LIST
22432: LIST
22433: PUSH
22434: EMPTY
22435: LIST
22436: LIST
22437: LIST
22438: PPUSH
22439: CALL_OW 72
22443: ST_TO_ADDR
// if not b then
22444: LD_VAR 0 12
22448: NOT
22449: IFFALSE 22453
// exit ;
22451: GO 25519
// p := [ ] ;
22453: LD_ADDR_VAR 0 11
22457: PUSH
22458: EMPTY
22459: ST_TO_ADDR
// if sci >= 2 then
22460: LD_VAR 0 8
22464: PUSH
22465: LD_INT 2
22467: GREATEREQUAL
22468: IFFALSE 22499
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
22470: LD_ADDR_VAR 0 8
22474: PUSH
22475: LD_VAR 0 8
22479: PUSH
22480: LD_INT 1
22482: ARRAY
22483: PUSH
22484: LD_VAR 0 8
22488: PUSH
22489: LD_INT 2
22491: ARRAY
22492: PUSH
22493: EMPTY
22494: LIST
22495: LIST
22496: ST_TO_ADDR
22497: GO 22560
// if sci = 1 then
22499: LD_VAR 0 8
22503: PUSH
22504: LD_INT 1
22506: EQUAL
22507: IFFALSE 22528
// sci := [ sci [ 1 ] ] else
22509: LD_ADDR_VAR 0 8
22513: PUSH
22514: LD_VAR 0 8
22518: PUSH
22519: LD_INT 1
22521: ARRAY
22522: PUSH
22523: EMPTY
22524: LIST
22525: ST_TO_ADDR
22526: GO 22560
// if sci = 0 then
22528: LD_VAR 0 8
22532: PUSH
22533: LD_INT 0
22535: EQUAL
22536: IFFALSE 22560
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
22538: LD_ADDR_VAR 0 11
22542: PUSH
22543: LD_VAR 0 4
22547: PPUSH
22548: LD_INT 4
22550: PPUSH
22551: CALL 88813 0 2
22555: PUSH
22556: LD_INT 1
22558: ARRAY
22559: ST_TO_ADDR
// if eng > 4 then
22560: LD_VAR 0 6
22564: PUSH
22565: LD_INT 4
22567: GREATER
22568: IFFALSE 22614
// for i = eng downto 4 do
22570: LD_ADDR_VAR 0 3
22574: PUSH
22575: DOUBLE
22576: LD_VAR 0 6
22580: INC
22581: ST_TO_ADDR
22582: LD_INT 4
22584: PUSH
22585: FOR_DOWNTO
22586: IFFALSE 22612
// eng := eng diff eng [ i ] ;
22588: LD_ADDR_VAR 0 6
22592: PUSH
22593: LD_VAR 0 6
22597: PUSH
22598: LD_VAR 0 6
22602: PUSH
22603: LD_VAR 0 3
22607: ARRAY
22608: DIFF
22609: ST_TO_ADDR
22610: GO 22585
22612: POP
22613: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
22614: LD_ADDR_VAR 0 4
22618: PUSH
22619: LD_VAR 0 4
22623: PUSH
22624: LD_VAR 0 5
22628: PUSH
22629: LD_VAR 0 6
22633: UNION
22634: PUSH
22635: LD_VAR 0 7
22639: UNION
22640: PUSH
22641: LD_VAR 0 8
22645: UNION
22646: DIFF
22647: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
22648: LD_ADDR_VAR 0 13
22652: PUSH
22653: LD_EXP 50
22657: PUSH
22658: LD_VAR 0 1
22662: ARRAY
22663: PPUSH
22664: LD_INT 2
22666: PUSH
22667: LD_INT 30
22669: PUSH
22670: LD_INT 32
22672: PUSH
22673: EMPTY
22674: LIST
22675: LIST
22676: PUSH
22677: LD_INT 30
22679: PUSH
22680: LD_INT 31
22682: PUSH
22683: EMPTY
22684: LIST
22685: LIST
22686: PUSH
22687: EMPTY
22688: LIST
22689: LIST
22690: LIST
22691: PPUSH
22692: CALL_OW 72
22696: PUSH
22697: LD_EXP 50
22701: PUSH
22702: LD_VAR 0 1
22706: ARRAY
22707: PPUSH
22708: LD_INT 2
22710: PUSH
22711: LD_INT 30
22713: PUSH
22714: LD_INT 4
22716: PUSH
22717: EMPTY
22718: LIST
22719: LIST
22720: PUSH
22721: LD_INT 30
22723: PUSH
22724: LD_INT 5
22726: PUSH
22727: EMPTY
22728: LIST
22729: LIST
22730: PUSH
22731: EMPTY
22732: LIST
22733: LIST
22734: LIST
22735: PPUSH
22736: CALL_OW 72
22740: PUSH
22741: LD_INT 6
22743: MUL
22744: PLUS
22745: ST_TO_ADDR
// if bcount < tmp then
22746: LD_VAR 0 13
22750: PUSH
22751: LD_VAR 0 4
22755: LESS
22756: IFFALSE 22802
// for i = tmp downto bcount do
22758: LD_ADDR_VAR 0 3
22762: PUSH
22763: DOUBLE
22764: LD_VAR 0 4
22768: INC
22769: ST_TO_ADDR
22770: LD_VAR 0 13
22774: PUSH
22775: FOR_DOWNTO
22776: IFFALSE 22800
// tmp := Delete ( tmp , tmp ) ;
22778: LD_ADDR_VAR 0 4
22782: PUSH
22783: LD_VAR 0 4
22787: PPUSH
22788: LD_VAR 0 4
22792: PPUSH
22793: CALL_OW 3
22797: ST_TO_ADDR
22798: GO 22775
22800: POP
22801: POP
// result := [ tmp , 0 , 0 , p ] ;
22802: LD_ADDR_VAR 0 2
22806: PUSH
22807: LD_VAR 0 4
22811: PUSH
22812: LD_INT 0
22814: PUSH
22815: LD_INT 0
22817: PUSH
22818: LD_VAR 0 11
22822: PUSH
22823: EMPTY
22824: LIST
22825: LIST
22826: LIST
22827: LIST
22828: ST_TO_ADDR
// exit ;
22829: GO 25519
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
22831: LD_EXP 50
22835: PUSH
22836: LD_VAR 0 1
22840: ARRAY
22841: PPUSH
22842: LD_INT 2
22844: PUSH
22845: LD_INT 30
22847: PUSH
22848: LD_INT 6
22850: PUSH
22851: EMPTY
22852: LIST
22853: LIST
22854: PUSH
22855: LD_INT 30
22857: PUSH
22858: LD_INT 7
22860: PUSH
22861: EMPTY
22862: LIST
22863: LIST
22864: PUSH
22865: LD_INT 30
22867: PUSH
22868: LD_INT 8
22870: PUSH
22871: EMPTY
22872: LIST
22873: LIST
22874: PUSH
22875: EMPTY
22876: LIST
22877: LIST
22878: LIST
22879: LIST
22880: PPUSH
22881: CALL_OW 72
22885: NOT
22886: PUSH
22887: LD_EXP 50
22891: PUSH
22892: LD_VAR 0 1
22896: ARRAY
22897: PPUSH
22898: LD_INT 30
22900: PUSH
22901: LD_INT 3
22903: PUSH
22904: EMPTY
22905: LIST
22906: LIST
22907: PPUSH
22908: CALL_OW 72
22912: NOT
22913: AND
22914: IFFALSE 22986
// begin if eng = tmp then
22916: LD_VAR 0 6
22920: PUSH
22921: LD_VAR 0 4
22925: EQUAL
22926: IFFALSE 22930
// exit ;
22928: GO 25519
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
22930: LD_ADDR_EXP 92
22934: PUSH
22935: LD_EXP 92
22939: PPUSH
22940: LD_VAR 0 1
22944: PPUSH
22945: LD_INT 1
22947: PPUSH
22948: CALL_OW 1
22952: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
22953: LD_ADDR_VAR 0 2
22957: PUSH
22958: LD_INT 0
22960: PUSH
22961: LD_VAR 0 4
22965: PUSH
22966: LD_VAR 0 6
22970: DIFF
22971: PUSH
22972: LD_INT 0
22974: PUSH
22975: LD_INT 0
22977: PUSH
22978: EMPTY
22979: LIST
22980: LIST
22981: LIST
22982: LIST
22983: ST_TO_ADDR
// exit ;
22984: GO 25519
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
22986: LD_EXP 77
22990: PUSH
22991: LD_EXP 76
22995: PUSH
22996: LD_VAR 0 1
23000: ARRAY
23001: ARRAY
23002: PUSH
23003: LD_EXP 50
23007: PUSH
23008: LD_VAR 0 1
23012: ARRAY
23013: PPUSH
23014: LD_INT 2
23016: PUSH
23017: LD_INT 30
23019: PUSH
23020: LD_INT 6
23022: PUSH
23023: EMPTY
23024: LIST
23025: LIST
23026: PUSH
23027: LD_INT 30
23029: PUSH
23030: LD_INT 7
23032: PUSH
23033: EMPTY
23034: LIST
23035: LIST
23036: PUSH
23037: LD_INT 30
23039: PUSH
23040: LD_INT 8
23042: PUSH
23043: EMPTY
23044: LIST
23045: LIST
23046: PUSH
23047: EMPTY
23048: LIST
23049: LIST
23050: LIST
23051: LIST
23052: PPUSH
23053: CALL_OW 72
23057: AND
23058: PUSH
23059: LD_EXP 50
23063: PUSH
23064: LD_VAR 0 1
23068: ARRAY
23069: PPUSH
23070: LD_INT 30
23072: PUSH
23073: LD_INT 3
23075: PUSH
23076: EMPTY
23077: LIST
23078: LIST
23079: PPUSH
23080: CALL_OW 72
23084: NOT
23085: AND
23086: IFFALSE 23300
// begin if sci >= 6 then
23088: LD_VAR 0 8
23092: PUSH
23093: LD_INT 6
23095: GREATEREQUAL
23096: IFFALSE 23100
// exit ;
23098: GO 25519
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
23100: LD_ADDR_EXP 92
23104: PUSH
23105: LD_EXP 92
23109: PPUSH
23110: LD_VAR 0 1
23114: PPUSH
23115: LD_INT 2
23117: PPUSH
23118: CALL_OW 1
23122: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
23123: LD_ADDR_VAR 0 9
23127: PUSH
23128: LD_VAR 0 4
23132: PUSH
23133: LD_VAR 0 8
23137: DIFF
23138: PPUSH
23139: LD_INT 4
23141: PPUSH
23142: CALL 88813 0 2
23146: ST_TO_ADDR
// p := [ ] ;
23147: LD_ADDR_VAR 0 11
23151: PUSH
23152: EMPTY
23153: ST_TO_ADDR
// if sci < 6 and sort > 6 then
23154: LD_VAR 0 8
23158: PUSH
23159: LD_INT 6
23161: LESS
23162: PUSH
23163: LD_VAR 0 9
23167: PUSH
23168: LD_INT 6
23170: GREATER
23171: AND
23172: IFFALSE 23253
// begin for i = 1 to 6 - sci do
23174: LD_ADDR_VAR 0 3
23178: PUSH
23179: DOUBLE
23180: LD_INT 1
23182: DEC
23183: ST_TO_ADDR
23184: LD_INT 6
23186: PUSH
23187: LD_VAR 0 8
23191: MINUS
23192: PUSH
23193: FOR_TO
23194: IFFALSE 23249
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
23196: LD_ADDR_VAR 0 11
23200: PUSH
23201: LD_VAR 0 11
23205: PPUSH
23206: LD_VAR 0 11
23210: PUSH
23211: LD_INT 1
23213: PLUS
23214: PPUSH
23215: LD_VAR 0 9
23219: PUSH
23220: LD_INT 1
23222: ARRAY
23223: PPUSH
23224: CALL_OW 2
23228: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
23229: LD_ADDR_VAR 0 9
23233: PUSH
23234: LD_VAR 0 9
23238: PPUSH
23239: LD_INT 1
23241: PPUSH
23242: CALL_OW 3
23246: ST_TO_ADDR
// end ;
23247: GO 23193
23249: POP
23250: POP
// end else
23251: GO 23273
// if sort then
23253: LD_VAR 0 9
23257: IFFALSE 23273
// p := sort [ 1 ] ;
23259: LD_ADDR_VAR 0 11
23263: PUSH
23264: LD_VAR 0 9
23268: PUSH
23269: LD_INT 1
23271: ARRAY
23272: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
23273: LD_ADDR_VAR 0 2
23277: PUSH
23278: LD_INT 0
23280: PUSH
23281: LD_INT 0
23283: PUSH
23284: LD_INT 0
23286: PUSH
23287: LD_VAR 0 11
23291: PUSH
23292: EMPTY
23293: LIST
23294: LIST
23295: LIST
23296: LIST
23297: ST_TO_ADDR
// exit ;
23298: GO 25519
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
23300: LD_EXP 77
23304: PUSH
23305: LD_EXP 76
23309: PUSH
23310: LD_VAR 0 1
23314: ARRAY
23315: ARRAY
23316: PUSH
23317: LD_EXP 50
23321: PUSH
23322: LD_VAR 0 1
23326: ARRAY
23327: PPUSH
23328: LD_INT 2
23330: PUSH
23331: LD_INT 30
23333: PUSH
23334: LD_INT 6
23336: PUSH
23337: EMPTY
23338: LIST
23339: LIST
23340: PUSH
23341: LD_INT 30
23343: PUSH
23344: LD_INT 7
23346: PUSH
23347: EMPTY
23348: LIST
23349: LIST
23350: PUSH
23351: LD_INT 30
23353: PUSH
23354: LD_INT 8
23356: PUSH
23357: EMPTY
23358: LIST
23359: LIST
23360: PUSH
23361: EMPTY
23362: LIST
23363: LIST
23364: LIST
23365: LIST
23366: PPUSH
23367: CALL_OW 72
23371: AND
23372: PUSH
23373: LD_EXP 50
23377: PUSH
23378: LD_VAR 0 1
23382: ARRAY
23383: PPUSH
23384: LD_INT 30
23386: PUSH
23387: LD_INT 3
23389: PUSH
23390: EMPTY
23391: LIST
23392: LIST
23393: PPUSH
23394: CALL_OW 72
23398: AND
23399: IFFALSE 24133
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
23401: LD_ADDR_EXP 92
23405: PUSH
23406: LD_EXP 92
23410: PPUSH
23411: LD_VAR 0 1
23415: PPUSH
23416: LD_INT 3
23418: PPUSH
23419: CALL_OW 1
23423: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
23424: LD_ADDR_VAR 0 2
23428: PUSH
23429: LD_INT 0
23431: PUSH
23432: LD_INT 0
23434: PUSH
23435: LD_INT 0
23437: PUSH
23438: LD_INT 0
23440: PUSH
23441: EMPTY
23442: LIST
23443: LIST
23444: LIST
23445: LIST
23446: ST_TO_ADDR
// if not eng then
23447: LD_VAR 0 6
23451: NOT
23452: IFFALSE 23515
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
23454: LD_ADDR_VAR 0 11
23458: PUSH
23459: LD_VAR 0 4
23463: PPUSH
23464: LD_INT 2
23466: PPUSH
23467: CALL 88813 0 2
23471: PUSH
23472: LD_INT 1
23474: ARRAY
23475: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
23476: LD_ADDR_VAR 0 2
23480: PUSH
23481: LD_VAR 0 2
23485: PPUSH
23486: LD_INT 2
23488: PPUSH
23489: LD_VAR 0 11
23493: PPUSH
23494: CALL_OW 1
23498: ST_TO_ADDR
// tmp := tmp diff p ;
23499: LD_ADDR_VAR 0 4
23503: PUSH
23504: LD_VAR 0 4
23508: PUSH
23509: LD_VAR 0 11
23513: DIFF
23514: ST_TO_ADDR
// end ; if tmp and sci < 6 then
23515: LD_VAR 0 4
23519: PUSH
23520: LD_VAR 0 8
23524: PUSH
23525: LD_INT 6
23527: LESS
23528: AND
23529: IFFALSE 23717
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
23531: LD_ADDR_VAR 0 9
23535: PUSH
23536: LD_VAR 0 4
23540: PUSH
23541: LD_VAR 0 8
23545: PUSH
23546: LD_VAR 0 7
23550: UNION
23551: DIFF
23552: PPUSH
23553: LD_INT 4
23555: PPUSH
23556: CALL 88813 0 2
23560: ST_TO_ADDR
// p := [ ] ;
23561: LD_ADDR_VAR 0 11
23565: PUSH
23566: EMPTY
23567: ST_TO_ADDR
// if sort then
23568: LD_VAR 0 9
23572: IFFALSE 23688
// for i = 1 to 6 - sci do
23574: LD_ADDR_VAR 0 3
23578: PUSH
23579: DOUBLE
23580: LD_INT 1
23582: DEC
23583: ST_TO_ADDR
23584: LD_INT 6
23586: PUSH
23587: LD_VAR 0 8
23591: MINUS
23592: PUSH
23593: FOR_TO
23594: IFFALSE 23686
// begin if i = sort then
23596: LD_VAR 0 3
23600: PUSH
23601: LD_VAR 0 9
23605: EQUAL
23606: IFFALSE 23610
// break ;
23608: GO 23686
// if GetClass ( i ) = 4 then
23610: LD_VAR 0 3
23614: PPUSH
23615: CALL_OW 257
23619: PUSH
23620: LD_INT 4
23622: EQUAL
23623: IFFALSE 23627
// continue ;
23625: GO 23593
// p := Insert ( p , p + 1 , sort [ i ] ) ;
23627: LD_ADDR_VAR 0 11
23631: PUSH
23632: LD_VAR 0 11
23636: PPUSH
23637: LD_VAR 0 11
23641: PUSH
23642: LD_INT 1
23644: PLUS
23645: PPUSH
23646: LD_VAR 0 9
23650: PUSH
23651: LD_VAR 0 3
23655: ARRAY
23656: PPUSH
23657: CALL_OW 2
23661: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
23662: LD_ADDR_VAR 0 4
23666: PUSH
23667: LD_VAR 0 4
23671: PUSH
23672: LD_VAR 0 9
23676: PUSH
23677: LD_VAR 0 3
23681: ARRAY
23682: DIFF
23683: ST_TO_ADDR
// end ;
23684: GO 23593
23686: POP
23687: POP
// if p then
23688: LD_VAR 0 11
23692: IFFALSE 23717
// result := Replace ( result , 4 , p ) ;
23694: LD_ADDR_VAR 0 2
23698: PUSH
23699: LD_VAR 0 2
23703: PPUSH
23704: LD_INT 4
23706: PPUSH
23707: LD_VAR 0 11
23711: PPUSH
23712: CALL_OW 1
23716: ST_TO_ADDR
// end ; if tmp and mech < 6 then
23717: LD_VAR 0 4
23721: PUSH
23722: LD_VAR 0 7
23726: PUSH
23727: LD_INT 6
23729: LESS
23730: AND
23731: IFFALSE 23919
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
23733: LD_ADDR_VAR 0 9
23737: PUSH
23738: LD_VAR 0 4
23742: PUSH
23743: LD_VAR 0 8
23747: PUSH
23748: LD_VAR 0 7
23752: UNION
23753: DIFF
23754: PPUSH
23755: LD_INT 3
23757: PPUSH
23758: CALL 88813 0 2
23762: ST_TO_ADDR
// p := [ ] ;
23763: LD_ADDR_VAR 0 11
23767: PUSH
23768: EMPTY
23769: ST_TO_ADDR
// if sort then
23770: LD_VAR 0 9
23774: IFFALSE 23890
// for i = 1 to 6 - mech do
23776: LD_ADDR_VAR 0 3
23780: PUSH
23781: DOUBLE
23782: LD_INT 1
23784: DEC
23785: ST_TO_ADDR
23786: LD_INT 6
23788: PUSH
23789: LD_VAR 0 7
23793: MINUS
23794: PUSH
23795: FOR_TO
23796: IFFALSE 23888
// begin if i = sort then
23798: LD_VAR 0 3
23802: PUSH
23803: LD_VAR 0 9
23807: EQUAL
23808: IFFALSE 23812
// break ;
23810: GO 23888
// if GetClass ( i ) = 3 then
23812: LD_VAR 0 3
23816: PPUSH
23817: CALL_OW 257
23821: PUSH
23822: LD_INT 3
23824: EQUAL
23825: IFFALSE 23829
// continue ;
23827: GO 23795
// p := Insert ( p , p + 1 , sort [ i ] ) ;
23829: LD_ADDR_VAR 0 11
23833: PUSH
23834: LD_VAR 0 11
23838: PPUSH
23839: LD_VAR 0 11
23843: PUSH
23844: LD_INT 1
23846: PLUS
23847: PPUSH
23848: LD_VAR 0 9
23852: PUSH
23853: LD_VAR 0 3
23857: ARRAY
23858: PPUSH
23859: CALL_OW 2
23863: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
23864: LD_ADDR_VAR 0 4
23868: PUSH
23869: LD_VAR 0 4
23873: PUSH
23874: LD_VAR 0 9
23878: PUSH
23879: LD_VAR 0 3
23883: ARRAY
23884: DIFF
23885: ST_TO_ADDR
// end ;
23886: GO 23795
23888: POP
23889: POP
// if p then
23890: LD_VAR 0 11
23894: IFFALSE 23919
// result := Replace ( result , 3 , p ) ;
23896: LD_ADDR_VAR 0 2
23900: PUSH
23901: LD_VAR 0 2
23905: PPUSH
23906: LD_INT 3
23908: PPUSH
23909: LD_VAR 0 11
23913: PPUSH
23914: CALL_OW 1
23918: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
23919: LD_VAR 0 4
23923: PUSH
23924: LD_INT 6
23926: GREATER
23927: PUSH
23928: LD_VAR 0 6
23932: PUSH
23933: LD_INT 6
23935: LESS
23936: AND
23937: IFFALSE 24131
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
23939: LD_ADDR_VAR 0 9
23943: PUSH
23944: LD_VAR 0 4
23948: PUSH
23949: LD_VAR 0 8
23953: PUSH
23954: LD_VAR 0 7
23958: UNION
23959: PUSH
23960: LD_VAR 0 6
23964: UNION
23965: DIFF
23966: PPUSH
23967: LD_INT 2
23969: PPUSH
23970: CALL 88813 0 2
23974: ST_TO_ADDR
// p := [ ] ;
23975: LD_ADDR_VAR 0 11
23979: PUSH
23980: EMPTY
23981: ST_TO_ADDR
// if sort then
23982: LD_VAR 0 9
23986: IFFALSE 24102
// for i = 1 to 6 - eng do
23988: LD_ADDR_VAR 0 3
23992: PUSH
23993: DOUBLE
23994: LD_INT 1
23996: DEC
23997: ST_TO_ADDR
23998: LD_INT 6
24000: PUSH
24001: LD_VAR 0 6
24005: MINUS
24006: PUSH
24007: FOR_TO
24008: IFFALSE 24100
// begin if i = sort then
24010: LD_VAR 0 3
24014: PUSH
24015: LD_VAR 0 9
24019: EQUAL
24020: IFFALSE 24024
// break ;
24022: GO 24100
// if GetClass ( i ) = 2 then
24024: LD_VAR 0 3
24028: PPUSH
24029: CALL_OW 257
24033: PUSH
24034: LD_INT 2
24036: EQUAL
24037: IFFALSE 24041
// continue ;
24039: GO 24007
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24041: LD_ADDR_VAR 0 11
24045: PUSH
24046: LD_VAR 0 11
24050: PPUSH
24051: LD_VAR 0 11
24055: PUSH
24056: LD_INT 1
24058: PLUS
24059: PPUSH
24060: LD_VAR 0 9
24064: PUSH
24065: LD_VAR 0 3
24069: ARRAY
24070: PPUSH
24071: CALL_OW 2
24075: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24076: LD_ADDR_VAR 0 4
24080: PUSH
24081: LD_VAR 0 4
24085: PUSH
24086: LD_VAR 0 9
24090: PUSH
24091: LD_VAR 0 3
24095: ARRAY
24096: DIFF
24097: ST_TO_ADDR
// end ;
24098: GO 24007
24100: POP
24101: POP
// if p then
24102: LD_VAR 0 11
24106: IFFALSE 24131
// result := Replace ( result , 2 , p ) ;
24108: LD_ADDR_VAR 0 2
24112: PUSH
24113: LD_VAR 0 2
24117: PPUSH
24118: LD_INT 2
24120: PPUSH
24121: LD_VAR 0 11
24125: PPUSH
24126: CALL_OW 1
24130: ST_TO_ADDR
// end ; exit ;
24131: GO 25519
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
24133: LD_EXP 77
24137: PUSH
24138: LD_EXP 76
24142: PUSH
24143: LD_VAR 0 1
24147: ARRAY
24148: ARRAY
24149: NOT
24150: PUSH
24151: LD_EXP 50
24155: PUSH
24156: LD_VAR 0 1
24160: ARRAY
24161: PPUSH
24162: LD_INT 30
24164: PUSH
24165: LD_INT 3
24167: PUSH
24168: EMPTY
24169: LIST
24170: LIST
24171: PPUSH
24172: CALL_OW 72
24176: AND
24177: PUSH
24178: LD_EXP 55
24182: PUSH
24183: LD_VAR 0 1
24187: ARRAY
24188: AND
24189: IFFALSE 24797
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
24191: LD_ADDR_EXP 92
24195: PUSH
24196: LD_EXP 92
24200: PPUSH
24201: LD_VAR 0 1
24205: PPUSH
24206: LD_INT 5
24208: PPUSH
24209: CALL_OW 1
24213: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
24214: LD_ADDR_VAR 0 2
24218: PUSH
24219: LD_INT 0
24221: PUSH
24222: LD_INT 0
24224: PUSH
24225: LD_INT 0
24227: PUSH
24228: LD_INT 0
24230: PUSH
24231: EMPTY
24232: LIST
24233: LIST
24234: LIST
24235: LIST
24236: ST_TO_ADDR
// if sci > 1 then
24237: LD_VAR 0 8
24241: PUSH
24242: LD_INT 1
24244: GREATER
24245: IFFALSE 24273
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
24247: LD_ADDR_VAR 0 4
24251: PUSH
24252: LD_VAR 0 4
24256: PUSH
24257: LD_VAR 0 8
24261: PUSH
24262: LD_VAR 0 8
24266: PUSH
24267: LD_INT 1
24269: ARRAY
24270: DIFF
24271: DIFF
24272: ST_TO_ADDR
// if tmp and not sci then
24273: LD_VAR 0 4
24277: PUSH
24278: LD_VAR 0 8
24282: NOT
24283: AND
24284: IFFALSE 24353
// begin sort := SortBySkill ( tmp , 4 ) ;
24286: LD_ADDR_VAR 0 9
24290: PUSH
24291: LD_VAR 0 4
24295: PPUSH
24296: LD_INT 4
24298: PPUSH
24299: CALL 88813 0 2
24303: ST_TO_ADDR
// if sort then
24304: LD_VAR 0 9
24308: IFFALSE 24324
// p := sort [ 1 ] ;
24310: LD_ADDR_VAR 0 11
24314: PUSH
24315: LD_VAR 0 9
24319: PUSH
24320: LD_INT 1
24322: ARRAY
24323: ST_TO_ADDR
// if p then
24324: LD_VAR 0 11
24328: IFFALSE 24353
// result := Replace ( result , 4 , p ) ;
24330: LD_ADDR_VAR 0 2
24334: PUSH
24335: LD_VAR 0 2
24339: PPUSH
24340: LD_INT 4
24342: PPUSH
24343: LD_VAR 0 11
24347: PPUSH
24348: CALL_OW 1
24352: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
24353: LD_ADDR_VAR 0 4
24357: PUSH
24358: LD_VAR 0 4
24362: PUSH
24363: LD_VAR 0 7
24367: DIFF
24368: ST_TO_ADDR
// if tmp and mech < 6 then
24369: LD_VAR 0 4
24373: PUSH
24374: LD_VAR 0 7
24378: PUSH
24379: LD_INT 6
24381: LESS
24382: AND
24383: IFFALSE 24571
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
24385: LD_ADDR_VAR 0 9
24389: PUSH
24390: LD_VAR 0 4
24394: PUSH
24395: LD_VAR 0 8
24399: PUSH
24400: LD_VAR 0 7
24404: UNION
24405: DIFF
24406: PPUSH
24407: LD_INT 3
24409: PPUSH
24410: CALL 88813 0 2
24414: ST_TO_ADDR
// p := [ ] ;
24415: LD_ADDR_VAR 0 11
24419: PUSH
24420: EMPTY
24421: ST_TO_ADDR
// if sort then
24422: LD_VAR 0 9
24426: IFFALSE 24542
// for i = 1 to 6 - mech do
24428: LD_ADDR_VAR 0 3
24432: PUSH
24433: DOUBLE
24434: LD_INT 1
24436: DEC
24437: ST_TO_ADDR
24438: LD_INT 6
24440: PUSH
24441: LD_VAR 0 7
24445: MINUS
24446: PUSH
24447: FOR_TO
24448: IFFALSE 24540
// begin if i = sort then
24450: LD_VAR 0 3
24454: PUSH
24455: LD_VAR 0 9
24459: EQUAL
24460: IFFALSE 24464
// break ;
24462: GO 24540
// if GetClass ( i ) = 3 then
24464: LD_VAR 0 3
24468: PPUSH
24469: CALL_OW 257
24473: PUSH
24474: LD_INT 3
24476: EQUAL
24477: IFFALSE 24481
// continue ;
24479: GO 24447
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24481: LD_ADDR_VAR 0 11
24485: PUSH
24486: LD_VAR 0 11
24490: PPUSH
24491: LD_VAR 0 11
24495: PUSH
24496: LD_INT 1
24498: PLUS
24499: PPUSH
24500: LD_VAR 0 9
24504: PUSH
24505: LD_VAR 0 3
24509: ARRAY
24510: PPUSH
24511: CALL_OW 2
24515: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24516: LD_ADDR_VAR 0 4
24520: PUSH
24521: LD_VAR 0 4
24525: PUSH
24526: LD_VAR 0 9
24530: PUSH
24531: LD_VAR 0 3
24535: ARRAY
24536: DIFF
24537: ST_TO_ADDR
// end ;
24538: GO 24447
24540: POP
24541: POP
// if p then
24542: LD_VAR 0 11
24546: IFFALSE 24571
// result := Replace ( result , 3 , p ) ;
24548: LD_ADDR_VAR 0 2
24552: PUSH
24553: LD_VAR 0 2
24557: PPUSH
24558: LD_INT 3
24560: PPUSH
24561: LD_VAR 0 11
24565: PPUSH
24566: CALL_OW 1
24570: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
24571: LD_ADDR_VAR 0 4
24575: PUSH
24576: LD_VAR 0 4
24580: PUSH
24581: LD_VAR 0 6
24585: DIFF
24586: ST_TO_ADDR
// if tmp and eng < 6 then
24587: LD_VAR 0 4
24591: PUSH
24592: LD_VAR 0 6
24596: PUSH
24597: LD_INT 6
24599: LESS
24600: AND
24601: IFFALSE 24795
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
24603: LD_ADDR_VAR 0 9
24607: PUSH
24608: LD_VAR 0 4
24612: PUSH
24613: LD_VAR 0 8
24617: PUSH
24618: LD_VAR 0 7
24622: UNION
24623: PUSH
24624: LD_VAR 0 6
24628: UNION
24629: DIFF
24630: PPUSH
24631: LD_INT 2
24633: PPUSH
24634: CALL 88813 0 2
24638: ST_TO_ADDR
// p := [ ] ;
24639: LD_ADDR_VAR 0 11
24643: PUSH
24644: EMPTY
24645: ST_TO_ADDR
// if sort then
24646: LD_VAR 0 9
24650: IFFALSE 24766
// for i = 1 to 6 - eng do
24652: LD_ADDR_VAR 0 3
24656: PUSH
24657: DOUBLE
24658: LD_INT 1
24660: DEC
24661: ST_TO_ADDR
24662: LD_INT 6
24664: PUSH
24665: LD_VAR 0 6
24669: MINUS
24670: PUSH
24671: FOR_TO
24672: IFFALSE 24764
// begin if i = sort then
24674: LD_VAR 0 3
24678: PUSH
24679: LD_VAR 0 9
24683: EQUAL
24684: IFFALSE 24688
// break ;
24686: GO 24764
// if GetClass ( i ) = 2 then
24688: LD_VAR 0 3
24692: PPUSH
24693: CALL_OW 257
24697: PUSH
24698: LD_INT 2
24700: EQUAL
24701: IFFALSE 24705
// continue ;
24703: GO 24671
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24705: LD_ADDR_VAR 0 11
24709: PUSH
24710: LD_VAR 0 11
24714: PPUSH
24715: LD_VAR 0 11
24719: PUSH
24720: LD_INT 1
24722: PLUS
24723: PPUSH
24724: LD_VAR 0 9
24728: PUSH
24729: LD_VAR 0 3
24733: ARRAY
24734: PPUSH
24735: CALL_OW 2
24739: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24740: LD_ADDR_VAR 0 4
24744: PUSH
24745: LD_VAR 0 4
24749: PUSH
24750: LD_VAR 0 9
24754: PUSH
24755: LD_VAR 0 3
24759: ARRAY
24760: DIFF
24761: ST_TO_ADDR
// end ;
24762: GO 24671
24764: POP
24765: POP
// if p then
24766: LD_VAR 0 11
24770: IFFALSE 24795
// result := Replace ( result , 2 , p ) ;
24772: LD_ADDR_VAR 0 2
24776: PUSH
24777: LD_VAR 0 2
24781: PPUSH
24782: LD_INT 2
24784: PPUSH
24785: LD_VAR 0 11
24789: PPUSH
24790: CALL_OW 1
24794: ST_TO_ADDR
// end ; exit ;
24795: GO 25519
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
24797: LD_EXP 77
24801: PUSH
24802: LD_EXP 76
24806: PUSH
24807: LD_VAR 0 1
24811: ARRAY
24812: ARRAY
24813: NOT
24814: PUSH
24815: LD_EXP 50
24819: PUSH
24820: LD_VAR 0 1
24824: ARRAY
24825: PPUSH
24826: LD_INT 30
24828: PUSH
24829: LD_INT 3
24831: PUSH
24832: EMPTY
24833: LIST
24834: LIST
24835: PPUSH
24836: CALL_OW 72
24840: AND
24841: PUSH
24842: LD_EXP 55
24846: PUSH
24847: LD_VAR 0 1
24851: ARRAY
24852: NOT
24853: AND
24854: IFFALSE 25519
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
24856: LD_ADDR_EXP 92
24860: PUSH
24861: LD_EXP 92
24865: PPUSH
24866: LD_VAR 0 1
24870: PPUSH
24871: LD_INT 6
24873: PPUSH
24874: CALL_OW 1
24878: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
24879: LD_ADDR_VAR 0 2
24883: PUSH
24884: LD_INT 0
24886: PUSH
24887: LD_INT 0
24889: PUSH
24890: LD_INT 0
24892: PUSH
24893: LD_INT 0
24895: PUSH
24896: EMPTY
24897: LIST
24898: LIST
24899: LIST
24900: LIST
24901: ST_TO_ADDR
// if sci >= 1 then
24902: LD_VAR 0 8
24906: PUSH
24907: LD_INT 1
24909: GREATEREQUAL
24910: IFFALSE 24932
// tmp := tmp diff sci [ 1 ] ;
24912: LD_ADDR_VAR 0 4
24916: PUSH
24917: LD_VAR 0 4
24921: PUSH
24922: LD_VAR 0 8
24926: PUSH
24927: LD_INT 1
24929: ARRAY
24930: DIFF
24931: ST_TO_ADDR
// if tmp and not sci then
24932: LD_VAR 0 4
24936: PUSH
24937: LD_VAR 0 8
24941: NOT
24942: AND
24943: IFFALSE 25012
// begin sort := SortBySkill ( tmp , 4 ) ;
24945: LD_ADDR_VAR 0 9
24949: PUSH
24950: LD_VAR 0 4
24954: PPUSH
24955: LD_INT 4
24957: PPUSH
24958: CALL 88813 0 2
24962: ST_TO_ADDR
// if sort then
24963: LD_VAR 0 9
24967: IFFALSE 24983
// p := sort [ 1 ] ;
24969: LD_ADDR_VAR 0 11
24973: PUSH
24974: LD_VAR 0 9
24978: PUSH
24979: LD_INT 1
24981: ARRAY
24982: ST_TO_ADDR
// if p then
24983: LD_VAR 0 11
24987: IFFALSE 25012
// result := Replace ( result , 4 , p ) ;
24989: LD_ADDR_VAR 0 2
24993: PUSH
24994: LD_VAR 0 2
24998: PPUSH
24999: LD_INT 4
25001: PPUSH
25002: LD_VAR 0 11
25006: PPUSH
25007: CALL_OW 1
25011: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
25012: LD_ADDR_VAR 0 4
25016: PUSH
25017: LD_VAR 0 4
25021: PUSH
25022: LD_VAR 0 7
25026: DIFF
25027: ST_TO_ADDR
// if tmp and mech < 6 then
25028: LD_VAR 0 4
25032: PUSH
25033: LD_VAR 0 7
25037: PUSH
25038: LD_INT 6
25040: LESS
25041: AND
25042: IFFALSE 25224
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
25044: LD_ADDR_VAR 0 9
25048: PUSH
25049: LD_VAR 0 4
25053: PUSH
25054: LD_VAR 0 7
25058: DIFF
25059: PPUSH
25060: LD_INT 3
25062: PPUSH
25063: CALL 88813 0 2
25067: ST_TO_ADDR
// p := [ ] ;
25068: LD_ADDR_VAR 0 11
25072: PUSH
25073: EMPTY
25074: ST_TO_ADDR
// if sort then
25075: LD_VAR 0 9
25079: IFFALSE 25195
// for i = 1 to 6 - mech do
25081: LD_ADDR_VAR 0 3
25085: PUSH
25086: DOUBLE
25087: LD_INT 1
25089: DEC
25090: ST_TO_ADDR
25091: LD_INT 6
25093: PUSH
25094: LD_VAR 0 7
25098: MINUS
25099: PUSH
25100: FOR_TO
25101: IFFALSE 25193
// begin if i = sort then
25103: LD_VAR 0 3
25107: PUSH
25108: LD_VAR 0 9
25112: EQUAL
25113: IFFALSE 25117
// break ;
25115: GO 25193
// if GetClass ( i ) = 3 then
25117: LD_VAR 0 3
25121: PPUSH
25122: CALL_OW 257
25126: PUSH
25127: LD_INT 3
25129: EQUAL
25130: IFFALSE 25134
// continue ;
25132: GO 25100
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25134: LD_ADDR_VAR 0 11
25138: PUSH
25139: LD_VAR 0 11
25143: PPUSH
25144: LD_VAR 0 11
25148: PUSH
25149: LD_INT 1
25151: PLUS
25152: PPUSH
25153: LD_VAR 0 9
25157: PUSH
25158: LD_VAR 0 3
25162: ARRAY
25163: PPUSH
25164: CALL_OW 2
25168: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25169: LD_ADDR_VAR 0 4
25173: PUSH
25174: LD_VAR 0 4
25178: PUSH
25179: LD_VAR 0 9
25183: PUSH
25184: LD_VAR 0 3
25188: ARRAY
25189: DIFF
25190: ST_TO_ADDR
// end ;
25191: GO 25100
25193: POP
25194: POP
// if p then
25195: LD_VAR 0 11
25199: IFFALSE 25224
// result := Replace ( result , 3 , p ) ;
25201: LD_ADDR_VAR 0 2
25205: PUSH
25206: LD_VAR 0 2
25210: PPUSH
25211: LD_INT 3
25213: PPUSH
25214: LD_VAR 0 11
25218: PPUSH
25219: CALL_OW 1
25223: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
25224: LD_ADDR_VAR 0 4
25228: PUSH
25229: LD_VAR 0 4
25233: PUSH
25234: LD_VAR 0 6
25238: DIFF
25239: ST_TO_ADDR
// if tmp and eng < 4 then
25240: LD_VAR 0 4
25244: PUSH
25245: LD_VAR 0 6
25249: PUSH
25250: LD_INT 4
25252: LESS
25253: AND
25254: IFFALSE 25444
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
25256: LD_ADDR_VAR 0 9
25260: PUSH
25261: LD_VAR 0 4
25265: PUSH
25266: LD_VAR 0 7
25270: PUSH
25271: LD_VAR 0 6
25275: UNION
25276: DIFF
25277: PPUSH
25278: LD_INT 2
25280: PPUSH
25281: CALL 88813 0 2
25285: ST_TO_ADDR
// p := [ ] ;
25286: LD_ADDR_VAR 0 11
25290: PUSH
25291: EMPTY
25292: ST_TO_ADDR
// if sort then
25293: LD_VAR 0 9
25297: IFFALSE 25413
// for i = 1 to 4 - eng do
25299: LD_ADDR_VAR 0 3
25303: PUSH
25304: DOUBLE
25305: LD_INT 1
25307: DEC
25308: ST_TO_ADDR
25309: LD_INT 4
25311: PUSH
25312: LD_VAR 0 6
25316: MINUS
25317: PUSH
25318: FOR_TO
25319: IFFALSE 25411
// begin if i = sort then
25321: LD_VAR 0 3
25325: PUSH
25326: LD_VAR 0 9
25330: EQUAL
25331: IFFALSE 25335
// break ;
25333: GO 25411
// if GetClass ( i ) = 2 then
25335: LD_VAR 0 3
25339: PPUSH
25340: CALL_OW 257
25344: PUSH
25345: LD_INT 2
25347: EQUAL
25348: IFFALSE 25352
// continue ;
25350: GO 25318
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25352: LD_ADDR_VAR 0 11
25356: PUSH
25357: LD_VAR 0 11
25361: PPUSH
25362: LD_VAR 0 11
25366: PUSH
25367: LD_INT 1
25369: PLUS
25370: PPUSH
25371: LD_VAR 0 9
25375: PUSH
25376: LD_VAR 0 3
25380: ARRAY
25381: PPUSH
25382: CALL_OW 2
25386: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25387: LD_ADDR_VAR 0 4
25391: PUSH
25392: LD_VAR 0 4
25396: PUSH
25397: LD_VAR 0 9
25401: PUSH
25402: LD_VAR 0 3
25406: ARRAY
25407: DIFF
25408: ST_TO_ADDR
// end ;
25409: GO 25318
25411: POP
25412: POP
// if p then
25413: LD_VAR 0 11
25417: IFFALSE 25442
// result := Replace ( result , 2 , p ) ;
25419: LD_ADDR_VAR 0 2
25423: PUSH
25424: LD_VAR 0 2
25428: PPUSH
25429: LD_INT 2
25431: PPUSH
25432: LD_VAR 0 11
25436: PPUSH
25437: CALL_OW 1
25441: ST_TO_ADDR
// end else
25442: GO 25488
// for i = eng downto 5 do
25444: LD_ADDR_VAR 0 3
25448: PUSH
25449: DOUBLE
25450: LD_VAR 0 6
25454: INC
25455: ST_TO_ADDR
25456: LD_INT 5
25458: PUSH
25459: FOR_DOWNTO
25460: IFFALSE 25486
// tmp := tmp union eng [ i ] ;
25462: LD_ADDR_VAR 0 4
25466: PUSH
25467: LD_VAR 0 4
25471: PUSH
25472: LD_VAR 0 6
25476: PUSH
25477: LD_VAR 0 3
25481: ARRAY
25482: UNION
25483: ST_TO_ADDR
25484: GO 25459
25486: POP
25487: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
25488: LD_ADDR_VAR 0 2
25492: PUSH
25493: LD_VAR 0 2
25497: PPUSH
25498: LD_INT 1
25500: PPUSH
25501: LD_VAR 0 4
25505: PUSH
25506: LD_VAR 0 5
25510: DIFF
25511: PPUSH
25512: CALL_OW 1
25516: ST_TO_ADDR
// exit ;
25517: GO 25519
// end ; end ;
25519: LD_VAR 0 2
25523: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
25524: LD_INT 0
25526: PPUSH
25527: PPUSH
25528: PPUSH
// if not mc_bases then
25529: LD_EXP 50
25533: NOT
25534: IFFALSE 25538
// exit ;
25536: GO 25644
// for i = 1 to mc_bases do
25538: LD_ADDR_VAR 0 2
25542: PUSH
25543: DOUBLE
25544: LD_INT 1
25546: DEC
25547: ST_TO_ADDR
25548: LD_EXP 50
25552: PUSH
25553: FOR_TO
25554: IFFALSE 25635
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
25556: LD_ADDR_VAR 0 3
25560: PUSH
25561: LD_EXP 50
25565: PUSH
25566: LD_VAR 0 2
25570: ARRAY
25571: PPUSH
25572: LD_INT 21
25574: PUSH
25575: LD_INT 3
25577: PUSH
25578: EMPTY
25579: LIST
25580: LIST
25581: PUSH
25582: LD_INT 3
25584: PUSH
25585: LD_INT 24
25587: PUSH
25588: LD_INT 1000
25590: PUSH
25591: EMPTY
25592: LIST
25593: LIST
25594: PUSH
25595: EMPTY
25596: LIST
25597: LIST
25598: PUSH
25599: EMPTY
25600: LIST
25601: LIST
25602: PPUSH
25603: CALL_OW 72
25607: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
25608: LD_ADDR_EXP 51
25612: PUSH
25613: LD_EXP 51
25617: PPUSH
25618: LD_VAR 0 2
25622: PPUSH
25623: LD_VAR 0 3
25627: PPUSH
25628: CALL_OW 1
25632: ST_TO_ADDR
// end ;
25633: GO 25553
25635: POP
25636: POP
// RaiseSailEvent ( 101 ) ;
25637: LD_INT 101
25639: PPUSH
25640: CALL_OW 427
// end ;
25644: LD_VAR 0 1
25648: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
25649: LD_INT 0
25651: PPUSH
25652: PPUSH
25653: PPUSH
25654: PPUSH
25655: PPUSH
25656: PPUSH
25657: PPUSH
// if not mc_bases then
25658: LD_EXP 50
25662: NOT
25663: IFFALSE 25667
// exit ;
25665: GO 26240
// for i = 1 to mc_bases do
25667: LD_ADDR_VAR 0 2
25671: PUSH
25672: DOUBLE
25673: LD_INT 1
25675: DEC
25676: ST_TO_ADDR
25677: LD_EXP 50
25681: PUSH
25682: FOR_TO
25683: IFFALSE 26231
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
25685: LD_ADDR_VAR 0 5
25689: PUSH
25690: LD_EXP 50
25694: PUSH
25695: LD_VAR 0 2
25699: ARRAY
25700: PUSH
25701: LD_EXP 79
25705: PUSH
25706: LD_VAR 0 2
25710: ARRAY
25711: UNION
25712: PPUSH
25713: LD_INT 21
25715: PUSH
25716: LD_INT 1
25718: PUSH
25719: EMPTY
25720: LIST
25721: LIST
25722: PUSH
25723: LD_INT 1
25725: PUSH
25726: LD_INT 3
25728: PUSH
25729: LD_INT 54
25731: PUSH
25732: EMPTY
25733: LIST
25734: PUSH
25735: EMPTY
25736: LIST
25737: LIST
25738: PUSH
25739: LD_INT 3
25741: PUSH
25742: LD_INT 24
25744: PUSH
25745: LD_INT 800
25747: PUSH
25748: EMPTY
25749: LIST
25750: LIST
25751: PUSH
25752: EMPTY
25753: LIST
25754: LIST
25755: PUSH
25756: EMPTY
25757: LIST
25758: LIST
25759: LIST
25760: PUSH
25761: EMPTY
25762: LIST
25763: LIST
25764: PPUSH
25765: CALL_OW 72
25769: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
25770: LD_ADDR_VAR 0 6
25774: PUSH
25775: LD_EXP 50
25779: PUSH
25780: LD_VAR 0 2
25784: ARRAY
25785: PPUSH
25786: LD_INT 21
25788: PUSH
25789: LD_INT 1
25791: PUSH
25792: EMPTY
25793: LIST
25794: LIST
25795: PUSH
25796: LD_INT 1
25798: PUSH
25799: LD_INT 3
25801: PUSH
25802: LD_INT 54
25804: PUSH
25805: EMPTY
25806: LIST
25807: PUSH
25808: EMPTY
25809: LIST
25810: LIST
25811: PUSH
25812: LD_INT 3
25814: PUSH
25815: LD_INT 24
25817: PUSH
25818: LD_INT 250
25820: PUSH
25821: EMPTY
25822: LIST
25823: LIST
25824: PUSH
25825: EMPTY
25826: LIST
25827: LIST
25828: PUSH
25829: EMPTY
25830: LIST
25831: LIST
25832: LIST
25833: PUSH
25834: EMPTY
25835: LIST
25836: LIST
25837: PPUSH
25838: CALL_OW 72
25842: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
25843: LD_ADDR_VAR 0 7
25847: PUSH
25848: LD_VAR 0 5
25852: PUSH
25853: LD_VAR 0 6
25857: DIFF
25858: ST_TO_ADDR
// if not need_heal_1 then
25859: LD_VAR 0 6
25863: NOT
25864: IFFALSE 25897
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
25866: LD_ADDR_EXP 53
25870: PUSH
25871: LD_EXP 53
25875: PPUSH
25876: LD_VAR 0 2
25880: PUSH
25881: LD_INT 1
25883: PUSH
25884: EMPTY
25885: LIST
25886: LIST
25887: PPUSH
25888: EMPTY
25889: PPUSH
25890: CALL 54555 0 3
25894: ST_TO_ADDR
25895: GO 25967
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
25897: LD_ADDR_EXP 53
25901: PUSH
25902: LD_EXP 53
25906: PPUSH
25907: LD_VAR 0 2
25911: PUSH
25912: LD_INT 1
25914: PUSH
25915: EMPTY
25916: LIST
25917: LIST
25918: PPUSH
25919: LD_EXP 53
25923: PUSH
25924: LD_VAR 0 2
25928: ARRAY
25929: PUSH
25930: LD_INT 1
25932: ARRAY
25933: PPUSH
25934: LD_INT 3
25936: PUSH
25937: LD_INT 24
25939: PUSH
25940: LD_INT 1000
25942: PUSH
25943: EMPTY
25944: LIST
25945: LIST
25946: PUSH
25947: EMPTY
25948: LIST
25949: LIST
25950: PPUSH
25951: CALL_OW 72
25955: PUSH
25956: LD_VAR 0 6
25960: UNION
25961: PPUSH
25962: CALL 54555 0 3
25966: ST_TO_ADDR
// if not need_heal_2 then
25967: LD_VAR 0 7
25971: NOT
25972: IFFALSE 26005
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
25974: LD_ADDR_EXP 53
25978: PUSH
25979: LD_EXP 53
25983: PPUSH
25984: LD_VAR 0 2
25988: PUSH
25989: LD_INT 2
25991: PUSH
25992: EMPTY
25993: LIST
25994: LIST
25995: PPUSH
25996: EMPTY
25997: PPUSH
25998: CALL 54555 0 3
26002: ST_TO_ADDR
26003: GO 26037
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
26005: LD_ADDR_EXP 53
26009: PUSH
26010: LD_EXP 53
26014: PPUSH
26015: LD_VAR 0 2
26019: PUSH
26020: LD_INT 2
26022: PUSH
26023: EMPTY
26024: LIST
26025: LIST
26026: PPUSH
26027: LD_VAR 0 7
26031: PPUSH
26032: CALL 54555 0 3
26036: ST_TO_ADDR
// if need_heal_2 then
26037: LD_VAR 0 7
26041: IFFALSE 26213
// for j in need_heal_2 do
26043: LD_ADDR_VAR 0 3
26047: PUSH
26048: LD_VAR 0 7
26052: PUSH
26053: FOR_IN
26054: IFFALSE 26211
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
26056: LD_ADDR_VAR 0 5
26060: PUSH
26061: LD_EXP 50
26065: PUSH
26066: LD_VAR 0 2
26070: ARRAY
26071: PPUSH
26072: LD_INT 2
26074: PUSH
26075: LD_INT 30
26077: PUSH
26078: LD_INT 6
26080: PUSH
26081: EMPTY
26082: LIST
26083: LIST
26084: PUSH
26085: LD_INT 30
26087: PUSH
26088: LD_INT 7
26090: PUSH
26091: EMPTY
26092: LIST
26093: LIST
26094: PUSH
26095: LD_INT 30
26097: PUSH
26098: LD_INT 8
26100: PUSH
26101: EMPTY
26102: LIST
26103: LIST
26104: PUSH
26105: LD_INT 30
26107: PUSH
26108: LD_INT 0
26110: PUSH
26111: EMPTY
26112: LIST
26113: LIST
26114: PUSH
26115: LD_INT 30
26117: PUSH
26118: LD_INT 1
26120: PUSH
26121: EMPTY
26122: LIST
26123: LIST
26124: PUSH
26125: LD_INT 25
26127: PUSH
26128: LD_INT 4
26130: PUSH
26131: EMPTY
26132: LIST
26133: LIST
26134: PUSH
26135: EMPTY
26136: LIST
26137: LIST
26138: LIST
26139: LIST
26140: LIST
26141: LIST
26142: LIST
26143: PPUSH
26144: CALL_OW 72
26148: ST_TO_ADDR
// if tmp then
26149: LD_VAR 0 5
26153: IFFALSE 26209
// begin k := NearestUnitToUnit ( tmp , j ) ;
26155: LD_ADDR_VAR 0 4
26159: PUSH
26160: LD_VAR 0 5
26164: PPUSH
26165: LD_VAR 0 3
26169: PPUSH
26170: CALL_OW 74
26174: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
26175: LD_VAR 0 3
26179: PPUSH
26180: LD_VAR 0 4
26184: PPUSH
26185: CALL_OW 296
26189: PUSH
26190: LD_INT 7
26192: GREATER
26193: IFFALSE 26209
// ComMoveUnit ( j , k ) ;
26195: LD_VAR 0 3
26199: PPUSH
26200: LD_VAR 0 4
26204: PPUSH
26205: CALL_OW 112
// end ; end ;
26209: GO 26053
26211: POP
26212: POP
// if not need_heal_1 and not need_heal_2 then
26213: LD_VAR 0 6
26217: NOT
26218: PUSH
26219: LD_VAR 0 7
26223: NOT
26224: AND
26225: IFFALSE 26229
// continue ;
26227: GO 25682
// end ;
26229: GO 25682
26231: POP
26232: POP
// RaiseSailEvent ( 102 ) ;
26233: LD_INT 102
26235: PPUSH
26236: CALL_OW 427
// end ;
26240: LD_VAR 0 1
26244: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
26245: LD_INT 0
26247: PPUSH
26248: PPUSH
26249: PPUSH
26250: PPUSH
26251: PPUSH
26252: PPUSH
26253: PPUSH
26254: PPUSH
// if not mc_bases then
26255: LD_EXP 50
26259: NOT
26260: IFFALSE 26264
// exit ;
26262: GO 27104
// for i = 1 to mc_bases do
26264: LD_ADDR_VAR 0 2
26268: PUSH
26269: DOUBLE
26270: LD_INT 1
26272: DEC
26273: ST_TO_ADDR
26274: LD_EXP 50
26278: PUSH
26279: FOR_TO
26280: IFFALSE 27102
// begin if not mc_building_need_repair [ i ] then
26282: LD_EXP 51
26286: PUSH
26287: LD_VAR 0 2
26291: ARRAY
26292: NOT
26293: IFFALSE 26467
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
26295: LD_ADDR_VAR 0 6
26299: PUSH
26300: LD_EXP 69
26304: PUSH
26305: LD_VAR 0 2
26309: ARRAY
26310: PPUSH
26311: LD_INT 3
26313: PUSH
26314: LD_INT 24
26316: PUSH
26317: LD_INT 1000
26319: PUSH
26320: EMPTY
26321: LIST
26322: LIST
26323: PUSH
26324: EMPTY
26325: LIST
26326: LIST
26327: PUSH
26328: LD_INT 2
26330: PUSH
26331: LD_INT 34
26333: PUSH
26334: LD_INT 13
26336: PUSH
26337: EMPTY
26338: LIST
26339: LIST
26340: PUSH
26341: LD_INT 34
26343: PUSH
26344: LD_INT 52
26346: PUSH
26347: EMPTY
26348: LIST
26349: LIST
26350: PUSH
26351: EMPTY
26352: LIST
26353: LIST
26354: LIST
26355: PUSH
26356: EMPTY
26357: LIST
26358: LIST
26359: PPUSH
26360: CALL_OW 72
26364: ST_TO_ADDR
// if cranes then
26365: LD_VAR 0 6
26369: IFFALSE 26431
// for j in cranes do
26371: LD_ADDR_VAR 0 3
26375: PUSH
26376: LD_VAR 0 6
26380: PUSH
26381: FOR_IN
26382: IFFALSE 26429
// if not IsInArea ( j , mc_parking [ i ] ) then
26384: LD_VAR 0 3
26388: PPUSH
26389: LD_EXP 74
26393: PUSH
26394: LD_VAR 0 2
26398: ARRAY
26399: PPUSH
26400: CALL_OW 308
26404: NOT
26405: IFFALSE 26427
// ComMoveToArea ( j , mc_parking [ i ] ) ;
26407: LD_VAR 0 3
26411: PPUSH
26412: LD_EXP 74
26416: PUSH
26417: LD_VAR 0 2
26421: ARRAY
26422: PPUSH
26423: CALL_OW 113
26427: GO 26381
26429: POP
26430: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
26431: LD_ADDR_EXP 52
26435: PUSH
26436: LD_EXP 52
26440: PPUSH
26441: LD_VAR 0 2
26445: PPUSH
26446: EMPTY
26447: PPUSH
26448: CALL_OW 1
26452: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
26453: LD_VAR 0 2
26457: PPUSH
26458: LD_INT 101
26460: PPUSH
26461: CALL 21357 0 2
// continue ;
26465: GO 26279
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
26467: LD_ADDR_EXP 56
26471: PUSH
26472: LD_EXP 56
26476: PPUSH
26477: LD_VAR 0 2
26481: PPUSH
26482: EMPTY
26483: PPUSH
26484: CALL_OW 1
26488: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
26489: LD_VAR 0 2
26493: PPUSH
26494: LD_INT 103
26496: PPUSH
26497: CALL 21357 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
26501: LD_ADDR_VAR 0 5
26505: PUSH
26506: LD_EXP 50
26510: PUSH
26511: LD_VAR 0 2
26515: ARRAY
26516: PUSH
26517: LD_EXP 79
26521: PUSH
26522: LD_VAR 0 2
26526: ARRAY
26527: UNION
26528: PPUSH
26529: LD_INT 2
26531: PUSH
26532: LD_INT 25
26534: PUSH
26535: LD_INT 2
26537: PUSH
26538: EMPTY
26539: LIST
26540: LIST
26541: PUSH
26542: LD_INT 25
26544: PUSH
26545: LD_INT 16
26547: PUSH
26548: EMPTY
26549: LIST
26550: LIST
26551: PUSH
26552: EMPTY
26553: LIST
26554: LIST
26555: LIST
26556: PUSH
26557: EMPTY
26558: LIST
26559: PPUSH
26560: CALL_OW 72
26564: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
26565: LD_ADDR_VAR 0 6
26569: PUSH
26570: LD_EXP 69
26574: PUSH
26575: LD_VAR 0 2
26579: ARRAY
26580: PPUSH
26581: LD_INT 2
26583: PUSH
26584: LD_INT 34
26586: PUSH
26587: LD_INT 13
26589: PUSH
26590: EMPTY
26591: LIST
26592: LIST
26593: PUSH
26594: LD_INT 34
26596: PUSH
26597: LD_INT 52
26599: PUSH
26600: EMPTY
26601: LIST
26602: LIST
26603: PUSH
26604: EMPTY
26605: LIST
26606: LIST
26607: LIST
26608: PPUSH
26609: CALL_OW 72
26613: ST_TO_ADDR
// if cranes then
26614: LD_VAR 0 6
26618: IFFALSE 26754
// begin for j in cranes do
26620: LD_ADDR_VAR 0 3
26624: PUSH
26625: LD_VAR 0 6
26629: PUSH
26630: FOR_IN
26631: IFFALSE 26752
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
26633: LD_VAR 0 3
26637: PPUSH
26638: CALL_OW 256
26642: PUSH
26643: LD_INT 500
26645: GREATEREQUAL
26646: PUSH
26647: LD_VAR 0 3
26651: PPUSH
26652: CALL_OW 314
26656: NOT
26657: AND
26658: IFFALSE 26692
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
26660: LD_VAR 0 3
26664: PPUSH
26665: LD_EXP 51
26669: PUSH
26670: LD_VAR 0 2
26674: ARRAY
26675: PPUSH
26676: LD_VAR 0 3
26680: PPUSH
26681: CALL_OW 74
26685: PPUSH
26686: CALL_OW 130
26690: GO 26750
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
26692: LD_VAR 0 3
26696: PPUSH
26697: CALL_OW 256
26701: PUSH
26702: LD_INT 500
26704: LESS
26705: PUSH
26706: LD_VAR 0 3
26710: PPUSH
26711: LD_EXP 74
26715: PUSH
26716: LD_VAR 0 2
26720: ARRAY
26721: PPUSH
26722: CALL_OW 308
26726: NOT
26727: AND
26728: IFFALSE 26750
// ComMoveToArea ( j , mc_parking [ i ] ) ;
26730: LD_VAR 0 3
26734: PPUSH
26735: LD_EXP 74
26739: PUSH
26740: LD_VAR 0 2
26744: ARRAY
26745: PPUSH
26746: CALL_OW 113
26750: GO 26630
26752: POP
26753: POP
// end ; if not tmp then
26754: LD_VAR 0 5
26758: NOT
26759: IFFALSE 26763
// continue ;
26761: GO 26279
// for j in tmp do
26763: LD_ADDR_VAR 0 3
26767: PUSH
26768: LD_VAR 0 5
26772: PUSH
26773: FOR_IN
26774: IFFALSE 27098
// begin if mc_need_heal [ i ] then
26776: LD_EXP 53
26780: PUSH
26781: LD_VAR 0 2
26785: ARRAY
26786: IFFALSE 26834
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
26788: LD_VAR 0 3
26792: PUSH
26793: LD_EXP 53
26797: PUSH
26798: LD_VAR 0 2
26802: ARRAY
26803: PUSH
26804: LD_INT 1
26806: ARRAY
26807: IN
26808: PUSH
26809: LD_VAR 0 3
26813: PUSH
26814: LD_EXP 53
26818: PUSH
26819: LD_VAR 0 2
26823: ARRAY
26824: PUSH
26825: LD_INT 2
26827: ARRAY
26828: IN
26829: OR
26830: IFFALSE 26834
// continue ;
26832: GO 26773
// if IsInUnit ( j ) then
26834: LD_VAR 0 3
26838: PPUSH
26839: CALL_OW 310
26843: IFFALSE 26854
// ComExitBuilding ( j ) ;
26845: LD_VAR 0 3
26849: PPUSH
26850: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
26854: LD_VAR 0 3
26858: PUSH
26859: LD_EXP 52
26863: PUSH
26864: LD_VAR 0 2
26868: ARRAY
26869: IN
26870: NOT
26871: IFFALSE 26929
// begin SetTag ( j , 101 ) ;
26873: LD_VAR 0 3
26877: PPUSH
26878: LD_INT 101
26880: PPUSH
26881: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
26885: LD_ADDR_EXP 52
26889: PUSH
26890: LD_EXP 52
26894: PPUSH
26895: LD_VAR 0 2
26899: PUSH
26900: LD_EXP 52
26904: PUSH
26905: LD_VAR 0 2
26909: ARRAY
26910: PUSH
26911: LD_INT 1
26913: PLUS
26914: PUSH
26915: EMPTY
26916: LIST
26917: LIST
26918: PPUSH
26919: LD_VAR 0 3
26923: PPUSH
26924: CALL 54555 0 3
26928: ST_TO_ADDR
// end ; wait ( 1 ) ;
26929: LD_INT 1
26931: PPUSH
26932: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
26936: LD_ADDR_VAR 0 7
26940: PUSH
26941: LD_EXP 51
26945: PUSH
26946: LD_VAR 0 2
26950: ARRAY
26951: ST_TO_ADDR
// if mc_scan [ i ] then
26952: LD_EXP 73
26956: PUSH
26957: LD_VAR 0 2
26961: ARRAY
26962: IFFALSE 27031
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ] ) ;
26964: LD_ADDR_VAR 0 7
26968: PUSH
26969: LD_EXP 51
26973: PUSH
26974: LD_VAR 0 2
26978: ARRAY
26979: PPUSH
26980: LD_INT 3
26982: PUSH
26983: LD_INT 2
26985: PUSH
26986: LD_INT 30
26988: PUSH
26989: LD_INT 32
26991: PUSH
26992: EMPTY
26993: LIST
26994: LIST
26995: PUSH
26996: LD_INT 30
26998: PUSH
26999: LD_INT 33
27001: PUSH
27002: EMPTY
27003: LIST
27004: LIST
27005: PUSH
27006: LD_INT 30
27008: PUSH
27009: LD_INT 31
27011: PUSH
27012: EMPTY
27013: LIST
27014: LIST
27015: PUSH
27016: EMPTY
27017: LIST
27018: LIST
27019: LIST
27020: LIST
27021: PUSH
27022: EMPTY
27023: LIST
27024: LIST
27025: PPUSH
27026: CALL_OW 72
27030: ST_TO_ADDR
// if not to_repair_tmp then
27031: LD_VAR 0 7
27035: NOT
27036: IFFALSE 27040
// continue ;
27038: GO 26773
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
27040: LD_ADDR_VAR 0 8
27044: PUSH
27045: LD_VAR 0 7
27049: PPUSH
27050: LD_VAR 0 3
27054: PPUSH
27055: CALL_OW 74
27059: ST_TO_ADDR
// if DangerAtRange ( to_repair , 14 ) [ 4 ] < 5 then
27060: LD_VAR 0 8
27064: PPUSH
27065: LD_INT 14
27067: PPUSH
27068: CALL 57148 0 2
27072: PUSH
27073: LD_INT 4
27075: ARRAY
27076: PUSH
27077: LD_INT 5
27079: LESS
27080: IFFALSE 27096
// ComRepairBuilding ( j , to_repair ) ;
27082: LD_VAR 0 3
27086: PPUSH
27087: LD_VAR 0 8
27091: PPUSH
27092: CALL_OW 130
// end ;
27096: GO 26773
27098: POP
27099: POP
// end ;
27100: GO 26279
27102: POP
27103: POP
// end ;
27104: LD_VAR 0 1
27108: RET
// export function MC_Heal ; var i , j , tmp ; begin
27109: LD_INT 0
27111: PPUSH
27112: PPUSH
27113: PPUSH
27114: PPUSH
// if not mc_bases then
27115: LD_EXP 50
27119: NOT
27120: IFFALSE 27124
// exit ;
27122: GO 27526
// for i = 1 to mc_bases do
27124: LD_ADDR_VAR 0 2
27128: PUSH
27129: DOUBLE
27130: LD_INT 1
27132: DEC
27133: ST_TO_ADDR
27134: LD_EXP 50
27138: PUSH
27139: FOR_TO
27140: IFFALSE 27524
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
27142: LD_EXP 53
27146: PUSH
27147: LD_VAR 0 2
27151: ARRAY
27152: PUSH
27153: LD_INT 1
27155: ARRAY
27156: NOT
27157: PUSH
27158: LD_EXP 53
27162: PUSH
27163: LD_VAR 0 2
27167: ARRAY
27168: PUSH
27169: LD_INT 2
27171: ARRAY
27172: NOT
27173: AND
27174: IFFALSE 27212
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
27176: LD_ADDR_EXP 54
27180: PUSH
27181: LD_EXP 54
27185: PPUSH
27186: LD_VAR 0 2
27190: PPUSH
27191: EMPTY
27192: PPUSH
27193: CALL_OW 1
27197: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
27198: LD_VAR 0 2
27202: PPUSH
27203: LD_INT 102
27205: PPUSH
27206: CALL 21357 0 2
// continue ;
27210: GO 27139
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
27212: LD_ADDR_VAR 0 4
27216: PUSH
27217: LD_EXP 50
27221: PUSH
27222: LD_VAR 0 2
27226: ARRAY
27227: PPUSH
27228: LD_INT 25
27230: PUSH
27231: LD_INT 4
27233: PUSH
27234: EMPTY
27235: LIST
27236: LIST
27237: PPUSH
27238: CALL_OW 72
27242: ST_TO_ADDR
// if not tmp then
27243: LD_VAR 0 4
27247: NOT
27248: IFFALSE 27252
// continue ;
27250: GO 27139
// if mc_taming [ i ] then
27252: LD_EXP 81
27256: PUSH
27257: LD_VAR 0 2
27261: ARRAY
27262: IFFALSE 27286
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
27264: LD_ADDR_EXP 81
27268: PUSH
27269: LD_EXP 81
27273: PPUSH
27274: LD_VAR 0 2
27278: PPUSH
27279: EMPTY
27280: PPUSH
27281: CALL_OW 1
27285: ST_TO_ADDR
// for j in tmp do
27286: LD_ADDR_VAR 0 3
27290: PUSH
27291: LD_VAR 0 4
27295: PUSH
27296: FOR_IN
27297: IFFALSE 27520
// begin if IsInUnit ( j ) then
27299: LD_VAR 0 3
27303: PPUSH
27304: CALL_OW 310
27308: IFFALSE 27319
// ComExitBuilding ( j ) ;
27310: LD_VAR 0 3
27314: PPUSH
27315: CALL_OW 122
// if not j in mc_healers [ i ] then
27319: LD_VAR 0 3
27323: PUSH
27324: LD_EXP 54
27328: PUSH
27329: LD_VAR 0 2
27333: ARRAY
27334: IN
27335: NOT
27336: IFFALSE 27382
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
27338: LD_ADDR_EXP 54
27342: PUSH
27343: LD_EXP 54
27347: PPUSH
27348: LD_VAR 0 2
27352: PUSH
27353: LD_EXP 54
27357: PUSH
27358: LD_VAR 0 2
27362: ARRAY
27363: PUSH
27364: LD_INT 1
27366: PLUS
27367: PUSH
27368: EMPTY
27369: LIST
27370: LIST
27371: PPUSH
27372: LD_VAR 0 3
27376: PPUSH
27377: CALL 54555 0 3
27381: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
27382: LD_VAR 0 3
27386: PPUSH
27387: CALL_OW 110
27391: PUSH
27392: LD_INT 102
27394: NONEQUAL
27395: IFFALSE 27409
// SetTag ( j , 102 ) ;
27397: LD_VAR 0 3
27401: PPUSH
27402: LD_INT 102
27404: PPUSH
27405: CALL_OW 109
// Wait ( 3 ) ;
27409: LD_INT 3
27411: PPUSH
27412: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
27416: LD_EXP 53
27420: PUSH
27421: LD_VAR 0 2
27425: ARRAY
27426: PUSH
27427: LD_INT 1
27429: ARRAY
27430: IFFALSE 27462
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
27432: LD_VAR 0 3
27436: PPUSH
27437: LD_EXP 53
27441: PUSH
27442: LD_VAR 0 2
27446: ARRAY
27447: PUSH
27448: LD_INT 1
27450: ARRAY
27451: PUSH
27452: LD_INT 1
27454: ARRAY
27455: PPUSH
27456: CALL_OW 128
27460: GO 27518
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
27462: LD_VAR 0 3
27466: PPUSH
27467: CALL_OW 314
27471: NOT
27472: PUSH
27473: LD_EXP 53
27477: PUSH
27478: LD_VAR 0 2
27482: ARRAY
27483: PUSH
27484: LD_INT 2
27486: ARRAY
27487: AND
27488: IFFALSE 27518
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
27490: LD_VAR 0 3
27494: PPUSH
27495: LD_EXP 53
27499: PUSH
27500: LD_VAR 0 2
27504: ARRAY
27505: PUSH
27506: LD_INT 2
27508: ARRAY
27509: PUSH
27510: LD_INT 1
27512: ARRAY
27513: PPUSH
27514: CALL_OW 128
// end ;
27518: GO 27296
27520: POP
27521: POP
// end ;
27522: GO 27139
27524: POP
27525: POP
// end ;
27526: LD_VAR 0 1
27530: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
27531: LD_INT 0
27533: PPUSH
27534: PPUSH
27535: PPUSH
27536: PPUSH
27537: PPUSH
// if not mc_bases then
27538: LD_EXP 50
27542: NOT
27543: IFFALSE 27547
// exit ;
27545: GO 28690
// for i = 1 to mc_bases do
27547: LD_ADDR_VAR 0 2
27551: PUSH
27552: DOUBLE
27553: LD_INT 1
27555: DEC
27556: ST_TO_ADDR
27557: LD_EXP 50
27561: PUSH
27562: FOR_TO
27563: IFFALSE 28688
// begin if mc_scan [ i ] then
27565: LD_EXP 73
27569: PUSH
27570: LD_VAR 0 2
27574: ARRAY
27575: IFFALSE 27579
// continue ;
27577: GO 27562
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
27579: LD_EXP 55
27583: PUSH
27584: LD_VAR 0 2
27588: ARRAY
27589: NOT
27590: PUSH
27591: LD_EXP 57
27595: PUSH
27596: LD_VAR 0 2
27600: ARRAY
27601: NOT
27602: AND
27603: PUSH
27604: LD_EXP 56
27608: PUSH
27609: LD_VAR 0 2
27613: ARRAY
27614: AND
27615: IFFALSE 27653
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
27617: LD_ADDR_EXP 56
27621: PUSH
27622: LD_EXP 56
27626: PPUSH
27627: LD_VAR 0 2
27631: PPUSH
27632: EMPTY
27633: PPUSH
27634: CALL_OW 1
27638: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
27639: LD_VAR 0 2
27643: PPUSH
27644: LD_INT 103
27646: PPUSH
27647: CALL 21357 0 2
// continue ;
27651: GO 27562
// end ; if mc_construct_list [ i ] then
27653: LD_EXP 57
27657: PUSH
27658: LD_VAR 0 2
27662: ARRAY
27663: IFFALSE 27883
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
27665: LD_ADDR_VAR 0 4
27669: PUSH
27670: LD_EXP 50
27674: PUSH
27675: LD_VAR 0 2
27679: ARRAY
27680: PPUSH
27681: LD_INT 25
27683: PUSH
27684: LD_INT 2
27686: PUSH
27687: EMPTY
27688: LIST
27689: LIST
27690: PPUSH
27691: CALL_OW 72
27695: PUSH
27696: LD_EXP 52
27700: PUSH
27701: LD_VAR 0 2
27705: ARRAY
27706: DIFF
27707: ST_TO_ADDR
// if not tmp then
27708: LD_VAR 0 4
27712: NOT
27713: IFFALSE 27717
// continue ;
27715: GO 27562
// for j in tmp do
27717: LD_ADDR_VAR 0 3
27721: PUSH
27722: LD_VAR 0 4
27726: PUSH
27727: FOR_IN
27728: IFFALSE 27879
// begin if not mc_builders [ i ] then
27730: LD_EXP 56
27734: PUSH
27735: LD_VAR 0 2
27739: ARRAY
27740: NOT
27741: IFFALSE 27799
// begin SetTag ( j , 103 ) ;
27743: LD_VAR 0 3
27747: PPUSH
27748: LD_INT 103
27750: PPUSH
27751: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
27755: LD_ADDR_EXP 56
27759: PUSH
27760: LD_EXP 56
27764: PPUSH
27765: LD_VAR 0 2
27769: PUSH
27770: LD_EXP 56
27774: PUSH
27775: LD_VAR 0 2
27779: ARRAY
27780: PUSH
27781: LD_INT 1
27783: PLUS
27784: PUSH
27785: EMPTY
27786: LIST
27787: LIST
27788: PPUSH
27789: LD_VAR 0 3
27793: PPUSH
27794: CALL 54555 0 3
27798: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
27799: LD_VAR 0 3
27803: PPUSH
27804: CALL_OW 310
27808: IFFALSE 27819
// ComExitBuilding ( j ) ;
27810: LD_VAR 0 3
27814: PPUSH
27815: CALL_OW 122
// wait ( 3 ) ;
27819: LD_INT 3
27821: PPUSH
27822: CALL_OW 67
// if not mc_construct_list [ i ] then
27826: LD_EXP 57
27830: PUSH
27831: LD_VAR 0 2
27835: ARRAY
27836: NOT
27837: IFFALSE 27841
// break ;
27839: GO 27879
// if not HasTask ( j ) then
27841: LD_VAR 0 3
27845: PPUSH
27846: CALL_OW 314
27850: NOT
27851: IFFALSE 27877
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
27853: LD_VAR 0 3
27857: PPUSH
27858: LD_EXP 57
27862: PUSH
27863: LD_VAR 0 2
27867: ARRAY
27868: PUSH
27869: LD_INT 1
27871: ARRAY
27872: PPUSH
27873: CALL 57406 0 2
// end ;
27877: GO 27727
27879: POP
27880: POP
// end else
27881: GO 28686
// if mc_build_list [ i ] then
27883: LD_EXP 55
27887: PUSH
27888: LD_VAR 0 2
27892: ARRAY
27893: IFFALSE 28686
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
27895: LD_ADDR_VAR 0 5
27899: PUSH
27900: LD_EXP 50
27904: PUSH
27905: LD_VAR 0 2
27909: ARRAY
27910: PPUSH
27911: LD_INT 2
27913: PUSH
27914: LD_INT 30
27916: PUSH
27917: LD_INT 0
27919: PUSH
27920: EMPTY
27921: LIST
27922: LIST
27923: PUSH
27924: LD_INT 30
27926: PUSH
27927: LD_INT 1
27929: PUSH
27930: EMPTY
27931: LIST
27932: LIST
27933: PUSH
27934: EMPTY
27935: LIST
27936: LIST
27937: LIST
27938: PPUSH
27939: CALL_OW 72
27943: ST_TO_ADDR
// if depot then
27944: LD_VAR 0 5
27948: IFFALSE 27966
// depot := depot [ 1 ] else
27950: LD_ADDR_VAR 0 5
27954: PUSH
27955: LD_VAR 0 5
27959: PUSH
27960: LD_INT 1
27962: ARRAY
27963: ST_TO_ADDR
27964: GO 27974
// depot := 0 ;
27966: LD_ADDR_VAR 0 5
27970: PUSH
27971: LD_INT 0
27973: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
27974: LD_EXP 55
27978: PUSH
27979: LD_VAR 0 2
27983: ARRAY
27984: PUSH
27985: LD_INT 1
27987: ARRAY
27988: PUSH
27989: LD_INT 1
27991: ARRAY
27992: PPUSH
27993: CALL 57236 0 1
27997: PUSH
27998: LD_EXP 50
28002: PUSH
28003: LD_VAR 0 2
28007: ARRAY
28008: PPUSH
28009: LD_INT 2
28011: PUSH
28012: LD_INT 30
28014: PUSH
28015: LD_INT 2
28017: PUSH
28018: EMPTY
28019: LIST
28020: LIST
28021: PUSH
28022: LD_INT 30
28024: PUSH
28025: LD_INT 3
28027: PUSH
28028: EMPTY
28029: LIST
28030: LIST
28031: PUSH
28032: EMPTY
28033: LIST
28034: LIST
28035: LIST
28036: PPUSH
28037: CALL_OW 72
28041: NOT
28042: AND
28043: IFFALSE 28148
// begin for j = 1 to mc_build_list [ i ] do
28045: LD_ADDR_VAR 0 3
28049: PUSH
28050: DOUBLE
28051: LD_INT 1
28053: DEC
28054: ST_TO_ADDR
28055: LD_EXP 55
28059: PUSH
28060: LD_VAR 0 2
28064: ARRAY
28065: PUSH
28066: FOR_TO
28067: IFFALSE 28146
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
28069: LD_EXP 55
28073: PUSH
28074: LD_VAR 0 2
28078: ARRAY
28079: PUSH
28080: LD_VAR 0 3
28084: ARRAY
28085: PUSH
28086: LD_INT 1
28088: ARRAY
28089: PUSH
28090: LD_INT 2
28092: EQUAL
28093: IFFALSE 28144
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
28095: LD_ADDR_EXP 55
28099: PUSH
28100: LD_EXP 55
28104: PPUSH
28105: LD_VAR 0 2
28109: PPUSH
28110: LD_EXP 55
28114: PUSH
28115: LD_VAR 0 2
28119: ARRAY
28120: PPUSH
28121: LD_VAR 0 3
28125: PPUSH
28126: LD_INT 1
28128: PPUSH
28129: LD_INT 0
28131: PPUSH
28132: CALL 53973 0 4
28136: PPUSH
28137: CALL_OW 1
28141: ST_TO_ADDR
// break ;
28142: GO 28146
// end ;
28144: GO 28066
28146: POP
28147: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
28148: LD_EXP 55
28152: PUSH
28153: LD_VAR 0 2
28157: ARRAY
28158: PUSH
28159: LD_INT 1
28161: ARRAY
28162: PUSH
28163: LD_INT 1
28165: ARRAY
28166: PUSH
28167: LD_INT 0
28169: EQUAL
28170: PUSH
28171: LD_VAR 0 5
28175: PUSH
28176: LD_VAR 0 5
28180: PPUSH
28181: LD_EXP 55
28185: PUSH
28186: LD_VAR 0 2
28190: ARRAY
28191: PUSH
28192: LD_INT 1
28194: ARRAY
28195: PUSH
28196: LD_INT 1
28198: ARRAY
28199: PPUSH
28200: LD_EXP 55
28204: PUSH
28205: LD_VAR 0 2
28209: ARRAY
28210: PUSH
28211: LD_INT 1
28213: ARRAY
28214: PUSH
28215: LD_INT 2
28217: ARRAY
28218: PPUSH
28219: LD_EXP 55
28223: PUSH
28224: LD_VAR 0 2
28228: ARRAY
28229: PUSH
28230: LD_INT 1
28232: ARRAY
28233: PUSH
28234: LD_INT 3
28236: ARRAY
28237: PPUSH
28238: LD_EXP 55
28242: PUSH
28243: LD_VAR 0 2
28247: ARRAY
28248: PUSH
28249: LD_INT 1
28251: ARRAY
28252: PUSH
28253: LD_INT 4
28255: ARRAY
28256: PPUSH
28257: CALL 61970 0 5
28261: AND
28262: OR
28263: IFFALSE 28544
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
28265: LD_ADDR_VAR 0 4
28269: PUSH
28270: LD_EXP 50
28274: PUSH
28275: LD_VAR 0 2
28279: ARRAY
28280: PPUSH
28281: LD_INT 25
28283: PUSH
28284: LD_INT 2
28286: PUSH
28287: EMPTY
28288: LIST
28289: LIST
28290: PPUSH
28291: CALL_OW 72
28295: PUSH
28296: LD_EXP 52
28300: PUSH
28301: LD_VAR 0 2
28305: ARRAY
28306: DIFF
28307: ST_TO_ADDR
// if not tmp then
28308: LD_VAR 0 4
28312: NOT
28313: IFFALSE 28317
// continue ;
28315: GO 27562
// for j in tmp do
28317: LD_ADDR_VAR 0 3
28321: PUSH
28322: LD_VAR 0 4
28326: PUSH
28327: FOR_IN
28328: IFFALSE 28540
// begin if not mc_builders [ i ] then
28330: LD_EXP 56
28334: PUSH
28335: LD_VAR 0 2
28339: ARRAY
28340: NOT
28341: IFFALSE 28399
// begin SetTag ( j , 103 ) ;
28343: LD_VAR 0 3
28347: PPUSH
28348: LD_INT 103
28350: PPUSH
28351: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
28355: LD_ADDR_EXP 56
28359: PUSH
28360: LD_EXP 56
28364: PPUSH
28365: LD_VAR 0 2
28369: PUSH
28370: LD_EXP 56
28374: PUSH
28375: LD_VAR 0 2
28379: ARRAY
28380: PUSH
28381: LD_INT 1
28383: PLUS
28384: PUSH
28385: EMPTY
28386: LIST
28387: LIST
28388: PPUSH
28389: LD_VAR 0 3
28393: PPUSH
28394: CALL 54555 0 3
28398: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
28399: LD_VAR 0 3
28403: PPUSH
28404: CALL_OW 310
28408: IFFALSE 28419
// ComExitBuilding ( j ) ;
28410: LD_VAR 0 3
28414: PPUSH
28415: CALL_OW 122
// wait ( 3 ) ;
28419: LD_INT 3
28421: PPUSH
28422: CALL_OW 67
// if not mc_build_list [ i ] then
28426: LD_EXP 55
28430: PUSH
28431: LD_VAR 0 2
28435: ARRAY
28436: NOT
28437: IFFALSE 28441
// break ;
28439: GO 28540
// if not HasTask ( j ) then
28441: LD_VAR 0 3
28445: PPUSH
28446: CALL_OW 314
28450: NOT
28451: IFFALSE 28538
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
28453: LD_VAR 0 3
28457: PPUSH
28458: LD_EXP 55
28462: PUSH
28463: LD_VAR 0 2
28467: ARRAY
28468: PUSH
28469: LD_INT 1
28471: ARRAY
28472: PUSH
28473: LD_INT 1
28475: ARRAY
28476: PPUSH
28477: LD_EXP 55
28481: PUSH
28482: LD_VAR 0 2
28486: ARRAY
28487: PUSH
28488: LD_INT 1
28490: ARRAY
28491: PUSH
28492: LD_INT 2
28494: ARRAY
28495: PPUSH
28496: LD_EXP 55
28500: PUSH
28501: LD_VAR 0 2
28505: ARRAY
28506: PUSH
28507: LD_INT 1
28509: ARRAY
28510: PUSH
28511: LD_INT 3
28513: ARRAY
28514: PPUSH
28515: LD_EXP 55
28519: PUSH
28520: LD_VAR 0 2
28524: ARRAY
28525: PUSH
28526: LD_INT 1
28528: ARRAY
28529: PUSH
28530: LD_INT 4
28532: ARRAY
28533: PPUSH
28534: CALL_OW 145
// end ;
28538: GO 28327
28540: POP
28541: POP
// end else
28542: GO 28686
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
28544: LD_EXP 50
28548: PUSH
28549: LD_VAR 0 2
28553: ARRAY
28554: PPUSH
28555: LD_EXP 55
28559: PUSH
28560: LD_VAR 0 2
28564: ARRAY
28565: PUSH
28566: LD_INT 1
28568: ARRAY
28569: PUSH
28570: LD_INT 1
28572: ARRAY
28573: PPUSH
28574: LD_EXP 55
28578: PUSH
28579: LD_VAR 0 2
28583: ARRAY
28584: PUSH
28585: LD_INT 1
28587: ARRAY
28588: PUSH
28589: LD_INT 2
28591: ARRAY
28592: PPUSH
28593: LD_EXP 55
28597: PUSH
28598: LD_VAR 0 2
28602: ARRAY
28603: PUSH
28604: LD_INT 1
28606: ARRAY
28607: PUSH
28608: LD_INT 3
28610: ARRAY
28611: PPUSH
28612: LD_EXP 55
28616: PUSH
28617: LD_VAR 0 2
28621: ARRAY
28622: PUSH
28623: LD_INT 1
28625: ARRAY
28626: PUSH
28627: LD_INT 4
28629: ARRAY
28630: PPUSH
28631: CALL 61306 0 5
28635: NOT
28636: IFFALSE 28686
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
28638: LD_ADDR_EXP 55
28642: PUSH
28643: LD_EXP 55
28647: PPUSH
28648: LD_VAR 0 2
28652: PPUSH
28653: LD_EXP 55
28657: PUSH
28658: LD_VAR 0 2
28662: ARRAY
28663: PPUSH
28664: LD_INT 1
28666: PPUSH
28667: LD_INT 1
28669: NEG
28670: PPUSH
28671: LD_INT 0
28673: PPUSH
28674: CALL 53973 0 4
28678: PPUSH
28679: CALL_OW 1
28683: ST_TO_ADDR
// continue ;
28684: GO 27562
// end ; end ; end ;
28686: GO 27562
28688: POP
28689: POP
// end ;
28690: LD_VAR 0 1
28694: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
28695: LD_INT 0
28697: PPUSH
28698: PPUSH
28699: PPUSH
28700: PPUSH
28701: PPUSH
28702: PPUSH
// if not mc_bases then
28703: LD_EXP 50
28707: NOT
28708: IFFALSE 28712
// exit ;
28710: GO 29139
// for i = 1 to mc_bases do
28712: LD_ADDR_VAR 0 2
28716: PUSH
28717: DOUBLE
28718: LD_INT 1
28720: DEC
28721: ST_TO_ADDR
28722: LD_EXP 50
28726: PUSH
28727: FOR_TO
28728: IFFALSE 29137
// begin tmp := mc_build_upgrade [ i ] ;
28730: LD_ADDR_VAR 0 4
28734: PUSH
28735: LD_EXP 82
28739: PUSH
28740: LD_VAR 0 2
28744: ARRAY
28745: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
28746: LD_ADDR_VAR 0 6
28750: PUSH
28751: LD_EXP 83
28755: PUSH
28756: LD_VAR 0 2
28760: ARRAY
28761: PPUSH
28762: LD_INT 2
28764: PUSH
28765: LD_INT 30
28767: PUSH
28768: LD_INT 6
28770: PUSH
28771: EMPTY
28772: LIST
28773: LIST
28774: PUSH
28775: LD_INT 30
28777: PUSH
28778: LD_INT 7
28780: PUSH
28781: EMPTY
28782: LIST
28783: LIST
28784: PUSH
28785: EMPTY
28786: LIST
28787: LIST
28788: LIST
28789: PPUSH
28790: CALL_OW 72
28794: ST_TO_ADDR
// if not tmp and not lab then
28795: LD_VAR 0 4
28799: NOT
28800: PUSH
28801: LD_VAR 0 6
28805: NOT
28806: AND
28807: IFFALSE 28811
// continue ;
28809: GO 28727
// if tmp then
28811: LD_VAR 0 4
28815: IFFALSE 28935
// for j in tmp do
28817: LD_ADDR_VAR 0 3
28821: PUSH
28822: LD_VAR 0 4
28826: PUSH
28827: FOR_IN
28828: IFFALSE 28933
// begin if UpgradeCost ( j ) then
28830: LD_VAR 0 3
28834: PPUSH
28835: CALL 60966 0 1
28839: IFFALSE 28931
// begin ComUpgrade ( j ) ;
28841: LD_VAR 0 3
28845: PPUSH
28846: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
28850: LD_ADDR_EXP 82
28854: PUSH
28855: LD_EXP 82
28859: PPUSH
28860: LD_VAR 0 2
28864: PPUSH
28865: LD_EXP 82
28869: PUSH
28870: LD_VAR 0 2
28874: ARRAY
28875: PUSH
28876: LD_VAR 0 3
28880: DIFF
28881: PPUSH
28882: CALL_OW 1
28886: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
28887: LD_ADDR_EXP 57
28891: PUSH
28892: LD_EXP 57
28896: PPUSH
28897: LD_VAR 0 2
28901: PUSH
28902: LD_EXP 57
28906: PUSH
28907: LD_VAR 0 2
28911: ARRAY
28912: PUSH
28913: LD_INT 1
28915: PLUS
28916: PUSH
28917: EMPTY
28918: LIST
28919: LIST
28920: PPUSH
28921: LD_VAR 0 3
28925: PPUSH
28926: CALL 54555 0 3
28930: ST_TO_ADDR
// end ; end ;
28931: GO 28827
28933: POP
28934: POP
// if not lab or not mc_lab_upgrade [ i ] then
28935: LD_VAR 0 6
28939: NOT
28940: PUSH
28941: LD_EXP 84
28945: PUSH
28946: LD_VAR 0 2
28950: ARRAY
28951: NOT
28952: OR
28953: IFFALSE 28957
// continue ;
28955: GO 28727
// for j in lab do
28957: LD_ADDR_VAR 0 3
28961: PUSH
28962: LD_VAR 0 6
28966: PUSH
28967: FOR_IN
28968: IFFALSE 29133
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
28970: LD_VAR 0 3
28974: PPUSH
28975: CALL_OW 266
28979: PUSH
28980: LD_INT 6
28982: PUSH
28983: LD_INT 7
28985: PUSH
28986: EMPTY
28987: LIST
28988: LIST
28989: IN
28990: PUSH
28991: LD_VAR 0 3
28995: PPUSH
28996: CALL_OW 461
29000: PUSH
29001: LD_INT 1
29003: NONEQUAL
29004: AND
29005: IFFALSE 29131
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
29007: LD_VAR 0 3
29011: PPUSH
29012: LD_EXP 84
29016: PUSH
29017: LD_VAR 0 2
29021: ARRAY
29022: PUSH
29023: LD_INT 1
29025: ARRAY
29026: PPUSH
29027: CALL 61171 0 2
29031: IFFALSE 29131
// begin ComCancel ( j ) ;
29033: LD_VAR 0 3
29037: PPUSH
29038: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
29042: LD_VAR 0 3
29046: PPUSH
29047: LD_EXP 84
29051: PUSH
29052: LD_VAR 0 2
29056: ARRAY
29057: PUSH
29058: LD_INT 1
29060: ARRAY
29061: PPUSH
29062: CALL_OW 207
// if not j in mc_construct_list [ i ] then
29066: LD_VAR 0 3
29070: PUSH
29071: LD_EXP 57
29075: PUSH
29076: LD_VAR 0 2
29080: ARRAY
29081: IN
29082: NOT
29083: IFFALSE 29129
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
29085: LD_ADDR_EXP 57
29089: PUSH
29090: LD_EXP 57
29094: PPUSH
29095: LD_VAR 0 2
29099: PUSH
29100: LD_EXP 57
29104: PUSH
29105: LD_VAR 0 2
29109: ARRAY
29110: PUSH
29111: LD_INT 1
29113: PLUS
29114: PUSH
29115: EMPTY
29116: LIST
29117: LIST
29118: PPUSH
29119: LD_VAR 0 3
29123: PPUSH
29124: CALL 54555 0 3
29128: ST_TO_ADDR
// break ;
29129: GO 29133
// end ; end ; end ;
29131: GO 28967
29133: POP
29134: POP
// end ;
29135: GO 28727
29137: POP
29138: POP
// end ;
29139: LD_VAR 0 1
29143: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
29144: LD_INT 0
29146: PPUSH
29147: PPUSH
29148: PPUSH
29149: PPUSH
29150: PPUSH
29151: PPUSH
29152: PPUSH
29153: PPUSH
29154: PPUSH
// if not mc_bases then
29155: LD_EXP 50
29159: NOT
29160: IFFALSE 29164
// exit ;
29162: GO 29569
// for i = 1 to mc_bases do
29164: LD_ADDR_VAR 0 2
29168: PUSH
29169: DOUBLE
29170: LD_INT 1
29172: DEC
29173: ST_TO_ADDR
29174: LD_EXP 50
29178: PUSH
29179: FOR_TO
29180: IFFALSE 29567
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
29182: LD_EXP 58
29186: PUSH
29187: LD_VAR 0 2
29191: ARRAY
29192: NOT
29193: PUSH
29194: LD_EXP 50
29198: PUSH
29199: LD_VAR 0 2
29203: ARRAY
29204: PPUSH
29205: LD_INT 30
29207: PUSH
29208: LD_INT 3
29210: PUSH
29211: EMPTY
29212: LIST
29213: LIST
29214: PPUSH
29215: CALL_OW 72
29219: NOT
29220: OR
29221: IFFALSE 29225
// continue ;
29223: GO 29179
// busy := false ;
29225: LD_ADDR_VAR 0 8
29229: PUSH
29230: LD_INT 0
29232: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
29233: LD_ADDR_VAR 0 4
29237: PUSH
29238: LD_EXP 50
29242: PUSH
29243: LD_VAR 0 2
29247: ARRAY
29248: PPUSH
29249: LD_INT 30
29251: PUSH
29252: LD_INT 3
29254: PUSH
29255: EMPTY
29256: LIST
29257: LIST
29258: PPUSH
29259: CALL_OW 72
29263: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
29264: LD_ADDR_VAR 0 6
29268: PUSH
29269: LD_EXP 58
29273: PUSH
29274: LD_VAR 0 2
29278: ARRAY
29279: PPUSH
29280: LD_INT 2
29282: PUSH
29283: LD_INT 30
29285: PUSH
29286: LD_INT 32
29288: PUSH
29289: EMPTY
29290: LIST
29291: LIST
29292: PUSH
29293: LD_INT 30
29295: PUSH
29296: LD_INT 33
29298: PUSH
29299: EMPTY
29300: LIST
29301: LIST
29302: PUSH
29303: EMPTY
29304: LIST
29305: LIST
29306: LIST
29307: PPUSH
29308: CALL_OW 72
29312: ST_TO_ADDR
// if not t then
29313: LD_VAR 0 6
29317: NOT
29318: IFFALSE 29322
// continue ;
29320: GO 29179
// for j in tmp do
29322: LD_ADDR_VAR 0 3
29326: PUSH
29327: LD_VAR 0 4
29331: PUSH
29332: FOR_IN
29333: IFFALSE 29363
// if not BuildingStatus ( j ) = bs_idle then
29335: LD_VAR 0 3
29339: PPUSH
29340: CALL_OW 461
29344: PUSH
29345: LD_INT 2
29347: EQUAL
29348: NOT
29349: IFFALSE 29361
// begin busy := true ;
29351: LD_ADDR_VAR 0 8
29355: PUSH
29356: LD_INT 1
29358: ST_TO_ADDR
// break ;
29359: GO 29363
// end ;
29361: GO 29332
29363: POP
29364: POP
// if busy then
29365: LD_VAR 0 8
29369: IFFALSE 29373
// continue ;
29371: GO 29179
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
29373: LD_ADDR_VAR 0 7
29377: PUSH
29378: LD_VAR 0 6
29382: PPUSH
29383: LD_INT 35
29385: PUSH
29386: LD_INT 0
29388: PUSH
29389: EMPTY
29390: LIST
29391: LIST
29392: PPUSH
29393: CALL_OW 72
29397: ST_TO_ADDR
// if tw then
29398: LD_VAR 0 7
29402: IFFALSE 29479
// begin tw := tw [ 1 ] ;
29404: LD_ADDR_VAR 0 7
29408: PUSH
29409: LD_VAR 0 7
29413: PUSH
29414: LD_INT 1
29416: ARRAY
29417: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
29418: LD_ADDR_VAR 0 9
29422: PUSH
29423: LD_VAR 0 7
29427: PPUSH
29428: LD_EXP 75
29432: PUSH
29433: LD_VAR 0 2
29437: ARRAY
29438: PPUSH
29439: CALL 59525 0 2
29443: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
29444: LD_EXP 89
29448: PUSH
29449: LD_VAR 0 2
29453: ARRAY
29454: IFFALSE 29477
// if not weapon in mc_allowed_tower_weapons [ i ] then
29456: LD_VAR 0 9
29460: PUSH
29461: LD_EXP 89
29465: PUSH
29466: LD_VAR 0 2
29470: ARRAY
29471: IN
29472: NOT
29473: IFFALSE 29477
// continue ;
29475: GO 29179
// end else
29477: GO 29542
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
29479: LD_ADDR_VAR 0 5
29483: PUSH
29484: LD_EXP 58
29488: PUSH
29489: LD_VAR 0 2
29493: ARRAY
29494: PPUSH
29495: LD_VAR 0 4
29499: PPUSH
29500: CALL 89736 0 2
29504: ST_TO_ADDR
// if not tmp2 then
29505: LD_VAR 0 5
29509: NOT
29510: IFFALSE 29514
// continue ;
29512: GO 29179
// tw := tmp2 [ 1 ] ;
29514: LD_ADDR_VAR 0 7
29518: PUSH
29519: LD_VAR 0 5
29523: PUSH
29524: LD_INT 1
29526: ARRAY
29527: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
29528: LD_ADDR_VAR 0 9
29532: PUSH
29533: LD_VAR 0 5
29537: PUSH
29538: LD_INT 2
29540: ARRAY
29541: ST_TO_ADDR
// end ; if not weapon then
29542: LD_VAR 0 9
29546: NOT
29547: IFFALSE 29551
// continue ;
29549: GO 29179
// ComPlaceWeapon ( tw , weapon ) ;
29551: LD_VAR 0 7
29555: PPUSH
29556: LD_VAR 0 9
29560: PPUSH
29561: CALL_OW 148
// end ;
29565: GO 29179
29567: POP
29568: POP
// end ;
29569: LD_VAR 0 1
29573: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
29574: LD_INT 0
29576: PPUSH
29577: PPUSH
29578: PPUSH
29579: PPUSH
29580: PPUSH
29581: PPUSH
// if not mc_bases then
29582: LD_EXP 50
29586: NOT
29587: IFFALSE 29591
// exit ;
29589: GO 30367
// for i = 1 to mc_bases do
29591: LD_ADDR_VAR 0 2
29595: PUSH
29596: DOUBLE
29597: LD_INT 1
29599: DEC
29600: ST_TO_ADDR
29601: LD_EXP 50
29605: PUSH
29606: FOR_TO
29607: IFFALSE 30365
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
29609: LD_EXP 63
29613: PUSH
29614: LD_VAR 0 2
29618: ARRAY
29619: NOT
29620: PUSH
29621: LD_EXP 63
29625: PUSH
29626: LD_VAR 0 2
29630: ARRAY
29631: PUSH
29632: LD_EXP 64
29636: PUSH
29637: LD_VAR 0 2
29641: ARRAY
29642: EQUAL
29643: OR
29644: PUSH
29645: LD_EXP 73
29649: PUSH
29650: LD_VAR 0 2
29654: ARRAY
29655: OR
29656: IFFALSE 29660
// continue ;
29658: GO 29606
// if mc_miners [ i ] then
29660: LD_EXP 64
29664: PUSH
29665: LD_VAR 0 2
29669: ARRAY
29670: IFFALSE 30052
// begin for j = mc_miners [ i ] downto 1 do
29672: LD_ADDR_VAR 0 3
29676: PUSH
29677: DOUBLE
29678: LD_EXP 64
29682: PUSH
29683: LD_VAR 0 2
29687: ARRAY
29688: INC
29689: ST_TO_ADDR
29690: LD_INT 1
29692: PUSH
29693: FOR_DOWNTO
29694: IFFALSE 30050
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
29696: LD_EXP 64
29700: PUSH
29701: LD_VAR 0 2
29705: ARRAY
29706: PUSH
29707: LD_VAR 0 3
29711: ARRAY
29712: PPUSH
29713: CALL_OW 301
29717: PUSH
29718: LD_EXP 64
29722: PUSH
29723: LD_VAR 0 2
29727: ARRAY
29728: PUSH
29729: LD_VAR 0 3
29733: ARRAY
29734: PPUSH
29735: CALL_OW 257
29739: PUSH
29740: LD_INT 1
29742: NONEQUAL
29743: OR
29744: IFFALSE 29807
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
29746: LD_ADDR_VAR 0 5
29750: PUSH
29751: LD_EXP 64
29755: PUSH
29756: LD_VAR 0 2
29760: ARRAY
29761: PUSH
29762: LD_EXP 64
29766: PUSH
29767: LD_VAR 0 2
29771: ARRAY
29772: PUSH
29773: LD_VAR 0 3
29777: ARRAY
29778: DIFF
29779: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
29780: LD_ADDR_EXP 64
29784: PUSH
29785: LD_EXP 64
29789: PPUSH
29790: LD_VAR 0 2
29794: PPUSH
29795: LD_VAR 0 5
29799: PPUSH
29800: CALL_OW 1
29804: ST_TO_ADDR
// continue ;
29805: GO 29693
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
29807: LD_EXP 64
29811: PUSH
29812: LD_VAR 0 2
29816: ARRAY
29817: PUSH
29818: LD_VAR 0 3
29822: ARRAY
29823: PPUSH
29824: CALL_OW 257
29828: PUSH
29829: LD_INT 1
29831: EQUAL
29832: PUSH
29833: LD_EXP 64
29837: PUSH
29838: LD_VAR 0 2
29842: ARRAY
29843: PUSH
29844: LD_VAR 0 3
29848: ARRAY
29849: PPUSH
29850: CALL_OW 459
29854: NOT
29855: AND
29856: PUSH
29857: LD_EXP 64
29861: PUSH
29862: LD_VAR 0 2
29866: ARRAY
29867: PUSH
29868: LD_VAR 0 3
29872: ARRAY
29873: PPUSH
29874: CALL_OW 314
29878: NOT
29879: AND
29880: IFFALSE 30048
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
29882: LD_EXP 64
29886: PUSH
29887: LD_VAR 0 2
29891: ARRAY
29892: PUSH
29893: LD_VAR 0 3
29897: ARRAY
29898: PPUSH
29899: CALL_OW 310
29903: IFFALSE 29926
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
29905: LD_EXP 64
29909: PUSH
29910: LD_VAR 0 2
29914: ARRAY
29915: PUSH
29916: LD_VAR 0 3
29920: ARRAY
29921: PPUSH
29922: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
29926: LD_EXP 64
29930: PUSH
29931: LD_VAR 0 2
29935: ARRAY
29936: PUSH
29937: LD_VAR 0 3
29941: ARRAY
29942: PPUSH
29943: CALL_OW 314
29947: NOT
29948: IFFALSE 30048
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
29950: LD_EXP 64
29954: PUSH
29955: LD_VAR 0 2
29959: ARRAY
29960: PUSH
29961: LD_VAR 0 3
29965: ARRAY
29966: PPUSH
29967: LD_EXP 63
29971: PUSH
29972: LD_VAR 0 2
29976: ARRAY
29977: PUSH
29978: LD_VAR 0 3
29982: PUSH
29983: LD_EXP 63
29987: PUSH
29988: LD_VAR 0 2
29992: ARRAY
29993: MOD
29994: PUSH
29995: LD_INT 1
29997: PLUS
29998: ARRAY
29999: PUSH
30000: LD_INT 1
30002: ARRAY
30003: PPUSH
30004: LD_EXP 63
30008: PUSH
30009: LD_VAR 0 2
30013: ARRAY
30014: PUSH
30015: LD_VAR 0 3
30019: PUSH
30020: LD_EXP 63
30024: PUSH
30025: LD_VAR 0 2
30029: ARRAY
30030: MOD
30031: PUSH
30032: LD_INT 1
30034: PLUS
30035: ARRAY
30036: PUSH
30037: LD_INT 2
30039: ARRAY
30040: PPUSH
30041: LD_INT 0
30043: PPUSH
30044: CALL_OW 193
// end ; end ;
30048: GO 29693
30050: POP
30051: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
30052: LD_ADDR_VAR 0 5
30056: PUSH
30057: LD_EXP 50
30061: PUSH
30062: LD_VAR 0 2
30066: ARRAY
30067: PPUSH
30068: LD_INT 2
30070: PUSH
30071: LD_INT 30
30073: PUSH
30074: LD_INT 4
30076: PUSH
30077: EMPTY
30078: LIST
30079: LIST
30080: PUSH
30081: LD_INT 30
30083: PUSH
30084: LD_INT 5
30086: PUSH
30087: EMPTY
30088: LIST
30089: LIST
30090: PUSH
30091: LD_INT 30
30093: PUSH
30094: LD_INT 32
30096: PUSH
30097: EMPTY
30098: LIST
30099: LIST
30100: PUSH
30101: EMPTY
30102: LIST
30103: LIST
30104: LIST
30105: LIST
30106: PPUSH
30107: CALL_OW 72
30111: ST_TO_ADDR
// if not tmp then
30112: LD_VAR 0 5
30116: NOT
30117: IFFALSE 30121
// continue ;
30119: GO 29606
// list := [ ] ;
30121: LD_ADDR_VAR 0 6
30125: PUSH
30126: EMPTY
30127: ST_TO_ADDR
// for j in tmp do
30128: LD_ADDR_VAR 0 3
30132: PUSH
30133: LD_VAR 0 5
30137: PUSH
30138: FOR_IN
30139: IFFALSE 30208
// begin for k in UnitsInside ( j ) do
30141: LD_ADDR_VAR 0 4
30145: PUSH
30146: LD_VAR 0 3
30150: PPUSH
30151: CALL_OW 313
30155: PUSH
30156: FOR_IN
30157: IFFALSE 30204
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
30159: LD_VAR 0 4
30163: PPUSH
30164: CALL_OW 257
30168: PUSH
30169: LD_INT 1
30171: EQUAL
30172: PUSH
30173: LD_VAR 0 4
30177: PPUSH
30178: CALL_OW 459
30182: NOT
30183: AND
30184: IFFALSE 30202
// list := list ^ k ;
30186: LD_ADDR_VAR 0 6
30190: PUSH
30191: LD_VAR 0 6
30195: PUSH
30196: LD_VAR 0 4
30200: ADD
30201: ST_TO_ADDR
30202: GO 30156
30204: POP
30205: POP
// end ;
30206: GO 30138
30208: POP
30209: POP
// list := list diff mc_miners [ i ] ;
30210: LD_ADDR_VAR 0 6
30214: PUSH
30215: LD_VAR 0 6
30219: PUSH
30220: LD_EXP 64
30224: PUSH
30225: LD_VAR 0 2
30229: ARRAY
30230: DIFF
30231: ST_TO_ADDR
// if not list then
30232: LD_VAR 0 6
30236: NOT
30237: IFFALSE 30241
// continue ;
30239: GO 29606
// k := mc_mines [ i ] - mc_miners [ i ] ;
30241: LD_ADDR_VAR 0 4
30245: PUSH
30246: LD_EXP 63
30250: PUSH
30251: LD_VAR 0 2
30255: ARRAY
30256: PUSH
30257: LD_EXP 64
30261: PUSH
30262: LD_VAR 0 2
30266: ARRAY
30267: MINUS
30268: ST_TO_ADDR
// if k > list then
30269: LD_VAR 0 4
30273: PUSH
30274: LD_VAR 0 6
30278: GREATER
30279: IFFALSE 30291
// k := list ;
30281: LD_ADDR_VAR 0 4
30285: PUSH
30286: LD_VAR 0 6
30290: ST_TO_ADDR
// for j = 1 to k do
30291: LD_ADDR_VAR 0 3
30295: PUSH
30296: DOUBLE
30297: LD_INT 1
30299: DEC
30300: ST_TO_ADDR
30301: LD_VAR 0 4
30305: PUSH
30306: FOR_TO
30307: IFFALSE 30361
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
30309: LD_ADDR_EXP 64
30313: PUSH
30314: LD_EXP 64
30318: PPUSH
30319: LD_VAR 0 2
30323: PUSH
30324: LD_EXP 64
30328: PUSH
30329: LD_VAR 0 2
30333: ARRAY
30334: PUSH
30335: LD_INT 1
30337: PLUS
30338: PUSH
30339: EMPTY
30340: LIST
30341: LIST
30342: PPUSH
30343: LD_VAR 0 6
30347: PUSH
30348: LD_VAR 0 3
30352: ARRAY
30353: PPUSH
30354: CALL 54555 0 3
30358: ST_TO_ADDR
30359: GO 30306
30361: POP
30362: POP
// end ;
30363: GO 29606
30365: POP
30366: POP
// end ;
30367: LD_VAR 0 1
30371: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
30372: LD_INT 0
30374: PPUSH
30375: PPUSH
30376: PPUSH
30377: PPUSH
30378: PPUSH
30379: PPUSH
30380: PPUSH
30381: PPUSH
30382: PPUSH
30383: PPUSH
// if not mc_bases then
30384: LD_EXP 50
30388: NOT
30389: IFFALSE 30393
// exit ;
30391: GO 32143
// for i = 1 to mc_bases do
30393: LD_ADDR_VAR 0 2
30397: PUSH
30398: DOUBLE
30399: LD_INT 1
30401: DEC
30402: ST_TO_ADDR
30403: LD_EXP 50
30407: PUSH
30408: FOR_TO
30409: IFFALSE 32141
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
30411: LD_EXP 50
30415: PUSH
30416: LD_VAR 0 2
30420: ARRAY
30421: NOT
30422: PUSH
30423: LD_EXP 57
30427: PUSH
30428: LD_VAR 0 2
30432: ARRAY
30433: OR
30434: IFFALSE 30438
// continue ;
30436: GO 30408
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
30438: LD_EXP 66
30442: PUSH
30443: LD_VAR 0 2
30447: ARRAY
30448: NOT
30449: PUSH
30450: LD_EXP 67
30454: PUSH
30455: LD_VAR 0 2
30459: ARRAY
30460: AND
30461: IFFALSE 30499
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
30463: LD_ADDR_EXP 67
30467: PUSH
30468: LD_EXP 67
30472: PPUSH
30473: LD_VAR 0 2
30477: PPUSH
30478: EMPTY
30479: PPUSH
30480: CALL_OW 1
30484: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
30485: LD_VAR 0 2
30489: PPUSH
30490: LD_INT 107
30492: PPUSH
30493: CALL 21357 0 2
// continue ;
30497: GO 30408
// end ; target := [ ] ;
30499: LD_ADDR_VAR 0 6
30503: PUSH
30504: EMPTY
30505: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
30506: LD_ADDR_VAR 0 3
30510: PUSH
30511: DOUBLE
30512: LD_EXP 66
30516: PUSH
30517: LD_VAR 0 2
30521: ARRAY
30522: INC
30523: ST_TO_ADDR
30524: LD_INT 1
30526: PUSH
30527: FOR_DOWNTO
30528: IFFALSE 30788
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
30530: LD_EXP 66
30534: PUSH
30535: LD_VAR 0 2
30539: ARRAY
30540: PUSH
30541: LD_VAR 0 3
30545: ARRAY
30546: PUSH
30547: LD_INT 2
30549: ARRAY
30550: PPUSH
30551: LD_EXP 66
30555: PUSH
30556: LD_VAR 0 2
30560: ARRAY
30561: PUSH
30562: LD_VAR 0 3
30566: ARRAY
30567: PUSH
30568: LD_INT 3
30570: ARRAY
30571: PPUSH
30572: CALL_OW 488
30576: PUSH
30577: LD_EXP 66
30581: PUSH
30582: LD_VAR 0 2
30586: ARRAY
30587: PUSH
30588: LD_VAR 0 3
30592: ARRAY
30593: PUSH
30594: LD_INT 2
30596: ARRAY
30597: PPUSH
30598: LD_EXP 66
30602: PUSH
30603: LD_VAR 0 2
30607: ARRAY
30608: PUSH
30609: LD_VAR 0 3
30613: ARRAY
30614: PUSH
30615: LD_INT 3
30617: ARRAY
30618: PPUSH
30619: CALL_OW 284
30623: PUSH
30624: LD_INT 0
30626: EQUAL
30627: AND
30628: IFFALSE 30683
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
30630: LD_ADDR_VAR 0 5
30634: PUSH
30635: LD_EXP 66
30639: PUSH
30640: LD_VAR 0 2
30644: ARRAY
30645: PPUSH
30646: LD_VAR 0 3
30650: PPUSH
30651: CALL_OW 3
30655: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
30656: LD_ADDR_EXP 66
30660: PUSH
30661: LD_EXP 66
30665: PPUSH
30666: LD_VAR 0 2
30670: PPUSH
30671: LD_VAR 0 5
30675: PPUSH
30676: CALL_OW 1
30680: ST_TO_ADDR
// continue ;
30681: GO 30527
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
30683: LD_EXP 50
30687: PUSH
30688: LD_VAR 0 2
30692: ARRAY
30693: PUSH
30694: LD_INT 1
30696: ARRAY
30697: PPUSH
30698: CALL_OW 255
30702: PPUSH
30703: LD_EXP 66
30707: PUSH
30708: LD_VAR 0 2
30712: ARRAY
30713: PUSH
30714: LD_VAR 0 3
30718: ARRAY
30719: PUSH
30720: LD_INT 2
30722: ARRAY
30723: PPUSH
30724: LD_EXP 66
30728: PUSH
30729: LD_VAR 0 2
30733: ARRAY
30734: PUSH
30735: LD_VAR 0 3
30739: ARRAY
30740: PUSH
30741: LD_INT 3
30743: ARRAY
30744: PPUSH
30745: LD_INT 30
30747: PPUSH
30748: CALL 55451 0 4
30752: PUSH
30753: LD_INT 4
30755: ARRAY
30756: PUSH
30757: LD_INT 0
30759: EQUAL
30760: IFFALSE 30786
// begin target := mc_crates [ i ] [ j ] ;
30762: LD_ADDR_VAR 0 6
30766: PUSH
30767: LD_EXP 66
30771: PUSH
30772: LD_VAR 0 2
30776: ARRAY
30777: PUSH
30778: LD_VAR 0 3
30782: ARRAY
30783: ST_TO_ADDR
// break ;
30784: GO 30788
// end ; end ;
30786: GO 30527
30788: POP
30789: POP
// if not target then
30790: LD_VAR 0 6
30794: NOT
30795: IFFALSE 30799
// continue ;
30797: GO 30408
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
30799: LD_ADDR_VAR 0 7
30803: PUSH
30804: LD_EXP 69
30808: PUSH
30809: LD_VAR 0 2
30813: ARRAY
30814: PPUSH
30815: LD_INT 2
30817: PUSH
30818: LD_INT 3
30820: PUSH
30821: LD_INT 58
30823: PUSH
30824: EMPTY
30825: LIST
30826: PUSH
30827: EMPTY
30828: LIST
30829: LIST
30830: PUSH
30831: LD_INT 61
30833: PUSH
30834: EMPTY
30835: LIST
30836: PUSH
30837: LD_INT 33
30839: PUSH
30840: LD_INT 5
30842: PUSH
30843: EMPTY
30844: LIST
30845: LIST
30846: PUSH
30847: LD_INT 33
30849: PUSH
30850: LD_INT 3
30852: PUSH
30853: EMPTY
30854: LIST
30855: LIST
30856: PUSH
30857: EMPTY
30858: LIST
30859: LIST
30860: LIST
30861: LIST
30862: LIST
30863: PUSH
30864: LD_INT 2
30866: PUSH
30867: LD_INT 34
30869: PUSH
30870: LD_INT 32
30872: PUSH
30873: EMPTY
30874: LIST
30875: LIST
30876: PUSH
30877: LD_INT 34
30879: PUSH
30880: LD_INT 51
30882: PUSH
30883: EMPTY
30884: LIST
30885: LIST
30886: PUSH
30887: LD_INT 34
30889: PUSH
30890: LD_INT 12
30892: PUSH
30893: EMPTY
30894: LIST
30895: LIST
30896: PUSH
30897: EMPTY
30898: LIST
30899: LIST
30900: LIST
30901: LIST
30902: PUSH
30903: EMPTY
30904: LIST
30905: LIST
30906: PPUSH
30907: CALL_OW 72
30911: ST_TO_ADDR
// if not cargo then
30912: LD_VAR 0 7
30916: NOT
30917: IFFALSE 31560
// begin if mc_crates_collector [ i ] < 5 then
30919: LD_EXP 67
30923: PUSH
30924: LD_VAR 0 2
30928: ARRAY
30929: PUSH
30930: LD_INT 5
30932: LESS
30933: IFFALSE 31299
// begin if mc_ape [ i ] then
30935: LD_EXP 79
30939: PUSH
30940: LD_VAR 0 2
30944: ARRAY
30945: IFFALSE 30992
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
30947: LD_ADDR_VAR 0 5
30951: PUSH
30952: LD_EXP 79
30956: PUSH
30957: LD_VAR 0 2
30961: ARRAY
30962: PPUSH
30963: LD_INT 25
30965: PUSH
30966: LD_INT 16
30968: PUSH
30969: EMPTY
30970: LIST
30971: LIST
30972: PUSH
30973: LD_INT 24
30975: PUSH
30976: LD_INT 750
30978: PUSH
30979: EMPTY
30980: LIST
30981: LIST
30982: PUSH
30983: EMPTY
30984: LIST
30985: LIST
30986: PPUSH
30987: CALL_OW 72
30991: ST_TO_ADDR
// if not tmp then
30992: LD_VAR 0 5
30996: NOT
30997: IFFALSE 31044
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
30999: LD_ADDR_VAR 0 5
31003: PUSH
31004: LD_EXP 50
31008: PUSH
31009: LD_VAR 0 2
31013: ARRAY
31014: PPUSH
31015: LD_INT 25
31017: PUSH
31018: LD_INT 2
31020: PUSH
31021: EMPTY
31022: LIST
31023: LIST
31024: PUSH
31025: LD_INT 24
31027: PUSH
31028: LD_INT 750
31030: PUSH
31031: EMPTY
31032: LIST
31033: LIST
31034: PUSH
31035: EMPTY
31036: LIST
31037: LIST
31038: PPUSH
31039: CALL_OW 72
31043: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
31044: LD_EXP 79
31048: PUSH
31049: LD_VAR 0 2
31053: ARRAY
31054: PUSH
31055: LD_EXP 50
31059: PUSH
31060: LD_VAR 0 2
31064: ARRAY
31065: PPUSH
31066: LD_INT 25
31068: PUSH
31069: LD_INT 2
31071: PUSH
31072: EMPTY
31073: LIST
31074: LIST
31075: PUSH
31076: LD_INT 24
31078: PUSH
31079: LD_INT 750
31081: PUSH
31082: EMPTY
31083: LIST
31084: LIST
31085: PUSH
31086: EMPTY
31087: LIST
31088: LIST
31089: PPUSH
31090: CALL_OW 72
31094: AND
31095: PUSH
31096: LD_VAR 0 5
31100: PUSH
31101: LD_INT 5
31103: LESS
31104: AND
31105: IFFALSE 31187
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
31107: LD_ADDR_VAR 0 3
31111: PUSH
31112: LD_EXP 50
31116: PUSH
31117: LD_VAR 0 2
31121: ARRAY
31122: PPUSH
31123: LD_INT 25
31125: PUSH
31126: LD_INT 2
31128: PUSH
31129: EMPTY
31130: LIST
31131: LIST
31132: PUSH
31133: LD_INT 24
31135: PUSH
31136: LD_INT 750
31138: PUSH
31139: EMPTY
31140: LIST
31141: LIST
31142: PUSH
31143: EMPTY
31144: LIST
31145: LIST
31146: PPUSH
31147: CALL_OW 72
31151: PUSH
31152: FOR_IN
31153: IFFALSE 31185
// begin tmp := tmp union j ;
31155: LD_ADDR_VAR 0 5
31159: PUSH
31160: LD_VAR 0 5
31164: PUSH
31165: LD_VAR 0 3
31169: UNION
31170: ST_TO_ADDR
// if tmp >= 5 then
31171: LD_VAR 0 5
31175: PUSH
31176: LD_INT 5
31178: GREATEREQUAL
31179: IFFALSE 31183
// break ;
31181: GO 31185
// end ;
31183: GO 31152
31185: POP
31186: POP
// end ; if not tmp then
31187: LD_VAR 0 5
31191: NOT
31192: IFFALSE 31196
// continue ;
31194: GO 30408
// for j in tmp do
31196: LD_ADDR_VAR 0 3
31200: PUSH
31201: LD_VAR 0 5
31205: PUSH
31206: FOR_IN
31207: IFFALSE 31297
// if not GetTag ( j ) then
31209: LD_VAR 0 3
31213: PPUSH
31214: CALL_OW 110
31218: NOT
31219: IFFALSE 31295
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
31221: LD_ADDR_EXP 67
31225: PUSH
31226: LD_EXP 67
31230: PPUSH
31231: LD_VAR 0 2
31235: PUSH
31236: LD_EXP 67
31240: PUSH
31241: LD_VAR 0 2
31245: ARRAY
31246: PUSH
31247: LD_INT 1
31249: PLUS
31250: PUSH
31251: EMPTY
31252: LIST
31253: LIST
31254: PPUSH
31255: LD_VAR 0 3
31259: PPUSH
31260: CALL 54555 0 3
31264: ST_TO_ADDR
// SetTag ( j , 107 ) ;
31265: LD_VAR 0 3
31269: PPUSH
31270: LD_INT 107
31272: PPUSH
31273: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
31277: LD_EXP 67
31281: PUSH
31282: LD_VAR 0 2
31286: ARRAY
31287: PUSH
31288: LD_INT 5
31290: GREATEREQUAL
31291: IFFALSE 31295
// break ;
31293: GO 31297
// end ;
31295: GO 31206
31297: POP
31298: POP
// end ; if mc_crates_collector [ i ] and target then
31299: LD_EXP 67
31303: PUSH
31304: LD_VAR 0 2
31308: ARRAY
31309: PUSH
31310: LD_VAR 0 6
31314: AND
31315: IFFALSE 31558
// begin if mc_crates_collector [ i ] < target [ 1 ] then
31317: LD_EXP 67
31321: PUSH
31322: LD_VAR 0 2
31326: ARRAY
31327: PUSH
31328: LD_VAR 0 6
31332: PUSH
31333: LD_INT 1
31335: ARRAY
31336: LESS
31337: IFFALSE 31357
// tmp := mc_crates_collector [ i ] else
31339: LD_ADDR_VAR 0 5
31343: PUSH
31344: LD_EXP 67
31348: PUSH
31349: LD_VAR 0 2
31353: ARRAY
31354: ST_TO_ADDR
31355: GO 31371
// tmp := target [ 1 ] ;
31357: LD_ADDR_VAR 0 5
31361: PUSH
31362: LD_VAR 0 6
31366: PUSH
31367: LD_INT 1
31369: ARRAY
31370: ST_TO_ADDR
// k := 0 ;
31371: LD_ADDR_VAR 0 4
31375: PUSH
31376: LD_INT 0
31378: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
31379: LD_ADDR_VAR 0 3
31383: PUSH
31384: LD_EXP 67
31388: PUSH
31389: LD_VAR 0 2
31393: ARRAY
31394: PUSH
31395: FOR_IN
31396: IFFALSE 31556
// begin k := k + 1 ;
31398: LD_ADDR_VAR 0 4
31402: PUSH
31403: LD_VAR 0 4
31407: PUSH
31408: LD_INT 1
31410: PLUS
31411: ST_TO_ADDR
// if k > tmp then
31412: LD_VAR 0 4
31416: PUSH
31417: LD_VAR 0 5
31421: GREATER
31422: IFFALSE 31426
// break ;
31424: GO 31556
// if not GetClass ( j ) in [ 2 , 16 ] then
31426: LD_VAR 0 3
31430: PPUSH
31431: CALL_OW 257
31435: PUSH
31436: LD_INT 2
31438: PUSH
31439: LD_INT 16
31441: PUSH
31442: EMPTY
31443: LIST
31444: LIST
31445: IN
31446: NOT
31447: IFFALSE 31500
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
31449: LD_ADDR_EXP 67
31453: PUSH
31454: LD_EXP 67
31458: PPUSH
31459: LD_VAR 0 2
31463: PPUSH
31464: LD_EXP 67
31468: PUSH
31469: LD_VAR 0 2
31473: ARRAY
31474: PUSH
31475: LD_VAR 0 3
31479: DIFF
31480: PPUSH
31481: CALL_OW 1
31485: ST_TO_ADDR
// SetTag ( j , 0 ) ;
31486: LD_VAR 0 3
31490: PPUSH
31491: LD_INT 0
31493: PPUSH
31494: CALL_OW 109
// continue ;
31498: GO 31395
// end ; if IsInUnit ( j ) then
31500: LD_VAR 0 3
31504: PPUSH
31505: CALL_OW 310
31509: IFFALSE 31520
// ComExitBuilding ( j ) ;
31511: LD_VAR 0 3
31515: PPUSH
31516: CALL_OW 122
// wait ( 3 ) ;
31520: LD_INT 3
31522: PPUSH
31523: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
31527: LD_VAR 0 3
31531: PPUSH
31532: LD_VAR 0 6
31536: PUSH
31537: LD_INT 2
31539: ARRAY
31540: PPUSH
31541: LD_VAR 0 6
31545: PUSH
31546: LD_INT 3
31548: ARRAY
31549: PPUSH
31550: CALL_OW 117
// end ;
31554: GO 31395
31556: POP
31557: POP
// end ; end else
31558: GO 32139
// begin for j in cargo do
31560: LD_ADDR_VAR 0 3
31564: PUSH
31565: LD_VAR 0 7
31569: PUSH
31570: FOR_IN
31571: IFFALSE 32137
// begin if GetTag ( j ) <> 0 then
31573: LD_VAR 0 3
31577: PPUSH
31578: CALL_OW 110
31582: PUSH
31583: LD_INT 0
31585: NONEQUAL
31586: IFFALSE 31590
// continue ;
31588: GO 31570
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
31590: LD_VAR 0 3
31594: PPUSH
31595: CALL_OW 256
31599: PUSH
31600: LD_INT 1000
31602: LESS
31603: PUSH
31604: LD_VAR 0 3
31608: PPUSH
31609: LD_EXP 74
31613: PUSH
31614: LD_VAR 0 2
31618: ARRAY
31619: PPUSH
31620: CALL_OW 308
31624: NOT
31625: AND
31626: IFFALSE 31648
// ComMoveToArea ( j , mc_parking [ i ] ) ;
31628: LD_VAR 0 3
31632: PPUSH
31633: LD_EXP 74
31637: PUSH
31638: LD_VAR 0 2
31642: ARRAY
31643: PPUSH
31644: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
31648: LD_VAR 0 3
31652: PPUSH
31653: CALL_OW 256
31657: PUSH
31658: LD_INT 1000
31660: LESS
31661: PUSH
31662: LD_VAR 0 3
31666: PPUSH
31667: LD_EXP 74
31671: PUSH
31672: LD_VAR 0 2
31676: ARRAY
31677: PPUSH
31678: CALL_OW 308
31682: AND
31683: IFFALSE 31687
// continue ;
31685: GO 31570
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
31687: LD_VAR 0 3
31691: PPUSH
31692: CALL_OW 262
31696: PUSH
31697: LD_INT 2
31699: EQUAL
31700: PUSH
31701: LD_VAR 0 3
31705: PPUSH
31706: CALL_OW 261
31710: PUSH
31711: LD_INT 15
31713: LESS
31714: AND
31715: IFFALSE 31719
// continue ;
31717: GO 31570
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
31719: LD_VAR 0 3
31723: PPUSH
31724: CALL_OW 262
31728: PUSH
31729: LD_INT 1
31731: EQUAL
31732: PUSH
31733: LD_VAR 0 3
31737: PPUSH
31738: CALL_OW 261
31742: PUSH
31743: LD_INT 10
31745: LESS
31746: AND
31747: IFFALSE 32076
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31749: LD_ADDR_VAR 0 8
31753: PUSH
31754: LD_EXP 50
31758: PUSH
31759: LD_VAR 0 2
31763: ARRAY
31764: PPUSH
31765: LD_INT 2
31767: PUSH
31768: LD_INT 30
31770: PUSH
31771: LD_INT 0
31773: PUSH
31774: EMPTY
31775: LIST
31776: LIST
31777: PUSH
31778: LD_INT 30
31780: PUSH
31781: LD_INT 1
31783: PUSH
31784: EMPTY
31785: LIST
31786: LIST
31787: PUSH
31788: EMPTY
31789: LIST
31790: LIST
31791: LIST
31792: PPUSH
31793: CALL_OW 72
31797: ST_TO_ADDR
// if not depot then
31798: LD_VAR 0 8
31802: NOT
31803: IFFALSE 31807
// continue ;
31805: GO 31570
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
31807: LD_VAR 0 3
31811: PPUSH
31812: LD_VAR 0 8
31816: PPUSH
31817: LD_VAR 0 3
31821: PPUSH
31822: CALL_OW 74
31826: PPUSH
31827: CALL_OW 296
31831: PUSH
31832: LD_INT 6
31834: LESS
31835: IFFALSE 31851
// SetFuel ( j , 100 ) else
31837: LD_VAR 0 3
31841: PPUSH
31842: LD_INT 100
31844: PPUSH
31845: CALL_OW 240
31849: GO 32076
// if GetFuel ( j ) = 0 then
31851: LD_VAR 0 3
31855: PPUSH
31856: CALL_OW 261
31860: PUSH
31861: LD_INT 0
31863: EQUAL
31864: IFFALSE 32076
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
31866: LD_ADDR_EXP 69
31870: PUSH
31871: LD_EXP 69
31875: PPUSH
31876: LD_VAR 0 2
31880: PPUSH
31881: LD_EXP 69
31885: PUSH
31886: LD_VAR 0 2
31890: ARRAY
31891: PUSH
31892: LD_VAR 0 3
31896: DIFF
31897: PPUSH
31898: CALL_OW 1
31902: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
31903: LD_VAR 0 3
31907: PPUSH
31908: CALL_OW 263
31912: PUSH
31913: LD_INT 1
31915: EQUAL
31916: IFFALSE 31932
// ComExitVehicle ( IsInUnit ( j ) ) ;
31918: LD_VAR 0 3
31922: PPUSH
31923: CALL_OW 310
31927: PPUSH
31928: CALL_OW 121
// if GetControl ( j ) = control_remote then
31932: LD_VAR 0 3
31936: PPUSH
31937: CALL_OW 263
31941: PUSH
31942: LD_INT 2
31944: EQUAL
31945: IFFALSE 31956
// ComUnlink ( j ) ;
31947: LD_VAR 0 3
31951: PPUSH
31952: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
31956: LD_ADDR_VAR 0 9
31960: PUSH
31961: LD_VAR 0 2
31965: PPUSH
31966: LD_INT 3
31968: PPUSH
31969: CALL 41429 0 2
31973: ST_TO_ADDR
// if fac then
31974: LD_VAR 0 9
31978: IFFALSE 32074
// begin for k in fac do
31980: LD_ADDR_VAR 0 4
31984: PUSH
31985: LD_VAR 0 9
31989: PUSH
31990: FOR_IN
31991: IFFALSE 32072
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
31993: LD_ADDR_VAR 0 10
31997: PUSH
31998: LD_VAR 0 9
32002: PPUSH
32003: LD_VAR 0 3
32007: PPUSH
32008: CALL_OW 265
32012: PPUSH
32013: LD_VAR 0 3
32017: PPUSH
32018: CALL_OW 262
32022: PPUSH
32023: LD_VAR 0 3
32027: PPUSH
32028: CALL_OW 263
32032: PPUSH
32033: LD_VAR 0 3
32037: PPUSH
32038: CALL_OW 264
32042: PPUSH
32043: CALL 52087 0 5
32047: ST_TO_ADDR
// if components then
32048: LD_VAR 0 10
32052: IFFALSE 32070
// begin MC_InsertProduceList ( i , components ) ;
32054: LD_VAR 0 2
32058: PPUSH
32059: LD_VAR 0 10
32063: PPUSH
32064: CALL 40974 0 2
// break ;
32068: GO 32072
// end ; end ;
32070: GO 31990
32072: POP
32073: POP
// end ; continue ;
32074: GO 31570
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
32076: LD_VAR 0 3
32080: PPUSH
32081: LD_INT 1
32083: PPUSH
32084: CALL_OW 289
32088: PUSH
32089: LD_INT 100
32091: LESS
32092: PUSH
32093: LD_VAR 0 3
32097: PPUSH
32098: CALL_OW 314
32102: NOT
32103: AND
32104: IFFALSE 32133
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
32106: LD_VAR 0 3
32110: PPUSH
32111: LD_VAR 0 6
32115: PUSH
32116: LD_INT 2
32118: ARRAY
32119: PPUSH
32120: LD_VAR 0 6
32124: PUSH
32125: LD_INT 3
32127: ARRAY
32128: PPUSH
32129: CALL_OW 117
// break ;
32133: GO 32137
// end ;
32135: GO 31570
32137: POP
32138: POP
// end ; end ;
32139: GO 30408
32141: POP
32142: POP
// end ;
32143: LD_VAR 0 1
32147: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
32148: LD_INT 0
32150: PPUSH
32151: PPUSH
32152: PPUSH
32153: PPUSH
// if not mc_bases then
32154: LD_EXP 50
32158: NOT
32159: IFFALSE 32163
// exit ;
32161: GO 32324
// for i = 1 to mc_bases do
32163: LD_ADDR_VAR 0 2
32167: PUSH
32168: DOUBLE
32169: LD_INT 1
32171: DEC
32172: ST_TO_ADDR
32173: LD_EXP 50
32177: PUSH
32178: FOR_TO
32179: IFFALSE 32322
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
32181: LD_ADDR_VAR 0 4
32185: PUSH
32186: LD_EXP 69
32190: PUSH
32191: LD_VAR 0 2
32195: ARRAY
32196: PUSH
32197: LD_EXP 72
32201: PUSH
32202: LD_VAR 0 2
32206: ARRAY
32207: UNION
32208: PPUSH
32209: LD_INT 33
32211: PUSH
32212: LD_INT 2
32214: PUSH
32215: EMPTY
32216: LIST
32217: LIST
32218: PPUSH
32219: CALL_OW 72
32223: ST_TO_ADDR
// if tmp then
32224: LD_VAR 0 4
32228: IFFALSE 32320
// for j in tmp do
32230: LD_ADDR_VAR 0 3
32234: PUSH
32235: LD_VAR 0 4
32239: PUSH
32240: FOR_IN
32241: IFFALSE 32318
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
32243: LD_VAR 0 3
32247: PPUSH
32248: CALL_OW 312
32252: NOT
32253: PUSH
32254: LD_VAR 0 3
32258: PPUSH
32259: CALL_OW 256
32263: PUSH
32264: LD_INT 250
32266: GREATEREQUAL
32267: AND
32268: IFFALSE 32281
// Connect ( j ) else
32270: LD_VAR 0 3
32274: PPUSH
32275: CALL 57488 0 1
32279: GO 32316
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
32281: LD_VAR 0 3
32285: PPUSH
32286: CALL_OW 256
32290: PUSH
32291: LD_INT 250
32293: LESS
32294: PUSH
32295: LD_VAR 0 3
32299: PPUSH
32300: CALL_OW 312
32304: AND
32305: IFFALSE 32316
// ComUnlink ( j ) ;
32307: LD_VAR 0 3
32311: PPUSH
32312: CALL_OW 136
32316: GO 32240
32318: POP
32319: POP
// end ;
32320: GO 32178
32322: POP
32323: POP
// end ;
32324: LD_VAR 0 1
32328: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
32329: LD_INT 0
32331: PPUSH
32332: PPUSH
32333: PPUSH
32334: PPUSH
32335: PPUSH
// if not mc_bases then
32336: LD_EXP 50
32340: NOT
32341: IFFALSE 32345
// exit ;
32343: GO 32790
// for i = 1 to mc_bases do
32345: LD_ADDR_VAR 0 2
32349: PUSH
32350: DOUBLE
32351: LD_INT 1
32353: DEC
32354: ST_TO_ADDR
32355: LD_EXP 50
32359: PUSH
32360: FOR_TO
32361: IFFALSE 32788
// begin if not mc_produce [ i ] then
32363: LD_EXP 71
32367: PUSH
32368: LD_VAR 0 2
32372: ARRAY
32373: NOT
32374: IFFALSE 32378
// continue ;
32376: GO 32360
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
32378: LD_ADDR_VAR 0 5
32382: PUSH
32383: LD_EXP 50
32387: PUSH
32388: LD_VAR 0 2
32392: ARRAY
32393: PPUSH
32394: LD_INT 30
32396: PUSH
32397: LD_INT 3
32399: PUSH
32400: EMPTY
32401: LIST
32402: LIST
32403: PPUSH
32404: CALL_OW 72
32408: ST_TO_ADDR
// if not fac then
32409: LD_VAR 0 5
32413: NOT
32414: IFFALSE 32418
// continue ;
32416: GO 32360
// for j in fac do
32418: LD_ADDR_VAR 0 3
32422: PUSH
32423: LD_VAR 0 5
32427: PUSH
32428: FOR_IN
32429: IFFALSE 32784
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
32431: LD_VAR 0 3
32435: PPUSH
32436: CALL_OW 461
32440: PUSH
32441: LD_INT 2
32443: NONEQUAL
32444: PUSH
32445: LD_VAR 0 3
32449: PPUSH
32450: LD_INT 15
32452: PPUSH
32453: CALL 57148 0 2
32457: PUSH
32458: LD_INT 4
32460: ARRAY
32461: OR
32462: IFFALSE 32466
// continue ;
32464: GO 32428
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
32466: LD_VAR 0 3
32470: PPUSH
32471: LD_EXP 71
32475: PUSH
32476: LD_VAR 0 2
32480: ARRAY
32481: PUSH
32482: LD_INT 1
32484: ARRAY
32485: PUSH
32486: LD_INT 1
32488: ARRAY
32489: PPUSH
32490: LD_EXP 71
32494: PUSH
32495: LD_VAR 0 2
32499: ARRAY
32500: PUSH
32501: LD_INT 1
32503: ARRAY
32504: PUSH
32505: LD_INT 2
32507: ARRAY
32508: PPUSH
32509: LD_EXP 71
32513: PUSH
32514: LD_VAR 0 2
32518: ARRAY
32519: PUSH
32520: LD_INT 1
32522: ARRAY
32523: PUSH
32524: LD_INT 3
32526: ARRAY
32527: PPUSH
32528: LD_EXP 71
32532: PUSH
32533: LD_VAR 0 2
32537: ARRAY
32538: PUSH
32539: LD_INT 1
32541: ARRAY
32542: PUSH
32543: LD_INT 4
32545: ARRAY
32546: PPUSH
32547: CALL_OW 448
32551: PUSH
32552: LD_VAR 0 3
32556: PPUSH
32557: LD_EXP 71
32561: PUSH
32562: LD_VAR 0 2
32566: ARRAY
32567: PUSH
32568: LD_INT 1
32570: ARRAY
32571: PUSH
32572: LD_INT 1
32574: ARRAY
32575: PUSH
32576: LD_EXP 71
32580: PUSH
32581: LD_VAR 0 2
32585: ARRAY
32586: PUSH
32587: LD_INT 1
32589: ARRAY
32590: PUSH
32591: LD_INT 2
32593: ARRAY
32594: PUSH
32595: LD_EXP 71
32599: PUSH
32600: LD_VAR 0 2
32604: ARRAY
32605: PUSH
32606: LD_INT 1
32608: ARRAY
32609: PUSH
32610: LD_INT 3
32612: ARRAY
32613: PUSH
32614: LD_EXP 71
32618: PUSH
32619: LD_VAR 0 2
32623: ARRAY
32624: PUSH
32625: LD_INT 1
32627: ARRAY
32628: PUSH
32629: LD_INT 4
32631: ARRAY
32632: PUSH
32633: EMPTY
32634: LIST
32635: LIST
32636: LIST
32637: LIST
32638: PPUSH
32639: CALL 60819 0 2
32643: AND
32644: IFFALSE 32782
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
32646: LD_VAR 0 3
32650: PPUSH
32651: LD_EXP 71
32655: PUSH
32656: LD_VAR 0 2
32660: ARRAY
32661: PUSH
32662: LD_INT 1
32664: ARRAY
32665: PUSH
32666: LD_INT 1
32668: ARRAY
32669: PPUSH
32670: LD_EXP 71
32674: PUSH
32675: LD_VAR 0 2
32679: ARRAY
32680: PUSH
32681: LD_INT 1
32683: ARRAY
32684: PUSH
32685: LD_INT 2
32687: ARRAY
32688: PPUSH
32689: LD_EXP 71
32693: PUSH
32694: LD_VAR 0 2
32698: ARRAY
32699: PUSH
32700: LD_INT 1
32702: ARRAY
32703: PUSH
32704: LD_INT 3
32706: ARRAY
32707: PPUSH
32708: LD_EXP 71
32712: PUSH
32713: LD_VAR 0 2
32717: ARRAY
32718: PUSH
32719: LD_INT 1
32721: ARRAY
32722: PUSH
32723: LD_INT 4
32725: ARRAY
32726: PPUSH
32727: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
32731: LD_ADDR_VAR 0 4
32735: PUSH
32736: LD_EXP 71
32740: PUSH
32741: LD_VAR 0 2
32745: ARRAY
32746: PPUSH
32747: LD_INT 1
32749: PPUSH
32750: CALL_OW 3
32754: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
32755: LD_ADDR_EXP 71
32759: PUSH
32760: LD_EXP 71
32764: PPUSH
32765: LD_VAR 0 2
32769: PPUSH
32770: LD_VAR 0 4
32774: PPUSH
32775: CALL_OW 1
32779: ST_TO_ADDR
// break ;
32780: GO 32784
// end ; end ;
32782: GO 32428
32784: POP
32785: POP
// end ;
32786: GO 32360
32788: POP
32789: POP
// end ;
32790: LD_VAR 0 1
32794: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
32795: LD_INT 0
32797: PPUSH
32798: PPUSH
32799: PPUSH
// if not mc_bases then
32800: LD_EXP 50
32804: NOT
32805: IFFALSE 32809
// exit ;
32807: GO 32898
// for i = 1 to mc_bases do
32809: LD_ADDR_VAR 0 2
32813: PUSH
32814: DOUBLE
32815: LD_INT 1
32817: DEC
32818: ST_TO_ADDR
32819: LD_EXP 50
32823: PUSH
32824: FOR_TO
32825: IFFALSE 32896
// begin if mc_attack [ i ] then
32827: LD_EXP 70
32831: PUSH
32832: LD_VAR 0 2
32836: ARRAY
32837: IFFALSE 32894
// begin tmp := mc_attack [ i ] [ 1 ] ;
32839: LD_ADDR_VAR 0 3
32843: PUSH
32844: LD_EXP 70
32848: PUSH
32849: LD_VAR 0 2
32853: ARRAY
32854: PUSH
32855: LD_INT 1
32857: ARRAY
32858: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
32859: LD_ADDR_EXP 70
32863: PUSH
32864: LD_EXP 70
32868: PPUSH
32869: LD_VAR 0 2
32873: PPUSH
32874: EMPTY
32875: PPUSH
32876: CALL_OW 1
32880: ST_TO_ADDR
// Attack ( tmp ) ;
32881: LD_VAR 0 3
32885: PPUSH
32886: CALL 83009 0 1
// exit ;
32890: POP
32891: POP
32892: GO 32898
// end ; end ;
32894: GO 32824
32896: POP
32897: POP
// end ;
32898: LD_VAR 0 1
32902: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
32903: LD_INT 0
32905: PPUSH
32906: PPUSH
32907: PPUSH
32908: PPUSH
32909: PPUSH
32910: PPUSH
32911: PPUSH
// if not mc_bases then
32912: LD_EXP 50
32916: NOT
32917: IFFALSE 32921
// exit ;
32919: GO 33503
// for i = 1 to mc_bases do
32921: LD_ADDR_VAR 0 2
32925: PUSH
32926: DOUBLE
32927: LD_INT 1
32929: DEC
32930: ST_TO_ADDR
32931: LD_EXP 50
32935: PUSH
32936: FOR_TO
32937: IFFALSE 33501
// begin if not mc_bases [ i ] then
32939: LD_EXP 50
32943: PUSH
32944: LD_VAR 0 2
32948: ARRAY
32949: NOT
32950: IFFALSE 32954
// continue ;
32952: GO 32936
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
32954: LD_ADDR_VAR 0 7
32958: PUSH
32959: LD_EXP 50
32963: PUSH
32964: LD_VAR 0 2
32968: ARRAY
32969: PUSH
32970: LD_INT 1
32972: ARRAY
32973: PPUSH
32974: CALL 51391 0 1
32978: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
32979: LD_ADDR_EXP 73
32983: PUSH
32984: LD_EXP 73
32988: PPUSH
32989: LD_VAR 0 2
32993: PPUSH
32994: LD_EXP 50
32998: PUSH
32999: LD_VAR 0 2
33003: ARRAY
33004: PUSH
33005: LD_INT 1
33007: ARRAY
33008: PPUSH
33009: CALL_OW 255
33013: PPUSH
33014: LD_EXP 75
33018: PUSH
33019: LD_VAR 0 2
33023: ARRAY
33024: PPUSH
33025: CALL 48945 0 2
33029: PPUSH
33030: CALL_OW 1
33034: ST_TO_ADDR
// if not mc_scan [ i ] then
33035: LD_EXP 73
33039: PUSH
33040: LD_VAR 0 2
33044: ARRAY
33045: NOT
33046: IFFALSE 33201
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
33048: LD_ADDR_VAR 0 4
33052: PUSH
33053: LD_EXP 50
33057: PUSH
33058: LD_VAR 0 2
33062: ARRAY
33063: PPUSH
33064: LD_INT 2
33066: PUSH
33067: LD_INT 25
33069: PUSH
33070: LD_INT 5
33072: PUSH
33073: EMPTY
33074: LIST
33075: LIST
33076: PUSH
33077: LD_INT 25
33079: PUSH
33080: LD_INT 8
33082: PUSH
33083: EMPTY
33084: LIST
33085: LIST
33086: PUSH
33087: LD_INT 25
33089: PUSH
33090: LD_INT 9
33092: PUSH
33093: EMPTY
33094: LIST
33095: LIST
33096: PUSH
33097: EMPTY
33098: LIST
33099: LIST
33100: LIST
33101: LIST
33102: PPUSH
33103: CALL_OW 72
33107: ST_TO_ADDR
// if not tmp then
33108: LD_VAR 0 4
33112: NOT
33113: IFFALSE 33117
// continue ;
33115: GO 32936
// for j in tmp do
33117: LD_ADDR_VAR 0 3
33121: PUSH
33122: LD_VAR 0 4
33126: PUSH
33127: FOR_IN
33128: IFFALSE 33199
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
33130: LD_VAR 0 3
33134: PPUSH
33135: CALL_OW 310
33139: PPUSH
33140: CALL_OW 266
33144: PUSH
33145: LD_INT 5
33147: EQUAL
33148: PUSH
33149: LD_VAR 0 3
33153: PPUSH
33154: CALL_OW 257
33158: PUSH
33159: LD_INT 1
33161: EQUAL
33162: AND
33163: PUSH
33164: LD_VAR 0 3
33168: PPUSH
33169: CALL_OW 459
33173: NOT
33174: AND
33175: PUSH
33176: LD_VAR 0 7
33180: AND
33181: IFFALSE 33197
// ComChangeProfession ( j , class ) ;
33183: LD_VAR 0 3
33187: PPUSH
33188: LD_VAR 0 7
33192: PPUSH
33193: CALL_OW 123
33197: GO 33127
33199: POP
33200: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
33201: LD_EXP 73
33205: PUSH
33206: LD_VAR 0 2
33210: ARRAY
33211: PUSH
33212: LD_EXP 72
33216: PUSH
33217: LD_VAR 0 2
33221: ARRAY
33222: NOT
33223: AND
33224: PUSH
33225: LD_EXP 50
33229: PUSH
33230: LD_VAR 0 2
33234: ARRAY
33235: PPUSH
33236: LD_INT 30
33238: PUSH
33239: LD_INT 32
33241: PUSH
33242: EMPTY
33243: LIST
33244: LIST
33245: PPUSH
33246: CALL_OW 72
33250: NOT
33251: AND
33252: PUSH
33253: LD_EXP 50
33257: PUSH
33258: LD_VAR 0 2
33262: ARRAY
33263: PPUSH
33264: LD_INT 2
33266: PUSH
33267: LD_INT 30
33269: PUSH
33270: LD_INT 4
33272: PUSH
33273: EMPTY
33274: LIST
33275: LIST
33276: PUSH
33277: LD_INT 30
33279: PUSH
33280: LD_INT 5
33282: PUSH
33283: EMPTY
33284: LIST
33285: LIST
33286: PUSH
33287: EMPTY
33288: LIST
33289: LIST
33290: LIST
33291: PPUSH
33292: CALL_OW 72
33296: NOT
33297: AND
33298: IFFALSE 33430
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
33300: LD_ADDR_VAR 0 4
33304: PUSH
33305: LD_EXP 50
33309: PUSH
33310: LD_VAR 0 2
33314: ARRAY
33315: PPUSH
33316: LD_INT 2
33318: PUSH
33319: LD_INT 25
33321: PUSH
33322: LD_INT 1
33324: PUSH
33325: EMPTY
33326: LIST
33327: LIST
33328: PUSH
33329: LD_INT 25
33331: PUSH
33332: LD_INT 5
33334: PUSH
33335: EMPTY
33336: LIST
33337: LIST
33338: PUSH
33339: LD_INT 25
33341: PUSH
33342: LD_INT 8
33344: PUSH
33345: EMPTY
33346: LIST
33347: LIST
33348: PUSH
33349: LD_INT 25
33351: PUSH
33352: LD_INT 9
33354: PUSH
33355: EMPTY
33356: LIST
33357: LIST
33358: PUSH
33359: EMPTY
33360: LIST
33361: LIST
33362: LIST
33363: LIST
33364: LIST
33365: PPUSH
33366: CALL_OW 72
33370: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
33371: LD_ADDR_VAR 0 4
33375: PUSH
33376: LD_VAR 0 4
33380: PUSH
33381: LD_VAR 0 4
33385: PPUSH
33386: LD_INT 18
33388: PPUSH
33389: CALL 87825 0 2
33393: DIFF
33394: ST_TO_ADDR
// if tmp then
33395: LD_VAR 0 4
33399: IFFALSE 33430
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
33401: LD_VAR 0 2
33405: PPUSH
33406: LD_VAR 0 4
33410: PPUSH
33411: LD_EXP 75
33415: PUSH
33416: LD_VAR 0 2
33420: ARRAY
33421: PPUSH
33422: CALL 48980 0 3
// exit ;
33426: POP
33427: POP
33428: GO 33503
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
33430: LD_EXP 73
33434: PUSH
33435: LD_VAR 0 2
33439: ARRAY
33440: PUSH
33441: LD_EXP 72
33445: PUSH
33446: LD_VAR 0 2
33450: ARRAY
33451: AND
33452: IFFALSE 33499
// begin tmp := mc_defender [ i ] ;
33454: LD_ADDR_VAR 0 4
33458: PUSH
33459: LD_EXP 72
33463: PUSH
33464: LD_VAR 0 2
33468: ARRAY
33469: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
33470: LD_VAR 0 2
33474: PPUSH
33475: LD_VAR 0 4
33479: PPUSH
33480: LD_EXP 73
33484: PUSH
33485: LD_VAR 0 2
33489: ARRAY
33490: PPUSH
33491: CALL 49541 0 3
// exit ;
33495: POP
33496: POP
33497: GO 33503
// end ; end ;
33499: GO 32936
33501: POP
33502: POP
// end ;
33503: LD_VAR 0 1
33507: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
33508: LD_INT 0
33510: PPUSH
33511: PPUSH
33512: PPUSH
33513: PPUSH
33514: PPUSH
33515: PPUSH
33516: PPUSH
33517: PPUSH
33518: PPUSH
33519: PPUSH
33520: PPUSH
// if not mc_bases then
33521: LD_EXP 50
33525: NOT
33526: IFFALSE 33530
// exit ;
33528: GO 34617
// for i = 1 to mc_bases do
33530: LD_ADDR_VAR 0 2
33534: PUSH
33535: DOUBLE
33536: LD_INT 1
33538: DEC
33539: ST_TO_ADDR
33540: LD_EXP 50
33544: PUSH
33545: FOR_TO
33546: IFFALSE 34615
// begin tmp := mc_lab [ i ] ;
33548: LD_ADDR_VAR 0 6
33552: PUSH
33553: LD_EXP 83
33557: PUSH
33558: LD_VAR 0 2
33562: ARRAY
33563: ST_TO_ADDR
// if not tmp then
33564: LD_VAR 0 6
33568: NOT
33569: IFFALSE 33573
// continue ;
33571: GO 33545
// idle_lab := 0 ;
33573: LD_ADDR_VAR 0 11
33577: PUSH
33578: LD_INT 0
33580: ST_TO_ADDR
// for j in tmp do
33581: LD_ADDR_VAR 0 3
33585: PUSH
33586: LD_VAR 0 6
33590: PUSH
33591: FOR_IN
33592: IFFALSE 34611
// begin researching := false ;
33594: LD_ADDR_VAR 0 10
33598: PUSH
33599: LD_INT 0
33601: ST_TO_ADDR
// side := GetSide ( j ) ;
33602: LD_ADDR_VAR 0 4
33606: PUSH
33607: LD_VAR 0 3
33611: PPUSH
33612: CALL_OW 255
33616: ST_TO_ADDR
// if not mc_tech [ side ] then
33617: LD_EXP 77
33621: PUSH
33622: LD_VAR 0 4
33626: ARRAY
33627: NOT
33628: IFFALSE 33632
// continue ;
33630: GO 33591
// if BuildingStatus ( j ) = bs_idle then
33632: LD_VAR 0 3
33636: PPUSH
33637: CALL_OW 461
33641: PUSH
33642: LD_INT 2
33644: EQUAL
33645: IFFALSE 33833
// begin if idle_lab and UnitsInside ( j ) < 6 then
33647: LD_VAR 0 11
33651: PUSH
33652: LD_VAR 0 3
33656: PPUSH
33657: CALL_OW 313
33661: PUSH
33662: LD_INT 6
33664: LESS
33665: AND
33666: IFFALSE 33737
// begin tmp2 := UnitsInside ( idle_lab ) ;
33668: LD_ADDR_VAR 0 9
33672: PUSH
33673: LD_VAR 0 11
33677: PPUSH
33678: CALL_OW 313
33682: ST_TO_ADDR
// if tmp2 then
33683: LD_VAR 0 9
33687: IFFALSE 33729
// for x in tmp2 do
33689: LD_ADDR_VAR 0 7
33693: PUSH
33694: LD_VAR 0 9
33698: PUSH
33699: FOR_IN
33700: IFFALSE 33727
// begin ComExitBuilding ( x ) ;
33702: LD_VAR 0 7
33706: PPUSH
33707: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
33711: LD_VAR 0 7
33715: PPUSH
33716: LD_VAR 0 3
33720: PPUSH
33721: CALL_OW 180
// end ;
33725: GO 33699
33727: POP
33728: POP
// idle_lab := 0 ;
33729: LD_ADDR_VAR 0 11
33733: PUSH
33734: LD_INT 0
33736: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
33737: LD_ADDR_VAR 0 5
33741: PUSH
33742: LD_EXP 77
33746: PUSH
33747: LD_VAR 0 4
33751: ARRAY
33752: PUSH
33753: FOR_IN
33754: IFFALSE 33814
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
33756: LD_VAR 0 3
33760: PPUSH
33761: LD_VAR 0 5
33765: PPUSH
33766: CALL_OW 430
33770: PUSH
33771: LD_VAR 0 4
33775: PPUSH
33776: LD_VAR 0 5
33780: PPUSH
33781: CALL 48050 0 2
33785: AND
33786: IFFALSE 33812
// begin researching := true ;
33788: LD_ADDR_VAR 0 10
33792: PUSH
33793: LD_INT 1
33795: ST_TO_ADDR
// ComResearch ( j , t ) ;
33796: LD_VAR 0 3
33800: PPUSH
33801: LD_VAR 0 5
33805: PPUSH
33806: CALL_OW 124
// break ;
33810: GO 33814
// end ;
33812: GO 33753
33814: POP
33815: POP
// if not researching then
33816: LD_VAR 0 10
33820: NOT
33821: IFFALSE 33833
// idle_lab := j ;
33823: LD_ADDR_VAR 0 11
33827: PUSH
33828: LD_VAR 0 3
33832: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
33833: LD_VAR 0 3
33837: PPUSH
33838: CALL_OW 461
33842: PUSH
33843: LD_INT 10
33845: EQUAL
33846: IFFALSE 34434
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
33848: LD_EXP 79
33852: PUSH
33853: LD_VAR 0 2
33857: ARRAY
33858: NOT
33859: PUSH
33860: LD_EXP 80
33864: PUSH
33865: LD_VAR 0 2
33869: ARRAY
33870: NOT
33871: AND
33872: PUSH
33873: LD_EXP 77
33877: PUSH
33878: LD_VAR 0 4
33882: ARRAY
33883: PUSH
33884: LD_INT 1
33886: GREATER
33887: AND
33888: IFFALSE 34019
// begin ComCancel ( j ) ;
33890: LD_VAR 0 3
33894: PPUSH
33895: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
33899: LD_ADDR_EXP 77
33903: PUSH
33904: LD_EXP 77
33908: PPUSH
33909: LD_VAR 0 4
33913: PPUSH
33914: LD_EXP 77
33918: PUSH
33919: LD_VAR 0 4
33923: ARRAY
33924: PPUSH
33925: LD_EXP 77
33929: PUSH
33930: LD_VAR 0 4
33934: ARRAY
33935: PUSH
33936: LD_INT 1
33938: MINUS
33939: PPUSH
33940: LD_EXP 77
33944: PUSH
33945: LD_VAR 0 4
33949: ARRAY
33950: PPUSH
33951: LD_INT 0
33953: PPUSH
33954: CALL 53973 0 4
33958: PPUSH
33959: CALL_OW 1
33963: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
33964: LD_ADDR_EXP 77
33968: PUSH
33969: LD_EXP 77
33973: PPUSH
33974: LD_VAR 0 4
33978: PPUSH
33979: LD_EXP 77
33983: PUSH
33984: LD_VAR 0 4
33988: ARRAY
33989: PPUSH
33990: LD_EXP 77
33994: PUSH
33995: LD_VAR 0 4
33999: ARRAY
34000: PPUSH
34001: LD_INT 1
34003: PPUSH
34004: LD_INT 0
34006: PPUSH
34007: CALL 53973 0 4
34011: PPUSH
34012: CALL_OW 1
34016: ST_TO_ADDR
// continue ;
34017: GO 33591
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
34019: LD_EXP 79
34023: PUSH
34024: LD_VAR 0 2
34028: ARRAY
34029: PUSH
34030: LD_EXP 80
34034: PUSH
34035: LD_VAR 0 2
34039: ARRAY
34040: NOT
34041: AND
34042: IFFALSE 34169
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
34044: LD_ADDR_EXP 80
34048: PUSH
34049: LD_EXP 80
34053: PPUSH
34054: LD_VAR 0 2
34058: PUSH
34059: LD_EXP 80
34063: PUSH
34064: LD_VAR 0 2
34068: ARRAY
34069: PUSH
34070: LD_INT 1
34072: PLUS
34073: PUSH
34074: EMPTY
34075: LIST
34076: LIST
34077: PPUSH
34078: LD_EXP 79
34082: PUSH
34083: LD_VAR 0 2
34087: ARRAY
34088: PUSH
34089: LD_INT 1
34091: ARRAY
34092: PPUSH
34093: CALL 54555 0 3
34097: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
34098: LD_EXP 79
34102: PUSH
34103: LD_VAR 0 2
34107: ARRAY
34108: PUSH
34109: LD_INT 1
34111: ARRAY
34112: PPUSH
34113: LD_INT 112
34115: PPUSH
34116: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
34120: LD_ADDR_VAR 0 9
34124: PUSH
34125: LD_EXP 79
34129: PUSH
34130: LD_VAR 0 2
34134: ARRAY
34135: PPUSH
34136: LD_INT 1
34138: PPUSH
34139: CALL_OW 3
34143: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
34144: LD_ADDR_EXP 79
34148: PUSH
34149: LD_EXP 79
34153: PPUSH
34154: LD_VAR 0 2
34158: PPUSH
34159: LD_VAR 0 9
34163: PPUSH
34164: CALL_OW 1
34168: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
34169: LD_EXP 79
34173: PUSH
34174: LD_VAR 0 2
34178: ARRAY
34179: PUSH
34180: LD_EXP 80
34184: PUSH
34185: LD_VAR 0 2
34189: ARRAY
34190: AND
34191: PUSH
34192: LD_EXP 80
34196: PUSH
34197: LD_VAR 0 2
34201: ARRAY
34202: PUSH
34203: LD_INT 1
34205: ARRAY
34206: PPUSH
34207: CALL_OW 310
34211: NOT
34212: AND
34213: PUSH
34214: LD_VAR 0 3
34218: PPUSH
34219: CALL_OW 313
34223: PUSH
34224: LD_INT 6
34226: EQUAL
34227: AND
34228: IFFALSE 34284
// begin tmp2 := UnitsInside ( j ) ;
34230: LD_ADDR_VAR 0 9
34234: PUSH
34235: LD_VAR 0 3
34239: PPUSH
34240: CALL_OW 313
34244: ST_TO_ADDR
// if tmp2 = 6 then
34245: LD_VAR 0 9
34249: PUSH
34250: LD_INT 6
34252: EQUAL
34253: IFFALSE 34284
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
34255: LD_VAR 0 9
34259: PUSH
34260: LD_INT 1
34262: ARRAY
34263: PPUSH
34264: LD_INT 112
34266: PPUSH
34267: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
34271: LD_VAR 0 9
34275: PUSH
34276: LD_INT 1
34278: ARRAY
34279: PPUSH
34280: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
34284: LD_EXP 80
34288: PUSH
34289: LD_VAR 0 2
34293: ARRAY
34294: PUSH
34295: LD_EXP 80
34299: PUSH
34300: LD_VAR 0 2
34304: ARRAY
34305: PUSH
34306: LD_INT 1
34308: ARRAY
34309: PPUSH
34310: CALL_OW 314
34314: NOT
34315: AND
34316: PUSH
34317: LD_EXP 80
34321: PUSH
34322: LD_VAR 0 2
34326: ARRAY
34327: PUSH
34328: LD_INT 1
34330: ARRAY
34331: PPUSH
34332: CALL_OW 310
34336: NOT
34337: AND
34338: IFFALSE 34364
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
34340: LD_EXP 80
34344: PUSH
34345: LD_VAR 0 2
34349: ARRAY
34350: PUSH
34351: LD_INT 1
34353: ARRAY
34354: PPUSH
34355: LD_VAR 0 3
34359: PPUSH
34360: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
34364: LD_EXP 80
34368: PUSH
34369: LD_VAR 0 2
34373: ARRAY
34374: PUSH
34375: LD_INT 1
34377: ARRAY
34378: PPUSH
34379: CALL_OW 310
34383: PUSH
34384: LD_EXP 80
34388: PUSH
34389: LD_VAR 0 2
34393: ARRAY
34394: PUSH
34395: LD_INT 1
34397: ARRAY
34398: PPUSH
34399: CALL_OW 310
34403: PPUSH
34404: CALL_OW 461
34408: PUSH
34409: LD_INT 3
34411: NONEQUAL
34412: AND
34413: IFFALSE 34434
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
34415: LD_EXP 80
34419: PUSH
34420: LD_VAR 0 2
34424: ARRAY
34425: PUSH
34426: LD_INT 1
34428: ARRAY
34429: PPUSH
34430: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
34434: LD_VAR 0 3
34438: PPUSH
34439: CALL_OW 461
34443: PUSH
34444: LD_INT 6
34446: EQUAL
34447: PUSH
34448: LD_VAR 0 6
34452: PUSH
34453: LD_INT 1
34455: GREATER
34456: AND
34457: IFFALSE 34609
// begin sci := [ ] ;
34459: LD_ADDR_VAR 0 8
34463: PUSH
34464: EMPTY
34465: ST_TO_ADDR
// for x in ( tmp diff j ) do
34466: LD_ADDR_VAR 0 7
34470: PUSH
34471: LD_VAR 0 6
34475: PUSH
34476: LD_VAR 0 3
34480: DIFF
34481: PUSH
34482: FOR_IN
34483: IFFALSE 34535
// begin if sci = 6 then
34485: LD_VAR 0 8
34489: PUSH
34490: LD_INT 6
34492: EQUAL
34493: IFFALSE 34497
// break ;
34495: GO 34535
// if BuildingStatus ( x ) = bs_idle then
34497: LD_VAR 0 7
34501: PPUSH
34502: CALL_OW 461
34506: PUSH
34507: LD_INT 2
34509: EQUAL
34510: IFFALSE 34533
// sci := sci ^ UnitsInside ( x ) ;
34512: LD_ADDR_VAR 0 8
34516: PUSH
34517: LD_VAR 0 8
34521: PUSH
34522: LD_VAR 0 7
34526: PPUSH
34527: CALL_OW 313
34531: ADD
34532: ST_TO_ADDR
// end ;
34533: GO 34482
34535: POP
34536: POP
// if not sci then
34537: LD_VAR 0 8
34541: NOT
34542: IFFALSE 34546
// continue ;
34544: GO 33591
// for x in sci do
34546: LD_ADDR_VAR 0 7
34550: PUSH
34551: LD_VAR 0 8
34555: PUSH
34556: FOR_IN
34557: IFFALSE 34607
// if IsInUnit ( x ) and not HasTask ( x ) then
34559: LD_VAR 0 7
34563: PPUSH
34564: CALL_OW 310
34568: PUSH
34569: LD_VAR 0 7
34573: PPUSH
34574: CALL_OW 314
34578: NOT
34579: AND
34580: IFFALSE 34605
// begin ComExitBuilding ( x ) ;
34582: LD_VAR 0 7
34586: PPUSH
34587: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
34591: LD_VAR 0 7
34595: PPUSH
34596: LD_VAR 0 3
34600: PPUSH
34601: CALL_OW 180
// end ;
34605: GO 34556
34607: POP
34608: POP
// end ; end ;
34609: GO 33591
34611: POP
34612: POP
// end ;
34613: GO 33545
34615: POP
34616: POP
// end ;
34617: LD_VAR 0 1
34621: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
34622: LD_INT 0
34624: PPUSH
34625: PPUSH
// if not mc_bases then
34626: LD_EXP 50
34630: NOT
34631: IFFALSE 34635
// exit ;
34633: GO 34716
// for i = 1 to mc_bases do
34635: LD_ADDR_VAR 0 2
34639: PUSH
34640: DOUBLE
34641: LD_INT 1
34643: DEC
34644: ST_TO_ADDR
34645: LD_EXP 50
34649: PUSH
34650: FOR_TO
34651: IFFALSE 34714
// if mc_mines [ i ] and mc_miners [ i ] then
34653: LD_EXP 63
34657: PUSH
34658: LD_VAR 0 2
34662: ARRAY
34663: PUSH
34664: LD_EXP 64
34668: PUSH
34669: LD_VAR 0 2
34673: ARRAY
34674: AND
34675: IFFALSE 34712
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
34677: LD_EXP 64
34681: PUSH
34682: LD_VAR 0 2
34686: ARRAY
34687: PUSH
34688: LD_INT 1
34690: ARRAY
34691: PPUSH
34692: CALL_OW 255
34696: PPUSH
34697: LD_EXP 63
34701: PUSH
34702: LD_VAR 0 2
34706: ARRAY
34707: PPUSH
34708: CALL 51544 0 2
34712: GO 34650
34714: POP
34715: POP
// end ;
34716: LD_VAR 0 1
34720: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
34721: LD_INT 0
34723: PPUSH
34724: PPUSH
34725: PPUSH
34726: PPUSH
34727: PPUSH
34728: PPUSH
34729: PPUSH
34730: PPUSH
// if not mc_bases or not mc_parking then
34731: LD_EXP 50
34735: NOT
34736: PUSH
34737: LD_EXP 74
34741: NOT
34742: OR
34743: IFFALSE 34747
// exit ;
34745: GO 35446
// for i = 1 to mc_bases do
34747: LD_ADDR_VAR 0 2
34751: PUSH
34752: DOUBLE
34753: LD_INT 1
34755: DEC
34756: ST_TO_ADDR
34757: LD_EXP 50
34761: PUSH
34762: FOR_TO
34763: IFFALSE 35444
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
34765: LD_EXP 50
34769: PUSH
34770: LD_VAR 0 2
34774: ARRAY
34775: NOT
34776: PUSH
34777: LD_EXP 74
34781: PUSH
34782: LD_VAR 0 2
34786: ARRAY
34787: NOT
34788: OR
34789: IFFALSE 34793
// continue ;
34791: GO 34762
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
34793: LD_ADDR_VAR 0 5
34797: PUSH
34798: LD_EXP 50
34802: PUSH
34803: LD_VAR 0 2
34807: ARRAY
34808: PUSH
34809: LD_INT 1
34811: ARRAY
34812: PPUSH
34813: CALL_OW 255
34817: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
34818: LD_ADDR_VAR 0 6
34822: PUSH
34823: LD_EXP 50
34827: PUSH
34828: LD_VAR 0 2
34832: ARRAY
34833: PPUSH
34834: LD_INT 30
34836: PUSH
34837: LD_INT 3
34839: PUSH
34840: EMPTY
34841: LIST
34842: LIST
34843: PPUSH
34844: CALL_OW 72
34848: ST_TO_ADDR
// if not fac then
34849: LD_VAR 0 6
34853: NOT
34854: IFFALSE 34905
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
34856: LD_ADDR_VAR 0 6
34860: PUSH
34861: LD_EXP 50
34865: PUSH
34866: LD_VAR 0 2
34870: ARRAY
34871: PPUSH
34872: LD_INT 2
34874: PUSH
34875: LD_INT 30
34877: PUSH
34878: LD_INT 0
34880: PUSH
34881: EMPTY
34882: LIST
34883: LIST
34884: PUSH
34885: LD_INT 30
34887: PUSH
34888: LD_INT 1
34890: PUSH
34891: EMPTY
34892: LIST
34893: LIST
34894: PUSH
34895: EMPTY
34896: LIST
34897: LIST
34898: LIST
34899: PPUSH
34900: CALL_OW 72
34904: ST_TO_ADDR
// if not fac then
34905: LD_VAR 0 6
34909: NOT
34910: IFFALSE 34914
// continue ;
34912: GO 34762
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
34914: LD_ADDR_VAR 0 7
34918: PUSH
34919: LD_EXP 74
34923: PUSH
34924: LD_VAR 0 2
34928: ARRAY
34929: PPUSH
34930: LD_INT 22
34932: PUSH
34933: LD_VAR 0 5
34937: PUSH
34938: EMPTY
34939: LIST
34940: LIST
34941: PUSH
34942: LD_INT 21
34944: PUSH
34945: LD_INT 2
34947: PUSH
34948: EMPTY
34949: LIST
34950: LIST
34951: PUSH
34952: LD_INT 3
34954: PUSH
34955: LD_INT 24
34957: PUSH
34958: LD_INT 1000
34960: PUSH
34961: EMPTY
34962: LIST
34963: LIST
34964: PUSH
34965: EMPTY
34966: LIST
34967: LIST
34968: PUSH
34969: EMPTY
34970: LIST
34971: LIST
34972: LIST
34973: PPUSH
34974: CALL_OW 70
34978: ST_TO_ADDR
// for j in fac do
34979: LD_ADDR_VAR 0 3
34983: PUSH
34984: LD_VAR 0 6
34988: PUSH
34989: FOR_IN
34990: IFFALSE 35071
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
34992: LD_ADDR_VAR 0 7
34996: PUSH
34997: LD_VAR 0 7
35001: PUSH
35002: LD_INT 22
35004: PUSH
35005: LD_VAR 0 5
35009: PUSH
35010: EMPTY
35011: LIST
35012: LIST
35013: PUSH
35014: LD_INT 91
35016: PUSH
35017: LD_VAR 0 3
35021: PUSH
35022: LD_INT 15
35024: PUSH
35025: EMPTY
35026: LIST
35027: LIST
35028: LIST
35029: PUSH
35030: LD_INT 21
35032: PUSH
35033: LD_INT 2
35035: PUSH
35036: EMPTY
35037: LIST
35038: LIST
35039: PUSH
35040: LD_INT 3
35042: PUSH
35043: LD_INT 24
35045: PUSH
35046: LD_INT 1000
35048: PUSH
35049: EMPTY
35050: LIST
35051: LIST
35052: PUSH
35053: EMPTY
35054: LIST
35055: LIST
35056: PUSH
35057: EMPTY
35058: LIST
35059: LIST
35060: LIST
35061: LIST
35062: PPUSH
35063: CALL_OW 69
35067: UNION
35068: ST_TO_ADDR
35069: GO 34989
35071: POP
35072: POP
// if not vehs then
35073: LD_VAR 0 7
35077: NOT
35078: IFFALSE 35104
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
35080: LD_ADDR_EXP 62
35084: PUSH
35085: LD_EXP 62
35089: PPUSH
35090: LD_VAR 0 2
35094: PPUSH
35095: EMPTY
35096: PPUSH
35097: CALL_OW 1
35101: ST_TO_ADDR
// continue ;
35102: GO 34762
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
35104: LD_ADDR_VAR 0 8
35108: PUSH
35109: LD_EXP 50
35113: PUSH
35114: LD_VAR 0 2
35118: ARRAY
35119: PPUSH
35120: LD_INT 30
35122: PUSH
35123: LD_INT 3
35125: PUSH
35126: EMPTY
35127: LIST
35128: LIST
35129: PPUSH
35130: CALL_OW 72
35134: ST_TO_ADDR
// if tmp then
35135: LD_VAR 0 8
35139: IFFALSE 35242
// begin for j in tmp do
35141: LD_ADDR_VAR 0 3
35145: PUSH
35146: LD_VAR 0 8
35150: PUSH
35151: FOR_IN
35152: IFFALSE 35240
// for k in UnitsInside ( j ) do
35154: LD_ADDR_VAR 0 4
35158: PUSH
35159: LD_VAR 0 3
35163: PPUSH
35164: CALL_OW 313
35168: PUSH
35169: FOR_IN
35170: IFFALSE 35236
// if k then
35172: LD_VAR 0 4
35176: IFFALSE 35234
// if not k in mc_repair_vehicle [ i ] then
35178: LD_VAR 0 4
35182: PUSH
35183: LD_EXP 62
35187: PUSH
35188: LD_VAR 0 2
35192: ARRAY
35193: IN
35194: NOT
35195: IFFALSE 35234
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
35197: LD_ADDR_EXP 62
35201: PUSH
35202: LD_EXP 62
35206: PPUSH
35207: LD_VAR 0 2
35211: PPUSH
35212: LD_EXP 62
35216: PUSH
35217: LD_VAR 0 2
35221: ARRAY
35222: PUSH
35223: LD_VAR 0 4
35227: UNION
35228: PPUSH
35229: CALL_OW 1
35233: ST_TO_ADDR
35234: GO 35169
35236: POP
35237: POP
35238: GO 35151
35240: POP
35241: POP
// end ; if not mc_repair_vehicle [ i ] then
35242: LD_EXP 62
35246: PUSH
35247: LD_VAR 0 2
35251: ARRAY
35252: NOT
35253: IFFALSE 35257
// continue ;
35255: GO 34762
// for j in mc_repair_vehicle [ i ] do
35257: LD_ADDR_VAR 0 3
35261: PUSH
35262: LD_EXP 62
35266: PUSH
35267: LD_VAR 0 2
35271: ARRAY
35272: PUSH
35273: FOR_IN
35274: IFFALSE 35440
// begin if GetClass ( j ) <> 3 then
35276: LD_VAR 0 3
35280: PPUSH
35281: CALL_OW 257
35285: PUSH
35286: LD_INT 3
35288: NONEQUAL
35289: IFFALSE 35330
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
35291: LD_ADDR_EXP 62
35295: PUSH
35296: LD_EXP 62
35300: PPUSH
35301: LD_VAR 0 2
35305: PPUSH
35306: LD_EXP 62
35310: PUSH
35311: LD_VAR 0 2
35315: ARRAY
35316: PUSH
35317: LD_VAR 0 3
35321: DIFF
35322: PPUSH
35323: CALL_OW 1
35327: ST_TO_ADDR
// continue ;
35328: GO 35273
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
35330: LD_VAR 0 3
35334: PPUSH
35335: CALL_OW 311
35339: NOT
35340: PUSH
35341: LD_VAR 0 3
35345: PUSH
35346: LD_EXP 53
35350: PUSH
35351: LD_VAR 0 2
35355: ARRAY
35356: PUSH
35357: LD_INT 1
35359: ARRAY
35360: IN
35361: NOT
35362: AND
35363: PUSH
35364: LD_VAR 0 3
35368: PUSH
35369: LD_EXP 53
35373: PUSH
35374: LD_VAR 0 2
35378: ARRAY
35379: PUSH
35380: LD_INT 2
35382: ARRAY
35383: IN
35384: NOT
35385: AND
35386: IFFALSE 35438
// begin if IsInUnit ( j ) then
35388: LD_VAR 0 3
35392: PPUSH
35393: CALL_OW 310
35397: IFFALSE 35408
// ComExitBuilding ( j ) ;
35399: LD_VAR 0 3
35403: PPUSH
35404: CALL_OW 122
// if not HasTask ( j ) then
35408: LD_VAR 0 3
35412: PPUSH
35413: CALL_OW 314
35417: NOT
35418: IFFALSE 35438
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
35420: LD_VAR 0 3
35424: PPUSH
35425: LD_VAR 0 7
35429: PUSH
35430: LD_INT 1
35432: ARRAY
35433: PPUSH
35434: CALL_OW 189
// end ; end ;
35438: GO 35273
35440: POP
35441: POP
// end ;
35442: GO 34762
35444: POP
35445: POP
// end ;
35446: LD_VAR 0 1
35450: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
35451: LD_INT 0
35453: PPUSH
35454: PPUSH
35455: PPUSH
35456: PPUSH
35457: PPUSH
35458: PPUSH
35459: PPUSH
35460: PPUSH
35461: PPUSH
35462: PPUSH
35463: PPUSH
// if not mc_bases then
35464: LD_EXP 50
35468: NOT
35469: IFFALSE 35473
// exit ;
35471: GO 36275
// for i = 1 to mc_bases do
35473: LD_ADDR_VAR 0 2
35477: PUSH
35478: DOUBLE
35479: LD_INT 1
35481: DEC
35482: ST_TO_ADDR
35483: LD_EXP 50
35487: PUSH
35488: FOR_TO
35489: IFFALSE 36273
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
35491: LD_EXP 78
35495: PUSH
35496: LD_VAR 0 2
35500: ARRAY
35501: NOT
35502: PUSH
35503: LD_EXP 53
35507: PUSH
35508: LD_VAR 0 2
35512: ARRAY
35513: PUSH
35514: LD_INT 1
35516: ARRAY
35517: OR
35518: PUSH
35519: LD_EXP 53
35523: PUSH
35524: LD_VAR 0 2
35528: ARRAY
35529: PUSH
35530: LD_INT 2
35532: ARRAY
35533: OR
35534: PUSH
35535: LD_EXP 76
35539: PUSH
35540: LD_VAR 0 2
35544: ARRAY
35545: PPUSH
35546: LD_INT 1
35548: PPUSH
35549: CALL_OW 325
35553: NOT
35554: OR
35555: PUSH
35556: LD_EXP 73
35560: PUSH
35561: LD_VAR 0 2
35565: ARRAY
35566: OR
35567: IFFALSE 35571
// continue ;
35569: GO 35488
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
35571: LD_ADDR_VAR 0 8
35575: PUSH
35576: LD_EXP 50
35580: PUSH
35581: LD_VAR 0 2
35585: ARRAY
35586: PPUSH
35587: LD_INT 25
35589: PUSH
35590: LD_INT 4
35592: PUSH
35593: EMPTY
35594: LIST
35595: LIST
35596: PUSH
35597: LD_INT 50
35599: PUSH
35600: EMPTY
35601: LIST
35602: PUSH
35603: LD_INT 3
35605: PUSH
35606: LD_INT 60
35608: PUSH
35609: EMPTY
35610: LIST
35611: PUSH
35612: EMPTY
35613: LIST
35614: LIST
35615: PUSH
35616: EMPTY
35617: LIST
35618: LIST
35619: LIST
35620: PPUSH
35621: CALL_OW 72
35625: PUSH
35626: LD_EXP 54
35630: PUSH
35631: LD_VAR 0 2
35635: ARRAY
35636: DIFF
35637: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
35638: LD_ADDR_VAR 0 9
35642: PUSH
35643: LD_EXP 50
35647: PUSH
35648: LD_VAR 0 2
35652: ARRAY
35653: PPUSH
35654: LD_INT 2
35656: PUSH
35657: LD_INT 30
35659: PUSH
35660: LD_INT 0
35662: PUSH
35663: EMPTY
35664: LIST
35665: LIST
35666: PUSH
35667: LD_INT 30
35669: PUSH
35670: LD_INT 1
35672: PUSH
35673: EMPTY
35674: LIST
35675: LIST
35676: PUSH
35677: EMPTY
35678: LIST
35679: LIST
35680: LIST
35681: PPUSH
35682: CALL_OW 72
35686: ST_TO_ADDR
// if not tmp or not dep then
35687: LD_VAR 0 8
35691: NOT
35692: PUSH
35693: LD_VAR 0 9
35697: NOT
35698: OR
35699: IFFALSE 35703
// continue ;
35701: GO 35488
// side := GetSide ( tmp [ 1 ] ) ;
35703: LD_ADDR_VAR 0 11
35707: PUSH
35708: LD_VAR 0 8
35712: PUSH
35713: LD_INT 1
35715: ARRAY
35716: PPUSH
35717: CALL_OW 255
35721: ST_TO_ADDR
// dep := dep [ 1 ] ;
35722: LD_ADDR_VAR 0 9
35726: PUSH
35727: LD_VAR 0 9
35731: PUSH
35732: LD_INT 1
35734: ARRAY
35735: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
35736: LD_ADDR_VAR 0 7
35740: PUSH
35741: LD_EXP 78
35745: PUSH
35746: LD_VAR 0 2
35750: ARRAY
35751: PPUSH
35752: LD_INT 22
35754: PUSH
35755: LD_INT 0
35757: PUSH
35758: EMPTY
35759: LIST
35760: LIST
35761: PUSH
35762: LD_INT 25
35764: PUSH
35765: LD_INT 12
35767: PUSH
35768: EMPTY
35769: LIST
35770: LIST
35771: PUSH
35772: EMPTY
35773: LIST
35774: LIST
35775: PPUSH
35776: CALL_OW 70
35780: PUSH
35781: LD_INT 22
35783: PUSH
35784: LD_INT 0
35786: PUSH
35787: EMPTY
35788: LIST
35789: LIST
35790: PUSH
35791: LD_INT 25
35793: PUSH
35794: LD_INT 12
35796: PUSH
35797: EMPTY
35798: LIST
35799: LIST
35800: PUSH
35801: LD_INT 91
35803: PUSH
35804: LD_VAR 0 9
35808: PUSH
35809: LD_INT 20
35811: PUSH
35812: EMPTY
35813: LIST
35814: LIST
35815: LIST
35816: PUSH
35817: EMPTY
35818: LIST
35819: LIST
35820: LIST
35821: PPUSH
35822: CALL_OW 69
35826: UNION
35827: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
35828: LD_ADDR_VAR 0 10
35832: PUSH
35833: LD_EXP 78
35837: PUSH
35838: LD_VAR 0 2
35842: ARRAY
35843: PPUSH
35844: LD_INT 81
35846: PUSH
35847: LD_VAR 0 11
35851: PUSH
35852: EMPTY
35853: LIST
35854: LIST
35855: PPUSH
35856: CALL_OW 70
35860: ST_TO_ADDR
// if not apes or danger_at_area then
35861: LD_VAR 0 7
35865: NOT
35866: PUSH
35867: LD_VAR 0 10
35871: OR
35872: IFFALSE 35922
// begin if mc_taming [ i ] then
35874: LD_EXP 81
35878: PUSH
35879: LD_VAR 0 2
35883: ARRAY
35884: IFFALSE 35920
// begin MC_Reset ( i , 121 ) ;
35886: LD_VAR 0 2
35890: PPUSH
35891: LD_INT 121
35893: PPUSH
35894: CALL 21357 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
35898: LD_ADDR_EXP 81
35902: PUSH
35903: LD_EXP 81
35907: PPUSH
35908: LD_VAR 0 2
35912: PPUSH
35913: EMPTY
35914: PPUSH
35915: CALL_OW 1
35919: ST_TO_ADDR
// end ; continue ;
35920: GO 35488
// end ; for j in tmp do
35922: LD_ADDR_VAR 0 3
35926: PUSH
35927: LD_VAR 0 8
35931: PUSH
35932: FOR_IN
35933: IFFALSE 36269
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
35935: LD_VAR 0 3
35939: PUSH
35940: LD_EXP 81
35944: PUSH
35945: LD_VAR 0 2
35949: ARRAY
35950: IN
35951: NOT
35952: PUSH
35953: LD_EXP 81
35957: PUSH
35958: LD_VAR 0 2
35962: ARRAY
35963: PUSH
35964: LD_INT 3
35966: LESS
35967: AND
35968: IFFALSE 36026
// begin SetTag ( j , 121 ) ;
35970: LD_VAR 0 3
35974: PPUSH
35975: LD_INT 121
35977: PPUSH
35978: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
35982: LD_ADDR_EXP 81
35986: PUSH
35987: LD_EXP 81
35991: PPUSH
35992: LD_VAR 0 2
35996: PUSH
35997: LD_EXP 81
36001: PUSH
36002: LD_VAR 0 2
36006: ARRAY
36007: PUSH
36008: LD_INT 1
36010: PLUS
36011: PUSH
36012: EMPTY
36013: LIST
36014: LIST
36015: PPUSH
36016: LD_VAR 0 3
36020: PPUSH
36021: CALL 54555 0 3
36025: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
36026: LD_VAR 0 3
36030: PUSH
36031: LD_EXP 81
36035: PUSH
36036: LD_VAR 0 2
36040: ARRAY
36041: IN
36042: IFFALSE 36267
// begin if GetClass ( j ) <> 4 then
36044: LD_VAR 0 3
36048: PPUSH
36049: CALL_OW 257
36053: PUSH
36054: LD_INT 4
36056: NONEQUAL
36057: IFFALSE 36110
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
36059: LD_ADDR_EXP 81
36063: PUSH
36064: LD_EXP 81
36068: PPUSH
36069: LD_VAR 0 2
36073: PPUSH
36074: LD_EXP 81
36078: PUSH
36079: LD_VAR 0 2
36083: ARRAY
36084: PUSH
36085: LD_VAR 0 3
36089: DIFF
36090: PPUSH
36091: CALL_OW 1
36095: ST_TO_ADDR
// SetTag ( j , 0 ) ;
36096: LD_VAR 0 3
36100: PPUSH
36101: LD_INT 0
36103: PPUSH
36104: CALL_OW 109
// continue ;
36108: GO 35932
// end ; if IsInUnit ( j ) then
36110: LD_VAR 0 3
36114: PPUSH
36115: CALL_OW 310
36119: IFFALSE 36130
// ComExitBuilding ( j ) ;
36121: LD_VAR 0 3
36125: PPUSH
36126: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
36130: LD_ADDR_VAR 0 6
36134: PUSH
36135: LD_VAR 0 7
36139: PPUSH
36140: LD_VAR 0 3
36144: PPUSH
36145: CALL_OW 74
36149: ST_TO_ADDR
// if not ape then
36150: LD_VAR 0 6
36154: NOT
36155: IFFALSE 36159
// break ;
36157: GO 36269
// x := GetX ( ape ) ;
36159: LD_ADDR_VAR 0 4
36163: PUSH
36164: LD_VAR 0 6
36168: PPUSH
36169: CALL_OW 250
36173: ST_TO_ADDR
// y := GetY ( ape ) ;
36174: LD_ADDR_VAR 0 5
36178: PUSH
36179: LD_VAR 0 6
36183: PPUSH
36184: CALL_OW 251
36188: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
36189: LD_VAR 0 4
36193: PPUSH
36194: LD_VAR 0 5
36198: PPUSH
36199: CALL_OW 488
36203: NOT
36204: PUSH
36205: LD_VAR 0 11
36209: PPUSH
36210: LD_VAR 0 4
36214: PPUSH
36215: LD_VAR 0 5
36219: PPUSH
36220: LD_INT 20
36222: PPUSH
36223: CALL 55451 0 4
36227: PUSH
36228: LD_INT 4
36230: ARRAY
36231: OR
36232: IFFALSE 36236
// break ;
36234: GO 36269
// if not HasTask ( j ) then
36236: LD_VAR 0 3
36240: PPUSH
36241: CALL_OW 314
36245: NOT
36246: IFFALSE 36267
// ComTameXY ( j , x , y ) ;
36248: LD_VAR 0 3
36252: PPUSH
36253: LD_VAR 0 4
36257: PPUSH
36258: LD_VAR 0 5
36262: PPUSH
36263: CALL_OW 131
// end ; end ;
36267: GO 35932
36269: POP
36270: POP
// end ;
36271: GO 35488
36273: POP
36274: POP
// end ;
36275: LD_VAR 0 1
36279: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
36280: LD_INT 0
36282: PPUSH
36283: PPUSH
36284: PPUSH
36285: PPUSH
36286: PPUSH
36287: PPUSH
36288: PPUSH
36289: PPUSH
// if not mc_bases then
36290: LD_EXP 50
36294: NOT
36295: IFFALSE 36299
// exit ;
36297: GO 36925
// for i = 1 to mc_bases do
36299: LD_ADDR_VAR 0 2
36303: PUSH
36304: DOUBLE
36305: LD_INT 1
36307: DEC
36308: ST_TO_ADDR
36309: LD_EXP 50
36313: PUSH
36314: FOR_TO
36315: IFFALSE 36923
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
36317: LD_EXP 79
36321: PUSH
36322: LD_VAR 0 2
36326: ARRAY
36327: NOT
36328: PUSH
36329: LD_EXP 79
36333: PUSH
36334: LD_VAR 0 2
36338: ARRAY
36339: PPUSH
36340: LD_INT 25
36342: PUSH
36343: LD_INT 12
36345: PUSH
36346: EMPTY
36347: LIST
36348: LIST
36349: PPUSH
36350: CALL_OW 72
36354: NOT
36355: OR
36356: IFFALSE 36360
// continue ;
36358: GO 36314
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
36360: LD_ADDR_VAR 0 5
36364: PUSH
36365: LD_EXP 79
36369: PUSH
36370: LD_VAR 0 2
36374: ARRAY
36375: PUSH
36376: LD_INT 1
36378: ARRAY
36379: PPUSH
36380: CALL_OW 255
36384: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
36385: LD_VAR 0 5
36389: PPUSH
36390: LD_INT 2
36392: PPUSH
36393: CALL_OW 325
36397: IFFALSE 36650
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
36399: LD_ADDR_VAR 0 4
36403: PUSH
36404: LD_EXP 79
36408: PUSH
36409: LD_VAR 0 2
36413: ARRAY
36414: PPUSH
36415: LD_INT 25
36417: PUSH
36418: LD_INT 16
36420: PUSH
36421: EMPTY
36422: LIST
36423: LIST
36424: PPUSH
36425: CALL_OW 72
36429: ST_TO_ADDR
// if tmp < 6 then
36430: LD_VAR 0 4
36434: PUSH
36435: LD_INT 6
36437: LESS
36438: IFFALSE 36650
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
36440: LD_ADDR_VAR 0 6
36444: PUSH
36445: LD_EXP 50
36449: PUSH
36450: LD_VAR 0 2
36454: ARRAY
36455: PPUSH
36456: LD_INT 2
36458: PUSH
36459: LD_INT 30
36461: PUSH
36462: LD_INT 0
36464: PUSH
36465: EMPTY
36466: LIST
36467: LIST
36468: PUSH
36469: LD_INT 30
36471: PUSH
36472: LD_INT 1
36474: PUSH
36475: EMPTY
36476: LIST
36477: LIST
36478: PUSH
36479: EMPTY
36480: LIST
36481: LIST
36482: LIST
36483: PPUSH
36484: CALL_OW 72
36488: ST_TO_ADDR
// if depot then
36489: LD_VAR 0 6
36493: IFFALSE 36650
// begin selected := 0 ;
36495: LD_ADDR_VAR 0 7
36499: PUSH
36500: LD_INT 0
36502: ST_TO_ADDR
// for j in depot do
36503: LD_ADDR_VAR 0 3
36507: PUSH
36508: LD_VAR 0 6
36512: PUSH
36513: FOR_IN
36514: IFFALSE 36545
// begin if UnitsInside ( j ) < 6 then
36516: LD_VAR 0 3
36520: PPUSH
36521: CALL_OW 313
36525: PUSH
36526: LD_INT 6
36528: LESS
36529: IFFALSE 36543
// begin selected := j ;
36531: LD_ADDR_VAR 0 7
36535: PUSH
36536: LD_VAR 0 3
36540: ST_TO_ADDR
// break ;
36541: GO 36545
// end ; end ;
36543: GO 36513
36545: POP
36546: POP
// if selected then
36547: LD_VAR 0 7
36551: IFFALSE 36650
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
36553: LD_ADDR_VAR 0 3
36557: PUSH
36558: LD_EXP 79
36562: PUSH
36563: LD_VAR 0 2
36567: ARRAY
36568: PPUSH
36569: LD_INT 25
36571: PUSH
36572: LD_INT 12
36574: PUSH
36575: EMPTY
36576: LIST
36577: LIST
36578: PPUSH
36579: CALL_OW 72
36583: PUSH
36584: FOR_IN
36585: IFFALSE 36648
// if not HasTask ( j ) then
36587: LD_VAR 0 3
36591: PPUSH
36592: CALL_OW 314
36596: NOT
36597: IFFALSE 36646
// begin if not IsInUnit ( j ) then
36599: LD_VAR 0 3
36603: PPUSH
36604: CALL_OW 310
36608: NOT
36609: IFFALSE 36625
// ComEnterUnit ( j , selected ) ;
36611: LD_VAR 0 3
36615: PPUSH
36616: LD_VAR 0 7
36620: PPUSH
36621: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
36625: LD_VAR 0 3
36629: PPUSH
36630: LD_INT 16
36632: PPUSH
36633: CALL_OW 183
// AddComExitBuilding ( j ) ;
36637: LD_VAR 0 3
36641: PPUSH
36642: CALL_OW 182
// end ;
36646: GO 36584
36648: POP
36649: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
36650: LD_VAR 0 5
36654: PPUSH
36655: LD_INT 11
36657: PPUSH
36658: CALL_OW 325
36662: IFFALSE 36921
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
36664: LD_ADDR_VAR 0 4
36668: PUSH
36669: LD_EXP 79
36673: PUSH
36674: LD_VAR 0 2
36678: ARRAY
36679: PPUSH
36680: LD_INT 25
36682: PUSH
36683: LD_INT 16
36685: PUSH
36686: EMPTY
36687: LIST
36688: LIST
36689: PPUSH
36690: CALL_OW 72
36694: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
36695: LD_VAR 0 4
36699: PUSH
36700: LD_INT 6
36702: GREATEREQUAL
36703: PUSH
36704: LD_VAR 0 5
36708: PPUSH
36709: LD_INT 2
36711: PPUSH
36712: CALL_OW 325
36716: NOT
36717: OR
36718: IFFALSE 36921
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
36720: LD_ADDR_VAR 0 8
36724: PUSH
36725: LD_EXP 50
36729: PUSH
36730: LD_VAR 0 2
36734: ARRAY
36735: PPUSH
36736: LD_INT 2
36738: PUSH
36739: LD_INT 30
36741: PUSH
36742: LD_INT 4
36744: PUSH
36745: EMPTY
36746: LIST
36747: LIST
36748: PUSH
36749: LD_INT 30
36751: PUSH
36752: LD_INT 5
36754: PUSH
36755: EMPTY
36756: LIST
36757: LIST
36758: PUSH
36759: EMPTY
36760: LIST
36761: LIST
36762: LIST
36763: PPUSH
36764: CALL_OW 72
36768: ST_TO_ADDR
// if barracks then
36769: LD_VAR 0 8
36773: IFFALSE 36921
// begin selected := 0 ;
36775: LD_ADDR_VAR 0 7
36779: PUSH
36780: LD_INT 0
36782: ST_TO_ADDR
// for j in barracks do
36783: LD_ADDR_VAR 0 3
36787: PUSH
36788: LD_VAR 0 8
36792: PUSH
36793: FOR_IN
36794: IFFALSE 36825
// begin if UnitsInside ( j ) < 6 then
36796: LD_VAR 0 3
36800: PPUSH
36801: CALL_OW 313
36805: PUSH
36806: LD_INT 6
36808: LESS
36809: IFFALSE 36823
// begin selected := j ;
36811: LD_ADDR_VAR 0 7
36815: PUSH
36816: LD_VAR 0 3
36820: ST_TO_ADDR
// break ;
36821: GO 36825
// end ; end ;
36823: GO 36793
36825: POP
36826: POP
// if selected then
36827: LD_VAR 0 7
36831: IFFALSE 36921
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
36833: LD_ADDR_VAR 0 3
36837: PUSH
36838: LD_EXP 79
36842: PUSH
36843: LD_VAR 0 2
36847: ARRAY
36848: PPUSH
36849: LD_INT 25
36851: PUSH
36852: LD_INT 12
36854: PUSH
36855: EMPTY
36856: LIST
36857: LIST
36858: PPUSH
36859: CALL_OW 72
36863: PUSH
36864: FOR_IN
36865: IFFALSE 36919
// if not IsInUnit ( j ) and not HasTask ( j ) then
36867: LD_VAR 0 3
36871: PPUSH
36872: CALL_OW 310
36876: NOT
36877: PUSH
36878: LD_VAR 0 3
36882: PPUSH
36883: CALL_OW 314
36887: NOT
36888: AND
36889: IFFALSE 36917
// begin ComEnterUnit ( j , selected ) ;
36891: LD_VAR 0 3
36895: PPUSH
36896: LD_VAR 0 7
36900: PPUSH
36901: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
36905: LD_VAR 0 3
36909: PPUSH
36910: LD_INT 15
36912: PPUSH
36913: CALL_OW 183
// end ;
36917: GO 36864
36919: POP
36920: POP
// end ; end ; end ; end ; end ;
36921: GO 36314
36923: POP
36924: POP
// end ;
36925: LD_VAR 0 1
36929: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
36930: LD_INT 0
36932: PPUSH
36933: PPUSH
36934: PPUSH
36935: PPUSH
// if not mc_bases then
36936: LD_EXP 50
36940: NOT
36941: IFFALSE 36945
// exit ;
36943: GO 37123
// for i = 1 to mc_bases do
36945: LD_ADDR_VAR 0 2
36949: PUSH
36950: DOUBLE
36951: LD_INT 1
36953: DEC
36954: ST_TO_ADDR
36955: LD_EXP 50
36959: PUSH
36960: FOR_TO
36961: IFFALSE 37121
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
36963: LD_ADDR_VAR 0 4
36967: PUSH
36968: LD_EXP 50
36972: PUSH
36973: LD_VAR 0 2
36977: ARRAY
36978: PPUSH
36979: LD_INT 25
36981: PUSH
36982: LD_INT 9
36984: PUSH
36985: EMPTY
36986: LIST
36987: LIST
36988: PPUSH
36989: CALL_OW 72
36993: ST_TO_ADDR
// if not tmp then
36994: LD_VAR 0 4
36998: NOT
36999: IFFALSE 37003
// continue ;
37001: GO 36960
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
37003: LD_EXP 76
37007: PUSH
37008: LD_VAR 0 2
37012: ARRAY
37013: PPUSH
37014: LD_INT 29
37016: PPUSH
37017: CALL_OW 325
37021: NOT
37022: PUSH
37023: LD_EXP 76
37027: PUSH
37028: LD_VAR 0 2
37032: ARRAY
37033: PPUSH
37034: LD_INT 28
37036: PPUSH
37037: CALL_OW 325
37041: NOT
37042: AND
37043: IFFALSE 37047
// continue ;
37045: GO 36960
// for j in tmp do
37047: LD_ADDR_VAR 0 3
37051: PUSH
37052: LD_VAR 0 4
37056: PUSH
37057: FOR_IN
37058: IFFALSE 37117
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
37060: LD_VAR 0 3
37064: PUSH
37065: LD_EXP 53
37069: PUSH
37070: LD_VAR 0 2
37074: ARRAY
37075: PUSH
37076: LD_INT 1
37078: ARRAY
37079: IN
37080: NOT
37081: PUSH
37082: LD_VAR 0 3
37086: PUSH
37087: LD_EXP 53
37091: PUSH
37092: LD_VAR 0 2
37096: ARRAY
37097: PUSH
37098: LD_INT 2
37100: ARRAY
37101: IN
37102: NOT
37103: AND
37104: IFFALSE 37115
// ComSpaceTimeShoot ( j ) ;
37106: LD_VAR 0 3
37110: PPUSH
37111: CALL 48141 0 1
37115: GO 37057
37117: POP
37118: POP
// end ;
37119: GO 36960
37121: POP
37122: POP
// end ;
37123: LD_VAR 0 1
37127: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
37128: LD_INT 0
37130: PPUSH
37131: PPUSH
37132: PPUSH
37133: PPUSH
37134: PPUSH
37135: PPUSH
37136: PPUSH
37137: PPUSH
37138: PPUSH
// if not mc_bases then
37139: LD_EXP 50
37143: NOT
37144: IFFALSE 37148
// exit ;
37146: GO 37770
// for i = 1 to mc_bases do
37148: LD_ADDR_VAR 0 2
37152: PUSH
37153: DOUBLE
37154: LD_INT 1
37156: DEC
37157: ST_TO_ADDR
37158: LD_EXP 50
37162: PUSH
37163: FOR_TO
37164: IFFALSE 37768
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
37166: LD_EXP 85
37170: PUSH
37171: LD_VAR 0 2
37175: ARRAY
37176: NOT
37177: PUSH
37178: LD_INT 38
37180: PPUSH
37181: LD_EXP 76
37185: PUSH
37186: LD_VAR 0 2
37190: ARRAY
37191: PPUSH
37192: CALL_OW 321
37196: PUSH
37197: LD_INT 2
37199: NONEQUAL
37200: OR
37201: IFFALSE 37205
// continue ;
37203: GO 37163
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
37205: LD_ADDR_VAR 0 8
37209: PUSH
37210: LD_EXP 50
37214: PUSH
37215: LD_VAR 0 2
37219: ARRAY
37220: PPUSH
37221: LD_INT 30
37223: PUSH
37224: LD_INT 34
37226: PUSH
37227: EMPTY
37228: LIST
37229: LIST
37230: PPUSH
37231: CALL_OW 72
37235: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
37236: LD_ADDR_VAR 0 9
37240: PUSH
37241: LD_EXP 50
37245: PUSH
37246: LD_VAR 0 2
37250: ARRAY
37251: PPUSH
37252: LD_INT 25
37254: PUSH
37255: LD_INT 4
37257: PUSH
37258: EMPTY
37259: LIST
37260: LIST
37261: PPUSH
37262: CALL_OW 72
37266: PPUSH
37267: LD_INT 0
37269: PPUSH
37270: CALL 87825 0 2
37274: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
37275: LD_VAR 0 9
37279: NOT
37280: PUSH
37281: LD_VAR 0 8
37285: NOT
37286: OR
37287: PUSH
37288: LD_EXP 50
37292: PUSH
37293: LD_VAR 0 2
37297: ARRAY
37298: PPUSH
37299: LD_INT 124
37301: PPUSH
37302: CALL 87825 0 2
37306: OR
37307: IFFALSE 37311
// continue ;
37309: GO 37163
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
37311: LD_EXP 86
37315: PUSH
37316: LD_VAR 0 2
37320: ARRAY
37321: PUSH
37322: LD_EXP 85
37326: PUSH
37327: LD_VAR 0 2
37331: ARRAY
37332: LESS
37333: PUSH
37334: LD_EXP 86
37338: PUSH
37339: LD_VAR 0 2
37343: ARRAY
37344: PUSH
37345: LD_VAR 0 8
37349: LESS
37350: AND
37351: IFFALSE 37766
// begin tmp := sci [ 1 ] ;
37353: LD_ADDR_VAR 0 7
37357: PUSH
37358: LD_VAR 0 9
37362: PUSH
37363: LD_INT 1
37365: ARRAY
37366: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
37367: LD_VAR 0 7
37371: PPUSH
37372: LD_INT 124
37374: PPUSH
37375: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
37379: LD_ADDR_VAR 0 3
37383: PUSH
37384: DOUBLE
37385: LD_EXP 85
37389: PUSH
37390: LD_VAR 0 2
37394: ARRAY
37395: INC
37396: ST_TO_ADDR
37397: LD_EXP 85
37401: PUSH
37402: LD_VAR 0 2
37406: ARRAY
37407: PUSH
37408: FOR_DOWNTO
37409: IFFALSE 37752
// begin if IsInUnit ( tmp ) then
37411: LD_VAR 0 7
37415: PPUSH
37416: CALL_OW 310
37420: IFFALSE 37431
// ComExitBuilding ( tmp ) ;
37422: LD_VAR 0 7
37426: PPUSH
37427: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
37431: LD_INT 35
37433: PPUSH
37434: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
37438: LD_VAR 0 7
37442: PPUSH
37443: CALL_OW 310
37447: NOT
37448: PUSH
37449: LD_VAR 0 7
37453: PPUSH
37454: CALL_OW 314
37458: NOT
37459: AND
37460: IFFALSE 37431
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
37462: LD_ADDR_VAR 0 6
37466: PUSH
37467: LD_VAR 0 7
37471: PPUSH
37472: CALL_OW 250
37476: PUSH
37477: LD_VAR 0 7
37481: PPUSH
37482: CALL_OW 251
37486: PUSH
37487: EMPTY
37488: LIST
37489: LIST
37490: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
37491: LD_INT 35
37493: PPUSH
37494: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
37498: LD_ADDR_VAR 0 4
37502: PUSH
37503: LD_EXP 85
37507: PUSH
37508: LD_VAR 0 2
37512: ARRAY
37513: PUSH
37514: LD_VAR 0 3
37518: ARRAY
37519: PUSH
37520: LD_INT 1
37522: ARRAY
37523: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
37524: LD_ADDR_VAR 0 5
37528: PUSH
37529: LD_EXP 85
37533: PUSH
37534: LD_VAR 0 2
37538: ARRAY
37539: PUSH
37540: LD_VAR 0 3
37544: ARRAY
37545: PUSH
37546: LD_INT 2
37548: ARRAY
37549: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
37550: LD_VAR 0 7
37554: PPUSH
37555: LD_INT 10
37557: PPUSH
37558: CALL 57148 0 2
37562: PUSH
37563: LD_INT 4
37565: ARRAY
37566: IFFALSE 37604
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
37568: LD_VAR 0 7
37572: PPUSH
37573: LD_VAR 0 6
37577: PUSH
37578: LD_INT 1
37580: ARRAY
37581: PPUSH
37582: LD_VAR 0 6
37586: PUSH
37587: LD_INT 2
37589: ARRAY
37590: PPUSH
37591: CALL_OW 111
// wait ( 0 0$10 ) ;
37595: LD_INT 350
37597: PPUSH
37598: CALL_OW 67
// end else
37602: GO 37630
// begin ComMoveXY ( tmp , x , y ) ;
37604: LD_VAR 0 7
37608: PPUSH
37609: LD_VAR 0 4
37613: PPUSH
37614: LD_VAR 0 5
37618: PPUSH
37619: CALL_OW 111
// wait ( 0 0$3 ) ;
37623: LD_INT 105
37625: PPUSH
37626: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
37630: LD_VAR 0 7
37634: PPUSH
37635: LD_VAR 0 4
37639: PPUSH
37640: LD_VAR 0 5
37644: PPUSH
37645: CALL_OW 307
37649: IFFALSE 37491
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
37651: LD_VAR 0 7
37655: PPUSH
37656: LD_VAR 0 4
37660: PPUSH
37661: LD_VAR 0 5
37665: PPUSH
37666: LD_VAR 0 8
37670: PUSH
37671: LD_VAR 0 3
37675: ARRAY
37676: PPUSH
37677: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
37681: LD_INT 35
37683: PPUSH
37684: CALL_OW 67
// until not HasTask ( tmp ) ;
37688: LD_VAR 0 7
37692: PPUSH
37693: CALL_OW 314
37697: NOT
37698: IFFALSE 37681
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
37700: LD_ADDR_EXP 86
37704: PUSH
37705: LD_EXP 86
37709: PPUSH
37710: LD_VAR 0 2
37714: PUSH
37715: LD_EXP 86
37719: PUSH
37720: LD_VAR 0 2
37724: ARRAY
37725: PUSH
37726: LD_INT 1
37728: PLUS
37729: PUSH
37730: EMPTY
37731: LIST
37732: LIST
37733: PPUSH
37734: LD_VAR 0 8
37738: PUSH
37739: LD_VAR 0 3
37743: ARRAY
37744: PPUSH
37745: CALL 54555 0 3
37749: ST_TO_ADDR
// end ;
37750: GO 37408
37752: POP
37753: POP
// MC_Reset ( i , 124 ) ;
37754: LD_VAR 0 2
37758: PPUSH
37759: LD_INT 124
37761: PPUSH
37762: CALL 21357 0 2
// end ; end ;
37766: GO 37163
37768: POP
37769: POP
// end ;
37770: LD_VAR 0 1
37774: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
37775: LD_INT 0
37777: PPUSH
37778: PPUSH
37779: PPUSH
// if not mc_bases then
37780: LD_EXP 50
37784: NOT
37785: IFFALSE 37789
// exit ;
37787: GO 38395
// for i = 1 to mc_bases do
37789: LD_ADDR_VAR 0 2
37793: PUSH
37794: DOUBLE
37795: LD_INT 1
37797: DEC
37798: ST_TO_ADDR
37799: LD_EXP 50
37803: PUSH
37804: FOR_TO
37805: IFFALSE 38393
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
37807: LD_ADDR_VAR 0 3
37811: PUSH
37812: LD_EXP 50
37816: PUSH
37817: LD_VAR 0 2
37821: ARRAY
37822: PPUSH
37823: LD_INT 25
37825: PUSH
37826: LD_INT 4
37828: PUSH
37829: EMPTY
37830: LIST
37831: LIST
37832: PPUSH
37833: CALL_OW 72
37837: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
37838: LD_VAR 0 3
37842: NOT
37843: PUSH
37844: LD_EXP 87
37848: PUSH
37849: LD_VAR 0 2
37853: ARRAY
37854: NOT
37855: OR
37856: PUSH
37857: LD_EXP 50
37861: PUSH
37862: LD_VAR 0 2
37866: ARRAY
37867: PPUSH
37868: LD_INT 2
37870: PUSH
37871: LD_INT 30
37873: PUSH
37874: LD_INT 0
37876: PUSH
37877: EMPTY
37878: LIST
37879: LIST
37880: PUSH
37881: LD_INT 30
37883: PUSH
37884: LD_INT 1
37886: PUSH
37887: EMPTY
37888: LIST
37889: LIST
37890: PUSH
37891: EMPTY
37892: LIST
37893: LIST
37894: LIST
37895: PPUSH
37896: CALL_OW 72
37900: NOT
37901: OR
37902: IFFALSE 37952
// begin if mc_deposits_finder [ i ] then
37904: LD_EXP 88
37908: PUSH
37909: LD_VAR 0 2
37913: ARRAY
37914: IFFALSE 37950
// begin MC_Reset ( i , 125 ) ;
37916: LD_VAR 0 2
37920: PPUSH
37921: LD_INT 125
37923: PPUSH
37924: CALL 21357 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
37928: LD_ADDR_EXP 88
37932: PUSH
37933: LD_EXP 88
37937: PPUSH
37938: LD_VAR 0 2
37942: PPUSH
37943: EMPTY
37944: PPUSH
37945: CALL_OW 1
37949: ST_TO_ADDR
// end ; continue ;
37950: GO 37804
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
37952: LD_EXP 87
37956: PUSH
37957: LD_VAR 0 2
37961: ARRAY
37962: PUSH
37963: LD_INT 1
37965: ARRAY
37966: PUSH
37967: LD_INT 3
37969: ARRAY
37970: PUSH
37971: LD_INT 1
37973: EQUAL
37974: PUSH
37975: LD_INT 20
37977: PPUSH
37978: LD_EXP 76
37982: PUSH
37983: LD_VAR 0 2
37987: ARRAY
37988: PPUSH
37989: CALL_OW 321
37993: PUSH
37994: LD_INT 2
37996: NONEQUAL
37997: AND
37998: IFFALSE 38048
// begin if mc_deposits_finder [ i ] then
38000: LD_EXP 88
38004: PUSH
38005: LD_VAR 0 2
38009: ARRAY
38010: IFFALSE 38046
// begin MC_Reset ( i , 125 ) ;
38012: LD_VAR 0 2
38016: PPUSH
38017: LD_INT 125
38019: PPUSH
38020: CALL 21357 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
38024: LD_ADDR_EXP 88
38028: PUSH
38029: LD_EXP 88
38033: PPUSH
38034: LD_VAR 0 2
38038: PPUSH
38039: EMPTY
38040: PPUSH
38041: CALL_OW 1
38045: ST_TO_ADDR
// end ; continue ;
38046: GO 37804
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
38048: LD_EXP 87
38052: PUSH
38053: LD_VAR 0 2
38057: ARRAY
38058: PUSH
38059: LD_INT 1
38061: ARRAY
38062: PUSH
38063: LD_INT 1
38065: ARRAY
38066: PPUSH
38067: LD_EXP 87
38071: PUSH
38072: LD_VAR 0 2
38076: ARRAY
38077: PUSH
38078: LD_INT 1
38080: ARRAY
38081: PUSH
38082: LD_INT 2
38084: ARRAY
38085: PPUSH
38086: LD_EXP 76
38090: PUSH
38091: LD_VAR 0 2
38095: ARRAY
38096: PPUSH
38097: CALL_OW 440
38101: IFFALSE 38144
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
38103: LD_ADDR_EXP 87
38107: PUSH
38108: LD_EXP 87
38112: PPUSH
38113: LD_VAR 0 2
38117: PPUSH
38118: LD_EXP 87
38122: PUSH
38123: LD_VAR 0 2
38127: ARRAY
38128: PPUSH
38129: LD_INT 1
38131: PPUSH
38132: CALL_OW 3
38136: PPUSH
38137: CALL_OW 1
38141: ST_TO_ADDR
38142: GO 38391
// begin if not mc_deposits_finder [ i ] then
38144: LD_EXP 88
38148: PUSH
38149: LD_VAR 0 2
38153: ARRAY
38154: NOT
38155: IFFALSE 38207
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
38157: LD_ADDR_EXP 88
38161: PUSH
38162: LD_EXP 88
38166: PPUSH
38167: LD_VAR 0 2
38171: PPUSH
38172: LD_VAR 0 3
38176: PUSH
38177: LD_INT 1
38179: ARRAY
38180: PUSH
38181: EMPTY
38182: LIST
38183: PPUSH
38184: CALL_OW 1
38188: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
38189: LD_VAR 0 3
38193: PUSH
38194: LD_INT 1
38196: ARRAY
38197: PPUSH
38198: LD_INT 125
38200: PPUSH
38201: CALL_OW 109
// end else
38205: GO 38391
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
38207: LD_EXP 88
38211: PUSH
38212: LD_VAR 0 2
38216: ARRAY
38217: PUSH
38218: LD_INT 1
38220: ARRAY
38221: PPUSH
38222: CALL_OW 310
38226: IFFALSE 38249
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
38228: LD_EXP 88
38232: PUSH
38233: LD_VAR 0 2
38237: ARRAY
38238: PUSH
38239: LD_INT 1
38241: ARRAY
38242: PPUSH
38243: CALL_OW 122
38247: GO 38391
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
38249: LD_EXP 88
38253: PUSH
38254: LD_VAR 0 2
38258: ARRAY
38259: PUSH
38260: LD_INT 1
38262: ARRAY
38263: PPUSH
38264: CALL_OW 314
38268: NOT
38269: PUSH
38270: LD_EXP 88
38274: PUSH
38275: LD_VAR 0 2
38279: ARRAY
38280: PUSH
38281: LD_INT 1
38283: ARRAY
38284: PPUSH
38285: LD_EXP 87
38289: PUSH
38290: LD_VAR 0 2
38294: ARRAY
38295: PUSH
38296: LD_INT 1
38298: ARRAY
38299: PUSH
38300: LD_INT 1
38302: ARRAY
38303: PPUSH
38304: LD_EXP 87
38308: PUSH
38309: LD_VAR 0 2
38313: ARRAY
38314: PUSH
38315: LD_INT 1
38317: ARRAY
38318: PUSH
38319: LD_INT 2
38321: ARRAY
38322: PPUSH
38323: CALL_OW 297
38327: PUSH
38328: LD_INT 6
38330: GREATER
38331: AND
38332: IFFALSE 38391
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
38334: LD_EXP 88
38338: PUSH
38339: LD_VAR 0 2
38343: ARRAY
38344: PUSH
38345: LD_INT 1
38347: ARRAY
38348: PPUSH
38349: LD_EXP 87
38353: PUSH
38354: LD_VAR 0 2
38358: ARRAY
38359: PUSH
38360: LD_INT 1
38362: ARRAY
38363: PUSH
38364: LD_INT 1
38366: ARRAY
38367: PPUSH
38368: LD_EXP 87
38372: PUSH
38373: LD_VAR 0 2
38377: ARRAY
38378: PUSH
38379: LD_INT 1
38381: ARRAY
38382: PUSH
38383: LD_INT 2
38385: ARRAY
38386: PPUSH
38387: CALL_OW 111
// end ; end ; end ;
38391: GO 37804
38393: POP
38394: POP
// end ;
38395: LD_VAR 0 1
38399: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
38400: LD_INT 0
38402: PPUSH
38403: PPUSH
38404: PPUSH
38405: PPUSH
38406: PPUSH
38407: PPUSH
38408: PPUSH
38409: PPUSH
38410: PPUSH
38411: PPUSH
38412: PPUSH
// if not mc_bases then
38413: LD_EXP 50
38417: NOT
38418: IFFALSE 38422
// exit ;
38420: GO 39362
// for i = 1 to mc_bases do
38422: LD_ADDR_VAR 0 2
38426: PUSH
38427: DOUBLE
38428: LD_INT 1
38430: DEC
38431: ST_TO_ADDR
38432: LD_EXP 50
38436: PUSH
38437: FOR_TO
38438: IFFALSE 39360
// begin if not mc_bases [ i ] or mc_scan [ i ] then
38440: LD_EXP 50
38444: PUSH
38445: LD_VAR 0 2
38449: ARRAY
38450: NOT
38451: PUSH
38452: LD_EXP 73
38456: PUSH
38457: LD_VAR 0 2
38461: ARRAY
38462: OR
38463: IFFALSE 38467
// continue ;
38465: GO 38437
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
38467: LD_ADDR_VAR 0 7
38471: PUSH
38472: LD_EXP 50
38476: PUSH
38477: LD_VAR 0 2
38481: ARRAY
38482: PUSH
38483: LD_INT 1
38485: ARRAY
38486: PPUSH
38487: CALL_OW 248
38491: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
38492: LD_VAR 0 7
38496: PUSH
38497: LD_INT 3
38499: EQUAL
38500: PUSH
38501: LD_EXP 69
38505: PUSH
38506: LD_VAR 0 2
38510: ARRAY
38511: PUSH
38512: LD_EXP 72
38516: PUSH
38517: LD_VAR 0 2
38521: ARRAY
38522: UNION
38523: PPUSH
38524: LD_INT 33
38526: PUSH
38527: LD_INT 2
38529: PUSH
38530: EMPTY
38531: LIST
38532: LIST
38533: PPUSH
38534: CALL_OW 72
38538: NOT
38539: OR
38540: IFFALSE 38544
// continue ;
38542: GO 38437
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
38544: LD_ADDR_VAR 0 9
38548: PUSH
38549: LD_EXP 50
38553: PUSH
38554: LD_VAR 0 2
38558: ARRAY
38559: PPUSH
38560: LD_INT 30
38562: PUSH
38563: LD_INT 36
38565: PUSH
38566: EMPTY
38567: LIST
38568: LIST
38569: PPUSH
38570: CALL_OW 72
38574: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
38575: LD_ADDR_VAR 0 10
38579: PUSH
38580: LD_EXP 69
38584: PUSH
38585: LD_VAR 0 2
38589: ARRAY
38590: PPUSH
38591: LD_INT 34
38593: PUSH
38594: LD_INT 31
38596: PUSH
38597: EMPTY
38598: LIST
38599: LIST
38600: PPUSH
38601: CALL_OW 72
38605: ST_TO_ADDR
// if not cts and not mcts then
38606: LD_VAR 0 9
38610: NOT
38611: PUSH
38612: LD_VAR 0 10
38616: NOT
38617: AND
38618: IFFALSE 38622
// continue ;
38620: GO 38437
// x := cts ;
38622: LD_ADDR_VAR 0 11
38626: PUSH
38627: LD_VAR 0 9
38631: ST_TO_ADDR
// if not x then
38632: LD_VAR 0 11
38636: NOT
38637: IFFALSE 38649
// x := mcts ;
38639: LD_ADDR_VAR 0 11
38643: PUSH
38644: LD_VAR 0 10
38648: ST_TO_ADDR
// if not x then
38649: LD_VAR 0 11
38653: NOT
38654: IFFALSE 38658
// continue ;
38656: GO 38437
// if mc_remote_driver [ i ] then
38658: LD_EXP 90
38662: PUSH
38663: LD_VAR 0 2
38667: ARRAY
38668: IFFALSE 39055
// for j in mc_remote_driver [ i ] do
38670: LD_ADDR_VAR 0 3
38674: PUSH
38675: LD_EXP 90
38679: PUSH
38680: LD_VAR 0 2
38684: ARRAY
38685: PUSH
38686: FOR_IN
38687: IFFALSE 39053
// begin if GetClass ( j ) <> 3 then
38689: LD_VAR 0 3
38693: PPUSH
38694: CALL_OW 257
38698: PUSH
38699: LD_INT 3
38701: NONEQUAL
38702: IFFALSE 38755
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
38704: LD_ADDR_EXP 90
38708: PUSH
38709: LD_EXP 90
38713: PPUSH
38714: LD_VAR 0 2
38718: PPUSH
38719: LD_EXP 90
38723: PUSH
38724: LD_VAR 0 2
38728: ARRAY
38729: PUSH
38730: LD_VAR 0 3
38734: DIFF
38735: PPUSH
38736: CALL_OW 1
38740: ST_TO_ADDR
// SetTag ( j , 0 ) ;
38741: LD_VAR 0 3
38745: PPUSH
38746: LD_INT 0
38748: PPUSH
38749: CALL_OW 109
// continue ;
38753: GO 38686
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
38755: LD_EXP 69
38759: PUSH
38760: LD_VAR 0 2
38764: ARRAY
38765: PPUSH
38766: LD_INT 34
38768: PUSH
38769: LD_INT 31
38771: PUSH
38772: EMPTY
38773: LIST
38774: LIST
38775: PUSH
38776: LD_INT 58
38778: PUSH
38779: EMPTY
38780: LIST
38781: PUSH
38782: EMPTY
38783: LIST
38784: LIST
38785: PPUSH
38786: CALL_OW 72
38790: PUSH
38791: LD_VAR 0 3
38795: PPUSH
38796: CALL 87913 0 1
38800: NOT
38801: AND
38802: IFFALSE 38873
// begin if IsInUnit ( j ) then
38804: LD_VAR 0 3
38808: PPUSH
38809: CALL_OW 310
38813: IFFALSE 38824
// ComExitBuilding ( j ) ;
38815: LD_VAR 0 3
38819: PPUSH
38820: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
38824: LD_VAR 0 3
38828: PPUSH
38829: LD_EXP 69
38833: PUSH
38834: LD_VAR 0 2
38838: ARRAY
38839: PPUSH
38840: LD_INT 34
38842: PUSH
38843: LD_INT 31
38845: PUSH
38846: EMPTY
38847: LIST
38848: LIST
38849: PUSH
38850: LD_INT 58
38852: PUSH
38853: EMPTY
38854: LIST
38855: PUSH
38856: EMPTY
38857: LIST
38858: LIST
38859: PPUSH
38860: CALL_OW 72
38864: PUSH
38865: LD_INT 1
38867: ARRAY
38868: PPUSH
38869: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
38873: LD_VAR 0 3
38877: PPUSH
38878: CALL_OW 310
38882: NOT
38883: PUSH
38884: LD_VAR 0 3
38888: PPUSH
38889: CALL_OW 310
38893: PPUSH
38894: CALL_OW 266
38898: PUSH
38899: LD_INT 36
38901: NONEQUAL
38902: PUSH
38903: LD_VAR 0 3
38907: PPUSH
38908: CALL 87913 0 1
38912: NOT
38913: AND
38914: OR
38915: IFFALSE 39051
// begin if IsInUnit ( j ) then
38917: LD_VAR 0 3
38921: PPUSH
38922: CALL_OW 310
38926: IFFALSE 38937
// ComExitBuilding ( j ) ;
38928: LD_VAR 0 3
38932: PPUSH
38933: CALL_OW 122
// ct := 0 ;
38937: LD_ADDR_VAR 0 8
38941: PUSH
38942: LD_INT 0
38944: ST_TO_ADDR
// for k in x do
38945: LD_ADDR_VAR 0 4
38949: PUSH
38950: LD_VAR 0 11
38954: PUSH
38955: FOR_IN
38956: IFFALSE 39029
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
38958: LD_VAR 0 4
38962: PPUSH
38963: CALL_OW 264
38967: PUSH
38968: LD_INT 31
38970: EQUAL
38971: PUSH
38972: LD_VAR 0 4
38976: PPUSH
38977: CALL_OW 311
38981: NOT
38982: AND
38983: PUSH
38984: LD_VAR 0 4
38988: PPUSH
38989: CALL_OW 266
38993: PUSH
38994: LD_INT 36
38996: EQUAL
38997: PUSH
38998: LD_VAR 0 4
39002: PPUSH
39003: CALL_OW 313
39007: PUSH
39008: LD_INT 3
39010: LESS
39011: AND
39012: OR
39013: IFFALSE 39027
// begin ct := k ;
39015: LD_ADDR_VAR 0 8
39019: PUSH
39020: LD_VAR 0 4
39024: ST_TO_ADDR
// break ;
39025: GO 39029
// end ;
39027: GO 38955
39029: POP
39030: POP
// if ct then
39031: LD_VAR 0 8
39035: IFFALSE 39051
// ComEnterUnit ( j , ct ) ;
39037: LD_VAR 0 3
39041: PPUSH
39042: LD_VAR 0 8
39046: PPUSH
39047: CALL_OW 120
// end ; end ;
39051: GO 38686
39053: POP
39054: POP
// places := 0 ;
39055: LD_ADDR_VAR 0 5
39059: PUSH
39060: LD_INT 0
39062: ST_TO_ADDR
// for j = 1 to x do
39063: LD_ADDR_VAR 0 3
39067: PUSH
39068: DOUBLE
39069: LD_INT 1
39071: DEC
39072: ST_TO_ADDR
39073: LD_VAR 0 11
39077: PUSH
39078: FOR_TO
39079: IFFALSE 39155
// if GetWeapon ( x [ j ] ) = ar_control_tower then
39081: LD_VAR 0 11
39085: PUSH
39086: LD_VAR 0 3
39090: ARRAY
39091: PPUSH
39092: CALL_OW 264
39096: PUSH
39097: LD_INT 31
39099: EQUAL
39100: IFFALSE 39118
// places := places + 1 else
39102: LD_ADDR_VAR 0 5
39106: PUSH
39107: LD_VAR 0 5
39111: PUSH
39112: LD_INT 1
39114: PLUS
39115: ST_TO_ADDR
39116: GO 39153
// if GetBType ( x [ j ] ) = b_control_tower then
39118: LD_VAR 0 11
39122: PUSH
39123: LD_VAR 0 3
39127: ARRAY
39128: PPUSH
39129: CALL_OW 266
39133: PUSH
39134: LD_INT 36
39136: EQUAL
39137: IFFALSE 39153
// places := places + 3 ;
39139: LD_ADDR_VAR 0 5
39143: PUSH
39144: LD_VAR 0 5
39148: PUSH
39149: LD_INT 3
39151: PLUS
39152: ST_TO_ADDR
39153: GO 39078
39155: POP
39156: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
39157: LD_VAR 0 5
39161: PUSH
39162: LD_INT 0
39164: EQUAL
39165: PUSH
39166: LD_VAR 0 5
39170: PUSH
39171: LD_EXP 90
39175: PUSH
39176: LD_VAR 0 2
39180: ARRAY
39181: LESSEQUAL
39182: OR
39183: IFFALSE 39187
// continue ;
39185: GO 38437
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
39187: LD_ADDR_VAR 0 6
39191: PUSH
39192: LD_EXP 50
39196: PUSH
39197: LD_VAR 0 2
39201: ARRAY
39202: PPUSH
39203: LD_INT 25
39205: PUSH
39206: LD_INT 3
39208: PUSH
39209: EMPTY
39210: LIST
39211: LIST
39212: PPUSH
39213: CALL_OW 72
39217: PUSH
39218: LD_EXP 90
39222: PUSH
39223: LD_VAR 0 2
39227: ARRAY
39228: DIFF
39229: PPUSH
39230: LD_INT 3
39232: PPUSH
39233: CALL 88813 0 2
39237: ST_TO_ADDR
// for j in tmp do
39238: LD_ADDR_VAR 0 3
39242: PUSH
39243: LD_VAR 0 6
39247: PUSH
39248: FOR_IN
39249: IFFALSE 39284
// if GetTag ( j ) > 0 then
39251: LD_VAR 0 3
39255: PPUSH
39256: CALL_OW 110
39260: PUSH
39261: LD_INT 0
39263: GREATER
39264: IFFALSE 39282
// tmp := tmp diff j ;
39266: LD_ADDR_VAR 0 6
39270: PUSH
39271: LD_VAR 0 6
39275: PUSH
39276: LD_VAR 0 3
39280: DIFF
39281: ST_TO_ADDR
39282: GO 39248
39284: POP
39285: POP
// if not tmp then
39286: LD_VAR 0 6
39290: NOT
39291: IFFALSE 39295
// continue ;
39293: GO 38437
// if places then
39295: LD_VAR 0 5
39299: IFFALSE 39358
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
39301: LD_ADDR_EXP 90
39305: PUSH
39306: LD_EXP 90
39310: PPUSH
39311: LD_VAR 0 2
39315: PPUSH
39316: LD_EXP 90
39320: PUSH
39321: LD_VAR 0 2
39325: ARRAY
39326: PUSH
39327: LD_VAR 0 6
39331: PUSH
39332: LD_INT 1
39334: ARRAY
39335: UNION
39336: PPUSH
39337: CALL_OW 1
39341: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
39342: LD_VAR 0 6
39346: PUSH
39347: LD_INT 1
39349: ARRAY
39350: PPUSH
39351: LD_INT 126
39353: PPUSH
39354: CALL_OW 109
// end ; end ;
39358: GO 38437
39360: POP
39361: POP
// end ;
39362: LD_VAR 0 1
39366: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
39367: LD_INT 0
39369: PPUSH
39370: PPUSH
39371: PPUSH
39372: PPUSH
39373: PPUSH
39374: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
39375: LD_VAR 0 1
39379: NOT
39380: PUSH
39381: LD_VAR 0 2
39385: NOT
39386: OR
39387: PUSH
39388: LD_VAR 0 3
39392: NOT
39393: OR
39394: PUSH
39395: LD_VAR 0 4
39399: PUSH
39400: LD_INT 1
39402: PUSH
39403: LD_INT 2
39405: PUSH
39406: LD_INT 3
39408: PUSH
39409: LD_INT 4
39411: PUSH
39412: LD_INT 5
39414: PUSH
39415: LD_INT 8
39417: PUSH
39418: LD_INT 9
39420: PUSH
39421: LD_INT 15
39423: PUSH
39424: LD_INT 16
39426: PUSH
39427: EMPTY
39428: LIST
39429: LIST
39430: LIST
39431: LIST
39432: LIST
39433: LIST
39434: LIST
39435: LIST
39436: LIST
39437: IN
39438: NOT
39439: OR
39440: IFFALSE 39444
// exit ;
39442: GO 40344
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
39444: LD_ADDR_VAR 0 2
39448: PUSH
39449: LD_VAR 0 2
39453: PPUSH
39454: LD_INT 21
39456: PUSH
39457: LD_INT 3
39459: PUSH
39460: EMPTY
39461: LIST
39462: LIST
39463: PUSH
39464: LD_INT 24
39466: PUSH
39467: LD_INT 250
39469: PUSH
39470: EMPTY
39471: LIST
39472: LIST
39473: PUSH
39474: EMPTY
39475: LIST
39476: LIST
39477: PPUSH
39478: CALL_OW 72
39482: ST_TO_ADDR
// case class of 1 , 15 :
39483: LD_VAR 0 4
39487: PUSH
39488: LD_INT 1
39490: DOUBLE
39491: EQUAL
39492: IFTRUE 39502
39494: LD_INT 15
39496: DOUBLE
39497: EQUAL
39498: IFTRUE 39502
39500: GO 39587
39502: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
39503: LD_ADDR_VAR 0 8
39507: PUSH
39508: LD_VAR 0 2
39512: PPUSH
39513: LD_INT 2
39515: PUSH
39516: LD_INT 30
39518: PUSH
39519: LD_INT 32
39521: PUSH
39522: EMPTY
39523: LIST
39524: LIST
39525: PUSH
39526: LD_INT 30
39528: PUSH
39529: LD_INT 31
39531: PUSH
39532: EMPTY
39533: LIST
39534: LIST
39535: PUSH
39536: EMPTY
39537: LIST
39538: LIST
39539: LIST
39540: PPUSH
39541: CALL_OW 72
39545: PUSH
39546: LD_VAR 0 2
39550: PPUSH
39551: LD_INT 2
39553: PUSH
39554: LD_INT 30
39556: PUSH
39557: LD_INT 4
39559: PUSH
39560: EMPTY
39561: LIST
39562: LIST
39563: PUSH
39564: LD_INT 30
39566: PUSH
39567: LD_INT 5
39569: PUSH
39570: EMPTY
39571: LIST
39572: LIST
39573: PUSH
39574: EMPTY
39575: LIST
39576: LIST
39577: LIST
39578: PPUSH
39579: CALL_OW 72
39583: ADD
39584: ST_TO_ADDR
39585: GO 39833
39587: LD_INT 2
39589: DOUBLE
39590: EQUAL
39591: IFTRUE 39601
39593: LD_INT 16
39595: DOUBLE
39596: EQUAL
39597: IFTRUE 39601
39599: GO 39647
39601: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
39602: LD_ADDR_VAR 0 8
39606: PUSH
39607: LD_VAR 0 2
39611: PPUSH
39612: LD_INT 2
39614: PUSH
39615: LD_INT 30
39617: PUSH
39618: LD_INT 0
39620: PUSH
39621: EMPTY
39622: LIST
39623: LIST
39624: PUSH
39625: LD_INT 30
39627: PUSH
39628: LD_INT 1
39630: PUSH
39631: EMPTY
39632: LIST
39633: LIST
39634: PUSH
39635: EMPTY
39636: LIST
39637: LIST
39638: LIST
39639: PPUSH
39640: CALL_OW 72
39644: ST_TO_ADDR
39645: GO 39833
39647: LD_INT 3
39649: DOUBLE
39650: EQUAL
39651: IFTRUE 39655
39653: GO 39701
39655: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
39656: LD_ADDR_VAR 0 8
39660: PUSH
39661: LD_VAR 0 2
39665: PPUSH
39666: LD_INT 2
39668: PUSH
39669: LD_INT 30
39671: PUSH
39672: LD_INT 2
39674: PUSH
39675: EMPTY
39676: LIST
39677: LIST
39678: PUSH
39679: LD_INT 30
39681: PUSH
39682: LD_INT 3
39684: PUSH
39685: EMPTY
39686: LIST
39687: LIST
39688: PUSH
39689: EMPTY
39690: LIST
39691: LIST
39692: LIST
39693: PPUSH
39694: CALL_OW 72
39698: ST_TO_ADDR
39699: GO 39833
39701: LD_INT 4
39703: DOUBLE
39704: EQUAL
39705: IFTRUE 39709
39707: GO 39766
39709: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
39710: LD_ADDR_VAR 0 8
39714: PUSH
39715: LD_VAR 0 2
39719: PPUSH
39720: LD_INT 2
39722: PUSH
39723: LD_INT 30
39725: PUSH
39726: LD_INT 6
39728: PUSH
39729: EMPTY
39730: LIST
39731: LIST
39732: PUSH
39733: LD_INT 30
39735: PUSH
39736: LD_INT 7
39738: PUSH
39739: EMPTY
39740: LIST
39741: LIST
39742: PUSH
39743: LD_INT 30
39745: PUSH
39746: LD_INT 8
39748: PUSH
39749: EMPTY
39750: LIST
39751: LIST
39752: PUSH
39753: EMPTY
39754: LIST
39755: LIST
39756: LIST
39757: LIST
39758: PPUSH
39759: CALL_OW 72
39763: ST_TO_ADDR
39764: GO 39833
39766: LD_INT 5
39768: DOUBLE
39769: EQUAL
39770: IFTRUE 39786
39772: LD_INT 8
39774: DOUBLE
39775: EQUAL
39776: IFTRUE 39786
39778: LD_INT 9
39780: DOUBLE
39781: EQUAL
39782: IFTRUE 39786
39784: GO 39832
39786: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
39787: LD_ADDR_VAR 0 8
39791: PUSH
39792: LD_VAR 0 2
39796: PPUSH
39797: LD_INT 2
39799: PUSH
39800: LD_INT 30
39802: PUSH
39803: LD_INT 4
39805: PUSH
39806: EMPTY
39807: LIST
39808: LIST
39809: PUSH
39810: LD_INT 30
39812: PUSH
39813: LD_INT 5
39815: PUSH
39816: EMPTY
39817: LIST
39818: LIST
39819: PUSH
39820: EMPTY
39821: LIST
39822: LIST
39823: LIST
39824: PPUSH
39825: CALL_OW 72
39829: ST_TO_ADDR
39830: GO 39833
39832: POP
// if not tmp then
39833: LD_VAR 0 8
39837: NOT
39838: IFFALSE 39842
// exit ;
39840: GO 40344
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
39842: LD_VAR 0 4
39846: PUSH
39847: LD_INT 1
39849: PUSH
39850: LD_INT 15
39852: PUSH
39853: EMPTY
39854: LIST
39855: LIST
39856: IN
39857: PUSH
39858: LD_EXP 59
39862: PUSH
39863: LD_VAR 0 1
39867: ARRAY
39868: AND
39869: IFFALSE 40025
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
39871: LD_ADDR_VAR 0 9
39875: PUSH
39876: LD_EXP 59
39880: PUSH
39881: LD_VAR 0 1
39885: ARRAY
39886: PUSH
39887: LD_INT 1
39889: ARRAY
39890: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
39891: LD_VAR 0 9
39895: PUSH
39896: LD_EXP 60
39900: PUSH
39901: LD_VAR 0 1
39905: ARRAY
39906: IN
39907: NOT
39908: IFFALSE 40023
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
39910: LD_ADDR_EXP 60
39914: PUSH
39915: LD_EXP 60
39919: PPUSH
39920: LD_VAR 0 1
39924: PUSH
39925: LD_EXP 60
39929: PUSH
39930: LD_VAR 0 1
39934: ARRAY
39935: PUSH
39936: LD_INT 1
39938: PLUS
39939: PUSH
39940: EMPTY
39941: LIST
39942: LIST
39943: PPUSH
39944: LD_VAR 0 9
39948: PPUSH
39949: CALL 54555 0 3
39953: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
39954: LD_ADDR_EXP 59
39958: PUSH
39959: LD_EXP 59
39963: PPUSH
39964: LD_VAR 0 1
39968: PPUSH
39969: LD_EXP 59
39973: PUSH
39974: LD_VAR 0 1
39978: ARRAY
39979: PUSH
39980: LD_VAR 0 9
39984: DIFF
39985: PPUSH
39986: CALL_OW 1
39990: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
39991: LD_VAR 0 3
39995: PPUSH
39996: LD_EXP 60
40000: PUSH
40001: LD_VAR 0 1
40005: ARRAY
40006: PUSH
40007: LD_EXP 60
40011: PUSH
40012: LD_VAR 0 1
40016: ARRAY
40017: ARRAY
40018: PPUSH
40019: CALL_OW 120
// end ; exit ;
40023: GO 40344
// end ; if tmp > 1 then
40025: LD_VAR 0 8
40029: PUSH
40030: LD_INT 1
40032: GREATER
40033: IFFALSE 40137
// for i = 2 to tmp do
40035: LD_ADDR_VAR 0 6
40039: PUSH
40040: DOUBLE
40041: LD_INT 2
40043: DEC
40044: ST_TO_ADDR
40045: LD_VAR 0 8
40049: PUSH
40050: FOR_TO
40051: IFFALSE 40135
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
40053: LD_VAR 0 8
40057: PUSH
40058: LD_VAR 0 6
40062: ARRAY
40063: PPUSH
40064: CALL_OW 461
40068: PUSH
40069: LD_INT 6
40071: EQUAL
40072: IFFALSE 40133
// begin x := tmp [ i ] ;
40074: LD_ADDR_VAR 0 9
40078: PUSH
40079: LD_VAR 0 8
40083: PUSH
40084: LD_VAR 0 6
40088: ARRAY
40089: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
40090: LD_ADDR_VAR 0 8
40094: PUSH
40095: LD_VAR 0 8
40099: PPUSH
40100: LD_VAR 0 6
40104: PPUSH
40105: CALL_OW 3
40109: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
40110: LD_ADDR_VAR 0 8
40114: PUSH
40115: LD_VAR 0 8
40119: PPUSH
40120: LD_INT 1
40122: PPUSH
40123: LD_VAR 0 9
40127: PPUSH
40128: CALL_OW 2
40132: ST_TO_ADDR
// end ;
40133: GO 40050
40135: POP
40136: POP
// for i in tmp do
40137: LD_ADDR_VAR 0 6
40141: PUSH
40142: LD_VAR 0 8
40146: PUSH
40147: FOR_IN
40148: IFFALSE 40217
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
40150: LD_VAR 0 6
40154: PPUSH
40155: CALL_OW 313
40159: PUSH
40160: LD_INT 6
40162: LESS
40163: PUSH
40164: LD_VAR 0 6
40168: PPUSH
40169: CALL_OW 266
40173: PUSH
40174: LD_INT 31
40176: PUSH
40177: LD_INT 32
40179: PUSH
40180: EMPTY
40181: LIST
40182: LIST
40183: IN
40184: NOT
40185: AND
40186: PUSH
40187: LD_VAR 0 6
40191: PPUSH
40192: CALL_OW 313
40196: PUSH
40197: LD_INT 0
40199: EQUAL
40200: OR
40201: IFFALSE 40215
// begin j := i ;
40203: LD_ADDR_VAR 0 7
40207: PUSH
40208: LD_VAR 0 6
40212: ST_TO_ADDR
// break ;
40213: GO 40217
// end ; end ;
40215: GO 40147
40217: POP
40218: POP
// if j then
40219: LD_VAR 0 7
40223: IFFALSE 40241
// ComEnterUnit ( unit , j ) else
40225: LD_VAR 0 3
40229: PPUSH
40230: LD_VAR 0 7
40234: PPUSH
40235: CALL_OW 120
40239: GO 40344
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
40241: LD_ADDR_VAR 0 10
40245: PUSH
40246: LD_VAR 0 2
40250: PPUSH
40251: LD_INT 2
40253: PUSH
40254: LD_INT 30
40256: PUSH
40257: LD_INT 0
40259: PUSH
40260: EMPTY
40261: LIST
40262: LIST
40263: PUSH
40264: LD_INT 30
40266: PUSH
40267: LD_INT 1
40269: PUSH
40270: EMPTY
40271: LIST
40272: LIST
40273: PUSH
40274: EMPTY
40275: LIST
40276: LIST
40277: LIST
40278: PPUSH
40279: CALL_OW 72
40283: ST_TO_ADDR
// if depot then
40284: LD_VAR 0 10
40288: IFFALSE 40344
// begin depot := NearestUnitToUnit ( depot , unit ) ;
40290: LD_ADDR_VAR 0 10
40294: PUSH
40295: LD_VAR 0 10
40299: PPUSH
40300: LD_VAR 0 3
40304: PPUSH
40305: CALL_OW 74
40309: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
40310: LD_VAR 0 3
40314: PPUSH
40315: LD_VAR 0 10
40319: PPUSH
40320: CALL_OW 296
40324: PUSH
40325: LD_INT 10
40327: GREATER
40328: IFFALSE 40344
// ComStandNearbyBuilding ( unit , depot ) ;
40330: LD_VAR 0 3
40334: PPUSH
40335: LD_VAR 0 10
40339: PPUSH
40340: CALL 48758 0 2
// end ; end ; end ;
40344: LD_VAR 0 5
40348: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
40349: LD_INT 0
40351: PPUSH
40352: PPUSH
40353: PPUSH
40354: PPUSH
// if not mc_bases then
40355: LD_EXP 50
40359: NOT
40360: IFFALSE 40364
// exit ;
40362: GO 40603
// for i = 1 to mc_bases do
40364: LD_ADDR_VAR 0 2
40368: PUSH
40369: DOUBLE
40370: LD_INT 1
40372: DEC
40373: ST_TO_ADDR
40374: LD_EXP 50
40378: PUSH
40379: FOR_TO
40380: IFFALSE 40601
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
40382: LD_ADDR_VAR 0 4
40386: PUSH
40387: LD_EXP 50
40391: PUSH
40392: LD_VAR 0 2
40396: ARRAY
40397: PPUSH
40398: LD_INT 21
40400: PUSH
40401: LD_INT 1
40403: PUSH
40404: EMPTY
40405: LIST
40406: LIST
40407: PPUSH
40408: CALL_OW 72
40412: PUSH
40413: LD_EXP 79
40417: PUSH
40418: LD_VAR 0 2
40422: ARRAY
40423: UNION
40424: ST_TO_ADDR
// if not tmp then
40425: LD_VAR 0 4
40429: NOT
40430: IFFALSE 40434
// continue ;
40432: GO 40379
// for j in tmp do
40434: LD_ADDR_VAR 0 3
40438: PUSH
40439: LD_VAR 0 4
40443: PUSH
40444: FOR_IN
40445: IFFALSE 40597
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
40447: LD_VAR 0 3
40451: PPUSH
40452: CALL_OW 110
40456: NOT
40457: PUSH
40458: LD_VAR 0 3
40462: PPUSH
40463: CALL_OW 314
40467: NOT
40468: AND
40469: PUSH
40470: LD_VAR 0 3
40474: PPUSH
40475: CALL_OW 311
40479: NOT
40480: AND
40481: PUSH
40482: LD_VAR 0 3
40486: PPUSH
40487: CALL_OW 310
40491: NOT
40492: AND
40493: PUSH
40494: LD_VAR 0 3
40498: PUSH
40499: LD_EXP 53
40503: PUSH
40504: LD_VAR 0 2
40508: ARRAY
40509: PUSH
40510: LD_INT 1
40512: ARRAY
40513: IN
40514: NOT
40515: AND
40516: PUSH
40517: LD_VAR 0 3
40521: PUSH
40522: LD_EXP 53
40526: PUSH
40527: LD_VAR 0 2
40531: ARRAY
40532: PUSH
40533: LD_INT 2
40535: ARRAY
40536: IN
40537: NOT
40538: AND
40539: PUSH
40540: LD_VAR 0 3
40544: PUSH
40545: LD_EXP 62
40549: PUSH
40550: LD_VAR 0 2
40554: ARRAY
40555: IN
40556: NOT
40557: AND
40558: IFFALSE 40595
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
40560: LD_VAR 0 2
40564: PPUSH
40565: LD_EXP 50
40569: PUSH
40570: LD_VAR 0 2
40574: ARRAY
40575: PPUSH
40576: LD_VAR 0 3
40580: PPUSH
40581: LD_VAR 0 3
40585: PPUSH
40586: CALL_OW 257
40590: PPUSH
40591: CALL 39367 0 4
// end ;
40595: GO 40444
40597: POP
40598: POP
// end ;
40599: GO 40379
40601: POP
40602: POP
// end ;
40603: LD_VAR 0 1
40607: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
40608: LD_INT 0
40610: PPUSH
40611: PPUSH
40612: PPUSH
40613: PPUSH
40614: PPUSH
40615: PPUSH
// if not mc_bases [ base ] then
40616: LD_EXP 50
40620: PUSH
40621: LD_VAR 0 1
40625: ARRAY
40626: NOT
40627: IFFALSE 40631
// exit ;
40629: GO 40813
// tmp := [ ] ;
40631: LD_ADDR_VAR 0 6
40635: PUSH
40636: EMPTY
40637: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
40638: LD_ADDR_VAR 0 7
40642: PUSH
40643: LD_VAR 0 3
40647: PPUSH
40648: LD_INT 0
40650: PPUSH
40651: CALL_OW 517
40655: ST_TO_ADDR
// if not list then
40656: LD_VAR 0 7
40660: NOT
40661: IFFALSE 40665
// exit ;
40663: GO 40813
// for i = 1 to amount do
40665: LD_ADDR_VAR 0 5
40669: PUSH
40670: DOUBLE
40671: LD_INT 1
40673: DEC
40674: ST_TO_ADDR
40675: LD_VAR 0 2
40679: PUSH
40680: FOR_TO
40681: IFFALSE 40761
// begin x := rand ( 1 , list [ 1 ] ) ;
40683: LD_ADDR_VAR 0 8
40687: PUSH
40688: LD_INT 1
40690: PPUSH
40691: LD_VAR 0 7
40695: PUSH
40696: LD_INT 1
40698: ARRAY
40699: PPUSH
40700: CALL_OW 12
40704: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
40705: LD_ADDR_VAR 0 6
40709: PUSH
40710: LD_VAR 0 6
40714: PPUSH
40715: LD_VAR 0 5
40719: PPUSH
40720: LD_VAR 0 7
40724: PUSH
40725: LD_INT 1
40727: ARRAY
40728: PUSH
40729: LD_VAR 0 8
40733: ARRAY
40734: PUSH
40735: LD_VAR 0 7
40739: PUSH
40740: LD_INT 2
40742: ARRAY
40743: PUSH
40744: LD_VAR 0 8
40748: ARRAY
40749: PUSH
40750: EMPTY
40751: LIST
40752: LIST
40753: PPUSH
40754: CALL_OW 1
40758: ST_TO_ADDR
// end ;
40759: GO 40680
40761: POP
40762: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
40763: LD_ADDR_EXP 63
40767: PUSH
40768: LD_EXP 63
40772: PPUSH
40773: LD_VAR 0 1
40777: PPUSH
40778: LD_VAR 0 6
40782: PPUSH
40783: CALL_OW 1
40787: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
40788: LD_ADDR_EXP 65
40792: PUSH
40793: LD_EXP 65
40797: PPUSH
40798: LD_VAR 0 1
40802: PPUSH
40803: LD_VAR 0 3
40807: PPUSH
40808: CALL_OW 1
40812: ST_TO_ADDR
// end ;
40813: LD_VAR 0 4
40817: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
40818: LD_INT 0
40820: PPUSH
// if not mc_bases [ base ] then
40821: LD_EXP 50
40825: PUSH
40826: LD_VAR 0 1
40830: ARRAY
40831: NOT
40832: IFFALSE 40836
// exit ;
40834: GO 40861
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
40836: LD_ADDR_EXP 55
40840: PUSH
40841: LD_EXP 55
40845: PPUSH
40846: LD_VAR 0 1
40850: PPUSH
40851: LD_VAR 0 2
40855: PPUSH
40856: CALL_OW 1
40860: ST_TO_ADDR
// end ;
40861: LD_VAR 0 3
40865: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
40866: LD_INT 0
40868: PPUSH
// if not mc_bases [ base ] then
40869: LD_EXP 50
40873: PUSH
40874: LD_VAR 0 1
40878: ARRAY
40879: NOT
40880: IFFALSE 40884
// exit ;
40882: GO 40921
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
40884: LD_ADDR_EXP 55
40888: PUSH
40889: LD_EXP 55
40893: PPUSH
40894: LD_VAR 0 1
40898: PPUSH
40899: LD_EXP 55
40903: PUSH
40904: LD_VAR 0 1
40908: ARRAY
40909: PUSH
40910: LD_VAR 0 2
40914: UNION
40915: PPUSH
40916: CALL_OW 1
40920: ST_TO_ADDR
// end ;
40921: LD_VAR 0 3
40925: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
40926: LD_INT 0
40928: PPUSH
// if not mc_bases [ base ] then
40929: LD_EXP 50
40933: PUSH
40934: LD_VAR 0 1
40938: ARRAY
40939: NOT
40940: IFFALSE 40944
// exit ;
40942: GO 40969
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
40944: LD_ADDR_EXP 71
40948: PUSH
40949: LD_EXP 71
40953: PPUSH
40954: LD_VAR 0 1
40958: PPUSH
40959: LD_VAR 0 2
40963: PPUSH
40964: CALL_OW 1
40968: ST_TO_ADDR
// end ;
40969: LD_VAR 0 3
40973: RET
// export function MC_InsertProduceList ( base , components ) ; begin
40974: LD_INT 0
40976: PPUSH
// if not mc_bases [ base ] then
40977: LD_EXP 50
40981: PUSH
40982: LD_VAR 0 1
40986: ARRAY
40987: NOT
40988: IFFALSE 40992
// exit ;
40990: GO 41029
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
40992: LD_ADDR_EXP 71
40996: PUSH
40997: LD_EXP 71
41001: PPUSH
41002: LD_VAR 0 1
41006: PPUSH
41007: LD_EXP 71
41011: PUSH
41012: LD_VAR 0 1
41016: ARRAY
41017: PUSH
41018: LD_VAR 0 2
41022: ADD
41023: PPUSH
41024: CALL_OW 1
41028: ST_TO_ADDR
// end ;
41029: LD_VAR 0 3
41033: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
41034: LD_INT 0
41036: PPUSH
// if not mc_bases [ base ] then
41037: LD_EXP 50
41041: PUSH
41042: LD_VAR 0 1
41046: ARRAY
41047: NOT
41048: IFFALSE 41052
// exit ;
41050: GO 41106
// mc_defender := Replace ( mc_defender , base , deflist ) ;
41052: LD_ADDR_EXP 72
41056: PUSH
41057: LD_EXP 72
41061: PPUSH
41062: LD_VAR 0 1
41066: PPUSH
41067: LD_VAR 0 2
41071: PPUSH
41072: CALL_OW 1
41076: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
41077: LD_ADDR_EXP 61
41081: PUSH
41082: LD_EXP 61
41086: PPUSH
41087: LD_VAR 0 1
41091: PPUSH
41092: LD_VAR 0 2
41096: PUSH
41097: LD_INT 0
41099: PLUS
41100: PPUSH
41101: CALL_OW 1
41105: ST_TO_ADDR
// end ;
41106: LD_VAR 0 3
41110: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
41111: LD_INT 0
41113: PPUSH
// if not mc_bases [ base ] then
41114: LD_EXP 50
41118: PUSH
41119: LD_VAR 0 1
41123: ARRAY
41124: NOT
41125: IFFALSE 41129
// exit ;
41127: GO 41154
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
41129: LD_ADDR_EXP 61
41133: PUSH
41134: LD_EXP 61
41138: PPUSH
41139: LD_VAR 0 1
41143: PPUSH
41144: LD_VAR 0 2
41148: PPUSH
41149: CALL_OW 1
41153: ST_TO_ADDR
// end ;
41154: LD_VAR 0 3
41158: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
41159: LD_INT 0
41161: PPUSH
41162: PPUSH
41163: PPUSH
41164: PPUSH
// if not mc_bases [ base ] then
41165: LD_EXP 50
41169: PUSH
41170: LD_VAR 0 1
41174: ARRAY
41175: NOT
41176: IFFALSE 41180
// exit ;
41178: GO 41245
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
41180: LD_ADDR_EXP 70
41184: PUSH
41185: LD_EXP 70
41189: PPUSH
41190: LD_VAR 0 1
41194: PUSH
41195: LD_EXP 70
41199: PUSH
41200: LD_VAR 0 1
41204: ARRAY
41205: PUSH
41206: LD_INT 1
41208: PLUS
41209: PUSH
41210: EMPTY
41211: LIST
41212: LIST
41213: PPUSH
41214: LD_VAR 0 1
41218: PUSH
41219: LD_VAR 0 2
41223: PUSH
41224: LD_VAR 0 3
41228: PUSH
41229: LD_VAR 0 4
41233: PUSH
41234: EMPTY
41235: LIST
41236: LIST
41237: LIST
41238: LIST
41239: PPUSH
41240: CALL 54555 0 3
41244: ST_TO_ADDR
// end ;
41245: LD_VAR 0 5
41249: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
41250: LD_INT 0
41252: PPUSH
// if not mc_bases [ base ] then
41253: LD_EXP 50
41257: PUSH
41258: LD_VAR 0 1
41262: ARRAY
41263: NOT
41264: IFFALSE 41268
// exit ;
41266: GO 41293
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
41268: LD_ADDR_EXP 87
41272: PUSH
41273: LD_EXP 87
41277: PPUSH
41278: LD_VAR 0 1
41282: PPUSH
41283: LD_VAR 0 2
41287: PPUSH
41288: CALL_OW 1
41292: ST_TO_ADDR
// end ;
41293: LD_VAR 0 3
41297: RET
// export function MC_GetMinesField ( base ) ; begin
41298: LD_INT 0
41300: PPUSH
// result := mc_mines [ base ] ;
41301: LD_ADDR_VAR 0 2
41305: PUSH
41306: LD_EXP 63
41310: PUSH
41311: LD_VAR 0 1
41315: ARRAY
41316: ST_TO_ADDR
// end ;
41317: LD_VAR 0 2
41321: RET
// export function MC_GetProduceList ( base ) ; begin
41322: LD_INT 0
41324: PPUSH
// result := mc_produce [ base ] ;
41325: LD_ADDR_VAR 0 2
41329: PUSH
41330: LD_EXP 71
41334: PUSH
41335: LD_VAR 0 1
41339: ARRAY
41340: ST_TO_ADDR
// end ;
41341: LD_VAR 0 2
41345: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
41346: LD_INT 0
41348: PPUSH
41349: PPUSH
// if not mc_bases then
41350: LD_EXP 50
41354: NOT
41355: IFFALSE 41359
// exit ;
41357: GO 41424
// if mc_bases [ base ] then
41359: LD_EXP 50
41363: PUSH
41364: LD_VAR 0 1
41368: ARRAY
41369: IFFALSE 41424
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
41371: LD_ADDR_VAR 0 3
41375: PUSH
41376: LD_EXP 50
41380: PUSH
41381: LD_VAR 0 1
41385: ARRAY
41386: PPUSH
41387: LD_INT 30
41389: PUSH
41390: LD_VAR 0 2
41394: PUSH
41395: EMPTY
41396: LIST
41397: LIST
41398: PPUSH
41399: CALL_OW 72
41403: ST_TO_ADDR
// if result then
41404: LD_VAR 0 3
41408: IFFALSE 41424
// result := result [ 1 ] ;
41410: LD_ADDR_VAR 0 3
41414: PUSH
41415: LD_VAR 0 3
41419: PUSH
41420: LD_INT 1
41422: ARRAY
41423: ST_TO_ADDR
// end ; end ;
41424: LD_VAR 0 3
41428: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
41429: LD_INT 0
41431: PPUSH
41432: PPUSH
// if not mc_bases then
41433: LD_EXP 50
41437: NOT
41438: IFFALSE 41442
// exit ;
41440: GO 41487
// if mc_bases [ base ] then
41442: LD_EXP 50
41446: PUSH
41447: LD_VAR 0 1
41451: ARRAY
41452: IFFALSE 41487
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
41454: LD_ADDR_VAR 0 3
41458: PUSH
41459: LD_EXP 50
41463: PUSH
41464: LD_VAR 0 1
41468: ARRAY
41469: PPUSH
41470: LD_INT 30
41472: PUSH
41473: LD_VAR 0 2
41477: PUSH
41478: EMPTY
41479: LIST
41480: LIST
41481: PPUSH
41482: CALL_OW 72
41486: ST_TO_ADDR
// end ;
41487: LD_VAR 0 3
41491: RET
// export function MC_SetTame ( base , area ) ; begin
41492: LD_INT 0
41494: PPUSH
// if not mc_bases or not base then
41495: LD_EXP 50
41499: NOT
41500: PUSH
41501: LD_VAR 0 1
41505: NOT
41506: OR
41507: IFFALSE 41511
// exit ;
41509: GO 41536
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
41511: LD_ADDR_EXP 78
41515: PUSH
41516: LD_EXP 78
41520: PPUSH
41521: LD_VAR 0 1
41525: PPUSH
41526: LD_VAR 0 2
41530: PPUSH
41531: CALL_OW 1
41535: ST_TO_ADDR
// end ;
41536: LD_VAR 0 3
41540: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
41541: LD_INT 0
41543: PPUSH
41544: PPUSH
// if not mc_bases or not base then
41545: LD_EXP 50
41549: NOT
41550: PUSH
41551: LD_VAR 0 1
41555: NOT
41556: OR
41557: IFFALSE 41561
// exit ;
41559: GO 41663
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
41561: LD_ADDR_VAR 0 4
41565: PUSH
41566: LD_EXP 50
41570: PUSH
41571: LD_VAR 0 1
41575: ARRAY
41576: PPUSH
41577: LD_INT 30
41579: PUSH
41580: LD_VAR 0 2
41584: PUSH
41585: EMPTY
41586: LIST
41587: LIST
41588: PPUSH
41589: CALL_OW 72
41593: ST_TO_ADDR
// if not tmp then
41594: LD_VAR 0 4
41598: NOT
41599: IFFALSE 41603
// exit ;
41601: GO 41663
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
41603: LD_ADDR_EXP 82
41607: PUSH
41608: LD_EXP 82
41612: PPUSH
41613: LD_VAR 0 1
41617: PPUSH
41618: LD_EXP 82
41622: PUSH
41623: LD_VAR 0 1
41627: ARRAY
41628: PPUSH
41629: LD_EXP 82
41633: PUSH
41634: LD_VAR 0 1
41638: ARRAY
41639: PUSH
41640: LD_INT 1
41642: PLUS
41643: PPUSH
41644: LD_VAR 0 4
41648: PUSH
41649: LD_INT 1
41651: ARRAY
41652: PPUSH
41653: CALL_OW 2
41657: PPUSH
41658: CALL_OW 1
41662: ST_TO_ADDR
// end ;
41663: LD_VAR 0 3
41667: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
41668: LD_INT 0
41670: PPUSH
41671: PPUSH
// if not mc_bases or not base or not kinds then
41672: LD_EXP 50
41676: NOT
41677: PUSH
41678: LD_VAR 0 1
41682: NOT
41683: OR
41684: PUSH
41685: LD_VAR 0 2
41689: NOT
41690: OR
41691: IFFALSE 41695
// exit ;
41693: GO 41756
// for i in kinds do
41695: LD_ADDR_VAR 0 4
41699: PUSH
41700: LD_VAR 0 2
41704: PUSH
41705: FOR_IN
41706: IFFALSE 41754
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
41708: LD_ADDR_EXP 84
41712: PUSH
41713: LD_EXP 84
41717: PPUSH
41718: LD_VAR 0 1
41722: PUSH
41723: LD_EXP 84
41727: PUSH
41728: LD_VAR 0 1
41732: ARRAY
41733: PUSH
41734: LD_INT 1
41736: PLUS
41737: PUSH
41738: EMPTY
41739: LIST
41740: LIST
41741: PPUSH
41742: LD_VAR 0 4
41746: PPUSH
41747: CALL 54555 0 3
41751: ST_TO_ADDR
41752: GO 41705
41754: POP
41755: POP
// end ;
41756: LD_VAR 0 3
41760: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
41761: LD_INT 0
41763: PPUSH
// if not mc_bases or not base or not areas then
41764: LD_EXP 50
41768: NOT
41769: PUSH
41770: LD_VAR 0 1
41774: NOT
41775: OR
41776: PUSH
41777: LD_VAR 0 2
41781: NOT
41782: OR
41783: IFFALSE 41787
// exit ;
41785: GO 41812
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
41787: LD_ADDR_EXP 68
41791: PUSH
41792: LD_EXP 68
41796: PPUSH
41797: LD_VAR 0 1
41801: PPUSH
41802: LD_VAR 0 2
41806: PPUSH
41807: CALL_OW 1
41811: ST_TO_ADDR
// end ;
41812: LD_VAR 0 3
41816: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
41817: LD_INT 0
41819: PPUSH
// if not mc_bases or not base or not teleports_exit then
41820: LD_EXP 50
41824: NOT
41825: PUSH
41826: LD_VAR 0 1
41830: NOT
41831: OR
41832: PUSH
41833: LD_VAR 0 2
41837: NOT
41838: OR
41839: IFFALSE 41843
// exit ;
41841: GO 41868
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
41843: LD_ADDR_EXP 85
41847: PUSH
41848: LD_EXP 85
41852: PPUSH
41853: LD_VAR 0 1
41857: PPUSH
41858: LD_VAR 0 2
41862: PPUSH
41863: CALL_OW 1
41867: ST_TO_ADDR
// end ;
41868: LD_VAR 0 3
41872: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
41873: LD_INT 0
41875: PPUSH
41876: PPUSH
41877: PPUSH
// if not mc_bases or not base or not ext_list then
41878: LD_EXP 50
41882: NOT
41883: PUSH
41884: LD_VAR 0 1
41888: NOT
41889: OR
41890: PUSH
41891: LD_VAR 0 5
41895: NOT
41896: OR
41897: IFFALSE 41901
// exit ;
41899: GO 42074
// tmp := GetFacExtXYD ( x , y , d ) ;
41901: LD_ADDR_VAR 0 8
41905: PUSH
41906: LD_VAR 0 2
41910: PPUSH
41911: LD_VAR 0 3
41915: PPUSH
41916: LD_VAR 0 4
41920: PPUSH
41921: CALL 87943 0 3
41925: ST_TO_ADDR
// if not tmp then
41926: LD_VAR 0 8
41930: NOT
41931: IFFALSE 41935
// exit ;
41933: GO 42074
// for i in tmp do
41935: LD_ADDR_VAR 0 7
41939: PUSH
41940: LD_VAR 0 8
41944: PUSH
41945: FOR_IN
41946: IFFALSE 42072
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
41948: LD_ADDR_EXP 55
41952: PUSH
41953: LD_EXP 55
41957: PPUSH
41958: LD_VAR 0 1
41962: PPUSH
41963: LD_EXP 55
41967: PUSH
41968: LD_VAR 0 1
41972: ARRAY
41973: PPUSH
41974: LD_EXP 55
41978: PUSH
41979: LD_VAR 0 1
41983: ARRAY
41984: PUSH
41985: LD_INT 1
41987: PLUS
41988: PPUSH
41989: LD_VAR 0 5
41993: PUSH
41994: LD_INT 1
41996: ARRAY
41997: PUSH
41998: LD_VAR 0 7
42002: PUSH
42003: LD_INT 1
42005: ARRAY
42006: PUSH
42007: LD_VAR 0 7
42011: PUSH
42012: LD_INT 2
42014: ARRAY
42015: PUSH
42016: LD_VAR 0 7
42020: PUSH
42021: LD_INT 3
42023: ARRAY
42024: PUSH
42025: EMPTY
42026: LIST
42027: LIST
42028: LIST
42029: LIST
42030: PPUSH
42031: CALL_OW 2
42035: PPUSH
42036: CALL_OW 1
42040: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
42041: LD_ADDR_VAR 0 5
42045: PUSH
42046: LD_VAR 0 5
42050: PPUSH
42051: LD_INT 1
42053: PPUSH
42054: CALL_OW 3
42058: ST_TO_ADDR
// if not ext_list then
42059: LD_VAR 0 5
42063: NOT
42064: IFFALSE 42070
// exit ;
42066: POP
42067: POP
42068: GO 42074
// end ;
42070: GO 41945
42072: POP
42073: POP
// end ;
42074: LD_VAR 0 6
42078: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
42079: LD_INT 0
42081: PPUSH
// if not mc_bases or not base or not weapon_list then
42082: LD_EXP 50
42086: NOT
42087: PUSH
42088: LD_VAR 0 1
42092: NOT
42093: OR
42094: PUSH
42095: LD_VAR 0 2
42099: NOT
42100: OR
42101: IFFALSE 42105
// exit ;
42103: GO 42130
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
42105: LD_ADDR_EXP 89
42109: PUSH
42110: LD_EXP 89
42114: PPUSH
42115: LD_VAR 0 1
42119: PPUSH
42120: LD_VAR 0 2
42124: PPUSH
42125: CALL_OW 1
42129: ST_TO_ADDR
// end ;
42130: LD_VAR 0 3
42134: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
42135: LD_INT 0
42137: PPUSH
// if not mc_bases or not base or not tech_list then
42138: LD_EXP 50
42142: NOT
42143: PUSH
42144: LD_VAR 0 1
42148: NOT
42149: OR
42150: PUSH
42151: LD_VAR 0 2
42155: NOT
42156: OR
42157: IFFALSE 42161
// exit ;
42159: GO 42186
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
42161: LD_ADDR_EXP 77
42165: PUSH
42166: LD_EXP 77
42170: PPUSH
42171: LD_VAR 0 1
42175: PPUSH
42176: LD_VAR 0 2
42180: PPUSH
42181: CALL_OW 1
42185: ST_TO_ADDR
// end ;
42186: LD_VAR 0 3
42190: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
42191: LD_INT 0
42193: PPUSH
// if not mc_bases or not parking_area or not base then
42194: LD_EXP 50
42198: NOT
42199: PUSH
42200: LD_VAR 0 2
42204: NOT
42205: OR
42206: PUSH
42207: LD_VAR 0 1
42211: NOT
42212: OR
42213: IFFALSE 42217
// exit ;
42215: GO 42242
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
42217: LD_ADDR_EXP 74
42221: PUSH
42222: LD_EXP 74
42226: PPUSH
42227: LD_VAR 0 1
42231: PPUSH
42232: LD_VAR 0 2
42236: PPUSH
42237: CALL_OW 1
42241: ST_TO_ADDR
// end ;
42242: LD_VAR 0 3
42246: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
42247: LD_INT 0
42249: PPUSH
// if not mc_bases or not base or not scan_area then
42250: LD_EXP 50
42254: NOT
42255: PUSH
42256: LD_VAR 0 1
42260: NOT
42261: OR
42262: PUSH
42263: LD_VAR 0 2
42267: NOT
42268: OR
42269: IFFALSE 42273
// exit ;
42271: GO 42298
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
42273: LD_ADDR_EXP 75
42277: PUSH
42278: LD_EXP 75
42282: PPUSH
42283: LD_VAR 0 1
42287: PPUSH
42288: LD_VAR 0 2
42292: PPUSH
42293: CALL_OW 1
42297: ST_TO_ADDR
// end ;
42298: LD_VAR 0 3
42302: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
42303: LD_INT 0
42305: PPUSH
42306: PPUSH
// if not mc_bases or not base then
42307: LD_EXP 50
42311: NOT
42312: PUSH
42313: LD_VAR 0 1
42317: NOT
42318: OR
42319: IFFALSE 42323
// exit ;
42321: GO 42387
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
42323: LD_ADDR_VAR 0 3
42327: PUSH
42328: LD_INT 1
42330: PUSH
42331: LD_INT 2
42333: PUSH
42334: LD_INT 3
42336: PUSH
42337: LD_INT 4
42339: PUSH
42340: LD_INT 11
42342: PUSH
42343: EMPTY
42344: LIST
42345: LIST
42346: LIST
42347: LIST
42348: LIST
42349: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
42350: LD_ADDR_EXP 77
42354: PUSH
42355: LD_EXP 77
42359: PPUSH
42360: LD_VAR 0 1
42364: PPUSH
42365: LD_EXP 77
42369: PUSH
42370: LD_VAR 0 1
42374: ARRAY
42375: PUSH
42376: LD_VAR 0 3
42380: DIFF
42381: PPUSH
42382: CALL_OW 1
42386: ST_TO_ADDR
// end ;
42387: LD_VAR 0 2
42391: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
42392: LD_INT 0
42394: PPUSH
// result := mc_vehicles [ base ] ;
42395: LD_ADDR_VAR 0 3
42399: PUSH
42400: LD_EXP 69
42404: PUSH
42405: LD_VAR 0 1
42409: ARRAY
42410: ST_TO_ADDR
// if onlyCombat then
42411: LD_VAR 0 2
42415: IFFALSE 42580
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
42417: LD_ADDR_VAR 0 3
42421: PUSH
42422: LD_VAR 0 3
42426: PUSH
42427: LD_VAR 0 3
42431: PPUSH
42432: LD_INT 2
42434: PUSH
42435: LD_INT 34
42437: PUSH
42438: LD_INT 12
42440: PUSH
42441: EMPTY
42442: LIST
42443: LIST
42444: PUSH
42445: LD_INT 34
42447: PUSH
42448: LD_INT 51
42450: PUSH
42451: EMPTY
42452: LIST
42453: LIST
42454: PUSH
42455: LD_INT 34
42457: PUSH
42458: LD_EXP 94
42462: PUSH
42463: EMPTY
42464: LIST
42465: LIST
42466: PUSH
42467: LD_INT 34
42469: PUSH
42470: LD_INT 32
42472: PUSH
42473: EMPTY
42474: LIST
42475: LIST
42476: PUSH
42477: LD_INT 34
42479: PUSH
42480: LD_INT 13
42482: PUSH
42483: EMPTY
42484: LIST
42485: LIST
42486: PUSH
42487: LD_INT 34
42489: PUSH
42490: LD_INT 52
42492: PUSH
42493: EMPTY
42494: LIST
42495: LIST
42496: PUSH
42497: LD_INT 34
42499: PUSH
42500: LD_INT 14
42502: PUSH
42503: EMPTY
42504: LIST
42505: LIST
42506: PUSH
42507: LD_INT 34
42509: PUSH
42510: LD_INT 53
42512: PUSH
42513: EMPTY
42514: LIST
42515: LIST
42516: PUSH
42517: LD_INT 34
42519: PUSH
42520: LD_EXP 93
42524: PUSH
42525: EMPTY
42526: LIST
42527: LIST
42528: PUSH
42529: LD_INT 34
42531: PUSH
42532: LD_INT 31
42534: PUSH
42535: EMPTY
42536: LIST
42537: LIST
42538: PUSH
42539: LD_INT 34
42541: PUSH
42542: LD_INT 48
42544: PUSH
42545: EMPTY
42546: LIST
42547: LIST
42548: PUSH
42549: LD_INT 34
42551: PUSH
42552: LD_INT 8
42554: PUSH
42555: EMPTY
42556: LIST
42557: LIST
42558: PUSH
42559: EMPTY
42560: LIST
42561: LIST
42562: LIST
42563: LIST
42564: LIST
42565: LIST
42566: LIST
42567: LIST
42568: LIST
42569: LIST
42570: LIST
42571: LIST
42572: LIST
42573: PPUSH
42574: CALL_OW 72
42578: DIFF
42579: ST_TO_ADDR
// end ; end_of_file
42580: LD_VAR 0 3
42584: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
42585: LD_INT 0
42587: PPUSH
42588: PPUSH
42589: PPUSH
// if not mc_bases or not skirmish then
42590: LD_EXP 50
42594: NOT
42595: PUSH
42596: LD_EXP 48
42600: NOT
42601: OR
42602: IFFALSE 42606
// exit ;
42604: GO 42771
// for i = 1 to mc_bases do
42606: LD_ADDR_VAR 0 4
42610: PUSH
42611: DOUBLE
42612: LD_INT 1
42614: DEC
42615: ST_TO_ADDR
42616: LD_EXP 50
42620: PUSH
42621: FOR_TO
42622: IFFALSE 42769
// begin if sci in mc_bases [ i ] then
42624: LD_VAR 0 2
42628: PUSH
42629: LD_EXP 50
42633: PUSH
42634: LD_VAR 0 4
42638: ARRAY
42639: IN
42640: IFFALSE 42767
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
42642: LD_ADDR_EXP 79
42646: PUSH
42647: LD_EXP 79
42651: PPUSH
42652: LD_VAR 0 4
42656: PUSH
42657: LD_EXP 79
42661: PUSH
42662: LD_VAR 0 4
42666: ARRAY
42667: PUSH
42668: LD_INT 1
42670: PLUS
42671: PUSH
42672: EMPTY
42673: LIST
42674: LIST
42675: PPUSH
42676: LD_VAR 0 1
42680: PPUSH
42681: CALL 54555 0 3
42685: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
42686: LD_ADDR_VAR 0 5
42690: PUSH
42691: LD_EXP 50
42695: PUSH
42696: LD_VAR 0 4
42700: ARRAY
42701: PPUSH
42702: LD_INT 2
42704: PUSH
42705: LD_INT 30
42707: PUSH
42708: LD_INT 0
42710: PUSH
42711: EMPTY
42712: LIST
42713: LIST
42714: PUSH
42715: LD_INT 30
42717: PUSH
42718: LD_INT 1
42720: PUSH
42721: EMPTY
42722: LIST
42723: LIST
42724: PUSH
42725: EMPTY
42726: LIST
42727: LIST
42728: LIST
42729: PPUSH
42730: CALL_OW 72
42734: PPUSH
42735: LD_VAR 0 1
42739: PPUSH
42740: CALL_OW 74
42744: ST_TO_ADDR
// if tmp then
42745: LD_VAR 0 5
42749: IFFALSE 42765
// ComStandNearbyBuilding ( ape , tmp ) ;
42751: LD_VAR 0 1
42755: PPUSH
42756: LD_VAR 0 5
42760: PPUSH
42761: CALL 48758 0 2
// break ;
42765: GO 42769
// end ; end ;
42767: GO 42621
42769: POP
42770: POP
// end ;
42771: LD_VAR 0 3
42775: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
42776: LD_INT 0
42778: PPUSH
42779: PPUSH
42780: PPUSH
// if not mc_bases or not skirmish then
42781: LD_EXP 50
42785: NOT
42786: PUSH
42787: LD_EXP 48
42791: NOT
42792: OR
42793: IFFALSE 42797
// exit ;
42795: GO 42886
// for i = 1 to mc_bases do
42797: LD_ADDR_VAR 0 4
42801: PUSH
42802: DOUBLE
42803: LD_INT 1
42805: DEC
42806: ST_TO_ADDR
42807: LD_EXP 50
42811: PUSH
42812: FOR_TO
42813: IFFALSE 42884
// begin if building in mc_busy_turret_list [ i ] then
42815: LD_VAR 0 1
42819: PUSH
42820: LD_EXP 60
42824: PUSH
42825: LD_VAR 0 4
42829: ARRAY
42830: IN
42831: IFFALSE 42882
// begin tmp := mc_busy_turret_list [ i ] diff building ;
42833: LD_ADDR_VAR 0 5
42837: PUSH
42838: LD_EXP 60
42842: PUSH
42843: LD_VAR 0 4
42847: ARRAY
42848: PUSH
42849: LD_VAR 0 1
42853: DIFF
42854: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
42855: LD_ADDR_EXP 60
42859: PUSH
42860: LD_EXP 60
42864: PPUSH
42865: LD_VAR 0 4
42869: PPUSH
42870: LD_VAR 0 5
42874: PPUSH
42875: CALL_OW 1
42879: ST_TO_ADDR
// break ;
42880: GO 42884
// end ; end ;
42882: GO 42812
42884: POP
42885: POP
// end ;
42886: LD_VAR 0 3
42890: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
42891: LD_INT 0
42893: PPUSH
42894: PPUSH
42895: PPUSH
// if not mc_bases or not skirmish then
42896: LD_EXP 50
42900: NOT
42901: PUSH
42902: LD_EXP 48
42906: NOT
42907: OR
42908: IFFALSE 42912
// exit ;
42910: GO 43111
// for i = 1 to mc_bases do
42912: LD_ADDR_VAR 0 5
42916: PUSH
42917: DOUBLE
42918: LD_INT 1
42920: DEC
42921: ST_TO_ADDR
42922: LD_EXP 50
42926: PUSH
42927: FOR_TO
42928: IFFALSE 43109
// if building in mc_bases [ i ] then
42930: LD_VAR 0 1
42934: PUSH
42935: LD_EXP 50
42939: PUSH
42940: LD_VAR 0 5
42944: ARRAY
42945: IN
42946: IFFALSE 43107
// begin tmp := mc_bases [ i ] diff building ;
42948: LD_ADDR_VAR 0 6
42952: PUSH
42953: LD_EXP 50
42957: PUSH
42958: LD_VAR 0 5
42962: ARRAY
42963: PUSH
42964: LD_VAR 0 1
42968: DIFF
42969: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
42970: LD_ADDR_EXP 50
42974: PUSH
42975: LD_EXP 50
42979: PPUSH
42980: LD_VAR 0 5
42984: PPUSH
42985: LD_VAR 0 6
42989: PPUSH
42990: CALL_OW 1
42994: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
42995: LD_VAR 0 1
42999: PUSH
43000: LD_EXP 58
43004: PUSH
43005: LD_VAR 0 5
43009: ARRAY
43010: IN
43011: IFFALSE 43050
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
43013: LD_ADDR_EXP 58
43017: PUSH
43018: LD_EXP 58
43022: PPUSH
43023: LD_VAR 0 5
43027: PPUSH
43028: LD_EXP 58
43032: PUSH
43033: LD_VAR 0 5
43037: ARRAY
43038: PUSH
43039: LD_VAR 0 1
43043: DIFF
43044: PPUSH
43045: CALL_OW 1
43049: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
43050: LD_VAR 0 1
43054: PUSH
43055: LD_EXP 59
43059: PUSH
43060: LD_VAR 0 5
43064: ARRAY
43065: IN
43066: IFFALSE 43105
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
43068: LD_ADDR_EXP 59
43072: PUSH
43073: LD_EXP 59
43077: PPUSH
43078: LD_VAR 0 5
43082: PPUSH
43083: LD_EXP 59
43087: PUSH
43088: LD_VAR 0 5
43092: ARRAY
43093: PUSH
43094: LD_VAR 0 1
43098: DIFF
43099: PPUSH
43100: CALL_OW 1
43104: ST_TO_ADDR
// break ;
43105: GO 43109
// end ;
43107: GO 42927
43109: POP
43110: POP
// end ;
43111: LD_VAR 0 4
43115: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
43116: LD_INT 0
43118: PPUSH
43119: PPUSH
43120: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
43121: LD_EXP 50
43125: NOT
43126: PUSH
43127: LD_EXP 48
43131: NOT
43132: OR
43133: PUSH
43134: LD_VAR 0 3
43138: PUSH
43139: LD_EXP 76
43143: IN
43144: NOT
43145: OR
43146: IFFALSE 43150
// exit ;
43148: GO 43273
// for i = 1 to mc_vehicles do
43150: LD_ADDR_VAR 0 6
43154: PUSH
43155: DOUBLE
43156: LD_INT 1
43158: DEC
43159: ST_TO_ADDR
43160: LD_EXP 69
43164: PUSH
43165: FOR_TO
43166: IFFALSE 43271
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
43168: LD_VAR 0 2
43172: PUSH
43173: LD_EXP 69
43177: PUSH
43178: LD_VAR 0 6
43182: ARRAY
43183: IN
43184: PUSH
43185: LD_VAR 0 1
43189: PUSH
43190: LD_EXP 69
43194: PUSH
43195: LD_VAR 0 6
43199: ARRAY
43200: IN
43201: OR
43202: IFFALSE 43269
// begin tmp := mc_vehicles [ i ] diff old ;
43204: LD_ADDR_VAR 0 7
43208: PUSH
43209: LD_EXP 69
43213: PUSH
43214: LD_VAR 0 6
43218: ARRAY
43219: PUSH
43220: LD_VAR 0 2
43224: DIFF
43225: ST_TO_ADDR
// tmp := tmp diff new ;
43226: LD_ADDR_VAR 0 7
43230: PUSH
43231: LD_VAR 0 7
43235: PUSH
43236: LD_VAR 0 1
43240: DIFF
43241: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
43242: LD_ADDR_EXP 69
43246: PUSH
43247: LD_EXP 69
43251: PPUSH
43252: LD_VAR 0 6
43256: PPUSH
43257: LD_VAR 0 7
43261: PPUSH
43262: CALL_OW 1
43266: ST_TO_ADDR
// break ;
43267: GO 43271
// end ;
43269: GO 43165
43271: POP
43272: POP
// end ;
43273: LD_VAR 0 5
43277: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
43278: LD_INT 0
43280: PPUSH
43281: PPUSH
43282: PPUSH
43283: PPUSH
// if not mc_bases or not skirmish then
43284: LD_EXP 50
43288: NOT
43289: PUSH
43290: LD_EXP 48
43294: NOT
43295: OR
43296: IFFALSE 43300
// exit ;
43298: GO 43677
// side := GetSide ( vehicle ) ;
43300: LD_ADDR_VAR 0 5
43304: PUSH
43305: LD_VAR 0 1
43309: PPUSH
43310: CALL_OW 255
43314: ST_TO_ADDR
// for i = 1 to mc_bases do
43315: LD_ADDR_VAR 0 4
43319: PUSH
43320: DOUBLE
43321: LD_INT 1
43323: DEC
43324: ST_TO_ADDR
43325: LD_EXP 50
43329: PUSH
43330: FOR_TO
43331: IFFALSE 43675
// begin if factory in mc_bases [ i ] then
43333: LD_VAR 0 2
43337: PUSH
43338: LD_EXP 50
43342: PUSH
43343: LD_VAR 0 4
43347: ARRAY
43348: IN
43349: IFFALSE 43673
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
43351: LD_EXP 72
43355: PUSH
43356: LD_VAR 0 4
43360: ARRAY
43361: PUSH
43362: LD_EXP 61
43366: PUSH
43367: LD_VAR 0 4
43371: ARRAY
43372: LESS
43373: PUSH
43374: LD_VAR 0 1
43378: PPUSH
43379: CALL_OW 264
43383: PUSH
43384: LD_INT 31
43386: PUSH
43387: LD_INT 32
43389: PUSH
43390: LD_INT 51
43392: PUSH
43393: LD_EXP 94
43397: PUSH
43398: LD_INT 12
43400: PUSH
43401: LD_INT 30
43403: PUSH
43404: LD_EXP 93
43408: PUSH
43409: LD_INT 11
43411: PUSH
43412: LD_INT 53
43414: PUSH
43415: LD_INT 14
43417: PUSH
43418: LD_EXP 97
43422: PUSH
43423: LD_INT 29
43425: PUSH
43426: LD_EXP 95
43430: PUSH
43431: LD_INT 13
43433: PUSH
43434: LD_INT 52
43436: PUSH
43437: LD_INT 48
43439: PUSH
43440: LD_INT 8
43442: PUSH
43443: EMPTY
43444: LIST
43445: LIST
43446: LIST
43447: LIST
43448: LIST
43449: LIST
43450: LIST
43451: LIST
43452: LIST
43453: LIST
43454: LIST
43455: LIST
43456: LIST
43457: LIST
43458: LIST
43459: LIST
43460: LIST
43461: IN
43462: NOT
43463: AND
43464: IFFALSE 43512
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
43466: LD_ADDR_EXP 72
43470: PUSH
43471: LD_EXP 72
43475: PPUSH
43476: LD_VAR 0 4
43480: PUSH
43481: LD_EXP 72
43485: PUSH
43486: LD_VAR 0 4
43490: ARRAY
43491: PUSH
43492: LD_INT 1
43494: PLUS
43495: PUSH
43496: EMPTY
43497: LIST
43498: LIST
43499: PPUSH
43500: LD_VAR 0 1
43504: PPUSH
43505: CALL 54555 0 3
43509: ST_TO_ADDR
43510: GO 43556
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
43512: LD_ADDR_EXP 69
43516: PUSH
43517: LD_EXP 69
43521: PPUSH
43522: LD_VAR 0 4
43526: PUSH
43527: LD_EXP 69
43531: PUSH
43532: LD_VAR 0 4
43536: ARRAY
43537: PUSH
43538: LD_INT 1
43540: PLUS
43541: PUSH
43542: EMPTY
43543: LIST
43544: LIST
43545: PPUSH
43546: LD_VAR 0 1
43550: PPUSH
43551: CALL 54555 0 3
43555: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
43556: LD_VAR 0 1
43560: PPUSH
43561: CALL_OW 263
43565: PUSH
43566: LD_INT 2
43568: EQUAL
43569: IFFALSE 43589
// begin repeat wait ( 0 0$1 ) ;
43571: LD_INT 35
43573: PPUSH
43574: CALL_OW 67
// until IsControledBy ( vehicle ) ;
43578: LD_VAR 0 1
43582: PPUSH
43583: CALL_OW 312
43587: IFFALSE 43571
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
43589: LD_VAR 0 1
43593: PPUSH
43594: LD_EXP 74
43598: PUSH
43599: LD_VAR 0 4
43603: ARRAY
43604: PPUSH
43605: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
43609: LD_VAR 0 1
43613: PPUSH
43614: CALL_OW 263
43618: PUSH
43619: LD_INT 1
43621: NONEQUAL
43622: IFFALSE 43626
// break ;
43624: GO 43675
// repeat wait ( 0 0$1 ) ;
43626: LD_INT 35
43628: PPUSH
43629: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
43633: LD_VAR 0 1
43637: PPUSH
43638: LD_EXP 74
43642: PUSH
43643: LD_VAR 0 4
43647: ARRAY
43648: PPUSH
43649: CALL_OW 308
43653: IFFALSE 43626
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
43655: LD_VAR 0 1
43659: PPUSH
43660: CALL_OW 311
43664: PPUSH
43665: CALL_OW 121
// exit ;
43669: POP
43670: POP
43671: GO 43677
// end ; end ;
43673: GO 43330
43675: POP
43676: POP
// end ;
43677: LD_VAR 0 3
43681: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
43682: LD_INT 0
43684: PPUSH
43685: PPUSH
43686: PPUSH
43687: PPUSH
// if not mc_bases or not skirmish then
43688: LD_EXP 50
43692: NOT
43693: PUSH
43694: LD_EXP 48
43698: NOT
43699: OR
43700: IFFALSE 43704
// exit ;
43702: GO 44057
// repeat wait ( 0 0$1 ) ;
43704: LD_INT 35
43706: PPUSH
43707: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
43711: LD_VAR 0 2
43715: PPUSH
43716: LD_VAR 0 3
43720: PPUSH
43721: CALL_OW 284
43725: IFFALSE 43704
// if GetResourceTypeXY ( x , y ) = mat_artefact then
43727: LD_VAR 0 2
43731: PPUSH
43732: LD_VAR 0 3
43736: PPUSH
43737: CALL_OW 283
43741: PUSH
43742: LD_INT 4
43744: EQUAL
43745: IFFALSE 43749
// exit ;
43747: GO 44057
// for i = 1 to mc_bases do
43749: LD_ADDR_VAR 0 7
43753: PUSH
43754: DOUBLE
43755: LD_INT 1
43757: DEC
43758: ST_TO_ADDR
43759: LD_EXP 50
43763: PUSH
43764: FOR_TO
43765: IFFALSE 44055
// begin if mc_crates_area [ i ] then
43767: LD_EXP 68
43771: PUSH
43772: LD_VAR 0 7
43776: ARRAY
43777: IFFALSE 43888
// for j in mc_crates_area [ i ] do
43779: LD_ADDR_VAR 0 8
43783: PUSH
43784: LD_EXP 68
43788: PUSH
43789: LD_VAR 0 7
43793: ARRAY
43794: PUSH
43795: FOR_IN
43796: IFFALSE 43886
// if InArea ( x , y , j ) then
43798: LD_VAR 0 2
43802: PPUSH
43803: LD_VAR 0 3
43807: PPUSH
43808: LD_VAR 0 8
43812: PPUSH
43813: CALL_OW 309
43817: IFFALSE 43884
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
43819: LD_ADDR_EXP 66
43823: PUSH
43824: LD_EXP 66
43828: PPUSH
43829: LD_VAR 0 7
43833: PUSH
43834: LD_EXP 66
43838: PUSH
43839: LD_VAR 0 7
43843: ARRAY
43844: PUSH
43845: LD_INT 1
43847: PLUS
43848: PUSH
43849: EMPTY
43850: LIST
43851: LIST
43852: PPUSH
43853: LD_VAR 0 4
43857: PUSH
43858: LD_VAR 0 2
43862: PUSH
43863: LD_VAR 0 3
43867: PUSH
43868: EMPTY
43869: LIST
43870: LIST
43871: LIST
43872: PPUSH
43873: CALL 54555 0 3
43877: ST_TO_ADDR
// exit ;
43878: POP
43879: POP
43880: POP
43881: POP
43882: GO 44057
// end ;
43884: GO 43795
43886: POP
43887: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
43888: LD_ADDR_VAR 0 9
43892: PUSH
43893: LD_EXP 50
43897: PUSH
43898: LD_VAR 0 7
43902: ARRAY
43903: PPUSH
43904: LD_INT 2
43906: PUSH
43907: LD_INT 30
43909: PUSH
43910: LD_INT 0
43912: PUSH
43913: EMPTY
43914: LIST
43915: LIST
43916: PUSH
43917: LD_INT 30
43919: PUSH
43920: LD_INT 1
43922: PUSH
43923: EMPTY
43924: LIST
43925: LIST
43926: PUSH
43927: EMPTY
43928: LIST
43929: LIST
43930: LIST
43931: PPUSH
43932: CALL_OW 72
43936: ST_TO_ADDR
// if not depot then
43937: LD_VAR 0 9
43941: NOT
43942: IFFALSE 43946
// continue ;
43944: GO 43764
// for j in depot do
43946: LD_ADDR_VAR 0 8
43950: PUSH
43951: LD_VAR 0 9
43955: PUSH
43956: FOR_IN
43957: IFFALSE 44051
// if GetDistUnitXY ( j , x , y ) < 30 then
43959: LD_VAR 0 8
43963: PPUSH
43964: LD_VAR 0 2
43968: PPUSH
43969: LD_VAR 0 3
43973: PPUSH
43974: CALL_OW 297
43978: PUSH
43979: LD_INT 30
43981: LESS
43982: IFFALSE 44049
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
43984: LD_ADDR_EXP 66
43988: PUSH
43989: LD_EXP 66
43993: PPUSH
43994: LD_VAR 0 7
43998: PUSH
43999: LD_EXP 66
44003: PUSH
44004: LD_VAR 0 7
44008: ARRAY
44009: PUSH
44010: LD_INT 1
44012: PLUS
44013: PUSH
44014: EMPTY
44015: LIST
44016: LIST
44017: PPUSH
44018: LD_VAR 0 4
44022: PUSH
44023: LD_VAR 0 2
44027: PUSH
44028: LD_VAR 0 3
44032: PUSH
44033: EMPTY
44034: LIST
44035: LIST
44036: LIST
44037: PPUSH
44038: CALL 54555 0 3
44042: ST_TO_ADDR
// exit ;
44043: POP
44044: POP
44045: POP
44046: POP
44047: GO 44057
// end ;
44049: GO 43956
44051: POP
44052: POP
// end ;
44053: GO 43764
44055: POP
44056: POP
// end ;
44057: LD_VAR 0 6
44061: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
44062: LD_INT 0
44064: PPUSH
44065: PPUSH
44066: PPUSH
44067: PPUSH
// if not mc_bases or not skirmish then
44068: LD_EXP 50
44072: NOT
44073: PUSH
44074: LD_EXP 48
44078: NOT
44079: OR
44080: IFFALSE 44084
// exit ;
44082: GO 44361
// side := GetSide ( lab ) ;
44084: LD_ADDR_VAR 0 4
44088: PUSH
44089: LD_VAR 0 2
44093: PPUSH
44094: CALL_OW 255
44098: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
44099: LD_VAR 0 4
44103: PUSH
44104: LD_EXP 76
44108: IN
44109: NOT
44110: PUSH
44111: LD_EXP 77
44115: NOT
44116: OR
44117: PUSH
44118: LD_EXP 50
44122: NOT
44123: OR
44124: IFFALSE 44128
// exit ;
44126: GO 44361
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
44128: LD_ADDR_EXP 77
44132: PUSH
44133: LD_EXP 77
44137: PPUSH
44138: LD_VAR 0 4
44142: PPUSH
44143: LD_EXP 77
44147: PUSH
44148: LD_VAR 0 4
44152: ARRAY
44153: PUSH
44154: LD_VAR 0 1
44158: DIFF
44159: PPUSH
44160: CALL_OW 1
44164: ST_TO_ADDR
// for i = 1 to mc_bases do
44165: LD_ADDR_VAR 0 5
44169: PUSH
44170: DOUBLE
44171: LD_INT 1
44173: DEC
44174: ST_TO_ADDR
44175: LD_EXP 50
44179: PUSH
44180: FOR_TO
44181: IFFALSE 44359
// begin if lab in mc_bases [ i ] then
44183: LD_VAR 0 2
44187: PUSH
44188: LD_EXP 50
44192: PUSH
44193: LD_VAR 0 5
44197: ARRAY
44198: IN
44199: IFFALSE 44357
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
44201: LD_VAR 0 1
44205: PUSH
44206: LD_INT 11
44208: PUSH
44209: LD_INT 4
44211: PUSH
44212: LD_INT 3
44214: PUSH
44215: LD_INT 2
44217: PUSH
44218: EMPTY
44219: LIST
44220: LIST
44221: LIST
44222: LIST
44223: IN
44224: PUSH
44225: LD_EXP 80
44229: PUSH
44230: LD_VAR 0 5
44234: ARRAY
44235: AND
44236: IFFALSE 44357
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
44238: LD_ADDR_VAR 0 6
44242: PUSH
44243: LD_EXP 80
44247: PUSH
44248: LD_VAR 0 5
44252: ARRAY
44253: PUSH
44254: LD_INT 1
44256: ARRAY
44257: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
44258: LD_ADDR_EXP 80
44262: PUSH
44263: LD_EXP 80
44267: PPUSH
44268: LD_VAR 0 5
44272: PPUSH
44273: EMPTY
44274: PPUSH
44275: CALL_OW 1
44279: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
44280: LD_VAR 0 6
44284: PPUSH
44285: LD_INT 0
44287: PPUSH
44288: CALL_OW 109
// ComExitBuilding ( tmp ) ;
44292: LD_VAR 0 6
44296: PPUSH
44297: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
44301: LD_ADDR_EXP 79
44305: PUSH
44306: LD_EXP 79
44310: PPUSH
44311: LD_VAR 0 5
44315: PPUSH
44316: LD_EXP 79
44320: PUSH
44321: LD_VAR 0 5
44325: ARRAY
44326: PPUSH
44327: LD_INT 1
44329: PPUSH
44330: LD_VAR 0 6
44334: PPUSH
44335: CALL_OW 2
44339: PPUSH
44340: CALL_OW 1
44344: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
44345: LD_VAR 0 5
44349: PPUSH
44350: LD_INT 112
44352: PPUSH
44353: CALL 21357 0 2
// end ; end ; end ;
44357: GO 44180
44359: POP
44360: POP
// end ;
44361: LD_VAR 0 3
44365: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
44366: LD_INT 0
44368: PPUSH
44369: PPUSH
44370: PPUSH
44371: PPUSH
44372: PPUSH
44373: PPUSH
44374: PPUSH
44375: PPUSH
// if not mc_bases or not skirmish then
44376: LD_EXP 50
44380: NOT
44381: PUSH
44382: LD_EXP 48
44386: NOT
44387: OR
44388: IFFALSE 44392
// exit ;
44390: GO 45763
// for i = 1 to mc_bases do
44392: LD_ADDR_VAR 0 3
44396: PUSH
44397: DOUBLE
44398: LD_INT 1
44400: DEC
44401: ST_TO_ADDR
44402: LD_EXP 50
44406: PUSH
44407: FOR_TO
44408: IFFALSE 45761
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
44410: LD_VAR 0 1
44414: PUSH
44415: LD_EXP 50
44419: PUSH
44420: LD_VAR 0 3
44424: ARRAY
44425: IN
44426: PUSH
44427: LD_VAR 0 1
44431: PUSH
44432: LD_EXP 57
44436: PUSH
44437: LD_VAR 0 3
44441: ARRAY
44442: IN
44443: OR
44444: PUSH
44445: LD_VAR 0 1
44449: PUSH
44450: LD_EXP 72
44454: PUSH
44455: LD_VAR 0 3
44459: ARRAY
44460: IN
44461: OR
44462: PUSH
44463: LD_VAR 0 1
44467: PUSH
44468: LD_EXP 69
44472: PUSH
44473: LD_VAR 0 3
44477: ARRAY
44478: IN
44479: OR
44480: PUSH
44481: LD_VAR 0 1
44485: PUSH
44486: LD_EXP 79
44490: PUSH
44491: LD_VAR 0 3
44495: ARRAY
44496: IN
44497: OR
44498: PUSH
44499: LD_VAR 0 1
44503: PUSH
44504: LD_EXP 80
44508: PUSH
44509: LD_VAR 0 3
44513: ARRAY
44514: IN
44515: OR
44516: IFFALSE 45759
// begin if un in mc_ape [ i ] then
44518: LD_VAR 0 1
44522: PUSH
44523: LD_EXP 79
44527: PUSH
44528: LD_VAR 0 3
44532: ARRAY
44533: IN
44534: IFFALSE 44573
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
44536: LD_ADDR_EXP 79
44540: PUSH
44541: LD_EXP 79
44545: PPUSH
44546: LD_VAR 0 3
44550: PPUSH
44551: LD_EXP 79
44555: PUSH
44556: LD_VAR 0 3
44560: ARRAY
44561: PUSH
44562: LD_VAR 0 1
44566: DIFF
44567: PPUSH
44568: CALL_OW 1
44572: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
44573: LD_VAR 0 1
44577: PUSH
44578: LD_EXP 80
44582: PUSH
44583: LD_VAR 0 3
44587: ARRAY
44588: IN
44589: IFFALSE 44613
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
44591: LD_ADDR_EXP 80
44595: PUSH
44596: LD_EXP 80
44600: PPUSH
44601: LD_VAR 0 3
44605: PPUSH
44606: EMPTY
44607: PPUSH
44608: CALL_OW 1
44612: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
44613: LD_VAR 0 1
44617: PPUSH
44618: CALL_OW 247
44622: PUSH
44623: LD_INT 2
44625: EQUAL
44626: PUSH
44627: LD_VAR 0 1
44631: PPUSH
44632: CALL_OW 110
44636: PUSH
44637: LD_INT 20
44639: EQUAL
44640: PUSH
44641: LD_VAR 0 1
44645: PUSH
44646: LD_EXP 72
44650: PUSH
44651: LD_VAR 0 3
44655: ARRAY
44656: IN
44657: OR
44658: PUSH
44659: LD_VAR 0 1
44663: PPUSH
44664: CALL_OW 264
44668: PUSH
44669: LD_INT 12
44671: PUSH
44672: LD_INT 51
44674: PUSH
44675: LD_EXP 94
44679: PUSH
44680: LD_INT 32
44682: PUSH
44683: LD_INT 13
44685: PUSH
44686: LD_INT 52
44688: PUSH
44689: LD_INT 31
44691: PUSH
44692: EMPTY
44693: LIST
44694: LIST
44695: LIST
44696: LIST
44697: LIST
44698: LIST
44699: LIST
44700: IN
44701: OR
44702: AND
44703: IFFALSE 45011
// begin if un in mc_defender [ i ] then
44705: LD_VAR 0 1
44709: PUSH
44710: LD_EXP 72
44714: PUSH
44715: LD_VAR 0 3
44719: ARRAY
44720: IN
44721: IFFALSE 44760
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
44723: LD_ADDR_EXP 72
44727: PUSH
44728: LD_EXP 72
44732: PPUSH
44733: LD_VAR 0 3
44737: PPUSH
44738: LD_EXP 72
44742: PUSH
44743: LD_VAR 0 3
44747: ARRAY
44748: PUSH
44749: LD_VAR 0 1
44753: DIFF
44754: PPUSH
44755: CALL_OW 1
44759: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
44760: LD_ADDR_VAR 0 8
44764: PUSH
44765: LD_VAR 0 3
44769: PPUSH
44770: LD_INT 3
44772: PPUSH
44773: CALL 41429 0 2
44777: ST_TO_ADDR
// if fac then
44778: LD_VAR 0 8
44782: IFFALSE 45011
// begin for j in fac do
44784: LD_ADDR_VAR 0 4
44788: PUSH
44789: LD_VAR 0 8
44793: PUSH
44794: FOR_IN
44795: IFFALSE 45009
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
44797: LD_ADDR_VAR 0 9
44801: PUSH
44802: LD_VAR 0 8
44806: PPUSH
44807: LD_VAR 0 1
44811: PPUSH
44812: CALL_OW 265
44816: PPUSH
44817: LD_VAR 0 1
44821: PPUSH
44822: CALL_OW 262
44826: PPUSH
44827: LD_VAR 0 1
44831: PPUSH
44832: CALL_OW 263
44836: PPUSH
44837: LD_VAR 0 1
44841: PPUSH
44842: CALL_OW 264
44846: PPUSH
44847: CALL 52087 0 5
44851: ST_TO_ADDR
// if components then
44852: LD_VAR 0 9
44856: IFFALSE 45007
// begin if GetWeapon ( un ) = ar_control_tower then
44858: LD_VAR 0 1
44862: PPUSH
44863: CALL_OW 264
44867: PUSH
44868: LD_INT 31
44870: EQUAL
44871: IFFALSE 44988
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
44873: LD_VAR 0 1
44877: PPUSH
44878: CALL_OW 311
44882: PPUSH
44883: LD_INT 0
44885: PPUSH
44886: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
44890: LD_ADDR_EXP 90
44894: PUSH
44895: LD_EXP 90
44899: PPUSH
44900: LD_VAR 0 3
44904: PPUSH
44905: LD_EXP 90
44909: PUSH
44910: LD_VAR 0 3
44914: ARRAY
44915: PUSH
44916: LD_VAR 0 1
44920: PPUSH
44921: CALL_OW 311
44925: DIFF
44926: PPUSH
44927: CALL_OW 1
44931: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
44932: LD_ADDR_VAR 0 7
44936: PUSH
44937: LD_EXP 71
44941: PUSH
44942: LD_VAR 0 3
44946: ARRAY
44947: PPUSH
44948: LD_INT 1
44950: PPUSH
44951: LD_VAR 0 9
44955: PPUSH
44956: CALL_OW 2
44960: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
44961: LD_ADDR_EXP 71
44965: PUSH
44966: LD_EXP 71
44970: PPUSH
44971: LD_VAR 0 3
44975: PPUSH
44976: LD_VAR 0 7
44980: PPUSH
44981: CALL_OW 1
44985: ST_TO_ADDR
// end else
44986: GO 45005
// MC_InsertProduceList ( i , [ components ] ) ;
44988: LD_VAR 0 3
44992: PPUSH
44993: LD_VAR 0 9
44997: PUSH
44998: EMPTY
44999: LIST
45000: PPUSH
45001: CALL 40974 0 2
// break ;
45005: GO 45009
// end ; end ;
45007: GO 44794
45009: POP
45010: POP
// end ; end ; if GetType ( un ) = unit_building then
45011: LD_VAR 0 1
45015: PPUSH
45016: CALL_OW 247
45020: PUSH
45021: LD_INT 3
45023: EQUAL
45024: IFFALSE 45427
// begin btype := GetBType ( un ) ;
45026: LD_ADDR_VAR 0 5
45030: PUSH
45031: LD_VAR 0 1
45035: PPUSH
45036: CALL_OW 266
45040: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
45041: LD_VAR 0 5
45045: PUSH
45046: LD_INT 29
45048: PUSH
45049: LD_INT 30
45051: PUSH
45052: EMPTY
45053: LIST
45054: LIST
45055: IN
45056: IFFALSE 45129
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
45058: LD_VAR 0 1
45062: PPUSH
45063: CALL_OW 250
45067: PPUSH
45068: LD_VAR 0 1
45072: PPUSH
45073: CALL_OW 251
45077: PPUSH
45078: LD_VAR 0 1
45082: PPUSH
45083: CALL_OW 255
45087: PPUSH
45088: CALL_OW 440
45092: NOT
45093: IFFALSE 45129
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
45095: LD_VAR 0 1
45099: PPUSH
45100: CALL_OW 250
45104: PPUSH
45105: LD_VAR 0 1
45109: PPUSH
45110: CALL_OW 251
45114: PPUSH
45115: LD_VAR 0 1
45119: PPUSH
45120: CALL_OW 255
45124: PPUSH
45125: CALL_OW 441
// end ; if btype = b_warehouse then
45129: LD_VAR 0 5
45133: PUSH
45134: LD_INT 1
45136: EQUAL
45137: IFFALSE 45155
// begin btype := b_depot ;
45139: LD_ADDR_VAR 0 5
45143: PUSH
45144: LD_INT 0
45146: ST_TO_ADDR
// pos := 1 ;
45147: LD_ADDR_VAR 0 6
45151: PUSH
45152: LD_INT 1
45154: ST_TO_ADDR
// end ; if btype = b_factory then
45155: LD_VAR 0 5
45159: PUSH
45160: LD_INT 3
45162: EQUAL
45163: IFFALSE 45181
// begin btype := b_workshop ;
45165: LD_ADDR_VAR 0 5
45169: PUSH
45170: LD_INT 2
45172: ST_TO_ADDR
// pos := 1 ;
45173: LD_ADDR_VAR 0 6
45177: PUSH
45178: LD_INT 1
45180: ST_TO_ADDR
// end ; if btype = b_barracks then
45181: LD_VAR 0 5
45185: PUSH
45186: LD_INT 5
45188: EQUAL
45189: IFFALSE 45199
// btype := b_armoury ;
45191: LD_ADDR_VAR 0 5
45195: PUSH
45196: LD_INT 4
45198: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
45199: LD_VAR 0 5
45203: PUSH
45204: LD_INT 7
45206: PUSH
45207: LD_INT 8
45209: PUSH
45210: EMPTY
45211: LIST
45212: LIST
45213: IN
45214: IFFALSE 45224
// btype := b_lab ;
45216: LD_ADDR_VAR 0 5
45220: PUSH
45221: LD_INT 6
45223: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
45224: LD_ADDR_EXP 55
45228: PUSH
45229: LD_EXP 55
45233: PPUSH
45234: LD_VAR 0 3
45238: PUSH
45239: LD_EXP 55
45243: PUSH
45244: LD_VAR 0 3
45248: ARRAY
45249: PUSH
45250: LD_INT 1
45252: PLUS
45253: PUSH
45254: EMPTY
45255: LIST
45256: LIST
45257: PPUSH
45258: LD_VAR 0 5
45262: PUSH
45263: LD_VAR 0 1
45267: PPUSH
45268: CALL_OW 250
45272: PUSH
45273: LD_VAR 0 1
45277: PPUSH
45278: CALL_OW 251
45282: PUSH
45283: LD_VAR 0 1
45287: PPUSH
45288: CALL_OW 254
45292: PUSH
45293: EMPTY
45294: LIST
45295: LIST
45296: LIST
45297: LIST
45298: PPUSH
45299: CALL 54555 0 3
45303: ST_TO_ADDR
// if pos = 1 then
45304: LD_VAR 0 6
45308: PUSH
45309: LD_INT 1
45311: EQUAL
45312: IFFALSE 45427
// begin tmp := mc_build_list [ i ] ;
45314: LD_ADDR_VAR 0 7
45318: PUSH
45319: LD_EXP 55
45323: PUSH
45324: LD_VAR 0 3
45328: ARRAY
45329: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
45330: LD_VAR 0 7
45334: PPUSH
45335: LD_INT 2
45337: PUSH
45338: LD_INT 30
45340: PUSH
45341: LD_INT 0
45343: PUSH
45344: EMPTY
45345: LIST
45346: LIST
45347: PUSH
45348: LD_INT 30
45350: PUSH
45351: LD_INT 1
45353: PUSH
45354: EMPTY
45355: LIST
45356: LIST
45357: PUSH
45358: EMPTY
45359: LIST
45360: LIST
45361: LIST
45362: PPUSH
45363: CALL_OW 72
45367: IFFALSE 45377
// pos := 2 ;
45369: LD_ADDR_VAR 0 6
45373: PUSH
45374: LD_INT 2
45376: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
45377: LD_ADDR_VAR 0 7
45381: PUSH
45382: LD_VAR 0 7
45386: PPUSH
45387: LD_VAR 0 6
45391: PPUSH
45392: LD_VAR 0 7
45396: PPUSH
45397: CALL 54881 0 3
45401: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
45402: LD_ADDR_EXP 55
45406: PUSH
45407: LD_EXP 55
45411: PPUSH
45412: LD_VAR 0 3
45416: PPUSH
45417: LD_VAR 0 7
45421: PPUSH
45422: CALL_OW 1
45426: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
45427: LD_VAR 0 1
45431: PUSH
45432: LD_EXP 50
45436: PUSH
45437: LD_VAR 0 3
45441: ARRAY
45442: IN
45443: IFFALSE 45482
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
45445: LD_ADDR_EXP 50
45449: PUSH
45450: LD_EXP 50
45454: PPUSH
45455: LD_VAR 0 3
45459: PPUSH
45460: LD_EXP 50
45464: PUSH
45465: LD_VAR 0 3
45469: ARRAY
45470: PUSH
45471: LD_VAR 0 1
45475: DIFF
45476: PPUSH
45477: CALL_OW 1
45481: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
45482: LD_VAR 0 1
45486: PUSH
45487: LD_EXP 57
45491: PUSH
45492: LD_VAR 0 3
45496: ARRAY
45497: IN
45498: IFFALSE 45537
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
45500: LD_ADDR_EXP 57
45504: PUSH
45505: LD_EXP 57
45509: PPUSH
45510: LD_VAR 0 3
45514: PPUSH
45515: LD_EXP 57
45519: PUSH
45520: LD_VAR 0 3
45524: ARRAY
45525: PUSH
45526: LD_VAR 0 1
45530: DIFF
45531: PPUSH
45532: CALL_OW 1
45536: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
45537: LD_VAR 0 1
45541: PUSH
45542: LD_EXP 69
45546: PUSH
45547: LD_VAR 0 3
45551: ARRAY
45552: IN
45553: IFFALSE 45592
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
45555: LD_ADDR_EXP 69
45559: PUSH
45560: LD_EXP 69
45564: PPUSH
45565: LD_VAR 0 3
45569: PPUSH
45570: LD_EXP 69
45574: PUSH
45575: LD_VAR 0 3
45579: ARRAY
45580: PUSH
45581: LD_VAR 0 1
45585: DIFF
45586: PPUSH
45587: CALL_OW 1
45591: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
45592: LD_VAR 0 1
45596: PUSH
45597: LD_EXP 72
45601: PUSH
45602: LD_VAR 0 3
45606: ARRAY
45607: IN
45608: IFFALSE 45647
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
45610: LD_ADDR_EXP 72
45614: PUSH
45615: LD_EXP 72
45619: PPUSH
45620: LD_VAR 0 3
45624: PPUSH
45625: LD_EXP 72
45629: PUSH
45630: LD_VAR 0 3
45634: ARRAY
45635: PUSH
45636: LD_VAR 0 1
45640: DIFF
45641: PPUSH
45642: CALL_OW 1
45646: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
45647: LD_VAR 0 1
45651: PUSH
45652: LD_EXP 59
45656: PUSH
45657: LD_VAR 0 3
45661: ARRAY
45662: IN
45663: IFFALSE 45702
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
45665: LD_ADDR_EXP 59
45669: PUSH
45670: LD_EXP 59
45674: PPUSH
45675: LD_VAR 0 3
45679: PPUSH
45680: LD_EXP 59
45684: PUSH
45685: LD_VAR 0 3
45689: ARRAY
45690: PUSH
45691: LD_VAR 0 1
45695: DIFF
45696: PPUSH
45697: CALL_OW 1
45701: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
45702: LD_VAR 0 1
45706: PUSH
45707: LD_EXP 58
45711: PUSH
45712: LD_VAR 0 3
45716: ARRAY
45717: IN
45718: IFFALSE 45757
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
45720: LD_ADDR_EXP 58
45724: PUSH
45725: LD_EXP 58
45729: PPUSH
45730: LD_VAR 0 3
45734: PPUSH
45735: LD_EXP 58
45739: PUSH
45740: LD_VAR 0 3
45744: ARRAY
45745: PUSH
45746: LD_VAR 0 1
45750: DIFF
45751: PPUSH
45752: CALL_OW 1
45756: ST_TO_ADDR
// end ; break ;
45757: GO 45761
// end ;
45759: GO 44407
45761: POP
45762: POP
// end ;
45763: LD_VAR 0 2
45767: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
45768: LD_INT 0
45770: PPUSH
45771: PPUSH
45772: PPUSH
// if not mc_bases or not skirmish then
45773: LD_EXP 50
45777: NOT
45778: PUSH
45779: LD_EXP 48
45783: NOT
45784: OR
45785: IFFALSE 45789
// exit ;
45787: GO 46004
// for i = 1 to mc_bases do
45789: LD_ADDR_VAR 0 3
45793: PUSH
45794: DOUBLE
45795: LD_INT 1
45797: DEC
45798: ST_TO_ADDR
45799: LD_EXP 50
45803: PUSH
45804: FOR_TO
45805: IFFALSE 46002
// begin if building in mc_construct_list [ i ] then
45807: LD_VAR 0 1
45811: PUSH
45812: LD_EXP 57
45816: PUSH
45817: LD_VAR 0 3
45821: ARRAY
45822: IN
45823: IFFALSE 46000
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
45825: LD_ADDR_EXP 57
45829: PUSH
45830: LD_EXP 57
45834: PPUSH
45835: LD_VAR 0 3
45839: PPUSH
45840: LD_EXP 57
45844: PUSH
45845: LD_VAR 0 3
45849: ARRAY
45850: PUSH
45851: LD_VAR 0 1
45855: DIFF
45856: PPUSH
45857: CALL_OW 1
45861: ST_TO_ADDR
// if building in mc_lab [ i ] then
45862: LD_VAR 0 1
45866: PUSH
45867: LD_EXP 83
45871: PUSH
45872: LD_VAR 0 3
45876: ARRAY
45877: IN
45878: IFFALSE 45933
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
45880: LD_ADDR_EXP 84
45884: PUSH
45885: LD_EXP 84
45889: PPUSH
45890: LD_VAR 0 3
45894: PPUSH
45895: LD_EXP 84
45899: PUSH
45900: LD_VAR 0 3
45904: ARRAY
45905: PPUSH
45906: LD_INT 1
45908: PPUSH
45909: LD_EXP 84
45913: PUSH
45914: LD_VAR 0 3
45918: ARRAY
45919: PPUSH
45920: LD_INT 0
45922: PPUSH
45923: CALL 53973 0 4
45927: PPUSH
45928: CALL_OW 1
45932: ST_TO_ADDR
// if not building in mc_bases [ i ] then
45933: LD_VAR 0 1
45937: PUSH
45938: LD_EXP 50
45942: PUSH
45943: LD_VAR 0 3
45947: ARRAY
45948: IN
45949: NOT
45950: IFFALSE 45996
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
45952: LD_ADDR_EXP 50
45956: PUSH
45957: LD_EXP 50
45961: PPUSH
45962: LD_VAR 0 3
45966: PUSH
45967: LD_EXP 50
45971: PUSH
45972: LD_VAR 0 3
45976: ARRAY
45977: PUSH
45978: LD_INT 1
45980: PLUS
45981: PUSH
45982: EMPTY
45983: LIST
45984: LIST
45985: PPUSH
45986: LD_VAR 0 1
45990: PPUSH
45991: CALL 54555 0 3
45995: ST_TO_ADDR
// exit ;
45996: POP
45997: POP
45998: GO 46004
// end ; end ;
46000: GO 45804
46002: POP
46003: POP
// end ;
46004: LD_VAR 0 2
46008: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
46009: LD_INT 0
46011: PPUSH
46012: PPUSH
46013: PPUSH
46014: PPUSH
46015: PPUSH
46016: PPUSH
46017: PPUSH
// if not mc_bases or not skirmish then
46018: LD_EXP 50
46022: NOT
46023: PUSH
46024: LD_EXP 48
46028: NOT
46029: OR
46030: IFFALSE 46034
// exit ;
46032: GO 46695
// for i = 1 to mc_bases do
46034: LD_ADDR_VAR 0 3
46038: PUSH
46039: DOUBLE
46040: LD_INT 1
46042: DEC
46043: ST_TO_ADDR
46044: LD_EXP 50
46048: PUSH
46049: FOR_TO
46050: IFFALSE 46693
// begin if building in mc_construct_list [ i ] then
46052: LD_VAR 0 1
46056: PUSH
46057: LD_EXP 57
46061: PUSH
46062: LD_VAR 0 3
46066: ARRAY
46067: IN
46068: IFFALSE 46691
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
46070: LD_ADDR_EXP 57
46074: PUSH
46075: LD_EXP 57
46079: PPUSH
46080: LD_VAR 0 3
46084: PPUSH
46085: LD_EXP 57
46089: PUSH
46090: LD_VAR 0 3
46094: ARRAY
46095: PUSH
46096: LD_VAR 0 1
46100: DIFF
46101: PPUSH
46102: CALL_OW 1
46106: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
46107: LD_ADDR_EXP 50
46111: PUSH
46112: LD_EXP 50
46116: PPUSH
46117: LD_VAR 0 3
46121: PUSH
46122: LD_EXP 50
46126: PUSH
46127: LD_VAR 0 3
46131: ARRAY
46132: PUSH
46133: LD_INT 1
46135: PLUS
46136: PUSH
46137: EMPTY
46138: LIST
46139: LIST
46140: PPUSH
46141: LD_VAR 0 1
46145: PPUSH
46146: CALL 54555 0 3
46150: ST_TO_ADDR
// btype := GetBType ( building ) ;
46151: LD_ADDR_VAR 0 5
46155: PUSH
46156: LD_VAR 0 1
46160: PPUSH
46161: CALL_OW 266
46165: ST_TO_ADDR
// side := GetSide ( building ) ;
46166: LD_ADDR_VAR 0 8
46170: PUSH
46171: LD_VAR 0 1
46175: PPUSH
46176: CALL_OW 255
46180: ST_TO_ADDR
// if btype = b_lab then
46181: LD_VAR 0 5
46185: PUSH
46186: LD_INT 6
46188: EQUAL
46189: IFFALSE 46239
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
46191: LD_ADDR_EXP 83
46195: PUSH
46196: LD_EXP 83
46200: PPUSH
46201: LD_VAR 0 3
46205: PUSH
46206: LD_EXP 83
46210: PUSH
46211: LD_VAR 0 3
46215: ARRAY
46216: PUSH
46217: LD_INT 1
46219: PLUS
46220: PUSH
46221: EMPTY
46222: LIST
46223: LIST
46224: PPUSH
46225: LD_VAR 0 1
46229: PPUSH
46230: CALL 54555 0 3
46234: ST_TO_ADDR
// exit ;
46235: POP
46236: POP
46237: GO 46695
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
46239: LD_VAR 0 5
46243: PUSH
46244: LD_INT 0
46246: PUSH
46247: LD_INT 2
46249: PUSH
46250: LD_INT 4
46252: PUSH
46253: EMPTY
46254: LIST
46255: LIST
46256: LIST
46257: IN
46258: IFFALSE 46382
// begin if btype = b_armoury then
46260: LD_VAR 0 5
46264: PUSH
46265: LD_INT 4
46267: EQUAL
46268: IFFALSE 46278
// btype := b_barracks ;
46270: LD_ADDR_VAR 0 5
46274: PUSH
46275: LD_INT 5
46277: ST_TO_ADDR
// if btype = b_depot then
46278: LD_VAR 0 5
46282: PUSH
46283: LD_INT 0
46285: EQUAL
46286: IFFALSE 46296
// btype := b_warehouse ;
46288: LD_ADDR_VAR 0 5
46292: PUSH
46293: LD_INT 1
46295: ST_TO_ADDR
// if btype = b_workshop then
46296: LD_VAR 0 5
46300: PUSH
46301: LD_INT 2
46303: EQUAL
46304: IFFALSE 46314
// btype := b_factory ;
46306: LD_ADDR_VAR 0 5
46310: PUSH
46311: LD_INT 3
46313: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
46314: LD_VAR 0 5
46318: PPUSH
46319: LD_VAR 0 8
46323: PPUSH
46324: CALL_OW 323
46328: PUSH
46329: LD_INT 1
46331: EQUAL
46332: IFFALSE 46378
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
46334: LD_ADDR_EXP 82
46338: PUSH
46339: LD_EXP 82
46343: PPUSH
46344: LD_VAR 0 3
46348: PUSH
46349: LD_EXP 82
46353: PUSH
46354: LD_VAR 0 3
46358: ARRAY
46359: PUSH
46360: LD_INT 1
46362: PLUS
46363: PUSH
46364: EMPTY
46365: LIST
46366: LIST
46367: PPUSH
46368: LD_VAR 0 1
46372: PPUSH
46373: CALL 54555 0 3
46377: ST_TO_ADDR
// exit ;
46378: POP
46379: POP
46380: GO 46695
// end ; if btype in [ b_bunker , b_turret ] then
46382: LD_VAR 0 5
46386: PUSH
46387: LD_INT 32
46389: PUSH
46390: LD_INT 33
46392: PUSH
46393: EMPTY
46394: LIST
46395: LIST
46396: IN
46397: IFFALSE 46687
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
46399: LD_ADDR_EXP 58
46403: PUSH
46404: LD_EXP 58
46408: PPUSH
46409: LD_VAR 0 3
46413: PUSH
46414: LD_EXP 58
46418: PUSH
46419: LD_VAR 0 3
46423: ARRAY
46424: PUSH
46425: LD_INT 1
46427: PLUS
46428: PUSH
46429: EMPTY
46430: LIST
46431: LIST
46432: PPUSH
46433: LD_VAR 0 1
46437: PPUSH
46438: CALL 54555 0 3
46442: ST_TO_ADDR
// if btype = b_bunker then
46443: LD_VAR 0 5
46447: PUSH
46448: LD_INT 32
46450: EQUAL
46451: IFFALSE 46687
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
46453: LD_ADDR_EXP 59
46457: PUSH
46458: LD_EXP 59
46462: PPUSH
46463: LD_VAR 0 3
46467: PUSH
46468: LD_EXP 59
46472: PUSH
46473: LD_VAR 0 3
46477: ARRAY
46478: PUSH
46479: LD_INT 1
46481: PLUS
46482: PUSH
46483: EMPTY
46484: LIST
46485: LIST
46486: PPUSH
46487: LD_VAR 0 1
46491: PPUSH
46492: CALL 54555 0 3
46496: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
46497: LD_ADDR_VAR 0 6
46501: PUSH
46502: LD_EXP 50
46506: PUSH
46507: LD_VAR 0 3
46511: ARRAY
46512: PPUSH
46513: LD_INT 25
46515: PUSH
46516: LD_INT 1
46518: PUSH
46519: EMPTY
46520: LIST
46521: LIST
46522: PUSH
46523: LD_INT 3
46525: PUSH
46526: LD_INT 54
46528: PUSH
46529: EMPTY
46530: LIST
46531: PUSH
46532: EMPTY
46533: LIST
46534: LIST
46535: PUSH
46536: EMPTY
46537: LIST
46538: LIST
46539: PPUSH
46540: CALL_OW 72
46544: ST_TO_ADDR
// if tmp then
46545: LD_VAR 0 6
46549: IFFALSE 46555
// exit ;
46551: POP
46552: POP
46553: GO 46695
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
46555: LD_ADDR_VAR 0 6
46559: PUSH
46560: LD_EXP 50
46564: PUSH
46565: LD_VAR 0 3
46569: ARRAY
46570: PPUSH
46571: LD_INT 2
46573: PUSH
46574: LD_INT 30
46576: PUSH
46577: LD_INT 4
46579: PUSH
46580: EMPTY
46581: LIST
46582: LIST
46583: PUSH
46584: LD_INT 30
46586: PUSH
46587: LD_INT 5
46589: PUSH
46590: EMPTY
46591: LIST
46592: LIST
46593: PUSH
46594: EMPTY
46595: LIST
46596: LIST
46597: LIST
46598: PPUSH
46599: CALL_OW 72
46603: ST_TO_ADDR
// if not tmp then
46604: LD_VAR 0 6
46608: NOT
46609: IFFALSE 46615
// exit ;
46611: POP
46612: POP
46613: GO 46695
// for j in tmp do
46615: LD_ADDR_VAR 0 4
46619: PUSH
46620: LD_VAR 0 6
46624: PUSH
46625: FOR_IN
46626: IFFALSE 46685
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
46628: LD_ADDR_VAR 0 7
46632: PUSH
46633: LD_VAR 0 4
46637: PPUSH
46638: CALL_OW 313
46642: PPUSH
46643: LD_INT 25
46645: PUSH
46646: LD_INT 1
46648: PUSH
46649: EMPTY
46650: LIST
46651: LIST
46652: PPUSH
46653: CALL_OW 72
46657: ST_TO_ADDR
// if units then
46658: LD_VAR 0 7
46662: IFFALSE 46683
// begin ComExitBuilding ( units [ 1 ] ) ;
46664: LD_VAR 0 7
46668: PUSH
46669: LD_INT 1
46671: ARRAY
46672: PPUSH
46673: CALL_OW 122
// exit ;
46677: POP
46678: POP
46679: POP
46680: POP
46681: GO 46695
// end ; end ;
46683: GO 46625
46685: POP
46686: POP
// end ; end ; exit ;
46687: POP
46688: POP
46689: GO 46695
// end ; end ;
46691: GO 46049
46693: POP
46694: POP
// end ;
46695: LD_VAR 0 2
46699: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
46700: LD_INT 0
46702: PPUSH
46703: PPUSH
46704: PPUSH
46705: PPUSH
46706: PPUSH
46707: PPUSH
46708: PPUSH
// if not mc_bases or not skirmish then
46709: LD_EXP 50
46713: NOT
46714: PUSH
46715: LD_EXP 48
46719: NOT
46720: OR
46721: IFFALSE 46725
// exit ;
46723: GO 46956
// btype := GetBType ( building ) ;
46725: LD_ADDR_VAR 0 6
46729: PUSH
46730: LD_VAR 0 1
46734: PPUSH
46735: CALL_OW 266
46739: ST_TO_ADDR
// x := GetX ( building ) ;
46740: LD_ADDR_VAR 0 7
46744: PUSH
46745: LD_VAR 0 1
46749: PPUSH
46750: CALL_OW 250
46754: ST_TO_ADDR
// y := GetY ( building ) ;
46755: LD_ADDR_VAR 0 8
46759: PUSH
46760: LD_VAR 0 1
46764: PPUSH
46765: CALL_OW 251
46769: ST_TO_ADDR
// d := GetDir ( building ) ;
46770: LD_ADDR_VAR 0 9
46774: PUSH
46775: LD_VAR 0 1
46779: PPUSH
46780: CALL_OW 254
46784: ST_TO_ADDR
// for i = 1 to mc_bases do
46785: LD_ADDR_VAR 0 4
46789: PUSH
46790: DOUBLE
46791: LD_INT 1
46793: DEC
46794: ST_TO_ADDR
46795: LD_EXP 50
46799: PUSH
46800: FOR_TO
46801: IFFALSE 46954
// begin if not mc_build_list [ i ] then
46803: LD_EXP 55
46807: PUSH
46808: LD_VAR 0 4
46812: ARRAY
46813: NOT
46814: IFFALSE 46818
// continue ;
46816: GO 46800
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
46818: LD_VAR 0 6
46822: PUSH
46823: LD_VAR 0 7
46827: PUSH
46828: LD_VAR 0 8
46832: PUSH
46833: LD_VAR 0 9
46837: PUSH
46838: EMPTY
46839: LIST
46840: LIST
46841: LIST
46842: LIST
46843: PPUSH
46844: LD_EXP 55
46848: PUSH
46849: LD_VAR 0 4
46853: ARRAY
46854: PUSH
46855: LD_INT 1
46857: ARRAY
46858: PPUSH
46859: CALL 60724 0 2
46863: IFFALSE 46952
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
46865: LD_ADDR_EXP 55
46869: PUSH
46870: LD_EXP 55
46874: PPUSH
46875: LD_VAR 0 4
46879: PPUSH
46880: LD_EXP 55
46884: PUSH
46885: LD_VAR 0 4
46889: ARRAY
46890: PPUSH
46891: LD_INT 1
46893: PPUSH
46894: CALL_OW 3
46898: PPUSH
46899: CALL_OW 1
46903: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
46904: LD_ADDR_EXP 57
46908: PUSH
46909: LD_EXP 57
46913: PPUSH
46914: LD_VAR 0 4
46918: PUSH
46919: LD_EXP 57
46923: PUSH
46924: LD_VAR 0 4
46928: ARRAY
46929: PUSH
46930: LD_INT 1
46932: PLUS
46933: PUSH
46934: EMPTY
46935: LIST
46936: LIST
46937: PPUSH
46938: LD_VAR 0 1
46942: PPUSH
46943: CALL 54555 0 3
46947: ST_TO_ADDR
// exit ;
46948: POP
46949: POP
46950: GO 46956
// end ; end ;
46952: GO 46800
46954: POP
46955: POP
// end ;
46956: LD_VAR 0 3
46960: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
46961: LD_INT 0
46963: PPUSH
46964: PPUSH
46965: PPUSH
// if not mc_bases or not skirmish then
46966: LD_EXP 50
46970: NOT
46971: PUSH
46972: LD_EXP 48
46976: NOT
46977: OR
46978: IFFALSE 46982
// exit ;
46980: GO 47172
// for i = 1 to mc_bases do
46982: LD_ADDR_VAR 0 4
46986: PUSH
46987: DOUBLE
46988: LD_INT 1
46990: DEC
46991: ST_TO_ADDR
46992: LD_EXP 50
46996: PUSH
46997: FOR_TO
46998: IFFALSE 47085
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
47000: LD_VAR 0 1
47004: PUSH
47005: LD_EXP 58
47009: PUSH
47010: LD_VAR 0 4
47014: ARRAY
47015: IN
47016: PUSH
47017: LD_VAR 0 1
47021: PUSH
47022: LD_EXP 59
47026: PUSH
47027: LD_VAR 0 4
47031: ARRAY
47032: IN
47033: NOT
47034: AND
47035: IFFALSE 47083
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
47037: LD_ADDR_EXP 59
47041: PUSH
47042: LD_EXP 59
47046: PPUSH
47047: LD_VAR 0 4
47051: PUSH
47052: LD_EXP 59
47056: PUSH
47057: LD_VAR 0 4
47061: ARRAY
47062: PUSH
47063: LD_INT 1
47065: PLUS
47066: PUSH
47067: EMPTY
47068: LIST
47069: LIST
47070: PPUSH
47071: LD_VAR 0 1
47075: PPUSH
47076: CALL 54555 0 3
47080: ST_TO_ADDR
// break ;
47081: GO 47085
// end ; end ;
47083: GO 46997
47085: POP
47086: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
47087: LD_VAR 0 1
47091: PPUSH
47092: CALL_OW 257
47096: PUSH
47097: LD_EXP 76
47101: IN
47102: PUSH
47103: LD_VAR 0 1
47107: PPUSH
47108: CALL_OW 266
47112: PUSH
47113: LD_INT 5
47115: EQUAL
47116: AND
47117: PUSH
47118: LD_VAR 0 2
47122: PPUSH
47123: CALL_OW 110
47127: PUSH
47128: LD_INT 18
47130: NONEQUAL
47131: AND
47132: IFFALSE 47172
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
47134: LD_VAR 0 2
47138: PPUSH
47139: CALL_OW 257
47143: PUSH
47144: LD_INT 5
47146: PUSH
47147: LD_INT 8
47149: PUSH
47150: LD_INT 9
47152: PUSH
47153: EMPTY
47154: LIST
47155: LIST
47156: LIST
47157: IN
47158: IFFALSE 47172
// SetClass ( unit , 1 ) ;
47160: LD_VAR 0 2
47164: PPUSH
47165: LD_INT 1
47167: PPUSH
47168: CALL_OW 336
// end ;
47172: LD_VAR 0 3
47176: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
47177: LD_INT 0
47179: PPUSH
47180: PPUSH
// if not mc_bases or not skirmish then
47181: LD_EXP 50
47185: NOT
47186: PUSH
47187: LD_EXP 48
47191: NOT
47192: OR
47193: IFFALSE 47197
// exit ;
47195: GO 47313
// if GetLives ( abandoned_vehicle ) > 250 then
47197: LD_VAR 0 2
47201: PPUSH
47202: CALL_OW 256
47206: PUSH
47207: LD_INT 250
47209: GREATER
47210: IFFALSE 47214
// exit ;
47212: GO 47313
// for i = 1 to mc_bases do
47214: LD_ADDR_VAR 0 6
47218: PUSH
47219: DOUBLE
47220: LD_INT 1
47222: DEC
47223: ST_TO_ADDR
47224: LD_EXP 50
47228: PUSH
47229: FOR_TO
47230: IFFALSE 47311
// begin if driver in mc_bases [ i ] then
47232: LD_VAR 0 1
47236: PUSH
47237: LD_EXP 50
47241: PUSH
47242: LD_VAR 0 6
47246: ARRAY
47247: IN
47248: IFFALSE 47309
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
47250: LD_VAR 0 1
47254: PPUSH
47255: LD_EXP 50
47259: PUSH
47260: LD_VAR 0 6
47264: ARRAY
47265: PPUSH
47266: LD_INT 2
47268: PUSH
47269: LD_INT 30
47271: PUSH
47272: LD_INT 0
47274: PUSH
47275: EMPTY
47276: LIST
47277: LIST
47278: PUSH
47279: LD_INT 30
47281: PUSH
47282: LD_INT 1
47284: PUSH
47285: EMPTY
47286: LIST
47287: LIST
47288: PUSH
47289: EMPTY
47290: LIST
47291: LIST
47292: LIST
47293: PPUSH
47294: CALL_OW 72
47298: PUSH
47299: LD_INT 1
47301: ARRAY
47302: PPUSH
47303: CALL_OW 112
// break ;
47307: GO 47311
// end ; end ;
47309: GO 47229
47311: POP
47312: POP
// end ; end_of_file
47313: LD_VAR 0 5
47317: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
47318: LD_INT 0
47320: PPUSH
47321: PPUSH
// if exist_mode then
47322: LD_VAR 0 2
47326: IFFALSE 47351
// unit := CreateCharacter ( prefix & ident ) else
47328: LD_ADDR_VAR 0 5
47332: PUSH
47333: LD_VAR 0 3
47337: PUSH
47338: LD_VAR 0 1
47342: STR
47343: PPUSH
47344: CALL_OW 34
47348: ST_TO_ADDR
47349: GO 47366
// unit := NewCharacter ( ident ) ;
47351: LD_ADDR_VAR 0 5
47355: PUSH
47356: LD_VAR 0 1
47360: PPUSH
47361: CALL_OW 25
47365: ST_TO_ADDR
// result := unit ;
47366: LD_ADDR_VAR 0 4
47370: PUSH
47371: LD_VAR 0 5
47375: ST_TO_ADDR
// end ;
47376: LD_VAR 0 4
47380: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
47381: LD_INT 0
47383: PPUSH
47384: PPUSH
// if not side or not nation then
47385: LD_VAR 0 1
47389: NOT
47390: PUSH
47391: LD_VAR 0 2
47395: NOT
47396: OR
47397: IFFALSE 47401
// exit ;
47399: GO 48045
// case nation of nation_american :
47401: LD_VAR 0 2
47405: PUSH
47406: LD_INT 1
47408: DOUBLE
47409: EQUAL
47410: IFTRUE 47414
47412: GO 47588
47414: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 ] ; nation_arabian :
47415: LD_ADDR_VAR 0 4
47419: PUSH
47420: LD_INT 35
47422: PUSH
47423: LD_INT 45
47425: PUSH
47426: LD_INT 46
47428: PUSH
47429: LD_INT 47
47431: PUSH
47432: LD_INT 1
47434: PUSH
47435: LD_INT 2
47437: PUSH
47438: LD_INT 6
47440: PUSH
47441: LD_INT 15
47443: PUSH
47444: LD_INT 16
47446: PUSH
47447: LD_INT 7
47449: PUSH
47450: LD_INT 12
47452: PUSH
47453: LD_INT 13
47455: PUSH
47456: LD_INT 10
47458: PUSH
47459: LD_INT 14
47461: PUSH
47462: LD_INT 20
47464: PUSH
47465: LD_INT 21
47467: PUSH
47468: LD_INT 22
47470: PUSH
47471: LD_INT 25
47473: PUSH
47474: LD_INT 32
47476: PUSH
47477: LD_INT 27
47479: PUSH
47480: LD_INT 36
47482: PUSH
47483: LD_INT 69
47485: PUSH
47486: LD_INT 39
47488: PUSH
47489: LD_INT 34
47491: PUSH
47492: LD_INT 40
47494: PUSH
47495: LD_INT 48
47497: PUSH
47498: LD_INT 49
47500: PUSH
47501: LD_INT 50
47503: PUSH
47504: LD_INT 51
47506: PUSH
47507: LD_INT 52
47509: PUSH
47510: LD_INT 53
47512: PUSH
47513: LD_INT 54
47515: PUSH
47516: LD_INT 55
47518: PUSH
47519: LD_INT 56
47521: PUSH
47522: LD_INT 57
47524: PUSH
47525: LD_INT 58
47527: PUSH
47528: LD_INT 59
47530: PUSH
47531: LD_INT 60
47533: PUSH
47534: LD_INT 61
47536: PUSH
47537: LD_INT 62
47539: PUSH
47540: LD_INT 80
47542: PUSH
47543: EMPTY
47544: LIST
47545: LIST
47546: LIST
47547: LIST
47548: LIST
47549: LIST
47550: LIST
47551: LIST
47552: LIST
47553: LIST
47554: LIST
47555: LIST
47556: LIST
47557: LIST
47558: LIST
47559: LIST
47560: LIST
47561: LIST
47562: LIST
47563: LIST
47564: LIST
47565: LIST
47566: LIST
47567: LIST
47568: LIST
47569: LIST
47570: LIST
47571: LIST
47572: LIST
47573: LIST
47574: LIST
47575: LIST
47576: LIST
47577: LIST
47578: LIST
47579: LIST
47580: LIST
47581: LIST
47582: LIST
47583: LIST
47584: LIST
47585: ST_TO_ADDR
47586: GO 47969
47588: LD_INT 2
47590: DOUBLE
47591: EQUAL
47592: IFTRUE 47596
47594: GO 47778
47596: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 ] ; nation_russian :
47597: LD_ADDR_VAR 0 4
47601: PUSH
47602: LD_INT 35
47604: PUSH
47605: LD_INT 45
47607: PUSH
47608: LD_INT 46
47610: PUSH
47611: LD_INT 47
47613: PUSH
47614: LD_INT 70
47616: PUSH
47617: LD_INT 1
47619: PUSH
47620: LD_INT 11
47622: PUSH
47623: LD_INT 3
47625: PUSH
47626: LD_INT 4
47628: PUSH
47629: LD_INT 5
47631: PUSH
47632: LD_INT 6
47634: PUSH
47635: LD_INT 15
47637: PUSH
47638: LD_INT 18
47640: PUSH
47641: LD_INT 7
47643: PUSH
47644: LD_INT 17
47646: PUSH
47647: LD_INT 8
47649: PUSH
47650: LD_INT 20
47652: PUSH
47653: LD_INT 21
47655: PUSH
47656: LD_INT 22
47658: PUSH
47659: LD_INT 72
47661: PUSH
47662: LD_INT 26
47664: PUSH
47665: LD_INT 69
47667: PUSH
47668: LD_INT 39
47670: PUSH
47671: LD_INT 40
47673: PUSH
47674: LD_INT 41
47676: PUSH
47677: LD_INT 42
47679: PUSH
47680: LD_INT 43
47682: PUSH
47683: LD_INT 48
47685: PUSH
47686: LD_INT 49
47688: PUSH
47689: LD_INT 50
47691: PUSH
47692: LD_INT 51
47694: PUSH
47695: LD_INT 52
47697: PUSH
47698: LD_INT 53
47700: PUSH
47701: LD_INT 54
47703: PUSH
47704: LD_INT 55
47706: PUSH
47707: LD_INT 56
47709: PUSH
47710: LD_INT 60
47712: PUSH
47713: LD_INT 61
47715: PUSH
47716: LD_INT 62
47718: PUSH
47719: LD_INT 66
47721: PUSH
47722: LD_INT 67
47724: PUSH
47725: LD_INT 68
47727: PUSH
47728: LD_INT 81
47730: PUSH
47731: EMPTY
47732: LIST
47733: LIST
47734: LIST
47735: LIST
47736: LIST
47737: LIST
47738: LIST
47739: LIST
47740: LIST
47741: LIST
47742: LIST
47743: LIST
47744: LIST
47745: LIST
47746: LIST
47747: LIST
47748: LIST
47749: LIST
47750: LIST
47751: LIST
47752: LIST
47753: LIST
47754: LIST
47755: LIST
47756: LIST
47757: LIST
47758: LIST
47759: LIST
47760: LIST
47761: LIST
47762: LIST
47763: LIST
47764: LIST
47765: LIST
47766: LIST
47767: LIST
47768: LIST
47769: LIST
47770: LIST
47771: LIST
47772: LIST
47773: LIST
47774: LIST
47775: ST_TO_ADDR
47776: GO 47969
47778: LD_INT 3
47780: DOUBLE
47781: EQUAL
47782: IFTRUE 47786
47784: GO 47968
47786: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
47787: LD_ADDR_VAR 0 4
47791: PUSH
47792: LD_INT 46
47794: PUSH
47795: LD_INT 47
47797: PUSH
47798: LD_INT 1
47800: PUSH
47801: LD_INT 2
47803: PUSH
47804: LD_INT 11
47806: PUSH
47807: LD_INT 9
47809: PUSH
47810: LD_INT 20
47812: PUSH
47813: LD_INT 19
47815: PUSH
47816: LD_INT 21
47818: PUSH
47819: LD_INT 24
47821: PUSH
47822: LD_INT 22
47824: PUSH
47825: LD_INT 25
47827: PUSH
47828: LD_INT 28
47830: PUSH
47831: LD_INT 29
47833: PUSH
47834: LD_INT 30
47836: PUSH
47837: LD_INT 31
47839: PUSH
47840: LD_INT 37
47842: PUSH
47843: LD_INT 38
47845: PUSH
47846: LD_INT 32
47848: PUSH
47849: LD_INT 27
47851: PUSH
47852: LD_INT 33
47854: PUSH
47855: LD_INT 69
47857: PUSH
47858: LD_INT 39
47860: PUSH
47861: LD_INT 34
47863: PUSH
47864: LD_INT 40
47866: PUSH
47867: LD_INT 71
47869: PUSH
47870: LD_INT 23
47872: PUSH
47873: LD_INT 44
47875: PUSH
47876: LD_INT 48
47878: PUSH
47879: LD_INT 49
47881: PUSH
47882: LD_INT 50
47884: PUSH
47885: LD_INT 51
47887: PUSH
47888: LD_INT 52
47890: PUSH
47891: LD_INT 53
47893: PUSH
47894: LD_INT 54
47896: PUSH
47897: LD_INT 55
47899: PUSH
47900: LD_INT 56
47902: PUSH
47903: LD_INT 57
47905: PUSH
47906: LD_INT 58
47908: PUSH
47909: LD_INT 59
47911: PUSH
47912: LD_INT 63
47914: PUSH
47915: LD_INT 64
47917: PUSH
47918: LD_INT 65
47920: PUSH
47921: EMPTY
47922: LIST
47923: LIST
47924: LIST
47925: LIST
47926: LIST
47927: LIST
47928: LIST
47929: LIST
47930: LIST
47931: LIST
47932: LIST
47933: LIST
47934: LIST
47935: LIST
47936: LIST
47937: LIST
47938: LIST
47939: LIST
47940: LIST
47941: LIST
47942: LIST
47943: LIST
47944: LIST
47945: LIST
47946: LIST
47947: LIST
47948: LIST
47949: LIST
47950: LIST
47951: LIST
47952: LIST
47953: LIST
47954: LIST
47955: LIST
47956: LIST
47957: LIST
47958: LIST
47959: LIST
47960: LIST
47961: LIST
47962: LIST
47963: LIST
47964: LIST
47965: ST_TO_ADDR
47966: GO 47969
47968: POP
// if state > - 1 and state < 3 then
47969: LD_VAR 0 3
47973: PUSH
47974: LD_INT 1
47976: NEG
47977: GREATER
47978: PUSH
47979: LD_VAR 0 3
47983: PUSH
47984: LD_INT 3
47986: LESS
47987: AND
47988: IFFALSE 48045
// for i in result do
47990: LD_ADDR_VAR 0 5
47994: PUSH
47995: LD_VAR 0 4
47999: PUSH
48000: FOR_IN
48001: IFFALSE 48043
// if GetTech ( i , side ) <> state then
48003: LD_VAR 0 5
48007: PPUSH
48008: LD_VAR 0 1
48012: PPUSH
48013: CALL_OW 321
48017: PUSH
48018: LD_VAR 0 3
48022: NONEQUAL
48023: IFFALSE 48041
// result := result diff i ;
48025: LD_ADDR_VAR 0 4
48029: PUSH
48030: LD_VAR 0 4
48034: PUSH
48035: LD_VAR 0 5
48039: DIFF
48040: ST_TO_ADDR
48041: GO 48000
48043: POP
48044: POP
// end ;
48045: LD_VAR 0 4
48049: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
48050: LD_INT 0
48052: PPUSH
48053: PPUSH
48054: PPUSH
// result := true ;
48055: LD_ADDR_VAR 0 3
48059: PUSH
48060: LD_INT 1
48062: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
48063: LD_ADDR_VAR 0 5
48067: PUSH
48068: LD_VAR 0 2
48072: PPUSH
48073: CALL_OW 480
48077: ST_TO_ADDR
// if not tmp then
48078: LD_VAR 0 5
48082: NOT
48083: IFFALSE 48087
// exit ;
48085: GO 48136
// for i in tmp do
48087: LD_ADDR_VAR 0 4
48091: PUSH
48092: LD_VAR 0 5
48096: PUSH
48097: FOR_IN
48098: IFFALSE 48134
// if GetTech ( i , side ) <> state_researched then
48100: LD_VAR 0 4
48104: PPUSH
48105: LD_VAR 0 1
48109: PPUSH
48110: CALL_OW 321
48114: PUSH
48115: LD_INT 2
48117: NONEQUAL
48118: IFFALSE 48132
// begin result := false ;
48120: LD_ADDR_VAR 0 3
48124: PUSH
48125: LD_INT 0
48127: ST_TO_ADDR
// exit ;
48128: POP
48129: POP
48130: GO 48136
// end ;
48132: GO 48097
48134: POP
48135: POP
// end ;
48136: LD_VAR 0 3
48140: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
48141: LD_INT 0
48143: PPUSH
48144: PPUSH
48145: PPUSH
48146: PPUSH
48147: PPUSH
48148: PPUSH
48149: PPUSH
48150: PPUSH
48151: PPUSH
48152: PPUSH
48153: PPUSH
48154: PPUSH
48155: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
48156: LD_VAR 0 1
48160: NOT
48161: PUSH
48162: LD_VAR 0 1
48166: PPUSH
48167: CALL_OW 257
48171: PUSH
48172: LD_INT 9
48174: NONEQUAL
48175: OR
48176: IFFALSE 48180
// exit ;
48178: GO 48753
// side := GetSide ( unit ) ;
48180: LD_ADDR_VAR 0 9
48184: PUSH
48185: LD_VAR 0 1
48189: PPUSH
48190: CALL_OW 255
48194: ST_TO_ADDR
// tech_space := tech_spacanom ;
48195: LD_ADDR_VAR 0 12
48199: PUSH
48200: LD_INT 29
48202: ST_TO_ADDR
// tech_time := tech_taurad ;
48203: LD_ADDR_VAR 0 13
48207: PUSH
48208: LD_INT 28
48210: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
48211: LD_ADDR_VAR 0 11
48215: PUSH
48216: LD_VAR 0 1
48220: PPUSH
48221: CALL_OW 310
48225: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
48226: LD_VAR 0 11
48230: PPUSH
48231: CALL_OW 247
48235: PUSH
48236: LD_INT 2
48238: EQUAL
48239: IFFALSE 48243
// exit ;
48241: GO 48753
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
48243: LD_ADDR_VAR 0 8
48247: PUSH
48248: LD_INT 81
48250: PUSH
48251: LD_VAR 0 9
48255: PUSH
48256: EMPTY
48257: LIST
48258: LIST
48259: PUSH
48260: LD_INT 3
48262: PUSH
48263: LD_INT 21
48265: PUSH
48266: LD_INT 3
48268: PUSH
48269: EMPTY
48270: LIST
48271: LIST
48272: PUSH
48273: EMPTY
48274: LIST
48275: LIST
48276: PUSH
48277: EMPTY
48278: LIST
48279: LIST
48280: PPUSH
48281: CALL_OW 69
48285: ST_TO_ADDR
// if not tmp then
48286: LD_VAR 0 8
48290: NOT
48291: IFFALSE 48295
// exit ;
48293: GO 48753
// if in_unit then
48295: LD_VAR 0 11
48299: IFFALSE 48323
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
48301: LD_ADDR_VAR 0 10
48305: PUSH
48306: LD_VAR 0 8
48310: PPUSH
48311: LD_VAR 0 11
48315: PPUSH
48316: CALL_OW 74
48320: ST_TO_ADDR
48321: GO 48343
// enemy := NearestUnitToUnit ( tmp , unit ) ;
48323: LD_ADDR_VAR 0 10
48327: PUSH
48328: LD_VAR 0 8
48332: PPUSH
48333: LD_VAR 0 1
48337: PPUSH
48338: CALL_OW 74
48342: ST_TO_ADDR
// if not enemy then
48343: LD_VAR 0 10
48347: NOT
48348: IFFALSE 48352
// exit ;
48350: GO 48753
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
48352: LD_VAR 0 11
48356: PUSH
48357: LD_VAR 0 11
48361: PPUSH
48362: LD_VAR 0 10
48366: PPUSH
48367: CALL_OW 296
48371: PUSH
48372: LD_INT 13
48374: GREATER
48375: AND
48376: PUSH
48377: LD_VAR 0 1
48381: PPUSH
48382: LD_VAR 0 10
48386: PPUSH
48387: CALL_OW 296
48391: PUSH
48392: LD_INT 12
48394: GREATER
48395: OR
48396: IFFALSE 48400
// exit ;
48398: GO 48753
// missile := [ 1 ] ;
48400: LD_ADDR_VAR 0 14
48404: PUSH
48405: LD_INT 1
48407: PUSH
48408: EMPTY
48409: LIST
48410: ST_TO_ADDR
// if Researched ( side , tech_space ) then
48411: LD_VAR 0 9
48415: PPUSH
48416: LD_VAR 0 12
48420: PPUSH
48421: CALL_OW 325
48425: IFFALSE 48454
// missile := Insert ( missile , missile + 1 , 2 ) ;
48427: LD_ADDR_VAR 0 14
48431: PUSH
48432: LD_VAR 0 14
48436: PPUSH
48437: LD_VAR 0 14
48441: PUSH
48442: LD_INT 1
48444: PLUS
48445: PPUSH
48446: LD_INT 2
48448: PPUSH
48449: CALL_OW 2
48453: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
48454: LD_VAR 0 9
48458: PPUSH
48459: LD_VAR 0 13
48463: PPUSH
48464: CALL_OW 325
48468: PUSH
48469: LD_VAR 0 10
48473: PPUSH
48474: CALL_OW 255
48478: PPUSH
48479: LD_VAR 0 13
48483: PPUSH
48484: CALL_OW 325
48488: NOT
48489: AND
48490: IFFALSE 48519
// missile := Insert ( missile , missile + 1 , 3 ) ;
48492: LD_ADDR_VAR 0 14
48496: PUSH
48497: LD_VAR 0 14
48501: PPUSH
48502: LD_VAR 0 14
48506: PUSH
48507: LD_INT 1
48509: PLUS
48510: PPUSH
48511: LD_INT 3
48513: PPUSH
48514: CALL_OW 2
48518: ST_TO_ADDR
// if missile < 2 then
48519: LD_VAR 0 14
48523: PUSH
48524: LD_INT 2
48526: LESS
48527: IFFALSE 48531
// exit ;
48529: GO 48753
// x := GetX ( enemy ) ;
48531: LD_ADDR_VAR 0 4
48535: PUSH
48536: LD_VAR 0 10
48540: PPUSH
48541: CALL_OW 250
48545: ST_TO_ADDR
// y := GetY ( enemy ) ;
48546: LD_ADDR_VAR 0 5
48550: PUSH
48551: LD_VAR 0 10
48555: PPUSH
48556: CALL_OW 251
48560: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
48561: LD_ADDR_VAR 0 6
48565: PUSH
48566: LD_VAR 0 4
48570: PUSH
48571: LD_INT 1
48573: NEG
48574: PPUSH
48575: LD_INT 1
48577: PPUSH
48578: CALL_OW 12
48582: PLUS
48583: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
48584: LD_ADDR_VAR 0 7
48588: PUSH
48589: LD_VAR 0 5
48593: PUSH
48594: LD_INT 1
48596: NEG
48597: PPUSH
48598: LD_INT 1
48600: PPUSH
48601: CALL_OW 12
48605: PLUS
48606: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
48607: LD_VAR 0 6
48611: PPUSH
48612: LD_VAR 0 7
48616: PPUSH
48617: CALL_OW 488
48621: NOT
48622: IFFALSE 48644
// begin _x := x ;
48624: LD_ADDR_VAR 0 6
48628: PUSH
48629: LD_VAR 0 4
48633: ST_TO_ADDR
// _y := y ;
48634: LD_ADDR_VAR 0 7
48638: PUSH
48639: LD_VAR 0 5
48643: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
48644: LD_ADDR_VAR 0 3
48648: PUSH
48649: LD_INT 1
48651: PPUSH
48652: LD_VAR 0 14
48656: PPUSH
48657: CALL_OW 12
48661: ST_TO_ADDR
// case i of 1 :
48662: LD_VAR 0 3
48666: PUSH
48667: LD_INT 1
48669: DOUBLE
48670: EQUAL
48671: IFTRUE 48675
48673: GO 48692
48675: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
48676: LD_VAR 0 1
48680: PPUSH
48681: LD_VAR 0 10
48685: PPUSH
48686: CALL_OW 115
48690: GO 48753
48692: LD_INT 2
48694: DOUBLE
48695: EQUAL
48696: IFTRUE 48700
48698: GO 48722
48700: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
48701: LD_VAR 0 1
48705: PPUSH
48706: LD_VAR 0 6
48710: PPUSH
48711: LD_VAR 0 7
48715: PPUSH
48716: CALL_OW 153
48720: GO 48753
48722: LD_INT 3
48724: DOUBLE
48725: EQUAL
48726: IFTRUE 48730
48728: GO 48752
48730: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
48731: LD_VAR 0 1
48735: PPUSH
48736: LD_VAR 0 6
48740: PPUSH
48741: LD_VAR 0 7
48745: PPUSH
48746: CALL_OW 154
48750: GO 48753
48752: POP
// end ;
48753: LD_VAR 0 2
48757: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
48758: LD_INT 0
48760: PPUSH
48761: PPUSH
48762: PPUSH
48763: PPUSH
48764: PPUSH
48765: PPUSH
// if not unit or not building then
48766: LD_VAR 0 1
48770: NOT
48771: PUSH
48772: LD_VAR 0 2
48776: NOT
48777: OR
48778: IFFALSE 48782
// exit ;
48780: GO 48940
// x := GetX ( building ) ;
48782: LD_ADDR_VAR 0 5
48786: PUSH
48787: LD_VAR 0 2
48791: PPUSH
48792: CALL_OW 250
48796: ST_TO_ADDR
// y := GetY ( building ) ;
48797: LD_ADDR_VAR 0 6
48801: PUSH
48802: LD_VAR 0 2
48806: PPUSH
48807: CALL_OW 251
48811: ST_TO_ADDR
// for i = 0 to 5 do
48812: LD_ADDR_VAR 0 4
48816: PUSH
48817: DOUBLE
48818: LD_INT 0
48820: DEC
48821: ST_TO_ADDR
48822: LD_INT 5
48824: PUSH
48825: FOR_TO
48826: IFFALSE 48938
// begin _x := ShiftX ( x , i , 3 ) ;
48828: LD_ADDR_VAR 0 7
48832: PUSH
48833: LD_VAR 0 5
48837: PPUSH
48838: LD_VAR 0 4
48842: PPUSH
48843: LD_INT 3
48845: PPUSH
48846: CALL_OW 272
48850: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
48851: LD_ADDR_VAR 0 8
48855: PUSH
48856: LD_VAR 0 6
48860: PPUSH
48861: LD_VAR 0 4
48865: PPUSH
48866: LD_INT 3
48868: PPUSH
48869: CALL_OW 273
48873: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
48874: LD_VAR 0 7
48878: PPUSH
48879: LD_VAR 0 8
48883: PPUSH
48884: CALL_OW 488
48888: NOT
48889: IFFALSE 48893
// continue ;
48891: GO 48825
// if HexInfo ( _x , _y ) = 0 then
48893: LD_VAR 0 7
48897: PPUSH
48898: LD_VAR 0 8
48902: PPUSH
48903: CALL_OW 428
48907: PUSH
48908: LD_INT 0
48910: EQUAL
48911: IFFALSE 48936
// begin ComMoveXY ( unit , _x , _y ) ;
48913: LD_VAR 0 1
48917: PPUSH
48918: LD_VAR 0 7
48922: PPUSH
48923: LD_VAR 0 8
48927: PPUSH
48928: CALL_OW 111
// exit ;
48932: POP
48933: POP
48934: GO 48940
// end ; end ;
48936: GO 48825
48938: POP
48939: POP
// end ;
48940: LD_VAR 0 3
48944: RET
// export function ScanBase ( side , base_area ) ; begin
48945: LD_INT 0
48947: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
48948: LD_ADDR_VAR 0 3
48952: PUSH
48953: LD_VAR 0 2
48957: PPUSH
48958: LD_INT 81
48960: PUSH
48961: LD_VAR 0 1
48965: PUSH
48966: EMPTY
48967: LIST
48968: LIST
48969: PPUSH
48970: CALL_OW 70
48974: ST_TO_ADDR
// end ;
48975: LD_VAR 0 3
48979: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
48980: LD_INT 0
48982: PPUSH
48983: PPUSH
48984: PPUSH
48985: PPUSH
48986: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
48987: LD_VAR 0 1
48991: NOT
48992: PUSH
48993: LD_EXP 50
48997: PUSH
48998: LD_VAR 0 1
49002: ARRAY
49003: NOT
49004: OR
49005: PUSH
49006: LD_VAR 0 2
49010: NOT
49011: OR
49012: PUSH
49013: LD_VAR 0 3
49017: NOT
49018: OR
49019: IFFALSE 49023
// exit ;
49021: GO 49536
// side := mc_sides [ base ] ;
49023: LD_ADDR_VAR 0 6
49027: PUSH
49028: LD_EXP 76
49032: PUSH
49033: LD_VAR 0 1
49037: ARRAY
49038: ST_TO_ADDR
// if not side then
49039: LD_VAR 0 6
49043: NOT
49044: IFFALSE 49048
// exit ;
49046: GO 49536
// for i in solds do
49048: LD_ADDR_VAR 0 7
49052: PUSH
49053: LD_VAR 0 2
49057: PUSH
49058: FOR_IN
49059: IFFALSE 49120
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
49061: LD_VAR 0 7
49065: PPUSH
49066: CALL_OW 310
49070: PPUSH
49071: CALL_OW 266
49075: PUSH
49076: LD_INT 32
49078: PUSH
49079: LD_INT 31
49081: PUSH
49082: EMPTY
49083: LIST
49084: LIST
49085: IN
49086: IFFALSE 49106
// solds := solds diff i else
49088: LD_ADDR_VAR 0 2
49092: PUSH
49093: LD_VAR 0 2
49097: PUSH
49098: LD_VAR 0 7
49102: DIFF
49103: ST_TO_ADDR
49104: GO 49118
// SetTag ( i , 18 ) ;
49106: LD_VAR 0 7
49110: PPUSH
49111: LD_INT 18
49113: PPUSH
49114: CALL_OW 109
49118: GO 49058
49120: POP
49121: POP
// if not solds then
49122: LD_VAR 0 2
49126: NOT
49127: IFFALSE 49131
// exit ;
49129: GO 49536
// repeat wait ( 0 0$1 ) ;
49131: LD_INT 35
49133: PPUSH
49134: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
49138: LD_ADDR_VAR 0 5
49142: PUSH
49143: LD_VAR 0 6
49147: PPUSH
49148: LD_VAR 0 3
49152: PPUSH
49153: CALL 48945 0 2
49157: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
49158: LD_EXP 50
49162: PUSH
49163: LD_VAR 0 1
49167: ARRAY
49168: NOT
49169: PUSH
49170: LD_EXP 50
49174: PUSH
49175: LD_VAR 0 1
49179: ARRAY
49180: PUSH
49181: EMPTY
49182: EQUAL
49183: OR
49184: IFFALSE 49221
// begin for i in solds do
49186: LD_ADDR_VAR 0 7
49190: PUSH
49191: LD_VAR 0 2
49195: PUSH
49196: FOR_IN
49197: IFFALSE 49210
// ComStop ( i ) ;
49199: LD_VAR 0 7
49203: PPUSH
49204: CALL_OW 141
49208: GO 49196
49210: POP
49211: POP
// solds := [ ] ;
49212: LD_ADDR_VAR 0 2
49216: PUSH
49217: EMPTY
49218: ST_TO_ADDR
// exit ;
49219: GO 49536
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
49221: LD_VAR 0 5
49225: NOT
49226: PUSH
49227: LD_VAR 0 5
49231: PUSH
49232: LD_INT 3
49234: GREATER
49235: OR
49236: PUSH
49237: LD_EXP 72
49241: PUSH
49242: LD_VAR 0 1
49246: ARRAY
49247: OR
49248: IFFALSE 49289
// begin for i in solds do
49250: LD_ADDR_VAR 0 7
49254: PUSH
49255: LD_VAR 0 2
49259: PUSH
49260: FOR_IN
49261: IFFALSE 49285
// if HasTask ( i ) then
49263: LD_VAR 0 7
49267: PPUSH
49268: CALL_OW 314
49272: IFFALSE 49283
// ComStop ( i ) ;
49274: LD_VAR 0 7
49278: PPUSH
49279: CALL_OW 141
49283: GO 49260
49285: POP
49286: POP
// break ;
49287: GO 49524
// end ; for i in solds do
49289: LD_ADDR_VAR 0 7
49293: PUSH
49294: LD_VAR 0 2
49298: PUSH
49299: FOR_IN
49300: IFFALSE 49516
// begin if IsInUnit ( i ) then
49302: LD_VAR 0 7
49306: PPUSH
49307: CALL_OW 310
49311: IFFALSE 49322
// ComExitBuilding ( i ) ;
49313: LD_VAR 0 7
49317: PPUSH
49318: CALL_OW 122
// if GetLives ( i ) > 333 then
49322: LD_VAR 0 7
49326: PPUSH
49327: CALL_OW 256
49331: PUSH
49332: LD_INT 333
49334: GREATER
49335: IFFALSE 49363
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
49337: LD_VAR 0 7
49341: PPUSH
49342: LD_VAR 0 5
49346: PPUSH
49347: LD_VAR 0 7
49351: PPUSH
49352: CALL_OW 74
49356: PPUSH
49357: CALL_OW 115
49361: GO 49514
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
49363: LD_ADDR_VAR 0 8
49367: PUSH
49368: LD_EXP 50
49372: PUSH
49373: LD_VAR 0 1
49377: ARRAY
49378: PPUSH
49379: LD_INT 2
49381: PUSH
49382: LD_INT 30
49384: PUSH
49385: LD_INT 0
49387: PUSH
49388: EMPTY
49389: LIST
49390: LIST
49391: PUSH
49392: LD_INT 30
49394: PUSH
49395: LD_INT 1
49397: PUSH
49398: EMPTY
49399: LIST
49400: LIST
49401: PUSH
49402: LD_INT 30
49404: PUSH
49405: LD_INT 6
49407: PUSH
49408: EMPTY
49409: LIST
49410: LIST
49411: PUSH
49412: EMPTY
49413: LIST
49414: LIST
49415: LIST
49416: LIST
49417: PPUSH
49418: CALL_OW 72
49422: PPUSH
49423: LD_VAR 0 7
49427: PPUSH
49428: CALL_OW 74
49432: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
49433: LD_VAR 0 7
49437: PPUSH
49438: LD_VAR 0 8
49442: PPUSH
49443: CALL_OW 250
49447: PPUSH
49448: LD_INT 3
49450: PPUSH
49451: LD_INT 5
49453: PPUSH
49454: CALL_OW 272
49458: PPUSH
49459: LD_VAR 0 8
49463: PPUSH
49464: CALL_OW 251
49468: PPUSH
49469: LD_INT 3
49471: PPUSH
49472: LD_INT 5
49474: PPUSH
49475: CALL_OW 273
49479: PPUSH
49480: CALL_OW 111
// SetTag ( i , 0 ) ;
49484: LD_VAR 0 7
49488: PPUSH
49489: LD_INT 0
49491: PPUSH
49492: CALL_OW 109
// solds := solds diff i ;
49496: LD_ADDR_VAR 0 2
49500: PUSH
49501: LD_VAR 0 2
49505: PUSH
49506: LD_VAR 0 7
49510: DIFF
49511: ST_TO_ADDR
// continue ;
49512: GO 49299
// end ; end ;
49514: GO 49299
49516: POP
49517: POP
// until solds ;
49518: LD_VAR 0 2
49522: IFFALSE 49131
// MC_Reset ( base , 18 ) ;
49524: LD_VAR 0 1
49528: PPUSH
49529: LD_INT 18
49531: PPUSH
49532: CALL 21357 0 2
// end ;
49536: LD_VAR 0 4
49540: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
49541: LD_INT 0
49543: PPUSH
49544: PPUSH
49545: PPUSH
49546: PPUSH
49547: PPUSH
49548: PPUSH
49549: PPUSH
49550: PPUSH
49551: PPUSH
49552: PPUSH
49553: PPUSH
49554: PPUSH
49555: PPUSH
49556: PPUSH
49557: PPUSH
49558: PPUSH
49559: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
49560: LD_ADDR_VAR 0 13
49564: PUSH
49565: LD_EXP 50
49569: PUSH
49570: LD_VAR 0 1
49574: ARRAY
49575: PPUSH
49576: LD_INT 25
49578: PUSH
49579: LD_INT 3
49581: PUSH
49582: EMPTY
49583: LIST
49584: LIST
49585: PPUSH
49586: CALL_OW 72
49590: ST_TO_ADDR
// if mc_remote_driver [ base ] then
49591: LD_EXP 90
49595: PUSH
49596: LD_VAR 0 1
49600: ARRAY
49601: IFFALSE 49625
// mechs := mechs diff mc_remote_driver [ base ] ;
49603: LD_ADDR_VAR 0 13
49607: PUSH
49608: LD_VAR 0 13
49612: PUSH
49613: LD_EXP 90
49617: PUSH
49618: LD_VAR 0 1
49622: ARRAY
49623: DIFF
49624: ST_TO_ADDR
// for i in mechs do
49625: LD_ADDR_VAR 0 5
49629: PUSH
49630: LD_VAR 0 13
49634: PUSH
49635: FOR_IN
49636: IFFALSE 49671
// if GetTag ( i ) > 0 then
49638: LD_VAR 0 5
49642: PPUSH
49643: CALL_OW 110
49647: PUSH
49648: LD_INT 0
49650: GREATER
49651: IFFALSE 49669
// mechs := mechs diff i ;
49653: LD_ADDR_VAR 0 13
49657: PUSH
49658: LD_VAR 0 13
49662: PUSH
49663: LD_VAR 0 5
49667: DIFF
49668: ST_TO_ADDR
49669: GO 49635
49671: POP
49672: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
49673: LD_ADDR_VAR 0 9
49677: PUSH
49678: LD_EXP 50
49682: PUSH
49683: LD_VAR 0 1
49687: ARRAY
49688: PPUSH
49689: LD_INT 2
49691: PUSH
49692: LD_INT 25
49694: PUSH
49695: LD_INT 1
49697: PUSH
49698: EMPTY
49699: LIST
49700: LIST
49701: PUSH
49702: LD_INT 25
49704: PUSH
49705: LD_INT 5
49707: PUSH
49708: EMPTY
49709: LIST
49710: LIST
49711: PUSH
49712: LD_INT 25
49714: PUSH
49715: LD_INT 8
49717: PUSH
49718: EMPTY
49719: LIST
49720: LIST
49721: PUSH
49722: LD_INT 25
49724: PUSH
49725: LD_INT 9
49727: PUSH
49728: EMPTY
49729: LIST
49730: LIST
49731: PUSH
49732: EMPTY
49733: LIST
49734: LIST
49735: LIST
49736: LIST
49737: LIST
49738: PPUSH
49739: CALL_OW 72
49743: ST_TO_ADDR
// if not defenders and not solds then
49744: LD_VAR 0 2
49748: NOT
49749: PUSH
49750: LD_VAR 0 9
49754: NOT
49755: AND
49756: IFFALSE 49760
// exit ;
49758: GO 51386
// depot_under_attack := false ;
49760: LD_ADDR_VAR 0 17
49764: PUSH
49765: LD_INT 0
49767: ST_TO_ADDR
// sold_defenders := [ ] ;
49768: LD_ADDR_VAR 0 18
49772: PUSH
49773: EMPTY
49774: ST_TO_ADDR
// if mechs then
49775: LD_VAR 0 13
49779: IFFALSE 49908
// for i in defenders do
49781: LD_ADDR_VAR 0 5
49785: PUSH
49786: LD_VAR 0 2
49790: PUSH
49791: FOR_IN
49792: IFFALSE 49906
// begin SetTag ( i , 20 ) ;
49794: LD_VAR 0 5
49798: PPUSH
49799: LD_INT 20
49801: PPUSH
49802: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
49806: LD_VAR 0 5
49810: PPUSH
49811: CALL_OW 263
49815: PUSH
49816: LD_INT 1
49818: EQUAL
49819: PUSH
49820: LD_VAR 0 5
49824: PPUSH
49825: CALL_OW 311
49829: NOT
49830: AND
49831: PUSH
49832: LD_VAR 0 13
49836: AND
49837: IFFALSE 49904
// begin un := mechs [ 1 ] ;
49839: LD_ADDR_VAR 0 11
49843: PUSH
49844: LD_VAR 0 13
49848: PUSH
49849: LD_INT 1
49851: ARRAY
49852: ST_TO_ADDR
// ComExitBuilding ( un ) ;
49853: LD_VAR 0 11
49857: PPUSH
49858: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
49862: LD_VAR 0 11
49866: PPUSH
49867: LD_VAR 0 5
49871: PPUSH
49872: CALL_OW 180
// SetTag ( un , 19 ) ;
49876: LD_VAR 0 11
49880: PPUSH
49881: LD_INT 19
49883: PPUSH
49884: CALL_OW 109
// mechs := mechs diff un ;
49888: LD_ADDR_VAR 0 13
49892: PUSH
49893: LD_VAR 0 13
49897: PUSH
49898: LD_VAR 0 11
49902: DIFF
49903: ST_TO_ADDR
// end ; end ;
49904: GO 49791
49906: POP
49907: POP
// if solds then
49908: LD_VAR 0 9
49912: IFFALSE 49971
// for i in solds do
49914: LD_ADDR_VAR 0 5
49918: PUSH
49919: LD_VAR 0 9
49923: PUSH
49924: FOR_IN
49925: IFFALSE 49969
// if not GetTag ( i ) then
49927: LD_VAR 0 5
49931: PPUSH
49932: CALL_OW 110
49936: NOT
49937: IFFALSE 49967
// begin defenders := defenders union i ;
49939: LD_ADDR_VAR 0 2
49943: PUSH
49944: LD_VAR 0 2
49948: PUSH
49949: LD_VAR 0 5
49953: UNION
49954: ST_TO_ADDR
// SetTag ( i , 18 ) ;
49955: LD_VAR 0 5
49959: PPUSH
49960: LD_INT 18
49962: PPUSH
49963: CALL_OW 109
// end ;
49967: GO 49924
49969: POP
49970: POP
// repeat wait ( 0 0$1 ) ;
49971: LD_INT 35
49973: PPUSH
49974: CALL_OW 67
// enemy := mc_scan [ base ] ;
49978: LD_ADDR_VAR 0 3
49982: PUSH
49983: LD_EXP 73
49987: PUSH
49988: LD_VAR 0 1
49992: ARRAY
49993: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
49994: LD_EXP 50
49998: PUSH
49999: LD_VAR 0 1
50003: ARRAY
50004: NOT
50005: PUSH
50006: LD_EXP 50
50010: PUSH
50011: LD_VAR 0 1
50015: ARRAY
50016: PUSH
50017: EMPTY
50018: EQUAL
50019: OR
50020: IFFALSE 50057
// begin for i in defenders do
50022: LD_ADDR_VAR 0 5
50026: PUSH
50027: LD_VAR 0 2
50031: PUSH
50032: FOR_IN
50033: IFFALSE 50046
// ComStop ( i ) ;
50035: LD_VAR 0 5
50039: PPUSH
50040: CALL_OW 141
50044: GO 50032
50046: POP
50047: POP
// defenders := [ ] ;
50048: LD_ADDR_VAR 0 2
50052: PUSH
50053: EMPTY
50054: ST_TO_ADDR
// exit ;
50055: GO 51386
// end ; for i in defenders do
50057: LD_ADDR_VAR 0 5
50061: PUSH
50062: LD_VAR 0 2
50066: PUSH
50067: FOR_IN
50068: IFFALSE 50886
// begin e := NearestUnitToUnit ( enemy , i ) ;
50070: LD_ADDR_VAR 0 14
50074: PUSH
50075: LD_VAR 0 3
50079: PPUSH
50080: LD_VAR 0 5
50084: PPUSH
50085: CALL_OW 74
50089: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
50090: LD_ADDR_VAR 0 8
50094: PUSH
50095: LD_EXP 50
50099: PUSH
50100: LD_VAR 0 1
50104: ARRAY
50105: PPUSH
50106: LD_INT 2
50108: PUSH
50109: LD_INT 30
50111: PUSH
50112: LD_INT 0
50114: PUSH
50115: EMPTY
50116: LIST
50117: LIST
50118: PUSH
50119: LD_INT 30
50121: PUSH
50122: LD_INT 1
50124: PUSH
50125: EMPTY
50126: LIST
50127: LIST
50128: PUSH
50129: EMPTY
50130: LIST
50131: LIST
50132: LIST
50133: PPUSH
50134: CALL_OW 72
50138: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
50139: LD_ADDR_VAR 0 17
50143: PUSH
50144: LD_VAR 0 8
50148: NOT
50149: PUSH
50150: LD_VAR 0 8
50154: PPUSH
50155: LD_INT 3
50157: PUSH
50158: LD_INT 24
50160: PUSH
50161: LD_INT 600
50163: PUSH
50164: EMPTY
50165: LIST
50166: LIST
50167: PUSH
50168: EMPTY
50169: LIST
50170: LIST
50171: PPUSH
50172: CALL_OW 72
50176: OR
50177: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
50178: LD_VAR 0 5
50182: PPUSH
50183: CALL_OW 247
50187: PUSH
50188: LD_INT 2
50190: DOUBLE
50191: EQUAL
50192: IFTRUE 50196
50194: GO 50592
50196: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
50197: LD_VAR 0 5
50201: PPUSH
50202: CALL_OW 256
50206: PUSH
50207: LD_INT 650
50209: GREATER
50210: PUSH
50211: LD_VAR 0 5
50215: PPUSH
50216: LD_VAR 0 14
50220: PPUSH
50221: CALL_OW 296
50225: PUSH
50226: LD_INT 40
50228: LESS
50229: PUSH
50230: LD_VAR 0 14
50234: PPUSH
50235: LD_EXP 75
50239: PUSH
50240: LD_VAR 0 1
50244: ARRAY
50245: PPUSH
50246: CALL_OW 308
50250: OR
50251: AND
50252: IFFALSE 50374
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
50254: LD_VAR 0 5
50258: PPUSH
50259: CALL_OW 262
50263: PUSH
50264: LD_INT 1
50266: EQUAL
50267: PUSH
50268: LD_VAR 0 5
50272: PPUSH
50273: CALL_OW 261
50277: PUSH
50278: LD_INT 30
50280: LESS
50281: AND
50282: PUSH
50283: LD_VAR 0 8
50287: AND
50288: IFFALSE 50358
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
50290: LD_VAR 0 5
50294: PPUSH
50295: LD_VAR 0 8
50299: PPUSH
50300: LD_VAR 0 5
50304: PPUSH
50305: CALL_OW 74
50309: PPUSH
50310: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
50314: LD_VAR 0 5
50318: PPUSH
50319: LD_VAR 0 8
50323: PPUSH
50324: LD_VAR 0 5
50328: PPUSH
50329: CALL_OW 74
50333: PPUSH
50334: CALL_OW 296
50338: PUSH
50339: LD_INT 6
50341: LESS
50342: IFFALSE 50356
// SetFuel ( i , 100 ) ;
50344: LD_VAR 0 5
50348: PPUSH
50349: LD_INT 100
50351: PPUSH
50352: CALL_OW 240
// end else
50356: GO 50372
// ComAttackUnit ( i , e ) ;
50358: LD_VAR 0 5
50362: PPUSH
50363: LD_VAR 0 14
50367: PPUSH
50368: CALL_OW 115
// end else
50372: GO 50475
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
50374: LD_VAR 0 14
50378: PPUSH
50379: LD_EXP 75
50383: PUSH
50384: LD_VAR 0 1
50388: ARRAY
50389: PPUSH
50390: CALL_OW 308
50394: NOT
50395: PUSH
50396: LD_VAR 0 5
50400: PPUSH
50401: LD_VAR 0 14
50405: PPUSH
50406: CALL_OW 296
50410: PUSH
50411: LD_INT 40
50413: GREATEREQUAL
50414: AND
50415: PUSH
50416: LD_VAR 0 5
50420: PPUSH
50421: CALL_OW 256
50425: PUSH
50426: LD_INT 650
50428: LESSEQUAL
50429: OR
50430: PUSH
50431: LD_VAR 0 5
50435: PPUSH
50436: LD_EXP 74
50440: PUSH
50441: LD_VAR 0 1
50445: ARRAY
50446: PPUSH
50447: CALL_OW 308
50451: NOT
50452: AND
50453: IFFALSE 50475
// ComMoveToArea ( i , mc_parking [ base ] ) ;
50455: LD_VAR 0 5
50459: PPUSH
50460: LD_EXP 74
50464: PUSH
50465: LD_VAR 0 1
50469: ARRAY
50470: PPUSH
50471: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
50475: LD_VAR 0 5
50479: PPUSH
50480: CALL_OW 256
50484: PUSH
50485: LD_INT 998
50487: LESS
50488: PUSH
50489: LD_VAR 0 5
50493: PPUSH
50494: CALL_OW 263
50498: PUSH
50499: LD_INT 1
50501: EQUAL
50502: AND
50503: PUSH
50504: LD_VAR 0 5
50508: PPUSH
50509: CALL_OW 311
50513: AND
50514: PUSH
50515: LD_VAR 0 5
50519: PPUSH
50520: LD_EXP 74
50524: PUSH
50525: LD_VAR 0 1
50529: ARRAY
50530: PPUSH
50531: CALL_OW 308
50535: AND
50536: IFFALSE 50590
// begin mech := IsDrivenBy ( i ) ;
50538: LD_ADDR_VAR 0 10
50542: PUSH
50543: LD_VAR 0 5
50547: PPUSH
50548: CALL_OW 311
50552: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
50553: LD_VAR 0 10
50557: PPUSH
50558: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
50562: LD_VAR 0 10
50566: PPUSH
50567: LD_VAR 0 5
50571: PPUSH
50572: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
50576: LD_VAR 0 10
50580: PPUSH
50581: LD_VAR 0 5
50585: PPUSH
50586: CALL_OW 180
// end ; end ; unit_human :
50590: GO 50857
50592: LD_INT 1
50594: DOUBLE
50595: EQUAL
50596: IFTRUE 50600
50598: GO 50856
50600: POP
// begin b := IsInUnit ( i ) ;
50601: LD_ADDR_VAR 0 19
50605: PUSH
50606: LD_VAR 0 5
50610: PPUSH
50611: CALL_OW 310
50615: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
50616: LD_ADDR_VAR 0 20
50620: PUSH
50621: LD_VAR 0 19
50625: NOT
50626: PUSH
50627: LD_VAR 0 19
50631: PPUSH
50632: CALL_OW 266
50636: PUSH
50637: LD_INT 32
50639: PUSH
50640: LD_INT 31
50642: PUSH
50643: EMPTY
50644: LIST
50645: LIST
50646: IN
50647: OR
50648: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
50649: LD_VAR 0 17
50653: PUSH
50654: LD_VAR 0 2
50658: PPUSH
50659: LD_INT 21
50661: PUSH
50662: LD_INT 2
50664: PUSH
50665: EMPTY
50666: LIST
50667: LIST
50668: PPUSH
50669: CALL_OW 72
50673: PUSH
50674: LD_INT 1
50676: LESSEQUAL
50677: OR
50678: PUSH
50679: LD_VAR 0 20
50683: AND
50684: PUSH
50685: LD_VAR 0 5
50689: PUSH
50690: LD_VAR 0 18
50694: IN
50695: NOT
50696: AND
50697: IFFALSE 50790
// begin if b then
50699: LD_VAR 0 19
50703: IFFALSE 50752
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
50705: LD_VAR 0 19
50709: PPUSH
50710: LD_VAR 0 3
50714: PPUSH
50715: LD_VAR 0 19
50719: PPUSH
50720: CALL_OW 74
50724: PPUSH
50725: CALL_OW 296
50729: PUSH
50730: LD_INT 10
50732: LESS
50733: PUSH
50734: LD_VAR 0 19
50738: PPUSH
50739: CALL_OW 461
50743: PUSH
50744: LD_INT 7
50746: NONEQUAL
50747: AND
50748: IFFALSE 50752
// continue ;
50750: GO 50067
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
50752: LD_ADDR_VAR 0 18
50756: PUSH
50757: LD_VAR 0 18
50761: PPUSH
50762: LD_VAR 0 18
50766: PUSH
50767: LD_INT 1
50769: PLUS
50770: PPUSH
50771: LD_VAR 0 5
50775: PPUSH
50776: CALL_OW 1
50780: ST_TO_ADDR
// ComExitBuilding ( i ) ;
50781: LD_VAR 0 5
50785: PPUSH
50786: CALL_OW 122
// end ; if sold_defenders then
50790: LD_VAR 0 18
50794: IFFALSE 50854
// if i in sold_defenders then
50796: LD_VAR 0 5
50800: PUSH
50801: LD_VAR 0 18
50805: IN
50806: IFFALSE 50854
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
50808: LD_VAR 0 5
50812: PPUSH
50813: CALL_OW 314
50817: NOT
50818: PUSH
50819: LD_VAR 0 5
50823: PPUSH
50824: LD_VAR 0 14
50828: PPUSH
50829: CALL_OW 296
50833: PUSH
50834: LD_INT 30
50836: LESS
50837: AND
50838: IFFALSE 50854
// ComAttackUnit ( i , e ) ;
50840: LD_VAR 0 5
50844: PPUSH
50845: LD_VAR 0 14
50849: PPUSH
50850: CALL_OW 115
// end ; end ; end ;
50854: GO 50857
50856: POP
// if IsDead ( i ) then
50857: LD_VAR 0 5
50861: PPUSH
50862: CALL_OW 301
50866: IFFALSE 50884
// defenders := defenders diff i ;
50868: LD_ADDR_VAR 0 2
50872: PUSH
50873: LD_VAR 0 2
50877: PUSH
50878: LD_VAR 0 5
50882: DIFF
50883: ST_TO_ADDR
// end ;
50884: GO 50067
50886: POP
50887: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
50888: LD_VAR 0 3
50892: NOT
50893: PUSH
50894: LD_VAR 0 2
50898: NOT
50899: OR
50900: PUSH
50901: LD_EXP 50
50905: PUSH
50906: LD_VAR 0 1
50910: ARRAY
50911: NOT
50912: OR
50913: IFFALSE 49971
// MC_Reset ( base , 18 ) ;
50915: LD_VAR 0 1
50919: PPUSH
50920: LD_INT 18
50922: PPUSH
50923: CALL 21357 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
50927: LD_ADDR_VAR 0 2
50931: PUSH
50932: LD_VAR 0 2
50936: PUSH
50937: LD_VAR 0 2
50941: PPUSH
50942: LD_INT 2
50944: PUSH
50945: LD_INT 25
50947: PUSH
50948: LD_INT 1
50950: PUSH
50951: EMPTY
50952: LIST
50953: LIST
50954: PUSH
50955: LD_INT 25
50957: PUSH
50958: LD_INT 5
50960: PUSH
50961: EMPTY
50962: LIST
50963: LIST
50964: PUSH
50965: LD_INT 25
50967: PUSH
50968: LD_INT 8
50970: PUSH
50971: EMPTY
50972: LIST
50973: LIST
50974: PUSH
50975: LD_INT 25
50977: PUSH
50978: LD_INT 9
50980: PUSH
50981: EMPTY
50982: LIST
50983: LIST
50984: PUSH
50985: EMPTY
50986: LIST
50987: LIST
50988: LIST
50989: LIST
50990: LIST
50991: PPUSH
50992: CALL_OW 72
50996: DIFF
50997: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
50998: LD_VAR 0 3
51002: NOT
51003: PUSH
51004: LD_VAR 0 2
51008: PPUSH
51009: LD_INT 21
51011: PUSH
51012: LD_INT 2
51014: PUSH
51015: EMPTY
51016: LIST
51017: LIST
51018: PPUSH
51019: CALL_OW 72
51023: AND
51024: IFFALSE 51362
// begin tmp := FilterByTag ( defenders , 19 ) ;
51026: LD_ADDR_VAR 0 12
51030: PUSH
51031: LD_VAR 0 2
51035: PPUSH
51036: LD_INT 19
51038: PPUSH
51039: CALL 87825 0 2
51043: ST_TO_ADDR
// if tmp then
51044: LD_VAR 0 12
51048: IFFALSE 51118
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
51050: LD_ADDR_VAR 0 12
51054: PUSH
51055: LD_VAR 0 12
51059: PPUSH
51060: LD_INT 25
51062: PUSH
51063: LD_INT 3
51065: PUSH
51066: EMPTY
51067: LIST
51068: LIST
51069: PPUSH
51070: CALL_OW 72
51074: ST_TO_ADDR
// if tmp then
51075: LD_VAR 0 12
51079: IFFALSE 51118
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
51081: LD_ADDR_EXP 62
51085: PUSH
51086: LD_EXP 62
51090: PPUSH
51091: LD_VAR 0 1
51095: PPUSH
51096: LD_EXP 62
51100: PUSH
51101: LD_VAR 0 1
51105: ARRAY
51106: PUSH
51107: LD_VAR 0 12
51111: UNION
51112: PPUSH
51113: CALL_OW 1
51117: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
51118: LD_VAR 0 1
51122: PPUSH
51123: LD_INT 19
51125: PPUSH
51126: CALL 21357 0 2
// repeat wait ( 0 0$1 ) ;
51130: LD_INT 35
51132: PPUSH
51133: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
51137: LD_EXP 50
51141: PUSH
51142: LD_VAR 0 1
51146: ARRAY
51147: NOT
51148: PUSH
51149: LD_EXP 50
51153: PUSH
51154: LD_VAR 0 1
51158: ARRAY
51159: PUSH
51160: EMPTY
51161: EQUAL
51162: OR
51163: IFFALSE 51200
// begin for i in defenders do
51165: LD_ADDR_VAR 0 5
51169: PUSH
51170: LD_VAR 0 2
51174: PUSH
51175: FOR_IN
51176: IFFALSE 51189
// ComStop ( i ) ;
51178: LD_VAR 0 5
51182: PPUSH
51183: CALL_OW 141
51187: GO 51175
51189: POP
51190: POP
// defenders := [ ] ;
51191: LD_ADDR_VAR 0 2
51195: PUSH
51196: EMPTY
51197: ST_TO_ADDR
// exit ;
51198: GO 51386
// end ; for i in defenders do
51200: LD_ADDR_VAR 0 5
51204: PUSH
51205: LD_VAR 0 2
51209: PUSH
51210: FOR_IN
51211: IFFALSE 51300
// begin if not IsInArea ( i , mc_parking [ base ] ) then
51213: LD_VAR 0 5
51217: PPUSH
51218: LD_EXP 74
51222: PUSH
51223: LD_VAR 0 1
51227: ARRAY
51228: PPUSH
51229: CALL_OW 308
51233: NOT
51234: IFFALSE 51258
// ComMoveToArea ( i , mc_parking [ base ] ) else
51236: LD_VAR 0 5
51240: PPUSH
51241: LD_EXP 74
51245: PUSH
51246: LD_VAR 0 1
51250: ARRAY
51251: PPUSH
51252: CALL_OW 113
51256: GO 51298
// if GetControl ( i ) = control_manual then
51258: LD_VAR 0 5
51262: PPUSH
51263: CALL_OW 263
51267: PUSH
51268: LD_INT 1
51270: EQUAL
51271: IFFALSE 51298
// if IsDrivenBy ( i ) then
51273: LD_VAR 0 5
51277: PPUSH
51278: CALL_OW 311
51282: IFFALSE 51298
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
51284: LD_VAR 0 5
51288: PPUSH
51289: CALL_OW 311
51293: PPUSH
51294: CALL_OW 121
// end ;
51298: GO 51210
51300: POP
51301: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
51302: LD_VAR 0 2
51306: PPUSH
51307: LD_INT 95
51309: PUSH
51310: LD_EXP 74
51314: PUSH
51315: LD_VAR 0 1
51319: ARRAY
51320: PUSH
51321: EMPTY
51322: LIST
51323: LIST
51324: PPUSH
51325: CALL_OW 72
51329: PUSH
51330: LD_VAR 0 2
51334: EQUAL
51335: PUSH
51336: LD_EXP 73
51340: PUSH
51341: LD_VAR 0 1
51345: ARRAY
51346: OR
51347: PUSH
51348: LD_EXP 50
51352: PUSH
51353: LD_VAR 0 1
51357: ARRAY
51358: NOT
51359: OR
51360: IFFALSE 51130
// end ; MC_Reset ( base , 19 ) ;
51362: LD_VAR 0 1
51366: PPUSH
51367: LD_INT 19
51369: PPUSH
51370: CALL 21357 0 2
// MC_Reset ( base , 20 ) ;
51374: LD_VAR 0 1
51378: PPUSH
51379: LD_INT 20
51381: PPUSH
51382: CALL 21357 0 2
// end ;
51386: LD_VAR 0 4
51390: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
51391: LD_INT 0
51393: PPUSH
51394: PPUSH
51395: PPUSH
51396: PPUSH
// result := false ;
51397: LD_ADDR_VAR 0 2
51401: PUSH
51402: LD_INT 0
51404: ST_TO_ADDR
// side := GetSide ( unit ) ;
51405: LD_ADDR_VAR 0 3
51409: PUSH
51410: LD_VAR 0 1
51414: PPUSH
51415: CALL_OW 255
51419: ST_TO_ADDR
// nat := GetNation ( unit ) ;
51420: LD_ADDR_VAR 0 4
51424: PUSH
51425: LD_VAR 0 1
51429: PPUSH
51430: CALL_OW 248
51434: ST_TO_ADDR
// case nat of 1 :
51435: LD_VAR 0 4
51439: PUSH
51440: LD_INT 1
51442: DOUBLE
51443: EQUAL
51444: IFTRUE 51448
51446: GO 51459
51448: POP
// tech := tech_lassight ; 2 :
51449: LD_ADDR_VAR 0 5
51453: PUSH
51454: LD_INT 12
51456: ST_TO_ADDR
51457: GO 51498
51459: LD_INT 2
51461: DOUBLE
51462: EQUAL
51463: IFTRUE 51467
51465: GO 51478
51467: POP
// tech := tech_mortar ; 3 :
51468: LD_ADDR_VAR 0 5
51472: PUSH
51473: LD_INT 41
51475: ST_TO_ADDR
51476: GO 51498
51478: LD_INT 3
51480: DOUBLE
51481: EQUAL
51482: IFTRUE 51486
51484: GO 51497
51486: POP
// tech := tech_bazooka ; end ;
51487: LD_ADDR_VAR 0 5
51491: PUSH
51492: LD_INT 44
51494: ST_TO_ADDR
51495: GO 51498
51497: POP
// if Researched ( side , tech ) then
51498: LD_VAR 0 3
51502: PPUSH
51503: LD_VAR 0 5
51507: PPUSH
51508: CALL_OW 325
51512: IFFALSE 51539
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
51514: LD_ADDR_VAR 0 2
51518: PUSH
51519: LD_INT 5
51521: PUSH
51522: LD_INT 8
51524: PUSH
51525: LD_INT 9
51527: PUSH
51528: EMPTY
51529: LIST
51530: LIST
51531: LIST
51532: PUSH
51533: LD_VAR 0 4
51537: ARRAY
51538: ST_TO_ADDR
// end ;
51539: LD_VAR 0 2
51543: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
51544: LD_INT 0
51546: PPUSH
51547: PPUSH
51548: PPUSH
// if not mines then
51549: LD_VAR 0 2
51553: NOT
51554: IFFALSE 51558
// exit ;
51556: GO 51702
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
51558: LD_ADDR_VAR 0 5
51562: PUSH
51563: LD_INT 81
51565: PUSH
51566: LD_VAR 0 1
51570: PUSH
51571: EMPTY
51572: LIST
51573: LIST
51574: PUSH
51575: LD_INT 3
51577: PUSH
51578: LD_INT 21
51580: PUSH
51581: LD_INT 3
51583: PUSH
51584: EMPTY
51585: LIST
51586: LIST
51587: PUSH
51588: EMPTY
51589: LIST
51590: LIST
51591: PUSH
51592: EMPTY
51593: LIST
51594: LIST
51595: PPUSH
51596: CALL_OW 69
51600: ST_TO_ADDR
// for i in mines do
51601: LD_ADDR_VAR 0 4
51605: PUSH
51606: LD_VAR 0 2
51610: PUSH
51611: FOR_IN
51612: IFFALSE 51700
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
51614: LD_VAR 0 4
51618: PUSH
51619: LD_INT 1
51621: ARRAY
51622: PPUSH
51623: LD_VAR 0 4
51627: PUSH
51628: LD_INT 2
51630: ARRAY
51631: PPUSH
51632: CALL_OW 458
51636: NOT
51637: IFFALSE 51641
// continue ;
51639: GO 51611
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
51641: LD_VAR 0 4
51645: PUSH
51646: LD_INT 1
51648: ARRAY
51649: PPUSH
51650: LD_VAR 0 4
51654: PUSH
51655: LD_INT 2
51657: ARRAY
51658: PPUSH
51659: CALL_OW 428
51663: PUSH
51664: LD_VAR 0 5
51668: IN
51669: IFFALSE 51698
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
51671: LD_VAR 0 4
51675: PUSH
51676: LD_INT 1
51678: ARRAY
51679: PPUSH
51680: LD_VAR 0 4
51684: PUSH
51685: LD_INT 2
51687: ARRAY
51688: PPUSH
51689: LD_VAR 0 1
51693: PPUSH
51694: CALL_OW 456
// end ;
51698: GO 51611
51700: POP
51701: POP
// end ;
51702: LD_VAR 0 3
51706: RET
// export function Count ( array ) ; var i ; begin
51707: LD_INT 0
51709: PPUSH
51710: PPUSH
// result := 0 ;
51711: LD_ADDR_VAR 0 2
51715: PUSH
51716: LD_INT 0
51718: ST_TO_ADDR
// for i in array do
51719: LD_ADDR_VAR 0 3
51723: PUSH
51724: LD_VAR 0 1
51728: PUSH
51729: FOR_IN
51730: IFFALSE 51754
// if i then
51732: LD_VAR 0 3
51736: IFFALSE 51752
// result := result + 1 ;
51738: LD_ADDR_VAR 0 2
51742: PUSH
51743: LD_VAR 0 2
51747: PUSH
51748: LD_INT 1
51750: PLUS
51751: ST_TO_ADDR
51752: GO 51729
51754: POP
51755: POP
// end ;
51756: LD_VAR 0 2
51760: RET
// export function IsEmpty ( building ) ; begin
51761: LD_INT 0
51763: PPUSH
// if not building then
51764: LD_VAR 0 1
51768: NOT
51769: IFFALSE 51773
// exit ;
51771: GO 51816
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
51773: LD_ADDR_VAR 0 2
51777: PUSH
51778: LD_VAR 0 1
51782: PUSH
51783: LD_INT 22
51785: PUSH
51786: LD_VAR 0 1
51790: PPUSH
51791: CALL_OW 255
51795: PUSH
51796: EMPTY
51797: LIST
51798: LIST
51799: PUSH
51800: LD_INT 58
51802: PUSH
51803: EMPTY
51804: LIST
51805: PUSH
51806: EMPTY
51807: LIST
51808: LIST
51809: PPUSH
51810: CALL_OW 69
51814: IN
51815: ST_TO_ADDR
// end ;
51816: LD_VAR 0 2
51820: RET
// export function IsNotFull ( building ) ; begin
51821: LD_INT 0
51823: PPUSH
// if not building then
51824: LD_VAR 0 1
51828: NOT
51829: IFFALSE 51833
// exit ;
51831: GO 51852
// result := UnitsInside ( building ) < 6 ;
51833: LD_ADDR_VAR 0 2
51837: PUSH
51838: LD_VAR 0 1
51842: PPUSH
51843: CALL_OW 313
51847: PUSH
51848: LD_INT 6
51850: LESS
51851: ST_TO_ADDR
// end ;
51852: LD_VAR 0 2
51856: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
51857: LD_INT 0
51859: PPUSH
51860: PPUSH
51861: PPUSH
51862: PPUSH
// tmp := [ ] ;
51863: LD_ADDR_VAR 0 3
51867: PUSH
51868: EMPTY
51869: ST_TO_ADDR
// list := [ ] ;
51870: LD_ADDR_VAR 0 5
51874: PUSH
51875: EMPTY
51876: ST_TO_ADDR
// for i = 16 to 25 do
51877: LD_ADDR_VAR 0 4
51881: PUSH
51882: DOUBLE
51883: LD_INT 16
51885: DEC
51886: ST_TO_ADDR
51887: LD_INT 25
51889: PUSH
51890: FOR_TO
51891: IFFALSE 51964
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
51893: LD_ADDR_VAR 0 3
51897: PUSH
51898: LD_VAR 0 3
51902: PUSH
51903: LD_INT 22
51905: PUSH
51906: LD_VAR 0 1
51910: PPUSH
51911: CALL_OW 255
51915: PUSH
51916: EMPTY
51917: LIST
51918: LIST
51919: PUSH
51920: LD_INT 91
51922: PUSH
51923: LD_VAR 0 1
51927: PUSH
51928: LD_INT 6
51930: PUSH
51931: EMPTY
51932: LIST
51933: LIST
51934: LIST
51935: PUSH
51936: LD_INT 30
51938: PUSH
51939: LD_VAR 0 4
51943: PUSH
51944: EMPTY
51945: LIST
51946: LIST
51947: PUSH
51948: EMPTY
51949: LIST
51950: LIST
51951: LIST
51952: PUSH
51953: EMPTY
51954: LIST
51955: PPUSH
51956: CALL_OW 69
51960: ADD
51961: ST_TO_ADDR
51962: GO 51890
51964: POP
51965: POP
// for i = 1 to tmp do
51966: LD_ADDR_VAR 0 4
51970: PUSH
51971: DOUBLE
51972: LD_INT 1
51974: DEC
51975: ST_TO_ADDR
51976: LD_VAR 0 3
51980: PUSH
51981: FOR_TO
51982: IFFALSE 52070
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
51984: LD_ADDR_VAR 0 5
51988: PUSH
51989: LD_VAR 0 5
51993: PUSH
51994: LD_VAR 0 3
51998: PUSH
51999: LD_VAR 0 4
52003: ARRAY
52004: PPUSH
52005: CALL_OW 266
52009: PUSH
52010: LD_VAR 0 3
52014: PUSH
52015: LD_VAR 0 4
52019: ARRAY
52020: PPUSH
52021: CALL_OW 250
52025: PUSH
52026: LD_VAR 0 3
52030: PUSH
52031: LD_VAR 0 4
52035: ARRAY
52036: PPUSH
52037: CALL_OW 251
52041: PUSH
52042: LD_VAR 0 3
52046: PUSH
52047: LD_VAR 0 4
52051: ARRAY
52052: PPUSH
52053: CALL_OW 254
52057: PUSH
52058: EMPTY
52059: LIST
52060: LIST
52061: LIST
52062: LIST
52063: PUSH
52064: EMPTY
52065: LIST
52066: ADD
52067: ST_TO_ADDR
52068: GO 51981
52070: POP
52071: POP
// result := list ;
52072: LD_ADDR_VAR 0 2
52076: PUSH
52077: LD_VAR 0 5
52081: ST_TO_ADDR
// end ;
52082: LD_VAR 0 2
52086: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
52087: LD_INT 0
52089: PPUSH
52090: PPUSH
52091: PPUSH
52092: PPUSH
52093: PPUSH
52094: PPUSH
52095: PPUSH
// if not factory then
52096: LD_VAR 0 1
52100: NOT
52101: IFFALSE 52105
// exit ;
52103: GO 52698
// if control = control_apeman then
52105: LD_VAR 0 4
52109: PUSH
52110: LD_INT 5
52112: EQUAL
52113: IFFALSE 52222
// begin tmp := UnitsInside ( factory ) ;
52115: LD_ADDR_VAR 0 8
52119: PUSH
52120: LD_VAR 0 1
52124: PPUSH
52125: CALL_OW 313
52129: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
52130: LD_VAR 0 8
52134: PPUSH
52135: LD_INT 25
52137: PUSH
52138: LD_INT 12
52140: PUSH
52141: EMPTY
52142: LIST
52143: LIST
52144: PPUSH
52145: CALL_OW 72
52149: NOT
52150: IFFALSE 52160
// control := control_manual ;
52152: LD_ADDR_VAR 0 4
52156: PUSH
52157: LD_INT 1
52159: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
52160: LD_ADDR_VAR 0 8
52164: PUSH
52165: LD_VAR 0 1
52169: PPUSH
52170: CALL 51857 0 1
52174: ST_TO_ADDR
// if tmp then
52175: LD_VAR 0 8
52179: IFFALSE 52222
// begin for i in tmp do
52181: LD_ADDR_VAR 0 7
52185: PUSH
52186: LD_VAR 0 8
52190: PUSH
52191: FOR_IN
52192: IFFALSE 52220
// if i [ 1 ] = b_ext_radio then
52194: LD_VAR 0 7
52198: PUSH
52199: LD_INT 1
52201: ARRAY
52202: PUSH
52203: LD_INT 22
52205: EQUAL
52206: IFFALSE 52218
// begin control := control_remote ;
52208: LD_ADDR_VAR 0 4
52212: PUSH
52213: LD_INT 2
52215: ST_TO_ADDR
// break ;
52216: GO 52220
// end ;
52218: GO 52191
52220: POP
52221: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
52222: LD_VAR 0 1
52226: PPUSH
52227: LD_VAR 0 2
52231: PPUSH
52232: LD_VAR 0 3
52236: PPUSH
52237: LD_VAR 0 4
52241: PPUSH
52242: LD_VAR 0 5
52246: PPUSH
52247: CALL_OW 448
52251: IFFALSE 52286
// begin result := [ chassis , engine , control , weapon ] ;
52253: LD_ADDR_VAR 0 6
52257: PUSH
52258: LD_VAR 0 2
52262: PUSH
52263: LD_VAR 0 3
52267: PUSH
52268: LD_VAR 0 4
52272: PUSH
52273: LD_VAR 0 5
52277: PUSH
52278: EMPTY
52279: LIST
52280: LIST
52281: LIST
52282: LIST
52283: ST_TO_ADDR
// exit ;
52284: GO 52698
// end ; _chassis := AvailableChassisList ( factory ) ;
52286: LD_ADDR_VAR 0 9
52290: PUSH
52291: LD_VAR 0 1
52295: PPUSH
52296: CALL_OW 475
52300: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
52301: LD_ADDR_VAR 0 11
52305: PUSH
52306: LD_VAR 0 1
52310: PPUSH
52311: CALL_OW 476
52315: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
52316: LD_ADDR_VAR 0 12
52320: PUSH
52321: LD_VAR 0 1
52325: PPUSH
52326: CALL_OW 477
52330: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
52331: LD_ADDR_VAR 0 10
52335: PUSH
52336: LD_VAR 0 1
52340: PPUSH
52341: CALL_OW 478
52345: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
52346: LD_VAR 0 9
52350: NOT
52351: PUSH
52352: LD_VAR 0 11
52356: NOT
52357: OR
52358: PUSH
52359: LD_VAR 0 12
52363: NOT
52364: OR
52365: PUSH
52366: LD_VAR 0 10
52370: NOT
52371: OR
52372: IFFALSE 52407
// begin result := [ chassis , engine , control , weapon ] ;
52374: LD_ADDR_VAR 0 6
52378: PUSH
52379: LD_VAR 0 2
52383: PUSH
52384: LD_VAR 0 3
52388: PUSH
52389: LD_VAR 0 4
52393: PUSH
52394: LD_VAR 0 5
52398: PUSH
52399: EMPTY
52400: LIST
52401: LIST
52402: LIST
52403: LIST
52404: ST_TO_ADDR
// exit ;
52405: GO 52698
// end ; if not chassis in _chassis then
52407: LD_VAR 0 2
52411: PUSH
52412: LD_VAR 0 9
52416: IN
52417: NOT
52418: IFFALSE 52444
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
52420: LD_ADDR_VAR 0 2
52424: PUSH
52425: LD_VAR 0 9
52429: PUSH
52430: LD_INT 1
52432: PPUSH
52433: LD_VAR 0 9
52437: PPUSH
52438: CALL_OW 12
52442: ARRAY
52443: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
52444: LD_VAR 0 2
52448: PPUSH
52449: LD_VAR 0 3
52453: PPUSH
52454: CALL 52703 0 2
52458: NOT
52459: IFFALSE 52518
// repeat engine := _engine [ 1 ] ;
52461: LD_ADDR_VAR 0 3
52465: PUSH
52466: LD_VAR 0 11
52470: PUSH
52471: LD_INT 1
52473: ARRAY
52474: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
52475: LD_ADDR_VAR 0 11
52479: PUSH
52480: LD_VAR 0 11
52484: PPUSH
52485: LD_INT 1
52487: PPUSH
52488: CALL_OW 3
52492: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
52493: LD_VAR 0 2
52497: PPUSH
52498: LD_VAR 0 3
52502: PPUSH
52503: CALL 52703 0 2
52507: PUSH
52508: LD_VAR 0 11
52512: PUSH
52513: EMPTY
52514: EQUAL
52515: OR
52516: IFFALSE 52461
// if not control in _control then
52518: LD_VAR 0 4
52522: PUSH
52523: LD_VAR 0 12
52527: IN
52528: NOT
52529: IFFALSE 52555
// control := _control [ rand ( 1 , _control ) ] ;
52531: LD_ADDR_VAR 0 4
52535: PUSH
52536: LD_VAR 0 12
52540: PUSH
52541: LD_INT 1
52543: PPUSH
52544: LD_VAR 0 12
52548: PPUSH
52549: CALL_OW 12
52553: ARRAY
52554: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
52555: LD_VAR 0 2
52559: PPUSH
52560: LD_VAR 0 5
52564: PPUSH
52565: CALL 52923 0 2
52569: NOT
52570: IFFALSE 52629
// repeat weapon := _weapon [ 1 ] ;
52572: LD_ADDR_VAR 0 5
52576: PUSH
52577: LD_VAR 0 10
52581: PUSH
52582: LD_INT 1
52584: ARRAY
52585: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
52586: LD_ADDR_VAR 0 10
52590: PUSH
52591: LD_VAR 0 10
52595: PPUSH
52596: LD_INT 1
52598: PPUSH
52599: CALL_OW 3
52603: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
52604: LD_VAR 0 2
52608: PPUSH
52609: LD_VAR 0 5
52613: PPUSH
52614: CALL 52923 0 2
52618: PUSH
52619: LD_VAR 0 10
52623: PUSH
52624: EMPTY
52625: EQUAL
52626: OR
52627: IFFALSE 52572
// result := [ ] ;
52629: LD_ADDR_VAR 0 6
52633: PUSH
52634: EMPTY
52635: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
52636: LD_VAR 0 1
52640: PPUSH
52641: LD_VAR 0 2
52645: PPUSH
52646: LD_VAR 0 3
52650: PPUSH
52651: LD_VAR 0 4
52655: PPUSH
52656: LD_VAR 0 5
52660: PPUSH
52661: CALL_OW 448
52665: IFFALSE 52698
// result := [ chassis , engine , control , weapon ] ;
52667: LD_ADDR_VAR 0 6
52671: PUSH
52672: LD_VAR 0 2
52676: PUSH
52677: LD_VAR 0 3
52681: PUSH
52682: LD_VAR 0 4
52686: PUSH
52687: LD_VAR 0 5
52691: PUSH
52692: EMPTY
52693: LIST
52694: LIST
52695: LIST
52696: LIST
52697: ST_TO_ADDR
// end ;
52698: LD_VAR 0 6
52702: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
52703: LD_INT 0
52705: PPUSH
// if not chassis or not engine then
52706: LD_VAR 0 1
52710: NOT
52711: PUSH
52712: LD_VAR 0 2
52716: NOT
52717: OR
52718: IFFALSE 52722
// exit ;
52720: GO 52918
// case engine of engine_solar :
52722: LD_VAR 0 2
52726: PUSH
52727: LD_INT 2
52729: DOUBLE
52730: EQUAL
52731: IFTRUE 52735
52733: GO 52773
52735: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
52736: LD_ADDR_VAR 0 3
52740: PUSH
52741: LD_INT 11
52743: PUSH
52744: LD_INT 12
52746: PUSH
52747: LD_INT 13
52749: PUSH
52750: LD_INT 14
52752: PUSH
52753: LD_INT 1
52755: PUSH
52756: LD_INT 2
52758: PUSH
52759: LD_INT 3
52761: PUSH
52762: EMPTY
52763: LIST
52764: LIST
52765: LIST
52766: LIST
52767: LIST
52768: LIST
52769: LIST
52770: ST_TO_ADDR
52771: GO 52902
52773: LD_INT 1
52775: DOUBLE
52776: EQUAL
52777: IFTRUE 52781
52779: GO 52843
52781: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
52782: LD_ADDR_VAR 0 3
52786: PUSH
52787: LD_INT 11
52789: PUSH
52790: LD_INT 12
52792: PUSH
52793: LD_INT 13
52795: PUSH
52796: LD_INT 14
52798: PUSH
52799: LD_INT 1
52801: PUSH
52802: LD_INT 2
52804: PUSH
52805: LD_INT 3
52807: PUSH
52808: LD_INT 4
52810: PUSH
52811: LD_INT 5
52813: PUSH
52814: LD_INT 21
52816: PUSH
52817: LD_INT 23
52819: PUSH
52820: LD_INT 22
52822: PUSH
52823: LD_INT 24
52825: PUSH
52826: EMPTY
52827: LIST
52828: LIST
52829: LIST
52830: LIST
52831: LIST
52832: LIST
52833: LIST
52834: LIST
52835: LIST
52836: LIST
52837: LIST
52838: LIST
52839: LIST
52840: ST_TO_ADDR
52841: GO 52902
52843: LD_INT 3
52845: DOUBLE
52846: EQUAL
52847: IFTRUE 52851
52849: GO 52901
52851: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
52852: LD_ADDR_VAR 0 3
52856: PUSH
52857: LD_INT 13
52859: PUSH
52860: LD_INT 14
52862: PUSH
52863: LD_INT 2
52865: PUSH
52866: LD_INT 3
52868: PUSH
52869: LD_INT 4
52871: PUSH
52872: LD_INT 5
52874: PUSH
52875: LD_INT 21
52877: PUSH
52878: LD_INT 22
52880: PUSH
52881: LD_INT 23
52883: PUSH
52884: LD_INT 24
52886: PUSH
52887: EMPTY
52888: LIST
52889: LIST
52890: LIST
52891: LIST
52892: LIST
52893: LIST
52894: LIST
52895: LIST
52896: LIST
52897: LIST
52898: ST_TO_ADDR
52899: GO 52902
52901: POP
// result := ( chassis in result ) ;
52902: LD_ADDR_VAR 0 3
52906: PUSH
52907: LD_VAR 0 1
52911: PUSH
52912: LD_VAR 0 3
52916: IN
52917: ST_TO_ADDR
// end ;
52918: LD_VAR 0 3
52922: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
52923: LD_INT 0
52925: PPUSH
// if not chassis or not weapon then
52926: LD_VAR 0 1
52930: NOT
52931: PUSH
52932: LD_VAR 0 2
52936: NOT
52937: OR
52938: IFFALSE 52942
// exit ;
52940: GO 53968
// case weapon of us_machine_gun :
52942: LD_VAR 0 2
52946: PUSH
52947: LD_INT 2
52949: DOUBLE
52950: EQUAL
52951: IFTRUE 52955
52953: GO 52985
52955: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
52956: LD_ADDR_VAR 0 3
52960: PUSH
52961: LD_INT 1
52963: PUSH
52964: LD_INT 2
52966: PUSH
52967: LD_INT 3
52969: PUSH
52970: LD_INT 4
52972: PUSH
52973: LD_INT 5
52975: PUSH
52976: EMPTY
52977: LIST
52978: LIST
52979: LIST
52980: LIST
52981: LIST
52982: ST_TO_ADDR
52983: GO 53952
52985: LD_INT 3
52987: DOUBLE
52988: EQUAL
52989: IFTRUE 52993
52991: GO 53023
52993: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
52994: LD_ADDR_VAR 0 3
52998: PUSH
52999: LD_INT 1
53001: PUSH
53002: LD_INT 2
53004: PUSH
53005: LD_INT 3
53007: PUSH
53008: LD_INT 4
53010: PUSH
53011: LD_INT 5
53013: PUSH
53014: EMPTY
53015: LIST
53016: LIST
53017: LIST
53018: LIST
53019: LIST
53020: ST_TO_ADDR
53021: GO 53952
53023: LD_INT 11
53025: DOUBLE
53026: EQUAL
53027: IFTRUE 53031
53029: GO 53061
53031: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
53032: LD_ADDR_VAR 0 3
53036: PUSH
53037: LD_INT 1
53039: PUSH
53040: LD_INT 2
53042: PUSH
53043: LD_INT 3
53045: PUSH
53046: LD_INT 4
53048: PUSH
53049: LD_INT 5
53051: PUSH
53052: EMPTY
53053: LIST
53054: LIST
53055: LIST
53056: LIST
53057: LIST
53058: ST_TO_ADDR
53059: GO 53952
53061: LD_INT 4
53063: DOUBLE
53064: EQUAL
53065: IFTRUE 53069
53067: GO 53095
53069: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
53070: LD_ADDR_VAR 0 3
53074: PUSH
53075: LD_INT 2
53077: PUSH
53078: LD_INT 3
53080: PUSH
53081: LD_INT 4
53083: PUSH
53084: LD_INT 5
53086: PUSH
53087: EMPTY
53088: LIST
53089: LIST
53090: LIST
53091: LIST
53092: ST_TO_ADDR
53093: GO 53952
53095: LD_INT 5
53097: DOUBLE
53098: EQUAL
53099: IFTRUE 53103
53101: GO 53129
53103: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
53104: LD_ADDR_VAR 0 3
53108: PUSH
53109: LD_INT 2
53111: PUSH
53112: LD_INT 3
53114: PUSH
53115: LD_INT 4
53117: PUSH
53118: LD_INT 5
53120: PUSH
53121: EMPTY
53122: LIST
53123: LIST
53124: LIST
53125: LIST
53126: ST_TO_ADDR
53127: GO 53952
53129: LD_INT 9
53131: DOUBLE
53132: EQUAL
53133: IFTRUE 53137
53135: GO 53163
53137: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
53138: LD_ADDR_VAR 0 3
53142: PUSH
53143: LD_INT 2
53145: PUSH
53146: LD_INT 3
53148: PUSH
53149: LD_INT 4
53151: PUSH
53152: LD_INT 5
53154: PUSH
53155: EMPTY
53156: LIST
53157: LIST
53158: LIST
53159: LIST
53160: ST_TO_ADDR
53161: GO 53952
53163: LD_INT 7
53165: DOUBLE
53166: EQUAL
53167: IFTRUE 53171
53169: GO 53197
53171: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
53172: LD_ADDR_VAR 0 3
53176: PUSH
53177: LD_INT 2
53179: PUSH
53180: LD_INT 3
53182: PUSH
53183: LD_INT 4
53185: PUSH
53186: LD_INT 5
53188: PUSH
53189: EMPTY
53190: LIST
53191: LIST
53192: LIST
53193: LIST
53194: ST_TO_ADDR
53195: GO 53952
53197: LD_INT 12
53199: DOUBLE
53200: EQUAL
53201: IFTRUE 53205
53203: GO 53231
53205: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
53206: LD_ADDR_VAR 0 3
53210: PUSH
53211: LD_INT 2
53213: PUSH
53214: LD_INT 3
53216: PUSH
53217: LD_INT 4
53219: PUSH
53220: LD_INT 5
53222: PUSH
53223: EMPTY
53224: LIST
53225: LIST
53226: LIST
53227: LIST
53228: ST_TO_ADDR
53229: GO 53952
53231: LD_INT 13
53233: DOUBLE
53234: EQUAL
53235: IFTRUE 53239
53237: GO 53265
53239: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
53240: LD_ADDR_VAR 0 3
53244: PUSH
53245: LD_INT 2
53247: PUSH
53248: LD_INT 3
53250: PUSH
53251: LD_INT 4
53253: PUSH
53254: LD_INT 5
53256: PUSH
53257: EMPTY
53258: LIST
53259: LIST
53260: LIST
53261: LIST
53262: ST_TO_ADDR
53263: GO 53952
53265: LD_INT 14
53267: DOUBLE
53268: EQUAL
53269: IFTRUE 53273
53271: GO 53291
53273: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
53274: LD_ADDR_VAR 0 3
53278: PUSH
53279: LD_INT 4
53281: PUSH
53282: LD_INT 5
53284: PUSH
53285: EMPTY
53286: LIST
53287: LIST
53288: ST_TO_ADDR
53289: GO 53952
53291: LD_INT 6
53293: DOUBLE
53294: EQUAL
53295: IFTRUE 53299
53297: GO 53317
53299: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
53300: LD_ADDR_VAR 0 3
53304: PUSH
53305: LD_INT 4
53307: PUSH
53308: LD_INT 5
53310: PUSH
53311: EMPTY
53312: LIST
53313: LIST
53314: ST_TO_ADDR
53315: GO 53952
53317: LD_INT 10
53319: DOUBLE
53320: EQUAL
53321: IFTRUE 53325
53323: GO 53343
53325: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
53326: LD_ADDR_VAR 0 3
53330: PUSH
53331: LD_INT 4
53333: PUSH
53334: LD_INT 5
53336: PUSH
53337: EMPTY
53338: LIST
53339: LIST
53340: ST_TO_ADDR
53341: GO 53952
53343: LD_INT 22
53345: DOUBLE
53346: EQUAL
53347: IFTRUE 53351
53349: GO 53377
53351: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
53352: LD_ADDR_VAR 0 3
53356: PUSH
53357: LD_INT 11
53359: PUSH
53360: LD_INT 12
53362: PUSH
53363: LD_INT 13
53365: PUSH
53366: LD_INT 14
53368: PUSH
53369: EMPTY
53370: LIST
53371: LIST
53372: LIST
53373: LIST
53374: ST_TO_ADDR
53375: GO 53952
53377: LD_INT 23
53379: DOUBLE
53380: EQUAL
53381: IFTRUE 53385
53383: GO 53411
53385: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
53386: LD_ADDR_VAR 0 3
53390: PUSH
53391: LD_INT 11
53393: PUSH
53394: LD_INT 12
53396: PUSH
53397: LD_INT 13
53399: PUSH
53400: LD_INT 14
53402: PUSH
53403: EMPTY
53404: LIST
53405: LIST
53406: LIST
53407: LIST
53408: ST_TO_ADDR
53409: GO 53952
53411: LD_INT 24
53413: DOUBLE
53414: EQUAL
53415: IFTRUE 53419
53417: GO 53445
53419: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
53420: LD_ADDR_VAR 0 3
53424: PUSH
53425: LD_INT 11
53427: PUSH
53428: LD_INT 12
53430: PUSH
53431: LD_INT 13
53433: PUSH
53434: LD_INT 14
53436: PUSH
53437: EMPTY
53438: LIST
53439: LIST
53440: LIST
53441: LIST
53442: ST_TO_ADDR
53443: GO 53952
53445: LD_INT 30
53447: DOUBLE
53448: EQUAL
53449: IFTRUE 53453
53451: GO 53479
53453: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
53454: LD_ADDR_VAR 0 3
53458: PUSH
53459: LD_INT 11
53461: PUSH
53462: LD_INT 12
53464: PUSH
53465: LD_INT 13
53467: PUSH
53468: LD_INT 14
53470: PUSH
53471: EMPTY
53472: LIST
53473: LIST
53474: LIST
53475: LIST
53476: ST_TO_ADDR
53477: GO 53952
53479: LD_INT 25
53481: DOUBLE
53482: EQUAL
53483: IFTRUE 53487
53485: GO 53505
53487: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
53488: LD_ADDR_VAR 0 3
53492: PUSH
53493: LD_INT 13
53495: PUSH
53496: LD_INT 14
53498: PUSH
53499: EMPTY
53500: LIST
53501: LIST
53502: ST_TO_ADDR
53503: GO 53952
53505: LD_INT 27
53507: DOUBLE
53508: EQUAL
53509: IFTRUE 53513
53511: GO 53531
53513: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
53514: LD_ADDR_VAR 0 3
53518: PUSH
53519: LD_INT 13
53521: PUSH
53522: LD_INT 14
53524: PUSH
53525: EMPTY
53526: LIST
53527: LIST
53528: ST_TO_ADDR
53529: GO 53952
53531: LD_INT 28
53533: DOUBLE
53534: EQUAL
53535: IFTRUE 53539
53537: GO 53557
53539: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
53540: LD_ADDR_VAR 0 3
53544: PUSH
53545: LD_INT 13
53547: PUSH
53548: LD_INT 14
53550: PUSH
53551: EMPTY
53552: LIST
53553: LIST
53554: ST_TO_ADDR
53555: GO 53952
53557: LD_INT 29
53559: DOUBLE
53560: EQUAL
53561: IFTRUE 53565
53563: GO 53583
53565: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
53566: LD_ADDR_VAR 0 3
53570: PUSH
53571: LD_INT 13
53573: PUSH
53574: LD_INT 14
53576: PUSH
53577: EMPTY
53578: LIST
53579: LIST
53580: ST_TO_ADDR
53581: GO 53952
53583: LD_INT 31
53585: DOUBLE
53586: EQUAL
53587: IFTRUE 53591
53589: GO 53609
53591: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
53592: LD_ADDR_VAR 0 3
53596: PUSH
53597: LD_INT 13
53599: PUSH
53600: LD_INT 14
53602: PUSH
53603: EMPTY
53604: LIST
53605: LIST
53606: ST_TO_ADDR
53607: GO 53952
53609: LD_INT 26
53611: DOUBLE
53612: EQUAL
53613: IFTRUE 53617
53615: GO 53635
53617: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
53618: LD_ADDR_VAR 0 3
53622: PUSH
53623: LD_INT 13
53625: PUSH
53626: LD_INT 14
53628: PUSH
53629: EMPTY
53630: LIST
53631: LIST
53632: ST_TO_ADDR
53633: GO 53952
53635: LD_INT 42
53637: DOUBLE
53638: EQUAL
53639: IFTRUE 53643
53641: GO 53669
53643: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
53644: LD_ADDR_VAR 0 3
53648: PUSH
53649: LD_INT 21
53651: PUSH
53652: LD_INT 22
53654: PUSH
53655: LD_INT 23
53657: PUSH
53658: LD_INT 24
53660: PUSH
53661: EMPTY
53662: LIST
53663: LIST
53664: LIST
53665: LIST
53666: ST_TO_ADDR
53667: GO 53952
53669: LD_INT 43
53671: DOUBLE
53672: EQUAL
53673: IFTRUE 53677
53675: GO 53703
53677: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
53678: LD_ADDR_VAR 0 3
53682: PUSH
53683: LD_INT 21
53685: PUSH
53686: LD_INT 22
53688: PUSH
53689: LD_INT 23
53691: PUSH
53692: LD_INT 24
53694: PUSH
53695: EMPTY
53696: LIST
53697: LIST
53698: LIST
53699: LIST
53700: ST_TO_ADDR
53701: GO 53952
53703: LD_INT 44
53705: DOUBLE
53706: EQUAL
53707: IFTRUE 53711
53709: GO 53737
53711: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
53712: LD_ADDR_VAR 0 3
53716: PUSH
53717: LD_INT 21
53719: PUSH
53720: LD_INT 22
53722: PUSH
53723: LD_INT 23
53725: PUSH
53726: LD_INT 24
53728: PUSH
53729: EMPTY
53730: LIST
53731: LIST
53732: LIST
53733: LIST
53734: ST_TO_ADDR
53735: GO 53952
53737: LD_INT 45
53739: DOUBLE
53740: EQUAL
53741: IFTRUE 53745
53743: GO 53771
53745: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
53746: LD_ADDR_VAR 0 3
53750: PUSH
53751: LD_INT 21
53753: PUSH
53754: LD_INT 22
53756: PUSH
53757: LD_INT 23
53759: PUSH
53760: LD_INT 24
53762: PUSH
53763: EMPTY
53764: LIST
53765: LIST
53766: LIST
53767: LIST
53768: ST_TO_ADDR
53769: GO 53952
53771: LD_INT 49
53773: DOUBLE
53774: EQUAL
53775: IFTRUE 53779
53777: GO 53805
53779: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
53780: LD_ADDR_VAR 0 3
53784: PUSH
53785: LD_INT 21
53787: PUSH
53788: LD_INT 22
53790: PUSH
53791: LD_INT 23
53793: PUSH
53794: LD_INT 24
53796: PUSH
53797: EMPTY
53798: LIST
53799: LIST
53800: LIST
53801: LIST
53802: ST_TO_ADDR
53803: GO 53952
53805: LD_INT 51
53807: DOUBLE
53808: EQUAL
53809: IFTRUE 53813
53811: GO 53839
53813: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
53814: LD_ADDR_VAR 0 3
53818: PUSH
53819: LD_INT 21
53821: PUSH
53822: LD_INT 22
53824: PUSH
53825: LD_INT 23
53827: PUSH
53828: LD_INT 24
53830: PUSH
53831: EMPTY
53832: LIST
53833: LIST
53834: LIST
53835: LIST
53836: ST_TO_ADDR
53837: GO 53952
53839: LD_INT 52
53841: DOUBLE
53842: EQUAL
53843: IFTRUE 53847
53845: GO 53873
53847: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
53848: LD_ADDR_VAR 0 3
53852: PUSH
53853: LD_INT 21
53855: PUSH
53856: LD_INT 22
53858: PUSH
53859: LD_INT 23
53861: PUSH
53862: LD_INT 24
53864: PUSH
53865: EMPTY
53866: LIST
53867: LIST
53868: LIST
53869: LIST
53870: ST_TO_ADDR
53871: GO 53952
53873: LD_INT 53
53875: DOUBLE
53876: EQUAL
53877: IFTRUE 53881
53879: GO 53899
53881: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
53882: LD_ADDR_VAR 0 3
53886: PUSH
53887: LD_INT 23
53889: PUSH
53890: LD_INT 24
53892: PUSH
53893: EMPTY
53894: LIST
53895: LIST
53896: ST_TO_ADDR
53897: GO 53952
53899: LD_INT 46
53901: DOUBLE
53902: EQUAL
53903: IFTRUE 53907
53905: GO 53925
53907: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
53908: LD_ADDR_VAR 0 3
53912: PUSH
53913: LD_INT 23
53915: PUSH
53916: LD_INT 24
53918: PUSH
53919: EMPTY
53920: LIST
53921: LIST
53922: ST_TO_ADDR
53923: GO 53952
53925: LD_INT 47
53927: DOUBLE
53928: EQUAL
53929: IFTRUE 53933
53931: GO 53951
53933: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
53934: LD_ADDR_VAR 0 3
53938: PUSH
53939: LD_INT 23
53941: PUSH
53942: LD_INT 24
53944: PUSH
53945: EMPTY
53946: LIST
53947: LIST
53948: ST_TO_ADDR
53949: GO 53952
53951: POP
// result := ( chassis in result ) ;
53952: LD_ADDR_VAR 0 3
53956: PUSH
53957: LD_VAR 0 1
53961: PUSH
53962: LD_VAR 0 3
53966: IN
53967: ST_TO_ADDR
// end ;
53968: LD_VAR 0 3
53972: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
53973: LD_INT 0
53975: PPUSH
53976: PPUSH
53977: PPUSH
53978: PPUSH
53979: PPUSH
53980: PPUSH
53981: PPUSH
// result := array ;
53982: LD_ADDR_VAR 0 5
53986: PUSH
53987: LD_VAR 0 1
53991: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
53992: LD_VAR 0 1
53996: NOT
53997: PUSH
53998: LD_VAR 0 2
54002: NOT
54003: OR
54004: PUSH
54005: LD_VAR 0 3
54009: NOT
54010: OR
54011: PUSH
54012: LD_VAR 0 2
54016: PUSH
54017: LD_VAR 0 1
54021: GREATER
54022: OR
54023: PUSH
54024: LD_VAR 0 3
54028: PUSH
54029: LD_VAR 0 1
54033: GREATER
54034: OR
54035: IFFALSE 54039
// exit ;
54037: GO 54335
// if direction then
54039: LD_VAR 0 4
54043: IFFALSE 54107
// begin d := 1 ;
54045: LD_ADDR_VAR 0 9
54049: PUSH
54050: LD_INT 1
54052: ST_TO_ADDR
// if i_from > i_to then
54053: LD_VAR 0 2
54057: PUSH
54058: LD_VAR 0 3
54062: GREATER
54063: IFFALSE 54089
// length := ( array - i_from ) + i_to else
54065: LD_ADDR_VAR 0 11
54069: PUSH
54070: LD_VAR 0 1
54074: PUSH
54075: LD_VAR 0 2
54079: MINUS
54080: PUSH
54081: LD_VAR 0 3
54085: PLUS
54086: ST_TO_ADDR
54087: GO 54105
// length := i_to - i_from ;
54089: LD_ADDR_VAR 0 11
54093: PUSH
54094: LD_VAR 0 3
54098: PUSH
54099: LD_VAR 0 2
54103: MINUS
54104: ST_TO_ADDR
// end else
54105: GO 54168
// begin d := - 1 ;
54107: LD_ADDR_VAR 0 9
54111: PUSH
54112: LD_INT 1
54114: NEG
54115: ST_TO_ADDR
// if i_from > i_to then
54116: LD_VAR 0 2
54120: PUSH
54121: LD_VAR 0 3
54125: GREATER
54126: IFFALSE 54146
// length := i_from - i_to else
54128: LD_ADDR_VAR 0 11
54132: PUSH
54133: LD_VAR 0 2
54137: PUSH
54138: LD_VAR 0 3
54142: MINUS
54143: ST_TO_ADDR
54144: GO 54168
// length := ( array - i_to ) + i_from ;
54146: LD_ADDR_VAR 0 11
54150: PUSH
54151: LD_VAR 0 1
54155: PUSH
54156: LD_VAR 0 3
54160: MINUS
54161: PUSH
54162: LD_VAR 0 2
54166: PLUS
54167: ST_TO_ADDR
// end ; if not length then
54168: LD_VAR 0 11
54172: NOT
54173: IFFALSE 54177
// exit ;
54175: GO 54335
// tmp := array ;
54177: LD_ADDR_VAR 0 10
54181: PUSH
54182: LD_VAR 0 1
54186: ST_TO_ADDR
// for i = 1 to length do
54187: LD_ADDR_VAR 0 6
54191: PUSH
54192: DOUBLE
54193: LD_INT 1
54195: DEC
54196: ST_TO_ADDR
54197: LD_VAR 0 11
54201: PUSH
54202: FOR_TO
54203: IFFALSE 54323
// begin for j = 1 to array do
54205: LD_ADDR_VAR 0 7
54209: PUSH
54210: DOUBLE
54211: LD_INT 1
54213: DEC
54214: ST_TO_ADDR
54215: LD_VAR 0 1
54219: PUSH
54220: FOR_TO
54221: IFFALSE 54309
// begin k := j + d ;
54223: LD_ADDR_VAR 0 8
54227: PUSH
54228: LD_VAR 0 7
54232: PUSH
54233: LD_VAR 0 9
54237: PLUS
54238: ST_TO_ADDR
// if k > array then
54239: LD_VAR 0 8
54243: PUSH
54244: LD_VAR 0 1
54248: GREATER
54249: IFFALSE 54259
// k := 1 ;
54251: LD_ADDR_VAR 0 8
54255: PUSH
54256: LD_INT 1
54258: ST_TO_ADDR
// if not k then
54259: LD_VAR 0 8
54263: NOT
54264: IFFALSE 54276
// k := array ;
54266: LD_ADDR_VAR 0 8
54270: PUSH
54271: LD_VAR 0 1
54275: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
54276: LD_ADDR_VAR 0 10
54280: PUSH
54281: LD_VAR 0 10
54285: PPUSH
54286: LD_VAR 0 8
54290: PPUSH
54291: LD_VAR 0 1
54295: PUSH
54296: LD_VAR 0 7
54300: ARRAY
54301: PPUSH
54302: CALL_OW 1
54306: ST_TO_ADDR
// end ;
54307: GO 54220
54309: POP
54310: POP
// array := tmp ;
54311: LD_ADDR_VAR 0 1
54315: PUSH
54316: LD_VAR 0 10
54320: ST_TO_ADDR
// end ;
54321: GO 54202
54323: POP
54324: POP
// result := array ;
54325: LD_ADDR_VAR 0 5
54329: PUSH
54330: LD_VAR 0 1
54334: ST_TO_ADDR
// end ;
54335: LD_VAR 0 5
54339: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
54340: LD_INT 0
54342: PPUSH
54343: PPUSH
// result := 0 ;
54344: LD_ADDR_VAR 0 3
54348: PUSH
54349: LD_INT 0
54351: ST_TO_ADDR
// if not array or not value in array then
54352: LD_VAR 0 1
54356: NOT
54357: PUSH
54358: LD_VAR 0 2
54362: PUSH
54363: LD_VAR 0 1
54367: IN
54368: NOT
54369: OR
54370: IFFALSE 54374
// exit ;
54372: GO 54428
// for i = 1 to array do
54374: LD_ADDR_VAR 0 4
54378: PUSH
54379: DOUBLE
54380: LD_INT 1
54382: DEC
54383: ST_TO_ADDR
54384: LD_VAR 0 1
54388: PUSH
54389: FOR_TO
54390: IFFALSE 54426
// if value = array [ i ] then
54392: LD_VAR 0 2
54396: PUSH
54397: LD_VAR 0 1
54401: PUSH
54402: LD_VAR 0 4
54406: ARRAY
54407: EQUAL
54408: IFFALSE 54424
// begin result := i ;
54410: LD_ADDR_VAR 0 3
54414: PUSH
54415: LD_VAR 0 4
54419: ST_TO_ADDR
// exit ;
54420: POP
54421: POP
54422: GO 54428
// end ;
54424: GO 54389
54426: POP
54427: POP
// end ;
54428: LD_VAR 0 3
54432: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
54433: LD_INT 0
54435: PPUSH
// vc_chassis := chassis ;
54436: LD_ADDR_OWVAR 37
54440: PUSH
54441: LD_VAR 0 1
54445: ST_TO_ADDR
// vc_engine := engine ;
54446: LD_ADDR_OWVAR 39
54450: PUSH
54451: LD_VAR 0 2
54455: ST_TO_ADDR
// vc_control := control ;
54456: LD_ADDR_OWVAR 38
54460: PUSH
54461: LD_VAR 0 3
54465: ST_TO_ADDR
// vc_weapon := weapon ;
54466: LD_ADDR_OWVAR 40
54470: PUSH
54471: LD_VAR 0 4
54475: ST_TO_ADDR
// vc_fuel_battery := fuel ;
54476: LD_ADDR_OWVAR 41
54480: PUSH
54481: LD_VAR 0 5
54485: ST_TO_ADDR
// end ;
54486: LD_VAR 0 6
54490: RET
// export function WantPlant ( unit ) ; var task ; begin
54491: LD_INT 0
54493: PPUSH
54494: PPUSH
// result := false ;
54495: LD_ADDR_VAR 0 2
54499: PUSH
54500: LD_INT 0
54502: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
54503: LD_ADDR_VAR 0 3
54507: PUSH
54508: LD_VAR 0 1
54512: PPUSH
54513: CALL_OW 437
54517: ST_TO_ADDR
// if task then
54518: LD_VAR 0 3
54522: IFFALSE 54550
// if task [ 1 ] [ 1 ] = p then
54524: LD_VAR 0 3
54528: PUSH
54529: LD_INT 1
54531: ARRAY
54532: PUSH
54533: LD_INT 1
54535: ARRAY
54536: PUSH
54537: LD_STRING p
54539: EQUAL
54540: IFFALSE 54550
// result := true ;
54542: LD_ADDR_VAR 0 2
54546: PUSH
54547: LD_INT 1
54549: ST_TO_ADDR
// end ;
54550: LD_VAR 0 2
54554: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
54555: LD_INT 0
54557: PPUSH
54558: PPUSH
54559: PPUSH
54560: PPUSH
// if pos < 1 then
54561: LD_VAR 0 2
54565: PUSH
54566: LD_INT 1
54568: LESS
54569: IFFALSE 54573
// exit ;
54571: GO 54876
// if pos = 1 then
54573: LD_VAR 0 2
54577: PUSH
54578: LD_INT 1
54580: EQUAL
54581: IFFALSE 54614
// result := Replace ( arr , pos [ 1 ] , value ) else
54583: LD_ADDR_VAR 0 4
54587: PUSH
54588: LD_VAR 0 1
54592: PPUSH
54593: LD_VAR 0 2
54597: PUSH
54598: LD_INT 1
54600: ARRAY
54601: PPUSH
54602: LD_VAR 0 3
54606: PPUSH
54607: CALL_OW 1
54611: ST_TO_ADDR
54612: GO 54876
// begin tmp := arr ;
54614: LD_ADDR_VAR 0 6
54618: PUSH
54619: LD_VAR 0 1
54623: ST_TO_ADDR
// s_arr := [ tmp ] ;
54624: LD_ADDR_VAR 0 7
54628: PUSH
54629: LD_VAR 0 6
54633: PUSH
54634: EMPTY
54635: LIST
54636: ST_TO_ADDR
// for i = 1 to pos - 1 do
54637: LD_ADDR_VAR 0 5
54641: PUSH
54642: DOUBLE
54643: LD_INT 1
54645: DEC
54646: ST_TO_ADDR
54647: LD_VAR 0 2
54651: PUSH
54652: LD_INT 1
54654: MINUS
54655: PUSH
54656: FOR_TO
54657: IFFALSE 54702
// begin tmp := tmp [ pos [ i ] ] ;
54659: LD_ADDR_VAR 0 6
54663: PUSH
54664: LD_VAR 0 6
54668: PUSH
54669: LD_VAR 0 2
54673: PUSH
54674: LD_VAR 0 5
54678: ARRAY
54679: ARRAY
54680: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
54681: LD_ADDR_VAR 0 7
54685: PUSH
54686: LD_VAR 0 7
54690: PUSH
54691: LD_VAR 0 6
54695: PUSH
54696: EMPTY
54697: LIST
54698: ADD
54699: ST_TO_ADDR
// end ;
54700: GO 54656
54702: POP
54703: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
54704: LD_ADDR_VAR 0 6
54708: PUSH
54709: LD_VAR 0 6
54713: PPUSH
54714: LD_VAR 0 2
54718: PUSH
54719: LD_VAR 0 2
54723: ARRAY
54724: PPUSH
54725: LD_VAR 0 3
54729: PPUSH
54730: CALL_OW 1
54734: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
54735: LD_ADDR_VAR 0 7
54739: PUSH
54740: LD_VAR 0 7
54744: PPUSH
54745: LD_VAR 0 7
54749: PPUSH
54750: LD_VAR 0 6
54754: PPUSH
54755: CALL_OW 1
54759: ST_TO_ADDR
// for i = s_arr downto 2 do
54760: LD_ADDR_VAR 0 5
54764: PUSH
54765: DOUBLE
54766: LD_VAR 0 7
54770: INC
54771: ST_TO_ADDR
54772: LD_INT 2
54774: PUSH
54775: FOR_DOWNTO
54776: IFFALSE 54860
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
54778: LD_ADDR_VAR 0 6
54782: PUSH
54783: LD_VAR 0 7
54787: PUSH
54788: LD_VAR 0 5
54792: PUSH
54793: LD_INT 1
54795: MINUS
54796: ARRAY
54797: PPUSH
54798: LD_VAR 0 2
54802: PUSH
54803: LD_VAR 0 5
54807: PUSH
54808: LD_INT 1
54810: MINUS
54811: ARRAY
54812: PPUSH
54813: LD_VAR 0 7
54817: PUSH
54818: LD_VAR 0 5
54822: ARRAY
54823: PPUSH
54824: CALL_OW 1
54828: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
54829: LD_ADDR_VAR 0 7
54833: PUSH
54834: LD_VAR 0 7
54838: PPUSH
54839: LD_VAR 0 5
54843: PUSH
54844: LD_INT 1
54846: MINUS
54847: PPUSH
54848: LD_VAR 0 6
54852: PPUSH
54853: CALL_OW 1
54857: ST_TO_ADDR
// end ;
54858: GO 54775
54860: POP
54861: POP
// result := s_arr [ 1 ] ;
54862: LD_ADDR_VAR 0 4
54866: PUSH
54867: LD_VAR 0 7
54871: PUSH
54872: LD_INT 1
54874: ARRAY
54875: ST_TO_ADDR
// end ; end ;
54876: LD_VAR 0 4
54880: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
54881: LD_INT 0
54883: PPUSH
54884: PPUSH
// if not list then
54885: LD_VAR 0 1
54889: NOT
54890: IFFALSE 54894
// exit ;
54892: GO 54985
// i := list [ pos1 ] ;
54894: LD_ADDR_VAR 0 5
54898: PUSH
54899: LD_VAR 0 1
54903: PUSH
54904: LD_VAR 0 2
54908: ARRAY
54909: ST_TO_ADDR
// if not i then
54910: LD_VAR 0 5
54914: NOT
54915: IFFALSE 54919
// exit ;
54917: GO 54985
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
54919: LD_ADDR_VAR 0 1
54923: PUSH
54924: LD_VAR 0 1
54928: PPUSH
54929: LD_VAR 0 2
54933: PPUSH
54934: LD_VAR 0 1
54938: PUSH
54939: LD_VAR 0 3
54943: ARRAY
54944: PPUSH
54945: CALL_OW 1
54949: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
54950: LD_ADDR_VAR 0 1
54954: PUSH
54955: LD_VAR 0 1
54959: PPUSH
54960: LD_VAR 0 3
54964: PPUSH
54965: LD_VAR 0 5
54969: PPUSH
54970: CALL_OW 1
54974: ST_TO_ADDR
// result := list ;
54975: LD_ADDR_VAR 0 4
54979: PUSH
54980: LD_VAR 0 1
54984: ST_TO_ADDR
// end ;
54985: LD_VAR 0 4
54989: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
54990: LD_INT 0
54992: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
54993: LD_ADDR_VAR 0 5
54997: PUSH
54998: LD_VAR 0 1
55002: PPUSH
55003: CALL_OW 250
55007: PPUSH
55008: LD_VAR 0 1
55012: PPUSH
55013: CALL_OW 251
55017: PPUSH
55018: LD_VAR 0 2
55022: PPUSH
55023: LD_VAR 0 3
55027: PPUSH
55028: LD_VAR 0 4
55032: PPUSH
55033: CALL 55043 0 5
55037: ST_TO_ADDR
// end ;
55038: LD_VAR 0 5
55042: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
55043: LD_INT 0
55045: PPUSH
55046: PPUSH
55047: PPUSH
55048: PPUSH
// if not list then
55049: LD_VAR 0 3
55053: NOT
55054: IFFALSE 55058
// exit ;
55056: GO 55446
// result := [ ] ;
55058: LD_ADDR_VAR 0 6
55062: PUSH
55063: EMPTY
55064: ST_TO_ADDR
// for i in list do
55065: LD_ADDR_VAR 0 7
55069: PUSH
55070: LD_VAR 0 3
55074: PUSH
55075: FOR_IN
55076: IFFALSE 55278
// begin tmp := GetDistUnitXY ( i , x , y ) ;
55078: LD_ADDR_VAR 0 9
55082: PUSH
55083: LD_VAR 0 7
55087: PPUSH
55088: LD_VAR 0 1
55092: PPUSH
55093: LD_VAR 0 2
55097: PPUSH
55098: CALL_OW 297
55102: ST_TO_ADDR
// if not result then
55103: LD_VAR 0 6
55107: NOT
55108: IFFALSE 55134
// result := [ [ i , tmp ] ] else
55110: LD_ADDR_VAR 0 6
55114: PUSH
55115: LD_VAR 0 7
55119: PUSH
55120: LD_VAR 0 9
55124: PUSH
55125: EMPTY
55126: LIST
55127: LIST
55128: PUSH
55129: EMPTY
55130: LIST
55131: ST_TO_ADDR
55132: GO 55276
// begin if result [ result ] [ 2 ] < tmp then
55134: LD_VAR 0 6
55138: PUSH
55139: LD_VAR 0 6
55143: ARRAY
55144: PUSH
55145: LD_INT 2
55147: ARRAY
55148: PUSH
55149: LD_VAR 0 9
55153: LESS
55154: IFFALSE 55196
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
55156: LD_ADDR_VAR 0 6
55160: PUSH
55161: LD_VAR 0 6
55165: PPUSH
55166: LD_VAR 0 6
55170: PUSH
55171: LD_INT 1
55173: PLUS
55174: PPUSH
55175: LD_VAR 0 7
55179: PUSH
55180: LD_VAR 0 9
55184: PUSH
55185: EMPTY
55186: LIST
55187: LIST
55188: PPUSH
55189: CALL_OW 2
55193: ST_TO_ADDR
55194: GO 55276
// for j = 1 to result do
55196: LD_ADDR_VAR 0 8
55200: PUSH
55201: DOUBLE
55202: LD_INT 1
55204: DEC
55205: ST_TO_ADDR
55206: LD_VAR 0 6
55210: PUSH
55211: FOR_TO
55212: IFFALSE 55274
// begin if tmp < result [ j ] [ 2 ] then
55214: LD_VAR 0 9
55218: PUSH
55219: LD_VAR 0 6
55223: PUSH
55224: LD_VAR 0 8
55228: ARRAY
55229: PUSH
55230: LD_INT 2
55232: ARRAY
55233: LESS
55234: IFFALSE 55272
// begin result := Insert ( result , j , [ i , tmp ] ) ;
55236: LD_ADDR_VAR 0 6
55240: PUSH
55241: LD_VAR 0 6
55245: PPUSH
55246: LD_VAR 0 8
55250: PPUSH
55251: LD_VAR 0 7
55255: PUSH
55256: LD_VAR 0 9
55260: PUSH
55261: EMPTY
55262: LIST
55263: LIST
55264: PPUSH
55265: CALL_OW 2
55269: ST_TO_ADDR
// break ;
55270: GO 55274
// end ; end ;
55272: GO 55211
55274: POP
55275: POP
// end ; end ;
55276: GO 55075
55278: POP
55279: POP
// if result and not asc then
55280: LD_VAR 0 6
55284: PUSH
55285: LD_VAR 0 4
55289: NOT
55290: AND
55291: IFFALSE 55366
// begin tmp := result ;
55293: LD_ADDR_VAR 0 9
55297: PUSH
55298: LD_VAR 0 6
55302: ST_TO_ADDR
// for i = tmp downto 1 do
55303: LD_ADDR_VAR 0 7
55307: PUSH
55308: DOUBLE
55309: LD_VAR 0 9
55313: INC
55314: ST_TO_ADDR
55315: LD_INT 1
55317: PUSH
55318: FOR_DOWNTO
55319: IFFALSE 55364
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
55321: LD_ADDR_VAR 0 6
55325: PUSH
55326: LD_VAR 0 6
55330: PPUSH
55331: LD_VAR 0 9
55335: PUSH
55336: LD_VAR 0 7
55340: MINUS
55341: PUSH
55342: LD_INT 1
55344: PLUS
55345: PPUSH
55346: LD_VAR 0 9
55350: PUSH
55351: LD_VAR 0 7
55355: ARRAY
55356: PPUSH
55357: CALL_OW 1
55361: ST_TO_ADDR
55362: GO 55318
55364: POP
55365: POP
// end ; tmp := [ ] ;
55366: LD_ADDR_VAR 0 9
55370: PUSH
55371: EMPTY
55372: ST_TO_ADDR
// if mode then
55373: LD_VAR 0 5
55377: IFFALSE 55446
// begin for i = 1 to result do
55379: LD_ADDR_VAR 0 7
55383: PUSH
55384: DOUBLE
55385: LD_INT 1
55387: DEC
55388: ST_TO_ADDR
55389: LD_VAR 0 6
55393: PUSH
55394: FOR_TO
55395: IFFALSE 55434
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
55397: LD_ADDR_VAR 0 9
55401: PUSH
55402: LD_VAR 0 9
55406: PPUSH
55407: LD_VAR 0 7
55411: PPUSH
55412: LD_VAR 0 6
55416: PUSH
55417: LD_VAR 0 7
55421: ARRAY
55422: PUSH
55423: LD_INT 1
55425: ARRAY
55426: PPUSH
55427: CALL_OW 1
55431: ST_TO_ADDR
55432: GO 55394
55434: POP
55435: POP
// result := tmp ;
55436: LD_ADDR_VAR 0 6
55440: PUSH
55441: LD_VAR 0 9
55445: ST_TO_ADDR
// end ; end ;
55446: LD_VAR 0 6
55450: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
55451: LD_INT 0
55453: PPUSH
55454: PPUSH
55455: PPUSH
55456: PPUSH
55457: PPUSH
55458: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
55459: LD_ADDR_VAR 0 5
55463: PUSH
55464: LD_INT 0
55466: PUSH
55467: LD_INT 0
55469: PUSH
55470: LD_INT 0
55472: PUSH
55473: EMPTY
55474: PUSH
55475: EMPTY
55476: LIST
55477: LIST
55478: LIST
55479: LIST
55480: ST_TO_ADDR
// if not x or not y then
55481: LD_VAR 0 2
55485: NOT
55486: PUSH
55487: LD_VAR 0 3
55491: NOT
55492: OR
55493: IFFALSE 55497
// exit ;
55495: GO 57143
// if not range then
55497: LD_VAR 0 4
55501: NOT
55502: IFFALSE 55512
// range := 10 ;
55504: LD_ADDR_VAR 0 4
55508: PUSH
55509: LD_INT 10
55511: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
55512: LD_ADDR_VAR 0 8
55516: PUSH
55517: LD_INT 81
55519: PUSH
55520: LD_VAR 0 1
55524: PUSH
55525: EMPTY
55526: LIST
55527: LIST
55528: PUSH
55529: LD_INT 92
55531: PUSH
55532: LD_VAR 0 2
55536: PUSH
55537: LD_VAR 0 3
55541: PUSH
55542: LD_VAR 0 4
55546: PUSH
55547: EMPTY
55548: LIST
55549: LIST
55550: LIST
55551: LIST
55552: PUSH
55553: LD_INT 3
55555: PUSH
55556: LD_INT 21
55558: PUSH
55559: LD_INT 3
55561: PUSH
55562: EMPTY
55563: LIST
55564: LIST
55565: PUSH
55566: EMPTY
55567: LIST
55568: LIST
55569: PUSH
55570: EMPTY
55571: LIST
55572: LIST
55573: LIST
55574: PPUSH
55575: CALL_OW 69
55579: ST_TO_ADDR
// if not tmp then
55580: LD_VAR 0 8
55584: NOT
55585: IFFALSE 55589
// exit ;
55587: GO 57143
// for i in tmp do
55589: LD_ADDR_VAR 0 6
55593: PUSH
55594: LD_VAR 0 8
55598: PUSH
55599: FOR_IN
55600: IFFALSE 57118
// begin points := [ 0 , 0 , 0 ] ;
55602: LD_ADDR_VAR 0 9
55606: PUSH
55607: LD_INT 0
55609: PUSH
55610: LD_INT 0
55612: PUSH
55613: LD_INT 0
55615: PUSH
55616: EMPTY
55617: LIST
55618: LIST
55619: LIST
55620: ST_TO_ADDR
// bpoints := 1 ;
55621: LD_ADDR_VAR 0 10
55625: PUSH
55626: LD_INT 1
55628: ST_TO_ADDR
// case GetType ( i ) of unit_human :
55629: LD_VAR 0 6
55633: PPUSH
55634: CALL_OW 247
55638: PUSH
55639: LD_INT 1
55641: DOUBLE
55642: EQUAL
55643: IFTRUE 55647
55645: GO 56225
55647: POP
// begin if GetClass ( i ) = 1 then
55648: LD_VAR 0 6
55652: PPUSH
55653: CALL_OW 257
55657: PUSH
55658: LD_INT 1
55660: EQUAL
55661: IFFALSE 55682
// points := [ 10 , 5 , 3 ] ;
55663: LD_ADDR_VAR 0 9
55667: PUSH
55668: LD_INT 10
55670: PUSH
55671: LD_INT 5
55673: PUSH
55674: LD_INT 3
55676: PUSH
55677: EMPTY
55678: LIST
55679: LIST
55680: LIST
55681: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
55682: LD_VAR 0 6
55686: PPUSH
55687: CALL_OW 257
55691: PUSH
55692: LD_INT 2
55694: PUSH
55695: LD_INT 3
55697: PUSH
55698: LD_INT 4
55700: PUSH
55701: EMPTY
55702: LIST
55703: LIST
55704: LIST
55705: IN
55706: IFFALSE 55727
// points := [ 3 , 2 , 1 ] ;
55708: LD_ADDR_VAR 0 9
55712: PUSH
55713: LD_INT 3
55715: PUSH
55716: LD_INT 2
55718: PUSH
55719: LD_INT 1
55721: PUSH
55722: EMPTY
55723: LIST
55724: LIST
55725: LIST
55726: ST_TO_ADDR
// if GetClass ( i ) = 5 then
55727: LD_VAR 0 6
55731: PPUSH
55732: CALL_OW 257
55736: PUSH
55737: LD_INT 5
55739: EQUAL
55740: IFFALSE 55761
// points := [ 130 , 5 , 2 ] ;
55742: LD_ADDR_VAR 0 9
55746: PUSH
55747: LD_INT 130
55749: PUSH
55750: LD_INT 5
55752: PUSH
55753: LD_INT 2
55755: PUSH
55756: EMPTY
55757: LIST
55758: LIST
55759: LIST
55760: ST_TO_ADDR
// if GetClass ( i ) = 8 then
55761: LD_VAR 0 6
55765: PPUSH
55766: CALL_OW 257
55770: PUSH
55771: LD_INT 8
55773: EQUAL
55774: IFFALSE 55795
// points := [ 35 , 35 , 30 ] ;
55776: LD_ADDR_VAR 0 9
55780: PUSH
55781: LD_INT 35
55783: PUSH
55784: LD_INT 35
55786: PUSH
55787: LD_INT 30
55789: PUSH
55790: EMPTY
55791: LIST
55792: LIST
55793: LIST
55794: ST_TO_ADDR
// if GetClass ( i ) = 9 then
55795: LD_VAR 0 6
55799: PPUSH
55800: CALL_OW 257
55804: PUSH
55805: LD_INT 9
55807: EQUAL
55808: IFFALSE 55829
// points := [ 20 , 55 , 40 ] ;
55810: LD_ADDR_VAR 0 9
55814: PUSH
55815: LD_INT 20
55817: PUSH
55818: LD_INT 55
55820: PUSH
55821: LD_INT 40
55823: PUSH
55824: EMPTY
55825: LIST
55826: LIST
55827: LIST
55828: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
55829: LD_VAR 0 6
55833: PPUSH
55834: CALL_OW 257
55838: PUSH
55839: LD_INT 12
55841: PUSH
55842: LD_INT 16
55844: PUSH
55845: EMPTY
55846: LIST
55847: LIST
55848: IN
55849: IFFALSE 55870
// points := [ 5 , 3 , 2 ] ;
55851: LD_ADDR_VAR 0 9
55855: PUSH
55856: LD_INT 5
55858: PUSH
55859: LD_INT 3
55861: PUSH
55862: LD_INT 2
55864: PUSH
55865: EMPTY
55866: LIST
55867: LIST
55868: LIST
55869: ST_TO_ADDR
// if GetClass ( i ) = 17 then
55870: LD_VAR 0 6
55874: PPUSH
55875: CALL_OW 257
55879: PUSH
55880: LD_INT 17
55882: EQUAL
55883: IFFALSE 55904
// points := [ 100 , 50 , 75 ] ;
55885: LD_ADDR_VAR 0 9
55889: PUSH
55890: LD_INT 100
55892: PUSH
55893: LD_INT 50
55895: PUSH
55896: LD_INT 75
55898: PUSH
55899: EMPTY
55900: LIST
55901: LIST
55902: LIST
55903: ST_TO_ADDR
// if GetClass ( i ) = 15 then
55904: LD_VAR 0 6
55908: PPUSH
55909: CALL_OW 257
55913: PUSH
55914: LD_INT 15
55916: EQUAL
55917: IFFALSE 55938
// points := [ 10 , 5 , 3 ] ;
55919: LD_ADDR_VAR 0 9
55923: PUSH
55924: LD_INT 10
55926: PUSH
55927: LD_INT 5
55929: PUSH
55930: LD_INT 3
55932: PUSH
55933: EMPTY
55934: LIST
55935: LIST
55936: LIST
55937: ST_TO_ADDR
// if GetClass ( i ) = 14 then
55938: LD_VAR 0 6
55942: PPUSH
55943: CALL_OW 257
55947: PUSH
55948: LD_INT 14
55950: EQUAL
55951: IFFALSE 55972
// points := [ 10 , 0 , 0 ] ;
55953: LD_ADDR_VAR 0 9
55957: PUSH
55958: LD_INT 10
55960: PUSH
55961: LD_INT 0
55963: PUSH
55964: LD_INT 0
55966: PUSH
55967: EMPTY
55968: LIST
55969: LIST
55970: LIST
55971: ST_TO_ADDR
// if GetClass ( i ) = 11 then
55972: LD_VAR 0 6
55976: PPUSH
55977: CALL_OW 257
55981: PUSH
55982: LD_INT 11
55984: EQUAL
55985: IFFALSE 56006
// points := [ 30 , 10 , 5 ] ;
55987: LD_ADDR_VAR 0 9
55991: PUSH
55992: LD_INT 30
55994: PUSH
55995: LD_INT 10
55997: PUSH
55998: LD_INT 5
56000: PUSH
56001: EMPTY
56002: LIST
56003: LIST
56004: LIST
56005: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
56006: LD_VAR 0 1
56010: PPUSH
56011: LD_INT 5
56013: PPUSH
56014: CALL_OW 321
56018: PUSH
56019: LD_INT 2
56021: EQUAL
56022: IFFALSE 56039
// bpoints := bpoints * 1.8 ;
56024: LD_ADDR_VAR 0 10
56028: PUSH
56029: LD_VAR 0 10
56033: PUSH
56034: LD_REAL  1.80000000000000E+0000
56037: MUL
56038: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
56039: LD_VAR 0 6
56043: PPUSH
56044: CALL_OW 257
56048: PUSH
56049: LD_INT 1
56051: PUSH
56052: LD_INT 2
56054: PUSH
56055: LD_INT 3
56057: PUSH
56058: LD_INT 4
56060: PUSH
56061: EMPTY
56062: LIST
56063: LIST
56064: LIST
56065: LIST
56066: IN
56067: PUSH
56068: LD_VAR 0 1
56072: PPUSH
56073: LD_INT 51
56075: PPUSH
56076: CALL_OW 321
56080: PUSH
56081: LD_INT 2
56083: EQUAL
56084: AND
56085: IFFALSE 56102
// bpoints := bpoints * 1.2 ;
56087: LD_ADDR_VAR 0 10
56091: PUSH
56092: LD_VAR 0 10
56096: PUSH
56097: LD_REAL  1.20000000000000E+0000
56100: MUL
56101: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
56102: LD_VAR 0 6
56106: PPUSH
56107: CALL_OW 257
56111: PUSH
56112: LD_INT 5
56114: PUSH
56115: LD_INT 7
56117: PUSH
56118: LD_INT 9
56120: PUSH
56121: EMPTY
56122: LIST
56123: LIST
56124: LIST
56125: IN
56126: PUSH
56127: LD_VAR 0 1
56131: PPUSH
56132: LD_INT 52
56134: PPUSH
56135: CALL_OW 321
56139: PUSH
56140: LD_INT 2
56142: EQUAL
56143: AND
56144: IFFALSE 56161
// bpoints := bpoints * 1.5 ;
56146: LD_ADDR_VAR 0 10
56150: PUSH
56151: LD_VAR 0 10
56155: PUSH
56156: LD_REAL  1.50000000000000E+0000
56159: MUL
56160: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
56161: LD_VAR 0 1
56165: PPUSH
56166: LD_INT 66
56168: PPUSH
56169: CALL_OW 321
56173: PUSH
56174: LD_INT 2
56176: EQUAL
56177: IFFALSE 56194
// bpoints := bpoints * 1.1 ;
56179: LD_ADDR_VAR 0 10
56183: PUSH
56184: LD_VAR 0 10
56188: PUSH
56189: LD_REAL  1.10000000000000E+0000
56192: MUL
56193: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
56194: LD_ADDR_VAR 0 10
56198: PUSH
56199: LD_VAR 0 10
56203: PUSH
56204: LD_VAR 0 6
56208: PPUSH
56209: LD_INT 1
56211: PPUSH
56212: CALL_OW 259
56216: PUSH
56217: LD_REAL  1.15000000000000E+0000
56220: MUL
56221: MUL
56222: ST_TO_ADDR
// end ; unit_vehicle :
56223: GO 57047
56225: LD_INT 2
56227: DOUBLE
56228: EQUAL
56229: IFTRUE 56233
56231: GO 57035
56233: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
56234: LD_VAR 0 6
56238: PPUSH
56239: CALL_OW 264
56243: PUSH
56244: LD_INT 2
56246: PUSH
56247: LD_INT 42
56249: PUSH
56250: LD_INT 24
56252: PUSH
56253: EMPTY
56254: LIST
56255: LIST
56256: LIST
56257: IN
56258: IFFALSE 56279
// points := [ 25 , 5 , 3 ] ;
56260: LD_ADDR_VAR 0 9
56264: PUSH
56265: LD_INT 25
56267: PUSH
56268: LD_INT 5
56270: PUSH
56271: LD_INT 3
56273: PUSH
56274: EMPTY
56275: LIST
56276: LIST
56277: LIST
56278: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
56279: LD_VAR 0 6
56283: PPUSH
56284: CALL_OW 264
56288: PUSH
56289: LD_INT 4
56291: PUSH
56292: LD_INT 43
56294: PUSH
56295: LD_INT 25
56297: PUSH
56298: EMPTY
56299: LIST
56300: LIST
56301: LIST
56302: IN
56303: IFFALSE 56324
// points := [ 40 , 15 , 5 ] ;
56305: LD_ADDR_VAR 0 9
56309: PUSH
56310: LD_INT 40
56312: PUSH
56313: LD_INT 15
56315: PUSH
56316: LD_INT 5
56318: PUSH
56319: EMPTY
56320: LIST
56321: LIST
56322: LIST
56323: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
56324: LD_VAR 0 6
56328: PPUSH
56329: CALL_OW 264
56333: PUSH
56334: LD_INT 3
56336: PUSH
56337: LD_INT 23
56339: PUSH
56340: EMPTY
56341: LIST
56342: LIST
56343: IN
56344: IFFALSE 56365
// points := [ 7 , 25 , 8 ] ;
56346: LD_ADDR_VAR 0 9
56350: PUSH
56351: LD_INT 7
56353: PUSH
56354: LD_INT 25
56356: PUSH
56357: LD_INT 8
56359: PUSH
56360: EMPTY
56361: LIST
56362: LIST
56363: LIST
56364: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
56365: LD_VAR 0 6
56369: PPUSH
56370: CALL_OW 264
56374: PUSH
56375: LD_INT 5
56377: PUSH
56378: LD_INT 27
56380: PUSH
56381: LD_INT 44
56383: PUSH
56384: EMPTY
56385: LIST
56386: LIST
56387: LIST
56388: IN
56389: IFFALSE 56410
// points := [ 14 , 50 , 16 ] ;
56391: LD_ADDR_VAR 0 9
56395: PUSH
56396: LD_INT 14
56398: PUSH
56399: LD_INT 50
56401: PUSH
56402: LD_INT 16
56404: PUSH
56405: EMPTY
56406: LIST
56407: LIST
56408: LIST
56409: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
56410: LD_VAR 0 6
56414: PPUSH
56415: CALL_OW 264
56419: PUSH
56420: LD_INT 6
56422: PUSH
56423: LD_INT 46
56425: PUSH
56426: EMPTY
56427: LIST
56428: LIST
56429: IN
56430: IFFALSE 56451
// points := [ 32 , 120 , 70 ] ;
56432: LD_ADDR_VAR 0 9
56436: PUSH
56437: LD_INT 32
56439: PUSH
56440: LD_INT 120
56442: PUSH
56443: LD_INT 70
56445: PUSH
56446: EMPTY
56447: LIST
56448: LIST
56449: LIST
56450: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
56451: LD_VAR 0 6
56455: PPUSH
56456: CALL_OW 264
56460: PUSH
56461: LD_INT 7
56463: PUSH
56464: LD_INT 28
56466: PUSH
56467: LD_INT 45
56469: PUSH
56470: EMPTY
56471: LIST
56472: LIST
56473: LIST
56474: IN
56475: IFFALSE 56496
// points := [ 35 , 20 , 45 ] ;
56477: LD_ADDR_VAR 0 9
56481: PUSH
56482: LD_INT 35
56484: PUSH
56485: LD_INT 20
56487: PUSH
56488: LD_INT 45
56490: PUSH
56491: EMPTY
56492: LIST
56493: LIST
56494: LIST
56495: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
56496: LD_VAR 0 6
56500: PPUSH
56501: CALL_OW 264
56505: PUSH
56506: LD_INT 47
56508: PUSH
56509: EMPTY
56510: LIST
56511: IN
56512: IFFALSE 56533
// points := [ 67 , 45 , 75 ] ;
56514: LD_ADDR_VAR 0 9
56518: PUSH
56519: LD_INT 67
56521: PUSH
56522: LD_INT 45
56524: PUSH
56525: LD_INT 75
56527: PUSH
56528: EMPTY
56529: LIST
56530: LIST
56531: LIST
56532: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
56533: LD_VAR 0 6
56537: PPUSH
56538: CALL_OW 264
56542: PUSH
56543: LD_INT 26
56545: PUSH
56546: EMPTY
56547: LIST
56548: IN
56549: IFFALSE 56570
// points := [ 120 , 30 , 80 ] ;
56551: LD_ADDR_VAR 0 9
56555: PUSH
56556: LD_INT 120
56558: PUSH
56559: LD_INT 30
56561: PUSH
56562: LD_INT 80
56564: PUSH
56565: EMPTY
56566: LIST
56567: LIST
56568: LIST
56569: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
56570: LD_VAR 0 6
56574: PPUSH
56575: CALL_OW 264
56579: PUSH
56580: LD_INT 22
56582: PUSH
56583: EMPTY
56584: LIST
56585: IN
56586: IFFALSE 56607
// points := [ 40 , 1 , 1 ] ;
56588: LD_ADDR_VAR 0 9
56592: PUSH
56593: LD_INT 40
56595: PUSH
56596: LD_INT 1
56598: PUSH
56599: LD_INT 1
56601: PUSH
56602: EMPTY
56603: LIST
56604: LIST
56605: LIST
56606: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
56607: LD_VAR 0 6
56611: PPUSH
56612: CALL_OW 264
56616: PUSH
56617: LD_INT 29
56619: PUSH
56620: EMPTY
56621: LIST
56622: IN
56623: IFFALSE 56644
// points := [ 70 , 200 , 400 ] ;
56625: LD_ADDR_VAR 0 9
56629: PUSH
56630: LD_INT 70
56632: PUSH
56633: LD_INT 200
56635: PUSH
56636: LD_INT 400
56638: PUSH
56639: EMPTY
56640: LIST
56641: LIST
56642: LIST
56643: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
56644: LD_VAR 0 6
56648: PPUSH
56649: CALL_OW 264
56653: PUSH
56654: LD_INT 14
56656: PUSH
56657: LD_INT 53
56659: PUSH
56660: EMPTY
56661: LIST
56662: LIST
56663: IN
56664: IFFALSE 56685
// points := [ 40 , 10 , 20 ] ;
56666: LD_ADDR_VAR 0 9
56670: PUSH
56671: LD_INT 40
56673: PUSH
56674: LD_INT 10
56676: PUSH
56677: LD_INT 20
56679: PUSH
56680: EMPTY
56681: LIST
56682: LIST
56683: LIST
56684: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
56685: LD_VAR 0 6
56689: PPUSH
56690: CALL_OW 264
56694: PUSH
56695: LD_INT 9
56697: PUSH
56698: EMPTY
56699: LIST
56700: IN
56701: IFFALSE 56722
// points := [ 5 , 70 , 20 ] ;
56703: LD_ADDR_VAR 0 9
56707: PUSH
56708: LD_INT 5
56710: PUSH
56711: LD_INT 70
56713: PUSH
56714: LD_INT 20
56716: PUSH
56717: EMPTY
56718: LIST
56719: LIST
56720: LIST
56721: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
56722: LD_VAR 0 6
56726: PPUSH
56727: CALL_OW 264
56731: PUSH
56732: LD_INT 10
56734: PUSH
56735: EMPTY
56736: LIST
56737: IN
56738: IFFALSE 56759
// points := [ 35 , 110 , 70 ] ;
56740: LD_ADDR_VAR 0 9
56744: PUSH
56745: LD_INT 35
56747: PUSH
56748: LD_INT 110
56750: PUSH
56751: LD_INT 70
56753: PUSH
56754: EMPTY
56755: LIST
56756: LIST
56757: LIST
56758: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
56759: LD_VAR 0 6
56763: PPUSH
56764: CALL_OW 265
56768: PUSH
56769: LD_INT 25
56771: EQUAL
56772: IFFALSE 56793
// points := [ 80 , 65 , 100 ] ;
56774: LD_ADDR_VAR 0 9
56778: PUSH
56779: LD_INT 80
56781: PUSH
56782: LD_INT 65
56784: PUSH
56785: LD_INT 100
56787: PUSH
56788: EMPTY
56789: LIST
56790: LIST
56791: LIST
56792: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
56793: LD_VAR 0 6
56797: PPUSH
56798: CALL_OW 263
56802: PUSH
56803: LD_INT 1
56805: EQUAL
56806: IFFALSE 56841
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
56808: LD_ADDR_VAR 0 10
56812: PUSH
56813: LD_VAR 0 10
56817: PUSH
56818: LD_VAR 0 6
56822: PPUSH
56823: CALL_OW 311
56827: PPUSH
56828: LD_INT 3
56830: PPUSH
56831: CALL_OW 259
56835: PUSH
56836: LD_INT 4
56838: MUL
56839: MUL
56840: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
56841: LD_VAR 0 6
56845: PPUSH
56846: CALL_OW 263
56850: PUSH
56851: LD_INT 2
56853: EQUAL
56854: IFFALSE 56905
// begin j := IsControledBy ( i ) ;
56856: LD_ADDR_VAR 0 7
56860: PUSH
56861: LD_VAR 0 6
56865: PPUSH
56866: CALL_OW 312
56870: ST_TO_ADDR
// if j then
56871: LD_VAR 0 7
56875: IFFALSE 56905
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
56877: LD_ADDR_VAR 0 10
56881: PUSH
56882: LD_VAR 0 10
56886: PUSH
56887: LD_VAR 0 7
56891: PPUSH
56892: LD_INT 3
56894: PPUSH
56895: CALL_OW 259
56899: PUSH
56900: LD_INT 3
56902: MUL
56903: MUL
56904: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
56905: LD_VAR 0 6
56909: PPUSH
56910: CALL_OW 264
56914: PUSH
56915: LD_INT 5
56917: PUSH
56918: LD_INT 6
56920: PUSH
56921: LD_INT 46
56923: PUSH
56924: LD_INT 44
56926: PUSH
56927: LD_INT 47
56929: PUSH
56930: LD_INT 45
56932: PUSH
56933: LD_INT 28
56935: PUSH
56936: LD_INT 7
56938: PUSH
56939: LD_INT 27
56941: PUSH
56942: LD_INT 29
56944: PUSH
56945: EMPTY
56946: LIST
56947: LIST
56948: LIST
56949: LIST
56950: LIST
56951: LIST
56952: LIST
56953: LIST
56954: LIST
56955: LIST
56956: IN
56957: PUSH
56958: LD_VAR 0 1
56962: PPUSH
56963: LD_INT 52
56965: PPUSH
56966: CALL_OW 321
56970: PUSH
56971: LD_INT 2
56973: EQUAL
56974: AND
56975: IFFALSE 56992
// bpoints := bpoints * 1.2 ;
56977: LD_ADDR_VAR 0 10
56981: PUSH
56982: LD_VAR 0 10
56986: PUSH
56987: LD_REAL  1.20000000000000E+0000
56990: MUL
56991: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
56992: LD_VAR 0 6
56996: PPUSH
56997: CALL_OW 264
57001: PUSH
57002: LD_INT 6
57004: PUSH
57005: LD_INT 46
57007: PUSH
57008: LD_INT 47
57010: PUSH
57011: EMPTY
57012: LIST
57013: LIST
57014: LIST
57015: IN
57016: IFFALSE 57033
// bpoints := bpoints * 1.2 ;
57018: LD_ADDR_VAR 0 10
57022: PUSH
57023: LD_VAR 0 10
57027: PUSH
57028: LD_REAL  1.20000000000000E+0000
57031: MUL
57032: ST_TO_ADDR
// end ; unit_building :
57033: GO 57047
57035: LD_INT 3
57037: DOUBLE
57038: EQUAL
57039: IFTRUE 57043
57041: GO 57046
57043: POP
// ; end ;
57044: GO 57047
57046: POP
// for j = 1 to 3 do
57047: LD_ADDR_VAR 0 7
57051: PUSH
57052: DOUBLE
57053: LD_INT 1
57055: DEC
57056: ST_TO_ADDR
57057: LD_INT 3
57059: PUSH
57060: FOR_TO
57061: IFFALSE 57114
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
57063: LD_ADDR_VAR 0 5
57067: PUSH
57068: LD_VAR 0 5
57072: PPUSH
57073: LD_VAR 0 7
57077: PPUSH
57078: LD_VAR 0 5
57082: PUSH
57083: LD_VAR 0 7
57087: ARRAY
57088: PUSH
57089: LD_VAR 0 9
57093: PUSH
57094: LD_VAR 0 7
57098: ARRAY
57099: PUSH
57100: LD_VAR 0 10
57104: MUL
57105: PLUS
57106: PPUSH
57107: CALL_OW 1
57111: ST_TO_ADDR
57112: GO 57060
57114: POP
57115: POP
// end ;
57116: GO 55599
57118: POP
57119: POP
// result := Replace ( result , 4 , tmp ) ;
57120: LD_ADDR_VAR 0 5
57124: PUSH
57125: LD_VAR 0 5
57129: PPUSH
57130: LD_INT 4
57132: PPUSH
57133: LD_VAR 0 8
57137: PPUSH
57138: CALL_OW 1
57142: ST_TO_ADDR
// end ;
57143: LD_VAR 0 5
57147: RET
// export function DangerAtRange ( unit , range ) ; begin
57148: LD_INT 0
57150: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
57151: LD_ADDR_VAR 0 3
57155: PUSH
57156: LD_VAR 0 1
57160: PPUSH
57161: CALL_OW 255
57165: PPUSH
57166: LD_VAR 0 1
57170: PPUSH
57171: CALL_OW 250
57175: PPUSH
57176: LD_VAR 0 1
57180: PPUSH
57181: CALL_OW 251
57185: PPUSH
57186: LD_VAR 0 2
57190: PPUSH
57191: CALL 55451 0 4
57195: ST_TO_ADDR
// end ;
57196: LD_VAR 0 3
57200: RET
// export function DangerInArea ( side , area ) ; begin
57201: LD_INT 0
57203: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
57204: LD_ADDR_VAR 0 3
57208: PUSH
57209: LD_VAR 0 2
57213: PPUSH
57214: LD_INT 81
57216: PUSH
57217: LD_VAR 0 1
57221: PUSH
57222: EMPTY
57223: LIST
57224: LIST
57225: PPUSH
57226: CALL_OW 70
57230: ST_TO_ADDR
// end ;
57231: LD_VAR 0 3
57235: RET
// export function IsExtension ( b ) ; begin
57236: LD_INT 0
57238: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
57239: LD_ADDR_VAR 0 2
57243: PUSH
57244: LD_VAR 0 1
57248: PUSH
57249: LD_INT 23
57251: PUSH
57252: LD_INT 20
57254: PUSH
57255: LD_INT 22
57257: PUSH
57258: LD_INT 17
57260: PUSH
57261: LD_INT 24
57263: PUSH
57264: LD_INT 21
57266: PUSH
57267: LD_INT 19
57269: PUSH
57270: LD_INT 16
57272: PUSH
57273: LD_INT 25
57275: PUSH
57276: LD_INT 18
57278: PUSH
57279: EMPTY
57280: LIST
57281: LIST
57282: LIST
57283: LIST
57284: LIST
57285: LIST
57286: LIST
57287: LIST
57288: LIST
57289: LIST
57290: IN
57291: ST_TO_ADDR
// end ;
57292: LD_VAR 0 2
57296: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
57297: LD_INT 0
57299: PPUSH
57300: PPUSH
57301: PPUSH
// result := [ ] ;
57302: LD_ADDR_VAR 0 3
57306: PUSH
57307: EMPTY
57308: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
57309: LD_ADDR_VAR 0 4
57313: PUSH
57314: LD_VAR 0 2
57318: PPUSH
57319: LD_INT 21
57321: PUSH
57322: LD_INT 3
57324: PUSH
57325: EMPTY
57326: LIST
57327: LIST
57328: PPUSH
57329: CALL_OW 70
57333: ST_TO_ADDR
// if not tmp then
57334: LD_VAR 0 4
57338: NOT
57339: IFFALSE 57343
// exit ;
57341: GO 57401
// for i in tmp do
57343: LD_ADDR_VAR 0 5
57347: PUSH
57348: LD_VAR 0 4
57352: PUSH
57353: FOR_IN
57354: IFFALSE 57389
// if GetBase ( i ) <> base then
57356: LD_VAR 0 5
57360: PPUSH
57361: CALL_OW 274
57365: PUSH
57366: LD_VAR 0 1
57370: NONEQUAL
57371: IFFALSE 57387
// ComLinkToBase ( base , i ) ;
57373: LD_VAR 0 1
57377: PPUSH
57378: LD_VAR 0 5
57382: PPUSH
57383: CALL_OW 169
57387: GO 57353
57389: POP
57390: POP
// result := tmp ;
57391: LD_ADDR_VAR 0 3
57395: PUSH
57396: LD_VAR 0 4
57400: ST_TO_ADDR
// end ;
57401: LD_VAR 0 3
57405: RET
// export function ComComplete ( unit , b ) ; var i ; begin
57406: LD_INT 0
57408: PPUSH
57409: PPUSH
// if BuildingStatus ( b ) = bs_build then
57410: LD_VAR 0 2
57414: PPUSH
57415: CALL_OW 461
57419: PUSH
57420: LD_INT 1
57422: EQUAL
57423: IFFALSE 57483
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
57425: LD_VAR 0 1
57429: PPUSH
57430: LD_STRING h
57432: PUSH
57433: LD_VAR 0 2
57437: PPUSH
57438: CALL_OW 250
57442: PUSH
57443: LD_VAR 0 2
57447: PPUSH
57448: CALL_OW 251
57452: PUSH
57453: LD_VAR 0 2
57457: PUSH
57458: LD_INT 0
57460: PUSH
57461: LD_INT 0
57463: PUSH
57464: LD_INT 0
57466: PUSH
57467: EMPTY
57468: LIST
57469: LIST
57470: LIST
57471: LIST
57472: LIST
57473: LIST
57474: LIST
57475: PUSH
57476: EMPTY
57477: LIST
57478: PPUSH
57479: CALL_OW 446
// end ;
57483: LD_VAR 0 3
57487: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
57488: LD_INT 0
57490: PPUSH
57491: PPUSH
57492: PPUSH
57493: PPUSH
57494: PPUSH
57495: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
57496: LD_VAR 0 1
57500: NOT
57501: PUSH
57502: LD_VAR 0 1
57506: PPUSH
57507: CALL_OW 263
57511: PUSH
57512: LD_INT 2
57514: EQUAL
57515: NOT
57516: OR
57517: IFFALSE 57521
// exit ;
57519: GO 57837
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
57521: LD_ADDR_VAR 0 6
57525: PUSH
57526: LD_INT 22
57528: PUSH
57529: LD_VAR 0 1
57533: PPUSH
57534: CALL_OW 255
57538: PUSH
57539: EMPTY
57540: LIST
57541: LIST
57542: PUSH
57543: LD_INT 2
57545: PUSH
57546: LD_INT 30
57548: PUSH
57549: LD_INT 36
57551: PUSH
57552: EMPTY
57553: LIST
57554: LIST
57555: PUSH
57556: LD_INT 34
57558: PUSH
57559: LD_INT 31
57561: PUSH
57562: EMPTY
57563: LIST
57564: LIST
57565: PUSH
57566: EMPTY
57567: LIST
57568: LIST
57569: LIST
57570: PUSH
57571: EMPTY
57572: LIST
57573: LIST
57574: PPUSH
57575: CALL_OW 69
57579: ST_TO_ADDR
// if not tmp then
57580: LD_VAR 0 6
57584: NOT
57585: IFFALSE 57589
// exit ;
57587: GO 57837
// result := [ ] ;
57589: LD_ADDR_VAR 0 2
57593: PUSH
57594: EMPTY
57595: ST_TO_ADDR
// for i in tmp do
57596: LD_ADDR_VAR 0 3
57600: PUSH
57601: LD_VAR 0 6
57605: PUSH
57606: FOR_IN
57607: IFFALSE 57678
// begin t := UnitsInside ( i ) ;
57609: LD_ADDR_VAR 0 4
57613: PUSH
57614: LD_VAR 0 3
57618: PPUSH
57619: CALL_OW 313
57623: ST_TO_ADDR
// if t then
57624: LD_VAR 0 4
57628: IFFALSE 57676
// for j in t do
57630: LD_ADDR_VAR 0 7
57634: PUSH
57635: LD_VAR 0 4
57639: PUSH
57640: FOR_IN
57641: IFFALSE 57674
// result := Insert ( result , result + 1 , j ) ;
57643: LD_ADDR_VAR 0 2
57647: PUSH
57648: LD_VAR 0 2
57652: PPUSH
57653: LD_VAR 0 2
57657: PUSH
57658: LD_INT 1
57660: PLUS
57661: PPUSH
57662: LD_VAR 0 7
57666: PPUSH
57667: CALL_OW 2
57671: ST_TO_ADDR
57672: GO 57640
57674: POP
57675: POP
// end ;
57676: GO 57606
57678: POP
57679: POP
// if not result then
57680: LD_VAR 0 2
57684: NOT
57685: IFFALSE 57689
// exit ;
57687: GO 57837
// mech := result [ 1 ] ;
57689: LD_ADDR_VAR 0 5
57693: PUSH
57694: LD_VAR 0 2
57698: PUSH
57699: LD_INT 1
57701: ARRAY
57702: ST_TO_ADDR
// if result > 1 then
57703: LD_VAR 0 2
57707: PUSH
57708: LD_INT 1
57710: GREATER
57711: IFFALSE 57823
// for i = 2 to result do
57713: LD_ADDR_VAR 0 3
57717: PUSH
57718: DOUBLE
57719: LD_INT 2
57721: DEC
57722: ST_TO_ADDR
57723: LD_VAR 0 2
57727: PUSH
57728: FOR_TO
57729: IFFALSE 57821
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
57731: LD_ADDR_VAR 0 4
57735: PUSH
57736: LD_VAR 0 2
57740: PUSH
57741: LD_VAR 0 3
57745: ARRAY
57746: PPUSH
57747: LD_INT 3
57749: PPUSH
57750: CALL_OW 259
57754: PUSH
57755: LD_VAR 0 2
57759: PUSH
57760: LD_VAR 0 3
57764: ARRAY
57765: PPUSH
57766: CALL_OW 432
57770: MINUS
57771: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
57772: LD_VAR 0 4
57776: PUSH
57777: LD_VAR 0 5
57781: PPUSH
57782: LD_INT 3
57784: PPUSH
57785: CALL_OW 259
57789: PUSH
57790: LD_VAR 0 5
57794: PPUSH
57795: CALL_OW 432
57799: MINUS
57800: GREATEREQUAL
57801: IFFALSE 57819
// mech := result [ i ] ;
57803: LD_ADDR_VAR 0 5
57807: PUSH
57808: LD_VAR 0 2
57812: PUSH
57813: LD_VAR 0 3
57817: ARRAY
57818: ST_TO_ADDR
// end ;
57819: GO 57728
57821: POP
57822: POP
// ComLinkTo ( vehicle , mech ) ;
57823: LD_VAR 0 1
57827: PPUSH
57828: LD_VAR 0 5
57832: PPUSH
57833: CALL_OW 135
// end ;
57837: LD_VAR 0 2
57841: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
57842: LD_INT 0
57844: PPUSH
57845: PPUSH
57846: PPUSH
57847: PPUSH
57848: PPUSH
57849: PPUSH
57850: PPUSH
57851: PPUSH
57852: PPUSH
57853: PPUSH
57854: PPUSH
57855: PPUSH
57856: PPUSH
// result := [ ] ;
57857: LD_ADDR_VAR 0 7
57861: PUSH
57862: EMPTY
57863: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
57864: LD_VAR 0 1
57868: PPUSH
57869: CALL_OW 266
57873: PUSH
57874: LD_INT 0
57876: PUSH
57877: LD_INT 1
57879: PUSH
57880: EMPTY
57881: LIST
57882: LIST
57883: IN
57884: NOT
57885: IFFALSE 57889
// exit ;
57887: GO 59520
// if name then
57889: LD_VAR 0 3
57893: IFFALSE 57909
// SetBName ( base_dep , name ) ;
57895: LD_VAR 0 1
57899: PPUSH
57900: LD_VAR 0 3
57904: PPUSH
57905: CALL_OW 500
// base := GetBase ( base_dep ) ;
57909: LD_ADDR_VAR 0 15
57913: PUSH
57914: LD_VAR 0 1
57918: PPUSH
57919: CALL_OW 274
57923: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
57924: LD_ADDR_VAR 0 16
57928: PUSH
57929: LD_VAR 0 1
57933: PPUSH
57934: CALL_OW 255
57938: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
57939: LD_ADDR_VAR 0 17
57943: PUSH
57944: LD_VAR 0 1
57948: PPUSH
57949: CALL_OW 248
57953: ST_TO_ADDR
// if sources then
57954: LD_VAR 0 5
57958: IFFALSE 58005
// for i = 1 to 3 do
57960: LD_ADDR_VAR 0 8
57964: PUSH
57965: DOUBLE
57966: LD_INT 1
57968: DEC
57969: ST_TO_ADDR
57970: LD_INT 3
57972: PUSH
57973: FOR_TO
57974: IFFALSE 58003
// AddResourceType ( base , i , sources [ i ] ) ;
57976: LD_VAR 0 15
57980: PPUSH
57981: LD_VAR 0 8
57985: PPUSH
57986: LD_VAR 0 5
57990: PUSH
57991: LD_VAR 0 8
57995: ARRAY
57996: PPUSH
57997: CALL_OW 276
58001: GO 57973
58003: POP
58004: POP
// buildings := GetBaseBuildings ( base , area ) ;
58005: LD_ADDR_VAR 0 18
58009: PUSH
58010: LD_VAR 0 15
58014: PPUSH
58015: LD_VAR 0 2
58019: PPUSH
58020: CALL 57297 0 2
58024: ST_TO_ADDR
// InitHc ;
58025: CALL_OW 19
// InitUc ;
58029: CALL_OW 18
// uc_side := side ;
58033: LD_ADDR_OWVAR 20
58037: PUSH
58038: LD_VAR 0 16
58042: ST_TO_ADDR
// uc_nation := nation ;
58043: LD_ADDR_OWVAR 21
58047: PUSH
58048: LD_VAR 0 17
58052: ST_TO_ADDR
// if buildings then
58053: LD_VAR 0 18
58057: IFFALSE 59379
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
58059: LD_ADDR_VAR 0 19
58063: PUSH
58064: LD_VAR 0 18
58068: PPUSH
58069: LD_INT 2
58071: PUSH
58072: LD_INT 30
58074: PUSH
58075: LD_INT 29
58077: PUSH
58078: EMPTY
58079: LIST
58080: LIST
58081: PUSH
58082: LD_INT 30
58084: PUSH
58085: LD_INT 30
58087: PUSH
58088: EMPTY
58089: LIST
58090: LIST
58091: PUSH
58092: EMPTY
58093: LIST
58094: LIST
58095: LIST
58096: PPUSH
58097: CALL_OW 72
58101: ST_TO_ADDR
// if tmp then
58102: LD_VAR 0 19
58106: IFFALSE 58154
// for i in tmp do
58108: LD_ADDR_VAR 0 8
58112: PUSH
58113: LD_VAR 0 19
58117: PUSH
58118: FOR_IN
58119: IFFALSE 58152
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
58121: LD_VAR 0 8
58125: PPUSH
58126: CALL_OW 250
58130: PPUSH
58131: LD_VAR 0 8
58135: PPUSH
58136: CALL_OW 251
58140: PPUSH
58141: LD_VAR 0 16
58145: PPUSH
58146: CALL_OW 441
58150: GO 58118
58152: POP
58153: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
58154: LD_VAR 0 18
58158: PPUSH
58159: LD_INT 2
58161: PUSH
58162: LD_INT 30
58164: PUSH
58165: LD_INT 32
58167: PUSH
58168: EMPTY
58169: LIST
58170: LIST
58171: PUSH
58172: LD_INT 30
58174: PUSH
58175: LD_INT 33
58177: PUSH
58178: EMPTY
58179: LIST
58180: LIST
58181: PUSH
58182: EMPTY
58183: LIST
58184: LIST
58185: LIST
58186: PPUSH
58187: CALL_OW 72
58191: IFFALSE 58279
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
58193: LD_ADDR_VAR 0 8
58197: PUSH
58198: LD_VAR 0 18
58202: PPUSH
58203: LD_INT 2
58205: PUSH
58206: LD_INT 30
58208: PUSH
58209: LD_INT 32
58211: PUSH
58212: EMPTY
58213: LIST
58214: LIST
58215: PUSH
58216: LD_INT 30
58218: PUSH
58219: LD_INT 33
58221: PUSH
58222: EMPTY
58223: LIST
58224: LIST
58225: PUSH
58226: EMPTY
58227: LIST
58228: LIST
58229: LIST
58230: PPUSH
58231: CALL_OW 72
58235: PUSH
58236: FOR_IN
58237: IFFALSE 58277
// begin if not GetBWeapon ( i ) then
58239: LD_VAR 0 8
58243: PPUSH
58244: CALL_OW 269
58248: NOT
58249: IFFALSE 58275
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
58251: LD_VAR 0 8
58255: PPUSH
58256: LD_VAR 0 8
58260: PPUSH
58261: LD_VAR 0 2
58265: PPUSH
58266: CALL 59525 0 2
58270: PPUSH
58271: CALL_OW 431
// end ;
58275: GO 58236
58277: POP
58278: POP
// end ; for i = 1 to personel do
58279: LD_ADDR_VAR 0 8
58283: PUSH
58284: DOUBLE
58285: LD_INT 1
58287: DEC
58288: ST_TO_ADDR
58289: LD_VAR 0 6
58293: PUSH
58294: FOR_TO
58295: IFFALSE 59359
// begin if i > 4 then
58297: LD_VAR 0 8
58301: PUSH
58302: LD_INT 4
58304: GREATER
58305: IFFALSE 58309
// break ;
58307: GO 59359
// case i of 1 :
58309: LD_VAR 0 8
58313: PUSH
58314: LD_INT 1
58316: DOUBLE
58317: EQUAL
58318: IFTRUE 58322
58320: GO 58402
58322: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
58323: LD_ADDR_VAR 0 12
58327: PUSH
58328: LD_VAR 0 18
58332: PPUSH
58333: LD_INT 22
58335: PUSH
58336: LD_VAR 0 16
58340: PUSH
58341: EMPTY
58342: LIST
58343: LIST
58344: PUSH
58345: LD_INT 58
58347: PUSH
58348: EMPTY
58349: LIST
58350: PUSH
58351: LD_INT 2
58353: PUSH
58354: LD_INT 30
58356: PUSH
58357: LD_INT 32
58359: PUSH
58360: EMPTY
58361: LIST
58362: LIST
58363: PUSH
58364: LD_INT 30
58366: PUSH
58367: LD_INT 4
58369: PUSH
58370: EMPTY
58371: LIST
58372: LIST
58373: PUSH
58374: LD_INT 30
58376: PUSH
58377: LD_INT 5
58379: PUSH
58380: EMPTY
58381: LIST
58382: LIST
58383: PUSH
58384: EMPTY
58385: LIST
58386: LIST
58387: LIST
58388: LIST
58389: PUSH
58390: EMPTY
58391: LIST
58392: LIST
58393: LIST
58394: PPUSH
58395: CALL_OW 72
58399: ST_TO_ADDR
58400: GO 58624
58402: LD_INT 2
58404: DOUBLE
58405: EQUAL
58406: IFTRUE 58410
58408: GO 58472
58410: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
58411: LD_ADDR_VAR 0 12
58415: PUSH
58416: LD_VAR 0 18
58420: PPUSH
58421: LD_INT 22
58423: PUSH
58424: LD_VAR 0 16
58428: PUSH
58429: EMPTY
58430: LIST
58431: LIST
58432: PUSH
58433: LD_INT 2
58435: PUSH
58436: LD_INT 30
58438: PUSH
58439: LD_INT 0
58441: PUSH
58442: EMPTY
58443: LIST
58444: LIST
58445: PUSH
58446: LD_INT 30
58448: PUSH
58449: LD_INT 1
58451: PUSH
58452: EMPTY
58453: LIST
58454: LIST
58455: PUSH
58456: EMPTY
58457: LIST
58458: LIST
58459: LIST
58460: PUSH
58461: EMPTY
58462: LIST
58463: LIST
58464: PPUSH
58465: CALL_OW 72
58469: ST_TO_ADDR
58470: GO 58624
58472: LD_INT 3
58474: DOUBLE
58475: EQUAL
58476: IFTRUE 58480
58478: GO 58542
58480: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
58481: LD_ADDR_VAR 0 12
58485: PUSH
58486: LD_VAR 0 18
58490: PPUSH
58491: LD_INT 22
58493: PUSH
58494: LD_VAR 0 16
58498: PUSH
58499: EMPTY
58500: LIST
58501: LIST
58502: PUSH
58503: LD_INT 2
58505: PUSH
58506: LD_INT 30
58508: PUSH
58509: LD_INT 2
58511: PUSH
58512: EMPTY
58513: LIST
58514: LIST
58515: PUSH
58516: LD_INT 30
58518: PUSH
58519: LD_INT 3
58521: PUSH
58522: EMPTY
58523: LIST
58524: LIST
58525: PUSH
58526: EMPTY
58527: LIST
58528: LIST
58529: LIST
58530: PUSH
58531: EMPTY
58532: LIST
58533: LIST
58534: PPUSH
58535: CALL_OW 72
58539: ST_TO_ADDR
58540: GO 58624
58542: LD_INT 4
58544: DOUBLE
58545: EQUAL
58546: IFTRUE 58550
58548: GO 58623
58550: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
58551: LD_ADDR_VAR 0 12
58555: PUSH
58556: LD_VAR 0 18
58560: PPUSH
58561: LD_INT 22
58563: PUSH
58564: LD_VAR 0 16
58568: PUSH
58569: EMPTY
58570: LIST
58571: LIST
58572: PUSH
58573: LD_INT 2
58575: PUSH
58576: LD_INT 30
58578: PUSH
58579: LD_INT 6
58581: PUSH
58582: EMPTY
58583: LIST
58584: LIST
58585: PUSH
58586: LD_INT 30
58588: PUSH
58589: LD_INT 7
58591: PUSH
58592: EMPTY
58593: LIST
58594: LIST
58595: PUSH
58596: LD_INT 30
58598: PUSH
58599: LD_INT 8
58601: PUSH
58602: EMPTY
58603: LIST
58604: LIST
58605: PUSH
58606: EMPTY
58607: LIST
58608: LIST
58609: LIST
58610: LIST
58611: PUSH
58612: EMPTY
58613: LIST
58614: LIST
58615: PPUSH
58616: CALL_OW 72
58620: ST_TO_ADDR
58621: GO 58624
58623: POP
// if i = 1 then
58624: LD_VAR 0 8
58628: PUSH
58629: LD_INT 1
58631: EQUAL
58632: IFFALSE 58743
// begin tmp := [ ] ;
58634: LD_ADDR_VAR 0 19
58638: PUSH
58639: EMPTY
58640: ST_TO_ADDR
// for j in f do
58641: LD_ADDR_VAR 0 9
58645: PUSH
58646: LD_VAR 0 12
58650: PUSH
58651: FOR_IN
58652: IFFALSE 58725
// if GetBType ( j ) = b_bunker then
58654: LD_VAR 0 9
58658: PPUSH
58659: CALL_OW 266
58663: PUSH
58664: LD_INT 32
58666: EQUAL
58667: IFFALSE 58694
// tmp := Insert ( tmp , 1 , j ) else
58669: LD_ADDR_VAR 0 19
58673: PUSH
58674: LD_VAR 0 19
58678: PPUSH
58679: LD_INT 1
58681: PPUSH
58682: LD_VAR 0 9
58686: PPUSH
58687: CALL_OW 2
58691: ST_TO_ADDR
58692: GO 58723
// tmp := Insert ( tmp , tmp + 1 , j ) ;
58694: LD_ADDR_VAR 0 19
58698: PUSH
58699: LD_VAR 0 19
58703: PPUSH
58704: LD_VAR 0 19
58708: PUSH
58709: LD_INT 1
58711: PLUS
58712: PPUSH
58713: LD_VAR 0 9
58717: PPUSH
58718: CALL_OW 2
58722: ST_TO_ADDR
58723: GO 58651
58725: POP
58726: POP
// if tmp then
58727: LD_VAR 0 19
58731: IFFALSE 58743
// f := tmp ;
58733: LD_ADDR_VAR 0 12
58737: PUSH
58738: LD_VAR 0 19
58742: ST_TO_ADDR
// end ; x := personel [ i ] ;
58743: LD_ADDR_VAR 0 13
58747: PUSH
58748: LD_VAR 0 6
58752: PUSH
58753: LD_VAR 0 8
58757: ARRAY
58758: ST_TO_ADDR
// if x = - 1 then
58759: LD_VAR 0 13
58763: PUSH
58764: LD_INT 1
58766: NEG
58767: EQUAL
58768: IFFALSE 58977
// begin for j in f do
58770: LD_ADDR_VAR 0 9
58774: PUSH
58775: LD_VAR 0 12
58779: PUSH
58780: FOR_IN
58781: IFFALSE 58973
// repeat InitHc ;
58783: CALL_OW 19
// if GetBType ( j ) = b_barracks then
58787: LD_VAR 0 9
58791: PPUSH
58792: CALL_OW 266
58796: PUSH
58797: LD_INT 5
58799: EQUAL
58800: IFFALSE 58870
// begin if UnitsInside ( j ) < 3 then
58802: LD_VAR 0 9
58806: PPUSH
58807: CALL_OW 313
58811: PUSH
58812: LD_INT 3
58814: LESS
58815: IFFALSE 58851
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
58817: LD_INT 0
58819: PPUSH
58820: LD_INT 5
58822: PUSH
58823: LD_INT 8
58825: PUSH
58826: LD_INT 9
58828: PUSH
58829: EMPTY
58830: LIST
58831: LIST
58832: LIST
58833: PUSH
58834: LD_VAR 0 17
58838: ARRAY
58839: PPUSH
58840: LD_VAR 0 4
58844: PPUSH
58845: CALL_OW 380
58849: GO 58868
// PrepareHuman ( false , i , skill ) ;
58851: LD_INT 0
58853: PPUSH
58854: LD_VAR 0 8
58858: PPUSH
58859: LD_VAR 0 4
58863: PPUSH
58864: CALL_OW 380
// end else
58868: GO 58887
// PrepareHuman ( false , i , skill ) ;
58870: LD_INT 0
58872: PPUSH
58873: LD_VAR 0 8
58877: PPUSH
58878: LD_VAR 0 4
58882: PPUSH
58883: CALL_OW 380
// un := CreateHuman ;
58887: LD_ADDR_VAR 0 14
58891: PUSH
58892: CALL_OW 44
58896: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58897: LD_ADDR_VAR 0 7
58901: PUSH
58902: LD_VAR 0 7
58906: PPUSH
58907: LD_INT 1
58909: PPUSH
58910: LD_VAR 0 14
58914: PPUSH
58915: CALL_OW 2
58919: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
58920: LD_VAR 0 14
58924: PPUSH
58925: LD_VAR 0 9
58929: PPUSH
58930: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
58934: LD_VAR 0 9
58938: PPUSH
58939: CALL_OW 313
58943: PUSH
58944: LD_INT 6
58946: EQUAL
58947: PUSH
58948: LD_VAR 0 9
58952: PPUSH
58953: CALL_OW 266
58957: PUSH
58958: LD_INT 32
58960: PUSH
58961: LD_INT 31
58963: PUSH
58964: EMPTY
58965: LIST
58966: LIST
58967: IN
58968: OR
58969: IFFALSE 58783
58971: GO 58780
58973: POP
58974: POP
// end else
58975: GO 59357
// for j = 1 to x do
58977: LD_ADDR_VAR 0 9
58981: PUSH
58982: DOUBLE
58983: LD_INT 1
58985: DEC
58986: ST_TO_ADDR
58987: LD_VAR 0 13
58991: PUSH
58992: FOR_TO
58993: IFFALSE 59355
// begin InitHc ;
58995: CALL_OW 19
// if not f then
58999: LD_VAR 0 12
59003: NOT
59004: IFFALSE 59093
// begin PrepareHuman ( false , i , skill ) ;
59006: LD_INT 0
59008: PPUSH
59009: LD_VAR 0 8
59013: PPUSH
59014: LD_VAR 0 4
59018: PPUSH
59019: CALL_OW 380
// un := CreateHuman ;
59023: LD_ADDR_VAR 0 14
59027: PUSH
59028: CALL_OW 44
59032: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
59033: LD_ADDR_VAR 0 7
59037: PUSH
59038: LD_VAR 0 7
59042: PPUSH
59043: LD_INT 1
59045: PPUSH
59046: LD_VAR 0 14
59050: PPUSH
59051: CALL_OW 2
59055: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
59056: LD_VAR 0 14
59060: PPUSH
59061: LD_VAR 0 1
59065: PPUSH
59066: CALL_OW 250
59070: PPUSH
59071: LD_VAR 0 1
59075: PPUSH
59076: CALL_OW 251
59080: PPUSH
59081: LD_INT 10
59083: PPUSH
59084: LD_INT 0
59086: PPUSH
59087: CALL_OW 50
// continue ;
59091: GO 58992
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
59093: LD_VAR 0 12
59097: PUSH
59098: LD_INT 1
59100: ARRAY
59101: PPUSH
59102: CALL_OW 313
59106: PUSH
59107: LD_VAR 0 12
59111: PUSH
59112: LD_INT 1
59114: ARRAY
59115: PPUSH
59116: CALL_OW 266
59120: PUSH
59121: LD_INT 32
59123: PUSH
59124: LD_INT 31
59126: PUSH
59127: EMPTY
59128: LIST
59129: LIST
59130: IN
59131: AND
59132: PUSH
59133: LD_VAR 0 12
59137: PUSH
59138: LD_INT 1
59140: ARRAY
59141: PPUSH
59142: CALL_OW 313
59146: PUSH
59147: LD_INT 6
59149: EQUAL
59150: OR
59151: IFFALSE 59171
// f := Delete ( f , 1 ) ;
59153: LD_ADDR_VAR 0 12
59157: PUSH
59158: LD_VAR 0 12
59162: PPUSH
59163: LD_INT 1
59165: PPUSH
59166: CALL_OW 3
59170: ST_TO_ADDR
// if not f then
59171: LD_VAR 0 12
59175: NOT
59176: IFFALSE 59194
// begin x := x + 2 ;
59178: LD_ADDR_VAR 0 13
59182: PUSH
59183: LD_VAR 0 13
59187: PUSH
59188: LD_INT 2
59190: PLUS
59191: ST_TO_ADDR
// continue ;
59192: GO 58992
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
59194: LD_VAR 0 12
59198: PUSH
59199: LD_INT 1
59201: ARRAY
59202: PPUSH
59203: CALL_OW 266
59207: PUSH
59208: LD_INT 5
59210: EQUAL
59211: IFFALSE 59285
// begin if UnitsInside ( f [ 1 ] ) < 3 then
59213: LD_VAR 0 12
59217: PUSH
59218: LD_INT 1
59220: ARRAY
59221: PPUSH
59222: CALL_OW 313
59226: PUSH
59227: LD_INT 3
59229: LESS
59230: IFFALSE 59266
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
59232: LD_INT 0
59234: PPUSH
59235: LD_INT 5
59237: PUSH
59238: LD_INT 8
59240: PUSH
59241: LD_INT 9
59243: PUSH
59244: EMPTY
59245: LIST
59246: LIST
59247: LIST
59248: PUSH
59249: LD_VAR 0 17
59253: ARRAY
59254: PPUSH
59255: LD_VAR 0 4
59259: PPUSH
59260: CALL_OW 380
59264: GO 59283
// PrepareHuman ( false , i , skill ) ;
59266: LD_INT 0
59268: PPUSH
59269: LD_VAR 0 8
59273: PPUSH
59274: LD_VAR 0 4
59278: PPUSH
59279: CALL_OW 380
// end else
59283: GO 59302
// PrepareHuman ( false , i , skill ) ;
59285: LD_INT 0
59287: PPUSH
59288: LD_VAR 0 8
59292: PPUSH
59293: LD_VAR 0 4
59297: PPUSH
59298: CALL_OW 380
// un := CreateHuman ;
59302: LD_ADDR_VAR 0 14
59306: PUSH
59307: CALL_OW 44
59311: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
59312: LD_ADDR_VAR 0 7
59316: PUSH
59317: LD_VAR 0 7
59321: PPUSH
59322: LD_INT 1
59324: PPUSH
59325: LD_VAR 0 14
59329: PPUSH
59330: CALL_OW 2
59334: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
59335: LD_VAR 0 14
59339: PPUSH
59340: LD_VAR 0 12
59344: PUSH
59345: LD_INT 1
59347: ARRAY
59348: PPUSH
59349: CALL_OW 52
// end ;
59353: GO 58992
59355: POP
59356: POP
// end ;
59357: GO 58294
59359: POP
59360: POP
// result := result ^ buildings ;
59361: LD_ADDR_VAR 0 7
59365: PUSH
59366: LD_VAR 0 7
59370: PUSH
59371: LD_VAR 0 18
59375: ADD
59376: ST_TO_ADDR
// end else
59377: GO 59520
// begin for i = 1 to personel do
59379: LD_ADDR_VAR 0 8
59383: PUSH
59384: DOUBLE
59385: LD_INT 1
59387: DEC
59388: ST_TO_ADDR
59389: LD_VAR 0 6
59393: PUSH
59394: FOR_TO
59395: IFFALSE 59518
// begin if i > 4 then
59397: LD_VAR 0 8
59401: PUSH
59402: LD_INT 4
59404: GREATER
59405: IFFALSE 59409
// break ;
59407: GO 59518
// x := personel [ i ] ;
59409: LD_ADDR_VAR 0 13
59413: PUSH
59414: LD_VAR 0 6
59418: PUSH
59419: LD_VAR 0 8
59423: ARRAY
59424: ST_TO_ADDR
// if x = - 1 then
59425: LD_VAR 0 13
59429: PUSH
59430: LD_INT 1
59432: NEG
59433: EQUAL
59434: IFFALSE 59438
// continue ;
59436: GO 59394
// PrepareHuman ( false , i , skill ) ;
59438: LD_INT 0
59440: PPUSH
59441: LD_VAR 0 8
59445: PPUSH
59446: LD_VAR 0 4
59450: PPUSH
59451: CALL_OW 380
// un := CreateHuman ;
59455: LD_ADDR_VAR 0 14
59459: PUSH
59460: CALL_OW 44
59464: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
59465: LD_VAR 0 14
59469: PPUSH
59470: LD_VAR 0 1
59474: PPUSH
59475: CALL_OW 250
59479: PPUSH
59480: LD_VAR 0 1
59484: PPUSH
59485: CALL_OW 251
59489: PPUSH
59490: LD_INT 10
59492: PPUSH
59493: LD_INT 0
59495: PPUSH
59496: CALL_OW 50
// result := result ^ un ;
59500: LD_ADDR_VAR 0 7
59504: PUSH
59505: LD_VAR 0 7
59509: PUSH
59510: LD_VAR 0 14
59514: ADD
59515: ST_TO_ADDR
// end ;
59516: GO 59394
59518: POP
59519: POP
// end ; end ;
59520: LD_VAR 0 7
59524: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
59525: LD_INT 0
59527: PPUSH
59528: PPUSH
59529: PPUSH
59530: PPUSH
59531: PPUSH
59532: PPUSH
59533: PPUSH
59534: PPUSH
59535: PPUSH
59536: PPUSH
59537: PPUSH
59538: PPUSH
59539: PPUSH
59540: PPUSH
59541: PPUSH
59542: PPUSH
// result := false ;
59543: LD_ADDR_VAR 0 3
59547: PUSH
59548: LD_INT 0
59550: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
59551: LD_VAR 0 1
59555: NOT
59556: PUSH
59557: LD_VAR 0 1
59561: PPUSH
59562: CALL_OW 266
59566: PUSH
59567: LD_INT 32
59569: PUSH
59570: LD_INT 33
59572: PUSH
59573: EMPTY
59574: LIST
59575: LIST
59576: IN
59577: NOT
59578: OR
59579: IFFALSE 59583
// exit ;
59581: GO 60719
// nat := GetNation ( tower ) ;
59583: LD_ADDR_VAR 0 12
59587: PUSH
59588: LD_VAR 0 1
59592: PPUSH
59593: CALL_OW 248
59597: ST_TO_ADDR
// side := GetSide ( tower ) ;
59598: LD_ADDR_VAR 0 16
59602: PUSH
59603: LD_VAR 0 1
59607: PPUSH
59608: CALL_OW 255
59612: ST_TO_ADDR
// x := GetX ( tower ) ;
59613: LD_ADDR_VAR 0 10
59617: PUSH
59618: LD_VAR 0 1
59622: PPUSH
59623: CALL_OW 250
59627: ST_TO_ADDR
// y := GetY ( tower ) ;
59628: LD_ADDR_VAR 0 11
59632: PUSH
59633: LD_VAR 0 1
59637: PPUSH
59638: CALL_OW 251
59642: ST_TO_ADDR
// if not x or not y then
59643: LD_VAR 0 10
59647: NOT
59648: PUSH
59649: LD_VAR 0 11
59653: NOT
59654: OR
59655: IFFALSE 59659
// exit ;
59657: GO 60719
// weapon := 0 ;
59659: LD_ADDR_VAR 0 18
59663: PUSH
59664: LD_INT 0
59666: ST_TO_ADDR
// fac_list := [ ] ;
59667: LD_ADDR_VAR 0 17
59671: PUSH
59672: EMPTY
59673: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
59674: LD_ADDR_VAR 0 6
59678: PUSH
59679: LD_VAR 0 1
59683: PPUSH
59684: CALL_OW 274
59688: PPUSH
59689: LD_VAR 0 2
59693: PPUSH
59694: CALL 57297 0 2
59698: PPUSH
59699: LD_INT 30
59701: PUSH
59702: LD_INT 3
59704: PUSH
59705: EMPTY
59706: LIST
59707: LIST
59708: PPUSH
59709: CALL_OW 72
59713: ST_TO_ADDR
// if not factories then
59714: LD_VAR 0 6
59718: NOT
59719: IFFALSE 59723
// exit ;
59721: GO 60719
// for i in factories do
59723: LD_ADDR_VAR 0 8
59727: PUSH
59728: LD_VAR 0 6
59732: PUSH
59733: FOR_IN
59734: IFFALSE 59759
// fac_list := fac_list union AvailableWeaponList ( i ) ;
59736: LD_ADDR_VAR 0 17
59740: PUSH
59741: LD_VAR 0 17
59745: PUSH
59746: LD_VAR 0 8
59750: PPUSH
59751: CALL_OW 478
59755: UNION
59756: ST_TO_ADDR
59757: GO 59733
59759: POP
59760: POP
// if not fac_list then
59761: LD_VAR 0 17
59765: NOT
59766: IFFALSE 59770
// exit ;
59768: GO 60719
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
59770: LD_ADDR_VAR 0 5
59774: PUSH
59775: LD_INT 4
59777: PUSH
59778: LD_INT 5
59780: PUSH
59781: LD_INT 9
59783: PUSH
59784: LD_INT 10
59786: PUSH
59787: LD_INT 6
59789: PUSH
59790: LD_INT 7
59792: PUSH
59793: LD_INT 11
59795: PUSH
59796: EMPTY
59797: LIST
59798: LIST
59799: LIST
59800: LIST
59801: LIST
59802: LIST
59803: LIST
59804: PUSH
59805: LD_INT 27
59807: PUSH
59808: LD_INT 28
59810: PUSH
59811: LD_INT 26
59813: PUSH
59814: LD_INT 30
59816: PUSH
59817: EMPTY
59818: LIST
59819: LIST
59820: LIST
59821: LIST
59822: PUSH
59823: LD_INT 43
59825: PUSH
59826: LD_INT 44
59828: PUSH
59829: LD_INT 46
59831: PUSH
59832: LD_INT 45
59834: PUSH
59835: LD_INT 47
59837: PUSH
59838: LD_INT 49
59840: PUSH
59841: EMPTY
59842: LIST
59843: LIST
59844: LIST
59845: LIST
59846: LIST
59847: LIST
59848: PUSH
59849: EMPTY
59850: LIST
59851: LIST
59852: LIST
59853: PUSH
59854: LD_VAR 0 12
59858: ARRAY
59859: ST_TO_ADDR
// for i in list do
59860: LD_ADDR_VAR 0 8
59864: PUSH
59865: LD_VAR 0 5
59869: PUSH
59870: FOR_IN
59871: IFFALSE 59904
// if not i in fac_list then
59873: LD_VAR 0 8
59877: PUSH
59878: LD_VAR 0 17
59882: IN
59883: NOT
59884: IFFALSE 59902
// list := list diff i ;
59886: LD_ADDR_VAR 0 5
59890: PUSH
59891: LD_VAR 0 5
59895: PUSH
59896: LD_VAR 0 8
59900: DIFF
59901: ST_TO_ADDR
59902: GO 59870
59904: POP
59905: POP
// if not list then
59906: LD_VAR 0 5
59910: NOT
59911: IFFALSE 59915
// exit ;
59913: GO 60719
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
59915: LD_VAR 0 12
59919: PUSH
59920: LD_INT 3
59922: EQUAL
59923: PUSH
59924: LD_INT 49
59926: PUSH
59927: LD_VAR 0 5
59931: IN
59932: AND
59933: PUSH
59934: LD_INT 31
59936: PPUSH
59937: LD_VAR 0 16
59941: PPUSH
59942: CALL_OW 321
59946: PUSH
59947: LD_INT 2
59949: EQUAL
59950: AND
59951: IFFALSE 60011
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
59953: LD_INT 22
59955: PUSH
59956: LD_VAR 0 16
59960: PUSH
59961: EMPTY
59962: LIST
59963: LIST
59964: PUSH
59965: LD_INT 35
59967: PUSH
59968: LD_INT 49
59970: PUSH
59971: EMPTY
59972: LIST
59973: LIST
59974: PUSH
59975: LD_INT 91
59977: PUSH
59978: LD_VAR 0 1
59982: PUSH
59983: LD_INT 10
59985: PUSH
59986: EMPTY
59987: LIST
59988: LIST
59989: LIST
59990: PUSH
59991: EMPTY
59992: LIST
59993: LIST
59994: LIST
59995: PPUSH
59996: CALL_OW 69
60000: NOT
60001: IFFALSE 60011
// weapon := ru_time_lapser ;
60003: LD_ADDR_VAR 0 18
60007: PUSH
60008: LD_INT 49
60010: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
60011: LD_VAR 0 12
60015: PUSH
60016: LD_INT 1
60018: PUSH
60019: LD_INT 2
60021: PUSH
60022: EMPTY
60023: LIST
60024: LIST
60025: IN
60026: PUSH
60027: LD_INT 11
60029: PUSH
60030: LD_VAR 0 5
60034: IN
60035: PUSH
60036: LD_INT 30
60038: PUSH
60039: LD_VAR 0 5
60043: IN
60044: OR
60045: AND
60046: PUSH
60047: LD_INT 6
60049: PPUSH
60050: LD_VAR 0 16
60054: PPUSH
60055: CALL_OW 321
60059: PUSH
60060: LD_INT 2
60062: EQUAL
60063: AND
60064: IFFALSE 60229
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
60066: LD_INT 22
60068: PUSH
60069: LD_VAR 0 16
60073: PUSH
60074: EMPTY
60075: LIST
60076: LIST
60077: PUSH
60078: LD_INT 2
60080: PUSH
60081: LD_INT 35
60083: PUSH
60084: LD_INT 11
60086: PUSH
60087: EMPTY
60088: LIST
60089: LIST
60090: PUSH
60091: LD_INT 35
60093: PUSH
60094: LD_INT 30
60096: PUSH
60097: EMPTY
60098: LIST
60099: LIST
60100: PUSH
60101: EMPTY
60102: LIST
60103: LIST
60104: LIST
60105: PUSH
60106: LD_INT 91
60108: PUSH
60109: LD_VAR 0 1
60113: PUSH
60114: LD_INT 18
60116: PUSH
60117: EMPTY
60118: LIST
60119: LIST
60120: LIST
60121: PUSH
60122: EMPTY
60123: LIST
60124: LIST
60125: LIST
60126: PPUSH
60127: CALL_OW 69
60131: NOT
60132: PUSH
60133: LD_INT 22
60135: PUSH
60136: LD_VAR 0 16
60140: PUSH
60141: EMPTY
60142: LIST
60143: LIST
60144: PUSH
60145: LD_INT 2
60147: PUSH
60148: LD_INT 30
60150: PUSH
60151: LD_INT 32
60153: PUSH
60154: EMPTY
60155: LIST
60156: LIST
60157: PUSH
60158: LD_INT 30
60160: PUSH
60161: LD_INT 33
60163: PUSH
60164: EMPTY
60165: LIST
60166: LIST
60167: PUSH
60168: EMPTY
60169: LIST
60170: LIST
60171: LIST
60172: PUSH
60173: LD_INT 91
60175: PUSH
60176: LD_VAR 0 1
60180: PUSH
60181: LD_INT 12
60183: PUSH
60184: EMPTY
60185: LIST
60186: LIST
60187: LIST
60188: PUSH
60189: EMPTY
60190: LIST
60191: LIST
60192: LIST
60193: PUSH
60194: EMPTY
60195: LIST
60196: PPUSH
60197: CALL_OW 69
60201: PUSH
60202: LD_INT 2
60204: GREATER
60205: AND
60206: IFFALSE 60229
// weapon := [ us_radar , ar_radar ] [ nat ] ;
60208: LD_ADDR_VAR 0 18
60212: PUSH
60213: LD_INT 11
60215: PUSH
60216: LD_INT 30
60218: PUSH
60219: EMPTY
60220: LIST
60221: LIST
60222: PUSH
60223: LD_VAR 0 12
60227: ARRAY
60228: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
60229: LD_VAR 0 18
60233: NOT
60234: PUSH
60235: LD_INT 40
60237: PPUSH
60238: LD_VAR 0 16
60242: PPUSH
60243: CALL_OW 321
60247: PUSH
60248: LD_INT 2
60250: EQUAL
60251: AND
60252: PUSH
60253: LD_INT 7
60255: PUSH
60256: LD_VAR 0 5
60260: IN
60261: PUSH
60262: LD_INT 28
60264: PUSH
60265: LD_VAR 0 5
60269: IN
60270: OR
60271: PUSH
60272: LD_INT 45
60274: PUSH
60275: LD_VAR 0 5
60279: IN
60280: OR
60281: AND
60282: IFFALSE 60536
// begin hex := GetHexInfo ( x , y ) ;
60284: LD_ADDR_VAR 0 4
60288: PUSH
60289: LD_VAR 0 10
60293: PPUSH
60294: LD_VAR 0 11
60298: PPUSH
60299: CALL_OW 546
60303: ST_TO_ADDR
// if hex [ 1 ] then
60304: LD_VAR 0 4
60308: PUSH
60309: LD_INT 1
60311: ARRAY
60312: IFFALSE 60316
// exit ;
60314: GO 60719
// height := hex [ 2 ] ;
60316: LD_ADDR_VAR 0 15
60320: PUSH
60321: LD_VAR 0 4
60325: PUSH
60326: LD_INT 2
60328: ARRAY
60329: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
60330: LD_ADDR_VAR 0 14
60334: PUSH
60335: LD_INT 0
60337: PUSH
60338: LD_INT 2
60340: PUSH
60341: LD_INT 3
60343: PUSH
60344: LD_INT 5
60346: PUSH
60347: EMPTY
60348: LIST
60349: LIST
60350: LIST
60351: LIST
60352: ST_TO_ADDR
// for i in tmp do
60353: LD_ADDR_VAR 0 8
60357: PUSH
60358: LD_VAR 0 14
60362: PUSH
60363: FOR_IN
60364: IFFALSE 60534
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
60366: LD_ADDR_VAR 0 9
60370: PUSH
60371: LD_VAR 0 10
60375: PPUSH
60376: LD_VAR 0 8
60380: PPUSH
60381: LD_INT 5
60383: PPUSH
60384: CALL_OW 272
60388: PUSH
60389: LD_VAR 0 11
60393: PPUSH
60394: LD_VAR 0 8
60398: PPUSH
60399: LD_INT 5
60401: PPUSH
60402: CALL_OW 273
60406: PUSH
60407: EMPTY
60408: LIST
60409: LIST
60410: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
60411: LD_VAR 0 9
60415: PUSH
60416: LD_INT 1
60418: ARRAY
60419: PPUSH
60420: LD_VAR 0 9
60424: PUSH
60425: LD_INT 2
60427: ARRAY
60428: PPUSH
60429: CALL_OW 488
60433: IFFALSE 60532
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
60435: LD_ADDR_VAR 0 4
60439: PUSH
60440: LD_VAR 0 9
60444: PUSH
60445: LD_INT 1
60447: ARRAY
60448: PPUSH
60449: LD_VAR 0 9
60453: PUSH
60454: LD_INT 2
60456: ARRAY
60457: PPUSH
60458: CALL_OW 546
60462: ST_TO_ADDR
// if hex [ 1 ] then
60463: LD_VAR 0 4
60467: PUSH
60468: LD_INT 1
60470: ARRAY
60471: IFFALSE 60475
// continue ;
60473: GO 60363
// h := hex [ 2 ] ;
60475: LD_ADDR_VAR 0 13
60479: PUSH
60480: LD_VAR 0 4
60484: PUSH
60485: LD_INT 2
60487: ARRAY
60488: ST_TO_ADDR
// if h + 7 < height then
60489: LD_VAR 0 13
60493: PUSH
60494: LD_INT 7
60496: PLUS
60497: PUSH
60498: LD_VAR 0 15
60502: LESS
60503: IFFALSE 60532
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
60505: LD_ADDR_VAR 0 18
60509: PUSH
60510: LD_INT 7
60512: PUSH
60513: LD_INT 28
60515: PUSH
60516: LD_INT 45
60518: PUSH
60519: EMPTY
60520: LIST
60521: LIST
60522: LIST
60523: PUSH
60524: LD_VAR 0 12
60528: ARRAY
60529: ST_TO_ADDR
// break ;
60530: GO 60534
// end ; end ; end ;
60532: GO 60363
60534: POP
60535: POP
// end ; if not weapon then
60536: LD_VAR 0 18
60540: NOT
60541: IFFALSE 60601
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
60543: LD_ADDR_VAR 0 5
60547: PUSH
60548: LD_VAR 0 5
60552: PUSH
60553: LD_INT 11
60555: PUSH
60556: LD_INT 30
60558: PUSH
60559: LD_INT 49
60561: PUSH
60562: EMPTY
60563: LIST
60564: LIST
60565: LIST
60566: DIFF
60567: ST_TO_ADDR
// if not list then
60568: LD_VAR 0 5
60572: NOT
60573: IFFALSE 60577
// exit ;
60575: GO 60719
// weapon := list [ rand ( 1 , list ) ] ;
60577: LD_ADDR_VAR 0 18
60581: PUSH
60582: LD_VAR 0 5
60586: PUSH
60587: LD_INT 1
60589: PPUSH
60590: LD_VAR 0 5
60594: PPUSH
60595: CALL_OW 12
60599: ARRAY
60600: ST_TO_ADDR
// end ; if weapon then
60601: LD_VAR 0 18
60605: IFFALSE 60719
// begin tmp := CostOfWeapon ( weapon ) ;
60607: LD_ADDR_VAR 0 14
60611: PUSH
60612: LD_VAR 0 18
60616: PPUSH
60617: CALL_OW 451
60621: ST_TO_ADDR
// j := GetBase ( tower ) ;
60622: LD_ADDR_VAR 0 9
60626: PUSH
60627: LD_VAR 0 1
60631: PPUSH
60632: CALL_OW 274
60636: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
60637: LD_VAR 0 9
60641: PPUSH
60642: LD_INT 1
60644: PPUSH
60645: CALL_OW 275
60649: PUSH
60650: LD_VAR 0 14
60654: PUSH
60655: LD_INT 1
60657: ARRAY
60658: GREATEREQUAL
60659: PUSH
60660: LD_VAR 0 9
60664: PPUSH
60665: LD_INT 2
60667: PPUSH
60668: CALL_OW 275
60672: PUSH
60673: LD_VAR 0 14
60677: PUSH
60678: LD_INT 2
60680: ARRAY
60681: GREATEREQUAL
60682: AND
60683: PUSH
60684: LD_VAR 0 9
60688: PPUSH
60689: LD_INT 3
60691: PPUSH
60692: CALL_OW 275
60696: PUSH
60697: LD_VAR 0 14
60701: PUSH
60702: LD_INT 3
60704: ARRAY
60705: GREATEREQUAL
60706: AND
60707: IFFALSE 60719
// result := weapon ;
60709: LD_ADDR_VAR 0 3
60713: PUSH
60714: LD_VAR 0 18
60718: ST_TO_ADDR
// end ; end ;
60719: LD_VAR 0 3
60723: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
60724: LD_INT 0
60726: PPUSH
60727: PPUSH
// result := true ;
60728: LD_ADDR_VAR 0 3
60732: PUSH
60733: LD_INT 1
60735: ST_TO_ADDR
// if array1 = array2 then
60736: LD_VAR 0 1
60740: PUSH
60741: LD_VAR 0 2
60745: EQUAL
60746: IFFALSE 60806
// begin for i = 1 to array1 do
60748: LD_ADDR_VAR 0 4
60752: PUSH
60753: DOUBLE
60754: LD_INT 1
60756: DEC
60757: ST_TO_ADDR
60758: LD_VAR 0 1
60762: PUSH
60763: FOR_TO
60764: IFFALSE 60802
// if array1 [ i ] <> array2 [ i ] then
60766: LD_VAR 0 1
60770: PUSH
60771: LD_VAR 0 4
60775: ARRAY
60776: PUSH
60777: LD_VAR 0 2
60781: PUSH
60782: LD_VAR 0 4
60786: ARRAY
60787: NONEQUAL
60788: IFFALSE 60800
// begin result := false ;
60790: LD_ADDR_VAR 0 3
60794: PUSH
60795: LD_INT 0
60797: ST_TO_ADDR
// break ;
60798: GO 60802
// end ;
60800: GO 60763
60802: POP
60803: POP
// end else
60804: GO 60814
// result := false ;
60806: LD_ADDR_VAR 0 3
60810: PUSH
60811: LD_INT 0
60813: ST_TO_ADDR
// end ;
60814: LD_VAR 0 3
60818: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
60819: LD_INT 0
60821: PPUSH
60822: PPUSH
60823: PPUSH
// pom := GetBase ( fac ) ;
60824: LD_ADDR_VAR 0 5
60828: PUSH
60829: LD_VAR 0 1
60833: PPUSH
60834: CALL_OW 274
60838: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
60839: LD_ADDR_VAR 0 4
60843: PUSH
60844: LD_VAR 0 2
60848: PUSH
60849: LD_INT 1
60851: ARRAY
60852: PPUSH
60853: LD_VAR 0 2
60857: PUSH
60858: LD_INT 2
60860: ARRAY
60861: PPUSH
60862: LD_VAR 0 2
60866: PUSH
60867: LD_INT 3
60869: ARRAY
60870: PPUSH
60871: LD_VAR 0 2
60875: PUSH
60876: LD_INT 4
60878: ARRAY
60879: PPUSH
60880: CALL_OW 449
60884: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60885: LD_ADDR_VAR 0 3
60889: PUSH
60890: LD_VAR 0 5
60894: PPUSH
60895: LD_INT 1
60897: PPUSH
60898: CALL_OW 275
60902: PUSH
60903: LD_VAR 0 4
60907: PUSH
60908: LD_INT 1
60910: ARRAY
60911: GREATEREQUAL
60912: PUSH
60913: LD_VAR 0 5
60917: PPUSH
60918: LD_INT 2
60920: PPUSH
60921: CALL_OW 275
60925: PUSH
60926: LD_VAR 0 4
60930: PUSH
60931: LD_INT 2
60933: ARRAY
60934: GREATEREQUAL
60935: AND
60936: PUSH
60937: LD_VAR 0 5
60941: PPUSH
60942: LD_INT 3
60944: PPUSH
60945: CALL_OW 275
60949: PUSH
60950: LD_VAR 0 4
60954: PUSH
60955: LD_INT 3
60957: ARRAY
60958: GREATEREQUAL
60959: AND
60960: ST_TO_ADDR
// end ;
60961: LD_VAR 0 3
60965: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
60966: LD_INT 0
60968: PPUSH
60969: PPUSH
60970: PPUSH
60971: PPUSH
// pom := GetBase ( building ) ;
60972: LD_ADDR_VAR 0 3
60976: PUSH
60977: LD_VAR 0 1
60981: PPUSH
60982: CALL_OW 274
60986: ST_TO_ADDR
// if not pom then
60987: LD_VAR 0 3
60991: NOT
60992: IFFALSE 60996
// exit ;
60994: GO 61166
// btype := GetBType ( building ) ;
60996: LD_ADDR_VAR 0 5
61000: PUSH
61001: LD_VAR 0 1
61005: PPUSH
61006: CALL_OW 266
61010: ST_TO_ADDR
// if btype = b_armoury then
61011: LD_VAR 0 5
61015: PUSH
61016: LD_INT 4
61018: EQUAL
61019: IFFALSE 61029
// btype := b_barracks ;
61021: LD_ADDR_VAR 0 5
61025: PUSH
61026: LD_INT 5
61028: ST_TO_ADDR
// if btype = b_depot then
61029: LD_VAR 0 5
61033: PUSH
61034: LD_INT 0
61036: EQUAL
61037: IFFALSE 61047
// btype := b_warehouse ;
61039: LD_ADDR_VAR 0 5
61043: PUSH
61044: LD_INT 1
61046: ST_TO_ADDR
// if btype = b_workshop then
61047: LD_VAR 0 5
61051: PUSH
61052: LD_INT 2
61054: EQUAL
61055: IFFALSE 61065
// btype := b_factory ;
61057: LD_ADDR_VAR 0 5
61061: PUSH
61062: LD_INT 3
61064: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
61065: LD_ADDR_VAR 0 4
61069: PUSH
61070: LD_VAR 0 5
61074: PPUSH
61075: LD_VAR 0 1
61079: PPUSH
61080: CALL_OW 248
61084: PPUSH
61085: CALL_OW 450
61089: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
61090: LD_ADDR_VAR 0 2
61094: PUSH
61095: LD_VAR 0 3
61099: PPUSH
61100: LD_INT 1
61102: PPUSH
61103: CALL_OW 275
61107: PUSH
61108: LD_VAR 0 4
61112: PUSH
61113: LD_INT 1
61115: ARRAY
61116: GREATEREQUAL
61117: PUSH
61118: LD_VAR 0 3
61122: PPUSH
61123: LD_INT 2
61125: PPUSH
61126: CALL_OW 275
61130: PUSH
61131: LD_VAR 0 4
61135: PUSH
61136: LD_INT 2
61138: ARRAY
61139: GREATEREQUAL
61140: AND
61141: PUSH
61142: LD_VAR 0 3
61146: PPUSH
61147: LD_INT 3
61149: PPUSH
61150: CALL_OW 275
61154: PUSH
61155: LD_VAR 0 4
61159: PUSH
61160: LD_INT 3
61162: ARRAY
61163: GREATEREQUAL
61164: AND
61165: ST_TO_ADDR
// end ;
61166: LD_VAR 0 2
61170: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
61171: LD_INT 0
61173: PPUSH
61174: PPUSH
61175: PPUSH
// pom := GetBase ( building ) ;
61176: LD_ADDR_VAR 0 4
61180: PUSH
61181: LD_VAR 0 1
61185: PPUSH
61186: CALL_OW 274
61190: ST_TO_ADDR
// if not pom then
61191: LD_VAR 0 4
61195: NOT
61196: IFFALSE 61200
// exit ;
61198: GO 61301
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
61200: LD_ADDR_VAR 0 5
61204: PUSH
61205: LD_VAR 0 2
61209: PPUSH
61210: LD_VAR 0 1
61214: PPUSH
61215: CALL_OW 248
61219: PPUSH
61220: CALL_OW 450
61224: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
61225: LD_ADDR_VAR 0 3
61229: PUSH
61230: LD_VAR 0 4
61234: PPUSH
61235: LD_INT 1
61237: PPUSH
61238: CALL_OW 275
61242: PUSH
61243: LD_VAR 0 5
61247: PUSH
61248: LD_INT 1
61250: ARRAY
61251: GREATEREQUAL
61252: PUSH
61253: LD_VAR 0 4
61257: PPUSH
61258: LD_INT 2
61260: PPUSH
61261: CALL_OW 275
61265: PUSH
61266: LD_VAR 0 5
61270: PUSH
61271: LD_INT 2
61273: ARRAY
61274: GREATEREQUAL
61275: AND
61276: PUSH
61277: LD_VAR 0 4
61281: PPUSH
61282: LD_INT 3
61284: PPUSH
61285: CALL_OW 275
61289: PUSH
61290: LD_VAR 0 5
61294: PUSH
61295: LD_INT 3
61297: ARRAY
61298: GREATEREQUAL
61299: AND
61300: ST_TO_ADDR
// end ;
61301: LD_VAR 0 3
61305: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
61306: LD_INT 0
61308: PPUSH
61309: PPUSH
61310: PPUSH
61311: PPUSH
61312: PPUSH
61313: PPUSH
61314: PPUSH
61315: PPUSH
61316: PPUSH
61317: PPUSH
// result := false ;
61318: LD_ADDR_VAR 0 6
61322: PUSH
61323: LD_INT 0
61325: ST_TO_ADDR
// if not base or not btype or not x or not y then
61326: LD_VAR 0 1
61330: NOT
61331: PUSH
61332: LD_VAR 0 2
61336: NOT
61337: OR
61338: PUSH
61339: LD_VAR 0 3
61343: NOT
61344: OR
61345: PUSH
61346: LD_VAR 0 4
61350: NOT
61351: OR
61352: IFFALSE 61356
// exit ;
61354: GO 61965
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
61356: LD_ADDR_VAR 0 12
61360: PUSH
61361: LD_VAR 0 2
61365: PPUSH
61366: LD_VAR 0 3
61370: PPUSH
61371: LD_VAR 0 4
61375: PPUSH
61376: LD_VAR 0 5
61380: PPUSH
61381: LD_VAR 0 1
61385: PUSH
61386: LD_INT 1
61388: ARRAY
61389: PPUSH
61390: CALL_OW 248
61394: PPUSH
61395: LD_INT 0
61397: PPUSH
61398: CALL 62802 0 6
61402: ST_TO_ADDR
// if not hexes then
61403: LD_VAR 0 12
61407: NOT
61408: IFFALSE 61412
// exit ;
61410: GO 61965
// for i = 1 to hexes do
61412: LD_ADDR_VAR 0 7
61416: PUSH
61417: DOUBLE
61418: LD_INT 1
61420: DEC
61421: ST_TO_ADDR
61422: LD_VAR 0 12
61426: PUSH
61427: FOR_TO
61428: IFFALSE 61963
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
61430: LD_ADDR_VAR 0 11
61434: PUSH
61435: LD_VAR 0 12
61439: PUSH
61440: LD_VAR 0 7
61444: ARRAY
61445: PUSH
61446: LD_INT 1
61448: ARRAY
61449: PPUSH
61450: LD_VAR 0 12
61454: PUSH
61455: LD_VAR 0 7
61459: ARRAY
61460: PUSH
61461: LD_INT 2
61463: ARRAY
61464: PPUSH
61465: CALL_OW 428
61469: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
61470: LD_VAR 0 12
61474: PUSH
61475: LD_VAR 0 7
61479: ARRAY
61480: PUSH
61481: LD_INT 1
61483: ARRAY
61484: PPUSH
61485: LD_VAR 0 12
61489: PUSH
61490: LD_VAR 0 7
61494: ARRAY
61495: PUSH
61496: LD_INT 2
61498: ARRAY
61499: PPUSH
61500: CALL_OW 351
61504: PUSH
61505: LD_VAR 0 12
61509: PUSH
61510: LD_VAR 0 7
61514: ARRAY
61515: PUSH
61516: LD_INT 1
61518: ARRAY
61519: PPUSH
61520: LD_VAR 0 12
61524: PUSH
61525: LD_VAR 0 7
61529: ARRAY
61530: PUSH
61531: LD_INT 2
61533: ARRAY
61534: PPUSH
61535: CALL_OW 488
61539: NOT
61540: OR
61541: PUSH
61542: LD_VAR 0 11
61546: PPUSH
61547: CALL_OW 247
61551: PUSH
61552: LD_INT 3
61554: EQUAL
61555: OR
61556: IFFALSE 61562
// exit ;
61558: POP
61559: POP
61560: GO 61965
// if not tmp or not tmp in base then
61562: LD_VAR 0 11
61566: NOT
61567: PUSH
61568: LD_VAR 0 11
61572: PUSH
61573: LD_VAR 0 1
61577: IN
61578: NOT
61579: OR
61580: IFFALSE 61584
// continue ;
61582: GO 61427
// result := true ;
61584: LD_ADDR_VAR 0 6
61588: PUSH
61589: LD_INT 1
61591: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
61592: LD_ADDR_VAR 0 15
61596: PUSH
61597: LD_VAR 0 1
61601: PPUSH
61602: LD_INT 22
61604: PUSH
61605: LD_VAR 0 11
61609: PPUSH
61610: CALL_OW 255
61614: PUSH
61615: EMPTY
61616: LIST
61617: LIST
61618: PUSH
61619: LD_INT 2
61621: PUSH
61622: LD_INT 30
61624: PUSH
61625: LD_INT 0
61627: PUSH
61628: EMPTY
61629: LIST
61630: LIST
61631: PUSH
61632: LD_INT 30
61634: PUSH
61635: LD_INT 1
61637: PUSH
61638: EMPTY
61639: LIST
61640: LIST
61641: PUSH
61642: EMPTY
61643: LIST
61644: LIST
61645: LIST
61646: PUSH
61647: EMPTY
61648: LIST
61649: LIST
61650: PPUSH
61651: CALL_OW 72
61655: ST_TO_ADDR
// if dep then
61656: LD_VAR 0 15
61660: IFFALSE 61796
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
61662: LD_ADDR_VAR 0 14
61666: PUSH
61667: LD_VAR 0 15
61671: PUSH
61672: LD_INT 1
61674: ARRAY
61675: PPUSH
61676: CALL_OW 250
61680: PPUSH
61681: LD_VAR 0 15
61685: PUSH
61686: LD_INT 1
61688: ARRAY
61689: PPUSH
61690: CALL_OW 254
61694: PPUSH
61695: LD_INT 5
61697: PPUSH
61698: CALL_OW 272
61702: PUSH
61703: LD_VAR 0 15
61707: PUSH
61708: LD_INT 1
61710: ARRAY
61711: PPUSH
61712: CALL_OW 251
61716: PPUSH
61717: LD_VAR 0 15
61721: PUSH
61722: LD_INT 1
61724: ARRAY
61725: PPUSH
61726: CALL_OW 254
61730: PPUSH
61731: LD_INT 5
61733: PPUSH
61734: CALL_OW 273
61738: PUSH
61739: EMPTY
61740: LIST
61741: LIST
61742: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
61743: LD_VAR 0 14
61747: PUSH
61748: LD_INT 1
61750: ARRAY
61751: PPUSH
61752: LD_VAR 0 14
61756: PUSH
61757: LD_INT 2
61759: ARRAY
61760: PPUSH
61761: CALL_OW 488
61765: IFFALSE 61796
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
61767: LD_VAR 0 11
61771: PPUSH
61772: LD_VAR 0 14
61776: PUSH
61777: LD_INT 1
61779: ARRAY
61780: PPUSH
61781: LD_VAR 0 14
61785: PUSH
61786: LD_INT 2
61788: ARRAY
61789: PPUSH
61790: CALL_OW 111
// continue ;
61794: GO 61427
// end ; end ; r := GetDir ( tmp ) ;
61796: LD_ADDR_VAR 0 13
61800: PUSH
61801: LD_VAR 0 11
61805: PPUSH
61806: CALL_OW 254
61810: ST_TO_ADDR
// if r = 5 then
61811: LD_VAR 0 13
61815: PUSH
61816: LD_INT 5
61818: EQUAL
61819: IFFALSE 61829
// r := 0 ;
61821: LD_ADDR_VAR 0 13
61825: PUSH
61826: LD_INT 0
61828: ST_TO_ADDR
// for j = r to 5 do
61829: LD_ADDR_VAR 0 8
61833: PUSH
61834: DOUBLE
61835: LD_VAR 0 13
61839: DEC
61840: ST_TO_ADDR
61841: LD_INT 5
61843: PUSH
61844: FOR_TO
61845: IFFALSE 61959
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
61847: LD_ADDR_VAR 0 9
61851: PUSH
61852: LD_VAR 0 11
61856: PPUSH
61857: CALL_OW 250
61861: PPUSH
61862: LD_VAR 0 8
61866: PPUSH
61867: LD_INT 2
61869: PPUSH
61870: CALL_OW 272
61874: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
61875: LD_ADDR_VAR 0 10
61879: PUSH
61880: LD_VAR 0 11
61884: PPUSH
61885: CALL_OW 251
61889: PPUSH
61890: LD_VAR 0 8
61894: PPUSH
61895: LD_INT 2
61897: PPUSH
61898: CALL_OW 273
61902: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
61903: LD_VAR 0 9
61907: PPUSH
61908: LD_VAR 0 10
61912: PPUSH
61913: CALL_OW 488
61917: PUSH
61918: LD_VAR 0 9
61922: PPUSH
61923: LD_VAR 0 10
61927: PPUSH
61928: CALL_OW 428
61932: NOT
61933: AND
61934: IFFALSE 61957
// begin ComMoveXY ( tmp , _x , _y ) ;
61936: LD_VAR 0 11
61940: PPUSH
61941: LD_VAR 0 9
61945: PPUSH
61946: LD_VAR 0 10
61950: PPUSH
61951: CALL_OW 111
// break ;
61955: GO 61959
// end ; end ;
61957: GO 61844
61959: POP
61960: POP
// end ;
61961: GO 61427
61963: POP
61964: POP
// end ;
61965: LD_VAR 0 6
61969: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
61970: LD_INT 0
61972: PPUSH
61973: PPUSH
61974: PPUSH
61975: PPUSH
61976: PPUSH
61977: PPUSH
61978: PPUSH
61979: PPUSH
61980: PPUSH
61981: PPUSH
// result := false ;
61982: LD_ADDR_VAR 0 6
61986: PUSH
61987: LD_INT 0
61989: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
61990: LD_VAR 0 1
61994: NOT
61995: PUSH
61996: LD_VAR 0 1
62000: PPUSH
62001: CALL_OW 266
62005: PUSH
62006: LD_INT 0
62008: PUSH
62009: LD_INT 1
62011: PUSH
62012: EMPTY
62013: LIST
62014: LIST
62015: IN
62016: NOT
62017: OR
62018: PUSH
62019: LD_VAR 0 2
62023: NOT
62024: OR
62025: PUSH
62026: LD_VAR 0 5
62030: PUSH
62031: LD_INT 0
62033: PUSH
62034: LD_INT 1
62036: PUSH
62037: LD_INT 2
62039: PUSH
62040: LD_INT 3
62042: PUSH
62043: LD_INT 4
62045: PUSH
62046: LD_INT 5
62048: PUSH
62049: EMPTY
62050: LIST
62051: LIST
62052: LIST
62053: LIST
62054: LIST
62055: LIST
62056: IN
62057: NOT
62058: OR
62059: PUSH
62060: LD_VAR 0 3
62064: PPUSH
62065: LD_VAR 0 4
62069: PPUSH
62070: CALL_OW 488
62074: NOT
62075: OR
62076: IFFALSE 62080
// exit ;
62078: GO 62797
// pom := GetBase ( depot ) ;
62080: LD_ADDR_VAR 0 10
62084: PUSH
62085: LD_VAR 0 1
62089: PPUSH
62090: CALL_OW 274
62094: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
62095: LD_ADDR_VAR 0 11
62099: PUSH
62100: LD_VAR 0 2
62104: PPUSH
62105: LD_VAR 0 1
62109: PPUSH
62110: CALL_OW 248
62114: PPUSH
62115: CALL_OW 450
62119: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
62120: LD_VAR 0 10
62124: PPUSH
62125: LD_INT 1
62127: PPUSH
62128: CALL_OW 275
62132: PUSH
62133: LD_VAR 0 11
62137: PUSH
62138: LD_INT 1
62140: ARRAY
62141: GREATEREQUAL
62142: PUSH
62143: LD_VAR 0 10
62147: PPUSH
62148: LD_INT 2
62150: PPUSH
62151: CALL_OW 275
62155: PUSH
62156: LD_VAR 0 11
62160: PUSH
62161: LD_INT 2
62163: ARRAY
62164: GREATEREQUAL
62165: AND
62166: PUSH
62167: LD_VAR 0 10
62171: PPUSH
62172: LD_INT 3
62174: PPUSH
62175: CALL_OW 275
62179: PUSH
62180: LD_VAR 0 11
62184: PUSH
62185: LD_INT 3
62187: ARRAY
62188: GREATEREQUAL
62189: AND
62190: NOT
62191: IFFALSE 62195
// exit ;
62193: GO 62797
// if GetBType ( depot ) = b_depot then
62195: LD_VAR 0 1
62199: PPUSH
62200: CALL_OW 266
62204: PUSH
62205: LD_INT 0
62207: EQUAL
62208: IFFALSE 62220
// dist := 28 else
62210: LD_ADDR_VAR 0 14
62214: PUSH
62215: LD_INT 28
62217: ST_TO_ADDR
62218: GO 62228
// dist := 36 ;
62220: LD_ADDR_VAR 0 14
62224: PUSH
62225: LD_INT 36
62227: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
62228: LD_VAR 0 1
62232: PPUSH
62233: LD_VAR 0 3
62237: PPUSH
62238: LD_VAR 0 4
62242: PPUSH
62243: CALL_OW 297
62247: PUSH
62248: LD_VAR 0 14
62252: GREATER
62253: IFFALSE 62257
// exit ;
62255: GO 62797
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
62257: LD_ADDR_VAR 0 12
62261: PUSH
62262: LD_VAR 0 2
62266: PPUSH
62267: LD_VAR 0 3
62271: PPUSH
62272: LD_VAR 0 4
62276: PPUSH
62277: LD_VAR 0 5
62281: PPUSH
62282: LD_VAR 0 1
62286: PPUSH
62287: CALL_OW 248
62291: PPUSH
62292: LD_INT 0
62294: PPUSH
62295: CALL 62802 0 6
62299: ST_TO_ADDR
// if not hexes then
62300: LD_VAR 0 12
62304: NOT
62305: IFFALSE 62309
// exit ;
62307: GO 62797
// hex := GetHexInfo ( x , y ) ;
62309: LD_ADDR_VAR 0 15
62313: PUSH
62314: LD_VAR 0 3
62318: PPUSH
62319: LD_VAR 0 4
62323: PPUSH
62324: CALL_OW 546
62328: ST_TO_ADDR
// if hex [ 1 ] then
62329: LD_VAR 0 15
62333: PUSH
62334: LD_INT 1
62336: ARRAY
62337: IFFALSE 62341
// exit ;
62339: GO 62797
// height := hex [ 2 ] ;
62341: LD_ADDR_VAR 0 13
62345: PUSH
62346: LD_VAR 0 15
62350: PUSH
62351: LD_INT 2
62353: ARRAY
62354: ST_TO_ADDR
// for i = 1 to hexes do
62355: LD_ADDR_VAR 0 7
62359: PUSH
62360: DOUBLE
62361: LD_INT 1
62363: DEC
62364: ST_TO_ADDR
62365: LD_VAR 0 12
62369: PUSH
62370: FOR_TO
62371: IFFALSE 62701
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
62373: LD_VAR 0 12
62377: PUSH
62378: LD_VAR 0 7
62382: ARRAY
62383: PUSH
62384: LD_INT 1
62386: ARRAY
62387: PPUSH
62388: LD_VAR 0 12
62392: PUSH
62393: LD_VAR 0 7
62397: ARRAY
62398: PUSH
62399: LD_INT 2
62401: ARRAY
62402: PPUSH
62403: CALL_OW 488
62407: NOT
62408: PUSH
62409: LD_VAR 0 12
62413: PUSH
62414: LD_VAR 0 7
62418: ARRAY
62419: PUSH
62420: LD_INT 1
62422: ARRAY
62423: PPUSH
62424: LD_VAR 0 12
62428: PUSH
62429: LD_VAR 0 7
62433: ARRAY
62434: PUSH
62435: LD_INT 2
62437: ARRAY
62438: PPUSH
62439: CALL_OW 428
62443: PUSH
62444: LD_INT 0
62446: GREATER
62447: OR
62448: PUSH
62449: LD_VAR 0 12
62453: PUSH
62454: LD_VAR 0 7
62458: ARRAY
62459: PUSH
62460: LD_INT 1
62462: ARRAY
62463: PPUSH
62464: LD_VAR 0 12
62468: PUSH
62469: LD_VAR 0 7
62473: ARRAY
62474: PUSH
62475: LD_INT 2
62477: ARRAY
62478: PPUSH
62479: CALL_OW 351
62483: OR
62484: IFFALSE 62490
// exit ;
62486: POP
62487: POP
62488: GO 62797
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
62490: LD_ADDR_VAR 0 8
62494: PUSH
62495: LD_VAR 0 12
62499: PUSH
62500: LD_VAR 0 7
62504: ARRAY
62505: PUSH
62506: LD_INT 1
62508: ARRAY
62509: PPUSH
62510: LD_VAR 0 12
62514: PUSH
62515: LD_VAR 0 7
62519: ARRAY
62520: PUSH
62521: LD_INT 2
62523: ARRAY
62524: PPUSH
62525: CALL_OW 546
62529: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
62530: LD_VAR 0 8
62534: PUSH
62535: LD_INT 1
62537: ARRAY
62538: PUSH
62539: LD_VAR 0 8
62543: PUSH
62544: LD_INT 2
62546: ARRAY
62547: PUSH
62548: LD_VAR 0 13
62552: PUSH
62553: LD_INT 2
62555: PLUS
62556: GREATER
62557: OR
62558: PUSH
62559: LD_VAR 0 8
62563: PUSH
62564: LD_INT 2
62566: ARRAY
62567: PUSH
62568: LD_VAR 0 13
62572: PUSH
62573: LD_INT 2
62575: MINUS
62576: LESS
62577: OR
62578: PUSH
62579: LD_VAR 0 8
62583: PUSH
62584: LD_INT 3
62586: ARRAY
62587: PUSH
62588: LD_INT 0
62590: PUSH
62591: LD_INT 8
62593: PUSH
62594: LD_INT 9
62596: PUSH
62597: LD_INT 10
62599: PUSH
62600: LD_INT 11
62602: PUSH
62603: LD_INT 12
62605: PUSH
62606: LD_INT 13
62608: PUSH
62609: LD_INT 16
62611: PUSH
62612: LD_INT 17
62614: PUSH
62615: LD_INT 18
62617: PUSH
62618: LD_INT 19
62620: PUSH
62621: LD_INT 20
62623: PUSH
62624: LD_INT 21
62626: PUSH
62627: EMPTY
62628: LIST
62629: LIST
62630: LIST
62631: LIST
62632: LIST
62633: LIST
62634: LIST
62635: LIST
62636: LIST
62637: LIST
62638: LIST
62639: LIST
62640: LIST
62641: IN
62642: NOT
62643: OR
62644: PUSH
62645: LD_VAR 0 8
62649: PUSH
62650: LD_INT 5
62652: ARRAY
62653: NOT
62654: OR
62655: PUSH
62656: LD_VAR 0 8
62660: PUSH
62661: LD_INT 6
62663: ARRAY
62664: PUSH
62665: LD_INT 1
62667: PUSH
62668: LD_INT 2
62670: PUSH
62671: LD_INT 7
62673: PUSH
62674: LD_INT 9
62676: PUSH
62677: LD_INT 10
62679: PUSH
62680: LD_INT 11
62682: PUSH
62683: EMPTY
62684: LIST
62685: LIST
62686: LIST
62687: LIST
62688: LIST
62689: LIST
62690: IN
62691: NOT
62692: OR
62693: IFFALSE 62699
// exit ;
62695: POP
62696: POP
62697: GO 62797
// end ;
62699: GO 62370
62701: POP
62702: POP
// side := GetSide ( depot ) ;
62703: LD_ADDR_VAR 0 9
62707: PUSH
62708: LD_VAR 0 1
62712: PPUSH
62713: CALL_OW 255
62717: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
62718: LD_VAR 0 9
62722: PPUSH
62723: LD_VAR 0 3
62727: PPUSH
62728: LD_VAR 0 4
62732: PPUSH
62733: LD_INT 20
62735: PPUSH
62736: CALL 55451 0 4
62740: PUSH
62741: LD_INT 4
62743: ARRAY
62744: IFFALSE 62748
// exit ;
62746: GO 62797
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
62748: LD_VAR 0 2
62752: PUSH
62753: LD_INT 29
62755: PUSH
62756: LD_INT 30
62758: PUSH
62759: EMPTY
62760: LIST
62761: LIST
62762: IN
62763: PUSH
62764: LD_VAR 0 3
62768: PPUSH
62769: LD_VAR 0 4
62773: PPUSH
62774: LD_VAR 0 9
62778: PPUSH
62779: CALL_OW 440
62783: NOT
62784: AND
62785: IFFALSE 62789
// exit ;
62787: GO 62797
// result := true ;
62789: LD_ADDR_VAR 0 6
62793: PUSH
62794: LD_INT 1
62796: ST_TO_ADDR
// end ;
62797: LD_VAR 0 6
62801: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
62802: LD_INT 0
62804: PPUSH
62805: PPUSH
62806: PPUSH
62807: PPUSH
62808: PPUSH
62809: PPUSH
62810: PPUSH
62811: PPUSH
62812: PPUSH
62813: PPUSH
62814: PPUSH
62815: PPUSH
62816: PPUSH
62817: PPUSH
62818: PPUSH
62819: PPUSH
62820: PPUSH
62821: PPUSH
62822: PPUSH
62823: PPUSH
62824: PPUSH
62825: PPUSH
62826: PPUSH
62827: PPUSH
62828: PPUSH
62829: PPUSH
62830: PPUSH
62831: PPUSH
62832: PPUSH
62833: PPUSH
62834: PPUSH
62835: PPUSH
62836: PPUSH
62837: PPUSH
62838: PPUSH
62839: PPUSH
62840: PPUSH
62841: PPUSH
62842: PPUSH
62843: PPUSH
62844: PPUSH
62845: PPUSH
62846: PPUSH
62847: PPUSH
62848: PPUSH
62849: PPUSH
62850: PPUSH
62851: PPUSH
62852: PPUSH
62853: PPUSH
62854: PPUSH
62855: PPUSH
62856: PPUSH
62857: PPUSH
62858: PPUSH
62859: PPUSH
62860: PPUSH
62861: PPUSH
// result = [ ] ;
62862: LD_ADDR_VAR 0 7
62866: PUSH
62867: EMPTY
62868: ST_TO_ADDR
// temp_list = [ ] ;
62869: LD_ADDR_VAR 0 9
62873: PUSH
62874: EMPTY
62875: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
62876: LD_VAR 0 4
62880: PUSH
62881: LD_INT 0
62883: PUSH
62884: LD_INT 1
62886: PUSH
62887: LD_INT 2
62889: PUSH
62890: LD_INT 3
62892: PUSH
62893: LD_INT 4
62895: PUSH
62896: LD_INT 5
62898: PUSH
62899: EMPTY
62900: LIST
62901: LIST
62902: LIST
62903: LIST
62904: LIST
62905: LIST
62906: IN
62907: NOT
62908: PUSH
62909: LD_VAR 0 1
62913: PUSH
62914: LD_INT 0
62916: PUSH
62917: LD_INT 1
62919: PUSH
62920: EMPTY
62921: LIST
62922: LIST
62923: IN
62924: PUSH
62925: LD_VAR 0 5
62929: PUSH
62930: LD_INT 1
62932: PUSH
62933: LD_INT 2
62935: PUSH
62936: LD_INT 3
62938: PUSH
62939: EMPTY
62940: LIST
62941: LIST
62942: LIST
62943: IN
62944: NOT
62945: AND
62946: OR
62947: IFFALSE 62951
// exit ;
62949: GO 81342
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
62951: LD_VAR 0 1
62955: PUSH
62956: LD_INT 6
62958: PUSH
62959: LD_INT 7
62961: PUSH
62962: LD_INT 8
62964: PUSH
62965: LD_INT 13
62967: PUSH
62968: LD_INT 12
62970: PUSH
62971: LD_INT 15
62973: PUSH
62974: LD_INT 11
62976: PUSH
62977: LD_INT 14
62979: PUSH
62980: LD_INT 10
62982: PUSH
62983: EMPTY
62984: LIST
62985: LIST
62986: LIST
62987: LIST
62988: LIST
62989: LIST
62990: LIST
62991: LIST
62992: LIST
62993: IN
62994: IFFALSE 63004
// btype = b_lab ;
62996: LD_ADDR_VAR 0 1
63000: PUSH
63001: LD_INT 6
63003: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
63004: LD_VAR 0 6
63008: PUSH
63009: LD_INT 0
63011: PUSH
63012: LD_INT 1
63014: PUSH
63015: LD_INT 2
63017: PUSH
63018: EMPTY
63019: LIST
63020: LIST
63021: LIST
63022: IN
63023: NOT
63024: PUSH
63025: LD_VAR 0 1
63029: PUSH
63030: LD_INT 0
63032: PUSH
63033: LD_INT 1
63035: PUSH
63036: LD_INT 2
63038: PUSH
63039: LD_INT 3
63041: PUSH
63042: LD_INT 6
63044: PUSH
63045: LD_INT 36
63047: PUSH
63048: LD_INT 4
63050: PUSH
63051: LD_INT 5
63053: PUSH
63054: LD_INT 31
63056: PUSH
63057: LD_INT 32
63059: PUSH
63060: LD_INT 33
63062: PUSH
63063: EMPTY
63064: LIST
63065: LIST
63066: LIST
63067: LIST
63068: LIST
63069: LIST
63070: LIST
63071: LIST
63072: LIST
63073: LIST
63074: LIST
63075: IN
63076: NOT
63077: PUSH
63078: LD_VAR 0 6
63082: PUSH
63083: LD_INT 1
63085: EQUAL
63086: AND
63087: OR
63088: PUSH
63089: LD_VAR 0 1
63093: PUSH
63094: LD_INT 2
63096: PUSH
63097: LD_INT 3
63099: PUSH
63100: EMPTY
63101: LIST
63102: LIST
63103: IN
63104: NOT
63105: PUSH
63106: LD_VAR 0 6
63110: PUSH
63111: LD_INT 2
63113: EQUAL
63114: AND
63115: OR
63116: IFFALSE 63126
// mode = 0 ;
63118: LD_ADDR_VAR 0 6
63122: PUSH
63123: LD_INT 0
63125: ST_TO_ADDR
// case mode of 0 :
63126: LD_VAR 0 6
63130: PUSH
63131: LD_INT 0
63133: DOUBLE
63134: EQUAL
63135: IFTRUE 63139
63137: GO 74592
63139: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
63140: LD_ADDR_VAR 0 11
63144: PUSH
63145: LD_INT 0
63147: PUSH
63148: LD_INT 0
63150: PUSH
63151: EMPTY
63152: LIST
63153: LIST
63154: PUSH
63155: LD_INT 0
63157: PUSH
63158: LD_INT 1
63160: NEG
63161: PUSH
63162: EMPTY
63163: LIST
63164: LIST
63165: PUSH
63166: LD_INT 1
63168: PUSH
63169: LD_INT 0
63171: PUSH
63172: EMPTY
63173: LIST
63174: LIST
63175: PUSH
63176: LD_INT 1
63178: PUSH
63179: LD_INT 1
63181: PUSH
63182: EMPTY
63183: LIST
63184: LIST
63185: PUSH
63186: LD_INT 0
63188: PUSH
63189: LD_INT 1
63191: PUSH
63192: EMPTY
63193: LIST
63194: LIST
63195: PUSH
63196: LD_INT 1
63198: NEG
63199: PUSH
63200: LD_INT 0
63202: PUSH
63203: EMPTY
63204: LIST
63205: LIST
63206: PUSH
63207: LD_INT 1
63209: NEG
63210: PUSH
63211: LD_INT 1
63213: NEG
63214: PUSH
63215: EMPTY
63216: LIST
63217: LIST
63218: PUSH
63219: LD_INT 1
63221: NEG
63222: PUSH
63223: LD_INT 2
63225: NEG
63226: PUSH
63227: EMPTY
63228: LIST
63229: LIST
63230: PUSH
63231: LD_INT 0
63233: PUSH
63234: LD_INT 2
63236: NEG
63237: PUSH
63238: EMPTY
63239: LIST
63240: LIST
63241: PUSH
63242: LD_INT 1
63244: PUSH
63245: LD_INT 1
63247: NEG
63248: PUSH
63249: EMPTY
63250: LIST
63251: LIST
63252: PUSH
63253: LD_INT 1
63255: PUSH
63256: LD_INT 2
63258: PUSH
63259: EMPTY
63260: LIST
63261: LIST
63262: PUSH
63263: LD_INT 0
63265: PUSH
63266: LD_INT 2
63268: PUSH
63269: EMPTY
63270: LIST
63271: LIST
63272: PUSH
63273: LD_INT 1
63275: NEG
63276: PUSH
63277: LD_INT 1
63279: PUSH
63280: EMPTY
63281: LIST
63282: LIST
63283: PUSH
63284: LD_INT 1
63286: PUSH
63287: LD_INT 3
63289: PUSH
63290: EMPTY
63291: LIST
63292: LIST
63293: PUSH
63294: LD_INT 0
63296: PUSH
63297: LD_INT 3
63299: PUSH
63300: EMPTY
63301: LIST
63302: LIST
63303: PUSH
63304: LD_INT 1
63306: NEG
63307: PUSH
63308: LD_INT 2
63310: PUSH
63311: EMPTY
63312: LIST
63313: LIST
63314: PUSH
63315: EMPTY
63316: LIST
63317: LIST
63318: LIST
63319: LIST
63320: LIST
63321: LIST
63322: LIST
63323: LIST
63324: LIST
63325: LIST
63326: LIST
63327: LIST
63328: LIST
63329: LIST
63330: LIST
63331: LIST
63332: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
63333: LD_ADDR_VAR 0 12
63337: PUSH
63338: LD_INT 0
63340: PUSH
63341: LD_INT 0
63343: PUSH
63344: EMPTY
63345: LIST
63346: LIST
63347: PUSH
63348: LD_INT 0
63350: PUSH
63351: LD_INT 1
63353: NEG
63354: PUSH
63355: EMPTY
63356: LIST
63357: LIST
63358: PUSH
63359: LD_INT 1
63361: PUSH
63362: LD_INT 0
63364: PUSH
63365: EMPTY
63366: LIST
63367: LIST
63368: PUSH
63369: LD_INT 1
63371: PUSH
63372: LD_INT 1
63374: PUSH
63375: EMPTY
63376: LIST
63377: LIST
63378: PUSH
63379: LD_INT 0
63381: PUSH
63382: LD_INT 1
63384: PUSH
63385: EMPTY
63386: LIST
63387: LIST
63388: PUSH
63389: LD_INT 1
63391: NEG
63392: PUSH
63393: LD_INT 0
63395: PUSH
63396: EMPTY
63397: LIST
63398: LIST
63399: PUSH
63400: LD_INT 1
63402: NEG
63403: PUSH
63404: LD_INT 1
63406: NEG
63407: PUSH
63408: EMPTY
63409: LIST
63410: LIST
63411: PUSH
63412: LD_INT 1
63414: PUSH
63415: LD_INT 1
63417: NEG
63418: PUSH
63419: EMPTY
63420: LIST
63421: LIST
63422: PUSH
63423: LD_INT 2
63425: PUSH
63426: LD_INT 0
63428: PUSH
63429: EMPTY
63430: LIST
63431: LIST
63432: PUSH
63433: LD_INT 2
63435: PUSH
63436: LD_INT 1
63438: PUSH
63439: EMPTY
63440: LIST
63441: LIST
63442: PUSH
63443: LD_INT 1
63445: NEG
63446: PUSH
63447: LD_INT 1
63449: PUSH
63450: EMPTY
63451: LIST
63452: LIST
63453: PUSH
63454: LD_INT 2
63456: NEG
63457: PUSH
63458: LD_INT 0
63460: PUSH
63461: EMPTY
63462: LIST
63463: LIST
63464: PUSH
63465: LD_INT 2
63467: NEG
63468: PUSH
63469: LD_INT 1
63471: NEG
63472: PUSH
63473: EMPTY
63474: LIST
63475: LIST
63476: PUSH
63477: LD_INT 2
63479: NEG
63480: PUSH
63481: LD_INT 1
63483: PUSH
63484: EMPTY
63485: LIST
63486: LIST
63487: PUSH
63488: LD_INT 3
63490: NEG
63491: PUSH
63492: LD_INT 0
63494: PUSH
63495: EMPTY
63496: LIST
63497: LIST
63498: PUSH
63499: LD_INT 3
63501: NEG
63502: PUSH
63503: LD_INT 1
63505: NEG
63506: PUSH
63507: EMPTY
63508: LIST
63509: LIST
63510: PUSH
63511: EMPTY
63512: LIST
63513: LIST
63514: LIST
63515: LIST
63516: LIST
63517: LIST
63518: LIST
63519: LIST
63520: LIST
63521: LIST
63522: LIST
63523: LIST
63524: LIST
63525: LIST
63526: LIST
63527: LIST
63528: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
63529: LD_ADDR_VAR 0 13
63533: PUSH
63534: LD_INT 0
63536: PUSH
63537: LD_INT 0
63539: PUSH
63540: EMPTY
63541: LIST
63542: LIST
63543: PUSH
63544: LD_INT 0
63546: PUSH
63547: LD_INT 1
63549: NEG
63550: PUSH
63551: EMPTY
63552: LIST
63553: LIST
63554: PUSH
63555: LD_INT 1
63557: PUSH
63558: LD_INT 0
63560: PUSH
63561: EMPTY
63562: LIST
63563: LIST
63564: PUSH
63565: LD_INT 1
63567: PUSH
63568: LD_INT 1
63570: PUSH
63571: EMPTY
63572: LIST
63573: LIST
63574: PUSH
63575: LD_INT 0
63577: PUSH
63578: LD_INT 1
63580: PUSH
63581: EMPTY
63582: LIST
63583: LIST
63584: PUSH
63585: LD_INT 1
63587: NEG
63588: PUSH
63589: LD_INT 0
63591: PUSH
63592: EMPTY
63593: LIST
63594: LIST
63595: PUSH
63596: LD_INT 1
63598: NEG
63599: PUSH
63600: LD_INT 1
63602: NEG
63603: PUSH
63604: EMPTY
63605: LIST
63606: LIST
63607: PUSH
63608: LD_INT 1
63610: NEG
63611: PUSH
63612: LD_INT 2
63614: NEG
63615: PUSH
63616: EMPTY
63617: LIST
63618: LIST
63619: PUSH
63620: LD_INT 2
63622: PUSH
63623: LD_INT 1
63625: PUSH
63626: EMPTY
63627: LIST
63628: LIST
63629: PUSH
63630: LD_INT 2
63632: PUSH
63633: LD_INT 2
63635: PUSH
63636: EMPTY
63637: LIST
63638: LIST
63639: PUSH
63640: LD_INT 1
63642: PUSH
63643: LD_INT 2
63645: PUSH
63646: EMPTY
63647: LIST
63648: LIST
63649: PUSH
63650: LD_INT 2
63652: NEG
63653: PUSH
63654: LD_INT 1
63656: NEG
63657: PUSH
63658: EMPTY
63659: LIST
63660: LIST
63661: PUSH
63662: LD_INT 2
63664: NEG
63665: PUSH
63666: LD_INT 2
63668: NEG
63669: PUSH
63670: EMPTY
63671: LIST
63672: LIST
63673: PUSH
63674: LD_INT 2
63676: NEG
63677: PUSH
63678: LD_INT 3
63680: NEG
63681: PUSH
63682: EMPTY
63683: LIST
63684: LIST
63685: PUSH
63686: LD_INT 3
63688: NEG
63689: PUSH
63690: LD_INT 2
63692: NEG
63693: PUSH
63694: EMPTY
63695: LIST
63696: LIST
63697: PUSH
63698: LD_INT 3
63700: NEG
63701: PUSH
63702: LD_INT 3
63704: NEG
63705: PUSH
63706: EMPTY
63707: LIST
63708: LIST
63709: PUSH
63710: EMPTY
63711: LIST
63712: LIST
63713: LIST
63714: LIST
63715: LIST
63716: LIST
63717: LIST
63718: LIST
63719: LIST
63720: LIST
63721: LIST
63722: LIST
63723: LIST
63724: LIST
63725: LIST
63726: LIST
63727: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
63728: LD_ADDR_VAR 0 14
63732: PUSH
63733: LD_INT 0
63735: PUSH
63736: LD_INT 0
63738: PUSH
63739: EMPTY
63740: LIST
63741: LIST
63742: PUSH
63743: LD_INT 0
63745: PUSH
63746: LD_INT 1
63748: NEG
63749: PUSH
63750: EMPTY
63751: LIST
63752: LIST
63753: PUSH
63754: LD_INT 1
63756: PUSH
63757: LD_INT 0
63759: PUSH
63760: EMPTY
63761: LIST
63762: LIST
63763: PUSH
63764: LD_INT 1
63766: PUSH
63767: LD_INT 1
63769: PUSH
63770: EMPTY
63771: LIST
63772: LIST
63773: PUSH
63774: LD_INT 0
63776: PUSH
63777: LD_INT 1
63779: PUSH
63780: EMPTY
63781: LIST
63782: LIST
63783: PUSH
63784: LD_INT 1
63786: NEG
63787: PUSH
63788: LD_INT 0
63790: PUSH
63791: EMPTY
63792: LIST
63793: LIST
63794: PUSH
63795: LD_INT 1
63797: NEG
63798: PUSH
63799: LD_INT 1
63801: NEG
63802: PUSH
63803: EMPTY
63804: LIST
63805: LIST
63806: PUSH
63807: LD_INT 1
63809: NEG
63810: PUSH
63811: LD_INT 2
63813: NEG
63814: PUSH
63815: EMPTY
63816: LIST
63817: LIST
63818: PUSH
63819: LD_INT 0
63821: PUSH
63822: LD_INT 2
63824: NEG
63825: PUSH
63826: EMPTY
63827: LIST
63828: LIST
63829: PUSH
63830: LD_INT 1
63832: PUSH
63833: LD_INT 1
63835: NEG
63836: PUSH
63837: EMPTY
63838: LIST
63839: LIST
63840: PUSH
63841: LD_INT 1
63843: PUSH
63844: LD_INT 2
63846: PUSH
63847: EMPTY
63848: LIST
63849: LIST
63850: PUSH
63851: LD_INT 0
63853: PUSH
63854: LD_INT 2
63856: PUSH
63857: EMPTY
63858: LIST
63859: LIST
63860: PUSH
63861: LD_INT 1
63863: NEG
63864: PUSH
63865: LD_INT 1
63867: PUSH
63868: EMPTY
63869: LIST
63870: LIST
63871: PUSH
63872: LD_INT 1
63874: NEG
63875: PUSH
63876: LD_INT 3
63878: NEG
63879: PUSH
63880: EMPTY
63881: LIST
63882: LIST
63883: PUSH
63884: LD_INT 0
63886: PUSH
63887: LD_INT 3
63889: NEG
63890: PUSH
63891: EMPTY
63892: LIST
63893: LIST
63894: PUSH
63895: LD_INT 1
63897: PUSH
63898: LD_INT 2
63900: NEG
63901: PUSH
63902: EMPTY
63903: LIST
63904: LIST
63905: PUSH
63906: EMPTY
63907: LIST
63908: LIST
63909: LIST
63910: LIST
63911: LIST
63912: LIST
63913: LIST
63914: LIST
63915: LIST
63916: LIST
63917: LIST
63918: LIST
63919: LIST
63920: LIST
63921: LIST
63922: LIST
63923: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
63924: LD_ADDR_VAR 0 15
63928: PUSH
63929: LD_INT 0
63931: PUSH
63932: LD_INT 0
63934: PUSH
63935: EMPTY
63936: LIST
63937: LIST
63938: PUSH
63939: LD_INT 0
63941: PUSH
63942: LD_INT 1
63944: NEG
63945: PUSH
63946: EMPTY
63947: LIST
63948: LIST
63949: PUSH
63950: LD_INT 1
63952: PUSH
63953: LD_INT 0
63955: PUSH
63956: EMPTY
63957: LIST
63958: LIST
63959: PUSH
63960: LD_INT 1
63962: PUSH
63963: LD_INT 1
63965: PUSH
63966: EMPTY
63967: LIST
63968: LIST
63969: PUSH
63970: LD_INT 0
63972: PUSH
63973: LD_INT 1
63975: PUSH
63976: EMPTY
63977: LIST
63978: LIST
63979: PUSH
63980: LD_INT 1
63982: NEG
63983: PUSH
63984: LD_INT 0
63986: PUSH
63987: EMPTY
63988: LIST
63989: LIST
63990: PUSH
63991: LD_INT 1
63993: NEG
63994: PUSH
63995: LD_INT 1
63997: NEG
63998: PUSH
63999: EMPTY
64000: LIST
64001: LIST
64002: PUSH
64003: LD_INT 1
64005: PUSH
64006: LD_INT 1
64008: NEG
64009: PUSH
64010: EMPTY
64011: LIST
64012: LIST
64013: PUSH
64014: LD_INT 2
64016: PUSH
64017: LD_INT 0
64019: PUSH
64020: EMPTY
64021: LIST
64022: LIST
64023: PUSH
64024: LD_INT 2
64026: PUSH
64027: LD_INT 1
64029: PUSH
64030: EMPTY
64031: LIST
64032: LIST
64033: PUSH
64034: LD_INT 1
64036: NEG
64037: PUSH
64038: LD_INT 1
64040: PUSH
64041: EMPTY
64042: LIST
64043: LIST
64044: PUSH
64045: LD_INT 2
64047: NEG
64048: PUSH
64049: LD_INT 0
64051: PUSH
64052: EMPTY
64053: LIST
64054: LIST
64055: PUSH
64056: LD_INT 2
64058: NEG
64059: PUSH
64060: LD_INT 1
64062: NEG
64063: PUSH
64064: EMPTY
64065: LIST
64066: LIST
64067: PUSH
64068: LD_INT 2
64070: PUSH
64071: LD_INT 1
64073: NEG
64074: PUSH
64075: EMPTY
64076: LIST
64077: LIST
64078: PUSH
64079: LD_INT 3
64081: PUSH
64082: LD_INT 0
64084: PUSH
64085: EMPTY
64086: LIST
64087: LIST
64088: PUSH
64089: LD_INT 3
64091: PUSH
64092: LD_INT 1
64094: PUSH
64095: EMPTY
64096: LIST
64097: LIST
64098: PUSH
64099: EMPTY
64100: LIST
64101: LIST
64102: LIST
64103: LIST
64104: LIST
64105: LIST
64106: LIST
64107: LIST
64108: LIST
64109: LIST
64110: LIST
64111: LIST
64112: LIST
64113: LIST
64114: LIST
64115: LIST
64116: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
64117: LD_ADDR_VAR 0 16
64121: PUSH
64122: LD_INT 0
64124: PUSH
64125: LD_INT 0
64127: PUSH
64128: EMPTY
64129: LIST
64130: LIST
64131: PUSH
64132: LD_INT 0
64134: PUSH
64135: LD_INT 1
64137: NEG
64138: PUSH
64139: EMPTY
64140: LIST
64141: LIST
64142: PUSH
64143: LD_INT 1
64145: PUSH
64146: LD_INT 0
64148: PUSH
64149: EMPTY
64150: LIST
64151: LIST
64152: PUSH
64153: LD_INT 1
64155: PUSH
64156: LD_INT 1
64158: PUSH
64159: EMPTY
64160: LIST
64161: LIST
64162: PUSH
64163: LD_INT 0
64165: PUSH
64166: LD_INT 1
64168: PUSH
64169: EMPTY
64170: LIST
64171: LIST
64172: PUSH
64173: LD_INT 1
64175: NEG
64176: PUSH
64177: LD_INT 0
64179: PUSH
64180: EMPTY
64181: LIST
64182: LIST
64183: PUSH
64184: LD_INT 1
64186: NEG
64187: PUSH
64188: LD_INT 1
64190: NEG
64191: PUSH
64192: EMPTY
64193: LIST
64194: LIST
64195: PUSH
64196: LD_INT 1
64198: NEG
64199: PUSH
64200: LD_INT 2
64202: NEG
64203: PUSH
64204: EMPTY
64205: LIST
64206: LIST
64207: PUSH
64208: LD_INT 2
64210: PUSH
64211: LD_INT 1
64213: PUSH
64214: EMPTY
64215: LIST
64216: LIST
64217: PUSH
64218: LD_INT 2
64220: PUSH
64221: LD_INT 2
64223: PUSH
64224: EMPTY
64225: LIST
64226: LIST
64227: PUSH
64228: LD_INT 1
64230: PUSH
64231: LD_INT 2
64233: PUSH
64234: EMPTY
64235: LIST
64236: LIST
64237: PUSH
64238: LD_INT 2
64240: NEG
64241: PUSH
64242: LD_INT 1
64244: NEG
64245: PUSH
64246: EMPTY
64247: LIST
64248: LIST
64249: PUSH
64250: LD_INT 2
64252: NEG
64253: PUSH
64254: LD_INT 2
64256: NEG
64257: PUSH
64258: EMPTY
64259: LIST
64260: LIST
64261: PUSH
64262: LD_INT 3
64264: PUSH
64265: LD_INT 2
64267: PUSH
64268: EMPTY
64269: LIST
64270: LIST
64271: PUSH
64272: LD_INT 3
64274: PUSH
64275: LD_INT 3
64277: PUSH
64278: EMPTY
64279: LIST
64280: LIST
64281: PUSH
64282: LD_INT 2
64284: PUSH
64285: LD_INT 3
64287: PUSH
64288: EMPTY
64289: LIST
64290: LIST
64291: PUSH
64292: EMPTY
64293: LIST
64294: LIST
64295: LIST
64296: LIST
64297: LIST
64298: LIST
64299: LIST
64300: LIST
64301: LIST
64302: LIST
64303: LIST
64304: LIST
64305: LIST
64306: LIST
64307: LIST
64308: LIST
64309: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64310: LD_ADDR_VAR 0 17
64314: PUSH
64315: LD_INT 0
64317: PUSH
64318: LD_INT 0
64320: PUSH
64321: EMPTY
64322: LIST
64323: LIST
64324: PUSH
64325: LD_INT 0
64327: PUSH
64328: LD_INT 1
64330: NEG
64331: PUSH
64332: EMPTY
64333: LIST
64334: LIST
64335: PUSH
64336: LD_INT 1
64338: PUSH
64339: LD_INT 0
64341: PUSH
64342: EMPTY
64343: LIST
64344: LIST
64345: PUSH
64346: LD_INT 1
64348: PUSH
64349: LD_INT 1
64351: PUSH
64352: EMPTY
64353: LIST
64354: LIST
64355: PUSH
64356: LD_INT 0
64358: PUSH
64359: LD_INT 1
64361: PUSH
64362: EMPTY
64363: LIST
64364: LIST
64365: PUSH
64366: LD_INT 1
64368: NEG
64369: PUSH
64370: LD_INT 0
64372: PUSH
64373: EMPTY
64374: LIST
64375: LIST
64376: PUSH
64377: LD_INT 1
64379: NEG
64380: PUSH
64381: LD_INT 1
64383: NEG
64384: PUSH
64385: EMPTY
64386: LIST
64387: LIST
64388: PUSH
64389: LD_INT 1
64391: NEG
64392: PUSH
64393: LD_INT 2
64395: NEG
64396: PUSH
64397: EMPTY
64398: LIST
64399: LIST
64400: PUSH
64401: LD_INT 0
64403: PUSH
64404: LD_INT 2
64406: NEG
64407: PUSH
64408: EMPTY
64409: LIST
64410: LIST
64411: PUSH
64412: LD_INT 1
64414: PUSH
64415: LD_INT 1
64417: NEG
64418: PUSH
64419: EMPTY
64420: LIST
64421: LIST
64422: PUSH
64423: LD_INT 2
64425: PUSH
64426: LD_INT 0
64428: PUSH
64429: EMPTY
64430: LIST
64431: LIST
64432: PUSH
64433: LD_INT 2
64435: PUSH
64436: LD_INT 1
64438: PUSH
64439: EMPTY
64440: LIST
64441: LIST
64442: PUSH
64443: LD_INT 2
64445: PUSH
64446: LD_INT 2
64448: PUSH
64449: EMPTY
64450: LIST
64451: LIST
64452: PUSH
64453: LD_INT 1
64455: PUSH
64456: LD_INT 2
64458: PUSH
64459: EMPTY
64460: LIST
64461: LIST
64462: PUSH
64463: LD_INT 0
64465: PUSH
64466: LD_INT 2
64468: PUSH
64469: EMPTY
64470: LIST
64471: LIST
64472: PUSH
64473: LD_INT 1
64475: NEG
64476: PUSH
64477: LD_INT 1
64479: PUSH
64480: EMPTY
64481: LIST
64482: LIST
64483: PUSH
64484: LD_INT 2
64486: NEG
64487: PUSH
64488: LD_INT 0
64490: PUSH
64491: EMPTY
64492: LIST
64493: LIST
64494: PUSH
64495: LD_INT 2
64497: NEG
64498: PUSH
64499: LD_INT 1
64501: NEG
64502: PUSH
64503: EMPTY
64504: LIST
64505: LIST
64506: PUSH
64507: LD_INT 2
64509: NEG
64510: PUSH
64511: LD_INT 2
64513: NEG
64514: PUSH
64515: EMPTY
64516: LIST
64517: LIST
64518: PUSH
64519: EMPTY
64520: LIST
64521: LIST
64522: LIST
64523: LIST
64524: LIST
64525: LIST
64526: LIST
64527: LIST
64528: LIST
64529: LIST
64530: LIST
64531: LIST
64532: LIST
64533: LIST
64534: LIST
64535: LIST
64536: LIST
64537: LIST
64538: LIST
64539: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64540: LD_ADDR_VAR 0 18
64544: PUSH
64545: LD_INT 0
64547: PUSH
64548: LD_INT 0
64550: PUSH
64551: EMPTY
64552: LIST
64553: LIST
64554: PUSH
64555: LD_INT 0
64557: PUSH
64558: LD_INT 1
64560: NEG
64561: PUSH
64562: EMPTY
64563: LIST
64564: LIST
64565: PUSH
64566: LD_INT 1
64568: PUSH
64569: LD_INT 0
64571: PUSH
64572: EMPTY
64573: LIST
64574: LIST
64575: PUSH
64576: LD_INT 1
64578: PUSH
64579: LD_INT 1
64581: PUSH
64582: EMPTY
64583: LIST
64584: LIST
64585: PUSH
64586: LD_INT 0
64588: PUSH
64589: LD_INT 1
64591: PUSH
64592: EMPTY
64593: LIST
64594: LIST
64595: PUSH
64596: LD_INT 1
64598: NEG
64599: PUSH
64600: LD_INT 0
64602: PUSH
64603: EMPTY
64604: LIST
64605: LIST
64606: PUSH
64607: LD_INT 1
64609: NEG
64610: PUSH
64611: LD_INT 1
64613: NEG
64614: PUSH
64615: EMPTY
64616: LIST
64617: LIST
64618: PUSH
64619: LD_INT 1
64621: NEG
64622: PUSH
64623: LD_INT 2
64625: NEG
64626: PUSH
64627: EMPTY
64628: LIST
64629: LIST
64630: PUSH
64631: LD_INT 0
64633: PUSH
64634: LD_INT 2
64636: NEG
64637: PUSH
64638: EMPTY
64639: LIST
64640: LIST
64641: PUSH
64642: LD_INT 1
64644: PUSH
64645: LD_INT 1
64647: NEG
64648: PUSH
64649: EMPTY
64650: LIST
64651: LIST
64652: PUSH
64653: LD_INT 2
64655: PUSH
64656: LD_INT 0
64658: PUSH
64659: EMPTY
64660: LIST
64661: LIST
64662: PUSH
64663: LD_INT 2
64665: PUSH
64666: LD_INT 1
64668: PUSH
64669: EMPTY
64670: LIST
64671: LIST
64672: PUSH
64673: LD_INT 2
64675: PUSH
64676: LD_INT 2
64678: PUSH
64679: EMPTY
64680: LIST
64681: LIST
64682: PUSH
64683: LD_INT 1
64685: PUSH
64686: LD_INT 2
64688: PUSH
64689: EMPTY
64690: LIST
64691: LIST
64692: PUSH
64693: LD_INT 0
64695: PUSH
64696: LD_INT 2
64698: PUSH
64699: EMPTY
64700: LIST
64701: LIST
64702: PUSH
64703: LD_INT 1
64705: NEG
64706: PUSH
64707: LD_INT 1
64709: PUSH
64710: EMPTY
64711: LIST
64712: LIST
64713: PUSH
64714: LD_INT 2
64716: NEG
64717: PUSH
64718: LD_INT 0
64720: PUSH
64721: EMPTY
64722: LIST
64723: LIST
64724: PUSH
64725: LD_INT 2
64727: NEG
64728: PUSH
64729: LD_INT 1
64731: NEG
64732: PUSH
64733: EMPTY
64734: LIST
64735: LIST
64736: PUSH
64737: LD_INT 2
64739: NEG
64740: PUSH
64741: LD_INT 2
64743: NEG
64744: PUSH
64745: EMPTY
64746: LIST
64747: LIST
64748: PUSH
64749: EMPTY
64750: LIST
64751: LIST
64752: LIST
64753: LIST
64754: LIST
64755: LIST
64756: LIST
64757: LIST
64758: LIST
64759: LIST
64760: LIST
64761: LIST
64762: LIST
64763: LIST
64764: LIST
64765: LIST
64766: LIST
64767: LIST
64768: LIST
64769: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64770: LD_ADDR_VAR 0 19
64774: PUSH
64775: LD_INT 0
64777: PUSH
64778: LD_INT 0
64780: PUSH
64781: EMPTY
64782: LIST
64783: LIST
64784: PUSH
64785: LD_INT 0
64787: PUSH
64788: LD_INT 1
64790: NEG
64791: PUSH
64792: EMPTY
64793: LIST
64794: LIST
64795: PUSH
64796: LD_INT 1
64798: PUSH
64799: LD_INT 0
64801: PUSH
64802: EMPTY
64803: LIST
64804: LIST
64805: PUSH
64806: LD_INT 1
64808: PUSH
64809: LD_INT 1
64811: PUSH
64812: EMPTY
64813: LIST
64814: LIST
64815: PUSH
64816: LD_INT 0
64818: PUSH
64819: LD_INT 1
64821: PUSH
64822: EMPTY
64823: LIST
64824: LIST
64825: PUSH
64826: LD_INT 1
64828: NEG
64829: PUSH
64830: LD_INT 0
64832: PUSH
64833: EMPTY
64834: LIST
64835: LIST
64836: PUSH
64837: LD_INT 1
64839: NEG
64840: PUSH
64841: LD_INT 1
64843: NEG
64844: PUSH
64845: EMPTY
64846: LIST
64847: LIST
64848: PUSH
64849: LD_INT 1
64851: NEG
64852: PUSH
64853: LD_INT 2
64855: NEG
64856: PUSH
64857: EMPTY
64858: LIST
64859: LIST
64860: PUSH
64861: LD_INT 0
64863: PUSH
64864: LD_INT 2
64866: NEG
64867: PUSH
64868: EMPTY
64869: LIST
64870: LIST
64871: PUSH
64872: LD_INT 1
64874: PUSH
64875: LD_INT 1
64877: NEG
64878: PUSH
64879: EMPTY
64880: LIST
64881: LIST
64882: PUSH
64883: LD_INT 2
64885: PUSH
64886: LD_INT 0
64888: PUSH
64889: EMPTY
64890: LIST
64891: LIST
64892: PUSH
64893: LD_INT 2
64895: PUSH
64896: LD_INT 1
64898: PUSH
64899: EMPTY
64900: LIST
64901: LIST
64902: PUSH
64903: LD_INT 2
64905: PUSH
64906: LD_INT 2
64908: PUSH
64909: EMPTY
64910: LIST
64911: LIST
64912: PUSH
64913: LD_INT 1
64915: PUSH
64916: LD_INT 2
64918: PUSH
64919: EMPTY
64920: LIST
64921: LIST
64922: PUSH
64923: LD_INT 0
64925: PUSH
64926: LD_INT 2
64928: PUSH
64929: EMPTY
64930: LIST
64931: LIST
64932: PUSH
64933: LD_INT 1
64935: NEG
64936: PUSH
64937: LD_INT 1
64939: PUSH
64940: EMPTY
64941: LIST
64942: LIST
64943: PUSH
64944: LD_INT 2
64946: NEG
64947: PUSH
64948: LD_INT 0
64950: PUSH
64951: EMPTY
64952: LIST
64953: LIST
64954: PUSH
64955: LD_INT 2
64957: NEG
64958: PUSH
64959: LD_INT 1
64961: NEG
64962: PUSH
64963: EMPTY
64964: LIST
64965: LIST
64966: PUSH
64967: LD_INT 2
64969: NEG
64970: PUSH
64971: LD_INT 2
64973: NEG
64974: PUSH
64975: EMPTY
64976: LIST
64977: LIST
64978: PUSH
64979: EMPTY
64980: LIST
64981: LIST
64982: LIST
64983: LIST
64984: LIST
64985: LIST
64986: LIST
64987: LIST
64988: LIST
64989: LIST
64990: LIST
64991: LIST
64992: LIST
64993: LIST
64994: LIST
64995: LIST
64996: LIST
64997: LIST
64998: LIST
64999: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65000: LD_ADDR_VAR 0 20
65004: PUSH
65005: LD_INT 0
65007: PUSH
65008: LD_INT 0
65010: PUSH
65011: EMPTY
65012: LIST
65013: LIST
65014: PUSH
65015: LD_INT 0
65017: PUSH
65018: LD_INT 1
65020: NEG
65021: PUSH
65022: EMPTY
65023: LIST
65024: LIST
65025: PUSH
65026: LD_INT 1
65028: PUSH
65029: LD_INT 0
65031: PUSH
65032: EMPTY
65033: LIST
65034: LIST
65035: PUSH
65036: LD_INT 1
65038: PUSH
65039: LD_INT 1
65041: PUSH
65042: EMPTY
65043: LIST
65044: LIST
65045: PUSH
65046: LD_INT 0
65048: PUSH
65049: LD_INT 1
65051: PUSH
65052: EMPTY
65053: LIST
65054: LIST
65055: PUSH
65056: LD_INT 1
65058: NEG
65059: PUSH
65060: LD_INT 0
65062: PUSH
65063: EMPTY
65064: LIST
65065: LIST
65066: PUSH
65067: LD_INT 1
65069: NEG
65070: PUSH
65071: LD_INT 1
65073: NEG
65074: PUSH
65075: EMPTY
65076: LIST
65077: LIST
65078: PUSH
65079: LD_INT 1
65081: NEG
65082: PUSH
65083: LD_INT 2
65085: NEG
65086: PUSH
65087: EMPTY
65088: LIST
65089: LIST
65090: PUSH
65091: LD_INT 0
65093: PUSH
65094: LD_INT 2
65096: NEG
65097: PUSH
65098: EMPTY
65099: LIST
65100: LIST
65101: PUSH
65102: LD_INT 1
65104: PUSH
65105: LD_INT 1
65107: NEG
65108: PUSH
65109: EMPTY
65110: LIST
65111: LIST
65112: PUSH
65113: LD_INT 2
65115: PUSH
65116: LD_INT 0
65118: PUSH
65119: EMPTY
65120: LIST
65121: LIST
65122: PUSH
65123: LD_INT 2
65125: PUSH
65126: LD_INT 1
65128: PUSH
65129: EMPTY
65130: LIST
65131: LIST
65132: PUSH
65133: LD_INT 2
65135: PUSH
65136: LD_INT 2
65138: PUSH
65139: EMPTY
65140: LIST
65141: LIST
65142: PUSH
65143: LD_INT 1
65145: PUSH
65146: LD_INT 2
65148: PUSH
65149: EMPTY
65150: LIST
65151: LIST
65152: PUSH
65153: LD_INT 0
65155: PUSH
65156: LD_INT 2
65158: PUSH
65159: EMPTY
65160: LIST
65161: LIST
65162: PUSH
65163: LD_INT 1
65165: NEG
65166: PUSH
65167: LD_INT 1
65169: PUSH
65170: EMPTY
65171: LIST
65172: LIST
65173: PUSH
65174: LD_INT 2
65176: NEG
65177: PUSH
65178: LD_INT 0
65180: PUSH
65181: EMPTY
65182: LIST
65183: LIST
65184: PUSH
65185: LD_INT 2
65187: NEG
65188: PUSH
65189: LD_INT 1
65191: NEG
65192: PUSH
65193: EMPTY
65194: LIST
65195: LIST
65196: PUSH
65197: LD_INT 2
65199: NEG
65200: PUSH
65201: LD_INT 2
65203: NEG
65204: PUSH
65205: EMPTY
65206: LIST
65207: LIST
65208: PUSH
65209: EMPTY
65210: LIST
65211: LIST
65212: LIST
65213: LIST
65214: LIST
65215: LIST
65216: LIST
65217: LIST
65218: LIST
65219: LIST
65220: LIST
65221: LIST
65222: LIST
65223: LIST
65224: LIST
65225: LIST
65226: LIST
65227: LIST
65228: LIST
65229: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65230: LD_ADDR_VAR 0 21
65234: PUSH
65235: LD_INT 0
65237: PUSH
65238: LD_INT 0
65240: PUSH
65241: EMPTY
65242: LIST
65243: LIST
65244: PUSH
65245: LD_INT 0
65247: PUSH
65248: LD_INT 1
65250: NEG
65251: PUSH
65252: EMPTY
65253: LIST
65254: LIST
65255: PUSH
65256: LD_INT 1
65258: PUSH
65259: LD_INT 0
65261: PUSH
65262: EMPTY
65263: LIST
65264: LIST
65265: PUSH
65266: LD_INT 1
65268: PUSH
65269: LD_INT 1
65271: PUSH
65272: EMPTY
65273: LIST
65274: LIST
65275: PUSH
65276: LD_INT 0
65278: PUSH
65279: LD_INT 1
65281: PUSH
65282: EMPTY
65283: LIST
65284: LIST
65285: PUSH
65286: LD_INT 1
65288: NEG
65289: PUSH
65290: LD_INT 0
65292: PUSH
65293: EMPTY
65294: LIST
65295: LIST
65296: PUSH
65297: LD_INT 1
65299: NEG
65300: PUSH
65301: LD_INT 1
65303: NEG
65304: PUSH
65305: EMPTY
65306: LIST
65307: LIST
65308: PUSH
65309: LD_INT 1
65311: NEG
65312: PUSH
65313: LD_INT 2
65315: NEG
65316: PUSH
65317: EMPTY
65318: LIST
65319: LIST
65320: PUSH
65321: LD_INT 0
65323: PUSH
65324: LD_INT 2
65326: NEG
65327: PUSH
65328: EMPTY
65329: LIST
65330: LIST
65331: PUSH
65332: LD_INT 1
65334: PUSH
65335: LD_INT 1
65337: NEG
65338: PUSH
65339: EMPTY
65340: LIST
65341: LIST
65342: PUSH
65343: LD_INT 2
65345: PUSH
65346: LD_INT 0
65348: PUSH
65349: EMPTY
65350: LIST
65351: LIST
65352: PUSH
65353: LD_INT 2
65355: PUSH
65356: LD_INT 1
65358: PUSH
65359: EMPTY
65360: LIST
65361: LIST
65362: PUSH
65363: LD_INT 2
65365: PUSH
65366: LD_INT 2
65368: PUSH
65369: EMPTY
65370: LIST
65371: LIST
65372: PUSH
65373: LD_INT 1
65375: PUSH
65376: LD_INT 2
65378: PUSH
65379: EMPTY
65380: LIST
65381: LIST
65382: PUSH
65383: LD_INT 0
65385: PUSH
65386: LD_INT 2
65388: PUSH
65389: EMPTY
65390: LIST
65391: LIST
65392: PUSH
65393: LD_INT 1
65395: NEG
65396: PUSH
65397: LD_INT 1
65399: PUSH
65400: EMPTY
65401: LIST
65402: LIST
65403: PUSH
65404: LD_INT 2
65406: NEG
65407: PUSH
65408: LD_INT 0
65410: PUSH
65411: EMPTY
65412: LIST
65413: LIST
65414: PUSH
65415: LD_INT 2
65417: NEG
65418: PUSH
65419: LD_INT 1
65421: NEG
65422: PUSH
65423: EMPTY
65424: LIST
65425: LIST
65426: PUSH
65427: LD_INT 2
65429: NEG
65430: PUSH
65431: LD_INT 2
65433: NEG
65434: PUSH
65435: EMPTY
65436: LIST
65437: LIST
65438: PUSH
65439: EMPTY
65440: LIST
65441: LIST
65442: LIST
65443: LIST
65444: LIST
65445: LIST
65446: LIST
65447: LIST
65448: LIST
65449: LIST
65450: LIST
65451: LIST
65452: LIST
65453: LIST
65454: LIST
65455: LIST
65456: LIST
65457: LIST
65458: LIST
65459: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65460: LD_ADDR_VAR 0 22
65464: PUSH
65465: LD_INT 0
65467: PUSH
65468: LD_INT 0
65470: PUSH
65471: EMPTY
65472: LIST
65473: LIST
65474: PUSH
65475: LD_INT 0
65477: PUSH
65478: LD_INT 1
65480: NEG
65481: PUSH
65482: EMPTY
65483: LIST
65484: LIST
65485: PUSH
65486: LD_INT 1
65488: PUSH
65489: LD_INT 0
65491: PUSH
65492: EMPTY
65493: LIST
65494: LIST
65495: PUSH
65496: LD_INT 1
65498: PUSH
65499: LD_INT 1
65501: PUSH
65502: EMPTY
65503: LIST
65504: LIST
65505: PUSH
65506: LD_INT 0
65508: PUSH
65509: LD_INT 1
65511: PUSH
65512: EMPTY
65513: LIST
65514: LIST
65515: PUSH
65516: LD_INT 1
65518: NEG
65519: PUSH
65520: LD_INT 0
65522: PUSH
65523: EMPTY
65524: LIST
65525: LIST
65526: PUSH
65527: LD_INT 1
65529: NEG
65530: PUSH
65531: LD_INT 1
65533: NEG
65534: PUSH
65535: EMPTY
65536: LIST
65537: LIST
65538: PUSH
65539: LD_INT 1
65541: NEG
65542: PUSH
65543: LD_INT 2
65545: NEG
65546: PUSH
65547: EMPTY
65548: LIST
65549: LIST
65550: PUSH
65551: LD_INT 0
65553: PUSH
65554: LD_INT 2
65556: NEG
65557: PUSH
65558: EMPTY
65559: LIST
65560: LIST
65561: PUSH
65562: LD_INT 1
65564: PUSH
65565: LD_INT 1
65567: NEG
65568: PUSH
65569: EMPTY
65570: LIST
65571: LIST
65572: PUSH
65573: LD_INT 2
65575: PUSH
65576: LD_INT 0
65578: PUSH
65579: EMPTY
65580: LIST
65581: LIST
65582: PUSH
65583: LD_INT 2
65585: PUSH
65586: LD_INT 1
65588: PUSH
65589: EMPTY
65590: LIST
65591: LIST
65592: PUSH
65593: LD_INT 2
65595: PUSH
65596: LD_INT 2
65598: PUSH
65599: EMPTY
65600: LIST
65601: LIST
65602: PUSH
65603: LD_INT 1
65605: PUSH
65606: LD_INT 2
65608: PUSH
65609: EMPTY
65610: LIST
65611: LIST
65612: PUSH
65613: LD_INT 0
65615: PUSH
65616: LD_INT 2
65618: PUSH
65619: EMPTY
65620: LIST
65621: LIST
65622: PUSH
65623: LD_INT 1
65625: NEG
65626: PUSH
65627: LD_INT 1
65629: PUSH
65630: EMPTY
65631: LIST
65632: LIST
65633: PUSH
65634: LD_INT 2
65636: NEG
65637: PUSH
65638: LD_INT 0
65640: PUSH
65641: EMPTY
65642: LIST
65643: LIST
65644: PUSH
65645: LD_INT 2
65647: NEG
65648: PUSH
65649: LD_INT 1
65651: NEG
65652: PUSH
65653: EMPTY
65654: LIST
65655: LIST
65656: PUSH
65657: LD_INT 2
65659: NEG
65660: PUSH
65661: LD_INT 2
65663: NEG
65664: PUSH
65665: EMPTY
65666: LIST
65667: LIST
65668: PUSH
65669: EMPTY
65670: LIST
65671: LIST
65672: LIST
65673: LIST
65674: LIST
65675: LIST
65676: LIST
65677: LIST
65678: LIST
65679: LIST
65680: LIST
65681: LIST
65682: LIST
65683: LIST
65684: LIST
65685: LIST
65686: LIST
65687: LIST
65688: LIST
65689: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
65690: LD_ADDR_VAR 0 23
65694: PUSH
65695: LD_INT 0
65697: PUSH
65698: LD_INT 0
65700: PUSH
65701: EMPTY
65702: LIST
65703: LIST
65704: PUSH
65705: LD_INT 0
65707: PUSH
65708: LD_INT 1
65710: NEG
65711: PUSH
65712: EMPTY
65713: LIST
65714: LIST
65715: PUSH
65716: LD_INT 1
65718: PUSH
65719: LD_INT 0
65721: PUSH
65722: EMPTY
65723: LIST
65724: LIST
65725: PUSH
65726: LD_INT 1
65728: PUSH
65729: LD_INT 1
65731: PUSH
65732: EMPTY
65733: LIST
65734: LIST
65735: PUSH
65736: LD_INT 0
65738: PUSH
65739: LD_INT 1
65741: PUSH
65742: EMPTY
65743: LIST
65744: LIST
65745: PUSH
65746: LD_INT 1
65748: NEG
65749: PUSH
65750: LD_INT 0
65752: PUSH
65753: EMPTY
65754: LIST
65755: LIST
65756: PUSH
65757: LD_INT 1
65759: NEG
65760: PUSH
65761: LD_INT 1
65763: NEG
65764: PUSH
65765: EMPTY
65766: LIST
65767: LIST
65768: PUSH
65769: LD_INT 1
65771: NEG
65772: PUSH
65773: LD_INT 2
65775: NEG
65776: PUSH
65777: EMPTY
65778: LIST
65779: LIST
65780: PUSH
65781: LD_INT 0
65783: PUSH
65784: LD_INT 2
65786: NEG
65787: PUSH
65788: EMPTY
65789: LIST
65790: LIST
65791: PUSH
65792: LD_INT 1
65794: PUSH
65795: LD_INT 1
65797: NEG
65798: PUSH
65799: EMPTY
65800: LIST
65801: LIST
65802: PUSH
65803: LD_INT 2
65805: PUSH
65806: LD_INT 0
65808: PUSH
65809: EMPTY
65810: LIST
65811: LIST
65812: PUSH
65813: LD_INT 2
65815: PUSH
65816: LD_INT 1
65818: PUSH
65819: EMPTY
65820: LIST
65821: LIST
65822: PUSH
65823: LD_INT 2
65825: PUSH
65826: LD_INT 2
65828: PUSH
65829: EMPTY
65830: LIST
65831: LIST
65832: PUSH
65833: LD_INT 1
65835: PUSH
65836: LD_INT 2
65838: PUSH
65839: EMPTY
65840: LIST
65841: LIST
65842: PUSH
65843: LD_INT 0
65845: PUSH
65846: LD_INT 2
65848: PUSH
65849: EMPTY
65850: LIST
65851: LIST
65852: PUSH
65853: LD_INT 1
65855: NEG
65856: PUSH
65857: LD_INT 1
65859: PUSH
65860: EMPTY
65861: LIST
65862: LIST
65863: PUSH
65864: LD_INT 2
65866: NEG
65867: PUSH
65868: LD_INT 0
65870: PUSH
65871: EMPTY
65872: LIST
65873: LIST
65874: PUSH
65875: LD_INT 2
65877: NEG
65878: PUSH
65879: LD_INT 1
65881: NEG
65882: PUSH
65883: EMPTY
65884: LIST
65885: LIST
65886: PUSH
65887: LD_INT 2
65889: NEG
65890: PUSH
65891: LD_INT 2
65893: NEG
65894: PUSH
65895: EMPTY
65896: LIST
65897: LIST
65898: PUSH
65899: LD_INT 2
65901: NEG
65902: PUSH
65903: LD_INT 3
65905: NEG
65906: PUSH
65907: EMPTY
65908: LIST
65909: LIST
65910: PUSH
65911: LD_INT 1
65913: NEG
65914: PUSH
65915: LD_INT 3
65917: NEG
65918: PUSH
65919: EMPTY
65920: LIST
65921: LIST
65922: PUSH
65923: LD_INT 1
65925: PUSH
65926: LD_INT 2
65928: NEG
65929: PUSH
65930: EMPTY
65931: LIST
65932: LIST
65933: PUSH
65934: LD_INT 2
65936: PUSH
65937: LD_INT 1
65939: NEG
65940: PUSH
65941: EMPTY
65942: LIST
65943: LIST
65944: PUSH
65945: EMPTY
65946: LIST
65947: LIST
65948: LIST
65949: LIST
65950: LIST
65951: LIST
65952: LIST
65953: LIST
65954: LIST
65955: LIST
65956: LIST
65957: LIST
65958: LIST
65959: LIST
65960: LIST
65961: LIST
65962: LIST
65963: LIST
65964: LIST
65965: LIST
65966: LIST
65967: LIST
65968: LIST
65969: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
65970: LD_ADDR_VAR 0 24
65974: PUSH
65975: LD_INT 0
65977: PUSH
65978: LD_INT 0
65980: PUSH
65981: EMPTY
65982: LIST
65983: LIST
65984: PUSH
65985: LD_INT 0
65987: PUSH
65988: LD_INT 1
65990: NEG
65991: PUSH
65992: EMPTY
65993: LIST
65994: LIST
65995: PUSH
65996: LD_INT 1
65998: PUSH
65999: LD_INT 0
66001: PUSH
66002: EMPTY
66003: LIST
66004: LIST
66005: PUSH
66006: LD_INT 1
66008: PUSH
66009: LD_INT 1
66011: PUSH
66012: EMPTY
66013: LIST
66014: LIST
66015: PUSH
66016: LD_INT 0
66018: PUSH
66019: LD_INT 1
66021: PUSH
66022: EMPTY
66023: LIST
66024: LIST
66025: PUSH
66026: LD_INT 1
66028: NEG
66029: PUSH
66030: LD_INT 0
66032: PUSH
66033: EMPTY
66034: LIST
66035: LIST
66036: PUSH
66037: LD_INT 1
66039: NEG
66040: PUSH
66041: LD_INT 1
66043: NEG
66044: PUSH
66045: EMPTY
66046: LIST
66047: LIST
66048: PUSH
66049: LD_INT 1
66051: NEG
66052: PUSH
66053: LD_INT 2
66055: NEG
66056: PUSH
66057: EMPTY
66058: LIST
66059: LIST
66060: PUSH
66061: LD_INT 0
66063: PUSH
66064: LD_INT 2
66066: NEG
66067: PUSH
66068: EMPTY
66069: LIST
66070: LIST
66071: PUSH
66072: LD_INT 1
66074: PUSH
66075: LD_INT 1
66077: NEG
66078: PUSH
66079: EMPTY
66080: LIST
66081: LIST
66082: PUSH
66083: LD_INT 2
66085: PUSH
66086: LD_INT 0
66088: PUSH
66089: EMPTY
66090: LIST
66091: LIST
66092: PUSH
66093: LD_INT 2
66095: PUSH
66096: LD_INT 1
66098: PUSH
66099: EMPTY
66100: LIST
66101: LIST
66102: PUSH
66103: LD_INT 2
66105: PUSH
66106: LD_INT 2
66108: PUSH
66109: EMPTY
66110: LIST
66111: LIST
66112: PUSH
66113: LD_INT 1
66115: PUSH
66116: LD_INT 2
66118: PUSH
66119: EMPTY
66120: LIST
66121: LIST
66122: PUSH
66123: LD_INT 0
66125: PUSH
66126: LD_INT 2
66128: PUSH
66129: EMPTY
66130: LIST
66131: LIST
66132: PUSH
66133: LD_INT 1
66135: NEG
66136: PUSH
66137: LD_INT 1
66139: PUSH
66140: EMPTY
66141: LIST
66142: LIST
66143: PUSH
66144: LD_INT 2
66146: NEG
66147: PUSH
66148: LD_INT 0
66150: PUSH
66151: EMPTY
66152: LIST
66153: LIST
66154: PUSH
66155: LD_INT 2
66157: NEG
66158: PUSH
66159: LD_INT 1
66161: NEG
66162: PUSH
66163: EMPTY
66164: LIST
66165: LIST
66166: PUSH
66167: LD_INT 2
66169: NEG
66170: PUSH
66171: LD_INT 2
66173: NEG
66174: PUSH
66175: EMPTY
66176: LIST
66177: LIST
66178: PUSH
66179: LD_INT 1
66181: PUSH
66182: LD_INT 2
66184: NEG
66185: PUSH
66186: EMPTY
66187: LIST
66188: LIST
66189: PUSH
66190: LD_INT 2
66192: PUSH
66193: LD_INT 1
66195: NEG
66196: PUSH
66197: EMPTY
66198: LIST
66199: LIST
66200: PUSH
66201: LD_INT 3
66203: PUSH
66204: LD_INT 1
66206: PUSH
66207: EMPTY
66208: LIST
66209: LIST
66210: PUSH
66211: LD_INT 3
66213: PUSH
66214: LD_INT 2
66216: PUSH
66217: EMPTY
66218: LIST
66219: LIST
66220: PUSH
66221: EMPTY
66222: LIST
66223: LIST
66224: LIST
66225: LIST
66226: LIST
66227: LIST
66228: LIST
66229: LIST
66230: LIST
66231: LIST
66232: LIST
66233: LIST
66234: LIST
66235: LIST
66236: LIST
66237: LIST
66238: LIST
66239: LIST
66240: LIST
66241: LIST
66242: LIST
66243: LIST
66244: LIST
66245: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
66246: LD_ADDR_VAR 0 25
66250: PUSH
66251: LD_INT 0
66253: PUSH
66254: LD_INT 0
66256: PUSH
66257: EMPTY
66258: LIST
66259: LIST
66260: PUSH
66261: LD_INT 0
66263: PUSH
66264: LD_INT 1
66266: NEG
66267: PUSH
66268: EMPTY
66269: LIST
66270: LIST
66271: PUSH
66272: LD_INT 1
66274: PUSH
66275: LD_INT 0
66277: PUSH
66278: EMPTY
66279: LIST
66280: LIST
66281: PUSH
66282: LD_INT 1
66284: PUSH
66285: LD_INT 1
66287: PUSH
66288: EMPTY
66289: LIST
66290: LIST
66291: PUSH
66292: LD_INT 0
66294: PUSH
66295: LD_INT 1
66297: PUSH
66298: EMPTY
66299: LIST
66300: LIST
66301: PUSH
66302: LD_INT 1
66304: NEG
66305: PUSH
66306: LD_INT 0
66308: PUSH
66309: EMPTY
66310: LIST
66311: LIST
66312: PUSH
66313: LD_INT 1
66315: NEG
66316: PUSH
66317: LD_INT 1
66319: NEG
66320: PUSH
66321: EMPTY
66322: LIST
66323: LIST
66324: PUSH
66325: LD_INT 1
66327: NEG
66328: PUSH
66329: LD_INT 2
66331: NEG
66332: PUSH
66333: EMPTY
66334: LIST
66335: LIST
66336: PUSH
66337: LD_INT 0
66339: PUSH
66340: LD_INT 2
66342: NEG
66343: PUSH
66344: EMPTY
66345: LIST
66346: LIST
66347: PUSH
66348: LD_INT 1
66350: PUSH
66351: LD_INT 1
66353: NEG
66354: PUSH
66355: EMPTY
66356: LIST
66357: LIST
66358: PUSH
66359: LD_INT 2
66361: PUSH
66362: LD_INT 0
66364: PUSH
66365: EMPTY
66366: LIST
66367: LIST
66368: PUSH
66369: LD_INT 2
66371: PUSH
66372: LD_INT 1
66374: PUSH
66375: EMPTY
66376: LIST
66377: LIST
66378: PUSH
66379: LD_INT 2
66381: PUSH
66382: LD_INT 2
66384: PUSH
66385: EMPTY
66386: LIST
66387: LIST
66388: PUSH
66389: LD_INT 1
66391: PUSH
66392: LD_INT 2
66394: PUSH
66395: EMPTY
66396: LIST
66397: LIST
66398: PUSH
66399: LD_INT 0
66401: PUSH
66402: LD_INT 2
66404: PUSH
66405: EMPTY
66406: LIST
66407: LIST
66408: PUSH
66409: LD_INT 1
66411: NEG
66412: PUSH
66413: LD_INT 1
66415: PUSH
66416: EMPTY
66417: LIST
66418: LIST
66419: PUSH
66420: LD_INT 2
66422: NEG
66423: PUSH
66424: LD_INT 0
66426: PUSH
66427: EMPTY
66428: LIST
66429: LIST
66430: PUSH
66431: LD_INT 2
66433: NEG
66434: PUSH
66435: LD_INT 1
66437: NEG
66438: PUSH
66439: EMPTY
66440: LIST
66441: LIST
66442: PUSH
66443: LD_INT 2
66445: NEG
66446: PUSH
66447: LD_INT 2
66449: NEG
66450: PUSH
66451: EMPTY
66452: LIST
66453: LIST
66454: PUSH
66455: LD_INT 3
66457: PUSH
66458: LD_INT 1
66460: PUSH
66461: EMPTY
66462: LIST
66463: LIST
66464: PUSH
66465: LD_INT 3
66467: PUSH
66468: LD_INT 2
66470: PUSH
66471: EMPTY
66472: LIST
66473: LIST
66474: PUSH
66475: LD_INT 2
66477: PUSH
66478: LD_INT 3
66480: PUSH
66481: EMPTY
66482: LIST
66483: LIST
66484: PUSH
66485: LD_INT 1
66487: PUSH
66488: LD_INT 3
66490: PUSH
66491: EMPTY
66492: LIST
66493: LIST
66494: PUSH
66495: EMPTY
66496: LIST
66497: LIST
66498: LIST
66499: LIST
66500: LIST
66501: LIST
66502: LIST
66503: LIST
66504: LIST
66505: LIST
66506: LIST
66507: LIST
66508: LIST
66509: LIST
66510: LIST
66511: LIST
66512: LIST
66513: LIST
66514: LIST
66515: LIST
66516: LIST
66517: LIST
66518: LIST
66519: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
66520: LD_ADDR_VAR 0 26
66524: PUSH
66525: LD_INT 0
66527: PUSH
66528: LD_INT 0
66530: PUSH
66531: EMPTY
66532: LIST
66533: LIST
66534: PUSH
66535: LD_INT 0
66537: PUSH
66538: LD_INT 1
66540: NEG
66541: PUSH
66542: EMPTY
66543: LIST
66544: LIST
66545: PUSH
66546: LD_INT 1
66548: PUSH
66549: LD_INT 0
66551: PUSH
66552: EMPTY
66553: LIST
66554: LIST
66555: PUSH
66556: LD_INT 1
66558: PUSH
66559: LD_INT 1
66561: PUSH
66562: EMPTY
66563: LIST
66564: LIST
66565: PUSH
66566: LD_INT 0
66568: PUSH
66569: LD_INT 1
66571: PUSH
66572: EMPTY
66573: LIST
66574: LIST
66575: PUSH
66576: LD_INT 1
66578: NEG
66579: PUSH
66580: LD_INT 0
66582: PUSH
66583: EMPTY
66584: LIST
66585: LIST
66586: PUSH
66587: LD_INT 1
66589: NEG
66590: PUSH
66591: LD_INT 1
66593: NEG
66594: PUSH
66595: EMPTY
66596: LIST
66597: LIST
66598: PUSH
66599: LD_INT 1
66601: NEG
66602: PUSH
66603: LD_INT 2
66605: NEG
66606: PUSH
66607: EMPTY
66608: LIST
66609: LIST
66610: PUSH
66611: LD_INT 0
66613: PUSH
66614: LD_INT 2
66616: NEG
66617: PUSH
66618: EMPTY
66619: LIST
66620: LIST
66621: PUSH
66622: LD_INT 1
66624: PUSH
66625: LD_INT 1
66627: NEG
66628: PUSH
66629: EMPTY
66630: LIST
66631: LIST
66632: PUSH
66633: LD_INT 2
66635: PUSH
66636: LD_INT 0
66638: PUSH
66639: EMPTY
66640: LIST
66641: LIST
66642: PUSH
66643: LD_INT 2
66645: PUSH
66646: LD_INT 1
66648: PUSH
66649: EMPTY
66650: LIST
66651: LIST
66652: PUSH
66653: LD_INT 2
66655: PUSH
66656: LD_INT 2
66658: PUSH
66659: EMPTY
66660: LIST
66661: LIST
66662: PUSH
66663: LD_INT 1
66665: PUSH
66666: LD_INT 2
66668: PUSH
66669: EMPTY
66670: LIST
66671: LIST
66672: PUSH
66673: LD_INT 0
66675: PUSH
66676: LD_INT 2
66678: PUSH
66679: EMPTY
66680: LIST
66681: LIST
66682: PUSH
66683: LD_INT 1
66685: NEG
66686: PUSH
66687: LD_INT 1
66689: PUSH
66690: EMPTY
66691: LIST
66692: LIST
66693: PUSH
66694: LD_INT 2
66696: NEG
66697: PUSH
66698: LD_INT 0
66700: PUSH
66701: EMPTY
66702: LIST
66703: LIST
66704: PUSH
66705: LD_INT 2
66707: NEG
66708: PUSH
66709: LD_INT 1
66711: NEG
66712: PUSH
66713: EMPTY
66714: LIST
66715: LIST
66716: PUSH
66717: LD_INT 2
66719: NEG
66720: PUSH
66721: LD_INT 2
66723: NEG
66724: PUSH
66725: EMPTY
66726: LIST
66727: LIST
66728: PUSH
66729: LD_INT 2
66731: PUSH
66732: LD_INT 3
66734: PUSH
66735: EMPTY
66736: LIST
66737: LIST
66738: PUSH
66739: LD_INT 1
66741: PUSH
66742: LD_INT 3
66744: PUSH
66745: EMPTY
66746: LIST
66747: LIST
66748: PUSH
66749: LD_INT 1
66751: NEG
66752: PUSH
66753: LD_INT 2
66755: PUSH
66756: EMPTY
66757: LIST
66758: LIST
66759: PUSH
66760: LD_INT 2
66762: NEG
66763: PUSH
66764: LD_INT 1
66766: PUSH
66767: EMPTY
66768: LIST
66769: LIST
66770: PUSH
66771: EMPTY
66772: LIST
66773: LIST
66774: LIST
66775: LIST
66776: LIST
66777: LIST
66778: LIST
66779: LIST
66780: LIST
66781: LIST
66782: LIST
66783: LIST
66784: LIST
66785: LIST
66786: LIST
66787: LIST
66788: LIST
66789: LIST
66790: LIST
66791: LIST
66792: LIST
66793: LIST
66794: LIST
66795: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
66796: LD_ADDR_VAR 0 27
66800: PUSH
66801: LD_INT 0
66803: PUSH
66804: LD_INT 0
66806: PUSH
66807: EMPTY
66808: LIST
66809: LIST
66810: PUSH
66811: LD_INT 0
66813: PUSH
66814: LD_INT 1
66816: NEG
66817: PUSH
66818: EMPTY
66819: LIST
66820: LIST
66821: PUSH
66822: LD_INT 1
66824: PUSH
66825: LD_INT 0
66827: PUSH
66828: EMPTY
66829: LIST
66830: LIST
66831: PUSH
66832: LD_INT 1
66834: PUSH
66835: LD_INT 1
66837: PUSH
66838: EMPTY
66839: LIST
66840: LIST
66841: PUSH
66842: LD_INT 0
66844: PUSH
66845: LD_INT 1
66847: PUSH
66848: EMPTY
66849: LIST
66850: LIST
66851: PUSH
66852: LD_INT 1
66854: NEG
66855: PUSH
66856: LD_INT 0
66858: PUSH
66859: EMPTY
66860: LIST
66861: LIST
66862: PUSH
66863: LD_INT 1
66865: NEG
66866: PUSH
66867: LD_INT 1
66869: NEG
66870: PUSH
66871: EMPTY
66872: LIST
66873: LIST
66874: PUSH
66875: LD_INT 1
66877: NEG
66878: PUSH
66879: LD_INT 2
66881: NEG
66882: PUSH
66883: EMPTY
66884: LIST
66885: LIST
66886: PUSH
66887: LD_INT 0
66889: PUSH
66890: LD_INT 2
66892: NEG
66893: PUSH
66894: EMPTY
66895: LIST
66896: LIST
66897: PUSH
66898: LD_INT 1
66900: PUSH
66901: LD_INT 1
66903: NEG
66904: PUSH
66905: EMPTY
66906: LIST
66907: LIST
66908: PUSH
66909: LD_INT 2
66911: PUSH
66912: LD_INT 0
66914: PUSH
66915: EMPTY
66916: LIST
66917: LIST
66918: PUSH
66919: LD_INT 2
66921: PUSH
66922: LD_INT 1
66924: PUSH
66925: EMPTY
66926: LIST
66927: LIST
66928: PUSH
66929: LD_INT 2
66931: PUSH
66932: LD_INT 2
66934: PUSH
66935: EMPTY
66936: LIST
66937: LIST
66938: PUSH
66939: LD_INT 1
66941: PUSH
66942: LD_INT 2
66944: PUSH
66945: EMPTY
66946: LIST
66947: LIST
66948: PUSH
66949: LD_INT 0
66951: PUSH
66952: LD_INT 2
66954: PUSH
66955: EMPTY
66956: LIST
66957: LIST
66958: PUSH
66959: LD_INT 1
66961: NEG
66962: PUSH
66963: LD_INT 1
66965: PUSH
66966: EMPTY
66967: LIST
66968: LIST
66969: PUSH
66970: LD_INT 2
66972: NEG
66973: PUSH
66974: LD_INT 0
66976: PUSH
66977: EMPTY
66978: LIST
66979: LIST
66980: PUSH
66981: LD_INT 2
66983: NEG
66984: PUSH
66985: LD_INT 1
66987: NEG
66988: PUSH
66989: EMPTY
66990: LIST
66991: LIST
66992: PUSH
66993: LD_INT 2
66995: NEG
66996: PUSH
66997: LD_INT 2
66999: NEG
67000: PUSH
67001: EMPTY
67002: LIST
67003: LIST
67004: PUSH
67005: LD_INT 1
67007: NEG
67008: PUSH
67009: LD_INT 2
67011: PUSH
67012: EMPTY
67013: LIST
67014: LIST
67015: PUSH
67016: LD_INT 2
67018: NEG
67019: PUSH
67020: LD_INT 1
67022: PUSH
67023: EMPTY
67024: LIST
67025: LIST
67026: PUSH
67027: LD_INT 3
67029: NEG
67030: PUSH
67031: LD_INT 1
67033: NEG
67034: PUSH
67035: EMPTY
67036: LIST
67037: LIST
67038: PUSH
67039: LD_INT 3
67041: NEG
67042: PUSH
67043: LD_INT 2
67045: NEG
67046: PUSH
67047: EMPTY
67048: LIST
67049: LIST
67050: PUSH
67051: EMPTY
67052: LIST
67053: LIST
67054: LIST
67055: LIST
67056: LIST
67057: LIST
67058: LIST
67059: LIST
67060: LIST
67061: LIST
67062: LIST
67063: LIST
67064: LIST
67065: LIST
67066: LIST
67067: LIST
67068: LIST
67069: LIST
67070: LIST
67071: LIST
67072: LIST
67073: LIST
67074: LIST
67075: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
67076: LD_ADDR_VAR 0 28
67080: PUSH
67081: LD_INT 0
67083: PUSH
67084: LD_INT 0
67086: PUSH
67087: EMPTY
67088: LIST
67089: LIST
67090: PUSH
67091: LD_INT 0
67093: PUSH
67094: LD_INT 1
67096: NEG
67097: PUSH
67098: EMPTY
67099: LIST
67100: LIST
67101: PUSH
67102: LD_INT 1
67104: PUSH
67105: LD_INT 0
67107: PUSH
67108: EMPTY
67109: LIST
67110: LIST
67111: PUSH
67112: LD_INT 1
67114: PUSH
67115: LD_INT 1
67117: PUSH
67118: EMPTY
67119: LIST
67120: LIST
67121: PUSH
67122: LD_INT 0
67124: PUSH
67125: LD_INT 1
67127: PUSH
67128: EMPTY
67129: LIST
67130: LIST
67131: PUSH
67132: LD_INT 1
67134: NEG
67135: PUSH
67136: LD_INT 0
67138: PUSH
67139: EMPTY
67140: LIST
67141: LIST
67142: PUSH
67143: LD_INT 1
67145: NEG
67146: PUSH
67147: LD_INT 1
67149: NEG
67150: PUSH
67151: EMPTY
67152: LIST
67153: LIST
67154: PUSH
67155: LD_INT 1
67157: NEG
67158: PUSH
67159: LD_INT 2
67161: NEG
67162: PUSH
67163: EMPTY
67164: LIST
67165: LIST
67166: PUSH
67167: LD_INT 0
67169: PUSH
67170: LD_INT 2
67172: NEG
67173: PUSH
67174: EMPTY
67175: LIST
67176: LIST
67177: PUSH
67178: LD_INT 1
67180: PUSH
67181: LD_INT 1
67183: NEG
67184: PUSH
67185: EMPTY
67186: LIST
67187: LIST
67188: PUSH
67189: LD_INT 2
67191: PUSH
67192: LD_INT 0
67194: PUSH
67195: EMPTY
67196: LIST
67197: LIST
67198: PUSH
67199: LD_INT 2
67201: PUSH
67202: LD_INT 1
67204: PUSH
67205: EMPTY
67206: LIST
67207: LIST
67208: PUSH
67209: LD_INT 2
67211: PUSH
67212: LD_INT 2
67214: PUSH
67215: EMPTY
67216: LIST
67217: LIST
67218: PUSH
67219: LD_INT 1
67221: PUSH
67222: LD_INT 2
67224: PUSH
67225: EMPTY
67226: LIST
67227: LIST
67228: PUSH
67229: LD_INT 0
67231: PUSH
67232: LD_INT 2
67234: PUSH
67235: EMPTY
67236: LIST
67237: LIST
67238: PUSH
67239: LD_INT 1
67241: NEG
67242: PUSH
67243: LD_INT 1
67245: PUSH
67246: EMPTY
67247: LIST
67248: LIST
67249: PUSH
67250: LD_INT 2
67252: NEG
67253: PUSH
67254: LD_INT 0
67256: PUSH
67257: EMPTY
67258: LIST
67259: LIST
67260: PUSH
67261: LD_INT 2
67263: NEG
67264: PUSH
67265: LD_INT 1
67267: NEG
67268: PUSH
67269: EMPTY
67270: LIST
67271: LIST
67272: PUSH
67273: LD_INT 2
67275: NEG
67276: PUSH
67277: LD_INT 2
67279: NEG
67280: PUSH
67281: EMPTY
67282: LIST
67283: LIST
67284: PUSH
67285: LD_INT 2
67287: NEG
67288: PUSH
67289: LD_INT 3
67291: NEG
67292: PUSH
67293: EMPTY
67294: LIST
67295: LIST
67296: PUSH
67297: LD_INT 1
67299: NEG
67300: PUSH
67301: LD_INT 3
67303: NEG
67304: PUSH
67305: EMPTY
67306: LIST
67307: LIST
67308: PUSH
67309: LD_INT 3
67311: NEG
67312: PUSH
67313: LD_INT 1
67315: NEG
67316: PUSH
67317: EMPTY
67318: LIST
67319: LIST
67320: PUSH
67321: LD_INT 3
67323: NEG
67324: PUSH
67325: LD_INT 2
67327: NEG
67328: PUSH
67329: EMPTY
67330: LIST
67331: LIST
67332: PUSH
67333: EMPTY
67334: LIST
67335: LIST
67336: LIST
67337: LIST
67338: LIST
67339: LIST
67340: LIST
67341: LIST
67342: LIST
67343: LIST
67344: LIST
67345: LIST
67346: LIST
67347: LIST
67348: LIST
67349: LIST
67350: LIST
67351: LIST
67352: LIST
67353: LIST
67354: LIST
67355: LIST
67356: LIST
67357: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
67358: LD_ADDR_VAR 0 29
67362: PUSH
67363: LD_INT 0
67365: PUSH
67366: LD_INT 0
67368: PUSH
67369: EMPTY
67370: LIST
67371: LIST
67372: PUSH
67373: LD_INT 0
67375: PUSH
67376: LD_INT 1
67378: NEG
67379: PUSH
67380: EMPTY
67381: LIST
67382: LIST
67383: PUSH
67384: LD_INT 1
67386: PUSH
67387: LD_INT 0
67389: PUSH
67390: EMPTY
67391: LIST
67392: LIST
67393: PUSH
67394: LD_INT 1
67396: PUSH
67397: LD_INT 1
67399: PUSH
67400: EMPTY
67401: LIST
67402: LIST
67403: PUSH
67404: LD_INT 0
67406: PUSH
67407: LD_INT 1
67409: PUSH
67410: EMPTY
67411: LIST
67412: LIST
67413: PUSH
67414: LD_INT 1
67416: NEG
67417: PUSH
67418: LD_INT 0
67420: PUSH
67421: EMPTY
67422: LIST
67423: LIST
67424: PUSH
67425: LD_INT 1
67427: NEG
67428: PUSH
67429: LD_INT 1
67431: NEG
67432: PUSH
67433: EMPTY
67434: LIST
67435: LIST
67436: PUSH
67437: LD_INT 1
67439: NEG
67440: PUSH
67441: LD_INT 2
67443: NEG
67444: PUSH
67445: EMPTY
67446: LIST
67447: LIST
67448: PUSH
67449: LD_INT 0
67451: PUSH
67452: LD_INT 2
67454: NEG
67455: PUSH
67456: EMPTY
67457: LIST
67458: LIST
67459: PUSH
67460: LD_INT 1
67462: PUSH
67463: LD_INT 1
67465: NEG
67466: PUSH
67467: EMPTY
67468: LIST
67469: LIST
67470: PUSH
67471: LD_INT 2
67473: PUSH
67474: LD_INT 0
67476: PUSH
67477: EMPTY
67478: LIST
67479: LIST
67480: PUSH
67481: LD_INT 2
67483: PUSH
67484: LD_INT 1
67486: PUSH
67487: EMPTY
67488: LIST
67489: LIST
67490: PUSH
67491: LD_INT 1
67493: PUSH
67494: LD_INT 2
67496: PUSH
67497: EMPTY
67498: LIST
67499: LIST
67500: PUSH
67501: LD_INT 0
67503: PUSH
67504: LD_INT 2
67506: PUSH
67507: EMPTY
67508: LIST
67509: LIST
67510: PUSH
67511: LD_INT 1
67513: NEG
67514: PUSH
67515: LD_INT 1
67517: PUSH
67518: EMPTY
67519: LIST
67520: LIST
67521: PUSH
67522: LD_INT 2
67524: NEG
67525: PUSH
67526: LD_INT 1
67528: NEG
67529: PUSH
67530: EMPTY
67531: LIST
67532: LIST
67533: PUSH
67534: LD_INT 2
67536: NEG
67537: PUSH
67538: LD_INT 2
67540: NEG
67541: PUSH
67542: EMPTY
67543: LIST
67544: LIST
67545: PUSH
67546: LD_INT 2
67548: NEG
67549: PUSH
67550: LD_INT 3
67552: NEG
67553: PUSH
67554: EMPTY
67555: LIST
67556: LIST
67557: PUSH
67558: LD_INT 2
67560: PUSH
67561: LD_INT 1
67563: NEG
67564: PUSH
67565: EMPTY
67566: LIST
67567: LIST
67568: PUSH
67569: LD_INT 3
67571: PUSH
67572: LD_INT 1
67574: PUSH
67575: EMPTY
67576: LIST
67577: LIST
67578: PUSH
67579: LD_INT 1
67581: PUSH
67582: LD_INT 3
67584: PUSH
67585: EMPTY
67586: LIST
67587: LIST
67588: PUSH
67589: LD_INT 1
67591: NEG
67592: PUSH
67593: LD_INT 2
67595: PUSH
67596: EMPTY
67597: LIST
67598: LIST
67599: PUSH
67600: LD_INT 3
67602: NEG
67603: PUSH
67604: LD_INT 2
67606: NEG
67607: PUSH
67608: EMPTY
67609: LIST
67610: LIST
67611: PUSH
67612: EMPTY
67613: LIST
67614: LIST
67615: LIST
67616: LIST
67617: LIST
67618: LIST
67619: LIST
67620: LIST
67621: LIST
67622: LIST
67623: LIST
67624: LIST
67625: LIST
67626: LIST
67627: LIST
67628: LIST
67629: LIST
67630: LIST
67631: LIST
67632: LIST
67633: LIST
67634: LIST
67635: LIST
67636: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
67637: LD_ADDR_VAR 0 30
67641: PUSH
67642: LD_INT 0
67644: PUSH
67645: LD_INT 0
67647: PUSH
67648: EMPTY
67649: LIST
67650: LIST
67651: PUSH
67652: LD_INT 0
67654: PUSH
67655: LD_INT 1
67657: NEG
67658: PUSH
67659: EMPTY
67660: LIST
67661: LIST
67662: PUSH
67663: LD_INT 1
67665: PUSH
67666: LD_INT 0
67668: PUSH
67669: EMPTY
67670: LIST
67671: LIST
67672: PUSH
67673: LD_INT 1
67675: PUSH
67676: LD_INT 1
67678: PUSH
67679: EMPTY
67680: LIST
67681: LIST
67682: PUSH
67683: LD_INT 0
67685: PUSH
67686: LD_INT 1
67688: PUSH
67689: EMPTY
67690: LIST
67691: LIST
67692: PUSH
67693: LD_INT 1
67695: NEG
67696: PUSH
67697: LD_INT 0
67699: PUSH
67700: EMPTY
67701: LIST
67702: LIST
67703: PUSH
67704: LD_INT 1
67706: NEG
67707: PUSH
67708: LD_INT 1
67710: NEG
67711: PUSH
67712: EMPTY
67713: LIST
67714: LIST
67715: PUSH
67716: LD_INT 1
67718: NEG
67719: PUSH
67720: LD_INT 2
67722: NEG
67723: PUSH
67724: EMPTY
67725: LIST
67726: LIST
67727: PUSH
67728: LD_INT 0
67730: PUSH
67731: LD_INT 2
67733: NEG
67734: PUSH
67735: EMPTY
67736: LIST
67737: LIST
67738: PUSH
67739: LD_INT 1
67741: PUSH
67742: LD_INT 1
67744: NEG
67745: PUSH
67746: EMPTY
67747: LIST
67748: LIST
67749: PUSH
67750: LD_INT 2
67752: PUSH
67753: LD_INT 0
67755: PUSH
67756: EMPTY
67757: LIST
67758: LIST
67759: PUSH
67760: LD_INT 2
67762: PUSH
67763: LD_INT 1
67765: PUSH
67766: EMPTY
67767: LIST
67768: LIST
67769: PUSH
67770: LD_INT 2
67772: PUSH
67773: LD_INT 2
67775: PUSH
67776: EMPTY
67777: LIST
67778: LIST
67779: PUSH
67780: LD_INT 1
67782: PUSH
67783: LD_INT 2
67785: PUSH
67786: EMPTY
67787: LIST
67788: LIST
67789: PUSH
67790: LD_INT 1
67792: NEG
67793: PUSH
67794: LD_INT 1
67796: PUSH
67797: EMPTY
67798: LIST
67799: LIST
67800: PUSH
67801: LD_INT 2
67803: NEG
67804: PUSH
67805: LD_INT 0
67807: PUSH
67808: EMPTY
67809: LIST
67810: LIST
67811: PUSH
67812: LD_INT 2
67814: NEG
67815: PUSH
67816: LD_INT 1
67818: NEG
67819: PUSH
67820: EMPTY
67821: LIST
67822: LIST
67823: PUSH
67824: LD_INT 1
67826: NEG
67827: PUSH
67828: LD_INT 3
67830: NEG
67831: PUSH
67832: EMPTY
67833: LIST
67834: LIST
67835: PUSH
67836: LD_INT 1
67838: PUSH
67839: LD_INT 2
67841: NEG
67842: PUSH
67843: EMPTY
67844: LIST
67845: LIST
67846: PUSH
67847: LD_INT 3
67849: PUSH
67850: LD_INT 2
67852: PUSH
67853: EMPTY
67854: LIST
67855: LIST
67856: PUSH
67857: LD_INT 2
67859: PUSH
67860: LD_INT 3
67862: PUSH
67863: EMPTY
67864: LIST
67865: LIST
67866: PUSH
67867: LD_INT 2
67869: NEG
67870: PUSH
67871: LD_INT 1
67873: PUSH
67874: EMPTY
67875: LIST
67876: LIST
67877: PUSH
67878: LD_INT 3
67880: NEG
67881: PUSH
67882: LD_INT 1
67884: NEG
67885: PUSH
67886: EMPTY
67887: LIST
67888: LIST
67889: PUSH
67890: EMPTY
67891: LIST
67892: LIST
67893: LIST
67894: LIST
67895: LIST
67896: LIST
67897: LIST
67898: LIST
67899: LIST
67900: LIST
67901: LIST
67902: LIST
67903: LIST
67904: LIST
67905: LIST
67906: LIST
67907: LIST
67908: LIST
67909: LIST
67910: LIST
67911: LIST
67912: LIST
67913: LIST
67914: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
67915: LD_ADDR_VAR 0 31
67919: PUSH
67920: LD_INT 0
67922: PUSH
67923: LD_INT 0
67925: PUSH
67926: EMPTY
67927: LIST
67928: LIST
67929: PUSH
67930: LD_INT 0
67932: PUSH
67933: LD_INT 1
67935: NEG
67936: PUSH
67937: EMPTY
67938: LIST
67939: LIST
67940: PUSH
67941: LD_INT 1
67943: PUSH
67944: LD_INT 0
67946: PUSH
67947: EMPTY
67948: LIST
67949: LIST
67950: PUSH
67951: LD_INT 1
67953: PUSH
67954: LD_INT 1
67956: PUSH
67957: EMPTY
67958: LIST
67959: LIST
67960: PUSH
67961: LD_INT 0
67963: PUSH
67964: LD_INT 1
67966: PUSH
67967: EMPTY
67968: LIST
67969: LIST
67970: PUSH
67971: LD_INT 1
67973: NEG
67974: PUSH
67975: LD_INT 0
67977: PUSH
67978: EMPTY
67979: LIST
67980: LIST
67981: PUSH
67982: LD_INT 1
67984: NEG
67985: PUSH
67986: LD_INT 1
67988: NEG
67989: PUSH
67990: EMPTY
67991: LIST
67992: LIST
67993: PUSH
67994: LD_INT 1
67996: NEG
67997: PUSH
67998: LD_INT 2
68000: NEG
68001: PUSH
68002: EMPTY
68003: LIST
68004: LIST
68005: PUSH
68006: LD_INT 1
68008: PUSH
68009: LD_INT 1
68011: NEG
68012: PUSH
68013: EMPTY
68014: LIST
68015: LIST
68016: PUSH
68017: LD_INT 2
68019: PUSH
68020: LD_INT 0
68022: PUSH
68023: EMPTY
68024: LIST
68025: LIST
68026: PUSH
68027: LD_INT 2
68029: PUSH
68030: LD_INT 1
68032: PUSH
68033: EMPTY
68034: LIST
68035: LIST
68036: PUSH
68037: LD_INT 2
68039: PUSH
68040: LD_INT 2
68042: PUSH
68043: EMPTY
68044: LIST
68045: LIST
68046: PUSH
68047: LD_INT 1
68049: PUSH
68050: LD_INT 2
68052: PUSH
68053: EMPTY
68054: LIST
68055: LIST
68056: PUSH
68057: LD_INT 0
68059: PUSH
68060: LD_INT 2
68062: PUSH
68063: EMPTY
68064: LIST
68065: LIST
68066: PUSH
68067: LD_INT 1
68069: NEG
68070: PUSH
68071: LD_INT 1
68073: PUSH
68074: EMPTY
68075: LIST
68076: LIST
68077: PUSH
68078: LD_INT 2
68080: NEG
68081: PUSH
68082: LD_INT 1
68084: NEG
68085: PUSH
68086: EMPTY
68087: LIST
68088: LIST
68089: PUSH
68090: LD_INT 2
68092: NEG
68093: PUSH
68094: LD_INT 2
68096: NEG
68097: PUSH
68098: EMPTY
68099: LIST
68100: LIST
68101: PUSH
68102: LD_INT 2
68104: NEG
68105: PUSH
68106: LD_INT 3
68108: NEG
68109: PUSH
68110: EMPTY
68111: LIST
68112: LIST
68113: PUSH
68114: LD_INT 2
68116: PUSH
68117: LD_INT 1
68119: NEG
68120: PUSH
68121: EMPTY
68122: LIST
68123: LIST
68124: PUSH
68125: LD_INT 3
68127: PUSH
68128: LD_INT 1
68130: PUSH
68131: EMPTY
68132: LIST
68133: LIST
68134: PUSH
68135: LD_INT 1
68137: PUSH
68138: LD_INT 3
68140: PUSH
68141: EMPTY
68142: LIST
68143: LIST
68144: PUSH
68145: LD_INT 1
68147: NEG
68148: PUSH
68149: LD_INT 2
68151: PUSH
68152: EMPTY
68153: LIST
68154: LIST
68155: PUSH
68156: LD_INT 3
68158: NEG
68159: PUSH
68160: LD_INT 2
68162: NEG
68163: PUSH
68164: EMPTY
68165: LIST
68166: LIST
68167: PUSH
68168: EMPTY
68169: LIST
68170: LIST
68171: LIST
68172: LIST
68173: LIST
68174: LIST
68175: LIST
68176: LIST
68177: LIST
68178: LIST
68179: LIST
68180: LIST
68181: LIST
68182: LIST
68183: LIST
68184: LIST
68185: LIST
68186: LIST
68187: LIST
68188: LIST
68189: LIST
68190: LIST
68191: LIST
68192: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
68193: LD_ADDR_VAR 0 32
68197: PUSH
68198: LD_INT 0
68200: PUSH
68201: LD_INT 0
68203: PUSH
68204: EMPTY
68205: LIST
68206: LIST
68207: PUSH
68208: LD_INT 0
68210: PUSH
68211: LD_INT 1
68213: NEG
68214: PUSH
68215: EMPTY
68216: LIST
68217: LIST
68218: PUSH
68219: LD_INT 1
68221: PUSH
68222: LD_INT 0
68224: PUSH
68225: EMPTY
68226: LIST
68227: LIST
68228: PUSH
68229: LD_INT 1
68231: PUSH
68232: LD_INT 1
68234: PUSH
68235: EMPTY
68236: LIST
68237: LIST
68238: PUSH
68239: LD_INT 0
68241: PUSH
68242: LD_INT 1
68244: PUSH
68245: EMPTY
68246: LIST
68247: LIST
68248: PUSH
68249: LD_INT 1
68251: NEG
68252: PUSH
68253: LD_INT 0
68255: PUSH
68256: EMPTY
68257: LIST
68258: LIST
68259: PUSH
68260: LD_INT 1
68262: NEG
68263: PUSH
68264: LD_INT 1
68266: NEG
68267: PUSH
68268: EMPTY
68269: LIST
68270: LIST
68271: PUSH
68272: LD_INT 1
68274: NEG
68275: PUSH
68276: LD_INT 2
68278: NEG
68279: PUSH
68280: EMPTY
68281: LIST
68282: LIST
68283: PUSH
68284: LD_INT 0
68286: PUSH
68287: LD_INT 2
68289: NEG
68290: PUSH
68291: EMPTY
68292: LIST
68293: LIST
68294: PUSH
68295: LD_INT 1
68297: PUSH
68298: LD_INT 1
68300: NEG
68301: PUSH
68302: EMPTY
68303: LIST
68304: LIST
68305: PUSH
68306: LD_INT 2
68308: PUSH
68309: LD_INT 1
68311: PUSH
68312: EMPTY
68313: LIST
68314: LIST
68315: PUSH
68316: LD_INT 2
68318: PUSH
68319: LD_INT 2
68321: PUSH
68322: EMPTY
68323: LIST
68324: LIST
68325: PUSH
68326: LD_INT 1
68328: PUSH
68329: LD_INT 2
68331: PUSH
68332: EMPTY
68333: LIST
68334: LIST
68335: PUSH
68336: LD_INT 0
68338: PUSH
68339: LD_INT 2
68341: PUSH
68342: EMPTY
68343: LIST
68344: LIST
68345: PUSH
68346: LD_INT 1
68348: NEG
68349: PUSH
68350: LD_INT 1
68352: PUSH
68353: EMPTY
68354: LIST
68355: LIST
68356: PUSH
68357: LD_INT 2
68359: NEG
68360: PUSH
68361: LD_INT 0
68363: PUSH
68364: EMPTY
68365: LIST
68366: LIST
68367: PUSH
68368: LD_INT 2
68370: NEG
68371: PUSH
68372: LD_INT 1
68374: NEG
68375: PUSH
68376: EMPTY
68377: LIST
68378: LIST
68379: PUSH
68380: LD_INT 1
68382: NEG
68383: PUSH
68384: LD_INT 3
68386: NEG
68387: PUSH
68388: EMPTY
68389: LIST
68390: LIST
68391: PUSH
68392: LD_INT 1
68394: PUSH
68395: LD_INT 2
68397: NEG
68398: PUSH
68399: EMPTY
68400: LIST
68401: LIST
68402: PUSH
68403: LD_INT 3
68405: PUSH
68406: LD_INT 2
68408: PUSH
68409: EMPTY
68410: LIST
68411: LIST
68412: PUSH
68413: LD_INT 2
68415: PUSH
68416: LD_INT 3
68418: PUSH
68419: EMPTY
68420: LIST
68421: LIST
68422: PUSH
68423: LD_INT 2
68425: NEG
68426: PUSH
68427: LD_INT 1
68429: PUSH
68430: EMPTY
68431: LIST
68432: LIST
68433: PUSH
68434: LD_INT 3
68436: NEG
68437: PUSH
68438: LD_INT 1
68440: NEG
68441: PUSH
68442: EMPTY
68443: LIST
68444: LIST
68445: PUSH
68446: EMPTY
68447: LIST
68448: LIST
68449: LIST
68450: LIST
68451: LIST
68452: LIST
68453: LIST
68454: LIST
68455: LIST
68456: LIST
68457: LIST
68458: LIST
68459: LIST
68460: LIST
68461: LIST
68462: LIST
68463: LIST
68464: LIST
68465: LIST
68466: LIST
68467: LIST
68468: LIST
68469: LIST
68470: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
68471: LD_ADDR_VAR 0 33
68475: PUSH
68476: LD_INT 0
68478: PUSH
68479: LD_INT 0
68481: PUSH
68482: EMPTY
68483: LIST
68484: LIST
68485: PUSH
68486: LD_INT 0
68488: PUSH
68489: LD_INT 1
68491: NEG
68492: PUSH
68493: EMPTY
68494: LIST
68495: LIST
68496: PUSH
68497: LD_INT 1
68499: PUSH
68500: LD_INT 0
68502: PUSH
68503: EMPTY
68504: LIST
68505: LIST
68506: PUSH
68507: LD_INT 1
68509: PUSH
68510: LD_INT 1
68512: PUSH
68513: EMPTY
68514: LIST
68515: LIST
68516: PUSH
68517: LD_INT 0
68519: PUSH
68520: LD_INT 1
68522: PUSH
68523: EMPTY
68524: LIST
68525: LIST
68526: PUSH
68527: LD_INT 1
68529: NEG
68530: PUSH
68531: LD_INT 0
68533: PUSH
68534: EMPTY
68535: LIST
68536: LIST
68537: PUSH
68538: LD_INT 1
68540: NEG
68541: PUSH
68542: LD_INT 1
68544: NEG
68545: PUSH
68546: EMPTY
68547: LIST
68548: LIST
68549: PUSH
68550: LD_INT 1
68552: NEG
68553: PUSH
68554: LD_INT 2
68556: NEG
68557: PUSH
68558: EMPTY
68559: LIST
68560: LIST
68561: PUSH
68562: LD_INT 1
68564: PUSH
68565: LD_INT 1
68567: NEG
68568: PUSH
68569: EMPTY
68570: LIST
68571: LIST
68572: PUSH
68573: LD_INT 2
68575: PUSH
68576: LD_INT 0
68578: PUSH
68579: EMPTY
68580: LIST
68581: LIST
68582: PUSH
68583: LD_INT 2
68585: PUSH
68586: LD_INT 1
68588: PUSH
68589: EMPTY
68590: LIST
68591: LIST
68592: PUSH
68593: LD_INT 1
68595: PUSH
68596: LD_INT 2
68598: PUSH
68599: EMPTY
68600: LIST
68601: LIST
68602: PUSH
68603: LD_INT 0
68605: PUSH
68606: LD_INT 2
68608: PUSH
68609: EMPTY
68610: LIST
68611: LIST
68612: PUSH
68613: LD_INT 1
68615: NEG
68616: PUSH
68617: LD_INT 1
68619: PUSH
68620: EMPTY
68621: LIST
68622: LIST
68623: PUSH
68624: LD_INT 2
68626: NEG
68627: PUSH
68628: LD_INT 0
68630: PUSH
68631: EMPTY
68632: LIST
68633: LIST
68634: PUSH
68635: LD_INT 2
68637: NEG
68638: PUSH
68639: LD_INT 1
68641: NEG
68642: PUSH
68643: EMPTY
68644: LIST
68645: LIST
68646: PUSH
68647: LD_INT 2
68649: NEG
68650: PUSH
68651: LD_INT 2
68653: NEG
68654: PUSH
68655: EMPTY
68656: LIST
68657: LIST
68658: PUSH
68659: LD_INT 2
68661: NEG
68662: PUSH
68663: LD_INT 3
68665: NEG
68666: PUSH
68667: EMPTY
68668: LIST
68669: LIST
68670: PUSH
68671: LD_INT 2
68673: PUSH
68674: LD_INT 1
68676: NEG
68677: PUSH
68678: EMPTY
68679: LIST
68680: LIST
68681: PUSH
68682: LD_INT 3
68684: PUSH
68685: LD_INT 1
68687: PUSH
68688: EMPTY
68689: LIST
68690: LIST
68691: PUSH
68692: LD_INT 1
68694: PUSH
68695: LD_INT 3
68697: PUSH
68698: EMPTY
68699: LIST
68700: LIST
68701: PUSH
68702: LD_INT 1
68704: NEG
68705: PUSH
68706: LD_INT 2
68708: PUSH
68709: EMPTY
68710: LIST
68711: LIST
68712: PUSH
68713: LD_INT 3
68715: NEG
68716: PUSH
68717: LD_INT 2
68719: NEG
68720: PUSH
68721: EMPTY
68722: LIST
68723: LIST
68724: PUSH
68725: EMPTY
68726: LIST
68727: LIST
68728: LIST
68729: LIST
68730: LIST
68731: LIST
68732: LIST
68733: LIST
68734: LIST
68735: LIST
68736: LIST
68737: LIST
68738: LIST
68739: LIST
68740: LIST
68741: LIST
68742: LIST
68743: LIST
68744: LIST
68745: LIST
68746: LIST
68747: LIST
68748: LIST
68749: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
68750: LD_ADDR_VAR 0 34
68754: PUSH
68755: LD_INT 0
68757: PUSH
68758: LD_INT 0
68760: PUSH
68761: EMPTY
68762: LIST
68763: LIST
68764: PUSH
68765: LD_INT 0
68767: PUSH
68768: LD_INT 1
68770: NEG
68771: PUSH
68772: EMPTY
68773: LIST
68774: LIST
68775: PUSH
68776: LD_INT 1
68778: PUSH
68779: LD_INT 0
68781: PUSH
68782: EMPTY
68783: LIST
68784: LIST
68785: PUSH
68786: LD_INT 1
68788: PUSH
68789: LD_INT 1
68791: PUSH
68792: EMPTY
68793: LIST
68794: LIST
68795: PUSH
68796: LD_INT 0
68798: PUSH
68799: LD_INT 1
68801: PUSH
68802: EMPTY
68803: LIST
68804: LIST
68805: PUSH
68806: LD_INT 1
68808: NEG
68809: PUSH
68810: LD_INT 0
68812: PUSH
68813: EMPTY
68814: LIST
68815: LIST
68816: PUSH
68817: LD_INT 1
68819: NEG
68820: PUSH
68821: LD_INT 1
68823: NEG
68824: PUSH
68825: EMPTY
68826: LIST
68827: LIST
68828: PUSH
68829: LD_INT 1
68831: NEG
68832: PUSH
68833: LD_INT 2
68835: NEG
68836: PUSH
68837: EMPTY
68838: LIST
68839: LIST
68840: PUSH
68841: LD_INT 0
68843: PUSH
68844: LD_INT 2
68846: NEG
68847: PUSH
68848: EMPTY
68849: LIST
68850: LIST
68851: PUSH
68852: LD_INT 1
68854: PUSH
68855: LD_INT 1
68857: NEG
68858: PUSH
68859: EMPTY
68860: LIST
68861: LIST
68862: PUSH
68863: LD_INT 2
68865: PUSH
68866: LD_INT 1
68868: PUSH
68869: EMPTY
68870: LIST
68871: LIST
68872: PUSH
68873: LD_INT 2
68875: PUSH
68876: LD_INT 2
68878: PUSH
68879: EMPTY
68880: LIST
68881: LIST
68882: PUSH
68883: LD_INT 1
68885: PUSH
68886: LD_INT 2
68888: PUSH
68889: EMPTY
68890: LIST
68891: LIST
68892: PUSH
68893: LD_INT 1
68895: NEG
68896: PUSH
68897: LD_INT 1
68899: PUSH
68900: EMPTY
68901: LIST
68902: LIST
68903: PUSH
68904: LD_INT 2
68906: NEG
68907: PUSH
68908: LD_INT 0
68910: PUSH
68911: EMPTY
68912: LIST
68913: LIST
68914: PUSH
68915: LD_INT 2
68917: NEG
68918: PUSH
68919: LD_INT 1
68921: NEG
68922: PUSH
68923: EMPTY
68924: LIST
68925: LIST
68926: PUSH
68927: LD_INT 2
68929: NEG
68930: PUSH
68931: LD_INT 2
68933: NEG
68934: PUSH
68935: EMPTY
68936: LIST
68937: LIST
68938: PUSH
68939: LD_INT 1
68941: NEG
68942: PUSH
68943: LD_INT 3
68945: NEG
68946: PUSH
68947: EMPTY
68948: LIST
68949: LIST
68950: PUSH
68951: LD_INT 1
68953: PUSH
68954: LD_INT 2
68956: NEG
68957: PUSH
68958: EMPTY
68959: LIST
68960: LIST
68961: PUSH
68962: LD_INT 3
68964: PUSH
68965: LD_INT 2
68967: PUSH
68968: EMPTY
68969: LIST
68970: LIST
68971: PUSH
68972: LD_INT 2
68974: PUSH
68975: LD_INT 3
68977: PUSH
68978: EMPTY
68979: LIST
68980: LIST
68981: PUSH
68982: LD_INT 2
68984: NEG
68985: PUSH
68986: LD_INT 1
68988: PUSH
68989: EMPTY
68990: LIST
68991: LIST
68992: PUSH
68993: LD_INT 3
68995: NEG
68996: PUSH
68997: LD_INT 1
68999: NEG
69000: PUSH
69001: EMPTY
69002: LIST
69003: LIST
69004: PUSH
69005: EMPTY
69006: LIST
69007: LIST
69008: LIST
69009: LIST
69010: LIST
69011: LIST
69012: LIST
69013: LIST
69014: LIST
69015: LIST
69016: LIST
69017: LIST
69018: LIST
69019: LIST
69020: LIST
69021: LIST
69022: LIST
69023: LIST
69024: LIST
69025: LIST
69026: LIST
69027: LIST
69028: LIST
69029: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
69030: LD_ADDR_VAR 0 35
69034: PUSH
69035: LD_INT 0
69037: PUSH
69038: LD_INT 0
69040: PUSH
69041: EMPTY
69042: LIST
69043: LIST
69044: PUSH
69045: LD_INT 0
69047: PUSH
69048: LD_INT 1
69050: NEG
69051: PUSH
69052: EMPTY
69053: LIST
69054: LIST
69055: PUSH
69056: LD_INT 1
69058: PUSH
69059: LD_INT 0
69061: PUSH
69062: EMPTY
69063: LIST
69064: LIST
69065: PUSH
69066: LD_INT 1
69068: PUSH
69069: LD_INT 1
69071: PUSH
69072: EMPTY
69073: LIST
69074: LIST
69075: PUSH
69076: LD_INT 0
69078: PUSH
69079: LD_INT 1
69081: PUSH
69082: EMPTY
69083: LIST
69084: LIST
69085: PUSH
69086: LD_INT 1
69088: NEG
69089: PUSH
69090: LD_INT 0
69092: PUSH
69093: EMPTY
69094: LIST
69095: LIST
69096: PUSH
69097: LD_INT 1
69099: NEG
69100: PUSH
69101: LD_INT 1
69103: NEG
69104: PUSH
69105: EMPTY
69106: LIST
69107: LIST
69108: PUSH
69109: LD_INT 2
69111: PUSH
69112: LD_INT 1
69114: PUSH
69115: EMPTY
69116: LIST
69117: LIST
69118: PUSH
69119: LD_INT 2
69121: NEG
69122: PUSH
69123: LD_INT 1
69125: NEG
69126: PUSH
69127: EMPTY
69128: LIST
69129: LIST
69130: PUSH
69131: EMPTY
69132: LIST
69133: LIST
69134: LIST
69135: LIST
69136: LIST
69137: LIST
69138: LIST
69139: LIST
69140: LIST
69141: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
69142: LD_ADDR_VAR 0 36
69146: PUSH
69147: LD_INT 0
69149: PUSH
69150: LD_INT 0
69152: PUSH
69153: EMPTY
69154: LIST
69155: LIST
69156: PUSH
69157: LD_INT 0
69159: PUSH
69160: LD_INT 1
69162: NEG
69163: PUSH
69164: EMPTY
69165: LIST
69166: LIST
69167: PUSH
69168: LD_INT 1
69170: PUSH
69171: LD_INT 0
69173: PUSH
69174: EMPTY
69175: LIST
69176: LIST
69177: PUSH
69178: LD_INT 1
69180: PUSH
69181: LD_INT 1
69183: PUSH
69184: EMPTY
69185: LIST
69186: LIST
69187: PUSH
69188: LD_INT 0
69190: PUSH
69191: LD_INT 1
69193: PUSH
69194: EMPTY
69195: LIST
69196: LIST
69197: PUSH
69198: LD_INT 1
69200: NEG
69201: PUSH
69202: LD_INT 0
69204: PUSH
69205: EMPTY
69206: LIST
69207: LIST
69208: PUSH
69209: LD_INT 1
69211: NEG
69212: PUSH
69213: LD_INT 1
69215: NEG
69216: PUSH
69217: EMPTY
69218: LIST
69219: LIST
69220: PUSH
69221: LD_INT 1
69223: NEG
69224: PUSH
69225: LD_INT 2
69227: NEG
69228: PUSH
69229: EMPTY
69230: LIST
69231: LIST
69232: PUSH
69233: LD_INT 1
69235: PUSH
69236: LD_INT 2
69238: PUSH
69239: EMPTY
69240: LIST
69241: LIST
69242: PUSH
69243: EMPTY
69244: LIST
69245: LIST
69246: LIST
69247: LIST
69248: LIST
69249: LIST
69250: LIST
69251: LIST
69252: LIST
69253: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
69254: LD_ADDR_VAR 0 37
69258: PUSH
69259: LD_INT 0
69261: PUSH
69262: LD_INT 0
69264: PUSH
69265: EMPTY
69266: LIST
69267: LIST
69268: PUSH
69269: LD_INT 0
69271: PUSH
69272: LD_INT 1
69274: NEG
69275: PUSH
69276: EMPTY
69277: LIST
69278: LIST
69279: PUSH
69280: LD_INT 1
69282: PUSH
69283: LD_INT 0
69285: PUSH
69286: EMPTY
69287: LIST
69288: LIST
69289: PUSH
69290: LD_INT 1
69292: PUSH
69293: LD_INT 1
69295: PUSH
69296: EMPTY
69297: LIST
69298: LIST
69299: PUSH
69300: LD_INT 0
69302: PUSH
69303: LD_INT 1
69305: PUSH
69306: EMPTY
69307: LIST
69308: LIST
69309: PUSH
69310: LD_INT 1
69312: NEG
69313: PUSH
69314: LD_INT 0
69316: PUSH
69317: EMPTY
69318: LIST
69319: LIST
69320: PUSH
69321: LD_INT 1
69323: NEG
69324: PUSH
69325: LD_INT 1
69327: NEG
69328: PUSH
69329: EMPTY
69330: LIST
69331: LIST
69332: PUSH
69333: LD_INT 1
69335: PUSH
69336: LD_INT 1
69338: NEG
69339: PUSH
69340: EMPTY
69341: LIST
69342: LIST
69343: PUSH
69344: LD_INT 1
69346: NEG
69347: PUSH
69348: LD_INT 1
69350: PUSH
69351: EMPTY
69352: LIST
69353: LIST
69354: PUSH
69355: EMPTY
69356: LIST
69357: LIST
69358: LIST
69359: LIST
69360: LIST
69361: LIST
69362: LIST
69363: LIST
69364: LIST
69365: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
69366: LD_ADDR_VAR 0 38
69370: PUSH
69371: LD_INT 0
69373: PUSH
69374: LD_INT 0
69376: PUSH
69377: EMPTY
69378: LIST
69379: LIST
69380: PUSH
69381: LD_INT 0
69383: PUSH
69384: LD_INT 1
69386: NEG
69387: PUSH
69388: EMPTY
69389: LIST
69390: LIST
69391: PUSH
69392: LD_INT 1
69394: PUSH
69395: LD_INT 0
69397: PUSH
69398: EMPTY
69399: LIST
69400: LIST
69401: PUSH
69402: LD_INT 1
69404: PUSH
69405: LD_INT 1
69407: PUSH
69408: EMPTY
69409: LIST
69410: LIST
69411: PUSH
69412: LD_INT 0
69414: PUSH
69415: LD_INT 1
69417: PUSH
69418: EMPTY
69419: LIST
69420: LIST
69421: PUSH
69422: LD_INT 1
69424: NEG
69425: PUSH
69426: LD_INT 0
69428: PUSH
69429: EMPTY
69430: LIST
69431: LIST
69432: PUSH
69433: LD_INT 1
69435: NEG
69436: PUSH
69437: LD_INT 1
69439: NEG
69440: PUSH
69441: EMPTY
69442: LIST
69443: LIST
69444: PUSH
69445: LD_INT 2
69447: PUSH
69448: LD_INT 1
69450: PUSH
69451: EMPTY
69452: LIST
69453: LIST
69454: PUSH
69455: LD_INT 2
69457: NEG
69458: PUSH
69459: LD_INT 1
69461: NEG
69462: PUSH
69463: EMPTY
69464: LIST
69465: LIST
69466: PUSH
69467: EMPTY
69468: LIST
69469: LIST
69470: LIST
69471: LIST
69472: LIST
69473: LIST
69474: LIST
69475: LIST
69476: LIST
69477: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
69478: LD_ADDR_VAR 0 39
69482: PUSH
69483: LD_INT 0
69485: PUSH
69486: LD_INT 0
69488: PUSH
69489: EMPTY
69490: LIST
69491: LIST
69492: PUSH
69493: LD_INT 0
69495: PUSH
69496: LD_INT 1
69498: NEG
69499: PUSH
69500: EMPTY
69501: LIST
69502: LIST
69503: PUSH
69504: LD_INT 1
69506: PUSH
69507: LD_INT 0
69509: PUSH
69510: EMPTY
69511: LIST
69512: LIST
69513: PUSH
69514: LD_INT 1
69516: PUSH
69517: LD_INT 1
69519: PUSH
69520: EMPTY
69521: LIST
69522: LIST
69523: PUSH
69524: LD_INT 0
69526: PUSH
69527: LD_INT 1
69529: PUSH
69530: EMPTY
69531: LIST
69532: LIST
69533: PUSH
69534: LD_INT 1
69536: NEG
69537: PUSH
69538: LD_INT 0
69540: PUSH
69541: EMPTY
69542: LIST
69543: LIST
69544: PUSH
69545: LD_INT 1
69547: NEG
69548: PUSH
69549: LD_INT 1
69551: NEG
69552: PUSH
69553: EMPTY
69554: LIST
69555: LIST
69556: PUSH
69557: LD_INT 1
69559: NEG
69560: PUSH
69561: LD_INT 2
69563: NEG
69564: PUSH
69565: EMPTY
69566: LIST
69567: LIST
69568: PUSH
69569: LD_INT 1
69571: PUSH
69572: LD_INT 2
69574: PUSH
69575: EMPTY
69576: LIST
69577: LIST
69578: PUSH
69579: EMPTY
69580: LIST
69581: LIST
69582: LIST
69583: LIST
69584: LIST
69585: LIST
69586: LIST
69587: LIST
69588: LIST
69589: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
69590: LD_ADDR_VAR 0 40
69594: PUSH
69595: LD_INT 0
69597: PUSH
69598: LD_INT 0
69600: PUSH
69601: EMPTY
69602: LIST
69603: LIST
69604: PUSH
69605: LD_INT 0
69607: PUSH
69608: LD_INT 1
69610: NEG
69611: PUSH
69612: EMPTY
69613: LIST
69614: LIST
69615: PUSH
69616: LD_INT 1
69618: PUSH
69619: LD_INT 0
69621: PUSH
69622: EMPTY
69623: LIST
69624: LIST
69625: PUSH
69626: LD_INT 1
69628: PUSH
69629: LD_INT 1
69631: PUSH
69632: EMPTY
69633: LIST
69634: LIST
69635: PUSH
69636: LD_INT 0
69638: PUSH
69639: LD_INT 1
69641: PUSH
69642: EMPTY
69643: LIST
69644: LIST
69645: PUSH
69646: LD_INT 1
69648: NEG
69649: PUSH
69650: LD_INT 0
69652: PUSH
69653: EMPTY
69654: LIST
69655: LIST
69656: PUSH
69657: LD_INT 1
69659: NEG
69660: PUSH
69661: LD_INT 1
69663: NEG
69664: PUSH
69665: EMPTY
69666: LIST
69667: LIST
69668: PUSH
69669: LD_INT 1
69671: PUSH
69672: LD_INT 1
69674: NEG
69675: PUSH
69676: EMPTY
69677: LIST
69678: LIST
69679: PUSH
69680: LD_INT 1
69682: NEG
69683: PUSH
69684: LD_INT 1
69686: PUSH
69687: EMPTY
69688: LIST
69689: LIST
69690: PUSH
69691: EMPTY
69692: LIST
69693: LIST
69694: LIST
69695: LIST
69696: LIST
69697: LIST
69698: LIST
69699: LIST
69700: LIST
69701: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
69702: LD_ADDR_VAR 0 41
69706: PUSH
69707: LD_INT 0
69709: PUSH
69710: LD_INT 0
69712: PUSH
69713: EMPTY
69714: LIST
69715: LIST
69716: PUSH
69717: LD_INT 0
69719: PUSH
69720: LD_INT 1
69722: NEG
69723: PUSH
69724: EMPTY
69725: LIST
69726: LIST
69727: PUSH
69728: LD_INT 1
69730: PUSH
69731: LD_INT 0
69733: PUSH
69734: EMPTY
69735: LIST
69736: LIST
69737: PUSH
69738: LD_INT 1
69740: PUSH
69741: LD_INT 1
69743: PUSH
69744: EMPTY
69745: LIST
69746: LIST
69747: PUSH
69748: LD_INT 0
69750: PUSH
69751: LD_INT 1
69753: PUSH
69754: EMPTY
69755: LIST
69756: LIST
69757: PUSH
69758: LD_INT 1
69760: NEG
69761: PUSH
69762: LD_INT 0
69764: PUSH
69765: EMPTY
69766: LIST
69767: LIST
69768: PUSH
69769: LD_INT 1
69771: NEG
69772: PUSH
69773: LD_INT 1
69775: NEG
69776: PUSH
69777: EMPTY
69778: LIST
69779: LIST
69780: PUSH
69781: LD_INT 1
69783: NEG
69784: PUSH
69785: LD_INT 2
69787: NEG
69788: PUSH
69789: EMPTY
69790: LIST
69791: LIST
69792: PUSH
69793: LD_INT 1
69795: PUSH
69796: LD_INT 1
69798: NEG
69799: PUSH
69800: EMPTY
69801: LIST
69802: LIST
69803: PUSH
69804: LD_INT 2
69806: PUSH
69807: LD_INT 0
69809: PUSH
69810: EMPTY
69811: LIST
69812: LIST
69813: PUSH
69814: LD_INT 2
69816: PUSH
69817: LD_INT 1
69819: PUSH
69820: EMPTY
69821: LIST
69822: LIST
69823: PUSH
69824: LD_INT 2
69826: PUSH
69827: LD_INT 2
69829: PUSH
69830: EMPTY
69831: LIST
69832: LIST
69833: PUSH
69834: LD_INT 1
69836: PUSH
69837: LD_INT 2
69839: PUSH
69840: EMPTY
69841: LIST
69842: LIST
69843: PUSH
69844: LD_INT 1
69846: NEG
69847: PUSH
69848: LD_INT 1
69850: PUSH
69851: EMPTY
69852: LIST
69853: LIST
69854: PUSH
69855: LD_INT 2
69857: NEG
69858: PUSH
69859: LD_INT 0
69861: PUSH
69862: EMPTY
69863: LIST
69864: LIST
69865: PUSH
69866: LD_INT 2
69868: NEG
69869: PUSH
69870: LD_INT 1
69872: NEG
69873: PUSH
69874: EMPTY
69875: LIST
69876: LIST
69877: PUSH
69878: LD_INT 2
69880: NEG
69881: PUSH
69882: LD_INT 2
69884: NEG
69885: PUSH
69886: EMPTY
69887: LIST
69888: LIST
69889: PUSH
69890: LD_INT 2
69892: NEG
69893: PUSH
69894: LD_INT 3
69896: NEG
69897: PUSH
69898: EMPTY
69899: LIST
69900: LIST
69901: PUSH
69902: LD_INT 2
69904: PUSH
69905: LD_INT 1
69907: NEG
69908: PUSH
69909: EMPTY
69910: LIST
69911: LIST
69912: PUSH
69913: LD_INT 3
69915: PUSH
69916: LD_INT 0
69918: PUSH
69919: EMPTY
69920: LIST
69921: LIST
69922: PUSH
69923: LD_INT 3
69925: PUSH
69926: LD_INT 1
69928: PUSH
69929: EMPTY
69930: LIST
69931: LIST
69932: PUSH
69933: LD_INT 3
69935: PUSH
69936: LD_INT 2
69938: PUSH
69939: EMPTY
69940: LIST
69941: LIST
69942: PUSH
69943: LD_INT 3
69945: PUSH
69946: LD_INT 3
69948: PUSH
69949: EMPTY
69950: LIST
69951: LIST
69952: PUSH
69953: LD_INT 2
69955: PUSH
69956: LD_INT 3
69958: PUSH
69959: EMPTY
69960: LIST
69961: LIST
69962: PUSH
69963: LD_INT 2
69965: NEG
69966: PUSH
69967: LD_INT 1
69969: PUSH
69970: EMPTY
69971: LIST
69972: LIST
69973: PUSH
69974: LD_INT 3
69976: NEG
69977: PUSH
69978: LD_INT 0
69980: PUSH
69981: EMPTY
69982: LIST
69983: LIST
69984: PUSH
69985: LD_INT 3
69987: NEG
69988: PUSH
69989: LD_INT 1
69991: NEG
69992: PUSH
69993: EMPTY
69994: LIST
69995: LIST
69996: PUSH
69997: LD_INT 3
69999: NEG
70000: PUSH
70001: LD_INT 2
70003: NEG
70004: PUSH
70005: EMPTY
70006: LIST
70007: LIST
70008: PUSH
70009: LD_INT 3
70011: NEG
70012: PUSH
70013: LD_INT 3
70015: NEG
70016: PUSH
70017: EMPTY
70018: LIST
70019: LIST
70020: PUSH
70021: EMPTY
70022: LIST
70023: LIST
70024: LIST
70025: LIST
70026: LIST
70027: LIST
70028: LIST
70029: LIST
70030: LIST
70031: LIST
70032: LIST
70033: LIST
70034: LIST
70035: LIST
70036: LIST
70037: LIST
70038: LIST
70039: LIST
70040: LIST
70041: LIST
70042: LIST
70043: LIST
70044: LIST
70045: LIST
70046: LIST
70047: LIST
70048: LIST
70049: LIST
70050: LIST
70051: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70052: LD_ADDR_VAR 0 42
70056: PUSH
70057: LD_INT 0
70059: PUSH
70060: LD_INT 0
70062: PUSH
70063: EMPTY
70064: LIST
70065: LIST
70066: PUSH
70067: LD_INT 0
70069: PUSH
70070: LD_INT 1
70072: NEG
70073: PUSH
70074: EMPTY
70075: LIST
70076: LIST
70077: PUSH
70078: LD_INT 1
70080: PUSH
70081: LD_INT 0
70083: PUSH
70084: EMPTY
70085: LIST
70086: LIST
70087: PUSH
70088: LD_INT 1
70090: PUSH
70091: LD_INT 1
70093: PUSH
70094: EMPTY
70095: LIST
70096: LIST
70097: PUSH
70098: LD_INT 0
70100: PUSH
70101: LD_INT 1
70103: PUSH
70104: EMPTY
70105: LIST
70106: LIST
70107: PUSH
70108: LD_INT 1
70110: NEG
70111: PUSH
70112: LD_INT 0
70114: PUSH
70115: EMPTY
70116: LIST
70117: LIST
70118: PUSH
70119: LD_INT 1
70121: NEG
70122: PUSH
70123: LD_INT 1
70125: NEG
70126: PUSH
70127: EMPTY
70128: LIST
70129: LIST
70130: PUSH
70131: LD_INT 1
70133: NEG
70134: PUSH
70135: LD_INT 2
70137: NEG
70138: PUSH
70139: EMPTY
70140: LIST
70141: LIST
70142: PUSH
70143: LD_INT 0
70145: PUSH
70146: LD_INT 2
70148: NEG
70149: PUSH
70150: EMPTY
70151: LIST
70152: LIST
70153: PUSH
70154: LD_INT 1
70156: PUSH
70157: LD_INT 1
70159: NEG
70160: PUSH
70161: EMPTY
70162: LIST
70163: LIST
70164: PUSH
70165: LD_INT 2
70167: PUSH
70168: LD_INT 1
70170: PUSH
70171: EMPTY
70172: LIST
70173: LIST
70174: PUSH
70175: LD_INT 2
70177: PUSH
70178: LD_INT 2
70180: PUSH
70181: EMPTY
70182: LIST
70183: LIST
70184: PUSH
70185: LD_INT 1
70187: PUSH
70188: LD_INT 2
70190: PUSH
70191: EMPTY
70192: LIST
70193: LIST
70194: PUSH
70195: LD_INT 0
70197: PUSH
70198: LD_INT 2
70200: PUSH
70201: EMPTY
70202: LIST
70203: LIST
70204: PUSH
70205: LD_INT 1
70207: NEG
70208: PUSH
70209: LD_INT 1
70211: PUSH
70212: EMPTY
70213: LIST
70214: LIST
70215: PUSH
70216: LD_INT 2
70218: NEG
70219: PUSH
70220: LD_INT 1
70222: NEG
70223: PUSH
70224: EMPTY
70225: LIST
70226: LIST
70227: PUSH
70228: LD_INT 2
70230: NEG
70231: PUSH
70232: LD_INT 2
70234: NEG
70235: PUSH
70236: EMPTY
70237: LIST
70238: LIST
70239: PUSH
70240: LD_INT 2
70242: NEG
70243: PUSH
70244: LD_INT 3
70246: NEG
70247: PUSH
70248: EMPTY
70249: LIST
70250: LIST
70251: PUSH
70252: LD_INT 1
70254: NEG
70255: PUSH
70256: LD_INT 3
70258: NEG
70259: PUSH
70260: EMPTY
70261: LIST
70262: LIST
70263: PUSH
70264: LD_INT 0
70266: PUSH
70267: LD_INT 3
70269: NEG
70270: PUSH
70271: EMPTY
70272: LIST
70273: LIST
70274: PUSH
70275: LD_INT 1
70277: PUSH
70278: LD_INT 2
70280: NEG
70281: PUSH
70282: EMPTY
70283: LIST
70284: LIST
70285: PUSH
70286: LD_INT 3
70288: PUSH
70289: LD_INT 2
70291: PUSH
70292: EMPTY
70293: LIST
70294: LIST
70295: PUSH
70296: LD_INT 3
70298: PUSH
70299: LD_INT 3
70301: PUSH
70302: EMPTY
70303: LIST
70304: LIST
70305: PUSH
70306: LD_INT 2
70308: PUSH
70309: LD_INT 3
70311: PUSH
70312: EMPTY
70313: LIST
70314: LIST
70315: PUSH
70316: LD_INT 1
70318: PUSH
70319: LD_INT 3
70321: PUSH
70322: EMPTY
70323: LIST
70324: LIST
70325: PUSH
70326: LD_INT 0
70328: PUSH
70329: LD_INT 3
70331: PUSH
70332: EMPTY
70333: LIST
70334: LIST
70335: PUSH
70336: LD_INT 1
70338: NEG
70339: PUSH
70340: LD_INT 2
70342: PUSH
70343: EMPTY
70344: LIST
70345: LIST
70346: PUSH
70347: LD_INT 3
70349: NEG
70350: PUSH
70351: LD_INT 2
70353: NEG
70354: PUSH
70355: EMPTY
70356: LIST
70357: LIST
70358: PUSH
70359: LD_INT 3
70361: NEG
70362: PUSH
70363: LD_INT 3
70365: NEG
70366: PUSH
70367: EMPTY
70368: LIST
70369: LIST
70370: PUSH
70371: EMPTY
70372: LIST
70373: LIST
70374: LIST
70375: LIST
70376: LIST
70377: LIST
70378: LIST
70379: LIST
70380: LIST
70381: LIST
70382: LIST
70383: LIST
70384: LIST
70385: LIST
70386: LIST
70387: LIST
70388: LIST
70389: LIST
70390: LIST
70391: LIST
70392: LIST
70393: LIST
70394: LIST
70395: LIST
70396: LIST
70397: LIST
70398: LIST
70399: LIST
70400: LIST
70401: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
70402: LD_ADDR_VAR 0 43
70406: PUSH
70407: LD_INT 0
70409: PUSH
70410: LD_INT 0
70412: PUSH
70413: EMPTY
70414: LIST
70415: LIST
70416: PUSH
70417: LD_INT 0
70419: PUSH
70420: LD_INT 1
70422: NEG
70423: PUSH
70424: EMPTY
70425: LIST
70426: LIST
70427: PUSH
70428: LD_INT 1
70430: PUSH
70431: LD_INT 0
70433: PUSH
70434: EMPTY
70435: LIST
70436: LIST
70437: PUSH
70438: LD_INT 1
70440: PUSH
70441: LD_INT 1
70443: PUSH
70444: EMPTY
70445: LIST
70446: LIST
70447: PUSH
70448: LD_INT 0
70450: PUSH
70451: LD_INT 1
70453: PUSH
70454: EMPTY
70455: LIST
70456: LIST
70457: PUSH
70458: LD_INT 1
70460: NEG
70461: PUSH
70462: LD_INT 0
70464: PUSH
70465: EMPTY
70466: LIST
70467: LIST
70468: PUSH
70469: LD_INT 1
70471: NEG
70472: PUSH
70473: LD_INT 1
70475: NEG
70476: PUSH
70477: EMPTY
70478: LIST
70479: LIST
70480: PUSH
70481: LD_INT 1
70483: NEG
70484: PUSH
70485: LD_INT 2
70487: NEG
70488: PUSH
70489: EMPTY
70490: LIST
70491: LIST
70492: PUSH
70493: LD_INT 0
70495: PUSH
70496: LD_INT 2
70498: NEG
70499: PUSH
70500: EMPTY
70501: LIST
70502: LIST
70503: PUSH
70504: LD_INT 1
70506: PUSH
70507: LD_INT 1
70509: NEG
70510: PUSH
70511: EMPTY
70512: LIST
70513: LIST
70514: PUSH
70515: LD_INT 2
70517: PUSH
70518: LD_INT 0
70520: PUSH
70521: EMPTY
70522: LIST
70523: LIST
70524: PUSH
70525: LD_INT 2
70527: PUSH
70528: LD_INT 1
70530: PUSH
70531: EMPTY
70532: LIST
70533: LIST
70534: PUSH
70535: LD_INT 1
70537: PUSH
70538: LD_INT 2
70540: PUSH
70541: EMPTY
70542: LIST
70543: LIST
70544: PUSH
70545: LD_INT 0
70547: PUSH
70548: LD_INT 2
70550: PUSH
70551: EMPTY
70552: LIST
70553: LIST
70554: PUSH
70555: LD_INT 1
70557: NEG
70558: PUSH
70559: LD_INT 1
70561: PUSH
70562: EMPTY
70563: LIST
70564: LIST
70565: PUSH
70566: LD_INT 2
70568: NEG
70569: PUSH
70570: LD_INT 0
70572: PUSH
70573: EMPTY
70574: LIST
70575: LIST
70576: PUSH
70577: LD_INT 2
70579: NEG
70580: PUSH
70581: LD_INT 1
70583: NEG
70584: PUSH
70585: EMPTY
70586: LIST
70587: LIST
70588: PUSH
70589: LD_INT 1
70591: NEG
70592: PUSH
70593: LD_INT 3
70595: NEG
70596: PUSH
70597: EMPTY
70598: LIST
70599: LIST
70600: PUSH
70601: LD_INT 0
70603: PUSH
70604: LD_INT 3
70606: NEG
70607: PUSH
70608: EMPTY
70609: LIST
70610: LIST
70611: PUSH
70612: LD_INT 1
70614: PUSH
70615: LD_INT 2
70617: NEG
70618: PUSH
70619: EMPTY
70620: LIST
70621: LIST
70622: PUSH
70623: LD_INT 2
70625: PUSH
70626: LD_INT 1
70628: NEG
70629: PUSH
70630: EMPTY
70631: LIST
70632: LIST
70633: PUSH
70634: LD_INT 3
70636: PUSH
70637: LD_INT 0
70639: PUSH
70640: EMPTY
70641: LIST
70642: LIST
70643: PUSH
70644: LD_INT 3
70646: PUSH
70647: LD_INT 1
70649: PUSH
70650: EMPTY
70651: LIST
70652: LIST
70653: PUSH
70654: LD_INT 1
70656: PUSH
70657: LD_INT 3
70659: PUSH
70660: EMPTY
70661: LIST
70662: LIST
70663: PUSH
70664: LD_INT 0
70666: PUSH
70667: LD_INT 3
70669: PUSH
70670: EMPTY
70671: LIST
70672: LIST
70673: PUSH
70674: LD_INT 1
70676: NEG
70677: PUSH
70678: LD_INT 2
70680: PUSH
70681: EMPTY
70682: LIST
70683: LIST
70684: PUSH
70685: LD_INT 2
70687: NEG
70688: PUSH
70689: LD_INT 1
70691: PUSH
70692: EMPTY
70693: LIST
70694: LIST
70695: PUSH
70696: LD_INT 3
70698: NEG
70699: PUSH
70700: LD_INT 0
70702: PUSH
70703: EMPTY
70704: LIST
70705: LIST
70706: PUSH
70707: LD_INT 3
70709: NEG
70710: PUSH
70711: LD_INT 1
70713: NEG
70714: PUSH
70715: EMPTY
70716: LIST
70717: LIST
70718: PUSH
70719: EMPTY
70720: LIST
70721: LIST
70722: LIST
70723: LIST
70724: LIST
70725: LIST
70726: LIST
70727: LIST
70728: LIST
70729: LIST
70730: LIST
70731: LIST
70732: LIST
70733: LIST
70734: LIST
70735: LIST
70736: LIST
70737: LIST
70738: LIST
70739: LIST
70740: LIST
70741: LIST
70742: LIST
70743: LIST
70744: LIST
70745: LIST
70746: LIST
70747: LIST
70748: LIST
70749: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70750: LD_ADDR_VAR 0 44
70754: PUSH
70755: LD_INT 0
70757: PUSH
70758: LD_INT 0
70760: PUSH
70761: EMPTY
70762: LIST
70763: LIST
70764: PUSH
70765: LD_INT 0
70767: PUSH
70768: LD_INT 1
70770: NEG
70771: PUSH
70772: EMPTY
70773: LIST
70774: LIST
70775: PUSH
70776: LD_INT 1
70778: PUSH
70779: LD_INT 0
70781: PUSH
70782: EMPTY
70783: LIST
70784: LIST
70785: PUSH
70786: LD_INT 1
70788: PUSH
70789: LD_INT 1
70791: PUSH
70792: EMPTY
70793: LIST
70794: LIST
70795: PUSH
70796: LD_INT 0
70798: PUSH
70799: LD_INT 1
70801: PUSH
70802: EMPTY
70803: LIST
70804: LIST
70805: PUSH
70806: LD_INT 1
70808: NEG
70809: PUSH
70810: LD_INT 0
70812: PUSH
70813: EMPTY
70814: LIST
70815: LIST
70816: PUSH
70817: LD_INT 1
70819: NEG
70820: PUSH
70821: LD_INT 1
70823: NEG
70824: PUSH
70825: EMPTY
70826: LIST
70827: LIST
70828: PUSH
70829: LD_INT 1
70831: NEG
70832: PUSH
70833: LD_INT 2
70835: NEG
70836: PUSH
70837: EMPTY
70838: LIST
70839: LIST
70840: PUSH
70841: LD_INT 1
70843: PUSH
70844: LD_INT 1
70846: NEG
70847: PUSH
70848: EMPTY
70849: LIST
70850: LIST
70851: PUSH
70852: LD_INT 2
70854: PUSH
70855: LD_INT 0
70857: PUSH
70858: EMPTY
70859: LIST
70860: LIST
70861: PUSH
70862: LD_INT 2
70864: PUSH
70865: LD_INT 1
70867: PUSH
70868: EMPTY
70869: LIST
70870: LIST
70871: PUSH
70872: LD_INT 2
70874: PUSH
70875: LD_INT 2
70877: PUSH
70878: EMPTY
70879: LIST
70880: LIST
70881: PUSH
70882: LD_INT 1
70884: PUSH
70885: LD_INT 2
70887: PUSH
70888: EMPTY
70889: LIST
70890: LIST
70891: PUSH
70892: LD_INT 1
70894: NEG
70895: PUSH
70896: LD_INT 1
70898: PUSH
70899: EMPTY
70900: LIST
70901: LIST
70902: PUSH
70903: LD_INT 2
70905: NEG
70906: PUSH
70907: LD_INT 0
70909: PUSH
70910: EMPTY
70911: LIST
70912: LIST
70913: PUSH
70914: LD_INT 2
70916: NEG
70917: PUSH
70918: LD_INT 1
70920: NEG
70921: PUSH
70922: EMPTY
70923: LIST
70924: LIST
70925: PUSH
70926: LD_INT 2
70928: NEG
70929: PUSH
70930: LD_INT 2
70932: NEG
70933: PUSH
70934: EMPTY
70935: LIST
70936: LIST
70937: PUSH
70938: LD_INT 2
70940: NEG
70941: PUSH
70942: LD_INT 3
70944: NEG
70945: PUSH
70946: EMPTY
70947: LIST
70948: LIST
70949: PUSH
70950: LD_INT 2
70952: PUSH
70953: LD_INT 1
70955: NEG
70956: PUSH
70957: EMPTY
70958: LIST
70959: LIST
70960: PUSH
70961: LD_INT 3
70963: PUSH
70964: LD_INT 0
70966: PUSH
70967: EMPTY
70968: LIST
70969: LIST
70970: PUSH
70971: LD_INT 3
70973: PUSH
70974: LD_INT 1
70976: PUSH
70977: EMPTY
70978: LIST
70979: LIST
70980: PUSH
70981: LD_INT 3
70983: PUSH
70984: LD_INT 2
70986: PUSH
70987: EMPTY
70988: LIST
70989: LIST
70990: PUSH
70991: LD_INT 3
70993: PUSH
70994: LD_INT 3
70996: PUSH
70997: EMPTY
70998: LIST
70999: LIST
71000: PUSH
71001: LD_INT 2
71003: PUSH
71004: LD_INT 3
71006: PUSH
71007: EMPTY
71008: LIST
71009: LIST
71010: PUSH
71011: LD_INT 2
71013: NEG
71014: PUSH
71015: LD_INT 1
71017: PUSH
71018: EMPTY
71019: LIST
71020: LIST
71021: PUSH
71022: LD_INT 3
71024: NEG
71025: PUSH
71026: LD_INT 0
71028: PUSH
71029: EMPTY
71030: LIST
71031: LIST
71032: PUSH
71033: LD_INT 3
71035: NEG
71036: PUSH
71037: LD_INT 1
71039: NEG
71040: PUSH
71041: EMPTY
71042: LIST
71043: LIST
71044: PUSH
71045: LD_INT 3
71047: NEG
71048: PUSH
71049: LD_INT 2
71051: NEG
71052: PUSH
71053: EMPTY
71054: LIST
71055: LIST
71056: PUSH
71057: LD_INT 3
71059: NEG
71060: PUSH
71061: LD_INT 3
71063: NEG
71064: PUSH
71065: EMPTY
71066: LIST
71067: LIST
71068: PUSH
71069: EMPTY
71070: LIST
71071: LIST
71072: LIST
71073: LIST
71074: LIST
71075: LIST
71076: LIST
71077: LIST
71078: LIST
71079: LIST
71080: LIST
71081: LIST
71082: LIST
71083: LIST
71084: LIST
71085: LIST
71086: LIST
71087: LIST
71088: LIST
71089: LIST
71090: LIST
71091: LIST
71092: LIST
71093: LIST
71094: LIST
71095: LIST
71096: LIST
71097: LIST
71098: LIST
71099: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
71100: LD_ADDR_VAR 0 45
71104: PUSH
71105: LD_INT 0
71107: PUSH
71108: LD_INT 0
71110: PUSH
71111: EMPTY
71112: LIST
71113: LIST
71114: PUSH
71115: LD_INT 0
71117: PUSH
71118: LD_INT 1
71120: NEG
71121: PUSH
71122: EMPTY
71123: LIST
71124: LIST
71125: PUSH
71126: LD_INT 1
71128: PUSH
71129: LD_INT 0
71131: PUSH
71132: EMPTY
71133: LIST
71134: LIST
71135: PUSH
71136: LD_INT 1
71138: PUSH
71139: LD_INT 1
71141: PUSH
71142: EMPTY
71143: LIST
71144: LIST
71145: PUSH
71146: LD_INT 0
71148: PUSH
71149: LD_INT 1
71151: PUSH
71152: EMPTY
71153: LIST
71154: LIST
71155: PUSH
71156: LD_INT 1
71158: NEG
71159: PUSH
71160: LD_INT 0
71162: PUSH
71163: EMPTY
71164: LIST
71165: LIST
71166: PUSH
71167: LD_INT 1
71169: NEG
71170: PUSH
71171: LD_INT 1
71173: NEG
71174: PUSH
71175: EMPTY
71176: LIST
71177: LIST
71178: PUSH
71179: LD_INT 1
71181: NEG
71182: PUSH
71183: LD_INT 2
71185: NEG
71186: PUSH
71187: EMPTY
71188: LIST
71189: LIST
71190: PUSH
71191: LD_INT 0
71193: PUSH
71194: LD_INT 2
71196: NEG
71197: PUSH
71198: EMPTY
71199: LIST
71200: LIST
71201: PUSH
71202: LD_INT 1
71204: PUSH
71205: LD_INT 1
71207: NEG
71208: PUSH
71209: EMPTY
71210: LIST
71211: LIST
71212: PUSH
71213: LD_INT 2
71215: PUSH
71216: LD_INT 1
71218: PUSH
71219: EMPTY
71220: LIST
71221: LIST
71222: PUSH
71223: LD_INT 2
71225: PUSH
71226: LD_INT 2
71228: PUSH
71229: EMPTY
71230: LIST
71231: LIST
71232: PUSH
71233: LD_INT 1
71235: PUSH
71236: LD_INT 2
71238: PUSH
71239: EMPTY
71240: LIST
71241: LIST
71242: PUSH
71243: LD_INT 0
71245: PUSH
71246: LD_INT 2
71248: PUSH
71249: EMPTY
71250: LIST
71251: LIST
71252: PUSH
71253: LD_INT 1
71255: NEG
71256: PUSH
71257: LD_INT 1
71259: PUSH
71260: EMPTY
71261: LIST
71262: LIST
71263: PUSH
71264: LD_INT 2
71266: NEG
71267: PUSH
71268: LD_INT 1
71270: NEG
71271: PUSH
71272: EMPTY
71273: LIST
71274: LIST
71275: PUSH
71276: LD_INT 2
71278: NEG
71279: PUSH
71280: LD_INT 2
71282: NEG
71283: PUSH
71284: EMPTY
71285: LIST
71286: LIST
71287: PUSH
71288: LD_INT 2
71290: NEG
71291: PUSH
71292: LD_INT 3
71294: NEG
71295: PUSH
71296: EMPTY
71297: LIST
71298: LIST
71299: PUSH
71300: LD_INT 1
71302: NEG
71303: PUSH
71304: LD_INT 3
71306: NEG
71307: PUSH
71308: EMPTY
71309: LIST
71310: LIST
71311: PUSH
71312: LD_INT 0
71314: PUSH
71315: LD_INT 3
71317: NEG
71318: PUSH
71319: EMPTY
71320: LIST
71321: LIST
71322: PUSH
71323: LD_INT 1
71325: PUSH
71326: LD_INT 2
71328: NEG
71329: PUSH
71330: EMPTY
71331: LIST
71332: LIST
71333: PUSH
71334: LD_INT 3
71336: PUSH
71337: LD_INT 2
71339: PUSH
71340: EMPTY
71341: LIST
71342: LIST
71343: PUSH
71344: LD_INT 3
71346: PUSH
71347: LD_INT 3
71349: PUSH
71350: EMPTY
71351: LIST
71352: LIST
71353: PUSH
71354: LD_INT 2
71356: PUSH
71357: LD_INT 3
71359: PUSH
71360: EMPTY
71361: LIST
71362: LIST
71363: PUSH
71364: LD_INT 1
71366: PUSH
71367: LD_INT 3
71369: PUSH
71370: EMPTY
71371: LIST
71372: LIST
71373: PUSH
71374: LD_INT 0
71376: PUSH
71377: LD_INT 3
71379: PUSH
71380: EMPTY
71381: LIST
71382: LIST
71383: PUSH
71384: LD_INT 1
71386: NEG
71387: PUSH
71388: LD_INT 2
71390: PUSH
71391: EMPTY
71392: LIST
71393: LIST
71394: PUSH
71395: LD_INT 3
71397: NEG
71398: PUSH
71399: LD_INT 2
71401: NEG
71402: PUSH
71403: EMPTY
71404: LIST
71405: LIST
71406: PUSH
71407: LD_INT 3
71409: NEG
71410: PUSH
71411: LD_INT 3
71413: NEG
71414: PUSH
71415: EMPTY
71416: LIST
71417: LIST
71418: PUSH
71419: EMPTY
71420: LIST
71421: LIST
71422: LIST
71423: LIST
71424: LIST
71425: LIST
71426: LIST
71427: LIST
71428: LIST
71429: LIST
71430: LIST
71431: LIST
71432: LIST
71433: LIST
71434: LIST
71435: LIST
71436: LIST
71437: LIST
71438: LIST
71439: LIST
71440: LIST
71441: LIST
71442: LIST
71443: LIST
71444: LIST
71445: LIST
71446: LIST
71447: LIST
71448: LIST
71449: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
71450: LD_ADDR_VAR 0 46
71454: PUSH
71455: LD_INT 0
71457: PUSH
71458: LD_INT 0
71460: PUSH
71461: EMPTY
71462: LIST
71463: LIST
71464: PUSH
71465: LD_INT 0
71467: PUSH
71468: LD_INT 1
71470: NEG
71471: PUSH
71472: EMPTY
71473: LIST
71474: LIST
71475: PUSH
71476: LD_INT 1
71478: PUSH
71479: LD_INT 0
71481: PUSH
71482: EMPTY
71483: LIST
71484: LIST
71485: PUSH
71486: LD_INT 1
71488: PUSH
71489: LD_INT 1
71491: PUSH
71492: EMPTY
71493: LIST
71494: LIST
71495: PUSH
71496: LD_INT 0
71498: PUSH
71499: LD_INT 1
71501: PUSH
71502: EMPTY
71503: LIST
71504: LIST
71505: PUSH
71506: LD_INT 1
71508: NEG
71509: PUSH
71510: LD_INT 0
71512: PUSH
71513: EMPTY
71514: LIST
71515: LIST
71516: PUSH
71517: LD_INT 1
71519: NEG
71520: PUSH
71521: LD_INT 1
71523: NEG
71524: PUSH
71525: EMPTY
71526: LIST
71527: LIST
71528: PUSH
71529: LD_INT 1
71531: NEG
71532: PUSH
71533: LD_INT 2
71535: NEG
71536: PUSH
71537: EMPTY
71538: LIST
71539: LIST
71540: PUSH
71541: LD_INT 0
71543: PUSH
71544: LD_INT 2
71546: NEG
71547: PUSH
71548: EMPTY
71549: LIST
71550: LIST
71551: PUSH
71552: LD_INT 1
71554: PUSH
71555: LD_INT 1
71557: NEG
71558: PUSH
71559: EMPTY
71560: LIST
71561: LIST
71562: PUSH
71563: LD_INT 2
71565: PUSH
71566: LD_INT 0
71568: PUSH
71569: EMPTY
71570: LIST
71571: LIST
71572: PUSH
71573: LD_INT 2
71575: PUSH
71576: LD_INT 1
71578: PUSH
71579: EMPTY
71580: LIST
71581: LIST
71582: PUSH
71583: LD_INT 1
71585: PUSH
71586: LD_INT 2
71588: PUSH
71589: EMPTY
71590: LIST
71591: LIST
71592: PUSH
71593: LD_INT 0
71595: PUSH
71596: LD_INT 2
71598: PUSH
71599: EMPTY
71600: LIST
71601: LIST
71602: PUSH
71603: LD_INT 1
71605: NEG
71606: PUSH
71607: LD_INT 1
71609: PUSH
71610: EMPTY
71611: LIST
71612: LIST
71613: PUSH
71614: LD_INT 2
71616: NEG
71617: PUSH
71618: LD_INT 0
71620: PUSH
71621: EMPTY
71622: LIST
71623: LIST
71624: PUSH
71625: LD_INT 2
71627: NEG
71628: PUSH
71629: LD_INT 1
71631: NEG
71632: PUSH
71633: EMPTY
71634: LIST
71635: LIST
71636: PUSH
71637: LD_INT 1
71639: NEG
71640: PUSH
71641: LD_INT 3
71643: NEG
71644: PUSH
71645: EMPTY
71646: LIST
71647: LIST
71648: PUSH
71649: LD_INT 0
71651: PUSH
71652: LD_INT 3
71654: NEG
71655: PUSH
71656: EMPTY
71657: LIST
71658: LIST
71659: PUSH
71660: LD_INT 1
71662: PUSH
71663: LD_INT 2
71665: NEG
71666: PUSH
71667: EMPTY
71668: LIST
71669: LIST
71670: PUSH
71671: LD_INT 2
71673: PUSH
71674: LD_INT 1
71676: NEG
71677: PUSH
71678: EMPTY
71679: LIST
71680: LIST
71681: PUSH
71682: LD_INT 3
71684: PUSH
71685: LD_INT 0
71687: PUSH
71688: EMPTY
71689: LIST
71690: LIST
71691: PUSH
71692: LD_INT 3
71694: PUSH
71695: LD_INT 1
71697: PUSH
71698: EMPTY
71699: LIST
71700: LIST
71701: PUSH
71702: LD_INT 1
71704: PUSH
71705: LD_INT 3
71707: PUSH
71708: EMPTY
71709: LIST
71710: LIST
71711: PUSH
71712: LD_INT 0
71714: PUSH
71715: LD_INT 3
71717: PUSH
71718: EMPTY
71719: LIST
71720: LIST
71721: PUSH
71722: LD_INT 1
71724: NEG
71725: PUSH
71726: LD_INT 2
71728: PUSH
71729: EMPTY
71730: LIST
71731: LIST
71732: PUSH
71733: LD_INT 2
71735: NEG
71736: PUSH
71737: LD_INT 1
71739: PUSH
71740: EMPTY
71741: LIST
71742: LIST
71743: PUSH
71744: LD_INT 3
71746: NEG
71747: PUSH
71748: LD_INT 0
71750: PUSH
71751: EMPTY
71752: LIST
71753: LIST
71754: PUSH
71755: LD_INT 3
71757: NEG
71758: PUSH
71759: LD_INT 1
71761: NEG
71762: PUSH
71763: EMPTY
71764: LIST
71765: LIST
71766: PUSH
71767: EMPTY
71768: LIST
71769: LIST
71770: LIST
71771: LIST
71772: LIST
71773: LIST
71774: LIST
71775: LIST
71776: LIST
71777: LIST
71778: LIST
71779: LIST
71780: LIST
71781: LIST
71782: LIST
71783: LIST
71784: LIST
71785: LIST
71786: LIST
71787: LIST
71788: LIST
71789: LIST
71790: LIST
71791: LIST
71792: LIST
71793: LIST
71794: LIST
71795: LIST
71796: LIST
71797: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71798: LD_ADDR_VAR 0 47
71802: PUSH
71803: LD_INT 0
71805: PUSH
71806: LD_INT 0
71808: PUSH
71809: EMPTY
71810: LIST
71811: LIST
71812: PUSH
71813: LD_INT 0
71815: PUSH
71816: LD_INT 1
71818: NEG
71819: PUSH
71820: EMPTY
71821: LIST
71822: LIST
71823: PUSH
71824: LD_INT 1
71826: PUSH
71827: LD_INT 0
71829: PUSH
71830: EMPTY
71831: LIST
71832: LIST
71833: PUSH
71834: LD_INT 1
71836: PUSH
71837: LD_INT 1
71839: PUSH
71840: EMPTY
71841: LIST
71842: LIST
71843: PUSH
71844: LD_INT 0
71846: PUSH
71847: LD_INT 1
71849: PUSH
71850: EMPTY
71851: LIST
71852: LIST
71853: PUSH
71854: LD_INT 1
71856: NEG
71857: PUSH
71858: LD_INT 0
71860: PUSH
71861: EMPTY
71862: LIST
71863: LIST
71864: PUSH
71865: LD_INT 1
71867: NEG
71868: PUSH
71869: LD_INT 1
71871: NEG
71872: PUSH
71873: EMPTY
71874: LIST
71875: LIST
71876: PUSH
71877: LD_INT 1
71879: NEG
71880: PUSH
71881: LD_INT 2
71883: NEG
71884: PUSH
71885: EMPTY
71886: LIST
71887: LIST
71888: PUSH
71889: LD_INT 0
71891: PUSH
71892: LD_INT 2
71894: NEG
71895: PUSH
71896: EMPTY
71897: LIST
71898: LIST
71899: PUSH
71900: LD_INT 1
71902: PUSH
71903: LD_INT 1
71905: NEG
71906: PUSH
71907: EMPTY
71908: LIST
71909: LIST
71910: PUSH
71911: LD_INT 2
71913: NEG
71914: PUSH
71915: LD_INT 1
71917: NEG
71918: PUSH
71919: EMPTY
71920: LIST
71921: LIST
71922: PUSH
71923: LD_INT 2
71925: NEG
71926: PUSH
71927: LD_INT 2
71929: NEG
71930: PUSH
71931: EMPTY
71932: LIST
71933: LIST
71934: PUSH
71935: EMPTY
71936: LIST
71937: LIST
71938: LIST
71939: LIST
71940: LIST
71941: LIST
71942: LIST
71943: LIST
71944: LIST
71945: LIST
71946: LIST
71947: LIST
71948: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
71949: LD_ADDR_VAR 0 48
71953: PUSH
71954: LD_INT 0
71956: PUSH
71957: LD_INT 0
71959: PUSH
71960: EMPTY
71961: LIST
71962: LIST
71963: PUSH
71964: LD_INT 0
71966: PUSH
71967: LD_INT 1
71969: NEG
71970: PUSH
71971: EMPTY
71972: LIST
71973: LIST
71974: PUSH
71975: LD_INT 1
71977: PUSH
71978: LD_INT 0
71980: PUSH
71981: EMPTY
71982: LIST
71983: LIST
71984: PUSH
71985: LD_INT 1
71987: PUSH
71988: LD_INT 1
71990: PUSH
71991: EMPTY
71992: LIST
71993: LIST
71994: PUSH
71995: LD_INT 0
71997: PUSH
71998: LD_INT 1
72000: PUSH
72001: EMPTY
72002: LIST
72003: LIST
72004: PUSH
72005: LD_INT 1
72007: NEG
72008: PUSH
72009: LD_INT 0
72011: PUSH
72012: EMPTY
72013: LIST
72014: LIST
72015: PUSH
72016: LD_INT 1
72018: NEG
72019: PUSH
72020: LD_INT 1
72022: NEG
72023: PUSH
72024: EMPTY
72025: LIST
72026: LIST
72027: PUSH
72028: LD_INT 1
72030: NEG
72031: PUSH
72032: LD_INT 2
72034: NEG
72035: PUSH
72036: EMPTY
72037: LIST
72038: LIST
72039: PUSH
72040: LD_INT 0
72042: PUSH
72043: LD_INT 2
72045: NEG
72046: PUSH
72047: EMPTY
72048: LIST
72049: LIST
72050: PUSH
72051: LD_INT 1
72053: PUSH
72054: LD_INT 1
72056: NEG
72057: PUSH
72058: EMPTY
72059: LIST
72060: LIST
72061: PUSH
72062: LD_INT 2
72064: PUSH
72065: LD_INT 0
72067: PUSH
72068: EMPTY
72069: LIST
72070: LIST
72071: PUSH
72072: LD_INT 2
72074: PUSH
72075: LD_INT 1
72077: PUSH
72078: EMPTY
72079: LIST
72080: LIST
72081: PUSH
72082: EMPTY
72083: LIST
72084: LIST
72085: LIST
72086: LIST
72087: LIST
72088: LIST
72089: LIST
72090: LIST
72091: LIST
72092: LIST
72093: LIST
72094: LIST
72095: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
72096: LD_ADDR_VAR 0 49
72100: PUSH
72101: LD_INT 0
72103: PUSH
72104: LD_INT 0
72106: PUSH
72107: EMPTY
72108: LIST
72109: LIST
72110: PUSH
72111: LD_INT 0
72113: PUSH
72114: LD_INT 1
72116: NEG
72117: PUSH
72118: EMPTY
72119: LIST
72120: LIST
72121: PUSH
72122: LD_INT 1
72124: PUSH
72125: LD_INT 0
72127: PUSH
72128: EMPTY
72129: LIST
72130: LIST
72131: PUSH
72132: LD_INT 1
72134: PUSH
72135: LD_INT 1
72137: PUSH
72138: EMPTY
72139: LIST
72140: LIST
72141: PUSH
72142: LD_INT 0
72144: PUSH
72145: LD_INT 1
72147: PUSH
72148: EMPTY
72149: LIST
72150: LIST
72151: PUSH
72152: LD_INT 1
72154: NEG
72155: PUSH
72156: LD_INT 0
72158: PUSH
72159: EMPTY
72160: LIST
72161: LIST
72162: PUSH
72163: LD_INT 1
72165: NEG
72166: PUSH
72167: LD_INT 1
72169: NEG
72170: PUSH
72171: EMPTY
72172: LIST
72173: LIST
72174: PUSH
72175: LD_INT 1
72177: PUSH
72178: LD_INT 1
72180: NEG
72181: PUSH
72182: EMPTY
72183: LIST
72184: LIST
72185: PUSH
72186: LD_INT 2
72188: PUSH
72189: LD_INT 0
72191: PUSH
72192: EMPTY
72193: LIST
72194: LIST
72195: PUSH
72196: LD_INT 2
72198: PUSH
72199: LD_INT 1
72201: PUSH
72202: EMPTY
72203: LIST
72204: LIST
72205: PUSH
72206: LD_INT 2
72208: PUSH
72209: LD_INT 2
72211: PUSH
72212: EMPTY
72213: LIST
72214: LIST
72215: PUSH
72216: LD_INT 1
72218: PUSH
72219: LD_INT 2
72221: PUSH
72222: EMPTY
72223: LIST
72224: LIST
72225: PUSH
72226: EMPTY
72227: LIST
72228: LIST
72229: LIST
72230: LIST
72231: LIST
72232: LIST
72233: LIST
72234: LIST
72235: LIST
72236: LIST
72237: LIST
72238: LIST
72239: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
72240: LD_ADDR_VAR 0 50
72244: PUSH
72245: LD_INT 0
72247: PUSH
72248: LD_INT 0
72250: PUSH
72251: EMPTY
72252: LIST
72253: LIST
72254: PUSH
72255: LD_INT 0
72257: PUSH
72258: LD_INT 1
72260: NEG
72261: PUSH
72262: EMPTY
72263: LIST
72264: LIST
72265: PUSH
72266: LD_INT 1
72268: PUSH
72269: LD_INT 0
72271: PUSH
72272: EMPTY
72273: LIST
72274: LIST
72275: PUSH
72276: LD_INT 1
72278: PUSH
72279: LD_INT 1
72281: PUSH
72282: EMPTY
72283: LIST
72284: LIST
72285: PUSH
72286: LD_INT 0
72288: PUSH
72289: LD_INT 1
72291: PUSH
72292: EMPTY
72293: LIST
72294: LIST
72295: PUSH
72296: LD_INT 1
72298: NEG
72299: PUSH
72300: LD_INT 0
72302: PUSH
72303: EMPTY
72304: LIST
72305: LIST
72306: PUSH
72307: LD_INT 1
72309: NEG
72310: PUSH
72311: LD_INT 1
72313: NEG
72314: PUSH
72315: EMPTY
72316: LIST
72317: LIST
72318: PUSH
72319: LD_INT 2
72321: PUSH
72322: LD_INT 1
72324: PUSH
72325: EMPTY
72326: LIST
72327: LIST
72328: PUSH
72329: LD_INT 2
72331: PUSH
72332: LD_INT 2
72334: PUSH
72335: EMPTY
72336: LIST
72337: LIST
72338: PUSH
72339: LD_INT 1
72341: PUSH
72342: LD_INT 2
72344: PUSH
72345: EMPTY
72346: LIST
72347: LIST
72348: PUSH
72349: LD_INT 0
72351: PUSH
72352: LD_INT 2
72354: PUSH
72355: EMPTY
72356: LIST
72357: LIST
72358: PUSH
72359: LD_INT 1
72361: NEG
72362: PUSH
72363: LD_INT 1
72365: PUSH
72366: EMPTY
72367: LIST
72368: LIST
72369: PUSH
72370: EMPTY
72371: LIST
72372: LIST
72373: LIST
72374: LIST
72375: LIST
72376: LIST
72377: LIST
72378: LIST
72379: LIST
72380: LIST
72381: LIST
72382: LIST
72383: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
72384: LD_ADDR_VAR 0 51
72388: PUSH
72389: LD_INT 0
72391: PUSH
72392: LD_INT 0
72394: PUSH
72395: EMPTY
72396: LIST
72397: LIST
72398: PUSH
72399: LD_INT 0
72401: PUSH
72402: LD_INT 1
72404: NEG
72405: PUSH
72406: EMPTY
72407: LIST
72408: LIST
72409: PUSH
72410: LD_INT 1
72412: PUSH
72413: LD_INT 0
72415: PUSH
72416: EMPTY
72417: LIST
72418: LIST
72419: PUSH
72420: LD_INT 1
72422: PUSH
72423: LD_INT 1
72425: PUSH
72426: EMPTY
72427: LIST
72428: LIST
72429: PUSH
72430: LD_INT 0
72432: PUSH
72433: LD_INT 1
72435: PUSH
72436: EMPTY
72437: LIST
72438: LIST
72439: PUSH
72440: LD_INT 1
72442: NEG
72443: PUSH
72444: LD_INT 0
72446: PUSH
72447: EMPTY
72448: LIST
72449: LIST
72450: PUSH
72451: LD_INT 1
72453: NEG
72454: PUSH
72455: LD_INT 1
72457: NEG
72458: PUSH
72459: EMPTY
72460: LIST
72461: LIST
72462: PUSH
72463: LD_INT 1
72465: PUSH
72466: LD_INT 2
72468: PUSH
72469: EMPTY
72470: LIST
72471: LIST
72472: PUSH
72473: LD_INT 0
72475: PUSH
72476: LD_INT 2
72478: PUSH
72479: EMPTY
72480: LIST
72481: LIST
72482: PUSH
72483: LD_INT 1
72485: NEG
72486: PUSH
72487: LD_INT 1
72489: PUSH
72490: EMPTY
72491: LIST
72492: LIST
72493: PUSH
72494: LD_INT 2
72496: NEG
72497: PUSH
72498: LD_INT 0
72500: PUSH
72501: EMPTY
72502: LIST
72503: LIST
72504: PUSH
72505: LD_INT 2
72507: NEG
72508: PUSH
72509: LD_INT 1
72511: NEG
72512: PUSH
72513: EMPTY
72514: LIST
72515: LIST
72516: PUSH
72517: EMPTY
72518: LIST
72519: LIST
72520: LIST
72521: LIST
72522: LIST
72523: LIST
72524: LIST
72525: LIST
72526: LIST
72527: LIST
72528: LIST
72529: LIST
72530: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72531: LD_ADDR_VAR 0 52
72535: PUSH
72536: LD_INT 0
72538: PUSH
72539: LD_INT 0
72541: PUSH
72542: EMPTY
72543: LIST
72544: LIST
72545: PUSH
72546: LD_INT 0
72548: PUSH
72549: LD_INT 1
72551: NEG
72552: PUSH
72553: EMPTY
72554: LIST
72555: LIST
72556: PUSH
72557: LD_INT 1
72559: PUSH
72560: LD_INT 0
72562: PUSH
72563: EMPTY
72564: LIST
72565: LIST
72566: PUSH
72567: LD_INT 1
72569: PUSH
72570: LD_INT 1
72572: PUSH
72573: EMPTY
72574: LIST
72575: LIST
72576: PUSH
72577: LD_INT 0
72579: PUSH
72580: LD_INT 1
72582: PUSH
72583: EMPTY
72584: LIST
72585: LIST
72586: PUSH
72587: LD_INT 1
72589: NEG
72590: PUSH
72591: LD_INT 0
72593: PUSH
72594: EMPTY
72595: LIST
72596: LIST
72597: PUSH
72598: LD_INT 1
72600: NEG
72601: PUSH
72602: LD_INT 1
72604: NEG
72605: PUSH
72606: EMPTY
72607: LIST
72608: LIST
72609: PUSH
72610: LD_INT 1
72612: NEG
72613: PUSH
72614: LD_INT 2
72616: NEG
72617: PUSH
72618: EMPTY
72619: LIST
72620: LIST
72621: PUSH
72622: LD_INT 1
72624: NEG
72625: PUSH
72626: LD_INT 1
72628: PUSH
72629: EMPTY
72630: LIST
72631: LIST
72632: PUSH
72633: LD_INT 2
72635: NEG
72636: PUSH
72637: LD_INT 0
72639: PUSH
72640: EMPTY
72641: LIST
72642: LIST
72643: PUSH
72644: LD_INT 2
72646: NEG
72647: PUSH
72648: LD_INT 1
72650: NEG
72651: PUSH
72652: EMPTY
72653: LIST
72654: LIST
72655: PUSH
72656: LD_INT 2
72658: NEG
72659: PUSH
72660: LD_INT 2
72662: NEG
72663: PUSH
72664: EMPTY
72665: LIST
72666: LIST
72667: PUSH
72668: EMPTY
72669: LIST
72670: LIST
72671: LIST
72672: LIST
72673: LIST
72674: LIST
72675: LIST
72676: LIST
72677: LIST
72678: LIST
72679: LIST
72680: LIST
72681: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72682: LD_ADDR_VAR 0 53
72686: PUSH
72687: LD_INT 0
72689: PUSH
72690: LD_INT 0
72692: PUSH
72693: EMPTY
72694: LIST
72695: LIST
72696: PUSH
72697: LD_INT 0
72699: PUSH
72700: LD_INT 1
72702: NEG
72703: PUSH
72704: EMPTY
72705: LIST
72706: LIST
72707: PUSH
72708: LD_INT 1
72710: PUSH
72711: LD_INT 0
72713: PUSH
72714: EMPTY
72715: LIST
72716: LIST
72717: PUSH
72718: LD_INT 1
72720: PUSH
72721: LD_INT 1
72723: PUSH
72724: EMPTY
72725: LIST
72726: LIST
72727: PUSH
72728: LD_INT 0
72730: PUSH
72731: LD_INT 1
72733: PUSH
72734: EMPTY
72735: LIST
72736: LIST
72737: PUSH
72738: LD_INT 1
72740: NEG
72741: PUSH
72742: LD_INT 0
72744: PUSH
72745: EMPTY
72746: LIST
72747: LIST
72748: PUSH
72749: LD_INT 1
72751: NEG
72752: PUSH
72753: LD_INT 1
72755: NEG
72756: PUSH
72757: EMPTY
72758: LIST
72759: LIST
72760: PUSH
72761: LD_INT 1
72763: NEG
72764: PUSH
72765: LD_INT 2
72767: NEG
72768: PUSH
72769: EMPTY
72770: LIST
72771: LIST
72772: PUSH
72773: LD_INT 0
72775: PUSH
72776: LD_INT 2
72778: NEG
72779: PUSH
72780: EMPTY
72781: LIST
72782: LIST
72783: PUSH
72784: LD_INT 1
72786: PUSH
72787: LD_INT 1
72789: NEG
72790: PUSH
72791: EMPTY
72792: LIST
72793: LIST
72794: PUSH
72795: LD_INT 2
72797: PUSH
72798: LD_INT 0
72800: PUSH
72801: EMPTY
72802: LIST
72803: LIST
72804: PUSH
72805: LD_INT 2
72807: PUSH
72808: LD_INT 1
72810: PUSH
72811: EMPTY
72812: LIST
72813: LIST
72814: PUSH
72815: LD_INT 2
72817: PUSH
72818: LD_INT 2
72820: PUSH
72821: EMPTY
72822: LIST
72823: LIST
72824: PUSH
72825: LD_INT 1
72827: PUSH
72828: LD_INT 2
72830: PUSH
72831: EMPTY
72832: LIST
72833: LIST
72834: PUSH
72835: LD_INT 0
72837: PUSH
72838: LD_INT 2
72840: PUSH
72841: EMPTY
72842: LIST
72843: LIST
72844: PUSH
72845: LD_INT 1
72847: NEG
72848: PUSH
72849: LD_INT 1
72851: PUSH
72852: EMPTY
72853: LIST
72854: LIST
72855: PUSH
72856: LD_INT 2
72858: NEG
72859: PUSH
72860: LD_INT 0
72862: PUSH
72863: EMPTY
72864: LIST
72865: LIST
72866: PUSH
72867: LD_INT 2
72869: NEG
72870: PUSH
72871: LD_INT 1
72873: NEG
72874: PUSH
72875: EMPTY
72876: LIST
72877: LIST
72878: PUSH
72879: LD_INT 2
72881: NEG
72882: PUSH
72883: LD_INT 2
72885: NEG
72886: PUSH
72887: EMPTY
72888: LIST
72889: LIST
72890: PUSH
72891: EMPTY
72892: LIST
72893: LIST
72894: LIST
72895: LIST
72896: LIST
72897: LIST
72898: LIST
72899: LIST
72900: LIST
72901: LIST
72902: LIST
72903: LIST
72904: LIST
72905: LIST
72906: LIST
72907: LIST
72908: LIST
72909: LIST
72910: LIST
72911: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72912: LD_ADDR_VAR 0 54
72916: PUSH
72917: LD_INT 0
72919: PUSH
72920: LD_INT 0
72922: PUSH
72923: EMPTY
72924: LIST
72925: LIST
72926: PUSH
72927: LD_INT 0
72929: PUSH
72930: LD_INT 1
72932: NEG
72933: PUSH
72934: EMPTY
72935: LIST
72936: LIST
72937: PUSH
72938: LD_INT 1
72940: PUSH
72941: LD_INT 0
72943: PUSH
72944: EMPTY
72945: LIST
72946: LIST
72947: PUSH
72948: LD_INT 1
72950: PUSH
72951: LD_INT 1
72953: PUSH
72954: EMPTY
72955: LIST
72956: LIST
72957: PUSH
72958: LD_INT 0
72960: PUSH
72961: LD_INT 1
72963: PUSH
72964: EMPTY
72965: LIST
72966: LIST
72967: PUSH
72968: LD_INT 1
72970: NEG
72971: PUSH
72972: LD_INT 0
72974: PUSH
72975: EMPTY
72976: LIST
72977: LIST
72978: PUSH
72979: LD_INT 1
72981: NEG
72982: PUSH
72983: LD_INT 1
72985: NEG
72986: PUSH
72987: EMPTY
72988: LIST
72989: LIST
72990: PUSH
72991: LD_INT 1
72993: NEG
72994: PUSH
72995: LD_INT 2
72997: NEG
72998: PUSH
72999: EMPTY
73000: LIST
73001: LIST
73002: PUSH
73003: LD_INT 0
73005: PUSH
73006: LD_INT 2
73008: NEG
73009: PUSH
73010: EMPTY
73011: LIST
73012: LIST
73013: PUSH
73014: LD_INT 1
73016: PUSH
73017: LD_INT 1
73019: NEG
73020: PUSH
73021: EMPTY
73022: LIST
73023: LIST
73024: PUSH
73025: LD_INT 2
73027: PUSH
73028: LD_INT 0
73030: PUSH
73031: EMPTY
73032: LIST
73033: LIST
73034: PUSH
73035: LD_INT 2
73037: PUSH
73038: LD_INT 1
73040: PUSH
73041: EMPTY
73042: LIST
73043: LIST
73044: PUSH
73045: LD_INT 2
73047: PUSH
73048: LD_INT 2
73050: PUSH
73051: EMPTY
73052: LIST
73053: LIST
73054: PUSH
73055: LD_INT 1
73057: PUSH
73058: LD_INT 2
73060: PUSH
73061: EMPTY
73062: LIST
73063: LIST
73064: PUSH
73065: LD_INT 0
73067: PUSH
73068: LD_INT 2
73070: PUSH
73071: EMPTY
73072: LIST
73073: LIST
73074: PUSH
73075: LD_INT 1
73077: NEG
73078: PUSH
73079: LD_INT 1
73081: PUSH
73082: EMPTY
73083: LIST
73084: LIST
73085: PUSH
73086: LD_INT 2
73088: NEG
73089: PUSH
73090: LD_INT 0
73092: PUSH
73093: EMPTY
73094: LIST
73095: LIST
73096: PUSH
73097: LD_INT 2
73099: NEG
73100: PUSH
73101: LD_INT 1
73103: NEG
73104: PUSH
73105: EMPTY
73106: LIST
73107: LIST
73108: PUSH
73109: LD_INT 2
73111: NEG
73112: PUSH
73113: LD_INT 2
73115: NEG
73116: PUSH
73117: EMPTY
73118: LIST
73119: LIST
73120: PUSH
73121: EMPTY
73122: LIST
73123: LIST
73124: LIST
73125: LIST
73126: LIST
73127: LIST
73128: LIST
73129: LIST
73130: LIST
73131: LIST
73132: LIST
73133: LIST
73134: LIST
73135: LIST
73136: LIST
73137: LIST
73138: LIST
73139: LIST
73140: LIST
73141: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73142: LD_ADDR_VAR 0 55
73146: PUSH
73147: LD_INT 0
73149: PUSH
73150: LD_INT 0
73152: PUSH
73153: EMPTY
73154: LIST
73155: LIST
73156: PUSH
73157: LD_INT 0
73159: PUSH
73160: LD_INT 1
73162: NEG
73163: PUSH
73164: EMPTY
73165: LIST
73166: LIST
73167: PUSH
73168: LD_INT 1
73170: PUSH
73171: LD_INT 0
73173: PUSH
73174: EMPTY
73175: LIST
73176: LIST
73177: PUSH
73178: LD_INT 1
73180: PUSH
73181: LD_INT 1
73183: PUSH
73184: EMPTY
73185: LIST
73186: LIST
73187: PUSH
73188: LD_INT 0
73190: PUSH
73191: LD_INT 1
73193: PUSH
73194: EMPTY
73195: LIST
73196: LIST
73197: PUSH
73198: LD_INT 1
73200: NEG
73201: PUSH
73202: LD_INT 0
73204: PUSH
73205: EMPTY
73206: LIST
73207: LIST
73208: PUSH
73209: LD_INT 1
73211: NEG
73212: PUSH
73213: LD_INT 1
73215: NEG
73216: PUSH
73217: EMPTY
73218: LIST
73219: LIST
73220: PUSH
73221: LD_INT 1
73223: NEG
73224: PUSH
73225: LD_INT 2
73227: NEG
73228: PUSH
73229: EMPTY
73230: LIST
73231: LIST
73232: PUSH
73233: LD_INT 0
73235: PUSH
73236: LD_INT 2
73238: NEG
73239: PUSH
73240: EMPTY
73241: LIST
73242: LIST
73243: PUSH
73244: LD_INT 1
73246: PUSH
73247: LD_INT 1
73249: NEG
73250: PUSH
73251: EMPTY
73252: LIST
73253: LIST
73254: PUSH
73255: LD_INT 2
73257: PUSH
73258: LD_INT 0
73260: PUSH
73261: EMPTY
73262: LIST
73263: LIST
73264: PUSH
73265: LD_INT 2
73267: PUSH
73268: LD_INT 1
73270: PUSH
73271: EMPTY
73272: LIST
73273: LIST
73274: PUSH
73275: LD_INT 2
73277: PUSH
73278: LD_INT 2
73280: PUSH
73281: EMPTY
73282: LIST
73283: LIST
73284: PUSH
73285: LD_INT 1
73287: PUSH
73288: LD_INT 2
73290: PUSH
73291: EMPTY
73292: LIST
73293: LIST
73294: PUSH
73295: LD_INT 0
73297: PUSH
73298: LD_INT 2
73300: PUSH
73301: EMPTY
73302: LIST
73303: LIST
73304: PUSH
73305: LD_INT 1
73307: NEG
73308: PUSH
73309: LD_INT 1
73311: PUSH
73312: EMPTY
73313: LIST
73314: LIST
73315: PUSH
73316: LD_INT 2
73318: NEG
73319: PUSH
73320: LD_INT 0
73322: PUSH
73323: EMPTY
73324: LIST
73325: LIST
73326: PUSH
73327: LD_INT 2
73329: NEG
73330: PUSH
73331: LD_INT 1
73333: NEG
73334: PUSH
73335: EMPTY
73336: LIST
73337: LIST
73338: PUSH
73339: LD_INT 2
73341: NEG
73342: PUSH
73343: LD_INT 2
73345: NEG
73346: PUSH
73347: EMPTY
73348: LIST
73349: LIST
73350: PUSH
73351: EMPTY
73352: LIST
73353: LIST
73354: LIST
73355: LIST
73356: LIST
73357: LIST
73358: LIST
73359: LIST
73360: LIST
73361: LIST
73362: LIST
73363: LIST
73364: LIST
73365: LIST
73366: LIST
73367: LIST
73368: LIST
73369: LIST
73370: LIST
73371: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73372: LD_ADDR_VAR 0 56
73376: PUSH
73377: LD_INT 0
73379: PUSH
73380: LD_INT 0
73382: PUSH
73383: EMPTY
73384: LIST
73385: LIST
73386: PUSH
73387: LD_INT 0
73389: PUSH
73390: LD_INT 1
73392: NEG
73393: PUSH
73394: EMPTY
73395: LIST
73396: LIST
73397: PUSH
73398: LD_INT 1
73400: PUSH
73401: LD_INT 0
73403: PUSH
73404: EMPTY
73405: LIST
73406: LIST
73407: PUSH
73408: LD_INT 1
73410: PUSH
73411: LD_INT 1
73413: PUSH
73414: EMPTY
73415: LIST
73416: LIST
73417: PUSH
73418: LD_INT 0
73420: PUSH
73421: LD_INT 1
73423: PUSH
73424: EMPTY
73425: LIST
73426: LIST
73427: PUSH
73428: LD_INT 1
73430: NEG
73431: PUSH
73432: LD_INT 0
73434: PUSH
73435: EMPTY
73436: LIST
73437: LIST
73438: PUSH
73439: LD_INT 1
73441: NEG
73442: PUSH
73443: LD_INT 1
73445: NEG
73446: PUSH
73447: EMPTY
73448: LIST
73449: LIST
73450: PUSH
73451: LD_INT 1
73453: NEG
73454: PUSH
73455: LD_INT 2
73457: NEG
73458: PUSH
73459: EMPTY
73460: LIST
73461: LIST
73462: PUSH
73463: LD_INT 0
73465: PUSH
73466: LD_INT 2
73468: NEG
73469: PUSH
73470: EMPTY
73471: LIST
73472: LIST
73473: PUSH
73474: LD_INT 1
73476: PUSH
73477: LD_INT 1
73479: NEG
73480: PUSH
73481: EMPTY
73482: LIST
73483: LIST
73484: PUSH
73485: LD_INT 2
73487: PUSH
73488: LD_INT 0
73490: PUSH
73491: EMPTY
73492: LIST
73493: LIST
73494: PUSH
73495: LD_INT 2
73497: PUSH
73498: LD_INT 1
73500: PUSH
73501: EMPTY
73502: LIST
73503: LIST
73504: PUSH
73505: LD_INT 2
73507: PUSH
73508: LD_INT 2
73510: PUSH
73511: EMPTY
73512: LIST
73513: LIST
73514: PUSH
73515: LD_INT 1
73517: PUSH
73518: LD_INT 2
73520: PUSH
73521: EMPTY
73522: LIST
73523: LIST
73524: PUSH
73525: LD_INT 0
73527: PUSH
73528: LD_INT 2
73530: PUSH
73531: EMPTY
73532: LIST
73533: LIST
73534: PUSH
73535: LD_INT 1
73537: NEG
73538: PUSH
73539: LD_INT 1
73541: PUSH
73542: EMPTY
73543: LIST
73544: LIST
73545: PUSH
73546: LD_INT 2
73548: NEG
73549: PUSH
73550: LD_INT 0
73552: PUSH
73553: EMPTY
73554: LIST
73555: LIST
73556: PUSH
73557: LD_INT 2
73559: NEG
73560: PUSH
73561: LD_INT 1
73563: NEG
73564: PUSH
73565: EMPTY
73566: LIST
73567: LIST
73568: PUSH
73569: LD_INT 2
73571: NEG
73572: PUSH
73573: LD_INT 2
73575: NEG
73576: PUSH
73577: EMPTY
73578: LIST
73579: LIST
73580: PUSH
73581: EMPTY
73582: LIST
73583: LIST
73584: LIST
73585: LIST
73586: LIST
73587: LIST
73588: LIST
73589: LIST
73590: LIST
73591: LIST
73592: LIST
73593: LIST
73594: LIST
73595: LIST
73596: LIST
73597: LIST
73598: LIST
73599: LIST
73600: LIST
73601: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73602: LD_ADDR_VAR 0 57
73606: PUSH
73607: LD_INT 0
73609: PUSH
73610: LD_INT 0
73612: PUSH
73613: EMPTY
73614: LIST
73615: LIST
73616: PUSH
73617: LD_INT 0
73619: PUSH
73620: LD_INT 1
73622: NEG
73623: PUSH
73624: EMPTY
73625: LIST
73626: LIST
73627: PUSH
73628: LD_INT 1
73630: PUSH
73631: LD_INT 0
73633: PUSH
73634: EMPTY
73635: LIST
73636: LIST
73637: PUSH
73638: LD_INT 1
73640: PUSH
73641: LD_INT 1
73643: PUSH
73644: EMPTY
73645: LIST
73646: LIST
73647: PUSH
73648: LD_INT 0
73650: PUSH
73651: LD_INT 1
73653: PUSH
73654: EMPTY
73655: LIST
73656: LIST
73657: PUSH
73658: LD_INT 1
73660: NEG
73661: PUSH
73662: LD_INT 0
73664: PUSH
73665: EMPTY
73666: LIST
73667: LIST
73668: PUSH
73669: LD_INT 1
73671: NEG
73672: PUSH
73673: LD_INT 1
73675: NEG
73676: PUSH
73677: EMPTY
73678: LIST
73679: LIST
73680: PUSH
73681: LD_INT 1
73683: NEG
73684: PUSH
73685: LD_INT 2
73687: NEG
73688: PUSH
73689: EMPTY
73690: LIST
73691: LIST
73692: PUSH
73693: LD_INT 0
73695: PUSH
73696: LD_INT 2
73698: NEG
73699: PUSH
73700: EMPTY
73701: LIST
73702: LIST
73703: PUSH
73704: LD_INT 1
73706: PUSH
73707: LD_INT 1
73709: NEG
73710: PUSH
73711: EMPTY
73712: LIST
73713: LIST
73714: PUSH
73715: LD_INT 2
73717: PUSH
73718: LD_INT 0
73720: PUSH
73721: EMPTY
73722: LIST
73723: LIST
73724: PUSH
73725: LD_INT 2
73727: PUSH
73728: LD_INT 1
73730: PUSH
73731: EMPTY
73732: LIST
73733: LIST
73734: PUSH
73735: LD_INT 2
73737: PUSH
73738: LD_INT 2
73740: PUSH
73741: EMPTY
73742: LIST
73743: LIST
73744: PUSH
73745: LD_INT 1
73747: PUSH
73748: LD_INT 2
73750: PUSH
73751: EMPTY
73752: LIST
73753: LIST
73754: PUSH
73755: LD_INT 0
73757: PUSH
73758: LD_INT 2
73760: PUSH
73761: EMPTY
73762: LIST
73763: LIST
73764: PUSH
73765: LD_INT 1
73767: NEG
73768: PUSH
73769: LD_INT 1
73771: PUSH
73772: EMPTY
73773: LIST
73774: LIST
73775: PUSH
73776: LD_INT 2
73778: NEG
73779: PUSH
73780: LD_INT 0
73782: PUSH
73783: EMPTY
73784: LIST
73785: LIST
73786: PUSH
73787: LD_INT 2
73789: NEG
73790: PUSH
73791: LD_INT 1
73793: NEG
73794: PUSH
73795: EMPTY
73796: LIST
73797: LIST
73798: PUSH
73799: LD_INT 2
73801: NEG
73802: PUSH
73803: LD_INT 2
73805: NEG
73806: PUSH
73807: EMPTY
73808: LIST
73809: LIST
73810: PUSH
73811: EMPTY
73812: LIST
73813: LIST
73814: LIST
73815: LIST
73816: LIST
73817: LIST
73818: LIST
73819: LIST
73820: LIST
73821: LIST
73822: LIST
73823: LIST
73824: LIST
73825: LIST
73826: LIST
73827: LIST
73828: LIST
73829: LIST
73830: LIST
73831: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73832: LD_ADDR_VAR 0 58
73836: PUSH
73837: LD_INT 0
73839: PUSH
73840: LD_INT 0
73842: PUSH
73843: EMPTY
73844: LIST
73845: LIST
73846: PUSH
73847: LD_INT 0
73849: PUSH
73850: LD_INT 1
73852: NEG
73853: PUSH
73854: EMPTY
73855: LIST
73856: LIST
73857: PUSH
73858: LD_INT 1
73860: PUSH
73861: LD_INT 0
73863: PUSH
73864: EMPTY
73865: LIST
73866: LIST
73867: PUSH
73868: LD_INT 1
73870: PUSH
73871: LD_INT 1
73873: PUSH
73874: EMPTY
73875: LIST
73876: LIST
73877: PUSH
73878: LD_INT 0
73880: PUSH
73881: LD_INT 1
73883: PUSH
73884: EMPTY
73885: LIST
73886: LIST
73887: PUSH
73888: LD_INT 1
73890: NEG
73891: PUSH
73892: LD_INT 0
73894: PUSH
73895: EMPTY
73896: LIST
73897: LIST
73898: PUSH
73899: LD_INT 1
73901: NEG
73902: PUSH
73903: LD_INT 1
73905: NEG
73906: PUSH
73907: EMPTY
73908: LIST
73909: LIST
73910: PUSH
73911: LD_INT 1
73913: NEG
73914: PUSH
73915: LD_INT 2
73917: NEG
73918: PUSH
73919: EMPTY
73920: LIST
73921: LIST
73922: PUSH
73923: LD_INT 0
73925: PUSH
73926: LD_INT 2
73928: NEG
73929: PUSH
73930: EMPTY
73931: LIST
73932: LIST
73933: PUSH
73934: LD_INT 1
73936: PUSH
73937: LD_INT 1
73939: NEG
73940: PUSH
73941: EMPTY
73942: LIST
73943: LIST
73944: PUSH
73945: LD_INT 2
73947: PUSH
73948: LD_INT 0
73950: PUSH
73951: EMPTY
73952: LIST
73953: LIST
73954: PUSH
73955: LD_INT 2
73957: PUSH
73958: LD_INT 1
73960: PUSH
73961: EMPTY
73962: LIST
73963: LIST
73964: PUSH
73965: LD_INT 2
73967: PUSH
73968: LD_INT 2
73970: PUSH
73971: EMPTY
73972: LIST
73973: LIST
73974: PUSH
73975: LD_INT 1
73977: PUSH
73978: LD_INT 2
73980: PUSH
73981: EMPTY
73982: LIST
73983: LIST
73984: PUSH
73985: LD_INT 0
73987: PUSH
73988: LD_INT 2
73990: PUSH
73991: EMPTY
73992: LIST
73993: LIST
73994: PUSH
73995: LD_INT 1
73997: NEG
73998: PUSH
73999: LD_INT 1
74001: PUSH
74002: EMPTY
74003: LIST
74004: LIST
74005: PUSH
74006: LD_INT 2
74008: NEG
74009: PUSH
74010: LD_INT 0
74012: PUSH
74013: EMPTY
74014: LIST
74015: LIST
74016: PUSH
74017: LD_INT 2
74019: NEG
74020: PUSH
74021: LD_INT 1
74023: NEG
74024: PUSH
74025: EMPTY
74026: LIST
74027: LIST
74028: PUSH
74029: LD_INT 2
74031: NEG
74032: PUSH
74033: LD_INT 2
74035: NEG
74036: PUSH
74037: EMPTY
74038: LIST
74039: LIST
74040: PUSH
74041: EMPTY
74042: LIST
74043: LIST
74044: LIST
74045: LIST
74046: LIST
74047: LIST
74048: LIST
74049: LIST
74050: LIST
74051: LIST
74052: LIST
74053: LIST
74054: LIST
74055: LIST
74056: LIST
74057: LIST
74058: LIST
74059: LIST
74060: LIST
74061: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74062: LD_ADDR_VAR 0 59
74066: PUSH
74067: LD_INT 0
74069: PUSH
74070: LD_INT 0
74072: PUSH
74073: EMPTY
74074: LIST
74075: LIST
74076: PUSH
74077: LD_INT 0
74079: PUSH
74080: LD_INT 1
74082: NEG
74083: PUSH
74084: EMPTY
74085: LIST
74086: LIST
74087: PUSH
74088: LD_INT 1
74090: PUSH
74091: LD_INT 0
74093: PUSH
74094: EMPTY
74095: LIST
74096: LIST
74097: PUSH
74098: LD_INT 1
74100: PUSH
74101: LD_INT 1
74103: PUSH
74104: EMPTY
74105: LIST
74106: LIST
74107: PUSH
74108: LD_INT 0
74110: PUSH
74111: LD_INT 1
74113: PUSH
74114: EMPTY
74115: LIST
74116: LIST
74117: PUSH
74118: LD_INT 1
74120: NEG
74121: PUSH
74122: LD_INT 0
74124: PUSH
74125: EMPTY
74126: LIST
74127: LIST
74128: PUSH
74129: LD_INT 1
74131: NEG
74132: PUSH
74133: LD_INT 1
74135: NEG
74136: PUSH
74137: EMPTY
74138: LIST
74139: LIST
74140: PUSH
74141: EMPTY
74142: LIST
74143: LIST
74144: LIST
74145: LIST
74146: LIST
74147: LIST
74148: LIST
74149: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74150: LD_ADDR_VAR 0 60
74154: PUSH
74155: LD_INT 0
74157: PUSH
74158: LD_INT 0
74160: PUSH
74161: EMPTY
74162: LIST
74163: LIST
74164: PUSH
74165: LD_INT 0
74167: PUSH
74168: LD_INT 1
74170: NEG
74171: PUSH
74172: EMPTY
74173: LIST
74174: LIST
74175: PUSH
74176: LD_INT 1
74178: PUSH
74179: LD_INT 0
74181: PUSH
74182: EMPTY
74183: LIST
74184: LIST
74185: PUSH
74186: LD_INT 1
74188: PUSH
74189: LD_INT 1
74191: PUSH
74192: EMPTY
74193: LIST
74194: LIST
74195: PUSH
74196: LD_INT 0
74198: PUSH
74199: LD_INT 1
74201: PUSH
74202: EMPTY
74203: LIST
74204: LIST
74205: PUSH
74206: LD_INT 1
74208: NEG
74209: PUSH
74210: LD_INT 0
74212: PUSH
74213: EMPTY
74214: LIST
74215: LIST
74216: PUSH
74217: LD_INT 1
74219: NEG
74220: PUSH
74221: LD_INT 1
74223: NEG
74224: PUSH
74225: EMPTY
74226: LIST
74227: LIST
74228: PUSH
74229: EMPTY
74230: LIST
74231: LIST
74232: LIST
74233: LIST
74234: LIST
74235: LIST
74236: LIST
74237: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74238: LD_ADDR_VAR 0 61
74242: PUSH
74243: LD_INT 0
74245: PUSH
74246: LD_INT 0
74248: PUSH
74249: EMPTY
74250: LIST
74251: LIST
74252: PUSH
74253: LD_INT 0
74255: PUSH
74256: LD_INT 1
74258: NEG
74259: PUSH
74260: EMPTY
74261: LIST
74262: LIST
74263: PUSH
74264: LD_INT 1
74266: PUSH
74267: LD_INT 0
74269: PUSH
74270: EMPTY
74271: LIST
74272: LIST
74273: PUSH
74274: LD_INT 1
74276: PUSH
74277: LD_INT 1
74279: PUSH
74280: EMPTY
74281: LIST
74282: LIST
74283: PUSH
74284: LD_INT 0
74286: PUSH
74287: LD_INT 1
74289: PUSH
74290: EMPTY
74291: LIST
74292: LIST
74293: PUSH
74294: LD_INT 1
74296: NEG
74297: PUSH
74298: LD_INT 0
74300: PUSH
74301: EMPTY
74302: LIST
74303: LIST
74304: PUSH
74305: LD_INT 1
74307: NEG
74308: PUSH
74309: LD_INT 1
74311: NEG
74312: PUSH
74313: EMPTY
74314: LIST
74315: LIST
74316: PUSH
74317: EMPTY
74318: LIST
74319: LIST
74320: LIST
74321: LIST
74322: LIST
74323: LIST
74324: LIST
74325: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74326: LD_ADDR_VAR 0 62
74330: PUSH
74331: LD_INT 0
74333: PUSH
74334: LD_INT 0
74336: PUSH
74337: EMPTY
74338: LIST
74339: LIST
74340: PUSH
74341: LD_INT 0
74343: PUSH
74344: LD_INT 1
74346: NEG
74347: PUSH
74348: EMPTY
74349: LIST
74350: LIST
74351: PUSH
74352: LD_INT 1
74354: PUSH
74355: LD_INT 0
74357: PUSH
74358: EMPTY
74359: LIST
74360: LIST
74361: PUSH
74362: LD_INT 1
74364: PUSH
74365: LD_INT 1
74367: PUSH
74368: EMPTY
74369: LIST
74370: LIST
74371: PUSH
74372: LD_INT 0
74374: PUSH
74375: LD_INT 1
74377: PUSH
74378: EMPTY
74379: LIST
74380: LIST
74381: PUSH
74382: LD_INT 1
74384: NEG
74385: PUSH
74386: LD_INT 0
74388: PUSH
74389: EMPTY
74390: LIST
74391: LIST
74392: PUSH
74393: LD_INT 1
74395: NEG
74396: PUSH
74397: LD_INT 1
74399: NEG
74400: PUSH
74401: EMPTY
74402: LIST
74403: LIST
74404: PUSH
74405: EMPTY
74406: LIST
74407: LIST
74408: LIST
74409: LIST
74410: LIST
74411: LIST
74412: LIST
74413: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74414: LD_ADDR_VAR 0 63
74418: PUSH
74419: LD_INT 0
74421: PUSH
74422: LD_INT 0
74424: PUSH
74425: EMPTY
74426: LIST
74427: LIST
74428: PUSH
74429: LD_INT 0
74431: PUSH
74432: LD_INT 1
74434: NEG
74435: PUSH
74436: EMPTY
74437: LIST
74438: LIST
74439: PUSH
74440: LD_INT 1
74442: PUSH
74443: LD_INT 0
74445: PUSH
74446: EMPTY
74447: LIST
74448: LIST
74449: PUSH
74450: LD_INT 1
74452: PUSH
74453: LD_INT 1
74455: PUSH
74456: EMPTY
74457: LIST
74458: LIST
74459: PUSH
74460: LD_INT 0
74462: PUSH
74463: LD_INT 1
74465: PUSH
74466: EMPTY
74467: LIST
74468: LIST
74469: PUSH
74470: LD_INT 1
74472: NEG
74473: PUSH
74474: LD_INT 0
74476: PUSH
74477: EMPTY
74478: LIST
74479: LIST
74480: PUSH
74481: LD_INT 1
74483: NEG
74484: PUSH
74485: LD_INT 1
74487: NEG
74488: PUSH
74489: EMPTY
74490: LIST
74491: LIST
74492: PUSH
74493: EMPTY
74494: LIST
74495: LIST
74496: LIST
74497: LIST
74498: LIST
74499: LIST
74500: LIST
74501: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74502: LD_ADDR_VAR 0 64
74506: PUSH
74507: LD_INT 0
74509: PUSH
74510: LD_INT 0
74512: PUSH
74513: EMPTY
74514: LIST
74515: LIST
74516: PUSH
74517: LD_INT 0
74519: PUSH
74520: LD_INT 1
74522: NEG
74523: PUSH
74524: EMPTY
74525: LIST
74526: LIST
74527: PUSH
74528: LD_INT 1
74530: PUSH
74531: LD_INT 0
74533: PUSH
74534: EMPTY
74535: LIST
74536: LIST
74537: PUSH
74538: LD_INT 1
74540: PUSH
74541: LD_INT 1
74543: PUSH
74544: EMPTY
74545: LIST
74546: LIST
74547: PUSH
74548: LD_INT 0
74550: PUSH
74551: LD_INT 1
74553: PUSH
74554: EMPTY
74555: LIST
74556: LIST
74557: PUSH
74558: LD_INT 1
74560: NEG
74561: PUSH
74562: LD_INT 0
74564: PUSH
74565: EMPTY
74566: LIST
74567: LIST
74568: PUSH
74569: LD_INT 1
74571: NEG
74572: PUSH
74573: LD_INT 1
74575: NEG
74576: PUSH
74577: EMPTY
74578: LIST
74579: LIST
74580: PUSH
74581: EMPTY
74582: LIST
74583: LIST
74584: LIST
74585: LIST
74586: LIST
74587: LIST
74588: LIST
74589: ST_TO_ADDR
// end ; 1 :
74590: GO 80487
74592: LD_INT 1
74594: DOUBLE
74595: EQUAL
74596: IFTRUE 74600
74598: GO 77223
74600: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
74601: LD_ADDR_VAR 0 11
74605: PUSH
74606: LD_INT 1
74608: NEG
74609: PUSH
74610: LD_INT 3
74612: NEG
74613: PUSH
74614: EMPTY
74615: LIST
74616: LIST
74617: PUSH
74618: LD_INT 0
74620: PUSH
74621: LD_INT 3
74623: NEG
74624: PUSH
74625: EMPTY
74626: LIST
74627: LIST
74628: PUSH
74629: LD_INT 1
74631: PUSH
74632: LD_INT 2
74634: NEG
74635: PUSH
74636: EMPTY
74637: LIST
74638: LIST
74639: PUSH
74640: EMPTY
74641: LIST
74642: LIST
74643: LIST
74644: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
74645: LD_ADDR_VAR 0 12
74649: PUSH
74650: LD_INT 2
74652: PUSH
74653: LD_INT 1
74655: NEG
74656: PUSH
74657: EMPTY
74658: LIST
74659: LIST
74660: PUSH
74661: LD_INT 3
74663: PUSH
74664: LD_INT 0
74666: PUSH
74667: EMPTY
74668: LIST
74669: LIST
74670: PUSH
74671: LD_INT 3
74673: PUSH
74674: LD_INT 1
74676: PUSH
74677: EMPTY
74678: LIST
74679: LIST
74680: PUSH
74681: EMPTY
74682: LIST
74683: LIST
74684: LIST
74685: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
74686: LD_ADDR_VAR 0 13
74690: PUSH
74691: LD_INT 3
74693: PUSH
74694: LD_INT 2
74696: PUSH
74697: EMPTY
74698: LIST
74699: LIST
74700: PUSH
74701: LD_INT 3
74703: PUSH
74704: LD_INT 3
74706: PUSH
74707: EMPTY
74708: LIST
74709: LIST
74710: PUSH
74711: LD_INT 2
74713: PUSH
74714: LD_INT 3
74716: PUSH
74717: EMPTY
74718: LIST
74719: LIST
74720: PUSH
74721: EMPTY
74722: LIST
74723: LIST
74724: LIST
74725: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
74726: LD_ADDR_VAR 0 14
74730: PUSH
74731: LD_INT 1
74733: PUSH
74734: LD_INT 3
74736: PUSH
74737: EMPTY
74738: LIST
74739: LIST
74740: PUSH
74741: LD_INT 0
74743: PUSH
74744: LD_INT 3
74746: PUSH
74747: EMPTY
74748: LIST
74749: LIST
74750: PUSH
74751: LD_INT 1
74753: NEG
74754: PUSH
74755: LD_INT 2
74757: PUSH
74758: EMPTY
74759: LIST
74760: LIST
74761: PUSH
74762: EMPTY
74763: LIST
74764: LIST
74765: LIST
74766: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74767: LD_ADDR_VAR 0 15
74771: PUSH
74772: LD_INT 2
74774: NEG
74775: PUSH
74776: LD_INT 1
74778: PUSH
74779: EMPTY
74780: LIST
74781: LIST
74782: PUSH
74783: LD_INT 3
74785: NEG
74786: PUSH
74787: LD_INT 0
74789: PUSH
74790: EMPTY
74791: LIST
74792: LIST
74793: PUSH
74794: LD_INT 3
74796: NEG
74797: PUSH
74798: LD_INT 1
74800: NEG
74801: PUSH
74802: EMPTY
74803: LIST
74804: LIST
74805: PUSH
74806: EMPTY
74807: LIST
74808: LIST
74809: LIST
74810: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74811: LD_ADDR_VAR 0 16
74815: PUSH
74816: LD_INT 2
74818: NEG
74819: PUSH
74820: LD_INT 3
74822: NEG
74823: PUSH
74824: EMPTY
74825: LIST
74826: LIST
74827: PUSH
74828: LD_INT 3
74830: NEG
74831: PUSH
74832: LD_INT 2
74834: NEG
74835: PUSH
74836: EMPTY
74837: LIST
74838: LIST
74839: PUSH
74840: LD_INT 3
74842: NEG
74843: PUSH
74844: LD_INT 3
74846: NEG
74847: PUSH
74848: EMPTY
74849: LIST
74850: LIST
74851: PUSH
74852: EMPTY
74853: LIST
74854: LIST
74855: LIST
74856: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
74857: LD_ADDR_VAR 0 17
74861: PUSH
74862: LD_INT 1
74864: NEG
74865: PUSH
74866: LD_INT 3
74868: NEG
74869: PUSH
74870: EMPTY
74871: LIST
74872: LIST
74873: PUSH
74874: LD_INT 0
74876: PUSH
74877: LD_INT 3
74879: NEG
74880: PUSH
74881: EMPTY
74882: LIST
74883: LIST
74884: PUSH
74885: LD_INT 1
74887: PUSH
74888: LD_INT 2
74890: NEG
74891: PUSH
74892: EMPTY
74893: LIST
74894: LIST
74895: PUSH
74896: EMPTY
74897: LIST
74898: LIST
74899: LIST
74900: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
74901: LD_ADDR_VAR 0 18
74905: PUSH
74906: LD_INT 2
74908: PUSH
74909: LD_INT 1
74911: NEG
74912: PUSH
74913: EMPTY
74914: LIST
74915: LIST
74916: PUSH
74917: LD_INT 3
74919: PUSH
74920: LD_INT 0
74922: PUSH
74923: EMPTY
74924: LIST
74925: LIST
74926: PUSH
74927: LD_INT 3
74929: PUSH
74930: LD_INT 1
74932: PUSH
74933: EMPTY
74934: LIST
74935: LIST
74936: PUSH
74937: EMPTY
74938: LIST
74939: LIST
74940: LIST
74941: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
74942: LD_ADDR_VAR 0 19
74946: PUSH
74947: LD_INT 3
74949: PUSH
74950: LD_INT 2
74952: PUSH
74953: EMPTY
74954: LIST
74955: LIST
74956: PUSH
74957: LD_INT 3
74959: PUSH
74960: LD_INT 3
74962: PUSH
74963: EMPTY
74964: LIST
74965: LIST
74966: PUSH
74967: LD_INT 2
74969: PUSH
74970: LD_INT 3
74972: PUSH
74973: EMPTY
74974: LIST
74975: LIST
74976: PUSH
74977: EMPTY
74978: LIST
74979: LIST
74980: LIST
74981: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
74982: LD_ADDR_VAR 0 20
74986: PUSH
74987: LD_INT 1
74989: PUSH
74990: LD_INT 3
74992: PUSH
74993: EMPTY
74994: LIST
74995: LIST
74996: PUSH
74997: LD_INT 0
74999: PUSH
75000: LD_INT 3
75002: PUSH
75003: EMPTY
75004: LIST
75005: LIST
75006: PUSH
75007: LD_INT 1
75009: NEG
75010: PUSH
75011: LD_INT 2
75013: PUSH
75014: EMPTY
75015: LIST
75016: LIST
75017: PUSH
75018: EMPTY
75019: LIST
75020: LIST
75021: LIST
75022: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
75023: LD_ADDR_VAR 0 21
75027: PUSH
75028: LD_INT 2
75030: NEG
75031: PUSH
75032: LD_INT 1
75034: PUSH
75035: EMPTY
75036: LIST
75037: LIST
75038: PUSH
75039: LD_INT 3
75041: NEG
75042: PUSH
75043: LD_INT 0
75045: PUSH
75046: EMPTY
75047: LIST
75048: LIST
75049: PUSH
75050: LD_INT 3
75052: NEG
75053: PUSH
75054: LD_INT 1
75056: NEG
75057: PUSH
75058: EMPTY
75059: LIST
75060: LIST
75061: PUSH
75062: EMPTY
75063: LIST
75064: LIST
75065: LIST
75066: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75067: LD_ADDR_VAR 0 22
75071: PUSH
75072: LD_INT 2
75074: NEG
75075: PUSH
75076: LD_INT 3
75078: NEG
75079: PUSH
75080: EMPTY
75081: LIST
75082: LIST
75083: PUSH
75084: LD_INT 3
75086: NEG
75087: PUSH
75088: LD_INT 2
75090: NEG
75091: PUSH
75092: EMPTY
75093: LIST
75094: LIST
75095: PUSH
75096: LD_INT 3
75098: NEG
75099: PUSH
75100: LD_INT 3
75102: NEG
75103: PUSH
75104: EMPTY
75105: LIST
75106: LIST
75107: PUSH
75108: EMPTY
75109: LIST
75110: LIST
75111: LIST
75112: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
75113: LD_ADDR_VAR 0 23
75117: PUSH
75118: LD_INT 0
75120: PUSH
75121: LD_INT 3
75123: NEG
75124: PUSH
75125: EMPTY
75126: LIST
75127: LIST
75128: PUSH
75129: LD_INT 1
75131: NEG
75132: PUSH
75133: LD_INT 4
75135: NEG
75136: PUSH
75137: EMPTY
75138: LIST
75139: LIST
75140: PUSH
75141: LD_INT 1
75143: PUSH
75144: LD_INT 3
75146: NEG
75147: PUSH
75148: EMPTY
75149: LIST
75150: LIST
75151: PUSH
75152: EMPTY
75153: LIST
75154: LIST
75155: LIST
75156: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
75157: LD_ADDR_VAR 0 24
75161: PUSH
75162: LD_INT 3
75164: PUSH
75165: LD_INT 0
75167: PUSH
75168: EMPTY
75169: LIST
75170: LIST
75171: PUSH
75172: LD_INT 3
75174: PUSH
75175: LD_INT 1
75177: NEG
75178: PUSH
75179: EMPTY
75180: LIST
75181: LIST
75182: PUSH
75183: LD_INT 4
75185: PUSH
75186: LD_INT 1
75188: PUSH
75189: EMPTY
75190: LIST
75191: LIST
75192: PUSH
75193: EMPTY
75194: LIST
75195: LIST
75196: LIST
75197: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
75198: LD_ADDR_VAR 0 25
75202: PUSH
75203: LD_INT 3
75205: PUSH
75206: LD_INT 3
75208: PUSH
75209: EMPTY
75210: LIST
75211: LIST
75212: PUSH
75213: LD_INT 4
75215: PUSH
75216: LD_INT 3
75218: PUSH
75219: EMPTY
75220: LIST
75221: LIST
75222: PUSH
75223: LD_INT 3
75225: PUSH
75226: LD_INT 4
75228: PUSH
75229: EMPTY
75230: LIST
75231: LIST
75232: PUSH
75233: EMPTY
75234: LIST
75235: LIST
75236: LIST
75237: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
75238: LD_ADDR_VAR 0 26
75242: PUSH
75243: LD_INT 0
75245: PUSH
75246: LD_INT 3
75248: PUSH
75249: EMPTY
75250: LIST
75251: LIST
75252: PUSH
75253: LD_INT 1
75255: PUSH
75256: LD_INT 4
75258: PUSH
75259: EMPTY
75260: LIST
75261: LIST
75262: PUSH
75263: LD_INT 1
75265: NEG
75266: PUSH
75267: LD_INT 3
75269: PUSH
75270: EMPTY
75271: LIST
75272: LIST
75273: PUSH
75274: EMPTY
75275: LIST
75276: LIST
75277: LIST
75278: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
75279: LD_ADDR_VAR 0 27
75283: PUSH
75284: LD_INT 3
75286: NEG
75287: PUSH
75288: LD_INT 0
75290: PUSH
75291: EMPTY
75292: LIST
75293: LIST
75294: PUSH
75295: LD_INT 3
75297: NEG
75298: PUSH
75299: LD_INT 1
75301: PUSH
75302: EMPTY
75303: LIST
75304: LIST
75305: PUSH
75306: LD_INT 4
75308: NEG
75309: PUSH
75310: LD_INT 1
75312: NEG
75313: PUSH
75314: EMPTY
75315: LIST
75316: LIST
75317: PUSH
75318: EMPTY
75319: LIST
75320: LIST
75321: LIST
75322: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
75323: LD_ADDR_VAR 0 28
75327: PUSH
75328: LD_INT 3
75330: NEG
75331: PUSH
75332: LD_INT 3
75334: NEG
75335: PUSH
75336: EMPTY
75337: LIST
75338: LIST
75339: PUSH
75340: LD_INT 3
75342: NEG
75343: PUSH
75344: LD_INT 4
75346: NEG
75347: PUSH
75348: EMPTY
75349: LIST
75350: LIST
75351: PUSH
75352: LD_INT 4
75354: NEG
75355: PUSH
75356: LD_INT 3
75358: NEG
75359: PUSH
75360: EMPTY
75361: LIST
75362: LIST
75363: PUSH
75364: EMPTY
75365: LIST
75366: LIST
75367: LIST
75368: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
75369: LD_ADDR_VAR 0 29
75373: PUSH
75374: LD_INT 1
75376: NEG
75377: PUSH
75378: LD_INT 3
75380: NEG
75381: PUSH
75382: EMPTY
75383: LIST
75384: LIST
75385: PUSH
75386: LD_INT 0
75388: PUSH
75389: LD_INT 3
75391: NEG
75392: PUSH
75393: EMPTY
75394: LIST
75395: LIST
75396: PUSH
75397: LD_INT 1
75399: PUSH
75400: LD_INT 2
75402: NEG
75403: PUSH
75404: EMPTY
75405: LIST
75406: LIST
75407: PUSH
75408: LD_INT 1
75410: NEG
75411: PUSH
75412: LD_INT 4
75414: NEG
75415: PUSH
75416: EMPTY
75417: LIST
75418: LIST
75419: PUSH
75420: LD_INT 0
75422: PUSH
75423: LD_INT 4
75425: NEG
75426: PUSH
75427: EMPTY
75428: LIST
75429: LIST
75430: PUSH
75431: LD_INT 1
75433: PUSH
75434: LD_INT 3
75436: NEG
75437: PUSH
75438: EMPTY
75439: LIST
75440: LIST
75441: PUSH
75442: LD_INT 1
75444: NEG
75445: PUSH
75446: LD_INT 5
75448: NEG
75449: PUSH
75450: EMPTY
75451: LIST
75452: LIST
75453: PUSH
75454: LD_INT 0
75456: PUSH
75457: LD_INT 5
75459: NEG
75460: PUSH
75461: EMPTY
75462: LIST
75463: LIST
75464: PUSH
75465: LD_INT 1
75467: PUSH
75468: LD_INT 4
75470: NEG
75471: PUSH
75472: EMPTY
75473: LIST
75474: LIST
75475: PUSH
75476: LD_INT 1
75478: NEG
75479: PUSH
75480: LD_INT 6
75482: NEG
75483: PUSH
75484: EMPTY
75485: LIST
75486: LIST
75487: PUSH
75488: LD_INT 0
75490: PUSH
75491: LD_INT 6
75493: NEG
75494: PUSH
75495: EMPTY
75496: LIST
75497: LIST
75498: PUSH
75499: LD_INT 1
75501: PUSH
75502: LD_INT 5
75504: NEG
75505: PUSH
75506: EMPTY
75507: LIST
75508: LIST
75509: PUSH
75510: EMPTY
75511: LIST
75512: LIST
75513: LIST
75514: LIST
75515: LIST
75516: LIST
75517: LIST
75518: LIST
75519: LIST
75520: LIST
75521: LIST
75522: LIST
75523: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
75524: LD_ADDR_VAR 0 30
75528: PUSH
75529: LD_INT 2
75531: PUSH
75532: LD_INT 1
75534: NEG
75535: PUSH
75536: EMPTY
75537: LIST
75538: LIST
75539: PUSH
75540: LD_INT 3
75542: PUSH
75543: LD_INT 0
75545: PUSH
75546: EMPTY
75547: LIST
75548: LIST
75549: PUSH
75550: LD_INT 3
75552: PUSH
75553: LD_INT 1
75555: PUSH
75556: EMPTY
75557: LIST
75558: LIST
75559: PUSH
75560: LD_INT 3
75562: PUSH
75563: LD_INT 1
75565: NEG
75566: PUSH
75567: EMPTY
75568: LIST
75569: LIST
75570: PUSH
75571: LD_INT 4
75573: PUSH
75574: LD_INT 0
75576: PUSH
75577: EMPTY
75578: LIST
75579: LIST
75580: PUSH
75581: LD_INT 4
75583: PUSH
75584: LD_INT 1
75586: PUSH
75587: EMPTY
75588: LIST
75589: LIST
75590: PUSH
75591: LD_INT 4
75593: PUSH
75594: LD_INT 1
75596: NEG
75597: PUSH
75598: EMPTY
75599: LIST
75600: LIST
75601: PUSH
75602: LD_INT 5
75604: PUSH
75605: LD_INT 0
75607: PUSH
75608: EMPTY
75609: LIST
75610: LIST
75611: PUSH
75612: LD_INT 5
75614: PUSH
75615: LD_INT 1
75617: PUSH
75618: EMPTY
75619: LIST
75620: LIST
75621: PUSH
75622: LD_INT 5
75624: PUSH
75625: LD_INT 1
75627: NEG
75628: PUSH
75629: EMPTY
75630: LIST
75631: LIST
75632: PUSH
75633: LD_INT 6
75635: PUSH
75636: LD_INT 0
75638: PUSH
75639: EMPTY
75640: LIST
75641: LIST
75642: PUSH
75643: LD_INT 6
75645: PUSH
75646: LD_INT 1
75648: PUSH
75649: EMPTY
75650: LIST
75651: LIST
75652: PUSH
75653: EMPTY
75654: LIST
75655: LIST
75656: LIST
75657: LIST
75658: LIST
75659: LIST
75660: LIST
75661: LIST
75662: LIST
75663: LIST
75664: LIST
75665: LIST
75666: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
75667: LD_ADDR_VAR 0 31
75671: PUSH
75672: LD_INT 3
75674: PUSH
75675: LD_INT 2
75677: PUSH
75678: EMPTY
75679: LIST
75680: LIST
75681: PUSH
75682: LD_INT 3
75684: PUSH
75685: LD_INT 3
75687: PUSH
75688: EMPTY
75689: LIST
75690: LIST
75691: PUSH
75692: LD_INT 2
75694: PUSH
75695: LD_INT 3
75697: PUSH
75698: EMPTY
75699: LIST
75700: LIST
75701: PUSH
75702: LD_INT 4
75704: PUSH
75705: LD_INT 3
75707: PUSH
75708: EMPTY
75709: LIST
75710: LIST
75711: PUSH
75712: LD_INT 4
75714: PUSH
75715: LD_INT 4
75717: PUSH
75718: EMPTY
75719: LIST
75720: LIST
75721: PUSH
75722: LD_INT 3
75724: PUSH
75725: LD_INT 4
75727: PUSH
75728: EMPTY
75729: LIST
75730: LIST
75731: PUSH
75732: LD_INT 5
75734: PUSH
75735: LD_INT 4
75737: PUSH
75738: EMPTY
75739: LIST
75740: LIST
75741: PUSH
75742: LD_INT 5
75744: PUSH
75745: LD_INT 5
75747: PUSH
75748: EMPTY
75749: LIST
75750: LIST
75751: PUSH
75752: LD_INT 4
75754: PUSH
75755: LD_INT 5
75757: PUSH
75758: EMPTY
75759: LIST
75760: LIST
75761: PUSH
75762: LD_INT 6
75764: PUSH
75765: LD_INT 5
75767: PUSH
75768: EMPTY
75769: LIST
75770: LIST
75771: PUSH
75772: LD_INT 6
75774: PUSH
75775: LD_INT 6
75777: PUSH
75778: EMPTY
75779: LIST
75780: LIST
75781: PUSH
75782: LD_INT 5
75784: PUSH
75785: LD_INT 6
75787: PUSH
75788: EMPTY
75789: LIST
75790: LIST
75791: PUSH
75792: EMPTY
75793: LIST
75794: LIST
75795: LIST
75796: LIST
75797: LIST
75798: LIST
75799: LIST
75800: LIST
75801: LIST
75802: LIST
75803: LIST
75804: LIST
75805: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
75806: LD_ADDR_VAR 0 32
75810: PUSH
75811: LD_INT 1
75813: PUSH
75814: LD_INT 3
75816: PUSH
75817: EMPTY
75818: LIST
75819: LIST
75820: PUSH
75821: LD_INT 0
75823: PUSH
75824: LD_INT 3
75826: PUSH
75827: EMPTY
75828: LIST
75829: LIST
75830: PUSH
75831: LD_INT 1
75833: NEG
75834: PUSH
75835: LD_INT 2
75837: PUSH
75838: EMPTY
75839: LIST
75840: LIST
75841: PUSH
75842: LD_INT 1
75844: PUSH
75845: LD_INT 4
75847: PUSH
75848: EMPTY
75849: LIST
75850: LIST
75851: PUSH
75852: LD_INT 0
75854: PUSH
75855: LD_INT 4
75857: PUSH
75858: EMPTY
75859: LIST
75860: LIST
75861: PUSH
75862: LD_INT 1
75864: NEG
75865: PUSH
75866: LD_INT 3
75868: PUSH
75869: EMPTY
75870: LIST
75871: LIST
75872: PUSH
75873: LD_INT 1
75875: PUSH
75876: LD_INT 5
75878: PUSH
75879: EMPTY
75880: LIST
75881: LIST
75882: PUSH
75883: LD_INT 0
75885: PUSH
75886: LD_INT 5
75888: PUSH
75889: EMPTY
75890: LIST
75891: LIST
75892: PUSH
75893: LD_INT 1
75895: NEG
75896: PUSH
75897: LD_INT 4
75899: PUSH
75900: EMPTY
75901: LIST
75902: LIST
75903: PUSH
75904: LD_INT 1
75906: PUSH
75907: LD_INT 6
75909: PUSH
75910: EMPTY
75911: LIST
75912: LIST
75913: PUSH
75914: LD_INT 0
75916: PUSH
75917: LD_INT 6
75919: PUSH
75920: EMPTY
75921: LIST
75922: LIST
75923: PUSH
75924: LD_INT 1
75926: NEG
75927: PUSH
75928: LD_INT 5
75930: PUSH
75931: EMPTY
75932: LIST
75933: LIST
75934: PUSH
75935: EMPTY
75936: LIST
75937: LIST
75938: LIST
75939: LIST
75940: LIST
75941: LIST
75942: LIST
75943: LIST
75944: LIST
75945: LIST
75946: LIST
75947: LIST
75948: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
75949: LD_ADDR_VAR 0 33
75953: PUSH
75954: LD_INT 2
75956: NEG
75957: PUSH
75958: LD_INT 1
75960: PUSH
75961: EMPTY
75962: LIST
75963: LIST
75964: PUSH
75965: LD_INT 3
75967: NEG
75968: PUSH
75969: LD_INT 0
75971: PUSH
75972: EMPTY
75973: LIST
75974: LIST
75975: PUSH
75976: LD_INT 3
75978: NEG
75979: PUSH
75980: LD_INT 1
75982: NEG
75983: PUSH
75984: EMPTY
75985: LIST
75986: LIST
75987: PUSH
75988: LD_INT 3
75990: NEG
75991: PUSH
75992: LD_INT 1
75994: PUSH
75995: EMPTY
75996: LIST
75997: LIST
75998: PUSH
75999: LD_INT 4
76001: NEG
76002: PUSH
76003: LD_INT 0
76005: PUSH
76006: EMPTY
76007: LIST
76008: LIST
76009: PUSH
76010: LD_INT 4
76012: NEG
76013: PUSH
76014: LD_INT 1
76016: NEG
76017: PUSH
76018: EMPTY
76019: LIST
76020: LIST
76021: PUSH
76022: LD_INT 4
76024: NEG
76025: PUSH
76026: LD_INT 1
76028: PUSH
76029: EMPTY
76030: LIST
76031: LIST
76032: PUSH
76033: LD_INT 5
76035: NEG
76036: PUSH
76037: LD_INT 0
76039: PUSH
76040: EMPTY
76041: LIST
76042: LIST
76043: PUSH
76044: LD_INT 5
76046: NEG
76047: PUSH
76048: LD_INT 1
76050: NEG
76051: PUSH
76052: EMPTY
76053: LIST
76054: LIST
76055: PUSH
76056: LD_INT 5
76058: NEG
76059: PUSH
76060: LD_INT 1
76062: PUSH
76063: EMPTY
76064: LIST
76065: LIST
76066: PUSH
76067: LD_INT 6
76069: NEG
76070: PUSH
76071: LD_INT 0
76073: PUSH
76074: EMPTY
76075: LIST
76076: LIST
76077: PUSH
76078: LD_INT 6
76080: NEG
76081: PUSH
76082: LD_INT 1
76084: NEG
76085: PUSH
76086: EMPTY
76087: LIST
76088: LIST
76089: PUSH
76090: EMPTY
76091: LIST
76092: LIST
76093: LIST
76094: LIST
76095: LIST
76096: LIST
76097: LIST
76098: LIST
76099: LIST
76100: LIST
76101: LIST
76102: LIST
76103: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
76104: LD_ADDR_VAR 0 34
76108: PUSH
76109: LD_INT 2
76111: NEG
76112: PUSH
76113: LD_INT 3
76115: NEG
76116: PUSH
76117: EMPTY
76118: LIST
76119: LIST
76120: PUSH
76121: LD_INT 3
76123: NEG
76124: PUSH
76125: LD_INT 2
76127: NEG
76128: PUSH
76129: EMPTY
76130: LIST
76131: LIST
76132: PUSH
76133: LD_INT 3
76135: NEG
76136: PUSH
76137: LD_INT 3
76139: NEG
76140: PUSH
76141: EMPTY
76142: LIST
76143: LIST
76144: PUSH
76145: LD_INT 3
76147: NEG
76148: PUSH
76149: LD_INT 4
76151: NEG
76152: PUSH
76153: EMPTY
76154: LIST
76155: LIST
76156: PUSH
76157: LD_INT 4
76159: NEG
76160: PUSH
76161: LD_INT 3
76163: NEG
76164: PUSH
76165: EMPTY
76166: LIST
76167: LIST
76168: PUSH
76169: LD_INT 4
76171: NEG
76172: PUSH
76173: LD_INT 4
76175: NEG
76176: PUSH
76177: EMPTY
76178: LIST
76179: LIST
76180: PUSH
76181: LD_INT 4
76183: NEG
76184: PUSH
76185: LD_INT 5
76187: NEG
76188: PUSH
76189: EMPTY
76190: LIST
76191: LIST
76192: PUSH
76193: LD_INT 5
76195: NEG
76196: PUSH
76197: LD_INT 4
76199: NEG
76200: PUSH
76201: EMPTY
76202: LIST
76203: LIST
76204: PUSH
76205: LD_INT 5
76207: NEG
76208: PUSH
76209: LD_INT 5
76211: NEG
76212: PUSH
76213: EMPTY
76214: LIST
76215: LIST
76216: PUSH
76217: LD_INT 5
76219: NEG
76220: PUSH
76221: LD_INT 6
76223: NEG
76224: PUSH
76225: EMPTY
76226: LIST
76227: LIST
76228: PUSH
76229: LD_INT 6
76231: NEG
76232: PUSH
76233: LD_INT 5
76235: NEG
76236: PUSH
76237: EMPTY
76238: LIST
76239: LIST
76240: PUSH
76241: LD_INT 6
76243: NEG
76244: PUSH
76245: LD_INT 6
76247: NEG
76248: PUSH
76249: EMPTY
76250: LIST
76251: LIST
76252: PUSH
76253: EMPTY
76254: LIST
76255: LIST
76256: LIST
76257: LIST
76258: LIST
76259: LIST
76260: LIST
76261: LIST
76262: LIST
76263: LIST
76264: LIST
76265: LIST
76266: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
76267: LD_ADDR_VAR 0 41
76271: PUSH
76272: LD_INT 0
76274: PUSH
76275: LD_INT 2
76277: NEG
76278: PUSH
76279: EMPTY
76280: LIST
76281: LIST
76282: PUSH
76283: LD_INT 1
76285: NEG
76286: PUSH
76287: LD_INT 3
76289: NEG
76290: PUSH
76291: EMPTY
76292: LIST
76293: LIST
76294: PUSH
76295: LD_INT 1
76297: PUSH
76298: LD_INT 2
76300: NEG
76301: PUSH
76302: EMPTY
76303: LIST
76304: LIST
76305: PUSH
76306: EMPTY
76307: LIST
76308: LIST
76309: LIST
76310: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
76311: LD_ADDR_VAR 0 42
76315: PUSH
76316: LD_INT 2
76318: PUSH
76319: LD_INT 0
76321: PUSH
76322: EMPTY
76323: LIST
76324: LIST
76325: PUSH
76326: LD_INT 2
76328: PUSH
76329: LD_INT 1
76331: NEG
76332: PUSH
76333: EMPTY
76334: LIST
76335: LIST
76336: PUSH
76337: LD_INT 3
76339: PUSH
76340: LD_INT 1
76342: PUSH
76343: EMPTY
76344: LIST
76345: LIST
76346: PUSH
76347: EMPTY
76348: LIST
76349: LIST
76350: LIST
76351: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
76352: LD_ADDR_VAR 0 43
76356: PUSH
76357: LD_INT 2
76359: PUSH
76360: LD_INT 2
76362: PUSH
76363: EMPTY
76364: LIST
76365: LIST
76366: PUSH
76367: LD_INT 3
76369: PUSH
76370: LD_INT 2
76372: PUSH
76373: EMPTY
76374: LIST
76375: LIST
76376: PUSH
76377: LD_INT 2
76379: PUSH
76380: LD_INT 3
76382: PUSH
76383: EMPTY
76384: LIST
76385: LIST
76386: PUSH
76387: EMPTY
76388: LIST
76389: LIST
76390: LIST
76391: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
76392: LD_ADDR_VAR 0 44
76396: PUSH
76397: LD_INT 0
76399: PUSH
76400: LD_INT 2
76402: PUSH
76403: EMPTY
76404: LIST
76405: LIST
76406: PUSH
76407: LD_INT 1
76409: PUSH
76410: LD_INT 3
76412: PUSH
76413: EMPTY
76414: LIST
76415: LIST
76416: PUSH
76417: LD_INT 1
76419: NEG
76420: PUSH
76421: LD_INT 2
76423: PUSH
76424: EMPTY
76425: LIST
76426: LIST
76427: PUSH
76428: EMPTY
76429: LIST
76430: LIST
76431: LIST
76432: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
76433: LD_ADDR_VAR 0 45
76437: PUSH
76438: LD_INT 2
76440: NEG
76441: PUSH
76442: LD_INT 0
76444: PUSH
76445: EMPTY
76446: LIST
76447: LIST
76448: PUSH
76449: LD_INT 2
76451: NEG
76452: PUSH
76453: LD_INT 1
76455: PUSH
76456: EMPTY
76457: LIST
76458: LIST
76459: PUSH
76460: LD_INT 3
76462: NEG
76463: PUSH
76464: LD_INT 1
76466: NEG
76467: PUSH
76468: EMPTY
76469: LIST
76470: LIST
76471: PUSH
76472: EMPTY
76473: LIST
76474: LIST
76475: LIST
76476: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
76477: LD_ADDR_VAR 0 46
76481: PUSH
76482: LD_INT 2
76484: NEG
76485: PUSH
76486: LD_INT 2
76488: NEG
76489: PUSH
76490: EMPTY
76491: LIST
76492: LIST
76493: PUSH
76494: LD_INT 2
76496: NEG
76497: PUSH
76498: LD_INT 3
76500: NEG
76501: PUSH
76502: EMPTY
76503: LIST
76504: LIST
76505: PUSH
76506: LD_INT 3
76508: NEG
76509: PUSH
76510: LD_INT 2
76512: NEG
76513: PUSH
76514: EMPTY
76515: LIST
76516: LIST
76517: PUSH
76518: EMPTY
76519: LIST
76520: LIST
76521: LIST
76522: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
76523: LD_ADDR_VAR 0 47
76527: PUSH
76528: LD_INT 2
76530: NEG
76531: PUSH
76532: LD_INT 3
76534: NEG
76535: PUSH
76536: EMPTY
76537: LIST
76538: LIST
76539: PUSH
76540: LD_INT 1
76542: NEG
76543: PUSH
76544: LD_INT 3
76546: NEG
76547: PUSH
76548: EMPTY
76549: LIST
76550: LIST
76551: PUSH
76552: EMPTY
76553: LIST
76554: LIST
76555: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
76556: LD_ADDR_VAR 0 48
76560: PUSH
76561: LD_INT 1
76563: PUSH
76564: LD_INT 2
76566: NEG
76567: PUSH
76568: EMPTY
76569: LIST
76570: LIST
76571: PUSH
76572: LD_INT 2
76574: PUSH
76575: LD_INT 1
76577: NEG
76578: PUSH
76579: EMPTY
76580: LIST
76581: LIST
76582: PUSH
76583: EMPTY
76584: LIST
76585: LIST
76586: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
76587: LD_ADDR_VAR 0 49
76591: PUSH
76592: LD_INT 3
76594: PUSH
76595: LD_INT 1
76597: PUSH
76598: EMPTY
76599: LIST
76600: LIST
76601: PUSH
76602: LD_INT 3
76604: PUSH
76605: LD_INT 2
76607: PUSH
76608: EMPTY
76609: LIST
76610: LIST
76611: PUSH
76612: EMPTY
76613: LIST
76614: LIST
76615: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
76616: LD_ADDR_VAR 0 50
76620: PUSH
76621: LD_INT 2
76623: PUSH
76624: LD_INT 3
76626: PUSH
76627: EMPTY
76628: LIST
76629: LIST
76630: PUSH
76631: LD_INT 1
76633: PUSH
76634: LD_INT 3
76636: PUSH
76637: EMPTY
76638: LIST
76639: LIST
76640: PUSH
76641: EMPTY
76642: LIST
76643: LIST
76644: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
76645: LD_ADDR_VAR 0 51
76649: PUSH
76650: LD_INT 1
76652: NEG
76653: PUSH
76654: LD_INT 2
76656: PUSH
76657: EMPTY
76658: LIST
76659: LIST
76660: PUSH
76661: LD_INT 2
76663: NEG
76664: PUSH
76665: LD_INT 1
76667: PUSH
76668: EMPTY
76669: LIST
76670: LIST
76671: PUSH
76672: EMPTY
76673: LIST
76674: LIST
76675: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
76676: LD_ADDR_VAR 0 52
76680: PUSH
76681: LD_INT 3
76683: NEG
76684: PUSH
76685: LD_INT 1
76687: NEG
76688: PUSH
76689: EMPTY
76690: LIST
76691: LIST
76692: PUSH
76693: LD_INT 3
76695: NEG
76696: PUSH
76697: LD_INT 2
76699: NEG
76700: PUSH
76701: EMPTY
76702: LIST
76703: LIST
76704: PUSH
76705: EMPTY
76706: LIST
76707: LIST
76708: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
76709: LD_ADDR_VAR 0 53
76713: PUSH
76714: LD_INT 1
76716: NEG
76717: PUSH
76718: LD_INT 3
76720: NEG
76721: PUSH
76722: EMPTY
76723: LIST
76724: LIST
76725: PUSH
76726: LD_INT 0
76728: PUSH
76729: LD_INT 3
76731: NEG
76732: PUSH
76733: EMPTY
76734: LIST
76735: LIST
76736: PUSH
76737: LD_INT 1
76739: PUSH
76740: LD_INT 2
76742: NEG
76743: PUSH
76744: EMPTY
76745: LIST
76746: LIST
76747: PUSH
76748: EMPTY
76749: LIST
76750: LIST
76751: LIST
76752: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
76753: LD_ADDR_VAR 0 54
76757: PUSH
76758: LD_INT 2
76760: PUSH
76761: LD_INT 1
76763: NEG
76764: PUSH
76765: EMPTY
76766: LIST
76767: LIST
76768: PUSH
76769: LD_INT 3
76771: PUSH
76772: LD_INT 0
76774: PUSH
76775: EMPTY
76776: LIST
76777: LIST
76778: PUSH
76779: LD_INT 3
76781: PUSH
76782: LD_INT 1
76784: PUSH
76785: EMPTY
76786: LIST
76787: LIST
76788: PUSH
76789: EMPTY
76790: LIST
76791: LIST
76792: LIST
76793: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
76794: LD_ADDR_VAR 0 55
76798: PUSH
76799: LD_INT 3
76801: PUSH
76802: LD_INT 2
76804: PUSH
76805: EMPTY
76806: LIST
76807: LIST
76808: PUSH
76809: LD_INT 3
76811: PUSH
76812: LD_INT 3
76814: PUSH
76815: EMPTY
76816: LIST
76817: LIST
76818: PUSH
76819: LD_INT 2
76821: PUSH
76822: LD_INT 3
76824: PUSH
76825: EMPTY
76826: LIST
76827: LIST
76828: PUSH
76829: EMPTY
76830: LIST
76831: LIST
76832: LIST
76833: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
76834: LD_ADDR_VAR 0 56
76838: PUSH
76839: LD_INT 1
76841: PUSH
76842: LD_INT 3
76844: PUSH
76845: EMPTY
76846: LIST
76847: LIST
76848: PUSH
76849: LD_INT 0
76851: PUSH
76852: LD_INT 3
76854: PUSH
76855: EMPTY
76856: LIST
76857: LIST
76858: PUSH
76859: LD_INT 1
76861: NEG
76862: PUSH
76863: LD_INT 2
76865: PUSH
76866: EMPTY
76867: LIST
76868: LIST
76869: PUSH
76870: EMPTY
76871: LIST
76872: LIST
76873: LIST
76874: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
76875: LD_ADDR_VAR 0 57
76879: PUSH
76880: LD_INT 2
76882: NEG
76883: PUSH
76884: LD_INT 1
76886: PUSH
76887: EMPTY
76888: LIST
76889: LIST
76890: PUSH
76891: LD_INT 3
76893: NEG
76894: PUSH
76895: LD_INT 0
76897: PUSH
76898: EMPTY
76899: LIST
76900: LIST
76901: PUSH
76902: LD_INT 3
76904: NEG
76905: PUSH
76906: LD_INT 1
76908: NEG
76909: PUSH
76910: EMPTY
76911: LIST
76912: LIST
76913: PUSH
76914: EMPTY
76915: LIST
76916: LIST
76917: LIST
76918: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
76919: LD_ADDR_VAR 0 58
76923: PUSH
76924: LD_INT 2
76926: NEG
76927: PUSH
76928: LD_INT 3
76930: NEG
76931: PUSH
76932: EMPTY
76933: LIST
76934: LIST
76935: PUSH
76936: LD_INT 3
76938: NEG
76939: PUSH
76940: LD_INT 2
76942: NEG
76943: PUSH
76944: EMPTY
76945: LIST
76946: LIST
76947: PUSH
76948: LD_INT 3
76950: NEG
76951: PUSH
76952: LD_INT 3
76954: NEG
76955: PUSH
76956: EMPTY
76957: LIST
76958: LIST
76959: PUSH
76960: EMPTY
76961: LIST
76962: LIST
76963: LIST
76964: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
76965: LD_ADDR_VAR 0 59
76969: PUSH
76970: LD_INT 1
76972: NEG
76973: PUSH
76974: LD_INT 2
76976: NEG
76977: PUSH
76978: EMPTY
76979: LIST
76980: LIST
76981: PUSH
76982: LD_INT 0
76984: PUSH
76985: LD_INT 2
76987: NEG
76988: PUSH
76989: EMPTY
76990: LIST
76991: LIST
76992: PUSH
76993: LD_INT 1
76995: PUSH
76996: LD_INT 1
76998: NEG
76999: PUSH
77000: EMPTY
77001: LIST
77002: LIST
77003: PUSH
77004: EMPTY
77005: LIST
77006: LIST
77007: LIST
77008: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
77009: LD_ADDR_VAR 0 60
77013: PUSH
77014: LD_INT 1
77016: PUSH
77017: LD_INT 1
77019: NEG
77020: PUSH
77021: EMPTY
77022: LIST
77023: LIST
77024: PUSH
77025: LD_INT 2
77027: PUSH
77028: LD_INT 0
77030: PUSH
77031: EMPTY
77032: LIST
77033: LIST
77034: PUSH
77035: LD_INT 2
77037: PUSH
77038: LD_INT 1
77040: PUSH
77041: EMPTY
77042: LIST
77043: LIST
77044: PUSH
77045: EMPTY
77046: LIST
77047: LIST
77048: LIST
77049: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
77050: LD_ADDR_VAR 0 61
77054: PUSH
77055: LD_INT 2
77057: PUSH
77058: LD_INT 1
77060: PUSH
77061: EMPTY
77062: LIST
77063: LIST
77064: PUSH
77065: LD_INT 2
77067: PUSH
77068: LD_INT 2
77070: PUSH
77071: EMPTY
77072: LIST
77073: LIST
77074: PUSH
77075: LD_INT 1
77077: PUSH
77078: LD_INT 2
77080: PUSH
77081: EMPTY
77082: LIST
77083: LIST
77084: PUSH
77085: EMPTY
77086: LIST
77087: LIST
77088: LIST
77089: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
77090: LD_ADDR_VAR 0 62
77094: PUSH
77095: LD_INT 1
77097: PUSH
77098: LD_INT 2
77100: PUSH
77101: EMPTY
77102: LIST
77103: LIST
77104: PUSH
77105: LD_INT 0
77107: PUSH
77108: LD_INT 2
77110: PUSH
77111: EMPTY
77112: LIST
77113: LIST
77114: PUSH
77115: LD_INT 1
77117: NEG
77118: PUSH
77119: LD_INT 1
77121: PUSH
77122: EMPTY
77123: LIST
77124: LIST
77125: PUSH
77126: EMPTY
77127: LIST
77128: LIST
77129: LIST
77130: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
77131: LD_ADDR_VAR 0 63
77135: PUSH
77136: LD_INT 1
77138: NEG
77139: PUSH
77140: LD_INT 1
77142: PUSH
77143: EMPTY
77144: LIST
77145: LIST
77146: PUSH
77147: LD_INT 2
77149: NEG
77150: PUSH
77151: LD_INT 0
77153: PUSH
77154: EMPTY
77155: LIST
77156: LIST
77157: PUSH
77158: LD_INT 2
77160: NEG
77161: PUSH
77162: LD_INT 1
77164: NEG
77165: PUSH
77166: EMPTY
77167: LIST
77168: LIST
77169: PUSH
77170: EMPTY
77171: LIST
77172: LIST
77173: LIST
77174: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77175: LD_ADDR_VAR 0 64
77179: PUSH
77180: LD_INT 1
77182: NEG
77183: PUSH
77184: LD_INT 2
77186: NEG
77187: PUSH
77188: EMPTY
77189: LIST
77190: LIST
77191: PUSH
77192: LD_INT 2
77194: NEG
77195: PUSH
77196: LD_INT 1
77198: NEG
77199: PUSH
77200: EMPTY
77201: LIST
77202: LIST
77203: PUSH
77204: LD_INT 2
77206: NEG
77207: PUSH
77208: LD_INT 2
77210: NEG
77211: PUSH
77212: EMPTY
77213: LIST
77214: LIST
77215: PUSH
77216: EMPTY
77217: LIST
77218: LIST
77219: LIST
77220: ST_TO_ADDR
// end ; 2 :
77221: GO 80487
77223: LD_INT 2
77225: DOUBLE
77226: EQUAL
77227: IFTRUE 77231
77229: GO 80486
77231: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
77232: LD_ADDR_VAR 0 29
77236: PUSH
77237: LD_INT 4
77239: PUSH
77240: LD_INT 0
77242: PUSH
77243: EMPTY
77244: LIST
77245: LIST
77246: PUSH
77247: LD_INT 4
77249: PUSH
77250: LD_INT 1
77252: NEG
77253: PUSH
77254: EMPTY
77255: LIST
77256: LIST
77257: PUSH
77258: LD_INT 5
77260: PUSH
77261: LD_INT 0
77263: PUSH
77264: EMPTY
77265: LIST
77266: LIST
77267: PUSH
77268: LD_INT 5
77270: PUSH
77271: LD_INT 1
77273: PUSH
77274: EMPTY
77275: LIST
77276: LIST
77277: PUSH
77278: LD_INT 4
77280: PUSH
77281: LD_INT 1
77283: PUSH
77284: EMPTY
77285: LIST
77286: LIST
77287: PUSH
77288: LD_INT 3
77290: PUSH
77291: LD_INT 0
77293: PUSH
77294: EMPTY
77295: LIST
77296: LIST
77297: PUSH
77298: LD_INT 3
77300: PUSH
77301: LD_INT 1
77303: NEG
77304: PUSH
77305: EMPTY
77306: LIST
77307: LIST
77308: PUSH
77309: LD_INT 3
77311: PUSH
77312: LD_INT 2
77314: NEG
77315: PUSH
77316: EMPTY
77317: LIST
77318: LIST
77319: PUSH
77320: LD_INT 5
77322: PUSH
77323: LD_INT 2
77325: PUSH
77326: EMPTY
77327: LIST
77328: LIST
77329: PUSH
77330: LD_INT 3
77332: PUSH
77333: LD_INT 3
77335: PUSH
77336: EMPTY
77337: LIST
77338: LIST
77339: PUSH
77340: LD_INT 3
77342: PUSH
77343: LD_INT 2
77345: PUSH
77346: EMPTY
77347: LIST
77348: LIST
77349: PUSH
77350: LD_INT 4
77352: PUSH
77353: LD_INT 3
77355: PUSH
77356: EMPTY
77357: LIST
77358: LIST
77359: PUSH
77360: LD_INT 4
77362: PUSH
77363: LD_INT 4
77365: PUSH
77366: EMPTY
77367: LIST
77368: LIST
77369: PUSH
77370: LD_INT 3
77372: PUSH
77373: LD_INT 4
77375: PUSH
77376: EMPTY
77377: LIST
77378: LIST
77379: PUSH
77380: LD_INT 2
77382: PUSH
77383: LD_INT 3
77385: PUSH
77386: EMPTY
77387: LIST
77388: LIST
77389: PUSH
77390: LD_INT 2
77392: PUSH
77393: LD_INT 2
77395: PUSH
77396: EMPTY
77397: LIST
77398: LIST
77399: PUSH
77400: LD_INT 4
77402: PUSH
77403: LD_INT 2
77405: PUSH
77406: EMPTY
77407: LIST
77408: LIST
77409: PUSH
77410: LD_INT 2
77412: PUSH
77413: LD_INT 4
77415: PUSH
77416: EMPTY
77417: LIST
77418: LIST
77419: PUSH
77420: LD_INT 0
77422: PUSH
77423: LD_INT 4
77425: PUSH
77426: EMPTY
77427: LIST
77428: LIST
77429: PUSH
77430: LD_INT 0
77432: PUSH
77433: LD_INT 3
77435: PUSH
77436: EMPTY
77437: LIST
77438: LIST
77439: PUSH
77440: LD_INT 1
77442: PUSH
77443: LD_INT 4
77445: PUSH
77446: EMPTY
77447: LIST
77448: LIST
77449: PUSH
77450: LD_INT 1
77452: PUSH
77453: LD_INT 5
77455: PUSH
77456: EMPTY
77457: LIST
77458: LIST
77459: PUSH
77460: LD_INT 0
77462: PUSH
77463: LD_INT 5
77465: PUSH
77466: EMPTY
77467: LIST
77468: LIST
77469: PUSH
77470: LD_INT 1
77472: NEG
77473: PUSH
77474: LD_INT 4
77476: PUSH
77477: EMPTY
77478: LIST
77479: LIST
77480: PUSH
77481: LD_INT 1
77483: NEG
77484: PUSH
77485: LD_INT 3
77487: PUSH
77488: EMPTY
77489: LIST
77490: LIST
77491: PUSH
77492: LD_INT 2
77494: PUSH
77495: LD_INT 5
77497: PUSH
77498: EMPTY
77499: LIST
77500: LIST
77501: PUSH
77502: LD_INT 2
77504: NEG
77505: PUSH
77506: LD_INT 3
77508: PUSH
77509: EMPTY
77510: LIST
77511: LIST
77512: PUSH
77513: LD_INT 3
77515: NEG
77516: PUSH
77517: LD_INT 0
77519: PUSH
77520: EMPTY
77521: LIST
77522: LIST
77523: PUSH
77524: LD_INT 3
77526: NEG
77527: PUSH
77528: LD_INT 1
77530: NEG
77531: PUSH
77532: EMPTY
77533: LIST
77534: LIST
77535: PUSH
77536: LD_INT 2
77538: NEG
77539: PUSH
77540: LD_INT 0
77542: PUSH
77543: EMPTY
77544: LIST
77545: LIST
77546: PUSH
77547: LD_INT 2
77549: NEG
77550: PUSH
77551: LD_INT 1
77553: PUSH
77554: EMPTY
77555: LIST
77556: LIST
77557: PUSH
77558: LD_INT 3
77560: NEG
77561: PUSH
77562: LD_INT 1
77564: PUSH
77565: EMPTY
77566: LIST
77567: LIST
77568: PUSH
77569: LD_INT 4
77571: NEG
77572: PUSH
77573: LD_INT 0
77575: PUSH
77576: EMPTY
77577: LIST
77578: LIST
77579: PUSH
77580: LD_INT 4
77582: NEG
77583: PUSH
77584: LD_INT 1
77586: NEG
77587: PUSH
77588: EMPTY
77589: LIST
77590: LIST
77591: PUSH
77592: LD_INT 4
77594: NEG
77595: PUSH
77596: LD_INT 2
77598: NEG
77599: PUSH
77600: EMPTY
77601: LIST
77602: LIST
77603: PUSH
77604: LD_INT 2
77606: NEG
77607: PUSH
77608: LD_INT 2
77610: PUSH
77611: EMPTY
77612: LIST
77613: LIST
77614: PUSH
77615: LD_INT 4
77617: NEG
77618: PUSH
77619: LD_INT 4
77621: NEG
77622: PUSH
77623: EMPTY
77624: LIST
77625: LIST
77626: PUSH
77627: LD_INT 4
77629: NEG
77630: PUSH
77631: LD_INT 5
77633: NEG
77634: PUSH
77635: EMPTY
77636: LIST
77637: LIST
77638: PUSH
77639: LD_INT 3
77641: NEG
77642: PUSH
77643: LD_INT 4
77645: NEG
77646: PUSH
77647: EMPTY
77648: LIST
77649: LIST
77650: PUSH
77651: LD_INT 3
77653: NEG
77654: PUSH
77655: LD_INT 3
77657: NEG
77658: PUSH
77659: EMPTY
77660: LIST
77661: LIST
77662: PUSH
77663: LD_INT 4
77665: NEG
77666: PUSH
77667: LD_INT 3
77669: NEG
77670: PUSH
77671: EMPTY
77672: LIST
77673: LIST
77674: PUSH
77675: LD_INT 5
77677: NEG
77678: PUSH
77679: LD_INT 4
77681: NEG
77682: PUSH
77683: EMPTY
77684: LIST
77685: LIST
77686: PUSH
77687: LD_INT 5
77689: NEG
77690: PUSH
77691: LD_INT 5
77693: NEG
77694: PUSH
77695: EMPTY
77696: LIST
77697: LIST
77698: PUSH
77699: LD_INT 3
77701: NEG
77702: PUSH
77703: LD_INT 5
77705: NEG
77706: PUSH
77707: EMPTY
77708: LIST
77709: LIST
77710: PUSH
77711: LD_INT 5
77713: NEG
77714: PUSH
77715: LD_INT 3
77717: NEG
77718: PUSH
77719: EMPTY
77720: LIST
77721: LIST
77722: PUSH
77723: EMPTY
77724: LIST
77725: LIST
77726: LIST
77727: LIST
77728: LIST
77729: LIST
77730: LIST
77731: LIST
77732: LIST
77733: LIST
77734: LIST
77735: LIST
77736: LIST
77737: LIST
77738: LIST
77739: LIST
77740: LIST
77741: LIST
77742: LIST
77743: LIST
77744: LIST
77745: LIST
77746: LIST
77747: LIST
77748: LIST
77749: LIST
77750: LIST
77751: LIST
77752: LIST
77753: LIST
77754: LIST
77755: LIST
77756: LIST
77757: LIST
77758: LIST
77759: LIST
77760: LIST
77761: LIST
77762: LIST
77763: LIST
77764: LIST
77765: LIST
77766: LIST
77767: LIST
77768: LIST
77769: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
77770: LD_ADDR_VAR 0 30
77774: PUSH
77775: LD_INT 4
77777: PUSH
77778: LD_INT 4
77780: PUSH
77781: EMPTY
77782: LIST
77783: LIST
77784: PUSH
77785: LD_INT 4
77787: PUSH
77788: LD_INT 3
77790: PUSH
77791: EMPTY
77792: LIST
77793: LIST
77794: PUSH
77795: LD_INT 5
77797: PUSH
77798: LD_INT 4
77800: PUSH
77801: EMPTY
77802: LIST
77803: LIST
77804: PUSH
77805: LD_INT 5
77807: PUSH
77808: LD_INT 5
77810: PUSH
77811: EMPTY
77812: LIST
77813: LIST
77814: PUSH
77815: LD_INT 4
77817: PUSH
77818: LD_INT 5
77820: PUSH
77821: EMPTY
77822: LIST
77823: LIST
77824: PUSH
77825: LD_INT 3
77827: PUSH
77828: LD_INT 4
77830: PUSH
77831: EMPTY
77832: LIST
77833: LIST
77834: PUSH
77835: LD_INT 3
77837: PUSH
77838: LD_INT 3
77840: PUSH
77841: EMPTY
77842: LIST
77843: LIST
77844: PUSH
77845: LD_INT 5
77847: PUSH
77848: LD_INT 3
77850: PUSH
77851: EMPTY
77852: LIST
77853: LIST
77854: PUSH
77855: LD_INT 3
77857: PUSH
77858: LD_INT 5
77860: PUSH
77861: EMPTY
77862: LIST
77863: LIST
77864: PUSH
77865: LD_INT 0
77867: PUSH
77868: LD_INT 3
77870: PUSH
77871: EMPTY
77872: LIST
77873: LIST
77874: PUSH
77875: LD_INT 0
77877: PUSH
77878: LD_INT 2
77880: PUSH
77881: EMPTY
77882: LIST
77883: LIST
77884: PUSH
77885: LD_INT 1
77887: PUSH
77888: LD_INT 3
77890: PUSH
77891: EMPTY
77892: LIST
77893: LIST
77894: PUSH
77895: LD_INT 1
77897: PUSH
77898: LD_INT 4
77900: PUSH
77901: EMPTY
77902: LIST
77903: LIST
77904: PUSH
77905: LD_INT 0
77907: PUSH
77908: LD_INT 4
77910: PUSH
77911: EMPTY
77912: LIST
77913: LIST
77914: PUSH
77915: LD_INT 1
77917: NEG
77918: PUSH
77919: LD_INT 3
77921: PUSH
77922: EMPTY
77923: LIST
77924: LIST
77925: PUSH
77926: LD_INT 1
77928: NEG
77929: PUSH
77930: LD_INT 2
77932: PUSH
77933: EMPTY
77934: LIST
77935: LIST
77936: PUSH
77937: LD_INT 2
77939: PUSH
77940: LD_INT 4
77942: PUSH
77943: EMPTY
77944: LIST
77945: LIST
77946: PUSH
77947: LD_INT 2
77949: NEG
77950: PUSH
77951: LD_INT 2
77953: PUSH
77954: EMPTY
77955: LIST
77956: LIST
77957: PUSH
77958: LD_INT 4
77960: NEG
77961: PUSH
77962: LD_INT 0
77964: PUSH
77965: EMPTY
77966: LIST
77967: LIST
77968: PUSH
77969: LD_INT 4
77971: NEG
77972: PUSH
77973: LD_INT 1
77975: NEG
77976: PUSH
77977: EMPTY
77978: LIST
77979: LIST
77980: PUSH
77981: LD_INT 3
77983: NEG
77984: PUSH
77985: LD_INT 0
77987: PUSH
77988: EMPTY
77989: LIST
77990: LIST
77991: PUSH
77992: LD_INT 3
77994: NEG
77995: PUSH
77996: LD_INT 1
77998: PUSH
77999: EMPTY
78000: LIST
78001: LIST
78002: PUSH
78003: LD_INT 4
78005: NEG
78006: PUSH
78007: LD_INT 1
78009: PUSH
78010: EMPTY
78011: LIST
78012: LIST
78013: PUSH
78014: LD_INT 5
78016: NEG
78017: PUSH
78018: LD_INT 0
78020: PUSH
78021: EMPTY
78022: LIST
78023: LIST
78024: PUSH
78025: LD_INT 5
78027: NEG
78028: PUSH
78029: LD_INT 1
78031: NEG
78032: PUSH
78033: EMPTY
78034: LIST
78035: LIST
78036: PUSH
78037: LD_INT 5
78039: NEG
78040: PUSH
78041: LD_INT 2
78043: NEG
78044: PUSH
78045: EMPTY
78046: LIST
78047: LIST
78048: PUSH
78049: LD_INT 3
78051: NEG
78052: PUSH
78053: LD_INT 2
78055: PUSH
78056: EMPTY
78057: LIST
78058: LIST
78059: PUSH
78060: LD_INT 3
78062: NEG
78063: PUSH
78064: LD_INT 3
78066: NEG
78067: PUSH
78068: EMPTY
78069: LIST
78070: LIST
78071: PUSH
78072: LD_INT 3
78074: NEG
78075: PUSH
78076: LD_INT 4
78078: NEG
78079: PUSH
78080: EMPTY
78081: LIST
78082: LIST
78083: PUSH
78084: LD_INT 2
78086: NEG
78087: PUSH
78088: LD_INT 3
78090: NEG
78091: PUSH
78092: EMPTY
78093: LIST
78094: LIST
78095: PUSH
78096: LD_INT 2
78098: NEG
78099: PUSH
78100: LD_INT 2
78102: NEG
78103: PUSH
78104: EMPTY
78105: LIST
78106: LIST
78107: PUSH
78108: LD_INT 3
78110: NEG
78111: PUSH
78112: LD_INT 2
78114: NEG
78115: PUSH
78116: EMPTY
78117: LIST
78118: LIST
78119: PUSH
78120: LD_INT 4
78122: NEG
78123: PUSH
78124: LD_INT 3
78126: NEG
78127: PUSH
78128: EMPTY
78129: LIST
78130: LIST
78131: PUSH
78132: LD_INT 4
78134: NEG
78135: PUSH
78136: LD_INT 4
78138: NEG
78139: PUSH
78140: EMPTY
78141: LIST
78142: LIST
78143: PUSH
78144: LD_INT 2
78146: NEG
78147: PUSH
78148: LD_INT 4
78150: NEG
78151: PUSH
78152: EMPTY
78153: LIST
78154: LIST
78155: PUSH
78156: LD_INT 4
78158: NEG
78159: PUSH
78160: LD_INT 2
78162: NEG
78163: PUSH
78164: EMPTY
78165: LIST
78166: LIST
78167: PUSH
78168: LD_INT 0
78170: PUSH
78171: LD_INT 4
78173: NEG
78174: PUSH
78175: EMPTY
78176: LIST
78177: LIST
78178: PUSH
78179: LD_INT 0
78181: PUSH
78182: LD_INT 5
78184: NEG
78185: PUSH
78186: EMPTY
78187: LIST
78188: LIST
78189: PUSH
78190: LD_INT 1
78192: PUSH
78193: LD_INT 4
78195: NEG
78196: PUSH
78197: EMPTY
78198: LIST
78199: LIST
78200: PUSH
78201: LD_INT 1
78203: PUSH
78204: LD_INT 3
78206: NEG
78207: PUSH
78208: EMPTY
78209: LIST
78210: LIST
78211: PUSH
78212: LD_INT 0
78214: PUSH
78215: LD_INT 3
78217: NEG
78218: PUSH
78219: EMPTY
78220: LIST
78221: LIST
78222: PUSH
78223: LD_INT 1
78225: NEG
78226: PUSH
78227: LD_INT 4
78229: NEG
78230: PUSH
78231: EMPTY
78232: LIST
78233: LIST
78234: PUSH
78235: LD_INT 1
78237: NEG
78238: PUSH
78239: LD_INT 5
78241: NEG
78242: PUSH
78243: EMPTY
78244: LIST
78245: LIST
78246: PUSH
78247: LD_INT 2
78249: PUSH
78250: LD_INT 3
78252: NEG
78253: PUSH
78254: EMPTY
78255: LIST
78256: LIST
78257: PUSH
78258: LD_INT 2
78260: NEG
78261: PUSH
78262: LD_INT 5
78264: NEG
78265: PUSH
78266: EMPTY
78267: LIST
78268: LIST
78269: PUSH
78270: EMPTY
78271: LIST
78272: LIST
78273: LIST
78274: LIST
78275: LIST
78276: LIST
78277: LIST
78278: LIST
78279: LIST
78280: LIST
78281: LIST
78282: LIST
78283: LIST
78284: LIST
78285: LIST
78286: LIST
78287: LIST
78288: LIST
78289: LIST
78290: LIST
78291: LIST
78292: LIST
78293: LIST
78294: LIST
78295: LIST
78296: LIST
78297: LIST
78298: LIST
78299: LIST
78300: LIST
78301: LIST
78302: LIST
78303: LIST
78304: LIST
78305: LIST
78306: LIST
78307: LIST
78308: LIST
78309: LIST
78310: LIST
78311: LIST
78312: LIST
78313: LIST
78314: LIST
78315: LIST
78316: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
78317: LD_ADDR_VAR 0 31
78321: PUSH
78322: LD_INT 0
78324: PUSH
78325: LD_INT 4
78327: PUSH
78328: EMPTY
78329: LIST
78330: LIST
78331: PUSH
78332: LD_INT 0
78334: PUSH
78335: LD_INT 3
78337: PUSH
78338: EMPTY
78339: LIST
78340: LIST
78341: PUSH
78342: LD_INT 1
78344: PUSH
78345: LD_INT 4
78347: PUSH
78348: EMPTY
78349: LIST
78350: LIST
78351: PUSH
78352: LD_INT 1
78354: PUSH
78355: LD_INT 5
78357: PUSH
78358: EMPTY
78359: LIST
78360: LIST
78361: PUSH
78362: LD_INT 0
78364: PUSH
78365: LD_INT 5
78367: PUSH
78368: EMPTY
78369: LIST
78370: LIST
78371: PUSH
78372: LD_INT 1
78374: NEG
78375: PUSH
78376: LD_INT 4
78378: PUSH
78379: EMPTY
78380: LIST
78381: LIST
78382: PUSH
78383: LD_INT 1
78385: NEG
78386: PUSH
78387: LD_INT 3
78389: PUSH
78390: EMPTY
78391: LIST
78392: LIST
78393: PUSH
78394: LD_INT 2
78396: PUSH
78397: LD_INT 5
78399: PUSH
78400: EMPTY
78401: LIST
78402: LIST
78403: PUSH
78404: LD_INT 2
78406: NEG
78407: PUSH
78408: LD_INT 3
78410: PUSH
78411: EMPTY
78412: LIST
78413: LIST
78414: PUSH
78415: LD_INT 3
78417: NEG
78418: PUSH
78419: LD_INT 0
78421: PUSH
78422: EMPTY
78423: LIST
78424: LIST
78425: PUSH
78426: LD_INT 3
78428: NEG
78429: PUSH
78430: LD_INT 1
78432: NEG
78433: PUSH
78434: EMPTY
78435: LIST
78436: LIST
78437: PUSH
78438: LD_INT 2
78440: NEG
78441: PUSH
78442: LD_INT 0
78444: PUSH
78445: EMPTY
78446: LIST
78447: LIST
78448: PUSH
78449: LD_INT 2
78451: NEG
78452: PUSH
78453: LD_INT 1
78455: PUSH
78456: EMPTY
78457: LIST
78458: LIST
78459: PUSH
78460: LD_INT 3
78462: NEG
78463: PUSH
78464: LD_INT 1
78466: PUSH
78467: EMPTY
78468: LIST
78469: LIST
78470: PUSH
78471: LD_INT 4
78473: NEG
78474: PUSH
78475: LD_INT 0
78477: PUSH
78478: EMPTY
78479: LIST
78480: LIST
78481: PUSH
78482: LD_INT 4
78484: NEG
78485: PUSH
78486: LD_INT 1
78488: NEG
78489: PUSH
78490: EMPTY
78491: LIST
78492: LIST
78493: PUSH
78494: LD_INT 4
78496: NEG
78497: PUSH
78498: LD_INT 2
78500: NEG
78501: PUSH
78502: EMPTY
78503: LIST
78504: LIST
78505: PUSH
78506: LD_INT 2
78508: NEG
78509: PUSH
78510: LD_INT 2
78512: PUSH
78513: EMPTY
78514: LIST
78515: LIST
78516: PUSH
78517: LD_INT 4
78519: NEG
78520: PUSH
78521: LD_INT 4
78523: NEG
78524: PUSH
78525: EMPTY
78526: LIST
78527: LIST
78528: PUSH
78529: LD_INT 4
78531: NEG
78532: PUSH
78533: LD_INT 5
78535: NEG
78536: PUSH
78537: EMPTY
78538: LIST
78539: LIST
78540: PUSH
78541: LD_INT 3
78543: NEG
78544: PUSH
78545: LD_INT 4
78547: NEG
78548: PUSH
78549: EMPTY
78550: LIST
78551: LIST
78552: PUSH
78553: LD_INT 3
78555: NEG
78556: PUSH
78557: LD_INT 3
78559: NEG
78560: PUSH
78561: EMPTY
78562: LIST
78563: LIST
78564: PUSH
78565: LD_INT 4
78567: NEG
78568: PUSH
78569: LD_INT 3
78571: NEG
78572: PUSH
78573: EMPTY
78574: LIST
78575: LIST
78576: PUSH
78577: LD_INT 5
78579: NEG
78580: PUSH
78581: LD_INT 4
78583: NEG
78584: PUSH
78585: EMPTY
78586: LIST
78587: LIST
78588: PUSH
78589: LD_INT 5
78591: NEG
78592: PUSH
78593: LD_INT 5
78595: NEG
78596: PUSH
78597: EMPTY
78598: LIST
78599: LIST
78600: PUSH
78601: LD_INT 3
78603: NEG
78604: PUSH
78605: LD_INT 5
78607: NEG
78608: PUSH
78609: EMPTY
78610: LIST
78611: LIST
78612: PUSH
78613: LD_INT 5
78615: NEG
78616: PUSH
78617: LD_INT 3
78619: NEG
78620: PUSH
78621: EMPTY
78622: LIST
78623: LIST
78624: PUSH
78625: LD_INT 0
78627: PUSH
78628: LD_INT 3
78630: NEG
78631: PUSH
78632: EMPTY
78633: LIST
78634: LIST
78635: PUSH
78636: LD_INT 0
78638: PUSH
78639: LD_INT 4
78641: NEG
78642: PUSH
78643: EMPTY
78644: LIST
78645: LIST
78646: PUSH
78647: LD_INT 1
78649: PUSH
78650: LD_INT 3
78652: NEG
78653: PUSH
78654: EMPTY
78655: LIST
78656: LIST
78657: PUSH
78658: LD_INT 1
78660: PUSH
78661: LD_INT 2
78663: NEG
78664: PUSH
78665: EMPTY
78666: LIST
78667: LIST
78668: PUSH
78669: LD_INT 0
78671: PUSH
78672: LD_INT 2
78674: NEG
78675: PUSH
78676: EMPTY
78677: LIST
78678: LIST
78679: PUSH
78680: LD_INT 1
78682: NEG
78683: PUSH
78684: LD_INT 3
78686: NEG
78687: PUSH
78688: EMPTY
78689: LIST
78690: LIST
78691: PUSH
78692: LD_INT 1
78694: NEG
78695: PUSH
78696: LD_INT 4
78698: NEG
78699: PUSH
78700: EMPTY
78701: LIST
78702: LIST
78703: PUSH
78704: LD_INT 2
78706: PUSH
78707: LD_INT 2
78709: NEG
78710: PUSH
78711: EMPTY
78712: LIST
78713: LIST
78714: PUSH
78715: LD_INT 2
78717: NEG
78718: PUSH
78719: LD_INT 4
78721: NEG
78722: PUSH
78723: EMPTY
78724: LIST
78725: LIST
78726: PUSH
78727: LD_INT 4
78729: PUSH
78730: LD_INT 0
78732: PUSH
78733: EMPTY
78734: LIST
78735: LIST
78736: PUSH
78737: LD_INT 4
78739: PUSH
78740: LD_INT 1
78742: NEG
78743: PUSH
78744: EMPTY
78745: LIST
78746: LIST
78747: PUSH
78748: LD_INT 5
78750: PUSH
78751: LD_INT 0
78753: PUSH
78754: EMPTY
78755: LIST
78756: LIST
78757: PUSH
78758: LD_INT 5
78760: PUSH
78761: LD_INT 1
78763: PUSH
78764: EMPTY
78765: LIST
78766: LIST
78767: PUSH
78768: LD_INT 4
78770: PUSH
78771: LD_INT 1
78773: PUSH
78774: EMPTY
78775: LIST
78776: LIST
78777: PUSH
78778: LD_INT 3
78780: PUSH
78781: LD_INT 0
78783: PUSH
78784: EMPTY
78785: LIST
78786: LIST
78787: PUSH
78788: LD_INT 3
78790: PUSH
78791: LD_INT 1
78793: NEG
78794: PUSH
78795: EMPTY
78796: LIST
78797: LIST
78798: PUSH
78799: LD_INT 3
78801: PUSH
78802: LD_INT 2
78804: NEG
78805: PUSH
78806: EMPTY
78807: LIST
78808: LIST
78809: PUSH
78810: LD_INT 5
78812: PUSH
78813: LD_INT 2
78815: PUSH
78816: EMPTY
78817: LIST
78818: LIST
78819: PUSH
78820: EMPTY
78821: LIST
78822: LIST
78823: LIST
78824: LIST
78825: LIST
78826: LIST
78827: LIST
78828: LIST
78829: LIST
78830: LIST
78831: LIST
78832: LIST
78833: LIST
78834: LIST
78835: LIST
78836: LIST
78837: LIST
78838: LIST
78839: LIST
78840: LIST
78841: LIST
78842: LIST
78843: LIST
78844: LIST
78845: LIST
78846: LIST
78847: LIST
78848: LIST
78849: LIST
78850: LIST
78851: LIST
78852: LIST
78853: LIST
78854: LIST
78855: LIST
78856: LIST
78857: LIST
78858: LIST
78859: LIST
78860: LIST
78861: LIST
78862: LIST
78863: LIST
78864: LIST
78865: LIST
78866: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
78867: LD_ADDR_VAR 0 32
78871: PUSH
78872: LD_INT 4
78874: NEG
78875: PUSH
78876: LD_INT 0
78878: PUSH
78879: EMPTY
78880: LIST
78881: LIST
78882: PUSH
78883: LD_INT 4
78885: NEG
78886: PUSH
78887: LD_INT 1
78889: NEG
78890: PUSH
78891: EMPTY
78892: LIST
78893: LIST
78894: PUSH
78895: LD_INT 3
78897: NEG
78898: PUSH
78899: LD_INT 0
78901: PUSH
78902: EMPTY
78903: LIST
78904: LIST
78905: PUSH
78906: LD_INT 3
78908: NEG
78909: PUSH
78910: LD_INT 1
78912: PUSH
78913: EMPTY
78914: LIST
78915: LIST
78916: PUSH
78917: LD_INT 4
78919: NEG
78920: PUSH
78921: LD_INT 1
78923: PUSH
78924: EMPTY
78925: LIST
78926: LIST
78927: PUSH
78928: LD_INT 5
78930: NEG
78931: PUSH
78932: LD_INT 0
78934: PUSH
78935: EMPTY
78936: LIST
78937: LIST
78938: PUSH
78939: LD_INT 5
78941: NEG
78942: PUSH
78943: LD_INT 1
78945: NEG
78946: PUSH
78947: EMPTY
78948: LIST
78949: LIST
78950: PUSH
78951: LD_INT 5
78953: NEG
78954: PUSH
78955: LD_INT 2
78957: NEG
78958: PUSH
78959: EMPTY
78960: LIST
78961: LIST
78962: PUSH
78963: LD_INT 3
78965: NEG
78966: PUSH
78967: LD_INT 2
78969: PUSH
78970: EMPTY
78971: LIST
78972: LIST
78973: PUSH
78974: LD_INT 3
78976: NEG
78977: PUSH
78978: LD_INT 3
78980: NEG
78981: PUSH
78982: EMPTY
78983: LIST
78984: LIST
78985: PUSH
78986: LD_INT 3
78988: NEG
78989: PUSH
78990: LD_INT 4
78992: NEG
78993: PUSH
78994: EMPTY
78995: LIST
78996: LIST
78997: PUSH
78998: LD_INT 2
79000: NEG
79001: PUSH
79002: LD_INT 3
79004: NEG
79005: PUSH
79006: EMPTY
79007: LIST
79008: LIST
79009: PUSH
79010: LD_INT 2
79012: NEG
79013: PUSH
79014: LD_INT 2
79016: NEG
79017: PUSH
79018: EMPTY
79019: LIST
79020: LIST
79021: PUSH
79022: LD_INT 3
79024: NEG
79025: PUSH
79026: LD_INT 2
79028: NEG
79029: PUSH
79030: EMPTY
79031: LIST
79032: LIST
79033: PUSH
79034: LD_INT 4
79036: NEG
79037: PUSH
79038: LD_INT 3
79040: NEG
79041: PUSH
79042: EMPTY
79043: LIST
79044: LIST
79045: PUSH
79046: LD_INT 4
79048: NEG
79049: PUSH
79050: LD_INT 4
79052: NEG
79053: PUSH
79054: EMPTY
79055: LIST
79056: LIST
79057: PUSH
79058: LD_INT 2
79060: NEG
79061: PUSH
79062: LD_INT 4
79064: NEG
79065: PUSH
79066: EMPTY
79067: LIST
79068: LIST
79069: PUSH
79070: LD_INT 4
79072: NEG
79073: PUSH
79074: LD_INT 2
79076: NEG
79077: PUSH
79078: EMPTY
79079: LIST
79080: LIST
79081: PUSH
79082: LD_INT 0
79084: PUSH
79085: LD_INT 4
79087: NEG
79088: PUSH
79089: EMPTY
79090: LIST
79091: LIST
79092: PUSH
79093: LD_INT 0
79095: PUSH
79096: LD_INT 5
79098: NEG
79099: PUSH
79100: EMPTY
79101: LIST
79102: LIST
79103: PUSH
79104: LD_INT 1
79106: PUSH
79107: LD_INT 4
79109: NEG
79110: PUSH
79111: EMPTY
79112: LIST
79113: LIST
79114: PUSH
79115: LD_INT 1
79117: PUSH
79118: LD_INT 3
79120: NEG
79121: PUSH
79122: EMPTY
79123: LIST
79124: LIST
79125: PUSH
79126: LD_INT 0
79128: PUSH
79129: LD_INT 3
79131: NEG
79132: PUSH
79133: EMPTY
79134: LIST
79135: LIST
79136: PUSH
79137: LD_INT 1
79139: NEG
79140: PUSH
79141: LD_INT 4
79143: NEG
79144: PUSH
79145: EMPTY
79146: LIST
79147: LIST
79148: PUSH
79149: LD_INT 1
79151: NEG
79152: PUSH
79153: LD_INT 5
79155: NEG
79156: PUSH
79157: EMPTY
79158: LIST
79159: LIST
79160: PUSH
79161: LD_INT 2
79163: PUSH
79164: LD_INT 3
79166: NEG
79167: PUSH
79168: EMPTY
79169: LIST
79170: LIST
79171: PUSH
79172: LD_INT 2
79174: NEG
79175: PUSH
79176: LD_INT 5
79178: NEG
79179: PUSH
79180: EMPTY
79181: LIST
79182: LIST
79183: PUSH
79184: LD_INT 3
79186: PUSH
79187: LD_INT 0
79189: PUSH
79190: EMPTY
79191: LIST
79192: LIST
79193: PUSH
79194: LD_INT 3
79196: PUSH
79197: LD_INT 1
79199: NEG
79200: PUSH
79201: EMPTY
79202: LIST
79203: LIST
79204: PUSH
79205: LD_INT 4
79207: PUSH
79208: LD_INT 0
79210: PUSH
79211: EMPTY
79212: LIST
79213: LIST
79214: PUSH
79215: LD_INT 4
79217: PUSH
79218: LD_INT 1
79220: PUSH
79221: EMPTY
79222: LIST
79223: LIST
79224: PUSH
79225: LD_INT 3
79227: PUSH
79228: LD_INT 1
79230: PUSH
79231: EMPTY
79232: LIST
79233: LIST
79234: PUSH
79235: LD_INT 2
79237: PUSH
79238: LD_INT 0
79240: PUSH
79241: EMPTY
79242: LIST
79243: LIST
79244: PUSH
79245: LD_INT 2
79247: PUSH
79248: LD_INT 1
79250: NEG
79251: PUSH
79252: EMPTY
79253: LIST
79254: LIST
79255: PUSH
79256: LD_INT 2
79258: PUSH
79259: LD_INT 2
79261: NEG
79262: PUSH
79263: EMPTY
79264: LIST
79265: LIST
79266: PUSH
79267: LD_INT 4
79269: PUSH
79270: LD_INT 2
79272: PUSH
79273: EMPTY
79274: LIST
79275: LIST
79276: PUSH
79277: LD_INT 4
79279: PUSH
79280: LD_INT 4
79282: PUSH
79283: EMPTY
79284: LIST
79285: LIST
79286: PUSH
79287: LD_INT 4
79289: PUSH
79290: LD_INT 3
79292: PUSH
79293: EMPTY
79294: LIST
79295: LIST
79296: PUSH
79297: LD_INT 5
79299: PUSH
79300: LD_INT 4
79302: PUSH
79303: EMPTY
79304: LIST
79305: LIST
79306: PUSH
79307: LD_INT 5
79309: PUSH
79310: LD_INT 5
79312: PUSH
79313: EMPTY
79314: LIST
79315: LIST
79316: PUSH
79317: LD_INT 4
79319: PUSH
79320: LD_INT 5
79322: PUSH
79323: EMPTY
79324: LIST
79325: LIST
79326: PUSH
79327: LD_INT 3
79329: PUSH
79330: LD_INT 4
79332: PUSH
79333: EMPTY
79334: LIST
79335: LIST
79336: PUSH
79337: LD_INT 3
79339: PUSH
79340: LD_INT 3
79342: PUSH
79343: EMPTY
79344: LIST
79345: LIST
79346: PUSH
79347: LD_INT 5
79349: PUSH
79350: LD_INT 3
79352: PUSH
79353: EMPTY
79354: LIST
79355: LIST
79356: PUSH
79357: LD_INT 3
79359: PUSH
79360: LD_INT 5
79362: PUSH
79363: EMPTY
79364: LIST
79365: LIST
79366: PUSH
79367: EMPTY
79368: LIST
79369: LIST
79370: LIST
79371: LIST
79372: LIST
79373: LIST
79374: LIST
79375: LIST
79376: LIST
79377: LIST
79378: LIST
79379: LIST
79380: LIST
79381: LIST
79382: LIST
79383: LIST
79384: LIST
79385: LIST
79386: LIST
79387: LIST
79388: LIST
79389: LIST
79390: LIST
79391: LIST
79392: LIST
79393: LIST
79394: LIST
79395: LIST
79396: LIST
79397: LIST
79398: LIST
79399: LIST
79400: LIST
79401: LIST
79402: LIST
79403: LIST
79404: LIST
79405: LIST
79406: LIST
79407: LIST
79408: LIST
79409: LIST
79410: LIST
79411: LIST
79412: LIST
79413: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
79414: LD_ADDR_VAR 0 33
79418: PUSH
79419: LD_INT 4
79421: NEG
79422: PUSH
79423: LD_INT 4
79425: NEG
79426: PUSH
79427: EMPTY
79428: LIST
79429: LIST
79430: PUSH
79431: LD_INT 4
79433: NEG
79434: PUSH
79435: LD_INT 5
79437: NEG
79438: PUSH
79439: EMPTY
79440: LIST
79441: LIST
79442: PUSH
79443: LD_INT 3
79445: NEG
79446: PUSH
79447: LD_INT 4
79449: NEG
79450: PUSH
79451: EMPTY
79452: LIST
79453: LIST
79454: PUSH
79455: LD_INT 3
79457: NEG
79458: PUSH
79459: LD_INT 3
79461: NEG
79462: PUSH
79463: EMPTY
79464: LIST
79465: LIST
79466: PUSH
79467: LD_INT 4
79469: NEG
79470: PUSH
79471: LD_INT 3
79473: NEG
79474: PUSH
79475: EMPTY
79476: LIST
79477: LIST
79478: PUSH
79479: LD_INT 5
79481: NEG
79482: PUSH
79483: LD_INT 4
79485: NEG
79486: PUSH
79487: EMPTY
79488: LIST
79489: LIST
79490: PUSH
79491: LD_INT 5
79493: NEG
79494: PUSH
79495: LD_INT 5
79497: NEG
79498: PUSH
79499: EMPTY
79500: LIST
79501: LIST
79502: PUSH
79503: LD_INT 3
79505: NEG
79506: PUSH
79507: LD_INT 5
79509: NEG
79510: PUSH
79511: EMPTY
79512: LIST
79513: LIST
79514: PUSH
79515: LD_INT 5
79517: NEG
79518: PUSH
79519: LD_INT 3
79521: NEG
79522: PUSH
79523: EMPTY
79524: LIST
79525: LIST
79526: PUSH
79527: LD_INT 0
79529: PUSH
79530: LD_INT 3
79532: NEG
79533: PUSH
79534: EMPTY
79535: LIST
79536: LIST
79537: PUSH
79538: LD_INT 0
79540: PUSH
79541: LD_INT 4
79543: NEG
79544: PUSH
79545: EMPTY
79546: LIST
79547: LIST
79548: PUSH
79549: LD_INT 1
79551: PUSH
79552: LD_INT 3
79554: NEG
79555: PUSH
79556: EMPTY
79557: LIST
79558: LIST
79559: PUSH
79560: LD_INT 1
79562: PUSH
79563: LD_INT 2
79565: NEG
79566: PUSH
79567: EMPTY
79568: LIST
79569: LIST
79570: PUSH
79571: LD_INT 0
79573: PUSH
79574: LD_INT 2
79576: NEG
79577: PUSH
79578: EMPTY
79579: LIST
79580: LIST
79581: PUSH
79582: LD_INT 1
79584: NEG
79585: PUSH
79586: LD_INT 3
79588: NEG
79589: PUSH
79590: EMPTY
79591: LIST
79592: LIST
79593: PUSH
79594: LD_INT 1
79596: NEG
79597: PUSH
79598: LD_INT 4
79600: NEG
79601: PUSH
79602: EMPTY
79603: LIST
79604: LIST
79605: PUSH
79606: LD_INT 2
79608: PUSH
79609: LD_INT 2
79611: NEG
79612: PUSH
79613: EMPTY
79614: LIST
79615: LIST
79616: PUSH
79617: LD_INT 2
79619: NEG
79620: PUSH
79621: LD_INT 4
79623: NEG
79624: PUSH
79625: EMPTY
79626: LIST
79627: LIST
79628: PUSH
79629: LD_INT 4
79631: PUSH
79632: LD_INT 0
79634: PUSH
79635: EMPTY
79636: LIST
79637: LIST
79638: PUSH
79639: LD_INT 4
79641: PUSH
79642: LD_INT 1
79644: NEG
79645: PUSH
79646: EMPTY
79647: LIST
79648: LIST
79649: PUSH
79650: LD_INT 5
79652: PUSH
79653: LD_INT 0
79655: PUSH
79656: EMPTY
79657: LIST
79658: LIST
79659: PUSH
79660: LD_INT 5
79662: PUSH
79663: LD_INT 1
79665: PUSH
79666: EMPTY
79667: LIST
79668: LIST
79669: PUSH
79670: LD_INT 4
79672: PUSH
79673: LD_INT 1
79675: PUSH
79676: EMPTY
79677: LIST
79678: LIST
79679: PUSH
79680: LD_INT 3
79682: PUSH
79683: LD_INT 0
79685: PUSH
79686: EMPTY
79687: LIST
79688: LIST
79689: PUSH
79690: LD_INT 3
79692: PUSH
79693: LD_INT 1
79695: NEG
79696: PUSH
79697: EMPTY
79698: LIST
79699: LIST
79700: PUSH
79701: LD_INT 3
79703: PUSH
79704: LD_INT 2
79706: NEG
79707: PUSH
79708: EMPTY
79709: LIST
79710: LIST
79711: PUSH
79712: LD_INT 5
79714: PUSH
79715: LD_INT 2
79717: PUSH
79718: EMPTY
79719: LIST
79720: LIST
79721: PUSH
79722: LD_INT 3
79724: PUSH
79725: LD_INT 3
79727: PUSH
79728: EMPTY
79729: LIST
79730: LIST
79731: PUSH
79732: LD_INT 3
79734: PUSH
79735: LD_INT 2
79737: PUSH
79738: EMPTY
79739: LIST
79740: LIST
79741: PUSH
79742: LD_INT 4
79744: PUSH
79745: LD_INT 3
79747: PUSH
79748: EMPTY
79749: LIST
79750: LIST
79751: PUSH
79752: LD_INT 4
79754: PUSH
79755: LD_INT 4
79757: PUSH
79758: EMPTY
79759: LIST
79760: LIST
79761: PUSH
79762: LD_INT 3
79764: PUSH
79765: LD_INT 4
79767: PUSH
79768: EMPTY
79769: LIST
79770: LIST
79771: PUSH
79772: LD_INT 2
79774: PUSH
79775: LD_INT 3
79777: PUSH
79778: EMPTY
79779: LIST
79780: LIST
79781: PUSH
79782: LD_INT 2
79784: PUSH
79785: LD_INT 2
79787: PUSH
79788: EMPTY
79789: LIST
79790: LIST
79791: PUSH
79792: LD_INT 4
79794: PUSH
79795: LD_INT 2
79797: PUSH
79798: EMPTY
79799: LIST
79800: LIST
79801: PUSH
79802: LD_INT 2
79804: PUSH
79805: LD_INT 4
79807: PUSH
79808: EMPTY
79809: LIST
79810: LIST
79811: PUSH
79812: LD_INT 0
79814: PUSH
79815: LD_INT 4
79817: PUSH
79818: EMPTY
79819: LIST
79820: LIST
79821: PUSH
79822: LD_INT 0
79824: PUSH
79825: LD_INT 3
79827: PUSH
79828: EMPTY
79829: LIST
79830: LIST
79831: PUSH
79832: LD_INT 1
79834: PUSH
79835: LD_INT 4
79837: PUSH
79838: EMPTY
79839: LIST
79840: LIST
79841: PUSH
79842: LD_INT 1
79844: PUSH
79845: LD_INT 5
79847: PUSH
79848: EMPTY
79849: LIST
79850: LIST
79851: PUSH
79852: LD_INT 0
79854: PUSH
79855: LD_INT 5
79857: PUSH
79858: EMPTY
79859: LIST
79860: LIST
79861: PUSH
79862: LD_INT 1
79864: NEG
79865: PUSH
79866: LD_INT 4
79868: PUSH
79869: EMPTY
79870: LIST
79871: LIST
79872: PUSH
79873: LD_INT 1
79875: NEG
79876: PUSH
79877: LD_INT 3
79879: PUSH
79880: EMPTY
79881: LIST
79882: LIST
79883: PUSH
79884: LD_INT 2
79886: PUSH
79887: LD_INT 5
79889: PUSH
79890: EMPTY
79891: LIST
79892: LIST
79893: PUSH
79894: LD_INT 2
79896: NEG
79897: PUSH
79898: LD_INT 3
79900: PUSH
79901: EMPTY
79902: LIST
79903: LIST
79904: PUSH
79905: EMPTY
79906: LIST
79907: LIST
79908: LIST
79909: LIST
79910: LIST
79911: LIST
79912: LIST
79913: LIST
79914: LIST
79915: LIST
79916: LIST
79917: LIST
79918: LIST
79919: LIST
79920: LIST
79921: LIST
79922: LIST
79923: LIST
79924: LIST
79925: LIST
79926: LIST
79927: LIST
79928: LIST
79929: LIST
79930: LIST
79931: LIST
79932: LIST
79933: LIST
79934: LIST
79935: LIST
79936: LIST
79937: LIST
79938: LIST
79939: LIST
79940: LIST
79941: LIST
79942: LIST
79943: LIST
79944: LIST
79945: LIST
79946: LIST
79947: LIST
79948: LIST
79949: LIST
79950: LIST
79951: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
79952: LD_ADDR_VAR 0 34
79956: PUSH
79957: LD_INT 0
79959: PUSH
79960: LD_INT 4
79962: NEG
79963: PUSH
79964: EMPTY
79965: LIST
79966: LIST
79967: PUSH
79968: LD_INT 0
79970: PUSH
79971: LD_INT 5
79973: NEG
79974: PUSH
79975: EMPTY
79976: LIST
79977: LIST
79978: PUSH
79979: LD_INT 1
79981: PUSH
79982: LD_INT 4
79984: NEG
79985: PUSH
79986: EMPTY
79987: LIST
79988: LIST
79989: PUSH
79990: LD_INT 1
79992: PUSH
79993: LD_INT 3
79995: NEG
79996: PUSH
79997: EMPTY
79998: LIST
79999: LIST
80000: PUSH
80001: LD_INT 0
80003: PUSH
80004: LD_INT 3
80006: NEG
80007: PUSH
80008: EMPTY
80009: LIST
80010: LIST
80011: PUSH
80012: LD_INT 1
80014: NEG
80015: PUSH
80016: LD_INT 4
80018: NEG
80019: PUSH
80020: EMPTY
80021: LIST
80022: LIST
80023: PUSH
80024: LD_INT 1
80026: NEG
80027: PUSH
80028: LD_INT 5
80030: NEG
80031: PUSH
80032: EMPTY
80033: LIST
80034: LIST
80035: PUSH
80036: LD_INT 2
80038: PUSH
80039: LD_INT 3
80041: NEG
80042: PUSH
80043: EMPTY
80044: LIST
80045: LIST
80046: PUSH
80047: LD_INT 2
80049: NEG
80050: PUSH
80051: LD_INT 5
80053: NEG
80054: PUSH
80055: EMPTY
80056: LIST
80057: LIST
80058: PUSH
80059: LD_INT 3
80061: PUSH
80062: LD_INT 0
80064: PUSH
80065: EMPTY
80066: LIST
80067: LIST
80068: PUSH
80069: LD_INT 3
80071: PUSH
80072: LD_INT 1
80074: NEG
80075: PUSH
80076: EMPTY
80077: LIST
80078: LIST
80079: PUSH
80080: LD_INT 4
80082: PUSH
80083: LD_INT 0
80085: PUSH
80086: EMPTY
80087: LIST
80088: LIST
80089: PUSH
80090: LD_INT 4
80092: PUSH
80093: LD_INT 1
80095: PUSH
80096: EMPTY
80097: LIST
80098: LIST
80099: PUSH
80100: LD_INT 3
80102: PUSH
80103: LD_INT 1
80105: PUSH
80106: EMPTY
80107: LIST
80108: LIST
80109: PUSH
80110: LD_INT 2
80112: PUSH
80113: LD_INT 0
80115: PUSH
80116: EMPTY
80117: LIST
80118: LIST
80119: PUSH
80120: LD_INT 2
80122: PUSH
80123: LD_INT 1
80125: NEG
80126: PUSH
80127: EMPTY
80128: LIST
80129: LIST
80130: PUSH
80131: LD_INT 2
80133: PUSH
80134: LD_INT 2
80136: NEG
80137: PUSH
80138: EMPTY
80139: LIST
80140: LIST
80141: PUSH
80142: LD_INT 4
80144: PUSH
80145: LD_INT 2
80147: PUSH
80148: EMPTY
80149: LIST
80150: LIST
80151: PUSH
80152: LD_INT 4
80154: PUSH
80155: LD_INT 4
80157: PUSH
80158: EMPTY
80159: LIST
80160: LIST
80161: PUSH
80162: LD_INT 4
80164: PUSH
80165: LD_INT 3
80167: PUSH
80168: EMPTY
80169: LIST
80170: LIST
80171: PUSH
80172: LD_INT 5
80174: PUSH
80175: LD_INT 4
80177: PUSH
80178: EMPTY
80179: LIST
80180: LIST
80181: PUSH
80182: LD_INT 5
80184: PUSH
80185: LD_INT 5
80187: PUSH
80188: EMPTY
80189: LIST
80190: LIST
80191: PUSH
80192: LD_INT 4
80194: PUSH
80195: LD_INT 5
80197: PUSH
80198: EMPTY
80199: LIST
80200: LIST
80201: PUSH
80202: LD_INT 3
80204: PUSH
80205: LD_INT 4
80207: PUSH
80208: EMPTY
80209: LIST
80210: LIST
80211: PUSH
80212: LD_INT 3
80214: PUSH
80215: LD_INT 3
80217: PUSH
80218: EMPTY
80219: LIST
80220: LIST
80221: PUSH
80222: LD_INT 5
80224: PUSH
80225: LD_INT 3
80227: PUSH
80228: EMPTY
80229: LIST
80230: LIST
80231: PUSH
80232: LD_INT 3
80234: PUSH
80235: LD_INT 5
80237: PUSH
80238: EMPTY
80239: LIST
80240: LIST
80241: PUSH
80242: LD_INT 0
80244: PUSH
80245: LD_INT 3
80247: PUSH
80248: EMPTY
80249: LIST
80250: LIST
80251: PUSH
80252: LD_INT 0
80254: PUSH
80255: LD_INT 2
80257: PUSH
80258: EMPTY
80259: LIST
80260: LIST
80261: PUSH
80262: LD_INT 1
80264: PUSH
80265: LD_INT 3
80267: PUSH
80268: EMPTY
80269: LIST
80270: LIST
80271: PUSH
80272: LD_INT 1
80274: PUSH
80275: LD_INT 4
80277: PUSH
80278: EMPTY
80279: LIST
80280: LIST
80281: PUSH
80282: LD_INT 0
80284: PUSH
80285: LD_INT 4
80287: PUSH
80288: EMPTY
80289: LIST
80290: LIST
80291: PUSH
80292: LD_INT 1
80294: NEG
80295: PUSH
80296: LD_INT 3
80298: PUSH
80299: EMPTY
80300: LIST
80301: LIST
80302: PUSH
80303: LD_INT 1
80305: NEG
80306: PUSH
80307: LD_INT 2
80309: PUSH
80310: EMPTY
80311: LIST
80312: LIST
80313: PUSH
80314: LD_INT 2
80316: PUSH
80317: LD_INT 4
80319: PUSH
80320: EMPTY
80321: LIST
80322: LIST
80323: PUSH
80324: LD_INT 2
80326: NEG
80327: PUSH
80328: LD_INT 2
80330: PUSH
80331: EMPTY
80332: LIST
80333: LIST
80334: PUSH
80335: LD_INT 4
80337: NEG
80338: PUSH
80339: LD_INT 0
80341: PUSH
80342: EMPTY
80343: LIST
80344: LIST
80345: PUSH
80346: LD_INT 4
80348: NEG
80349: PUSH
80350: LD_INT 1
80352: NEG
80353: PUSH
80354: EMPTY
80355: LIST
80356: LIST
80357: PUSH
80358: LD_INT 3
80360: NEG
80361: PUSH
80362: LD_INT 0
80364: PUSH
80365: EMPTY
80366: LIST
80367: LIST
80368: PUSH
80369: LD_INT 3
80371: NEG
80372: PUSH
80373: LD_INT 1
80375: PUSH
80376: EMPTY
80377: LIST
80378: LIST
80379: PUSH
80380: LD_INT 4
80382: NEG
80383: PUSH
80384: LD_INT 1
80386: PUSH
80387: EMPTY
80388: LIST
80389: LIST
80390: PUSH
80391: LD_INT 5
80393: NEG
80394: PUSH
80395: LD_INT 0
80397: PUSH
80398: EMPTY
80399: LIST
80400: LIST
80401: PUSH
80402: LD_INT 5
80404: NEG
80405: PUSH
80406: LD_INT 1
80408: NEG
80409: PUSH
80410: EMPTY
80411: LIST
80412: LIST
80413: PUSH
80414: LD_INT 5
80416: NEG
80417: PUSH
80418: LD_INT 2
80420: NEG
80421: PUSH
80422: EMPTY
80423: LIST
80424: LIST
80425: PUSH
80426: LD_INT 3
80428: NEG
80429: PUSH
80430: LD_INT 2
80432: PUSH
80433: EMPTY
80434: LIST
80435: LIST
80436: PUSH
80437: EMPTY
80438: LIST
80439: LIST
80440: LIST
80441: LIST
80442: LIST
80443: LIST
80444: LIST
80445: LIST
80446: LIST
80447: LIST
80448: LIST
80449: LIST
80450: LIST
80451: LIST
80452: LIST
80453: LIST
80454: LIST
80455: LIST
80456: LIST
80457: LIST
80458: LIST
80459: LIST
80460: LIST
80461: LIST
80462: LIST
80463: LIST
80464: LIST
80465: LIST
80466: LIST
80467: LIST
80468: LIST
80469: LIST
80470: LIST
80471: LIST
80472: LIST
80473: LIST
80474: LIST
80475: LIST
80476: LIST
80477: LIST
80478: LIST
80479: LIST
80480: LIST
80481: LIST
80482: LIST
80483: ST_TO_ADDR
// end ; end ;
80484: GO 80487
80486: POP
// case btype of b_depot , b_warehouse :
80487: LD_VAR 0 1
80491: PUSH
80492: LD_INT 0
80494: DOUBLE
80495: EQUAL
80496: IFTRUE 80506
80498: LD_INT 1
80500: DOUBLE
80501: EQUAL
80502: IFTRUE 80506
80504: GO 80707
80506: POP
// case nation of nation_american :
80507: LD_VAR 0 5
80511: PUSH
80512: LD_INT 1
80514: DOUBLE
80515: EQUAL
80516: IFTRUE 80520
80518: GO 80576
80520: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
80521: LD_ADDR_VAR 0 9
80525: PUSH
80526: LD_VAR 0 11
80530: PUSH
80531: LD_VAR 0 12
80535: PUSH
80536: LD_VAR 0 13
80540: PUSH
80541: LD_VAR 0 14
80545: PUSH
80546: LD_VAR 0 15
80550: PUSH
80551: LD_VAR 0 16
80555: PUSH
80556: EMPTY
80557: LIST
80558: LIST
80559: LIST
80560: LIST
80561: LIST
80562: LIST
80563: PUSH
80564: LD_VAR 0 4
80568: PUSH
80569: LD_INT 1
80571: PLUS
80572: ARRAY
80573: ST_TO_ADDR
80574: GO 80705
80576: LD_INT 2
80578: DOUBLE
80579: EQUAL
80580: IFTRUE 80584
80582: GO 80640
80584: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
80585: LD_ADDR_VAR 0 9
80589: PUSH
80590: LD_VAR 0 17
80594: PUSH
80595: LD_VAR 0 18
80599: PUSH
80600: LD_VAR 0 19
80604: PUSH
80605: LD_VAR 0 20
80609: PUSH
80610: LD_VAR 0 21
80614: PUSH
80615: LD_VAR 0 22
80619: PUSH
80620: EMPTY
80621: LIST
80622: LIST
80623: LIST
80624: LIST
80625: LIST
80626: LIST
80627: PUSH
80628: LD_VAR 0 4
80632: PUSH
80633: LD_INT 1
80635: PLUS
80636: ARRAY
80637: ST_TO_ADDR
80638: GO 80705
80640: LD_INT 3
80642: DOUBLE
80643: EQUAL
80644: IFTRUE 80648
80646: GO 80704
80648: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
80649: LD_ADDR_VAR 0 9
80653: PUSH
80654: LD_VAR 0 23
80658: PUSH
80659: LD_VAR 0 24
80663: PUSH
80664: LD_VAR 0 25
80668: PUSH
80669: LD_VAR 0 26
80673: PUSH
80674: LD_VAR 0 27
80678: PUSH
80679: LD_VAR 0 28
80683: PUSH
80684: EMPTY
80685: LIST
80686: LIST
80687: LIST
80688: LIST
80689: LIST
80690: LIST
80691: PUSH
80692: LD_VAR 0 4
80696: PUSH
80697: LD_INT 1
80699: PLUS
80700: ARRAY
80701: ST_TO_ADDR
80702: GO 80705
80704: POP
80705: GO 81260
80707: LD_INT 2
80709: DOUBLE
80710: EQUAL
80711: IFTRUE 80721
80713: LD_INT 3
80715: DOUBLE
80716: EQUAL
80717: IFTRUE 80721
80719: GO 80777
80721: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
80722: LD_ADDR_VAR 0 9
80726: PUSH
80727: LD_VAR 0 29
80731: PUSH
80732: LD_VAR 0 30
80736: PUSH
80737: LD_VAR 0 31
80741: PUSH
80742: LD_VAR 0 32
80746: PUSH
80747: LD_VAR 0 33
80751: PUSH
80752: LD_VAR 0 34
80756: PUSH
80757: EMPTY
80758: LIST
80759: LIST
80760: LIST
80761: LIST
80762: LIST
80763: LIST
80764: PUSH
80765: LD_VAR 0 4
80769: PUSH
80770: LD_INT 1
80772: PLUS
80773: ARRAY
80774: ST_TO_ADDR
80775: GO 81260
80777: LD_INT 16
80779: DOUBLE
80780: EQUAL
80781: IFTRUE 80839
80783: LD_INT 17
80785: DOUBLE
80786: EQUAL
80787: IFTRUE 80839
80789: LD_INT 18
80791: DOUBLE
80792: EQUAL
80793: IFTRUE 80839
80795: LD_INT 19
80797: DOUBLE
80798: EQUAL
80799: IFTRUE 80839
80801: LD_INT 22
80803: DOUBLE
80804: EQUAL
80805: IFTRUE 80839
80807: LD_INT 20
80809: DOUBLE
80810: EQUAL
80811: IFTRUE 80839
80813: LD_INT 21
80815: DOUBLE
80816: EQUAL
80817: IFTRUE 80839
80819: LD_INT 23
80821: DOUBLE
80822: EQUAL
80823: IFTRUE 80839
80825: LD_INT 24
80827: DOUBLE
80828: EQUAL
80829: IFTRUE 80839
80831: LD_INT 25
80833: DOUBLE
80834: EQUAL
80835: IFTRUE 80839
80837: GO 80895
80839: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
80840: LD_ADDR_VAR 0 9
80844: PUSH
80845: LD_VAR 0 35
80849: PUSH
80850: LD_VAR 0 36
80854: PUSH
80855: LD_VAR 0 37
80859: PUSH
80860: LD_VAR 0 38
80864: PUSH
80865: LD_VAR 0 39
80869: PUSH
80870: LD_VAR 0 40
80874: PUSH
80875: EMPTY
80876: LIST
80877: LIST
80878: LIST
80879: LIST
80880: LIST
80881: LIST
80882: PUSH
80883: LD_VAR 0 4
80887: PUSH
80888: LD_INT 1
80890: PLUS
80891: ARRAY
80892: ST_TO_ADDR
80893: GO 81260
80895: LD_INT 6
80897: DOUBLE
80898: EQUAL
80899: IFTRUE 80951
80901: LD_INT 7
80903: DOUBLE
80904: EQUAL
80905: IFTRUE 80951
80907: LD_INT 8
80909: DOUBLE
80910: EQUAL
80911: IFTRUE 80951
80913: LD_INT 13
80915: DOUBLE
80916: EQUAL
80917: IFTRUE 80951
80919: LD_INT 12
80921: DOUBLE
80922: EQUAL
80923: IFTRUE 80951
80925: LD_INT 15
80927: DOUBLE
80928: EQUAL
80929: IFTRUE 80951
80931: LD_INT 11
80933: DOUBLE
80934: EQUAL
80935: IFTRUE 80951
80937: LD_INT 14
80939: DOUBLE
80940: EQUAL
80941: IFTRUE 80951
80943: LD_INT 10
80945: DOUBLE
80946: EQUAL
80947: IFTRUE 80951
80949: GO 81007
80951: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
80952: LD_ADDR_VAR 0 9
80956: PUSH
80957: LD_VAR 0 41
80961: PUSH
80962: LD_VAR 0 42
80966: PUSH
80967: LD_VAR 0 43
80971: PUSH
80972: LD_VAR 0 44
80976: PUSH
80977: LD_VAR 0 45
80981: PUSH
80982: LD_VAR 0 46
80986: PUSH
80987: EMPTY
80988: LIST
80989: LIST
80990: LIST
80991: LIST
80992: LIST
80993: LIST
80994: PUSH
80995: LD_VAR 0 4
80999: PUSH
81000: LD_INT 1
81002: PLUS
81003: ARRAY
81004: ST_TO_ADDR
81005: GO 81260
81007: LD_INT 36
81009: DOUBLE
81010: EQUAL
81011: IFTRUE 81015
81013: GO 81071
81015: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
81016: LD_ADDR_VAR 0 9
81020: PUSH
81021: LD_VAR 0 47
81025: PUSH
81026: LD_VAR 0 48
81030: PUSH
81031: LD_VAR 0 49
81035: PUSH
81036: LD_VAR 0 50
81040: PUSH
81041: LD_VAR 0 51
81045: PUSH
81046: LD_VAR 0 52
81050: PUSH
81051: EMPTY
81052: LIST
81053: LIST
81054: LIST
81055: LIST
81056: LIST
81057: LIST
81058: PUSH
81059: LD_VAR 0 4
81063: PUSH
81064: LD_INT 1
81066: PLUS
81067: ARRAY
81068: ST_TO_ADDR
81069: GO 81260
81071: LD_INT 4
81073: DOUBLE
81074: EQUAL
81075: IFTRUE 81097
81077: LD_INT 5
81079: DOUBLE
81080: EQUAL
81081: IFTRUE 81097
81083: LD_INT 34
81085: DOUBLE
81086: EQUAL
81087: IFTRUE 81097
81089: LD_INT 37
81091: DOUBLE
81092: EQUAL
81093: IFTRUE 81097
81095: GO 81153
81097: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
81098: LD_ADDR_VAR 0 9
81102: PUSH
81103: LD_VAR 0 53
81107: PUSH
81108: LD_VAR 0 54
81112: PUSH
81113: LD_VAR 0 55
81117: PUSH
81118: LD_VAR 0 56
81122: PUSH
81123: LD_VAR 0 57
81127: PUSH
81128: LD_VAR 0 58
81132: PUSH
81133: EMPTY
81134: LIST
81135: LIST
81136: LIST
81137: LIST
81138: LIST
81139: LIST
81140: PUSH
81141: LD_VAR 0 4
81145: PUSH
81146: LD_INT 1
81148: PLUS
81149: ARRAY
81150: ST_TO_ADDR
81151: GO 81260
81153: LD_INT 31
81155: DOUBLE
81156: EQUAL
81157: IFTRUE 81203
81159: LD_INT 32
81161: DOUBLE
81162: EQUAL
81163: IFTRUE 81203
81165: LD_INT 33
81167: DOUBLE
81168: EQUAL
81169: IFTRUE 81203
81171: LD_INT 27
81173: DOUBLE
81174: EQUAL
81175: IFTRUE 81203
81177: LD_INT 26
81179: DOUBLE
81180: EQUAL
81181: IFTRUE 81203
81183: LD_INT 28
81185: DOUBLE
81186: EQUAL
81187: IFTRUE 81203
81189: LD_INT 29
81191: DOUBLE
81192: EQUAL
81193: IFTRUE 81203
81195: LD_INT 30
81197: DOUBLE
81198: EQUAL
81199: IFTRUE 81203
81201: GO 81259
81203: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
81204: LD_ADDR_VAR 0 9
81208: PUSH
81209: LD_VAR 0 59
81213: PUSH
81214: LD_VAR 0 60
81218: PUSH
81219: LD_VAR 0 61
81223: PUSH
81224: LD_VAR 0 62
81228: PUSH
81229: LD_VAR 0 63
81233: PUSH
81234: LD_VAR 0 64
81238: PUSH
81239: EMPTY
81240: LIST
81241: LIST
81242: LIST
81243: LIST
81244: LIST
81245: LIST
81246: PUSH
81247: LD_VAR 0 4
81251: PUSH
81252: LD_INT 1
81254: PLUS
81255: ARRAY
81256: ST_TO_ADDR
81257: GO 81260
81259: POP
// temp_list2 = [ ] ;
81260: LD_ADDR_VAR 0 10
81264: PUSH
81265: EMPTY
81266: ST_TO_ADDR
// for i in temp_list do
81267: LD_ADDR_VAR 0 8
81271: PUSH
81272: LD_VAR 0 9
81276: PUSH
81277: FOR_IN
81278: IFFALSE 81330
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
81280: LD_ADDR_VAR 0 10
81284: PUSH
81285: LD_VAR 0 10
81289: PUSH
81290: LD_VAR 0 8
81294: PUSH
81295: LD_INT 1
81297: ARRAY
81298: PUSH
81299: LD_VAR 0 2
81303: PLUS
81304: PUSH
81305: LD_VAR 0 8
81309: PUSH
81310: LD_INT 2
81312: ARRAY
81313: PUSH
81314: LD_VAR 0 3
81318: PLUS
81319: PUSH
81320: EMPTY
81321: LIST
81322: LIST
81323: PUSH
81324: EMPTY
81325: LIST
81326: ADD
81327: ST_TO_ADDR
81328: GO 81277
81330: POP
81331: POP
// result = temp_list2 ;
81332: LD_ADDR_VAR 0 7
81336: PUSH
81337: LD_VAR 0 10
81341: ST_TO_ADDR
// end ;
81342: LD_VAR 0 7
81346: RET
// export function EnemyInRange ( unit , dist ) ; begin
81347: LD_INT 0
81349: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
81350: LD_ADDR_VAR 0 3
81354: PUSH
81355: LD_VAR 0 1
81359: PPUSH
81360: CALL_OW 255
81364: PPUSH
81365: LD_VAR 0 1
81369: PPUSH
81370: CALL_OW 250
81374: PPUSH
81375: LD_VAR 0 1
81379: PPUSH
81380: CALL_OW 251
81384: PPUSH
81385: LD_VAR 0 2
81389: PPUSH
81390: CALL 55451 0 4
81394: PUSH
81395: LD_INT 4
81397: ARRAY
81398: ST_TO_ADDR
// end ;
81399: LD_VAR 0 3
81403: RET
// export function PlayerSeeMe ( unit ) ; begin
81404: LD_INT 0
81406: PPUSH
// result := See ( your_side , unit ) ;
81407: LD_ADDR_VAR 0 2
81411: PUSH
81412: LD_OWVAR 2
81416: PPUSH
81417: LD_VAR 0 1
81421: PPUSH
81422: CALL_OW 292
81426: ST_TO_ADDR
// end ;
81427: LD_VAR 0 2
81431: RET
// export function ReverseDir ( unit ) ; begin
81432: LD_INT 0
81434: PPUSH
// if not unit then
81435: LD_VAR 0 1
81439: NOT
81440: IFFALSE 81444
// exit ;
81442: GO 81467
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
81444: LD_ADDR_VAR 0 2
81448: PUSH
81449: LD_VAR 0 1
81453: PPUSH
81454: CALL_OW 254
81458: PUSH
81459: LD_INT 3
81461: PLUS
81462: PUSH
81463: LD_INT 6
81465: MOD
81466: ST_TO_ADDR
// end ;
81467: LD_VAR 0 2
81471: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
81472: LD_INT 0
81474: PPUSH
81475: PPUSH
81476: PPUSH
81477: PPUSH
81478: PPUSH
// if not hexes then
81479: LD_VAR 0 2
81483: NOT
81484: IFFALSE 81488
// exit ;
81486: GO 81636
// dist := 9999 ;
81488: LD_ADDR_VAR 0 5
81492: PUSH
81493: LD_INT 9999
81495: ST_TO_ADDR
// for i = 1 to hexes do
81496: LD_ADDR_VAR 0 4
81500: PUSH
81501: DOUBLE
81502: LD_INT 1
81504: DEC
81505: ST_TO_ADDR
81506: LD_VAR 0 2
81510: PUSH
81511: FOR_TO
81512: IFFALSE 81624
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
81514: LD_VAR 0 1
81518: PPUSH
81519: LD_VAR 0 2
81523: PUSH
81524: LD_VAR 0 4
81528: ARRAY
81529: PUSH
81530: LD_INT 1
81532: ARRAY
81533: PPUSH
81534: LD_VAR 0 2
81538: PUSH
81539: LD_VAR 0 4
81543: ARRAY
81544: PUSH
81545: LD_INT 2
81547: ARRAY
81548: PPUSH
81549: CALL_OW 297
81553: PUSH
81554: LD_VAR 0 5
81558: LESS
81559: IFFALSE 81622
// begin hex := hexes [ i ] ;
81561: LD_ADDR_VAR 0 7
81565: PUSH
81566: LD_VAR 0 2
81570: PUSH
81571: LD_VAR 0 4
81575: ARRAY
81576: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
81577: LD_ADDR_VAR 0 5
81581: PUSH
81582: LD_VAR 0 1
81586: PPUSH
81587: LD_VAR 0 2
81591: PUSH
81592: LD_VAR 0 4
81596: ARRAY
81597: PUSH
81598: LD_INT 1
81600: ARRAY
81601: PPUSH
81602: LD_VAR 0 2
81606: PUSH
81607: LD_VAR 0 4
81611: ARRAY
81612: PUSH
81613: LD_INT 2
81615: ARRAY
81616: PPUSH
81617: CALL_OW 297
81621: ST_TO_ADDR
// end ; end ;
81622: GO 81511
81624: POP
81625: POP
// result := hex ;
81626: LD_ADDR_VAR 0 3
81630: PUSH
81631: LD_VAR 0 7
81635: ST_TO_ADDR
// end ;
81636: LD_VAR 0 3
81640: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
81641: LD_INT 0
81643: PPUSH
81644: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
81645: LD_VAR 0 1
81649: NOT
81650: PUSH
81651: LD_VAR 0 1
81655: PUSH
81656: LD_INT 21
81658: PUSH
81659: LD_INT 2
81661: PUSH
81662: EMPTY
81663: LIST
81664: LIST
81665: PUSH
81666: LD_INT 23
81668: PUSH
81669: LD_INT 2
81671: PUSH
81672: EMPTY
81673: LIST
81674: LIST
81675: PUSH
81676: EMPTY
81677: LIST
81678: LIST
81679: PPUSH
81680: CALL_OW 69
81684: IN
81685: NOT
81686: OR
81687: IFFALSE 81691
// exit ;
81689: GO 81738
// for i = 1 to 3 do
81691: LD_ADDR_VAR 0 3
81695: PUSH
81696: DOUBLE
81697: LD_INT 1
81699: DEC
81700: ST_TO_ADDR
81701: LD_INT 3
81703: PUSH
81704: FOR_TO
81705: IFFALSE 81736
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
81707: LD_VAR 0 1
81711: PPUSH
81712: CALL_OW 250
81716: PPUSH
81717: LD_VAR 0 1
81721: PPUSH
81722: CALL_OW 251
81726: PPUSH
81727: LD_INT 1
81729: PPUSH
81730: CALL_OW 453
81734: GO 81704
81736: POP
81737: POP
// end ;
81738: LD_VAR 0 2
81742: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
81743: LD_INT 0
81745: PPUSH
81746: PPUSH
81747: PPUSH
81748: PPUSH
81749: PPUSH
81750: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
81751: LD_VAR 0 1
81755: NOT
81756: PUSH
81757: LD_VAR 0 2
81761: NOT
81762: OR
81763: PUSH
81764: LD_VAR 0 1
81768: PPUSH
81769: CALL_OW 314
81773: OR
81774: IFFALSE 81778
// exit ;
81776: GO 82219
// x := GetX ( enemy_unit ) ;
81778: LD_ADDR_VAR 0 7
81782: PUSH
81783: LD_VAR 0 2
81787: PPUSH
81788: CALL_OW 250
81792: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
81793: LD_ADDR_VAR 0 8
81797: PUSH
81798: LD_VAR 0 2
81802: PPUSH
81803: CALL_OW 251
81807: ST_TO_ADDR
// if not x or not y then
81808: LD_VAR 0 7
81812: NOT
81813: PUSH
81814: LD_VAR 0 8
81818: NOT
81819: OR
81820: IFFALSE 81824
// exit ;
81822: GO 82219
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
81824: LD_ADDR_VAR 0 6
81828: PUSH
81829: LD_VAR 0 7
81833: PPUSH
81834: LD_INT 0
81836: PPUSH
81837: LD_INT 4
81839: PPUSH
81840: CALL_OW 272
81844: PUSH
81845: LD_VAR 0 8
81849: PPUSH
81850: LD_INT 0
81852: PPUSH
81853: LD_INT 4
81855: PPUSH
81856: CALL_OW 273
81860: PUSH
81861: EMPTY
81862: LIST
81863: LIST
81864: PUSH
81865: LD_VAR 0 7
81869: PPUSH
81870: LD_INT 1
81872: PPUSH
81873: LD_INT 4
81875: PPUSH
81876: CALL_OW 272
81880: PUSH
81881: LD_VAR 0 8
81885: PPUSH
81886: LD_INT 1
81888: PPUSH
81889: LD_INT 4
81891: PPUSH
81892: CALL_OW 273
81896: PUSH
81897: EMPTY
81898: LIST
81899: LIST
81900: PUSH
81901: LD_VAR 0 7
81905: PPUSH
81906: LD_INT 2
81908: PPUSH
81909: LD_INT 4
81911: PPUSH
81912: CALL_OW 272
81916: PUSH
81917: LD_VAR 0 8
81921: PPUSH
81922: LD_INT 2
81924: PPUSH
81925: LD_INT 4
81927: PPUSH
81928: CALL_OW 273
81932: PUSH
81933: EMPTY
81934: LIST
81935: LIST
81936: PUSH
81937: LD_VAR 0 7
81941: PPUSH
81942: LD_INT 3
81944: PPUSH
81945: LD_INT 4
81947: PPUSH
81948: CALL_OW 272
81952: PUSH
81953: LD_VAR 0 8
81957: PPUSH
81958: LD_INT 3
81960: PPUSH
81961: LD_INT 4
81963: PPUSH
81964: CALL_OW 273
81968: PUSH
81969: EMPTY
81970: LIST
81971: LIST
81972: PUSH
81973: LD_VAR 0 7
81977: PPUSH
81978: LD_INT 4
81980: PPUSH
81981: LD_INT 4
81983: PPUSH
81984: CALL_OW 272
81988: PUSH
81989: LD_VAR 0 8
81993: PPUSH
81994: LD_INT 4
81996: PPUSH
81997: LD_INT 4
81999: PPUSH
82000: CALL_OW 273
82004: PUSH
82005: EMPTY
82006: LIST
82007: LIST
82008: PUSH
82009: LD_VAR 0 7
82013: PPUSH
82014: LD_INT 5
82016: PPUSH
82017: LD_INT 4
82019: PPUSH
82020: CALL_OW 272
82024: PUSH
82025: LD_VAR 0 8
82029: PPUSH
82030: LD_INT 5
82032: PPUSH
82033: LD_INT 4
82035: PPUSH
82036: CALL_OW 273
82040: PUSH
82041: EMPTY
82042: LIST
82043: LIST
82044: PUSH
82045: EMPTY
82046: LIST
82047: LIST
82048: LIST
82049: LIST
82050: LIST
82051: LIST
82052: ST_TO_ADDR
// for i = tmp downto 1 do
82053: LD_ADDR_VAR 0 4
82057: PUSH
82058: DOUBLE
82059: LD_VAR 0 6
82063: INC
82064: ST_TO_ADDR
82065: LD_INT 1
82067: PUSH
82068: FOR_DOWNTO
82069: IFFALSE 82170
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
82071: LD_VAR 0 6
82075: PUSH
82076: LD_VAR 0 4
82080: ARRAY
82081: PUSH
82082: LD_INT 1
82084: ARRAY
82085: PPUSH
82086: LD_VAR 0 6
82090: PUSH
82091: LD_VAR 0 4
82095: ARRAY
82096: PUSH
82097: LD_INT 2
82099: ARRAY
82100: PPUSH
82101: CALL_OW 488
82105: NOT
82106: PUSH
82107: LD_VAR 0 6
82111: PUSH
82112: LD_VAR 0 4
82116: ARRAY
82117: PUSH
82118: LD_INT 1
82120: ARRAY
82121: PPUSH
82122: LD_VAR 0 6
82126: PUSH
82127: LD_VAR 0 4
82131: ARRAY
82132: PUSH
82133: LD_INT 2
82135: ARRAY
82136: PPUSH
82137: CALL_OW 428
82141: PUSH
82142: LD_INT 0
82144: NONEQUAL
82145: OR
82146: IFFALSE 82168
// tmp := Delete ( tmp , i ) ;
82148: LD_ADDR_VAR 0 6
82152: PUSH
82153: LD_VAR 0 6
82157: PPUSH
82158: LD_VAR 0 4
82162: PPUSH
82163: CALL_OW 3
82167: ST_TO_ADDR
82168: GO 82068
82170: POP
82171: POP
// j := GetClosestHex ( unit , tmp ) ;
82172: LD_ADDR_VAR 0 5
82176: PUSH
82177: LD_VAR 0 1
82181: PPUSH
82182: LD_VAR 0 6
82186: PPUSH
82187: CALL 81472 0 2
82191: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
82192: LD_VAR 0 1
82196: PPUSH
82197: LD_VAR 0 5
82201: PUSH
82202: LD_INT 1
82204: ARRAY
82205: PPUSH
82206: LD_VAR 0 5
82210: PUSH
82211: LD_INT 2
82213: ARRAY
82214: PPUSH
82215: CALL_OW 111
// end ;
82219: LD_VAR 0 3
82223: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
82224: LD_INT 0
82226: PPUSH
82227: PPUSH
82228: PPUSH
// uc_side = 0 ;
82229: LD_ADDR_OWVAR 20
82233: PUSH
82234: LD_INT 0
82236: ST_TO_ADDR
// uc_nation = 0 ;
82237: LD_ADDR_OWVAR 21
82241: PUSH
82242: LD_INT 0
82244: ST_TO_ADDR
// InitHc ;
82245: CALL_OW 19
// InitVc ;
82249: CALL_OW 20
// if mastodonts then
82253: LD_VAR 0 6
82257: IFFALSE 82324
// for i = 1 to mastodonts do
82259: LD_ADDR_VAR 0 11
82263: PUSH
82264: DOUBLE
82265: LD_INT 1
82267: DEC
82268: ST_TO_ADDR
82269: LD_VAR 0 6
82273: PUSH
82274: FOR_TO
82275: IFFALSE 82322
// begin vc_chassis := 31 ;
82277: LD_ADDR_OWVAR 37
82281: PUSH
82282: LD_INT 31
82284: ST_TO_ADDR
// vc_control := control_rider ;
82285: LD_ADDR_OWVAR 38
82289: PUSH
82290: LD_INT 4
82292: ST_TO_ADDR
// animal := CreateVehicle ;
82293: LD_ADDR_VAR 0 12
82297: PUSH
82298: CALL_OW 45
82302: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82303: LD_VAR 0 12
82307: PPUSH
82308: LD_VAR 0 8
82312: PPUSH
82313: LD_INT 0
82315: PPUSH
82316: CALL 89102 0 3
// end ;
82320: GO 82274
82322: POP
82323: POP
// if horses then
82324: LD_VAR 0 5
82328: IFFALSE 82395
// for i = 1 to horses do
82330: LD_ADDR_VAR 0 11
82334: PUSH
82335: DOUBLE
82336: LD_INT 1
82338: DEC
82339: ST_TO_ADDR
82340: LD_VAR 0 5
82344: PUSH
82345: FOR_TO
82346: IFFALSE 82393
// begin hc_class := 21 ;
82348: LD_ADDR_OWVAR 28
82352: PUSH
82353: LD_INT 21
82355: ST_TO_ADDR
// hc_gallery :=  ;
82356: LD_ADDR_OWVAR 33
82360: PUSH
82361: LD_STRING 
82363: ST_TO_ADDR
// animal := CreateHuman ;
82364: LD_ADDR_VAR 0 12
82368: PUSH
82369: CALL_OW 44
82373: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82374: LD_VAR 0 12
82378: PPUSH
82379: LD_VAR 0 8
82383: PPUSH
82384: LD_INT 0
82386: PPUSH
82387: CALL 89102 0 3
// end ;
82391: GO 82345
82393: POP
82394: POP
// if birds then
82395: LD_VAR 0 1
82399: IFFALSE 82466
// for i = 1 to birds do
82401: LD_ADDR_VAR 0 11
82405: PUSH
82406: DOUBLE
82407: LD_INT 1
82409: DEC
82410: ST_TO_ADDR
82411: LD_VAR 0 1
82415: PUSH
82416: FOR_TO
82417: IFFALSE 82464
// begin hc_class = 18 ;
82419: LD_ADDR_OWVAR 28
82423: PUSH
82424: LD_INT 18
82426: ST_TO_ADDR
// hc_gallery =  ;
82427: LD_ADDR_OWVAR 33
82431: PUSH
82432: LD_STRING 
82434: ST_TO_ADDR
// animal := CreateHuman ;
82435: LD_ADDR_VAR 0 12
82439: PUSH
82440: CALL_OW 44
82444: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82445: LD_VAR 0 12
82449: PPUSH
82450: LD_VAR 0 8
82454: PPUSH
82455: LD_INT 0
82457: PPUSH
82458: CALL 89102 0 3
// end ;
82462: GO 82416
82464: POP
82465: POP
// if tigers then
82466: LD_VAR 0 2
82470: IFFALSE 82554
// for i = 1 to tigers do
82472: LD_ADDR_VAR 0 11
82476: PUSH
82477: DOUBLE
82478: LD_INT 1
82480: DEC
82481: ST_TO_ADDR
82482: LD_VAR 0 2
82486: PUSH
82487: FOR_TO
82488: IFFALSE 82552
// begin hc_class = class_tiger ;
82490: LD_ADDR_OWVAR 28
82494: PUSH
82495: LD_INT 14
82497: ST_TO_ADDR
// hc_gallery =  ;
82498: LD_ADDR_OWVAR 33
82502: PUSH
82503: LD_STRING 
82505: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
82506: LD_ADDR_OWVAR 35
82510: PUSH
82511: LD_INT 7
82513: NEG
82514: PPUSH
82515: LD_INT 7
82517: PPUSH
82518: CALL_OW 12
82522: ST_TO_ADDR
// animal := CreateHuman ;
82523: LD_ADDR_VAR 0 12
82527: PUSH
82528: CALL_OW 44
82532: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82533: LD_VAR 0 12
82537: PPUSH
82538: LD_VAR 0 8
82542: PPUSH
82543: LD_INT 0
82545: PPUSH
82546: CALL 89102 0 3
// end ;
82550: GO 82487
82552: POP
82553: POP
// if apemans then
82554: LD_VAR 0 3
82558: IFFALSE 82681
// for i = 1 to apemans do
82560: LD_ADDR_VAR 0 11
82564: PUSH
82565: DOUBLE
82566: LD_INT 1
82568: DEC
82569: ST_TO_ADDR
82570: LD_VAR 0 3
82574: PUSH
82575: FOR_TO
82576: IFFALSE 82679
// begin hc_class = class_apeman ;
82578: LD_ADDR_OWVAR 28
82582: PUSH
82583: LD_INT 12
82585: ST_TO_ADDR
// hc_gallery =  ;
82586: LD_ADDR_OWVAR 33
82590: PUSH
82591: LD_STRING 
82593: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
82594: LD_ADDR_OWVAR 35
82598: PUSH
82599: LD_INT 5
82601: NEG
82602: PPUSH
82603: LD_INT 5
82605: PPUSH
82606: CALL_OW 12
82610: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
82611: LD_ADDR_OWVAR 31
82615: PUSH
82616: LD_INT 1
82618: PPUSH
82619: LD_INT 3
82621: PPUSH
82622: CALL_OW 12
82626: PUSH
82627: LD_INT 1
82629: PPUSH
82630: LD_INT 3
82632: PPUSH
82633: CALL_OW 12
82637: PUSH
82638: LD_INT 0
82640: PUSH
82641: LD_INT 0
82643: PUSH
82644: EMPTY
82645: LIST
82646: LIST
82647: LIST
82648: LIST
82649: ST_TO_ADDR
// animal := CreateHuman ;
82650: LD_ADDR_VAR 0 12
82654: PUSH
82655: CALL_OW 44
82659: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82660: LD_VAR 0 12
82664: PPUSH
82665: LD_VAR 0 8
82669: PPUSH
82670: LD_INT 0
82672: PPUSH
82673: CALL 89102 0 3
// end ;
82677: GO 82575
82679: POP
82680: POP
// if enchidnas then
82681: LD_VAR 0 4
82685: IFFALSE 82752
// for i = 1 to enchidnas do
82687: LD_ADDR_VAR 0 11
82691: PUSH
82692: DOUBLE
82693: LD_INT 1
82695: DEC
82696: ST_TO_ADDR
82697: LD_VAR 0 4
82701: PUSH
82702: FOR_TO
82703: IFFALSE 82750
// begin hc_class = 13 ;
82705: LD_ADDR_OWVAR 28
82709: PUSH
82710: LD_INT 13
82712: ST_TO_ADDR
// hc_gallery =  ;
82713: LD_ADDR_OWVAR 33
82717: PUSH
82718: LD_STRING 
82720: ST_TO_ADDR
// animal := CreateHuman ;
82721: LD_ADDR_VAR 0 12
82725: PUSH
82726: CALL_OW 44
82730: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82731: LD_VAR 0 12
82735: PPUSH
82736: LD_VAR 0 8
82740: PPUSH
82741: LD_INT 0
82743: PPUSH
82744: CALL 89102 0 3
// end ;
82748: GO 82702
82750: POP
82751: POP
// if fishes then
82752: LD_VAR 0 7
82756: IFFALSE 82823
// for i = 1 to fishes do
82758: LD_ADDR_VAR 0 11
82762: PUSH
82763: DOUBLE
82764: LD_INT 1
82766: DEC
82767: ST_TO_ADDR
82768: LD_VAR 0 7
82772: PUSH
82773: FOR_TO
82774: IFFALSE 82821
// begin hc_class = 20 ;
82776: LD_ADDR_OWVAR 28
82780: PUSH
82781: LD_INT 20
82783: ST_TO_ADDR
// hc_gallery =  ;
82784: LD_ADDR_OWVAR 33
82788: PUSH
82789: LD_STRING 
82791: ST_TO_ADDR
// animal := CreateHuman ;
82792: LD_ADDR_VAR 0 12
82796: PUSH
82797: CALL_OW 44
82801: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
82802: LD_VAR 0 12
82806: PPUSH
82807: LD_VAR 0 9
82811: PPUSH
82812: LD_INT 0
82814: PPUSH
82815: CALL 89102 0 3
// end ;
82819: GO 82773
82821: POP
82822: POP
// end ;
82823: LD_VAR 0 10
82827: RET
// export function WantHeal ( sci , unit ) ; begin
82828: LD_INT 0
82830: PPUSH
// if GetTaskList ( sci ) > 0 then
82831: LD_VAR 0 1
82835: PPUSH
82836: CALL_OW 437
82840: PUSH
82841: LD_INT 0
82843: GREATER
82844: IFFALSE 82914
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
82846: LD_VAR 0 1
82850: PPUSH
82851: CALL_OW 437
82855: PUSH
82856: LD_INT 1
82858: ARRAY
82859: PUSH
82860: LD_INT 1
82862: ARRAY
82863: PUSH
82864: LD_STRING l
82866: EQUAL
82867: PUSH
82868: LD_VAR 0 1
82872: PPUSH
82873: CALL_OW 437
82877: PUSH
82878: LD_INT 1
82880: ARRAY
82881: PUSH
82882: LD_INT 4
82884: ARRAY
82885: PUSH
82886: LD_VAR 0 2
82890: EQUAL
82891: AND
82892: IFFALSE 82904
// result := true else
82894: LD_ADDR_VAR 0 3
82898: PUSH
82899: LD_INT 1
82901: ST_TO_ADDR
82902: GO 82912
// result := false ;
82904: LD_ADDR_VAR 0 3
82908: PUSH
82909: LD_INT 0
82911: ST_TO_ADDR
// end else
82912: GO 82922
// result := false ;
82914: LD_ADDR_VAR 0 3
82918: PUSH
82919: LD_INT 0
82921: ST_TO_ADDR
// end ;
82922: LD_VAR 0 3
82926: RET
// export function HealTarget ( sci ) ; begin
82927: LD_INT 0
82929: PPUSH
// if not sci then
82930: LD_VAR 0 1
82934: NOT
82935: IFFALSE 82939
// exit ;
82937: GO 83004
// result := 0 ;
82939: LD_ADDR_VAR 0 2
82943: PUSH
82944: LD_INT 0
82946: ST_TO_ADDR
// if GetTaskList ( sci ) then
82947: LD_VAR 0 1
82951: PPUSH
82952: CALL_OW 437
82956: IFFALSE 83004
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
82958: LD_VAR 0 1
82962: PPUSH
82963: CALL_OW 437
82967: PUSH
82968: LD_INT 1
82970: ARRAY
82971: PUSH
82972: LD_INT 1
82974: ARRAY
82975: PUSH
82976: LD_STRING l
82978: EQUAL
82979: IFFALSE 83004
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
82981: LD_ADDR_VAR 0 2
82985: PUSH
82986: LD_VAR 0 1
82990: PPUSH
82991: CALL_OW 437
82995: PUSH
82996: LD_INT 1
82998: ARRAY
82999: PUSH
83000: LD_INT 4
83002: ARRAY
83003: ST_TO_ADDR
// end ;
83004: LD_VAR 0 2
83008: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
83009: LD_INT 0
83011: PPUSH
83012: PPUSH
83013: PPUSH
83014: PPUSH
83015: PPUSH
83016: PPUSH
83017: PPUSH
83018: PPUSH
83019: PPUSH
83020: PPUSH
83021: PPUSH
83022: PPUSH
83023: PPUSH
83024: PPUSH
83025: PPUSH
83026: PPUSH
83027: PPUSH
83028: PPUSH
83029: PPUSH
83030: PPUSH
83031: PPUSH
83032: PPUSH
83033: PPUSH
83034: PPUSH
83035: PPUSH
83036: PPUSH
83037: PPUSH
83038: PPUSH
83039: PPUSH
83040: PPUSH
83041: PPUSH
83042: PPUSH
83043: PPUSH
83044: PPUSH
// if not list then
83045: LD_VAR 0 1
83049: NOT
83050: IFFALSE 83054
// exit ;
83052: GO 87713
// base := list [ 1 ] ;
83054: LD_ADDR_VAR 0 3
83058: PUSH
83059: LD_VAR 0 1
83063: PUSH
83064: LD_INT 1
83066: ARRAY
83067: ST_TO_ADDR
// group := list [ 2 ] ;
83068: LD_ADDR_VAR 0 4
83072: PUSH
83073: LD_VAR 0 1
83077: PUSH
83078: LD_INT 2
83080: ARRAY
83081: ST_TO_ADDR
// path := list [ 3 ] ;
83082: LD_ADDR_VAR 0 5
83086: PUSH
83087: LD_VAR 0 1
83091: PUSH
83092: LD_INT 3
83094: ARRAY
83095: ST_TO_ADDR
// flags := list [ 4 ] ;
83096: LD_ADDR_VAR 0 6
83100: PUSH
83101: LD_VAR 0 1
83105: PUSH
83106: LD_INT 4
83108: ARRAY
83109: ST_TO_ADDR
// mined := [ ] ;
83110: LD_ADDR_VAR 0 27
83114: PUSH
83115: EMPTY
83116: ST_TO_ADDR
// bombed := [ ] ;
83117: LD_ADDR_VAR 0 28
83121: PUSH
83122: EMPTY
83123: ST_TO_ADDR
// healers := [ ] ;
83124: LD_ADDR_VAR 0 31
83128: PUSH
83129: EMPTY
83130: ST_TO_ADDR
// to_heal := [ ] ;
83131: LD_ADDR_VAR 0 30
83135: PUSH
83136: EMPTY
83137: ST_TO_ADDR
// repairs := [ ] ;
83138: LD_ADDR_VAR 0 33
83142: PUSH
83143: EMPTY
83144: ST_TO_ADDR
// to_repair := [ ] ;
83145: LD_ADDR_VAR 0 32
83149: PUSH
83150: EMPTY
83151: ST_TO_ADDR
// if not group or not path then
83152: LD_VAR 0 4
83156: NOT
83157: PUSH
83158: LD_VAR 0 5
83162: NOT
83163: OR
83164: IFFALSE 83168
// exit ;
83166: GO 87713
// side := GetSide ( group [ 1 ] ) ;
83168: LD_ADDR_VAR 0 35
83172: PUSH
83173: LD_VAR 0 4
83177: PUSH
83178: LD_INT 1
83180: ARRAY
83181: PPUSH
83182: CALL_OW 255
83186: ST_TO_ADDR
// if flags then
83187: LD_VAR 0 6
83191: IFFALSE 83335
// begin f_ignore_area := flags [ 1 ] ;
83193: LD_ADDR_VAR 0 17
83197: PUSH
83198: LD_VAR 0 6
83202: PUSH
83203: LD_INT 1
83205: ARRAY
83206: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
83207: LD_ADDR_VAR 0 18
83211: PUSH
83212: LD_VAR 0 6
83216: PUSH
83217: LD_INT 2
83219: ARRAY
83220: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
83221: LD_ADDR_VAR 0 19
83225: PUSH
83226: LD_VAR 0 6
83230: PUSH
83231: LD_INT 3
83233: ARRAY
83234: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
83235: LD_ADDR_VAR 0 20
83239: PUSH
83240: LD_VAR 0 6
83244: PUSH
83245: LD_INT 4
83247: ARRAY
83248: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
83249: LD_ADDR_VAR 0 21
83253: PUSH
83254: LD_VAR 0 6
83258: PUSH
83259: LD_INT 5
83261: ARRAY
83262: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
83263: LD_ADDR_VAR 0 22
83267: PUSH
83268: LD_VAR 0 6
83272: PUSH
83273: LD_INT 6
83275: ARRAY
83276: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
83277: LD_ADDR_VAR 0 23
83281: PUSH
83282: LD_VAR 0 6
83286: PUSH
83287: LD_INT 7
83289: ARRAY
83290: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
83291: LD_ADDR_VAR 0 24
83295: PUSH
83296: LD_VAR 0 6
83300: PUSH
83301: LD_INT 8
83303: ARRAY
83304: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
83305: LD_ADDR_VAR 0 25
83309: PUSH
83310: LD_VAR 0 6
83314: PUSH
83315: LD_INT 9
83317: ARRAY
83318: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
83319: LD_ADDR_VAR 0 26
83323: PUSH
83324: LD_VAR 0 6
83328: PUSH
83329: LD_INT 10
83331: ARRAY
83332: ST_TO_ADDR
// end else
83333: GO 83415
// begin f_ignore_area := false ;
83335: LD_ADDR_VAR 0 17
83339: PUSH
83340: LD_INT 0
83342: ST_TO_ADDR
// f_capture := false ;
83343: LD_ADDR_VAR 0 18
83347: PUSH
83348: LD_INT 0
83350: ST_TO_ADDR
// f_ignore_civ := false ;
83351: LD_ADDR_VAR 0 19
83355: PUSH
83356: LD_INT 0
83358: ST_TO_ADDR
// f_murder := false ;
83359: LD_ADDR_VAR 0 20
83363: PUSH
83364: LD_INT 0
83366: ST_TO_ADDR
// f_mines := false ;
83367: LD_ADDR_VAR 0 21
83371: PUSH
83372: LD_INT 0
83374: ST_TO_ADDR
// f_repair := false ;
83375: LD_ADDR_VAR 0 22
83379: PUSH
83380: LD_INT 0
83382: ST_TO_ADDR
// f_heal := false ;
83383: LD_ADDR_VAR 0 23
83387: PUSH
83388: LD_INT 0
83390: ST_TO_ADDR
// f_spacetime := false ;
83391: LD_ADDR_VAR 0 24
83395: PUSH
83396: LD_INT 0
83398: ST_TO_ADDR
// f_attack_depot := false ;
83399: LD_ADDR_VAR 0 25
83403: PUSH
83404: LD_INT 0
83406: ST_TO_ADDR
// f_crawl := false ;
83407: LD_ADDR_VAR 0 26
83411: PUSH
83412: LD_INT 0
83414: ST_TO_ADDR
// end ; if f_heal then
83415: LD_VAR 0 23
83419: IFFALSE 83446
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
83421: LD_ADDR_VAR 0 31
83425: PUSH
83426: LD_VAR 0 4
83430: PPUSH
83431: LD_INT 25
83433: PUSH
83434: LD_INT 4
83436: PUSH
83437: EMPTY
83438: LIST
83439: LIST
83440: PPUSH
83441: CALL_OW 72
83445: ST_TO_ADDR
// if f_repair then
83446: LD_VAR 0 22
83450: IFFALSE 83477
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
83452: LD_ADDR_VAR 0 33
83456: PUSH
83457: LD_VAR 0 4
83461: PPUSH
83462: LD_INT 25
83464: PUSH
83465: LD_INT 3
83467: PUSH
83468: EMPTY
83469: LIST
83470: LIST
83471: PPUSH
83472: CALL_OW 72
83476: ST_TO_ADDR
// units_path := [ ] ;
83477: LD_ADDR_VAR 0 16
83481: PUSH
83482: EMPTY
83483: ST_TO_ADDR
// for i = 1 to group do
83484: LD_ADDR_VAR 0 7
83488: PUSH
83489: DOUBLE
83490: LD_INT 1
83492: DEC
83493: ST_TO_ADDR
83494: LD_VAR 0 4
83498: PUSH
83499: FOR_TO
83500: IFFALSE 83529
// units_path := Replace ( units_path , i , path ) ;
83502: LD_ADDR_VAR 0 16
83506: PUSH
83507: LD_VAR 0 16
83511: PPUSH
83512: LD_VAR 0 7
83516: PPUSH
83517: LD_VAR 0 5
83521: PPUSH
83522: CALL_OW 1
83526: ST_TO_ADDR
83527: GO 83499
83529: POP
83530: POP
// repeat for i = group downto 1 do
83531: LD_ADDR_VAR 0 7
83535: PUSH
83536: DOUBLE
83537: LD_VAR 0 4
83541: INC
83542: ST_TO_ADDR
83543: LD_INT 1
83545: PUSH
83546: FOR_DOWNTO
83547: IFFALSE 87669
// begin wait ( 5 ) ;
83549: LD_INT 5
83551: PPUSH
83552: CALL_OW 67
// tmp := [ ] ;
83556: LD_ADDR_VAR 0 14
83560: PUSH
83561: EMPTY
83562: ST_TO_ADDR
// attacking := false ;
83563: LD_ADDR_VAR 0 29
83567: PUSH
83568: LD_INT 0
83570: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
83571: LD_VAR 0 4
83575: PUSH
83576: LD_VAR 0 7
83580: ARRAY
83581: PPUSH
83582: CALL_OW 301
83586: PUSH
83587: LD_VAR 0 4
83591: PUSH
83592: LD_VAR 0 7
83596: ARRAY
83597: NOT
83598: OR
83599: IFFALSE 83708
// begin if GetType ( group [ i ] ) = unit_human then
83601: LD_VAR 0 4
83605: PUSH
83606: LD_VAR 0 7
83610: ARRAY
83611: PPUSH
83612: CALL_OW 247
83616: PUSH
83617: LD_INT 1
83619: EQUAL
83620: IFFALSE 83666
// begin to_heal := to_heal diff group [ i ] ;
83622: LD_ADDR_VAR 0 30
83626: PUSH
83627: LD_VAR 0 30
83631: PUSH
83632: LD_VAR 0 4
83636: PUSH
83637: LD_VAR 0 7
83641: ARRAY
83642: DIFF
83643: ST_TO_ADDR
// healers := healers diff group [ i ] ;
83644: LD_ADDR_VAR 0 31
83648: PUSH
83649: LD_VAR 0 31
83653: PUSH
83654: LD_VAR 0 4
83658: PUSH
83659: LD_VAR 0 7
83663: ARRAY
83664: DIFF
83665: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
83666: LD_ADDR_VAR 0 4
83670: PUSH
83671: LD_VAR 0 4
83675: PPUSH
83676: LD_VAR 0 7
83680: PPUSH
83681: CALL_OW 3
83685: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
83686: LD_ADDR_VAR 0 16
83690: PUSH
83691: LD_VAR 0 16
83695: PPUSH
83696: LD_VAR 0 7
83700: PPUSH
83701: CALL_OW 3
83705: ST_TO_ADDR
// continue ;
83706: GO 83546
// end ; if f_repair then
83708: LD_VAR 0 22
83712: IFFALSE 84201
// begin if GetType ( group [ i ] ) = unit_vehicle then
83714: LD_VAR 0 4
83718: PUSH
83719: LD_VAR 0 7
83723: ARRAY
83724: PPUSH
83725: CALL_OW 247
83729: PUSH
83730: LD_INT 2
83732: EQUAL
83733: IFFALSE 83923
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
83735: LD_VAR 0 4
83739: PUSH
83740: LD_VAR 0 7
83744: ARRAY
83745: PPUSH
83746: CALL_OW 256
83750: PUSH
83751: LD_INT 700
83753: LESS
83754: PUSH
83755: LD_VAR 0 4
83759: PUSH
83760: LD_VAR 0 7
83764: ARRAY
83765: PUSH
83766: LD_VAR 0 32
83770: IN
83771: NOT
83772: AND
83773: IFFALSE 83797
// to_repair := to_repair union group [ i ] ;
83775: LD_ADDR_VAR 0 32
83779: PUSH
83780: LD_VAR 0 32
83784: PUSH
83785: LD_VAR 0 4
83789: PUSH
83790: LD_VAR 0 7
83794: ARRAY
83795: UNION
83796: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
83797: LD_VAR 0 4
83801: PUSH
83802: LD_VAR 0 7
83806: ARRAY
83807: PPUSH
83808: CALL_OW 256
83812: PUSH
83813: LD_INT 1000
83815: EQUAL
83816: PUSH
83817: LD_VAR 0 4
83821: PUSH
83822: LD_VAR 0 7
83826: ARRAY
83827: PUSH
83828: LD_VAR 0 32
83832: IN
83833: AND
83834: IFFALSE 83858
// to_repair := to_repair diff group [ i ] ;
83836: LD_ADDR_VAR 0 32
83840: PUSH
83841: LD_VAR 0 32
83845: PUSH
83846: LD_VAR 0 4
83850: PUSH
83851: LD_VAR 0 7
83855: ARRAY
83856: DIFF
83857: ST_TO_ADDR
// if group [ i ] in to_repair then
83858: LD_VAR 0 4
83862: PUSH
83863: LD_VAR 0 7
83867: ARRAY
83868: PUSH
83869: LD_VAR 0 32
83873: IN
83874: IFFALSE 83921
// begin if not IsInArea ( group [ i ] , f_repair ) then
83876: LD_VAR 0 4
83880: PUSH
83881: LD_VAR 0 7
83885: ARRAY
83886: PPUSH
83887: LD_VAR 0 22
83891: PPUSH
83892: CALL_OW 308
83896: NOT
83897: IFFALSE 83919
// ComMoveToArea ( group [ i ] , f_repair ) ;
83899: LD_VAR 0 4
83903: PUSH
83904: LD_VAR 0 7
83908: ARRAY
83909: PPUSH
83910: LD_VAR 0 22
83914: PPUSH
83915: CALL_OW 113
// continue ;
83919: GO 83546
// end ; end else
83921: GO 84201
// if group [ i ] in repairs then
83923: LD_VAR 0 4
83927: PUSH
83928: LD_VAR 0 7
83932: ARRAY
83933: PUSH
83934: LD_VAR 0 33
83938: IN
83939: IFFALSE 84201
// begin if IsInUnit ( group [ i ] ) then
83941: LD_VAR 0 4
83945: PUSH
83946: LD_VAR 0 7
83950: ARRAY
83951: PPUSH
83952: CALL_OW 310
83956: IFFALSE 84024
// begin z := IsInUnit ( group [ i ] ) ;
83958: LD_ADDR_VAR 0 13
83962: PUSH
83963: LD_VAR 0 4
83967: PUSH
83968: LD_VAR 0 7
83972: ARRAY
83973: PPUSH
83974: CALL_OW 310
83978: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
83979: LD_VAR 0 13
83983: PUSH
83984: LD_VAR 0 32
83988: IN
83989: PUSH
83990: LD_VAR 0 13
83994: PPUSH
83995: LD_VAR 0 22
83999: PPUSH
84000: CALL_OW 308
84004: AND
84005: IFFALSE 84022
// ComExitVehicle ( group [ i ] ) ;
84007: LD_VAR 0 4
84011: PUSH
84012: LD_VAR 0 7
84016: ARRAY
84017: PPUSH
84018: CALL_OW 121
// end else
84022: GO 84201
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
84024: LD_ADDR_VAR 0 13
84028: PUSH
84029: LD_VAR 0 4
84033: PPUSH
84034: LD_INT 95
84036: PUSH
84037: LD_VAR 0 22
84041: PUSH
84042: EMPTY
84043: LIST
84044: LIST
84045: PUSH
84046: LD_INT 58
84048: PUSH
84049: EMPTY
84050: LIST
84051: PUSH
84052: EMPTY
84053: LIST
84054: LIST
84055: PPUSH
84056: CALL_OW 72
84060: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
84061: LD_VAR 0 4
84065: PUSH
84066: LD_VAR 0 7
84070: ARRAY
84071: PPUSH
84072: CALL_OW 314
84076: NOT
84077: IFFALSE 84199
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
84079: LD_ADDR_VAR 0 10
84083: PUSH
84084: LD_VAR 0 13
84088: PPUSH
84089: LD_VAR 0 4
84093: PUSH
84094: LD_VAR 0 7
84098: ARRAY
84099: PPUSH
84100: CALL_OW 74
84104: ST_TO_ADDR
// if not x then
84105: LD_VAR 0 10
84109: NOT
84110: IFFALSE 84114
// continue ;
84112: GO 83546
// if GetLives ( x ) < 1000 then
84114: LD_VAR 0 10
84118: PPUSH
84119: CALL_OW 256
84123: PUSH
84124: LD_INT 1000
84126: LESS
84127: IFFALSE 84151
// ComRepairVehicle ( group [ i ] , x ) else
84129: LD_VAR 0 4
84133: PUSH
84134: LD_VAR 0 7
84138: ARRAY
84139: PPUSH
84140: LD_VAR 0 10
84144: PPUSH
84145: CALL_OW 129
84149: GO 84199
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
84151: LD_VAR 0 23
84155: PUSH
84156: LD_VAR 0 4
84160: PUSH
84161: LD_VAR 0 7
84165: ARRAY
84166: PPUSH
84167: CALL_OW 256
84171: PUSH
84172: LD_INT 1000
84174: LESS
84175: AND
84176: NOT
84177: IFFALSE 84199
// ComEnterUnit ( group [ i ] , x ) ;
84179: LD_VAR 0 4
84183: PUSH
84184: LD_VAR 0 7
84188: ARRAY
84189: PPUSH
84190: LD_VAR 0 10
84194: PPUSH
84195: CALL_OW 120
// end ; continue ;
84199: GO 83546
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
84201: LD_VAR 0 23
84205: PUSH
84206: LD_VAR 0 4
84210: PUSH
84211: LD_VAR 0 7
84215: ARRAY
84216: PPUSH
84217: CALL_OW 247
84221: PUSH
84222: LD_INT 1
84224: EQUAL
84225: AND
84226: IFFALSE 84704
// begin if group [ i ] in healers then
84228: LD_VAR 0 4
84232: PUSH
84233: LD_VAR 0 7
84237: ARRAY
84238: PUSH
84239: LD_VAR 0 31
84243: IN
84244: IFFALSE 84517
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
84246: LD_VAR 0 4
84250: PUSH
84251: LD_VAR 0 7
84255: ARRAY
84256: PPUSH
84257: LD_VAR 0 23
84261: PPUSH
84262: CALL_OW 308
84266: NOT
84267: PUSH
84268: LD_VAR 0 4
84272: PUSH
84273: LD_VAR 0 7
84277: ARRAY
84278: PPUSH
84279: CALL_OW 314
84283: NOT
84284: AND
84285: IFFALSE 84309
// ComMoveToArea ( group [ i ] , f_heal ) else
84287: LD_VAR 0 4
84291: PUSH
84292: LD_VAR 0 7
84296: ARRAY
84297: PPUSH
84298: LD_VAR 0 23
84302: PPUSH
84303: CALL_OW 113
84307: GO 84515
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
84309: LD_VAR 0 4
84313: PUSH
84314: LD_VAR 0 7
84318: ARRAY
84319: PPUSH
84320: CALL 82927 0 1
84324: PPUSH
84325: CALL_OW 256
84329: PUSH
84330: LD_INT 1000
84332: EQUAL
84333: IFFALSE 84352
// ComStop ( group [ i ] ) else
84335: LD_VAR 0 4
84339: PUSH
84340: LD_VAR 0 7
84344: ARRAY
84345: PPUSH
84346: CALL_OW 141
84350: GO 84515
// if not HasTask ( group [ i ] ) and to_heal then
84352: LD_VAR 0 4
84356: PUSH
84357: LD_VAR 0 7
84361: ARRAY
84362: PPUSH
84363: CALL_OW 314
84367: NOT
84368: PUSH
84369: LD_VAR 0 30
84373: AND
84374: IFFALSE 84515
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
84376: LD_ADDR_VAR 0 13
84380: PUSH
84381: LD_VAR 0 30
84385: PPUSH
84386: LD_INT 3
84388: PUSH
84389: LD_INT 54
84391: PUSH
84392: EMPTY
84393: LIST
84394: PUSH
84395: EMPTY
84396: LIST
84397: LIST
84398: PPUSH
84399: CALL_OW 72
84403: PPUSH
84404: LD_VAR 0 4
84408: PUSH
84409: LD_VAR 0 7
84413: ARRAY
84414: PPUSH
84415: CALL_OW 74
84419: ST_TO_ADDR
// if z then
84420: LD_VAR 0 13
84424: IFFALSE 84515
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
84426: LD_INT 91
84428: PUSH
84429: LD_VAR 0 13
84433: PUSH
84434: LD_INT 10
84436: PUSH
84437: EMPTY
84438: LIST
84439: LIST
84440: LIST
84441: PUSH
84442: LD_INT 81
84444: PUSH
84445: LD_VAR 0 13
84449: PPUSH
84450: CALL_OW 255
84454: PUSH
84455: EMPTY
84456: LIST
84457: LIST
84458: PUSH
84459: EMPTY
84460: LIST
84461: LIST
84462: PPUSH
84463: CALL_OW 69
84467: PUSH
84468: LD_INT 0
84470: EQUAL
84471: IFFALSE 84495
// ComHeal ( group [ i ] , z ) else
84473: LD_VAR 0 4
84477: PUSH
84478: LD_VAR 0 7
84482: ARRAY
84483: PPUSH
84484: LD_VAR 0 13
84488: PPUSH
84489: CALL_OW 128
84493: GO 84515
// ComMoveToArea ( group [ i ] , f_heal ) ;
84495: LD_VAR 0 4
84499: PUSH
84500: LD_VAR 0 7
84504: ARRAY
84505: PPUSH
84506: LD_VAR 0 23
84510: PPUSH
84511: CALL_OW 113
// end ; continue ;
84515: GO 83546
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
84517: LD_VAR 0 4
84521: PUSH
84522: LD_VAR 0 7
84526: ARRAY
84527: PPUSH
84528: CALL_OW 256
84532: PUSH
84533: LD_INT 700
84535: LESS
84536: PUSH
84537: LD_VAR 0 4
84541: PUSH
84542: LD_VAR 0 7
84546: ARRAY
84547: PUSH
84548: LD_VAR 0 30
84552: IN
84553: NOT
84554: AND
84555: IFFALSE 84579
// to_heal := to_heal union group [ i ] ;
84557: LD_ADDR_VAR 0 30
84561: PUSH
84562: LD_VAR 0 30
84566: PUSH
84567: LD_VAR 0 4
84571: PUSH
84572: LD_VAR 0 7
84576: ARRAY
84577: UNION
84578: ST_TO_ADDR
// if group [ i ] in to_heal then
84579: LD_VAR 0 4
84583: PUSH
84584: LD_VAR 0 7
84588: ARRAY
84589: PUSH
84590: LD_VAR 0 30
84594: IN
84595: IFFALSE 84704
// begin if GetLives ( group [ i ] ) = 1000 then
84597: LD_VAR 0 4
84601: PUSH
84602: LD_VAR 0 7
84606: ARRAY
84607: PPUSH
84608: CALL_OW 256
84612: PUSH
84613: LD_INT 1000
84615: EQUAL
84616: IFFALSE 84642
// to_heal := to_heal diff group [ i ] else
84618: LD_ADDR_VAR 0 30
84622: PUSH
84623: LD_VAR 0 30
84627: PUSH
84628: LD_VAR 0 4
84632: PUSH
84633: LD_VAR 0 7
84637: ARRAY
84638: DIFF
84639: ST_TO_ADDR
84640: GO 84704
// begin if not IsInArea ( group [ i ] , to_heal ) then
84642: LD_VAR 0 4
84646: PUSH
84647: LD_VAR 0 7
84651: ARRAY
84652: PPUSH
84653: LD_VAR 0 30
84657: PPUSH
84658: CALL_OW 308
84662: NOT
84663: IFFALSE 84687
// ComMoveToArea ( group [ i ] , f_heal ) else
84665: LD_VAR 0 4
84669: PUSH
84670: LD_VAR 0 7
84674: ARRAY
84675: PPUSH
84676: LD_VAR 0 23
84680: PPUSH
84681: CALL_OW 113
84685: GO 84702
// ComHold ( group [ i ] ) ;
84687: LD_VAR 0 4
84691: PUSH
84692: LD_VAR 0 7
84696: ARRAY
84697: PPUSH
84698: CALL_OW 140
// continue ;
84702: GO 83546
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
84704: LD_VAR 0 4
84708: PUSH
84709: LD_VAR 0 7
84713: ARRAY
84714: PPUSH
84715: LD_INT 10
84717: PPUSH
84718: CALL 81347 0 2
84722: NOT
84723: PUSH
84724: LD_VAR 0 16
84728: PUSH
84729: LD_VAR 0 7
84733: ARRAY
84734: PUSH
84735: EMPTY
84736: EQUAL
84737: NOT
84738: AND
84739: IFFALSE 85005
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
84741: LD_VAR 0 4
84745: PUSH
84746: LD_VAR 0 7
84750: ARRAY
84751: PPUSH
84752: CALL_OW 262
84756: PUSH
84757: LD_INT 1
84759: PUSH
84760: LD_INT 2
84762: PUSH
84763: EMPTY
84764: LIST
84765: LIST
84766: IN
84767: IFFALSE 84808
// if GetFuel ( group [ i ] ) < 10 then
84769: LD_VAR 0 4
84773: PUSH
84774: LD_VAR 0 7
84778: ARRAY
84779: PPUSH
84780: CALL_OW 261
84784: PUSH
84785: LD_INT 10
84787: LESS
84788: IFFALSE 84808
// SetFuel ( group [ i ] , 12 ) ;
84790: LD_VAR 0 4
84794: PUSH
84795: LD_VAR 0 7
84799: ARRAY
84800: PPUSH
84801: LD_INT 12
84803: PPUSH
84804: CALL_OW 240
// if units_path [ i ] then
84808: LD_VAR 0 16
84812: PUSH
84813: LD_VAR 0 7
84817: ARRAY
84818: IFFALSE 85003
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
84820: LD_VAR 0 4
84824: PUSH
84825: LD_VAR 0 7
84829: ARRAY
84830: PPUSH
84831: LD_VAR 0 16
84835: PUSH
84836: LD_VAR 0 7
84840: ARRAY
84841: PUSH
84842: LD_INT 1
84844: ARRAY
84845: PUSH
84846: LD_INT 1
84848: ARRAY
84849: PPUSH
84850: LD_VAR 0 16
84854: PUSH
84855: LD_VAR 0 7
84859: ARRAY
84860: PUSH
84861: LD_INT 1
84863: ARRAY
84864: PUSH
84865: LD_INT 2
84867: ARRAY
84868: PPUSH
84869: CALL_OW 297
84873: PUSH
84874: LD_INT 6
84876: GREATER
84877: IFFALSE 84952
// begin if not HasTask ( group [ i ] ) then
84879: LD_VAR 0 4
84883: PUSH
84884: LD_VAR 0 7
84888: ARRAY
84889: PPUSH
84890: CALL_OW 314
84894: NOT
84895: IFFALSE 84950
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
84897: LD_VAR 0 4
84901: PUSH
84902: LD_VAR 0 7
84906: ARRAY
84907: PPUSH
84908: LD_VAR 0 16
84912: PUSH
84913: LD_VAR 0 7
84917: ARRAY
84918: PUSH
84919: LD_INT 1
84921: ARRAY
84922: PUSH
84923: LD_INT 1
84925: ARRAY
84926: PPUSH
84927: LD_VAR 0 16
84931: PUSH
84932: LD_VAR 0 7
84936: ARRAY
84937: PUSH
84938: LD_INT 1
84940: ARRAY
84941: PUSH
84942: LD_INT 2
84944: ARRAY
84945: PPUSH
84946: CALL_OW 114
// end else
84950: GO 85003
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
84952: LD_ADDR_VAR 0 15
84956: PUSH
84957: LD_VAR 0 16
84961: PUSH
84962: LD_VAR 0 7
84966: ARRAY
84967: PPUSH
84968: LD_INT 1
84970: PPUSH
84971: CALL_OW 3
84975: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
84976: LD_ADDR_VAR 0 16
84980: PUSH
84981: LD_VAR 0 16
84985: PPUSH
84986: LD_VAR 0 7
84990: PPUSH
84991: LD_VAR 0 15
84995: PPUSH
84996: CALL_OW 1
85000: ST_TO_ADDR
// continue ;
85001: GO 83546
// end ; end ; end else
85003: GO 87667
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
85005: LD_ADDR_VAR 0 14
85009: PUSH
85010: LD_INT 81
85012: PUSH
85013: LD_VAR 0 4
85017: PUSH
85018: LD_VAR 0 7
85022: ARRAY
85023: PPUSH
85024: CALL_OW 255
85028: PUSH
85029: EMPTY
85030: LIST
85031: LIST
85032: PPUSH
85033: CALL_OW 69
85037: ST_TO_ADDR
// if not tmp then
85038: LD_VAR 0 14
85042: NOT
85043: IFFALSE 85047
// continue ;
85045: GO 83546
// if f_ignore_area then
85047: LD_VAR 0 17
85051: IFFALSE 85139
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
85053: LD_ADDR_VAR 0 15
85057: PUSH
85058: LD_VAR 0 14
85062: PPUSH
85063: LD_INT 3
85065: PUSH
85066: LD_INT 92
85068: PUSH
85069: LD_VAR 0 17
85073: PUSH
85074: LD_INT 1
85076: ARRAY
85077: PUSH
85078: LD_VAR 0 17
85082: PUSH
85083: LD_INT 2
85085: ARRAY
85086: PUSH
85087: LD_VAR 0 17
85091: PUSH
85092: LD_INT 3
85094: ARRAY
85095: PUSH
85096: EMPTY
85097: LIST
85098: LIST
85099: LIST
85100: LIST
85101: PUSH
85102: EMPTY
85103: LIST
85104: LIST
85105: PPUSH
85106: CALL_OW 72
85110: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
85111: LD_VAR 0 14
85115: PUSH
85116: LD_VAR 0 15
85120: DIFF
85121: IFFALSE 85139
// tmp := tmp diff tmp2 ;
85123: LD_ADDR_VAR 0 14
85127: PUSH
85128: LD_VAR 0 14
85132: PUSH
85133: LD_VAR 0 15
85137: DIFF
85138: ST_TO_ADDR
// end ; if not f_murder then
85139: LD_VAR 0 20
85143: NOT
85144: IFFALSE 85202
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
85146: LD_ADDR_VAR 0 15
85150: PUSH
85151: LD_VAR 0 14
85155: PPUSH
85156: LD_INT 3
85158: PUSH
85159: LD_INT 50
85161: PUSH
85162: EMPTY
85163: LIST
85164: PUSH
85165: EMPTY
85166: LIST
85167: LIST
85168: PPUSH
85169: CALL_OW 72
85173: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
85174: LD_VAR 0 14
85178: PUSH
85179: LD_VAR 0 15
85183: DIFF
85184: IFFALSE 85202
// tmp := tmp diff tmp2 ;
85186: LD_ADDR_VAR 0 14
85190: PUSH
85191: LD_VAR 0 14
85195: PUSH
85196: LD_VAR 0 15
85200: DIFF
85201: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
85202: LD_ADDR_VAR 0 14
85206: PUSH
85207: LD_VAR 0 4
85211: PUSH
85212: LD_VAR 0 7
85216: ARRAY
85217: PPUSH
85218: LD_VAR 0 14
85222: PPUSH
85223: LD_INT 1
85225: PPUSH
85226: LD_INT 1
85228: PPUSH
85229: CALL 54990 0 4
85233: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
85234: LD_VAR 0 4
85238: PUSH
85239: LD_VAR 0 7
85243: ARRAY
85244: PPUSH
85245: CALL_OW 257
85249: PUSH
85250: LD_INT 1
85252: EQUAL
85253: IFFALSE 85701
// begin if WantPlant ( group [ i ] ) then
85255: LD_VAR 0 4
85259: PUSH
85260: LD_VAR 0 7
85264: ARRAY
85265: PPUSH
85266: CALL 54491 0 1
85270: IFFALSE 85274
// continue ;
85272: GO 83546
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
85274: LD_VAR 0 18
85278: PUSH
85279: LD_VAR 0 4
85283: PUSH
85284: LD_VAR 0 7
85288: ARRAY
85289: PPUSH
85290: CALL_OW 310
85294: NOT
85295: AND
85296: PUSH
85297: LD_VAR 0 14
85301: PUSH
85302: LD_INT 1
85304: ARRAY
85305: PUSH
85306: LD_VAR 0 14
85310: PPUSH
85311: LD_INT 21
85313: PUSH
85314: LD_INT 2
85316: PUSH
85317: EMPTY
85318: LIST
85319: LIST
85320: PUSH
85321: LD_INT 58
85323: PUSH
85324: EMPTY
85325: LIST
85326: PUSH
85327: EMPTY
85328: LIST
85329: LIST
85330: PPUSH
85331: CALL_OW 72
85335: IN
85336: AND
85337: IFFALSE 85373
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
85339: LD_VAR 0 4
85343: PUSH
85344: LD_VAR 0 7
85348: ARRAY
85349: PPUSH
85350: LD_VAR 0 14
85354: PUSH
85355: LD_INT 1
85357: ARRAY
85358: PPUSH
85359: CALL_OW 120
// attacking := true ;
85363: LD_ADDR_VAR 0 29
85367: PUSH
85368: LD_INT 1
85370: ST_TO_ADDR
// continue ;
85371: GO 83546
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
85373: LD_VAR 0 26
85377: PUSH
85378: LD_VAR 0 4
85382: PUSH
85383: LD_VAR 0 7
85387: ARRAY
85388: PPUSH
85389: CALL_OW 257
85393: PUSH
85394: LD_INT 1
85396: EQUAL
85397: AND
85398: PUSH
85399: LD_VAR 0 4
85403: PUSH
85404: LD_VAR 0 7
85408: ARRAY
85409: PPUSH
85410: CALL_OW 256
85414: PUSH
85415: LD_INT 800
85417: LESS
85418: AND
85419: PUSH
85420: LD_VAR 0 4
85424: PUSH
85425: LD_VAR 0 7
85429: ARRAY
85430: PPUSH
85431: CALL_OW 318
85435: NOT
85436: AND
85437: IFFALSE 85454
// ComCrawl ( group [ i ] ) ;
85439: LD_VAR 0 4
85443: PUSH
85444: LD_VAR 0 7
85448: ARRAY
85449: PPUSH
85450: CALL_OW 137
// if f_mines then
85454: LD_VAR 0 21
85458: IFFALSE 85701
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
85460: LD_VAR 0 14
85464: PUSH
85465: LD_INT 1
85467: ARRAY
85468: PPUSH
85469: CALL_OW 247
85473: PUSH
85474: LD_INT 3
85476: EQUAL
85477: PUSH
85478: LD_VAR 0 14
85482: PUSH
85483: LD_INT 1
85485: ARRAY
85486: PUSH
85487: LD_VAR 0 27
85491: IN
85492: NOT
85493: AND
85494: IFFALSE 85701
// begin x := GetX ( tmp [ 1 ] ) ;
85496: LD_ADDR_VAR 0 10
85500: PUSH
85501: LD_VAR 0 14
85505: PUSH
85506: LD_INT 1
85508: ARRAY
85509: PPUSH
85510: CALL_OW 250
85514: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
85515: LD_ADDR_VAR 0 11
85519: PUSH
85520: LD_VAR 0 14
85524: PUSH
85525: LD_INT 1
85527: ARRAY
85528: PPUSH
85529: CALL_OW 251
85533: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
85534: LD_ADDR_VAR 0 12
85538: PUSH
85539: LD_VAR 0 4
85543: PUSH
85544: LD_VAR 0 7
85548: ARRAY
85549: PPUSH
85550: CALL 81432 0 1
85554: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
85555: LD_VAR 0 4
85559: PUSH
85560: LD_VAR 0 7
85564: ARRAY
85565: PPUSH
85566: LD_VAR 0 10
85570: PPUSH
85571: LD_VAR 0 11
85575: PPUSH
85576: LD_VAR 0 14
85580: PUSH
85581: LD_INT 1
85583: ARRAY
85584: PPUSH
85585: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
85589: LD_VAR 0 4
85593: PUSH
85594: LD_VAR 0 7
85598: ARRAY
85599: PPUSH
85600: LD_VAR 0 10
85604: PPUSH
85605: LD_VAR 0 12
85609: PPUSH
85610: LD_INT 7
85612: PPUSH
85613: CALL_OW 272
85617: PPUSH
85618: LD_VAR 0 11
85622: PPUSH
85623: LD_VAR 0 12
85627: PPUSH
85628: LD_INT 7
85630: PPUSH
85631: CALL_OW 273
85635: PPUSH
85636: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
85640: LD_VAR 0 4
85644: PUSH
85645: LD_VAR 0 7
85649: ARRAY
85650: PPUSH
85651: LD_INT 71
85653: PPUSH
85654: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
85658: LD_ADDR_VAR 0 27
85662: PUSH
85663: LD_VAR 0 27
85667: PPUSH
85668: LD_VAR 0 27
85672: PUSH
85673: LD_INT 1
85675: PLUS
85676: PPUSH
85677: LD_VAR 0 14
85681: PUSH
85682: LD_INT 1
85684: ARRAY
85685: PPUSH
85686: CALL_OW 1
85690: ST_TO_ADDR
// attacking := true ;
85691: LD_ADDR_VAR 0 29
85695: PUSH
85696: LD_INT 1
85698: ST_TO_ADDR
// continue ;
85699: GO 83546
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
85701: LD_VAR 0 4
85705: PUSH
85706: LD_VAR 0 7
85710: ARRAY
85711: PPUSH
85712: CALL_OW 257
85716: PUSH
85717: LD_INT 17
85719: EQUAL
85720: PUSH
85721: LD_VAR 0 4
85725: PUSH
85726: LD_VAR 0 7
85730: ARRAY
85731: PPUSH
85732: CALL_OW 110
85736: PUSH
85737: LD_INT 71
85739: EQUAL
85740: NOT
85741: AND
85742: IFFALSE 85888
// begin attacking := false ;
85744: LD_ADDR_VAR 0 29
85748: PUSH
85749: LD_INT 0
85751: ST_TO_ADDR
// k := 5 ;
85752: LD_ADDR_VAR 0 9
85756: PUSH
85757: LD_INT 5
85759: ST_TO_ADDR
// if tmp < k then
85760: LD_VAR 0 14
85764: PUSH
85765: LD_VAR 0 9
85769: LESS
85770: IFFALSE 85782
// k := tmp ;
85772: LD_ADDR_VAR 0 9
85776: PUSH
85777: LD_VAR 0 14
85781: ST_TO_ADDR
// for j = 1 to k do
85782: LD_ADDR_VAR 0 8
85786: PUSH
85787: DOUBLE
85788: LD_INT 1
85790: DEC
85791: ST_TO_ADDR
85792: LD_VAR 0 9
85796: PUSH
85797: FOR_TO
85798: IFFALSE 85886
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
85800: LD_VAR 0 14
85804: PUSH
85805: LD_VAR 0 8
85809: ARRAY
85810: PUSH
85811: LD_VAR 0 14
85815: PPUSH
85816: LD_INT 58
85818: PUSH
85819: EMPTY
85820: LIST
85821: PPUSH
85822: CALL_OW 72
85826: IN
85827: NOT
85828: IFFALSE 85884
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
85830: LD_VAR 0 4
85834: PUSH
85835: LD_VAR 0 7
85839: ARRAY
85840: PPUSH
85841: LD_VAR 0 14
85845: PUSH
85846: LD_VAR 0 8
85850: ARRAY
85851: PPUSH
85852: CALL_OW 115
// attacking := true ;
85856: LD_ADDR_VAR 0 29
85860: PUSH
85861: LD_INT 1
85863: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
85864: LD_VAR 0 4
85868: PUSH
85869: LD_VAR 0 7
85873: ARRAY
85874: PPUSH
85875: LD_INT 71
85877: PPUSH
85878: CALL_OW 109
// continue ;
85882: GO 85797
// end ; end ;
85884: GO 85797
85886: POP
85887: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
85888: LD_VAR 0 4
85892: PUSH
85893: LD_VAR 0 7
85897: ARRAY
85898: PPUSH
85899: CALL_OW 257
85903: PUSH
85904: LD_INT 8
85906: EQUAL
85907: PUSH
85908: LD_VAR 0 4
85912: PUSH
85913: LD_VAR 0 7
85917: ARRAY
85918: PPUSH
85919: CALL_OW 264
85923: PUSH
85924: LD_INT 28
85926: PUSH
85927: LD_INT 45
85929: PUSH
85930: LD_INT 7
85932: PUSH
85933: LD_INT 47
85935: PUSH
85936: EMPTY
85937: LIST
85938: LIST
85939: LIST
85940: LIST
85941: IN
85942: OR
85943: IFFALSE 86199
// begin attacking := false ;
85945: LD_ADDR_VAR 0 29
85949: PUSH
85950: LD_INT 0
85952: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
85953: LD_VAR 0 14
85957: PUSH
85958: LD_INT 1
85960: ARRAY
85961: PPUSH
85962: CALL_OW 266
85966: PUSH
85967: LD_INT 32
85969: PUSH
85970: LD_INT 31
85972: PUSH
85973: LD_INT 33
85975: PUSH
85976: LD_INT 4
85978: PUSH
85979: LD_INT 5
85981: PUSH
85982: EMPTY
85983: LIST
85984: LIST
85985: LIST
85986: LIST
85987: LIST
85988: IN
85989: IFFALSE 86175
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
85991: LD_ADDR_VAR 0 9
85995: PUSH
85996: LD_VAR 0 14
86000: PUSH
86001: LD_INT 1
86003: ARRAY
86004: PPUSH
86005: CALL_OW 266
86009: PPUSH
86010: LD_VAR 0 14
86014: PUSH
86015: LD_INT 1
86017: ARRAY
86018: PPUSH
86019: CALL_OW 250
86023: PPUSH
86024: LD_VAR 0 14
86028: PUSH
86029: LD_INT 1
86031: ARRAY
86032: PPUSH
86033: CALL_OW 251
86037: PPUSH
86038: LD_VAR 0 14
86042: PUSH
86043: LD_INT 1
86045: ARRAY
86046: PPUSH
86047: CALL_OW 254
86051: PPUSH
86052: LD_VAR 0 14
86056: PUSH
86057: LD_INT 1
86059: ARRAY
86060: PPUSH
86061: CALL_OW 248
86065: PPUSH
86066: LD_INT 0
86068: PPUSH
86069: CALL 62802 0 6
86073: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
86074: LD_ADDR_VAR 0 8
86078: PUSH
86079: LD_VAR 0 4
86083: PUSH
86084: LD_VAR 0 7
86088: ARRAY
86089: PPUSH
86090: LD_VAR 0 9
86094: PPUSH
86095: CALL 81472 0 2
86099: ST_TO_ADDR
// if j then
86100: LD_VAR 0 8
86104: IFFALSE 86173
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
86106: LD_VAR 0 8
86110: PUSH
86111: LD_INT 1
86113: ARRAY
86114: PPUSH
86115: LD_VAR 0 8
86119: PUSH
86120: LD_INT 2
86122: ARRAY
86123: PPUSH
86124: CALL_OW 488
86128: IFFALSE 86173
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
86130: LD_VAR 0 4
86134: PUSH
86135: LD_VAR 0 7
86139: ARRAY
86140: PPUSH
86141: LD_VAR 0 8
86145: PUSH
86146: LD_INT 1
86148: ARRAY
86149: PPUSH
86150: LD_VAR 0 8
86154: PUSH
86155: LD_INT 2
86157: ARRAY
86158: PPUSH
86159: CALL_OW 116
// attacking := true ;
86163: LD_ADDR_VAR 0 29
86167: PUSH
86168: LD_INT 1
86170: ST_TO_ADDR
// continue ;
86171: GO 83546
// end ; end else
86173: GO 86199
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
86175: LD_VAR 0 4
86179: PUSH
86180: LD_VAR 0 7
86184: ARRAY
86185: PPUSH
86186: LD_VAR 0 14
86190: PUSH
86191: LD_INT 1
86193: ARRAY
86194: PPUSH
86195: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
86199: LD_VAR 0 4
86203: PUSH
86204: LD_VAR 0 7
86208: ARRAY
86209: PPUSH
86210: CALL_OW 265
86214: PUSH
86215: LD_INT 11
86217: EQUAL
86218: IFFALSE 86496
// begin k := 10 ;
86220: LD_ADDR_VAR 0 9
86224: PUSH
86225: LD_INT 10
86227: ST_TO_ADDR
// x := 0 ;
86228: LD_ADDR_VAR 0 10
86232: PUSH
86233: LD_INT 0
86235: ST_TO_ADDR
// if tmp < k then
86236: LD_VAR 0 14
86240: PUSH
86241: LD_VAR 0 9
86245: LESS
86246: IFFALSE 86258
// k := tmp ;
86248: LD_ADDR_VAR 0 9
86252: PUSH
86253: LD_VAR 0 14
86257: ST_TO_ADDR
// for j = k downto 1 do
86258: LD_ADDR_VAR 0 8
86262: PUSH
86263: DOUBLE
86264: LD_VAR 0 9
86268: INC
86269: ST_TO_ADDR
86270: LD_INT 1
86272: PUSH
86273: FOR_DOWNTO
86274: IFFALSE 86349
// begin if GetType ( tmp [ j ] ) = unit_human then
86276: LD_VAR 0 14
86280: PUSH
86281: LD_VAR 0 8
86285: ARRAY
86286: PPUSH
86287: CALL_OW 247
86291: PUSH
86292: LD_INT 1
86294: EQUAL
86295: IFFALSE 86347
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
86297: LD_VAR 0 4
86301: PUSH
86302: LD_VAR 0 7
86306: ARRAY
86307: PPUSH
86308: LD_VAR 0 14
86312: PUSH
86313: LD_VAR 0 8
86317: ARRAY
86318: PPUSH
86319: CALL 81743 0 2
// x := tmp [ j ] ;
86323: LD_ADDR_VAR 0 10
86327: PUSH
86328: LD_VAR 0 14
86332: PUSH
86333: LD_VAR 0 8
86337: ARRAY
86338: ST_TO_ADDR
// attacking := true ;
86339: LD_ADDR_VAR 0 29
86343: PUSH
86344: LD_INT 1
86346: ST_TO_ADDR
// end ; end ;
86347: GO 86273
86349: POP
86350: POP
// if not x then
86351: LD_VAR 0 10
86355: NOT
86356: IFFALSE 86496
// begin attacking := true ;
86358: LD_ADDR_VAR 0 29
86362: PUSH
86363: LD_INT 1
86365: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
86366: LD_VAR 0 4
86370: PUSH
86371: LD_VAR 0 7
86375: ARRAY
86376: PPUSH
86377: CALL_OW 250
86381: PPUSH
86382: LD_VAR 0 4
86386: PUSH
86387: LD_VAR 0 7
86391: ARRAY
86392: PPUSH
86393: CALL_OW 251
86397: PPUSH
86398: CALL_OW 546
86402: PUSH
86403: LD_INT 2
86405: ARRAY
86406: PUSH
86407: LD_VAR 0 14
86411: PUSH
86412: LD_INT 1
86414: ARRAY
86415: PPUSH
86416: CALL_OW 250
86420: PPUSH
86421: LD_VAR 0 14
86425: PUSH
86426: LD_INT 1
86428: ARRAY
86429: PPUSH
86430: CALL_OW 251
86434: PPUSH
86435: CALL_OW 546
86439: PUSH
86440: LD_INT 2
86442: ARRAY
86443: EQUAL
86444: IFFALSE 86472
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
86446: LD_VAR 0 4
86450: PUSH
86451: LD_VAR 0 7
86455: ARRAY
86456: PPUSH
86457: LD_VAR 0 14
86461: PUSH
86462: LD_INT 1
86464: ARRAY
86465: PPUSH
86466: CALL 81743 0 2
86470: GO 86496
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
86472: LD_VAR 0 4
86476: PUSH
86477: LD_VAR 0 7
86481: ARRAY
86482: PPUSH
86483: LD_VAR 0 14
86487: PUSH
86488: LD_INT 1
86490: ARRAY
86491: PPUSH
86492: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
86496: LD_VAR 0 4
86500: PUSH
86501: LD_VAR 0 7
86505: ARRAY
86506: PPUSH
86507: CALL_OW 264
86511: PUSH
86512: LD_INT 29
86514: EQUAL
86515: IFFALSE 86881
// begin if WantsToAttack ( group [ i ] ) in bombed then
86517: LD_VAR 0 4
86521: PUSH
86522: LD_VAR 0 7
86526: ARRAY
86527: PPUSH
86528: CALL_OW 319
86532: PUSH
86533: LD_VAR 0 28
86537: IN
86538: IFFALSE 86542
// continue ;
86540: GO 83546
// k := 8 ;
86542: LD_ADDR_VAR 0 9
86546: PUSH
86547: LD_INT 8
86549: ST_TO_ADDR
// x := 0 ;
86550: LD_ADDR_VAR 0 10
86554: PUSH
86555: LD_INT 0
86557: ST_TO_ADDR
// if tmp < k then
86558: LD_VAR 0 14
86562: PUSH
86563: LD_VAR 0 9
86567: LESS
86568: IFFALSE 86580
// k := tmp ;
86570: LD_ADDR_VAR 0 9
86574: PUSH
86575: LD_VAR 0 14
86579: ST_TO_ADDR
// for j = 1 to k do
86580: LD_ADDR_VAR 0 8
86584: PUSH
86585: DOUBLE
86586: LD_INT 1
86588: DEC
86589: ST_TO_ADDR
86590: LD_VAR 0 9
86594: PUSH
86595: FOR_TO
86596: IFFALSE 86728
// begin if GetType ( tmp [ j ] ) = unit_building then
86598: LD_VAR 0 14
86602: PUSH
86603: LD_VAR 0 8
86607: ARRAY
86608: PPUSH
86609: CALL_OW 247
86613: PUSH
86614: LD_INT 3
86616: EQUAL
86617: IFFALSE 86726
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
86619: LD_VAR 0 14
86623: PUSH
86624: LD_VAR 0 8
86628: ARRAY
86629: PUSH
86630: LD_VAR 0 28
86634: IN
86635: NOT
86636: PUSH
86637: LD_VAR 0 14
86641: PUSH
86642: LD_VAR 0 8
86646: ARRAY
86647: PPUSH
86648: CALL_OW 313
86652: AND
86653: IFFALSE 86726
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
86655: LD_VAR 0 4
86659: PUSH
86660: LD_VAR 0 7
86664: ARRAY
86665: PPUSH
86666: LD_VAR 0 14
86670: PUSH
86671: LD_VAR 0 8
86675: ARRAY
86676: PPUSH
86677: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
86681: LD_ADDR_VAR 0 28
86685: PUSH
86686: LD_VAR 0 28
86690: PPUSH
86691: LD_VAR 0 28
86695: PUSH
86696: LD_INT 1
86698: PLUS
86699: PPUSH
86700: LD_VAR 0 14
86704: PUSH
86705: LD_VAR 0 8
86709: ARRAY
86710: PPUSH
86711: CALL_OW 1
86715: ST_TO_ADDR
// attacking := true ;
86716: LD_ADDR_VAR 0 29
86720: PUSH
86721: LD_INT 1
86723: ST_TO_ADDR
// break ;
86724: GO 86728
// end ; end ;
86726: GO 86595
86728: POP
86729: POP
// if not attacking and f_attack_depot then
86730: LD_VAR 0 29
86734: NOT
86735: PUSH
86736: LD_VAR 0 25
86740: AND
86741: IFFALSE 86836
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
86743: LD_ADDR_VAR 0 13
86747: PUSH
86748: LD_VAR 0 14
86752: PPUSH
86753: LD_INT 2
86755: PUSH
86756: LD_INT 30
86758: PUSH
86759: LD_INT 0
86761: PUSH
86762: EMPTY
86763: LIST
86764: LIST
86765: PUSH
86766: LD_INT 30
86768: PUSH
86769: LD_INT 1
86771: PUSH
86772: EMPTY
86773: LIST
86774: LIST
86775: PUSH
86776: EMPTY
86777: LIST
86778: LIST
86779: LIST
86780: PPUSH
86781: CALL_OW 72
86785: ST_TO_ADDR
// if z then
86786: LD_VAR 0 13
86790: IFFALSE 86836
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
86792: LD_VAR 0 4
86796: PUSH
86797: LD_VAR 0 7
86801: ARRAY
86802: PPUSH
86803: LD_VAR 0 13
86807: PPUSH
86808: LD_VAR 0 4
86812: PUSH
86813: LD_VAR 0 7
86817: ARRAY
86818: PPUSH
86819: CALL_OW 74
86823: PPUSH
86824: CALL_OW 115
// attacking := true ;
86828: LD_ADDR_VAR 0 29
86832: PUSH
86833: LD_INT 1
86835: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
86836: LD_VAR 0 4
86840: PUSH
86841: LD_VAR 0 7
86845: ARRAY
86846: PPUSH
86847: CALL_OW 256
86851: PUSH
86852: LD_INT 500
86854: LESS
86855: IFFALSE 86881
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
86857: LD_VAR 0 4
86861: PUSH
86862: LD_VAR 0 7
86866: ARRAY
86867: PPUSH
86868: LD_VAR 0 14
86872: PUSH
86873: LD_INT 1
86875: ARRAY
86876: PPUSH
86877: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
86881: LD_VAR 0 4
86885: PUSH
86886: LD_VAR 0 7
86890: ARRAY
86891: PPUSH
86892: CALL_OW 264
86896: PUSH
86897: LD_INT 49
86899: EQUAL
86900: IFFALSE 87021
// begin if not HasTask ( group [ i ] ) then
86902: LD_VAR 0 4
86906: PUSH
86907: LD_VAR 0 7
86911: ARRAY
86912: PPUSH
86913: CALL_OW 314
86917: NOT
86918: IFFALSE 87021
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
86920: LD_ADDR_VAR 0 9
86924: PUSH
86925: LD_INT 81
86927: PUSH
86928: LD_VAR 0 4
86932: PUSH
86933: LD_VAR 0 7
86937: ARRAY
86938: PPUSH
86939: CALL_OW 255
86943: PUSH
86944: EMPTY
86945: LIST
86946: LIST
86947: PPUSH
86948: CALL_OW 69
86952: PPUSH
86953: LD_VAR 0 4
86957: PUSH
86958: LD_VAR 0 7
86962: ARRAY
86963: PPUSH
86964: CALL_OW 74
86968: ST_TO_ADDR
// if k then
86969: LD_VAR 0 9
86973: IFFALSE 87021
// if GetDistUnits ( group [ i ] , k ) > 10 then
86975: LD_VAR 0 4
86979: PUSH
86980: LD_VAR 0 7
86984: ARRAY
86985: PPUSH
86986: LD_VAR 0 9
86990: PPUSH
86991: CALL_OW 296
86995: PUSH
86996: LD_INT 10
86998: GREATER
86999: IFFALSE 87021
// ComMoveUnit ( group [ i ] , k ) ;
87001: LD_VAR 0 4
87005: PUSH
87006: LD_VAR 0 7
87010: ARRAY
87011: PPUSH
87012: LD_VAR 0 9
87016: PPUSH
87017: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
87021: LD_VAR 0 4
87025: PUSH
87026: LD_VAR 0 7
87030: ARRAY
87031: PPUSH
87032: CALL_OW 256
87036: PUSH
87037: LD_INT 250
87039: LESS
87040: PUSH
87041: LD_VAR 0 4
87045: PUSH
87046: LD_VAR 0 7
87050: ARRAY
87051: PUSH
87052: LD_INT 21
87054: PUSH
87055: LD_INT 2
87057: PUSH
87058: EMPTY
87059: LIST
87060: LIST
87061: PUSH
87062: LD_INT 23
87064: PUSH
87065: LD_INT 2
87067: PUSH
87068: EMPTY
87069: LIST
87070: LIST
87071: PUSH
87072: EMPTY
87073: LIST
87074: LIST
87075: PPUSH
87076: CALL_OW 69
87080: IN
87081: AND
87082: IFFALSE 87207
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
87084: LD_ADDR_VAR 0 9
87088: PUSH
87089: LD_OWVAR 3
87093: PUSH
87094: LD_VAR 0 4
87098: PUSH
87099: LD_VAR 0 7
87103: ARRAY
87104: DIFF
87105: PPUSH
87106: LD_VAR 0 4
87110: PUSH
87111: LD_VAR 0 7
87115: ARRAY
87116: PPUSH
87117: CALL_OW 74
87121: ST_TO_ADDR
// if not k then
87122: LD_VAR 0 9
87126: NOT
87127: IFFALSE 87131
// continue ;
87129: GO 83546
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
87131: LD_VAR 0 9
87135: PUSH
87136: LD_INT 81
87138: PUSH
87139: LD_VAR 0 4
87143: PUSH
87144: LD_VAR 0 7
87148: ARRAY
87149: PPUSH
87150: CALL_OW 255
87154: PUSH
87155: EMPTY
87156: LIST
87157: LIST
87158: PPUSH
87159: CALL_OW 69
87163: IN
87164: PUSH
87165: LD_VAR 0 9
87169: PPUSH
87170: LD_VAR 0 4
87174: PUSH
87175: LD_VAR 0 7
87179: ARRAY
87180: PPUSH
87181: CALL_OW 296
87185: PUSH
87186: LD_INT 5
87188: LESS
87189: AND
87190: IFFALSE 87207
// ComAutodestruct ( group [ i ] ) ;
87192: LD_VAR 0 4
87196: PUSH
87197: LD_VAR 0 7
87201: ARRAY
87202: PPUSH
87203: CALL 81641 0 1
// end ; if f_attack_depot then
87207: LD_VAR 0 25
87211: IFFALSE 87323
// begin k := 6 ;
87213: LD_ADDR_VAR 0 9
87217: PUSH
87218: LD_INT 6
87220: ST_TO_ADDR
// if tmp < k then
87221: LD_VAR 0 14
87225: PUSH
87226: LD_VAR 0 9
87230: LESS
87231: IFFALSE 87243
// k := tmp ;
87233: LD_ADDR_VAR 0 9
87237: PUSH
87238: LD_VAR 0 14
87242: ST_TO_ADDR
// for j = 1 to k do
87243: LD_ADDR_VAR 0 8
87247: PUSH
87248: DOUBLE
87249: LD_INT 1
87251: DEC
87252: ST_TO_ADDR
87253: LD_VAR 0 9
87257: PUSH
87258: FOR_TO
87259: IFFALSE 87321
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
87261: LD_VAR 0 8
87265: PPUSH
87266: CALL_OW 266
87270: PUSH
87271: LD_INT 0
87273: PUSH
87274: LD_INT 1
87276: PUSH
87277: EMPTY
87278: LIST
87279: LIST
87280: IN
87281: IFFALSE 87319
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
87283: LD_VAR 0 4
87287: PUSH
87288: LD_VAR 0 7
87292: ARRAY
87293: PPUSH
87294: LD_VAR 0 14
87298: PUSH
87299: LD_VAR 0 8
87303: ARRAY
87304: PPUSH
87305: CALL_OW 115
// attacking := true ;
87309: LD_ADDR_VAR 0 29
87313: PUSH
87314: LD_INT 1
87316: ST_TO_ADDR
// break ;
87317: GO 87321
// end ;
87319: GO 87258
87321: POP
87322: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
87323: LD_VAR 0 4
87327: PUSH
87328: LD_VAR 0 7
87332: ARRAY
87333: PPUSH
87334: CALL_OW 302
87338: PUSH
87339: LD_VAR 0 29
87343: NOT
87344: AND
87345: IFFALSE 87667
// begin if GetTag ( group [ i ] ) = 71 then
87347: LD_VAR 0 4
87351: PUSH
87352: LD_VAR 0 7
87356: ARRAY
87357: PPUSH
87358: CALL_OW 110
87362: PUSH
87363: LD_INT 71
87365: EQUAL
87366: IFFALSE 87407
// begin if HasTask ( group [ i ] ) then
87368: LD_VAR 0 4
87372: PUSH
87373: LD_VAR 0 7
87377: ARRAY
87378: PPUSH
87379: CALL_OW 314
87383: IFFALSE 87389
// continue else
87385: GO 83546
87387: GO 87407
// SetTag ( group [ i ] , 0 ) ;
87389: LD_VAR 0 4
87393: PUSH
87394: LD_VAR 0 7
87398: ARRAY
87399: PPUSH
87400: LD_INT 0
87402: PPUSH
87403: CALL_OW 109
// end ; k := 8 ;
87407: LD_ADDR_VAR 0 9
87411: PUSH
87412: LD_INT 8
87414: ST_TO_ADDR
// x := 0 ;
87415: LD_ADDR_VAR 0 10
87419: PUSH
87420: LD_INT 0
87422: ST_TO_ADDR
// if tmp < k then
87423: LD_VAR 0 14
87427: PUSH
87428: LD_VAR 0 9
87432: LESS
87433: IFFALSE 87445
// k := tmp ;
87435: LD_ADDR_VAR 0 9
87439: PUSH
87440: LD_VAR 0 14
87444: ST_TO_ADDR
// for j = 1 to k do
87445: LD_ADDR_VAR 0 8
87449: PUSH
87450: DOUBLE
87451: LD_INT 1
87453: DEC
87454: ST_TO_ADDR
87455: LD_VAR 0 9
87459: PUSH
87460: FOR_TO
87461: IFFALSE 87559
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
87463: LD_VAR 0 14
87467: PUSH
87468: LD_VAR 0 8
87472: ARRAY
87473: PPUSH
87474: CALL_OW 247
87478: PUSH
87479: LD_INT 1
87481: EQUAL
87482: PUSH
87483: LD_VAR 0 14
87487: PUSH
87488: LD_VAR 0 8
87492: ARRAY
87493: PPUSH
87494: CALL_OW 256
87498: PUSH
87499: LD_INT 250
87501: LESS
87502: PUSH
87503: LD_VAR 0 20
87507: AND
87508: PUSH
87509: LD_VAR 0 20
87513: NOT
87514: PUSH
87515: LD_VAR 0 14
87519: PUSH
87520: LD_VAR 0 8
87524: ARRAY
87525: PPUSH
87526: CALL_OW 256
87530: PUSH
87531: LD_INT 250
87533: GREATEREQUAL
87534: AND
87535: OR
87536: AND
87537: IFFALSE 87557
// begin x := tmp [ j ] ;
87539: LD_ADDR_VAR 0 10
87543: PUSH
87544: LD_VAR 0 14
87548: PUSH
87549: LD_VAR 0 8
87553: ARRAY
87554: ST_TO_ADDR
// break ;
87555: GO 87559
// end ;
87557: GO 87460
87559: POP
87560: POP
// if x then
87561: LD_VAR 0 10
87565: IFFALSE 87589
// ComAttackUnit ( group [ i ] , x ) else
87567: LD_VAR 0 4
87571: PUSH
87572: LD_VAR 0 7
87576: ARRAY
87577: PPUSH
87578: LD_VAR 0 10
87582: PPUSH
87583: CALL_OW 115
87587: GO 87613
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
87589: LD_VAR 0 4
87593: PUSH
87594: LD_VAR 0 7
87598: ARRAY
87599: PPUSH
87600: LD_VAR 0 14
87604: PUSH
87605: LD_INT 1
87607: ARRAY
87608: PPUSH
87609: CALL_OW 115
// if not HasTask ( group [ i ] ) then
87613: LD_VAR 0 4
87617: PUSH
87618: LD_VAR 0 7
87622: ARRAY
87623: PPUSH
87624: CALL_OW 314
87628: NOT
87629: IFFALSE 87667
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
87631: LD_VAR 0 4
87635: PUSH
87636: LD_VAR 0 7
87640: ARRAY
87641: PPUSH
87642: LD_VAR 0 14
87646: PPUSH
87647: LD_VAR 0 4
87651: PUSH
87652: LD_VAR 0 7
87656: ARRAY
87657: PPUSH
87658: CALL_OW 74
87662: PPUSH
87663: CALL_OW 115
// end ; end ; end ;
87667: GO 83546
87669: POP
87670: POP
// wait ( 0 0$2 ) ;
87671: LD_INT 70
87673: PPUSH
87674: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
87678: LD_VAR 0 4
87682: NOT
87683: PUSH
87684: LD_VAR 0 4
87688: PUSH
87689: EMPTY
87690: EQUAL
87691: OR
87692: PUSH
87693: LD_INT 81
87695: PUSH
87696: LD_VAR 0 35
87700: PUSH
87701: EMPTY
87702: LIST
87703: LIST
87704: PPUSH
87705: CALL_OW 69
87709: NOT
87710: OR
87711: IFFALSE 83531
// end ;
87713: LD_VAR 0 2
87717: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
87718: LD_INT 0
87720: PPUSH
87721: PPUSH
87722: PPUSH
87723: PPUSH
// if not base_units then
87724: LD_VAR 0 1
87728: NOT
87729: IFFALSE 87733
// exit ;
87731: GO 87820
// result := false ;
87733: LD_ADDR_VAR 0 2
87737: PUSH
87738: LD_INT 0
87740: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
87741: LD_ADDR_VAR 0 5
87745: PUSH
87746: LD_VAR 0 1
87750: PPUSH
87751: LD_INT 21
87753: PUSH
87754: LD_INT 3
87756: PUSH
87757: EMPTY
87758: LIST
87759: LIST
87760: PPUSH
87761: CALL_OW 72
87765: ST_TO_ADDR
// if not tmp then
87766: LD_VAR 0 5
87770: NOT
87771: IFFALSE 87775
// exit ;
87773: GO 87820
// for i in tmp do
87775: LD_ADDR_VAR 0 3
87779: PUSH
87780: LD_VAR 0 5
87784: PUSH
87785: FOR_IN
87786: IFFALSE 87818
// begin result := EnemyInRange ( i , 22 ) ;
87788: LD_ADDR_VAR 0 2
87792: PUSH
87793: LD_VAR 0 3
87797: PPUSH
87798: LD_INT 22
87800: PPUSH
87801: CALL 81347 0 2
87805: ST_TO_ADDR
// if result then
87806: LD_VAR 0 2
87810: IFFALSE 87816
// exit ;
87812: POP
87813: POP
87814: GO 87820
// end ;
87816: GO 87785
87818: POP
87819: POP
// end ;
87820: LD_VAR 0 2
87824: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
87825: LD_INT 0
87827: PPUSH
87828: PPUSH
// if not units then
87829: LD_VAR 0 1
87833: NOT
87834: IFFALSE 87838
// exit ;
87836: GO 87908
// result := [ ] ;
87838: LD_ADDR_VAR 0 3
87842: PUSH
87843: EMPTY
87844: ST_TO_ADDR
// for i in units do
87845: LD_ADDR_VAR 0 4
87849: PUSH
87850: LD_VAR 0 1
87854: PUSH
87855: FOR_IN
87856: IFFALSE 87906
// if GetTag ( i ) = tag then
87858: LD_VAR 0 4
87862: PPUSH
87863: CALL_OW 110
87867: PUSH
87868: LD_VAR 0 2
87872: EQUAL
87873: IFFALSE 87904
// result := Insert ( result , result + 1 , i ) ;
87875: LD_ADDR_VAR 0 3
87879: PUSH
87880: LD_VAR 0 3
87884: PPUSH
87885: LD_VAR 0 3
87889: PUSH
87890: LD_INT 1
87892: PLUS
87893: PPUSH
87894: LD_VAR 0 4
87898: PPUSH
87899: CALL_OW 2
87903: ST_TO_ADDR
87904: GO 87855
87906: POP
87907: POP
// end ;
87908: LD_VAR 0 3
87912: RET
// export function IsDriver ( un ) ; begin
87913: LD_INT 0
87915: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
87916: LD_ADDR_VAR 0 2
87920: PUSH
87921: LD_VAR 0 1
87925: PUSH
87926: LD_INT 55
87928: PUSH
87929: EMPTY
87930: LIST
87931: PPUSH
87932: CALL_OW 69
87936: IN
87937: ST_TO_ADDR
// end ;
87938: LD_VAR 0 2
87942: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
87943: LD_INT 0
87945: PPUSH
87946: PPUSH
// list := [ ] ;
87947: LD_ADDR_VAR 0 5
87951: PUSH
87952: EMPTY
87953: ST_TO_ADDR
// case d of 0 :
87954: LD_VAR 0 3
87958: PUSH
87959: LD_INT 0
87961: DOUBLE
87962: EQUAL
87963: IFTRUE 87967
87965: GO 88100
87967: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
87968: LD_ADDR_VAR 0 5
87972: PUSH
87973: LD_VAR 0 1
87977: PUSH
87978: LD_INT 4
87980: MINUS
87981: PUSH
87982: LD_VAR 0 2
87986: PUSH
87987: LD_INT 4
87989: MINUS
87990: PUSH
87991: LD_INT 2
87993: PUSH
87994: EMPTY
87995: LIST
87996: LIST
87997: LIST
87998: PUSH
87999: LD_VAR 0 1
88003: PUSH
88004: LD_INT 3
88006: MINUS
88007: PUSH
88008: LD_VAR 0 2
88012: PUSH
88013: LD_INT 1
88015: PUSH
88016: EMPTY
88017: LIST
88018: LIST
88019: LIST
88020: PUSH
88021: LD_VAR 0 1
88025: PUSH
88026: LD_INT 4
88028: PLUS
88029: PUSH
88030: LD_VAR 0 2
88034: PUSH
88035: LD_INT 4
88037: PUSH
88038: EMPTY
88039: LIST
88040: LIST
88041: LIST
88042: PUSH
88043: LD_VAR 0 1
88047: PUSH
88048: LD_INT 3
88050: PLUS
88051: PUSH
88052: LD_VAR 0 2
88056: PUSH
88057: LD_INT 3
88059: PLUS
88060: PUSH
88061: LD_INT 5
88063: PUSH
88064: EMPTY
88065: LIST
88066: LIST
88067: LIST
88068: PUSH
88069: LD_VAR 0 1
88073: PUSH
88074: LD_VAR 0 2
88078: PUSH
88079: LD_INT 4
88081: PLUS
88082: PUSH
88083: LD_INT 0
88085: PUSH
88086: EMPTY
88087: LIST
88088: LIST
88089: LIST
88090: PUSH
88091: EMPTY
88092: LIST
88093: LIST
88094: LIST
88095: LIST
88096: LIST
88097: ST_TO_ADDR
// end ; 1 :
88098: GO 88798
88100: LD_INT 1
88102: DOUBLE
88103: EQUAL
88104: IFTRUE 88108
88106: GO 88241
88108: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
88109: LD_ADDR_VAR 0 5
88113: PUSH
88114: LD_VAR 0 1
88118: PUSH
88119: LD_VAR 0 2
88123: PUSH
88124: LD_INT 4
88126: MINUS
88127: PUSH
88128: LD_INT 3
88130: PUSH
88131: EMPTY
88132: LIST
88133: LIST
88134: LIST
88135: PUSH
88136: LD_VAR 0 1
88140: PUSH
88141: LD_INT 3
88143: MINUS
88144: PUSH
88145: LD_VAR 0 2
88149: PUSH
88150: LD_INT 3
88152: MINUS
88153: PUSH
88154: LD_INT 2
88156: PUSH
88157: EMPTY
88158: LIST
88159: LIST
88160: LIST
88161: PUSH
88162: LD_VAR 0 1
88166: PUSH
88167: LD_INT 4
88169: MINUS
88170: PUSH
88171: LD_VAR 0 2
88175: PUSH
88176: LD_INT 1
88178: PUSH
88179: EMPTY
88180: LIST
88181: LIST
88182: LIST
88183: PUSH
88184: LD_VAR 0 1
88188: PUSH
88189: LD_VAR 0 2
88193: PUSH
88194: LD_INT 3
88196: PLUS
88197: PUSH
88198: LD_INT 0
88200: PUSH
88201: EMPTY
88202: LIST
88203: LIST
88204: LIST
88205: PUSH
88206: LD_VAR 0 1
88210: PUSH
88211: LD_INT 4
88213: PLUS
88214: PUSH
88215: LD_VAR 0 2
88219: PUSH
88220: LD_INT 4
88222: PLUS
88223: PUSH
88224: LD_INT 5
88226: PUSH
88227: EMPTY
88228: LIST
88229: LIST
88230: LIST
88231: PUSH
88232: EMPTY
88233: LIST
88234: LIST
88235: LIST
88236: LIST
88237: LIST
88238: ST_TO_ADDR
// end ; 2 :
88239: GO 88798
88241: LD_INT 2
88243: DOUBLE
88244: EQUAL
88245: IFTRUE 88249
88247: GO 88378
88249: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
88250: LD_ADDR_VAR 0 5
88254: PUSH
88255: LD_VAR 0 1
88259: PUSH
88260: LD_VAR 0 2
88264: PUSH
88265: LD_INT 3
88267: MINUS
88268: PUSH
88269: LD_INT 3
88271: PUSH
88272: EMPTY
88273: LIST
88274: LIST
88275: LIST
88276: PUSH
88277: LD_VAR 0 1
88281: PUSH
88282: LD_INT 4
88284: PLUS
88285: PUSH
88286: LD_VAR 0 2
88290: PUSH
88291: LD_INT 4
88293: PUSH
88294: EMPTY
88295: LIST
88296: LIST
88297: LIST
88298: PUSH
88299: LD_VAR 0 1
88303: PUSH
88304: LD_VAR 0 2
88308: PUSH
88309: LD_INT 4
88311: PLUS
88312: PUSH
88313: LD_INT 0
88315: PUSH
88316: EMPTY
88317: LIST
88318: LIST
88319: LIST
88320: PUSH
88321: LD_VAR 0 1
88325: PUSH
88326: LD_INT 3
88328: MINUS
88329: PUSH
88330: LD_VAR 0 2
88334: PUSH
88335: LD_INT 1
88337: PUSH
88338: EMPTY
88339: LIST
88340: LIST
88341: LIST
88342: PUSH
88343: LD_VAR 0 1
88347: PUSH
88348: LD_INT 4
88350: MINUS
88351: PUSH
88352: LD_VAR 0 2
88356: PUSH
88357: LD_INT 4
88359: MINUS
88360: PUSH
88361: LD_INT 2
88363: PUSH
88364: EMPTY
88365: LIST
88366: LIST
88367: LIST
88368: PUSH
88369: EMPTY
88370: LIST
88371: LIST
88372: LIST
88373: LIST
88374: LIST
88375: ST_TO_ADDR
// end ; 3 :
88376: GO 88798
88378: LD_INT 3
88380: DOUBLE
88381: EQUAL
88382: IFTRUE 88386
88384: GO 88519
88386: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
88387: LD_ADDR_VAR 0 5
88391: PUSH
88392: LD_VAR 0 1
88396: PUSH
88397: LD_INT 3
88399: PLUS
88400: PUSH
88401: LD_VAR 0 2
88405: PUSH
88406: LD_INT 4
88408: PUSH
88409: EMPTY
88410: LIST
88411: LIST
88412: LIST
88413: PUSH
88414: LD_VAR 0 1
88418: PUSH
88419: LD_INT 4
88421: PLUS
88422: PUSH
88423: LD_VAR 0 2
88427: PUSH
88428: LD_INT 4
88430: PLUS
88431: PUSH
88432: LD_INT 5
88434: PUSH
88435: EMPTY
88436: LIST
88437: LIST
88438: LIST
88439: PUSH
88440: LD_VAR 0 1
88444: PUSH
88445: LD_INT 4
88447: MINUS
88448: PUSH
88449: LD_VAR 0 2
88453: PUSH
88454: LD_INT 1
88456: PUSH
88457: EMPTY
88458: LIST
88459: LIST
88460: LIST
88461: PUSH
88462: LD_VAR 0 1
88466: PUSH
88467: LD_VAR 0 2
88471: PUSH
88472: LD_INT 4
88474: MINUS
88475: PUSH
88476: LD_INT 3
88478: PUSH
88479: EMPTY
88480: LIST
88481: LIST
88482: LIST
88483: PUSH
88484: LD_VAR 0 1
88488: PUSH
88489: LD_INT 3
88491: MINUS
88492: PUSH
88493: LD_VAR 0 2
88497: PUSH
88498: LD_INT 3
88500: MINUS
88501: PUSH
88502: LD_INT 2
88504: PUSH
88505: EMPTY
88506: LIST
88507: LIST
88508: LIST
88509: PUSH
88510: EMPTY
88511: LIST
88512: LIST
88513: LIST
88514: LIST
88515: LIST
88516: ST_TO_ADDR
// end ; 4 :
88517: GO 88798
88519: LD_INT 4
88521: DOUBLE
88522: EQUAL
88523: IFTRUE 88527
88525: GO 88660
88527: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
88528: LD_ADDR_VAR 0 5
88532: PUSH
88533: LD_VAR 0 1
88537: PUSH
88538: LD_VAR 0 2
88542: PUSH
88543: LD_INT 4
88545: PLUS
88546: PUSH
88547: LD_INT 0
88549: PUSH
88550: EMPTY
88551: LIST
88552: LIST
88553: LIST
88554: PUSH
88555: LD_VAR 0 1
88559: PUSH
88560: LD_INT 3
88562: PLUS
88563: PUSH
88564: LD_VAR 0 2
88568: PUSH
88569: LD_INT 3
88571: PLUS
88572: PUSH
88573: LD_INT 5
88575: PUSH
88576: EMPTY
88577: LIST
88578: LIST
88579: LIST
88580: PUSH
88581: LD_VAR 0 1
88585: PUSH
88586: LD_INT 4
88588: PLUS
88589: PUSH
88590: LD_VAR 0 2
88594: PUSH
88595: LD_INT 4
88597: PUSH
88598: EMPTY
88599: LIST
88600: LIST
88601: LIST
88602: PUSH
88603: LD_VAR 0 1
88607: PUSH
88608: LD_VAR 0 2
88612: PUSH
88613: LD_INT 3
88615: MINUS
88616: PUSH
88617: LD_INT 3
88619: PUSH
88620: EMPTY
88621: LIST
88622: LIST
88623: LIST
88624: PUSH
88625: LD_VAR 0 1
88629: PUSH
88630: LD_INT 4
88632: MINUS
88633: PUSH
88634: LD_VAR 0 2
88638: PUSH
88639: LD_INT 4
88641: MINUS
88642: PUSH
88643: LD_INT 2
88645: PUSH
88646: EMPTY
88647: LIST
88648: LIST
88649: LIST
88650: PUSH
88651: EMPTY
88652: LIST
88653: LIST
88654: LIST
88655: LIST
88656: LIST
88657: ST_TO_ADDR
// end ; 5 :
88658: GO 88798
88660: LD_INT 5
88662: DOUBLE
88663: EQUAL
88664: IFTRUE 88668
88666: GO 88797
88668: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
88669: LD_ADDR_VAR 0 5
88673: PUSH
88674: LD_VAR 0 1
88678: PUSH
88679: LD_INT 4
88681: MINUS
88682: PUSH
88683: LD_VAR 0 2
88687: PUSH
88688: LD_INT 1
88690: PUSH
88691: EMPTY
88692: LIST
88693: LIST
88694: LIST
88695: PUSH
88696: LD_VAR 0 1
88700: PUSH
88701: LD_VAR 0 2
88705: PUSH
88706: LD_INT 4
88708: MINUS
88709: PUSH
88710: LD_INT 3
88712: PUSH
88713: EMPTY
88714: LIST
88715: LIST
88716: LIST
88717: PUSH
88718: LD_VAR 0 1
88722: PUSH
88723: LD_INT 4
88725: PLUS
88726: PUSH
88727: LD_VAR 0 2
88731: PUSH
88732: LD_INT 4
88734: PLUS
88735: PUSH
88736: LD_INT 5
88738: PUSH
88739: EMPTY
88740: LIST
88741: LIST
88742: LIST
88743: PUSH
88744: LD_VAR 0 1
88748: PUSH
88749: LD_INT 3
88751: PLUS
88752: PUSH
88753: LD_VAR 0 2
88757: PUSH
88758: LD_INT 4
88760: PUSH
88761: EMPTY
88762: LIST
88763: LIST
88764: LIST
88765: PUSH
88766: LD_VAR 0 1
88770: PUSH
88771: LD_VAR 0 2
88775: PUSH
88776: LD_INT 3
88778: PLUS
88779: PUSH
88780: LD_INT 0
88782: PUSH
88783: EMPTY
88784: LIST
88785: LIST
88786: LIST
88787: PUSH
88788: EMPTY
88789: LIST
88790: LIST
88791: LIST
88792: LIST
88793: LIST
88794: ST_TO_ADDR
// end ; end ;
88795: GO 88798
88797: POP
// result := list ;
88798: LD_ADDR_VAR 0 4
88802: PUSH
88803: LD_VAR 0 5
88807: ST_TO_ADDR
// end ;
88808: LD_VAR 0 4
88812: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
88813: LD_INT 0
88815: PPUSH
88816: PPUSH
88817: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
88818: LD_VAR 0 1
88822: NOT
88823: PUSH
88824: LD_VAR 0 2
88828: PUSH
88829: LD_INT 1
88831: PUSH
88832: LD_INT 2
88834: PUSH
88835: LD_INT 3
88837: PUSH
88838: LD_INT 4
88840: PUSH
88841: EMPTY
88842: LIST
88843: LIST
88844: LIST
88845: LIST
88846: IN
88847: NOT
88848: OR
88849: IFFALSE 88853
// exit ;
88851: GO 88945
// tmp := [ ] ;
88853: LD_ADDR_VAR 0 5
88857: PUSH
88858: EMPTY
88859: ST_TO_ADDR
// for i in units do
88860: LD_ADDR_VAR 0 4
88864: PUSH
88865: LD_VAR 0 1
88869: PUSH
88870: FOR_IN
88871: IFFALSE 88914
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
88873: LD_ADDR_VAR 0 5
88877: PUSH
88878: LD_VAR 0 5
88882: PPUSH
88883: LD_VAR 0 5
88887: PUSH
88888: LD_INT 1
88890: PLUS
88891: PPUSH
88892: LD_VAR 0 4
88896: PPUSH
88897: LD_VAR 0 2
88901: PPUSH
88902: CALL_OW 259
88906: PPUSH
88907: CALL_OW 2
88911: ST_TO_ADDR
88912: GO 88870
88914: POP
88915: POP
// if not tmp then
88916: LD_VAR 0 5
88920: NOT
88921: IFFALSE 88925
// exit ;
88923: GO 88945
// result := SortListByListDesc ( units , tmp ) ;
88925: LD_ADDR_VAR 0 3
88929: PUSH
88930: LD_VAR 0 1
88934: PPUSH
88935: LD_VAR 0 5
88939: PPUSH
88940: CALL_OW 77
88944: ST_TO_ADDR
// end ;
88945: LD_VAR 0 3
88949: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
88950: LD_INT 0
88952: PPUSH
88953: PPUSH
88954: PPUSH
// x := GetX ( building ) ;
88955: LD_ADDR_VAR 0 4
88959: PUSH
88960: LD_VAR 0 2
88964: PPUSH
88965: CALL_OW 250
88969: ST_TO_ADDR
// y := GetY ( building ) ;
88970: LD_ADDR_VAR 0 5
88974: PUSH
88975: LD_VAR 0 2
88979: PPUSH
88980: CALL_OW 251
88984: ST_TO_ADDR
// if GetTaskList ( unit ) then
88985: LD_VAR 0 1
88989: PPUSH
88990: CALL_OW 437
88994: IFFALSE 89089
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
88996: LD_STRING e
88998: PUSH
88999: LD_VAR 0 1
89003: PPUSH
89004: CALL_OW 437
89008: PUSH
89009: LD_INT 1
89011: ARRAY
89012: PUSH
89013: LD_INT 1
89015: ARRAY
89016: EQUAL
89017: PUSH
89018: LD_VAR 0 4
89022: PUSH
89023: LD_VAR 0 1
89027: PPUSH
89028: CALL_OW 437
89032: PUSH
89033: LD_INT 1
89035: ARRAY
89036: PUSH
89037: LD_INT 2
89039: ARRAY
89040: EQUAL
89041: AND
89042: PUSH
89043: LD_VAR 0 5
89047: PUSH
89048: LD_VAR 0 1
89052: PPUSH
89053: CALL_OW 437
89057: PUSH
89058: LD_INT 1
89060: ARRAY
89061: PUSH
89062: LD_INT 3
89064: ARRAY
89065: EQUAL
89066: AND
89067: IFFALSE 89079
// result := true else
89069: LD_ADDR_VAR 0 3
89073: PUSH
89074: LD_INT 1
89076: ST_TO_ADDR
89077: GO 89087
// result := false ;
89079: LD_ADDR_VAR 0 3
89083: PUSH
89084: LD_INT 0
89086: ST_TO_ADDR
// end else
89087: GO 89097
// result := false ;
89089: LD_ADDR_VAR 0 3
89093: PUSH
89094: LD_INT 0
89096: ST_TO_ADDR
// end ;
89097: LD_VAR 0 3
89101: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
89102: LD_INT 0
89104: PPUSH
89105: PPUSH
89106: PPUSH
89107: PPUSH
// if not unit or not area then
89108: LD_VAR 0 1
89112: NOT
89113: PUSH
89114: LD_VAR 0 2
89118: NOT
89119: OR
89120: IFFALSE 89124
// exit ;
89122: GO 89288
// tmp := AreaToList ( area , i ) ;
89124: LD_ADDR_VAR 0 6
89128: PUSH
89129: LD_VAR 0 2
89133: PPUSH
89134: LD_VAR 0 5
89138: PPUSH
89139: CALL_OW 517
89143: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
89144: LD_ADDR_VAR 0 5
89148: PUSH
89149: DOUBLE
89150: LD_INT 1
89152: DEC
89153: ST_TO_ADDR
89154: LD_VAR 0 6
89158: PUSH
89159: LD_INT 1
89161: ARRAY
89162: PUSH
89163: FOR_TO
89164: IFFALSE 89286
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
89166: LD_ADDR_VAR 0 7
89170: PUSH
89171: LD_VAR 0 6
89175: PUSH
89176: LD_INT 1
89178: ARRAY
89179: PUSH
89180: LD_VAR 0 5
89184: ARRAY
89185: PUSH
89186: LD_VAR 0 6
89190: PUSH
89191: LD_INT 2
89193: ARRAY
89194: PUSH
89195: LD_VAR 0 5
89199: ARRAY
89200: PUSH
89201: EMPTY
89202: LIST
89203: LIST
89204: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
89205: LD_VAR 0 7
89209: PUSH
89210: LD_INT 1
89212: ARRAY
89213: PPUSH
89214: LD_VAR 0 7
89218: PUSH
89219: LD_INT 2
89221: ARRAY
89222: PPUSH
89223: CALL_OW 428
89227: PUSH
89228: LD_INT 0
89230: EQUAL
89231: IFFALSE 89284
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
89233: LD_VAR 0 1
89237: PPUSH
89238: LD_VAR 0 7
89242: PUSH
89243: LD_INT 1
89245: ARRAY
89246: PPUSH
89247: LD_VAR 0 7
89251: PUSH
89252: LD_INT 2
89254: ARRAY
89255: PPUSH
89256: LD_VAR 0 3
89260: PPUSH
89261: CALL_OW 48
// result := IsPlaced ( unit ) ;
89265: LD_ADDR_VAR 0 4
89269: PUSH
89270: LD_VAR 0 1
89274: PPUSH
89275: CALL_OW 305
89279: ST_TO_ADDR
// exit ;
89280: POP
89281: POP
89282: GO 89288
// end ; end ;
89284: GO 89163
89286: POP
89287: POP
// end ;
89288: LD_VAR 0 4
89292: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
89293: LD_INT 0
89295: PPUSH
89296: PPUSH
89297: PPUSH
// if not side or side > 8 then
89298: LD_VAR 0 1
89302: NOT
89303: PUSH
89304: LD_VAR 0 1
89308: PUSH
89309: LD_INT 8
89311: GREATER
89312: OR
89313: IFFALSE 89317
// exit ;
89315: GO 89504
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
89317: LD_ADDR_VAR 0 4
89321: PUSH
89322: LD_INT 22
89324: PUSH
89325: LD_VAR 0 1
89329: PUSH
89330: EMPTY
89331: LIST
89332: LIST
89333: PUSH
89334: LD_INT 21
89336: PUSH
89337: LD_INT 3
89339: PUSH
89340: EMPTY
89341: LIST
89342: LIST
89343: PUSH
89344: EMPTY
89345: LIST
89346: LIST
89347: PPUSH
89348: CALL_OW 69
89352: ST_TO_ADDR
// if not tmp then
89353: LD_VAR 0 4
89357: NOT
89358: IFFALSE 89362
// exit ;
89360: GO 89504
// enable_addtolog := true ;
89362: LD_ADDR_OWVAR 81
89366: PUSH
89367: LD_INT 1
89369: ST_TO_ADDR
// AddToLog ( [ ) ;
89370: LD_STRING [
89372: PPUSH
89373: CALL_OW 561
// for i in tmp do
89377: LD_ADDR_VAR 0 3
89381: PUSH
89382: LD_VAR 0 4
89386: PUSH
89387: FOR_IN
89388: IFFALSE 89495
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
89390: LD_STRING [
89392: PUSH
89393: LD_VAR 0 3
89397: PPUSH
89398: CALL_OW 266
89402: STR
89403: PUSH
89404: LD_STRING , 
89406: STR
89407: PUSH
89408: LD_VAR 0 3
89412: PPUSH
89413: CALL_OW 250
89417: STR
89418: PUSH
89419: LD_STRING , 
89421: STR
89422: PUSH
89423: LD_VAR 0 3
89427: PPUSH
89428: CALL_OW 251
89432: STR
89433: PUSH
89434: LD_STRING , 
89436: STR
89437: PUSH
89438: LD_VAR 0 3
89442: PPUSH
89443: CALL_OW 254
89447: STR
89448: PUSH
89449: LD_STRING , 
89451: STR
89452: PUSH
89453: LD_VAR 0 3
89457: PPUSH
89458: LD_INT 1
89460: PPUSH
89461: CALL_OW 268
89465: STR
89466: PUSH
89467: LD_STRING , 
89469: STR
89470: PUSH
89471: LD_VAR 0 3
89475: PPUSH
89476: LD_INT 2
89478: PPUSH
89479: CALL_OW 268
89483: STR
89484: PUSH
89485: LD_STRING ],
89487: STR
89488: PPUSH
89489: CALL_OW 561
// end ;
89493: GO 89387
89495: POP
89496: POP
// AddToLog ( ]; ) ;
89497: LD_STRING ];
89499: PPUSH
89500: CALL_OW 561
// end ;
89504: LD_VAR 0 2
89508: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
89509: LD_INT 0
89511: PPUSH
89512: PPUSH
89513: PPUSH
89514: PPUSH
89515: PPUSH
// if not area or not rate or not max then
89516: LD_VAR 0 1
89520: NOT
89521: PUSH
89522: LD_VAR 0 2
89526: NOT
89527: OR
89528: PUSH
89529: LD_VAR 0 4
89533: NOT
89534: OR
89535: IFFALSE 89539
// exit ;
89537: GO 89731
// while 1 do
89539: LD_INT 1
89541: IFFALSE 89731
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
89543: LD_ADDR_VAR 0 9
89547: PUSH
89548: LD_VAR 0 1
89552: PPUSH
89553: LD_INT 1
89555: PPUSH
89556: CALL_OW 287
89560: PUSH
89561: LD_INT 10
89563: MUL
89564: ST_TO_ADDR
// r := rate / 10 ;
89565: LD_ADDR_VAR 0 7
89569: PUSH
89570: LD_VAR 0 2
89574: PUSH
89575: LD_INT 10
89577: DIVREAL
89578: ST_TO_ADDR
// time := 1 1$00 ;
89579: LD_ADDR_VAR 0 8
89583: PUSH
89584: LD_INT 2100
89586: ST_TO_ADDR
// if amount < min then
89587: LD_VAR 0 9
89591: PUSH
89592: LD_VAR 0 3
89596: LESS
89597: IFFALSE 89615
// r := r * 2 else
89599: LD_ADDR_VAR 0 7
89603: PUSH
89604: LD_VAR 0 7
89608: PUSH
89609: LD_INT 2
89611: MUL
89612: ST_TO_ADDR
89613: GO 89641
// if amount > max then
89615: LD_VAR 0 9
89619: PUSH
89620: LD_VAR 0 4
89624: GREATER
89625: IFFALSE 89641
// r := r / 2 ;
89627: LD_ADDR_VAR 0 7
89631: PUSH
89632: LD_VAR 0 7
89636: PUSH
89637: LD_INT 2
89639: DIVREAL
89640: ST_TO_ADDR
// time := time / r ;
89641: LD_ADDR_VAR 0 8
89645: PUSH
89646: LD_VAR 0 8
89650: PUSH
89651: LD_VAR 0 7
89655: DIVREAL
89656: ST_TO_ADDR
// if time < 0 then
89657: LD_VAR 0 8
89661: PUSH
89662: LD_INT 0
89664: LESS
89665: IFFALSE 89682
// time := time * - 1 ;
89667: LD_ADDR_VAR 0 8
89671: PUSH
89672: LD_VAR 0 8
89676: PUSH
89677: LD_INT 1
89679: NEG
89680: MUL
89681: ST_TO_ADDR
// wait ( time ) ;
89682: LD_VAR 0 8
89686: PPUSH
89687: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
89691: LD_INT 35
89693: PPUSH
89694: LD_INT 875
89696: PPUSH
89697: CALL_OW 12
89701: PPUSH
89702: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
89706: LD_INT 1
89708: PPUSH
89709: LD_INT 5
89711: PPUSH
89712: CALL_OW 12
89716: PPUSH
89717: LD_VAR 0 1
89721: PPUSH
89722: LD_INT 1
89724: PPUSH
89725: CALL_OW 55
// end ;
89729: GO 89539
// end ;
89731: LD_VAR 0 5
89735: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
89736: LD_INT 0
89738: PPUSH
89739: PPUSH
89740: PPUSH
89741: PPUSH
89742: PPUSH
89743: PPUSH
89744: PPUSH
89745: PPUSH
// if not turrets or not factories then
89746: LD_VAR 0 1
89750: NOT
89751: PUSH
89752: LD_VAR 0 2
89756: NOT
89757: OR
89758: IFFALSE 89762
// exit ;
89760: GO 90069
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
89762: LD_ADDR_VAR 0 10
89766: PUSH
89767: LD_INT 5
89769: PUSH
89770: LD_INT 6
89772: PUSH
89773: EMPTY
89774: LIST
89775: LIST
89776: PUSH
89777: LD_INT 2
89779: PUSH
89780: LD_INT 4
89782: PUSH
89783: EMPTY
89784: LIST
89785: LIST
89786: PUSH
89787: LD_INT 3
89789: PUSH
89790: LD_INT 5
89792: PUSH
89793: EMPTY
89794: LIST
89795: LIST
89796: PUSH
89797: EMPTY
89798: LIST
89799: LIST
89800: LIST
89801: PUSH
89802: LD_INT 24
89804: PUSH
89805: LD_INT 25
89807: PUSH
89808: EMPTY
89809: LIST
89810: LIST
89811: PUSH
89812: LD_INT 23
89814: PUSH
89815: LD_INT 27
89817: PUSH
89818: EMPTY
89819: LIST
89820: LIST
89821: PUSH
89822: EMPTY
89823: LIST
89824: LIST
89825: PUSH
89826: LD_INT 42
89828: PUSH
89829: LD_INT 43
89831: PUSH
89832: EMPTY
89833: LIST
89834: LIST
89835: PUSH
89836: LD_INT 44
89838: PUSH
89839: LD_INT 46
89841: PUSH
89842: EMPTY
89843: LIST
89844: LIST
89845: PUSH
89846: LD_INT 45
89848: PUSH
89849: LD_INT 47
89851: PUSH
89852: EMPTY
89853: LIST
89854: LIST
89855: PUSH
89856: EMPTY
89857: LIST
89858: LIST
89859: LIST
89860: PUSH
89861: EMPTY
89862: LIST
89863: LIST
89864: LIST
89865: ST_TO_ADDR
// result := [ ] ;
89866: LD_ADDR_VAR 0 3
89870: PUSH
89871: EMPTY
89872: ST_TO_ADDR
// for i in turrets do
89873: LD_ADDR_VAR 0 4
89877: PUSH
89878: LD_VAR 0 1
89882: PUSH
89883: FOR_IN
89884: IFFALSE 90067
// begin nat := GetNation ( i ) ;
89886: LD_ADDR_VAR 0 7
89890: PUSH
89891: LD_VAR 0 4
89895: PPUSH
89896: CALL_OW 248
89900: ST_TO_ADDR
// weapon := 0 ;
89901: LD_ADDR_VAR 0 8
89905: PUSH
89906: LD_INT 0
89908: ST_TO_ADDR
// if not nat then
89909: LD_VAR 0 7
89913: NOT
89914: IFFALSE 89918
// continue ;
89916: GO 89883
// for j in list [ nat ] do
89918: LD_ADDR_VAR 0 5
89922: PUSH
89923: LD_VAR 0 10
89927: PUSH
89928: LD_VAR 0 7
89932: ARRAY
89933: PUSH
89934: FOR_IN
89935: IFFALSE 89976
// if GetBWeapon ( i ) = j [ 1 ] then
89937: LD_VAR 0 4
89941: PPUSH
89942: CALL_OW 269
89946: PUSH
89947: LD_VAR 0 5
89951: PUSH
89952: LD_INT 1
89954: ARRAY
89955: EQUAL
89956: IFFALSE 89974
// begin weapon := j [ 2 ] ;
89958: LD_ADDR_VAR 0 8
89962: PUSH
89963: LD_VAR 0 5
89967: PUSH
89968: LD_INT 2
89970: ARRAY
89971: ST_TO_ADDR
// break ;
89972: GO 89976
// end ;
89974: GO 89934
89976: POP
89977: POP
// if not weapon then
89978: LD_VAR 0 8
89982: NOT
89983: IFFALSE 89987
// continue ;
89985: GO 89883
// for k in factories do
89987: LD_ADDR_VAR 0 6
89991: PUSH
89992: LD_VAR 0 2
89996: PUSH
89997: FOR_IN
89998: IFFALSE 90063
// begin weapons := AvailableWeaponList ( k ) ;
90000: LD_ADDR_VAR 0 9
90004: PUSH
90005: LD_VAR 0 6
90009: PPUSH
90010: CALL_OW 478
90014: ST_TO_ADDR
// if not weapons then
90015: LD_VAR 0 9
90019: NOT
90020: IFFALSE 90024
// continue ;
90022: GO 89997
// if weapon in weapons then
90024: LD_VAR 0 8
90028: PUSH
90029: LD_VAR 0 9
90033: IN
90034: IFFALSE 90061
// begin result := [ i , weapon ] ;
90036: LD_ADDR_VAR 0 3
90040: PUSH
90041: LD_VAR 0 4
90045: PUSH
90046: LD_VAR 0 8
90050: PUSH
90051: EMPTY
90052: LIST
90053: LIST
90054: ST_TO_ADDR
// exit ;
90055: POP
90056: POP
90057: POP
90058: POP
90059: GO 90069
// end ; end ;
90061: GO 89997
90063: POP
90064: POP
// end ;
90065: GO 89883
90067: POP
90068: POP
// end ;
90069: LD_VAR 0 3
90073: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
90074: LD_INT 0
90076: PPUSH
// if not side or side > 8 then
90077: LD_VAR 0 3
90081: NOT
90082: PUSH
90083: LD_VAR 0 3
90087: PUSH
90088: LD_INT 8
90090: GREATER
90091: OR
90092: IFFALSE 90096
// exit ;
90094: GO 90155
// if not range then
90096: LD_VAR 0 4
90100: NOT
90101: IFFALSE 90112
// range := - 12 ;
90103: LD_ADDR_VAR 0 4
90107: PUSH
90108: LD_INT 12
90110: NEG
90111: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
90112: LD_VAR 0 1
90116: PPUSH
90117: LD_VAR 0 2
90121: PPUSH
90122: LD_VAR 0 3
90126: PPUSH
90127: LD_VAR 0 4
90131: PPUSH
90132: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
90136: LD_VAR 0 1
90140: PPUSH
90141: LD_VAR 0 2
90145: PPUSH
90146: LD_VAR 0 3
90150: PPUSH
90151: CALL_OW 331
// end ;
90155: LD_VAR 0 5
90159: RET
// export function Video ( mode ) ; begin
90160: LD_INT 0
90162: PPUSH
// ingame_video = mode ;
90163: LD_ADDR_OWVAR 52
90167: PUSH
90168: LD_VAR 0 1
90172: ST_TO_ADDR
// interface_hidden = mode ;
90173: LD_ADDR_OWVAR 54
90177: PUSH
90178: LD_VAR 0 1
90182: ST_TO_ADDR
// end ;
90183: LD_VAR 0 2
90187: RET
// export function Join ( array , element ) ; begin
90188: LD_INT 0
90190: PPUSH
// result := array ^ element ;
90191: LD_ADDR_VAR 0 3
90195: PUSH
90196: LD_VAR 0 1
90200: PUSH
90201: LD_VAR 0 2
90205: ADD
90206: ST_TO_ADDR
// end ;
90207: LD_VAR 0 3
90211: RET
// export function JoinUnion ( array , element ) ; begin
90212: LD_INT 0
90214: PPUSH
// result := array union element ;
90215: LD_ADDR_VAR 0 3
90219: PUSH
90220: LD_VAR 0 1
90224: PUSH
90225: LD_VAR 0 2
90229: UNION
90230: ST_TO_ADDR
// end ;
90231: LD_VAR 0 3
90235: RET
// export function GetBehemoths ( side ) ; begin
90236: LD_INT 0
90238: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
90239: LD_ADDR_VAR 0 2
90243: PUSH
90244: LD_INT 22
90246: PUSH
90247: LD_VAR 0 1
90251: PUSH
90252: EMPTY
90253: LIST
90254: LIST
90255: PUSH
90256: LD_INT 31
90258: PUSH
90259: LD_INT 25
90261: PUSH
90262: EMPTY
90263: LIST
90264: LIST
90265: PUSH
90266: EMPTY
90267: LIST
90268: LIST
90269: PPUSH
90270: CALL_OW 69
90274: ST_TO_ADDR
// end ;
90275: LD_VAR 0 2
90279: RET
// export function Shuffle ( array ) ; var i , index ; begin
90280: LD_INT 0
90282: PPUSH
90283: PPUSH
90284: PPUSH
// result := [ ] ;
90285: LD_ADDR_VAR 0 2
90289: PUSH
90290: EMPTY
90291: ST_TO_ADDR
// if not array then
90292: LD_VAR 0 1
90296: NOT
90297: IFFALSE 90301
// exit ;
90299: GO 90400
// Randomize ;
90301: CALL_OW 10
// for i = array downto 1 do
90305: LD_ADDR_VAR 0 3
90309: PUSH
90310: DOUBLE
90311: LD_VAR 0 1
90315: INC
90316: ST_TO_ADDR
90317: LD_INT 1
90319: PUSH
90320: FOR_DOWNTO
90321: IFFALSE 90398
// begin index := rand ( 1 , array ) ;
90323: LD_ADDR_VAR 0 4
90327: PUSH
90328: LD_INT 1
90330: PPUSH
90331: LD_VAR 0 1
90335: PPUSH
90336: CALL_OW 12
90340: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
90341: LD_ADDR_VAR 0 2
90345: PUSH
90346: LD_VAR 0 2
90350: PPUSH
90351: LD_VAR 0 2
90355: PUSH
90356: LD_INT 1
90358: PLUS
90359: PPUSH
90360: LD_VAR 0 1
90364: PUSH
90365: LD_VAR 0 4
90369: ARRAY
90370: PPUSH
90371: CALL_OW 2
90375: ST_TO_ADDR
// array := Delete ( array , index ) ;
90376: LD_ADDR_VAR 0 1
90380: PUSH
90381: LD_VAR 0 1
90385: PPUSH
90386: LD_VAR 0 4
90390: PPUSH
90391: CALL_OW 3
90395: ST_TO_ADDR
// end ;
90396: GO 90320
90398: POP
90399: POP
// end ;
90400: LD_VAR 0 2
90404: RET
// export function GetBaseMaterials ( base ) ; begin
90405: LD_INT 0
90407: PPUSH
// result := [ 0 , 0 , 0 ] ;
90408: LD_ADDR_VAR 0 2
90412: PUSH
90413: LD_INT 0
90415: PUSH
90416: LD_INT 0
90418: PUSH
90419: LD_INT 0
90421: PUSH
90422: EMPTY
90423: LIST
90424: LIST
90425: LIST
90426: ST_TO_ADDR
// if not base then
90427: LD_VAR 0 1
90431: NOT
90432: IFFALSE 90436
// exit ;
90434: GO 90485
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
90436: LD_ADDR_VAR 0 2
90440: PUSH
90441: LD_VAR 0 1
90445: PPUSH
90446: LD_INT 1
90448: PPUSH
90449: CALL_OW 275
90453: PUSH
90454: LD_VAR 0 1
90458: PPUSH
90459: LD_INT 2
90461: PPUSH
90462: CALL_OW 275
90466: PUSH
90467: LD_VAR 0 1
90471: PPUSH
90472: LD_INT 3
90474: PPUSH
90475: CALL_OW 275
90479: PUSH
90480: EMPTY
90481: LIST
90482: LIST
90483: LIST
90484: ST_TO_ADDR
// end ; end_of_file
90485: LD_VAR 0 2
90489: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
90490: GO 90492
90492: DISABLE
// begin ru_radar := 98 ;
90493: LD_ADDR_EXP 93
90497: PUSH
90498: LD_INT 98
90500: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
90501: LD_ADDR_EXP 94
90505: PUSH
90506: LD_INT 89
90508: ST_TO_ADDR
// us_hack := 99 ;
90509: LD_ADDR_EXP 95
90513: PUSH
90514: LD_INT 99
90516: ST_TO_ADDR
// us_artillery := 97 ;
90517: LD_ADDR_EXP 96
90521: PUSH
90522: LD_INT 97
90524: ST_TO_ADDR
// ar_bio_bomb := 91 ;
90525: LD_ADDR_EXP 97
90529: PUSH
90530: LD_INT 91
90532: ST_TO_ADDR
// end ; end_of_file end_of_file
90533: END
// export StreamModeActive , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun ; every 0 0$1 do
90534: GO 90536
90536: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
90537: LD_STRING initStreamRollete();
90539: PPUSH
90540: CALL_OW 559
// InitStreamMode ;
90544: CALL 90549 0 0
// end ;
90548: END
// function InitStreamMode ; begin
90549: LD_INT 0
90551: PPUSH
// streamModeActive := false ;
90552: LD_ADDR_EXP 98
90556: PUSH
90557: LD_INT 0
90559: ST_TO_ADDR
// sRocket := false ;
90560: LD_ADDR_EXP 101
90564: PUSH
90565: LD_INT 0
90567: ST_TO_ADDR
// sSpeed := false ;
90568: LD_ADDR_EXP 100
90572: PUSH
90573: LD_INT 0
90575: ST_TO_ADDR
// sEngine := false ;
90576: LD_ADDR_EXP 102
90580: PUSH
90581: LD_INT 0
90583: ST_TO_ADDR
// sSpec := false ;
90584: LD_ADDR_EXP 99
90588: PUSH
90589: LD_INT 0
90591: ST_TO_ADDR
// sLevel := false ;
90592: LD_ADDR_EXP 103
90596: PUSH
90597: LD_INT 0
90599: ST_TO_ADDR
// sArmoury := false ;
90600: LD_ADDR_EXP 104
90604: PUSH
90605: LD_INT 0
90607: ST_TO_ADDR
// sRadar := false ;
90608: LD_ADDR_EXP 105
90612: PUSH
90613: LD_INT 0
90615: ST_TO_ADDR
// sBunker := false ;
90616: LD_ADDR_EXP 106
90620: PUSH
90621: LD_INT 0
90623: ST_TO_ADDR
// sHack := false ;
90624: LD_ADDR_EXP 107
90628: PUSH
90629: LD_INT 0
90631: ST_TO_ADDR
// sFire := false ;
90632: LD_ADDR_EXP 108
90636: PUSH
90637: LD_INT 0
90639: ST_TO_ADDR
// sRefresh := false ;
90640: LD_ADDR_EXP 109
90644: PUSH
90645: LD_INT 0
90647: ST_TO_ADDR
// sExp := false ;
90648: LD_ADDR_EXP 110
90652: PUSH
90653: LD_INT 0
90655: ST_TO_ADDR
// sDepot := false ;
90656: LD_ADDR_EXP 111
90660: PUSH
90661: LD_INT 0
90663: ST_TO_ADDR
// sFlag := false ;
90664: LD_ADDR_EXP 112
90668: PUSH
90669: LD_INT 0
90671: ST_TO_ADDR
// sSold := false ;
90672: LD_ADDR_EXP 113
90676: PUSH
90677: LD_INT 0
90679: ST_TO_ADDR
// sDiff := false ;
90680: LD_ADDR_EXP 114
90684: PUSH
90685: LD_INT 0
90687: ST_TO_ADDR
// sTiger := false ;
90688: LD_ADDR_EXP 115
90692: PUSH
90693: LD_INT 0
90695: ST_TO_ADDR
// sBomb := false ;
90696: LD_ADDR_EXP 116
90700: PUSH
90701: LD_INT 0
90703: ST_TO_ADDR
// sFog := false ;
90704: LD_ADDR_EXP 117
90708: PUSH
90709: LD_INT 0
90711: ST_TO_ADDR
// sReset := false ;
90712: LD_ADDR_EXP 118
90716: PUSH
90717: LD_INT 0
90719: ST_TO_ADDR
// sSun := false ;
90720: LD_ADDR_EXP 119
90724: PUSH
90725: LD_INT 0
90727: ST_TO_ADDR
// end ;
90728: LD_VAR 0 1
90732: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
90733: LD_VAR 0 2
90737: PUSH
90738: LD_INT 100
90740: EQUAL
90741: IFFALSE 91150
// begin if not StreamModeActive then
90743: LD_EXP 98
90747: NOT
90748: IFFALSE 90758
// StreamModeActive := true ;
90750: LD_ADDR_EXP 98
90754: PUSH
90755: LD_INT 1
90757: ST_TO_ADDR
// if p3 = 0 then
90758: LD_VAR 0 3
90762: PUSH
90763: LD_INT 0
90765: EQUAL
90766: IFFALSE 90772
// InitStreamMode ;
90768: CALL 90549 0 0
// if p3 = 1 then
90772: LD_VAR 0 3
90776: PUSH
90777: LD_INT 1
90779: EQUAL
90780: IFFALSE 90790
// sRocket := true ;
90782: LD_ADDR_EXP 101
90786: PUSH
90787: LD_INT 1
90789: ST_TO_ADDR
// if p3 = 2 then
90790: LD_VAR 0 3
90794: PUSH
90795: LD_INT 2
90797: EQUAL
90798: IFFALSE 90808
// sSpeed := true ;
90800: LD_ADDR_EXP 100
90804: PUSH
90805: LD_INT 1
90807: ST_TO_ADDR
// if p3 = 3 then
90808: LD_VAR 0 3
90812: PUSH
90813: LD_INT 3
90815: EQUAL
90816: IFFALSE 90826
// sEngine := true ;
90818: LD_ADDR_EXP 102
90822: PUSH
90823: LD_INT 1
90825: ST_TO_ADDR
// if p3 = 4 then
90826: LD_VAR 0 3
90830: PUSH
90831: LD_INT 4
90833: EQUAL
90834: IFFALSE 90844
// sSpec := true ;
90836: LD_ADDR_EXP 99
90840: PUSH
90841: LD_INT 1
90843: ST_TO_ADDR
// if p3 = 5 then
90844: LD_VAR 0 3
90848: PUSH
90849: LD_INT 5
90851: EQUAL
90852: IFFALSE 90862
// sLevel := true ;
90854: LD_ADDR_EXP 103
90858: PUSH
90859: LD_INT 1
90861: ST_TO_ADDR
// if p3 = 6 then
90862: LD_VAR 0 3
90866: PUSH
90867: LD_INT 6
90869: EQUAL
90870: IFFALSE 90880
// sArmoury := true ;
90872: LD_ADDR_EXP 104
90876: PUSH
90877: LD_INT 1
90879: ST_TO_ADDR
// if p3 = 7 then
90880: LD_VAR 0 3
90884: PUSH
90885: LD_INT 7
90887: EQUAL
90888: IFFALSE 90898
// sRadar := true ;
90890: LD_ADDR_EXP 105
90894: PUSH
90895: LD_INT 1
90897: ST_TO_ADDR
// if p3 = 8 then
90898: LD_VAR 0 3
90902: PUSH
90903: LD_INT 8
90905: EQUAL
90906: IFFALSE 90916
// sBunker := true ;
90908: LD_ADDR_EXP 106
90912: PUSH
90913: LD_INT 1
90915: ST_TO_ADDR
// if p3 = 9 then
90916: LD_VAR 0 3
90920: PUSH
90921: LD_INT 9
90923: EQUAL
90924: IFFALSE 90934
// sHack := true ;
90926: LD_ADDR_EXP 107
90930: PUSH
90931: LD_INT 1
90933: ST_TO_ADDR
// if p3 = 10 then
90934: LD_VAR 0 3
90938: PUSH
90939: LD_INT 10
90941: EQUAL
90942: IFFALSE 90952
// sFire := true ;
90944: LD_ADDR_EXP 108
90948: PUSH
90949: LD_INT 1
90951: ST_TO_ADDR
// if p3 = 11 then
90952: LD_VAR 0 3
90956: PUSH
90957: LD_INT 11
90959: EQUAL
90960: IFFALSE 90970
// sRefresh := true ;
90962: LD_ADDR_EXP 109
90966: PUSH
90967: LD_INT 1
90969: ST_TO_ADDR
// if p3 = 12 then
90970: LD_VAR 0 3
90974: PUSH
90975: LD_INT 12
90977: EQUAL
90978: IFFALSE 90988
// sExp := true ;
90980: LD_ADDR_EXP 110
90984: PUSH
90985: LD_INT 1
90987: ST_TO_ADDR
// if p3 = 13 then
90988: LD_VAR 0 3
90992: PUSH
90993: LD_INT 13
90995: EQUAL
90996: IFFALSE 91006
// sDepot := true ;
90998: LD_ADDR_EXP 111
91002: PUSH
91003: LD_INT 1
91005: ST_TO_ADDR
// if p3 = 14 then
91006: LD_VAR 0 3
91010: PUSH
91011: LD_INT 14
91013: EQUAL
91014: IFFALSE 91024
// sFlag := true ;
91016: LD_ADDR_EXP 112
91020: PUSH
91021: LD_INT 1
91023: ST_TO_ADDR
// if p3 = 101 then
91024: LD_VAR 0 3
91028: PUSH
91029: LD_INT 101
91031: EQUAL
91032: IFFALSE 91042
// sSold := true ;
91034: LD_ADDR_EXP 113
91038: PUSH
91039: LD_INT 1
91041: ST_TO_ADDR
// if p3 = 102 then
91042: LD_VAR 0 3
91046: PUSH
91047: LD_INT 102
91049: EQUAL
91050: IFFALSE 91060
// sDiff := true ;
91052: LD_ADDR_EXP 114
91056: PUSH
91057: LD_INT 1
91059: ST_TO_ADDR
// if p3 = 103 then
91060: LD_VAR 0 3
91064: PUSH
91065: LD_INT 103
91067: EQUAL
91068: IFFALSE 91078
// sFog := true ;
91070: LD_ADDR_EXP 117
91074: PUSH
91075: LD_INT 1
91077: ST_TO_ADDR
// if p3 = 104 then
91078: LD_VAR 0 3
91082: PUSH
91083: LD_INT 104
91085: EQUAL
91086: IFFALSE 91096
// sReset := true ;
91088: LD_ADDR_EXP 118
91092: PUSH
91093: LD_INT 1
91095: ST_TO_ADDR
// if p3 = 105 then
91096: LD_VAR 0 3
91100: PUSH
91101: LD_INT 105
91103: EQUAL
91104: IFFALSE 91114
// sSun := true ;
91106: LD_ADDR_EXP 119
91110: PUSH
91111: LD_INT 1
91113: ST_TO_ADDR
// if p3 = 106 then
91114: LD_VAR 0 3
91118: PUSH
91119: LD_INT 106
91121: EQUAL
91122: IFFALSE 91132
// sTiger := true ;
91124: LD_ADDR_EXP 115
91128: PUSH
91129: LD_INT 1
91131: ST_TO_ADDR
// if p3 = 107 then
91132: LD_VAR 0 3
91136: PUSH
91137: LD_INT 107
91139: EQUAL
91140: IFFALSE 91150
// sBomb := true ;
91142: LD_ADDR_EXP 116
91146: PUSH
91147: LD_INT 1
91149: ST_TO_ADDR
// end ; end ;
91150: PPOPN 6
91152: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
91153: LD_EXP 98
91157: PUSH
91158: LD_EXP 101
91162: AND
91163: IFFALSE 91284
91165: GO 91167
91167: DISABLE
91168: LD_INT 0
91170: PPUSH
91171: PPUSH
// begin enable ;
91172: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
91173: LD_ADDR_VAR 0 2
91177: PUSH
91178: LD_INT 22
91180: PUSH
91181: LD_OWVAR 2
91185: PUSH
91186: EMPTY
91187: LIST
91188: LIST
91189: PUSH
91190: LD_INT 2
91192: PUSH
91193: LD_INT 34
91195: PUSH
91196: LD_INT 7
91198: PUSH
91199: EMPTY
91200: LIST
91201: LIST
91202: PUSH
91203: LD_INT 34
91205: PUSH
91206: LD_INT 45
91208: PUSH
91209: EMPTY
91210: LIST
91211: LIST
91212: PUSH
91213: LD_INT 34
91215: PUSH
91216: LD_INT 28
91218: PUSH
91219: EMPTY
91220: LIST
91221: LIST
91222: PUSH
91223: LD_INT 34
91225: PUSH
91226: LD_INT 47
91228: PUSH
91229: EMPTY
91230: LIST
91231: LIST
91232: PUSH
91233: EMPTY
91234: LIST
91235: LIST
91236: LIST
91237: LIST
91238: LIST
91239: PUSH
91240: EMPTY
91241: LIST
91242: LIST
91243: PPUSH
91244: CALL_OW 69
91248: ST_TO_ADDR
// if not tmp then
91249: LD_VAR 0 2
91253: NOT
91254: IFFALSE 91258
// exit ;
91256: GO 91284
// for i in tmp do
91258: LD_ADDR_VAR 0 1
91262: PUSH
91263: LD_VAR 0 2
91267: PUSH
91268: FOR_IN
91269: IFFALSE 91282
// begin DestroyUnit ( i ) ;
91271: LD_VAR 0 1
91275: PPUSH
91276: CALL_OW 65
// end ;
91280: GO 91268
91282: POP
91283: POP
// end ;
91284: PPOPN 2
91286: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
91287: LD_EXP 98
91291: PUSH
91292: LD_EXP 102
91296: AND
91297: IFFALSE 91378
91299: GO 91301
91301: DISABLE
91302: LD_INT 0
91304: PPUSH
91305: PPUSH
// begin enable ;
91306: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
91307: LD_ADDR_VAR 0 2
91311: PUSH
91312: LD_INT 22
91314: PUSH
91315: LD_OWVAR 2
91319: PUSH
91320: EMPTY
91321: LIST
91322: LIST
91323: PUSH
91324: LD_INT 32
91326: PUSH
91327: LD_INT 3
91329: PUSH
91330: EMPTY
91331: LIST
91332: LIST
91333: PUSH
91334: EMPTY
91335: LIST
91336: LIST
91337: PPUSH
91338: CALL_OW 69
91342: ST_TO_ADDR
// if not tmp then
91343: LD_VAR 0 2
91347: NOT
91348: IFFALSE 91352
// exit ;
91350: GO 91378
// for i in tmp do
91352: LD_ADDR_VAR 0 1
91356: PUSH
91357: LD_VAR 0 2
91361: PUSH
91362: FOR_IN
91363: IFFALSE 91376
// begin DestroyUnit ( i ) ;
91365: LD_VAR 0 1
91369: PPUSH
91370: CALL_OW 65
// end ;
91374: GO 91362
91376: POP
91377: POP
// end ;
91378: PPOPN 2
91380: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
91381: LD_EXP 98
91385: PUSH
91386: LD_EXP 99
91390: AND
91391: IFFALSE 91484
91393: GO 91395
91395: DISABLE
91396: LD_INT 0
91398: PPUSH
// begin enable ;
91399: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
91400: LD_ADDR_VAR 0 1
91404: PUSH
91405: LD_INT 22
91407: PUSH
91408: LD_OWVAR 2
91412: PUSH
91413: EMPTY
91414: LIST
91415: LIST
91416: PUSH
91417: LD_INT 2
91419: PUSH
91420: LD_INT 25
91422: PUSH
91423: LD_INT 5
91425: PUSH
91426: EMPTY
91427: LIST
91428: LIST
91429: PUSH
91430: LD_INT 25
91432: PUSH
91433: LD_INT 9
91435: PUSH
91436: EMPTY
91437: LIST
91438: LIST
91439: PUSH
91440: LD_INT 25
91442: PUSH
91443: LD_INT 8
91445: PUSH
91446: EMPTY
91447: LIST
91448: LIST
91449: PUSH
91450: EMPTY
91451: LIST
91452: LIST
91453: LIST
91454: LIST
91455: PUSH
91456: EMPTY
91457: LIST
91458: LIST
91459: PPUSH
91460: CALL_OW 69
91464: PUSH
91465: FOR_IN
91466: IFFALSE 91482
// begin SetClass ( i , 1 ) ;
91468: LD_VAR 0 1
91472: PPUSH
91473: LD_INT 1
91475: PPUSH
91476: CALL_OW 336
// end ;
91480: GO 91465
91482: POP
91483: POP
// end ;
91484: PPOPN 1
91486: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
91487: LD_EXP 98
91491: PUSH
91492: LD_EXP 100
91496: AND
91497: PUSH
91498: LD_OWVAR 65
91502: PUSH
91503: LD_INT 7
91505: LESS
91506: AND
91507: IFFALSE 91521
91509: GO 91511
91511: DISABLE
// begin enable ;
91512: ENABLE
// game_speed := 7 ;
91513: LD_ADDR_OWVAR 65
91517: PUSH
91518: LD_INT 7
91520: ST_TO_ADDR
// end ;
91521: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
91522: LD_EXP 98
91526: PUSH
91527: LD_EXP 103
91531: AND
91532: IFFALSE 91734
91534: GO 91536
91536: DISABLE
91537: LD_INT 0
91539: PPUSH
91540: PPUSH
91541: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
91542: LD_ADDR_VAR 0 3
91546: PUSH
91547: LD_INT 81
91549: PUSH
91550: LD_OWVAR 2
91554: PUSH
91555: EMPTY
91556: LIST
91557: LIST
91558: PUSH
91559: LD_INT 21
91561: PUSH
91562: LD_INT 1
91564: PUSH
91565: EMPTY
91566: LIST
91567: LIST
91568: PUSH
91569: EMPTY
91570: LIST
91571: LIST
91572: PPUSH
91573: CALL_OW 69
91577: ST_TO_ADDR
// if not tmp then
91578: LD_VAR 0 3
91582: NOT
91583: IFFALSE 91587
// exit ;
91585: GO 91734
// if tmp > 5 then
91587: LD_VAR 0 3
91591: PUSH
91592: LD_INT 5
91594: GREATER
91595: IFFALSE 91607
// k := 5 else
91597: LD_ADDR_VAR 0 2
91601: PUSH
91602: LD_INT 5
91604: ST_TO_ADDR
91605: GO 91617
// k := tmp ;
91607: LD_ADDR_VAR 0 2
91611: PUSH
91612: LD_VAR 0 3
91616: ST_TO_ADDR
// for i := 1 to k do
91617: LD_ADDR_VAR 0 1
91621: PUSH
91622: DOUBLE
91623: LD_INT 1
91625: DEC
91626: ST_TO_ADDR
91627: LD_VAR 0 2
91631: PUSH
91632: FOR_TO
91633: IFFALSE 91732
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
91635: LD_VAR 0 3
91639: PUSH
91640: LD_VAR 0 1
91644: ARRAY
91645: PPUSH
91646: LD_VAR 0 1
91650: PUSH
91651: LD_INT 4
91653: MOD
91654: PUSH
91655: LD_INT 1
91657: PLUS
91658: PPUSH
91659: CALL_OW 259
91663: PUSH
91664: LD_INT 10
91666: LESS
91667: IFFALSE 91730
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
91669: LD_VAR 0 3
91673: PUSH
91674: LD_VAR 0 1
91678: ARRAY
91679: PPUSH
91680: LD_VAR 0 1
91684: PUSH
91685: LD_INT 4
91687: MOD
91688: PUSH
91689: LD_INT 1
91691: PLUS
91692: PPUSH
91693: LD_VAR 0 3
91697: PUSH
91698: LD_VAR 0 1
91702: ARRAY
91703: PPUSH
91704: LD_VAR 0 1
91708: PUSH
91709: LD_INT 4
91711: MOD
91712: PUSH
91713: LD_INT 1
91715: PLUS
91716: PPUSH
91717: CALL_OW 259
91721: PUSH
91722: LD_INT 1
91724: PLUS
91725: PPUSH
91726: CALL_OW 237
91730: GO 91632
91732: POP
91733: POP
// end ;
91734: PPOPN 3
91736: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
91737: LD_EXP 98
91741: PUSH
91742: LD_EXP 104
91746: AND
91747: IFFALSE 91767
91749: GO 91751
91751: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
91752: LD_INT 4
91754: PPUSH
91755: LD_OWVAR 2
91759: PPUSH
91760: LD_INT 0
91762: PPUSH
91763: CALL_OW 324
91767: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
91768: LD_EXP 98
91772: PUSH
91773: LD_EXP 105
91777: AND
91778: IFFALSE 91877
91780: GO 91782
91782: DISABLE
91783: LD_INT 0
91785: PPUSH
91786: PPUSH
// begin enable ;
91787: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
91788: LD_ADDR_VAR 0 2
91792: PUSH
91793: LD_INT 22
91795: PUSH
91796: LD_OWVAR 2
91800: PUSH
91801: EMPTY
91802: LIST
91803: LIST
91804: PUSH
91805: LD_INT 2
91807: PUSH
91808: LD_INT 34
91810: PUSH
91811: LD_INT 11
91813: PUSH
91814: EMPTY
91815: LIST
91816: LIST
91817: PUSH
91818: LD_INT 34
91820: PUSH
91821: LD_INT 30
91823: PUSH
91824: EMPTY
91825: LIST
91826: LIST
91827: PUSH
91828: EMPTY
91829: LIST
91830: LIST
91831: LIST
91832: PUSH
91833: EMPTY
91834: LIST
91835: LIST
91836: PPUSH
91837: CALL_OW 69
91841: ST_TO_ADDR
// if not tmp then
91842: LD_VAR 0 2
91846: NOT
91847: IFFALSE 91851
// exit ;
91849: GO 91877
// for i in tmp do
91851: LD_ADDR_VAR 0 1
91855: PUSH
91856: LD_VAR 0 2
91860: PUSH
91861: FOR_IN
91862: IFFALSE 91875
// begin DestroyUnit ( i ) ;
91864: LD_VAR 0 1
91868: PPUSH
91869: CALL_OW 65
// end ;
91873: GO 91861
91875: POP
91876: POP
// end ;
91877: PPOPN 2
91879: END
// every 0 0$1 trigger StreamModeActive and sBunker do
91880: LD_EXP 98
91884: PUSH
91885: LD_EXP 106
91889: AND
91890: IFFALSE 91910
91892: GO 91894
91894: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
91895: LD_INT 32
91897: PPUSH
91898: LD_OWVAR 2
91902: PPUSH
91903: LD_INT 0
91905: PPUSH
91906: CALL_OW 324
91910: END
// every 0 0$1 trigger StreamModeActive and sHack do
91911: LD_EXP 98
91915: PUSH
91916: LD_EXP 107
91920: AND
91921: IFFALSE 91941
91923: GO 91925
91925: DISABLE
// SetTech ( tech_Virus , your_side , state_disabled ) ;
91926: LD_INT 33
91928: PPUSH
91929: LD_OWVAR 2
91933: PPUSH
91934: LD_INT 0
91936: PPUSH
91937: CALL_OW 322
91941: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
91942: LD_EXP 98
91946: PUSH
91947: LD_EXP 108
91951: AND
91952: IFFALSE 92031
91954: GO 91956
91956: DISABLE
91957: LD_INT 0
91959: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
91960: LD_ADDR_VAR 0 1
91964: PUSH
91965: LD_INT 22
91967: PUSH
91968: LD_OWVAR 2
91972: PUSH
91973: EMPTY
91974: LIST
91975: LIST
91976: PUSH
91977: LD_INT 21
91979: PUSH
91980: LD_INT 3
91982: PUSH
91983: EMPTY
91984: LIST
91985: LIST
91986: PUSH
91987: EMPTY
91988: LIST
91989: LIST
91990: PPUSH
91991: CALL_OW 69
91995: ST_TO_ADDR
// if not tmp then
91996: LD_VAR 0 1
92000: NOT
92001: IFFALSE 92005
// exit ;
92003: GO 92031
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
92005: LD_VAR 0 1
92009: PUSH
92010: LD_INT 1
92012: PPUSH
92013: LD_VAR 0 1
92017: PPUSH
92018: CALL_OW 12
92022: ARRAY
92023: PPUSH
92024: LD_INT 100
92026: PPUSH
92027: CALL_OW 234
// end ;
92031: PPOPN 1
92033: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
92034: LD_EXP 98
92038: PUSH
92039: LD_EXP 110
92043: AND
92044: IFFALSE 92142
92046: GO 92048
92048: DISABLE
92049: LD_INT 0
92051: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
92052: LD_ADDR_VAR 0 1
92056: PUSH
92057: LD_INT 22
92059: PUSH
92060: LD_OWVAR 2
92064: PUSH
92065: EMPTY
92066: LIST
92067: LIST
92068: PUSH
92069: LD_INT 21
92071: PUSH
92072: LD_INT 1
92074: PUSH
92075: EMPTY
92076: LIST
92077: LIST
92078: PUSH
92079: EMPTY
92080: LIST
92081: LIST
92082: PPUSH
92083: CALL_OW 69
92087: ST_TO_ADDR
// if not tmp then
92088: LD_VAR 0 1
92092: NOT
92093: IFFALSE 92097
// exit ;
92095: GO 92142
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
92097: LD_VAR 0 1
92101: PUSH
92102: LD_INT 1
92104: PPUSH
92105: LD_VAR 0 1
92109: PPUSH
92110: CALL_OW 12
92114: ARRAY
92115: PPUSH
92116: LD_INT 1
92118: PPUSH
92119: LD_INT 4
92121: PPUSH
92122: CALL_OW 12
92126: PPUSH
92127: LD_INT 3000
92129: PPUSH
92130: LD_INT 9000
92132: PPUSH
92133: CALL_OW 12
92137: PPUSH
92138: CALL_OW 492
// end ;
92142: PPOPN 1
92144: END
// every 0 0$1 trigger StreamModeActive and sDepot do
92145: LD_EXP 98
92149: PUSH
92150: LD_EXP 111
92154: AND
92155: IFFALSE 92175
92157: GO 92159
92159: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
92160: LD_INT 1
92162: PPUSH
92163: LD_OWVAR 2
92167: PPUSH
92168: LD_INT 0
92170: PPUSH
92171: CALL_OW 324
92175: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
92176: LD_EXP 98
92180: PUSH
92181: LD_EXP 112
92185: AND
92186: IFFALSE 92269
92188: GO 92190
92190: DISABLE
92191: LD_INT 0
92193: PPUSH
92194: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
92195: LD_ADDR_VAR 0 2
92199: PUSH
92200: LD_INT 22
92202: PUSH
92203: LD_OWVAR 2
92207: PUSH
92208: EMPTY
92209: LIST
92210: LIST
92211: PUSH
92212: LD_INT 21
92214: PUSH
92215: LD_INT 3
92217: PUSH
92218: EMPTY
92219: LIST
92220: LIST
92221: PUSH
92222: EMPTY
92223: LIST
92224: LIST
92225: PPUSH
92226: CALL_OW 69
92230: ST_TO_ADDR
// if not tmp then
92231: LD_VAR 0 2
92235: NOT
92236: IFFALSE 92240
// exit ;
92238: GO 92269
// for i in tmp do
92240: LD_ADDR_VAR 0 1
92244: PUSH
92245: LD_VAR 0 2
92249: PUSH
92250: FOR_IN
92251: IFFALSE 92267
// SetBLevel ( i , 10 ) ;
92253: LD_VAR 0 1
92257: PPUSH
92258: LD_INT 10
92260: PPUSH
92261: CALL_OW 241
92265: GO 92250
92267: POP
92268: POP
// end ;
92269: PPOPN 2
92271: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , tmp ;
92272: LD_EXP 98
92276: PUSH
92277: LD_EXP 113
92281: AND
92282: IFFALSE 92365
92284: GO 92286
92286: DISABLE
92287: LD_INT 0
92289: PPUSH
92290: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
92291: LD_ADDR_VAR 0 2
92295: PUSH
92296: LD_INT 22
92298: PUSH
92299: LD_OWVAR 2
92303: PUSH
92304: EMPTY
92305: LIST
92306: LIST
92307: PUSH
92308: LD_INT 25
92310: PUSH
92311: LD_INT 1
92313: PUSH
92314: EMPTY
92315: LIST
92316: LIST
92317: PUSH
92318: EMPTY
92319: LIST
92320: LIST
92321: PPUSH
92322: CALL_OW 69
92326: ST_TO_ADDR
// if not tmp then
92327: LD_VAR 0 2
92331: NOT
92332: IFFALSE 92336
// exit ;
92334: GO 92365
// for i in tmp do
92336: LD_ADDR_VAR 0 1
92340: PUSH
92341: LD_VAR 0 2
92345: PUSH
92346: FOR_IN
92347: IFFALSE 92363
// SetClass ( i , 4 ) ;
92349: LD_VAR 0 1
92353: PPUSH
92354: LD_INT 4
92356: PPUSH
92357: CALL_OW 336
92361: GO 92346
92363: POP
92364: POP
// end ;
92365: PPOPN 2
92367: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
92368: LD_EXP 98
92372: PUSH
92373: LD_EXP 114
92377: AND
92378: PUSH
92379: LD_OWVAR 67
92383: PUSH
92384: LD_INT 3
92386: LESS
92387: AND
92388: IFFALSE 92407
92390: GO 92392
92392: DISABLE
// Difficulty := Difficulty + 1 ;
92393: LD_ADDR_OWVAR 67
92397: PUSH
92398: LD_OWVAR 67
92402: PUSH
92403: LD_INT 1
92405: PLUS
92406: ST_TO_ADDR
92407: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
92408: LD_EXP 98
92412: PUSH
92413: LD_EXP 115
92417: AND
92418: IFFALSE 92521
92420: GO 92422
92422: DISABLE
92423: LD_INT 0
92425: PPUSH
// begin for i := 1 to 5 do
92426: LD_ADDR_VAR 0 1
92430: PUSH
92431: DOUBLE
92432: LD_INT 1
92434: DEC
92435: ST_TO_ADDR
92436: LD_INT 5
92438: PUSH
92439: FOR_TO
92440: IFFALSE 92519
// begin uc_nation := nation_nature ;
92442: LD_ADDR_OWVAR 21
92446: PUSH
92447: LD_INT 0
92449: ST_TO_ADDR
// uc_side := 0 ;
92450: LD_ADDR_OWVAR 20
92454: PUSH
92455: LD_INT 0
92457: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
92458: LD_ADDR_OWVAR 29
92462: PUSH
92463: LD_INT 12
92465: PUSH
92466: LD_INT 12
92468: PUSH
92469: EMPTY
92470: LIST
92471: LIST
92472: ST_TO_ADDR
// hc_agressivity := 20 ;
92473: LD_ADDR_OWVAR 35
92477: PUSH
92478: LD_INT 20
92480: ST_TO_ADDR
// hc_class := class_tiger ;
92481: LD_ADDR_OWVAR 28
92485: PUSH
92486: LD_INT 14
92488: ST_TO_ADDR
// hc_gallery :=  ;
92489: LD_ADDR_OWVAR 33
92493: PUSH
92494: LD_STRING 
92496: ST_TO_ADDR
// hc_name :=  ;
92497: LD_ADDR_OWVAR 26
92501: PUSH
92502: LD_STRING 
92504: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
92505: CALL_OW 44
92509: PPUSH
92510: LD_INT 0
92512: PPUSH
92513: CALL_OW 51
// end ;
92517: GO 92439
92519: POP
92520: POP
// end ;
92521: PPOPN 1
92523: END
// every 0 0$1 trigger StreamModeActive and sBomb do var i , x , y , result ;
92524: LD_EXP 98
92528: PUSH
92529: LD_EXP 116
92533: AND
92534: IFFALSE 92708
92536: GO 92538
92538: DISABLE
92539: LD_INT 0
92541: PPUSH
92542: PPUSH
92543: PPUSH
92544: PPUSH
// begin result := false ;
92545: LD_ADDR_VAR 0 4
92549: PUSH
92550: LD_INT 0
92552: ST_TO_ADDR
// for i := 1 to 8 do
92553: LD_ADDR_VAR 0 1
92557: PUSH
92558: DOUBLE
92559: LD_INT 1
92561: DEC
92562: ST_TO_ADDR
92563: LD_INT 8
92565: PUSH
92566: FOR_TO
92567: IFFALSE 92678
// begin x := [ 10 , 50 , 90 , 140 ] [ rand ( 1 , 4 ) ] ;
92569: LD_ADDR_VAR 0 2
92573: PUSH
92574: LD_INT 10
92576: PUSH
92577: LD_INT 50
92579: PUSH
92580: LD_INT 90
92582: PUSH
92583: LD_INT 140
92585: PUSH
92586: EMPTY
92587: LIST
92588: LIST
92589: LIST
92590: LIST
92591: PUSH
92592: LD_INT 1
92594: PPUSH
92595: LD_INT 4
92597: PPUSH
92598: CALL_OW 12
92602: ARRAY
92603: ST_TO_ADDR
// y := [ 10 , 50 , 90 , 140 ] [ rand ( 1 , 4 ) ] ;
92604: LD_ADDR_VAR 0 3
92608: PUSH
92609: LD_INT 10
92611: PUSH
92612: LD_INT 50
92614: PUSH
92615: LD_INT 90
92617: PUSH
92618: LD_INT 140
92620: PUSH
92621: EMPTY
92622: LIST
92623: LIST
92624: LIST
92625: LIST
92626: PUSH
92627: LD_INT 1
92629: PPUSH
92630: LD_INT 4
92632: PPUSH
92633: CALL_OW 12
92637: ARRAY
92638: ST_TO_ADDR
// if ValidHex ( x , y ) then
92639: LD_VAR 0 2
92643: PPUSH
92644: LD_VAR 0 3
92648: PPUSH
92649: CALL_OW 488
92653: IFFALSE 92676
// begin result := [ x , y ] ;
92655: LD_ADDR_VAR 0 4
92659: PUSH
92660: LD_VAR 0 2
92664: PUSH
92665: LD_VAR 0 3
92669: PUSH
92670: EMPTY
92671: LIST
92672: LIST
92673: ST_TO_ADDR
// break ;
92674: GO 92678
// end ; end ;
92676: GO 92566
92678: POP
92679: POP
// if result then
92680: LD_VAR 0 4
92684: IFFALSE 92708
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
92686: LD_VAR 0 4
92690: PUSH
92691: LD_INT 1
92693: ARRAY
92694: PPUSH
92695: LD_VAR 0 4
92699: PUSH
92700: LD_INT 2
92702: ARRAY
92703: PPUSH
92704: CALL_OW 429
// end ;
92708: PPOPN 4
92710: END
// every 0 0$1 trigger StreamModeActive and sReset do
92711: LD_EXP 98
92715: PUSH
92716: LD_EXP 118
92720: AND
92721: IFFALSE 92733
92723: GO 92725
92725: DISABLE
// YouLost (  ) ;
92726: LD_STRING 
92728: PPUSH
92729: CALL_OW 104
92733: END
// every 0 0$1 trigger StreamModeActive and sFog do
92734: LD_EXP 98
92738: PUSH
92739: LD_EXP 117
92743: AND
92744: IFFALSE 92758
92746: GO 92748
92748: DISABLE
// FogOff ( your_side ) ;
92749: LD_OWVAR 2
92753: PPUSH
92754: CALL_OW 344
92758: END
// every 0 0$1 trigger StreamModeActive and sSun do
92759: LD_EXP 98
92763: PUSH
92764: LD_EXP 119
92768: AND
92769: IFFALSE 92797
92771: GO 92773
92773: DISABLE
// begin solar_recharge_percent := 0 ;
92774: LD_ADDR_OWVAR 79
92778: PUSH
92779: LD_INT 0
92781: ST_TO_ADDR
// wait ( 5 5$00 ) ;
92782: LD_INT 10500
92784: PPUSH
92785: CALL_OW 67
// solar_recharge_percent := 100 ;
92789: LD_ADDR_OWVAR 79
92793: PUSH
92794: LD_INT 100
92796: ST_TO_ADDR
// end ; end_of_file
92797: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
92798: LD_INT 0
92800: PPUSH
92801: PPUSH
92802: PPUSH
92803: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
92804: LD_VAR 0 1
92808: PPUSH
92809: CALL_OW 264
92813: PUSH
92814: LD_EXP 97
92818: EQUAL
92819: IFFALSE 92891
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
92821: LD_INT 68
92823: PPUSH
92824: LD_VAR 0 1
92828: PPUSH
92829: CALL_OW 255
92833: PPUSH
92834: CALL_OW 321
92838: PUSH
92839: LD_INT 2
92841: EQUAL
92842: IFFALSE 92854
// eff := 70 else
92844: LD_ADDR_VAR 0 6
92848: PUSH
92849: LD_INT 70
92851: ST_TO_ADDR
92852: GO 92862
// eff := 30 ;
92854: LD_ADDR_VAR 0 6
92858: PUSH
92859: LD_INT 30
92861: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
92862: LD_VAR 0 1
92866: PPUSH
92867: CALL_OW 250
92871: PPUSH
92872: LD_VAR 0 1
92876: PPUSH
92877: CALL_OW 251
92881: PPUSH
92882: LD_VAR 0 6
92886: PPUSH
92887: CALL_OW 495
// end ; end ;
92891: LD_VAR 0 4
92895: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
92896: LD_INT 0
92898: PPUSH
92899: PPUSH
92900: PPUSH
92901: PPUSH
92902: PPUSH
92903: PPUSH
// if cmd = 124 then
92904: LD_VAR 0 1
92908: PUSH
92909: LD_INT 124
92911: EQUAL
92912: IFFALSE 93118
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
92914: LD_ADDR_VAR 0 5
92918: PUSH
92919: LD_INT 2
92921: PUSH
92922: LD_INT 34
92924: PUSH
92925: LD_INT 53
92927: PUSH
92928: EMPTY
92929: LIST
92930: LIST
92931: PUSH
92932: LD_INT 34
92934: PUSH
92935: LD_INT 14
92937: PUSH
92938: EMPTY
92939: LIST
92940: LIST
92941: PUSH
92942: EMPTY
92943: LIST
92944: LIST
92945: LIST
92946: PPUSH
92947: CALL_OW 69
92951: ST_TO_ADDR
// if not tmp then
92952: LD_VAR 0 5
92956: NOT
92957: IFFALSE 92961
// exit ;
92959: GO 93118
// for i in tmp do
92961: LD_ADDR_VAR 0 3
92965: PUSH
92966: LD_VAR 0 5
92970: PUSH
92971: FOR_IN
92972: IFFALSE 93116
// begin taskList := GetTaskList ( i ) ;
92974: LD_ADDR_VAR 0 6
92978: PUSH
92979: LD_VAR 0 3
92983: PPUSH
92984: CALL_OW 437
92988: ST_TO_ADDR
// if not taskList then
92989: LD_VAR 0 6
92993: NOT
92994: IFFALSE 92998
// continue ;
92996: GO 92971
// for j = 1 to taskList do
92998: LD_ADDR_VAR 0 4
93002: PUSH
93003: DOUBLE
93004: LD_INT 1
93006: DEC
93007: ST_TO_ADDR
93008: LD_VAR 0 6
93012: PUSH
93013: FOR_TO
93014: IFFALSE 93112
// if taskList [ j ] [ 1 ] = | then
93016: LD_VAR 0 6
93020: PUSH
93021: LD_VAR 0 4
93025: ARRAY
93026: PUSH
93027: LD_INT 1
93029: ARRAY
93030: PUSH
93031: LD_STRING |
93033: EQUAL
93034: IFFALSE 93110
// begin _taskList := Delete ( taskList , 1 ) ;
93036: LD_ADDR_VAR 0 7
93040: PUSH
93041: LD_VAR 0 6
93045: PPUSH
93046: LD_INT 1
93048: PPUSH
93049: CALL_OW 3
93053: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
93054: LD_VAR 0 3
93058: PPUSH
93059: LD_VAR 0 7
93063: PPUSH
93064: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
93068: LD_VAR 0 3
93072: PPUSH
93073: LD_VAR 0 6
93077: PUSH
93078: LD_VAR 0 4
93082: ARRAY
93083: PUSH
93084: LD_INT 2
93086: ARRAY
93087: PPUSH
93088: LD_VAR 0 6
93092: PUSH
93093: LD_VAR 0 4
93097: ARRAY
93098: PUSH
93099: LD_INT 3
93101: ARRAY
93102: PPUSH
93103: LD_INT 8
93105: PPUSH
93106: CALL 93123 0 4
// end ;
93110: GO 93013
93112: POP
93113: POP
// end ;
93114: GO 92971
93116: POP
93117: POP
// end ; end ;
93118: LD_VAR 0 2
93122: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
93123: LD_INT 0
93125: PPUSH
93126: PPUSH
93127: PPUSH
93128: PPUSH
93129: PPUSH
93130: PPUSH
93131: PPUSH
93132: PPUSH
93133: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
93134: LD_VAR 0 1
93138: NOT
93139: PUSH
93140: LD_VAR 0 2
93144: PPUSH
93145: LD_VAR 0 3
93149: PPUSH
93150: CALL_OW 488
93154: NOT
93155: OR
93156: PUSH
93157: LD_VAR 0 4
93161: NOT
93162: OR
93163: IFFALSE 93167
// exit ;
93165: GO 93507
// list := [ ] ;
93167: LD_ADDR_VAR 0 13
93171: PUSH
93172: EMPTY
93173: ST_TO_ADDR
// if x - r < 0 then
93174: LD_VAR 0 2
93178: PUSH
93179: LD_VAR 0 4
93183: MINUS
93184: PUSH
93185: LD_INT 0
93187: LESS
93188: IFFALSE 93200
// min_x := 0 else
93190: LD_ADDR_VAR 0 7
93194: PUSH
93195: LD_INT 0
93197: ST_TO_ADDR
93198: GO 93216
// min_x := x - r ;
93200: LD_ADDR_VAR 0 7
93204: PUSH
93205: LD_VAR 0 2
93209: PUSH
93210: LD_VAR 0 4
93214: MINUS
93215: ST_TO_ADDR
// if y - r < 0 then
93216: LD_VAR 0 3
93220: PUSH
93221: LD_VAR 0 4
93225: MINUS
93226: PUSH
93227: LD_INT 0
93229: LESS
93230: IFFALSE 93242
// min_y := 0 else
93232: LD_ADDR_VAR 0 8
93236: PUSH
93237: LD_INT 0
93239: ST_TO_ADDR
93240: GO 93258
// min_y := y - r ;
93242: LD_ADDR_VAR 0 8
93246: PUSH
93247: LD_VAR 0 3
93251: PUSH
93252: LD_VAR 0 4
93256: MINUS
93257: ST_TO_ADDR
// max_x := x + r ;
93258: LD_ADDR_VAR 0 9
93262: PUSH
93263: LD_VAR 0 2
93267: PUSH
93268: LD_VAR 0 4
93272: PLUS
93273: ST_TO_ADDR
// max_y := y + r ;
93274: LD_ADDR_VAR 0 10
93278: PUSH
93279: LD_VAR 0 3
93283: PUSH
93284: LD_VAR 0 4
93288: PLUS
93289: ST_TO_ADDR
// for _x = min_x to max_x do
93290: LD_ADDR_VAR 0 11
93294: PUSH
93295: DOUBLE
93296: LD_VAR 0 7
93300: DEC
93301: ST_TO_ADDR
93302: LD_VAR 0 9
93306: PUSH
93307: FOR_TO
93308: IFFALSE 93425
// for _y = min_y to max_y do
93310: LD_ADDR_VAR 0 12
93314: PUSH
93315: DOUBLE
93316: LD_VAR 0 8
93320: DEC
93321: ST_TO_ADDR
93322: LD_VAR 0 10
93326: PUSH
93327: FOR_TO
93328: IFFALSE 93421
// begin if not ValidHex ( _x , _y ) then
93330: LD_VAR 0 11
93334: PPUSH
93335: LD_VAR 0 12
93339: PPUSH
93340: CALL_OW 488
93344: NOT
93345: IFFALSE 93349
// continue ;
93347: GO 93327
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
93349: LD_VAR 0 11
93353: PPUSH
93354: LD_VAR 0 12
93358: PPUSH
93359: CALL_OW 351
93363: PUSH
93364: LD_VAR 0 11
93368: PPUSH
93369: LD_VAR 0 12
93373: PPUSH
93374: CALL_OW 554
93378: AND
93379: IFFALSE 93419
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
93381: LD_ADDR_VAR 0 13
93385: PUSH
93386: LD_VAR 0 13
93390: PPUSH
93391: LD_VAR 0 13
93395: PUSH
93396: LD_INT 1
93398: PLUS
93399: PPUSH
93400: LD_VAR 0 11
93404: PUSH
93405: LD_VAR 0 12
93409: PUSH
93410: EMPTY
93411: LIST
93412: LIST
93413: PPUSH
93414: CALL_OW 2
93418: ST_TO_ADDR
// end ;
93419: GO 93327
93421: POP
93422: POP
93423: GO 93307
93425: POP
93426: POP
// if not list then
93427: LD_VAR 0 13
93431: NOT
93432: IFFALSE 93436
// exit ;
93434: GO 93507
// for i in list do
93436: LD_ADDR_VAR 0 6
93440: PUSH
93441: LD_VAR 0 13
93445: PUSH
93446: FOR_IN
93447: IFFALSE 93505
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
93449: LD_VAR 0 1
93453: PPUSH
93454: LD_STRING M
93456: PUSH
93457: LD_VAR 0 6
93461: PUSH
93462: LD_INT 1
93464: ARRAY
93465: PUSH
93466: LD_VAR 0 6
93470: PUSH
93471: LD_INT 2
93473: ARRAY
93474: PUSH
93475: LD_INT 0
93477: PUSH
93478: LD_INT 0
93480: PUSH
93481: LD_INT 0
93483: PUSH
93484: LD_INT 0
93486: PUSH
93487: EMPTY
93488: LIST
93489: LIST
93490: LIST
93491: LIST
93492: LIST
93493: LIST
93494: LIST
93495: PUSH
93496: EMPTY
93497: LIST
93498: PPUSH
93499: CALL_OW 447
93503: GO 93446
93505: POP
93506: POP
// end ;
93507: LD_VAR 0 5
93511: RET
