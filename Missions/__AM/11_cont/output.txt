// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Randomize ;
  11: CALL_OW 10
// InitVariables ;
  15: CALL 94 0 0
// InitMacro ;
  19: CALL 18378 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// ChangeSideFog ( 8 , 1 ) ;
  36: LD_INT 8
  38: PPUSH
  39: LD_INT 1
  41: PPUSH
  42: CALL_OW 343
// PrepareNature ( 4 , 3 , 6 , 3 , 2 , 0 , 7 , natureArea , waterArea ) ;
  46: LD_INT 4
  48: PPUSH
  49: LD_INT 3
  51: PPUSH
  52: LD_INT 6
  54: PPUSH
  55: LD_INT 3
  57: PPUSH
  58: LD_INT 2
  60: PPUSH
  61: LD_INT 0
  63: PPUSH
  64: LD_INT 7
  66: PPUSH
  67: LD_INT 18
  69: PPUSH
  70: LD_INT 19
  72: PPUSH
  73: CALL 83054 0 9
// PrepareAmerican ;
  77: CALL 653 0 0
// PrepareArabian ;
  81: CALL 2605 0 0
// MC_Start ( ) ;
  85: CALL 20558 0 0
// Action ;
  89: CALL 8749 0 0
// end ;
  93: END
// export debug , game ; export mission_prefix , mission_prefix_prev ; export ar_run , base_captured , ar_patrol , us_scout , seen , can_kamikazed , kamikazed , artifact_stolen , artifact_get , artifact_oncargo , game_time , powell_warn , loses_counter , gensher_active , selected , am_veh_consturcted ; function InitVariables ; begin
  94: LD_INT 0
  96: PPUSH
// debug := false ;
  97: LD_ADDR_EXP 1
 101: PUSH
 102: LD_INT 0
 104: ST_TO_ADDR
// game := true ;
 105: LD_ADDR_EXP 2
 109: PUSH
 110: LD_INT 1
 112: ST_TO_ADDR
// mission_prefix := 11_ ;
 113: LD_ADDR_EXP 3
 117: PUSH
 118: LD_STRING 11_
 120: ST_TO_ADDR
// mission_prefix_prev := 10c_ ;
 121: LD_ADDR_EXP 4
 125: PUSH
 126: LD_STRING 10c_
 128: ST_TO_ADDR
// ar_run := false ;
 129: LD_ADDR_EXP 5
 133: PUSH
 134: LD_INT 0
 136: ST_TO_ADDR
// ar_patrol := false ;
 137: LD_ADDR_EXP 7
 141: PUSH
 142: LD_INT 0
 144: ST_TO_ADDR
// base_captured := false ;
 145: LD_ADDR_EXP 6
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// us_scout := 0 ;
 153: LD_ADDR_EXP 8
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// seen := [ 0 , 0 , 0 , 0 , 0 ] ;
 161: LD_ADDR_EXP 9
 165: PUSH
 166: LD_INT 0
 168: PUSH
 169: LD_INT 0
 171: PUSH
 172: LD_INT 0
 174: PUSH
 175: LD_INT 0
 177: PUSH
 178: LD_INT 0
 180: PUSH
 181: EMPTY
 182: LIST
 183: LIST
 184: LIST
 185: LIST
 186: LIST
 187: ST_TO_ADDR
// kamikazed := false ;
 188: LD_ADDR_EXP 11
 192: PUSH
 193: LD_INT 0
 195: ST_TO_ADDR
// artifact_stolen := false ;
 196: LD_ADDR_EXP 12
 200: PUSH
 201: LD_INT 0
 203: ST_TO_ADDR
// artifact_get := false ;
 204: LD_ADDR_EXP 13
 208: PUSH
 209: LD_INT 0
 211: ST_TO_ADDR
// game_time := [ 130 130$00 , 120 120$00 , 115 115$00 , 112 112$00 ] [ Difficulty ] ;
 212: LD_ADDR_EXP 15
 216: PUSH
 217: LD_INT 273000
 219: PUSH
 220: LD_INT 252000
 222: PUSH
 223: LD_INT 241500
 225: PUSH
 226: LD_INT 235200
 228: PUSH
 229: EMPTY
 230: LIST
 231: LIST
 232: LIST
 233: LIST
 234: PUSH
 235: LD_OWVAR 67
 239: ARRAY
 240: ST_TO_ADDR
// powell_warn := false ;
 241: LD_ADDR_EXP 16
 245: PUSH
 246: LD_INT 0
 248: ST_TO_ADDR
// loses_counter := 0 ;
 249: LD_ADDR_EXP 17
 253: PUSH
 254: LD_INT 0
 256: ST_TO_ADDR
// artifact_oncargo := false ;
 257: LD_ADDR_EXP 14
 261: PUSH
 262: LD_INT 0
 264: ST_TO_ADDR
// gensher_active := LoadVariable ( 10_GensherEscape_1 , debug ) ;
 265: LD_ADDR_EXP 18
 269: PUSH
 270: LD_STRING 10_GensherEscape_1
 272: PPUSH
 273: LD_EXP 1
 277: PPUSH
 278: CALL_OW 30
 282: ST_TO_ADDR
// can_kamikazed := false ;
 283: LD_ADDR_EXP 10
 287: PUSH
 288: LD_INT 0
 290: ST_TO_ADDR
// am_veh_consturcted := false ;
 291: LD_ADDR_EXP 20
 295: PUSH
 296: LD_INT 0
 298: ST_TO_ADDR
// end ;
 299: LD_VAR 0 1
 303: RET
// export function CustomInitMacro ; var i ; begin
 304: LD_INT 0
 306: PPUSH
 307: PPUSH
// mc_parking := [ parking_north , parking_west , parking_east ] ;
 308: LD_ADDR_EXP 74
 312: PUSH
 313: LD_INT 20
 315: PUSH
 316: LD_INT 21
 318: PUSH
 319: LD_INT 22
 321: PUSH
 322: EMPTY
 323: LIST
 324: LIST
 325: LIST
 326: ST_TO_ADDR
// mc_scan_area := [ base_north , base_west , base_east ] ;
 327: LD_ADDR_EXP 75
 331: PUSH
 332: LD_INT 28
 334: PUSH
 335: LD_INT 24
 337: PUSH
 338: LD_INT 26
 340: PUSH
 341: EMPTY
 342: LIST
 343: LIST
 344: LIST
 345: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield1_left ) ;
 346: LD_INT 1
 348: PPUSH
 349: LD_INT 4
 351: PUSH
 352: LD_INT 6
 354: PUSH
 355: LD_INT 8
 357: PUSH
 358: LD_INT 9
 360: PUSH
 361: EMPTY
 362: LIST
 363: LIST
 364: LIST
 365: LIST
 366: PUSH
 367: LD_OWVAR 67
 371: ARRAY
 372: PPUSH
 373: LD_INT 3
 375: PPUSH
 376: CALL 42261 0 3
// MC_SetMinesField ( 2 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield2_left ) ;
 380: LD_INT 2
 382: PPUSH
 383: LD_INT 4
 385: PUSH
 386: LD_INT 6
 388: PUSH
 389: LD_INT 8
 391: PUSH
 392: LD_INT 9
 394: PUSH
 395: EMPTY
 396: LIST
 397: LIST
 398: LIST
 399: LIST
 400: PUSH
 401: LD_OWVAR 67
 405: ARRAY
 406: PPUSH
 407: LD_INT 2
 409: PPUSH
 410: CALL 42261 0 3
// MC_SetMinesField ( 3 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield3_left ) ;
 414: LD_INT 3
 416: PPUSH
 417: LD_INT 4
 419: PUSH
 420: LD_INT 6
 422: PUSH
 423: LD_INT 8
 425: PUSH
 426: LD_INT 9
 428: PUSH
 429: EMPTY
 430: LIST
 431: LIST
 432: LIST
 433: LIST
 434: PUSH
 435: LD_OWVAR 67
 439: ARRAY
 440: PPUSH
 441: LD_INT 1
 443: PPUSH
 444: CALL 42261 0 3
// for i = 1 to mc_bases do
 448: LD_ADDR_VAR 0 2
 452: PUSH
 453: DOUBLE
 454: LD_INT 1
 456: DEC
 457: ST_TO_ADDR
 458: LD_EXP 50
 462: PUSH
 463: FOR_TO
 464: IFFALSE 488
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 466: LD_VAR 0 2
 470: PPUSH
 471: LD_EXP 43
 475: PUSH
 476: LD_VAR 0 2
 480: ARRAY
 481: PPUSH
 482: CALL 42706 0 2
 486: GO 463
 488: POP
 489: POP
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] , ] ) ;
 490: LD_INT 1
 492: PPUSH
 493: LD_INT 14
 495: PUSH
 496: LD_INT 1
 498: PUSH
 499: LD_INT 2
 501: PUSH
 502: LD_INT 88
 504: PUSH
 505: EMPTY
 506: LIST
 507: LIST
 508: LIST
 509: LIST
 510: PUSH
 511: LD_INT 14
 513: PUSH
 514: LD_INT 1
 516: PUSH
 517: LD_INT 2
 519: PUSH
 520: LD_INT 88
 522: PUSH
 523: EMPTY
 524: LIST
 525: LIST
 526: LIST
 527: LIST
 528: PUSH
 529: EMPTY
 530: LIST
 531: LIST
 532: PPUSH
 533: CALL 42598 0 2
// MC_SetProduceList ( 2 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 537: LD_INT 2
 539: PPUSH
 540: LD_INT 14
 542: PUSH
 543: LD_INT 1
 545: PUSH
 546: LD_INT 2
 548: PUSH
 549: LD_INT 88
 551: PUSH
 552: EMPTY
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: PUSH
 558: EMPTY
 559: LIST
 560: PPUSH
 561: CALL 42598 0 2
// end ;
 565: LD_VAR 0 1
 569: RET
// function Debuger ; var i ; begin
 570: LD_INT 0
 572: PPUSH
 573: PPUSH
// if not debug then
 574: LD_EXP 1
 578: NOT
 579: IFFALSE 583
// exit ;
 581: GO 619
// game_speed := 5 ;
 583: LD_ADDR_OWVAR 65
 587: PUSH
 588: LD_INT 5
 590: ST_TO_ADDR
// uc_side := 1 ;
 591: LD_ADDR_OWVAR 20
 595: PUSH
 596: LD_INT 1
 598: ST_TO_ADDR
// uc_nation := 1 ;
 599: LD_ADDR_OWVAR 21
 603: PUSH
 604: LD_INT 1
 606: ST_TO_ADDR
// SetSide ( ar_force_south , 1 ) ;
 607: LD_EXP 36
 611: PPUSH
 612: LD_INT 1
 614: PPUSH
 615: CALL_OW 235
// end ;
 619: LD_VAR 0 1
 623: RET
// every 0 0$1 trigger IsDead ( ar_dep_n ) and IsOk ( ar_dep_w ) do
 624: LD_INT 94
 626: PPUSH
 627: CALL_OW 301
 631: PUSH
 632: LD_INT 45
 634: PPUSH
 635: CALL_OW 302
 639: AND
 640: IFFALSE 652
 642: GO 644
 644: DISABLE
// SetAchievement ( ACH_EAST ) ; end_of_file
 645: LD_STRING ACH_EAST
 647: PPUSH
 648: CALL_OW 543
 652: END
// export JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Frank , Kikuchi ; export function PrepareAmerican ; var i , k , un , tmp , vehs , veh , others ; begin
 653: LD_INT 0
 655: PPUSH
 656: PPUSH
 657: PPUSH
 658: PPUSH
 659: PPUSH
 660: PPUSH
 661: PPUSH
 662: PPUSH
// uc_side := 4 ;
 663: LD_ADDR_OWVAR 20
 667: PUSH
 668: LD_INT 4
 670: ST_TO_ADDR
// uc_nation := 1 ;
 671: LD_ADDR_OWVAR 21
 675: PUSH
 676: LD_INT 1
 678: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
 679: LD_ADDR_EXP 30
 683: PUSH
 684: LD_STRING Powell
 686: PPUSH
 687: LD_INT 0
 689: PPUSH
 690: LD_STRING 
 692: PPUSH
 693: CALL 49072 0 3
 697: ST_TO_ADDR
// uc_side := 1 ;
 698: LD_ADDR_OWVAR 20
 702: PUSH
 703: LD_INT 1
 705: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , mission_prefix_prev ) ;
 706: LD_ADDR_EXP 21
 710: PUSH
 711: LD_STRING JMM
 713: PPUSH
 714: LD_EXP 1
 718: NOT
 719: PPUSH
 720: LD_EXP 4
 724: PPUSH
 725: CALL 49072 0 3
 729: ST_TO_ADDR
// if GetClass ( JMM ) > 4 then
 730: LD_EXP 21
 734: PPUSH
 735: CALL_OW 257
 739: PUSH
 740: LD_INT 4
 742: GREATER
 743: IFFALSE 757
// SetClass ( JMM , 1 ) ;
 745: LD_EXP 21
 749: PPUSH
 750: LD_INT 1
 752: PPUSH
 753: CALL_OW 336
// Lisa := PrepareUnit ( Lisa , ( not debug ) , mission_prefix_prev ) ;
 757: LD_ADDR_EXP 22
 761: PUSH
 762: LD_STRING Lisa
 764: PPUSH
 765: LD_EXP 1
 769: NOT
 770: PPUSH
 771: LD_EXP 4
 775: PPUSH
 776: CALL 49072 0 3
 780: ST_TO_ADDR
// if not Lisa then
 781: LD_EXP 22
 785: NOT
 786: IFFALSE 801
// Lisa := CreateCharacter ( 10_Lisa ) ;
 788: LD_ADDR_EXP 22
 792: PUSH
 793: LD_STRING 10_Lisa
 795: PPUSH
 796: CALL_OW 34
 800: ST_TO_ADDR
// if not Lisa then
 801: LD_EXP 22
 805: NOT
 806: IFFALSE 821
// Lisa := CreateCharacter ( 09_Lisa ) ;
 808: LD_ADDR_EXP 22
 812: PUSH
 813: LD_STRING 09_Lisa
 815: PPUSH
 816: CALL_OW 34
 820: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , mission_prefix_prev ) ;
 821: LD_ADDR_EXP 31
 825: PUSH
 826: LD_STRING Cornel
 828: PPUSH
 829: LD_EXP 1
 833: NOT
 834: PPUSH
 835: LD_EXP 4
 839: PPUSH
 840: CALL 49072 0 3
 844: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , mission_prefix_prev ) ;
 845: LD_ADDR_EXP 23
 849: PUSH
 850: LD_STRING Donaldson
 852: PPUSH
 853: LD_EXP 1
 857: NOT
 858: PPUSH
 859: LD_EXP 4
 863: PPUSH
 864: CALL 49072 0 3
 868: ST_TO_ADDR
// if not Donaldson then
 869: LD_EXP 23
 873: NOT
 874: IFFALSE 889
// Donaldson := CreateCharacter ( 10_Donaldson ) ;
 876: LD_ADDR_EXP 23
 880: PUSH
 881: LD_STRING 10_Donaldson
 883: PPUSH
 884: CALL_OW 34
 888: ST_TO_ADDR
// if not Donaldson then
 889: LD_EXP 23
 893: NOT
 894: IFFALSE 909
// Donaldson := CreateCharacter ( 09_Donaldson ) ;
 896: LD_ADDR_EXP 23
 900: PUSH
 901: LD_STRING 09_Donaldson
 903: PPUSH
 904: CALL_OW 34
 908: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , mission_prefix_prev ) ;
 909: LD_ADDR_EXP 24
 913: PUSH
 914: LD_STRING Bobby
 916: PPUSH
 917: LD_EXP 1
 921: NOT
 922: PPUSH
 923: LD_EXP 4
 927: PPUSH
 928: CALL 49072 0 3
 932: ST_TO_ADDR
// if not Bobby then
 933: LD_EXP 24
 937: NOT
 938: IFFALSE 953
// Bobby := CreateCharacter ( 10_Bobby ) ;
 940: LD_ADDR_EXP 24
 944: PUSH
 945: LD_STRING 10_Bobby
 947: PPUSH
 948: CALL_OW 34
 952: ST_TO_ADDR
// if not Bobby then
 953: LD_EXP 24
 957: NOT
 958: IFFALSE 973
// Bobby := CreateCharacter ( 09_Bobby ) ;
 960: LD_ADDR_EXP 24
 964: PUSH
 965: LD_STRING 09_Bobby
 967: PPUSH
 968: CALL_OW 34
 972: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , mission_prefix_prev ) ;
 973: LD_ADDR_EXP 25
 977: PUSH
 978: LD_STRING Cyrus
 980: PPUSH
 981: LD_EXP 1
 985: NOT
 986: PPUSH
 987: LD_EXP 4
 991: PPUSH
 992: CALL 49072 0 3
 996: ST_TO_ADDR
// if not Cyrus then
 997: LD_EXP 25
1001: NOT
1002: IFFALSE 1017
// Cyrus := CreateCharacter ( 10_Cyrus ) ;
1004: LD_ADDR_EXP 25
1008: PUSH
1009: LD_STRING 10_Cyrus
1011: PPUSH
1012: CALL_OW 34
1016: ST_TO_ADDR
// if not Cyrus then
1017: LD_EXP 25
1021: NOT
1022: IFFALSE 1037
// Cyrus := CreateCharacter ( 09_Cyrus ) ;
1024: LD_ADDR_EXP 25
1028: PUSH
1029: LD_STRING 09_Cyrus
1031: PPUSH
1032: CALL_OW 34
1036: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , mission_prefix_prev ) ;
1037: LD_ADDR_EXP 26
1041: PUSH
1042: LD_STRING Denis
1044: PPUSH
1045: LD_EXP 1
1049: NOT
1050: PPUSH
1051: LD_EXP 4
1055: PPUSH
1056: CALL 49072 0 3
1060: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , mission_prefix_prev ) ;
1061: LD_ADDR_EXP 27
1065: PUSH
1066: LD_STRING Brown
1068: PPUSH
1069: LD_EXP 1
1073: NOT
1074: PPUSH
1075: LD_EXP 4
1079: PPUSH
1080: CALL 49072 0 3
1084: ST_TO_ADDR
// if not Brown then
1085: LD_EXP 27
1089: NOT
1090: IFFALSE 1105
// Brown := CreateCharacter ( 10_Brown ) ;
1092: LD_ADDR_EXP 27
1096: PUSH
1097: LD_STRING 10_Brown
1099: PPUSH
1100: CALL_OW 34
1104: ST_TO_ADDR
// if not Brown then
1105: LD_EXP 27
1109: NOT
1110: IFFALSE 1125
// Brown := CreateCharacter ( 08_Brown ) ;
1112: LD_ADDR_EXP 27
1116: PUSH
1117: LD_STRING 08_Brown
1119: PPUSH
1120: CALL_OW 34
1124: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , mission_prefix_prev ) ;
1125: LD_ADDR_EXP 28
1129: PUSH
1130: LD_STRING Gladstone
1132: PPUSH
1133: LD_EXP 1
1137: NOT
1138: PPUSH
1139: LD_EXP 4
1143: PPUSH
1144: CALL 49072 0 3
1148: ST_TO_ADDR
// if not Gladstone then
1149: LD_EXP 28
1153: NOT
1154: IFFALSE 1169
// Gladstone := CreateCharacter ( 10_Gladstone ) ;
1156: LD_ADDR_EXP 28
1160: PUSH
1161: LD_STRING 10_Gladstone
1163: PPUSH
1164: CALL_OW 34
1168: ST_TO_ADDR
// if not Gladstone then
1169: LD_EXP 28
1173: NOT
1174: IFFALSE 1189
// Gladstone := CreateCharacter ( 08_Gladstone ) ;
1176: LD_ADDR_EXP 28
1180: PUSH
1181: LD_STRING 08_Gladstone
1183: PPUSH
1184: CALL_OW 34
1188: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , mission_prefix_prev ) ;
1189: LD_ADDR_EXP 29
1193: PUSH
1194: LD_STRING Houten
1196: PPUSH
1197: LD_EXP 1
1201: NOT
1202: PPUSH
1203: LD_EXP 4
1207: PPUSH
1208: CALL 49072 0 3
1212: ST_TO_ADDR
// if not Houten then
1213: LD_EXP 29
1217: NOT
1218: IFFALSE 1233
// Houten := CreateCharacter ( 10_Houten ) ;
1220: LD_ADDR_EXP 29
1224: PUSH
1225: LD_STRING 10_Houten
1227: PPUSH
1228: CALL_OW 34
1232: ST_TO_ADDR
// if not Houten then
1233: LD_EXP 29
1237: NOT
1238: IFFALSE 1253
// Houten := CreateCharacter ( 09_Houten ) ;
1240: LD_ADDR_EXP 29
1244: PUSH
1245: LD_STRING 09_Houten
1247: PPUSH
1248: CALL_OW 34
1252: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , ( not debug ) , mission_prefix_prev ) ;
1253: LD_ADDR_EXP 31
1257: PUSH
1258: LD_STRING Cornell
1260: PPUSH
1261: LD_EXP 1
1265: NOT
1266: PPUSH
1267: LD_EXP 4
1271: PPUSH
1272: CALL 49072 0 3
1276: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , mission_prefix_prev ) ;
1277: LD_ADDR_EXP 32
1281: PUSH
1282: LD_STRING Gary
1284: PPUSH
1285: LD_EXP 1
1289: NOT
1290: PPUSH
1291: LD_EXP 4
1295: PPUSH
1296: CALL 49072 0 3
1300: ST_TO_ADDR
// if not Gary then
1301: LD_EXP 32
1305: NOT
1306: IFFALSE 1321
// Gary := CreateCharacter ( 10_Gary ) ;
1308: LD_ADDR_EXP 32
1312: PUSH
1313: LD_STRING 10_Gary
1315: PPUSH
1316: CALL_OW 34
1320: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , mission_prefix_prev ) ;
1321: LD_ADDR_EXP 33
1325: PUSH
1326: LD_STRING Frank
1328: PPUSH
1329: LD_EXP 1
1333: NOT
1334: PPUSH
1335: LD_EXP 4
1339: PPUSH
1340: CALL 49072 0 3
1344: ST_TO_ADDR
// if not Frank then
1345: LD_EXP 33
1349: NOT
1350: IFFALSE 1365
// Frank := CreateCharacter ( 08_Frank ) ;
1352: LD_ADDR_EXP 33
1356: PUSH
1357: LD_STRING 08_Frank
1359: PPUSH
1360: CALL_OW 34
1364: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , mission_prefix_prev ) ;
1365: LD_ADDR_EXP 34
1369: PUSH
1370: LD_STRING Kikuchi
1372: PPUSH
1373: LD_EXP 1
1377: NOT
1378: PPUSH
1379: LD_EXP 4
1383: PPUSH
1384: CALL 49072 0 3
1388: ST_TO_ADDR
// if not Kikuchi then
1389: LD_EXP 34
1393: NOT
1394: IFFALSE 1409
// Kikuchi := CreateCharacter ( 08_Kikuchi ) ;
1396: LD_ADDR_EXP 34
1400: PUSH
1401: LD_STRING 08_Kikuchi
1403: PPUSH
1404: CALL_OW 34
1408: ST_TO_ADDR
// tmp := [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1409: LD_ADDR_VAR 0 5
1413: PUSH
1414: LD_EXP 22
1418: PUSH
1419: LD_EXP 23
1423: PUSH
1424: LD_EXP 24
1428: PUSH
1429: LD_EXP 25
1433: PUSH
1434: LD_EXP 26
1438: PUSH
1439: LD_EXP 27
1443: PUSH
1444: LD_EXP 28
1448: PUSH
1449: LD_EXP 29
1453: PUSH
1454: LD_EXP 31
1458: PUSH
1459: LD_EXP 32
1463: PUSH
1464: LD_EXP 33
1468: PUSH
1469: LD_EXP 34
1473: PUSH
1474: EMPTY
1475: LIST
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: LIST
1481: LIST
1482: LIST
1483: LIST
1484: LIST
1485: LIST
1486: LIST
1487: ST_TO_ADDR
// tmp := tmp diff 0 ;
1488: LD_ADDR_VAR 0 5
1492: PUSH
1493: LD_VAR 0 5
1497: PUSH
1498: LD_INT 0
1500: DIFF
1501: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10_lock ) ;
1502: LD_ADDR_VAR 0 5
1506: PUSH
1507: LD_VAR 0 5
1511: PUSH
1512: LD_STRING 10_lock
1514: PPUSH
1515: CALL_OW 31
1519: UNION
1520: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10c_lock ) ;
1521: LD_ADDR_VAR 0 5
1525: PUSH
1526: LD_VAR 0 5
1530: PUSH
1531: LD_STRING 10c_lock
1533: PPUSH
1534: CALL_OW 31
1538: UNION
1539: ST_TO_ADDR
// DeleteCharacters ( 10_lock ) ;
1540: LD_STRING 10_lock
1542: PPUSH
1543: CALL_OW 40
// DeleteCharacters ( 10c_lock ) ;
1547: LD_STRING 10c_lock
1549: PPUSH
1550: CALL_OW 40
// for i in tmp do
1554: LD_ADDR_VAR 0 2
1558: PUSH
1559: LD_VAR 0 5
1563: PUSH
1564: FOR_IN
1565: IFFALSE 1603
// if GetClass ( i ) in [ class_mortar , class_engineer ] then
1567: LD_VAR 0 2
1571: PPUSH
1572: CALL_OW 257
1576: PUSH
1577: LD_INT 8
1579: PUSH
1580: LD_INT 2
1582: PUSH
1583: EMPTY
1584: LIST
1585: LIST
1586: IN
1587: IFFALSE 1601
// SetClass ( i , class_soldier ) ;
1589: LD_VAR 0 2
1593: PPUSH
1594: LD_INT 1
1596: PPUSH
1597: CALL_OW 336
1601: GO 1564
1603: POP
1604: POP
// if tmp < 12 then
1605: LD_VAR 0 5
1609: PUSH
1610: LD_INT 12
1612: LESS
1613: IFFALSE 1707
// begin k := 16 - tmp ;
1615: LD_ADDR_VAR 0 3
1619: PUSH
1620: LD_INT 16
1622: PUSH
1623: LD_VAR 0 5
1627: MINUS
1628: ST_TO_ADDR
// for i = 1 to k do
1629: LD_ADDR_VAR 0 2
1633: PUSH
1634: DOUBLE
1635: LD_INT 1
1637: DEC
1638: ST_TO_ADDR
1639: LD_VAR 0 3
1643: PUSH
1644: FOR_TO
1645: IFFALSE 1705
// begin PrepareHuman ( false , [ 1 , 1 , 3 , 4 ] [ rand ( 1 , 4 ) ] , 6 ) ;
1647: LD_INT 0
1649: PPUSH
1650: LD_INT 1
1652: PUSH
1653: LD_INT 1
1655: PUSH
1656: LD_INT 3
1658: PUSH
1659: LD_INT 4
1661: PUSH
1662: EMPTY
1663: LIST
1664: LIST
1665: LIST
1666: LIST
1667: PUSH
1668: LD_INT 1
1670: PPUSH
1671: LD_INT 4
1673: PPUSH
1674: CALL_OW 12
1678: ARRAY
1679: PPUSH
1680: LD_INT 6
1682: PPUSH
1683: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
1687: LD_ADDR_VAR 0 5
1691: PUSH
1692: LD_VAR 0 5
1696: PUSH
1697: CALL_OW 44
1701: ADD
1702: ST_TO_ADDR
// end ;
1703: GO 1644
1705: POP
1706: POP
// end ; selected := CharacterSelection ( 1 , 12 , 12 , [ sel_change_class , JMM , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp ^ [ sel_dont_change_class , sel_not_changeable , Powell ] , [ [ class_soldier , 4 ] , [ class_mechanic , 0 , 5 ] , [ class_scientistic , 0 , 3 ] , [ class_sniper , 0 , 2 ] ] ) ;
1707: LD_ADDR_EXP 19
1711: PUSH
1712: LD_STRING 1
1714: PPUSH
1715: LD_INT 12
1717: PPUSH
1718: LD_INT 12
1720: PPUSH
1721: LD_INT -5
1723: PUSH
1724: LD_EXP 21
1728: PUSH
1729: LD_INT -2
1731: PUSH
1732: LD_INT -3
1734: PUSH
1735: LD_INT -5
1737: PUSH
1738: EMPTY
1739: LIST
1740: LIST
1741: LIST
1742: LIST
1743: LIST
1744: PUSH
1745: LD_VAR 0 5
1749: ADD
1750: PUSH
1751: LD_INT -6
1753: PUSH
1754: LD_INT -4
1756: PUSH
1757: LD_EXP 30
1761: PUSH
1762: EMPTY
1763: LIST
1764: LIST
1765: LIST
1766: ADD
1767: PPUSH
1768: LD_INT 1
1770: PUSH
1771: LD_INT 4
1773: PUSH
1774: EMPTY
1775: LIST
1776: LIST
1777: PUSH
1778: LD_INT 3
1780: PUSH
1781: LD_INT 0
1783: PUSH
1784: LD_INT 5
1786: PUSH
1787: EMPTY
1788: LIST
1789: LIST
1790: LIST
1791: PUSH
1792: LD_INT 4
1794: PUSH
1795: LD_INT 0
1797: PUSH
1798: LD_INT 3
1800: PUSH
1801: EMPTY
1802: LIST
1803: LIST
1804: LIST
1805: PUSH
1806: LD_INT 5
1808: PUSH
1809: LD_INT 0
1811: PUSH
1812: LD_INT 2
1814: PUSH
1815: EMPTY
1816: LIST
1817: LIST
1818: LIST
1819: PUSH
1820: EMPTY
1821: LIST
1822: LIST
1823: LIST
1824: LIST
1825: PPUSH
1826: CALL_OW 42
1830: ST_TO_ADDR
// others := tmp diff selected ;
1831: LD_ADDR_VAR 0 8
1835: PUSH
1836: LD_VAR 0 5
1840: PUSH
1841: LD_EXP 19
1845: DIFF
1846: ST_TO_ADDR
// others := others diff [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1847: LD_ADDR_VAR 0 8
1851: PUSH
1852: LD_VAR 0 8
1856: PUSH
1857: LD_EXP 22
1861: PUSH
1862: LD_EXP 23
1866: PUSH
1867: LD_EXP 24
1871: PUSH
1872: LD_EXP 25
1876: PUSH
1877: LD_EXP 26
1881: PUSH
1882: LD_EXP 27
1886: PUSH
1887: LD_EXP 28
1891: PUSH
1892: LD_EXP 29
1896: PUSH
1897: LD_EXP 31
1901: PUSH
1902: LD_EXP 32
1906: PUSH
1907: LD_EXP 33
1911: PUSH
1912: LD_EXP 34
1916: PUSH
1917: EMPTY
1918: LIST
1919: LIST
1920: LIST
1921: LIST
1922: LIST
1923: LIST
1924: LIST
1925: LIST
1926: LIST
1927: LIST
1928: LIST
1929: LIST
1930: DIFF
1931: ST_TO_ADDR
// if others then
1932: LD_VAR 0 8
1936: IFFALSE 1950
// SaveCharacters ( others , 11_others ) ;
1938: LD_VAR 0 8
1942: PPUSH
1943: LD_STRING 11_others
1945: PPUSH
1946: CALL_OW 38
// vehs := [ [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun ] , [ us_medium_wheeled , engine_siberite , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_medium_wheeled , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_siberite , control_manual , us_rocket_launcher ] ] ;
1950: LD_ADDR_VAR 0 6
1954: PUSH
1955: LD_INT 3
1957: PUSH
1958: LD_INT 1
1960: PUSH
1961: LD_INT 1
1963: PUSH
1964: LD_INT 4
1966: PUSH
1967: EMPTY
1968: LIST
1969: LIST
1970: LIST
1971: LIST
1972: PUSH
1973: LD_INT 2
1975: PUSH
1976: LD_INT 3
1978: PUSH
1979: LD_INT 1
1981: PUSH
1982: LD_INT 5
1984: PUSH
1985: EMPTY
1986: LIST
1987: LIST
1988: LIST
1989: LIST
1990: PUSH
1991: LD_INT 4
1993: PUSH
1994: LD_INT 1
1996: PUSH
1997: LD_INT 1
1999: PUSH
2000: LD_INT 5
2002: PUSH
2003: EMPTY
2004: LIST
2005: LIST
2006: LIST
2007: LIST
2008: PUSH
2009: LD_INT 2
2011: PUSH
2012: LD_INT 1
2014: PUSH
2015: LD_INT 1
2017: PUSH
2018: LD_INT 7
2020: PUSH
2021: EMPTY
2022: LIST
2023: LIST
2024: LIST
2025: LIST
2026: PUSH
2027: LD_INT 3
2029: PUSH
2030: LD_INT 3
2032: PUSH
2033: LD_INT 1
2035: PUSH
2036: LD_INT 7
2038: PUSH
2039: EMPTY
2040: LIST
2041: LIST
2042: LIST
2043: LIST
2044: PUSH
2045: EMPTY
2046: LIST
2047: LIST
2048: LIST
2049: LIST
2050: LIST
2051: ST_TO_ADDR
// for i in JMM ^ selected do
2052: LD_ADDR_VAR 0 2
2056: PUSH
2057: LD_EXP 21
2061: PUSH
2062: LD_EXP 19
2066: ADD
2067: PUSH
2068: FOR_IN
2069: IFFALSE 2259
// begin if GetClass ( i ) = 3 then
2071: LD_VAR 0 2
2075: PPUSH
2076: CALL_OW 257
2080: PUSH
2081: LD_INT 3
2083: EQUAL
2084: IFFALSE 2242
// begin vc_chassis := vehs [ 1 ] [ 1 ] ;
2086: LD_ADDR_OWVAR 37
2090: PUSH
2091: LD_VAR 0 6
2095: PUSH
2096: LD_INT 1
2098: ARRAY
2099: PUSH
2100: LD_INT 1
2102: ARRAY
2103: ST_TO_ADDR
// vc_engine := vehs [ 1 ] [ 2 ] ;
2104: LD_ADDR_OWVAR 39
2108: PUSH
2109: LD_VAR 0 6
2113: PUSH
2114: LD_INT 1
2116: ARRAY
2117: PUSH
2118: LD_INT 2
2120: ARRAY
2121: ST_TO_ADDR
// vc_control := vehs [ 1 ] [ 3 ] ;
2122: LD_ADDR_OWVAR 38
2126: PUSH
2127: LD_VAR 0 6
2131: PUSH
2132: LD_INT 1
2134: ARRAY
2135: PUSH
2136: LD_INT 3
2138: ARRAY
2139: ST_TO_ADDR
// vc_weapon := vehs [ 1 ] [ 4 ] ;
2140: LD_ADDR_OWVAR 40
2144: PUSH
2145: LD_VAR 0 6
2149: PUSH
2150: LD_INT 1
2152: ARRAY
2153: PUSH
2154: LD_INT 4
2156: ARRAY
2157: ST_TO_ADDR
// vehs := Delete ( vehs , 1 ) ;
2158: LD_ADDR_VAR 0 6
2162: PUSH
2163: LD_VAR 0 6
2167: PPUSH
2168: LD_INT 1
2170: PPUSH
2171: CALL_OW 3
2175: ST_TO_ADDR
// veh := CreateVehicle ;
2176: LD_ADDR_VAR 0 7
2180: PUSH
2181: CALL_OW 45
2185: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2186: LD_VAR 0 7
2190: PPUSH
2191: LD_INT 8
2193: PPUSH
2194: LD_INT 0
2196: PPUSH
2197: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
2201: LD_VAR 0 2
2205: PPUSH
2206: LD_VAR 0 7
2210: PPUSH
2211: CALL_OW 52
// if i = JMM then
2215: LD_VAR 0 2
2219: PUSH
2220: LD_EXP 21
2224: EQUAL
2225: IFFALSE 2240
// SetMark ( veh , - 1 ) ;
2227: LD_VAR 0 7
2231: PPUSH
2232: LD_INT 1
2234: NEG
2235: PPUSH
2236: CALL_OW 242
// end else
2240: GO 2257
// PlaceUnitArea ( i , am_hum_start , false ) ;
2242: LD_VAR 0 2
2246: PPUSH
2247: LD_INT 9
2249: PPUSH
2250: LD_INT 0
2252: PPUSH
2253: CALL_OW 49
// end ;
2257: GO 2068
2259: POP
2260: POP
// vc_chassis := us_medium_tracked ;
2261: LD_ADDR_OWVAR 37
2265: PUSH
2266: LD_INT 3
2268: ST_TO_ADDR
// vc_engine := engine_solar ;
2269: LD_ADDR_OWVAR 39
2273: PUSH
2274: LD_INT 2
2276: ST_TO_ADDR
// vc_control := control_computer ;
2277: LD_ADDR_OWVAR 38
2281: PUSH
2282: LD_INT 3
2284: ST_TO_ADDR
// vc_weapon := us_radar ;
2285: LD_ADDR_OWVAR 40
2289: PUSH
2290: LD_INT 11
2292: ST_TO_ADDR
// veh := CreateVehicle ;
2293: LD_ADDR_VAR 0 7
2297: PUSH
2298: CALL_OW 45
2302: ST_TO_ADDR
// PlaceUnitXY ( veh , 87 , 142 , false ) ;
2303: LD_VAR 0 7
2307: PPUSH
2308: LD_INT 87
2310: PPUSH
2311: LD_INT 142
2313: PPUSH
2314: LD_INT 0
2316: PPUSH
2317: CALL_OW 48
// end ;
2321: LD_VAR 0 1
2325: RET
// export function AmericanReinforcements ; var i , vehs , veh ; begin
2326: LD_INT 0
2328: PPUSH
2329: PPUSH
2330: PPUSH
2331: PPUSH
// uc_side := 1 ;
2332: LD_ADDR_OWVAR 20
2336: PUSH
2337: LD_INT 1
2339: ST_TO_ADDR
// uc_nation := 1 ;
2340: LD_ADDR_OWVAR 21
2344: PUSH
2345: LD_INT 1
2347: ST_TO_ADDR
// vehs := [ [ us_medium_tracked , engine_combustion , control_computer , us_double_gun ] , [ us_medium_tracked , engine_combustion , control_computer , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_computer , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_computer , us_radar ] , [ us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_computer , us_double_gun ] ] ;
2348: LD_ADDR_VAR 0 3
2352: PUSH
2353: LD_INT 3
2355: PUSH
2356: LD_INT 1
2358: PUSH
2359: LD_INT 3
2361: PUSH
2362: LD_INT 5
2364: PUSH
2365: EMPTY
2366: LIST
2367: LIST
2368: LIST
2369: LIST
2370: PUSH
2371: LD_INT 3
2373: PUSH
2374: LD_INT 1
2376: PUSH
2377: LD_INT 3
2379: PUSH
2380: LD_INT 7
2382: PUSH
2383: EMPTY
2384: LIST
2385: LIST
2386: LIST
2387: LIST
2388: PUSH
2389: LD_INT 3
2391: PUSH
2392: LD_INT 1
2394: PUSH
2395: LD_INT 3
2397: PUSH
2398: LD_INT 7
2400: PUSH
2401: EMPTY
2402: LIST
2403: LIST
2404: LIST
2405: LIST
2406: PUSH
2407: LD_INT 3
2409: PUSH
2410: LD_INT 1
2412: PUSH
2413: LD_INT 3
2415: PUSH
2416: LD_INT 11
2418: PUSH
2419: EMPTY
2420: LIST
2421: LIST
2422: LIST
2423: LIST
2424: PUSH
2425: LD_INT 4
2427: PUSH
2428: LD_INT 1
2430: PUSH
2431: LD_INT 3
2433: PUSH
2434: LD_INT 6
2436: PUSH
2437: EMPTY
2438: LIST
2439: LIST
2440: LIST
2441: LIST
2442: PUSH
2443: LD_INT 4
2445: PUSH
2446: LD_INT 1
2448: PUSH
2449: LD_INT 3
2451: PUSH
2452: LD_INT 5
2454: PUSH
2455: EMPTY
2456: LIST
2457: LIST
2458: LIST
2459: LIST
2460: PUSH
2461: EMPTY
2462: LIST
2463: LIST
2464: LIST
2465: LIST
2466: LIST
2467: LIST
2468: ST_TO_ADDR
// for i := 1 to 7 - Difficulty do
2469: LD_ADDR_VAR 0 2
2473: PUSH
2474: DOUBLE
2475: LD_INT 1
2477: DEC
2478: ST_TO_ADDR
2479: LD_INT 7
2481: PUSH
2482: LD_OWVAR 67
2486: MINUS
2487: PUSH
2488: FOR_TO
2489: IFFALSE 2598
// begin vc_chassis := vehs [ i ] [ 1 ] ;
2491: LD_ADDR_OWVAR 37
2495: PUSH
2496: LD_VAR 0 3
2500: PUSH
2501: LD_VAR 0 2
2505: ARRAY
2506: PUSH
2507: LD_INT 1
2509: ARRAY
2510: ST_TO_ADDR
// vc_engine := vehs [ i ] [ 2 ] ;
2511: LD_ADDR_OWVAR 39
2515: PUSH
2516: LD_VAR 0 3
2520: PUSH
2521: LD_VAR 0 2
2525: ARRAY
2526: PUSH
2527: LD_INT 2
2529: ARRAY
2530: ST_TO_ADDR
// vc_control := vehs [ i ] [ 3 ] ;
2531: LD_ADDR_OWVAR 38
2535: PUSH
2536: LD_VAR 0 3
2540: PUSH
2541: LD_VAR 0 2
2545: ARRAY
2546: PUSH
2547: LD_INT 3
2549: ARRAY
2550: ST_TO_ADDR
// vc_weapon := vehs [ i ] [ 4 ] ;
2551: LD_ADDR_OWVAR 40
2555: PUSH
2556: LD_VAR 0 3
2560: PUSH
2561: LD_VAR 0 2
2565: ARRAY
2566: PUSH
2567: LD_INT 4
2569: ARRAY
2570: ST_TO_ADDR
// veh := CreateVehicle ;
2571: LD_ADDR_VAR 0 4
2575: PUSH
2576: CALL_OW 45
2580: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2581: LD_VAR 0 4
2585: PPUSH
2586: LD_INT 8
2588: PPUSH
2589: LD_INT 0
2591: PPUSH
2592: CALL_OW 49
// end ;
2596: GO 2488
2598: POP
2599: POP
// end ; end_of_file
2600: LD_VAR 0 1
2604: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_north_2 , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_kamikadze , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ; var i , d , un , skill , tmp ; begin
2605: LD_INT 0
2607: PPUSH
2608: PPUSH
2609: PPUSH
2610: PPUSH
2611: PPUSH
2612: PPUSH
// if Difficulty = 1 then
2613: LD_OWVAR 67
2617: PUSH
2618: LD_INT 1
2620: EQUAL
2621: IFFALSE 2718
// begin tmp := [ [ 129 , 45 ] , [ 143 , 58 ] , [ 184 , 113 ] , [ 163 , 107 ] ] ;
2623: LD_ADDR_VAR 0 6
2627: PUSH
2628: LD_INT 129
2630: PUSH
2631: LD_INT 45
2633: PUSH
2634: EMPTY
2635: LIST
2636: LIST
2637: PUSH
2638: LD_INT 143
2640: PUSH
2641: LD_INT 58
2643: PUSH
2644: EMPTY
2645: LIST
2646: LIST
2647: PUSH
2648: LD_INT 184
2650: PUSH
2651: LD_INT 113
2653: PUSH
2654: EMPTY
2655: LIST
2656: LIST
2657: PUSH
2658: LD_INT 163
2660: PUSH
2661: LD_INT 107
2663: PUSH
2664: EMPTY
2665: LIST
2666: LIST
2667: PUSH
2668: EMPTY
2669: LIST
2670: LIST
2671: LIST
2672: LIST
2673: ST_TO_ADDR
// for i in tmp do
2674: LD_ADDR_VAR 0 2
2678: PUSH
2679: LD_VAR 0 6
2683: PUSH
2684: FOR_IN
2685: IFFALSE 2716
// RemoveUnit ( HexInfo ( i [ 1 ] , i [ 2 ] ) ) ;
2687: LD_VAR 0 2
2691: PUSH
2692: LD_INT 1
2694: ARRAY
2695: PPUSH
2696: LD_VAR 0 2
2700: PUSH
2701: LD_INT 2
2703: ARRAY
2704: PPUSH
2705: CALL_OW 428
2709: PPUSH
2710: CALL_OW 64
2714: GO 2684
2716: POP
2717: POP
// end ; for i in FilterAllUnits ( [ f_type , unit_building ] ) do
2718: LD_ADDR_VAR 0 2
2722: PUSH
2723: LD_INT 21
2725: PUSH
2726: LD_INT 3
2728: PUSH
2729: EMPTY
2730: LIST
2731: LIST
2732: PPUSH
2733: CALL_OW 69
2737: PUSH
2738: FOR_IN
2739: IFFALSE 2776
// SetBLevel ( i , [ 5 , 6 , 7 , 8 ] [ Difficulty ] ) ;
2741: LD_VAR 0 2
2745: PPUSH
2746: LD_INT 5
2748: PUSH
2749: LD_INT 6
2751: PUSH
2752: LD_INT 7
2754: PUSH
2755: LD_INT 8
2757: PUSH
2758: EMPTY
2759: LIST
2760: LIST
2761: LIST
2762: LIST
2763: PUSH
2764: LD_OWVAR 67
2768: ARRAY
2769: PPUSH
2770: CALL_OW 241
2774: GO 2738
2776: POP
2777: POP
// skill := [ 5 , 6 , 7 , 8 ] [ Difficulty ] ;
2778: LD_ADDR_VAR 0 5
2782: PUSH
2783: LD_INT 5
2785: PUSH
2786: LD_INT 6
2788: PUSH
2789: LD_INT 7
2791: PUSH
2792: LD_INT 8
2794: PUSH
2795: EMPTY
2796: LIST
2797: LIST
2798: LIST
2799: LIST
2800: PUSH
2801: LD_OWVAR 67
2805: ARRAY
2806: ST_TO_ADDR
// uc_side := 2 ;
2807: LD_ADDR_OWVAR 20
2811: PUSH
2812: LD_INT 2
2814: ST_TO_ADDR
// uc_nation := 2 ;
2815: LD_ADDR_OWVAR 21
2819: PUSH
2820: LD_INT 2
2822: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
2823: LD_ADDR_OWVAR 37
2827: PUSH
2828: LD_INT 14
2830: ST_TO_ADDR
// vc_engine := engine_siberite ;
2831: LD_ADDR_OWVAR 39
2835: PUSH
2836: LD_INT 3
2838: ST_TO_ADDR
// vc_control := control_manual ;
2839: LD_ADDR_OWVAR 38
2843: PUSH
2844: LD_INT 1
2846: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
2847: LD_ADDR_OWVAR 40
2851: PUSH
2852: LD_INT 31
2854: ST_TO_ADDR
// for i = 1 to 3 do
2855: LD_ADDR_VAR 0 2
2859: PUSH
2860: DOUBLE
2861: LD_INT 1
2863: DEC
2864: ST_TO_ADDR
2865: LD_INT 3
2867: PUSH
2868: FOR_TO
2869: IFFALSE 2953
// begin PrepareHuman ( false , class_mechanic , skill ) ;
2871: LD_INT 0
2873: PPUSH
2874: LD_INT 3
2876: PPUSH
2877: LD_VAR 0 5
2881: PPUSH
2882: CALL_OW 380
// un := CreateVehicle ;
2886: LD_ADDR_VAR 0 4
2890: PUSH
2891: CALL_OW 45
2895: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
2896: LD_VAR 0 4
2900: PPUSH
2901: LD_INT 0
2903: PPUSH
2904: LD_INT 5
2906: PPUSH
2907: CALL_OW 12
2911: PPUSH
2912: CALL_OW 233
// PlaceUnitXYR ( un , 156 , 15 , 6 , false ) ;
2916: LD_VAR 0 4
2920: PPUSH
2921: LD_INT 156
2923: PPUSH
2924: LD_INT 15
2926: PPUSH
2927: LD_INT 6
2929: PPUSH
2930: LD_INT 0
2932: PPUSH
2933: CALL_OW 50
// PlaceHumanInUnit ( CreateHuman , un ) ;
2937: CALL_OW 44
2941: PPUSH
2942: LD_VAR 0 4
2946: PPUSH
2947: CALL_OW 52
// end ;
2951: GO 2868
2953: POP
2954: POP
// ar_force_north := PrepareBase ( ar_dep_n , base_north , dammam , skill , [ 10000 , 1000 , 300 ] , [ 12 , [ 2 , 3 , 4 , 4 ] [ Difficulty ] , - 1 , 4 ] ) ;
2955: LD_ADDR_EXP 37
2959: PUSH
2960: LD_INT 94
2962: PPUSH
2963: LD_INT 28
2965: PPUSH
2966: LD_STRING dammam
2968: PPUSH
2969: LD_VAR 0 5
2973: PPUSH
2974: LD_INT 10000
2976: PUSH
2977: LD_INT 1000
2979: PUSH
2980: LD_INT 300
2982: PUSH
2983: EMPTY
2984: LIST
2985: LIST
2986: LIST
2987: PPUSH
2988: LD_INT 12
2990: PUSH
2991: LD_INT 2
2993: PUSH
2994: LD_INT 3
2996: PUSH
2997: LD_INT 4
2999: PUSH
3000: LD_INT 4
3002: PUSH
3003: EMPTY
3004: LIST
3005: LIST
3006: LIST
3007: LIST
3008: PUSH
3009: LD_OWVAR 67
3013: ARRAY
3014: PUSH
3015: LD_INT 1
3017: NEG
3018: PUSH
3019: LD_INT 4
3021: PUSH
3022: EMPTY
3023: LIST
3024: LIST
3025: LIST
3026: LIST
3027: PPUSH
3028: CALL 57356 0 6
3032: ST_TO_ADDR
// ar_force_north := ar_force_north union PrepareBase ( ar_dep_n2 , base_north_2 ,  , skill , [ 500 , 60 , 0 ] , [ 8 , [ 2 , 3 , 4 , 5 ] [ Difficulty ] , 2 , 0 ] ) ;
3033: LD_ADDR_EXP 37
3037: PUSH
3038: LD_EXP 37
3042: PUSH
3043: LD_INT 122
3045: PPUSH
3046: LD_INT 25
3048: PPUSH
3049: LD_STRING 
3051: PPUSH
3052: LD_VAR 0 5
3056: PPUSH
3057: LD_INT 500
3059: PUSH
3060: LD_INT 60
3062: PUSH
3063: LD_INT 0
3065: PUSH
3066: EMPTY
3067: LIST
3068: LIST
3069: LIST
3070: PPUSH
3071: LD_INT 8
3073: PUSH
3074: LD_INT 2
3076: PUSH
3077: LD_INT 3
3079: PUSH
3080: LD_INT 4
3082: PUSH
3083: LD_INT 5
3085: PUSH
3086: EMPTY
3087: LIST
3088: LIST
3089: LIST
3090: LIST
3091: PUSH
3092: LD_OWVAR 67
3096: ARRAY
3097: PUSH
3098: LD_INT 2
3100: PUSH
3101: LD_INT 0
3103: PUSH
3104: EMPTY
3105: LIST
3106: LIST
3107: LIST
3108: LIST
3109: PPUSH
3110: CALL 57356 0 6
3114: UNION
3115: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , base_west , jeddah , skill , [ 700 , 300 , 10 ] , [ 9 , 4 , 3 , 2 ] ) ;
3116: LD_ADDR_EXP 35
3120: PUSH
3121: LD_INT 45
3123: PPUSH
3124: LD_INT 24
3126: PPUSH
3127: LD_STRING jeddah
3129: PPUSH
3130: LD_VAR 0 5
3134: PPUSH
3135: LD_INT 700
3137: PUSH
3138: LD_INT 300
3140: PUSH
3141: LD_INT 10
3143: PUSH
3144: EMPTY
3145: LIST
3146: LIST
3147: LIST
3148: PPUSH
3149: LD_INT 9
3151: PUSH
3152: LD_INT 4
3154: PUSH
3155: LD_INT 3
3157: PUSH
3158: LD_INT 2
3160: PUSH
3161: EMPTY
3162: LIST
3163: LIST
3164: LIST
3165: LIST
3166: PPUSH
3167: CALL 57356 0 6
3171: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , base_south , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
3172: LD_ADDR_EXP 36
3176: PUSH
3177: LD_INT 7
3179: PPUSH
3180: LD_INT 27
3182: PPUSH
3183: LD_STRING riyadh
3185: PPUSH
3186: LD_VAR 0 5
3190: PPUSH
3191: LD_INT 500
3193: PUSH
3194: LD_INT 60
3196: PUSH
3197: LD_INT 0
3199: PUSH
3200: EMPTY
3201: LIST
3202: LIST
3203: LIST
3204: PPUSH
3205: LD_INT 4
3207: PUSH
3208: LD_INT 2
3210: PUSH
3211: LD_INT 3
3213: PUSH
3214: LD_INT 1
3216: PUSH
3217: EMPTY
3218: LIST
3219: LIST
3220: LIST
3221: LIST
3222: PPUSH
3223: CALL 57356 0 6
3227: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e , base_east ,  , skill , [ 500 , 50 , 0 ] , [ 9 , 2 , 3 , 1 ] ) ;
3228: LD_ADDR_EXP 39
3232: PUSH
3233: LD_INT 204
3235: PPUSH
3236: LD_INT 26
3238: PPUSH
3239: LD_STRING 
3241: PPUSH
3242: LD_VAR 0 5
3246: PPUSH
3247: LD_INT 500
3249: PUSH
3250: LD_INT 50
3252: PUSH
3253: LD_INT 0
3255: PUSH
3256: EMPTY
3257: LIST
3258: LIST
3259: LIST
3260: PPUSH
3261: LD_INT 9
3263: PUSH
3264: LD_INT 2
3266: PUSH
3267: LD_INT 3
3269: PUSH
3270: LD_INT 1
3272: PUSH
3273: EMPTY
3274: LIST
3275: LIST
3276: LIST
3277: LIST
3278: PPUSH
3279: CALL 57356 0 6
3283: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east ] ;
3284: LD_ADDR_EXP 50
3288: PUSH
3289: LD_EXP 37
3293: PUSH
3294: LD_EXP 35
3298: PUSH
3299: LD_EXP 39
3303: PUSH
3304: EMPTY
3305: LIST
3306: LIST
3307: LIST
3308: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
3309: LD_ADDR_VAR 0 2
3313: PUSH
3314: LD_INT 22
3316: PUSH
3317: LD_INT 2
3319: PUSH
3320: EMPTY
3321: LIST
3322: LIST
3323: PUSH
3324: LD_INT 30
3326: PUSH
3327: LD_INT 31
3329: PUSH
3330: EMPTY
3331: LIST
3332: LIST
3333: PUSH
3334: LD_INT 58
3336: PUSH
3337: EMPTY
3338: LIST
3339: PUSH
3340: EMPTY
3341: LIST
3342: LIST
3343: LIST
3344: PPUSH
3345: CALL_OW 69
3349: PUSH
3350: FOR_IN
3351: IFFALSE 3476
// begin if GetBase ( i ) then
3353: LD_VAR 0 2
3357: PPUSH
3358: CALL_OW 274
3362: IFFALSE 3366
// continue ;
3364: GO 3350
// d := GetDir ( i ) ;
3366: LD_ADDR_VAR 0 3
3370: PUSH
3371: LD_VAR 0 2
3375: PPUSH
3376: CALL_OW 254
3380: ST_TO_ADDR
// if d < 3 then
3381: LD_VAR 0 3
3385: PUSH
3386: LD_INT 3
3388: LESS
3389: IFFALSE 3407
// d := d + 3 else
3391: LD_ADDR_VAR 0 3
3395: PUSH
3396: LD_VAR 0 3
3400: PUSH
3401: LD_INT 3
3403: PLUS
3404: ST_TO_ADDR
3405: GO 3421
// d := d - 3 ;
3407: LD_ADDR_VAR 0 3
3411: PUSH
3412: LD_VAR 0 3
3416: PUSH
3417: LD_INT 3
3419: MINUS
3420: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
3421: LD_INT 0
3423: PPUSH
3424: LD_INT 8
3426: PPUSH
3427: LD_VAR 0 5
3431: PPUSH
3432: CALL_OW 380
// un := CreateHuman ;
3436: LD_ADDR_VAR 0 4
3440: PUSH
3441: CALL_OW 44
3445: ST_TO_ADDR
// SetDir ( un , d ) ;
3446: LD_VAR 0 4
3450: PPUSH
3451: LD_VAR 0 3
3455: PPUSH
3456: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
3460: LD_VAR 0 4
3464: PPUSH
3465: LD_VAR 0 2
3469: PPUSH
3470: CALL_OW 52
// end ;
3474: GO 3350
3476: POP
3477: POP
// if Difficulty > 1 then
3478: LD_OWVAR 67
3482: PUSH
3483: LD_INT 1
3485: GREATER
3486: IFFALSE 3857
// begin ar_kamikadze := [ ] ;
3488: LD_ADDR_EXP 42
3492: PUSH
3493: EMPTY
3494: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
3495: LD_INT 0
3497: PPUSH
3498: LD_INT 1
3500: PPUSH
3501: LD_VAR 0 5
3505: PPUSH
3506: CALL_OW 380
// un := CreateHuman ;
3510: LD_ADDR_VAR 0 4
3514: PUSH
3515: CALL_OW 44
3519: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3520: LD_VAR 0 4
3524: PPUSH
3525: LD_INT 3
3527: PPUSH
3528: CALL_OW 233
// PlaceUnitXY ( un , 23 , 44 , false ) ;
3532: LD_VAR 0 4
3536: PPUSH
3537: LD_INT 23
3539: PPUSH
3540: LD_INT 44
3542: PPUSH
3543: LD_INT 0
3545: PPUSH
3546: CALL_OW 48
// ComCrawl ( un ) ;
3550: LD_VAR 0 4
3554: PPUSH
3555: CALL_OW 137
// un := CreateHuman ;
3559: LD_ADDR_VAR 0 4
3563: PUSH
3564: CALL_OW 44
3568: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3569: LD_VAR 0 4
3573: PPUSH
3574: LD_INT 3
3576: PPUSH
3577: CALL_OW 233
// PlaceUnitXY ( un , 30 , 39 , false ) ;
3581: LD_VAR 0 4
3585: PPUSH
3586: LD_INT 30
3588: PPUSH
3589: LD_INT 39
3591: PPUSH
3592: LD_INT 0
3594: PPUSH
3595: CALL_OW 48
// ComCrawl ( un ) ;
3599: LD_VAR 0 4
3603: PPUSH
3604: CALL_OW 137
// PrepareHuman ( false , 17 , skill ) ;
3608: LD_INT 0
3610: PPUSH
3611: LD_INT 17
3613: PPUSH
3614: LD_VAR 0 5
3618: PPUSH
3619: CALL_OW 380
// un := CreateHuman ;
3623: LD_ADDR_VAR 0 4
3627: PUSH
3628: CALL_OW 44
3632: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3633: LD_VAR 0 4
3637: PPUSH
3638: LD_INT 3
3640: PPUSH
3641: CALL_OW 233
// PlaceUnitXY ( un , 45 , 86 , false ) ;
3645: LD_VAR 0 4
3649: PPUSH
3650: LD_INT 45
3652: PPUSH
3653: LD_INT 86
3655: PPUSH
3656: LD_INT 0
3658: PPUSH
3659: CALL_OW 48
// ComHold ( un ) ;
3663: LD_VAR 0 4
3667: PPUSH
3668: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3672: LD_ADDR_EXP 42
3676: PUSH
3677: LD_EXP 42
3681: PPUSH
3682: LD_EXP 42
3686: PUSH
3687: LD_INT 1
3689: PLUS
3690: PPUSH
3691: LD_VAR 0 4
3695: PPUSH
3696: CALL_OW 1
3700: ST_TO_ADDR
// un := CreateHuman ;
3701: LD_ADDR_VAR 0 4
3705: PUSH
3706: CALL_OW 44
3710: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3711: LD_VAR 0 4
3715: PPUSH
3716: LD_INT 3
3718: PPUSH
3719: CALL_OW 233
// PlaceUnitXY ( un , 60 , 85 , false ) ;
3723: LD_VAR 0 4
3727: PPUSH
3728: LD_INT 60
3730: PPUSH
3731: LD_INT 85
3733: PPUSH
3734: LD_INT 0
3736: PPUSH
3737: CALL_OW 48
// ComHold ( un ) ;
3741: LD_VAR 0 4
3745: PPUSH
3746: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3750: LD_ADDR_EXP 42
3754: PUSH
3755: LD_EXP 42
3759: PPUSH
3760: LD_EXP 42
3764: PUSH
3765: LD_INT 1
3767: PLUS
3768: PPUSH
3769: LD_VAR 0 4
3773: PPUSH
3774: CALL_OW 1
3778: ST_TO_ADDR
// un := CreateHuman ;
3779: LD_ADDR_VAR 0 4
3783: PUSH
3784: CALL_OW 44
3788: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3789: LD_VAR 0 4
3793: PPUSH
3794: LD_INT 3
3796: PPUSH
3797: CALL_OW 233
// PlaceUnitXY ( un , 222 , 166 , false ) ;
3801: LD_VAR 0 4
3805: PPUSH
3806: LD_INT 222
3808: PPUSH
3809: LD_INT 166
3811: PPUSH
3812: LD_INT 0
3814: PPUSH
3815: CALL_OW 48
// ComHold ( un ) ;
3819: LD_VAR 0 4
3823: PPUSH
3824: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3828: LD_ADDR_EXP 42
3832: PUSH
3833: LD_EXP 42
3837: PPUSH
3838: LD_EXP 42
3842: PUSH
3843: LD_INT 1
3845: PLUS
3846: PPUSH
3847: LD_VAR 0 4
3851: PPUSH
3852: CALL_OW 1
3856: ST_TO_ADDR
// end ; ar_force_tmp := [ ] ;
3857: LD_ADDR_EXP 40
3861: PUSH
3862: EMPTY
3863: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
3864: LD_INT 1
3866: PPUSH
3867: LD_INT 1
3869: PPUSH
3870: LD_VAR 0 5
3874: PPUSH
3875: CALL_OW 380
// hc_name := Pavel Grigorovic ;
3879: LD_ADDR_OWVAR 26
3883: PUSH
3884: LD_STRING Pavel Grigorovic
3886: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3887: LD_ADDR_OWVAR 33
3891: PUSH
3892: LD_STRING SecondCharsGal
3894: ST_TO_ADDR
// hc_face_number := 4 ;
3895: LD_ADDR_OWVAR 34
3899: PUSH
3900: LD_INT 4
3902: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
3903: LD_ADDR_EXP 40
3907: PUSH
3908: LD_EXP 40
3912: PPUSH
3913: LD_INT 1
3915: PPUSH
3916: CALL_OW 44
3920: PPUSH
3921: CALL_OW 1
3925: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3926: LD_INT 2
3928: PPUSH
3929: LD_INT 4
3931: PPUSH
3932: LD_INT 2
3934: PPUSH
3935: CALL_OW 380
// hc_name := Lucy Sebel ;
3939: LD_ADDR_OWVAR 26
3943: PUSH
3944: LD_STRING Lucy Sebel
3946: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3947: LD_ADDR_OWVAR 33
3951: PUSH
3952: LD_STRING SecondCharsGal
3954: ST_TO_ADDR
// hc_face_number := 15 ;
3955: LD_ADDR_OWVAR 34
3959: PUSH
3960: LD_INT 15
3962: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
3963: LD_ADDR_EXP 40
3967: PUSH
3968: LD_EXP 40
3972: PPUSH
3973: LD_INT 2
3975: PPUSH
3976: CALL_OW 44
3980: PPUSH
3981: CALL_OW 1
3985: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3986: LD_INT 2
3988: PPUSH
3989: LD_INT 4
3991: PPUSH
3992: LD_INT 2
3994: PPUSH
3995: CALL_OW 380
// hc_gallery :=  ;
3999: LD_ADDR_OWVAR 33
4003: PUSH
4004: LD_STRING 
4006: ST_TO_ADDR
// hc_name :=  ;
4007: LD_ADDR_OWVAR 26
4011: PUSH
4012: LD_STRING 
4014: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
4015: LD_ADDR_EXP 40
4019: PUSH
4020: LD_EXP 40
4024: PPUSH
4025: LD_INT 3
4027: PPUSH
4028: CALL_OW 44
4032: PPUSH
4033: CALL_OW 1
4037: ST_TO_ADDR
// hc_sex := sex_male ;
4038: LD_ADDR_OWVAR 27
4042: PUSH
4043: LD_INT 1
4045: ST_TO_ADDR
// hc_class = 11 ;
4046: LD_ADDR_OWVAR 28
4050: PUSH
4051: LD_INT 11
4053: ST_TO_ADDR
// hc_gallery = sandar ;
4054: LD_ADDR_OWVAR 33
4058: PUSH
4059: LD_STRING sandar
4061: ST_TO_ADDR
// hc_face_number = 33 ;
4062: LD_ADDR_OWVAR 34
4066: PUSH
4067: LD_INT 33
4069: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
4070: LD_ADDR_OWVAR 26
4074: PUSH
4075: LD_STRING Thabit Muhair Saliba
4077: ST_TO_ADDR
// hc_skills = [ 0 , 0 , 0 , 0 ] ;
4078: LD_ADDR_OWVAR 31
4082: PUSH
4083: LD_INT 0
4085: PUSH
4086: LD_INT 0
4088: PUSH
4089: LD_INT 0
4091: PUSH
4092: LD_INT 0
4094: PUSH
4095: EMPTY
4096: LIST
4097: LIST
4098: LIST
4099: LIST
4100: ST_TO_ADDR
// Saliba = CreateHuman ;
4101: LD_ADDR_EXP 44
4105: PUSH
4106: CALL_OW 44
4110: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
4111: LD_EXP 44
4115: PPUSH
4116: LD_INT 7
4118: PPUSH
4119: CALL_OW 52
// if gensher_active then
4123: LD_EXP 18
4127: IFFALSE 4154
// begin Gensher = NewCharacter ( Dietrich ) ;
4129: LD_ADDR_EXP 45
4133: PUSH
4134: LD_STRING Dietrich
4136: PPUSH
4137: CALL_OW 25
4141: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
4142: LD_EXP 45
4146: PPUSH
4147: LD_INT 94
4149: PPUSH
4150: CALL_OW 52
// end ; InitHc ;
4154: CALL_OW 19
// ar_vehicles_tmp := [ ] ;
4158: LD_ADDR_EXP 41
4162: PUSH
4163: EMPTY
4164: ST_TO_ADDR
// for i = 1 to 5 do
4165: LD_ADDR_VAR 0 2
4169: PUSH
4170: DOUBLE
4171: LD_INT 1
4173: DEC
4174: ST_TO_ADDR
4175: LD_INT 5
4177: PUSH
4178: FOR_TO
4179: IFFALSE 4351
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , [ engine_combustion , engine_solar ] [ rand ( 1 , 2 ) ] , control_manual , [ ar_gatling_gun , ar_gun , ar_flame_thrower ] [ rand ( 1 , 3 ) ] , rand ( 60 , 100 ) ) ;
4181: LD_INT 13
4183: PUSH
4184: LD_INT 14
4186: PUSH
4187: EMPTY
4188: LIST
4189: LIST
4190: PUSH
4191: LD_INT 1
4193: PPUSH
4194: LD_INT 2
4196: PPUSH
4197: CALL_OW 12
4201: ARRAY
4202: PPUSH
4203: LD_INT 1
4205: PUSH
4206: LD_INT 2
4208: PUSH
4209: EMPTY
4210: LIST
4211: LIST
4212: PUSH
4213: LD_INT 1
4215: PPUSH
4216: LD_INT 2
4218: PPUSH
4219: CALL_OW 12
4223: ARRAY
4224: PPUSH
4225: LD_INT 1
4227: PPUSH
4228: LD_INT 25
4230: PUSH
4231: LD_INT 27
4233: PUSH
4234: LD_INT 26
4236: PUSH
4237: EMPTY
4238: LIST
4239: LIST
4240: LIST
4241: PUSH
4242: LD_INT 1
4244: PPUSH
4245: LD_INT 3
4247: PPUSH
4248: CALL_OW 12
4252: ARRAY
4253: PPUSH
4254: LD_INT 60
4256: PPUSH
4257: LD_INT 100
4259: PPUSH
4260: CALL_OW 12
4264: PPUSH
4265: CALL 53912 0 5
// un := CreateVehicle ;
4269: LD_ADDR_VAR 0 4
4273: PUSH
4274: CALL_OW 45
4278: ST_TO_ADDR
// ar_vehicles_tmp := Replace ( ar_vehicles_tmp , ar_vehicles_tmp + 1 , un ) ;
4279: LD_ADDR_EXP 41
4283: PUSH
4284: LD_EXP 41
4288: PPUSH
4289: LD_EXP 41
4293: PUSH
4294: LD_INT 1
4296: PLUS
4297: PPUSH
4298: LD_VAR 0 4
4302: PPUSH
4303: CALL_OW 1
4307: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4308: LD_VAR 0 4
4312: PPUSH
4313: LD_INT 0
4315: PPUSH
4316: LD_INT 5
4318: PPUSH
4319: CALL_OW 12
4323: PPUSH
4324: CALL_OW 233
// PlaceUnitXYR ( un , 124 , 141 , 8 , false ) ;
4328: LD_VAR 0 4
4332: PPUSH
4333: LD_INT 124
4335: PPUSH
4336: LD_INT 141
4338: PPUSH
4339: LD_INT 8
4341: PPUSH
4342: LD_INT 0
4344: PPUSH
4345: CALL_OW 50
// end ;
4349: GO 4178
4351: POP
4352: POP
// ar_defenders_tmp := [ [ ] , [ ] , [ ] ] ;
4353: LD_ADDR_EXP 43
4357: PUSH
4358: EMPTY
4359: PUSH
4360: EMPTY
4361: PUSH
4362: EMPTY
4363: PUSH
4364: EMPTY
4365: LIST
4366: LIST
4367: LIST
4368: ST_TO_ADDR
// for d = 1 to [ 3 , 3 , 4 , 4 ] [ Difficulty ] do
4369: LD_ADDR_VAR 0 3
4373: PUSH
4374: DOUBLE
4375: LD_INT 1
4377: DEC
4378: ST_TO_ADDR
4379: LD_INT 3
4381: PUSH
4382: LD_INT 3
4384: PUSH
4385: LD_INT 4
4387: PUSH
4388: LD_INT 4
4390: PUSH
4391: EMPTY
4392: LIST
4393: LIST
4394: LIST
4395: LIST
4396: PUSH
4397: LD_OWVAR 67
4401: ARRAY
4402: PUSH
4403: FOR_TO
4404: IFFALSE 4618
// for i = 1 to 3 do
4406: LD_ADDR_VAR 0 2
4410: PUSH
4411: DOUBLE
4412: LD_INT 1
4414: DEC
4415: ST_TO_ADDR
4416: LD_INT 3
4418: PUSH
4419: FOR_TO
4420: IFFALSE 4614
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
4422: LD_INT 14
4424: PPUSH
4425: LD_INT 3
4427: PUSH
4428: LD_INT 2
4430: PUSH
4431: EMPTY
4432: LIST
4433: LIST
4434: PUSH
4435: LD_INT 1
4437: PPUSH
4438: LD_INT 2
4440: PPUSH
4441: CALL_OW 12
4445: ARRAY
4446: PPUSH
4447: LD_INT 1
4449: PUSH
4450: LD_INT 5
4452: PUSH
4453: EMPTY
4454: LIST
4455: LIST
4456: PUSH
4457: LD_INT 1
4459: PPUSH
4460: LD_INT 2
4462: PPUSH
4463: CALL_OW 12
4467: ARRAY
4468: PPUSH
4469: LD_INT 25
4471: PUSH
4472: LD_INT 27
4474: PUSH
4475: LD_INT 26
4477: PUSH
4478: LD_INT 28
4480: PUSH
4481: EMPTY
4482: LIST
4483: LIST
4484: LIST
4485: LIST
4486: PUSH
4487: LD_INT 1
4489: PPUSH
4490: LD_INT 4
4492: PPUSH
4493: CALL_OW 12
4497: ARRAY
4498: PPUSH
4499: LD_INT 100
4501: PPUSH
4502: CALL 53912 0 5
// un := CreateVehicle ;
4506: LD_ADDR_VAR 0 4
4510: PUSH
4511: CALL_OW 45
4515: ST_TO_ADDR
// ar_defenders_tmp := ReplaceIn ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
4516: LD_ADDR_EXP 43
4520: PUSH
4521: LD_EXP 43
4525: PPUSH
4526: LD_VAR 0 2
4530: PUSH
4531: LD_EXP 43
4535: PUSH
4536: LD_VAR 0 2
4540: ARRAY
4541: PUSH
4542: LD_INT 1
4544: PLUS
4545: PUSH
4546: EMPTY
4547: LIST
4548: LIST
4549: PPUSH
4550: LD_VAR 0 4
4554: PPUSH
4555: CALL 54034 0 3
4559: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4560: LD_VAR 0 4
4564: PPUSH
4565: LD_INT 0
4567: PPUSH
4568: LD_INT 5
4570: PPUSH
4571: CALL_OW 12
4575: PPUSH
4576: CALL_OW 233
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east ] [ i ] , false ) ;
4580: LD_VAR 0 4
4584: PPUSH
4585: LD_INT 20
4587: PUSH
4588: LD_INT 21
4590: PUSH
4591: LD_INT 22
4593: PUSH
4594: EMPTY
4595: LIST
4596: LIST
4597: LIST
4598: PUSH
4599: LD_VAR 0 2
4603: ARRAY
4604: PPUSH
4605: LD_INT 0
4607: PPUSH
4608: CALL_OW 49
// end ;
4612: GO 4419
4614: POP
4615: POP
4616: GO 4403
4618: POP
4619: POP
// InitHc ;
4620: CALL_OW 19
// CreateResourcesXY ( mat_artifact , 5 , 10 , 5 , false ) ;
4624: LD_INT 4
4626: PPUSH
4627: LD_INT 5
4629: PPUSH
4630: LD_INT 10
4632: PPUSH
4633: LD_INT 5
4635: PPUSH
4636: LD_INT 0
4638: PPUSH
4639: CALL_OW 58
// end ;
4643: LD_VAR 0 1
4647: RET
// every 0 0$1 trigger ar_kamikadze do var i ;
4648: LD_EXP 42
4652: IFFALSE 4726
4654: GO 4656
4656: DISABLE
4657: LD_INT 0
4659: PPUSH
// begin enable ;
4660: ENABLE
// for i in ar_kamikadze do
4661: LD_ADDR_VAR 0 1
4665: PUSH
4666: LD_EXP 42
4670: PUSH
4671: FOR_IN
4672: IFFALSE 4724
// if See ( 1 , i ) then
4674: LD_INT 1
4676: PPUSH
4677: LD_VAR 0 1
4681: PPUSH
4682: CALL_OW 292
4686: IFFALSE 4722
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
4688: LD_VAR 0 1
4692: PPUSH
4693: LD_INT 81
4695: PUSH
4696: LD_INT 2
4698: PUSH
4699: EMPTY
4700: LIST
4701: LIST
4702: PPUSH
4703: CALL_OW 69
4707: PPUSH
4708: LD_VAR 0 1
4712: PPUSH
4713: CALL_OW 74
4717: PPUSH
4718: CALL_OW 115
4722: GO 4671
4724: POP
4725: POP
// end ;
4726: PPOPN 1
4728: END
// every 5 5$20 trigger artifact_get do var i , cargo , tmp , pos ;
4729: LD_EXP 13
4733: IFFALSE 5050
4735: GO 4737
4737: DISABLE
4738: LD_INT 0
4740: PPUSH
4741: PPUSH
4742: PPUSH
4743: PPUSH
// begin repeat wait ( 0 0$1 ) ;
4744: LD_INT 35
4746: PPUSH
4747: CALL_OW 67
// until MC_GetProduceList ( 1 ) = 0 ;
4751: LD_INT 1
4753: PPUSH
4754: CALL 42994 0 1
4758: PUSH
4759: LD_INT 0
4761: EQUAL
4762: IFFALSE 4744
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
4764: LD_INT 1
4766: PPUSH
4767: LD_INT 14
4769: PUSH
4770: LD_INT 3
4772: PUSH
4773: LD_INT 2
4775: PUSH
4776: LD_INT 32
4778: PUSH
4779: EMPTY
4780: LIST
4781: LIST
4782: LIST
4783: LIST
4784: PUSH
4785: EMPTY
4786: LIST
4787: PPUSH
4788: CALL 42598 0 2
// repeat wait ( 0 0$1 ) ;
4792: LD_INT 35
4794: PPUSH
4795: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) ;
4799: LD_EXP 69
4803: PUSH
4804: LD_INT 1
4806: ARRAY
4807: PPUSH
4808: LD_INT 33
4810: PUSH
4811: LD_INT 2
4813: PUSH
4814: EMPTY
4815: LIST
4816: LIST
4817: PUSH
4818: LD_INT 34
4820: PUSH
4821: LD_INT 32
4823: PUSH
4824: EMPTY
4825: LIST
4826: LIST
4827: PUSH
4828: EMPTY
4829: LIST
4830: LIST
4831: PPUSH
4832: CALL_OW 72
4836: IFFALSE 4792
// cargo := UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) [ 1 ] ;
4838: LD_ADDR_VAR 0 2
4842: PUSH
4843: LD_EXP 69
4847: PUSH
4848: LD_INT 1
4850: ARRAY
4851: PPUSH
4852: LD_INT 33
4854: PUSH
4855: LD_INT 2
4857: PUSH
4858: EMPTY
4859: LIST
4860: LIST
4861: PUSH
4862: LD_INT 34
4864: PUSH
4865: LD_INT 32
4867: PUSH
4868: EMPTY
4869: LIST
4870: LIST
4871: PUSH
4872: EMPTY
4873: LIST
4874: LIST
4875: PPUSH
4876: CALL_OW 72
4880: PUSH
4881: LD_INT 1
4883: ARRAY
4884: ST_TO_ADDR
// pos := FindArtifact ( 5 ) ;
4885: LD_ADDR_VAR 0 4
4889: PUSH
4890: LD_INT 5
4892: PPUSH
4893: CALL_OW 469
4897: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4898: LD_INT 35
4900: PPUSH
4901: CALL_OW 67
// pos := FindArtifact ( 5 ) ;
4905: LD_ADDR_VAR 0 4
4909: PUSH
4910: LD_INT 5
4912: PPUSH
4913: CALL_OW 469
4917: ST_TO_ADDR
// tmp := 100 ;
4918: LD_ADDR_VAR 0 3
4922: PUSH
4923: LD_INT 100
4925: ST_TO_ADDR
// if pos then
4926: LD_VAR 0 4
4930: IFFALSE 4970
// tmp := DangerAtRangeXY ( 2 , pos [ 1 ] , pos [ 2 ] , 20 ) [ 4 ] ;
4932: LD_ADDR_VAR 0 3
4936: PUSH
4937: LD_INT 2
4939: PPUSH
4940: LD_VAR 0 4
4944: PUSH
4945: LD_INT 1
4947: ARRAY
4948: PPUSH
4949: LD_VAR 0 4
4953: PUSH
4954: LD_INT 2
4956: ARRAY
4957: PPUSH
4958: LD_INT 20
4960: PPUSH
4961: CALL 54930 0 4
4965: PUSH
4966: LD_INT 4
4968: ARRAY
4969: ST_TO_ADDR
// until pos and not artifact_oncargo and tmp < 10 ;
4970: LD_VAR 0 4
4974: PUSH
4975: LD_EXP 14
4979: NOT
4980: AND
4981: PUSH
4982: LD_VAR 0 3
4986: PUSH
4987: LD_INT 10
4989: LESS
4990: AND
4991: IFFALSE 4898
// ComGet ( cargo , pos [ 1 ] , pos [ 2 ] ) ;
4993: LD_VAR 0 2
4997: PPUSH
4998: LD_VAR 0 4
5002: PUSH
5003: LD_INT 1
5005: ARRAY
5006: PPUSH
5007: LD_VAR 0 4
5011: PUSH
5012: LD_INT 2
5014: ARRAY
5015: PPUSH
5016: CALL_OW 160
// AddComMoveXY ( cargo , 198 , 113 ) ;
5020: LD_VAR 0 2
5024: PPUSH
5025: LD_INT 198
5027: PPUSH
5028: LD_INT 113
5030: PPUSH
5031: CALL_OW 171
// AddComMoveXY ( cargo , 124 , 7 ) ;
5035: LD_VAR 0 2
5039: PPUSH
5040: LD_INT 124
5042: PPUSH
5043: LD_INT 7
5045: PPUSH
5046: CALL_OW 171
// end ;
5050: PPOPN 4
5052: END
// every 5 5$00 trigger base_captured do var i , un , tmp , skill , coords , flags , list ;
5053: LD_EXP 6
5057: IFFALSE 7020
5059: GO 5061
5061: DISABLE
5062: LD_INT 0
5064: PPUSH
5065: PPUSH
5066: PPUSH
5067: PPUSH
5068: PPUSH
5069: PPUSH
5070: PPUSH
// begin skill := [ 5 , 6 , 7 , 8 ] [ Difficulty ] ;
5071: LD_ADDR_VAR 0 4
5075: PUSH
5076: LD_INT 5
5078: PUSH
5079: LD_INT 6
5081: PUSH
5082: LD_INT 7
5084: PUSH
5085: LD_INT 8
5087: PUSH
5088: EMPTY
5089: LIST
5090: LIST
5091: LIST
5092: LIST
5093: PUSH
5094: LD_OWVAR 67
5098: ARRAY
5099: ST_TO_ADDR
// coords := [ ] ;
5100: LD_ADDR_VAR 0 5
5104: PUSH
5105: EMPTY
5106: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
5107: LD_ADDR_VAR 0 6
5111: PUSH
5112: LD_INT 0
5114: PUSH
5115: LD_INT 0
5117: PUSH
5118: LD_INT 0
5120: PUSH
5121: LD_INT 0
5123: PUSH
5124: LD_INT 1
5126: PUSH
5127: LD_INT 0
5129: PUSH
5130: LD_INT 0
5132: PUSH
5133: LD_INT 0
5135: PUSH
5136: LD_INT 1
5138: PUSH
5139: LD_INT 0
5141: PUSH
5142: EMPTY
5143: LIST
5144: LIST
5145: LIST
5146: LIST
5147: LIST
5148: LIST
5149: LIST
5150: LIST
5151: LIST
5152: LIST
5153: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ) ;
5154: LD_INT 1
5156: PPUSH
5157: LD_INT 14
5159: PUSH
5160: LD_INT 1
5162: PUSH
5163: LD_INT 2
5165: PUSH
5166: LD_INT 28
5168: PUSH
5169: EMPTY
5170: LIST
5171: LIST
5172: LIST
5173: LIST
5174: PUSH
5175: LD_INT 14
5177: PUSH
5178: LD_INT 1
5180: PUSH
5181: LD_INT 2
5183: PUSH
5184: LD_INT 25
5186: PUSH
5187: EMPTY
5188: LIST
5189: LIST
5190: LIST
5191: LIST
5192: PUSH
5193: LD_INT 14
5195: PUSH
5196: LD_INT 1
5198: PUSH
5199: LD_INT 2
5201: PUSH
5202: LD_INT 28
5204: PUSH
5205: EMPTY
5206: LIST
5207: LIST
5208: LIST
5209: LIST
5210: PUSH
5211: LD_INT 14
5213: PUSH
5214: LD_INT 1
5216: PUSH
5217: LD_INT 2
5219: PUSH
5220: LD_INT 29
5222: PUSH
5223: EMPTY
5224: LIST
5225: LIST
5226: LIST
5227: LIST
5228: PUSH
5229: EMPTY
5230: LIST
5231: LIST
5232: LIST
5233: LIST
5234: PPUSH
5235: CALL 42598 0 2
// wait ( [ 10 10$00 , 9 9$30 , 9 9$00 , 8 8$40 ] [ Difficulty ] ) ;
5239: LD_INT 21000
5241: PUSH
5242: LD_INT 19950
5244: PUSH
5245: LD_INT 18900
5247: PUSH
5248: LD_INT 18200
5250: PUSH
5251: EMPTY
5252: LIST
5253: LIST
5254: LIST
5255: LIST
5256: PUSH
5257: LD_OWVAR 67
5261: ARRAY
5262: PPUSH
5263: CALL_OW 67
// InitHc ;
5267: CALL_OW 19
// InitUc ;
5271: CALL_OW 18
// uc_side := 2 ;
5275: LD_ADDR_OWVAR 20
5279: PUSH
5280: LD_INT 2
5282: ST_TO_ADDR
// uc_nation := 2 ;
5283: LD_ADDR_OWVAR 21
5287: PUSH
5288: LD_INT 2
5290: ST_TO_ADDR
// tmp := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
5291: LD_ADDR_VAR 0 3
5295: PUSH
5296: EMPTY
5297: PUSH
5298: EMPTY
5299: PUSH
5300: EMPTY
5301: PUSH
5302: EMPTY
5303: PUSH
5304: EMPTY
5305: PUSH
5306: EMPTY
5307: LIST
5308: LIST
5309: LIST
5310: LIST
5311: LIST
5312: ST_TO_ADDR
// tmp := Replace ( tmp , 1 , mc_vehicles [ 1 ] diff FilterAllUnits ( [ f_or , [ f_weapon , ar_crane ] , [ f_weapon , ar_cargo_bay ] ] ) ) ;
5313: LD_ADDR_VAR 0 3
5317: PUSH
5318: LD_VAR 0 3
5322: PPUSH
5323: LD_INT 1
5325: PPUSH
5326: LD_EXP 69
5330: PUSH
5331: LD_INT 1
5333: ARRAY
5334: PUSH
5335: LD_INT 2
5337: PUSH
5338: LD_INT 34
5340: PUSH
5341: LD_INT 88
5343: PUSH
5344: EMPTY
5345: LIST
5346: LIST
5347: PUSH
5348: LD_INT 34
5350: PUSH
5351: LD_INT 32
5353: PUSH
5354: EMPTY
5355: LIST
5356: LIST
5357: PUSH
5358: EMPTY
5359: LIST
5360: LIST
5361: LIST
5362: PPUSH
5363: CALL_OW 69
5367: DIFF
5368: PPUSH
5369: CALL_OW 1
5373: ST_TO_ADDR
// for i = 1 to Difficulty do
5374: LD_ADDR_VAR 0 1
5378: PUSH
5379: DOUBLE
5380: LD_INT 1
5382: DEC
5383: ST_TO_ADDR
5384: LD_OWVAR 67
5388: PUSH
5389: FOR_TO
5390: IFFALSE 5528
// begin uc_side := 2 ;
5392: LD_ADDR_OWVAR 20
5396: PUSH
5397: LD_INT 2
5399: ST_TO_ADDR
// uc_nation := 2 ;
5400: LD_ADDR_OWVAR 21
5404: PUSH
5405: LD_INT 2
5407: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
5408: LD_INT 13
5410: PPUSH
5411: LD_INT 3
5413: PPUSH
5414: LD_INT 5
5416: PPUSH
5417: LD_INT 29
5419: PPUSH
5420: LD_INT 100
5422: PPUSH
5423: CALL 53912 0 5
// un := CreateVehicle ;
5427: LD_ADDR_VAR 0 2
5431: PUSH
5432: CALL_OW 45
5436: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 1 , tmp [ 1 ] + 1 ] , un ) ;
5437: LD_ADDR_VAR 0 3
5441: PUSH
5442: LD_VAR 0 3
5446: PPUSH
5447: LD_INT 1
5449: PUSH
5450: LD_VAR 0 3
5454: PUSH
5455: LD_INT 1
5457: ARRAY
5458: PUSH
5459: LD_INT 1
5461: PLUS
5462: PUSH
5463: EMPTY
5464: LIST
5465: LIST
5466: PPUSH
5467: LD_VAR 0 2
5471: PPUSH
5472: CALL 54034 0 3
5476: ST_TO_ADDR
// SetDir ( un , 3 ) ;
5477: LD_VAR 0 2
5481: PPUSH
5482: LD_INT 3
5484: PPUSH
5485: CALL_OW 233
// PlaceUnitArea ( un , north_attack_spawn , false ) ;
5489: LD_VAR 0 2
5493: PPUSH
5494: LD_INT 16
5496: PPUSH
5497: LD_INT 0
5499: PPUSH
5500: CALL_OW 49
// ComMoveXY ( un , 51 , 10 ) ;
5504: LD_VAR 0 2
5508: PPUSH
5509: LD_INT 51
5511: PPUSH
5512: LD_INT 10
5514: PPUSH
5515: CALL_OW 111
// wait ( 0 0$2 ) ;
5519: LD_INT 70
5521: PPUSH
5522: CALL_OW 67
// end ;
5526: GO 5389
5528: POP
5529: POP
// coords := [ [ 51 , 24 ] , [ 75 , 90 ] ] ;
5530: LD_ADDR_VAR 0 5
5534: PUSH
5535: LD_INT 51
5537: PUSH
5538: LD_INT 24
5540: PUSH
5541: EMPTY
5542: LIST
5543: LIST
5544: PUSH
5545: LD_INT 75
5547: PUSH
5548: LD_INT 90
5550: PUSH
5551: EMPTY
5552: LIST
5553: LIST
5554: PUSH
5555: EMPTY
5556: LIST
5557: LIST
5558: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 1 ] , coords , flags ) ;
5559: LD_INT 1
5561: PPUSH
5562: LD_VAR 0 3
5566: PUSH
5567: LD_INT 1
5569: ARRAY
5570: PPUSH
5571: LD_VAR 0 5
5575: PPUSH
5576: LD_VAR 0 6
5580: PPUSH
5581: CALL 42831 0 4
// for i = 1 to [ 1 , 3 , 4 , 5 ] [ Difficulty ] do
5585: LD_ADDR_VAR 0 1
5589: PUSH
5590: DOUBLE
5591: LD_INT 1
5593: DEC
5594: ST_TO_ADDR
5595: LD_INT 1
5597: PUSH
5598: LD_INT 3
5600: PUSH
5601: LD_INT 4
5603: PUSH
5604: LD_INT 5
5606: PUSH
5607: EMPTY
5608: LIST
5609: LIST
5610: LIST
5611: LIST
5612: PUSH
5613: LD_OWVAR 67
5617: ARRAY
5618: PUSH
5619: FOR_TO
5620: IFFALSE 5720
// begin uc_side := 2 ;
5622: LD_ADDR_OWVAR 20
5626: PUSH
5627: LD_INT 2
5629: ST_TO_ADDR
// uc_nation := 2 ;
5630: LD_ADDR_OWVAR 21
5634: PUSH
5635: LD_INT 2
5637: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5638: LD_INT 0
5640: PPUSH
5641: LD_INT 17
5643: PPUSH
5644: LD_VAR 0 4
5648: PPUSH
5649: CALL_OW 380
// un := CreateHuman ;
5653: LD_ADDR_VAR 0 2
5657: PUSH
5658: CALL_OW 44
5662: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5663: LD_ADDR_VAR 0 3
5667: PUSH
5668: LD_VAR 0 3
5672: PPUSH
5673: LD_INT 2
5675: PUSH
5676: LD_VAR 0 3
5680: PUSH
5681: LD_INT 2
5683: ARRAY
5684: PUSH
5685: LD_INT 1
5687: PLUS
5688: PUSH
5689: EMPTY
5690: LIST
5691: LIST
5692: PPUSH
5693: LD_VAR 0 2
5697: PPUSH
5698: CALL 54034 0 3
5702: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5703: LD_VAR 0 2
5707: PPUSH
5708: LD_INT 13
5710: PPUSH
5711: LD_INT 0
5713: PPUSH
5714: CALL_OW 49
// end ;
5718: GO 5619
5720: POP
5721: POP
// for i = 1 to [ 3 , 4 , 5 , 6 ] [ Difficulty ] do
5722: LD_ADDR_VAR 0 1
5726: PUSH
5727: DOUBLE
5728: LD_INT 1
5730: DEC
5731: ST_TO_ADDR
5732: LD_INT 3
5734: PUSH
5735: LD_INT 4
5737: PUSH
5738: LD_INT 5
5740: PUSH
5741: LD_INT 6
5743: PUSH
5744: EMPTY
5745: LIST
5746: LIST
5747: LIST
5748: LIST
5749: PUSH
5750: LD_OWVAR 67
5754: ARRAY
5755: PUSH
5756: FOR_TO
5757: IFFALSE 5878
// begin uc_side := 2 ;
5759: LD_ADDR_OWVAR 20
5763: PUSH
5764: LD_INT 2
5766: ST_TO_ADDR
// uc_nation := 2 ;
5767: LD_ADDR_OWVAR 21
5771: PUSH
5772: LD_INT 2
5774: ST_TO_ADDR
// PrepareHuman ( false , [ 1 , 8 ] [ i mod 2 + 1 ] , skill ) ;
5775: LD_INT 0
5777: PPUSH
5778: LD_INT 1
5780: PUSH
5781: LD_INT 8
5783: PUSH
5784: EMPTY
5785: LIST
5786: LIST
5787: PUSH
5788: LD_VAR 0 1
5792: PUSH
5793: LD_INT 2
5795: MOD
5796: PUSH
5797: LD_INT 1
5799: PLUS
5800: ARRAY
5801: PPUSH
5802: LD_VAR 0 4
5806: PPUSH
5807: CALL_OW 380
// un := CreateHuman ;
5811: LD_ADDR_VAR 0 2
5815: PUSH
5816: CALL_OW 44
5820: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5821: LD_ADDR_VAR 0 3
5825: PUSH
5826: LD_VAR 0 3
5830: PPUSH
5831: LD_INT 2
5833: PUSH
5834: LD_VAR 0 3
5838: PUSH
5839: LD_INT 2
5841: ARRAY
5842: PUSH
5843: LD_INT 1
5845: PLUS
5846: PUSH
5847: EMPTY
5848: LIST
5849: LIST
5850: PPUSH
5851: LD_VAR 0 2
5855: PPUSH
5856: CALL 54034 0 3
5860: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5861: LD_VAR 0 2
5865: PPUSH
5866: LD_INT 13
5868: PPUSH
5869: LD_INT 0
5871: PPUSH
5872: CALL_OW 49
// end ;
5876: GO 5756
5878: POP
5879: POP
// coords := [ [ 67 , 112 ] , [ 85 , 130 ] ] ;
5880: LD_ADDR_VAR 0 5
5884: PUSH
5885: LD_INT 67
5887: PUSH
5888: LD_INT 112
5890: PUSH
5891: EMPTY
5892: LIST
5893: LIST
5894: PUSH
5895: LD_INT 85
5897: PUSH
5898: LD_INT 130
5900: PUSH
5901: EMPTY
5902: LIST
5903: LIST
5904: PUSH
5905: EMPTY
5906: LIST
5907: LIST
5908: ST_TO_ADDR
// MC_PrepareAttack ( 2 , tmp [ 2 ] , coords , flags ) ;
5909: LD_INT 2
5911: PPUSH
5912: LD_VAR 0 3
5916: PUSH
5917: LD_INT 2
5919: ARRAY
5920: PPUSH
5921: LD_VAR 0 5
5925: PPUSH
5926: LD_VAR 0 6
5930: PPUSH
5931: CALL 42831 0 4
// for i = 1 to [ 1 , 2 , 3 , 5 ] [ Difficulty ] do
5935: LD_ADDR_VAR 0 1
5939: PUSH
5940: DOUBLE
5941: LD_INT 1
5943: DEC
5944: ST_TO_ADDR
5945: LD_INT 1
5947: PUSH
5948: LD_INT 2
5950: PUSH
5951: LD_INT 3
5953: PUSH
5954: LD_INT 5
5956: PUSH
5957: EMPTY
5958: LIST
5959: LIST
5960: LIST
5961: LIST
5962: PUSH
5963: LD_OWVAR 67
5967: ARRAY
5968: PUSH
5969: FOR_TO
5970: IFFALSE 6070
// begin uc_side := 2 ;
5972: LD_ADDR_OWVAR 20
5976: PUSH
5977: LD_INT 2
5979: ST_TO_ADDR
// uc_nation := 2 ;
5980: LD_ADDR_OWVAR 21
5984: PUSH
5985: LD_INT 2
5987: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5988: LD_INT 0
5990: PPUSH
5991: LD_INT 17
5993: PPUSH
5994: LD_VAR 0 4
5998: PPUSH
5999: CALL_OW 380
// un := CreateHuman ;
6003: LD_ADDR_VAR 0 2
6007: PUSH
6008: CALL_OW 44
6012: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 3 , tmp [ 3 ] + 1 ] , un ) ;
6013: LD_ADDR_VAR 0 3
6017: PUSH
6018: LD_VAR 0 3
6022: PPUSH
6023: LD_INT 3
6025: PUSH
6026: LD_VAR 0 3
6030: PUSH
6031: LD_INT 3
6033: ARRAY
6034: PUSH
6035: LD_INT 1
6037: PLUS
6038: PUSH
6039: EMPTY
6040: LIST
6041: LIST
6042: PPUSH
6043: LD_VAR 0 2
6047: PPUSH
6048: CALL 54034 0 3
6052: ST_TO_ADDR
// PlaceUnitArea ( un , south_attack_spawn , false ) ;
6053: LD_VAR 0 2
6057: PPUSH
6058: LD_INT 14
6060: PPUSH
6061: LD_INT 0
6063: PPUSH
6064: CALL_OW 49
// end ;
6068: GO 5969
6070: POP
6071: POP
// coords := [ [ 148 , 158 ] , [ 148 , 158 ] ] ;
6072: LD_ADDR_VAR 0 5
6076: PUSH
6077: LD_INT 148
6079: PUSH
6080: LD_INT 158
6082: PUSH
6083: EMPTY
6084: LIST
6085: LIST
6086: PUSH
6087: LD_INT 148
6089: PUSH
6090: LD_INT 158
6092: PUSH
6093: EMPTY
6094: LIST
6095: LIST
6096: PUSH
6097: EMPTY
6098: LIST
6099: LIST
6100: ST_TO_ADDR
// MC_PrepareAttack ( 3 , tmp [ 3 ] , coords , flags ) ;
6101: LD_INT 3
6103: PPUSH
6104: LD_VAR 0 3
6108: PUSH
6109: LD_INT 3
6111: ARRAY
6112: PPUSH
6113: LD_VAR 0 5
6117: PPUSH
6118: LD_VAR 0 6
6122: PPUSH
6123: CALL 42831 0 4
// for i = 1 to [ 2 , 3 , 4 , 5 ] [ Difficulty ] do
6127: LD_ADDR_VAR 0 1
6131: PUSH
6132: DOUBLE
6133: LD_INT 1
6135: DEC
6136: ST_TO_ADDR
6137: LD_INT 2
6139: PUSH
6140: LD_INT 3
6142: PUSH
6143: LD_INT 4
6145: PUSH
6146: LD_INT 5
6148: PUSH
6149: EMPTY
6150: LIST
6151: LIST
6152: LIST
6153: LIST
6154: PUSH
6155: LD_OWVAR 67
6159: ARRAY
6160: PUSH
6161: FOR_TO
6162: IFFALSE 6386
// begin uc_side := 2 ;
6164: LD_ADDR_OWVAR 20
6168: PUSH
6169: LD_INT 2
6171: ST_TO_ADDR
// uc_nation := 2 ;
6172: LD_ADDR_OWVAR 21
6176: PUSH
6177: LD_INT 2
6179: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 3 ) ] , 100 ) ;
6180: LD_INT 14
6182: PPUSH
6183: LD_INT 3
6185: PPUSH
6186: LD_INT 1
6188: PUSH
6189: LD_INT 5
6191: PUSH
6192: EMPTY
6193: LIST
6194: LIST
6195: PUSH
6196: LD_INT 1
6198: PPUSH
6199: LD_INT 2
6201: PPUSH
6202: CALL_OW 12
6206: ARRAY
6207: PPUSH
6208: LD_INT 27
6210: PUSH
6211: LD_INT 26
6213: PUSH
6214: LD_INT 28
6216: PUSH
6217: EMPTY
6218: LIST
6219: LIST
6220: LIST
6221: PUSH
6222: LD_INT 1
6224: PPUSH
6225: LD_INT 3
6227: PPUSH
6228: CALL_OW 12
6232: ARRAY
6233: PPUSH
6234: LD_INT 100
6236: PPUSH
6237: CALL 53912 0 5
// un := CreateVehicle ;
6241: LD_ADDR_VAR 0 2
6245: PUSH
6246: CALL_OW 45
6250: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , un ) ;
6251: LD_ADDR_VAR 0 3
6255: PUSH
6256: LD_VAR 0 3
6260: PPUSH
6261: LD_INT 4
6263: PUSH
6264: LD_VAR 0 3
6268: PUSH
6269: LD_INT 4
6271: ARRAY
6272: PUSH
6273: LD_INT 1
6275: PLUS
6276: PUSH
6277: EMPTY
6278: LIST
6279: LIST
6280: PPUSH
6281: LD_VAR 0 2
6285: PPUSH
6286: CALL 54034 0 3
6290: ST_TO_ADDR
// SetDir ( un , 5 ) ;
6291: LD_VAR 0 2
6295: PPUSH
6296: LD_INT 5
6298: PPUSH
6299: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
6303: LD_VAR 0 2
6307: PPUSH
6308: LD_INT 15
6310: PPUSH
6311: LD_INT 0
6313: PPUSH
6314: CALL_OW 49
// if GetControl ( un ) = control_manual then
6318: LD_VAR 0 2
6322: PPUSH
6323: CALL_OW 263
6327: PUSH
6328: LD_INT 1
6330: EQUAL
6331: IFFALSE 6362
// begin PrepareHuman ( false , 3 , skill ) ;
6333: LD_INT 0
6335: PPUSH
6336: LD_INT 3
6338: PPUSH
6339: LD_VAR 0 4
6343: PPUSH
6344: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
6348: CALL_OW 44
6352: PPUSH
6353: LD_VAR 0 2
6357: PPUSH
6358: CALL_OW 52
// end ; ComMoveXY ( un , 179 , 135 ) ;
6362: LD_VAR 0 2
6366: PPUSH
6367: LD_INT 179
6369: PPUSH
6370: LD_INT 135
6372: PPUSH
6373: CALL_OW 111
// wait ( 0 0$2 ) ;
6377: LD_INT 70
6379: PPUSH
6380: CALL_OW 67
// end ;
6384: GO 6161
6386: POP
6387: POP
// vc_chassis := 15 ;
6388: LD_ADDR_OWVAR 37
6392: PUSH
6393: LD_INT 15
6395: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateVehicle ) ;
6396: LD_ADDR_VAR 0 3
6400: PUSH
6401: LD_VAR 0 3
6405: PPUSH
6406: LD_INT 4
6408: PUSH
6409: LD_VAR 0 3
6413: PUSH
6414: LD_INT 4
6416: ARRAY
6417: PUSH
6418: LD_INT 1
6420: PLUS
6421: PUSH
6422: EMPTY
6423: LIST
6424: LIST
6425: PPUSH
6426: CALL_OW 45
6430: PPUSH
6431: CALL 54034 0 3
6435: ST_TO_ADDR
// PlaceUnitArea ( tmp [ 4 ] [ tmp [ 4 ] ] , east_attack_spawn , false ) ;
6436: LD_VAR 0 3
6440: PUSH
6441: LD_INT 4
6443: ARRAY
6444: PUSH
6445: LD_VAR 0 3
6449: PUSH
6450: LD_INT 4
6452: ARRAY
6453: ARRAY
6454: PPUSH
6455: LD_INT 15
6457: PPUSH
6458: LD_INT 0
6460: PPUSH
6461: CALL_OW 49
// PrepareHuman ( false , class_desert_warior , skill ) ;
6465: LD_INT 0
6467: PPUSH
6468: LD_INT 11
6470: PPUSH
6471: LD_VAR 0 4
6475: PPUSH
6476: CALL_OW 380
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateHuman ) ;
6480: LD_ADDR_VAR 0 3
6484: PUSH
6485: LD_VAR 0 3
6489: PPUSH
6490: LD_INT 4
6492: PUSH
6493: LD_VAR 0 3
6497: PUSH
6498: LD_INT 4
6500: ARRAY
6501: PUSH
6502: LD_INT 1
6504: PLUS
6505: PUSH
6506: EMPTY
6507: LIST
6508: LIST
6509: PPUSH
6510: CALL_OW 44
6514: PPUSH
6515: CALL 54034 0 3
6519: ST_TO_ADDR
// PlaceHumanInUnit ( tmp [ 4 ] [ tmp [ 4 ] ] , tmp [ 4 ] [ tmp [ 4 ] - 1 ] ) ;
6520: LD_VAR 0 3
6524: PUSH
6525: LD_INT 4
6527: ARRAY
6528: PUSH
6529: LD_VAR 0 3
6533: PUSH
6534: LD_INT 4
6536: ARRAY
6537: ARRAY
6538: PPUSH
6539: LD_VAR 0 3
6543: PUSH
6544: LD_INT 4
6546: ARRAY
6547: PUSH
6548: LD_VAR 0 3
6552: PUSH
6553: LD_INT 4
6555: ARRAY
6556: PUSH
6557: LD_INT 1
6559: MINUS
6560: ARRAY
6561: PPUSH
6562: CALL_OW 52
// coords := [ [ 148 , 140 ] ] ;
6566: LD_ADDR_VAR 0 5
6570: PUSH
6571: LD_INT 148
6573: PUSH
6574: LD_INT 140
6576: PUSH
6577: EMPTY
6578: LIST
6579: LIST
6580: PUSH
6581: EMPTY
6582: LIST
6583: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 4 ] , coords , flags ) ;
6584: LD_INT 1
6586: PPUSH
6587: LD_VAR 0 3
6591: PUSH
6592: LD_INT 4
6594: ARRAY
6595: PPUSH
6596: LD_VAR 0 5
6600: PPUSH
6601: LD_VAR 0 6
6605: PPUSH
6606: CALL 42831 0 4
// if gensher_active then
6610: LD_EXP 18
6614: IFFALSE 7020
// begin SayRadio ( Gensher , D10-Diet-1 ) ;
6616: LD_EXP 45
6620: PPUSH
6621: LD_STRING D10-Diet-1
6623: PPUSH
6624: CALL_OW 94
// for i = 1 to 2 do
6628: LD_ADDR_VAR 0 1
6632: PUSH
6633: DOUBLE
6634: LD_INT 1
6636: DEC
6637: ST_TO_ADDR
6638: LD_INT 2
6640: PUSH
6641: FOR_TO
6642: IFFALSE 6780
// begin uc_side := 2 ;
6644: LD_ADDR_OWVAR 20
6648: PUSH
6649: LD_INT 2
6651: ST_TO_ADDR
// uc_nation := 2 ;
6652: LD_ADDR_OWVAR 21
6656: PUSH
6657: LD_INT 2
6659: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
6660: LD_INT 13
6662: PPUSH
6663: LD_INT 3
6665: PPUSH
6666: LD_INT 5
6668: PPUSH
6669: LD_INT 29
6671: PPUSH
6672: LD_INT 100
6674: PPUSH
6675: CALL 53912 0 5
// un := CreateVehicle ;
6679: LD_ADDR_VAR 0 2
6683: PUSH
6684: CALL_OW 45
6688: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6689: LD_ADDR_VAR 0 3
6693: PUSH
6694: LD_VAR 0 3
6698: PPUSH
6699: LD_INT 5
6701: PUSH
6702: LD_VAR 0 3
6706: PUSH
6707: LD_INT 5
6709: ARRAY
6710: PUSH
6711: LD_INT 1
6713: PLUS
6714: PUSH
6715: EMPTY
6716: LIST
6717: LIST
6718: PPUSH
6719: LD_VAR 0 2
6723: PPUSH
6724: CALL 54034 0 3
6728: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6729: LD_VAR 0 2
6733: PPUSH
6734: LD_INT 0
6736: PPUSH
6737: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6741: LD_VAR 0 2
6745: PPUSH
6746: LD_INT 23
6748: PPUSH
6749: LD_INT 0
6751: PPUSH
6752: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6756: LD_VAR 0 2
6760: PPUSH
6761: LD_INT 85
6763: PPUSH
6764: LD_INT 152
6766: PPUSH
6767: CALL_OW 111
// wait ( 0 0$2 ) ;
6771: LD_INT 70
6773: PPUSH
6774: CALL_OW 67
// end ;
6778: GO 6641
6780: POP
6781: POP
// for i = 1 to [ 2 , 3 , 3 , 4 ] [ Difficulty ] do
6782: LD_ADDR_VAR 0 1
6786: PUSH
6787: DOUBLE
6788: LD_INT 1
6790: DEC
6791: ST_TO_ADDR
6792: LD_INT 2
6794: PUSH
6795: LD_INT 3
6797: PUSH
6798: LD_INT 3
6800: PUSH
6801: LD_INT 4
6803: PUSH
6804: EMPTY
6805: LIST
6806: LIST
6807: LIST
6808: LIST
6809: PUSH
6810: LD_OWVAR 67
6814: ARRAY
6815: PUSH
6816: FOR_TO
6817: IFFALSE 6974
// begin uc_side := 2 ;
6819: LD_ADDR_OWVAR 20
6823: PUSH
6824: LD_INT 2
6826: ST_TO_ADDR
// uc_nation := 2 ;
6827: LD_ADDR_OWVAR 21
6831: PUSH
6832: LD_INT 2
6834: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
6835: LD_INT 14
6837: PPUSH
6838: LD_INT 3
6840: PPUSH
6841: LD_INT 5
6843: PPUSH
6844: LD_INT 27
6846: PUSH
6847: LD_INT 28
6849: PUSH
6850: EMPTY
6851: LIST
6852: LIST
6853: PUSH
6854: LD_INT 1
6856: PPUSH
6857: LD_INT 2
6859: PPUSH
6860: CALL_OW 12
6864: ARRAY
6865: PPUSH
6866: LD_INT 100
6868: PPUSH
6869: CALL 53912 0 5
// un := CreateVehicle ;
6873: LD_ADDR_VAR 0 2
6877: PUSH
6878: CALL_OW 45
6882: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6883: LD_ADDR_VAR 0 3
6887: PUSH
6888: LD_VAR 0 3
6892: PPUSH
6893: LD_INT 5
6895: PUSH
6896: LD_VAR 0 3
6900: PUSH
6901: LD_INT 5
6903: ARRAY
6904: PUSH
6905: LD_INT 1
6907: PLUS
6908: PUSH
6909: EMPTY
6910: LIST
6911: LIST
6912: PPUSH
6913: LD_VAR 0 2
6917: PPUSH
6918: CALL 54034 0 3
6922: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6923: LD_VAR 0 2
6927: PPUSH
6928: LD_INT 0
6930: PPUSH
6931: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6935: LD_VAR 0 2
6939: PPUSH
6940: LD_INT 23
6942: PPUSH
6943: LD_INT 0
6945: PPUSH
6946: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6950: LD_VAR 0 2
6954: PPUSH
6955: LD_INT 85
6957: PPUSH
6958: LD_INT 152
6960: PPUSH
6961: CALL_OW 111
// wait ( 0 0$2 ) ;
6965: LD_INT 70
6967: PPUSH
6968: CALL_OW 67
// end ;
6972: GO 6816
6974: POP
6975: POP
// coords := [ [ 97 , 143 ] ] ;
6976: LD_ADDR_VAR 0 5
6980: PUSH
6981: LD_INT 97
6983: PUSH
6984: LD_INT 143
6986: PUSH
6987: EMPTY
6988: LIST
6989: LIST
6990: PUSH
6991: EMPTY
6992: LIST
6993: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 5 ] , coords , flags ) ;
6994: LD_INT 1
6996: PPUSH
6997: LD_VAR 0 3
7001: PUSH
7002: LD_INT 5
7004: ARRAY
7005: PPUSH
7006: LD_VAR 0 5
7010: PPUSH
7011: LD_VAR 0 6
7015: PPUSH
7016: CALL 42831 0 4
// end ; end ;
7020: PPOPN 7
7022: END
// every 9 9$0 + 15 15$0 do var i , tmp , tmp2 , coords , w , list , p ;
7023: GO 7025
7025: DISABLE
7026: LD_INT 0
7028: PPUSH
7029: PPUSH
7030: PPUSH
7031: PPUSH
7032: PPUSH
7033: PPUSH
7034: PPUSH
// begin enable ;
7035: ENABLE
// tmp := [ ] ;
7036: LD_ADDR_VAR 0 2
7040: PUSH
7041: EMPTY
7042: ST_TO_ADDR
// w := rand ( 1 , 3 ) ;
7043: LD_ADDR_VAR 0 5
7047: PUSH
7048: LD_INT 1
7050: PPUSH
7051: LD_INT 3
7053: PPUSH
7054: CALL_OW 12
7058: ST_TO_ADDR
// if w = 3 then
7059: LD_VAR 0 5
7063: PUSH
7064: LD_INT 3
7066: EQUAL
7067: IFFALSE 7154
// list := [ [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] else
7069: LD_ADDR_VAR 0 6
7073: PUSH
7074: LD_INT 11
7076: PUSH
7077: LD_INT 1
7079: PUSH
7080: LD_INT 2
7082: PUSH
7083: LD_INT 24
7085: PUSH
7086: EMPTY
7087: LIST
7088: LIST
7089: LIST
7090: LIST
7091: PUSH
7092: LD_INT 11
7094: PUSH
7095: LD_INT 1
7097: PUSH
7098: LD_INT 2
7100: PUSH
7101: LD_INT 24
7103: PUSH
7104: EMPTY
7105: LIST
7106: LIST
7107: LIST
7108: LIST
7109: PUSH
7110: LD_INT 11
7112: PUSH
7113: LD_INT 1
7115: PUSH
7116: LD_INT 2
7118: PUSH
7119: LD_INT 24
7121: PUSH
7122: EMPTY
7123: LIST
7124: LIST
7125: LIST
7126: LIST
7127: PUSH
7128: LD_INT 11
7130: PUSH
7131: LD_INT 1
7133: PUSH
7134: LD_INT 2
7136: PUSH
7137: LD_INT 24
7139: PUSH
7140: EMPTY
7141: LIST
7142: LIST
7143: LIST
7144: LIST
7145: PUSH
7146: EMPTY
7147: LIST
7148: LIST
7149: LIST
7150: LIST
7151: ST_TO_ADDR
7152: GO 7256
// list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ;
7154: LD_ADDR_VAR 0 6
7158: PUSH
7159: LD_INT 14
7161: PUSH
7162: LD_INT 1
7164: PUSH
7165: LD_INT 2
7167: PUSH
7168: LD_INT 28
7170: PUSH
7171: EMPTY
7172: LIST
7173: LIST
7174: LIST
7175: LIST
7176: PUSH
7177: LD_INT 14
7179: PUSH
7180: LD_INT 1
7182: PUSH
7183: LD_INT 2
7185: PUSH
7186: LD_INT 25
7188: PUSH
7189: EMPTY
7190: LIST
7191: LIST
7192: LIST
7193: LIST
7194: PUSH
7195: LD_INT 14
7197: PUSH
7198: LD_INT 1
7200: PUSH
7201: LD_INT 2
7203: PUSH
7204: LD_INT 28
7206: PUSH
7207: EMPTY
7208: LIST
7209: LIST
7210: LIST
7211: LIST
7212: PUSH
7213: LD_INT 14
7215: PUSH
7216: LD_INT 1
7218: PUSH
7219: LD_INT 2
7221: PUSH
7222: LD_INT 29
7224: PUSH
7225: EMPTY
7226: LIST
7227: LIST
7228: LIST
7229: LIST
7230: PUSH
7231: LD_INT 14
7233: PUSH
7234: LD_INT 1
7236: PUSH
7237: LD_INT 2
7239: PUSH
7240: LD_INT 29
7242: PUSH
7243: EMPTY
7244: LIST
7245: LIST
7246: LIST
7247: LIST
7248: PUSH
7249: EMPTY
7250: LIST
7251: LIST
7252: LIST
7253: LIST
7254: LIST
7255: ST_TO_ADDR
// if w < 3 then
7256: LD_VAR 0 5
7260: PUSH
7261: LD_INT 3
7263: LESS
7264: IFFALSE 7344
// list := ReplaceIn ( list , [ 1 , list [ i ] + 1 ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gatling_gun , ar_rocket_launcher , ar_selfpropelled_bomb ] [ rand ( 1 , 3 ) ] ] ) ;
7266: LD_ADDR_VAR 0 6
7270: PUSH
7271: LD_VAR 0 6
7275: PPUSH
7276: LD_INT 1
7278: PUSH
7279: LD_VAR 0 6
7283: PUSH
7284: LD_VAR 0 1
7288: ARRAY
7289: PUSH
7290: LD_INT 1
7292: PLUS
7293: PUSH
7294: EMPTY
7295: LIST
7296: LIST
7297: PPUSH
7298: LD_INT 14
7300: PUSH
7301: LD_INT 1
7303: PUSH
7304: LD_INT 2
7306: PUSH
7307: LD_INT 25
7309: PUSH
7310: LD_INT 28
7312: PUSH
7313: LD_INT 29
7315: PUSH
7316: EMPTY
7317: LIST
7318: LIST
7319: LIST
7320: PUSH
7321: LD_INT 1
7323: PPUSH
7324: LD_INT 3
7326: PPUSH
7327: CALL_OW 12
7331: ARRAY
7332: PUSH
7333: EMPTY
7334: LIST
7335: LIST
7336: LIST
7337: LIST
7338: PPUSH
7339: CALL 54034 0 3
7343: ST_TO_ADDR
// MC_SetProduceList ( 1 , list ) ;
7344: LD_INT 1
7346: PPUSH
7347: LD_VAR 0 6
7351: PPUSH
7352: CALL 42598 0 2
// if GetSide ( ar_dep_w ) = 2 and IsOk ( ar_dep_w ) and w < 3 then
7356: LD_INT 45
7358: PPUSH
7359: CALL_OW 255
7363: PUSH
7364: LD_INT 2
7366: EQUAL
7367: PUSH
7368: LD_INT 45
7370: PPUSH
7371: CALL_OW 302
7375: AND
7376: PUSH
7377: LD_VAR 0 5
7381: PUSH
7382: LD_INT 3
7384: LESS
7385: AND
7386: IFFALSE 7471
// begin list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] ] ;
7388: LD_ADDR_VAR 0 6
7392: PUSH
7393: LD_INT 14
7395: PUSH
7396: LD_INT 1
7398: PUSH
7399: LD_INT 2
7401: PUSH
7402: LD_INT 28
7404: PUSH
7405: EMPTY
7406: LIST
7407: LIST
7408: LIST
7409: LIST
7410: PUSH
7411: LD_INT 14
7413: PUSH
7414: LD_INT 1
7416: PUSH
7417: LD_INT 2
7419: PUSH
7420: LD_INT 27
7422: PUSH
7423: EMPTY
7424: LIST
7425: LIST
7426: LIST
7427: LIST
7428: PUSH
7429: LD_INT 14
7431: PUSH
7432: LD_INT 1
7434: PUSH
7435: LD_INT 2
7437: PUSH
7438: LD_INT 27
7440: PUSH
7441: EMPTY
7442: LIST
7443: LIST
7444: LIST
7445: LIST
7446: PUSH
7447: EMPTY
7448: LIST
7449: LIST
7450: LIST
7451: ST_TO_ADDR
// MC_SetProduceList ( 2 , list ) ;
7452: LD_INT 2
7454: PPUSH
7455: LD_VAR 0 6
7459: PPUSH
7460: CALL 42598 0 2
// wait ( 0 0$20 ) ;
7464: LD_INT 700
7466: PPUSH
7467: CALL_OW 67
// end ; p := 60 ;
7471: LD_ADDR_VAR 0 7
7475: PUSH
7476: LD_INT 60
7478: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7479: LD_INT 35
7481: PPUSH
7482: CALL_OW 67
// p := Dec ( p ) ;
7486: LD_ADDR_VAR 0 7
7490: PUSH
7491: LD_VAR 0 7
7495: PPUSH
7496: CALL 87747 0 1
7500: ST_TO_ADDR
// until UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ] ) >= 4 or p <= 0 ;
7501: LD_EXP 69
7505: PUSH
7506: LD_INT 1
7508: ARRAY
7509: PPUSH
7510: LD_INT 3
7512: PUSH
7513: LD_INT 2
7515: PUSH
7516: LD_INT 34
7518: PUSH
7519: LD_INT 32
7521: PUSH
7522: EMPTY
7523: LIST
7524: LIST
7525: PUSH
7526: LD_INT 34
7528: PUSH
7529: LD_INT 88
7531: PUSH
7532: EMPTY
7533: LIST
7534: LIST
7535: PUSH
7536: EMPTY
7537: LIST
7538: LIST
7539: LIST
7540: PUSH
7541: EMPTY
7542: LIST
7543: LIST
7544: PPUSH
7545: CALL_OW 72
7549: PUSH
7550: LD_INT 4
7552: GREATEREQUAL
7553: PUSH
7554: LD_VAR 0 7
7558: PUSH
7559: LD_INT 0
7561: LESSEQUAL
7562: OR
7563: IFFALSE 7479
// wait ( 0 0$10 ) ;
7565: LD_INT 350
7567: PPUSH
7568: CALL_OW 67
// tmp := UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ] ) ;
7572: LD_ADDR_VAR 0 2
7576: PUSH
7577: LD_EXP 69
7581: PUSH
7582: LD_INT 1
7584: ARRAY
7585: PPUSH
7586: LD_INT 3
7588: PUSH
7589: LD_INT 2
7591: PUSH
7592: LD_INT 34
7594: PUSH
7595: LD_INT 32
7597: PUSH
7598: EMPTY
7599: LIST
7600: LIST
7601: PUSH
7602: LD_INT 34
7604: PUSH
7605: LD_INT 88
7607: PUSH
7608: EMPTY
7609: LIST
7610: LIST
7611: PUSH
7612: EMPTY
7613: LIST
7614: LIST
7615: LIST
7616: PUSH
7617: EMPTY
7618: LIST
7619: LIST
7620: PPUSH
7621: CALL_OW 72
7625: ST_TO_ADDR
// tmp2 := UnitFilter ( mc_vehicles [ 2 ] , [ f_not , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ] ) ;
7626: LD_ADDR_VAR 0 3
7630: PUSH
7631: LD_EXP 69
7635: PUSH
7636: LD_INT 2
7638: ARRAY
7639: PPUSH
7640: LD_INT 3
7642: PUSH
7643: LD_INT 2
7645: PUSH
7646: LD_INT 34
7648: PUSH
7649: LD_INT 32
7651: PUSH
7652: EMPTY
7653: LIST
7654: LIST
7655: PUSH
7656: LD_INT 34
7658: PUSH
7659: LD_INT 88
7661: PUSH
7662: EMPTY
7663: LIST
7664: LIST
7665: PUSH
7666: EMPTY
7667: LIST
7668: LIST
7669: LIST
7670: PUSH
7671: EMPTY
7672: LIST
7673: LIST
7674: PPUSH
7675: CALL_OW 72
7679: ST_TO_ADDR
// if tmp2 then
7680: LD_VAR 0 3
7684: IFFALSE 7702
// tmp := tmp union tmp2 ;
7686: LD_ADDR_VAR 0 2
7690: PUSH
7691: LD_VAR 0 2
7695: PUSH
7696: LD_VAR 0 3
7700: UNION
7701: ST_TO_ADDR
// if not tmp then
7702: LD_VAR 0 2
7706: NOT
7707: IFFALSE 7711
// exit ;
7709: GO 8071
// if Count ( tmp2 ) or Prob ( 50 ) then
7711: LD_VAR 0 3
7715: PPUSH
7716: CALL 51174 0 1
7720: PUSH
7721: LD_INT 50
7723: PPUSH
7724: CALL_OW 13
7728: OR
7729: IFFALSE 7762
// coords := [ [ 48 , 33 ] , [ 71 , 88 ] ] else
7731: LD_ADDR_VAR 0 4
7735: PUSH
7736: LD_INT 48
7738: PUSH
7739: LD_INT 33
7741: PUSH
7742: EMPTY
7743: LIST
7744: LIST
7745: PUSH
7746: LD_INT 71
7748: PUSH
7749: LD_INT 88
7751: PUSH
7752: EMPTY
7753: LIST
7754: LIST
7755: PUSH
7756: EMPTY
7757: LIST
7758: LIST
7759: ST_TO_ADDR
7760: GO 7791
// coords := [ [ 128 , 94 ] , [ 180 , 135 ] ] ;
7762: LD_ADDR_VAR 0 4
7766: PUSH
7767: LD_INT 128
7769: PUSH
7770: LD_INT 94
7772: PUSH
7773: EMPTY
7774: LIST
7775: LIST
7776: PUSH
7777: LD_INT 180
7779: PUSH
7780: LD_INT 135
7782: PUSH
7783: EMPTY
7784: LIST
7785: LIST
7786: PUSH
7787: EMPTY
7788: LIST
7789: LIST
7790: ST_TO_ADDR
// if w = 3 then
7791: LD_VAR 0 5
7795: PUSH
7796: LD_INT 3
7798: EQUAL
7799: IFFALSE 7830
// coords := [ [ 91 , 58 ] , [ 117 , 107 ] ] ;
7801: LD_ADDR_VAR 0 4
7805: PUSH
7806: LD_INT 91
7808: PUSH
7809: LD_INT 58
7811: PUSH
7812: EMPTY
7813: LIST
7814: LIST
7815: PUSH
7816: LD_INT 117
7818: PUSH
7819: LD_INT 107
7821: PUSH
7822: EMPTY
7823: LIST
7824: LIST
7825: PUSH
7826: EMPTY
7827: LIST
7828: LIST
7829: ST_TO_ADDR
// if FilterUnitsInArea ( base_north , [ f_side , 1 ] ) then
7830: LD_INT 28
7832: PPUSH
7833: LD_INT 22
7835: PUSH
7836: LD_INT 1
7838: PUSH
7839: EMPTY
7840: LIST
7841: LIST
7842: PPUSH
7843: CALL_OW 70
7847: IFFALSE 7867
// coords := [ [ 163 , 41 ] ] ;
7849: LD_ADDR_VAR 0 4
7853: PUSH
7854: LD_INT 163
7856: PUSH
7857: LD_INT 41
7859: PUSH
7860: EMPTY
7861: LIST
7862: LIST
7863: PUSH
7864: EMPTY
7865: LIST
7866: ST_TO_ADDR
// ComAgressiveMove ( tmp , coords [ 1 ] , coords [ 2 ] ) ;
7867: LD_VAR 0 2
7871: PPUSH
7872: LD_VAR 0 4
7876: PUSH
7877: LD_INT 1
7879: ARRAY
7880: PPUSH
7881: LD_VAR 0 4
7885: PUSH
7886: LD_INT 2
7888: ARRAY
7889: PPUSH
7890: CALL_OW 114
// p := 90 ;
7894: LD_ADDR_VAR 0 7
7898: PUSH
7899: LD_INT 90
7901: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7902: LD_INT 35
7904: PPUSH
7905: CALL_OW 67
// p := Dec ( p ) ;
7909: LD_ADDR_VAR 0 7
7913: PUSH
7914: LD_VAR 0 7
7918: PPUSH
7919: CALL 87747 0 1
7923: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_hastask ] ) = 0 or p <= 0 ;
7924: LD_VAR 0 2
7928: PPUSH
7929: LD_INT 60
7931: PUSH
7932: EMPTY
7933: LIST
7934: PPUSH
7935: CALL_OW 72
7939: PUSH
7940: LD_INT 0
7942: EQUAL
7943: PUSH
7944: LD_VAR 0 7
7948: PUSH
7949: LD_INT 0
7951: LESSEQUAL
7952: OR
7953: IFFALSE 7902
// repeat wait ( 0 0$2 ) ;
7955: LD_INT 70
7957: PPUSH
7958: CALL_OW 67
// for i in tmp do
7962: LD_ADDR_VAR 0 1
7966: PUSH
7967: LD_VAR 0 2
7971: PUSH
7972: FOR_IN
7973: IFFALSE 8062
// if GetChassis ( i ) = ar_hovercraft then
7975: LD_VAR 0 1
7979: PPUSH
7980: CALL_OW 265
7984: PUSH
7985: LD_INT 11
7987: EQUAL
7988: IFFALSE 8026
// AttackHovercraft ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) else
7990: LD_VAR 0 1
7994: PPUSH
7995: LD_INT 22
7997: PUSH
7998: LD_INT 1
8000: PUSH
8001: EMPTY
8002: LIST
8003: LIST
8004: PPUSH
8005: CALL_OW 69
8009: PPUSH
8010: LD_VAR 0 1
8014: PPUSH
8015: CALL_OW 74
8019: PPUSH
8020: CALL 81980 0 2
8024: GO 8060
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
8026: LD_VAR 0 1
8030: PPUSH
8031: LD_INT 22
8033: PUSH
8034: LD_INT 1
8036: PUSH
8037: EMPTY
8038: LIST
8039: LIST
8040: PPUSH
8041: CALL_OW 69
8045: PPUSH
8046: LD_VAR 0 1
8050: PPUSH
8051: CALL_OW 74
8055: PPUSH
8056: CALL_OW 115
8060: GO 7972
8062: POP
8063: POP
// until not tmp ;
8064: LD_VAR 0 2
8068: NOT
8069: IFFALSE 7955
// end ;
8071: PPOPN 7
8073: END
// every 28 28$00 do var i , tmp , un , x , p ;
8074: GO 8076
8076: DISABLE
8077: LD_INT 0
8079: PPUSH
8080: PPUSH
8081: PPUSH
8082: PPUSH
8083: PPUSH
// begin enable ;
8084: ENABLE
// wait ( rand ( 0 0$1 , 0 0$34 ) ) ;
8085: LD_INT 35
8087: PPUSH
8088: LD_INT 1190
8090: PPUSH
8091: CALL_OW 12
8095: PPUSH
8096: CALL_OW 67
// tmp := [ ] ;
8100: LD_ADDR_VAR 0 2
8104: PUSH
8105: EMPTY
8106: ST_TO_ADDR
// InitHc ;
8107: CALL_OW 19
// for i = 1 to 3 do
8111: LD_ADDR_VAR 0 1
8115: PUSH
8116: DOUBLE
8117: LD_INT 1
8119: DEC
8120: ST_TO_ADDR
8121: LD_INT 3
8123: PUSH
8124: FOR_TO
8125: IFFALSE 8268
// begin uc_side := 8 ;
8127: LD_ADDR_OWVAR 20
8131: PUSH
8132: LD_INT 8
8134: ST_TO_ADDR
// uc_nation := 2 ;
8135: LD_ADDR_OWVAR 21
8139: PUSH
8140: LD_INT 2
8142: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
8143: LD_INT 13
8145: PUSH
8146: LD_INT 14
8148: PUSH
8149: EMPTY
8150: LIST
8151: LIST
8152: PUSH
8153: LD_INT 1
8155: PPUSH
8156: LD_INT 2
8158: PPUSH
8159: CALL_OW 12
8163: ARRAY
8164: PPUSH
8165: LD_INT 3
8167: PPUSH
8168: LD_INT 5
8170: PPUSH
8171: LD_INT 27
8173: PUSH
8174: LD_INT 28
8176: PUSH
8177: EMPTY
8178: LIST
8179: LIST
8180: PUSH
8181: LD_INT 1
8183: PPUSH
8184: LD_INT 2
8186: PPUSH
8187: CALL_OW 12
8191: ARRAY
8192: PPUSH
8193: LD_INT 100
8195: PPUSH
8196: CALL 53912 0 5
// un := CreateVehicle ;
8200: LD_ADDR_VAR 0 3
8204: PUSH
8205: CALL_OW 45
8209: ST_TO_ADDR
// SetDir ( un , 4 ) ;
8210: LD_VAR 0 3
8214: PPUSH
8215: LD_INT 4
8217: PPUSH
8218: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
8222: LD_VAR 0 3
8226: PPUSH
8227: LD_INT 15
8229: PPUSH
8230: LD_INT 0
8232: PPUSH
8233: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8237: LD_ADDR_VAR 0 2
8241: PUSH
8242: LD_VAR 0 2
8246: PPUSH
8247: LD_VAR 0 2
8251: PUSH
8252: LD_INT 1
8254: PLUS
8255: PPUSH
8256: LD_VAR 0 3
8260: PPUSH
8261: CALL_OW 1
8265: ST_TO_ADDR
// end ;
8266: GO 8124
8268: POP
8269: POP
// for i = 1 to 3 do
8270: LD_ADDR_VAR 0 1
8274: PUSH
8275: DOUBLE
8276: LD_INT 1
8278: DEC
8279: ST_TO_ADDR
8280: LD_INT 3
8282: PUSH
8283: FOR_TO
8284: IFFALSE 8392
// begin uc_side := 8 ;
8286: LD_ADDR_OWVAR 20
8290: PUSH
8291: LD_INT 8
8293: ST_TO_ADDR
// uc_nation := 2 ;
8294: LD_ADDR_OWVAR 21
8298: PUSH
8299: LD_INT 2
8301: ST_TO_ADDR
// PrepareHuman ( false , 1 , 6 ) ;
8302: LD_INT 0
8304: PPUSH
8305: LD_INT 1
8307: PPUSH
8308: LD_INT 6
8310: PPUSH
8311: CALL_OW 380
// un := CreateHuman ;
8315: LD_ADDR_VAR 0 3
8319: PUSH
8320: CALL_OW 44
8324: ST_TO_ADDR
// if Prob ( 50 ) then
8325: LD_INT 50
8327: PPUSH
8328: CALL_OW 13
8332: IFFALSE 8346
// SetClass ( un , class_mortar ) ;
8334: LD_VAR 0 3
8338: PPUSH
8339: LD_INT 8
8341: PPUSH
8342: CALL_OW 336
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
8346: LD_VAR 0 3
8350: PPUSH
8351: LD_INT 15
8353: PPUSH
8354: LD_INT 0
8356: PPUSH
8357: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8361: LD_ADDR_VAR 0 2
8365: PUSH
8366: LD_VAR 0 2
8370: PPUSH
8371: LD_VAR 0 2
8375: PUSH
8376: LD_INT 1
8378: PLUS
8379: PPUSH
8380: LD_VAR 0 3
8384: PPUSH
8385: CALL_OW 1
8389: ST_TO_ADDR
// end ;
8390: GO 8283
8392: POP
8393: POP
// wait ( 0 0$3 ) ;
8394: LD_INT 105
8396: PPUSH
8397: CALL_OW 67
// p := 0 ;
8401: LD_ADDR_VAR 0 5
8405: PUSH
8406: LD_INT 0
8408: ST_TO_ADDR
// repeat wait ( 0 0$3 ) ;
8409: LD_INT 105
8411: PPUSH
8412: CALL_OW 67
// p := p + 3 ;
8416: LD_ADDR_VAR 0 5
8420: PUSH
8421: LD_VAR 0 5
8425: PUSH
8426: LD_INT 3
8428: PLUS
8429: ST_TO_ADDR
// for i in UnitFilter ( tmp , [ f_ok ] ) do
8430: LD_ADDR_VAR 0 1
8434: PUSH
8435: LD_VAR 0 2
8439: PPUSH
8440: LD_INT 50
8442: PUSH
8443: EMPTY
8444: LIST
8445: PPUSH
8446: CALL_OW 72
8450: PUSH
8451: FOR_IN
8452: IFFALSE 8490
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
8454: LD_VAR 0 1
8458: PPUSH
8459: LD_INT 81
8461: PUSH
8462: LD_INT 8
8464: PUSH
8465: EMPTY
8466: LIST
8467: LIST
8468: PPUSH
8469: CALL_OW 69
8473: PPUSH
8474: LD_VAR 0 1
8478: PPUSH
8479: CALL_OW 74
8483: PPUSH
8484: CALL_OW 115
8488: GO 8451
8490: POP
8491: POP
// until p >= 120 ;
8492: LD_VAR 0 5
8496: PUSH
8497: LD_INT 120
8499: GREATEREQUAL
8500: IFFALSE 8409
// repeat AddComAgressiveMove ( tmp , 210 , 178 ) ;
8502: LD_VAR 0 2
8506: PPUSH
8507: LD_INT 210
8509: PPUSH
8510: LD_INT 178
8512: PPUSH
8513: CALL_OW 174
// x := FilterUnitsInArea ( escape_area , [ f_side , 8 ] ) ;
8517: LD_ADDR_VAR 0 4
8521: PUSH
8522: LD_INT 10
8524: PPUSH
8525: LD_INT 22
8527: PUSH
8528: LD_INT 8
8530: PUSH
8531: EMPTY
8532: LIST
8533: LIST
8534: PPUSH
8535: CALL_OW 70
8539: ST_TO_ADDR
// if x then
8540: LD_VAR 0 4
8544: IFFALSE 8572
// for i in x do
8546: LD_ADDR_VAR 0 1
8550: PUSH
8551: LD_VAR 0 4
8555: PUSH
8556: FOR_IN
8557: IFFALSE 8570
// RemoveUnit ( i ) ;
8559: LD_VAR 0 1
8563: PPUSH
8564: CALL_OW 64
8568: GO 8556
8570: POP
8571: POP
// wait ( 0 0$1 ) ;
8572: LD_INT 35
8574: PPUSH
8575: CALL_OW 67
// until not FilterAllUnits ( [ f_side , 8 ] ) ;
8579: LD_INT 22
8581: PUSH
8582: LD_INT 8
8584: PUSH
8585: EMPTY
8586: LIST
8587: LIST
8588: PPUSH
8589: CALL_OW 69
8593: NOT
8594: IFFALSE 8502
// end ;
8596: PPOPN 5
8598: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
8599: LD_INT 22
8601: PUSH
8602: LD_INT 2
8604: PUSH
8605: EMPTY
8606: LIST
8607: LIST
8608: PUSH
8609: LD_INT 34
8611: PUSH
8612: LD_INT 31
8614: PUSH
8615: EMPTY
8616: LIST
8617: LIST
8618: PUSH
8619: LD_INT 3
8621: PUSH
8622: LD_INT 24
8624: PUSH
8625: LD_INT 1000
8627: PUSH
8628: EMPTY
8629: LIST
8630: LIST
8631: PUSH
8632: EMPTY
8633: LIST
8634: LIST
8635: PUSH
8636: EMPTY
8637: LIST
8638: LIST
8639: LIST
8640: PPUSH
8641: CALL_OW 69
8645: IFFALSE 8748
8647: GO 8649
8649: DISABLE
// begin if IsOk ( ar_dep_w ) and GetSide ( ar_dep_w ) then
8650: LD_INT 45
8652: PPUSH
8653: CALL_OW 302
8657: PUSH
8658: LD_INT 45
8660: PPUSH
8661: CALL_OW 255
8665: AND
8666: IFFALSE 8709
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 18 , 8 ) else
8668: LD_INT 22
8670: PUSH
8671: LD_INT 2
8673: PUSH
8674: EMPTY
8675: LIST
8676: LIST
8677: PUSH
8678: LD_INT 34
8680: PUSH
8681: LD_INT 31
8683: PUSH
8684: EMPTY
8685: LIST
8686: LIST
8687: PUSH
8688: EMPTY
8689: LIST
8690: LIST
8691: PPUSH
8692: CALL_OW 69
8696: PPUSH
8697: LD_INT 18
8699: PPUSH
8700: LD_INT 8
8702: PPUSH
8703: CALL_OW 111
8707: GO 8748
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 106 , 14 ) ;
8709: LD_INT 22
8711: PUSH
8712: LD_INT 2
8714: PUSH
8715: EMPTY
8716: LIST
8717: LIST
8718: PUSH
8719: LD_INT 34
8721: PUSH
8722: LD_INT 31
8724: PUSH
8725: EMPTY
8726: LIST
8727: LIST
8728: PUSH
8729: EMPTY
8730: LIST
8731: LIST
8732: PPUSH
8733: CALL_OW 69
8737: PPUSH
8738: LD_INT 106
8740: PPUSH
8741: LD_INT 14
8743: PPUSH
8744: CALL_OW 111
// end ; end_of_file
8748: END
// export function Action ; var tmp , p , radar , sols , i ; begin
8749: LD_INT 0
8751: PPUSH
8752: PPUSH
8753: PPUSH
8754: PPUSH
8755: PPUSH
8756: PPUSH
// InGameOn ;
8757: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
8761: LD_EXP 21
8765: PPUSH
8766: CALL_OW 87
// SetAttitude ( 2 , 1 , att_friend , true ) ;
8770: LD_INT 2
8772: PPUSH
8773: LD_INT 1
8775: PPUSH
8776: LD_INT 1
8778: PPUSH
8779: LD_INT 1
8781: PPUSH
8782: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) ;
8786: LD_ADDR_VAR 0 2
8790: PUSH
8791: LD_INT 22
8793: PUSH
8794: LD_INT 1
8796: PUSH
8797: EMPTY
8798: LIST
8799: LIST
8800: PUSH
8801: LD_INT 25
8803: PUSH
8804: LD_INT 1
8806: PUSH
8807: EMPTY
8808: LIST
8809: LIST
8810: PUSH
8811: EMPTY
8812: LIST
8813: LIST
8814: PPUSH
8815: CALL_OW 69
8819: ST_TO_ADDR
// radar := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_radar ] ] ) [ 1 ] ;
8820: LD_ADDR_VAR 0 4
8824: PUSH
8825: LD_INT 22
8827: PUSH
8828: LD_INT 1
8830: PUSH
8831: EMPTY
8832: LIST
8833: LIST
8834: PUSH
8835: LD_INT 34
8837: PUSH
8838: LD_INT 11
8840: PUSH
8841: EMPTY
8842: LIST
8843: LIST
8844: PUSH
8845: EMPTY
8846: LIST
8847: LIST
8848: PPUSH
8849: CALL_OW 69
8853: PUSH
8854: LD_INT 1
8856: ARRAY
8857: ST_TO_ADDR
// for i = 1 to tmp do
8858: LD_ADDR_VAR 0 6
8862: PUSH
8863: DOUBLE
8864: LD_INT 1
8866: DEC
8867: ST_TO_ADDR
8868: LD_VAR 0 2
8872: PUSH
8873: FOR_TO
8874: IFFALSE 8921
// begin if i = 5 then
8876: LD_VAR 0 6
8880: PUSH
8881: LD_INT 5
8883: EQUAL
8884: IFFALSE 8888
// break ;
8886: GO 8921
// sols := Replace ( sols , i , tmp [ i ] ) ;
8888: LD_ADDR_VAR 0 5
8892: PUSH
8893: LD_VAR 0 5
8897: PPUSH
8898: LD_VAR 0 6
8902: PPUSH
8903: LD_VAR 0 2
8907: PUSH
8908: LD_VAR 0 6
8912: ARRAY
8913: PPUSH
8914: CALL_OW 1
8918: ST_TO_ADDR
// end ;
8919: GO 8873
8921: POP
8922: POP
// tmp := ar_force_tmp ;
8923: LD_ADDR_VAR 0 2
8927: PUSH
8928: LD_EXP 40
8932: ST_TO_ADDR
// PlaceUnitXY ( tmp [ 1 ] , 108 , 139 , false ) ;
8933: LD_VAR 0 2
8937: PUSH
8938: LD_INT 1
8940: ARRAY
8941: PPUSH
8942: LD_INT 108
8944: PPUSH
8945: LD_INT 139
8947: PPUSH
8948: LD_INT 0
8950: PPUSH
8951: CALL_OW 48
// ComTurnUnit ( tmp [ 1 ] , JMM ) ;
8955: LD_VAR 0 2
8959: PUSH
8960: LD_INT 1
8962: ARRAY
8963: PPUSH
8964: LD_EXP 21
8968: PPUSH
8969: CALL_OW 119
// PlaceUnitXY ( tmp [ 2 ] , 114 , 132 , false ) ;
8973: LD_VAR 0 2
8977: PUSH
8978: LD_INT 2
8980: ARRAY
8981: PPUSH
8982: LD_INT 114
8984: PPUSH
8985: LD_INT 132
8987: PPUSH
8988: LD_INT 0
8990: PPUSH
8991: CALL_OW 48
// PlaceUnitXY ( tmp [ 3 ] , 115 , 132 , false ) ;
8995: LD_VAR 0 2
8999: PUSH
9000: LD_INT 3
9002: ARRAY
9003: PPUSH
9004: LD_INT 115
9006: PPUSH
9007: LD_INT 132
9009: PPUSH
9010: LD_INT 0
9012: PPUSH
9013: CALL_OW 48
// ComHold ( [ tmp [ 2 ] , tmp [ 3 ] ] ) ;
9017: LD_VAR 0 2
9021: PUSH
9022: LD_INT 2
9024: ARRAY
9025: PUSH
9026: LD_VAR 0 2
9030: PUSH
9031: LD_INT 3
9033: ARRAY
9034: PUSH
9035: EMPTY
9036: LIST
9037: LIST
9038: PPUSH
9039: CALL_OW 140
// ComMoveXY ( radar , 83 , 123 ) ;
9043: LD_VAR 0 4
9047: PPUSH
9048: LD_INT 83
9050: PPUSH
9051: LD_INT 123
9053: PPUSH
9054: CALL_OW 111
// Wait ( 0 0$01 ) ;
9058: LD_INT 35
9060: PPUSH
9061: CALL_OW 67
// CenterOnXY ( 90 , 144 ) ;
9065: LD_INT 90
9067: PPUSH
9068: LD_INT 144
9070: PPUSH
9071: CALL_OW 84
// ComMoveXY ( sols , 88 , 129 ) ;
9075: LD_VAR 0 5
9079: PPUSH
9080: LD_INT 88
9082: PPUSH
9083: LD_INT 129
9085: PPUSH
9086: CALL_OW 111
// p := [ [ 92 , 131 ] , [ 88 , 127 ] , [ 91 , 132 ] , [ 92 , 134 ] ] ;
9090: LD_ADDR_VAR 0 3
9094: PUSH
9095: LD_INT 92
9097: PUSH
9098: LD_INT 131
9100: PUSH
9101: EMPTY
9102: LIST
9103: LIST
9104: PUSH
9105: LD_INT 88
9107: PUSH
9108: LD_INT 127
9110: PUSH
9111: EMPTY
9112: LIST
9113: LIST
9114: PUSH
9115: LD_INT 91
9117: PUSH
9118: LD_INT 132
9120: PUSH
9121: EMPTY
9122: LIST
9123: LIST
9124: PUSH
9125: LD_INT 92
9127: PUSH
9128: LD_INT 134
9130: PUSH
9131: EMPTY
9132: LIST
9133: LIST
9134: PUSH
9135: EMPTY
9136: LIST
9137: LIST
9138: LIST
9139: LIST
9140: ST_TO_ADDR
// for i = 1 to sols do
9141: LD_ADDR_VAR 0 6
9145: PUSH
9146: DOUBLE
9147: LD_INT 1
9149: DEC
9150: ST_TO_ADDR
9151: LD_VAR 0 5
9155: PUSH
9156: FOR_TO
9157: IFFALSE 9230
// begin AddComMoveXY ( sols [ i ] , p [ i ] [ 1 ] , p [ i ] [ 2 ] ) ;
9159: LD_VAR 0 5
9163: PUSH
9164: LD_VAR 0 6
9168: ARRAY
9169: PPUSH
9170: LD_VAR 0 3
9174: PUSH
9175: LD_VAR 0 6
9179: ARRAY
9180: PUSH
9181: LD_INT 1
9183: ARRAY
9184: PPUSH
9185: LD_VAR 0 3
9189: PUSH
9190: LD_VAR 0 6
9194: ARRAY
9195: PUSH
9196: LD_INT 2
9198: ARRAY
9199: PPUSH
9200: CALL_OW 171
// AddComCrawl ( sols [ i ] ) ;
9204: LD_VAR 0 5
9208: PUSH
9209: LD_VAR 0 6
9213: ARRAY
9214: PPUSH
9215: CALL_OW 197
// AddComHold ( sols ) ;
9219: LD_VAR 0 5
9223: PPUSH
9224: CALL_OW 200
// end ;
9228: GO 9156
9230: POP
9231: POP
// repeat wait ( 0 0$1 ) ;
9232: LD_INT 35
9234: PPUSH
9235: CALL_OW 67
// until GetDistUnitXY ( sols [ 1 ] , 92 , 131 ) < 4 ;
9239: LD_VAR 0 5
9243: PUSH
9244: LD_INT 1
9246: ARRAY
9247: PPUSH
9248: LD_INT 92
9250: PPUSH
9251: LD_INT 131
9253: PPUSH
9254: CALL_OW 297
9258: PUSH
9259: LD_INT 4
9261: LESS
9262: IFFALSE 9232
// CenterOnXY ( 96 , 139 ) ;
9264: LD_INT 96
9266: PPUSH
9267: LD_INT 139
9269: PPUSH
9270: CALL_OW 84
// wait ( 0 0$3 ) ;
9274: LD_INT 105
9276: PPUSH
9277: CALL_OW 67
// PlaceSeeing ( 111 , 135 , 1 , - 25 ) ;
9281: LD_INT 111
9283: PPUSH
9284: LD_INT 135
9286: PPUSH
9287: LD_INT 1
9289: PPUSH
9290: LD_INT 25
9292: NEG
9293: PPUSH
9294: CALL_OW 330
// ComMoveXY ( tmp [ 2 ] , GetX ( tmp [ 1 ] ) + 3 , GetY ( tmp [ 1 ] ) ) ;
9298: LD_VAR 0 2
9302: PUSH
9303: LD_INT 2
9305: ARRAY
9306: PPUSH
9307: LD_VAR 0 2
9311: PUSH
9312: LD_INT 1
9314: ARRAY
9315: PPUSH
9316: CALL_OW 250
9320: PUSH
9321: LD_INT 3
9323: PLUS
9324: PPUSH
9325: LD_VAR 0 2
9329: PUSH
9330: LD_INT 1
9332: ARRAY
9333: PPUSH
9334: CALL_OW 251
9338: PPUSH
9339: CALL_OW 111
// ComEnterUnit ( tmp [ 3 ] , ar_dep_s ) ;
9343: LD_VAR 0 2
9347: PUSH
9348: LD_INT 3
9350: ARRAY
9351: PPUSH
9352: LD_INT 7
9354: PPUSH
9355: CALL_OW 120
// AddComTurnUnit ( tmp [ 2 ] , tmp [ 1 ] ) ;
9359: LD_VAR 0 2
9363: PUSH
9364: LD_INT 2
9366: ARRAY
9367: PPUSH
9368: LD_VAR 0 2
9372: PUSH
9373: LD_INT 1
9375: ARRAY
9376: PPUSH
9377: CALL_OW 179
// repeat wait ( 0 0$1 ) ;
9381: LD_INT 35
9383: PPUSH
9384: CALL_OW 67
// until GetDistUnits ( tmp [ 1 ] , tmp [ 2 ] ) < 5 ;
9388: LD_VAR 0 2
9392: PUSH
9393: LD_INT 1
9395: ARRAY
9396: PPUSH
9397: LD_VAR 0 2
9401: PUSH
9402: LD_INT 2
9404: ARRAY
9405: PPUSH
9406: CALL_OW 296
9410: PUSH
9411: LD_INT 5
9413: LESS
9414: IFFALSE 9381
// ComTurnUnit ( tmp [ 1 ] , tmp [ 2 ] ) ;
9416: LD_VAR 0 2
9420: PUSH
9421: LD_INT 1
9423: ARRAY
9424: PPUSH
9425: LD_VAR 0 2
9429: PUSH
9430: LD_INT 2
9432: ARRAY
9433: PPUSH
9434: CALL_OW 119
// Say ( tmp [ 1 ] , D1a-Merc1-1 ) ;
9438: LD_VAR 0 2
9442: PUSH
9443: LD_INT 1
9445: ARRAY
9446: PPUSH
9447: LD_STRING D1a-Merc1-1
9449: PPUSH
9450: CALL_OW 88
// Say ( tmp [ 2 ] , D1a-FMerc2-1 ) ;
9454: LD_VAR 0 2
9458: PUSH
9459: LD_INT 2
9461: ARRAY
9462: PPUSH
9463: LD_STRING D1a-FMerc2-1
9465: PPUSH
9466: CALL_OW 88
// ComHeal ( tmp [ 2 ] , tmp [ 1 ] ) ;
9470: LD_VAR 0 2
9474: PUSH
9475: LD_INT 2
9477: ARRAY
9478: PPUSH
9479: LD_VAR 0 2
9483: PUSH
9484: LD_INT 1
9486: ARRAY
9487: PPUSH
9488: CALL_OW 128
// SetLives ( tmp [ 1 ] , 500 ) ;
9492: LD_VAR 0 2
9496: PUSH
9497: LD_INT 1
9499: ARRAY
9500: PPUSH
9501: LD_INT 500
9503: PPUSH
9504: CALL_OW 234
// wait ( 0 0$2 ) ;
9508: LD_INT 70
9510: PPUSH
9511: CALL_OW 67
// SetLives ( tmp [ 1 ] , 2 ) ;
9515: LD_VAR 0 2
9519: PUSH
9520: LD_INT 1
9522: ARRAY
9523: PPUSH
9524: LD_INT 2
9526: PPUSH
9527: CALL_OW 234
// wait ( 0 0$0.3 ) ;
9531: LD_INT 10
9533: PPUSH
9534: CALL_OW 67
// ForceSay ( tmp [ 1 ] , D1a-Merc1-2 ) ;
9538: LD_VAR 0 2
9542: PUSH
9543: LD_INT 1
9545: ARRAY
9546: PPUSH
9547: LD_STRING D1a-Merc1-2
9549: PPUSH
9550: CALL_OW 91
// wait ( 0 0$0.2 ) ;
9554: LD_INT 7
9556: PPUSH
9557: CALL_OW 67
// KillUnit ( tmp [ 1 ] ) ;
9561: LD_VAR 0 2
9565: PUSH
9566: LD_INT 1
9568: ARRAY
9569: PPUSH
9570: CALL_OW 66
// ComMoveToArea ( tmp [ 2 ] , escape_area ) ;
9574: LD_VAR 0 2
9578: PUSH
9579: LD_INT 2
9581: ARRAY
9582: PPUSH
9583: LD_INT 10
9585: PPUSH
9586: CALL_OW 113
// Say ( tmp [ 2 ] , D1a-FMerc2-2 ) ;
9590: LD_VAR 0 2
9594: PUSH
9595: LD_INT 2
9597: ARRAY
9598: PPUSH
9599: LD_STRING D1a-FMerc2-2
9601: PPUSH
9602: CALL_OW 88
// wait ( 0 0$1 ) ;
9606: LD_INT 35
9608: PPUSH
9609: CALL_OW 67
// CenterOnUnits ( ar_dep_s ) ;
9613: LD_INT 7
9615: PPUSH
9616: CALL_OW 85
// wait ( 0 0$2 ) ;
9620: LD_INT 70
9622: PPUSH
9623: CALL_OW 67
// ForceSay ( Saliba , D1a-Saliba-1 ) ;
9627: LD_EXP 44
9631: PPUSH
9632: LD_STRING D1a-Saliba-1
9634: PPUSH
9635: CALL_OW 91
// KillUnit ( Saliba ) ;
9639: LD_EXP 44
9643: PPUSH
9644: CALL_OW 66
// ComExitBuilding ( tmp [ 3 ] ) ;
9648: LD_VAR 0 2
9652: PUSH
9653: LD_INT 3
9655: ARRAY
9656: PPUSH
9657: CALL_OW 122
// CenterOnUnits ( JMM ) ;
9661: LD_EXP 21
9665: PPUSH
9666: CALL_OW 85
// wait ( 0 0$1 ) ;
9670: LD_INT 35
9672: PPUSH
9673: CALL_OW 67
// ComMoveXY ( sols , 88 , 141 ) ;
9677: LD_VAR 0 5
9681: PPUSH
9682: LD_INT 88
9684: PPUSH
9685: LD_INT 141
9687: PPUSH
9688: CALL_OW 111
// AddComWait ( sols , 0 0$2 ) ;
9692: LD_VAR 0 5
9696: PPUSH
9697: LD_INT 70
9699: PPUSH
9700: CALL_OW 202
// wait ( 0 0$2 ) ;
9704: LD_INT 70
9706: PPUSH
9707: CALL_OW 67
// SetAttitude ( 2 , 1 , att_enemy , true ) ;
9711: LD_INT 2
9713: PPUSH
9714: LD_INT 1
9716: PPUSH
9717: LD_INT 2
9719: PPUSH
9720: LD_INT 1
9722: PPUSH
9723: CALL_OW 80
// InGameOff ;
9727: CALL_OW 9
// ComWalk ( sols ) ;
9731: LD_VAR 0 5
9735: PPUSH
9736: CALL_OW 138
// ChangeMissionObjectives ( M1 ) ;
9740: LD_STRING M1
9742: PPUSH
9743: CALL_OW 337
// game_speed := 4 ;
9747: LD_ADDR_OWVAR 65
9751: PUSH
9752: LD_INT 4
9754: ST_TO_ADDR
// RemoveSeeing ( 111 , 135 , 1 ) ;
9755: LD_INT 111
9757: PPUSH
9758: LD_INT 135
9760: PPUSH
9761: LD_INT 1
9763: PPUSH
9764: CALL_OW 331
// SaveForQuickRestart ;
9768: CALL_OW 22
// ar_run := true ;
9772: LD_ADDR_EXP 5
9776: PUSH
9777: LD_INT 1
9779: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9780: LD_INT 35
9782: PPUSH
9783: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 1 ] , [ f_dist , ar_dep_s , 10 ] ] ) or GetLives ( ar_dep_s ) < 999 ;
9787: LD_INT 22
9789: PUSH
9790: LD_INT 1
9792: PUSH
9793: EMPTY
9794: LIST
9795: LIST
9796: PUSH
9797: LD_INT 91
9799: PUSH
9800: LD_INT 7
9802: PUSH
9803: LD_INT 10
9805: PUSH
9806: EMPTY
9807: LIST
9808: LIST
9809: LIST
9810: PUSH
9811: EMPTY
9812: LIST
9813: LIST
9814: PPUSH
9815: CALL_OW 69
9819: PUSH
9820: LD_INT 7
9822: PPUSH
9823: CALL_OW 256
9827: PUSH
9828: LD_INT 999
9830: LESS
9831: OR
9832: IFFALSE 9780
// if GetSide ( ar_dep_s ) = 2 then
9834: LD_INT 7
9836: PPUSH
9837: CALL_OW 255
9841: PUSH
9842: LD_INT 2
9844: EQUAL
9845: IFFALSE 9857
// SetSide ( ar_dep_s , 1 ) ;
9847: LD_INT 7
9849: PPUSH
9850: LD_INT 1
9852: PPUSH
9853: CALL_OW 235
// end ;
9857: LD_VAR 0 1
9861: RET
// every 0 0$2 trigger ar_run do var i , tmp , k ;
9862: LD_EXP 5
9866: IFFALSE 10226
9868: GO 9870
9870: DISABLE
9871: LD_INT 0
9873: PPUSH
9874: PPUSH
9875: PPUSH
// begin tmp := ar_force_tmp ^ UnitFilter ( ar_force_south , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ) ;
9876: LD_ADDR_VAR 0 2
9880: PUSH
9881: LD_EXP 40
9885: PUSH
9886: LD_EXP 36
9890: PPUSH
9891: LD_INT 2
9893: PUSH
9894: LD_INT 21
9896: PUSH
9897: LD_INT 2
9899: PUSH
9900: EMPTY
9901: LIST
9902: LIST
9903: PUSH
9904: LD_INT 21
9906: PUSH
9907: LD_INT 1
9909: PUSH
9910: EMPTY
9911: LIST
9912: LIST
9913: PUSH
9914: EMPTY
9915: LIST
9916: LIST
9917: LIST
9918: PPUSH
9919: CALL_OW 72
9923: ADD
9924: ST_TO_ADDR
// SetSide ( tmp , 5 ) ;
9925: LD_VAR 0 2
9929: PPUSH
9930: LD_INT 5
9932: PPUSH
9933: CALL_OW 235
// ChangeSideFog ( 5 , 1 ) ;
9937: LD_INT 5
9939: PPUSH
9940: LD_INT 1
9942: PPUSH
9943: CALL_OW 343
// k := 1 ;
9947: LD_ADDR_VAR 0 3
9951: PUSH
9952: LD_INT 1
9954: ST_TO_ADDR
// for i in tmp do
9955: LD_ADDR_VAR 0 1
9959: PUSH
9960: LD_VAR 0 2
9964: PUSH
9965: FOR_IN
9966: IFFALSE 10051
// begin if IsInUnit ( i ) then
9968: LD_VAR 0 1
9972: PPUSH
9973: CALL_OW 310
9977: IFFALSE 9988
// ComExitBuilding ( i ) ;
9979: LD_VAR 0 1
9983: PPUSH
9984: CALL_OW 122
// if GetClass ( i ) = 3 then
9988: LD_VAR 0 1
9992: PPUSH
9993: CALL_OW 257
9997: PUSH
9998: LD_INT 3
10000: EQUAL
10001: IFFALSE 10037
// begin AddComEnterUnit ( i , ar_vehicles_tmp [ k ] ) ;
10003: LD_VAR 0 1
10007: PPUSH
10008: LD_EXP 41
10012: PUSH
10013: LD_VAR 0 3
10017: ARRAY
10018: PPUSH
10019: CALL_OW 180
// k := k + 1 ;
10023: LD_ADDR_VAR 0 3
10027: PUSH
10028: LD_VAR 0 3
10032: PUSH
10033: LD_INT 1
10035: PLUS
10036: ST_TO_ADDR
// end ; AddComMoveToArea ( i , escape_area ) ;
10037: LD_VAR 0 1
10041: PPUSH
10042: LD_INT 10
10044: PPUSH
10045: CALL_OW 173
// end ;
10049: GO 9965
10051: POP
10052: POP
// ar_patrol := true ;
10053: LD_ADDR_EXP 7
10057: PUSH
10058: LD_INT 1
10060: ST_TO_ADDR
// repeat wait ( 0 0$0.3 ) ;
10061: LD_INT 10
10063: PPUSH
10064: CALL_OW 67
// for i in tmp do
10068: LD_ADDR_VAR 0 1
10072: PUSH
10073: LD_VAR 0 2
10077: PUSH
10078: FOR_IN
10079: IFFALSE 10107
// if not HasTask ( i ) then
10081: LD_VAR 0 1
10085: PPUSH
10086: CALL_OW 314
10090: NOT
10091: IFFALSE 10105
// ComMoveToArea ( i , escape_area ) ;
10093: LD_VAR 0 1
10097: PPUSH
10098: LD_INT 10
10100: PPUSH
10101: CALL_OW 113
10105: GO 10078
10107: POP
10108: POP
// k := UnitFilter ( tmp , [ f_inarea , escape_area ] ) ;
10109: LD_ADDR_VAR 0 3
10113: PUSH
10114: LD_VAR 0 2
10118: PPUSH
10119: LD_INT 95
10121: PUSH
10122: LD_INT 10
10124: PUSH
10125: EMPTY
10126: LIST
10127: LIST
10128: PPUSH
10129: CALL_OW 72
10133: ST_TO_ADDR
// if k then
10134: LD_VAR 0 3
10138: IFFALSE 10207
// for i in k do
10140: LD_ADDR_VAR 0 1
10144: PUSH
10145: LD_VAR 0 3
10149: PUSH
10150: FOR_IN
10151: IFFALSE 10205
// begin if IsInUnit ( i ) then
10153: LD_VAR 0 1
10157: PPUSH
10158: CALL_OW 310
10162: IFFALSE 10178
// RemoveUnit ( IsInUnit ( i ) ) ;
10164: LD_VAR 0 1
10168: PPUSH
10169: CALL_OW 310
10173: PPUSH
10174: CALL_OW 64
// RemoveUnit ( i ) ;
10178: LD_VAR 0 1
10182: PPUSH
10183: CALL_OW 64
// tmp := tmp diff i ;
10187: LD_ADDR_VAR 0 2
10191: PUSH
10192: LD_VAR 0 2
10196: PUSH
10197: LD_VAR 0 1
10201: DIFF
10202: ST_TO_ADDR
// end ;
10203: GO 10150
10205: POP
10206: POP
// until tmp = [ ] ;
10207: LD_VAR 0 2
10211: PUSH
10212: EMPTY
10213: EQUAL
10214: IFFALSE 10061
// ChangeSideFog ( 5 , 5 ) ;
10216: LD_INT 5
10218: PPUSH
10219: LD_INT 5
10221: PPUSH
10222: CALL_OW 343
// end ;
10226: PPOPN 3
10228: END
// every 0 0$03 trigger ar_patrol do var i , un , veh ;
10229: LD_EXP 7
10233: IFFALSE 10523
10235: GO 10237
10237: DISABLE
10238: LD_INT 0
10240: PPUSH
10241: PPUSH
10242: PPUSH
// begin uc_side := 2 ;
10243: LD_ADDR_OWVAR 20
10247: PUSH
10248: LD_INT 2
10250: ST_TO_ADDR
// uc_nation := 2 ;
10251: LD_ADDR_OWVAR 21
10255: PUSH
10256: LD_INT 2
10258: ST_TO_ADDR
// InitHc ;
10259: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
10263: LD_INT 1
10265: PPUSH
10266: LD_INT 1
10268: PPUSH
10269: LD_INT 6
10271: PPUSH
10272: CALL_OW 380
// un := CreateHuman ;
10276: LD_ADDR_VAR 0 2
10280: PUSH
10281: CALL_OW 44
10285: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_combustion , control_manual , ar_gun , 98 ) ;
10286: LD_INT 14
10288: PPUSH
10289: LD_INT 1
10291: PPUSH
10292: LD_INT 1
10294: PPUSH
10295: LD_INT 27
10297: PPUSH
10298: LD_INT 98
10300: PPUSH
10301: CALL 53912 0 5
// veh := CreateVehicle ;
10305: LD_ADDR_VAR 0 3
10309: PUSH
10310: CALL_OW 45
10314: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
10315: LD_VAR 0 3
10319: PPUSH
10320: LD_INT 4
10322: PPUSH
10323: CALL_OW 233
// PlaceUnitXY ( veh , 179 , 135 , false ) ;
10327: LD_VAR 0 3
10331: PPUSH
10332: LD_INT 179
10334: PPUSH
10335: LD_INT 135
10337: PPUSH
10338: LD_INT 0
10340: PPUSH
10341: CALL_OW 48
// PlaceHumanInUnit ( un , veh ) ;
10345: LD_VAR 0 2
10349: PPUSH
10350: LD_VAR 0 3
10354: PPUSH
10355: CALL_OW 52
// ComMoveXY ( un , 126 , 133 ) ;
10359: LD_VAR 0 2
10363: PPUSH
10364: LD_INT 126
10366: PPUSH
10367: LD_INT 133
10369: PPUSH
10370: CALL_OW 111
// repeat wait ( 0 0$0.3 ) ;
10374: LD_INT 10
10376: PPUSH
10377: CALL_OW 67
// until See ( 1 , veh ) or GetDistUnits ( veh , ar_dep_s ) < 9 ;
10381: LD_INT 1
10383: PPUSH
10384: LD_VAR 0 3
10388: PPUSH
10389: CALL_OW 292
10393: PUSH
10394: LD_VAR 0 3
10398: PPUSH
10399: LD_INT 7
10401: PPUSH
10402: CALL_OW 296
10406: PUSH
10407: LD_INT 9
10409: LESS
10410: OR
10411: IFFALSE 10374
// ComHold ( veh ) ;
10413: LD_VAR 0 3
10417: PPUSH
10418: CALL_OW 140
// Say ( un , D2aa-Ar1-1 ) ;
10422: LD_VAR 0 2
10426: PPUSH
10427: LD_STRING D2aa-Ar1-1
10429: PPUSH
10430: CALL_OW 88
// ComMoveXY ( un , 177 , 96 ) ;
10434: LD_VAR 0 2
10438: PPUSH
10439: LD_INT 177
10441: PPUSH
10442: LD_INT 96
10444: PPUSH
10445: CALL_OW 111
// AddComExitVehicle ( un ) ;
10449: LD_VAR 0 2
10453: PPUSH
10454: CALL_OW 181
// repeat wait ( 0 0$1 ) ;
10458: LD_INT 35
10460: PPUSH
10461: CALL_OW 67
// until GetDistUnits ( un , ar_dep_e ) < 15 ;
10465: LD_VAR 0 2
10469: PPUSH
10470: LD_INT 204
10472: PPUSH
10473: CALL_OW 296
10477: PUSH
10478: LD_INT 15
10480: LESS
10481: IFFALSE 10458
// mc_bases := ReplaceIn ( mc_bases , [ 3 , mc_bases [ 3 ] + 1 ] , un ) ;
10483: LD_ADDR_EXP 50
10487: PUSH
10488: LD_EXP 50
10492: PPUSH
10493: LD_INT 3
10495: PUSH
10496: LD_EXP 50
10500: PUSH
10501: LD_INT 3
10503: ARRAY
10504: PUSH
10505: LD_INT 1
10507: PLUS
10508: PUSH
10509: EMPTY
10510: LIST
10511: LIST
10512: PPUSH
10513: LD_VAR 0 2
10517: PPUSH
10518: CALL 54034 0 3
10522: ST_TO_ADDR
// end ;
10523: PPOPN 3
10525: END
// every 0 0$2 trigger GetSide ( ar_dep_s ) = 1 or IsDead ( ar_dep_s ) do var i , points ;
10526: LD_INT 7
10528: PPUSH
10529: CALL_OW 255
10533: PUSH
10534: LD_INT 1
10536: EQUAL
10537: PUSH
10538: LD_INT 7
10540: PPUSH
10541: CALL_OW 301
10545: OR
10546: IFFALSE 12951
10548: GO 10550
10550: DISABLE
10551: LD_INT 0
10553: PPUSH
10554: PPUSH
// begin for i in UnitFilter ( ar_force_south , [ f_type , unit_building ] ) do
10555: LD_ADDR_VAR 0 1
10559: PUSH
10560: LD_EXP 36
10564: PPUSH
10565: LD_INT 21
10567: PUSH
10568: LD_INT 3
10570: PUSH
10571: EMPTY
10572: LIST
10573: LIST
10574: PPUSH
10575: CALL_OW 72
10579: PUSH
10580: FOR_IN
10581: IFFALSE 10597
// SetSide ( i , 1 ) ;
10583: LD_VAR 0 1
10587: PPUSH
10588: LD_INT 1
10590: PPUSH
10591: CALL_OW 235
10595: GO 10580
10597: POP
10598: POP
// points := [ [ 46 , 41 ] , [ 50 , 25 ] , [ 57 , 75 ] , [ 75 , 89 ] , [ 51 , 45 ] , [ 95 , 95 ] , [ 84 , 77 ] , [ 101 , 76 ] , [ 118 , 81 ] , [ 139 , 97 ] , [ 129 , 114 ] , [ 154 , 111 ] ] ;
10599: LD_ADDR_VAR 0 2
10603: PUSH
10604: LD_INT 46
10606: PUSH
10607: LD_INT 41
10609: PUSH
10610: EMPTY
10611: LIST
10612: LIST
10613: PUSH
10614: LD_INT 50
10616: PUSH
10617: LD_INT 25
10619: PUSH
10620: EMPTY
10621: LIST
10622: LIST
10623: PUSH
10624: LD_INT 57
10626: PUSH
10627: LD_INT 75
10629: PUSH
10630: EMPTY
10631: LIST
10632: LIST
10633: PUSH
10634: LD_INT 75
10636: PUSH
10637: LD_INT 89
10639: PUSH
10640: EMPTY
10641: LIST
10642: LIST
10643: PUSH
10644: LD_INT 51
10646: PUSH
10647: LD_INT 45
10649: PUSH
10650: EMPTY
10651: LIST
10652: LIST
10653: PUSH
10654: LD_INT 95
10656: PUSH
10657: LD_INT 95
10659: PUSH
10660: EMPTY
10661: LIST
10662: LIST
10663: PUSH
10664: LD_INT 84
10666: PUSH
10667: LD_INT 77
10669: PUSH
10670: EMPTY
10671: LIST
10672: LIST
10673: PUSH
10674: LD_INT 101
10676: PUSH
10677: LD_INT 76
10679: PUSH
10680: EMPTY
10681: LIST
10682: LIST
10683: PUSH
10684: LD_INT 118
10686: PUSH
10687: LD_INT 81
10689: PUSH
10690: EMPTY
10691: LIST
10692: LIST
10693: PUSH
10694: LD_INT 139
10696: PUSH
10697: LD_INT 97
10699: PUSH
10700: EMPTY
10701: LIST
10702: LIST
10703: PUSH
10704: LD_INT 129
10706: PUSH
10707: LD_INT 114
10709: PUSH
10710: EMPTY
10711: LIST
10712: LIST
10713: PUSH
10714: LD_INT 154
10716: PUSH
10717: LD_INT 111
10719: PUSH
10720: EMPTY
10721: LIST
10722: LIST
10723: PUSH
10724: EMPTY
10725: LIST
10726: LIST
10727: LIST
10728: LIST
10729: LIST
10730: LIST
10731: LIST
10732: LIST
10733: LIST
10734: LIST
10735: LIST
10736: LIST
10737: ST_TO_ADDR
// base_captured := true ;
10738: LD_ADDR_EXP 6
10742: PUSH
10743: LD_INT 1
10745: ST_TO_ADDR
// DialogueOn ;
10746: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
10750: LD_EXP 21
10754: PPUSH
10755: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
10759: LD_EXP 21
10763: PPUSH
10764: LD_STRING D2-JMM-1
10766: PPUSH
10767: CALL_OW 88
// SayRadio ( Powell , D2-Pow-1 ) ;
10771: LD_EXP 30
10775: PPUSH
10776: LD_STRING D2-Pow-1
10778: PPUSH
10779: CALL_OW 94
// Say ( JMM , D2-JMM-2 ) ;
10783: LD_EXP 21
10787: PPUSH
10788: LD_STRING D2-JMM-2
10790: PPUSH
10791: CALL_OW 88
// SayRadio ( Powell , D2-Pow-2 ) ;
10795: LD_EXP 30
10799: PPUSH
10800: LD_STRING D2-Pow-2
10802: PPUSH
10803: CALL_OW 94
// Say ( JMM , D2-JMM-3 ) ;
10807: LD_EXP 21
10811: PPUSH
10812: LD_STRING D2-JMM-3
10814: PPUSH
10815: CALL_OW 88
// DialogueOff ;
10819: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
10823: LD_STRING M2
10825: PPUSH
10826: CALL_OW 337
// Wait ( 0 0$2 ) ;
10830: LD_INT 70
10832: PPUSH
10833: CALL_OW 67
// if IsOk ( Gary ) then
10837: LD_EXP 32
10841: PPUSH
10842: CALL_OW 302
10846: IFFALSE 10860
// Say ( Gary , D2a-Gary-1 ) ;
10848: LD_EXP 32
10852: PPUSH
10853: LD_STRING D2a-Gary-1
10855: PPUSH
10856: CALL_OW 88
// if IsOk ( Bobby ) then
10860: LD_EXP 24
10864: PPUSH
10865: CALL_OW 302
10869: IFFALSE 10883
// Say ( Bobby , D2a-Bobby-1 ) ;
10871: LD_EXP 24
10875: PPUSH
10876: LD_STRING D2a-Bobby-1
10878: PPUSH
10879: CALL_OW 88
// if IsOk ( Cyrus ) then
10883: LD_EXP 25
10887: PPUSH
10888: CALL_OW 302
10892: IFFALSE 10906
// Say ( Cyrus , D2a-Cyrus-1 ) ;
10894: LD_EXP 25
10898: PPUSH
10899: LD_STRING D2a-Cyrus-1
10901: PPUSH
10902: CALL_OW 88
// if IsOk ( Lisa ) then
10906: LD_EXP 22
10910: PPUSH
10911: CALL_OW 302
10915: IFFALSE 10929
// Say ( Lisa , D2a-Lisa-1 ) ;
10917: LD_EXP 22
10921: PPUSH
10922: LD_STRING D2a-Lisa-1
10924: PPUSH
10925: CALL_OW 88
// if IsOk ( Frank ) then
10929: LD_EXP 33
10933: PPUSH
10934: CALL_OW 302
10938: IFFALSE 10952
// Say ( Frank , D2a-Frank-1 ) ;
10940: LD_EXP 33
10944: PPUSH
10945: LD_STRING D2a-Frank-1
10947: PPUSH
10948: CALL_OW 88
// if IsOk ( Cornel ) then
10952: LD_EXP 31
10956: PPUSH
10957: CALL_OW 302
10961: IFFALSE 10975
// Say ( Cornel , D2a-Corn-1 ) ;
10963: LD_EXP 31
10967: PPUSH
10968: LD_STRING D2a-Corn-1
10970: PPUSH
10971: CALL_OW 88
// if IsOk ( Donaldson ) then
10975: LD_EXP 23
10979: PPUSH
10980: CALL_OW 302
10984: IFFALSE 10998
// Say ( Donaldson , D2a-Don-1 ) ;
10986: LD_EXP 23
10990: PPUSH
10991: LD_STRING D2a-Don-1
10993: PPUSH
10994: CALL_OW 88
// if IsOk ( Brown ) then
10998: LD_EXP 27
11002: PPUSH
11003: CALL_OW 302
11007: IFFALSE 11021
// Say ( Brown , D2a-Brown-1 ) ;
11009: LD_EXP 27
11013: PPUSH
11014: LD_STRING D2a-Brown-1
11016: PPUSH
11017: CALL_OW 88
// Wait ( 0 0$30 ) ;
11021: LD_INT 1050
11023: PPUSH
11024: CALL_OW 67
// if IsOk ( Frank ) then
11028: LD_EXP 33
11032: PPUSH
11033: CALL_OW 302
11037: IFFALSE 12017
// begin DialogueOn ;
11039: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Frank ] ) ;
11043: LD_EXP 21
11047: PUSH
11048: LD_EXP 33
11052: PUSH
11053: EMPTY
11054: LIST
11055: LIST
11056: PPUSH
11057: CALL_OW 87
// Say ( Frank , D3F-Frank-1 ) ;
11061: LD_EXP 33
11065: PPUSH
11066: LD_STRING D3F-Frank-1
11068: PPUSH
11069: CALL_OW 88
// Say ( JMM , D3F-JMM-1 ) ;
11073: LD_EXP 21
11077: PPUSH
11078: LD_STRING D3F-JMM-1
11080: PPUSH
11081: CALL_OW 88
// Say ( Frank , D3F-Frank-2 ) ;
11085: LD_EXP 33
11089: PPUSH
11090: LD_STRING D3F-Frank-2
11092: PPUSH
11093: CALL_OW 88
// case Query ( QFrank ) of 1 :
11097: LD_STRING QFrank
11099: PPUSH
11100: CALL_OW 97
11104: PUSH
11105: LD_INT 1
11107: DOUBLE
11108: EQUAL
11109: IFTRUE 11113
11111: GO 11136
11113: POP
// begin Say ( JMM , D3Fa-JMM-1 ) ;
11114: LD_EXP 21
11118: PPUSH
11119: LD_STRING D3Fa-JMM-1
11121: PPUSH
11122: CALL_OW 88
// us_scout := 1 ;
11126: LD_ADDR_EXP 8
11130: PUSH
11131: LD_INT 1
11133: ST_TO_ADDR
// end ; 2 :
11134: GO 11299
11136: LD_INT 2
11138: DOUBLE
11139: EQUAL
11140: IFTRUE 11144
11142: GO 11266
11144: POP
// begin Say ( JMM , D3Fb-JMM-1 ) ;
11145: LD_EXP 21
11149: PPUSH
11150: LD_STRING D3Fb-JMM-1
11152: PPUSH
11153: CALL_OW 88
// Say ( Frank , D3Fb-Frank-1 ) ;
11157: LD_EXP 33
11161: PPUSH
11162: LD_STRING D3Fb-Frank-1
11164: PPUSH
11165: CALL_OW 88
// case Query ( QFrank2 ) of 1 :
11169: LD_STRING QFrank2
11171: PPUSH
11172: CALL_OW 97
11176: PUSH
11177: LD_INT 1
11179: DOUBLE
11180: EQUAL
11181: IFTRUE 11185
11183: GO 11232
11185: POP
// begin us_scout := 2 ;
11186: LD_ADDR_EXP 8
11190: PUSH
11191: LD_INT 2
11193: ST_TO_ADDR
// Say ( JMM , D3Fba-JMM-1 ) ;
11194: LD_EXP 21
11198: PPUSH
11199: LD_STRING D3Fba-JMM-1
11201: PPUSH
11202: CALL_OW 88
// Say ( Frank , D3Fba-Frank-1 ) ;
11206: LD_EXP 33
11210: PPUSH
11211: LD_STRING D3Fba-Frank-1
11213: PPUSH
11214: CALL_OW 88
// Say ( JMM , D3Fba-JMM-2 ) ;
11218: LD_EXP 21
11222: PPUSH
11223: LD_STRING D3Fba-JMM-2
11225: PPUSH
11226: CALL_OW 88
// end ; 2 :
11230: GO 11264
11232: LD_INT 2
11234: DOUBLE
11235: EQUAL
11236: IFTRUE 11240
11238: GO 11263
11240: POP
// begin us_scout := 0 ;
11241: LD_ADDR_EXP 8
11245: PUSH
11246: LD_INT 0
11248: ST_TO_ADDR
// Say ( JMM , D3Fbb-JMM-1 ) ;
11249: LD_EXP 21
11253: PPUSH
11254: LD_STRING D3Fbb-JMM-1
11256: PPUSH
11257: CALL_OW 88
// end ; end ;
11261: GO 11264
11263: POP
// end ; 3 :
11264: GO 11299
11266: LD_INT 3
11268: DOUBLE
11269: EQUAL
11270: IFTRUE 11274
11272: GO 11298
11274: POP
// begin us_scout := - 1 ;
11275: LD_ADDR_EXP 8
11279: PUSH
11280: LD_INT 1
11282: NEG
11283: ST_TO_ADDR
// Say ( JMM , D3Fc-JMM-1 ) ;
11284: LD_EXP 21
11288: PPUSH
11289: LD_STRING D3Fc-JMM-1
11291: PPUSH
11292: CALL_OW 88
// end ; end ;
11296: GO 11299
11298: POP
// DialogueOff ;
11299: CALL_OW 7
// if us_scout in [ - 1 , 0 ] then
11303: LD_EXP 8
11307: PUSH
11308: LD_INT 1
11310: NEG
11311: PUSH
11312: LD_INT 0
11314: PUSH
11315: EMPTY
11316: LIST
11317: LIST
11318: IN
11319: IFFALSE 11323
// exit ;
11321: GO 12951
// if us_scout in [ 1 , 2 ] then
11323: LD_EXP 8
11327: PUSH
11328: LD_INT 1
11330: PUSH
11331: LD_INT 2
11333: PUSH
11334: EMPTY
11335: LIST
11336: LIST
11337: IN
11338: IFFALSE 12017
// begin if IsInUnit ( Frank ) then
11340: LD_EXP 33
11344: PPUSH
11345: CALL_OW 310
11349: IFFALSE 11360
// ComExit ( Frank ) ;
11351: LD_EXP 33
11355: PPUSH
11356: CALL 86762 0 1
// SetSide ( Frank , 4 ) ;
11360: LD_EXP 33
11364: PPUSH
11365: LD_INT 4
11367: PPUSH
11368: CALL_OW 235
// wait ( 0 0$1 ) ;
11372: LD_INT 35
11374: PPUSH
11375: CALL_OW 67
// if us_scout = 2 then
11379: LD_EXP 8
11383: PUSH
11384: LD_INT 2
11386: EQUAL
11387: IFFALSE 11755
// begin ComMoveXY ( Frank , 75 , 63 ) ;
11389: LD_EXP 33
11393: PPUSH
11394: LD_INT 75
11396: PPUSH
11397: LD_INT 63
11399: PPUSH
11400: CALL_OW 111
// AddComHold ( Frank ) ;
11404: LD_EXP 33
11408: PPUSH
11409: CALL_OW 200
// AddComWait ( Frank , 0 0$22 ) ;
11413: LD_EXP 33
11417: PPUSH
11418: LD_INT 770
11420: PPUSH
11421: CALL_OW 202
// AddComMoveXY ( Frank , 100 , 75 ) ;
11425: LD_EXP 33
11429: PPUSH
11430: LD_INT 100
11432: PPUSH
11433: LD_INT 75
11435: PPUSH
11436: CALL_OW 171
// AddComMoveXY ( Frank , 123 , 103 ) ;
11440: LD_EXP 33
11444: PPUSH
11445: LD_INT 123
11447: PPUSH
11448: LD_INT 103
11450: PPUSH
11451: CALL_OW 171
// AddComMoveXY ( Frank , 138 , 108 ) ;
11455: LD_EXP 33
11459: PPUSH
11460: LD_INT 138
11462: PPUSH
11463: LD_INT 108
11465: PPUSH
11466: CALL_OW 171
// AddComHold ( Frank ) ;
11470: LD_EXP 33
11474: PPUSH
11475: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
11479: LD_INT 35
11481: PPUSH
11482: CALL_OW 67
// until IsAt ( Frank , 138 , 108 ) ;
11486: LD_EXP 33
11490: PPUSH
11491: LD_INT 138
11493: PPUSH
11494: LD_INT 108
11496: PPUSH
11497: CALL_OW 307
11501: IFFALSE 11479
// AddComMoveXY ( Frank , 125 , 132 ) ;
11503: LD_EXP 33
11507: PPUSH
11508: LD_INT 125
11510: PPUSH
11511: LD_INT 132
11513: PPUSH
11514: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11518: LD_INT 35
11520: PPUSH
11521: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 7 ;
11525: LD_INT 1
11527: PPUSH
11528: LD_EXP 33
11532: PPUSH
11533: CALL_OW 292
11537: PUSH
11538: LD_EXP 33
11542: PPUSH
11543: LD_INT 7
11545: PPUSH
11546: CALL_OW 296
11550: PUSH
11551: LD_INT 7
11553: LESS
11554: OR
11555: IFFALSE 11518
// DialogueOn ;
11557: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11561: LD_EXP 33
11565: PPUSH
11566: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
11570: LD_INT 10
11572: PPUSH
11573: CALL_OW 68
// Say ( JMM , D4Fa-JMM-1 ) ;
11577: LD_EXP 21
11581: PPUSH
11582: LD_STRING D4Fa-JMM-1
11584: PPUSH
11585: CALL_OW 88
// for i in points do
11589: LD_ADDR_VAR 0 1
11593: PUSH
11594: LD_VAR 0 2
11598: PUSH
11599: FOR_IN
11600: IFFALSE 11658
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
11602: LD_VAR 0 1
11606: PUSH
11607: LD_INT 1
11609: ARRAY
11610: PPUSH
11611: LD_VAR 0 1
11615: PUSH
11616: LD_INT 2
11618: ARRAY
11619: PPUSH
11620: LD_INT 1
11622: PPUSH
11623: LD_INT 20
11625: NEG
11626: PPUSH
11627: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
11631: LD_VAR 0 1
11635: PUSH
11636: LD_INT 1
11638: ARRAY
11639: PPUSH
11640: LD_VAR 0 1
11644: PUSH
11645: LD_INT 2
11647: ARRAY
11648: PPUSH
11649: LD_INT 1
11651: PPUSH
11652: CALL_OW 331
// end ;
11656: GO 11599
11658: POP
11659: POP
// dwait ( 0 0$0.5 ) ;
11660: LD_INT 18
11662: PPUSH
11663: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
11667: LD_INT 42
11669: PPUSH
11670: LD_INT 27
11672: PPUSH
11673: CALL_OW 84
// Say ( Frank , D4Fa-Frank-1 ) ;
11677: LD_EXP 33
11681: PPUSH
11682: LD_STRING D4Fa-Frank-1
11684: PPUSH
11685: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
11689: LD_INT 18
11691: PPUSH
11692: CALL_OW 68
// Say ( JMM , D4Fa-JMM-2 ) ;
11696: LD_EXP 21
11700: PPUSH
11701: LD_STRING D4Fa-JMM-2
11703: PPUSH
11704: CALL_OW 88
// CenterNowOnXY ( 118 , 80 ) ;
11708: LD_INT 118
11710: PPUSH
11711: LD_INT 80
11713: PPUSH
11714: CALL_OW 86
// Say ( Frank , D4Fa-Frank-2 ) ;
11718: LD_EXP 33
11722: PPUSH
11723: LD_STRING D4Fa-Frank-2
11725: PPUSH
11726: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
11730: LD_INT 10
11732: PPUSH
11733: CALL_OW 68
// DialogueOff ;
11737: CALL_OW 7
// SetSide ( Frank , 1 ) ;
11741: LD_EXP 33
11745: PPUSH
11746: LD_INT 1
11748: PPUSH
11749: CALL_OW 235
// end else
11753: GO 12017
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
11755: LD_INT 2
11757: PPUSH
11758: LD_INT 4
11760: PPUSH
11761: LD_INT 2
11763: PPUSH
11764: LD_INT 1
11766: PPUSH
11767: CALL_OW 80
// ComMoveXY ( Frank , 75 , 63 ) ;
11771: LD_EXP 33
11775: PPUSH
11776: LD_INT 75
11778: PPUSH
11779: LD_INT 63
11781: PPUSH
11782: CALL_OW 111
// AddComWait ( Frank , 0 0$5 ) ;
11786: LD_EXP 33
11790: PPUSH
11791: LD_INT 175
11793: PPUSH
11794: CALL_OW 202
// AddComMoveXY ( Frank , 102 , 76 ) ;
11798: LD_EXP 33
11802: PPUSH
11803: LD_INT 102
11805: PPUSH
11806: LD_INT 76
11808: PPUSH
11809: CALL_OW 171
// AddComMoveXY ( Frank , 108 , 70 ) ;
11813: LD_EXP 33
11817: PPUSH
11818: LD_INT 108
11820: PPUSH
11821: LD_INT 70
11823: PPUSH
11824: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11828: LD_INT 35
11830: PPUSH
11831: CALL_OW 67
// until See ( 2 , Frank ) ;
11835: LD_INT 2
11837: PPUSH
11838: LD_EXP 33
11842: PPUSH
11843: CALL_OW 292
11847: IFFALSE 11828
// ComMoveXY ( Frank , 112 , 118 ) ;
11849: LD_EXP 33
11853: PPUSH
11854: LD_INT 112
11856: PPUSH
11857: LD_INT 118
11859: PPUSH
11860: CALL_OW 111
// if GetLives ( Frank ) >= 750 then
11864: LD_EXP 33
11868: PPUSH
11869: CALL_OW 256
11873: PUSH
11874: LD_INT 750
11876: GREATEREQUAL
11877: IFFALSE 11891
// SetLives ( Frank , 700 ) ;
11879: LD_EXP 33
11883: PPUSH
11884: LD_INT 700
11886: PPUSH
11887: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
11891: LD_INT 35
11893: PPUSH
11894: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 17 ;
11898: LD_INT 1
11900: PPUSH
11901: LD_EXP 33
11905: PPUSH
11906: CALL_OW 292
11910: PUSH
11911: LD_EXP 33
11915: PPUSH
11916: LD_INT 7
11918: PPUSH
11919: CALL_OW 296
11923: PUSH
11924: LD_INT 17
11926: LESS
11927: OR
11928: IFFALSE 11891
// DialogueOn ;
11930: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11934: LD_EXP 33
11938: PPUSH
11939: CALL_OW 87
// Say ( Frank , D4Fb-Frank-1 ) ;
11943: LD_EXP 33
11947: PPUSH
11948: LD_STRING D4Fb-Frank-1
11950: PPUSH
11951: CALL_OW 88
// Say ( JMM , D4Fb-JMM-1 ) ;
11955: LD_EXP 21
11959: PPUSH
11960: LD_STRING D4Fb-JMM-1
11962: PPUSH
11963: CALL_OW 88
// SayRand ( sex_female , D4Fb-FSci1-1 ) ;
11967: LD_INT 2
11969: PPUSH
11970: LD_STRING D4Fb-FSci1-1
11972: PPUSH
11973: CALL 16928 0 2
// Say ( Frank , D4Fb-Frank-2 ) ;
11977: LD_EXP 33
11981: PPUSH
11982: LD_STRING D4Fb-Frank-2
11984: PPUSH
11985: CALL_OW 88
// Say ( JMM , D4Fb-JMM-2 ) ;
11989: LD_EXP 21
11993: PPUSH
11994: LD_STRING D4Fb-JMM-2
11996: PPUSH
11997: CALL_OW 88
// DialogueOff ;
12001: CALL_OW 7
// SetSide ( Frank , 1 ) ;
12005: LD_EXP 33
12009: PPUSH
12010: LD_INT 1
12012: PPUSH
12013: CALL_OW 235
// end ; end ; end ; if IsOk ( Kikuchi ) and not IsOk ( Frank ) then
12017: LD_EXP 34
12021: PPUSH
12022: CALL_OW 302
12026: PUSH
12027: LD_EXP 33
12031: PPUSH
12032: CALL_OW 302
12036: NOT
12037: AND
12038: IFFALSE 12951
// begin DialogueOn ;
12040: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Kikuchi ] ) ;
12044: LD_EXP 21
12048: PUSH
12049: LD_EXP 34
12053: PUSH
12054: EMPTY
12055: LIST
12056: LIST
12057: PPUSH
12058: CALL_OW 87
// Say ( Kikuchi , D3Y-Yam-1 ) ;
12062: LD_EXP 34
12066: PPUSH
12067: LD_STRING D3Y-Yam-1
12069: PPUSH
12070: CALL_OW 88
// Say ( JMM , D3Y-JMM-1 ) ;
12074: LD_EXP 21
12078: PPUSH
12079: LD_STRING D3Y-JMM-1
12081: PPUSH
12082: CALL_OW 88
// Say ( Kikuchi , D3Y-Yam-2 ) ;
12086: LD_EXP 34
12090: PPUSH
12091: LD_STRING D3Y-Yam-2
12093: PPUSH
12094: CALL_OW 88
// case Query ( QYamoko ) of 1 :
12098: LD_STRING QYamoko
12100: PPUSH
12101: CALL_OW 97
12105: PUSH
12106: LD_INT 1
12108: DOUBLE
12109: EQUAL
12110: IFTRUE 12114
12112: GO 12149
12114: POP
// begin Say ( JMM , D3Ya-JMM-1 ) ;
12115: LD_EXP 21
12119: PPUSH
12120: LD_STRING D3Ya-JMM-1
12122: PPUSH
12123: CALL_OW 88
// Say ( Kikuchi , D3Ya-Yam-1 ) ;
12127: LD_EXP 34
12131: PPUSH
12132: LD_STRING D3Ya-Yam-1
12134: PPUSH
12135: CALL_OW 88
// us_scout := 1 ;
12139: LD_ADDR_EXP 8
12143: PUSH
12144: LD_INT 1
12146: ST_TO_ADDR
// end ; 2 :
12147: GO 12182
12149: LD_INT 2
12151: DOUBLE
12152: EQUAL
12153: IFTRUE 12157
12155: GO 12181
12157: POP
// begin us_scout := - 1 ;
12158: LD_ADDR_EXP 8
12162: PUSH
12163: LD_INT 1
12165: NEG
12166: ST_TO_ADDR
// Say ( JMM , D3Yb-JMM-1 ) ;
12167: LD_EXP 21
12171: PPUSH
12172: LD_STRING D3Yb-JMM-1
12174: PPUSH
12175: CALL_OW 88
// end ; end ;
12179: GO 12182
12181: POP
// DialogueOff ;
12182: CALL_OW 7
// if us_scout in [ - 1 , 0 ] then
12186: LD_EXP 8
12190: PUSH
12191: LD_INT 1
12193: NEG
12194: PUSH
12195: LD_INT 0
12197: PUSH
12198: EMPTY
12199: LIST
12200: LIST
12201: IN
12202: IFFALSE 12206
// exit ;
12204: GO 12951
// us_scout := [ 2 , 2 , 1 , 1 ] [ Difficulty ] ;
12206: LD_ADDR_EXP 8
12210: PUSH
12211: LD_INT 2
12213: PUSH
12214: LD_INT 2
12216: PUSH
12217: LD_INT 1
12219: PUSH
12220: LD_INT 1
12222: PUSH
12223: EMPTY
12224: LIST
12225: LIST
12226: LIST
12227: LIST
12228: PUSH
12229: LD_OWVAR 67
12233: ARRAY
12234: ST_TO_ADDR
// if us_scout in [ 1 , 2 ] then
12235: LD_EXP 8
12239: PUSH
12240: LD_INT 1
12242: PUSH
12243: LD_INT 2
12245: PUSH
12246: EMPTY
12247: LIST
12248: LIST
12249: IN
12250: IFFALSE 12951
// begin if IsInUnit ( Kikuchi ) then
12252: LD_EXP 34
12256: PPUSH
12257: CALL_OW 310
12261: IFFALSE 12272
// ComExitBuilding ( Kikuchi ) ;
12263: LD_EXP 34
12267: PPUSH
12268: CALL_OW 122
// if IsDrivenBy ( Kikuchi ) then
12272: LD_EXP 34
12276: PPUSH
12277: CALL_OW 311
12281: IFFALSE 12292
// ComExitVehicle ( Kikuchi ) ;
12283: LD_EXP 34
12287: PPUSH
12288: CALL_OW 121
// SetSide ( Kikuchi , 4 ) ;
12292: LD_EXP 34
12296: PPUSH
12297: LD_INT 4
12299: PPUSH
12300: CALL_OW 235
// wait ( 0 0$1 ) ;
12304: LD_INT 35
12306: PPUSH
12307: CALL_OW 67
// if us_scout = 2 then
12311: LD_EXP 8
12315: PUSH
12316: LD_INT 2
12318: EQUAL
12319: IFFALSE 12699
// begin ComMoveXY ( Kikuchi , 75 , 63 ) ;
12321: LD_EXP 34
12325: PPUSH
12326: LD_INT 75
12328: PPUSH
12329: LD_INT 63
12331: PPUSH
12332: CALL_OW 111
// AddComHold ( Kikuchi ) ;
12336: LD_EXP 34
12340: PPUSH
12341: CALL_OW 200
// AddComWait ( Kikuchi , 0 0$22 ) ;
12345: LD_EXP 34
12349: PPUSH
12350: LD_INT 770
12352: PPUSH
12353: CALL_OW 202
// AddComMoveXY ( Kikuchi , 100 , 75 ) ;
12357: LD_EXP 34
12361: PPUSH
12362: LD_INT 100
12364: PPUSH
12365: LD_INT 75
12367: PPUSH
12368: CALL_OW 171
// AddComMoveXY ( Kikuchi , 123 , 103 ) ;
12372: LD_EXP 34
12376: PPUSH
12377: LD_INT 123
12379: PPUSH
12380: LD_INT 103
12382: PPUSH
12383: CALL_OW 171
// AddComMoveXY ( Kikuchi , 138 , 108 ) ;
12387: LD_EXP 34
12391: PPUSH
12392: LD_INT 138
12394: PPUSH
12395: LD_INT 108
12397: PPUSH
12398: CALL_OW 171
// AddComHold ( Kikuchi ) ;
12402: LD_EXP 34
12406: PPUSH
12407: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
12411: LD_INT 35
12413: PPUSH
12414: CALL_OW 67
// until IsAt ( Kikuchi , 138 , 108 ) ;
12418: LD_EXP 34
12422: PPUSH
12423: LD_INT 138
12425: PPUSH
12426: LD_INT 108
12428: PPUSH
12429: CALL_OW 307
12433: IFFALSE 12411
// AddComMoveXY ( Kikuchi , 125 , 132 ) ;
12435: LD_EXP 34
12439: PPUSH
12440: LD_INT 125
12442: PPUSH
12443: LD_INT 132
12445: PPUSH
12446: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12450: LD_INT 35
12452: PPUSH
12453: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 7 ;
12457: LD_INT 1
12459: PPUSH
12460: LD_EXP 34
12464: PPUSH
12465: CALL_OW 292
12469: PUSH
12470: LD_EXP 34
12474: PPUSH
12475: LD_INT 7
12477: PPUSH
12478: CALL_OW 296
12482: PUSH
12483: LD_INT 7
12485: LESS
12486: OR
12487: IFFALSE 12450
// DialogueOn ;
12489: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12493: LD_EXP 34
12497: PPUSH
12498: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12502: LD_INT 10
12504: PPUSH
12505: CALL_OW 68
// Say ( Kikuchi , D4Ya-Yam-1 ) ;
12509: LD_EXP 34
12513: PPUSH
12514: LD_STRING D4Ya-Yam-1
12516: PPUSH
12517: CALL_OW 88
// Say ( JMM , D4Ya-JMM-1 ) ;
12521: LD_EXP 21
12525: PPUSH
12526: LD_STRING D4Ya-JMM-1
12528: PPUSH
12529: CALL_OW 88
// for i in points do
12533: LD_ADDR_VAR 0 1
12537: PUSH
12538: LD_VAR 0 2
12542: PUSH
12543: FOR_IN
12544: IFFALSE 12602
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
12546: LD_VAR 0 1
12550: PUSH
12551: LD_INT 1
12553: ARRAY
12554: PPUSH
12555: LD_VAR 0 1
12559: PUSH
12560: LD_INT 2
12562: ARRAY
12563: PPUSH
12564: LD_INT 1
12566: PPUSH
12567: LD_INT 20
12569: NEG
12570: PPUSH
12571: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
12575: LD_VAR 0 1
12579: PUSH
12580: LD_INT 1
12582: ARRAY
12583: PPUSH
12584: LD_VAR 0 1
12588: PUSH
12589: LD_INT 2
12591: ARRAY
12592: PPUSH
12593: LD_INT 1
12595: PPUSH
12596: CALL_OW 331
// end ;
12600: GO 12543
12602: POP
12603: POP
// dwait ( 0 0$0.5 ) ;
12604: LD_INT 18
12606: PPUSH
12607: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
12611: LD_INT 42
12613: PPUSH
12614: LD_INT 27
12616: PPUSH
12617: CALL_OW 84
// Say ( Kikuchi , D4Ya-Yam-2 ) ;
12621: LD_EXP 34
12625: PPUSH
12626: LD_STRING D4Ya-Yam-2
12628: PPUSH
12629: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
12633: LD_INT 18
12635: PPUSH
12636: CALL_OW 68
// CenterNowOnXY ( 118 , 80 ) ;
12640: LD_INT 118
12642: PPUSH
12643: LD_INT 80
12645: PPUSH
12646: CALL_OW 86
// Say ( JMM , D4Ya-JMM-2 ) ;
12650: LD_EXP 21
12654: PPUSH
12655: LD_STRING D4Ya-JMM-2
12657: PPUSH
12658: CALL_OW 88
// Say ( Kikuchi , D4Ya-Yam-3 ) ;
12662: LD_EXP 34
12666: PPUSH
12667: LD_STRING D4Ya-Yam-3
12669: PPUSH
12670: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
12674: LD_INT 10
12676: PPUSH
12677: CALL_OW 68
// DialogueOff ;
12681: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12685: LD_EXP 34
12689: PPUSH
12690: LD_INT 1
12692: PPUSH
12693: CALL_OW 235
// end else
12697: GO 12951
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
12699: LD_INT 2
12701: PPUSH
12702: LD_INT 4
12704: PPUSH
12705: LD_INT 2
12707: PPUSH
12708: LD_INT 1
12710: PPUSH
12711: CALL_OW 80
// ComMoveXY ( Kikuchi , 75 , 63 ) ;
12715: LD_EXP 34
12719: PPUSH
12720: LD_INT 75
12722: PPUSH
12723: LD_INT 63
12725: PPUSH
12726: CALL_OW 111
// AddComWait ( Kikuchi , 0 0$5 ) ;
12730: LD_EXP 34
12734: PPUSH
12735: LD_INT 175
12737: PPUSH
12738: CALL_OW 202
// AddComMoveXY ( Kikuchi , 102 , 76 ) ;
12742: LD_EXP 34
12746: PPUSH
12747: LD_INT 102
12749: PPUSH
12750: LD_INT 76
12752: PPUSH
12753: CALL_OW 171
// AddComMoveXY ( Kikuchi , 108 , 70 ) ;
12757: LD_EXP 34
12761: PPUSH
12762: LD_INT 108
12764: PPUSH
12765: LD_INT 70
12767: PPUSH
12768: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12772: LD_INT 35
12774: PPUSH
12775: CALL_OW 67
// until See ( 2 , Kikuchi ) ;
12779: LD_INT 2
12781: PPUSH
12782: LD_EXP 34
12786: PPUSH
12787: CALL_OW 292
12791: IFFALSE 12772
// ComMoveXY ( Kikuchi , 112 , 118 ) ;
12793: LD_EXP 34
12797: PPUSH
12798: LD_INT 112
12800: PPUSH
12801: LD_INT 118
12803: PPUSH
12804: CALL_OW 111
// if GetLives ( Kikuchi ) >= 750 then
12808: LD_EXP 34
12812: PPUSH
12813: CALL_OW 256
12817: PUSH
12818: LD_INT 750
12820: GREATEREQUAL
12821: IFFALSE 12835
// SetLives ( Kikuchi , 700 ) ;
12823: LD_EXP 34
12827: PPUSH
12828: LD_INT 700
12830: PPUSH
12831: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
12835: LD_INT 35
12837: PPUSH
12838: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 17 ;
12842: LD_INT 1
12844: PPUSH
12845: LD_EXP 34
12849: PPUSH
12850: CALL_OW 292
12854: PUSH
12855: LD_EXP 34
12859: PPUSH
12860: LD_INT 7
12862: PPUSH
12863: CALL_OW 296
12867: PUSH
12868: LD_INT 17
12870: LESS
12871: OR
12872: IFFALSE 12835
// DialogueOn ;
12874: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12878: LD_EXP 34
12882: PPUSH
12883: CALL_OW 87
// Say ( Kikuchi , D4Yb-Yam-1 ) ;
12887: LD_EXP 34
12891: PPUSH
12892: LD_STRING D4Yb-Yam-1
12894: PPUSH
12895: CALL_OW 88
// Say ( JMM , D4Yb-JMM-1 ) ;
12899: LD_EXP 21
12903: PPUSH
12904: LD_STRING D4Yb-JMM-1
12906: PPUSH
12907: CALL_OW 88
// Say ( Kikuchi , D4Yb-Yam-2 ) ;
12911: LD_EXP 34
12915: PPUSH
12916: LD_STRING D4Yb-Yam-2
12918: PPUSH
12919: CALL_OW 88
// Say ( JMM , D4Yb-JMM-2 ) ;
12923: LD_EXP 21
12927: PPUSH
12928: LD_STRING D4Yb-JMM-2
12930: PPUSH
12931: CALL_OW 88
// DialogueOff ;
12935: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12939: LD_EXP 34
12943: PPUSH
12944: LD_INT 1
12946: PPUSH
12947: CALL_OW 235
// end ; end ; end ; end ;
12951: PPOPN 2
12953: END
// every 0 0$01 trigger base_captured do var i , tmp , un , un2 ;
12954: LD_EXP 6
12958: IFFALSE 13991
12960: GO 12962
12962: DISABLE
12963: LD_INT 0
12965: PPUSH
12966: PPUSH
12967: PPUSH
12968: PPUSH
// begin enable ;
12969: ENABLE
// if not seen [ 1 ] then
12970: LD_EXP 9
12974: PUSH
12975: LD_INT 1
12977: ARRAY
12978: NOT
12979: IFFALSE 13159
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 11 ] , [ f_control , control_rider ] ] ] ) ;
12981: LD_ADDR_VAR 0 2
12985: PUSH
12986: LD_INT 22
12988: PUSH
12989: LD_INT 2
12991: PUSH
12992: EMPTY
12993: LIST
12994: LIST
12995: PUSH
12996: LD_INT 2
12998: PUSH
12999: LD_INT 25
13001: PUSH
13002: LD_INT 11
13004: PUSH
13005: EMPTY
13006: LIST
13007: LIST
13008: PUSH
13009: LD_INT 33
13011: PUSH
13012: LD_INT 4
13014: PUSH
13015: EMPTY
13016: LIST
13017: LIST
13018: PUSH
13019: EMPTY
13020: LIST
13021: LIST
13022: LIST
13023: PUSH
13024: EMPTY
13025: LIST
13026: LIST
13027: PPUSH
13028: CALL_OW 69
13032: ST_TO_ADDR
// if tmp then
13033: LD_VAR 0 2
13037: IFFALSE 13159
// for i in tmp do
13039: LD_ADDR_VAR 0 1
13043: PUSH
13044: LD_VAR 0 2
13048: PUSH
13049: FOR_IN
13050: IFFALSE 13157
// if See ( 1 , i ) then
13052: LD_INT 1
13054: PPUSH
13055: LD_VAR 0 1
13059: PPUSH
13060: CALL_OW 292
13064: IFFALSE 13155
// begin seen := Replace ( seen , 1 , true ) ;
13066: LD_ADDR_EXP 9
13070: PUSH
13071: LD_EXP 9
13075: PPUSH
13076: LD_INT 1
13078: PPUSH
13079: LD_INT 1
13081: PPUSH
13082: CALL_OW 1
13086: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13087: LD_INT 1
13089: PPUSH
13090: CALL 16750 0 1
13094: IFFALSE 13155
// begin DialogueOn ;
13096: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13100: LD_VAR 0 1
13104: PPUSH
13105: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13109: LD_INT 10
13111: PPUSH
13112: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol2-1 ) ;
13116: LD_ADDR_VAR 0 3
13120: PUSH
13121: LD_INT 1
13123: PPUSH
13124: LD_STRING D5a-Sol2-1
13126: PPUSH
13127: CALL 16928 0 2
13131: ST_TO_ADDR
// if not un then
13132: LD_VAR 0 3
13136: NOT
13137: IFFALSE 13149
// SayRand ( sex_female , D5a-FSol2-1 ) ;
13139: LD_INT 2
13141: PPUSH
13142: LD_STRING D5a-FSol2-1
13144: PPUSH
13145: CALL 16928 0 2
// DialogueOff ;
13149: CALL_OW 7
// break ;
13153: GO 13157
// end ; end ;
13155: GO 13049
13157: POP
13158: POP
// end ; if not seen [ 2 ] then
13159: LD_EXP 9
13163: PUSH
13164: LD_INT 2
13166: ARRAY
13167: NOT
13168: IFFALSE 13393
// begin can_kamikazed := true ;
13170: LD_ADDR_EXP 10
13174: PUSH
13175: LD_INT 1
13177: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 17 ] ] ) ;
13178: LD_ADDR_VAR 0 2
13182: PUSH
13183: LD_INT 22
13185: PUSH
13186: LD_INT 2
13188: PUSH
13189: EMPTY
13190: LIST
13191: LIST
13192: PUSH
13193: LD_INT 25
13195: PUSH
13196: LD_INT 17
13198: PUSH
13199: EMPTY
13200: LIST
13201: LIST
13202: PUSH
13203: EMPTY
13204: LIST
13205: LIST
13206: PPUSH
13207: CALL_OW 69
13211: ST_TO_ADDR
// if tmp then
13212: LD_VAR 0 2
13216: IFFALSE 13393
// for i in tmp do
13218: LD_ADDR_VAR 0 1
13222: PUSH
13223: LD_VAR 0 2
13227: PUSH
13228: FOR_IN
13229: IFFALSE 13391
// if See ( 1 , i ) then
13231: LD_INT 1
13233: PPUSH
13234: LD_VAR 0 1
13238: PPUSH
13239: CALL_OW 292
13243: IFFALSE 13389
// begin seen := Replace ( seen , 2 , true ) ;
13245: LD_ADDR_EXP 9
13249: PUSH
13250: LD_EXP 9
13254: PPUSH
13255: LD_INT 2
13257: PPUSH
13258: LD_INT 1
13260: PPUSH
13261: CALL_OW 1
13265: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13266: LD_INT 1
13268: PPUSH
13269: CALL 16750 0 1
13273: IFFALSE 13389
// begin DialogueOn ;
13275: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13279: LD_VAR 0 1
13283: PPUSH
13284: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13288: LD_INT 10
13290: PPUSH
13291: CALL_OW 68
// un := SayRand ( sex_male , D5b-Sol1-1 ) ;
13295: LD_ADDR_VAR 0 3
13299: PUSH
13300: LD_INT 1
13302: PPUSH
13303: LD_STRING D5b-Sol1-1
13305: PPUSH
13306: CALL 16928 0 2
13310: ST_TO_ADDR
// if not un then
13311: LD_VAR 0 3
13315: NOT
13316: IFFALSE 13334
// un := SayRand ( sex_female , D5b-FSol1-1 ) ;
13318: LD_ADDR_VAR 0 3
13322: PUSH
13323: LD_INT 2
13325: PPUSH
13326: LD_STRING D5b-FSol1-1
13328: PPUSH
13329: CALL 16928 0 2
13333: ST_TO_ADDR
// if un then
13334: LD_VAR 0 3
13338: IFFALSE 13383
// begin un2 := SayRand2 ( sex_male , D5b-Sol2-1 , un ) ;
13340: LD_ADDR_VAR 0 4
13344: PUSH
13345: LD_INT 1
13347: PPUSH
13348: LD_STRING D5b-Sol2-1
13350: PPUSH
13351: LD_VAR 0 3
13355: PPUSH
13356: CALL 17154 0 3
13360: ST_TO_ADDR
// if not un2 then
13361: LD_VAR 0 4
13365: NOT
13366: IFFALSE 13383
// SayRand2 ( sex_female , D5b-FSol2-1 , un ) ;
13368: LD_INT 2
13370: PPUSH
13371: LD_STRING D5b-FSol2-1
13373: PPUSH
13374: LD_VAR 0 3
13378: PPUSH
13379: CALL 17154 0 3
// end ; DialogueOff ;
13383: CALL_OW 7
// break ;
13387: GO 13391
// end ; end ;
13389: GO 13228
13391: POP
13392: POP
// end ; if not seen [ 3 ] then
13393: LD_EXP 9
13397: PUSH
13398: LD_INT 3
13400: ARRAY
13401: NOT
13402: IFFALSE 13576
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] ] ) ;
13404: LD_ADDR_VAR 0 2
13408: PUSH
13409: LD_INT 22
13411: PUSH
13412: LD_INT 2
13414: PUSH
13415: EMPTY
13416: LIST
13417: LIST
13418: PUSH
13419: LD_INT 33
13421: PUSH
13422: LD_INT 2
13424: PUSH
13425: EMPTY
13426: LIST
13427: LIST
13428: PUSH
13429: EMPTY
13430: LIST
13431: LIST
13432: PPUSH
13433: CALL_OW 69
13437: ST_TO_ADDR
// if tmp then
13438: LD_VAR 0 2
13442: IFFALSE 13576
// for i in tmp do
13444: LD_ADDR_VAR 0 1
13448: PUSH
13449: LD_VAR 0 2
13453: PUSH
13454: FOR_IN
13455: IFFALSE 13574
// if See ( 1 , i ) then
13457: LD_INT 1
13459: PPUSH
13460: LD_VAR 0 1
13464: PPUSH
13465: CALL_OW 292
13469: IFFALSE 13572
// begin seen := Replace ( seen , 3 , true ) ;
13471: LD_ADDR_EXP 9
13475: PUSH
13476: LD_EXP 9
13480: PPUSH
13481: LD_INT 3
13483: PPUSH
13484: LD_INT 1
13486: PPUSH
13487: CALL_OW 1
13491: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13492: LD_INT 1
13494: PPUSH
13495: CALL 16750 0 1
13499: IFFALSE 13572
// begin DialogueOn ;
13501: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13505: LD_VAR 0 1
13509: PPUSH
13510: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13514: LD_INT 10
13516: PPUSH
13517: CALL_OW 68
// un := SayRand ( sex_male , D8-Sol1-1 ) ;
13521: LD_ADDR_VAR 0 3
13525: PUSH
13526: LD_INT 1
13528: PPUSH
13529: LD_STRING D8-Sol1-1
13531: PPUSH
13532: CALL 16928 0 2
13536: ST_TO_ADDR
// if not un then
13537: LD_VAR 0 3
13541: NOT
13542: IFFALSE 13554
// SayRand ( sex_female , D8-FSol1-1 ) ;
13544: LD_INT 2
13546: PPUSH
13547: LD_STRING D8-FSol1-1
13549: PPUSH
13550: CALL 16928 0 2
// Say ( JMM , D8-JMM-1 ) ;
13554: LD_EXP 21
13558: PPUSH
13559: LD_STRING D8-JMM-1
13561: PPUSH
13562: CALL_OW 88
// DialogueOff ;
13566: CALL_OW 7
// break ;
13570: GO 13574
// end ; end ;
13572: GO 13454
13574: POP
13575: POP
// end ; if not seen [ 4 ] then
13576: LD_EXP 9
13580: PUSH
13581: LD_INT 4
13583: ARRAY
13584: NOT
13585: IFFALSE 13747
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] ] ) ;
13587: LD_ADDR_VAR 0 2
13591: PUSH
13592: LD_INT 22
13594: PUSH
13595: LD_INT 2
13597: PUSH
13598: EMPTY
13599: LIST
13600: LIST
13601: PUSH
13602: LD_INT 33
13604: PUSH
13605: LD_INT 5
13607: PUSH
13608: EMPTY
13609: LIST
13610: LIST
13611: PUSH
13612: EMPTY
13613: LIST
13614: LIST
13615: PPUSH
13616: CALL_OW 69
13620: ST_TO_ADDR
// if tmp then
13621: LD_VAR 0 2
13625: IFFALSE 13747
// for i in tmp do
13627: LD_ADDR_VAR 0 1
13631: PUSH
13632: LD_VAR 0 2
13636: PUSH
13637: FOR_IN
13638: IFFALSE 13745
// if See ( 1 , i ) then
13640: LD_INT 1
13642: PPUSH
13643: LD_VAR 0 1
13647: PPUSH
13648: CALL_OW 292
13652: IFFALSE 13743
// begin seen := Replace ( seen , 4 , true ) ;
13654: LD_ADDR_EXP 9
13658: PUSH
13659: LD_EXP 9
13663: PPUSH
13664: LD_INT 4
13666: PPUSH
13667: LD_INT 1
13669: PPUSH
13670: CALL_OW 1
13674: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13675: LD_INT 1
13677: PPUSH
13678: CALL 16750 0 1
13682: IFFALSE 13743
// begin DialogueOn ;
13684: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13688: LD_VAR 0 1
13692: PPUSH
13693: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13697: LD_INT 10
13699: PPUSH
13700: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol1-1 ) ;
13704: LD_ADDR_VAR 0 3
13708: PUSH
13709: LD_INT 1
13711: PPUSH
13712: LD_STRING D5a-Sol1-1
13714: PPUSH
13715: CALL 16928 0 2
13719: ST_TO_ADDR
// if not un then
13720: LD_VAR 0 3
13724: NOT
13725: IFFALSE 13737
// SayRand ( sex_female , D5a-FSol1-1 ) ;
13727: LD_INT 2
13729: PPUSH
13730: LD_STRING D5a-FSol1-1
13732: PPUSH
13733: CALL 16928 0 2
// DialogueOff ;
13737: CALL_OW 7
// break ;
13741: GO 13745
// end ; end ;
13743: GO 13637
13745: POP
13746: POP
// end ; if not seen [ 5 ] and seen [ 3 ] then
13747: LD_EXP 9
13751: PUSH
13752: LD_INT 5
13754: ARRAY
13755: NOT
13756: PUSH
13757: LD_EXP 9
13761: PUSH
13762: LD_INT 3
13764: ARRAY
13765: AND
13766: IFFALSE 13940
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) ;
13768: LD_ADDR_VAR 0 2
13772: PUSH
13773: LD_INT 22
13775: PUSH
13776: LD_INT 2
13778: PUSH
13779: EMPTY
13780: LIST
13781: LIST
13782: PUSH
13783: LD_INT 34
13785: PUSH
13786: LD_INT 31
13788: PUSH
13789: EMPTY
13790: LIST
13791: LIST
13792: PUSH
13793: EMPTY
13794: LIST
13795: LIST
13796: PPUSH
13797: CALL_OW 69
13801: ST_TO_ADDR
// if tmp then
13802: LD_VAR 0 2
13806: IFFALSE 13940
// for i in tmp do
13808: LD_ADDR_VAR 0 1
13812: PUSH
13813: LD_VAR 0 2
13817: PUSH
13818: FOR_IN
13819: IFFALSE 13938
// if See ( 1 , i ) then
13821: LD_INT 1
13823: PPUSH
13824: LD_VAR 0 1
13828: PPUSH
13829: CALL_OW 292
13833: IFFALSE 13936
// begin seen := Replace ( seen , 5 , true ) ;
13835: LD_ADDR_EXP 9
13839: PUSH
13840: LD_EXP 9
13844: PPUSH
13845: LD_INT 5
13847: PPUSH
13848: LD_INT 1
13850: PPUSH
13851: CALL_OW 1
13855: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13856: LD_INT 1
13858: PPUSH
13859: CALL 16750 0 1
13863: IFFALSE 13936
// begin DialogueOn ;
13865: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13869: LD_VAR 0 1
13873: PPUSH
13874: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13878: LD_INT 10
13880: PPUSH
13881: CALL_OW 68
// un := SayRand ( sex_male , D8a-Sol2-1 ) ;
13885: LD_ADDR_VAR 0 3
13889: PUSH
13890: LD_INT 1
13892: PPUSH
13893: LD_STRING D8a-Sol2-1
13895: PPUSH
13896: CALL 16928 0 2
13900: ST_TO_ADDR
// if not un then
13901: LD_VAR 0 3
13905: NOT
13906: IFFALSE 13918
// SayRand ( sex_female , D8a-FSol2-1 ) ;
13908: LD_INT 2
13910: PPUSH
13911: LD_STRING D8a-FSol2-1
13913: PPUSH
13914: CALL 16928 0 2
// Say ( JMM , D8a-JMM-1 ) ;
13918: LD_EXP 21
13922: PPUSH
13923: LD_STRING D8a-JMM-1
13925: PPUSH
13926: CALL_OW 88
// DialogueOff ;
13930: CALL_OW 7
// break ;
13934: GO 13938
// end ; end ;
13936: GO 13818
13938: POP
13939: POP
// end ; if seen [ 1 ] and seen [ 2 ] and seen [ 3 ] and seen [ 4 ] and seen [ 5 ] then
13940: LD_EXP 9
13944: PUSH
13945: LD_INT 1
13947: ARRAY
13948: PUSH
13949: LD_EXP 9
13953: PUSH
13954: LD_INT 2
13956: ARRAY
13957: AND
13958: PUSH
13959: LD_EXP 9
13963: PUSH
13964: LD_INT 3
13966: ARRAY
13967: AND
13968: PUSH
13969: LD_EXP 9
13973: PUSH
13974: LD_INT 4
13976: ARRAY
13977: AND
13978: PUSH
13979: LD_EXP 9
13983: PUSH
13984: LD_INT 5
13986: ARRAY
13987: AND
13988: IFFALSE 13991
// disable ;
13990: DISABLE
// end ;
13991: PPOPN 4
13993: END
// every 0 0$1 trigger can_kamikazed and kamikazed do var un ;
13994: LD_EXP 10
13998: PUSH
13999: LD_EXP 11
14003: AND
14004: IFFALSE 14202
14006: GO 14008
14008: DISABLE
14009: LD_INT 0
14011: PPUSH
// begin DialogueOn ;
14012: CALL_OW 6
// CenterNowOnUnits ( kamikazed ) ;
14016: LD_EXP 11
14020: PPUSH
14021: CALL_OW 87
// un := SayRand ( sex_male , D5c-Sol1-1 ) ;
14025: LD_ADDR_VAR 0 1
14029: PUSH
14030: LD_INT 1
14032: PPUSH
14033: LD_STRING D5c-Sol1-1
14035: PPUSH
14036: CALL 16928 0 2
14040: ST_TO_ADDR
// if not un then
14041: LD_VAR 0 1
14045: NOT
14046: IFFALSE 14064
// un := SayRand ( sex_female , D5c-FSol1-1 ) ;
14048: LD_ADDR_VAR 0 1
14052: PUSH
14053: LD_INT 2
14055: PPUSH
14056: LD_STRING D5c-FSol1-1
14058: PPUSH
14059: CALL 16928 0 2
14063: ST_TO_ADDR
// Say ( JMM , D5c-JMM-1 ) ;
14064: LD_EXP 21
14068: PPUSH
14069: LD_STRING D5c-JMM-1
14071: PPUSH
14072: CALL_OW 88
// if IsOk ( Lisa ) then
14076: LD_EXP 22
14080: PPUSH
14081: CALL_OW 302
14085: IFFALSE 14101
// Say ( Lisa , D5d-Lisa-1 ) else
14087: LD_EXP 22
14091: PPUSH
14092: LD_STRING D5d-Lisa-1
14094: PPUSH
14095: CALL_OW 88
14099: GO 14186
// if IsOk ( Cyrus ) then
14101: LD_EXP 25
14105: PPUSH
14106: CALL_OW 302
14110: IFFALSE 14126
// Say ( Cyrus , D5d-Cyrus-1 ) else
14112: LD_EXP 25
14116: PPUSH
14117: LD_STRING D5d-Cyrus-1
14119: PPUSH
14120: CALL_OW 88
14124: GO 14186
// if IsOk ( Gary ) then
14126: LD_EXP 32
14130: PPUSH
14131: CALL_OW 302
14135: IFFALSE 14151
// Say ( Gary , D5d-Gary-1 ) else
14137: LD_EXP 32
14141: PPUSH
14142: LD_STRING D5d-Gary-1
14144: PPUSH
14145: CALL_OW 88
14149: GO 14186
// if GetSex ( un ) = sex_male then
14151: LD_VAR 0 1
14155: PPUSH
14156: CALL_OW 258
14160: PUSH
14161: LD_INT 1
14163: EQUAL
14164: IFFALSE 14180
// Say ( un , D5d-Sol1-1 ) else
14166: LD_VAR 0 1
14170: PPUSH
14171: LD_STRING D5d-Sol1-1
14173: PPUSH
14174: CALL_OW 88
14178: GO 14186
// begin DialogueOff ;
14180: CALL_OW 7
// exit ;
14184: GO 14202
// end ; Say ( JMM , D5d-JMM-1 ) ;
14186: LD_EXP 21
14190: PPUSH
14191: LD_STRING D5d-JMM-1
14193: PPUSH
14194: CALL_OW 88
// DialogueOff ;
14198: CALL_OW 7
// end ;
14202: PPOPN 1
14204: END
// every 0 0$2 trigger SeeArea ( 1 , artifact_area ) >= 2 do var un ;
14205: LD_INT 1
14207: PPUSH
14208: LD_INT 17
14210: PPUSH
14211: CALL_OW 294
14215: PUSH
14216: LD_INT 2
14218: GREATEREQUAL
14219: IFFALSE 14351
14221: GO 14223
14223: DISABLE
14224: LD_INT 0
14226: PPUSH
// begin PlaceSeeing ( 10 , 5 , 1 , - 10 ) ;
14227: LD_INT 10
14229: PPUSH
14230: LD_INT 5
14232: PPUSH
14233: LD_INT 1
14235: PPUSH
14236: LD_INT 10
14238: NEG
14239: PPUSH
14240: CALL_OW 330
// RemoveSeeing ( 10 , 5 , 1 ) ;
14244: LD_INT 10
14246: PPUSH
14247: LD_INT 5
14249: PPUSH
14250: LD_INT 1
14252: PPUSH
14253: CALL_OW 331
// CenterNowOnXY ( 10 , 5 ) ;
14257: LD_INT 10
14259: PPUSH
14260: LD_INT 5
14262: PPUSH
14263: CALL_OW 86
// DialogueOn ;
14267: CALL_OW 6
// un := SayRand ( sex_male , D6-Sci1-1 ) ;
14271: LD_ADDR_VAR 0 1
14275: PUSH
14276: LD_INT 1
14278: PPUSH
14279: LD_STRING D6-Sci1-1
14281: PPUSH
14282: CALL 16928 0 2
14286: ST_TO_ADDR
// if un then
14287: LD_VAR 0 1
14291: IFFALSE 14329
// begin Say ( JMM , D6-JMM-1 ) ;
14293: LD_EXP 21
14297: PPUSH
14298: LD_STRING D6-JMM-1
14300: PPUSH
14301: CALL_OW 88
// Say ( un , D6-Sci1-2 ) ;
14305: LD_VAR 0 1
14309: PPUSH
14310: LD_STRING D6-Sci1-2
14312: PPUSH
14313: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
14317: LD_EXP 21
14321: PPUSH
14322: LD_STRING D6-JMM-2
14324: PPUSH
14325: CALL_OW 88
// end ; DialogueOff ;
14329: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
14333: LD_STRING M3
14335: PPUSH
14336: CALL_OW 337
// wait ( 0 0$30 ) ;
14340: LD_INT 1050
14342: PPUSH
14343: CALL_OW 67
// AmericanReinforcements ;
14347: CALL 2326 0 0
// end ;
14351: PPOPN 1
14353: END
// export ar_mechanic , ar_mechanic_friend ; every 0 0$20 trigger tick >= 20 20$00 and ( DangerAtRangeXY ( 2 , 169 , 90 , 10 ) [ 4 ] = 0 or IsDead ( ar_dep_w ) or GetSide ( ar_dep_w ) = 1 ) and not IsDead ( ar_dep_n ) do var un , i , cargo , tmp , escaped ;
14354: LD_OWVAR 1
14358: PUSH
14359: LD_INT 42000
14361: GREATEREQUAL
14362: PUSH
14363: LD_INT 2
14365: PPUSH
14366: LD_INT 169
14368: PPUSH
14369: LD_INT 90
14371: PPUSH
14372: LD_INT 10
14374: PPUSH
14375: CALL 54930 0 4
14379: PUSH
14380: LD_INT 4
14382: ARRAY
14383: PUSH
14384: LD_INT 0
14386: EQUAL
14387: PUSH
14388: LD_INT 45
14390: PPUSH
14391: CALL_OW 301
14395: OR
14396: PUSH
14397: LD_INT 45
14399: PPUSH
14400: CALL_OW 255
14404: PUSH
14405: LD_INT 1
14407: EQUAL
14408: OR
14409: AND
14410: PUSH
14411: LD_INT 94
14413: PPUSH
14414: CALL_OW 301
14418: NOT
14419: AND
14420: IFFALSE 15625
14422: GO 14424
14424: DISABLE
14425: LD_INT 0
14427: PPUSH
14428: PPUSH
14429: PPUSH
14430: PPUSH
14431: PPUSH
// begin uc_side := 5 ;
14432: LD_ADDR_OWVAR 20
14436: PUSH
14437: LD_INT 5
14439: ST_TO_ADDR
// uc_nation := 2 ;
14440: LD_ADDR_OWVAR 21
14444: PUSH
14445: LD_INT 2
14447: ST_TO_ADDR
// InitHc ;
14448: CALL_OW 19
// PrepareHuman ( sex_male , 3 , 8 ) ;
14452: LD_INT 1
14454: PPUSH
14455: LD_INT 3
14457: PPUSH
14458: LD_INT 8
14460: PPUSH
14461: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
14465: LD_ADDR_OWVAR 29
14469: PUSH
14470: LD_INT 12
14472: PUSH
14473: LD_INT 12
14475: PUSH
14476: EMPTY
14477: LIST
14478: LIST
14479: ST_TO_ADDR
// hc_name := Hans Fliege ;
14480: LD_ADDR_OWVAR 26
14484: PUSH
14485: LD_STRING Hans Fliege
14487: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
14488: LD_ADDR_OWVAR 33
14492: PUSH
14493: LD_STRING SecondCharsGal
14495: ST_TO_ADDR
// hc_face_number := 7 ;
14496: LD_ADDR_OWVAR 34
14500: PUSH
14501: LD_INT 7
14503: ST_TO_ADDR
// ar_mechanic := CreateHuman ;
14504: LD_ADDR_EXP 46
14508: PUSH
14509: CALL_OW 44
14513: ST_TO_ADDR
// InitHc ;
14514: CALL_OW 19
// PrepareHuman ( sex_male , 16 , 2 ) ;
14518: LD_INT 1
14520: PPUSH
14521: LD_INT 16
14523: PPUSH
14524: LD_INT 2
14526: PPUSH
14527: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
14531: LD_ADDR_OWVAR 29
14535: PUSH
14536: LD_INT 12
14538: PUSH
14539: LD_INT 12
14541: PUSH
14542: EMPTY
14543: LIST
14544: LIST
14545: ST_TO_ADDR
// hc_name :=  ;
14546: LD_ADDR_OWVAR 26
14550: PUSH
14551: LD_STRING 
14553: ST_TO_ADDR
// ar_mechanic_friend := CreateHuman ;
14554: LD_ADDR_EXP 47
14558: PUSH
14559: CALL_OW 44
14563: ST_TO_ADDR
// InitHc ;
14564: CALL_OW 19
// repeat wait ( 0 0$1 ) ;
14568: LD_INT 35
14570: PPUSH
14571: CALL_OW 67
// until not InBattle ( 1 ) ;
14575: LD_INT 1
14577: PPUSH
14578: CALL_OW 463
14582: NOT
14583: IFFALSE 14568
// wait ( 0 0$5 ) ;
14585: LD_INT 175
14587: PPUSH
14588: CALL_OW 67
// DialogueOn ;
14592: CALL_OW 6
// InGameOn ;
14596: CALL_OW 8
// un := UnitFilter ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , [ f_sex , sex_male ] ) [ 1 ] ;
14600: LD_ADDR_VAR 0 1
14604: PUSH
14605: LD_INT 22
14607: PUSH
14608: LD_INT 1
14610: PUSH
14611: EMPTY
14612: LIST
14613: LIST
14614: PUSH
14615: LD_INT 2
14617: PUSH
14618: LD_INT 25
14620: PUSH
14621: LD_INT 1
14623: PUSH
14624: EMPTY
14625: LIST
14626: LIST
14627: PUSH
14628: LD_INT 25
14630: PUSH
14631: LD_INT 2
14633: PUSH
14634: EMPTY
14635: LIST
14636: LIST
14637: PUSH
14638: LD_INT 25
14640: PUSH
14641: LD_INT 3
14643: PUSH
14644: EMPTY
14645: LIST
14646: LIST
14647: PUSH
14648: LD_INT 25
14650: PUSH
14651: LD_INT 4
14653: PUSH
14654: EMPTY
14655: LIST
14656: LIST
14657: PUSH
14658: LD_INT 25
14660: PUSH
14661: LD_INT 5
14663: PUSH
14664: EMPTY
14665: LIST
14666: LIST
14667: PUSH
14668: LD_INT 25
14670: PUSH
14671: LD_INT 8
14673: PUSH
14674: EMPTY
14675: LIST
14676: LIST
14677: PUSH
14678: EMPTY
14679: LIST
14680: LIST
14681: LIST
14682: LIST
14683: LIST
14684: LIST
14685: LIST
14686: PUSH
14687: EMPTY
14688: LIST
14689: LIST
14690: PPUSH
14691: CALL_OW 69
14695: PUSH
14696: LD_EXP 21
14700: PUSH
14701: LD_EXP 22
14705: PUSH
14706: LD_EXP 23
14710: PUSH
14711: LD_EXP 24
14715: PUSH
14716: LD_EXP 25
14720: PUSH
14721: LD_EXP 26
14725: PUSH
14726: LD_EXP 27
14730: PUSH
14731: LD_EXP 28
14735: PUSH
14736: LD_EXP 29
14740: PUSH
14741: LD_EXP 31
14745: PUSH
14746: LD_EXP 32
14750: PUSH
14751: LD_EXP 33
14755: PUSH
14756: LD_EXP 34
14760: PUSH
14761: EMPTY
14762: LIST
14763: LIST
14764: LIST
14765: LIST
14766: LIST
14767: LIST
14768: LIST
14769: LIST
14770: LIST
14771: LIST
14772: LIST
14773: LIST
14774: LIST
14775: DIFF
14776: PPUSH
14777: LD_INT 26
14779: PUSH
14780: LD_INT 1
14782: PUSH
14783: EMPTY
14784: LIST
14785: LIST
14786: PPUSH
14787: CALL_OW 72
14791: PUSH
14792: LD_INT 1
14794: ARRAY
14795: ST_TO_ADDR
// if Brown then
14796: LD_EXP 27
14800: IFFALSE 14812
// un := Brown ;
14802: LD_ADDR_VAR 0 1
14806: PUSH
14807: LD_EXP 27
14811: ST_TO_ADDR
// if un then
14812: LD_VAR 0 1
14816: IFFALSE 14842
// begin Say ( un , D7-Sol1-1 ) ;
14818: LD_VAR 0 1
14822: PPUSH
14823: LD_STRING D7-Sol1-1
14825: PPUSH
14826: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
14830: LD_EXP 21
14834: PPUSH
14835: LD_STRING D7-JMM-1
14837: PPUSH
14838: CALL_OW 88
// end ; SayRadio ( ar_mechanic , D7-Ar1-1 ) ;
14842: LD_EXP 46
14846: PPUSH
14847: LD_STRING D7-Ar1-1
14849: PPUSH
14850: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
14854: LD_EXP 21
14858: PPUSH
14859: LD_STRING D7-JMM-2
14861: PPUSH
14862: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-2 ) ;
14866: LD_EXP 46
14870: PPUSH
14871: LD_STRING D7-Ar1-2
14873: PPUSH
14874: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
14878: LD_EXP 21
14882: PPUSH
14883: LD_STRING D7-JMM-3
14885: PPUSH
14886: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-3 ) ;
14890: LD_EXP 46
14894: PPUSH
14895: LD_STRING D7-Ar1-3
14897: PPUSH
14898: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
14902: LD_EXP 21
14906: PPUSH
14907: LD_STRING D7-JMM-4
14909: PPUSH
14910: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-4 ) ;
14914: LD_EXP 46
14918: PPUSH
14919: LD_STRING D7-Ar1-4
14921: PPUSH
14922: CALL_OW 94
// InGameOff ;
14926: CALL_OW 9
// DialogueOff ;
14930: CALL_OW 7
// case Query ( QCameras ) of 1 :
14934: LD_STRING QCameras
14936: PPUSH
14937: CALL_OW 97
14941: PUSH
14942: LD_INT 1
14944: DOUBLE
14945: EQUAL
14946: IFTRUE 14950
14948: GO 14953
14950: POP
// ; 2 :
14951: GO 14967
14953: LD_INT 2
14955: DOUBLE
14956: EQUAL
14957: IFTRUE 14961
14959: GO 14966
14961: POP
// exit ; end ;
14962: GO 15625
14964: GO 14967
14966: POP
// ChangeMissionObjectives ( MCar ) ;
14967: LD_STRING MCar
14969: PPUSH
14970: CALL_OW 337
// PlaceSeeing ( 124 , 90 , 1 , - 6 ) ;
14974: LD_INT 124
14976: PPUSH
14977: LD_INT 90
14979: PPUSH
14980: LD_INT 1
14982: PPUSH
14983: LD_INT 6
14985: NEG
14986: PPUSH
14987: CALL_OW 330
// RemoveSeeing ( 124 , 90 , 1 ) ;
14991: LD_INT 124
14993: PPUSH
14994: LD_INT 90
14996: PPUSH
14997: LD_INT 1
14999: PPUSH
15000: CALL_OW 331
// SetAreaMapShow ( parking_marea , 1 ) ;
15004: LD_INT 12
15006: PPUSH
15007: LD_INT 1
15009: PPUSH
15010: CALL_OW 424
// wait ( 3 ) ;
15014: LD_INT 3
15016: PPUSH
15017: CALL_OW 67
// CenterNowOnXY ( 124 , 90 ) ;
15021: LD_INT 124
15023: PPUSH
15024: LD_INT 90
15026: PPUSH
15027: CALL_OW 86
// cargo := false ;
15031: LD_ADDR_VAR 0 3
15035: PUSH
15036: LD_INT 0
15038: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
15039: LD_INT 35
15041: PPUSH
15042: CALL_OW 67
// cargo := FilterUnitsInArea ( parking_marea , [ [ f_engine , engine_siberite ] , [ f_weapon , ar_cargo_bay ] , [ f_empty ] ] ) ;
15046: LD_ADDR_VAR 0 3
15050: PUSH
15051: LD_INT 12
15053: PPUSH
15054: LD_INT 32
15056: PUSH
15057: LD_INT 3
15059: PUSH
15060: EMPTY
15061: LIST
15062: LIST
15063: PUSH
15064: LD_INT 34
15066: PUSH
15067: LD_INT 32
15069: PUSH
15070: EMPTY
15071: LIST
15072: LIST
15073: PUSH
15074: LD_INT 58
15076: PUSH
15077: EMPTY
15078: LIST
15079: PUSH
15080: EMPTY
15081: LIST
15082: LIST
15083: LIST
15084: PPUSH
15085: CALL_OW 70
15089: ST_TO_ADDR
// until cargo ;
15090: LD_VAR 0 3
15094: IFFALSE 15039
// cargo := cargo [ 1 ] ;
15096: LD_ADDR_VAR 0 3
15100: PUSH
15101: LD_VAR 0 3
15105: PUSH
15106: LD_INT 1
15108: ARRAY
15109: ST_TO_ADDR
// SetSide ( cargo , 5 ) ;
15110: LD_VAR 0 3
15114: PPUSH
15115: LD_INT 5
15117: PPUSH
15118: CALL_OW 235
// SetAreaMapShow ( parking_marea , 0 ) ;
15122: LD_INT 12
15124: PPUSH
15125: LD_INT 0
15127: PPUSH
15128: CALL_OW 424
// PlaceUnitArea ( ar_mechanic , mechanic_spawn , false ) ;
15132: LD_EXP 46
15136: PPUSH
15137: LD_INT 11
15139: PPUSH
15140: LD_INT 0
15142: PPUSH
15143: CALL_OW 49
// PlaceUnitArea ( ar_mechanic_friend , mechanic_spawn , false ) ;
15147: LD_EXP 47
15151: PPUSH
15152: LD_INT 11
15154: PPUSH
15155: LD_INT 0
15157: PPUSH
15158: CALL_OW 49
// ComMoveToArea ( [ ar_mechanic , ar_mechanic_friend ] , parking_marea ) ;
15162: LD_EXP 46
15166: PUSH
15167: LD_EXP 47
15171: PUSH
15172: EMPTY
15173: LIST
15174: LIST
15175: PPUSH
15176: LD_INT 12
15178: PPUSH
15179: CALL_OW 113
// AddComEnterUnit ( ar_mechanic , cargo ) ;
15183: LD_EXP 46
15187: PPUSH
15188: LD_VAR 0 3
15192: PPUSH
15193: CALL_OW 180
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
15197: LD_EXP 46
15201: PUSH
15202: LD_EXP 47
15206: PUSH
15207: EMPTY
15208: LIST
15209: LIST
15210: PPUSH
15211: LD_INT 209
15213: PPUSH
15214: LD_INT 178
15216: PPUSH
15217: CALL_OW 171
// escaped := 0 ;
15221: LD_ADDR_VAR 0 5
15225: PUSH
15226: LD_INT 0
15228: ST_TO_ADDR
// while ( true ) do
15229: LD_INT 1
15231: IFFALSE 15447
// begin wait ( 0 0$1 ) ;
15233: LD_INT 35
15235: PPUSH
15236: CALL_OW 67
// if not HasTask ( ar_mechanic ) or not HasTask ( ar_mechanic_friend ) then
15240: LD_EXP 46
15244: PPUSH
15245: CALL_OW 314
15249: NOT
15250: PUSH
15251: LD_EXP 47
15255: PPUSH
15256: CALL_OW 314
15260: NOT
15261: OR
15262: IFFALSE 15288
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
15264: LD_EXP 46
15268: PUSH
15269: LD_EXP 47
15273: PUSH
15274: EMPTY
15275: LIST
15276: LIST
15277: PPUSH
15278: LD_INT 209
15280: PPUSH
15281: LD_INT 178
15283: PPUSH
15284: CALL_OW 171
// if IsInArea ( ar_mechanic , escape_area ) then
15288: LD_EXP 46
15292: PPUSH
15293: LD_INT 10
15295: PPUSH
15296: CALL_OW 308
15300: IFFALSE 15325
// begin RemoveUnit ( ar_mechanic ) ;
15302: LD_EXP 46
15306: PPUSH
15307: CALL_OW 64
// escaped := escaped + 1 ;
15311: LD_ADDR_VAR 0 5
15315: PUSH
15316: LD_VAR 0 5
15320: PUSH
15321: LD_INT 1
15323: PLUS
15324: ST_TO_ADDR
// end ; if IsInArea ( ar_mechanic_friend , escape_area ) then
15325: LD_EXP 47
15329: PPUSH
15330: LD_INT 10
15332: PPUSH
15333: CALL_OW 308
15337: IFFALSE 15362
// begin RemoveUnit ( ar_mechanic_friend ) ;
15339: LD_EXP 47
15343: PPUSH
15344: CALL_OW 64
// escaped := escaped + 1 ;
15348: LD_ADDR_VAR 0 5
15352: PUSH
15353: LD_VAR 0 5
15357: PUSH
15358: LD_INT 1
15360: PLUS
15361: ST_TO_ADDR
// end ; if IsInArea ( cargo , escape_area ) then
15362: LD_VAR 0 3
15366: PPUSH
15367: LD_INT 10
15369: PPUSH
15370: CALL_OW 308
15374: IFFALSE 15385
// RemoveUnit ( cargo ) ;
15376: LD_VAR 0 3
15380: PPUSH
15381: CALL_OW 64
// if not IsPlaced ( ar_mechanic ) and escaped >= 2 then
15385: LD_EXP 46
15389: PPUSH
15390: CALL_OW 305
15394: NOT
15395: PUSH
15396: LD_VAR 0 5
15400: PUSH
15401: LD_INT 2
15403: GREATEREQUAL
15404: AND
15405: IFFALSE 15409
// break ;
15407: GO 15447
// if not IsPlaced ( ar_mechanic ) and not IsPlaced ( ar_mechanic_friend ) and escaped < 2 then
15409: LD_EXP 46
15413: PPUSH
15414: CALL_OW 305
15418: NOT
15419: PUSH
15420: LD_EXP 47
15424: PPUSH
15425: CALL_OW 305
15429: NOT
15430: AND
15431: PUSH
15432: LD_VAR 0 5
15436: PUSH
15437: LD_INT 2
15439: LESS
15440: AND
15441: IFFALSE 15445
// exit ;
15443: GO 15625
// end ;
15445: GO 15229
// wait ( 0 0$2 ) ;
15447: LD_INT 70
15449: PPUSH
15450: CALL_OW 67
// SayRadio ( ar_mechanic , D7a-Ar1-1 ) ;
15454: LD_EXP 46
15458: PPUSH
15459: LD_STRING D7a-Ar1-1
15461: PPUSH
15462: CALL_OW 94
// tmp := [ [ 129 , 10 ] , [ 103 , 6 ] , [ 148 , 47 ] , [ 155 , 16 ] ] ;
15466: LD_ADDR_VAR 0 4
15470: PUSH
15471: LD_INT 129
15473: PUSH
15474: LD_INT 10
15476: PUSH
15477: EMPTY
15478: LIST
15479: LIST
15480: PUSH
15481: LD_INT 103
15483: PUSH
15484: LD_INT 6
15486: PUSH
15487: EMPTY
15488: LIST
15489: LIST
15490: PUSH
15491: LD_INT 148
15493: PUSH
15494: LD_INT 47
15496: PUSH
15497: EMPTY
15498: LIST
15499: LIST
15500: PUSH
15501: LD_INT 155
15503: PUSH
15504: LD_INT 16
15506: PUSH
15507: EMPTY
15508: LIST
15509: LIST
15510: PUSH
15511: EMPTY
15512: LIST
15513: LIST
15514: LIST
15515: LIST
15516: ST_TO_ADDR
// if Difficulty = 1 then
15517: LD_OWVAR 67
15521: PUSH
15522: LD_INT 1
15524: EQUAL
15525: IFFALSE 15562
// tmp := tmp ^ [ [ 78 , 7 ] , [ 104 , 43 ] ] ;
15527: LD_ADDR_VAR 0 4
15531: PUSH
15532: LD_VAR 0 4
15536: PUSH
15537: LD_INT 78
15539: PUSH
15540: LD_INT 7
15542: PUSH
15543: EMPTY
15544: LIST
15545: LIST
15546: PUSH
15547: LD_INT 104
15549: PUSH
15550: LD_INT 43
15552: PUSH
15553: EMPTY
15554: LIST
15555: LIST
15556: PUSH
15557: EMPTY
15558: LIST
15559: LIST
15560: ADD
15561: ST_TO_ADDR
// for i in tmp do
15562: LD_ADDR_VAR 0 2
15566: PUSH
15567: LD_VAR 0 4
15571: PUSH
15572: FOR_IN
15573: IFFALSE 15606
// PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 9 ) ;
15575: LD_VAR 0 2
15579: PUSH
15580: LD_INT 1
15582: ARRAY
15583: PPUSH
15584: LD_VAR 0 2
15588: PUSH
15589: LD_INT 2
15591: ARRAY
15592: PPUSH
15593: LD_INT 1
15595: PPUSH
15596: LD_INT 9
15598: NEG
15599: PPUSH
15600: CALL_OW 330
15604: GO 15572
15606: POP
15607: POP
// SetAchievement ( ACH_FRIEND ) ;
15608: LD_STRING ACH_FRIEND
15610: PPUSH
15611: CALL_OW 543
// CenterOnXY ( 129 , 10 ) ;
15615: LD_INT 129
15617: PPUSH
15618: LD_INT 10
15620: PPUSH
15621: CALL_OW 84
// end ;
15625: PPOPN 5
15627: END
// every 0 0$1 trigger game_time - 10 10$00 <= tick do
15628: LD_EXP 15
15632: PUSH
15633: LD_INT 21000
15635: MINUS
15636: PUSH
15637: LD_OWVAR 1
15641: LESSEQUAL
15642: IFFALSE 15682
15644: GO 15646
15646: DISABLE
// begin powell_warn := true ;
15647: LD_ADDR_EXP 16
15651: PUSH
15652: LD_INT 1
15654: ST_TO_ADDR
// DialogueOn ;
15655: CALL_OW 6
// SayRadio ( Powell , D9-Pow-1 ) ;
15659: LD_EXP 30
15663: PPUSH
15664: LD_STRING D9-Pow-1
15666: PPUSH
15667: CALL_OW 94
// dwait ( 0 0$0.3 ) ;
15671: LD_INT 10
15673: PPUSH
15674: CALL_OW 68
// DialogueOff ;
15678: CALL_OW 7
// end ;
15682: END
// every 0 0$1 trigger game_time <= tick do
15683: LD_EXP 15
15687: PUSH
15688: LD_OWVAR 1
15692: LESSEQUAL
15693: IFFALSE 15732
15695: GO 15697
15697: DISABLE
// begin DialogueOn ;
15698: CALL_OW 6
// SayRadio ( Powell , D9a-Pow-1 ) ;
15702: LD_EXP 30
15706: PPUSH
15707: LD_STRING D9a-Pow-1
15709: PPUSH
15710: CALL_OW 94
// dwait ( 0 0$2 ) ;
15714: LD_INT 70
15716: PPUSH
15717: CALL_OW 68
// DialogueOff ;
15721: CALL_OW 7
// YouLost ( Command ) ;
15725: LD_STRING Command
15727: PPUSH
15728: CALL_OW 104
// end ;
15732: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_warehouse ] ] ) = 0 and IsOk ( JMM ) do
15733: LD_INT 22
15735: PUSH
15736: LD_INT 2
15738: PUSH
15739: EMPTY
15740: LIST
15741: LIST
15742: PUSH
15743: LD_INT 30
15745: PUSH
15746: LD_INT 1
15748: PUSH
15749: EMPTY
15750: LIST
15751: LIST
15752: PUSH
15753: EMPTY
15754: LIST
15755: LIST
15756: PPUSH
15757: CALL_OW 69
15761: PUSH
15762: LD_INT 0
15764: EQUAL
15765: PUSH
15766: LD_EXP 21
15770: PPUSH
15771: CALL_OW 302
15775: AND
15776: IFFALSE 15824
15778: GO 15780
15780: DISABLE
// begin case Query ( QEndMission ) of 1 :
15781: LD_STRING QEndMission
15783: PPUSH
15784: CALL_OW 97
15788: PUSH
15789: LD_INT 1
15791: DOUBLE
15792: EQUAL
15793: IFTRUE 15797
15795: GO 15808
15797: POP
// end_the_mission_allowed := true ; 2 :
15798: LD_ADDR_OWVAR 57
15802: PUSH
15803: LD_INT 1
15805: ST_TO_ADDR
15806: GO 15824
15808: LD_INT 2
15810: DOUBLE
15811: EQUAL
15812: IFTRUE 15816
15814: GO 15823
15816: POP
// EndMission ; end ;
15817: CALL 15832 0 0
15821: GO 15824
15823: POP
// end ;
15824: END
// on EndTheMissionRaised ( p ) do begin EndMission ;
15825: CALL 15832 0 0
// end ;
15829: PPOPN 1
15831: END
// function EndMission ; var tmp , m1 , m2 , m3 ; begin
15832: LD_INT 0
15834: PPUSH
15835: PPUSH
15836: PPUSH
15837: PPUSH
15838: PPUSH
// m1 := false ;
15839: LD_ADDR_VAR 0 3
15843: PUSH
15844: LD_INT 0
15846: ST_TO_ADDR
// m2 := false ;
15847: LD_ADDR_VAR 0 4
15851: PUSH
15852: LD_INT 0
15854: ST_TO_ADDR
// m3 := false ;
15855: LD_ADDR_VAR 0 5
15859: PUSH
15860: LD_INT 0
15862: ST_TO_ADDR
// if not am_veh_consturcted then
15863: LD_EXP 20
15867: NOT
15868: IFFALSE 15877
// SetAchievement ( ACH_ARABTECH ) ;
15870: LD_STRING ACH_ARABTECH
15872: PPUSH
15873: CALL_OW 543
// if tick < [ 120 120$00 , 100 100$00 , 95 95$00 , 92 92$00 ] [ Difficulty ] then
15877: LD_OWVAR 1
15881: PUSH
15882: LD_INT 252000
15884: PUSH
15885: LD_INT 210000
15887: PUSH
15888: LD_INT 199500
15890: PUSH
15891: LD_INT 193200
15893: PUSH
15894: EMPTY
15895: LIST
15896: LIST
15897: LIST
15898: LIST
15899: PUSH
15900: LD_OWVAR 67
15904: ARRAY
15905: LESS
15906: IFFALSE 15928
// begin m3 := true ;
15908: LD_ADDR_VAR 0 5
15912: PUSH
15913: LD_INT 1
15915: ST_TO_ADDR
// AddMedal ( Time1 , 1 ) ;
15916: LD_STRING Time1
15918: PPUSH
15919: LD_INT 1
15921: PPUSH
15922: CALL_OW 101
// end else
15926: GO 15959
// if not powell_warn then
15928: LD_EXP 16
15932: NOT
15933: IFFALSE 15948
// AddMedal ( Time1 , - 1 ) else
15935: LD_STRING Time1
15937: PPUSH
15938: LD_INT 1
15940: NEG
15941: PPUSH
15942: CALL_OW 101
15946: GO 15959
// AddMedal ( Time1 , - 2 ) ;
15948: LD_STRING Time1
15950: PPUSH
15951: LD_INT 2
15953: NEG
15954: PPUSH
15955: CALL_OW 101
// if loses_counter >= [ 5 , 4 , 3 , 3 ] [ Difficulty ] then
15959: LD_EXP 17
15963: PUSH
15964: LD_INT 5
15966: PUSH
15967: LD_INT 4
15969: PUSH
15970: LD_INT 3
15972: PUSH
15973: LD_INT 3
15975: PUSH
15976: EMPTY
15977: LIST
15978: LIST
15979: LIST
15980: LIST
15981: PUSH
15982: LD_OWVAR 67
15986: ARRAY
15987: GREATEREQUAL
15988: IFFALSE 16003
// AddMedal ( Destroy , - 2 ) else
15990: LD_STRING Destroy
15992: PPUSH
15993: LD_INT 2
15995: NEG
15996: PPUSH
15997: CALL_OW 101
16001: GO 16136
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 25 then
16003: LD_INT 22
16005: PUSH
16006: LD_INT 2
16008: PUSH
16009: EMPTY
16010: LIST
16011: LIST
16012: PUSH
16013: LD_INT 21
16015: PUSH
16016: LD_INT 3
16018: PUSH
16019: EMPTY
16020: LIST
16021: LIST
16022: PUSH
16023: LD_INT 50
16025: PUSH
16026: EMPTY
16027: LIST
16028: PUSH
16029: EMPTY
16030: LIST
16031: LIST
16032: LIST
16033: PPUSH
16034: CALL_OW 69
16038: PUSH
16039: LD_INT 25
16041: GREATEREQUAL
16042: IFFALSE 16057
// AddMedal ( Destroy , - 1 ) else
16044: LD_STRING Destroy
16046: PPUSH
16047: LD_INT 1
16049: NEG
16050: PPUSH
16051: CALL_OW 101
16055: GO 16136
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 15 then
16057: LD_INT 22
16059: PUSH
16060: LD_INT 2
16062: PUSH
16063: EMPTY
16064: LIST
16065: LIST
16066: PUSH
16067: LD_INT 21
16069: PUSH
16070: LD_INT 3
16072: PUSH
16073: EMPTY
16074: LIST
16075: LIST
16076: PUSH
16077: LD_INT 50
16079: PUSH
16080: EMPTY
16081: LIST
16082: PUSH
16083: EMPTY
16084: LIST
16085: LIST
16086: LIST
16087: PPUSH
16088: CALL_OW 69
16092: PUSH
16093: LD_INT 15
16095: GREATEREQUAL
16096: IFFALSE 16118
// begin m1 := true ;
16098: LD_ADDR_VAR 0 3
16102: PUSH
16103: LD_INT 1
16105: ST_TO_ADDR
// AddMedal ( Destroy , 1 ) ;
16106: LD_STRING Destroy
16108: PPUSH
16109: LD_INT 1
16111: PPUSH
16112: CALL_OW 101
// end else
16116: GO 16136
// begin m1 := true ;
16118: LD_ADDR_VAR 0 3
16122: PUSH
16123: LD_INT 1
16125: ST_TO_ADDR
// AddMedal ( Destroy , 2 ) ;
16126: LD_STRING Destroy
16128: PPUSH
16129: LD_INT 2
16131: PPUSH
16132: CALL_OW 101
// end ; SaveVariable ( artifact_get , 11_artifact_captured ) ;
16136: LD_EXP 13
16140: PPUSH
16141: LD_STRING 11_artifact_captured
16143: PPUSH
16144: CALL_OW 39
// if artifact_get then
16148: LD_EXP 13
16152: IFFALSE 16174
// begin m2 := true ;
16154: LD_ADDR_VAR 0 4
16158: PUSH
16159: LD_INT 1
16161: ST_TO_ADDR
// AddMedal ( Artefact , 1 ) ;
16162: LD_STRING Artefact
16164: PPUSH
16165: LD_INT 1
16167: PPUSH
16168: CALL_OW 101
// end else
16172: GO 16185
// AddMedal ( Artefact , - 1 ) ;
16174: LD_STRING Artefact
16176: PPUSH
16177: LD_INT 1
16179: NEG
16180: PPUSH
16181: CALL_OW 101
// if m1 and m2 and m3 and Difficulty >= 3 then
16185: LD_VAR 0 3
16189: PUSH
16190: LD_VAR 0 4
16194: AND
16195: PUSH
16196: LD_VAR 0 5
16200: AND
16201: PUSH
16202: LD_OWVAR 67
16206: PUSH
16207: LD_INT 3
16209: GREATEREQUAL
16210: AND
16211: IFFALSE 16223
// SetAchievementEX ( ACH_AMER , 11 ) ;
16213: LD_STRING ACH_AMER
16215: PPUSH
16216: LD_INT 11
16218: PPUSH
16219: CALL_OW 564
// if m1 and m2 and m3 and loses_counter = 0 then
16223: LD_VAR 0 3
16227: PUSH
16228: LD_VAR 0 4
16232: AND
16233: PUSH
16234: LD_VAR 0 5
16238: AND
16239: PUSH
16240: LD_EXP 17
16244: PUSH
16245: LD_INT 0
16247: EQUAL
16248: AND
16249: IFFALSE 16265
// begin wait ( 3 ) ;
16251: LD_INT 3
16253: PPUSH
16254: CALL_OW 67
// SetAchievement ( ACH_GENERAL ) ;
16258: LD_STRING ACH_GENERAL
16260: PPUSH
16261: CALL_OW 543
// end ; if tick <= 100 100$00 then
16265: LD_OWVAR 1
16269: PUSH
16270: LD_INT 210000
16272: LESSEQUAL
16273: IFFALSE 16289
// begin wait ( 3 ) ;
16275: LD_INT 3
16277: PPUSH
16278: CALL_OW 67
// SetAchievement ( ACH_ASPEED_11 ) ;
16282: LD_STRING ACH_ASPEED_11
16284: PPUSH
16285: CALL_OW 543
// end ; GiveMedals ( MAIN ) ;
16289: LD_STRING MAIN
16291: PPUSH
16292: CALL_OW 102
// selected := UnitFilter ( selected , [ f_alive ] ) ;
16296: LD_ADDR_EXP 19
16300: PUSH
16301: LD_EXP 19
16305: PPUSH
16306: LD_INT 51
16308: PUSH
16309: EMPTY
16310: LIST
16311: PPUSH
16312: CALL_OW 72
16316: ST_TO_ADDR
// tmp := JMM ^ selected ;
16317: LD_ADDR_VAR 0 2
16321: PUSH
16322: LD_EXP 21
16326: PUSH
16327: LD_EXP 19
16331: ADD
16332: ST_TO_ADDR
// RewardPeople ( tmp ) ;
16333: LD_VAR 0 2
16337: PPUSH
16338: CALL_OW 43
// SaveCharacters ( tmp diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , 11c_others ) ;
16342: LD_VAR 0 2
16346: PUSH
16347: LD_EXP 21
16351: PUSH
16352: LD_EXP 22
16356: PUSH
16357: LD_EXP 23
16361: PUSH
16362: LD_EXP 24
16366: PUSH
16367: LD_EXP 25
16371: PUSH
16372: LD_EXP 26
16376: PUSH
16377: LD_EXP 27
16381: PUSH
16382: LD_EXP 28
16386: PUSH
16387: LD_EXP 29
16391: PUSH
16392: LD_EXP 31
16396: PUSH
16397: LD_EXP 32
16401: PUSH
16402: LD_EXP 33
16406: PUSH
16407: LD_EXP 34
16411: PUSH
16412: EMPTY
16413: LIST
16414: LIST
16415: LIST
16416: LIST
16417: LIST
16418: LIST
16419: LIST
16420: LIST
16421: LIST
16422: LIST
16423: LIST
16424: LIST
16425: LIST
16426: DIFF
16427: PPUSH
16428: LD_STRING 11c_others
16430: PPUSH
16431: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
16435: LD_EXP 21
16439: PPUSH
16440: LD_EXP 3
16444: PUSH
16445: LD_STRING JMM
16447: STR
16448: PPUSH
16449: CALL_OW 38
// if Lisa then
16453: LD_EXP 22
16457: IFFALSE 16477
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
16459: LD_EXP 22
16463: PPUSH
16464: LD_EXP 3
16468: PUSH
16469: LD_STRING Lisa
16471: STR
16472: PPUSH
16473: CALL_OW 38
// if Donaldson then
16477: LD_EXP 23
16481: IFFALSE 16501
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
16483: LD_EXP 23
16487: PPUSH
16488: LD_EXP 3
16492: PUSH
16493: LD_STRING Donaldson
16495: STR
16496: PPUSH
16497: CALL_OW 38
// if Bobby then
16501: LD_EXP 24
16505: IFFALSE 16525
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
16507: LD_EXP 24
16511: PPUSH
16512: LD_EXP 3
16516: PUSH
16517: LD_STRING Bobby
16519: STR
16520: PPUSH
16521: CALL_OW 38
// if Cyrus then
16525: LD_EXP 25
16529: IFFALSE 16549
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
16531: LD_EXP 25
16535: PPUSH
16536: LD_EXP 3
16540: PUSH
16541: LD_STRING Cyrus
16543: STR
16544: PPUSH
16545: CALL_OW 38
// if Denis then
16549: LD_EXP 26
16553: IFFALSE 16573
// SaveCharacters ( Denis , mission_prefix & Denis ) ;
16555: LD_EXP 26
16559: PPUSH
16560: LD_EXP 3
16564: PUSH
16565: LD_STRING Denis
16567: STR
16568: PPUSH
16569: CALL_OW 38
// if Brown then
16573: LD_EXP 27
16577: IFFALSE 16597
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
16579: LD_EXP 27
16583: PPUSH
16584: LD_EXP 3
16588: PUSH
16589: LD_STRING Brown
16591: STR
16592: PPUSH
16593: CALL_OW 38
// if Gladstone then
16597: LD_EXP 28
16601: IFFALSE 16621
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
16603: LD_EXP 28
16607: PPUSH
16608: LD_EXP 3
16612: PUSH
16613: LD_STRING Gladstone
16615: STR
16616: PPUSH
16617: CALL_OW 38
// if Houten then
16621: LD_EXP 29
16625: IFFALSE 16645
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
16627: LD_EXP 29
16631: PPUSH
16632: LD_EXP 3
16636: PUSH
16637: LD_STRING Houten
16639: STR
16640: PPUSH
16641: CALL_OW 38
// if Cornel then
16645: LD_EXP 31
16649: IFFALSE 16669
// SaveCharacters ( Cornel , mission_prefix & Cornell ) ;
16651: LD_EXP 31
16655: PPUSH
16656: LD_EXP 3
16660: PUSH
16661: LD_STRING Cornell
16663: STR
16664: PPUSH
16665: CALL_OW 38
// if Gary then
16669: LD_EXP 32
16673: IFFALSE 16693
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
16675: LD_EXP 32
16679: PPUSH
16680: LD_EXP 3
16684: PUSH
16685: LD_STRING Gary
16687: STR
16688: PPUSH
16689: CALL_OW 38
// if Frank then
16693: LD_EXP 33
16697: IFFALSE 16717
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
16699: LD_EXP 33
16703: PPUSH
16704: LD_EXP 3
16708: PUSH
16709: LD_STRING Frank
16711: STR
16712: PPUSH
16713: CALL_OW 38
// if Kikuchi then
16717: LD_EXP 34
16721: IFFALSE 16741
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
16723: LD_EXP 34
16727: PPUSH
16728: LD_EXP 3
16732: PUSH
16733: LD_STRING Kikuchi
16735: STR
16736: PPUSH
16737: CALL_OW 38
// YouWin ;
16741: CALL_OW 103
// end ;
16745: LD_VAR 0 1
16749: RET
// export function CanSayRand ( side ) ; begin
16750: LD_INT 0
16752: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16753: LD_ADDR_VAR 0 2
16757: PUSH
16758: LD_INT 52
16760: PUSH
16761: EMPTY
16762: LIST
16763: PUSH
16764: LD_INT 22
16766: PUSH
16767: LD_VAR 0 1
16771: PUSH
16772: EMPTY
16773: LIST
16774: LIST
16775: PUSH
16776: LD_INT 2
16778: PUSH
16779: LD_INT 25
16781: PUSH
16782: LD_INT 1
16784: PUSH
16785: EMPTY
16786: LIST
16787: LIST
16788: PUSH
16789: LD_INT 25
16791: PUSH
16792: LD_INT 2
16794: PUSH
16795: EMPTY
16796: LIST
16797: LIST
16798: PUSH
16799: LD_INT 25
16801: PUSH
16802: LD_INT 3
16804: PUSH
16805: EMPTY
16806: LIST
16807: LIST
16808: PUSH
16809: LD_INT 25
16811: PUSH
16812: LD_INT 4
16814: PUSH
16815: EMPTY
16816: LIST
16817: LIST
16818: PUSH
16819: EMPTY
16820: LIST
16821: LIST
16822: LIST
16823: LIST
16824: LIST
16825: PUSH
16826: EMPTY
16827: LIST
16828: LIST
16829: LIST
16830: PPUSH
16831: CALL_OW 69
16835: PUSH
16836: LD_EXP 21
16840: PUSH
16841: LD_EXP 33
16845: PUSH
16846: LD_EXP 22
16850: PUSH
16851: LD_EXP 23
16855: PUSH
16856: LD_EXP 24
16860: PUSH
16861: LD_EXP 25
16865: PUSH
16866: LD_EXP 26
16870: PUSH
16871: LD_EXP 27
16875: PUSH
16876: LD_EXP 28
16880: PUSH
16881: LD_EXP 29
16885: PUSH
16886: LD_EXP 30
16890: PUSH
16891: LD_EXP 31
16895: PUSH
16896: LD_EXP 32
16900: PUSH
16901: LD_EXP 34
16905: PUSH
16906: EMPTY
16907: LIST
16908: LIST
16909: LIST
16910: LIST
16911: LIST
16912: LIST
16913: LIST
16914: LIST
16915: LIST
16916: LIST
16917: LIST
16918: LIST
16919: LIST
16920: LIST
16921: DIFF
16922: ST_TO_ADDR
// end ;
16923: LD_VAR 0 2
16927: RET
// export function SayRand ( sex , dial ) ; begin
16928: LD_INT 0
16930: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16931: LD_ADDR_VAR 0 3
16935: PUSH
16936: LD_INT 52
16938: PUSH
16939: EMPTY
16940: LIST
16941: PUSH
16942: LD_INT 22
16944: PUSH
16945: LD_INT 1
16947: PUSH
16948: EMPTY
16949: LIST
16950: LIST
16951: PUSH
16952: LD_INT 26
16954: PUSH
16955: LD_VAR 0 1
16959: PUSH
16960: EMPTY
16961: LIST
16962: LIST
16963: PUSH
16964: LD_INT 2
16966: PUSH
16967: LD_INT 25
16969: PUSH
16970: LD_INT 1
16972: PUSH
16973: EMPTY
16974: LIST
16975: LIST
16976: PUSH
16977: LD_INT 25
16979: PUSH
16980: LD_INT 2
16982: PUSH
16983: EMPTY
16984: LIST
16985: LIST
16986: PUSH
16987: LD_INT 25
16989: PUSH
16990: LD_INT 3
16992: PUSH
16993: EMPTY
16994: LIST
16995: LIST
16996: PUSH
16997: LD_INT 25
16999: PUSH
17000: LD_INT 4
17002: PUSH
17003: EMPTY
17004: LIST
17005: LIST
17006: PUSH
17007: EMPTY
17008: LIST
17009: LIST
17010: LIST
17011: LIST
17012: LIST
17013: PUSH
17014: EMPTY
17015: LIST
17016: LIST
17017: LIST
17018: LIST
17019: PPUSH
17020: CALL_OW 69
17024: PUSH
17025: LD_EXP 21
17029: PUSH
17030: LD_EXP 33
17034: PUSH
17035: LD_EXP 22
17039: PUSH
17040: LD_EXP 23
17044: PUSH
17045: LD_EXP 24
17049: PUSH
17050: LD_EXP 25
17054: PUSH
17055: LD_EXP 26
17059: PUSH
17060: LD_EXP 27
17064: PUSH
17065: LD_EXP 28
17069: PUSH
17070: LD_EXP 29
17074: PUSH
17075: LD_EXP 30
17079: PUSH
17080: LD_EXP 31
17084: PUSH
17085: LD_EXP 32
17089: PUSH
17090: LD_EXP 34
17094: PUSH
17095: EMPTY
17096: LIST
17097: LIST
17098: LIST
17099: LIST
17100: LIST
17101: LIST
17102: LIST
17103: LIST
17104: LIST
17105: LIST
17106: LIST
17107: LIST
17108: LIST
17109: LIST
17110: DIFF
17111: ST_TO_ADDR
// if not result then
17112: LD_VAR 0 3
17116: NOT
17117: IFFALSE 17121
// exit ;
17119: GO 17149
// result := result [ 1 ] ;
17121: LD_ADDR_VAR 0 3
17125: PUSH
17126: LD_VAR 0 3
17130: PUSH
17131: LD_INT 1
17133: ARRAY
17134: ST_TO_ADDR
// Say ( result , dial ) ;
17135: LD_VAR 0 3
17139: PPUSH
17140: LD_VAR 0 2
17144: PPUSH
17145: CALL_OW 88
// end ;
17149: LD_VAR 0 3
17153: RET
// export function SayRand2 ( sex , dial , filter ) ; begin
17154: LD_INT 0
17156: PPUSH
// result := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ^ filter ;
17157: LD_ADDR_VAR 0 4
17161: PUSH
17162: LD_INT 22
17164: PUSH
17165: LD_INT 1
17167: PUSH
17168: EMPTY
17169: LIST
17170: LIST
17171: PUSH
17172: LD_INT 26
17174: PUSH
17175: LD_VAR 0 1
17179: PUSH
17180: EMPTY
17181: LIST
17182: LIST
17183: PUSH
17184: LD_INT 2
17186: PUSH
17187: LD_INT 25
17189: PUSH
17190: LD_INT 1
17192: PUSH
17193: EMPTY
17194: LIST
17195: LIST
17196: PUSH
17197: LD_INT 25
17199: PUSH
17200: LD_INT 2
17202: PUSH
17203: EMPTY
17204: LIST
17205: LIST
17206: PUSH
17207: LD_INT 25
17209: PUSH
17210: LD_INT 3
17212: PUSH
17213: EMPTY
17214: LIST
17215: LIST
17216: PUSH
17217: LD_INT 25
17219: PUSH
17220: LD_INT 4
17222: PUSH
17223: EMPTY
17224: LIST
17225: LIST
17226: PUSH
17227: EMPTY
17228: LIST
17229: LIST
17230: LIST
17231: LIST
17232: LIST
17233: PUSH
17234: EMPTY
17235: LIST
17236: LIST
17237: LIST
17238: PPUSH
17239: CALL_OW 69
17243: PUSH
17244: LD_EXP 21
17248: PUSH
17249: LD_EXP 33
17253: PUSH
17254: LD_EXP 22
17258: PUSH
17259: LD_EXP 23
17263: PUSH
17264: LD_EXP 24
17268: PUSH
17269: LD_EXP 25
17273: PUSH
17274: LD_EXP 26
17278: PUSH
17279: LD_EXP 27
17283: PUSH
17284: LD_EXP 28
17288: PUSH
17289: LD_EXP 29
17293: PUSH
17294: LD_EXP 30
17298: PUSH
17299: LD_EXP 31
17303: PUSH
17304: LD_EXP 32
17308: PUSH
17309: LD_EXP 34
17313: PUSH
17314: EMPTY
17315: LIST
17316: LIST
17317: LIST
17318: LIST
17319: LIST
17320: LIST
17321: LIST
17322: LIST
17323: LIST
17324: LIST
17325: LIST
17326: LIST
17327: LIST
17328: LIST
17329: PUSH
17330: LD_VAR 0 3
17334: ADD
17335: DIFF
17336: ST_TO_ADDR
// if not result then
17337: LD_VAR 0 4
17341: NOT
17342: IFFALSE 17346
// exit ;
17344: GO 17374
// result := result [ 1 ] ;
17346: LD_ADDR_VAR 0 4
17350: PUSH
17351: LD_VAR 0 4
17355: PUSH
17356: LD_INT 1
17358: ARRAY
17359: ST_TO_ADDR
// Say ( result , dial ) ;
17360: LD_VAR 0 4
17364: PPUSH
17365: LD_VAR 0 2
17369: PPUSH
17370: CALL_OW 88
// end ; end_of_file
17374: LD_VAR 0 4
17378: RET
// export function CustomEvent ( event ) ; begin
17379: LD_INT 0
17381: PPUSH
// end ;
17382: LD_VAR 0 2
17386: RET
// on ArtifactLoaded ( cargo , artifact ) do begin if GetSide ( cargo ) = 1 then
17387: LD_VAR 0 1
17391: PPUSH
17392: CALL_OW 255
17396: PUSH
17397: LD_INT 1
17399: EQUAL
17400: IFFALSE 17410
// artifact_get := true ;
17402: LD_ADDR_EXP 13
17406: PUSH
17407: LD_INT 1
17409: ST_TO_ADDR
// if GetSide ( cargo ) = 2 then
17410: LD_VAR 0 1
17414: PPUSH
17415: CALL_OW 255
17419: PUSH
17420: LD_INT 2
17422: EQUAL
17423: IFFALSE 17441
// begin artifact_get := false ;
17425: LD_ADDR_EXP 13
17429: PUSH
17430: LD_INT 0
17432: ST_TO_ADDR
// artifact_stolen := true ;
17433: LD_ADDR_EXP 12
17437: PUSH
17438: LD_INT 1
17440: ST_TO_ADDR
// end ; artifact_oncargo := true ;
17441: LD_ADDR_EXP 14
17445: PUSH
17446: LD_INT 1
17448: ST_TO_ADDR
// end ;
17449: PPOPN 2
17451: END
// on ArtifactUnloaded ( cargo , artifact ) do begin artifact_oncargo := false ;
17452: LD_ADDR_EXP 14
17456: PUSH
17457: LD_INT 0
17459: ST_TO_ADDR
// end ;
17460: PPOPN 2
17462: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
17463: LD_VAR 0 1
17467: PPUSH
17468: CALL 106230 0 1
// if un = JMM then
17472: LD_VAR 0 1
17476: PUSH
17477: LD_EXP 21
17481: EQUAL
17482: IFFALSE 17493
// begin YouLost ( JMM ) ;
17484: LD_STRING JMM
17486: PPUSH
17487: CALL_OW 104
// exit ;
17491: GO 17625
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) then
17493: LD_VAR 0 1
17497: PUSH
17498: LD_INT 22
17500: PUSH
17501: LD_INT 1
17503: PUSH
17504: EMPTY
17505: LIST
17506: LIST
17507: PUSH
17508: LD_INT 21
17510: PUSH
17511: LD_INT 1
17513: PUSH
17514: EMPTY
17515: LIST
17516: LIST
17517: PUSH
17518: LD_INT 2
17520: PUSH
17521: LD_INT 25
17523: PUSH
17524: LD_INT 1
17526: PUSH
17527: EMPTY
17528: LIST
17529: LIST
17530: PUSH
17531: LD_INT 25
17533: PUSH
17534: LD_INT 2
17536: PUSH
17537: EMPTY
17538: LIST
17539: LIST
17540: PUSH
17541: LD_INT 25
17543: PUSH
17544: LD_INT 3
17546: PUSH
17547: EMPTY
17548: LIST
17549: LIST
17550: PUSH
17551: LD_INT 25
17553: PUSH
17554: LD_INT 4
17556: PUSH
17557: EMPTY
17558: LIST
17559: LIST
17560: PUSH
17561: LD_INT 25
17563: PUSH
17564: LD_INT 5
17566: PUSH
17567: EMPTY
17568: LIST
17569: LIST
17570: PUSH
17571: LD_INT 25
17573: PUSH
17574: LD_INT 8
17576: PUSH
17577: EMPTY
17578: LIST
17579: LIST
17580: PUSH
17581: EMPTY
17582: LIST
17583: LIST
17584: LIST
17585: LIST
17586: LIST
17587: LIST
17588: LIST
17589: PUSH
17590: EMPTY
17591: LIST
17592: LIST
17593: LIST
17594: PPUSH
17595: CALL_OW 69
17599: IN
17600: IFFALSE 17616
// loses_counter := loses_counter + 1 ;
17602: LD_ADDR_EXP 17
17606: PUSH
17607: LD_EXP 17
17611: PUSH
17612: LD_INT 1
17614: PLUS
17615: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
17616: LD_VAR 0 1
17620: PPUSH
17621: CALL 46088 0 1
// end ;
17625: PPOPN 1
17627: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
17628: LD_VAR 0 1
17632: PPUSH
17633: LD_VAR 0 2
17637: PPUSH
17638: CALL 48420 0 2
// end ;
17642: PPOPN 2
17644: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
17645: LD_VAR 0 1
17649: PPUSH
17650: CALL 47729 0 1
// end ;
17654: PPOPN 1
17656: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
17657: LD_VAR 0 1
17661: PPUSH
17662: LD_VAR 0 2
17666: PPUSH
17667: LD_VAR 0 3
17671: PPUSH
17672: LD_VAR 0 4
17676: PPUSH
17677: LD_VAR 0 5
17681: PPUSH
17682: CALL 45404 0 5
// end ;
17686: PPOPN 5
17688: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
17689: LD_VAR 0 1
17693: PPUSH
17694: LD_VAR 0 2
17698: PPUSH
17699: CALL 106350 0 2
// if GetNation ( vehicle ) = nation_american then
17703: LD_VAR 0 1
17707: PPUSH
17708: CALL_OW 248
17712: PUSH
17713: LD_INT 1
17715: EQUAL
17716: IFFALSE 17726
// am_veh_consturcted := true ;
17718: LD_ADDR_EXP 20
17722: PUSH
17723: LD_INT 1
17725: ST_TO_ADDR
// MCE_VehicleConstructed ( vehicle , factory ) ;
17726: LD_VAR 0 1
17730: PPUSH
17731: LD_VAR 0 2
17735: PPUSH
17736: CALL 44957 0 2
// end ;
17740: PPOPN 2
17742: END
// on UnitKamikazed ( unit ) do begin if GetType ( unit ) = unit_vehicle then
17743: LD_VAR 0 1
17747: PPUSH
17748: CALL_OW 247
17752: PUSH
17753: LD_INT 2
17755: EQUAL
17756: IFFALSE 17760
// exit ;
17758: GO 17777
// if not kamikazed then
17760: LD_EXP 11
17764: NOT
17765: IFFALSE 17777
// kamikazed := unit ;
17767: LD_ADDR_EXP 11
17771: PUSH
17772: LD_VAR 0 1
17776: ST_TO_ADDR
// end ;
17777: PPOPN 1
17779: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do var i , tmp ;
17780: LD_INT 0
17782: PPUSH
17783: PPUSH
// begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
17784: LD_VAR 0 1
17788: PPUSH
17789: LD_VAR 0 2
17793: PPUSH
17794: LD_VAR 0 3
17798: PPUSH
17799: LD_VAR 0 4
17803: PPUSH
17804: CALL 44795 0 4
// end ;
17808: PPOPN 6
17810: END
// on BuildingCaptured ( building , side , capturning_unit ) do var i ;
17811: LD_INT 0
17813: PPUSH
// begin if building = ar_dep_n then
17814: LD_VAR 0 1
17818: PUSH
17819: LD_INT 94
17821: EQUAL
17822: IFFALSE 17874
// begin for i := 1 to 3 do
17824: LD_ADDR_VAR 0 4
17828: PUSH
17829: DOUBLE
17830: LD_INT 1
17832: DEC
17833: ST_TO_ADDR
17834: LD_INT 3
17836: PUSH
17837: FOR_TO
17838: IFFALSE 17872
// begin MineExplosion ( 115 + ( i * 2 ) , 6 , 1 ) ;
17840: LD_INT 115
17842: PUSH
17843: LD_VAR 0 4
17847: PUSH
17848: LD_INT 2
17850: MUL
17851: PLUS
17852: PPUSH
17853: LD_INT 6
17855: PPUSH
17856: LD_INT 1
17858: PPUSH
17859: CALL_OW 453
// wait ( 0 0$0.3 ) ;
17863: LD_INT 10
17865: PPUSH
17866: CALL_OW 67
// end ;
17870: GO 17837
17872: POP
17873: POP
// end ; MCE_BuildingCaptured ( building , side , capturning_unit ) ;
17874: LD_VAR 0 1
17878: PPUSH
17879: LD_VAR 0 2
17883: PPUSH
17884: LD_VAR 0 3
17888: PPUSH
17889: CALL 44570 0 3
// end ;
17893: PPOPN 4
17895: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
17896: LD_VAR 0 1
17900: PPUSH
17901: LD_VAR 0 2
17905: PPUSH
17906: CALL 45784 0 2
// end ;
17910: PPOPN 2
17912: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
17913: LD_VAR 0 1
17917: PPUSH
17918: LD_VAR 0 2
17922: PPUSH
17923: CALL 44264 0 2
// end ;
17927: PPOPN 2
17929: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
17930: LD_VAR 0 1
17934: PPUSH
17935: LD_VAR 0 2
17939: PPUSH
17940: CALL 44455 0 2
// end ;
17944: PPOPN 2
17946: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
17947: LD_VAR 0 1
17951: PPUSH
17952: CALL 47488 0 1
// end ;
17956: PPOPN 1
17958: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
17959: LD_VAR 0 1
17963: PPUSH
17964: LD_VAR 0 2
17968: PPUSH
17969: CALL 48715 0 2
// end ;
17973: PPOPN 2
17975: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
17976: LD_VAR 0 1
17980: PPUSH
17981: LD_VAR 0 2
17985: PPUSH
17986: LD_VAR 0 3
17990: PPUSH
17991: LD_VAR 0 4
17995: PPUSH
17996: CALL 48931 0 4
// end ;
18000: PPOPN 4
18002: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
18003: LD_VAR 0 1
18007: PPUSH
18008: CALL 106334 0 1
// end ;
18012: PPOPN 1
18014: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_ok ] , [ f_type , engine_combustion ] ] ) do var i ;
18015: LD_INT 22
18017: PUSH
18018: LD_INT 2
18020: PUSH
18021: EMPTY
18022: LIST
18023: LIST
18024: PUSH
18025: LD_INT 50
18027: PUSH
18028: EMPTY
18029: LIST
18030: PUSH
18031: LD_INT 21
18033: PUSH
18034: LD_INT 1
18036: PUSH
18037: EMPTY
18038: LIST
18039: LIST
18040: PUSH
18041: EMPTY
18042: LIST
18043: LIST
18044: LIST
18045: PPUSH
18046: CALL_OW 69
18050: IFFALSE 18134
18052: GO 18054
18054: DISABLE
18055: LD_INT 0
18057: PPUSH
// begin enable ;
18058: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_ok ] , [ f_type , engine_combustion ] ] ) do
18059: LD_ADDR_VAR 0 1
18063: PUSH
18064: LD_INT 22
18066: PUSH
18067: LD_INT 2
18069: PUSH
18070: EMPTY
18071: LIST
18072: LIST
18073: PUSH
18074: LD_INT 50
18076: PUSH
18077: EMPTY
18078: LIST
18079: PUSH
18080: LD_INT 21
18082: PUSH
18083: LD_INT 1
18085: PUSH
18086: EMPTY
18087: LIST
18088: LIST
18089: PUSH
18090: EMPTY
18091: LIST
18092: LIST
18093: LIST
18094: PPUSH
18095: CALL_OW 69
18099: PUSH
18100: FOR_IN
18101: IFFALSE 18132
// if GetFuel ( i ) < 3 then
18103: LD_VAR 0 1
18107: PPUSH
18108: CALL_OW 261
18112: PUSH
18113: LD_INT 3
18115: LESS
18116: IFFALSE 18130
// SetFuel ( i , 5 ) ;
18118: LD_VAR 0 1
18122: PPUSH
18123: LD_INT 5
18125: PPUSH
18126: CALL_OW 240
18130: GO 18100
18132: POP
18133: POP
// end ; end_of_file
18134: PPOPN 1
18136: END
// every 0 0$1 trigger game do
18137: LD_EXP 2
18141: IFFALSE 18171
18143: GO 18145
18145: DISABLE
// SpawnCrates ( [ crates_west , crates_east , crates_north_west , crates_east ] , 0 0$50 ) ;
18146: LD_INT 7
18148: PUSH
18149: LD_INT 6
18151: PUSH
18152: LD_INT 4
18154: PUSH
18155: LD_INT 6
18157: PUSH
18158: EMPTY
18159: LIST
18160: LIST
18161: LIST
18162: LIST
18163: PPUSH
18164: LD_INT 1750
18166: PPUSH
18167: CALL 18172 0 2
18171: END
// export function SpawnCrates ( areas , time ) ; var i , p ; begin
18172: LD_INT 0
18174: PPUSH
18175: PPUSH
18176: PPUSH
// if not areas then
18177: LD_VAR 0 1
18181: NOT
18182: IFFALSE 18186
// exit ;
18184: GO 18316
// repeat wait ( time ) ;
18186: LD_VAR 0 2
18190: PPUSH
18191: CALL_OW 67
// for i in areas do
18195: LD_ADDR_VAR 0 4
18199: PUSH
18200: LD_VAR 0 1
18204: PUSH
18205: FOR_IN
18206: IFFALSE 18275
// begin p := rand ( 1 , 90 ) ;
18208: LD_ADDR_VAR 0 5
18212: PUSH
18213: LD_INT 1
18215: PPUSH
18216: LD_INT 90
18218: PPUSH
18219: CALL_OW 12
18223: ST_TO_ADDR
// if Prob ( p ) then
18224: LD_VAR 0 5
18228: PPUSH
18229: CALL_OW 13
18233: IFFALSE 18273
// begin CreateCratesArea ( rand ( 2 , 5 ) , i , true ) ;
18235: LD_INT 2
18237: PPUSH
18238: LD_INT 5
18240: PPUSH
18241: CALL_OW 12
18245: PPUSH
18246: LD_VAR 0 4
18250: PPUSH
18251: LD_INT 1
18253: PPUSH
18254: CALL_OW 55
// wait ( rand ( 0 0$21 , 0 0$37 ) ) ;
18258: LD_INT 735
18260: PPUSH
18261: LD_INT 1295
18263: PPUSH
18264: CALL_OW 12
18268: PPUSH
18269: CALL_OW 67
// end ; end ;
18273: GO 18205
18275: POP
18276: POP
// time := time + 0 0$3 ;
18277: LD_ADDR_VAR 0 2
18281: PUSH
18282: LD_VAR 0 2
18286: PUSH
18287: LD_INT 105
18289: PLUS
18290: ST_TO_ADDR
// if time > 3 3$00 then
18291: LD_VAR 0 2
18295: PUSH
18296: LD_INT 6300
18298: GREATER
18299: IFFALSE 18309
// time := 0 0$40 ;
18301: LD_ADDR_VAR 0 2
18305: PUSH
18306: LD_INT 1400
18308: ST_TO_ADDR
// until not game ;
18309: LD_EXP 2
18313: NOT
18314: IFFALSE 18186
// end ;
18316: LD_VAR 0 3
18320: RET
// every 0 0$45 + 3 3$00 trigger tick < [ 40 40$00 , 35 35$00 , 30 30$00 , 25 25$00 ] [ Difficulty ] do
18321: LD_OWVAR 1
18325: PUSH
18326: LD_INT 84000
18328: PUSH
18329: LD_INT 73500
18331: PUSH
18332: LD_INT 63000
18334: PUSH
18335: LD_INT 52500
18337: PUSH
18338: EMPTY
18339: LIST
18340: LIST
18341: LIST
18342: LIST
18343: PUSH
18344: LD_OWVAR 67
18348: ARRAY
18349: LESS
18350: IFFALSE 18377
18352: GO 18354
18354: DISABLE
// begin enable ;
18355: ENABLE
// CreateCratesArea ( rand ( 1 , 5 ) , crates_west , true ) ;
18356: LD_INT 1
18358: PPUSH
18359: LD_INT 5
18361: PPUSH
18362: CALL_OW 12
18366: PPUSH
18367: LD_INT 7
18369: PPUSH
18370: LD_INT 1
18372: PPUSH
18373: CALL_OW 55
// end ; end_of_file
18377: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
18378: LD_INT 0
18380: PPUSH
18381: PPUSH
// skirmish := false ;
18382: LD_ADDR_EXP 48
18386: PUSH
18387: LD_INT 0
18389: ST_TO_ADDR
// debug_mc := false ;
18390: LD_ADDR_EXP 49
18394: PUSH
18395: LD_INT 0
18397: ST_TO_ADDR
// mc_bases := [ ] ;
18398: LD_ADDR_EXP 50
18402: PUSH
18403: EMPTY
18404: ST_TO_ADDR
// mc_sides := [ ] ;
18405: LD_ADDR_EXP 76
18409: PUSH
18410: EMPTY
18411: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
18412: LD_ADDR_EXP 51
18416: PUSH
18417: EMPTY
18418: ST_TO_ADDR
// mc_building_repairs := [ ] ;
18419: LD_ADDR_EXP 52
18423: PUSH
18424: EMPTY
18425: ST_TO_ADDR
// mc_need_heal := [ ] ;
18426: LD_ADDR_EXP 53
18430: PUSH
18431: EMPTY
18432: ST_TO_ADDR
// mc_healers := [ ] ;
18433: LD_ADDR_EXP 54
18437: PUSH
18438: EMPTY
18439: ST_TO_ADDR
// mc_build_list := [ ] ;
18440: LD_ADDR_EXP 55
18444: PUSH
18445: EMPTY
18446: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
18447: LD_ADDR_EXP 82
18451: PUSH
18452: EMPTY
18453: ST_TO_ADDR
// mc_builders := [ ] ;
18454: LD_ADDR_EXP 56
18458: PUSH
18459: EMPTY
18460: ST_TO_ADDR
// mc_construct_list := [ ] ;
18461: LD_ADDR_EXP 57
18465: PUSH
18466: EMPTY
18467: ST_TO_ADDR
// mc_turret_list := [ ] ;
18468: LD_ADDR_EXP 58
18472: PUSH
18473: EMPTY
18474: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
18475: LD_ADDR_EXP 59
18479: PUSH
18480: EMPTY
18481: ST_TO_ADDR
// mc_miners := [ ] ;
18482: LD_ADDR_EXP 64
18486: PUSH
18487: EMPTY
18488: ST_TO_ADDR
// mc_mines := [ ] ;
18489: LD_ADDR_EXP 63
18493: PUSH
18494: EMPTY
18495: ST_TO_ADDR
// mc_minefields := [ ] ;
18496: LD_ADDR_EXP 65
18500: PUSH
18501: EMPTY
18502: ST_TO_ADDR
// mc_crates := [ ] ;
18503: LD_ADDR_EXP 66
18507: PUSH
18508: EMPTY
18509: ST_TO_ADDR
// mc_crates_collector := [ ] ;
18510: LD_ADDR_EXP 67
18514: PUSH
18515: EMPTY
18516: ST_TO_ADDR
// mc_crates_area := [ ] ;
18517: LD_ADDR_EXP 68
18521: PUSH
18522: EMPTY
18523: ST_TO_ADDR
// mc_vehicles := [ ] ;
18524: LD_ADDR_EXP 69
18528: PUSH
18529: EMPTY
18530: ST_TO_ADDR
// mc_attack := [ ] ;
18531: LD_ADDR_EXP 70
18535: PUSH
18536: EMPTY
18537: ST_TO_ADDR
// mc_produce := [ ] ;
18538: LD_ADDR_EXP 71
18542: PUSH
18543: EMPTY
18544: ST_TO_ADDR
// mc_defender := [ ] ;
18545: LD_ADDR_EXP 72
18549: PUSH
18550: EMPTY
18551: ST_TO_ADDR
// mc_parking := [ ] ;
18552: LD_ADDR_EXP 74
18556: PUSH
18557: EMPTY
18558: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
18559: LD_ADDR_EXP 60
18563: PUSH
18564: EMPTY
18565: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
18566: LD_ADDR_EXP 62
18570: PUSH
18571: EMPTY
18572: ST_TO_ADDR
// mc_scan := [ ] ;
18573: LD_ADDR_EXP 73
18577: PUSH
18578: EMPTY
18579: ST_TO_ADDR
// mc_scan_area := [ ] ;
18580: LD_ADDR_EXP 75
18584: PUSH
18585: EMPTY
18586: ST_TO_ADDR
// mc_tech := [ ] ;
18587: LD_ADDR_EXP 77
18591: PUSH
18592: EMPTY
18593: ST_TO_ADDR
// mc_class := [ ] ;
18594: LD_ADDR_EXP 91
18598: PUSH
18599: EMPTY
18600: ST_TO_ADDR
// mc_class_case_use := [ ] ;
18601: LD_ADDR_EXP 92
18605: PUSH
18606: EMPTY
18607: ST_TO_ADDR
// mc_is_defending := [ ] ;
18608: LD_ADDR_EXP 93
18612: PUSH
18613: EMPTY
18614: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
18615: LD_ADDR_EXP 84
18619: PUSH
18620: EMPTY
18621: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
18622: LD_ADDR_EXP 94
18626: PUSH
18627: LD_INT 0
18629: ST_TO_ADDR
// end ;
18630: LD_VAR 0 1
18634: RET
// export function MC_Kill ( base ) ; begin
18635: LD_INT 0
18637: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
18638: LD_ADDR_EXP 50
18642: PUSH
18643: LD_EXP 50
18647: PPUSH
18648: LD_VAR 0 1
18652: PPUSH
18653: EMPTY
18654: PPUSH
18655: CALL_OW 1
18659: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
18660: LD_ADDR_EXP 51
18664: PUSH
18665: LD_EXP 51
18669: PPUSH
18670: LD_VAR 0 1
18674: PPUSH
18675: EMPTY
18676: PPUSH
18677: CALL_OW 1
18681: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
18682: LD_ADDR_EXP 52
18686: PUSH
18687: LD_EXP 52
18691: PPUSH
18692: LD_VAR 0 1
18696: PPUSH
18697: EMPTY
18698: PPUSH
18699: CALL_OW 1
18703: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
18704: LD_ADDR_EXP 53
18708: PUSH
18709: LD_EXP 53
18713: PPUSH
18714: LD_VAR 0 1
18718: PPUSH
18719: EMPTY
18720: PPUSH
18721: CALL_OW 1
18725: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
18726: LD_ADDR_EXP 54
18730: PUSH
18731: LD_EXP 54
18735: PPUSH
18736: LD_VAR 0 1
18740: PPUSH
18741: EMPTY
18742: PPUSH
18743: CALL_OW 1
18747: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
18748: LD_ADDR_EXP 55
18752: PUSH
18753: LD_EXP 55
18757: PPUSH
18758: LD_VAR 0 1
18762: PPUSH
18763: EMPTY
18764: PPUSH
18765: CALL_OW 1
18769: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
18770: LD_ADDR_EXP 56
18774: PUSH
18775: LD_EXP 56
18779: PPUSH
18780: LD_VAR 0 1
18784: PPUSH
18785: EMPTY
18786: PPUSH
18787: CALL_OW 1
18791: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
18792: LD_ADDR_EXP 57
18796: PUSH
18797: LD_EXP 57
18801: PPUSH
18802: LD_VAR 0 1
18806: PPUSH
18807: EMPTY
18808: PPUSH
18809: CALL_OW 1
18813: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
18814: LD_ADDR_EXP 58
18818: PUSH
18819: LD_EXP 58
18823: PPUSH
18824: LD_VAR 0 1
18828: PPUSH
18829: EMPTY
18830: PPUSH
18831: CALL_OW 1
18835: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
18836: LD_ADDR_EXP 59
18840: PUSH
18841: LD_EXP 59
18845: PPUSH
18846: LD_VAR 0 1
18850: PPUSH
18851: EMPTY
18852: PPUSH
18853: CALL_OW 1
18857: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
18858: LD_ADDR_EXP 60
18862: PUSH
18863: LD_EXP 60
18867: PPUSH
18868: LD_VAR 0 1
18872: PPUSH
18873: EMPTY
18874: PPUSH
18875: CALL_OW 1
18879: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
18880: LD_ADDR_EXP 61
18884: PUSH
18885: LD_EXP 61
18889: PPUSH
18890: LD_VAR 0 1
18894: PPUSH
18895: LD_INT 0
18897: PPUSH
18898: CALL_OW 1
18902: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
18903: LD_ADDR_EXP 62
18907: PUSH
18908: LD_EXP 62
18912: PPUSH
18913: LD_VAR 0 1
18917: PPUSH
18918: EMPTY
18919: PPUSH
18920: CALL_OW 1
18924: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
18925: LD_ADDR_EXP 63
18929: PUSH
18930: LD_EXP 63
18934: PPUSH
18935: LD_VAR 0 1
18939: PPUSH
18940: EMPTY
18941: PPUSH
18942: CALL_OW 1
18946: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
18947: LD_ADDR_EXP 64
18951: PUSH
18952: LD_EXP 64
18956: PPUSH
18957: LD_VAR 0 1
18961: PPUSH
18962: EMPTY
18963: PPUSH
18964: CALL_OW 1
18968: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
18969: LD_ADDR_EXP 65
18973: PUSH
18974: LD_EXP 65
18978: PPUSH
18979: LD_VAR 0 1
18983: PPUSH
18984: EMPTY
18985: PPUSH
18986: CALL_OW 1
18990: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
18991: LD_ADDR_EXP 66
18995: PUSH
18996: LD_EXP 66
19000: PPUSH
19001: LD_VAR 0 1
19005: PPUSH
19006: EMPTY
19007: PPUSH
19008: CALL_OW 1
19012: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
19013: LD_ADDR_EXP 67
19017: PUSH
19018: LD_EXP 67
19022: PPUSH
19023: LD_VAR 0 1
19027: PPUSH
19028: EMPTY
19029: PPUSH
19030: CALL_OW 1
19034: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
19035: LD_ADDR_EXP 68
19039: PUSH
19040: LD_EXP 68
19044: PPUSH
19045: LD_VAR 0 1
19049: PPUSH
19050: EMPTY
19051: PPUSH
19052: CALL_OW 1
19056: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
19057: LD_ADDR_EXP 69
19061: PUSH
19062: LD_EXP 69
19066: PPUSH
19067: LD_VAR 0 1
19071: PPUSH
19072: EMPTY
19073: PPUSH
19074: CALL_OW 1
19078: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
19079: LD_ADDR_EXP 70
19083: PUSH
19084: LD_EXP 70
19088: PPUSH
19089: LD_VAR 0 1
19093: PPUSH
19094: EMPTY
19095: PPUSH
19096: CALL_OW 1
19100: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
19101: LD_ADDR_EXP 71
19105: PUSH
19106: LD_EXP 71
19110: PPUSH
19111: LD_VAR 0 1
19115: PPUSH
19116: EMPTY
19117: PPUSH
19118: CALL_OW 1
19122: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
19123: LD_ADDR_EXP 72
19127: PUSH
19128: LD_EXP 72
19132: PPUSH
19133: LD_VAR 0 1
19137: PPUSH
19138: EMPTY
19139: PPUSH
19140: CALL_OW 1
19144: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
19145: LD_ADDR_EXP 73
19149: PUSH
19150: LD_EXP 73
19154: PPUSH
19155: LD_VAR 0 1
19159: PPUSH
19160: EMPTY
19161: PPUSH
19162: CALL_OW 1
19166: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
19167: LD_ADDR_EXP 74
19171: PUSH
19172: LD_EXP 74
19176: PPUSH
19177: LD_VAR 0 1
19181: PPUSH
19182: EMPTY
19183: PPUSH
19184: CALL_OW 1
19188: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
19189: LD_ADDR_EXP 75
19193: PUSH
19194: LD_EXP 75
19198: PPUSH
19199: LD_VAR 0 1
19203: PPUSH
19204: EMPTY
19205: PPUSH
19206: CALL_OW 1
19210: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
19211: LD_ADDR_EXP 77
19215: PUSH
19216: LD_EXP 77
19220: PPUSH
19221: LD_VAR 0 1
19225: PPUSH
19226: EMPTY
19227: PPUSH
19228: CALL_OW 1
19232: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
19233: LD_ADDR_EXP 79
19237: PUSH
19238: LD_EXP 79
19242: PPUSH
19243: LD_VAR 0 1
19247: PPUSH
19248: EMPTY
19249: PPUSH
19250: CALL_OW 1
19254: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
19255: LD_ADDR_EXP 80
19259: PUSH
19260: LD_EXP 80
19264: PPUSH
19265: LD_VAR 0 1
19269: PPUSH
19270: EMPTY
19271: PPUSH
19272: CALL_OW 1
19276: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
19277: LD_ADDR_EXP 81
19281: PUSH
19282: LD_EXP 81
19286: PPUSH
19287: LD_VAR 0 1
19291: PPUSH
19292: EMPTY
19293: PPUSH
19294: CALL_OW 1
19298: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
19299: LD_ADDR_EXP 82
19303: PUSH
19304: LD_EXP 82
19308: PPUSH
19309: LD_VAR 0 1
19313: PPUSH
19314: EMPTY
19315: PPUSH
19316: CALL_OW 1
19320: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
19321: LD_ADDR_EXP 83
19325: PUSH
19326: LD_EXP 83
19330: PPUSH
19331: LD_VAR 0 1
19335: PPUSH
19336: EMPTY
19337: PPUSH
19338: CALL_OW 1
19342: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
19343: LD_ADDR_EXP 84
19347: PUSH
19348: LD_EXP 84
19352: PPUSH
19353: LD_VAR 0 1
19357: PPUSH
19358: EMPTY
19359: PPUSH
19360: CALL_OW 1
19364: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
19365: LD_ADDR_EXP 85
19369: PUSH
19370: LD_EXP 85
19374: PPUSH
19375: LD_VAR 0 1
19379: PPUSH
19380: EMPTY
19381: PPUSH
19382: CALL_OW 1
19386: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
19387: LD_ADDR_EXP 86
19391: PUSH
19392: LD_EXP 86
19396: PPUSH
19397: LD_VAR 0 1
19401: PPUSH
19402: EMPTY
19403: PPUSH
19404: CALL_OW 1
19408: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
19409: LD_ADDR_EXP 87
19413: PUSH
19414: LD_EXP 87
19418: PPUSH
19419: LD_VAR 0 1
19423: PPUSH
19424: EMPTY
19425: PPUSH
19426: CALL_OW 1
19430: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
19431: LD_ADDR_EXP 88
19435: PUSH
19436: LD_EXP 88
19440: PPUSH
19441: LD_VAR 0 1
19445: PPUSH
19446: EMPTY
19447: PPUSH
19448: CALL_OW 1
19452: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
19453: LD_ADDR_EXP 89
19457: PUSH
19458: LD_EXP 89
19462: PPUSH
19463: LD_VAR 0 1
19467: PPUSH
19468: EMPTY
19469: PPUSH
19470: CALL_OW 1
19474: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
19475: LD_ADDR_EXP 90
19479: PUSH
19480: LD_EXP 90
19484: PPUSH
19485: LD_VAR 0 1
19489: PPUSH
19490: EMPTY
19491: PPUSH
19492: CALL_OW 1
19496: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
19497: LD_ADDR_EXP 91
19501: PUSH
19502: LD_EXP 91
19506: PPUSH
19507: LD_VAR 0 1
19511: PPUSH
19512: EMPTY
19513: PPUSH
19514: CALL_OW 1
19518: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
19519: LD_ADDR_EXP 92
19523: PUSH
19524: LD_EXP 92
19528: PPUSH
19529: LD_VAR 0 1
19533: PPUSH
19534: LD_INT 0
19536: PPUSH
19537: CALL_OW 1
19541: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
19542: LD_ADDR_EXP 93
19546: PUSH
19547: LD_EXP 93
19551: PPUSH
19552: LD_VAR 0 1
19556: PPUSH
19557: LD_INT 0
19559: PPUSH
19560: CALL_OW 1
19564: ST_TO_ADDR
// end ;
19565: LD_VAR 0 2
19569: RET
// export function MC_Add ( side , units ) ; var base ; begin
19570: LD_INT 0
19572: PPUSH
19573: PPUSH
// base := mc_bases + 1 ;
19574: LD_ADDR_VAR 0 4
19578: PUSH
19579: LD_EXP 50
19583: PUSH
19584: LD_INT 1
19586: PLUS
19587: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
19588: LD_ADDR_EXP 76
19592: PUSH
19593: LD_EXP 76
19597: PPUSH
19598: LD_VAR 0 4
19602: PPUSH
19603: LD_VAR 0 1
19607: PPUSH
19608: CALL_OW 1
19612: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
19613: LD_ADDR_EXP 50
19617: PUSH
19618: LD_EXP 50
19622: PPUSH
19623: LD_VAR 0 4
19627: PPUSH
19628: LD_VAR 0 2
19632: PPUSH
19633: CALL_OW 1
19637: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
19638: LD_ADDR_EXP 51
19642: PUSH
19643: LD_EXP 51
19647: PPUSH
19648: LD_VAR 0 4
19652: PPUSH
19653: EMPTY
19654: PPUSH
19655: CALL_OW 1
19659: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
19660: LD_ADDR_EXP 52
19664: PUSH
19665: LD_EXP 52
19669: PPUSH
19670: LD_VAR 0 4
19674: PPUSH
19675: EMPTY
19676: PPUSH
19677: CALL_OW 1
19681: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
19682: LD_ADDR_EXP 53
19686: PUSH
19687: LD_EXP 53
19691: PPUSH
19692: LD_VAR 0 4
19696: PPUSH
19697: EMPTY
19698: PPUSH
19699: CALL_OW 1
19703: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
19704: LD_ADDR_EXP 54
19708: PUSH
19709: LD_EXP 54
19713: PPUSH
19714: LD_VAR 0 4
19718: PPUSH
19719: EMPTY
19720: PPUSH
19721: CALL_OW 1
19725: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
19726: LD_ADDR_EXP 55
19730: PUSH
19731: LD_EXP 55
19735: PPUSH
19736: LD_VAR 0 4
19740: PPUSH
19741: EMPTY
19742: PPUSH
19743: CALL_OW 1
19747: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
19748: LD_ADDR_EXP 56
19752: PUSH
19753: LD_EXP 56
19757: PPUSH
19758: LD_VAR 0 4
19762: PPUSH
19763: EMPTY
19764: PPUSH
19765: CALL_OW 1
19769: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
19770: LD_ADDR_EXP 57
19774: PUSH
19775: LD_EXP 57
19779: PPUSH
19780: LD_VAR 0 4
19784: PPUSH
19785: EMPTY
19786: PPUSH
19787: CALL_OW 1
19791: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
19792: LD_ADDR_EXP 58
19796: PUSH
19797: LD_EXP 58
19801: PPUSH
19802: LD_VAR 0 4
19806: PPUSH
19807: EMPTY
19808: PPUSH
19809: CALL_OW 1
19813: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
19814: LD_ADDR_EXP 59
19818: PUSH
19819: LD_EXP 59
19823: PPUSH
19824: LD_VAR 0 4
19828: PPUSH
19829: EMPTY
19830: PPUSH
19831: CALL_OW 1
19835: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
19836: LD_ADDR_EXP 60
19840: PUSH
19841: LD_EXP 60
19845: PPUSH
19846: LD_VAR 0 4
19850: PPUSH
19851: EMPTY
19852: PPUSH
19853: CALL_OW 1
19857: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
19858: LD_ADDR_EXP 61
19862: PUSH
19863: LD_EXP 61
19867: PPUSH
19868: LD_VAR 0 4
19872: PPUSH
19873: LD_INT 0
19875: PPUSH
19876: CALL_OW 1
19880: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
19881: LD_ADDR_EXP 62
19885: PUSH
19886: LD_EXP 62
19890: PPUSH
19891: LD_VAR 0 4
19895: PPUSH
19896: EMPTY
19897: PPUSH
19898: CALL_OW 1
19902: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
19903: LD_ADDR_EXP 63
19907: PUSH
19908: LD_EXP 63
19912: PPUSH
19913: LD_VAR 0 4
19917: PPUSH
19918: EMPTY
19919: PPUSH
19920: CALL_OW 1
19924: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
19925: LD_ADDR_EXP 64
19929: PUSH
19930: LD_EXP 64
19934: PPUSH
19935: LD_VAR 0 4
19939: PPUSH
19940: EMPTY
19941: PPUSH
19942: CALL_OW 1
19946: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
19947: LD_ADDR_EXP 65
19951: PUSH
19952: LD_EXP 65
19956: PPUSH
19957: LD_VAR 0 4
19961: PPUSH
19962: EMPTY
19963: PPUSH
19964: CALL_OW 1
19968: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
19969: LD_ADDR_EXP 66
19973: PUSH
19974: LD_EXP 66
19978: PPUSH
19979: LD_VAR 0 4
19983: PPUSH
19984: EMPTY
19985: PPUSH
19986: CALL_OW 1
19990: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
19991: LD_ADDR_EXP 67
19995: PUSH
19996: LD_EXP 67
20000: PPUSH
20001: LD_VAR 0 4
20005: PPUSH
20006: EMPTY
20007: PPUSH
20008: CALL_OW 1
20012: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
20013: LD_ADDR_EXP 68
20017: PUSH
20018: LD_EXP 68
20022: PPUSH
20023: LD_VAR 0 4
20027: PPUSH
20028: EMPTY
20029: PPUSH
20030: CALL_OW 1
20034: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
20035: LD_ADDR_EXP 69
20039: PUSH
20040: LD_EXP 69
20044: PPUSH
20045: LD_VAR 0 4
20049: PPUSH
20050: EMPTY
20051: PPUSH
20052: CALL_OW 1
20056: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
20057: LD_ADDR_EXP 70
20061: PUSH
20062: LD_EXP 70
20066: PPUSH
20067: LD_VAR 0 4
20071: PPUSH
20072: EMPTY
20073: PPUSH
20074: CALL_OW 1
20078: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
20079: LD_ADDR_EXP 71
20083: PUSH
20084: LD_EXP 71
20088: PPUSH
20089: LD_VAR 0 4
20093: PPUSH
20094: EMPTY
20095: PPUSH
20096: CALL_OW 1
20100: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
20101: LD_ADDR_EXP 72
20105: PUSH
20106: LD_EXP 72
20110: PPUSH
20111: LD_VAR 0 4
20115: PPUSH
20116: EMPTY
20117: PPUSH
20118: CALL_OW 1
20122: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
20123: LD_ADDR_EXP 73
20127: PUSH
20128: LD_EXP 73
20132: PPUSH
20133: LD_VAR 0 4
20137: PPUSH
20138: EMPTY
20139: PPUSH
20140: CALL_OW 1
20144: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
20145: LD_ADDR_EXP 74
20149: PUSH
20150: LD_EXP 74
20154: PPUSH
20155: LD_VAR 0 4
20159: PPUSH
20160: EMPTY
20161: PPUSH
20162: CALL_OW 1
20166: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
20167: LD_ADDR_EXP 75
20171: PUSH
20172: LD_EXP 75
20176: PPUSH
20177: LD_VAR 0 4
20181: PPUSH
20182: EMPTY
20183: PPUSH
20184: CALL_OW 1
20188: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
20189: LD_ADDR_EXP 77
20193: PUSH
20194: LD_EXP 77
20198: PPUSH
20199: LD_VAR 0 4
20203: PPUSH
20204: EMPTY
20205: PPUSH
20206: CALL_OW 1
20210: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
20211: LD_ADDR_EXP 79
20215: PUSH
20216: LD_EXP 79
20220: PPUSH
20221: LD_VAR 0 4
20225: PPUSH
20226: EMPTY
20227: PPUSH
20228: CALL_OW 1
20232: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
20233: LD_ADDR_EXP 80
20237: PUSH
20238: LD_EXP 80
20242: PPUSH
20243: LD_VAR 0 4
20247: PPUSH
20248: EMPTY
20249: PPUSH
20250: CALL_OW 1
20254: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
20255: LD_ADDR_EXP 81
20259: PUSH
20260: LD_EXP 81
20264: PPUSH
20265: LD_VAR 0 4
20269: PPUSH
20270: EMPTY
20271: PPUSH
20272: CALL_OW 1
20276: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
20277: LD_ADDR_EXP 82
20281: PUSH
20282: LD_EXP 82
20286: PPUSH
20287: LD_VAR 0 4
20291: PPUSH
20292: EMPTY
20293: PPUSH
20294: CALL_OW 1
20298: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
20299: LD_ADDR_EXP 83
20303: PUSH
20304: LD_EXP 83
20308: PPUSH
20309: LD_VAR 0 4
20313: PPUSH
20314: EMPTY
20315: PPUSH
20316: CALL_OW 1
20320: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
20321: LD_ADDR_EXP 84
20325: PUSH
20326: LD_EXP 84
20330: PPUSH
20331: LD_VAR 0 4
20335: PPUSH
20336: EMPTY
20337: PPUSH
20338: CALL_OW 1
20342: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
20343: LD_ADDR_EXP 85
20347: PUSH
20348: LD_EXP 85
20352: PPUSH
20353: LD_VAR 0 4
20357: PPUSH
20358: EMPTY
20359: PPUSH
20360: CALL_OW 1
20364: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
20365: LD_ADDR_EXP 86
20369: PUSH
20370: LD_EXP 86
20374: PPUSH
20375: LD_VAR 0 4
20379: PPUSH
20380: EMPTY
20381: PPUSH
20382: CALL_OW 1
20386: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
20387: LD_ADDR_EXP 87
20391: PUSH
20392: LD_EXP 87
20396: PPUSH
20397: LD_VAR 0 4
20401: PPUSH
20402: EMPTY
20403: PPUSH
20404: CALL_OW 1
20408: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
20409: LD_ADDR_EXP 88
20413: PUSH
20414: LD_EXP 88
20418: PPUSH
20419: LD_VAR 0 4
20423: PPUSH
20424: EMPTY
20425: PPUSH
20426: CALL_OW 1
20430: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
20431: LD_ADDR_EXP 89
20435: PUSH
20436: LD_EXP 89
20440: PPUSH
20441: LD_VAR 0 4
20445: PPUSH
20446: EMPTY
20447: PPUSH
20448: CALL_OW 1
20452: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
20453: LD_ADDR_EXP 90
20457: PUSH
20458: LD_EXP 90
20462: PPUSH
20463: LD_VAR 0 4
20467: PPUSH
20468: EMPTY
20469: PPUSH
20470: CALL_OW 1
20474: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
20475: LD_ADDR_EXP 91
20479: PUSH
20480: LD_EXP 91
20484: PPUSH
20485: LD_VAR 0 4
20489: PPUSH
20490: EMPTY
20491: PPUSH
20492: CALL_OW 1
20496: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
20497: LD_ADDR_EXP 92
20501: PUSH
20502: LD_EXP 92
20506: PPUSH
20507: LD_VAR 0 4
20511: PPUSH
20512: LD_INT 0
20514: PPUSH
20515: CALL_OW 1
20519: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
20520: LD_ADDR_EXP 93
20524: PUSH
20525: LD_EXP 93
20529: PPUSH
20530: LD_VAR 0 4
20534: PPUSH
20535: LD_INT 0
20537: PPUSH
20538: CALL_OW 1
20542: ST_TO_ADDR
// result := base ;
20543: LD_ADDR_VAR 0 3
20547: PUSH
20548: LD_VAR 0 4
20552: ST_TO_ADDR
// end ;
20553: LD_VAR 0 3
20557: RET
// export function MC_Start ( ) ; var i ; begin
20558: LD_INT 0
20560: PPUSH
20561: PPUSH
// for i = 1 to mc_bases do
20562: LD_ADDR_VAR 0 2
20566: PUSH
20567: DOUBLE
20568: LD_INT 1
20570: DEC
20571: ST_TO_ADDR
20572: LD_EXP 50
20576: PUSH
20577: FOR_TO
20578: IFFALSE 21678
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
20580: LD_ADDR_EXP 50
20584: PUSH
20585: LD_EXP 50
20589: PPUSH
20590: LD_VAR 0 2
20594: PPUSH
20595: LD_EXP 50
20599: PUSH
20600: LD_VAR 0 2
20604: ARRAY
20605: PUSH
20606: LD_INT 0
20608: DIFF
20609: PPUSH
20610: CALL_OW 1
20614: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
20615: LD_ADDR_EXP 51
20619: PUSH
20620: LD_EXP 51
20624: PPUSH
20625: LD_VAR 0 2
20629: PPUSH
20630: EMPTY
20631: PPUSH
20632: CALL_OW 1
20636: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
20637: LD_ADDR_EXP 52
20641: PUSH
20642: LD_EXP 52
20646: PPUSH
20647: LD_VAR 0 2
20651: PPUSH
20652: EMPTY
20653: PPUSH
20654: CALL_OW 1
20658: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
20659: LD_ADDR_EXP 53
20663: PUSH
20664: LD_EXP 53
20668: PPUSH
20669: LD_VAR 0 2
20673: PPUSH
20674: EMPTY
20675: PPUSH
20676: CALL_OW 1
20680: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
20681: LD_ADDR_EXP 54
20685: PUSH
20686: LD_EXP 54
20690: PPUSH
20691: LD_VAR 0 2
20695: PPUSH
20696: EMPTY
20697: PUSH
20698: EMPTY
20699: PUSH
20700: EMPTY
20701: LIST
20702: LIST
20703: PPUSH
20704: CALL_OW 1
20708: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
20709: LD_ADDR_EXP 55
20713: PUSH
20714: LD_EXP 55
20718: PPUSH
20719: LD_VAR 0 2
20723: PPUSH
20724: EMPTY
20725: PPUSH
20726: CALL_OW 1
20730: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
20731: LD_ADDR_EXP 82
20735: PUSH
20736: LD_EXP 82
20740: PPUSH
20741: LD_VAR 0 2
20745: PPUSH
20746: EMPTY
20747: PPUSH
20748: CALL_OW 1
20752: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
20753: LD_ADDR_EXP 56
20757: PUSH
20758: LD_EXP 56
20762: PPUSH
20763: LD_VAR 0 2
20767: PPUSH
20768: EMPTY
20769: PPUSH
20770: CALL_OW 1
20774: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
20775: LD_ADDR_EXP 57
20779: PUSH
20780: LD_EXP 57
20784: PPUSH
20785: LD_VAR 0 2
20789: PPUSH
20790: EMPTY
20791: PPUSH
20792: CALL_OW 1
20796: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
20797: LD_ADDR_EXP 58
20801: PUSH
20802: LD_EXP 58
20806: PPUSH
20807: LD_VAR 0 2
20811: PPUSH
20812: LD_EXP 50
20816: PUSH
20817: LD_VAR 0 2
20821: ARRAY
20822: PPUSH
20823: LD_INT 2
20825: PUSH
20826: LD_INT 30
20828: PUSH
20829: LD_INT 32
20831: PUSH
20832: EMPTY
20833: LIST
20834: LIST
20835: PUSH
20836: LD_INT 30
20838: PUSH
20839: LD_INT 33
20841: PUSH
20842: EMPTY
20843: LIST
20844: LIST
20845: PUSH
20846: EMPTY
20847: LIST
20848: LIST
20849: LIST
20850: PPUSH
20851: CALL_OW 72
20855: PPUSH
20856: CALL_OW 1
20860: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
20861: LD_ADDR_EXP 59
20865: PUSH
20866: LD_EXP 59
20870: PPUSH
20871: LD_VAR 0 2
20875: PPUSH
20876: LD_EXP 50
20880: PUSH
20881: LD_VAR 0 2
20885: ARRAY
20886: PPUSH
20887: LD_INT 2
20889: PUSH
20890: LD_INT 30
20892: PUSH
20893: LD_INT 32
20895: PUSH
20896: EMPTY
20897: LIST
20898: LIST
20899: PUSH
20900: LD_INT 30
20902: PUSH
20903: LD_INT 31
20905: PUSH
20906: EMPTY
20907: LIST
20908: LIST
20909: PUSH
20910: EMPTY
20911: LIST
20912: LIST
20913: LIST
20914: PUSH
20915: LD_INT 58
20917: PUSH
20918: EMPTY
20919: LIST
20920: PUSH
20921: EMPTY
20922: LIST
20923: LIST
20924: PPUSH
20925: CALL_OW 72
20929: PPUSH
20930: CALL_OW 1
20934: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
20935: LD_ADDR_EXP 60
20939: PUSH
20940: LD_EXP 60
20944: PPUSH
20945: LD_VAR 0 2
20949: PPUSH
20950: EMPTY
20951: PPUSH
20952: CALL_OW 1
20956: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
20957: LD_ADDR_EXP 64
20961: PUSH
20962: LD_EXP 64
20966: PPUSH
20967: LD_VAR 0 2
20971: PPUSH
20972: EMPTY
20973: PPUSH
20974: CALL_OW 1
20978: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
20979: LD_ADDR_EXP 63
20983: PUSH
20984: LD_EXP 63
20988: PPUSH
20989: LD_VAR 0 2
20993: PPUSH
20994: EMPTY
20995: PPUSH
20996: CALL_OW 1
21000: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
21001: LD_ADDR_EXP 65
21005: PUSH
21006: LD_EXP 65
21010: PPUSH
21011: LD_VAR 0 2
21015: PPUSH
21016: EMPTY
21017: PPUSH
21018: CALL_OW 1
21022: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
21023: LD_ADDR_EXP 66
21027: PUSH
21028: LD_EXP 66
21032: PPUSH
21033: LD_VAR 0 2
21037: PPUSH
21038: EMPTY
21039: PPUSH
21040: CALL_OW 1
21044: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
21045: LD_ADDR_EXP 67
21049: PUSH
21050: LD_EXP 67
21054: PPUSH
21055: LD_VAR 0 2
21059: PPUSH
21060: EMPTY
21061: PPUSH
21062: CALL_OW 1
21066: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
21067: LD_ADDR_EXP 68
21071: PUSH
21072: LD_EXP 68
21076: PPUSH
21077: LD_VAR 0 2
21081: PPUSH
21082: EMPTY
21083: PPUSH
21084: CALL_OW 1
21088: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
21089: LD_ADDR_EXP 69
21093: PUSH
21094: LD_EXP 69
21098: PPUSH
21099: LD_VAR 0 2
21103: PPUSH
21104: EMPTY
21105: PPUSH
21106: CALL_OW 1
21110: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
21111: LD_ADDR_EXP 70
21115: PUSH
21116: LD_EXP 70
21120: PPUSH
21121: LD_VAR 0 2
21125: PPUSH
21126: EMPTY
21127: PPUSH
21128: CALL_OW 1
21132: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
21133: LD_ADDR_EXP 71
21137: PUSH
21138: LD_EXP 71
21142: PPUSH
21143: LD_VAR 0 2
21147: PPUSH
21148: EMPTY
21149: PPUSH
21150: CALL_OW 1
21154: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
21155: LD_ADDR_EXP 72
21159: PUSH
21160: LD_EXP 72
21164: PPUSH
21165: LD_VAR 0 2
21169: PPUSH
21170: EMPTY
21171: PPUSH
21172: CALL_OW 1
21176: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
21177: LD_ADDR_EXP 61
21181: PUSH
21182: LD_EXP 61
21186: PPUSH
21187: LD_VAR 0 2
21191: PPUSH
21192: LD_INT 0
21194: PPUSH
21195: CALL_OW 1
21199: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
21200: LD_ADDR_EXP 74
21204: PUSH
21205: LD_EXP 74
21209: PPUSH
21210: LD_VAR 0 2
21214: PPUSH
21215: LD_INT 0
21217: PPUSH
21218: CALL_OW 1
21222: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
21223: LD_ADDR_EXP 62
21227: PUSH
21228: LD_EXP 62
21232: PPUSH
21233: LD_VAR 0 2
21237: PPUSH
21238: EMPTY
21239: PPUSH
21240: CALL_OW 1
21244: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
21245: LD_ADDR_EXP 73
21249: PUSH
21250: LD_EXP 73
21254: PPUSH
21255: LD_VAR 0 2
21259: PPUSH
21260: LD_INT 0
21262: PPUSH
21263: CALL_OW 1
21267: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
21268: LD_ADDR_EXP 75
21272: PUSH
21273: LD_EXP 75
21277: PPUSH
21278: LD_VAR 0 2
21282: PPUSH
21283: EMPTY
21284: PPUSH
21285: CALL_OW 1
21289: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
21290: LD_ADDR_EXP 78
21294: PUSH
21295: LD_EXP 78
21299: PPUSH
21300: LD_VAR 0 2
21304: PPUSH
21305: LD_INT 0
21307: PPUSH
21308: CALL_OW 1
21312: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
21313: LD_ADDR_EXP 79
21317: PUSH
21318: LD_EXP 79
21322: PPUSH
21323: LD_VAR 0 2
21327: PPUSH
21328: EMPTY
21329: PPUSH
21330: CALL_OW 1
21334: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
21335: LD_ADDR_EXP 80
21339: PUSH
21340: LD_EXP 80
21344: PPUSH
21345: LD_VAR 0 2
21349: PPUSH
21350: EMPTY
21351: PPUSH
21352: CALL_OW 1
21356: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
21357: LD_ADDR_EXP 81
21361: PUSH
21362: LD_EXP 81
21366: PPUSH
21367: LD_VAR 0 2
21371: PPUSH
21372: EMPTY
21373: PPUSH
21374: CALL_OW 1
21378: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
21379: LD_ADDR_EXP 83
21383: PUSH
21384: LD_EXP 83
21388: PPUSH
21389: LD_VAR 0 2
21393: PPUSH
21394: LD_EXP 50
21398: PUSH
21399: LD_VAR 0 2
21403: ARRAY
21404: PPUSH
21405: LD_INT 2
21407: PUSH
21408: LD_INT 30
21410: PUSH
21411: LD_INT 6
21413: PUSH
21414: EMPTY
21415: LIST
21416: LIST
21417: PUSH
21418: LD_INT 30
21420: PUSH
21421: LD_INT 7
21423: PUSH
21424: EMPTY
21425: LIST
21426: LIST
21427: PUSH
21428: LD_INT 30
21430: PUSH
21431: LD_INT 8
21433: PUSH
21434: EMPTY
21435: LIST
21436: LIST
21437: PUSH
21438: EMPTY
21439: LIST
21440: LIST
21441: LIST
21442: LIST
21443: PPUSH
21444: CALL_OW 72
21448: PPUSH
21449: CALL_OW 1
21453: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
21454: LD_ADDR_EXP 84
21458: PUSH
21459: LD_EXP 84
21463: PPUSH
21464: LD_VAR 0 2
21468: PPUSH
21469: EMPTY
21470: PPUSH
21471: CALL_OW 1
21475: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
21476: LD_ADDR_EXP 85
21480: PUSH
21481: LD_EXP 85
21485: PPUSH
21486: LD_VAR 0 2
21490: PPUSH
21491: EMPTY
21492: PPUSH
21493: CALL_OW 1
21497: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
21498: LD_ADDR_EXP 86
21502: PUSH
21503: LD_EXP 86
21507: PPUSH
21508: LD_VAR 0 2
21512: PPUSH
21513: EMPTY
21514: PPUSH
21515: CALL_OW 1
21519: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
21520: LD_ADDR_EXP 87
21524: PUSH
21525: LD_EXP 87
21529: PPUSH
21530: LD_VAR 0 2
21534: PPUSH
21535: EMPTY
21536: PPUSH
21537: CALL_OW 1
21541: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
21542: LD_ADDR_EXP 88
21546: PUSH
21547: LD_EXP 88
21551: PPUSH
21552: LD_VAR 0 2
21556: PPUSH
21557: EMPTY
21558: PPUSH
21559: CALL_OW 1
21563: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
21564: LD_ADDR_EXP 89
21568: PUSH
21569: LD_EXP 89
21573: PPUSH
21574: LD_VAR 0 2
21578: PPUSH
21579: EMPTY
21580: PPUSH
21581: CALL_OW 1
21585: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
21586: LD_ADDR_EXP 90
21590: PUSH
21591: LD_EXP 90
21595: PPUSH
21596: LD_VAR 0 2
21600: PPUSH
21601: EMPTY
21602: PPUSH
21603: CALL_OW 1
21607: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
21608: LD_ADDR_EXP 91
21612: PUSH
21613: LD_EXP 91
21617: PPUSH
21618: LD_VAR 0 2
21622: PPUSH
21623: EMPTY
21624: PPUSH
21625: CALL_OW 1
21629: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
21630: LD_ADDR_EXP 92
21634: PUSH
21635: LD_EXP 92
21639: PPUSH
21640: LD_VAR 0 2
21644: PPUSH
21645: LD_INT 0
21647: PPUSH
21648: CALL_OW 1
21652: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
21653: LD_ADDR_EXP 93
21657: PUSH
21658: LD_EXP 93
21662: PPUSH
21663: LD_VAR 0 2
21667: PPUSH
21668: LD_INT 0
21670: PPUSH
21671: CALL_OW 1
21675: ST_TO_ADDR
// end ;
21676: GO 20577
21678: POP
21679: POP
// MC_InitSides ( ) ;
21680: CALL 21966 0 0
// MC_InitResearch ( ) ;
21684: CALL 21705 0 0
// CustomInitMacro ( ) ;
21688: CALL 304 0 0
// skirmish := true ;
21692: LD_ADDR_EXP 48
21696: PUSH
21697: LD_INT 1
21699: ST_TO_ADDR
// end ;
21700: LD_VAR 0 1
21704: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
21705: LD_INT 0
21707: PPUSH
21708: PPUSH
21709: PPUSH
21710: PPUSH
21711: PPUSH
21712: PPUSH
// if not mc_bases then
21713: LD_EXP 50
21717: NOT
21718: IFFALSE 21722
// exit ;
21720: GO 21961
// for i = 1 to 8 do
21722: LD_ADDR_VAR 0 2
21726: PUSH
21727: DOUBLE
21728: LD_INT 1
21730: DEC
21731: ST_TO_ADDR
21732: LD_INT 8
21734: PUSH
21735: FOR_TO
21736: IFFALSE 21762
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
21738: LD_ADDR_EXP 77
21742: PUSH
21743: LD_EXP 77
21747: PPUSH
21748: LD_VAR 0 2
21752: PPUSH
21753: EMPTY
21754: PPUSH
21755: CALL_OW 1
21759: ST_TO_ADDR
21760: GO 21735
21762: POP
21763: POP
// tmp := [ ] ;
21764: LD_ADDR_VAR 0 5
21768: PUSH
21769: EMPTY
21770: ST_TO_ADDR
// for i = 1 to mc_sides do
21771: LD_ADDR_VAR 0 2
21775: PUSH
21776: DOUBLE
21777: LD_INT 1
21779: DEC
21780: ST_TO_ADDR
21781: LD_EXP 76
21785: PUSH
21786: FOR_TO
21787: IFFALSE 21845
// if not mc_sides [ i ] in tmp then
21789: LD_EXP 76
21793: PUSH
21794: LD_VAR 0 2
21798: ARRAY
21799: PUSH
21800: LD_VAR 0 5
21804: IN
21805: NOT
21806: IFFALSE 21843
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
21808: LD_ADDR_VAR 0 5
21812: PUSH
21813: LD_VAR 0 5
21817: PPUSH
21818: LD_VAR 0 5
21822: PUSH
21823: LD_INT 1
21825: PLUS
21826: PPUSH
21827: LD_EXP 76
21831: PUSH
21832: LD_VAR 0 2
21836: ARRAY
21837: PPUSH
21838: CALL_OW 2
21842: ST_TO_ADDR
21843: GO 21786
21845: POP
21846: POP
// if not tmp then
21847: LD_VAR 0 5
21851: NOT
21852: IFFALSE 21856
// exit ;
21854: GO 21961
// for j in tmp do
21856: LD_ADDR_VAR 0 3
21860: PUSH
21861: LD_VAR 0 5
21865: PUSH
21866: FOR_IN
21867: IFFALSE 21959
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
21869: LD_ADDR_VAR 0 6
21873: PUSH
21874: LD_INT 22
21876: PUSH
21877: LD_VAR 0 3
21881: PUSH
21882: EMPTY
21883: LIST
21884: LIST
21885: PPUSH
21886: CALL_OW 69
21890: ST_TO_ADDR
// if not un then
21891: LD_VAR 0 6
21895: NOT
21896: IFFALSE 21900
// continue ;
21898: GO 21866
// nation := GetNation ( un [ 1 ] ) ;
21900: LD_ADDR_VAR 0 4
21904: PUSH
21905: LD_VAR 0 6
21909: PUSH
21910: LD_INT 1
21912: ARRAY
21913: PPUSH
21914: CALL_OW 248
21918: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
21919: LD_ADDR_EXP 77
21923: PUSH
21924: LD_EXP 77
21928: PPUSH
21929: LD_VAR 0 3
21933: PPUSH
21934: LD_VAR 0 3
21938: PPUSH
21939: LD_VAR 0 4
21943: PPUSH
21944: LD_INT 1
21946: PPUSH
21947: CALL 49135 0 3
21951: PPUSH
21952: CALL_OW 1
21956: ST_TO_ADDR
// end ;
21957: GO 21866
21959: POP
21960: POP
// end ;
21961: LD_VAR 0 1
21965: RET
// export function MC_InitSides ( ) ; var i ; begin
21966: LD_INT 0
21968: PPUSH
21969: PPUSH
// if not mc_bases then
21970: LD_EXP 50
21974: NOT
21975: IFFALSE 21979
// exit ;
21977: GO 22053
// for i = 1 to mc_bases do
21979: LD_ADDR_VAR 0 2
21983: PUSH
21984: DOUBLE
21985: LD_INT 1
21987: DEC
21988: ST_TO_ADDR
21989: LD_EXP 50
21993: PUSH
21994: FOR_TO
21995: IFFALSE 22051
// if mc_bases [ i ] then
21997: LD_EXP 50
22001: PUSH
22002: LD_VAR 0 2
22006: ARRAY
22007: IFFALSE 22049
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
22009: LD_ADDR_EXP 76
22013: PUSH
22014: LD_EXP 76
22018: PPUSH
22019: LD_VAR 0 2
22023: PPUSH
22024: LD_EXP 50
22028: PUSH
22029: LD_VAR 0 2
22033: ARRAY
22034: PUSH
22035: LD_INT 1
22037: ARRAY
22038: PPUSH
22039: CALL_OW 255
22043: PPUSH
22044: CALL_OW 1
22048: ST_TO_ADDR
22049: GO 21994
22051: POP
22052: POP
// end ;
22053: LD_VAR 0 1
22057: RET
// every 0 0$03 trigger skirmish do
22058: LD_EXP 48
22062: IFFALSE 22216
22064: GO 22066
22066: DISABLE
// begin enable ;
22067: ENABLE
// MC_CheckBuildings ( ) ;
22068: CALL 26714 0 0
// MC_CheckPeopleLife ( ) ;
22072: CALL 26875 0 0
// RaiseSailEvent ( 100 ) ;
22076: LD_INT 100
22078: PPUSH
22079: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
22083: LD_INT 103
22085: PPUSH
22086: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
22090: LD_INT 104
22092: PPUSH
22093: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
22097: LD_INT 105
22099: PPUSH
22100: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
22104: LD_INT 106
22106: PPUSH
22107: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
22111: LD_INT 107
22113: PPUSH
22114: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
22118: LD_INT 108
22120: PPUSH
22121: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
22125: LD_INT 109
22127: PPUSH
22128: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
22132: LD_INT 110
22134: PPUSH
22135: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
22139: LD_INT 111
22141: PPUSH
22142: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
22146: LD_INT 112
22148: PPUSH
22149: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
22153: LD_INT 113
22155: PPUSH
22156: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
22160: LD_INT 120
22162: PPUSH
22163: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
22167: LD_INT 121
22169: PPUSH
22170: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
22174: LD_INT 122
22176: PPUSH
22177: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
22181: LD_INT 123
22183: PPUSH
22184: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
22188: LD_INT 124
22190: PPUSH
22191: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
22195: LD_INT 125
22197: PPUSH
22198: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
22202: LD_INT 126
22204: PPUSH
22205: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
22209: LD_INT 200
22211: PPUSH
22212: CALL_OW 427
// end ;
22216: END
// on SailEvent ( event ) do begin if event < 100 then
22217: LD_VAR 0 1
22221: PUSH
22222: LD_INT 100
22224: LESS
22225: IFFALSE 22236
// CustomEvent ( event ) ;
22227: LD_VAR 0 1
22231: PPUSH
22232: CALL 17379 0 1
// if event = 100 then
22236: LD_VAR 0 1
22240: PUSH
22241: LD_INT 100
22243: EQUAL
22244: IFFALSE 22250
// MC_ClassManager ( ) ;
22246: CALL 22642 0 0
// if event = 101 then
22250: LD_VAR 0 1
22254: PUSH
22255: LD_INT 101
22257: EQUAL
22258: IFFALSE 22264
// MC_RepairBuildings ( ) ;
22260: CALL 27460 0 0
// if event = 102 then
22264: LD_VAR 0 1
22268: PUSH
22269: LD_INT 102
22271: EQUAL
22272: IFFALSE 22278
// MC_Heal ( ) ;
22274: CALL 28395 0 0
// if event = 103 then
22278: LD_VAR 0 1
22282: PUSH
22283: LD_INT 103
22285: EQUAL
22286: IFFALSE 22292
// MC_Build ( ) ;
22288: CALL 28817 0 0
// if event = 104 then
22292: LD_VAR 0 1
22296: PUSH
22297: LD_INT 104
22299: EQUAL
22300: IFFALSE 22306
// MC_TurretWeapon ( ) ;
22302: CALL 30451 0 0
// if event = 105 then
22306: LD_VAR 0 1
22310: PUSH
22311: LD_INT 105
22313: EQUAL
22314: IFFALSE 22320
// MC_BuildUpgrade ( ) ;
22316: CALL 30002 0 0
// if event = 106 then
22320: LD_VAR 0 1
22324: PUSH
22325: LD_INT 106
22327: EQUAL
22328: IFFALSE 22334
// MC_PlantMines ( ) ;
22330: CALL 30881 0 0
// if event = 107 then
22334: LD_VAR 0 1
22338: PUSH
22339: LD_INT 107
22341: EQUAL
22342: IFFALSE 22348
// MC_CollectCrates ( ) ;
22344: CALL 31679 0 0
// if event = 108 then
22348: LD_VAR 0 1
22352: PUSH
22353: LD_INT 108
22355: EQUAL
22356: IFFALSE 22362
// MC_LinkRemoteControl ( ) ;
22358: CALL 33529 0 0
// if event = 109 then
22362: LD_VAR 0 1
22366: PUSH
22367: LD_INT 109
22369: EQUAL
22370: IFFALSE 22376
// MC_ProduceVehicle ( ) ;
22372: CALL 33710 0 0
// if event = 110 then
22376: LD_VAR 0 1
22380: PUSH
22381: LD_INT 110
22383: EQUAL
22384: IFFALSE 22390
// MC_SendAttack ( ) ;
22386: CALL 34176 0 0
// if event = 111 then
22390: LD_VAR 0 1
22394: PUSH
22395: LD_INT 111
22397: EQUAL
22398: IFFALSE 22404
// MC_Defend ( ) ;
22400: CALL 34284 0 0
// if event = 112 then
22404: LD_VAR 0 1
22408: PUSH
22409: LD_INT 112
22411: EQUAL
22412: IFFALSE 22418
// MC_Research ( ) ;
22414: CALL 35164 0 0
// if event = 113 then
22418: LD_VAR 0 1
22422: PUSH
22423: LD_INT 113
22425: EQUAL
22426: IFFALSE 22432
// MC_MinesTrigger ( ) ;
22428: CALL 36278 0 0
// if event = 120 then
22432: LD_VAR 0 1
22436: PUSH
22437: LD_INT 120
22439: EQUAL
22440: IFFALSE 22446
// MC_RepairVehicle ( ) ;
22442: CALL 36377 0 0
// if event = 121 then
22446: LD_VAR 0 1
22450: PUSH
22451: LD_INT 121
22453: EQUAL
22454: IFFALSE 22460
// MC_TameApe ( ) ;
22456: CALL 37146 0 0
// if event = 122 then
22460: LD_VAR 0 1
22464: PUSH
22465: LD_INT 122
22467: EQUAL
22468: IFFALSE 22474
// MC_ChangeApeClass ( ) ;
22470: CALL 37975 0 0
// if event = 123 then
22474: LD_VAR 0 1
22478: PUSH
22479: LD_INT 123
22481: EQUAL
22482: IFFALSE 22488
// MC_Bazooka ( ) ;
22484: CALL 38625 0 0
// if event = 124 then
22488: LD_VAR 0 1
22492: PUSH
22493: LD_INT 124
22495: EQUAL
22496: IFFALSE 22502
// MC_TeleportExit ( ) ;
22498: CALL 38823 0 0
// if event = 125 then
22502: LD_VAR 0 1
22506: PUSH
22507: LD_INT 125
22509: EQUAL
22510: IFFALSE 22516
// MC_Deposits ( ) ;
22512: CALL 39470 0 0
// if event = 126 then
22516: LD_VAR 0 1
22520: PUSH
22521: LD_INT 126
22523: EQUAL
22524: IFFALSE 22530
// MC_RemoteDriver ( ) ;
22526: CALL 40095 0 0
// if event = 200 then
22530: LD_VAR 0 1
22534: PUSH
22535: LD_INT 200
22537: EQUAL
22538: IFFALSE 22544
// MC_Idle ( ) ;
22540: CALL 42002 0 0
// end ;
22544: PPOPN 1
22546: END
// export function MC_Reset ( base , tag ) ; var i ; begin
22547: LD_INT 0
22549: PPUSH
22550: PPUSH
// if not mc_bases [ base ] or not tag then
22551: LD_EXP 50
22555: PUSH
22556: LD_VAR 0 1
22560: ARRAY
22561: NOT
22562: PUSH
22563: LD_VAR 0 2
22567: NOT
22568: OR
22569: IFFALSE 22573
// exit ;
22571: GO 22637
// for i in mc_bases [ base ] union mc_ape [ base ] do
22573: LD_ADDR_VAR 0 4
22577: PUSH
22578: LD_EXP 50
22582: PUSH
22583: LD_VAR 0 1
22587: ARRAY
22588: PUSH
22589: LD_EXP 79
22593: PUSH
22594: LD_VAR 0 1
22598: ARRAY
22599: UNION
22600: PUSH
22601: FOR_IN
22602: IFFALSE 22635
// if GetTag ( i ) = tag then
22604: LD_VAR 0 4
22608: PPUSH
22609: CALL_OW 110
22613: PUSH
22614: LD_VAR 0 2
22618: EQUAL
22619: IFFALSE 22633
// SetTag ( i , 0 ) ;
22621: LD_VAR 0 4
22625: PPUSH
22626: LD_INT 0
22628: PPUSH
22629: CALL_OW 109
22633: GO 22601
22635: POP
22636: POP
// end ;
22637: LD_VAR 0 3
22641: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
22642: LD_INT 0
22644: PPUSH
22645: PPUSH
22646: PPUSH
22647: PPUSH
22648: PPUSH
22649: PPUSH
22650: PPUSH
22651: PPUSH
// if not mc_bases then
22652: LD_EXP 50
22656: NOT
22657: IFFALSE 22661
// exit ;
22659: GO 23119
// for i = 1 to mc_bases do
22661: LD_ADDR_VAR 0 2
22665: PUSH
22666: DOUBLE
22667: LD_INT 1
22669: DEC
22670: ST_TO_ADDR
22671: LD_EXP 50
22675: PUSH
22676: FOR_TO
22677: IFFALSE 23117
// begin tmp := MC_ClassCheckReq ( i ) ;
22679: LD_ADDR_VAR 0 4
22683: PUSH
22684: LD_VAR 0 2
22688: PPUSH
22689: CALL 23124 0 1
22693: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
22694: LD_ADDR_EXP 91
22698: PUSH
22699: LD_EXP 91
22703: PPUSH
22704: LD_VAR 0 2
22708: PPUSH
22709: LD_VAR 0 4
22713: PPUSH
22714: CALL_OW 1
22718: ST_TO_ADDR
// if not tmp then
22719: LD_VAR 0 4
22723: NOT
22724: IFFALSE 22728
// continue ;
22726: GO 22676
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
22728: LD_ADDR_VAR 0 6
22732: PUSH
22733: LD_EXP 50
22737: PUSH
22738: LD_VAR 0 2
22742: ARRAY
22743: PPUSH
22744: LD_INT 2
22746: PUSH
22747: LD_INT 30
22749: PUSH
22750: LD_INT 4
22752: PUSH
22753: EMPTY
22754: LIST
22755: LIST
22756: PUSH
22757: LD_INT 30
22759: PUSH
22760: LD_INT 5
22762: PUSH
22763: EMPTY
22764: LIST
22765: LIST
22766: PUSH
22767: EMPTY
22768: LIST
22769: LIST
22770: LIST
22771: PPUSH
22772: CALL_OW 72
22776: PUSH
22777: LD_EXP 50
22781: PUSH
22782: LD_VAR 0 2
22786: ARRAY
22787: PPUSH
22788: LD_INT 2
22790: PUSH
22791: LD_INT 30
22793: PUSH
22794: LD_INT 0
22796: PUSH
22797: EMPTY
22798: LIST
22799: LIST
22800: PUSH
22801: LD_INT 30
22803: PUSH
22804: LD_INT 1
22806: PUSH
22807: EMPTY
22808: LIST
22809: LIST
22810: PUSH
22811: EMPTY
22812: LIST
22813: LIST
22814: LIST
22815: PPUSH
22816: CALL_OW 72
22820: PUSH
22821: LD_EXP 50
22825: PUSH
22826: LD_VAR 0 2
22830: ARRAY
22831: PPUSH
22832: LD_INT 30
22834: PUSH
22835: LD_INT 3
22837: PUSH
22838: EMPTY
22839: LIST
22840: LIST
22841: PPUSH
22842: CALL_OW 72
22846: PUSH
22847: LD_EXP 50
22851: PUSH
22852: LD_VAR 0 2
22856: ARRAY
22857: PPUSH
22858: LD_INT 2
22860: PUSH
22861: LD_INT 30
22863: PUSH
22864: LD_INT 6
22866: PUSH
22867: EMPTY
22868: LIST
22869: LIST
22870: PUSH
22871: LD_INT 30
22873: PUSH
22874: LD_INT 7
22876: PUSH
22877: EMPTY
22878: LIST
22879: LIST
22880: PUSH
22881: LD_INT 30
22883: PUSH
22884: LD_INT 8
22886: PUSH
22887: EMPTY
22888: LIST
22889: LIST
22890: PUSH
22891: EMPTY
22892: LIST
22893: LIST
22894: LIST
22895: LIST
22896: PPUSH
22897: CALL_OW 72
22901: PUSH
22902: EMPTY
22903: LIST
22904: LIST
22905: LIST
22906: LIST
22907: ST_TO_ADDR
// for j = 1 to 4 do
22908: LD_ADDR_VAR 0 3
22912: PUSH
22913: DOUBLE
22914: LD_INT 1
22916: DEC
22917: ST_TO_ADDR
22918: LD_INT 4
22920: PUSH
22921: FOR_TO
22922: IFFALSE 23113
// begin if not tmp [ j ] then
22924: LD_VAR 0 4
22928: PUSH
22929: LD_VAR 0 3
22933: ARRAY
22934: NOT
22935: IFFALSE 22939
// continue ;
22937: GO 22921
// for p in tmp [ j ] do
22939: LD_ADDR_VAR 0 5
22943: PUSH
22944: LD_VAR 0 4
22948: PUSH
22949: LD_VAR 0 3
22953: ARRAY
22954: PUSH
22955: FOR_IN
22956: IFFALSE 23109
// begin if not b [ j ] then
22958: LD_VAR 0 6
22962: PUSH
22963: LD_VAR 0 3
22967: ARRAY
22968: NOT
22969: IFFALSE 22973
// break ;
22971: GO 23109
// e := 0 ;
22973: LD_ADDR_VAR 0 7
22977: PUSH
22978: LD_INT 0
22980: ST_TO_ADDR
// for k in b [ j ] do
22981: LD_ADDR_VAR 0 8
22985: PUSH
22986: LD_VAR 0 6
22990: PUSH
22991: LD_VAR 0 3
22995: ARRAY
22996: PUSH
22997: FOR_IN
22998: IFFALSE 23025
// if IsNotFull ( k ) then
23000: LD_VAR 0 8
23004: PPUSH
23005: CALL 51256 0 1
23009: IFFALSE 23023
// begin e := k ;
23011: LD_ADDR_VAR 0 7
23015: PUSH
23016: LD_VAR 0 8
23020: ST_TO_ADDR
// break ;
23021: GO 23025
// end ;
23023: GO 22997
23025: POP
23026: POP
// if e and not UnitGoingToBuilding ( p , e ) then
23027: LD_VAR 0 7
23031: PUSH
23032: LD_VAR 0 5
23036: PPUSH
23037: LD_VAR 0 7
23041: PPUSH
23042: CALL 85009 0 2
23046: NOT
23047: AND
23048: IFFALSE 23107
// begin if IsInUnit ( p ) then
23050: LD_VAR 0 5
23054: PPUSH
23055: CALL_OW 310
23059: IFFALSE 23070
// ComExitBuilding ( p ) ;
23061: LD_VAR 0 5
23065: PPUSH
23066: CALL_OW 122
// ComEnterUnit ( p , e ) ;
23070: LD_VAR 0 5
23074: PPUSH
23075: LD_VAR 0 7
23079: PPUSH
23080: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
23084: LD_VAR 0 5
23088: PPUSH
23089: LD_VAR 0 3
23093: PPUSH
23094: CALL_OW 183
// AddComExitBuilding ( p ) ;
23098: LD_VAR 0 5
23102: PPUSH
23103: CALL_OW 182
// end ; end ;
23107: GO 22955
23109: POP
23110: POP
// end ;
23111: GO 22921
23113: POP
23114: POP
// end ;
23115: GO 22676
23117: POP
23118: POP
// end ;
23119: LD_VAR 0 1
23123: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
23124: LD_INT 0
23126: PPUSH
23127: PPUSH
23128: PPUSH
23129: PPUSH
23130: PPUSH
23131: PPUSH
23132: PPUSH
23133: PPUSH
23134: PPUSH
23135: PPUSH
23136: PPUSH
23137: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
23138: LD_VAR 0 1
23142: NOT
23143: PUSH
23144: LD_EXP 50
23148: PUSH
23149: LD_VAR 0 1
23153: ARRAY
23154: NOT
23155: OR
23156: PUSH
23157: LD_EXP 50
23161: PUSH
23162: LD_VAR 0 1
23166: ARRAY
23167: PPUSH
23168: LD_INT 2
23170: PUSH
23171: LD_INT 30
23173: PUSH
23174: LD_INT 0
23176: PUSH
23177: EMPTY
23178: LIST
23179: LIST
23180: PUSH
23181: LD_INT 30
23183: PUSH
23184: LD_INT 1
23186: PUSH
23187: EMPTY
23188: LIST
23189: LIST
23190: PUSH
23191: EMPTY
23192: LIST
23193: LIST
23194: LIST
23195: PPUSH
23196: CALL_OW 72
23200: NOT
23201: OR
23202: IFFALSE 23206
// exit ;
23204: GO 26709
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
23206: LD_ADDR_VAR 0 4
23210: PUSH
23211: LD_EXP 50
23215: PUSH
23216: LD_VAR 0 1
23220: ARRAY
23221: PPUSH
23222: LD_INT 2
23224: PUSH
23225: LD_INT 25
23227: PUSH
23228: LD_INT 1
23230: PUSH
23231: EMPTY
23232: LIST
23233: LIST
23234: PUSH
23235: LD_INT 25
23237: PUSH
23238: LD_INT 2
23240: PUSH
23241: EMPTY
23242: LIST
23243: LIST
23244: PUSH
23245: LD_INT 25
23247: PUSH
23248: LD_INT 3
23250: PUSH
23251: EMPTY
23252: LIST
23253: LIST
23254: PUSH
23255: LD_INT 25
23257: PUSH
23258: LD_INT 4
23260: PUSH
23261: EMPTY
23262: LIST
23263: LIST
23264: PUSH
23265: LD_INT 25
23267: PUSH
23268: LD_INT 5
23270: PUSH
23271: EMPTY
23272: LIST
23273: LIST
23274: PUSH
23275: LD_INT 25
23277: PUSH
23278: LD_INT 8
23280: PUSH
23281: EMPTY
23282: LIST
23283: LIST
23284: PUSH
23285: LD_INT 25
23287: PUSH
23288: LD_INT 9
23290: PUSH
23291: EMPTY
23292: LIST
23293: LIST
23294: PUSH
23295: EMPTY
23296: LIST
23297: LIST
23298: LIST
23299: LIST
23300: LIST
23301: LIST
23302: LIST
23303: LIST
23304: PPUSH
23305: CALL_OW 72
23309: ST_TO_ADDR
// if not tmp then
23310: LD_VAR 0 4
23314: NOT
23315: IFFALSE 23319
// exit ;
23317: GO 26709
// for i in tmp do
23319: LD_ADDR_VAR 0 3
23323: PUSH
23324: LD_VAR 0 4
23328: PUSH
23329: FOR_IN
23330: IFFALSE 23361
// if GetTag ( i ) then
23332: LD_VAR 0 3
23336: PPUSH
23337: CALL_OW 110
23341: IFFALSE 23359
// tmp := tmp diff i ;
23343: LD_ADDR_VAR 0 4
23347: PUSH
23348: LD_VAR 0 4
23352: PUSH
23353: LD_VAR 0 3
23357: DIFF
23358: ST_TO_ADDR
23359: GO 23329
23361: POP
23362: POP
// if not tmp then
23363: LD_VAR 0 4
23367: NOT
23368: IFFALSE 23372
// exit ;
23370: GO 26709
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
23372: LD_ADDR_VAR 0 5
23376: PUSH
23377: LD_EXP 50
23381: PUSH
23382: LD_VAR 0 1
23386: ARRAY
23387: PPUSH
23388: LD_INT 2
23390: PUSH
23391: LD_INT 25
23393: PUSH
23394: LD_INT 1
23396: PUSH
23397: EMPTY
23398: LIST
23399: LIST
23400: PUSH
23401: LD_INT 25
23403: PUSH
23404: LD_INT 5
23406: PUSH
23407: EMPTY
23408: LIST
23409: LIST
23410: PUSH
23411: LD_INT 25
23413: PUSH
23414: LD_INT 8
23416: PUSH
23417: EMPTY
23418: LIST
23419: LIST
23420: PUSH
23421: LD_INT 25
23423: PUSH
23424: LD_INT 9
23426: PUSH
23427: EMPTY
23428: LIST
23429: LIST
23430: PUSH
23431: EMPTY
23432: LIST
23433: LIST
23434: LIST
23435: LIST
23436: LIST
23437: PPUSH
23438: CALL_OW 72
23442: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
23443: LD_ADDR_VAR 0 6
23447: PUSH
23448: LD_EXP 50
23452: PUSH
23453: LD_VAR 0 1
23457: ARRAY
23458: PPUSH
23459: LD_INT 25
23461: PUSH
23462: LD_INT 2
23464: PUSH
23465: EMPTY
23466: LIST
23467: LIST
23468: PPUSH
23469: CALL_OW 72
23473: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
23474: LD_ADDR_VAR 0 7
23478: PUSH
23479: LD_EXP 50
23483: PUSH
23484: LD_VAR 0 1
23488: ARRAY
23489: PPUSH
23490: LD_INT 25
23492: PUSH
23493: LD_INT 3
23495: PUSH
23496: EMPTY
23497: LIST
23498: LIST
23499: PPUSH
23500: CALL_OW 72
23504: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
23505: LD_ADDR_VAR 0 8
23509: PUSH
23510: LD_EXP 50
23514: PUSH
23515: LD_VAR 0 1
23519: ARRAY
23520: PPUSH
23521: LD_INT 25
23523: PUSH
23524: LD_INT 4
23526: PUSH
23527: EMPTY
23528: LIST
23529: LIST
23530: PUSH
23531: LD_INT 24
23533: PUSH
23534: LD_INT 251
23536: PUSH
23537: EMPTY
23538: LIST
23539: LIST
23540: PUSH
23541: EMPTY
23542: LIST
23543: LIST
23544: PPUSH
23545: CALL_OW 72
23549: ST_TO_ADDR
// if mc_is_defending [ base ] then
23550: LD_EXP 93
23554: PUSH
23555: LD_VAR 0 1
23559: ARRAY
23560: IFFALSE 24021
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
23562: LD_ADDR_EXP 92
23566: PUSH
23567: LD_EXP 92
23571: PPUSH
23572: LD_VAR 0 1
23576: PPUSH
23577: LD_INT 4
23579: PPUSH
23580: CALL_OW 1
23584: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
23585: LD_ADDR_VAR 0 12
23589: PUSH
23590: LD_EXP 50
23594: PUSH
23595: LD_VAR 0 1
23599: ARRAY
23600: PPUSH
23601: LD_INT 2
23603: PUSH
23604: LD_INT 30
23606: PUSH
23607: LD_INT 4
23609: PUSH
23610: EMPTY
23611: LIST
23612: LIST
23613: PUSH
23614: LD_INT 30
23616: PUSH
23617: LD_INT 5
23619: PUSH
23620: EMPTY
23621: LIST
23622: LIST
23623: PUSH
23624: EMPTY
23625: LIST
23626: LIST
23627: LIST
23628: PPUSH
23629: CALL_OW 72
23633: ST_TO_ADDR
// if not b then
23634: LD_VAR 0 12
23638: NOT
23639: IFFALSE 23643
// exit ;
23641: GO 26709
// p := [ ] ;
23643: LD_ADDR_VAR 0 11
23647: PUSH
23648: EMPTY
23649: ST_TO_ADDR
// if sci >= 2 then
23650: LD_VAR 0 8
23654: PUSH
23655: LD_INT 2
23657: GREATEREQUAL
23658: IFFALSE 23689
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
23660: LD_ADDR_VAR 0 8
23664: PUSH
23665: LD_VAR 0 8
23669: PUSH
23670: LD_INT 1
23672: ARRAY
23673: PUSH
23674: LD_VAR 0 8
23678: PUSH
23679: LD_INT 2
23681: ARRAY
23682: PUSH
23683: EMPTY
23684: LIST
23685: LIST
23686: ST_TO_ADDR
23687: GO 23750
// if sci = 1 then
23689: LD_VAR 0 8
23693: PUSH
23694: LD_INT 1
23696: EQUAL
23697: IFFALSE 23718
// sci := [ sci [ 1 ] ] else
23699: LD_ADDR_VAR 0 8
23703: PUSH
23704: LD_VAR 0 8
23708: PUSH
23709: LD_INT 1
23711: ARRAY
23712: PUSH
23713: EMPTY
23714: LIST
23715: ST_TO_ADDR
23716: GO 23750
// if sci = 0 then
23718: LD_VAR 0 8
23722: PUSH
23723: LD_INT 0
23725: EQUAL
23726: IFFALSE 23750
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
23728: LD_ADDR_VAR 0 11
23732: PUSH
23733: LD_VAR 0 4
23737: PPUSH
23738: LD_INT 4
23740: PPUSH
23741: CALL 84881 0 2
23745: PUSH
23746: LD_INT 1
23748: ARRAY
23749: ST_TO_ADDR
// if eng > 4 then
23750: LD_VAR 0 6
23754: PUSH
23755: LD_INT 4
23757: GREATER
23758: IFFALSE 23804
// for i = eng downto 4 do
23760: LD_ADDR_VAR 0 3
23764: PUSH
23765: DOUBLE
23766: LD_VAR 0 6
23770: INC
23771: ST_TO_ADDR
23772: LD_INT 4
23774: PUSH
23775: FOR_DOWNTO
23776: IFFALSE 23802
// eng := eng diff eng [ i ] ;
23778: LD_ADDR_VAR 0 6
23782: PUSH
23783: LD_VAR 0 6
23787: PUSH
23788: LD_VAR 0 6
23792: PUSH
23793: LD_VAR 0 3
23797: ARRAY
23798: DIFF
23799: ST_TO_ADDR
23800: GO 23775
23802: POP
23803: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
23804: LD_ADDR_VAR 0 4
23808: PUSH
23809: LD_VAR 0 4
23813: PUSH
23814: LD_VAR 0 5
23818: PUSH
23819: LD_VAR 0 6
23823: UNION
23824: PUSH
23825: LD_VAR 0 7
23829: UNION
23830: PUSH
23831: LD_VAR 0 8
23835: UNION
23836: DIFF
23837: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
23838: LD_ADDR_VAR 0 13
23842: PUSH
23843: LD_EXP 50
23847: PUSH
23848: LD_VAR 0 1
23852: ARRAY
23853: PPUSH
23854: LD_INT 2
23856: PUSH
23857: LD_INT 30
23859: PUSH
23860: LD_INT 32
23862: PUSH
23863: EMPTY
23864: LIST
23865: LIST
23866: PUSH
23867: LD_INT 30
23869: PUSH
23870: LD_INT 31
23872: PUSH
23873: EMPTY
23874: LIST
23875: LIST
23876: PUSH
23877: EMPTY
23878: LIST
23879: LIST
23880: LIST
23881: PPUSH
23882: CALL_OW 72
23886: PUSH
23887: LD_EXP 50
23891: PUSH
23892: LD_VAR 0 1
23896: ARRAY
23897: PPUSH
23898: LD_INT 2
23900: PUSH
23901: LD_INT 30
23903: PUSH
23904: LD_INT 4
23906: PUSH
23907: EMPTY
23908: LIST
23909: LIST
23910: PUSH
23911: LD_INT 30
23913: PUSH
23914: LD_INT 5
23916: PUSH
23917: EMPTY
23918: LIST
23919: LIST
23920: PUSH
23921: EMPTY
23922: LIST
23923: LIST
23924: LIST
23925: PPUSH
23926: CALL_OW 72
23930: PUSH
23931: LD_INT 6
23933: MUL
23934: PLUS
23935: ST_TO_ADDR
// if bcount < tmp then
23936: LD_VAR 0 13
23940: PUSH
23941: LD_VAR 0 4
23945: LESS
23946: IFFALSE 23992
// for i = tmp downto bcount do
23948: LD_ADDR_VAR 0 3
23952: PUSH
23953: DOUBLE
23954: LD_VAR 0 4
23958: INC
23959: ST_TO_ADDR
23960: LD_VAR 0 13
23964: PUSH
23965: FOR_DOWNTO
23966: IFFALSE 23990
// tmp := Delete ( tmp , tmp ) ;
23968: LD_ADDR_VAR 0 4
23972: PUSH
23973: LD_VAR 0 4
23977: PPUSH
23978: LD_VAR 0 4
23982: PPUSH
23983: CALL_OW 3
23987: ST_TO_ADDR
23988: GO 23965
23990: POP
23991: POP
// result := [ tmp , 0 , 0 , p ] ;
23992: LD_ADDR_VAR 0 2
23996: PUSH
23997: LD_VAR 0 4
24001: PUSH
24002: LD_INT 0
24004: PUSH
24005: LD_INT 0
24007: PUSH
24008: LD_VAR 0 11
24012: PUSH
24013: EMPTY
24014: LIST
24015: LIST
24016: LIST
24017: LIST
24018: ST_TO_ADDR
// exit ;
24019: GO 26709
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
24021: LD_EXP 50
24025: PUSH
24026: LD_VAR 0 1
24030: ARRAY
24031: PPUSH
24032: LD_INT 2
24034: PUSH
24035: LD_INT 30
24037: PUSH
24038: LD_INT 6
24040: PUSH
24041: EMPTY
24042: LIST
24043: LIST
24044: PUSH
24045: LD_INT 30
24047: PUSH
24048: LD_INT 7
24050: PUSH
24051: EMPTY
24052: LIST
24053: LIST
24054: PUSH
24055: LD_INT 30
24057: PUSH
24058: LD_INT 8
24060: PUSH
24061: EMPTY
24062: LIST
24063: LIST
24064: PUSH
24065: EMPTY
24066: LIST
24067: LIST
24068: LIST
24069: LIST
24070: PPUSH
24071: CALL_OW 72
24075: NOT
24076: PUSH
24077: LD_EXP 50
24081: PUSH
24082: LD_VAR 0 1
24086: ARRAY
24087: PPUSH
24088: LD_INT 30
24090: PUSH
24091: LD_INT 3
24093: PUSH
24094: EMPTY
24095: LIST
24096: LIST
24097: PPUSH
24098: CALL_OW 72
24102: NOT
24103: AND
24104: IFFALSE 24176
// begin if eng = tmp then
24106: LD_VAR 0 6
24110: PUSH
24111: LD_VAR 0 4
24115: EQUAL
24116: IFFALSE 24120
// exit ;
24118: GO 26709
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
24120: LD_ADDR_EXP 92
24124: PUSH
24125: LD_EXP 92
24129: PPUSH
24130: LD_VAR 0 1
24134: PPUSH
24135: LD_INT 1
24137: PPUSH
24138: CALL_OW 1
24142: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
24143: LD_ADDR_VAR 0 2
24147: PUSH
24148: LD_INT 0
24150: PUSH
24151: LD_VAR 0 4
24155: PUSH
24156: LD_VAR 0 6
24160: DIFF
24161: PUSH
24162: LD_INT 0
24164: PUSH
24165: LD_INT 0
24167: PUSH
24168: EMPTY
24169: LIST
24170: LIST
24171: LIST
24172: LIST
24173: ST_TO_ADDR
// exit ;
24174: GO 26709
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
24176: LD_EXP 77
24180: PUSH
24181: LD_EXP 76
24185: PUSH
24186: LD_VAR 0 1
24190: ARRAY
24191: ARRAY
24192: PUSH
24193: LD_EXP 50
24197: PUSH
24198: LD_VAR 0 1
24202: ARRAY
24203: PPUSH
24204: LD_INT 2
24206: PUSH
24207: LD_INT 30
24209: PUSH
24210: LD_INT 6
24212: PUSH
24213: EMPTY
24214: LIST
24215: LIST
24216: PUSH
24217: LD_INT 30
24219: PUSH
24220: LD_INT 7
24222: PUSH
24223: EMPTY
24224: LIST
24225: LIST
24226: PUSH
24227: LD_INT 30
24229: PUSH
24230: LD_INT 8
24232: PUSH
24233: EMPTY
24234: LIST
24235: LIST
24236: PUSH
24237: EMPTY
24238: LIST
24239: LIST
24240: LIST
24241: LIST
24242: PPUSH
24243: CALL_OW 72
24247: AND
24248: PUSH
24249: LD_EXP 50
24253: PUSH
24254: LD_VAR 0 1
24258: ARRAY
24259: PPUSH
24260: LD_INT 30
24262: PUSH
24263: LD_INT 3
24265: PUSH
24266: EMPTY
24267: LIST
24268: LIST
24269: PPUSH
24270: CALL_OW 72
24274: NOT
24275: AND
24276: IFFALSE 24490
// begin if sci >= 6 then
24278: LD_VAR 0 8
24282: PUSH
24283: LD_INT 6
24285: GREATEREQUAL
24286: IFFALSE 24290
// exit ;
24288: GO 26709
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
24290: LD_ADDR_EXP 92
24294: PUSH
24295: LD_EXP 92
24299: PPUSH
24300: LD_VAR 0 1
24304: PPUSH
24305: LD_INT 2
24307: PPUSH
24308: CALL_OW 1
24312: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
24313: LD_ADDR_VAR 0 9
24317: PUSH
24318: LD_VAR 0 4
24322: PUSH
24323: LD_VAR 0 8
24327: DIFF
24328: PPUSH
24329: LD_INT 4
24331: PPUSH
24332: CALL 84881 0 2
24336: ST_TO_ADDR
// p := [ ] ;
24337: LD_ADDR_VAR 0 11
24341: PUSH
24342: EMPTY
24343: ST_TO_ADDR
// if sci < 6 and sort > 6 then
24344: LD_VAR 0 8
24348: PUSH
24349: LD_INT 6
24351: LESS
24352: PUSH
24353: LD_VAR 0 9
24357: PUSH
24358: LD_INT 6
24360: GREATER
24361: AND
24362: IFFALSE 24443
// begin for i = 1 to 6 - sci do
24364: LD_ADDR_VAR 0 3
24368: PUSH
24369: DOUBLE
24370: LD_INT 1
24372: DEC
24373: ST_TO_ADDR
24374: LD_INT 6
24376: PUSH
24377: LD_VAR 0 8
24381: MINUS
24382: PUSH
24383: FOR_TO
24384: IFFALSE 24439
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
24386: LD_ADDR_VAR 0 11
24390: PUSH
24391: LD_VAR 0 11
24395: PPUSH
24396: LD_VAR 0 11
24400: PUSH
24401: LD_INT 1
24403: PLUS
24404: PPUSH
24405: LD_VAR 0 9
24409: PUSH
24410: LD_INT 1
24412: ARRAY
24413: PPUSH
24414: CALL_OW 2
24418: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
24419: LD_ADDR_VAR 0 9
24423: PUSH
24424: LD_VAR 0 9
24428: PPUSH
24429: LD_INT 1
24431: PPUSH
24432: CALL_OW 3
24436: ST_TO_ADDR
// end ;
24437: GO 24383
24439: POP
24440: POP
// end else
24441: GO 24463
// if sort then
24443: LD_VAR 0 9
24447: IFFALSE 24463
// p := sort [ 1 ] ;
24449: LD_ADDR_VAR 0 11
24453: PUSH
24454: LD_VAR 0 9
24458: PUSH
24459: LD_INT 1
24461: ARRAY
24462: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
24463: LD_ADDR_VAR 0 2
24467: PUSH
24468: LD_INT 0
24470: PUSH
24471: LD_INT 0
24473: PUSH
24474: LD_INT 0
24476: PUSH
24477: LD_VAR 0 11
24481: PUSH
24482: EMPTY
24483: LIST
24484: LIST
24485: LIST
24486: LIST
24487: ST_TO_ADDR
// exit ;
24488: GO 26709
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
24490: LD_EXP 77
24494: PUSH
24495: LD_EXP 76
24499: PUSH
24500: LD_VAR 0 1
24504: ARRAY
24505: ARRAY
24506: PUSH
24507: LD_EXP 50
24511: PUSH
24512: LD_VAR 0 1
24516: ARRAY
24517: PPUSH
24518: LD_INT 2
24520: PUSH
24521: LD_INT 30
24523: PUSH
24524: LD_INT 6
24526: PUSH
24527: EMPTY
24528: LIST
24529: LIST
24530: PUSH
24531: LD_INT 30
24533: PUSH
24534: LD_INT 7
24536: PUSH
24537: EMPTY
24538: LIST
24539: LIST
24540: PUSH
24541: LD_INT 30
24543: PUSH
24544: LD_INT 8
24546: PUSH
24547: EMPTY
24548: LIST
24549: LIST
24550: PUSH
24551: EMPTY
24552: LIST
24553: LIST
24554: LIST
24555: LIST
24556: PPUSH
24557: CALL_OW 72
24561: AND
24562: PUSH
24563: LD_EXP 50
24567: PUSH
24568: LD_VAR 0 1
24572: ARRAY
24573: PPUSH
24574: LD_INT 30
24576: PUSH
24577: LD_INT 3
24579: PUSH
24580: EMPTY
24581: LIST
24582: LIST
24583: PPUSH
24584: CALL_OW 72
24588: AND
24589: IFFALSE 25323
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
24591: LD_ADDR_EXP 92
24595: PUSH
24596: LD_EXP 92
24600: PPUSH
24601: LD_VAR 0 1
24605: PPUSH
24606: LD_INT 3
24608: PPUSH
24609: CALL_OW 1
24613: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
24614: LD_ADDR_VAR 0 2
24618: PUSH
24619: LD_INT 0
24621: PUSH
24622: LD_INT 0
24624: PUSH
24625: LD_INT 0
24627: PUSH
24628: LD_INT 0
24630: PUSH
24631: EMPTY
24632: LIST
24633: LIST
24634: LIST
24635: LIST
24636: ST_TO_ADDR
// if not eng then
24637: LD_VAR 0 6
24641: NOT
24642: IFFALSE 24705
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
24644: LD_ADDR_VAR 0 11
24648: PUSH
24649: LD_VAR 0 4
24653: PPUSH
24654: LD_INT 2
24656: PPUSH
24657: CALL 84881 0 2
24661: PUSH
24662: LD_INT 1
24664: ARRAY
24665: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
24666: LD_ADDR_VAR 0 2
24670: PUSH
24671: LD_VAR 0 2
24675: PPUSH
24676: LD_INT 2
24678: PPUSH
24679: LD_VAR 0 11
24683: PPUSH
24684: CALL_OW 1
24688: ST_TO_ADDR
// tmp := tmp diff p ;
24689: LD_ADDR_VAR 0 4
24693: PUSH
24694: LD_VAR 0 4
24698: PUSH
24699: LD_VAR 0 11
24703: DIFF
24704: ST_TO_ADDR
// end ; if tmp and sci < 6 then
24705: LD_VAR 0 4
24709: PUSH
24710: LD_VAR 0 8
24714: PUSH
24715: LD_INT 6
24717: LESS
24718: AND
24719: IFFALSE 24907
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
24721: LD_ADDR_VAR 0 9
24725: PUSH
24726: LD_VAR 0 4
24730: PUSH
24731: LD_VAR 0 8
24735: PUSH
24736: LD_VAR 0 7
24740: UNION
24741: DIFF
24742: PPUSH
24743: LD_INT 4
24745: PPUSH
24746: CALL 84881 0 2
24750: ST_TO_ADDR
// p := [ ] ;
24751: LD_ADDR_VAR 0 11
24755: PUSH
24756: EMPTY
24757: ST_TO_ADDR
// if sort then
24758: LD_VAR 0 9
24762: IFFALSE 24878
// for i = 1 to 6 - sci do
24764: LD_ADDR_VAR 0 3
24768: PUSH
24769: DOUBLE
24770: LD_INT 1
24772: DEC
24773: ST_TO_ADDR
24774: LD_INT 6
24776: PUSH
24777: LD_VAR 0 8
24781: MINUS
24782: PUSH
24783: FOR_TO
24784: IFFALSE 24876
// begin if i = sort then
24786: LD_VAR 0 3
24790: PUSH
24791: LD_VAR 0 9
24795: EQUAL
24796: IFFALSE 24800
// break ;
24798: GO 24876
// if GetClass ( i ) = 4 then
24800: LD_VAR 0 3
24804: PPUSH
24805: CALL_OW 257
24809: PUSH
24810: LD_INT 4
24812: EQUAL
24813: IFFALSE 24817
// continue ;
24815: GO 24783
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24817: LD_ADDR_VAR 0 11
24821: PUSH
24822: LD_VAR 0 11
24826: PPUSH
24827: LD_VAR 0 11
24831: PUSH
24832: LD_INT 1
24834: PLUS
24835: PPUSH
24836: LD_VAR 0 9
24840: PUSH
24841: LD_VAR 0 3
24845: ARRAY
24846: PPUSH
24847: CALL_OW 2
24851: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24852: LD_ADDR_VAR 0 4
24856: PUSH
24857: LD_VAR 0 4
24861: PUSH
24862: LD_VAR 0 9
24866: PUSH
24867: LD_VAR 0 3
24871: ARRAY
24872: DIFF
24873: ST_TO_ADDR
// end ;
24874: GO 24783
24876: POP
24877: POP
// if p then
24878: LD_VAR 0 11
24882: IFFALSE 24907
// result := Replace ( result , 4 , p ) ;
24884: LD_ADDR_VAR 0 2
24888: PUSH
24889: LD_VAR 0 2
24893: PPUSH
24894: LD_INT 4
24896: PPUSH
24897: LD_VAR 0 11
24901: PPUSH
24902: CALL_OW 1
24906: ST_TO_ADDR
// end ; if tmp and mech < 6 then
24907: LD_VAR 0 4
24911: PUSH
24912: LD_VAR 0 7
24916: PUSH
24917: LD_INT 6
24919: LESS
24920: AND
24921: IFFALSE 25109
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
24923: LD_ADDR_VAR 0 9
24927: PUSH
24928: LD_VAR 0 4
24932: PUSH
24933: LD_VAR 0 8
24937: PUSH
24938: LD_VAR 0 7
24942: UNION
24943: DIFF
24944: PPUSH
24945: LD_INT 3
24947: PPUSH
24948: CALL 84881 0 2
24952: ST_TO_ADDR
// p := [ ] ;
24953: LD_ADDR_VAR 0 11
24957: PUSH
24958: EMPTY
24959: ST_TO_ADDR
// if sort then
24960: LD_VAR 0 9
24964: IFFALSE 25080
// for i = 1 to 6 - mech do
24966: LD_ADDR_VAR 0 3
24970: PUSH
24971: DOUBLE
24972: LD_INT 1
24974: DEC
24975: ST_TO_ADDR
24976: LD_INT 6
24978: PUSH
24979: LD_VAR 0 7
24983: MINUS
24984: PUSH
24985: FOR_TO
24986: IFFALSE 25078
// begin if i = sort then
24988: LD_VAR 0 3
24992: PUSH
24993: LD_VAR 0 9
24997: EQUAL
24998: IFFALSE 25002
// break ;
25000: GO 25078
// if GetClass ( i ) = 3 then
25002: LD_VAR 0 3
25006: PPUSH
25007: CALL_OW 257
25011: PUSH
25012: LD_INT 3
25014: EQUAL
25015: IFFALSE 25019
// continue ;
25017: GO 24985
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25019: LD_ADDR_VAR 0 11
25023: PUSH
25024: LD_VAR 0 11
25028: PPUSH
25029: LD_VAR 0 11
25033: PUSH
25034: LD_INT 1
25036: PLUS
25037: PPUSH
25038: LD_VAR 0 9
25042: PUSH
25043: LD_VAR 0 3
25047: ARRAY
25048: PPUSH
25049: CALL_OW 2
25053: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25054: LD_ADDR_VAR 0 4
25058: PUSH
25059: LD_VAR 0 4
25063: PUSH
25064: LD_VAR 0 9
25068: PUSH
25069: LD_VAR 0 3
25073: ARRAY
25074: DIFF
25075: ST_TO_ADDR
// end ;
25076: GO 24985
25078: POP
25079: POP
// if p then
25080: LD_VAR 0 11
25084: IFFALSE 25109
// result := Replace ( result , 3 , p ) ;
25086: LD_ADDR_VAR 0 2
25090: PUSH
25091: LD_VAR 0 2
25095: PPUSH
25096: LD_INT 3
25098: PPUSH
25099: LD_VAR 0 11
25103: PPUSH
25104: CALL_OW 1
25108: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
25109: LD_VAR 0 4
25113: PUSH
25114: LD_INT 6
25116: GREATER
25117: PUSH
25118: LD_VAR 0 6
25122: PUSH
25123: LD_INT 6
25125: LESS
25126: AND
25127: IFFALSE 25321
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
25129: LD_ADDR_VAR 0 9
25133: PUSH
25134: LD_VAR 0 4
25138: PUSH
25139: LD_VAR 0 8
25143: PUSH
25144: LD_VAR 0 7
25148: UNION
25149: PUSH
25150: LD_VAR 0 6
25154: UNION
25155: DIFF
25156: PPUSH
25157: LD_INT 2
25159: PPUSH
25160: CALL 84881 0 2
25164: ST_TO_ADDR
// p := [ ] ;
25165: LD_ADDR_VAR 0 11
25169: PUSH
25170: EMPTY
25171: ST_TO_ADDR
// if sort then
25172: LD_VAR 0 9
25176: IFFALSE 25292
// for i = 1 to 6 - eng do
25178: LD_ADDR_VAR 0 3
25182: PUSH
25183: DOUBLE
25184: LD_INT 1
25186: DEC
25187: ST_TO_ADDR
25188: LD_INT 6
25190: PUSH
25191: LD_VAR 0 6
25195: MINUS
25196: PUSH
25197: FOR_TO
25198: IFFALSE 25290
// begin if i = sort then
25200: LD_VAR 0 3
25204: PUSH
25205: LD_VAR 0 9
25209: EQUAL
25210: IFFALSE 25214
// break ;
25212: GO 25290
// if GetClass ( i ) = 2 then
25214: LD_VAR 0 3
25218: PPUSH
25219: CALL_OW 257
25223: PUSH
25224: LD_INT 2
25226: EQUAL
25227: IFFALSE 25231
// continue ;
25229: GO 25197
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25231: LD_ADDR_VAR 0 11
25235: PUSH
25236: LD_VAR 0 11
25240: PPUSH
25241: LD_VAR 0 11
25245: PUSH
25246: LD_INT 1
25248: PLUS
25249: PPUSH
25250: LD_VAR 0 9
25254: PUSH
25255: LD_VAR 0 3
25259: ARRAY
25260: PPUSH
25261: CALL_OW 2
25265: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25266: LD_ADDR_VAR 0 4
25270: PUSH
25271: LD_VAR 0 4
25275: PUSH
25276: LD_VAR 0 9
25280: PUSH
25281: LD_VAR 0 3
25285: ARRAY
25286: DIFF
25287: ST_TO_ADDR
// end ;
25288: GO 25197
25290: POP
25291: POP
// if p then
25292: LD_VAR 0 11
25296: IFFALSE 25321
// result := Replace ( result , 2 , p ) ;
25298: LD_ADDR_VAR 0 2
25302: PUSH
25303: LD_VAR 0 2
25307: PPUSH
25308: LD_INT 2
25310: PPUSH
25311: LD_VAR 0 11
25315: PPUSH
25316: CALL_OW 1
25320: ST_TO_ADDR
// end ; exit ;
25321: GO 26709
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
25323: LD_EXP 77
25327: PUSH
25328: LD_EXP 76
25332: PUSH
25333: LD_VAR 0 1
25337: ARRAY
25338: ARRAY
25339: NOT
25340: PUSH
25341: LD_EXP 50
25345: PUSH
25346: LD_VAR 0 1
25350: ARRAY
25351: PPUSH
25352: LD_INT 30
25354: PUSH
25355: LD_INT 3
25357: PUSH
25358: EMPTY
25359: LIST
25360: LIST
25361: PPUSH
25362: CALL_OW 72
25366: AND
25367: PUSH
25368: LD_EXP 55
25372: PUSH
25373: LD_VAR 0 1
25377: ARRAY
25378: AND
25379: IFFALSE 25987
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
25381: LD_ADDR_EXP 92
25385: PUSH
25386: LD_EXP 92
25390: PPUSH
25391: LD_VAR 0 1
25395: PPUSH
25396: LD_INT 5
25398: PPUSH
25399: CALL_OW 1
25403: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
25404: LD_ADDR_VAR 0 2
25408: PUSH
25409: LD_INT 0
25411: PUSH
25412: LD_INT 0
25414: PUSH
25415: LD_INT 0
25417: PUSH
25418: LD_INT 0
25420: PUSH
25421: EMPTY
25422: LIST
25423: LIST
25424: LIST
25425: LIST
25426: ST_TO_ADDR
// if sci > 1 then
25427: LD_VAR 0 8
25431: PUSH
25432: LD_INT 1
25434: GREATER
25435: IFFALSE 25463
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
25437: LD_ADDR_VAR 0 4
25441: PUSH
25442: LD_VAR 0 4
25446: PUSH
25447: LD_VAR 0 8
25451: PUSH
25452: LD_VAR 0 8
25456: PUSH
25457: LD_INT 1
25459: ARRAY
25460: DIFF
25461: DIFF
25462: ST_TO_ADDR
// if tmp and not sci then
25463: LD_VAR 0 4
25467: PUSH
25468: LD_VAR 0 8
25472: NOT
25473: AND
25474: IFFALSE 25543
// begin sort := SortBySkill ( tmp , 4 ) ;
25476: LD_ADDR_VAR 0 9
25480: PUSH
25481: LD_VAR 0 4
25485: PPUSH
25486: LD_INT 4
25488: PPUSH
25489: CALL 84881 0 2
25493: ST_TO_ADDR
// if sort then
25494: LD_VAR 0 9
25498: IFFALSE 25514
// p := sort [ 1 ] ;
25500: LD_ADDR_VAR 0 11
25504: PUSH
25505: LD_VAR 0 9
25509: PUSH
25510: LD_INT 1
25512: ARRAY
25513: ST_TO_ADDR
// if p then
25514: LD_VAR 0 11
25518: IFFALSE 25543
// result := Replace ( result , 4 , p ) ;
25520: LD_ADDR_VAR 0 2
25524: PUSH
25525: LD_VAR 0 2
25529: PPUSH
25530: LD_INT 4
25532: PPUSH
25533: LD_VAR 0 11
25537: PPUSH
25538: CALL_OW 1
25542: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
25543: LD_ADDR_VAR 0 4
25547: PUSH
25548: LD_VAR 0 4
25552: PUSH
25553: LD_VAR 0 7
25557: DIFF
25558: ST_TO_ADDR
// if tmp and mech < 6 then
25559: LD_VAR 0 4
25563: PUSH
25564: LD_VAR 0 7
25568: PUSH
25569: LD_INT 6
25571: LESS
25572: AND
25573: IFFALSE 25761
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
25575: LD_ADDR_VAR 0 9
25579: PUSH
25580: LD_VAR 0 4
25584: PUSH
25585: LD_VAR 0 8
25589: PUSH
25590: LD_VAR 0 7
25594: UNION
25595: DIFF
25596: PPUSH
25597: LD_INT 3
25599: PPUSH
25600: CALL 84881 0 2
25604: ST_TO_ADDR
// p := [ ] ;
25605: LD_ADDR_VAR 0 11
25609: PUSH
25610: EMPTY
25611: ST_TO_ADDR
// if sort then
25612: LD_VAR 0 9
25616: IFFALSE 25732
// for i = 1 to 6 - mech do
25618: LD_ADDR_VAR 0 3
25622: PUSH
25623: DOUBLE
25624: LD_INT 1
25626: DEC
25627: ST_TO_ADDR
25628: LD_INT 6
25630: PUSH
25631: LD_VAR 0 7
25635: MINUS
25636: PUSH
25637: FOR_TO
25638: IFFALSE 25730
// begin if i = sort then
25640: LD_VAR 0 3
25644: PUSH
25645: LD_VAR 0 9
25649: EQUAL
25650: IFFALSE 25654
// break ;
25652: GO 25730
// if GetClass ( i ) = 3 then
25654: LD_VAR 0 3
25658: PPUSH
25659: CALL_OW 257
25663: PUSH
25664: LD_INT 3
25666: EQUAL
25667: IFFALSE 25671
// continue ;
25669: GO 25637
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25671: LD_ADDR_VAR 0 11
25675: PUSH
25676: LD_VAR 0 11
25680: PPUSH
25681: LD_VAR 0 11
25685: PUSH
25686: LD_INT 1
25688: PLUS
25689: PPUSH
25690: LD_VAR 0 9
25694: PUSH
25695: LD_VAR 0 3
25699: ARRAY
25700: PPUSH
25701: CALL_OW 2
25705: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25706: LD_ADDR_VAR 0 4
25710: PUSH
25711: LD_VAR 0 4
25715: PUSH
25716: LD_VAR 0 9
25720: PUSH
25721: LD_VAR 0 3
25725: ARRAY
25726: DIFF
25727: ST_TO_ADDR
// end ;
25728: GO 25637
25730: POP
25731: POP
// if p then
25732: LD_VAR 0 11
25736: IFFALSE 25761
// result := Replace ( result , 3 , p ) ;
25738: LD_ADDR_VAR 0 2
25742: PUSH
25743: LD_VAR 0 2
25747: PPUSH
25748: LD_INT 3
25750: PPUSH
25751: LD_VAR 0 11
25755: PPUSH
25756: CALL_OW 1
25760: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
25761: LD_ADDR_VAR 0 4
25765: PUSH
25766: LD_VAR 0 4
25770: PUSH
25771: LD_VAR 0 6
25775: DIFF
25776: ST_TO_ADDR
// if tmp and eng < 6 then
25777: LD_VAR 0 4
25781: PUSH
25782: LD_VAR 0 6
25786: PUSH
25787: LD_INT 6
25789: LESS
25790: AND
25791: IFFALSE 25985
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
25793: LD_ADDR_VAR 0 9
25797: PUSH
25798: LD_VAR 0 4
25802: PUSH
25803: LD_VAR 0 8
25807: PUSH
25808: LD_VAR 0 7
25812: UNION
25813: PUSH
25814: LD_VAR 0 6
25818: UNION
25819: DIFF
25820: PPUSH
25821: LD_INT 2
25823: PPUSH
25824: CALL 84881 0 2
25828: ST_TO_ADDR
// p := [ ] ;
25829: LD_ADDR_VAR 0 11
25833: PUSH
25834: EMPTY
25835: ST_TO_ADDR
// if sort then
25836: LD_VAR 0 9
25840: IFFALSE 25956
// for i = 1 to 6 - eng do
25842: LD_ADDR_VAR 0 3
25846: PUSH
25847: DOUBLE
25848: LD_INT 1
25850: DEC
25851: ST_TO_ADDR
25852: LD_INT 6
25854: PUSH
25855: LD_VAR 0 6
25859: MINUS
25860: PUSH
25861: FOR_TO
25862: IFFALSE 25954
// begin if i = sort then
25864: LD_VAR 0 3
25868: PUSH
25869: LD_VAR 0 9
25873: EQUAL
25874: IFFALSE 25878
// break ;
25876: GO 25954
// if GetClass ( i ) = 2 then
25878: LD_VAR 0 3
25882: PPUSH
25883: CALL_OW 257
25887: PUSH
25888: LD_INT 2
25890: EQUAL
25891: IFFALSE 25895
// continue ;
25893: GO 25861
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25895: LD_ADDR_VAR 0 11
25899: PUSH
25900: LD_VAR 0 11
25904: PPUSH
25905: LD_VAR 0 11
25909: PUSH
25910: LD_INT 1
25912: PLUS
25913: PPUSH
25914: LD_VAR 0 9
25918: PUSH
25919: LD_VAR 0 3
25923: ARRAY
25924: PPUSH
25925: CALL_OW 2
25929: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25930: LD_ADDR_VAR 0 4
25934: PUSH
25935: LD_VAR 0 4
25939: PUSH
25940: LD_VAR 0 9
25944: PUSH
25945: LD_VAR 0 3
25949: ARRAY
25950: DIFF
25951: ST_TO_ADDR
// end ;
25952: GO 25861
25954: POP
25955: POP
// if p then
25956: LD_VAR 0 11
25960: IFFALSE 25985
// result := Replace ( result , 2 , p ) ;
25962: LD_ADDR_VAR 0 2
25966: PUSH
25967: LD_VAR 0 2
25971: PPUSH
25972: LD_INT 2
25974: PPUSH
25975: LD_VAR 0 11
25979: PPUSH
25980: CALL_OW 1
25984: ST_TO_ADDR
// end ; exit ;
25985: GO 26709
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
25987: LD_EXP 77
25991: PUSH
25992: LD_EXP 76
25996: PUSH
25997: LD_VAR 0 1
26001: ARRAY
26002: ARRAY
26003: NOT
26004: PUSH
26005: LD_EXP 50
26009: PUSH
26010: LD_VAR 0 1
26014: ARRAY
26015: PPUSH
26016: LD_INT 30
26018: PUSH
26019: LD_INT 3
26021: PUSH
26022: EMPTY
26023: LIST
26024: LIST
26025: PPUSH
26026: CALL_OW 72
26030: AND
26031: PUSH
26032: LD_EXP 55
26036: PUSH
26037: LD_VAR 0 1
26041: ARRAY
26042: NOT
26043: AND
26044: IFFALSE 26709
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
26046: LD_ADDR_EXP 92
26050: PUSH
26051: LD_EXP 92
26055: PPUSH
26056: LD_VAR 0 1
26060: PPUSH
26061: LD_INT 6
26063: PPUSH
26064: CALL_OW 1
26068: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
26069: LD_ADDR_VAR 0 2
26073: PUSH
26074: LD_INT 0
26076: PUSH
26077: LD_INT 0
26079: PUSH
26080: LD_INT 0
26082: PUSH
26083: LD_INT 0
26085: PUSH
26086: EMPTY
26087: LIST
26088: LIST
26089: LIST
26090: LIST
26091: ST_TO_ADDR
// if sci >= 1 then
26092: LD_VAR 0 8
26096: PUSH
26097: LD_INT 1
26099: GREATEREQUAL
26100: IFFALSE 26122
// tmp := tmp diff sci [ 1 ] ;
26102: LD_ADDR_VAR 0 4
26106: PUSH
26107: LD_VAR 0 4
26111: PUSH
26112: LD_VAR 0 8
26116: PUSH
26117: LD_INT 1
26119: ARRAY
26120: DIFF
26121: ST_TO_ADDR
// if tmp and not sci then
26122: LD_VAR 0 4
26126: PUSH
26127: LD_VAR 0 8
26131: NOT
26132: AND
26133: IFFALSE 26202
// begin sort := SortBySkill ( tmp , 4 ) ;
26135: LD_ADDR_VAR 0 9
26139: PUSH
26140: LD_VAR 0 4
26144: PPUSH
26145: LD_INT 4
26147: PPUSH
26148: CALL 84881 0 2
26152: ST_TO_ADDR
// if sort then
26153: LD_VAR 0 9
26157: IFFALSE 26173
// p := sort [ 1 ] ;
26159: LD_ADDR_VAR 0 11
26163: PUSH
26164: LD_VAR 0 9
26168: PUSH
26169: LD_INT 1
26171: ARRAY
26172: ST_TO_ADDR
// if p then
26173: LD_VAR 0 11
26177: IFFALSE 26202
// result := Replace ( result , 4 , p ) ;
26179: LD_ADDR_VAR 0 2
26183: PUSH
26184: LD_VAR 0 2
26188: PPUSH
26189: LD_INT 4
26191: PPUSH
26192: LD_VAR 0 11
26196: PPUSH
26197: CALL_OW 1
26201: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
26202: LD_ADDR_VAR 0 4
26206: PUSH
26207: LD_VAR 0 4
26211: PUSH
26212: LD_VAR 0 7
26216: DIFF
26217: ST_TO_ADDR
// if tmp and mech < 6 then
26218: LD_VAR 0 4
26222: PUSH
26223: LD_VAR 0 7
26227: PUSH
26228: LD_INT 6
26230: LESS
26231: AND
26232: IFFALSE 26414
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
26234: LD_ADDR_VAR 0 9
26238: PUSH
26239: LD_VAR 0 4
26243: PUSH
26244: LD_VAR 0 7
26248: DIFF
26249: PPUSH
26250: LD_INT 3
26252: PPUSH
26253: CALL 84881 0 2
26257: ST_TO_ADDR
// p := [ ] ;
26258: LD_ADDR_VAR 0 11
26262: PUSH
26263: EMPTY
26264: ST_TO_ADDR
// if sort then
26265: LD_VAR 0 9
26269: IFFALSE 26385
// for i = 1 to 6 - mech do
26271: LD_ADDR_VAR 0 3
26275: PUSH
26276: DOUBLE
26277: LD_INT 1
26279: DEC
26280: ST_TO_ADDR
26281: LD_INT 6
26283: PUSH
26284: LD_VAR 0 7
26288: MINUS
26289: PUSH
26290: FOR_TO
26291: IFFALSE 26383
// begin if i = sort then
26293: LD_VAR 0 3
26297: PUSH
26298: LD_VAR 0 9
26302: EQUAL
26303: IFFALSE 26307
// break ;
26305: GO 26383
// if GetClass ( i ) = 3 then
26307: LD_VAR 0 3
26311: PPUSH
26312: CALL_OW 257
26316: PUSH
26317: LD_INT 3
26319: EQUAL
26320: IFFALSE 26324
// continue ;
26322: GO 26290
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26324: LD_ADDR_VAR 0 11
26328: PUSH
26329: LD_VAR 0 11
26333: PPUSH
26334: LD_VAR 0 11
26338: PUSH
26339: LD_INT 1
26341: PLUS
26342: PPUSH
26343: LD_VAR 0 9
26347: PUSH
26348: LD_VAR 0 3
26352: ARRAY
26353: PPUSH
26354: CALL_OW 2
26358: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26359: LD_ADDR_VAR 0 4
26363: PUSH
26364: LD_VAR 0 4
26368: PUSH
26369: LD_VAR 0 9
26373: PUSH
26374: LD_VAR 0 3
26378: ARRAY
26379: DIFF
26380: ST_TO_ADDR
// end ;
26381: GO 26290
26383: POP
26384: POP
// if p then
26385: LD_VAR 0 11
26389: IFFALSE 26414
// result := Replace ( result , 3 , p ) ;
26391: LD_ADDR_VAR 0 2
26395: PUSH
26396: LD_VAR 0 2
26400: PPUSH
26401: LD_INT 3
26403: PPUSH
26404: LD_VAR 0 11
26408: PPUSH
26409: CALL_OW 1
26413: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
26414: LD_ADDR_VAR 0 4
26418: PUSH
26419: LD_VAR 0 4
26423: PUSH
26424: LD_VAR 0 6
26428: DIFF
26429: ST_TO_ADDR
// if tmp and eng < 4 then
26430: LD_VAR 0 4
26434: PUSH
26435: LD_VAR 0 6
26439: PUSH
26440: LD_INT 4
26442: LESS
26443: AND
26444: IFFALSE 26634
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
26446: LD_ADDR_VAR 0 9
26450: PUSH
26451: LD_VAR 0 4
26455: PUSH
26456: LD_VAR 0 7
26460: PUSH
26461: LD_VAR 0 6
26465: UNION
26466: DIFF
26467: PPUSH
26468: LD_INT 2
26470: PPUSH
26471: CALL 84881 0 2
26475: ST_TO_ADDR
// p := [ ] ;
26476: LD_ADDR_VAR 0 11
26480: PUSH
26481: EMPTY
26482: ST_TO_ADDR
// if sort then
26483: LD_VAR 0 9
26487: IFFALSE 26603
// for i = 1 to 4 - eng do
26489: LD_ADDR_VAR 0 3
26493: PUSH
26494: DOUBLE
26495: LD_INT 1
26497: DEC
26498: ST_TO_ADDR
26499: LD_INT 4
26501: PUSH
26502: LD_VAR 0 6
26506: MINUS
26507: PUSH
26508: FOR_TO
26509: IFFALSE 26601
// begin if i = sort then
26511: LD_VAR 0 3
26515: PUSH
26516: LD_VAR 0 9
26520: EQUAL
26521: IFFALSE 26525
// break ;
26523: GO 26601
// if GetClass ( i ) = 2 then
26525: LD_VAR 0 3
26529: PPUSH
26530: CALL_OW 257
26534: PUSH
26535: LD_INT 2
26537: EQUAL
26538: IFFALSE 26542
// continue ;
26540: GO 26508
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26542: LD_ADDR_VAR 0 11
26546: PUSH
26547: LD_VAR 0 11
26551: PPUSH
26552: LD_VAR 0 11
26556: PUSH
26557: LD_INT 1
26559: PLUS
26560: PPUSH
26561: LD_VAR 0 9
26565: PUSH
26566: LD_VAR 0 3
26570: ARRAY
26571: PPUSH
26572: CALL_OW 2
26576: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26577: LD_ADDR_VAR 0 4
26581: PUSH
26582: LD_VAR 0 4
26586: PUSH
26587: LD_VAR 0 9
26591: PUSH
26592: LD_VAR 0 3
26596: ARRAY
26597: DIFF
26598: ST_TO_ADDR
// end ;
26599: GO 26508
26601: POP
26602: POP
// if p then
26603: LD_VAR 0 11
26607: IFFALSE 26632
// result := Replace ( result , 2 , p ) ;
26609: LD_ADDR_VAR 0 2
26613: PUSH
26614: LD_VAR 0 2
26618: PPUSH
26619: LD_INT 2
26621: PPUSH
26622: LD_VAR 0 11
26626: PPUSH
26627: CALL_OW 1
26631: ST_TO_ADDR
// end else
26632: GO 26678
// for i = eng downto 5 do
26634: LD_ADDR_VAR 0 3
26638: PUSH
26639: DOUBLE
26640: LD_VAR 0 6
26644: INC
26645: ST_TO_ADDR
26646: LD_INT 5
26648: PUSH
26649: FOR_DOWNTO
26650: IFFALSE 26676
// tmp := tmp union eng [ i ] ;
26652: LD_ADDR_VAR 0 4
26656: PUSH
26657: LD_VAR 0 4
26661: PUSH
26662: LD_VAR 0 6
26666: PUSH
26667: LD_VAR 0 3
26671: ARRAY
26672: UNION
26673: ST_TO_ADDR
26674: GO 26649
26676: POP
26677: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
26678: LD_ADDR_VAR 0 2
26682: PUSH
26683: LD_VAR 0 2
26687: PPUSH
26688: LD_INT 1
26690: PPUSH
26691: LD_VAR 0 4
26695: PUSH
26696: LD_VAR 0 5
26700: DIFF
26701: PPUSH
26702: CALL_OW 1
26706: ST_TO_ADDR
// exit ;
26707: GO 26709
// end ; end ;
26709: LD_VAR 0 2
26713: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
26714: LD_INT 0
26716: PPUSH
26717: PPUSH
26718: PPUSH
// if not mc_bases then
26719: LD_EXP 50
26723: NOT
26724: IFFALSE 26728
// exit ;
26726: GO 26870
// for i = 1 to mc_bases do
26728: LD_ADDR_VAR 0 2
26732: PUSH
26733: DOUBLE
26734: LD_INT 1
26736: DEC
26737: ST_TO_ADDR
26738: LD_EXP 50
26742: PUSH
26743: FOR_TO
26744: IFFALSE 26861
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
26746: LD_ADDR_VAR 0 3
26750: PUSH
26751: LD_EXP 50
26755: PUSH
26756: LD_VAR 0 2
26760: ARRAY
26761: PPUSH
26762: LD_INT 21
26764: PUSH
26765: LD_INT 3
26767: PUSH
26768: EMPTY
26769: LIST
26770: LIST
26771: PUSH
26772: LD_INT 3
26774: PUSH
26775: LD_INT 2
26777: PUSH
26778: LD_INT 30
26780: PUSH
26781: LD_INT 29
26783: PUSH
26784: EMPTY
26785: LIST
26786: LIST
26787: PUSH
26788: LD_INT 30
26790: PUSH
26791: LD_INT 30
26793: PUSH
26794: EMPTY
26795: LIST
26796: LIST
26797: PUSH
26798: EMPTY
26799: LIST
26800: LIST
26801: LIST
26802: PUSH
26803: EMPTY
26804: LIST
26805: LIST
26806: PUSH
26807: LD_INT 3
26809: PUSH
26810: LD_INT 24
26812: PUSH
26813: LD_INT 1000
26815: PUSH
26816: EMPTY
26817: LIST
26818: LIST
26819: PUSH
26820: EMPTY
26821: LIST
26822: LIST
26823: PUSH
26824: EMPTY
26825: LIST
26826: LIST
26827: LIST
26828: PPUSH
26829: CALL_OW 72
26833: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
26834: LD_ADDR_EXP 51
26838: PUSH
26839: LD_EXP 51
26843: PPUSH
26844: LD_VAR 0 2
26848: PPUSH
26849: LD_VAR 0 3
26853: PPUSH
26854: CALL_OW 1
26858: ST_TO_ADDR
// end ;
26859: GO 26743
26861: POP
26862: POP
// RaiseSailEvent ( 101 ) ;
26863: LD_INT 101
26865: PPUSH
26866: CALL_OW 427
// end ;
26870: LD_VAR 0 1
26874: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
26875: LD_INT 0
26877: PPUSH
26878: PPUSH
26879: PPUSH
26880: PPUSH
26881: PPUSH
26882: PPUSH
26883: PPUSH
// if not mc_bases then
26884: LD_EXP 50
26888: NOT
26889: IFFALSE 26893
// exit ;
26891: GO 27455
// for i = 1 to mc_bases do
26893: LD_ADDR_VAR 0 2
26897: PUSH
26898: DOUBLE
26899: LD_INT 1
26901: DEC
26902: ST_TO_ADDR
26903: LD_EXP 50
26907: PUSH
26908: FOR_TO
26909: IFFALSE 27446
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
26911: LD_ADDR_VAR 0 5
26915: PUSH
26916: LD_EXP 50
26920: PUSH
26921: LD_VAR 0 2
26925: ARRAY
26926: PUSH
26927: LD_EXP 79
26931: PUSH
26932: LD_VAR 0 2
26936: ARRAY
26937: UNION
26938: PPUSH
26939: LD_INT 21
26941: PUSH
26942: LD_INT 1
26944: PUSH
26945: EMPTY
26946: LIST
26947: LIST
26948: PUSH
26949: LD_INT 1
26951: PUSH
26952: LD_INT 3
26954: PUSH
26955: LD_INT 54
26957: PUSH
26958: EMPTY
26959: LIST
26960: PUSH
26961: EMPTY
26962: LIST
26963: LIST
26964: PUSH
26965: LD_INT 3
26967: PUSH
26968: LD_INT 24
26970: PUSH
26971: LD_INT 1000
26973: PUSH
26974: EMPTY
26975: LIST
26976: LIST
26977: PUSH
26978: EMPTY
26979: LIST
26980: LIST
26981: PUSH
26982: EMPTY
26983: LIST
26984: LIST
26985: LIST
26986: PUSH
26987: EMPTY
26988: LIST
26989: LIST
26990: PPUSH
26991: CALL_OW 72
26995: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
26996: LD_ADDR_VAR 0 6
27000: PUSH
27001: LD_EXP 50
27005: PUSH
27006: LD_VAR 0 2
27010: ARRAY
27011: PPUSH
27012: LD_INT 21
27014: PUSH
27015: LD_INT 1
27017: PUSH
27018: EMPTY
27019: LIST
27020: LIST
27021: PUSH
27022: LD_INT 1
27024: PUSH
27025: LD_INT 3
27027: PUSH
27028: LD_INT 54
27030: PUSH
27031: EMPTY
27032: LIST
27033: PUSH
27034: EMPTY
27035: LIST
27036: LIST
27037: PUSH
27038: LD_INT 3
27040: PUSH
27041: LD_INT 24
27043: PUSH
27044: LD_INT 250
27046: PUSH
27047: EMPTY
27048: LIST
27049: LIST
27050: PUSH
27051: EMPTY
27052: LIST
27053: LIST
27054: PUSH
27055: EMPTY
27056: LIST
27057: LIST
27058: LIST
27059: PUSH
27060: EMPTY
27061: LIST
27062: LIST
27063: PPUSH
27064: CALL_OW 72
27068: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
27069: LD_ADDR_VAR 0 7
27073: PUSH
27074: LD_VAR 0 5
27078: PUSH
27079: LD_VAR 0 6
27083: DIFF
27084: ST_TO_ADDR
// if not need_heal_1 then
27085: LD_VAR 0 6
27089: NOT
27090: IFFALSE 27123
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
27092: LD_ADDR_EXP 53
27096: PUSH
27097: LD_EXP 53
27101: PPUSH
27102: LD_VAR 0 2
27106: PUSH
27107: LD_INT 1
27109: PUSH
27110: EMPTY
27111: LIST
27112: LIST
27113: PPUSH
27114: EMPTY
27115: PPUSH
27116: CALL 54034 0 3
27120: ST_TO_ADDR
27121: GO 27193
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
27123: LD_ADDR_EXP 53
27127: PUSH
27128: LD_EXP 53
27132: PPUSH
27133: LD_VAR 0 2
27137: PUSH
27138: LD_INT 1
27140: PUSH
27141: EMPTY
27142: LIST
27143: LIST
27144: PPUSH
27145: LD_EXP 53
27149: PUSH
27150: LD_VAR 0 2
27154: ARRAY
27155: PUSH
27156: LD_INT 1
27158: ARRAY
27159: PPUSH
27160: LD_INT 3
27162: PUSH
27163: LD_INT 24
27165: PUSH
27166: LD_INT 1000
27168: PUSH
27169: EMPTY
27170: LIST
27171: LIST
27172: PUSH
27173: EMPTY
27174: LIST
27175: LIST
27176: PPUSH
27177: CALL_OW 72
27181: PUSH
27182: LD_VAR 0 6
27186: UNION
27187: PPUSH
27188: CALL 54034 0 3
27192: ST_TO_ADDR
// if not need_heal_2 then
27193: LD_VAR 0 7
27197: NOT
27198: IFFALSE 27231
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
27200: LD_ADDR_EXP 53
27204: PUSH
27205: LD_EXP 53
27209: PPUSH
27210: LD_VAR 0 2
27214: PUSH
27215: LD_INT 2
27217: PUSH
27218: EMPTY
27219: LIST
27220: LIST
27221: PPUSH
27222: EMPTY
27223: PPUSH
27224: CALL 54034 0 3
27228: ST_TO_ADDR
27229: GO 27263
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
27231: LD_ADDR_EXP 53
27235: PUSH
27236: LD_EXP 53
27240: PPUSH
27241: LD_VAR 0 2
27245: PUSH
27246: LD_INT 2
27248: PUSH
27249: EMPTY
27250: LIST
27251: LIST
27252: PPUSH
27253: LD_VAR 0 7
27257: PPUSH
27258: CALL 54034 0 3
27262: ST_TO_ADDR
// if need_heal_2 then
27263: LD_VAR 0 7
27267: IFFALSE 27428
// for j in need_heal_2 do
27269: LD_ADDR_VAR 0 3
27273: PUSH
27274: LD_VAR 0 7
27278: PUSH
27279: FOR_IN
27280: IFFALSE 27426
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
27282: LD_ADDR_VAR 0 5
27286: PUSH
27287: LD_EXP 50
27291: PUSH
27292: LD_VAR 0 2
27296: ARRAY
27297: PPUSH
27298: LD_INT 2
27300: PUSH
27301: LD_INT 30
27303: PUSH
27304: LD_INT 6
27306: PUSH
27307: EMPTY
27308: LIST
27309: LIST
27310: PUSH
27311: LD_INT 30
27313: PUSH
27314: LD_INT 7
27316: PUSH
27317: EMPTY
27318: LIST
27319: LIST
27320: PUSH
27321: LD_INT 30
27323: PUSH
27324: LD_INT 8
27326: PUSH
27327: EMPTY
27328: LIST
27329: LIST
27330: PUSH
27331: LD_INT 30
27333: PUSH
27334: LD_INT 0
27336: PUSH
27337: EMPTY
27338: LIST
27339: LIST
27340: PUSH
27341: LD_INT 30
27343: PUSH
27344: LD_INT 1
27346: PUSH
27347: EMPTY
27348: LIST
27349: LIST
27350: PUSH
27351: EMPTY
27352: LIST
27353: LIST
27354: LIST
27355: LIST
27356: LIST
27357: LIST
27358: PPUSH
27359: CALL_OW 72
27363: ST_TO_ADDR
// if tmp then
27364: LD_VAR 0 5
27368: IFFALSE 27424
// begin k := NearestUnitToUnit ( tmp , j ) ;
27370: LD_ADDR_VAR 0 4
27374: PUSH
27375: LD_VAR 0 5
27379: PPUSH
27380: LD_VAR 0 3
27384: PPUSH
27385: CALL_OW 74
27389: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
27390: LD_VAR 0 3
27394: PPUSH
27395: LD_VAR 0 4
27399: PPUSH
27400: CALL_OW 296
27404: PUSH
27405: LD_INT 5
27407: GREATER
27408: IFFALSE 27424
// ComMoveToNearbyEntrance ( j , k ) ;
27410: LD_VAR 0 3
27414: PPUSH
27415: LD_VAR 0 4
27419: PPUSH
27420: CALL 87241 0 2
// end ; end ;
27424: GO 27279
27426: POP
27427: POP
// if not need_heal_1 and not need_heal_2 then
27428: LD_VAR 0 6
27432: NOT
27433: PUSH
27434: LD_VAR 0 7
27438: NOT
27439: AND
27440: IFFALSE 27444
// continue ;
27442: GO 26908
// end ;
27444: GO 26908
27446: POP
27447: POP
// RaiseSailEvent ( 102 ) ;
27448: LD_INT 102
27450: PPUSH
27451: CALL_OW 427
// end ;
27455: LD_VAR 0 1
27459: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
27460: LD_INT 0
27462: PPUSH
27463: PPUSH
27464: PPUSH
27465: PPUSH
27466: PPUSH
27467: PPUSH
27468: PPUSH
27469: PPUSH
// if not mc_bases then
27470: LD_EXP 50
27474: NOT
27475: IFFALSE 27479
// exit ;
27477: GO 28390
// for i = 1 to mc_bases do
27479: LD_ADDR_VAR 0 2
27483: PUSH
27484: DOUBLE
27485: LD_INT 1
27487: DEC
27488: ST_TO_ADDR
27489: LD_EXP 50
27493: PUSH
27494: FOR_TO
27495: IFFALSE 28388
// begin if not mc_building_need_repair [ i ] then
27497: LD_EXP 51
27501: PUSH
27502: LD_VAR 0 2
27506: ARRAY
27507: NOT
27508: IFFALSE 27693
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
27510: LD_ADDR_VAR 0 6
27514: PUSH
27515: LD_EXP 69
27519: PUSH
27520: LD_VAR 0 2
27524: ARRAY
27525: PPUSH
27526: LD_INT 3
27528: PUSH
27529: LD_INT 24
27531: PUSH
27532: LD_INT 1000
27534: PUSH
27535: EMPTY
27536: LIST
27537: LIST
27538: PUSH
27539: EMPTY
27540: LIST
27541: LIST
27542: PUSH
27543: LD_INT 2
27545: PUSH
27546: LD_INT 34
27548: PUSH
27549: LD_INT 13
27551: PUSH
27552: EMPTY
27553: LIST
27554: LIST
27555: PUSH
27556: LD_INT 34
27558: PUSH
27559: LD_INT 52
27561: PUSH
27562: EMPTY
27563: LIST
27564: LIST
27565: PUSH
27566: LD_INT 34
27568: PUSH
27569: LD_INT 88
27571: PUSH
27572: EMPTY
27573: LIST
27574: LIST
27575: PUSH
27576: EMPTY
27577: LIST
27578: LIST
27579: LIST
27580: LIST
27581: PUSH
27582: EMPTY
27583: LIST
27584: LIST
27585: PPUSH
27586: CALL_OW 72
27590: ST_TO_ADDR
// if cranes then
27591: LD_VAR 0 6
27595: IFFALSE 27657
// for j in cranes do
27597: LD_ADDR_VAR 0 3
27601: PUSH
27602: LD_VAR 0 6
27606: PUSH
27607: FOR_IN
27608: IFFALSE 27655
// if not IsInArea ( j , mc_parking [ i ] ) then
27610: LD_VAR 0 3
27614: PPUSH
27615: LD_EXP 74
27619: PUSH
27620: LD_VAR 0 2
27624: ARRAY
27625: PPUSH
27626: CALL_OW 308
27630: NOT
27631: IFFALSE 27653
// ComMoveToArea ( j , mc_parking [ i ] ) ;
27633: LD_VAR 0 3
27637: PPUSH
27638: LD_EXP 74
27642: PUSH
27643: LD_VAR 0 2
27647: ARRAY
27648: PPUSH
27649: CALL_OW 113
27653: GO 27607
27655: POP
27656: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
27657: LD_ADDR_EXP 52
27661: PUSH
27662: LD_EXP 52
27666: PPUSH
27667: LD_VAR 0 2
27671: PPUSH
27672: EMPTY
27673: PPUSH
27674: CALL_OW 1
27678: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
27679: LD_VAR 0 2
27683: PPUSH
27684: LD_INT 101
27686: PPUSH
27687: CALL 22547 0 2
// continue ;
27691: GO 27494
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
27693: LD_ADDR_EXP 56
27697: PUSH
27698: LD_EXP 56
27702: PPUSH
27703: LD_VAR 0 2
27707: PPUSH
27708: EMPTY
27709: PPUSH
27710: CALL_OW 1
27714: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
27715: LD_VAR 0 2
27719: PPUSH
27720: LD_INT 103
27722: PPUSH
27723: CALL 22547 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
27727: LD_ADDR_VAR 0 5
27731: PUSH
27732: LD_EXP 50
27736: PUSH
27737: LD_VAR 0 2
27741: ARRAY
27742: PUSH
27743: LD_EXP 79
27747: PUSH
27748: LD_VAR 0 2
27752: ARRAY
27753: UNION
27754: PPUSH
27755: LD_INT 2
27757: PUSH
27758: LD_INT 25
27760: PUSH
27761: LD_INT 2
27763: PUSH
27764: EMPTY
27765: LIST
27766: LIST
27767: PUSH
27768: LD_INT 25
27770: PUSH
27771: LD_INT 16
27773: PUSH
27774: EMPTY
27775: LIST
27776: LIST
27777: PUSH
27778: EMPTY
27779: LIST
27780: LIST
27781: LIST
27782: PUSH
27783: EMPTY
27784: LIST
27785: PPUSH
27786: CALL_OW 72
27790: ST_TO_ADDR
// if mc_need_heal [ i ] then
27791: LD_EXP 53
27795: PUSH
27796: LD_VAR 0 2
27800: ARRAY
27801: IFFALSE 27845
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
27803: LD_ADDR_VAR 0 5
27807: PUSH
27808: LD_VAR 0 5
27812: PUSH
27813: LD_EXP 53
27817: PUSH
27818: LD_VAR 0 2
27822: ARRAY
27823: PUSH
27824: LD_INT 1
27826: ARRAY
27827: PUSH
27828: LD_EXP 53
27832: PUSH
27833: LD_VAR 0 2
27837: ARRAY
27838: PUSH
27839: LD_INT 2
27841: ARRAY
27842: UNION
27843: DIFF
27844: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
27845: LD_ADDR_VAR 0 6
27849: PUSH
27850: LD_EXP 69
27854: PUSH
27855: LD_VAR 0 2
27859: ARRAY
27860: PPUSH
27861: LD_INT 2
27863: PUSH
27864: LD_INT 34
27866: PUSH
27867: LD_INT 13
27869: PUSH
27870: EMPTY
27871: LIST
27872: LIST
27873: PUSH
27874: LD_INT 34
27876: PUSH
27877: LD_INT 52
27879: PUSH
27880: EMPTY
27881: LIST
27882: LIST
27883: PUSH
27884: LD_INT 34
27886: PUSH
27887: LD_INT 88
27889: PUSH
27890: EMPTY
27891: LIST
27892: LIST
27893: PUSH
27894: EMPTY
27895: LIST
27896: LIST
27897: LIST
27898: LIST
27899: PPUSH
27900: CALL_OW 72
27904: ST_TO_ADDR
// if cranes then
27905: LD_VAR 0 6
27909: IFFALSE 28077
// begin for j in cranes do
27911: LD_ADDR_VAR 0 3
27915: PUSH
27916: LD_VAR 0 6
27920: PUSH
27921: FOR_IN
27922: IFFALSE 28075
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
27924: LD_VAR 0 3
27928: PPUSH
27929: CALL_OW 256
27933: PUSH
27934: LD_INT 1000
27936: EQUAL
27937: PUSH
27938: LD_VAR 0 3
27942: PPUSH
27943: CALL_OW 314
27947: NOT
27948: AND
27949: IFFALSE 28015
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
27951: LD_ADDR_VAR 0 8
27955: PUSH
27956: LD_EXP 51
27960: PUSH
27961: LD_VAR 0 2
27965: ARRAY
27966: PPUSH
27967: LD_VAR 0 3
27971: PPUSH
27972: CALL_OW 74
27976: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
27977: LD_VAR 0 8
27981: PPUSH
27982: LD_INT 16
27984: PPUSH
27985: CALL 56631 0 2
27989: PUSH
27990: LD_INT 4
27992: ARRAY
27993: PUSH
27994: LD_INT 10
27996: LESS
27997: IFFALSE 28013
// ComRepairBuilding ( j , to_repair ) ;
27999: LD_VAR 0 3
28003: PPUSH
28004: LD_VAR 0 8
28008: PPUSH
28009: CALL_OW 130
// end else
28013: GO 28073
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
28015: LD_VAR 0 3
28019: PPUSH
28020: CALL_OW 256
28024: PUSH
28025: LD_INT 500
28027: LESS
28028: PUSH
28029: LD_VAR 0 3
28033: PPUSH
28034: LD_EXP 74
28038: PUSH
28039: LD_VAR 0 2
28043: ARRAY
28044: PPUSH
28045: CALL_OW 308
28049: NOT
28050: AND
28051: IFFALSE 28073
// ComMoveToArea ( j , mc_parking [ i ] ) ;
28053: LD_VAR 0 3
28057: PPUSH
28058: LD_EXP 74
28062: PUSH
28063: LD_VAR 0 2
28067: ARRAY
28068: PPUSH
28069: CALL_OW 113
// end ;
28073: GO 27921
28075: POP
28076: POP
// end ; if tmp > 3 then
28077: LD_VAR 0 5
28081: PUSH
28082: LD_INT 3
28084: GREATER
28085: IFFALSE 28105
// tmp := ShrinkArray ( tmp , 4 ) ;
28087: LD_ADDR_VAR 0 5
28091: PUSH
28092: LD_VAR 0 5
28096: PPUSH
28097: LD_INT 4
28099: PPUSH
28100: CALL 86679 0 2
28104: ST_TO_ADDR
// if not tmp then
28105: LD_VAR 0 5
28109: NOT
28110: IFFALSE 28114
// continue ;
28112: GO 27494
// for j in tmp do
28114: LD_ADDR_VAR 0 3
28118: PUSH
28119: LD_VAR 0 5
28123: PUSH
28124: FOR_IN
28125: IFFALSE 28384
// begin if IsInUnit ( j ) then
28127: LD_VAR 0 3
28131: PPUSH
28132: CALL_OW 310
28136: IFFALSE 28147
// ComExitBuilding ( j ) ;
28138: LD_VAR 0 3
28142: PPUSH
28143: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
28147: LD_VAR 0 3
28151: PUSH
28152: LD_EXP 52
28156: PUSH
28157: LD_VAR 0 2
28161: ARRAY
28162: IN
28163: NOT
28164: IFFALSE 28222
// begin SetTag ( j , 101 ) ;
28166: LD_VAR 0 3
28170: PPUSH
28171: LD_INT 101
28173: PPUSH
28174: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
28178: LD_ADDR_EXP 52
28182: PUSH
28183: LD_EXP 52
28187: PPUSH
28188: LD_VAR 0 2
28192: PUSH
28193: LD_EXP 52
28197: PUSH
28198: LD_VAR 0 2
28202: ARRAY
28203: PUSH
28204: LD_INT 1
28206: PLUS
28207: PUSH
28208: EMPTY
28209: LIST
28210: LIST
28211: PPUSH
28212: LD_VAR 0 3
28216: PPUSH
28217: CALL 54034 0 3
28221: ST_TO_ADDR
// end ; wait ( 1 ) ;
28222: LD_INT 1
28224: PPUSH
28225: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
28229: LD_ADDR_VAR 0 7
28233: PUSH
28234: LD_EXP 51
28238: PUSH
28239: LD_VAR 0 2
28243: ARRAY
28244: ST_TO_ADDR
// if mc_scan [ i ] then
28245: LD_EXP 73
28249: PUSH
28250: LD_VAR 0 2
28254: ARRAY
28255: IFFALSE 28317
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
28257: LD_ADDR_VAR 0 7
28261: PUSH
28262: LD_EXP 51
28266: PUSH
28267: LD_VAR 0 2
28271: ARRAY
28272: PPUSH
28273: LD_INT 3
28275: PUSH
28276: LD_INT 30
28278: PUSH
28279: LD_INT 32
28281: PUSH
28282: EMPTY
28283: LIST
28284: LIST
28285: PUSH
28286: LD_INT 30
28288: PUSH
28289: LD_INT 33
28291: PUSH
28292: EMPTY
28293: LIST
28294: LIST
28295: PUSH
28296: LD_INT 30
28298: PUSH
28299: LD_INT 31
28301: PUSH
28302: EMPTY
28303: LIST
28304: LIST
28305: PUSH
28306: EMPTY
28307: LIST
28308: LIST
28309: LIST
28310: LIST
28311: PPUSH
28312: CALL_OW 72
28316: ST_TO_ADDR
// if not to_repair_tmp then
28317: LD_VAR 0 7
28321: NOT
28322: IFFALSE 28326
// continue ;
28324: GO 28124
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
28326: LD_ADDR_VAR 0 8
28330: PUSH
28331: LD_VAR 0 7
28335: PPUSH
28336: LD_VAR 0 3
28340: PPUSH
28341: CALL_OW 74
28345: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
28346: LD_VAR 0 8
28350: PPUSH
28351: LD_INT 16
28353: PPUSH
28354: CALL 56631 0 2
28358: PUSH
28359: LD_INT 4
28361: ARRAY
28362: PUSH
28363: LD_INT 14
28365: LESS
28366: IFFALSE 28382
// ComRepairBuilding ( j , to_repair ) ;
28368: LD_VAR 0 3
28372: PPUSH
28373: LD_VAR 0 8
28377: PPUSH
28378: CALL_OW 130
// end ;
28382: GO 28124
28384: POP
28385: POP
// end ;
28386: GO 27494
28388: POP
28389: POP
// end ;
28390: LD_VAR 0 1
28394: RET
// export function MC_Heal ; var i , j , tmp ; begin
28395: LD_INT 0
28397: PPUSH
28398: PPUSH
28399: PPUSH
28400: PPUSH
// if not mc_bases then
28401: LD_EXP 50
28405: NOT
28406: IFFALSE 28410
// exit ;
28408: GO 28812
// for i = 1 to mc_bases do
28410: LD_ADDR_VAR 0 2
28414: PUSH
28415: DOUBLE
28416: LD_INT 1
28418: DEC
28419: ST_TO_ADDR
28420: LD_EXP 50
28424: PUSH
28425: FOR_TO
28426: IFFALSE 28810
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
28428: LD_EXP 53
28432: PUSH
28433: LD_VAR 0 2
28437: ARRAY
28438: PUSH
28439: LD_INT 1
28441: ARRAY
28442: NOT
28443: PUSH
28444: LD_EXP 53
28448: PUSH
28449: LD_VAR 0 2
28453: ARRAY
28454: PUSH
28455: LD_INT 2
28457: ARRAY
28458: NOT
28459: AND
28460: IFFALSE 28498
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
28462: LD_ADDR_EXP 54
28466: PUSH
28467: LD_EXP 54
28471: PPUSH
28472: LD_VAR 0 2
28476: PPUSH
28477: EMPTY
28478: PPUSH
28479: CALL_OW 1
28483: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
28484: LD_VAR 0 2
28488: PPUSH
28489: LD_INT 102
28491: PPUSH
28492: CALL 22547 0 2
// continue ;
28496: GO 28425
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
28498: LD_ADDR_VAR 0 4
28502: PUSH
28503: LD_EXP 50
28507: PUSH
28508: LD_VAR 0 2
28512: ARRAY
28513: PPUSH
28514: LD_INT 25
28516: PUSH
28517: LD_INT 4
28519: PUSH
28520: EMPTY
28521: LIST
28522: LIST
28523: PPUSH
28524: CALL_OW 72
28528: ST_TO_ADDR
// if not tmp then
28529: LD_VAR 0 4
28533: NOT
28534: IFFALSE 28538
// continue ;
28536: GO 28425
// if mc_taming [ i ] then
28538: LD_EXP 81
28542: PUSH
28543: LD_VAR 0 2
28547: ARRAY
28548: IFFALSE 28572
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
28550: LD_ADDR_EXP 81
28554: PUSH
28555: LD_EXP 81
28559: PPUSH
28560: LD_VAR 0 2
28564: PPUSH
28565: EMPTY
28566: PPUSH
28567: CALL_OW 1
28571: ST_TO_ADDR
// for j in tmp do
28572: LD_ADDR_VAR 0 3
28576: PUSH
28577: LD_VAR 0 4
28581: PUSH
28582: FOR_IN
28583: IFFALSE 28806
// begin if IsInUnit ( j ) then
28585: LD_VAR 0 3
28589: PPUSH
28590: CALL_OW 310
28594: IFFALSE 28605
// ComExitBuilding ( j ) ;
28596: LD_VAR 0 3
28600: PPUSH
28601: CALL_OW 122
// if not j in mc_healers [ i ] then
28605: LD_VAR 0 3
28609: PUSH
28610: LD_EXP 54
28614: PUSH
28615: LD_VAR 0 2
28619: ARRAY
28620: IN
28621: NOT
28622: IFFALSE 28668
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
28624: LD_ADDR_EXP 54
28628: PUSH
28629: LD_EXP 54
28633: PPUSH
28634: LD_VAR 0 2
28638: PUSH
28639: LD_EXP 54
28643: PUSH
28644: LD_VAR 0 2
28648: ARRAY
28649: PUSH
28650: LD_INT 1
28652: PLUS
28653: PUSH
28654: EMPTY
28655: LIST
28656: LIST
28657: PPUSH
28658: LD_VAR 0 3
28662: PPUSH
28663: CALL 54034 0 3
28667: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
28668: LD_VAR 0 3
28672: PPUSH
28673: CALL_OW 110
28677: PUSH
28678: LD_INT 102
28680: NONEQUAL
28681: IFFALSE 28695
// SetTag ( j , 102 ) ;
28683: LD_VAR 0 3
28687: PPUSH
28688: LD_INT 102
28690: PPUSH
28691: CALL_OW 109
// Wait ( 3 ) ;
28695: LD_INT 3
28697: PPUSH
28698: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
28702: LD_EXP 53
28706: PUSH
28707: LD_VAR 0 2
28711: ARRAY
28712: PUSH
28713: LD_INT 1
28715: ARRAY
28716: IFFALSE 28748
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
28718: LD_VAR 0 3
28722: PPUSH
28723: LD_EXP 53
28727: PUSH
28728: LD_VAR 0 2
28732: ARRAY
28733: PUSH
28734: LD_INT 1
28736: ARRAY
28737: PUSH
28738: LD_INT 1
28740: ARRAY
28741: PPUSH
28742: CALL_OW 128
28746: GO 28804
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
28748: LD_VAR 0 3
28752: PPUSH
28753: CALL_OW 314
28757: NOT
28758: PUSH
28759: LD_EXP 53
28763: PUSH
28764: LD_VAR 0 2
28768: ARRAY
28769: PUSH
28770: LD_INT 2
28772: ARRAY
28773: AND
28774: IFFALSE 28804
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
28776: LD_VAR 0 3
28780: PPUSH
28781: LD_EXP 53
28785: PUSH
28786: LD_VAR 0 2
28790: ARRAY
28791: PUSH
28792: LD_INT 2
28794: ARRAY
28795: PUSH
28796: LD_INT 1
28798: ARRAY
28799: PPUSH
28800: CALL_OW 128
// end ;
28804: GO 28582
28806: POP
28807: POP
// end ;
28808: GO 28425
28810: POP
28811: POP
// end ;
28812: LD_VAR 0 1
28816: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
28817: LD_INT 0
28819: PPUSH
28820: PPUSH
28821: PPUSH
28822: PPUSH
28823: PPUSH
28824: PPUSH
// if not mc_bases then
28825: LD_EXP 50
28829: NOT
28830: IFFALSE 28834
// exit ;
28832: GO 29997
// for i = 1 to mc_bases do
28834: LD_ADDR_VAR 0 2
28838: PUSH
28839: DOUBLE
28840: LD_INT 1
28842: DEC
28843: ST_TO_ADDR
28844: LD_EXP 50
28848: PUSH
28849: FOR_TO
28850: IFFALSE 29995
// begin if mc_scan [ i ] then
28852: LD_EXP 73
28856: PUSH
28857: LD_VAR 0 2
28861: ARRAY
28862: IFFALSE 28866
// continue ;
28864: GO 28849
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
28866: LD_EXP 55
28870: PUSH
28871: LD_VAR 0 2
28875: ARRAY
28876: NOT
28877: PUSH
28878: LD_EXP 57
28882: PUSH
28883: LD_VAR 0 2
28887: ARRAY
28888: NOT
28889: AND
28890: PUSH
28891: LD_EXP 56
28895: PUSH
28896: LD_VAR 0 2
28900: ARRAY
28901: AND
28902: IFFALSE 28940
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
28904: LD_ADDR_EXP 56
28908: PUSH
28909: LD_EXP 56
28913: PPUSH
28914: LD_VAR 0 2
28918: PPUSH
28919: EMPTY
28920: PPUSH
28921: CALL_OW 1
28925: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
28926: LD_VAR 0 2
28930: PPUSH
28931: LD_INT 103
28933: PPUSH
28934: CALL 22547 0 2
// continue ;
28938: GO 28849
// end ; if mc_construct_list [ i ] then
28940: LD_EXP 57
28944: PUSH
28945: LD_VAR 0 2
28949: ARRAY
28950: IFFALSE 29170
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
28952: LD_ADDR_VAR 0 5
28956: PUSH
28957: LD_EXP 50
28961: PUSH
28962: LD_VAR 0 2
28966: ARRAY
28967: PPUSH
28968: LD_INT 25
28970: PUSH
28971: LD_INT 2
28973: PUSH
28974: EMPTY
28975: LIST
28976: LIST
28977: PPUSH
28978: CALL_OW 72
28982: PUSH
28983: LD_EXP 52
28987: PUSH
28988: LD_VAR 0 2
28992: ARRAY
28993: DIFF
28994: ST_TO_ADDR
// if not tmp then
28995: LD_VAR 0 5
28999: NOT
29000: IFFALSE 29004
// continue ;
29002: GO 28849
// for j in tmp do
29004: LD_ADDR_VAR 0 3
29008: PUSH
29009: LD_VAR 0 5
29013: PUSH
29014: FOR_IN
29015: IFFALSE 29166
// begin if not mc_builders [ i ] then
29017: LD_EXP 56
29021: PUSH
29022: LD_VAR 0 2
29026: ARRAY
29027: NOT
29028: IFFALSE 29086
// begin SetTag ( j , 103 ) ;
29030: LD_VAR 0 3
29034: PPUSH
29035: LD_INT 103
29037: PPUSH
29038: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
29042: LD_ADDR_EXP 56
29046: PUSH
29047: LD_EXP 56
29051: PPUSH
29052: LD_VAR 0 2
29056: PUSH
29057: LD_EXP 56
29061: PUSH
29062: LD_VAR 0 2
29066: ARRAY
29067: PUSH
29068: LD_INT 1
29070: PLUS
29071: PUSH
29072: EMPTY
29073: LIST
29074: LIST
29075: PPUSH
29076: LD_VAR 0 3
29080: PPUSH
29081: CALL 54034 0 3
29085: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
29086: LD_VAR 0 3
29090: PPUSH
29091: CALL_OW 310
29095: IFFALSE 29106
// ComExitBuilding ( j ) ;
29097: LD_VAR 0 3
29101: PPUSH
29102: CALL_OW 122
// wait ( 3 ) ;
29106: LD_INT 3
29108: PPUSH
29109: CALL_OW 67
// if not mc_construct_list [ i ] then
29113: LD_EXP 57
29117: PUSH
29118: LD_VAR 0 2
29122: ARRAY
29123: NOT
29124: IFFALSE 29128
// break ;
29126: GO 29166
// if not HasTask ( j ) then
29128: LD_VAR 0 3
29132: PPUSH
29133: CALL_OW 314
29137: NOT
29138: IFFALSE 29164
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
29140: LD_VAR 0 3
29144: PPUSH
29145: LD_EXP 57
29149: PUSH
29150: LD_VAR 0 2
29154: ARRAY
29155: PUSH
29156: LD_INT 1
29158: ARRAY
29159: PPUSH
29160: CALL 56895 0 2
// end ;
29164: GO 29014
29166: POP
29167: POP
// end else
29168: GO 29993
// if mc_build_list [ i ] then
29170: LD_EXP 55
29174: PUSH
29175: LD_VAR 0 2
29179: ARRAY
29180: IFFALSE 29993
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
29182: LD_EXP 55
29186: PUSH
29187: LD_VAR 0 2
29191: ARRAY
29192: PUSH
29193: LD_INT 1
29195: ARRAY
29196: PUSH
29197: LD_INT 1
29199: ARRAY
29200: PPUSH
29201: CALL 56719 0 1
29205: PUSH
29206: LD_EXP 50
29210: PUSH
29211: LD_VAR 0 2
29215: ARRAY
29216: PPUSH
29217: LD_INT 2
29219: PUSH
29220: LD_INT 30
29222: PUSH
29223: LD_INT 2
29225: PUSH
29226: EMPTY
29227: LIST
29228: LIST
29229: PUSH
29230: LD_INT 30
29232: PUSH
29233: LD_INT 3
29235: PUSH
29236: EMPTY
29237: LIST
29238: LIST
29239: PUSH
29240: EMPTY
29241: LIST
29242: LIST
29243: LIST
29244: PPUSH
29245: CALL_OW 72
29249: NOT
29250: AND
29251: IFFALSE 29356
// begin for j = 1 to mc_build_list [ i ] do
29253: LD_ADDR_VAR 0 3
29257: PUSH
29258: DOUBLE
29259: LD_INT 1
29261: DEC
29262: ST_TO_ADDR
29263: LD_EXP 55
29267: PUSH
29268: LD_VAR 0 2
29272: ARRAY
29273: PUSH
29274: FOR_TO
29275: IFFALSE 29354
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
29277: LD_EXP 55
29281: PUSH
29282: LD_VAR 0 2
29286: ARRAY
29287: PUSH
29288: LD_VAR 0 3
29292: ARRAY
29293: PUSH
29294: LD_INT 1
29296: ARRAY
29297: PUSH
29298: LD_INT 2
29300: EQUAL
29301: IFFALSE 29352
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
29303: LD_ADDR_EXP 55
29307: PUSH
29308: LD_EXP 55
29312: PPUSH
29313: LD_VAR 0 2
29317: PPUSH
29318: LD_EXP 55
29322: PUSH
29323: LD_VAR 0 2
29327: ARRAY
29328: PPUSH
29329: LD_VAR 0 3
29333: PPUSH
29334: LD_INT 1
29336: PPUSH
29337: LD_INT 0
29339: PPUSH
29340: CALL 53452 0 4
29344: PPUSH
29345: CALL_OW 1
29349: ST_TO_ADDR
// break ;
29350: GO 29354
// end ;
29352: GO 29274
29354: POP
29355: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
29356: LD_ADDR_VAR 0 6
29360: PUSH
29361: LD_EXP 50
29365: PUSH
29366: LD_VAR 0 2
29370: ARRAY
29371: PPUSH
29372: LD_INT 2
29374: PUSH
29375: LD_INT 30
29377: PUSH
29378: LD_INT 0
29380: PUSH
29381: EMPTY
29382: LIST
29383: LIST
29384: PUSH
29385: LD_INT 30
29387: PUSH
29388: LD_INT 1
29390: PUSH
29391: EMPTY
29392: LIST
29393: LIST
29394: PUSH
29395: EMPTY
29396: LIST
29397: LIST
29398: LIST
29399: PPUSH
29400: CALL_OW 72
29404: ST_TO_ADDR
// for k := 1 to depot do
29405: LD_ADDR_VAR 0 4
29409: PUSH
29410: DOUBLE
29411: LD_INT 1
29413: DEC
29414: ST_TO_ADDR
29415: LD_VAR 0 6
29419: PUSH
29420: FOR_TO
29421: IFFALSE 29991
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
29423: LD_EXP 55
29427: PUSH
29428: LD_VAR 0 2
29432: ARRAY
29433: PUSH
29434: LD_INT 1
29436: ARRAY
29437: PUSH
29438: LD_INT 1
29440: ARRAY
29441: PUSH
29442: LD_INT 0
29444: EQUAL
29445: PUSH
29446: LD_VAR 0 6
29450: PUSH
29451: LD_VAR 0 4
29455: ARRAY
29456: PPUSH
29457: LD_EXP 55
29461: PUSH
29462: LD_VAR 0 2
29466: ARRAY
29467: PUSH
29468: LD_INT 1
29470: ARRAY
29471: PUSH
29472: LD_INT 1
29474: ARRAY
29475: PPUSH
29476: LD_EXP 55
29480: PUSH
29481: LD_VAR 0 2
29485: ARRAY
29486: PUSH
29487: LD_INT 1
29489: ARRAY
29490: PUSH
29491: LD_INT 2
29493: ARRAY
29494: PPUSH
29495: LD_EXP 55
29499: PUSH
29500: LD_VAR 0 2
29504: ARRAY
29505: PUSH
29506: LD_INT 1
29508: ARRAY
29509: PUSH
29510: LD_INT 3
29512: ARRAY
29513: PPUSH
29514: LD_EXP 55
29518: PUSH
29519: LD_VAR 0 2
29523: ARRAY
29524: PUSH
29525: LD_INT 1
29527: ARRAY
29528: PUSH
29529: LD_INT 4
29531: ARRAY
29532: PPUSH
29533: CALL 62131 0 5
29537: OR
29538: IFFALSE 29819
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
29540: LD_ADDR_VAR 0 5
29544: PUSH
29545: LD_EXP 50
29549: PUSH
29550: LD_VAR 0 2
29554: ARRAY
29555: PPUSH
29556: LD_INT 25
29558: PUSH
29559: LD_INT 2
29561: PUSH
29562: EMPTY
29563: LIST
29564: LIST
29565: PPUSH
29566: CALL_OW 72
29570: PUSH
29571: LD_EXP 52
29575: PUSH
29576: LD_VAR 0 2
29580: ARRAY
29581: DIFF
29582: ST_TO_ADDR
// if not tmp then
29583: LD_VAR 0 5
29587: NOT
29588: IFFALSE 29592
// continue ;
29590: GO 29420
// for j in tmp do
29592: LD_ADDR_VAR 0 3
29596: PUSH
29597: LD_VAR 0 5
29601: PUSH
29602: FOR_IN
29603: IFFALSE 29815
// begin if not mc_builders [ i ] then
29605: LD_EXP 56
29609: PUSH
29610: LD_VAR 0 2
29614: ARRAY
29615: NOT
29616: IFFALSE 29674
// begin SetTag ( j , 103 ) ;
29618: LD_VAR 0 3
29622: PPUSH
29623: LD_INT 103
29625: PPUSH
29626: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
29630: LD_ADDR_EXP 56
29634: PUSH
29635: LD_EXP 56
29639: PPUSH
29640: LD_VAR 0 2
29644: PUSH
29645: LD_EXP 56
29649: PUSH
29650: LD_VAR 0 2
29654: ARRAY
29655: PUSH
29656: LD_INT 1
29658: PLUS
29659: PUSH
29660: EMPTY
29661: LIST
29662: LIST
29663: PPUSH
29664: LD_VAR 0 3
29668: PPUSH
29669: CALL 54034 0 3
29673: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
29674: LD_VAR 0 3
29678: PPUSH
29679: CALL_OW 310
29683: IFFALSE 29694
// ComExitBuilding ( j ) ;
29685: LD_VAR 0 3
29689: PPUSH
29690: CALL_OW 122
// wait ( 3 ) ;
29694: LD_INT 3
29696: PPUSH
29697: CALL_OW 67
// if not mc_build_list [ i ] then
29701: LD_EXP 55
29705: PUSH
29706: LD_VAR 0 2
29710: ARRAY
29711: NOT
29712: IFFALSE 29716
// break ;
29714: GO 29815
// if not HasTask ( j ) then
29716: LD_VAR 0 3
29720: PPUSH
29721: CALL_OW 314
29725: NOT
29726: IFFALSE 29813
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
29728: LD_VAR 0 3
29732: PPUSH
29733: LD_EXP 55
29737: PUSH
29738: LD_VAR 0 2
29742: ARRAY
29743: PUSH
29744: LD_INT 1
29746: ARRAY
29747: PUSH
29748: LD_INT 1
29750: ARRAY
29751: PPUSH
29752: LD_EXP 55
29756: PUSH
29757: LD_VAR 0 2
29761: ARRAY
29762: PUSH
29763: LD_INT 1
29765: ARRAY
29766: PUSH
29767: LD_INT 2
29769: ARRAY
29770: PPUSH
29771: LD_EXP 55
29775: PUSH
29776: LD_VAR 0 2
29780: ARRAY
29781: PUSH
29782: LD_INT 1
29784: ARRAY
29785: PUSH
29786: LD_INT 3
29788: ARRAY
29789: PPUSH
29790: LD_EXP 55
29794: PUSH
29795: LD_VAR 0 2
29799: ARRAY
29800: PUSH
29801: LD_INT 1
29803: ARRAY
29804: PUSH
29805: LD_INT 4
29807: ARRAY
29808: PPUSH
29809: CALL_OW 145
// end ;
29813: GO 29602
29815: POP
29816: POP
// end else
29817: GO 29989
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
29819: LD_EXP 50
29823: PUSH
29824: LD_VAR 0 2
29828: ARRAY
29829: PPUSH
29830: LD_EXP 55
29834: PUSH
29835: LD_VAR 0 2
29839: ARRAY
29840: PUSH
29841: LD_INT 1
29843: ARRAY
29844: PUSH
29845: LD_INT 1
29847: ARRAY
29848: PPUSH
29849: LD_EXP 55
29853: PUSH
29854: LD_VAR 0 2
29858: ARRAY
29859: PUSH
29860: LD_INT 1
29862: ARRAY
29863: PUSH
29864: LD_INT 2
29866: ARRAY
29867: PPUSH
29868: LD_EXP 55
29872: PUSH
29873: LD_VAR 0 2
29877: ARRAY
29878: PUSH
29879: LD_INT 1
29881: ARRAY
29882: PUSH
29883: LD_INT 3
29885: ARRAY
29886: PPUSH
29887: LD_EXP 55
29891: PUSH
29892: LD_VAR 0 2
29896: ARRAY
29897: PUSH
29898: LD_INT 1
29900: ARRAY
29901: PUSH
29902: LD_INT 4
29904: ARRAY
29905: PPUSH
29906: LD_EXP 50
29910: PUSH
29911: LD_VAR 0 2
29915: ARRAY
29916: PPUSH
29917: LD_INT 21
29919: PUSH
29920: LD_INT 3
29922: PUSH
29923: EMPTY
29924: LIST
29925: LIST
29926: PPUSH
29927: CALL_OW 72
29931: PPUSH
29932: EMPTY
29933: PPUSH
29934: CALL 60885 0 7
29938: NOT
29939: IFFALSE 29989
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
29941: LD_ADDR_EXP 55
29945: PUSH
29946: LD_EXP 55
29950: PPUSH
29951: LD_VAR 0 2
29955: PPUSH
29956: LD_EXP 55
29960: PUSH
29961: LD_VAR 0 2
29965: ARRAY
29966: PPUSH
29967: LD_INT 1
29969: PPUSH
29970: LD_INT 1
29972: NEG
29973: PPUSH
29974: LD_INT 0
29976: PPUSH
29977: CALL 53452 0 4
29981: PPUSH
29982: CALL_OW 1
29986: ST_TO_ADDR
// continue ;
29987: GO 29420
// end ; end ;
29989: GO 29420
29991: POP
29992: POP
// end ; end ;
29993: GO 28849
29995: POP
29996: POP
// end ;
29997: LD_VAR 0 1
30001: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
30002: LD_INT 0
30004: PPUSH
30005: PPUSH
30006: PPUSH
30007: PPUSH
30008: PPUSH
30009: PPUSH
// if not mc_bases then
30010: LD_EXP 50
30014: NOT
30015: IFFALSE 30019
// exit ;
30017: GO 30446
// for i = 1 to mc_bases do
30019: LD_ADDR_VAR 0 2
30023: PUSH
30024: DOUBLE
30025: LD_INT 1
30027: DEC
30028: ST_TO_ADDR
30029: LD_EXP 50
30033: PUSH
30034: FOR_TO
30035: IFFALSE 30444
// begin tmp := mc_build_upgrade [ i ] ;
30037: LD_ADDR_VAR 0 4
30041: PUSH
30042: LD_EXP 82
30046: PUSH
30047: LD_VAR 0 2
30051: ARRAY
30052: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
30053: LD_ADDR_VAR 0 6
30057: PUSH
30058: LD_EXP 83
30062: PUSH
30063: LD_VAR 0 2
30067: ARRAY
30068: PPUSH
30069: LD_INT 2
30071: PUSH
30072: LD_INT 30
30074: PUSH
30075: LD_INT 6
30077: PUSH
30078: EMPTY
30079: LIST
30080: LIST
30081: PUSH
30082: LD_INT 30
30084: PUSH
30085: LD_INT 7
30087: PUSH
30088: EMPTY
30089: LIST
30090: LIST
30091: PUSH
30092: EMPTY
30093: LIST
30094: LIST
30095: LIST
30096: PPUSH
30097: CALL_OW 72
30101: ST_TO_ADDR
// if not tmp and not lab then
30102: LD_VAR 0 4
30106: NOT
30107: PUSH
30108: LD_VAR 0 6
30112: NOT
30113: AND
30114: IFFALSE 30118
// continue ;
30116: GO 30034
// if tmp then
30118: LD_VAR 0 4
30122: IFFALSE 30242
// for j in tmp do
30124: LD_ADDR_VAR 0 3
30128: PUSH
30129: LD_VAR 0 4
30133: PUSH
30134: FOR_IN
30135: IFFALSE 30240
// begin if UpgradeCost ( j ) then
30137: LD_VAR 0 3
30141: PPUSH
30142: CALL 60545 0 1
30146: IFFALSE 30238
// begin ComUpgrade ( j ) ;
30148: LD_VAR 0 3
30152: PPUSH
30153: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
30157: LD_ADDR_EXP 82
30161: PUSH
30162: LD_EXP 82
30166: PPUSH
30167: LD_VAR 0 2
30171: PPUSH
30172: LD_EXP 82
30176: PUSH
30177: LD_VAR 0 2
30181: ARRAY
30182: PUSH
30183: LD_VAR 0 3
30187: DIFF
30188: PPUSH
30189: CALL_OW 1
30193: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
30194: LD_ADDR_EXP 57
30198: PUSH
30199: LD_EXP 57
30203: PPUSH
30204: LD_VAR 0 2
30208: PUSH
30209: LD_EXP 57
30213: PUSH
30214: LD_VAR 0 2
30218: ARRAY
30219: PUSH
30220: LD_INT 1
30222: PLUS
30223: PUSH
30224: EMPTY
30225: LIST
30226: LIST
30227: PPUSH
30228: LD_VAR 0 3
30232: PPUSH
30233: CALL 54034 0 3
30237: ST_TO_ADDR
// end ; end ;
30238: GO 30134
30240: POP
30241: POP
// if not lab or not mc_lab_upgrade [ i ] then
30242: LD_VAR 0 6
30246: NOT
30247: PUSH
30248: LD_EXP 84
30252: PUSH
30253: LD_VAR 0 2
30257: ARRAY
30258: NOT
30259: OR
30260: IFFALSE 30264
// continue ;
30262: GO 30034
// for j in lab do
30264: LD_ADDR_VAR 0 3
30268: PUSH
30269: LD_VAR 0 6
30273: PUSH
30274: FOR_IN
30275: IFFALSE 30440
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
30277: LD_VAR 0 3
30281: PPUSH
30282: CALL_OW 266
30286: PUSH
30287: LD_INT 6
30289: PUSH
30290: LD_INT 7
30292: PUSH
30293: EMPTY
30294: LIST
30295: LIST
30296: IN
30297: PUSH
30298: LD_VAR 0 3
30302: PPUSH
30303: CALL_OW 461
30307: PUSH
30308: LD_INT 1
30310: NONEQUAL
30311: AND
30312: IFFALSE 30438
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
30314: LD_VAR 0 3
30318: PPUSH
30319: LD_EXP 84
30323: PUSH
30324: LD_VAR 0 2
30328: ARRAY
30329: PUSH
30330: LD_INT 1
30332: ARRAY
30333: PPUSH
30334: CALL 60750 0 2
30338: IFFALSE 30438
// begin ComCancel ( j ) ;
30340: LD_VAR 0 3
30344: PPUSH
30345: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
30349: LD_VAR 0 3
30353: PPUSH
30354: LD_EXP 84
30358: PUSH
30359: LD_VAR 0 2
30363: ARRAY
30364: PUSH
30365: LD_INT 1
30367: ARRAY
30368: PPUSH
30369: CALL_OW 207
// if not j in mc_construct_list [ i ] then
30373: LD_VAR 0 3
30377: PUSH
30378: LD_EXP 57
30382: PUSH
30383: LD_VAR 0 2
30387: ARRAY
30388: IN
30389: NOT
30390: IFFALSE 30436
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
30392: LD_ADDR_EXP 57
30396: PUSH
30397: LD_EXP 57
30401: PPUSH
30402: LD_VAR 0 2
30406: PUSH
30407: LD_EXP 57
30411: PUSH
30412: LD_VAR 0 2
30416: ARRAY
30417: PUSH
30418: LD_INT 1
30420: PLUS
30421: PUSH
30422: EMPTY
30423: LIST
30424: LIST
30425: PPUSH
30426: LD_VAR 0 3
30430: PPUSH
30431: CALL 54034 0 3
30435: ST_TO_ADDR
// break ;
30436: GO 30440
// end ; end ; end ;
30438: GO 30274
30440: POP
30441: POP
// end ;
30442: GO 30034
30444: POP
30445: POP
// end ;
30446: LD_VAR 0 1
30450: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
30451: LD_INT 0
30453: PPUSH
30454: PPUSH
30455: PPUSH
30456: PPUSH
30457: PPUSH
30458: PPUSH
30459: PPUSH
30460: PPUSH
30461: PPUSH
// if not mc_bases then
30462: LD_EXP 50
30466: NOT
30467: IFFALSE 30471
// exit ;
30469: GO 30876
// for i = 1 to mc_bases do
30471: LD_ADDR_VAR 0 2
30475: PUSH
30476: DOUBLE
30477: LD_INT 1
30479: DEC
30480: ST_TO_ADDR
30481: LD_EXP 50
30485: PUSH
30486: FOR_TO
30487: IFFALSE 30874
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
30489: LD_EXP 58
30493: PUSH
30494: LD_VAR 0 2
30498: ARRAY
30499: NOT
30500: PUSH
30501: LD_EXP 50
30505: PUSH
30506: LD_VAR 0 2
30510: ARRAY
30511: PPUSH
30512: LD_INT 30
30514: PUSH
30515: LD_INT 3
30517: PUSH
30518: EMPTY
30519: LIST
30520: LIST
30521: PPUSH
30522: CALL_OW 72
30526: NOT
30527: OR
30528: IFFALSE 30532
// continue ;
30530: GO 30486
// busy := false ;
30532: LD_ADDR_VAR 0 8
30536: PUSH
30537: LD_INT 0
30539: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
30540: LD_ADDR_VAR 0 4
30544: PUSH
30545: LD_EXP 50
30549: PUSH
30550: LD_VAR 0 2
30554: ARRAY
30555: PPUSH
30556: LD_INT 30
30558: PUSH
30559: LD_INT 3
30561: PUSH
30562: EMPTY
30563: LIST
30564: LIST
30565: PPUSH
30566: CALL_OW 72
30570: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
30571: LD_ADDR_VAR 0 6
30575: PUSH
30576: LD_EXP 58
30580: PUSH
30581: LD_VAR 0 2
30585: ARRAY
30586: PPUSH
30587: LD_INT 2
30589: PUSH
30590: LD_INT 30
30592: PUSH
30593: LD_INT 32
30595: PUSH
30596: EMPTY
30597: LIST
30598: LIST
30599: PUSH
30600: LD_INT 30
30602: PUSH
30603: LD_INT 33
30605: PUSH
30606: EMPTY
30607: LIST
30608: LIST
30609: PUSH
30610: EMPTY
30611: LIST
30612: LIST
30613: LIST
30614: PPUSH
30615: CALL_OW 72
30619: ST_TO_ADDR
// if not t then
30620: LD_VAR 0 6
30624: NOT
30625: IFFALSE 30629
// continue ;
30627: GO 30486
// for j in tmp do
30629: LD_ADDR_VAR 0 3
30633: PUSH
30634: LD_VAR 0 4
30638: PUSH
30639: FOR_IN
30640: IFFALSE 30670
// if not BuildingStatus ( j ) = bs_idle then
30642: LD_VAR 0 3
30646: PPUSH
30647: CALL_OW 461
30651: PUSH
30652: LD_INT 2
30654: EQUAL
30655: NOT
30656: IFFALSE 30668
// begin busy := true ;
30658: LD_ADDR_VAR 0 8
30662: PUSH
30663: LD_INT 1
30665: ST_TO_ADDR
// break ;
30666: GO 30670
// end ;
30668: GO 30639
30670: POP
30671: POP
// if busy then
30672: LD_VAR 0 8
30676: IFFALSE 30680
// continue ;
30678: GO 30486
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
30680: LD_ADDR_VAR 0 7
30684: PUSH
30685: LD_VAR 0 6
30689: PPUSH
30690: LD_INT 35
30692: PUSH
30693: LD_INT 0
30695: PUSH
30696: EMPTY
30697: LIST
30698: LIST
30699: PPUSH
30700: CALL_OW 72
30704: ST_TO_ADDR
// if tw then
30705: LD_VAR 0 7
30709: IFFALSE 30786
// begin tw := tw [ 1 ] ;
30711: LD_ADDR_VAR 0 7
30715: PUSH
30716: LD_VAR 0 7
30720: PUSH
30721: LD_INT 1
30723: ARRAY
30724: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
30725: LD_ADDR_VAR 0 9
30729: PUSH
30730: LD_VAR 0 7
30734: PPUSH
30735: LD_EXP 75
30739: PUSH
30740: LD_VAR 0 2
30744: ARRAY
30745: PPUSH
30746: CALL 59042 0 2
30750: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
30751: LD_EXP 89
30755: PUSH
30756: LD_VAR 0 2
30760: ARRAY
30761: IFFALSE 30784
// if not weapon in mc_allowed_tower_weapons [ i ] then
30763: LD_VAR 0 9
30767: PUSH
30768: LD_EXP 89
30772: PUSH
30773: LD_VAR 0 2
30777: ARRAY
30778: IN
30779: NOT
30780: IFFALSE 30784
// continue ;
30782: GO 30486
// end else
30784: GO 30849
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
30786: LD_ADDR_VAR 0 5
30790: PUSH
30791: LD_EXP 58
30795: PUSH
30796: LD_VAR 0 2
30800: ARRAY
30801: PPUSH
30802: LD_VAR 0 4
30806: PPUSH
30807: CALL 85912 0 2
30811: ST_TO_ADDR
// if not tmp2 then
30812: LD_VAR 0 5
30816: NOT
30817: IFFALSE 30821
// continue ;
30819: GO 30486
// tw := tmp2 [ 1 ] ;
30821: LD_ADDR_VAR 0 7
30825: PUSH
30826: LD_VAR 0 5
30830: PUSH
30831: LD_INT 1
30833: ARRAY
30834: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
30835: LD_ADDR_VAR 0 9
30839: PUSH
30840: LD_VAR 0 5
30844: PUSH
30845: LD_INT 2
30847: ARRAY
30848: ST_TO_ADDR
// end ; if not weapon then
30849: LD_VAR 0 9
30853: NOT
30854: IFFALSE 30858
// continue ;
30856: GO 30486
// ComPlaceWeapon ( tw , weapon ) ;
30858: LD_VAR 0 7
30862: PPUSH
30863: LD_VAR 0 9
30867: PPUSH
30868: CALL_OW 148
// end ;
30872: GO 30486
30874: POP
30875: POP
// end ;
30876: LD_VAR 0 1
30880: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
30881: LD_INT 0
30883: PPUSH
30884: PPUSH
30885: PPUSH
30886: PPUSH
30887: PPUSH
30888: PPUSH
30889: PPUSH
// if not mc_bases then
30890: LD_EXP 50
30894: NOT
30895: IFFALSE 30899
// exit ;
30897: GO 31674
// for i = 1 to mc_bases do
30899: LD_ADDR_VAR 0 2
30903: PUSH
30904: DOUBLE
30905: LD_INT 1
30907: DEC
30908: ST_TO_ADDR
30909: LD_EXP 50
30913: PUSH
30914: FOR_TO
30915: IFFALSE 31672
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
30917: LD_EXP 63
30921: PUSH
30922: LD_VAR 0 2
30926: ARRAY
30927: NOT
30928: PUSH
30929: LD_EXP 63
30933: PUSH
30934: LD_VAR 0 2
30938: ARRAY
30939: PUSH
30940: LD_EXP 64
30944: PUSH
30945: LD_VAR 0 2
30949: ARRAY
30950: EQUAL
30951: OR
30952: PUSH
30953: LD_EXP 73
30957: PUSH
30958: LD_VAR 0 2
30962: ARRAY
30963: OR
30964: IFFALSE 30968
// continue ;
30966: GO 30914
// if mc_miners [ i ] then
30968: LD_EXP 64
30972: PUSH
30973: LD_VAR 0 2
30977: ARRAY
30978: IFFALSE 31359
// begin for j = mc_miners [ i ] downto 1 do
30980: LD_ADDR_VAR 0 3
30984: PUSH
30985: DOUBLE
30986: LD_EXP 64
30990: PUSH
30991: LD_VAR 0 2
30995: ARRAY
30996: INC
30997: ST_TO_ADDR
30998: LD_INT 1
31000: PUSH
31001: FOR_DOWNTO
31002: IFFALSE 31357
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
31004: LD_EXP 64
31008: PUSH
31009: LD_VAR 0 2
31013: ARRAY
31014: PUSH
31015: LD_VAR 0 3
31019: ARRAY
31020: PPUSH
31021: CALL_OW 301
31025: PUSH
31026: LD_EXP 64
31030: PUSH
31031: LD_VAR 0 2
31035: ARRAY
31036: PUSH
31037: LD_VAR 0 3
31041: ARRAY
31042: PPUSH
31043: CALL_OW 257
31047: PUSH
31048: LD_INT 1
31050: NONEQUAL
31051: OR
31052: IFFALSE 31115
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
31054: LD_ADDR_VAR 0 5
31058: PUSH
31059: LD_EXP 64
31063: PUSH
31064: LD_VAR 0 2
31068: ARRAY
31069: PUSH
31070: LD_EXP 64
31074: PUSH
31075: LD_VAR 0 2
31079: ARRAY
31080: PUSH
31081: LD_VAR 0 3
31085: ARRAY
31086: DIFF
31087: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
31088: LD_ADDR_EXP 64
31092: PUSH
31093: LD_EXP 64
31097: PPUSH
31098: LD_VAR 0 2
31102: PPUSH
31103: LD_VAR 0 5
31107: PPUSH
31108: CALL_OW 1
31112: ST_TO_ADDR
// continue ;
31113: GO 31001
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
31115: LD_EXP 64
31119: PUSH
31120: LD_VAR 0 2
31124: ARRAY
31125: PUSH
31126: LD_VAR 0 3
31130: ARRAY
31131: PPUSH
31132: CALL_OW 257
31136: PUSH
31137: LD_INT 1
31139: EQUAL
31140: PUSH
31141: LD_EXP 64
31145: PUSH
31146: LD_VAR 0 2
31150: ARRAY
31151: PUSH
31152: LD_VAR 0 3
31156: ARRAY
31157: PPUSH
31158: CALL_OW 459
31162: NOT
31163: AND
31164: PUSH
31165: LD_EXP 64
31169: PUSH
31170: LD_VAR 0 2
31174: ARRAY
31175: PUSH
31176: LD_VAR 0 3
31180: ARRAY
31181: PPUSH
31182: CALL_OW 314
31186: NOT
31187: AND
31188: IFFALSE 31355
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
31190: LD_EXP 64
31194: PUSH
31195: LD_VAR 0 2
31199: ARRAY
31200: PUSH
31201: LD_VAR 0 3
31205: ARRAY
31206: PPUSH
31207: CALL_OW 310
31211: IFFALSE 31234
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
31213: LD_EXP 64
31217: PUSH
31218: LD_VAR 0 2
31222: ARRAY
31223: PUSH
31224: LD_VAR 0 3
31228: ARRAY
31229: PPUSH
31230: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
31234: LD_EXP 64
31238: PUSH
31239: LD_VAR 0 2
31243: ARRAY
31244: PUSH
31245: LD_VAR 0 3
31249: ARRAY
31250: PPUSH
31251: CALL_OW 314
31255: NOT
31256: IFFALSE 31355
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
31258: LD_ADDR_VAR 0 7
31262: PUSH
31263: LD_VAR 0 3
31267: PUSH
31268: LD_EXP 63
31272: PUSH
31273: LD_VAR 0 2
31277: ARRAY
31278: PPUSH
31279: CALL 51174 0 1
31283: MOD
31284: PUSH
31285: LD_INT 1
31287: PLUS
31288: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
31289: LD_EXP 64
31293: PUSH
31294: LD_VAR 0 2
31298: ARRAY
31299: PUSH
31300: LD_VAR 0 3
31304: ARRAY
31305: PPUSH
31306: LD_EXP 63
31310: PUSH
31311: LD_VAR 0 2
31315: ARRAY
31316: PUSH
31317: LD_VAR 0 7
31321: ARRAY
31322: PUSH
31323: LD_INT 1
31325: ARRAY
31326: PPUSH
31327: LD_EXP 63
31331: PUSH
31332: LD_VAR 0 2
31336: ARRAY
31337: PUSH
31338: LD_VAR 0 7
31342: ARRAY
31343: PUSH
31344: LD_INT 2
31346: ARRAY
31347: PPUSH
31348: LD_INT 0
31350: PPUSH
31351: CALL_OW 193
// end ; end ; end ;
31355: GO 31001
31357: POP
31358: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
31359: LD_ADDR_VAR 0 5
31363: PUSH
31364: LD_EXP 50
31368: PUSH
31369: LD_VAR 0 2
31373: ARRAY
31374: PPUSH
31375: LD_INT 2
31377: PUSH
31378: LD_INT 30
31380: PUSH
31381: LD_INT 4
31383: PUSH
31384: EMPTY
31385: LIST
31386: LIST
31387: PUSH
31388: LD_INT 30
31390: PUSH
31391: LD_INT 5
31393: PUSH
31394: EMPTY
31395: LIST
31396: LIST
31397: PUSH
31398: LD_INT 30
31400: PUSH
31401: LD_INT 32
31403: PUSH
31404: EMPTY
31405: LIST
31406: LIST
31407: PUSH
31408: EMPTY
31409: LIST
31410: LIST
31411: LIST
31412: LIST
31413: PPUSH
31414: CALL_OW 72
31418: ST_TO_ADDR
// if not tmp then
31419: LD_VAR 0 5
31423: NOT
31424: IFFALSE 31428
// continue ;
31426: GO 30914
// list := [ ] ;
31428: LD_ADDR_VAR 0 6
31432: PUSH
31433: EMPTY
31434: ST_TO_ADDR
// for j in tmp do
31435: LD_ADDR_VAR 0 3
31439: PUSH
31440: LD_VAR 0 5
31444: PUSH
31445: FOR_IN
31446: IFFALSE 31515
// begin for k in UnitsInside ( j ) do
31448: LD_ADDR_VAR 0 4
31452: PUSH
31453: LD_VAR 0 3
31457: PPUSH
31458: CALL_OW 313
31462: PUSH
31463: FOR_IN
31464: IFFALSE 31511
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
31466: LD_VAR 0 4
31470: PPUSH
31471: CALL_OW 257
31475: PUSH
31476: LD_INT 1
31478: EQUAL
31479: PUSH
31480: LD_VAR 0 4
31484: PPUSH
31485: CALL_OW 459
31489: NOT
31490: AND
31491: IFFALSE 31509
// list := list ^ k ;
31493: LD_ADDR_VAR 0 6
31497: PUSH
31498: LD_VAR 0 6
31502: PUSH
31503: LD_VAR 0 4
31507: ADD
31508: ST_TO_ADDR
31509: GO 31463
31511: POP
31512: POP
// end ;
31513: GO 31445
31515: POP
31516: POP
// list := list diff mc_miners [ i ] ;
31517: LD_ADDR_VAR 0 6
31521: PUSH
31522: LD_VAR 0 6
31526: PUSH
31527: LD_EXP 64
31531: PUSH
31532: LD_VAR 0 2
31536: ARRAY
31537: DIFF
31538: ST_TO_ADDR
// if not list then
31539: LD_VAR 0 6
31543: NOT
31544: IFFALSE 31548
// continue ;
31546: GO 30914
// k := mc_mines [ i ] - mc_miners [ i ] ;
31548: LD_ADDR_VAR 0 4
31552: PUSH
31553: LD_EXP 63
31557: PUSH
31558: LD_VAR 0 2
31562: ARRAY
31563: PUSH
31564: LD_EXP 64
31568: PUSH
31569: LD_VAR 0 2
31573: ARRAY
31574: MINUS
31575: ST_TO_ADDR
// if k > list then
31576: LD_VAR 0 4
31580: PUSH
31581: LD_VAR 0 6
31585: GREATER
31586: IFFALSE 31598
// k := list ;
31588: LD_ADDR_VAR 0 4
31592: PUSH
31593: LD_VAR 0 6
31597: ST_TO_ADDR
// for j = 1 to k do
31598: LD_ADDR_VAR 0 3
31602: PUSH
31603: DOUBLE
31604: LD_INT 1
31606: DEC
31607: ST_TO_ADDR
31608: LD_VAR 0 4
31612: PUSH
31613: FOR_TO
31614: IFFALSE 31668
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
31616: LD_ADDR_EXP 64
31620: PUSH
31621: LD_EXP 64
31625: PPUSH
31626: LD_VAR 0 2
31630: PUSH
31631: LD_EXP 64
31635: PUSH
31636: LD_VAR 0 2
31640: ARRAY
31641: PUSH
31642: LD_INT 1
31644: PLUS
31645: PUSH
31646: EMPTY
31647: LIST
31648: LIST
31649: PPUSH
31650: LD_VAR 0 6
31654: PUSH
31655: LD_VAR 0 3
31659: ARRAY
31660: PPUSH
31661: CALL 54034 0 3
31665: ST_TO_ADDR
31666: GO 31613
31668: POP
31669: POP
// end ;
31670: GO 30914
31672: POP
31673: POP
// end ;
31674: LD_VAR 0 1
31678: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
31679: LD_INT 0
31681: PPUSH
31682: PPUSH
31683: PPUSH
31684: PPUSH
31685: PPUSH
31686: PPUSH
31687: PPUSH
31688: PPUSH
31689: PPUSH
31690: PPUSH
31691: PPUSH
// if not mc_bases then
31692: LD_EXP 50
31696: NOT
31697: IFFALSE 31701
// exit ;
31699: GO 33524
// for i = 1 to mc_bases do
31701: LD_ADDR_VAR 0 2
31705: PUSH
31706: DOUBLE
31707: LD_INT 1
31709: DEC
31710: ST_TO_ADDR
31711: LD_EXP 50
31715: PUSH
31716: FOR_TO
31717: IFFALSE 33522
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
31719: LD_EXP 50
31723: PUSH
31724: LD_VAR 0 2
31728: ARRAY
31729: NOT
31730: PUSH
31731: LD_EXP 57
31735: PUSH
31736: LD_VAR 0 2
31740: ARRAY
31741: OR
31742: IFFALSE 31746
// continue ;
31744: GO 31716
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
31746: LD_EXP 66
31750: PUSH
31751: LD_VAR 0 2
31755: ARRAY
31756: NOT
31757: PUSH
31758: LD_EXP 67
31762: PUSH
31763: LD_VAR 0 2
31767: ARRAY
31768: AND
31769: IFFALSE 31807
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
31771: LD_ADDR_EXP 67
31775: PUSH
31776: LD_EXP 67
31780: PPUSH
31781: LD_VAR 0 2
31785: PPUSH
31786: EMPTY
31787: PPUSH
31788: CALL_OW 1
31792: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
31793: LD_VAR 0 2
31797: PPUSH
31798: LD_INT 107
31800: PPUSH
31801: CALL 22547 0 2
// continue ;
31805: GO 31716
// end ; target := [ ] ;
31807: LD_ADDR_VAR 0 7
31811: PUSH
31812: EMPTY
31813: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
31814: LD_ADDR_VAR 0 6
31818: PUSH
31819: LD_EXP 50
31823: PUSH
31824: LD_VAR 0 2
31828: ARRAY
31829: PUSH
31830: LD_INT 1
31832: ARRAY
31833: PPUSH
31834: CALL_OW 255
31838: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31839: LD_ADDR_VAR 0 9
31843: PUSH
31844: LD_EXP 50
31848: PUSH
31849: LD_VAR 0 2
31853: ARRAY
31854: PPUSH
31855: LD_INT 2
31857: PUSH
31858: LD_INT 30
31860: PUSH
31861: LD_INT 0
31863: PUSH
31864: EMPTY
31865: LIST
31866: LIST
31867: PUSH
31868: LD_INT 30
31870: PUSH
31871: LD_INT 1
31873: PUSH
31874: EMPTY
31875: LIST
31876: LIST
31877: PUSH
31878: EMPTY
31879: LIST
31880: LIST
31881: LIST
31882: PPUSH
31883: CALL_OW 72
31887: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
31888: LD_ADDR_VAR 0 3
31892: PUSH
31893: DOUBLE
31894: LD_EXP 66
31898: PUSH
31899: LD_VAR 0 2
31903: ARRAY
31904: INC
31905: ST_TO_ADDR
31906: LD_INT 1
31908: PUSH
31909: FOR_DOWNTO
31910: IFFALSE 32155
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
31912: LD_EXP 66
31916: PUSH
31917: LD_VAR 0 2
31921: ARRAY
31922: PUSH
31923: LD_VAR 0 3
31927: ARRAY
31928: PUSH
31929: LD_INT 2
31931: ARRAY
31932: PPUSH
31933: LD_EXP 66
31937: PUSH
31938: LD_VAR 0 2
31942: ARRAY
31943: PUSH
31944: LD_VAR 0 3
31948: ARRAY
31949: PUSH
31950: LD_INT 3
31952: ARRAY
31953: PPUSH
31954: CALL_OW 488
31958: PUSH
31959: LD_EXP 66
31963: PUSH
31964: LD_VAR 0 2
31968: ARRAY
31969: PUSH
31970: LD_VAR 0 3
31974: ARRAY
31975: PUSH
31976: LD_INT 2
31978: ARRAY
31979: PPUSH
31980: LD_EXP 66
31984: PUSH
31985: LD_VAR 0 2
31989: ARRAY
31990: PUSH
31991: LD_VAR 0 3
31995: ARRAY
31996: PUSH
31997: LD_INT 3
31999: ARRAY
32000: PPUSH
32001: CALL_OW 284
32005: PUSH
32006: LD_INT 0
32008: EQUAL
32009: AND
32010: IFFALSE 32065
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
32012: LD_ADDR_VAR 0 5
32016: PUSH
32017: LD_EXP 66
32021: PUSH
32022: LD_VAR 0 2
32026: ARRAY
32027: PPUSH
32028: LD_VAR 0 3
32032: PPUSH
32033: CALL_OW 3
32037: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
32038: LD_ADDR_EXP 66
32042: PUSH
32043: LD_EXP 66
32047: PPUSH
32048: LD_VAR 0 2
32052: PPUSH
32053: LD_VAR 0 5
32057: PPUSH
32058: CALL_OW 1
32062: ST_TO_ADDR
// continue ;
32063: GO 31909
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
32065: LD_VAR 0 6
32069: PPUSH
32070: LD_EXP 66
32074: PUSH
32075: LD_VAR 0 2
32079: ARRAY
32080: PUSH
32081: LD_VAR 0 3
32085: ARRAY
32086: PUSH
32087: LD_INT 2
32089: ARRAY
32090: PPUSH
32091: LD_EXP 66
32095: PUSH
32096: LD_VAR 0 2
32100: ARRAY
32101: PUSH
32102: LD_VAR 0 3
32106: ARRAY
32107: PUSH
32108: LD_INT 3
32110: ARRAY
32111: PPUSH
32112: LD_INT 30
32114: PPUSH
32115: CALL 54930 0 4
32119: PUSH
32120: LD_INT 4
32122: ARRAY
32123: PUSH
32124: LD_INT 0
32126: EQUAL
32127: IFFALSE 32153
// begin target := mc_crates [ i ] [ j ] ;
32129: LD_ADDR_VAR 0 7
32133: PUSH
32134: LD_EXP 66
32138: PUSH
32139: LD_VAR 0 2
32143: ARRAY
32144: PUSH
32145: LD_VAR 0 3
32149: ARRAY
32150: ST_TO_ADDR
// break ;
32151: GO 32155
// end ; end ;
32153: GO 31909
32155: POP
32156: POP
// if not target then
32157: LD_VAR 0 7
32161: NOT
32162: IFFALSE 32166
// continue ;
32164: GO 31716
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
32166: LD_ADDR_VAR 0 8
32170: PUSH
32171: LD_EXP 69
32175: PUSH
32176: LD_VAR 0 2
32180: ARRAY
32181: PPUSH
32182: LD_INT 2
32184: PUSH
32185: LD_INT 3
32187: PUSH
32188: LD_INT 58
32190: PUSH
32191: EMPTY
32192: LIST
32193: PUSH
32194: EMPTY
32195: LIST
32196: LIST
32197: PUSH
32198: LD_INT 61
32200: PUSH
32201: EMPTY
32202: LIST
32203: PUSH
32204: LD_INT 33
32206: PUSH
32207: LD_INT 5
32209: PUSH
32210: EMPTY
32211: LIST
32212: LIST
32213: PUSH
32214: LD_INT 33
32216: PUSH
32217: LD_INT 3
32219: PUSH
32220: EMPTY
32221: LIST
32222: LIST
32223: PUSH
32224: EMPTY
32225: LIST
32226: LIST
32227: LIST
32228: LIST
32229: LIST
32230: PUSH
32231: LD_INT 2
32233: PUSH
32234: LD_INT 34
32236: PUSH
32237: LD_INT 32
32239: PUSH
32240: EMPTY
32241: LIST
32242: LIST
32243: PUSH
32244: LD_INT 34
32246: PUSH
32247: LD_INT 51
32249: PUSH
32250: EMPTY
32251: LIST
32252: LIST
32253: PUSH
32254: LD_INT 34
32256: PUSH
32257: LD_INT 12
32259: PUSH
32260: EMPTY
32261: LIST
32262: LIST
32263: PUSH
32264: EMPTY
32265: LIST
32266: LIST
32267: LIST
32268: LIST
32269: PUSH
32270: EMPTY
32271: LIST
32272: LIST
32273: PPUSH
32274: CALL_OW 72
32278: ST_TO_ADDR
// if not cargo then
32279: LD_VAR 0 8
32283: NOT
32284: IFFALSE 32990
// begin if mc_crates_collector [ i ] < 5 then
32286: LD_EXP 67
32290: PUSH
32291: LD_VAR 0 2
32295: ARRAY
32296: PUSH
32297: LD_INT 5
32299: LESS
32300: IFFALSE 32666
// begin if mc_ape [ i ] then
32302: LD_EXP 79
32306: PUSH
32307: LD_VAR 0 2
32311: ARRAY
32312: IFFALSE 32359
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
32314: LD_ADDR_VAR 0 5
32318: PUSH
32319: LD_EXP 79
32323: PUSH
32324: LD_VAR 0 2
32328: ARRAY
32329: PPUSH
32330: LD_INT 25
32332: PUSH
32333: LD_INT 16
32335: PUSH
32336: EMPTY
32337: LIST
32338: LIST
32339: PUSH
32340: LD_INT 24
32342: PUSH
32343: LD_INT 750
32345: PUSH
32346: EMPTY
32347: LIST
32348: LIST
32349: PUSH
32350: EMPTY
32351: LIST
32352: LIST
32353: PPUSH
32354: CALL_OW 72
32358: ST_TO_ADDR
// if not tmp then
32359: LD_VAR 0 5
32363: NOT
32364: IFFALSE 32411
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
32366: LD_ADDR_VAR 0 5
32370: PUSH
32371: LD_EXP 50
32375: PUSH
32376: LD_VAR 0 2
32380: ARRAY
32381: PPUSH
32382: LD_INT 25
32384: PUSH
32385: LD_INT 2
32387: PUSH
32388: EMPTY
32389: LIST
32390: LIST
32391: PUSH
32392: LD_INT 24
32394: PUSH
32395: LD_INT 750
32397: PUSH
32398: EMPTY
32399: LIST
32400: LIST
32401: PUSH
32402: EMPTY
32403: LIST
32404: LIST
32405: PPUSH
32406: CALL_OW 72
32410: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
32411: LD_EXP 79
32415: PUSH
32416: LD_VAR 0 2
32420: ARRAY
32421: PUSH
32422: LD_EXP 50
32426: PUSH
32427: LD_VAR 0 2
32431: ARRAY
32432: PPUSH
32433: LD_INT 25
32435: PUSH
32436: LD_INT 2
32438: PUSH
32439: EMPTY
32440: LIST
32441: LIST
32442: PUSH
32443: LD_INT 24
32445: PUSH
32446: LD_INT 750
32448: PUSH
32449: EMPTY
32450: LIST
32451: LIST
32452: PUSH
32453: EMPTY
32454: LIST
32455: LIST
32456: PPUSH
32457: CALL_OW 72
32461: AND
32462: PUSH
32463: LD_VAR 0 5
32467: PUSH
32468: LD_INT 5
32470: LESS
32471: AND
32472: IFFALSE 32554
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
32474: LD_ADDR_VAR 0 3
32478: PUSH
32479: LD_EXP 50
32483: PUSH
32484: LD_VAR 0 2
32488: ARRAY
32489: PPUSH
32490: LD_INT 25
32492: PUSH
32493: LD_INT 2
32495: PUSH
32496: EMPTY
32497: LIST
32498: LIST
32499: PUSH
32500: LD_INT 24
32502: PUSH
32503: LD_INT 750
32505: PUSH
32506: EMPTY
32507: LIST
32508: LIST
32509: PUSH
32510: EMPTY
32511: LIST
32512: LIST
32513: PPUSH
32514: CALL_OW 72
32518: PUSH
32519: FOR_IN
32520: IFFALSE 32552
// begin tmp := tmp union j ;
32522: LD_ADDR_VAR 0 5
32526: PUSH
32527: LD_VAR 0 5
32531: PUSH
32532: LD_VAR 0 3
32536: UNION
32537: ST_TO_ADDR
// if tmp >= 5 then
32538: LD_VAR 0 5
32542: PUSH
32543: LD_INT 5
32545: GREATEREQUAL
32546: IFFALSE 32550
// break ;
32548: GO 32552
// end ;
32550: GO 32519
32552: POP
32553: POP
// end ; if not tmp then
32554: LD_VAR 0 5
32558: NOT
32559: IFFALSE 32563
// continue ;
32561: GO 31716
// for j in tmp do
32563: LD_ADDR_VAR 0 3
32567: PUSH
32568: LD_VAR 0 5
32572: PUSH
32573: FOR_IN
32574: IFFALSE 32664
// if not GetTag ( j ) then
32576: LD_VAR 0 3
32580: PPUSH
32581: CALL_OW 110
32585: NOT
32586: IFFALSE 32662
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
32588: LD_ADDR_EXP 67
32592: PUSH
32593: LD_EXP 67
32597: PPUSH
32598: LD_VAR 0 2
32602: PUSH
32603: LD_EXP 67
32607: PUSH
32608: LD_VAR 0 2
32612: ARRAY
32613: PUSH
32614: LD_INT 1
32616: PLUS
32617: PUSH
32618: EMPTY
32619: LIST
32620: LIST
32621: PPUSH
32622: LD_VAR 0 3
32626: PPUSH
32627: CALL 54034 0 3
32631: ST_TO_ADDR
// SetTag ( j , 107 ) ;
32632: LD_VAR 0 3
32636: PPUSH
32637: LD_INT 107
32639: PPUSH
32640: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
32644: LD_EXP 67
32648: PUSH
32649: LD_VAR 0 2
32653: ARRAY
32654: PUSH
32655: LD_INT 5
32657: GREATEREQUAL
32658: IFFALSE 32662
// break ;
32660: GO 32664
// end ;
32662: GO 32573
32664: POP
32665: POP
// end ; if mc_crates_collector [ i ] and target then
32666: LD_EXP 67
32670: PUSH
32671: LD_VAR 0 2
32675: ARRAY
32676: PUSH
32677: LD_VAR 0 7
32681: AND
32682: IFFALSE 32988
// begin if mc_crates_collector [ i ] < target [ 1 ] then
32684: LD_EXP 67
32688: PUSH
32689: LD_VAR 0 2
32693: ARRAY
32694: PUSH
32695: LD_VAR 0 7
32699: PUSH
32700: LD_INT 1
32702: ARRAY
32703: LESS
32704: IFFALSE 32724
// tmp := mc_crates_collector [ i ] else
32706: LD_ADDR_VAR 0 5
32710: PUSH
32711: LD_EXP 67
32715: PUSH
32716: LD_VAR 0 2
32720: ARRAY
32721: ST_TO_ADDR
32722: GO 32738
// tmp := target [ 1 ] ;
32724: LD_ADDR_VAR 0 5
32728: PUSH
32729: LD_VAR 0 7
32733: PUSH
32734: LD_INT 1
32736: ARRAY
32737: ST_TO_ADDR
// k := 0 ;
32738: LD_ADDR_VAR 0 4
32742: PUSH
32743: LD_INT 0
32745: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
32746: LD_ADDR_VAR 0 3
32750: PUSH
32751: LD_EXP 67
32755: PUSH
32756: LD_VAR 0 2
32760: ARRAY
32761: PUSH
32762: FOR_IN
32763: IFFALSE 32986
// begin k := k + 1 ;
32765: LD_ADDR_VAR 0 4
32769: PUSH
32770: LD_VAR 0 4
32774: PUSH
32775: LD_INT 1
32777: PLUS
32778: ST_TO_ADDR
// if k > tmp then
32779: LD_VAR 0 4
32783: PUSH
32784: LD_VAR 0 5
32788: GREATER
32789: IFFALSE 32793
// break ;
32791: GO 32986
// if not GetClass ( j ) in [ 2 , 16 ] then
32793: LD_VAR 0 3
32797: PPUSH
32798: CALL_OW 257
32802: PUSH
32803: LD_INT 2
32805: PUSH
32806: LD_INT 16
32808: PUSH
32809: EMPTY
32810: LIST
32811: LIST
32812: IN
32813: NOT
32814: IFFALSE 32867
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
32816: LD_ADDR_EXP 67
32820: PUSH
32821: LD_EXP 67
32825: PPUSH
32826: LD_VAR 0 2
32830: PPUSH
32831: LD_EXP 67
32835: PUSH
32836: LD_VAR 0 2
32840: ARRAY
32841: PUSH
32842: LD_VAR 0 3
32846: DIFF
32847: PPUSH
32848: CALL_OW 1
32852: ST_TO_ADDR
// SetTag ( j , 0 ) ;
32853: LD_VAR 0 3
32857: PPUSH
32858: LD_INT 0
32860: PPUSH
32861: CALL_OW 109
// continue ;
32865: GO 32762
// end ; if IsInUnit ( j ) then
32867: LD_VAR 0 3
32871: PPUSH
32872: CALL_OW 310
32876: IFFALSE 32887
// ComExitBuilding ( j ) ;
32878: LD_VAR 0 3
32882: PPUSH
32883: CALL_OW 122
// wait ( 3 ) ;
32887: LD_INT 3
32889: PPUSH
32890: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
32894: LD_VAR 0 3
32898: PPUSH
32899: CALL_OW 314
32903: PUSH
32904: LD_VAR 0 6
32908: PPUSH
32909: LD_VAR 0 7
32913: PUSH
32914: LD_INT 2
32916: ARRAY
32917: PPUSH
32918: LD_VAR 0 7
32922: PUSH
32923: LD_INT 3
32925: ARRAY
32926: PPUSH
32927: LD_INT 30
32929: PPUSH
32930: CALL 54930 0 4
32934: PUSH
32935: LD_INT 4
32937: ARRAY
32938: AND
32939: IFFALSE 32957
// ComStandNearbyBuilding ( j , depot ) else
32941: LD_VAR 0 3
32945: PPUSH
32946: LD_VAR 0 9
32950: PPUSH
32951: CALL 50636 0 2
32955: GO 32984
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
32957: LD_VAR 0 3
32961: PPUSH
32962: LD_VAR 0 7
32966: PUSH
32967: LD_INT 2
32969: ARRAY
32970: PPUSH
32971: LD_VAR 0 7
32975: PUSH
32976: LD_INT 3
32978: ARRAY
32979: PPUSH
32980: CALL_OW 117
// end ;
32984: GO 32762
32986: POP
32987: POP
// end ; end else
32988: GO 33520
// begin for j in cargo do
32990: LD_ADDR_VAR 0 3
32994: PUSH
32995: LD_VAR 0 8
32999: PUSH
33000: FOR_IN
33001: IFFALSE 33518
// begin if GetTag ( j ) <> 0 then
33003: LD_VAR 0 3
33007: PPUSH
33008: CALL_OW 110
33012: PUSH
33013: LD_INT 0
33015: NONEQUAL
33016: IFFALSE 33020
// continue ;
33018: GO 33000
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
33020: LD_VAR 0 3
33024: PPUSH
33025: CALL_OW 256
33029: PUSH
33030: LD_INT 1000
33032: LESS
33033: PUSH
33034: LD_VAR 0 3
33038: PPUSH
33039: LD_EXP 74
33043: PUSH
33044: LD_VAR 0 2
33048: ARRAY
33049: PPUSH
33050: CALL_OW 308
33054: NOT
33055: AND
33056: IFFALSE 33078
// ComMoveToArea ( j , mc_parking [ i ] ) ;
33058: LD_VAR 0 3
33062: PPUSH
33063: LD_EXP 74
33067: PUSH
33068: LD_VAR 0 2
33072: ARRAY
33073: PPUSH
33074: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
33078: LD_VAR 0 3
33082: PPUSH
33083: CALL_OW 256
33087: PUSH
33088: LD_INT 1000
33090: LESS
33091: PUSH
33092: LD_VAR 0 3
33096: PPUSH
33097: LD_EXP 74
33101: PUSH
33102: LD_VAR 0 2
33106: ARRAY
33107: PPUSH
33108: CALL_OW 308
33112: AND
33113: IFFALSE 33117
// continue ;
33115: GO 33000
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
33117: LD_VAR 0 3
33121: PPUSH
33122: CALL_OW 262
33126: PUSH
33127: LD_INT 2
33129: EQUAL
33130: PUSH
33131: LD_VAR 0 3
33135: PPUSH
33136: CALL_OW 261
33140: PUSH
33141: LD_INT 15
33143: LESS
33144: AND
33145: IFFALSE 33149
// continue ;
33147: GO 33000
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
33149: LD_VAR 0 3
33153: PPUSH
33154: CALL_OW 262
33158: PUSH
33159: LD_INT 1
33161: EQUAL
33162: PUSH
33163: LD_VAR 0 3
33167: PPUSH
33168: CALL_OW 261
33172: PUSH
33173: LD_INT 10
33175: LESS
33176: AND
33177: IFFALSE 33457
// begin if not depot then
33179: LD_VAR 0 9
33183: NOT
33184: IFFALSE 33188
// continue ;
33186: GO 33000
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
33188: LD_VAR 0 3
33192: PPUSH
33193: LD_VAR 0 9
33197: PPUSH
33198: LD_VAR 0 3
33202: PPUSH
33203: CALL_OW 74
33207: PPUSH
33208: CALL_OW 296
33212: PUSH
33213: LD_INT 6
33215: LESS
33216: IFFALSE 33232
// SetFuel ( j , 100 ) else
33218: LD_VAR 0 3
33222: PPUSH
33223: LD_INT 100
33225: PPUSH
33226: CALL_OW 240
33230: GO 33457
// if GetFuel ( j ) = 0 then
33232: LD_VAR 0 3
33236: PPUSH
33237: CALL_OW 261
33241: PUSH
33242: LD_INT 0
33244: EQUAL
33245: IFFALSE 33457
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
33247: LD_ADDR_EXP 69
33251: PUSH
33252: LD_EXP 69
33256: PPUSH
33257: LD_VAR 0 2
33261: PPUSH
33262: LD_EXP 69
33266: PUSH
33267: LD_VAR 0 2
33271: ARRAY
33272: PUSH
33273: LD_VAR 0 3
33277: DIFF
33278: PPUSH
33279: CALL_OW 1
33283: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
33284: LD_VAR 0 3
33288: PPUSH
33289: CALL_OW 263
33293: PUSH
33294: LD_INT 1
33296: EQUAL
33297: IFFALSE 33313
// ComExitVehicle ( IsInUnit ( j ) ) ;
33299: LD_VAR 0 3
33303: PPUSH
33304: CALL_OW 310
33308: PPUSH
33309: CALL_OW 121
// if GetControl ( j ) = control_remote then
33313: LD_VAR 0 3
33317: PPUSH
33318: CALL_OW 263
33322: PUSH
33323: LD_INT 2
33325: EQUAL
33326: IFFALSE 33337
// ComUnlink ( j ) ;
33328: LD_VAR 0 3
33332: PPUSH
33333: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
33337: LD_ADDR_VAR 0 10
33341: PUSH
33342: LD_VAR 0 2
33346: PPUSH
33347: LD_INT 3
33349: PPUSH
33350: CALL 43101 0 2
33354: ST_TO_ADDR
// if fac then
33355: LD_VAR 0 10
33359: IFFALSE 33455
// begin for k in fac do
33361: LD_ADDR_VAR 0 4
33365: PUSH
33366: LD_VAR 0 10
33370: PUSH
33371: FOR_IN
33372: IFFALSE 33453
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
33374: LD_ADDR_VAR 0 11
33378: PUSH
33379: LD_VAR 0 10
33383: PPUSH
33384: LD_VAR 0 3
33388: PPUSH
33389: CALL_OW 265
33393: PPUSH
33394: LD_VAR 0 3
33398: PPUSH
33399: CALL_OW 262
33403: PPUSH
33404: LD_VAR 0 3
33408: PPUSH
33409: CALL_OW 263
33413: PPUSH
33414: LD_VAR 0 3
33418: PPUSH
33419: CALL_OW 264
33423: PPUSH
33424: CALL 51532 0 5
33428: ST_TO_ADDR
// if components then
33429: LD_VAR 0 11
33433: IFFALSE 33451
// begin MC_InsertProduceList ( i , components ) ;
33435: LD_VAR 0 2
33439: PPUSH
33440: LD_VAR 0 11
33444: PPUSH
33445: CALL 42646 0 2
// break ;
33449: GO 33453
// end ; end ;
33451: GO 33371
33453: POP
33454: POP
// end ; continue ;
33455: GO 33000
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
33457: LD_VAR 0 3
33461: PPUSH
33462: LD_INT 1
33464: PPUSH
33465: CALL_OW 289
33469: PUSH
33470: LD_INT 100
33472: LESS
33473: PUSH
33474: LD_VAR 0 3
33478: PPUSH
33479: CALL_OW 314
33483: NOT
33484: AND
33485: IFFALSE 33514
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
33487: LD_VAR 0 3
33491: PPUSH
33492: LD_VAR 0 7
33496: PUSH
33497: LD_INT 2
33499: ARRAY
33500: PPUSH
33501: LD_VAR 0 7
33505: PUSH
33506: LD_INT 3
33508: ARRAY
33509: PPUSH
33510: CALL_OW 117
// break ;
33514: GO 33518
// end ;
33516: GO 33000
33518: POP
33519: POP
// end ; end ;
33520: GO 31716
33522: POP
33523: POP
// end ;
33524: LD_VAR 0 1
33528: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
33529: LD_INT 0
33531: PPUSH
33532: PPUSH
33533: PPUSH
33534: PPUSH
// if not mc_bases then
33535: LD_EXP 50
33539: NOT
33540: IFFALSE 33544
// exit ;
33542: GO 33705
// for i = 1 to mc_bases do
33544: LD_ADDR_VAR 0 2
33548: PUSH
33549: DOUBLE
33550: LD_INT 1
33552: DEC
33553: ST_TO_ADDR
33554: LD_EXP 50
33558: PUSH
33559: FOR_TO
33560: IFFALSE 33703
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
33562: LD_ADDR_VAR 0 4
33566: PUSH
33567: LD_EXP 69
33571: PUSH
33572: LD_VAR 0 2
33576: ARRAY
33577: PUSH
33578: LD_EXP 72
33582: PUSH
33583: LD_VAR 0 2
33587: ARRAY
33588: UNION
33589: PPUSH
33590: LD_INT 33
33592: PUSH
33593: LD_INT 2
33595: PUSH
33596: EMPTY
33597: LIST
33598: LIST
33599: PPUSH
33600: CALL_OW 72
33604: ST_TO_ADDR
// if tmp then
33605: LD_VAR 0 4
33609: IFFALSE 33701
// for j in tmp do
33611: LD_ADDR_VAR 0 3
33615: PUSH
33616: LD_VAR 0 4
33620: PUSH
33621: FOR_IN
33622: IFFALSE 33699
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
33624: LD_VAR 0 3
33628: PPUSH
33629: CALL_OW 312
33633: NOT
33634: PUSH
33635: LD_VAR 0 3
33639: PPUSH
33640: CALL_OW 256
33644: PUSH
33645: LD_INT 250
33647: GREATEREQUAL
33648: AND
33649: IFFALSE 33662
// Connect ( j ) else
33651: LD_VAR 0 3
33655: PPUSH
33656: CALL 57003 0 1
33660: GO 33697
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
33662: LD_VAR 0 3
33666: PPUSH
33667: CALL_OW 256
33671: PUSH
33672: LD_INT 250
33674: LESS
33675: PUSH
33676: LD_VAR 0 3
33680: PPUSH
33681: CALL_OW 312
33685: AND
33686: IFFALSE 33697
// ComUnlink ( j ) ;
33688: LD_VAR 0 3
33692: PPUSH
33693: CALL_OW 136
33697: GO 33621
33699: POP
33700: POP
// end ;
33701: GO 33559
33703: POP
33704: POP
// end ;
33705: LD_VAR 0 1
33709: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
33710: LD_INT 0
33712: PPUSH
33713: PPUSH
33714: PPUSH
33715: PPUSH
33716: PPUSH
// if not mc_bases then
33717: LD_EXP 50
33721: NOT
33722: IFFALSE 33726
// exit ;
33724: GO 34171
// for i = 1 to mc_bases do
33726: LD_ADDR_VAR 0 2
33730: PUSH
33731: DOUBLE
33732: LD_INT 1
33734: DEC
33735: ST_TO_ADDR
33736: LD_EXP 50
33740: PUSH
33741: FOR_TO
33742: IFFALSE 34169
// begin if not mc_produce [ i ] then
33744: LD_EXP 71
33748: PUSH
33749: LD_VAR 0 2
33753: ARRAY
33754: NOT
33755: IFFALSE 33759
// continue ;
33757: GO 33741
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
33759: LD_ADDR_VAR 0 5
33763: PUSH
33764: LD_EXP 50
33768: PUSH
33769: LD_VAR 0 2
33773: ARRAY
33774: PPUSH
33775: LD_INT 30
33777: PUSH
33778: LD_INT 3
33780: PUSH
33781: EMPTY
33782: LIST
33783: LIST
33784: PPUSH
33785: CALL_OW 72
33789: ST_TO_ADDR
// if not fac then
33790: LD_VAR 0 5
33794: NOT
33795: IFFALSE 33799
// continue ;
33797: GO 33741
// for j in fac do
33799: LD_ADDR_VAR 0 3
33803: PUSH
33804: LD_VAR 0 5
33808: PUSH
33809: FOR_IN
33810: IFFALSE 34165
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
33812: LD_VAR 0 3
33816: PPUSH
33817: CALL_OW 461
33821: PUSH
33822: LD_INT 2
33824: NONEQUAL
33825: PUSH
33826: LD_VAR 0 3
33830: PPUSH
33831: LD_INT 15
33833: PPUSH
33834: CALL 56631 0 2
33838: PUSH
33839: LD_INT 4
33841: ARRAY
33842: OR
33843: IFFALSE 33847
// continue ;
33845: GO 33809
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
33847: LD_VAR 0 3
33851: PPUSH
33852: LD_EXP 71
33856: PUSH
33857: LD_VAR 0 2
33861: ARRAY
33862: PUSH
33863: LD_INT 1
33865: ARRAY
33866: PUSH
33867: LD_INT 1
33869: ARRAY
33870: PPUSH
33871: LD_EXP 71
33875: PUSH
33876: LD_VAR 0 2
33880: ARRAY
33881: PUSH
33882: LD_INT 1
33884: ARRAY
33885: PUSH
33886: LD_INT 2
33888: ARRAY
33889: PPUSH
33890: LD_EXP 71
33894: PUSH
33895: LD_VAR 0 2
33899: ARRAY
33900: PUSH
33901: LD_INT 1
33903: ARRAY
33904: PUSH
33905: LD_INT 3
33907: ARRAY
33908: PPUSH
33909: LD_EXP 71
33913: PUSH
33914: LD_VAR 0 2
33918: ARRAY
33919: PUSH
33920: LD_INT 1
33922: ARRAY
33923: PUSH
33924: LD_INT 4
33926: ARRAY
33927: PPUSH
33928: CALL_OW 448
33932: PUSH
33933: LD_VAR 0 3
33937: PPUSH
33938: LD_EXP 71
33942: PUSH
33943: LD_VAR 0 2
33947: ARRAY
33948: PUSH
33949: LD_INT 1
33951: ARRAY
33952: PUSH
33953: LD_INT 1
33955: ARRAY
33956: PUSH
33957: LD_EXP 71
33961: PUSH
33962: LD_VAR 0 2
33966: ARRAY
33967: PUSH
33968: LD_INT 1
33970: ARRAY
33971: PUSH
33972: LD_INT 2
33974: ARRAY
33975: PUSH
33976: LD_EXP 71
33980: PUSH
33981: LD_VAR 0 2
33985: ARRAY
33986: PUSH
33987: LD_INT 1
33989: ARRAY
33990: PUSH
33991: LD_INT 3
33993: ARRAY
33994: PUSH
33995: LD_EXP 71
33999: PUSH
34000: LD_VAR 0 2
34004: ARRAY
34005: PUSH
34006: LD_INT 1
34008: ARRAY
34009: PUSH
34010: LD_INT 4
34012: ARRAY
34013: PUSH
34014: EMPTY
34015: LIST
34016: LIST
34017: LIST
34018: LIST
34019: PPUSH
34020: CALL 60398 0 2
34024: AND
34025: IFFALSE 34163
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
34027: LD_VAR 0 3
34031: PPUSH
34032: LD_EXP 71
34036: PUSH
34037: LD_VAR 0 2
34041: ARRAY
34042: PUSH
34043: LD_INT 1
34045: ARRAY
34046: PUSH
34047: LD_INT 1
34049: ARRAY
34050: PPUSH
34051: LD_EXP 71
34055: PUSH
34056: LD_VAR 0 2
34060: ARRAY
34061: PUSH
34062: LD_INT 1
34064: ARRAY
34065: PUSH
34066: LD_INT 2
34068: ARRAY
34069: PPUSH
34070: LD_EXP 71
34074: PUSH
34075: LD_VAR 0 2
34079: ARRAY
34080: PUSH
34081: LD_INT 1
34083: ARRAY
34084: PUSH
34085: LD_INT 3
34087: ARRAY
34088: PPUSH
34089: LD_EXP 71
34093: PUSH
34094: LD_VAR 0 2
34098: ARRAY
34099: PUSH
34100: LD_INT 1
34102: ARRAY
34103: PUSH
34104: LD_INT 4
34106: ARRAY
34107: PPUSH
34108: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
34112: LD_ADDR_VAR 0 4
34116: PUSH
34117: LD_EXP 71
34121: PUSH
34122: LD_VAR 0 2
34126: ARRAY
34127: PPUSH
34128: LD_INT 1
34130: PPUSH
34131: CALL_OW 3
34135: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
34136: LD_ADDR_EXP 71
34140: PUSH
34141: LD_EXP 71
34145: PPUSH
34146: LD_VAR 0 2
34150: PPUSH
34151: LD_VAR 0 4
34155: PPUSH
34156: CALL_OW 1
34160: ST_TO_ADDR
// break ;
34161: GO 34165
// end ; end ;
34163: GO 33809
34165: POP
34166: POP
// end ;
34167: GO 33741
34169: POP
34170: POP
// end ;
34171: LD_VAR 0 1
34175: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
34176: LD_INT 0
34178: PPUSH
34179: PPUSH
34180: PPUSH
// if not mc_bases then
34181: LD_EXP 50
34185: NOT
34186: IFFALSE 34190
// exit ;
34188: GO 34279
// for i = 1 to mc_bases do
34190: LD_ADDR_VAR 0 2
34194: PUSH
34195: DOUBLE
34196: LD_INT 1
34198: DEC
34199: ST_TO_ADDR
34200: LD_EXP 50
34204: PUSH
34205: FOR_TO
34206: IFFALSE 34277
// begin if mc_attack [ i ] then
34208: LD_EXP 70
34212: PUSH
34213: LD_VAR 0 2
34217: ARRAY
34218: IFFALSE 34275
// begin tmp := mc_attack [ i ] [ 1 ] ;
34220: LD_ADDR_VAR 0 3
34224: PUSH
34225: LD_EXP 70
34229: PUSH
34230: LD_VAR 0 2
34234: ARRAY
34235: PUSH
34236: LD_INT 1
34238: ARRAY
34239: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
34240: LD_ADDR_EXP 70
34244: PUSH
34245: LD_EXP 70
34249: PPUSH
34250: LD_VAR 0 2
34254: PPUSH
34255: EMPTY
34256: PPUSH
34257: CALL_OW 1
34261: ST_TO_ADDR
// Attack ( tmp ) ;
34262: LD_VAR 0 3
34266: PPUSH
34267: CALL 110519 0 1
// exit ;
34271: POP
34272: POP
34273: GO 34279
// end ; end ;
34275: GO 34205
34277: POP
34278: POP
// end ;
34279: LD_VAR 0 1
34283: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
34284: LD_INT 0
34286: PPUSH
34287: PPUSH
34288: PPUSH
34289: PPUSH
34290: PPUSH
34291: PPUSH
34292: PPUSH
// if not mc_bases then
34293: LD_EXP 50
34297: NOT
34298: IFFALSE 34302
// exit ;
34300: GO 35159
// for i = 1 to mc_bases do
34302: LD_ADDR_VAR 0 2
34306: PUSH
34307: DOUBLE
34308: LD_INT 1
34310: DEC
34311: ST_TO_ADDR
34312: LD_EXP 50
34316: PUSH
34317: FOR_TO
34318: IFFALSE 35157
// begin if not mc_bases [ i ] then
34320: LD_EXP 50
34324: PUSH
34325: LD_VAR 0 2
34329: ARRAY
34330: NOT
34331: IFFALSE 34335
// continue ;
34333: GO 34317
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
34335: LD_ADDR_VAR 0 7
34339: PUSH
34340: LD_EXP 50
34344: PUSH
34345: LD_VAR 0 2
34349: ARRAY
34350: PUSH
34351: LD_INT 1
34353: ARRAY
34354: PPUSH
34355: CALL 50858 0 1
34359: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
34360: LD_ADDR_EXP 73
34364: PUSH
34365: LD_EXP 73
34369: PPUSH
34370: LD_VAR 0 2
34374: PPUSH
34375: LD_EXP 50
34379: PUSH
34380: LD_VAR 0 2
34384: ARRAY
34385: PUSH
34386: LD_INT 1
34388: ARRAY
34389: PPUSH
34390: CALL_OW 255
34394: PPUSH
34395: LD_EXP 75
34399: PUSH
34400: LD_VAR 0 2
34404: ARRAY
34405: PPUSH
34406: CALL 50823 0 2
34410: PPUSH
34411: CALL_OW 1
34415: ST_TO_ADDR
// if not mc_scan [ i ] then
34416: LD_EXP 73
34420: PUSH
34421: LD_VAR 0 2
34425: ARRAY
34426: NOT
34427: IFFALSE 34605
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
34429: LD_ADDR_EXP 93
34433: PUSH
34434: LD_EXP 93
34438: PPUSH
34439: LD_VAR 0 2
34443: PPUSH
34444: LD_INT 0
34446: PPUSH
34447: CALL_OW 1
34451: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
34452: LD_ADDR_VAR 0 4
34456: PUSH
34457: LD_EXP 50
34461: PUSH
34462: LD_VAR 0 2
34466: ARRAY
34467: PPUSH
34468: LD_INT 2
34470: PUSH
34471: LD_INT 25
34473: PUSH
34474: LD_INT 5
34476: PUSH
34477: EMPTY
34478: LIST
34479: LIST
34480: PUSH
34481: LD_INT 25
34483: PUSH
34484: LD_INT 8
34486: PUSH
34487: EMPTY
34488: LIST
34489: LIST
34490: PUSH
34491: LD_INT 25
34493: PUSH
34494: LD_INT 9
34496: PUSH
34497: EMPTY
34498: LIST
34499: LIST
34500: PUSH
34501: EMPTY
34502: LIST
34503: LIST
34504: LIST
34505: LIST
34506: PPUSH
34507: CALL_OW 72
34511: ST_TO_ADDR
// if not tmp then
34512: LD_VAR 0 4
34516: NOT
34517: IFFALSE 34521
// continue ;
34519: GO 34317
// for j in tmp do
34521: LD_ADDR_VAR 0 3
34525: PUSH
34526: LD_VAR 0 4
34530: PUSH
34531: FOR_IN
34532: IFFALSE 34603
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
34534: LD_VAR 0 3
34538: PPUSH
34539: CALL_OW 310
34543: PPUSH
34544: CALL_OW 266
34548: PUSH
34549: LD_INT 5
34551: EQUAL
34552: PUSH
34553: LD_VAR 0 3
34557: PPUSH
34558: CALL_OW 257
34562: PUSH
34563: LD_INT 1
34565: EQUAL
34566: AND
34567: PUSH
34568: LD_VAR 0 3
34572: PPUSH
34573: CALL_OW 459
34577: NOT
34578: AND
34579: PUSH
34580: LD_VAR 0 7
34584: AND
34585: IFFALSE 34601
// ComChangeProfession ( j , class ) ;
34587: LD_VAR 0 3
34591: PPUSH
34592: LD_VAR 0 7
34596: PPUSH
34597: CALL_OW 123
34601: GO 34531
34603: POP
34604: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
34605: LD_EXP 73
34609: PUSH
34610: LD_VAR 0 2
34614: ARRAY
34615: PUSH
34616: LD_EXP 93
34620: PUSH
34621: LD_VAR 0 2
34625: ARRAY
34626: NOT
34627: AND
34628: PUSH
34629: LD_EXP 72
34633: PUSH
34634: LD_VAR 0 2
34638: ARRAY
34639: NOT
34640: AND
34641: PUSH
34642: LD_EXP 50
34646: PUSH
34647: LD_VAR 0 2
34651: ARRAY
34652: PPUSH
34653: LD_INT 50
34655: PUSH
34656: EMPTY
34657: LIST
34658: PUSH
34659: LD_INT 2
34661: PUSH
34662: LD_INT 30
34664: PUSH
34665: LD_INT 32
34667: PUSH
34668: EMPTY
34669: LIST
34670: LIST
34671: PUSH
34672: LD_INT 30
34674: PUSH
34675: LD_INT 33
34677: PUSH
34678: EMPTY
34679: LIST
34680: LIST
34681: PUSH
34682: LD_INT 30
34684: PUSH
34685: LD_INT 4
34687: PUSH
34688: EMPTY
34689: LIST
34690: LIST
34691: PUSH
34692: LD_INT 30
34694: PUSH
34695: LD_INT 5
34697: PUSH
34698: EMPTY
34699: LIST
34700: LIST
34701: PUSH
34702: EMPTY
34703: LIST
34704: LIST
34705: LIST
34706: LIST
34707: LIST
34708: PUSH
34709: EMPTY
34710: LIST
34711: LIST
34712: PPUSH
34713: CALL_OW 72
34717: PUSH
34718: LD_INT 4
34720: LESS
34721: PUSH
34722: LD_EXP 50
34726: PUSH
34727: LD_VAR 0 2
34731: ARRAY
34732: PPUSH
34733: LD_INT 3
34735: PUSH
34736: LD_INT 24
34738: PUSH
34739: LD_INT 1000
34741: PUSH
34742: EMPTY
34743: LIST
34744: LIST
34745: PUSH
34746: EMPTY
34747: LIST
34748: LIST
34749: PUSH
34750: LD_INT 2
34752: PUSH
34753: LD_INT 30
34755: PUSH
34756: LD_INT 0
34758: PUSH
34759: EMPTY
34760: LIST
34761: LIST
34762: PUSH
34763: LD_INT 30
34765: PUSH
34766: LD_INT 1
34768: PUSH
34769: EMPTY
34770: LIST
34771: LIST
34772: PUSH
34773: EMPTY
34774: LIST
34775: LIST
34776: LIST
34777: PUSH
34778: EMPTY
34779: LIST
34780: LIST
34781: PPUSH
34782: CALL_OW 72
34786: OR
34787: AND
34788: IFFALSE 35039
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
34790: LD_ADDR_EXP 93
34794: PUSH
34795: LD_EXP 93
34799: PPUSH
34800: LD_VAR 0 2
34804: PPUSH
34805: LD_INT 1
34807: PPUSH
34808: CALL_OW 1
34812: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
34813: LD_ADDR_VAR 0 4
34817: PUSH
34818: LD_EXP 50
34822: PUSH
34823: LD_VAR 0 2
34827: ARRAY
34828: PPUSH
34829: LD_INT 2
34831: PUSH
34832: LD_INT 25
34834: PUSH
34835: LD_INT 1
34837: PUSH
34838: EMPTY
34839: LIST
34840: LIST
34841: PUSH
34842: LD_INT 25
34844: PUSH
34845: LD_INT 5
34847: PUSH
34848: EMPTY
34849: LIST
34850: LIST
34851: PUSH
34852: LD_INT 25
34854: PUSH
34855: LD_INT 8
34857: PUSH
34858: EMPTY
34859: LIST
34860: LIST
34861: PUSH
34862: LD_INT 25
34864: PUSH
34865: LD_INT 9
34867: PUSH
34868: EMPTY
34869: LIST
34870: LIST
34871: PUSH
34872: EMPTY
34873: LIST
34874: LIST
34875: LIST
34876: LIST
34877: LIST
34878: PPUSH
34879: CALL_OW 72
34883: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
34884: LD_ADDR_VAR 0 4
34888: PUSH
34889: LD_VAR 0 4
34893: PUSH
34894: LD_VAR 0 4
34898: PPUSH
34899: LD_INT 18
34901: PPUSH
34902: CALL 83946 0 2
34906: DIFF
34907: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
34908: LD_VAR 0 4
34912: NOT
34913: PUSH
34914: LD_EXP 50
34918: PUSH
34919: LD_VAR 0 2
34923: ARRAY
34924: PPUSH
34925: LD_INT 2
34927: PUSH
34928: LD_INT 30
34930: PUSH
34931: LD_INT 4
34933: PUSH
34934: EMPTY
34935: LIST
34936: LIST
34937: PUSH
34938: LD_INT 30
34940: PUSH
34941: LD_INT 5
34943: PUSH
34944: EMPTY
34945: LIST
34946: LIST
34947: PUSH
34948: EMPTY
34949: LIST
34950: LIST
34951: LIST
34952: PPUSH
34953: CALL_OW 72
34957: NOT
34958: AND
34959: IFFALSE 35021
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
34961: LD_ADDR_VAR 0 4
34965: PUSH
34966: LD_EXP 50
34970: PUSH
34971: LD_VAR 0 2
34975: ARRAY
34976: PPUSH
34977: LD_INT 2
34979: PUSH
34980: LD_INT 25
34982: PUSH
34983: LD_INT 2
34985: PUSH
34986: EMPTY
34987: LIST
34988: LIST
34989: PUSH
34990: LD_INT 25
34992: PUSH
34993: LD_INT 3
34995: PUSH
34996: EMPTY
34997: LIST
34998: LIST
34999: PUSH
35000: LD_INT 25
35002: PUSH
35003: LD_INT 4
35005: PUSH
35006: EMPTY
35007: LIST
35008: LIST
35009: PUSH
35010: EMPTY
35011: LIST
35012: LIST
35013: LIST
35014: LIST
35015: PPUSH
35016: CALL_OW 72
35020: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
35021: LD_VAR 0 2
35025: PPUSH
35026: LD_VAR 0 4
35030: PPUSH
35031: CALL 115228 0 2
// exit ;
35035: POP
35036: POP
35037: GO 35159
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
35039: LD_EXP 73
35043: PUSH
35044: LD_VAR 0 2
35048: ARRAY
35049: PUSH
35050: LD_EXP 93
35054: PUSH
35055: LD_VAR 0 2
35059: ARRAY
35060: NOT
35061: AND
35062: PUSH
35063: LD_EXP 72
35067: PUSH
35068: LD_VAR 0 2
35072: ARRAY
35073: AND
35074: IFFALSE 35155
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
35076: LD_ADDR_EXP 93
35080: PUSH
35081: LD_EXP 93
35085: PPUSH
35086: LD_VAR 0 2
35090: PPUSH
35091: LD_INT 1
35093: PPUSH
35094: CALL_OW 1
35098: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
35099: LD_ADDR_VAR 0 4
35103: PUSH
35104: LD_EXP 72
35108: PUSH
35109: LD_VAR 0 2
35113: ARRAY
35114: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
35115: LD_ADDR_EXP 72
35119: PUSH
35120: LD_EXP 72
35124: PPUSH
35125: LD_VAR 0 2
35129: PPUSH
35130: EMPTY
35131: PPUSH
35132: CALL_OW 1
35136: ST_TO_ADDR
// Defend ( i , tmp ) ;
35137: LD_VAR 0 2
35141: PPUSH
35142: LD_VAR 0 4
35146: PPUSH
35147: CALL 115824 0 2
// exit ;
35151: POP
35152: POP
35153: GO 35159
// end ; end ;
35155: GO 34317
35157: POP
35158: POP
// end ;
35159: LD_VAR 0 1
35163: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
35164: LD_INT 0
35166: PPUSH
35167: PPUSH
35168: PPUSH
35169: PPUSH
35170: PPUSH
35171: PPUSH
35172: PPUSH
35173: PPUSH
35174: PPUSH
35175: PPUSH
35176: PPUSH
// if not mc_bases then
35177: LD_EXP 50
35181: NOT
35182: IFFALSE 35186
// exit ;
35184: GO 36273
// for i = 1 to mc_bases do
35186: LD_ADDR_VAR 0 2
35190: PUSH
35191: DOUBLE
35192: LD_INT 1
35194: DEC
35195: ST_TO_ADDR
35196: LD_EXP 50
35200: PUSH
35201: FOR_TO
35202: IFFALSE 36271
// begin tmp := mc_lab [ i ] ;
35204: LD_ADDR_VAR 0 6
35208: PUSH
35209: LD_EXP 83
35213: PUSH
35214: LD_VAR 0 2
35218: ARRAY
35219: ST_TO_ADDR
// if not tmp then
35220: LD_VAR 0 6
35224: NOT
35225: IFFALSE 35229
// continue ;
35227: GO 35201
// idle_lab := 0 ;
35229: LD_ADDR_VAR 0 11
35233: PUSH
35234: LD_INT 0
35236: ST_TO_ADDR
// for j in tmp do
35237: LD_ADDR_VAR 0 3
35241: PUSH
35242: LD_VAR 0 6
35246: PUSH
35247: FOR_IN
35248: IFFALSE 36267
// begin researching := false ;
35250: LD_ADDR_VAR 0 10
35254: PUSH
35255: LD_INT 0
35257: ST_TO_ADDR
// side := GetSide ( j ) ;
35258: LD_ADDR_VAR 0 4
35262: PUSH
35263: LD_VAR 0 3
35267: PPUSH
35268: CALL_OW 255
35272: ST_TO_ADDR
// if not mc_tech [ side ] then
35273: LD_EXP 77
35277: PUSH
35278: LD_VAR 0 4
35282: ARRAY
35283: NOT
35284: IFFALSE 35288
// continue ;
35286: GO 35247
// if BuildingStatus ( j ) = bs_idle then
35288: LD_VAR 0 3
35292: PPUSH
35293: CALL_OW 461
35297: PUSH
35298: LD_INT 2
35300: EQUAL
35301: IFFALSE 35489
// begin if idle_lab and UnitsInside ( j ) < 6 then
35303: LD_VAR 0 11
35307: PUSH
35308: LD_VAR 0 3
35312: PPUSH
35313: CALL_OW 313
35317: PUSH
35318: LD_INT 6
35320: LESS
35321: AND
35322: IFFALSE 35393
// begin tmp2 := UnitsInside ( idle_lab ) ;
35324: LD_ADDR_VAR 0 9
35328: PUSH
35329: LD_VAR 0 11
35333: PPUSH
35334: CALL_OW 313
35338: ST_TO_ADDR
// if tmp2 then
35339: LD_VAR 0 9
35343: IFFALSE 35385
// for x in tmp2 do
35345: LD_ADDR_VAR 0 7
35349: PUSH
35350: LD_VAR 0 9
35354: PUSH
35355: FOR_IN
35356: IFFALSE 35383
// begin ComExitBuilding ( x ) ;
35358: LD_VAR 0 7
35362: PPUSH
35363: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
35367: LD_VAR 0 7
35371: PPUSH
35372: LD_VAR 0 3
35376: PPUSH
35377: CALL_OW 180
// end ;
35381: GO 35355
35383: POP
35384: POP
// idle_lab := 0 ;
35385: LD_ADDR_VAR 0 11
35389: PUSH
35390: LD_INT 0
35392: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
35393: LD_ADDR_VAR 0 5
35397: PUSH
35398: LD_EXP 77
35402: PUSH
35403: LD_VAR 0 4
35407: ARRAY
35408: PUSH
35409: FOR_IN
35410: IFFALSE 35470
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
35412: LD_VAR 0 3
35416: PPUSH
35417: LD_VAR 0 5
35421: PPUSH
35422: CALL_OW 430
35426: PUSH
35427: LD_VAR 0 4
35431: PPUSH
35432: LD_VAR 0 5
35436: PPUSH
35437: CALL 49928 0 2
35441: AND
35442: IFFALSE 35468
// begin researching := true ;
35444: LD_ADDR_VAR 0 10
35448: PUSH
35449: LD_INT 1
35451: ST_TO_ADDR
// ComResearch ( j , t ) ;
35452: LD_VAR 0 3
35456: PPUSH
35457: LD_VAR 0 5
35461: PPUSH
35462: CALL_OW 124
// break ;
35466: GO 35470
// end ;
35468: GO 35409
35470: POP
35471: POP
// if not researching then
35472: LD_VAR 0 10
35476: NOT
35477: IFFALSE 35489
// idle_lab := j ;
35479: LD_ADDR_VAR 0 11
35483: PUSH
35484: LD_VAR 0 3
35488: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
35489: LD_VAR 0 3
35493: PPUSH
35494: CALL_OW 461
35498: PUSH
35499: LD_INT 10
35501: EQUAL
35502: IFFALSE 36090
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
35504: LD_EXP 79
35508: PUSH
35509: LD_VAR 0 2
35513: ARRAY
35514: NOT
35515: PUSH
35516: LD_EXP 80
35520: PUSH
35521: LD_VAR 0 2
35525: ARRAY
35526: NOT
35527: AND
35528: PUSH
35529: LD_EXP 77
35533: PUSH
35534: LD_VAR 0 4
35538: ARRAY
35539: PUSH
35540: LD_INT 1
35542: GREATER
35543: AND
35544: IFFALSE 35675
// begin ComCancel ( j ) ;
35546: LD_VAR 0 3
35550: PPUSH
35551: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
35555: LD_ADDR_EXP 77
35559: PUSH
35560: LD_EXP 77
35564: PPUSH
35565: LD_VAR 0 4
35569: PPUSH
35570: LD_EXP 77
35574: PUSH
35575: LD_VAR 0 4
35579: ARRAY
35580: PPUSH
35581: LD_EXP 77
35585: PUSH
35586: LD_VAR 0 4
35590: ARRAY
35591: PUSH
35592: LD_INT 1
35594: MINUS
35595: PPUSH
35596: LD_EXP 77
35600: PUSH
35601: LD_VAR 0 4
35605: ARRAY
35606: PPUSH
35607: LD_INT 0
35609: PPUSH
35610: CALL 53452 0 4
35614: PPUSH
35615: CALL_OW 1
35619: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
35620: LD_ADDR_EXP 77
35624: PUSH
35625: LD_EXP 77
35629: PPUSH
35630: LD_VAR 0 4
35634: PPUSH
35635: LD_EXP 77
35639: PUSH
35640: LD_VAR 0 4
35644: ARRAY
35645: PPUSH
35646: LD_EXP 77
35650: PUSH
35651: LD_VAR 0 4
35655: ARRAY
35656: PPUSH
35657: LD_INT 1
35659: PPUSH
35660: LD_INT 0
35662: PPUSH
35663: CALL 53452 0 4
35667: PPUSH
35668: CALL_OW 1
35672: ST_TO_ADDR
// continue ;
35673: GO 35247
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
35675: LD_EXP 79
35679: PUSH
35680: LD_VAR 0 2
35684: ARRAY
35685: PUSH
35686: LD_EXP 80
35690: PUSH
35691: LD_VAR 0 2
35695: ARRAY
35696: NOT
35697: AND
35698: IFFALSE 35825
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
35700: LD_ADDR_EXP 80
35704: PUSH
35705: LD_EXP 80
35709: PPUSH
35710: LD_VAR 0 2
35714: PUSH
35715: LD_EXP 80
35719: PUSH
35720: LD_VAR 0 2
35724: ARRAY
35725: PUSH
35726: LD_INT 1
35728: PLUS
35729: PUSH
35730: EMPTY
35731: LIST
35732: LIST
35733: PPUSH
35734: LD_EXP 79
35738: PUSH
35739: LD_VAR 0 2
35743: ARRAY
35744: PUSH
35745: LD_INT 1
35747: ARRAY
35748: PPUSH
35749: CALL 54034 0 3
35753: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
35754: LD_EXP 79
35758: PUSH
35759: LD_VAR 0 2
35763: ARRAY
35764: PUSH
35765: LD_INT 1
35767: ARRAY
35768: PPUSH
35769: LD_INT 112
35771: PPUSH
35772: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
35776: LD_ADDR_VAR 0 9
35780: PUSH
35781: LD_EXP 79
35785: PUSH
35786: LD_VAR 0 2
35790: ARRAY
35791: PPUSH
35792: LD_INT 1
35794: PPUSH
35795: CALL_OW 3
35799: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
35800: LD_ADDR_EXP 79
35804: PUSH
35805: LD_EXP 79
35809: PPUSH
35810: LD_VAR 0 2
35814: PPUSH
35815: LD_VAR 0 9
35819: PPUSH
35820: CALL_OW 1
35824: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
35825: LD_EXP 79
35829: PUSH
35830: LD_VAR 0 2
35834: ARRAY
35835: PUSH
35836: LD_EXP 80
35840: PUSH
35841: LD_VAR 0 2
35845: ARRAY
35846: AND
35847: PUSH
35848: LD_EXP 80
35852: PUSH
35853: LD_VAR 0 2
35857: ARRAY
35858: PUSH
35859: LD_INT 1
35861: ARRAY
35862: PPUSH
35863: CALL_OW 310
35867: NOT
35868: AND
35869: PUSH
35870: LD_VAR 0 3
35874: PPUSH
35875: CALL_OW 313
35879: PUSH
35880: LD_INT 6
35882: EQUAL
35883: AND
35884: IFFALSE 35940
// begin tmp2 := UnitsInside ( j ) ;
35886: LD_ADDR_VAR 0 9
35890: PUSH
35891: LD_VAR 0 3
35895: PPUSH
35896: CALL_OW 313
35900: ST_TO_ADDR
// if tmp2 = 6 then
35901: LD_VAR 0 9
35905: PUSH
35906: LD_INT 6
35908: EQUAL
35909: IFFALSE 35940
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
35911: LD_VAR 0 9
35915: PUSH
35916: LD_INT 1
35918: ARRAY
35919: PPUSH
35920: LD_INT 112
35922: PPUSH
35923: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
35927: LD_VAR 0 9
35931: PUSH
35932: LD_INT 1
35934: ARRAY
35935: PPUSH
35936: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
35940: LD_EXP 80
35944: PUSH
35945: LD_VAR 0 2
35949: ARRAY
35950: PUSH
35951: LD_EXP 80
35955: PUSH
35956: LD_VAR 0 2
35960: ARRAY
35961: PUSH
35962: LD_INT 1
35964: ARRAY
35965: PPUSH
35966: CALL_OW 314
35970: NOT
35971: AND
35972: PUSH
35973: LD_EXP 80
35977: PUSH
35978: LD_VAR 0 2
35982: ARRAY
35983: PUSH
35984: LD_INT 1
35986: ARRAY
35987: PPUSH
35988: CALL_OW 310
35992: NOT
35993: AND
35994: IFFALSE 36020
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
35996: LD_EXP 80
36000: PUSH
36001: LD_VAR 0 2
36005: ARRAY
36006: PUSH
36007: LD_INT 1
36009: ARRAY
36010: PPUSH
36011: LD_VAR 0 3
36015: PPUSH
36016: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
36020: LD_EXP 80
36024: PUSH
36025: LD_VAR 0 2
36029: ARRAY
36030: PUSH
36031: LD_INT 1
36033: ARRAY
36034: PPUSH
36035: CALL_OW 310
36039: PUSH
36040: LD_EXP 80
36044: PUSH
36045: LD_VAR 0 2
36049: ARRAY
36050: PUSH
36051: LD_INT 1
36053: ARRAY
36054: PPUSH
36055: CALL_OW 310
36059: PPUSH
36060: CALL_OW 461
36064: PUSH
36065: LD_INT 3
36067: NONEQUAL
36068: AND
36069: IFFALSE 36090
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
36071: LD_EXP 80
36075: PUSH
36076: LD_VAR 0 2
36080: ARRAY
36081: PUSH
36082: LD_INT 1
36084: ARRAY
36085: PPUSH
36086: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
36090: LD_VAR 0 3
36094: PPUSH
36095: CALL_OW 461
36099: PUSH
36100: LD_INT 6
36102: EQUAL
36103: PUSH
36104: LD_VAR 0 6
36108: PUSH
36109: LD_INT 1
36111: GREATER
36112: AND
36113: IFFALSE 36265
// begin sci := [ ] ;
36115: LD_ADDR_VAR 0 8
36119: PUSH
36120: EMPTY
36121: ST_TO_ADDR
// for x in ( tmp diff j ) do
36122: LD_ADDR_VAR 0 7
36126: PUSH
36127: LD_VAR 0 6
36131: PUSH
36132: LD_VAR 0 3
36136: DIFF
36137: PUSH
36138: FOR_IN
36139: IFFALSE 36191
// begin if sci = 6 then
36141: LD_VAR 0 8
36145: PUSH
36146: LD_INT 6
36148: EQUAL
36149: IFFALSE 36153
// break ;
36151: GO 36191
// if BuildingStatus ( x ) = bs_idle then
36153: LD_VAR 0 7
36157: PPUSH
36158: CALL_OW 461
36162: PUSH
36163: LD_INT 2
36165: EQUAL
36166: IFFALSE 36189
// sci := sci ^ UnitsInside ( x ) ;
36168: LD_ADDR_VAR 0 8
36172: PUSH
36173: LD_VAR 0 8
36177: PUSH
36178: LD_VAR 0 7
36182: PPUSH
36183: CALL_OW 313
36187: ADD
36188: ST_TO_ADDR
// end ;
36189: GO 36138
36191: POP
36192: POP
// if not sci then
36193: LD_VAR 0 8
36197: NOT
36198: IFFALSE 36202
// continue ;
36200: GO 35247
// for x in sci do
36202: LD_ADDR_VAR 0 7
36206: PUSH
36207: LD_VAR 0 8
36211: PUSH
36212: FOR_IN
36213: IFFALSE 36263
// if IsInUnit ( x ) and not HasTask ( x ) then
36215: LD_VAR 0 7
36219: PPUSH
36220: CALL_OW 310
36224: PUSH
36225: LD_VAR 0 7
36229: PPUSH
36230: CALL_OW 314
36234: NOT
36235: AND
36236: IFFALSE 36261
// begin ComExitBuilding ( x ) ;
36238: LD_VAR 0 7
36242: PPUSH
36243: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
36247: LD_VAR 0 7
36251: PPUSH
36252: LD_VAR 0 3
36256: PPUSH
36257: CALL_OW 180
// end ;
36261: GO 36212
36263: POP
36264: POP
// end ; end ;
36265: GO 35247
36267: POP
36268: POP
// end ;
36269: GO 35201
36271: POP
36272: POP
// end ;
36273: LD_VAR 0 1
36277: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
36278: LD_INT 0
36280: PPUSH
36281: PPUSH
// if not mc_bases then
36282: LD_EXP 50
36286: NOT
36287: IFFALSE 36291
// exit ;
36289: GO 36372
// for i = 1 to mc_bases do
36291: LD_ADDR_VAR 0 2
36295: PUSH
36296: DOUBLE
36297: LD_INT 1
36299: DEC
36300: ST_TO_ADDR
36301: LD_EXP 50
36305: PUSH
36306: FOR_TO
36307: IFFALSE 36370
// if mc_mines [ i ] and mc_miners [ i ] then
36309: LD_EXP 63
36313: PUSH
36314: LD_VAR 0 2
36318: ARRAY
36319: PUSH
36320: LD_EXP 64
36324: PUSH
36325: LD_VAR 0 2
36329: ARRAY
36330: AND
36331: IFFALSE 36368
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
36333: LD_EXP 64
36337: PUSH
36338: LD_VAR 0 2
36342: ARRAY
36343: PUSH
36344: LD_INT 1
36346: ARRAY
36347: PPUSH
36348: CALL_OW 255
36352: PPUSH
36353: LD_EXP 63
36357: PUSH
36358: LD_VAR 0 2
36362: ARRAY
36363: PPUSH
36364: CALL 51011 0 2
36368: GO 36306
36370: POP
36371: POP
// end ;
36372: LD_VAR 0 1
36376: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
36377: LD_INT 0
36379: PPUSH
36380: PPUSH
36381: PPUSH
36382: PPUSH
36383: PPUSH
36384: PPUSH
36385: PPUSH
36386: PPUSH
// if not mc_bases or not mc_parking then
36387: LD_EXP 50
36391: NOT
36392: PUSH
36393: LD_EXP 74
36397: NOT
36398: OR
36399: IFFALSE 36403
// exit ;
36401: GO 37141
// for i = 1 to mc_bases do
36403: LD_ADDR_VAR 0 2
36407: PUSH
36408: DOUBLE
36409: LD_INT 1
36411: DEC
36412: ST_TO_ADDR
36413: LD_EXP 50
36417: PUSH
36418: FOR_TO
36419: IFFALSE 37139
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
36421: LD_EXP 50
36425: PUSH
36426: LD_VAR 0 2
36430: ARRAY
36431: NOT
36432: PUSH
36433: LD_EXP 74
36437: PUSH
36438: LD_VAR 0 2
36442: ARRAY
36443: NOT
36444: OR
36445: IFFALSE 36449
// continue ;
36447: GO 36418
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
36449: LD_ADDR_VAR 0 5
36453: PUSH
36454: LD_EXP 50
36458: PUSH
36459: LD_VAR 0 2
36463: ARRAY
36464: PUSH
36465: LD_INT 1
36467: ARRAY
36468: PPUSH
36469: CALL_OW 255
36473: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
36474: LD_ADDR_VAR 0 6
36478: PUSH
36479: LD_EXP 50
36483: PUSH
36484: LD_VAR 0 2
36488: ARRAY
36489: PPUSH
36490: LD_INT 30
36492: PUSH
36493: LD_INT 3
36495: PUSH
36496: EMPTY
36497: LIST
36498: LIST
36499: PPUSH
36500: CALL_OW 72
36504: ST_TO_ADDR
// if not fac then
36505: LD_VAR 0 6
36509: NOT
36510: IFFALSE 36561
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
36512: LD_ADDR_VAR 0 6
36516: PUSH
36517: LD_EXP 50
36521: PUSH
36522: LD_VAR 0 2
36526: ARRAY
36527: PPUSH
36528: LD_INT 2
36530: PUSH
36531: LD_INT 30
36533: PUSH
36534: LD_INT 0
36536: PUSH
36537: EMPTY
36538: LIST
36539: LIST
36540: PUSH
36541: LD_INT 30
36543: PUSH
36544: LD_INT 1
36546: PUSH
36547: EMPTY
36548: LIST
36549: LIST
36550: PUSH
36551: EMPTY
36552: LIST
36553: LIST
36554: LIST
36555: PPUSH
36556: CALL_OW 72
36560: ST_TO_ADDR
// if not fac then
36561: LD_VAR 0 6
36565: NOT
36566: IFFALSE 36570
// continue ;
36568: GO 36418
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
36570: LD_ADDR_VAR 0 7
36574: PUSH
36575: LD_EXP 74
36579: PUSH
36580: LD_VAR 0 2
36584: ARRAY
36585: PPUSH
36586: LD_INT 22
36588: PUSH
36589: LD_VAR 0 5
36593: PUSH
36594: EMPTY
36595: LIST
36596: LIST
36597: PUSH
36598: LD_INT 21
36600: PUSH
36601: LD_INT 2
36603: PUSH
36604: EMPTY
36605: LIST
36606: LIST
36607: PUSH
36608: LD_INT 3
36610: PUSH
36611: LD_INT 60
36613: PUSH
36614: EMPTY
36615: LIST
36616: PUSH
36617: EMPTY
36618: LIST
36619: LIST
36620: PUSH
36621: LD_INT 3
36623: PUSH
36624: LD_INT 24
36626: PUSH
36627: LD_INT 1000
36629: PUSH
36630: EMPTY
36631: LIST
36632: LIST
36633: PUSH
36634: EMPTY
36635: LIST
36636: LIST
36637: PUSH
36638: EMPTY
36639: LIST
36640: LIST
36641: LIST
36642: LIST
36643: PPUSH
36644: CALL_OW 70
36648: ST_TO_ADDR
// for j in fac do
36649: LD_ADDR_VAR 0 3
36653: PUSH
36654: LD_VAR 0 6
36658: PUSH
36659: FOR_IN
36660: IFFALSE 36755
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
36662: LD_ADDR_VAR 0 7
36666: PUSH
36667: LD_VAR 0 7
36671: PUSH
36672: LD_INT 22
36674: PUSH
36675: LD_VAR 0 5
36679: PUSH
36680: EMPTY
36681: LIST
36682: LIST
36683: PUSH
36684: LD_INT 91
36686: PUSH
36687: LD_VAR 0 3
36691: PUSH
36692: LD_INT 15
36694: PUSH
36695: EMPTY
36696: LIST
36697: LIST
36698: LIST
36699: PUSH
36700: LD_INT 21
36702: PUSH
36703: LD_INT 2
36705: PUSH
36706: EMPTY
36707: LIST
36708: LIST
36709: PUSH
36710: LD_INT 3
36712: PUSH
36713: LD_INT 60
36715: PUSH
36716: EMPTY
36717: LIST
36718: PUSH
36719: EMPTY
36720: LIST
36721: LIST
36722: PUSH
36723: LD_INT 3
36725: PUSH
36726: LD_INT 24
36728: PUSH
36729: LD_INT 1000
36731: PUSH
36732: EMPTY
36733: LIST
36734: LIST
36735: PUSH
36736: EMPTY
36737: LIST
36738: LIST
36739: PUSH
36740: EMPTY
36741: LIST
36742: LIST
36743: LIST
36744: LIST
36745: LIST
36746: PPUSH
36747: CALL_OW 69
36751: UNION
36752: ST_TO_ADDR
36753: GO 36659
36755: POP
36756: POP
// if not vehs then
36757: LD_VAR 0 7
36761: NOT
36762: IFFALSE 36788
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
36764: LD_ADDR_EXP 62
36768: PUSH
36769: LD_EXP 62
36773: PPUSH
36774: LD_VAR 0 2
36778: PPUSH
36779: EMPTY
36780: PPUSH
36781: CALL_OW 1
36785: ST_TO_ADDR
// continue ;
36786: GO 36418
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
36788: LD_ADDR_VAR 0 8
36792: PUSH
36793: LD_EXP 50
36797: PUSH
36798: LD_VAR 0 2
36802: ARRAY
36803: PPUSH
36804: LD_INT 30
36806: PUSH
36807: LD_INT 3
36809: PUSH
36810: EMPTY
36811: LIST
36812: LIST
36813: PPUSH
36814: CALL_OW 72
36818: ST_TO_ADDR
// if tmp then
36819: LD_VAR 0 8
36823: IFFALSE 36926
// begin for j in tmp do
36825: LD_ADDR_VAR 0 3
36829: PUSH
36830: LD_VAR 0 8
36834: PUSH
36835: FOR_IN
36836: IFFALSE 36924
// for k in UnitsInside ( j ) do
36838: LD_ADDR_VAR 0 4
36842: PUSH
36843: LD_VAR 0 3
36847: PPUSH
36848: CALL_OW 313
36852: PUSH
36853: FOR_IN
36854: IFFALSE 36920
// if k then
36856: LD_VAR 0 4
36860: IFFALSE 36918
// if not k in mc_repair_vehicle [ i ] then
36862: LD_VAR 0 4
36866: PUSH
36867: LD_EXP 62
36871: PUSH
36872: LD_VAR 0 2
36876: ARRAY
36877: IN
36878: NOT
36879: IFFALSE 36918
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
36881: LD_ADDR_EXP 62
36885: PUSH
36886: LD_EXP 62
36890: PPUSH
36891: LD_VAR 0 2
36895: PPUSH
36896: LD_EXP 62
36900: PUSH
36901: LD_VAR 0 2
36905: ARRAY
36906: PUSH
36907: LD_VAR 0 4
36911: UNION
36912: PPUSH
36913: CALL_OW 1
36917: ST_TO_ADDR
36918: GO 36853
36920: POP
36921: POP
36922: GO 36835
36924: POP
36925: POP
// end ; if not mc_repair_vehicle [ i ] then
36926: LD_EXP 62
36930: PUSH
36931: LD_VAR 0 2
36935: ARRAY
36936: NOT
36937: IFFALSE 36941
// continue ;
36939: GO 36418
// for j in mc_repair_vehicle [ i ] do
36941: LD_ADDR_VAR 0 3
36945: PUSH
36946: LD_EXP 62
36950: PUSH
36951: LD_VAR 0 2
36955: ARRAY
36956: PUSH
36957: FOR_IN
36958: IFFALSE 37135
// begin if GetClass ( j ) <> 3 then
36960: LD_VAR 0 3
36964: PPUSH
36965: CALL_OW 257
36969: PUSH
36970: LD_INT 3
36972: NONEQUAL
36973: IFFALSE 37014
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
36975: LD_ADDR_EXP 62
36979: PUSH
36980: LD_EXP 62
36984: PPUSH
36985: LD_VAR 0 2
36989: PPUSH
36990: LD_EXP 62
36994: PUSH
36995: LD_VAR 0 2
36999: ARRAY
37000: PUSH
37001: LD_VAR 0 3
37005: DIFF
37006: PPUSH
37007: CALL_OW 1
37011: ST_TO_ADDR
// continue ;
37012: GO 36957
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
37014: LD_VAR 0 3
37018: PPUSH
37019: CALL_OW 311
37023: NOT
37024: PUSH
37025: LD_VAR 0 3
37029: PUSH
37030: LD_EXP 53
37034: PUSH
37035: LD_VAR 0 2
37039: ARRAY
37040: PUSH
37041: LD_INT 1
37043: ARRAY
37044: IN
37045: NOT
37046: AND
37047: PUSH
37048: LD_VAR 0 3
37052: PUSH
37053: LD_EXP 53
37057: PUSH
37058: LD_VAR 0 2
37062: ARRAY
37063: PUSH
37064: LD_INT 2
37066: ARRAY
37067: IN
37068: NOT
37069: AND
37070: IFFALSE 37133
// begin if IsInUnit ( j ) then
37072: LD_VAR 0 3
37076: PPUSH
37077: CALL_OW 310
37081: IFFALSE 37094
// ComExitBuilding ( j ) else
37083: LD_VAR 0 3
37087: PPUSH
37088: CALL_OW 122
37092: GO 37133
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
37094: LD_VAR 0 3
37098: PPUSH
37099: LD_VAR 0 7
37103: PUSH
37104: LD_INT 1
37106: ARRAY
37107: PPUSH
37108: CALL 88429 0 2
37112: NOT
37113: IFFALSE 37133
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
37115: LD_VAR 0 3
37119: PPUSH
37120: LD_VAR 0 7
37124: PUSH
37125: LD_INT 1
37127: ARRAY
37128: PPUSH
37129: CALL_OW 129
// end ; end ;
37133: GO 36957
37135: POP
37136: POP
// end ;
37137: GO 36418
37139: POP
37140: POP
// end ;
37141: LD_VAR 0 1
37145: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
37146: LD_INT 0
37148: PPUSH
37149: PPUSH
37150: PPUSH
37151: PPUSH
37152: PPUSH
37153: PPUSH
37154: PPUSH
37155: PPUSH
37156: PPUSH
37157: PPUSH
37158: PPUSH
// if not mc_bases then
37159: LD_EXP 50
37163: NOT
37164: IFFALSE 37168
// exit ;
37166: GO 37970
// for i = 1 to mc_bases do
37168: LD_ADDR_VAR 0 2
37172: PUSH
37173: DOUBLE
37174: LD_INT 1
37176: DEC
37177: ST_TO_ADDR
37178: LD_EXP 50
37182: PUSH
37183: FOR_TO
37184: IFFALSE 37968
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
37186: LD_EXP 78
37190: PUSH
37191: LD_VAR 0 2
37195: ARRAY
37196: NOT
37197: PUSH
37198: LD_EXP 53
37202: PUSH
37203: LD_VAR 0 2
37207: ARRAY
37208: PUSH
37209: LD_INT 1
37211: ARRAY
37212: OR
37213: PUSH
37214: LD_EXP 53
37218: PUSH
37219: LD_VAR 0 2
37223: ARRAY
37224: PUSH
37225: LD_INT 2
37227: ARRAY
37228: OR
37229: PUSH
37230: LD_EXP 76
37234: PUSH
37235: LD_VAR 0 2
37239: ARRAY
37240: PPUSH
37241: LD_INT 1
37243: PPUSH
37244: CALL_OW 325
37248: NOT
37249: OR
37250: PUSH
37251: LD_EXP 73
37255: PUSH
37256: LD_VAR 0 2
37260: ARRAY
37261: OR
37262: IFFALSE 37266
// continue ;
37264: GO 37183
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
37266: LD_ADDR_VAR 0 8
37270: PUSH
37271: LD_EXP 50
37275: PUSH
37276: LD_VAR 0 2
37280: ARRAY
37281: PPUSH
37282: LD_INT 25
37284: PUSH
37285: LD_INT 4
37287: PUSH
37288: EMPTY
37289: LIST
37290: LIST
37291: PUSH
37292: LD_INT 50
37294: PUSH
37295: EMPTY
37296: LIST
37297: PUSH
37298: LD_INT 3
37300: PUSH
37301: LD_INT 60
37303: PUSH
37304: EMPTY
37305: LIST
37306: PUSH
37307: EMPTY
37308: LIST
37309: LIST
37310: PUSH
37311: EMPTY
37312: LIST
37313: LIST
37314: LIST
37315: PPUSH
37316: CALL_OW 72
37320: PUSH
37321: LD_EXP 54
37325: PUSH
37326: LD_VAR 0 2
37330: ARRAY
37331: DIFF
37332: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
37333: LD_ADDR_VAR 0 9
37337: PUSH
37338: LD_EXP 50
37342: PUSH
37343: LD_VAR 0 2
37347: ARRAY
37348: PPUSH
37349: LD_INT 2
37351: PUSH
37352: LD_INT 30
37354: PUSH
37355: LD_INT 0
37357: PUSH
37358: EMPTY
37359: LIST
37360: LIST
37361: PUSH
37362: LD_INT 30
37364: PUSH
37365: LD_INT 1
37367: PUSH
37368: EMPTY
37369: LIST
37370: LIST
37371: PUSH
37372: EMPTY
37373: LIST
37374: LIST
37375: LIST
37376: PPUSH
37377: CALL_OW 72
37381: ST_TO_ADDR
// if not tmp or not dep then
37382: LD_VAR 0 8
37386: NOT
37387: PUSH
37388: LD_VAR 0 9
37392: NOT
37393: OR
37394: IFFALSE 37398
// continue ;
37396: GO 37183
// side := GetSide ( tmp [ 1 ] ) ;
37398: LD_ADDR_VAR 0 11
37402: PUSH
37403: LD_VAR 0 8
37407: PUSH
37408: LD_INT 1
37410: ARRAY
37411: PPUSH
37412: CALL_OW 255
37416: ST_TO_ADDR
// dep := dep [ 1 ] ;
37417: LD_ADDR_VAR 0 9
37421: PUSH
37422: LD_VAR 0 9
37426: PUSH
37427: LD_INT 1
37429: ARRAY
37430: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
37431: LD_ADDR_VAR 0 7
37435: PUSH
37436: LD_EXP 78
37440: PUSH
37441: LD_VAR 0 2
37445: ARRAY
37446: PPUSH
37447: LD_INT 22
37449: PUSH
37450: LD_INT 0
37452: PUSH
37453: EMPTY
37454: LIST
37455: LIST
37456: PUSH
37457: LD_INT 25
37459: PUSH
37460: LD_INT 12
37462: PUSH
37463: EMPTY
37464: LIST
37465: LIST
37466: PUSH
37467: EMPTY
37468: LIST
37469: LIST
37470: PPUSH
37471: CALL_OW 70
37475: PUSH
37476: LD_INT 22
37478: PUSH
37479: LD_INT 0
37481: PUSH
37482: EMPTY
37483: LIST
37484: LIST
37485: PUSH
37486: LD_INT 25
37488: PUSH
37489: LD_INT 12
37491: PUSH
37492: EMPTY
37493: LIST
37494: LIST
37495: PUSH
37496: LD_INT 91
37498: PUSH
37499: LD_VAR 0 9
37503: PUSH
37504: LD_INT 20
37506: PUSH
37507: EMPTY
37508: LIST
37509: LIST
37510: LIST
37511: PUSH
37512: EMPTY
37513: LIST
37514: LIST
37515: LIST
37516: PPUSH
37517: CALL_OW 69
37521: UNION
37522: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
37523: LD_ADDR_VAR 0 10
37527: PUSH
37528: LD_EXP 78
37532: PUSH
37533: LD_VAR 0 2
37537: ARRAY
37538: PPUSH
37539: LD_INT 81
37541: PUSH
37542: LD_VAR 0 11
37546: PUSH
37547: EMPTY
37548: LIST
37549: LIST
37550: PPUSH
37551: CALL_OW 70
37555: ST_TO_ADDR
// if not apes or danger_at_area then
37556: LD_VAR 0 7
37560: NOT
37561: PUSH
37562: LD_VAR 0 10
37566: OR
37567: IFFALSE 37617
// begin if mc_taming [ i ] then
37569: LD_EXP 81
37573: PUSH
37574: LD_VAR 0 2
37578: ARRAY
37579: IFFALSE 37615
// begin MC_Reset ( i , 121 ) ;
37581: LD_VAR 0 2
37585: PPUSH
37586: LD_INT 121
37588: PPUSH
37589: CALL 22547 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
37593: LD_ADDR_EXP 81
37597: PUSH
37598: LD_EXP 81
37602: PPUSH
37603: LD_VAR 0 2
37607: PPUSH
37608: EMPTY
37609: PPUSH
37610: CALL_OW 1
37614: ST_TO_ADDR
// end ; continue ;
37615: GO 37183
// end ; for j in tmp do
37617: LD_ADDR_VAR 0 3
37621: PUSH
37622: LD_VAR 0 8
37626: PUSH
37627: FOR_IN
37628: IFFALSE 37964
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
37630: LD_VAR 0 3
37634: PUSH
37635: LD_EXP 81
37639: PUSH
37640: LD_VAR 0 2
37644: ARRAY
37645: IN
37646: NOT
37647: PUSH
37648: LD_EXP 81
37652: PUSH
37653: LD_VAR 0 2
37657: ARRAY
37658: PUSH
37659: LD_INT 3
37661: LESS
37662: AND
37663: IFFALSE 37721
// begin SetTag ( j , 121 ) ;
37665: LD_VAR 0 3
37669: PPUSH
37670: LD_INT 121
37672: PPUSH
37673: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
37677: LD_ADDR_EXP 81
37681: PUSH
37682: LD_EXP 81
37686: PPUSH
37687: LD_VAR 0 2
37691: PUSH
37692: LD_EXP 81
37696: PUSH
37697: LD_VAR 0 2
37701: ARRAY
37702: PUSH
37703: LD_INT 1
37705: PLUS
37706: PUSH
37707: EMPTY
37708: LIST
37709: LIST
37710: PPUSH
37711: LD_VAR 0 3
37715: PPUSH
37716: CALL 54034 0 3
37720: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
37721: LD_VAR 0 3
37725: PUSH
37726: LD_EXP 81
37730: PUSH
37731: LD_VAR 0 2
37735: ARRAY
37736: IN
37737: IFFALSE 37962
// begin if GetClass ( j ) <> 4 then
37739: LD_VAR 0 3
37743: PPUSH
37744: CALL_OW 257
37748: PUSH
37749: LD_INT 4
37751: NONEQUAL
37752: IFFALSE 37805
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
37754: LD_ADDR_EXP 81
37758: PUSH
37759: LD_EXP 81
37763: PPUSH
37764: LD_VAR 0 2
37768: PPUSH
37769: LD_EXP 81
37773: PUSH
37774: LD_VAR 0 2
37778: ARRAY
37779: PUSH
37780: LD_VAR 0 3
37784: DIFF
37785: PPUSH
37786: CALL_OW 1
37790: ST_TO_ADDR
// SetTag ( j , 0 ) ;
37791: LD_VAR 0 3
37795: PPUSH
37796: LD_INT 0
37798: PPUSH
37799: CALL_OW 109
// continue ;
37803: GO 37627
// end ; if IsInUnit ( j ) then
37805: LD_VAR 0 3
37809: PPUSH
37810: CALL_OW 310
37814: IFFALSE 37825
// ComExitBuilding ( j ) ;
37816: LD_VAR 0 3
37820: PPUSH
37821: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
37825: LD_ADDR_VAR 0 6
37829: PUSH
37830: LD_VAR 0 7
37834: PPUSH
37835: LD_VAR 0 3
37839: PPUSH
37840: CALL_OW 74
37844: ST_TO_ADDR
// if not ape then
37845: LD_VAR 0 6
37849: NOT
37850: IFFALSE 37854
// break ;
37852: GO 37964
// x := GetX ( ape ) ;
37854: LD_ADDR_VAR 0 4
37858: PUSH
37859: LD_VAR 0 6
37863: PPUSH
37864: CALL_OW 250
37868: ST_TO_ADDR
// y := GetY ( ape ) ;
37869: LD_ADDR_VAR 0 5
37873: PUSH
37874: LD_VAR 0 6
37878: PPUSH
37879: CALL_OW 251
37883: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
37884: LD_VAR 0 4
37888: PPUSH
37889: LD_VAR 0 5
37893: PPUSH
37894: CALL_OW 488
37898: NOT
37899: PUSH
37900: LD_VAR 0 11
37904: PPUSH
37905: LD_VAR 0 4
37909: PPUSH
37910: LD_VAR 0 5
37914: PPUSH
37915: LD_INT 20
37917: PPUSH
37918: CALL 54930 0 4
37922: PUSH
37923: LD_INT 4
37925: ARRAY
37926: OR
37927: IFFALSE 37931
// break ;
37929: GO 37964
// if not HasTask ( j ) then
37931: LD_VAR 0 3
37935: PPUSH
37936: CALL_OW 314
37940: NOT
37941: IFFALSE 37962
// ComTameXY ( j , x , y ) ;
37943: LD_VAR 0 3
37947: PPUSH
37948: LD_VAR 0 4
37952: PPUSH
37953: LD_VAR 0 5
37957: PPUSH
37958: CALL_OW 131
// end ; end ;
37962: GO 37627
37964: POP
37965: POP
// end ;
37966: GO 37183
37968: POP
37969: POP
// end ;
37970: LD_VAR 0 1
37974: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
37975: LD_INT 0
37977: PPUSH
37978: PPUSH
37979: PPUSH
37980: PPUSH
37981: PPUSH
37982: PPUSH
37983: PPUSH
37984: PPUSH
// if not mc_bases then
37985: LD_EXP 50
37989: NOT
37990: IFFALSE 37994
// exit ;
37992: GO 38620
// for i = 1 to mc_bases do
37994: LD_ADDR_VAR 0 2
37998: PUSH
37999: DOUBLE
38000: LD_INT 1
38002: DEC
38003: ST_TO_ADDR
38004: LD_EXP 50
38008: PUSH
38009: FOR_TO
38010: IFFALSE 38618
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
38012: LD_EXP 79
38016: PUSH
38017: LD_VAR 0 2
38021: ARRAY
38022: NOT
38023: PUSH
38024: LD_EXP 79
38028: PUSH
38029: LD_VAR 0 2
38033: ARRAY
38034: PPUSH
38035: LD_INT 25
38037: PUSH
38038: LD_INT 12
38040: PUSH
38041: EMPTY
38042: LIST
38043: LIST
38044: PPUSH
38045: CALL_OW 72
38049: NOT
38050: OR
38051: IFFALSE 38055
// continue ;
38053: GO 38009
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
38055: LD_ADDR_VAR 0 5
38059: PUSH
38060: LD_EXP 79
38064: PUSH
38065: LD_VAR 0 2
38069: ARRAY
38070: PUSH
38071: LD_INT 1
38073: ARRAY
38074: PPUSH
38075: CALL_OW 255
38079: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
38080: LD_VAR 0 5
38084: PPUSH
38085: LD_INT 2
38087: PPUSH
38088: CALL_OW 325
38092: IFFALSE 38345
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
38094: LD_ADDR_VAR 0 4
38098: PUSH
38099: LD_EXP 79
38103: PUSH
38104: LD_VAR 0 2
38108: ARRAY
38109: PPUSH
38110: LD_INT 25
38112: PUSH
38113: LD_INT 16
38115: PUSH
38116: EMPTY
38117: LIST
38118: LIST
38119: PPUSH
38120: CALL_OW 72
38124: ST_TO_ADDR
// if tmp < 6 then
38125: LD_VAR 0 4
38129: PUSH
38130: LD_INT 6
38132: LESS
38133: IFFALSE 38345
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
38135: LD_ADDR_VAR 0 6
38139: PUSH
38140: LD_EXP 50
38144: PUSH
38145: LD_VAR 0 2
38149: ARRAY
38150: PPUSH
38151: LD_INT 2
38153: PUSH
38154: LD_INT 30
38156: PUSH
38157: LD_INT 0
38159: PUSH
38160: EMPTY
38161: LIST
38162: LIST
38163: PUSH
38164: LD_INT 30
38166: PUSH
38167: LD_INT 1
38169: PUSH
38170: EMPTY
38171: LIST
38172: LIST
38173: PUSH
38174: EMPTY
38175: LIST
38176: LIST
38177: LIST
38178: PPUSH
38179: CALL_OW 72
38183: ST_TO_ADDR
// if depot then
38184: LD_VAR 0 6
38188: IFFALSE 38345
// begin selected := 0 ;
38190: LD_ADDR_VAR 0 7
38194: PUSH
38195: LD_INT 0
38197: ST_TO_ADDR
// for j in depot do
38198: LD_ADDR_VAR 0 3
38202: PUSH
38203: LD_VAR 0 6
38207: PUSH
38208: FOR_IN
38209: IFFALSE 38240
// begin if UnitsInside ( j ) < 6 then
38211: LD_VAR 0 3
38215: PPUSH
38216: CALL_OW 313
38220: PUSH
38221: LD_INT 6
38223: LESS
38224: IFFALSE 38238
// begin selected := j ;
38226: LD_ADDR_VAR 0 7
38230: PUSH
38231: LD_VAR 0 3
38235: ST_TO_ADDR
// break ;
38236: GO 38240
// end ; end ;
38238: GO 38208
38240: POP
38241: POP
// if selected then
38242: LD_VAR 0 7
38246: IFFALSE 38345
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
38248: LD_ADDR_VAR 0 3
38252: PUSH
38253: LD_EXP 79
38257: PUSH
38258: LD_VAR 0 2
38262: ARRAY
38263: PPUSH
38264: LD_INT 25
38266: PUSH
38267: LD_INT 12
38269: PUSH
38270: EMPTY
38271: LIST
38272: LIST
38273: PPUSH
38274: CALL_OW 72
38278: PUSH
38279: FOR_IN
38280: IFFALSE 38343
// if not HasTask ( j ) then
38282: LD_VAR 0 3
38286: PPUSH
38287: CALL_OW 314
38291: NOT
38292: IFFALSE 38341
// begin if not IsInUnit ( j ) then
38294: LD_VAR 0 3
38298: PPUSH
38299: CALL_OW 310
38303: NOT
38304: IFFALSE 38320
// ComEnterUnit ( j , selected ) ;
38306: LD_VAR 0 3
38310: PPUSH
38311: LD_VAR 0 7
38315: PPUSH
38316: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
38320: LD_VAR 0 3
38324: PPUSH
38325: LD_INT 16
38327: PPUSH
38328: CALL_OW 183
// AddComExitBuilding ( j ) ;
38332: LD_VAR 0 3
38336: PPUSH
38337: CALL_OW 182
// end ;
38341: GO 38279
38343: POP
38344: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
38345: LD_VAR 0 5
38349: PPUSH
38350: LD_INT 11
38352: PPUSH
38353: CALL_OW 325
38357: IFFALSE 38616
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
38359: LD_ADDR_VAR 0 4
38363: PUSH
38364: LD_EXP 79
38368: PUSH
38369: LD_VAR 0 2
38373: ARRAY
38374: PPUSH
38375: LD_INT 25
38377: PUSH
38378: LD_INT 16
38380: PUSH
38381: EMPTY
38382: LIST
38383: LIST
38384: PPUSH
38385: CALL_OW 72
38389: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
38390: LD_VAR 0 4
38394: PUSH
38395: LD_INT 6
38397: GREATEREQUAL
38398: PUSH
38399: LD_VAR 0 5
38403: PPUSH
38404: LD_INT 2
38406: PPUSH
38407: CALL_OW 325
38411: NOT
38412: OR
38413: IFFALSE 38616
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
38415: LD_ADDR_VAR 0 8
38419: PUSH
38420: LD_EXP 50
38424: PUSH
38425: LD_VAR 0 2
38429: ARRAY
38430: PPUSH
38431: LD_INT 2
38433: PUSH
38434: LD_INT 30
38436: PUSH
38437: LD_INT 4
38439: PUSH
38440: EMPTY
38441: LIST
38442: LIST
38443: PUSH
38444: LD_INT 30
38446: PUSH
38447: LD_INT 5
38449: PUSH
38450: EMPTY
38451: LIST
38452: LIST
38453: PUSH
38454: EMPTY
38455: LIST
38456: LIST
38457: LIST
38458: PPUSH
38459: CALL_OW 72
38463: ST_TO_ADDR
// if barracks then
38464: LD_VAR 0 8
38468: IFFALSE 38616
// begin selected := 0 ;
38470: LD_ADDR_VAR 0 7
38474: PUSH
38475: LD_INT 0
38477: ST_TO_ADDR
// for j in barracks do
38478: LD_ADDR_VAR 0 3
38482: PUSH
38483: LD_VAR 0 8
38487: PUSH
38488: FOR_IN
38489: IFFALSE 38520
// begin if UnitsInside ( j ) < 6 then
38491: LD_VAR 0 3
38495: PPUSH
38496: CALL_OW 313
38500: PUSH
38501: LD_INT 6
38503: LESS
38504: IFFALSE 38518
// begin selected := j ;
38506: LD_ADDR_VAR 0 7
38510: PUSH
38511: LD_VAR 0 3
38515: ST_TO_ADDR
// break ;
38516: GO 38520
// end ; end ;
38518: GO 38488
38520: POP
38521: POP
// if selected then
38522: LD_VAR 0 7
38526: IFFALSE 38616
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
38528: LD_ADDR_VAR 0 3
38532: PUSH
38533: LD_EXP 79
38537: PUSH
38538: LD_VAR 0 2
38542: ARRAY
38543: PPUSH
38544: LD_INT 25
38546: PUSH
38547: LD_INT 12
38549: PUSH
38550: EMPTY
38551: LIST
38552: LIST
38553: PPUSH
38554: CALL_OW 72
38558: PUSH
38559: FOR_IN
38560: IFFALSE 38614
// if not IsInUnit ( j ) and not HasTask ( j ) then
38562: LD_VAR 0 3
38566: PPUSH
38567: CALL_OW 310
38571: NOT
38572: PUSH
38573: LD_VAR 0 3
38577: PPUSH
38578: CALL_OW 314
38582: NOT
38583: AND
38584: IFFALSE 38612
// begin ComEnterUnit ( j , selected ) ;
38586: LD_VAR 0 3
38590: PPUSH
38591: LD_VAR 0 7
38595: PPUSH
38596: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
38600: LD_VAR 0 3
38604: PPUSH
38605: LD_INT 15
38607: PPUSH
38608: CALL_OW 183
// end ;
38612: GO 38559
38614: POP
38615: POP
// end ; end ; end ; end ; end ;
38616: GO 38009
38618: POP
38619: POP
// end ;
38620: LD_VAR 0 1
38624: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
38625: LD_INT 0
38627: PPUSH
38628: PPUSH
38629: PPUSH
38630: PPUSH
// if not mc_bases then
38631: LD_EXP 50
38635: NOT
38636: IFFALSE 38640
// exit ;
38638: GO 38818
// for i = 1 to mc_bases do
38640: LD_ADDR_VAR 0 2
38644: PUSH
38645: DOUBLE
38646: LD_INT 1
38648: DEC
38649: ST_TO_ADDR
38650: LD_EXP 50
38654: PUSH
38655: FOR_TO
38656: IFFALSE 38816
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
38658: LD_ADDR_VAR 0 4
38662: PUSH
38663: LD_EXP 50
38667: PUSH
38668: LD_VAR 0 2
38672: ARRAY
38673: PPUSH
38674: LD_INT 25
38676: PUSH
38677: LD_INT 9
38679: PUSH
38680: EMPTY
38681: LIST
38682: LIST
38683: PPUSH
38684: CALL_OW 72
38688: ST_TO_ADDR
// if not tmp then
38689: LD_VAR 0 4
38693: NOT
38694: IFFALSE 38698
// continue ;
38696: GO 38655
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
38698: LD_EXP 76
38702: PUSH
38703: LD_VAR 0 2
38707: ARRAY
38708: PPUSH
38709: LD_INT 29
38711: PPUSH
38712: CALL_OW 325
38716: NOT
38717: PUSH
38718: LD_EXP 76
38722: PUSH
38723: LD_VAR 0 2
38727: ARRAY
38728: PPUSH
38729: LD_INT 28
38731: PPUSH
38732: CALL_OW 325
38736: NOT
38737: AND
38738: IFFALSE 38742
// continue ;
38740: GO 38655
// for j in tmp do
38742: LD_ADDR_VAR 0 3
38746: PUSH
38747: LD_VAR 0 4
38751: PUSH
38752: FOR_IN
38753: IFFALSE 38812
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
38755: LD_VAR 0 3
38759: PUSH
38760: LD_EXP 53
38764: PUSH
38765: LD_VAR 0 2
38769: ARRAY
38770: PUSH
38771: LD_INT 1
38773: ARRAY
38774: IN
38775: NOT
38776: PUSH
38777: LD_VAR 0 3
38781: PUSH
38782: LD_EXP 53
38786: PUSH
38787: LD_VAR 0 2
38791: ARRAY
38792: PUSH
38793: LD_INT 2
38795: ARRAY
38796: IN
38797: NOT
38798: AND
38799: IFFALSE 38810
// ComSpaceTimeShoot ( j ) ;
38801: LD_VAR 0 3
38805: PPUSH
38806: CALL 50019 0 1
38810: GO 38752
38812: POP
38813: POP
// end ;
38814: GO 38655
38816: POP
38817: POP
// end ;
38818: LD_VAR 0 1
38822: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
38823: LD_INT 0
38825: PPUSH
38826: PPUSH
38827: PPUSH
38828: PPUSH
38829: PPUSH
38830: PPUSH
38831: PPUSH
38832: PPUSH
38833: PPUSH
// if not mc_bases then
38834: LD_EXP 50
38838: NOT
38839: IFFALSE 38843
// exit ;
38841: GO 39465
// for i = 1 to mc_bases do
38843: LD_ADDR_VAR 0 2
38847: PUSH
38848: DOUBLE
38849: LD_INT 1
38851: DEC
38852: ST_TO_ADDR
38853: LD_EXP 50
38857: PUSH
38858: FOR_TO
38859: IFFALSE 39463
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
38861: LD_EXP 85
38865: PUSH
38866: LD_VAR 0 2
38870: ARRAY
38871: NOT
38872: PUSH
38873: LD_INT 38
38875: PPUSH
38876: LD_EXP 76
38880: PUSH
38881: LD_VAR 0 2
38885: ARRAY
38886: PPUSH
38887: CALL_OW 321
38891: PUSH
38892: LD_INT 2
38894: NONEQUAL
38895: OR
38896: IFFALSE 38900
// continue ;
38898: GO 38858
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
38900: LD_ADDR_VAR 0 8
38904: PUSH
38905: LD_EXP 50
38909: PUSH
38910: LD_VAR 0 2
38914: ARRAY
38915: PPUSH
38916: LD_INT 30
38918: PUSH
38919: LD_INT 34
38921: PUSH
38922: EMPTY
38923: LIST
38924: LIST
38925: PPUSH
38926: CALL_OW 72
38930: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
38931: LD_ADDR_VAR 0 9
38935: PUSH
38936: LD_EXP 50
38940: PUSH
38941: LD_VAR 0 2
38945: ARRAY
38946: PPUSH
38947: LD_INT 25
38949: PUSH
38950: LD_INT 4
38952: PUSH
38953: EMPTY
38954: LIST
38955: LIST
38956: PPUSH
38957: CALL_OW 72
38961: PPUSH
38962: LD_INT 0
38964: PPUSH
38965: CALL 83946 0 2
38969: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
38970: LD_VAR 0 9
38974: NOT
38975: PUSH
38976: LD_VAR 0 8
38980: NOT
38981: OR
38982: PUSH
38983: LD_EXP 50
38987: PUSH
38988: LD_VAR 0 2
38992: ARRAY
38993: PPUSH
38994: LD_INT 124
38996: PPUSH
38997: CALL 83946 0 2
39001: OR
39002: IFFALSE 39006
// continue ;
39004: GO 38858
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
39006: LD_EXP 86
39010: PUSH
39011: LD_VAR 0 2
39015: ARRAY
39016: PUSH
39017: LD_EXP 85
39021: PUSH
39022: LD_VAR 0 2
39026: ARRAY
39027: LESS
39028: PUSH
39029: LD_EXP 86
39033: PUSH
39034: LD_VAR 0 2
39038: ARRAY
39039: PUSH
39040: LD_VAR 0 8
39044: LESS
39045: AND
39046: IFFALSE 39461
// begin tmp := sci [ 1 ] ;
39048: LD_ADDR_VAR 0 7
39052: PUSH
39053: LD_VAR 0 9
39057: PUSH
39058: LD_INT 1
39060: ARRAY
39061: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
39062: LD_VAR 0 7
39066: PPUSH
39067: LD_INT 124
39069: PPUSH
39070: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
39074: LD_ADDR_VAR 0 3
39078: PUSH
39079: DOUBLE
39080: LD_EXP 85
39084: PUSH
39085: LD_VAR 0 2
39089: ARRAY
39090: INC
39091: ST_TO_ADDR
39092: LD_EXP 85
39096: PUSH
39097: LD_VAR 0 2
39101: ARRAY
39102: PUSH
39103: FOR_DOWNTO
39104: IFFALSE 39447
// begin if IsInUnit ( tmp ) then
39106: LD_VAR 0 7
39110: PPUSH
39111: CALL_OW 310
39115: IFFALSE 39126
// ComExitBuilding ( tmp ) ;
39117: LD_VAR 0 7
39121: PPUSH
39122: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
39126: LD_INT 35
39128: PPUSH
39129: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
39133: LD_VAR 0 7
39137: PPUSH
39138: CALL_OW 310
39142: NOT
39143: PUSH
39144: LD_VAR 0 7
39148: PPUSH
39149: CALL_OW 314
39153: NOT
39154: AND
39155: IFFALSE 39126
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
39157: LD_ADDR_VAR 0 6
39161: PUSH
39162: LD_VAR 0 7
39166: PPUSH
39167: CALL_OW 250
39171: PUSH
39172: LD_VAR 0 7
39176: PPUSH
39177: CALL_OW 251
39181: PUSH
39182: EMPTY
39183: LIST
39184: LIST
39185: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
39186: LD_INT 35
39188: PPUSH
39189: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
39193: LD_ADDR_VAR 0 4
39197: PUSH
39198: LD_EXP 85
39202: PUSH
39203: LD_VAR 0 2
39207: ARRAY
39208: PUSH
39209: LD_VAR 0 3
39213: ARRAY
39214: PUSH
39215: LD_INT 1
39217: ARRAY
39218: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
39219: LD_ADDR_VAR 0 5
39223: PUSH
39224: LD_EXP 85
39228: PUSH
39229: LD_VAR 0 2
39233: ARRAY
39234: PUSH
39235: LD_VAR 0 3
39239: ARRAY
39240: PUSH
39241: LD_INT 2
39243: ARRAY
39244: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
39245: LD_VAR 0 7
39249: PPUSH
39250: LD_INT 10
39252: PPUSH
39253: CALL 56631 0 2
39257: PUSH
39258: LD_INT 4
39260: ARRAY
39261: IFFALSE 39299
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
39263: LD_VAR 0 7
39267: PPUSH
39268: LD_VAR 0 6
39272: PUSH
39273: LD_INT 1
39275: ARRAY
39276: PPUSH
39277: LD_VAR 0 6
39281: PUSH
39282: LD_INT 2
39284: ARRAY
39285: PPUSH
39286: CALL_OW 111
// wait ( 0 0$10 ) ;
39290: LD_INT 350
39292: PPUSH
39293: CALL_OW 67
// end else
39297: GO 39325
// begin ComMoveXY ( tmp , x , y ) ;
39299: LD_VAR 0 7
39303: PPUSH
39304: LD_VAR 0 4
39308: PPUSH
39309: LD_VAR 0 5
39313: PPUSH
39314: CALL_OW 111
// wait ( 0 0$3 ) ;
39318: LD_INT 105
39320: PPUSH
39321: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
39325: LD_VAR 0 7
39329: PPUSH
39330: LD_VAR 0 4
39334: PPUSH
39335: LD_VAR 0 5
39339: PPUSH
39340: CALL_OW 307
39344: IFFALSE 39186
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
39346: LD_VAR 0 7
39350: PPUSH
39351: LD_VAR 0 4
39355: PPUSH
39356: LD_VAR 0 5
39360: PPUSH
39361: LD_VAR 0 8
39365: PUSH
39366: LD_VAR 0 3
39370: ARRAY
39371: PPUSH
39372: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
39376: LD_INT 35
39378: PPUSH
39379: CALL_OW 67
// until not HasTask ( tmp ) ;
39383: LD_VAR 0 7
39387: PPUSH
39388: CALL_OW 314
39392: NOT
39393: IFFALSE 39376
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
39395: LD_ADDR_EXP 86
39399: PUSH
39400: LD_EXP 86
39404: PPUSH
39405: LD_VAR 0 2
39409: PUSH
39410: LD_EXP 86
39414: PUSH
39415: LD_VAR 0 2
39419: ARRAY
39420: PUSH
39421: LD_INT 1
39423: PLUS
39424: PUSH
39425: EMPTY
39426: LIST
39427: LIST
39428: PPUSH
39429: LD_VAR 0 8
39433: PUSH
39434: LD_VAR 0 3
39438: ARRAY
39439: PPUSH
39440: CALL 54034 0 3
39444: ST_TO_ADDR
// end ;
39445: GO 39103
39447: POP
39448: POP
// MC_Reset ( i , 124 ) ;
39449: LD_VAR 0 2
39453: PPUSH
39454: LD_INT 124
39456: PPUSH
39457: CALL 22547 0 2
// end ; end ;
39461: GO 38858
39463: POP
39464: POP
// end ;
39465: LD_VAR 0 1
39469: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
39470: LD_INT 0
39472: PPUSH
39473: PPUSH
39474: PPUSH
// if not mc_bases then
39475: LD_EXP 50
39479: NOT
39480: IFFALSE 39484
// exit ;
39482: GO 40090
// for i = 1 to mc_bases do
39484: LD_ADDR_VAR 0 2
39488: PUSH
39489: DOUBLE
39490: LD_INT 1
39492: DEC
39493: ST_TO_ADDR
39494: LD_EXP 50
39498: PUSH
39499: FOR_TO
39500: IFFALSE 40088
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
39502: LD_ADDR_VAR 0 3
39506: PUSH
39507: LD_EXP 50
39511: PUSH
39512: LD_VAR 0 2
39516: ARRAY
39517: PPUSH
39518: LD_INT 25
39520: PUSH
39521: LD_INT 4
39523: PUSH
39524: EMPTY
39525: LIST
39526: LIST
39527: PPUSH
39528: CALL_OW 72
39532: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
39533: LD_VAR 0 3
39537: NOT
39538: PUSH
39539: LD_EXP 87
39543: PUSH
39544: LD_VAR 0 2
39548: ARRAY
39549: NOT
39550: OR
39551: PUSH
39552: LD_EXP 50
39556: PUSH
39557: LD_VAR 0 2
39561: ARRAY
39562: PPUSH
39563: LD_INT 2
39565: PUSH
39566: LD_INT 30
39568: PUSH
39569: LD_INT 0
39571: PUSH
39572: EMPTY
39573: LIST
39574: LIST
39575: PUSH
39576: LD_INT 30
39578: PUSH
39579: LD_INT 1
39581: PUSH
39582: EMPTY
39583: LIST
39584: LIST
39585: PUSH
39586: EMPTY
39587: LIST
39588: LIST
39589: LIST
39590: PPUSH
39591: CALL_OW 72
39595: NOT
39596: OR
39597: IFFALSE 39647
// begin if mc_deposits_finder [ i ] then
39599: LD_EXP 88
39603: PUSH
39604: LD_VAR 0 2
39608: ARRAY
39609: IFFALSE 39645
// begin MC_Reset ( i , 125 ) ;
39611: LD_VAR 0 2
39615: PPUSH
39616: LD_INT 125
39618: PPUSH
39619: CALL 22547 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
39623: LD_ADDR_EXP 88
39627: PUSH
39628: LD_EXP 88
39632: PPUSH
39633: LD_VAR 0 2
39637: PPUSH
39638: EMPTY
39639: PPUSH
39640: CALL_OW 1
39644: ST_TO_ADDR
// end ; continue ;
39645: GO 39499
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
39647: LD_EXP 87
39651: PUSH
39652: LD_VAR 0 2
39656: ARRAY
39657: PUSH
39658: LD_INT 1
39660: ARRAY
39661: PUSH
39662: LD_INT 3
39664: ARRAY
39665: PUSH
39666: LD_INT 1
39668: EQUAL
39669: PUSH
39670: LD_INT 20
39672: PPUSH
39673: LD_EXP 76
39677: PUSH
39678: LD_VAR 0 2
39682: ARRAY
39683: PPUSH
39684: CALL_OW 321
39688: PUSH
39689: LD_INT 2
39691: NONEQUAL
39692: AND
39693: IFFALSE 39743
// begin if mc_deposits_finder [ i ] then
39695: LD_EXP 88
39699: PUSH
39700: LD_VAR 0 2
39704: ARRAY
39705: IFFALSE 39741
// begin MC_Reset ( i , 125 ) ;
39707: LD_VAR 0 2
39711: PPUSH
39712: LD_INT 125
39714: PPUSH
39715: CALL 22547 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
39719: LD_ADDR_EXP 88
39723: PUSH
39724: LD_EXP 88
39728: PPUSH
39729: LD_VAR 0 2
39733: PPUSH
39734: EMPTY
39735: PPUSH
39736: CALL_OW 1
39740: ST_TO_ADDR
// end ; continue ;
39741: GO 39499
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
39743: LD_EXP 87
39747: PUSH
39748: LD_VAR 0 2
39752: ARRAY
39753: PUSH
39754: LD_INT 1
39756: ARRAY
39757: PUSH
39758: LD_INT 1
39760: ARRAY
39761: PPUSH
39762: LD_EXP 87
39766: PUSH
39767: LD_VAR 0 2
39771: ARRAY
39772: PUSH
39773: LD_INT 1
39775: ARRAY
39776: PUSH
39777: LD_INT 2
39779: ARRAY
39780: PPUSH
39781: LD_EXP 76
39785: PUSH
39786: LD_VAR 0 2
39790: ARRAY
39791: PPUSH
39792: CALL_OW 440
39796: IFFALSE 39839
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
39798: LD_ADDR_EXP 87
39802: PUSH
39803: LD_EXP 87
39807: PPUSH
39808: LD_VAR 0 2
39812: PPUSH
39813: LD_EXP 87
39817: PUSH
39818: LD_VAR 0 2
39822: ARRAY
39823: PPUSH
39824: LD_INT 1
39826: PPUSH
39827: CALL_OW 3
39831: PPUSH
39832: CALL_OW 1
39836: ST_TO_ADDR
39837: GO 40086
// begin if not mc_deposits_finder [ i ] then
39839: LD_EXP 88
39843: PUSH
39844: LD_VAR 0 2
39848: ARRAY
39849: NOT
39850: IFFALSE 39902
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
39852: LD_ADDR_EXP 88
39856: PUSH
39857: LD_EXP 88
39861: PPUSH
39862: LD_VAR 0 2
39866: PPUSH
39867: LD_VAR 0 3
39871: PUSH
39872: LD_INT 1
39874: ARRAY
39875: PUSH
39876: EMPTY
39877: LIST
39878: PPUSH
39879: CALL_OW 1
39883: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
39884: LD_VAR 0 3
39888: PUSH
39889: LD_INT 1
39891: ARRAY
39892: PPUSH
39893: LD_INT 125
39895: PPUSH
39896: CALL_OW 109
// end else
39900: GO 40086
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
39902: LD_EXP 88
39906: PUSH
39907: LD_VAR 0 2
39911: ARRAY
39912: PUSH
39913: LD_INT 1
39915: ARRAY
39916: PPUSH
39917: CALL_OW 310
39921: IFFALSE 39944
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
39923: LD_EXP 88
39927: PUSH
39928: LD_VAR 0 2
39932: ARRAY
39933: PUSH
39934: LD_INT 1
39936: ARRAY
39937: PPUSH
39938: CALL_OW 122
39942: GO 40086
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
39944: LD_EXP 88
39948: PUSH
39949: LD_VAR 0 2
39953: ARRAY
39954: PUSH
39955: LD_INT 1
39957: ARRAY
39958: PPUSH
39959: CALL_OW 314
39963: NOT
39964: PUSH
39965: LD_EXP 88
39969: PUSH
39970: LD_VAR 0 2
39974: ARRAY
39975: PUSH
39976: LD_INT 1
39978: ARRAY
39979: PPUSH
39980: LD_EXP 87
39984: PUSH
39985: LD_VAR 0 2
39989: ARRAY
39990: PUSH
39991: LD_INT 1
39993: ARRAY
39994: PUSH
39995: LD_INT 1
39997: ARRAY
39998: PPUSH
39999: LD_EXP 87
40003: PUSH
40004: LD_VAR 0 2
40008: ARRAY
40009: PUSH
40010: LD_INT 1
40012: ARRAY
40013: PUSH
40014: LD_INT 2
40016: ARRAY
40017: PPUSH
40018: CALL_OW 297
40022: PUSH
40023: LD_INT 6
40025: GREATER
40026: AND
40027: IFFALSE 40086
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
40029: LD_EXP 88
40033: PUSH
40034: LD_VAR 0 2
40038: ARRAY
40039: PUSH
40040: LD_INT 1
40042: ARRAY
40043: PPUSH
40044: LD_EXP 87
40048: PUSH
40049: LD_VAR 0 2
40053: ARRAY
40054: PUSH
40055: LD_INT 1
40057: ARRAY
40058: PUSH
40059: LD_INT 1
40061: ARRAY
40062: PPUSH
40063: LD_EXP 87
40067: PUSH
40068: LD_VAR 0 2
40072: ARRAY
40073: PUSH
40074: LD_INT 1
40076: ARRAY
40077: PUSH
40078: LD_INT 2
40080: ARRAY
40081: PPUSH
40082: CALL_OW 111
// end ; end ; end ;
40086: GO 39499
40088: POP
40089: POP
// end ;
40090: LD_VAR 0 1
40094: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
40095: LD_INT 0
40097: PPUSH
40098: PPUSH
40099: PPUSH
40100: PPUSH
40101: PPUSH
40102: PPUSH
40103: PPUSH
40104: PPUSH
40105: PPUSH
40106: PPUSH
40107: PPUSH
// if not mc_bases then
40108: LD_EXP 50
40112: NOT
40113: IFFALSE 40117
// exit ;
40115: GO 41057
// for i = 1 to mc_bases do
40117: LD_ADDR_VAR 0 2
40121: PUSH
40122: DOUBLE
40123: LD_INT 1
40125: DEC
40126: ST_TO_ADDR
40127: LD_EXP 50
40131: PUSH
40132: FOR_TO
40133: IFFALSE 41055
// begin if not mc_bases [ i ] or mc_scan [ i ] then
40135: LD_EXP 50
40139: PUSH
40140: LD_VAR 0 2
40144: ARRAY
40145: NOT
40146: PUSH
40147: LD_EXP 73
40151: PUSH
40152: LD_VAR 0 2
40156: ARRAY
40157: OR
40158: IFFALSE 40162
// continue ;
40160: GO 40132
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
40162: LD_ADDR_VAR 0 7
40166: PUSH
40167: LD_EXP 50
40171: PUSH
40172: LD_VAR 0 2
40176: ARRAY
40177: PUSH
40178: LD_INT 1
40180: ARRAY
40181: PPUSH
40182: CALL_OW 248
40186: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
40187: LD_VAR 0 7
40191: PUSH
40192: LD_INT 3
40194: EQUAL
40195: PUSH
40196: LD_EXP 69
40200: PUSH
40201: LD_VAR 0 2
40205: ARRAY
40206: PUSH
40207: LD_EXP 72
40211: PUSH
40212: LD_VAR 0 2
40216: ARRAY
40217: UNION
40218: PPUSH
40219: LD_INT 33
40221: PUSH
40222: LD_INT 2
40224: PUSH
40225: EMPTY
40226: LIST
40227: LIST
40228: PPUSH
40229: CALL_OW 72
40233: NOT
40234: OR
40235: IFFALSE 40239
// continue ;
40237: GO 40132
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
40239: LD_ADDR_VAR 0 9
40243: PUSH
40244: LD_EXP 50
40248: PUSH
40249: LD_VAR 0 2
40253: ARRAY
40254: PPUSH
40255: LD_INT 30
40257: PUSH
40258: LD_INT 36
40260: PUSH
40261: EMPTY
40262: LIST
40263: LIST
40264: PPUSH
40265: CALL_OW 72
40269: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
40270: LD_ADDR_VAR 0 10
40274: PUSH
40275: LD_EXP 69
40279: PUSH
40280: LD_VAR 0 2
40284: ARRAY
40285: PPUSH
40286: LD_INT 34
40288: PUSH
40289: LD_INT 31
40291: PUSH
40292: EMPTY
40293: LIST
40294: LIST
40295: PPUSH
40296: CALL_OW 72
40300: ST_TO_ADDR
// if not cts and not mcts then
40301: LD_VAR 0 9
40305: NOT
40306: PUSH
40307: LD_VAR 0 10
40311: NOT
40312: AND
40313: IFFALSE 40317
// continue ;
40315: GO 40132
// x := cts ;
40317: LD_ADDR_VAR 0 11
40321: PUSH
40322: LD_VAR 0 9
40326: ST_TO_ADDR
// if not x then
40327: LD_VAR 0 11
40331: NOT
40332: IFFALSE 40344
// x := mcts ;
40334: LD_ADDR_VAR 0 11
40338: PUSH
40339: LD_VAR 0 10
40343: ST_TO_ADDR
// if not x then
40344: LD_VAR 0 11
40348: NOT
40349: IFFALSE 40353
// continue ;
40351: GO 40132
// if mc_remote_driver [ i ] then
40353: LD_EXP 90
40357: PUSH
40358: LD_VAR 0 2
40362: ARRAY
40363: IFFALSE 40750
// for j in mc_remote_driver [ i ] do
40365: LD_ADDR_VAR 0 3
40369: PUSH
40370: LD_EXP 90
40374: PUSH
40375: LD_VAR 0 2
40379: ARRAY
40380: PUSH
40381: FOR_IN
40382: IFFALSE 40748
// begin if GetClass ( j ) <> 3 then
40384: LD_VAR 0 3
40388: PPUSH
40389: CALL_OW 257
40393: PUSH
40394: LD_INT 3
40396: NONEQUAL
40397: IFFALSE 40450
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
40399: LD_ADDR_EXP 90
40403: PUSH
40404: LD_EXP 90
40408: PPUSH
40409: LD_VAR 0 2
40413: PPUSH
40414: LD_EXP 90
40418: PUSH
40419: LD_VAR 0 2
40423: ARRAY
40424: PUSH
40425: LD_VAR 0 3
40429: DIFF
40430: PPUSH
40431: CALL_OW 1
40435: ST_TO_ADDR
// SetTag ( j , 0 ) ;
40436: LD_VAR 0 3
40440: PPUSH
40441: LD_INT 0
40443: PPUSH
40444: CALL_OW 109
// continue ;
40448: GO 40381
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
40450: LD_EXP 69
40454: PUSH
40455: LD_VAR 0 2
40459: ARRAY
40460: PPUSH
40461: LD_INT 34
40463: PUSH
40464: LD_INT 31
40466: PUSH
40467: EMPTY
40468: LIST
40469: LIST
40470: PUSH
40471: LD_INT 58
40473: PUSH
40474: EMPTY
40475: LIST
40476: PUSH
40477: EMPTY
40478: LIST
40479: LIST
40480: PPUSH
40481: CALL_OW 72
40485: PUSH
40486: LD_VAR 0 3
40490: PPUSH
40491: CALL 83981 0 1
40495: NOT
40496: AND
40497: IFFALSE 40568
// begin if IsInUnit ( j ) then
40499: LD_VAR 0 3
40503: PPUSH
40504: CALL_OW 310
40508: IFFALSE 40519
// ComExitBuilding ( j ) ;
40510: LD_VAR 0 3
40514: PPUSH
40515: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
40519: LD_VAR 0 3
40523: PPUSH
40524: LD_EXP 69
40528: PUSH
40529: LD_VAR 0 2
40533: ARRAY
40534: PPUSH
40535: LD_INT 34
40537: PUSH
40538: LD_INT 31
40540: PUSH
40541: EMPTY
40542: LIST
40543: LIST
40544: PUSH
40545: LD_INT 58
40547: PUSH
40548: EMPTY
40549: LIST
40550: PUSH
40551: EMPTY
40552: LIST
40553: LIST
40554: PPUSH
40555: CALL_OW 72
40559: PUSH
40560: LD_INT 1
40562: ARRAY
40563: PPUSH
40564: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
40568: LD_VAR 0 3
40572: PPUSH
40573: CALL_OW 310
40577: NOT
40578: PUSH
40579: LD_VAR 0 3
40583: PPUSH
40584: CALL_OW 310
40588: PPUSH
40589: CALL_OW 266
40593: PUSH
40594: LD_INT 36
40596: NONEQUAL
40597: PUSH
40598: LD_VAR 0 3
40602: PPUSH
40603: CALL 83981 0 1
40607: NOT
40608: AND
40609: OR
40610: IFFALSE 40746
// begin if IsInUnit ( j ) then
40612: LD_VAR 0 3
40616: PPUSH
40617: CALL_OW 310
40621: IFFALSE 40632
// ComExitBuilding ( j ) ;
40623: LD_VAR 0 3
40627: PPUSH
40628: CALL_OW 122
// ct := 0 ;
40632: LD_ADDR_VAR 0 8
40636: PUSH
40637: LD_INT 0
40639: ST_TO_ADDR
// for k in x do
40640: LD_ADDR_VAR 0 4
40644: PUSH
40645: LD_VAR 0 11
40649: PUSH
40650: FOR_IN
40651: IFFALSE 40724
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
40653: LD_VAR 0 4
40657: PPUSH
40658: CALL_OW 264
40662: PUSH
40663: LD_INT 31
40665: EQUAL
40666: PUSH
40667: LD_VAR 0 4
40671: PPUSH
40672: CALL_OW 311
40676: NOT
40677: AND
40678: PUSH
40679: LD_VAR 0 4
40683: PPUSH
40684: CALL_OW 266
40688: PUSH
40689: LD_INT 36
40691: EQUAL
40692: PUSH
40693: LD_VAR 0 4
40697: PPUSH
40698: CALL_OW 313
40702: PUSH
40703: LD_INT 3
40705: LESS
40706: AND
40707: OR
40708: IFFALSE 40722
// begin ct := k ;
40710: LD_ADDR_VAR 0 8
40714: PUSH
40715: LD_VAR 0 4
40719: ST_TO_ADDR
// break ;
40720: GO 40724
// end ;
40722: GO 40650
40724: POP
40725: POP
// if ct then
40726: LD_VAR 0 8
40730: IFFALSE 40746
// ComEnterUnit ( j , ct ) ;
40732: LD_VAR 0 3
40736: PPUSH
40737: LD_VAR 0 8
40741: PPUSH
40742: CALL_OW 120
// end ; end ;
40746: GO 40381
40748: POP
40749: POP
// places := 0 ;
40750: LD_ADDR_VAR 0 5
40754: PUSH
40755: LD_INT 0
40757: ST_TO_ADDR
// for j = 1 to x do
40758: LD_ADDR_VAR 0 3
40762: PUSH
40763: DOUBLE
40764: LD_INT 1
40766: DEC
40767: ST_TO_ADDR
40768: LD_VAR 0 11
40772: PUSH
40773: FOR_TO
40774: IFFALSE 40850
// if GetWeapon ( x [ j ] ) = ar_control_tower then
40776: LD_VAR 0 11
40780: PUSH
40781: LD_VAR 0 3
40785: ARRAY
40786: PPUSH
40787: CALL_OW 264
40791: PUSH
40792: LD_INT 31
40794: EQUAL
40795: IFFALSE 40813
// places := places + 1 else
40797: LD_ADDR_VAR 0 5
40801: PUSH
40802: LD_VAR 0 5
40806: PUSH
40807: LD_INT 1
40809: PLUS
40810: ST_TO_ADDR
40811: GO 40848
// if GetBType ( x [ j ] ) = b_control_tower then
40813: LD_VAR 0 11
40817: PUSH
40818: LD_VAR 0 3
40822: ARRAY
40823: PPUSH
40824: CALL_OW 266
40828: PUSH
40829: LD_INT 36
40831: EQUAL
40832: IFFALSE 40848
// places := places + 3 ;
40834: LD_ADDR_VAR 0 5
40838: PUSH
40839: LD_VAR 0 5
40843: PUSH
40844: LD_INT 3
40846: PLUS
40847: ST_TO_ADDR
40848: GO 40773
40850: POP
40851: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
40852: LD_VAR 0 5
40856: PUSH
40857: LD_INT 0
40859: EQUAL
40860: PUSH
40861: LD_VAR 0 5
40865: PUSH
40866: LD_EXP 90
40870: PUSH
40871: LD_VAR 0 2
40875: ARRAY
40876: LESSEQUAL
40877: OR
40878: IFFALSE 40882
// continue ;
40880: GO 40132
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
40882: LD_ADDR_VAR 0 6
40886: PUSH
40887: LD_EXP 50
40891: PUSH
40892: LD_VAR 0 2
40896: ARRAY
40897: PPUSH
40898: LD_INT 25
40900: PUSH
40901: LD_INT 3
40903: PUSH
40904: EMPTY
40905: LIST
40906: LIST
40907: PPUSH
40908: CALL_OW 72
40912: PUSH
40913: LD_EXP 90
40917: PUSH
40918: LD_VAR 0 2
40922: ARRAY
40923: DIFF
40924: PPUSH
40925: LD_INT 3
40927: PPUSH
40928: CALL 84881 0 2
40932: ST_TO_ADDR
// for j in tmp do
40933: LD_ADDR_VAR 0 3
40937: PUSH
40938: LD_VAR 0 6
40942: PUSH
40943: FOR_IN
40944: IFFALSE 40979
// if GetTag ( j ) > 0 then
40946: LD_VAR 0 3
40950: PPUSH
40951: CALL_OW 110
40955: PUSH
40956: LD_INT 0
40958: GREATER
40959: IFFALSE 40977
// tmp := tmp diff j ;
40961: LD_ADDR_VAR 0 6
40965: PUSH
40966: LD_VAR 0 6
40970: PUSH
40971: LD_VAR 0 3
40975: DIFF
40976: ST_TO_ADDR
40977: GO 40943
40979: POP
40980: POP
// if not tmp then
40981: LD_VAR 0 6
40985: NOT
40986: IFFALSE 40990
// continue ;
40988: GO 40132
// if places then
40990: LD_VAR 0 5
40994: IFFALSE 41053
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
40996: LD_ADDR_EXP 90
41000: PUSH
41001: LD_EXP 90
41005: PPUSH
41006: LD_VAR 0 2
41010: PPUSH
41011: LD_EXP 90
41015: PUSH
41016: LD_VAR 0 2
41020: ARRAY
41021: PUSH
41022: LD_VAR 0 6
41026: PUSH
41027: LD_INT 1
41029: ARRAY
41030: UNION
41031: PPUSH
41032: CALL_OW 1
41036: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
41037: LD_VAR 0 6
41041: PUSH
41042: LD_INT 1
41044: ARRAY
41045: PPUSH
41046: LD_INT 126
41048: PPUSH
41049: CALL_OW 109
// end ; end ;
41053: GO 40132
41055: POP
41056: POP
// end ;
41057: LD_VAR 0 1
41061: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
41062: LD_INT 0
41064: PPUSH
41065: PPUSH
41066: PPUSH
41067: PPUSH
41068: PPUSH
41069: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
41070: LD_VAR 0 1
41074: NOT
41075: PUSH
41076: LD_VAR 0 2
41080: NOT
41081: OR
41082: PUSH
41083: LD_VAR 0 3
41087: NOT
41088: OR
41089: PUSH
41090: LD_VAR 0 4
41094: PUSH
41095: LD_INT 1
41097: PUSH
41098: LD_INT 2
41100: PUSH
41101: LD_INT 3
41103: PUSH
41104: LD_INT 4
41106: PUSH
41107: LD_INT 5
41109: PUSH
41110: LD_INT 8
41112: PUSH
41113: LD_INT 9
41115: PUSH
41116: LD_INT 15
41118: PUSH
41119: LD_INT 16
41121: PUSH
41122: EMPTY
41123: LIST
41124: LIST
41125: LIST
41126: LIST
41127: LIST
41128: LIST
41129: LIST
41130: LIST
41131: LIST
41132: IN
41133: NOT
41134: OR
41135: IFFALSE 41139
// exit ;
41137: GO 41997
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
41139: LD_ADDR_VAR 0 2
41143: PUSH
41144: LD_VAR 0 2
41148: PPUSH
41149: LD_INT 21
41151: PUSH
41152: LD_INT 3
41154: PUSH
41155: EMPTY
41156: LIST
41157: LIST
41158: PUSH
41159: LD_INT 24
41161: PUSH
41162: LD_INT 250
41164: PUSH
41165: EMPTY
41166: LIST
41167: LIST
41168: PUSH
41169: EMPTY
41170: LIST
41171: LIST
41172: PPUSH
41173: CALL_OW 72
41177: ST_TO_ADDR
// case class of 1 , 15 :
41178: LD_VAR 0 4
41182: PUSH
41183: LD_INT 1
41185: DOUBLE
41186: EQUAL
41187: IFTRUE 41197
41189: LD_INT 15
41191: DOUBLE
41192: EQUAL
41193: IFTRUE 41197
41195: GO 41282
41197: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
41198: LD_ADDR_VAR 0 8
41202: PUSH
41203: LD_VAR 0 2
41207: PPUSH
41208: LD_INT 2
41210: PUSH
41211: LD_INT 30
41213: PUSH
41214: LD_INT 32
41216: PUSH
41217: EMPTY
41218: LIST
41219: LIST
41220: PUSH
41221: LD_INT 30
41223: PUSH
41224: LD_INT 31
41226: PUSH
41227: EMPTY
41228: LIST
41229: LIST
41230: PUSH
41231: EMPTY
41232: LIST
41233: LIST
41234: LIST
41235: PPUSH
41236: CALL_OW 72
41240: PUSH
41241: LD_VAR 0 2
41245: PPUSH
41246: LD_INT 2
41248: PUSH
41249: LD_INT 30
41251: PUSH
41252: LD_INT 4
41254: PUSH
41255: EMPTY
41256: LIST
41257: LIST
41258: PUSH
41259: LD_INT 30
41261: PUSH
41262: LD_INT 5
41264: PUSH
41265: EMPTY
41266: LIST
41267: LIST
41268: PUSH
41269: EMPTY
41270: LIST
41271: LIST
41272: LIST
41273: PPUSH
41274: CALL_OW 72
41278: ADD
41279: ST_TO_ADDR
41280: GO 41528
41282: LD_INT 2
41284: DOUBLE
41285: EQUAL
41286: IFTRUE 41296
41288: LD_INT 16
41290: DOUBLE
41291: EQUAL
41292: IFTRUE 41296
41294: GO 41342
41296: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
41297: LD_ADDR_VAR 0 8
41301: PUSH
41302: LD_VAR 0 2
41306: PPUSH
41307: LD_INT 2
41309: PUSH
41310: LD_INT 30
41312: PUSH
41313: LD_INT 0
41315: PUSH
41316: EMPTY
41317: LIST
41318: LIST
41319: PUSH
41320: LD_INT 30
41322: PUSH
41323: LD_INT 1
41325: PUSH
41326: EMPTY
41327: LIST
41328: LIST
41329: PUSH
41330: EMPTY
41331: LIST
41332: LIST
41333: LIST
41334: PPUSH
41335: CALL_OW 72
41339: ST_TO_ADDR
41340: GO 41528
41342: LD_INT 3
41344: DOUBLE
41345: EQUAL
41346: IFTRUE 41350
41348: GO 41396
41350: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
41351: LD_ADDR_VAR 0 8
41355: PUSH
41356: LD_VAR 0 2
41360: PPUSH
41361: LD_INT 2
41363: PUSH
41364: LD_INT 30
41366: PUSH
41367: LD_INT 2
41369: PUSH
41370: EMPTY
41371: LIST
41372: LIST
41373: PUSH
41374: LD_INT 30
41376: PUSH
41377: LD_INT 3
41379: PUSH
41380: EMPTY
41381: LIST
41382: LIST
41383: PUSH
41384: EMPTY
41385: LIST
41386: LIST
41387: LIST
41388: PPUSH
41389: CALL_OW 72
41393: ST_TO_ADDR
41394: GO 41528
41396: LD_INT 4
41398: DOUBLE
41399: EQUAL
41400: IFTRUE 41404
41402: GO 41461
41404: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
41405: LD_ADDR_VAR 0 8
41409: PUSH
41410: LD_VAR 0 2
41414: PPUSH
41415: LD_INT 2
41417: PUSH
41418: LD_INT 30
41420: PUSH
41421: LD_INT 6
41423: PUSH
41424: EMPTY
41425: LIST
41426: LIST
41427: PUSH
41428: LD_INT 30
41430: PUSH
41431: LD_INT 7
41433: PUSH
41434: EMPTY
41435: LIST
41436: LIST
41437: PUSH
41438: LD_INT 30
41440: PUSH
41441: LD_INT 8
41443: PUSH
41444: EMPTY
41445: LIST
41446: LIST
41447: PUSH
41448: EMPTY
41449: LIST
41450: LIST
41451: LIST
41452: LIST
41453: PPUSH
41454: CALL_OW 72
41458: ST_TO_ADDR
41459: GO 41528
41461: LD_INT 5
41463: DOUBLE
41464: EQUAL
41465: IFTRUE 41481
41467: LD_INT 8
41469: DOUBLE
41470: EQUAL
41471: IFTRUE 41481
41473: LD_INT 9
41475: DOUBLE
41476: EQUAL
41477: IFTRUE 41481
41479: GO 41527
41481: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
41482: LD_ADDR_VAR 0 8
41486: PUSH
41487: LD_VAR 0 2
41491: PPUSH
41492: LD_INT 2
41494: PUSH
41495: LD_INT 30
41497: PUSH
41498: LD_INT 4
41500: PUSH
41501: EMPTY
41502: LIST
41503: LIST
41504: PUSH
41505: LD_INT 30
41507: PUSH
41508: LD_INT 5
41510: PUSH
41511: EMPTY
41512: LIST
41513: LIST
41514: PUSH
41515: EMPTY
41516: LIST
41517: LIST
41518: LIST
41519: PPUSH
41520: CALL_OW 72
41524: ST_TO_ADDR
41525: GO 41528
41527: POP
// if not tmp then
41528: LD_VAR 0 8
41532: NOT
41533: IFFALSE 41537
// exit ;
41535: GO 41997
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
41537: LD_VAR 0 4
41541: PUSH
41542: LD_INT 1
41544: PUSH
41545: LD_INT 15
41547: PUSH
41548: EMPTY
41549: LIST
41550: LIST
41551: IN
41552: PUSH
41553: LD_EXP 59
41557: PUSH
41558: LD_VAR 0 1
41562: ARRAY
41563: AND
41564: IFFALSE 41720
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
41566: LD_ADDR_VAR 0 9
41570: PUSH
41571: LD_EXP 59
41575: PUSH
41576: LD_VAR 0 1
41580: ARRAY
41581: PUSH
41582: LD_INT 1
41584: ARRAY
41585: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
41586: LD_VAR 0 9
41590: PUSH
41591: LD_EXP 60
41595: PUSH
41596: LD_VAR 0 1
41600: ARRAY
41601: IN
41602: NOT
41603: IFFALSE 41718
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
41605: LD_ADDR_EXP 60
41609: PUSH
41610: LD_EXP 60
41614: PPUSH
41615: LD_VAR 0 1
41619: PUSH
41620: LD_EXP 60
41624: PUSH
41625: LD_VAR 0 1
41629: ARRAY
41630: PUSH
41631: LD_INT 1
41633: PLUS
41634: PUSH
41635: EMPTY
41636: LIST
41637: LIST
41638: PPUSH
41639: LD_VAR 0 9
41643: PPUSH
41644: CALL 54034 0 3
41648: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
41649: LD_ADDR_EXP 59
41653: PUSH
41654: LD_EXP 59
41658: PPUSH
41659: LD_VAR 0 1
41663: PPUSH
41664: LD_EXP 59
41668: PUSH
41669: LD_VAR 0 1
41673: ARRAY
41674: PUSH
41675: LD_VAR 0 9
41679: DIFF
41680: PPUSH
41681: CALL_OW 1
41685: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
41686: LD_VAR 0 3
41690: PPUSH
41691: LD_EXP 60
41695: PUSH
41696: LD_VAR 0 1
41700: ARRAY
41701: PUSH
41702: LD_EXP 60
41706: PUSH
41707: LD_VAR 0 1
41711: ARRAY
41712: ARRAY
41713: PPUSH
41714: CALL_OW 120
// end ; exit ;
41718: GO 41997
// end ; if tmp > 1 then
41720: LD_VAR 0 8
41724: PUSH
41725: LD_INT 1
41727: GREATER
41728: IFFALSE 41832
// for i = 2 to tmp do
41730: LD_ADDR_VAR 0 6
41734: PUSH
41735: DOUBLE
41736: LD_INT 2
41738: DEC
41739: ST_TO_ADDR
41740: LD_VAR 0 8
41744: PUSH
41745: FOR_TO
41746: IFFALSE 41830
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
41748: LD_VAR 0 8
41752: PUSH
41753: LD_VAR 0 6
41757: ARRAY
41758: PPUSH
41759: CALL_OW 461
41763: PUSH
41764: LD_INT 6
41766: EQUAL
41767: IFFALSE 41828
// begin x := tmp [ i ] ;
41769: LD_ADDR_VAR 0 9
41773: PUSH
41774: LD_VAR 0 8
41778: PUSH
41779: LD_VAR 0 6
41783: ARRAY
41784: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
41785: LD_ADDR_VAR 0 8
41789: PUSH
41790: LD_VAR 0 8
41794: PPUSH
41795: LD_VAR 0 6
41799: PPUSH
41800: CALL_OW 3
41804: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
41805: LD_ADDR_VAR 0 8
41809: PUSH
41810: LD_VAR 0 8
41814: PPUSH
41815: LD_INT 1
41817: PPUSH
41818: LD_VAR 0 9
41822: PPUSH
41823: CALL_OW 2
41827: ST_TO_ADDR
// end ;
41828: GO 41745
41830: POP
41831: POP
// for i in tmp do
41832: LD_ADDR_VAR 0 6
41836: PUSH
41837: LD_VAR 0 8
41841: PUSH
41842: FOR_IN
41843: IFFALSE 41870
// begin if IsNotFull ( i ) then
41845: LD_VAR 0 6
41849: PPUSH
41850: CALL 51256 0 1
41854: IFFALSE 41868
// begin j := i ;
41856: LD_ADDR_VAR 0 7
41860: PUSH
41861: LD_VAR 0 6
41865: ST_TO_ADDR
// break ;
41866: GO 41870
// end ; end ;
41868: GO 41842
41870: POP
41871: POP
// if j then
41872: LD_VAR 0 7
41876: IFFALSE 41894
// ComEnterUnit ( unit , j ) else
41878: LD_VAR 0 3
41882: PPUSH
41883: LD_VAR 0 7
41887: PPUSH
41888: CALL_OW 120
41892: GO 41997
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
41894: LD_ADDR_VAR 0 10
41898: PUSH
41899: LD_VAR 0 2
41903: PPUSH
41904: LD_INT 2
41906: PUSH
41907: LD_INT 30
41909: PUSH
41910: LD_INT 0
41912: PUSH
41913: EMPTY
41914: LIST
41915: LIST
41916: PUSH
41917: LD_INT 30
41919: PUSH
41920: LD_INT 1
41922: PUSH
41923: EMPTY
41924: LIST
41925: LIST
41926: PUSH
41927: EMPTY
41928: LIST
41929: LIST
41930: LIST
41931: PPUSH
41932: CALL_OW 72
41936: ST_TO_ADDR
// if depot then
41937: LD_VAR 0 10
41941: IFFALSE 41997
// begin depot := NearestUnitToUnit ( depot , unit ) ;
41943: LD_ADDR_VAR 0 10
41947: PUSH
41948: LD_VAR 0 10
41952: PPUSH
41953: LD_VAR 0 3
41957: PPUSH
41958: CALL_OW 74
41962: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
41963: LD_VAR 0 3
41967: PPUSH
41968: LD_VAR 0 10
41972: PPUSH
41973: CALL_OW 296
41977: PUSH
41978: LD_INT 10
41980: GREATER
41981: IFFALSE 41997
// ComStandNearbyBuilding ( unit , depot ) ;
41983: LD_VAR 0 3
41987: PPUSH
41988: LD_VAR 0 10
41992: PPUSH
41993: CALL 50636 0 2
// end ; end ; end ;
41997: LD_VAR 0 5
42001: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
42002: LD_INT 0
42004: PPUSH
42005: PPUSH
42006: PPUSH
42007: PPUSH
// if not mc_bases then
42008: LD_EXP 50
42012: NOT
42013: IFFALSE 42017
// exit ;
42015: GO 42256
// for i = 1 to mc_bases do
42017: LD_ADDR_VAR 0 2
42021: PUSH
42022: DOUBLE
42023: LD_INT 1
42025: DEC
42026: ST_TO_ADDR
42027: LD_EXP 50
42031: PUSH
42032: FOR_TO
42033: IFFALSE 42254
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
42035: LD_ADDR_VAR 0 4
42039: PUSH
42040: LD_EXP 50
42044: PUSH
42045: LD_VAR 0 2
42049: ARRAY
42050: PPUSH
42051: LD_INT 21
42053: PUSH
42054: LD_INT 1
42056: PUSH
42057: EMPTY
42058: LIST
42059: LIST
42060: PPUSH
42061: CALL_OW 72
42065: PUSH
42066: LD_EXP 79
42070: PUSH
42071: LD_VAR 0 2
42075: ARRAY
42076: UNION
42077: ST_TO_ADDR
// if not tmp then
42078: LD_VAR 0 4
42082: NOT
42083: IFFALSE 42087
// continue ;
42085: GO 42032
// for j in tmp do
42087: LD_ADDR_VAR 0 3
42091: PUSH
42092: LD_VAR 0 4
42096: PUSH
42097: FOR_IN
42098: IFFALSE 42250
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
42100: LD_VAR 0 3
42104: PPUSH
42105: CALL_OW 110
42109: NOT
42110: PUSH
42111: LD_VAR 0 3
42115: PPUSH
42116: CALL_OW 314
42120: NOT
42121: AND
42122: PUSH
42123: LD_VAR 0 3
42127: PPUSH
42128: CALL_OW 311
42132: NOT
42133: AND
42134: PUSH
42135: LD_VAR 0 3
42139: PPUSH
42140: CALL_OW 310
42144: NOT
42145: AND
42146: PUSH
42147: LD_VAR 0 3
42151: PUSH
42152: LD_EXP 53
42156: PUSH
42157: LD_VAR 0 2
42161: ARRAY
42162: PUSH
42163: LD_INT 1
42165: ARRAY
42166: IN
42167: NOT
42168: AND
42169: PUSH
42170: LD_VAR 0 3
42174: PUSH
42175: LD_EXP 53
42179: PUSH
42180: LD_VAR 0 2
42184: ARRAY
42185: PUSH
42186: LD_INT 2
42188: ARRAY
42189: IN
42190: NOT
42191: AND
42192: PUSH
42193: LD_VAR 0 3
42197: PUSH
42198: LD_EXP 62
42202: PUSH
42203: LD_VAR 0 2
42207: ARRAY
42208: IN
42209: NOT
42210: AND
42211: IFFALSE 42248
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
42213: LD_VAR 0 2
42217: PPUSH
42218: LD_EXP 50
42222: PUSH
42223: LD_VAR 0 2
42227: ARRAY
42228: PPUSH
42229: LD_VAR 0 3
42233: PPUSH
42234: LD_VAR 0 3
42238: PPUSH
42239: CALL_OW 257
42243: PPUSH
42244: CALL 41062 0 4
// end ;
42248: GO 42097
42250: POP
42251: POP
// end ;
42252: GO 42032
42254: POP
42255: POP
// end ;
42256: LD_VAR 0 1
42260: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
42261: LD_INT 0
42263: PPUSH
42264: PPUSH
42265: PPUSH
42266: PPUSH
42267: PPUSH
42268: PPUSH
// if not mc_bases [ base ] then
42269: LD_EXP 50
42273: PUSH
42274: LD_VAR 0 1
42278: ARRAY
42279: NOT
42280: IFFALSE 42284
// exit ;
42282: GO 42485
// tmp := [ ] ;
42284: LD_ADDR_VAR 0 6
42288: PUSH
42289: EMPTY
42290: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
42291: LD_ADDR_VAR 0 7
42295: PUSH
42296: LD_VAR 0 3
42300: PPUSH
42301: LD_INT 0
42303: PPUSH
42304: CALL_OW 517
42308: ST_TO_ADDR
// if not list then
42309: LD_VAR 0 7
42313: NOT
42314: IFFALSE 42318
// exit ;
42316: GO 42485
// c := Count ( list [ 1 ] ) ;
42318: LD_ADDR_VAR 0 9
42322: PUSH
42323: LD_VAR 0 7
42327: PUSH
42328: LD_INT 1
42330: ARRAY
42331: PPUSH
42332: CALL 51174 0 1
42336: ST_TO_ADDR
// if amount > c then
42337: LD_VAR 0 2
42341: PUSH
42342: LD_VAR 0 9
42346: GREATER
42347: IFFALSE 42359
// amount := c ;
42349: LD_ADDR_VAR 0 2
42353: PUSH
42354: LD_VAR 0 9
42358: ST_TO_ADDR
// for i := 1 to amount do
42359: LD_ADDR_VAR 0 5
42363: PUSH
42364: DOUBLE
42365: LD_INT 1
42367: DEC
42368: ST_TO_ADDR
42369: LD_VAR 0 2
42373: PUSH
42374: FOR_TO
42375: IFFALSE 42433
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
42377: LD_ADDR_VAR 0 6
42381: PUSH
42382: LD_VAR 0 6
42386: PPUSH
42387: LD_VAR 0 5
42391: PPUSH
42392: LD_VAR 0 7
42396: PUSH
42397: LD_INT 1
42399: ARRAY
42400: PUSH
42401: LD_VAR 0 5
42405: ARRAY
42406: PUSH
42407: LD_VAR 0 7
42411: PUSH
42412: LD_INT 2
42414: ARRAY
42415: PUSH
42416: LD_VAR 0 5
42420: ARRAY
42421: PUSH
42422: EMPTY
42423: LIST
42424: LIST
42425: PPUSH
42426: CALL_OW 1
42430: ST_TO_ADDR
42431: GO 42374
42433: POP
42434: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
42435: LD_ADDR_EXP 63
42439: PUSH
42440: LD_EXP 63
42444: PPUSH
42445: LD_VAR 0 1
42449: PPUSH
42450: LD_VAR 0 6
42454: PPUSH
42455: CALL_OW 1
42459: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
42460: LD_ADDR_EXP 65
42464: PUSH
42465: LD_EXP 65
42469: PPUSH
42470: LD_VAR 0 1
42474: PPUSH
42475: LD_VAR 0 3
42479: PPUSH
42480: CALL_OW 1
42484: ST_TO_ADDR
// end ;
42485: LD_VAR 0 4
42489: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
42490: LD_INT 0
42492: PPUSH
// if not mc_bases [ base ] then
42493: LD_EXP 50
42497: PUSH
42498: LD_VAR 0 1
42502: ARRAY
42503: NOT
42504: IFFALSE 42508
// exit ;
42506: GO 42533
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
42508: LD_ADDR_EXP 55
42512: PUSH
42513: LD_EXP 55
42517: PPUSH
42518: LD_VAR 0 1
42522: PPUSH
42523: LD_VAR 0 2
42527: PPUSH
42528: CALL_OW 1
42532: ST_TO_ADDR
// end ;
42533: LD_VAR 0 3
42537: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
42538: LD_INT 0
42540: PPUSH
// if not mc_bases [ base ] then
42541: LD_EXP 50
42545: PUSH
42546: LD_VAR 0 1
42550: ARRAY
42551: NOT
42552: IFFALSE 42556
// exit ;
42554: GO 42593
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
42556: LD_ADDR_EXP 55
42560: PUSH
42561: LD_EXP 55
42565: PPUSH
42566: LD_VAR 0 1
42570: PPUSH
42571: LD_EXP 55
42575: PUSH
42576: LD_VAR 0 1
42580: ARRAY
42581: PUSH
42582: LD_VAR 0 2
42586: UNION
42587: PPUSH
42588: CALL_OW 1
42592: ST_TO_ADDR
// end ;
42593: LD_VAR 0 3
42597: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
42598: LD_INT 0
42600: PPUSH
// if not mc_bases [ base ] then
42601: LD_EXP 50
42605: PUSH
42606: LD_VAR 0 1
42610: ARRAY
42611: NOT
42612: IFFALSE 42616
// exit ;
42614: GO 42641
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
42616: LD_ADDR_EXP 71
42620: PUSH
42621: LD_EXP 71
42625: PPUSH
42626: LD_VAR 0 1
42630: PPUSH
42631: LD_VAR 0 2
42635: PPUSH
42636: CALL_OW 1
42640: ST_TO_ADDR
// end ;
42641: LD_VAR 0 3
42645: RET
// export function MC_InsertProduceList ( base , components ) ; begin
42646: LD_INT 0
42648: PPUSH
// if not mc_bases [ base ] then
42649: LD_EXP 50
42653: PUSH
42654: LD_VAR 0 1
42658: ARRAY
42659: NOT
42660: IFFALSE 42664
// exit ;
42662: GO 42701
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
42664: LD_ADDR_EXP 71
42668: PUSH
42669: LD_EXP 71
42673: PPUSH
42674: LD_VAR 0 1
42678: PPUSH
42679: LD_EXP 71
42683: PUSH
42684: LD_VAR 0 1
42688: ARRAY
42689: PUSH
42690: LD_VAR 0 2
42694: ADD
42695: PPUSH
42696: CALL_OW 1
42700: ST_TO_ADDR
// end ;
42701: LD_VAR 0 3
42705: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
42706: LD_INT 0
42708: PPUSH
// if not mc_bases [ base ] then
42709: LD_EXP 50
42713: PUSH
42714: LD_VAR 0 1
42718: ARRAY
42719: NOT
42720: IFFALSE 42724
// exit ;
42722: GO 42778
// mc_defender := Replace ( mc_defender , base , deflist ) ;
42724: LD_ADDR_EXP 72
42728: PUSH
42729: LD_EXP 72
42733: PPUSH
42734: LD_VAR 0 1
42738: PPUSH
42739: LD_VAR 0 2
42743: PPUSH
42744: CALL_OW 1
42748: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
42749: LD_ADDR_EXP 61
42753: PUSH
42754: LD_EXP 61
42758: PPUSH
42759: LD_VAR 0 1
42763: PPUSH
42764: LD_VAR 0 2
42768: PUSH
42769: LD_INT 0
42771: PLUS
42772: PPUSH
42773: CALL_OW 1
42777: ST_TO_ADDR
// end ;
42778: LD_VAR 0 3
42782: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
42783: LD_INT 0
42785: PPUSH
// if not mc_bases [ base ] then
42786: LD_EXP 50
42790: PUSH
42791: LD_VAR 0 1
42795: ARRAY
42796: NOT
42797: IFFALSE 42801
// exit ;
42799: GO 42826
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
42801: LD_ADDR_EXP 61
42805: PUSH
42806: LD_EXP 61
42810: PPUSH
42811: LD_VAR 0 1
42815: PPUSH
42816: LD_VAR 0 2
42820: PPUSH
42821: CALL_OW 1
42825: ST_TO_ADDR
// end ;
42826: LD_VAR 0 3
42830: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
42831: LD_INT 0
42833: PPUSH
42834: PPUSH
42835: PPUSH
42836: PPUSH
// if not mc_bases [ base ] then
42837: LD_EXP 50
42841: PUSH
42842: LD_VAR 0 1
42846: ARRAY
42847: NOT
42848: IFFALSE 42852
// exit ;
42850: GO 42917
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
42852: LD_ADDR_EXP 70
42856: PUSH
42857: LD_EXP 70
42861: PPUSH
42862: LD_VAR 0 1
42866: PUSH
42867: LD_EXP 70
42871: PUSH
42872: LD_VAR 0 1
42876: ARRAY
42877: PUSH
42878: LD_INT 1
42880: PLUS
42881: PUSH
42882: EMPTY
42883: LIST
42884: LIST
42885: PPUSH
42886: LD_VAR 0 1
42890: PUSH
42891: LD_VAR 0 2
42895: PUSH
42896: LD_VAR 0 3
42900: PUSH
42901: LD_VAR 0 4
42905: PUSH
42906: EMPTY
42907: LIST
42908: LIST
42909: LIST
42910: LIST
42911: PPUSH
42912: CALL 54034 0 3
42916: ST_TO_ADDR
// end ;
42917: LD_VAR 0 5
42921: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
42922: LD_INT 0
42924: PPUSH
// if not mc_bases [ base ] then
42925: LD_EXP 50
42929: PUSH
42930: LD_VAR 0 1
42934: ARRAY
42935: NOT
42936: IFFALSE 42940
// exit ;
42938: GO 42965
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
42940: LD_ADDR_EXP 87
42944: PUSH
42945: LD_EXP 87
42949: PPUSH
42950: LD_VAR 0 1
42954: PPUSH
42955: LD_VAR 0 2
42959: PPUSH
42960: CALL_OW 1
42964: ST_TO_ADDR
// end ;
42965: LD_VAR 0 3
42969: RET
// export function MC_GetMinesField ( base ) ; begin
42970: LD_INT 0
42972: PPUSH
// result := mc_mines [ base ] ;
42973: LD_ADDR_VAR 0 2
42977: PUSH
42978: LD_EXP 63
42982: PUSH
42983: LD_VAR 0 1
42987: ARRAY
42988: ST_TO_ADDR
// end ;
42989: LD_VAR 0 2
42993: RET
// export function MC_GetProduceList ( base ) ; begin
42994: LD_INT 0
42996: PPUSH
// result := mc_produce [ base ] ;
42997: LD_ADDR_VAR 0 2
43001: PUSH
43002: LD_EXP 71
43006: PUSH
43007: LD_VAR 0 1
43011: ARRAY
43012: ST_TO_ADDR
// end ;
43013: LD_VAR 0 2
43017: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
43018: LD_INT 0
43020: PPUSH
43021: PPUSH
// if not mc_bases then
43022: LD_EXP 50
43026: NOT
43027: IFFALSE 43031
// exit ;
43029: GO 43096
// if mc_bases [ base ] then
43031: LD_EXP 50
43035: PUSH
43036: LD_VAR 0 1
43040: ARRAY
43041: IFFALSE 43096
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
43043: LD_ADDR_VAR 0 3
43047: PUSH
43048: LD_EXP 50
43052: PUSH
43053: LD_VAR 0 1
43057: ARRAY
43058: PPUSH
43059: LD_INT 30
43061: PUSH
43062: LD_VAR 0 2
43066: PUSH
43067: EMPTY
43068: LIST
43069: LIST
43070: PPUSH
43071: CALL_OW 72
43075: ST_TO_ADDR
// if result then
43076: LD_VAR 0 3
43080: IFFALSE 43096
// result := result [ 1 ] ;
43082: LD_ADDR_VAR 0 3
43086: PUSH
43087: LD_VAR 0 3
43091: PUSH
43092: LD_INT 1
43094: ARRAY
43095: ST_TO_ADDR
// end ; end ;
43096: LD_VAR 0 3
43100: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
43101: LD_INT 0
43103: PPUSH
43104: PPUSH
// if not mc_bases then
43105: LD_EXP 50
43109: NOT
43110: IFFALSE 43114
// exit ;
43112: GO 43159
// if mc_bases [ base ] then
43114: LD_EXP 50
43118: PUSH
43119: LD_VAR 0 1
43123: ARRAY
43124: IFFALSE 43159
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
43126: LD_ADDR_VAR 0 3
43130: PUSH
43131: LD_EXP 50
43135: PUSH
43136: LD_VAR 0 1
43140: ARRAY
43141: PPUSH
43142: LD_INT 30
43144: PUSH
43145: LD_VAR 0 2
43149: PUSH
43150: EMPTY
43151: LIST
43152: LIST
43153: PPUSH
43154: CALL_OW 72
43158: ST_TO_ADDR
// end ;
43159: LD_VAR 0 3
43163: RET
// export function MC_SetTame ( base , area ) ; begin
43164: LD_INT 0
43166: PPUSH
// if not mc_bases or not base then
43167: LD_EXP 50
43171: NOT
43172: PUSH
43173: LD_VAR 0 1
43177: NOT
43178: OR
43179: IFFALSE 43183
// exit ;
43181: GO 43208
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
43183: LD_ADDR_EXP 78
43187: PUSH
43188: LD_EXP 78
43192: PPUSH
43193: LD_VAR 0 1
43197: PPUSH
43198: LD_VAR 0 2
43202: PPUSH
43203: CALL_OW 1
43207: ST_TO_ADDR
// end ;
43208: LD_VAR 0 3
43212: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
43213: LD_INT 0
43215: PPUSH
43216: PPUSH
// if not mc_bases or not base then
43217: LD_EXP 50
43221: NOT
43222: PUSH
43223: LD_VAR 0 1
43227: NOT
43228: OR
43229: IFFALSE 43233
// exit ;
43231: GO 43335
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
43233: LD_ADDR_VAR 0 4
43237: PUSH
43238: LD_EXP 50
43242: PUSH
43243: LD_VAR 0 1
43247: ARRAY
43248: PPUSH
43249: LD_INT 30
43251: PUSH
43252: LD_VAR 0 2
43256: PUSH
43257: EMPTY
43258: LIST
43259: LIST
43260: PPUSH
43261: CALL_OW 72
43265: ST_TO_ADDR
// if not tmp then
43266: LD_VAR 0 4
43270: NOT
43271: IFFALSE 43275
// exit ;
43273: GO 43335
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
43275: LD_ADDR_EXP 82
43279: PUSH
43280: LD_EXP 82
43284: PPUSH
43285: LD_VAR 0 1
43289: PPUSH
43290: LD_EXP 82
43294: PUSH
43295: LD_VAR 0 1
43299: ARRAY
43300: PPUSH
43301: LD_EXP 82
43305: PUSH
43306: LD_VAR 0 1
43310: ARRAY
43311: PUSH
43312: LD_INT 1
43314: PLUS
43315: PPUSH
43316: LD_VAR 0 4
43320: PUSH
43321: LD_INT 1
43323: ARRAY
43324: PPUSH
43325: CALL_OW 2
43329: PPUSH
43330: CALL_OW 1
43334: ST_TO_ADDR
// end ;
43335: LD_VAR 0 3
43339: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
43340: LD_INT 0
43342: PPUSH
43343: PPUSH
// if not mc_bases or not base or not kinds then
43344: LD_EXP 50
43348: NOT
43349: PUSH
43350: LD_VAR 0 1
43354: NOT
43355: OR
43356: PUSH
43357: LD_VAR 0 2
43361: NOT
43362: OR
43363: IFFALSE 43367
// exit ;
43365: GO 43428
// for i in kinds do
43367: LD_ADDR_VAR 0 4
43371: PUSH
43372: LD_VAR 0 2
43376: PUSH
43377: FOR_IN
43378: IFFALSE 43426
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
43380: LD_ADDR_EXP 84
43384: PUSH
43385: LD_EXP 84
43389: PPUSH
43390: LD_VAR 0 1
43394: PUSH
43395: LD_EXP 84
43399: PUSH
43400: LD_VAR 0 1
43404: ARRAY
43405: PUSH
43406: LD_INT 1
43408: PLUS
43409: PUSH
43410: EMPTY
43411: LIST
43412: LIST
43413: PPUSH
43414: LD_VAR 0 4
43418: PPUSH
43419: CALL 54034 0 3
43423: ST_TO_ADDR
43424: GO 43377
43426: POP
43427: POP
// end ;
43428: LD_VAR 0 3
43432: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
43433: LD_INT 0
43435: PPUSH
// if not mc_bases or not base or not areas then
43436: LD_EXP 50
43440: NOT
43441: PUSH
43442: LD_VAR 0 1
43446: NOT
43447: OR
43448: PUSH
43449: LD_VAR 0 2
43453: NOT
43454: OR
43455: IFFALSE 43459
// exit ;
43457: GO 43484
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
43459: LD_ADDR_EXP 68
43463: PUSH
43464: LD_EXP 68
43468: PPUSH
43469: LD_VAR 0 1
43473: PPUSH
43474: LD_VAR 0 2
43478: PPUSH
43479: CALL_OW 1
43483: ST_TO_ADDR
// end ;
43484: LD_VAR 0 3
43488: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
43489: LD_INT 0
43491: PPUSH
// if not mc_bases or not base or not teleports_exit then
43492: LD_EXP 50
43496: NOT
43497: PUSH
43498: LD_VAR 0 1
43502: NOT
43503: OR
43504: PUSH
43505: LD_VAR 0 2
43509: NOT
43510: OR
43511: IFFALSE 43515
// exit ;
43513: GO 43540
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
43515: LD_ADDR_EXP 85
43519: PUSH
43520: LD_EXP 85
43524: PPUSH
43525: LD_VAR 0 1
43529: PPUSH
43530: LD_VAR 0 2
43534: PPUSH
43535: CALL_OW 1
43539: ST_TO_ADDR
// end ;
43540: LD_VAR 0 3
43544: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
43545: LD_INT 0
43547: PPUSH
43548: PPUSH
43549: PPUSH
// if not mc_bases or not base or not ext_list then
43550: LD_EXP 50
43554: NOT
43555: PUSH
43556: LD_VAR 0 1
43560: NOT
43561: OR
43562: PUSH
43563: LD_VAR 0 5
43567: NOT
43568: OR
43569: IFFALSE 43573
// exit ;
43571: GO 43746
// tmp := GetFacExtXYD ( x , y , d ) ;
43573: LD_ADDR_VAR 0 8
43577: PUSH
43578: LD_VAR 0 2
43582: PPUSH
43583: LD_VAR 0 3
43587: PPUSH
43588: LD_VAR 0 4
43592: PPUSH
43593: CALL 84011 0 3
43597: ST_TO_ADDR
// if not tmp then
43598: LD_VAR 0 8
43602: NOT
43603: IFFALSE 43607
// exit ;
43605: GO 43746
// for i in tmp do
43607: LD_ADDR_VAR 0 7
43611: PUSH
43612: LD_VAR 0 8
43616: PUSH
43617: FOR_IN
43618: IFFALSE 43744
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
43620: LD_ADDR_EXP 55
43624: PUSH
43625: LD_EXP 55
43629: PPUSH
43630: LD_VAR 0 1
43634: PPUSH
43635: LD_EXP 55
43639: PUSH
43640: LD_VAR 0 1
43644: ARRAY
43645: PPUSH
43646: LD_EXP 55
43650: PUSH
43651: LD_VAR 0 1
43655: ARRAY
43656: PUSH
43657: LD_INT 1
43659: PLUS
43660: PPUSH
43661: LD_VAR 0 5
43665: PUSH
43666: LD_INT 1
43668: ARRAY
43669: PUSH
43670: LD_VAR 0 7
43674: PUSH
43675: LD_INT 1
43677: ARRAY
43678: PUSH
43679: LD_VAR 0 7
43683: PUSH
43684: LD_INT 2
43686: ARRAY
43687: PUSH
43688: LD_VAR 0 7
43692: PUSH
43693: LD_INT 3
43695: ARRAY
43696: PUSH
43697: EMPTY
43698: LIST
43699: LIST
43700: LIST
43701: LIST
43702: PPUSH
43703: CALL_OW 2
43707: PPUSH
43708: CALL_OW 1
43712: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
43713: LD_ADDR_VAR 0 5
43717: PUSH
43718: LD_VAR 0 5
43722: PPUSH
43723: LD_INT 1
43725: PPUSH
43726: CALL_OW 3
43730: ST_TO_ADDR
// if not ext_list then
43731: LD_VAR 0 5
43735: NOT
43736: IFFALSE 43742
// exit ;
43738: POP
43739: POP
43740: GO 43746
// end ;
43742: GO 43617
43744: POP
43745: POP
// end ;
43746: LD_VAR 0 6
43750: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
43751: LD_INT 0
43753: PPUSH
// if not mc_bases or not base or not weapon_list then
43754: LD_EXP 50
43758: NOT
43759: PUSH
43760: LD_VAR 0 1
43764: NOT
43765: OR
43766: PUSH
43767: LD_VAR 0 2
43771: NOT
43772: OR
43773: IFFALSE 43777
// exit ;
43775: GO 43802
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
43777: LD_ADDR_EXP 89
43781: PUSH
43782: LD_EXP 89
43786: PPUSH
43787: LD_VAR 0 1
43791: PPUSH
43792: LD_VAR 0 2
43796: PPUSH
43797: CALL_OW 1
43801: ST_TO_ADDR
// end ;
43802: LD_VAR 0 3
43806: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
43807: LD_INT 0
43809: PPUSH
// if not mc_bases or not base or not tech_list then
43810: LD_EXP 50
43814: NOT
43815: PUSH
43816: LD_VAR 0 1
43820: NOT
43821: OR
43822: PUSH
43823: LD_VAR 0 2
43827: NOT
43828: OR
43829: IFFALSE 43833
// exit ;
43831: GO 43858
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
43833: LD_ADDR_EXP 77
43837: PUSH
43838: LD_EXP 77
43842: PPUSH
43843: LD_VAR 0 1
43847: PPUSH
43848: LD_VAR 0 2
43852: PPUSH
43853: CALL_OW 1
43857: ST_TO_ADDR
// end ;
43858: LD_VAR 0 3
43862: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
43863: LD_INT 0
43865: PPUSH
// if not mc_bases or not parking_area or not base then
43866: LD_EXP 50
43870: NOT
43871: PUSH
43872: LD_VAR 0 2
43876: NOT
43877: OR
43878: PUSH
43879: LD_VAR 0 1
43883: NOT
43884: OR
43885: IFFALSE 43889
// exit ;
43887: GO 43914
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
43889: LD_ADDR_EXP 74
43893: PUSH
43894: LD_EXP 74
43898: PPUSH
43899: LD_VAR 0 1
43903: PPUSH
43904: LD_VAR 0 2
43908: PPUSH
43909: CALL_OW 1
43913: ST_TO_ADDR
// end ;
43914: LD_VAR 0 3
43918: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
43919: LD_INT 0
43921: PPUSH
// if not mc_bases or not base or not scan_area then
43922: LD_EXP 50
43926: NOT
43927: PUSH
43928: LD_VAR 0 1
43932: NOT
43933: OR
43934: PUSH
43935: LD_VAR 0 2
43939: NOT
43940: OR
43941: IFFALSE 43945
// exit ;
43943: GO 43970
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
43945: LD_ADDR_EXP 75
43949: PUSH
43950: LD_EXP 75
43954: PPUSH
43955: LD_VAR 0 1
43959: PPUSH
43960: LD_VAR 0 2
43964: PPUSH
43965: CALL_OW 1
43969: ST_TO_ADDR
// end ;
43970: LD_VAR 0 3
43974: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
43975: LD_INT 0
43977: PPUSH
43978: PPUSH
// if not mc_bases or not base then
43979: LD_EXP 50
43983: NOT
43984: PUSH
43985: LD_VAR 0 1
43989: NOT
43990: OR
43991: IFFALSE 43995
// exit ;
43993: GO 44059
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
43995: LD_ADDR_VAR 0 3
43999: PUSH
44000: LD_INT 1
44002: PUSH
44003: LD_INT 2
44005: PUSH
44006: LD_INT 3
44008: PUSH
44009: LD_INT 4
44011: PUSH
44012: LD_INT 11
44014: PUSH
44015: EMPTY
44016: LIST
44017: LIST
44018: LIST
44019: LIST
44020: LIST
44021: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
44022: LD_ADDR_EXP 77
44026: PUSH
44027: LD_EXP 77
44031: PPUSH
44032: LD_VAR 0 1
44036: PPUSH
44037: LD_EXP 77
44041: PUSH
44042: LD_VAR 0 1
44046: ARRAY
44047: PUSH
44048: LD_VAR 0 3
44052: DIFF
44053: PPUSH
44054: CALL_OW 1
44058: ST_TO_ADDR
// end ;
44059: LD_VAR 0 2
44063: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
44064: LD_INT 0
44066: PPUSH
// result := mc_vehicles [ base ] ;
44067: LD_ADDR_VAR 0 3
44071: PUSH
44072: LD_EXP 69
44076: PUSH
44077: LD_VAR 0 1
44081: ARRAY
44082: ST_TO_ADDR
// if onlyCombat then
44083: LD_VAR 0 2
44087: IFFALSE 44259
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
44089: LD_ADDR_VAR 0 3
44093: PUSH
44094: LD_VAR 0 3
44098: PUSH
44099: LD_VAR 0 3
44103: PPUSH
44104: LD_INT 2
44106: PUSH
44107: LD_INT 34
44109: PUSH
44110: LD_INT 12
44112: PUSH
44113: EMPTY
44114: LIST
44115: LIST
44116: PUSH
44117: LD_INT 34
44119: PUSH
44120: LD_INT 51
44122: PUSH
44123: EMPTY
44124: LIST
44125: LIST
44126: PUSH
44127: LD_INT 34
44129: PUSH
44130: LD_INT 89
44132: PUSH
44133: EMPTY
44134: LIST
44135: LIST
44136: PUSH
44137: LD_INT 34
44139: PUSH
44140: LD_INT 32
44142: PUSH
44143: EMPTY
44144: LIST
44145: LIST
44146: PUSH
44147: LD_INT 34
44149: PUSH
44150: LD_INT 13
44152: PUSH
44153: EMPTY
44154: LIST
44155: LIST
44156: PUSH
44157: LD_INT 34
44159: PUSH
44160: LD_INT 52
44162: PUSH
44163: EMPTY
44164: LIST
44165: LIST
44166: PUSH
44167: LD_INT 34
44169: PUSH
44170: LD_INT 88
44172: PUSH
44173: EMPTY
44174: LIST
44175: LIST
44176: PUSH
44177: LD_INT 34
44179: PUSH
44180: LD_INT 14
44182: PUSH
44183: EMPTY
44184: LIST
44185: LIST
44186: PUSH
44187: LD_INT 34
44189: PUSH
44190: LD_INT 53
44192: PUSH
44193: EMPTY
44194: LIST
44195: LIST
44196: PUSH
44197: LD_INT 34
44199: PUSH
44200: LD_INT 98
44202: PUSH
44203: EMPTY
44204: LIST
44205: LIST
44206: PUSH
44207: LD_INT 34
44209: PUSH
44210: LD_INT 31
44212: PUSH
44213: EMPTY
44214: LIST
44215: LIST
44216: PUSH
44217: LD_INT 34
44219: PUSH
44220: LD_INT 48
44222: PUSH
44223: EMPTY
44224: LIST
44225: LIST
44226: PUSH
44227: LD_INT 34
44229: PUSH
44230: LD_INT 8
44232: PUSH
44233: EMPTY
44234: LIST
44235: LIST
44236: PUSH
44237: EMPTY
44238: LIST
44239: LIST
44240: LIST
44241: LIST
44242: LIST
44243: LIST
44244: LIST
44245: LIST
44246: LIST
44247: LIST
44248: LIST
44249: LIST
44250: LIST
44251: LIST
44252: PPUSH
44253: CALL_OW 72
44257: DIFF
44258: ST_TO_ADDR
// end ; end_of_file
44259: LD_VAR 0 3
44263: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
44264: LD_INT 0
44266: PPUSH
44267: PPUSH
44268: PPUSH
// if not mc_bases or not skirmish then
44269: LD_EXP 50
44273: NOT
44274: PUSH
44275: LD_EXP 48
44279: NOT
44280: OR
44281: IFFALSE 44285
// exit ;
44283: GO 44450
// for i = 1 to mc_bases do
44285: LD_ADDR_VAR 0 4
44289: PUSH
44290: DOUBLE
44291: LD_INT 1
44293: DEC
44294: ST_TO_ADDR
44295: LD_EXP 50
44299: PUSH
44300: FOR_TO
44301: IFFALSE 44448
// begin if sci in mc_bases [ i ] then
44303: LD_VAR 0 2
44307: PUSH
44308: LD_EXP 50
44312: PUSH
44313: LD_VAR 0 4
44317: ARRAY
44318: IN
44319: IFFALSE 44446
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
44321: LD_ADDR_EXP 79
44325: PUSH
44326: LD_EXP 79
44330: PPUSH
44331: LD_VAR 0 4
44335: PUSH
44336: LD_EXP 79
44340: PUSH
44341: LD_VAR 0 4
44345: ARRAY
44346: PUSH
44347: LD_INT 1
44349: PLUS
44350: PUSH
44351: EMPTY
44352: LIST
44353: LIST
44354: PPUSH
44355: LD_VAR 0 1
44359: PPUSH
44360: CALL 54034 0 3
44364: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
44365: LD_ADDR_VAR 0 5
44369: PUSH
44370: LD_EXP 50
44374: PUSH
44375: LD_VAR 0 4
44379: ARRAY
44380: PPUSH
44381: LD_INT 2
44383: PUSH
44384: LD_INT 30
44386: PUSH
44387: LD_INT 0
44389: PUSH
44390: EMPTY
44391: LIST
44392: LIST
44393: PUSH
44394: LD_INT 30
44396: PUSH
44397: LD_INT 1
44399: PUSH
44400: EMPTY
44401: LIST
44402: LIST
44403: PUSH
44404: EMPTY
44405: LIST
44406: LIST
44407: LIST
44408: PPUSH
44409: CALL_OW 72
44413: PPUSH
44414: LD_VAR 0 1
44418: PPUSH
44419: CALL_OW 74
44423: ST_TO_ADDR
// if tmp then
44424: LD_VAR 0 5
44428: IFFALSE 44444
// ComStandNearbyBuilding ( ape , tmp ) ;
44430: LD_VAR 0 1
44434: PPUSH
44435: LD_VAR 0 5
44439: PPUSH
44440: CALL 50636 0 2
// break ;
44444: GO 44448
// end ; end ;
44446: GO 44300
44448: POP
44449: POP
// end ;
44450: LD_VAR 0 3
44454: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
44455: LD_INT 0
44457: PPUSH
44458: PPUSH
44459: PPUSH
// if not mc_bases or not skirmish then
44460: LD_EXP 50
44464: NOT
44465: PUSH
44466: LD_EXP 48
44470: NOT
44471: OR
44472: IFFALSE 44476
// exit ;
44474: GO 44565
// for i = 1 to mc_bases do
44476: LD_ADDR_VAR 0 4
44480: PUSH
44481: DOUBLE
44482: LD_INT 1
44484: DEC
44485: ST_TO_ADDR
44486: LD_EXP 50
44490: PUSH
44491: FOR_TO
44492: IFFALSE 44563
// begin if building in mc_busy_turret_list [ i ] then
44494: LD_VAR 0 1
44498: PUSH
44499: LD_EXP 60
44503: PUSH
44504: LD_VAR 0 4
44508: ARRAY
44509: IN
44510: IFFALSE 44561
// begin tmp := mc_busy_turret_list [ i ] diff building ;
44512: LD_ADDR_VAR 0 5
44516: PUSH
44517: LD_EXP 60
44521: PUSH
44522: LD_VAR 0 4
44526: ARRAY
44527: PUSH
44528: LD_VAR 0 1
44532: DIFF
44533: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
44534: LD_ADDR_EXP 60
44538: PUSH
44539: LD_EXP 60
44543: PPUSH
44544: LD_VAR 0 4
44548: PPUSH
44549: LD_VAR 0 5
44553: PPUSH
44554: CALL_OW 1
44558: ST_TO_ADDR
// break ;
44559: GO 44563
// end ; end ;
44561: GO 44491
44563: POP
44564: POP
// end ;
44565: LD_VAR 0 3
44569: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
44570: LD_INT 0
44572: PPUSH
44573: PPUSH
44574: PPUSH
// if not mc_bases or not skirmish then
44575: LD_EXP 50
44579: NOT
44580: PUSH
44581: LD_EXP 48
44585: NOT
44586: OR
44587: IFFALSE 44591
// exit ;
44589: GO 44790
// for i = 1 to mc_bases do
44591: LD_ADDR_VAR 0 5
44595: PUSH
44596: DOUBLE
44597: LD_INT 1
44599: DEC
44600: ST_TO_ADDR
44601: LD_EXP 50
44605: PUSH
44606: FOR_TO
44607: IFFALSE 44788
// if building in mc_bases [ i ] then
44609: LD_VAR 0 1
44613: PUSH
44614: LD_EXP 50
44618: PUSH
44619: LD_VAR 0 5
44623: ARRAY
44624: IN
44625: IFFALSE 44786
// begin tmp := mc_bases [ i ] diff building ;
44627: LD_ADDR_VAR 0 6
44631: PUSH
44632: LD_EXP 50
44636: PUSH
44637: LD_VAR 0 5
44641: ARRAY
44642: PUSH
44643: LD_VAR 0 1
44647: DIFF
44648: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
44649: LD_ADDR_EXP 50
44653: PUSH
44654: LD_EXP 50
44658: PPUSH
44659: LD_VAR 0 5
44663: PPUSH
44664: LD_VAR 0 6
44668: PPUSH
44669: CALL_OW 1
44673: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
44674: LD_VAR 0 1
44678: PUSH
44679: LD_EXP 58
44683: PUSH
44684: LD_VAR 0 5
44688: ARRAY
44689: IN
44690: IFFALSE 44729
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
44692: LD_ADDR_EXP 58
44696: PUSH
44697: LD_EXP 58
44701: PPUSH
44702: LD_VAR 0 5
44706: PPUSH
44707: LD_EXP 58
44711: PUSH
44712: LD_VAR 0 5
44716: ARRAY
44717: PUSH
44718: LD_VAR 0 1
44722: DIFF
44723: PPUSH
44724: CALL_OW 1
44728: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
44729: LD_VAR 0 1
44733: PUSH
44734: LD_EXP 59
44738: PUSH
44739: LD_VAR 0 5
44743: ARRAY
44744: IN
44745: IFFALSE 44784
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
44747: LD_ADDR_EXP 59
44751: PUSH
44752: LD_EXP 59
44756: PPUSH
44757: LD_VAR 0 5
44761: PPUSH
44762: LD_EXP 59
44766: PUSH
44767: LD_VAR 0 5
44771: ARRAY
44772: PUSH
44773: LD_VAR 0 1
44777: DIFF
44778: PPUSH
44779: CALL_OW 1
44783: ST_TO_ADDR
// break ;
44784: GO 44788
// end ;
44786: GO 44606
44788: POP
44789: POP
// end ;
44790: LD_VAR 0 4
44794: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
44795: LD_INT 0
44797: PPUSH
44798: PPUSH
44799: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
44800: LD_EXP 50
44804: NOT
44805: PUSH
44806: LD_EXP 48
44810: NOT
44811: OR
44812: PUSH
44813: LD_VAR 0 3
44817: PUSH
44818: LD_EXP 76
44822: IN
44823: NOT
44824: OR
44825: IFFALSE 44829
// exit ;
44827: GO 44952
// for i = 1 to mc_vehicles do
44829: LD_ADDR_VAR 0 6
44833: PUSH
44834: DOUBLE
44835: LD_INT 1
44837: DEC
44838: ST_TO_ADDR
44839: LD_EXP 69
44843: PUSH
44844: FOR_TO
44845: IFFALSE 44950
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
44847: LD_VAR 0 2
44851: PUSH
44852: LD_EXP 69
44856: PUSH
44857: LD_VAR 0 6
44861: ARRAY
44862: IN
44863: PUSH
44864: LD_VAR 0 1
44868: PUSH
44869: LD_EXP 69
44873: PUSH
44874: LD_VAR 0 6
44878: ARRAY
44879: IN
44880: OR
44881: IFFALSE 44948
// begin tmp := mc_vehicles [ i ] diff old ;
44883: LD_ADDR_VAR 0 7
44887: PUSH
44888: LD_EXP 69
44892: PUSH
44893: LD_VAR 0 6
44897: ARRAY
44898: PUSH
44899: LD_VAR 0 2
44903: DIFF
44904: ST_TO_ADDR
// tmp := tmp diff new ;
44905: LD_ADDR_VAR 0 7
44909: PUSH
44910: LD_VAR 0 7
44914: PUSH
44915: LD_VAR 0 1
44919: DIFF
44920: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
44921: LD_ADDR_EXP 69
44925: PUSH
44926: LD_EXP 69
44930: PPUSH
44931: LD_VAR 0 6
44935: PPUSH
44936: LD_VAR 0 7
44940: PPUSH
44941: CALL_OW 1
44945: ST_TO_ADDR
// break ;
44946: GO 44950
// end ;
44948: GO 44844
44950: POP
44951: POP
// end ;
44952: LD_VAR 0 5
44956: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
44957: LD_INT 0
44959: PPUSH
44960: PPUSH
44961: PPUSH
44962: PPUSH
// if not mc_bases or not skirmish then
44963: LD_EXP 50
44967: NOT
44968: PUSH
44969: LD_EXP 48
44973: NOT
44974: OR
44975: IFFALSE 44979
// exit ;
44977: GO 45399
// repeat wait ( 0 0$1 ) ;
44979: LD_INT 35
44981: PPUSH
44982: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
44986: LD_EXP 94
44990: NOT
44991: IFFALSE 44979
// mc_block_vehicle_constructed_thread := true ;
44993: LD_ADDR_EXP 94
44997: PUSH
44998: LD_INT 1
45000: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
45001: LD_ADDR_VAR 0 5
45005: PUSH
45006: LD_VAR 0 1
45010: PPUSH
45011: CALL_OW 255
45015: ST_TO_ADDR
// for i = 1 to mc_bases do
45016: LD_ADDR_VAR 0 4
45020: PUSH
45021: DOUBLE
45022: LD_INT 1
45024: DEC
45025: ST_TO_ADDR
45026: LD_EXP 50
45030: PUSH
45031: FOR_TO
45032: IFFALSE 45389
// begin if factory in mc_bases [ i ] then
45034: LD_VAR 0 2
45038: PUSH
45039: LD_EXP 50
45043: PUSH
45044: LD_VAR 0 4
45048: ARRAY
45049: IN
45050: IFFALSE 45387
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
45052: LD_EXP 72
45056: PUSH
45057: LD_VAR 0 4
45061: ARRAY
45062: PUSH
45063: LD_EXP 61
45067: PUSH
45068: LD_VAR 0 4
45072: ARRAY
45073: LESS
45074: PUSH
45075: LD_VAR 0 1
45079: PPUSH
45080: CALL_OW 264
45084: PUSH
45085: LD_INT 31
45087: PUSH
45088: LD_INT 32
45090: PUSH
45091: LD_INT 51
45093: PUSH
45094: LD_INT 89
45096: PUSH
45097: LD_INT 12
45099: PUSH
45100: LD_INT 30
45102: PUSH
45103: LD_INT 98
45105: PUSH
45106: LD_INT 11
45108: PUSH
45109: LD_INT 53
45111: PUSH
45112: LD_INT 14
45114: PUSH
45115: LD_INT 91
45117: PUSH
45118: LD_INT 29
45120: PUSH
45121: LD_INT 99
45123: PUSH
45124: LD_INT 13
45126: PUSH
45127: LD_INT 52
45129: PUSH
45130: LD_INT 88
45132: PUSH
45133: LD_INT 48
45135: PUSH
45136: LD_INT 8
45138: PUSH
45139: EMPTY
45140: LIST
45141: LIST
45142: LIST
45143: LIST
45144: LIST
45145: LIST
45146: LIST
45147: LIST
45148: LIST
45149: LIST
45150: LIST
45151: LIST
45152: LIST
45153: LIST
45154: LIST
45155: LIST
45156: LIST
45157: LIST
45158: IN
45159: NOT
45160: AND
45161: IFFALSE 45209
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
45163: LD_ADDR_EXP 72
45167: PUSH
45168: LD_EXP 72
45172: PPUSH
45173: LD_VAR 0 4
45177: PUSH
45178: LD_EXP 72
45182: PUSH
45183: LD_VAR 0 4
45187: ARRAY
45188: PUSH
45189: LD_INT 1
45191: PLUS
45192: PUSH
45193: EMPTY
45194: LIST
45195: LIST
45196: PPUSH
45197: LD_VAR 0 1
45201: PPUSH
45202: CALL 54034 0 3
45206: ST_TO_ADDR
45207: GO 45253
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
45209: LD_ADDR_EXP 69
45213: PUSH
45214: LD_EXP 69
45218: PPUSH
45219: LD_VAR 0 4
45223: PUSH
45224: LD_EXP 69
45228: PUSH
45229: LD_VAR 0 4
45233: ARRAY
45234: PUSH
45235: LD_INT 1
45237: PLUS
45238: PUSH
45239: EMPTY
45240: LIST
45241: LIST
45242: PPUSH
45243: LD_VAR 0 1
45247: PPUSH
45248: CALL 54034 0 3
45252: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
45253: LD_ADDR_EXP 94
45257: PUSH
45258: LD_INT 0
45260: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
45261: LD_VAR 0 1
45265: PPUSH
45266: CALL_OW 263
45270: PUSH
45271: LD_INT 2
45273: EQUAL
45274: IFFALSE 45303
// begin repeat wait ( 0 0$3 ) ;
45276: LD_INT 105
45278: PPUSH
45279: CALL_OW 67
// Connect ( vehicle ) ;
45283: LD_VAR 0 1
45287: PPUSH
45288: CALL 57003 0 1
// until IsControledBy ( vehicle ) ;
45292: LD_VAR 0 1
45296: PPUSH
45297: CALL_OW 312
45301: IFFALSE 45276
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
45303: LD_VAR 0 1
45307: PPUSH
45308: LD_EXP 74
45312: PUSH
45313: LD_VAR 0 4
45317: ARRAY
45318: PPUSH
45319: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
45323: LD_VAR 0 1
45327: PPUSH
45328: CALL_OW 263
45332: PUSH
45333: LD_INT 1
45335: NONEQUAL
45336: IFFALSE 45340
// break ;
45338: GO 45389
// repeat wait ( 0 0$1 ) ;
45340: LD_INT 35
45342: PPUSH
45343: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
45347: LD_VAR 0 1
45351: PPUSH
45352: LD_EXP 74
45356: PUSH
45357: LD_VAR 0 4
45361: ARRAY
45362: PPUSH
45363: CALL_OW 308
45367: IFFALSE 45340
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
45369: LD_VAR 0 1
45373: PPUSH
45374: CALL_OW 311
45378: PPUSH
45379: CALL_OW 121
// exit ;
45383: POP
45384: POP
45385: GO 45399
// end ; end ;
45387: GO 45031
45389: POP
45390: POP
// mc_block_vehicle_constructed_thread := false ;
45391: LD_ADDR_EXP 94
45395: PUSH
45396: LD_INT 0
45398: ST_TO_ADDR
// end ;
45399: LD_VAR 0 3
45403: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
45404: LD_INT 0
45406: PPUSH
45407: PPUSH
45408: PPUSH
45409: PPUSH
// if not mc_bases or not skirmish then
45410: LD_EXP 50
45414: NOT
45415: PUSH
45416: LD_EXP 48
45420: NOT
45421: OR
45422: IFFALSE 45426
// exit ;
45424: GO 45779
// repeat wait ( 0 0$1 ) ;
45426: LD_INT 35
45428: PPUSH
45429: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
45433: LD_VAR 0 2
45437: PPUSH
45438: LD_VAR 0 3
45442: PPUSH
45443: CALL_OW 284
45447: IFFALSE 45426
// if GetResourceTypeXY ( x , y ) = mat_artefact then
45449: LD_VAR 0 2
45453: PPUSH
45454: LD_VAR 0 3
45458: PPUSH
45459: CALL_OW 283
45463: PUSH
45464: LD_INT 4
45466: EQUAL
45467: IFFALSE 45471
// exit ;
45469: GO 45779
// for i = 1 to mc_bases do
45471: LD_ADDR_VAR 0 7
45475: PUSH
45476: DOUBLE
45477: LD_INT 1
45479: DEC
45480: ST_TO_ADDR
45481: LD_EXP 50
45485: PUSH
45486: FOR_TO
45487: IFFALSE 45777
// begin if mc_crates_area [ i ] then
45489: LD_EXP 68
45493: PUSH
45494: LD_VAR 0 7
45498: ARRAY
45499: IFFALSE 45610
// for j in mc_crates_area [ i ] do
45501: LD_ADDR_VAR 0 8
45505: PUSH
45506: LD_EXP 68
45510: PUSH
45511: LD_VAR 0 7
45515: ARRAY
45516: PUSH
45517: FOR_IN
45518: IFFALSE 45608
// if InArea ( x , y , j ) then
45520: LD_VAR 0 2
45524: PPUSH
45525: LD_VAR 0 3
45529: PPUSH
45530: LD_VAR 0 8
45534: PPUSH
45535: CALL_OW 309
45539: IFFALSE 45606
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
45541: LD_ADDR_EXP 66
45545: PUSH
45546: LD_EXP 66
45550: PPUSH
45551: LD_VAR 0 7
45555: PUSH
45556: LD_EXP 66
45560: PUSH
45561: LD_VAR 0 7
45565: ARRAY
45566: PUSH
45567: LD_INT 1
45569: PLUS
45570: PUSH
45571: EMPTY
45572: LIST
45573: LIST
45574: PPUSH
45575: LD_VAR 0 4
45579: PUSH
45580: LD_VAR 0 2
45584: PUSH
45585: LD_VAR 0 3
45589: PUSH
45590: EMPTY
45591: LIST
45592: LIST
45593: LIST
45594: PPUSH
45595: CALL 54034 0 3
45599: ST_TO_ADDR
// exit ;
45600: POP
45601: POP
45602: POP
45603: POP
45604: GO 45779
// end ;
45606: GO 45517
45608: POP
45609: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
45610: LD_ADDR_VAR 0 9
45614: PUSH
45615: LD_EXP 50
45619: PUSH
45620: LD_VAR 0 7
45624: ARRAY
45625: PPUSH
45626: LD_INT 2
45628: PUSH
45629: LD_INT 30
45631: PUSH
45632: LD_INT 0
45634: PUSH
45635: EMPTY
45636: LIST
45637: LIST
45638: PUSH
45639: LD_INT 30
45641: PUSH
45642: LD_INT 1
45644: PUSH
45645: EMPTY
45646: LIST
45647: LIST
45648: PUSH
45649: EMPTY
45650: LIST
45651: LIST
45652: LIST
45653: PPUSH
45654: CALL_OW 72
45658: ST_TO_ADDR
// if not depot then
45659: LD_VAR 0 9
45663: NOT
45664: IFFALSE 45668
// continue ;
45666: GO 45486
// for j in depot do
45668: LD_ADDR_VAR 0 8
45672: PUSH
45673: LD_VAR 0 9
45677: PUSH
45678: FOR_IN
45679: IFFALSE 45773
// if GetDistUnitXY ( j , x , y ) < 30 then
45681: LD_VAR 0 8
45685: PPUSH
45686: LD_VAR 0 2
45690: PPUSH
45691: LD_VAR 0 3
45695: PPUSH
45696: CALL_OW 297
45700: PUSH
45701: LD_INT 30
45703: LESS
45704: IFFALSE 45771
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
45706: LD_ADDR_EXP 66
45710: PUSH
45711: LD_EXP 66
45715: PPUSH
45716: LD_VAR 0 7
45720: PUSH
45721: LD_EXP 66
45725: PUSH
45726: LD_VAR 0 7
45730: ARRAY
45731: PUSH
45732: LD_INT 1
45734: PLUS
45735: PUSH
45736: EMPTY
45737: LIST
45738: LIST
45739: PPUSH
45740: LD_VAR 0 4
45744: PUSH
45745: LD_VAR 0 2
45749: PUSH
45750: LD_VAR 0 3
45754: PUSH
45755: EMPTY
45756: LIST
45757: LIST
45758: LIST
45759: PPUSH
45760: CALL 54034 0 3
45764: ST_TO_ADDR
// exit ;
45765: POP
45766: POP
45767: POP
45768: POP
45769: GO 45779
// end ;
45771: GO 45678
45773: POP
45774: POP
// end ;
45775: GO 45486
45777: POP
45778: POP
// end ;
45779: LD_VAR 0 6
45783: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
45784: LD_INT 0
45786: PPUSH
45787: PPUSH
45788: PPUSH
45789: PPUSH
// if not mc_bases or not skirmish then
45790: LD_EXP 50
45794: NOT
45795: PUSH
45796: LD_EXP 48
45800: NOT
45801: OR
45802: IFFALSE 45806
// exit ;
45804: GO 46083
// side := GetSide ( lab ) ;
45806: LD_ADDR_VAR 0 4
45810: PUSH
45811: LD_VAR 0 2
45815: PPUSH
45816: CALL_OW 255
45820: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
45821: LD_VAR 0 4
45825: PUSH
45826: LD_EXP 76
45830: IN
45831: NOT
45832: PUSH
45833: LD_EXP 77
45837: NOT
45838: OR
45839: PUSH
45840: LD_EXP 50
45844: NOT
45845: OR
45846: IFFALSE 45850
// exit ;
45848: GO 46083
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
45850: LD_ADDR_EXP 77
45854: PUSH
45855: LD_EXP 77
45859: PPUSH
45860: LD_VAR 0 4
45864: PPUSH
45865: LD_EXP 77
45869: PUSH
45870: LD_VAR 0 4
45874: ARRAY
45875: PUSH
45876: LD_VAR 0 1
45880: DIFF
45881: PPUSH
45882: CALL_OW 1
45886: ST_TO_ADDR
// for i = 1 to mc_bases do
45887: LD_ADDR_VAR 0 5
45891: PUSH
45892: DOUBLE
45893: LD_INT 1
45895: DEC
45896: ST_TO_ADDR
45897: LD_EXP 50
45901: PUSH
45902: FOR_TO
45903: IFFALSE 46081
// begin if lab in mc_bases [ i ] then
45905: LD_VAR 0 2
45909: PUSH
45910: LD_EXP 50
45914: PUSH
45915: LD_VAR 0 5
45919: ARRAY
45920: IN
45921: IFFALSE 46079
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
45923: LD_VAR 0 1
45927: PUSH
45928: LD_INT 11
45930: PUSH
45931: LD_INT 4
45933: PUSH
45934: LD_INT 3
45936: PUSH
45937: LD_INT 2
45939: PUSH
45940: EMPTY
45941: LIST
45942: LIST
45943: LIST
45944: LIST
45945: IN
45946: PUSH
45947: LD_EXP 80
45951: PUSH
45952: LD_VAR 0 5
45956: ARRAY
45957: AND
45958: IFFALSE 46079
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
45960: LD_ADDR_VAR 0 6
45964: PUSH
45965: LD_EXP 80
45969: PUSH
45970: LD_VAR 0 5
45974: ARRAY
45975: PUSH
45976: LD_INT 1
45978: ARRAY
45979: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
45980: LD_ADDR_EXP 80
45984: PUSH
45985: LD_EXP 80
45989: PPUSH
45990: LD_VAR 0 5
45994: PPUSH
45995: EMPTY
45996: PPUSH
45997: CALL_OW 1
46001: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
46002: LD_VAR 0 6
46006: PPUSH
46007: LD_INT 0
46009: PPUSH
46010: CALL_OW 109
// ComExitBuilding ( tmp ) ;
46014: LD_VAR 0 6
46018: PPUSH
46019: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
46023: LD_ADDR_EXP 79
46027: PUSH
46028: LD_EXP 79
46032: PPUSH
46033: LD_VAR 0 5
46037: PPUSH
46038: LD_EXP 79
46042: PUSH
46043: LD_VAR 0 5
46047: ARRAY
46048: PPUSH
46049: LD_INT 1
46051: PPUSH
46052: LD_VAR 0 6
46056: PPUSH
46057: CALL_OW 2
46061: PPUSH
46062: CALL_OW 1
46066: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
46067: LD_VAR 0 5
46071: PPUSH
46072: LD_INT 112
46074: PPUSH
46075: CALL 22547 0 2
// end ; end ; end ;
46079: GO 45902
46081: POP
46082: POP
// end ;
46083: LD_VAR 0 3
46087: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
46088: LD_INT 0
46090: PPUSH
46091: PPUSH
46092: PPUSH
46093: PPUSH
46094: PPUSH
46095: PPUSH
46096: PPUSH
46097: PPUSH
// if not mc_bases or not skirmish then
46098: LD_EXP 50
46102: NOT
46103: PUSH
46104: LD_EXP 48
46108: NOT
46109: OR
46110: IFFALSE 46114
// exit ;
46112: GO 47483
// for i = 1 to mc_bases do
46114: LD_ADDR_VAR 0 3
46118: PUSH
46119: DOUBLE
46120: LD_INT 1
46122: DEC
46123: ST_TO_ADDR
46124: LD_EXP 50
46128: PUSH
46129: FOR_TO
46130: IFFALSE 47481
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
46132: LD_VAR 0 1
46136: PUSH
46137: LD_EXP 50
46141: PUSH
46142: LD_VAR 0 3
46146: ARRAY
46147: IN
46148: PUSH
46149: LD_VAR 0 1
46153: PUSH
46154: LD_EXP 57
46158: PUSH
46159: LD_VAR 0 3
46163: ARRAY
46164: IN
46165: OR
46166: PUSH
46167: LD_VAR 0 1
46171: PUSH
46172: LD_EXP 72
46176: PUSH
46177: LD_VAR 0 3
46181: ARRAY
46182: IN
46183: OR
46184: PUSH
46185: LD_VAR 0 1
46189: PUSH
46190: LD_EXP 69
46194: PUSH
46195: LD_VAR 0 3
46199: ARRAY
46200: IN
46201: OR
46202: PUSH
46203: LD_VAR 0 1
46207: PUSH
46208: LD_EXP 79
46212: PUSH
46213: LD_VAR 0 3
46217: ARRAY
46218: IN
46219: OR
46220: PUSH
46221: LD_VAR 0 1
46225: PUSH
46226: LD_EXP 80
46230: PUSH
46231: LD_VAR 0 3
46235: ARRAY
46236: IN
46237: OR
46238: IFFALSE 47479
// begin if un in mc_ape [ i ] then
46240: LD_VAR 0 1
46244: PUSH
46245: LD_EXP 79
46249: PUSH
46250: LD_VAR 0 3
46254: ARRAY
46255: IN
46256: IFFALSE 46295
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
46258: LD_ADDR_EXP 79
46262: PUSH
46263: LD_EXP 79
46267: PPUSH
46268: LD_VAR 0 3
46272: PPUSH
46273: LD_EXP 79
46277: PUSH
46278: LD_VAR 0 3
46282: ARRAY
46283: PUSH
46284: LD_VAR 0 1
46288: DIFF
46289: PPUSH
46290: CALL_OW 1
46294: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
46295: LD_VAR 0 1
46299: PUSH
46300: LD_EXP 80
46304: PUSH
46305: LD_VAR 0 3
46309: ARRAY
46310: IN
46311: IFFALSE 46335
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
46313: LD_ADDR_EXP 80
46317: PUSH
46318: LD_EXP 80
46322: PPUSH
46323: LD_VAR 0 3
46327: PPUSH
46328: EMPTY
46329: PPUSH
46330: CALL_OW 1
46334: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
46335: LD_VAR 0 1
46339: PPUSH
46340: CALL_OW 247
46344: PUSH
46345: LD_INT 2
46347: EQUAL
46348: PUSH
46349: LD_VAR 0 1
46353: PPUSH
46354: CALL_OW 110
46358: PUSH
46359: LD_INT 20
46361: EQUAL
46362: PUSH
46363: LD_VAR 0 1
46367: PUSH
46368: LD_EXP 72
46372: PUSH
46373: LD_VAR 0 3
46377: ARRAY
46378: IN
46379: OR
46380: PUSH
46381: LD_VAR 0 1
46385: PPUSH
46386: CALL_OW 264
46390: PUSH
46391: LD_INT 12
46393: PUSH
46394: LD_INT 51
46396: PUSH
46397: LD_INT 89
46399: PUSH
46400: LD_INT 32
46402: PUSH
46403: LD_INT 13
46405: PUSH
46406: LD_INT 52
46408: PUSH
46409: LD_INT 31
46411: PUSH
46412: EMPTY
46413: LIST
46414: LIST
46415: LIST
46416: LIST
46417: LIST
46418: LIST
46419: LIST
46420: IN
46421: OR
46422: AND
46423: IFFALSE 46731
// begin if un in mc_defender [ i ] then
46425: LD_VAR 0 1
46429: PUSH
46430: LD_EXP 72
46434: PUSH
46435: LD_VAR 0 3
46439: ARRAY
46440: IN
46441: IFFALSE 46480
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
46443: LD_ADDR_EXP 72
46447: PUSH
46448: LD_EXP 72
46452: PPUSH
46453: LD_VAR 0 3
46457: PPUSH
46458: LD_EXP 72
46462: PUSH
46463: LD_VAR 0 3
46467: ARRAY
46468: PUSH
46469: LD_VAR 0 1
46473: DIFF
46474: PPUSH
46475: CALL_OW 1
46479: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
46480: LD_ADDR_VAR 0 8
46484: PUSH
46485: LD_VAR 0 3
46489: PPUSH
46490: LD_INT 3
46492: PPUSH
46493: CALL 43101 0 2
46497: ST_TO_ADDR
// if fac then
46498: LD_VAR 0 8
46502: IFFALSE 46731
// begin for j in fac do
46504: LD_ADDR_VAR 0 4
46508: PUSH
46509: LD_VAR 0 8
46513: PUSH
46514: FOR_IN
46515: IFFALSE 46729
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
46517: LD_ADDR_VAR 0 9
46521: PUSH
46522: LD_VAR 0 8
46526: PPUSH
46527: LD_VAR 0 1
46531: PPUSH
46532: CALL_OW 265
46536: PPUSH
46537: LD_VAR 0 1
46541: PPUSH
46542: CALL_OW 262
46546: PPUSH
46547: LD_VAR 0 1
46551: PPUSH
46552: CALL_OW 263
46556: PPUSH
46557: LD_VAR 0 1
46561: PPUSH
46562: CALL_OW 264
46566: PPUSH
46567: CALL 51532 0 5
46571: ST_TO_ADDR
// if components then
46572: LD_VAR 0 9
46576: IFFALSE 46727
// begin if GetWeapon ( un ) = ar_control_tower then
46578: LD_VAR 0 1
46582: PPUSH
46583: CALL_OW 264
46587: PUSH
46588: LD_INT 31
46590: EQUAL
46591: IFFALSE 46708
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
46593: LD_VAR 0 1
46597: PPUSH
46598: CALL_OW 311
46602: PPUSH
46603: LD_INT 0
46605: PPUSH
46606: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
46610: LD_ADDR_EXP 90
46614: PUSH
46615: LD_EXP 90
46619: PPUSH
46620: LD_VAR 0 3
46624: PPUSH
46625: LD_EXP 90
46629: PUSH
46630: LD_VAR 0 3
46634: ARRAY
46635: PUSH
46636: LD_VAR 0 1
46640: PPUSH
46641: CALL_OW 311
46645: DIFF
46646: PPUSH
46647: CALL_OW 1
46651: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
46652: LD_ADDR_VAR 0 7
46656: PUSH
46657: LD_EXP 71
46661: PUSH
46662: LD_VAR 0 3
46666: ARRAY
46667: PPUSH
46668: LD_INT 1
46670: PPUSH
46671: LD_VAR 0 9
46675: PPUSH
46676: CALL_OW 2
46680: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
46681: LD_ADDR_EXP 71
46685: PUSH
46686: LD_EXP 71
46690: PPUSH
46691: LD_VAR 0 3
46695: PPUSH
46696: LD_VAR 0 7
46700: PPUSH
46701: CALL_OW 1
46705: ST_TO_ADDR
// end else
46706: GO 46725
// MC_InsertProduceList ( i , [ components ] ) ;
46708: LD_VAR 0 3
46712: PPUSH
46713: LD_VAR 0 9
46717: PUSH
46718: EMPTY
46719: LIST
46720: PPUSH
46721: CALL 42646 0 2
// break ;
46725: GO 46729
// end ; end ;
46727: GO 46514
46729: POP
46730: POP
// end ; end ; if GetType ( un ) = unit_building then
46731: LD_VAR 0 1
46735: PPUSH
46736: CALL_OW 247
46740: PUSH
46741: LD_INT 3
46743: EQUAL
46744: IFFALSE 47147
// begin btype := GetBType ( un ) ;
46746: LD_ADDR_VAR 0 5
46750: PUSH
46751: LD_VAR 0 1
46755: PPUSH
46756: CALL_OW 266
46760: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
46761: LD_VAR 0 5
46765: PUSH
46766: LD_INT 29
46768: PUSH
46769: LD_INT 30
46771: PUSH
46772: EMPTY
46773: LIST
46774: LIST
46775: IN
46776: IFFALSE 46849
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
46778: LD_VAR 0 1
46782: PPUSH
46783: CALL_OW 250
46787: PPUSH
46788: LD_VAR 0 1
46792: PPUSH
46793: CALL_OW 251
46797: PPUSH
46798: LD_VAR 0 1
46802: PPUSH
46803: CALL_OW 255
46807: PPUSH
46808: CALL_OW 440
46812: NOT
46813: IFFALSE 46849
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
46815: LD_VAR 0 1
46819: PPUSH
46820: CALL_OW 250
46824: PPUSH
46825: LD_VAR 0 1
46829: PPUSH
46830: CALL_OW 251
46834: PPUSH
46835: LD_VAR 0 1
46839: PPUSH
46840: CALL_OW 255
46844: PPUSH
46845: CALL_OW 441
// end ; if btype = b_warehouse then
46849: LD_VAR 0 5
46853: PUSH
46854: LD_INT 1
46856: EQUAL
46857: IFFALSE 46875
// begin btype := b_depot ;
46859: LD_ADDR_VAR 0 5
46863: PUSH
46864: LD_INT 0
46866: ST_TO_ADDR
// pos := 1 ;
46867: LD_ADDR_VAR 0 6
46871: PUSH
46872: LD_INT 1
46874: ST_TO_ADDR
// end ; if btype = b_factory then
46875: LD_VAR 0 5
46879: PUSH
46880: LD_INT 3
46882: EQUAL
46883: IFFALSE 46901
// begin btype := b_workshop ;
46885: LD_ADDR_VAR 0 5
46889: PUSH
46890: LD_INT 2
46892: ST_TO_ADDR
// pos := 1 ;
46893: LD_ADDR_VAR 0 6
46897: PUSH
46898: LD_INT 1
46900: ST_TO_ADDR
// end ; if btype = b_barracks then
46901: LD_VAR 0 5
46905: PUSH
46906: LD_INT 5
46908: EQUAL
46909: IFFALSE 46919
// btype := b_armoury ;
46911: LD_ADDR_VAR 0 5
46915: PUSH
46916: LD_INT 4
46918: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
46919: LD_VAR 0 5
46923: PUSH
46924: LD_INT 7
46926: PUSH
46927: LD_INT 8
46929: PUSH
46930: EMPTY
46931: LIST
46932: LIST
46933: IN
46934: IFFALSE 46944
// btype := b_lab ;
46936: LD_ADDR_VAR 0 5
46940: PUSH
46941: LD_INT 6
46943: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
46944: LD_ADDR_EXP 55
46948: PUSH
46949: LD_EXP 55
46953: PPUSH
46954: LD_VAR 0 3
46958: PUSH
46959: LD_EXP 55
46963: PUSH
46964: LD_VAR 0 3
46968: ARRAY
46969: PUSH
46970: LD_INT 1
46972: PLUS
46973: PUSH
46974: EMPTY
46975: LIST
46976: LIST
46977: PPUSH
46978: LD_VAR 0 5
46982: PUSH
46983: LD_VAR 0 1
46987: PPUSH
46988: CALL_OW 250
46992: PUSH
46993: LD_VAR 0 1
46997: PPUSH
46998: CALL_OW 251
47002: PUSH
47003: LD_VAR 0 1
47007: PPUSH
47008: CALL_OW 254
47012: PUSH
47013: EMPTY
47014: LIST
47015: LIST
47016: LIST
47017: LIST
47018: PPUSH
47019: CALL 54034 0 3
47023: ST_TO_ADDR
// if pos = 1 then
47024: LD_VAR 0 6
47028: PUSH
47029: LD_INT 1
47031: EQUAL
47032: IFFALSE 47147
// begin tmp := mc_build_list [ i ] ;
47034: LD_ADDR_VAR 0 7
47038: PUSH
47039: LD_EXP 55
47043: PUSH
47044: LD_VAR 0 3
47048: ARRAY
47049: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
47050: LD_VAR 0 7
47054: PPUSH
47055: LD_INT 2
47057: PUSH
47058: LD_INT 30
47060: PUSH
47061: LD_INT 0
47063: PUSH
47064: EMPTY
47065: LIST
47066: LIST
47067: PUSH
47068: LD_INT 30
47070: PUSH
47071: LD_INT 1
47073: PUSH
47074: EMPTY
47075: LIST
47076: LIST
47077: PUSH
47078: EMPTY
47079: LIST
47080: LIST
47081: LIST
47082: PPUSH
47083: CALL_OW 72
47087: IFFALSE 47097
// pos := 2 ;
47089: LD_ADDR_VAR 0 6
47093: PUSH
47094: LD_INT 2
47096: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
47097: LD_ADDR_VAR 0 7
47101: PUSH
47102: LD_VAR 0 7
47106: PPUSH
47107: LD_VAR 0 6
47111: PPUSH
47112: LD_VAR 0 7
47116: PPUSH
47117: CALL 54360 0 3
47121: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
47122: LD_ADDR_EXP 55
47126: PUSH
47127: LD_EXP 55
47131: PPUSH
47132: LD_VAR 0 3
47136: PPUSH
47137: LD_VAR 0 7
47141: PPUSH
47142: CALL_OW 1
47146: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
47147: LD_VAR 0 1
47151: PUSH
47152: LD_EXP 50
47156: PUSH
47157: LD_VAR 0 3
47161: ARRAY
47162: IN
47163: IFFALSE 47202
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
47165: LD_ADDR_EXP 50
47169: PUSH
47170: LD_EXP 50
47174: PPUSH
47175: LD_VAR 0 3
47179: PPUSH
47180: LD_EXP 50
47184: PUSH
47185: LD_VAR 0 3
47189: ARRAY
47190: PUSH
47191: LD_VAR 0 1
47195: DIFF
47196: PPUSH
47197: CALL_OW 1
47201: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
47202: LD_VAR 0 1
47206: PUSH
47207: LD_EXP 57
47211: PUSH
47212: LD_VAR 0 3
47216: ARRAY
47217: IN
47218: IFFALSE 47257
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
47220: LD_ADDR_EXP 57
47224: PUSH
47225: LD_EXP 57
47229: PPUSH
47230: LD_VAR 0 3
47234: PPUSH
47235: LD_EXP 57
47239: PUSH
47240: LD_VAR 0 3
47244: ARRAY
47245: PUSH
47246: LD_VAR 0 1
47250: DIFF
47251: PPUSH
47252: CALL_OW 1
47256: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
47257: LD_VAR 0 1
47261: PUSH
47262: LD_EXP 69
47266: PUSH
47267: LD_VAR 0 3
47271: ARRAY
47272: IN
47273: IFFALSE 47312
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
47275: LD_ADDR_EXP 69
47279: PUSH
47280: LD_EXP 69
47284: PPUSH
47285: LD_VAR 0 3
47289: PPUSH
47290: LD_EXP 69
47294: PUSH
47295: LD_VAR 0 3
47299: ARRAY
47300: PUSH
47301: LD_VAR 0 1
47305: DIFF
47306: PPUSH
47307: CALL_OW 1
47311: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
47312: LD_VAR 0 1
47316: PUSH
47317: LD_EXP 72
47321: PUSH
47322: LD_VAR 0 3
47326: ARRAY
47327: IN
47328: IFFALSE 47367
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
47330: LD_ADDR_EXP 72
47334: PUSH
47335: LD_EXP 72
47339: PPUSH
47340: LD_VAR 0 3
47344: PPUSH
47345: LD_EXP 72
47349: PUSH
47350: LD_VAR 0 3
47354: ARRAY
47355: PUSH
47356: LD_VAR 0 1
47360: DIFF
47361: PPUSH
47362: CALL_OW 1
47366: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
47367: LD_VAR 0 1
47371: PUSH
47372: LD_EXP 59
47376: PUSH
47377: LD_VAR 0 3
47381: ARRAY
47382: IN
47383: IFFALSE 47422
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
47385: LD_ADDR_EXP 59
47389: PUSH
47390: LD_EXP 59
47394: PPUSH
47395: LD_VAR 0 3
47399: PPUSH
47400: LD_EXP 59
47404: PUSH
47405: LD_VAR 0 3
47409: ARRAY
47410: PUSH
47411: LD_VAR 0 1
47415: DIFF
47416: PPUSH
47417: CALL_OW 1
47421: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
47422: LD_VAR 0 1
47426: PUSH
47427: LD_EXP 58
47431: PUSH
47432: LD_VAR 0 3
47436: ARRAY
47437: IN
47438: IFFALSE 47477
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
47440: LD_ADDR_EXP 58
47444: PUSH
47445: LD_EXP 58
47449: PPUSH
47450: LD_VAR 0 3
47454: PPUSH
47455: LD_EXP 58
47459: PUSH
47460: LD_VAR 0 3
47464: ARRAY
47465: PUSH
47466: LD_VAR 0 1
47470: DIFF
47471: PPUSH
47472: CALL_OW 1
47476: ST_TO_ADDR
// end ; break ;
47477: GO 47481
// end ;
47479: GO 46129
47481: POP
47482: POP
// end ;
47483: LD_VAR 0 2
47487: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
47488: LD_INT 0
47490: PPUSH
47491: PPUSH
47492: PPUSH
// if not mc_bases or not skirmish then
47493: LD_EXP 50
47497: NOT
47498: PUSH
47499: LD_EXP 48
47503: NOT
47504: OR
47505: IFFALSE 47509
// exit ;
47507: GO 47724
// for i = 1 to mc_bases do
47509: LD_ADDR_VAR 0 3
47513: PUSH
47514: DOUBLE
47515: LD_INT 1
47517: DEC
47518: ST_TO_ADDR
47519: LD_EXP 50
47523: PUSH
47524: FOR_TO
47525: IFFALSE 47722
// begin if building in mc_construct_list [ i ] then
47527: LD_VAR 0 1
47531: PUSH
47532: LD_EXP 57
47536: PUSH
47537: LD_VAR 0 3
47541: ARRAY
47542: IN
47543: IFFALSE 47720
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
47545: LD_ADDR_EXP 57
47549: PUSH
47550: LD_EXP 57
47554: PPUSH
47555: LD_VAR 0 3
47559: PPUSH
47560: LD_EXP 57
47564: PUSH
47565: LD_VAR 0 3
47569: ARRAY
47570: PUSH
47571: LD_VAR 0 1
47575: DIFF
47576: PPUSH
47577: CALL_OW 1
47581: ST_TO_ADDR
// if building in mc_lab [ i ] then
47582: LD_VAR 0 1
47586: PUSH
47587: LD_EXP 83
47591: PUSH
47592: LD_VAR 0 3
47596: ARRAY
47597: IN
47598: IFFALSE 47653
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
47600: LD_ADDR_EXP 84
47604: PUSH
47605: LD_EXP 84
47609: PPUSH
47610: LD_VAR 0 3
47614: PPUSH
47615: LD_EXP 84
47619: PUSH
47620: LD_VAR 0 3
47624: ARRAY
47625: PPUSH
47626: LD_INT 1
47628: PPUSH
47629: LD_EXP 84
47633: PUSH
47634: LD_VAR 0 3
47638: ARRAY
47639: PPUSH
47640: LD_INT 0
47642: PPUSH
47643: CALL 53452 0 4
47647: PPUSH
47648: CALL_OW 1
47652: ST_TO_ADDR
// if not building in mc_bases [ i ] then
47653: LD_VAR 0 1
47657: PUSH
47658: LD_EXP 50
47662: PUSH
47663: LD_VAR 0 3
47667: ARRAY
47668: IN
47669: NOT
47670: IFFALSE 47716
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
47672: LD_ADDR_EXP 50
47676: PUSH
47677: LD_EXP 50
47681: PPUSH
47682: LD_VAR 0 3
47686: PUSH
47687: LD_EXP 50
47691: PUSH
47692: LD_VAR 0 3
47696: ARRAY
47697: PUSH
47698: LD_INT 1
47700: PLUS
47701: PUSH
47702: EMPTY
47703: LIST
47704: LIST
47705: PPUSH
47706: LD_VAR 0 1
47710: PPUSH
47711: CALL 54034 0 3
47715: ST_TO_ADDR
// exit ;
47716: POP
47717: POP
47718: GO 47724
// end ; end ;
47720: GO 47524
47722: POP
47723: POP
// end ;
47724: LD_VAR 0 2
47728: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
47729: LD_INT 0
47731: PPUSH
47732: PPUSH
47733: PPUSH
47734: PPUSH
47735: PPUSH
47736: PPUSH
47737: PPUSH
// if not mc_bases or not skirmish then
47738: LD_EXP 50
47742: NOT
47743: PUSH
47744: LD_EXP 48
47748: NOT
47749: OR
47750: IFFALSE 47754
// exit ;
47752: GO 48415
// for i = 1 to mc_bases do
47754: LD_ADDR_VAR 0 3
47758: PUSH
47759: DOUBLE
47760: LD_INT 1
47762: DEC
47763: ST_TO_ADDR
47764: LD_EXP 50
47768: PUSH
47769: FOR_TO
47770: IFFALSE 48413
// begin if building in mc_construct_list [ i ] then
47772: LD_VAR 0 1
47776: PUSH
47777: LD_EXP 57
47781: PUSH
47782: LD_VAR 0 3
47786: ARRAY
47787: IN
47788: IFFALSE 48411
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
47790: LD_ADDR_EXP 57
47794: PUSH
47795: LD_EXP 57
47799: PPUSH
47800: LD_VAR 0 3
47804: PPUSH
47805: LD_EXP 57
47809: PUSH
47810: LD_VAR 0 3
47814: ARRAY
47815: PUSH
47816: LD_VAR 0 1
47820: DIFF
47821: PPUSH
47822: CALL_OW 1
47826: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
47827: LD_ADDR_EXP 50
47831: PUSH
47832: LD_EXP 50
47836: PPUSH
47837: LD_VAR 0 3
47841: PUSH
47842: LD_EXP 50
47846: PUSH
47847: LD_VAR 0 3
47851: ARRAY
47852: PUSH
47853: LD_INT 1
47855: PLUS
47856: PUSH
47857: EMPTY
47858: LIST
47859: LIST
47860: PPUSH
47861: LD_VAR 0 1
47865: PPUSH
47866: CALL 54034 0 3
47870: ST_TO_ADDR
// btype := GetBType ( building ) ;
47871: LD_ADDR_VAR 0 5
47875: PUSH
47876: LD_VAR 0 1
47880: PPUSH
47881: CALL_OW 266
47885: ST_TO_ADDR
// side := GetSide ( building ) ;
47886: LD_ADDR_VAR 0 8
47890: PUSH
47891: LD_VAR 0 1
47895: PPUSH
47896: CALL_OW 255
47900: ST_TO_ADDR
// if btype = b_lab then
47901: LD_VAR 0 5
47905: PUSH
47906: LD_INT 6
47908: EQUAL
47909: IFFALSE 47959
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
47911: LD_ADDR_EXP 83
47915: PUSH
47916: LD_EXP 83
47920: PPUSH
47921: LD_VAR 0 3
47925: PUSH
47926: LD_EXP 83
47930: PUSH
47931: LD_VAR 0 3
47935: ARRAY
47936: PUSH
47937: LD_INT 1
47939: PLUS
47940: PUSH
47941: EMPTY
47942: LIST
47943: LIST
47944: PPUSH
47945: LD_VAR 0 1
47949: PPUSH
47950: CALL 54034 0 3
47954: ST_TO_ADDR
// exit ;
47955: POP
47956: POP
47957: GO 48415
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
47959: LD_VAR 0 5
47963: PUSH
47964: LD_INT 0
47966: PUSH
47967: LD_INT 2
47969: PUSH
47970: LD_INT 4
47972: PUSH
47973: EMPTY
47974: LIST
47975: LIST
47976: LIST
47977: IN
47978: IFFALSE 48102
// begin if btype = b_armoury then
47980: LD_VAR 0 5
47984: PUSH
47985: LD_INT 4
47987: EQUAL
47988: IFFALSE 47998
// btype := b_barracks ;
47990: LD_ADDR_VAR 0 5
47994: PUSH
47995: LD_INT 5
47997: ST_TO_ADDR
// if btype = b_depot then
47998: LD_VAR 0 5
48002: PUSH
48003: LD_INT 0
48005: EQUAL
48006: IFFALSE 48016
// btype := b_warehouse ;
48008: LD_ADDR_VAR 0 5
48012: PUSH
48013: LD_INT 1
48015: ST_TO_ADDR
// if btype = b_workshop then
48016: LD_VAR 0 5
48020: PUSH
48021: LD_INT 2
48023: EQUAL
48024: IFFALSE 48034
// btype := b_factory ;
48026: LD_ADDR_VAR 0 5
48030: PUSH
48031: LD_INT 3
48033: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
48034: LD_VAR 0 5
48038: PPUSH
48039: LD_VAR 0 8
48043: PPUSH
48044: CALL_OW 323
48048: PUSH
48049: LD_INT 1
48051: EQUAL
48052: IFFALSE 48098
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
48054: LD_ADDR_EXP 82
48058: PUSH
48059: LD_EXP 82
48063: PPUSH
48064: LD_VAR 0 3
48068: PUSH
48069: LD_EXP 82
48073: PUSH
48074: LD_VAR 0 3
48078: ARRAY
48079: PUSH
48080: LD_INT 1
48082: PLUS
48083: PUSH
48084: EMPTY
48085: LIST
48086: LIST
48087: PPUSH
48088: LD_VAR 0 1
48092: PPUSH
48093: CALL 54034 0 3
48097: ST_TO_ADDR
// exit ;
48098: POP
48099: POP
48100: GO 48415
// end ; if btype in [ b_bunker , b_turret ] then
48102: LD_VAR 0 5
48106: PUSH
48107: LD_INT 32
48109: PUSH
48110: LD_INT 33
48112: PUSH
48113: EMPTY
48114: LIST
48115: LIST
48116: IN
48117: IFFALSE 48407
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
48119: LD_ADDR_EXP 58
48123: PUSH
48124: LD_EXP 58
48128: PPUSH
48129: LD_VAR 0 3
48133: PUSH
48134: LD_EXP 58
48138: PUSH
48139: LD_VAR 0 3
48143: ARRAY
48144: PUSH
48145: LD_INT 1
48147: PLUS
48148: PUSH
48149: EMPTY
48150: LIST
48151: LIST
48152: PPUSH
48153: LD_VAR 0 1
48157: PPUSH
48158: CALL 54034 0 3
48162: ST_TO_ADDR
// if btype = b_bunker then
48163: LD_VAR 0 5
48167: PUSH
48168: LD_INT 32
48170: EQUAL
48171: IFFALSE 48407
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
48173: LD_ADDR_EXP 59
48177: PUSH
48178: LD_EXP 59
48182: PPUSH
48183: LD_VAR 0 3
48187: PUSH
48188: LD_EXP 59
48192: PUSH
48193: LD_VAR 0 3
48197: ARRAY
48198: PUSH
48199: LD_INT 1
48201: PLUS
48202: PUSH
48203: EMPTY
48204: LIST
48205: LIST
48206: PPUSH
48207: LD_VAR 0 1
48211: PPUSH
48212: CALL 54034 0 3
48216: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
48217: LD_ADDR_VAR 0 6
48221: PUSH
48222: LD_EXP 50
48226: PUSH
48227: LD_VAR 0 3
48231: ARRAY
48232: PPUSH
48233: LD_INT 25
48235: PUSH
48236: LD_INT 1
48238: PUSH
48239: EMPTY
48240: LIST
48241: LIST
48242: PUSH
48243: LD_INT 3
48245: PUSH
48246: LD_INT 54
48248: PUSH
48249: EMPTY
48250: LIST
48251: PUSH
48252: EMPTY
48253: LIST
48254: LIST
48255: PUSH
48256: EMPTY
48257: LIST
48258: LIST
48259: PPUSH
48260: CALL_OW 72
48264: ST_TO_ADDR
// if tmp then
48265: LD_VAR 0 6
48269: IFFALSE 48275
// exit ;
48271: POP
48272: POP
48273: GO 48415
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
48275: LD_ADDR_VAR 0 6
48279: PUSH
48280: LD_EXP 50
48284: PUSH
48285: LD_VAR 0 3
48289: ARRAY
48290: PPUSH
48291: LD_INT 2
48293: PUSH
48294: LD_INT 30
48296: PUSH
48297: LD_INT 4
48299: PUSH
48300: EMPTY
48301: LIST
48302: LIST
48303: PUSH
48304: LD_INT 30
48306: PUSH
48307: LD_INT 5
48309: PUSH
48310: EMPTY
48311: LIST
48312: LIST
48313: PUSH
48314: EMPTY
48315: LIST
48316: LIST
48317: LIST
48318: PPUSH
48319: CALL_OW 72
48323: ST_TO_ADDR
// if not tmp then
48324: LD_VAR 0 6
48328: NOT
48329: IFFALSE 48335
// exit ;
48331: POP
48332: POP
48333: GO 48415
// for j in tmp do
48335: LD_ADDR_VAR 0 4
48339: PUSH
48340: LD_VAR 0 6
48344: PUSH
48345: FOR_IN
48346: IFFALSE 48405
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
48348: LD_ADDR_VAR 0 7
48352: PUSH
48353: LD_VAR 0 4
48357: PPUSH
48358: CALL_OW 313
48362: PPUSH
48363: LD_INT 25
48365: PUSH
48366: LD_INT 1
48368: PUSH
48369: EMPTY
48370: LIST
48371: LIST
48372: PPUSH
48373: CALL_OW 72
48377: ST_TO_ADDR
// if units then
48378: LD_VAR 0 7
48382: IFFALSE 48403
// begin ComExitBuilding ( units [ 1 ] ) ;
48384: LD_VAR 0 7
48388: PUSH
48389: LD_INT 1
48391: ARRAY
48392: PPUSH
48393: CALL_OW 122
// exit ;
48397: POP
48398: POP
48399: POP
48400: POP
48401: GO 48415
// end ; end ;
48403: GO 48345
48405: POP
48406: POP
// end ; end ; exit ;
48407: POP
48408: POP
48409: GO 48415
// end ; end ;
48411: GO 47769
48413: POP
48414: POP
// end ;
48415: LD_VAR 0 2
48419: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
48420: LD_INT 0
48422: PPUSH
48423: PPUSH
48424: PPUSH
48425: PPUSH
48426: PPUSH
48427: PPUSH
48428: PPUSH
// if not mc_bases or not skirmish then
48429: LD_EXP 50
48433: NOT
48434: PUSH
48435: LD_EXP 48
48439: NOT
48440: OR
48441: IFFALSE 48445
// exit ;
48443: GO 48710
// btype := GetBType ( building ) ;
48445: LD_ADDR_VAR 0 6
48449: PUSH
48450: LD_VAR 0 1
48454: PPUSH
48455: CALL_OW 266
48459: ST_TO_ADDR
// x := GetX ( building ) ;
48460: LD_ADDR_VAR 0 7
48464: PUSH
48465: LD_VAR 0 1
48469: PPUSH
48470: CALL_OW 250
48474: ST_TO_ADDR
// y := GetY ( building ) ;
48475: LD_ADDR_VAR 0 8
48479: PUSH
48480: LD_VAR 0 1
48484: PPUSH
48485: CALL_OW 251
48489: ST_TO_ADDR
// d := GetDir ( building ) ;
48490: LD_ADDR_VAR 0 9
48494: PUSH
48495: LD_VAR 0 1
48499: PPUSH
48500: CALL_OW 254
48504: ST_TO_ADDR
// for i = 1 to mc_bases do
48505: LD_ADDR_VAR 0 4
48509: PUSH
48510: DOUBLE
48511: LD_INT 1
48513: DEC
48514: ST_TO_ADDR
48515: LD_EXP 50
48519: PUSH
48520: FOR_TO
48521: IFFALSE 48708
// begin if not mc_build_list [ i ] then
48523: LD_EXP 55
48527: PUSH
48528: LD_VAR 0 4
48532: ARRAY
48533: NOT
48534: IFFALSE 48538
// continue ;
48536: GO 48520
// for j := 1 to mc_build_list [ i ] do
48538: LD_ADDR_VAR 0 5
48542: PUSH
48543: DOUBLE
48544: LD_INT 1
48546: DEC
48547: ST_TO_ADDR
48548: LD_EXP 55
48552: PUSH
48553: LD_VAR 0 4
48557: ARRAY
48558: PUSH
48559: FOR_TO
48560: IFFALSE 48704
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
48562: LD_VAR 0 6
48566: PUSH
48567: LD_VAR 0 7
48571: PUSH
48572: LD_VAR 0 8
48576: PUSH
48577: LD_VAR 0 9
48581: PUSH
48582: EMPTY
48583: LIST
48584: LIST
48585: LIST
48586: LIST
48587: PPUSH
48588: LD_EXP 55
48592: PUSH
48593: LD_VAR 0 4
48597: ARRAY
48598: PUSH
48599: LD_VAR 0 5
48603: ARRAY
48604: PPUSH
48605: CALL 60214 0 2
48609: IFFALSE 48702
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
48611: LD_ADDR_EXP 55
48615: PUSH
48616: LD_EXP 55
48620: PPUSH
48621: LD_VAR 0 4
48625: PPUSH
48626: LD_EXP 55
48630: PUSH
48631: LD_VAR 0 4
48635: ARRAY
48636: PPUSH
48637: LD_VAR 0 5
48641: PPUSH
48642: CALL_OW 3
48646: PPUSH
48647: CALL_OW 1
48651: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
48652: LD_ADDR_EXP 57
48656: PUSH
48657: LD_EXP 57
48661: PPUSH
48662: LD_VAR 0 4
48666: PUSH
48667: LD_EXP 57
48671: PUSH
48672: LD_VAR 0 4
48676: ARRAY
48677: PUSH
48678: LD_INT 1
48680: PLUS
48681: PUSH
48682: EMPTY
48683: LIST
48684: LIST
48685: PPUSH
48686: LD_VAR 0 1
48690: PPUSH
48691: CALL 54034 0 3
48695: ST_TO_ADDR
// exit ;
48696: POP
48697: POP
48698: POP
48699: POP
48700: GO 48710
// end ;
48702: GO 48559
48704: POP
48705: POP
// end ;
48706: GO 48520
48708: POP
48709: POP
// end ;
48710: LD_VAR 0 3
48714: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
48715: LD_INT 0
48717: PPUSH
48718: PPUSH
48719: PPUSH
// if not mc_bases or not skirmish then
48720: LD_EXP 50
48724: NOT
48725: PUSH
48726: LD_EXP 48
48730: NOT
48731: OR
48732: IFFALSE 48736
// exit ;
48734: GO 48926
// for i = 1 to mc_bases do
48736: LD_ADDR_VAR 0 4
48740: PUSH
48741: DOUBLE
48742: LD_INT 1
48744: DEC
48745: ST_TO_ADDR
48746: LD_EXP 50
48750: PUSH
48751: FOR_TO
48752: IFFALSE 48839
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
48754: LD_VAR 0 1
48758: PUSH
48759: LD_EXP 58
48763: PUSH
48764: LD_VAR 0 4
48768: ARRAY
48769: IN
48770: PUSH
48771: LD_VAR 0 1
48775: PUSH
48776: LD_EXP 59
48780: PUSH
48781: LD_VAR 0 4
48785: ARRAY
48786: IN
48787: NOT
48788: AND
48789: IFFALSE 48837
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
48791: LD_ADDR_EXP 59
48795: PUSH
48796: LD_EXP 59
48800: PPUSH
48801: LD_VAR 0 4
48805: PUSH
48806: LD_EXP 59
48810: PUSH
48811: LD_VAR 0 4
48815: ARRAY
48816: PUSH
48817: LD_INT 1
48819: PLUS
48820: PUSH
48821: EMPTY
48822: LIST
48823: LIST
48824: PPUSH
48825: LD_VAR 0 1
48829: PPUSH
48830: CALL 54034 0 3
48834: ST_TO_ADDR
// break ;
48835: GO 48839
// end ; end ;
48837: GO 48751
48839: POP
48840: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
48841: LD_VAR 0 1
48845: PPUSH
48846: CALL_OW 257
48850: PUSH
48851: LD_EXP 76
48855: IN
48856: PUSH
48857: LD_VAR 0 1
48861: PPUSH
48862: CALL_OW 266
48866: PUSH
48867: LD_INT 5
48869: EQUAL
48870: AND
48871: PUSH
48872: LD_VAR 0 2
48876: PPUSH
48877: CALL_OW 110
48881: PUSH
48882: LD_INT 18
48884: NONEQUAL
48885: AND
48886: IFFALSE 48926
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
48888: LD_VAR 0 2
48892: PPUSH
48893: CALL_OW 257
48897: PUSH
48898: LD_INT 5
48900: PUSH
48901: LD_INT 8
48903: PUSH
48904: LD_INT 9
48906: PUSH
48907: EMPTY
48908: LIST
48909: LIST
48910: LIST
48911: IN
48912: IFFALSE 48926
// SetClass ( unit , 1 ) ;
48914: LD_VAR 0 2
48918: PPUSH
48919: LD_INT 1
48921: PPUSH
48922: CALL_OW 336
// end ;
48926: LD_VAR 0 3
48930: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
48931: LD_INT 0
48933: PPUSH
48934: PPUSH
// if not mc_bases or not skirmish then
48935: LD_EXP 50
48939: NOT
48940: PUSH
48941: LD_EXP 48
48945: NOT
48946: OR
48947: IFFALSE 48951
// exit ;
48949: GO 49067
// if GetLives ( abandoned_vehicle ) > 250 then
48951: LD_VAR 0 2
48955: PPUSH
48956: CALL_OW 256
48960: PUSH
48961: LD_INT 250
48963: GREATER
48964: IFFALSE 48968
// exit ;
48966: GO 49067
// for i = 1 to mc_bases do
48968: LD_ADDR_VAR 0 6
48972: PUSH
48973: DOUBLE
48974: LD_INT 1
48976: DEC
48977: ST_TO_ADDR
48978: LD_EXP 50
48982: PUSH
48983: FOR_TO
48984: IFFALSE 49065
// begin if driver in mc_bases [ i ] then
48986: LD_VAR 0 1
48990: PUSH
48991: LD_EXP 50
48995: PUSH
48996: LD_VAR 0 6
49000: ARRAY
49001: IN
49002: IFFALSE 49063
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
49004: LD_VAR 0 1
49008: PPUSH
49009: LD_EXP 50
49013: PUSH
49014: LD_VAR 0 6
49018: ARRAY
49019: PPUSH
49020: LD_INT 2
49022: PUSH
49023: LD_INT 30
49025: PUSH
49026: LD_INT 0
49028: PUSH
49029: EMPTY
49030: LIST
49031: LIST
49032: PUSH
49033: LD_INT 30
49035: PUSH
49036: LD_INT 1
49038: PUSH
49039: EMPTY
49040: LIST
49041: LIST
49042: PUSH
49043: EMPTY
49044: LIST
49045: LIST
49046: LIST
49047: PPUSH
49048: CALL_OW 72
49052: PUSH
49053: LD_INT 1
49055: ARRAY
49056: PPUSH
49057: CALL 87241 0 2
// break ;
49061: GO 49065
// end ; end ;
49063: GO 48983
49065: POP
49066: POP
// end ; end_of_file
49067: LD_VAR 0 5
49071: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
49072: LD_INT 0
49074: PPUSH
49075: PPUSH
// if exist_mode then
49076: LD_VAR 0 2
49080: IFFALSE 49105
// unit := CreateCharacter ( prefix & ident ) else
49082: LD_ADDR_VAR 0 5
49086: PUSH
49087: LD_VAR 0 3
49091: PUSH
49092: LD_VAR 0 1
49096: STR
49097: PPUSH
49098: CALL_OW 34
49102: ST_TO_ADDR
49103: GO 49120
// unit := NewCharacter ( ident ) ;
49105: LD_ADDR_VAR 0 5
49109: PUSH
49110: LD_VAR 0 1
49114: PPUSH
49115: CALL_OW 25
49119: ST_TO_ADDR
// result := unit ;
49120: LD_ADDR_VAR 0 4
49124: PUSH
49125: LD_VAR 0 5
49129: ST_TO_ADDR
// end ;
49130: LD_VAR 0 4
49134: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
49135: LD_INT 0
49137: PPUSH
49138: PPUSH
// if not side or not nation then
49139: LD_VAR 0 1
49143: NOT
49144: PUSH
49145: LD_VAR 0 2
49149: NOT
49150: OR
49151: IFFALSE 49155
// exit ;
49153: GO 49923
// case nation of nation_american :
49155: LD_VAR 0 2
49159: PUSH
49160: LD_INT 1
49162: DOUBLE
49163: EQUAL
49164: IFTRUE 49168
49166: GO 49382
49168: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
49169: LD_ADDR_VAR 0 4
49173: PUSH
49174: LD_INT 35
49176: PUSH
49177: LD_INT 45
49179: PUSH
49180: LD_INT 46
49182: PUSH
49183: LD_INT 47
49185: PUSH
49186: LD_INT 82
49188: PUSH
49189: LD_INT 83
49191: PUSH
49192: LD_INT 84
49194: PUSH
49195: LD_INT 85
49197: PUSH
49198: LD_INT 86
49200: PUSH
49201: LD_INT 1
49203: PUSH
49204: LD_INT 2
49206: PUSH
49207: LD_INT 6
49209: PUSH
49210: LD_INT 15
49212: PUSH
49213: LD_INT 16
49215: PUSH
49216: LD_INT 7
49218: PUSH
49219: LD_INT 12
49221: PUSH
49222: LD_INT 13
49224: PUSH
49225: LD_INT 10
49227: PUSH
49228: LD_INT 14
49230: PUSH
49231: LD_INT 20
49233: PUSH
49234: LD_INT 21
49236: PUSH
49237: LD_INT 22
49239: PUSH
49240: LD_INT 25
49242: PUSH
49243: LD_INT 32
49245: PUSH
49246: LD_INT 27
49248: PUSH
49249: LD_INT 36
49251: PUSH
49252: LD_INT 69
49254: PUSH
49255: LD_INT 39
49257: PUSH
49258: LD_INT 34
49260: PUSH
49261: LD_INT 40
49263: PUSH
49264: LD_INT 48
49266: PUSH
49267: LD_INT 49
49269: PUSH
49270: LD_INT 50
49272: PUSH
49273: LD_INT 51
49275: PUSH
49276: LD_INT 52
49278: PUSH
49279: LD_INT 53
49281: PUSH
49282: LD_INT 54
49284: PUSH
49285: LD_INT 55
49287: PUSH
49288: LD_INT 56
49290: PUSH
49291: LD_INT 57
49293: PUSH
49294: LD_INT 58
49296: PUSH
49297: LD_INT 59
49299: PUSH
49300: LD_INT 60
49302: PUSH
49303: LD_INT 61
49305: PUSH
49306: LD_INT 62
49308: PUSH
49309: LD_INT 80
49311: PUSH
49312: LD_INT 82
49314: PUSH
49315: LD_INT 83
49317: PUSH
49318: LD_INT 84
49320: PUSH
49321: LD_INT 85
49323: PUSH
49324: LD_INT 86
49326: PUSH
49327: EMPTY
49328: LIST
49329: LIST
49330: LIST
49331: LIST
49332: LIST
49333: LIST
49334: LIST
49335: LIST
49336: LIST
49337: LIST
49338: LIST
49339: LIST
49340: LIST
49341: LIST
49342: LIST
49343: LIST
49344: LIST
49345: LIST
49346: LIST
49347: LIST
49348: LIST
49349: LIST
49350: LIST
49351: LIST
49352: LIST
49353: LIST
49354: LIST
49355: LIST
49356: LIST
49357: LIST
49358: LIST
49359: LIST
49360: LIST
49361: LIST
49362: LIST
49363: LIST
49364: LIST
49365: LIST
49366: LIST
49367: LIST
49368: LIST
49369: LIST
49370: LIST
49371: LIST
49372: LIST
49373: LIST
49374: LIST
49375: LIST
49376: LIST
49377: LIST
49378: LIST
49379: ST_TO_ADDR
49380: GO 49847
49382: LD_INT 2
49384: DOUBLE
49385: EQUAL
49386: IFTRUE 49390
49388: GO 49616
49390: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
49391: LD_ADDR_VAR 0 4
49395: PUSH
49396: LD_INT 35
49398: PUSH
49399: LD_INT 45
49401: PUSH
49402: LD_INT 46
49404: PUSH
49405: LD_INT 47
49407: PUSH
49408: LD_INT 82
49410: PUSH
49411: LD_INT 83
49413: PUSH
49414: LD_INT 84
49416: PUSH
49417: LD_INT 85
49419: PUSH
49420: LD_INT 87
49422: PUSH
49423: LD_INT 70
49425: PUSH
49426: LD_INT 1
49428: PUSH
49429: LD_INT 11
49431: PUSH
49432: LD_INT 3
49434: PUSH
49435: LD_INT 4
49437: PUSH
49438: LD_INT 5
49440: PUSH
49441: LD_INT 6
49443: PUSH
49444: LD_INT 15
49446: PUSH
49447: LD_INT 18
49449: PUSH
49450: LD_INT 7
49452: PUSH
49453: LD_INT 17
49455: PUSH
49456: LD_INT 8
49458: PUSH
49459: LD_INT 20
49461: PUSH
49462: LD_INT 21
49464: PUSH
49465: LD_INT 22
49467: PUSH
49468: LD_INT 72
49470: PUSH
49471: LD_INT 26
49473: PUSH
49474: LD_INT 69
49476: PUSH
49477: LD_INT 39
49479: PUSH
49480: LD_INT 40
49482: PUSH
49483: LD_INT 41
49485: PUSH
49486: LD_INT 42
49488: PUSH
49489: LD_INT 43
49491: PUSH
49492: LD_INT 48
49494: PUSH
49495: LD_INT 49
49497: PUSH
49498: LD_INT 50
49500: PUSH
49501: LD_INT 51
49503: PUSH
49504: LD_INT 52
49506: PUSH
49507: LD_INT 53
49509: PUSH
49510: LD_INT 54
49512: PUSH
49513: LD_INT 55
49515: PUSH
49516: LD_INT 56
49518: PUSH
49519: LD_INT 60
49521: PUSH
49522: LD_INT 61
49524: PUSH
49525: LD_INT 62
49527: PUSH
49528: LD_INT 66
49530: PUSH
49531: LD_INT 67
49533: PUSH
49534: LD_INT 68
49536: PUSH
49537: LD_INT 81
49539: PUSH
49540: LD_INT 82
49542: PUSH
49543: LD_INT 83
49545: PUSH
49546: LD_INT 84
49548: PUSH
49549: LD_INT 85
49551: PUSH
49552: LD_INT 87
49554: PUSH
49555: LD_INT 88
49557: PUSH
49558: EMPTY
49559: LIST
49560: LIST
49561: LIST
49562: LIST
49563: LIST
49564: LIST
49565: LIST
49566: LIST
49567: LIST
49568: LIST
49569: LIST
49570: LIST
49571: LIST
49572: LIST
49573: LIST
49574: LIST
49575: LIST
49576: LIST
49577: LIST
49578: LIST
49579: LIST
49580: LIST
49581: LIST
49582: LIST
49583: LIST
49584: LIST
49585: LIST
49586: LIST
49587: LIST
49588: LIST
49589: LIST
49590: LIST
49591: LIST
49592: LIST
49593: LIST
49594: LIST
49595: LIST
49596: LIST
49597: LIST
49598: LIST
49599: LIST
49600: LIST
49601: LIST
49602: LIST
49603: LIST
49604: LIST
49605: LIST
49606: LIST
49607: LIST
49608: LIST
49609: LIST
49610: LIST
49611: LIST
49612: LIST
49613: ST_TO_ADDR
49614: GO 49847
49616: LD_INT 3
49618: DOUBLE
49619: EQUAL
49620: IFTRUE 49624
49622: GO 49846
49624: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
49625: LD_ADDR_VAR 0 4
49629: PUSH
49630: LD_INT 46
49632: PUSH
49633: LD_INT 47
49635: PUSH
49636: LD_INT 1
49638: PUSH
49639: LD_INT 2
49641: PUSH
49642: LD_INT 82
49644: PUSH
49645: LD_INT 83
49647: PUSH
49648: LD_INT 84
49650: PUSH
49651: LD_INT 85
49653: PUSH
49654: LD_INT 86
49656: PUSH
49657: LD_INT 11
49659: PUSH
49660: LD_INT 9
49662: PUSH
49663: LD_INT 20
49665: PUSH
49666: LD_INT 19
49668: PUSH
49669: LD_INT 21
49671: PUSH
49672: LD_INT 24
49674: PUSH
49675: LD_INT 22
49677: PUSH
49678: LD_INT 25
49680: PUSH
49681: LD_INT 28
49683: PUSH
49684: LD_INT 29
49686: PUSH
49687: LD_INT 30
49689: PUSH
49690: LD_INT 31
49692: PUSH
49693: LD_INT 37
49695: PUSH
49696: LD_INT 38
49698: PUSH
49699: LD_INT 32
49701: PUSH
49702: LD_INT 27
49704: PUSH
49705: LD_INT 33
49707: PUSH
49708: LD_INT 69
49710: PUSH
49711: LD_INT 39
49713: PUSH
49714: LD_INT 34
49716: PUSH
49717: LD_INT 40
49719: PUSH
49720: LD_INT 71
49722: PUSH
49723: LD_INT 23
49725: PUSH
49726: LD_INT 44
49728: PUSH
49729: LD_INT 48
49731: PUSH
49732: LD_INT 49
49734: PUSH
49735: LD_INT 50
49737: PUSH
49738: LD_INT 51
49740: PUSH
49741: LD_INT 52
49743: PUSH
49744: LD_INT 53
49746: PUSH
49747: LD_INT 54
49749: PUSH
49750: LD_INT 55
49752: PUSH
49753: LD_INT 56
49755: PUSH
49756: LD_INT 57
49758: PUSH
49759: LD_INT 58
49761: PUSH
49762: LD_INT 59
49764: PUSH
49765: LD_INT 63
49767: PUSH
49768: LD_INT 64
49770: PUSH
49771: LD_INT 65
49773: PUSH
49774: LD_INT 82
49776: PUSH
49777: LD_INT 83
49779: PUSH
49780: LD_INT 84
49782: PUSH
49783: LD_INT 85
49785: PUSH
49786: LD_INT 86
49788: PUSH
49789: EMPTY
49790: LIST
49791: LIST
49792: LIST
49793: LIST
49794: LIST
49795: LIST
49796: LIST
49797: LIST
49798: LIST
49799: LIST
49800: LIST
49801: LIST
49802: LIST
49803: LIST
49804: LIST
49805: LIST
49806: LIST
49807: LIST
49808: LIST
49809: LIST
49810: LIST
49811: LIST
49812: LIST
49813: LIST
49814: LIST
49815: LIST
49816: LIST
49817: LIST
49818: LIST
49819: LIST
49820: LIST
49821: LIST
49822: LIST
49823: LIST
49824: LIST
49825: LIST
49826: LIST
49827: LIST
49828: LIST
49829: LIST
49830: LIST
49831: LIST
49832: LIST
49833: LIST
49834: LIST
49835: LIST
49836: LIST
49837: LIST
49838: LIST
49839: LIST
49840: LIST
49841: LIST
49842: LIST
49843: ST_TO_ADDR
49844: GO 49847
49846: POP
// if state > - 1 and state < 3 then
49847: LD_VAR 0 3
49851: PUSH
49852: LD_INT 1
49854: NEG
49855: GREATER
49856: PUSH
49857: LD_VAR 0 3
49861: PUSH
49862: LD_INT 3
49864: LESS
49865: AND
49866: IFFALSE 49923
// for i in result do
49868: LD_ADDR_VAR 0 5
49872: PUSH
49873: LD_VAR 0 4
49877: PUSH
49878: FOR_IN
49879: IFFALSE 49921
// if GetTech ( i , side ) <> state then
49881: LD_VAR 0 5
49885: PPUSH
49886: LD_VAR 0 1
49890: PPUSH
49891: CALL_OW 321
49895: PUSH
49896: LD_VAR 0 3
49900: NONEQUAL
49901: IFFALSE 49919
// result := result diff i ;
49903: LD_ADDR_VAR 0 4
49907: PUSH
49908: LD_VAR 0 4
49912: PUSH
49913: LD_VAR 0 5
49917: DIFF
49918: ST_TO_ADDR
49919: GO 49878
49921: POP
49922: POP
// end ;
49923: LD_VAR 0 4
49927: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
49928: LD_INT 0
49930: PPUSH
49931: PPUSH
49932: PPUSH
// result := true ;
49933: LD_ADDR_VAR 0 3
49937: PUSH
49938: LD_INT 1
49940: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
49941: LD_ADDR_VAR 0 5
49945: PUSH
49946: LD_VAR 0 2
49950: PPUSH
49951: CALL_OW 480
49955: ST_TO_ADDR
// if not tmp then
49956: LD_VAR 0 5
49960: NOT
49961: IFFALSE 49965
// exit ;
49963: GO 50014
// for i in tmp do
49965: LD_ADDR_VAR 0 4
49969: PUSH
49970: LD_VAR 0 5
49974: PUSH
49975: FOR_IN
49976: IFFALSE 50012
// if GetTech ( i , side ) <> state_researched then
49978: LD_VAR 0 4
49982: PPUSH
49983: LD_VAR 0 1
49987: PPUSH
49988: CALL_OW 321
49992: PUSH
49993: LD_INT 2
49995: NONEQUAL
49996: IFFALSE 50010
// begin result := false ;
49998: LD_ADDR_VAR 0 3
50002: PUSH
50003: LD_INT 0
50005: ST_TO_ADDR
// exit ;
50006: POP
50007: POP
50008: GO 50014
// end ;
50010: GO 49975
50012: POP
50013: POP
// end ;
50014: LD_VAR 0 3
50018: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
50019: LD_INT 0
50021: PPUSH
50022: PPUSH
50023: PPUSH
50024: PPUSH
50025: PPUSH
50026: PPUSH
50027: PPUSH
50028: PPUSH
50029: PPUSH
50030: PPUSH
50031: PPUSH
50032: PPUSH
50033: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
50034: LD_VAR 0 1
50038: NOT
50039: PUSH
50040: LD_VAR 0 1
50044: PPUSH
50045: CALL_OW 257
50049: PUSH
50050: LD_INT 9
50052: NONEQUAL
50053: OR
50054: IFFALSE 50058
// exit ;
50056: GO 50631
// side := GetSide ( unit ) ;
50058: LD_ADDR_VAR 0 9
50062: PUSH
50063: LD_VAR 0 1
50067: PPUSH
50068: CALL_OW 255
50072: ST_TO_ADDR
// tech_space := tech_spacanom ;
50073: LD_ADDR_VAR 0 12
50077: PUSH
50078: LD_INT 29
50080: ST_TO_ADDR
// tech_time := tech_taurad ;
50081: LD_ADDR_VAR 0 13
50085: PUSH
50086: LD_INT 28
50088: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
50089: LD_ADDR_VAR 0 11
50093: PUSH
50094: LD_VAR 0 1
50098: PPUSH
50099: CALL_OW 310
50103: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
50104: LD_VAR 0 11
50108: PPUSH
50109: CALL_OW 247
50113: PUSH
50114: LD_INT 2
50116: EQUAL
50117: IFFALSE 50121
// exit ;
50119: GO 50631
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
50121: LD_ADDR_VAR 0 8
50125: PUSH
50126: LD_INT 81
50128: PUSH
50129: LD_VAR 0 9
50133: PUSH
50134: EMPTY
50135: LIST
50136: LIST
50137: PUSH
50138: LD_INT 3
50140: PUSH
50141: LD_INT 21
50143: PUSH
50144: LD_INT 3
50146: PUSH
50147: EMPTY
50148: LIST
50149: LIST
50150: PUSH
50151: EMPTY
50152: LIST
50153: LIST
50154: PUSH
50155: EMPTY
50156: LIST
50157: LIST
50158: PPUSH
50159: CALL_OW 69
50163: ST_TO_ADDR
// if not tmp then
50164: LD_VAR 0 8
50168: NOT
50169: IFFALSE 50173
// exit ;
50171: GO 50631
// if in_unit then
50173: LD_VAR 0 11
50177: IFFALSE 50201
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
50179: LD_ADDR_VAR 0 10
50183: PUSH
50184: LD_VAR 0 8
50188: PPUSH
50189: LD_VAR 0 11
50193: PPUSH
50194: CALL_OW 74
50198: ST_TO_ADDR
50199: GO 50221
// enemy := NearestUnitToUnit ( tmp , unit ) ;
50201: LD_ADDR_VAR 0 10
50205: PUSH
50206: LD_VAR 0 8
50210: PPUSH
50211: LD_VAR 0 1
50215: PPUSH
50216: CALL_OW 74
50220: ST_TO_ADDR
// if not enemy then
50221: LD_VAR 0 10
50225: NOT
50226: IFFALSE 50230
// exit ;
50228: GO 50631
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
50230: LD_VAR 0 11
50234: PUSH
50235: LD_VAR 0 11
50239: PPUSH
50240: LD_VAR 0 10
50244: PPUSH
50245: CALL_OW 296
50249: PUSH
50250: LD_INT 13
50252: GREATER
50253: AND
50254: PUSH
50255: LD_VAR 0 1
50259: PPUSH
50260: LD_VAR 0 10
50264: PPUSH
50265: CALL_OW 296
50269: PUSH
50270: LD_INT 12
50272: GREATER
50273: OR
50274: IFFALSE 50278
// exit ;
50276: GO 50631
// missile := [ 1 ] ;
50278: LD_ADDR_VAR 0 14
50282: PUSH
50283: LD_INT 1
50285: PUSH
50286: EMPTY
50287: LIST
50288: ST_TO_ADDR
// if Researched ( side , tech_space ) then
50289: LD_VAR 0 9
50293: PPUSH
50294: LD_VAR 0 12
50298: PPUSH
50299: CALL_OW 325
50303: IFFALSE 50332
// missile := Replace ( missile , missile + 1 , 2 ) ;
50305: LD_ADDR_VAR 0 14
50309: PUSH
50310: LD_VAR 0 14
50314: PPUSH
50315: LD_VAR 0 14
50319: PUSH
50320: LD_INT 1
50322: PLUS
50323: PPUSH
50324: LD_INT 2
50326: PPUSH
50327: CALL_OW 1
50331: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
50332: LD_VAR 0 9
50336: PPUSH
50337: LD_VAR 0 13
50341: PPUSH
50342: CALL_OW 325
50346: PUSH
50347: LD_VAR 0 10
50351: PPUSH
50352: CALL_OW 255
50356: PPUSH
50357: LD_VAR 0 13
50361: PPUSH
50362: CALL_OW 325
50366: NOT
50367: AND
50368: IFFALSE 50397
// missile := Replace ( missile , missile + 1 , 3 ) ;
50370: LD_ADDR_VAR 0 14
50374: PUSH
50375: LD_VAR 0 14
50379: PPUSH
50380: LD_VAR 0 14
50384: PUSH
50385: LD_INT 1
50387: PLUS
50388: PPUSH
50389: LD_INT 3
50391: PPUSH
50392: CALL_OW 1
50396: ST_TO_ADDR
// if missile < 2 then
50397: LD_VAR 0 14
50401: PUSH
50402: LD_INT 2
50404: LESS
50405: IFFALSE 50409
// exit ;
50407: GO 50631
// x := GetX ( enemy ) ;
50409: LD_ADDR_VAR 0 4
50413: PUSH
50414: LD_VAR 0 10
50418: PPUSH
50419: CALL_OW 250
50423: ST_TO_ADDR
// y := GetY ( enemy ) ;
50424: LD_ADDR_VAR 0 5
50428: PUSH
50429: LD_VAR 0 10
50433: PPUSH
50434: CALL_OW 251
50438: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
50439: LD_ADDR_VAR 0 6
50443: PUSH
50444: LD_VAR 0 4
50448: PUSH
50449: LD_INT 1
50451: NEG
50452: PPUSH
50453: LD_INT 1
50455: PPUSH
50456: CALL_OW 12
50460: PLUS
50461: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
50462: LD_ADDR_VAR 0 7
50466: PUSH
50467: LD_VAR 0 5
50471: PUSH
50472: LD_INT 1
50474: NEG
50475: PPUSH
50476: LD_INT 1
50478: PPUSH
50479: CALL_OW 12
50483: PLUS
50484: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
50485: LD_VAR 0 6
50489: PPUSH
50490: LD_VAR 0 7
50494: PPUSH
50495: CALL_OW 488
50499: NOT
50500: IFFALSE 50522
// begin _x := x ;
50502: LD_ADDR_VAR 0 6
50506: PUSH
50507: LD_VAR 0 4
50511: ST_TO_ADDR
// _y := y ;
50512: LD_ADDR_VAR 0 7
50516: PUSH
50517: LD_VAR 0 5
50521: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
50522: LD_ADDR_VAR 0 3
50526: PUSH
50527: LD_INT 1
50529: PPUSH
50530: LD_VAR 0 14
50534: PPUSH
50535: CALL_OW 12
50539: ST_TO_ADDR
// case i of 1 :
50540: LD_VAR 0 3
50544: PUSH
50545: LD_INT 1
50547: DOUBLE
50548: EQUAL
50549: IFTRUE 50553
50551: GO 50570
50553: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
50554: LD_VAR 0 1
50558: PPUSH
50559: LD_VAR 0 10
50563: PPUSH
50564: CALL_OW 115
50568: GO 50631
50570: LD_INT 2
50572: DOUBLE
50573: EQUAL
50574: IFTRUE 50578
50576: GO 50600
50578: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
50579: LD_VAR 0 1
50583: PPUSH
50584: LD_VAR 0 6
50588: PPUSH
50589: LD_VAR 0 7
50593: PPUSH
50594: CALL_OW 153
50598: GO 50631
50600: LD_INT 3
50602: DOUBLE
50603: EQUAL
50604: IFTRUE 50608
50606: GO 50630
50608: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
50609: LD_VAR 0 1
50613: PPUSH
50614: LD_VAR 0 6
50618: PPUSH
50619: LD_VAR 0 7
50623: PPUSH
50624: CALL_OW 154
50628: GO 50631
50630: POP
// end ;
50631: LD_VAR 0 2
50635: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
50636: LD_INT 0
50638: PPUSH
50639: PPUSH
50640: PPUSH
50641: PPUSH
50642: PPUSH
50643: PPUSH
// if not unit or not building then
50644: LD_VAR 0 1
50648: NOT
50649: PUSH
50650: LD_VAR 0 2
50654: NOT
50655: OR
50656: IFFALSE 50660
// exit ;
50658: GO 50818
// x := GetX ( building ) ;
50660: LD_ADDR_VAR 0 5
50664: PUSH
50665: LD_VAR 0 2
50669: PPUSH
50670: CALL_OW 250
50674: ST_TO_ADDR
// y := GetY ( building ) ;
50675: LD_ADDR_VAR 0 6
50679: PUSH
50680: LD_VAR 0 2
50684: PPUSH
50685: CALL_OW 251
50689: ST_TO_ADDR
// for i = 0 to 5 do
50690: LD_ADDR_VAR 0 4
50694: PUSH
50695: DOUBLE
50696: LD_INT 0
50698: DEC
50699: ST_TO_ADDR
50700: LD_INT 5
50702: PUSH
50703: FOR_TO
50704: IFFALSE 50816
// begin _x := ShiftX ( x , i , 3 ) ;
50706: LD_ADDR_VAR 0 7
50710: PUSH
50711: LD_VAR 0 5
50715: PPUSH
50716: LD_VAR 0 4
50720: PPUSH
50721: LD_INT 3
50723: PPUSH
50724: CALL_OW 272
50728: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
50729: LD_ADDR_VAR 0 8
50733: PUSH
50734: LD_VAR 0 6
50738: PPUSH
50739: LD_VAR 0 4
50743: PPUSH
50744: LD_INT 3
50746: PPUSH
50747: CALL_OW 273
50751: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
50752: LD_VAR 0 7
50756: PPUSH
50757: LD_VAR 0 8
50761: PPUSH
50762: CALL_OW 488
50766: NOT
50767: IFFALSE 50771
// continue ;
50769: GO 50703
// if HexInfo ( _x , _y ) = 0 then
50771: LD_VAR 0 7
50775: PPUSH
50776: LD_VAR 0 8
50780: PPUSH
50781: CALL_OW 428
50785: PUSH
50786: LD_INT 0
50788: EQUAL
50789: IFFALSE 50814
// begin ComMoveXY ( unit , _x , _y ) ;
50791: LD_VAR 0 1
50795: PPUSH
50796: LD_VAR 0 7
50800: PPUSH
50801: LD_VAR 0 8
50805: PPUSH
50806: CALL_OW 111
// exit ;
50810: POP
50811: POP
50812: GO 50818
// end ; end ;
50814: GO 50703
50816: POP
50817: POP
// end ;
50818: LD_VAR 0 3
50822: RET
// export function ScanBase ( side , base_area ) ; begin
50823: LD_INT 0
50825: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
50826: LD_ADDR_VAR 0 3
50830: PUSH
50831: LD_VAR 0 2
50835: PPUSH
50836: LD_INT 81
50838: PUSH
50839: LD_VAR 0 1
50843: PUSH
50844: EMPTY
50845: LIST
50846: LIST
50847: PPUSH
50848: CALL_OW 70
50852: ST_TO_ADDR
// end ;
50853: LD_VAR 0 3
50857: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
50858: LD_INT 0
50860: PPUSH
50861: PPUSH
50862: PPUSH
50863: PPUSH
// result := false ;
50864: LD_ADDR_VAR 0 2
50868: PUSH
50869: LD_INT 0
50871: ST_TO_ADDR
// side := GetSide ( unit ) ;
50872: LD_ADDR_VAR 0 3
50876: PUSH
50877: LD_VAR 0 1
50881: PPUSH
50882: CALL_OW 255
50886: ST_TO_ADDR
// nat := GetNation ( unit ) ;
50887: LD_ADDR_VAR 0 4
50891: PUSH
50892: LD_VAR 0 1
50896: PPUSH
50897: CALL_OW 248
50901: ST_TO_ADDR
// case nat of 1 :
50902: LD_VAR 0 4
50906: PUSH
50907: LD_INT 1
50909: DOUBLE
50910: EQUAL
50911: IFTRUE 50915
50913: GO 50926
50915: POP
// tech := tech_lassight ; 2 :
50916: LD_ADDR_VAR 0 5
50920: PUSH
50921: LD_INT 12
50923: ST_TO_ADDR
50924: GO 50965
50926: LD_INT 2
50928: DOUBLE
50929: EQUAL
50930: IFTRUE 50934
50932: GO 50945
50934: POP
// tech := tech_mortar ; 3 :
50935: LD_ADDR_VAR 0 5
50939: PUSH
50940: LD_INT 41
50942: ST_TO_ADDR
50943: GO 50965
50945: LD_INT 3
50947: DOUBLE
50948: EQUAL
50949: IFTRUE 50953
50951: GO 50964
50953: POP
// tech := tech_bazooka ; end ;
50954: LD_ADDR_VAR 0 5
50958: PUSH
50959: LD_INT 44
50961: ST_TO_ADDR
50962: GO 50965
50964: POP
// if Researched ( side , tech ) then
50965: LD_VAR 0 3
50969: PPUSH
50970: LD_VAR 0 5
50974: PPUSH
50975: CALL_OW 325
50979: IFFALSE 51006
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
50981: LD_ADDR_VAR 0 2
50985: PUSH
50986: LD_INT 5
50988: PUSH
50989: LD_INT 8
50991: PUSH
50992: LD_INT 9
50994: PUSH
50995: EMPTY
50996: LIST
50997: LIST
50998: LIST
50999: PUSH
51000: LD_VAR 0 4
51004: ARRAY
51005: ST_TO_ADDR
// end ;
51006: LD_VAR 0 2
51010: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
51011: LD_INT 0
51013: PPUSH
51014: PPUSH
51015: PPUSH
// if not mines then
51016: LD_VAR 0 2
51020: NOT
51021: IFFALSE 51025
// exit ;
51023: GO 51169
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
51025: LD_ADDR_VAR 0 5
51029: PUSH
51030: LD_INT 81
51032: PUSH
51033: LD_VAR 0 1
51037: PUSH
51038: EMPTY
51039: LIST
51040: LIST
51041: PUSH
51042: LD_INT 3
51044: PUSH
51045: LD_INT 21
51047: PUSH
51048: LD_INT 3
51050: PUSH
51051: EMPTY
51052: LIST
51053: LIST
51054: PUSH
51055: EMPTY
51056: LIST
51057: LIST
51058: PUSH
51059: EMPTY
51060: LIST
51061: LIST
51062: PPUSH
51063: CALL_OW 69
51067: ST_TO_ADDR
// for i in mines do
51068: LD_ADDR_VAR 0 4
51072: PUSH
51073: LD_VAR 0 2
51077: PUSH
51078: FOR_IN
51079: IFFALSE 51167
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
51081: LD_VAR 0 4
51085: PUSH
51086: LD_INT 1
51088: ARRAY
51089: PPUSH
51090: LD_VAR 0 4
51094: PUSH
51095: LD_INT 2
51097: ARRAY
51098: PPUSH
51099: CALL_OW 458
51103: NOT
51104: IFFALSE 51108
// continue ;
51106: GO 51078
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
51108: LD_VAR 0 4
51112: PUSH
51113: LD_INT 1
51115: ARRAY
51116: PPUSH
51117: LD_VAR 0 4
51121: PUSH
51122: LD_INT 2
51124: ARRAY
51125: PPUSH
51126: CALL_OW 428
51130: PUSH
51131: LD_VAR 0 5
51135: IN
51136: IFFALSE 51165
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
51138: LD_VAR 0 4
51142: PUSH
51143: LD_INT 1
51145: ARRAY
51146: PPUSH
51147: LD_VAR 0 4
51151: PUSH
51152: LD_INT 2
51154: ARRAY
51155: PPUSH
51156: LD_VAR 0 1
51160: PPUSH
51161: CALL_OW 456
// end ;
51165: GO 51078
51167: POP
51168: POP
// end ;
51169: LD_VAR 0 3
51173: RET
// export function Count ( array ) ; begin
51174: LD_INT 0
51176: PPUSH
// result := array + 0 ;
51177: LD_ADDR_VAR 0 2
51181: PUSH
51182: LD_VAR 0 1
51186: PUSH
51187: LD_INT 0
51189: PLUS
51190: ST_TO_ADDR
// end ;
51191: LD_VAR 0 2
51195: RET
// export function IsEmpty ( building ) ; begin
51196: LD_INT 0
51198: PPUSH
// if not building then
51199: LD_VAR 0 1
51203: NOT
51204: IFFALSE 51208
// exit ;
51206: GO 51251
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
51208: LD_ADDR_VAR 0 2
51212: PUSH
51213: LD_VAR 0 1
51217: PUSH
51218: LD_INT 22
51220: PUSH
51221: LD_VAR 0 1
51225: PPUSH
51226: CALL_OW 255
51230: PUSH
51231: EMPTY
51232: LIST
51233: LIST
51234: PUSH
51235: LD_INT 58
51237: PUSH
51238: EMPTY
51239: LIST
51240: PUSH
51241: EMPTY
51242: LIST
51243: LIST
51244: PPUSH
51245: CALL_OW 69
51249: IN
51250: ST_TO_ADDR
// end ;
51251: LD_VAR 0 2
51255: RET
// export function IsNotFull ( building ) ; var places ; begin
51256: LD_INT 0
51258: PPUSH
51259: PPUSH
// if not building then
51260: LD_VAR 0 1
51264: NOT
51265: IFFALSE 51269
// exit ;
51267: GO 51297
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
51269: LD_ADDR_VAR 0 2
51273: PUSH
51274: LD_VAR 0 1
51278: PPUSH
51279: LD_INT 3
51281: PUSH
51282: LD_INT 62
51284: PUSH
51285: EMPTY
51286: LIST
51287: PUSH
51288: EMPTY
51289: LIST
51290: LIST
51291: PPUSH
51292: CALL_OW 72
51296: ST_TO_ADDR
// end ;
51297: LD_VAR 0 2
51301: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
51302: LD_INT 0
51304: PPUSH
51305: PPUSH
51306: PPUSH
51307: PPUSH
// tmp := [ ] ;
51308: LD_ADDR_VAR 0 3
51312: PUSH
51313: EMPTY
51314: ST_TO_ADDR
// list := [ ] ;
51315: LD_ADDR_VAR 0 5
51319: PUSH
51320: EMPTY
51321: ST_TO_ADDR
// for i = 16 to 25 do
51322: LD_ADDR_VAR 0 4
51326: PUSH
51327: DOUBLE
51328: LD_INT 16
51330: DEC
51331: ST_TO_ADDR
51332: LD_INT 25
51334: PUSH
51335: FOR_TO
51336: IFFALSE 51409
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
51338: LD_ADDR_VAR 0 3
51342: PUSH
51343: LD_VAR 0 3
51347: PUSH
51348: LD_INT 22
51350: PUSH
51351: LD_VAR 0 1
51355: PPUSH
51356: CALL_OW 255
51360: PUSH
51361: EMPTY
51362: LIST
51363: LIST
51364: PUSH
51365: LD_INT 91
51367: PUSH
51368: LD_VAR 0 1
51372: PUSH
51373: LD_INT 6
51375: PUSH
51376: EMPTY
51377: LIST
51378: LIST
51379: LIST
51380: PUSH
51381: LD_INT 30
51383: PUSH
51384: LD_VAR 0 4
51388: PUSH
51389: EMPTY
51390: LIST
51391: LIST
51392: PUSH
51393: EMPTY
51394: LIST
51395: LIST
51396: LIST
51397: PUSH
51398: EMPTY
51399: LIST
51400: PPUSH
51401: CALL_OW 69
51405: ADD
51406: ST_TO_ADDR
51407: GO 51335
51409: POP
51410: POP
// for i = 1 to tmp do
51411: LD_ADDR_VAR 0 4
51415: PUSH
51416: DOUBLE
51417: LD_INT 1
51419: DEC
51420: ST_TO_ADDR
51421: LD_VAR 0 3
51425: PUSH
51426: FOR_TO
51427: IFFALSE 51515
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
51429: LD_ADDR_VAR 0 5
51433: PUSH
51434: LD_VAR 0 5
51438: PUSH
51439: LD_VAR 0 3
51443: PUSH
51444: LD_VAR 0 4
51448: ARRAY
51449: PPUSH
51450: CALL_OW 266
51454: PUSH
51455: LD_VAR 0 3
51459: PUSH
51460: LD_VAR 0 4
51464: ARRAY
51465: PPUSH
51466: CALL_OW 250
51470: PUSH
51471: LD_VAR 0 3
51475: PUSH
51476: LD_VAR 0 4
51480: ARRAY
51481: PPUSH
51482: CALL_OW 251
51486: PUSH
51487: LD_VAR 0 3
51491: PUSH
51492: LD_VAR 0 4
51496: ARRAY
51497: PPUSH
51498: CALL_OW 254
51502: PUSH
51503: EMPTY
51504: LIST
51505: LIST
51506: LIST
51507: LIST
51508: PUSH
51509: EMPTY
51510: LIST
51511: ADD
51512: ST_TO_ADDR
51513: GO 51426
51515: POP
51516: POP
// result := list ;
51517: LD_ADDR_VAR 0 2
51521: PUSH
51522: LD_VAR 0 5
51526: ST_TO_ADDR
// end ;
51527: LD_VAR 0 2
51531: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
51532: LD_INT 0
51534: PPUSH
51535: PPUSH
51536: PPUSH
51537: PPUSH
51538: PPUSH
51539: PPUSH
51540: PPUSH
// if not factory then
51541: LD_VAR 0 1
51545: NOT
51546: IFFALSE 51550
// exit ;
51548: GO 52143
// if control = control_apeman then
51550: LD_VAR 0 4
51554: PUSH
51555: LD_INT 5
51557: EQUAL
51558: IFFALSE 51667
// begin tmp := UnitsInside ( factory ) ;
51560: LD_ADDR_VAR 0 8
51564: PUSH
51565: LD_VAR 0 1
51569: PPUSH
51570: CALL_OW 313
51574: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
51575: LD_VAR 0 8
51579: PPUSH
51580: LD_INT 25
51582: PUSH
51583: LD_INT 12
51585: PUSH
51586: EMPTY
51587: LIST
51588: LIST
51589: PPUSH
51590: CALL_OW 72
51594: NOT
51595: IFFALSE 51605
// control := control_manual ;
51597: LD_ADDR_VAR 0 4
51601: PUSH
51602: LD_INT 1
51604: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
51605: LD_ADDR_VAR 0 8
51609: PUSH
51610: LD_VAR 0 1
51614: PPUSH
51615: CALL 51302 0 1
51619: ST_TO_ADDR
// if tmp then
51620: LD_VAR 0 8
51624: IFFALSE 51667
// begin for i in tmp do
51626: LD_ADDR_VAR 0 7
51630: PUSH
51631: LD_VAR 0 8
51635: PUSH
51636: FOR_IN
51637: IFFALSE 51665
// if i [ 1 ] = b_ext_radio then
51639: LD_VAR 0 7
51643: PUSH
51644: LD_INT 1
51646: ARRAY
51647: PUSH
51648: LD_INT 22
51650: EQUAL
51651: IFFALSE 51663
// begin control := control_remote ;
51653: LD_ADDR_VAR 0 4
51657: PUSH
51658: LD_INT 2
51660: ST_TO_ADDR
// break ;
51661: GO 51665
// end ;
51663: GO 51636
51665: POP
51666: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
51667: LD_VAR 0 1
51671: PPUSH
51672: LD_VAR 0 2
51676: PPUSH
51677: LD_VAR 0 3
51681: PPUSH
51682: LD_VAR 0 4
51686: PPUSH
51687: LD_VAR 0 5
51691: PPUSH
51692: CALL_OW 448
51696: IFFALSE 51731
// begin result := [ chassis , engine , control , weapon ] ;
51698: LD_ADDR_VAR 0 6
51702: PUSH
51703: LD_VAR 0 2
51707: PUSH
51708: LD_VAR 0 3
51712: PUSH
51713: LD_VAR 0 4
51717: PUSH
51718: LD_VAR 0 5
51722: PUSH
51723: EMPTY
51724: LIST
51725: LIST
51726: LIST
51727: LIST
51728: ST_TO_ADDR
// exit ;
51729: GO 52143
// end ; _chassis := AvailableChassisList ( factory ) ;
51731: LD_ADDR_VAR 0 9
51735: PUSH
51736: LD_VAR 0 1
51740: PPUSH
51741: CALL_OW 475
51745: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
51746: LD_ADDR_VAR 0 11
51750: PUSH
51751: LD_VAR 0 1
51755: PPUSH
51756: CALL_OW 476
51760: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
51761: LD_ADDR_VAR 0 12
51765: PUSH
51766: LD_VAR 0 1
51770: PPUSH
51771: CALL_OW 477
51775: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
51776: LD_ADDR_VAR 0 10
51780: PUSH
51781: LD_VAR 0 1
51785: PPUSH
51786: CALL_OW 478
51790: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
51791: LD_VAR 0 9
51795: NOT
51796: PUSH
51797: LD_VAR 0 11
51801: NOT
51802: OR
51803: PUSH
51804: LD_VAR 0 12
51808: NOT
51809: OR
51810: PUSH
51811: LD_VAR 0 10
51815: NOT
51816: OR
51817: IFFALSE 51852
// begin result := [ chassis , engine , control , weapon ] ;
51819: LD_ADDR_VAR 0 6
51823: PUSH
51824: LD_VAR 0 2
51828: PUSH
51829: LD_VAR 0 3
51833: PUSH
51834: LD_VAR 0 4
51838: PUSH
51839: LD_VAR 0 5
51843: PUSH
51844: EMPTY
51845: LIST
51846: LIST
51847: LIST
51848: LIST
51849: ST_TO_ADDR
// exit ;
51850: GO 52143
// end ; if not chassis in _chassis then
51852: LD_VAR 0 2
51856: PUSH
51857: LD_VAR 0 9
51861: IN
51862: NOT
51863: IFFALSE 51889
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
51865: LD_ADDR_VAR 0 2
51869: PUSH
51870: LD_VAR 0 9
51874: PUSH
51875: LD_INT 1
51877: PPUSH
51878: LD_VAR 0 9
51882: PPUSH
51883: CALL_OW 12
51887: ARRAY
51888: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
51889: LD_VAR 0 2
51893: PPUSH
51894: LD_VAR 0 3
51898: PPUSH
51899: CALL 52148 0 2
51903: NOT
51904: IFFALSE 51963
// repeat engine := _engine [ 1 ] ;
51906: LD_ADDR_VAR 0 3
51910: PUSH
51911: LD_VAR 0 11
51915: PUSH
51916: LD_INT 1
51918: ARRAY
51919: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
51920: LD_ADDR_VAR 0 11
51924: PUSH
51925: LD_VAR 0 11
51929: PPUSH
51930: LD_INT 1
51932: PPUSH
51933: CALL_OW 3
51937: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
51938: LD_VAR 0 2
51942: PPUSH
51943: LD_VAR 0 3
51947: PPUSH
51948: CALL 52148 0 2
51952: PUSH
51953: LD_VAR 0 11
51957: PUSH
51958: EMPTY
51959: EQUAL
51960: OR
51961: IFFALSE 51906
// if not control in _control then
51963: LD_VAR 0 4
51967: PUSH
51968: LD_VAR 0 12
51972: IN
51973: NOT
51974: IFFALSE 52000
// control := _control [ rand ( 1 , _control ) ] ;
51976: LD_ADDR_VAR 0 4
51980: PUSH
51981: LD_VAR 0 12
51985: PUSH
51986: LD_INT 1
51988: PPUSH
51989: LD_VAR 0 12
51993: PPUSH
51994: CALL_OW 12
51998: ARRAY
51999: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
52000: LD_VAR 0 2
52004: PPUSH
52005: LD_VAR 0 5
52009: PPUSH
52010: CALL 52368 0 2
52014: NOT
52015: IFFALSE 52074
// repeat weapon := _weapon [ 1 ] ;
52017: LD_ADDR_VAR 0 5
52021: PUSH
52022: LD_VAR 0 10
52026: PUSH
52027: LD_INT 1
52029: ARRAY
52030: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
52031: LD_ADDR_VAR 0 10
52035: PUSH
52036: LD_VAR 0 10
52040: PPUSH
52041: LD_INT 1
52043: PPUSH
52044: CALL_OW 3
52048: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
52049: LD_VAR 0 2
52053: PPUSH
52054: LD_VAR 0 5
52058: PPUSH
52059: CALL 52368 0 2
52063: PUSH
52064: LD_VAR 0 10
52068: PUSH
52069: EMPTY
52070: EQUAL
52071: OR
52072: IFFALSE 52017
// result := [ ] ;
52074: LD_ADDR_VAR 0 6
52078: PUSH
52079: EMPTY
52080: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
52081: LD_VAR 0 1
52085: PPUSH
52086: LD_VAR 0 2
52090: PPUSH
52091: LD_VAR 0 3
52095: PPUSH
52096: LD_VAR 0 4
52100: PPUSH
52101: LD_VAR 0 5
52105: PPUSH
52106: CALL_OW 448
52110: IFFALSE 52143
// result := [ chassis , engine , control , weapon ] ;
52112: LD_ADDR_VAR 0 6
52116: PUSH
52117: LD_VAR 0 2
52121: PUSH
52122: LD_VAR 0 3
52126: PUSH
52127: LD_VAR 0 4
52131: PUSH
52132: LD_VAR 0 5
52136: PUSH
52137: EMPTY
52138: LIST
52139: LIST
52140: LIST
52141: LIST
52142: ST_TO_ADDR
// end ;
52143: LD_VAR 0 6
52147: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
52148: LD_INT 0
52150: PPUSH
// if not chassis or not engine then
52151: LD_VAR 0 1
52155: NOT
52156: PUSH
52157: LD_VAR 0 2
52161: NOT
52162: OR
52163: IFFALSE 52167
// exit ;
52165: GO 52363
// case engine of engine_solar :
52167: LD_VAR 0 2
52171: PUSH
52172: LD_INT 2
52174: DOUBLE
52175: EQUAL
52176: IFTRUE 52180
52178: GO 52218
52180: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
52181: LD_ADDR_VAR 0 3
52185: PUSH
52186: LD_INT 11
52188: PUSH
52189: LD_INT 12
52191: PUSH
52192: LD_INT 13
52194: PUSH
52195: LD_INT 14
52197: PUSH
52198: LD_INT 1
52200: PUSH
52201: LD_INT 2
52203: PUSH
52204: LD_INT 3
52206: PUSH
52207: EMPTY
52208: LIST
52209: LIST
52210: LIST
52211: LIST
52212: LIST
52213: LIST
52214: LIST
52215: ST_TO_ADDR
52216: GO 52347
52218: LD_INT 1
52220: DOUBLE
52221: EQUAL
52222: IFTRUE 52226
52224: GO 52288
52226: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
52227: LD_ADDR_VAR 0 3
52231: PUSH
52232: LD_INT 11
52234: PUSH
52235: LD_INT 12
52237: PUSH
52238: LD_INT 13
52240: PUSH
52241: LD_INT 14
52243: PUSH
52244: LD_INT 1
52246: PUSH
52247: LD_INT 2
52249: PUSH
52250: LD_INT 3
52252: PUSH
52253: LD_INT 4
52255: PUSH
52256: LD_INT 5
52258: PUSH
52259: LD_INT 21
52261: PUSH
52262: LD_INT 23
52264: PUSH
52265: LD_INT 22
52267: PUSH
52268: LD_INT 24
52270: PUSH
52271: EMPTY
52272: LIST
52273: LIST
52274: LIST
52275: LIST
52276: LIST
52277: LIST
52278: LIST
52279: LIST
52280: LIST
52281: LIST
52282: LIST
52283: LIST
52284: LIST
52285: ST_TO_ADDR
52286: GO 52347
52288: LD_INT 3
52290: DOUBLE
52291: EQUAL
52292: IFTRUE 52296
52294: GO 52346
52296: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
52297: LD_ADDR_VAR 0 3
52301: PUSH
52302: LD_INT 13
52304: PUSH
52305: LD_INT 14
52307: PUSH
52308: LD_INT 2
52310: PUSH
52311: LD_INT 3
52313: PUSH
52314: LD_INT 4
52316: PUSH
52317: LD_INT 5
52319: PUSH
52320: LD_INT 21
52322: PUSH
52323: LD_INT 22
52325: PUSH
52326: LD_INT 23
52328: PUSH
52329: LD_INT 24
52331: PUSH
52332: EMPTY
52333: LIST
52334: LIST
52335: LIST
52336: LIST
52337: LIST
52338: LIST
52339: LIST
52340: LIST
52341: LIST
52342: LIST
52343: ST_TO_ADDR
52344: GO 52347
52346: POP
// result := ( chassis in result ) ;
52347: LD_ADDR_VAR 0 3
52351: PUSH
52352: LD_VAR 0 1
52356: PUSH
52357: LD_VAR 0 3
52361: IN
52362: ST_TO_ADDR
// end ;
52363: LD_VAR 0 3
52367: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
52368: LD_INT 0
52370: PPUSH
// if not chassis or not weapon then
52371: LD_VAR 0 1
52375: NOT
52376: PUSH
52377: LD_VAR 0 2
52381: NOT
52382: OR
52383: IFFALSE 52387
// exit ;
52385: GO 53447
// case weapon of us_machine_gun :
52387: LD_VAR 0 2
52391: PUSH
52392: LD_INT 2
52394: DOUBLE
52395: EQUAL
52396: IFTRUE 52400
52398: GO 52430
52400: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
52401: LD_ADDR_VAR 0 3
52405: PUSH
52406: LD_INT 1
52408: PUSH
52409: LD_INT 2
52411: PUSH
52412: LD_INT 3
52414: PUSH
52415: LD_INT 4
52417: PUSH
52418: LD_INT 5
52420: PUSH
52421: EMPTY
52422: LIST
52423: LIST
52424: LIST
52425: LIST
52426: LIST
52427: ST_TO_ADDR
52428: GO 53431
52430: LD_INT 3
52432: DOUBLE
52433: EQUAL
52434: IFTRUE 52438
52436: GO 52468
52438: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
52439: LD_ADDR_VAR 0 3
52443: PUSH
52444: LD_INT 1
52446: PUSH
52447: LD_INT 2
52449: PUSH
52450: LD_INT 3
52452: PUSH
52453: LD_INT 4
52455: PUSH
52456: LD_INT 5
52458: PUSH
52459: EMPTY
52460: LIST
52461: LIST
52462: LIST
52463: LIST
52464: LIST
52465: ST_TO_ADDR
52466: GO 53431
52468: LD_INT 11
52470: DOUBLE
52471: EQUAL
52472: IFTRUE 52476
52474: GO 52506
52476: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
52477: LD_ADDR_VAR 0 3
52481: PUSH
52482: LD_INT 1
52484: PUSH
52485: LD_INT 2
52487: PUSH
52488: LD_INT 3
52490: PUSH
52491: LD_INT 4
52493: PUSH
52494: LD_INT 5
52496: PUSH
52497: EMPTY
52498: LIST
52499: LIST
52500: LIST
52501: LIST
52502: LIST
52503: ST_TO_ADDR
52504: GO 53431
52506: LD_INT 4
52508: DOUBLE
52509: EQUAL
52510: IFTRUE 52514
52512: GO 52540
52514: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
52515: LD_ADDR_VAR 0 3
52519: PUSH
52520: LD_INT 2
52522: PUSH
52523: LD_INT 3
52525: PUSH
52526: LD_INT 4
52528: PUSH
52529: LD_INT 5
52531: PUSH
52532: EMPTY
52533: LIST
52534: LIST
52535: LIST
52536: LIST
52537: ST_TO_ADDR
52538: GO 53431
52540: LD_INT 5
52542: DOUBLE
52543: EQUAL
52544: IFTRUE 52548
52546: GO 52574
52548: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
52549: LD_ADDR_VAR 0 3
52553: PUSH
52554: LD_INT 2
52556: PUSH
52557: LD_INT 3
52559: PUSH
52560: LD_INT 4
52562: PUSH
52563: LD_INT 5
52565: PUSH
52566: EMPTY
52567: LIST
52568: LIST
52569: LIST
52570: LIST
52571: ST_TO_ADDR
52572: GO 53431
52574: LD_INT 9
52576: DOUBLE
52577: EQUAL
52578: IFTRUE 52582
52580: GO 52608
52582: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
52583: LD_ADDR_VAR 0 3
52587: PUSH
52588: LD_INT 2
52590: PUSH
52591: LD_INT 3
52593: PUSH
52594: LD_INT 4
52596: PUSH
52597: LD_INT 5
52599: PUSH
52600: EMPTY
52601: LIST
52602: LIST
52603: LIST
52604: LIST
52605: ST_TO_ADDR
52606: GO 53431
52608: LD_INT 7
52610: DOUBLE
52611: EQUAL
52612: IFTRUE 52616
52614: GO 52642
52616: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
52617: LD_ADDR_VAR 0 3
52621: PUSH
52622: LD_INT 2
52624: PUSH
52625: LD_INT 3
52627: PUSH
52628: LD_INT 4
52630: PUSH
52631: LD_INT 5
52633: PUSH
52634: EMPTY
52635: LIST
52636: LIST
52637: LIST
52638: LIST
52639: ST_TO_ADDR
52640: GO 53431
52642: LD_INT 12
52644: DOUBLE
52645: EQUAL
52646: IFTRUE 52650
52648: GO 52676
52650: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
52651: LD_ADDR_VAR 0 3
52655: PUSH
52656: LD_INT 2
52658: PUSH
52659: LD_INT 3
52661: PUSH
52662: LD_INT 4
52664: PUSH
52665: LD_INT 5
52667: PUSH
52668: EMPTY
52669: LIST
52670: LIST
52671: LIST
52672: LIST
52673: ST_TO_ADDR
52674: GO 53431
52676: LD_INT 13
52678: DOUBLE
52679: EQUAL
52680: IFTRUE 52684
52682: GO 52710
52684: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
52685: LD_ADDR_VAR 0 3
52689: PUSH
52690: LD_INT 2
52692: PUSH
52693: LD_INT 3
52695: PUSH
52696: LD_INT 4
52698: PUSH
52699: LD_INT 5
52701: PUSH
52702: EMPTY
52703: LIST
52704: LIST
52705: LIST
52706: LIST
52707: ST_TO_ADDR
52708: GO 53431
52710: LD_INT 14
52712: DOUBLE
52713: EQUAL
52714: IFTRUE 52718
52716: GO 52736
52718: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
52719: LD_ADDR_VAR 0 3
52723: PUSH
52724: LD_INT 4
52726: PUSH
52727: LD_INT 5
52729: PUSH
52730: EMPTY
52731: LIST
52732: LIST
52733: ST_TO_ADDR
52734: GO 53431
52736: LD_INT 6
52738: DOUBLE
52739: EQUAL
52740: IFTRUE 52744
52742: GO 52762
52744: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
52745: LD_ADDR_VAR 0 3
52749: PUSH
52750: LD_INT 4
52752: PUSH
52753: LD_INT 5
52755: PUSH
52756: EMPTY
52757: LIST
52758: LIST
52759: ST_TO_ADDR
52760: GO 53431
52762: LD_INT 10
52764: DOUBLE
52765: EQUAL
52766: IFTRUE 52770
52768: GO 52788
52770: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
52771: LD_ADDR_VAR 0 3
52775: PUSH
52776: LD_INT 4
52778: PUSH
52779: LD_INT 5
52781: PUSH
52782: EMPTY
52783: LIST
52784: LIST
52785: ST_TO_ADDR
52786: GO 53431
52788: LD_INT 22
52790: DOUBLE
52791: EQUAL
52792: IFTRUE 52796
52794: GO 52822
52796: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
52797: LD_ADDR_VAR 0 3
52801: PUSH
52802: LD_INT 11
52804: PUSH
52805: LD_INT 12
52807: PUSH
52808: LD_INT 13
52810: PUSH
52811: LD_INT 14
52813: PUSH
52814: EMPTY
52815: LIST
52816: LIST
52817: LIST
52818: LIST
52819: ST_TO_ADDR
52820: GO 53431
52822: LD_INT 23
52824: DOUBLE
52825: EQUAL
52826: IFTRUE 52830
52828: GO 52856
52830: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
52831: LD_ADDR_VAR 0 3
52835: PUSH
52836: LD_INT 11
52838: PUSH
52839: LD_INT 12
52841: PUSH
52842: LD_INT 13
52844: PUSH
52845: LD_INT 14
52847: PUSH
52848: EMPTY
52849: LIST
52850: LIST
52851: LIST
52852: LIST
52853: ST_TO_ADDR
52854: GO 53431
52856: LD_INT 24
52858: DOUBLE
52859: EQUAL
52860: IFTRUE 52864
52862: GO 52890
52864: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
52865: LD_ADDR_VAR 0 3
52869: PUSH
52870: LD_INT 11
52872: PUSH
52873: LD_INT 12
52875: PUSH
52876: LD_INT 13
52878: PUSH
52879: LD_INT 14
52881: PUSH
52882: EMPTY
52883: LIST
52884: LIST
52885: LIST
52886: LIST
52887: ST_TO_ADDR
52888: GO 53431
52890: LD_INT 30
52892: DOUBLE
52893: EQUAL
52894: IFTRUE 52898
52896: GO 52924
52898: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
52899: LD_ADDR_VAR 0 3
52903: PUSH
52904: LD_INT 11
52906: PUSH
52907: LD_INT 12
52909: PUSH
52910: LD_INT 13
52912: PUSH
52913: LD_INT 14
52915: PUSH
52916: EMPTY
52917: LIST
52918: LIST
52919: LIST
52920: LIST
52921: ST_TO_ADDR
52922: GO 53431
52924: LD_INT 25
52926: DOUBLE
52927: EQUAL
52928: IFTRUE 52932
52930: GO 52950
52932: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
52933: LD_ADDR_VAR 0 3
52937: PUSH
52938: LD_INT 13
52940: PUSH
52941: LD_INT 14
52943: PUSH
52944: EMPTY
52945: LIST
52946: LIST
52947: ST_TO_ADDR
52948: GO 53431
52950: LD_INT 27
52952: DOUBLE
52953: EQUAL
52954: IFTRUE 52958
52956: GO 52976
52958: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
52959: LD_ADDR_VAR 0 3
52963: PUSH
52964: LD_INT 13
52966: PUSH
52967: LD_INT 14
52969: PUSH
52970: EMPTY
52971: LIST
52972: LIST
52973: ST_TO_ADDR
52974: GO 53431
52976: LD_INT 92
52978: DOUBLE
52979: EQUAL
52980: IFTRUE 52984
52982: GO 53010
52984: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
52985: LD_ADDR_VAR 0 3
52989: PUSH
52990: LD_INT 11
52992: PUSH
52993: LD_INT 12
52995: PUSH
52996: LD_INT 13
52998: PUSH
52999: LD_INT 14
53001: PUSH
53002: EMPTY
53003: LIST
53004: LIST
53005: LIST
53006: LIST
53007: ST_TO_ADDR
53008: GO 53431
53010: LD_INT 28
53012: DOUBLE
53013: EQUAL
53014: IFTRUE 53018
53016: GO 53036
53018: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
53019: LD_ADDR_VAR 0 3
53023: PUSH
53024: LD_INT 13
53026: PUSH
53027: LD_INT 14
53029: PUSH
53030: EMPTY
53031: LIST
53032: LIST
53033: ST_TO_ADDR
53034: GO 53431
53036: LD_INT 29
53038: DOUBLE
53039: EQUAL
53040: IFTRUE 53044
53042: GO 53062
53044: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
53045: LD_ADDR_VAR 0 3
53049: PUSH
53050: LD_INT 13
53052: PUSH
53053: LD_INT 14
53055: PUSH
53056: EMPTY
53057: LIST
53058: LIST
53059: ST_TO_ADDR
53060: GO 53431
53062: LD_INT 31
53064: DOUBLE
53065: EQUAL
53066: IFTRUE 53070
53068: GO 53088
53070: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
53071: LD_ADDR_VAR 0 3
53075: PUSH
53076: LD_INT 13
53078: PUSH
53079: LD_INT 14
53081: PUSH
53082: EMPTY
53083: LIST
53084: LIST
53085: ST_TO_ADDR
53086: GO 53431
53088: LD_INT 26
53090: DOUBLE
53091: EQUAL
53092: IFTRUE 53096
53094: GO 53114
53096: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
53097: LD_ADDR_VAR 0 3
53101: PUSH
53102: LD_INT 13
53104: PUSH
53105: LD_INT 14
53107: PUSH
53108: EMPTY
53109: LIST
53110: LIST
53111: ST_TO_ADDR
53112: GO 53431
53114: LD_INT 42
53116: DOUBLE
53117: EQUAL
53118: IFTRUE 53122
53120: GO 53148
53122: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
53123: LD_ADDR_VAR 0 3
53127: PUSH
53128: LD_INT 21
53130: PUSH
53131: LD_INT 22
53133: PUSH
53134: LD_INT 23
53136: PUSH
53137: LD_INT 24
53139: PUSH
53140: EMPTY
53141: LIST
53142: LIST
53143: LIST
53144: LIST
53145: ST_TO_ADDR
53146: GO 53431
53148: LD_INT 43
53150: DOUBLE
53151: EQUAL
53152: IFTRUE 53156
53154: GO 53182
53156: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
53157: LD_ADDR_VAR 0 3
53161: PUSH
53162: LD_INT 21
53164: PUSH
53165: LD_INT 22
53167: PUSH
53168: LD_INT 23
53170: PUSH
53171: LD_INT 24
53173: PUSH
53174: EMPTY
53175: LIST
53176: LIST
53177: LIST
53178: LIST
53179: ST_TO_ADDR
53180: GO 53431
53182: LD_INT 44
53184: DOUBLE
53185: EQUAL
53186: IFTRUE 53190
53188: GO 53216
53190: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
53191: LD_ADDR_VAR 0 3
53195: PUSH
53196: LD_INT 21
53198: PUSH
53199: LD_INT 22
53201: PUSH
53202: LD_INT 23
53204: PUSH
53205: LD_INT 24
53207: PUSH
53208: EMPTY
53209: LIST
53210: LIST
53211: LIST
53212: LIST
53213: ST_TO_ADDR
53214: GO 53431
53216: LD_INT 45
53218: DOUBLE
53219: EQUAL
53220: IFTRUE 53224
53222: GO 53250
53224: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
53225: LD_ADDR_VAR 0 3
53229: PUSH
53230: LD_INT 21
53232: PUSH
53233: LD_INT 22
53235: PUSH
53236: LD_INT 23
53238: PUSH
53239: LD_INT 24
53241: PUSH
53242: EMPTY
53243: LIST
53244: LIST
53245: LIST
53246: LIST
53247: ST_TO_ADDR
53248: GO 53431
53250: LD_INT 49
53252: DOUBLE
53253: EQUAL
53254: IFTRUE 53258
53256: GO 53284
53258: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
53259: LD_ADDR_VAR 0 3
53263: PUSH
53264: LD_INT 21
53266: PUSH
53267: LD_INT 22
53269: PUSH
53270: LD_INT 23
53272: PUSH
53273: LD_INT 24
53275: PUSH
53276: EMPTY
53277: LIST
53278: LIST
53279: LIST
53280: LIST
53281: ST_TO_ADDR
53282: GO 53431
53284: LD_INT 51
53286: DOUBLE
53287: EQUAL
53288: IFTRUE 53292
53290: GO 53318
53292: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
53293: LD_ADDR_VAR 0 3
53297: PUSH
53298: LD_INT 21
53300: PUSH
53301: LD_INT 22
53303: PUSH
53304: LD_INT 23
53306: PUSH
53307: LD_INT 24
53309: PUSH
53310: EMPTY
53311: LIST
53312: LIST
53313: LIST
53314: LIST
53315: ST_TO_ADDR
53316: GO 53431
53318: LD_INT 52
53320: DOUBLE
53321: EQUAL
53322: IFTRUE 53326
53324: GO 53352
53326: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
53327: LD_ADDR_VAR 0 3
53331: PUSH
53332: LD_INT 21
53334: PUSH
53335: LD_INT 22
53337: PUSH
53338: LD_INT 23
53340: PUSH
53341: LD_INT 24
53343: PUSH
53344: EMPTY
53345: LIST
53346: LIST
53347: LIST
53348: LIST
53349: ST_TO_ADDR
53350: GO 53431
53352: LD_INT 53
53354: DOUBLE
53355: EQUAL
53356: IFTRUE 53360
53358: GO 53378
53360: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
53361: LD_ADDR_VAR 0 3
53365: PUSH
53366: LD_INT 23
53368: PUSH
53369: LD_INT 24
53371: PUSH
53372: EMPTY
53373: LIST
53374: LIST
53375: ST_TO_ADDR
53376: GO 53431
53378: LD_INT 46
53380: DOUBLE
53381: EQUAL
53382: IFTRUE 53386
53384: GO 53404
53386: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
53387: LD_ADDR_VAR 0 3
53391: PUSH
53392: LD_INT 23
53394: PUSH
53395: LD_INT 24
53397: PUSH
53398: EMPTY
53399: LIST
53400: LIST
53401: ST_TO_ADDR
53402: GO 53431
53404: LD_INT 47
53406: DOUBLE
53407: EQUAL
53408: IFTRUE 53412
53410: GO 53430
53412: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
53413: LD_ADDR_VAR 0 3
53417: PUSH
53418: LD_INT 23
53420: PUSH
53421: LD_INT 24
53423: PUSH
53424: EMPTY
53425: LIST
53426: LIST
53427: ST_TO_ADDR
53428: GO 53431
53430: POP
// result := ( chassis in result ) ;
53431: LD_ADDR_VAR 0 3
53435: PUSH
53436: LD_VAR 0 1
53440: PUSH
53441: LD_VAR 0 3
53445: IN
53446: ST_TO_ADDR
// end ;
53447: LD_VAR 0 3
53451: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
53452: LD_INT 0
53454: PPUSH
53455: PPUSH
53456: PPUSH
53457: PPUSH
53458: PPUSH
53459: PPUSH
53460: PPUSH
// result := array ;
53461: LD_ADDR_VAR 0 5
53465: PUSH
53466: LD_VAR 0 1
53470: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
53471: LD_VAR 0 1
53475: NOT
53476: PUSH
53477: LD_VAR 0 2
53481: NOT
53482: OR
53483: PUSH
53484: LD_VAR 0 3
53488: NOT
53489: OR
53490: PUSH
53491: LD_VAR 0 2
53495: PUSH
53496: LD_VAR 0 1
53500: GREATER
53501: OR
53502: PUSH
53503: LD_VAR 0 3
53507: PUSH
53508: LD_VAR 0 1
53512: GREATER
53513: OR
53514: IFFALSE 53518
// exit ;
53516: GO 53814
// if direction then
53518: LD_VAR 0 4
53522: IFFALSE 53586
// begin d := 1 ;
53524: LD_ADDR_VAR 0 9
53528: PUSH
53529: LD_INT 1
53531: ST_TO_ADDR
// if i_from > i_to then
53532: LD_VAR 0 2
53536: PUSH
53537: LD_VAR 0 3
53541: GREATER
53542: IFFALSE 53568
// length := ( array - i_from ) + i_to else
53544: LD_ADDR_VAR 0 11
53548: PUSH
53549: LD_VAR 0 1
53553: PUSH
53554: LD_VAR 0 2
53558: MINUS
53559: PUSH
53560: LD_VAR 0 3
53564: PLUS
53565: ST_TO_ADDR
53566: GO 53584
// length := i_to - i_from ;
53568: LD_ADDR_VAR 0 11
53572: PUSH
53573: LD_VAR 0 3
53577: PUSH
53578: LD_VAR 0 2
53582: MINUS
53583: ST_TO_ADDR
// end else
53584: GO 53647
// begin d := - 1 ;
53586: LD_ADDR_VAR 0 9
53590: PUSH
53591: LD_INT 1
53593: NEG
53594: ST_TO_ADDR
// if i_from > i_to then
53595: LD_VAR 0 2
53599: PUSH
53600: LD_VAR 0 3
53604: GREATER
53605: IFFALSE 53625
// length := i_from - i_to else
53607: LD_ADDR_VAR 0 11
53611: PUSH
53612: LD_VAR 0 2
53616: PUSH
53617: LD_VAR 0 3
53621: MINUS
53622: ST_TO_ADDR
53623: GO 53647
// length := ( array - i_to ) + i_from ;
53625: LD_ADDR_VAR 0 11
53629: PUSH
53630: LD_VAR 0 1
53634: PUSH
53635: LD_VAR 0 3
53639: MINUS
53640: PUSH
53641: LD_VAR 0 2
53645: PLUS
53646: ST_TO_ADDR
// end ; if not length then
53647: LD_VAR 0 11
53651: NOT
53652: IFFALSE 53656
// exit ;
53654: GO 53814
// tmp := array ;
53656: LD_ADDR_VAR 0 10
53660: PUSH
53661: LD_VAR 0 1
53665: ST_TO_ADDR
// for i = 1 to length do
53666: LD_ADDR_VAR 0 6
53670: PUSH
53671: DOUBLE
53672: LD_INT 1
53674: DEC
53675: ST_TO_ADDR
53676: LD_VAR 0 11
53680: PUSH
53681: FOR_TO
53682: IFFALSE 53802
// begin for j = 1 to array do
53684: LD_ADDR_VAR 0 7
53688: PUSH
53689: DOUBLE
53690: LD_INT 1
53692: DEC
53693: ST_TO_ADDR
53694: LD_VAR 0 1
53698: PUSH
53699: FOR_TO
53700: IFFALSE 53788
// begin k := j + d ;
53702: LD_ADDR_VAR 0 8
53706: PUSH
53707: LD_VAR 0 7
53711: PUSH
53712: LD_VAR 0 9
53716: PLUS
53717: ST_TO_ADDR
// if k > array then
53718: LD_VAR 0 8
53722: PUSH
53723: LD_VAR 0 1
53727: GREATER
53728: IFFALSE 53738
// k := 1 ;
53730: LD_ADDR_VAR 0 8
53734: PUSH
53735: LD_INT 1
53737: ST_TO_ADDR
// if not k then
53738: LD_VAR 0 8
53742: NOT
53743: IFFALSE 53755
// k := array ;
53745: LD_ADDR_VAR 0 8
53749: PUSH
53750: LD_VAR 0 1
53754: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
53755: LD_ADDR_VAR 0 10
53759: PUSH
53760: LD_VAR 0 10
53764: PPUSH
53765: LD_VAR 0 8
53769: PPUSH
53770: LD_VAR 0 1
53774: PUSH
53775: LD_VAR 0 7
53779: ARRAY
53780: PPUSH
53781: CALL_OW 1
53785: ST_TO_ADDR
// end ;
53786: GO 53699
53788: POP
53789: POP
// array := tmp ;
53790: LD_ADDR_VAR 0 1
53794: PUSH
53795: LD_VAR 0 10
53799: ST_TO_ADDR
// end ;
53800: GO 53681
53802: POP
53803: POP
// result := array ;
53804: LD_ADDR_VAR 0 5
53808: PUSH
53809: LD_VAR 0 1
53813: ST_TO_ADDR
// end ;
53814: LD_VAR 0 5
53818: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
53819: LD_INT 0
53821: PPUSH
53822: PPUSH
// result := 0 ;
53823: LD_ADDR_VAR 0 3
53827: PUSH
53828: LD_INT 0
53830: ST_TO_ADDR
// if not array or not value in array then
53831: LD_VAR 0 1
53835: NOT
53836: PUSH
53837: LD_VAR 0 2
53841: PUSH
53842: LD_VAR 0 1
53846: IN
53847: NOT
53848: OR
53849: IFFALSE 53853
// exit ;
53851: GO 53907
// for i = 1 to array do
53853: LD_ADDR_VAR 0 4
53857: PUSH
53858: DOUBLE
53859: LD_INT 1
53861: DEC
53862: ST_TO_ADDR
53863: LD_VAR 0 1
53867: PUSH
53868: FOR_TO
53869: IFFALSE 53905
// if value = array [ i ] then
53871: LD_VAR 0 2
53875: PUSH
53876: LD_VAR 0 1
53880: PUSH
53881: LD_VAR 0 4
53885: ARRAY
53886: EQUAL
53887: IFFALSE 53903
// begin result := i ;
53889: LD_ADDR_VAR 0 3
53893: PUSH
53894: LD_VAR 0 4
53898: ST_TO_ADDR
// exit ;
53899: POP
53900: POP
53901: GO 53907
// end ;
53903: GO 53868
53905: POP
53906: POP
// end ;
53907: LD_VAR 0 3
53911: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
53912: LD_INT 0
53914: PPUSH
// vc_chassis := chassis ;
53915: LD_ADDR_OWVAR 37
53919: PUSH
53920: LD_VAR 0 1
53924: ST_TO_ADDR
// vc_engine := engine ;
53925: LD_ADDR_OWVAR 39
53929: PUSH
53930: LD_VAR 0 2
53934: ST_TO_ADDR
// vc_control := control ;
53935: LD_ADDR_OWVAR 38
53939: PUSH
53940: LD_VAR 0 3
53944: ST_TO_ADDR
// vc_weapon := weapon ;
53945: LD_ADDR_OWVAR 40
53949: PUSH
53950: LD_VAR 0 4
53954: ST_TO_ADDR
// vc_fuel_battery := fuel ;
53955: LD_ADDR_OWVAR 41
53959: PUSH
53960: LD_VAR 0 5
53964: ST_TO_ADDR
// end ;
53965: LD_VAR 0 6
53969: RET
// export function WantPlant ( unit ) ; var task ; begin
53970: LD_INT 0
53972: PPUSH
53973: PPUSH
// result := false ;
53974: LD_ADDR_VAR 0 2
53978: PUSH
53979: LD_INT 0
53981: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
53982: LD_ADDR_VAR 0 3
53986: PUSH
53987: LD_VAR 0 1
53991: PPUSH
53992: CALL_OW 437
53996: ST_TO_ADDR
// if task then
53997: LD_VAR 0 3
54001: IFFALSE 54029
// if task [ 1 ] [ 1 ] = p then
54003: LD_VAR 0 3
54007: PUSH
54008: LD_INT 1
54010: ARRAY
54011: PUSH
54012: LD_INT 1
54014: ARRAY
54015: PUSH
54016: LD_STRING p
54018: EQUAL
54019: IFFALSE 54029
// result := true ;
54021: LD_ADDR_VAR 0 2
54025: PUSH
54026: LD_INT 1
54028: ST_TO_ADDR
// end ;
54029: LD_VAR 0 2
54033: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
54034: LD_INT 0
54036: PPUSH
54037: PPUSH
54038: PPUSH
54039: PPUSH
// if pos < 1 then
54040: LD_VAR 0 2
54044: PUSH
54045: LD_INT 1
54047: LESS
54048: IFFALSE 54052
// exit ;
54050: GO 54355
// if pos = 1 then
54052: LD_VAR 0 2
54056: PUSH
54057: LD_INT 1
54059: EQUAL
54060: IFFALSE 54093
// result := Replace ( arr , pos [ 1 ] , value ) else
54062: LD_ADDR_VAR 0 4
54066: PUSH
54067: LD_VAR 0 1
54071: PPUSH
54072: LD_VAR 0 2
54076: PUSH
54077: LD_INT 1
54079: ARRAY
54080: PPUSH
54081: LD_VAR 0 3
54085: PPUSH
54086: CALL_OW 1
54090: ST_TO_ADDR
54091: GO 54355
// begin tmp := arr ;
54093: LD_ADDR_VAR 0 6
54097: PUSH
54098: LD_VAR 0 1
54102: ST_TO_ADDR
// s_arr := [ tmp ] ;
54103: LD_ADDR_VAR 0 7
54107: PUSH
54108: LD_VAR 0 6
54112: PUSH
54113: EMPTY
54114: LIST
54115: ST_TO_ADDR
// for i = 1 to pos - 1 do
54116: LD_ADDR_VAR 0 5
54120: PUSH
54121: DOUBLE
54122: LD_INT 1
54124: DEC
54125: ST_TO_ADDR
54126: LD_VAR 0 2
54130: PUSH
54131: LD_INT 1
54133: MINUS
54134: PUSH
54135: FOR_TO
54136: IFFALSE 54181
// begin tmp := tmp [ pos [ i ] ] ;
54138: LD_ADDR_VAR 0 6
54142: PUSH
54143: LD_VAR 0 6
54147: PUSH
54148: LD_VAR 0 2
54152: PUSH
54153: LD_VAR 0 5
54157: ARRAY
54158: ARRAY
54159: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
54160: LD_ADDR_VAR 0 7
54164: PUSH
54165: LD_VAR 0 7
54169: PUSH
54170: LD_VAR 0 6
54174: PUSH
54175: EMPTY
54176: LIST
54177: ADD
54178: ST_TO_ADDR
// end ;
54179: GO 54135
54181: POP
54182: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
54183: LD_ADDR_VAR 0 6
54187: PUSH
54188: LD_VAR 0 6
54192: PPUSH
54193: LD_VAR 0 2
54197: PUSH
54198: LD_VAR 0 2
54202: ARRAY
54203: PPUSH
54204: LD_VAR 0 3
54208: PPUSH
54209: CALL_OW 1
54213: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
54214: LD_ADDR_VAR 0 7
54218: PUSH
54219: LD_VAR 0 7
54223: PPUSH
54224: LD_VAR 0 7
54228: PPUSH
54229: LD_VAR 0 6
54233: PPUSH
54234: CALL_OW 1
54238: ST_TO_ADDR
// for i = s_arr downto 2 do
54239: LD_ADDR_VAR 0 5
54243: PUSH
54244: DOUBLE
54245: LD_VAR 0 7
54249: INC
54250: ST_TO_ADDR
54251: LD_INT 2
54253: PUSH
54254: FOR_DOWNTO
54255: IFFALSE 54339
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
54257: LD_ADDR_VAR 0 6
54261: PUSH
54262: LD_VAR 0 7
54266: PUSH
54267: LD_VAR 0 5
54271: PUSH
54272: LD_INT 1
54274: MINUS
54275: ARRAY
54276: PPUSH
54277: LD_VAR 0 2
54281: PUSH
54282: LD_VAR 0 5
54286: PUSH
54287: LD_INT 1
54289: MINUS
54290: ARRAY
54291: PPUSH
54292: LD_VAR 0 7
54296: PUSH
54297: LD_VAR 0 5
54301: ARRAY
54302: PPUSH
54303: CALL_OW 1
54307: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
54308: LD_ADDR_VAR 0 7
54312: PUSH
54313: LD_VAR 0 7
54317: PPUSH
54318: LD_VAR 0 5
54322: PUSH
54323: LD_INT 1
54325: MINUS
54326: PPUSH
54327: LD_VAR 0 6
54331: PPUSH
54332: CALL_OW 1
54336: ST_TO_ADDR
// end ;
54337: GO 54254
54339: POP
54340: POP
// result := s_arr [ 1 ] ;
54341: LD_ADDR_VAR 0 4
54345: PUSH
54346: LD_VAR 0 7
54350: PUSH
54351: LD_INT 1
54353: ARRAY
54354: ST_TO_ADDR
// end ; end ;
54355: LD_VAR 0 4
54359: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
54360: LD_INT 0
54362: PPUSH
54363: PPUSH
// if not list then
54364: LD_VAR 0 1
54368: NOT
54369: IFFALSE 54373
// exit ;
54371: GO 54464
// i := list [ pos1 ] ;
54373: LD_ADDR_VAR 0 5
54377: PUSH
54378: LD_VAR 0 1
54382: PUSH
54383: LD_VAR 0 2
54387: ARRAY
54388: ST_TO_ADDR
// if not i then
54389: LD_VAR 0 5
54393: NOT
54394: IFFALSE 54398
// exit ;
54396: GO 54464
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
54398: LD_ADDR_VAR 0 1
54402: PUSH
54403: LD_VAR 0 1
54407: PPUSH
54408: LD_VAR 0 2
54412: PPUSH
54413: LD_VAR 0 1
54417: PUSH
54418: LD_VAR 0 3
54422: ARRAY
54423: PPUSH
54424: CALL_OW 1
54428: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
54429: LD_ADDR_VAR 0 1
54433: PUSH
54434: LD_VAR 0 1
54438: PPUSH
54439: LD_VAR 0 3
54443: PPUSH
54444: LD_VAR 0 5
54448: PPUSH
54449: CALL_OW 1
54453: ST_TO_ADDR
// result := list ;
54454: LD_ADDR_VAR 0 4
54458: PUSH
54459: LD_VAR 0 1
54463: ST_TO_ADDR
// end ;
54464: LD_VAR 0 4
54468: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
54469: LD_INT 0
54471: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
54472: LD_ADDR_VAR 0 5
54476: PUSH
54477: LD_VAR 0 1
54481: PPUSH
54482: CALL_OW 250
54486: PPUSH
54487: LD_VAR 0 1
54491: PPUSH
54492: CALL_OW 251
54496: PPUSH
54497: LD_VAR 0 2
54501: PPUSH
54502: LD_VAR 0 3
54506: PPUSH
54507: LD_VAR 0 4
54511: PPUSH
54512: CALL 54522 0 5
54516: ST_TO_ADDR
// end ;
54517: LD_VAR 0 5
54521: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
54522: LD_INT 0
54524: PPUSH
54525: PPUSH
54526: PPUSH
54527: PPUSH
// if not list then
54528: LD_VAR 0 3
54532: NOT
54533: IFFALSE 54537
// exit ;
54535: GO 54925
// result := [ ] ;
54537: LD_ADDR_VAR 0 6
54541: PUSH
54542: EMPTY
54543: ST_TO_ADDR
// for i in list do
54544: LD_ADDR_VAR 0 7
54548: PUSH
54549: LD_VAR 0 3
54553: PUSH
54554: FOR_IN
54555: IFFALSE 54757
// begin tmp := GetDistUnitXY ( i , x , y ) ;
54557: LD_ADDR_VAR 0 9
54561: PUSH
54562: LD_VAR 0 7
54566: PPUSH
54567: LD_VAR 0 1
54571: PPUSH
54572: LD_VAR 0 2
54576: PPUSH
54577: CALL_OW 297
54581: ST_TO_ADDR
// if not result then
54582: LD_VAR 0 6
54586: NOT
54587: IFFALSE 54613
// result := [ [ i , tmp ] ] else
54589: LD_ADDR_VAR 0 6
54593: PUSH
54594: LD_VAR 0 7
54598: PUSH
54599: LD_VAR 0 9
54603: PUSH
54604: EMPTY
54605: LIST
54606: LIST
54607: PUSH
54608: EMPTY
54609: LIST
54610: ST_TO_ADDR
54611: GO 54755
// begin if result [ result ] [ 2 ] < tmp then
54613: LD_VAR 0 6
54617: PUSH
54618: LD_VAR 0 6
54622: ARRAY
54623: PUSH
54624: LD_INT 2
54626: ARRAY
54627: PUSH
54628: LD_VAR 0 9
54632: LESS
54633: IFFALSE 54675
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
54635: LD_ADDR_VAR 0 6
54639: PUSH
54640: LD_VAR 0 6
54644: PPUSH
54645: LD_VAR 0 6
54649: PUSH
54650: LD_INT 1
54652: PLUS
54653: PPUSH
54654: LD_VAR 0 7
54658: PUSH
54659: LD_VAR 0 9
54663: PUSH
54664: EMPTY
54665: LIST
54666: LIST
54667: PPUSH
54668: CALL_OW 2
54672: ST_TO_ADDR
54673: GO 54755
// for j = 1 to result do
54675: LD_ADDR_VAR 0 8
54679: PUSH
54680: DOUBLE
54681: LD_INT 1
54683: DEC
54684: ST_TO_ADDR
54685: LD_VAR 0 6
54689: PUSH
54690: FOR_TO
54691: IFFALSE 54753
// begin if tmp < result [ j ] [ 2 ] then
54693: LD_VAR 0 9
54697: PUSH
54698: LD_VAR 0 6
54702: PUSH
54703: LD_VAR 0 8
54707: ARRAY
54708: PUSH
54709: LD_INT 2
54711: ARRAY
54712: LESS
54713: IFFALSE 54751
// begin result := Insert ( result , j , [ i , tmp ] ) ;
54715: LD_ADDR_VAR 0 6
54719: PUSH
54720: LD_VAR 0 6
54724: PPUSH
54725: LD_VAR 0 8
54729: PPUSH
54730: LD_VAR 0 7
54734: PUSH
54735: LD_VAR 0 9
54739: PUSH
54740: EMPTY
54741: LIST
54742: LIST
54743: PPUSH
54744: CALL_OW 2
54748: ST_TO_ADDR
// break ;
54749: GO 54753
// end ; end ;
54751: GO 54690
54753: POP
54754: POP
// end ; end ;
54755: GO 54554
54757: POP
54758: POP
// if result and not asc then
54759: LD_VAR 0 6
54763: PUSH
54764: LD_VAR 0 4
54768: NOT
54769: AND
54770: IFFALSE 54845
// begin tmp := result ;
54772: LD_ADDR_VAR 0 9
54776: PUSH
54777: LD_VAR 0 6
54781: ST_TO_ADDR
// for i = tmp downto 1 do
54782: LD_ADDR_VAR 0 7
54786: PUSH
54787: DOUBLE
54788: LD_VAR 0 9
54792: INC
54793: ST_TO_ADDR
54794: LD_INT 1
54796: PUSH
54797: FOR_DOWNTO
54798: IFFALSE 54843
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
54800: LD_ADDR_VAR 0 6
54804: PUSH
54805: LD_VAR 0 6
54809: PPUSH
54810: LD_VAR 0 9
54814: PUSH
54815: LD_VAR 0 7
54819: MINUS
54820: PUSH
54821: LD_INT 1
54823: PLUS
54824: PPUSH
54825: LD_VAR 0 9
54829: PUSH
54830: LD_VAR 0 7
54834: ARRAY
54835: PPUSH
54836: CALL_OW 1
54840: ST_TO_ADDR
54841: GO 54797
54843: POP
54844: POP
// end ; tmp := [ ] ;
54845: LD_ADDR_VAR 0 9
54849: PUSH
54850: EMPTY
54851: ST_TO_ADDR
// if mode then
54852: LD_VAR 0 5
54856: IFFALSE 54925
// begin for i = 1 to result do
54858: LD_ADDR_VAR 0 7
54862: PUSH
54863: DOUBLE
54864: LD_INT 1
54866: DEC
54867: ST_TO_ADDR
54868: LD_VAR 0 6
54872: PUSH
54873: FOR_TO
54874: IFFALSE 54913
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
54876: LD_ADDR_VAR 0 9
54880: PUSH
54881: LD_VAR 0 9
54885: PPUSH
54886: LD_VAR 0 7
54890: PPUSH
54891: LD_VAR 0 6
54895: PUSH
54896: LD_VAR 0 7
54900: ARRAY
54901: PUSH
54902: LD_INT 1
54904: ARRAY
54905: PPUSH
54906: CALL_OW 1
54910: ST_TO_ADDR
54911: GO 54873
54913: POP
54914: POP
// result := tmp ;
54915: LD_ADDR_VAR 0 6
54919: PUSH
54920: LD_VAR 0 9
54924: ST_TO_ADDR
// end ; end ;
54925: LD_VAR 0 6
54929: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
54930: LD_INT 0
54932: PPUSH
54933: PPUSH
54934: PPUSH
54935: PPUSH
54936: PPUSH
54937: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
54938: LD_ADDR_VAR 0 5
54942: PUSH
54943: LD_INT 0
54945: PUSH
54946: LD_INT 0
54948: PUSH
54949: LD_INT 0
54951: PUSH
54952: EMPTY
54953: PUSH
54954: EMPTY
54955: LIST
54956: LIST
54957: LIST
54958: LIST
54959: ST_TO_ADDR
// if not x or not y then
54960: LD_VAR 0 2
54964: NOT
54965: PUSH
54966: LD_VAR 0 3
54970: NOT
54971: OR
54972: IFFALSE 54976
// exit ;
54974: GO 56626
// if not range then
54976: LD_VAR 0 4
54980: NOT
54981: IFFALSE 54991
// range := 10 ;
54983: LD_ADDR_VAR 0 4
54987: PUSH
54988: LD_INT 10
54990: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
54991: LD_ADDR_VAR 0 8
54995: PUSH
54996: LD_INT 81
54998: PUSH
54999: LD_VAR 0 1
55003: PUSH
55004: EMPTY
55005: LIST
55006: LIST
55007: PUSH
55008: LD_INT 92
55010: PUSH
55011: LD_VAR 0 2
55015: PUSH
55016: LD_VAR 0 3
55020: PUSH
55021: LD_VAR 0 4
55025: PUSH
55026: EMPTY
55027: LIST
55028: LIST
55029: LIST
55030: LIST
55031: PUSH
55032: LD_INT 3
55034: PUSH
55035: LD_INT 21
55037: PUSH
55038: LD_INT 3
55040: PUSH
55041: EMPTY
55042: LIST
55043: LIST
55044: PUSH
55045: EMPTY
55046: LIST
55047: LIST
55048: PUSH
55049: EMPTY
55050: LIST
55051: LIST
55052: LIST
55053: PPUSH
55054: CALL_OW 69
55058: ST_TO_ADDR
// if not tmp then
55059: LD_VAR 0 8
55063: NOT
55064: IFFALSE 55068
// exit ;
55066: GO 56626
// for i in tmp do
55068: LD_ADDR_VAR 0 6
55072: PUSH
55073: LD_VAR 0 8
55077: PUSH
55078: FOR_IN
55079: IFFALSE 56601
// begin points := [ 0 , 0 , 0 ] ;
55081: LD_ADDR_VAR 0 9
55085: PUSH
55086: LD_INT 0
55088: PUSH
55089: LD_INT 0
55091: PUSH
55092: LD_INT 0
55094: PUSH
55095: EMPTY
55096: LIST
55097: LIST
55098: LIST
55099: ST_TO_ADDR
// bpoints := 1 ;
55100: LD_ADDR_VAR 0 10
55104: PUSH
55105: LD_INT 1
55107: ST_TO_ADDR
// case GetType ( i ) of unit_human :
55108: LD_VAR 0 6
55112: PPUSH
55113: CALL_OW 247
55117: PUSH
55118: LD_INT 1
55120: DOUBLE
55121: EQUAL
55122: IFTRUE 55126
55124: GO 55704
55126: POP
// begin if GetClass ( i ) = 1 then
55127: LD_VAR 0 6
55131: PPUSH
55132: CALL_OW 257
55136: PUSH
55137: LD_INT 1
55139: EQUAL
55140: IFFALSE 55161
// points := [ 10 , 5 , 3 ] ;
55142: LD_ADDR_VAR 0 9
55146: PUSH
55147: LD_INT 10
55149: PUSH
55150: LD_INT 5
55152: PUSH
55153: LD_INT 3
55155: PUSH
55156: EMPTY
55157: LIST
55158: LIST
55159: LIST
55160: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
55161: LD_VAR 0 6
55165: PPUSH
55166: CALL_OW 257
55170: PUSH
55171: LD_INT 2
55173: PUSH
55174: LD_INT 3
55176: PUSH
55177: LD_INT 4
55179: PUSH
55180: EMPTY
55181: LIST
55182: LIST
55183: LIST
55184: IN
55185: IFFALSE 55206
// points := [ 3 , 2 , 1 ] ;
55187: LD_ADDR_VAR 0 9
55191: PUSH
55192: LD_INT 3
55194: PUSH
55195: LD_INT 2
55197: PUSH
55198: LD_INT 1
55200: PUSH
55201: EMPTY
55202: LIST
55203: LIST
55204: LIST
55205: ST_TO_ADDR
// if GetClass ( i ) = 5 then
55206: LD_VAR 0 6
55210: PPUSH
55211: CALL_OW 257
55215: PUSH
55216: LD_INT 5
55218: EQUAL
55219: IFFALSE 55240
// points := [ 130 , 5 , 2 ] ;
55221: LD_ADDR_VAR 0 9
55225: PUSH
55226: LD_INT 130
55228: PUSH
55229: LD_INT 5
55231: PUSH
55232: LD_INT 2
55234: PUSH
55235: EMPTY
55236: LIST
55237: LIST
55238: LIST
55239: ST_TO_ADDR
// if GetClass ( i ) = 8 then
55240: LD_VAR 0 6
55244: PPUSH
55245: CALL_OW 257
55249: PUSH
55250: LD_INT 8
55252: EQUAL
55253: IFFALSE 55274
// points := [ 35 , 35 , 30 ] ;
55255: LD_ADDR_VAR 0 9
55259: PUSH
55260: LD_INT 35
55262: PUSH
55263: LD_INT 35
55265: PUSH
55266: LD_INT 30
55268: PUSH
55269: EMPTY
55270: LIST
55271: LIST
55272: LIST
55273: ST_TO_ADDR
// if GetClass ( i ) = 9 then
55274: LD_VAR 0 6
55278: PPUSH
55279: CALL_OW 257
55283: PUSH
55284: LD_INT 9
55286: EQUAL
55287: IFFALSE 55308
// points := [ 20 , 55 , 40 ] ;
55289: LD_ADDR_VAR 0 9
55293: PUSH
55294: LD_INT 20
55296: PUSH
55297: LD_INT 55
55299: PUSH
55300: LD_INT 40
55302: PUSH
55303: EMPTY
55304: LIST
55305: LIST
55306: LIST
55307: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
55308: LD_VAR 0 6
55312: PPUSH
55313: CALL_OW 257
55317: PUSH
55318: LD_INT 12
55320: PUSH
55321: LD_INT 16
55323: PUSH
55324: EMPTY
55325: LIST
55326: LIST
55327: IN
55328: IFFALSE 55349
// points := [ 5 , 3 , 2 ] ;
55330: LD_ADDR_VAR 0 9
55334: PUSH
55335: LD_INT 5
55337: PUSH
55338: LD_INT 3
55340: PUSH
55341: LD_INT 2
55343: PUSH
55344: EMPTY
55345: LIST
55346: LIST
55347: LIST
55348: ST_TO_ADDR
// if GetClass ( i ) = 17 then
55349: LD_VAR 0 6
55353: PPUSH
55354: CALL_OW 257
55358: PUSH
55359: LD_INT 17
55361: EQUAL
55362: IFFALSE 55383
// points := [ 100 , 50 , 75 ] ;
55364: LD_ADDR_VAR 0 9
55368: PUSH
55369: LD_INT 100
55371: PUSH
55372: LD_INT 50
55374: PUSH
55375: LD_INT 75
55377: PUSH
55378: EMPTY
55379: LIST
55380: LIST
55381: LIST
55382: ST_TO_ADDR
// if GetClass ( i ) = 15 then
55383: LD_VAR 0 6
55387: PPUSH
55388: CALL_OW 257
55392: PUSH
55393: LD_INT 15
55395: EQUAL
55396: IFFALSE 55417
// points := [ 10 , 5 , 3 ] ;
55398: LD_ADDR_VAR 0 9
55402: PUSH
55403: LD_INT 10
55405: PUSH
55406: LD_INT 5
55408: PUSH
55409: LD_INT 3
55411: PUSH
55412: EMPTY
55413: LIST
55414: LIST
55415: LIST
55416: ST_TO_ADDR
// if GetClass ( i ) = 14 then
55417: LD_VAR 0 6
55421: PPUSH
55422: CALL_OW 257
55426: PUSH
55427: LD_INT 14
55429: EQUAL
55430: IFFALSE 55451
// points := [ 10 , 0 , 0 ] ;
55432: LD_ADDR_VAR 0 9
55436: PUSH
55437: LD_INT 10
55439: PUSH
55440: LD_INT 0
55442: PUSH
55443: LD_INT 0
55445: PUSH
55446: EMPTY
55447: LIST
55448: LIST
55449: LIST
55450: ST_TO_ADDR
// if GetClass ( i ) = 11 then
55451: LD_VAR 0 6
55455: PPUSH
55456: CALL_OW 257
55460: PUSH
55461: LD_INT 11
55463: EQUAL
55464: IFFALSE 55485
// points := [ 30 , 10 , 5 ] ;
55466: LD_ADDR_VAR 0 9
55470: PUSH
55471: LD_INT 30
55473: PUSH
55474: LD_INT 10
55476: PUSH
55477: LD_INT 5
55479: PUSH
55480: EMPTY
55481: LIST
55482: LIST
55483: LIST
55484: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
55485: LD_VAR 0 1
55489: PPUSH
55490: LD_INT 5
55492: PPUSH
55493: CALL_OW 321
55497: PUSH
55498: LD_INT 2
55500: EQUAL
55501: IFFALSE 55518
// bpoints := bpoints * 1.8 ;
55503: LD_ADDR_VAR 0 10
55507: PUSH
55508: LD_VAR 0 10
55512: PUSH
55513: LD_REAL  1.80000000000000E+0000
55516: MUL
55517: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
55518: LD_VAR 0 6
55522: PPUSH
55523: CALL_OW 257
55527: PUSH
55528: LD_INT 1
55530: PUSH
55531: LD_INT 2
55533: PUSH
55534: LD_INT 3
55536: PUSH
55537: LD_INT 4
55539: PUSH
55540: EMPTY
55541: LIST
55542: LIST
55543: LIST
55544: LIST
55545: IN
55546: PUSH
55547: LD_VAR 0 1
55551: PPUSH
55552: LD_INT 51
55554: PPUSH
55555: CALL_OW 321
55559: PUSH
55560: LD_INT 2
55562: EQUAL
55563: AND
55564: IFFALSE 55581
// bpoints := bpoints * 1.2 ;
55566: LD_ADDR_VAR 0 10
55570: PUSH
55571: LD_VAR 0 10
55575: PUSH
55576: LD_REAL  1.20000000000000E+0000
55579: MUL
55580: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
55581: LD_VAR 0 6
55585: PPUSH
55586: CALL_OW 257
55590: PUSH
55591: LD_INT 5
55593: PUSH
55594: LD_INT 7
55596: PUSH
55597: LD_INT 9
55599: PUSH
55600: EMPTY
55601: LIST
55602: LIST
55603: LIST
55604: IN
55605: PUSH
55606: LD_VAR 0 1
55610: PPUSH
55611: LD_INT 52
55613: PPUSH
55614: CALL_OW 321
55618: PUSH
55619: LD_INT 2
55621: EQUAL
55622: AND
55623: IFFALSE 55640
// bpoints := bpoints * 1.5 ;
55625: LD_ADDR_VAR 0 10
55629: PUSH
55630: LD_VAR 0 10
55634: PUSH
55635: LD_REAL  1.50000000000000E+0000
55638: MUL
55639: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
55640: LD_VAR 0 1
55644: PPUSH
55645: LD_INT 66
55647: PPUSH
55648: CALL_OW 321
55652: PUSH
55653: LD_INT 2
55655: EQUAL
55656: IFFALSE 55673
// bpoints := bpoints * 1.1 ;
55658: LD_ADDR_VAR 0 10
55662: PUSH
55663: LD_VAR 0 10
55667: PUSH
55668: LD_REAL  1.10000000000000E+0000
55671: MUL
55672: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
55673: LD_ADDR_VAR 0 10
55677: PUSH
55678: LD_VAR 0 10
55682: PUSH
55683: LD_VAR 0 6
55687: PPUSH
55688: LD_INT 1
55690: PPUSH
55691: CALL_OW 259
55695: PUSH
55696: LD_REAL  1.15000000000000E+0000
55699: MUL
55700: MUL
55701: ST_TO_ADDR
// end ; unit_vehicle :
55702: GO 56530
55704: LD_INT 2
55706: DOUBLE
55707: EQUAL
55708: IFTRUE 55712
55710: GO 56518
55712: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
55713: LD_VAR 0 6
55717: PPUSH
55718: CALL_OW 264
55722: PUSH
55723: LD_INT 2
55725: PUSH
55726: LD_INT 42
55728: PUSH
55729: LD_INT 24
55731: PUSH
55732: EMPTY
55733: LIST
55734: LIST
55735: LIST
55736: IN
55737: IFFALSE 55758
// points := [ 25 , 5 , 3 ] ;
55739: LD_ADDR_VAR 0 9
55743: PUSH
55744: LD_INT 25
55746: PUSH
55747: LD_INT 5
55749: PUSH
55750: LD_INT 3
55752: PUSH
55753: EMPTY
55754: LIST
55755: LIST
55756: LIST
55757: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
55758: LD_VAR 0 6
55762: PPUSH
55763: CALL_OW 264
55767: PUSH
55768: LD_INT 4
55770: PUSH
55771: LD_INT 43
55773: PUSH
55774: LD_INT 25
55776: PUSH
55777: EMPTY
55778: LIST
55779: LIST
55780: LIST
55781: IN
55782: IFFALSE 55803
// points := [ 40 , 15 , 5 ] ;
55784: LD_ADDR_VAR 0 9
55788: PUSH
55789: LD_INT 40
55791: PUSH
55792: LD_INT 15
55794: PUSH
55795: LD_INT 5
55797: PUSH
55798: EMPTY
55799: LIST
55800: LIST
55801: LIST
55802: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
55803: LD_VAR 0 6
55807: PPUSH
55808: CALL_OW 264
55812: PUSH
55813: LD_INT 3
55815: PUSH
55816: LD_INT 23
55818: PUSH
55819: EMPTY
55820: LIST
55821: LIST
55822: IN
55823: IFFALSE 55844
// points := [ 7 , 25 , 8 ] ;
55825: LD_ADDR_VAR 0 9
55829: PUSH
55830: LD_INT 7
55832: PUSH
55833: LD_INT 25
55835: PUSH
55836: LD_INT 8
55838: PUSH
55839: EMPTY
55840: LIST
55841: LIST
55842: LIST
55843: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
55844: LD_VAR 0 6
55848: PPUSH
55849: CALL_OW 264
55853: PUSH
55854: LD_INT 5
55856: PUSH
55857: LD_INT 27
55859: PUSH
55860: LD_INT 44
55862: PUSH
55863: EMPTY
55864: LIST
55865: LIST
55866: LIST
55867: IN
55868: IFFALSE 55889
// points := [ 14 , 50 , 16 ] ;
55870: LD_ADDR_VAR 0 9
55874: PUSH
55875: LD_INT 14
55877: PUSH
55878: LD_INT 50
55880: PUSH
55881: LD_INT 16
55883: PUSH
55884: EMPTY
55885: LIST
55886: LIST
55887: LIST
55888: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
55889: LD_VAR 0 6
55893: PPUSH
55894: CALL_OW 264
55898: PUSH
55899: LD_INT 6
55901: PUSH
55902: LD_INT 46
55904: PUSH
55905: EMPTY
55906: LIST
55907: LIST
55908: IN
55909: IFFALSE 55930
// points := [ 32 , 120 , 70 ] ;
55911: LD_ADDR_VAR 0 9
55915: PUSH
55916: LD_INT 32
55918: PUSH
55919: LD_INT 120
55921: PUSH
55922: LD_INT 70
55924: PUSH
55925: EMPTY
55926: LIST
55927: LIST
55928: LIST
55929: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
55930: LD_VAR 0 6
55934: PPUSH
55935: CALL_OW 264
55939: PUSH
55940: LD_INT 7
55942: PUSH
55943: LD_INT 28
55945: PUSH
55946: LD_INT 45
55948: PUSH
55949: LD_INT 92
55951: PUSH
55952: EMPTY
55953: LIST
55954: LIST
55955: LIST
55956: LIST
55957: IN
55958: IFFALSE 55979
// points := [ 35 , 20 , 45 ] ;
55960: LD_ADDR_VAR 0 9
55964: PUSH
55965: LD_INT 35
55967: PUSH
55968: LD_INT 20
55970: PUSH
55971: LD_INT 45
55973: PUSH
55974: EMPTY
55975: LIST
55976: LIST
55977: LIST
55978: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
55979: LD_VAR 0 6
55983: PPUSH
55984: CALL_OW 264
55988: PUSH
55989: LD_INT 47
55991: PUSH
55992: EMPTY
55993: LIST
55994: IN
55995: IFFALSE 56016
// points := [ 67 , 45 , 75 ] ;
55997: LD_ADDR_VAR 0 9
56001: PUSH
56002: LD_INT 67
56004: PUSH
56005: LD_INT 45
56007: PUSH
56008: LD_INT 75
56010: PUSH
56011: EMPTY
56012: LIST
56013: LIST
56014: LIST
56015: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
56016: LD_VAR 0 6
56020: PPUSH
56021: CALL_OW 264
56025: PUSH
56026: LD_INT 26
56028: PUSH
56029: EMPTY
56030: LIST
56031: IN
56032: IFFALSE 56053
// points := [ 120 , 30 , 80 ] ;
56034: LD_ADDR_VAR 0 9
56038: PUSH
56039: LD_INT 120
56041: PUSH
56042: LD_INT 30
56044: PUSH
56045: LD_INT 80
56047: PUSH
56048: EMPTY
56049: LIST
56050: LIST
56051: LIST
56052: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
56053: LD_VAR 0 6
56057: PPUSH
56058: CALL_OW 264
56062: PUSH
56063: LD_INT 22
56065: PUSH
56066: EMPTY
56067: LIST
56068: IN
56069: IFFALSE 56090
// points := [ 40 , 1 , 1 ] ;
56071: LD_ADDR_VAR 0 9
56075: PUSH
56076: LD_INT 40
56078: PUSH
56079: LD_INT 1
56081: PUSH
56082: LD_INT 1
56084: PUSH
56085: EMPTY
56086: LIST
56087: LIST
56088: LIST
56089: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
56090: LD_VAR 0 6
56094: PPUSH
56095: CALL_OW 264
56099: PUSH
56100: LD_INT 29
56102: PUSH
56103: EMPTY
56104: LIST
56105: IN
56106: IFFALSE 56127
// points := [ 70 , 200 , 400 ] ;
56108: LD_ADDR_VAR 0 9
56112: PUSH
56113: LD_INT 70
56115: PUSH
56116: LD_INT 200
56118: PUSH
56119: LD_INT 400
56121: PUSH
56122: EMPTY
56123: LIST
56124: LIST
56125: LIST
56126: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
56127: LD_VAR 0 6
56131: PPUSH
56132: CALL_OW 264
56136: PUSH
56137: LD_INT 14
56139: PUSH
56140: LD_INT 53
56142: PUSH
56143: EMPTY
56144: LIST
56145: LIST
56146: IN
56147: IFFALSE 56168
// points := [ 40 , 10 , 20 ] ;
56149: LD_ADDR_VAR 0 9
56153: PUSH
56154: LD_INT 40
56156: PUSH
56157: LD_INT 10
56159: PUSH
56160: LD_INT 20
56162: PUSH
56163: EMPTY
56164: LIST
56165: LIST
56166: LIST
56167: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
56168: LD_VAR 0 6
56172: PPUSH
56173: CALL_OW 264
56177: PUSH
56178: LD_INT 9
56180: PUSH
56181: EMPTY
56182: LIST
56183: IN
56184: IFFALSE 56205
// points := [ 5 , 70 , 20 ] ;
56186: LD_ADDR_VAR 0 9
56190: PUSH
56191: LD_INT 5
56193: PUSH
56194: LD_INT 70
56196: PUSH
56197: LD_INT 20
56199: PUSH
56200: EMPTY
56201: LIST
56202: LIST
56203: LIST
56204: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
56205: LD_VAR 0 6
56209: PPUSH
56210: CALL_OW 264
56214: PUSH
56215: LD_INT 10
56217: PUSH
56218: EMPTY
56219: LIST
56220: IN
56221: IFFALSE 56242
// points := [ 35 , 110 , 70 ] ;
56223: LD_ADDR_VAR 0 9
56227: PUSH
56228: LD_INT 35
56230: PUSH
56231: LD_INT 110
56233: PUSH
56234: LD_INT 70
56236: PUSH
56237: EMPTY
56238: LIST
56239: LIST
56240: LIST
56241: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
56242: LD_VAR 0 6
56246: PPUSH
56247: CALL_OW 265
56251: PUSH
56252: LD_INT 25
56254: EQUAL
56255: IFFALSE 56276
// points := [ 80 , 65 , 100 ] ;
56257: LD_ADDR_VAR 0 9
56261: PUSH
56262: LD_INT 80
56264: PUSH
56265: LD_INT 65
56267: PUSH
56268: LD_INT 100
56270: PUSH
56271: EMPTY
56272: LIST
56273: LIST
56274: LIST
56275: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
56276: LD_VAR 0 6
56280: PPUSH
56281: CALL_OW 263
56285: PUSH
56286: LD_INT 1
56288: EQUAL
56289: IFFALSE 56324
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
56291: LD_ADDR_VAR 0 10
56295: PUSH
56296: LD_VAR 0 10
56300: PUSH
56301: LD_VAR 0 6
56305: PPUSH
56306: CALL_OW 311
56310: PPUSH
56311: LD_INT 3
56313: PPUSH
56314: CALL_OW 259
56318: PUSH
56319: LD_INT 4
56321: MUL
56322: MUL
56323: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
56324: LD_VAR 0 6
56328: PPUSH
56329: CALL_OW 263
56333: PUSH
56334: LD_INT 2
56336: EQUAL
56337: IFFALSE 56388
// begin j := IsControledBy ( i ) ;
56339: LD_ADDR_VAR 0 7
56343: PUSH
56344: LD_VAR 0 6
56348: PPUSH
56349: CALL_OW 312
56353: ST_TO_ADDR
// if j then
56354: LD_VAR 0 7
56358: IFFALSE 56388
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
56360: LD_ADDR_VAR 0 10
56364: PUSH
56365: LD_VAR 0 10
56369: PUSH
56370: LD_VAR 0 7
56374: PPUSH
56375: LD_INT 3
56377: PPUSH
56378: CALL_OW 259
56382: PUSH
56383: LD_INT 3
56385: MUL
56386: MUL
56387: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
56388: LD_VAR 0 6
56392: PPUSH
56393: CALL_OW 264
56397: PUSH
56398: LD_INT 5
56400: PUSH
56401: LD_INT 6
56403: PUSH
56404: LD_INT 46
56406: PUSH
56407: LD_INT 44
56409: PUSH
56410: LD_INT 47
56412: PUSH
56413: LD_INT 45
56415: PUSH
56416: LD_INT 28
56418: PUSH
56419: LD_INT 7
56421: PUSH
56422: LD_INT 27
56424: PUSH
56425: LD_INT 29
56427: PUSH
56428: EMPTY
56429: LIST
56430: LIST
56431: LIST
56432: LIST
56433: LIST
56434: LIST
56435: LIST
56436: LIST
56437: LIST
56438: LIST
56439: IN
56440: PUSH
56441: LD_VAR 0 1
56445: PPUSH
56446: LD_INT 52
56448: PPUSH
56449: CALL_OW 321
56453: PUSH
56454: LD_INT 2
56456: EQUAL
56457: AND
56458: IFFALSE 56475
// bpoints := bpoints * 1.2 ;
56460: LD_ADDR_VAR 0 10
56464: PUSH
56465: LD_VAR 0 10
56469: PUSH
56470: LD_REAL  1.20000000000000E+0000
56473: MUL
56474: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
56475: LD_VAR 0 6
56479: PPUSH
56480: CALL_OW 264
56484: PUSH
56485: LD_INT 6
56487: PUSH
56488: LD_INT 46
56490: PUSH
56491: LD_INT 47
56493: PUSH
56494: EMPTY
56495: LIST
56496: LIST
56497: LIST
56498: IN
56499: IFFALSE 56516
// bpoints := bpoints * 1.2 ;
56501: LD_ADDR_VAR 0 10
56505: PUSH
56506: LD_VAR 0 10
56510: PUSH
56511: LD_REAL  1.20000000000000E+0000
56514: MUL
56515: ST_TO_ADDR
// end ; unit_building :
56516: GO 56530
56518: LD_INT 3
56520: DOUBLE
56521: EQUAL
56522: IFTRUE 56526
56524: GO 56529
56526: POP
// ; end ;
56527: GO 56530
56529: POP
// for j = 1 to 3 do
56530: LD_ADDR_VAR 0 7
56534: PUSH
56535: DOUBLE
56536: LD_INT 1
56538: DEC
56539: ST_TO_ADDR
56540: LD_INT 3
56542: PUSH
56543: FOR_TO
56544: IFFALSE 56597
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
56546: LD_ADDR_VAR 0 5
56550: PUSH
56551: LD_VAR 0 5
56555: PPUSH
56556: LD_VAR 0 7
56560: PPUSH
56561: LD_VAR 0 5
56565: PUSH
56566: LD_VAR 0 7
56570: ARRAY
56571: PUSH
56572: LD_VAR 0 9
56576: PUSH
56577: LD_VAR 0 7
56581: ARRAY
56582: PUSH
56583: LD_VAR 0 10
56587: MUL
56588: PLUS
56589: PPUSH
56590: CALL_OW 1
56594: ST_TO_ADDR
56595: GO 56543
56597: POP
56598: POP
// end ;
56599: GO 55078
56601: POP
56602: POP
// result := Replace ( result , 4 , tmp ) ;
56603: LD_ADDR_VAR 0 5
56607: PUSH
56608: LD_VAR 0 5
56612: PPUSH
56613: LD_INT 4
56615: PPUSH
56616: LD_VAR 0 8
56620: PPUSH
56621: CALL_OW 1
56625: ST_TO_ADDR
// end ;
56626: LD_VAR 0 5
56630: RET
// export function DangerAtRange ( unit , range ) ; begin
56631: LD_INT 0
56633: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
56634: LD_ADDR_VAR 0 3
56638: PUSH
56639: LD_VAR 0 1
56643: PPUSH
56644: CALL_OW 255
56648: PPUSH
56649: LD_VAR 0 1
56653: PPUSH
56654: CALL_OW 250
56658: PPUSH
56659: LD_VAR 0 1
56663: PPUSH
56664: CALL_OW 251
56668: PPUSH
56669: LD_VAR 0 2
56673: PPUSH
56674: CALL 54930 0 4
56678: ST_TO_ADDR
// end ;
56679: LD_VAR 0 3
56683: RET
// export function DangerInArea ( side , area ) ; begin
56684: LD_INT 0
56686: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
56687: LD_ADDR_VAR 0 3
56691: PUSH
56692: LD_VAR 0 2
56696: PPUSH
56697: LD_INT 81
56699: PUSH
56700: LD_VAR 0 1
56704: PUSH
56705: EMPTY
56706: LIST
56707: LIST
56708: PPUSH
56709: CALL_OW 70
56713: ST_TO_ADDR
// end ;
56714: LD_VAR 0 3
56718: RET
// export function IsExtension ( b ) ; begin
56719: LD_INT 0
56721: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
56722: LD_ADDR_VAR 0 2
56726: PUSH
56727: LD_VAR 0 1
56731: PUSH
56732: LD_INT 23
56734: PUSH
56735: LD_INT 20
56737: PUSH
56738: LD_INT 22
56740: PUSH
56741: LD_INT 17
56743: PUSH
56744: LD_INT 24
56746: PUSH
56747: LD_INT 21
56749: PUSH
56750: LD_INT 19
56752: PUSH
56753: LD_INT 16
56755: PUSH
56756: LD_INT 25
56758: PUSH
56759: LD_INT 18
56761: PUSH
56762: EMPTY
56763: LIST
56764: LIST
56765: LIST
56766: LIST
56767: LIST
56768: LIST
56769: LIST
56770: LIST
56771: LIST
56772: LIST
56773: IN
56774: ST_TO_ADDR
// end ;
56775: LD_VAR 0 2
56779: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
56780: LD_INT 0
56782: PPUSH
56783: PPUSH
56784: PPUSH
// result := [ ] ;
56785: LD_ADDR_VAR 0 4
56789: PUSH
56790: EMPTY
56791: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
56792: LD_ADDR_VAR 0 5
56796: PUSH
56797: LD_VAR 0 2
56801: PPUSH
56802: LD_INT 21
56804: PUSH
56805: LD_INT 3
56807: PUSH
56808: EMPTY
56809: LIST
56810: LIST
56811: PPUSH
56812: CALL_OW 70
56816: ST_TO_ADDR
// if not tmp then
56817: LD_VAR 0 5
56821: NOT
56822: IFFALSE 56826
// exit ;
56824: GO 56890
// if checkLink then
56826: LD_VAR 0 3
56830: IFFALSE 56880
// begin for i in tmp do
56832: LD_ADDR_VAR 0 6
56836: PUSH
56837: LD_VAR 0 5
56841: PUSH
56842: FOR_IN
56843: IFFALSE 56878
// if GetBase ( i ) <> base then
56845: LD_VAR 0 6
56849: PPUSH
56850: CALL_OW 274
56854: PUSH
56855: LD_VAR 0 1
56859: NONEQUAL
56860: IFFALSE 56876
// ComLinkToBase ( base , i ) ;
56862: LD_VAR 0 1
56866: PPUSH
56867: LD_VAR 0 6
56871: PPUSH
56872: CALL_OW 169
56876: GO 56842
56878: POP
56879: POP
// end ; result := tmp ;
56880: LD_ADDR_VAR 0 4
56884: PUSH
56885: LD_VAR 0 5
56889: ST_TO_ADDR
// end ;
56890: LD_VAR 0 4
56894: RET
// export function ComComplete ( units , b ) ; var i ; begin
56895: LD_INT 0
56897: PPUSH
56898: PPUSH
// if not units then
56899: LD_VAR 0 1
56903: NOT
56904: IFFALSE 56908
// exit ;
56906: GO 56998
// for i in units do
56908: LD_ADDR_VAR 0 4
56912: PUSH
56913: LD_VAR 0 1
56917: PUSH
56918: FOR_IN
56919: IFFALSE 56996
// if BuildingStatus ( b ) = bs_build then
56921: LD_VAR 0 2
56925: PPUSH
56926: CALL_OW 461
56930: PUSH
56931: LD_INT 1
56933: EQUAL
56934: IFFALSE 56994
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
56936: LD_VAR 0 4
56940: PPUSH
56941: LD_STRING h
56943: PUSH
56944: LD_VAR 0 2
56948: PPUSH
56949: CALL_OW 250
56953: PUSH
56954: LD_VAR 0 2
56958: PPUSH
56959: CALL_OW 251
56963: PUSH
56964: LD_VAR 0 2
56968: PUSH
56969: LD_INT 0
56971: PUSH
56972: LD_INT 0
56974: PUSH
56975: LD_INT 0
56977: PUSH
56978: EMPTY
56979: LIST
56980: LIST
56981: LIST
56982: LIST
56983: LIST
56984: LIST
56985: LIST
56986: PUSH
56987: EMPTY
56988: LIST
56989: PPUSH
56990: CALL_OW 446
56994: GO 56918
56996: POP
56997: POP
// end ;
56998: LD_VAR 0 3
57002: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
57003: LD_INT 0
57005: PPUSH
57006: PPUSH
57007: PPUSH
57008: PPUSH
57009: PPUSH
57010: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
57011: LD_VAR 0 1
57015: NOT
57016: PUSH
57017: LD_VAR 0 1
57021: PPUSH
57022: CALL_OW 263
57026: PUSH
57027: LD_INT 2
57029: NONEQUAL
57030: OR
57031: IFFALSE 57035
// exit ;
57033: GO 57351
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
57035: LD_ADDR_VAR 0 6
57039: PUSH
57040: LD_INT 22
57042: PUSH
57043: LD_VAR 0 1
57047: PPUSH
57048: CALL_OW 255
57052: PUSH
57053: EMPTY
57054: LIST
57055: LIST
57056: PUSH
57057: LD_INT 2
57059: PUSH
57060: LD_INT 30
57062: PUSH
57063: LD_INT 36
57065: PUSH
57066: EMPTY
57067: LIST
57068: LIST
57069: PUSH
57070: LD_INT 34
57072: PUSH
57073: LD_INT 31
57075: PUSH
57076: EMPTY
57077: LIST
57078: LIST
57079: PUSH
57080: EMPTY
57081: LIST
57082: LIST
57083: LIST
57084: PUSH
57085: EMPTY
57086: LIST
57087: LIST
57088: PPUSH
57089: CALL_OW 69
57093: ST_TO_ADDR
// if not tmp then
57094: LD_VAR 0 6
57098: NOT
57099: IFFALSE 57103
// exit ;
57101: GO 57351
// result := [ ] ;
57103: LD_ADDR_VAR 0 2
57107: PUSH
57108: EMPTY
57109: ST_TO_ADDR
// for i in tmp do
57110: LD_ADDR_VAR 0 3
57114: PUSH
57115: LD_VAR 0 6
57119: PUSH
57120: FOR_IN
57121: IFFALSE 57192
// begin t := UnitsInside ( i ) ;
57123: LD_ADDR_VAR 0 4
57127: PUSH
57128: LD_VAR 0 3
57132: PPUSH
57133: CALL_OW 313
57137: ST_TO_ADDR
// if t then
57138: LD_VAR 0 4
57142: IFFALSE 57190
// for j in t do
57144: LD_ADDR_VAR 0 7
57148: PUSH
57149: LD_VAR 0 4
57153: PUSH
57154: FOR_IN
57155: IFFALSE 57188
// result := Replace ( result , result + 1 , j ) ;
57157: LD_ADDR_VAR 0 2
57161: PUSH
57162: LD_VAR 0 2
57166: PPUSH
57167: LD_VAR 0 2
57171: PUSH
57172: LD_INT 1
57174: PLUS
57175: PPUSH
57176: LD_VAR 0 7
57180: PPUSH
57181: CALL_OW 1
57185: ST_TO_ADDR
57186: GO 57154
57188: POP
57189: POP
// end ;
57190: GO 57120
57192: POP
57193: POP
// if not result then
57194: LD_VAR 0 2
57198: NOT
57199: IFFALSE 57203
// exit ;
57201: GO 57351
// mech := result [ 1 ] ;
57203: LD_ADDR_VAR 0 5
57207: PUSH
57208: LD_VAR 0 2
57212: PUSH
57213: LD_INT 1
57215: ARRAY
57216: ST_TO_ADDR
// if result > 1 then
57217: LD_VAR 0 2
57221: PUSH
57222: LD_INT 1
57224: GREATER
57225: IFFALSE 57337
// begin for i = 2 to result do
57227: LD_ADDR_VAR 0 3
57231: PUSH
57232: DOUBLE
57233: LD_INT 2
57235: DEC
57236: ST_TO_ADDR
57237: LD_VAR 0 2
57241: PUSH
57242: FOR_TO
57243: IFFALSE 57335
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
57245: LD_ADDR_VAR 0 4
57249: PUSH
57250: LD_VAR 0 2
57254: PUSH
57255: LD_VAR 0 3
57259: ARRAY
57260: PPUSH
57261: LD_INT 3
57263: PPUSH
57264: CALL_OW 259
57268: PUSH
57269: LD_VAR 0 2
57273: PUSH
57274: LD_VAR 0 3
57278: ARRAY
57279: PPUSH
57280: CALL_OW 432
57284: MINUS
57285: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
57286: LD_VAR 0 4
57290: PUSH
57291: LD_VAR 0 5
57295: PPUSH
57296: LD_INT 3
57298: PPUSH
57299: CALL_OW 259
57303: PUSH
57304: LD_VAR 0 5
57308: PPUSH
57309: CALL_OW 432
57313: MINUS
57314: GREATEREQUAL
57315: IFFALSE 57333
// mech := result [ i ] ;
57317: LD_ADDR_VAR 0 5
57321: PUSH
57322: LD_VAR 0 2
57326: PUSH
57327: LD_VAR 0 3
57331: ARRAY
57332: ST_TO_ADDR
// end ;
57333: GO 57242
57335: POP
57336: POP
// end ; ComLinkTo ( vehicle , mech ) ;
57337: LD_VAR 0 1
57341: PPUSH
57342: LD_VAR 0 5
57346: PPUSH
57347: CALL_OW 135
// end ;
57351: LD_VAR 0 2
57355: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
57356: LD_INT 0
57358: PPUSH
57359: PPUSH
57360: PPUSH
57361: PPUSH
57362: PPUSH
57363: PPUSH
57364: PPUSH
57365: PPUSH
57366: PPUSH
57367: PPUSH
57368: PPUSH
57369: PPUSH
57370: PPUSH
// result := [ ] ;
57371: LD_ADDR_VAR 0 7
57375: PUSH
57376: EMPTY
57377: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
57378: LD_VAR 0 1
57382: PPUSH
57383: CALL_OW 266
57387: PUSH
57388: LD_INT 0
57390: PUSH
57391: LD_INT 1
57393: PUSH
57394: EMPTY
57395: LIST
57396: LIST
57397: IN
57398: NOT
57399: IFFALSE 57403
// exit ;
57401: GO 59037
// if name then
57403: LD_VAR 0 3
57407: IFFALSE 57423
// SetBName ( base_dep , name ) ;
57409: LD_VAR 0 1
57413: PPUSH
57414: LD_VAR 0 3
57418: PPUSH
57419: CALL_OW 500
// base := GetBase ( base_dep ) ;
57423: LD_ADDR_VAR 0 15
57427: PUSH
57428: LD_VAR 0 1
57432: PPUSH
57433: CALL_OW 274
57437: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
57438: LD_ADDR_VAR 0 16
57442: PUSH
57443: LD_VAR 0 1
57447: PPUSH
57448: CALL_OW 255
57452: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
57453: LD_ADDR_VAR 0 17
57457: PUSH
57458: LD_VAR 0 1
57462: PPUSH
57463: CALL_OW 248
57467: ST_TO_ADDR
// if sources then
57468: LD_VAR 0 5
57472: IFFALSE 57519
// for i = 1 to 3 do
57474: LD_ADDR_VAR 0 8
57478: PUSH
57479: DOUBLE
57480: LD_INT 1
57482: DEC
57483: ST_TO_ADDR
57484: LD_INT 3
57486: PUSH
57487: FOR_TO
57488: IFFALSE 57517
// AddResourceType ( base , i , sources [ i ] ) ;
57490: LD_VAR 0 15
57494: PPUSH
57495: LD_VAR 0 8
57499: PPUSH
57500: LD_VAR 0 5
57504: PUSH
57505: LD_VAR 0 8
57509: ARRAY
57510: PPUSH
57511: CALL_OW 276
57515: GO 57487
57517: POP
57518: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
57519: LD_ADDR_VAR 0 18
57523: PUSH
57524: LD_VAR 0 15
57528: PPUSH
57529: LD_VAR 0 2
57533: PPUSH
57534: LD_INT 1
57536: PPUSH
57537: CALL 56780 0 3
57541: ST_TO_ADDR
// InitHc ;
57542: CALL_OW 19
// InitUc ;
57546: CALL_OW 18
// uc_side := side ;
57550: LD_ADDR_OWVAR 20
57554: PUSH
57555: LD_VAR 0 16
57559: ST_TO_ADDR
// uc_nation := nation ;
57560: LD_ADDR_OWVAR 21
57564: PUSH
57565: LD_VAR 0 17
57569: ST_TO_ADDR
// if buildings then
57570: LD_VAR 0 18
57574: IFFALSE 58896
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
57576: LD_ADDR_VAR 0 19
57580: PUSH
57581: LD_VAR 0 18
57585: PPUSH
57586: LD_INT 2
57588: PUSH
57589: LD_INT 30
57591: PUSH
57592: LD_INT 29
57594: PUSH
57595: EMPTY
57596: LIST
57597: LIST
57598: PUSH
57599: LD_INT 30
57601: PUSH
57602: LD_INT 30
57604: PUSH
57605: EMPTY
57606: LIST
57607: LIST
57608: PUSH
57609: EMPTY
57610: LIST
57611: LIST
57612: LIST
57613: PPUSH
57614: CALL_OW 72
57618: ST_TO_ADDR
// if tmp then
57619: LD_VAR 0 19
57623: IFFALSE 57671
// for i in tmp do
57625: LD_ADDR_VAR 0 8
57629: PUSH
57630: LD_VAR 0 19
57634: PUSH
57635: FOR_IN
57636: IFFALSE 57669
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
57638: LD_VAR 0 8
57642: PPUSH
57643: CALL_OW 250
57647: PPUSH
57648: LD_VAR 0 8
57652: PPUSH
57653: CALL_OW 251
57657: PPUSH
57658: LD_VAR 0 16
57662: PPUSH
57663: CALL_OW 441
57667: GO 57635
57669: POP
57670: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
57671: LD_VAR 0 18
57675: PPUSH
57676: LD_INT 2
57678: PUSH
57679: LD_INT 30
57681: PUSH
57682: LD_INT 32
57684: PUSH
57685: EMPTY
57686: LIST
57687: LIST
57688: PUSH
57689: LD_INT 30
57691: PUSH
57692: LD_INT 33
57694: PUSH
57695: EMPTY
57696: LIST
57697: LIST
57698: PUSH
57699: EMPTY
57700: LIST
57701: LIST
57702: LIST
57703: PPUSH
57704: CALL_OW 72
57708: IFFALSE 57796
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
57710: LD_ADDR_VAR 0 8
57714: PUSH
57715: LD_VAR 0 18
57719: PPUSH
57720: LD_INT 2
57722: PUSH
57723: LD_INT 30
57725: PUSH
57726: LD_INT 32
57728: PUSH
57729: EMPTY
57730: LIST
57731: LIST
57732: PUSH
57733: LD_INT 30
57735: PUSH
57736: LD_INT 33
57738: PUSH
57739: EMPTY
57740: LIST
57741: LIST
57742: PUSH
57743: EMPTY
57744: LIST
57745: LIST
57746: LIST
57747: PPUSH
57748: CALL_OW 72
57752: PUSH
57753: FOR_IN
57754: IFFALSE 57794
// begin if not GetBWeapon ( i ) then
57756: LD_VAR 0 8
57760: PPUSH
57761: CALL_OW 269
57765: NOT
57766: IFFALSE 57792
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
57768: LD_VAR 0 8
57772: PPUSH
57773: LD_VAR 0 8
57777: PPUSH
57778: LD_VAR 0 2
57782: PPUSH
57783: CALL 59042 0 2
57787: PPUSH
57788: CALL_OW 431
// end ;
57792: GO 57753
57794: POP
57795: POP
// end ; for i = 1 to personel do
57796: LD_ADDR_VAR 0 8
57800: PUSH
57801: DOUBLE
57802: LD_INT 1
57804: DEC
57805: ST_TO_ADDR
57806: LD_VAR 0 6
57810: PUSH
57811: FOR_TO
57812: IFFALSE 58876
// begin if i > 4 then
57814: LD_VAR 0 8
57818: PUSH
57819: LD_INT 4
57821: GREATER
57822: IFFALSE 57826
// break ;
57824: GO 58876
// case i of 1 :
57826: LD_VAR 0 8
57830: PUSH
57831: LD_INT 1
57833: DOUBLE
57834: EQUAL
57835: IFTRUE 57839
57837: GO 57919
57839: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
57840: LD_ADDR_VAR 0 12
57844: PUSH
57845: LD_VAR 0 18
57849: PPUSH
57850: LD_INT 22
57852: PUSH
57853: LD_VAR 0 16
57857: PUSH
57858: EMPTY
57859: LIST
57860: LIST
57861: PUSH
57862: LD_INT 58
57864: PUSH
57865: EMPTY
57866: LIST
57867: PUSH
57868: LD_INT 2
57870: PUSH
57871: LD_INT 30
57873: PUSH
57874: LD_INT 32
57876: PUSH
57877: EMPTY
57878: LIST
57879: LIST
57880: PUSH
57881: LD_INT 30
57883: PUSH
57884: LD_INT 4
57886: PUSH
57887: EMPTY
57888: LIST
57889: LIST
57890: PUSH
57891: LD_INT 30
57893: PUSH
57894: LD_INT 5
57896: PUSH
57897: EMPTY
57898: LIST
57899: LIST
57900: PUSH
57901: EMPTY
57902: LIST
57903: LIST
57904: LIST
57905: LIST
57906: PUSH
57907: EMPTY
57908: LIST
57909: LIST
57910: LIST
57911: PPUSH
57912: CALL_OW 72
57916: ST_TO_ADDR
57917: GO 58141
57919: LD_INT 2
57921: DOUBLE
57922: EQUAL
57923: IFTRUE 57927
57925: GO 57989
57927: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
57928: LD_ADDR_VAR 0 12
57932: PUSH
57933: LD_VAR 0 18
57937: PPUSH
57938: LD_INT 22
57940: PUSH
57941: LD_VAR 0 16
57945: PUSH
57946: EMPTY
57947: LIST
57948: LIST
57949: PUSH
57950: LD_INT 2
57952: PUSH
57953: LD_INT 30
57955: PUSH
57956: LD_INT 0
57958: PUSH
57959: EMPTY
57960: LIST
57961: LIST
57962: PUSH
57963: LD_INT 30
57965: PUSH
57966: LD_INT 1
57968: PUSH
57969: EMPTY
57970: LIST
57971: LIST
57972: PUSH
57973: EMPTY
57974: LIST
57975: LIST
57976: LIST
57977: PUSH
57978: EMPTY
57979: LIST
57980: LIST
57981: PPUSH
57982: CALL_OW 72
57986: ST_TO_ADDR
57987: GO 58141
57989: LD_INT 3
57991: DOUBLE
57992: EQUAL
57993: IFTRUE 57997
57995: GO 58059
57997: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
57998: LD_ADDR_VAR 0 12
58002: PUSH
58003: LD_VAR 0 18
58007: PPUSH
58008: LD_INT 22
58010: PUSH
58011: LD_VAR 0 16
58015: PUSH
58016: EMPTY
58017: LIST
58018: LIST
58019: PUSH
58020: LD_INT 2
58022: PUSH
58023: LD_INT 30
58025: PUSH
58026: LD_INT 2
58028: PUSH
58029: EMPTY
58030: LIST
58031: LIST
58032: PUSH
58033: LD_INT 30
58035: PUSH
58036: LD_INT 3
58038: PUSH
58039: EMPTY
58040: LIST
58041: LIST
58042: PUSH
58043: EMPTY
58044: LIST
58045: LIST
58046: LIST
58047: PUSH
58048: EMPTY
58049: LIST
58050: LIST
58051: PPUSH
58052: CALL_OW 72
58056: ST_TO_ADDR
58057: GO 58141
58059: LD_INT 4
58061: DOUBLE
58062: EQUAL
58063: IFTRUE 58067
58065: GO 58140
58067: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
58068: LD_ADDR_VAR 0 12
58072: PUSH
58073: LD_VAR 0 18
58077: PPUSH
58078: LD_INT 22
58080: PUSH
58081: LD_VAR 0 16
58085: PUSH
58086: EMPTY
58087: LIST
58088: LIST
58089: PUSH
58090: LD_INT 2
58092: PUSH
58093: LD_INT 30
58095: PUSH
58096: LD_INT 6
58098: PUSH
58099: EMPTY
58100: LIST
58101: LIST
58102: PUSH
58103: LD_INT 30
58105: PUSH
58106: LD_INT 7
58108: PUSH
58109: EMPTY
58110: LIST
58111: LIST
58112: PUSH
58113: LD_INT 30
58115: PUSH
58116: LD_INT 8
58118: PUSH
58119: EMPTY
58120: LIST
58121: LIST
58122: PUSH
58123: EMPTY
58124: LIST
58125: LIST
58126: LIST
58127: LIST
58128: PUSH
58129: EMPTY
58130: LIST
58131: LIST
58132: PPUSH
58133: CALL_OW 72
58137: ST_TO_ADDR
58138: GO 58141
58140: POP
// if i = 1 then
58141: LD_VAR 0 8
58145: PUSH
58146: LD_INT 1
58148: EQUAL
58149: IFFALSE 58260
// begin tmp := [ ] ;
58151: LD_ADDR_VAR 0 19
58155: PUSH
58156: EMPTY
58157: ST_TO_ADDR
// for j in f do
58158: LD_ADDR_VAR 0 9
58162: PUSH
58163: LD_VAR 0 12
58167: PUSH
58168: FOR_IN
58169: IFFALSE 58242
// if GetBType ( j ) = b_bunker then
58171: LD_VAR 0 9
58175: PPUSH
58176: CALL_OW 266
58180: PUSH
58181: LD_INT 32
58183: EQUAL
58184: IFFALSE 58211
// tmp := Insert ( tmp , 1 , j ) else
58186: LD_ADDR_VAR 0 19
58190: PUSH
58191: LD_VAR 0 19
58195: PPUSH
58196: LD_INT 1
58198: PPUSH
58199: LD_VAR 0 9
58203: PPUSH
58204: CALL_OW 2
58208: ST_TO_ADDR
58209: GO 58240
// tmp := Insert ( tmp , tmp + 1 , j ) ;
58211: LD_ADDR_VAR 0 19
58215: PUSH
58216: LD_VAR 0 19
58220: PPUSH
58221: LD_VAR 0 19
58225: PUSH
58226: LD_INT 1
58228: PLUS
58229: PPUSH
58230: LD_VAR 0 9
58234: PPUSH
58235: CALL_OW 2
58239: ST_TO_ADDR
58240: GO 58168
58242: POP
58243: POP
// if tmp then
58244: LD_VAR 0 19
58248: IFFALSE 58260
// f := tmp ;
58250: LD_ADDR_VAR 0 12
58254: PUSH
58255: LD_VAR 0 19
58259: ST_TO_ADDR
// end ; x := personel [ i ] ;
58260: LD_ADDR_VAR 0 13
58264: PUSH
58265: LD_VAR 0 6
58269: PUSH
58270: LD_VAR 0 8
58274: ARRAY
58275: ST_TO_ADDR
// if x = - 1 then
58276: LD_VAR 0 13
58280: PUSH
58281: LD_INT 1
58283: NEG
58284: EQUAL
58285: IFFALSE 58494
// begin for j in f do
58287: LD_ADDR_VAR 0 9
58291: PUSH
58292: LD_VAR 0 12
58296: PUSH
58297: FOR_IN
58298: IFFALSE 58490
// repeat InitHc ;
58300: CALL_OW 19
// if GetBType ( j ) = b_barracks then
58304: LD_VAR 0 9
58308: PPUSH
58309: CALL_OW 266
58313: PUSH
58314: LD_INT 5
58316: EQUAL
58317: IFFALSE 58387
// begin if UnitsInside ( j ) < 3 then
58319: LD_VAR 0 9
58323: PPUSH
58324: CALL_OW 313
58328: PUSH
58329: LD_INT 3
58331: LESS
58332: IFFALSE 58368
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
58334: LD_INT 0
58336: PPUSH
58337: LD_INT 5
58339: PUSH
58340: LD_INT 8
58342: PUSH
58343: LD_INT 9
58345: PUSH
58346: EMPTY
58347: LIST
58348: LIST
58349: LIST
58350: PUSH
58351: LD_VAR 0 17
58355: ARRAY
58356: PPUSH
58357: LD_VAR 0 4
58361: PPUSH
58362: CALL_OW 380
58366: GO 58385
// PrepareHuman ( false , i , skill ) ;
58368: LD_INT 0
58370: PPUSH
58371: LD_VAR 0 8
58375: PPUSH
58376: LD_VAR 0 4
58380: PPUSH
58381: CALL_OW 380
// end else
58385: GO 58404
// PrepareHuman ( false , i , skill ) ;
58387: LD_INT 0
58389: PPUSH
58390: LD_VAR 0 8
58394: PPUSH
58395: LD_VAR 0 4
58399: PPUSH
58400: CALL_OW 380
// un := CreateHuman ;
58404: LD_ADDR_VAR 0 14
58408: PUSH
58409: CALL_OW 44
58413: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58414: LD_ADDR_VAR 0 7
58418: PUSH
58419: LD_VAR 0 7
58423: PPUSH
58424: LD_INT 1
58426: PPUSH
58427: LD_VAR 0 14
58431: PPUSH
58432: CALL_OW 2
58436: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
58437: LD_VAR 0 14
58441: PPUSH
58442: LD_VAR 0 9
58446: PPUSH
58447: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
58451: LD_VAR 0 9
58455: PPUSH
58456: CALL_OW 313
58460: PUSH
58461: LD_INT 6
58463: EQUAL
58464: PUSH
58465: LD_VAR 0 9
58469: PPUSH
58470: CALL_OW 266
58474: PUSH
58475: LD_INT 32
58477: PUSH
58478: LD_INT 31
58480: PUSH
58481: EMPTY
58482: LIST
58483: LIST
58484: IN
58485: OR
58486: IFFALSE 58300
58488: GO 58297
58490: POP
58491: POP
// end else
58492: GO 58874
// for j = 1 to x do
58494: LD_ADDR_VAR 0 9
58498: PUSH
58499: DOUBLE
58500: LD_INT 1
58502: DEC
58503: ST_TO_ADDR
58504: LD_VAR 0 13
58508: PUSH
58509: FOR_TO
58510: IFFALSE 58872
// begin InitHc ;
58512: CALL_OW 19
// if not f then
58516: LD_VAR 0 12
58520: NOT
58521: IFFALSE 58610
// begin PrepareHuman ( false , i , skill ) ;
58523: LD_INT 0
58525: PPUSH
58526: LD_VAR 0 8
58530: PPUSH
58531: LD_VAR 0 4
58535: PPUSH
58536: CALL_OW 380
// un := CreateHuman ;
58540: LD_ADDR_VAR 0 14
58544: PUSH
58545: CALL_OW 44
58549: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58550: LD_ADDR_VAR 0 7
58554: PUSH
58555: LD_VAR 0 7
58559: PPUSH
58560: LD_INT 1
58562: PPUSH
58563: LD_VAR 0 14
58567: PPUSH
58568: CALL_OW 2
58572: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
58573: LD_VAR 0 14
58577: PPUSH
58578: LD_VAR 0 1
58582: PPUSH
58583: CALL_OW 250
58587: PPUSH
58588: LD_VAR 0 1
58592: PPUSH
58593: CALL_OW 251
58597: PPUSH
58598: LD_INT 10
58600: PPUSH
58601: LD_INT 0
58603: PPUSH
58604: CALL_OW 50
// continue ;
58608: GO 58509
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
58610: LD_VAR 0 12
58614: PUSH
58615: LD_INT 1
58617: ARRAY
58618: PPUSH
58619: CALL_OW 313
58623: PUSH
58624: LD_VAR 0 12
58628: PUSH
58629: LD_INT 1
58631: ARRAY
58632: PPUSH
58633: CALL_OW 266
58637: PUSH
58638: LD_INT 32
58640: PUSH
58641: LD_INT 31
58643: PUSH
58644: EMPTY
58645: LIST
58646: LIST
58647: IN
58648: AND
58649: PUSH
58650: LD_VAR 0 12
58654: PUSH
58655: LD_INT 1
58657: ARRAY
58658: PPUSH
58659: CALL_OW 313
58663: PUSH
58664: LD_INT 6
58666: EQUAL
58667: OR
58668: IFFALSE 58688
// f := Delete ( f , 1 ) ;
58670: LD_ADDR_VAR 0 12
58674: PUSH
58675: LD_VAR 0 12
58679: PPUSH
58680: LD_INT 1
58682: PPUSH
58683: CALL_OW 3
58687: ST_TO_ADDR
// if not f then
58688: LD_VAR 0 12
58692: NOT
58693: IFFALSE 58711
// begin x := x + 2 ;
58695: LD_ADDR_VAR 0 13
58699: PUSH
58700: LD_VAR 0 13
58704: PUSH
58705: LD_INT 2
58707: PLUS
58708: ST_TO_ADDR
// continue ;
58709: GO 58509
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
58711: LD_VAR 0 12
58715: PUSH
58716: LD_INT 1
58718: ARRAY
58719: PPUSH
58720: CALL_OW 266
58724: PUSH
58725: LD_INT 5
58727: EQUAL
58728: IFFALSE 58802
// begin if UnitsInside ( f [ 1 ] ) < 3 then
58730: LD_VAR 0 12
58734: PUSH
58735: LD_INT 1
58737: ARRAY
58738: PPUSH
58739: CALL_OW 313
58743: PUSH
58744: LD_INT 3
58746: LESS
58747: IFFALSE 58783
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
58749: LD_INT 0
58751: PPUSH
58752: LD_INT 5
58754: PUSH
58755: LD_INT 8
58757: PUSH
58758: LD_INT 9
58760: PUSH
58761: EMPTY
58762: LIST
58763: LIST
58764: LIST
58765: PUSH
58766: LD_VAR 0 17
58770: ARRAY
58771: PPUSH
58772: LD_VAR 0 4
58776: PPUSH
58777: CALL_OW 380
58781: GO 58800
// PrepareHuman ( false , i , skill ) ;
58783: LD_INT 0
58785: PPUSH
58786: LD_VAR 0 8
58790: PPUSH
58791: LD_VAR 0 4
58795: PPUSH
58796: CALL_OW 380
// end else
58800: GO 58819
// PrepareHuman ( false , i , skill ) ;
58802: LD_INT 0
58804: PPUSH
58805: LD_VAR 0 8
58809: PPUSH
58810: LD_VAR 0 4
58814: PPUSH
58815: CALL_OW 380
// un := CreateHuman ;
58819: LD_ADDR_VAR 0 14
58823: PUSH
58824: CALL_OW 44
58828: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58829: LD_ADDR_VAR 0 7
58833: PUSH
58834: LD_VAR 0 7
58838: PPUSH
58839: LD_INT 1
58841: PPUSH
58842: LD_VAR 0 14
58846: PPUSH
58847: CALL_OW 2
58851: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
58852: LD_VAR 0 14
58856: PPUSH
58857: LD_VAR 0 12
58861: PUSH
58862: LD_INT 1
58864: ARRAY
58865: PPUSH
58866: CALL_OW 52
// end ;
58870: GO 58509
58872: POP
58873: POP
// end ;
58874: GO 57811
58876: POP
58877: POP
// result := result ^ buildings ;
58878: LD_ADDR_VAR 0 7
58882: PUSH
58883: LD_VAR 0 7
58887: PUSH
58888: LD_VAR 0 18
58892: ADD
58893: ST_TO_ADDR
// end else
58894: GO 59037
// begin for i = 1 to personel do
58896: LD_ADDR_VAR 0 8
58900: PUSH
58901: DOUBLE
58902: LD_INT 1
58904: DEC
58905: ST_TO_ADDR
58906: LD_VAR 0 6
58910: PUSH
58911: FOR_TO
58912: IFFALSE 59035
// begin if i > 4 then
58914: LD_VAR 0 8
58918: PUSH
58919: LD_INT 4
58921: GREATER
58922: IFFALSE 58926
// break ;
58924: GO 59035
// x := personel [ i ] ;
58926: LD_ADDR_VAR 0 13
58930: PUSH
58931: LD_VAR 0 6
58935: PUSH
58936: LD_VAR 0 8
58940: ARRAY
58941: ST_TO_ADDR
// if x = - 1 then
58942: LD_VAR 0 13
58946: PUSH
58947: LD_INT 1
58949: NEG
58950: EQUAL
58951: IFFALSE 58955
// continue ;
58953: GO 58911
// PrepareHuman ( false , i , skill ) ;
58955: LD_INT 0
58957: PPUSH
58958: LD_VAR 0 8
58962: PPUSH
58963: LD_VAR 0 4
58967: PPUSH
58968: CALL_OW 380
// un := CreateHuman ;
58972: LD_ADDR_VAR 0 14
58976: PUSH
58977: CALL_OW 44
58981: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
58982: LD_VAR 0 14
58986: PPUSH
58987: LD_VAR 0 1
58991: PPUSH
58992: CALL_OW 250
58996: PPUSH
58997: LD_VAR 0 1
59001: PPUSH
59002: CALL_OW 251
59006: PPUSH
59007: LD_INT 10
59009: PPUSH
59010: LD_INT 0
59012: PPUSH
59013: CALL_OW 50
// result := result ^ un ;
59017: LD_ADDR_VAR 0 7
59021: PUSH
59022: LD_VAR 0 7
59026: PUSH
59027: LD_VAR 0 14
59031: ADD
59032: ST_TO_ADDR
// end ;
59033: GO 58911
59035: POP
59036: POP
// end ; end ;
59037: LD_VAR 0 7
59041: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
59042: LD_INT 0
59044: PPUSH
59045: PPUSH
59046: PPUSH
59047: PPUSH
59048: PPUSH
59049: PPUSH
59050: PPUSH
59051: PPUSH
59052: PPUSH
59053: PPUSH
59054: PPUSH
59055: PPUSH
59056: PPUSH
59057: PPUSH
59058: PPUSH
59059: PPUSH
// result := false ;
59060: LD_ADDR_VAR 0 3
59064: PUSH
59065: LD_INT 0
59067: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
59068: LD_VAR 0 1
59072: NOT
59073: PUSH
59074: LD_VAR 0 1
59078: PPUSH
59079: CALL_OW 266
59083: PUSH
59084: LD_INT 32
59086: PUSH
59087: LD_INT 33
59089: PUSH
59090: EMPTY
59091: LIST
59092: LIST
59093: IN
59094: NOT
59095: OR
59096: IFFALSE 59100
// exit ;
59098: GO 60209
// nat := GetNation ( tower ) ;
59100: LD_ADDR_VAR 0 12
59104: PUSH
59105: LD_VAR 0 1
59109: PPUSH
59110: CALL_OW 248
59114: ST_TO_ADDR
// side := GetSide ( tower ) ;
59115: LD_ADDR_VAR 0 16
59119: PUSH
59120: LD_VAR 0 1
59124: PPUSH
59125: CALL_OW 255
59129: ST_TO_ADDR
// x := GetX ( tower ) ;
59130: LD_ADDR_VAR 0 10
59134: PUSH
59135: LD_VAR 0 1
59139: PPUSH
59140: CALL_OW 250
59144: ST_TO_ADDR
// y := GetY ( tower ) ;
59145: LD_ADDR_VAR 0 11
59149: PUSH
59150: LD_VAR 0 1
59154: PPUSH
59155: CALL_OW 251
59159: ST_TO_ADDR
// if not x or not y then
59160: LD_VAR 0 10
59164: NOT
59165: PUSH
59166: LD_VAR 0 11
59170: NOT
59171: OR
59172: IFFALSE 59176
// exit ;
59174: GO 60209
// weapon := 0 ;
59176: LD_ADDR_VAR 0 18
59180: PUSH
59181: LD_INT 0
59183: ST_TO_ADDR
// fac_list := [ ] ;
59184: LD_ADDR_VAR 0 17
59188: PUSH
59189: EMPTY
59190: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
59191: LD_ADDR_VAR 0 6
59195: PUSH
59196: LD_VAR 0 1
59200: PPUSH
59201: CALL_OW 274
59205: PPUSH
59206: LD_VAR 0 2
59210: PPUSH
59211: LD_INT 0
59213: PPUSH
59214: CALL 56780 0 3
59218: PPUSH
59219: LD_INT 30
59221: PUSH
59222: LD_INT 3
59224: PUSH
59225: EMPTY
59226: LIST
59227: LIST
59228: PPUSH
59229: CALL_OW 72
59233: ST_TO_ADDR
// if not factories then
59234: LD_VAR 0 6
59238: NOT
59239: IFFALSE 59243
// exit ;
59241: GO 60209
// for i in factories do
59243: LD_ADDR_VAR 0 8
59247: PUSH
59248: LD_VAR 0 6
59252: PUSH
59253: FOR_IN
59254: IFFALSE 59279
// fac_list := fac_list union AvailableWeaponList ( i ) ;
59256: LD_ADDR_VAR 0 17
59260: PUSH
59261: LD_VAR 0 17
59265: PUSH
59266: LD_VAR 0 8
59270: PPUSH
59271: CALL_OW 478
59275: UNION
59276: ST_TO_ADDR
59277: GO 59253
59279: POP
59280: POP
// if not fac_list then
59281: LD_VAR 0 17
59285: NOT
59286: IFFALSE 59290
// exit ;
59288: GO 60209
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
59290: LD_ADDR_VAR 0 5
59294: PUSH
59295: LD_INT 4
59297: PUSH
59298: LD_INT 5
59300: PUSH
59301: LD_INT 9
59303: PUSH
59304: LD_INT 10
59306: PUSH
59307: LD_INT 6
59309: PUSH
59310: LD_INT 7
59312: PUSH
59313: LD_INT 11
59315: PUSH
59316: EMPTY
59317: LIST
59318: LIST
59319: LIST
59320: LIST
59321: LIST
59322: LIST
59323: LIST
59324: PUSH
59325: LD_INT 27
59327: PUSH
59328: LD_INT 28
59330: PUSH
59331: LD_INT 26
59333: PUSH
59334: LD_INT 30
59336: PUSH
59337: EMPTY
59338: LIST
59339: LIST
59340: LIST
59341: LIST
59342: PUSH
59343: LD_INT 43
59345: PUSH
59346: LD_INT 44
59348: PUSH
59349: LD_INT 46
59351: PUSH
59352: LD_INT 45
59354: PUSH
59355: LD_INT 47
59357: PUSH
59358: LD_INT 49
59360: PUSH
59361: EMPTY
59362: LIST
59363: LIST
59364: LIST
59365: LIST
59366: LIST
59367: LIST
59368: PUSH
59369: EMPTY
59370: LIST
59371: LIST
59372: LIST
59373: PUSH
59374: LD_VAR 0 12
59378: ARRAY
59379: ST_TO_ADDR
// list := list isect fac_list ;
59380: LD_ADDR_VAR 0 5
59384: PUSH
59385: LD_VAR 0 5
59389: PUSH
59390: LD_VAR 0 17
59394: ISECT
59395: ST_TO_ADDR
// if not list then
59396: LD_VAR 0 5
59400: NOT
59401: IFFALSE 59405
// exit ;
59403: GO 60209
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
59405: LD_VAR 0 12
59409: PUSH
59410: LD_INT 3
59412: EQUAL
59413: PUSH
59414: LD_INT 49
59416: PUSH
59417: LD_VAR 0 5
59421: IN
59422: AND
59423: PUSH
59424: LD_INT 31
59426: PPUSH
59427: LD_VAR 0 16
59431: PPUSH
59432: CALL_OW 321
59436: PUSH
59437: LD_INT 2
59439: EQUAL
59440: AND
59441: IFFALSE 59501
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
59443: LD_INT 22
59445: PUSH
59446: LD_VAR 0 16
59450: PUSH
59451: EMPTY
59452: LIST
59453: LIST
59454: PUSH
59455: LD_INT 35
59457: PUSH
59458: LD_INT 49
59460: PUSH
59461: EMPTY
59462: LIST
59463: LIST
59464: PUSH
59465: LD_INT 91
59467: PUSH
59468: LD_VAR 0 1
59472: PUSH
59473: LD_INT 10
59475: PUSH
59476: EMPTY
59477: LIST
59478: LIST
59479: LIST
59480: PUSH
59481: EMPTY
59482: LIST
59483: LIST
59484: LIST
59485: PPUSH
59486: CALL_OW 69
59490: NOT
59491: IFFALSE 59501
// weapon := ru_time_lapser ;
59493: LD_ADDR_VAR 0 18
59497: PUSH
59498: LD_INT 49
59500: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
59501: LD_VAR 0 12
59505: PUSH
59506: LD_INT 1
59508: PUSH
59509: LD_INT 2
59511: PUSH
59512: EMPTY
59513: LIST
59514: LIST
59515: IN
59516: PUSH
59517: LD_INT 11
59519: PUSH
59520: LD_VAR 0 5
59524: IN
59525: PUSH
59526: LD_INT 30
59528: PUSH
59529: LD_VAR 0 5
59533: IN
59534: OR
59535: AND
59536: PUSH
59537: LD_INT 6
59539: PPUSH
59540: LD_VAR 0 16
59544: PPUSH
59545: CALL_OW 321
59549: PUSH
59550: LD_INT 2
59552: EQUAL
59553: AND
59554: IFFALSE 59719
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
59556: LD_INT 22
59558: PUSH
59559: LD_VAR 0 16
59563: PUSH
59564: EMPTY
59565: LIST
59566: LIST
59567: PUSH
59568: LD_INT 2
59570: PUSH
59571: LD_INT 35
59573: PUSH
59574: LD_INT 11
59576: PUSH
59577: EMPTY
59578: LIST
59579: LIST
59580: PUSH
59581: LD_INT 35
59583: PUSH
59584: LD_INT 30
59586: PUSH
59587: EMPTY
59588: LIST
59589: LIST
59590: PUSH
59591: EMPTY
59592: LIST
59593: LIST
59594: LIST
59595: PUSH
59596: LD_INT 91
59598: PUSH
59599: LD_VAR 0 1
59603: PUSH
59604: LD_INT 18
59606: PUSH
59607: EMPTY
59608: LIST
59609: LIST
59610: LIST
59611: PUSH
59612: EMPTY
59613: LIST
59614: LIST
59615: LIST
59616: PPUSH
59617: CALL_OW 69
59621: NOT
59622: PUSH
59623: LD_INT 22
59625: PUSH
59626: LD_VAR 0 16
59630: PUSH
59631: EMPTY
59632: LIST
59633: LIST
59634: PUSH
59635: LD_INT 2
59637: PUSH
59638: LD_INT 30
59640: PUSH
59641: LD_INT 32
59643: PUSH
59644: EMPTY
59645: LIST
59646: LIST
59647: PUSH
59648: LD_INT 30
59650: PUSH
59651: LD_INT 33
59653: PUSH
59654: EMPTY
59655: LIST
59656: LIST
59657: PUSH
59658: EMPTY
59659: LIST
59660: LIST
59661: LIST
59662: PUSH
59663: LD_INT 91
59665: PUSH
59666: LD_VAR 0 1
59670: PUSH
59671: LD_INT 12
59673: PUSH
59674: EMPTY
59675: LIST
59676: LIST
59677: LIST
59678: PUSH
59679: EMPTY
59680: LIST
59681: LIST
59682: LIST
59683: PUSH
59684: EMPTY
59685: LIST
59686: PPUSH
59687: CALL_OW 69
59691: PUSH
59692: LD_INT 2
59694: GREATER
59695: AND
59696: IFFALSE 59719
// weapon := [ us_radar , ar_radar ] [ nat ] ;
59698: LD_ADDR_VAR 0 18
59702: PUSH
59703: LD_INT 11
59705: PUSH
59706: LD_INT 30
59708: PUSH
59709: EMPTY
59710: LIST
59711: LIST
59712: PUSH
59713: LD_VAR 0 12
59717: ARRAY
59718: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
59719: LD_VAR 0 18
59723: NOT
59724: PUSH
59725: LD_INT 40
59727: PPUSH
59728: LD_VAR 0 16
59732: PPUSH
59733: CALL_OW 321
59737: PUSH
59738: LD_INT 2
59740: EQUAL
59741: AND
59742: PUSH
59743: LD_INT 7
59745: PUSH
59746: LD_VAR 0 5
59750: IN
59751: PUSH
59752: LD_INT 28
59754: PUSH
59755: LD_VAR 0 5
59759: IN
59760: OR
59761: PUSH
59762: LD_INT 45
59764: PUSH
59765: LD_VAR 0 5
59769: IN
59770: OR
59771: AND
59772: IFFALSE 60026
// begin hex := GetHexInfo ( x , y ) ;
59774: LD_ADDR_VAR 0 4
59778: PUSH
59779: LD_VAR 0 10
59783: PPUSH
59784: LD_VAR 0 11
59788: PPUSH
59789: CALL_OW 546
59793: ST_TO_ADDR
// if hex [ 1 ] then
59794: LD_VAR 0 4
59798: PUSH
59799: LD_INT 1
59801: ARRAY
59802: IFFALSE 59806
// exit ;
59804: GO 60209
// height := hex [ 2 ] ;
59806: LD_ADDR_VAR 0 15
59810: PUSH
59811: LD_VAR 0 4
59815: PUSH
59816: LD_INT 2
59818: ARRAY
59819: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
59820: LD_ADDR_VAR 0 14
59824: PUSH
59825: LD_INT 0
59827: PUSH
59828: LD_INT 2
59830: PUSH
59831: LD_INT 3
59833: PUSH
59834: LD_INT 5
59836: PUSH
59837: EMPTY
59838: LIST
59839: LIST
59840: LIST
59841: LIST
59842: ST_TO_ADDR
// for i in tmp do
59843: LD_ADDR_VAR 0 8
59847: PUSH
59848: LD_VAR 0 14
59852: PUSH
59853: FOR_IN
59854: IFFALSE 60024
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
59856: LD_ADDR_VAR 0 9
59860: PUSH
59861: LD_VAR 0 10
59865: PPUSH
59866: LD_VAR 0 8
59870: PPUSH
59871: LD_INT 5
59873: PPUSH
59874: CALL_OW 272
59878: PUSH
59879: LD_VAR 0 11
59883: PPUSH
59884: LD_VAR 0 8
59888: PPUSH
59889: LD_INT 5
59891: PPUSH
59892: CALL_OW 273
59896: PUSH
59897: EMPTY
59898: LIST
59899: LIST
59900: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
59901: LD_VAR 0 9
59905: PUSH
59906: LD_INT 1
59908: ARRAY
59909: PPUSH
59910: LD_VAR 0 9
59914: PUSH
59915: LD_INT 2
59917: ARRAY
59918: PPUSH
59919: CALL_OW 488
59923: IFFALSE 60022
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
59925: LD_ADDR_VAR 0 4
59929: PUSH
59930: LD_VAR 0 9
59934: PUSH
59935: LD_INT 1
59937: ARRAY
59938: PPUSH
59939: LD_VAR 0 9
59943: PUSH
59944: LD_INT 2
59946: ARRAY
59947: PPUSH
59948: CALL_OW 546
59952: ST_TO_ADDR
// if hex [ 1 ] then
59953: LD_VAR 0 4
59957: PUSH
59958: LD_INT 1
59960: ARRAY
59961: IFFALSE 59965
// continue ;
59963: GO 59853
// h := hex [ 2 ] ;
59965: LD_ADDR_VAR 0 13
59969: PUSH
59970: LD_VAR 0 4
59974: PUSH
59975: LD_INT 2
59977: ARRAY
59978: ST_TO_ADDR
// if h + 7 < height then
59979: LD_VAR 0 13
59983: PUSH
59984: LD_INT 7
59986: PLUS
59987: PUSH
59988: LD_VAR 0 15
59992: LESS
59993: IFFALSE 60022
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
59995: LD_ADDR_VAR 0 18
59999: PUSH
60000: LD_INT 7
60002: PUSH
60003: LD_INT 28
60005: PUSH
60006: LD_INT 45
60008: PUSH
60009: EMPTY
60010: LIST
60011: LIST
60012: LIST
60013: PUSH
60014: LD_VAR 0 12
60018: ARRAY
60019: ST_TO_ADDR
// break ;
60020: GO 60024
// end ; end ; end ;
60022: GO 59853
60024: POP
60025: POP
// end ; if not weapon then
60026: LD_VAR 0 18
60030: NOT
60031: IFFALSE 60091
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
60033: LD_ADDR_VAR 0 5
60037: PUSH
60038: LD_VAR 0 5
60042: PUSH
60043: LD_INT 11
60045: PUSH
60046: LD_INT 30
60048: PUSH
60049: LD_INT 49
60051: PUSH
60052: EMPTY
60053: LIST
60054: LIST
60055: LIST
60056: DIFF
60057: ST_TO_ADDR
// if not list then
60058: LD_VAR 0 5
60062: NOT
60063: IFFALSE 60067
// exit ;
60065: GO 60209
// weapon := list [ rand ( 1 , list ) ] ;
60067: LD_ADDR_VAR 0 18
60071: PUSH
60072: LD_VAR 0 5
60076: PUSH
60077: LD_INT 1
60079: PPUSH
60080: LD_VAR 0 5
60084: PPUSH
60085: CALL_OW 12
60089: ARRAY
60090: ST_TO_ADDR
// end ; if weapon then
60091: LD_VAR 0 18
60095: IFFALSE 60209
// begin tmp := CostOfWeapon ( weapon ) ;
60097: LD_ADDR_VAR 0 14
60101: PUSH
60102: LD_VAR 0 18
60106: PPUSH
60107: CALL_OW 451
60111: ST_TO_ADDR
// j := GetBase ( tower ) ;
60112: LD_ADDR_VAR 0 9
60116: PUSH
60117: LD_VAR 0 1
60121: PPUSH
60122: CALL_OW 274
60126: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
60127: LD_VAR 0 9
60131: PPUSH
60132: LD_INT 1
60134: PPUSH
60135: CALL_OW 275
60139: PUSH
60140: LD_VAR 0 14
60144: PUSH
60145: LD_INT 1
60147: ARRAY
60148: GREATEREQUAL
60149: PUSH
60150: LD_VAR 0 9
60154: PPUSH
60155: LD_INT 2
60157: PPUSH
60158: CALL_OW 275
60162: PUSH
60163: LD_VAR 0 14
60167: PUSH
60168: LD_INT 2
60170: ARRAY
60171: GREATEREQUAL
60172: AND
60173: PUSH
60174: LD_VAR 0 9
60178: PPUSH
60179: LD_INT 3
60181: PPUSH
60182: CALL_OW 275
60186: PUSH
60187: LD_VAR 0 14
60191: PUSH
60192: LD_INT 3
60194: ARRAY
60195: GREATEREQUAL
60196: AND
60197: IFFALSE 60209
// result := weapon ;
60199: LD_ADDR_VAR 0 3
60203: PUSH
60204: LD_VAR 0 18
60208: ST_TO_ADDR
// end ; end ;
60209: LD_VAR 0 3
60213: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
60214: LD_INT 0
60216: PPUSH
60217: PPUSH
// result := true ;
60218: LD_ADDR_VAR 0 3
60222: PUSH
60223: LD_INT 1
60225: ST_TO_ADDR
// if array1 = array2 then
60226: LD_VAR 0 1
60230: PUSH
60231: LD_VAR 0 2
60235: EQUAL
60236: IFFALSE 60296
// begin for i = 1 to array1 do
60238: LD_ADDR_VAR 0 4
60242: PUSH
60243: DOUBLE
60244: LD_INT 1
60246: DEC
60247: ST_TO_ADDR
60248: LD_VAR 0 1
60252: PUSH
60253: FOR_TO
60254: IFFALSE 60292
// if array1 [ i ] <> array2 [ i ] then
60256: LD_VAR 0 1
60260: PUSH
60261: LD_VAR 0 4
60265: ARRAY
60266: PUSH
60267: LD_VAR 0 2
60271: PUSH
60272: LD_VAR 0 4
60276: ARRAY
60277: NONEQUAL
60278: IFFALSE 60290
// begin result := false ;
60280: LD_ADDR_VAR 0 3
60284: PUSH
60285: LD_INT 0
60287: ST_TO_ADDR
// break ;
60288: GO 60292
// end ;
60290: GO 60253
60292: POP
60293: POP
// end else
60294: GO 60304
// result := false ;
60296: LD_ADDR_VAR 0 3
60300: PUSH
60301: LD_INT 0
60303: ST_TO_ADDR
// end ;
60304: LD_VAR 0 3
60308: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
60309: LD_INT 0
60311: PPUSH
60312: PPUSH
// if not array1 or not array2 then
60313: LD_VAR 0 1
60317: NOT
60318: PUSH
60319: LD_VAR 0 2
60323: NOT
60324: OR
60325: IFFALSE 60329
// exit ;
60327: GO 60393
// result := true ;
60329: LD_ADDR_VAR 0 3
60333: PUSH
60334: LD_INT 1
60336: ST_TO_ADDR
// for i = 1 to array1 do
60337: LD_ADDR_VAR 0 4
60341: PUSH
60342: DOUBLE
60343: LD_INT 1
60345: DEC
60346: ST_TO_ADDR
60347: LD_VAR 0 1
60351: PUSH
60352: FOR_TO
60353: IFFALSE 60391
// if array1 [ i ] <> array2 [ i ] then
60355: LD_VAR 0 1
60359: PUSH
60360: LD_VAR 0 4
60364: ARRAY
60365: PUSH
60366: LD_VAR 0 2
60370: PUSH
60371: LD_VAR 0 4
60375: ARRAY
60376: NONEQUAL
60377: IFFALSE 60389
// begin result := false ;
60379: LD_ADDR_VAR 0 3
60383: PUSH
60384: LD_INT 0
60386: ST_TO_ADDR
// break ;
60387: GO 60391
// end ;
60389: GO 60352
60391: POP
60392: POP
// end ;
60393: LD_VAR 0 3
60397: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
60398: LD_INT 0
60400: PPUSH
60401: PPUSH
60402: PPUSH
// pom := GetBase ( fac ) ;
60403: LD_ADDR_VAR 0 5
60407: PUSH
60408: LD_VAR 0 1
60412: PPUSH
60413: CALL_OW 274
60417: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
60418: LD_ADDR_VAR 0 4
60422: PUSH
60423: LD_VAR 0 2
60427: PUSH
60428: LD_INT 1
60430: ARRAY
60431: PPUSH
60432: LD_VAR 0 2
60436: PUSH
60437: LD_INT 2
60439: ARRAY
60440: PPUSH
60441: LD_VAR 0 2
60445: PUSH
60446: LD_INT 3
60448: ARRAY
60449: PPUSH
60450: LD_VAR 0 2
60454: PUSH
60455: LD_INT 4
60457: ARRAY
60458: PPUSH
60459: CALL_OW 449
60463: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60464: LD_ADDR_VAR 0 3
60468: PUSH
60469: LD_VAR 0 5
60473: PPUSH
60474: LD_INT 1
60476: PPUSH
60477: CALL_OW 275
60481: PUSH
60482: LD_VAR 0 4
60486: PUSH
60487: LD_INT 1
60489: ARRAY
60490: GREATEREQUAL
60491: PUSH
60492: LD_VAR 0 5
60496: PPUSH
60497: LD_INT 2
60499: PPUSH
60500: CALL_OW 275
60504: PUSH
60505: LD_VAR 0 4
60509: PUSH
60510: LD_INT 2
60512: ARRAY
60513: GREATEREQUAL
60514: AND
60515: PUSH
60516: LD_VAR 0 5
60520: PPUSH
60521: LD_INT 3
60523: PPUSH
60524: CALL_OW 275
60528: PUSH
60529: LD_VAR 0 4
60533: PUSH
60534: LD_INT 3
60536: ARRAY
60537: GREATEREQUAL
60538: AND
60539: ST_TO_ADDR
// end ;
60540: LD_VAR 0 3
60544: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
60545: LD_INT 0
60547: PPUSH
60548: PPUSH
60549: PPUSH
60550: PPUSH
// pom := GetBase ( building ) ;
60551: LD_ADDR_VAR 0 3
60555: PUSH
60556: LD_VAR 0 1
60560: PPUSH
60561: CALL_OW 274
60565: ST_TO_ADDR
// if not pom then
60566: LD_VAR 0 3
60570: NOT
60571: IFFALSE 60575
// exit ;
60573: GO 60745
// btype := GetBType ( building ) ;
60575: LD_ADDR_VAR 0 5
60579: PUSH
60580: LD_VAR 0 1
60584: PPUSH
60585: CALL_OW 266
60589: ST_TO_ADDR
// if btype = b_armoury then
60590: LD_VAR 0 5
60594: PUSH
60595: LD_INT 4
60597: EQUAL
60598: IFFALSE 60608
// btype := b_barracks ;
60600: LD_ADDR_VAR 0 5
60604: PUSH
60605: LD_INT 5
60607: ST_TO_ADDR
// if btype = b_depot then
60608: LD_VAR 0 5
60612: PUSH
60613: LD_INT 0
60615: EQUAL
60616: IFFALSE 60626
// btype := b_warehouse ;
60618: LD_ADDR_VAR 0 5
60622: PUSH
60623: LD_INT 1
60625: ST_TO_ADDR
// if btype = b_workshop then
60626: LD_VAR 0 5
60630: PUSH
60631: LD_INT 2
60633: EQUAL
60634: IFFALSE 60644
// btype := b_factory ;
60636: LD_ADDR_VAR 0 5
60640: PUSH
60641: LD_INT 3
60643: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
60644: LD_ADDR_VAR 0 4
60648: PUSH
60649: LD_VAR 0 5
60653: PPUSH
60654: LD_VAR 0 1
60658: PPUSH
60659: CALL_OW 248
60663: PPUSH
60664: CALL_OW 450
60668: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60669: LD_ADDR_VAR 0 2
60673: PUSH
60674: LD_VAR 0 3
60678: PPUSH
60679: LD_INT 1
60681: PPUSH
60682: CALL_OW 275
60686: PUSH
60687: LD_VAR 0 4
60691: PUSH
60692: LD_INT 1
60694: ARRAY
60695: GREATEREQUAL
60696: PUSH
60697: LD_VAR 0 3
60701: PPUSH
60702: LD_INT 2
60704: PPUSH
60705: CALL_OW 275
60709: PUSH
60710: LD_VAR 0 4
60714: PUSH
60715: LD_INT 2
60717: ARRAY
60718: GREATEREQUAL
60719: AND
60720: PUSH
60721: LD_VAR 0 3
60725: PPUSH
60726: LD_INT 3
60728: PPUSH
60729: CALL_OW 275
60733: PUSH
60734: LD_VAR 0 4
60738: PUSH
60739: LD_INT 3
60741: ARRAY
60742: GREATEREQUAL
60743: AND
60744: ST_TO_ADDR
// end ;
60745: LD_VAR 0 2
60749: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
60750: LD_INT 0
60752: PPUSH
60753: PPUSH
60754: PPUSH
// pom := GetBase ( building ) ;
60755: LD_ADDR_VAR 0 4
60759: PUSH
60760: LD_VAR 0 1
60764: PPUSH
60765: CALL_OW 274
60769: ST_TO_ADDR
// if not pom then
60770: LD_VAR 0 4
60774: NOT
60775: IFFALSE 60779
// exit ;
60777: GO 60880
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
60779: LD_ADDR_VAR 0 5
60783: PUSH
60784: LD_VAR 0 2
60788: PPUSH
60789: LD_VAR 0 1
60793: PPUSH
60794: CALL_OW 248
60798: PPUSH
60799: CALL_OW 450
60803: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60804: LD_ADDR_VAR 0 3
60808: PUSH
60809: LD_VAR 0 4
60813: PPUSH
60814: LD_INT 1
60816: PPUSH
60817: CALL_OW 275
60821: PUSH
60822: LD_VAR 0 5
60826: PUSH
60827: LD_INT 1
60829: ARRAY
60830: GREATEREQUAL
60831: PUSH
60832: LD_VAR 0 4
60836: PPUSH
60837: LD_INT 2
60839: PPUSH
60840: CALL_OW 275
60844: PUSH
60845: LD_VAR 0 5
60849: PUSH
60850: LD_INT 2
60852: ARRAY
60853: GREATEREQUAL
60854: AND
60855: PUSH
60856: LD_VAR 0 4
60860: PPUSH
60861: LD_INT 3
60863: PPUSH
60864: CALL_OW 275
60868: PUSH
60869: LD_VAR 0 5
60873: PUSH
60874: LD_INT 3
60876: ARRAY
60877: GREATEREQUAL
60878: AND
60879: ST_TO_ADDR
// end ;
60880: LD_VAR 0 3
60884: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
60885: LD_INT 0
60887: PPUSH
60888: PPUSH
60889: PPUSH
60890: PPUSH
60891: PPUSH
60892: PPUSH
60893: PPUSH
60894: PPUSH
60895: PPUSH
60896: PPUSH
60897: PPUSH
// result := false ;
60898: LD_ADDR_VAR 0 8
60902: PUSH
60903: LD_INT 0
60905: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
60906: LD_VAR 0 5
60910: NOT
60911: PUSH
60912: LD_VAR 0 1
60916: NOT
60917: OR
60918: PUSH
60919: LD_VAR 0 2
60923: NOT
60924: OR
60925: PUSH
60926: LD_VAR 0 3
60930: NOT
60931: OR
60932: IFFALSE 60936
// exit ;
60934: GO 61750
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
60936: LD_ADDR_VAR 0 14
60940: PUSH
60941: LD_VAR 0 1
60945: PPUSH
60946: LD_VAR 0 2
60950: PPUSH
60951: LD_VAR 0 3
60955: PPUSH
60956: LD_VAR 0 4
60960: PPUSH
60961: LD_VAR 0 5
60965: PUSH
60966: LD_INT 1
60968: ARRAY
60969: PPUSH
60970: CALL_OW 248
60974: PPUSH
60975: LD_INT 0
60977: PPUSH
60978: CALL 62983 0 6
60982: ST_TO_ADDR
// if not hexes then
60983: LD_VAR 0 14
60987: NOT
60988: IFFALSE 60992
// exit ;
60990: GO 61750
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
60992: LD_ADDR_VAR 0 17
60996: PUSH
60997: LD_VAR 0 5
61001: PPUSH
61002: LD_INT 22
61004: PUSH
61005: LD_VAR 0 13
61009: PPUSH
61010: CALL_OW 255
61014: PUSH
61015: EMPTY
61016: LIST
61017: LIST
61018: PUSH
61019: LD_INT 2
61021: PUSH
61022: LD_INT 30
61024: PUSH
61025: LD_INT 0
61027: PUSH
61028: EMPTY
61029: LIST
61030: LIST
61031: PUSH
61032: LD_INT 30
61034: PUSH
61035: LD_INT 1
61037: PUSH
61038: EMPTY
61039: LIST
61040: LIST
61041: PUSH
61042: EMPTY
61043: LIST
61044: LIST
61045: LIST
61046: PUSH
61047: EMPTY
61048: LIST
61049: LIST
61050: PPUSH
61051: CALL_OW 72
61055: ST_TO_ADDR
// for i = 1 to hexes do
61056: LD_ADDR_VAR 0 9
61060: PUSH
61061: DOUBLE
61062: LD_INT 1
61064: DEC
61065: ST_TO_ADDR
61066: LD_VAR 0 14
61070: PUSH
61071: FOR_TO
61072: IFFALSE 61748
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
61074: LD_ADDR_VAR 0 13
61078: PUSH
61079: LD_VAR 0 14
61083: PUSH
61084: LD_VAR 0 9
61088: ARRAY
61089: PUSH
61090: LD_INT 1
61092: ARRAY
61093: PPUSH
61094: LD_VAR 0 14
61098: PUSH
61099: LD_VAR 0 9
61103: ARRAY
61104: PUSH
61105: LD_INT 2
61107: ARRAY
61108: PPUSH
61109: CALL_OW 428
61113: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
61114: LD_VAR 0 14
61118: PUSH
61119: LD_VAR 0 9
61123: ARRAY
61124: PUSH
61125: LD_INT 1
61127: ARRAY
61128: PPUSH
61129: LD_VAR 0 14
61133: PUSH
61134: LD_VAR 0 9
61138: ARRAY
61139: PUSH
61140: LD_INT 2
61142: ARRAY
61143: PPUSH
61144: CALL_OW 351
61148: PUSH
61149: LD_VAR 0 14
61153: PUSH
61154: LD_VAR 0 9
61158: ARRAY
61159: PUSH
61160: LD_INT 1
61162: ARRAY
61163: PPUSH
61164: LD_VAR 0 14
61168: PUSH
61169: LD_VAR 0 9
61173: ARRAY
61174: PUSH
61175: LD_INT 2
61177: ARRAY
61178: PPUSH
61179: CALL_OW 488
61183: NOT
61184: OR
61185: PUSH
61186: LD_VAR 0 13
61190: PPUSH
61191: CALL_OW 247
61195: PUSH
61196: LD_INT 3
61198: EQUAL
61199: OR
61200: IFFALSE 61206
// exit ;
61202: POP
61203: POP
61204: GO 61750
// if not tmp then
61206: LD_VAR 0 13
61210: NOT
61211: IFFALSE 61215
// continue ;
61213: GO 61071
// result := true ;
61215: LD_ADDR_VAR 0 8
61219: PUSH
61220: LD_INT 1
61222: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
61223: LD_VAR 0 6
61227: PUSH
61228: LD_VAR 0 13
61232: PPUSH
61233: CALL_OW 247
61237: PUSH
61238: LD_INT 2
61240: EQUAL
61241: AND
61242: PUSH
61243: LD_VAR 0 13
61247: PPUSH
61248: CALL_OW 263
61252: PUSH
61253: LD_INT 1
61255: EQUAL
61256: AND
61257: IFFALSE 61421
// begin if IsDrivenBy ( tmp ) then
61259: LD_VAR 0 13
61263: PPUSH
61264: CALL_OW 311
61268: IFFALSE 61272
// continue ;
61270: GO 61071
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
61272: LD_VAR 0 6
61276: PPUSH
61277: LD_INT 3
61279: PUSH
61280: LD_INT 60
61282: PUSH
61283: EMPTY
61284: LIST
61285: PUSH
61286: EMPTY
61287: LIST
61288: LIST
61289: PUSH
61290: LD_INT 3
61292: PUSH
61293: LD_INT 55
61295: PUSH
61296: EMPTY
61297: LIST
61298: PUSH
61299: EMPTY
61300: LIST
61301: LIST
61302: PUSH
61303: EMPTY
61304: LIST
61305: LIST
61306: PPUSH
61307: CALL_OW 72
61311: IFFALSE 61419
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
61313: LD_ADDR_VAR 0 18
61317: PUSH
61318: LD_VAR 0 6
61322: PPUSH
61323: LD_INT 3
61325: PUSH
61326: LD_INT 60
61328: PUSH
61329: EMPTY
61330: LIST
61331: PUSH
61332: EMPTY
61333: LIST
61334: LIST
61335: PUSH
61336: LD_INT 3
61338: PUSH
61339: LD_INT 55
61341: PUSH
61342: EMPTY
61343: LIST
61344: PUSH
61345: EMPTY
61346: LIST
61347: LIST
61348: PUSH
61349: EMPTY
61350: LIST
61351: LIST
61352: PPUSH
61353: CALL_OW 72
61357: PUSH
61358: LD_INT 1
61360: ARRAY
61361: ST_TO_ADDR
// if IsInUnit ( driver ) then
61362: LD_VAR 0 18
61366: PPUSH
61367: CALL_OW 310
61371: IFFALSE 61382
// ComExit ( driver ) ;
61373: LD_VAR 0 18
61377: PPUSH
61378: CALL 86762 0 1
// AddComEnterUnit ( driver , tmp ) ;
61382: LD_VAR 0 18
61386: PPUSH
61387: LD_VAR 0 13
61391: PPUSH
61392: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
61396: LD_VAR 0 18
61400: PPUSH
61401: LD_VAR 0 7
61405: PPUSH
61406: CALL_OW 173
// AddComExitVehicle ( driver ) ;
61410: LD_VAR 0 18
61414: PPUSH
61415: CALL_OW 181
// end ; continue ;
61419: GO 61071
// end ; if not cleaners or not tmp in cleaners then
61421: LD_VAR 0 6
61425: NOT
61426: PUSH
61427: LD_VAR 0 13
61431: PUSH
61432: LD_VAR 0 6
61436: IN
61437: NOT
61438: OR
61439: IFFALSE 61746
// begin if dep then
61441: LD_VAR 0 17
61445: IFFALSE 61581
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
61447: LD_ADDR_VAR 0 16
61451: PUSH
61452: LD_VAR 0 17
61456: PUSH
61457: LD_INT 1
61459: ARRAY
61460: PPUSH
61461: CALL_OW 250
61465: PPUSH
61466: LD_VAR 0 17
61470: PUSH
61471: LD_INT 1
61473: ARRAY
61474: PPUSH
61475: CALL_OW 254
61479: PPUSH
61480: LD_INT 5
61482: PPUSH
61483: CALL_OW 272
61487: PUSH
61488: LD_VAR 0 17
61492: PUSH
61493: LD_INT 1
61495: ARRAY
61496: PPUSH
61497: CALL_OW 251
61501: PPUSH
61502: LD_VAR 0 17
61506: PUSH
61507: LD_INT 1
61509: ARRAY
61510: PPUSH
61511: CALL_OW 254
61515: PPUSH
61516: LD_INT 5
61518: PPUSH
61519: CALL_OW 273
61523: PUSH
61524: EMPTY
61525: LIST
61526: LIST
61527: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
61528: LD_VAR 0 16
61532: PUSH
61533: LD_INT 1
61535: ARRAY
61536: PPUSH
61537: LD_VAR 0 16
61541: PUSH
61542: LD_INT 2
61544: ARRAY
61545: PPUSH
61546: CALL_OW 488
61550: IFFALSE 61581
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
61552: LD_VAR 0 13
61556: PPUSH
61557: LD_VAR 0 16
61561: PUSH
61562: LD_INT 1
61564: ARRAY
61565: PPUSH
61566: LD_VAR 0 16
61570: PUSH
61571: LD_INT 2
61573: ARRAY
61574: PPUSH
61575: CALL_OW 111
// continue ;
61579: GO 61071
// end ; end ; r := GetDir ( tmp ) ;
61581: LD_ADDR_VAR 0 15
61585: PUSH
61586: LD_VAR 0 13
61590: PPUSH
61591: CALL_OW 254
61595: ST_TO_ADDR
// if r = 5 then
61596: LD_VAR 0 15
61600: PUSH
61601: LD_INT 5
61603: EQUAL
61604: IFFALSE 61614
// r := 0 ;
61606: LD_ADDR_VAR 0 15
61610: PUSH
61611: LD_INT 0
61613: ST_TO_ADDR
// for j = r to 5 do
61614: LD_ADDR_VAR 0 10
61618: PUSH
61619: DOUBLE
61620: LD_VAR 0 15
61624: DEC
61625: ST_TO_ADDR
61626: LD_INT 5
61628: PUSH
61629: FOR_TO
61630: IFFALSE 61744
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
61632: LD_ADDR_VAR 0 11
61636: PUSH
61637: LD_VAR 0 13
61641: PPUSH
61642: CALL_OW 250
61646: PPUSH
61647: LD_VAR 0 10
61651: PPUSH
61652: LD_INT 2
61654: PPUSH
61655: CALL_OW 272
61659: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
61660: LD_ADDR_VAR 0 12
61664: PUSH
61665: LD_VAR 0 13
61669: PPUSH
61670: CALL_OW 251
61674: PPUSH
61675: LD_VAR 0 10
61679: PPUSH
61680: LD_INT 2
61682: PPUSH
61683: CALL_OW 273
61687: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
61688: LD_VAR 0 11
61692: PPUSH
61693: LD_VAR 0 12
61697: PPUSH
61698: CALL_OW 488
61702: PUSH
61703: LD_VAR 0 11
61707: PPUSH
61708: LD_VAR 0 12
61712: PPUSH
61713: CALL_OW 428
61717: NOT
61718: AND
61719: IFFALSE 61742
// begin ComMoveXY ( tmp , _x , _y ) ;
61721: LD_VAR 0 13
61725: PPUSH
61726: LD_VAR 0 11
61730: PPUSH
61731: LD_VAR 0 12
61735: PPUSH
61736: CALL_OW 111
// break ;
61740: GO 61744
// end ; end ;
61742: GO 61629
61744: POP
61745: POP
// end ; end ;
61746: GO 61071
61748: POP
61749: POP
// end ;
61750: LD_VAR 0 8
61754: RET
// export function BuildingTechInvented ( side , btype ) ; begin
61755: LD_INT 0
61757: PPUSH
// result := true ;
61758: LD_ADDR_VAR 0 3
61762: PUSH
61763: LD_INT 1
61765: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
61766: LD_VAR 0 2
61770: PUSH
61771: LD_INT 24
61773: DOUBLE
61774: EQUAL
61775: IFTRUE 61785
61777: LD_INT 33
61779: DOUBLE
61780: EQUAL
61781: IFTRUE 61785
61783: GO 61810
61785: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
61786: LD_ADDR_VAR 0 3
61790: PUSH
61791: LD_INT 32
61793: PPUSH
61794: LD_VAR 0 1
61798: PPUSH
61799: CALL_OW 321
61803: PUSH
61804: LD_INT 2
61806: EQUAL
61807: ST_TO_ADDR
61808: GO 62126
61810: LD_INT 20
61812: DOUBLE
61813: EQUAL
61814: IFTRUE 61818
61816: GO 61843
61818: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
61819: LD_ADDR_VAR 0 3
61823: PUSH
61824: LD_INT 6
61826: PPUSH
61827: LD_VAR 0 1
61831: PPUSH
61832: CALL_OW 321
61836: PUSH
61837: LD_INT 2
61839: EQUAL
61840: ST_TO_ADDR
61841: GO 62126
61843: LD_INT 22
61845: DOUBLE
61846: EQUAL
61847: IFTRUE 61857
61849: LD_INT 36
61851: DOUBLE
61852: EQUAL
61853: IFTRUE 61857
61855: GO 61882
61857: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
61858: LD_ADDR_VAR 0 3
61862: PUSH
61863: LD_INT 15
61865: PPUSH
61866: LD_VAR 0 1
61870: PPUSH
61871: CALL_OW 321
61875: PUSH
61876: LD_INT 2
61878: EQUAL
61879: ST_TO_ADDR
61880: GO 62126
61882: LD_INT 30
61884: DOUBLE
61885: EQUAL
61886: IFTRUE 61890
61888: GO 61915
61890: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
61891: LD_ADDR_VAR 0 3
61895: PUSH
61896: LD_INT 20
61898: PPUSH
61899: LD_VAR 0 1
61903: PPUSH
61904: CALL_OW 321
61908: PUSH
61909: LD_INT 2
61911: EQUAL
61912: ST_TO_ADDR
61913: GO 62126
61915: LD_INT 28
61917: DOUBLE
61918: EQUAL
61919: IFTRUE 61929
61921: LD_INT 21
61923: DOUBLE
61924: EQUAL
61925: IFTRUE 61929
61927: GO 61954
61929: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
61930: LD_ADDR_VAR 0 3
61934: PUSH
61935: LD_INT 21
61937: PPUSH
61938: LD_VAR 0 1
61942: PPUSH
61943: CALL_OW 321
61947: PUSH
61948: LD_INT 2
61950: EQUAL
61951: ST_TO_ADDR
61952: GO 62126
61954: LD_INT 16
61956: DOUBLE
61957: EQUAL
61958: IFTRUE 61962
61960: GO 61987
61962: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
61963: LD_ADDR_VAR 0 3
61967: PUSH
61968: LD_INT 84
61970: PPUSH
61971: LD_VAR 0 1
61975: PPUSH
61976: CALL_OW 321
61980: PUSH
61981: LD_INT 2
61983: EQUAL
61984: ST_TO_ADDR
61985: GO 62126
61987: LD_INT 19
61989: DOUBLE
61990: EQUAL
61991: IFTRUE 62001
61993: LD_INT 23
61995: DOUBLE
61996: EQUAL
61997: IFTRUE 62001
61999: GO 62026
62001: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
62002: LD_ADDR_VAR 0 3
62006: PUSH
62007: LD_INT 83
62009: PPUSH
62010: LD_VAR 0 1
62014: PPUSH
62015: CALL_OW 321
62019: PUSH
62020: LD_INT 2
62022: EQUAL
62023: ST_TO_ADDR
62024: GO 62126
62026: LD_INT 17
62028: DOUBLE
62029: EQUAL
62030: IFTRUE 62034
62032: GO 62059
62034: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
62035: LD_ADDR_VAR 0 3
62039: PUSH
62040: LD_INT 39
62042: PPUSH
62043: LD_VAR 0 1
62047: PPUSH
62048: CALL_OW 321
62052: PUSH
62053: LD_INT 2
62055: EQUAL
62056: ST_TO_ADDR
62057: GO 62126
62059: LD_INT 18
62061: DOUBLE
62062: EQUAL
62063: IFTRUE 62067
62065: GO 62092
62067: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
62068: LD_ADDR_VAR 0 3
62072: PUSH
62073: LD_INT 40
62075: PPUSH
62076: LD_VAR 0 1
62080: PPUSH
62081: CALL_OW 321
62085: PUSH
62086: LD_INT 2
62088: EQUAL
62089: ST_TO_ADDR
62090: GO 62126
62092: LD_INT 27
62094: DOUBLE
62095: EQUAL
62096: IFTRUE 62100
62098: GO 62125
62100: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
62101: LD_ADDR_VAR 0 3
62105: PUSH
62106: LD_INT 35
62108: PPUSH
62109: LD_VAR 0 1
62113: PPUSH
62114: CALL_OW 321
62118: PUSH
62119: LD_INT 2
62121: EQUAL
62122: ST_TO_ADDR
62123: GO 62126
62125: POP
// end ;
62126: LD_VAR 0 3
62130: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
62131: LD_INT 0
62133: PPUSH
62134: PPUSH
62135: PPUSH
62136: PPUSH
62137: PPUSH
62138: PPUSH
62139: PPUSH
62140: PPUSH
62141: PPUSH
62142: PPUSH
62143: PPUSH
// result := false ;
62144: LD_ADDR_VAR 0 6
62148: PUSH
62149: LD_INT 0
62151: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
62152: LD_VAR 0 1
62156: NOT
62157: PUSH
62158: LD_VAR 0 1
62162: PPUSH
62163: CALL_OW 266
62167: PUSH
62168: LD_INT 0
62170: PUSH
62171: LD_INT 1
62173: PUSH
62174: EMPTY
62175: LIST
62176: LIST
62177: IN
62178: NOT
62179: OR
62180: PUSH
62181: LD_VAR 0 2
62185: NOT
62186: OR
62187: PUSH
62188: LD_VAR 0 5
62192: PUSH
62193: LD_INT 0
62195: PUSH
62196: LD_INT 1
62198: PUSH
62199: LD_INT 2
62201: PUSH
62202: LD_INT 3
62204: PUSH
62205: LD_INT 4
62207: PUSH
62208: LD_INT 5
62210: PUSH
62211: EMPTY
62212: LIST
62213: LIST
62214: LIST
62215: LIST
62216: LIST
62217: LIST
62218: IN
62219: NOT
62220: OR
62221: PUSH
62222: LD_VAR 0 3
62226: PPUSH
62227: LD_VAR 0 4
62231: PPUSH
62232: CALL_OW 488
62236: NOT
62237: OR
62238: IFFALSE 62242
// exit ;
62240: GO 62978
// side := GetSide ( depot ) ;
62242: LD_ADDR_VAR 0 9
62246: PUSH
62247: LD_VAR 0 1
62251: PPUSH
62252: CALL_OW 255
62256: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
62257: LD_VAR 0 9
62261: PPUSH
62262: LD_VAR 0 2
62266: PPUSH
62267: CALL 61755 0 2
62271: NOT
62272: IFFALSE 62276
// exit ;
62274: GO 62978
// pom := GetBase ( depot ) ;
62276: LD_ADDR_VAR 0 10
62280: PUSH
62281: LD_VAR 0 1
62285: PPUSH
62286: CALL_OW 274
62290: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
62291: LD_ADDR_VAR 0 11
62295: PUSH
62296: LD_VAR 0 2
62300: PPUSH
62301: LD_VAR 0 1
62305: PPUSH
62306: CALL_OW 248
62310: PPUSH
62311: CALL_OW 450
62315: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
62316: LD_VAR 0 10
62320: PPUSH
62321: LD_INT 1
62323: PPUSH
62324: CALL_OW 275
62328: PUSH
62329: LD_VAR 0 11
62333: PUSH
62334: LD_INT 1
62336: ARRAY
62337: GREATEREQUAL
62338: PUSH
62339: LD_VAR 0 10
62343: PPUSH
62344: LD_INT 2
62346: PPUSH
62347: CALL_OW 275
62351: PUSH
62352: LD_VAR 0 11
62356: PUSH
62357: LD_INT 2
62359: ARRAY
62360: GREATEREQUAL
62361: AND
62362: PUSH
62363: LD_VAR 0 10
62367: PPUSH
62368: LD_INT 3
62370: PPUSH
62371: CALL_OW 275
62375: PUSH
62376: LD_VAR 0 11
62380: PUSH
62381: LD_INT 3
62383: ARRAY
62384: GREATEREQUAL
62385: AND
62386: NOT
62387: IFFALSE 62391
// exit ;
62389: GO 62978
// if GetBType ( depot ) = b_depot then
62391: LD_VAR 0 1
62395: PPUSH
62396: CALL_OW 266
62400: PUSH
62401: LD_INT 0
62403: EQUAL
62404: IFFALSE 62416
// dist := 28 else
62406: LD_ADDR_VAR 0 14
62410: PUSH
62411: LD_INT 28
62413: ST_TO_ADDR
62414: GO 62424
// dist := 36 ;
62416: LD_ADDR_VAR 0 14
62420: PUSH
62421: LD_INT 36
62423: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
62424: LD_VAR 0 1
62428: PPUSH
62429: LD_VAR 0 3
62433: PPUSH
62434: LD_VAR 0 4
62438: PPUSH
62439: CALL_OW 297
62443: PUSH
62444: LD_VAR 0 14
62448: GREATER
62449: IFFALSE 62453
// exit ;
62451: GO 62978
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
62453: LD_ADDR_VAR 0 12
62457: PUSH
62458: LD_VAR 0 2
62462: PPUSH
62463: LD_VAR 0 3
62467: PPUSH
62468: LD_VAR 0 4
62472: PPUSH
62473: LD_VAR 0 5
62477: PPUSH
62478: LD_VAR 0 1
62482: PPUSH
62483: CALL_OW 248
62487: PPUSH
62488: LD_INT 0
62490: PPUSH
62491: CALL 62983 0 6
62495: ST_TO_ADDR
// if not hexes then
62496: LD_VAR 0 12
62500: NOT
62501: IFFALSE 62505
// exit ;
62503: GO 62978
// hex := GetHexInfo ( x , y ) ;
62505: LD_ADDR_VAR 0 15
62509: PUSH
62510: LD_VAR 0 3
62514: PPUSH
62515: LD_VAR 0 4
62519: PPUSH
62520: CALL_OW 546
62524: ST_TO_ADDR
// if hex [ 1 ] then
62525: LD_VAR 0 15
62529: PUSH
62530: LD_INT 1
62532: ARRAY
62533: IFFALSE 62537
// exit ;
62535: GO 62978
// height := hex [ 2 ] ;
62537: LD_ADDR_VAR 0 13
62541: PUSH
62542: LD_VAR 0 15
62546: PUSH
62547: LD_INT 2
62549: ARRAY
62550: ST_TO_ADDR
// for i = 1 to hexes do
62551: LD_ADDR_VAR 0 7
62555: PUSH
62556: DOUBLE
62557: LD_INT 1
62559: DEC
62560: ST_TO_ADDR
62561: LD_VAR 0 12
62565: PUSH
62566: FOR_TO
62567: IFFALSE 62897
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
62569: LD_VAR 0 12
62573: PUSH
62574: LD_VAR 0 7
62578: ARRAY
62579: PUSH
62580: LD_INT 1
62582: ARRAY
62583: PPUSH
62584: LD_VAR 0 12
62588: PUSH
62589: LD_VAR 0 7
62593: ARRAY
62594: PUSH
62595: LD_INT 2
62597: ARRAY
62598: PPUSH
62599: CALL_OW 488
62603: NOT
62604: PUSH
62605: LD_VAR 0 12
62609: PUSH
62610: LD_VAR 0 7
62614: ARRAY
62615: PUSH
62616: LD_INT 1
62618: ARRAY
62619: PPUSH
62620: LD_VAR 0 12
62624: PUSH
62625: LD_VAR 0 7
62629: ARRAY
62630: PUSH
62631: LD_INT 2
62633: ARRAY
62634: PPUSH
62635: CALL_OW 428
62639: PUSH
62640: LD_INT 0
62642: GREATER
62643: OR
62644: PUSH
62645: LD_VAR 0 12
62649: PUSH
62650: LD_VAR 0 7
62654: ARRAY
62655: PUSH
62656: LD_INT 1
62658: ARRAY
62659: PPUSH
62660: LD_VAR 0 12
62664: PUSH
62665: LD_VAR 0 7
62669: ARRAY
62670: PUSH
62671: LD_INT 2
62673: ARRAY
62674: PPUSH
62675: CALL_OW 351
62679: OR
62680: IFFALSE 62686
// exit ;
62682: POP
62683: POP
62684: GO 62978
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
62686: LD_ADDR_VAR 0 8
62690: PUSH
62691: LD_VAR 0 12
62695: PUSH
62696: LD_VAR 0 7
62700: ARRAY
62701: PUSH
62702: LD_INT 1
62704: ARRAY
62705: PPUSH
62706: LD_VAR 0 12
62710: PUSH
62711: LD_VAR 0 7
62715: ARRAY
62716: PUSH
62717: LD_INT 2
62719: ARRAY
62720: PPUSH
62721: CALL_OW 546
62725: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
62726: LD_VAR 0 8
62730: PUSH
62731: LD_INT 1
62733: ARRAY
62734: PUSH
62735: LD_VAR 0 8
62739: PUSH
62740: LD_INT 2
62742: ARRAY
62743: PUSH
62744: LD_VAR 0 13
62748: PUSH
62749: LD_INT 2
62751: PLUS
62752: GREATER
62753: OR
62754: PUSH
62755: LD_VAR 0 8
62759: PUSH
62760: LD_INT 2
62762: ARRAY
62763: PUSH
62764: LD_VAR 0 13
62768: PUSH
62769: LD_INT 2
62771: MINUS
62772: LESS
62773: OR
62774: PUSH
62775: LD_VAR 0 8
62779: PUSH
62780: LD_INT 3
62782: ARRAY
62783: PUSH
62784: LD_INT 0
62786: PUSH
62787: LD_INT 8
62789: PUSH
62790: LD_INT 9
62792: PUSH
62793: LD_INT 10
62795: PUSH
62796: LD_INT 11
62798: PUSH
62799: LD_INT 12
62801: PUSH
62802: LD_INT 13
62804: PUSH
62805: LD_INT 16
62807: PUSH
62808: LD_INT 17
62810: PUSH
62811: LD_INT 18
62813: PUSH
62814: LD_INT 19
62816: PUSH
62817: LD_INT 20
62819: PUSH
62820: LD_INT 21
62822: PUSH
62823: EMPTY
62824: LIST
62825: LIST
62826: LIST
62827: LIST
62828: LIST
62829: LIST
62830: LIST
62831: LIST
62832: LIST
62833: LIST
62834: LIST
62835: LIST
62836: LIST
62837: IN
62838: NOT
62839: OR
62840: PUSH
62841: LD_VAR 0 8
62845: PUSH
62846: LD_INT 5
62848: ARRAY
62849: NOT
62850: OR
62851: PUSH
62852: LD_VAR 0 8
62856: PUSH
62857: LD_INT 6
62859: ARRAY
62860: PUSH
62861: LD_INT 1
62863: PUSH
62864: LD_INT 2
62866: PUSH
62867: LD_INT 7
62869: PUSH
62870: LD_INT 9
62872: PUSH
62873: LD_INT 10
62875: PUSH
62876: LD_INT 11
62878: PUSH
62879: EMPTY
62880: LIST
62881: LIST
62882: LIST
62883: LIST
62884: LIST
62885: LIST
62886: IN
62887: NOT
62888: OR
62889: IFFALSE 62895
// exit ;
62891: POP
62892: POP
62893: GO 62978
// end ;
62895: GO 62566
62897: POP
62898: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
62899: LD_VAR 0 9
62903: PPUSH
62904: LD_VAR 0 3
62908: PPUSH
62909: LD_VAR 0 4
62913: PPUSH
62914: LD_INT 20
62916: PPUSH
62917: CALL 54930 0 4
62921: PUSH
62922: LD_INT 4
62924: ARRAY
62925: IFFALSE 62929
// exit ;
62927: GO 62978
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
62929: LD_VAR 0 2
62933: PUSH
62934: LD_INT 29
62936: PUSH
62937: LD_INT 30
62939: PUSH
62940: EMPTY
62941: LIST
62942: LIST
62943: IN
62944: PUSH
62945: LD_VAR 0 3
62949: PPUSH
62950: LD_VAR 0 4
62954: PPUSH
62955: LD_VAR 0 9
62959: PPUSH
62960: CALL_OW 440
62964: NOT
62965: AND
62966: IFFALSE 62970
// exit ;
62968: GO 62978
// result := true ;
62970: LD_ADDR_VAR 0 6
62974: PUSH
62975: LD_INT 1
62977: ST_TO_ADDR
// end ;
62978: LD_VAR 0 6
62982: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
62983: LD_INT 0
62985: PPUSH
62986: PPUSH
62987: PPUSH
62988: PPUSH
62989: PPUSH
62990: PPUSH
62991: PPUSH
62992: PPUSH
62993: PPUSH
62994: PPUSH
62995: PPUSH
62996: PPUSH
62997: PPUSH
62998: PPUSH
62999: PPUSH
63000: PPUSH
63001: PPUSH
63002: PPUSH
63003: PPUSH
63004: PPUSH
63005: PPUSH
63006: PPUSH
63007: PPUSH
63008: PPUSH
63009: PPUSH
63010: PPUSH
63011: PPUSH
63012: PPUSH
63013: PPUSH
63014: PPUSH
63015: PPUSH
63016: PPUSH
63017: PPUSH
63018: PPUSH
63019: PPUSH
63020: PPUSH
63021: PPUSH
63022: PPUSH
63023: PPUSH
63024: PPUSH
63025: PPUSH
63026: PPUSH
63027: PPUSH
63028: PPUSH
63029: PPUSH
63030: PPUSH
63031: PPUSH
63032: PPUSH
63033: PPUSH
63034: PPUSH
63035: PPUSH
63036: PPUSH
63037: PPUSH
63038: PPUSH
63039: PPUSH
63040: PPUSH
63041: PPUSH
63042: PPUSH
// result = [ ] ;
63043: LD_ADDR_VAR 0 7
63047: PUSH
63048: EMPTY
63049: ST_TO_ADDR
// temp_list = [ ] ;
63050: LD_ADDR_VAR 0 9
63054: PUSH
63055: EMPTY
63056: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
63057: LD_VAR 0 4
63061: PUSH
63062: LD_INT 0
63064: PUSH
63065: LD_INT 1
63067: PUSH
63068: LD_INT 2
63070: PUSH
63071: LD_INT 3
63073: PUSH
63074: LD_INT 4
63076: PUSH
63077: LD_INT 5
63079: PUSH
63080: EMPTY
63081: LIST
63082: LIST
63083: LIST
63084: LIST
63085: LIST
63086: LIST
63087: IN
63088: NOT
63089: PUSH
63090: LD_VAR 0 1
63094: PUSH
63095: LD_INT 0
63097: PUSH
63098: LD_INT 1
63100: PUSH
63101: EMPTY
63102: LIST
63103: LIST
63104: IN
63105: PUSH
63106: LD_VAR 0 5
63110: PUSH
63111: LD_INT 1
63113: PUSH
63114: LD_INT 2
63116: PUSH
63117: LD_INT 3
63119: PUSH
63120: EMPTY
63121: LIST
63122: LIST
63123: LIST
63124: IN
63125: NOT
63126: AND
63127: OR
63128: IFFALSE 63132
// exit ;
63130: GO 81523
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
63132: LD_VAR 0 1
63136: PUSH
63137: LD_INT 6
63139: PUSH
63140: LD_INT 7
63142: PUSH
63143: LD_INT 8
63145: PUSH
63146: LD_INT 13
63148: PUSH
63149: LD_INT 12
63151: PUSH
63152: LD_INT 15
63154: PUSH
63155: LD_INT 11
63157: PUSH
63158: LD_INT 14
63160: PUSH
63161: LD_INT 10
63163: PUSH
63164: EMPTY
63165: LIST
63166: LIST
63167: LIST
63168: LIST
63169: LIST
63170: LIST
63171: LIST
63172: LIST
63173: LIST
63174: IN
63175: IFFALSE 63185
// btype = b_lab ;
63177: LD_ADDR_VAR 0 1
63181: PUSH
63182: LD_INT 6
63184: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
63185: LD_VAR 0 6
63189: PUSH
63190: LD_INT 0
63192: PUSH
63193: LD_INT 1
63195: PUSH
63196: LD_INT 2
63198: PUSH
63199: EMPTY
63200: LIST
63201: LIST
63202: LIST
63203: IN
63204: NOT
63205: PUSH
63206: LD_VAR 0 1
63210: PUSH
63211: LD_INT 0
63213: PUSH
63214: LD_INT 1
63216: PUSH
63217: LD_INT 2
63219: PUSH
63220: LD_INT 3
63222: PUSH
63223: LD_INT 6
63225: PUSH
63226: LD_INT 36
63228: PUSH
63229: LD_INT 4
63231: PUSH
63232: LD_INT 5
63234: PUSH
63235: LD_INT 31
63237: PUSH
63238: LD_INT 32
63240: PUSH
63241: LD_INT 33
63243: PUSH
63244: EMPTY
63245: LIST
63246: LIST
63247: LIST
63248: LIST
63249: LIST
63250: LIST
63251: LIST
63252: LIST
63253: LIST
63254: LIST
63255: LIST
63256: IN
63257: NOT
63258: PUSH
63259: LD_VAR 0 6
63263: PUSH
63264: LD_INT 1
63266: EQUAL
63267: AND
63268: OR
63269: PUSH
63270: LD_VAR 0 1
63274: PUSH
63275: LD_INT 2
63277: PUSH
63278: LD_INT 3
63280: PUSH
63281: EMPTY
63282: LIST
63283: LIST
63284: IN
63285: NOT
63286: PUSH
63287: LD_VAR 0 6
63291: PUSH
63292: LD_INT 2
63294: EQUAL
63295: AND
63296: OR
63297: IFFALSE 63307
// mode = 0 ;
63299: LD_ADDR_VAR 0 6
63303: PUSH
63304: LD_INT 0
63306: ST_TO_ADDR
// case mode of 0 :
63307: LD_VAR 0 6
63311: PUSH
63312: LD_INT 0
63314: DOUBLE
63315: EQUAL
63316: IFTRUE 63320
63318: GO 74773
63320: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
63321: LD_ADDR_VAR 0 11
63325: PUSH
63326: LD_INT 0
63328: PUSH
63329: LD_INT 0
63331: PUSH
63332: EMPTY
63333: LIST
63334: LIST
63335: PUSH
63336: LD_INT 0
63338: PUSH
63339: LD_INT 1
63341: NEG
63342: PUSH
63343: EMPTY
63344: LIST
63345: LIST
63346: PUSH
63347: LD_INT 1
63349: PUSH
63350: LD_INT 0
63352: PUSH
63353: EMPTY
63354: LIST
63355: LIST
63356: PUSH
63357: LD_INT 1
63359: PUSH
63360: LD_INT 1
63362: PUSH
63363: EMPTY
63364: LIST
63365: LIST
63366: PUSH
63367: LD_INT 0
63369: PUSH
63370: LD_INT 1
63372: PUSH
63373: EMPTY
63374: LIST
63375: LIST
63376: PUSH
63377: LD_INT 1
63379: NEG
63380: PUSH
63381: LD_INT 0
63383: PUSH
63384: EMPTY
63385: LIST
63386: LIST
63387: PUSH
63388: LD_INT 1
63390: NEG
63391: PUSH
63392: LD_INT 1
63394: NEG
63395: PUSH
63396: EMPTY
63397: LIST
63398: LIST
63399: PUSH
63400: LD_INT 1
63402: NEG
63403: PUSH
63404: LD_INT 2
63406: NEG
63407: PUSH
63408: EMPTY
63409: LIST
63410: LIST
63411: PUSH
63412: LD_INT 0
63414: PUSH
63415: LD_INT 2
63417: NEG
63418: PUSH
63419: EMPTY
63420: LIST
63421: LIST
63422: PUSH
63423: LD_INT 1
63425: PUSH
63426: LD_INT 1
63428: NEG
63429: PUSH
63430: EMPTY
63431: LIST
63432: LIST
63433: PUSH
63434: LD_INT 1
63436: PUSH
63437: LD_INT 2
63439: PUSH
63440: EMPTY
63441: LIST
63442: LIST
63443: PUSH
63444: LD_INT 0
63446: PUSH
63447: LD_INT 2
63449: PUSH
63450: EMPTY
63451: LIST
63452: LIST
63453: PUSH
63454: LD_INT 1
63456: NEG
63457: PUSH
63458: LD_INT 1
63460: PUSH
63461: EMPTY
63462: LIST
63463: LIST
63464: PUSH
63465: LD_INT 1
63467: PUSH
63468: LD_INT 3
63470: PUSH
63471: EMPTY
63472: LIST
63473: LIST
63474: PUSH
63475: LD_INT 0
63477: PUSH
63478: LD_INT 3
63480: PUSH
63481: EMPTY
63482: LIST
63483: LIST
63484: PUSH
63485: LD_INT 1
63487: NEG
63488: PUSH
63489: LD_INT 2
63491: PUSH
63492: EMPTY
63493: LIST
63494: LIST
63495: PUSH
63496: EMPTY
63497: LIST
63498: LIST
63499: LIST
63500: LIST
63501: LIST
63502: LIST
63503: LIST
63504: LIST
63505: LIST
63506: LIST
63507: LIST
63508: LIST
63509: LIST
63510: LIST
63511: LIST
63512: LIST
63513: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
63514: LD_ADDR_VAR 0 12
63518: PUSH
63519: LD_INT 0
63521: PUSH
63522: LD_INT 0
63524: PUSH
63525: EMPTY
63526: LIST
63527: LIST
63528: PUSH
63529: LD_INT 0
63531: PUSH
63532: LD_INT 1
63534: NEG
63535: PUSH
63536: EMPTY
63537: LIST
63538: LIST
63539: PUSH
63540: LD_INT 1
63542: PUSH
63543: LD_INT 0
63545: PUSH
63546: EMPTY
63547: LIST
63548: LIST
63549: PUSH
63550: LD_INT 1
63552: PUSH
63553: LD_INT 1
63555: PUSH
63556: EMPTY
63557: LIST
63558: LIST
63559: PUSH
63560: LD_INT 0
63562: PUSH
63563: LD_INT 1
63565: PUSH
63566: EMPTY
63567: LIST
63568: LIST
63569: PUSH
63570: LD_INT 1
63572: NEG
63573: PUSH
63574: LD_INT 0
63576: PUSH
63577: EMPTY
63578: LIST
63579: LIST
63580: PUSH
63581: LD_INT 1
63583: NEG
63584: PUSH
63585: LD_INT 1
63587: NEG
63588: PUSH
63589: EMPTY
63590: LIST
63591: LIST
63592: PUSH
63593: LD_INT 1
63595: PUSH
63596: LD_INT 1
63598: NEG
63599: PUSH
63600: EMPTY
63601: LIST
63602: LIST
63603: PUSH
63604: LD_INT 2
63606: PUSH
63607: LD_INT 0
63609: PUSH
63610: EMPTY
63611: LIST
63612: LIST
63613: PUSH
63614: LD_INT 2
63616: PUSH
63617: LD_INT 1
63619: PUSH
63620: EMPTY
63621: LIST
63622: LIST
63623: PUSH
63624: LD_INT 1
63626: NEG
63627: PUSH
63628: LD_INT 1
63630: PUSH
63631: EMPTY
63632: LIST
63633: LIST
63634: PUSH
63635: LD_INT 2
63637: NEG
63638: PUSH
63639: LD_INT 0
63641: PUSH
63642: EMPTY
63643: LIST
63644: LIST
63645: PUSH
63646: LD_INT 2
63648: NEG
63649: PUSH
63650: LD_INT 1
63652: NEG
63653: PUSH
63654: EMPTY
63655: LIST
63656: LIST
63657: PUSH
63658: LD_INT 2
63660: NEG
63661: PUSH
63662: LD_INT 1
63664: PUSH
63665: EMPTY
63666: LIST
63667: LIST
63668: PUSH
63669: LD_INT 3
63671: NEG
63672: PUSH
63673: LD_INT 0
63675: PUSH
63676: EMPTY
63677: LIST
63678: LIST
63679: PUSH
63680: LD_INT 3
63682: NEG
63683: PUSH
63684: LD_INT 1
63686: NEG
63687: PUSH
63688: EMPTY
63689: LIST
63690: LIST
63691: PUSH
63692: EMPTY
63693: LIST
63694: LIST
63695: LIST
63696: LIST
63697: LIST
63698: LIST
63699: LIST
63700: LIST
63701: LIST
63702: LIST
63703: LIST
63704: LIST
63705: LIST
63706: LIST
63707: LIST
63708: LIST
63709: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
63710: LD_ADDR_VAR 0 13
63714: PUSH
63715: LD_INT 0
63717: PUSH
63718: LD_INT 0
63720: PUSH
63721: EMPTY
63722: LIST
63723: LIST
63724: PUSH
63725: LD_INT 0
63727: PUSH
63728: LD_INT 1
63730: NEG
63731: PUSH
63732: EMPTY
63733: LIST
63734: LIST
63735: PUSH
63736: LD_INT 1
63738: PUSH
63739: LD_INT 0
63741: PUSH
63742: EMPTY
63743: LIST
63744: LIST
63745: PUSH
63746: LD_INT 1
63748: PUSH
63749: LD_INT 1
63751: PUSH
63752: EMPTY
63753: LIST
63754: LIST
63755: PUSH
63756: LD_INT 0
63758: PUSH
63759: LD_INT 1
63761: PUSH
63762: EMPTY
63763: LIST
63764: LIST
63765: PUSH
63766: LD_INT 1
63768: NEG
63769: PUSH
63770: LD_INT 0
63772: PUSH
63773: EMPTY
63774: LIST
63775: LIST
63776: PUSH
63777: LD_INT 1
63779: NEG
63780: PUSH
63781: LD_INT 1
63783: NEG
63784: PUSH
63785: EMPTY
63786: LIST
63787: LIST
63788: PUSH
63789: LD_INT 1
63791: NEG
63792: PUSH
63793: LD_INT 2
63795: NEG
63796: PUSH
63797: EMPTY
63798: LIST
63799: LIST
63800: PUSH
63801: LD_INT 2
63803: PUSH
63804: LD_INT 1
63806: PUSH
63807: EMPTY
63808: LIST
63809: LIST
63810: PUSH
63811: LD_INT 2
63813: PUSH
63814: LD_INT 2
63816: PUSH
63817: EMPTY
63818: LIST
63819: LIST
63820: PUSH
63821: LD_INT 1
63823: PUSH
63824: LD_INT 2
63826: PUSH
63827: EMPTY
63828: LIST
63829: LIST
63830: PUSH
63831: LD_INT 2
63833: NEG
63834: PUSH
63835: LD_INT 1
63837: NEG
63838: PUSH
63839: EMPTY
63840: LIST
63841: LIST
63842: PUSH
63843: LD_INT 2
63845: NEG
63846: PUSH
63847: LD_INT 2
63849: NEG
63850: PUSH
63851: EMPTY
63852: LIST
63853: LIST
63854: PUSH
63855: LD_INT 2
63857: NEG
63858: PUSH
63859: LD_INT 3
63861: NEG
63862: PUSH
63863: EMPTY
63864: LIST
63865: LIST
63866: PUSH
63867: LD_INT 3
63869: NEG
63870: PUSH
63871: LD_INT 2
63873: NEG
63874: PUSH
63875: EMPTY
63876: LIST
63877: LIST
63878: PUSH
63879: LD_INT 3
63881: NEG
63882: PUSH
63883: LD_INT 3
63885: NEG
63886: PUSH
63887: EMPTY
63888: LIST
63889: LIST
63890: PUSH
63891: EMPTY
63892: LIST
63893: LIST
63894: LIST
63895: LIST
63896: LIST
63897: LIST
63898: LIST
63899: LIST
63900: LIST
63901: LIST
63902: LIST
63903: LIST
63904: LIST
63905: LIST
63906: LIST
63907: LIST
63908: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
63909: LD_ADDR_VAR 0 14
63913: PUSH
63914: LD_INT 0
63916: PUSH
63917: LD_INT 0
63919: PUSH
63920: EMPTY
63921: LIST
63922: LIST
63923: PUSH
63924: LD_INT 0
63926: PUSH
63927: LD_INT 1
63929: NEG
63930: PUSH
63931: EMPTY
63932: LIST
63933: LIST
63934: PUSH
63935: LD_INT 1
63937: PUSH
63938: LD_INT 0
63940: PUSH
63941: EMPTY
63942: LIST
63943: LIST
63944: PUSH
63945: LD_INT 1
63947: PUSH
63948: LD_INT 1
63950: PUSH
63951: EMPTY
63952: LIST
63953: LIST
63954: PUSH
63955: LD_INT 0
63957: PUSH
63958: LD_INT 1
63960: PUSH
63961: EMPTY
63962: LIST
63963: LIST
63964: PUSH
63965: LD_INT 1
63967: NEG
63968: PUSH
63969: LD_INT 0
63971: PUSH
63972: EMPTY
63973: LIST
63974: LIST
63975: PUSH
63976: LD_INT 1
63978: NEG
63979: PUSH
63980: LD_INT 1
63982: NEG
63983: PUSH
63984: EMPTY
63985: LIST
63986: LIST
63987: PUSH
63988: LD_INT 1
63990: NEG
63991: PUSH
63992: LD_INT 2
63994: NEG
63995: PUSH
63996: EMPTY
63997: LIST
63998: LIST
63999: PUSH
64000: LD_INT 0
64002: PUSH
64003: LD_INT 2
64005: NEG
64006: PUSH
64007: EMPTY
64008: LIST
64009: LIST
64010: PUSH
64011: LD_INT 1
64013: PUSH
64014: LD_INT 1
64016: NEG
64017: PUSH
64018: EMPTY
64019: LIST
64020: LIST
64021: PUSH
64022: LD_INT 1
64024: PUSH
64025: LD_INT 2
64027: PUSH
64028: EMPTY
64029: LIST
64030: LIST
64031: PUSH
64032: LD_INT 0
64034: PUSH
64035: LD_INT 2
64037: PUSH
64038: EMPTY
64039: LIST
64040: LIST
64041: PUSH
64042: LD_INT 1
64044: NEG
64045: PUSH
64046: LD_INT 1
64048: PUSH
64049: EMPTY
64050: LIST
64051: LIST
64052: PUSH
64053: LD_INT 1
64055: NEG
64056: PUSH
64057: LD_INT 3
64059: NEG
64060: PUSH
64061: EMPTY
64062: LIST
64063: LIST
64064: PUSH
64065: LD_INT 0
64067: PUSH
64068: LD_INT 3
64070: NEG
64071: PUSH
64072: EMPTY
64073: LIST
64074: LIST
64075: PUSH
64076: LD_INT 1
64078: PUSH
64079: LD_INT 2
64081: NEG
64082: PUSH
64083: EMPTY
64084: LIST
64085: LIST
64086: PUSH
64087: EMPTY
64088: LIST
64089: LIST
64090: LIST
64091: LIST
64092: LIST
64093: LIST
64094: LIST
64095: LIST
64096: LIST
64097: LIST
64098: LIST
64099: LIST
64100: LIST
64101: LIST
64102: LIST
64103: LIST
64104: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
64105: LD_ADDR_VAR 0 15
64109: PUSH
64110: LD_INT 0
64112: PUSH
64113: LD_INT 0
64115: PUSH
64116: EMPTY
64117: LIST
64118: LIST
64119: PUSH
64120: LD_INT 0
64122: PUSH
64123: LD_INT 1
64125: NEG
64126: PUSH
64127: EMPTY
64128: LIST
64129: LIST
64130: PUSH
64131: LD_INT 1
64133: PUSH
64134: LD_INT 0
64136: PUSH
64137: EMPTY
64138: LIST
64139: LIST
64140: PUSH
64141: LD_INT 1
64143: PUSH
64144: LD_INT 1
64146: PUSH
64147: EMPTY
64148: LIST
64149: LIST
64150: PUSH
64151: LD_INT 0
64153: PUSH
64154: LD_INT 1
64156: PUSH
64157: EMPTY
64158: LIST
64159: LIST
64160: PUSH
64161: LD_INT 1
64163: NEG
64164: PUSH
64165: LD_INT 0
64167: PUSH
64168: EMPTY
64169: LIST
64170: LIST
64171: PUSH
64172: LD_INT 1
64174: NEG
64175: PUSH
64176: LD_INT 1
64178: NEG
64179: PUSH
64180: EMPTY
64181: LIST
64182: LIST
64183: PUSH
64184: LD_INT 1
64186: PUSH
64187: LD_INT 1
64189: NEG
64190: PUSH
64191: EMPTY
64192: LIST
64193: LIST
64194: PUSH
64195: LD_INT 2
64197: PUSH
64198: LD_INT 0
64200: PUSH
64201: EMPTY
64202: LIST
64203: LIST
64204: PUSH
64205: LD_INT 2
64207: PUSH
64208: LD_INT 1
64210: PUSH
64211: EMPTY
64212: LIST
64213: LIST
64214: PUSH
64215: LD_INT 1
64217: NEG
64218: PUSH
64219: LD_INT 1
64221: PUSH
64222: EMPTY
64223: LIST
64224: LIST
64225: PUSH
64226: LD_INT 2
64228: NEG
64229: PUSH
64230: LD_INT 0
64232: PUSH
64233: EMPTY
64234: LIST
64235: LIST
64236: PUSH
64237: LD_INT 2
64239: NEG
64240: PUSH
64241: LD_INT 1
64243: NEG
64244: PUSH
64245: EMPTY
64246: LIST
64247: LIST
64248: PUSH
64249: LD_INT 2
64251: PUSH
64252: LD_INT 1
64254: NEG
64255: PUSH
64256: EMPTY
64257: LIST
64258: LIST
64259: PUSH
64260: LD_INT 3
64262: PUSH
64263: LD_INT 0
64265: PUSH
64266: EMPTY
64267: LIST
64268: LIST
64269: PUSH
64270: LD_INT 3
64272: PUSH
64273: LD_INT 1
64275: PUSH
64276: EMPTY
64277: LIST
64278: LIST
64279: PUSH
64280: EMPTY
64281: LIST
64282: LIST
64283: LIST
64284: LIST
64285: LIST
64286: LIST
64287: LIST
64288: LIST
64289: LIST
64290: LIST
64291: LIST
64292: LIST
64293: LIST
64294: LIST
64295: LIST
64296: LIST
64297: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
64298: LD_ADDR_VAR 0 16
64302: PUSH
64303: LD_INT 0
64305: PUSH
64306: LD_INT 0
64308: PUSH
64309: EMPTY
64310: LIST
64311: LIST
64312: PUSH
64313: LD_INT 0
64315: PUSH
64316: LD_INT 1
64318: NEG
64319: PUSH
64320: EMPTY
64321: LIST
64322: LIST
64323: PUSH
64324: LD_INT 1
64326: PUSH
64327: LD_INT 0
64329: PUSH
64330: EMPTY
64331: LIST
64332: LIST
64333: PUSH
64334: LD_INT 1
64336: PUSH
64337: LD_INT 1
64339: PUSH
64340: EMPTY
64341: LIST
64342: LIST
64343: PUSH
64344: LD_INT 0
64346: PUSH
64347: LD_INT 1
64349: PUSH
64350: EMPTY
64351: LIST
64352: LIST
64353: PUSH
64354: LD_INT 1
64356: NEG
64357: PUSH
64358: LD_INT 0
64360: PUSH
64361: EMPTY
64362: LIST
64363: LIST
64364: PUSH
64365: LD_INT 1
64367: NEG
64368: PUSH
64369: LD_INT 1
64371: NEG
64372: PUSH
64373: EMPTY
64374: LIST
64375: LIST
64376: PUSH
64377: LD_INT 1
64379: NEG
64380: PUSH
64381: LD_INT 2
64383: NEG
64384: PUSH
64385: EMPTY
64386: LIST
64387: LIST
64388: PUSH
64389: LD_INT 2
64391: PUSH
64392: LD_INT 1
64394: PUSH
64395: EMPTY
64396: LIST
64397: LIST
64398: PUSH
64399: LD_INT 2
64401: PUSH
64402: LD_INT 2
64404: PUSH
64405: EMPTY
64406: LIST
64407: LIST
64408: PUSH
64409: LD_INT 1
64411: PUSH
64412: LD_INT 2
64414: PUSH
64415: EMPTY
64416: LIST
64417: LIST
64418: PUSH
64419: LD_INT 2
64421: NEG
64422: PUSH
64423: LD_INT 1
64425: NEG
64426: PUSH
64427: EMPTY
64428: LIST
64429: LIST
64430: PUSH
64431: LD_INT 2
64433: NEG
64434: PUSH
64435: LD_INT 2
64437: NEG
64438: PUSH
64439: EMPTY
64440: LIST
64441: LIST
64442: PUSH
64443: LD_INT 3
64445: PUSH
64446: LD_INT 2
64448: PUSH
64449: EMPTY
64450: LIST
64451: LIST
64452: PUSH
64453: LD_INT 3
64455: PUSH
64456: LD_INT 3
64458: PUSH
64459: EMPTY
64460: LIST
64461: LIST
64462: PUSH
64463: LD_INT 2
64465: PUSH
64466: LD_INT 3
64468: PUSH
64469: EMPTY
64470: LIST
64471: LIST
64472: PUSH
64473: EMPTY
64474: LIST
64475: LIST
64476: LIST
64477: LIST
64478: LIST
64479: LIST
64480: LIST
64481: LIST
64482: LIST
64483: LIST
64484: LIST
64485: LIST
64486: LIST
64487: LIST
64488: LIST
64489: LIST
64490: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64491: LD_ADDR_VAR 0 17
64495: PUSH
64496: LD_INT 0
64498: PUSH
64499: LD_INT 0
64501: PUSH
64502: EMPTY
64503: LIST
64504: LIST
64505: PUSH
64506: LD_INT 0
64508: PUSH
64509: LD_INT 1
64511: NEG
64512: PUSH
64513: EMPTY
64514: LIST
64515: LIST
64516: PUSH
64517: LD_INT 1
64519: PUSH
64520: LD_INT 0
64522: PUSH
64523: EMPTY
64524: LIST
64525: LIST
64526: PUSH
64527: LD_INT 1
64529: PUSH
64530: LD_INT 1
64532: PUSH
64533: EMPTY
64534: LIST
64535: LIST
64536: PUSH
64537: LD_INT 0
64539: PUSH
64540: LD_INT 1
64542: PUSH
64543: EMPTY
64544: LIST
64545: LIST
64546: PUSH
64547: LD_INT 1
64549: NEG
64550: PUSH
64551: LD_INT 0
64553: PUSH
64554: EMPTY
64555: LIST
64556: LIST
64557: PUSH
64558: LD_INT 1
64560: NEG
64561: PUSH
64562: LD_INT 1
64564: NEG
64565: PUSH
64566: EMPTY
64567: LIST
64568: LIST
64569: PUSH
64570: LD_INT 1
64572: NEG
64573: PUSH
64574: LD_INT 2
64576: NEG
64577: PUSH
64578: EMPTY
64579: LIST
64580: LIST
64581: PUSH
64582: LD_INT 0
64584: PUSH
64585: LD_INT 2
64587: NEG
64588: PUSH
64589: EMPTY
64590: LIST
64591: LIST
64592: PUSH
64593: LD_INT 1
64595: PUSH
64596: LD_INT 1
64598: NEG
64599: PUSH
64600: EMPTY
64601: LIST
64602: LIST
64603: PUSH
64604: LD_INT 2
64606: PUSH
64607: LD_INT 0
64609: PUSH
64610: EMPTY
64611: LIST
64612: LIST
64613: PUSH
64614: LD_INT 2
64616: PUSH
64617: LD_INT 1
64619: PUSH
64620: EMPTY
64621: LIST
64622: LIST
64623: PUSH
64624: LD_INT 2
64626: PUSH
64627: LD_INT 2
64629: PUSH
64630: EMPTY
64631: LIST
64632: LIST
64633: PUSH
64634: LD_INT 1
64636: PUSH
64637: LD_INT 2
64639: PUSH
64640: EMPTY
64641: LIST
64642: LIST
64643: PUSH
64644: LD_INT 0
64646: PUSH
64647: LD_INT 2
64649: PUSH
64650: EMPTY
64651: LIST
64652: LIST
64653: PUSH
64654: LD_INT 1
64656: NEG
64657: PUSH
64658: LD_INT 1
64660: PUSH
64661: EMPTY
64662: LIST
64663: LIST
64664: PUSH
64665: LD_INT 2
64667: NEG
64668: PUSH
64669: LD_INT 0
64671: PUSH
64672: EMPTY
64673: LIST
64674: LIST
64675: PUSH
64676: LD_INT 2
64678: NEG
64679: PUSH
64680: LD_INT 1
64682: NEG
64683: PUSH
64684: EMPTY
64685: LIST
64686: LIST
64687: PUSH
64688: LD_INT 2
64690: NEG
64691: PUSH
64692: LD_INT 2
64694: NEG
64695: PUSH
64696: EMPTY
64697: LIST
64698: LIST
64699: PUSH
64700: EMPTY
64701: LIST
64702: LIST
64703: LIST
64704: LIST
64705: LIST
64706: LIST
64707: LIST
64708: LIST
64709: LIST
64710: LIST
64711: LIST
64712: LIST
64713: LIST
64714: LIST
64715: LIST
64716: LIST
64717: LIST
64718: LIST
64719: LIST
64720: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64721: LD_ADDR_VAR 0 18
64725: PUSH
64726: LD_INT 0
64728: PUSH
64729: LD_INT 0
64731: PUSH
64732: EMPTY
64733: LIST
64734: LIST
64735: PUSH
64736: LD_INT 0
64738: PUSH
64739: LD_INT 1
64741: NEG
64742: PUSH
64743: EMPTY
64744: LIST
64745: LIST
64746: PUSH
64747: LD_INT 1
64749: PUSH
64750: LD_INT 0
64752: PUSH
64753: EMPTY
64754: LIST
64755: LIST
64756: PUSH
64757: LD_INT 1
64759: PUSH
64760: LD_INT 1
64762: PUSH
64763: EMPTY
64764: LIST
64765: LIST
64766: PUSH
64767: LD_INT 0
64769: PUSH
64770: LD_INT 1
64772: PUSH
64773: EMPTY
64774: LIST
64775: LIST
64776: PUSH
64777: LD_INT 1
64779: NEG
64780: PUSH
64781: LD_INT 0
64783: PUSH
64784: EMPTY
64785: LIST
64786: LIST
64787: PUSH
64788: LD_INT 1
64790: NEG
64791: PUSH
64792: LD_INT 1
64794: NEG
64795: PUSH
64796: EMPTY
64797: LIST
64798: LIST
64799: PUSH
64800: LD_INT 1
64802: NEG
64803: PUSH
64804: LD_INT 2
64806: NEG
64807: PUSH
64808: EMPTY
64809: LIST
64810: LIST
64811: PUSH
64812: LD_INT 0
64814: PUSH
64815: LD_INT 2
64817: NEG
64818: PUSH
64819: EMPTY
64820: LIST
64821: LIST
64822: PUSH
64823: LD_INT 1
64825: PUSH
64826: LD_INT 1
64828: NEG
64829: PUSH
64830: EMPTY
64831: LIST
64832: LIST
64833: PUSH
64834: LD_INT 2
64836: PUSH
64837: LD_INT 0
64839: PUSH
64840: EMPTY
64841: LIST
64842: LIST
64843: PUSH
64844: LD_INT 2
64846: PUSH
64847: LD_INT 1
64849: PUSH
64850: EMPTY
64851: LIST
64852: LIST
64853: PUSH
64854: LD_INT 2
64856: PUSH
64857: LD_INT 2
64859: PUSH
64860: EMPTY
64861: LIST
64862: LIST
64863: PUSH
64864: LD_INT 1
64866: PUSH
64867: LD_INT 2
64869: PUSH
64870: EMPTY
64871: LIST
64872: LIST
64873: PUSH
64874: LD_INT 0
64876: PUSH
64877: LD_INT 2
64879: PUSH
64880: EMPTY
64881: LIST
64882: LIST
64883: PUSH
64884: LD_INT 1
64886: NEG
64887: PUSH
64888: LD_INT 1
64890: PUSH
64891: EMPTY
64892: LIST
64893: LIST
64894: PUSH
64895: LD_INT 2
64897: NEG
64898: PUSH
64899: LD_INT 0
64901: PUSH
64902: EMPTY
64903: LIST
64904: LIST
64905: PUSH
64906: LD_INT 2
64908: NEG
64909: PUSH
64910: LD_INT 1
64912: NEG
64913: PUSH
64914: EMPTY
64915: LIST
64916: LIST
64917: PUSH
64918: LD_INT 2
64920: NEG
64921: PUSH
64922: LD_INT 2
64924: NEG
64925: PUSH
64926: EMPTY
64927: LIST
64928: LIST
64929: PUSH
64930: EMPTY
64931: LIST
64932: LIST
64933: LIST
64934: LIST
64935: LIST
64936: LIST
64937: LIST
64938: LIST
64939: LIST
64940: LIST
64941: LIST
64942: LIST
64943: LIST
64944: LIST
64945: LIST
64946: LIST
64947: LIST
64948: LIST
64949: LIST
64950: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64951: LD_ADDR_VAR 0 19
64955: PUSH
64956: LD_INT 0
64958: PUSH
64959: LD_INT 0
64961: PUSH
64962: EMPTY
64963: LIST
64964: LIST
64965: PUSH
64966: LD_INT 0
64968: PUSH
64969: LD_INT 1
64971: NEG
64972: PUSH
64973: EMPTY
64974: LIST
64975: LIST
64976: PUSH
64977: LD_INT 1
64979: PUSH
64980: LD_INT 0
64982: PUSH
64983: EMPTY
64984: LIST
64985: LIST
64986: PUSH
64987: LD_INT 1
64989: PUSH
64990: LD_INT 1
64992: PUSH
64993: EMPTY
64994: LIST
64995: LIST
64996: PUSH
64997: LD_INT 0
64999: PUSH
65000: LD_INT 1
65002: PUSH
65003: EMPTY
65004: LIST
65005: LIST
65006: PUSH
65007: LD_INT 1
65009: NEG
65010: PUSH
65011: LD_INT 0
65013: PUSH
65014: EMPTY
65015: LIST
65016: LIST
65017: PUSH
65018: LD_INT 1
65020: NEG
65021: PUSH
65022: LD_INT 1
65024: NEG
65025: PUSH
65026: EMPTY
65027: LIST
65028: LIST
65029: PUSH
65030: LD_INT 1
65032: NEG
65033: PUSH
65034: LD_INT 2
65036: NEG
65037: PUSH
65038: EMPTY
65039: LIST
65040: LIST
65041: PUSH
65042: LD_INT 0
65044: PUSH
65045: LD_INT 2
65047: NEG
65048: PUSH
65049: EMPTY
65050: LIST
65051: LIST
65052: PUSH
65053: LD_INT 1
65055: PUSH
65056: LD_INT 1
65058: NEG
65059: PUSH
65060: EMPTY
65061: LIST
65062: LIST
65063: PUSH
65064: LD_INT 2
65066: PUSH
65067: LD_INT 0
65069: PUSH
65070: EMPTY
65071: LIST
65072: LIST
65073: PUSH
65074: LD_INT 2
65076: PUSH
65077: LD_INT 1
65079: PUSH
65080: EMPTY
65081: LIST
65082: LIST
65083: PUSH
65084: LD_INT 2
65086: PUSH
65087: LD_INT 2
65089: PUSH
65090: EMPTY
65091: LIST
65092: LIST
65093: PUSH
65094: LD_INT 1
65096: PUSH
65097: LD_INT 2
65099: PUSH
65100: EMPTY
65101: LIST
65102: LIST
65103: PUSH
65104: LD_INT 0
65106: PUSH
65107: LD_INT 2
65109: PUSH
65110: EMPTY
65111: LIST
65112: LIST
65113: PUSH
65114: LD_INT 1
65116: NEG
65117: PUSH
65118: LD_INT 1
65120: PUSH
65121: EMPTY
65122: LIST
65123: LIST
65124: PUSH
65125: LD_INT 2
65127: NEG
65128: PUSH
65129: LD_INT 0
65131: PUSH
65132: EMPTY
65133: LIST
65134: LIST
65135: PUSH
65136: LD_INT 2
65138: NEG
65139: PUSH
65140: LD_INT 1
65142: NEG
65143: PUSH
65144: EMPTY
65145: LIST
65146: LIST
65147: PUSH
65148: LD_INT 2
65150: NEG
65151: PUSH
65152: LD_INT 2
65154: NEG
65155: PUSH
65156: EMPTY
65157: LIST
65158: LIST
65159: PUSH
65160: EMPTY
65161: LIST
65162: LIST
65163: LIST
65164: LIST
65165: LIST
65166: LIST
65167: LIST
65168: LIST
65169: LIST
65170: LIST
65171: LIST
65172: LIST
65173: LIST
65174: LIST
65175: LIST
65176: LIST
65177: LIST
65178: LIST
65179: LIST
65180: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65181: LD_ADDR_VAR 0 20
65185: PUSH
65186: LD_INT 0
65188: PUSH
65189: LD_INT 0
65191: PUSH
65192: EMPTY
65193: LIST
65194: LIST
65195: PUSH
65196: LD_INT 0
65198: PUSH
65199: LD_INT 1
65201: NEG
65202: PUSH
65203: EMPTY
65204: LIST
65205: LIST
65206: PUSH
65207: LD_INT 1
65209: PUSH
65210: LD_INT 0
65212: PUSH
65213: EMPTY
65214: LIST
65215: LIST
65216: PUSH
65217: LD_INT 1
65219: PUSH
65220: LD_INT 1
65222: PUSH
65223: EMPTY
65224: LIST
65225: LIST
65226: PUSH
65227: LD_INT 0
65229: PUSH
65230: LD_INT 1
65232: PUSH
65233: EMPTY
65234: LIST
65235: LIST
65236: PUSH
65237: LD_INT 1
65239: NEG
65240: PUSH
65241: LD_INT 0
65243: PUSH
65244: EMPTY
65245: LIST
65246: LIST
65247: PUSH
65248: LD_INT 1
65250: NEG
65251: PUSH
65252: LD_INT 1
65254: NEG
65255: PUSH
65256: EMPTY
65257: LIST
65258: LIST
65259: PUSH
65260: LD_INT 1
65262: NEG
65263: PUSH
65264: LD_INT 2
65266: NEG
65267: PUSH
65268: EMPTY
65269: LIST
65270: LIST
65271: PUSH
65272: LD_INT 0
65274: PUSH
65275: LD_INT 2
65277: NEG
65278: PUSH
65279: EMPTY
65280: LIST
65281: LIST
65282: PUSH
65283: LD_INT 1
65285: PUSH
65286: LD_INT 1
65288: NEG
65289: PUSH
65290: EMPTY
65291: LIST
65292: LIST
65293: PUSH
65294: LD_INT 2
65296: PUSH
65297: LD_INT 0
65299: PUSH
65300: EMPTY
65301: LIST
65302: LIST
65303: PUSH
65304: LD_INT 2
65306: PUSH
65307: LD_INT 1
65309: PUSH
65310: EMPTY
65311: LIST
65312: LIST
65313: PUSH
65314: LD_INT 2
65316: PUSH
65317: LD_INT 2
65319: PUSH
65320: EMPTY
65321: LIST
65322: LIST
65323: PUSH
65324: LD_INT 1
65326: PUSH
65327: LD_INT 2
65329: PUSH
65330: EMPTY
65331: LIST
65332: LIST
65333: PUSH
65334: LD_INT 0
65336: PUSH
65337: LD_INT 2
65339: PUSH
65340: EMPTY
65341: LIST
65342: LIST
65343: PUSH
65344: LD_INT 1
65346: NEG
65347: PUSH
65348: LD_INT 1
65350: PUSH
65351: EMPTY
65352: LIST
65353: LIST
65354: PUSH
65355: LD_INT 2
65357: NEG
65358: PUSH
65359: LD_INT 0
65361: PUSH
65362: EMPTY
65363: LIST
65364: LIST
65365: PUSH
65366: LD_INT 2
65368: NEG
65369: PUSH
65370: LD_INT 1
65372: NEG
65373: PUSH
65374: EMPTY
65375: LIST
65376: LIST
65377: PUSH
65378: LD_INT 2
65380: NEG
65381: PUSH
65382: LD_INT 2
65384: NEG
65385: PUSH
65386: EMPTY
65387: LIST
65388: LIST
65389: PUSH
65390: EMPTY
65391: LIST
65392: LIST
65393: LIST
65394: LIST
65395: LIST
65396: LIST
65397: LIST
65398: LIST
65399: LIST
65400: LIST
65401: LIST
65402: LIST
65403: LIST
65404: LIST
65405: LIST
65406: LIST
65407: LIST
65408: LIST
65409: LIST
65410: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65411: LD_ADDR_VAR 0 21
65415: PUSH
65416: LD_INT 0
65418: PUSH
65419: LD_INT 0
65421: PUSH
65422: EMPTY
65423: LIST
65424: LIST
65425: PUSH
65426: LD_INT 0
65428: PUSH
65429: LD_INT 1
65431: NEG
65432: PUSH
65433: EMPTY
65434: LIST
65435: LIST
65436: PUSH
65437: LD_INT 1
65439: PUSH
65440: LD_INT 0
65442: PUSH
65443: EMPTY
65444: LIST
65445: LIST
65446: PUSH
65447: LD_INT 1
65449: PUSH
65450: LD_INT 1
65452: PUSH
65453: EMPTY
65454: LIST
65455: LIST
65456: PUSH
65457: LD_INT 0
65459: PUSH
65460: LD_INT 1
65462: PUSH
65463: EMPTY
65464: LIST
65465: LIST
65466: PUSH
65467: LD_INT 1
65469: NEG
65470: PUSH
65471: LD_INT 0
65473: PUSH
65474: EMPTY
65475: LIST
65476: LIST
65477: PUSH
65478: LD_INT 1
65480: NEG
65481: PUSH
65482: LD_INT 1
65484: NEG
65485: PUSH
65486: EMPTY
65487: LIST
65488: LIST
65489: PUSH
65490: LD_INT 1
65492: NEG
65493: PUSH
65494: LD_INT 2
65496: NEG
65497: PUSH
65498: EMPTY
65499: LIST
65500: LIST
65501: PUSH
65502: LD_INT 0
65504: PUSH
65505: LD_INT 2
65507: NEG
65508: PUSH
65509: EMPTY
65510: LIST
65511: LIST
65512: PUSH
65513: LD_INT 1
65515: PUSH
65516: LD_INT 1
65518: NEG
65519: PUSH
65520: EMPTY
65521: LIST
65522: LIST
65523: PUSH
65524: LD_INT 2
65526: PUSH
65527: LD_INT 0
65529: PUSH
65530: EMPTY
65531: LIST
65532: LIST
65533: PUSH
65534: LD_INT 2
65536: PUSH
65537: LD_INT 1
65539: PUSH
65540: EMPTY
65541: LIST
65542: LIST
65543: PUSH
65544: LD_INT 2
65546: PUSH
65547: LD_INT 2
65549: PUSH
65550: EMPTY
65551: LIST
65552: LIST
65553: PUSH
65554: LD_INT 1
65556: PUSH
65557: LD_INT 2
65559: PUSH
65560: EMPTY
65561: LIST
65562: LIST
65563: PUSH
65564: LD_INT 0
65566: PUSH
65567: LD_INT 2
65569: PUSH
65570: EMPTY
65571: LIST
65572: LIST
65573: PUSH
65574: LD_INT 1
65576: NEG
65577: PUSH
65578: LD_INT 1
65580: PUSH
65581: EMPTY
65582: LIST
65583: LIST
65584: PUSH
65585: LD_INT 2
65587: NEG
65588: PUSH
65589: LD_INT 0
65591: PUSH
65592: EMPTY
65593: LIST
65594: LIST
65595: PUSH
65596: LD_INT 2
65598: NEG
65599: PUSH
65600: LD_INT 1
65602: NEG
65603: PUSH
65604: EMPTY
65605: LIST
65606: LIST
65607: PUSH
65608: LD_INT 2
65610: NEG
65611: PUSH
65612: LD_INT 2
65614: NEG
65615: PUSH
65616: EMPTY
65617: LIST
65618: LIST
65619: PUSH
65620: EMPTY
65621: LIST
65622: LIST
65623: LIST
65624: LIST
65625: LIST
65626: LIST
65627: LIST
65628: LIST
65629: LIST
65630: LIST
65631: LIST
65632: LIST
65633: LIST
65634: LIST
65635: LIST
65636: LIST
65637: LIST
65638: LIST
65639: LIST
65640: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65641: LD_ADDR_VAR 0 22
65645: PUSH
65646: LD_INT 0
65648: PUSH
65649: LD_INT 0
65651: PUSH
65652: EMPTY
65653: LIST
65654: LIST
65655: PUSH
65656: LD_INT 0
65658: PUSH
65659: LD_INT 1
65661: NEG
65662: PUSH
65663: EMPTY
65664: LIST
65665: LIST
65666: PUSH
65667: LD_INT 1
65669: PUSH
65670: LD_INT 0
65672: PUSH
65673: EMPTY
65674: LIST
65675: LIST
65676: PUSH
65677: LD_INT 1
65679: PUSH
65680: LD_INT 1
65682: PUSH
65683: EMPTY
65684: LIST
65685: LIST
65686: PUSH
65687: LD_INT 0
65689: PUSH
65690: LD_INT 1
65692: PUSH
65693: EMPTY
65694: LIST
65695: LIST
65696: PUSH
65697: LD_INT 1
65699: NEG
65700: PUSH
65701: LD_INT 0
65703: PUSH
65704: EMPTY
65705: LIST
65706: LIST
65707: PUSH
65708: LD_INT 1
65710: NEG
65711: PUSH
65712: LD_INT 1
65714: NEG
65715: PUSH
65716: EMPTY
65717: LIST
65718: LIST
65719: PUSH
65720: LD_INT 1
65722: NEG
65723: PUSH
65724: LD_INT 2
65726: NEG
65727: PUSH
65728: EMPTY
65729: LIST
65730: LIST
65731: PUSH
65732: LD_INT 0
65734: PUSH
65735: LD_INT 2
65737: NEG
65738: PUSH
65739: EMPTY
65740: LIST
65741: LIST
65742: PUSH
65743: LD_INT 1
65745: PUSH
65746: LD_INT 1
65748: NEG
65749: PUSH
65750: EMPTY
65751: LIST
65752: LIST
65753: PUSH
65754: LD_INT 2
65756: PUSH
65757: LD_INT 0
65759: PUSH
65760: EMPTY
65761: LIST
65762: LIST
65763: PUSH
65764: LD_INT 2
65766: PUSH
65767: LD_INT 1
65769: PUSH
65770: EMPTY
65771: LIST
65772: LIST
65773: PUSH
65774: LD_INT 2
65776: PUSH
65777: LD_INT 2
65779: PUSH
65780: EMPTY
65781: LIST
65782: LIST
65783: PUSH
65784: LD_INT 1
65786: PUSH
65787: LD_INT 2
65789: PUSH
65790: EMPTY
65791: LIST
65792: LIST
65793: PUSH
65794: LD_INT 0
65796: PUSH
65797: LD_INT 2
65799: PUSH
65800: EMPTY
65801: LIST
65802: LIST
65803: PUSH
65804: LD_INT 1
65806: NEG
65807: PUSH
65808: LD_INT 1
65810: PUSH
65811: EMPTY
65812: LIST
65813: LIST
65814: PUSH
65815: LD_INT 2
65817: NEG
65818: PUSH
65819: LD_INT 0
65821: PUSH
65822: EMPTY
65823: LIST
65824: LIST
65825: PUSH
65826: LD_INT 2
65828: NEG
65829: PUSH
65830: LD_INT 1
65832: NEG
65833: PUSH
65834: EMPTY
65835: LIST
65836: LIST
65837: PUSH
65838: LD_INT 2
65840: NEG
65841: PUSH
65842: LD_INT 2
65844: NEG
65845: PUSH
65846: EMPTY
65847: LIST
65848: LIST
65849: PUSH
65850: EMPTY
65851: LIST
65852: LIST
65853: LIST
65854: LIST
65855: LIST
65856: LIST
65857: LIST
65858: LIST
65859: LIST
65860: LIST
65861: LIST
65862: LIST
65863: LIST
65864: LIST
65865: LIST
65866: LIST
65867: LIST
65868: LIST
65869: LIST
65870: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
65871: LD_ADDR_VAR 0 23
65875: PUSH
65876: LD_INT 0
65878: PUSH
65879: LD_INT 0
65881: PUSH
65882: EMPTY
65883: LIST
65884: LIST
65885: PUSH
65886: LD_INT 0
65888: PUSH
65889: LD_INT 1
65891: NEG
65892: PUSH
65893: EMPTY
65894: LIST
65895: LIST
65896: PUSH
65897: LD_INT 1
65899: PUSH
65900: LD_INT 0
65902: PUSH
65903: EMPTY
65904: LIST
65905: LIST
65906: PUSH
65907: LD_INT 1
65909: PUSH
65910: LD_INT 1
65912: PUSH
65913: EMPTY
65914: LIST
65915: LIST
65916: PUSH
65917: LD_INT 0
65919: PUSH
65920: LD_INT 1
65922: PUSH
65923: EMPTY
65924: LIST
65925: LIST
65926: PUSH
65927: LD_INT 1
65929: NEG
65930: PUSH
65931: LD_INT 0
65933: PUSH
65934: EMPTY
65935: LIST
65936: LIST
65937: PUSH
65938: LD_INT 1
65940: NEG
65941: PUSH
65942: LD_INT 1
65944: NEG
65945: PUSH
65946: EMPTY
65947: LIST
65948: LIST
65949: PUSH
65950: LD_INT 1
65952: NEG
65953: PUSH
65954: LD_INT 2
65956: NEG
65957: PUSH
65958: EMPTY
65959: LIST
65960: LIST
65961: PUSH
65962: LD_INT 0
65964: PUSH
65965: LD_INT 2
65967: NEG
65968: PUSH
65969: EMPTY
65970: LIST
65971: LIST
65972: PUSH
65973: LD_INT 1
65975: PUSH
65976: LD_INT 1
65978: NEG
65979: PUSH
65980: EMPTY
65981: LIST
65982: LIST
65983: PUSH
65984: LD_INT 2
65986: PUSH
65987: LD_INT 0
65989: PUSH
65990: EMPTY
65991: LIST
65992: LIST
65993: PUSH
65994: LD_INT 2
65996: PUSH
65997: LD_INT 1
65999: PUSH
66000: EMPTY
66001: LIST
66002: LIST
66003: PUSH
66004: LD_INT 2
66006: PUSH
66007: LD_INT 2
66009: PUSH
66010: EMPTY
66011: LIST
66012: LIST
66013: PUSH
66014: LD_INT 1
66016: PUSH
66017: LD_INT 2
66019: PUSH
66020: EMPTY
66021: LIST
66022: LIST
66023: PUSH
66024: LD_INT 0
66026: PUSH
66027: LD_INT 2
66029: PUSH
66030: EMPTY
66031: LIST
66032: LIST
66033: PUSH
66034: LD_INT 1
66036: NEG
66037: PUSH
66038: LD_INT 1
66040: PUSH
66041: EMPTY
66042: LIST
66043: LIST
66044: PUSH
66045: LD_INT 2
66047: NEG
66048: PUSH
66049: LD_INT 0
66051: PUSH
66052: EMPTY
66053: LIST
66054: LIST
66055: PUSH
66056: LD_INT 2
66058: NEG
66059: PUSH
66060: LD_INT 1
66062: NEG
66063: PUSH
66064: EMPTY
66065: LIST
66066: LIST
66067: PUSH
66068: LD_INT 2
66070: NEG
66071: PUSH
66072: LD_INT 2
66074: NEG
66075: PUSH
66076: EMPTY
66077: LIST
66078: LIST
66079: PUSH
66080: LD_INT 2
66082: NEG
66083: PUSH
66084: LD_INT 3
66086: NEG
66087: PUSH
66088: EMPTY
66089: LIST
66090: LIST
66091: PUSH
66092: LD_INT 1
66094: NEG
66095: PUSH
66096: LD_INT 3
66098: NEG
66099: PUSH
66100: EMPTY
66101: LIST
66102: LIST
66103: PUSH
66104: LD_INT 1
66106: PUSH
66107: LD_INT 2
66109: NEG
66110: PUSH
66111: EMPTY
66112: LIST
66113: LIST
66114: PUSH
66115: LD_INT 2
66117: PUSH
66118: LD_INT 1
66120: NEG
66121: PUSH
66122: EMPTY
66123: LIST
66124: LIST
66125: PUSH
66126: EMPTY
66127: LIST
66128: LIST
66129: LIST
66130: LIST
66131: LIST
66132: LIST
66133: LIST
66134: LIST
66135: LIST
66136: LIST
66137: LIST
66138: LIST
66139: LIST
66140: LIST
66141: LIST
66142: LIST
66143: LIST
66144: LIST
66145: LIST
66146: LIST
66147: LIST
66148: LIST
66149: LIST
66150: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
66151: LD_ADDR_VAR 0 24
66155: PUSH
66156: LD_INT 0
66158: PUSH
66159: LD_INT 0
66161: PUSH
66162: EMPTY
66163: LIST
66164: LIST
66165: PUSH
66166: LD_INT 0
66168: PUSH
66169: LD_INT 1
66171: NEG
66172: PUSH
66173: EMPTY
66174: LIST
66175: LIST
66176: PUSH
66177: LD_INT 1
66179: PUSH
66180: LD_INT 0
66182: PUSH
66183: EMPTY
66184: LIST
66185: LIST
66186: PUSH
66187: LD_INT 1
66189: PUSH
66190: LD_INT 1
66192: PUSH
66193: EMPTY
66194: LIST
66195: LIST
66196: PUSH
66197: LD_INT 0
66199: PUSH
66200: LD_INT 1
66202: PUSH
66203: EMPTY
66204: LIST
66205: LIST
66206: PUSH
66207: LD_INT 1
66209: NEG
66210: PUSH
66211: LD_INT 0
66213: PUSH
66214: EMPTY
66215: LIST
66216: LIST
66217: PUSH
66218: LD_INT 1
66220: NEG
66221: PUSH
66222: LD_INT 1
66224: NEG
66225: PUSH
66226: EMPTY
66227: LIST
66228: LIST
66229: PUSH
66230: LD_INT 1
66232: NEG
66233: PUSH
66234: LD_INT 2
66236: NEG
66237: PUSH
66238: EMPTY
66239: LIST
66240: LIST
66241: PUSH
66242: LD_INT 0
66244: PUSH
66245: LD_INT 2
66247: NEG
66248: PUSH
66249: EMPTY
66250: LIST
66251: LIST
66252: PUSH
66253: LD_INT 1
66255: PUSH
66256: LD_INT 1
66258: NEG
66259: PUSH
66260: EMPTY
66261: LIST
66262: LIST
66263: PUSH
66264: LD_INT 2
66266: PUSH
66267: LD_INT 0
66269: PUSH
66270: EMPTY
66271: LIST
66272: LIST
66273: PUSH
66274: LD_INT 2
66276: PUSH
66277: LD_INT 1
66279: PUSH
66280: EMPTY
66281: LIST
66282: LIST
66283: PUSH
66284: LD_INT 2
66286: PUSH
66287: LD_INT 2
66289: PUSH
66290: EMPTY
66291: LIST
66292: LIST
66293: PUSH
66294: LD_INT 1
66296: PUSH
66297: LD_INT 2
66299: PUSH
66300: EMPTY
66301: LIST
66302: LIST
66303: PUSH
66304: LD_INT 0
66306: PUSH
66307: LD_INT 2
66309: PUSH
66310: EMPTY
66311: LIST
66312: LIST
66313: PUSH
66314: LD_INT 1
66316: NEG
66317: PUSH
66318: LD_INT 1
66320: PUSH
66321: EMPTY
66322: LIST
66323: LIST
66324: PUSH
66325: LD_INT 2
66327: NEG
66328: PUSH
66329: LD_INT 0
66331: PUSH
66332: EMPTY
66333: LIST
66334: LIST
66335: PUSH
66336: LD_INT 2
66338: NEG
66339: PUSH
66340: LD_INT 1
66342: NEG
66343: PUSH
66344: EMPTY
66345: LIST
66346: LIST
66347: PUSH
66348: LD_INT 2
66350: NEG
66351: PUSH
66352: LD_INT 2
66354: NEG
66355: PUSH
66356: EMPTY
66357: LIST
66358: LIST
66359: PUSH
66360: LD_INT 1
66362: PUSH
66363: LD_INT 2
66365: NEG
66366: PUSH
66367: EMPTY
66368: LIST
66369: LIST
66370: PUSH
66371: LD_INT 2
66373: PUSH
66374: LD_INT 1
66376: NEG
66377: PUSH
66378: EMPTY
66379: LIST
66380: LIST
66381: PUSH
66382: LD_INT 3
66384: PUSH
66385: LD_INT 1
66387: PUSH
66388: EMPTY
66389: LIST
66390: LIST
66391: PUSH
66392: LD_INT 3
66394: PUSH
66395: LD_INT 2
66397: PUSH
66398: EMPTY
66399: LIST
66400: LIST
66401: PUSH
66402: EMPTY
66403: LIST
66404: LIST
66405: LIST
66406: LIST
66407: LIST
66408: LIST
66409: LIST
66410: LIST
66411: LIST
66412: LIST
66413: LIST
66414: LIST
66415: LIST
66416: LIST
66417: LIST
66418: LIST
66419: LIST
66420: LIST
66421: LIST
66422: LIST
66423: LIST
66424: LIST
66425: LIST
66426: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
66427: LD_ADDR_VAR 0 25
66431: PUSH
66432: LD_INT 0
66434: PUSH
66435: LD_INT 0
66437: PUSH
66438: EMPTY
66439: LIST
66440: LIST
66441: PUSH
66442: LD_INT 0
66444: PUSH
66445: LD_INT 1
66447: NEG
66448: PUSH
66449: EMPTY
66450: LIST
66451: LIST
66452: PUSH
66453: LD_INT 1
66455: PUSH
66456: LD_INT 0
66458: PUSH
66459: EMPTY
66460: LIST
66461: LIST
66462: PUSH
66463: LD_INT 1
66465: PUSH
66466: LD_INT 1
66468: PUSH
66469: EMPTY
66470: LIST
66471: LIST
66472: PUSH
66473: LD_INT 0
66475: PUSH
66476: LD_INT 1
66478: PUSH
66479: EMPTY
66480: LIST
66481: LIST
66482: PUSH
66483: LD_INT 1
66485: NEG
66486: PUSH
66487: LD_INT 0
66489: PUSH
66490: EMPTY
66491: LIST
66492: LIST
66493: PUSH
66494: LD_INT 1
66496: NEG
66497: PUSH
66498: LD_INT 1
66500: NEG
66501: PUSH
66502: EMPTY
66503: LIST
66504: LIST
66505: PUSH
66506: LD_INT 1
66508: NEG
66509: PUSH
66510: LD_INT 2
66512: NEG
66513: PUSH
66514: EMPTY
66515: LIST
66516: LIST
66517: PUSH
66518: LD_INT 0
66520: PUSH
66521: LD_INT 2
66523: NEG
66524: PUSH
66525: EMPTY
66526: LIST
66527: LIST
66528: PUSH
66529: LD_INT 1
66531: PUSH
66532: LD_INT 1
66534: NEG
66535: PUSH
66536: EMPTY
66537: LIST
66538: LIST
66539: PUSH
66540: LD_INT 2
66542: PUSH
66543: LD_INT 0
66545: PUSH
66546: EMPTY
66547: LIST
66548: LIST
66549: PUSH
66550: LD_INT 2
66552: PUSH
66553: LD_INT 1
66555: PUSH
66556: EMPTY
66557: LIST
66558: LIST
66559: PUSH
66560: LD_INT 2
66562: PUSH
66563: LD_INT 2
66565: PUSH
66566: EMPTY
66567: LIST
66568: LIST
66569: PUSH
66570: LD_INT 1
66572: PUSH
66573: LD_INT 2
66575: PUSH
66576: EMPTY
66577: LIST
66578: LIST
66579: PUSH
66580: LD_INT 0
66582: PUSH
66583: LD_INT 2
66585: PUSH
66586: EMPTY
66587: LIST
66588: LIST
66589: PUSH
66590: LD_INT 1
66592: NEG
66593: PUSH
66594: LD_INT 1
66596: PUSH
66597: EMPTY
66598: LIST
66599: LIST
66600: PUSH
66601: LD_INT 2
66603: NEG
66604: PUSH
66605: LD_INT 0
66607: PUSH
66608: EMPTY
66609: LIST
66610: LIST
66611: PUSH
66612: LD_INT 2
66614: NEG
66615: PUSH
66616: LD_INT 1
66618: NEG
66619: PUSH
66620: EMPTY
66621: LIST
66622: LIST
66623: PUSH
66624: LD_INT 2
66626: NEG
66627: PUSH
66628: LD_INT 2
66630: NEG
66631: PUSH
66632: EMPTY
66633: LIST
66634: LIST
66635: PUSH
66636: LD_INT 3
66638: PUSH
66639: LD_INT 1
66641: PUSH
66642: EMPTY
66643: LIST
66644: LIST
66645: PUSH
66646: LD_INT 3
66648: PUSH
66649: LD_INT 2
66651: PUSH
66652: EMPTY
66653: LIST
66654: LIST
66655: PUSH
66656: LD_INT 2
66658: PUSH
66659: LD_INT 3
66661: PUSH
66662: EMPTY
66663: LIST
66664: LIST
66665: PUSH
66666: LD_INT 1
66668: PUSH
66669: LD_INT 3
66671: PUSH
66672: EMPTY
66673: LIST
66674: LIST
66675: PUSH
66676: EMPTY
66677: LIST
66678: LIST
66679: LIST
66680: LIST
66681: LIST
66682: LIST
66683: LIST
66684: LIST
66685: LIST
66686: LIST
66687: LIST
66688: LIST
66689: LIST
66690: LIST
66691: LIST
66692: LIST
66693: LIST
66694: LIST
66695: LIST
66696: LIST
66697: LIST
66698: LIST
66699: LIST
66700: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
66701: LD_ADDR_VAR 0 26
66705: PUSH
66706: LD_INT 0
66708: PUSH
66709: LD_INT 0
66711: PUSH
66712: EMPTY
66713: LIST
66714: LIST
66715: PUSH
66716: LD_INT 0
66718: PUSH
66719: LD_INT 1
66721: NEG
66722: PUSH
66723: EMPTY
66724: LIST
66725: LIST
66726: PUSH
66727: LD_INT 1
66729: PUSH
66730: LD_INT 0
66732: PUSH
66733: EMPTY
66734: LIST
66735: LIST
66736: PUSH
66737: LD_INT 1
66739: PUSH
66740: LD_INT 1
66742: PUSH
66743: EMPTY
66744: LIST
66745: LIST
66746: PUSH
66747: LD_INT 0
66749: PUSH
66750: LD_INT 1
66752: PUSH
66753: EMPTY
66754: LIST
66755: LIST
66756: PUSH
66757: LD_INT 1
66759: NEG
66760: PUSH
66761: LD_INT 0
66763: PUSH
66764: EMPTY
66765: LIST
66766: LIST
66767: PUSH
66768: LD_INT 1
66770: NEG
66771: PUSH
66772: LD_INT 1
66774: NEG
66775: PUSH
66776: EMPTY
66777: LIST
66778: LIST
66779: PUSH
66780: LD_INT 1
66782: NEG
66783: PUSH
66784: LD_INT 2
66786: NEG
66787: PUSH
66788: EMPTY
66789: LIST
66790: LIST
66791: PUSH
66792: LD_INT 0
66794: PUSH
66795: LD_INT 2
66797: NEG
66798: PUSH
66799: EMPTY
66800: LIST
66801: LIST
66802: PUSH
66803: LD_INT 1
66805: PUSH
66806: LD_INT 1
66808: NEG
66809: PUSH
66810: EMPTY
66811: LIST
66812: LIST
66813: PUSH
66814: LD_INT 2
66816: PUSH
66817: LD_INT 0
66819: PUSH
66820: EMPTY
66821: LIST
66822: LIST
66823: PUSH
66824: LD_INT 2
66826: PUSH
66827: LD_INT 1
66829: PUSH
66830: EMPTY
66831: LIST
66832: LIST
66833: PUSH
66834: LD_INT 2
66836: PUSH
66837: LD_INT 2
66839: PUSH
66840: EMPTY
66841: LIST
66842: LIST
66843: PUSH
66844: LD_INT 1
66846: PUSH
66847: LD_INT 2
66849: PUSH
66850: EMPTY
66851: LIST
66852: LIST
66853: PUSH
66854: LD_INT 0
66856: PUSH
66857: LD_INT 2
66859: PUSH
66860: EMPTY
66861: LIST
66862: LIST
66863: PUSH
66864: LD_INT 1
66866: NEG
66867: PUSH
66868: LD_INT 1
66870: PUSH
66871: EMPTY
66872: LIST
66873: LIST
66874: PUSH
66875: LD_INT 2
66877: NEG
66878: PUSH
66879: LD_INT 0
66881: PUSH
66882: EMPTY
66883: LIST
66884: LIST
66885: PUSH
66886: LD_INT 2
66888: NEG
66889: PUSH
66890: LD_INT 1
66892: NEG
66893: PUSH
66894: EMPTY
66895: LIST
66896: LIST
66897: PUSH
66898: LD_INT 2
66900: NEG
66901: PUSH
66902: LD_INT 2
66904: NEG
66905: PUSH
66906: EMPTY
66907: LIST
66908: LIST
66909: PUSH
66910: LD_INT 2
66912: PUSH
66913: LD_INT 3
66915: PUSH
66916: EMPTY
66917: LIST
66918: LIST
66919: PUSH
66920: LD_INT 1
66922: PUSH
66923: LD_INT 3
66925: PUSH
66926: EMPTY
66927: LIST
66928: LIST
66929: PUSH
66930: LD_INT 1
66932: NEG
66933: PUSH
66934: LD_INT 2
66936: PUSH
66937: EMPTY
66938: LIST
66939: LIST
66940: PUSH
66941: LD_INT 2
66943: NEG
66944: PUSH
66945: LD_INT 1
66947: PUSH
66948: EMPTY
66949: LIST
66950: LIST
66951: PUSH
66952: EMPTY
66953: LIST
66954: LIST
66955: LIST
66956: LIST
66957: LIST
66958: LIST
66959: LIST
66960: LIST
66961: LIST
66962: LIST
66963: LIST
66964: LIST
66965: LIST
66966: LIST
66967: LIST
66968: LIST
66969: LIST
66970: LIST
66971: LIST
66972: LIST
66973: LIST
66974: LIST
66975: LIST
66976: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
66977: LD_ADDR_VAR 0 27
66981: PUSH
66982: LD_INT 0
66984: PUSH
66985: LD_INT 0
66987: PUSH
66988: EMPTY
66989: LIST
66990: LIST
66991: PUSH
66992: LD_INT 0
66994: PUSH
66995: LD_INT 1
66997: NEG
66998: PUSH
66999: EMPTY
67000: LIST
67001: LIST
67002: PUSH
67003: LD_INT 1
67005: PUSH
67006: LD_INT 0
67008: PUSH
67009: EMPTY
67010: LIST
67011: LIST
67012: PUSH
67013: LD_INT 1
67015: PUSH
67016: LD_INT 1
67018: PUSH
67019: EMPTY
67020: LIST
67021: LIST
67022: PUSH
67023: LD_INT 0
67025: PUSH
67026: LD_INT 1
67028: PUSH
67029: EMPTY
67030: LIST
67031: LIST
67032: PUSH
67033: LD_INT 1
67035: NEG
67036: PUSH
67037: LD_INT 0
67039: PUSH
67040: EMPTY
67041: LIST
67042: LIST
67043: PUSH
67044: LD_INT 1
67046: NEG
67047: PUSH
67048: LD_INT 1
67050: NEG
67051: PUSH
67052: EMPTY
67053: LIST
67054: LIST
67055: PUSH
67056: LD_INT 1
67058: NEG
67059: PUSH
67060: LD_INT 2
67062: NEG
67063: PUSH
67064: EMPTY
67065: LIST
67066: LIST
67067: PUSH
67068: LD_INT 0
67070: PUSH
67071: LD_INT 2
67073: NEG
67074: PUSH
67075: EMPTY
67076: LIST
67077: LIST
67078: PUSH
67079: LD_INT 1
67081: PUSH
67082: LD_INT 1
67084: NEG
67085: PUSH
67086: EMPTY
67087: LIST
67088: LIST
67089: PUSH
67090: LD_INT 2
67092: PUSH
67093: LD_INT 0
67095: PUSH
67096: EMPTY
67097: LIST
67098: LIST
67099: PUSH
67100: LD_INT 2
67102: PUSH
67103: LD_INT 1
67105: PUSH
67106: EMPTY
67107: LIST
67108: LIST
67109: PUSH
67110: LD_INT 2
67112: PUSH
67113: LD_INT 2
67115: PUSH
67116: EMPTY
67117: LIST
67118: LIST
67119: PUSH
67120: LD_INT 1
67122: PUSH
67123: LD_INT 2
67125: PUSH
67126: EMPTY
67127: LIST
67128: LIST
67129: PUSH
67130: LD_INT 0
67132: PUSH
67133: LD_INT 2
67135: PUSH
67136: EMPTY
67137: LIST
67138: LIST
67139: PUSH
67140: LD_INT 1
67142: NEG
67143: PUSH
67144: LD_INT 1
67146: PUSH
67147: EMPTY
67148: LIST
67149: LIST
67150: PUSH
67151: LD_INT 2
67153: NEG
67154: PUSH
67155: LD_INT 0
67157: PUSH
67158: EMPTY
67159: LIST
67160: LIST
67161: PUSH
67162: LD_INT 2
67164: NEG
67165: PUSH
67166: LD_INT 1
67168: NEG
67169: PUSH
67170: EMPTY
67171: LIST
67172: LIST
67173: PUSH
67174: LD_INT 2
67176: NEG
67177: PUSH
67178: LD_INT 2
67180: NEG
67181: PUSH
67182: EMPTY
67183: LIST
67184: LIST
67185: PUSH
67186: LD_INT 1
67188: NEG
67189: PUSH
67190: LD_INT 2
67192: PUSH
67193: EMPTY
67194: LIST
67195: LIST
67196: PUSH
67197: LD_INT 2
67199: NEG
67200: PUSH
67201: LD_INT 1
67203: PUSH
67204: EMPTY
67205: LIST
67206: LIST
67207: PUSH
67208: LD_INT 3
67210: NEG
67211: PUSH
67212: LD_INT 1
67214: NEG
67215: PUSH
67216: EMPTY
67217: LIST
67218: LIST
67219: PUSH
67220: LD_INT 3
67222: NEG
67223: PUSH
67224: LD_INT 2
67226: NEG
67227: PUSH
67228: EMPTY
67229: LIST
67230: LIST
67231: PUSH
67232: EMPTY
67233: LIST
67234: LIST
67235: LIST
67236: LIST
67237: LIST
67238: LIST
67239: LIST
67240: LIST
67241: LIST
67242: LIST
67243: LIST
67244: LIST
67245: LIST
67246: LIST
67247: LIST
67248: LIST
67249: LIST
67250: LIST
67251: LIST
67252: LIST
67253: LIST
67254: LIST
67255: LIST
67256: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
67257: LD_ADDR_VAR 0 28
67261: PUSH
67262: LD_INT 0
67264: PUSH
67265: LD_INT 0
67267: PUSH
67268: EMPTY
67269: LIST
67270: LIST
67271: PUSH
67272: LD_INT 0
67274: PUSH
67275: LD_INT 1
67277: NEG
67278: PUSH
67279: EMPTY
67280: LIST
67281: LIST
67282: PUSH
67283: LD_INT 1
67285: PUSH
67286: LD_INT 0
67288: PUSH
67289: EMPTY
67290: LIST
67291: LIST
67292: PUSH
67293: LD_INT 1
67295: PUSH
67296: LD_INT 1
67298: PUSH
67299: EMPTY
67300: LIST
67301: LIST
67302: PUSH
67303: LD_INT 0
67305: PUSH
67306: LD_INT 1
67308: PUSH
67309: EMPTY
67310: LIST
67311: LIST
67312: PUSH
67313: LD_INT 1
67315: NEG
67316: PUSH
67317: LD_INT 0
67319: PUSH
67320: EMPTY
67321: LIST
67322: LIST
67323: PUSH
67324: LD_INT 1
67326: NEG
67327: PUSH
67328: LD_INT 1
67330: NEG
67331: PUSH
67332: EMPTY
67333: LIST
67334: LIST
67335: PUSH
67336: LD_INT 1
67338: NEG
67339: PUSH
67340: LD_INT 2
67342: NEG
67343: PUSH
67344: EMPTY
67345: LIST
67346: LIST
67347: PUSH
67348: LD_INT 0
67350: PUSH
67351: LD_INT 2
67353: NEG
67354: PUSH
67355: EMPTY
67356: LIST
67357: LIST
67358: PUSH
67359: LD_INT 1
67361: PUSH
67362: LD_INT 1
67364: NEG
67365: PUSH
67366: EMPTY
67367: LIST
67368: LIST
67369: PUSH
67370: LD_INT 2
67372: PUSH
67373: LD_INT 0
67375: PUSH
67376: EMPTY
67377: LIST
67378: LIST
67379: PUSH
67380: LD_INT 2
67382: PUSH
67383: LD_INT 1
67385: PUSH
67386: EMPTY
67387: LIST
67388: LIST
67389: PUSH
67390: LD_INT 2
67392: PUSH
67393: LD_INT 2
67395: PUSH
67396: EMPTY
67397: LIST
67398: LIST
67399: PUSH
67400: LD_INT 1
67402: PUSH
67403: LD_INT 2
67405: PUSH
67406: EMPTY
67407: LIST
67408: LIST
67409: PUSH
67410: LD_INT 0
67412: PUSH
67413: LD_INT 2
67415: PUSH
67416: EMPTY
67417: LIST
67418: LIST
67419: PUSH
67420: LD_INT 1
67422: NEG
67423: PUSH
67424: LD_INT 1
67426: PUSH
67427: EMPTY
67428: LIST
67429: LIST
67430: PUSH
67431: LD_INT 2
67433: NEG
67434: PUSH
67435: LD_INT 0
67437: PUSH
67438: EMPTY
67439: LIST
67440: LIST
67441: PUSH
67442: LD_INT 2
67444: NEG
67445: PUSH
67446: LD_INT 1
67448: NEG
67449: PUSH
67450: EMPTY
67451: LIST
67452: LIST
67453: PUSH
67454: LD_INT 2
67456: NEG
67457: PUSH
67458: LD_INT 2
67460: NEG
67461: PUSH
67462: EMPTY
67463: LIST
67464: LIST
67465: PUSH
67466: LD_INT 2
67468: NEG
67469: PUSH
67470: LD_INT 3
67472: NEG
67473: PUSH
67474: EMPTY
67475: LIST
67476: LIST
67477: PUSH
67478: LD_INT 1
67480: NEG
67481: PUSH
67482: LD_INT 3
67484: NEG
67485: PUSH
67486: EMPTY
67487: LIST
67488: LIST
67489: PUSH
67490: LD_INT 3
67492: NEG
67493: PUSH
67494: LD_INT 1
67496: NEG
67497: PUSH
67498: EMPTY
67499: LIST
67500: LIST
67501: PUSH
67502: LD_INT 3
67504: NEG
67505: PUSH
67506: LD_INT 2
67508: NEG
67509: PUSH
67510: EMPTY
67511: LIST
67512: LIST
67513: PUSH
67514: EMPTY
67515: LIST
67516: LIST
67517: LIST
67518: LIST
67519: LIST
67520: LIST
67521: LIST
67522: LIST
67523: LIST
67524: LIST
67525: LIST
67526: LIST
67527: LIST
67528: LIST
67529: LIST
67530: LIST
67531: LIST
67532: LIST
67533: LIST
67534: LIST
67535: LIST
67536: LIST
67537: LIST
67538: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
67539: LD_ADDR_VAR 0 29
67543: PUSH
67544: LD_INT 0
67546: PUSH
67547: LD_INT 0
67549: PUSH
67550: EMPTY
67551: LIST
67552: LIST
67553: PUSH
67554: LD_INT 0
67556: PUSH
67557: LD_INT 1
67559: NEG
67560: PUSH
67561: EMPTY
67562: LIST
67563: LIST
67564: PUSH
67565: LD_INT 1
67567: PUSH
67568: LD_INT 0
67570: PUSH
67571: EMPTY
67572: LIST
67573: LIST
67574: PUSH
67575: LD_INT 1
67577: PUSH
67578: LD_INT 1
67580: PUSH
67581: EMPTY
67582: LIST
67583: LIST
67584: PUSH
67585: LD_INT 0
67587: PUSH
67588: LD_INT 1
67590: PUSH
67591: EMPTY
67592: LIST
67593: LIST
67594: PUSH
67595: LD_INT 1
67597: NEG
67598: PUSH
67599: LD_INT 0
67601: PUSH
67602: EMPTY
67603: LIST
67604: LIST
67605: PUSH
67606: LD_INT 1
67608: NEG
67609: PUSH
67610: LD_INT 1
67612: NEG
67613: PUSH
67614: EMPTY
67615: LIST
67616: LIST
67617: PUSH
67618: LD_INT 1
67620: NEG
67621: PUSH
67622: LD_INT 2
67624: NEG
67625: PUSH
67626: EMPTY
67627: LIST
67628: LIST
67629: PUSH
67630: LD_INT 0
67632: PUSH
67633: LD_INT 2
67635: NEG
67636: PUSH
67637: EMPTY
67638: LIST
67639: LIST
67640: PUSH
67641: LD_INT 1
67643: PUSH
67644: LD_INT 1
67646: NEG
67647: PUSH
67648: EMPTY
67649: LIST
67650: LIST
67651: PUSH
67652: LD_INT 2
67654: PUSH
67655: LD_INT 0
67657: PUSH
67658: EMPTY
67659: LIST
67660: LIST
67661: PUSH
67662: LD_INT 2
67664: PUSH
67665: LD_INT 1
67667: PUSH
67668: EMPTY
67669: LIST
67670: LIST
67671: PUSH
67672: LD_INT 1
67674: PUSH
67675: LD_INT 2
67677: PUSH
67678: EMPTY
67679: LIST
67680: LIST
67681: PUSH
67682: LD_INT 0
67684: PUSH
67685: LD_INT 2
67687: PUSH
67688: EMPTY
67689: LIST
67690: LIST
67691: PUSH
67692: LD_INT 1
67694: NEG
67695: PUSH
67696: LD_INT 1
67698: PUSH
67699: EMPTY
67700: LIST
67701: LIST
67702: PUSH
67703: LD_INT 2
67705: NEG
67706: PUSH
67707: LD_INT 1
67709: NEG
67710: PUSH
67711: EMPTY
67712: LIST
67713: LIST
67714: PUSH
67715: LD_INT 2
67717: NEG
67718: PUSH
67719: LD_INT 2
67721: NEG
67722: PUSH
67723: EMPTY
67724: LIST
67725: LIST
67726: PUSH
67727: LD_INT 2
67729: NEG
67730: PUSH
67731: LD_INT 3
67733: NEG
67734: PUSH
67735: EMPTY
67736: LIST
67737: LIST
67738: PUSH
67739: LD_INT 2
67741: PUSH
67742: LD_INT 1
67744: NEG
67745: PUSH
67746: EMPTY
67747: LIST
67748: LIST
67749: PUSH
67750: LD_INT 3
67752: PUSH
67753: LD_INT 1
67755: PUSH
67756: EMPTY
67757: LIST
67758: LIST
67759: PUSH
67760: LD_INT 1
67762: PUSH
67763: LD_INT 3
67765: PUSH
67766: EMPTY
67767: LIST
67768: LIST
67769: PUSH
67770: LD_INT 1
67772: NEG
67773: PUSH
67774: LD_INT 2
67776: PUSH
67777: EMPTY
67778: LIST
67779: LIST
67780: PUSH
67781: LD_INT 3
67783: NEG
67784: PUSH
67785: LD_INT 2
67787: NEG
67788: PUSH
67789: EMPTY
67790: LIST
67791: LIST
67792: PUSH
67793: EMPTY
67794: LIST
67795: LIST
67796: LIST
67797: LIST
67798: LIST
67799: LIST
67800: LIST
67801: LIST
67802: LIST
67803: LIST
67804: LIST
67805: LIST
67806: LIST
67807: LIST
67808: LIST
67809: LIST
67810: LIST
67811: LIST
67812: LIST
67813: LIST
67814: LIST
67815: LIST
67816: LIST
67817: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
67818: LD_ADDR_VAR 0 30
67822: PUSH
67823: LD_INT 0
67825: PUSH
67826: LD_INT 0
67828: PUSH
67829: EMPTY
67830: LIST
67831: LIST
67832: PUSH
67833: LD_INT 0
67835: PUSH
67836: LD_INT 1
67838: NEG
67839: PUSH
67840: EMPTY
67841: LIST
67842: LIST
67843: PUSH
67844: LD_INT 1
67846: PUSH
67847: LD_INT 0
67849: PUSH
67850: EMPTY
67851: LIST
67852: LIST
67853: PUSH
67854: LD_INT 1
67856: PUSH
67857: LD_INT 1
67859: PUSH
67860: EMPTY
67861: LIST
67862: LIST
67863: PUSH
67864: LD_INT 0
67866: PUSH
67867: LD_INT 1
67869: PUSH
67870: EMPTY
67871: LIST
67872: LIST
67873: PUSH
67874: LD_INT 1
67876: NEG
67877: PUSH
67878: LD_INT 0
67880: PUSH
67881: EMPTY
67882: LIST
67883: LIST
67884: PUSH
67885: LD_INT 1
67887: NEG
67888: PUSH
67889: LD_INT 1
67891: NEG
67892: PUSH
67893: EMPTY
67894: LIST
67895: LIST
67896: PUSH
67897: LD_INT 1
67899: NEG
67900: PUSH
67901: LD_INT 2
67903: NEG
67904: PUSH
67905: EMPTY
67906: LIST
67907: LIST
67908: PUSH
67909: LD_INT 0
67911: PUSH
67912: LD_INT 2
67914: NEG
67915: PUSH
67916: EMPTY
67917: LIST
67918: LIST
67919: PUSH
67920: LD_INT 1
67922: PUSH
67923: LD_INT 1
67925: NEG
67926: PUSH
67927: EMPTY
67928: LIST
67929: LIST
67930: PUSH
67931: LD_INT 2
67933: PUSH
67934: LD_INT 0
67936: PUSH
67937: EMPTY
67938: LIST
67939: LIST
67940: PUSH
67941: LD_INT 2
67943: PUSH
67944: LD_INT 1
67946: PUSH
67947: EMPTY
67948: LIST
67949: LIST
67950: PUSH
67951: LD_INT 2
67953: PUSH
67954: LD_INT 2
67956: PUSH
67957: EMPTY
67958: LIST
67959: LIST
67960: PUSH
67961: LD_INT 1
67963: PUSH
67964: LD_INT 2
67966: PUSH
67967: EMPTY
67968: LIST
67969: LIST
67970: PUSH
67971: LD_INT 1
67973: NEG
67974: PUSH
67975: LD_INT 1
67977: PUSH
67978: EMPTY
67979: LIST
67980: LIST
67981: PUSH
67982: LD_INT 2
67984: NEG
67985: PUSH
67986: LD_INT 0
67988: PUSH
67989: EMPTY
67990: LIST
67991: LIST
67992: PUSH
67993: LD_INT 2
67995: NEG
67996: PUSH
67997: LD_INT 1
67999: NEG
68000: PUSH
68001: EMPTY
68002: LIST
68003: LIST
68004: PUSH
68005: LD_INT 1
68007: NEG
68008: PUSH
68009: LD_INT 3
68011: NEG
68012: PUSH
68013: EMPTY
68014: LIST
68015: LIST
68016: PUSH
68017: LD_INT 1
68019: PUSH
68020: LD_INT 2
68022: NEG
68023: PUSH
68024: EMPTY
68025: LIST
68026: LIST
68027: PUSH
68028: LD_INT 3
68030: PUSH
68031: LD_INT 2
68033: PUSH
68034: EMPTY
68035: LIST
68036: LIST
68037: PUSH
68038: LD_INT 2
68040: PUSH
68041: LD_INT 3
68043: PUSH
68044: EMPTY
68045: LIST
68046: LIST
68047: PUSH
68048: LD_INT 2
68050: NEG
68051: PUSH
68052: LD_INT 1
68054: PUSH
68055: EMPTY
68056: LIST
68057: LIST
68058: PUSH
68059: LD_INT 3
68061: NEG
68062: PUSH
68063: LD_INT 1
68065: NEG
68066: PUSH
68067: EMPTY
68068: LIST
68069: LIST
68070: PUSH
68071: EMPTY
68072: LIST
68073: LIST
68074: LIST
68075: LIST
68076: LIST
68077: LIST
68078: LIST
68079: LIST
68080: LIST
68081: LIST
68082: LIST
68083: LIST
68084: LIST
68085: LIST
68086: LIST
68087: LIST
68088: LIST
68089: LIST
68090: LIST
68091: LIST
68092: LIST
68093: LIST
68094: LIST
68095: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
68096: LD_ADDR_VAR 0 31
68100: PUSH
68101: LD_INT 0
68103: PUSH
68104: LD_INT 0
68106: PUSH
68107: EMPTY
68108: LIST
68109: LIST
68110: PUSH
68111: LD_INT 0
68113: PUSH
68114: LD_INT 1
68116: NEG
68117: PUSH
68118: EMPTY
68119: LIST
68120: LIST
68121: PUSH
68122: LD_INT 1
68124: PUSH
68125: LD_INT 0
68127: PUSH
68128: EMPTY
68129: LIST
68130: LIST
68131: PUSH
68132: LD_INT 1
68134: PUSH
68135: LD_INT 1
68137: PUSH
68138: EMPTY
68139: LIST
68140: LIST
68141: PUSH
68142: LD_INT 0
68144: PUSH
68145: LD_INT 1
68147: PUSH
68148: EMPTY
68149: LIST
68150: LIST
68151: PUSH
68152: LD_INT 1
68154: NEG
68155: PUSH
68156: LD_INT 0
68158: PUSH
68159: EMPTY
68160: LIST
68161: LIST
68162: PUSH
68163: LD_INT 1
68165: NEG
68166: PUSH
68167: LD_INT 1
68169: NEG
68170: PUSH
68171: EMPTY
68172: LIST
68173: LIST
68174: PUSH
68175: LD_INT 1
68177: NEG
68178: PUSH
68179: LD_INT 2
68181: NEG
68182: PUSH
68183: EMPTY
68184: LIST
68185: LIST
68186: PUSH
68187: LD_INT 1
68189: PUSH
68190: LD_INT 1
68192: NEG
68193: PUSH
68194: EMPTY
68195: LIST
68196: LIST
68197: PUSH
68198: LD_INT 2
68200: PUSH
68201: LD_INT 0
68203: PUSH
68204: EMPTY
68205: LIST
68206: LIST
68207: PUSH
68208: LD_INT 2
68210: PUSH
68211: LD_INT 1
68213: PUSH
68214: EMPTY
68215: LIST
68216: LIST
68217: PUSH
68218: LD_INT 2
68220: PUSH
68221: LD_INT 2
68223: PUSH
68224: EMPTY
68225: LIST
68226: LIST
68227: PUSH
68228: LD_INT 1
68230: PUSH
68231: LD_INT 2
68233: PUSH
68234: EMPTY
68235: LIST
68236: LIST
68237: PUSH
68238: LD_INT 0
68240: PUSH
68241: LD_INT 2
68243: PUSH
68244: EMPTY
68245: LIST
68246: LIST
68247: PUSH
68248: LD_INT 1
68250: NEG
68251: PUSH
68252: LD_INT 1
68254: PUSH
68255: EMPTY
68256: LIST
68257: LIST
68258: PUSH
68259: LD_INT 2
68261: NEG
68262: PUSH
68263: LD_INT 1
68265: NEG
68266: PUSH
68267: EMPTY
68268: LIST
68269: LIST
68270: PUSH
68271: LD_INT 2
68273: NEG
68274: PUSH
68275: LD_INT 2
68277: NEG
68278: PUSH
68279: EMPTY
68280: LIST
68281: LIST
68282: PUSH
68283: LD_INT 2
68285: NEG
68286: PUSH
68287: LD_INT 3
68289: NEG
68290: PUSH
68291: EMPTY
68292: LIST
68293: LIST
68294: PUSH
68295: LD_INT 2
68297: PUSH
68298: LD_INT 1
68300: NEG
68301: PUSH
68302: EMPTY
68303: LIST
68304: LIST
68305: PUSH
68306: LD_INT 3
68308: PUSH
68309: LD_INT 1
68311: PUSH
68312: EMPTY
68313: LIST
68314: LIST
68315: PUSH
68316: LD_INT 1
68318: PUSH
68319: LD_INT 3
68321: PUSH
68322: EMPTY
68323: LIST
68324: LIST
68325: PUSH
68326: LD_INT 1
68328: NEG
68329: PUSH
68330: LD_INT 2
68332: PUSH
68333: EMPTY
68334: LIST
68335: LIST
68336: PUSH
68337: LD_INT 3
68339: NEG
68340: PUSH
68341: LD_INT 2
68343: NEG
68344: PUSH
68345: EMPTY
68346: LIST
68347: LIST
68348: PUSH
68349: EMPTY
68350: LIST
68351: LIST
68352: LIST
68353: LIST
68354: LIST
68355: LIST
68356: LIST
68357: LIST
68358: LIST
68359: LIST
68360: LIST
68361: LIST
68362: LIST
68363: LIST
68364: LIST
68365: LIST
68366: LIST
68367: LIST
68368: LIST
68369: LIST
68370: LIST
68371: LIST
68372: LIST
68373: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
68374: LD_ADDR_VAR 0 32
68378: PUSH
68379: LD_INT 0
68381: PUSH
68382: LD_INT 0
68384: PUSH
68385: EMPTY
68386: LIST
68387: LIST
68388: PUSH
68389: LD_INT 0
68391: PUSH
68392: LD_INT 1
68394: NEG
68395: PUSH
68396: EMPTY
68397: LIST
68398: LIST
68399: PUSH
68400: LD_INT 1
68402: PUSH
68403: LD_INT 0
68405: PUSH
68406: EMPTY
68407: LIST
68408: LIST
68409: PUSH
68410: LD_INT 1
68412: PUSH
68413: LD_INT 1
68415: PUSH
68416: EMPTY
68417: LIST
68418: LIST
68419: PUSH
68420: LD_INT 0
68422: PUSH
68423: LD_INT 1
68425: PUSH
68426: EMPTY
68427: LIST
68428: LIST
68429: PUSH
68430: LD_INT 1
68432: NEG
68433: PUSH
68434: LD_INT 0
68436: PUSH
68437: EMPTY
68438: LIST
68439: LIST
68440: PUSH
68441: LD_INT 1
68443: NEG
68444: PUSH
68445: LD_INT 1
68447: NEG
68448: PUSH
68449: EMPTY
68450: LIST
68451: LIST
68452: PUSH
68453: LD_INT 1
68455: NEG
68456: PUSH
68457: LD_INT 2
68459: NEG
68460: PUSH
68461: EMPTY
68462: LIST
68463: LIST
68464: PUSH
68465: LD_INT 0
68467: PUSH
68468: LD_INT 2
68470: NEG
68471: PUSH
68472: EMPTY
68473: LIST
68474: LIST
68475: PUSH
68476: LD_INT 1
68478: PUSH
68479: LD_INT 1
68481: NEG
68482: PUSH
68483: EMPTY
68484: LIST
68485: LIST
68486: PUSH
68487: LD_INT 2
68489: PUSH
68490: LD_INT 1
68492: PUSH
68493: EMPTY
68494: LIST
68495: LIST
68496: PUSH
68497: LD_INT 2
68499: PUSH
68500: LD_INT 2
68502: PUSH
68503: EMPTY
68504: LIST
68505: LIST
68506: PUSH
68507: LD_INT 1
68509: PUSH
68510: LD_INT 2
68512: PUSH
68513: EMPTY
68514: LIST
68515: LIST
68516: PUSH
68517: LD_INT 0
68519: PUSH
68520: LD_INT 2
68522: PUSH
68523: EMPTY
68524: LIST
68525: LIST
68526: PUSH
68527: LD_INT 1
68529: NEG
68530: PUSH
68531: LD_INT 1
68533: PUSH
68534: EMPTY
68535: LIST
68536: LIST
68537: PUSH
68538: LD_INT 2
68540: NEG
68541: PUSH
68542: LD_INT 0
68544: PUSH
68545: EMPTY
68546: LIST
68547: LIST
68548: PUSH
68549: LD_INT 2
68551: NEG
68552: PUSH
68553: LD_INT 1
68555: NEG
68556: PUSH
68557: EMPTY
68558: LIST
68559: LIST
68560: PUSH
68561: LD_INT 1
68563: NEG
68564: PUSH
68565: LD_INT 3
68567: NEG
68568: PUSH
68569: EMPTY
68570: LIST
68571: LIST
68572: PUSH
68573: LD_INT 1
68575: PUSH
68576: LD_INT 2
68578: NEG
68579: PUSH
68580: EMPTY
68581: LIST
68582: LIST
68583: PUSH
68584: LD_INT 3
68586: PUSH
68587: LD_INT 2
68589: PUSH
68590: EMPTY
68591: LIST
68592: LIST
68593: PUSH
68594: LD_INT 2
68596: PUSH
68597: LD_INT 3
68599: PUSH
68600: EMPTY
68601: LIST
68602: LIST
68603: PUSH
68604: LD_INT 2
68606: NEG
68607: PUSH
68608: LD_INT 1
68610: PUSH
68611: EMPTY
68612: LIST
68613: LIST
68614: PUSH
68615: LD_INT 3
68617: NEG
68618: PUSH
68619: LD_INT 1
68621: NEG
68622: PUSH
68623: EMPTY
68624: LIST
68625: LIST
68626: PUSH
68627: EMPTY
68628: LIST
68629: LIST
68630: LIST
68631: LIST
68632: LIST
68633: LIST
68634: LIST
68635: LIST
68636: LIST
68637: LIST
68638: LIST
68639: LIST
68640: LIST
68641: LIST
68642: LIST
68643: LIST
68644: LIST
68645: LIST
68646: LIST
68647: LIST
68648: LIST
68649: LIST
68650: LIST
68651: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
68652: LD_ADDR_VAR 0 33
68656: PUSH
68657: LD_INT 0
68659: PUSH
68660: LD_INT 0
68662: PUSH
68663: EMPTY
68664: LIST
68665: LIST
68666: PUSH
68667: LD_INT 0
68669: PUSH
68670: LD_INT 1
68672: NEG
68673: PUSH
68674: EMPTY
68675: LIST
68676: LIST
68677: PUSH
68678: LD_INT 1
68680: PUSH
68681: LD_INT 0
68683: PUSH
68684: EMPTY
68685: LIST
68686: LIST
68687: PUSH
68688: LD_INT 1
68690: PUSH
68691: LD_INT 1
68693: PUSH
68694: EMPTY
68695: LIST
68696: LIST
68697: PUSH
68698: LD_INT 0
68700: PUSH
68701: LD_INT 1
68703: PUSH
68704: EMPTY
68705: LIST
68706: LIST
68707: PUSH
68708: LD_INT 1
68710: NEG
68711: PUSH
68712: LD_INT 0
68714: PUSH
68715: EMPTY
68716: LIST
68717: LIST
68718: PUSH
68719: LD_INT 1
68721: NEG
68722: PUSH
68723: LD_INT 1
68725: NEG
68726: PUSH
68727: EMPTY
68728: LIST
68729: LIST
68730: PUSH
68731: LD_INT 1
68733: NEG
68734: PUSH
68735: LD_INT 2
68737: NEG
68738: PUSH
68739: EMPTY
68740: LIST
68741: LIST
68742: PUSH
68743: LD_INT 1
68745: PUSH
68746: LD_INT 1
68748: NEG
68749: PUSH
68750: EMPTY
68751: LIST
68752: LIST
68753: PUSH
68754: LD_INT 2
68756: PUSH
68757: LD_INT 0
68759: PUSH
68760: EMPTY
68761: LIST
68762: LIST
68763: PUSH
68764: LD_INT 2
68766: PUSH
68767: LD_INT 1
68769: PUSH
68770: EMPTY
68771: LIST
68772: LIST
68773: PUSH
68774: LD_INT 1
68776: PUSH
68777: LD_INT 2
68779: PUSH
68780: EMPTY
68781: LIST
68782: LIST
68783: PUSH
68784: LD_INT 0
68786: PUSH
68787: LD_INT 2
68789: PUSH
68790: EMPTY
68791: LIST
68792: LIST
68793: PUSH
68794: LD_INT 1
68796: NEG
68797: PUSH
68798: LD_INT 1
68800: PUSH
68801: EMPTY
68802: LIST
68803: LIST
68804: PUSH
68805: LD_INT 2
68807: NEG
68808: PUSH
68809: LD_INT 0
68811: PUSH
68812: EMPTY
68813: LIST
68814: LIST
68815: PUSH
68816: LD_INT 2
68818: NEG
68819: PUSH
68820: LD_INT 1
68822: NEG
68823: PUSH
68824: EMPTY
68825: LIST
68826: LIST
68827: PUSH
68828: LD_INT 2
68830: NEG
68831: PUSH
68832: LD_INT 2
68834: NEG
68835: PUSH
68836: EMPTY
68837: LIST
68838: LIST
68839: PUSH
68840: LD_INT 2
68842: NEG
68843: PUSH
68844: LD_INT 3
68846: NEG
68847: PUSH
68848: EMPTY
68849: LIST
68850: LIST
68851: PUSH
68852: LD_INT 2
68854: PUSH
68855: LD_INT 1
68857: NEG
68858: PUSH
68859: EMPTY
68860: LIST
68861: LIST
68862: PUSH
68863: LD_INT 3
68865: PUSH
68866: LD_INT 1
68868: PUSH
68869: EMPTY
68870: LIST
68871: LIST
68872: PUSH
68873: LD_INT 1
68875: PUSH
68876: LD_INT 3
68878: PUSH
68879: EMPTY
68880: LIST
68881: LIST
68882: PUSH
68883: LD_INT 1
68885: NEG
68886: PUSH
68887: LD_INT 2
68889: PUSH
68890: EMPTY
68891: LIST
68892: LIST
68893: PUSH
68894: LD_INT 3
68896: NEG
68897: PUSH
68898: LD_INT 2
68900: NEG
68901: PUSH
68902: EMPTY
68903: LIST
68904: LIST
68905: PUSH
68906: EMPTY
68907: LIST
68908: LIST
68909: LIST
68910: LIST
68911: LIST
68912: LIST
68913: LIST
68914: LIST
68915: LIST
68916: LIST
68917: LIST
68918: LIST
68919: LIST
68920: LIST
68921: LIST
68922: LIST
68923: LIST
68924: LIST
68925: LIST
68926: LIST
68927: LIST
68928: LIST
68929: LIST
68930: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
68931: LD_ADDR_VAR 0 34
68935: PUSH
68936: LD_INT 0
68938: PUSH
68939: LD_INT 0
68941: PUSH
68942: EMPTY
68943: LIST
68944: LIST
68945: PUSH
68946: LD_INT 0
68948: PUSH
68949: LD_INT 1
68951: NEG
68952: PUSH
68953: EMPTY
68954: LIST
68955: LIST
68956: PUSH
68957: LD_INT 1
68959: PUSH
68960: LD_INT 0
68962: PUSH
68963: EMPTY
68964: LIST
68965: LIST
68966: PUSH
68967: LD_INT 1
68969: PUSH
68970: LD_INT 1
68972: PUSH
68973: EMPTY
68974: LIST
68975: LIST
68976: PUSH
68977: LD_INT 0
68979: PUSH
68980: LD_INT 1
68982: PUSH
68983: EMPTY
68984: LIST
68985: LIST
68986: PUSH
68987: LD_INT 1
68989: NEG
68990: PUSH
68991: LD_INT 0
68993: PUSH
68994: EMPTY
68995: LIST
68996: LIST
68997: PUSH
68998: LD_INT 1
69000: NEG
69001: PUSH
69002: LD_INT 1
69004: NEG
69005: PUSH
69006: EMPTY
69007: LIST
69008: LIST
69009: PUSH
69010: LD_INT 1
69012: NEG
69013: PUSH
69014: LD_INT 2
69016: NEG
69017: PUSH
69018: EMPTY
69019: LIST
69020: LIST
69021: PUSH
69022: LD_INT 0
69024: PUSH
69025: LD_INT 2
69027: NEG
69028: PUSH
69029: EMPTY
69030: LIST
69031: LIST
69032: PUSH
69033: LD_INT 1
69035: PUSH
69036: LD_INT 1
69038: NEG
69039: PUSH
69040: EMPTY
69041: LIST
69042: LIST
69043: PUSH
69044: LD_INT 2
69046: PUSH
69047: LD_INT 1
69049: PUSH
69050: EMPTY
69051: LIST
69052: LIST
69053: PUSH
69054: LD_INT 2
69056: PUSH
69057: LD_INT 2
69059: PUSH
69060: EMPTY
69061: LIST
69062: LIST
69063: PUSH
69064: LD_INT 1
69066: PUSH
69067: LD_INT 2
69069: PUSH
69070: EMPTY
69071: LIST
69072: LIST
69073: PUSH
69074: LD_INT 1
69076: NEG
69077: PUSH
69078: LD_INT 1
69080: PUSH
69081: EMPTY
69082: LIST
69083: LIST
69084: PUSH
69085: LD_INT 2
69087: NEG
69088: PUSH
69089: LD_INT 0
69091: PUSH
69092: EMPTY
69093: LIST
69094: LIST
69095: PUSH
69096: LD_INT 2
69098: NEG
69099: PUSH
69100: LD_INT 1
69102: NEG
69103: PUSH
69104: EMPTY
69105: LIST
69106: LIST
69107: PUSH
69108: LD_INT 2
69110: NEG
69111: PUSH
69112: LD_INT 2
69114: NEG
69115: PUSH
69116: EMPTY
69117: LIST
69118: LIST
69119: PUSH
69120: LD_INT 1
69122: NEG
69123: PUSH
69124: LD_INT 3
69126: NEG
69127: PUSH
69128: EMPTY
69129: LIST
69130: LIST
69131: PUSH
69132: LD_INT 1
69134: PUSH
69135: LD_INT 2
69137: NEG
69138: PUSH
69139: EMPTY
69140: LIST
69141: LIST
69142: PUSH
69143: LD_INT 3
69145: PUSH
69146: LD_INT 2
69148: PUSH
69149: EMPTY
69150: LIST
69151: LIST
69152: PUSH
69153: LD_INT 2
69155: PUSH
69156: LD_INT 3
69158: PUSH
69159: EMPTY
69160: LIST
69161: LIST
69162: PUSH
69163: LD_INT 2
69165: NEG
69166: PUSH
69167: LD_INT 1
69169: PUSH
69170: EMPTY
69171: LIST
69172: LIST
69173: PUSH
69174: LD_INT 3
69176: NEG
69177: PUSH
69178: LD_INT 1
69180: NEG
69181: PUSH
69182: EMPTY
69183: LIST
69184: LIST
69185: PUSH
69186: EMPTY
69187: LIST
69188: LIST
69189: LIST
69190: LIST
69191: LIST
69192: LIST
69193: LIST
69194: LIST
69195: LIST
69196: LIST
69197: LIST
69198: LIST
69199: LIST
69200: LIST
69201: LIST
69202: LIST
69203: LIST
69204: LIST
69205: LIST
69206: LIST
69207: LIST
69208: LIST
69209: LIST
69210: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
69211: LD_ADDR_VAR 0 35
69215: PUSH
69216: LD_INT 0
69218: PUSH
69219: LD_INT 0
69221: PUSH
69222: EMPTY
69223: LIST
69224: LIST
69225: PUSH
69226: LD_INT 0
69228: PUSH
69229: LD_INT 1
69231: NEG
69232: PUSH
69233: EMPTY
69234: LIST
69235: LIST
69236: PUSH
69237: LD_INT 1
69239: PUSH
69240: LD_INT 0
69242: PUSH
69243: EMPTY
69244: LIST
69245: LIST
69246: PUSH
69247: LD_INT 1
69249: PUSH
69250: LD_INT 1
69252: PUSH
69253: EMPTY
69254: LIST
69255: LIST
69256: PUSH
69257: LD_INT 0
69259: PUSH
69260: LD_INT 1
69262: PUSH
69263: EMPTY
69264: LIST
69265: LIST
69266: PUSH
69267: LD_INT 1
69269: NEG
69270: PUSH
69271: LD_INT 0
69273: PUSH
69274: EMPTY
69275: LIST
69276: LIST
69277: PUSH
69278: LD_INT 1
69280: NEG
69281: PUSH
69282: LD_INT 1
69284: NEG
69285: PUSH
69286: EMPTY
69287: LIST
69288: LIST
69289: PUSH
69290: LD_INT 2
69292: PUSH
69293: LD_INT 1
69295: PUSH
69296: EMPTY
69297: LIST
69298: LIST
69299: PUSH
69300: LD_INT 2
69302: NEG
69303: PUSH
69304: LD_INT 1
69306: NEG
69307: PUSH
69308: EMPTY
69309: LIST
69310: LIST
69311: PUSH
69312: EMPTY
69313: LIST
69314: LIST
69315: LIST
69316: LIST
69317: LIST
69318: LIST
69319: LIST
69320: LIST
69321: LIST
69322: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
69323: LD_ADDR_VAR 0 36
69327: PUSH
69328: LD_INT 0
69330: PUSH
69331: LD_INT 0
69333: PUSH
69334: EMPTY
69335: LIST
69336: LIST
69337: PUSH
69338: LD_INT 0
69340: PUSH
69341: LD_INT 1
69343: NEG
69344: PUSH
69345: EMPTY
69346: LIST
69347: LIST
69348: PUSH
69349: LD_INT 1
69351: PUSH
69352: LD_INT 0
69354: PUSH
69355: EMPTY
69356: LIST
69357: LIST
69358: PUSH
69359: LD_INT 1
69361: PUSH
69362: LD_INT 1
69364: PUSH
69365: EMPTY
69366: LIST
69367: LIST
69368: PUSH
69369: LD_INT 0
69371: PUSH
69372: LD_INT 1
69374: PUSH
69375: EMPTY
69376: LIST
69377: LIST
69378: PUSH
69379: LD_INT 1
69381: NEG
69382: PUSH
69383: LD_INT 0
69385: PUSH
69386: EMPTY
69387: LIST
69388: LIST
69389: PUSH
69390: LD_INT 1
69392: NEG
69393: PUSH
69394: LD_INT 1
69396: NEG
69397: PUSH
69398: EMPTY
69399: LIST
69400: LIST
69401: PUSH
69402: LD_INT 1
69404: NEG
69405: PUSH
69406: LD_INT 2
69408: NEG
69409: PUSH
69410: EMPTY
69411: LIST
69412: LIST
69413: PUSH
69414: LD_INT 1
69416: PUSH
69417: LD_INT 2
69419: PUSH
69420: EMPTY
69421: LIST
69422: LIST
69423: PUSH
69424: EMPTY
69425: LIST
69426: LIST
69427: LIST
69428: LIST
69429: LIST
69430: LIST
69431: LIST
69432: LIST
69433: LIST
69434: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
69435: LD_ADDR_VAR 0 37
69439: PUSH
69440: LD_INT 0
69442: PUSH
69443: LD_INT 0
69445: PUSH
69446: EMPTY
69447: LIST
69448: LIST
69449: PUSH
69450: LD_INT 0
69452: PUSH
69453: LD_INT 1
69455: NEG
69456: PUSH
69457: EMPTY
69458: LIST
69459: LIST
69460: PUSH
69461: LD_INT 1
69463: PUSH
69464: LD_INT 0
69466: PUSH
69467: EMPTY
69468: LIST
69469: LIST
69470: PUSH
69471: LD_INT 1
69473: PUSH
69474: LD_INT 1
69476: PUSH
69477: EMPTY
69478: LIST
69479: LIST
69480: PUSH
69481: LD_INT 0
69483: PUSH
69484: LD_INT 1
69486: PUSH
69487: EMPTY
69488: LIST
69489: LIST
69490: PUSH
69491: LD_INT 1
69493: NEG
69494: PUSH
69495: LD_INT 0
69497: PUSH
69498: EMPTY
69499: LIST
69500: LIST
69501: PUSH
69502: LD_INT 1
69504: NEG
69505: PUSH
69506: LD_INT 1
69508: NEG
69509: PUSH
69510: EMPTY
69511: LIST
69512: LIST
69513: PUSH
69514: LD_INT 1
69516: PUSH
69517: LD_INT 1
69519: NEG
69520: PUSH
69521: EMPTY
69522: LIST
69523: LIST
69524: PUSH
69525: LD_INT 1
69527: NEG
69528: PUSH
69529: LD_INT 1
69531: PUSH
69532: EMPTY
69533: LIST
69534: LIST
69535: PUSH
69536: EMPTY
69537: LIST
69538: LIST
69539: LIST
69540: LIST
69541: LIST
69542: LIST
69543: LIST
69544: LIST
69545: LIST
69546: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
69547: LD_ADDR_VAR 0 38
69551: PUSH
69552: LD_INT 0
69554: PUSH
69555: LD_INT 0
69557: PUSH
69558: EMPTY
69559: LIST
69560: LIST
69561: PUSH
69562: LD_INT 0
69564: PUSH
69565: LD_INT 1
69567: NEG
69568: PUSH
69569: EMPTY
69570: LIST
69571: LIST
69572: PUSH
69573: LD_INT 1
69575: PUSH
69576: LD_INT 0
69578: PUSH
69579: EMPTY
69580: LIST
69581: LIST
69582: PUSH
69583: LD_INT 1
69585: PUSH
69586: LD_INT 1
69588: PUSH
69589: EMPTY
69590: LIST
69591: LIST
69592: PUSH
69593: LD_INT 0
69595: PUSH
69596: LD_INT 1
69598: PUSH
69599: EMPTY
69600: LIST
69601: LIST
69602: PUSH
69603: LD_INT 1
69605: NEG
69606: PUSH
69607: LD_INT 0
69609: PUSH
69610: EMPTY
69611: LIST
69612: LIST
69613: PUSH
69614: LD_INT 1
69616: NEG
69617: PUSH
69618: LD_INT 1
69620: NEG
69621: PUSH
69622: EMPTY
69623: LIST
69624: LIST
69625: PUSH
69626: LD_INT 2
69628: PUSH
69629: LD_INT 1
69631: PUSH
69632: EMPTY
69633: LIST
69634: LIST
69635: PUSH
69636: LD_INT 2
69638: NEG
69639: PUSH
69640: LD_INT 1
69642: NEG
69643: PUSH
69644: EMPTY
69645: LIST
69646: LIST
69647: PUSH
69648: EMPTY
69649: LIST
69650: LIST
69651: LIST
69652: LIST
69653: LIST
69654: LIST
69655: LIST
69656: LIST
69657: LIST
69658: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
69659: LD_ADDR_VAR 0 39
69663: PUSH
69664: LD_INT 0
69666: PUSH
69667: LD_INT 0
69669: PUSH
69670: EMPTY
69671: LIST
69672: LIST
69673: PUSH
69674: LD_INT 0
69676: PUSH
69677: LD_INT 1
69679: NEG
69680: PUSH
69681: EMPTY
69682: LIST
69683: LIST
69684: PUSH
69685: LD_INT 1
69687: PUSH
69688: LD_INT 0
69690: PUSH
69691: EMPTY
69692: LIST
69693: LIST
69694: PUSH
69695: LD_INT 1
69697: PUSH
69698: LD_INT 1
69700: PUSH
69701: EMPTY
69702: LIST
69703: LIST
69704: PUSH
69705: LD_INT 0
69707: PUSH
69708: LD_INT 1
69710: PUSH
69711: EMPTY
69712: LIST
69713: LIST
69714: PUSH
69715: LD_INT 1
69717: NEG
69718: PUSH
69719: LD_INT 0
69721: PUSH
69722: EMPTY
69723: LIST
69724: LIST
69725: PUSH
69726: LD_INT 1
69728: NEG
69729: PUSH
69730: LD_INT 1
69732: NEG
69733: PUSH
69734: EMPTY
69735: LIST
69736: LIST
69737: PUSH
69738: LD_INT 1
69740: NEG
69741: PUSH
69742: LD_INT 2
69744: NEG
69745: PUSH
69746: EMPTY
69747: LIST
69748: LIST
69749: PUSH
69750: LD_INT 1
69752: PUSH
69753: LD_INT 2
69755: PUSH
69756: EMPTY
69757: LIST
69758: LIST
69759: PUSH
69760: EMPTY
69761: LIST
69762: LIST
69763: LIST
69764: LIST
69765: LIST
69766: LIST
69767: LIST
69768: LIST
69769: LIST
69770: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
69771: LD_ADDR_VAR 0 40
69775: PUSH
69776: LD_INT 0
69778: PUSH
69779: LD_INT 0
69781: PUSH
69782: EMPTY
69783: LIST
69784: LIST
69785: PUSH
69786: LD_INT 0
69788: PUSH
69789: LD_INT 1
69791: NEG
69792: PUSH
69793: EMPTY
69794: LIST
69795: LIST
69796: PUSH
69797: LD_INT 1
69799: PUSH
69800: LD_INT 0
69802: PUSH
69803: EMPTY
69804: LIST
69805: LIST
69806: PUSH
69807: LD_INT 1
69809: PUSH
69810: LD_INT 1
69812: PUSH
69813: EMPTY
69814: LIST
69815: LIST
69816: PUSH
69817: LD_INT 0
69819: PUSH
69820: LD_INT 1
69822: PUSH
69823: EMPTY
69824: LIST
69825: LIST
69826: PUSH
69827: LD_INT 1
69829: NEG
69830: PUSH
69831: LD_INT 0
69833: PUSH
69834: EMPTY
69835: LIST
69836: LIST
69837: PUSH
69838: LD_INT 1
69840: NEG
69841: PUSH
69842: LD_INT 1
69844: NEG
69845: PUSH
69846: EMPTY
69847: LIST
69848: LIST
69849: PUSH
69850: LD_INT 1
69852: PUSH
69853: LD_INT 1
69855: NEG
69856: PUSH
69857: EMPTY
69858: LIST
69859: LIST
69860: PUSH
69861: LD_INT 1
69863: NEG
69864: PUSH
69865: LD_INT 1
69867: PUSH
69868: EMPTY
69869: LIST
69870: LIST
69871: PUSH
69872: EMPTY
69873: LIST
69874: LIST
69875: LIST
69876: LIST
69877: LIST
69878: LIST
69879: LIST
69880: LIST
69881: LIST
69882: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
69883: LD_ADDR_VAR 0 41
69887: PUSH
69888: LD_INT 0
69890: PUSH
69891: LD_INT 0
69893: PUSH
69894: EMPTY
69895: LIST
69896: LIST
69897: PUSH
69898: LD_INT 0
69900: PUSH
69901: LD_INT 1
69903: NEG
69904: PUSH
69905: EMPTY
69906: LIST
69907: LIST
69908: PUSH
69909: LD_INT 1
69911: PUSH
69912: LD_INT 0
69914: PUSH
69915: EMPTY
69916: LIST
69917: LIST
69918: PUSH
69919: LD_INT 1
69921: PUSH
69922: LD_INT 1
69924: PUSH
69925: EMPTY
69926: LIST
69927: LIST
69928: PUSH
69929: LD_INT 0
69931: PUSH
69932: LD_INT 1
69934: PUSH
69935: EMPTY
69936: LIST
69937: LIST
69938: PUSH
69939: LD_INT 1
69941: NEG
69942: PUSH
69943: LD_INT 0
69945: PUSH
69946: EMPTY
69947: LIST
69948: LIST
69949: PUSH
69950: LD_INT 1
69952: NEG
69953: PUSH
69954: LD_INT 1
69956: NEG
69957: PUSH
69958: EMPTY
69959: LIST
69960: LIST
69961: PUSH
69962: LD_INT 1
69964: NEG
69965: PUSH
69966: LD_INT 2
69968: NEG
69969: PUSH
69970: EMPTY
69971: LIST
69972: LIST
69973: PUSH
69974: LD_INT 1
69976: PUSH
69977: LD_INT 1
69979: NEG
69980: PUSH
69981: EMPTY
69982: LIST
69983: LIST
69984: PUSH
69985: LD_INT 2
69987: PUSH
69988: LD_INT 0
69990: PUSH
69991: EMPTY
69992: LIST
69993: LIST
69994: PUSH
69995: LD_INT 2
69997: PUSH
69998: LD_INT 1
70000: PUSH
70001: EMPTY
70002: LIST
70003: LIST
70004: PUSH
70005: LD_INT 2
70007: PUSH
70008: LD_INT 2
70010: PUSH
70011: EMPTY
70012: LIST
70013: LIST
70014: PUSH
70015: LD_INT 1
70017: PUSH
70018: LD_INT 2
70020: PUSH
70021: EMPTY
70022: LIST
70023: LIST
70024: PUSH
70025: LD_INT 1
70027: NEG
70028: PUSH
70029: LD_INT 1
70031: PUSH
70032: EMPTY
70033: LIST
70034: LIST
70035: PUSH
70036: LD_INT 2
70038: NEG
70039: PUSH
70040: LD_INT 0
70042: PUSH
70043: EMPTY
70044: LIST
70045: LIST
70046: PUSH
70047: LD_INT 2
70049: NEG
70050: PUSH
70051: LD_INT 1
70053: NEG
70054: PUSH
70055: EMPTY
70056: LIST
70057: LIST
70058: PUSH
70059: LD_INT 2
70061: NEG
70062: PUSH
70063: LD_INT 2
70065: NEG
70066: PUSH
70067: EMPTY
70068: LIST
70069: LIST
70070: PUSH
70071: LD_INT 2
70073: NEG
70074: PUSH
70075: LD_INT 3
70077: NEG
70078: PUSH
70079: EMPTY
70080: LIST
70081: LIST
70082: PUSH
70083: LD_INT 2
70085: PUSH
70086: LD_INT 1
70088: NEG
70089: PUSH
70090: EMPTY
70091: LIST
70092: LIST
70093: PUSH
70094: LD_INT 3
70096: PUSH
70097: LD_INT 0
70099: PUSH
70100: EMPTY
70101: LIST
70102: LIST
70103: PUSH
70104: LD_INT 3
70106: PUSH
70107: LD_INT 1
70109: PUSH
70110: EMPTY
70111: LIST
70112: LIST
70113: PUSH
70114: LD_INT 3
70116: PUSH
70117: LD_INT 2
70119: PUSH
70120: EMPTY
70121: LIST
70122: LIST
70123: PUSH
70124: LD_INT 3
70126: PUSH
70127: LD_INT 3
70129: PUSH
70130: EMPTY
70131: LIST
70132: LIST
70133: PUSH
70134: LD_INT 2
70136: PUSH
70137: LD_INT 3
70139: PUSH
70140: EMPTY
70141: LIST
70142: LIST
70143: PUSH
70144: LD_INT 2
70146: NEG
70147: PUSH
70148: LD_INT 1
70150: PUSH
70151: EMPTY
70152: LIST
70153: LIST
70154: PUSH
70155: LD_INT 3
70157: NEG
70158: PUSH
70159: LD_INT 0
70161: PUSH
70162: EMPTY
70163: LIST
70164: LIST
70165: PUSH
70166: LD_INT 3
70168: NEG
70169: PUSH
70170: LD_INT 1
70172: NEG
70173: PUSH
70174: EMPTY
70175: LIST
70176: LIST
70177: PUSH
70178: LD_INT 3
70180: NEG
70181: PUSH
70182: LD_INT 2
70184: NEG
70185: PUSH
70186: EMPTY
70187: LIST
70188: LIST
70189: PUSH
70190: LD_INT 3
70192: NEG
70193: PUSH
70194: LD_INT 3
70196: NEG
70197: PUSH
70198: EMPTY
70199: LIST
70200: LIST
70201: PUSH
70202: EMPTY
70203: LIST
70204: LIST
70205: LIST
70206: LIST
70207: LIST
70208: LIST
70209: LIST
70210: LIST
70211: LIST
70212: LIST
70213: LIST
70214: LIST
70215: LIST
70216: LIST
70217: LIST
70218: LIST
70219: LIST
70220: LIST
70221: LIST
70222: LIST
70223: LIST
70224: LIST
70225: LIST
70226: LIST
70227: LIST
70228: LIST
70229: LIST
70230: LIST
70231: LIST
70232: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70233: LD_ADDR_VAR 0 42
70237: PUSH
70238: LD_INT 0
70240: PUSH
70241: LD_INT 0
70243: PUSH
70244: EMPTY
70245: LIST
70246: LIST
70247: PUSH
70248: LD_INT 0
70250: PUSH
70251: LD_INT 1
70253: NEG
70254: PUSH
70255: EMPTY
70256: LIST
70257: LIST
70258: PUSH
70259: LD_INT 1
70261: PUSH
70262: LD_INT 0
70264: PUSH
70265: EMPTY
70266: LIST
70267: LIST
70268: PUSH
70269: LD_INT 1
70271: PUSH
70272: LD_INT 1
70274: PUSH
70275: EMPTY
70276: LIST
70277: LIST
70278: PUSH
70279: LD_INT 0
70281: PUSH
70282: LD_INT 1
70284: PUSH
70285: EMPTY
70286: LIST
70287: LIST
70288: PUSH
70289: LD_INT 1
70291: NEG
70292: PUSH
70293: LD_INT 0
70295: PUSH
70296: EMPTY
70297: LIST
70298: LIST
70299: PUSH
70300: LD_INT 1
70302: NEG
70303: PUSH
70304: LD_INT 1
70306: NEG
70307: PUSH
70308: EMPTY
70309: LIST
70310: LIST
70311: PUSH
70312: LD_INT 1
70314: NEG
70315: PUSH
70316: LD_INT 2
70318: NEG
70319: PUSH
70320: EMPTY
70321: LIST
70322: LIST
70323: PUSH
70324: LD_INT 0
70326: PUSH
70327: LD_INT 2
70329: NEG
70330: PUSH
70331: EMPTY
70332: LIST
70333: LIST
70334: PUSH
70335: LD_INT 1
70337: PUSH
70338: LD_INT 1
70340: NEG
70341: PUSH
70342: EMPTY
70343: LIST
70344: LIST
70345: PUSH
70346: LD_INT 2
70348: PUSH
70349: LD_INT 1
70351: PUSH
70352: EMPTY
70353: LIST
70354: LIST
70355: PUSH
70356: LD_INT 2
70358: PUSH
70359: LD_INT 2
70361: PUSH
70362: EMPTY
70363: LIST
70364: LIST
70365: PUSH
70366: LD_INT 1
70368: PUSH
70369: LD_INT 2
70371: PUSH
70372: EMPTY
70373: LIST
70374: LIST
70375: PUSH
70376: LD_INT 0
70378: PUSH
70379: LD_INT 2
70381: PUSH
70382: EMPTY
70383: LIST
70384: LIST
70385: PUSH
70386: LD_INT 1
70388: NEG
70389: PUSH
70390: LD_INT 1
70392: PUSH
70393: EMPTY
70394: LIST
70395: LIST
70396: PUSH
70397: LD_INT 2
70399: NEG
70400: PUSH
70401: LD_INT 1
70403: NEG
70404: PUSH
70405: EMPTY
70406: LIST
70407: LIST
70408: PUSH
70409: LD_INT 2
70411: NEG
70412: PUSH
70413: LD_INT 2
70415: NEG
70416: PUSH
70417: EMPTY
70418: LIST
70419: LIST
70420: PUSH
70421: LD_INT 2
70423: NEG
70424: PUSH
70425: LD_INT 3
70427: NEG
70428: PUSH
70429: EMPTY
70430: LIST
70431: LIST
70432: PUSH
70433: LD_INT 1
70435: NEG
70436: PUSH
70437: LD_INT 3
70439: NEG
70440: PUSH
70441: EMPTY
70442: LIST
70443: LIST
70444: PUSH
70445: LD_INT 0
70447: PUSH
70448: LD_INT 3
70450: NEG
70451: PUSH
70452: EMPTY
70453: LIST
70454: LIST
70455: PUSH
70456: LD_INT 1
70458: PUSH
70459: LD_INT 2
70461: NEG
70462: PUSH
70463: EMPTY
70464: LIST
70465: LIST
70466: PUSH
70467: LD_INT 3
70469: PUSH
70470: LD_INT 2
70472: PUSH
70473: EMPTY
70474: LIST
70475: LIST
70476: PUSH
70477: LD_INT 3
70479: PUSH
70480: LD_INT 3
70482: PUSH
70483: EMPTY
70484: LIST
70485: LIST
70486: PUSH
70487: LD_INT 2
70489: PUSH
70490: LD_INT 3
70492: PUSH
70493: EMPTY
70494: LIST
70495: LIST
70496: PUSH
70497: LD_INT 1
70499: PUSH
70500: LD_INT 3
70502: PUSH
70503: EMPTY
70504: LIST
70505: LIST
70506: PUSH
70507: LD_INT 0
70509: PUSH
70510: LD_INT 3
70512: PUSH
70513: EMPTY
70514: LIST
70515: LIST
70516: PUSH
70517: LD_INT 1
70519: NEG
70520: PUSH
70521: LD_INT 2
70523: PUSH
70524: EMPTY
70525: LIST
70526: LIST
70527: PUSH
70528: LD_INT 3
70530: NEG
70531: PUSH
70532: LD_INT 2
70534: NEG
70535: PUSH
70536: EMPTY
70537: LIST
70538: LIST
70539: PUSH
70540: LD_INT 3
70542: NEG
70543: PUSH
70544: LD_INT 3
70546: NEG
70547: PUSH
70548: EMPTY
70549: LIST
70550: LIST
70551: PUSH
70552: EMPTY
70553: LIST
70554: LIST
70555: LIST
70556: LIST
70557: LIST
70558: LIST
70559: LIST
70560: LIST
70561: LIST
70562: LIST
70563: LIST
70564: LIST
70565: LIST
70566: LIST
70567: LIST
70568: LIST
70569: LIST
70570: LIST
70571: LIST
70572: LIST
70573: LIST
70574: LIST
70575: LIST
70576: LIST
70577: LIST
70578: LIST
70579: LIST
70580: LIST
70581: LIST
70582: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
70583: LD_ADDR_VAR 0 43
70587: PUSH
70588: LD_INT 0
70590: PUSH
70591: LD_INT 0
70593: PUSH
70594: EMPTY
70595: LIST
70596: LIST
70597: PUSH
70598: LD_INT 0
70600: PUSH
70601: LD_INT 1
70603: NEG
70604: PUSH
70605: EMPTY
70606: LIST
70607: LIST
70608: PUSH
70609: LD_INT 1
70611: PUSH
70612: LD_INT 0
70614: PUSH
70615: EMPTY
70616: LIST
70617: LIST
70618: PUSH
70619: LD_INT 1
70621: PUSH
70622: LD_INT 1
70624: PUSH
70625: EMPTY
70626: LIST
70627: LIST
70628: PUSH
70629: LD_INT 0
70631: PUSH
70632: LD_INT 1
70634: PUSH
70635: EMPTY
70636: LIST
70637: LIST
70638: PUSH
70639: LD_INT 1
70641: NEG
70642: PUSH
70643: LD_INT 0
70645: PUSH
70646: EMPTY
70647: LIST
70648: LIST
70649: PUSH
70650: LD_INT 1
70652: NEG
70653: PUSH
70654: LD_INT 1
70656: NEG
70657: PUSH
70658: EMPTY
70659: LIST
70660: LIST
70661: PUSH
70662: LD_INT 1
70664: NEG
70665: PUSH
70666: LD_INT 2
70668: NEG
70669: PUSH
70670: EMPTY
70671: LIST
70672: LIST
70673: PUSH
70674: LD_INT 0
70676: PUSH
70677: LD_INT 2
70679: NEG
70680: PUSH
70681: EMPTY
70682: LIST
70683: LIST
70684: PUSH
70685: LD_INT 1
70687: PUSH
70688: LD_INT 1
70690: NEG
70691: PUSH
70692: EMPTY
70693: LIST
70694: LIST
70695: PUSH
70696: LD_INT 2
70698: PUSH
70699: LD_INT 0
70701: PUSH
70702: EMPTY
70703: LIST
70704: LIST
70705: PUSH
70706: LD_INT 2
70708: PUSH
70709: LD_INT 1
70711: PUSH
70712: EMPTY
70713: LIST
70714: LIST
70715: PUSH
70716: LD_INT 1
70718: PUSH
70719: LD_INT 2
70721: PUSH
70722: EMPTY
70723: LIST
70724: LIST
70725: PUSH
70726: LD_INT 0
70728: PUSH
70729: LD_INT 2
70731: PUSH
70732: EMPTY
70733: LIST
70734: LIST
70735: PUSH
70736: LD_INT 1
70738: NEG
70739: PUSH
70740: LD_INT 1
70742: PUSH
70743: EMPTY
70744: LIST
70745: LIST
70746: PUSH
70747: LD_INT 2
70749: NEG
70750: PUSH
70751: LD_INT 0
70753: PUSH
70754: EMPTY
70755: LIST
70756: LIST
70757: PUSH
70758: LD_INT 2
70760: NEG
70761: PUSH
70762: LD_INT 1
70764: NEG
70765: PUSH
70766: EMPTY
70767: LIST
70768: LIST
70769: PUSH
70770: LD_INT 1
70772: NEG
70773: PUSH
70774: LD_INT 3
70776: NEG
70777: PUSH
70778: EMPTY
70779: LIST
70780: LIST
70781: PUSH
70782: LD_INT 0
70784: PUSH
70785: LD_INT 3
70787: NEG
70788: PUSH
70789: EMPTY
70790: LIST
70791: LIST
70792: PUSH
70793: LD_INT 1
70795: PUSH
70796: LD_INT 2
70798: NEG
70799: PUSH
70800: EMPTY
70801: LIST
70802: LIST
70803: PUSH
70804: LD_INT 2
70806: PUSH
70807: LD_INT 1
70809: NEG
70810: PUSH
70811: EMPTY
70812: LIST
70813: LIST
70814: PUSH
70815: LD_INT 3
70817: PUSH
70818: LD_INT 0
70820: PUSH
70821: EMPTY
70822: LIST
70823: LIST
70824: PUSH
70825: LD_INT 3
70827: PUSH
70828: LD_INT 1
70830: PUSH
70831: EMPTY
70832: LIST
70833: LIST
70834: PUSH
70835: LD_INT 1
70837: PUSH
70838: LD_INT 3
70840: PUSH
70841: EMPTY
70842: LIST
70843: LIST
70844: PUSH
70845: LD_INT 0
70847: PUSH
70848: LD_INT 3
70850: PUSH
70851: EMPTY
70852: LIST
70853: LIST
70854: PUSH
70855: LD_INT 1
70857: NEG
70858: PUSH
70859: LD_INT 2
70861: PUSH
70862: EMPTY
70863: LIST
70864: LIST
70865: PUSH
70866: LD_INT 2
70868: NEG
70869: PUSH
70870: LD_INT 1
70872: PUSH
70873: EMPTY
70874: LIST
70875: LIST
70876: PUSH
70877: LD_INT 3
70879: NEG
70880: PUSH
70881: LD_INT 0
70883: PUSH
70884: EMPTY
70885: LIST
70886: LIST
70887: PUSH
70888: LD_INT 3
70890: NEG
70891: PUSH
70892: LD_INT 1
70894: NEG
70895: PUSH
70896: EMPTY
70897: LIST
70898: LIST
70899: PUSH
70900: EMPTY
70901: LIST
70902: LIST
70903: LIST
70904: LIST
70905: LIST
70906: LIST
70907: LIST
70908: LIST
70909: LIST
70910: LIST
70911: LIST
70912: LIST
70913: LIST
70914: LIST
70915: LIST
70916: LIST
70917: LIST
70918: LIST
70919: LIST
70920: LIST
70921: LIST
70922: LIST
70923: LIST
70924: LIST
70925: LIST
70926: LIST
70927: LIST
70928: LIST
70929: LIST
70930: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70931: LD_ADDR_VAR 0 44
70935: PUSH
70936: LD_INT 0
70938: PUSH
70939: LD_INT 0
70941: PUSH
70942: EMPTY
70943: LIST
70944: LIST
70945: PUSH
70946: LD_INT 0
70948: PUSH
70949: LD_INT 1
70951: NEG
70952: PUSH
70953: EMPTY
70954: LIST
70955: LIST
70956: PUSH
70957: LD_INT 1
70959: PUSH
70960: LD_INT 0
70962: PUSH
70963: EMPTY
70964: LIST
70965: LIST
70966: PUSH
70967: LD_INT 1
70969: PUSH
70970: LD_INT 1
70972: PUSH
70973: EMPTY
70974: LIST
70975: LIST
70976: PUSH
70977: LD_INT 0
70979: PUSH
70980: LD_INT 1
70982: PUSH
70983: EMPTY
70984: LIST
70985: LIST
70986: PUSH
70987: LD_INT 1
70989: NEG
70990: PUSH
70991: LD_INT 0
70993: PUSH
70994: EMPTY
70995: LIST
70996: LIST
70997: PUSH
70998: LD_INT 1
71000: NEG
71001: PUSH
71002: LD_INT 1
71004: NEG
71005: PUSH
71006: EMPTY
71007: LIST
71008: LIST
71009: PUSH
71010: LD_INT 1
71012: NEG
71013: PUSH
71014: LD_INT 2
71016: NEG
71017: PUSH
71018: EMPTY
71019: LIST
71020: LIST
71021: PUSH
71022: LD_INT 1
71024: PUSH
71025: LD_INT 1
71027: NEG
71028: PUSH
71029: EMPTY
71030: LIST
71031: LIST
71032: PUSH
71033: LD_INT 2
71035: PUSH
71036: LD_INT 0
71038: PUSH
71039: EMPTY
71040: LIST
71041: LIST
71042: PUSH
71043: LD_INT 2
71045: PUSH
71046: LD_INT 1
71048: PUSH
71049: EMPTY
71050: LIST
71051: LIST
71052: PUSH
71053: LD_INT 2
71055: PUSH
71056: LD_INT 2
71058: PUSH
71059: EMPTY
71060: LIST
71061: LIST
71062: PUSH
71063: LD_INT 1
71065: PUSH
71066: LD_INT 2
71068: PUSH
71069: EMPTY
71070: LIST
71071: LIST
71072: PUSH
71073: LD_INT 1
71075: NEG
71076: PUSH
71077: LD_INT 1
71079: PUSH
71080: EMPTY
71081: LIST
71082: LIST
71083: PUSH
71084: LD_INT 2
71086: NEG
71087: PUSH
71088: LD_INT 0
71090: PUSH
71091: EMPTY
71092: LIST
71093: LIST
71094: PUSH
71095: LD_INT 2
71097: NEG
71098: PUSH
71099: LD_INT 1
71101: NEG
71102: PUSH
71103: EMPTY
71104: LIST
71105: LIST
71106: PUSH
71107: LD_INT 2
71109: NEG
71110: PUSH
71111: LD_INT 2
71113: NEG
71114: PUSH
71115: EMPTY
71116: LIST
71117: LIST
71118: PUSH
71119: LD_INT 2
71121: NEG
71122: PUSH
71123: LD_INT 3
71125: NEG
71126: PUSH
71127: EMPTY
71128: LIST
71129: LIST
71130: PUSH
71131: LD_INT 2
71133: PUSH
71134: LD_INT 1
71136: NEG
71137: PUSH
71138: EMPTY
71139: LIST
71140: LIST
71141: PUSH
71142: LD_INT 3
71144: PUSH
71145: LD_INT 0
71147: PUSH
71148: EMPTY
71149: LIST
71150: LIST
71151: PUSH
71152: LD_INT 3
71154: PUSH
71155: LD_INT 1
71157: PUSH
71158: EMPTY
71159: LIST
71160: LIST
71161: PUSH
71162: LD_INT 3
71164: PUSH
71165: LD_INT 2
71167: PUSH
71168: EMPTY
71169: LIST
71170: LIST
71171: PUSH
71172: LD_INT 3
71174: PUSH
71175: LD_INT 3
71177: PUSH
71178: EMPTY
71179: LIST
71180: LIST
71181: PUSH
71182: LD_INT 2
71184: PUSH
71185: LD_INT 3
71187: PUSH
71188: EMPTY
71189: LIST
71190: LIST
71191: PUSH
71192: LD_INT 2
71194: NEG
71195: PUSH
71196: LD_INT 1
71198: PUSH
71199: EMPTY
71200: LIST
71201: LIST
71202: PUSH
71203: LD_INT 3
71205: NEG
71206: PUSH
71207: LD_INT 0
71209: PUSH
71210: EMPTY
71211: LIST
71212: LIST
71213: PUSH
71214: LD_INT 3
71216: NEG
71217: PUSH
71218: LD_INT 1
71220: NEG
71221: PUSH
71222: EMPTY
71223: LIST
71224: LIST
71225: PUSH
71226: LD_INT 3
71228: NEG
71229: PUSH
71230: LD_INT 2
71232: NEG
71233: PUSH
71234: EMPTY
71235: LIST
71236: LIST
71237: PUSH
71238: LD_INT 3
71240: NEG
71241: PUSH
71242: LD_INT 3
71244: NEG
71245: PUSH
71246: EMPTY
71247: LIST
71248: LIST
71249: PUSH
71250: EMPTY
71251: LIST
71252: LIST
71253: LIST
71254: LIST
71255: LIST
71256: LIST
71257: LIST
71258: LIST
71259: LIST
71260: LIST
71261: LIST
71262: LIST
71263: LIST
71264: LIST
71265: LIST
71266: LIST
71267: LIST
71268: LIST
71269: LIST
71270: LIST
71271: LIST
71272: LIST
71273: LIST
71274: LIST
71275: LIST
71276: LIST
71277: LIST
71278: LIST
71279: LIST
71280: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
71281: LD_ADDR_VAR 0 45
71285: PUSH
71286: LD_INT 0
71288: PUSH
71289: LD_INT 0
71291: PUSH
71292: EMPTY
71293: LIST
71294: LIST
71295: PUSH
71296: LD_INT 0
71298: PUSH
71299: LD_INT 1
71301: NEG
71302: PUSH
71303: EMPTY
71304: LIST
71305: LIST
71306: PUSH
71307: LD_INT 1
71309: PUSH
71310: LD_INT 0
71312: PUSH
71313: EMPTY
71314: LIST
71315: LIST
71316: PUSH
71317: LD_INT 1
71319: PUSH
71320: LD_INT 1
71322: PUSH
71323: EMPTY
71324: LIST
71325: LIST
71326: PUSH
71327: LD_INT 0
71329: PUSH
71330: LD_INT 1
71332: PUSH
71333: EMPTY
71334: LIST
71335: LIST
71336: PUSH
71337: LD_INT 1
71339: NEG
71340: PUSH
71341: LD_INT 0
71343: PUSH
71344: EMPTY
71345: LIST
71346: LIST
71347: PUSH
71348: LD_INT 1
71350: NEG
71351: PUSH
71352: LD_INT 1
71354: NEG
71355: PUSH
71356: EMPTY
71357: LIST
71358: LIST
71359: PUSH
71360: LD_INT 1
71362: NEG
71363: PUSH
71364: LD_INT 2
71366: NEG
71367: PUSH
71368: EMPTY
71369: LIST
71370: LIST
71371: PUSH
71372: LD_INT 0
71374: PUSH
71375: LD_INT 2
71377: NEG
71378: PUSH
71379: EMPTY
71380: LIST
71381: LIST
71382: PUSH
71383: LD_INT 1
71385: PUSH
71386: LD_INT 1
71388: NEG
71389: PUSH
71390: EMPTY
71391: LIST
71392: LIST
71393: PUSH
71394: LD_INT 2
71396: PUSH
71397: LD_INT 1
71399: PUSH
71400: EMPTY
71401: LIST
71402: LIST
71403: PUSH
71404: LD_INT 2
71406: PUSH
71407: LD_INT 2
71409: PUSH
71410: EMPTY
71411: LIST
71412: LIST
71413: PUSH
71414: LD_INT 1
71416: PUSH
71417: LD_INT 2
71419: PUSH
71420: EMPTY
71421: LIST
71422: LIST
71423: PUSH
71424: LD_INT 0
71426: PUSH
71427: LD_INT 2
71429: PUSH
71430: EMPTY
71431: LIST
71432: LIST
71433: PUSH
71434: LD_INT 1
71436: NEG
71437: PUSH
71438: LD_INT 1
71440: PUSH
71441: EMPTY
71442: LIST
71443: LIST
71444: PUSH
71445: LD_INT 2
71447: NEG
71448: PUSH
71449: LD_INT 1
71451: NEG
71452: PUSH
71453: EMPTY
71454: LIST
71455: LIST
71456: PUSH
71457: LD_INT 2
71459: NEG
71460: PUSH
71461: LD_INT 2
71463: NEG
71464: PUSH
71465: EMPTY
71466: LIST
71467: LIST
71468: PUSH
71469: LD_INT 2
71471: NEG
71472: PUSH
71473: LD_INT 3
71475: NEG
71476: PUSH
71477: EMPTY
71478: LIST
71479: LIST
71480: PUSH
71481: LD_INT 1
71483: NEG
71484: PUSH
71485: LD_INT 3
71487: NEG
71488: PUSH
71489: EMPTY
71490: LIST
71491: LIST
71492: PUSH
71493: LD_INT 0
71495: PUSH
71496: LD_INT 3
71498: NEG
71499: PUSH
71500: EMPTY
71501: LIST
71502: LIST
71503: PUSH
71504: LD_INT 1
71506: PUSH
71507: LD_INT 2
71509: NEG
71510: PUSH
71511: EMPTY
71512: LIST
71513: LIST
71514: PUSH
71515: LD_INT 3
71517: PUSH
71518: LD_INT 2
71520: PUSH
71521: EMPTY
71522: LIST
71523: LIST
71524: PUSH
71525: LD_INT 3
71527: PUSH
71528: LD_INT 3
71530: PUSH
71531: EMPTY
71532: LIST
71533: LIST
71534: PUSH
71535: LD_INT 2
71537: PUSH
71538: LD_INT 3
71540: PUSH
71541: EMPTY
71542: LIST
71543: LIST
71544: PUSH
71545: LD_INT 1
71547: PUSH
71548: LD_INT 3
71550: PUSH
71551: EMPTY
71552: LIST
71553: LIST
71554: PUSH
71555: LD_INT 0
71557: PUSH
71558: LD_INT 3
71560: PUSH
71561: EMPTY
71562: LIST
71563: LIST
71564: PUSH
71565: LD_INT 1
71567: NEG
71568: PUSH
71569: LD_INT 2
71571: PUSH
71572: EMPTY
71573: LIST
71574: LIST
71575: PUSH
71576: LD_INT 3
71578: NEG
71579: PUSH
71580: LD_INT 2
71582: NEG
71583: PUSH
71584: EMPTY
71585: LIST
71586: LIST
71587: PUSH
71588: LD_INT 3
71590: NEG
71591: PUSH
71592: LD_INT 3
71594: NEG
71595: PUSH
71596: EMPTY
71597: LIST
71598: LIST
71599: PUSH
71600: EMPTY
71601: LIST
71602: LIST
71603: LIST
71604: LIST
71605: LIST
71606: LIST
71607: LIST
71608: LIST
71609: LIST
71610: LIST
71611: LIST
71612: LIST
71613: LIST
71614: LIST
71615: LIST
71616: LIST
71617: LIST
71618: LIST
71619: LIST
71620: LIST
71621: LIST
71622: LIST
71623: LIST
71624: LIST
71625: LIST
71626: LIST
71627: LIST
71628: LIST
71629: LIST
71630: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
71631: LD_ADDR_VAR 0 46
71635: PUSH
71636: LD_INT 0
71638: PUSH
71639: LD_INT 0
71641: PUSH
71642: EMPTY
71643: LIST
71644: LIST
71645: PUSH
71646: LD_INT 0
71648: PUSH
71649: LD_INT 1
71651: NEG
71652: PUSH
71653: EMPTY
71654: LIST
71655: LIST
71656: PUSH
71657: LD_INT 1
71659: PUSH
71660: LD_INT 0
71662: PUSH
71663: EMPTY
71664: LIST
71665: LIST
71666: PUSH
71667: LD_INT 1
71669: PUSH
71670: LD_INT 1
71672: PUSH
71673: EMPTY
71674: LIST
71675: LIST
71676: PUSH
71677: LD_INT 0
71679: PUSH
71680: LD_INT 1
71682: PUSH
71683: EMPTY
71684: LIST
71685: LIST
71686: PUSH
71687: LD_INT 1
71689: NEG
71690: PUSH
71691: LD_INT 0
71693: PUSH
71694: EMPTY
71695: LIST
71696: LIST
71697: PUSH
71698: LD_INT 1
71700: NEG
71701: PUSH
71702: LD_INT 1
71704: NEG
71705: PUSH
71706: EMPTY
71707: LIST
71708: LIST
71709: PUSH
71710: LD_INT 1
71712: NEG
71713: PUSH
71714: LD_INT 2
71716: NEG
71717: PUSH
71718: EMPTY
71719: LIST
71720: LIST
71721: PUSH
71722: LD_INT 0
71724: PUSH
71725: LD_INT 2
71727: NEG
71728: PUSH
71729: EMPTY
71730: LIST
71731: LIST
71732: PUSH
71733: LD_INT 1
71735: PUSH
71736: LD_INT 1
71738: NEG
71739: PUSH
71740: EMPTY
71741: LIST
71742: LIST
71743: PUSH
71744: LD_INT 2
71746: PUSH
71747: LD_INT 0
71749: PUSH
71750: EMPTY
71751: LIST
71752: LIST
71753: PUSH
71754: LD_INT 2
71756: PUSH
71757: LD_INT 1
71759: PUSH
71760: EMPTY
71761: LIST
71762: LIST
71763: PUSH
71764: LD_INT 1
71766: PUSH
71767: LD_INT 2
71769: PUSH
71770: EMPTY
71771: LIST
71772: LIST
71773: PUSH
71774: LD_INT 0
71776: PUSH
71777: LD_INT 2
71779: PUSH
71780: EMPTY
71781: LIST
71782: LIST
71783: PUSH
71784: LD_INT 1
71786: NEG
71787: PUSH
71788: LD_INT 1
71790: PUSH
71791: EMPTY
71792: LIST
71793: LIST
71794: PUSH
71795: LD_INT 2
71797: NEG
71798: PUSH
71799: LD_INT 0
71801: PUSH
71802: EMPTY
71803: LIST
71804: LIST
71805: PUSH
71806: LD_INT 2
71808: NEG
71809: PUSH
71810: LD_INT 1
71812: NEG
71813: PUSH
71814: EMPTY
71815: LIST
71816: LIST
71817: PUSH
71818: LD_INT 1
71820: NEG
71821: PUSH
71822: LD_INT 3
71824: NEG
71825: PUSH
71826: EMPTY
71827: LIST
71828: LIST
71829: PUSH
71830: LD_INT 0
71832: PUSH
71833: LD_INT 3
71835: NEG
71836: PUSH
71837: EMPTY
71838: LIST
71839: LIST
71840: PUSH
71841: LD_INT 1
71843: PUSH
71844: LD_INT 2
71846: NEG
71847: PUSH
71848: EMPTY
71849: LIST
71850: LIST
71851: PUSH
71852: LD_INT 2
71854: PUSH
71855: LD_INT 1
71857: NEG
71858: PUSH
71859: EMPTY
71860: LIST
71861: LIST
71862: PUSH
71863: LD_INT 3
71865: PUSH
71866: LD_INT 0
71868: PUSH
71869: EMPTY
71870: LIST
71871: LIST
71872: PUSH
71873: LD_INT 3
71875: PUSH
71876: LD_INT 1
71878: PUSH
71879: EMPTY
71880: LIST
71881: LIST
71882: PUSH
71883: LD_INT 1
71885: PUSH
71886: LD_INT 3
71888: PUSH
71889: EMPTY
71890: LIST
71891: LIST
71892: PUSH
71893: LD_INT 0
71895: PUSH
71896: LD_INT 3
71898: PUSH
71899: EMPTY
71900: LIST
71901: LIST
71902: PUSH
71903: LD_INT 1
71905: NEG
71906: PUSH
71907: LD_INT 2
71909: PUSH
71910: EMPTY
71911: LIST
71912: LIST
71913: PUSH
71914: LD_INT 2
71916: NEG
71917: PUSH
71918: LD_INT 1
71920: PUSH
71921: EMPTY
71922: LIST
71923: LIST
71924: PUSH
71925: LD_INT 3
71927: NEG
71928: PUSH
71929: LD_INT 0
71931: PUSH
71932: EMPTY
71933: LIST
71934: LIST
71935: PUSH
71936: LD_INT 3
71938: NEG
71939: PUSH
71940: LD_INT 1
71942: NEG
71943: PUSH
71944: EMPTY
71945: LIST
71946: LIST
71947: PUSH
71948: EMPTY
71949: LIST
71950: LIST
71951: LIST
71952: LIST
71953: LIST
71954: LIST
71955: LIST
71956: LIST
71957: LIST
71958: LIST
71959: LIST
71960: LIST
71961: LIST
71962: LIST
71963: LIST
71964: LIST
71965: LIST
71966: LIST
71967: LIST
71968: LIST
71969: LIST
71970: LIST
71971: LIST
71972: LIST
71973: LIST
71974: LIST
71975: LIST
71976: LIST
71977: LIST
71978: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71979: LD_ADDR_VAR 0 47
71983: PUSH
71984: LD_INT 0
71986: PUSH
71987: LD_INT 0
71989: PUSH
71990: EMPTY
71991: LIST
71992: LIST
71993: PUSH
71994: LD_INT 0
71996: PUSH
71997: LD_INT 1
71999: NEG
72000: PUSH
72001: EMPTY
72002: LIST
72003: LIST
72004: PUSH
72005: LD_INT 1
72007: PUSH
72008: LD_INT 0
72010: PUSH
72011: EMPTY
72012: LIST
72013: LIST
72014: PUSH
72015: LD_INT 1
72017: PUSH
72018: LD_INT 1
72020: PUSH
72021: EMPTY
72022: LIST
72023: LIST
72024: PUSH
72025: LD_INT 0
72027: PUSH
72028: LD_INT 1
72030: PUSH
72031: EMPTY
72032: LIST
72033: LIST
72034: PUSH
72035: LD_INT 1
72037: NEG
72038: PUSH
72039: LD_INT 0
72041: PUSH
72042: EMPTY
72043: LIST
72044: LIST
72045: PUSH
72046: LD_INT 1
72048: NEG
72049: PUSH
72050: LD_INT 1
72052: NEG
72053: PUSH
72054: EMPTY
72055: LIST
72056: LIST
72057: PUSH
72058: LD_INT 1
72060: NEG
72061: PUSH
72062: LD_INT 2
72064: NEG
72065: PUSH
72066: EMPTY
72067: LIST
72068: LIST
72069: PUSH
72070: LD_INT 0
72072: PUSH
72073: LD_INT 2
72075: NEG
72076: PUSH
72077: EMPTY
72078: LIST
72079: LIST
72080: PUSH
72081: LD_INT 1
72083: PUSH
72084: LD_INT 1
72086: NEG
72087: PUSH
72088: EMPTY
72089: LIST
72090: LIST
72091: PUSH
72092: LD_INT 2
72094: NEG
72095: PUSH
72096: LD_INT 1
72098: NEG
72099: PUSH
72100: EMPTY
72101: LIST
72102: LIST
72103: PUSH
72104: LD_INT 2
72106: NEG
72107: PUSH
72108: LD_INT 2
72110: NEG
72111: PUSH
72112: EMPTY
72113: LIST
72114: LIST
72115: PUSH
72116: EMPTY
72117: LIST
72118: LIST
72119: LIST
72120: LIST
72121: LIST
72122: LIST
72123: LIST
72124: LIST
72125: LIST
72126: LIST
72127: LIST
72128: LIST
72129: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
72130: LD_ADDR_VAR 0 48
72134: PUSH
72135: LD_INT 0
72137: PUSH
72138: LD_INT 0
72140: PUSH
72141: EMPTY
72142: LIST
72143: LIST
72144: PUSH
72145: LD_INT 0
72147: PUSH
72148: LD_INT 1
72150: NEG
72151: PUSH
72152: EMPTY
72153: LIST
72154: LIST
72155: PUSH
72156: LD_INT 1
72158: PUSH
72159: LD_INT 0
72161: PUSH
72162: EMPTY
72163: LIST
72164: LIST
72165: PUSH
72166: LD_INT 1
72168: PUSH
72169: LD_INT 1
72171: PUSH
72172: EMPTY
72173: LIST
72174: LIST
72175: PUSH
72176: LD_INT 0
72178: PUSH
72179: LD_INT 1
72181: PUSH
72182: EMPTY
72183: LIST
72184: LIST
72185: PUSH
72186: LD_INT 1
72188: NEG
72189: PUSH
72190: LD_INT 0
72192: PUSH
72193: EMPTY
72194: LIST
72195: LIST
72196: PUSH
72197: LD_INT 1
72199: NEG
72200: PUSH
72201: LD_INT 1
72203: NEG
72204: PUSH
72205: EMPTY
72206: LIST
72207: LIST
72208: PUSH
72209: LD_INT 1
72211: NEG
72212: PUSH
72213: LD_INT 2
72215: NEG
72216: PUSH
72217: EMPTY
72218: LIST
72219: LIST
72220: PUSH
72221: LD_INT 0
72223: PUSH
72224: LD_INT 2
72226: NEG
72227: PUSH
72228: EMPTY
72229: LIST
72230: LIST
72231: PUSH
72232: LD_INT 1
72234: PUSH
72235: LD_INT 1
72237: NEG
72238: PUSH
72239: EMPTY
72240: LIST
72241: LIST
72242: PUSH
72243: LD_INT 2
72245: PUSH
72246: LD_INT 0
72248: PUSH
72249: EMPTY
72250: LIST
72251: LIST
72252: PUSH
72253: LD_INT 2
72255: PUSH
72256: LD_INT 1
72258: PUSH
72259: EMPTY
72260: LIST
72261: LIST
72262: PUSH
72263: EMPTY
72264: LIST
72265: LIST
72266: LIST
72267: LIST
72268: LIST
72269: LIST
72270: LIST
72271: LIST
72272: LIST
72273: LIST
72274: LIST
72275: LIST
72276: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
72277: LD_ADDR_VAR 0 49
72281: PUSH
72282: LD_INT 0
72284: PUSH
72285: LD_INT 0
72287: PUSH
72288: EMPTY
72289: LIST
72290: LIST
72291: PUSH
72292: LD_INT 0
72294: PUSH
72295: LD_INT 1
72297: NEG
72298: PUSH
72299: EMPTY
72300: LIST
72301: LIST
72302: PUSH
72303: LD_INT 1
72305: PUSH
72306: LD_INT 0
72308: PUSH
72309: EMPTY
72310: LIST
72311: LIST
72312: PUSH
72313: LD_INT 1
72315: PUSH
72316: LD_INT 1
72318: PUSH
72319: EMPTY
72320: LIST
72321: LIST
72322: PUSH
72323: LD_INT 0
72325: PUSH
72326: LD_INT 1
72328: PUSH
72329: EMPTY
72330: LIST
72331: LIST
72332: PUSH
72333: LD_INT 1
72335: NEG
72336: PUSH
72337: LD_INT 0
72339: PUSH
72340: EMPTY
72341: LIST
72342: LIST
72343: PUSH
72344: LD_INT 1
72346: NEG
72347: PUSH
72348: LD_INT 1
72350: NEG
72351: PUSH
72352: EMPTY
72353: LIST
72354: LIST
72355: PUSH
72356: LD_INT 1
72358: PUSH
72359: LD_INT 1
72361: NEG
72362: PUSH
72363: EMPTY
72364: LIST
72365: LIST
72366: PUSH
72367: LD_INT 2
72369: PUSH
72370: LD_INT 0
72372: PUSH
72373: EMPTY
72374: LIST
72375: LIST
72376: PUSH
72377: LD_INT 2
72379: PUSH
72380: LD_INT 1
72382: PUSH
72383: EMPTY
72384: LIST
72385: LIST
72386: PUSH
72387: LD_INT 2
72389: PUSH
72390: LD_INT 2
72392: PUSH
72393: EMPTY
72394: LIST
72395: LIST
72396: PUSH
72397: LD_INT 1
72399: PUSH
72400: LD_INT 2
72402: PUSH
72403: EMPTY
72404: LIST
72405: LIST
72406: PUSH
72407: EMPTY
72408: LIST
72409: LIST
72410: LIST
72411: LIST
72412: LIST
72413: LIST
72414: LIST
72415: LIST
72416: LIST
72417: LIST
72418: LIST
72419: LIST
72420: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
72421: LD_ADDR_VAR 0 50
72425: PUSH
72426: LD_INT 0
72428: PUSH
72429: LD_INT 0
72431: PUSH
72432: EMPTY
72433: LIST
72434: LIST
72435: PUSH
72436: LD_INT 0
72438: PUSH
72439: LD_INT 1
72441: NEG
72442: PUSH
72443: EMPTY
72444: LIST
72445: LIST
72446: PUSH
72447: LD_INT 1
72449: PUSH
72450: LD_INT 0
72452: PUSH
72453: EMPTY
72454: LIST
72455: LIST
72456: PUSH
72457: LD_INT 1
72459: PUSH
72460: LD_INT 1
72462: PUSH
72463: EMPTY
72464: LIST
72465: LIST
72466: PUSH
72467: LD_INT 0
72469: PUSH
72470: LD_INT 1
72472: PUSH
72473: EMPTY
72474: LIST
72475: LIST
72476: PUSH
72477: LD_INT 1
72479: NEG
72480: PUSH
72481: LD_INT 0
72483: PUSH
72484: EMPTY
72485: LIST
72486: LIST
72487: PUSH
72488: LD_INT 1
72490: NEG
72491: PUSH
72492: LD_INT 1
72494: NEG
72495: PUSH
72496: EMPTY
72497: LIST
72498: LIST
72499: PUSH
72500: LD_INT 2
72502: PUSH
72503: LD_INT 1
72505: PUSH
72506: EMPTY
72507: LIST
72508: LIST
72509: PUSH
72510: LD_INT 2
72512: PUSH
72513: LD_INT 2
72515: PUSH
72516: EMPTY
72517: LIST
72518: LIST
72519: PUSH
72520: LD_INT 1
72522: PUSH
72523: LD_INT 2
72525: PUSH
72526: EMPTY
72527: LIST
72528: LIST
72529: PUSH
72530: LD_INT 0
72532: PUSH
72533: LD_INT 2
72535: PUSH
72536: EMPTY
72537: LIST
72538: LIST
72539: PUSH
72540: LD_INT 1
72542: NEG
72543: PUSH
72544: LD_INT 1
72546: PUSH
72547: EMPTY
72548: LIST
72549: LIST
72550: PUSH
72551: EMPTY
72552: LIST
72553: LIST
72554: LIST
72555: LIST
72556: LIST
72557: LIST
72558: LIST
72559: LIST
72560: LIST
72561: LIST
72562: LIST
72563: LIST
72564: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
72565: LD_ADDR_VAR 0 51
72569: PUSH
72570: LD_INT 0
72572: PUSH
72573: LD_INT 0
72575: PUSH
72576: EMPTY
72577: LIST
72578: LIST
72579: PUSH
72580: LD_INT 0
72582: PUSH
72583: LD_INT 1
72585: NEG
72586: PUSH
72587: EMPTY
72588: LIST
72589: LIST
72590: PUSH
72591: LD_INT 1
72593: PUSH
72594: LD_INT 0
72596: PUSH
72597: EMPTY
72598: LIST
72599: LIST
72600: PUSH
72601: LD_INT 1
72603: PUSH
72604: LD_INT 1
72606: PUSH
72607: EMPTY
72608: LIST
72609: LIST
72610: PUSH
72611: LD_INT 0
72613: PUSH
72614: LD_INT 1
72616: PUSH
72617: EMPTY
72618: LIST
72619: LIST
72620: PUSH
72621: LD_INT 1
72623: NEG
72624: PUSH
72625: LD_INT 0
72627: PUSH
72628: EMPTY
72629: LIST
72630: LIST
72631: PUSH
72632: LD_INT 1
72634: NEG
72635: PUSH
72636: LD_INT 1
72638: NEG
72639: PUSH
72640: EMPTY
72641: LIST
72642: LIST
72643: PUSH
72644: LD_INT 1
72646: PUSH
72647: LD_INT 2
72649: PUSH
72650: EMPTY
72651: LIST
72652: LIST
72653: PUSH
72654: LD_INT 0
72656: PUSH
72657: LD_INT 2
72659: PUSH
72660: EMPTY
72661: LIST
72662: LIST
72663: PUSH
72664: LD_INT 1
72666: NEG
72667: PUSH
72668: LD_INT 1
72670: PUSH
72671: EMPTY
72672: LIST
72673: LIST
72674: PUSH
72675: LD_INT 2
72677: NEG
72678: PUSH
72679: LD_INT 0
72681: PUSH
72682: EMPTY
72683: LIST
72684: LIST
72685: PUSH
72686: LD_INT 2
72688: NEG
72689: PUSH
72690: LD_INT 1
72692: NEG
72693: PUSH
72694: EMPTY
72695: LIST
72696: LIST
72697: PUSH
72698: EMPTY
72699: LIST
72700: LIST
72701: LIST
72702: LIST
72703: LIST
72704: LIST
72705: LIST
72706: LIST
72707: LIST
72708: LIST
72709: LIST
72710: LIST
72711: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72712: LD_ADDR_VAR 0 52
72716: PUSH
72717: LD_INT 0
72719: PUSH
72720: LD_INT 0
72722: PUSH
72723: EMPTY
72724: LIST
72725: LIST
72726: PUSH
72727: LD_INT 0
72729: PUSH
72730: LD_INT 1
72732: NEG
72733: PUSH
72734: EMPTY
72735: LIST
72736: LIST
72737: PUSH
72738: LD_INT 1
72740: PUSH
72741: LD_INT 0
72743: PUSH
72744: EMPTY
72745: LIST
72746: LIST
72747: PUSH
72748: LD_INT 1
72750: PUSH
72751: LD_INT 1
72753: PUSH
72754: EMPTY
72755: LIST
72756: LIST
72757: PUSH
72758: LD_INT 0
72760: PUSH
72761: LD_INT 1
72763: PUSH
72764: EMPTY
72765: LIST
72766: LIST
72767: PUSH
72768: LD_INT 1
72770: NEG
72771: PUSH
72772: LD_INT 0
72774: PUSH
72775: EMPTY
72776: LIST
72777: LIST
72778: PUSH
72779: LD_INT 1
72781: NEG
72782: PUSH
72783: LD_INT 1
72785: NEG
72786: PUSH
72787: EMPTY
72788: LIST
72789: LIST
72790: PUSH
72791: LD_INT 1
72793: NEG
72794: PUSH
72795: LD_INT 2
72797: NEG
72798: PUSH
72799: EMPTY
72800: LIST
72801: LIST
72802: PUSH
72803: LD_INT 1
72805: NEG
72806: PUSH
72807: LD_INT 1
72809: PUSH
72810: EMPTY
72811: LIST
72812: LIST
72813: PUSH
72814: LD_INT 2
72816: NEG
72817: PUSH
72818: LD_INT 0
72820: PUSH
72821: EMPTY
72822: LIST
72823: LIST
72824: PUSH
72825: LD_INT 2
72827: NEG
72828: PUSH
72829: LD_INT 1
72831: NEG
72832: PUSH
72833: EMPTY
72834: LIST
72835: LIST
72836: PUSH
72837: LD_INT 2
72839: NEG
72840: PUSH
72841: LD_INT 2
72843: NEG
72844: PUSH
72845: EMPTY
72846: LIST
72847: LIST
72848: PUSH
72849: EMPTY
72850: LIST
72851: LIST
72852: LIST
72853: LIST
72854: LIST
72855: LIST
72856: LIST
72857: LIST
72858: LIST
72859: LIST
72860: LIST
72861: LIST
72862: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72863: LD_ADDR_VAR 0 53
72867: PUSH
72868: LD_INT 0
72870: PUSH
72871: LD_INT 0
72873: PUSH
72874: EMPTY
72875: LIST
72876: LIST
72877: PUSH
72878: LD_INT 0
72880: PUSH
72881: LD_INT 1
72883: NEG
72884: PUSH
72885: EMPTY
72886: LIST
72887: LIST
72888: PUSH
72889: LD_INT 1
72891: PUSH
72892: LD_INT 0
72894: PUSH
72895: EMPTY
72896: LIST
72897: LIST
72898: PUSH
72899: LD_INT 1
72901: PUSH
72902: LD_INT 1
72904: PUSH
72905: EMPTY
72906: LIST
72907: LIST
72908: PUSH
72909: LD_INT 0
72911: PUSH
72912: LD_INT 1
72914: PUSH
72915: EMPTY
72916: LIST
72917: LIST
72918: PUSH
72919: LD_INT 1
72921: NEG
72922: PUSH
72923: LD_INT 0
72925: PUSH
72926: EMPTY
72927: LIST
72928: LIST
72929: PUSH
72930: LD_INT 1
72932: NEG
72933: PUSH
72934: LD_INT 1
72936: NEG
72937: PUSH
72938: EMPTY
72939: LIST
72940: LIST
72941: PUSH
72942: LD_INT 1
72944: NEG
72945: PUSH
72946: LD_INT 2
72948: NEG
72949: PUSH
72950: EMPTY
72951: LIST
72952: LIST
72953: PUSH
72954: LD_INT 0
72956: PUSH
72957: LD_INT 2
72959: NEG
72960: PUSH
72961: EMPTY
72962: LIST
72963: LIST
72964: PUSH
72965: LD_INT 1
72967: PUSH
72968: LD_INT 1
72970: NEG
72971: PUSH
72972: EMPTY
72973: LIST
72974: LIST
72975: PUSH
72976: LD_INT 2
72978: PUSH
72979: LD_INT 0
72981: PUSH
72982: EMPTY
72983: LIST
72984: LIST
72985: PUSH
72986: LD_INT 2
72988: PUSH
72989: LD_INT 1
72991: PUSH
72992: EMPTY
72993: LIST
72994: LIST
72995: PUSH
72996: LD_INT 2
72998: PUSH
72999: LD_INT 2
73001: PUSH
73002: EMPTY
73003: LIST
73004: LIST
73005: PUSH
73006: LD_INT 1
73008: PUSH
73009: LD_INT 2
73011: PUSH
73012: EMPTY
73013: LIST
73014: LIST
73015: PUSH
73016: LD_INT 0
73018: PUSH
73019: LD_INT 2
73021: PUSH
73022: EMPTY
73023: LIST
73024: LIST
73025: PUSH
73026: LD_INT 1
73028: NEG
73029: PUSH
73030: LD_INT 1
73032: PUSH
73033: EMPTY
73034: LIST
73035: LIST
73036: PUSH
73037: LD_INT 2
73039: NEG
73040: PUSH
73041: LD_INT 0
73043: PUSH
73044: EMPTY
73045: LIST
73046: LIST
73047: PUSH
73048: LD_INT 2
73050: NEG
73051: PUSH
73052: LD_INT 1
73054: NEG
73055: PUSH
73056: EMPTY
73057: LIST
73058: LIST
73059: PUSH
73060: LD_INT 2
73062: NEG
73063: PUSH
73064: LD_INT 2
73066: NEG
73067: PUSH
73068: EMPTY
73069: LIST
73070: LIST
73071: PUSH
73072: EMPTY
73073: LIST
73074: LIST
73075: LIST
73076: LIST
73077: LIST
73078: LIST
73079: LIST
73080: LIST
73081: LIST
73082: LIST
73083: LIST
73084: LIST
73085: LIST
73086: LIST
73087: LIST
73088: LIST
73089: LIST
73090: LIST
73091: LIST
73092: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73093: LD_ADDR_VAR 0 54
73097: PUSH
73098: LD_INT 0
73100: PUSH
73101: LD_INT 0
73103: PUSH
73104: EMPTY
73105: LIST
73106: LIST
73107: PUSH
73108: LD_INT 0
73110: PUSH
73111: LD_INT 1
73113: NEG
73114: PUSH
73115: EMPTY
73116: LIST
73117: LIST
73118: PUSH
73119: LD_INT 1
73121: PUSH
73122: LD_INT 0
73124: PUSH
73125: EMPTY
73126: LIST
73127: LIST
73128: PUSH
73129: LD_INT 1
73131: PUSH
73132: LD_INT 1
73134: PUSH
73135: EMPTY
73136: LIST
73137: LIST
73138: PUSH
73139: LD_INT 0
73141: PUSH
73142: LD_INT 1
73144: PUSH
73145: EMPTY
73146: LIST
73147: LIST
73148: PUSH
73149: LD_INT 1
73151: NEG
73152: PUSH
73153: LD_INT 0
73155: PUSH
73156: EMPTY
73157: LIST
73158: LIST
73159: PUSH
73160: LD_INT 1
73162: NEG
73163: PUSH
73164: LD_INT 1
73166: NEG
73167: PUSH
73168: EMPTY
73169: LIST
73170: LIST
73171: PUSH
73172: LD_INT 1
73174: NEG
73175: PUSH
73176: LD_INT 2
73178: NEG
73179: PUSH
73180: EMPTY
73181: LIST
73182: LIST
73183: PUSH
73184: LD_INT 0
73186: PUSH
73187: LD_INT 2
73189: NEG
73190: PUSH
73191: EMPTY
73192: LIST
73193: LIST
73194: PUSH
73195: LD_INT 1
73197: PUSH
73198: LD_INT 1
73200: NEG
73201: PUSH
73202: EMPTY
73203: LIST
73204: LIST
73205: PUSH
73206: LD_INT 2
73208: PUSH
73209: LD_INT 0
73211: PUSH
73212: EMPTY
73213: LIST
73214: LIST
73215: PUSH
73216: LD_INT 2
73218: PUSH
73219: LD_INT 1
73221: PUSH
73222: EMPTY
73223: LIST
73224: LIST
73225: PUSH
73226: LD_INT 2
73228: PUSH
73229: LD_INT 2
73231: PUSH
73232: EMPTY
73233: LIST
73234: LIST
73235: PUSH
73236: LD_INT 1
73238: PUSH
73239: LD_INT 2
73241: PUSH
73242: EMPTY
73243: LIST
73244: LIST
73245: PUSH
73246: LD_INT 0
73248: PUSH
73249: LD_INT 2
73251: PUSH
73252: EMPTY
73253: LIST
73254: LIST
73255: PUSH
73256: LD_INT 1
73258: NEG
73259: PUSH
73260: LD_INT 1
73262: PUSH
73263: EMPTY
73264: LIST
73265: LIST
73266: PUSH
73267: LD_INT 2
73269: NEG
73270: PUSH
73271: LD_INT 0
73273: PUSH
73274: EMPTY
73275: LIST
73276: LIST
73277: PUSH
73278: LD_INT 2
73280: NEG
73281: PUSH
73282: LD_INT 1
73284: NEG
73285: PUSH
73286: EMPTY
73287: LIST
73288: LIST
73289: PUSH
73290: LD_INT 2
73292: NEG
73293: PUSH
73294: LD_INT 2
73296: NEG
73297: PUSH
73298: EMPTY
73299: LIST
73300: LIST
73301: PUSH
73302: EMPTY
73303: LIST
73304: LIST
73305: LIST
73306: LIST
73307: LIST
73308: LIST
73309: LIST
73310: LIST
73311: LIST
73312: LIST
73313: LIST
73314: LIST
73315: LIST
73316: LIST
73317: LIST
73318: LIST
73319: LIST
73320: LIST
73321: LIST
73322: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73323: LD_ADDR_VAR 0 55
73327: PUSH
73328: LD_INT 0
73330: PUSH
73331: LD_INT 0
73333: PUSH
73334: EMPTY
73335: LIST
73336: LIST
73337: PUSH
73338: LD_INT 0
73340: PUSH
73341: LD_INT 1
73343: NEG
73344: PUSH
73345: EMPTY
73346: LIST
73347: LIST
73348: PUSH
73349: LD_INT 1
73351: PUSH
73352: LD_INT 0
73354: PUSH
73355: EMPTY
73356: LIST
73357: LIST
73358: PUSH
73359: LD_INT 1
73361: PUSH
73362: LD_INT 1
73364: PUSH
73365: EMPTY
73366: LIST
73367: LIST
73368: PUSH
73369: LD_INT 0
73371: PUSH
73372: LD_INT 1
73374: PUSH
73375: EMPTY
73376: LIST
73377: LIST
73378: PUSH
73379: LD_INT 1
73381: NEG
73382: PUSH
73383: LD_INT 0
73385: PUSH
73386: EMPTY
73387: LIST
73388: LIST
73389: PUSH
73390: LD_INT 1
73392: NEG
73393: PUSH
73394: LD_INT 1
73396: NEG
73397: PUSH
73398: EMPTY
73399: LIST
73400: LIST
73401: PUSH
73402: LD_INT 1
73404: NEG
73405: PUSH
73406: LD_INT 2
73408: NEG
73409: PUSH
73410: EMPTY
73411: LIST
73412: LIST
73413: PUSH
73414: LD_INT 0
73416: PUSH
73417: LD_INT 2
73419: NEG
73420: PUSH
73421: EMPTY
73422: LIST
73423: LIST
73424: PUSH
73425: LD_INT 1
73427: PUSH
73428: LD_INT 1
73430: NEG
73431: PUSH
73432: EMPTY
73433: LIST
73434: LIST
73435: PUSH
73436: LD_INT 2
73438: PUSH
73439: LD_INT 0
73441: PUSH
73442: EMPTY
73443: LIST
73444: LIST
73445: PUSH
73446: LD_INT 2
73448: PUSH
73449: LD_INT 1
73451: PUSH
73452: EMPTY
73453: LIST
73454: LIST
73455: PUSH
73456: LD_INT 2
73458: PUSH
73459: LD_INT 2
73461: PUSH
73462: EMPTY
73463: LIST
73464: LIST
73465: PUSH
73466: LD_INT 1
73468: PUSH
73469: LD_INT 2
73471: PUSH
73472: EMPTY
73473: LIST
73474: LIST
73475: PUSH
73476: LD_INT 0
73478: PUSH
73479: LD_INT 2
73481: PUSH
73482: EMPTY
73483: LIST
73484: LIST
73485: PUSH
73486: LD_INT 1
73488: NEG
73489: PUSH
73490: LD_INT 1
73492: PUSH
73493: EMPTY
73494: LIST
73495: LIST
73496: PUSH
73497: LD_INT 2
73499: NEG
73500: PUSH
73501: LD_INT 0
73503: PUSH
73504: EMPTY
73505: LIST
73506: LIST
73507: PUSH
73508: LD_INT 2
73510: NEG
73511: PUSH
73512: LD_INT 1
73514: NEG
73515: PUSH
73516: EMPTY
73517: LIST
73518: LIST
73519: PUSH
73520: LD_INT 2
73522: NEG
73523: PUSH
73524: LD_INT 2
73526: NEG
73527: PUSH
73528: EMPTY
73529: LIST
73530: LIST
73531: PUSH
73532: EMPTY
73533: LIST
73534: LIST
73535: LIST
73536: LIST
73537: LIST
73538: LIST
73539: LIST
73540: LIST
73541: LIST
73542: LIST
73543: LIST
73544: LIST
73545: LIST
73546: LIST
73547: LIST
73548: LIST
73549: LIST
73550: LIST
73551: LIST
73552: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73553: LD_ADDR_VAR 0 56
73557: PUSH
73558: LD_INT 0
73560: PUSH
73561: LD_INT 0
73563: PUSH
73564: EMPTY
73565: LIST
73566: LIST
73567: PUSH
73568: LD_INT 0
73570: PUSH
73571: LD_INT 1
73573: NEG
73574: PUSH
73575: EMPTY
73576: LIST
73577: LIST
73578: PUSH
73579: LD_INT 1
73581: PUSH
73582: LD_INT 0
73584: PUSH
73585: EMPTY
73586: LIST
73587: LIST
73588: PUSH
73589: LD_INT 1
73591: PUSH
73592: LD_INT 1
73594: PUSH
73595: EMPTY
73596: LIST
73597: LIST
73598: PUSH
73599: LD_INT 0
73601: PUSH
73602: LD_INT 1
73604: PUSH
73605: EMPTY
73606: LIST
73607: LIST
73608: PUSH
73609: LD_INT 1
73611: NEG
73612: PUSH
73613: LD_INT 0
73615: PUSH
73616: EMPTY
73617: LIST
73618: LIST
73619: PUSH
73620: LD_INT 1
73622: NEG
73623: PUSH
73624: LD_INT 1
73626: NEG
73627: PUSH
73628: EMPTY
73629: LIST
73630: LIST
73631: PUSH
73632: LD_INT 1
73634: NEG
73635: PUSH
73636: LD_INT 2
73638: NEG
73639: PUSH
73640: EMPTY
73641: LIST
73642: LIST
73643: PUSH
73644: LD_INT 0
73646: PUSH
73647: LD_INT 2
73649: NEG
73650: PUSH
73651: EMPTY
73652: LIST
73653: LIST
73654: PUSH
73655: LD_INT 1
73657: PUSH
73658: LD_INT 1
73660: NEG
73661: PUSH
73662: EMPTY
73663: LIST
73664: LIST
73665: PUSH
73666: LD_INT 2
73668: PUSH
73669: LD_INT 0
73671: PUSH
73672: EMPTY
73673: LIST
73674: LIST
73675: PUSH
73676: LD_INT 2
73678: PUSH
73679: LD_INT 1
73681: PUSH
73682: EMPTY
73683: LIST
73684: LIST
73685: PUSH
73686: LD_INT 2
73688: PUSH
73689: LD_INT 2
73691: PUSH
73692: EMPTY
73693: LIST
73694: LIST
73695: PUSH
73696: LD_INT 1
73698: PUSH
73699: LD_INT 2
73701: PUSH
73702: EMPTY
73703: LIST
73704: LIST
73705: PUSH
73706: LD_INT 0
73708: PUSH
73709: LD_INT 2
73711: PUSH
73712: EMPTY
73713: LIST
73714: LIST
73715: PUSH
73716: LD_INT 1
73718: NEG
73719: PUSH
73720: LD_INT 1
73722: PUSH
73723: EMPTY
73724: LIST
73725: LIST
73726: PUSH
73727: LD_INT 2
73729: NEG
73730: PUSH
73731: LD_INT 0
73733: PUSH
73734: EMPTY
73735: LIST
73736: LIST
73737: PUSH
73738: LD_INT 2
73740: NEG
73741: PUSH
73742: LD_INT 1
73744: NEG
73745: PUSH
73746: EMPTY
73747: LIST
73748: LIST
73749: PUSH
73750: LD_INT 2
73752: NEG
73753: PUSH
73754: LD_INT 2
73756: NEG
73757: PUSH
73758: EMPTY
73759: LIST
73760: LIST
73761: PUSH
73762: EMPTY
73763: LIST
73764: LIST
73765: LIST
73766: LIST
73767: LIST
73768: LIST
73769: LIST
73770: LIST
73771: LIST
73772: LIST
73773: LIST
73774: LIST
73775: LIST
73776: LIST
73777: LIST
73778: LIST
73779: LIST
73780: LIST
73781: LIST
73782: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73783: LD_ADDR_VAR 0 57
73787: PUSH
73788: LD_INT 0
73790: PUSH
73791: LD_INT 0
73793: PUSH
73794: EMPTY
73795: LIST
73796: LIST
73797: PUSH
73798: LD_INT 0
73800: PUSH
73801: LD_INT 1
73803: NEG
73804: PUSH
73805: EMPTY
73806: LIST
73807: LIST
73808: PUSH
73809: LD_INT 1
73811: PUSH
73812: LD_INT 0
73814: PUSH
73815: EMPTY
73816: LIST
73817: LIST
73818: PUSH
73819: LD_INT 1
73821: PUSH
73822: LD_INT 1
73824: PUSH
73825: EMPTY
73826: LIST
73827: LIST
73828: PUSH
73829: LD_INT 0
73831: PUSH
73832: LD_INT 1
73834: PUSH
73835: EMPTY
73836: LIST
73837: LIST
73838: PUSH
73839: LD_INT 1
73841: NEG
73842: PUSH
73843: LD_INT 0
73845: PUSH
73846: EMPTY
73847: LIST
73848: LIST
73849: PUSH
73850: LD_INT 1
73852: NEG
73853: PUSH
73854: LD_INT 1
73856: NEG
73857: PUSH
73858: EMPTY
73859: LIST
73860: LIST
73861: PUSH
73862: LD_INT 1
73864: NEG
73865: PUSH
73866: LD_INT 2
73868: NEG
73869: PUSH
73870: EMPTY
73871: LIST
73872: LIST
73873: PUSH
73874: LD_INT 0
73876: PUSH
73877: LD_INT 2
73879: NEG
73880: PUSH
73881: EMPTY
73882: LIST
73883: LIST
73884: PUSH
73885: LD_INT 1
73887: PUSH
73888: LD_INT 1
73890: NEG
73891: PUSH
73892: EMPTY
73893: LIST
73894: LIST
73895: PUSH
73896: LD_INT 2
73898: PUSH
73899: LD_INT 0
73901: PUSH
73902: EMPTY
73903: LIST
73904: LIST
73905: PUSH
73906: LD_INT 2
73908: PUSH
73909: LD_INT 1
73911: PUSH
73912: EMPTY
73913: LIST
73914: LIST
73915: PUSH
73916: LD_INT 2
73918: PUSH
73919: LD_INT 2
73921: PUSH
73922: EMPTY
73923: LIST
73924: LIST
73925: PUSH
73926: LD_INT 1
73928: PUSH
73929: LD_INT 2
73931: PUSH
73932: EMPTY
73933: LIST
73934: LIST
73935: PUSH
73936: LD_INT 0
73938: PUSH
73939: LD_INT 2
73941: PUSH
73942: EMPTY
73943: LIST
73944: LIST
73945: PUSH
73946: LD_INT 1
73948: NEG
73949: PUSH
73950: LD_INT 1
73952: PUSH
73953: EMPTY
73954: LIST
73955: LIST
73956: PUSH
73957: LD_INT 2
73959: NEG
73960: PUSH
73961: LD_INT 0
73963: PUSH
73964: EMPTY
73965: LIST
73966: LIST
73967: PUSH
73968: LD_INT 2
73970: NEG
73971: PUSH
73972: LD_INT 1
73974: NEG
73975: PUSH
73976: EMPTY
73977: LIST
73978: LIST
73979: PUSH
73980: LD_INT 2
73982: NEG
73983: PUSH
73984: LD_INT 2
73986: NEG
73987: PUSH
73988: EMPTY
73989: LIST
73990: LIST
73991: PUSH
73992: EMPTY
73993: LIST
73994: LIST
73995: LIST
73996: LIST
73997: LIST
73998: LIST
73999: LIST
74000: LIST
74001: LIST
74002: LIST
74003: LIST
74004: LIST
74005: LIST
74006: LIST
74007: LIST
74008: LIST
74009: LIST
74010: LIST
74011: LIST
74012: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74013: LD_ADDR_VAR 0 58
74017: PUSH
74018: LD_INT 0
74020: PUSH
74021: LD_INT 0
74023: PUSH
74024: EMPTY
74025: LIST
74026: LIST
74027: PUSH
74028: LD_INT 0
74030: PUSH
74031: LD_INT 1
74033: NEG
74034: PUSH
74035: EMPTY
74036: LIST
74037: LIST
74038: PUSH
74039: LD_INT 1
74041: PUSH
74042: LD_INT 0
74044: PUSH
74045: EMPTY
74046: LIST
74047: LIST
74048: PUSH
74049: LD_INT 1
74051: PUSH
74052: LD_INT 1
74054: PUSH
74055: EMPTY
74056: LIST
74057: LIST
74058: PUSH
74059: LD_INT 0
74061: PUSH
74062: LD_INT 1
74064: PUSH
74065: EMPTY
74066: LIST
74067: LIST
74068: PUSH
74069: LD_INT 1
74071: NEG
74072: PUSH
74073: LD_INT 0
74075: PUSH
74076: EMPTY
74077: LIST
74078: LIST
74079: PUSH
74080: LD_INT 1
74082: NEG
74083: PUSH
74084: LD_INT 1
74086: NEG
74087: PUSH
74088: EMPTY
74089: LIST
74090: LIST
74091: PUSH
74092: LD_INT 1
74094: NEG
74095: PUSH
74096: LD_INT 2
74098: NEG
74099: PUSH
74100: EMPTY
74101: LIST
74102: LIST
74103: PUSH
74104: LD_INT 0
74106: PUSH
74107: LD_INT 2
74109: NEG
74110: PUSH
74111: EMPTY
74112: LIST
74113: LIST
74114: PUSH
74115: LD_INT 1
74117: PUSH
74118: LD_INT 1
74120: NEG
74121: PUSH
74122: EMPTY
74123: LIST
74124: LIST
74125: PUSH
74126: LD_INT 2
74128: PUSH
74129: LD_INT 0
74131: PUSH
74132: EMPTY
74133: LIST
74134: LIST
74135: PUSH
74136: LD_INT 2
74138: PUSH
74139: LD_INT 1
74141: PUSH
74142: EMPTY
74143: LIST
74144: LIST
74145: PUSH
74146: LD_INT 2
74148: PUSH
74149: LD_INT 2
74151: PUSH
74152: EMPTY
74153: LIST
74154: LIST
74155: PUSH
74156: LD_INT 1
74158: PUSH
74159: LD_INT 2
74161: PUSH
74162: EMPTY
74163: LIST
74164: LIST
74165: PUSH
74166: LD_INT 0
74168: PUSH
74169: LD_INT 2
74171: PUSH
74172: EMPTY
74173: LIST
74174: LIST
74175: PUSH
74176: LD_INT 1
74178: NEG
74179: PUSH
74180: LD_INT 1
74182: PUSH
74183: EMPTY
74184: LIST
74185: LIST
74186: PUSH
74187: LD_INT 2
74189: NEG
74190: PUSH
74191: LD_INT 0
74193: PUSH
74194: EMPTY
74195: LIST
74196: LIST
74197: PUSH
74198: LD_INT 2
74200: NEG
74201: PUSH
74202: LD_INT 1
74204: NEG
74205: PUSH
74206: EMPTY
74207: LIST
74208: LIST
74209: PUSH
74210: LD_INT 2
74212: NEG
74213: PUSH
74214: LD_INT 2
74216: NEG
74217: PUSH
74218: EMPTY
74219: LIST
74220: LIST
74221: PUSH
74222: EMPTY
74223: LIST
74224: LIST
74225: LIST
74226: LIST
74227: LIST
74228: LIST
74229: LIST
74230: LIST
74231: LIST
74232: LIST
74233: LIST
74234: LIST
74235: LIST
74236: LIST
74237: LIST
74238: LIST
74239: LIST
74240: LIST
74241: LIST
74242: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74243: LD_ADDR_VAR 0 59
74247: PUSH
74248: LD_INT 0
74250: PUSH
74251: LD_INT 0
74253: PUSH
74254: EMPTY
74255: LIST
74256: LIST
74257: PUSH
74258: LD_INT 0
74260: PUSH
74261: LD_INT 1
74263: NEG
74264: PUSH
74265: EMPTY
74266: LIST
74267: LIST
74268: PUSH
74269: LD_INT 1
74271: PUSH
74272: LD_INT 0
74274: PUSH
74275: EMPTY
74276: LIST
74277: LIST
74278: PUSH
74279: LD_INT 1
74281: PUSH
74282: LD_INT 1
74284: PUSH
74285: EMPTY
74286: LIST
74287: LIST
74288: PUSH
74289: LD_INT 0
74291: PUSH
74292: LD_INT 1
74294: PUSH
74295: EMPTY
74296: LIST
74297: LIST
74298: PUSH
74299: LD_INT 1
74301: NEG
74302: PUSH
74303: LD_INT 0
74305: PUSH
74306: EMPTY
74307: LIST
74308: LIST
74309: PUSH
74310: LD_INT 1
74312: NEG
74313: PUSH
74314: LD_INT 1
74316: NEG
74317: PUSH
74318: EMPTY
74319: LIST
74320: LIST
74321: PUSH
74322: EMPTY
74323: LIST
74324: LIST
74325: LIST
74326: LIST
74327: LIST
74328: LIST
74329: LIST
74330: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74331: LD_ADDR_VAR 0 60
74335: PUSH
74336: LD_INT 0
74338: PUSH
74339: LD_INT 0
74341: PUSH
74342: EMPTY
74343: LIST
74344: LIST
74345: PUSH
74346: LD_INT 0
74348: PUSH
74349: LD_INT 1
74351: NEG
74352: PUSH
74353: EMPTY
74354: LIST
74355: LIST
74356: PUSH
74357: LD_INT 1
74359: PUSH
74360: LD_INT 0
74362: PUSH
74363: EMPTY
74364: LIST
74365: LIST
74366: PUSH
74367: LD_INT 1
74369: PUSH
74370: LD_INT 1
74372: PUSH
74373: EMPTY
74374: LIST
74375: LIST
74376: PUSH
74377: LD_INT 0
74379: PUSH
74380: LD_INT 1
74382: PUSH
74383: EMPTY
74384: LIST
74385: LIST
74386: PUSH
74387: LD_INT 1
74389: NEG
74390: PUSH
74391: LD_INT 0
74393: PUSH
74394: EMPTY
74395: LIST
74396: LIST
74397: PUSH
74398: LD_INT 1
74400: NEG
74401: PUSH
74402: LD_INT 1
74404: NEG
74405: PUSH
74406: EMPTY
74407: LIST
74408: LIST
74409: PUSH
74410: EMPTY
74411: LIST
74412: LIST
74413: LIST
74414: LIST
74415: LIST
74416: LIST
74417: LIST
74418: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74419: LD_ADDR_VAR 0 61
74423: PUSH
74424: LD_INT 0
74426: PUSH
74427: LD_INT 0
74429: PUSH
74430: EMPTY
74431: LIST
74432: LIST
74433: PUSH
74434: LD_INT 0
74436: PUSH
74437: LD_INT 1
74439: NEG
74440: PUSH
74441: EMPTY
74442: LIST
74443: LIST
74444: PUSH
74445: LD_INT 1
74447: PUSH
74448: LD_INT 0
74450: PUSH
74451: EMPTY
74452: LIST
74453: LIST
74454: PUSH
74455: LD_INT 1
74457: PUSH
74458: LD_INT 1
74460: PUSH
74461: EMPTY
74462: LIST
74463: LIST
74464: PUSH
74465: LD_INT 0
74467: PUSH
74468: LD_INT 1
74470: PUSH
74471: EMPTY
74472: LIST
74473: LIST
74474: PUSH
74475: LD_INT 1
74477: NEG
74478: PUSH
74479: LD_INT 0
74481: PUSH
74482: EMPTY
74483: LIST
74484: LIST
74485: PUSH
74486: LD_INT 1
74488: NEG
74489: PUSH
74490: LD_INT 1
74492: NEG
74493: PUSH
74494: EMPTY
74495: LIST
74496: LIST
74497: PUSH
74498: EMPTY
74499: LIST
74500: LIST
74501: LIST
74502: LIST
74503: LIST
74504: LIST
74505: LIST
74506: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74507: LD_ADDR_VAR 0 62
74511: PUSH
74512: LD_INT 0
74514: PUSH
74515: LD_INT 0
74517: PUSH
74518: EMPTY
74519: LIST
74520: LIST
74521: PUSH
74522: LD_INT 0
74524: PUSH
74525: LD_INT 1
74527: NEG
74528: PUSH
74529: EMPTY
74530: LIST
74531: LIST
74532: PUSH
74533: LD_INT 1
74535: PUSH
74536: LD_INT 0
74538: PUSH
74539: EMPTY
74540: LIST
74541: LIST
74542: PUSH
74543: LD_INT 1
74545: PUSH
74546: LD_INT 1
74548: PUSH
74549: EMPTY
74550: LIST
74551: LIST
74552: PUSH
74553: LD_INT 0
74555: PUSH
74556: LD_INT 1
74558: PUSH
74559: EMPTY
74560: LIST
74561: LIST
74562: PUSH
74563: LD_INT 1
74565: NEG
74566: PUSH
74567: LD_INT 0
74569: PUSH
74570: EMPTY
74571: LIST
74572: LIST
74573: PUSH
74574: LD_INT 1
74576: NEG
74577: PUSH
74578: LD_INT 1
74580: NEG
74581: PUSH
74582: EMPTY
74583: LIST
74584: LIST
74585: PUSH
74586: EMPTY
74587: LIST
74588: LIST
74589: LIST
74590: LIST
74591: LIST
74592: LIST
74593: LIST
74594: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74595: LD_ADDR_VAR 0 63
74599: PUSH
74600: LD_INT 0
74602: PUSH
74603: LD_INT 0
74605: PUSH
74606: EMPTY
74607: LIST
74608: LIST
74609: PUSH
74610: LD_INT 0
74612: PUSH
74613: LD_INT 1
74615: NEG
74616: PUSH
74617: EMPTY
74618: LIST
74619: LIST
74620: PUSH
74621: LD_INT 1
74623: PUSH
74624: LD_INT 0
74626: PUSH
74627: EMPTY
74628: LIST
74629: LIST
74630: PUSH
74631: LD_INT 1
74633: PUSH
74634: LD_INT 1
74636: PUSH
74637: EMPTY
74638: LIST
74639: LIST
74640: PUSH
74641: LD_INT 0
74643: PUSH
74644: LD_INT 1
74646: PUSH
74647: EMPTY
74648: LIST
74649: LIST
74650: PUSH
74651: LD_INT 1
74653: NEG
74654: PUSH
74655: LD_INT 0
74657: PUSH
74658: EMPTY
74659: LIST
74660: LIST
74661: PUSH
74662: LD_INT 1
74664: NEG
74665: PUSH
74666: LD_INT 1
74668: NEG
74669: PUSH
74670: EMPTY
74671: LIST
74672: LIST
74673: PUSH
74674: EMPTY
74675: LIST
74676: LIST
74677: LIST
74678: LIST
74679: LIST
74680: LIST
74681: LIST
74682: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74683: LD_ADDR_VAR 0 64
74687: PUSH
74688: LD_INT 0
74690: PUSH
74691: LD_INT 0
74693: PUSH
74694: EMPTY
74695: LIST
74696: LIST
74697: PUSH
74698: LD_INT 0
74700: PUSH
74701: LD_INT 1
74703: NEG
74704: PUSH
74705: EMPTY
74706: LIST
74707: LIST
74708: PUSH
74709: LD_INT 1
74711: PUSH
74712: LD_INT 0
74714: PUSH
74715: EMPTY
74716: LIST
74717: LIST
74718: PUSH
74719: LD_INT 1
74721: PUSH
74722: LD_INT 1
74724: PUSH
74725: EMPTY
74726: LIST
74727: LIST
74728: PUSH
74729: LD_INT 0
74731: PUSH
74732: LD_INT 1
74734: PUSH
74735: EMPTY
74736: LIST
74737: LIST
74738: PUSH
74739: LD_INT 1
74741: NEG
74742: PUSH
74743: LD_INT 0
74745: PUSH
74746: EMPTY
74747: LIST
74748: LIST
74749: PUSH
74750: LD_INT 1
74752: NEG
74753: PUSH
74754: LD_INT 1
74756: NEG
74757: PUSH
74758: EMPTY
74759: LIST
74760: LIST
74761: PUSH
74762: EMPTY
74763: LIST
74764: LIST
74765: LIST
74766: LIST
74767: LIST
74768: LIST
74769: LIST
74770: ST_TO_ADDR
// end ; 1 :
74771: GO 80668
74773: LD_INT 1
74775: DOUBLE
74776: EQUAL
74777: IFTRUE 74781
74779: GO 77404
74781: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
74782: LD_ADDR_VAR 0 11
74786: PUSH
74787: LD_INT 1
74789: NEG
74790: PUSH
74791: LD_INT 3
74793: NEG
74794: PUSH
74795: EMPTY
74796: LIST
74797: LIST
74798: PUSH
74799: LD_INT 0
74801: PUSH
74802: LD_INT 3
74804: NEG
74805: PUSH
74806: EMPTY
74807: LIST
74808: LIST
74809: PUSH
74810: LD_INT 1
74812: PUSH
74813: LD_INT 2
74815: NEG
74816: PUSH
74817: EMPTY
74818: LIST
74819: LIST
74820: PUSH
74821: EMPTY
74822: LIST
74823: LIST
74824: LIST
74825: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
74826: LD_ADDR_VAR 0 12
74830: PUSH
74831: LD_INT 2
74833: PUSH
74834: LD_INT 1
74836: NEG
74837: PUSH
74838: EMPTY
74839: LIST
74840: LIST
74841: PUSH
74842: LD_INT 3
74844: PUSH
74845: LD_INT 0
74847: PUSH
74848: EMPTY
74849: LIST
74850: LIST
74851: PUSH
74852: LD_INT 3
74854: PUSH
74855: LD_INT 1
74857: PUSH
74858: EMPTY
74859: LIST
74860: LIST
74861: PUSH
74862: EMPTY
74863: LIST
74864: LIST
74865: LIST
74866: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
74867: LD_ADDR_VAR 0 13
74871: PUSH
74872: LD_INT 3
74874: PUSH
74875: LD_INT 2
74877: PUSH
74878: EMPTY
74879: LIST
74880: LIST
74881: PUSH
74882: LD_INT 3
74884: PUSH
74885: LD_INT 3
74887: PUSH
74888: EMPTY
74889: LIST
74890: LIST
74891: PUSH
74892: LD_INT 2
74894: PUSH
74895: LD_INT 3
74897: PUSH
74898: EMPTY
74899: LIST
74900: LIST
74901: PUSH
74902: EMPTY
74903: LIST
74904: LIST
74905: LIST
74906: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
74907: LD_ADDR_VAR 0 14
74911: PUSH
74912: LD_INT 1
74914: PUSH
74915: LD_INT 3
74917: PUSH
74918: EMPTY
74919: LIST
74920: LIST
74921: PUSH
74922: LD_INT 0
74924: PUSH
74925: LD_INT 3
74927: PUSH
74928: EMPTY
74929: LIST
74930: LIST
74931: PUSH
74932: LD_INT 1
74934: NEG
74935: PUSH
74936: LD_INT 2
74938: PUSH
74939: EMPTY
74940: LIST
74941: LIST
74942: PUSH
74943: EMPTY
74944: LIST
74945: LIST
74946: LIST
74947: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74948: LD_ADDR_VAR 0 15
74952: PUSH
74953: LD_INT 2
74955: NEG
74956: PUSH
74957: LD_INT 1
74959: PUSH
74960: EMPTY
74961: LIST
74962: LIST
74963: PUSH
74964: LD_INT 3
74966: NEG
74967: PUSH
74968: LD_INT 0
74970: PUSH
74971: EMPTY
74972: LIST
74973: LIST
74974: PUSH
74975: LD_INT 3
74977: NEG
74978: PUSH
74979: LD_INT 1
74981: NEG
74982: PUSH
74983: EMPTY
74984: LIST
74985: LIST
74986: PUSH
74987: EMPTY
74988: LIST
74989: LIST
74990: LIST
74991: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74992: LD_ADDR_VAR 0 16
74996: PUSH
74997: LD_INT 2
74999: NEG
75000: PUSH
75001: LD_INT 3
75003: NEG
75004: PUSH
75005: EMPTY
75006: LIST
75007: LIST
75008: PUSH
75009: LD_INT 3
75011: NEG
75012: PUSH
75013: LD_INT 2
75015: NEG
75016: PUSH
75017: EMPTY
75018: LIST
75019: LIST
75020: PUSH
75021: LD_INT 3
75023: NEG
75024: PUSH
75025: LD_INT 3
75027: NEG
75028: PUSH
75029: EMPTY
75030: LIST
75031: LIST
75032: PUSH
75033: EMPTY
75034: LIST
75035: LIST
75036: LIST
75037: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
75038: LD_ADDR_VAR 0 17
75042: PUSH
75043: LD_INT 1
75045: NEG
75046: PUSH
75047: LD_INT 3
75049: NEG
75050: PUSH
75051: EMPTY
75052: LIST
75053: LIST
75054: PUSH
75055: LD_INT 0
75057: PUSH
75058: LD_INT 3
75060: NEG
75061: PUSH
75062: EMPTY
75063: LIST
75064: LIST
75065: PUSH
75066: LD_INT 1
75068: PUSH
75069: LD_INT 2
75071: NEG
75072: PUSH
75073: EMPTY
75074: LIST
75075: LIST
75076: PUSH
75077: EMPTY
75078: LIST
75079: LIST
75080: LIST
75081: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
75082: LD_ADDR_VAR 0 18
75086: PUSH
75087: LD_INT 2
75089: PUSH
75090: LD_INT 1
75092: NEG
75093: PUSH
75094: EMPTY
75095: LIST
75096: LIST
75097: PUSH
75098: LD_INT 3
75100: PUSH
75101: LD_INT 0
75103: PUSH
75104: EMPTY
75105: LIST
75106: LIST
75107: PUSH
75108: LD_INT 3
75110: PUSH
75111: LD_INT 1
75113: PUSH
75114: EMPTY
75115: LIST
75116: LIST
75117: PUSH
75118: EMPTY
75119: LIST
75120: LIST
75121: LIST
75122: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
75123: LD_ADDR_VAR 0 19
75127: PUSH
75128: LD_INT 3
75130: PUSH
75131: LD_INT 2
75133: PUSH
75134: EMPTY
75135: LIST
75136: LIST
75137: PUSH
75138: LD_INT 3
75140: PUSH
75141: LD_INT 3
75143: PUSH
75144: EMPTY
75145: LIST
75146: LIST
75147: PUSH
75148: LD_INT 2
75150: PUSH
75151: LD_INT 3
75153: PUSH
75154: EMPTY
75155: LIST
75156: LIST
75157: PUSH
75158: EMPTY
75159: LIST
75160: LIST
75161: LIST
75162: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
75163: LD_ADDR_VAR 0 20
75167: PUSH
75168: LD_INT 1
75170: PUSH
75171: LD_INT 3
75173: PUSH
75174: EMPTY
75175: LIST
75176: LIST
75177: PUSH
75178: LD_INT 0
75180: PUSH
75181: LD_INT 3
75183: PUSH
75184: EMPTY
75185: LIST
75186: LIST
75187: PUSH
75188: LD_INT 1
75190: NEG
75191: PUSH
75192: LD_INT 2
75194: PUSH
75195: EMPTY
75196: LIST
75197: LIST
75198: PUSH
75199: EMPTY
75200: LIST
75201: LIST
75202: LIST
75203: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
75204: LD_ADDR_VAR 0 21
75208: PUSH
75209: LD_INT 2
75211: NEG
75212: PUSH
75213: LD_INT 1
75215: PUSH
75216: EMPTY
75217: LIST
75218: LIST
75219: PUSH
75220: LD_INT 3
75222: NEG
75223: PUSH
75224: LD_INT 0
75226: PUSH
75227: EMPTY
75228: LIST
75229: LIST
75230: PUSH
75231: LD_INT 3
75233: NEG
75234: PUSH
75235: LD_INT 1
75237: NEG
75238: PUSH
75239: EMPTY
75240: LIST
75241: LIST
75242: PUSH
75243: EMPTY
75244: LIST
75245: LIST
75246: LIST
75247: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75248: LD_ADDR_VAR 0 22
75252: PUSH
75253: LD_INT 2
75255: NEG
75256: PUSH
75257: LD_INT 3
75259: NEG
75260: PUSH
75261: EMPTY
75262: LIST
75263: LIST
75264: PUSH
75265: LD_INT 3
75267: NEG
75268: PUSH
75269: LD_INT 2
75271: NEG
75272: PUSH
75273: EMPTY
75274: LIST
75275: LIST
75276: PUSH
75277: LD_INT 3
75279: NEG
75280: PUSH
75281: LD_INT 3
75283: NEG
75284: PUSH
75285: EMPTY
75286: LIST
75287: LIST
75288: PUSH
75289: EMPTY
75290: LIST
75291: LIST
75292: LIST
75293: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
75294: LD_ADDR_VAR 0 23
75298: PUSH
75299: LD_INT 0
75301: PUSH
75302: LD_INT 3
75304: NEG
75305: PUSH
75306: EMPTY
75307: LIST
75308: LIST
75309: PUSH
75310: LD_INT 1
75312: NEG
75313: PUSH
75314: LD_INT 4
75316: NEG
75317: PUSH
75318: EMPTY
75319: LIST
75320: LIST
75321: PUSH
75322: LD_INT 1
75324: PUSH
75325: LD_INT 3
75327: NEG
75328: PUSH
75329: EMPTY
75330: LIST
75331: LIST
75332: PUSH
75333: EMPTY
75334: LIST
75335: LIST
75336: LIST
75337: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
75338: LD_ADDR_VAR 0 24
75342: PUSH
75343: LD_INT 3
75345: PUSH
75346: LD_INT 0
75348: PUSH
75349: EMPTY
75350: LIST
75351: LIST
75352: PUSH
75353: LD_INT 3
75355: PUSH
75356: LD_INT 1
75358: NEG
75359: PUSH
75360: EMPTY
75361: LIST
75362: LIST
75363: PUSH
75364: LD_INT 4
75366: PUSH
75367: LD_INT 1
75369: PUSH
75370: EMPTY
75371: LIST
75372: LIST
75373: PUSH
75374: EMPTY
75375: LIST
75376: LIST
75377: LIST
75378: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
75379: LD_ADDR_VAR 0 25
75383: PUSH
75384: LD_INT 3
75386: PUSH
75387: LD_INT 3
75389: PUSH
75390: EMPTY
75391: LIST
75392: LIST
75393: PUSH
75394: LD_INT 4
75396: PUSH
75397: LD_INT 3
75399: PUSH
75400: EMPTY
75401: LIST
75402: LIST
75403: PUSH
75404: LD_INT 3
75406: PUSH
75407: LD_INT 4
75409: PUSH
75410: EMPTY
75411: LIST
75412: LIST
75413: PUSH
75414: EMPTY
75415: LIST
75416: LIST
75417: LIST
75418: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
75419: LD_ADDR_VAR 0 26
75423: PUSH
75424: LD_INT 0
75426: PUSH
75427: LD_INT 3
75429: PUSH
75430: EMPTY
75431: LIST
75432: LIST
75433: PUSH
75434: LD_INT 1
75436: PUSH
75437: LD_INT 4
75439: PUSH
75440: EMPTY
75441: LIST
75442: LIST
75443: PUSH
75444: LD_INT 1
75446: NEG
75447: PUSH
75448: LD_INT 3
75450: PUSH
75451: EMPTY
75452: LIST
75453: LIST
75454: PUSH
75455: EMPTY
75456: LIST
75457: LIST
75458: LIST
75459: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
75460: LD_ADDR_VAR 0 27
75464: PUSH
75465: LD_INT 3
75467: NEG
75468: PUSH
75469: LD_INT 0
75471: PUSH
75472: EMPTY
75473: LIST
75474: LIST
75475: PUSH
75476: LD_INT 3
75478: NEG
75479: PUSH
75480: LD_INT 1
75482: PUSH
75483: EMPTY
75484: LIST
75485: LIST
75486: PUSH
75487: LD_INT 4
75489: NEG
75490: PUSH
75491: LD_INT 1
75493: NEG
75494: PUSH
75495: EMPTY
75496: LIST
75497: LIST
75498: PUSH
75499: EMPTY
75500: LIST
75501: LIST
75502: LIST
75503: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
75504: LD_ADDR_VAR 0 28
75508: PUSH
75509: LD_INT 3
75511: NEG
75512: PUSH
75513: LD_INT 3
75515: NEG
75516: PUSH
75517: EMPTY
75518: LIST
75519: LIST
75520: PUSH
75521: LD_INT 3
75523: NEG
75524: PUSH
75525: LD_INT 4
75527: NEG
75528: PUSH
75529: EMPTY
75530: LIST
75531: LIST
75532: PUSH
75533: LD_INT 4
75535: NEG
75536: PUSH
75537: LD_INT 3
75539: NEG
75540: PUSH
75541: EMPTY
75542: LIST
75543: LIST
75544: PUSH
75545: EMPTY
75546: LIST
75547: LIST
75548: LIST
75549: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
75550: LD_ADDR_VAR 0 29
75554: PUSH
75555: LD_INT 1
75557: NEG
75558: PUSH
75559: LD_INT 3
75561: NEG
75562: PUSH
75563: EMPTY
75564: LIST
75565: LIST
75566: PUSH
75567: LD_INT 0
75569: PUSH
75570: LD_INT 3
75572: NEG
75573: PUSH
75574: EMPTY
75575: LIST
75576: LIST
75577: PUSH
75578: LD_INT 1
75580: PUSH
75581: LD_INT 2
75583: NEG
75584: PUSH
75585: EMPTY
75586: LIST
75587: LIST
75588: PUSH
75589: LD_INT 1
75591: NEG
75592: PUSH
75593: LD_INT 4
75595: NEG
75596: PUSH
75597: EMPTY
75598: LIST
75599: LIST
75600: PUSH
75601: LD_INT 0
75603: PUSH
75604: LD_INT 4
75606: NEG
75607: PUSH
75608: EMPTY
75609: LIST
75610: LIST
75611: PUSH
75612: LD_INT 1
75614: PUSH
75615: LD_INT 3
75617: NEG
75618: PUSH
75619: EMPTY
75620: LIST
75621: LIST
75622: PUSH
75623: LD_INT 1
75625: NEG
75626: PUSH
75627: LD_INT 5
75629: NEG
75630: PUSH
75631: EMPTY
75632: LIST
75633: LIST
75634: PUSH
75635: LD_INT 0
75637: PUSH
75638: LD_INT 5
75640: NEG
75641: PUSH
75642: EMPTY
75643: LIST
75644: LIST
75645: PUSH
75646: LD_INT 1
75648: PUSH
75649: LD_INT 4
75651: NEG
75652: PUSH
75653: EMPTY
75654: LIST
75655: LIST
75656: PUSH
75657: LD_INT 1
75659: NEG
75660: PUSH
75661: LD_INT 6
75663: NEG
75664: PUSH
75665: EMPTY
75666: LIST
75667: LIST
75668: PUSH
75669: LD_INT 0
75671: PUSH
75672: LD_INT 6
75674: NEG
75675: PUSH
75676: EMPTY
75677: LIST
75678: LIST
75679: PUSH
75680: LD_INT 1
75682: PUSH
75683: LD_INT 5
75685: NEG
75686: PUSH
75687: EMPTY
75688: LIST
75689: LIST
75690: PUSH
75691: EMPTY
75692: LIST
75693: LIST
75694: LIST
75695: LIST
75696: LIST
75697: LIST
75698: LIST
75699: LIST
75700: LIST
75701: LIST
75702: LIST
75703: LIST
75704: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
75705: LD_ADDR_VAR 0 30
75709: PUSH
75710: LD_INT 2
75712: PUSH
75713: LD_INT 1
75715: NEG
75716: PUSH
75717: EMPTY
75718: LIST
75719: LIST
75720: PUSH
75721: LD_INT 3
75723: PUSH
75724: LD_INT 0
75726: PUSH
75727: EMPTY
75728: LIST
75729: LIST
75730: PUSH
75731: LD_INT 3
75733: PUSH
75734: LD_INT 1
75736: PUSH
75737: EMPTY
75738: LIST
75739: LIST
75740: PUSH
75741: LD_INT 3
75743: PUSH
75744: LD_INT 1
75746: NEG
75747: PUSH
75748: EMPTY
75749: LIST
75750: LIST
75751: PUSH
75752: LD_INT 4
75754: PUSH
75755: LD_INT 0
75757: PUSH
75758: EMPTY
75759: LIST
75760: LIST
75761: PUSH
75762: LD_INT 4
75764: PUSH
75765: LD_INT 1
75767: PUSH
75768: EMPTY
75769: LIST
75770: LIST
75771: PUSH
75772: LD_INT 4
75774: PUSH
75775: LD_INT 1
75777: NEG
75778: PUSH
75779: EMPTY
75780: LIST
75781: LIST
75782: PUSH
75783: LD_INT 5
75785: PUSH
75786: LD_INT 0
75788: PUSH
75789: EMPTY
75790: LIST
75791: LIST
75792: PUSH
75793: LD_INT 5
75795: PUSH
75796: LD_INT 1
75798: PUSH
75799: EMPTY
75800: LIST
75801: LIST
75802: PUSH
75803: LD_INT 5
75805: PUSH
75806: LD_INT 1
75808: NEG
75809: PUSH
75810: EMPTY
75811: LIST
75812: LIST
75813: PUSH
75814: LD_INT 6
75816: PUSH
75817: LD_INT 0
75819: PUSH
75820: EMPTY
75821: LIST
75822: LIST
75823: PUSH
75824: LD_INT 6
75826: PUSH
75827: LD_INT 1
75829: PUSH
75830: EMPTY
75831: LIST
75832: LIST
75833: PUSH
75834: EMPTY
75835: LIST
75836: LIST
75837: LIST
75838: LIST
75839: LIST
75840: LIST
75841: LIST
75842: LIST
75843: LIST
75844: LIST
75845: LIST
75846: LIST
75847: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
75848: LD_ADDR_VAR 0 31
75852: PUSH
75853: LD_INT 3
75855: PUSH
75856: LD_INT 2
75858: PUSH
75859: EMPTY
75860: LIST
75861: LIST
75862: PUSH
75863: LD_INT 3
75865: PUSH
75866: LD_INT 3
75868: PUSH
75869: EMPTY
75870: LIST
75871: LIST
75872: PUSH
75873: LD_INT 2
75875: PUSH
75876: LD_INT 3
75878: PUSH
75879: EMPTY
75880: LIST
75881: LIST
75882: PUSH
75883: LD_INT 4
75885: PUSH
75886: LD_INT 3
75888: PUSH
75889: EMPTY
75890: LIST
75891: LIST
75892: PUSH
75893: LD_INT 4
75895: PUSH
75896: LD_INT 4
75898: PUSH
75899: EMPTY
75900: LIST
75901: LIST
75902: PUSH
75903: LD_INT 3
75905: PUSH
75906: LD_INT 4
75908: PUSH
75909: EMPTY
75910: LIST
75911: LIST
75912: PUSH
75913: LD_INT 5
75915: PUSH
75916: LD_INT 4
75918: PUSH
75919: EMPTY
75920: LIST
75921: LIST
75922: PUSH
75923: LD_INT 5
75925: PUSH
75926: LD_INT 5
75928: PUSH
75929: EMPTY
75930: LIST
75931: LIST
75932: PUSH
75933: LD_INT 4
75935: PUSH
75936: LD_INT 5
75938: PUSH
75939: EMPTY
75940: LIST
75941: LIST
75942: PUSH
75943: LD_INT 6
75945: PUSH
75946: LD_INT 5
75948: PUSH
75949: EMPTY
75950: LIST
75951: LIST
75952: PUSH
75953: LD_INT 6
75955: PUSH
75956: LD_INT 6
75958: PUSH
75959: EMPTY
75960: LIST
75961: LIST
75962: PUSH
75963: LD_INT 5
75965: PUSH
75966: LD_INT 6
75968: PUSH
75969: EMPTY
75970: LIST
75971: LIST
75972: PUSH
75973: EMPTY
75974: LIST
75975: LIST
75976: LIST
75977: LIST
75978: LIST
75979: LIST
75980: LIST
75981: LIST
75982: LIST
75983: LIST
75984: LIST
75985: LIST
75986: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
75987: LD_ADDR_VAR 0 32
75991: PUSH
75992: LD_INT 1
75994: PUSH
75995: LD_INT 3
75997: PUSH
75998: EMPTY
75999: LIST
76000: LIST
76001: PUSH
76002: LD_INT 0
76004: PUSH
76005: LD_INT 3
76007: PUSH
76008: EMPTY
76009: LIST
76010: LIST
76011: PUSH
76012: LD_INT 1
76014: NEG
76015: PUSH
76016: LD_INT 2
76018: PUSH
76019: EMPTY
76020: LIST
76021: LIST
76022: PUSH
76023: LD_INT 1
76025: PUSH
76026: LD_INT 4
76028: PUSH
76029: EMPTY
76030: LIST
76031: LIST
76032: PUSH
76033: LD_INT 0
76035: PUSH
76036: LD_INT 4
76038: PUSH
76039: EMPTY
76040: LIST
76041: LIST
76042: PUSH
76043: LD_INT 1
76045: NEG
76046: PUSH
76047: LD_INT 3
76049: PUSH
76050: EMPTY
76051: LIST
76052: LIST
76053: PUSH
76054: LD_INT 1
76056: PUSH
76057: LD_INT 5
76059: PUSH
76060: EMPTY
76061: LIST
76062: LIST
76063: PUSH
76064: LD_INT 0
76066: PUSH
76067: LD_INT 5
76069: PUSH
76070: EMPTY
76071: LIST
76072: LIST
76073: PUSH
76074: LD_INT 1
76076: NEG
76077: PUSH
76078: LD_INT 4
76080: PUSH
76081: EMPTY
76082: LIST
76083: LIST
76084: PUSH
76085: LD_INT 1
76087: PUSH
76088: LD_INT 6
76090: PUSH
76091: EMPTY
76092: LIST
76093: LIST
76094: PUSH
76095: LD_INT 0
76097: PUSH
76098: LD_INT 6
76100: PUSH
76101: EMPTY
76102: LIST
76103: LIST
76104: PUSH
76105: LD_INT 1
76107: NEG
76108: PUSH
76109: LD_INT 5
76111: PUSH
76112: EMPTY
76113: LIST
76114: LIST
76115: PUSH
76116: EMPTY
76117: LIST
76118: LIST
76119: LIST
76120: LIST
76121: LIST
76122: LIST
76123: LIST
76124: LIST
76125: LIST
76126: LIST
76127: LIST
76128: LIST
76129: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
76130: LD_ADDR_VAR 0 33
76134: PUSH
76135: LD_INT 2
76137: NEG
76138: PUSH
76139: LD_INT 1
76141: PUSH
76142: EMPTY
76143: LIST
76144: LIST
76145: PUSH
76146: LD_INT 3
76148: NEG
76149: PUSH
76150: LD_INT 0
76152: PUSH
76153: EMPTY
76154: LIST
76155: LIST
76156: PUSH
76157: LD_INT 3
76159: NEG
76160: PUSH
76161: LD_INT 1
76163: NEG
76164: PUSH
76165: EMPTY
76166: LIST
76167: LIST
76168: PUSH
76169: LD_INT 3
76171: NEG
76172: PUSH
76173: LD_INT 1
76175: PUSH
76176: EMPTY
76177: LIST
76178: LIST
76179: PUSH
76180: LD_INT 4
76182: NEG
76183: PUSH
76184: LD_INT 0
76186: PUSH
76187: EMPTY
76188: LIST
76189: LIST
76190: PUSH
76191: LD_INT 4
76193: NEG
76194: PUSH
76195: LD_INT 1
76197: NEG
76198: PUSH
76199: EMPTY
76200: LIST
76201: LIST
76202: PUSH
76203: LD_INT 4
76205: NEG
76206: PUSH
76207: LD_INT 1
76209: PUSH
76210: EMPTY
76211: LIST
76212: LIST
76213: PUSH
76214: LD_INT 5
76216: NEG
76217: PUSH
76218: LD_INT 0
76220: PUSH
76221: EMPTY
76222: LIST
76223: LIST
76224: PUSH
76225: LD_INT 5
76227: NEG
76228: PUSH
76229: LD_INT 1
76231: NEG
76232: PUSH
76233: EMPTY
76234: LIST
76235: LIST
76236: PUSH
76237: LD_INT 5
76239: NEG
76240: PUSH
76241: LD_INT 1
76243: PUSH
76244: EMPTY
76245: LIST
76246: LIST
76247: PUSH
76248: LD_INT 6
76250: NEG
76251: PUSH
76252: LD_INT 0
76254: PUSH
76255: EMPTY
76256: LIST
76257: LIST
76258: PUSH
76259: LD_INT 6
76261: NEG
76262: PUSH
76263: LD_INT 1
76265: NEG
76266: PUSH
76267: EMPTY
76268: LIST
76269: LIST
76270: PUSH
76271: EMPTY
76272: LIST
76273: LIST
76274: LIST
76275: LIST
76276: LIST
76277: LIST
76278: LIST
76279: LIST
76280: LIST
76281: LIST
76282: LIST
76283: LIST
76284: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
76285: LD_ADDR_VAR 0 34
76289: PUSH
76290: LD_INT 2
76292: NEG
76293: PUSH
76294: LD_INT 3
76296: NEG
76297: PUSH
76298: EMPTY
76299: LIST
76300: LIST
76301: PUSH
76302: LD_INT 3
76304: NEG
76305: PUSH
76306: LD_INT 2
76308: NEG
76309: PUSH
76310: EMPTY
76311: LIST
76312: LIST
76313: PUSH
76314: LD_INT 3
76316: NEG
76317: PUSH
76318: LD_INT 3
76320: NEG
76321: PUSH
76322: EMPTY
76323: LIST
76324: LIST
76325: PUSH
76326: LD_INT 3
76328: NEG
76329: PUSH
76330: LD_INT 4
76332: NEG
76333: PUSH
76334: EMPTY
76335: LIST
76336: LIST
76337: PUSH
76338: LD_INT 4
76340: NEG
76341: PUSH
76342: LD_INT 3
76344: NEG
76345: PUSH
76346: EMPTY
76347: LIST
76348: LIST
76349: PUSH
76350: LD_INT 4
76352: NEG
76353: PUSH
76354: LD_INT 4
76356: NEG
76357: PUSH
76358: EMPTY
76359: LIST
76360: LIST
76361: PUSH
76362: LD_INT 4
76364: NEG
76365: PUSH
76366: LD_INT 5
76368: NEG
76369: PUSH
76370: EMPTY
76371: LIST
76372: LIST
76373: PUSH
76374: LD_INT 5
76376: NEG
76377: PUSH
76378: LD_INT 4
76380: NEG
76381: PUSH
76382: EMPTY
76383: LIST
76384: LIST
76385: PUSH
76386: LD_INT 5
76388: NEG
76389: PUSH
76390: LD_INT 5
76392: NEG
76393: PUSH
76394: EMPTY
76395: LIST
76396: LIST
76397: PUSH
76398: LD_INT 5
76400: NEG
76401: PUSH
76402: LD_INT 6
76404: NEG
76405: PUSH
76406: EMPTY
76407: LIST
76408: LIST
76409: PUSH
76410: LD_INT 6
76412: NEG
76413: PUSH
76414: LD_INT 5
76416: NEG
76417: PUSH
76418: EMPTY
76419: LIST
76420: LIST
76421: PUSH
76422: LD_INT 6
76424: NEG
76425: PUSH
76426: LD_INT 6
76428: NEG
76429: PUSH
76430: EMPTY
76431: LIST
76432: LIST
76433: PUSH
76434: EMPTY
76435: LIST
76436: LIST
76437: LIST
76438: LIST
76439: LIST
76440: LIST
76441: LIST
76442: LIST
76443: LIST
76444: LIST
76445: LIST
76446: LIST
76447: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
76448: LD_ADDR_VAR 0 41
76452: PUSH
76453: LD_INT 0
76455: PUSH
76456: LD_INT 2
76458: NEG
76459: PUSH
76460: EMPTY
76461: LIST
76462: LIST
76463: PUSH
76464: LD_INT 1
76466: NEG
76467: PUSH
76468: LD_INT 3
76470: NEG
76471: PUSH
76472: EMPTY
76473: LIST
76474: LIST
76475: PUSH
76476: LD_INT 1
76478: PUSH
76479: LD_INT 2
76481: NEG
76482: PUSH
76483: EMPTY
76484: LIST
76485: LIST
76486: PUSH
76487: EMPTY
76488: LIST
76489: LIST
76490: LIST
76491: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
76492: LD_ADDR_VAR 0 42
76496: PUSH
76497: LD_INT 2
76499: PUSH
76500: LD_INT 0
76502: PUSH
76503: EMPTY
76504: LIST
76505: LIST
76506: PUSH
76507: LD_INT 2
76509: PUSH
76510: LD_INT 1
76512: NEG
76513: PUSH
76514: EMPTY
76515: LIST
76516: LIST
76517: PUSH
76518: LD_INT 3
76520: PUSH
76521: LD_INT 1
76523: PUSH
76524: EMPTY
76525: LIST
76526: LIST
76527: PUSH
76528: EMPTY
76529: LIST
76530: LIST
76531: LIST
76532: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
76533: LD_ADDR_VAR 0 43
76537: PUSH
76538: LD_INT 2
76540: PUSH
76541: LD_INT 2
76543: PUSH
76544: EMPTY
76545: LIST
76546: LIST
76547: PUSH
76548: LD_INT 3
76550: PUSH
76551: LD_INT 2
76553: PUSH
76554: EMPTY
76555: LIST
76556: LIST
76557: PUSH
76558: LD_INT 2
76560: PUSH
76561: LD_INT 3
76563: PUSH
76564: EMPTY
76565: LIST
76566: LIST
76567: PUSH
76568: EMPTY
76569: LIST
76570: LIST
76571: LIST
76572: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
76573: LD_ADDR_VAR 0 44
76577: PUSH
76578: LD_INT 0
76580: PUSH
76581: LD_INT 2
76583: PUSH
76584: EMPTY
76585: LIST
76586: LIST
76587: PUSH
76588: LD_INT 1
76590: PUSH
76591: LD_INT 3
76593: PUSH
76594: EMPTY
76595: LIST
76596: LIST
76597: PUSH
76598: LD_INT 1
76600: NEG
76601: PUSH
76602: LD_INT 2
76604: PUSH
76605: EMPTY
76606: LIST
76607: LIST
76608: PUSH
76609: EMPTY
76610: LIST
76611: LIST
76612: LIST
76613: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
76614: LD_ADDR_VAR 0 45
76618: PUSH
76619: LD_INT 2
76621: NEG
76622: PUSH
76623: LD_INT 0
76625: PUSH
76626: EMPTY
76627: LIST
76628: LIST
76629: PUSH
76630: LD_INT 2
76632: NEG
76633: PUSH
76634: LD_INT 1
76636: PUSH
76637: EMPTY
76638: LIST
76639: LIST
76640: PUSH
76641: LD_INT 3
76643: NEG
76644: PUSH
76645: LD_INT 1
76647: NEG
76648: PUSH
76649: EMPTY
76650: LIST
76651: LIST
76652: PUSH
76653: EMPTY
76654: LIST
76655: LIST
76656: LIST
76657: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
76658: LD_ADDR_VAR 0 46
76662: PUSH
76663: LD_INT 2
76665: NEG
76666: PUSH
76667: LD_INT 2
76669: NEG
76670: PUSH
76671: EMPTY
76672: LIST
76673: LIST
76674: PUSH
76675: LD_INT 2
76677: NEG
76678: PUSH
76679: LD_INT 3
76681: NEG
76682: PUSH
76683: EMPTY
76684: LIST
76685: LIST
76686: PUSH
76687: LD_INT 3
76689: NEG
76690: PUSH
76691: LD_INT 2
76693: NEG
76694: PUSH
76695: EMPTY
76696: LIST
76697: LIST
76698: PUSH
76699: EMPTY
76700: LIST
76701: LIST
76702: LIST
76703: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
76704: LD_ADDR_VAR 0 47
76708: PUSH
76709: LD_INT 2
76711: NEG
76712: PUSH
76713: LD_INT 3
76715: NEG
76716: PUSH
76717: EMPTY
76718: LIST
76719: LIST
76720: PUSH
76721: LD_INT 1
76723: NEG
76724: PUSH
76725: LD_INT 3
76727: NEG
76728: PUSH
76729: EMPTY
76730: LIST
76731: LIST
76732: PUSH
76733: EMPTY
76734: LIST
76735: LIST
76736: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
76737: LD_ADDR_VAR 0 48
76741: PUSH
76742: LD_INT 1
76744: PUSH
76745: LD_INT 2
76747: NEG
76748: PUSH
76749: EMPTY
76750: LIST
76751: LIST
76752: PUSH
76753: LD_INT 2
76755: PUSH
76756: LD_INT 1
76758: NEG
76759: PUSH
76760: EMPTY
76761: LIST
76762: LIST
76763: PUSH
76764: EMPTY
76765: LIST
76766: LIST
76767: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
76768: LD_ADDR_VAR 0 49
76772: PUSH
76773: LD_INT 3
76775: PUSH
76776: LD_INT 1
76778: PUSH
76779: EMPTY
76780: LIST
76781: LIST
76782: PUSH
76783: LD_INT 3
76785: PUSH
76786: LD_INT 2
76788: PUSH
76789: EMPTY
76790: LIST
76791: LIST
76792: PUSH
76793: EMPTY
76794: LIST
76795: LIST
76796: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
76797: LD_ADDR_VAR 0 50
76801: PUSH
76802: LD_INT 2
76804: PUSH
76805: LD_INT 3
76807: PUSH
76808: EMPTY
76809: LIST
76810: LIST
76811: PUSH
76812: LD_INT 1
76814: PUSH
76815: LD_INT 3
76817: PUSH
76818: EMPTY
76819: LIST
76820: LIST
76821: PUSH
76822: EMPTY
76823: LIST
76824: LIST
76825: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
76826: LD_ADDR_VAR 0 51
76830: PUSH
76831: LD_INT 1
76833: NEG
76834: PUSH
76835: LD_INT 2
76837: PUSH
76838: EMPTY
76839: LIST
76840: LIST
76841: PUSH
76842: LD_INT 2
76844: NEG
76845: PUSH
76846: LD_INT 1
76848: PUSH
76849: EMPTY
76850: LIST
76851: LIST
76852: PUSH
76853: EMPTY
76854: LIST
76855: LIST
76856: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
76857: LD_ADDR_VAR 0 52
76861: PUSH
76862: LD_INT 3
76864: NEG
76865: PUSH
76866: LD_INT 1
76868: NEG
76869: PUSH
76870: EMPTY
76871: LIST
76872: LIST
76873: PUSH
76874: LD_INT 3
76876: NEG
76877: PUSH
76878: LD_INT 2
76880: NEG
76881: PUSH
76882: EMPTY
76883: LIST
76884: LIST
76885: PUSH
76886: EMPTY
76887: LIST
76888: LIST
76889: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
76890: LD_ADDR_VAR 0 53
76894: PUSH
76895: LD_INT 1
76897: NEG
76898: PUSH
76899: LD_INT 3
76901: NEG
76902: PUSH
76903: EMPTY
76904: LIST
76905: LIST
76906: PUSH
76907: LD_INT 0
76909: PUSH
76910: LD_INT 3
76912: NEG
76913: PUSH
76914: EMPTY
76915: LIST
76916: LIST
76917: PUSH
76918: LD_INT 1
76920: PUSH
76921: LD_INT 2
76923: NEG
76924: PUSH
76925: EMPTY
76926: LIST
76927: LIST
76928: PUSH
76929: EMPTY
76930: LIST
76931: LIST
76932: LIST
76933: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
76934: LD_ADDR_VAR 0 54
76938: PUSH
76939: LD_INT 2
76941: PUSH
76942: LD_INT 1
76944: NEG
76945: PUSH
76946: EMPTY
76947: LIST
76948: LIST
76949: PUSH
76950: LD_INT 3
76952: PUSH
76953: LD_INT 0
76955: PUSH
76956: EMPTY
76957: LIST
76958: LIST
76959: PUSH
76960: LD_INT 3
76962: PUSH
76963: LD_INT 1
76965: PUSH
76966: EMPTY
76967: LIST
76968: LIST
76969: PUSH
76970: EMPTY
76971: LIST
76972: LIST
76973: LIST
76974: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
76975: LD_ADDR_VAR 0 55
76979: PUSH
76980: LD_INT 3
76982: PUSH
76983: LD_INT 2
76985: PUSH
76986: EMPTY
76987: LIST
76988: LIST
76989: PUSH
76990: LD_INT 3
76992: PUSH
76993: LD_INT 3
76995: PUSH
76996: EMPTY
76997: LIST
76998: LIST
76999: PUSH
77000: LD_INT 2
77002: PUSH
77003: LD_INT 3
77005: PUSH
77006: EMPTY
77007: LIST
77008: LIST
77009: PUSH
77010: EMPTY
77011: LIST
77012: LIST
77013: LIST
77014: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
77015: LD_ADDR_VAR 0 56
77019: PUSH
77020: LD_INT 1
77022: PUSH
77023: LD_INT 3
77025: PUSH
77026: EMPTY
77027: LIST
77028: LIST
77029: PUSH
77030: LD_INT 0
77032: PUSH
77033: LD_INT 3
77035: PUSH
77036: EMPTY
77037: LIST
77038: LIST
77039: PUSH
77040: LD_INT 1
77042: NEG
77043: PUSH
77044: LD_INT 2
77046: PUSH
77047: EMPTY
77048: LIST
77049: LIST
77050: PUSH
77051: EMPTY
77052: LIST
77053: LIST
77054: LIST
77055: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
77056: LD_ADDR_VAR 0 57
77060: PUSH
77061: LD_INT 2
77063: NEG
77064: PUSH
77065: LD_INT 1
77067: PUSH
77068: EMPTY
77069: LIST
77070: LIST
77071: PUSH
77072: LD_INT 3
77074: NEG
77075: PUSH
77076: LD_INT 0
77078: PUSH
77079: EMPTY
77080: LIST
77081: LIST
77082: PUSH
77083: LD_INT 3
77085: NEG
77086: PUSH
77087: LD_INT 1
77089: NEG
77090: PUSH
77091: EMPTY
77092: LIST
77093: LIST
77094: PUSH
77095: EMPTY
77096: LIST
77097: LIST
77098: LIST
77099: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
77100: LD_ADDR_VAR 0 58
77104: PUSH
77105: LD_INT 2
77107: NEG
77108: PUSH
77109: LD_INT 3
77111: NEG
77112: PUSH
77113: EMPTY
77114: LIST
77115: LIST
77116: PUSH
77117: LD_INT 3
77119: NEG
77120: PUSH
77121: LD_INT 2
77123: NEG
77124: PUSH
77125: EMPTY
77126: LIST
77127: LIST
77128: PUSH
77129: LD_INT 3
77131: NEG
77132: PUSH
77133: LD_INT 3
77135: NEG
77136: PUSH
77137: EMPTY
77138: LIST
77139: LIST
77140: PUSH
77141: EMPTY
77142: LIST
77143: LIST
77144: LIST
77145: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
77146: LD_ADDR_VAR 0 59
77150: PUSH
77151: LD_INT 1
77153: NEG
77154: PUSH
77155: LD_INT 2
77157: NEG
77158: PUSH
77159: EMPTY
77160: LIST
77161: LIST
77162: PUSH
77163: LD_INT 0
77165: PUSH
77166: LD_INT 2
77168: NEG
77169: PUSH
77170: EMPTY
77171: LIST
77172: LIST
77173: PUSH
77174: LD_INT 1
77176: PUSH
77177: LD_INT 1
77179: NEG
77180: PUSH
77181: EMPTY
77182: LIST
77183: LIST
77184: PUSH
77185: EMPTY
77186: LIST
77187: LIST
77188: LIST
77189: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
77190: LD_ADDR_VAR 0 60
77194: PUSH
77195: LD_INT 1
77197: PUSH
77198: LD_INT 1
77200: NEG
77201: PUSH
77202: EMPTY
77203: LIST
77204: LIST
77205: PUSH
77206: LD_INT 2
77208: PUSH
77209: LD_INT 0
77211: PUSH
77212: EMPTY
77213: LIST
77214: LIST
77215: PUSH
77216: LD_INT 2
77218: PUSH
77219: LD_INT 1
77221: PUSH
77222: EMPTY
77223: LIST
77224: LIST
77225: PUSH
77226: EMPTY
77227: LIST
77228: LIST
77229: LIST
77230: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
77231: LD_ADDR_VAR 0 61
77235: PUSH
77236: LD_INT 2
77238: PUSH
77239: LD_INT 1
77241: PUSH
77242: EMPTY
77243: LIST
77244: LIST
77245: PUSH
77246: LD_INT 2
77248: PUSH
77249: LD_INT 2
77251: PUSH
77252: EMPTY
77253: LIST
77254: LIST
77255: PUSH
77256: LD_INT 1
77258: PUSH
77259: LD_INT 2
77261: PUSH
77262: EMPTY
77263: LIST
77264: LIST
77265: PUSH
77266: EMPTY
77267: LIST
77268: LIST
77269: LIST
77270: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
77271: LD_ADDR_VAR 0 62
77275: PUSH
77276: LD_INT 1
77278: PUSH
77279: LD_INT 2
77281: PUSH
77282: EMPTY
77283: LIST
77284: LIST
77285: PUSH
77286: LD_INT 0
77288: PUSH
77289: LD_INT 2
77291: PUSH
77292: EMPTY
77293: LIST
77294: LIST
77295: PUSH
77296: LD_INT 1
77298: NEG
77299: PUSH
77300: LD_INT 1
77302: PUSH
77303: EMPTY
77304: LIST
77305: LIST
77306: PUSH
77307: EMPTY
77308: LIST
77309: LIST
77310: LIST
77311: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
77312: LD_ADDR_VAR 0 63
77316: PUSH
77317: LD_INT 1
77319: NEG
77320: PUSH
77321: LD_INT 1
77323: PUSH
77324: EMPTY
77325: LIST
77326: LIST
77327: PUSH
77328: LD_INT 2
77330: NEG
77331: PUSH
77332: LD_INT 0
77334: PUSH
77335: EMPTY
77336: LIST
77337: LIST
77338: PUSH
77339: LD_INT 2
77341: NEG
77342: PUSH
77343: LD_INT 1
77345: NEG
77346: PUSH
77347: EMPTY
77348: LIST
77349: LIST
77350: PUSH
77351: EMPTY
77352: LIST
77353: LIST
77354: LIST
77355: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77356: LD_ADDR_VAR 0 64
77360: PUSH
77361: LD_INT 1
77363: NEG
77364: PUSH
77365: LD_INT 2
77367: NEG
77368: PUSH
77369: EMPTY
77370: LIST
77371: LIST
77372: PUSH
77373: LD_INT 2
77375: NEG
77376: PUSH
77377: LD_INT 1
77379: NEG
77380: PUSH
77381: EMPTY
77382: LIST
77383: LIST
77384: PUSH
77385: LD_INT 2
77387: NEG
77388: PUSH
77389: LD_INT 2
77391: NEG
77392: PUSH
77393: EMPTY
77394: LIST
77395: LIST
77396: PUSH
77397: EMPTY
77398: LIST
77399: LIST
77400: LIST
77401: ST_TO_ADDR
// end ; 2 :
77402: GO 80668
77404: LD_INT 2
77406: DOUBLE
77407: EQUAL
77408: IFTRUE 77412
77410: GO 80667
77412: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
77413: LD_ADDR_VAR 0 29
77417: PUSH
77418: LD_INT 4
77420: PUSH
77421: LD_INT 0
77423: PUSH
77424: EMPTY
77425: LIST
77426: LIST
77427: PUSH
77428: LD_INT 4
77430: PUSH
77431: LD_INT 1
77433: NEG
77434: PUSH
77435: EMPTY
77436: LIST
77437: LIST
77438: PUSH
77439: LD_INT 5
77441: PUSH
77442: LD_INT 0
77444: PUSH
77445: EMPTY
77446: LIST
77447: LIST
77448: PUSH
77449: LD_INT 5
77451: PUSH
77452: LD_INT 1
77454: PUSH
77455: EMPTY
77456: LIST
77457: LIST
77458: PUSH
77459: LD_INT 4
77461: PUSH
77462: LD_INT 1
77464: PUSH
77465: EMPTY
77466: LIST
77467: LIST
77468: PUSH
77469: LD_INT 3
77471: PUSH
77472: LD_INT 0
77474: PUSH
77475: EMPTY
77476: LIST
77477: LIST
77478: PUSH
77479: LD_INT 3
77481: PUSH
77482: LD_INT 1
77484: NEG
77485: PUSH
77486: EMPTY
77487: LIST
77488: LIST
77489: PUSH
77490: LD_INT 3
77492: PUSH
77493: LD_INT 2
77495: NEG
77496: PUSH
77497: EMPTY
77498: LIST
77499: LIST
77500: PUSH
77501: LD_INT 5
77503: PUSH
77504: LD_INT 2
77506: PUSH
77507: EMPTY
77508: LIST
77509: LIST
77510: PUSH
77511: LD_INT 3
77513: PUSH
77514: LD_INT 3
77516: PUSH
77517: EMPTY
77518: LIST
77519: LIST
77520: PUSH
77521: LD_INT 3
77523: PUSH
77524: LD_INT 2
77526: PUSH
77527: EMPTY
77528: LIST
77529: LIST
77530: PUSH
77531: LD_INT 4
77533: PUSH
77534: LD_INT 3
77536: PUSH
77537: EMPTY
77538: LIST
77539: LIST
77540: PUSH
77541: LD_INT 4
77543: PUSH
77544: LD_INT 4
77546: PUSH
77547: EMPTY
77548: LIST
77549: LIST
77550: PUSH
77551: LD_INT 3
77553: PUSH
77554: LD_INT 4
77556: PUSH
77557: EMPTY
77558: LIST
77559: LIST
77560: PUSH
77561: LD_INT 2
77563: PUSH
77564: LD_INT 3
77566: PUSH
77567: EMPTY
77568: LIST
77569: LIST
77570: PUSH
77571: LD_INT 2
77573: PUSH
77574: LD_INT 2
77576: PUSH
77577: EMPTY
77578: LIST
77579: LIST
77580: PUSH
77581: LD_INT 4
77583: PUSH
77584: LD_INT 2
77586: PUSH
77587: EMPTY
77588: LIST
77589: LIST
77590: PUSH
77591: LD_INT 2
77593: PUSH
77594: LD_INT 4
77596: PUSH
77597: EMPTY
77598: LIST
77599: LIST
77600: PUSH
77601: LD_INT 0
77603: PUSH
77604: LD_INT 4
77606: PUSH
77607: EMPTY
77608: LIST
77609: LIST
77610: PUSH
77611: LD_INT 0
77613: PUSH
77614: LD_INT 3
77616: PUSH
77617: EMPTY
77618: LIST
77619: LIST
77620: PUSH
77621: LD_INT 1
77623: PUSH
77624: LD_INT 4
77626: PUSH
77627: EMPTY
77628: LIST
77629: LIST
77630: PUSH
77631: LD_INT 1
77633: PUSH
77634: LD_INT 5
77636: PUSH
77637: EMPTY
77638: LIST
77639: LIST
77640: PUSH
77641: LD_INT 0
77643: PUSH
77644: LD_INT 5
77646: PUSH
77647: EMPTY
77648: LIST
77649: LIST
77650: PUSH
77651: LD_INT 1
77653: NEG
77654: PUSH
77655: LD_INT 4
77657: PUSH
77658: EMPTY
77659: LIST
77660: LIST
77661: PUSH
77662: LD_INT 1
77664: NEG
77665: PUSH
77666: LD_INT 3
77668: PUSH
77669: EMPTY
77670: LIST
77671: LIST
77672: PUSH
77673: LD_INT 2
77675: PUSH
77676: LD_INT 5
77678: PUSH
77679: EMPTY
77680: LIST
77681: LIST
77682: PUSH
77683: LD_INT 2
77685: NEG
77686: PUSH
77687: LD_INT 3
77689: PUSH
77690: EMPTY
77691: LIST
77692: LIST
77693: PUSH
77694: LD_INT 3
77696: NEG
77697: PUSH
77698: LD_INT 0
77700: PUSH
77701: EMPTY
77702: LIST
77703: LIST
77704: PUSH
77705: LD_INT 3
77707: NEG
77708: PUSH
77709: LD_INT 1
77711: NEG
77712: PUSH
77713: EMPTY
77714: LIST
77715: LIST
77716: PUSH
77717: LD_INT 2
77719: NEG
77720: PUSH
77721: LD_INT 0
77723: PUSH
77724: EMPTY
77725: LIST
77726: LIST
77727: PUSH
77728: LD_INT 2
77730: NEG
77731: PUSH
77732: LD_INT 1
77734: PUSH
77735: EMPTY
77736: LIST
77737: LIST
77738: PUSH
77739: LD_INT 3
77741: NEG
77742: PUSH
77743: LD_INT 1
77745: PUSH
77746: EMPTY
77747: LIST
77748: LIST
77749: PUSH
77750: LD_INT 4
77752: NEG
77753: PUSH
77754: LD_INT 0
77756: PUSH
77757: EMPTY
77758: LIST
77759: LIST
77760: PUSH
77761: LD_INT 4
77763: NEG
77764: PUSH
77765: LD_INT 1
77767: NEG
77768: PUSH
77769: EMPTY
77770: LIST
77771: LIST
77772: PUSH
77773: LD_INT 4
77775: NEG
77776: PUSH
77777: LD_INT 2
77779: NEG
77780: PUSH
77781: EMPTY
77782: LIST
77783: LIST
77784: PUSH
77785: LD_INT 2
77787: NEG
77788: PUSH
77789: LD_INT 2
77791: PUSH
77792: EMPTY
77793: LIST
77794: LIST
77795: PUSH
77796: LD_INT 4
77798: NEG
77799: PUSH
77800: LD_INT 4
77802: NEG
77803: PUSH
77804: EMPTY
77805: LIST
77806: LIST
77807: PUSH
77808: LD_INT 4
77810: NEG
77811: PUSH
77812: LD_INT 5
77814: NEG
77815: PUSH
77816: EMPTY
77817: LIST
77818: LIST
77819: PUSH
77820: LD_INT 3
77822: NEG
77823: PUSH
77824: LD_INT 4
77826: NEG
77827: PUSH
77828: EMPTY
77829: LIST
77830: LIST
77831: PUSH
77832: LD_INT 3
77834: NEG
77835: PUSH
77836: LD_INT 3
77838: NEG
77839: PUSH
77840: EMPTY
77841: LIST
77842: LIST
77843: PUSH
77844: LD_INT 4
77846: NEG
77847: PUSH
77848: LD_INT 3
77850: NEG
77851: PUSH
77852: EMPTY
77853: LIST
77854: LIST
77855: PUSH
77856: LD_INT 5
77858: NEG
77859: PUSH
77860: LD_INT 4
77862: NEG
77863: PUSH
77864: EMPTY
77865: LIST
77866: LIST
77867: PUSH
77868: LD_INT 5
77870: NEG
77871: PUSH
77872: LD_INT 5
77874: NEG
77875: PUSH
77876: EMPTY
77877: LIST
77878: LIST
77879: PUSH
77880: LD_INT 3
77882: NEG
77883: PUSH
77884: LD_INT 5
77886: NEG
77887: PUSH
77888: EMPTY
77889: LIST
77890: LIST
77891: PUSH
77892: LD_INT 5
77894: NEG
77895: PUSH
77896: LD_INT 3
77898: NEG
77899: PUSH
77900: EMPTY
77901: LIST
77902: LIST
77903: PUSH
77904: EMPTY
77905: LIST
77906: LIST
77907: LIST
77908: LIST
77909: LIST
77910: LIST
77911: LIST
77912: LIST
77913: LIST
77914: LIST
77915: LIST
77916: LIST
77917: LIST
77918: LIST
77919: LIST
77920: LIST
77921: LIST
77922: LIST
77923: LIST
77924: LIST
77925: LIST
77926: LIST
77927: LIST
77928: LIST
77929: LIST
77930: LIST
77931: LIST
77932: LIST
77933: LIST
77934: LIST
77935: LIST
77936: LIST
77937: LIST
77938: LIST
77939: LIST
77940: LIST
77941: LIST
77942: LIST
77943: LIST
77944: LIST
77945: LIST
77946: LIST
77947: LIST
77948: LIST
77949: LIST
77950: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
77951: LD_ADDR_VAR 0 30
77955: PUSH
77956: LD_INT 4
77958: PUSH
77959: LD_INT 4
77961: PUSH
77962: EMPTY
77963: LIST
77964: LIST
77965: PUSH
77966: LD_INT 4
77968: PUSH
77969: LD_INT 3
77971: PUSH
77972: EMPTY
77973: LIST
77974: LIST
77975: PUSH
77976: LD_INT 5
77978: PUSH
77979: LD_INT 4
77981: PUSH
77982: EMPTY
77983: LIST
77984: LIST
77985: PUSH
77986: LD_INT 5
77988: PUSH
77989: LD_INT 5
77991: PUSH
77992: EMPTY
77993: LIST
77994: LIST
77995: PUSH
77996: LD_INT 4
77998: PUSH
77999: LD_INT 5
78001: PUSH
78002: EMPTY
78003: LIST
78004: LIST
78005: PUSH
78006: LD_INT 3
78008: PUSH
78009: LD_INT 4
78011: PUSH
78012: EMPTY
78013: LIST
78014: LIST
78015: PUSH
78016: LD_INT 3
78018: PUSH
78019: LD_INT 3
78021: PUSH
78022: EMPTY
78023: LIST
78024: LIST
78025: PUSH
78026: LD_INT 5
78028: PUSH
78029: LD_INT 3
78031: PUSH
78032: EMPTY
78033: LIST
78034: LIST
78035: PUSH
78036: LD_INT 3
78038: PUSH
78039: LD_INT 5
78041: PUSH
78042: EMPTY
78043: LIST
78044: LIST
78045: PUSH
78046: LD_INT 0
78048: PUSH
78049: LD_INT 3
78051: PUSH
78052: EMPTY
78053: LIST
78054: LIST
78055: PUSH
78056: LD_INT 0
78058: PUSH
78059: LD_INT 2
78061: PUSH
78062: EMPTY
78063: LIST
78064: LIST
78065: PUSH
78066: LD_INT 1
78068: PUSH
78069: LD_INT 3
78071: PUSH
78072: EMPTY
78073: LIST
78074: LIST
78075: PUSH
78076: LD_INT 1
78078: PUSH
78079: LD_INT 4
78081: PUSH
78082: EMPTY
78083: LIST
78084: LIST
78085: PUSH
78086: LD_INT 0
78088: PUSH
78089: LD_INT 4
78091: PUSH
78092: EMPTY
78093: LIST
78094: LIST
78095: PUSH
78096: LD_INT 1
78098: NEG
78099: PUSH
78100: LD_INT 3
78102: PUSH
78103: EMPTY
78104: LIST
78105: LIST
78106: PUSH
78107: LD_INT 1
78109: NEG
78110: PUSH
78111: LD_INT 2
78113: PUSH
78114: EMPTY
78115: LIST
78116: LIST
78117: PUSH
78118: LD_INT 2
78120: PUSH
78121: LD_INT 4
78123: PUSH
78124: EMPTY
78125: LIST
78126: LIST
78127: PUSH
78128: LD_INT 2
78130: NEG
78131: PUSH
78132: LD_INT 2
78134: PUSH
78135: EMPTY
78136: LIST
78137: LIST
78138: PUSH
78139: LD_INT 4
78141: NEG
78142: PUSH
78143: LD_INT 0
78145: PUSH
78146: EMPTY
78147: LIST
78148: LIST
78149: PUSH
78150: LD_INT 4
78152: NEG
78153: PUSH
78154: LD_INT 1
78156: NEG
78157: PUSH
78158: EMPTY
78159: LIST
78160: LIST
78161: PUSH
78162: LD_INT 3
78164: NEG
78165: PUSH
78166: LD_INT 0
78168: PUSH
78169: EMPTY
78170: LIST
78171: LIST
78172: PUSH
78173: LD_INT 3
78175: NEG
78176: PUSH
78177: LD_INT 1
78179: PUSH
78180: EMPTY
78181: LIST
78182: LIST
78183: PUSH
78184: LD_INT 4
78186: NEG
78187: PUSH
78188: LD_INT 1
78190: PUSH
78191: EMPTY
78192: LIST
78193: LIST
78194: PUSH
78195: LD_INT 5
78197: NEG
78198: PUSH
78199: LD_INT 0
78201: PUSH
78202: EMPTY
78203: LIST
78204: LIST
78205: PUSH
78206: LD_INT 5
78208: NEG
78209: PUSH
78210: LD_INT 1
78212: NEG
78213: PUSH
78214: EMPTY
78215: LIST
78216: LIST
78217: PUSH
78218: LD_INT 5
78220: NEG
78221: PUSH
78222: LD_INT 2
78224: NEG
78225: PUSH
78226: EMPTY
78227: LIST
78228: LIST
78229: PUSH
78230: LD_INT 3
78232: NEG
78233: PUSH
78234: LD_INT 2
78236: PUSH
78237: EMPTY
78238: LIST
78239: LIST
78240: PUSH
78241: LD_INT 3
78243: NEG
78244: PUSH
78245: LD_INT 3
78247: NEG
78248: PUSH
78249: EMPTY
78250: LIST
78251: LIST
78252: PUSH
78253: LD_INT 3
78255: NEG
78256: PUSH
78257: LD_INT 4
78259: NEG
78260: PUSH
78261: EMPTY
78262: LIST
78263: LIST
78264: PUSH
78265: LD_INT 2
78267: NEG
78268: PUSH
78269: LD_INT 3
78271: NEG
78272: PUSH
78273: EMPTY
78274: LIST
78275: LIST
78276: PUSH
78277: LD_INT 2
78279: NEG
78280: PUSH
78281: LD_INT 2
78283: NEG
78284: PUSH
78285: EMPTY
78286: LIST
78287: LIST
78288: PUSH
78289: LD_INT 3
78291: NEG
78292: PUSH
78293: LD_INT 2
78295: NEG
78296: PUSH
78297: EMPTY
78298: LIST
78299: LIST
78300: PUSH
78301: LD_INT 4
78303: NEG
78304: PUSH
78305: LD_INT 3
78307: NEG
78308: PUSH
78309: EMPTY
78310: LIST
78311: LIST
78312: PUSH
78313: LD_INT 4
78315: NEG
78316: PUSH
78317: LD_INT 4
78319: NEG
78320: PUSH
78321: EMPTY
78322: LIST
78323: LIST
78324: PUSH
78325: LD_INT 2
78327: NEG
78328: PUSH
78329: LD_INT 4
78331: NEG
78332: PUSH
78333: EMPTY
78334: LIST
78335: LIST
78336: PUSH
78337: LD_INT 4
78339: NEG
78340: PUSH
78341: LD_INT 2
78343: NEG
78344: PUSH
78345: EMPTY
78346: LIST
78347: LIST
78348: PUSH
78349: LD_INT 0
78351: PUSH
78352: LD_INT 4
78354: NEG
78355: PUSH
78356: EMPTY
78357: LIST
78358: LIST
78359: PUSH
78360: LD_INT 0
78362: PUSH
78363: LD_INT 5
78365: NEG
78366: PUSH
78367: EMPTY
78368: LIST
78369: LIST
78370: PUSH
78371: LD_INT 1
78373: PUSH
78374: LD_INT 4
78376: NEG
78377: PUSH
78378: EMPTY
78379: LIST
78380: LIST
78381: PUSH
78382: LD_INT 1
78384: PUSH
78385: LD_INT 3
78387: NEG
78388: PUSH
78389: EMPTY
78390: LIST
78391: LIST
78392: PUSH
78393: LD_INT 0
78395: PUSH
78396: LD_INT 3
78398: NEG
78399: PUSH
78400: EMPTY
78401: LIST
78402: LIST
78403: PUSH
78404: LD_INT 1
78406: NEG
78407: PUSH
78408: LD_INT 4
78410: NEG
78411: PUSH
78412: EMPTY
78413: LIST
78414: LIST
78415: PUSH
78416: LD_INT 1
78418: NEG
78419: PUSH
78420: LD_INT 5
78422: NEG
78423: PUSH
78424: EMPTY
78425: LIST
78426: LIST
78427: PUSH
78428: LD_INT 2
78430: PUSH
78431: LD_INT 3
78433: NEG
78434: PUSH
78435: EMPTY
78436: LIST
78437: LIST
78438: PUSH
78439: LD_INT 2
78441: NEG
78442: PUSH
78443: LD_INT 5
78445: NEG
78446: PUSH
78447: EMPTY
78448: LIST
78449: LIST
78450: PUSH
78451: EMPTY
78452: LIST
78453: LIST
78454: LIST
78455: LIST
78456: LIST
78457: LIST
78458: LIST
78459: LIST
78460: LIST
78461: LIST
78462: LIST
78463: LIST
78464: LIST
78465: LIST
78466: LIST
78467: LIST
78468: LIST
78469: LIST
78470: LIST
78471: LIST
78472: LIST
78473: LIST
78474: LIST
78475: LIST
78476: LIST
78477: LIST
78478: LIST
78479: LIST
78480: LIST
78481: LIST
78482: LIST
78483: LIST
78484: LIST
78485: LIST
78486: LIST
78487: LIST
78488: LIST
78489: LIST
78490: LIST
78491: LIST
78492: LIST
78493: LIST
78494: LIST
78495: LIST
78496: LIST
78497: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
78498: LD_ADDR_VAR 0 31
78502: PUSH
78503: LD_INT 0
78505: PUSH
78506: LD_INT 4
78508: PUSH
78509: EMPTY
78510: LIST
78511: LIST
78512: PUSH
78513: LD_INT 0
78515: PUSH
78516: LD_INT 3
78518: PUSH
78519: EMPTY
78520: LIST
78521: LIST
78522: PUSH
78523: LD_INT 1
78525: PUSH
78526: LD_INT 4
78528: PUSH
78529: EMPTY
78530: LIST
78531: LIST
78532: PUSH
78533: LD_INT 1
78535: PUSH
78536: LD_INT 5
78538: PUSH
78539: EMPTY
78540: LIST
78541: LIST
78542: PUSH
78543: LD_INT 0
78545: PUSH
78546: LD_INT 5
78548: PUSH
78549: EMPTY
78550: LIST
78551: LIST
78552: PUSH
78553: LD_INT 1
78555: NEG
78556: PUSH
78557: LD_INT 4
78559: PUSH
78560: EMPTY
78561: LIST
78562: LIST
78563: PUSH
78564: LD_INT 1
78566: NEG
78567: PUSH
78568: LD_INT 3
78570: PUSH
78571: EMPTY
78572: LIST
78573: LIST
78574: PUSH
78575: LD_INT 2
78577: PUSH
78578: LD_INT 5
78580: PUSH
78581: EMPTY
78582: LIST
78583: LIST
78584: PUSH
78585: LD_INT 2
78587: NEG
78588: PUSH
78589: LD_INT 3
78591: PUSH
78592: EMPTY
78593: LIST
78594: LIST
78595: PUSH
78596: LD_INT 3
78598: NEG
78599: PUSH
78600: LD_INT 0
78602: PUSH
78603: EMPTY
78604: LIST
78605: LIST
78606: PUSH
78607: LD_INT 3
78609: NEG
78610: PUSH
78611: LD_INT 1
78613: NEG
78614: PUSH
78615: EMPTY
78616: LIST
78617: LIST
78618: PUSH
78619: LD_INT 2
78621: NEG
78622: PUSH
78623: LD_INT 0
78625: PUSH
78626: EMPTY
78627: LIST
78628: LIST
78629: PUSH
78630: LD_INT 2
78632: NEG
78633: PUSH
78634: LD_INT 1
78636: PUSH
78637: EMPTY
78638: LIST
78639: LIST
78640: PUSH
78641: LD_INT 3
78643: NEG
78644: PUSH
78645: LD_INT 1
78647: PUSH
78648: EMPTY
78649: LIST
78650: LIST
78651: PUSH
78652: LD_INT 4
78654: NEG
78655: PUSH
78656: LD_INT 0
78658: PUSH
78659: EMPTY
78660: LIST
78661: LIST
78662: PUSH
78663: LD_INT 4
78665: NEG
78666: PUSH
78667: LD_INT 1
78669: NEG
78670: PUSH
78671: EMPTY
78672: LIST
78673: LIST
78674: PUSH
78675: LD_INT 4
78677: NEG
78678: PUSH
78679: LD_INT 2
78681: NEG
78682: PUSH
78683: EMPTY
78684: LIST
78685: LIST
78686: PUSH
78687: LD_INT 2
78689: NEG
78690: PUSH
78691: LD_INT 2
78693: PUSH
78694: EMPTY
78695: LIST
78696: LIST
78697: PUSH
78698: LD_INT 4
78700: NEG
78701: PUSH
78702: LD_INT 4
78704: NEG
78705: PUSH
78706: EMPTY
78707: LIST
78708: LIST
78709: PUSH
78710: LD_INT 4
78712: NEG
78713: PUSH
78714: LD_INT 5
78716: NEG
78717: PUSH
78718: EMPTY
78719: LIST
78720: LIST
78721: PUSH
78722: LD_INT 3
78724: NEG
78725: PUSH
78726: LD_INT 4
78728: NEG
78729: PUSH
78730: EMPTY
78731: LIST
78732: LIST
78733: PUSH
78734: LD_INT 3
78736: NEG
78737: PUSH
78738: LD_INT 3
78740: NEG
78741: PUSH
78742: EMPTY
78743: LIST
78744: LIST
78745: PUSH
78746: LD_INT 4
78748: NEG
78749: PUSH
78750: LD_INT 3
78752: NEG
78753: PUSH
78754: EMPTY
78755: LIST
78756: LIST
78757: PUSH
78758: LD_INT 5
78760: NEG
78761: PUSH
78762: LD_INT 4
78764: NEG
78765: PUSH
78766: EMPTY
78767: LIST
78768: LIST
78769: PUSH
78770: LD_INT 5
78772: NEG
78773: PUSH
78774: LD_INT 5
78776: NEG
78777: PUSH
78778: EMPTY
78779: LIST
78780: LIST
78781: PUSH
78782: LD_INT 3
78784: NEG
78785: PUSH
78786: LD_INT 5
78788: NEG
78789: PUSH
78790: EMPTY
78791: LIST
78792: LIST
78793: PUSH
78794: LD_INT 5
78796: NEG
78797: PUSH
78798: LD_INT 3
78800: NEG
78801: PUSH
78802: EMPTY
78803: LIST
78804: LIST
78805: PUSH
78806: LD_INT 0
78808: PUSH
78809: LD_INT 3
78811: NEG
78812: PUSH
78813: EMPTY
78814: LIST
78815: LIST
78816: PUSH
78817: LD_INT 0
78819: PUSH
78820: LD_INT 4
78822: NEG
78823: PUSH
78824: EMPTY
78825: LIST
78826: LIST
78827: PUSH
78828: LD_INT 1
78830: PUSH
78831: LD_INT 3
78833: NEG
78834: PUSH
78835: EMPTY
78836: LIST
78837: LIST
78838: PUSH
78839: LD_INT 1
78841: PUSH
78842: LD_INT 2
78844: NEG
78845: PUSH
78846: EMPTY
78847: LIST
78848: LIST
78849: PUSH
78850: LD_INT 0
78852: PUSH
78853: LD_INT 2
78855: NEG
78856: PUSH
78857: EMPTY
78858: LIST
78859: LIST
78860: PUSH
78861: LD_INT 1
78863: NEG
78864: PUSH
78865: LD_INT 3
78867: NEG
78868: PUSH
78869: EMPTY
78870: LIST
78871: LIST
78872: PUSH
78873: LD_INT 1
78875: NEG
78876: PUSH
78877: LD_INT 4
78879: NEG
78880: PUSH
78881: EMPTY
78882: LIST
78883: LIST
78884: PUSH
78885: LD_INT 2
78887: PUSH
78888: LD_INT 2
78890: NEG
78891: PUSH
78892: EMPTY
78893: LIST
78894: LIST
78895: PUSH
78896: LD_INT 2
78898: NEG
78899: PUSH
78900: LD_INT 4
78902: NEG
78903: PUSH
78904: EMPTY
78905: LIST
78906: LIST
78907: PUSH
78908: LD_INT 4
78910: PUSH
78911: LD_INT 0
78913: PUSH
78914: EMPTY
78915: LIST
78916: LIST
78917: PUSH
78918: LD_INT 4
78920: PUSH
78921: LD_INT 1
78923: NEG
78924: PUSH
78925: EMPTY
78926: LIST
78927: LIST
78928: PUSH
78929: LD_INT 5
78931: PUSH
78932: LD_INT 0
78934: PUSH
78935: EMPTY
78936: LIST
78937: LIST
78938: PUSH
78939: LD_INT 5
78941: PUSH
78942: LD_INT 1
78944: PUSH
78945: EMPTY
78946: LIST
78947: LIST
78948: PUSH
78949: LD_INT 4
78951: PUSH
78952: LD_INT 1
78954: PUSH
78955: EMPTY
78956: LIST
78957: LIST
78958: PUSH
78959: LD_INT 3
78961: PUSH
78962: LD_INT 0
78964: PUSH
78965: EMPTY
78966: LIST
78967: LIST
78968: PUSH
78969: LD_INT 3
78971: PUSH
78972: LD_INT 1
78974: NEG
78975: PUSH
78976: EMPTY
78977: LIST
78978: LIST
78979: PUSH
78980: LD_INT 3
78982: PUSH
78983: LD_INT 2
78985: NEG
78986: PUSH
78987: EMPTY
78988: LIST
78989: LIST
78990: PUSH
78991: LD_INT 5
78993: PUSH
78994: LD_INT 2
78996: PUSH
78997: EMPTY
78998: LIST
78999: LIST
79000: PUSH
79001: EMPTY
79002: LIST
79003: LIST
79004: LIST
79005: LIST
79006: LIST
79007: LIST
79008: LIST
79009: LIST
79010: LIST
79011: LIST
79012: LIST
79013: LIST
79014: LIST
79015: LIST
79016: LIST
79017: LIST
79018: LIST
79019: LIST
79020: LIST
79021: LIST
79022: LIST
79023: LIST
79024: LIST
79025: LIST
79026: LIST
79027: LIST
79028: LIST
79029: LIST
79030: LIST
79031: LIST
79032: LIST
79033: LIST
79034: LIST
79035: LIST
79036: LIST
79037: LIST
79038: LIST
79039: LIST
79040: LIST
79041: LIST
79042: LIST
79043: LIST
79044: LIST
79045: LIST
79046: LIST
79047: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
79048: LD_ADDR_VAR 0 32
79052: PUSH
79053: LD_INT 4
79055: NEG
79056: PUSH
79057: LD_INT 0
79059: PUSH
79060: EMPTY
79061: LIST
79062: LIST
79063: PUSH
79064: LD_INT 4
79066: NEG
79067: PUSH
79068: LD_INT 1
79070: NEG
79071: PUSH
79072: EMPTY
79073: LIST
79074: LIST
79075: PUSH
79076: LD_INT 3
79078: NEG
79079: PUSH
79080: LD_INT 0
79082: PUSH
79083: EMPTY
79084: LIST
79085: LIST
79086: PUSH
79087: LD_INT 3
79089: NEG
79090: PUSH
79091: LD_INT 1
79093: PUSH
79094: EMPTY
79095: LIST
79096: LIST
79097: PUSH
79098: LD_INT 4
79100: NEG
79101: PUSH
79102: LD_INT 1
79104: PUSH
79105: EMPTY
79106: LIST
79107: LIST
79108: PUSH
79109: LD_INT 5
79111: NEG
79112: PUSH
79113: LD_INT 0
79115: PUSH
79116: EMPTY
79117: LIST
79118: LIST
79119: PUSH
79120: LD_INT 5
79122: NEG
79123: PUSH
79124: LD_INT 1
79126: NEG
79127: PUSH
79128: EMPTY
79129: LIST
79130: LIST
79131: PUSH
79132: LD_INT 5
79134: NEG
79135: PUSH
79136: LD_INT 2
79138: NEG
79139: PUSH
79140: EMPTY
79141: LIST
79142: LIST
79143: PUSH
79144: LD_INT 3
79146: NEG
79147: PUSH
79148: LD_INT 2
79150: PUSH
79151: EMPTY
79152: LIST
79153: LIST
79154: PUSH
79155: LD_INT 3
79157: NEG
79158: PUSH
79159: LD_INT 3
79161: NEG
79162: PUSH
79163: EMPTY
79164: LIST
79165: LIST
79166: PUSH
79167: LD_INT 3
79169: NEG
79170: PUSH
79171: LD_INT 4
79173: NEG
79174: PUSH
79175: EMPTY
79176: LIST
79177: LIST
79178: PUSH
79179: LD_INT 2
79181: NEG
79182: PUSH
79183: LD_INT 3
79185: NEG
79186: PUSH
79187: EMPTY
79188: LIST
79189: LIST
79190: PUSH
79191: LD_INT 2
79193: NEG
79194: PUSH
79195: LD_INT 2
79197: NEG
79198: PUSH
79199: EMPTY
79200: LIST
79201: LIST
79202: PUSH
79203: LD_INT 3
79205: NEG
79206: PUSH
79207: LD_INT 2
79209: NEG
79210: PUSH
79211: EMPTY
79212: LIST
79213: LIST
79214: PUSH
79215: LD_INT 4
79217: NEG
79218: PUSH
79219: LD_INT 3
79221: NEG
79222: PUSH
79223: EMPTY
79224: LIST
79225: LIST
79226: PUSH
79227: LD_INT 4
79229: NEG
79230: PUSH
79231: LD_INT 4
79233: NEG
79234: PUSH
79235: EMPTY
79236: LIST
79237: LIST
79238: PUSH
79239: LD_INT 2
79241: NEG
79242: PUSH
79243: LD_INT 4
79245: NEG
79246: PUSH
79247: EMPTY
79248: LIST
79249: LIST
79250: PUSH
79251: LD_INT 4
79253: NEG
79254: PUSH
79255: LD_INT 2
79257: NEG
79258: PUSH
79259: EMPTY
79260: LIST
79261: LIST
79262: PUSH
79263: LD_INT 0
79265: PUSH
79266: LD_INT 4
79268: NEG
79269: PUSH
79270: EMPTY
79271: LIST
79272: LIST
79273: PUSH
79274: LD_INT 0
79276: PUSH
79277: LD_INT 5
79279: NEG
79280: PUSH
79281: EMPTY
79282: LIST
79283: LIST
79284: PUSH
79285: LD_INT 1
79287: PUSH
79288: LD_INT 4
79290: NEG
79291: PUSH
79292: EMPTY
79293: LIST
79294: LIST
79295: PUSH
79296: LD_INT 1
79298: PUSH
79299: LD_INT 3
79301: NEG
79302: PUSH
79303: EMPTY
79304: LIST
79305: LIST
79306: PUSH
79307: LD_INT 0
79309: PUSH
79310: LD_INT 3
79312: NEG
79313: PUSH
79314: EMPTY
79315: LIST
79316: LIST
79317: PUSH
79318: LD_INT 1
79320: NEG
79321: PUSH
79322: LD_INT 4
79324: NEG
79325: PUSH
79326: EMPTY
79327: LIST
79328: LIST
79329: PUSH
79330: LD_INT 1
79332: NEG
79333: PUSH
79334: LD_INT 5
79336: NEG
79337: PUSH
79338: EMPTY
79339: LIST
79340: LIST
79341: PUSH
79342: LD_INT 2
79344: PUSH
79345: LD_INT 3
79347: NEG
79348: PUSH
79349: EMPTY
79350: LIST
79351: LIST
79352: PUSH
79353: LD_INT 2
79355: NEG
79356: PUSH
79357: LD_INT 5
79359: NEG
79360: PUSH
79361: EMPTY
79362: LIST
79363: LIST
79364: PUSH
79365: LD_INT 3
79367: PUSH
79368: LD_INT 0
79370: PUSH
79371: EMPTY
79372: LIST
79373: LIST
79374: PUSH
79375: LD_INT 3
79377: PUSH
79378: LD_INT 1
79380: NEG
79381: PUSH
79382: EMPTY
79383: LIST
79384: LIST
79385: PUSH
79386: LD_INT 4
79388: PUSH
79389: LD_INT 0
79391: PUSH
79392: EMPTY
79393: LIST
79394: LIST
79395: PUSH
79396: LD_INT 4
79398: PUSH
79399: LD_INT 1
79401: PUSH
79402: EMPTY
79403: LIST
79404: LIST
79405: PUSH
79406: LD_INT 3
79408: PUSH
79409: LD_INT 1
79411: PUSH
79412: EMPTY
79413: LIST
79414: LIST
79415: PUSH
79416: LD_INT 2
79418: PUSH
79419: LD_INT 0
79421: PUSH
79422: EMPTY
79423: LIST
79424: LIST
79425: PUSH
79426: LD_INT 2
79428: PUSH
79429: LD_INT 1
79431: NEG
79432: PUSH
79433: EMPTY
79434: LIST
79435: LIST
79436: PUSH
79437: LD_INT 2
79439: PUSH
79440: LD_INT 2
79442: NEG
79443: PUSH
79444: EMPTY
79445: LIST
79446: LIST
79447: PUSH
79448: LD_INT 4
79450: PUSH
79451: LD_INT 2
79453: PUSH
79454: EMPTY
79455: LIST
79456: LIST
79457: PUSH
79458: LD_INT 4
79460: PUSH
79461: LD_INT 4
79463: PUSH
79464: EMPTY
79465: LIST
79466: LIST
79467: PUSH
79468: LD_INT 4
79470: PUSH
79471: LD_INT 3
79473: PUSH
79474: EMPTY
79475: LIST
79476: LIST
79477: PUSH
79478: LD_INT 5
79480: PUSH
79481: LD_INT 4
79483: PUSH
79484: EMPTY
79485: LIST
79486: LIST
79487: PUSH
79488: LD_INT 5
79490: PUSH
79491: LD_INT 5
79493: PUSH
79494: EMPTY
79495: LIST
79496: LIST
79497: PUSH
79498: LD_INT 4
79500: PUSH
79501: LD_INT 5
79503: PUSH
79504: EMPTY
79505: LIST
79506: LIST
79507: PUSH
79508: LD_INT 3
79510: PUSH
79511: LD_INT 4
79513: PUSH
79514: EMPTY
79515: LIST
79516: LIST
79517: PUSH
79518: LD_INT 3
79520: PUSH
79521: LD_INT 3
79523: PUSH
79524: EMPTY
79525: LIST
79526: LIST
79527: PUSH
79528: LD_INT 5
79530: PUSH
79531: LD_INT 3
79533: PUSH
79534: EMPTY
79535: LIST
79536: LIST
79537: PUSH
79538: LD_INT 3
79540: PUSH
79541: LD_INT 5
79543: PUSH
79544: EMPTY
79545: LIST
79546: LIST
79547: PUSH
79548: EMPTY
79549: LIST
79550: LIST
79551: LIST
79552: LIST
79553: LIST
79554: LIST
79555: LIST
79556: LIST
79557: LIST
79558: LIST
79559: LIST
79560: LIST
79561: LIST
79562: LIST
79563: LIST
79564: LIST
79565: LIST
79566: LIST
79567: LIST
79568: LIST
79569: LIST
79570: LIST
79571: LIST
79572: LIST
79573: LIST
79574: LIST
79575: LIST
79576: LIST
79577: LIST
79578: LIST
79579: LIST
79580: LIST
79581: LIST
79582: LIST
79583: LIST
79584: LIST
79585: LIST
79586: LIST
79587: LIST
79588: LIST
79589: LIST
79590: LIST
79591: LIST
79592: LIST
79593: LIST
79594: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
79595: LD_ADDR_VAR 0 33
79599: PUSH
79600: LD_INT 4
79602: NEG
79603: PUSH
79604: LD_INT 4
79606: NEG
79607: PUSH
79608: EMPTY
79609: LIST
79610: LIST
79611: PUSH
79612: LD_INT 4
79614: NEG
79615: PUSH
79616: LD_INT 5
79618: NEG
79619: PUSH
79620: EMPTY
79621: LIST
79622: LIST
79623: PUSH
79624: LD_INT 3
79626: NEG
79627: PUSH
79628: LD_INT 4
79630: NEG
79631: PUSH
79632: EMPTY
79633: LIST
79634: LIST
79635: PUSH
79636: LD_INT 3
79638: NEG
79639: PUSH
79640: LD_INT 3
79642: NEG
79643: PUSH
79644: EMPTY
79645: LIST
79646: LIST
79647: PUSH
79648: LD_INT 4
79650: NEG
79651: PUSH
79652: LD_INT 3
79654: NEG
79655: PUSH
79656: EMPTY
79657: LIST
79658: LIST
79659: PUSH
79660: LD_INT 5
79662: NEG
79663: PUSH
79664: LD_INT 4
79666: NEG
79667: PUSH
79668: EMPTY
79669: LIST
79670: LIST
79671: PUSH
79672: LD_INT 5
79674: NEG
79675: PUSH
79676: LD_INT 5
79678: NEG
79679: PUSH
79680: EMPTY
79681: LIST
79682: LIST
79683: PUSH
79684: LD_INT 3
79686: NEG
79687: PUSH
79688: LD_INT 5
79690: NEG
79691: PUSH
79692: EMPTY
79693: LIST
79694: LIST
79695: PUSH
79696: LD_INT 5
79698: NEG
79699: PUSH
79700: LD_INT 3
79702: NEG
79703: PUSH
79704: EMPTY
79705: LIST
79706: LIST
79707: PUSH
79708: LD_INT 0
79710: PUSH
79711: LD_INT 3
79713: NEG
79714: PUSH
79715: EMPTY
79716: LIST
79717: LIST
79718: PUSH
79719: LD_INT 0
79721: PUSH
79722: LD_INT 4
79724: NEG
79725: PUSH
79726: EMPTY
79727: LIST
79728: LIST
79729: PUSH
79730: LD_INT 1
79732: PUSH
79733: LD_INT 3
79735: NEG
79736: PUSH
79737: EMPTY
79738: LIST
79739: LIST
79740: PUSH
79741: LD_INT 1
79743: PUSH
79744: LD_INT 2
79746: NEG
79747: PUSH
79748: EMPTY
79749: LIST
79750: LIST
79751: PUSH
79752: LD_INT 0
79754: PUSH
79755: LD_INT 2
79757: NEG
79758: PUSH
79759: EMPTY
79760: LIST
79761: LIST
79762: PUSH
79763: LD_INT 1
79765: NEG
79766: PUSH
79767: LD_INT 3
79769: NEG
79770: PUSH
79771: EMPTY
79772: LIST
79773: LIST
79774: PUSH
79775: LD_INT 1
79777: NEG
79778: PUSH
79779: LD_INT 4
79781: NEG
79782: PUSH
79783: EMPTY
79784: LIST
79785: LIST
79786: PUSH
79787: LD_INT 2
79789: PUSH
79790: LD_INT 2
79792: NEG
79793: PUSH
79794: EMPTY
79795: LIST
79796: LIST
79797: PUSH
79798: LD_INT 2
79800: NEG
79801: PUSH
79802: LD_INT 4
79804: NEG
79805: PUSH
79806: EMPTY
79807: LIST
79808: LIST
79809: PUSH
79810: LD_INT 4
79812: PUSH
79813: LD_INT 0
79815: PUSH
79816: EMPTY
79817: LIST
79818: LIST
79819: PUSH
79820: LD_INT 4
79822: PUSH
79823: LD_INT 1
79825: NEG
79826: PUSH
79827: EMPTY
79828: LIST
79829: LIST
79830: PUSH
79831: LD_INT 5
79833: PUSH
79834: LD_INT 0
79836: PUSH
79837: EMPTY
79838: LIST
79839: LIST
79840: PUSH
79841: LD_INT 5
79843: PUSH
79844: LD_INT 1
79846: PUSH
79847: EMPTY
79848: LIST
79849: LIST
79850: PUSH
79851: LD_INT 4
79853: PUSH
79854: LD_INT 1
79856: PUSH
79857: EMPTY
79858: LIST
79859: LIST
79860: PUSH
79861: LD_INT 3
79863: PUSH
79864: LD_INT 0
79866: PUSH
79867: EMPTY
79868: LIST
79869: LIST
79870: PUSH
79871: LD_INT 3
79873: PUSH
79874: LD_INT 1
79876: NEG
79877: PUSH
79878: EMPTY
79879: LIST
79880: LIST
79881: PUSH
79882: LD_INT 3
79884: PUSH
79885: LD_INT 2
79887: NEG
79888: PUSH
79889: EMPTY
79890: LIST
79891: LIST
79892: PUSH
79893: LD_INT 5
79895: PUSH
79896: LD_INT 2
79898: PUSH
79899: EMPTY
79900: LIST
79901: LIST
79902: PUSH
79903: LD_INT 3
79905: PUSH
79906: LD_INT 3
79908: PUSH
79909: EMPTY
79910: LIST
79911: LIST
79912: PUSH
79913: LD_INT 3
79915: PUSH
79916: LD_INT 2
79918: PUSH
79919: EMPTY
79920: LIST
79921: LIST
79922: PUSH
79923: LD_INT 4
79925: PUSH
79926: LD_INT 3
79928: PUSH
79929: EMPTY
79930: LIST
79931: LIST
79932: PUSH
79933: LD_INT 4
79935: PUSH
79936: LD_INT 4
79938: PUSH
79939: EMPTY
79940: LIST
79941: LIST
79942: PUSH
79943: LD_INT 3
79945: PUSH
79946: LD_INT 4
79948: PUSH
79949: EMPTY
79950: LIST
79951: LIST
79952: PUSH
79953: LD_INT 2
79955: PUSH
79956: LD_INT 3
79958: PUSH
79959: EMPTY
79960: LIST
79961: LIST
79962: PUSH
79963: LD_INT 2
79965: PUSH
79966: LD_INT 2
79968: PUSH
79969: EMPTY
79970: LIST
79971: LIST
79972: PUSH
79973: LD_INT 4
79975: PUSH
79976: LD_INT 2
79978: PUSH
79979: EMPTY
79980: LIST
79981: LIST
79982: PUSH
79983: LD_INT 2
79985: PUSH
79986: LD_INT 4
79988: PUSH
79989: EMPTY
79990: LIST
79991: LIST
79992: PUSH
79993: LD_INT 0
79995: PUSH
79996: LD_INT 4
79998: PUSH
79999: EMPTY
80000: LIST
80001: LIST
80002: PUSH
80003: LD_INT 0
80005: PUSH
80006: LD_INT 3
80008: PUSH
80009: EMPTY
80010: LIST
80011: LIST
80012: PUSH
80013: LD_INT 1
80015: PUSH
80016: LD_INT 4
80018: PUSH
80019: EMPTY
80020: LIST
80021: LIST
80022: PUSH
80023: LD_INT 1
80025: PUSH
80026: LD_INT 5
80028: PUSH
80029: EMPTY
80030: LIST
80031: LIST
80032: PUSH
80033: LD_INT 0
80035: PUSH
80036: LD_INT 5
80038: PUSH
80039: EMPTY
80040: LIST
80041: LIST
80042: PUSH
80043: LD_INT 1
80045: NEG
80046: PUSH
80047: LD_INT 4
80049: PUSH
80050: EMPTY
80051: LIST
80052: LIST
80053: PUSH
80054: LD_INT 1
80056: NEG
80057: PUSH
80058: LD_INT 3
80060: PUSH
80061: EMPTY
80062: LIST
80063: LIST
80064: PUSH
80065: LD_INT 2
80067: PUSH
80068: LD_INT 5
80070: PUSH
80071: EMPTY
80072: LIST
80073: LIST
80074: PUSH
80075: LD_INT 2
80077: NEG
80078: PUSH
80079: LD_INT 3
80081: PUSH
80082: EMPTY
80083: LIST
80084: LIST
80085: PUSH
80086: EMPTY
80087: LIST
80088: LIST
80089: LIST
80090: LIST
80091: LIST
80092: LIST
80093: LIST
80094: LIST
80095: LIST
80096: LIST
80097: LIST
80098: LIST
80099: LIST
80100: LIST
80101: LIST
80102: LIST
80103: LIST
80104: LIST
80105: LIST
80106: LIST
80107: LIST
80108: LIST
80109: LIST
80110: LIST
80111: LIST
80112: LIST
80113: LIST
80114: LIST
80115: LIST
80116: LIST
80117: LIST
80118: LIST
80119: LIST
80120: LIST
80121: LIST
80122: LIST
80123: LIST
80124: LIST
80125: LIST
80126: LIST
80127: LIST
80128: LIST
80129: LIST
80130: LIST
80131: LIST
80132: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
80133: LD_ADDR_VAR 0 34
80137: PUSH
80138: LD_INT 0
80140: PUSH
80141: LD_INT 4
80143: NEG
80144: PUSH
80145: EMPTY
80146: LIST
80147: LIST
80148: PUSH
80149: LD_INT 0
80151: PUSH
80152: LD_INT 5
80154: NEG
80155: PUSH
80156: EMPTY
80157: LIST
80158: LIST
80159: PUSH
80160: LD_INT 1
80162: PUSH
80163: LD_INT 4
80165: NEG
80166: PUSH
80167: EMPTY
80168: LIST
80169: LIST
80170: PUSH
80171: LD_INT 1
80173: PUSH
80174: LD_INT 3
80176: NEG
80177: PUSH
80178: EMPTY
80179: LIST
80180: LIST
80181: PUSH
80182: LD_INT 0
80184: PUSH
80185: LD_INT 3
80187: NEG
80188: PUSH
80189: EMPTY
80190: LIST
80191: LIST
80192: PUSH
80193: LD_INT 1
80195: NEG
80196: PUSH
80197: LD_INT 4
80199: NEG
80200: PUSH
80201: EMPTY
80202: LIST
80203: LIST
80204: PUSH
80205: LD_INT 1
80207: NEG
80208: PUSH
80209: LD_INT 5
80211: NEG
80212: PUSH
80213: EMPTY
80214: LIST
80215: LIST
80216: PUSH
80217: LD_INT 2
80219: PUSH
80220: LD_INT 3
80222: NEG
80223: PUSH
80224: EMPTY
80225: LIST
80226: LIST
80227: PUSH
80228: LD_INT 2
80230: NEG
80231: PUSH
80232: LD_INT 5
80234: NEG
80235: PUSH
80236: EMPTY
80237: LIST
80238: LIST
80239: PUSH
80240: LD_INT 3
80242: PUSH
80243: LD_INT 0
80245: PUSH
80246: EMPTY
80247: LIST
80248: LIST
80249: PUSH
80250: LD_INT 3
80252: PUSH
80253: LD_INT 1
80255: NEG
80256: PUSH
80257: EMPTY
80258: LIST
80259: LIST
80260: PUSH
80261: LD_INT 4
80263: PUSH
80264: LD_INT 0
80266: PUSH
80267: EMPTY
80268: LIST
80269: LIST
80270: PUSH
80271: LD_INT 4
80273: PUSH
80274: LD_INT 1
80276: PUSH
80277: EMPTY
80278: LIST
80279: LIST
80280: PUSH
80281: LD_INT 3
80283: PUSH
80284: LD_INT 1
80286: PUSH
80287: EMPTY
80288: LIST
80289: LIST
80290: PUSH
80291: LD_INT 2
80293: PUSH
80294: LD_INT 0
80296: PUSH
80297: EMPTY
80298: LIST
80299: LIST
80300: PUSH
80301: LD_INT 2
80303: PUSH
80304: LD_INT 1
80306: NEG
80307: PUSH
80308: EMPTY
80309: LIST
80310: LIST
80311: PUSH
80312: LD_INT 2
80314: PUSH
80315: LD_INT 2
80317: NEG
80318: PUSH
80319: EMPTY
80320: LIST
80321: LIST
80322: PUSH
80323: LD_INT 4
80325: PUSH
80326: LD_INT 2
80328: PUSH
80329: EMPTY
80330: LIST
80331: LIST
80332: PUSH
80333: LD_INT 4
80335: PUSH
80336: LD_INT 4
80338: PUSH
80339: EMPTY
80340: LIST
80341: LIST
80342: PUSH
80343: LD_INT 4
80345: PUSH
80346: LD_INT 3
80348: PUSH
80349: EMPTY
80350: LIST
80351: LIST
80352: PUSH
80353: LD_INT 5
80355: PUSH
80356: LD_INT 4
80358: PUSH
80359: EMPTY
80360: LIST
80361: LIST
80362: PUSH
80363: LD_INT 5
80365: PUSH
80366: LD_INT 5
80368: PUSH
80369: EMPTY
80370: LIST
80371: LIST
80372: PUSH
80373: LD_INT 4
80375: PUSH
80376: LD_INT 5
80378: PUSH
80379: EMPTY
80380: LIST
80381: LIST
80382: PUSH
80383: LD_INT 3
80385: PUSH
80386: LD_INT 4
80388: PUSH
80389: EMPTY
80390: LIST
80391: LIST
80392: PUSH
80393: LD_INT 3
80395: PUSH
80396: LD_INT 3
80398: PUSH
80399: EMPTY
80400: LIST
80401: LIST
80402: PUSH
80403: LD_INT 5
80405: PUSH
80406: LD_INT 3
80408: PUSH
80409: EMPTY
80410: LIST
80411: LIST
80412: PUSH
80413: LD_INT 3
80415: PUSH
80416: LD_INT 5
80418: PUSH
80419: EMPTY
80420: LIST
80421: LIST
80422: PUSH
80423: LD_INT 0
80425: PUSH
80426: LD_INT 3
80428: PUSH
80429: EMPTY
80430: LIST
80431: LIST
80432: PUSH
80433: LD_INT 0
80435: PUSH
80436: LD_INT 2
80438: PUSH
80439: EMPTY
80440: LIST
80441: LIST
80442: PUSH
80443: LD_INT 1
80445: PUSH
80446: LD_INT 3
80448: PUSH
80449: EMPTY
80450: LIST
80451: LIST
80452: PUSH
80453: LD_INT 1
80455: PUSH
80456: LD_INT 4
80458: PUSH
80459: EMPTY
80460: LIST
80461: LIST
80462: PUSH
80463: LD_INT 0
80465: PUSH
80466: LD_INT 4
80468: PUSH
80469: EMPTY
80470: LIST
80471: LIST
80472: PUSH
80473: LD_INT 1
80475: NEG
80476: PUSH
80477: LD_INT 3
80479: PUSH
80480: EMPTY
80481: LIST
80482: LIST
80483: PUSH
80484: LD_INT 1
80486: NEG
80487: PUSH
80488: LD_INT 2
80490: PUSH
80491: EMPTY
80492: LIST
80493: LIST
80494: PUSH
80495: LD_INT 2
80497: PUSH
80498: LD_INT 4
80500: PUSH
80501: EMPTY
80502: LIST
80503: LIST
80504: PUSH
80505: LD_INT 2
80507: NEG
80508: PUSH
80509: LD_INT 2
80511: PUSH
80512: EMPTY
80513: LIST
80514: LIST
80515: PUSH
80516: LD_INT 4
80518: NEG
80519: PUSH
80520: LD_INT 0
80522: PUSH
80523: EMPTY
80524: LIST
80525: LIST
80526: PUSH
80527: LD_INT 4
80529: NEG
80530: PUSH
80531: LD_INT 1
80533: NEG
80534: PUSH
80535: EMPTY
80536: LIST
80537: LIST
80538: PUSH
80539: LD_INT 3
80541: NEG
80542: PUSH
80543: LD_INT 0
80545: PUSH
80546: EMPTY
80547: LIST
80548: LIST
80549: PUSH
80550: LD_INT 3
80552: NEG
80553: PUSH
80554: LD_INT 1
80556: PUSH
80557: EMPTY
80558: LIST
80559: LIST
80560: PUSH
80561: LD_INT 4
80563: NEG
80564: PUSH
80565: LD_INT 1
80567: PUSH
80568: EMPTY
80569: LIST
80570: LIST
80571: PUSH
80572: LD_INT 5
80574: NEG
80575: PUSH
80576: LD_INT 0
80578: PUSH
80579: EMPTY
80580: LIST
80581: LIST
80582: PUSH
80583: LD_INT 5
80585: NEG
80586: PUSH
80587: LD_INT 1
80589: NEG
80590: PUSH
80591: EMPTY
80592: LIST
80593: LIST
80594: PUSH
80595: LD_INT 5
80597: NEG
80598: PUSH
80599: LD_INT 2
80601: NEG
80602: PUSH
80603: EMPTY
80604: LIST
80605: LIST
80606: PUSH
80607: LD_INT 3
80609: NEG
80610: PUSH
80611: LD_INT 2
80613: PUSH
80614: EMPTY
80615: LIST
80616: LIST
80617: PUSH
80618: EMPTY
80619: LIST
80620: LIST
80621: LIST
80622: LIST
80623: LIST
80624: LIST
80625: LIST
80626: LIST
80627: LIST
80628: LIST
80629: LIST
80630: LIST
80631: LIST
80632: LIST
80633: LIST
80634: LIST
80635: LIST
80636: LIST
80637: LIST
80638: LIST
80639: LIST
80640: LIST
80641: LIST
80642: LIST
80643: LIST
80644: LIST
80645: LIST
80646: LIST
80647: LIST
80648: LIST
80649: LIST
80650: LIST
80651: LIST
80652: LIST
80653: LIST
80654: LIST
80655: LIST
80656: LIST
80657: LIST
80658: LIST
80659: LIST
80660: LIST
80661: LIST
80662: LIST
80663: LIST
80664: ST_TO_ADDR
// end ; end ;
80665: GO 80668
80667: POP
// case btype of b_depot , b_warehouse :
80668: LD_VAR 0 1
80672: PUSH
80673: LD_INT 0
80675: DOUBLE
80676: EQUAL
80677: IFTRUE 80687
80679: LD_INT 1
80681: DOUBLE
80682: EQUAL
80683: IFTRUE 80687
80685: GO 80888
80687: POP
// case nation of nation_american :
80688: LD_VAR 0 5
80692: PUSH
80693: LD_INT 1
80695: DOUBLE
80696: EQUAL
80697: IFTRUE 80701
80699: GO 80757
80701: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
80702: LD_ADDR_VAR 0 9
80706: PUSH
80707: LD_VAR 0 11
80711: PUSH
80712: LD_VAR 0 12
80716: PUSH
80717: LD_VAR 0 13
80721: PUSH
80722: LD_VAR 0 14
80726: PUSH
80727: LD_VAR 0 15
80731: PUSH
80732: LD_VAR 0 16
80736: PUSH
80737: EMPTY
80738: LIST
80739: LIST
80740: LIST
80741: LIST
80742: LIST
80743: LIST
80744: PUSH
80745: LD_VAR 0 4
80749: PUSH
80750: LD_INT 1
80752: PLUS
80753: ARRAY
80754: ST_TO_ADDR
80755: GO 80886
80757: LD_INT 2
80759: DOUBLE
80760: EQUAL
80761: IFTRUE 80765
80763: GO 80821
80765: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
80766: LD_ADDR_VAR 0 9
80770: PUSH
80771: LD_VAR 0 17
80775: PUSH
80776: LD_VAR 0 18
80780: PUSH
80781: LD_VAR 0 19
80785: PUSH
80786: LD_VAR 0 20
80790: PUSH
80791: LD_VAR 0 21
80795: PUSH
80796: LD_VAR 0 22
80800: PUSH
80801: EMPTY
80802: LIST
80803: LIST
80804: LIST
80805: LIST
80806: LIST
80807: LIST
80808: PUSH
80809: LD_VAR 0 4
80813: PUSH
80814: LD_INT 1
80816: PLUS
80817: ARRAY
80818: ST_TO_ADDR
80819: GO 80886
80821: LD_INT 3
80823: DOUBLE
80824: EQUAL
80825: IFTRUE 80829
80827: GO 80885
80829: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
80830: LD_ADDR_VAR 0 9
80834: PUSH
80835: LD_VAR 0 23
80839: PUSH
80840: LD_VAR 0 24
80844: PUSH
80845: LD_VAR 0 25
80849: PUSH
80850: LD_VAR 0 26
80854: PUSH
80855: LD_VAR 0 27
80859: PUSH
80860: LD_VAR 0 28
80864: PUSH
80865: EMPTY
80866: LIST
80867: LIST
80868: LIST
80869: LIST
80870: LIST
80871: LIST
80872: PUSH
80873: LD_VAR 0 4
80877: PUSH
80878: LD_INT 1
80880: PLUS
80881: ARRAY
80882: ST_TO_ADDR
80883: GO 80886
80885: POP
80886: GO 81441
80888: LD_INT 2
80890: DOUBLE
80891: EQUAL
80892: IFTRUE 80902
80894: LD_INT 3
80896: DOUBLE
80897: EQUAL
80898: IFTRUE 80902
80900: GO 80958
80902: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
80903: LD_ADDR_VAR 0 9
80907: PUSH
80908: LD_VAR 0 29
80912: PUSH
80913: LD_VAR 0 30
80917: PUSH
80918: LD_VAR 0 31
80922: PUSH
80923: LD_VAR 0 32
80927: PUSH
80928: LD_VAR 0 33
80932: PUSH
80933: LD_VAR 0 34
80937: PUSH
80938: EMPTY
80939: LIST
80940: LIST
80941: LIST
80942: LIST
80943: LIST
80944: LIST
80945: PUSH
80946: LD_VAR 0 4
80950: PUSH
80951: LD_INT 1
80953: PLUS
80954: ARRAY
80955: ST_TO_ADDR
80956: GO 81441
80958: LD_INT 16
80960: DOUBLE
80961: EQUAL
80962: IFTRUE 81020
80964: LD_INT 17
80966: DOUBLE
80967: EQUAL
80968: IFTRUE 81020
80970: LD_INT 18
80972: DOUBLE
80973: EQUAL
80974: IFTRUE 81020
80976: LD_INT 19
80978: DOUBLE
80979: EQUAL
80980: IFTRUE 81020
80982: LD_INT 22
80984: DOUBLE
80985: EQUAL
80986: IFTRUE 81020
80988: LD_INT 20
80990: DOUBLE
80991: EQUAL
80992: IFTRUE 81020
80994: LD_INT 21
80996: DOUBLE
80997: EQUAL
80998: IFTRUE 81020
81000: LD_INT 23
81002: DOUBLE
81003: EQUAL
81004: IFTRUE 81020
81006: LD_INT 24
81008: DOUBLE
81009: EQUAL
81010: IFTRUE 81020
81012: LD_INT 25
81014: DOUBLE
81015: EQUAL
81016: IFTRUE 81020
81018: GO 81076
81020: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
81021: LD_ADDR_VAR 0 9
81025: PUSH
81026: LD_VAR 0 35
81030: PUSH
81031: LD_VAR 0 36
81035: PUSH
81036: LD_VAR 0 37
81040: PUSH
81041: LD_VAR 0 38
81045: PUSH
81046: LD_VAR 0 39
81050: PUSH
81051: LD_VAR 0 40
81055: PUSH
81056: EMPTY
81057: LIST
81058: LIST
81059: LIST
81060: LIST
81061: LIST
81062: LIST
81063: PUSH
81064: LD_VAR 0 4
81068: PUSH
81069: LD_INT 1
81071: PLUS
81072: ARRAY
81073: ST_TO_ADDR
81074: GO 81441
81076: LD_INT 6
81078: DOUBLE
81079: EQUAL
81080: IFTRUE 81132
81082: LD_INT 7
81084: DOUBLE
81085: EQUAL
81086: IFTRUE 81132
81088: LD_INT 8
81090: DOUBLE
81091: EQUAL
81092: IFTRUE 81132
81094: LD_INT 13
81096: DOUBLE
81097: EQUAL
81098: IFTRUE 81132
81100: LD_INT 12
81102: DOUBLE
81103: EQUAL
81104: IFTRUE 81132
81106: LD_INT 15
81108: DOUBLE
81109: EQUAL
81110: IFTRUE 81132
81112: LD_INT 11
81114: DOUBLE
81115: EQUAL
81116: IFTRUE 81132
81118: LD_INT 14
81120: DOUBLE
81121: EQUAL
81122: IFTRUE 81132
81124: LD_INT 10
81126: DOUBLE
81127: EQUAL
81128: IFTRUE 81132
81130: GO 81188
81132: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
81133: LD_ADDR_VAR 0 9
81137: PUSH
81138: LD_VAR 0 41
81142: PUSH
81143: LD_VAR 0 42
81147: PUSH
81148: LD_VAR 0 43
81152: PUSH
81153: LD_VAR 0 44
81157: PUSH
81158: LD_VAR 0 45
81162: PUSH
81163: LD_VAR 0 46
81167: PUSH
81168: EMPTY
81169: LIST
81170: LIST
81171: LIST
81172: LIST
81173: LIST
81174: LIST
81175: PUSH
81176: LD_VAR 0 4
81180: PUSH
81181: LD_INT 1
81183: PLUS
81184: ARRAY
81185: ST_TO_ADDR
81186: GO 81441
81188: LD_INT 36
81190: DOUBLE
81191: EQUAL
81192: IFTRUE 81196
81194: GO 81252
81196: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
81197: LD_ADDR_VAR 0 9
81201: PUSH
81202: LD_VAR 0 47
81206: PUSH
81207: LD_VAR 0 48
81211: PUSH
81212: LD_VAR 0 49
81216: PUSH
81217: LD_VAR 0 50
81221: PUSH
81222: LD_VAR 0 51
81226: PUSH
81227: LD_VAR 0 52
81231: PUSH
81232: EMPTY
81233: LIST
81234: LIST
81235: LIST
81236: LIST
81237: LIST
81238: LIST
81239: PUSH
81240: LD_VAR 0 4
81244: PUSH
81245: LD_INT 1
81247: PLUS
81248: ARRAY
81249: ST_TO_ADDR
81250: GO 81441
81252: LD_INT 4
81254: DOUBLE
81255: EQUAL
81256: IFTRUE 81278
81258: LD_INT 5
81260: DOUBLE
81261: EQUAL
81262: IFTRUE 81278
81264: LD_INT 34
81266: DOUBLE
81267: EQUAL
81268: IFTRUE 81278
81270: LD_INT 37
81272: DOUBLE
81273: EQUAL
81274: IFTRUE 81278
81276: GO 81334
81278: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
81279: LD_ADDR_VAR 0 9
81283: PUSH
81284: LD_VAR 0 53
81288: PUSH
81289: LD_VAR 0 54
81293: PUSH
81294: LD_VAR 0 55
81298: PUSH
81299: LD_VAR 0 56
81303: PUSH
81304: LD_VAR 0 57
81308: PUSH
81309: LD_VAR 0 58
81313: PUSH
81314: EMPTY
81315: LIST
81316: LIST
81317: LIST
81318: LIST
81319: LIST
81320: LIST
81321: PUSH
81322: LD_VAR 0 4
81326: PUSH
81327: LD_INT 1
81329: PLUS
81330: ARRAY
81331: ST_TO_ADDR
81332: GO 81441
81334: LD_INT 31
81336: DOUBLE
81337: EQUAL
81338: IFTRUE 81384
81340: LD_INT 32
81342: DOUBLE
81343: EQUAL
81344: IFTRUE 81384
81346: LD_INT 33
81348: DOUBLE
81349: EQUAL
81350: IFTRUE 81384
81352: LD_INT 27
81354: DOUBLE
81355: EQUAL
81356: IFTRUE 81384
81358: LD_INT 26
81360: DOUBLE
81361: EQUAL
81362: IFTRUE 81384
81364: LD_INT 28
81366: DOUBLE
81367: EQUAL
81368: IFTRUE 81384
81370: LD_INT 29
81372: DOUBLE
81373: EQUAL
81374: IFTRUE 81384
81376: LD_INT 30
81378: DOUBLE
81379: EQUAL
81380: IFTRUE 81384
81382: GO 81440
81384: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
81385: LD_ADDR_VAR 0 9
81389: PUSH
81390: LD_VAR 0 59
81394: PUSH
81395: LD_VAR 0 60
81399: PUSH
81400: LD_VAR 0 61
81404: PUSH
81405: LD_VAR 0 62
81409: PUSH
81410: LD_VAR 0 63
81414: PUSH
81415: LD_VAR 0 64
81419: PUSH
81420: EMPTY
81421: LIST
81422: LIST
81423: LIST
81424: LIST
81425: LIST
81426: LIST
81427: PUSH
81428: LD_VAR 0 4
81432: PUSH
81433: LD_INT 1
81435: PLUS
81436: ARRAY
81437: ST_TO_ADDR
81438: GO 81441
81440: POP
// temp_list2 = [ ] ;
81441: LD_ADDR_VAR 0 10
81445: PUSH
81446: EMPTY
81447: ST_TO_ADDR
// for i in temp_list do
81448: LD_ADDR_VAR 0 8
81452: PUSH
81453: LD_VAR 0 9
81457: PUSH
81458: FOR_IN
81459: IFFALSE 81511
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
81461: LD_ADDR_VAR 0 10
81465: PUSH
81466: LD_VAR 0 10
81470: PUSH
81471: LD_VAR 0 8
81475: PUSH
81476: LD_INT 1
81478: ARRAY
81479: PUSH
81480: LD_VAR 0 2
81484: PLUS
81485: PUSH
81486: LD_VAR 0 8
81490: PUSH
81491: LD_INT 2
81493: ARRAY
81494: PUSH
81495: LD_VAR 0 3
81499: PLUS
81500: PUSH
81501: EMPTY
81502: LIST
81503: LIST
81504: PUSH
81505: EMPTY
81506: LIST
81507: ADD
81508: ST_TO_ADDR
81509: GO 81458
81511: POP
81512: POP
// result = temp_list2 ;
81513: LD_ADDR_VAR 0 7
81517: PUSH
81518: LD_VAR 0 10
81522: ST_TO_ADDR
// end ;
81523: LD_VAR 0 7
81527: RET
// export function EnemyInRange ( unit , dist ) ; begin
81528: LD_INT 0
81530: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
81531: LD_ADDR_VAR 0 3
81535: PUSH
81536: LD_VAR 0 1
81540: PPUSH
81541: CALL_OW 255
81545: PPUSH
81546: LD_VAR 0 1
81550: PPUSH
81551: CALL_OW 250
81555: PPUSH
81556: LD_VAR 0 1
81560: PPUSH
81561: CALL_OW 251
81565: PPUSH
81566: LD_VAR 0 2
81570: PPUSH
81571: CALL 54930 0 4
81575: PUSH
81576: LD_INT 4
81578: ARRAY
81579: ST_TO_ADDR
// end ;
81580: LD_VAR 0 3
81584: RET
// export function PlayerSeeMe ( unit ) ; begin
81585: LD_INT 0
81587: PPUSH
// result := See ( your_side , unit ) ;
81588: LD_ADDR_VAR 0 2
81592: PUSH
81593: LD_OWVAR 2
81597: PPUSH
81598: LD_VAR 0 1
81602: PPUSH
81603: CALL_OW 292
81607: ST_TO_ADDR
// end ;
81608: LD_VAR 0 2
81612: RET
// export function ReverseDir ( unit ) ; begin
81613: LD_INT 0
81615: PPUSH
// if not unit then
81616: LD_VAR 0 1
81620: NOT
81621: IFFALSE 81625
// exit ;
81623: GO 81648
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
81625: LD_ADDR_VAR 0 2
81629: PUSH
81630: LD_VAR 0 1
81634: PPUSH
81635: CALL_OW 254
81639: PUSH
81640: LD_INT 3
81642: PLUS
81643: PUSH
81644: LD_INT 6
81646: MOD
81647: ST_TO_ADDR
// end ;
81648: LD_VAR 0 2
81652: RET
// export function ReverseArray ( array ) ; var i ; begin
81653: LD_INT 0
81655: PPUSH
81656: PPUSH
// if not array then
81657: LD_VAR 0 1
81661: NOT
81662: IFFALSE 81666
// exit ;
81664: GO 81721
// result := [ ] ;
81666: LD_ADDR_VAR 0 2
81670: PUSH
81671: EMPTY
81672: ST_TO_ADDR
// for i := array downto 1 do
81673: LD_ADDR_VAR 0 3
81677: PUSH
81678: DOUBLE
81679: LD_VAR 0 1
81683: INC
81684: ST_TO_ADDR
81685: LD_INT 1
81687: PUSH
81688: FOR_DOWNTO
81689: IFFALSE 81719
// result := Join ( result , array [ i ] ) ;
81691: LD_ADDR_VAR 0 2
81695: PUSH
81696: LD_VAR 0 2
81700: PPUSH
81701: LD_VAR 0 1
81705: PUSH
81706: LD_VAR 0 3
81710: ARRAY
81711: PPUSH
81712: CALL 86364 0 2
81716: ST_TO_ADDR
81717: GO 81688
81719: POP
81720: POP
// end ;
81721: LD_VAR 0 2
81725: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
81726: LD_INT 0
81728: PPUSH
81729: PPUSH
81730: PPUSH
81731: PPUSH
81732: PPUSH
81733: PPUSH
// if not unit or not hexes then
81734: LD_VAR 0 1
81738: NOT
81739: PUSH
81740: LD_VAR 0 2
81744: NOT
81745: OR
81746: IFFALSE 81750
// exit ;
81748: GO 81873
// dist := 9999 ;
81750: LD_ADDR_VAR 0 5
81754: PUSH
81755: LD_INT 9999
81757: ST_TO_ADDR
// for i = 1 to hexes do
81758: LD_ADDR_VAR 0 4
81762: PUSH
81763: DOUBLE
81764: LD_INT 1
81766: DEC
81767: ST_TO_ADDR
81768: LD_VAR 0 2
81772: PUSH
81773: FOR_TO
81774: IFFALSE 81861
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
81776: LD_ADDR_VAR 0 6
81780: PUSH
81781: LD_VAR 0 1
81785: PPUSH
81786: LD_VAR 0 2
81790: PUSH
81791: LD_VAR 0 4
81795: ARRAY
81796: PUSH
81797: LD_INT 1
81799: ARRAY
81800: PPUSH
81801: LD_VAR 0 2
81805: PUSH
81806: LD_VAR 0 4
81810: ARRAY
81811: PUSH
81812: LD_INT 2
81814: ARRAY
81815: PPUSH
81816: CALL_OW 297
81820: ST_TO_ADDR
// if tdist < dist then
81821: LD_VAR 0 6
81825: PUSH
81826: LD_VAR 0 5
81830: LESS
81831: IFFALSE 81859
// begin hex := hexes [ i ] ;
81833: LD_ADDR_VAR 0 8
81837: PUSH
81838: LD_VAR 0 2
81842: PUSH
81843: LD_VAR 0 4
81847: ARRAY
81848: ST_TO_ADDR
// dist := tdist ;
81849: LD_ADDR_VAR 0 5
81853: PUSH
81854: LD_VAR 0 6
81858: ST_TO_ADDR
// end ; end ;
81859: GO 81773
81861: POP
81862: POP
// result := hex ;
81863: LD_ADDR_VAR 0 3
81867: PUSH
81868: LD_VAR 0 8
81872: ST_TO_ADDR
// end ;
81873: LD_VAR 0 3
81877: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
81878: LD_INT 0
81880: PPUSH
81881: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
81882: LD_VAR 0 1
81886: NOT
81887: PUSH
81888: LD_VAR 0 1
81892: PUSH
81893: LD_INT 21
81895: PUSH
81896: LD_INT 2
81898: PUSH
81899: EMPTY
81900: LIST
81901: LIST
81902: PUSH
81903: LD_INT 23
81905: PUSH
81906: LD_INT 2
81908: PUSH
81909: EMPTY
81910: LIST
81911: LIST
81912: PUSH
81913: EMPTY
81914: LIST
81915: LIST
81916: PPUSH
81917: CALL_OW 69
81921: IN
81922: NOT
81923: OR
81924: IFFALSE 81928
// exit ;
81926: GO 81975
// for i = 1 to 3 do
81928: LD_ADDR_VAR 0 3
81932: PUSH
81933: DOUBLE
81934: LD_INT 1
81936: DEC
81937: ST_TO_ADDR
81938: LD_INT 3
81940: PUSH
81941: FOR_TO
81942: IFFALSE 81973
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
81944: LD_VAR 0 1
81948: PPUSH
81949: CALL_OW 250
81953: PPUSH
81954: LD_VAR 0 1
81958: PPUSH
81959: CALL_OW 251
81963: PPUSH
81964: LD_INT 1
81966: PPUSH
81967: CALL_OW 453
81971: GO 81941
81973: POP
81974: POP
// end ;
81975: LD_VAR 0 2
81979: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
81980: LD_INT 0
81982: PPUSH
81983: PPUSH
81984: PPUSH
81985: PPUSH
81986: PPUSH
81987: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
81988: LD_VAR 0 1
81992: NOT
81993: PUSH
81994: LD_VAR 0 2
81998: NOT
81999: OR
82000: PUSH
82001: LD_VAR 0 1
82005: PPUSH
82006: CALL_OW 314
82010: OR
82011: IFFALSE 82015
// exit ;
82013: GO 82482
// if GetLives ( i ) < 250 then
82015: LD_VAR 0 4
82019: PPUSH
82020: CALL_OW 256
82024: PUSH
82025: LD_INT 250
82027: LESS
82028: IFFALSE 82041
// begin ComAutodestruct ( i ) ;
82030: LD_VAR 0 4
82034: PPUSH
82035: CALL 81878 0 1
// exit ;
82039: GO 82482
// end ; x := GetX ( enemy_unit ) ;
82041: LD_ADDR_VAR 0 7
82045: PUSH
82046: LD_VAR 0 2
82050: PPUSH
82051: CALL_OW 250
82055: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
82056: LD_ADDR_VAR 0 8
82060: PUSH
82061: LD_VAR 0 2
82065: PPUSH
82066: CALL_OW 251
82070: ST_TO_ADDR
// if not x or not y then
82071: LD_VAR 0 7
82075: NOT
82076: PUSH
82077: LD_VAR 0 8
82081: NOT
82082: OR
82083: IFFALSE 82087
// exit ;
82085: GO 82482
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
82087: LD_ADDR_VAR 0 6
82091: PUSH
82092: LD_VAR 0 7
82096: PPUSH
82097: LD_INT 0
82099: PPUSH
82100: LD_INT 4
82102: PPUSH
82103: CALL_OW 272
82107: PUSH
82108: LD_VAR 0 8
82112: PPUSH
82113: LD_INT 0
82115: PPUSH
82116: LD_INT 4
82118: PPUSH
82119: CALL_OW 273
82123: PUSH
82124: EMPTY
82125: LIST
82126: LIST
82127: PUSH
82128: LD_VAR 0 7
82132: PPUSH
82133: LD_INT 1
82135: PPUSH
82136: LD_INT 4
82138: PPUSH
82139: CALL_OW 272
82143: PUSH
82144: LD_VAR 0 8
82148: PPUSH
82149: LD_INT 1
82151: PPUSH
82152: LD_INT 4
82154: PPUSH
82155: CALL_OW 273
82159: PUSH
82160: EMPTY
82161: LIST
82162: LIST
82163: PUSH
82164: LD_VAR 0 7
82168: PPUSH
82169: LD_INT 2
82171: PPUSH
82172: LD_INT 4
82174: PPUSH
82175: CALL_OW 272
82179: PUSH
82180: LD_VAR 0 8
82184: PPUSH
82185: LD_INT 2
82187: PPUSH
82188: LD_INT 4
82190: PPUSH
82191: CALL_OW 273
82195: PUSH
82196: EMPTY
82197: LIST
82198: LIST
82199: PUSH
82200: LD_VAR 0 7
82204: PPUSH
82205: LD_INT 3
82207: PPUSH
82208: LD_INT 4
82210: PPUSH
82211: CALL_OW 272
82215: PUSH
82216: LD_VAR 0 8
82220: PPUSH
82221: LD_INT 3
82223: PPUSH
82224: LD_INT 4
82226: PPUSH
82227: CALL_OW 273
82231: PUSH
82232: EMPTY
82233: LIST
82234: LIST
82235: PUSH
82236: LD_VAR 0 7
82240: PPUSH
82241: LD_INT 4
82243: PPUSH
82244: LD_INT 4
82246: PPUSH
82247: CALL_OW 272
82251: PUSH
82252: LD_VAR 0 8
82256: PPUSH
82257: LD_INT 4
82259: PPUSH
82260: LD_INT 4
82262: PPUSH
82263: CALL_OW 273
82267: PUSH
82268: EMPTY
82269: LIST
82270: LIST
82271: PUSH
82272: LD_VAR 0 7
82276: PPUSH
82277: LD_INT 5
82279: PPUSH
82280: LD_INT 4
82282: PPUSH
82283: CALL_OW 272
82287: PUSH
82288: LD_VAR 0 8
82292: PPUSH
82293: LD_INT 5
82295: PPUSH
82296: LD_INT 4
82298: PPUSH
82299: CALL_OW 273
82303: PUSH
82304: EMPTY
82305: LIST
82306: LIST
82307: PUSH
82308: EMPTY
82309: LIST
82310: LIST
82311: LIST
82312: LIST
82313: LIST
82314: LIST
82315: ST_TO_ADDR
// for i = tmp downto 1 do
82316: LD_ADDR_VAR 0 4
82320: PUSH
82321: DOUBLE
82322: LD_VAR 0 6
82326: INC
82327: ST_TO_ADDR
82328: LD_INT 1
82330: PUSH
82331: FOR_DOWNTO
82332: IFFALSE 82433
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
82334: LD_VAR 0 6
82338: PUSH
82339: LD_VAR 0 4
82343: ARRAY
82344: PUSH
82345: LD_INT 1
82347: ARRAY
82348: PPUSH
82349: LD_VAR 0 6
82353: PUSH
82354: LD_VAR 0 4
82358: ARRAY
82359: PUSH
82360: LD_INT 2
82362: ARRAY
82363: PPUSH
82364: CALL_OW 488
82368: NOT
82369: PUSH
82370: LD_VAR 0 6
82374: PUSH
82375: LD_VAR 0 4
82379: ARRAY
82380: PUSH
82381: LD_INT 1
82383: ARRAY
82384: PPUSH
82385: LD_VAR 0 6
82389: PUSH
82390: LD_VAR 0 4
82394: ARRAY
82395: PUSH
82396: LD_INT 2
82398: ARRAY
82399: PPUSH
82400: CALL_OW 428
82404: PUSH
82405: LD_INT 0
82407: NONEQUAL
82408: OR
82409: IFFALSE 82431
// tmp := Delete ( tmp , i ) ;
82411: LD_ADDR_VAR 0 6
82415: PUSH
82416: LD_VAR 0 6
82420: PPUSH
82421: LD_VAR 0 4
82425: PPUSH
82426: CALL_OW 3
82430: ST_TO_ADDR
82431: GO 82331
82433: POP
82434: POP
// j := GetClosestHex ( unit , tmp ) ;
82435: LD_ADDR_VAR 0 5
82439: PUSH
82440: LD_VAR 0 1
82444: PPUSH
82445: LD_VAR 0 6
82449: PPUSH
82450: CALL 81726 0 2
82454: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
82455: LD_VAR 0 1
82459: PPUSH
82460: LD_VAR 0 5
82464: PUSH
82465: LD_INT 1
82467: ARRAY
82468: PPUSH
82469: LD_VAR 0 5
82473: PUSH
82474: LD_INT 2
82476: ARRAY
82477: PPUSH
82478: CALL_OW 111
// end ;
82482: LD_VAR 0 3
82486: RET
// export function PrepareApemanSoldier ( ) ; begin
82487: LD_INT 0
82489: PPUSH
// uc_nation := 0 ;
82490: LD_ADDR_OWVAR 21
82494: PUSH
82495: LD_INT 0
82497: ST_TO_ADDR
// hc_sex := sex_male ;
82498: LD_ADDR_OWVAR 27
82502: PUSH
82503: LD_INT 1
82505: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
82506: LD_ADDR_OWVAR 28
82510: PUSH
82511: LD_INT 15
82513: ST_TO_ADDR
// hc_gallery :=  ;
82514: LD_ADDR_OWVAR 33
82518: PUSH
82519: LD_STRING 
82521: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
82522: LD_ADDR_OWVAR 31
82526: PUSH
82527: LD_INT 0
82529: PPUSH
82530: LD_INT 3
82532: PPUSH
82533: CALL_OW 12
82537: PUSH
82538: LD_INT 0
82540: PPUSH
82541: LD_INT 3
82543: PPUSH
82544: CALL_OW 12
82548: PUSH
82549: LD_INT 0
82551: PUSH
82552: LD_INT 0
82554: PUSH
82555: EMPTY
82556: LIST
82557: LIST
82558: LIST
82559: LIST
82560: ST_TO_ADDR
// end ;
82561: LD_VAR 0 1
82565: RET
// export function PrepareApemanEngineer ( ) ; begin
82566: LD_INT 0
82568: PPUSH
// uc_nation := 0 ;
82569: LD_ADDR_OWVAR 21
82573: PUSH
82574: LD_INT 0
82576: ST_TO_ADDR
// hc_sex := sex_male ;
82577: LD_ADDR_OWVAR 27
82581: PUSH
82582: LD_INT 1
82584: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
82585: LD_ADDR_OWVAR 28
82589: PUSH
82590: LD_INT 16
82592: ST_TO_ADDR
// hc_gallery :=  ;
82593: LD_ADDR_OWVAR 33
82597: PUSH
82598: LD_STRING 
82600: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
82601: LD_ADDR_OWVAR 31
82605: PUSH
82606: LD_INT 0
82608: PPUSH
82609: LD_INT 3
82611: PPUSH
82612: CALL_OW 12
82616: PUSH
82617: LD_INT 0
82619: PPUSH
82620: LD_INT 3
82622: PPUSH
82623: CALL_OW 12
82627: PUSH
82628: LD_INT 0
82630: PUSH
82631: LD_INT 0
82633: PUSH
82634: EMPTY
82635: LIST
82636: LIST
82637: LIST
82638: LIST
82639: ST_TO_ADDR
// end ;
82640: LD_VAR 0 1
82644: RET
// export function PrepareApeman ( agressivity ) ; begin
82645: LD_INT 0
82647: PPUSH
// uc_side := 0 ;
82648: LD_ADDR_OWVAR 20
82652: PUSH
82653: LD_INT 0
82655: ST_TO_ADDR
// uc_nation := 0 ;
82656: LD_ADDR_OWVAR 21
82660: PUSH
82661: LD_INT 0
82663: ST_TO_ADDR
// hc_sex := sex_male ;
82664: LD_ADDR_OWVAR 27
82668: PUSH
82669: LD_INT 1
82671: ST_TO_ADDR
// hc_class := class_apeman ;
82672: LD_ADDR_OWVAR 28
82676: PUSH
82677: LD_INT 12
82679: ST_TO_ADDR
// hc_gallery :=  ;
82680: LD_ADDR_OWVAR 33
82684: PUSH
82685: LD_STRING 
82687: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
82688: LD_ADDR_OWVAR 35
82692: PUSH
82693: LD_VAR 0 1
82697: NEG
82698: PPUSH
82699: LD_VAR 0 1
82703: PPUSH
82704: CALL_OW 12
82708: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
82709: LD_ADDR_OWVAR 31
82713: PUSH
82714: LD_INT 0
82716: PPUSH
82717: LD_INT 3
82719: PPUSH
82720: CALL_OW 12
82724: PUSH
82725: LD_INT 0
82727: PPUSH
82728: LD_INT 3
82730: PPUSH
82731: CALL_OW 12
82735: PUSH
82736: LD_INT 0
82738: PUSH
82739: LD_INT 0
82741: PUSH
82742: EMPTY
82743: LIST
82744: LIST
82745: LIST
82746: LIST
82747: ST_TO_ADDR
// end ;
82748: LD_VAR 0 2
82752: RET
// export function PrepareTiger ( agressivity ) ; begin
82753: LD_INT 0
82755: PPUSH
// uc_side := 0 ;
82756: LD_ADDR_OWVAR 20
82760: PUSH
82761: LD_INT 0
82763: ST_TO_ADDR
// uc_nation := 0 ;
82764: LD_ADDR_OWVAR 21
82768: PUSH
82769: LD_INT 0
82771: ST_TO_ADDR
// hc_class := class_tiger ;
82772: LD_ADDR_OWVAR 28
82776: PUSH
82777: LD_INT 14
82779: ST_TO_ADDR
// hc_gallery :=  ;
82780: LD_ADDR_OWVAR 33
82784: PUSH
82785: LD_STRING 
82787: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
82788: LD_ADDR_OWVAR 35
82792: PUSH
82793: LD_VAR 0 1
82797: NEG
82798: PPUSH
82799: LD_VAR 0 1
82803: PPUSH
82804: CALL_OW 12
82808: ST_TO_ADDR
// end ;
82809: LD_VAR 0 2
82813: RET
// export function PrepareEnchidna ( ) ; begin
82814: LD_INT 0
82816: PPUSH
// uc_side := 0 ;
82817: LD_ADDR_OWVAR 20
82821: PUSH
82822: LD_INT 0
82824: ST_TO_ADDR
// uc_nation := 0 ;
82825: LD_ADDR_OWVAR 21
82829: PUSH
82830: LD_INT 0
82832: ST_TO_ADDR
// hc_class := class_baggie ;
82833: LD_ADDR_OWVAR 28
82837: PUSH
82838: LD_INT 13
82840: ST_TO_ADDR
// hc_gallery :=  ;
82841: LD_ADDR_OWVAR 33
82845: PUSH
82846: LD_STRING 
82848: ST_TO_ADDR
// end ;
82849: LD_VAR 0 1
82853: RET
// export function PrepareFrog ( ) ; begin
82854: LD_INT 0
82856: PPUSH
// uc_side := 0 ;
82857: LD_ADDR_OWVAR 20
82861: PUSH
82862: LD_INT 0
82864: ST_TO_ADDR
// uc_nation := 0 ;
82865: LD_ADDR_OWVAR 21
82869: PUSH
82870: LD_INT 0
82872: ST_TO_ADDR
// hc_class := class_frog ;
82873: LD_ADDR_OWVAR 28
82877: PUSH
82878: LD_INT 19
82880: ST_TO_ADDR
// hc_gallery :=  ;
82881: LD_ADDR_OWVAR 33
82885: PUSH
82886: LD_STRING 
82888: ST_TO_ADDR
// end ;
82889: LD_VAR 0 1
82893: RET
// export function PrepareFish ( ) ; begin
82894: LD_INT 0
82896: PPUSH
// uc_side := 0 ;
82897: LD_ADDR_OWVAR 20
82901: PUSH
82902: LD_INT 0
82904: ST_TO_ADDR
// uc_nation := 0 ;
82905: LD_ADDR_OWVAR 21
82909: PUSH
82910: LD_INT 0
82912: ST_TO_ADDR
// hc_class := class_fish ;
82913: LD_ADDR_OWVAR 28
82917: PUSH
82918: LD_INT 20
82920: ST_TO_ADDR
// hc_gallery :=  ;
82921: LD_ADDR_OWVAR 33
82925: PUSH
82926: LD_STRING 
82928: ST_TO_ADDR
// end ;
82929: LD_VAR 0 1
82933: RET
// export function PrepareBird ( ) ; begin
82934: LD_INT 0
82936: PPUSH
// uc_side := 0 ;
82937: LD_ADDR_OWVAR 20
82941: PUSH
82942: LD_INT 0
82944: ST_TO_ADDR
// uc_nation := 0 ;
82945: LD_ADDR_OWVAR 21
82949: PUSH
82950: LD_INT 0
82952: ST_TO_ADDR
// hc_class := class_phororhacos ;
82953: LD_ADDR_OWVAR 28
82957: PUSH
82958: LD_INT 18
82960: ST_TO_ADDR
// hc_gallery :=  ;
82961: LD_ADDR_OWVAR 33
82965: PUSH
82966: LD_STRING 
82968: ST_TO_ADDR
// end ;
82969: LD_VAR 0 1
82973: RET
// export function PrepareHorse ( ) ; begin
82974: LD_INT 0
82976: PPUSH
// uc_side := 0 ;
82977: LD_ADDR_OWVAR 20
82981: PUSH
82982: LD_INT 0
82984: ST_TO_ADDR
// uc_nation := 0 ;
82985: LD_ADDR_OWVAR 21
82989: PUSH
82990: LD_INT 0
82992: ST_TO_ADDR
// hc_class := class_horse ;
82993: LD_ADDR_OWVAR 28
82997: PUSH
82998: LD_INT 21
83000: ST_TO_ADDR
// hc_gallery :=  ;
83001: LD_ADDR_OWVAR 33
83005: PUSH
83006: LD_STRING 
83008: ST_TO_ADDR
// end ;
83009: LD_VAR 0 1
83013: RET
// export function PrepareMastodont ( ) ; begin
83014: LD_INT 0
83016: PPUSH
// uc_side := 0 ;
83017: LD_ADDR_OWVAR 20
83021: PUSH
83022: LD_INT 0
83024: ST_TO_ADDR
// uc_nation := 0 ;
83025: LD_ADDR_OWVAR 21
83029: PUSH
83030: LD_INT 0
83032: ST_TO_ADDR
// vc_chassis := class_mastodont ;
83033: LD_ADDR_OWVAR 37
83037: PUSH
83038: LD_INT 31
83040: ST_TO_ADDR
// vc_control := control_rider ;
83041: LD_ADDR_OWVAR 38
83045: PUSH
83046: LD_INT 4
83048: ST_TO_ADDR
// end ;
83049: LD_VAR 0 1
83053: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
83054: LD_INT 0
83056: PPUSH
83057: PPUSH
83058: PPUSH
// uc_side = 0 ;
83059: LD_ADDR_OWVAR 20
83063: PUSH
83064: LD_INT 0
83066: ST_TO_ADDR
// uc_nation = 0 ;
83067: LD_ADDR_OWVAR 21
83071: PUSH
83072: LD_INT 0
83074: ST_TO_ADDR
// InitHc_All ( ) ;
83075: CALL_OW 584
// InitVc ;
83079: CALL_OW 20
// if mastodonts then
83083: LD_VAR 0 6
83087: IFFALSE 83154
// for i = 1 to mastodonts do
83089: LD_ADDR_VAR 0 11
83093: PUSH
83094: DOUBLE
83095: LD_INT 1
83097: DEC
83098: ST_TO_ADDR
83099: LD_VAR 0 6
83103: PUSH
83104: FOR_TO
83105: IFFALSE 83152
// begin vc_chassis := 31 ;
83107: LD_ADDR_OWVAR 37
83111: PUSH
83112: LD_INT 31
83114: ST_TO_ADDR
// vc_control := control_rider ;
83115: LD_ADDR_OWVAR 38
83119: PUSH
83120: LD_INT 4
83122: ST_TO_ADDR
// animal := CreateVehicle ;
83123: LD_ADDR_VAR 0 12
83127: PUSH
83128: CALL_OW 45
83132: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83133: LD_VAR 0 12
83137: PPUSH
83138: LD_VAR 0 8
83142: PPUSH
83143: LD_INT 0
83145: PPUSH
83146: CALL 85282 0 3
// end ;
83150: GO 83104
83152: POP
83153: POP
// if horses then
83154: LD_VAR 0 5
83158: IFFALSE 83225
// for i = 1 to horses do
83160: LD_ADDR_VAR 0 11
83164: PUSH
83165: DOUBLE
83166: LD_INT 1
83168: DEC
83169: ST_TO_ADDR
83170: LD_VAR 0 5
83174: PUSH
83175: FOR_TO
83176: IFFALSE 83223
// begin hc_class := 21 ;
83178: LD_ADDR_OWVAR 28
83182: PUSH
83183: LD_INT 21
83185: ST_TO_ADDR
// hc_gallery :=  ;
83186: LD_ADDR_OWVAR 33
83190: PUSH
83191: LD_STRING 
83193: ST_TO_ADDR
// animal := CreateHuman ;
83194: LD_ADDR_VAR 0 12
83198: PUSH
83199: CALL_OW 44
83203: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83204: LD_VAR 0 12
83208: PPUSH
83209: LD_VAR 0 8
83213: PPUSH
83214: LD_INT 0
83216: PPUSH
83217: CALL 85282 0 3
// end ;
83221: GO 83175
83223: POP
83224: POP
// if birds then
83225: LD_VAR 0 1
83229: IFFALSE 83296
// for i = 1 to birds do
83231: LD_ADDR_VAR 0 11
83235: PUSH
83236: DOUBLE
83237: LD_INT 1
83239: DEC
83240: ST_TO_ADDR
83241: LD_VAR 0 1
83245: PUSH
83246: FOR_TO
83247: IFFALSE 83294
// begin hc_class = 18 ;
83249: LD_ADDR_OWVAR 28
83253: PUSH
83254: LD_INT 18
83256: ST_TO_ADDR
// hc_gallery =  ;
83257: LD_ADDR_OWVAR 33
83261: PUSH
83262: LD_STRING 
83264: ST_TO_ADDR
// animal := CreateHuman ;
83265: LD_ADDR_VAR 0 12
83269: PUSH
83270: CALL_OW 44
83274: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83275: LD_VAR 0 12
83279: PPUSH
83280: LD_VAR 0 8
83284: PPUSH
83285: LD_INT 0
83287: PPUSH
83288: CALL 85282 0 3
// end ;
83292: GO 83246
83294: POP
83295: POP
// if tigers then
83296: LD_VAR 0 2
83300: IFFALSE 83384
// for i = 1 to tigers do
83302: LD_ADDR_VAR 0 11
83306: PUSH
83307: DOUBLE
83308: LD_INT 1
83310: DEC
83311: ST_TO_ADDR
83312: LD_VAR 0 2
83316: PUSH
83317: FOR_TO
83318: IFFALSE 83382
// begin hc_class = class_tiger ;
83320: LD_ADDR_OWVAR 28
83324: PUSH
83325: LD_INT 14
83327: ST_TO_ADDR
// hc_gallery =  ;
83328: LD_ADDR_OWVAR 33
83332: PUSH
83333: LD_STRING 
83335: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
83336: LD_ADDR_OWVAR 35
83340: PUSH
83341: LD_INT 7
83343: NEG
83344: PPUSH
83345: LD_INT 7
83347: PPUSH
83348: CALL_OW 12
83352: ST_TO_ADDR
// animal := CreateHuman ;
83353: LD_ADDR_VAR 0 12
83357: PUSH
83358: CALL_OW 44
83362: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83363: LD_VAR 0 12
83367: PPUSH
83368: LD_VAR 0 8
83372: PPUSH
83373: LD_INT 0
83375: PPUSH
83376: CALL 85282 0 3
// end ;
83380: GO 83317
83382: POP
83383: POP
// if apemans then
83384: LD_VAR 0 3
83388: IFFALSE 83511
// for i = 1 to apemans do
83390: LD_ADDR_VAR 0 11
83394: PUSH
83395: DOUBLE
83396: LD_INT 1
83398: DEC
83399: ST_TO_ADDR
83400: LD_VAR 0 3
83404: PUSH
83405: FOR_TO
83406: IFFALSE 83509
// begin hc_class = class_apeman ;
83408: LD_ADDR_OWVAR 28
83412: PUSH
83413: LD_INT 12
83415: ST_TO_ADDR
// hc_gallery =  ;
83416: LD_ADDR_OWVAR 33
83420: PUSH
83421: LD_STRING 
83423: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
83424: LD_ADDR_OWVAR 35
83428: PUSH
83429: LD_INT 2
83431: NEG
83432: PPUSH
83433: LD_INT 2
83435: PPUSH
83436: CALL_OW 12
83440: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
83441: LD_ADDR_OWVAR 31
83445: PUSH
83446: LD_INT 1
83448: PPUSH
83449: LD_INT 3
83451: PPUSH
83452: CALL_OW 12
83456: PUSH
83457: LD_INT 1
83459: PPUSH
83460: LD_INT 3
83462: PPUSH
83463: CALL_OW 12
83467: PUSH
83468: LD_INT 0
83470: PUSH
83471: LD_INT 0
83473: PUSH
83474: EMPTY
83475: LIST
83476: LIST
83477: LIST
83478: LIST
83479: ST_TO_ADDR
// animal := CreateHuman ;
83480: LD_ADDR_VAR 0 12
83484: PUSH
83485: CALL_OW 44
83489: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83490: LD_VAR 0 12
83494: PPUSH
83495: LD_VAR 0 8
83499: PPUSH
83500: LD_INT 0
83502: PPUSH
83503: CALL 85282 0 3
// end ;
83507: GO 83405
83509: POP
83510: POP
// if enchidnas then
83511: LD_VAR 0 4
83515: IFFALSE 83582
// for i = 1 to enchidnas do
83517: LD_ADDR_VAR 0 11
83521: PUSH
83522: DOUBLE
83523: LD_INT 1
83525: DEC
83526: ST_TO_ADDR
83527: LD_VAR 0 4
83531: PUSH
83532: FOR_TO
83533: IFFALSE 83580
// begin hc_class = 13 ;
83535: LD_ADDR_OWVAR 28
83539: PUSH
83540: LD_INT 13
83542: ST_TO_ADDR
// hc_gallery =  ;
83543: LD_ADDR_OWVAR 33
83547: PUSH
83548: LD_STRING 
83550: ST_TO_ADDR
// animal := CreateHuman ;
83551: LD_ADDR_VAR 0 12
83555: PUSH
83556: CALL_OW 44
83560: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83561: LD_VAR 0 12
83565: PPUSH
83566: LD_VAR 0 8
83570: PPUSH
83571: LD_INT 0
83573: PPUSH
83574: CALL 85282 0 3
// end ;
83578: GO 83532
83580: POP
83581: POP
// if fishes then
83582: LD_VAR 0 7
83586: IFFALSE 83653
// for i = 1 to fishes do
83588: LD_ADDR_VAR 0 11
83592: PUSH
83593: DOUBLE
83594: LD_INT 1
83596: DEC
83597: ST_TO_ADDR
83598: LD_VAR 0 7
83602: PUSH
83603: FOR_TO
83604: IFFALSE 83651
// begin hc_class = 20 ;
83606: LD_ADDR_OWVAR 28
83610: PUSH
83611: LD_INT 20
83613: ST_TO_ADDR
// hc_gallery =  ;
83614: LD_ADDR_OWVAR 33
83618: PUSH
83619: LD_STRING 
83621: ST_TO_ADDR
// animal := CreateHuman ;
83622: LD_ADDR_VAR 0 12
83626: PUSH
83627: CALL_OW 44
83631: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
83632: LD_VAR 0 12
83636: PPUSH
83637: LD_VAR 0 9
83641: PPUSH
83642: LD_INT 0
83644: PPUSH
83645: CALL 85282 0 3
// end ;
83649: GO 83603
83651: POP
83652: POP
// end ;
83653: LD_VAR 0 10
83657: RET
// export function WantHeal ( sci , unit ) ; begin
83658: LD_INT 0
83660: PPUSH
// if GetTaskList ( sci ) > 0 then
83661: LD_VAR 0 1
83665: PPUSH
83666: CALL_OW 437
83670: PUSH
83671: LD_INT 0
83673: GREATER
83674: IFFALSE 83744
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
83676: LD_VAR 0 1
83680: PPUSH
83681: CALL_OW 437
83685: PUSH
83686: LD_INT 1
83688: ARRAY
83689: PUSH
83690: LD_INT 1
83692: ARRAY
83693: PUSH
83694: LD_STRING l
83696: EQUAL
83697: PUSH
83698: LD_VAR 0 1
83702: PPUSH
83703: CALL_OW 437
83707: PUSH
83708: LD_INT 1
83710: ARRAY
83711: PUSH
83712: LD_INT 4
83714: ARRAY
83715: PUSH
83716: LD_VAR 0 2
83720: EQUAL
83721: AND
83722: IFFALSE 83734
// result := true else
83724: LD_ADDR_VAR 0 3
83728: PUSH
83729: LD_INT 1
83731: ST_TO_ADDR
83732: GO 83742
// result := false ;
83734: LD_ADDR_VAR 0 3
83738: PUSH
83739: LD_INT 0
83741: ST_TO_ADDR
// end else
83742: GO 83752
// result := false ;
83744: LD_ADDR_VAR 0 3
83748: PUSH
83749: LD_INT 0
83751: ST_TO_ADDR
// end ;
83752: LD_VAR 0 3
83756: RET
// export function HealTarget ( sci ) ; begin
83757: LD_INT 0
83759: PPUSH
// if not sci then
83760: LD_VAR 0 1
83764: NOT
83765: IFFALSE 83769
// exit ;
83767: GO 83834
// result := 0 ;
83769: LD_ADDR_VAR 0 2
83773: PUSH
83774: LD_INT 0
83776: ST_TO_ADDR
// if GetTaskList ( sci ) then
83777: LD_VAR 0 1
83781: PPUSH
83782: CALL_OW 437
83786: IFFALSE 83834
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
83788: LD_VAR 0 1
83792: PPUSH
83793: CALL_OW 437
83797: PUSH
83798: LD_INT 1
83800: ARRAY
83801: PUSH
83802: LD_INT 1
83804: ARRAY
83805: PUSH
83806: LD_STRING l
83808: EQUAL
83809: IFFALSE 83834
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
83811: LD_ADDR_VAR 0 2
83815: PUSH
83816: LD_VAR 0 1
83820: PPUSH
83821: CALL_OW 437
83825: PUSH
83826: LD_INT 1
83828: ARRAY
83829: PUSH
83830: LD_INT 4
83832: ARRAY
83833: ST_TO_ADDR
// end ;
83834: LD_VAR 0 2
83838: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
83839: LD_INT 0
83841: PPUSH
83842: PPUSH
83843: PPUSH
83844: PPUSH
// if not base_units then
83845: LD_VAR 0 1
83849: NOT
83850: IFFALSE 83854
// exit ;
83852: GO 83941
// result := false ;
83854: LD_ADDR_VAR 0 2
83858: PUSH
83859: LD_INT 0
83861: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
83862: LD_ADDR_VAR 0 5
83866: PUSH
83867: LD_VAR 0 1
83871: PPUSH
83872: LD_INT 21
83874: PUSH
83875: LD_INT 3
83877: PUSH
83878: EMPTY
83879: LIST
83880: LIST
83881: PPUSH
83882: CALL_OW 72
83886: ST_TO_ADDR
// if not tmp then
83887: LD_VAR 0 5
83891: NOT
83892: IFFALSE 83896
// exit ;
83894: GO 83941
// for i in tmp do
83896: LD_ADDR_VAR 0 3
83900: PUSH
83901: LD_VAR 0 5
83905: PUSH
83906: FOR_IN
83907: IFFALSE 83939
// begin result := EnemyInRange ( i , 22 ) ;
83909: LD_ADDR_VAR 0 2
83913: PUSH
83914: LD_VAR 0 3
83918: PPUSH
83919: LD_INT 22
83921: PPUSH
83922: CALL 81528 0 2
83926: ST_TO_ADDR
// if result then
83927: LD_VAR 0 2
83931: IFFALSE 83937
// exit ;
83933: POP
83934: POP
83935: GO 83941
// end ;
83937: GO 83906
83939: POP
83940: POP
// end ;
83941: LD_VAR 0 2
83945: RET
// export function FilterByTag ( units , tag ) ; begin
83946: LD_INT 0
83948: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
83949: LD_ADDR_VAR 0 3
83953: PUSH
83954: LD_VAR 0 1
83958: PPUSH
83959: LD_INT 120
83961: PUSH
83962: LD_VAR 0 2
83966: PUSH
83967: EMPTY
83968: LIST
83969: LIST
83970: PPUSH
83971: CALL_OW 72
83975: ST_TO_ADDR
// end ;
83976: LD_VAR 0 3
83980: RET
// export function IsDriver ( un ) ; begin
83981: LD_INT 0
83983: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
83984: LD_ADDR_VAR 0 2
83988: PUSH
83989: LD_VAR 0 1
83993: PUSH
83994: LD_INT 55
83996: PUSH
83997: EMPTY
83998: LIST
83999: PPUSH
84000: CALL_OW 69
84004: IN
84005: ST_TO_ADDR
// end ;
84006: LD_VAR 0 2
84010: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
84011: LD_INT 0
84013: PPUSH
84014: PPUSH
// list := [ ] ;
84015: LD_ADDR_VAR 0 5
84019: PUSH
84020: EMPTY
84021: ST_TO_ADDR
// case d of 0 :
84022: LD_VAR 0 3
84026: PUSH
84027: LD_INT 0
84029: DOUBLE
84030: EQUAL
84031: IFTRUE 84035
84033: GO 84168
84035: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
84036: LD_ADDR_VAR 0 5
84040: PUSH
84041: LD_VAR 0 1
84045: PUSH
84046: LD_INT 4
84048: MINUS
84049: PUSH
84050: LD_VAR 0 2
84054: PUSH
84055: LD_INT 4
84057: MINUS
84058: PUSH
84059: LD_INT 2
84061: PUSH
84062: EMPTY
84063: LIST
84064: LIST
84065: LIST
84066: PUSH
84067: LD_VAR 0 1
84071: PUSH
84072: LD_INT 3
84074: MINUS
84075: PUSH
84076: LD_VAR 0 2
84080: PUSH
84081: LD_INT 1
84083: PUSH
84084: EMPTY
84085: LIST
84086: LIST
84087: LIST
84088: PUSH
84089: LD_VAR 0 1
84093: PUSH
84094: LD_INT 4
84096: PLUS
84097: PUSH
84098: LD_VAR 0 2
84102: PUSH
84103: LD_INT 4
84105: PUSH
84106: EMPTY
84107: LIST
84108: LIST
84109: LIST
84110: PUSH
84111: LD_VAR 0 1
84115: PUSH
84116: LD_INT 3
84118: PLUS
84119: PUSH
84120: LD_VAR 0 2
84124: PUSH
84125: LD_INT 3
84127: PLUS
84128: PUSH
84129: LD_INT 5
84131: PUSH
84132: EMPTY
84133: LIST
84134: LIST
84135: LIST
84136: PUSH
84137: LD_VAR 0 1
84141: PUSH
84142: LD_VAR 0 2
84146: PUSH
84147: LD_INT 4
84149: PLUS
84150: PUSH
84151: LD_INT 0
84153: PUSH
84154: EMPTY
84155: LIST
84156: LIST
84157: LIST
84158: PUSH
84159: EMPTY
84160: LIST
84161: LIST
84162: LIST
84163: LIST
84164: LIST
84165: ST_TO_ADDR
// end ; 1 :
84166: GO 84866
84168: LD_INT 1
84170: DOUBLE
84171: EQUAL
84172: IFTRUE 84176
84174: GO 84309
84176: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
84177: LD_ADDR_VAR 0 5
84181: PUSH
84182: LD_VAR 0 1
84186: PUSH
84187: LD_VAR 0 2
84191: PUSH
84192: LD_INT 4
84194: MINUS
84195: PUSH
84196: LD_INT 3
84198: PUSH
84199: EMPTY
84200: LIST
84201: LIST
84202: LIST
84203: PUSH
84204: LD_VAR 0 1
84208: PUSH
84209: LD_INT 3
84211: MINUS
84212: PUSH
84213: LD_VAR 0 2
84217: PUSH
84218: LD_INT 3
84220: MINUS
84221: PUSH
84222: LD_INT 2
84224: PUSH
84225: EMPTY
84226: LIST
84227: LIST
84228: LIST
84229: PUSH
84230: LD_VAR 0 1
84234: PUSH
84235: LD_INT 4
84237: MINUS
84238: PUSH
84239: LD_VAR 0 2
84243: PUSH
84244: LD_INT 1
84246: PUSH
84247: EMPTY
84248: LIST
84249: LIST
84250: LIST
84251: PUSH
84252: LD_VAR 0 1
84256: PUSH
84257: LD_VAR 0 2
84261: PUSH
84262: LD_INT 3
84264: PLUS
84265: PUSH
84266: LD_INT 0
84268: PUSH
84269: EMPTY
84270: LIST
84271: LIST
84272: LIST
84273: PUSH
84274: LD_VAR 0 1
84278: PUSH
84279: LD_INT 4
84281: PLUS
84282: PUSH
84283: LD_VAR 0 2
84287: PUSH
84288: LD_INT 4
84290: PLUS
84291: PUSH
84292: LD_INT 5
84294: PUSH
84295: EMPTY
84296: LIST
84297: LIST
84298: LIST
84299: PUSH
84300: EMPTY
84301: LIST
84302: LIST
84303: LIST
84304: LIST
84305: LIST
84306: ST_TO_ADDR
// end ; 2 :
84307: GO 84866
84309: LD_INT 2
84311: DOUBLE
84312: EQUAL
84313: IFTRUE 84317
84315: GO 84446
84317: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
84318: LD_ADDR_VAR 0 5
84322: PUSH
84323: LD_VAR 0 1
84327: PUSH
84328: LD_VAR 0 2
84332: PUSH
84333: LD_INT 3
84335: MINUS
84336: PUSH
84337: LD_INT 3
84339: PUSH
84340: EMPTY
84341: LIST
84342: LIST
84343: LIST
84344: PUSH
84345: LD_VAR 0 1
84349: PUSH
84350: LD_INT 4
84352: PLUS
84353: PUSH
84354: LD_VAR 0 2
84358: PUSH
84359: LD_INT 4
84361: PUSH
84362: EMPTY
84363: LIST
84364: LIST
84365: LIST
84366: PUSH
84367: LD_VAR 0 1
84371: PUSH
84372: LD_VAR 0 2
84376: PUSH
84377: LD_INT 4
84379: PLUS
84380: PUSH
84381: LD_INT 0
84383: PUSH
84384: EMPTY
84385: LIST
84386: LIST
84387: LIST
84388: PUSH
84389: LD_VAR 0 1
84393: PUSH
84394: LD_INT 3
84396: MINUS
84397: PUSH
84398: LD_VAR 0 2
84402: PUSH
84403: LD_INT 1
84405: PUSH
84406: EMPTY
84407: LIST
84408: LIST
84409: LIST
84410: PUSH
84411: LD_VAR 0 1
84415: PUSH
84416: LD_INT 4
84418: MINUS
84419: PUSH
84420: LD_VAR 0 2
84424: PUSH
84425: LD_INT 4
84427: MINUS
84428: PUSH
84429: LD_INT 2
84431: PUSH
84432: EMPTY
84433: LIST
84434: LIST
84435: LIST
84436: PUSH
84437: EMPTY
84438: LIST
84439: LIST
84440: LIST
84441: LIST
84442: LIST
84443: ST_TO_ADDR
// end ; 3 :
84444: GO 84866
84446: LD_INT 3
84448: DOUBLE
84449: EQUAL
84450: IFTRUE 84454
84452: GO 84587
84454: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
84455: LD_ADDR_VAR 0 5
84459: PUSH
84460: LD_VAR 0 1
84464: PUSH
84465: LD_INT 3
84467: PLUS
84468: PUSH
84469: LD_VAR 0 2
84473: PUSH
84474: LD_INT 4
84476: PUSH
84477: EMPTY
84478: LIST
84479: LIST
84480: LIST
84481: PUSH
84482: LD_VAR 0 1
84486: PUSH
84487: LD_INT 4
84489: PLUS
84490: PUSH
84491: LD_VAR 0 2
84495: PUSH
84496: LD_INT 4
84498: PLUS
84499: PUSH
84500: LD_INT 5
84502: PUSH
84503: EMPTY
84504: LIST
84505: LIST
84506: LIST
84507: PUSH
84508: LD_VAR 0 1
84512: PUSH
84513: LD_INT 4
84515: MINUS
84516: PUSH
84517: LD_VAR 0 2
84521: PUSH
84522: LD_INT 1
84524: PUSH
84525: EMPTY
84526: LIST
84527: LIST
84528: LIST
84529: PUSH
84530: LD_VAR 0 1
84534: PUSH
84535: LD_VAR 0 2
84539: PUSH
84540: LD_INT 4
84542: MINUS
84543: PUSH
84544: LD_INT 3
84546: PUSH
84547: EMPTY
84548: LIST
84549: LIST
84550: LIST
84551: PUSH
84552: LD_VAR 0 1
84556: PUSH
84557: LD_INT 3
84559: MINUS
84560: PUSH
84561: LD_VAR 0 2
84565: PUSH
84566: LD_INT 3
84568: MINUS
84569: PUSH
84570: LD_INT 2
84572: PUSH
84573: EMPTY
84574: LIST
84575: LIST
84576: LIST
84577: PUSH
84578: EMPTY
84579: LIST
84580: LIST
84581: LIST
84582: LIST
84583: LIST
84584: ST_TO_ADDR
// end ; 4 :
84585: GO 84866
84587: LD_INT 4
84589: DOUBLE
84590: EQUAL
84591: IFTRUE 84595
84593: GO 84728
84595: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
84596: LD_ADDR_VAR 0 5
84600: PUSH
84601: LD_VAR 0 1
84605: PUSH
84606: LD_VAR 0 2
84610: PUSH
84611: LD_INT 4
84613: PLUS
84614: PUSH
84615: LD_INT 0
84617: PUSH
84618: EMPTY
84619: LIST
84620: LIST
84621: LIST
84622: PUSH
84623: LD_VAR 0 1
84627: PUSH
84628: LD_INT 3
84630: PLUS
84631: PUSH
84632: LD_VAR 0 2
84636: PUSH
84637: LD_INT 3
84639: PLUS
84640: PUSH
84641: LD_INT 5
84643: PUSH
84644: EMPTY
84645: LIST
84646: LIST
84647: LIST
84648: PUSH
84649: LD_VAR 0 1
84653: PUSH
84654: LD_INT 4
84656: PLUS
84657: PUSH
84658: LD_VAR 0 2
84662: PUSH
84663: LD_INT 4
84665: PUSH
84666: EMPTY
84667: LIST
84668: LIST
84669: LIST
84670: PUSH
84671: LD_VAR 0 1
84675: PUSH
84676: LD_VAR 0 2
84680: PUSH
84681: LD_INT 3
84683: MINUS
84684: PUSH
84685: LD_INT 3
84687: PUSH
84688: EMPTY
84689: LIST
84690: LIST
84691: LIST
84692: PUSH
84693: LD_VAR 0 1
84697: PUSH
84698: LD_INT 4
84700: MINUS
84701: PUSH
84702: LD_VAR 0 2
84706: PUSH
84707: LD_INT 4
84709: MINUS
84710: PUSH
84711: LD_INT 2
84713: PUSH
84714: EMPTY
84715: LIST
84716: LIST
84717: LIST
84718: PUSH
84719: EMPTY
84720: LIST
84721: LIST
84722: LIST
84723: LIST
84724: LIST
84725: ST_TO_ADDR
// end ; 5 :
84726: GO 84866
84728: LD_INT 5
84730: DOUBLE
84731: EQUAL
84732: IFTRUE 84736
84734: GO 84865
84736: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
84737: LD_ADDR_VAR 0 5
84741: PUSH
84742: LD_VAR 0 1
84746: PUSH
84747: LD_INT 4
84749: MINUS
84750: PUSH
84751: LD_VAR 0 2
84755: PUSH
84756: LD_INT 1
84758: PUSH
84759: EMPTY
84760: LIST
84761: LIST
84762: LIST
84763: PUSH
84764: LD_VAR 0 1
84768: PUSH
84769: LD_VAR 0 2
84773: PUSH
84774: LD_INT 4
84776: MINUS
84777: PUSH
84778: LD_INT 3
84780: PUSH
84781: EMPTY
84782: LIST
84783: LIST
84784: LIST
84785: PUSH
84786: LD_VAR 0 1
84790: PUSH
84791: LD_INT 4
84793: PLUS
84794: PUSH
84795: LD_VAR 0 2
84799: PUSH
84800: LD_INT 4
84802: PLUS
84803: PUSH
84804: LD_INT 5
84806: PUSH
84807: EMPTY
84808: LIST
84809: LIST
84810: LIST
84811: PUSH
84812: LD_VAR 0 1
84816: PUSH
84817: LD_INT 3
84819: PLUS
84820: PUSH
84821: LD_VAR 0 2
84825: PUSH
84826: LD_INT 4
84828: PUSH
84829: EMPTY
84830: LIST
84831: LIST
84832: LIST
84833: PUSH
84834: LD_VAR 0 1
84838: PUSH
84839: LD_VAR 0 2
84843: PUSH
84844: LD_INT 3
84846: PLUS
84847: PUSH
84848: LD_INT 0
84850: PUSH
84851: EMPTY
84852: LIST
84853: LIST
84854: LIST
84855: PUSH
84856: EMPTY
84857: LIST
84858: LIST
84859: LIST
84860: LIST
84861: LIST
84862: ST_TO_ADDR
// end ; end ;
84863: GO 84866
84865: POP
// result := list ;
84866: LD_ADDR_VAR 0 4
84870: PUSH
84871: LD_VAR 0 5
84875: ST_TO_ADDR
// end ;
84876: LD_VAR 0 4
84880: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
84881: LD_INT 0
84883: PPUSH
84884: PPUSH
84885: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
84886: LD_VAR 0 1
84890: NOT
84891: PUSH
84892: LD_VAR 0 2
84896: PUSH
84897: LD_INT 1
84899: PUSH
84900: LD_INT 2
84902: PUSH
84903: LD_INT 3
84905: PUSH
84906: LD_INT 4
84908: PUSH
84909: EMPTY
84910: LIST
84911: LIST
84912: LIST
84913: LIST
84914: IN
84915: NOT
84916: OR
84917: IFFALSE 84921
// exit ;
84919: GO 85004
// tmp := [ ] ;
84921: LD_ADDR_VAR 0 5
84925: PUSH
84926: EMPTY
84927: ST_TO_ADDR
// for i in units do
84928: LD_ADDR_VAR 0 4
84932: PUSH
84933: LD_VAR 0 1
84937: PUSH
84938: FOR_IN
84939: IFFALSE 84973
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
84941: LD_ADDR_VAR 0 5
84945: PUSH
84946: LD_VAR 0 5
84950: PPUSH
84951: LD_VAR 0 4
84955: PPUSH
84956: LD_VAR 0 2
84960: PPUSH
84961: CALL_OW 259
84965: PPUSH
84966: CALL 86364 0 2
84970: ST_TO_ADDR
84971: GO 84938
84973: POP
84974: POP
// if not tmp then
84975: LD_VAR 0 5
84979: NOT
84980: IFFALSE 84984
// exit ;
84982: GO 85004
// result := SortListByListDesc ( units , tmp ) ;
84984: LD_ADDR_VAR 0 3
84988: PUSH
84989: LD_VAR 0 1
84993: PPUSH
84994: LD_VAR 0 5
84998: PPUSH
84999: CALL_OW 77
85003: ST_TO_ADDR
// end ;
85004: LD_VAR 0 3
85008: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
85009: LD_INT 0
85011: PPUSH
85012: PPUSH
85013: PPUSH
// result := false ;
85014: LD_ADDR_VAR 0 3
85018: PUSH
85019: LD_INT 0
85021: ST_TO_ADDR
// if not building then
85022: LD_VAR 0 2
85026: NOT
85027: IFFALSE 85031
// exit ;
85029: GO 85169
// x := GetX ( building ) ;
85031: LD_ADDR_VAR 0 4
85035: PUSH
85036: LD_VAR 0 2
85040: PPUSH
85041: CALL_OW 250
85045: ST_TO_ADDR
// y := GetY ( building ) ;
85046: LD_ADDR_VAR 0 5
85050: PUSH
85051: LD_VAR 0 2
85055: PPUSH
85056: CALL_OW 251
85060: ST_TO_ADDR
// if not x or not y then
85061: LD_VAR 0 4
85065: NOT
85066: PUSH
85067: LD_VAR 0 5
85071: NOT
85072: OR
85073: IFFALSE 85077
// exit ;
85075: GO 85169
// if GetTaskList ( unit ) then
85077: LD_VAR 0 1
85081: PPUSH
85082: CALL_OW 437
85086: IFFALSE 85169
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
85088: LD_STRING e
85090: PUSH
85091: LD_VAR 0 1
85095: PPUSH
85096: CALL_OW 437
85100: PUSH
85101: LD_INT 1
85103: ARRAY
85104: PUSH
85105: LD_INT 1
85107: ARRAY
85108: EQUAL
85109: PUSH
85110: LD_VAR 0 4
85114: PUSH
85115: LD_VAR 0 1
85119: PPUSH
85120: CALL_OW 437
85124: PUSH
85125: LD_INT 1
85127: ARRAY
85128: PUSH
85129: LD_INT 2
85131: ARRAY
85132: EQUAL
85133: AND
85134: PUSH
85135: LD_VAR 0 5
85139: PUSH
85140: LD_VAR 0 1
85144: PPUSH
85145: CALL_OW 437
85149: PUSH
85150: LD_INT 1
85152: ARRAY
85153: PUSH
85154: LD_INT 3
85156: ARRAY
85157: EQUAL
85158: AND
85159: IFFALSE 85169
// result := true end ;
85161: LD_ADDR_VAR 0 3
85165: PUSH
85166: LD_INT 1
85168: ST_TO_ADDR
// end ;
85169: LD_VAR 0 3
85173: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
85174: LD_INT 0
85176: PPUSH
// result := false ;
85177: LD_ADDR_VAR 0 4
85181: PUSH
85182: LD_INT 0
85184: ST_TO_ADDR
// if GetTaskList ( unit ) then
85185: LD_VAR 0 1
85189: PPUSH
85190: CALL_OW 437
85194: IFFALSE 85277
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
85196: LD_STRING M
85198: PUSH
85199: LD_VAR 0 1
85203: PPUSH
85204: CALL_OW 437
85208: PUSH
85209: LD_INT 1
85211: ARRAY
85212: PUSH
85213: LD_INT 1
85215: ARRAY
85216: EQUAL
85217: PUSH
85218: LD_VAR 0 2
85222: PUSH
85223: LD_VAR 0 1
85227: PPUSH
85228: CALL_OW 437
85232: PUSH
85233: LD_INT 1
85235: ARRAY
85236: PUSH
85237: LD_INT 2
85239: ARRAY
85240: EQUAL
85241: AND
85242: PUSH
85243: LD_VAR 0 3
85247: PUSH
85248: LD_VAR 0 1
85252: PPUSH
85253: CALL_OW 437
85257: PUSH
85258: LD_INT 1
85260: ARRAY
85261: PUSH
85262: LD_INT 3
85264: ARRAY
85265: EQUAL
85266: AND
85267: IFFALSE 85277
// result := true ;
85269: LD_ADDR_VAR 0 4
85273: PUSH
85274: LD_INT 1
85276: ST_TO_ADDR
// end ; end ;
85277: LD_VAR 0 4
85281: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
85282: LD_INT 0
85284: PPUSH
85285: PPUSH
85286: PPUSH
85287: PPUSH
// if not unit or not area then
85288: LD_VAR 0 1
85292: NOT
85293: PUSH
85294: LD_VAR 0 2
85298: NOT
85299: OR
85300: IFFALSE 85304
// exit ;
85302: GO 85467
// tmp := AreaToList ( area , i ) ;
85304: LD_ADDR_VAR 0 6
85308: PUSH
85309: LD_VAR 0 2
85313: PPUSH
85314: LD_VAR 0 5
85318: PPUSH
85319: CALL_OW 517
85323: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
85324: LD_ADDR_VAR 0 5
85328: PUSH
85329: DOUBLE
85330: LD_INT 1
85332: DEC
85333: ST_TO_ADDR
85334: LD_VAR 0 6
85338: PUSH
85339: LD_INT 1
85341: ARRAY
85342: PUSH
85343: FOR_TO
85344: IFFALSE 85465
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
85346: LD_ADDR_VAR 0 7
85350: PUSH
85351: LD_VAR 0 6
85355: PUSH
85356: LD_INT 1
85358: ARRAY
85359: PUSH
85360: LD_VAR 0 5
85364: ARRAY
85365: PUSH
85366: LD_VAR 0 6
85370: PUSH
85371: LD_INT 2
85373: ARRAY
85374: PUSH
85375: LD_VAR 0 5
85379: ARRAY
85380: PUSH
85381: EMPTY
85382: LIST
85383: LIST
85384: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 3 ] ) = 0 then
85385: LD_INT 92
85387: PUSH
85388: LD_VAR 0 7
85392: PUSH
85393: LD_INT 1
85395: ARRAY
85396: PUSH
85397: LD_VAR 0 7
85401: PUSH
85402: LD_INT 2
85404: ARRAY
85405: PUSH
85406: LD_INT 3
85408: PUSH
85409: EMPTY
85410: LIST
85411: LIST
85412: LIST
85413: LIST
85414: PPUSH
85415: CALL_OW 69
85419: PUSH
85420: LD_INT 0
85422: EQUAL
85423: IFFALSE 85463
// begin PlaceUnitArea ( unit , area , mode ) ;
85425: LD_VAR 0 1
85429: PPUSH
85430: LD_VAR 0 2
85434: PPUSH
85435: LD_VAR 0 3
85439: PPUSH
85440: CALL_OW 49
// result := IsPlaced ( unit ) ;
85444: LD_ADDR_VAR 0 4
85448: PUSH
85449: LD_VAR 0 1
85453: PPUSH
85454: CALL_OW 305
85458: ST_TO_ADDR
// exit ;
85459: POP
85460: POP
85461: GO 85467
// end ; end ;
85463: GO 85343
85465: POP
85466: POP
// end ;
85467: LD_VAR 0 4
85471: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
85472: LD_INT 0
85474: PPUSH
85475: PPUSH
85476: PPUSH
// if not side or side > 8 then
85477: LD_VAR 0 1
85481: NOT
85482: PUSH
85483: LD_VAR 0 1
85487: PUSH
85488: LD_INT 8
85490: GREATER
85491: OR
85492: IFFALSE 85496
// exit ;
85494: GO 85683
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
85496: LD_ADDR_VAR 0 4
85500: PUSH
85501: LD_INT 22
85503: PUSH
85504: LD_VAR 0 1
85508: PUSH
85509: EMPTY
85510: LIST
85511: LIST
85512: PUSH
85513: LD_INT 21
85515: PUSH
85516: LD_INT 3
85518: PUSH
85519: EMPTY
85520: LIST
85521: LIST
85522: PUSH
85523: EMPTY
85524: LIST
85525: LIST
85526: PPUSH
85527: CALL_OW 69
85531: ST_TO_ADDR
// if not tmp then
85532: LD_VAR 0 4
85536: NOT
85537: IFFALSE 85541
// exit ;
85539: GO 85683
// enable_addtolog := true ;
85541: LD_ADDR_OWVAR 81
85545: PUSH
85546: LD_INT 1
85548: ST_TO_ADDR
// AddToLog ( [ ) ;
85549: LD_STRING [
85551: PPUSH
85552: CALL_OW 561
// for i in tmp do
85556: LD_ADDR_VAR 0 3
85560: PUSH
85561: LD_VAR 0 4
85565: PUSH
85566: FOR_IN
85567: IFFALSE 85674
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
85569: LD_STRING [
85571: PUSH
85572: LD_VAR 0 3
85576: PPUSH
85577: CALL_OW 266
85581: STR
85582: PUSH
85583: LD_STRING , 
85585: STR
85586: PUSH
85587: LD_VAR 0 3
85591: PPUSH
85592: CALL_OW 250
85596: STR
85597: PUSH
85598: LD_STRING , 
85600: STR
85601: PUSH
85602: LD_VAR 0 3
85606: PPUSH
85607: CALL_OW 251
85611: STR
85612: PUSH
85613: LD_STRING , 
85615: STR
85616: PUSH
85617: LD_VAR 0 3
85621: PPUSH
85622: CALL_OW 254
85626: STR
85627: PUSH
85628: LD_STRING , 
85630: STR
85631: PUSH
85632: LD_VAR 0 3
85636: PPUSH
85637: LD_INT 1
85639: PPUSH
85640: CALL_OW 268
85644: STR
85645: PUSH
85646: LD_STRING , 
85648: STR
85649: PUSH
85650: LD_VAR 0 3
85654: PPUSH
85655: LD_INT 2
85657: PPUSH
85658: CALL_OW 268
85662: STR
85663: PUSH
85664: LD_STRING ],
85666: STR
85667: PPUSH
85668: CALL_OW 561
// end ;
85672: GO 85566
85674: POP
85675: POP
// AddToLog ( ]; ) ;
85676: LD_STRING ];
85678: PPUSH
85679: CALL_OW 561
// end ;
85683: LD_VAR 0 2
85687: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
85688: LD_INT 0
85690: PPUSH
85691: PPUSH
85692: PPUSH
85693: PPUSH
85694: PPUSH
// if not area or not rate or not max then
85695: LD_VAR 0 1
85699: NOT
85700: PUSH
85701: LD_VAR 0 2
85705: NOT
85706: OR
85707: PUSH
85708: LD_VAR 0 4
85712: NOT
85713: OR
85714: IFFALSE 85718
// exit ;
85716: GO 85907
// while 1 do
85718: LD_INT 1
85720: IFFALSE 85907
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
85722: LD_ADDR_VAR 0 9
85726: PUSH
85727: LD_VAR 0 1
85731: PPUSH
85732: LD_INT 1
85734: PPUSH
85735: CALL_OW 287
85739: PUSH
85740: LD_INT 10
85742: MUL
85743: ST_TO_ADDR
// r := rate / 10 ;
85744: LD_ADDR_VAR 0 7
85748: PUSH
85749: LD_VAR 0 2
85753: PUSH
85754: LD_INT 10
85756: DIVREAL
85757: ST_TO_ADDR
// time := 1 1$00 ;
85758: LD_ADDR_VAR 0 8
85762: PUSH
85763: LD_INT 2100
85765: ST_TO_ADDR
// if amount < min then
85766: LD_VAR 0 9
85770: PUSH
85771: LD_VAR 0 3
85775: LESS
85776: IFFALSE 85794
// r := r * 2 else
85778: LD_ADDR_VAR 0 7
85782: PUSH
85783: LD_VAR 0 7
85787: PUSH
85788: LD_INT 2
85790: MUL
85791: ST_TO_ADDR
85792: GO 85820
// if amount > max then
85794: LD_VAR 0 9
85798: PUSH
85799: LD_VAR 0 4
85803: GREATER
85804: IFFALSE 85820
// r := r / 2 ;
85806: LD_ADDR_VAR 0 7
85810: PUSH
85811: LD_VAR 0 7
85815: PUSH
85816: LD_INT 2
85818: DIVREAL
85819: ST_TO_ADDR
// time := time / r ;
85820: LD_ADDR_VAR 0 8
85824: PUSH
85825: LD_VAR 0 8
85829: PUSH
85830: LD_VAR 0 7
85834: DIVREAL
85835: ST_TO_ADDR
// if time < 0 then
85836: LD_VAR 0 8
85840: PUSH
85841: LD_INT 0
85843: LESS
85844: IFFALSE 85861
// time := time * - 1 ;
85846: LD_ADDR_VAR 0 8
85850: PUSH
85851: LD_VAR 0 8
85855: PUSH
85856: LD_INT 1
85858: NEG
85859: MUL
85860: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
85861: LD_VAR 0 8
85865: PUSH
85866: LD_INT 35
85868: PPUSH
85869: LD_INT 875
85871: PPUSH
85872: CALL_OW 12
85876: PLUS
85877: PPUSH
85878: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
85882: LD_INT 1
85884: PPUSH
85885: LD_INT 5
85887: PPUSH
85888: CALL_OW 12
85892: PPUSH
85893: LD_VAR 0 1
85897: PPUSH
85898: LD_INT 1
85900: PPUSH
85901: CALL_OW 55
// end ;
85905: GO 85718
// end ;
85907: LD_VAR 0 5
85911: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
85912: LD_INT 0
85914: PPUSH
85915: PPUSH
85916: PPUSH
85917: PPUSH
85918: PPUSH
85919: PPUSH
85920: PPUSH
85921: PPUSH
// if not turrets or not factories then
85922: LD_VAR 0 1
85926: NOT
85927: PUSH
85928: LD_VAR 0 2
85932: NOT
85933: OR
85934: IFFALSE 85938
// exit ;
85936: GO 86245
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
85938: LD_ADDR_VAR 0 10
85942: PUSH
85943: LD_INT 5
85945: PUSH
85946: LD_INT 6
85948: PUSH
85949: EMPTY
85950: LIST
85951: LIST
85952: PUSH
85953: LD_INT 2
85955: PUSH
85956: LD_INT 4
85958: PUSH
85959: EMPTY
85960: LIST
85961: LIST
85962: PUSH
85963: LD_INT 3
85965: PUSH
85966: LD_INT 5
85968: PUSH
85969: EMPTY
85970: LIST
85971: LIST
85972: PUSH
85973: EMPTY
85974: LIST
85975: LIST
85976: LIST
85977: PUSH
85978: LD_INT 24
85980: PUSH
85981: LD_INT 25
85983: PUSH
85984: EMPTY
85985: LIST
85986: LIST
85987: PUSH
85988: LD_INT 23
85990: PUSH
85991: LD_INT 27
85993: PUSH
85994: EMPTY
85995: LIST
85996: LIST
85997: PUSH
85998: EMPTY
85999: LIST
86000: LIST
86001: PUSH
86002: LD_INT 42
86004: PUSH
86005: LD_INT 43
86007: PUSH
86008: EMPTY
86009: LIST
86010: LIST
86011: PUSH
86012: LD_INT 44
86014: PUSH
86015: LD_INT 46
86017: PUSH
86018: EMPTY
86019: LIST
86020: LIST
86021: PUSH
86022: LD_INT 45
86024: PUSH
86025: LD_INT 47
86027: PUSH
86028: EMPTY
86029: LIST
86030: LIST
86031: PUSH
86032: EMPTY
86033: LIST
86034: LIST
86035: LIST
86036: PUSH
86037: EMPTY
86038: LIST
86039: LIST
86040: LIST
86041: ST_TO_ADDR
// result := [ ] ;
86042: LD_ADDR_VAR 0 3
86046: PUSH
86047: EMPTY
86048: ST_TO_ADDR
// for i in turrets do
86049: LD_ADDR_VAR 0 4
86053: PUSH
86054: LD_VAR 0 1
86058: PUSH
86059: FOR_IN
86060: IFFALSE 86243
// begin nat := GetNation ( i ) ;
86062: LD_ADDR_VAR 0 7
86066: PUSH
86067: LD_VAR 0 4
86071: PPUSH
86072: CALL_OW 248
86076: ST_TO_ADDR
// weapon := 0 ;
86077: LD_ADDR_VAR 0 8
86081: PUSH
86082: LD_INT 0
86084: ST_TO_ADDR
// if not nat then
86085: LD_VAR 0 7
86089: NOT
86090: IFFALSE 86094
// continue ;
86092: GO 86059
// for j in list [ nat ] do
86094: LD_ADDR_VAR 0 5
86098: PUSH
86099: LD_VAR 0 10
86103: PUSH
86104: LD_VAR 0 7
86108: ARRAY
86109: PUSH
86110: FOR_IN
86111: IFFALSE 86152
// if GetBWeapon ( i ) = j [ 1 ] then
86113: LD_VAR 0 4
86117: PPUSH
86118: CALL_OW 269
86122: PUSH
86123: LD_VAR 0 5
86127: PUSH
86128: LD_INT 1
86130: ARRAY
86131: EQUAL
86132: IFFALSE 86150
// begin weapon := j [ 2 ] ;
86134: LD_ADDR_VAR 0 8
86138: PUSH
86139: LD_VAR 0 5
86143: PUSH
86144: LD_INT 2
86146: ARRAY
86147: ST_TO_ADDR
// break ;
86148: GO 86152
// end ;
86150: GO 86110
86152: POP
86153: POP
// if not weapon then
86154: LD_VAR 0 8
86158: NOT
86159: IFFALSE 86163
// continue ;
86161: GO 86059
// for k in factories do
86163: LD_ADDR_VAR 0 6
86167: PUSH
86168: LD_VAR 0 2
86172: PUSH
86173: FOR_IN
86174: IFFALSE 86239
// begin weapons := AvailableWeaponList ( k ) ;
86176: LD_ADDR_VAR 0 9
86180: PUSH
86181: LD_VAR 0 6
86185: PPUSH
86186: CALL_OW 478
86190: ST_TO_ADDR
// if not weapons then
86191: LD_VAR 0 9
86195: NOT
86196: IFFALSE 86200
// continue ;
86198: GO 86173
// if weapon in weapons then
86200: LD_VAR 0 8
86204: PUSH
86205: LD_VAR 0 9
86209: IN
86210: IFFALSE 86237
// begin result := [ i , weapon ] ;
86212: LD_ADDR_VAR 0 3
86216: PUSH
86217: LD_VAR 0 4
86221: PUSH
86222: LD_VAR 0 8
86226: PUSH
86227: EMPTY
86228: LIST
86229: LIST
86230: ST_TO_ADDR
// exit ;
86231: POP
86232: POP
86233: POP
86234: POP
86235: GO 86245
// end ; end ;
86237: GO 86173
86239: POP
86240: POP
// end ;
86241: GO 86059
86243: POP
86244: POP
// end ;
86245: LD_VAR 0 3
86249: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
86250: LD_INT 0
86252: PPUSH
// if not side or side > 8 then
86253: LD_VAR 0 3
86257: NOT
86258: PUSH
86259: LD_VAR 0 3
86263: PUSH
86264: LD_INT 8
86266: GREATER
86267: OR
86268: IFFALSE 86272
// exit ;
86270: GO 86331
// if not range then
86272: LD_VAR 0 4
86276: NOT
86277: IFFALSE 86288
// range := - 12 ;
86279: LD_ADDR_VAR 0 4
86283: PUSH
86284: LD_INT 12
86286: NEG
86287: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
86288: LD_VAR 0 1
86292: PPUSH
86293: LD_VAR 0 2
86297: PPUSH
86298: LD_VAR 0 3
86302: PPUSH
86303: LD_VAR 0 4
86307: PPUSH
86308: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
86312: LD_VAR 0 1
86316: PPUSH
86317: LD_VAR 0 2
86321: PPUSH
86322: LD_VAR 0 3
86326: PPUSH
86327: CALL_OW 331
// end ;
86331: LD_VAR 0 5
86335: RET
// export function Video ( mode ) ; begin
86336: LD_INT 0
86338: PPUSH
// ingame_video = mode ;
86339: LD_ADDR_OWVAR 52
86343: PUSH
86344: LD_VAR 0 1
86348: ST_TO_ADDR
// interface_hidden = mode ;
86349: LD_ADDR_OWVAR 54
86353: PUSH
86354: LD_VAR 0 1
86358: ST_TO_ADDR
// end ;
86359: LD_VAR 0 2
86363: RET
// export function Join ( array , element ) ; begin
86364: LD_INT 0
86366: PPUSH
// result := Replace ( array , array + 1 , element ) ;
86367: LD_ADDR_VAR 0 3
86371: PUSH
86372: LD_VAR 0 1
86376: PPUSH
86377: LD_VAR 0 1
86381: PUSH
86382: LD_INT 1
86384: PLUS
86385: PPUSH
86386: LD_VAR 0 2
86390: PPUSH
86391: CALL_OW 1
86395: ST_TO_ADDR
// end ;
86396: LD_VAR 0 3
86400: RET
// export function JoinUnion ( array , element ) ; begin
86401: LD_INT 0
86403: PPUSH
// result := array union element ;
86404: LD_ADDR_VAR 0 3
86408: PUSH
86409: LD_VAR 0 1
86413: PUSH
86414: LD_VAR 0 2
86418: UNION
86419: ST_TO_ADDR
// end ;
86420: LD_VAR 0 3
86424: RET
// export function GetBehemoths ( side ) ; begin
86425: LD_INT 0
86427: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
86428: LD_ADDR_VAR 0 2
86432: PUSH
86433: LD_INT 22
86435: PUSH
86436: LD_VAR 0 1
86440: PUSH
86441: EMPTY
86442: LIST
86443: LIST
86444: PUSH
86445: LD_INT 31
86447: PUSH
86448: LD_INT 25
86450: PUSH
86451: EMPTY
86452: LIST
86453: LIST
86454: PUSH
86455: EMPTY
86456: LIST
86457: LIST
86458: PPUSH
86459: CALL_OW 69
86463: ST_TO_ADDR
// end ;
86464: LD_VAR 0 2
86468: RET
// export function Shuffle ( array ) ; var i , index ; begin
86469: LD_INT 0
86471: PPUSH
86472: PPUSH
86473: PPUSH
// result := [ ] ;
86474: LD_ADDR_VAR 0 2
86478: PUSH
86479: EMPTY
86480: ST_TO_ADDR
// if not array then
86481: LD_VAR 0 1
86485: NOT
86486: IFFALSE 86490
// exit ;
86488: GO 86589
// Randomize ;
86490: CALL_OW 10
// for i = array downto 1 do
86494: LD_ADDR_VAR 0 3
86498: PUSH
86499: DOUBLE
86500: LD_VAR 0 1
86504: INC
86505: ST_TO_ADDR
86506: LD_INT 1
86508: PUSH
86509: FOR_DOWNTO
86510: IFFALSE 86587
// begin index := rand ( 1 , array ) ;
86512: LD_ADDR_VAR 0 4
86516: PUSH
86517: LD_INT 1
86519: PPUSH
86520: LD_VAR 0 1
86524: PPUSH
86525: CALL_OW 12
86529: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
86530: LD_ADDR_VAR 0 2
86534: PUSH
86535: LD_VAR 0 2
86539: PPUSH
86540: LD_VAR 0 2
86544: PUSH
86545: LD_INT 1
86547: PLUS
86548: PPUSH
86549: LD_VAR 0 1
86553: PUSH
86554: LD_VAR 0 4
86558: ARRAY
86559: PPUSH
86560: CALL_OW 2
86564: ST_TO_ADDR
// array := Delete ( array , index ) ;
86565: LD_ADDR_VAR 0 1
86569: PUSH
86570: LD_VAR 0 1
86574: PPUSH
86575: LD_VAR 0 4
86579: PPUSH
86580: CALL_OW 3
86584: ST_TO_ADDR
// end ;
86585: GO 86509
86587: POP
86588: POP
// end ;
86589: LD_VAR 0 2
86593: RET
// export function GetBaseMaterials ( base ) ; begin
86594: LD_INT 0
86596: PPUSH
// result := [ 0 , 0 , 0 ] ;
86597: LD_ADDR_VAR 0 2
86601: PUSH
86602: LD_INT 0
86604: PUSH
86605: LD_INT 0
86607: PUSH
86608: LD_INT 0
86610: PUSH
86611: EMPTY
86612: LIST
86613: LIST
86614: LIST
86615: ST_TO_ADDR
// if not base then
86616: LD_VAR 0 1
86620: NOT
86621: IFFALSE 86625
// exit ;
86623: GO 86674
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
86625: LD_ADDR_VAR 0 2
86629: PUSH
86630: LD_VAR 0 1
86634: PPUSH
86635: LD_INT 1
86637: PPUSH
86638: CALL_OW 275
86642: PUSH
86643: LD_VAR 0 1
86647: PPUSH
86648: LD_INT 2
86650: PPUSH
86651: CALL_OW 275
86655: PUSH
86656: LD_VAR 0 1
86660: PPUSH
86661: LD_INT 3
86663: PPUSH
86664: CALL_OW 275
86668: PUSH
86669: EMPTY
86670: LIST
86671: LIST
86672: LIST
86673: ST_TO_ADDR
// end ;
86674: LD_VAR 0 2
86678: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
86679: LD_INT 0
86681: PPUSH
86682: PPUSH
// result := array ;
86683: LD_ADDR_VAR 0 3
86687: PUSH
86688: LD_VAR 0 1
86692: ST_TO_ADDR
// if size >= result then
86693: LD_VAR 0 2
86697: PUSH
86698: LD_VAR 0 3
86702: GREATEREQUAL
86703: IFFALSE 86707
// exit ;
86705: GO 86757
// if size then
86707: LD_VAR 0 2
86711: IFFALSE 86757
// for i := array downto size do
86713: LD_ADDR_VAR 0 4
86717: PUSH
86718: DOUBLE
86719: LD_VAR 0 1
86723: INC
86724: ST_TO_ADDR
86725: LD_VAR 0 2
86729: PUSH
86730: FOR_DOWNTO
86731: IFFALSE 86755
// result := Delete ( result , result ) ;
86733: LD_ADDR_VAR 0 3
86737: PUSH
86738: LD_VAR 0 3
86742: PPUSH
86743: LD_VAR 0 3
86747: PPUSH
86748: CALL_OW 3
86752: ST_TO_ADDR
86753: GO 86730
86755: POP
86756: POP
// end ;
86757: LD_VAR 0 3
86761: RET
// export function ComExit ( unit ) ; var tmp ; begin
86762: LD_INT 0
86764: PPUSH
86765: PPUSH
// if not IsInUnit ( unit ) then
86766: LD_VAR 0 1
86770: PPUSH
86771: CALL_OW 310
86775: NOT
86776: IFFALSE 86780
// exit ;
86778: GO 86840
// tmp := IsInUnit ( unit ) ;
86780: LD_ADDR_VAR 0 3
86784: PUSH
86785: LD_VAR 0 1
86789: PPUSH
86790: CALL_OW 310
86794: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
86795: LD_VAR 0 3
86799: PPUSH
86800: CALL_OW 247
86804: PUSH
86805: LD_INT 2
86807: EQUAL
86808: IFFALSE 86821
// ComExitVehicle ( unit ) else
86810: LD_VAR 0 1
86814: PPUSH
86815: CALL_OW 121
86819: GO 86830
// ComExitBuilding ( unit ) ;
86821: LD_VAR 0 1
86825: PPUSH
86826: CALL_OW 122
// result := tmp ;
86830: LD_ADDR_VAR 0 2
86834: PUSH
86835: LD_VAR 0 3
86839: ST_TO_ADDR
// end ;
86840: LD_VAR 0 2
86844: RET
// export function ComExitAll ( units ) ; var i ; begin
86845: LD_INT 0
86847: PPUSH
86848: PPUSH
// if not units then
86849: LD_VAR 0 1
86853: NOT
86854: IFFALSE 86858
// exit ;
86856: GO 86884
// for i in units do
86858: LD_ADDR_VAR 0 3
86862: PUSH
86863: LD_VAR 0 1
86867: PUSH
86868: FOR_IN
86869: IFFALSE 86882
// ComExit ( i ) ;
86871: LD_VAR 0 3
86875: PPUSH
86876: CALL 86762 0 1
86880: GO 86868
86882: POP
86883: POP
// end ;
86884: LD_VAR 0 2
86888: RET
// export function ResetHc ; begin
86889: LD_INT 0
86891: PPUSH
// InitHc ;
86892: CALL_OW 19
// hc_importance := 0 ;
86896: LD_ADDR_OWVAR 32
86900: PUSH
86901: LD_INT 0
86903: ST_TO_ADDR
// end ;
86904: LD_VAR 0 1
86908: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
86909: LD_INT 0
86911: PPUSH
86912: PPUSH
86913: PPUSH
// _x := ( x1 + x2 ) div 2 ;
86914: LD_ADDR_VAR 0 6
86918: PUSH
86919: LD_VAR 0 1
86923: PUSH
86924: LD_VAR 0 3
86928: PLUS
86929: PUSH
86930: LD_INT 2
86932: DIV
86933: ST_TO_ADDR
// if _x < 0 then
86934: LD_VAR 0 6
86938: PUSH
86939: LD_INT 0
86941: LESS
86942: IFFALSE 86959
// _x := _x * - 1 ;
86944: LD_ADDR_VAR 0 6
86948: PUSH
86949: LD_VAR 0 6
86953: PUSH
86954: LD_INT 1
86956: NEG
86957: MUL
86958: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
86959: LD_ADDR_VAR 0 7
86963: PUSH
86964: LD_VAR 0 2
86968: PUSH
86969: LD_VAR 0 4
86973: PLUS
86974: PUSH
86975: LD_INT 2
86977: DIV
86978: ST_TO_ADDR
// if _y < 0 then
86979: LD_VAR 0 7
86983: PUSH
86984: LD_INT 0
86986: LESS
86987: IFFALSE 87004
// _y := _y * - 1 ;
86989: LD_ADDR_VAR 0 7
86993: PUSH
86994: LD_VAR 0 7
86998: PUSH
86999: LD_INT 1
87001: NEG
87002: MUL
87003: ST_TO_ADDR
// result := [ _x , _y ] ;
87004: LD_ADDR_VAR 0 5
87008: PUSH
87009: LD_VAR 0 6
87013: PUSH
87014: LD_VAR 0 7
87018: PUSH
87019: EMPTY
87020: LIST
87021: LIST
87022: ST_TO_ADDR
// end ;
87023: LD_VAR 0 5
87027: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
87028: LD_INT 0
87030: PPUSH
87031: PPUSH
87032: PPUSH
87033: PPUSH
// task := GetTaskList ( unit ) ;
87034: LD_ADDR_VAR 0 7
87038: PUSH
87039: LD_VAR 0 1
87043: PPUSH
87044: CALL_OW 437
87048: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
87049: LD_VAR 0 7
87053: NOT
87054: PUSH
87055: LD_VAR 0 1
87059: PPUSH
87060: LD_VAR 0 2
87064: PPUSH
87065: CALL_OW 308
87069: NOT
87070: AND
87071: IFFALSE 87075
// exit ;
87073: GO 87193
// if IsInArea ( unit , area ) then
87075: LD_VAR 0 1
87079: PPUSH
87080: LD_VAR 0 2
87084: PPUSH
87085: CALL_OW 308
87089: IFFALSE 87107
// begin ComMoveToArea ( unit , goAway ) ;
87091: LD_VAR 0 1
87095: PPUSH
87096: LD_VAR 0 3
87100: PPUSH
87101: CALL_OW 113
// exit ;
87105: GO 87193
// end ; if task [ 1 ] [ 1 ] <> M then
87107: LD_VAR 0 7
87111: PUSH
87112: LD_INT 1
87114: ARRAY
87115: PUSH
87116: LD_INT 1
87118: ARRAY
87119: PUSH
87120: LD_STRING M
87122: NONEQUAL
87123: IFFALSE 87127
// exit ;
87125: GO 87193
// x := task [ 1 ] [ 2 ] ;
87127: LD_ADDR_VAR 0 5
87131: PUSH
87132: LD_VAR 0 7
87136: PUSH
87137: LD_INT 1
87139: ARRAY
87140: PUSH
87141: LD_INT 2
87143: ARRAY
87144: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
87145: LD_ADDR_VAR 0 6
87149: PUSH
87150: LD_VAR 0 7
87154: PUSH
87155: LD_INT 1
87157: ARRAY
87158: PUSH
87159: LD_INT 3
87161: ARRAY
87162: ST_TO_ADDR
// if InArea ( x , y , area ) then
87163: LD_VAR 0 5
87167: PPUSH
87168: LD_VAR 0 6
87172: PPUSH
87173: LD_VAR 0 2
87177: PPUSH
87178: CALL_OW 309
87182: IFFALSE 87193
// ComStop ( unit ) ;
87184: LD_VAR 0 1
87188: PPUSH
87189: CALL_OW 141
// end ;
87193: LD_VAR 0 4
87197: RET
// export function Abs ( value ) ; begin
87198: LD_INT 0
87200: PPUSH
// result := value ;
87201: LD_ADDR_VAR 0 2
87205: PUSH
87206: LD_VAR 0 1
87210: ST_TO_ADDR
// if value < 0 then
87211: LD_VAR 0 1
87215: PUSH
87216: LD_INT 0
87218: LESS
87219: IFFALSE 87236
// result := value * - 1 ;
87221: LD_ADDR_VAR 0 2
87225: PUSH
87226: LD_VAR 0 1
87230: PUSH
87231: LD_INT 1
87233: NEG
87234: MUL
87235: ST_TO_ADDR
// end ;
87236: LD_VAR 0 2
87240: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
87241: LD_INT 0
87243: PPUSH
87244: PPUSH
87245: PPUSH
87246: PPUSH
87247: PPUSH
87248: PPUSH
87249: PPUSH
87250: PPUSH
// if not unit or not building then
87251: LD_VAR 0 1
87255: NOT
87256: PUSH
87257: LD_VAR 0 2
87261: NOT
87262: OR
87263: IFFALSE 87267
// exit ;
87265: GO 87493
// x := GetX ( building ) ;
87267: LD_ADDR_VAR 0 4
87271: PUSH
87272: LD_VAR 0 2
87276: PPUSH
87277: CALL_OW 250
87281: ST_TO_ADDR
// y := GetY ( building ) ;
87282: LD_ADDR_VAR 0 6
87286: PUSH
87287: LD_VAR 0 2
87291: PPUSH
87292: CALL_OW 251
87296: ST_TO_ADDR
// d := GetDir ( building ) ;
87297: LD_ADDR_VAR 0 8
87301: PUSH
87302: LD_VAR 0 2
87306: PPUSH
87307: CALL_OW 254
87311: ST_TO_ADDR
// r := 4 ;
87312: LD_ADDR_VAR 0 9
87316: PUSH
87317: LD_INT 4
87319: ST_TO_ADDR
// for i := 1 to 5 do
87320: LD_ADDR_VAR 0 10
87324: PUSH
87325: DOUBLE
87326: LD_INT 1
87328: DEC
87329: ST_TO_ADDR
87330: LD_INT 5
87332: PUSH
87333: FOR_TO
87334: IFFALSE 87491
// begin _x := ShiftX ( x , d , r + i ) ;
87336: LD_ADDR_VAR 0 5
87340: PUSH
87341: LD_VAR 0 4
87345: PPUSH
87346: LD_VAR 0 8
87350: PPUSH
87351: LD_VAR 0 9
87355: PUSH
87356: LD_VAR 0 10
87360: PLUS
87361: PPUSH
87362: CALL_OW 272
87366: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
87367: LD_ADDR_VAR 0 7
87371: PUSH
87372: LD_VAR 0 6
87376: PPUSH
87377: LD_VAR 0 8
87381: PPUSH
87382: LD_VAR 0 9
87386: PUSH
87387: LD_VAR 0 10
87391: PLUS
87392: PPUSH
87393: CALL_OW 273
87397: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
87398: LD_VAR 0 5
87402: PPUSH
87403: LD_VAR 0 7
87407: PPUSH
87408: CALL_OW 488
87412: PUSH
87413: LD_VAR 0 5
87417: PPUSH
87418: LD_VAR 0 7
87422: PPUSH
87423: CALL_OW 428
87427: PPUSH
87428: CALL_OW 247
87432: PUSH
87433: LD_INT 3
87435: PUSH
87436: LD_INT 2
87438: PUSH
87439: EMPTY
87440: LIST
87441: LIST
87442: IN
87443: NOT
87444: AND
87445: IFFALSE 87489
// begin ComMoveXY ( unit , _x , _y ) ;
87447: LD_VAR 0 1
87451: PPUSH
87452: LD_VAR 0 5
87456: PPUSH
87457: LD_VAR 0 7
87461: PPUSH
87462: CALL_OW 111
// result := [ _x , _y ] ;
87466: LD_ADDR_VAR 0 3
87470: PUSH
87471: LD_VAR 0 5
87475: PUSH
87476: LD_VAR 0 7
87480: PUSH
87481: EMPTY
87482: LIST
87483: LIST
87484: ST_TO_ADDR
// exit ;
87485: POP
87486: POP
87487: GO 87493
// end ; end ;
87489: GO 87333
87491: POP
87492: POP
// end ;
87493: LD_VAR 0 3
87497: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
87498: LD_INT 0
87500: PPUSH
87501: PPUSH
87502: PPUSH
// result := 0 ;
87503: LD_ADDR_VAR 0 3
87507: PUSH
87508: LD_INT 0
87510: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
87511: LD_VAR 0 1
87515: PUSH
87516: LD_INT 0
87518: LESS
87519: PUSH
87520: LD_VAR 0 1
87524: PUSH
87525: LD_INT 8
87527: GREATER
87528: OR
87529: PUSH
87530: LD_VAR 0 2
87534: PUSH
87535: LD_INT 0
87537: LESS
87538: OR
87539: PUSH
87540: LD_VAR 0 2
87544: PUSH
87545: LD_INT 8
87547: GREATER
87548: OR
87549: IFFALSE 87553
// exit ;
87551: GO 87628
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
87553: LD_ADDR_VAR 0 4
87557: PUSH
87558: LD_INT 22
87560: PUSH
87561: LD_VAR 0 2
87565: PUSH
87566: EMPTY
87567: LIST
87568: LIST
87569: PPUSH
87570: CALL_OW 69
87574: PUSH
87575: FOR_IN
87576: IFFALSE 87626
// begin un := UnitShoot ( i ) ;
87578: LD_ADDR_VAR 0 5
87582: PUSH
87583: LD_VAR 0 4
87587: PPUSH
87588: CALL_OW 504
87592: ST_TO_ADDR
// if GetSide ( un ) = side1 then
87593: LD_VAR 0 5
87597: PPUSH
87598: CALL_OW 255
87602: PUSH
87603: LD_VAR 0 1
87607: EQUAL
87608: IFFALSE 87624
// begin result := un ;
87610: LD_ADDR_VAR 0 3
87614: PUSH
87615: LD_VAR 0 5
87619: ST_TO_ADDR
// exit ;
87620: POP
87621: POP
87622: GO 87628
// end ; end ;
87624: GO 87575
87626: POP
87627: POP
// end ;
87628: LD_VAR 0 3
87632: RET
// export function GetCargoBay ( units ) ; begin
87633: LD_INT 0
87635: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
87636: LD_ADDR_VAR 0 2
87640: PUSH
87641: LD_VAR 0 1
87645: PPUSH
87646: LD_INT 2
87648: PUSH
87649: LD_INT 34
87651: PUSH
87652: LD_INT 12
87654: PUSH
87655: EMPTY
87656: LIST
87657: LIST
87658: PUSH
87659: LD_INT 34
87661: PUSH
87662: LD_INT 51
87664: PUSH
87665: EMPTY
87666: LIST
87667: LIST
87668: PUSH
87669: LD_INT 34
87671: PUSH
87672: LD_INT 32
87674: PUSH
87675: EMPTY
87676: LIST
87677: LIST
87678: PUSH
87679: LD_INT 34
87681: PUSH
87682: LD_INT 89
87684: PUSH
87685: EMPTY
87686: LIST
87687: LIST
87688: PUSH
87689: EMPTY
87690: LIST
87691: LIST
87692: LIST
87693: LIST
87694: LIST
87695: PPUSH
87696: CALL_OW 72
87700: ST_TO_ADDR
// end ;
87701: LD_VAR 0 2
87705: RET
// export function Negate ( value ) ; begin
87706: LD_INT 0
87708: PPUSH
// result := not value ;
87709: LD_ADDR_VAR 0 2
87713: PUSH
87714: LD_VAR 0 1
87718: NOT
87719: ST_TO_ADDR
// end ;
87720: LD_VAR 0 2
87724: RET
// export function Inc ( value ) ; begin
87725: LD_INT 0
87727: PPUSH
// result := value + 1 ;
87728: LD_ADDR_VAR 0 2
87732: PUSH
87733: LD_VAR 0 1
87737: PUSH
87738: LD_INT 1
87740: PLUS
87741: ST_TO_ADDR
// end ;
87742: LD_VAR 0 2
87746: RET
// export function Dec ( value ) ; begin
87747: LD_INT 0
87749: PPUSH
// result := value - 1 ;
87750: LD_ADDR_VAR 0 2
87754: PUSH
87755: LD_VAR 0 1
87759: PUSH
87760: LD_INT 1
87762: MINUS
87763: ST_TO_ADDR
// end ;
87764: LD_VAR 0 2
87768: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
87769: LD_INT 0
87771: PPUSH
87772: PPUSH
87773: PPUSH
87774: PPUSH
87775: PPUSH
87776: PPUSH
87777: PPUSH
87778: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
87779: LD_VAR 0 1
87783: PPUSH
87784: LD_VAR 0 2
87788: PPUSH
87789: CALL_OW 488
87793: NOT
87794: PUSH
87795: LD_VAR 0 3
87799: PPUSH
87800: LD_VAR 0 4
87804: PPUSH
87805: CALL_OW 488
87809: NOT
87810: OR
87811: IFFALSE 87824
// begin result := - 1 ;
87813: LD_ADDR_VAR 0 5
87817: PUSH
87818: LD_INT 1
87820: NEG
87821: ST_TO_ADDR
// exit ;
87822: GO 88059
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
87824: LD_ADDR_VAR 0 12
87828: PUSH
87829: LD_VAR 0 1
87833: PPUSH
87834: LD_VAR 0 2
87838: PPUSH
87839: LD_VAR 0 3
87843: PPUSH
87844: LD_VAR 0 4
87848: PPUSH
87849: CALL 86909 0 4
87853: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
87854: LD_ADDR_VAR 0 11
87858: PUSH
87859: LD_VAR 0 1
87863: PPUSH
87864: LD_VAR 0 2
87868: PPUSH
87869: LD_VAR 0 12
87873: PUSH
87874: LD_INT 1
87876: ARRAY
87877: PPUSH
87878: LD_VAR 0 12
87882: PUSH
87883: LD_INT 2
87885: ARRAY
87886: PPUSH
87887: CALL_OW 298
87891: ST_TO_ADDR
// distance := 9999 ;
87892: LD_ADDR_VAR 0 10
87896: PUSH
87897: LD_INT 9999
87899: ST_TO_ADDR
// for i := 0 to 5 do
87900: LD_ADDR_VAR 0 6
87904: PUSH
87905: DOUBLE
87906: LD_INT 0
87908: DEC
87909: ST_TO_ADDR
87910: LD_INT 5
87912: PUSH
87913: FOR_TO
87914: IFFALSE 88057
// begin _x := ShiftX ( x1 , i , centerDist ) ;
87916: LD_ADDR_VAR 0 7
87920: PUSH
87921: LD_VAR 0 1
87925: PPUSH
87926: LD_VAR 0 6
87930: PPUSH
87931: LD_VAR 0 11
87935: PPUSH
87936: CALL_OW 272
87940: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
87941: LD_ADDR_VAR 0 8
87945: PUSH
87946: LD_VAR 0 2
87950: PPUSH
87951: LD_VAR 0 6
87955: PPUSH
87956: LD_VAR 0 11
87960: PPUSH
87961: CALL_OW 273
87965: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
87966: LD_VAR 0 7
87970: PPUSH
87971: LD_VAR 0 8
87975: PPUSH
87976: CALL_OW 488
87980: NOT
87981: IFFALSE 87985
// continue ;
87983: GO 87913
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
87985: LD_ADDR_VAR 0 9
87989: PUSH
87990: LD_VAR 0 12
87994: PUSH
87995: LD_INT 1
87997: ARRAY
87998: PPUSH
87999: LD_VAR 0 12
88003: PUSH
88004: LD_INT 2
88006: ARRAY
88007: PPUSH
88008: LD_VAR 0 7
88012: PPUSH
88013: LD_VAR 0 8
88017: PPUSH
88018: CALL_OW 298
88022: ST_TO_ADDR
// if tmp < distance then
88023: LD_VAR 0 9
88027: PUSH
88028: LD_VAR 0 10
88032: LESS
88033: IFFALSE 88055
// begin result := i ;
88035: LD_ADDR_VAR 0 5
88039: PUSH
88040: LD_VAR 0 6
88044: ST_TO_ADDR
// distance := tmp ;
88045: LD_ADDR_VAR 0 10
88049: PUSH
88050: LD_VAR 0 9
88054: ST_TO_ADDR
// end ; end ;
88055: GO 87913
88057: POP
88058: POP
// end ;
88059: LD_VAR 0 5
88063: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
88064: LD_INT 0
88066: PPUSH
88067: PPUSH
// if not driver or not IsInUnit ( driver ) then
88068: LD_VAR 0 1
88072: NOT
88073: PUSH
88074: LD_VAR 0 1
88078: PPUSH
88079: CALL_OW 310
88083: NOT
88084: OR
88085: IFFALSE 88089
// exit ;
88087: GO 88179
// vehicle := IsInUnit ( driver ) ;
88089: LD_ADDR_VAR 0 3
88093: PUSH
88094: LD_VAR 0 1
88098: PPUSH
88099: CALL_OW 310
88103: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
88104: LD_VAR 0 1
88108: PPUSH
88109: LD_STRING \
88111: PUSH
88112: LD_INT 0
88114: PUSH
88115: LD_INT 0
88117: PUSH
88118: LD_INT 0
88120: PUSH
88121: LD_INT 0
88123: PUSH
88124: LD_INT 0
88126: PUSH
88127: LD_INT 0
88129: PUSH
88130: EMPTY
88131: LIST
88132: LIST
88133: LIST
88134: LIST
88135: LIST
88136: LIST
88137: LIST
88138: PUSH
88139: LD_STRING E
88141: PUSH
88142: LD_INT 0
88144: PUSH
88145: LD_INT 0
88147: PUSH
88148: LD_VAR 0 3
88152: PUSH
88153: LD_INT 0
88155: PUSH
88156: LD_INT 0
88158: PUSH
88159: LD_INT 0
88161: PUSH
88162: EMPTY
88163: LIST
88164: LIST
88165: LIST
88166: LIST
88167: LIST
88168: LIST
88169: LIST
88170: PUSH
88171: EMPTY
88172: LIST
88173: LIST
88174: PPUSH
88175: CALL_OW 446
// end ;
88179: LD_VAR 0 2
88183: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
88184: LD_INT 0
88186: PPUSH
88187: PPUSH
// if not driver or not IsInUnit ( driver ) then
88188: LD_VAR 0 1
88192: NOT
88193: PUSH
88194: LD_VAR 0 1
88198: PPUSH
88199: CALL_OW 310
88203: NOT
88204: OR
88205: IFFALSE 88209
// exit ;
88207: GO 88299
// vehicle := IsInUnit ( driver ) ;
88209: LD_ADDR_VAR 0 3
88213: PUSH
88214: LD_VAR 0 1
88218: PPUSH
88219: CALL_OW 310
88223: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
88224: LD_VAR 0 1
88228: PPUSH
88229: LD_STRING \
88231: PUSH
88232: LD_INT 0
88234: PUSH
88235: LD_INT 0
88237: PUSH
88238: LD_INT 0
88240: PUSH
88241: LD_INT 0
88243: PUSH
88244: LD_INT 0
88246: PUSH
88247: LD_INT 0
88249: PUSH
88250: EMPTY
88251: LIST
88252: LIST
88253: LIST
88254: LIST
88255: LIST
88256: LIST
88257: LIST
88258: PUSH
88259: LD_STRING E
88261: PUSH
88262: LD_INT 0
88264: PUSH
88265: LD_INT 0
88267: PUSH
88268: LD_VAR 0 3
88272: PUSH
88273: LD_INT 0
88275: PUSH
88276: LD_INT 0
88278: PUSH
88279: LD_INT 0
88281: PUSH
88282: EMPTY
88283: LIST
88284: LIST
88285: LIST
88286: LIST
88287: LIST
88288: LIST
88289: LIST
88290: PUSH
88291: EMPTY
88292: LIST
88293: LIST
88294: PPUSH
88295: CALL_OW 447
// end ;
88299: LD_VAR 0 2
88303: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
88304: LD_INT 0
88306: PPUSH
88307: PPUSH
88308: PPUSH
// tmp := [ ] ;
88309: LD_ADDR_VAR 0 5
88313: PUSH
88314: EMPTY
88315: ST_TO_ADDR
// for i in units do
88316: LD_ADDR_VAR 0 4
88320: PUSH
88321: LD_VAR 0 1
88325: PUSH
88326: FOR_IN
88327: IFFALSE 88365
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
88329: LD_ADDR_VAR 0 5
88333: PUSH
88334: LD_VAR 0 5
88338: PPUSH
88339: LD_VAR 0 5
88343: PUSH
88344: LD_INT 1
88346: PLUS
88347: PPUSH
88348: LD_VAR 0 4
88352: PPUSH
88353: CALL_OW 256
88357: PPUSH
88358: CALL_OW 2
88362: ST_TO_ADDR
88363: GO 88326
88365: POP
88366: POP
// if not tmp then
88367: LD_VAR 0 5
88371: NOT
88372: IFFALSE 88376
// exit ;
88374: GO 88424
// if asc then
88376: LD_VAR 0 2
88380: IFFALSE 88404
// result := SortListByListAsc ( units , tmp ) else
88382: LD_ADDR_VAR 0 3
88386: PUSH
88387: LD_VAR 0 1
88391: PPUSH
88392: LD_VAR 0 5
88396: PPUSH
88397: CALL_OW 76
88401: ST_TO_ADDR
88402: GO 88424
// result := SortListByListDesc ( units , tmp ) ;
88404: LD_ADDR_VAR 0 3
88408: PUSH
88409: LD_VAR 0 1
88413: PPUSH
88414: LD_VAR 0 5
88418: PPUSH
88419: CALL_OW 77
88423: ST_TO_ADDR
// end ;
88424: LD_VAR 0 3
88428: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
88429: LD_INT 0
88431: PPUSH
88432: PPUSH
// task := GetTaskList ( mech ) ;
88433: LD_ADDR_VAR 0 4
88437: PUSH
88438: LD_VAR 0 1
88442: PPUSH
88443: CALL_OW 437
88447: ST_TO_ADDR
// if not task then
88448: LD_VAR 0 4
88452: NOT
88453: IFFALSE 88457
// exit ;
88455: GO 88499
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
88457: LD_ADDR_VAR 0 3
88461: PUSH
88462: LD_VAR 0 4
88466: PUSH
88467: LD_INT 1
88469: ARRAY
88470: PUSH
88471: LD_INT 1
88473: ARRAY
88474: PUSH
88475: LD_STRING r
88477: EQUAL
88478: PUSH
88479: LD_VAR 0 4
88483: PUSH
88484: LD_INT 1
88486: ARRAY
88487: PUSH
88488: LD_INT 4
88490: ARRAY
88491: PUSH
88492: LD_VAR 0 2
88496: EQUAL
88497: AND
88498: ST_TO_ADDR
// end ;
88499: LD_VAR 0 3
88503: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
88504: LD_INT 0
88506: PPUSH
// SetDir ( unit , d ) ;
88507: LD_VAR 0 1
88511: PPUSH
88512: LD_VAR 0 4
88516: PPUSH
88517: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
88521: LD_VAR 0 1
88525: PPUSH
88526: LD_VAR 0 2
88530: PPUSH
88531: LD_VAR 0 3
88535: PPUSH
88536: LD_VAR 0 5
88540: PPUSH
88541: CALL_OW 48
// end ;
88545: LD_VAR 0 6
88549: RET
// export function ToNaturalNumber ( number ) ; begin
88550: LD_INT 0
88552: PPUSH
// result := number div 1 ;
88553: LD_ADDR_VAR 0 2
88557: PUSH
88558: LD_VAR 0 1
88562: PUSH
88563: LD_INT 1
88565: DIV
88566: ST_TO_ADDR
// if number < 0 then
88567: LD_VAR 0 1
88571: PUSH
88572: LD_INT 0
88574: LESS
88575: IFFALSE 88585
// result := 0 ;
88577: LD_ADDR_VAR 0 2
88581: PUSH
88582: LD_INT 0
88584: ST_TO_ADDR
// end ;
88585: LD_VAR 0 2
88589: RET
// export function SortByClass ( units , class ) ; var un ; begin
88590: LD_INT 0
88592: PPUSH
88593: PPUSH
// if not units or not class then
88594: LD_VAR 0 1
88598: NOT
88599: PUSH
88600: LD_VAR 0 2
88604: NOT
88605: OR
88606: IFFALSE 88610
// exit ;
88608: GO 88705
// result := [ ] ;
88610: LD_ADDR_VAR 0 3
88614: PUSH
88615: EMPTY
88616: ST_TO_ADDR
// for un in units do
88617: LD_ADDR_VAR 0 4
88621: PUSH
88622: LD_VAR 0 1
88626: PUSH
88627: FOR_IN
88628: IFFALSE 88703
// if GetClass ( un ) = class then
88630: LD_VAR 0 4
88634: PPUSH
88635: CALL_OW 257
88639: PUSH
88640: LD_VAR 0 2
88644: EQUAL
88645: IFFALSE 88672
// result := Insert ( result , 1 , un ) else
88647: LD_ADDR_VAR 0 3
88651: PUSH
88652: LD_VAR 0 3
88656: PPUSH
88657: LD_INT 1
88659: PPUSH
88660: LD_VAR 0 4
88664: PPUSH
88665: CALL_OW 2
88669: ST_TO_ADDR
88670: GO 88701
// result := Replace ( result , result + 1 , un ) ;
88672: LD_ADDR_VAR 0 3
88676: PUSH
88677: LD_VAR 0 3
88681: PPUSH
88682: LD_VAR 0 3
88686: PUSH
88687: LD_INT 1
88689: PLUS
88690: PPUSH
88691: LD_VAR 0 4
88695: PPUSH
88696: CALL_OW 1
88700: ST_TO_ADDR
88701: GO 88627
88703: POP
88704: POP
// end ;
88705: LD_VAR 0 3
88709: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
88710: LD_INT 0
88712: PPUSH
88713: PPUSH
88714: PPUSH
88715: PPUSH
88716: PPUSH
88717: PPUSH
88718: PPUSH
// result := [ ] ;
88719: LD_ADDR_VAR 0 4
88723: PUSH
88724: EMPTY
88725: ST_TO_ADDR
// if x - r < 0 then
88726: LD_VAR 0 1
88730: PUSH
88731: LD_VAR 0 3
88735: MINUS
88736: PUSH
88737: LD_INT 0
88739: LESS
88740: IFFALSE 88752
// min_x := 0 else
88742: LD_ADDR_VAR 0 8
88746: PUSH
88747: LD_INT 0
88749: ST_TO_ADDR
88750: GO 88768
// min_x := x - r ;
88752: LD_ADDR_VAR 0 8
88756: PUSH
88757: LD_VAR 0 1
88761: PUSH
88762: LD_VAR 0 3
88766: MINUS
88767: ST_TO_ADDR
// if y - r < 0 then
88768: LD_VAR 0 2
88772: PUSH
88773: LD_VAR 0 3
88777: MINUS
88778: PUSH
88779: LD_INT 0
88781: LESS
88782: IFFALSE 88794
// min_y := 0 else
88784: LD_ADDR_VAR 0 7
88788: PUSH
88789: LD_INT 0
88791: ST_TO_ADDR
88792: GO 88810
// min_y := y - r ;
88794: LD_ADDR_VAR 0 7
88798: PUSH
88799: LD_VAR 0 2
88803: PUSH
88804: LD_VAR 0 3
88808: MINUS
88809: ST_TO_ADDR
// max_x := x + r ;
88810: LD_ADDR_VAR 0 9
88814: PUSH
88815: LD_VAR 0 1
88819: PUSH
88820: LD_VAR 0 3
88824: PLUS
88825: ST_TO_ADDR
// max_y := y + r ;
88826: LD_ADDR_VAR 0 10
88830: PUSH
88831: LD_VAR 0 2
88835: PUSH
88836: LD_VAR 0 3
88840: PLUS
88841: ST_TO_ADDR
// for _x = min_x to max_x do
88842: LD_ADDR_VAR 0 5
88846: PUSH
88847: DOUBLE
88848: LD_VAR 0 8
88852: DEC
88853: ST_TO_ADDR
88854: LD_VAR 0 9
88858: PUSH
88859: FOR_TO
88860: IFFALSE 88961
// for _y = min_y to max_y do
88862: LD_ADDR_VAR 0 6
88866: PUSH
88867: DOUBLE
88868: LD_VAR 0 7
88872: DEC
88873: ST_TO_ADDR
88874: LD_VAR 0 10
88878: PUSH
88879: FOR_TO
88880: IFFALSE 88957
// begin if not ValidHex ( _x , _y ) then
88882: LD_VAR 0 5
88886: PPUSH
88887: LD_VAR 0 6
88891: PPUSH
88892: CALL_OW 488
88896: NOT
88897: IFFALSE 88901
// continue ;
88899: GO 88879
// if GetResourceTypeXY ( _x , _y ) then
88901: LD_VAR 0 5
88905: PPUSH
88906: LD_VAR 0 6
88910: PPUSH
88911: CALL_OW 283
88915: IFFALSE 88955
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
88917: LD_ADDR_VAR 0 4
88921: PUSH
88922: LD_VAR 0 4
88926: PPUSH
88927: LD_VAR 0 4
88931: PUSH
88932: LD_INT 1
88934: PLUS
88935: PPUSH
88936: LD_VAR 0 5
88940: PUSH
88941: LD_VAR 0 6
88945: PUSH
88946: EMPTY
88947: LIST
88948: LIST
88949: PPUSH
88950: CALL_OW 1
88954: ST_TO_ADDR
// end ;
88955: GO 88879
88957: POP
88958: POP
88959: GO 88859
88961: POP
88962: POP
// end ;
88963: LD_VAR 0 4
88967: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
88968: LD_INT 0
88970: PPUSH
88971: PPUSH
88972: PPUSH
88973: PPUSH
88974: PPUSH
88975: PPUSH
88976: PPUSH
88977: PPUSH
// if not units then
88978: LD_VAR 0 1
88982: NOT
88983: IFFALSE 88987
// exit ;
88985: GO 89511
// result := UnitFilter ( units , [ f_ok ] ) ;
88987: LD_ADDR_VAR 0 3
88991: PUSH
88992: LD_VAR 0 1
88996: PPUSH
88997: LD_INT 50
88999: PUSH
89000: EMPTY
89001: LIST
89002: PPUSH
89003: CALL_OW 72
89007: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
89008: LD_ADDR_VAR 0 8
89012: PUSH
89013: LD_VAR 0 1
89017: PUSH
89018: LD_INT 1
89020: ARRAY
89021: PPUSH
89022: CALL_OW 255
89026: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
89027: LD_ADDR_VAR 0 10
89031: PUSH
89032: LD_INT 29
89034: PUSH
89035: LD_INT 91
89037: PUSH
89038: LD_INT 49
89040: PUSH
89041: EMPTY
89042: LIST
89043: LIST
89044: LIST
89045: ST_TO_ADDR
// if not result then
89046: LD_VAR 0 3
89050: NOT
89051: IFFALSE 89055
// exit ;
89053: GO 89511
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
89055: LD_ADDR_VAR 0 5
89059: PUSH
89060: LD_INT 81
89062: PUSH
89063: LD_VAR 0 8
89067: PUSH
89068: EMPTY
89069: LIST
89070: LIST
89071: PPUSH
89072: CALL_OW 69
89076: ST_TO_ADDR
// for i in result do
89077: LD_ADDR_VAR 0 4
89081: PUSH
89082: LD_VAR 0 3
89086: PUSH
89087: FOR_IN
89088: IFFALSE 89509
// begin tag := GetTag ( i ) + 1 ;
89090: LD_ADDR_VAR 0 9
89094: PUSH
89095: LD_VAR 0 4
89099: PPUSH
89100: CALL_OW 110
89104: PUSH
89105: LD_INT 1
89107: PLUS
89108: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
89109: LD_ADDR_VAR 0 7
89113: PUSH
89114: LD_VAR 0 4
89118: PPUSH
89119: CALL_OW 250
89123: PPUSH
89124: LD_VAR 0 4
89128: PPUSH
89129: CALL_OW 251
89133: PPUSH
89134: LD_INT 6
89136: PPUSH
89137: CALL 88710 0 3
89141: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
89142: LD_VAR 0 4
89146: PPUSH
89147: CALL_OW 247
89151: PUSH
89152: LD_INT 2
89154: EQUAL
89155: PUSH
89156: LD_VAR 0 7
89160: AND
89161: PUSH
89162: LD_VAR 0 4
89166: PPUSH
89167: CALL_OW 264
89171: PUSH
89172: LD_VAR 0 10
89176: IN
89177: NOT
89178: AND
89179: IFFALSE 89218
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
89181: LD_VAR 0 4
89185: PPUSH
89186: LD_VAR 0 7
89190: PUSH
89191: LD_INT 1
89193: ARRAY
89194: PUSH
89195: LD_INT 1
89197: ARRAY
89198: PPUSH
89199: LD_VAR 0 7
89203: PUSH
89204: LD_INT 1
89206: ARRAY
89207: PUSH
89208: LD_INT 2
89210: ARRAY
89211: PPUSH
89212: CALL_OW 116
89216: GO 89507
// if path > tag then
89218: LD_VAR 0 2
89222: PUSH
89223: LD_VAR 0 9
89227: GREATER
89228: IFFALSE 89436
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
89230: LD_ADDR_VAR 0 6
89234: PUSH
89235: LD_VAR 0 5
89239: PPUSH
89240: LD_INT 91
89242: PUSH
89243: LD_VAR 0 4
89247: PUSH
89248: LD_INT 8
89250: PUSH
89251: EMPTY
89252: LIST
89253: LIST
89254: LIST
89255: PPUSH
89256: CALL_OW 72
89260: ST_TO_ADDR
// if nearEnemy then
89261: LD_VAR 0 6
89265: IFFALSE 89334
// begin if GetWeapon ( i ) = ru_time_lapser then
89267: LD_VAR 0 4
89271: PPUSH
89272: CALL_OW 264
89276: PUSH
89277: LD_INT 49
89279: EQUAL
89280: IFFALSE 89308
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
89282: LD_VAR 0 4
89286: PPUSH
89287: LD_VAR 0 6
89291: PPUSH
89292: LD_VAR 0 4
89296: PPUSH
89297: CALL_OW 74
89301: PPUSH
89302: CALL_OW 112
89306: GO 89332
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
89308: LD_VAR 0 4
89312: PPUSH
89313: LD_VAR 0 6
89317: PPUSH
89318: LD_VAR 0 4
89322: PPUSH
89323: CALL_OW 74
89327: PPUSH
89328: CALL_OW 115
// end else
89332: GO 89434
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
89334: LD_VAR 0 4
89338: PPUSH
89339: LD_VAR 0 2
89343: PUSH
89344: LD_VAR 0 9
89348: ARRAY
89349: PUSH
89350: LD_INT 1
89352: ARRAY
89353: PPUSH
89354: LD_VAR 0 2
89358: PUSH
89359: LD_VAR 0 9
89363: ARRAY
89364: PUSH
89365: LD_INT 2
89367: ARRAY
89368: PPUSH
89369: CALL_OW 297
89373: PUSH
89374: LD_INT 6
89376: GREATER
89377: IFFALSE 89420
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
89379: LD_VAR 0 4
89383: PPUSH
89384: LD_VAR 0 2
89388: PUSH
89389: LD_VAR 0 9
89393: ARRAY
89394: PUSH
89395: LD_INT 1
89397: ARRAY
89398: PPUSH
89399: LD_VAR 0 2
89403: PUSH
89404: LD_VAR 0 9
89408: ARRAY
89409: PUSH
89410: LD_INT 2
89412: ARRAY
89413: PPUSH
89414: CALL_OW 114
89418: GO 89434
// SetTag ( i , tag ) ;
89420: LD_VAR 0 4
89424: PPUSH
89425: LD_VAR 0 9
89429: PPUSH
89430: CALL_OW 109
// end else
89434: GO 89507
// if enemy then
89436: LD_VAR 0 5
89440: IFFALSE 89507
// begin if GetWeapon ( i ) = ru_time_lapser then
89442: LD_VAR 0 4
89446: PPUSH
89447: CALL_OW 264
89451: PUSH
89452: LD_INT 49
89454: EQUAL
89455: IFFALSE 89483
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
89457: LD_VAR 0 4
89461: PPUSH
89462: LD_VAR 0 5
89466: PPUSH
89467: LD_VAR 0 4
89471: PPUSH
89472: CALL_OW 74
89476: PPUSH
89477: CALL_OW 112
89481: GO 89507
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
89483: LD_VAR 0 4
89487: PPUSH
89488: LD_VAR 0 5
89492: PPUSH
89493: LD_VAR 0 4
89497: PPUSH
89498: CALL_OW 74
89502: PPUSH
89503: CALL_OW 115
// end ; end ;
89507: GO 89087
89509: POP
89510: POP
// end ;
89511: LD_VAR 0 3
89515: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
89516: LD_INT 0
89518: PPUSH
89519: PPUSH
89520: PPUSH
// if not unit or IsInUnit ( unit ) then
89521: LD_VAR 0 1
89525: NOT
89526: PUSH
89527: LD_VAR 0 1
89531: PPUSH
89532: CALL_OW 310
89536: OR
89537: IFFALSE 89541
// exit ;
89539: GO 89632
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
89541: LD_ADDR_VAR 0 4
89545: PUSH
89546: LD_VAR 0 1
89550: PPUSH
89551: CALL_OW 250
89555: PPUSH
89556: LD_VAR 0 2
89560: PPUSH
89561: LD_INT 1
89563: PPUSH
89564: CALL_OW 272
89568: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
89569: LD_ADDR_VAR 0 5
89573: PUSH
89574: LD_VAR 0 1
89578: PPUSH
89579: CALL_OW 251
89583: PPUSH
89584: LD_VAR 0 2
89588: PPUSH
89589: LD_INT 1
89591: PPUSH
89592: CALL_OW 273
89596: ST_TO_ADDR
// if ValidHex ( x , y ) then
89597: LD_VAR 0 4
89601: PPUSH
89602: LD_VAR 0 5
89606: PPUSH
89607: CALL_OW 488
89611: IFFALSE 89632
// ComTurnXY ( unit , x , y ) ;
89613: LD_VAR 0 1
89617: PPUSH
89618: LD_VAR 0 4
89622: PPUSH
89623: LD_VAR 0 5
89627: PPUSH
89628: CALL_OW 118
// end ;
89632: LD_VAR 0 3
89636: RET
// export function SeeUnits ( side , units ) ; var i ; begin
89637: LD_INT 0
89639: PPUSH
89640: PPUSH
// result := false ;
89641: LD_ADDR_VAR 0 3
89645: PUSH
89646: LD_INT 0
89648: ST_TO_ADDR
// if not units then
89649: LD_VAR 0 2
89653: NOT
89654: IFFALSE 89658
// exit ;
89656: GO 89703
// for i in units do
89658: LD_ADDR_VAR 0 4
89662: PUSH
89663: LD_VAR 0 2
89667: PUSH
89668: FOR_IN
89669: IFFALSE 89701
// if See ( side , i ) then
89671: LD_VAR 0 1
89675: PPUSH
89676: LD_VAR 0 4
89680: PPUSH
89681: CALL_OW 292
89685: IFFALSE 89699
// begin result := true ;
89687: LD_ADDR_VAR 0 3
89691: PUSH
89692: LD_INT 1
89694: ST_TO_ADDR
// exit ;
89695: POP
89696: POP
89697: GO 89703
// end ;
89699: GO 89668
89701: POP
89702: POP
// end ;
89703: LD_VAR 0 3
89707: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
89708: LD_INT 0
89710: PPUSH
89711: PPUSH
89712: PPUSH
89713: PPUSH
// if not unit or not points then
89714: LD_VAR 0 1
89718: NOT
89719: PUSH
89720: LD_VAR 0 2
89724: NOT
89725: OR
89726: IFFALSE 89730
// exit ;
89728: GO 89820
// dist := 99999 ;
89730: LD_ADDR_VAR 0 5
89734: PUSH
89735: LD_INT 99999
89737: ST_TO_ADDR
// for i in points do
89738: LD_ADDR_VAR 0 4
89742: PUSH
89743: LD_VAR 0 2
89747: PUSH
89748: FOR_IN
89749: IFFALSE 89818
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
89751: LD_ADDR_VAR 0 6
89755: PUSH
89756: LD_VAR 0 1
89760: PPUSH
89761: LD_VAR 0 4
89765: PUSH
89766: LD_INT 1
89768: ARRAY
89769: PPUSH
89770: LD_VAR 0 4
89774: PUSH
89775: LD_INT 2
89777: ARRAY
89778: PPUSH
89779: CALL_OW 297
89783: ST_TO_ADDR
// if tmpDist < dist then
89784: LD_VAR 0 6
89788: PUSH
89789: LD_VAR 0 5
89793: LESS
89794: IFFALSE 89816
// begin result := i ;
89796: LD_ADDR_VAR 0 3
89800: PUSH
89801: LD_VAR 0 4
89805: ST_TO_ADDR
// dist := tmpDist ;
89806: LD_ADDR_VAR 0 5
89810: PUSH
89811: LD_VAR 0 6
89815: ST_TO_ADDR
// end ; end ;
89816: GO 89748
89818: POP
89819: POP
// end ;
89820: LD_VAR 0 3
89824: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
89825: LD_INT 0
89827: PPUSH
// uc_side := side ;
89828: LD_ADDR_OWVAR 20
89832: PUSH
89833: LD_VAR 0 1
89837: ST_TO_ADDR
// uc_nation := 3 ;
89838: LD_ADDR_OWVAR 21
89842: PUSH
89843: LD_INT 3
89845: ST_TO_ADDR
// vc_chassis := 25 ;
89846: LD_ADDR_OWVAR 37
89850: PUSH
89851: LD_INT 25
89853: ST_TO_ADDR
// vc_engine := engine_siberite ;
89854: LD_ADDR_OWVAR 39
89858: PUSH
89859: LD_INT 3
89861: ST_TO_ADDR
// vc_control := control_computer ;
89862: LD_ADDR_OWVAR 38
89866: PUSH
89867: LD_INT 3
89869: ST_TO_ADDR
// vc_weapon := 59 ;
89870: LD_ADDR_OWVAR 40
89874: PUSH
89875: LD_INT 59
89877: ST_TO_ADDR
// result := CreateVehicle ;
89878: LD_ADDR_VAR 0 5
89882: PUSH
89883: CALL_OW 45
89887: ST_TO_ADDR
// SetDir ( result , d ) ;
89888: LD_VAR 0 5
89892: PPUSH
89893: LD_VAR 0 4
89897: PPUSH
89898: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
89902: LD_VAR 0 5
89906: PPUSH
89907: LD_VAR 0 2
89911: PPUSH
89912: LD_VAR 0 3
89916: PPUSH
89917: LD_INT 0
89919: PPUSH
89920: CALL_OW 48
// end ;
89924: LD_VAR 0 5
89928: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
89929: LD_INT 0
89931: PPUSH
89932: PPUSH
89933: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
89934: LD_ADDR_VAR 0 2
89938: PUSH
89939: LD_INT 0
89941: PUSH
89942: LD_INT 0
89944: PUSH
89945: LD_INT 0
89947: PUSH
89948: LD_INT 0
89950: PUSH
89951: EMPTY
89952: LIST
89953: LIST
89954: LIST
89955: LIST
89956: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
89957: LD_VAR 0 1
89961: NOT
89962: PUSH
89963: LD_VAR 0 1
89967: PPUSH
89968: CALL_OW 264
89972: PUSH
89973: LD_INT 12
89975: PUSH
89976: LD_INT 51
89978: PUSH
89979: LD_INT 32
89981: PUSH
89982: LD_INT 89
89984: PUSH
89985: EMPTY
89986: LIST
89987: LIST
89988: LIST
89989: LIST
89990: IN
89991: NOT
89992: OR
89993: IFFALSE 89997
// exit ;
89995: GO 90095
// for i := 1 to 3 do
89997: LD_ADDR_VAR 0 3
90001: PUSH
90002: DOUBLE
90003: LD_INT 1
90005: DEC
90006: ST_TO_ADDR
90007: LD_INT 3
90009: PUSH
90010: FOR_TO
90011: IFFALSE 90093
// begin tmp := GetCargo ( cargo , i ) ;
90013: LD_ADDR_VAR 0 4
90017: PUSH
90018: LD_VAR 0 1
90022: PPUSH
90023: LD_VAR 0 3
90027: PPUSH
90028: CALL_OW 289
90032: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
90033: LD_ADDR_VAR 0 2
90037: PUSH
90038: LD_VAR 0 2
90042: PPUSH
90043: LD_VAR 0 3
90047: PPUSH
90048: LD_VAR 0 4
90052: PPUSH
90053: CALL_OW 1
90057: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
90058: LD_ADDR_VAR 0 2
90062: PUSH
90063: LD_VAR 0 2
90067: PPUSH
90068: LD_INT 4
90070: PPUSH
90071: LD_VAR 0 2
90075: PUSH
90076: LD_INT 4
90078: ARRAY
90079: PUSH
90080: LD_VAR 0 4
90084: PLUS
90085: PPUSH
90086: CALL_OW 1
90090: ST_TO_ADDR
// end ;
90091: GO 90010
90093: POP
90094: POP
// end ;
90095: LD_VAR 0 2
90099: RET
// export function Length ( array ) ; begin
90100: LD_INT 0
90102: PPUSH
// result := array + 0 ;
90103: LD_ADDR_VAR 0 2
90107: PUSH
90108: LD_VAR 0 1
90112: PUSH
90113: LD_INT 0
90115: PLUS
90116: ST_TO_ADDR
// end ;
90117: LD_VAR 0 2
90121: RET
// export function PrepareArray ( array ) ; begin
90122: LD_INT 0
90124: PPUSH
// result := array diff 0 ;
90125: LD_ADDR_VAR 0 2
90129: PUSH
90130: LD_VAR 0 1
90134: PUSH
90135: LD_INT 0
90137: DIFF
90138: ST_TO_ADDR
// if not result [ 1 ] then
90139: LD_VAR 0 2
90143: PUSH
90144: LD_INT 1
90146: ARRAY
90147: NOT
90148: IFFALSE 90168
// result := Delete ( result , 1 ) ;
90150: LD_ADDR_VAR 0 2
90154: PUSH
90155: LD_VAR 0 2
90159: PPUSH
90160: LD_INT 1
90162: PPUSH
90163: CALL_OW 3
90167: ST_TO_ADDR
// end ;
90168: LD_VAR 0 2
90172: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
90173: LD_INT 0
90175: PPUSH
90176: PPUSH
90177: PPUSH
90178: PPUSH
// sibRocketRange := 25 ;
90179: LD_ADDR_VAR 0 6
90183: PUSH
90184: LD_INT 25
90186: ST_TO_ADDR
// result := false ;
90187: LD_ADDR_VAR 0 4
90191: PUSH
90192: LD_INT 0
90194: ST_TO_ADDR
// for i := 0 to 5 do
90195: LD_ADDR_VAR 0 5
90199: PUSH
90200: DOUBLE
90201: LD_INT 0
90203: DEC
90204: ST_TO_ADDR
90205: LD_INT 5
90207: PUSH
90208: FOR_TO
90209: IFFALSE 90276
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
90211: LD_VAR 0 1
90215: PPUSH
90216: LD_VAR 0 5
90220: PPUSH
90221: LD_VAR 0 6
90225: PPUSH
90226: CALL_OW 272
90230: PPUSH
90231: LD_VAR 0 2
90235: PPUSH
90236: LD_VAR 0 5
90240: PPUSH
90241: LD_VAR 0 6
90245: PPUSH
90246: CALL_OW 273
90250: PPUSH
90251: LD_VAR 0 3
90255: PPUSH
90256: CALL_OW 309
90260: IFFALSE 90274
// begin result := true ;
90262: LD_ADDR_VAR 0 4
90266: PUSH
90267: LD_INT 1
90269: ST_TO_ADDR
// exit ;
90270: POP
90271: POP
90272: GO 90278
// end ;
90274: GO 90208
90276: POP
90277: POP
// end ;
90278: LD_VAR 0 4
90282: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
90283: LD_INT 0
90285: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
90286: LD_VAR 0 1
90290: PPUSH
90291: LD_VAR 0 2
90295: PPUSH
90296: LD_INT 0
90298: PPUSH
90299: LD_INT 0
90301: PPUSH
90302: LD_INT 1
90304: PPUSH
90305: LD_INT 0
90307: PPUSH
90308: CALL_OW 587
// end ;
90312: LD_VAR 0 3
90316: RET
// export function CenterOnNow ( unit ) ; begin
90317: LD_INT 0
90319: PPUSH
// result := IsInUnit ( unit ) ;
90320: LD_ADDR_VAR 0 2
90324: PUSH
90325: LD_VAR 0 1
90329: PPUSH
90330: CALL_OW 310
90334: ST_TO_ADDR
// if not result then
90335: LD_VAR 0 2
90339: NOT
90340: IFFALSE 90352
// result := unit ;
90342: LD_ADDR_VAR 0 2
90346: PUSH
90347: LD_VAR 0 1
90351: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
90352: LD_VAR 0 1
90356: PPUSH
90357: CALL_OW 87
// end ;
90361: LD_VAR 0 2
90365: RET
// export function ComMoveHex ( unit , hex ) ; begin
90366: LD_INT 0
90368: PPUSH
// if not hex then
90369: LD_VAR 0 2
90373: NOT
90374: IFFALSE 90378
// exit ;
90376: GO 90431
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
90378: LD_VAR 0 2
90382: PUSH
90383: LD_INT 1
90385: ARRAY
90386: PPUSH
90387: LD_VAR 0 2
90391: PUSH
90392: LD_INT 2
90394: ARRAY
90395: PPUSH
90396: CALL_OW 428
90400: IFFALSE 90404
// exit ;
90402: GO 90431
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
90404: LD_VAR 0 1
90408: PPUSH
90409: LD_VAR 0 2
90413: PUSH
90414: LD_INT 1
90416: ARRAY
90417: PPUSH
90418: LD_VAR 0 2
90422: PUSH
90423: LD_INT 2
90425: ARRAY
90426: PPUSH
90427: CALL_OW 111
// end ; end_of_file end_of_file
90431: LD_VAR 0 3
90435: RET
// export globalGameSaveCounter ; every 0 0$1 do
90436: GO 90438
90438: DISABLE
// begin enable ;
90439: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
90440: LD_STRING updateTimer(
90442: PUSH
90443: LD_OWVAR 1
90447: STR
90448: PUSH
90449: LD_STRING );
90451: STR
90452: PPUSH
90453: CALL_OW 559
// end ;
90457: END
// every 0 0$1 do
90458: GO 90460
90460: DISABLE
// begin globalGameSaveCounter := 0 ;
90461: LD_ADDR_EXP 95
90465: PUSH
90466: LD_INT 0
90468: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
90469: LD_STRING setGameSaveCounter(0)
90471: PPUSH
90472: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
90476: LD_STRING initStreamRollete();
90478: PPUSH
90479: CALL_OW 559
// InitStreamMode ;
90483: CALL 91809 0 0
// DefineStreamItems ( false ) ;
90487: LD_INT 0
90489: PPUSH
90490: CALL 92273 0 1
// end ;
90494: END
// export function SOS_MapStart ( ) ; begin
90495: LD_INT 0
90497: PPUSH
// if streamModeActive then
90498: LD_EXP 96
90502: IFFALSE 90511
// DefineStreamItems ( true ) ;
90504: LD_INT 1
90506: PPUSH
90507: CALL 92273 0 1
// UpdateLuaVariables ( ) ;
90511: CALL 90528 0 0
// UpdateFactoryWaypoints ( ) ;
90515: CALL 105134 0 0
// UpdateWarehouseGatheringPoints ( ) ;
90519: CALL 105391 0 0
// end ;
90523: LD_VAR 0 1
90527: RET
// function UpdateLuaVariables ( ) ; begin
90528: LD_INT 0
90530: PPUSH
// if globalGameSaveCounter then
90531: LD_EXP 95
90535: IFFALSE 90569
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
90537: LD_ADDR_EXP 95
90541: PUSH
90542: LD_EXP 95
90546: PPUSH
90547: CALL 87725 0 1
90551: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
90552: LD_STRING setGameSaveCounter(
90554: PUSH
90555: LD_EXP 95
90559: STR
90560: PUSH
90561: LD_STRING )
90563: STR
90564: PPUSH
90565: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
90569: LD_STRING setGameDifficulty(
90571: PUSH
90572: LD_OWVAR 67
90576: STR
90577: PUSH
90578: LD_STRING )
90580: STR
90581: PPUSH
90582: CALL_OW 559
// end ;
90586: LD_VAR 0 1
90590: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
90591: LD_INT 0
90593: PPUSH
// if p2 = stream_mode then
90594: LD_VAR 0 2
90598: PUSH
90599: LD_INT 100
90601: EQUAL
90602: IFFALSE 91605
// begin if not StreamModeActive then
90604: LD_EXP 96
90608: NOT
90609: IFFALSE 90619
// StreamModeActive := true ;
90611: LD_ADDR_EXP 96
90615: PUSH
90616: LD_INT 1
90618: ST_TO_ADDR
// if p3 = 0 then
90619: LD_VAR 0 3
90623: PUSH
90624: LD_INT 0
90626: EQUAL
90627: IFFALSE 90633
// InitStreamMode ;
90629: CALL 91809 0 0
// if p3 = 1 then
90633: LD_VAR 0 3
90637: PUSH
90638: LD_INT 1
90640: EQUAL
90641: IFFALSE 90651
// sRocket := true ;
90643: LD_ADDR_EXP 101
90647: PUSH
90648: LD_INT 1
90650: ST_TO_ADDR
// if p3 = 2 then
90651: LD_VAR 0 3
90655: PUSH
90656: LD_INT 2
90658: EQUAL
90659: IFFALSE 90669
// sSpeed := true ;
90661: LD_ADDR_EXP 100
90665: PUSH
90666: LD_INT 1
90668: ST_TO_ADDR
// if p3 = 3 then
90669: LD_VAR 0 3
90673: PUSH
90674: LD_INT 3
90676: EQUAL
90677: IFFALSE 90687
// sEngine := true ;
90679: LD_ADDR_EXP 102
90683: PUSH
90684: LD_INT 1
90686: ST_TO_ADDR
// if p3 = 4 then
90687: LD_VAR 0 3
90691: PUSH
90692: LD_INT 4
90694: EQUAL
90695: IFFALSE 90705
// sSpec := true ;
90697: LD_ADDR_EXP 99
90701: PUSH
90702: LD_INT 1
90704: ST_TO_ADDR
// if p3 = 5 then
90705: LD_VAR 0 3
90709: PUSH
90710: LD_INT 5
90712: EQUAL
90713: IFFALSE 90723
// sLevel := true ;
90715: LD_ADDR_EXP 103
90719: PUSH
90720: LD_INT 1
90722: ST_TO_ADDR
// if p3 = 6 then
90723: LD_VAR 0 3
90727: PUSH
90728: LD_INT 6
90730: EQUAL
90731: IFFALSE 90741
// sArmoury := true ;
90733: LD_ADDR_EXP 104
90737: PUSH
90738: LD_INT 1
90740: ST_TO_ADDR
// if p3 = 7 then
90741: LD_VAR 0 3
90745: PUSH
90746: LD_INT 7
90748: EQUAL
90749: IFFALSE 90759
// sRadar := true ;
90751: LD_ADDR_EXP 105
90755: PUSH
90756: LD_INT 1
90758: ST_TO_ADDR
// if p3 = 8 then
90759: LD_VAR 0 3
90763: PUSH
90764: LD_INT 8
90766: EQUAL
90767: IFFALSE 90777
// sBunker := true ;
90769: LD_ADDR_EXP 106
90773: PUSH
90774: LD_INT 1
90776: ST_TO_ADDR
// if p3 = 9 then
90777: LD_VAR 0 3
90781: PUSH
90782: LD_INT 9
90784: EQUAL
90785: IFFALSE 90795
// sHack := true ;
90787: LD_ADDR_EXP 107
90791: PUSH
90792: LD_INT 1
90794: ST_TO_ADDR
// if p3 = 10 then
90795: LD_VAR 0 3
90799: PUSH
90800: LD_INT 10
90802: EQUAL
90803: IFFALSE 90813
// sFire := true ;
90805: LD_ADDR_EXP 108
90809: PUSH
90810: LD_INT 1
90812: ST_TO_ADDR
// if p3 = 11 then
90813: LD_VAR 0 3
90817: PUSH
90818: LD_INT 11
90820: EQUAL
90821: IFFALSE 90831
// sRefresh := true ;
90823: LD_ADDR_EXP 109
90827: PUSH
90828: LD_INT 1
90830: ST_TO_ADDR
// if p3 = 12 then
90831: LD_VAR 0 3
90835: PUSH
90836: LD_INT 12
90838: EQUAL
90839: IFFALSE 90849
// sExp := true ;
90841: LD_ADDR_EXP 110
90845: PUSH
90846: LD_INT 1
90848: ST_TO_ADDR
// if p3 = 13 then
90849: LD_VAR 0 3
90853: PUSH
90854: LD_INT 13
90856: EQUAL
90857: IFFALSE 90867
// sDepot := true ;
90859: LD_ADDR_EXP 111
90863: PUSH
90864: LD_INT 1
90866: ST_TO_ADDR
// if p3 = 14 then
90867: LD_VAR 0 3
90871: PUSH
90872: LD_INT 14
90874: EQUAL
90875: IFFALSE 90885
// sFlag := true ;
90877: LD_ADDR_EXP 112
90881: PUSH
90882: LD_INT 1
90884: ST_TO_ADDR
// if p3 = 15 then
90885: LD_VAR 0 3
90889: PUSH
90890: LD_INT 15
90892: EQUAL
90893: IFFALSE 90903
// sKamikadze := true ;
90895: LD_ADDR_EXP 120
90899: PUSH
90900: LD_INT 1
90902: ST_TO_ADDR
// if p3 = 16 then
90903: LD_VAR 0 3
90907: PUSH
90908: LD_INT 16
90910: EQUAL
90911: IFFALSE 90921
// sTroll := true ;
90913: LD_ADDR_EXP 121
90917: PUSH
90918: LD_INT 1
90920: ST_TO_ADDR
// if p3 = 17 then
90921: LD_VAR 0 3
90925: PUSH
90926: LD_INT 17
90928: EQUAL
90929: IFFALSE 90939
// sSlow := true ;
90931: LD_ADDR_EXP 122
90935: PUSH
90936: LD_INT 1
90938: ST_TO_ADDR
// if p3 = 18 then
90939: LD_VAR 0 3
90943: PUSH
90944: LD_INT 18
90946: EQUAL
90947: IFFALSE 90957
// sLack := true ;
90949: LD_ADDR_EXP 123
90953: PUSH
90954: LD_INT 1
90956: ST_TO_ADDR
// if p3 = 19 then
90957: LD_VAR 0 3
90961: PUSH
90962: LD_INT 19
90964: EQUAL
90965: IFFALSE 90975
// sTank := true ;
90967: LD_ADDR_EXP 125
90971: PUSH
90972: LD_INT 1
90974: ST_TO_ADDR
// if p3 = 20 then
90975: LD_VAR 0 3
90979: PUSH
90980: LD_INT 20
90982: EQUAL
90983: IFFALSE 90993
// sRemote := true ;
90985: LD_ADDR_EXP 126
90989: PUSH
90990: LD_INT 1
90992: ST_TO_ADDR
// if p3 = 21 then
90993: LD_VAR 0 3
90997: PUSH
90998: LD_INT 21
91000: EQUAL
91001: IFFALSE 91011
// sPowell := true ;
91003: LD_ADDR_EXP 127
91007: PUSH
91008: LD_INT 1
91010: ST_TO_ADDR
// if p3 = 22 then
91011: LD_VAR 0 3
91015: PUSH
91016: LD_INT 22
91018: EQUAL
91019: IFFALSE 91029
// sTeleport := true ;
91021: LD_ADDR_EXP 130
91025: PUSH
91026: LD_INT 1
91028: ST_TO_ADDR
// if p3 = 23 then
91029: LD_VAR 0 3
91033: PUSH
91034: LD_INT 23
91036: EQUAL
91037: IFFALSE 91047
// sOilTower := true ;
91039: LD_ADDR_EXP 132
91043: PUSH
91044: LD_INT 1
91046: ST_TO_ADDR
// if p3 = 24 then
91047: LD_VAR 0 3
91051: PUSH
91052: LD_INT 24
91054: EQUAL
91055: IFFALSE 91065
// sShovel := true ;
91057: LD_ADDR_EXP 133
91061: PUSH
91062: LD_INT 1
91064: ST_TO_ADDR
// if p3 = 25 then
91065: LD_VAR 0 3
91069: PUSH
91070: LD_INT 25
91072: EQUAL
91073: IFFALSE 91083
// sSheik := true ;
91075: LD_ADDR_EXP 134
91079: PUSH
91080: LD_INT 1
91082: ST_TO_ADDR
// if p3 = 26 then
91083: LD_VAR 0 3
91087: PUSH
91088: LD_INT 26
91090: EQUAL
91091: IFFALSE 91101
// sEarthquake := true ;
91093: LD_ADDR_EXP 136
91097: PUSH
91098: LD_INT 1
91100: ST_TO_ADDR
// if p3 = 27 then
91101: LD_VAR 0 3
91105: PUSH
91106: LD_INT 27
91108: EQUAL
91109: IFFALSE 91119
// sAI := true ;
91111: LD_ADDR_EXP 137
91115: PUSH
91116: LD_INT 1
91118: ST_TO_ADDR
// if p3 = 28 then
91119: LD_VAR 0 3
91123: PUSH
91124: LD_INT 28
91126: EQUAL
91127: IFFALSE 91137
// sCargo := true ;
91129: LD_ADDR_EXP 140
91133: PUSH
91134: LD_INT 1
91136: ST_TO_ADDR
// if p3 = 29 then
91137: LD_VAR 0 3
91141: PUSH
91142: LD_INT 29
91144: EQUAL
91145: IFFALSE 91155
// sDLaser := true ;
91147: LD_ADDR_EXP 141
91151: PUSH
91152: LD_INT 1
91154: ST_TO_ADDR
// if p3 = 30 then
91155: LD_VAR 0 3
91159: PUSH
91160: LD_INT 30
91162: EQUAL
91163: IFFALSE 91173
// sExchange := true ;
91165: LD_ADDR_EXP 142
91169: PUSH
91170: LD_INT 1
91172: ST_TO_ADDR
// if p3 = 31 then
91173: LD_VAR 0 3
91177: PUSH
91178: LD_INT 31
91180: EQUAL
91181: IFFALSE 91191
// sFac := true ;
91183: LD_ADDR_EXP 143
91187: PUSH
91188: LD_INT 1
91190: ST_TO_ADDR
// if p3 = 32 then
91191: LD_VAR 0 3
91195: PUSH
91196: LD_INT 32
91198: EQUAL
91199: IFFALSE 91209
// sPower := true ;
91201: LD_ADDR_EXP 144
91205: PUSH
91206: LD_INT 1
91208: ST_TO_ADDR
// if p3 = 33 then
91209: LD_VAR 0 3
91213: PUSH
91214: LD_INT 33
91216: EQUAL
91217: IFFALSE 91227
// sRandom := true ;
91219: LD_ADDR_EXP 145
91223: PUSH
91224: LD_INT 1
91226: ST_TO_ADDR
// if p3 = 34 then
91227: LD_VAR 0 3
91231: PUSH
91232: LD_INT 34
91234: EQUAL
91235: IFFALSE 91245
// sShield := true ;
91237: LD_ADDR_EXP 146
91241: PUSH
91242: LD_INT 1
91244: ST_TO_ADDR
// if p3 = 35 then
91245: LD_VAR 0 3
91249: PUSH
91250: LD_INT 35
91252: EQUAL
91253: IFFALSE 91263
// sTime := true ;
91255: LD_ADDR_EXP 147
91259: PUSH
91260: LD_INT 1
91262: ST_TO_ADDR
// if p3 = 36 then
91263: LD_VAR 0 3
91267: PUSH
91268: LD_INT 36
91270: EQUAL
91271: IFFALSE 91281
// sTools := true ;
91273: LD_ADDR_EXP 148
91277: PUSH
91278: LD_INT 1
91280: ST_TO_ADDR
// if p3 = 101 then
91281: LD_VAR 0 3
91285: PUSH
91286: LD_INT 101
91288: EQUAL
91289: IFFALSE 91299
// sSold := true ;
91291: LD_ADDR_EXP 113
91295: PUSH
91296: LD_INT 1
91298: ST_TO_ADDR
// if p3 = 102 then
91299: LD_VAR 0 3
91303: PUSH
91304: LD_INT 102
91306: EQUAL
91307: IFFALSE 91317
// sDiff := true ;
91309: LD_ADDR_EXP 114
91313: PUSH
91314: LD_INT 1
91316: ST_TO_ADDR
// if p3 = 103 then
91317: LD_VAR 0 3
91321: PUSH
91322: LD_INT 103
91324: EQUAL
91325: IFFALSE 91335
// sFog := true ;
91327: LD_ADDR_EXP 117
91331: PUSH
91332: LD_INT 1
91334: ST_TO_ADDR
// if p3 = 104 then
91335: LD_VAR 0 3
91339: PUSH
91340: LD_INT 104
91342: EQUAL
91343: IFFALSE 91353
// sReset := true ;
91345: LD_ADDR_EXP 118
91349: PUSH
91350: LD_INT 1
91352: ST_TO_ADDR
// if p3 = 105 then
91353: LD_VAR 0 3
91357: PUSH
91358: LD_INT 105
91360: EQUAL
91361: IFFALSE 91371
// sSun := true ;
91363: LD_ADDR_EXP 119
91367: PUSH
91368: LD_INT 1
91370: ST_TO_ADDR
// if p3 = 106 then
91371: LD_VAR 0 3
91375: PUSH
91376: LD_INT 106
91378: EQUAL
91379: IFFALSE 91389
// sTiger := true ;
91381: LD_ADDR_EXP 115
91385: PUSH
91386: LD_INT 1
91388: ST_TO_ADDR
// if p3 = 107 then
91389: LD_VAR 0 3
91393: PUSH
91394: LD_INT 107
91396: EQUAL
91397: IFFALSE 91407
// sBomb := true ;
91399: LD_ADDR_EXP 116
91403: PUSH
91404: LD_INT 1
91406: ST_TO_ADDR
// if p3 = 108 then
91407: LD_VAR 0 3
91411: PUSH
91412: LD_INT 108
91414: EQUAL
91415: IFFALSE 91425
// sWound := true ;
91417: LD_ADDR_EXP 124
91421: PUSH
91422: LD_INT 1
91424: ST_TO_ADDR
// if p3 = 109 then
91425: LD_VAR 0 3
91429: PUSH
91430: LD_INT 109
91432: EQUAL
91433: IFFALSE 91443
// sBetray := true ;
91435: LD_ADDR_EXP 128
91439: PUSH
91440: LD_INT 1
91442: ST_TO_ADDR
// if p3 = 110 then
91443: LD_VAR 0 3
91447: PUSH
91448: LD_INT 110
91450: EQUAL
91451: IFFALSE 91461
// sContamin := true ;
91453: LD_ADDR_EXP 129
91457: PUSH
91458: LD_INT 1
91460: ST_TO_ADDR
// if p3 = 111 then
91461: LD_VAR 0 3
91465: PUSH
91466: LD_INT 111
91468: EQUAL
91469: IFFALSE 91479
// sOil := true ;
91471: LD_ADDR_EXP 131
91475: PUSH
91476: LD_INT 1
91478: ST_TO_ADDR
// if p3 = 112 then
91479: LD_VAR 0 3
91483: PUSH
91484: LD_INT 112
91486: EQUAL
91487: IFFALSE 91497
// sStu := true ;
91489: LD_ADDR_EXP 135
91493: PUSH
91494: LD_INT 1
91496: ST_TO_ADDR
// if p3 = 113 then
91497: LD_VAR 0 3
91501: PUSH
91502: LD_INT 113
91504: EQUAL
91505: IFFALSE 91515
// sBazooka := true ;
91507: LD_ADDR_EXP 138
91511: PUSH
91512: LD_INT 1
91514: ST_TO_ADDR
// if p3 = 114 then
91515: LD_VAR 0 3
91519: PUSH
91520: LD_INT 114
91522: EQUAL
91523: IFFALSE 91533
// sMortar := true ;
91525: LD_ADDR_EXP 139
91529: PUSH
91530: LD_INT 1
91532: ST_TO_ADDR
// if p3 = 115 then
91533: LD_VAR 0 3
91537: PUSH
91538: LD_INT 115
91540: EQUAL
91541: IFFALSE 91551
// sRanger := true ;
91543: LD_ADDR_EXP 149
91547: PUSH
91548: LD_INT 1
91550: ST_TO_ADDR
// if p3 = 116 then
91551: LD_VAR 0 3
91555: PUSH
91556: LD_INT 116
91558: EQUAL
91559: IFFALSE 91569
// sComputer := true ;
91561: LD_ADDR_EXP 150
91565: PUSH
91566: LD_INT 1
91568: ST_TO_ADDR
// if p3 = 117 then
91569: LD_VAR 0 3
91573: PUSH
91574: LD_INT 117
91576: EQUAL
91577: IFFALSE 91587
// s30 := true ;
91579: LD_ADDR_EXP 151
91583: PUSH
91584: LD_INT 1
91586: ST_TO_ADDR
// if p3 = 118 then
91587: LD_VAR 0 3
91591: PUSH
91592: LD_INT 118
91594: EQUAL
91595: IFFALSE 91605
// s60 := true ;
91597: LD_ADDR_EXP 152
91601: PUSH
91602: LD_INT 1
91604: ST_TO_ADDR
// end ; if p2 = hack_mode then
91605: LD_VAR 0 2
91609: PUSH
91610: LD_INT 101
91612: EQUAL
91613: IFFALSE 91741
// begin case p3 of 1 :
91615: LD_VAR 0 3
91619: PUSH
91620: LD_INT 1
91622: DOUBLE
91623: EQUAL
91624: IFTRUE 91628
91626: GO 91635
91628: POP
// hHackUnlimitedResources ; 2 :
91629: CALL 103880 0 0
91633: GO 91741
91635: LD_INT 2
91637: DOUBLE
91638: EQUAL
91639: IFTRUE 91643
91641: GO 91650
91643: POP
// hHackSetLevel10 ; 3 :
91644: CALL 104013 0 0
91648: GO 91741
91650: LD_INT 3
91652: DOUBLE
91653: EQUAL
91654: IFTRUE 91658
91656: GO 91665
91658: POP
// hHackSetLevel10YourUnits ; 4 :
91659: CALL 104098 0 0
91663: GO 91741
91665: LD_INT 4
91667: DOUBLE
91668: EQUAL
91669: IFTRUE 91673
91671: GO 91680
91673: POP
// hHackInvincible ; 5 :
91674: CALL 104546 0 0
91678: GO 91741
91680: LD_INT 5
91682: DOUBLE
91683: EQUAL
91684: IFTRUE 91688
91686: GO 91695
91688: POP
// hHackInvisible ; 6 :
91689: CALL 104657 0 0
91693: GO 91741
91695: LD_INT 6
91697: DOUBLE
91698: EQUAL
91699: IFTRUE 91703
91701: GO 91710
91703: POP
// hHackChangeYourSide ; 7 :
91704: CALL 104714 0 0
91708: GO 91741
91710: LD_INT 7
91712: DOUBLE
91713: EQUAL
91714: IFTRUE 91718
91716: GO 91725
91718: POP
// hHackChangeUnitSide ; 8 :
91719: CALL 104756 0 0
91723: GO 91741
91725: LD_INT 8
91727: DOUBLE
91728: EQUAL
91729: IFTRUE 91733
91731: GO 91740
91733: POP
// hHackFog ; end ;
91734: CALL 104857 0 0
91738: GO 91741
91740: POP
// end ; if p2 = game_save_mode then
91741: LD_VAR 0 2
91745: PUSH
91746: LD_INT 102
91748: EQUAL
91749: IFFALSE 91804
// begin if p3 = 1 then
91751: LD_VAR 0 3
91755: PUSH
91756: LD_INT 1
91758: EQUAL
91759: IFFALSE 91771
// globalGameSaveCounter := p4 ;
91761: LD_ADDR_EXP 95
91765: PUSH
91766: LD_VAR 0 4
91770: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
91771: LD_VAR 0 3
91775: PUSH
91776: LD_INT 2
91778: EQUAL
91779: PUSH
91780: LD_EXP 95
91784: AND
91785: IFFALSE 91804
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
91787: LD_STRING setGameSaveCounter(
91789: PUSH
91790: LD_EXP 95
91794: STR
91795: PUSH
91796: LD_STRING )
91798: STR
91799: PPUSH
91800: CALL_OW 559
// end ; end ;
91804: LD_VAR 0 7
91808: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
91809: LD_INT 0
91811: PPUSH
// streamModeActive := false ;
91812: LD_ADDR_EXP 96
91816: PUSH
91817: LD_INT 0
91819: ST_TO_ADDR
// normalCounter := 36 ;
91820: LD_ADDR_EXP 97
91824: PUSH
91825: LD_INT 36
91827: ST_TO_ADDR
// hardcoreCounter := 18 ;
91828: LD_ADDR_EXP 98
91832: PUSH
91833: LD_INT 18
91835: ST_TO_ADDR
// sRocket := false ;
91836: LD_ADDR_EXP 101
91840: PUSH
91841: LD_INT 0
91843: ST_TO_ADDR
// sSpeed := false ;
91844: LD_ADDR_EXP 100
91848: PUSH
91849: LD_INT 0
91851: ST_TO_ADDR
// sEngine := false ;
91852: LD_ADDR_EXP 102
91856: PUSH
91857: LD_INT 0
91859: ST_TO_ADDR
// sSpec := false ;
91860: LD_ADDR_EXP 99
91864: PUSH
91865: LD_INT 0
91867: ST_TO_ADDR
// sLevel := false ;
91868: LD_ADDR_EXP 103
91872: PUSH
91873: LD_INT 0
91875: ST_TO_ADDR
// sArmoury := false ;
91876: LD_ADDR_EXP 104
91880: PUSH
91881: LD_INT 0
91883: ST_TO_ADDR
// sRadar := false ;
91884: LD_ADDR_EXP 105
91888: PUSH
91889: LD_INT 0
91891: ST_TO_ADDR
// sBunker := false ;
91892: LD_ADDR_EXP 106
91896: PUSH
91897: LD_INT 0
91899: ST_TO_ADDR
// sHack := false ;
91900: LD_ADDR_EXP 107
91904: PUSH
91905: LD_INT 0
91907: ST_TO_ADDR
// sFire := false ;
91908: LD_ADDR_EXP 108
91912: PUSH
91913: LD_INT 0
91915: ST_TO_ADDR
// sRefresh := false ;
91916: LD_ADDR_EXP 109
91920: PUSH
91921: LD_INT 0
91923: ST_TO_ADDR
// sExp := false ;
91924: LD_ADDR_EXP 110
91928: PUSH
91929: LD_INT 0
91931: ST_TO_ADDR
// sDepot := false ;
91932: LD_ADDR_EXP 111
91936: PUSH
91937: LD_INT 0
91939: ST_TO_ADDR
// sFlag := false ;
91940: LD_ADDR_EXP 112
91944: PUSH
91945: LD_INT 0
91947: ST_TO_ADDR
// sKamikadze := false ;
91948: LD_ADDR_EXP 120
91952: PUSH
91953: LD_INT 0
91955: ST_TO_ADDR
// sTroll := false ;
91956: LD_ADDR_EXP 121
91960: PUSH
91961: LD_INT 0
91963: ST_TO_ADDR
// sSlow := false ;
91964: LD_ADDR_EXP 122
91968: PUSH
91969: LD_INT 0
91971: ST_TO_ADDR
// sLack := false ;
91972: LD_ADDR_EXP 123
91976: PUSH
91977: LD_INT 0
91979: ST_TO_ADDR
// sTank := false ;
91980: LD_ADDR_EXP 125
91984: PUSH
91985: LD_INT 0
91987: ST_TO_ADDR
// sRemote := false ;
91988: LD_ADDR_EXP 126
91992: PUSH
91993: LD_INT 0
91995: ST_TO_ADDR
// sPowell := false ;
91996: LD_ADDR_EXP 127
92000: PUSH
92001: LD_INT 0
92003: ST_TO_ADDR
// sTeleport := false ;
92004: LD_ADDR_EXP 130
92008: PUSH
92009: LD_INT 0
92011: ST_TO_ADDR
// sOilTower := false ;
92012: LD_ADDR_EXP 132
92016: PUSH
92017: LD_INT 0
92019: ST_TO_ADDR
// sShovel := false ;
92020: LD_ADDR_EXP 133
92024: PUSH
92025: LD_INT 0
92027: ST_TO_ADDR
// sSheik := false ;
92028: LD_ADDR_EXP 134
92032: PUSH
92033: LD_INT 0
92035: ST_TO_ADDR
// sEarthquake := false ;
92036: LD_ADDR_EXP 136
92040: PUSH
92041: LD_INT 0
92043: ST_TO_ADDR
// sAI := false ;
92044: LD_ADDR_EXP 137
92048: PUSH
92049: LD_INT 0
92051: ST_TO_ADDR
// sCargo := false ;
92052: LD_ADDR_EXP 140
92056: PUSH
92057: LD_INT 0
92059: ST_TO_ADDR
// sDLaser := false ;
92060: LD_ADDR_EXP 141
92064: PUSH
92065: LD_INT 0
92067: ST_TO_ADDR
// sExchange := false ;
92068: LD_ADDR_EXP 142
92072: PUSH
92073: LD_INT 0
92075: ST_TO_ADDR
// sFac := false ;
92076: LD_ADDR_EXP 143
92080: PUSH
92081: LD_INT 0
92083: ST_TO_ADDR
// sPower := false ;
92084: LD_ADDR_EXP 144
92088: PUSH
92089: LD_INT 0
92091: ST_TO_ADDR
// sRandom := false ;
92092: LD_ADDR_EXP 145
92096: PUSH
92097: LD_INT 0
92099: ST_TO_ADDR
// sShield := false ;
92100: LD_ADDR_EXP 146
92104: PUSH
92105: LD_INT 0
92107: ST_TO_ADDR
// sTime := false ;
92108: LD_ADDR_EXP 147
92112: PUSH
92113: LD_INT 0
92115: ST_TO_ADDR
// sTools := false ;
92116: LD_ADDR_EXP 148
92120: PUSH
92121: LD_INT 0
92123: ST_TO_ADDR
// sSold := false ;
92124: LD_ADDR_EXP 113
92128: PUSH
92129: LD_INT 0
92131: ST_TO_ADDR
// sDiff := false ;
92132: LD_ADDR_EXP 114
92136: PUSH
92137: LD_INT 0
92139: ST_TO_ADDR
// sFog := false ;
92140: LD_ADDR_EXP 117
92144: PUSH
92145: LD_INT 0
92147: ST_TO_ADDR
// sReset := false ;
92148: LD_ADDR_EXP 118
92152: PUSH
92153: LD_INT 0
92155: ST_TO_ADDR
// sSun := false ;
92156: LD_ADDR_EXP 119
92160: PUSH
92161: LD_INT 0
92163: ST_TO_ADDR
// sTiger := false ;
92164: LD_ADDR_EXP 115
92168: PUSH
92169: LD_INT 0
92171: ST_TO_ADDR
// sBomb := false ;
92172: LD_ADDR_EXP 116
92176: PUSH
92177: LD_INT 0
92179: ST_TO_ADDR
// sWound := false ;
92180: LD_ADDR_EXP 124
92184: PUSH
92185: LD_INT 0
92187: ST_TO_ADDR
// sBetray := false ;
92188: LD_ADDR_EXP 128
92192: PUSH
92193: LD_INT 0
92195: ST_TO_ADDR
// sContamin := false ;
92196: LD_ADDR_EXP 129
92200: PUSH
92201: LD_INT 0
92203: ST_TO_ADDR
// sOil := false ;
92204: LD_ADDR_EXP 131
92208: PUSH
92209: LD_INT 0
92211: ST_TO_ADDR
// sStu := false ;
92212: LD_ADDR_EXP 135
92216: PUSH
92217: LD_INT 0
92219: ST_TO_ADDR
// sBazooka := false ;
92220: LD_ADDR_EXP 138
92224: PUSH
92225: LD_INT 0
92227: ST_TO_ADDR
// sMortar := false ;
92228: LD_ADDR_EXP 139
92232: PUSH
92233: LD_INT 0
92235: ST_TO_ADDR
// sRanger := false ;
92236: LD_ADDR_EXP 149
92240: PUSH
92241: LD_INT 0
92243: ST_TO_ADDR
// sComputer := false ;
92244: LD_ADDR_EXP 150
92248: PUSH
92249: LD_INT 0
92251: ST_TO_ADDR
// s30 := false ;
92252: LD_ADDR_EXP 151
92256: PUSH
92257: LD_INT 0
92259: ST_TO_ADDR
// s60 := false ;
92260: LD_ADDR_EXP 152
92264: PUSH
92265: LD_INT 0
92267: ST_TO_ADDR
// end ;
92268: LD_VAR 0 1
92272: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
92273: LD_INT 0
92275: PPUSH
92276: PPUSH
92277: PPUSH
92278: PPUSH
92279: PPUSH
92280: PPUSH
92281: PPUSH
// result := [ ] ;
92282: LD_ADDR_VAR 0 2
92286: PUSH
92287: EMPTY
92288: ST_TO_ADDR
// if campaign_id = 1 then
92289: LD_OWVAR 69
92293: PUSH
92294: LD_INT 1
92296: EQUAL
92297: IFFALSE 95463
// begin case mission_number of 1 :
92299: LD_OWVAR 70
92303: PUSH
92304: LD_INT 1
92306: DOUBLE
92307: EQUAL
92308: IFTRUE 92312
92310: GO 92388
92312: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
92313: LD_ADDR_VAR 0 2
92317: PUSH
92318: LD_INT 2
92320: PUSH
92321: LD_INT 4
92323: PUSH
92324: LD_INT 11
92326: PUSH
92327: LD_INT 12
92329: PUSH
92330: LD_INT 15
92332: PUSH
92333: LD_INT 16
92335: PUSH
92336: LD_INT 22
92338: PUSH
92339: LD_INT 23
92341: PUSH
92342: LD_INT 26
92344: PUSH
92345: EMPTY
92346: LIST
92347: LIST
92348: LIST
92349: LIST
92350: LIST
92351: LIST
92352: LIST
92353: LIST
92354: LIST
92355: PUSH
92356: LD_INT 101
92358: PUSH
92359: LD_INT 102
92361: PUSH
92362: LD_INT 106
92364: PUSH
92365: LD_INT 116
92367: PUSH
92368: LD_INT 117
92370: PUSH
92371: LD_INT 118
92373: PUSH
92374: EMPTY
92375: LIST
92376: LIST
92377: LIST
92378: LIST
92379: LIST
92380: LIST
92381: PUSH
92382: EMPTY
92383: LIST
92384: LIST
92385: ST_TO_ADDR
92386: GO 95461
92388: LD_INT 2
92390: DOUBLE
92391: EQUAL
92392: IFTRUE 92396
92394: GO 92480
92396: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
92397: LD_ADDR_VAR 0 2
92401: PUSH
92402: LD_INT 2
92404: PUSH
92405: LD_INT 4
92407: PUSH
92408: LD_INT 11
92410: PUSH
92411: LD_INT 12
92413: PUSH
92414: LD_INT 15
92416: PUSH
92417: LD_INT 16
92419: PUSH
92420: LD_INT 22
92422: PUSH
92423: LD_INT 23
92425: PUSH
92426: LD_INT 26
92428: PUSH
92429: EMPTY
92430: LIST
92431: LIST
92432: LIST
92433: LIST
92434: LIST
92435: LIST
92436: LIST
92437: LIST
92438: LIST
92439: PUSH
92440: LD_INT 101
92442: PUSH
92443: LD_INT 102
92445: PUSH
92446: LD_INT 105
92448: PUSH
92449: LD_INT 106
92451: PUSH
92452: LD_INT 108
92454: PUSH
92455: LD_INT 116
92457: PUSH
92458: LD_INT 117
92460: PUSH
92461: LD_INT 118
92463: PUSH
92464: EMPTY
92465: LIST
92466: LIST
92467: LIST
92468: LIST
92469: LIST
92470: LIST
92471: LIST
92472: LIST
92473: PUSH
92474: EMPTY
92475: LIST
92476: LIST
92477: ST_TO_ADDR
92478: GO 95461
92480: LD_INT 3
92482: DOUBLE
92483: EQUAL
92484: IFTRUE 92488
92486: GO 92576
92488: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
92489: LD_ADDR_VAR 0 2
92493: PUSH
92494: LD_INT 2
92496: PUSH
92497: LD_INT 4
92499: PUSH
92500: LD_INT 5
92502: PUSH
92503: LD_INT 11
92505: PUSH
92506: LD_INT 12
92508: PUSH
92509: LD_INT 15
92511: PUSH
92512: LD_INT 16
92514: PUSH
92515: LD_INT 22
92517: PUSH
92518: LD_INT 26
92520: PUSH
92521: LD_INT 36
92523: PUSH
92524: EMPTY
92525: LIST
92526: LIST
92527: LIST
92528: LIST
92529: LIST
92530: LIST
92531: LIST
92532: LIST
92533: LIST
92534: LIST
92535: PUSH
92536: LD_INT 101
92538: PUSH
92539: LD_INT 102
92541: PUSH
92542: LD_INT 105
92544: PUSH
92545: LD_INT 106
92547: PUSH
92548: LD_INT 108
92550: PUSH
92551: LD_INT 116
92553: PUSH
92554: LD_INT 117
92556: PUSH
92557: LD_INT 118
92559: PUSH
92560: EMPTY
92561: LIST
92562: LIST
92563: LIST
92564: LIST
92565: LIST
92566: LIST
92567: LIST
92568: LIST
92569: PUSH
92570: EMPTY
92571: LIST
92572: LIST
92573: ST_TO_ADDR
92574: GO 95461
92576: LD_INT 4
92578: DOUBLE
92579: EQUAL
92580: IFTRUE 92584
92582: GO 92680
92584: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
92585: LD_ADDR_VAR 0 2
92589: PUSH
92590: LD_INT 2
92592: PUSH
92593: LD_INT 4
92595: PUSH
92596: LD_INT 5
92598: PUSH
92599: LD_INT 8
92601: PUSH
92602: LD_INT 11
92604: PUSH
92605: LD_INT 12
92607: PUSH
92608: LD_INT 15
92610: PUSH
92611: LD_INT 16
92613: PUSH
92614: LD_INT 22
92616: PUSH
92617: LD_INT 23
92619: PUSH
92620: LD_INT 26
92622: PUSH
92623: LD_INT 36
92625: PUSH
92626: EMPTY
92627: LIST
92628: LIST
92629: LIST
92630: LIST
92631: LIST
92632: LIST
92633: LIST
92634: LIST
92635: LIST
92636: LIST
92637: LIST
92638: LIST
92639: PUSH
92640: LD_INT 101
92642: PUSH
92643: LD_INT 102
92645: PUSH
92646: LD_INT 105
92648: PUSH
92649: LD_INT 106
92651: PUSH
92652: LD_INT 108
92654: PUSH
92655: LD_INT 116
92657: PUSH
92658: LD_INT 117
92660: PUSH
92661: LD_INT 118
92663: PUSH
92664: EMPTY
92665: LIST
92666: LIST
92667: LIST
92668: LIST
92669: LIST
92670: LIST
92671: LIST
92672: LIST
92673: PUSH
92674: EMPTY
92675: LIST
92676: LIST
92677: ST_TO_ADDR
92678: GO 95461
92680: LD_INT 5
92682: DOUBLE
92683: EQUAL
92684: IFTRUE 92688
92686: GO 92800
92688: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
92689: LD_ADDR_VAR 0 2
92693: PUSH
92694: LD_INT 2
92696: PUSH
92697: LD_INT 4
92699: PUSH
92700: LD_INT 5
92702: PUSH
92703: LD_INT 6
92705: PUSH
92706: LD_INT 8
92708: PUSH
92709: LD_INT 11
92711: PUSH
92712: LD_INT 12
92714: PUSH
92715: LD_INT 15
92717: PUSH
92718: LD_INT 16
92720: PUSH
92721: LD_INT 22
92723: PUSH
92724: LD_INT 23
92726: PUSH
92727: LD_INT 25
92729: PUSH
92730: LD_INT 26
92732: PUSH
92733: LD_INT 36
92735: PUSH
92736: EMPTY
92737: LIST
92738: LIST
92739: LIST
92740: LIST
92741: LIST
92742: LIST
92743: LIST
92744: LIST
92745: LIST
92746: LIST
92747: LIST
92748: LIST
92749: LIST
92750: LIST
92751: PUSH
92752: LD_INT 101
92754: PUSH
92755: LD_INT 102
92757: PUSH
92758: LD_INT 105
92760: PUSH
92761: LD_INT 106
92763: PUSH
92764: LD_INT 108
92766: PUSH
92767: LD_INT 109
92769: PUSH
92770: LD_INT 112
92772: PUSH
92773: LD_INT 116
92775: PUSH
92776: LD_INT 117
92778: PUSH
92779: LD_INT 118
92781: PUSH
92782: EMPTY
92783: LIST
92784: LIST
92785: LIST
92786: LIST
92787: LIST
92788: LIST
92789: LIST
92790: LIST
92791: LIST
92792: LIST
92793: PUSH
92794: EMPTY
92795: LIST
92796: LIST
92797: ST_TO_ADDR
92798: GO 95461
92800: LD_INT 6
92802: DOUBLE
92803: EQUAL
92804: IFTRUE 92808
92806: GO 92940
92808: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
92809: LD_ADDR_VAR 0 2
92813: PUSH
92814: LD_INT 2
92816: PUSH
92817: LD_INT 4
92819: PUSH
92820: LD_INT 5
92822: PUSH
92823: LD_INT 6
92825: PUSH
92826: LD_INT 8
92828: PUSH
92829: LD_INT 11
92831: PUSH
92832: LD_INT 12
92834: PUSH
92835: LD_INT 15
92837: PUSH
92838: LD_INT 16
92840: PUSH
92841: LD_INT 20
92843: PUSH
92844: LD_INT 21
92846: PUSH
92847: LD_INT 22
92849: PUSH
92850: LD_INT 23
92852: PUSH
92853: LD_INT 25
92855: PUSH
92856: LD_INT 26
92858: PUSH
92859: LD_INT 30
92861: PUSH
92862: LD_INT 31
92864: PUSH
92865: LD_INT 32
92867: PUSH
92868: LD_INT 36
92870: PUSH
92871: EMPTY
92872: LIST
92873: LIST
92874: LIST
92875: LIST
92876: LIST
92877: LIST
92878: LIST
92879: LIST
92880: LIST
92881: LIST
92882: LIST
92883: LIST
92884: LIST
92885: LIST
92886: LIST
92887: LIST
92888: LIST
92889: LIST
92890: LIST
92891: PUSH
92892: LD_INT 101
92894: PUSH
92895: LD_INT 102
92897: PUSH
92898: LD_INT 105
92900: PUSH
92901: LD_INT 106
92903: PUSH
92904: LD_INT 108
92906: PUSH
92907: LD_INT 109
92909: PUSH
92910: LD_INT 112
92912: PUSH
92913: LD_INT 116
92915: PUSH
92916: LD_INT 117
92918: PUSH
92919: LD_INT 118
92921: PUSH
92922: EMPTY
92923: LIST
92924: LIST
92925: LIST
92926: LIST
92927: LIST
92928: LIST
92929: LIST
92930: LIST
92931: LIST
92932: LIST
92933: PUSH
92934: EMPTY
92935: LIST
92936: LIST
92937: ST_TO_ADDR
92938: GO 95461
92940: LD_INT 7
92942: DOUBLE
92943: EQUAL
92944: IFTRUE 92948
92946: GO 93060
92948: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
92949: LD_ADDR_VAR 0 2
92953: PUSH
92954: LD_INT 2
92956: PUSH
92957: LD_INT 4
92959: PUSH
92960: LD_INT 5
92962: PUSH
92963: LD_INT 7
92965: PUSH
92966: LD_INT 11
92968: PUSH
92969: LD_INT 12
92971: PUSH
92972: LD_INT 15
92974: PUSH
92975: LD_INT 16
92977: PUSH
92978: LD_INT 20
92980: PUSH
92981: LD_INT 21
92983: PUSH
92984: LD_INT 22
92986: PUSH
92987: LD_INT 23
92989: PUSH
92990: LD_INT 25
92992: PUSH
92993: LD_INT 26
92995: PUSH
92996: EMPTY
92997: LIST
92998: LIST
92999: LIST
93000: LIST
93001: LIST
93002: LIST
93003: LIST
93004: LIST
93005: LIST
93006: LIST
93007: LIST
93008: LIST
93009: LIST
93010: LIST
93011: PUSH
93012: LD_INT 101
93014: PUSH
93015: LD_INT 102
93017: PUSH
93018: LD_INT 103
93020: PUSH
93021: LD_INT 105
93023: PUSH
93024: LD_INT 106
93026: PUSH
93027: LD_INT 108
93029: PUSH
93030: LD_INT 112
93032: PUSH
93033: LD_INT 116
93035: PUSH
93036: LD_INT 117
93038: PUSH
93039: LD_INT 118
93041: PUSH
93042: EMPTY
93043: LIST
93044: LIST
93045: LIST
93046: LIST
93047: LIST
93048: LIST
93049: LIST
93050: LIST
93051: LIST
93052: LIST
93053: PUSH
93054: EMPTY
93055: LIST
93056: LIST
93057: ST_TO_ADDR
93058: GO 95461
93060: LD_INT 8
93062: DOUBLE
93063: EQUAL
93064: IFTRUE 93068
93066: GO 93208
93068: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
93069: LD_ADDR_VAR 0 2
93073: PUSH
93074: LD_INT 2
93076: PUSH
93077: LD_INT 4
93079: PUSH
93080: LD_INT 5
93082: PUSH
93083: LD_INT 6
93085: PUSH
93086: LD_INT 7
93088: PUSH
93089: LD_INT 8
93091: PUSH
93092: LD_INT 11
93094: PUSH
93095: LD_INT 12
93097: PUSH
93098: LD_INT 15
93100: PUSH
93101: LD_INT 16
93103: PUSH
93104: LD_INT 20
93106: PUSH
93107: LD_INT 21
93109: PUSH
93110: LD_INT 22
93112: PUSH
93113: LD_INT 23
93115: PUSH
93116: LD_INT 25
93118: PUSH
93119: LD_INT 26
93121: PUSH
93122: LD_INT 30
93124: PUSH
93125: LD_INT 31
93127: PUSH
93128: LD_INT 32
93130: PUSH
93131: LD_INT 36
93133: PUSH
93134: EMPTY
93135: LIST
93136: LIST
93137: LIST
93138: LIST
93139: LIST
93140: LIST
93141: LIST
93142: LIST
93143: LIST
93144: LIST
93145: LIST
93146: LIST
93147: LIST
93148: LIST
93149: LIST
93150: LIST
93151: LIST
93152: LIST
93153: LIST
93154: LIST
93155: PUSH
93156: LD_INT 101
93158: PUSH
93159: LD_INT 102
93161: PUSH
93162: LD_INT 103
93164: PUSH
93165: LD_INT 105
93167: PUSH
93168: LD_INT 106
93170: PUSH
93171: LD_INT 108
93173: PUSH
93174: LD_INT 109
93176: PUSH
93177: LD_INT 112
93179: PUSH
93180: LD_INT 116
93182: PUSH
93183: LD_INT 117
93185: PUSH
93186: LD_INT 118
93188: PUSH
93189: EMPTY
93190: LIST
93191: LIST
93192: LIST
93193: LIST
93194: LIST
93195: LIST
93196: LIST
93197: LIST
93198: LIST
93199: LIST
93200: LIST
93201: PUSH
93202: EMPTY
93203: LIST
93204: LIST
93205: ST_TO_ADDR
93206: GO 95461
93208: LD_INT 9
93210: DOUBLE
93211: EQUAL
93212: IFTRUE 93216
93214: GO 93364
93216: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
93217: LD_ADDR_VAR 0 2
93221: PUSH
93222: LD_INT 2
93224: PUSH
93225: LD_INT 4
93227: PUSH
93228: LD_INT 5
93230: PUSH
93231: LD_INT 6
93233: PUSH
93234: LD_INT 7
93236: PUSH
93237: LD_INT 8
93239: PUSH
93240: LD_INT 11
93242: PUSH
93243: LD_INT 12
93245: PUSH
93246: LD_INT 15
93248: PUSH
93249: LD_INT 16
93251: PUSH
93252: LD_INT 20
93254: PUSH
93255: LD_INT 21
93257: PUSH
93258: LD_INT 22
93260: PUSH
93261: LD_INT 23
93263: PUSH
93264: LD_INT 25
93266: PUSH
93267: LD_INT 26
93269: PUSH
93270: LD_INT 28
93272: PUSH
93273: LD_INT 30
93275: PUSH
93276: LD_INT 31
93278: PUSH
93279: LD_INT 32
93281: PUSH
93282: LD_INT 36
93284: PUSH
93285: EMPTY
93286: LIST
93287: LIST
93288: LIST
93289: LIST
93290: LIST
93291: LIST
93292: LIST
93293: LIST
93294: LIST
93295: LIST
93296: LIST
93297: LIST
93298: LIST
93299: LIST
93300: LIST
93301: LIST
93302: LIST
93303: LIST
93304: LIST
93305: LIST
93306: LIST
93307: PUSH
93308: LD_INT 101
93310: PUSH
93311: LD_INT 102
93313: PUSH
93314: LD_INT 103
93316: PUSH
93317: LD_INT 105
93319: PUSH
93320: LD_INT 106
93322: PUSH
93323: LD_INT 108
93325: PUSH
93326: LD_INT 109
93328: PUSH
93329: LD_INT 112
93331: PUSH
93332: LD_INT 114
93334: PUSH
93335: LD_INT 116
93337: PUSH
93338: LD_INT 117
93340: PUSH
93341: LD_INT 118
93343: PUSH
93344: EMPTY
93345: LIST
93346: LIST
93347: LIST
93348: LIST
93349: LIST
93350: LIST
93351: LIST
93352: LIST
93353: LIST
93354: LIST
93355: LIST
93356: LIST
93357: PUSH
93358: EMPTY
93359: LIST
93360: LIST
93361: ST_TO_ADDR
93362: GO 95461
93364: LD_INT 10
93366: DOUBLE
93367: EQUAL
93368: IFTRUE 93372
93370: GO 93568
93372: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
93373: LD_ADDR_VAR 0 2
93377: PUSH
93378: LD_INT 2
93380: PUSH
93381: LD_INT 4
93383: PUSH
93384: LD_INT 5
93386: PUSH
93387: LD_INT 6
93389: PUSH
93390: LD_INT 7
93392: PUSH
93393: LD_INT 8
93395: PUSH
93396: LD_INT 9
93398: PUSH
93399: LD_INT 10
93401: PUSH
93402: LD_INT 11
93404: PUSH
93405: LD_INT 12
93407: PUSH
93408: LD_INT 13
93410: PUSH
93411: LD_INT 14
93413: PUSH
93414: LD_INT 15
93416: PUSH
93417: LD_INT 16
93419: PUSH
93420: LD_INT 17
93422: PUSH
93423: LD_INT 18
93425: PUSH
93426: LD_INT 19
93428: PUSH
93429: LD_INT 20
93431: PUSH
93432: LD_INT 21
93434: PUSH
93435: LD_INT 22
93437: PUSH
93438: LD_INT 23
93440: PUSH
93441: LD_INT 24
93443: PUSH
93444: LD_INT 25
93446: PUSH
93447: LD_INT 26
93449: PUSH
93450: LD_INT 28
93452: PUSH
93453: LD_INT 30
93455: PUSH
93456: LD_INT 31
93458: PUSH
93459: LD_INT 32
93461: PUSH
93462: LD_INT 36
93464: PUSH
93465: EMPTY
93466: LIST
93467: LIST
93468: LIST
93469: LIST
93470: LIST
93471: LIST
93472: LIST
93473: LIST
93474: LIST
93475: LIST
93476: LIST
93477: LIST
93478: LIST
93479: LIST
93480: LIST
93481: LIST
93482: LIST
93483: LIST
93484: LIST
93485: LIST
93486: LIST
93487: LIST
93488: LIST
93489: LIST
93490: LIST
93491: LIST
93492: LIST
93493: LIST
93494: LIST
93495: PUSH
93496: LD_INT 101
93498: PUSH
93499: LD_INT 102
93501: PUSH
93502: LD_INT 103
93504: PUSH
93505: LD_INT 104
93507: PUSH
93508: LD_INT 105
93510: PUSH
93511: LD_INT 106
93513: PUSH
93514: LD_INT 107
93516: PUSH
93517: LD_INT 108
93519: PUSH
93520: LD_INT 109
93522: PUSH
93523: LD_INT 110
93525: PUSH
93526: LD_INT 111
93528: PUSH
93529: LD_INT 112
93531: PUSH
93532: LD_INT 114
93534: PUSH
93535: LD_INT 116
93537: PUSH
93538: LD_INT 117
93540: PUSH
93541: LD_INT 118
93543: PUSH
93544: EMPTY
93545: LIST
93546: LIST
93547: LIST
93548: LIST
93549: LIST
93550: LIST
93551: LIST
93552: LIST
93553: LIST
93554: LIST
93555: LIST
93556: LIST
93557: LIST
93558: LIST
93559: LIST
93560: LIST
93561: PUSH
93562: EMPTY
93563: LIST
93564: LIST
93565: ST_TO_ADDR
93566: GO 95461
93568: LD_INT 11
93570: DOUBLE
93571: EQUAL
93572: IFTRUE 93576
93574: GO 93780
93576: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
93577: LD_ADDR_VAR 0 2
93581: PUSH
93582: LD_INT 2
93584: PUSH
93585: LD_INT 3
93587: PUSH
93588: LD_INT 4
93590: PUSH
93591: LD_INT 5
93593: PUSH
93594: LD_INT 6
93596: PUSH
93597: LD_INT 7
93599: PUSH
93600: LD_INT 8
93602: PUSH
93603: LD_INT 9
93605: PUSH
93606: LD_INT 10
93608: PUSH
93609: LD_INT 11
93611: PUSH
93612: LD_INT 12
93614: PUSH
93615: LD_INT 13
93617: PUSH
93618: LD_INT 14
93620: PUSH
93621: LD_INT 15
93623: PUSH
93624: LD_INT 16
93626: PUSH
93627: LD_INT 17
93629: PUSH
93630: LD_INT 18
93632: PUSH
93633: LD_INT 19
93635: PUSH
93636: LD_INT 20
93638: PUSH
93639: LD_INT 21
93641: PUSH
93642: LD_INT 22
93644: PUSH
93645: LD_INT 23
93647: PUSH
93648: LD_INT 24
93650: PUSH
93651: LD_INT 25
93653: PUSH
93654: LD_INT 26
93656: PUSH
93657: LD_INT 28
93659: PUSH
93660: LD_INT 30
93662: PUSH
93663: LD_INT 31
93665: PUSH
93666: LD_INT 32
93668: PUSH
93669: LD_INT 34
93671: PUSH
93672: LD_INT 36
93674: PUSH
93675: EMPTY
93676: LIST
93677: LIST
93678: LIST
93679: LIST
93680: LIST
93681: LIST
93682: LIST
93683: LIST
93684: LIST
93685: LIST
93686: LIST
93687: LIST
93688: LIST
93689: LIST
93690: LIST
93691: LIST
93692: LIST
93693: LIST
93694: LIST
93695: LIST
93696: LIST
93697: LIST
93698: LIST
93699: LIST
93700: LIST
93701: LIST
93702: LIST
93703: LIST
93704: LIST
93705: LIST
93706: LIST
93707: PUSH
93708: LD_INT 101
93710: PUSH
93711: LD_INT 102
93713: PUSH
93714: LD_INT 103
93716: PUSH
93717: LD_INT 104
93719: PUSH
93720: LD_INT 105
93722: PUSH
93723: LD_INT 106
93725: PUSH
93726: LD_INT 107
93728: PUSH
93729: LD_INT 108
93731: PUSH
93732: LD_INT 109
93734: PUSH
93735: LD_INT 110
93737: PUSH
93738: LD_INT 111
93740: PUSH
93741: LD_INT 112
93743: PUSH
93744: LD_INT 114
93746: PUSH
93747: LD_INT 116
93749: PUSH
93750: LD_INT 117
93752: PUSH
93753: LD_INT 118
93755: PUSH
93756: EMPTY
93757: LIST
93758: LIST
93759: LIST
93760: LIST
93761: LIST
93762: LIST
93763: LIST
93764: LIST
93765: LIST
93766: LIST
93767: LIST
93768: LIST
93769: LIST
93770: LIST
93771: LIST
93772: LIST
93773: PUSH
93774: EMPTY
93775: LIST
93776: LIST
93777: ST_TO_ADDR
93778: GO 95461
93780: LD_INT 12
93782: DOUBLE
93783: EQUAL
93784: IFTRUE 93788
93786: GO 94008
93788: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
93789: LD_ADDR_VAR 0 2
93793: PUSH
93794: LD_INT 1
93796: PUSH
93797: LD_INT 2
93799: PUSH
93800: LD_INT 3
93802: PUSH
93803: LD_INT 4
93805: PUSH
93806: LD_INT 5
93808: PUSH
93809: LD_INT 6
93811: PUSH
93812: LD_INT 7
93814: PUSH
93815: LD_INT 8
93817: PUSH
93818: LD_INT 9
93820: PUSH
93821: LD_INT 10
93823: PUSH
93824: LD_INT 11
93826: PUSH
93827: LD_INT 12
93829: PUSH
93830: LD_INT 13
93832: PUSH
93833: LD_INT 14
93835: PUSH
93836: LD_INT 15
93838: PUSH
93839: LD_INT 16
93841: PUSH
93842: LD_INT 17
93844: PUSH
93845: LD_INT 18
93847: PUSH
93848: LD_INT 19
93850: PUSH
93851: LD_INT 20
93853: PUSH
93854: LD_INT 21
93856: PUSH
93857: LD_INT 22
93859: PUSH
93860: LD_INT 23
93862: PUSH
93863: LD_INT 24
93865: PUSH
93866: LD_INT 25
93868: PUSH
93869: LD_INT 26
93871: PUSH
93872: LD_INT 27
93874: PUSH
93875: LD_INT 28
93877: PUSH
93878: LD_INT 30
93880: PUSH
93881: LD_INT 31
93883: PUSH
93884: LD_INT 32
93886: PUSH
93887: LD_INT 33
93889: PUSH
93890: LD_INT 34
93892: PUSH
93893: LD_INT 36
93895: PUSH
93896: EMPTY
93897: LIST
93898: LIST
93899: LIST
93900: LIST
93901: LIST
93902: LIST
93903: LIST
93904: LIST
93905: LIST
93906: LIST
93907: LIST
93908: LIST
93909: LIST
93910: LIST
93911: LIST
93912: LIST
93913: LIST
93914: LIST
93915: LIST
93916: LIST
93917: LIST
93918: LIST
93919: LIST
93920: LIST
93921: LIST
93922: LIST
93923: LIST
93924: LIST
93925: LIST
93926: LIST
93927: LIST
93928: LIST
93929: LIST
93930: LIST
93931: PUSH
93932: LD_INT 101
93934: PUSH
93935: LD_INT 102
93937: PUSH
93938: LD_INT 103
93940: PUSH
93941: LD_INT 104
93943: PUSH
93944: LD_INT 105
93946: PUSH
93947: LD_INT 106
93949: PUSH
93950: LD_INT 107
93952: PUSH
93953: LD_INT 108
93955: PUSH
93956: LD_INT 109
93958: PUSH
93959: LD_INT 110
93961: PUSH
93962: LD_INT 111
93964: PUSH
93965: LD_INT 112
93967: PUSH
93968: LD_INT 113
93970: PUSH
93971: LD_INT 114
93973: PUSH
93974: LD_INT 116
93976: PUSH
93977: LD_INT 117
93979: PUSH
93980: LD_INT 118
93982: PUSH
93983: EMPTY
93984: LIST
93985: LIST
93986: LIST
93987: LIST
93988: LIST
93989: LIST
93990: LIST
93991: LIST
93992: LIST
93993: LIST
93994: LIST
93995: LIST
93996: LIST
93997: LIST
93998: LIST
93999: LIST
94000: LIST
94001: PUSH
94002: EMPTY
94003: LIST
94004: LIST
94005: ST_TO_ADDR
94006: GO 95461
94008: LD_INT 13
94010: DOUBLE
94011: EQUAL
94012: IFTRUE 94016
94014: GO 94224
94016: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
94017: LD_ADDR_VAR 0 2
94021: PUSH
94022: LD_INT 1
94024: PUSH
94025: LD_INT 2
94027: PUSH
94028: LD_INT 3
94030: PUSH
94031: LD_INT 4
94033: PUSH
94034: LD_INT 5
94036: PUSH
94037: LD_INT 8
94039: PUSH
94040: LD_INT 9
94042: PUSH
94043: LD_INT 10
94045: PUSH
94046: LD_INT 11
94048: PUSH
94049: LD_INT 12
94051: PUSH
94052: LD_INT 14
94054: PUSH
94055: LD_INT 15
94057: PUSH
94058: LD_INT 16
94060: PUSH
94061: LD_INT 17
94063: PUSH
94064: LD_INT 18
94066: PUSH
94067: LD_INT 19
94069: PUSH
94070: LD_INT 20
94072: PUSH
94073: LD_INT 21
94075: PUSH
94076: LD_INT 22
94078: PUSH
94079: LD_INT 23
94081: PUSH
94082: LD_INT 24
94084: PUSH
94085: LD_INT 25
94087: PUSH
94088: LD_INT 26
94090: PUSH
94091: LD_INT 27
94093: PUSH
94094: LD_INT 28
94096: PUSH
94097: LD_INT 30
94099: PUSH
94100: LD_INT 31
94102: PUSH
94103: LD_INT 32
94105: PUSH
94106: LD_INT 33
94108: PUSH
94109: LD_INT 34
94111: PUSH
94112: LD_INT 36
94114: PUSH
94115: EMPTY
94116: LIST
94117: LIST
94118: LIST
94119: LIST
94120: LIST
94121: LIST
94122: LIST
94123: LIST
94124: LIST
94125: LIST
94126: LIST
94127: LIST
94128: LIST
94129: LIST
94130: LIST
94131: LIST
94132: LIST
94133: LIST
94134: LIST
94135: LIST
94136: LIST
94137: LIST
94138: LIST
94139: LIST
94140: LIST
94141: LIST
94142: LIST
94143: LIST
94144: LIST
94145: LIST
94146: LIST
94147: PUSH
94148: LD_INT 101
94150: PUSH
94151: LD_INT 102
94153: PUSH
94154: LD_INT 103
94156: PUSH
94157: LD_INT 104
94159: PUSH
94160: LD_INT 105
94162: PUSH
94163: LD_INT 106
94165: PUSH
94166: LD_INT 107
94168: PUSH
94169: LD_INT 108
94171: PUSH
94172: LD_INT 109
94174: PUSH
94175: LD_INT 110
94177: PUSH
94178: LD_INT 111
94180: PUSH
94181: LD_INT 112
94183: PUSH
94184: LD_INT 113
94186: PUSH
94187: LD_INT 114
94189: PUSH
94190: LD_INT 116
94192: PUSH
94193: LD_INT 117
94195: PUSH
94196: LD_INT 118
94198: PUSH
94199: EMPTY
94200: LIST
94201: LIST
94202: LIST
94203: LIST
94204: LIST
94205: LIST
94206: LIST
94207: LIST
94208: LIST
94209: LIST
94210: LIST
94211: LIST
94212: LIST
94213: LIST
94214: LIST
94215: LIST
94216: LIST
94217: PUSH
94218: EMPTY
94219: LIST
94220: LIST
94221: ST_TO_ADDR
94222: GO 95461
94224: LD_INT 14
94226: DOUBLE
94227: EQUAL
94228: IFTRUE 94232
94230: GO 94456
94232: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
94233: LD_ADDR_VAR 0 2
94237: PUSH
94238: LD_INT 1
94240: PUSH
94241: LD_INT 2
94243: PUSH
94244: LD_INT 3
94246: PUSH
94247: LD_INT 4
94249: PUSH
94250: LD_INT 5
94252: PUSH
94253: LD_INT 6
94255: PUSH
94256: LD_INT 7
94258: PUSH
94259: LD_INT 8
94261: PUSH
94262: LD_INT 9
94264: PUSH
94265: LD_INT 10
94267: PUSH
94268: LD_INT 11
94270: PUSH
94271: LD_INT 12
94273: PUSH
94274: LD_INT 13
94276: PUSH
94277: LD_INT 14
94279: PUSH
94280: LD_INT 15
94282: PUSH
94283: LD_INT 16
94285: PUSH
94286: LD_INT 17
94288: PUSH
94289: LD_INT 18
94291: PUSH
94292: LD_INT 19
94294: PUSH
94295: LD_INT 20
94297: PUSH
94298: LD_INT 21
94300: PUSH
94301: LD_INT 22
94303: PUSH
94304: LD_INT 23
94306: PUSH
94307: LD_INT 24
94309: PUSH
94310: LD_INT 25
94312: PUSH
94313: LD_INT 26
94315: PUSH
94316: LD_INT 27
94318: PUSH
94319: LD_INT 28
94321: PUSH
94322: LD_INT 29
94324: PUSH
94325: LD_INT 30
94327: PUSH
94328: LD_INT 31
94330: PUSH
94331: LD_INT 32
94333: PUSH
94334: LD_INT 33
94336: PUSH
94337: LD_INT 34
94339: PUSH
94340: LD_INT 36
94342: PUSH
94343: EMPTY
94344: LIST
94345: LIST
94346: LIST
94347: LIST
94348: LIST
94349: LIST
94350: LIST
94351: LIST
94352: LIST
94353: LIST
94354: LIST
94355: LIST
94356: LIST
94357: LIST
94358: LIST
94359: LIST
94360: LIST
94361: LIST
94362: LIST
94363: LIST
94364: LIST
94365: LIST
94366: LIST
94367: LIST
94368: LIST
94369: LIST
94370: LIST
94371: LIST
94372: LIST
94373: LIST
94374: LIST
94375: LIST
94376: LIST
94377: LIST
94378: LIST
94379: PUSH
94380: LD_INT 101
94382: PUSH
94383: LD_INT 102
94385: PUSH
94386: LD_INT 103
94388: PUSH
94389: LD_INT 104
94391: PUSH
94392: LD_INT 105
94394: PUSH
94395: LD_INT 106
94397: PUSH
94398: LD_INT 107
94400: PUSH
94401: LD_INT 108
94403: PUSH
94404: LD_INT 109
94406: PUSH
94407: LD_INT 110
94409: PUSH
94410: LD_INT 111
94412: PUSH
94413: LD_INT 112
94415: PUSH
94416: LD_INT 113
94418: PUSH
94419: LD_INT 114
94421: PUSH
94422: LD_INT 116
94424: PUSH
94425: LD_INT 117
94427: PUSH
94428: LD_INT 118
94430: PUSH
94431: EMPTY
94432: LIST
94433: LIST
94434: LIST
94435: LIST
94436: LIST
94437: LIST
94438: LIST
94439: LIST
94440: LIST
94441: LIST
94442: LIST
94443: LIST
94444: LIST
94445: LIST
94446: LIST
94447: LIST
94448: LIST
94449: PUSH
94450: EMPTY
94451: LIST
94452: LIST
94453: ST_TO_ADDR
94454: GO 95461
94456: LD_INT 15
94458: DOUBLE
94459: EQUAL
94460: IFTRUE 94464
94462: GO 94688
94464: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
94465: LD_ADDR_VAR 0 2
94469: PUSH
94470: LD_INT 1
94472: PUSH
94473: LD_INT 2
94475: PUSH
94476: LD_INT 3
94478: PUSH
94479: LD_INT 4
94481: PUSH
94482: LD_INT 5
94484: PUSH
94485: LD_INT 6
94487: PUSH
94488: LD_INT 7
94490: PUSH
94491: LD_INT 8
94493: PUSH
94494: LD_INT 9
94496: PUSH
94497: LD_INT 10
94499: PUSH
94500: LD_INT 11
94502: PUSH
94503: LD_INT 12
94505: PUSH
94506: LD_INT 13
94508: PUSH
94509: LD_INT 14
94511: PUSH
94512: LD_INT 15
94514: PUSH
94515: LD_INT 16
94517: PUSH
94518: LD_INT 17
94520: PUSH
94521: LD_INT 18
94523: PUSH
94524: LD_INT 19
94526: PUSH
94527: LD_INT 20
94529: PUSH
94530: LD_INT 21
94532: PUSH
94533: LD_INT 22
94535: PUSH
94536: LD_INT 23
94538: PUSH
94539: LD_INT 24
94541: PUSH
94542: LD_INT 25
94544: PUSH
94545: LD_INT 26
94547: PUSH
94548: LD_INT 27
94550: PUSH
94551: LD_INT 28
94553: PUSH
94554: LD_INT 29
94556: PUSH
94557: LD_INT 30
94559: PUSH
94560: LD_INT 31
94562: PUSH
94563: LD_INT 32
94565: PUSH
94566: LD_INT 33
94568: PUSH
94569: LD_INT 34
94571: PUSH
94572: LD_INT 36
94574: PUSH
94575: EMPTY
94576: LIST
94577: LIST
94578: LIST
94579: LIST
94580: LIST
94581: LIST
94582: LIST
94583: LIST
94584: LIST
94585: LIST
94586: LIST
94587: LIST
94588: LIST
94589: LIST
94590: LIST
94591: LIST
94592: LIST
94593: LIST
94594: LIST
94595: LIST
94596: LIST
94597: LIST
94598: LIST
94599: LIST
94600: LIST
94601: LIST
94602: LIST
94603: LIST
94604: LIST
94605: LIST
94606: LIST
94607: LIST
94608: LIST
94609: LIST
94610: LIST
94611: PUSH
94612: LD_INT 101
94614: PUSH
94615: LD_INT 102
94617: PUSH
94618: LD_INT 103
94620: PUSH
94621: LD_INT 104
94623: PUSH
94624: LD_INT 105
94626: PUSH
94627: LD_INT 106
94629: PUSH
94630: LD_INT 107
94632: PUSH
94633: LD_INT 108
94635: PUSH
94636: LD_INT 109
94638: PUSH
94639: LD_INT 110
94641: PUSH
94642: LD_INT 111
94644: PUSH
94645: LD_INT 112
94647: PUSH
94648: LD_INT 113
94650: PUSH
94651: LD_INT 114
94653: PUSH
94654: LD_INT 116
94656: PUSH
94657: LD_INT 117
94659: PUSH
94660: LD_INT 118
94662: PUSH
94663: EMPTY
94664: LIST
94665: LIST
94666: LIST
94667: LIST
94668: LIST
94669: LIST
94670: LIST
94671: LIST
94672: LIST
94673: LIST
94674: LIST
94675: LIST
94676: LIST
94677: LIST
94678: LIST
94679: LIST
94680: LIST
94681: PUSH
94682: EMPTY
94683: LIST
94684: LIST
94685: ST_TO_ADDR
94686: GO 95461
94688: LD_INT 16
94690: DOUBLE
94691: EQUAL
94692: IFTRUE 94696
94694: GO 94832
94696: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
94697: LD_ADDR_VAR 0 2
94701: PUSH
94702: LD_INT 2
94704: PUSH
94705: LD_INT 4
94707: PUSH
94708: LD_INT 5
94710: PUSH
94711: LD_INT 7
94713: PUSH
94714: LD_INT 11
94716: PUSH
94717: LD_INT 12
94719: PUSH
94720: LD_INT 15
94722: PUSH
94723: LD_INT 16
94725: PUSH
94726: LD_INT 20
94728: PUSH
94729: LD_INT 21
94731: PUSH
94732: LD_INT 22
94734: PUSH
94735: LD_INT 23
94737: PUSH
94738: LD_INT 25
94740: PUSH
94741: LD_INT 26
94743: PUSH
94744: LD_INT 30
94746: PUSH
94747: LD_INT 31
94749: PUSH
94750: LD_INT 32
94752: PUSH
94753: LD_INT 33
94755: PUSH
94756: LD_INT 34
94758: PUSH
94759: EMPTY
94760: LIST
94761: LIST
94762: LIST
94763: LIST
94764: LIST
94765: LIST
94766: LIST
94767: LIST
94768: LIST
94769: LIST
94770: LIST
94771: LIST
94772: LIST
94773: LIST
94774: LIST
94775: LIST
94776: LIST
94777: LIST
94778: LIST
94779: PUSH
94780: LD_INT 101
94782: PUSH
94783: LD_INT 102
94785: PUSH
94786: LD_INT 103
94788: PUSH
94789: LD_INT 106
94791: PUSH
94792: LD_INT 108
94794: PUSH
94795: LD_INT 112
94797: PUSH
94798: LD_INT 113
94800: PUSH
94801: LD_INT 114
94803: PUSH
94804: LD_INT 116
94806: PUSH
94807: LD_INT 117
94809: PUSH
94810: LD_INT 118
94812: PUSH
94813: EMPTY
94814: LIST
94815: LIST
94816: LIST
94817: LIST
94818: LIST
94819: LIST
94820: LIST
94821: LIST
94822: LIST
94823: LIST
94824: LIST
94825: PUSH
94826: EMPTY
94827: LIST
94828: LIST
94829: ST_TO_ADDR
94830: GO 95461
94832: LD_INT 17
94834: DOUBLE
94835: EQUAL
94836: IFTRUE 94840
94838: GO 95064
94840: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
94841: LD_ADDR_VAR 0 2
94845: PUSH
94846: LD_INT 1
94848: PUSH
94849: LD_INT 2
94851: PUSH
94852: LD_INT 3
94854: PUSH
94855: LD_INT 4
94857: PUSH
94858: LD_INT 5
94860: PUSH
94861: LD_INT 6
94863: PUSH
94864: LD_INT 7
94866: PUSH
94867: LD_INT 8
94869: PUSH
94870: LD_INT 9
94872: PUSH
94873: LD_INT 10
94875: PUSH
94876: LD_INT 11
94878: PUSH
94879: LD_INT 12
94881: PUSH
94882: LD_INT 13
94884: PUSH
94885: LD_INT 14
94887: PUSH
94888: LD_INT 15
94890: PUSH
94891: LD_INT 16
94893: PUSH
94894: LD_INT 17
94896: PUSH
94897: LD_INT 18
94899: PUSH
94900: LD_INT 19
94902: PUSH
94903: LD_INT 20
94905: PUSH
94906: LD_INT 21
94908: PUSH
94909: LD_INT 22
94911: PUSH
94912: LD_INT 23
94914: PUSH
94915: LD_INT 24
94917: PUSH
94918: LD_INT 25
94920: PUSH
94921: LD_INT 26
94923: PUSH
94924: LD_INT 27
94926: PUSH
94927: LD_INT 28
94929: PUSH
94930: LD_INT 29
94932: PUSH
94933: LD_INT 30
94935: PUSH
94936: LD_INT 31
94938: PUSH
94939: LD_INT 32
94941: PUSH
94942: LD_INT 33
94944: PUSH
94945: LD_INT 34
94947: PUSH
94948: LD_INT 36
94950: PUSH
94951: EMPTY
94952: LIST
94953: LIST
94954: LIST
94955: LIST
94956: LIST
94957: LIST
94958: LIST
94959: LIST
94960: LIST
94961: LIST
94962: LIST
94963: LIST
94964: LIST
94965: LIST
94966: LIST
94967: LIST
94968: LIST
94969: LIST
94970: LIST
94971: LIST
94972: LIST
94973: LIST
94974: LIST
94975: LIST
94976: LIST
94977: LIST
94978: LIST
94979: LIST
94980: LIST
94981: LIST
94982: LIST
94983: LIST
94984: LIST
94985: LIST
94986: LIST
94987: PUSH
94988: LD_INT 101
94990: PUSH
94991: LD_INT 102
94993: PUSH
94994: LD_INT 103
94996: PUSH
94997: LD_INT 104
94999: PUSH
95000: LD_INT 105
95002: PUSH
95003: LD_INT 106
95005: PUSH
95006: LD_INT 107
95008: PUSH
95009: LD_INT 108
95011: PUSH
95012: LD_INT 109
95014: PUSH
95015: LD_INT 110
95017: PUSH
95018: LD_INT 111
95020: PUSH
95021: LD_INT 112
95023: PUSH
95024: LD_INT 113
95026: PUSH
95027: LD_INT 114
95029: PUSH
95030: LD_INT 116
95032: PUSH
95033: LD_INT 117
95035: PUSH
95036: LD_INT 118
95038: PUSH
95039: EMPTY
95040: LIST
95041: LIST
95042: LIST
95043: LIST
95044: LIST
95045: LIST
95046: LIST
95047: LIST
95048: LIST
95049: LIST
95050: LIST
95051: LIST
95052: LIST
95053: LIST
95054: LIST
95055: LIST
95056: LIST
95057: PUSH
95058: EMPTY
95059: LIST
95060: LIST
95061: ST_TO_ADDR
95062: GO 95461
95064: LD_INT 18
95066: DOUBLE
95067: EQUAL
95068: IFTRUE 95072
95070: GO 95220
95072: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
95073: LD_ADDR_VAR 0 2
95077: PUSH
95078: LD_INT 2
95080: PUSH
95081: LD_INT 4
95083: PUSH
95084: LD_INT 5
95086: PUSH
95087: LD_INT 7
95089: PUSH
95090: LD_INT 11
95092: PUSH
95093: LD_INT 12
95095: PUSH
95096: LD_INT 15
95098: PUSH
95099: LD_INT 16
95101: PUSH
95102: LD_INT 20
95104: PUSH
95105: LD_INT 21
95107: PUSH
95108: LD_INT 22
95110: PUSH
95111: LD_INT 23
95113: PUSH
95114: LD_INT 25
95116: PUSH
95117: LD_INT 26
95119: PUSH
95120: LD_INT 30
95122: PUSH
95123: LD_INT 31
95125: PUSH
95126: LD_INT 32
95128: PUSH
95129: LD_INT 33
95131: PUSH
95132: LD_INT 34
95134: PUSH
95135: LD_INT 35
95137: PUSH
95138: LD_INT 36
95140: PUSH
95141: EMPTY
95142: LIST
95143: LIST
95144: LIST
95145: LIST
95146: LIST
95147: LIST
95148: LIST
95149: LIST
95150: LIST
95151: LIST
95152: LIST
95153: LIST
95154: LIST
95155: LIST
95156: LIST
95157: LIST
95158: LIST
95159: LIST
95160: LIST
95161: LIST
95162: LIST
95163: PUSH
95164: LD_INT 101
95166: PUSH
95167: LD_INT 102
95169: PUSH
95170: LD_INT 103
95172: PUSH
95173: LD_INT 106
95175: PUSH
95176: LD_INT 108
95178: PUSH
95179: LD_INT 112
95181: PUSH
95182: LD_INT 113
95184: PUSH
95185: LD_INT 114
95187: PUSH
95188: LD_INT 115
95190: PUSH
95191: LD_INT 116
95193: PUSH
95194: LD_INT 117
95196: PUSH
95197: LD_INT 118
95199: PUSH
95200: EMPTY
95201: LIST
95202: LIST
95203: LIST
95204: LIST
95205: LIST
95206: LIST
95207: LIST
95208: LIST
95209: LIST
95210: LIST
95211: LIST
95212: LIST
95213: PUSH
95214: EMPTY
95215: LIST
95216: LIST
95217: ST_TO_ADDR
95218: GO 95461
95220: LD_INT 19
95222: DOUBLE
95223: EQUAL
95224: IFTRUE 95228
95226: GO 95460
95228: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
95229: LD_ADDR_VAR 0 2
95233: PUSH
95234: LD_INT 1
95236: PUSH
95237: LD_INT 2
95239: PUSH
95240: LD_INT 3
95242: PUSH
95243: LD_INT 4
95245: PUSH
95246: LD_INT 5
95248: PUSH
95249: LD_INT 6
95251: PUSH
95252: LD_INT 7
95254: PUSH
95255: LD_INT 8
95257: PUSH
95258: LD_INT 9
95260: PUSH
95261: LD_INT 10
95263: PUSH
95264: LD_INT 11
95266: PUSH
95267: LD_INT 12
95269: PUSH
95270: LD_INT 13
95272: PUSH
95273: LD_INT 14
95275: PUSH
95276: LD_INT 15
95278: PUSH
95279: LD_INT 16
95281: PUSH
95282: LD_INT 17
95284: PUSH
95285: LD_INT 18
95287: PUSH
95288: LD_INT 19
95290: PUSH
95291: LD_INT 20
95293: PUSH
95294: LD_INT 21
95296: PUSH
95297: LD_INT 22
95299: PUSH
95300: LD_INT 23
95302: PUSH
95303: LD_INT 24
95305: PUSH
95306: LD_INT 25
95308: PUSH
95309: LD_INT 26
95311: PUSH
95312: LD_INT 27
95314: PUSH
95315: LD_INT 28
95317: PUSH
95318: LD_INT 29
95320: PUSH
95321: LD_INT 30
95323: PUSH
95324: LD_INT 31
95326: PUSH
95327: LD_INT 32
95329: PUSH
95330: LD_INT 33
95332: PUSH
95333: LD_INT 34
95335: PUSH
95336: LD_INT 35
95338: PUSH
95339: LD_INT 36
95341: PUSH
95342: EMPTY
95343: LIST
95344: LIST
95345: LIST
95346: LIST
95347: LIST
95348: LIST
95349: LIST
95350: LIST
95351: LIST
95352: LIST
95353: LIST
95354: LIST
95355: LIST
95356: LIST
95357: LIST
95358: LIST
95359: LIST
95360: LIST
95361: LIST
95362: LIST
95363: LIST
95364: LIST
95365: LIST
95366: LIST
95367: LIST
95368: LIST
95369: LIST
95370: LIST
95371: LIST
95372: LIST
95373: LIST
95374: LIST
95375: LIST
95376: LIST
95377: LIST
95378: LIST
95379: PUSH
95380: LD_INT 101
95382: PUSH
95383: LD_INT 102
95385: PUSH
95386: LD_INT 103
95388: PUSH
95389: LD_INT 104
95391: PUSH
95392: LD_INT 105
95394: PUSH
95395: LD_INT 106
95397: PUSH
95398: LD_INT 107
95400: PUSH
95401: LD_INT 108
95403: PUSH
95404: LD_INT 109
95406: PUSH
95407: LD_INT 110
95409: PUSH
95410: LD_INT 111
95412: PUSH
95413: LD_INT 112
95415: PUSH
95416: LD_INT 113
95418: PUSH
95419: LD_INT 114
95421: PUSH
95422: LD_INT 115
95424: PUSH
95425: LD_INT 116
95427: PUSH
95428: LD_INT 117
95430: PUSH
95431: LD_INT 118
95433: PUSH
95434: EMPTY
95435: LIST
95436: LIST
95437: LIST
95438: LIST
95439: LIST
95440: LIST
95441: LIST
95442: LIST
95443: LIST
95444: LIST
95445: LIST
95446: LIST
95447: LIST
95448: LIST
95449: LIST
95450: LIST
95451: LIST
95452: LIST
95453: PUSH
95454: EMPTY
95455: LIST
95456: LIST
95457: ST_TO_ADDR
95458: GO 95461
95460: POP
// end else
95461: GO 95692
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
95463: LD_ADDR_VAR 0 2
95467: PUSH
95468: LD_INT 1
95470: PUSH
95471: LD_INT 2
95473: PUSH
95474: LD_INT 3
95476: PUSH
95477: LD_INT 4
95479: PUSH
95480: LD_INT 5
95482: PUSH
95483: LD_INT 6
95485: PUSH
95486: LD_INT 7
95488: PUSH
95489: LD_INT 8
95491: PUSH
95492: LD_INT 9
95494: PUSH
95495: LD_INT 10
95497: PUSH
95498: LD_INT 11
95500: PUSH
95501: LD_INT 12
95503: PUSH
95504: LD_INT 13
95506: PUSH
95507: LD_INT 14
95509: PUSH
95510: LD_INT 15
95512: PUSH
95513: LD_INT 16
95515: PUSH
95516: LD_INT 17
95518: PUSH
95519: LD_INT 18
95521: PUSH
95522: LD_INT 19
95524: PUSH
95525: LD_INT 20
95527: PUSH
95528: LD_INT 21
95530: PUSH
95531: LD_INT 22
95533: PUSH
95534: LD_INT 23
95536: PUSH
95537: LD_INT 24
95539: PUSH
95540: LD_INT 25
95542: PUSH
95543: LD_INT 26
95545: PUSH
95546: LD_INT 27
95548: PUSH
95549: LD_INT 28
95551: PUSH
95552: LD_INT 29
95554: PUSH
95555: LD_INT 30
95557: PUSH
95558: LD_INT 31
95560: PUSH
95561: LD_INT 32
95563: PUSH
95564: LD_INT 33
95566: PUSH
95567: LD_INT 34
95569: PUSH
95570: LD_INT 35
95572: PUSH
95573: LD_INT 36
95575: PUSH
95576: EMPTY
95577: LIST
95578: LIST
95579: LIST
95580: LIST
95581: LIST
95582: LIST
95583: LIST
95584: LIST
95585: LIST
95586: LIST
95587: LIST
95588: LIST
95589: LIST
95590: LIST
95591: LIST
95592: LIST
95593: LIST
95594: LIST
95595: LIST
95596: LIST
95597: LIST
95598: LIST
95599: LIST
95600: LIST
95601: LIST
95602: LIST
95603: LIST
95604: LIST
95605: LIST
95606: LIST
95607: LIST
95608: LIST
95609: LIST
95610: LIST
95611: LIST
95612: LIST
95613: PUSH
95614: LD_INT 101
95616: PUSH
95617: LD_INT 102
95619: PUSH
95620: LD_INT 103
95622: PUSH
95623: LD_INT 104
95625: PUSH
95626: LD_INT 105
95628: PUSH
95629: LD_INT 106
95631: PUSH
95632: LD_INT 107
95634: PUSH
95635: LD_INT 108
95637: PUSH
95638: LD_INT 109
95640: PUSH
95641: LD_INT 110
95643: PUSH
95644: LD_INT 111
95646: PUSH
95647: LD_INT 112
95649: PUSH
95650: LD_INT 113
95652: PUSH
95653: LD_INT 114
95655: PUSH
95656: LD_INT 115
95658: PUSH
95659: LD_INT 116
95661: PUSH
95662: LD_INT 117
95664: PUSH
95665: LD_INT 118
95667: PUSH
95668: EMPTY
95669: LIST
95670: LIST
95671: LIST
95672: LIST
95673: LIST
95674: LIST
95675: LIST
95676: LIST
95677: LIST
95678: LIST
95679: LIST
95680: LIST
95681: LIST
95682: LIST
95683: LIST
95684: LIST
95685: LIST
95686: LIST
95687: PUSH
95688: EMPTY
95689: LIST
95690: LIST
95691: ST_TO_ADDR
// if result then
95692: LD_VAR 0 2
95696: IFFALSE 96482
// begin normal :=  ;
95698: LD_ADDR_VAR 0 5
95702: PUSH
95703: LD_STRING 
95705: ST_TO_ADDR
// hardcore :=  ;
95706: LD_ADDR_VAR 0 6
95710: PUSH
95711: LD_STRING 
95713: ST_TO_ADDR
// active :=  ;
95714: LD_ADDR_VAR 0 7
95718: PUSH
95719: LD_STRING 
95721: ST_TO_ADDR
// for i = 1 to normalCounter do
95722: LD_ADDR_VAR 0 8
95726: PUSH
95727: DOUBLE
95728: LD_INT 1
95730: DEC
95731: ST_TO_ADDR
95732: LD_EXP 97
95736: PUSH
95737: FOR_TO
95738: IFFALSE 95839
// begin tmp := 0 ;
95740: LD_ADDR_VAR 0 3
95744: PUSH
95745: LD_STRING 0
95747: ST_TO_ADDR
// if result [ 1 ] then
95748: LD_VAR 0 2
95752: PUSH
95753: LD_INT 1
95755: ARRAY
95756: IFFALSE 95821
// if result [ 1 ] [ 1 ] = i then
95758: LD_VAR 0 2
95762: PUSH
95763: LD_INT 1
95765: ARRAY
95766: PUSH
95767: LD_INT 1
95769: ARRAY
95770: PUSH
95771: LD_VAR 0 8
95775: EQUAL
95776: IFFALSE 95821
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
95778: LD_ADDR_VAR 0 2
95782: PUSH
95783: LD_VAR 0 2
95787: PPUSH
95788: LD_INT 1
95790: PPUSH
95791: LD_VAR 0 2
95795: PUSH
95796: LD_INT 1
95798: ARRAY
95799: PPUSH
95800: LD_INT 1
95802: PPUSH
95803: CALL_OW 3
95807: PPUSH
95808: CALL_OW 1
95812: ST_TO_ADDR
// tmp := 1 ;
95813: LD_ADDR_VAR 0 3
95817: PUSH
95818: LD_STRING 1
95820: ST_TO_ADDR
// end ; normal := normal & tmp ;
95821: LD_ADDR_VAR 0 5
95825: PUSH
95826: LD_VAR 0 5
95830: PUSH
95831: LD_VAR 0 3
95835: STR
95836: ST_TO_ADDR
// end ;
95837: GO 95737
95839: POP
95840: POP
// for i = 1 to hardcoreCounter do
95841: LD_ADDR_VAR 0 8
95845: PUSH
95846: DOUBLE
95847: LD_INT 1
95849: DEC
95850: ST_TO_ADDR
95851: LD_EXP 98
95855: PUSH
95856: FOR_TO
95857: IFFALSE 95962
// begin tmp := 0 ;
95859: LD_ADDR_VAR 0 3
95863: PUSH
95864: LD_STRING 0
95866: ST_TO_ADDR
// if result [ 2 ] then
95867: LD_VAR 0 2
95871: PUSH
95872: LD_INT 2
95874: ARRAY
95875: IFFALSE 95944
// if result [ 2 ] [ 1 ] = 100 + i then
95877: LD_VAR 0 2
95881: PUSH
95882: LD_INT 2
95884: ARRAY
95885: PUSH
95886: LD_INT 1
95888: ARRAY
95889: PUSH
95890: LD_INT 100
95892: PUSH
95893: LD_VAR 0 8
95897: PLUS
95898: EQUAL
95899: IFFALSE 95944
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
95901: LD_ADDR_VAR 0 2
95905: PUSH
95906: LD_VAR 0 2
95910: PPUSH
95911: LD_INT 2
95913: PPUSH
95914: LD_VAR 0 2
95918: PUSH
95919: LD_INT 2
95921: ARRAY
95922: PPUSH
95923: LD_INT 1
95925: PPUSH
95926: CALL_OW 3
95930: PPUSH
95931: CALL_OW 1
95935: ST_TO_ADDR
// tmp := 1 ;
95936: LD_ADDR_VAR 0 3
95940: PUSH
95941: LD_STRING 1
95943: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
95944: LD_ADDR_VAR 0 6
95948: PUSH
95949: LD_VAR 0 6
95953: PUSH
95954: LD_VAR 0 3
95958: STR
95959: ST_TO_ADDR
// end ;
95960: GO 95856
95962: POP
95963: POP
// if isGameLoad then
95964: LD_VAR 0 1
95968: IFFALSE 96443
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
95970: LD_ADDR_VAR 0 4
95974: PUSH
95975: LD_EXP 101
95979: PUSH
95980: LD_EXP 100
95984: PUSH
95985: LD_EXP 102
95989: PUSH
95990: LD_EXP 99
95994: PUSH
95995: LD_EXP 103
95999: PUSH
96000: LD_EXP 104
96004: PUSH
96005: LD_EXP 105
96009: PUSH
96010: LD_EXP 106
96014: PUSH
96015: LD_EXP 107
96019: PUSH
96020: LD_EXP 108
96024: PUSH
96025: LD_EXP 109
96029: PUSH
96030: LD_EXP 110
96034: PUSH
96035: LD_EXP 111
96039: PUSH
96040: LD_EXP 112
96044: PUSH
96045: LD_EXP 120
96049: PUSH
96050: LD_EXP 121
96054: PUSH
96055: LD_EXP 122
96059: PUSH
96060: LD_EXP 123
96064: PUSH
96065: LD_EXP 125
96069: PUSH
96070: LD_EXP 126
96074: PUSH
96075: LD_EXP 127
96079: PUSH
96080: LD_EXP 130
96084: PUSH
96085: LD_EXP 132
96089: PUSH
96090: LD_EXP 133
96094: PUSH
96095: LD_EXP 134
96099: PUSH
96100: LD_EXP 136
96104: PUSH
96105: LD_EXP 137
96109: PUSH
96110: LD_EXP 140
96114: PUSH
96115: LD_EXP 141
96119: PUSH
96120: LD_EXP 142
96124: PUSH
96125: LD_EXP 143
96129: PUSH
96130: LD_EXP 144
96134: PUSH
96135: LD_EXP 145
96139: PUSH
96140: LD_EXP 146
96144: PUSH
96145: LD_EXP 147
96149: PUSH
96150: LD_EXP 148
96154: PUSH
96155: LD_EXP 113
96159: PUSH
96160: LD_EXP 114
96164: PUSH
96165: LD_EXP 117
96169: PUSH
96170: LD_EXP 118
96174: PUSH
96175: LD_EXP 119
96179: PUSH
96180: LD_EXP 115
96184: PUSH
96185: LD_EXP 116
96189: PUSH
96190: LD_EXP 124
96194: PUSH
96195: LD_EXP 128
96199: PUSH
96200: LD_EXP 129
96204: PUSH
96205: LD_EXP 131
96209: PUSH
96210: LD_EXP 135
96214: PUSH
96215: LD_EXP 138
96219: PUSH
96220: LD_EXP 139
96224: PUSH
96225: LD_EXP 149
96229: PUSH
96230: LD_EXP 150
96234: PUSH
96235: LD_EXP 151
96239: PUSH
96240: LD_EXP 152
96244: PUSH
96245: EMPTY
96246: LIST
96247: LIST
96248: LIST
96249: LIST
96250: LIST
96251: LIST
96252: LIST
96253: LIST
96254: LIST
96255: LIST
96256: LIST
96257: LIST
96258: LIST
96259: LIST
96260: LIST
96261: LIST
96262: LIST
96263: LIST
96264: LIST
96265: LIST
96266: LIST
96267: LIST
96268: LIST
96269: LIST
96270: LIST
96271: LIST
96272: LIST
96273: LIST
96274: LIST
96275: LIST
96276: LIST
96277: LIST
96278: LIST
96279: LIST
96280: LIST
96281: LIST
96282: LIST
96283: LIST
96284: LIST
96285: LIST
96286: LIST
96287: LIST
96288: LIST
96289: LIST
96290: LIST
96291: LIST
96292: LIST
96293: LIST
96294: LIST
96295: LIST
96296: LIST
96297: LIST
96298: LIST
96299: LIST
96300: ST_TO_ADDR
// tmp :=  ;
96301: LD_ADDR_VAR 0 3
96305: PUSH
96306: LD_STRING 
96308: ST_TO_ADDR
// for i = 1 to normalCounter do
96309: LD_ADDR_VAR 0 8
96313: PUSH
96314: DOUBLE
96315: LD_INT 1
96317: DEC
96318: ST_TO_ADDR
96319: LD_EXP 97
96323: PUSH
96324: FOR_TO
96325: IFFALSE 96361
// begin if flags [ i ] then
96327: LD_VAR 0 4
96331: PUSH
96332: LD_VAR 0 8
96336: ARRAY
96337: IFFALSE 96359
// tmp := tmp & i & ; ;
96339: LD_ADDR_VAR 0 3
96343: PUSH
96344: LD_VAR 0 3
96348: PUSH
96349: LD_VAR 0 8
96353: STR
96354: PUSH
96355: LD_STRING ;
96357: STR
96358: ST_TO_ADDR
// end ;
96359: GO 96324
96361: POP
96362: POP
// for i = 1 to hardcoreCounter do
96363: LD_ADDR_VAR 0 8
96367: PUSH
96368: DOUBLE
96369: LD_INT 1
96371: DEC
96372: ST_TO_ADDR
96373: LD_EXP 98
96377: PUSH
96378: FOR_TO
96379: IFFALSE 96425
// begin if flags [ normalCounter + i ] then
96381: LD_VAR 0 4
96385: PUSH
96386: LD_EXP 97
96390: PUSH
96391: LD_VAR 0 8
96395: PLUS
96396: ARRAY
96397: IFFALSE 96423
// tmp := tmp & ( 100 + i ) & ; ;
96399: LD_ADDR_VAR 0 3
96403: PUSH
96404: LD_VAR 0 3
96408: PUSH
96409: LD_INT 100
96411: PUSH
96412: LD_VAR 0 8
96416: PLUS
96417: STR
96418: PUSH
96419: LD_STRING ;
96421: STR
96422: ST_TO_ADDR
// end ;
96423: GO 96378
96425: POP
96426: POP
// if tmp then
96427: LD_VAR 0 3
96431: IFFALSE 96443
// active := tmp ;
96433: LD_ADDR_VAR 0 7
96437: PUSH
96438: LD_VAR 0 3
96442: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
96443: LD_STRING getStreamItemsFromMission("
96445: PUSH
96446: LD_VAR 0 5
96450: STR
96451: PUSH
96452: LD_STRING ","
96454: STR
96455: PUSH
96456: LD_VAR 0 6
96460: STR
96461: PUSH
96462: LD_STRING ","
96464: STR
96465: PUSH
96466: LD_VAR 0 7
96470: STR
96471: PUSH
96472: LD_STRING ")
96474: STR
96475: PPUSH
96476: CALL_OW 559
// end else
96480: GO 96489
// ToLua ( getStreamItemsFromMission("","","") ) ;
96482: LD_STRING getStreamItemsFromMission("","","")
96484: PPUSH
96485: CALL_OW 559
// end ;
96489: LD_VAR 0 2
96493: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
96494: LD_EXP 96
96498: PUSH
96499: LD_EXP 101
96503: AND
96504: IFFALSE 96628
96506: GO 96508
96508: DISABLE
96509: LD_INT 0
96511: PPUSH
96512: PPUSH
// begin enable ;
96513: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
96514: LD_ADDR_VAR 0 2
96518: PUSH
96519: LD_INT 22
96521: PUSH
96522: LD_OWVAR 2
96526: PUSH
96527: EMPTY
96528: LIST
96529: LIST
96530: PUSH
96531: LD_INT 2
96533: PUSH
96534: LD_INT 34
96536: PUSH
96537: LD_INT 7
96539: PUSH
96540: EMPTY
96541: LIST
96542: LIST
96543: PUSH
96544: LD_INT 34
96546: PUSH
96547: LD_INT 45
96549: PUSH
96550: EMPTY
96551: LIST
96552: LIST
96553: PUSH
96554: LD_INT 34
96556: PUSH
96557: LD_INT 28
96559: PUSH
96560: EMPTY
96561: LIST
96562: LIST
96563: PUSH
96564: LD_INT 34
96566: PUSH
96567: LD_INT 47
96569: PUSH
96570: EMPTY
96571: LIST
96572: LIST
96573: PUSH
96574: EMPTY
96575: LIST
96576: LIST
96577: LIST
96578: LIST
96579: LIST
96580: PUSH
96581: EMPTY
96582: LIST
96583: LIST
96584: PPUSH
96585: CALL_OW 69
96589: ST_TO_ADDR
// if not tmp then
96590: LD_VAR 0 2
96594: NOT
96595: IFFALSE 96599
// exit ;
96597: GO 96628
// for i in tmp do
96599: LD_ADDR_VAR 0 1
96603: PUSH
96604: LD_VAR 0 2
96608: PUSH
96609: FOR_IN
96610: IFFALSE 96626
// begin SetLives ( i , 0 ) ;
96612: LD_VAR 0 1
96616: PPUSH
96617: LD_INT 0
96619: PPUSH
96620: CALL_OW 234
// end ;
96624: GO 96609
96626: POP
96627: POP
// end ;
96628: PPOPN 2
96630: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
96631: LD_EXP 96
96635: PUSH
96636: LD_EXP 102
96640: AND
96641: IFFALSE 96725
96643: GO 96645
96645: DISABLE
96646: LD_INT 0
96648: PPUSH
96649: PPUSH
// begin enable ;
96650: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
96651: LD_ADDR_VAR 0 2
96655: PUSH
96656: LD_INT 22
96658: PUSH
96659: LD_OWVAR 2
96663: PUSH
96664: EMPTY
96665: LIST
96666: LIST
96667: PUSH
96668: LD_INT 32
96670: PUSH
96671: LD_INT 3
96673: PUSH
96674: EMPTY
96675: LIST
96676: LIST
96677: PUSH
96678: EMPTY
96679: LIST
96680: LIST
96681: PPUSH
96682: CALL_OW 69
96686: ST_TO_ADDR
// if not tmp then
96687: LD_VAR 0 2
96691: NOT
96692: IFFALSE 96696
// exit ;
96694: GO 96725
// for i in tmp do
96696: LD_ADDR_VAR 0 1
96700: PUSH
96701: LD_VAR 0 2
96705: PUSH
96706: FOR_IN
96707: IFFALSE 96723
// begin SetLives ( i , 0 ) ;
96709: LD_VAR 0 1
96713: PPUSH
96714: LD_INT 0
96716: PPUSH
96717: CALL_OW 234
// end ;
96721: GO 96706
96723: POP
96724: POP
// end ;
96725: PPOPN 2
96727: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
96728: LD_EXP 96
96732: PUSH
96733: LD_EXP 99
96737: AND
96738: IFFALSE 96831
96740: GO 96742
96742: DISABLE
96743: LD_INT 0
96745: PPUSH
// begin enable ;
96746: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
96747: LD_ADDR_VAR 0 1
96751: PUSH
96752: LD_INT 22
96754: PUSH
96755: LD_OWVAR 2
96759: PUSH
96760: EMPTY
96761: LIST
96762: LIST
96763: PUSH
96764: LD_INT 2
96766: PUSH
96767: LD_INT 25
96769: PUSH
96770: LD_INT 5
96772: PUSH
96773: EMPTY
96774: LIST
96775: LIST
96776: PUSH
96777: LD_INT 25
96779: PUSH
96780: LD_INT 9
96782: PUSH
96783: EMPTY
96784: LIST
96785: LIST
96786: PUSH
96787: LD_INT 25
96789: PUSH
96790: LD_INT 8
96792: PUSH
96793: EMPTY
96794: LIST
96795: LIST
96796: PUSH
96797: EMPTY
96798: LIST
96799: LIST
96800: LIST
96801: LIST
96802: PUSH
96803: EMPTY
96804: LIST
96805: LIST
96806: PPUSH
96807: CALL_OW 69
96811: PUSH
96812: FOR_IN
96813: IFFALSE 96829
// begin SetClass ( i , 1 ) ;
96815: LD_VAR 0 1
96819: PPUSH
96820: LD_INT 1
96822: PPUSH
96823: CALL_OW 336
// end ;
96827: GO 96812
96829: POP
96830: POP
// end ;
96831: PPOPN 1
96833: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
96834: LD_EXP 96
96838: PUSH
96839: LD_EXP 100
96843: AND
96844: PUSH
96845: LD_OWVAR 65
96849: PUSH
96850: LD_INT 7
96852: LESS
96853: AND
96854: IFFALSE 96868
96856: GO 96858
96858: DISABLE
// begin enable ;
96859: ENABLE
// game_speed := 7 ;
96860: LD_ADDR_OWVAR 65
96864: PUSH
96865: LD_INT 7
96867: ST_TO_ADDR
// end ;
96868: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
96869: LD_EXP 96
96873: PUSH
96874: LD_EXP 103
96878: AND
96879: IFFALSE 97081
96881: GO 96883
96883: DISABLE
96884: LD_INT 0
96886: PPUSH
96887: PPUSH
96888: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
96889: LD_ADDR_VAR 0 3
96893: PUSH
96894: LD_INT 81
96896: PUSH
96897: LD_OWVAR 2
96901: PUSH
96902: EMPTY
96903: LIST
96904: LIST
96905: PUSH
96906: LD_INT 21
96908: PUSH
96909: LD_INT 1
96911: PUSH
96912: EMPTY
96913: LIST
96914: LIST
96915: PUSH
96916: EMPTY
96917: LIST
96918: LIST
96919: PPUSH
96920: CALL_OW 69
96924: ST_TO_ADDR
// if not tmp then
96925: LD_VAR 0 3
96929: NOT
96930: IFFALSE 96934
// exit ;
96932: GO 97081
// if tmp > 5 then
96934: LD_VAR 0 3
96938: PUSH
96939: LD_INT 5
96941: GREATER
96942: IFFALSE 96954
// k := 5 else
96944: LD_ADDR_VAR 0 2
96948: PUSH
96949: LD_INT 5
96951: ST_TO_ADDR
96952: GO 96964
// k := tmp ;
96954: LD_ADDR_VAR 0 2
96958: PUSH
96959: LD_VAR 0 3
96963: ST_TO_ADDR
// for i := 1 to k do
96964: LD_ADDR_VAR 0 1
96968: PUSH
96969: DOUBLE
96970: LD_INT 1
96972: DEC
96973: ST_TO_ADDR
96974: LD_VAR 0 2
96978: PUSH
96979: FOR_TO
96980: IFFALSE 97079
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
96982: LD_VAR 0 3
96986: PUSH
96987: LD_VAR 0 1
96991: ARRAY
96992: PPUSH
96993: LD_VAR 0 1
96997: PUSH
96998: LD_INT 4
97000: MOD
97001: PUSH
97002: LD_INT 1
97004: PLUS
97005: PPUSH
97006: CALL_OW 259
97010: PUSH
97011: LD_INT 10
97013: LESS
97014: IFFALSE 97077
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
97016: LD_VAR 0 3
97020: PUSH
97021: LD_VAR 0 1
97025: ARRAY
97026: PPUSH
97027: LD_VAR 0 1
97031: PUSH
97032: LD_INT 4
97034: MOD
97035: PUSH
97036: LD_INT 1
97038: PLUS
97039: PPUSH
97040: LD_VAR 0 3
97044: PUSH
97045: LD_VAR 0 1
97049: ARRAY
97050: PPUSH
97051: LD_VAR 0 1
97055: PUSH
97056: LD_INT 4
97058: MOD
97059: PUSH
97060: LD_INT 1
97062: PLUS
97063: PPUSH
97064: CALL_OW 259
97068: PUSH
97069: LD_INT 1
97071: PLUS
97072: PPUSH
97073: CALL_OW 237
97077: GO 96979
97079: POP
97080: POP
// end ;
97081: PPOPN 3
97083: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
97084: LD_EXP 96
97088: PUSH
97089: LD_EXP 104
97093: AND
97094: IFFALSE 97114
97096: GO 97098
97098: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
97099: LD_INT 4
97101: PPUSH
97102: LD_OWVAR 2
97106: PPUSH
97107: LD_INT 0
97109: PPUSH
97110: CALL_OW 324
97114: END
// every 0 0$1 trigger StreamModeActive and sShovel do
97115: LD_EXP 96
97119: PUSH
97120: LD_EXP 133
97124: AND
97125: IFFALSE 97145
97127: GO 97129
97129: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
97130: LD_INT 19
97132: PPUSH
97133: LD_OWVAR 2
97137: PPUSH
97138: LD_INT 0
97140: PPUSH
97141: CALL_OW 324
97145: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
97146: LD_EXP 96
97150: PUSH
97151: LD_EXP 105
97155: AND
97156: IFFALSE 97258
97158: GO 97160
97160: DISABLE
97161: LD_INT 0
97163: PPUSH
97164: PPUSH
// begin enable ;
97165: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
97166: LD_ADDR_VAR 0 2
97170: PUSH
97171: LD_INT 22
97173: PUSH
97174: LD_OWVAR 2
97178: PUSH
97179: EMPTY
97180: LIST
97181: LIST
97182: PUSH
97183: LD_INT 2
97185: PUSH
97186: LD_INT 34
97188: PUSH
97189: LD_INT 11
97191: PUSH
97192: EMPTY
97193: LIST
97194: LIST
97195: PUSH
97196: LD_INT 34
97198: PUSH
97199: LD_INT 30
97201: PUSH
97202: EMPTY
97203: LIST
97204: LIST
97205: PUSH
97206: EMPTY
97207: LIST
97208: LIST
97209: LIST
97210: PUSH
97211: EMPTY
97212: LIST
97213: LIST
97214: PPUSH
97215: CALL_OW 69
97219: ST_TO_ADDR
// if not tmp then
97220: LD_VAR 0 2
97224: NOT
97225: IFFALSE 97229
// exit ;
97227: GO 97258
// for i in tmp do
97229: LD_ADDR_VAR 0 1
97233: PUSH
97234: LD_VAR 0 2
97238: PUSH
97239: FOR_IN
97240: IFFALSE 97256
// begin SetLives ( i , 0 ) ;
97242: LD_VAR 0 1
97246: PPUSH
97247: LD_INT 0
97249: PPUSH
97250: CALL_OW 234
// end ;
97254: GO 97239
97256: POP
97257: POP
// end ;
97258: PPOPN 2
97260: END
// every 0 0$1 trigger StreamModeActive and sBunker do
97261: LD_EXP 96
97265: PUSH
97266: LD_EXP 106
97270: AND
97271: IFFALSE 97291
97273: GO 97275
97275: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
97276: LD_INT 32
97278: PPUSH
97279: LD_OWVAR 2
97283: PPUSH
97284: LD_INT 0
97286: PPUSH
97287: CALL_OW 324
97291: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
97292: LD_EXP 96
97296: PUSH
97297: LD_EXP 107
97301: AND
97302: IFFALSE 97483
97304: GO 97306
97306: DISABLE
97307: LD_INT 0
97309: PPUSH
97310: PPUSH
97311: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
97312: LD_ADDR_VAR 0 2
97316: PUSH
97317: LD_INT 22
97319: PUSH
97320: LD_OWVAR 2
97324: PUSH
97325: EMPTY
97326: LIST
97327: LIST
97328: PUSH
97329: LD_INT 33
97331: PUSH
97332: LD_INT 3
97334: PUSH
97335: EMPTY
97336: LIST
97337: LIST
97338: PUSH
97339: EMPTY
97340: LIST
97341: LIST
97342: PPUSH
97343: CALL_OW 69
97347: ST_TO_ADDR
// if not tmp then
97348: LD_VAR 0 2
97352: NOT
97353: IFFALSE 97357
// exit ;
97355: GO 97483
// side := 0 ;
97357: LD_ADDR_VAR 0 3
97361: PUSH
97362: LD_INT 0
97364: ST_TO_ADDR
// for i := 1 to 8 do
97365: LD_ADDR_VAR 0 1
97369: PUSH
97370: DOUBLE
97371: LD_INT 1
97373: DEC
97374: ST_TO_ADDR
97375: LD_INT 8
97377: PUSH
97378: FOR_TO
97379: IFFALSE 97427
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
97381: LD_OWVAR 2
97385: PUSH
97386: LD_VAR 0 1
97390: NONEQUAL
97391: PUSH
97392: LD_OWVAR 2
97396: PPUSH
97397: LD_VAR 0 1
97401: PPUSH
97402: CALL_OW 81
97406: PUSH
97407: LD_INT 2
97409: EQUAL
97410: AND
97411: IFFALSE 97425
// begin side := i ;
97413: LD_ADDR_VAR 0 3
97417: PUSH
97418: LD_VAR 0 1
97422: ST_TO_ADDR
// break ;
97423: GO 97427
// end ;
97425: GO 97378
97427: POP
97428: POP
// if not side then
97429: LD_VAR 0 3
97433: NOT
97434: IFFALSE 97438
// exit ;
97436: GO 97483
// for i := 1 to tmp do
97438: LD_ADDR_VAR 0 1
97442: PUSH
97443: DOUBLE
97444: LD_INT 1
97446: DEC
97447: ST_TO_ADDR
97448: LD_VAR 0 2
97452: PUSH
97453: FOR_TO
97454: IFFALSE 97481
// if Prob ( 60 ) then
97456: LD_INT 60
97458: PPUSH
97459: CALL_OW 13
97463: IFFALSE 97479
// SetSide ( i , side ) ;
97465: LD_VAR 0 1
97469: PPUSH
97470: LD_VAR 0 3
97474: PPUSH
97475: CALL_OW 235
97479: GO 97453
97481: POP
97482: POP
// end ;
97483: PPOPN 3
97485: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
97486: LD_EXP 96
97490: PUSH
97491: LD_EXP 109
97495: AND
97496: IFFALSE 97615
97498: GO 97500
97500: DISABLE
97501: LD_INT 0
97503: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
97504: LD_ADDR_VAR 0 1
97508: PUSH
97509: LD_INT 22
97511: PUSH
97512: LD_OWVAR 2
97516: PUSH
97517: EMPTY
97518: LIST
97519: LIST
97520: PUSH
97521: LD_INT 21
97523: PUSH
97524: LD_INT 1
97526: PUSH
97527: EMPTY
97528: LIST
97529: LIST
97530: PUSH
97531: LD_INT 3
97533: PUSH
97534: LD_INT 23
97536: PUSH
97537: LD_INT 0
97539: PUSH
97540: EMPTY
97541: LIST
97542: LIST
97543: PUSH
97544: EMPTY
97545: LIST
97546: LIST
97547: PUSH
97548: EMPTY
97549: LIST
97550: LIST
97551: LIST
97552: PPUSH
97553: CALL_OW 69
97557: PUSH
97558: FOR_IN
97559: IFFALSE 97613
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
97561: LD_VAR 0 1
97565: PPUSH
97566: CALL_OW 257
97570: PUSH
97571: LD_INT 1
97573: PUSH
97574: LD_INT 2
97576: PUSH
97577: LD_INT 3
97579: PUSH
97580: LD_INT 4
97582: PUSH
97583: EMPTY
97584: LIST
97585: LIST
97586: LIST
97587: LIST
97588: IN
97589: IFFALSE 97611
// SetClass ( un , rand ( 1 , 4 ) ) ;
97591: LD_VAR 0 1
97595: PPUSH
97596: LD_INT 1
97598: PPUSH
97599: LD_INT 4
97601: PPUSH
97602: CALL_OW 12
97606: PPUSH
97607: CALL_OW 336
97611: GO 97558
97613: POP
97614: POP
// end ;
97615: PPOPN 1
97617: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
97618: LD_EXP 96
97622: PUSH
97623: LD_EXP 108
97627: AND
97628: IFFALSE 97707
97630: GO 97632
97632: DISABLE
97633: LD_INT 0
97635: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
97636: LD_ADDR_VAR 0 1
97640: PUSH
97641: LD_INT 22
97643: PUSH
97644: LD_OWVAR 2
97648: PUSH
97649: EMPTY
97650: LIST
97651: LIST
97652: PUSH
97653: LD_INT 21
97655: PUSH
97656: LD_INT 3
97658: PUSH
97659: EMPTY
97660: LIST
97661: LIST
97662: PUSH
97663: EMPTY
97664: LIST
97665: LIST
97666: PPUSH
97667: CALL_OW 69
97671: ST_TO_ADDR
// if not tmp then
97672: LD_VAR 0 1
97676: NOT
97677: IFFALSE 97681
// exit ;
97679: GO 97707
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
97681: LD_VAR 0 1
97685: PUSH
97686: LD_INT 1
97688: PPUSH
97689: LD_VAR 0 1
97693: PPUSH
97694: CALL_OW 12
97698: ARRAY
97699: PPUSH
97700: LD_INT 100
97702: PPUSH
97703: CALL_OW 234
// end ;
97707: PPOPN 1
97709: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
97710: LD_EXP 96
97714: PUSH
97715: LD_EXP 110
97719: AND
97720: IFFALSE 97818
97722: GO 97724
97724: DISABLE
97725: LD_INT 0
97727: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
97728: LD_ADDR_VAR 0 1
97732: PUSH
97733: LD_INT 22
97735: PUSH
97736: LD_OWVAR 2
97740: PUSH
97741: EMPTY
97742: LIST
97743: LIST
97744: PUSH
97745: LD_INT 21
97747: PUSH
97748: LD_INT 1
97750: PUSH
97751: EMPTY
97752: LIST
97753: LIST
97754: PUSH
97755: EMPTY
97756: LIST
97757: LIST
97758: PPUSH
97759: CALL_OW 69
97763: ST_TO_ADDR
// if not tmp then
97764: LD_VAR 0 1
97768: NOT
97769: IFFALSE 97773
// exit ;
97771: GO 97818
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
97773: LD_VAR 0 1
97777: PUSH
97778: LD_INT 1
97780: PPUSH
97781: LD_VAR 0 1
97785: PPUSH
97786: CALL_OW 12
97790: ARRAY
97791: PPUSH
97792: LD_INT 1
97794: PPUSH
97795: LD_INT 4
97797: PPUSH
97798: CALL_OW 12
97802: PPUSH
97803: LD_INT 3000
97805: PPUSH
97806: LD_INT 9000
97808: PPUSH
97809: CALL_OW 12
97813: PPUSH
97814: CALL_OW 492
// end ;
97818: PPOPN 1
97820: END
// every 0 0$1 trigger StreamModeActive and sDepot do
97821: LD_EXP 96
97825: PUSH
97826: LD_EXP 111
97830: AND
97831: IFFALSE 97851
97833: GO 97835
97835: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
97836: LD_INT 1
97838: PPUSH
97839: LD_OWVAR 2
97843: PPUSH
97844: LD_INT 0
97846: PPUSH
97847: CALL_OW 324
97851: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
97852: LD_EXP 96
97856: PUSH
97857: LD_EXP 112
97861: AND
97862: IFFALSE 97945
97864: GO 97866
97866: DISABLE
97867: LD_INT 0
97869: PPUSH
97870: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
97871: LD_ADDR_VAR 0 2
97875: PUSH
97876: LD_INT 22
97878: PUSH
97879: LD_OWVAR 2
97883: PUSH
97884: EMPTY
97885: LIST
97886: LIST
97887: PUSH
97888: LD_INT 21
97890: PUSH
97891: LD_INT 3
97893: PUSH
97894: EMPTY
97895: LIST
97896: LIST
97897: PUSH
97898: EMPTY
97899: LIST
97900: LIST
97901: PPUSH
97902: CALL_OW 69
97906: ST_TO_ADDR
// if not tmp then
97907: LD_VAR 0 2
97911: NOT
97912: IFFALSE 97916
// exit ;
97914: GO 97945
// for i in tmp do
97916: LD_ADDR_VAR 0 1
97920: PUSH
97921: LD_VAR 0 2
97925: PUSH
97926: FOR_IN
97927: IFFALSE 97943
// SetBLevel ( i , 10 ) ;
97929: LD_VAR 0 1
97933: PPUSH
97934: LD_INT 10
97936: PPUSH
97937: CALL_OW 241
97941: GO 97926
97943: POP
97944: POP
// end ;
97945: PPOPN 2
97947: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
97948: LD_EXP 96
97952: PUSH
97953: LD_EXP 113
97957: AND
97958: IFFALSE 98069
97960: GO 97962
97962: DISABLE
97963: LD_INT 0
97965: PPUSH
97966: PPUSH
97967: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
97968: LD_ADDR_VAR 0 3
97972: PUSH
97973: LD_INT 22
97975: PUSH
97976: LD_OWVAR 2
97980: PUSH
97981: EMPTY
97982: LIST
97983: LIST
97984: PUSH
97985: LD_INT 25
97987: PUSH
97988: LD_INT 1
97990: PUSH
97991: EMPTY
97992: LIST
97993: LIST
97994: PUSH
97995: EMPTY
97996: LIST
97997: LIST
97998: PPUSH
97999: CALL_OW 69
98003: ST_TO_ADDR
// if not tmp then
98004: LD_VAR 0 3
98008: NOT
98009: IFFALSE 98013
// exit ;
98011: GO 98069
// un := tmp [ rand ( 1 , tmp ) ] ;
98013: LD_ADDR_VAR 0 2
98017: PUSH
98018: LD_VAR 0 3
98022: PUSH
98023: LD_INT 1
98025: PPUSH
98026: LD_VAR 0 3
98030: PPUSH
98031: CALL_OW 12
98035: ARRAY
98036: ST_TO_ADDR
// if Crawls ( un ) then
98037: LD_VAR 0 2
98041: PPUSH
98042: CALL_OW 318
98046: IFFALSE 98057
// ComWalk ( un ) ;
98048: LD_VAR 0 2
98052: PPUSH
98053: CALL_OW 138
// SetClass ( un , class_sniper ) ;
98057: LD_VAR 0 2
98061: PPUSH
98062: LD_INT 5
98064: PPUSH
98065: CALL_OW 336
// end ;
98069: PPOPN 3
98071: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
98072: LD_EXP 96
98076: PUSH
98077: LD_EXP 114
98081: AND
98082: PUSH
98083: LD_OWVAR 67
98087: PUSH
98088: LD_INT 4
98090: LESS
98091: AND
98092: IFFALSE 98111
98094: GO 98096
98096: DISABLE
// begin Difficulty := Difficulty + 1 ;
98097: LD_ADDR_OWVAR 67
98101: PUSH
98102: LD_OWVAR 67
98106: PUSH
98107: LD_INT 1
98109: PLUS
98110: ST_TO_ADDR
// end ;
98111: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
98112: LD_EXP 96
98116: PUSH
98117: LD_EXP 115
98121: AND
98122: IFFALSE 98225
98124: GO 98126
98126: DISABLE
98127: LD_INT 0
98129: PPUSH
// begin for i := 1 to 5 do
98130: LD_ADDR_VAR 0 1
98134: PUSH
98135: DOUBLE
98136: LD_INT 1
98138: DEC
98139: ST_TO_ADDR
98140: LD_INT 5
98142: PUSH
98143: FOR_TO
98144: IFFALSE 98223
// begin uc_nation := nation_nature ;
98146: LD_ADDR_OWVAR 21
98150: PUSH
98151: LD_INT 0
98153: ST_TO_ADDR
// uc_side := 0 ;
98154: LD_ADDR_OWVAR 20
98158: PUSH
98159: LD_INT 0
98161: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
98162: LD_ADDR_OWVAR 29
98166: PUSH
98167: LD_INT 12
98169: PUSH
98170: LD_INT 12
98172: PUSH
98173: EMPTY
98174: LIST
98175: LIST
98176: ST_TO_ADDR
// hc_agressivity := 20 ;
98177: LD_ADDR_OWVAR 35
98181: PUSH
98182: LD_INT 20
98184: ST_TO_ADDR
// hc_class := class_tiger ;
98185: LD_ADDR_OWVAR 28
98189: PUSH
98190: LD_INT 14
98192: ST_TO_ADDR
// hc_gallery :=  ;
98193: LD_ADDR_OWVAR 33
98197: PUSH
98198: LD_STRING 
98200: ST_TO_ADDR
// hc_name :=  ;
98201: LD_ADDR_OWVAR 26
98205: PUSH
98206: LD_STRING 
98208: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
98209: CALL_OW 44
98213: PPUSH
98214: LD_INT 0
98216: PPUSH
98217: CALL_OW 51
// end ;
98221: GO 98143
98223: POP
98224: POP
// end ;
98225: PPOPN 1
98227: END
// every 0 0$1 trigger StreamModeActive and sBomb do
98228: LD_EXP 96
98232: PUSH
98233: LD_EXP 116
98237: AND
98238: IFFALSE 98247
98240: GO 98242
98242: DISABLE
// StreamSibBomb ;
98243: CALL 98248 0 0
98247: END
// export function StreamSibBomb ; var i , x , y ; begin
98248: LD_INT 0
98250: PPUSH
98251: PPUSH
98252: PPUSH
98253: PPUSH
// result := false ;
98254: LD_ADDR_VAR 0 1
98258: PUSH
98259: LD_INT 0
98261: ST_TO_ADDR
// for i := 1 to 16 do
98262: LD_ADDR_VAR 0 2
98266: PUSH
98267: DOUBLE
98268: LD_INT 1
98270: DEC
98271: ST_TO_ADDR
98272: LD_INT 16
98274: PUSH
98275: FOR_TO
98276: IFFALSE 98475
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
98278: LD_ADDR_VAR 0 3
98282: PUSH
98283: LD_INT 10
98285: PUSH
98286: LD_INT 20
98288: PUSH
98289: LD_INT 30
98291: PUSH
98292: LD_INT 40
98294: PUSH
98295: LD_INT 50
98297: PUSH
98298: LD_INT 60
98300: PUSH
98301: LD_INT 70
98303: PUSH
98304: LD_INT 80
98306: PUSH
98307: LD_INT 90
98309: PUSH
98310: LD_INT 100
98312: PUSH
98313: LD_INT 110
98315: PUSH
98316: LD_INT 120
98318: PUSH
98319: LD_INT 130
98321: PUSH
98322: LD_INT 140
98324: PUSH
98325: LD_INT 150
98327: PUSH
98328: EMPTY
98329: LIST
98330: LIST
98331: LIST
98332: LIST
98333: LIST
98334: LIST
98335: LIST
98336: LIST
98337: LIST
98338: LIST
98339: LIST
98340: LIST
98341: LIST
98342: LIST
98343: LIST
98344: PUSH
98345: LD_INT 1
98347: PPUSH
98348: LD_INT 15
98350: PPUSH
98351: CALL_OW 12
98355: ARRAY
98356: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
98357: LD_ADDR_VAR 0 4
98361: PUSH
98362: LD_INT 10
98364: PUSH
98365: LD_INT 20
98367: PUSH
98368: LD_INT 30
98370: PUSH
98371: LD_INT 40
98373: PUSH
98374: LD_INT 50
98376: PUSH
98377: LD_INT 60
98379: PUSH
98380: LD_INT 70
98382: PUSH
98383: LD_INT 80
98385: PUSH
98386: LD_INT 90
98388: PUSH
98389: LD_INT 100
98391: PUSH
98392: LD_INT 110
98394: PUSH
98395: LD_INT 120
98397: PUSH
98398: LD_INT 130
98400: PUSH
98401: LD_INT 140
98403: PUSH
98404: LD_INT 150
98406: PUSH
98407: EMPTY
98408: LIST
98409: LIST
98410: LIST
98411: LIST
98412: LIST
98413: LIST
98414: LIST
98415: LIST
98416: LIST
98417: LIST
98418: LIST
98419: LIST
98420: LIST
98421: LIST
98422: LIST
98423: PUSH
98424: LD_INT 1
98426: PPUSH
98427: LD_INT 15
98429: PPUSH
98430: CALL_OW 12
98434: ARRAY
98435: ST_TO_ADDR
// if ValidHex ( x , y ) then
98436: LD_VAR 0 3
98440: PPUSH
98441: LD_VAR 0 4
98445: PPUSH
98446: CALL_OW 488
98450: IFFALSE 98473
// begin result := [ x , y ] ;
98452: LD_ADDR_VAR 0 1
98456: PUSH
98457: LD_VAR 0 3
98461: PUSH
98462: LD_VAR 0 4
98466: PUSH
98467: EMPTY
98468: LIST
98469: LIST
98470: ST_TO_ADDR
// break ;
98471: GO 98475
// end ; end ;
98473: GO 98275
98475: POP
98476: POP
// if result then
98477: LD_VAR 0 1
98481: IFFALSE 98541
// begin ToLua ( playSibBomb() ) ;
98483: LD_STRING playSibBomb()
98485: PPUSH
98486: CALL_OW 559
// wait ( 0 0$14 ) ;
98490: LD_INT 490
98492: PPUSH
98493: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
98497: LD_VAR 0 1
98501: PUSH
98502: LD_INT 1
98504: ARRAY
98505: PPUSH
98506: LD_VAR 0 1
98510: PUSH
98511: LD_INT 2
98513: ARRAY
98514: PPUSH
98515: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
98519: LD_VAR 0 1
98523: PUSH
98524: LD_INT 1
98526: ARRAY
98527: PPUSH
98528: LD_VAR 0 1
98532: PUSH
98533: LD_INT 2
98535: ARRAY
98536: PPUSH
98537: CALL_OW 429
// end ; end ;
98541: LD_VAR 0 1
98545: RET
// every 0 0$1 trigger StreamModeActive and sReset do
98546: LD_EXP 96
98550: PUSH
98551: LD_EXP 118
98555: AND
98556: IFFALSE 98568
98558: GO 98560
98560: DISABLE
// YouLost (  ) ;
98561: LD_STRING 
98563: PPUSH
98564: CALL_OW 104
98568: END
// every 0 0$1 trigger StreamModeActive and sFog do
98569: LD_EXP 96
98573: PUSH
98574: LD_EXP 117
98578: AND
98579: IFFALSE 98593
98581: GO 98583
98583: DISABLE
// FogOff ( your_side ) ;
98584: LD_OWVAR 2
98588: PPUSH
98589: CALL_OW 344
98593: END
// every 0 0$1 trigger StreamModeActive and sSun do
98594: LD_EXP 96
98598: PUSH
98599: LD_EXP 119
98603: AND
98604: IFFALSE 98632
98606: GO 98608
98608: DISABLE
// begin solar_recharge_percent := 0 ;
98609: LD_ADDR_OWVAR 79
98613: PUSH
98614: LD_INT 0
98616: ST_TO_ADDR
// wait ( 5 5$00 ) ;
98617: LD_INT 10500
98619: PPUSH
98620: CALL_OW 67
// solar_recharge_percent := 100 ;
98624: LD_ADDR_OWVAR 79
98628: PUSH
98629: LD_INT 100
98631: ST_TO_ADDR
// end ;
98632: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
98633: LD_EXP 96
98637: PUSH
98638: LD_EXP 120
98642: AND
98643: IFFALSE 98882
98645: GO 98647
98647: DISABLE
98648: LD_INT 0
98650: PPUSH
98651: PPUSH
98652: PPUSH
// begin tmp := [ ] ;
98653: LD_ADDR_VAR 0 3
98657: PUSH
98658: EMPTY
98659: ST_TO_ADDR
// for i := 1 to 6 do
98660: LD_ADDR_VAR 0 1
98664: PUSH
98665: DOUBLE
98666: LD_INT 1
98668: DEC
98669: ST_TO_ADDR
98670: LD_INT 6
98672: PUSH
98673: FOR_TO
98674: IFFALSE 98779
// begin uc_nation := nation_nature ;
98676: LD_ADDR_OWVAR 21
98680: PUSH
98681: LD_INT 0
98683: ST_TO_ADDR
// uc_side := 0 ;
98684: LD_ADDR_OWVAR 20
98688: PUSH
98689: LD_INT 0
98691: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
98692: LD_ADDR_OWVAR 29
98696: PUSH
98697: LD_INT 12
98699: PUSH
98700: LD_INT 12
98702: PUSH
98703: EMPTY
98704: LIST
98705: LIST
98706: ST_TO_ADDR
// hc_agressivity := 20 ;
98707: LD_ADDR_OWVAR 35
98711: PUSH
98712: LD_INT 20
98714: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
98715: LD_ADDR_OWVAR 28
98719: PUSH
98720: LD_INT 17
98722: ST_TO_ADDR
// hc_gallery :=  ;
98723: LD_ADDR_OWVAR 33
98727: PUSH
98728: LD_STRING 
98730: ST_TO_ADDR
// hc_name :=  ;
98731: LD_ADDR_OWVAR 26
98735: PUSH
98736: LD_STRING 
98738: ST_TO_ADDR
// un := CreateHuman ;
98739: LD_ADDR_VAR 0 2
98743: PUSH
98744: CALL_OW 44
98748: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
98749: LD_VAR 0 2
98753: PPUSH
98754: LD_INT 1
98756: PPUSH
98757: CALL_OW 51
// tmp := tmp ^ un ;
98761: LD_ADDR_VAR 0 3
98765: PUSH
98766: LD_VAR 0 3
98770: PUSH
98771: LD_VAR 0 2
98775: ADD
98776: ST_TO_ADDR
// end ;
98777: GO 98673
98779: POP
98780: POP
// repeat wait ( 0 0$1 ) ;
98781: LD_INT 35
98783: PPUSH
98784: CALL_OW 67
// for un in tmp do
98788: LD_ADDR_VAR 0 2
98792: PUSH
98793: LD_VAR 0 3
98797: PUSH
98798: FOR_IN
98799: IFFALSE 98873
// begin if IsDead ( un ) then
98801: LD_VAR 0 2
98805: PPUSH
98806: CALL_OW 301
98810: IFFALSE 98830
// begin tmp := tmp diff un ;
98812: LD_ADDR_VAR 0 3
98816: PUSH
98817: LD_VAR 0 3
98821: PUSH
98822: LD_VAR 0 2
98826: DIFF
98827: ST_TO_ADDR
// continue ;
98828: GO 98798
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
98830: LD_VAR 0 2
98834: PPUSH
98835: LD_INT 3
98837: PUSH
98838: LD_INT 22
98840: PUSH
98841: LD_INT 0
98843: PUSH
98844: EMPTY
98845: LIST
98846: LIST
98847: PUSH
98848: EMPTY
98849: LIST
98850: LIST
98851: PPUSH
98852: CALL_OW 69
98856: PPUSH
98857: LD_VAR 0 2
98861: PPUSH
98862: CALL_OW 74
98866: PPUSH
98867: CALL_OW 115
// end ;
98871: GO 98798
98873: POP
98874: POP
// until not tmp ;
98875: LD_VAR 0 3
98879: NOT
98880: IFFALSE 98781
// end ;
98882: PPOPN 3
98884: END
// every 0 0$1 trigger StreamModeActive and sTroll do
98885: LD_EXP 96
98889: PUSH
98890: LD_EXP 121
98894: AND
98895: IFFALSE 98949
98897: GO 98899
98899: DISABLE
// begin ToLua ( displayTroll(); ) ;
98900: LD_STRING displayTroll();
98902: PPUSH
98903: CALL_OW 559
// wait ( 3 3$00 ) ;
98907: LD_INT 6300
98909: PPUSH
98910: CALL_OW 67
// ToLua ( hideTroll(); ) ;
98914: LD_STRING hideTroll();
98916: PPUSH
98917: CALL_OW 559
// wait ( 1 1$00 ) ;
98921: LD_INT 2100
98923: PPUSH
98924: CALL_OW 67
// ToLua ( displayTroll(); ) ;
98928: LD_STRING displayTroll();
98930: PPUSH
98931: CALL_OW 559
// wait ( 1 1$00 ) ;
98935: LD_INT 2100
98937: PPUSH
98938: CALL_OW 67
// ToLua ( hideTroll(); ) ;
98942: LD_STRING hideTroll();
98944: PPUSH
98945: CALL_OW 559
// end ;
98949: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
98950: LD_EXP 96
98954: PUSH
98955: LD_EXP 122
98959: AND
98960: IFFALSE 99023
98962: GO 98964
98964: DISABLE
98965: LD_INT 0
98967: PPUSH
// begin p := 0 ;
98968: LD_ADDR_VAR 0 1
98972: PUSH
98973: LD_INT 0
98975: ST_TO_ADDR
// repeat game_speed := 1 ;
98976: LD_ADDR_OWVAR 65
98980: PUSH
98981: LD_INT 1
98983: ST_TO_ADDR
// wait ( 0 0$1 ) ;
98984: LD_INT 35
98986: PPUSH
98987: CALL_OW 67
// p := p + 1 ;
98991: LD_ADDR_VAR 0 1
98995: PUSH
98996: LD_VAR 0 1
99000: PUSH
99001: LD_INT 1
99003: PLUS
99004: ST_TO_ADDR
// until p >= 60 ;
99005: LD_VAR 0 1
99009: PUSH
99010: LD_INT 60
99012: GREATEREQUAL
99013: IFFALSE 98976
// game_speed := 4 ;
99015: LD_ADDR_OWVAR 65
99019: PUSH
99020: LD_INT 4
99022: ST_TO_ADDR
// end ;
99023: PPOPN 1
99025: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
99026: LD_EXP 96
99030: PUSH
99031: LD_EXP 123
99035: AND
99036: IFFALSE 99182
99038: GO 99040
99040: DISABLE
99041: LD_INT 0
99043: PPUSH
99044: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
99045: LD_ADDR_VAR 0 1
99049: PUSH
99050: LD_INT 22
99052: PUSH
99053: LD_OWVAR 2
99057: PUSH
99058: EMPTY
99059: LIST
99060: LIST
99061: PUSH
99062: LD_INT 2
99064: PUSH
99065: LD_INT 30
99067: PUSH
99068: LD_INT 0
99070: PUSH
99071: EMPTY
99072: LIST
99073: LIST
99074: PUSH
99075: LD_INT 30
99077: PUSH
99078: LD_INT 1
99080: PUSH
99081: EMPTY
99082: LIST
99083: LIST
99084: PUSH
99085: EMPTY
99086: LIST
99087: LIST
99088: LIST
99089: PUSH
99090: EMPTY
99091: LIST
99092: LIST
99093: PPUSH
99094: CALL_OW 69
99098: ST_TO_ADDR
// if not depot then
99099: LD_VAR 0 1
99103: NOT
99104: IFFALSE 99108
// exit ;
99106: GO 99182
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
99108: LD_ADDR_VAR 0 2
99112: PUSH
99113: LD_VAR 0 1
99117: PUSH
99118: LD_INT 1
99120: PPUSH
99121: LD_VAR 0 1
99125: PPUSH
99126: CALL_OW 12
99130: ARRAY
99131: PPUSH
99132: CALL_OW 274
99136: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
99137: LD_VAR 0 2
99141: PPUSH
99142: LD_INT 1
99144: PPUSH
99145: LD_INT 0
99147: PPUSH
99148: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
99152: LD_VAR 0 2
99156: PPUSH
99157: LD_INT 2
99159: PPUSH
99160: LD_INT 0
99162: PPUSH
99163: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
99167: LD_VAR 0 2
99171: PPUSH
99172: LD_INT 3
99174: PPUSH
99175: LD_INT 0
99177: PPUSH
99178: CALL_OW 277
// end ;
99182: PPOPN 2
99184: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
99185: LD_EXP 96
99189: PUSH
99190: LD_EXP 124
99194: AND
99195: IFFALSE 99292
99197: GO 99199
99199: DISABLE
99200: LD_INT 0
99202: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
99203: LD_ADDR_VAR 0 1
99207: PUSH
99208: LD_INT 22
99210: PUSH
99211: LD_OWVAR 2
99215: PUSH
99216: EMPTY
99217: LIST
99218: LIST
99219: PUSH
99220: LD_INT 21
99222: PUSH
99223: LD_INT 1
99225: PUSH
99226: EMPTY
99227: LIST
99228: LIST
99229: PUSH
99230: LD_INT 3
99232: PUSH
99233: LD_INT 23
99235: PUSH
99236: LD_INT 0
99238: PUSH
99239: EMPTY
99240: LIST
99241: LIST
99242: PUSH
99243: EMPTY
99244: LIST
99245: LIST
99246: PUSH
99247: EMPTY
99248: LIST
99249: LIST
99250: LIST
99251: PPUSH
99252: CALL_OW 69
99256: ST_TO_ADDR
// if not tmp then
99257: LD_VAR 0 1
99261: NOT
99262: IFFALSE 99266
// exit ;
99264: GO 99292
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
99266: LD_VAR 0 1
99270: PUSH
99271: LD_INT 1
99273: PPUSH
99274: LD_VAR 0 1
99278: PPUSH
99279: CALL_OW 12
99283: ARRAY
99284: PPUSH
99285: LD_INT 200
99287: PPUSH
99288: CALL_OW 234
// end ;
99292: PPOPN 1
99294: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
99295: LD_EXP 96
99299: PUSH
99300: LD_EXP 125
99304: AND
99305: IFFALSE 99384
99307: GO 99309
99309: DISABLE
99310: LD_INT 0
99312: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
99313: LD_ADDR_VAR 0 1
99317: PUSH
99318: LD_INT 22
99320: PUSH
99321: LD_OWVAR 2
99325: PUSH
99326: EMPTY
99327: LIST
99328: LIST
99329: PUSH
99330: LD_INT 21
99332: PUSH
99333: LD_INT 2
99335: PUSH
99336: EMPTY
99337: LIST
99338: LIST
99339: PUSH
99340: EMPTY
99341: LIST
99342: LIST
99343: PPUSH
99344: CALL_OW 69
99348: ST_TO_ADDR
// if not tmp then
99349: LD_VAR 0 1
99353: NOT
99354: IFFALSE 99358
// exit ;
99356: GO 99384
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
99358: LD_VAR 0 1
99362: PUSH
99363: LD_INT 1
99365: PPUSH
99366: LD_VAR 0 1
99370: PPUSH
99371: CALL_OW 12
99375: ARRAY
99376: PPUSH
99377: LD_INT 60
99379: PPUSH
99380: CALL_OW 234
// end ;
99384: PPOPN 1
99386: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
99387: LD_EXP 96
99391: PUSH
99392: LD_EXP 126
99396: AND
99397: IFFALSE 99496
99399: GO 99401
99401: DISABLE
99402: LD_INT 0
99404: PPUSH
99405: PPUSH
// begin enable ;
99406: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
99407: LD_ADDR_VAR 0 1
99411: PUSH
99412: LD_INT 22
99414: PUSH
99415: LD_OWVAR 2
99419: PUSH
99420: EMPTY
99421: LIST
99422: LIST
99423: PUSH
99424: LD_INT 61
99426: PUSH
99427: EMPTY
99428: LIST
99429: PUSH
99430: LD_INT 33
99432: PUSH
99433: LD_INT 2
99435: PUSH
99436: EMPTY
99437: LIST
99438: LIST
99439: PUSH
99440: EMPTY
99441: LIST
99442: LIST
99443: LIST
99444: PPUSH
99445: CALL_OW 69
99449: ST_TO_ADDR
// if not tmp then
99450: LD_VAR 0 1
99454: NOT
99455: IFFALSE 99459
// exit ;
99457: GO 99496
// for i in tmp do
99459: LD_ADDR_VAR 0 2
99463: PUSH
99464: LD_VAR 0 1
99468: PUSH
99469: FOR_IN
99470: IFFALSE 99494
// if IsControledBy ( i ) then
99472: LD_VAR 0 2
99476: PPUSH
99477: CALL_OW 312
99481: IFFALSE 99492
// ComUnlink ( i ) ;
99483: LD_VAR 0 2
99487: PPUSH
99488: CALL_OW 136
99492: GO 99469
99494: POP
99495: POP
// end ;
99496: PPOPN 2
99498: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
99499: LD_EXP 96
99503: PUSH
99504: LD_EXP 127
99508: AND
99509: IFFALSE 99649
99511: GO 99513
99513: DISABLE
99514: LD_INT 0
99516: PPUSH
99517: PPUSH
// begin ToLua ( displayPowell(); ) ;
99518: LD_STRING displayPowell();
99520: PPUSH
99521: CALL_OW 559
// uc_side := 0 ;
99525: LD_ADDR_OWVAR 20
99529: PUSH
99530: LD_INT 0
99532: ST_TO_ADDR
// uc_nation := 2 ;
99533: LD_ADDR_OWVAR 21
99537: PUSH
99538: LD_INT 2
99540: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
99541: LD_ADDR_OWVAR 37
99545: PUSH
99546: LD_INT 14
99548: ST_TO_ADDR
// vc_engine := engine_siberite ;
99549: LD_ADDR_OWVAR 39
99553: PUSH
99554: LD_INT 3
99556: ST_TO_ADDR
// vc_control := control_apeman ;
99557: LD_ADDR_OWVAR 38
99561: PUSH
99562: LD_INT 5
99564: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
99565: LD_ADDR_OWVAR 40
99569: PUSH
99570: LD_INT 29
99572: ST_TO_ADDR
// un := CreateVehicle ;
99573: LD_ADDR_VAR 0 2
99577: PUSH
99578: CALL_OW 45
99582: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
99583: LD_VAR 0 2
99587: PPUSH
99588: LD_INT 1
99590: PPUSH
99591: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
99595: LD_INT 35
99597: PPUSH
99598: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
99602: LD_VAR 0 2
99606: PPUSH
99607: LD_INT 22
99609: PUSH
99610: LD_OWVAR 2
99614: PUSH
99615: EMPTY
99616: LIST
99617: LIST
99618: PPUSH
99619: CALL_OW 69
99623: PPUSH
99624: LD_VAR 0 2
99628: PPUSH
99629: CALL_OW 74
99633: PPUSH
99634: CALL_OW 115
// until IsDead ( un ) ;
99638: LD_VAR 0 2
99642: PPUSH
99643: CALL_OW 301
99647: IFFALSE 99595
// end ;
99649: PPOPN 2
99651: END
// every 0 0$1 trigger StreamModeActive and sStu do
99652: LD_EXP 96
99656: PUSH
99657: LD_EXP 135
99661: AND
99662: IFFALSE 99678
99664: GO 99666
99666: DISABLE
// begin ToLua ( displayStucuk(); ) ;
99667: LD_STRING displayStucuk();
99669: PPUSH
99670: CALL_OW 559
// ResetFog ;
99674: CALL_OW 335
// end ;
99678: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
99679: LD_EXP 96
99683: PUSH
99684: LD_EXP 128
99688: AND
99689: IFFALSE 99830
99691: GO 99693
99693: DISABLE
99694: LD_INT 0
99696: PPUSH
99697: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
99698: LD_ADDR_VAR 0 2
99702: PUSH
99703: LD_INT 22
99705: PUSH
99706: LD_OWVAR 2
99710: PUSH
99711: EMPTY
99712: LIST
99713: LIST
99714: PUSH
99715: LD_INT 21
99717: PUSH
99718: LD_INT 1
99720: PUSH
99721: EMPTY
99722: LIST
99723: LIST
99724: PUSH
99725: EMPTY
99726: LIST
99727: LIST
99728: PPUSH
99729: CALL_OW 69
99733: ST_TO_ADDR
// if not tmp then
99734: LD_VAR 0 2
99738: NOT
99739: IFFALSE 99743
// exit ;
99741: GO 99830
// un := tmp [ rand ( 1 , tmp ) ] ;
99743: LD_ADDR_VAR 0 1
99747: PUSH
99748: LD_VAR 0 2
99752: PUSH
99753: LD_INT 1
99755: PPUSH
99756: LD_VAR 0 2
99760: PPUSH
99761: CALL_OW 12
99765: ARRAY
99766: ST_TO_ADDR
// SetSide ( un , 0 ) ;
99767: LD_VAR 0 1
99771: PPUSH
99772: LD_INT 0
99774: PPUSH
99775: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
99779: LD_VAR 0 1
99783: PPUSH
99784: LD_OWVAR 3
99788: PUSH
99789: LD_VAR 0 1
99793: DIFF
99794: PPUSH
99795: LD_VAR 0 1
99799: PPUSH
99800: CALL_OW 74
99804: PPUSH
99805: CALL_OW 115
// wait ( 0 0$20 ) ;
99809: LD_INT 700
99811: PPUSH
99812: CALL_OW 67
// SetSide ( un , your_side ) ;
99816: LD_VAR 0 1
99820: PPUSH
99821: LD_OWVAR 2
99825: PPUSH
99826: CALL_OW 235
// end ;
99830: PPOPN 2
99832: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
99833: LD_EXP 96
99837: PUSH
99838: LD_EXP 129
99842: AND
99843: IFFALSE 99949
99845: GO 99847
99847: DISABLE
99848: LD_INT 0
99850: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
99851: LD_ADDR_VAR 0 1
99855: PUSH
99856: LD_INT 22
99858: PUSH
99859: LD_OWVAR 2
99863: PUSH
99864: EMPTY
99865: LIST
99866: LIST
99867: PUSH
99868: LD_INT 2
99870: PUSH
99871: LD_INT 30
99873: PUSH
99874: LD_INT 0
99876: PUSH
99877: EMPTY
99878: LIST
99879: LIST
99880: PUSH
99881: LD_INT 30
99883: PUSH
99884: LD_INT 1
99886: PUSH
99887: EMPTY
99888: LIST
99889: LIST
99890: PUSH
99891: EMPTY
99892: LIST
99893: LIST
99894: LIST
99895: PUSH
99896: EMPTY
99897: LIST
99898: LIST
99899: PPUSH
99900: CALL_OW 69
99904: ST_TO_ADDR
// if not depot then
99905: LD_VAR 0 1
99909: NOT
99910: IFFALSE 99914
// exit ;
99912: GO 99949
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
99914: LD_VAR 0 1
99918: PUSH
99919: LD_INT 1
99921: ARRAY
99922: PPUSH
99923: CALL_OW 250
99927: PPUSH
99928: LD_VAR 0 1
99932: PUSH
99933: LD_INT 1
99935: ARRAY
99936: PPUSH
99937: CALL_OW 251
99941: PPUSH
99942: LD_INT 70
99944: PPUSH
99945: CALL_OW 495
// end ;
99949: PPOPN 1
99951: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
99952: LD_EXP 96
99956: PUSH
99957: LD_EXP 130
99961: AND
99962: IFFALSE 100173
99964: GO 99966
99966: DISABLE
99967: LD_INT 0
99969: PPUSH
99970: PPUSH
99971: PPUSH
99972: PPUSH
99973: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
99974: LD_ADDR_VAR 0 5
99978: PUSH
99979: LD_INT 22
99981: PUSH
99982: LD_OWVAR 2
99986: PUSH
99987: EMPTY
99988: LIST
99989: LIST
99990: PUSH
99991: LD_INT 21
99993: PUSH
99994: LD_INT 1
99996: PUSH
99997: EMPTY
99998: LIST
99999: LIST
100000: PUSH
100001: EMPTY
100002: LIST
100003: LIST
100004: PPUSH
100005: CALL_OW 69
100009: ST_TO_ADDR
// if not tmp then
100010: LD_VAR 0 5
100014: NOT
100015: IFFALSE 100019
// exit ;
100017: GO 100173
// for i in tmp do
100019: LD_ADDR_VAR 0 1
100023: PUSH
100024: LD_VAR 0 5
100028: PUSH
100029: FOR_IN
100030: IFFALSE 100171
// begin d := rand ( 0 , 5 ) ;
100032: LD_ADDR_VAR 0 4
100036: PUSH
100037: LD_INT 0
100039: PPUSH
100040: LD_INT 5
100042: PPUSH
100043: CALL_OW 12
100047: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
100048: LD_ADDR_VAR 0 2
100052: PUSH
100053: LD_VAR 0 1
100057: PPUSH
100058: CALL_OW 250
100062: PPUSH
100063: LD_VAR 0 4
100067: PPUSH
100068: LD_INT 3
100070: PPUSH
100071: LD_INT 12
100073: PPUSH
100074: CALL_OW 12
100078: PPUSH
100079: CALL_OW 272
100083: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
100084: LD_ADDR_VAR 0 3
100088: PUSH
100089: LD_VAR 0 1
100093: PPUSH
100094: CALL_OW 251
100098: PPUSH
100099: LD_VAR 0 4
100103: PPUSH
100104: LD_INT 3
100106: PPUSH
100107: LD_INT 12
100109: PPUSH
100110: CALL_OW 12
100114: PPUSH
100115: CALL_OW 273
100119: ST_TO_ADDR
// if ValidHex ( x , y ) then
100120: LD_VAR 0 2
100124: PPUSH
100125: LD_VAR 0 3
100129: PPUSH
100130: CALL_OW 488
100134: IFFALSE 100169
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
100136: LD_VAR 0 1
100140: PPUSH
100141: LD_VAR 0 2
100145: PPUSH
100146: LD_VAR 0 3
100150: PPUSH
100151: LD_INT 3
100153: PPUSH
100154: LD_INT 6
100156: PPUSH
100157: CALL_OW 12
100161: PPUSH
100162: LD_INT 1
100164: PPUSH
100165: CALL_OW 483
// end ;
100169: GO 100029
100171: POP
100172: POP
// end ;
100173: PPOPN 5
100175: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
100176: LD_EXP 96
100180: PUSH
100181: LD_EXP 131
100185: AND
100186: IFFALSE 100280
100188: GO 100190
100190: DISABLE
100191: LD_INT 0
100193: PPUSH
100194: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
100195: LD_ADDR_VAR 0 2
100199: PUSH
100200: LD_INT 22
100202: PUSH
100203: LD_OWVAR 2
100207: PUSH
100208: EMPTY
100209: LIST
100210: LIST
100211: PUSH
100212: LD_INT 32
100214: PUSH
100215: LD_INT 1
100217: PUSH
100218: EMPTY
100219: LIST
100220: LIST
100221: PUSH
100222: LD_INT 21
100224: PUSH
100225: LD_INT 2
100227: PUSH
100228: EMPTY
100229: LIST
100230: LIST
100231: PUSH
100232: EMPTY
100233: LIST
100234: LIST
100235: LIST
100236: PPUSH
100237: CALL_OW 69
100241: ST_TO_ADDR
// if not tmp then
100242: LD_VAR 0 2
100246: NOT
100247: IFFALSE 100251
// exit ;
100249: GO 100280
// for i in tmp do
100251: LD_ADDR_VAR 0 1
100255: PUSH
100256: LD_VAR 0 2
100260: PUSH
100261: FOR_IN
100262: IFFALSE 100278
// SetFuel ( i , 0 ) ;
100264: LD_VAR 0 1
100268: PPUSH
100269: LD_INT 0
100271: PPUSH
100272: CALL_OW 240
100276: GO 100261
100278: POP
100279: POP
// end ;
100280: PPOPN 2
100282: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
100283: LD_EXP 96
100287: PUSH
100288: LD_EXP 132
100292: AND
100293: IFFALSE 100359
100295: GO 100297
100297: DISABLE
100298: LD_INT 0
100300: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
100301: LD_ADDR_VAR 0 1
100305: PUSH
100306: LD_INT 22
100308: PUSH
100309: LD_OWVAR 2
100313: PUSH
100314: EMPTY
100315: LIST
100316: LIST
100317: PUSH
100318: LD_INT 30
100320: PUSH
100321: LD_INT 29
100323: PUSH
100324: EMPTY
100325: LIST
100326: LIST
100327: PUSH
100328: EMPTY
100329: LIST
100330: LIST
100331: PPUSH
100332: CALL_OW 69
100336: ST_TO_ADDR
// if not tmp then
100337: LD_VAR 0 1
100341: NOT
100342: IFFALSE 100346
// exit ;
100344: GO 100359
// DestroyUnit ( tmp [ 1 ] ) ;
100346: LD_VAR 0 1
100350: PUSH
100351: LD_INT 1
100353: ARRAY
100354: PPUSH
100355: CALL_OW 65
// end ;
100359: PPOPN 1
100361: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
100362: LD_EXP 96
100366: PUSH
100367: LD_EXP 134
100371: AND
100372: IFFALSE 100501
100374: GO 100376
100376: DISABLE
100377: LD_INT 0
100379: PPUSH
// begin uc_side := 0 ;
100380: LD_ADDR_OWVAR 20
100384: PUSH
100385: LD_INT 0
100387: ST_TO_ADDR
// uc_nation := nation_arabian ;
100388: LD_ADDR_OWVAR 21
100392: PUSH
100393: LD_INT 2
100395: ST_TO_ADDR
// hc_gallery :=  ;
100396: LD_ADDR_OWVAR 33
100400: PUSH
100401: LD_STRING 
100403: ST_TO_ADDR
// hc_name :=  ;
100404: LD_ADDR_OWVAR 26
100408: PUSH
100409: LD_STRING 
100411: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
100412: LD_INT 1
100414: PPUSH
100415: LD_INT 11
100417: PPUSH
100418: LD_INT 10
100420: PPUSH
100421: CALL_OW 380
// un := CreateHuman ;
100425: LD_ADDR_VAR 0 1
100429: PUSH
100430: CALL_OW 44
100434: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
100435: LD_VAR 0 1
100439: PPUSH
100440: LD_INT 1
100442: PPUSH
100443: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
100447: LD_INT 35
100449: PPUSH
100450: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
100454: LD_VAR 0 1
100458: PPUSH
100459: LD_INT 22
100461: PUSH
100462: LD_OWVAR 2
100466: PUSH
100467: EMPTY
100468: LIST
100469: LIST
100470: PPUSH
100471: CALL_OW 69
100475: PPUSH
100476: LD_VAR 0 1
100480: PPUSH
100481: CALL_OW 74
100485: PPUSH
100486: CALL_OW 115
// until IsDead ( un ) ;
100490: LD_VAR 0 1
100494: PPUSH
100495: CALL_OW 301
100499: IFFALSE 100447
// end ;
100501: PPOPN 1
100503: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
100504: LD_EXP 96
100508: PUSH
100509: LD_EXP 136
100513: AND
100514: IFFALSE 100526
100516: GO 100518
100518: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
100519: LD_STRING earthquake(getX(game), 0, 32)
100521: PPUSH
100522: CALL_OW 559
100526: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
100527: LD_EXP 96
100531: PUSH
100532: LD_EXP 137
100536: AND
100537: IFFALSE 100628
100539: GO 100541
100541: DISABLE
100542: LD_INT 0
100544: PPUSH
// begin enable ;
100545: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
100546: LD_ADDR_VAR 0 1
100550: PUSH
100551: LD_INT 22
100553: PUSH
100554: LD_OWVAR 2
100558: PUSH
100559: EMPTY
100560: LIST
100561: LIST
100562: PUSH
100563: LD_INT 21
100565: PUSH
100566: LD_INT 2
100568: PUSH
100569: EMPTY
100570: LIST
100571: LIST
100572: PUSH
100573: LD_INT 33
100575: PUSH
100576: LD_INT 3
100578: PUSH
100579: EMPTY
100580: LIST
100581: LIST
100582: PUSH
100583: EMPTY
100584: LIST
100585: LIST
100586: LIST
100587: PPUSH
100588: CALL_OW 69
100592: ST_TO_ADDR
// if not tmp then
100593: LD_VAR 0 1
100597: NOT
100598: IFFALSE 100602
// exit ;
100600: GO 100628
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
100602: LD_VAR 0 1
100606: PUSH
100607: LD_INT 1
100609: PPUSH
100610: LD_VAR 0 1
100614: PPUSH
100615: CALL_OW 12
100619: ARRAY
100620: PPUSH
100621: LD_INT 1
100623: PPUSH
100624: CALL_OW 234
// end ;
100628: PPOPN 1
100630: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
100631: LD_EXP 96
100635: PUSH
100636: LD_EXP 138
100640: AND
100641: IFFALSE 100782
100643: GO 100645
100645: DISABLE
100646: LD_INT 0
100648: PPUSH
100649: PPUSH
100650: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
100651: LD_ADDR_VAR 0 3
100655: PUSH
100656: LD_INT 22
100658: PUSH
100659: LD_OWVAR 2
100663: PUSH
100664: EMPTY
100665: LIST
100666: LIST
100667: PUSH
100668: LD_INT 25
100670: PUSH
100671: LD_INT 1
100673: PUSH
100674: EMPTY
100675: LIST
100676: LIST
100677: PUSH
100678: EMPTY
100679: LIST
100680: LIST
100681: PPUSH
100682: CALL_OW 69
100686: ST_TO_ADDR
// if not tmp then
100687: LD_VAR 0 3
100691: NOT
100692: IFFALSE 100696
// exit ;
100694: GO 100782
// un := tmp [ rand ( 1 , tmp ) ] ;
100696: LD_ADDR_VAR 0 2
100700: PUSH
100701: LD_VAR 0 3
100705: PUSH
100706: LD_INT 1
100708: PPUSH
100709: LD_VAR 0 3
100713: PPUSH
100714: CALL_OW 12
100718: ARRAY
100719: ST_TO_ADDR
// if Crawls ( un ) then
100720: LD_VAR 0 2
100724: PPUSH
100725: CALL_OW 318
100729: IFFALSE 100740
// ComWalk ( un ) ;
100731: LD_VAR 0 2
100735: PPUSH
100736: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
100740: LD_VAR 0 2
100744: PPUSH
100745: LD_INT 9
100747: PPUSH
100748: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
100752: LD_INT 28
100754: PPUSH
100755: LD_OWVAR 2
100759: PPUSH
100760: LD_INT 2
100762: PPUSH
100763: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
100767: LD_INT 29
100769: PPUSH
100770: LD_OWVAR 2
100774: PPUSH
100775: LD_INT 2
100777: PPUSH
100778: CALL_OW 322
// end ;
100782: PPOPN 3
100784: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
100785: LD_EXP 96
100789: PUSH
100790: LD_EXP 139
100794: AND
100795: IFFALSE 100906
100797: GO 100799
100799: DISABLE
100800: LD_INT 0
100802: PPUSH
100803: PPUSH
100804: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
100805: LD_ADDR_VAR 0 3
100809: PUSH
100810: LD_INT 22
100812: PUSH
100813: LD_OWVAR 2
100817: PUSH
100818: EMPTY
100819: LIST
100820: LIST
100821: PUSH
100822: LD_INT 25
100824: PUSH
100825: LD_INT 1
100827: PUSH
100828: EMPTY
100829: LIST
100830: LIST
100831: PUSH
100832: EMPTY
100833: LIST
100834: LIST
100835: PPUSH
100836: CALL_OW 69
100840: ST_TO_ADDR
// if not tmp then
100841: LD_VAR 0 3
100845: NOT
100846: IFFALSE 100850
// exit ;
100848: GO 100906
// un := tmp [ rand ( 1 , tmp ) ] ;
100850: LD_ADDR_VAR 0 2
100854: PUSH
100855: LD_VAR 0 3
100859: PUSH
100860: LD_INT 1
100862: PPUSH
100863: LD_VAR 0 3
100867: PPUSH
100868: CALL_OW 12
100872: ARRAY
100873: ST_TO_ADDR
// if Crawls ( un ) then
100874: LD_VAR 0 2
100878: PPUSH
100879: CALL_OW 318
100883: IFFALSE 100894
// ComWalk ( un ) ;
100885: LD_VAR 0 2
100889: PPUSH
100890: CALL_OW 138
// SetClass ( un , class_mortar ) ;
100894: LD_VAR 0 2
100898: PPUSH
100899: LD_INT 8
100901: PPUSH
100902: CALL_OW 336
// end ;
100906: PPOPN 3
100908: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
100909: LD_EXP 96
100913: PUSH
100914: LD_EXP 140
100918: AND
100919: IFFALSE 101063
100921: GO 100923
100923: DISABLE
100924: LD_INT 0
100926: PPUSH
100927: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
100928: LD_ADDR_VAR 0 2
100932: PUSH
100933: LD_INT 22
100935: PUSH
100936: LD_OWVAR 2
100940: PUSH
100941: EMPTY
100942: LIST
100943: LIST
100944: PUSH
100945: LD_INT 21
100947: PUSH
100948: LD_INT 2
100950: PUSH
100951: EMPTY
100952: LIST
100953: LIST
100954: PUSH
100955: LD_INT 2
100957: PUSH
100958: LD_INT 34
100960: PUSH
100961: LD_INT 12
100963: PUSH
100964: EMPTY
100965: LIST
100966: LIST
100967: PUSH
100968: LD_INT 34
100970: PUSH
100971: LD_INT 51
100973: PUSH
100974: EMPTY
100975: LIST
100976: LIST
100977: PUSH
100978: LD_INT 34
100980: PUSH
100981: LD_INT 32
100983: PUSH
100984: EMPTY
100985: LIST
100986: LIST
100987: PUSH
100988: EMPTY
100989: LIST
100990: LIST
100991: LIST
100992: LIST
100993: PUSH
100994: EMPTY
100995: LIST
100996: LIST
100997: LIST
100998: PPUSH
100999: CALL_OW 69
101003: ST_TO_ADDR
// if not tmp then
101004: LD_VAR 0 2
101008: NOT
101009: IFFALSE 101013
// exit ;
101011: GO 101063
// for i in tmp do
101013: LD_ADDR_VAR 0 1
101017: PUSH
101018: LD_VAR 0 2
101022: PUSH
101023: FOR_IN
101024: IFFALSE 101061
// if GetCargo ( i , mat_artifact ) = 0 then
101026: LD_VAR 0 1
101030: PPUSH
101031: LD_INT 4
101033: PPUSH
101034: CALL_OW 289
101038: PUSH
101039: LD_INT 0
101041: EQUAL
101042: IFFALSE 101059
// SetCargo ( i , mat_siberit , 100 ) ;
101044: LD_VAR 0 1
101048: PPUSH
101049: LD_INT 3
101051: PPUSH
101052: LD_INT 100
101054: PPUSH
101055: CALL_OW 290
101059: GO 101023
101061: POP
101062: POP
// end ;
101063: PPOPN 2
101065: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
101066: LD_EXP 96
101070: PUSH
101071: LD_EXP 141
101075: AND
101076: IFFALSE 101259
101078: GO 101080
101080: DISABLE
101081: LD_INT 0
101083: PPUSH
101084: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
101085: LD_ADDR_VAR 0 2
101089: PUSH
101090: LD_INT 22
101092: PUSH
101093: LD_OWVAR 2
101097: PUSH
101098: EMPTY
101099: LIST
101100: LIST
101101: PPUSH
101102: CALL_OW 69
101106: ST_TO_ADDR
// if not tmp then
101107: LD_VAR 0 2
101111: NOT
101112: IFFALSE 101116
// exit ;
101114: GO 101259
// for i := 1 to 2 do
101116: LD_ADDR_VAR 0 1
101120: PUSH
101121: DOUBLE
101122: LD_INT 1
101124: DEC
101125: ST_TO_ADDR
101126: LD_INT 2
101128: PUSH
101129: FOR_TO
101130: IFFALSE 101257
// begin uc_side := your_side ;
101132: LD_ADDR_OWVAR 20
101136: PUSH
101137: LD_OWVAR 2
101141: ST_TO_ADDR
// uc_nation := nation_american ;
101142: LD_ADDR_OWVAR 21
101146: PUSH
101147: LD_INT 1
101149: ST_TO_ADDR
// vc_chassis := us_morphling ;
101150: LD_ADDR_OWVAR 37
101154: PUSH
101155: LD_INT 5
101157: ST_TO_ADDR
// vc_engine := engine_siberite ;
101158: LD_ADDR_OWVAR 39
101162: PUSH
101163: LD_INT 3
101165: ST_TO_ADDR
// vc_control := control_computer ;
101166: LD_ADDR_OWVAR 38
101170: PUSH
101171: LD_INT 3
101173: ST_TO_ADDR
// vc_weapon := us_double_laser ;
101174: LD_ADDR_OWVAR 40
101178: PUSH
101179: LD_INT 10
101181: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
101182: LD_VAR 0 2
101186: PUSH
101187: LD_INT 1
101189: ARRAY
101190: PPUSH
101191: CALL_OW 310
101195: NOT
101196: IFFALSE 101243
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
101198: CALL_OW 45
101202: PPUSH
101203: LD_VAR 0 2
101207: PUSH
101208: LD_INT 1
101210: ARRAY
101211: PPUSH
101212: CALL_OW 250
101216: PPUSH
101217: LD_VAR 0 2
101221: PUSH
101222: LD_INT 1
101224: ARRAY
101225: PPUSH
101226: CALL_OW 251
101230: PPUSH
101231: LD_INT 12
101233: PPUSH
101234: LD_INT 1
101236: PPUSH
101237: CALL_OW 50
101241: GO 101255
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
101243: CALL_OW 45
101247: PPUSH
101248: LD_INT 1
101250: PPUSH
101251: CALL_OW 51
// end ;
101255: GO 101129
101257: POP
101258: POP
// end ;
101259: PPOPN 2
101261: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
101262: LD_EXP 96
101266: PUSH
101267: LD_EXP 142
101271: AND
101272: IFFALSE 101494
101274: GO 101276
101276: DISABLE
101277: LD_INT 0
101279: PPUSH
101280: PPUSH
101281: PPUSH
101282: PPUSH
101283: PPUSH
101284: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
101285: LD_ADDR_VAR 0 6
101289: PUSH
101290: LD_INT 22
101292: PUSH
101293: LD_OWVAR 2
101297: PUSH
101298: EMPTY
101299: LIST
101300: LIST
101301: PUSH
101302: LD_INT 21
101304: PUSH
101305: LD_INT 1
101307: PUSH
101308: EMPTY
101309: LIST
101310: LIST
101311: PUSH
101312: LD_INT 3
101314: PUSH
101315: LD_INT 23
101317: PUSH
101318: LD_INT 0
101320: PUSH
101321: EMPTY
101322: LIST
101323: LIST
101324: PUSH
101325: EMPTY
101326: LIST
101327: LIST
101328: PUSH
101329: EMPTY
101330: LIST
101331: LIST
101332: LIST
101333: PPUSH
101334: CALL_OW 69
101338: ST_TO_ADDR
// if not tmp then
101339: LD_VAR 0 6
101343: NOT
101344: IFFALSE 101348
// exit ;
101346: GO 101494
// s1 := rand ( 1 , 4 ) ;
101348: LD_ADDR_VAR 0 2
101352: PUSH
101353: LD_INT 1
101355: PPUSH
101356: LD_INT 4
101358: PPUSH
101359: CALL_OW 12
101363: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
101364: LD_ADDR_VAR 0 4
101368: PUSH
101369: LD_VAR 0 6
101373: PUSH
101374: LD_INT 1
101376: ARRAY
101377: PPUSH
101378: LD_VAR 0 2
101382: PPUSH
101383: CALL_OW 259
101387: ST_TO_ADDR
// if s1 = 1 then
101388: LD_VAR 0 2
101392: PUSH
101393: LD_INT 1
101395: EQUAL
101396: IFFALSE 101416
// s2 := rand ( 2 , 4 ) else
101398: LD_ADDR_VAR 0 3
101402: PUSH
101403: LD_INT 2
101405: PPUSH
101406: LD_INT 4
101408: PPUSH
101409: CALL_OW 12
101413: ST_TO_ADDR
101414: GO 101424
// s2 := 1 ;
101416: LD_ADDR_VAR 0 3
101420: PUSH
101421: LD_INT 1
101423: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
101424: LD_ADDR_VAR 0 5
101428: PUSH
101429: LD_VAR 0 6
101433: PUSH
101434: LD_INT 1
101436: ARRAY
101437: PPUSH
101438: LD_VAR 0 3
101442: PPUSH
101443: CALL_OW 259
101447: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
101448: LD_VAR 0 6
101452: PUSH
101453: LD_INT 1
101455: ARRAY
101456: PPUSH
101457: LD_VAR 0 2
101461: PPUSH
101462: LD_VAR 0 5
101466: PPUSH
101467: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
101471: LD_VAR 0 6
101475: PUSH
101476: LD_INT 1
101478: ARRAY
101479: PPUSH
101480: LD_VAR 0 3
101484: PPUSH
101485: LD_VAR 0 4
101489: PPUSH
101490: CALL_OW 237
// end ;
101494: PPOPN 6
101496: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
101497: LD_EXP 96
101501: PUSH
101502: LD_EXP 143
101506: AND
101507: IFFALSE 101586
101509: GO 101511
101511: DISABLE
101512: LD_INT 0
101514: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
101515: LD_ADDR_VAR 0 1
101519: PUSH
101520: LD_INT 22
101522: PUSH
101523: LD_OWVAR 2
101527: PUSH
101528: EMPTY
101529: LIST
101530: LIST
101531: PUSH
101532: LD_INT 30
101534: PUSH
101535: LD_INT 3
101537: PUSH
101538: EMPTY
101539: LIST
101540: LIST
101541: PUSH
101542: EMPTY
101543: LIST
101544: LIST
101545: PPUSH
101546: CALL_OW 69
101550: ST_TO_ADDR
// if not tmp then
101551: LD_VAR 0 1
101555: NOT
101556: IFFALSE 101560
// exit ;
101558: GO 101586
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
101560: LD_VAR 0 1
101564: PUSH
101565: LD_INT 1
101567: PPUSH
101568: LD_VAR 0 1
101572: PPUSH
101573: CALL_OW 12
101577: ARRAY
101578: PPUSH
101579: LD_INT 1
101581: PPUSH
101582: CALL_OW 234
// end ;
101586: PPOPN 1
101588: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
101589: LD_EXP 96
101593: PUSH
101594: LD_EXP 144
101598: AND
101599: IFFALSE 101711
101601: GO 101603
101603: DISABLE
101604: LD_INT 0
101606: PPUSH
101607: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
101608: LD_ADDR_VAR 0 2
101612: PUSH
101613: LD_INT 22
101615: PUSH
101616: LD_OWVAR 2
101620: PUSH
101621: EMPTY
101622: LIST
101623: LIST
101624: PUSH
101625: LD_INT 2
101627: PUSH
101628: LD_INT 30
101630: PUSH
101631: LD_INT 27
101633: PUSH
101634: EMPTY
101635: LIST
101636: LIST
101637: PUSH
101638: LD_INT 30
101640: PUSH
101641: LD_INT 26
101643: PUSH
101644: EMPTY
101645: LIST
101646: LIST
101647: PUSH
101648: LD_INT 30
101650: PUSH
101651: LD_INT 28
101653: PUSH
101654: EMPTY
101655: LIST
101656: LIST
101657: PUSH
101658: EMPTY
101659: LIST
101660: LIST
101661: LIST
101662: LIST
101663: PUSH
101664: EMPTY
101665: LIST
101666: LIST
101667: PPUSH
101668: CALL_OW 69
101672: ST_TO_ADDR
// if not tmp then
101673: LD_VAR 0 2
101677: NOT
101678: IFFALSE 101682
// exit ;
101680: GO 101711
// for i in tmp do
101682: LD_ADDR_VAR 0 1
101686: PUSH
101687: LD_VAR 0 2
101691: PUSH
101692: FOR_IN
101693: IFFALSE 101709
// SetLives ( i , 1 ) ;
101695: LD_VAR 0 1
101699: PPUSH
101700: LD_INT 1
101702: PPUSH
101703: CALL_OW 234
101707: GO 101692
101709: POP
101710: POP
// end ;
101711: PPOPN 2
101713: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
101714: LD_EXP 96
101718: PUSH
101719: LD_EXP 145
101723: AND
101724: IFFALSE 102011
101726: GO 101728
101728: DISABLE
101729: LD_INT 0
101731: PPUSH
101732: PPUSH
101733: PPUSH
// begin i := rand ( 1 , 7 ) ;
101734: LD_ADDR_VAR 0 1
101738: PUSH
101739: LD_INT 1
101741: PPUSH
101742: LD_INT 7
101744: PPUSH
101745: CALL_OW 12
101749: ST_TO_ADDR
// case i of 1 :
101750: LD_VAR 0 1
101754: PUSH
101755: LD_INT 1
101757: DOUBLE
101758: EQUAL
101759: IFTRUE 101763
101761: GO 101773
101763: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
101764: LD_STRING earthquake(getX(game), 0, 32)
101766: PPUSH
101767: CALL_OW 559
101771: GO 102011
101773: LD_INT 2
101775: DOUBLE
101776: EQUAL
101777: IFTRUE 101781
101779: GO 101795
101781: POP
// begin ToLua ( displayStucuk(); ) ;
101782: LD_STRING displayStucuk();
101784: PPUSH
101785: CALL_OW 559
// ResetFog ;
101789: CALL_OW 335
// end ; 3 :
101793: GO 102011
101795: LD_INT 3
101797: DOUBLE
101798: EQUAL
101799: IFTRUE 101803
101801: GO 101907
101803: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
101804: LD_ADDR_VAR 0 2
101808: PUSH
101809: LD_INT 22
101811: PUSH
101812: LD_OWVAR 2
101816: PUSH
101817: EMPTY
101818: LIST
101819: LIST
101820: PUSH
101821: LD_INT 25
101823: PUSH
101824: LD_INT 1
101826: PUSH
101827: EMPTY
101828: LIST
101829: LIST
101830: PUSH
101831: EMPTY
101832: LIST
101833: LIST
101834: PPUSH
101835: CALL_OW 69
101839: ST_TO_ADDR
// if not tmp then
101840: LD_VAR 0 2
101844: NOT
101845: IFFALSE 101849
// exit ;
101847: GO 102011
// un := tmp [ rand ( 1 , tmp ) ] ;
101849: LD_ADDR_VAR 0 3
101853: PUSH
101854: LD_VAR 0 2
101858: PUSH
101859: LD_INT 1
101861: PPUSH
101862: LD_VAR 0 2
101866: PPUSH
101867: CALL_OW 12
101871: ARRAY
101872: ST_TO_ADDR
// if Crawls ( un ) then
101873: LD_VAR 0 3
101877: PPUSH
101878: CALL_OW 318
101882: IFFALSE 101893
// ComWalk ( un ) ;
101884: LD_VAR 0 3
101888: PPUSH
101889: CALL_OW 138
// SetClass ( un , class_mortar ) ;
101893: LD_VAR 0 3
101897: PPUSH
101898: LD_INT 8
101900: PPUSH
101901: CALL_OW 336
// end ; 4 :
101905: GO 102011
101907: LD_INT 4
101909: DOUBLE
101910: EQUAL
101911: IFTRUE 101915
101913: GO 101989
101915: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
101916: LD_ADDR_VAR 0 2
101920: PUSH
101921: LD_INT 22
101923: PUSH
101924: LD_OWVAR 2
101928: PUSH
101929: EMPTY
101930: LIST
101931: LIST
101932: PUSH
101933: LD_INT 30
101935: PUSH
101936: LD_INT 29
101938: PUSH
101939: EMPTY
101940: LIST
101941: LIST
101942: PUSH
101943: EMPTY
101944: LIST
101945: LIST
101946: PPUSH
101947: CALL_OW 69
101951: ST_TO_ADDR
// if not tmp then
101952: LD_VAR 0 2
101956: NOT
101957: IFFALSE 101961
// exit ;
101959: GO 102011
// CenterNowOnUnits ( tmp [ 1 ] ) ;
101961: LD_VAR 0 2
101965: PUSH
101966: LD_INT 1
101968: ARRAY
101969: PPUSH
101970: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
101974: LD_VAR 0 2
101978: PUSH
101979: LD_INT 1
101981: ARRAY
101982: PPUSH
101983: CALL_OW 65
// end ; 5 .. 7 :
101987: GO 102011
101989: LD_INT 5
101991: DOUBLE
101992: GREATEREQUAL
101993: IFFALSE 102001
101995: LD_INT 7
101997: DOUBLE
101998: LESSEQUAL
101999: IFTRUE 102003
102001: GO 102010
102003: POP
// StreamSibBomb ; end ;
102004: CALL 98248 0 0
102008: GO 102011
102010: POP
// end ;
102011: PPOPN 3
102013: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
102014: LD_EXP 96
102018: PUSH
102019: LD_EXP 146
102023: AND
102024: IFFALSE 102180
102026: GO 102028
102028: DISABLE
102029: LD_INT 0
102031: PPUSH
102032: PPUSH
102033: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
102034: LD_ADDR_VAR 0 2
102038: PUSH
102039: LD_INT 81
102041: PUSH
102042: LD_OWVAR 2
102046: PUSH
102047: EMPTY
102048: LIST
102049: LIST
102050: PUSH
102051: LD_INT 2
102053: PUSH
102054: LD_INT 21
102056: PUSH
102057: LD_INT 1
102059: PUSH
102060: EMPTY
102061: LIST
102062: LIST
102063: PUSH
102064: LD_INT 21
102066: PUSH
102067: LD_INT 2
102069: PUSH
102070: EMPTY
102071: LIST
102072: LIST
102073: PUSH
102074: EMPTY
102075: LIST
102076: LIST
102077: LIST
102078: PUSH
102079: EMPTY
102080: LIST
102081: LIST
102082: PPUSH
102083: CALL_OW 69
102087: ST_TO_ADDR
// if not tmp then
102088: LD_VAR 0 2
102092: NOT
102093: IFFALSE 102097
// exit ;
102095: GO 102180
// p := 0 ;
102097: LD_ADDR_VAR 0 3
102101: PUSH
102102: LD_INT 0
102104: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
102105: LD_INT 35
102107: PPUSH
102108: CALL_OW 67
// p := p + 1 ;
102112: LD_ADDR_VAR 0 3
102116: PUSH
102117: LD_VAR 0 3
102121: PUSH
102122: LD_INT 1
102124: PLUS
102125: ST_TO_ADDR
// for i in tmp do
102126: LD_ADDR_VAR 0 1
102130: PUSH
102131: LD_VAR 0 2
102135: PUSH
102136: FOR_IN
102137: IFFALSE 102168
// if GetLives ( i ) < 1000 then
102139: LD_VAR 0 1
102143: PPUSH
102144: CALL_OW 256
102148: PUSH
102149: LD_INT 1000
102151: LESS
102152: IFFALSE 102166
// SetLives ( i , 1000 ) ;
102154: LD_VAR 0 1
102158: PPUSH
102159: LD_INT 1000
102161: PPUSH
102162: CALL_OW 234
102166: GO 102136
102168: POP
102169: POP
// until p > 20 ;
102170: LD_VAR 0 3
102174: PUSH
102175: LD_INT 20
102177: GREATER
102178: IFFALSE 102105
// end ;
102180: PPOPN 3
102182: END
// every 0 0$1 trigger StreamModeActive and sTime do
102183: LD_EXP 96
102187: PUSH
102188: LD_EXP 147
102192: AND
102193: IFFALSE 102228
102195: GO 102197
102197: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
102198: LD_INT 28
102200: PPUSH
102201: LD_OWVAR 2
102205: PPUSH
102206: LD_INT 2
102208: PPUSH
102209: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
102213: LD_INT 30
102215: PPUSH
102216: LD_OWVAR 2
102220: PPUSH
102221: LD_INT 2
102223: PPUSH
102224: CALL_OW 322
// end ;
102228: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
102229: LD_EXP 96
102233: PUSH
102234: LD_EXP 148
102238: AND
102239: IFFALSE 102360
102241: GO 102243
102243: DISABLE
102244: LD_INT 0
102246: PPUSH
102247: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
102248: LD_ADDR_VAR 0 2
102252: PUSH
102253: LD_INT 22
102255: PUSH
102256: LD_OWVAR 2
102260: PUSH
102261: EMPTY
102262: LIST
102263: LIST
102264: PUSH
102265: LD_INT 21
102267: PUSH
102268: LD_INT 1
102270: PUSH
102271: EMPTY
102272: LIST
102273: LIST
102274: PUSH
102275: LD_INT 3
102277: PUSH
102278: LD_INT 23
102280: PUSH
102281: LD_INT 0
102283: PUSH
102284: EMPTY
102285: LIST
102286: LIST
102287: PUSH
102288: EMPTY
102289: LIST
102290: LIST
102291: PUSH
102292: EMPTY
102293: LIST
102294: LIST
102295: LIST
102296: PPUSH
102297: CALL_OW 69
102301: ST_TO_ADDR
// if not tmp then
102302: LD_VAR 0 2
102306: NOT
102307: IFFALSE 102311
// exit ;
102309: GO 102360
// for i in tmp do
102311: LD_ADDR_VAR 0 1
102315: PUSH
102316: LD_VAR 0 2
102320: PUSH
102321: FOR_IN
102322: IFFALSE 102358
// begin if Crawls ( i ) then
102324: LD_VAR 0 1
102328: PPUSH
102329: CALL_OW 318
102333: IFFALSE 102344
// ComWalk ( i ) ;
102335: LD_VAR 0 1
102339: PPUSH
102340: CALL_OW 138
// SetClass ( i , 2 ) ;
102344: LD_VAR 0 1
102348: PPUSH
102349: LD_INT 2
102351: PPUSH
102352: CALL_OW 336
// end ;
102356: GO 102321
102358: POP
102359: POP
// end ;
102360: PPOPN 2
102362: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
102363: LD_EXP 96
102367: PUSH
102368: LD_EXP 149
102372: AND
102373: IFFALSE 102661
102375: GO 102377
102377: DISABLE
102378: LD_INT 0
102380: PPUSH
102381: PPUSH
102382: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
102383: LD_OWVAR 2
102387: PPUSH
102388: LD_INT 9
102390: PPUSH
102391: LD_INT 1
102393: PPUSH
102394: LD_INT 1
102396: PPUSH
102397: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
102401: LD_INT 9
102403: PPUSH
102404: LD_OWVAR 2
102408: PPUSH
102409: CALL_OW 343
// uc_side := 9 ;
102413: LD_ADDR_OWVAR 20
102417: PUSH
102418: LD_INT 9
102420: ST_TO_ADDR
// uc_nation := 2 ;
102421: LD_ADDR_OWVAR 21
102425: PUSH
102426: LD_INT 2
102428: ST_TO_ADDR
// hc_name := Dark Warrior ;
102429: LD_ADDR_OWVAR 26
102433: PUSH
102434: LD_STRING Dark Warrior
102436: ST_TO_ADDR
// hc_gallery :=  ;
102437: LD_ADDR_OWVAR 33
102441: PUSH
102442: LD_STRING 
102444: ST_TO_ADDR
// hc_noskilllimit := true ;
102445: LD_ADDR_OWVAR 76
102449: PUSH
102450: LD_INT 1
102452: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
102453: LD_ADDR_OWVAR 31
102457: PUSH
102458: LD_INT 30
102460: PUSH
102461: LD_INT 30
102463: PUSH
102464: LD_INT 30
102466: PUSH
102467: LD_INT 30
102469: PUSH
102470: EMPTY
102471: LIST
102472: LIST
102473: LIST
102474: LIST
102475: ST_TO_ADDR
// un := CreateHuman ;
102476: LD_ADDR_VAR 0 3
102480: PUSH
102481: CALL_OW 44
102485: ST_TO_ADDR
// hc_noskilllimit := false ;
102486: LD_ADDR_OWVAR 76
102490: PUSH
102491: LD_INT 0
102493: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
102494: LD_VAR 0 3
102498: PPUSH
102499: LD_INT 1
102501: PPUSH
102502: CALL_OW 51
// ToLua ( playRanger() ) ;
102506: LD_STRING playRanger()
102508: PPUSH
102509: CALL_OW 559
// p := 0 ;
102513: LD_ADDR_VAR 0 2
102517: PUSH
102518: LD_INT 0
102520: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
102521: LD_INT 35
102523: PPUSH
102524: CALL_OW 67
// p := p + 1 ;
102528: LD_ADDR_VAR 0 2
102532: PUSH
102533: LD_VAR 0 2
102537: PUSH
102538: LD_INT 1
102540: PLUS
102541: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
102542: LD_VAR 0 3
102546: PPUSH
102547: CALL_OW 256
102551: PUSH
102552: LD_INT 1000
102554: LESS
102555: IFFALSE 102569
// SetLives ( un , 1000 ) ;
102557: LD_VAR 0 3
102561: PPUSH
102562: LD_INT 1000
102564: PPUSH
102565: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
102569: LD_VAR 0 3
102573: PPUSH
102574: LD_INT 81
102576: PUSH
102577: LD_OWVAR 2
102581: PUSH
102582: EMPTY
102583: LIST
102584: LIST
102585: PUSH
102586: LD_INT 91
102588: PUSH
102589: LD_VAR 0 3
102593: PUSH
102594: LD_INT 30
102596: PUSH
102597: EMPTY
102598: LIST
102599: LIST
102600: LIST
102601: PUSH
102602: EMPTY
102603: LIST
102604: LIST
102605: PPUSH
102606: CALL_OW 69
102610: PPUSH
102611: LD_VAR 0 3
102615: PPUSH
102616: CALL_OW 74
102620: PPUSH
102621: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
102625: LD_VAR 0 2
102629: PUSH
102630: LD_INT 80
102632: GREATER
102633: PUSH
102634: LD_VAR 0 3
102638: PPUSH
102639: CALL_OW 301
102643: OR
102644: IFFALSE 102521
// if un then
102646: LD_VAR 0 3
102650: IFFALSE 102661
// RemoveUnit ( un ) ;
102652: LD_VAR 0 3
102656: PPUSH
102657: CALL_OW 64
// end ;
102661: PPOPN 3
102663: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
102664: LD_EXP 150
102668: IFFALSE 102784
102670: GO 102672
102672: DISABLE
102673: LD_INT 0
102675: PPUSH
102676: PPUSH
102677: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
102678: LD_ADDR_VAR 0 2
102682: PUSH
102683: LD_INT 81
102685: PUSH
102686: LD_OWVAR 2
102690: PUSH
102691: EMPTY
102692: LIST
102693: LIST
102694: PUSH
102695: LD_INT 21
102697: PUSH
102698: LD_INT 1
102700: PUSH
102701: EMPTY
102702: LIST
102703: LIST
102704: PUSH
102705: EMPTY
102706: LIST
102707: LIST
102708: PPUSH
102709: CALL_OW 69
102713: ST_TO_ADDR
// ToLua ( playComputer() ) ;
102714: LD_STRING playComputer()
102716: PPUSH
102717: CALL_OW 559
// if not tmp then
102721: LD_VAR 0 2
102725: NOT
102726: IFFALSE 102730
// exit ;
102728: GO 102784
// for i in tmp do
102730: LD_ADDR_VAR 0 1
102734: PUSH
102735: LD_VAR 0 2
102739: PUSH
102740: FOR_IN
102741: IFFALSE 102782
// for j := 1 to 4 do
102743: LD_ADDR_VAR 0 3
102747: PUSH
102748: DOUBLE
102749: LD_INT 1
102751: DEC
102752: ST_TO_ADDR
102753: LD_INT 4
102755: PUSH
102756: FOR_TO
102757: IFFALSE 102778
// SetSkill ( i , j , 10 ) ;
102759: LD_VAR 0 1
102763: PPUSH
102764: LD_VAR 0 3
102768: PPUSH
102769: LD_INT 10
102771: PPUSH
102772: CALL_OW 237
102776: GO 102756
102778: POP
102779: POP
102780: GO 102740
102782: POP
102783: POP
// end ;
102784: PPOPN 3
102786: END
// every 0 0$1 trigger s30 do var i , tmp ;
102787: LD_EXP 151
102791: IFFALSE 102860
102793: GO 102795
102795: DISABLE
102796: LD_INT 0
102798: PPUSH
102799: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
102800: LD_ADDR_VAR 0 2
102804: PUSH
102805: LD_INT 22
102807: PUSH
102808: LD_OWVAR 2
102812: PUSH
102813: EMPTY
102814: LIST
102815: LIST
102816: PPUSH
102817: CALL_OW 69
102821: ST_TO_ADDR
// if not tmp then
102822: LD_VAR 0 2
102826: NOT
102827: IFFALSE 102831
// exit ;
102829: GO 102860
// for i in tmp do
102831: LD_ADDR_VAR 0 1
102835: PUSH
102836: LD_VAR 0 2
102840: PUSH
102841: FOR_IN
102842: IFFALSE 102858
// SetLives ( i , 300 ) ;
102844: LD_VAR 0 1
102848: PPUSH
102849: LD_INT 300
102851: PPUSH
102852: CALL_OW 234
102856: GO 102841
102858: POP
102859: POP
// end ;
102860: PPOPN 2
102862: END
// every 0 0$1 trigger s60 do var i , tmp ;
102863: LD_EXP 152
102867: IFFALSE 102936
102869: GO 102871
102871: DISABLE
102872: LD_INT 0
102874: PPUSH
102875: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
102876: LD_ADDR_VAR 0 2
102880: PUSH
102881: LD_INT 22
102883: PUSH
102884: LD_OWVAR 2
102888: PUSH
102889: EMPTY
102890: LIST
102891: LIST
102892: PPUSH
102893: CALL_OW 69
102897: ST_TO_ADDR
// if not tmp then
102898: LD_VAR 0 2
102902: NOT
102903: IFFALSE 102907
// exit ;
102905: GO 102936
// for i in tmp do
102907: LD_ADDR_VAR 0 1
102911: PUSH
102912: LD_VAR 0 2
102916: PUSH
102917: FOR_IN
102918: IFFALSE 102934
// SetLives ( i , 600 ) ;
102920: LD_VAR 0 1
102924: PPUSH
102925: LD_INT 600
102927: PPUSH
102928: CALL_OW 234
102932: GO 102917
102934: POP
102935: POP
// end ;
102936: PPOPN 2
102938: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
102939: LD_INT 0
102941: PPUSH
// case cmd of 301 :
102942: LD_VAR 0 1
102946: PUSH
102947: LD_INT 301
102949: DOUBLE
102950: EQUAL
102951: IFTRUE 102955
102953: GO 102987
102955: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
102956: LD_VAR 0 6
102960: PPUSH
102961: LD_VAR 0 7
102965: PPUSH
102966: LD_VAR 0 8
102970: PPUSH
102971: LD_VAR 0 4
102975: PPUSH
102976: LD_VAR 0 5
102980: PPUSH
102981: CALL 104188 0 5
102985: GO 103108
102987: LD_INT 302
102989: DOUBLE
102990: EQUAL
102991: IFTRUE 102995
102993: GO 103032
102995: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
102996: LD_VAR 0 6
103000: PPUSH
103001: LD_VAR 0 7
103005: PPUSH
103006: LD_VAR 0 8
103010: PPUSH
103011: LD_VAR 0 9
103015: PPUSH
103016: LD_VAR 0 4
103020: PPUSH
103021: LD_VAR 0 5
103025: PPUSH
103026: CALL 104279 0 6
103030: GO 103108
103032: LD_INT 303
103034: DOUBLE
103035: EQUAL
103036: IFTRUE 103040
103038: GO 103077
103040: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
103041: LD_VAR 0 6
103045: PPUSH
103046: LD_VAR 0 7
103050: PPUSH
103051: LD_VAR 0 8
103055: PPUSH
103056: LD_VAR 0 9
103060: PPUSH
103061: LD_VAR 0 4
103065: PPUSH
103066: LD_VAR 0 5
103070: PPUSH
103071: CALL 103113 0 6
103075: GO 103108
103077: LD_INT 304
103079: DOUBLE
103080: EQUAL
103081: IFTRUE 103085
103083: GO 103107
103085: POP
// hHackTeleport ( unit , x , y ) ; end ;
103086: LD_VAR 0 2
103090: PPUSH
103091: LD_VAR 0 4
103095: PPUSH
103096: LD_VAR 0 5
103100: PPUSH
103101: CALL 104872 0 3
103105: GO 103108
103107: POP
// end ;
103108: LD_VAR 0 12
103112: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
103113: LD_INT 0
103115: PPUSH
103116: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
103117: LD_VAR 0 1
103121: PUSH
103122: LD_INT 1
103124: LESS
103125: PUSH
103126: LD_VAR 0 1
103130: PUSH
103131: LD_INT 3
103133: GREATER
103134: OR
103135: PUSH
103136: LD_VAR 0 5
103140: PPUSH
103141: LD_VAR 0 6
103145: PPUSH
103146: CALL_OW 428
103150: OR
103151: IFFALSE 103155
// exit ;
103153: GO 103875
// uc_side := your_side ;
103155: LD_ADDR_OWVAR 20
103159: PUSH
103160: LD_OWVAR 2
103164: ST_TO_ADDR
// uc_nation := nation ;
103165: LD_ADDR_OWVAR 21
103169: PUSH
103170: LD_VAR 0 1
103174: ST_TO_ADDR
// bc_level = 1 ;
103175: LD_ADDR_OWVAR 43
103179: PUSH
103180: LD_INT 1
103182: ST_TO_ADDR
// case btype of 1 :
103183: LD_VAR 0 2
103187: PUSH
103188: LD_INT 1
103190: DOUBLE
103191: EQUAL
103192: IFTRUE 103196
103194: GO 103207
103196: POP
// bc_type := b_depot ; 2 :
103197: LD_ADDR_OWVAR 42
103201: PUSH
103202: LD_INT 0
103204: ST_TO_ADDR
103205: GO 103819
103207: LD_INT 2
103209: DOUBLE
103210: EQUAL
103211: IFTRUE 103215
103213: GO 103226
103215: POP
// bc_type := b_warehouse ; 3 :
103216: LD_ADDR_OWVAR 42
103220: PUSH
103221: LD_INT 1
103223: ST_TO_ADDR
103224: GO 103819
103226: LD_INT 3
103228: DOUBLE
103229: EQUAL
103230: IFTRUE 103234
103232: GO 103245
103234: POP
// bc_type := b_lab ; 4 .. 9 :
103235: LD_ADDR_OWVAR 42
103239: PUSH
103240: LD_INT 6
103242: ST_TO_ADDR
103243: GO 103819
103245: LD_INT 4
103247: DOUBLE
103248: GREATEREQUAL
103249: IFFALSE 103257
103251: LD_INT 9
103253: DOUBLE
103254: LESSEQUAL
103255: IFTRUE 103259
103257: GO 103311
103259: POP
// begin bc_type := b_lab_half ;
103260: LD_ADDR_OWVAR 42
103264: PUSH
103265: LD_INT 7
103267: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
103268: LD_ADDR_OWVAR 44
103272: PUSH
103273: LD_INT 10
103275: PUSH
103276: LD_INT 11
103278: PUSH
103279: LD_INT 12
103281: PUSH
103282: LD_INT 15
103284: PUSH
103285: LD_INT 14
103287: PUSH
103288: LD_INT 13
103290: PUSH
103291: EMPTY
103292: LIST
103293: LIST
103294: LIST
103295: LIST
103296: LIST
103297: LIST
103298: PUSH
103299: LD_VAR 0 2
103303: PUSH
103304: LD_INT 3
103306: MINUS
103307: ARRAY
103308: ST_TO_ADDR
// end ; 10 .. 13 :
103309: GO 103819
103311: LD_INT 10
103313: DOUBLE
103314: GREATEREQUAL
103315: IFFALSE 103323
103317: LD_INT 13
103319: DOUBLE
103320: LESSEQUAL
103321: IFTRUE 103325
103323: GO 103402
103325: POP
// begin bc_type := b_lab_full ;
103326: LD_ADDR_OWVAR 42
103330: PUSH
103331: LD_INT 8
103333: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
103334: LD_ADDR_OWVAR 44
103338: PUSH
103339: LD_INT 10
103341: PUSH
103342: LD_INT 12
103344: PUSH
103345: LD_INT 14
103347: PUSH
103348: LD_INT 13
103350: PUSH
103351: EMPTY
103352: LIST
103353: LIST
103354: LIST
103355: LIST
103356: PUSH
103357: LD_VAR 0 2
103361: PUSH
103362: LD_INT 9
103364: MINUS
103365: ARRAY
103366: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
103367: LD_ADDR_OWVAR 45
103371: PUSH
103372: LD_INT 11
103374: PUSH
103375: LD_INT 15
103377: PUSH
103378: LD_INT 12
103380: PUSH
103381: LD_INT 15
103383: PUSH
103384: EMPTY
103385: LIST
103386: LIST
103387: LIST
103388: LIST
103389: PUSH
103390: LD_VAR 0 2
103394: PUSH
103395: LD_INT 9
103397: MINUS
103398: ARRAY
103399: ST_TO_ADDR
// end ; 14 :
103400: GO 103819
103402: LD_INT 14
103404: DOUBLE
103405: EQUAL
103406: IFTRUE 103410
103408: GO 103421
103410: POP
// bc_type := b_workshop ; 15 :
103411: LD_ADDR_OWVAR 42
103415: PUSH
103416: LD_INT 2
103418: ST_TO_ADDR
103419: GO 103819
103421: LD_INT 15
103423: DOUBLE
103424: EQUAL
103425: IFTRUE 103429
103427: GO 103440
103429: POP
// bc_type := b_factory ; 16 :
103430: LD_ADDR_OWVAR 42
103434: PUSH
103435: LD_INT 3
103437: ST_TO_ADDR
103438: GO 103819
103440: LD_INT 16
103442: DOUBLE
103443: EQUAL
103444: IFTRUE 103448
103446: GO 103459
103448: POP
// bc_type := b_ext_gun ; 17 :
103449: LD_ADDR_OWVAR 42
103453: PUSH
103454: LD_INT 17
103456: ST_TO_ADDR
103457: GO 103819
103459: LD_INT 17
103461: DOUBLE
103462: EQUAL
103463: IFTRUE 103467
103465: GO 103495
103467: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
103468: LD_ADDR_OWVAR 42
103472: PUSH
103473: LD_INT 19
103475: PUSH
103476: LD_INT 23
103478: PUSH
103479: LD_INT 19
103481: PUSH
103482: EMPTY
103483: LIST
103484: LIST
103485: LIST
103486: PUSH
103487: LD_VAR 0 1
103491: ARRAY
103492: ST_TO_ADDR
103493: GO 103819
103495: LD_INT 18
103497: DOUBLE
103498: EQUAL
103499: IFTRUE 103503
103501: GO 103514
103503: POP
// bc_type := b_ext_radar ; 19 :
103504: LD_ADDR_OWVAR 42
103508: PUSH
103509: LD_INT 20
103511: ST_TO_ADDR
103512: GO 103819
103514: LD_INT 19
103516: DOUBLE
103517: EQUAL
103518: IFTRUE 103522
103520: GO 103533
103522: POP
// bc_type := b_ext_radio ; 20 :
103523: LD_ADDR_OWVAR 42
103527: PUSH
103528: LD_INT 22
103530: ST_TO_ADDR
103531: GO 103819
103533: LD_INT 20
103535: DOUBLE
103536: EQUAL
103537: IFTRUE 103541
103539: GO 103552
103541: POP
// bc_type := b_ext_siberium ; 21 :
103542: LD_ADDR_OWVAR 42
103546: PUSH
103547: LD_INT 21
103549: ST_TO_ADDR
103550: GO 103819
103552: LD_INT 21
103554: DOUBLE
103555: EQUAL
103556: IFTRUE 103560
103558: GO 103571
103560: POP
// bc_type := b_ext_computer ; 22 :
103561: LD_ADDR_OWVAR 42
103565: PUSH
103566: LD_INT 24
103568: ST_TO_ADDR
103569: GO 103819
103571: LD_INT 22
103573: DOUBLE
103574: EQUAL
103575: IFTRUE 103579
103577: GO 103590
103579: POP
// bc_type := b_ext_track ; 23 :
103580: LD_ADDR_OWVAR 42
103584: PUSH
103585: LD_INT 16
103587: ST_TO_ADDR
103588: GO 103819
103590: LD_INT 23
103592: DOUBLE
103593: EQUAL
103594: IFTRUE 103598
103596: GO 103609
103598: POP
// bc_type := b_ext_laser ; 24 :
103599: LD_ADDR_OWVAR 42
103603: PUSH
103604: LD_INT 25
103606: ST_TO_ADDR
103607: GO 103819
103609: LD_INT 24
103611: DOUBLE
103612: EQUAL
103613: IFTRUE 103617
103615: GO 103628
103617: POP
// bc_type := b_control_tower ; 25 :
103618: LD_ADDR_OWVAR 42
103622: PUSH
103623: LD_INT 36
103625: ST_TO_ADDR
103626: GO 103819
103628: LD_INT 25
103630: DOUBLE
103631: EQUAL
103632: IFTRUE 103636
103634: GO 103647
103636: POP
// bc_type := b_breastwork ; 26 :
103637: LD_ADDR_OWVAR 42
103641: PUSH
103642: LD_INT 31
103644: ST_TO_ADDR
103645: GO 103819
103647: LD_INT 26
103649: DOUBLE
103650: EQUAL
103651: IFTRUE 103655
103653: GO 103666
103655: POP
// bc_type := b_bunker ; 27 :
103656: LD_ADDR_OWVAR 42
103660: PUSH
103661: LD_INT 32
103663: ST_TO_ADDR
103664: GO 103819
103666: LD_INT 27
103668: DOUBLE
103669: EQUAL
103670: IFTRUE 103674
103672: GO 103685
103674: POP
// bc_type := b_turret ; 28 :
103675: LD_ADDR_OWVAR 42
103679: PUSH
103680: LD_INT 33
103682: ST_TO_ADDR
103683: GO 103819
103685: LD_INT 28
103687: DOUBLE
103688: EQUAL
103689: IFTRUE 103693
103691: GO 103704
103693: POP
// bc_type := b_armoury ; 29 :
103694: LD_ADDR_OWVAR 42
103698: PUSH
103699: LD_INT 4
103701: ST_TO_ADDR
103702: GO 103819
103704: LD_INT 29
103706: DOUBLE
103707: EQUAL
103708: IFTRUE 103712
103710: GO 103723
103712: POP
// bc_type := b_barracks ; 30 :
103713: LD_ADDR_OWVAR 42
103717: PUSH
103718: LD_INT 5
103720: ST_TO_ADDR
103721: GO 103819
103723: LD_INT 30
103725: DOUBLE
103726: EQUAL
103727: IFTRUE 103731
103729: GO 103742
103731: POP
// bc_type := b_solar_power ; 31 :
103732: LD_ADDR_OWVAR 42
103736: PUSH
103737: LD_INT 27
103739: ST_TO_ADDR
103740: GO 103819
103742: LD_INT 31
103744: DOUBLE
103745: EQUAL
103746: IFTRUE 103750
103748: GO 103761
103750: POP
// bc_type := b_oil_power ; 32 :
103751: LD_ADDR_OWVAR 42
103755: PUSH
103756: LD_INT 26
103758: ST_TO_ADDR
103759: GO 103819
103761: LD_INT 32
103763: DOUBLE
103764: EQUAL
103765: IFTRUE 103769
103767: GO 103780
103769: POP
// bc_type := b_siberite_power ; 33 :
103770: LD_ADDR_OWVAR 42
103774: PUSH
103775: LD_INT 28
103777: ST_TO_ADDR
103778: GO 103819
103780: LD_INT 33
103782: DOUBLE
103783: EQUAL
103784: IFTRUE 103788
103786: GO 103799
103788: POP
// bc_type := b_oil_mine ; 34 :
103789: LD_ADDR_OWVAR 42
103793: PUSH
103794: LD_INT 29
103796: ST_TO_ADDR
103797: GO 103819
103799: LD_INT 34
103801: DOUBLE
103802: EQUAL
103803: IFTRUE 103807
103805: GO 103818
103807: POP
// bc_type := b_siberite_mine ; end ;
103808: LD_ADDR_OWVAR 42
103812: PUSH
103813: LD_INT 30
103815: ST_TO_ADDR
103816: GO 103819
103818: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
103819: LD_ADDR_VAR 0 8
103823: PUSH
103824: LD_VAR 0 5
103828: PPUSH
103829: LD_VAR 0 6
103833: PPUSH
103834: LD_VAR 0 3
103838: PPUSH
103839: CALL_OW 47
103843: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
103844: LD_OWVAR 42
103848: PUSH
103849: LD_INT 32
103851: PUSH
103852: LD_INT 33
103854: PUSH
103855: EMPTY
103856: LIST
103857: LIST
103858: IN
103859: IFFALSE 103875
// PlaceWeaponTurret ( b , weapon ) ;
103861: LD_VAR 0 8
103865: PPUSH
103866: LD_VAR 0 4
103870: PPUSH
103871: CALL_OW 431
// end ;
103875: LD_VAR 0 7
103879: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
103880: LD_INT 0
103882: PPUSH
103883: PPUSH
103884: PPUSH
103885: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
103886: LD_ADDR_VAR 0 4
103890: PUSH
103891: LD_INT 22
103893: PUSH
103894: LD_OWVAR 2
103898: PUSH
103899: EMPTY
103900: LIST
103901: LIST
103902: PUSH
103903: LD_INT 2
103905: PUSH
103906: LD_INT 30
103908: PUSH
103909: LD_INT 0
103911: PUSH
103912: EMPTY
103913: LIST
103914: LIST
103915: PUSH
103916: LD_INT 30
103918: PUSH
103919: LD_INT 1
103921: PUSH
103922: EMPTY
103923: LIST
103924: LIST
103925: PUSH
103926: EMPTY
103927: LIST
103928: LIST
103929: LIST
103930: PUSH
103931: EMPTY
103932: LIST
103933: LIST
103934: PPUSH
103935: CALL_OW 69
103939: ST_TO_ADDR
// if not tmp then
103940: LD_VAR 0 4
103944: NOT
103945: IFFALSE 103949
// exit ;
103947: GO 104008
// for i in tmp do
103949: LD_ADDR_VAR 0 2
103953: PUSH
103954: LD_VAR 0 4
103958: PUSH
103959: FOR_IN
103960: IFFALSE 104006
// for j = 1 to 3 do
103962: LD_ADDR_VAR 0 3
103966: PUSH
103967: DOUBLE
103968: LD_INT 1
103970: DEC
103971: ST_TO_ADDR
103972: LD_INT 3
103974: PUSH
103975: FOR_TO
103976: IFFALSE 104002
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
103978: LD_VAR 0 2
103982: PPUSH
103983: CALL_OW 274
103987: PPUSH
103988: LD_VAR 0 3
103992: PPUSH
103993: LD_INT 99999
103995: PPUSH
103996: CALL_OW 277
104000: GO 103975
104002: POP
104003: POP
104004: GO 103959
104006: POP
104007: POP
// end ;
104008: LD_VAR 0 1
104012: RET
// export function hHackSetLevel10 ; var i , j ; begin
104013: LD_INT 0
104015: PPUSH
104016: PPUSH
104017: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
104018: LD_ADDR_VAR 0 2
104022: PUSH
104023: LD_INT 21
104025: PUSH
104026: LD_INT 1
104028: PUSH
104029: EMPTY
104030: LIST
104031: LIST
104032: PPUSH
104033: CALL_OW 69
104037: PUSH
104038: FOR_IN
104039: IFFALSE 104091
// if IsSelected ( i ) then
104041: LD_VAR 0 2
104045: PPUSH
104046: CALL_OW 306
104050: IFFALSE 104089
// begin for j := 1 to 4 do
104052: LD_ADDR_VAR 0 3
104056: PUSH
104057: DOUBLE
104058: LD_INT 1
104060: DEC
104061: ST_TO_ADDR
104062: LD_INT 4
104064: PUSH
104065: FOR_TO
104066: IFFALSE 104087
// SetSkill ( i , j , 10 ) ;
104068: LD_VAR 0 2
104072: PPUSH
104073: LD_VAR 0 3
104077: PPUSH
104078: LD_INT 10
104080: PPUSH
104081: CALL_OW 237
104085: GO 104065
104087: POP
104088: POP
// end ;
104089: GO 104038
104091: POP
104092: POP
// end ;
104093: LD_VAR 0 1
104097: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
104098: LD_INT 0
104100: PPUSH
104101: PPUSH
104102: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
104103: LD_ADDR_VAR 0 2
104107: PUSH
104108: LD_INT 22
104110: PUSH
104111: LD_OWVAR 2
104115: PUSH
104116: EMPTY
104117: LIST
104118: LIST
104119: PUSH
104120: LD_INT 21
104122: PUSH
104123: LD_INT 1
104125: PUSH
104126: EMPTY
104127: LIST
104128: LIST
104129: PUSH
104130: EMPTY
104131: LIST
104132: LIST
104133: PPUSH
104134: CALL_OW 69
104138: PUSH
104139: FOR_IN
104140: IFFALSE 104181
// begin for j := 1 to 4 do
104142: LD_ADDR_VAR 0 3
104146: PUSH
104147: DOUBLE
104148: LD_INT 1
104150: DEC
104151: ST_TO_ADDR
104152: LD_INT 4
104154: PUSH
104155: FOR_TO
104156: IFFALSE 104177
// SetSkill ( i , j , 10 ) ;
104158: LD_VAR 0 2
104162: PPUSH
104163: LD_VAR 0 3
104167: PPUSH
104168: LD_INT 10
104170: PPUSH
104171: CALL_OW 237
104175: GO 104155
104177: POP
104178: POP
// end ;
104179: GO 104139
104181: POP
104182: POP
// end ;
104183: LD_VAR 0 1
104187: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
104188: LD_INT 0
104190: PPUSH
// uc_side := your_side ;
104191: LD_ADDR_OWVAR 20
104195: PUSH
104196: LD_OWVAR 2
104200: ST_TO_ADDR
// uc_nation := nation ;
104201: LD_ADDR_OWVAR 21
104205: PUSH
104206: LD_VAR 0 1
104210: ST_TO_ADDR
// InitHc ;
104211: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
104215: LD_INT 0
104217: PPUSH
104218: LD_VAR 0 2
104222: PPUSH
104223: LD_VAR 0 3
104227: PPUSH
104228: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
104232: LD_VAR 0 4
104236: PPUSH
104237: LD_VAR 0 5
104241: PPUSH
104242: CALL_OW 428
104246: PUSH
104247: LD_INT 0
104249: EQUAL
104250: IFFALSE 104274
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
104252: CALL_OW 44
104256: PPUSH
104257: LD_VAR 0 4
104261: PPUSH
104262: LD_VAR 0 5
104266: PPUSH
104267: LD_INT 1
104269: PPUSH
104270: CALL_OW 48
// end ;
104274: LD_VAR 0 6
104278: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
104279: LD_INT 0
104281: PPUSH
104282: PPUSH
// uc_side := your_side ;
104283: LD_ADDR_OWVAR 20
104287: PUSH
104288: LD_OWVAR 2
104292: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
104293: LD_VAR 0 1
104297: PUSH
104298: LD_INT 1
104300: PUSH
104301: LD_INT 2
104303: PUSH
104304: LD_INT 3
104306: PUSH
104307: LD_INT 4
104309: PUSH
104310: LD_INT 5
104312: PUSH
104313: EMPTY
104314: LIST
104315: LIST
104316: LIST
104317: LIST
104318: LIST
104319: IN
104320: IFFALSE 104332
// uc_nation := nation_american else
104322: LD_ADDR_OWVAR 21
104326: PUSH
104327: LD_INT 1
104329: ST_TO_ADDR
104330: GO 104375
// if chassis in [ 11 , 12 , 13 , 14 ] then
104332: LD_VAR 0 1
104336: PUSH
104337: LD_INT 11
104339: PUSH
104340: LD_INT 12
104342: PUSH
104343: LD_INT 13
104345: PUSH
104346: LD_INT 14
104348: PUSH
104349: EMPTY
104350: LIST
104351: LIST
104352: LIST
104353: LIST
104354: IN
104355: IFFALSE 104367
// uc_nation := nation_arabian else
104357: LD_ADDR_OWVAR 21
104361: PUSH
104362: LD_INT 2
104364: ST_TO_ADDR
104365: GO 104375
// uc_nation := nation_russian ;
104367: LD_ADDR_OWVAR 21
104371: PUSH
104372: LD_INT 3
104374: ST_TO_ADDR
// vc_chassis := chassis ;
104375: LD_ADDR_OWVAR 37
104379: PUSH
104380: LD_VAR 0 1
104384: ST_TO_ADDR
// vc_engine := engine ;
104385: LD_ADDR_OWVAR 39
104389: PUSH
104390: LD_VAR 0 2
104394: ST_TO_ADDR
// vc_control := control ;
104395: LD_ADDR_OWVAR 38
104399: PUSH
104400: LD_VAR 0 3
104404: ST_TO_ADDR
// vc_weapon := weapon ;
104405: LD_ADDR_OWVAR 40
104409: PUSH
104410: LD_VAR 0 4
104414: ST_TO_ADDR
// un := CreateVehicle ;
104415: LD_ADDR_VAR 0 8
104419: PUSH
104420: CALL_OW 45
104424: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
104425: LD_VAR 0 8
104429: PPUSH
104430: LD_INT 0
104432: PPUSH
104433: LD_INT 5
104435: PPUSH
104436: CALL_OW 12
104440: PPUSH
104441: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
104445: LD_VAR 0 8
104449: PPUSH
104450: LD_VAR 0 5
104454: PPUSH
104455: LD_VAR 0 6
104459: PPUSH
104460: LD_INT 1
104462: PPUSH
104463: CALL_OW 48
// end ;
104467: LD_VAR 0 7
104471: RET
// export hInvincible ; every 1 do
104472: GO 104474
104474: DISABLE
// hInvincible := [ ] ;
104475: LD_ADDR_EXP 153
104479: PUSH
104480: EMPTY
104481: ST_TO_ADDR
104482: END
// every 10 do var i ;
104483: GO 104485
104485: DISABLE
104486: LD_INT 0
104488: PPUSH
// begin enable ;
104489: ENABLE
// if not hInvincible then
104490: LD_EXP 153
104494: NOT
104495: IFFALSE 104499
// exit ;
104497: GO 104543
// for i in hInvincible do
104499: LD_ADDR_VAR 0 1
104503: PUSH
104504: LD_EXP 153
104508: PUSH
104509: FOR_IN
104510: IFFALSE 104541
// if GetLives ( i ) < 1000 then
104512: LD_VAR 0 1
104516: PPUSH
104517: CALL_OW 256
104521: PUSH
104522: LD_INT 1000
104524: LESS
104525: IFFALSE 104539
// SetLives ( i , 1000 ) ;
104527: LD_VAR 0 1
104531: PPUSH
104532: LD_INT 1000
104534: PPUSH
104535: CALL_OW 234
104539: GO 104509
104541: POP
104542: POP
// end ;
104543: PPOPN 1
104545: END
// export function hHackInvincible ; var i ; begin
104546: LD_INT 0
104548: PPUSH
104549: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
104550: LD_ADDR_VAR 0 2
104554: PUSH
104555: LD_INT 2
104557: PUSH
104558: LD_INT 21
104560: PUSH
104561: LD_INT 1
104563: PUSH
104564: EMPTY
104565: LIST
104566: LIST
104567: PUSH
104568: LD_INT 21
104570: PUSH
104571: LD_INT 2
104573: PUSH
104574: EMPTY
104575: LIST
104576: LIST
104577: PUSH
104578: EMPTY
104579: LIST
104580: LIST
104581: LIST
104582: PPUSH
104583: CALL_OW 69
104587: PUSH
104588: FOR_IN
104589: IFFALSE 104650
// if IsSelected ( i ) then
104591: LD_VAR 0 2
104595: PPUSH
104596: CALL_OW 306
104600: IFFALSE 104648
// begin if i in hInvincible then
104602: LD_VAR 0 2
104606: PUSH
104607: LD_EXP 153
104611: IN
104612: IFFALSE 104632
// hInvincible := hInvincible diff i else
104614: LD_ADDR_EXP 153
104618: PUSH
104619: LD_EXP 153
104623: PUSH
104624: LD_VAR 0 2
104628: DIFF
104629: ST_TO_ADDR
104630: GO 104648
// hInvincible := hInvincible union i ;
104632: LD_ADDR_EXP 153
104636: PUSH
104637: LD_EXP 153
104641: PUSH
104642: LD_VAR 0 2
104646: UNION
104647: ST_TO_ADDR
// end ;
104648: GO 104588
104650: POP
104651: POP
// end ;
104652: LD_VAR 0 1
104656: RET
// export function hHackInvisible ; var i , j ; begin
104657: LD_INT 0
104659: PPUSH
104660: PPUSH
104661: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
104662: LD_ADDR_VAR 0 2
104666: PUSH
104667: LD_INT 21
104669: PUSH
104670: LD_INT 1
104672: PUSH
104673: EMPTY
104674: LIST
104675: LIST
104676: PPUSH
104677: CALL_OW 69
104681: PUSH
104682: FOR_IN
104683: IFFALSE 104707
// if IsSelected ( i ) then
104685: LD_VAR 0 2
104689: PPUSH
104690: CALL_OW 306
104694: IFFALSE 104705
// ComForceInvisible ( i ) ;
104696: LD_VAR 0 2
104700: PPUSH
104701: CALL_OW 496
104705: GO 104682
104707: POP
104708: POP
// end ;
104709: LD_VAR 0 1
104713: RET
// export function hHackChangeYourSide ; begin
104714: LD_INT 0
104716: PPUSH
// if your_side = 8 then
104717: LD_OWVAR 2
104721: PUSH
104722: LD_INT 8
104724: EQUAL
104725: IFFALSE 104737
// your_side := 0 else
104727: LD_ADDR_OWVAR 2
104731: PUSH
104732: LD_INT 0
104734: ST_TO_ADDR
104735: GO 104751
// your_side := your_side + 1 ;
104737: LD_ADDR_OWVAR 2
104741: PUSH
104742: LD_OWVAR 2
104746: PUSH
104747: LD_INT 1
104749: PLUS
104750: ST_TO_ADDR
// end ;
104751: LD_VAR 0 1
104755: RET
// export function hHackChangeUnitSide ; var i , j ; begin
104756: LD_INT 0
104758: PPUSH
104759: PPUSH
104760: PPUSH
// for i in all_units do
104761: LD_ADDR_VAR 0 2
104765: PUSH
104766: LD_OWVAR 3
104770: PUSH
104771: FOR_IN
104772: IFFALSE 104850
// if IsSelected ( i ) then
104774: LD_VAR 0 2
104778: PPUSH
104779: CALL_OW 306
104783: IFFALSE 104848
// begin j := GetSide ( i ) ;
104785: LD_ADDR_VAR 0 3
104789: PUSH
104790: LD_VAR 0 2
104794: PPUSH
104795: CALL_OW 255
104799: ST_TO_ADDR
// if j = 8 then
104800: LD_VAR 0 3
104804: PUSH
104805: LD_INT 8
104807: EQUAL
104808: IFFALSE 104820
// j := 0 else
104810: LD_ADDR_VAR 0 3
104814: PUSH
104815: LD_INT 0
104817: ST_TO_ADDR
104818: GO 104834
// j := j + 1 ;
104820: LD_ADDR_VAR 0 3
104824: PUSH
104825: LD_VAR 0 3
104829: PUSH
104830: LD_INT 1
104832: PLUS
104833: ST_TO_ADDR
// SetSide ( i , j ) ;
104834: LD_VAR 0 2
104838: PPUSH
104839: LD_VAR 0 3
104843: PPUSH
104844: CALL_OW 235
// end ;
104848: GO 104771
104850: POP
104851: POP
// end ;
104852: LD_VAR 0 1
104856: RET
// export function hHackFog ; begin
104857: LD_INT 0
104859: PPUSH
// FogOff ( true ) ;
104860: LD_INT 1
104862: PPUSH
104863: CALL_OW 344
// end ;
104867: LD_VAR 0 1
104871: RET
// export function hHackTeleport ( unit , x , y ) ; begin
104872: LD_INT 0
104874: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
104875: LD_VAR 0 1
104879: PPUSH
104880: LD_VAR 0 2
104884: PPUSH
104885: LD_VAR 0 3
104889: PPUSH
104890: LD_INT 1
104892: PPUSH
104893: LD_INT 1
104895: PPUSH
104896: CALL_OW 483
// CenterOnXY ( x , y ) ;
104900: LD_VAR 0 2
104904: PPUSH
104905: LD_VAR 0 3
104909: PPUSH
104910: CALL_OW 84
// end ;
104914: LD_VAR 0 4
104918: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
104919: LD_INT 0
104921: PPUSH
104922: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
104923: LD_VAR 0 1
104927: NOT
104928: PUSH
104929: LD_VAR 0 2
104933: PPUSH
104934: LD_VAR 0 3
104938: PPUSH
104939: CALL_OW 488
104943: NOT
104944: OR
104945: PUSH
104946: LD_VAR 0 1
104950: PPUSH
104951: CALL_OW 266
104955: PUSH
104956: LD_INT 3
104958: NONEQUAL
104959: PUSH
104960: LD_VAR 0 1
104964: PPUSH
104965: CALL_OW 247
104969: PUSH
104970: LD_INT 1
104972: EQUAL
104973: NOT
104974: AND
104975: OR
104976: IFFALSE 104980
// exit ;
104978: GO 105129
// if GetType ( factory ) = unit_human then
104980: LD_VAR 0 1
104984: PPUSH
104985: CALL_OW 247
104989: PUSH
104990: LD_INT 1
104992: EQUAL
104993: IFFALSE 105010
// factory := IsInUnit ( factory ) ;
104995: LD_ADDR_VAR 0 1
104999: PUSH
105000: LD_VAR 0 1
105004: PPUSH
105005: CALL_OW 310
105009: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
105010: LD_VAR 0 1
105014: PPUSH
105015: CALL_OW 266
105019: PUSH
105020: LD_INT 3
105022: NONEQUAL
105023: IFFALSE 105027
// exit ;
105025: GO 105129
// if HexInfo ( x , y ) = factory then
105027: LD_VAR 0 2
105031: PPUSH
105032: LD_VAR 0 3
105036: PPUSH
105037: CALL_OW 428
105041: PUSH
105042: LD_VAR 0 1
105046: EQUAL
105047: IFFALSE 105074
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
105049: LD_ADDR_EXP 154
105053: PUSH
105054: LD_EXP 154
105058: PPUSH
105059: LD_VAR 0 1
105063: PPUSH
105064: LD_INT 0
105066: PPUSH
105067: CALL_OW 1
105071: ST_TO_ADDR
105072: GO 105125
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
105074: LD_ADDR_EXP 154
105078: PUSH
105079: LD_EXP 154
105083: PPUSH
105084: LD_VAR 0 1
105088: PPUSH
105089: LD_VAR 0 1
105093: PPUSH
105094: CALL_OW 255
105098: PUSH
105099: LD_VAR 0 1
105103: PUSH
105104: LD_VAR 0 2
105108: PUSH
105109: LD_VAR 0 3
105113: PUSH
105114: EMPTY
105115: LIST
105116: LIST
105117: LIST
105118: LIST
105119: PPUSH
105120: CALL_OW 1
105124: ST_TO_ADDR
// UpdateFactoryWaypoints ;
105125: CALL 105134 0 0
// end ;
105129: LD_VAR 0 4
105133: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
105134: LD_INT 0
105136: PPUSH
105137: PPUSH
105138: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
105139: LD_STRING resetFactoryWaypoint();
105141: PPUSH
105142: CALL_OW 559
// if factoryWaypoints then
105146: LD_EXP 154
105150: IFFALSE 105276
// begin list := PrepareArray ( factoryWaypoints ) ;
105152: LD_ADDR_VAR 0 3
105156: PUSH
105157: LD_EXP 154
105161: PPUSH
105162: CALL 90122 0 1
105166: ST_TO_ADDR
// for i := 1 to list do
105167: LD_ADDR_VAR 0 2
105171: PUSH
105172: DOUBLE
105173: LD_INT 1
105175: DEC
105176: ST_TO_ADDR
105177: LD_VAR 0 3
105181: PUSH
105182: FOR_TO
105183: IFFALSE 105274
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
105185: LD_STRING setFactoryWaypointXY(
105187: PUSH
105188: LD_VAR 0 3
105192: PUSH
105193: LD_VAR 0 2
105197: ARRAY
105198: PUSH
105199: LD_INT 1
105201: ARRAY
105202: STR
105203: PUSH
105204: LD_STRING ,
105206: STR
105207: PUSH
105208: LD_VAR 0 3
105212: PUSH
105213: LD_VAR 0 2
105217: ARRAY
105218: PUSH
105219: LD_INT 2
105221: ARRAY
105222: STR
105223: PUSH
105224: LD_STRING ,
105226: STR
105227: PUSH
105228: LD_VAR 0 3
105232: PUSH
105233: LD_VAR 0 2
105237: ARRAY
105238: PUSH
105239: LD_INT 3
105241: ARRAY
105242: STR
105243: PUSH
105244: LD_STRING ,
105246: STR
105247: PUSH
105248: LD_VAR 0 3
105252: PUSH
105253: LD_VAR 0 2
105257: ARRAY
105258: PUSH
105259: LD_INT 4
105261: ARRAY
105262: STR
105263: PUSH
105264: LD_STRING )
105266: STR
105267: PPUSH
105268: CALL_OW 559
105272: GO 105182
105274: POP
105275: POP
// end ; end ;
105276: LD_VAR 0 1
105280: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
105281: LD_INT 0
105283: PPUSH
// if HexInfo ( x , y ) = warehouse then
105284: LD_VAR 0 2
105288: PPUSH
105289: LD_VAR 0 3
105293: PPUSH
105294: CALL_OW 428
105298: PUSH
105299: LD_VAR 0 1
105303: EQUAL
105304: IFFALSE 105331
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
105306: LD_ADDR_EXP 155
105310: PUSH
105311: LD_EXP 155
105315: PPUSH
105316: LD_VAR 0 1
105320: PPUSH
105321: LD_INT 0
105323: PPUSH
105324: CALL_OW 1
105328: ST_TO_ADDR
105329: GO 105382
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
105331: LD_ADDR_EXP 155
105335: PUSH
105336: LD_EXP 155
105340: PPUSH
105341: LD_VAR 0 1
105345: PPUSH
105346: LD_VAR 0 1
105350: PPUSH
105351: CALL_OW 255
105355: PUSH
105356: LD_VAR 0 1
105360: PUSH
105361: LD_VAR 0 2
105365: PUSH
105366: LD_VAR 0 3
105370: PUSH
105371: EMPTY
105372: LIST
105373: LIST
105374: LIST
105375: LIST
105376: PPUSH
105377: CALL_OW 1
105381: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
105382: CALL 105391 0 0
// end ;
105386: LD_VAR 0 4
105390: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
105391: LD_INT 0
105393: PPUSH
105394: PPUSH
105395: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
105396: LD_STRING resetWarehouseGatheringPoints();
105398: PPUSH
105399: CALL_OW 559
// if warehouseGatheringPoints then
105403: LD_EXP 155
105407: IFFALSE 105533
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
105409: LD_ADDR_VAR 0 3
105413: PUSH
105414: LD_EXP 155
105418: PPUSH
105419: CALL 90122 0 1
105423: ST_TO_ADDR
// for i := 1 to list do
105424: LD_ADDR_VAR 0 2
105428: PUSH
105429: DOUBLE
105430: LD_INT 1
105432: DEC
105433: ST_TO_ADDR
105434: LD_VAR 0 3
105438: PUSH
105439: FOR_TO
105440: IFFALSE 105531
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
105442: LD_STRING setWarehouseGatheringPointXY(
105444: PUSH
105445: LD_VAR 0 3
105449: PUSH
105450: LD_VAR 0 2
105454: ARRAY
105455: PUSH
105456: LD_INT 1
105458: ARRAY
105459: STR
105460: PUSH
105461: LD_STRING ,
105463: STR
105464: PUSH
105465: LD_VAR 0 3
105469: PUSH
105470: LD_VAR 0 2
105474: ARRAY
105475: PUSH
105476: LD_INT 2
105478: ARRAY
105479: STR
105480: PUSH
105481: LD_STRING ,
105483: STR
105484: PUSH
105485: LD_VAR 0 3
105489: PUSH
105490: LD_VAR 0 2
105494: ARRAY
105495: PUSH
105496: LD_INT 3
105498: ARRAY
105499: STR
105500: PUSH
105501: LD_STRING ,
105503: STR
105504: PUSH
105505: LD_VAR 0 3
105509: PUSH
105510: LD_VAR 0 2
105514: ARRAY
105515: PUSH
105516: LD_INT 4
105518: ARRAY
105519: STR
105520: PUSH
105521: LD_STRING )
105523: STR
105524: PPUSH
105525: CALL_OW 559
105529: GO 105439
105531: POP
105532: POP
// end ; end ;
105533: LD_VAR 0 1
105537: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
105538: LD_EXP 155
105542: IFFALSE 106227
105544: GO 105546
105546: DISABLE
105547: LD_INT 0
105549: PPUSH
105550: PPUSH
105551: PPUSH
105552: PPUSH
105553: PPUSH
105554: PPUSH
105555: PPUSH
105556: PPUSH
105557: PPUSH
// begin enable ;
105558: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
105559: LD_ADDR_VAR 0 3
105563: PUSH
105564: LD_EXP 155
105568: PPUSH
105569: CALL 90122 0 1
105573: ST_TO_ADDR
// if not list then
105574: LD_VAR 0 3
105578: NOT
105579: IFFALSE 105583
// exit ;
105581: GO 106227
// for i := 1 to list do
105583: LD_ADDR_VAR 0 1
105587: PUSH
105588: DOUBLE
105589: LD_INT 1
105591: DEC
105592: ST_TO_ADDR
105593: LD_VAR 0 3
105597: PUSH
105598: FOR_TO
105599: IFFALSE 106225
// begin depot := list [ i ] [ 2 ] ;
105601: LD_ADDR_VAR 0 8
105605: PUSH
105606: LD_VAR 0 3
105610: PUSH
105611: LD_VAR 0 1
105615: ARRAY
105616: PUSH
105617: LD_INT 2
105619: ARRAY
105620: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
105621: LD_ADDR_VAR 0 5
105625: PUSH
105626: LD_VAR 0 3
105630: PUSH
105631: LD_VAR 0 1
105635: ARRAY
105636: PUSH
105637: LD_INT 1
105639: ARRAY
105640: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
105641: LD_VAR 0 8
105645: PPUSH
105646: CALL_OW 301
105650: PUSH
105651: LD_VAR 0 5
105655: PUSH
105656: LD_VAR 0 8
105660: PPUSH
105661: CALL_OW 255
105665: NONEQUAL
105666: OR
105667: IFFALSE 105696
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
105669: LD_ADDR_EXP 155
105673: PUSH
105674: LD_EXP 155
105678: PPUSH
105679: LD_VAR 0 8
105683: PPUSH
105684: LD_INT 0
105686: PPUSH
105687: CALL_OW 1
105691: ST_TO_ADDR
// exit ;
105692: POP
105693: POP
105694: GO 106227
// end ; x := list [ i ] [ 3 ] ;
105696: LD_ADDR_VAR 0 6
105700: PUSH
105701: LD_VAR 0 3
105705: PUSH
105706: LD_VAR 0 1
105710: ARRAY
105711: PUSH
105712: LD_INT 3
105714: ARRAY
105715: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
105716: LD_ADDR_VAR 0 7
105720: PUSH
105721: LD_VAR 0 3
105725: PUSH
105726: LD_VAR 0 1
105730: ARRAY
105731: PUSH
105732: LD_INT 4
105734: ARRAY
105735: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
105736: LD_ADDR_VAR 0 9
105740: PUSH
105741: LD_VAR 0 6
105745: PPUSH
105746: LD_VAR 0 7
105750: PPUSH
105751: LD_INT 16
105753: PPUSH
105754: CALL 88710 0 3
105758: ST_TO_ADDR
// if not cratesNearbyPoint then
105759: LD_VAR 0 9
105763: NOT
105764: IFFALSE 105770
// exit ;
105766: POP
105767: POP
105768: GO 106227
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
105770: LD_ADDR_VAR 0 4
105774: PUSH
105775: LD_INT 22
105777: PUSH
105778: LD_VAR 0 5
105782: PUSH
105783: EMPTY
105784: LIST
105785: LIST
105786: PUSH
105787: LD_INT 3
105789: PUSH
105790: LD_INT 60
105792: PUSH
105793: EMPTY
105794: LIST
105795: PUSH
105796: EMPTY
105797: LIST
105798: LIST
105799: PUSH
105800: LD_INT 91
105802: PUSH
105803: LD_VAR 0 8
105807: PUSH
105808: LD_INT 6
105810: PUSH
105811: EMPTY
105812: LIST
105813: LIST
105814: LIST
105815: PUSH
105816: LD_INT 2
105818: PUSH
105819: LD_INT 25
105821: PUSH
105822: LD_INT 2
105824: PUSH
105825: EMPTY
105826: LIST
105827: LIST
105828: PUSH
105829: LD_INT 25
105831: PUSH
105832: LD_INT 16
105834: PUSH
105835: EMPTY
105836: LIST
105837: LIST
105838: PUSH
105839: EMPTY
105840: LIST
105841: LIST
105842: LIST
105843: PUSH
105844: EMPTY
105845: LIST
105846: LIST
105847: LIST
105848: LIST
105849: PPUSH
105850: CALL_OW 69
105854: PUSH
105855: LD_VAR 0 8
105859: PPUSH
105860: CALL_OW 313
105864: PPUSH
105865: LD_INT 3
105867: PUSH
105868: LD_INT 60
105870: PUSH
105871: EMPTY
105872: LIST
105873: PUSH
105874: EMPTY
105875: LIST
105876: LIST
105877: PUSH
105878: LD_INT 2
105880: PUSH
105881: LD_INT 25
105883: PUSH
105884: LD_INT 2
105886: PUSH
105887: EMPTY
105888: LIST
105889: LIST
105890: PUSH
105891: LD_INT 25
105893: PUSH
105894: LD_INT 16
105896: PUSH
105897: EMPTY
105898: LIST
105899: LIST
105900: PUSH
105901: EMPTY
105902: LIST
105903: LIST
105904: LIST
105905: PUSH
105906: EMPTY
105907: LIST
105908: LIST
105909: PPUSH
105910: CALL_OW 72
105914: UNION
105915: ST_TO_ADDR
// if tmp then
105916: LD_VAR 0 4
105920: IFFALSE 106000
// begin tmp := ShrinkArray ( tmp , 3 ) ;
105922: LD_ADDR_VAR 0 4
105926: PUSH
105927: LD_VAR 0 4
105931: PPUSH
105932: LD_INT 3
105934: PPUSH
105935: CALL 86679 0 2
105939: ST_TO_ADDR
// for j in tmp do
105940: LD_ADDR_VAR 0 2
105944: PUSH
105945: LD_VAR 0 4
105949: PUSH
105950: FOR_IN
105951: IFFALSE 105994
// begin if IsInUnit ( j ) then
105953: LD_VAR 0 2
105957: PPUSH
105958: CALL_OW 310
105962: IFFALSE 105973
// ComExit ( j ) ;
105964: LD_VAR 0 2
105968: PPUSH
105969: CALL 86762 0 1
// AddComCollect ( j , x , y ) ;
105973: LD_VAR 0 2
105977: PPUSH
105978: LD_VAR 0 6
105982: PPUSH
105983: LD_VAR 0 7
105987: PPUSH
105988: CALL_OW 177
// end ;
105992: GO 105950
105994: POP
105995: POP
// exit ;
105996: POP
105997: POP
105998: GO 106227
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
106000: LD_ADDR_VAR 0 4
106004: PUSH
106005: LD_INT 22
106007: PUSH
106008: LD_VAR 0 5
106012: PUSH
106013: EMPTY
106014: LIST
106015: LIST
106016: PUSH
106017: LD_INT 91
106019: PUSH
106020: LD_VAR 0 8
106024: PUSH
106025: LD_INT 8
106027: PUSH
106028: EMPTY
106029: LIST
106030: LIST
106031: LIST
106032: PUSH
106033: LD_INT 2
106035: PUSH
106036: LD_INT 34
106038: PUSH
106039: LD_INT 12
106041: PUSH
106042: EMPTY
106043: LIST
106044: LIST
106045: PUSH
106046: LD_INT 34
106048: PUSH
106049: LD_INT 51
106051: PUSH
106052: EMPTY
106053: LIST
106054: LIST
106055: PUSH
106056: LD_INT 34
106058: PUSH
106059: LD_INT 32
106061: PUSH
106062: EMPTY
106063: LIST
106064: LIST
106065: PUSH
106066: LD_INT 34
106068: PUSH
106069: LD_INT 89
106071: PUSH
106072: EMPTY
106073: LIST
106074: LIST
106075: PUSH
106076: EMPTY
106077: LIST
106078: LIST
106079: LIST
106080: LIST
106081: LIST
106082: PUSH
106083: EMPTY
106084: LIST
106085: LIST
106086: LIST
106087: PPUSH
106088: CALL_OW 69
106092: ST_TO_ADDR
// if tmp then
106093: LD_VAR 0 4
106097: IFFALSE 106223
// begin for j in tmp do
106099: LD_ADDR_VAR 0 2
106103: PUSH
106104: LD_VAR 0 4
106108: PUSH
106109: FOR_IN
106110: IFFALSE 106221
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
106112: LD_VAR 0 2
106116: PPUSH
106117: CALL_OW 262
106121: PUSH
106122: LD_INT 3
106124: EQUAL
106125: PUSH
106126: LD_VAR 0 2
106130: PPUSH
106131: CALL_OW 261
106135: PUSH
106136: LD_INT 20
106138: GREATER
106139: OR
106140: PUSH
106141: LD_VAR 0 2
106145: PPUSH
106146: CALL_OW 314
106150: NOT
106151: AND
106152: PUSH
106153: LD_VAR 0 2
106157: PPUSH
106158: CALL_OW 263
106162: PUSH
106163: LD_INT 1
106165: NONEQUAL
106166: PUSH
106167: LD_VAR 0 2
106171: PPUSH
106172: CALL_OW 311
106176: OR
106177: AND
106178: IFFALSE 106219
// begin ComCollect ( j , x , y ) ;
106180: LD_VAR 0 2
106184: PPUSH
106185: LD_VAR 0 6
106189: PPUSH
106190: LD_VAR 0 7
106194: PPUSH
106195: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
106199: LD_VAR 0 2
106203: PPUSH
106204: LD_VAR 0 8
106208: PPUSH
106209: CALL_OW 172
// exit ;
106213: POP
106214: POP
106215: POP
106216: POP
106217: GO 106227
// end ;
106219: GO 106109
106221: POP
106222: POP
// end ; end ;
106223: GO 105598
106225: POP
106226: POP
// end ; end_of_file
106227: PPOPN 9
106229: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
106230: LD_INT 0
106232: PPUSH
106233: PPUSH
106234: PPUSH
106235: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
106236: LD_VAR 0 1
106240: PPUSH
106241: CALL_OW 264
106245: PUSH
106246: LD_INT 91
106248: EQUAL
106249: IFFALSE 106321
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
106251: LD_INT 68
106253: PPUSH
106254: LD_VAR 0 1
106258: PPUSH
106259: CALL_OW 255
106263: PPUSH
106264: CALL_OW 321
106268: PUSH
106269: LD_INT 2
106271: EQUAL
106272: IFFALSE 106284
// eff := 70 else
106274: LD_ADDR_VAR 0 4
106278: PUSH
106279: LD_INT 70
106281: ST_TO_ADDR
106282: GO 106292
// eff := 30 ;
106284: LD_ADDR_VAR 0 4
106288: PUSH
106289: LD_INT 30
106291: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
106292: LD_VAR 0 1
106296: PPUSH
106297: CALL_OW 250
106301: PPUSH
106302: LD_VAR 0 1
106306: PPUSH
106307: CALL_OW 251
106311: PPUSH
106312: LD_VAR 0 4
106316: PPUSH
106317: CALL_OW 495
// end ; end ;
106321: LD_VAR 0 2
106325: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
106326: LD_INT 0
106328: PPUSH
// end ;
106329: LD_VAR 0 4
106333: RET
// export function SOS_Command ( cmd ) ; begin
106334: LD_INT 0
106336: PPUSH
// end ;
106337: LD_VAR 0 2
106341: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
106342: LD_INT 0
106344: PPUSH
// end ;
106345: LD_VAR 0 6
106349: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
106350: LD_INT 0
106352: PPUSH
106353: PPUSH
// if not vehicle or not factory then
106354: LD_VAR 0 1
106358: NOT
106359: PUSH
106360: LD_VAR 0 2
106364: NOT
106365: OR
106366: IFFALSE 106370
// exit ;
106368: GO 106601
// if factoryWaypoints >= factory then
106370: LD_EXP 154
106374: PUSH
106375: LD_VAR 0 2
106379: GREATEREQUAL
106380: IFFALSE 106601
// if factoryWaypoints [ factory ] then
106382: LD_EXP 154
106386: PUSH
106387: LD_VAR 0 2
106391: ARRAY
106392: IFFALSE 106601
// begin if GetControl ( vehicle ) = control_manual then
106394: LD_VAR 0 1
106398: PPUSH
106399: CALL_OW 263
106403: PUSH
106404: LD_INT 1
106406: EQUAL
106407: IFFALSE 106488
// begin driver := IsDrivenBy ( vehicle ) ;
106409: LD_ADDR_VAR 0 4
106413: PUSH
106414: LD_VAR 0 1
106418: PPUSH
106419: CALL_OW 311
106423: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
106424: LD_VAR 0 4
106428: PPUSH
106429: LD_EXP 154
106433: PUSH
106434: LD_VAR 0 2
106438: ARRAY
106439: PUSH
106440: LD_INT 3
106442: ARRAY
106443: PPUSH
106444: LD_EXP 154
106448: PUSH
106449: LD_VAR 0 2
106453: ARRAY
106454: PUSH
106455: LD_INT 4
106457: ARRAY
106458: PPUSH
106459: CALL_OW 171
// AddComExitVehicle ( driver ) ;
106463: LD_VAR 0 4
106467: PPUSH
106468: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
106472: LD_VAR 0 4
106476: PPUSH
106477: LD_VAR 0 2
106481: PPUSH
106482: CALL_OW 180
// end else
106486: GO 106601
// if GetControl ( vehicle ) = control_remote then
106488: LD_VAR 0 1
106492: PPUSH
106493: CALL_OW 263
106497: PUSH
106498: LD_INT 2
106500: EQUAL
106501: IFFALSE 106562
// begin wait ( 0 0$2 ) ;
106503: LD_INT 70
106505: PPUSH
106506: CALL_OW 67
// if Connect ( vehicle ) then
106510: LD_VAR 0 1
106514: PPUSH
106515: CALL 57003 0 1
106519: IFFALSE 106560
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
106521: LD_VAR 0 1
106525: PPUSH
106526: LD_EXP 154
106530: PUSH
106531: LD_VAR 0 2
106535: ARRAY
106536: PUSH
106537: LD_INT 3
106539: ARRAY
106540: PPUSH
106541: LD_EXP 154
106545: PUSH
106546: LD_VAR 0 2
106550: ARRAY
106551: PUSH
106552: LD_INT 4
106554: ARRAY
106555: PPUSH
106556: CALL_OW 171
// end else
106560: GO 106601
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
106562: LD_VAR 0 1
106566: PPUSH
106567: LD_EXP 154
106571: PUSH
106572: LD_VAR 0 2
106576: ARRAY
106577: PUSH
106578: LD_INT 3
106580: ARRAY
106581: PPUSH
106582: LD_EXP 154
106586: PUSH
106587: LD_VAR 0 2
106591: ARRAY
106592: PUSH
106593: LD_INT 4
106595: ARRAY
106596: PPUSH
106597: CALL_OW 171
// end ; end ;
106601: LD_VAR 0 3
106605: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
106606: LD_INT 0
106608: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
106609: LD_VAR 0 1
106613: PUSH
106614: LD_INT 250
106616: EQUAL
106617: PUSH
106618: LD_VAR 0 2
106622: PPUSH
106623: CALL_OW 264
106627: PUSH
106628: LD_INT 81
106630: EQUAL
106631: AND
106632: IFFALSE 106653
// MinerPlaceMine ( unit , x , y ) ;
106634: LD_VAR 0 2
106638: PPUSH
106639: LD_VAR 0 4
106643: PPUSH
106644: LD_VAR 0 5
106648: PPUSH
106649: CALL 109038 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
106653: LD_VAR 0 1
106657: PUSH
106658: LD_INT 251
106660: EQUAL
106661: PUSH
106662: LD_VAR 0 2
106666: PPUSH
106667: CALL_OW 264
106671: PUSH
106672: LD_INT 81
106674: EQUAL
106675: AND
106676: IFFALSE 106697
// MinerDetonateMine ( unit , x , y ) ;
106678: LD_VAR 0 2
106682: PPUSH
106683: LD_VAR 0 4
106687: PPUSH
106688: LD_VAR 0 5
106692: PPUSH
106693: CALL 109313 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
106697: LD_VAR 0 1
106701: PUSH
106702: LD_INT 252
106704: EQUAL
106705: PUSH
106706: LD_VAR 0 2
106710: PPUSH
106711: CALL_OW 264
106715: PUSH
106716: LD_INT 81
106718: EQUAL
106719: AND
106720: IFFALSE 106741
// MinerCreateMinefield ( unit , x , y ) ;
106722: LD_VAR 0 2
106726: PPUSH
106727: LD_VAR 0 4
106731: PPUSH
106732: LD_VAR 0 5
106736: PPUSH
106737: CALL 109730 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
106741: LD_VAR 0 1
106745: PUSH
106746: LD_INT 253
106748: EQUAL
106749: PUSH
106750: LD_VAR 0 2
106754: PPUSH
106755: CALL_OW 257
106759: PUSH
106760: LD_INT 5
106762: EQUAL
106763: AND
106764: IFFALSE 106785
// ComBinocular ( unit , x , y ) ;
106766: LD_VAR 0 2
106770: PPUSH
106771: LD_VAR 0 4
106775: PPUSH
106776: LD_VAR 0 5
106780: PPUSH
106781: CALL 110099 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
106785: LD_VAR 0 1
106789: PUSH
106790: LD_INT 254
106792: EQUAL
106793: PUSH
106794: LD_VAR 0 2
106798: PPUSH
106799: CALL_OW 264
106803: PUSH
106804: LD_INT 99
106806: EQUAL
106807: AND
106808: PUSH
106809: LD_VAR 0 3
106813: PPUSH
106814: CALL_OW 263
106818: PUSH
106819: LD_INT 3
106821: EQUAL
106822: AND
106823: IFFALSE 106839
// HackDestroyVehicle ( unit , selectedUnit ) ;
106825: LD_VAR 0 2
106829: PPUSH
106830: LD_VAR 0 3
106834: PPUSH
106835: CALL 108402 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
106839: LD_VAR 0 1
106843: PUSH
106844: LD_INT 255
106846: EQUAL
106847: PUSH
106848: LD_VAR 0 2
106852: PPUSH
106853: CALL_OW 264
106857: PUSH
106858: LD_INT 14
106860: PUSH
106861: LD_INT 53
106863: PUSH
106864: EMPTY
106865: LIST
106866: LIST
106867: IN
106868: AND
106869: PUSH
106870: LD_VAR 0 4
106874: PPUSH
106875: LD_VAR 0 5
106879: PPUSH
106880: CALL_OW 488
106884: AND
106885: IFFALSE 106909
// CutTreeXYR ( unit , x , y , 12 ) ;
106887: LD_VAR 0 2
106891: PPUSH
106892: LD_VAR 0 4
106896: PPUSH
106897: LD_VAR 0 5
106901: PPUSH
106902: LD_INT 12
106904: PPUSH
106905: CALL 106972 0 4
// if cmd = 256 then
106909: LD_VAR 0 1
106913: PUSH
106914: LD_INT 256
106916: EQUAL
106917: IFFALSE 106938
// SetFactoryWaypoint ( unit , x , y ) ;
106919: LD_VAR 0 2
106923: PPUSH
106924: LD_VAR 0 4
106928: PPUSH
106929: LD_VAR 0 5
106933: PPUSH
106934: CALL 104919 0 3
// if cmd = 257 then
106938: LD_VAR 0 1
106942: PUSH
106943: LD_INT 257
106945: EQUAL
106946: IFFALSE 106967
// SetWarehouseGatheringPoint ( unit , x , y ) ;
106948: LD_VAR 0 2
106952: PPUSH
106953: LD_VAR 0 4
106957: PPUSH
106958: LD_VAR 0 5
106962: PPUSH
106963: CALL 105281 0 3
// end ;
106967: LD_VAR 0 6
106971: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
106972: LD_INT 0
106974: PPUSH
106975: PPUSH
106976: PPUSH
106977: PPUSH
106978: PPUSH
106979: PPUSH
106980: PPUSH
106981: PPUSH
106982: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
106983: LD_VAR 0 1
106987: NOT
106988: PUSH
106989: LD_VAR 0 2
106993: PPUSH
106994: LD_VAR 0 3
106998: PPUSH
106999: CALL_OW 488
107003: NOT
107004: OR
107005: PUSH
107006: LD_VAR 0 4
107010: NOT
107011: OR
107012: IFFALSE 107016
// exit ;
107014: GO 107356
// list := [ ] ;
107016: LD_ADDR_VAR 0 13
107020: PUSH
107021: EMPTY
107022: ST_TO_ADDR
// if x - r < 0 then
107023: LD_VAR 0 2
107027: PUSH
107028: LD_VAR 0 4
107032: MINUS
107033: PUSH
107034: LD_INT 0
107036: LESS
107037: IFFALSE 107049
// min_x := 0 else
107039: LD_ADDR_VAR 0 7
107043: PUSH
107044: LD_INT 0
107046: ST_TO_ADDR
107047: GO 107065
// min_x := x - r ;
107049: LD_ADDR_VAR 0 7
107053: PUSH
107054: LD_VAR 0 2
107058: PUSH
107059: LD_VAR 0 4
107063: MINUS
107064: ST_TO_ADDR
// if y - r < 0 then
107065: LD_VAR 0 3
107069: PUSH
107070: LD_VAR 0 4
107074: MINUS
107075: PUSH
107076: LD_INT 0
107078: LESS
107079: IFFALSE 107091
// min_y := 0 else
107081: LD_ADDR_VAR 0 8
107085: PUSH
107086: LD_INT 0
107088: ST_TO_ADDR
107089: GO 107107
// min_y := y - r ;
107091: LD_ADDR_VAR 0 8
107095: PUSH
107096: LD_VAR 0 3
107100: PUSH
107101: LD_VAR 0 4
107105: MINUS
107106: ST_TO_ADDR
// max_x := x + r ;
107107: LD_ADDR_VAR 0 9
107111: PUSH
107112: LD_VAR 0 2
107116: PUSH
107117: LD_VAR 0 4
107121: PLUS
107122: ST_TO_ADDR
// max_y := y + r ;
107123: LD_ADDR_VAR 0 10
107127: PUSH
107128: LD_VAR 0 3
107132: PUSH
107133: LD_VAR 0 4
107137: PLUS
107138: ST_TO_ADDR
// for _x = min_x to max_x do
107139: LD_ADDR_VAR 0 11
107143: PUSH
107144: DOUBLE
107145: LD_VAR 0 7
107149: DEC
107150: ST_TO_ADDR
107151: LD_VAR 0 9
107155: PUSH
107156: FOR_TO
107157: IFFALSE 107274
// for _y = min_y to max_y do
107159: LD_ADDR_VAR 0 12
107163: PUSH
107164: DOUBLE
107165: LD_VAR 0 8
107169: DEC
107170: ST_TO_ADDR
107171: LD_VAR 0 10
107175: PUSH
107176: FOR_TO
107177: IFFALSE 107270
// begin if not ValidHex ( _x , _y ) then
107179: LD_VAR 0 11
107183: PPUSH
107184: LD_VAR 0 12
107188: PPUSH
107189: CALL_OW 488
107193: NOT
107194: IFFALSE 107198
// continue ;
107196: GO 107176
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
107198: LD_VAR 0 11
107202: PPUSH
107203: LD_VAR 0 12
107207: PPUSH
107208: CALL_OW 351
107212: PUSH
107213: LD_VAR 0 11
107217: PPUSH
107218: LD_VAR 0 12
107222: PPUSH
107223: CALL_OW 554
107227: AND
107228: IFFALSE 107268
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
107230: LD_ADDR_VAR 0 13
107234: PUSH
107235: LD_VAR 0 13
107239: PPUSH
107240: LD_VAR 0 13
107244: PUSH
107245: LD_INT 1
107247: PLUS
107248: PPUSH
107249: LD_VAR 0 11
107253: PUSH
107254: LD_VAR 0 12
107258: PUSH
107259: EMPTY
107260: LIST
107261: LIST
107262: PPUSH
107263: CALL_OW 2
107267: ST_TO_ADDR
// end ;
107268: GO 107176
107270: POP
107271: POP
107272: GO 107156
107274: POP
107275: POP
// if not list then
107276: LD_VAR 0 13
107280: NOT
107281: IFFALSE 107285
// exit ;
107283: GO 107356
// for i in list do
107285: LD_ADDR_VAR 0 6
107289: PUSH
107290: LD_VAR 0 13
107294: PUSH
107295: FOR_IN
107296: IFFALSE 107354
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
107298: LD_VAR 0 1
107302: PPUSH
107303: LD_STRING M
107305: PUSH
107306: LD_VAR 0 6
107310: PUSH
107311: LD_INT 1
107313: ARRAY
107314: PUSH
107315: LD_VAR 0 6
107319: PUSH
107320: LD_INT 2
107322: ARRAY
107323: PUSH
107324: LD_INT 0
107326: PUSH
107327: LD_INT 0
107329: PUSH
107330: LD_INT 0
107332: PUSH
107333: LD_INT 0
107335: PUSH
107336: EMPTY
107337: LIST
107338: LIST
107339: LIST
107340: LIST
107341: LIST
107342: LIST
107343: LIST
107344: PUSH
107345: EMPTY
107346: LIST
107347: PPUSH
107348: CALL_OW 447
107352: GO 107295
107354: POP
107355: POP
// end ;
107356: LD_VAR 0 5
107360: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
107361: LD_EXP 157
107365: NOT
107366: IFFALSE 107416
107368: GO 107370
107370: DISABLE
// begin initHack := true ;
107371: LD_ADDR_EXP 157
107375: PUSH
107376: LD_INT 1
107378: ST_TO_ADDR
// hackTanks := [ ] ;
107379: LD_ADDR_EXP 158
107383: PUSH
107384: EMPTY
107385: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
107386: LD_ADDR_EXP 159
107390: PUSH
107391: EMPTY
107392: ST_TO_ADDR
// hackLimit := 3 ;
107393: LD_ADDR_EXP 160
107397: PUSH
107398: LD_INT 3
107400: ST_TO_ADDR
// hackDist := 12 ;
107401: LD_ADDR_EXP 161
107405: PUSH
107406: LD_INT 12
107408: ST_TO_ADDR
// hackCounter := [ ] ;
107409: LD_ADDR_EXP 162
107413: PUSH
107414: EMPTY
107415: ST_TO_ADDR
// end ;
107416: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
107417: LD_EXP 157
107421: PUSH
107422: LD_INT 34
107424: PUSH
107425: LD_INT 99
107427: PUSH
107428: EMPTY
107429: LIST
107430: LIST
107431: PPUSH
107432: CALL_OW 69
107436: AND
107437: IFFALSE 107690
107439: GO 107441
107441: DISABLE
107442: LD_INT 0
107444: PPUSH
107445: PPUSH
// begin enable ;
107446: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
107447: LD_ADDR_VAR 0 1
107451: PUSH
107452: LD_INT 34
107454: PUSH
107455: LD_INT 99
107457: PUSH
107458: EMPTY
107459: LIST
107460: LIST
107461: PPUSH
107462: CALL_OW 69
107466: PUSH
107467: FOR_IN
107468: IFFALSE 107688
// begin if not i in hackTanks then
107470: LD_VAR 0 1
107474: PUSH
107475: LD_EXP 158
107479: IN
107480: NOT
107481: IFFALSE 107564
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
107483: LD_ADDR_EXP 158
107487: PUSH
107488: LD_EXP 158
107492: PPUSH
107493: LD_EXP 158
107497: PUSH
107498: LD_INT 1
107500: PLUS
107501: PPUSH
107502: LD_VAR 0 1
107506: PPUSH
107507: CALL_OW 1
107511: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
107512: LD_ADDR_EXP 159
107516: PUSH
107517: LD_EXP 159
107521: PPUSH
107522: LD_EXP 159
107526: PUSH
107527: LD_INT 1
107529: PLUS
107530: PPUSH
107531: EMPTY
107532: PPUSH
107533: CALL_OW 1
107537: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
107538: LD_ADDR_EXP 162
107542: PUSH
107543: LD_EXP 162
107547: PPUSH
107548: LD_EXP 162
107552: PUSH
107553: LD_INT 1
107555: PLUS
107556: PPUSH
107557: EMPTY
107558: PPUSH
107559: CALL_OW 1
107563: ST_TO_ADDR
// end ; if not IsOk ( i ) then
107564: LD_VAR 0 1
107568: PPUSH
107569: CALL_OW 302
107573: NOT
107574: IFFALSE 107587
// begin HackUnlinkAll ( i ) ;
107576: LD_VAR 0 1
107580: PPUSH
107581: CALL 107693 0 1
// continue ;
107585: GO 107467
// end ; HackCheckCapturedStatus ( i ) ;
107587: LD_VAR 0 1
107591: PPUSH
107592: CALL 108136 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
107596: LD_ADDR_VAR 0 2
107600: PUSH
107601: LD_INT 81
107603: PUSH
107604: LD_VAR 0 1
107608: PPUSH
107609: CALL_OW 255
107613: PUSH
107614: EMPTY
107615: LIST
107616: LIST
107617: PUSH
107618: LD_INT 33
107620: PUSH
107621: LD_INT 3
107623: PUSH
107624: EMPTY
107625: LIST
107626: LIST
107627: PUSH
107628: LD_INT 91
107630: PUSH
107631: LD_VAR 0 1
107635: PUSH
107636: LD_EXP 161
107640: PUSH
107641: EMPTY
107642: LIST
107643: LIST
107644: LIST
107645: PUSH
107646: LD_INT 50
107648: PUSH
107649: EMPTY
107650: LIST
107651: PUSH
107652: EMPTY
107653: LIST
107654: LIST
107655: LIST
107656: LIST
107657: PPUSH
107658: CALL_OW 69
107662: ST_TO_ADDR
// if not tmp then
107663: LD_VAR 0 2
107667: NOT
107668: IFFALSE 107672
// continue ;
107670: GO 107467
// HackLink ( i , tmp ) ;
107672: LD_VAR 0 1
107676: PPUSH
107677: LD_VAR 0 2
107681: PPUSH
107682: CALL 107829 0 2
// end ;
107686: GO 107467
107688: POP
107689: POP
// end ;
107690: PPOPN 2
107692: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
107693: LD_INT 0
107695: PPUSH
107696: PPUSH
107697: PPUSH
// if not hack in hackTanks then
107698: LD_VAR 0 1
107702: PUSH
107703: LD_EXP 158
107707: IN
107708: NOT
107709: IFFALSE 107713
// exit ;
107711: GO 107824
// index := GetElementIndex ( hackTanks , hack ) ;
107713: LD_ADDR_VAR 0 4
107717: PUSH
107718: LD_EXP 158
107722: PPUSH
107723: LD_VAR 0 1
107727: PPUSH
107728: CALL 53819 0 2
107732: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
107733: LD_EXP 159
107737: PUSH
107738: LD_VAR 0 4
107742: ARRAY
107743: IFFALSE 107824
// begin for i in hackTanksCaptured [ index ] do
107745: LD_ADDR_VAR 0 3
107749: PUSH
107750: LD_EXP 159
107754: PUSH
107755: LD_VAR 0 4
107759: ARRAY
107760: PUSH
107761: FOR_IN
107762: IFFALSE 107788
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
107764: LD_VAR 0 3
107768: PUSH
107769: LD_INT 1
107771: ARRAY
107772: PPUSH
107773: LD_VAR 0 3
107777: PUSH
107778: LD_INT 2
107780: ARRAY
107781: PPUSH
107782: CALL_OW 235
107786: GO 107761
107788: POP
107789: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
107790: LD_ADDR_EXP 159
107794: PUSH
107795: LD_EXP 159
107799: PPUSH
107800: LD_VAR 0 4
107804: PPUSH
107805: EMPTY
107806: PPUSH
107807: CALL_OW 1
107811: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
107812: LD_VAR 0 1
107816: PPUSH
107817: LD_INT 0
107819: PPUSH
107820: CALL_OW 505
// end ; end ;
107824: LD_VAR 0 2
107828: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
107829: LD_INT 0
107831: PPUSH
107832: PPUSH
107833: PPUSH
// if not hack in hackTanks or not vehicles then
107834: LD_VAR 0 1
107838: PUSH
107839: LD_EXP 158
107843: IN
107844: NOT
107845: PUSH
107846: LD_VAR 0 2
107850: NOT
107851: OR
107852: IFFALSE 107856
// exit ;
107854: GO 108131
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
107856: LD_ADDR_VAR 0 2
107860: PUSH
107861: LD_VAR 0 1
107865: PPUSH
107866: LD_VAR 0 2
107870: PPUSH
107871: LD_INT 1
107873: PPUSH
107874: LD_INT 1
107876: PPUSH
107877: CALL 54469 0 4
107881: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
107882: LD_ADDR_VAR 0 5
107886: PUSH
107887: LD_EXP 158
107891: PPUSH
107892: LD_VAR 0 1
107896: PPUSH
107897: CALL 53819 0 2
107901: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
107902: LD_EXP 159
107906: PUSH
107907: LD_VAR 0 5
107911: ARRAY
107912: PUSH
107913: LD_EXP 160
107917: LESS
107918: IFFALSE 108107
// begin for i := 1 to vehicles do
107920: LD_ADDR_VAR 0 4
107924: PUSH
107925: DOUBLE
107926: LD_INT 1
107928: DEC
107929: ST_TO_ADDR
107930: LD_VAR 0 2
107934: PUSH
107935: FOR_TO
107936: IFFALSE 108105
// begin if hackTanksCaptured [ index ] = hackLimit then
107938: LD_EXP 159
107942: PUSH
107943: LD_VAR 0 5
107947: ARRAY
107948: PUSH
107949: LD_EXP 160
107953: EQUAL
107954: IFFALSE 107958
// break ;
107956: GO 108105
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
107958: LD_ADDR_EXP 162
107962: PUSH
107963: LD_EXP 162
107967: PPUSH
107968: LD_VAR 0 5
107972: PPUSH
107973: LD_EXP 162
107977: PUSH
107978: LD_VAR 0 5
107982: ARRAY
107983: PUSH
107984: LD_INT 1
107986: PLUS
107987: PPUSH
107988: CALL_OW 1
107992: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
107993: LD_ADDR_EXP 159
107997: PUSH
107998: LD_EXP 159
108002: PPUSH
108003: LD_VAR 0 5
108007: PUSH
108008: LD_EXP 159
108012: PUSH
108013: LD_VAR 0 5
108017: ARRAY
108018: PUSH
108019: LD_INT 1
108021: PLUS
108022: PUSH
108023: EMPTY
108024: LIST
108025: LIST
108026: PPUSH
108027: LD_VAR 0 2
108031: PUSH
108032: LD_VAR 0 4
108036: ARRAY
108037: PUSH
108038: LD_VAR 0 2
108042: PUSH
108043: LD_VAR 0 4
108047: ARRAY
108048: PPUSH
108049: CALL_OW 255
108053: PUSH
108054: EMPTY
108055: LIST
108056: LIST
108057: PPUSH
108058: CALL 54034 0 3
108062: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
108063: LD_VAR 0 2
108067: PUSH
108068: LD_VAR 0 4
108072: ARRAY
108073: PPUSH
108074: LD_VAR 0 1
108078: PPUSH
108079: CALL_OW 255
108083: PPUSH
108084: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
108088: LD_VAR 0 2
108092: PUSH
108093: LD_VAR 0 4
108097: ARRAY
108098: PPUSH
108099: CALL_OW 141
// end ;
108103: GO 107935
108105: POP
108106: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
108107: LD_VAR 0 1
108111: PPUSH
108112: LD_EXP 159
108116: PUSH
108117: LD_VAR 0 5
108121: ARRAY
108122: PUSH
108123: LD_INT 0
108125: PLUS
108126: PPUSH
108127: CALL_OW 505
// end ;
108131: LD_VAR 0 3
108135: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
108136: LD_INT 0
108138: PPUSH
108139: PPUSH
108140: PPUSH
108141: PPUSH
// if not hack in hackTanks then
108142: LD_VAR 0 1
108146: PUSH
108147: LD_EXP 158
108151: IN
108152: NOT
108153: IFFALSE 108157
// exit ;
108155: GO 108397
// index := GetElementIndex ( hackTanks , hack ) ;
108157: LD_ADDR_VAR 0 4
108161: PUSH
108162: LD_EXP 158
108166: PPUSH
108167: LD_VAR 0 1
108171: PPUSH
108172: CALL 53819 0 2
108176: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
108177: LD_ADDR_VAR 0 3
108181: PUSH
108182: DOUBLE
108183: LD_EXP 159
108187: PUSH
108188: LD_VAR 0 4
108192: ARRAY
108193: INC
108194: ST_TO_ADDR
108195: LD_INT 1
108197: PUSH
108198: FOR_DOWNTO
108199: IFFALSE 108371
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
108201: LD_ADDR_VAR 0 5
108205: PUSH
108206: LD_EXP 159
108210: PUSH
108211: LD_VAR 0 4
108215: ARRAY
108216: PUSH
108217: LD_VAR 0 3
108221: ARRAY
108222: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
108223: LD_VAR 0 5
108227: PUSH
108228: LD_INT 1
108230: ARRAY
108231: PPUSH
108232: CALL_OW 302
108236: NOT
108237: PUSH
108238: LD_VAR 0 5
108242: PUSH
108243: LD_INT 1
108245: ARRAY
108246: PPUSH
108247: CALL_OW 255
108251: PUSH
108252: LD_VAR 0 1
108256: PPUSH
108257: CALL_OW 255
108261: NONEQUAL
108262: OR
108263: IFFALSE 108369
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
108265: LD_VAR 0 5
108269: PUSH
108270: LD_INT 1
108272: ARRAY
108273: PPUSH
108274: CALL_OW 305
108278: PUSH
108279: LD_VAR 0 5
108283: PUSH
108284: LD_INT 1
108286: ARRAY
108287: PPUSH
108288: CALL_OW 255
108292: PUSH
108293: LD_VAR 0 1
108297: PPUSH
108298: CALL_OW 255
108302: EQUAL
108303: AND
108304: IFFALSE 108328
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
108306: LD_VAR 0 5
108310: PUSH
108311: LD_INT 1
108313: ARRAY
108314: PPUSH
108315: LD_VAR 0 5
108319: PUSH
108320: LD_INT 2
108322: ARRAY
108323: PPUSH
108324: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
108328: LD_ADDR_EXP 159
108332: PUSH
108333: LD_EXP 159
108337: PPUSH
108338: LD_VAR 0 4
108342: PPUSH
108343: LD_EXP 159
108347: PUSH
108348: LD_VAR 0 4
108352: ARRAY
108353: PPUSH
108354: LD_VAR 0 3
108358: PPUSH
108359: CALL_OW 3
108363: PPUSH
108364: CALL_OW 1
108368: ST_TO_ADDR
// end ; end ;
108369: GO 108198
108371: POP
108372: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
108373: LD_VAR 0 1
108377: PPUSH
108378: LD_EXP 159
108382: PUSH
108383: LD_VAR 0 4
108387: ARRAY
108388: PUSH
108389: LD_INT 0
108391: PLUS
108392: PPUSH
108393: CALL_OW 505
// end ;
108397: LD_VAR 0 2
108401: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
108402: LD_INT 0
108404: PPUSH
108405: PPUSH
108406: PPUSH
108407: PPUSH
// if not hack in hackTanks then
108408: LD_VAR 0 1
108412: PUSH
108413: LD_EXP 158
108417: IN
108418: NOT
108419: IFFALSE 108423
// exit ;
108421: GO 108508
// index := GetElementIndex ( hackTanks , hack ) ;
108423: LD_ADDR_VAR 0 5
108427: PUSH
108428: LD_EXP 158
108432: PPUSH
108433: LD_VAR 0 1
108437: PPUSH
108438: CALL 53819 0 2
108442: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
108443: LD_ADDR_VAR 0 4
108447: PUSH
108448: DOUBLE
108449: LD_INT 1
108451: DEC
108452: ST_TO_ADDR
108453: LD_EXP 159
108457: PUSH
108458: LD_VAR 0 5
108462: ARRAY
108463: PUSH
108464: FOR_TO
108465: IFFALSE 108506
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
108467: LD_EXP 159
108471: PUSH
108472: LD_VAR 0 5
108476: ARRAY
108477: PUSH
108478: LD_VAR 0 4
108482: ARRAY
108483: PUSH
108484: LD_INT 1
108486: ARRAY
108487: PUSH
108488: LD_VAR 0 2
108492: EQUAL
108493: IFFALSE 108504
// KillUnit ( vehicle ) ;
108495: LD_VAR 0 2
108499: PPUSH
108500: CALL_OW 66
108504: GO 108464
108506: POP
108507: POP
// end ;
108508: LD_VAR 0 3
108512: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
108513: LD_EXP 163
108517: NOT
108518: IFFALSE 108553
108520: GO 108522
108522: DISABLE
// begin initMiner := true ;
108523: LD_ADDR_EXP 163
108527: PUSH
108528: LD_INT 1
108530: ST_TO_ADDR
// minersList := [ ] ;
108531: LD_ADDR_EXP 164
108535: PUSH
108536: EMPTY
108537: ST_TO_ADDR
// minerMinesList := [ ] ;
108538: LD_ADDR_EXP 165
108542: PUSH
108543: EMPTY
108544: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
108545: LD_ADDR_EXP 166
108549: PUSH
108550: LD_INT 5
108552: ST_TO_ADDR
// end ;
108553: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
108554: LD_EXP 163
108558: PUSH
108559: LD_INT 34
108561: PUSH
108562: LD_INT 81
108564: PUSH
108565: EMPTY
108566: LIST
108567: LIST
108568: PPUSH
108569: CALL_OW 69
108573: AND
108574: IFFALSE 109035
108576: GO 108578
108578: DISABLE
108579: LD_INT 0
108581: PPUSH
108582: PPUSH
108583: PPUSH
108584: PPUSH
// begin enable ;
108585: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
108586: LD_ADDR_VAR 0 1
108590: PUSH
108591: LD_INT 34
108593: PUSH
108594: LD_INT 81
108596: PUSH
108597: EMPTY
108598: LIST
108599: LIST
108600: PPUSH
108601: CALL_OW 69
108605: PUSH
108606: FOR_IN
108607: IFFALSE 108679
// begin if not i in minersList then
108609: LD_VAR 0 1
108613: PUSH
108614: LD_EXP 164
108618: IN
108619: NOT
108620: IFFALSE 108677
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
108622: LD_ADDR_EXP 164
108626: PUSH
108627: LD_EXP 164
108631: PPUSH
108632: LD_EXP 164
108636: PUSH
108637: LD_INT 1
108639: PLUS
108640: PPUSH
108641: LD_VAR 0 1
108645: PPUSH
108646: CALL_OW 1
108650: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
108651: LD_ADDR_EXP 165
108655: PUSH
108656: LD_EXP 165
108660: PPUSH
108661: LD_EXP 165
108665: PUSH
108666: LD_INT 1
108668: PLUS
108669: PPUSH
108670: EMPTY
108671: PPUSH
108672: CALL_OW 1
108676: ST_TO_ADDR
// end end ;
108677: GO 108606
108679: POP
108680: POP
// for i := minerMinesList downto 1 do
108681: LD_ADDR_VAR 0 1
108685: PUSH
108686: DOUBLE
108687: LD_EXP 165
108691: INC
108692: ST_TO_ADDR
108693: LD_INT 1
108695: PUSH
108696: FOR_DOWNTO
108697: IFFALSE 109033
// begin if IsLive ( minersList [ i ] ) then
108699: LD_EXP 164
108703: PUSH
108704: LD_VAR 0 1
108708: ARRAY
108709: PPUSH
108710: CALL_OW 300
108714: IFFALSE 108742
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
108716: LD_EXP 164
108720: PUSH
108721: LD_VAR 0 1
108725: ARRAY
108726: PPUSH
108727: LD_EXP 165
108731: PUSH
108732: LD_VAR 0 1
108736: ARRAY
108737: PPUSH
108738: CALL_OW 505
// if not minerMinesList [ i ] then
108742: LD_EXP 165
108746: PUSH
108747: LD_VAR 0 1
108751: ARRAY
108752: NOT
108753: IFFALSE 108757
// continue ;
108755: GO 108696
// for j := minerMinesList [ i ] downto 1 do
108757: LD_ADDR_VAR 0 2
108761: PUSH
108762: DOUBLE
108763: LD_EXP 165
108767: PUSH
108768: LD_VAR 0 1
108772: ARRAY
108773: INC
108774: ST_TO_ADDR
108775: LD_INT 1
108777: PUSH
108778: FOR_DOWNTO
108779: IFFALSE 109029
// begin side := GetSide ( minersList [ i ] ) ;
108781: LD_ADDR_VAR 0 3
108785: PUSH
108786: LD_EXP 164
108790: PUSH
108791: LD_VAR 0 1
108795: ARRAY
108796: PPUSH
108797: CALL_OW 255
108801: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
108802: LD_ADDR_VAR 0 4
108806: PUSH
108807: LD_EXP 165
108811: PUSH
108812: LD_VAR 0 1
108816: ARRAY
108817: PUSH
108818: LD_VAR 0 2
108822: ARRAY
108823: PUSH
108824: LD_INT 1
108826: ARRAY
108827: PPUSH
108828: LD_EXP 165
108832: PUSH
108833: LD_VAR 0 1
108837: ARRAY
108838: PUSH
108839: LD_VAR 0 2
108843: ARRAY
108844: PUSH
108845: LD_INT 2
108847: ARRAY
108848: PPUSH
108849: CALL_OW 428
108853: ST_TO_ADDR
// if not tmp then
108854: LD_VAR 0 4
108858: NOT
108859: IFFALSE 108863
// continue ;
108861: GO 108778
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
108863: LD_VAR 0 4
108867: PUSH
108868: LD_INT 81
108870: PUSH
108871: LD_VAR 0 3
108875: PUSH
108876: EMPTY
108877: LIST
108878: LIST
108879: PPUSH
108880: CALL_OW 69
108884: IN
108885: PUSH
108886: LD_EXP 165
108890: PUSH
108891: LD_VAR 0 1
108895: ARRAY
108896: PUSH
108897: LD_VAR 0 2
108901: ARRAY
108902: PUSH
108903: LD_INT 1
108905: ARRAY
108906: PPUSH
108907: LD_EXP 165
108911: PUSH
108912: LD_VAR 0 1
108916: ARRAY
108917: PUSH
108918: LD_VAR 0 2
108922: ARRAY
108923: PUSH
108924: LD_INT 2
108926: ARRAY
108927: PPUSH
108928: CALL_OW 458
108932: AND
108933: IFFALSE 109027
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
108935: LD_EXP 165
108939: PUSH
108940: LD_VAR 0 1
108944: ARRAY
108945: PUSH
108946: LD_VAR 0 2
108950: ARRAY
108951: PUSH
108952: LD_INT 1
108954: ARRAY
108955: PPUSH
108956: LD_EXP 165
108960: PUSH
108961: LD_VAR 0 1
108965: ARRAY
108966: PUSH
108967: LD_VAR 0 2
108971: ARRAY
108972: PUSH
108973: LD_INT 2
108975: ARRAY
108976: PPUSH
108977: LD_VAR 0 3
108981: PPUSH
108982: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
108986: LD_ADDR_EXP 165
108990: PUSH
108991: LD_EXP 165
108995: PPUSH
108996: LD_VAR 0 1
109000: PPUSH
109001: LD_EXP 165
109005: PUSH
109006: LD_VAR 0 1
109010: ARRAY
109011: PPUSH
109012: LD_VAR 0 2
109016: PPUSH
109017: CALL_OW 3
109021: PPUSH
109022: CALL_OW 1
109026: ST_TO_ADDR
// end ; end ;
109027: GO 108778
109029: POP
109030: POP
// end ;
109031: GO 108696
109033: POP
109034: POP
// end ;
109035: PPOPN 4
109037: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
109038: LD_INT 0
109040: PPUSH
109041: PPUSH
// result := false ;
109042: LD_ADDR_VAR 0 4
109046: PUSH
109047: LD_INT 0
109049: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
109050: LD_VAR 0 1
109054: PPUSH
109055: CALL_OW 264
109059: PUSH
109060: LD_INT 81
109062: EQUAL
109063: NOT
109064: IFFALSE 109068
// exit ;
109066: GO 109308
// index := GetElementIndex ( minersList , unit ) ;
109068: LD_ADDR_VAR 0 5
109072: PUSH
109073: LD_EXP 164
109077: PPUSH
109078: LD_VAR 0 1
109082: PPUSH
109083: CALL 53819 0 2
109087: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
109088: LD_EXP 165
109092: PUSH
109093: LD_VAR 0 5
109097: ARRAY
109098: PUSH
109099: LD_EXP 166
109103: GREATEREQUAL
109104: IFFALSE 109108
// exit ;
109106: GO 109308
// ComMoveXY ( unit , x , y ) ;
109108: LD_VAR 0 1
109112: PPUSH
109113: LD_VAR 0 2
109117: PPUSH
109118: LD_VAR 0 3
109122: PPUSH
109123: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
109127: LD_INT 35
109129: PPUSH
109130: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
109134: LD_VAR 0 1
109138: PPUSH
109139: LD_VAR 0 2
109143: PPUSH
109144: LD_VAR 0 3
109148: PPUSH
109149: CALL 85174 0 3
109153: NOT
109154: PUSH
109155: LD_VAR 0 1
109159: PPUSH
109160: CALL_OW 314
109164: AND
109165: IFFALSE 109169
// exit ;
109167: GO 109308
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
109169: LD_VAR 0 2
109173: PPUSH
109174: LD_VAR 0 3
109178: PPUSH
109179: CALL_OW 428
109183: PUSH
109184: LD_VAR 0 1
109188: EQUAL
109189: PUSH
109190: LD_VAR 0 1
109194: PPUSH
109195: CALL_OW 314
109199: NOT
109200: AND
109201: IFFALSE 109127
// PlaySoundXY ( x , y , PlantMine ) ;
109203: LD_VAR 0 2
109207: PPUSH
109208: LD_VAR 0 3
109212: PPUSH
109213: LD_STRING PlantMine
109215: PPUSH
109216: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
109220: LD_VAR 0 2
109224: PPUSH
109225: LD_VAR 0 3
109229: PPUSH
109230: LD_VAR 0 1
109234: PPUSH
109235: CALL_OW 255
109239: PPUSH
109240: LD_INT 0
109242: PPUSH
109243: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
109247: LD_ADDR_EXP 165
109251: PUSH
109252: LD_EXP 165
109256: PPUSH
109257: LD_VAR 0 5
109261: PUSH
109262: LD_EXP 165
109266: PUSH
109267: LD_VAR 0 5
109271: ARRAY
109272: PUSH
109273: LD_INT 1
109275: PLUS
109276: PUSH
109277: EMPTY
109278: LIST
109279: LIST
109280: PPUSH
109281: LD_VAR 0 2
109285: PUSH
109286: LD_VAR 0 3
109290: PUSH
109291: EMPTY
109292: LIST
109293: LIST
109294: PPUSH
109295: CALL 54034 0 3
109299: ST_TO_ADDR
// result := true ;
109300: LD_ADDR_VAR 0 4
109304: PUSH
109305: LD_INT 1
109307: ST_TO_ADDR
// end ;
109308: LD_VAR 0 4
109312: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
109313: LD_INT 0
109315: PPUSH
109316: PPUSH
109317: PPUSH
// if not unit in minersList then
109318: LD_VAR 0 1
109322: PUSH
109323: LD_EXP 164
109327: IN
109328: NOT
109329: IFFALSE 109333
// exit ;
109331: GO 109725
// index := GetElementIndex ( minersList , unit ) ;
109333: LD_ADDR_VAR 0 6
109337: PUSH
109338: LD_EXP 164
109342: PPUSH
109343: LD_VAR 0 1
109347: PPUSH
109348: CALL 53819 0 2
109352: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
109353: LD_ADDR_VAR 0 5
109357: PUSH
109358: DOUBLE
109359: LD_EXP 165
109363: PUSH
109364: LD_VAR 0 6
109368: ARRAY
109369: INC
109370: ST_TO_ADDR
109371: LD_INT 1
109373: PUSH
109374: FOR_DOWNTO
109375: IFFALSE 109536
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
109377: LD_EXP 165
109381: PUSH
109382: LD_VAR 0 6
109386: ARRAY
109387: PUSH
109388: LD_VAR 0 5
109392: ARRAY
109393: PUSH
109394: LD_INT 1
109396: ARRAY
109397: PUSH
109398: LD_VAR 0 2
109402: EQUAL
109403: PUSH
109404: LD_EXP 165
109408: PUSH
109409: LD_VAR 0 6
109413: ARRAY
109414: PUSH
109415: LD_VAR 0 5
109419: ARRAY
109420: PUSH
109421: LD_INT 2
109423: ARRAY
109424: PUSH
109425: LD_VAR 0 3
109429: EQUAL
109430: AND
109431: IFFALSE 109534
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
109433: LD_EXP 165
109437: PUSH
109438: LD_VAR 0 6
109442: ARRAY
109443: PUSH
109444: LD_VAR 0 5
109448: ARRAY
109449: PUSH
109450: LD_INT 1
109452: ARRAY
109453: PPUSH
109454: LD_EXP 165
109458: PUSH
109459: LD_VAR 0 6
109463: ARRAY
109464: PUSH
109465: LD_VAR 0 5
109469: ARRAY
109470: PUSH
109471: LD_INT 2
109473: ARRAY
109474: PPUSH
109475: LD_VAR 0 1
109479: PPUSH
109480: CALL_OW 255
109484: PPUSH
109485: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
109489: LD_ADDR_EXP 165
109493: PUSH
109494: LD_EXP 165
109498: PPUSH
109499: LD_VAR 0 6
109503: PPUSH
109504: LD_EXP 165
109508: PUSH
109509: LD_VAR 0 6
109513: ARRAY
109514: PPUSH
109515: LD_VAR 0 5
109519: PPUSH
109520: CALL_OW 3
109524: PPUSH
109525: CALL_OW 1
109529: ST_TO_ADDR
// exit ;
109530: POP
109531: POP
109532: GO 109725
// end ; end ;
109534: GO 109374
109536: POP
109537: POP
// for i := minerMinesList [ index ] downto 1 do
109538: LD_ADDR_VAR 0 5
109542: PUSH
109543: DOUBLE
109544: LD_EXP 165
109548: PUSH
109549: LD_VAR 0 6
109553: ARRAY
109554: INC
109555: ST_TO_ADDR
109556: LD_INT 1
109558: PUSH
109559: FOR_DOWNTO
109560: IFFALSE 109723
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
109562: LD_EXP 165
109566: PUSH
109567: LD_VAR 0 6
109571: ARRAY
109572: PUSH
109573: LD_VAR 0 5
109577: ARRAY
109578: PUSH
109579: LD_INT 1
109581: ARRAY
109582: PPUSH
109583: LD_EXP 165
109587: PUSH
109588: LD_VAR 0 6
109592: ARRAY
109593: PUSH
109594: LD_VAR 0 5
109598: ARRAY
109599: PUSH
109600: LD_INT 2
109602: ARRAY
109603: PPUSH
109604: LD_VAR 0 2
109608: PPUSH
109609: LD_VAR 0 3
109613: PPUSH
109614: CALL_OW 298
109618: PUSH
109619: LD_INT 6
109621: LESS
109622: IFFALSE 109721
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
109624: LD_EXP 165
109628: PUSH
109629: LD_VAR 0 6
109633: ARRAY
109634: PUSH
109635: LD_VAR 0 5
109639: ARRAY
109640: PUSH
109641: LD_INT 1
109643: ARRAY
109644: PPUSH
109645: LD_EXP 165
109649: PUSH
109650: LD_VAR 0 6
109654: ARRAY
109655: PUSH
109656: LD_VAR 0 5
109660: ARRAY
109661: PUSH
109662: LD_INT 2
109664: ARRAY
109665: PPUSH
109666: LD_VAR 0 1
109670: PPUSH
109671: CALL_OW 255
109675: PPUSH
109676: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
109680: LD_ADDR_EXP 165
109684: PUSH
109685: LD_EXP 165
109689: PPUSH
109690: LD_VAR 0 6
109694: PPUSH
109695: LD_EXP 165
109699: PUSH
109700: LD_VAR 0 6
109704: ARRAY
109705: PPUSH
109706: LD_VAR 0 5
109710: PPUSH
109711: CALL_OW 3
109715: PPUSH
109716: CALL_OW 1
109720: ST_TO_ADDR
// end ; end ;
109721: GO 109559
109723: POP
109724: POP
// end ;
109725: LD_VAR 0 4
109729: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
109730: LD_INT 0
109732: PPUSH
109733: PPUSH
109734: PPUSH
109735: PPUSH
109736: PPUSH
109737: PPUSH
109738: PPUSH
109739: PPUSH
109740: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
109741: LD_VAR 0 1
109745: PPUSH
109746: CALL_OW 264
109750: PUSH
109751: LD_INT 81
109753: EQUAL
109754: NOT
109755: PUSH
109756: LD_VAR 0 1
109760: PUSH
109761: LD_EXP 164
109765: IN
109766: NOT
109767: OR
109768: IFFALSE 109772
// exit ;
109770: GO 110094
// index := GetElementIndex ( minersList , unit ) ;
109772: LD_ADDR_VAR 0 6
109776: PUSH
109777: LD_EXP 164
109781: PPUSH
109782: LD_VAR 0 1
109786: PPUSH
109787: CALL 53819 0 2
109791: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
109792: LD_ADDR_VAR 0 8
109796: PUSH
109797: LD_EXP 166
109801: PUSH
109802: LD_EXP 165
109806: PUSH
109807: LD_VAR 0 6
109811: ARRAY
109812: MINUS
109813: ST_TO_ADDR
// if not minesFreeAmount then
109814: LD_VAR 0 8
109818: NOT
109819: IFFALSE 109823
// exit ;
109821: GO 110094
// tmp := [ ] ;
109823: LD_ADDR_VAR 0 7
109827: PUSH
109828: EMPTY
109829: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
109830: LD_ADDR_VAR 0 5
109834: PUSH
109835: DOUBLE
109836: LD_INT 1
109838: DEC
109839: ST_TO_ADDR
109840: LD_VAR 0 8
109844: PUSH
109845: FOR_TO
109846: IFFALSE 110041
// begin _d := rand ( 0 , 5 ) ;
109848: LD_ADDR_VAR 0 11
109852: PUSH
109853: LD_INT 0
109855: PPUSH
109856: LD_INT 5
109858: PPUSH
109859: CALL_OW 12
109863: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
109864: LD_ADDR_VAR 0 12
109868: PUSH
109869: LD_INT 2
109871: PPUSH
109872: LD_INT 6
109874: PPUSH
109875: CALL_OW 12
109879: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
109880: LD_ADDR_VAR 0 9
109884: PUSH
109885: LD_VAR 0 2
109889: PPUSH
109890: LD_VAR 0 11
109894: PPUSH
109895: LD_VAR 0 12
109899: PPUSH
109900: CALL_OW 272
109904: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
109905: LD_ADDR_VAR 0 10
109909: PUSH
109910: LD_VAR 0 3
109914: PPUSH
109915: LD_VAR 0 11
109919: PPUSH
109920: LD_VAR 0 12
109924: PPUSH
109925: CALL_OW 273
109929: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
109930: LD_VAR 0 9
109934: PPUSH
109935: LD_VAR 0 10
109939: PPUSH
109940: CALL_OW 488
109944: PUSH
109945: LD_VAR 0 9
109949: PUSH
109950: LD_VAR 0 10
109954: PUSH
109955: EMPTY
109956: LIST
109957: LIST
109958: PUSH
109959: LD_VAR 0 7
109963: IN
109964: NOT
109965: AND
109966: PUSH
109967: LD_VAR 0 9
109971: PPUSH
109972: LD_VAR 0 10
109976: PPUSH
109977: CALL_OW 458
109981: NOT
109982: AND
109983: IFFALSE 110025
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
109985: LD_ADDR_VAR 0 7
109989: PUSH
109990: LD_VAR 0 7
109994: PPUSH
109995: LD_VAR 0 7
109999: PUSH
110000: LD_INT 1
110002: PLUS
110003: PPUSH
110004: LD_VAR 0 9
110008: PUSH
110009: LD_VAR 0 10
110013: PUSH
110014: EMPTY
110015: LIST
110016: LIST
110017: PPUSH
110018: CALL_OW 1
110022: ST_TO_ADDR
110023: GO 110039
// i := i - 1 ;
110025: LD_ADDR_VAR 0 5
110029: PUSH
110030: LD_VAR 0 5
110034: PUSH
110035: LD_INT 1
110037: MINUS
110038: ST_TO_ADDR
// end ;
110039: GO 109845
110041: POP
110042: POP
// for i in tmp do
110043: LD_ADDR_VAR 0 5
110047: PUSH
110048: LD_VAR 0 7
110052: PUSH
110053: FOR_IN
110054: IFFALSE 110092
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
110056: LD_VAR 0 1
110060: PPUSH
110061: LD_VAR 0 5
110065: PUSH
110066: LD_INT 1
110068: ARRAY
110069: PPUSH
110070: LD_VAR 0 5
110074: PUSH
110075: LD_INT 2
110077: ARRAY
110078: PPUSH
110079: CALL 109038 0 3
110083: NOT
110084: IFFALSE 110090
// exit ;
110086: POP
110087: POP
110088: GO 110094
110090: GO 110053
110092: POP
110093: POP
// end ;
110094: LD_VAR 0 4
110098: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
110099: LD_INT 0
110101: PPUSH
110102: PPUSH
110103: PPUSH
110104: PPUSH
110105: PPUSH
110106: PPUSH
110107: PPUSH
// if not GetClass ( unit ) = class_sniper then
110108: LD_VAR 0 1
110112: PPUSH
110113: CALL_OW 257
110117: PUSH
110118: LD_INT 5
110120: EQUAL
110121: NOT
110122: IFFALSE 110126
// exit ;
110124: GO 110514
// dist := 8 ;
110126: LD_ADDR_VAR 0 5
110130: PUSH
110131: LD_INT 8
110133: ST_TO_ADDR
// viewRange := 12 ;
110134: LD_ADDR_VAR 0 7
110138: PUSH
110139: LD_INT 12
110141: ST_TO_ADDR
// side := GetSide ( unit ) ;
110142: LD_ADDR_VAR 0 6
110146: PUSH
110147: LD_VAR 0 1
110151: PPUSH
110152: CALL_OW 255
110156: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
110157: LD_INT 61
110159: PPUSH
110160: LD_VAR 0 6
110164: PPUSH
110165: CALL_OW 321
110169: PUSH
110170: LD_INT 2
110172: EQUAL
110173: IFFALSE 110183
// viewRange := 16 ;
110175: LD_ADDR_VAR 0 7
110179: PUSH
110180: LD_INT 16
110182: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
110183: LD_VAR 0 1
110187: PPUSH
110188: LD_VAR 0 2
110192: PPUSH
110193: LD_VAR 0 3
110197: PPUSH
110198: CALL_OW 297
110202: PUSH
110203: LD_VAR 0 5
110207: GREATER
110208: IFFALSE 110287
// begin ComMoveXY ( unit , x , y ) ;
110210: LD_VAR 0 1
110214: PPUSH
110215: LD_VAR 0 2
110219: PPUSH
110220: LD_VAR 0 3
110224: PPUSH
110225: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
110229: LD_INT 35
110231: PPUSH
110232: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
110236: LD_VAR 0 1
110240: PPUSH
110241: LD_VAR 0 2
110245: PPUSH
110246: LD_VAR 0 3
110250: PPUSH
110251: CALL 85174 0 3
110255: NOT
110256: IFFALSE 110260
// exit ;
110258: GO 110514
// until GetDistUnitXY ( unit , x , y ) < dist ;
110260: LD_VAR 0 1
110264: PPUSH
110265: LD_VAR 0 2
110269: PPUSH
110270: LD_VAR 0 3
110274: PPUSH
110275: CALL_OW 297
110279: PUSH
110280: LD_VAR 0 5
110284: LESS
110285: IFFALSE 110229
// end ; ComTurnXY ( unit , x , y ) ;
110287: LD_VAR 0 1
110291: PPUSH
110292: LD_VAR 0 2
110296: PPUSH
110297: LD_VAR 0 3
110301: PPUSH
110302: CALL_OW 118
// wait ( 5 ) ;
110306: LD_INT 5
110308: PPUSH
110309: CALL_OW 67
// _d := GetDir ( unit ) ;
110313: LD_ADDR_VAR 0 10
110317: PUSH
110318: LD_VAR 0 1
110322: PPUSH
110323: CALL_OW 254
110327: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
110328: LD_ADDR_VAR 0 8
110332: PUSH
110333: LD_VAR 0 1
110337: PPUSH
110338: CALL_OW 250
110342: PPUSH
110343: LD_VAR 0 10
110347: PPUSH
110348: LD_VAR 0 5
110352: PPUSH
110353: CALL_OW 272
110357: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
110358: LD_ADDR_VAR 0 9
110362: PUSH
110363: LD_VAR 0 1
110367: PPUSH
110368: CALL_OW 251
110372: PPUSH
110373: LD_VAR 0 10
110377: PPUSH
110378: LD_VAR 0 5
110382: PPUSH
110383: CALL_OW 273
110387: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
110388: LD_VAR 0 8
110392: PPUSH
110393: LD_VAR 0 9
110397: PPUSH
110398: CALL_OW 488
110402: NOT
110403: IFFALSE 110407
// exit ;
110405: GO 110514
// ComAnimCustom ( unit , 1 ) ;
110407: LD_VAR 0 1
110411: PPUSH
110412: LD_INT 1
110414: PPUSH
110415: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
110419: LD_VAR 0 8
110423: PPUSH
110424: LD_VAR 0 9
110428: PPUSH
110429: LD_VAR 0 6
110433: PPUSH
110434: LD_VAR 0 7
110438: PPUSH
110439: CALL_OW 330
// repeat wait ( 1 ) ;
110443: LD_INT 1
110445: PPUSH
110446: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
110450: LD_VAR 0 1
110454: PPUSH
110455: CALL_OW 316
110459: PUSH
110460: LD_VAR 0 1
110464: PPUSH
110465: CALL_OW 314
110469: OR
110470: PUSH
110471: LD_VAR 0 1
110475: PPUSH
110476: CALL_OW 302
110480: NOT
110481: OR
110482: PUSH
110483: LD_VAR 0 1
110487: PPUSH
110488: CALL_OW 301
110492: OR
110493: IFFALSE 110443
// RemoveSeeing ( _x , _y , side ) ;
110495: LD_VAR 0 8
110499: PPUSH
110500: LD_VAR 0 9
110504: PPUSH
110505: LD_VAR 0 6
110509: PPUSH
110510: CALL_OW 331
// end ; end_of_file
110514: LD_VAR 0 4
110518: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
110519: LD_INT 0
110521: PPUSH
110522: PPUSH
110523: PPUSH
110524: PPUSH
110525: PPUSH
110526: PPUSH
110527: PPUSH
110528: PPUSH
110529: PPUSH
110530: PPUSH
110531: PPUSH
110532: PPUSH
110533: PPUSH
110534: PPUSH
110535: PPUSH
110536: PPUSH
110537: PPUSH
110538: PPUSH
110539: PPUSH
110540: PPUSH
110541: PPUSH
110542: PPUSH
110543: PPUSH
110544: PPUSH
110545: PPUSH
110546: PPUSH
110547: PPUSH
110548: PPUSH
110549: PPUSH
110550: PPUSH
110551: PPUSH
110552: PPUSH
110553: PPUSH
110554: PPUSH
// if not list then
110555: LD_VAR 0 1
110559: NOT
110560: IFFALSE 110564
// exit ;
110562: GO 115223
// base := list [ 1 ] ;
110564: LD_ADDR_VAR 0 3
110568: PUSH
110569: LD_VAR 0 1
110573: PUSH
110574: LD_INT 1
110576: ARRAY
110577: ST_TO_ADDR
// group := list [ 2 ] ;
110578: LD_ADDR_VAR 0 4
110582: PUSH
110583: LD_VAR 0 1
110587: PUSH
110588: LD_INT 2
110590: ARRAY
110591: ST_TO_ADDR
// path := list [ 3 ] ;
110592: LD_ADDR_VAR 0 5
110596: PUSH
110597: LD_VAR 0 1
110601: PUSH
110602: LD_INT 3
110604: ARRAY
110605: ST_TO_ADDR
// flags := list [ 4 ] ;
110606: LD_ADDR_VAR 0 6
110610: PUSH
110611: LD_VAR 0 1
110615: PUSH
110616: LD_INT 4
110618: ARRAY
110619: ST_TO_ADDR
// mined := [ ] ;
110620: LD_ADDR_VAR 0 27
110624: PUSH
110625: EMPTY
110626: ST_TO_ADDR
// bombed := [ ] ;
110627: LD_ADDR_VAR 0 28
110631: PUSH
110632: EMPTY
110633: ST_TO_ADDR
// healers := [ ] ;
110634: LD_ADDR_VAR 0 31
110638: PUSH
110639: EMPTY
110640: ST_TO_ADDR
// to_heal := [ ] ;
110641: LD_ADDR_VAR 0 30
110645: PUSH
110646: EMPTY
110647: ST_TO_ADDR
// repairs := [ ] ;
110648: LD_ADDR_VAR 0 33
110652: PUSH
110653: EMPTY
110654: ST_TO_ADDR
// to_repair := [ ] ;
110655: LD_ADDR_VAR 0 32
110659: PUSH
110660: EMPTY
110661: ST_TO_ADDR
// if not group or not path then
110662: LD_VAR 0 4
110666: NOT
110667: PUSH
110668: LD_VAR 0 5
110672: NOT
110673: OR
110674: IFFALSE 110678
// exit ;
110676: GO 115223
// side := GetSide ( group [ 1 ] ) ;
110678: LD_ADDR_VAR 0 35
110682: PUSH
110683: LD_VAR 0 4
110687: PUSH
110688: LD_INT 1
110690: ARRAY
110691: PPUSH
110692: CALL_OW 255
110696: ST_TO_ADDR
// if flags then
110697: LD_VAR 0 6
110701: IFFALSE 110845
// begin f_ignore_area := flags [ 1 ] ;
110703: LD_ADDR_VAR 0 17
110707: PUSH
110708: LD_VAR 0 6
110712: PUSH
110713: LD_INT 1
110715: ARRAY
110716: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
110717: LD_ADDR_VAR 0 18
110721: PUSH
110722: LD_VAR 0 6
110726: PUSH
110727: LD_INT 2
110729: ARRAY
110730: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
110731: LD_ADDR_VAR 0 19
110735: PUSH
110736: LD_VAR 0 6
110740: PUSH
110741: LD_INT 3
110743: ARRAY
110744: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
110745: LD_ADDR_VAR 0 20
110749: PUSH
110750: LD_VAR 0 6
110754: PUSH
110755: LD_INT 4
110757: ARRAY
110758: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
110759: LD_ADDR_VAR 0 21
110763: PUSH
110764: LD_VAR 0 6
110768: PUSH
110769: LD_INT 5
110771: ARRAY
110772: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
110773: LD_ADDR_VAR 0 22
110777: PUSH
110778: LD_VAR 0 6
110782: PUSH
110783: LD_INT 6
110785: ARRAY
110786: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
110787: LD_ADDR_VAR 0 23
110791: PUSH
110792: LD_VAR 0 6
110796: PUSH
110797: LD_INT 7
110799: ARRAY
110800: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
110801: LD_ADDR_VAR 0 24
110805: PUSH
110806: LD_VAR 0 6
110810: PUSH
110811: LD_INT 8
110813: ARRAY
110814: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
110815: LD_ADDR_VAR 0 25
110819: PUSH
110820: LD_VAR 0 6
110824: PUSH
110825: LD_INT 9
110827: ARRAY
110828: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
110829: LD_ADDR_VAR 0 26
110833: PUSH
110834: LD_VAR 0 6
110838: PUSH
110839: LD_INT 10
110841: ARRAY
110842: ST_TO_ADDR
// end else
110843: GO 110925
// begin f_ignore_area := false ;
110845: LD_ADDR_VAR 0 17
110849: PUSH
110850: LD_INT 0
110852: ST_TO_ADDR
// f_capture := false ;
110853: LD_ADDR_VAR 0 18
110857: PUSH
110858: LD_INT 0
110860: ST_TO_ADDR
// f_ignore_civ := false ;
110861: LD_ADDR_VAR 0 19
110865: PUSH
110866: LD_INT 0
110868: ST_TO_ADDR
// f_murder := false ;
110869: LD_ADDR_VAR 0 20
110873: PUSH
110874: LD_INT 0
110876: ST_TO_ADDR
// f_mines := false ;
110877: LD_ADDR_VAR 0 21
110881: PUSH
110882: LD_INT 0
110884: ST_TO_ADDR
// f_repair := false ;
110885: LD_ADDR_VAR 0 22
110889: PUSH
110890: LD_INT 0
110892: ST_TO_ADDR
// f_heal := false ;
110893: LD_ADDR_VAR 0 23
110897: PUSH
110898: LD_INT 0
110900: ST_TO_ADDR
// f_spacetime := false ;
110901: LD_ADDR_VAR 0 24
110905: PUSH
110906: LD_INT 0
110908: ST_TO_ADDR
// f_attack_depot := false ;
110909: LD_ADDR_VAR 0 25
110913: PUSH
110914: LD_INT 0
110916: ST_TO_ADDR
// f_crawl := false ;
110917: LD_ADDR_VAR 0 26
110921: PUSH
110922: LD_INT 0
110924: ST_TO_ADDR
// end ; if f_heal then
110925: LD_VAR 0 23
110929: IFFALSE 110956
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
110931: LD_ADDR_VAR 0 31
110935: PUSH
110936: LD_VAR 0 4
110940: PPUSH
110941: LD_INT 25
110943: PUSH
110944: LD_INT 4
110946: PUSH
110947: EMPTY
110948: LIST
110949: LIST
110950: PPUSH
110951: CALL_OW 72
110955: ST_TO_ADDR
// if f_repair then
110956: LD_VAR 0 22
110960: IFFALSE 110987
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
110962: LD_ADDR_VAR 0 33
110966: PUSH
110967: LD_VAR 0 4
110971: PPUSH
110972: LD_INT 25
110974: PUSH
110975: LD_INT 3
110977: PUSH
110978: EMPTY
110979: LIST
110980: LIST
110981: PPUSH
110982: CALL_OW 72
110986: ST_TO_ADDR
// units_path := [ ] ;
110987: LD_ADDR_VAR 0 16
110991: PUSH
110992: EMPTY
110993: ST_TO_ADDR
// for i = 1 to group do
110994: LD_ADDR_VAR 0 7
110998: PUSH
110999: DOUBLE
111000: LD_INT 1
111002: DEC
111003: ST_TO_ADDR
111004: LD_VAR 0 4
111008: PUSH
111009: FOR_TO
111010: IFFALSE 111039
// units_path := Replace ( units_path , i , path ) ;
111012: LD_ADDR_VAR 0 16
111016: PUSH
111017: LD_VAR 0 16
111021: PPUSH
111022: LD_VAR 0 7
111026: PPUSH
111027: LD_VAR 0 5
111031: PPUSH
111032: CALL_OW 1
111036: ST_TO_ADDR
111037: GO 111009
111039: POP
111040: POP
// repeat for i = group downto 1 do
111041: LD_ADDR_VAR 0 7
111045: PUSH
111046: DOUBLE
111047: LD_VAR 0 4
111051: INC
111052: ST_TO_ADDR
111053: LD_INT 1
111055: PUSH
111056: FOR_DOWNTO
111057: IFFALSE 115179
// begin wait ( 5 ) ;
111059: LD_INT 5
111061: PPUSH
111062: CALL_OW 67
// tmp := [ ] ;
111066: LD_ADDR_VAR 0 14
111070: PUSH
111071: EMPTY
111072: ST_TO_ADDR
// attacking := false ;
111073: LD_ADDR_VAR 0 29
111077: PUSH
111078: LD_INT 0
111080: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
111081: LD_VAR 0 4
111085: PUSH
111086: LD_VAR 0 7
111090: ARRAY
111091: PPUSH
111092: CALL_OW 301
111096: PUSH
111097: LD_VAR 0 4
111101: PUSH
111102: LD_VAR 0 7
111106: ARRAY
111107: NOT
111108: OR
111109: IFFALSE 111218
// begin if GetType ( group [ i ] ) = unit_human then
111111: LD_VAR 0 4
111115: PUSH
111116: LD_VAR 0 7
111120: ARRAY
111121: PPUSH
111122: CALL_OW 247
111126: PUSH
111127: LD_INT 1
111129: EQUAL
111130: IFFALSE 111176
// begin to_heal := to_heal diff group [ i ] ;
111132: LD_ADDR_VAR 0 30
111136: PUSH
111137: LD_VAR 0 30
111141: PUSH
111142: LD_VAR 0 4
111146: PUSH
111147: LD_VAR 0 7
111151: ARRAY
111152: DIFF
111153: ST_TO_ADDR
// healers := healers diff group [ i ] ;
111154: LD_ADDR_VAR 0 31
111158: PUSH
111159: LD_VAR 0 31
111163: PUSH
111164: LD_VAR 0 4
111168: PUSH
111169: LD_VAR 0 7
111173: ARRAY
111174: DIFF
111175: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
111176: LD_ADDR_VAR 0 4
111180: PUSH
111181: LD_VAR 0 4
111185: PPUSH
111186: LD_VAR 0 7
111190: PPUSH
111191: CALL_OW 3
111195: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
111196: LD_ADDR_VAR 0 16
111200: PUSH
111201: LD_VAR 0 16
111205: PPUSH
111206: LD_VAR 0 7
111210: PPUSH
111211: CALL_OW 3
111215: ST_TO_ADDR
// continue ;
111216: GO 111056
// end ; if f_repair then
111218: LD_VAR 0 22
111222: IFFALSE 111711
// begin if GetType ( group [ i ] ) = unit_vehicle then
111224: LD_VAR 0 4
111228: PUSH
111229: LD_VAR 0 7
111233: ARRAY
111234: PPUSH
111235: CALL_OW 247
111239: PUSH
111240: LD_INT 2
111242: EQUAL
111243: IFFALSE 111433
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
111245: LD_VAR 0 4
111249: PUSH
111250: LD_VAR 0 7
111254: ARRAY
111255: PPUSH
111256: CALL_OW 256
111260: PUSH
111261: LD_INT 700
111263: LESS
111264: PUSH
111265: LD_VAR 0 4
111269: PUSH
111270: LD_VAR 0 7
111274: ARRAY
111275: PUSH
111276: LD_VAR 0 32
111280: IN
111281: NOT
111282: AND
111283: IFFALSE 111307
// to_repair := to_repair union group [ i ] ;
111285: LD_ADDR_VAR 0 32
111289: PUSH
111290: LD_VAR 0 32
111294: PUSH
111295: LD_VAR 0 4
111299: PUSH
111300: LD_VAR 0 7
111304: ARRAY
111305: UNION
111306: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
111307: LD_VAR 0 4
111311: PUSH
111312: LD_VAR 0 7
111316: ARRAY
111317: PPUSH
111318: CALL_OW 256
111322: PUSH
111323: LD_INT 1000
111325: EQUAL
111326: PUSH
111327: LD_VAR 0 4
111331: PUSH
111332: LD_VAR 0 7
111336: ARRAY
111337: PUSH
111338: LD_VAR 0 32
111342: IN
111343: AND
111344: IFFALSE 111368
// to_repair := to_repair diff group [ i ] ;
111346: LD_ADDR_VAR 0 32
111350: PUSH
111351: LD_VAR 0 32
111355: PUSH
111356: LD_VAR 0 4
111360: PUSH
111361: LD_VAR 0 7
111365: ARRAY
111366: DIFF
111367: ST_TO_ADDR
// if group [ i ] in to_repair then
111368: LD_VAR 0 4
111372: PUSH
111373: LD_VAR 0 7
111377: ARRAY
111378: PUSH
111379: LD_VAR 0 32
111383: IN
111384: IFFALSE 111431
// begin if not IsInArea ( group [ i ] , f_repair ) then
111386: LD_VAR 0 4
111390: PUSH
111391: LD_VAR 0 7
111395: ARRAY
111396: PPUSH
111397: LD_VAR 0 22
111401: PPUSH
111402: CALL_OW 308
111406: NOT
111407: IFFALSE 111429
// ComMoveToArea ( group [ i ] , f_repair ) ;
111409: LD_VAR 0 4
111413: PUSH
111414: LD_VAR 0 7
111418: ARRAY
111419: PPUSH
111420: LD_VAR 0 22
111424: PPUSH
111425: CALL_OW 113
// continue ;
111429: GO 111056
// end ; end else
111431: GO 111711
// if group [ i ] in repairs then
111433: LD_VAR 0 4
111437: PUSH
111438: LD_VAR 0 7
111442: ARRAY
111443: PUSH
111444: LD_VAR 0 33
111448: IN
111449: IFFALSE 111711
// begin if IsInUnit ( group [ i ] ) then
111451: LD_VAR 0 4
111455: PUSH
111456: LD_VAR 0 7
111460: ARRAY
111461: PPUSH
111462: CALL_OW 310
111466: IFFALSE 111534
// begin z := IsInUnit ( group [ i ] ) ;
111468: LD_ADDR_VAR 0 13
111472: PUSH
111473: LD_VAR 0 4
111477: PUSH
111478: LD_VAR 0 7
111482: ARRAY
111483: PPUSH
111484: CALL_OW 310
111488: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
111489: LD_VAR 0 13
111493: PUSH
111494: LD_VAR 0 32
111498: IN
111499: PUSH
111500: LD_VAR 0 13
111504: PPUSH
111505: LD_VAR 0 22
111509: PPUSH
111510: CALL_OW 308
111514: AND
111515: IFFALSE 111532
// ComExitVehicle ( group [ i ] ) ;
111517: LD_VAR 0 4
111521: PUSH
111522: LD_VAR 0 7
111526: ARRAY
111527: PPUSH
111528: CALL_OW 121
// end else
111532: GO 111711
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
111534: LD_ADDR_VAR 0 13
111538: PUSH
111539: LD_VAR 0 4
111543: PPUSH
111544: LD_INT 95
111546: PUSH
111547: LD_VAR 0 22
111551: PUSH
111552: EMPTY
111553: LIST
111554: LIST
111555: PUSH
111556: LD_INT 58
111558: PUSH
111559: EMPTY
111560: LIST
111561: PUSH
111562: EMPTY
111563: LIST
111564: LIST
111565: PPUSH
111566: CALL_OW 72
111570: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
111571: LD_VAR 0 4
111575: PUSH
111576: LD_VAR 0 7
111580: ARRAY
111581: PPUSH
111582: CALL_OW 314
111586: NOT
111587: IFFALSE 111709
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
111589: LD_ADDR_VAR 0 10
111593: PUSH
111594: LD_VAR 0 13
111598: PPUSH
111599: LD_VAR 0 4
111603: PUSH
111604: LD_VAR 0 7
111608: ARRAY
111609: PPUSH
111610: CALL_OW 74
111614: ST_TO_ADDR
// if not x then
111615: LD_VAR 0 10
111619: NOT
111620: IFFALSE 111624
// continue ;
111622: GO 111056
// if GetLives ( x ) < 1000 then
111624: LD_VAR 0 10
111628: PPUSH
111629: CALL_OW 256
111633: PUSH
111634: LD_INT 1000
111636: LESS
111637: IFFALSE 111661
// ComRepairVehicle ( group [ i ] , x ) else
111639: LD_VAR 0 4
111643: PUSH
111644: LD_VAR 0 7
111648: ARRAY
111649: PPUSH
111650: LD_VAR 0 10
111654: PPUSH
111655: CALL_OW 129
111659: GO 111709
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
111661: LD_VAR 0 23
111665: PUSH
111666: LD_VAR 0 4
111670: PUSH
111671: LD_VAR 0 7
111675: ARRAY
111676: PPUSH
111677: CALL_OW 256
111681: PUSH
111682: LD_INT 1000
111684: LESS
111685: AND
111686: NOT
111687: IFFALSE 111709
// ComEnterUnit ( group [ i ] , x ) ;
111689: LD_VAR 0 4
111693: PUSH
111694: LD_VAR 0 7
111698: ARRAY
111699: PPUSH
111700: LD_VAR 0 10
111704: PPUSH
111705: CALL_OW 120
// end ; continue ;
111709: GO 111056
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
111711: LD_VAR 0 23
111715: PUSH
111716: LD_VAR 0 4
111720: PUSH
111721: LD_VAR 0 7
111725: ARRAY
111726: PPUSH
111727: CALL_OW 247
111731: PUSH
111732: LD_INT 1
111734: EQUAL
111735: AND
111736: IFFALSE 112214
// begin if group [ i ] in healers then
111738: LD_VAR 0 4
111742: PUSH
111743: LD_VAR 0 7
111747: ARRAY
111748: PUSH
111749: LD_VAR 0 31
111753: IN
111754: IFFALSE 112027
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
111756: LD_VAR 0 4
111760: PUSH
111761: LD_VAR 0 7
111765: ARRAY
111766: PPUSH
111767: LD_VAR 0 23
111771: PPUSH
111772: CALL_OW 308
111776: NOT
111777: PUSH
111778: LD_VAR 0 4
111782: PUSH
111783: LD_VAR 0 7
111787: ARRAY
111788: PPUSH
111789: CALL_OW 314
111793: NOT
111794: AND
111795: IFFALSE 111819
// ComMoveToArea ( group [ i ] , f_heal ) else
111797: LD_VAR 0 4
111801: PUSH
111802: LD_VAR 0 7
111806: ARRAY
111807: PPUSH
111808: LD_VAR 0 23
111812: PPUSH
111813: CALL_OW 113
111817: GO 112025
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
111819: LD_VAR 0 4
111823: PUSH
111824: LD_VAR 0 7
111828: ARRAY
111829: PPUSH
111830: CALL 83757 0 1
111834: PPUSH
111835: CALL_OW 256
111839: PUSH
111840: LD_INT 1000
111842: EQUAL
111843: IFFALSE 111862
// ComStop ( group [ i ] ) else
111845: LD_VAR 0 4
111849: PUSH
111850: LD_VAR 0 7
111854: ARRAY
111855: PPUSH
111856: CALL_OW 141
111860: GO 112025
// if not HasTask ( group [ i ] ) and to_heal then
111862: LD_VAR 0 4
111866: PUSH
111867: LD_VAR 0 7
111871: ARRAY
111872: PPUSH
111873: CALL_OW 314
111877: NOT
111878: PUSH
111879: LD_VAR 0 30
111883: AND
111884: IFFALSE 112025
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
111886: LD_ADDR_VAR 0 13
111890: PUSH
111891: LD_VAR 0 30
111895: PPUSH
111896: LD_INT 3
111898: PUSH
111899: LD_INT 54
111901: PUSH
111902: EMPTY
111903: LIST
111904: PUSH
111905: EMPTY
111906: LIST
111907: LIST
111908: PPUSH
111909: CALL_OW 72
111913: PPUSH
111914: LD_VAR 0 4
111918: PUSH
111919: LD_VAR 0 7
111923: ARRAY
111924: PPUSH
111925: CALL_OW 74
111929: ST_TO_ADDR
// if z then
111930: LD_VAR 0 13
111934: IFFALSE 112025
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
111936: LD_INT 91
111938: PUSH
111939: LD_VAR 0 13
111943: PUSH
111944: LD_INT 10
111946: PUSH
111947: EMPTY
111948: LIST
111949: LIST
111950: LIST
111951: PUSH
111952: LD_INT 81
111954: PUSH
111955: LD_VAR 0 13
111959: PPUSH
111960: CALL_OW 255
111964: PUSH
111965: EMPTY
111966: LIST
111967: LIST
111968: PUSH
111969: EMPTY
111970: LIST
111971: LIST
111972: PPUSH
111973: CALL_OW 69
111977: PUSH
111978: LD_INT 0
111980: EQUAL
111981: IFFALSE 112005
// ComHeal ( group [ i ] , z ) else
111983: LD_VAR 0 4
111987: PUSH
111988: LD_VAR 0 7
111992: ARRAY
111993: PPUSH
111994: LD_VAR 0 13
111998: PPUSH
111999: CALL_OW 128
112003: GO 112025
// ComMoveToArea ( group [ i ] , f_heal ) ;
112005: LD_VAR 0 4
112009: PUSH
112010: LD_VAR 0 7
112014: ARRAY
112015: PPUSH
112016: LD_VAR 0 23
112020: PPUSH
112021: CALL_OW 113
// end ; continue ;
112025: GO 111056
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
112027: LD_VAR 0 4
112031: PUSH
112032: LD_VAR 0 7
112036: ARRAY
112037: PPUSH
112038: CALL_OW 256
112042: PUSH
112043: LD_INT 700
112045: LESS
112046: PUSH
112047: LD_VAR 0 4
112051: PUSH
112052: LD_VAR 0 7
112056: ARRAY
112057: PUSH
112058: LD_VAR 0 30
112062: IN
112063: NOT
112064: AND
112065: IFFALSE 112089
// to_heal := to_heal union group [ i ] ;
112067: LD_ADDR_VAR 0 30
112071: PUSH
112072: LD_VAR 0 30
112076: PUSH
112077: LD_VAR 0 4
112081: PUSH
112082: LD_VAR 0 7
112086: ARRAY
112087: UNION
112088: ST_TO_ADDR
// if group [ i ] in to_heal then
112089: LD_VAR 0 4
112093: PUSH
112094: LD_VAR 0 7
112098: ARRAY
112099: PUSH
112100: LD_VAR 0 30
112104: IN
112105: IFFALSE 112214
// begin if GetLives ( group [ i ] ) = 1000 then
112107: LD_VAR 0 4
112111: PUSH
112112: LD_VAR 0 7
112116: ARRAY
112117: PPUSH
112118: CALL_OW 256
112122: PUSH
112123: LD_INT 1000
112125: EQUAL
112126: IFFALSE 112152
// to_heal := to_heal diff group [ i ] else
112128: LD_ADDR_VAR 0 30
112132: PUSH
112133: LD_VAR 0 30
112137: PUSH
112138: LD_VAR 0 4
112142: PUSH
112143: LD_VAR 0 7
112147: ARRAY
112148: DIFF
112149: ST_TO_ADDR
112150: GO 112214
// begin if not IsInArea ( group [ i ] , to_heal ) then
112152: LD_VAR 0 4
112156: PUSH
112157: LD_VAR 0 7
112161: ARRAY
112162: PPUSH
112163: LD_VAR 0 30
112167: PPUSH
112168: CALL_OW 308
112172: NOT
112173: IFFALSE 112197
// ComMoveToArea ( group [ i ] , f_heal ) else
112175: LD_VAR 0 4
112179: PUSH
112180: LD_VAR 0 7
112184: ARRAY
112185: PPUSH
112186: LD_VAR 0 23
112190: PPUSH
112191: CALL_OW 113
112195: GO 112212
// ComHold ( group [ i ] ) ;
112197: LD_VAR 0 4
112201: PUSH
112202: LD_VAR 0 7
112206: ARRAY
112207: PPUSH
112208: CALL_OW 140
// continue ;
112212: GO 111056
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
112214: LD_VAR 0 4
112218: PUSH
112219: LD_VAR 0 7
112223: ARRAY
112224: PPUSH
112225: LD_INT 10
112227: PPUSH
112228: CALL 81528 0 2
112232: NOT
112233: PUSH
112234: LD_VAR 0 16
112238: PUSH
112239: LD_VAR 0 7
112243: ARRAY
112244: PUSH
112245: EMPTY
112246: EQUAL
112247: NOT
112248: AND
112249: IFFALSE 112515
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
112251: LD_VAR 0 4
112255: PUSH
112256: LD_VAR 0 7
112260: ARRAY
112261: PPUSH
112262: CALL_OW 262
112266: PUSH
112267: LD_INT 1
112269: PUSH
112270: LD_INT 2
112272: PUSH
112273: EMPTY
112274: LIST
112275: LIST
112276: IN
112277: IFFALSE 112318
// if GetFuel ( group [ i ] ) < 10 then
112279: LD_VAR 0 4
112283: PUSH
112284: LD_VAR 0 7
112288: ARRAY
112289: PPUSH
112290: CALL_OW 261
112294: PUSH
112295: LD_INT 10
112297: LESS
112298: IFFALSE 112318
// SetFuel ( group [ i ] , 12 ) ;
112300: LD_VAR 0 4
112304: PUSH
112305: LD_VAR 0 7
112309: ARRAY
112310: PPUSH
112311: LD_INT 12
112313: PPUSH
112314: CALL_OW 240
// if units_path [ i ] then
112318: LD_VAR 0 16
112322: PUSH
112323: LD_VAR 0 7
112327: ARRAY
112328: IFFALSE 112513
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
112330: LD_VAR 0 4
112334: PUSH
112335: LD_VAR 0 7
112339: ARRAY
112340: PPUSH
112341: LD_VAR 0 16
112345: PUSH
112346: LD_VAR 0 7
112350: ARRAY
112351: PUSH
112352: LD_INT 1
112354: ARRAY
112355: PUSH
112356: LD_INT 1
112358: ARRAY
112359: PPUSH
112360: LD_VAR 0 16
112364: PUSH
112365: LD_VAR 0 7
112369: ARRAY
112370: PUSH
112371: LD_INT 1
112373: ARRAY
112374: PUSH
112375: LD_INT 2
112377: ARRAY
112378: PPUSH
112379: CALL_OW 297
112383: PUSH
112384: LD_INT 6
112386: GREATER
112387: IFFALSE 112462
// begin if not HasTask ( group [ i ] ) then
112389: LD_VAR 0 4
112393: PUSH
112394: LD_VAR 0 7
112398: ARRAY
112399: PPUSH
112400: CALL_OW 314
112404: NOT
112405: IFFALSE 112460
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
112407: LD_VAR 0 4
112411: PUSH
112412: LD_VAR 0 7
112416: ARRAY
112417: PPUSH
112418: LD_VAR 0 16
112422: PUSH
112423: LD_VAR 0 7
112427: ARRAY
112428: PUSH
112429: LD_INT 1
112431: ARRAY
112432: PUSH
112433: LD_INT 1
112435: ARRAY
112436: PPUSH
112437: LD_VAR 0 16
112441: PUSH
112442: LD_VAR 0 7
112446: ARRAY
112447: PUSH
112448: LD_INT 1
112450: ARRAY
112451: PUSH
112452: LD_INT 2
112454: ARRAY
112455: PPUSH
112456: CALL_OW 114
// end else
112460: GO 112513
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
112462: LD_ADDR_VAR 0 15
112466: PUSH
112467: LD_VAR 0 16
112471: PUSH
112472: LD_VAR 0 7
112476: ARRAY
112477: PPUSH
112478: LD_INT 1
112480: PPUSH
112481: CALL_OW 3
112485: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
112486: LD_ADDR_VAR 0 16
112490: PUSH
112491: LD_VAR 0 16
112495: PPUSH
112496: LD_VAR 0 7
112500: PPUSH
112501: LD_VAR 0 15
112505: PPUSH
112506: CALL_OW 1
112510: ST_TO_ADDR
// continue ;
112511: GO 111056
// end ; end ; end else
112513: GO 115177
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
112515: LD_ADDR_VAR 0 14
112519: PUSH
112520: LD_INT 81
112522: PUSH
112523: LD_VAR 0 4
112527: PUSH
112528: LD_VAR 0 7
112532: ARRAY
112533: PPUSH
112534: CALL_OW 255
112538: PUSH
112539: EMPTY
112540: LIST
112541: LIST
112542: PPUSH
112543: CALL_OW 69
112547: ST_TO_ADDR
// if not tmp then
112548: LD_VAR 0 14
112552: NOT
112553: IFFALSE 112557
// continue ;
112555: GO 111056
// if f_ignore_area then
112557: LD_VAR 0 17
112561: IFFALSE 112649
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
112563: LD_ADDR_VAR 0 15
112567: PUSH
112568: LD_VAR 0 14
112572: PPUSH
112573: LD_INT 3
112575: PUSH
112576: LD_INT 92
112578: PUSH
112579: LD_VAR 0 17
112583: PUSH
112584: LD_INT 1
112586: ARRAY
112587: PUSH
112588: LD_VAR 0 17
112592: PUSH
112593: LD_INT 2
112595: ARRAY
112596: PUSH
112597: LD_VAR 0 17
112601: PUSH
112602: LD_INT 3
112604: ARRAY
112605: PUSH
112606: EMPTY
112607: LIST
112608: LIST
112609: LIST
112610: LIST
112611: PUSH
112612: EMPTY
112613: LIST
112614: LIST
112615: PPUSH
112616: CALL_OW 72
112620: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
112621: LD_VAR 0 14
112625: PUSH
112626: LD_VAR 0 15
112630: DIFF
112631: IFFALSE 112649
// tmp := tmp diff tmp2 ;
112633: LD_ADDR_VAR 0 14
112637: PUSH
112638: LD_VAR 0 14
112642: PUSH
112643: LD_VAR 0 15
112647: DIFF
112648: ST_TO_ADDR
// end ; if not f_murder then
112649: LD_VAR 0 20
112653: NOT
112654: IFFALSE 112712
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
112656: LD_ADDR_VAR 0 15
112660: PUSH
112661: LD_VAR 0 14
112665: PPUSH
112666: LD_INT 3
112668: PUSH
112669: LD_INT 50
112671: PUSH
112672: EMPTY
112673: LIST
112674: PUSH
112675: EMPTY
112676: LIST
112677: LIST
112678: PPUSH
112679: CALL_OW 72
112683: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
112684: LD_VAR 0 14
112688: PUSH
112689: LD_VAR 0 15
112693: DIFF
112694: IFFALSE 112712
// tmp := tmp diff tmp2 ;
112696: LD_ADDR_VAR 0 14
112700: PUSH
112701: LD_VAR 0 14
112705: PUSH
112706: LD_VAR 0 15
112710: DIFF
112711: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
112712: LD_ADDR_VAR 0 14
112716: PUSH
112717: LD_VAR 0 4
112721: PUSH
112722: LD_VAR 0 7
112726: ARRAY
112727: PPUSH
112728: LD_VAR 0 14
112732: PPUSH
112733: LD_INT 1
112735: PPUSH
112736: LD_INT 1
112738: PPUSH
112739: CALL 54469 0 4
112743: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
112744: LD_VAR 0 4
112748: PUSH
112749: LD_VAR 0 7
112753: ARRAY
112754: PPUSH
112755: CALL_OW 257
112759: PUSH
112760: LD_INT 1
112762: EQUAL
112763: IFFALSE 113211
// begin if WantPlant ( group [ i ] ) then
112765: LD_VAR 0 4
112769: PUSH
112770: LD_VAR 0 7
112774: ARRAY
112775: PPUSH
112776: CALL 53970 0 1
112780: IFFALSE 112784
// continue ;
112782: GO 111056
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
112784: LD_VAR 0 18
112788: PUSH
112789: LD_VAR 0 4
112793: PUSH
112794: LD_VAR 0 7
112798: ARRAY
112799: PPUSH
112800: CALL_OW 310
112804: NOT
112805: AND
112806: PUSH
112807: LD_VAR 0 14
112811: PUSH
112812: LD_INT 1
112814: ARRAY
112815: PUSH
112816: LD_VAR 0 14
112820: PPUSH
112821: LD_INT 21
112823: PUSH
112824: LD_INT 2
112826: PUSH
112827: EMPTY
112828: LIST
112829: LIST
112830: PUSH
112831: LD_INT 58
112833: PUSH
112834: EMPTY
112835: LIST
112836: PUSH
112837: EMPTY
112838: LIST
112839: LIST
112840: PPUSH
112841: CALL_OW 72
112845: IN
112846: AND
112847: IFFALSE 112883
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
112849: LD_VAR 0 4
112853: PUSH
112854: LD_VAR 0 7
112858: ARRAY
112859: PPUSH
112860: LD_VAR 0 14
112864: PUSH
112865: LD_INT 1
112867: ARRAY
112868: PPUSH
112869: CALL_OW 120
// attacking := true ;
112873: LD_ADDR_VAR 0 29
112877: PUSH
112878: LD_INT 1
112880: ST_TO_ADDR
// continue ;
112881: GO 111056
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
112883: LD_VAR 0 26
112887: PUSH
112888: LD_VAR 0 4
112892: PUSH
112893: LD_VAR 0 7
112897: ARRAY
112898: PPUSH
112899: CALL_OW 257
112903: PUSH
112904: LD_INT 1
112906: EQUAL
112907: AND
112908: PUSH
112909: LD_VAR 0 4
112913: PUSH
112914: LD_VAR 0 7
112918: ARRAY
112919: PPUSH
112920: CALL_OW 256
112924: PUSH
112925: LD_INT 800
112927: LESS
112928: AND
112929: PUSH
112930: LD_VAR 0 4
112934: PUSH
112935: LD_VAR 0 7
112939: ARRAY
112940: PPUSH
112941: CALL_OW 318
112945: NOT
112946: AND
112947: IFFALSE 112964
// ComCrawl ( group [ i ] ) ;
112949: LD_VAR 0 4
112953: PUSH
112954: LD_VAR 0 7
112958: ARRAY
112959: PPUSH
112960: CALL_OW 137
// if f_mines then
112964: LD_VAR 0 21
112968: IFFALSE 113211
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
112970: LD_VAR 0 14
112974: PUSH
112975: LD_INT 1
112977: ARRAY
112978: PPUSH
112979: CALL_OW 247
112983: PUSH
112984: LD_INT 3
112986: EQUAL
112987: PUSH
112988: LD_VAR 0 14
112992: PUSH
112993: LD_INT 1
112995: ARRAY
112996: PUSH
112997: LD_VAR 0 27
113001: IN
113002: NOT
113003: AND
113004: IFFALSE 113211
// begin x := GetX ( tmp [ 1 ] ) ;
113006: LD_ADDR_VAR 0 10
113010: PUSH
113011: LD_VAR 0 14
113015: PUSH
113016: LD_INT 1
113018: ARRAY
113019: PPUSH
113020: CALL_OW 250
113024: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
113025: LD_ADDR_VAR 0 11
113029: PUSH
113030: LD_VAR 0 14
113034: PUSH
113035: LD_INT 1
113037: ARRAY
113038: PPUSH
113039: CALL_OW 251
113043: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
113044: LD_ADDR_VAR 0 12
113048: PUSH
113049: LD_VAR 0 4
113053: PUSH
113054: LD_VAR 0 7
113058: ARRAY
113059: PPUSH
113060: CALL 81613 0 1
113064: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
113065: LD_VAR 0 4
113069: PUSH
113070: LD_VAR 0 7
113074: ARRAY
113075: PPUSH
113076: LD_VAR 0 10
113080: PPUSH
113081: LD_VAR 0 11
113085: PPUSH
113086: LD_VAR 0 14
113090: PUSH
113091: LD_INT 1
113093: ARRAY
113094: PPUSH
113095: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
113099: LD_VAR 0 4
113103: PUSH
113104: LD_VAR 0 7
113108: ARRAY
113109: PPUSH
113110: LD_VAR 0 10
113114: PPUSH
113115: LD_VAR 0 12
113119: PPUSH
113120: LD_INT 7
113122: PPUSH
113123: CALL_OW 272
113127: PPUSH
113128: LD_VAR 0 11
113132: PPUSH
113133: LD_VAR 0 12
113137: PPUSH
113138: LD_INT 7
113140: PPUSH
113141: CALL_OW 273
113145: PPUSH
113146: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
113150: LD_VAR 0 4
113154: PUSH
113155: LD_VAR 0 7
113159: ARRAY
113160: PPUSH
113161: LD_INT 71
113163: PPUSH
113164: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
113168: LD_ADDR_VAR 0 27
113172: PUSH
113173: LD_VAR 0 27
113177: PPUSH
113178: LD_VAR 0 27
113182: PUSH
113183: LD_INT 1
113185: PLUS
113186: PPUSH
113187: LD_VAR 0 14
113191: PUSH
113192: LD_INT 1
113194: ARRAY
113195: PPUSH
113196: CALL_OW 1
113200: ST_TO_ADDR
// attacking := true ;
113201: LD_ADDR_VAR 0 29
113205: PUSH
113206: LD_INT 1
113208: ST_TO_ADDR
// continue ;
113209: GO 111056
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
113211: LD_VAR 0 4
113215: PUSH
113216: LD_VAR 0 7
113220: ARRAY
113221: PPUSH
113222: CALL_OW 257
113226: PUSH
113227: LD_INT 17
113229: EQUAL
113230: PUSH
113231: LD_VAR 0 4
113235: PUSH
113236: LD_VAR 0 7
113240: ARRAY
113241: PPUSH
113242: CALL_OW 110
113246: PUSH
113247: LD_INT 71
113249: EQUAL
113250: NOT
113251: AND
113252: IFFALSE 113398
// begin attacking := false ;
113254: LD_ADDR_VAR 0 29
113258: PUSH
113259: LD_INT 0
113261: ST_TO_ADDR
// k := 5 ;
113262: LD_ADDR_VAR 0 9
113266: PUSH
113267: LD_INT 5
113269: ST_TO_ADDR
// if tmp < k then
113270: LD_VAR 0 14
113274: PUSH
113275: LD_VAR 0 9
113279: LESS
113280: IFFALSE 113292
// k := tmp ;
113282: LD_ADDR_VAR 0 9
113286: PUSH
113287: LD_VAR 0 14
113291: ST_TO_ADDR
// for j = 1 to k do
113292: LD_ADDR_VAR 0 8
113296: PUSH
113297: DOUBLE
113298: LD_INT 1
113300: DEC
113301: ST_TO_ADDR
113302: LD_VAR 0 9
113306: PUSH
113307: FOR_TO
113308: IFFALSE 113396
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
113310: LD_VAR 0 14
113314: PUSH
113315: LD_VAR 0 8
113319: ARRAY
113320: PUSH
113321: LD_VAR 0 14
113325: PPUSH
113326: LD_INT 58
113328: PUSH
113329: EMPTY
113330: LIST
113331: PPUSH
113332: CALL_OW 72
113336: IN
113337: NOT
113338: IFFALSE 113394
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
113340: LD_VAR 0 4
113344: PUSH
113345: LD_VAR 0 7
113349: ARRAY
113350: PPUSH
113351: LD_VAR 0 14
113355: PUSH
113356: LD_VAR 0 8
113360: ARRAY
113361: PPUSH
113362: CALL_OW 115
// attacking := true ;
113366: LD_ADDR_VAR 0 29
113370: PUSH
113371: LD_INT 1
113373: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
113374: LD_VAR 0 4
113378: PUSH
113379: LD_VAR 0 7
113383: ARRAY
113384: PPUSH
113385: LD_INT 71
113387: PPUSH
113388: CALL_OW 109
// continue ;
113392: GO 113307
// end ; end ;
113394: GO 113307
113396: POP
113397: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
113398: LD_VAR 0 4
113402: PUSH
113403: LD_VAR 0 7
113407: ARRAY
113408: PPUSH
113409: CALL_OW 257
113413: PUSH
113414: LD_INT 8
113416: EQUAL
113417: PUSH
113418: LD_VAR 0 4
113422: PUSH
113423: LD_VAR 0 7
113427: ARRAY
113428: PPUSH
113429: CALL_OW 264
113433: PUSH
113434: LD_INT 28
113436: PUSH
113437: LD_INT 45
113439: PUSH
113440: LD_INT 7
113442: PUSH
113443: LD_INT 47
113445: PUSH
113446: EMPTY
113447: LIST
113448: LIST
113449: LIST
113450: LIST
113451: IN
113452: OR
113453: IFFALSE 113709
// begin attacking := false ;
113455: LD_ADDR_VAR 0 29
113459: PUSH
113460: LD_INT 0
113462: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
113463: LD_VAR 0 14
113467: PUSH
113468: LD_INT 1
113470: ARRAY
113471: PPUSH
113472: CALL_OW 266
113476: PUSH
113477: LD_INT 32
113479: PUSH
113480: LD_INT 31
113482: PUSH
113483: LD_INT 33
113485: PUSH
113486: LD_INT 4
113488: PUSH
113489: LD_INT 5
113491: PUSH
113492: EMPTY
113493: LIST
113494: LIST
113495: LIST
113496: LIST
113497: LIST
113498: IN
113499: IFFALSE 113685
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
113501: LD_ADDR_VAR 0 9
113505: PUSH
113506: LD_VAR 0 14
113510: PUSH
113511: LD_INT 1
113513: ARRAY
113514: PPUSH
113515: CALL_OW 266
113519: PPUSH
113520: LD_VAR 0 14
113524: PUSH
113525: LD_INT 1
113527: ARRAY
113528: PPUSH
113529: CALL_OW 250
113533: PPUSH
113534: LD_VAR 0 14
113538: PUSH
113539: LD_INT 1
113541: ARRAY
113542: PPUSH
113543: CALL_OW 251
113547: PPUSH
113548: LD_VAR 0 14
113552: PUSH
113553: LD_INT 1
113555: ARRAY
113556: PPUSH
113557: CALL_OW 254
113561: PPUSH
113562: LD_VAR 0 14
113566: PUSH
113567: LD_INT 1
113569: ARRAY
113570: PPUSH
113571: CALL_OW 248
113575: PPUSH
113576: LD_INT 0
113578: PPUSH
113579: CALL 62983 0 6
113583: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
113584: LD_ADDR_VAR 0 8
113588: PUSH
113589: LD_VAR 0 4
113593: PUSH
113594: LD_VAR 0 7
113598: ARRAY
113599: PPUSH
113600: LD_VAR 0 9
113604: PPUSH
113605: CALL 81726 0 2
113609: ST_TO_ADDR
// if j then
113610: LD_VAR 0 8
113614: IFFALSE 113683
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
113616: LD_VAR 0 8
113620: PUSH
113621: LD_INT 1
113623: ARRAY
113624: PPUSH
113625: LD_VAR 0 8
113629: PUSH
113630: LD_INT 2
113632: ARRAY
113633: PPUSH
113634: CALL_OW 488
113638: IFFALSE 113683
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
113640: LD_VAR 0 4
113644: PUSH
113645: LD_VAR 0 7
113649: ARRAY
113650: PPUSH
113651: LD_VAR 0 8
113655: PUSH
113656: LD_INT 1
113658: ARRAY
113659: PPUSH
113660: LD_VAR 0 8
113664: PUSH
113665: LD_INT 2
113667: ARRAY
113668: PPUSH
113669: CALL_OW 116
// attacking := true ;
113673: LD_ADDR_VAR 0 29
113677: PUSH
113678: LD_INT 1
113680: ST_TO_ADDR
// continue ;
113681: GO 111056
// end ; end else
113683: GO 113709
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
113685: LD_VAR 0 4
113689: PUSH
113690: LD_VAR 0 7
113694: ARRAY
113695: PPUSH
113696: LD_VAR 0 14
113700: PUSH
113701: LD_INT 1
113703: ARRAY
113704: PPUSH
113705: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
113709: LD_VAR 0 4
113713: PUSH
113714: LD_VAR 0 7
113718: ARRAY
113719: PPUSH
113720: CALL_OW 265
113724: PUSH
113725: LD_INT 11
113727: EQUAL
113728: IFFALSE 114006
// begin k := 10 ;
113730: LD_ADDR_VAR 0 9
113734: PUSH
113735: LD_INT 10
113737: ST_TO_ADDR
// x := 0 ;
113738: LD_ADDR_VAR 0 10
113742: PUSH
113743: LD_INT 0
113745: ST_TO_ADDR
// if tmp < k then
113746: LD_VAR 0 14
113750: PUSH
113751: LD_VAR 0 9
113755: LESS
113756: IFFALSE 113768
// k := tmp ;
113758: LD_ADDR_VAR 0 9
113762: PUSH
113763: LD_VAR 0 14
113767: ST_TO_ADDR
// for j = k downto 1 do
113768: LD_ADDR_VAR 0 8
113772: PUSH
113773: DOUBLE
113774: LD_VAR 0 9
113778: INC
113779: ST_TO_ADDR
113780: LD_INT 1
113782: PUSH
113783: FOR_DOWNTO
113784: IFFALSE 113859
// begin if GetType ( tmp [ j ] ) = unit_human then
113786: LD_VAR 0 14
113790: PUSH
113791: LD_VAR 0 8
113795: ARRAY
113796: PPUSH
113797: CALL_OW 247
113801: PUSH
113802: LD_INT 1
113804: EQUAL
113805: IFFALSE 113857
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
113807: LD_VAR 0 4
113811: PUSH
113812: LD_VAR 0 7
113816: ARRAY
113817: PPUSH
113818: LD_VAR 0 14
113822: PUSH
113823: LD_VAR 0 8
113827: ARRAY
113828: PPUSH
113829: CALL 81980 0 2
// x := tmp [ j ] ;
113833: LD_ADDR_VAR 0 10
113837: PUSH
113838: LD_VAR 0 14
113842: PUSH
113843: LD_VAR 0 8
113847: ARRAY
113848: ST_TO_ADDR
// attacking := true ;
113849: LD_ADDR_VAR 0 29
113853: PUSH
113854: LD_INT 1
113856: ST_TO_ADDR
// end ; end ;
113857: GO 113783
113859: POP
113860: POP
// if not x then
113861: LD_VAR 0 10
113865: NOT
113866: IFFALSE 114006
// begin attacking := true ;
113868: LD_ADDR_VAR 0 29
113872: PUSH
113873: LD_INT 1
113875: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
113876: LD_VAR 0 4
113880: PUSH
113881: LD_VAR 0 7
113885: ARRAY
113886: PPUSH
113887: CALL_OW 250
113891: PPUSH
113892: LD_VAR 0 4
113896: PUSH
113897: LD_VAR 0 7
113901: ARRAY
113902: PPUSH
113903: CALL_OW 251
113907: PPUSH
113908: CALL_OW 546
113912: PUSH
113913: LD_INT 2
113915: ARRAY
113916: PUSH
113917: LD_VAR 0 14
113921: PUSH
113922: LD_INT 1
113924: ARRAY
113925: PPUSH
113926: CALL_OW 250
113930: PPUSH
113931: LD_VAR 0 14
113935: PUSH
113936: LD_INT 1
113938: ARRAY
113939: PPUSH
113940: CALL_OW 251
113944: PPUSH
113945: CALL_OW 546
113949: PUSH
113950: LD_INT 2
113952: ARRAY
113953: EQUAL
113954: IFFALSE 113982
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
113956: LD_VAR 0 4
113960: PUSH
113961: LD_VAR 0 7
113965: ARRAY
113966: PPUSH
113967: LD_VAR 0 14
113971: PUSH
113972: LD_INT 1
113974: ARRAY
113975: PPUSH
113976: CALL 81980 0 2
113980: GO 114006
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
113982: LD_VAR 0 4
113986: PUSH
113987: LD_VAR 0 7
113991: ARRAY
113992: PPUSH
113993: LD_VAR 0 14
113997: PUSH
113998: LD_INT 1
114000: ARRAY
114001: PPUSH
114002: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
114006: LD_VAR 0 4
114010: PUSH
114011: LD_VAR 0 7
114015: ARRAY
114016: PPUSH
114017: CALL_OW 264
114021: PUSH
114022: LD_INT 29
114024: EQUAL
114025: IFFALSE 114391
// begin if WantsToAttack ( group [ i ] ) in bombed then
114027: LD_VAR 0 4
114031: PUSH
114032: LD_VAR 0 7
114036: ARRAY
114037: PPUSH
114038: CALL_OW 319
114042: PUSH
114043: LD_VAR 0 28
114047: IN
114048: IFFALSE 114052
// continue ;
114050: GO 111056
// k := 8 ;
114052: LD_ADDR_VAR 0 9
114056: PUSH
114057: LD_INT 8
114059: ST_TO_ADDR
// x := 0 ;
114060: LD_ADDR_VAR 0 10
114064: PUSH
114065: LD_INT 0
114067: ST_TO_ADDR
// if tmp < k then
114068: LD_VAR 0 14
114072: PUSH
114073: LD_VAR 0 9
114077: LESS
114078: IFFALSE 114090
// k := tmp ;
114080: LD_ADDR_VAR 0 9
114084: PUSH
114085: LD_VAR 0 14
114089: ST_TO_ADDR
// for j = 1 to k do
114090: LD_ADDR_VAR 0 8
114094: PUSH
114095: DOUBLE
114096: LD_INT 1
114098: DEC
114099: ST_TO_ADDR
114100: LD_VAR 0 9
114104: PUSH
114105: FOR_TO
114106: IFFALSE 114238
// begin if GetType ( tmp [ j ] ) = unit_building then
114108: LD_VAR 0 14
114112: PUSH
114113: LD_VAR 0 8
114117: ARRAY
114118: PPUSH
114119: CALL_OW 247
114123: PUSH
114124: LD_INT 3
114126: EQUAL
114127: IFFALSE 114236
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
114129: LD_VAR 0 14
114133: PUSH
114134: LD_VAR 0 8
114138: ARRAY
114139: PUSH
114140: LD_VAR 0 28
114144: IN
114145: NOT
114146: PUSH
114147: LD_VAR 0 14
114151: PUSH
114152: LD_VAR 0 8
114156: ARRAY
114157: PPUSH
114158: CALL_OW 313
114162: AND
114163: IFFALSE 114236
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
114165: LD_VAR 0 4
114169: PUSH
114170: LD_VAR 0 7
114174: ARRAY
114175: PPUSH
114176: LD_VAR 0 14
114180: PUSH
114181: LD_VAR 0 8
114185: ARRAY
114186: PPUSH
114187: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
114191: LD_ADDR_VAR 0 28
114195: PUSH
114196: LD_VAR 0 28
114200: PPUSH
114201: LD_VAR 0 28
114205: PUSH
114206: LD_INT 1
114208: PLUS
114209: PPUSH
114210: LD_VAR 0 14
114214: PUSH
114215: LD_VAR 0 8
114219: ARRAY
114220: PPUSH
114221: CALL_OW 1
114225: ST_TO_ADDR
// attacking := true ;
114226: LD_ADDR_VAR 0 29
114230: PUSH
114231: LD_INT 1
114233: ST_TO_ADDR
// break ;
114234: GO 114238
// end ; end ;
114236: GO 114105
114238: POP
114239: POP
// if not attacking and f_attack_depot then
114240: LD_VAR 0 29
114244: NOT
114245: PUSH
114246: LD_VAR 0 25
114250: AND
114251: IFFALSE 114346
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
114253: LD_ADDR_VAR 0 13
114257: PUSH
114258: LD_VAR 0 14
114262: PPUSH
114263: LD_INT 2
114265: PUSH
114266: LD_INT 30
114268: PUSH
114269: LD_INT 0
114271: PUSH
114272: EMPTY
114273: LIST
114274: LIST
114275: PUSH
114276: LD_INT 30
114278: PUSH
114279: LD_INT 1
114281: PUSH
114282: EMPTY
114283: LIST
114284: LIST
114285: PUSH
114286: EMPTY
114287: LIST
114288: LIST
114289: LIST
114290: PPUSH
114291: CALL_OW 72
114295: ST_TO_ADDR
// if z then
114296: LD_VAR 0 13
114300: IFFALSE 114346
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
114302: LD_VAR 0 4
114306: PUSH
114307: LD_VAR 0 7
114311: ARRAY
114312: PPUSH
114313: LD_VAR 0 13
114317: PPUSH
114318: LD_VAR 0 4
114322: PUSH
114323: LD_VAR 0 7
114327: ARRAY
114328: PPUSH
114329: CALL_OW 74
114333: PPUSH
114334: CALL_OW 115
// attacking := true ;
114338: LD_ADDR_VAR 0 29
114342: PUSH
114343: LD_INT 1
114345: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
114346: LD_VAR 0 4
114350: PUSH
114351: LD_VAR 0 7
114355: ARRAY
114356: PPUSH
114357: CALL_OW 256
114361: PUSH
114362: LD_INT 500
114364: LESS
114365: IFFALSE 114391
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
114367: LD_VAR 0 4
114371: PUSH
114372: LD_VAR 0 7
114376: ARRAY
114377: PPUSH
114378: LD_VAR 0 14
114382: PUSH
114383: LD_INT 1
114385: ARRAY
114386: PPUSH
114387: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
114391: LD_VAR 0 4
114395: PUSH
114396: LD_VAR 0 7
114400: ARRAY
114401: PPUSH
114402: CALL_OW 264
114406: PUSH
114407: LD_INT 49
114409: EQUAL
114410: IFFALSE 114531
// begin if not HasTask ( group [ i ] ) then
114412: LD_VAR 0 4
114416: PUSH
114417: LD_VAR 0 7
114421: ARRAY
114422: PPUSH
114423: CALL_OW 314
114427: NOT
114428: IFFALSE 114531
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
114430: LD_ADDR_VAR 0 9
114434: PUSH
114435: LD_INT 81
114437: PUSH
114438: LD_VAR 0 4
114442: PUSH
114443: LD_VAR 0 7
114447: ARRAY
114448: PPUSH
114449: CALL_OW 255
114453: PUSH
114454: EMPTY
114455: LIST
114456: LIST
114457: PPUSH
114458: CALL_OW 69
114462: PPUSH
114463: LD_VAR 0 4
114467: PUSH
114468: LD_VAR 0 7
114472: ARRAY
114473: PPUSH
114474: CALL_OW 74
114478: ST_TO_ADDR
// if k then
114479: LD_VAR 0 9
114483: IFFALSE 114531
// if GetDistUnits ( group [ i ] , k ) > 10 then
114485: LD_VAR 0 4
114489: PUSH
114490: LD_VAR 0 7
114494: ARRAY
114495: PPUSH
114496: LD_VAR 0 9
114500: PPUSH
114501: CALL_OW 296
114505: PUSH
114506: LD_INT 10
114508: GREATER
114509: IFFALSE 114531
// ComMoveUnit ( group [ i ] , k ) ;
114511: LD_VAR 0 4
114515: PUSH
114516: LD_VAR 0 7
114520: ARRAY
114521: PPUSH
114522: LD_VAR 0 9
114526: PPUSH
114527: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
114531: LD_VAR 0 4
114535: PUSH
114536: LD_VAR 0 7
114540: ARRAY
114541: PPUSH
114542: CALL_OW 256
114546: PUSH
114547: LD_INT 250
114549: LESS
114550: PUSH
114551: LD_VAR 0 4
114555: PUSH
114556: LD_VAR 0 7
114560: ARRAY
114561: PUSH
114562: LD_INT 21
114564: PUSH
114565: LD_INT 2
114567: PUSH
114568: EMPTY
114569: LIST
114570: LIST
114571: PUSH
114572: LD_INT 23
114574: PUSH
114575: LD_INT 2
114577: PUSH
114578: EMPTY
114579: LIST
114580: LIST
114581: PUSH
114582: EMPTY
114583: LIST
114584: LIST
114585: PPUSH
114586: CALL_OW 69
114590: IN
114591: AND
114592: IFFALSE 114717
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
114594: LD_ADDR_VAR 0 9
114598: PUSH
114599: LD_OWVAR 3
114603: PUSH
114604: LD_VAR 0 4
114608: PUSH
114609: LD_VAR 0 7
114613: ARRAY
114614: DIFF
114615: PPUSH
114616: LD_VAR 0 4
114620: PUSH
114621: LD_VAR 0 7
114625: ARRAY
114626: PPUSH
114627: CALL_OW 74
114631: ST_TO_ADDR
// if not k then
114632: LD_VAR 0 9
114636: NOT
114637: IFFALSE 114641
// continue ;
114639: GO 111056
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
114641: LD_VAR 0 9
114645: PUSH
114646: LD_INT 81
114648: PUSH
114649: LD_VAR 0 4
114653: PUSH
114654: LD_VAR 0 7
114658: ARRAY
114659: PPUSH
114660: CALL_OW 255
114664: PUSH
114665: EMPTY
114666: LIST
114667: LIST
114668: PPUSH
114669: CALL_OW 69
114673: IN
114674: PUSH
114675: LD_VAR 0 9
114679: PPUSH
114680: LD_VAR 0 4
114684: PUSH
114685: LD_VAR 0 7
114689: ARRAY
114690: PPUSH
114691: CALL_OW 296
114695: PUSH
114696: LD_INT 5
114698: LESS
114699: AND
114700: IFFALSE 114717
// ComAutodestruct ( group [ i ] ) ;
114702: LD_VAR 0 4
114706: PUSH
114707: LD_VAR 0 7
114711: ARRAY
114712: PPUSH
114713: CALL 81878 0 1
// end ; if f_attack_depot then
114717: LD_VAR 0 25
114721: IFFALSE 114833
// begin k := 6 ;
114723: LD_ADDR_VAR 0 9
114727: PUSH
114728: LD_INT 6
114730: ST_TO_ADDR
// if tmp < k then
114731: LD_VAR 0 14
114735: PUSH
114736: LD_VAR 0 9
114740: LESS
114741: IFFALSE 114753
// k := tmp ;
114743: LD_ADDR_VAR 0 9
114747: PUSH
114748: LD_VAR 0 14
114752: ST_TO_ADDR
// for j = 1 to k do
114753: LD_ADDR_VAR 0 8
114757: PUSH
114758: DOUBLE
114759: LD_INT 1
114761: DEC
114762: ST_TO_ADDR
114763: LD_VAR 0 9
114767: PUSH
114768: FOR_TO
114769: IFFALSE 114831
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
114771: LD_VAR 0 8
114775: PPUSH
114776: CALL_OW 266
114780: PUSH
114781: LD_INT 0
114783: PUSH
114784: LD_INT 1
114786: PUSH
114787: EMPTY
114788: LIST
114789: LIST
114790: IN
114791: IFFALSE 114829
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
114793: LD_VAR 0 4
114797: PUSH
114798: LD_VAR 0 7
114802: ARRAY
114803: PPUSH
114804: LD_VAR 0 14
114808: PUSH
114809: LD_VAR 0 8
114813: ARRAY
114814: PPUSH
114815: CALL_OW 115
// attacking := true ;
114819: LD_ADDR_VAR 0 29
114823: PUSH
114824: LD_INT 1
114826: ST_TO_ADDR
// break ;
114827: GO 114831
// end ;
114829: GO 114768
114831: POP
114832: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
114833: LD_VAR 0 4
114837: PUSH
114838: LD_VAR 0 7
114842: ARRAY
114843: PPUSH
114844: CALL_OW 302
114848: PUSH
114849: LD_VAR 0 29
114853: NOT
114854: AND
114855: IFFALSE 115177
// begin if GetTag ( group [ i ] ) = 71 then
114857: LD_VAR 0 4
114861: PUSH
114862: LD_VAR 0 7
114866: ARRAY
114867: PPUSH
114868: CALL_OW 110
114872: PUSH
114873: LD_INT 71
114875: EQUAL
114876: IFFALSE 114917
// begin if HasTask ( group [ i ] ) then
114878: LD_VAR 0 4
114882: PUSH
114883: LD_VAR 0 7
114887: ARRAY
114888: PPUSH
114889: CALL_OW 314
114893: IFFALSE 114899
// continue else
114895: GO 111056
114897: GO 114917
// SetTag ( group [ i ] , 0 ) ;
114899: LD_VAR 0 4
114903: PUSH
114904: LD_VAR 0 7
114908: ARRAY
114909: PPUSH
114910: LD_INT 0
114912: PPUSH
114913: CALL_OW 109
// end ; k := 8 ;
114917: LD_ADDR_VAR 0 9
114921: PUSH
114922: LD_INT 8
114924: ST_TO_ADDR
// x := 0 ;
114925: LD_ADDR_VAR 0 10
114929: PUSH
114930: LD_INT 0
114932: ST_TO_ADDR
// if tmp < k then
114933: LD_VAR 0 14
114937: PUSH
114938: LD_VAR 0 9
114942: LESS
114943: IFFALSE 114955
// k := tmp ;
114945: LD_ADDR_VAR 0 9
114949: PUSH
114950: LD_VAR 0 14
114954: ST_TO_ADDR
// for j = 1 to k do
114955: LD_ADDR_VAR 0 8
114959: PUSH
114960: DOUBLE
114961: LD_INT 1
114963: DEC
114964: ST_TO_ADDR
114965: LD_VAR 0 9
114969: PUSH
114970: FOR_TO
114971: IFFALSE 115069
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
114973: LD_VAR 0 14
114977: PUSH
114978: LD_VAR 0 8
114982: ARRAY
114983: PPUSH
114984: CALL_OW 247
114988: PUSH
114989: LD_INT 1
114991: EQUAL
114992: PUSH
114993: LD_VAR 0 14
114997: PUSH
114998: LD_VAR 0 8
115002: ARRAY
115003: PPUSH
115004: CALL_OW 256
115008: PUSH
115009: LD_INT 250
115011: LESS
115012: PUSH
115013: LD_VAR 0 20
115017: AND
115018: PUSH
115019: LD_VAR 0 20
115023: NOT
115024: PUSH
115025: LD_VAR 0 14
115029: PUSH
115030: LD_VAR 0 8
115034: ARRAY
115035: PPUSH
115036: CALL_OW 256
115040: PUSH
115041: LD_INT 250
115043: GREATEREQUAL
115044: AND
115045: OR
115046: AND
115047: IFFALSE 115067
// begin x := tmp [ j ] ;
115049: LD_ADDR_VAR 0 10
115053: PUSH
115054: LD_VAR 0 14
115058: PUSH
115059: LD_VAR 0 8
115063: ARRAY
115064: ST_TO_ADDR
// break ;
115065: GO 115069
// end ;
115067: GO 114970
115069: POP
115070: POP
// if x then
115071: LD_VAR 0 10
115075: IFFALSE 115099
// ComAttackUnit ( group [ i ] , x ) else
115077: LD_VAR 0 4
115081: PUSH
115082: LD_VAR 0 7
115086: ARRAY
115087: PPUSH
115088: LD_VAR 0 10
115092: PPUSH
115093: CALL_OW 115
115097: GO 115123
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
115099: LD_VAR 0 4
115103: PUSH
115104: LD_VAR 0 7
115108: ARRAY
115109: PPUSH
115110: LD_VAR 0 14
115114: PUSH
115115: LD_INT 1
115117: ARRAY
115118: PPUSH
115119: CALL_OW 115
// if not HasTask ( group [ i ] ) then
115123: LD_VAR 0 4
115127: PUSH
115128: LD_VAR 0 7
115132: ARRAY
115133: PPUSH
115134: CALL_OW 314
115138: NOT
115139: IFFALSE 115177
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
115141: LD_VAR 0 4
115145: PUSH
115146: LD_VAR 0 7
115150: ARRAY
115151: PPUSH
115152: LD_VAR 0 14
115156: PPUSH
115157: LD_VAR 0 4
115161: PUSH
115162: LD_VAR 0 7
115166: ARRAY
115167: PPUSH
115168: CALL_OW 74
115172: PPUSH
115173: CALL_OW 115
// end ; end ; end ;
115177: GO 111056
115179: POP
115180: POP
// wait ( 0 0$2 ) ;
115181: LD_INT 70
115183: PPUSH
115184: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
115188: LD_VAR 0 4
115192: NOT
115193: PUSH
115194: LD_VAR 0 4
115198: PUSH
115199: EMPTY
115200: EQUAL
115201: OR
115202: PUSH
115203: LD_INT 81
115205: PUSH
115206: LD_VAR 0 35
115210: PUSH
115211: EMPTY
115212: LIST
115213: LIST
115214: PPUSH
115215: CALL_OW 69
115219: NOT
115220: OR
115221: IFFALSE 111041
// end ;
115223: LD_VAR 0 2
115227: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
115228: LD_INT 0
115230: PPUSH
115231: PPUSH
115232: PPUSH
115233: PPUSH
115234: PPUSH
115235: PPUSH
// if not base or not mc_bases [ base ] or not solds then
115236: LD_VAR 0 1
115240: NOT
115241: PUSH
115242: LD_EXP 50
115246: PUSH
115247: LD_VAR 0 1
115251: ARRAY
115252: NOT
115253: OR
115254: PUSH
115255: LD_VAR 0 2
115259: NOT
115260: OR
115261: IFFALSE 115265
// exit ;
115263: GO 115819
// side := mc_sides [ base ] ;
115265: LD_ADDR_VAR 0 6
115269: PUSH
115270: LD_EXP 76
115274: PUSH
115275: LD_VAR 0 1
115279: ARRAY
115280: ST_TO_ADDR
// if not side then
115281: LD_VAR 0 6
115285: NOT
115286: IFFALSE 115290
// exit ;
115288: GO 115819
// for i in solds do
115290: LD_ADDR_VAR 0 7
115294: PUSH
115295: LD_VAR 0 2
115299: PUSH
115300: FOR_IN
115301: IFFALSE 115362
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
115303: LD_VAR 0 7
115307: PPUSH
115308: CALL_OW 310
115312: PPUSH
115313: CALL_OW 266
115317: PUSH
115318: LD_INT 32
115320: PUSH
115321: LD_INT 31
115323: PUSH
115324: EMPTY
115325: LIST
115326: LIST
115327: IN
115328: IFFALSE 115348
// solds := solds diff i else
115330: LD_ADDR_VAR 0 2
115334: PUSH
115335: LD_VAR 0 2
115339: PUSH
115340: LD_VAR 0 7
115344: DIFF
115345: ST_TO_ADDR
115346: GO 115360
// SetTag ( i , 18 ) ;
115348: LD_VAR 0 7
115352: PPUSH
115353: LD_INT 18
115355: PPUSH
115356: CALL_OW 109
115360: GO 115300
115362: POP
115363: POP
// if not solds then
115364: LD_VAR 0 2
115368: NOT
115369: IFFALSE 115373
// exit ;
115371: GO 115819
// repeat wait ( 0 0$2 ) ;
115373: LD_INT 70
115375: PPUSH
115376: CALL_OW 67
// enemy := mc_scan [ base ] ;
115380: LD_ADDR_VAR 0 4
115384: PUSH
115385: LD_EXP 73
115389: PUSH
115390: LD_VAR 0 1
115394: ARRAY
115395: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
115396: LD_EXP 50
115400: PUSH
115401: LD_VAR 0 1
115405: ARRAY
115406: NOT
115407: PUSH
115408: LD_EXP 50
115412: PUSH
115413: LD_VAR 0 1
115417: ARRAY
115418: PUSH
115419: EMPTY
115420: EQUAL
115421: OR
115422: IFFALSE 115459
// begin for i in solds do
115424: LD_ADDR_VAR 0 7
115428: PUSH
115429: LD_VAR 0 2
115433: PUSH
115434: FOR_IN
115435: IFFALSE 115448
// ComStop ( i ) ;
115437: LD_VAR 0 7
115441: PPUSH
115442: CALL_OW 141
115446: GO 115434
115448: POP
115449: POP
// solds := [ ] ;
115450: LD_ADDR_VAR 0 2
115454: PUSH
115455: EMPTY
115456: ST_TO_ADDR
// exit ;
115457: GO 115819
// end ; for i in solds do
115459: LD_ADDR_VAR 0 7
115463: PUSH
115464: LD_VAR 0 2
115468: PUSH
115469: FOR_IN
115470: IFFALSE 115791
// begin if IsInUnit ( i ) then
115472: LD_VAR 0 7
115476: PPUSH
115477: CALL_OW 310
115481: IFFALSE 115492
// ComExitBuilding ( i ) ;
115483: LD_VAR 0 7
115487: PPUSH
115488: CALL_OW 122
// if GetLives ( i ) > 500 then
115492: LD_VAR 0 7
115496: PPUSH
115497: CALL_OW 256
115501: PUSH
115502: LD_INT 500
115504: GREATER
115505: IFFALSE 115558
// begin e := NearestUnitToUnit ( enemy , i ) ;
115507: LD_ADDR_VAR 0 5
115511: PUSH
115512: LD_VAR 0 4
115516: PPUSH
115517: LD_VAR 0 7
115521: PPUSH
115522: CALL_OW 74
115526: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
115527: LD_VAR 0 7
115531: PPUSH
115532: LD_VAR 0 5
115536: PPUSH
115537: CALL_OW 250
115541: PPUSH
115542: LD_VAR 0 5
115546: PPUSH
115547: CALL_OW 251
115551: PPUSH
115552: CALL_OW 114
// end else
115556: GO 115789
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
115558: LD_VAR 0 7
115562: PPUSH
115563: LD_EXP 50
115567: PUSH
115568: LD_VAR 0 1
115572: ARRAY
115573: PPUSH
115574: LD_INT 2
115576: PUSH
115577: LD_INT 30
115579: PUSH
115580: LD_INT 0
115582: PUSH
115583: EMPTY
115584: LIST
115585: LIST
115586: PUSH
115587: LD_INT 30
115589: PUSH
115590: LD_INT 1
115592: PUSH
115593: EMPTY
115594: LIST
115595: LIST
115596: PUSH
115597: LD_INT 30
115599: PUSH
115600: LD_INT 6
115602: PUSH
115603: EMPTY
115604: LIST
115605: LIST
115606: PUSH
115607: EMPTY
115608: LIST
115609: LIST
115610: LIST
115611: LIST
115612: PPUSH
115613: CALL_OW 72
115617: PPUSH
115618: LD_VAR 0 7
115622: PPUSH
115623: CALL_OW 74
115627: PPUSH
115628: CALL_OW 296
115632: PUSH
115633: LD_INT 10
115635: GREATER
115636: IFFALSE 115789
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
115638: LD_ADDR_VAR 0 8
115642: PUSH
115643: LD_EXP 50
115647: PUSH
115648: LD_VAR 0 1
115652: ARRAY
115653: PPUSH
115654: LD_INT 2
115656: PUSH
115657: LD_INT 30
115659: PUSH
115660: LD_INT 0
115662: PUSH
115663: EMPTY
115664: LIST
115665: LIST
115666: PUSH
115667: LD_INT 30
115669: PUSH
115670: LD_INT 1
115672: PUSH
115673: EMPTY
115674: LIST
115675: LIST
115676: PUSH
115677: LD_INT 30
115679: PUSH
115680: LD_INT 6
115682: PUSH
115683: EMPTY
115684: LIST
115685: LIST
115686: PUSH
115687: EMPTY
115688: LIST
115689: LIST
115690: LIST
115691: LIST
115692: PPUSH
115693: CALL_OW 72
115697: PPUSH
115698: LD_VAR 0 7
115702: PPUSH
115703: CALL_OW 74
115707: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
115708: LD_VAR 0 7
115712: PPUSH
115713: LD_VAR 0 8
115717: PPUSH
115718: CALL_OW 250
115722: PPUSH
115723: LD_INT 3
115725: PPUSH
115726: LD_INT 5
115728: PPUSH
115729: CALL_OW 272
115733: PPUSH
115734: LD_VAR 0 8
115738: PPUSH
115739: CALL_OW 251
115743: PPUSH
115744: LD_INT 3
115746: PPUSH
115747: LD_INT 5
115749: PPUSH
115750: CALL_OW 273
115754: PPUSH
115755: CALL_OW 111
// SetTag ( i , 0 ) ;
115759: LD_VAR 0 7
115763: PPUSH
115764: LD_INT 0
115766: PPUSH
115767: CALL_OW 109
// solds := solds diff i ;
115771: LD_ADDR_VAR 0 2
115775: PUSH
115776: LD_VAR 0 2
115780: PUSH
115781: LD_VAR 0 7
115785: DIFF
115786: ST_TO_ADDR
// continue ;
115787: GO 115469
// end ; end ;
115789: GO 115469
115791: POP
115792: POP
// until not solds or not enemy ;
115793: LD_VAR 0 2
115797: NOT
115798: PUSH
115799: LD_VAR 0 4
115803: NOT
115804: OR
115805: IFFALSE 115373
// MC_Reset ( base , 18 ) ;
115807: LD_VAR 0 1
115811: PPUSH
115812: LD_INT 18
115814: PPUSH
115815: CALL 22547 0 2
// end ;
115819: LD_VAR 0 3
115823: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
115824: LD_INT 0
115826: PPUSH
115827: PPUSH
115828: PPUSH
115829: PPUSH
115830: PPUSH
115831: PPUSH
115832: PPUSH
115833: PPUSH
115834: PPUSH
115835: PPUSH
115836: PPUSH
115837: PPUSH
115838: PPUSH
115839: PPUSH
115840: PPUSH
115841: PPUSH
115842: PPUSH
115843: PPUSH
115844: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
115845: LD_ADDR_VAR 0 12
115849: PUSH
115850: LD_EXP 50
115854: PUSH
115855: LD_VAR 0 1
115859: ARRAY
115860: PPUSH
115861: LD_INT 25
115863: PUSH
115864: LD_INT 3
115866: PUSH
115867: EMPTY
115868: LIST
115869: LIST
115870: PPUSH
115871: CALL_OW 72
115875: ST_TO_ADDR
// if mc_remote_driver [ base ] then
115876: LD_EXP 90
115880: PUSH
115881: LD_VAR 0 1
115885: ARRAY
115886: IFFALSE 115910
// mechs := mechs diff mc_remote_driver [ base ] ;
115888: LD_ADDR_VAR 0 12
115892: PUSH
115893: LD_VAR 0 12
115897: PUSH
115898: LD_EXP 90
115902: PUSH
115903: LD_VAR 0 1
115907: ARRAY
115908: DIFF
115909: ST_TO_ADDR
// for i in mechs do
115910: LD_ADDR_VAR 0 4
115914: PUSH
115915: LD_VAR 0 12
115919: PUSH
115920: FOR_IN
115921: IFFALSE 115956
// if GetTag ( i ) > 0 then
115923: LD_VAR 0 4
115927: PPUSH
115928: CALL_OW 110
115932: PUSH
115933: LD_INT 0
115935: GREATER
115936: IFFALSE 115954
// mechs := mechs diff i ;
115938: LD_ADDR_VAR 0 12
115942: PUSH
115943: LD_VAR 0 12
115947: PUSH
115948: LD_VAR 0 4
115952: DIFF
115953: ST_TO_ADDR
115954: GO 115920
115956: POP
115957: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
115958: LD_ADDR_VAR 0 8
115962: PUSH
115963: LD_EXP 50
115967: PUSH
115968: LD_VAR 0 1
115972: ARRAY
115973: PPUSH
115974: LD_INT 2
115976: PUSH
115977: LD_INT 25
115979: PUSH
115980: LD_INT 1
115982: PUSH
115983: EMPTY
115984: LIST
115985: LIST
115986: PUSH
115987: LD_INT 25
115989: PUSH
115990: LD_INT 5
115992: PUSH
115993: EMPTY
115994: LIST
115995: LIST
115996: PUSH
115997: LD_INT 25
115999: PUSH
116000: LD_INT 8
116002: PUSH
116003: EMPTY
116004: LIST
116005: LIST
116006: PUSH
116007: LD_INT 25
116009: PUSH
116010: LD_INT 9
116012: PUSH
116013: EMPTY
116014: LIST
116015: LIST
116016: PUSH
116017: EMPTY
116018: LIST
116019: LIST
116020: LIST
116021: LIST
116022: LIST
116023: PPUSH
116024: CALL_OW 72
116028: ST_TO_ADDR
// if not defenders and not solds then
116029: LD_VAR 0 2
116033: NOT
116034: PUSH
116035: LD_VAR 0 8
116039: NOT
116040: AND
116041: IFFALSE 116045
// exit ;
116043: GO 117815
// depot_under_attack := false ;
116045: LD_ADDR_VAR 0 16
116049: PUSH
116050: LD_INT 0
116052: ST_TO_ADDR
// sold_defenders := [ ] ;
116053: LD_ADDR_VAR 0 17
116057: PUSH
116058: EMPTY
116059: ST_TO_ADDR
// if mechs then
116060: LD_VAR 0 12
116064: IFFALSE 116217
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
116066: LD_ADDR_VAR 0 4
116070: PUSH
116071: LD_VAR 0 2
116075: PPUSH
116076: LD_INT 21
116078: PUSH
116079: LD_INT 2
116081: PUSH
116082: EMPTY
116083: LIST
116084: LIST
116085: PPUSH
116086: CALL_OW 72
116090: PUSH
116091: FOR_IN
116092: IFFALSE 116215
// begin if GetTag ( i ) <> 20 then
116094: LD_VAR 0 4
116098: PPUSH
116099: CALL_OW 110
116103: PUSH
116104: LD_INT 20
116106: NONEQUAL
116107: IFFALSE 116121
// SetTag ( i , 20 ) ;
116109: LD_VAR 0 4
116113: PPUSH
116114: LD_INT 20
116116: PPUSH
116117: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
116121: LD_VAR 0 4
116125: PPUSH
116126: CALL_OW 263
116130: PUSH
116131: LD_INT 1
116133: EQUAL
116134: PUSH
116135: LD_VAR 0 4
116139: PPUSH
116140: CALL_OW 311
116144: NOT
116145: AND
116146: IFFALSE 116213
// begin un := mechs [ 1 ] ;
116148: LD_ADDR_VAR 0 10
116152: PUSH
116153: LD_VAR 0 12
116157: PUSH
116158: LD_INT 1
116160: ARRAY
116161: ST_TO_ADDR
// ComExit ( un ) ;
116162: LD_VAR 0 10
116166: PPUSH
116167: CALL 86762 0 1
// AddComEnterUnit ( un , i ) ;
116171: LD_VAR 0 10
116175: PPUSH
116176: LD_VAR 0 4
116180: PPUSH
116181: CALL_OW 180
// SetTag ( un , 19 ) ;
116185: LD_VAR 0 10
116189: PPUSH
116190: LD_INT 19
116192: PPUSH
116193: CALL_OW 109
// mechs := mechs diff un ;
116197: LD_ADDR_VAR 0 12
116201: PUSH
116202: LD_VAR 0 12
116206: PUSH
116207: LD_VAR 0 10
116211: DIFF
116212: ST_TO_ADDR
// end ; end ;
116213: GO 116091
116215: POP
116216: POP
// if solds then
116217: LD_VAR 0 8
116221: IFFALSE 116280
// for i in solds do
116223: LD_ADDR_VAR 0 4
116227: PUSH
116228: LD_VAR 0 8
116232: PUSH
116233: FOR_IN
116234: IFFALSE 116278
// if not GetTag ( i ) then
116236: LD_VAR 0 4
116240: PPUSH
116241: CALL_OW 110
116245: NOT
116246: IFFALSE 116276
// begin defenders := defenders union i ;
116248: LD_ADDR_VAR 0 2
116252: PUSH
116253: LD_VAR 0 2
116257: PUSH
116258: LD_VAR 0 4
116262: UNION
116263: ST_TO_ADDR
// SetTag ( i , 18 ) ;
116264: LD_VAR 0 4
116268: PPUSH
116269: LD_INT 18
116271: PPUSH
116272: CALL_OW 109
// end ;
116276: GO 116233
116278: POP
116279: POP
// repeat wait ( 0 0$2 ) ;
116280: LD_INT 70
116282: PPUSH
116283: CALL_OW 67
// enemy := mc_scan [ base ] ;
116287: LD_ADDR_VAR 0 21
116291: PUSH
116292: LD_EXP 73
116296: PUSH
116297: LD_VAR 0 1
116301: ARRAY
116302: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
116303: LD_EXP 50
116307: PUSH
116308: LD_VAR 0 1
116312: ARRAY
116313: NOT
116314: PUSH
116315: LD_EXP 50
116319: PUSH
116320: LD_VAR 0 1
116324: ARRAY
116325: PUSH
116326: EMPTY
116327: EQUAL
116328: OR
116329: IFFALSE 116366
// begin for i in defenders do
116331: LD_ADDR_VAR 0 4
116335: PUSH
116336: LD_VAR 0 2
116340: PUSH
116341: FOR_IN
116342: IFFALSE 116355
// ComStop ( i ) ;
116344: LD_VAR 0 4
116348: PPUSH
116349: CALL_OW 141
116353: GO 116341
116355: POP
116356: POP
// defenders := [ ] ;
116357: LD_ADDR_VAR 0 2
116361: PUSH
116362: EMPTY
116363: ST_TO_ADDR
// exit ;
116364: GO 117815
// end ; for i in defenders do
116366: LD_ADDR_VAR 0 4
116370: PUSH
116371: LD_VAR 0 2
116375: PUSH
116376: FOR_IN
116377: IFFALSE 117275
// begin e := NearestUnitToUnit ( enemy , i ) ;
116379: LD_ADDR_VAR 0 13
116383: PUSH
116384: LD_VAR 0 21
116388: PPUSH
116389: LD_VAR 0 4
116393: PPUSH
116394: CALL_OW 74
116398: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
116399: LD_ADDR_VAR 0 7
116403: PUSH
116404: LD_EXP 50
116408: PUSH
116409: LD_VAR 0 1
116413: ARRAY
116414: PPUSH
116415: LD_INT 2
116417: PUSH
116418: LD_INT 30
116420: PUSH
116421: LD_INT 0
116423: PUSH
116424: EMPTY
116425: LIST
116426: LIST
116427: PUSH
116428: LD_INT 30
116430: PUSH
116431: LD_INT 1
116433: PUSH
116434: EMPTY
116435: LIST
116436: LIST
116437: PUSH
116438: EMPTY
116439: LIST
116440: LIST
116441: LIST
116442: PPUSH
116443: CALL_OW 72
116447: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
116448: LD_ADDR_VAR 0 16
116452: PUSH
116453: LD_VAR 0 7
116457: NOT
116458: PUSH
116459: LD_VAR 0 7
116463: PPUSH
116464: LD_INT 3
116466: PUSH
116467: LD_INT 24
116469: PUSH
116470: LD_INT 600
116472: PUSH
116473: EMPTY
116474: LIST
116475: LIST
116476: PUSH
116477: EMPTY
116478: LIST
116479: LIST
116480: PPUSH
116481: CALL_OW 72
116485: OR
116486: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
116487: LD_VAR 0 4
116491: PPUSH
116492: CALL_OW 247
116496: PUSH
116497: LD_INT 2
116499: DOUBLE
116500: EQUAL
116501: IFTRUE 116505
116503: GO 116901
116505: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
116506: LD_VAR 0 4
116510: PPUSH
116511: CALL_OW 256
116515: PUSH
116516: LD_INT 1000
116518: EQUAL
116519: PUSH
116520: LD_VAR 0 4
116524: PPUSH
116525: LD_VAR 0 13
116529: PPUSH
116530: CALL_OW 296
116534: PUSH
116535: LD_INT 40
116537: LESS
116538: PUSH
116539: LD_VAR 0 13
116543: PPUSH
116544: LD_EXP 75
116548: PUSH
116549: LD_VAR 0 1
116553: ARRAY
116554: PPUSH
116555: CALL_OW 308
116559: OR
116560: AND
116561: IFFALSE 116683
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
116563: LD_VAR 0 4
116567: PPUSH
116568: CALL_OW 262
116572: PUSH
116573: LD_INT 1
116575: EQUAL
116576: PUSH
116577: LD_VAR 0 4
116581: PPUSH
116582: CALL_OW 261
116586: PUSH
116587: LD_INT 30
116589: LESS
116590: AND
116591: PUSH
116592: LD_VAR 0 7
116596: AND
116597: IFFALSE 116667
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
116599: LD_VAR 0 4
116603: PPUSH
116604: LD_VAR 0 7
116608: PPUSH
116609: LD_VAR 0 4
116613: PPUSH
116614: CALL_OW 74
116618: PPUSH
116619: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
116623: LD_VAR 0 4
116627: PPUSH
116628: LD_VAR 0 7
116632: PPUSH
116633: LD_VAR 0 4
116637: PPUSH
116638: CALL_OW 74
116642: PPUSH
116643: CALL_OW 296
116647: PUSH
116648: LD_INT 6
116650: LESS
116651: IFFALSE 116665
// SetFuel ( i , 100 ) ;
116653: LD_VAR 0 4
116657: PPUSH
116658: LD_INT 100
116660: PPUSH
116661: CALL_OW 240
// end else
116665: GO 116681
// ComAttackUnit ( i , e ) ;
116667: LD_VAR 0 4
116671: PPUSH
116672: LD_VAR 0 13
116676: PPUSH
116677: CALL_OW 115
// end else
116681: GO 116784
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
116683: LD_VAR 0 13
116687: PPUSH
116688: LD_EXP 75
116692: PUSH
116693: LD_VAR 0 1
116697: ARRAY
116698: PPUSH
116699: CALL_OW 308
116703: NOT
116704: PUSH
116705: LD_VAR 0 4
116709: PPUSH
116710: LD_VAR 0 13
116714: PPUSH
116715: CALL_OW 296
116719: PUSH
116720: LD_INT 40
116722: GREATEREQUAL
116723: AND
116724: PUSH
116725: LD_VAR 0 4
116729: PPUSH
116730: CALL_OW 256
116734: PUSH
116735: LD_INT 650
116737: LESSEQUAL
116738: OR
116739: PUSH
116740: LD_VAR 0 4
116744: PPUSH
116745: LD_EXP 74
116749: PUSH
116750: LD_VAR 0 1
116754: ARRAY
116755: PPUSH
116756: CALL_OW 308
116760: NOT
116761: AND
116762: IFFALSE 116784
// ComMoveToArea ( i , mc_parking [ base ] ) ;
116764: LD_VAR 0 4
116768: PPUSH
116769: LD_EXP 74
116773: PUSH
116774: LD_VAR 0 1
116778: ARRAY
116779: PPUSH
116780: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
116784: LD_VAR 0 4
116788: PPUSH
116789: CALL_OW 256
116793: PUSH
116794: LD_INT 1000
116796: LESS
116797: PUSH
116798: LD_VAR 0 4
116802: PPUSH
116803: CALL_OW 263
116807: PUSH
116808: LD_INT 1
116810: EQUAL
116811: AND
116812: PUSH
116813: LD_VAR 0 4
116817: PPUSH
116818: CALL_OW 311
116822: AND
116823: PUSH
116824: LD_VAR 0 4
116828: PPUSH
116829: LD_EXP 74
116833: PUSH
116834: LD_VAR 0 1
116838: ARRAY
116839: PPUSH
116840: CALL_OW 308
116844: AND
116845: IFFALSE 116899
// begin mech := IsDrivenBy ( i ) ;
116847: LD_ADDR_VAR 0 9
116851: PUSH
116852: LD_VAR 0 4
116856: PPUSH
116857: CALL_OW 311
116861: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
116862: LD_VAR 0 9
116866: PPUSH
116867: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
116871: LD_VAR 0 9
116875: PPUSH
116876: LD_VAR 0 4
116880: PPUSH
116881: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
116885: LD_VAR 0 9
116889: PPUSH
116890: LD_VAR 0 4
116894: PPUSH
116895: CALL_OW 180
// end ; end ; unit_human :
116899: GO 117246
116901: LD_INT 1
116903: DOUBLE
116904: EQUAL
116905: IFTRUE 116909
116907: GO 117245
116909: POP
// begin b := IsInUnit ( i ) ;
116910: LD_ADDR_VAR 0 18
116914: PUSH
116915: LD_VAR 0 4
116919: PPUSH
116920: CALL_OW 310
116924: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
116925: LD_ADDR_VAR 0 19
116929: PUSH
116930: LD_VAR 0 18
116934: NOT
116935: PUSH
116936: LD_VAR 0 18
116940: PPUSH
116941: CALL_OW 266
116945: PUSH
116946: LD_INT 32
116948: PUSH
116949: LD_INT 31
116951: PUSH
116952: EMPTY
116953: LIST
116954: LIST
116955: IN
116956: OR
116957: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
116958: LD_VAR 0 18
116962: PPUSH
116963: CALL_OW 266
116967: PUSH
116968: LD_INT 5
116970: EQUAL
116971: PUSH
116972: LD_VAR 0 4
116976: PPUSH
116977: CALL_OW 257
116981: PUSH
116982: LD_INT 1
116984: PUSH
116985: LD_INT 2
116987: PUSH
116988: LD_INT 3
116990: PUSH
116991: LD_INT 4
116993: PUSH
116994: EMPTY
116995: LIST
116996: LIST
116997: LIST
116998: LIST
116999: IN
117000: AND
117001: IFFALSE 117038
// begin class := AllowSpecClass ( i ) ;
117003: LD_ADDR_VAR 0 20
117007: PUSH
117008: LD_VAR 0 4
117012: PPUSH
117013: CALL 50858 0 1
117017: ST_TO_ADDR
// if class then
117018: LD_VAR 0 20
117022: IFFALSE 117038
// ComChangeProfession ( i , class ) ;
117024: LD_VAR 0 4
117028: PPUSH
117029: LD_VAR 0 20
117033: PPUSH
117034: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
117038: LD_VAR 0 16
117042: PUSH
117043: LD_VAR 0 2
117047: PPUSH
117048: LD_INT 21
117050: PUSH
117051: LD_INT 2
117053: PUSH
117054: EMPTY
117055: LIST
117056: LIST
117057: PPUSH
117058: CALL_OW 72
117062: PUSH
117063: LD_INT 1
117065: LESSEQUAL
117066: OR
117067: PUSH
117068: LD_VAR 0 19
117072: AND
117073: PUSH
117074: LD_VAR 0 4
117078: PUSH
117079: LD_VAR 0 17
117083: IN
117084: NOT
117085: AND
117086: IFFALSE 117179
// begin if b then
117088: LD_VAR 0 18
117092: IFFALSE 117141
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
117094: LD_VAR 0 18
117098: PPUSH
117099: LD_VAR 0 21
117103: PPUSH
117104: LD_VAR 0 18
117108: PPUSH
117109: CALL_OW 74
117113: PPUSH
117114: CALL_OW 296
117118: PUSH
117119: LD_INT 10
117121: LESS
117122: PUSH
117123: LD_VAR 0 18
117127: PPUSH
117128: CALL_OW 461
117132: PUSH
117133: LD_INT 7
117135: NONEQUAL
117136: AND
117137: IFFALSE 117141
// continue ;
117139: GO 116376
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
117141: LD_ADDR_VAR 0 17
117145: PUSH
117146: LD_VAR 0 17
117150: PPUSH
117151: LD_VAR 0 17
117155: PUSH
117156: LD_INT 1
117158: PLUS
117159: PPUSH
117160: LD_VAR 0 4
117164: PPUSH
117165: CALL_OW 1
117169: ST_TO_ADDR
// ComExitBuilding ( i ) ;
117170: LD_VAR 0 4
117174: PPUSH
117175: CALL_OW 122
// end ; if sold_defenders then
117179: LD_VAR 0 17
117183: IFFALSE 117243
// if i in sold_defenders then
117185: LD_VAR 0 4
117189: PUSH
117190: LD_VAR 0 17
117194: IN
117195: IFFALSE 117243
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
117197: LD_VAR 0 4
117201: PPUSH
117202: CALL_OW 314
117206: NOT
117207: PUSH
117208: LD_VAR 0 4
117212: PPUSH
117213: LD_VAR 0 13
117217: PPUSH
117218: CALL_OW 296
117222: PUSH
117223: LD_INT 30
117225: LESS
117226: AND
117227: IFFALSE 117243
// ComAttackUnit ( i , e ) ;
117229: LD_VAR 0 4
117233: PPUSH
117234: LD_VAR 0 13
117238: PPUSH
117239: CALL_OW 115
// end ; end ; end ;
117243: GO 117246
117245: POP
// if IsDead ( i ) then
117246: LD_VAR 0 4
117250: PPUSH
117251: CALL_OW 301
117255: IFFALSE 117273
// defenders := defenders diff i ;
117257: LD_ADDR_VAR 0 2
117261: PUSH
117262: LD_VAR 0 2
117266: PUSH
117267: LD_VAR 0 4
117271: DIFF
117272: ST_TO_ADDR
// end ;
117273: GO 116376
117275: POP
117276: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
117277: LD_VAR 0 21
117281: NOT
117282: PUSH
117283: LD_VAR 0 2
117287: NOT
117288: OR
117289: PUSH
117290: LD_EXP 50
117294: PUSH
117295: LD_VAR 0 1
117299: ARRAY
117300: NOT
117301: OR
117302: IFFALSE 116280
// MC_Reset ( base , 18 ) ;
117304: LD_VAR 0 1
117308: PPUSH
117309: LD_INT 18
117311: PPUSH
117312: CALL 22547 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
117316: LD_ADDR_VAR 0 2
117320: PUSH
117321: LD_VAR 0 2
117325: PUSH
117326: LD_VAR 0 2
117330: PPUSH
117331: LD_INT 2
117333: PUSH
117334: LD_INT 25
117336: PUSH
117337: LD_INT 1
117339: PUSH
117340: EMPTY
117341: LIST
117342: LIST
117343: PUSH
117344: LD_INT 25
117346: PUSH
117347: LD_INT 5
117349: PUSH
117350: EMPTY
117351: LIST
117352: LIST
117353: PUSH
117354: LD_INT 25
117356: PUSH
117357: LD_INT 8
117359: PUSH
117360: EMPTY
117361: LIST
117362: LIST
117363: PUSH
117364: LD_INT 25
117366: PUSH
117367: LD_INT 9
117369: PUSH
117370: EMPTY
117371: LIST
117372: LIST
117373: PUSH
117374: EMPTY
117375: LIST
117376: LIST
117377: LIST
117378: LIST
117379: LIST
117380: PPUSH
117381: CALL_OW 72
117385: DIFF
117386: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
117387: LD_VAR 0 21
117391: NOT
117392: PUSH
117393: LD_VAR 0 2
117397: PPUSH
117398: LD_INT 21
117400: PUSH
117401: LD_INT 2
117403: PUSH
117404: EMPTY
117405: LIST
117406: LIST
117407: PPUSH
117408: CALL_OW 72
117412: AND
117413: IFFALSE 117751
// begin tmp := FilterByTag ( defenders , 19 ) ;
117415: LD_ADDR_VAR 0 11
117419: PUSH
117420: LD_VAR 0 2
117424: PPUSH
117425: LD_INT 19
117427: PPUSH
117428: CALL 83946 0 2
117432: ST_TO_ADDR
// if tmp then
117433: LD_VAR 0 11
117437: IFFALSE 117507
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
117439: LD_ADDR_VAR 0 11
117443: PUSH
117444: LD_VAR 0 11
117448: PPUSH
117449: LD_INT 25
117451: PUSH
117452: LD_INT 3
117454: PUSH
117455: EMPTY
117456: LIST
117457: LIST
117458: PPUSH
117459: CALL_OW 72
117463: ST_TO_ADDR
// if tmp then
117464: LD_VAR 0 11
117468: IFFALSE 117507
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
117470: LD_ADDR_EXP 62
117474: PUSH
117475: LD_EXP 62
117479: PPUSH
117480: LD_VAR 0 1
117484: PPUSH
117485: LD_EXP 62
117489: PUSH
117490: LD_VAR 0 1
117494: ARRAY
117495: PUSH
117496: LD_VAR 0 11
117500: UNION
117501: PPUSH
117502: CALL_OW 1
117506: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
117507: LD_VAR 0 1
117511: PPUSH
117512: LD_INT 19
117514: PPUSH
117515: CALL 22547 0 2
// repeat wait ( 0 0$1 ) ;
117519: LD_INT 35
117521: PPUSH
117522: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
117526: LD_EXP 50
117530: PUSH
117531: LD_VAR 0 1
117535: ARRAY
117536: NOT
117537: PUSH
117538: LD_EXP 50
117542: PUSH
117543: LD_VAR 0 1
117547: ARRAY
117548: PUSH
117549: EMPTY
117550: EQUAL
117551: OR
117552: IFFALSE 117589
// begin for i in defenders do
117554: LD_ADDR_VAR 0 4
117558: PUSH
117559: LD_VAR 0 2
117563: PUSH
117564: FOR_IN
117565: IFFALSE 117578
// ComStop ( i ) ;
117567: LD_VAR 0 4
117571: PPUSH
117572: CALL_OW 141
117576: GO 117564
117578: POP
117579: POP
// defenders := [ ] ;
117580: LD_ADDR_VAR 0 2
117584: PUSH
117585: EMPTY
117586: ST_TO_ADDR
// exit ;
117587: GO 117815
// end ; for i in defenders do
117589: LD_ADDR_VAR 0 4
117593: PUSH
117594: LD_VAR 0 2
117598: PUSH
117599: FOR_IN
117600: IFFALSE 117689
// begin if not IsInArea ( i , mc_parking [ base ] ) then
117602: LD_VAR 0 4
117606: PPUSH
117607: LD_EXP 74
117611: PUSH
117612: LD_VAR 0 1
117616: ARRAY
117617: PPUSH
117618: CALL_OW 308
117622: NOT
117623: IFFALSE 117647
// ComMoveToArea ( i , mc_parking [ base ] ) else
117625: LD_VAR 0 4
117629: PPUSH
117630: LD_EXP 74
117634: PUSH
117635: LD_VAR 0 1
117639: ARRAY
117640: PPUSH
117641: CALL_OW 113
117645: GO 117687
// if GetControl ( i ) = control_manual then
117647: LD_VAR 0 4
117651: PPUSH
117652: CALL_OW 263
117656: PUSH
117657: LD_INT 1
117659: EQUAL
117660: IFFALSE 117687
// if IsDrivenBy ( i ) then
117662: LD_VAR 0 4
117666: PPUSH
117667: CALL_OW 311
117671: IFFALSE 117687
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
117673: LD_VAR 0 4
117677: PPUSH
117678: CALL_OW 311
117682: PPUSH
117683: CALL_OW 121
// end ;
117687: GO 117599
117689: POP
117690: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
117691: LD_VAR 0 2
117695: PPUSH
117696: LD_INT 95
117698: PUSH
117699: LD_EXP 74
117703: PUSH
117704: LD_VAR 0 1
117708: ARRAY
117709: PUSH
117710: EMPTY
117711: LIST
117712: LIST
117713: PPUSH
117714: CALL_OW 72
117718: PUSH
117719: LD_VAR 0 2
117723: EQUAL
117724: PUSH
117725: LD_EXP 73
117729: PUSH
117730: LD_VAR 0 1
117734: ARRAY
117735: OR
117736: PUSH
117737: LD_EXP 50
117741: PUSH
117742: LD_VAR 0 1
117746: ARRAY
117747: NOT
117748: OR
117749: IFFALSE 117519
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
117751: LD_ADDR_EXP 72
117755: PUSH
117756: LD_EXP 72
117760: PPUSH
117761: LD_VAR 0 1
117765: PPUSH
117766: LD_VAR 0 2
117770: PPUSH
117771: LD_INT 21
117773: PUSH
117774: LD_INT 2
117776: PUSH
117777: EMPTY
117778: LIST
117779: LIST
117780: PPUSH
117781: CALL_OW 72
117785: PPUSH
117786: CALL_OW 1
117790: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
117791: LD_VAR 0 1
117795: PPUSH
117796: LD_INT 19
117798: PPUSH
117799: CALL 22547 0 2
// MC_Reset ( base , 20 ) ;
117803: LD_VAR 0 1
117807: PPUSH
117808: LD_INT 20
117810: PPUSH
117811: CALL 22547 0 2
// end ; end_of_file
117815: LD_VAR 0 3
117819: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
117820: LD_VAR 0 1
117824: PUSH
117825: LD_INT 200
117827: DOUBLE
117828: GREATEREQUAL
117829: IFFALSE 117837
117831: LD_INT 299
117833: DOUBLE
117834: LESSEQUAL
117835: IFTRUE 117839
117837: GO 117871
117839: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
117840: LD_VAR 0 1
117844: PPUSH
117845: LD_VAR 0 2
117849: PPUSH
117850: LD_VAR 0 3
117854: PPUSH
117855: LD_VAR 0 4
117859: PPUSH
117860: LD_VAR 0 5
117864: PPUSH
117865: CALL 106606 0 5
117869: GO 117948
117871: LD_INT 300
117873: DOUBLE
117874: GREATEREQUAL
117875: IFFALSE 117883
117877: LD_INT 399
117879: DOUBLE
117880: LESSEQUAL
117881: IFTRUE 117885
117883: GO 117947
117885: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
117886: LD_VAR 0 1
117890: PPUSH
117891: LD_VAR 0 2
117895: PPUSH
117896: LD_VAR 0 3
117900: PPUSH
117901: LD_VAR 0 4
117905: PPUSH
117906: LD_VAR 0 5
117910: PPUSH
117911: LD_VAR 0 6
117915: PPUSH
117916: LD_VAR 0 7
117920: PPUSH
117921: LD_VAR 0 8
117925: PPUSH
117926: LD_VAR 0 9
117930: PPUSH
117931: LD_VAR 0 10
117935: PPUSH
117936: LD_VAR 0 11
117940: PPUSH
117941: CALL 102939 0 11
117945: GO 117948
117947: POP
// end ;
117948: PPOPN 11
117950: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
117951: LD_VAR 0 1
117955: PPUSH
117956: LD_VAR 0 2
117960: PPUSH
117961: LD_VAR 0 3
117965: PPUSH
117966: LD_VAR 0 4
117970: PPUSH
117971: LD_VAR 0 5
117975: PPUSH
117976: CALL 106342 0 5
// end ; end_of_file
117980: PPOPN 5
117982: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
117983: LD_VAR 0 1
117987: PPUSH
117988: LD_VAR 0 2
117992: PPUSH
117993: LD_VAR 0 3
117997: PPUSH
117998: LD_VAR 0 4
118002: PPUSH
118003: LD_VAR 0 5
118007: PPUSH
118008: LD_VAR 0 6
118012: PPUSH
118013: CALL 90591 0 6
// end ;
118017: PPOPN 6
118019: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
118020: LD_INT 0
118022: PPUSH
// begin if not units then
118023: LD_VAR 0 1
118027: NOT
118028: IFFALSE 118032
// exit ;
118030: GO 118032
// end ;
118032: PPOPN 7
118034: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
118035: CALL 90495 0 0
// end ;
118039: PPOPN 1
118041: END
