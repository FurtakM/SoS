// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Randomize ;
  11: CALL_OW 10
// InitVariables ;
  15: CALL 94 0 0
// InitMacro ;
  19: CALL 18397 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// ChangeSideFog ( 8 , 1 ) ;
  36: LD_INT 8
  38: PPUSH
  39: LD_INT 1
  41: PPUSH
  42: CALL_OW 343
// PrepareNature ( 4 , 3 , 6 , 3 , 2 , 0 , 7 , natureArea , waterArea ) ;
  46: LD_INT 4
  48: PPUSH
  49: LD_INT 3
  51: PPUSH
  52: LD_INT 6
  54: PPUSH
  55: LD_INT 3
  57: PPUSH
  58: LD_INT 2
  60: PPUSH
  61: LD_INT 0
  63: PPUSH
  64: LD_INT 7
  66: PPUSH
  67: LD_INT 18
  69: PPUSH
  70: LD_INT 19
  72: PPUSH
  73: CALL 83484 0 9
// PrepareAmerican ;
  77: CALL 653 0 0
// PrepareArabian ;
  81: CALL 2624 0 0
// MC_Start ( ) ;
  85: CALL 20577 0 0
// Action ;
  89: CALL 8768 0 0
// end ;
  93: END
// export debug , game ; export mission_prefix , mission_prefix_prev ; export ar_run , base_captured , ar_patrol , us_scout , seen , can_kamikazed , kamikazed , artifact_stolen , artifact_get , artifact_oncargo , game_time , powell_warn , loses_counter , gensher_active , selected , am_veh_consturcted ; function InitVariables ; begin
  94: LD_INT 0
  96: PPUSH
// debug := false ;
  97: LD_ADDR_EXP 1
 101: PUSH
 102: LD_INT 0
 104: ST_TO_ADDR
// game := true ;
 105: LD_ADDR_EXP 2
 109: PUSH
 110: LD_INT 1
 112: ST_TO_ADDR
// mission_prefix := 11_ ;
 113: LD_ADDR_EXP 3
 117: PUSH
 118: LD_STRING 11_
 120: ST_TO_ADDR
// mission_prefix_prev := 10c_ ;
 121: LD_ADDR_EXP 4
 125: PUSH
 126: LD_STRING 10c_
 128: ST_TO_ADDR
// ar_run := false ;
 129: LD_ADDR_EXP 5
 133: PUSH
 134: LD_INT 0
 136: ST_TO_ADDR
// ar_patrol := false ;
 137: LD_ADDR_EXP 7
 141: PUSH
 142: LD_INT 0
 144: ST_TO_ADDR
// base_captured := false ;
 145: LD_ADDR_EXP 6
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// us_scout := 0 ;
 153: LD_ADDR_EXP 8
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// seen := [ 0 , 0 , 0 , 0 , 0 ] ;
 161: LD_ADDR_EXP 9
 165: PUSH
 166: LD_INT 0
 168: PUSH
 169: LD_INT 0
 171: PUSH
 172: LD_INT 0
 174: PUSH
 175: LD_INT 0
 177: PUSH
 178: LD_INT 0
 180: PUSH
 181: EMPTY
 182: LIST
 183: LIST
 184: LIST
 185: LIST
 186: LIST
 187: ST_TO_ADDR
// kamikazed := false ;
 188: LD_ADDR_EXP 11
 192: PUSH
 193: LD_INT 0
 195: ST_TO_ADDR
// artifact_stolen := false ;
 196: LD_ADDR_EXP 12
 200: PUSH
 201: LD_INT 0
 203: ST_TO_ADDR
// artifact_get := false ;
 204: LD_ADDR_EXP 13
 208: PUSH
 209: LD_INT 0
 211: ST_TO_ADDR
// game_time := [ 130 130$00 , 120 120$00 , 115 115$00 , 112 112$00 ] [ Difficulty ] ;
 212: LD_ADDR_EXP 15
 216: PUSH
 217: LD_INT 273000
 219: PUSH
 220: LD_INT 252000
 222: PUSH
 223: LD_INT 241500
 225: PUSH
 226: LD_INT 235200
 228: PUSH
 229: EMPTY
 230: LIST
 231: LIST
 232: LIST
 233: LIST
 234: PUSH
 235: LD_OWVAR 67
 239: ARRAY
 240: ST_TO_ADDR
// powell_warn := false ;
 241: LD_ADDR_EXP 16
 245: PUSH
 246: LD_INT 0
 248: ST_TO_ADDR
// loses_counter := 0 ;
 249: LD_ADDR_EXP 17
 253: PUSH
 254: LD_INT 0
 256: ST_TO_ADDR
// artifact_oncargo := false ;
 257: LD_ADDR_EXP 14
 261: PUSH
 262: LD_INT 0
 264: ST_TO_ADDR
// gensher_active := LoadVariable ( 10_GensherEscape_1 , debug ) ;
 265: LD_ADDR_EXP 18
 269: PUSH
 270: LD_STRING 10_GensherEscape_1
 272: PPUSH
 273: LD_EXP 1
 277: PPUSH
 278: CALL_OW 30
 282: ST_TO_ADDR
// can_kamikazed := false ;
 283: LD_ADDR_EXP 10
 287: PUSH
 288: LD_INT 0
 290: ST_TO_ADDR
// am_veh_consturcted := false ;
 291: LD_ADDR_EXP 20
 295: PUSH
 296: LD_INT 0
 298: ST_TO_ADDR
// end ;
 299: LD_VAR 0 1
 303: RET
// export function CustomInitMacro ; var i ; begin
 304: LD_INT 0
 306: PPUSH
 307: PPUSH
// mc_parking := [ parking_north , parking_west , parking_east ] ;
 308: LD_ADDR_EXP 74
 312: PUSH
 313: LD_INT 20
 315: PUSH
 316: LD_INT 21
 318: PUSH
 319: LD_INT 22
 321: PUSH
 322: EMPTY
 323: LIST
 324: LIST
 325: LIST
 326: ST_TO_ADDR
// mc_scan_area := [ base_north , base_west , base_east ] ;
 327: LD_ADDR_EXP 75
 331: PUSH
 332: LD_INT 28
 334: PUSH
 335: LD_INT 24
 337: PUSH
 338: LD_INT 26
 340: PUSH
 341: EMPTY
 342: LIST
 343: LIST
 344: LIST
 345: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield1_left ) ;
 346: LD_INT 1
 348: PPUSH
 349: LD_INT 4
 351: PUSH
 352: LD_INT 6
 354: PUSH
 355: LD_INT 8
 357: PUSH
 358: LD_INT 9
 360: PUSH
 361: EMPTY
 362: LIST
 363: LIST
 364: LIST
 365: LIST
 366: PUSH
 367: LD_OWVAR 67
 371: ARRAY
 372: PPUSH
 373: LD_INT 3
 375: PPUSH
 376: CALL 42294 0 3
// MC_SetMinesField ( 2 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield2_left ) ;
 380: LD_INT 2
 382: PPUSH
 383: LD_INT 4
 385: PUSH
 386: LD_INT 6
 388: PUSH
 389: LD_INT 8
 391: PUSH
 392: LD_INT 9
 394: PUSH
 395: EMPTY
 396: LIST
 397: LIST
 398: LIST
 399: LIST
 400: PUSH
 401: LD_OWVAR 67
 405: ARRAY
 406: PPUSH
 407: LD_INT 2
 409: PPUSH
 410: CALL 42294 0 3
// MC_SetMinesField ( 3 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield3_left ) ;
 414: LD_INT 3
 416: PPUSH
 417: LD_INT 4
 419: PUSH
 420: LD_INT 6
 422: PUSH
 423: LD_INT 8
 425: PUSH
 426: LD_INT 9
 428: PUSH
 429: EMPTY
 430: LIST
 431: LIST
 432: LIST
 433: LIST
 434: PUSH
 435: LD_OWVAR 67
 439: ARRAY
 440: PPUSH
 441: LD_INT 1
 443: PPUSH
 444: CALL 42294 0 3
// for i = 1 to mc_bases do
 448: LD_ADDR_VAR 0 2
 452: PUSH
 453: DOUBLE
 454: LD_INT 1
 456: DEC
 457: ST_TO_ADDR
 458: LD_EXP 50
 462: PUSH
 463: FOR_TO
 464: IFFALSE 488
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 466: LD_VAR 0 2
 470: PPUSH
 471: LD_EXP 43
 475: PUSH
 476: LD_VAR 0 2
 480: ARRAY
 481: PPUSH
 482: CALL 42739 0 2
 486: GO 463
 488: POP
 489: POP
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] , ] ) ;
 490: LD_INT 1
 492: PPUSH
 493: LD_INT 14
 495: PUSH
 496: LD_INT 1
 498: PUSH
 499: LD_INT 2
 501: PUSH
 502: LD_INT 88
 504: PUSH
 505: EMPTY
 506: LIST
 507: LIST
 508: LIST
 509: LIST
 510: PUSH
 511: LD_INT 14
 513: PUSH
 514: LD_INT 1
 516: PUSH
 517: LD_INT 2
 519: PUSH
 520: LD_INT 88
 522: PUSH
 523: EMPTY
 524: LIST
 525: LIST
 526: LIST
 527: LIST
 528: PUSH
 529: EMPTY
 530: LIST
 531: LIST
 532: PPUSH
 533: CALL 42631 0 2
// MC_SetProduceList ( 2 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 537: LD_INT 2
 539: PPUSH
 540: LD_INT 14
 542: PUSH
 543: LD_INT 1
 545: PUSH
 546: LD_INT 2
 548: PUSH
 549: LD_INT 88
 551: PUSH
 552: EMPTY
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: PUSH
 558: EMPTY
 559: LIST
 560: PPUSH
 561: CALL 42631 0 2
// end ;
 565: LD_VAR 0 1
 569: RET
// function Debuger ; var i ; begin
 570: LD_INT 0
 572: PPUSH
 573: PPUSH
// if not debug then
 574: LD_EXP 1
 578: NOT
 579: IFFALSE 583
// exit ;
 581: GO 619
// game_speed := 5 ;
 583: LD_ADDR_OWVAR 65
 587: PUSH
 588: LD_INT 5
 590: ST_TO_ADDR
// uc_side := 1 ;
 591: LD_ADDR_OWVAR 20
 595: PUSH
 596: LD_INT 1
 598: ST_TO_ADDR
// uc_nation := 1 ;
 599: LD_ADDR_OWVAR 21
 603: PUSH
 604: LD_INT 1
 606: ST_TO_ADDR
// SetSide ( ar_force_south , 1 ) ;
 607: LD_EXP 36
 611: PPUSH
 612: LD_INT 1
 614: PPUSH
 615: CALL_OW 235
// end ;
 619: LD_VAR 0 1
 623: RET
// every 0 0$1 trigger IsDead ( ar_dep_n ) and IsOk ( ar_dep_w ) do
 624: LD_INT 94
 626: PPUSH
 627: CALL_OW 301
 631: PUSH
 632: LD_INT 45
 634: PPUSH
 635: CALL_OW 302
 639: AND
 640: IFFALSE 652
 642: GO 644
 644: DISABLE
// SetAchievement ( ACH_EAST ) ; end_of_file
 645: LD_STRING ACH_EAST
 647: PPUSH
 648: CALL_OW 543
 652: END
// export JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Frank , Kikuchi ; export function PrepareAmerican ; var i , k , un , tmp , vehs , veh , others ; begin
 653: LD_INT 0
 655: PPUSH
 656: PPUSH
 657: PPUSH
 658: PPUSH
 659: PPUSH
 660: PPUSH
 661: PPUSH
 662: PPUSH
// uc_side := 4 ;
 663: LD_ADDR_OWVAR 20
 667: PUSH
 668: LD_INT 4
 670: ST_TO_ADDR
// uc_nation := 1 ;
 671: LD_ADDR_OWVAR 21
 675: PUSH
 676: LD_INT 1
 678: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
 679: LD_ADDR_EXP 30
 683: PUSH
 684: LD_STRING Powell
 686: PPUSH
 687: LD_INT 0
 689: PPUSH
 690: LD_STRING 
 692: PPUSH
 693: CALL 49105 0 3
 697: ST_TO_ADDR
// uc_side := 1 ;
 698: LD_ADDR_OWVAR 20
 702: PUSH
 703: LD_INT 1
 705: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , mission_prefix_prev ) ;
 706: LD_ADDR_EXP 21
 710: PUSH
 711: LD_STRING JMM
 713: PPUSH
 714: LD_EXP 1
 718: NOT
 719: PPUSH
 720: LD_EXP 4
 724: PPUSH
 725: CALL 49105 0 3
 729: ST_TO_ADDR
// if GetClass ( JMM ) > 4 then
 730: LD_EXP 21
 734: PPUSH
 735: CALL_OW 257
 739: PUSH
 740: LD_INT 4
 742: GREATER
 743: IFFALSE 757
// SetClass ( JMM , 1 ) ;
 745: LD_EXP 21
 749: PPUSH
 750: LD_INT 1
 752: PPUSH
 753: CALL_OW 336
// Lisa := PrepareUnit ( Lisa , ( not debug ) , mission_prefix_prev ) ;
 757: LD_ADDR_EXP 22
 761: PUSH
 762: LD_STRING Lisa
 764: PPUSH
 765: LD_EXP 1
 769: NOT
 770: PPUSH
 771: LD_EXP 4
 775: PPUSH
 776: CALL 49105 0 3
 780: ST_TO_ADDR
// if not Lisa then
 781: LD_EXP 22
 785: NOT
 786: IFFALSE 801
// Lisa := CreateCharacter ( 10_Lisa ) ;
 788: LD_ADDR_EXP 22
 792: PUSH
 793: LD_STRING 10_Lisa
 795: PPUSH
 796: CALL_OW 34
 800: ST_TO_ADDR
// if not Lisa then
 801: LD_EXP 22
 805: NOT
 806: IFFALSE 821
// Lisa := CreateCharacter ( 09_Lisa ) ;
 808: LD_ADDR_EXP 22
 812: PUSH
 813: LD_STRING 09_Lisa
 815: PPUSH
 816: CALL_OW 34
 820: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , mission_prefix_prev ) ;
 821: LD_ADDR_EXP 31
 825: PUSH
 826: LD_STRING Cornel
 828: PPUSH
 829: LD_EXP 1
 833: NOT
 834: PPUSH
 835: LD_EXP 4
 839: PPUSH
 840: CALL 49105 0 3
 844: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , mission_prefix_prev ) ;
 845: LD_ADDR_EXP 23
 849: PUSH
 850: LD_STRING Donaldson
 852: PPUSH
 853: LD_EXP 1
 857: NOT
 858: PPUSH
 859: LD_EXP 4
 863: PPUSH
 864: CALL 49105 0 3
 868: ST_TO_ADDR
// if not Donaldson then
 869: LD_EXP 23
 873: NOT
 874: IFFALSE 889
// Donaldson := CreateCharacter ( 10_Donaldson ) ;
 876: LD_ADDR_EXP 23
 880: PUSH
 881: LD_STRING 10_Donaldson
 883: PPUSH
 884: CALL_OW 34
 888: ST_TO_ADDR
// if not Donaldson then
 889: LD_EXP 23
 893: NOT
 894: IFFALSE 909
// Donaldson := CreateCharacter ( 09_Donaldson ) ;
 896: LD_ADDR_EXP 23
 900: PUSH
 901: LD_STRING 09_Donaldson
 903: PPUSH
 904: CALL_OW 34
 908: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , mission_prefix_prev ) ;
 909: LD_ADDR_EXP 24
 913: PUSH
 914: LD_STRING Bobby
 916: PPUSH
 917: LD_EXP 1
 921: NOT
 922: PPUSH
 923: LD_EXP 4
 927: PPUSH
 928: CALL 49105 0 3
 932: ST_TO_ADDR
// if not Bobby then
 933: LD_EXP 24
 937: NOT
 938: IFFALSE 953
// Bobby := CreateCharacter ( 10_Bobby ) ;
 940: LD_ADDR_EXP 24
 944: PUSH
 945: LD_STRING 10_Bobby
 947: PPUSH
 948: CALL_OW 34
 952: ST_TO_ADDR
// if not Bobby then
 953: LD_EXP 24
 957: NOT
 958: IFFALSE 973
// Bobby := CreateCharacter ( 09_Bobby ) ;
 960: LD_ADDR_EXP 24
 964: PUSH
 965: LD_STRING 09_Bobby
 967: PPUSH
 968: CALL_OW 34
 972: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , mission_prefix_prev ) ;
 973: LD_ADDR_EXP 25
 977: PUSH
 978: LD_STRING Cyrus
 980: PPUSH
 981: LD_EXP 1
 985: NOT
 986: PPUSH
 987: LD_EXP 4
 991: PPUSH
 992: CALL 49105 0 3
 996: ST_TO_ADDR
// if not Cyrus then
 997: LD_EXP 25
1001: NOT
1002: IFFALSE 1017
// Cyrus := CreateCharacter ( 10_Cyrus ) ;
1004: LD_ADDR_EXP 25
1008: PUSH
1009: LD_STRING 10_Cyrus
1011: PPUSH
1012: CALL_OW 34
1016: ST_TO_ADDR
// if not Cyrus then
1017: LD_EXP 25
1021: NOT
1022: IFFALSE 1037
// Cyrus := CreateCharacter ( 09_Cyrus ) ;
1024: LD_ADDR_EXP 25
1028: PUSH
1029: LD_STRING 09_Cyrus
1031: PPUSH
1032: CALL_OW 34
1036: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , mission_prefix_prev ) ;
1037: LD_ADDR_EXP 26
1041: PUSH
1042: LD_STRING Denis
1044: PPUSH
1045: LD_EXP 1
1049: NOT
1050: PPUSH
1051: LD_EXP 4
1055: PPUSH
1056: CALL 49105 0 3
1060: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , mission_prefix_prev ) ;
1061: LD_ADDR_EXP 27
1065: PUSH
1066: LD_STRING Brown
1068: PPUSH
1069: LD_EXP 1
1073: NOT
1074: PPUSH
1075: LD_EXP 4
1079: PPUSH
1080: CALL 49105 0 3
1084: ST_TO_ADDR
// if not Brown then
1085: LD_EXP 27
1089: NOT
1090: IFFALSE 1105
// Brown := CreateCharacter ( 10_Brown ) ;
1092: LD_ADDR_EXP 27
1096: PUSH
1097: LD_STRING 10_Brown
1099: PPUSH
1100: CALL_OW 34
1104: ST_TO_ADDR
// if not Brown then
1105: LD_EXP 27
1109: NOT
1110: IFFALSE 1125
// Brown := CreateCharacter ( 08_Brown ) ;
1112: LD_ADDR_EXP 27
1116: PUSH
1117: LD_STRING 08_Brown
1119: PPUSH
1120: CALL_OW 34
1124: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , mission_prefix_prev ) ;
1125: LD_ADDR_EXP 28
1129: PUSH
1130: LD_STRING Gladstone
1132: PPUSH
1133: LD_EXP 1
1137: NOT
1138: PPUSH
1139: LD_EXP 4
1143: PPUSH
1144: CALL 49105 0 3
1148: ST_TO_ADDR
// if not Gladstone then
1149: LD_EXP 28
1153: NOT
1154: IFFALSE 1169
// Gladstone := CreateCharacter ( 10_Gladstone ) ;
1156: LD_ADDR_EXP 28
1160: PUSH
1161: LD_STRING 10_Gladstone
1163: PPUSH
1164: CALL_OW 34
1168: ST_TO_ADDR
// if not Gladstone then
1169: LD_EXP 28
1173: NOT
1174: IFFALSE 1189
// Gladstone := CreateCharacter ( 08_Gladstone ) ;
1176: LD_ADDR_EXP 28
1180: PUSH
1181: LD_STRING 08_Gladstone
1183: PPUSH
1184: CALL_OW 34
1188: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , mission_prefix_prev ) ;
1189: LD_ADDR_EXP 29
1193: PUSH
1194: LD_STRING Houten
1196: PPUSH
1197: LD_EXP 1
1201: NOT
1202: PPUSH
1203: LD_EXP 4
1207: PPUSH
1208: CALL 49105 0 3
1212: ST_TO_ADDR
// if not Houten then
1213: LD_EXP 29
1217: NOT
1218: IFFALSE 1233
// Houten := CreateCharacter ( 10_Houten ) ;
1220: LD_ADDR_EXP 29
1224: PUSH
1225: LD_STRING 10_Houten
1227: PPUSH
1228: CALL_OW 34
1232: ST_TO_ADDR
// if not Houten then
1233: LD_EXP 29
1237: NOT
1238: IFFALSE 1253
// Houten := CreateCharacter ( 09_Houten ) ;
1240: LD_ADDR_EXP 29
1244: PUSH
1245: LD_STRING 09_Houten
1247: PPUSH
1248: CALL_OW 34
1252: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , ( not debug ) , mission_prefix_prev ) ;
1253: LD_ADDR_EXP 31
1257: PUSH
1258: LD_STRING Cornell
1260: PPUSH
1261: LD_EXP 1
1265: NOT
1266: PPUSH
1267: LD_EXP 4
1271: PPUSH
1272: CALL 49105 0 3
1276: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , mission_prefix_prev ) ;
1277: LD_ADDR_EXP 32
1281: PUSH
1282: LD_STRING Gary
1284: PPUSH
1285: LD_EXP 1
1289: NOT
1290: PPUSH
1291: LD_EXP 4
1295: PPUSH
1296: CALL 49105 0 3
1300: ST_TO_ADDR
// if not Gary then
1301: LD_EXP 32
1305: NOT
1306: IFFALSE 1321
// Gary := CreateCharacter ( 10_Gary ) ;
1308: LD_ADDR_EXP 32
1312: PUSH
1313: LD_STRING 10_Gary
1315: PPUSH
1316: CALL_OW 34
1320: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , mission_prefix_prev ) ;
1321: LD_ADDR_EXP 33
1325: PUSH
1326: LD_STRING Frank
1328: PPUSH
1329: LD_EXP 1
1333: NOT
1334: PPUSH
1335: LD_EXP 4
1339: PPUSH
1340: CALL 49105 0 3
1344: ST_TO_ADDR
// if not Frank then
1345: LD_EXP 33
1349: NOT
1350: IFFALSE 1365
// Frank := CreateCharacter ( 08_Frank ) ;
1352: LD_ADDR_EXP 33
1356: PUSH
1357: LD_STRING 08_Frank
1359: PPUSH
1360: CALL_OW 34
1364: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , mission_prefix_prev ) ;
1365: LD_ADDR_EXP 34
1369: PUSH
1370: LD_STRING Kikuchi
1372: PPUSH
1373: LD_EXP 1
1377: NOT
1378: PPUSH
1379: LD_EXP 4
1383: PPUSH
1384: CALL 49105 0 3
1388: ST_TO_ADDR
// if not Kikuchi then
1389: LD_EXP 34
1393: NOT
1394: IFFALSE 1409
// Kikuchi := CreateCharacter ( 08_Kikuchi ) ;
1396: LD_ADDR_EXP 34
1400: PUSH
1401: LD_STRING 08_Kikuchi
1403: PPUSH
1404: CALL_OW 34
1408: ST_TO_ADDR
// tmp := [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1409: LD_ADDR_VAR 0 5
1413: PUSH
1414: LD_EXP 22
1418: PUSH
1419: LD_EXP 23
1423: PUSH
1424: LD_EXP 24
1428: PUSH
1429: LD_EXP 25
1433: PUSH
1434: LD_EXP 26
1438: PUSH
1439: LD_EXP 27
1443: PUSH
1444: LD_EXP 28
1448: PUSH
1449: LD_EXP 29
1453: PUSH
1454: LD_EXP 31
1458: PUSH
1459: LD_EXP 32
1463: PUSH
1464: LD_EXP 33
1468: PUSH
1469: LD_EXP 34
1473: PUSH
1474: EMPTY
1475: LIST
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: LIST
1481: LIST
1482: LIST
1483: LIST
1484: LIST
1485: LIST
1486: LIST
1487: ST_TO_ADDR
// tmp := tmp diff 0 ;
1488: LD_ADDR_VAR 0 5
1492: PUSH
1493: LD_VAR 0 5
1497: PUSH
1498: LD_INT 0
1500: DIFF
1501: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10_other_survivors ) ;
1502: LD_ADDR_VAR 0 5
1506: PUSH
1507: LD_VAR 0 5
1511: PUSH
1512: LD_STRING 10_other_survivors
1514: PPUSH
1515: CALL_OW 31
1519: UNION
1520: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10_lock ) ;
1521: LD_ADDR_VAR 0 5
1525: PUSH
1526: LD_VAR 0 5
1530: PUSH
1531: LD_STRING 10_lock
1533: PPUSH
1534: CALL_OW 31
1538: UNION
1539: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10c_lock ) ;
1540: LD_ADDR_VAR 0 5
1544: PUSH
1545: LD_VAR 0 5
1549: PUSH
1550: LD_STRING 10c_lock
1552: PPUSH
1553: CALL_OW 31
1557: UNION
1558: ST_TO_ADDR
// DeleteCharacters ( 10_lock ) ;
1559: LD_STRING 10_lock
1561: PPUSH
1562: CALL_OW 40
// DeleteCharacters ( 10c_lock ) ;
1566: LD_STRING 10c_lock
1568: PPUSH
1569: CALL_OW 40
// for i in tmp do
1573: LD_ADDR_VAR 0 2
1577: PUSH
1578: LD_VAR 0 5
1582: PUSH
1583: FOR_IN
1584: IFFALSE 1622
// if GetClass ( i ) in [ class_mortar , class_engineer ] then
1586: LD_VAR 0 2
1590: PPUSH
1591: CALL_OW 257
1595: PUSH
1596: LD_INT 8
1598: PUSH
1599: LD_INT 2
1601: PUSH
1602: EMPTY
1603: LIST
1604: LIST
1605: IN
1606: IFFALSE 1620
// SetClass ( i , class_soldier ) ;
1608: LD_VAR 0 2
1612: PPUSH
1613: LD_INT 1
1615: PPUSH
1616: CALL_OW 336
1620: GO 1583
1622: POP
1623: POP
// if tmp < 12 then
1624: LD_VAR 0 5
1628: PUSH
1629: LD_INT 12
1631: LESS
1632: IFFALSE 1726
// begin k := 16 - tmp ;
1634: LD_ADDR_VAR 0 3
1638: PUSH
1639: LD_INT 16
1641: PUSH
1642: LD_VAR 0 5
1646: MINUS
1647: ST_TO_ADDR
// for i = 1 to k do
1648: LD_ADDR_VAR 0 2
1652: PUSH
1653: DOUBLE
1654: LD_INT 1
1656: DEC
1657: ST_TO_ADDR
1658: LD_VAR 0 3
1662: PUSH
1663: FOR_TO
1664: IFFALSE 1724
// begin PrepareHuman ( false , [ 1 , 1 , 3 , 4 ] [ rand ( 1 , 4 ) ] , 6 ) ;
1666: LD_INT 0
1668: PPUSH
1669: LD_INT 1
1671: PUSH
1672: LD_INT 1
1674: PUSH
1675: LD_INT 3
1677: PUSH
1678: LD_INT 4
1680: PUSH
1681: EMPTY
1682: LIST
1683: LIST
1684: LIST
1685: LIST
1686: PUSH
1687: LD_INT 1
1689: PPUSH
1690: LD_INT 4
1692: PPUSH
1693: CALL_OW 12
1697: ARRAY
1698: PPUSH
1699: LD_INT 6
1701: PPUSH
1702: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
1706: LD_ADDR_VAR 0 5
1710: PUSH
1711: LD_VAR 0 5
1715: PUSH
1716: CALL_OW 44
1720: ADD
1721: ST_TO_ADDR
// end ;
1722: GO 1663
1724: POP
1725: POP
// end ; selected := CharacterSelection ( 1 , 12 , 12 , [ sel_change_class , JMM , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp ^ [ sel_dont_change_class , sel_not_changeable , Powell ] , [ [ class_soldier , 4 ] , [ class_mechanic , 0 , 5 ] , [ class_scientistic , 0 , 3 ] , [ class_sniper , 0 , 2 ] ] ) ;
1726: LD_ADDR_EXP 19
1730: PUSH
1731: LD_STRING 1
1733: PPUSH
1734: LD_INT 12
1736: PPUSH
1737: LD_INT 12
1739: PPUSH
1740: LD_INT -5
1742: PUSH
1743: LD_EXP 21
1747: PUSH
1748: LD_INT -2
1750: PUSH
1751: LD_INT -3
1753: PUSH
1754: LD_INT -5
1756: PUSH
1757: EMPTY
1758: LIST
1759: LIST
1760: LIST
1761: LIST
1762: LIST
1763: PUSH
1764: LD_VAR 0 5
1768: ADD
1769: PUSH
1770: LD_INT -6
1772: PUSH
1773: LD_INT -4
1775: PUSH
1776: LD_EXP 30
1780: PUSH
1781: EMPTY
1782: LIST
1783: LIST
1784: LIST
1785: ADD
1786: PPUSH
1787: LD_INT 1
1789: PUSH
1790: LD_INT 4
1792: PUSH
1793: EMPTY
1794: LIST
1795: LIST
1796: PUSH
1797: LD_INT 3
1799: PUSH
1800: LD_INT 0
1802: PUSH
1803: LD_INT 5
1805: PUSH
1806: EMPTY
1807: LIST
1808: LIST
1809: LIST
1810: PUSH
1811: LD_INT 4
1813: PUSH
1814: LD_INT 0
1816: PUSH
1817: LD_INT 3
1819: PUSH
1820: EMPTY
1821: LIST
1822: LIST
1823: LIST
1824: PUSH
1825: LD_INT 5
1827: PUSH
1828: LD_INT 0
1830: PUSH
1831: LD_INT 2
1833: PUSH
1834: EMPTY
1835: LIST
1836: LIST
1837: LIST
1838: PUSH
1839: EMPTY
1840: LIST
1841: LIST
1842: LIST
1843: LIST
1844: PPUSH
1845: CALL_OW 42
1849: ST_TO_ADDR
// others := tmp diff selected ;
1850: LD_ADDR_VAR 0 8
1854: PUSH
1855: LD_VAR 0 5
1859: PUSH
1860: LD_EXP 19
1864: DIFF
1865: ST_TO_ADDR
// others := others diff [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1866: LD_ADDR_VAR 0 8
1870: PUSH
1871: LD_VAR 0 8
1875: PUSH
1876: LD_EXP 22
1880: PUSH
1881: LD_EXP 23
1885: PUSH
1886: LD_EXP 24
1890: PUSH
1891: LD_EXP 25
1895: PUSH
1896: LD_EXP 26
1900: PUSH
1901: LD_EXP 27
1905: PUSH
1906: LD_EXP 28
1910: PUSH
1911: LD_EXP 29
1915: PUSH
1916: LD_EXP 31
1920: PUSH
1921: LD_EXP 32
1925: PUSH
1926: LD_EXP 33
1930: PUSH
1931: LD_EXP 34
1935: PUSH
1936: EMPTY
1937: LIST
1938: LIST
1939: LIST
1940: LIST
1941: LIST
1942: LIST
1943: LIST
1944: LIST
1945: LIST
1946: LIST
1947: LIST
1948: LIST
1949: DIFF
1950: ST_TO_ADDR
// if others then
1951: LD_VAR 0 8
1955: IFFALSE 1969
// SaveCharacters ( others , 11_others ) ;
1957: LD_VAR 0 8
1961: PPUSH
1962: LD_STRING 11_others
1964: PPUSH
1965: CALL_OW 38
// vehs := [ [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun ] , [ us_medium_wheeled , engine_siberite , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_medium_wheeled , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_siberite , control_manual , us_rocket_launcher ] ] ;
1969: LD_ADDR_VAR 0 6
1973: PUSH
1974: LD_INT 3
1976: PUSH
1977: LD_INT 1
1979: PUSH
1980: LD_INT 1
1982: PUSH
1983: LD_INT 4
1985: PUSH
1986: EMPTY
1987: LIST
1988: LIST
1989: LIST
1990: LIST
1991: PUSH
1992: LD_INT 2
1994: PUSH
1995: LD_INT 3
1997: PUSH
1998: LD_INT 1
2000: PUSH
2001: LD_INT 5
2003: PUSH
2004: EMPTY
2005: LIST
2006: LIST
2007: LIST
2008: LIST
2009: PUSH
2010: LD_INT 4
2012: PUSH
2013: LD_INT 1
2015: PUSH
2016: LD_INT 1
2018: PUSH
2019: LD_INT 5
2021: PUSH
2022: EMPTY
2023: LIST
2024: LIST
2025: LIST
2026: LIST
2027: PUSH
2028: LD_INT 2
2030: PUSH
2031: LD_INT 1
2033: PUSH
2034: LD_INT 1
2036: PUSH
2037: LD_INT 7
2039: PUSH
2040: EMPTY
2041: LIST
2042: LIST
2043: LIST
2044: LIST
2045: PUSH
2046: LD_INT 3
2048: PUSH
2049: LD_INT 3
2051: PUSH
2052: LD_INT 1
2054: PUSH
2055: LD_INT 7
2057: PUSH
2058: EMPTY
2059: LIST
2060: LIST
2061: LIST
2062: LIST
2063: PUSH
2064: EMPTY
2065: LIST
2066: LIST
2067: LIST
2068: LIST
2069: LIST
2070: ST_TO_ADDR
// for i in JMM ^ selected do
2071: LD_ADDR_VAR 0 2
2075: PUSH
2076: LD_EXP 21
2080: PUSH
2081: LD_EXP 19
2085: ADD
2086: PUSH
2087: FOR_IN
2088: IFFALSE 2278
// begin if GetClass ( i ) = 3 then
2090: LD_VAR 0 2
2094: PPUSH
2095: CALL_OW 257
2099: PUSH
2100: LD_INT 3
2102: EQUAL
2103: IFFALSE 2261
// begin vc_chassis := vehs [ 1 ] [ 1 ] ;
2105: LD_ADDR_OWVAR 37
2109: PUSH
2110: LD_VAR 0 6
2114: PUSH
2115: LD_INT 1
2117: ARRAY
2118: PUSH
2119: LD_INT 1
2121: ARRAY
2122: ST_TO_ADDR
// vc_engine := vehs [ 1 ] [ 2 ] ;
2123: LD_ADDR_OWVAR 39
2127: PUSH
2128: LD_VAR 0 6
2132: PUSH
2133: LD_INT 1
2135: ARRAY
2136: PUSH
2137: LD_INT 2
2139: ARRAY
2140: ST_TO_ADDR
// vc_control := vehs [ 1 ] [ 3 ] ;
2141: LD_ADDR_OWVAR 38
2145: PUSH
2146: LD_VAR 0 6
2150: PUSH
2151: LD_INT 1
2153: ARRAY
2154: PUSH
2155: LD_INT 3
2157: ARRAY
2158: ST_TO_ADDR
// vc_weapon := vehs [ 1 ] [ 4 ] ;
2159: LD_ADDR_OWVAR 40
2163: PUSH
2164: LD_VAR 0 6
2168: PUSH
2169: LD_INT 1
2171: ARRAY
2172: PUSH
2173: LD_INT 4
2175: ARRAY
2176: ST_TO_ADDR
// vehs := Delete ( vehs , 1 ) ;
2177: LD_ADDR_VAR 0 6
2181: PUSH
2182: LD_VAR 0 6
2186: PPUSH
2187: LD_INT 1
2189: PPUSH
2190: CALL_OW 3
2194: ST_TO_ADDR
// veh := CreateVehicle ;
2195: LD_ADDR_VAR 0 7
2199: PUSH
2200: CALL_OW 45
2204: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2205: LD_VAR 0 7
2209: PPUSH
2210: LD_INT 8
2212: PPUSH
2213: LD_INT 0
2215: PPUSH
2216: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
2220: LD_VAR 0 2
2224: PPUSH
2225: LD_VAR 0 7
2229: PPUSH
2230: CALL_OW 52
// if i = JMM then
2234: LD_VAR 0 2
2238: PUSH
2239: LD_EXP 21
2243: EQUAL
2244: IFFALSE 2259
// SetMark ( veh , - 1 ) ;
2246: LD_VAR 0 7
2250: PPUSH
2251: LD_INT 1
2253: NEG
2254: PPUSH
2255: CALL_OW 242
// end else
2259: GO 2276
// PlaceUnitArea ( i , am_hum_start , false ) ;
2261: LD_VAR 0 2
2265: PPUSH
2266: LD_INT 9
2268: PPUSH
2269: LD_INT 0
2271: PPUSH
2272: CALL_OW 49
// end ;
2276: GO 2087
2278: POP
2279: POP
// vc_chassis := us_medium_tracked ;
2280: LD_ADDR_OWVAR 37
2284: PUSH
2285: LD_INT 3
2287: ST_TO_ADDR
// vc_engine := engine_solar ;
2288: LD_ADDR_OWVAR 39
2292: PUSH
2293: LD_INT 2
2295: ST_TO_ADDR
// vc_control := control_computer ;
2296: LD_ADDR_OWVAR 38
2300: PUSH
2301: LD_INT 3
2303: ST_TO_ADDR
// vc_weapon := us_radar ;
2304: LD_ADDR_OWVAR 40
2308: PUSH
2309: LD_INT 11
2311: ST_TO_ADDR
// veh := CreateVehicle ;
2312: LD_ADDR_VAR 0 7
2316: PUSH
2317: CALL_OW 45
2321: ST_TO_ADDR
// PlaceUnitXY ( veh , 87 , 142 , false ) ;
2322: LD_VAR 0 7
2326: PPUSH
2327: LD_INT 87
2329: PPUSH
2330: LD_INT 142
2332: PPUSH
2333: LD_INT 0
2335: PPUSH
2336: CALL_OW 48
// end ;
2340: LD_VAR 0 1
2344: RET
// export function AmericanReinforcements ; var i , vehs , veh ; begin
2345: LD_INT 0
2347: PPUSH
2348: PPUSH
2349: PPUSH
2350: PPUSH
// uc_side := 1 ;
2351: LD_ADDR_OWVAR 20
2355: PUSH
2356: LD_INT 1
2358: ST_TO_ADDR
// uc_nation := 1 ;
2359: LD_ADDR_OWVAR 21
2363: PUSH
2364: LD_INT 1
2366: ST_TO_ADDR
// vehs := [ [ us_medium_tracked , engine_combustion , control_computer , us_double_gun ] , [ us_medium_tracked , engine_combustion , control_computer , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_computer , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_computer , us_radar ] , [ us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_computer , us_double_gun ] ] ;
2367: LD_ADDR_VAR 0 3
2371: PUSH
2372: LD_INT 3
2374: PUSH
2375: LD_INT 1
2377: PUSH
2378: LD_INT 3
2380: PUSH
2381: LD_INT 5
2383: PUSH
2384: EMPTY
2385: LIST
2386: LIST
2387: LIST
2388: LIST
2389: PUSH
2390: LD_INT 3
2392: PUSH
2393: LD_INT 1
2395: PUSH
2396: LD_INT 3
2398: PUSH
2399: LD_INT 7
2401: PUSH
2402: EMPTY
2403: LIST
2404: LIST
2405: LIST
2406: LIST
2407: PUSH
2408: LD_INT 3
2410: PUSH
2411: LD_INT 1
2413: PUSH
2414: LD_INT 3
2416: PUSH
2417: LD_INT 7
2419: PUSH
2420: EMPTY
2421: LIST
2422: LIST
2423: LIST
2424: LIST
2425: PUSH
2426: LD_INT 3
2428: PUSH
2429: LD_INT 1
2431: PUSH
2432: LD_INT 3
2434: PUSH
2435: LD_INT 11
2437: PUSH
2438: EMPTY
2439: LIST
2440: LIST
2441: LIST
2442: LIST
2443: PUSH
2444: LD_INT 4
2446: PUSH
2447: LD_INT 1
2449: PUSH
2450: LD_INT 3
2452: PUSH
2453: LD_INT 6
2455: PUSH
2456: EMPTY
2457: LIST
2458: LIST
2459: LIST
2460: LIST
2461: PUSH
2462: LD_INT 4
2464: PUSH
2465: LD_INT 1
2467: PUSH
2468: LD_INT 3
2470: PUSH
2471: LD_INT 5
2473: PUSH
2474: EMPTY
2475: LIST
2476: LIST
2477: LIST
2478: LIST
2479: PUSH
2480: EMPTY
2481: LIST
2482: LIST
2483: LIST
2484: LIST
2485: LIST
2486: LIST
2487: ST_TO_ADDR
// for i := 1 to 7 - Difficulty do
2488: LD_ADDR_VAR 0 2
2492: PUSH
2493: DOUBLE
2494: LD_INT 1
2496: DEC
2497: ST_TO_ADDR
2498: LD_INT 7
2500: PUSH
2501: LD_OWVAR 67
2505: MINUS
2506: PUSH
2507: FOR_TO
2508: IFFALSE 2617
// begin vc_chassis := vehs [ i ] [ 1 ] ;
2510: LD_ADDR_OWVAR 37
2514: PUSH
2515: LD_VAR 0 3
2519: PUSH
2520: LD_VAR 0 2
2524: ARRAY
2525: PUSH
2526: LD_INT 1
2528: ARRAY
2529: ST_TO_ADDR
// vc_engine := vehs [ i ] [ 2 ] ;
2530: LD_ADDR_OWVAR 39
2534: PUSH
2535: LD_VAR 0 3
2539: PUSH
2540: LD_VAR 0 2
2544: ARRAY
2545: PUSH
2546: LD_INT 2
2548: ARRAY
2549: ST_TO_ADDR
// vc_control := vehs [ i ] [ 3 ] ;
2550: LD_ADDR_OWVAR 38
2554: PUSH
2555: LD_VAR 0 3
2559: PUSH
2560: LD_VAR 0 2
2564: ARRAY
2565: PUSH
2566: LD_INT 3
2568: ARRAY
2569: ST_TO_ADDR
// vc_weapon := vehs [ i ] [ 4 ] ;
2570: LD_ADDR_OWVAR 40
2574: PUSH
2575: LD_VAR 0 3
2579: PUSH
2580: LD_VAR 0 2
2584: ARRAY
2585: PUSH
2586: LD_INT 4
2588: ARRAY
2589: ST_TO_ADDR
// veh := CreateVehicle ;
2590: LD_ADDR_VAR 0 4
2594: PUSH
2595: CALL_OW 45
2599: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2600: LD_VAR 0 4
2604: PPUSH
2605: LD_INT 8
2607: PPUSH
2608: LD_INT 0
2610: PPUSH
2611: CALL_OW 49
// end ;
2615: GO 2507
2617: POP
2618: POP
// end ; end_of_file
2619: LD_VAR 0 1
2623: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_north_2 , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_kamikadze , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ; var i , d , un , skill , tmp ; begin
2624: LD_INT 0
2626: PPUSH
2627: PPUSH
2628: PPUSH
2629: PPUSH
2630: PPUSH
2631: PPUSH
// if Difficulty = 1 then
2632: LD_OWVAR 67
2636: PUSH
2637: LD_INT 1
2639: EQUAL
2640: IFFALSE 2737
// begin tmp := [ [ 129 , 45 ] , [ 143 , 58 ] , [ 184 , 113 ] , [ 163 , 107 ] ] ;
2642: LD_ADDR_VAR 0 6
2646: PUSH
2647: LD_INT 129
2649: PUSH
2650: LD_INT 45
2652: PUSH
2653: EMPTY
2654: LIST
2655: LIST
2656: PUSH
2657: LD_INT 143
2659: PUSH
2660: LD_INT 58
2662: PUSH
2663: EMPTY
2664: LIST
2665: LIST
2666: PUSH
2667: LD_INT 184
2669: PUSH
2670: LD_INT 113
2672: PUSH
2673: EMPTY
2674: LIST
2675: LIST
2676: PUSH
2677: LD_INT 163
2679: PUSH
2680: LD_INT 107
2682: PUSH
2683: EMPTY
2684: LIST
2685: LIST
2686: PUSH
2687: EMPTY
2688: LIST
2689: LIST
2690: LIST
2691: LIST
2692: ST_TO_ADDR
// for i in tmp do
2693: LD_ADDR_VAR 0 2
2697: PUSH
2698: LD_VAR 0 6
2702: PUSH
2703: FOR_IN
2704: IFFALSE 2735
// RemoveUnit ( HexInfo ( i [ 1 ] , i [ 2 ] ) ) ;
2706: LD_VAR 0 2
2710: PUSH
2711: LD_INT 1
2713: ARRAY
2714: PPUSH
2715: LD_VAR 0 2
2719: PUSH
2720: LD_INT 2
2722: ARRAY
2723: PPUSH
2724: CALL_OW 428
2728: PPUSH
2729: CALL_OW 64
2733: GO 2703
2735: POP
2736: POP
// end ; for i in FilterAllUnits ( [ f_type , unit_building ] ) do
2737: LD_ADDR_VAR 0 2
2741: PUSH
2742: LD_INT 21
2744: PUSH
2745: LD_INT 3
2747: PUSH
2748: EMPTY
2749: LIST
2750: LIST
2751: PPUSH
2752: CALL_OW 69
2756: PUSH
2757: FOR_IN
2758: IFFALSE 2795
// SetBLevel ( i , [ 5 , 6 , 7 , 8 ] [ Difficulty ] ) ;
2760: LD_VAR 0 2
2764: PPUSH
2765: LD_INT 5
2767: PUSH
2768: LD_INT 6
2770: PUSH
2771: LD_INT 7
2773: PUSH
2774: LD_INT 8
2776: PUSH
2777: EMPTY
2778: LIST
2779: LIST
2780: LIST
2781: LIST
2782: PUSH
2783: LD_OWVAR 67
2787: ARRAY
2788: PPUSH
2789: CALL_OW 241
2793: GO 2757
2795: POP
2796: POP
// skill := [ 5 , 6 , 7 , 8 ] [ Difficulty ] ;
2797: LD_ADDR_VAR 0 5
2801: PUSH
2802: LD_INT 5
2804: PUSH
2805: LD_INT 6
2807: PUSH
2808: LD_INT 7
2810: PUSH
2811: LD_INT 8
2813: PUSH
2814: EMPTY
2815: LIST
2816: LIST
2817: LIST
2818: LIST
2819: PUSH
2820: LD_OWVAR 67
2824: ARRAY
2825: ST_TO_ADDR
// uc_side := 2 ;
2826: LD_ADDR_OWVAR 20
2830: PUSH
2831: LD_INT 2
2833: ST_TO_ADDR
// uc_nation := 2 ;
2834: LD_ADDR_OWVAR 21
2838: PUSH
2839: LD_INT 2
2841: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
2842: LD_ADDR_OWVAR 37
2846: PUSH
2847: LD_INT 14
2849: ST_TO_ADDR
// vc_engine := engine_siberite ;
2850: LD_ADDR_OWVAR 39
2854: PUSH
2855: LD_INT 3
2857: ST_TO_ADDR
// vc_control := control_manual ;
2858: LD_ADDR_OWVAR 38
2862: PUSH
2863: LD_INT 1
2865: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
2866: LD_ADDR_OWVAR 40
2870: PUSH
2871: LD_INT 31
2873: ST_TO_ADDR
// for i = 1 to 3 do
2874: LD_ADDR_VAR 0 2
2878: PUSH
2879: DOUBLE
2880: LD_INT 1
2882: DEC
2883: ST_TO_ADDR
2884: LD_INT 3
2886: PUSH
2887: FOR_TO
2888: IFFALSE 2972
// begin PrepareHuman ( false , class_mechanic , skill ) ;
2890: LD_INT 0
2892: PPUSH
2893: LD_INT 3
2895: PPUSH
2896: LD_VAR 0 5
2900: PPUSH
2901: CALL_OW 380
// un := CreateVehicle ;
2905: LD_ADDR_VAR 0 4
2909: PUSH
2910: CALL_OW 45
2914: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
2915: LD_VAR 0 4
2919: PPUSH
2920: LD_INT 0
2922: PPUSH
2923: LD_INT 5
2925: PPUSH
2926: CALL_OW 12
2930: PPUSH
2931: CALL_OW 233
// PlaceUnitXYR ( un , 156 , 15 , 6 , false ) ;
2935: LD_VAR 0 4
2939: PPUSH
2940: LD_INT 156
2942: PPUSH
2943: LD_INT 15
2945: PPUSH
2946: LD_INT 6
2948: PPUSH
2949: LD_INT 0
2951: PPUSH
2952: CALL_OW 50
// PlaceHumanInUnit ( CreateHuman , un ) ;
2956: CALL_OW 44
2960: PPUSH
2961: LD_VAR 0 4
2965: PPUSH
2966: CALL_OW 52
// end ;
2970: GO 2887
2972: POP
2973: POP
// ar_force_north := PrepareBase ( ar_dep_n , base_north , dammam , skill , [ 10000 , 1000 , 300 ] , [ 12 , [ 2 , 3 , 4 , 4 ] [ Difficulty ] , - 1 , 4 ] ) ;
2974: LD_ADDR_EXP 37
2978: PUSH
2979: LD_INT 94
2981: PPUSH
2982: LD_INT 28
2984: PPUSH
2985: LD_STRING dammam
2987: PPUSH
2988: LD_VAR 0 5
2992: PPUSH
2993: LD_INT 10000
2995: PUSH
2996: LD_INT 1000
2998: PUSH
2999: LD_INT 300
3001: PUSH
3002: EMPTY
3003: LIST
3004: LIST
3005: LIST
3006: PPUSH
3007: LD_INT 12
3009: PUSH
3010: LD_INT 2
3012: PUSH
3013: LD_INT 3
3015: PUSH
3016: LD_INT 4
3018: PUSH
3019: LD_INT 4
3021: PUSH
3022: EMPTY
3023: LIST
3024: LIST
3025: LIST
3026: LIST
3027: PUSH
3028: LD_OWVAR 67
3032: ARRAY
3033: PUSH
3034: LD_INT 1
3036: NEG
3037: PUSH
3038: LD_INT 4
3040: PUSH
3041: EMPTY
3042: LIST
3043: LIST
3044: LIST
3045: LIST
3046: PPUSH
3047: CALL 57766 0 6
3051: ST_TO_ADDR
// ar_force_north := ar_force_north union PrepareBase ( ar_dep_n2 , base_north_2 ,  , skill , [ 500 , 60 , 0 ] , [ 8 , [ 2 , 3 , 4 , 5 ] [ Difficulty ] , 2 , 0 ] ) ;
3052: LD_ADDR_EXP 37
3056: PUSH
3057: LD_EXP 37
3061: PUSH
3062: LD_INT 122
3064: PPUSH
3065: LD_INT 25
3067: PPUSH
3068: LD_STRING 
3070: PPUSH
3071: LD_VAR 0 5
3075: PPUSH
3076: LD_INT 500
3078: PUSH
3079: LD_INT 60
3081: PUSH
3082: LD_INT 0
3084: PUSH
3085: EMPTY
3086: LIST
3087: LIST
3088: LIST
3089: PPUSH
3090: LD_INT 8
3092: PUSH
3093: LD_INT 2
3095: PUSH
3096: LD_INT 3
3098: PUSH
3099: LD_INT 4
3101: PUSH
3102: LD_INT 5
3104: PUSH
3105: EMPTY
3106: LIST
3107: LIST
3108: LIST
3109: LIST
3110: PUSH
3111: LD_OWVAR 67
3115: ARRAY
3116: PUSH
3117: LD_INT 2
3119: PUSH
3120: LD_INT 0
3122: PUSH
3123: EMPTY
3124: LIST
3125: LIST
3126: LIST
3127: LIST
3128: PPUSH
3129: CALL 57766 0 6
3133: UNION
3134: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , base_west , jeddah , skill , [ 700 , 300 , 10 ] , [ 9 , 4 , 3 , 2 ] ) ;
3135: LD_ADDR_EXP 35
3139: PUSH
3140: LD_INT 45
3142: PPUSH
3143: LD_INT 24
3145: PPUSH
3146: LD_STRING jeddah
3148: PPUSH
3149: LD_VAR 0 5
3153: PPUSH
3154: LD_INT 700
3156: PUSH
3157: LD_INT 300
3159: PUSH
3160: LD_INT 10
3162: PUSH
3163: EMPTY
3164: LIST
3165: LIST
3166: LIST
3167: PPUSH
3168: LD_INT 9
3170: PUSH
3171: LD_INT 4
3173: PUSH
3174: LD_INT 3
3176: PUSH
3177: LD_INT 2
3179: PUSH
3180: EMPTY
3181: LIST
3182: LIST
3183: LIST
3184: LIST
3185: PPUSH
3186: CALL 57766 0 6
3190: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , base_south , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
3191: LD_ADDR_EXP 36
3195: PUSH
3196: LD_INT 7
3198: PPUSH
3199: LD_INT 27
3201: PPUSH
3202: LD_STRING riyadh
3204: PPUSH
3205: LD_VAR 0 5
3209: PPUSH
3210: LD_INT 500
3212: PUSH
3213: LD_INT 60
3215: PUSH
3216: LD_INT 0
3218: PUSH
3219: EMPTY
3220: LIST
3221: LIST
3222: LIST
3223: PPUSH
3224: LD_INT 4
3226: PUSH
3227: LD_INT 2
3229: PUSH
3230: LD_INT 3
3232: PUSH
3233: LD_INT 1
3235: PUSH
3236: EMPTY
3237: LIST
3238: LIST
3239: LIST
3240: LIST
3241: PPUSH
3242: CALL 57766 0 6
3246: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e , base_east ,  , skill , [ 500 , 50 , 0 ] , [ 9 , 2 , 3 , 1 ] ) ;
3247: LD_ADDR_EXP 39
3251: PUSH
3252: LD_INT 204
3254: PPUSH
3255: LD_INT 26
3257: PPUSH
3258: LD_STRING 
3260: PPUSH
3261: LD_VAR 0 5
3265: PPUSH
3266: LD_INT 500
3268: PUSH
3269: LD_INT 50
3271: PUSH
3272: LD_INT 0
3274: PUSH
3275: EMPTY
3276: LIST
3277: LIST
3278: LIST
3279: PPUSH
3280: LD_INT 9
3282: PUSH
3283: LD_INT 2
3285: PUSH
3286: LD_INT 3
3288: PUSH
3289: LD_INT 1
3291: PUSH
3292: EMPTY
3293: LIST
3294: LIST
3295: LIST
3296: LIST
3297: PPUSH
3298: CALL 57766 0 6
3302: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east ] ;
3303: LD_ADDR_EXP 50
3307: PUSH
3308: LD_EXP 37
3312: PUSH
3313: LD_EXP 35
3317: PUSH
3318: LD_EXP 39
3322: PUSH
3323: EMPTY
3324: LIST
3325: LIST
3326: LIST
3327: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
3328: LD_ADDR_VAR 0 2
3332: PUSH
3333: LD_INT 22
3335: PUSH
3336: LD_INT 2
3338: PUSH
3339: EMPTY
3340: LIST
3341: LIST
3342: PUSH
3343: LD_INT 30
3345: PUSH
3346: LD_INT 31
3348: PUSH
3349: EMPTY
3350: LIST
3351: LIST
3352: PUSH
3353: LD_INT 58
3355: PUSH
3356: EMPTY
3357: LIST
3358: PUSH
3359: EMPTY
3360: LIST
3361: LIST
3362: LIST
3363: PPUSH
3364: CALL_OW 69
3368: PUSH
3369: FOR_IN
3370: IFFALSE 3495
// begin if GetBase ( i ) then
3372: LD_VAR 0 2
3376: PPUSH
3377: CALL_OW 274
3381: IFFALSE 3385
// continue ;
3383: GO 3369
// d := GetDir ( i ) ;
3385: LD_ADDR_VAR 0 3
3389: PUSH
3390: LD_VAR 0 2
3394: PPUSH
3395: CALL_OW 254
3399: ST_TO_ADDR
// if d < 3 then
3400: LD_VAR 0 3
3404: PUSH
3405: LD_INT 3
3407: LESS
3408: IFFALSE 3426
// d := d + 3 else
3410: LD_ADDR_VAR 0 3
3414: PUSH
3415: LD_VAR 0 3
3419: PUSH
3420: LD_INT 3
3422: PLUS
3423: ST_TO_ADDR
3424: GO 3440
// d := d - 3 ;
3426: LD_ADDR_VAR 0 3
3430: PUSH
3431: LD_VAR 0 3
3435: PUSH
3436: LD_INT 3
3438: MINUS
3439: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
3440: LD_INT 0
3442: PPUSH
3443: LD_INT 8
3445: PPUSH
3446: LD_VAR 0 5
3450: PPUSH
3451: CALL_OW 380
// un := CreateHuman ;
3455: LD_ADDR_VAR 0 4
3459: PUSH
3460: CALL_OW 44
3464: ST_TO_ADDR
// SetDir ( un , d ) ;
3465: LD_VAR 0 4
3469: PPUSH
3470: LD_VAR 0 3
3474: PPUSH
3475: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
3479: LD_VAR 0 4
3483: PPUSH
3484: LD_VAR 0 2
3488: PPUSH
3489: CALL_OW 52
// end ;
3493: GO 3369
3495: POP
3496: POP
// if Difficulty > 1 then
3497: LD_OWVAR 67
3501: PUSH
3502: LD_INT 1
3504: GREATER
3505: IFFALSE 3876
// begin ar_kamikadze := [ ] ;
3507: LD_ADDR_EXP 42
3511: PUSH
3512: EMPTY
3513: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
3514: LD_INT 0
3516: PPUSH
3517: LD_INT 1
3519: PPUSH
3520: LD_VAR 0 5
3524: PPUSH
3525: CALL_OW 380
// un := CreateHuman ;
3529: LD_ADDR_VAR 0 4
3533: PUSH
3534: CALL_OW 44
3538: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3539: LD_VAR 0 4
3543: PPUSH
3544: LD_INT 3
3546: PPUSH
3547: CALL_OW 233
// PlaceUnitXY ( un , 23 , 44 , false ) ;
3551: LD_VAR 0 4
3555: PPUSH
3556: LD_INT 23
3558: PPUSH
3559: LD_INT 44
3561: PPUSH
3562: LD_INT 0
3564: PPUSH
3565: CALL_OW 48
// ComCrawl ( un ) ;
3569: LD_VAR 0 4
3573: PPUSH
3574: CALL_OW 137
// un := CreateHuman ;
3578: LD_ADDR_VAR 0 4
3582: PUSH
3583: CALL_OW 44
3587: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3588: LD_VAR 0 4
3592: PPUSH
3593: LD_INT 3
3595: PPUSH
3596: CALL_OW 233
// PlaceUnitXY ( un , 30 , 39 , false ) ;
3600: LD_VAR 0 4
3604: PPUSH
3605: LD_INT 30
3607: PPUSH
3608: LD_INT 39
3610: PPUSH
3611: LD_INT 0
3613: PPUSH
3614: CALL_OW 48
// ComCrawl ( un ) ;
3618: LD_VAR 0 4
3622: PPUSH
3623: CALL_OW 137
// PrepareHuman ( false , 17 , skill ) ;
3627: LD_INT 0
3629: PPUSH
3630: LD_INT 17
3632: PPUSH
3633: LD_VAR 0 5
3637: PPUSH
3638: CALL_OW 380
// un := CreateHuman ;
3642: LD_ADDR_VAR 0 4
3646: PUSH
3647: CALL_OW 44
3651: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3652: LD_VAR 0 4
3656: PPUSH
3657: LD_INT 3
3659: PPUSH
3660: CALL_OW 233
// PlaceUnitXY ( un , 45 , 86 , false ) ;
3664: LD_VAR 0 4
3668: PPUSH
3669: LD_INT 45
3671: PPUSH
3672: LD_INT 86
3674: PPUSH
3675: LD_INT 0
3677: PPUSH
3678: CALL_OW 48
// ComHold ( un ) ;
3682: LD_VAR 0 4
3686: PPUSH
3687: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3691: LD_ADDR_EXP 42
3695: PUSH
3696: LD_EXP 42
3700: PPUSH
3701: LD_EXP 42
3705: PUSH
3706: LD_INT 1
3708: PLUS
3709: PPUSH
3710: LD_VAR 0 4
3714: PPUSH
3715: CALL_OW 1
3719: ST_TO_ADDR
// un := CreateHuman ;
3720: LD_ADDR_VAR 0 4
3724: PUSH
3725: CALL_OW 44
3729: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3730: LD_VAR 0 4
3734: PPUSH
3735: LD_INT 3
3737: PPUSH
3738: CALL_OW 233
// PlaceUnitXY ( un , 60 , 85 , false ) ;
3742: LD_VAR 0 4
3746: PPUSH
3747: LD_INT 60
3749: PPUSH
3750: LD_INT 85
3752: PPUSH
3753: LD_INT 0
3755: PPUSH
3756: CALL_OW 48
// ComHold ( un ) ;
3760: LD_VAR 0 4
3764: PPUSH
3765: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3769: LD_ADDR_EXP 42
3773: PUSH
3774: LD_EXP 42
3778: PPUSH
3779: LD_EXP 42
3783: PUSH
3784: LD_INT 1
3786: PLUS
3787: PPUSH
3788: LD_VAR 0 4
3792: PPUSH
3793: CALL_OW 1
3797: ST_TO_ADDR
// un := CreateHuman ;
3798: LD_ADDR_VAR 0 4
3802: PUSH
3803: CALL_OW 44
3807: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3808: LD_VAR 0 4
3812: PPUSH
3813: LD_INT 3
3815: PPUSH
3816: CALL_OW 233
// PlaceUnitXY ( un , 222 , 166 , false ) ;
3820: LD_VAR 0 4
3824: PPUSH
3825: LD_INT 222
3827: PPUSH
3828: LD_INT 166
3830: PPUSH
3831: LD_INT 0
3833: PPUSH
3834: CALL_OW 48
// ComHold ( un ) ;
3838: LD_VAR 0 4
3842: PPUSH
3843: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3847: LD_ADDR_EXP 42
3851: PUSH
3852: LD_EXP 42
3856: PPUSH
3857: LD_EXP 42
3861: PUSH
3862: LD_INT 1
3864: PLUS
3865: PPUSH
3866: LD_VAR 0 4
3870: PPUSH
3871: CALL_OW 1
3875: ST_TO_ADDR
// end ; ar_force_tmp := [ ] ;
3876: LD_ADDR_EXP 40
3880: PUSH
3881: EMPTY
3882: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
3883: LD_INT 1
3885: PPUSH
3886: LD_INT 1
3888: PPUSH
3889: LD_VAR 0 5
3893: PPUSH
3894: CALL_OW 380
// hc_name := Pavel Grigorovic ;
3898: LD_ADDR_OWVAR 26
3902: PUSH
3903: LD_STRING Pavel Grigorovic
3905: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3906: LD_ADDR_OWVAR 33
3910: PUSH
3911: LD_STRING SecondCharsGal
3913: ST_TO_ADDR
// hc_face_number := 4 ;
3914: LD_ADDR_OWVAR 34
3918: PUSH
3919: LD_INT 4
3921: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
3922: LD_ADDR_EXP 40
3926: PUSH
3927: LD_EXP 40
3931: PPUSH
3932: LD_INT 1
3934: PPUSH
3935: CALL_OW 44
3939: PPUSH
3940: CALL_OW 1
3944: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3945: LD_INT 2
3947: PPUSH
3948: LD_INT 4
3950: PPUSH
3951: LD_INT 2
3953: PPUSH
3954: CALL_OW 380
// hc_name := Lucy Sebel ;
3958: LD_ADDR_OWVAR 26
3962: PUSH
3963: LD_STRING Lucy Sebel
3965: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3966: LD_ADDR_OWVAR 33
3970: PUSH
3971: LD_STRING SecondCharsGal
3973: ST_TO_ADDR
// hc_face_number := 15 ;
3974: LD_ADDR_OWVAR 34
3978: PUSH
3979: LD_INT 15
3981: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
3982: LD_ADDR_EXP 40
3986: PUSH
3987: LD_EXP 40
3991: PPUSH
3992: LD_INT 2
3994: PPUSH
3995: CALL_OW 44
3999: PPUSH
4000: CALL_OW 1
4004: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
4005: LD_INT 2
4007: PPUSH
4008: LD_INT 4
4010: PPUSH
4011: LD_INT 2
4013: PPUSH
4014: CALL_OW 380
// hc_gallery :=  ;
4018: LD_ADDR_OWVAR 33
4022: PUSH
4023: LD_STRING 
4025: ST_TO_ADDR
// hc_name :=  ;
4026: LD_ADDR_OWVAR 26
4030: PUSH
4031: LD_STRING 
4033: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
4034: LD_ADDR_EXP 40
4038: PUSH
4039: LD_EXP 40
4043: PPUSH
4044: LD_INT 3
4046: PPUSH
4047: CALL_OW 44
4051: PPUSH
4052: CALL_OW 1
4056: ST_TO_ADDR
// hc_sex := sex_male ;
4057: LD_ADDR_OWVAR 27
4061: PUSH
4062: LD_INT 1
4064: ST_TO_ADDR
// hc_class = 11 ;
4065: LD_ADDR_OWVAR 28
4069: PUSH
4070: LD_INT 11
4072: ST_TO_ADDR
// hc_gallery = sandar ;
4073: LD_ADDR_OWVAR 33
4077: PUSH
4078: LD_STRING sandar
4080: ST_TO_ADDR
// hc_face_number = 33 ;
4081: LD_ADDR_OWVAR 34
4085: PUSH
4086: LD_INT 33
4088: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
4089: LD_ADDR_OWVAR 26
4093: PUSH
4094: LD_STRING Thabit Muhair Saliba
4096: ST_TO_ADDR
// hc_skills = [ 0 , 0 , 0 , 0 ] ;
4097: LD_ADDR_OWVAR 31
4101: PUSH
4102: LD_INT 0
4104: PUSH
4105: LD_INT 0
4107: PUSH
4108: LD_INT 0
4110: PUSH
4111: LD_INT 0
4113: PUSH
4114: EMPTY
4115: LIST
4116: LIST
4117: LIST
4118: LIST
4119: ST_TO_ADDR
// Saliba = CreateHuman ;
4120: LD_ADDR_EXP 44
4124: PUSH
4125: CALL_OW 44
4129: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
4130: LD_EXP 44
4134: PPUSH
4135: LD_INT 7
4137: PPUSH
4138: CALL_OW 52
// if gensher_active then
4142: LD_EXP 18
4146: IFFALSE 4173
// begin Gensher = NewCharacter ( Dietrich ) ;
4148: LD_ADDR_EXP 45
4152: PUSH
4153: LD_STRING Dietrich
4155: PPUSH
4156: CALL_OW 25
4160: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
4161: LD_EXP 45
4165: PPUSH
4166: LD_INT 94
4168: PPUSH
4169: CALL_OW 52
// end ; InitHc ;
4173: CALL_OW 19
// ar_vehicles_tmp := [ ] ;
4177: LD_ADDR_EXP 41
4181: PUSH
4182: EMPTY
4183: ST_TO_ADDR
// for i = 1 to 5 do
4184: LD_ADDR_VAR 0 2
4188: PUSH
4189: DOUBLE
4190: LD_INT 1
4192: DEC
4193: ST_TO_ADDR
4194: LD_INT 5
4196: PUSH
4197: FOR_TO
4198: IFFALSE 4370
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , [ engine_combustion , engine_solar ] [ rand ( 1 , 2 ) ] , control_manual , [ ar_gatling_gun , ar_gun , ar_flame_thrower ] [ rand ( 1 , 3 ) ] , rand ( 60 , 100 ) ) ;
4200: LD_INT 13
4202: PUSH
4203: LD_INT 14
4205: PUSH
4206: EMPTY
4207: LIST
4208: LIST
4209: PUSH
4210: LD_INT 1
4212: PPUSH
4213: LD_INT 2
4215: PPUSH
4216: CALL_OW 12
4220: ARRAY
4221: PPUSH
4222: LD_INT 1
4224: PUSH
4225: LD_INT 2
4227: PUSH
4228: EMPTY
4229: LIST
4230: LIST
4231: PUSH
4232: LD_INT 1
4234: PPUSH
4235: LD_INT 2
4237: PPUSH
4238: CALL_OW 12
4242: ARRAY
4243: PPUSH
4244: LD_INT 1
4246: PPUSH
4247: LD_INT 25
4249: PUSH
4250: LD_INT 27
4252: PUSH
4253: LD_INT 26
4255: PUSH
4256: EMPTY
4257: LIST
4258: LIST
4259: LIST
4260: PUSH
4261: LD_INT 1
4263: PPUSH
4264: LD_INT 3
4266: PPUSH
4267: CALL_OW 12
4271: ARRAY
4272: PPUSH
4273: LD_INT 60
4275: PPUSH
4276: LD_INT 100
4278: PPUSH
4279: CALL_OW 12
4283: PPUSH
4284: CALL 53945 0 5
// un := CreateVehicle ;
4288: LD_ADDR_VAR 0 4
4292: PUSH
4293: CALL_OW 45
4297: ST_TO_ADDR
// ar_vehicles_tmp := Replace ( ar_vehicles_tmp , ar_vehicles_tmp + 1 , un ) ;
4298: LD_ADDR_EXP 41
4302: PUSH
4303: LD_EXP 41
4307: PPUSH
4308: LD_EXP 41
4312: PUSH
4313: LD_INT 1
4315: PLUS
4316: PPUSH
4317: LD_VAR 0 4
4321: PPUSH
4322: CALL_OW 1
4326: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4327: LD_VAR 0 4
4331: PPUSH
4332: LD_INT 0
4334: PPUSH
4335: LD_INT 5
4337: PPUSH
4338: CALL_OW 12
4342: PPUSH
4343: CALL_OW 233
// PlaceUnitXYR ( un , 124 , 141 , 8 , false ) ;
4347: LD_VAR 0 4
4351: PPUSH
4352: LD_INT 124
4354: PPUSH
4355: LD_INT 141
4357: PPUSH
4358: LD_INT 8
4360: PPUSH
4361: LD_INT 0
4363: PPUSH
4364: CALL_OW 50
// end ;
4368: GO 4197
4370: POP
4371: POP
// ar_defenders_tmp := [ [ ] , [ ] , [ ] ] ;
4372: LD_ADDR_EXP 43
4376: PUSH
4377: EMPTY
4378: PUSH
4379: EMPTY
4380: PUSH
4381: EMPTY
4382: PUSH
4383: EMPTY
4384: LIST
4385: LIST
4386: LIST
4387: ST_TO_ADDR
// for d = 1 to [ 3 , 3 , 4 , 4 ] [ Difficulty ] do
4388: LD_ADDR_VAR 0 3
4392: PUSH
4393: DOUBLE
4394: LD_INT 1
4396: DEC
4397: ST_TO_ADDR
4398: LD_INT 3
4400: PUSH
4401: LD_INT 3
4403: PUSH
4404: LD_INT 4
4406: PUSH
4407: LD_INT 4
4409: PUSH
4410: EMPTY
4411: LIST
4412: LIST
4413: LIST
4414: LIST
4415: PUSH
4416: LD_OWVAR 67
4420: ARRAY
4421: PUSH
4422: FOR_TO
4423: IFFALSE 4637
// for i = 1 to 3 do
4425: LD_ADDR_VAR 0 2
4429: PUSH
4430: DOUBLE
4431: LD_INT 1
4433: DEC
4434: ST_TO_ADDR
4435: LD_INT 3
4437: PUSH
4438: FOR_TO
4439: IFFALSE 4633
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
4441: LD_INT 14
4443: PPUSH
4444: LD_INT 3
4446: PUSH
4447: LD_INT 2
4449: PUSH
4450: EMPTY
4451: LIST
4452: LIST
4453: PUSH
4454: LD_INT 1
4456: PPUSH
4457: LD_INT 2
4459: PPUSH
4460: CALL_OW 12
4464: ARRAY
4465: PPUSH
4466: LD_INT 1
4468: PUSH
4469: LD_INT 5
4471: PUSH
4472: EMPTY
4473: LIST
4474: LIST
4475: PUSH
4476: LD_INT 1
4478: PPUSH
4479: LD_INT 2
4481: PPUSH
4482: CALL_OW 12
4486: ARRAY
4487: PPUSH
4488: LD_INT 25
4490: PUSH
4491: LD_INT 27
4493: PUSH
4494: LD_INT 26
4496: PUSH
4497: LD_INT 28
4499: PUSH
4500: EMPTY
4501: LIST
4502: LIST
4503: LIST
4504: LIST
4505: PUSH
4506: LD_INT 1
4508: PPUSH
4509: LD_INT 4
4511: PPUSH
4512: CALL_OW 12
4516: ARRAY
4517: PPUSH
4518: LD_INT 100
4520: PPUSH
4521: CALL 53945 0 5
// un := CreateVehicle ;
4525: LD_ADDR_VAR 0 4
4529: PUSH
4530: CALL_OW 45
4534: ST_TO_ADDR
// ar_defenders_tmp := ReplaceIn ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
4535: LD_ADDR_EXP 43
4539: PUSH
4540: LD_EXP 43
4544: PPUSH
4545: LD_VAR 0 2
4549: PUSH
4550: LD_EXP 43
4554: PUSH
4555: LD_VAR 0 2
4559: ARRAY
4560: PUSH
4561: LD_INT 1
4563: PLUS
4564: PUSH
4565: EMPTY
4566: LIST
4567: LIST
4568: PPUSH
4569: LD_VAR 0 4
4573: PPUSH
4574: CALL 54067 0 3
4578: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4579: LD_VAR 0 4
4583: PPUSH
4584: LD_INT 0
4586: PPUSH
4587: LD_INT 5
4589: PPUSH
4590: CALL_OW 12
4594: PPUSH
4595: CALL_OW 233
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east ] [ i ] , false ) ;
4599: LD_VAR 0 4
4603: PPUSH
4604: LD_INT 20
4606: PUSH
4607: LD_INT 21
4609: PUSH
4610: LD_INT 22
4612: PUSH
4613: EMPTY
4614: LIST
4615: LIST
4616: LIST
4617: PUSH
4618: LD_VAR 0 2
4622: ARRAY
4623: PPUSH
4624: LD_INT 0
4626: PPUSH
4627: CALL_OW 49
// end ;
4631: GO 4438
4633: POP
4634: POP
4635: GO 4422
4637: POP
4638: POP
// InitHc ;
4639: CALL_OW 19
// CreateResourcesXY ( mat_artifact , 5 , 10 , 5 , false ) ;
4643: LD_INT 4
4645: PPUSH
4646: LD_INT 5
4648: PPUSH
4649: LD_INT 10
4651: PPUSH
4652: LD_INT 5
4654: PPUSH
4655: LD_INT 0
4657: PPUSH
4658: CALL_OW 58
// end ;
4662: LD_VAR 0 1
4666: RET
// every 0 0$1 trigger ar_kamikadze do var i ;
4667: LD_EXP 42
4671: IFFALSE 4745
4673: GO 4675
4675: DISABLE
4676: LD_INT 0
4678: PPUSH
// begin enable ;
4679: ENABLE
// for i in ar_kamikadze do
4680: LD_ADDR_VAR 0 1
4684: PUSH
4685: LD_EXP 42
4689: PUSH
4690: FOR_IN
4691: IFFALSE 4743
// if See ( 1 , i ) then
4693: LD_INT 1
4695: PPUSH
4696: LD_VAR 0 1
4700: PPUSH
4701: CALL_OW 292
4705: IFFALSE 4741
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
4707: LD_VAR 0 1
4711: PPUSH
4712: LD_INT 81
4714: PUSH
4715: LD_INT 2
4717: PUSH
4718: EMPTY
4719: LIST
4720: LIST
4721: PPUSH
4722: CALL_OW 69
4726: PPUSH
4727: LD_VAR 0 1
4731: PPUSH
4732: CALL_OW 74
4736: PPUSH
4737: CALL_OW 115
4741: GO 4690
4743: POP
4744: POP
// end ;
4745: PPOPN 1
4747: END
// every 5 5$20 trigger artifact_get do var i , cargo , tmp , pos ;
4748: LD_EXP 13
4752: IFFALSE 5069
4754: GO 4756
4756: DISABLE
4757: LD_INT 0
4759: PPUSH
4760: PPUSH
4761: PPUSH
4762: PPUSH
// begin repeat wait ( 0 0$1 ) ;
4763: LD_INT 35
4765: PPUSH
4766: CALL_OW 67
// until MC_GetProduceList ( 1 ) = 0 ;
4770: LD_INT 1
4772: PPUSH
4773: CALL 43027 0 1
4777: PUSH
4778: LD_INT 0
4780: EQUAL
4781: IFFALSE 4763
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
4783: LD_INT 1
4785: PPUSH
4786: LD_INT 14
4788: PUSH
4789: LD_INT 3
4791: PUSH
4792: LD_INT 2
4794: PUSH
4795: LD_INT 32
4797: PUSH
4798: EMPTY
4799: LIST
4800: LIST
4801: LIST
4802: LIST
4803: PUSH
4804: EMPTY
4805: LIST
4806: PPUSH
4807: CALL 42631 0 2
// repeat wait ( 0 0$1 ) ;
4811: LD_INT 35
4813: PPUSH
4814: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) ;
4818: LD_EXP 69
4822: PUSH
4823: LD_INT 1
4825: ARRAY
4826: PPUSH
4827: LD_INT 33
4829: PUSH
4830: LD_INT 2
4832: PUSH
4833: EMPTY
4834: LIST
4835: LIST
4836: PUSH
4837: LD_INT 34
4839: PUSH
4840: LD_INT 32
4842: PUSH
4843: EMPTY
4844: LIST
4845: LIST
4846: PUSH
4847: EMPTY
4848: LIST
4849: LIST
4850: PPUSH
4851: CALL_OW 72
4855: IFFALSE 4811
// cargo := UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) [ 1 ] ;
4857: LD_ADDR_VAR 0 2
4861: PUSH
4862: LD_EXP 69
4866: PUSH
4867: LD_INT 1
4869: ARRAY
4870: PPUSH
4871: LD_INT 33
4873: PUSH
4874: LD_INT 2
4876: PUSH
4877: EMPTY
4878: LIST
4879: LIST
4880: PUSH
4881: LD_INT 34
4883: PUSH
4884: LD_INT 32
4886: PUSH
4887: EMPTY
4888: LIST
4889: LIST
4890: PUSH
4891: EMPTY
4892: LIST
4893: LIST
4894: PPUSH
4895: CALL_OW 72
4899: PUSH
4900: LD_INT 1
4902: ARRAY
4903: ST_TO_ADDR
// pos := FindArtifact ( 5 ) ;
4904: LD_ADDR_VAR 0 4
4908: PUSH
4909: LD_INT 5
4911: PPUSH
4912: CALL_OW 469
4916: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4917: LD_INT 35
4919: PPUSH
4920: CALL_OW 67
// pos := FindArtifact ( 5 ) ;
4924: LD_ADDR_VAR 0 4
4928: PUSH
4929: LD_INT 5
4931: PPUSH
4932: CALL_OW 469
4936: ST_TO_ADDR
// tmp := 100 ;
4937: LD_ADDR_VAR 0 3
4941: PUSH
4942: LD_INT 100
4944: ST_TO_ADDR
// if pos then
4945: LD_VAR 0 4
4949: IFFALSE 4989
// tmp := DangerAtRangeXY ( 2 , pos [ 1 ] , pos [ 2 ] , 20 ) [ 4 ] ;
4951: LD_ADDR_VAR 0 3
4955: PUSH
4956: LD_INT 2
4958: PPUSH
4959: LD_VAR 0 4
4963: PUSH
4964: LD_INT 1
4966: ARRAY
4967: PPUSH
4968: LD_VAR 0 4
4972: PUSH
4973: LD_INT 2
4975: ARRAY
4976: PPUSH
4977: LD_INT 20
4979: PPUSH
4980: CALL 55331 0 4
4984: PUSH
4985: LD_INT 4
4987: ARRAY
4988: ST_TO_ADDR
// until pos and not artifact_oncargo and tmp < 10 ;
4989: LD_VAR 0 4
4993: PUSH
4994: LD_EXP 14
4998: NOT
4999: AND
5000: PUSH
5001: LD_VAR 0 3
5005: PUSH
5006: LD_INT 10
5008: LESS
5009: AND
5010: IFFALSE 4917
// ComGet ( cargo , pos [ 1 ] , pos [ 2 ] ) ;
5012: LD_VAR 0 2
5016: PPUSH
5017: LD_VAR 0 4
5021: PUSH
5022: LD_INT 1
5024: ARRAY
5025: PPUSH
5026: LD_VAR 0 4
5030: PUSH
5031: LD_INT 2
5033: ARRAY
5034: PPUSH
5035: CALL_OW 160
// AddComMoveXY ( cargo , 198 , 113 ) ;
5039: LD_VAR 0 2
5043: PPUSH
5044: LD_INT 198
5046: PPUSH
5047: LD_INT 113
5049: PPUSH
5050: CALL_OW 171
// AddComMoveXY ( cargo , 124 , 7 ) ;
5054: LD_VAR 0 2
5058: PPUSH
5059: LD_INT 124
5061: PPUSH
5062: LD_INT 7
5064: PPUSH
5065: CALL_OW 171
// end ;
5069: PPOPN 4
5071: END
// every 5 5$00 trigger base_captured do var i , un , tmp , skill , coords , flags , list ;
5072: LD_EXP 6
5076: IFFALSE 7039
5078: GO 5080
5080: DISABLE
5081: LD_INT 0
5083: PPUSH
5084: PPUSH
5085: PPUSH
5086: PPUSH
5087: PPUSH
5088: PPUSH
5089: PPUSH
// begin skill := [ 5 , 6 , 7 , 8 ] [ Difficulty ] ;
5090: LD_ADDR_VAR 0 4
5094: PUSH
5095: LD_INT 5
5097: PUSH
5098: LD_INT 6
5100: PUSH
5101: LD_INT 7
5103: PUSH
5104: LD_INT 8
5106: PUSH
5107: EMPTY
5108: LIST
5109: LIST
5110: LIST
5111: LIST
5112: PUSH
5113: LD_OWVAR 67
5117: ARRAY
5118: ST_TO_ADDR
// coords := [ ] ;
5119: LD_ADDR_VAR 0 5
5123: PUSH
5124: EMPTY
5125: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
5126: LD_ADDR_VAR 0 6
5130: PUSH
5131: LD_INT 0
5133: PUSH
5134: LD_INT 0
5136: PUSH
5137: LD_INT 0
5139: PUSH
5140: LD_INT 0
5142: PUSH
5143: LD_INT 1
5145: PUSH
5146: LD_INT 0
5148: PUSH
5149: LD_INT 0
5151: PUSH
5152: LD_INT 0
5154: PUSH
5155: LD_INT 1
5157: PUSH
5158: LD_INT 0
5160: PUSH
5161: EMPTY
5162: LIST
5163: LIST
5164: LIST
5165: LIST
5166: LIST
5167: LIST
5168: LIST
5169: LIST
5170: LIST
5171: LIST
5172: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ) ;
5173: LD_INT 1
5175: PPUSH
5176: LD_INT 14
5178: PUSH
5179: LD_INT 1
5181: PUSH
5182: LD_INT 2
5184: PUSH
5185: LD_INT 28
5187: PUSH
5188: EMPTY
5189: LIST
5190: LIST
5191: LIST
5192: LIST
5193: PUSH
5194: LD_INT 14
5196: PUSH
5197: LD_INT 1
5199: PUSH
5200: LD_INT 2
5202: PUSH
5203: LD_INT 25
5205: PUSH
5206: EMPTY
5207: LIST
5208: LIST
5209: LIST
5210: LIST
5211: PUSH
5212: LD_INT 14
5214: PUSH
5215: LD_INT 1
5217: PUSH
5218: LD_INT 2
5220: PUSH
5221: LD_INT 28
5223: PUSH
5224: EMPTY
5225: LIST
5226: LIST
5227: LIST
5228: LIST
5229: PUSH
5230: LD_INT 14
5232: PUSH
5233: LD_INT 1
5235: PUSH
5236: LD_INT 2
5238: PUSH
5239: LD_INT 29
5241: PUSH
5242: EMPTY
5243: LIST
5244: LIST
5245: LIST
5246: LIST
5247: PUSH
5248: EMPTY
5249: LIST
5250: LIST
5251: LIST
5252: LIST
5253: PPUSH
5254: CALL 42631 0 2
// wait ( [ 10 10$00 , 9 9$30 , 9 9$00 , 8 8$40 ] [ Difficulty ] ) ;
5258: LD_INT 21000
5260: PUSH
5261: LD_INT 19950
5263: PUSH
5264: LD_INT 18900
5266: PUSH
5267: LD_INT 18200
5269: PUSH
5270: EMPTY
5271: LIST
5272: LIST
5273: LIST
5274: LIST
5275: PUSH
5276: LD_OWVAR 67
5280: ARRAY
5281: PPUSH
5282: CALL_OW 67
// InitHc ;
5286: CALL_OW 19
// InitUc ;
5290: CALL_OW 18
// uc_side := 2 ;
5294: LD_ADDR_OWVAR 20
5298: PUSH
5299: LD_INT 2
5301: ST_TO_ADDR
// uc_nation := 2 ;
5302: LD_ADDR_OWVAR 21
5306: PUSH
5307: LD_INT 2
5309: ST_TO_ADDR
// tmp := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
5310: LD_ADDR_VAR 0 3
5314: PUSH
5315: EMPTY
5316: PUSH
5317: EMPTY
5318: PUSH
5319: EMPTY
5320: PUSH
5321: EMPTY
5322: PUSH
5323: EMPTY
5324: PUSH
5325: EMPTY
5326: LIST
5327: LIST
5328: LIST
5329: LIST
5330: LIST
5331: ST_TO_ADDR
// tmp := Replace ( tmp , 1 , mc_vehicles [ 1 ] diff FilterAllUnits ( [ f_or , [ f_weapon , ar_crane ] , [ f_weapon , ar_cargo_bay ] ] ) ) ;
5332: LD_ADDR_VAR 0 3
5336: PUSH
5337: LD_VAR 0 3
5341: PPUSH
5342: LD_INT 1
5344: PPUSH
5345: LD_EXP 69
5349: PUSH
5350: LD_INT 1
5352: ARRAY
5353: PUSH
5354: LD_INT 2
5356: PUSH
5357: LD_INT 34
5359: PUSH
5360: LD_INT 88
5362: PUSH
5363: EMPTY
5364: LIST
5365: LIST
5366: PUSH
5367: LD_INT 34
5369: PUSH
5370: LD_INT 32
5372: PUSH
5373: EMPTY
5374: LIST
5375: LIST
5376: PUSH
5377: EMPTY
5378: LIST
5379: LIST
5380: LIST
5381: PPUSH
5382: CALL_OW 69
5386: DIFF
5387: PPUSH
5388: CALL_OW 1
5392: ST_TO_ADDR
// for i = 1 to Difficulty do
5393: LD_ADDR_VAR 0 1
5397: PUSH
5398: DOUBLE
5399: LD_INT 1
5401: DEC
5402: ST_TO_ADDR
5403: LD_OWVAR 67
5407: PUSH
5408: FOR_TO
5409: IFFALSE 5547
// begin uc_side := 2 ;
5411: LD_ADDR_OWVAR 20
5415: PUSH
5416: LD_INT 2
5418: ST_TO_ADDR
// uc_nation := 2 ;
5419: LD_ADDR_OWVAR 21
5423: PUSH
5424: LD_INT 2
5426: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
5427: LD_INT 13
5429: PPUSH
5430: LD_INT 3
5432: PPUSH
5433: LD_INT 5
5435: PPUSH
5436: LD_INT 29
5438: PPUSH
5439: LD_INT 100
5441: PPUSH
5442: CALL 53945 0 5
// un := CreateVehicle ;
5446: LD_ADDR_VAR 0 2
5450: PUSH
5451: CALL_OW 45
5455: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 1 , tmp [ 1 ] + 1 ] , un ) ;
5456: LD_ADDR_VAR 0 3
5460: PUSH
5461: LD_VAR 0 3
5465: PPUSH
5466: LD_INT 1
5468: PUSH
5469: LD_VAR 0 3
5473: PUSH
5474: LD_INT 1
5476: ARRAY
5477: PUSH
5478: LD_INT 1
5480: PLUS
5481: PUSH
5482: EMPTY
5483: LIST
5484: LIST
5485: PPUSH
5486: LD_VAR 0 2
5490: PPUSH
5491: CALL 54067 0 3
5495: ST_TO_ADDR
// SetDir ( un , 3 ) ;
5496: LD_VAR 0 2
5500: PPUSH
5501: LD_INT 3
5503: PPUSH
5504: CALL_OW 233
// PlaceUnitArea ( un , north_attack_spawn , false ) ;
5508: LD_VAR 0 2
5512: PPUSH
5513: LD_INT 16
5515: PPUSH
5516: LD_INT 0
5518: PPUSH
5519: CALL_OW 49
// ComMoveXY ( un , 51 , 10 ) ;
5523: LD_VAR 0 2
5527: PPUSH
5528: LD_INT 51
5530: PPUSH
5531: LD_INT 10
5533: PPUSH
5534: CALL_OW 111
// wait ( 0 0$2 ) ;
5538: LD_INT 70
5540: PPUSH
5541: CALL_OW 67
// end ;
5545: GO 5408
5547: POP
5548: POP
// coords := [ [ 51 , 24 ] , [ 75 , 90 ] ] ;
5549: LD_ADDR_VAR 0 5
5553: PUSH
5554: LD_INT 51
5556: PUSH
5557: LD_INT 24
5559: PUSH
5560: EMPTY
5561: LIST
5562: LIST
5563: PUSH
5564: LD_INT 75
5566: PUSH
5567: LD_INT 90
5569: PUSH
5570: EMPTY
5571: LIST
5572: LIST
5573: PUSH
5574: EMPTY
5575: LIST
5576: LIST
5577: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 1 ] , coords , flags ) ;
5578: LD_INT 1
5580: PPUSH
5581: LD_VAR 0 3
5585: PUSH
5586: LD_INT 1
5588: ARRAY
5589: PPUSH
5590: LD_VAR 0 5
5594: PPUSH
5595: LD_VAR 0 6
5599: PPUSH
5600: CALL 42864 0 4
// for i = 1 to [ 1 , 3 , 4 , 5 ] [ Difficulty ] do
5604: LD_ADDR_VAR 0 1
5608: PUSH
5609: DOUBLE
5610: LD_INT 1
5612: DEC
5613: ST_TO_ADDR
5614: LD_INT 1
5616: PUSH
5617: LD_INT 3
5619: PUSH
5620: LD_INT 4
5622: PUSH
5623: LD_INT 5
5625: PUSH
5626: EMPTY
5627: LIST
5628: LIST
5629: LIST
5630: LIST
5631: PUSH
5632: LD_OWVAR 67
5636: ARRAY
5637: PUSH
5638: FOR_TO
5639: IFFALSE 5739
// begin uc_side := 2 ;
5641: LD_ADDR_OWVAR 20
5645: PUSH
5646: LD_INT 2
5648: ST_TO_ADDR
// uc_nation := 2 ;
5649: LD_ADDR_OWVAR 21
5653: PUSH
5654: LD_INT 2
5656: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5657: LD_INT 0
5659: PPUSH
5660: LD_INT 17
5662: PPUSH
5663: LD_VAR 0 4
5667: PPUSH
5668: CALL_OW 380
// un := CreateHuman ;
5672: LD_ADDR_VAR 0 2
5676: PUSH
5677: CALL_OW 44
5681: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5682: LD_ADDR_VAR 0 3
5686: PUSH
5687: LD_VAR 0 3
5691: PPUSH
5692: LD_INT 2
5694: PUSH
5695: LD_VAR 0 3
5699: PUSH
5700: LD_INT 2
5702: ARRAY
5703: PUSH
5704: LD_INT 1
5706: PLUS
5707: PUSH
5708: EMPTY
5709: LIST
5710: LIST
5711: PPUSH
5712: LD_VAR 0 2
5716: PPUSH
5717: CALL 54067 0 3
5721: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5722: LD_VAR 0 2
5726: PPUSH
5727: LD_INT 13
5729: PPUSH
5730: LD_INT 0
5732: PPUSH
5733: CALL_OW 49
// end ;
5737: GO 5638
5739: POP
5740: POP
// for i = 1 to [ 3 , 4 , 5 , 6 ] [ Difficulty ] do
5741: LD_ADDR_VAR 0 1
5745: PUSH
5746: DOUBLE
5747: LD_INT 1
5749: DEC
5750: ST_TO_ADDR
5751: LD_INT 3
5753: PUSH
5754: LD_INT 4
5756: PUSH
5757: LD_INT 5
5759: PUSH
5760: LD_INT 6
5762: PUSH
5763: EMPTY
5764: LIST
5765: LIST
5766: LIST
5767: LIST
5768: PUSH
5769: LD_OWVAR 67
5773: ARRAY
5774: PUSH
5775: FOR_TO
5776: IFFALSE 5897
// begin uc_side := 2 ;
5778: LD_ADDR_OWVAR 20
5782: PUSH
5783: LD_INT 2
5785: ST_TO_ADDR
// uc_nation := 2 ;
5786: LD_ADDR_OWVAR 21
5790: PUSH
5791: LD_INT 2
5793: ST_TO_ADDR
// PrepareHuman ( false , [ 1 , 8 ] [ i mod 2 + 1 ] , skill ) ;
5794: LD_INT 0
5796: PPUSH
5797: LD_INT 1
5799: PUSH
5800: LD_INT 8
5802: PUSH
5803: EMPTY
5804: LIST
5805: LIST
5806: PUSH
5807: LD_VAR 0 1
5811: PUSH
5812: LD_INT 2
5814: MOD
5815: PUSH
5816: LD_INT 1
5818: PLUS
5819: ARRAY
5820: PPUSH
5821: LD_VAR 0 4
5825: PPUSH
5826: CALL_OW 380
// un := CreateHuman ;
5830: LD_ADDR_VAR 0 2
5834: PUSH
5835: CALL_OW 44
5839: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5840: LD_ADDR_VAR 0 3
5844: PUSH
5845: LD_VAR 0 3
5849: PPUSH
5850: LD_INT 2
5852: PUSH
5853: LD_VAR 0 3
5857: PUSH
5858: LD_INT 2
5860: ARRAY
5861: PUSH
5862: LD_INT 1
5864: PLUS
5865: PUSH
5866: EMPTY
5867: LIST
5868: LIST
5869: PPUSH
5870: LD_VAR 0 2
5874: PPUSH
5875: CALL 54067 0 3
5879: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5880: LD_VAR 0 2
5884: PPUSH
5885: LD_INT 13
5887: PPUSH
5888: LD_INT 0
5890: PPUSH
5891: CALL_OW 49
// end ;
5895: GO 5775
5897: POP
5898: POP
// coords := [ [ 67 , 112 ] , [ 85 , 130 ] ] ;
5899: LD_ADDR_VAR 0 5
5903: PUSH
5904: LD_INT 67
5906: PUSH
5907: LD_INT 112
5909: PUSH
5910: EMPTY
5911: LIST
5912: LIST
5913: PUSH
5914: LD_INT 85
5916: PUSH
5917: LD_INT 130
5919: PUSH
5920: EMPTY
5921: LIST
5922: LIST
5923: PUSH
5924: EMPTY
5925: LIST
5926: LIST
5927: ST_TO_ADDR
// MC_PrepareAttack ( 2 , tmp [ 2 ] , coords , flags ) ;
5928: LD_INT 2
5930: PPUSH
5931: LD_VAR 0 3
5935: PUSH
5936: LD_INT 2
5938: ARRAY
5939: PPUSH
5940: LD_VAR 0 5
5944: PPUSH
5945: LD_VAR 0 6
5949: PPUSH
5950: CALL 42864 0 4
// for i = 1 to [ 1 , 2 , 3 , 5 ] [ Difficulty ] do
5954: LD_ADDR_VAR 0 1
5958: PUSH
5959: DOUBLE
5960: LD_INT 1
5962: DEC
5963: ST_TO_ADDR
5964: LD_INT 1
5966: PUSH
5967: LD_INT 2
5969: PUSH
5970: LD_INT 3
5972: PUSH
5973: LD_INT 5
5975: PUSH
5976: EMPTY
5977: LIST
5978: LIST
5979: LIST
5980: LIST
5981: PUSH
5982: LD_OWVAR 67
5986: ARRAY
5987: PUSH
5988: FOR_TO
5989: IFFALSE 6089
// begin uc_side := 2 ;
5991: LD_ADDR_OWVAR 20
5995: PUSH
5996: LD_INT 2
5998: ST_TO_ADDR
// uc_nation := 2 ;
5999: LD_ADDR_OWVAR 21
6003: PUSH
6004: LD_INT 2
6006: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
6007: LD_INT 0
6009: PPUSH
6010: LD_INT 17
6012: PPUSH
6013: LD_VAR 0 4
6017: PPUSH
6018: CALL_OW 380
// un := CreateHuman ;
6022: LD_ADDR_VAR 0 2
6026: PUSH
6027: CALL_OW 44
6031: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 3 , tmp [ 3 ] + 1 ] , un ) ;
6032: LD_ADDR_VAR 0 3
6036: PUSH
6037: LD_VAR 0 3
6041: PPUSH
6042: LD_INT 3
6044: PUSH
6045: LD_VAR 0 3
6049: PUSH
6050: LD_INT 3
6052: ARRAY
6053: PUSH
6054: LD_INT 1
6056: PLUS
6057: PUSH
6058: EMPTY
6059: LIST
6060: LIST
6061: PPUSH
6062: LD_VAR 0 2
6066: PPUSH
6067: CALL 54067 0 3
6071: ST_TO_ADDR
// PlaceUnitArea ( un , south_attack_spawn , false ) ;
6072: LD_VAR 0 2
6076: PPUSH
6077: LD_INT 14
6079: PPUSH
6080: LD_INT 0
6082: PPUSH
6083: CALL_OW 49
// end ;
6087: GO 5988
6089: POP
6090: POP
// coords := [ [ 148 , 158 ] , [ 148 , 158 ] ] ;
6091: LD_ADDR_VAR 0 5
6095: PUSH
6096: LD_INT 148
6098: PUSH
6099: LD_INT 158
6101: PUSH
6102: EMPTY
6103: LIST
6104: LIST
6105: PUSH
6106: LD_INT 148
6108: PUSH
6109: LD_INT 158
6111: PUSH
6112: EMPTY
6113: LIST
6114: LIST
6115: PUSH
6116: EMPTY
6117: LIST
6118: LIST
6119: ST_TO_ADDR
// MC_PrepareAttack ( 3 , tmp [ 3 ] , coords , flags ) ;
6120: LD_INT 3
6122: PPUSH
6123: LD_VAR 0 3
6127: PUSH
6128: LD_INT 3
6130: ARRAY
6131: PPUSH
6132: LD_VAR 0 5
6136: PPUSH
6137: LD_VAR 0 6
6141: PPUSH
6142: CALL 42864 0 4
// for i = 1 to [ 2 , 3 , 4 , 5 ] [ Difficulty ] do
6146: LD_ADDR_VAR 0 1
6150: PUSH
6151: DOUBLE
6152: LD_INT 1
6154: DEC
6155: ST_TO_ADDR
6156: LD_INT 2
6158: PUSH
6159: LD_INT 3
6161: PUSH
6162: LD_INT 4
6164: PUSH
6165: LD_INT 5
6167: PUSH
6168: EMPTY
6169: LIST
6170: LIST
6171: LIST
6172: LIST
6173: PUSH
6174: LD_OWVAR 67
6178: ARRAY
6179: PUSH
6180: FOR_TO
6181: IFFALSE 6405
// begin uc_side := 2 ;
6183: LD_ADDR_OWVAR 20
6187: PUSH
6188: LD_INT 2
6190: ST_TO_ADDR
// uc_nation := 2 ;
6191: LD_ADDR_OWVAR 21
6195: PUSH
6196: LD_INT 2
6198: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 3 ) ] , 100 ) ;
6199: LD_INT 14
6201: PPUSH
6202: LD_INT 3
6204: PPUSH
6205: LD_INT 1
6207: PUSH
6208: LD_INT 5
6210: PUSH
6211: EMPTY
6212: LIST
6213: LIST
6214: PUSH
6215: LD_INT 1
6217: PPUSH
6218: LD_INT 2
6220: PPUSH
6221: CALL_OW 12
6225: ARRAY
6226: PPUSH
6227: LD_INT 27
6229: PUSH
6230: LD_INT 26
6232: PUSH
6233: LD_INT 28
6235: PUSH
6236: EMPTY
6237: LIST
6238: LIST
6239: LIST
6240: PUSH
6241: LD_INT 1
6243: PPUSH
6244: LD_INT 3
6246: PPUSH
6247: CALL_OW 12
6251: ARRAY
6252: PPUSH
6253: LD_INT 100
6255: PPUSH
6256: CALL 53945 0 5
// un := CreateVehicle ;
6260: LD_ADDR_VAR 0 2
6264: PUSH
6265: CALL_OW 45
6269: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , un ) ;
6270: LD_ADDR_VAR 0 3
6274: PUSH
6275: LD_VAR 0 3
6279: PPUSH
6280: LD_INT 4
6282: PUSH
6283: LD_VAR 0 3
6287: PUSH
6288: LD_INT 4
6290: ARRAY
6291: PUSH
6292: LD_INT 1
6294: PLUS
6295: PUSH
6296: EMPTY
6297: LIST
6298: LIST
6299: PPUSH
6300: LD_VAR 0 2
6304: PPUSH
6305: CALL 54067 0 3
6309: ST_TO_ADDR
// SetDir ( un , 5 ) ;
6310: LD_VAR 0 2
6314: PPUSH
6315: LD_INT 5
6317: PPUSH
6318: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
6322: LD_VAR 0 2
6326: PPUSH
6327: LD_INT 15
6329: PPUSH
6330: LD_INT 0
6332: PPUSH
6333: CALL_OW 49
// if GetControl ( un ) = control_manual then
6337: LD_VAR 0 2
6341: PPUSH
6342: CALL_OW 263
6346: PUSH
6347: LD_INT 1
6349: EQUAL
6350: IFFALSE 6381
// begin PrepareHuman ( false , 3 , skill ) ;
6352: LD_INT 0
6354: PPUSH
6355: LD_INT 3
6357: PPUSH
6358: LD_VAR 0 4
6362: PPUSH
6363: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
6367: CALL_OW 44
6371: PPUSH
6372: LD_VAR 0 2
6376: PPUSH
6377: CALL_OW 52
// end ; ComMoveXY ( un , 179 , 135 ) ;
6381: LD_VAR 0 2
6385: PPUSH
6386: LD_INT 179
6388: PPUSH
6389: LD_INT 135
6391: PPUSH
6392: CALL_OW 111
// wait ( 0 0$2 ) ;
6396: LD_INT 70
6398: PPUSH
6399: CALL_OW 67
// end ;
6403: GO 6180
6405: POP
6406: POP
// vc_chassis := 15 ;
6407: LD_ADDR_OWVAR 37
6411: PUSH
6412: LD_INT 15
6414: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateVehicle ) ;
6415: LD_ADDR_VAR 0 3
6419: PUSH
6420: LD_VAR 0 3
6424: PPUSH
6425: LD_INT 4
6427: PUSH
6428: LD_VAR 0 3
6432: PUSH
6433: LD_INT 4
6435: ARRAY
6436: PUSH
6437: LD_INT 1
6439: PLUS
6440: PUSH
6441: EMPTY
6442: LIST
6443: LIST
6444: PPUSH
6445: CALL_OW 45
6449: PPUSH
6450: CALL 54067 0 3
6454: ST_TO_ADDR
// PlaceUnitArea ( tmp [ 4 ] [ tmp [ 4 ] ] , east_attack_spawn , false ) ;
6455: LD_VAR 0 3
6459: PUSH
6460: LD_INT 4
6462: ARRAY
6463: PUSH
6464: LD_VAR 0 3
6468: PUSH
6469: LD_INT 4
6471: ARRAY
6472: ARRAY
6473: PPUSH
6474: LD_INT 15
6476: PPUSH
6477: LD_INT 0
6479: PPUSH
6480: CALL_OW 49
// PrepareHuman ( false , class_desert_warior , skill ) ;
6484: LD_INT 0
6486: PPUSH
6487: LD_INT 11
6489: PPUSH
6490: LD_VAR 0 4
6494: PPUSH
6495: CALL_OW 380
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateHuman ) ;
6499: LD_ADDR_VAR 0 3
6503: PUSH
6504: LD_VAR 0 3
6508: PPUSH
6509: LD_INT 4
6511: PUSH
6512: LD_VAR 0 3
6516: PUSH
6517: LD_INT 4
6519: ARRAY
6520: PUSH
6521: LD_INT 1
6523: PLUS
6524: PUSH
6525: EMPTY
6526: LIST
6527: LIST
6528: PPUSH
6529: CALL_OW 44
6533: PPUSH
6534: CALL 54067 0 3
6538: ST_TO_ADDR
// PlaceHumanInUnit ( tmp [ 4 ] [ tmp [ 4 ] ] , tmp [ 4 ] [ tmp [ 4 ] - 1 ] ) ;
6539: LD_VAR 0 3
6543: PUSH
6544: LD_INT 4
6546: ARRAY
6547: PUSH
6548: LD_VAR 0 3
6552: PUSH
6553: LD_INT 4
6555: ARRAY
6556: ARRAY
6557: PPUSH
6558: LD_VAR 0 3
6562: PUSH
6563: LD_INT 4
6565: ARRAY
6566: PUSH
6567: LD_VAR 0 3
6571: PUSH
6572: LD_INT 4
6574: ARRAY
6575: PUSH
6576: LD_INT 1
6578: MINUS
6579: ARRAY
6580: PPUSH
6581: CALL_OW 52
// coords := [ [ 148 , 140 ] ] ;
6585: LD_ADDR_VAR 0 5
6589: PUSH
6590: LD_INT 148
6592: PUSH
6593: LD_INT 140
6595: PUSH
6596: EMPTY
6597: LIST
6598: LIST
6599: PUSH
6600: EMPTY
6601: LIST
6602: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 4 ] , coords , flags ) ;
6603: LD_INT 1
6605: PPUSH
6606: LD_VAR 0 3
6610: PUSH
6611: LD_INT 4
6613: ARRAY
6614: PPUSH
6615: LD_VAR 0 5
6619: PPUSH
6620: LD_VAR 0 6
6624: PPUSH
6625: CALL 42864 0 4
// if gensher_active then
6629: LD_EXP 18
6633: IFFALSE 7039
// begin SayRadio ( Gensher , D10-Diet-1 ) ;
6635: LD_EXP 45
6639: PPUSH
6640: LD_STRING D10-Diet-1
6642: PPUSH
6643: CALL_OW 94
// for i = 1 to 2 do
6647: LD_ADDR_VAR 0 1
6651: PUSH
6652: DOUBLE
6653: LD_INT 1
6655: DEC
6656: ST_TO_ADDR
6657: LD_INT 2
6659: PUSH
6660: FOR_TO
6661: IFFALSE 6799
// begin uc_side := 2 ;
6663: LD_ADDR_OWVAR 20
6667: PUSH
6668: LD_INT 2
6670: ST_TO_ADDR
// uc_nation := 2 ;
6671: LD_ADDR_OWVAR 21
6675: PUSH
6676: LD_INT 2
6678: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
6679: LD_INT 13
6681: PPUSH
6682: LD_INT 3
6684: PPUSH
6685: LD_INT 5
6687: PPUSH
6688: LD_INT 29
6690: PPUSH
6691: LD_INT 100
6693: PPUSH
6694: CALL 53945 0 5
// un := CreateVehicle ;
6698: LD_ADDR_VAR 0 2
6702: PUSH
6703: CALL_OW 45
6707: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6708: LD_ADDR_VAR 0 3
6712: PUSH
6713: LD_VAR 0 3
6717: PPUSH
6718: LD_INT 5
6720: PUSH
6721: LD_VAR 0 3
6725: PUSH
6726: LD_INT 5
6728: ARRAY
6729: PUSH
6730: LD_INT 1
6732: PLUS
6733: PUSH
6734: EMPTY
6735: LIST
6736: LIST
6737: PPUSH
6738: LD_VAR 0 2
6742: PPUSH
6743: CALL 54067 0 3
6747: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6748: LD_VAR 0 2
6752: PPUSH
6753: LD_INT 0
6755: PPUSH
6756: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6760: LD_VAR 0 2
6764: PPUSH
6765: LD_INT 23
6767: PPUSH
6768: LD_INT 0
6770: PPUSH
6771: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6775: LD_VAR 0 2
6779: PPUSH
6780: LD_INT 85
6782: PPUSH
6783: LD_INT 152
6785: PPUSH
6786: CALL_OW 111
// wait ( 0 0$2 ) ;
6790: LD_INT 70
6792: PPUSH
6793: CALL_OW 67
// end ;
6797: GO 6660
6799: POP
6800: POP
// for i = 1 to [ 2 , 3 , 3 , 4 ] [ Difficulty ] do
6801: LD_ADDR_VAR 0 1
6805: PUSH
6806: DOUBLE
6807: LD_INT 1
6809: DEC
6810: ST_TO_ADDR
6811: LD_INT 2
6813: PUSH
6814: LD_INT 3
6816: PUSH
6817: LD_INT 3
6819: PUSH
6820: LD_INT 4
6822: PUSH
6823: EMPTY
6824: LIST
6825: LIST
6826: LIST
6827: LIST
6828: PUSH
6829: LD_OWVAR 67
6833: ARRAY
6834: PUSH
6835: FOR_TO
6836: IFFALSE 6993
// begin uc_side := 2 ;
6838: LD_ADDR_OWVAR 20
6842: PUSH
6843: LD_INT 2
6845: ST_TO_ADDR
// uc_nation := 2 ;
6846: LD_ADDR_OWVAR 21
6850: PUSH
6851: LD_INT 2
6853: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
6854: LD_INT 14
6856: PPUSH
6857: LD_INT 3
6859: PPUSH
6860: LD_INT 5
6862: PPUSH
6863: LD_INT 27
6865: PUSH
6866: LD_INT 28
6868: PUSH
6869: EMPTY
6870: LIST
6871: LIST
6872: PUSH
6873: LD_INT 1
6875: PPUSH
6876: LD_INT 2
6878: PPUSH
6879: CALL_OW 12
6883: ARRAY
6884: PPUSH
6885: LD_INT 100
6887: PPUSH
6888: CALL 53945 0 5
// un := CreateVehicle ;
6892: LD_ADDR_VAR 0 2
6896: PUSH
6897: CALL_OW 45
6901: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6902: LD_ADDR_VAR 0 3
6906: PUSH
6907: LD_VAR 0 3
6911: PPUSH
6912: LD_INT 5
6914: PUSH
6915: LD_VAR 0 3
6919: PUSH
6920: LD_INT 5
6922: ARRAY
6923: PUSH
6924: LD_INT 1
6926: PLUS
6927: PUSH
6928: EMPTY
6929: LIST
6930: LIST
6931: PPUSH
6932: LD_VAR 0 2
6936: PPUSH
6937: CALL 54067 0 3
6941: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6942: LD_VAR 0 2
6946: PPUSH
6947: LD_INT 0
6949: PPUSH
6950: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6954: LD_VAR 0 2
6958: PPUSH
6959: LD_INT 23
6961: PPUSH
6962: LD_INT 0
6964: PPUSH
6965: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6969: LD_VAR 0 2
6973: PPUSH
6974: LD_INT 85
6976: PPUSH
6977: LD_INT 152
6979: PPUSH
6980: CALL_OW 111
// wait ( 0 0$2 ) ;
6984: LD_INT 70
6986: PPUSH
6987: CALL_OW 67
// end ;
6991: GO 6835
6993: POP
6994: POP
// coords := [ [ 97 , 143 ] ] ;
6995: LD_ADDR_VAR 0 5
6999: PUSH
7000: LD_INT 97
7002: PUSH
7003: LD_INT 143
7005: PUSH
7006: EMPTY
7007: LIST
7008: LIST
7009: PUSH
7010: EMPTY
7011: LIST
7012: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 5 ] , coords , flags ) ;
7013: LD_INT 1
7015: PPUSH
7016: LD_VAR 0 3
7020: PUSH
7021: LD_INT 5
7023: ARRAY
7024: PPUSH
7025: LD_VAR 0 5
7029: PPUSH
7030: LD_VAR 0 6
7034: PPUSH
7035: CALL 42864 0 4
// end ; end ;
7039: PPOPN 7
7041: END
// every 9 9$0 + 15 15$0 do var i , tmp , tmp2 , coords , w , list , p ;
7042: GO 7044
7044: DISABLE
7045: LD_INT 0
7047: PPUSH
7048: PPUSH
7049: PPUSH
7050: PPUSH
7051: PPUSH
7052: PPUSH
7053: PPUSH
// begin enable ;
7054: ENABLE
// tmp := [ ] ;
7055: LD_ADDR_VAR 0 2
7059: PUSH
7060: EMPTY
7061: ST_TO_ADDR
// w := rand ( 1 , 3 ) ;
7062: LD_ADDR_VAR 0 5
7066: PUSH
7067: LD_INT 1
7069: PPUSH
7070: LD_INT 3
7072: PPUSH
7073: CALL_OW 12
7077: ST_TO_ADDR
// if w = 3 then
7078: LD_VAR 0 5
7082: PUSH
7083: LD_INT 3
7085: EQUAL
7086: IFFALSE 7173
// list := [ [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] else
7088: LD_ADDR_VAR 0 6
7092: PUSH
7093: LD_INT 11
7095: PUSH
7096: LD_INT 1
7098: PUSH
7099: LD_INT 2
7101: PUSH
7102: LD_INT 24
7104: PUSH
7105: EMPTY
7106: LIST
7107: LIST
7108: LIST
7109: LIST
7110: PUSH
7111: LD_INT 11
7113: PUSH
7114: LD_INT 1
7116: PUSH
7117: LD_INT 2
7119: PUSH
7120: LD_INT 24
7122: PUSH
7123: EMPTY
7124: LIST
7125: LIST
7126: LIST
7127: LIST
7128: PUSH
7129: LD_INT 11
7131: PUSH
7132: LD_INT 1
7134: PUSH
7135: LD_INT 2
7137: PUSH
7138: LD_INT 24
7140: PUSH
7141: EMPTY
7142: LIST
7143: LIST
7144: LIST
7145: LIST
7146: PUSH
7147: LD_INT 11
7149: PUSH
7150: LD_INT 1
7152: PUSH
7153: LD_INT 2
7155: PUSH
7156: LD_INT 24
7158: PUSH
7159: EMPTY
7160: LIST
7161: LIST
7162: LIST
7163: LIST
7164: PUSH
7165: EMPTY
7166: LIST
7167: LIST
7168: LIST
7169: LIST
7170: ST_TO_ADDR
7171: GO 7275
// list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ;
7173: LD_ADDR_VAR 0 6
7177: PUSH
7178: LD_INT 14
7180: PUSH
7181: LD_INT 1
7183: PUSH
7184: LD_INT 2
7186: PUSH
7187: LD_INT 28
7189: PUSH
7190: EMPTY
7191: LIST
7192: LIST
7193: LIST
7194: LIST
7195: PUSH
7196: LD_INT 14
7198: PUSH
7199: LD_INT 1
7201: PUSH
7202: LD_INT 2
7204: PUSH
7205: LD_INT 25
7207: PUSH
7208: EMPTY
7209: LIST
7210: LIST
7211: LIST
7212: LIST
7213: PUSH
7214: LD_INT 14
7216: PUSH
7217: LD_INT 1
7219: PUSH
7220: LD_INT 2
7222: PUSH
7223: LD_INT 28
7225: PUSH
7226: EMPTY
7227: LIST
7228: LIST
7229: LIST
7230: LIST
7231: PUSH
7232: LD_INT 14
7234: PUSH
7235: LD_INT 1
7237: PUSH
7238: LD_INT 2
7240: PUSH
7241: LD_INT 29
7243: PUSH
7244: EMPTY
7245: LIST
7246: LIST
7247: LIST
7248: LIST
7249: PUSH
7250: LD_INT 14
7252: PUSH
7253: LD_INT 1
7255: PUSH
7256: LD_INT 2
7258: PUSH
7259: LD_INT 29
7261: PUSH
7262: EMPTY
7263: LIST
7264: LIST
7265: LIST
7266: LIST
7267: PUSH
7268: EMPTY
7269: LIST
7270: LIST
7271: LIST
7272: LIST
7273: LIST
7274: ST_TO_ADDR
// if w < 3 then
7275: LD_VAR 0 5
7279: PUSH
7280: LD_INT 3
7282: LESS
7283: IFFALSE 7363
// list := ReplaceIn ( list , [ 1 , list [ i ] + 1 ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gatling_gun , ar_rocket_launcher , ar_selfpropelled_bomb ] [ rand ( 1 , 3 ) ] ] ) ;
7285: LD_ADDR_VAR 0 6
7289: PUSH
7290: LD_VAR 0 6
7294: PPUSH
7295: LD_INT 1
7297: PUSH
7298: LD_VAR 0 6
7302: PUSH
7303: LD_VAR 0 1
7307: ARRAY
7308: PUSH
7309: LD_INT 1
7311: PLUS
7312: PUSH
7313: EMPTY
7314: LIST
7315: LIST
7316: PPUSH
7317: LD_INT 14
7319: PUSH
7320: LD_INT 1
7322: PUSH
7323: LD_INT 2
7325: PUSH
7326: LD_INT 25
7328: PUSH
7329: LD_INT 28
7331: PUSH
7332: LD_INT 29
7334: PUSH
7335: EMPTY
7336: LIST
7337: LIST
7338: LIST
7339: PUSH
7340: LD_INT 1
7342: PPUSH
7343: LD_INT 3
7345: PPUSH
7346: CALL_OW 12
7350: ARRAY
7351: PUSH
7352: EMPTY
7353: LIST
7354: LIST
7355: LIST
7356: LIST
7357: PPUSH
7358: CALL 54067 0 3
7362: ST_TO_ADDR
// MC_SetProduceList ( 1 , list ) ;
7363: LD_INT 1
7365: PPUSH
7366: LD_VAR 0 6
7370: PPUSH
7371: CALL 42631 0 2
// if GetSide ( ar_dep_w ) = 2 and IsOk ( ar_dep_w ) and w < 3 then
7375: LD_INT 45
7377: PPUSH
7378: CALL_OW 255
7382: PUSH
7383: LD_INT 2
7385: EQUAL
7386: PUSH
7387: LD_INT 45
7389: PPUSH
7390: CALL_OW 302
7394: AND
7395: PUSH
7396: LD_VAR 0 5
7400: PUSH
7401: LD_INT 3
7403: LESS
7404: AND
7405: IFFALSE 7490
// begin list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] ] ;
7407: LD_ADDR_VAR 0 6
7411: PUSH
7412: LD_INT 14
7414: PUSH
7415: LD_INT 1
7417: PUSH
7418: LD_INT 2
7420: PUSH
7421: LD_INT 28
7423: PUSH
7424: EMPTY
7425: LIST
7426: LIST
7427: LIST
7428: LIST
7429: PUSH
7430: LD_INT 14
7432: PUSH
7433: LD_INT 1
7435: PUSH
7436: LD_INT 2
7438: PUSH
7439: LD_INT 27
7441: PUSH
7442: EMPTY
7443: LIST
7444: LIST
7445: LIST
7446: LIST
7447: PUSH
7448: LD_INT 14
7450: PUSH
7451: LD_INT 1
7453: PUSH
7454: LD_INT 2
7456: PUSH
7457: LD_INT 27
7459: PUSH
7460: EMPTY
7461: LIST
7462: LIST
7463: LIST
7464: LIST
7465: PUSH
7466: EMPTY
7467: LIST
7468: LIST
7469: LIST
7470: ST_TO_ADDR
// MC_SetProduceList ( 2 , list ) ;
7471: LD_INT 2
7473: PPUSH
7474: LD_VAR 0 6
7478: PPUSH
7479: CALL 42631 0 2
// wait ( 0 0$20 ) ;
7483: LD_INT 700
7485: PPUSH
7486: CALL_OW 67
// end ; p := 60 ;
7490: LD_ADDR_VAR 0 7
7494: PUSH
7495: LD_INT 60
7497: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7498: LD_INT 35
7500: PPUSH
7501: CALL_OW 67
// p := Dec ( p ) ;
7505: LD_ADDR_VAR 0 7
7509: PUSH
7510: LD_VAR 0 7
7514: PPUSH
7515: CALL 88190 0 1
7519: ST_TO_ADDR
// until UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ] ) >= 4 or p <= 0 ;
7520: LD_EXP 69
7524: PUSH
7525: LD_INT 1
7527: ARRAY
7528: PPUSH
7529: LD_INT 3
7531: PUSH
7532: LD_INT 2
7534: PUSH
7535: LD_INT 34
7537: PUSH
7538: LD_INT 32
7540: PUSH
7541: EMPTY
7542: LIST
7543: LIST
7544: PUSH
7545: LD_INT 34
7547: PUSH
7548: LD_INT 88
7550: PUSH
7551: EMPTY
7552: LIST
7553: LIST
7554: PUSH
7555: EMPTY
7556: LIST
7557: LIST
7558: LIST
7559: PUSH
7560: EMPTY
7561: LIST
7562: LIST
7563: PPUSH
7564: CALL_OW 72
7568: PUSH
7569: LD_INT 4
7571: GREATEREQUAL
7572: PUSH
7573: LD_VAR 0 7
7577: PUSH
7578: LD_INT 0
7580: LESSEQUAL
7581: OR
7582: IFFALSE 7498
// wait ( 0 0$10 ) ;
7584: LD_INT 350
7586: PPUSH
7587: CALL_OW 67
// tmp := UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ] ) ;
7591: LD_ADDR_VAR 0 2
7595: PUSH
7596: LD_EXP 69
7600: PUSH
7601: LD_INT 1
7603: ARRAY
7604: PPUSH
7605: LD_INT 3
7607: PUSH
7608: LD_INT 2
7610: PUSH
7611: LD_INT 34
7613: PUSH
7614: LD_INT 32
7616: PUSH
7617: EMPTY
7618: LIST
7619: LIST
7620: PUSH
7621: LD_INT 34
7623: PUSH
7624: LD_INT 88
7626: PUSH
7627: EMPTY
7628: LIST
7629: LIST
7630: PUSH
7631: EMPTY
7632: LIST
7633: LIST
7634: LIST
7635: PUSH
7636: EMPTY
7637: LIST
7638: LIST
7639: PPUSH
7640: CALL_OW 72
7644: ST_TO_ADDR
// tmp2 := UnitFilter ( mc_vehicles [ 2 ] , [ f_not , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ] ) ;
7645: LD_ADDR_VAR 0 3
7649: PUSH
7650: LD_EXP 69
7654: PUSH
7655: LD_INT 2
7657: ARRAY
7658: PPUSH
7659: LD_INT 3
7661: PUSH
7662: LD_INT 2
7664: PUSH
7665: LD_INT 34
7667: PUSH
7668: LD_INT 32
7670: PUSH
7671: EMPTY
7672: LIST
7673: LIST
7674: PUSH
7675: LD_INT 34
7677: PUSH
7678: LD_INT 88
7680: PUSH
7681: EMPTY
7682: LIST
7683: LIST
7684: PUSH
7685: EMPTY
7686: LIST
7687: LIST
7688: LIST
7689: PUSH
7690: EMPTY
7691: LIST
7692: LIST
7693: PPUSH
7694: CALL_OW 72
7698: ST_TO_ADDR
// if tmp2 then
7699: LD_VAR 0 3
7703: IFFALSE 7721
// tmp := tmp union tmp2 ;
7705: LD_ADDR_VAR 0 2
7709: PUSH
7710: LD_VAR 0 2
7714: PUSH
7715: LD_VAR 0 3
7719: UNION
7720: ST_TO_ADDR
// if not tmp then
7721: LD_VAR 0 2
7725: NOT
7726: IFFALSE 7730
// exit ;
7728: GO 8090
// if Count ( tmp2 ) or Prob ( 50 ) then
7730: LD_VAR 0 3
7734: PPUSH
7735: CALL 51207 0 1
7739: PUSH
7740: LD_INT 50
7742: PPUSH
7743: CALL_OW 13
7747: OR
7748: IFFALSE 7781
// coords := [ [ 48 , 33 ] , [ 71 , 88 ] ] else
7750: LD_ADDR_VAR 0 4
7754: PUSH
7755: LD_INT 48
7757: PUSH
7758: LD_INT 33
7760: PUSH
7761: EMPTY
7762: LIST
7763: LIST
7764: PUSH
7765: LD_INT 71
7767: PUSH
7768: LD_INT 88
7770: PUSH
7771: EMPTY
7772: LIST
7773: LIST
7774: PUSH
7775: EMPTY
7776: LIST
7777: LIST
7778: ST_TO_ADDR
7779: GO 7810
// coords := [ [ 128 , 94 ] , [ 180 , 135 ] ] ;
7781: LD_ADDR_VAR 0 4
7785: PUSH
7786: LD_INT 128
7788: PUSH
7789: LD_INT 94
7791: PUSH
7792: EMPTY
7793: LIST
7794: LIST
7795: PUSH
7796: LD_INT 180
7798: PUSH
7799: LD_INT 135
7801: PUSH
7802: EMPTY
7803: LIST
7804: LIST
7805: PUSH
7806: EMPTY
7807: LIST
7808: LIST
7809: ST_TO_ADDR
// if w = 3 then
7810: LD_VAR 0 5
7814: PUSH
7815: LD_INT 3
7817: EQUAL
7818: IFFALSE 7849
// coords := [ [ 91 , 58 ] , [ 117 , 107 ] ] ;
7820: LD_ADDR_VAR 0 4
7824: PUSH
7825: LD_INT 91
7827: PUSH
7828: LD_INT 58
7830: PUSH
7831: EMPTY
7832: LIST
7833: LIST
7834: PUSH
7835: LD_INT 117
7837: PUSH
7838: LD_INT 107
7840: PUSH
7841: EMPTY
7842: LIST
7843: LIST
7844: PUSH
7845: EMPTY
7846: LIST
7847: LIST
7848: ST_TO_ADDR
// if FilterUnitsInArea ( base_north , [ f_side , 1 ] ) then
7849: LD_INT 28
7851: PPUSH
7852: LD_INT 22
7854: PUSH
7855: LD_INT 1
7857: PUSH
7858: EMPTY
7859: LIST
7860: LIST
7861: PPUSH
7862: CALL_OW 70
7866: IFFALSE 7886
// coords := [ [ 163 , 41 ] ] ;
7868: LD_ADDR_VAR 0 4
7872: PUSH
7873: LD_INT 163
7875: PUSH
7876: LD_INT 41
7878: PUSH
7879: EMPTY
7880: LIST
7881: LIST
7882: PUSH
7883: EMPTY
7884: LIST
7885: ST_TO_ADDR
// ComAgressiveMove ( tmp , coords [ 1 ] , coords [ 2 ] ) ;
7886: LD_VAR 0 2
7890: PPUSH
7891: LD_VAR 0 4
7895: PUSH
7896: LD_INT 1
7898: ARRAY
7899: PPUSH
7900: LD_VAR 0 4
7904: PUSH
7905: LD_INT 2
7907: ARRAY
7908: PPUSH
7909: CALL_OW 114
// p := 90 ;
7913: LD_ADDR_VAR 0 7
7917: PUSH
7918: LD_INT 90
7920: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7921: LD_INT 35
7923: PPUSH
7924: CALL_OW 67
// p := Dec ( p ) ;
7928: LD_ADDR_VAR 0 7
7932: PUSH
7933: LD_VAR 0 7
7937: PPUSH
7938: CALL 88190 0 1
7942: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_hastask ] ) = 0 or p <= 0 ;
7943: LD_VAR 0 2
7947: PPUSH
7948: LD_INT 60
7950: PUSH
7951: EMPTY
7952: LIST
7953: PPUSH
7954: CALL_OW 72
7958: PUSH
7959: LD_INT 0
7961: EQUAL
7962: PUSH
7963: LD_VAR 0 7
7967: PUSH
7968: LD_INT 0
7970: LESSEQUAL
7971: OR
7972: IFFALSE 7921
// repeat wait ( 0 0$2 ) ;
7974: LD_INT 70
7976: PPUSH
7977: CALL_OW 67
// for i in tmp do
7981: LD_ADDR_VAR 0 1
7985: PUSH
7986: LD_VAR 0 2
7990: PUSH
7991: FOR_IN
7992: IFFALSE 8081
// if GetChassis ( i ) = ar_hovercraft then
7994: LD_VAR 0 1
7998: PPUSH
7999: CALL_OW 265
8003: PUSH
8004: LD_INT 11
8006: EQUAL
8007: IFFALSE 8045
// AttackHovercraft ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) else
8009: LD_VAR 0 1
8013: PPUSH
8014: LD_INT 22
8016: PUSH
8017: LD_INT 1
8019: PUSH
8020: EMPTY
8021: LIST
8022: LIST
8023: PPUSH
8024: CALL_OW 69
8028: PPUSH
8029: LD_VAR 0 1
8033: PPUSH
8034: CALL_OW 74
8038: PPUSH
8039: CALL 82410 0 2
8043: GO 8079
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
8045: LD_VAR 0 1
8049: PPUSH
8050: LD_INT 22
8052: PUSH
8053: LD_INT 1
8055: PUSH
8056: EMPTY
8057: LIST
8058: LIST
8059: PPUSH
8060: CALL_OW 69
8064: PPUSH
8065: LD_VAR 0 1
8069: PPUSH
8070: CALL_OW 74
8074: PPUSH
8075: CALL_OW 115
8079: GO 7991
8081: POP
8082: POP
// until not tmp ;
8083: LD_VAR 0 2
8087: NOT
8088: IFFALSE 7974
// end ;
8090: PPOPN 7
8092: END
// every 28 28$00 do var i , tmp , un , x , p ;
8093: GO 8095
8095: DISABLE
8096: LD_INT 0
8098: PPUSH
8099: PPUSH
8100: PPUSH
8101: PPUSH
8102: PPUSH
// begin enable ;
8103: ENABLE
// wait ( rand ( 0 0$1 , 0 0$34 ) ) ;
8104: LD_INT 35
8106: PPUSH
8107: LD_INT 1190
8109: PPUSH
8110: CALL_OW 12
8114: PPUSH
8115: CALL_OW 67
// tmp := [ ] ;
8119: LD_ADDR_VAR 0 2
8123: PUSH
8124: EMPTY
8125: ST_TO_ADDR
// InitHc ;
8126: CALL_OW 19
// for i = 1 to 3 do
8130: LD_ADDR_VAR 0 1
8134: PUSH
8135: DOUBLE
8136: LD_INT 1
8138: DEC
8139: ST_TO_ADDR
8140: LD_INT 3
8142: PUSH
8143: FOR_TO
8144: IFFALSE 8287
// begin uc_side := 8 ;
8146: LD_ADDR_OWVAR 20
8150: PUSH
8151: LD_INT 8
8153: ST_TO_ADDR
// uc_nation := 2 ;
8154: LD_ADDR_OWVAR 21
8158: PUSH
8159: LD_INT 2
8161: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
8162: LD_INT 13
8164: PUSH
8165: LD_INT 14
8167: PUSH
8168: EMPTY
8169: LIST
8170: LIST
8171: PUSH
8172: LD_INT 1
8174: PPUSH
8175: LD_INT 2
8177: PPUSH
8178: CALL_OW 12
8182: ARRAY
8183: PPUSH
8184: LD_INT 3
8186: PPUSH
8187: LD_INT 5
8189: PPUSH
8190: LD_INT 27
8192: PUSH
8193: LD_INT 28
8195: PUSH
8196: EMPTY
8197: LIST
8198: LIST
8199: PUSH
8200: LD_INT 1
8202: PPUSH
8203: LD_INT 2
8205: PPUSH
8206: CALL_OW 12
8210: ARRAY
8211: PPUSH
8212: LD_INT 100
8214: PPUSH
8215: CALL 53945 0 5
// un := CreateVehicle ;
8219: LD_ADDR_VAR 0 3
8223: PUSH
8224: CALL_OW 45
8228: ST_TO_ADDR
// SetDir ( un , 4 ) ;
8229: LD_VAR 0 3
8233: PPUSH
8234: LD_INT 4
8236: PPUSH
8237: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
8241: LD_VAR 0 3
8245: PPUSH
8246: LD_INT 15
8248: PPUSH
8249: LD_INT 0
8251: PPUSH
8252: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8256: LD_ADDR_VAR 0 2
8260: PUSH
8261: LD_VAR 0 2
8265: PPUSH
8266: LD_VAR 0 2
8270: PUSH
8271: LD_INT 1
8273: PLUS
8274: PPUSH
8275: LD_VAR 0 3
8279: PPUSH
8280: CALL_OW 1
8284: ST_TO_ADDR
// end ;
8285: GO 8143
8287: POP
8288: POP
// for i = 1 to 3 do
8289: LD_ADDR_VAR 0 1
8293: PUSH
8294: DOUBLE
8295: LD_INT 1
8297: DEC
8298: ST_TO_ADDR
8299: LD_INT 3
8301: PUSH
8302: FOR_TO
8303: IFFALSE 8411
// begin uc_side := 8 ;
8305: LD_ADDR_OWVAR 20
8309: PUSH
8310: LD_INT 8
8312: ST_TO_ADDR
// uc_nation := 2 ;
8313: LD_ADDR_OWVAR 21
8317: PUSH
8318: LD_INT 2
8320: ST_TO_ADDR
// PrepareHuman ( false , 1 , 6 ) ;
8321: LD_INT 0
8323: PPUSH
8324: LD_INT 1
8326: PPUSH
8327: LD_INT 6
8329: PPUSH
8330: CALL_OW 380
// un := CreateHuman ;
8334: LD_ADDR_VAR 0 3
8338: PUSH
8339: CALL_OW 44
8343: ST_TO_ADDR
// if Prob ( 50 ) then
8344: LD_INT 50
8346: PPUSH
8347: CALL_OW 13
8351: IFFALSE 8365
// SetClass ( un , class_mortar ) ;
8353: LD_VAR 0 3
8357: PPUSH
8358: LD_INT 8
8360: PPUSH
8361: CALL_OW 336
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
8365: LD_VAR 0 3
8369: PPUSH
8370: LD_INT 15
8372: PPUSH
8373: LD_INT 0
8375: PPUSH
8376: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8380: LD_ADDR_VAR 0 2
8384: PUSH
8385: LD_VAR 0 2
8389: PPUSH
8390: LD_VAR 0 2
8394: PUSH
8395: LD_INT 1
8397: PLUS
8398: PPUSH
8399: LD_VAR 0 3
8403: PPUSH
8404: CALL_OW 1
8408: ST_TO_ADDR
// end ;
8409: GO 8302
8411: POP
8412: POP
// wait ( 0 0$3 ) ;
8413: LD_INT 105
8415: PPUSH
8416: CALL_OW 67
// p := 0 ;
8420: LD_ADDR_VAR 0 5
8424: PUSH
8425: LD_INT 0
8427: ST_TO_ADDR
// repeat wait ( 0 0$3 ) ;
8428: LD_INT 105
8430: PPUSH
8431: CALL_OW 67
// p := p + 3 ;
8435: LD_ADDR_VAR 0 5
8439: PUSH
8440: LD_VAR 0 5
8444: PUSH
8445: LD_INT 3
8447: PLUS
8448: ST_TO_ADDR
// for i in UnitFilter ( tmp , [ f_ok ] ) do
8449: LD_ADDR_VAR 0 1
8453: PUSH
8454: LD_VAR 0 2
8458: PPUSH
8459: LD_INT 50
8461: PUSH
8462: EMPTY
8463: LIST
8464: PPUSH
8465: CALL_OW 72
8469: PUSH
8470: FOR_IN
8471: IFFALSE 8509
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
8473: LD_VAR 0 1
8477: PPUSH
8478: LD_INT 81
8480: PUSH
8481: LD_INT 8
8483: PUSH
8484: EMPTY
8485: LIST
8486: LIST
8487: PPUSH
8488: CALL_OW 69
8492: PPUSH
8493: LD_VAR 0 1
8497: PPUSH
8498: CALL_OW 74
8502: PPUSH
8503: CALL_OW 115
8507: GO 8470
8509: POP
8510: POP
// until p >= 120 ;
8511: LD_VAR 0 5
8515: PUSH
8516: LD_INT 120
8518: GREATEREQUAL
8519: IFFALSE 8428
// repeat AddComAgressiveMove ( tmp , 210 , 178 ) ;
8521: LD_VAR 0 2
8525: PPUSH
8526: LD_INT 210
8528: PPUSH
8529: LD_INT 178
8531: PPUSH
8532: CALL_OW 174
// x := FilterUnitsInArea ( escape_area , [ f_side , 8 ] ) ;
8536: LD_ADDR_VAR 0 4
8540: PUSH
8541: LD_INT 10
8543: PPUSH
8544: LD_INT 22
8546: PUSH
8547: LD_INT 8
8549: PUSH
8550: EMPTY
8551: LIST
8552: LIST
8553: PPUSH
8554: CALL_OW 70
8558: ST_TO_ADDR
// if x then
8559: LD_VAR 0 4
8563: IFFALSE 8591
// for i in x do
8565: LD_ADDR_VAR 0 1
8569: PUSH
8570: LD_VAR 0 4
8574: PUSH
8575: FOR_IN
8576: IFFALSE 8589
// RemoveUnit ( i ) ;
8578: LD_VAR 0 1
8582: PPUSH
8583: CALL_OW 64
8587: GO 8575
8589: POP
8590: POP
// wait ( 0 0$1 ) ;
8591: LD_INT 35
8593: PPUSH
8594: CALL_OW 67
// until not FilterAllUnits ( [ f_side , 8 ] ) ;
8598: LD_INT 22
8600: PUSH
8601: LD_INT 8
8603: PUSH
8604: EMPTY
8605: LIST
8606: LIST
8607: PPUSH
8608: CALL_OW 69
8612: NOT
8613: IFFALSE 8521
// end ;
8615: PPOPN 5
8617: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
8618: LD_INT 22
8620: PUSH
8621: LD_INT 2
8623: PUSH
8624: EMPTY
8625: LIST
8626: LIST
8627: PUSH
8628: LD_INT 34
8630: PUSH
8631: LD_INT 31
8633: PUSH
8634: EMPTY
8635: LIST
8636: LIST
8637: PUSH
8638: LD_INT 3
8640: PUSH
8641: LD_INT 24
8643: PUSH
8644: LD_INT 1000
8646: PUSH
8647: EMPTY
8648: LIST
8649: LIST
8650: PUSH
8651: EMPTY
8652: LIST
8653: LIST
8654: PUSH
8655: EMPTY
8656: LIST
8657: LIST
8658: LIST
8659: PPUSH
8660: CALL_OW 69
8664: IFFALSE 8767
8666: GO 8668
8668: DISABLE
// begin if IsOk ( ar_dep_w ) and GetSide ( ar_dep_w ) then
8669: LD_INT 45
8671: PPUSH
8672: CALL_OW 302
8676: PUSH
8677: LD_INT 45
8679: PPUSH
8680: CALL_OW 255
8684: AND
8685: IFFALSE 8728
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 18 , 8 ) else
8687: LD_INT 22
8689: PUSH
8690: LD_INT 2
8692: PUSH
8693: EMPTY
8694: LIST
8695: LIST
8696: PUSH
8697: LD_INT 34
8699: PUSH
8700: LD_INT 31
8702: PUSH
8703: EMPTY
8704: LIST
8705: LIST
8706: PUSH
8707: EMPTY
8708: LIST
8709: LIST
8710: PPUSH
8711: CALL_OW 69
8715: PPUSH
8716: LD_INT 18
8718: PPUSH
8719: LD_INT 8
8721: PPUSH
8722: CALL_OW 111
8726: GO 8767
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 106 , 14 ) ;
8728: LD_INT 22
8730: PUSH
8731: LD_INT 2
8733: PUSH
8734: EMPTY
8735: LIST
8736: LIST
8737: PUSH
8738: LD_INT 34
8740: PUSH
8741: LD_INT 31
8743: PUSH
8744: EMPTY
8745: LIST
8746: LIST
8747: PUSH
8748: EMPTY
8749: LIST
8750: LIST
8751: PPUSH
8752: CALL_OW 69
8756: PPUSH
8757: LD_INT 106
8759: PPUSH
8760: LD_INT 14
8762: PPUSH
8763: CALL_OW 111
// end ; end_of_file
8767: END
// export function Action ; var tmp , p , radar , sols , i ; begin
8768: LD_INT 0
8770: PPUSH
8771: PPUSH
8772: PPUSH
8773: PPUSH
8774: PPUSH
8775: PPUSH
// InGameOn ;
8776: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
8780: LD_EXP 21
8784: PPUSH
8785: CALL_OW 87
// SetAttitude ( 2 , 1 , att_friend , true ) ;
8789: LD_INT 2
8791: PPUSH
8792: LD_INT 1
8794: PPUSH
8795: LD_INT 1
8797: PPUSH
8798: LD_INT 1
8800: PPUSH
8801: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) ;
8805: LD_ADDR_VAR 0 2
8809: PUSH
8810: LD_INT 22
8812: PUSH
8813: LD_INT 1
8815: PUSH
8816: EMPTY
8817: LIST
8818: LIST
8819: PUSH
8820: LD_INT 25
8822: PUSH
8823: LD_INT 1
8825: PUSH
8826: EMPTY
8827: LIST
8828: LIST
8829: PUSH
8830: EMPTY
8831: LIST
8832: LIST
8833: PPUSH
8834: CALL_OW 69
8838: ST_TO_ADDR
// radar := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_radar ] ] ) [ 1 ] ;
8839: LD_ADDR_VAR 0 4
8843: PUSH
8844: LD_INT 22
8846: PUSH
8847: LD_INT 1
8849: PUSH
8850: EMPTY
8851: LIST
8852: LIST
8853: PUSH
8854: LD_INT 34
8856: PUSH
8857: LD_INT 11
8859: PUSH
8860: EMPTY
8861: LIST
8862: LIST
8863: PUSH
8864: EMPTY
8865: LIST
8866: LIST
8867: PPUSH
8868: CALL_OW 69
8872: PUSH
8873: LD_INT 1
8875: ARRAY
8876: ST_TO_ADDR
// for i = 1 to tmp do
8877: LD_ADDR_VAR 0 6
8881: PUSH
8882: DOUBLE
8883: LD_INT 1
8885: DEC
8886: ST_TO_ADDR
8887: LD_VAR 0 2
8891: PUSH
8892: FOR_TO
8893: IFFALSE 8940
// begin if i = 5 then
8895: LD_VAR 0 6
8899: PUSH
8900: LD_INT 5
8902: EQUAL
8903: IFFALSE 8907
// break ;
8905: GO 8940
// sols := Replace ( sols , i , tmp [ i ] ) ;
8907: LD_ADDR_VAR 0 5
8911: PUSH
8912: LD_VAR 0 5
8916: PPUSH
8917: LD_VAR 0 6
8921: PPUSH
8922: LD_VAR 0 2
8926: PUSH
8927: LD_VAR 0 6
8931: ARRAY
8932: PPUSH
8933: CALL_OW 1
8937: ST_TO_ADDR
// end ;
8938: GO 8892
8940: POP
8941: POP
// tmp := ar_force_tmp ;
8942: LD_ADDR_VAR 0 2
8946: PUSH
8947: LD_EXP 40
8951: ST_TO_ADDR
// PlaceUnitXY ( tmp [ 1 ] , 108 , 139 , false ) ;
8952: LD_VAR 0 2
8956: PUSH
8957: LD_INT 1
8959: ARRAY
8960: PPUSH
8961: LD_INT 108
8963: PPUSH
8964: LD_INT 139
8966: PPUSH
8967: LD_INT 0
8969: PPUSH
8970: CALL_OW 48
// ComTurnUnit ( tmp [ 1 ] , JMM ) ;
8974: LD_VAR 0 2
8978: PUSH
8979: LD_INT 1
8981: ARRAY
8982: PPUSH
8983: LD_EXP 21
8987: PPUSH
8988: CALL_OW 119
// PlaceUnitXY ( tmp [ 2 ] , 114 , 132 , false ) ;
8992: LD_VAR 0 2
8996: PUSH
8997: LD_INT 2
8999: ARRAY
9000: PPUSH
9001: LD_INT 114
9003: PPUSH
9004: LD_INT 132
9006: PPUSH
9007: LD_INT 0
9009: PPUSH
9010: CALL_OW 48
// PlaceUnitXY ( tmp [ 3 ] , 115 , 132 , false ) ;
9014: LD_VAR 0 2
9018: PUSH
9019: LD_INT 3
9021: ARRAY
9022: PPUSH
9023: LD_INT 115
9025: PPUSH
9026: LD_INT 132
9028: PPUSH
9029: LD_INT 0
9031: PPUSH
9032: CALL_OW 48
// ComHold ( [ tmp [ 2 ] , tmp [ 3 ] ] ) ;
9036: LD_VAR 0 2
9040: PUSH
9041: LD_INT 2
9043: ARRAY
9044: PUSH
9045: LD_VAR 0 2
9049: PUSH
9050: LD_INT 3
9052: ARRAY
9053: PUSH
9054: EMPTY
9055: LIST
9056: LIST
9057: PPUSH
9058: CALL_OW 140
// ComMoveXY ( radar , 83 , 123 ) ;
9062: LD_VAR 0 4
9066: PPUSH
9067: LD_INT 83
9069: PPUSH
9070: LD_INT 123
9072: PPUSH
9073: CALL_OW 111
// Wait ( 0 0$01 ) ;
9077: LD_INT 35
9079: PPUSH
9080: CALL_OW 67
// CenterOnXY ( 90 , 144 ) ;
9084: LD_INT 90
9086: PPUSH
9087: LD_INT 144
9089: PPUSH
9090: CALL_OW 84
// ComMoveXY ( sols , 88 , 129 ) ;
9094: LD_VAR 0 5
9098: PPUSH
9099: LD_INT 88
9101: PPUSH
9102: LD_INT 129
9104: PPUSH
9105: CALL_OW 111
// p := [ [ 92 , 131 ] , [ 88 , 127 ] , [ 91 , 132 ] , [ 92 , 134 ] ] ;
9109: LD_ADDR_VAR 0 3
9113: PUSH
9114: LD_INT 92
9116: PUSH
9117: LD_INT 131
9119: PUSH
9120: EMPTY
9121: LIST
9122: LIST
9123: PUSH
9124: LD_INT 88
9126: PUSH
9127: LD_INT 127
9129: PUSH
9130: EMPTY
9131: LIST
9132: LIST
9133: PUSH
9134: LD_INT 91
9136: PUSH
9137: LD_INT 132
9139: PUSH
9140: EMPTY
9141: LIST
9142: LIST
9143: PUSH
9144: LD_INT 92
9146: PUSH
9147: LD_INT 134
9149: PUSH
9150: EMPTY
9151: LIST
9152: LIST
9153: PUSH
9154: EMPTY
9155: LIST
9156: LIST
9157: LIST
9158: LIST
9159: ST_TO_ADDR
// for i = 1 to sols do
9160: LD_ADDR_VAR 0 6
9164: PUSH
9165: DOUBLE
9166: LD_INT 1
9168: DEC
9169: ST_TO_ADDR
9170: LD_VAR 0 5
9174: PUSH
9175: FOR_TO
9176: IFFALSE 9249
// begin AddComMoveXY ( sols [ i ] , p [ i ] [ 1 ] , p [ i ] [ 2 ] ) ;
9178: LD_VAR 0 5
9182: PUSH
9183: LD_VAR 0 6
9187: ARRAY
9188: PPUSH
9189: LD_VAR 0 3
9193: PUSH
9194: LD_VAR 0 6
9198: ARRAY
9199: PUSH
9200: LD_INT 1
9202: ARRAY
9203: PPUSH
9204: LD_VAR 0 3
9208: PUSH
9209: LD_VAR 0 6
9213: ARRAY
9214: PUSH
9215: LD_INT 2
9217: ARRAY
9218: PPUSH
9219: CALL_OW 171
// AddComCrawl ( sols [ i ] ) ;
9223: LD_VAR 0 5
9227: PUSH
9228: LD_VAR 0 6
9232: ARRAY
9233: PPUSH
9234: CALL_OW 197
// AddComHold ( sols ) ;
9238: LD_VAR 0 5
9242: PPUSH
9243: CALL_OW 200
// end ;
9247: GO 9175
9249: POP
9250: POP
// repeat wait ( 0 0$1 ) ;
9251: LD_INT 35
9253: PPUSH
9254: CALL_OW 67
// until GetDistUnitXY ( sols [ 1 ] , 92 , 131 ) < 4 ;
9258: LD_VAR 0 5
9262: PUSH
9263: LD_INT 1
9265: ARRAY
9266: PPUSH
9267: LD_INT 92
9269: PPUSH
9270: LD_INT 131
9272: PPUSH
9273: CALL_OW 297
9277: PUSH
9278: LD_INT 4
9280: LESS
9281: IFFALSE 9251
// CenterOnXY ( 96 , 139 ) ;
9283: LD_INT 96
9285: PPUSH
9286: LD_INT 139
9288: PPUSH
9289: CALL_OW 84
// wait ( 0 0$3 ) ;
9293: LD_INT 105
9295: PPUSH
9296: CALL_OW 67
// PlaceSeeing ( 111 , 135 , 1 , - 25 ) ;
9300: LD_INT 111
9302: PPUSH
9303: LD_INT 135
9305: PPUSH
9306: LD_INT 1
9308: PPUSH
9309: LD_INT 25
9311: NEG
9312: PPUSH
9313: CALL_OW 330
// ComMoveXY ( tmp [ 2 ] , GetX ( tmp [ 1 ] ) + 3 , GetY ( tmp [ 1 ] ) ) ;
9317: LD_VAR 0 2
9321: PUSH
9322: LD_INT 2
9324: ARRAY
9325: PPUSH
9326: LD_VAR 0 2
9330: PUSH
9331: LD_INT 1
9333: ARRAY
9334: PPUSH
9335: CALL_OW 250
9339: PUSH
9340: LD_INT 3
9342: PLUS
9343: PPUSH
9344: LD_VAR 0 2
9348: PUSH
9349: LD_INT 1
9351: ARRAY
9352: PPUSH
9353: CALL_OW 251
9357: PPUSH
9358: CALL_OW 111
// ComEnterUnit ( tmp [ 3 ] , ar_dep_s ) ;
9362: LD_VAR 0 2
9366: PUSH
9367: LD_INT 3
9369: ARRAY
9370: PPUSH
9371: LD_INT 7
9373: PPUSH
9374: CALL_OW 120
// AddComTurnUnit ( tmp [ 2 ] , tmp [ 1 ] ) ;
9378: LD_VAR 0 2
9382: PUSH
9383: LD_INT 2
9385: ARRAY
9386: PPUSH
9387: LD_VAR 0 2
9391: PUSH
9392: LD_INT 1
9394: ARRAY
9395: PPUSH
9396: CALL_OW 179
// repeat wait ( 0 0$1 ) ;
9400: LD_INT 35
9402: PPUSH
9403: CALL_OW 67
// until GetDistUnits ( tmp [ 1 ] , tmp [ 2 ] ) < 5 ;
9407: LD_VAR 0 2
9411: PUSH
9412: LD_INT 1
9414: ARRAY
9415: PPUSH
9416: LD_VAR 0 2
9420: PUSH
9421: LD_INT 2
9423: ARRAY
9424: PPUSH
9425: CALL_OW 296
9429: PUSH
9430: LD_INT 5
9432: LESS
9433: IFFALSE 9400
// ComTurnUnit ( tmp [ 1 ] , tmp [ 2 ] ) ;
9435: LD_VAR 0 2
9439: PUSH
9440: LD_INT 1
9442: ARRAY
9443: PPUSH
9444: LD_VAR 0 2
9448: PUSH
9449: LD_INT 2
9451: ARRAY
9452: PPUSH
9453: CALL_OW 119
// Say ( tmp [ 1 ] , D1a-Merc1-1 ) ;
9457: LD_VAR 0 2
9461: PUSH
9462: LD_INT 1
9464: ARRAY
9465: PPUSH
9466: LD_STRING D1a-Merc1-1
9468: PPUSH
9469: CALL_OW 88
// Say ( tmp [ 2 ] , D1a-FMerc2-1 ) ;
9473: LD_VAR 0 2
9477: PUSH
9478: LD_INT 2
9480: ARRAY
9481: PPUSH
9482: LD_STRING D1a-FMerc2-1
9484: PPUSH
9485: CALL_OW 88
// ComHeal ( tmp [ 2 ] , tmp [ 1 ] ) ;
9489: LD_VAR 0 2
9493: PUSH
9494: LD_INT 2
9496: ARRAY
9497: PPUSH
9498: LD_VAR 0 2
9502: PUSH
9503: LD_INT 1
9505: ARRAY
9506: PPUSH
9507: CALL_OW 128
// SetLives ( tmp [ 1 ] , 500 ) ;
9511: LD_VAR 0 2
9515: PUSH
9516: LD_INT 1
9518: ARRAY
9519: PPUSH
9520: LD_INT 500
9522: PPUSH
9523: CALL_OW 234
// wait ( 0 0$2 ) ;
9527: LD_INT 70
9529: PPUSH
9530: CALL_OW 67
// SetLives ( tmp [ 1 ] , 2 ) ;
9534: LD_VAR 0 2
9538: PUSH
9539: LD_INT 1
9541: ARRAY
9542: PPUSH
9543: LD_INT 2
9545: PPUSH
9546: CALL_OW 234
// wait ( 0 0$0.3 ) ;
9550: LD_INT 10
9552: PPUSH
9553: CALL_OW 67
// ForceSay ( tmp [ 1 ] , D1a-Merc1-2 ) ;
9557: LD_VAR 0 2
9561: PUSH
9562: LD_INT 1
9564: ARRAY
9565: PPUSH
9566: LD_STRING D1a-Merc1-2
9568: PPUSH
9569: CALL_OW 91
// wait ( 0 0$0.2 ) ;
9573: LD_INT 7
9575: PPUSH
9576: CALL_OW 67
// KillUnit ( tmp [ 1 ] ) ;
9580: LD_VAR 0 2
9584: PUSH
9585: LD_INT 1
9587: ARRAY
9588: PPUSH
9589: CALL_OW 66
// ComMoveToArea ( tmp [ 2 ] , escape_area ) ;
9593: LD_VAR 0 2
9597: PUSH
9598: LD_INT 2
9600: ARRAY
9601: PPUSH
9602: LD_INT 10
9604: PPUSH
9605: CALL_OW 113
// Say ( tmp [ 2 ] , D1a-FMerc2-2 ) ;
9609: LD_VAR 0 2
9613: PUSH
9614: LD_INT 2
9616: ARRAY
9617: PPUSH
9618: LD_STRING D1a-FMerc2-2
9620: PPUSH
9621: CALL_OW 88
// wait ( 0 0$1 ) ;
9625: LD_INT 35
9627: PPUSH
9628: CALL_OW 67
// CenterOnUnits ( ar_dep_s ) ;
9632: LD_INT 7
9634: PPUSH
9635: CALL_OW 85
// wait ( 0 0$2 ) ;
9639: LD_INT 70
9641: PPUSH
9642: CALL_OW 67
// ForceSay ( Saliba , D1a-Saliba-1 ) ;
9646: LD_EXP 44
9650: PPUSH
9651: LD_STRING D1a-Saliba-1
9653: PPUSH
9654: CALL_OW 91
// KillUnit ( Saliba ) ;
9658: LD_EXP 44
9662: PPUSH
9663: CALL_OW 66
// ComExitBuilding ( tmp [ 3 ] ) ;
9667: LD_VAR 0 2
9671: PUSH
9672: LD_INT 3
9674: ARRAY
9675: PPUSH
9676: CALL_OW 122
// CenterOnUnits ( JMM ) ;
9680: LD_EXP 21
9684: PPUSH
9685: CALL_OW 85
// wait ( 0 0$1 ) ;
9689: LD_INT 35
9691: PPUSH
9692: CALL_OW 67
// ComMoveXY ( sols , 88 , 141 ) ;
9696: LD_VAR 0 5
9700: PPUSH
9701: LD_INT 88
9703: PPUSH
9704: LD_INT 141
9706: PPUSH
9707: CALL_OW 111
// AddComWait ( sols , 0 0$2 ) ;
9711: LD_VAR 0 5
9715: PPUSH
9716: LD_INT 70
9718: PPUSH
9719: CALL_OW 202
// wait ( 0 0$2 ) ;
9723: LD_INT 70
9725: PPUSH
9726: CALL_OW 67
// SetAttitude ( 2 , 1 , att_enemy , true ) ;
9730: LD_INT 2
9732: PPUSH
9733: LD_INT 1
9735: PPUSH
9736: LD_INT 2
9738: PPUSH
9739: LD_INT 1
9741: PPUSH
9742: CALL_OW 80
// InGameOff ;
9746: CALL_OW 9
// ComWalk ( sols ) ;
9750: LD_VAR 0 5
9754: PPUSH
9755: CALL_OW 138
// ChangeMissionObjectives ( M1 ) ;
9759: LD_STRING M1
9761: PPUSH
9762: CALL_OW 337
// game_speed := 4 ;
9766: LD_ADDR_OWVAR 65
9770: PUSH
9771: LD_INT 4
9773: ST_TO_ADDR
// RemoveSeeing ( 111 , 135 , 1 ) ;
9774: LD_INT 111
9776: PPUSH
9777: LD_INT 135
9779: PPUSH
9780: LD_INT 1
9782: PPUSH
9783: CALL_OW 331
// SaveForQuickRestart ;
9787: CALL_OW 22
// ar_run := true ;
9791: LD_ADDR_EXP 5
9795: PUSH
9796: LD_INT 1
9798: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9799: LD_INT 35
9801: PPUSH
9802: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 1 ] , [ f_dist , ar_dep_s , 10 ] ] ) or GetLives ( ar_dep_s ) < 999 ;
9806: LD_INT 22
9808: PUSH
9809: LD_INT 1
9811: PUSH
9812: EMPTY
9813: LIST
9814: LIST
9815: PUSH
9816: LD_INT 91
9818: PUSH
9819: LD_INT 7
9821: PUSH
9822: LD_INT 10
9824: PUSH
9825: EMPTY
9826: LIST
9827: LIST
9828: LIST
9829: PUSH
9830: EMPTY
9831: LIST
9832: LIST
9833: PPUSH
9834: CALL_OW 69
9838: PUSH
9839: LD_INT 7
9841: PPUSH
9842: CALL_OW 256
9846: PUSH
9847: LD_INT 999
9849: LESS
9850: OR
9851: IFFALSE 9799
// if GetSide ( ar_dep_s ) = 2 then
9853: LD_INT 7
9855: PPUSH
9856: CALL_OW 255
9860: PUSH
9861: LD_INT 2
9863: EQUAL
9864: IFFALSE 9876
// SetSide ( ar_dep_s , 1 ) ;
9866: LD_INT 7
9868: PPUSH
9869: LD_INT 1
9871: PPUSH
9872: CALL_OW 235
// end ;
9876: LD_VAR 0 1
9880: RET
// every 0 0$2 trigger ar_run do var i , tmp , k ;
9881: LD_EXP 5
9885: IFFALSE 10245
9887: GO 9889
9889: DISABLE
9890: LD_INT 0
9892: PPUSH
9893: PPUSH
9894: PPUSH
// begin tmp := ar_force_tmp ^ UnitFilter ( ar_force_south , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ) ;
9895: LD_ADDR_VAR 0 2
9899: PUSH
9900: LD_EXP 40
9904: PUSH
9905: LD_EXP 36
9909: PPUSH
9910: LD_INT 2
9912: PUSH
9913: LD_INT 21
9915: PUSH
9916: LD_INT 2
9918: PUSH
9919: EMPTY
9920: LIST
9921: LIST
9922: PUSH
9923: LD_INT 21
9925: PUSH
9926: LD_INT 1
9928: PUSH
9929: EMPTY
9930: LIST
9931: LIST
9932: PUSH
9933: EMPTY
9934: LIST
9935: LIST
9936: LIST
9937: PPUSH
9938: CALL_OW 72
9942: ADD
9943: ST_TO_ADDR
// SetSide ( tmp , 5 ) ;
9944: LD_VAR 0 2
9948: PPUSH
9949: LD_INT 5
9951: PPUSH
9952: CALL_OW 235
// ChangeSideFog ( 5 , 1 ) ;
9956: LD_INT 5
9958: PPUSH
9959: LD_INT 1
9961: PPUSH
9962: CALL_OW 343
// k := 1 ;
9966: LD_ADDR_VAR 0 3
9970: PUSH
9971: LD_INT 1
9973: ST_TO_ADDR
// for i in tmp do
9974: LD_ADDR_VAR 0 1
9978: PUSH
9979: LD_VAR 0 2
9983: PUSH
9984: FOR_IN
9985: IFFALSE 10070
// begin if IsInUnit ( i ) then
9987: LD_VAR 0 1
9991: PPUSH
9992: CALL_OW 310
9996: IFFALSE 10007
// ComExitBuilding ( i ) ;
9998: LD_VAR 0 1
10002: PPUSH
10003: CALL_OW 122
// if GetClass ( i ) = 3 then
10007: LD_VAR 0 1
10011: PPUSH
10012: CALL_OW 257
10016: PUSH
10017: LD_INT 3
10019: EQUAL
10020: IFFALSE 10056
// begin AddComEnterUnit ( i , ar_vehicles_tmp [ k ] ) ;
10022: LD_VAR 0 1
10026: PPUSH
10027: LD_EXP 41
10031: PUSH
10032: LD_VAR 0 3
10036: ARRAY
10037: PPUSH
10038: CALL_OW 180
// k := k + 1 ;
10042: LD_ADDR_VAR 0 3
10046: PUSH
10047: LD_VAR 0 3
10051: PUSH
10052: LD_INT 1
10054: PLUS
10055: ST_TO_ADDR
// end ; AddComMoveToArea ( i , escape_area ) ;
10056: LD_VAR 0 1
10060: PPUSH
10061: LD_INT 10
10063: PPUSH
10064: CALL_OW 173
// end ;
10068: GO 9984
10070: POP
10071: POP
// ar_patrol := true ;
10072: LD_ADDR_EXP 7
10076: PUSH
10077: LD_INT 1
10079: ST_TO_ADDR
// repeat wait ( 0 0$0.3 ) ;
10080: LD_INT 10
10082: PPUSH
10083: CALL_OW 67
// for i in tmp do
10087: LD_ADDR_VAR 0 1
10091: PUSH
10092: LD_VAR 0 2
10096: PUSH
10097: FOR_IN
10098: IFFALSE 10126
// if not HasTask ( i ) then
10100: LD_VAR 0 1
10104: PPUSH
10105: CALL_OW 314
10109: NOT
10110: IFFALSE 10124
// ComMoveToArea ( i , escape_area ) ;
10112: LD_VAR 0 1
10116: PPUSH
10117: LD_INT 10
10119: PPUSH
10120: CALL_OW 113
10124: GO 10097
10126: POP
10127: POP
// k := UnitFilter ( tmp , [ f_inarea , escape_area ] ) ;
10128: LD_ADDR_VAR 0 3
10132: PUSH
10133: LD_VAR 0 2
10137: PPUSH
10138: LD_INT 95
10140: PUSH
10141: LD_INT 10
10143: PUSH
10144: EMPTY
10145: LIST
10146: LIST
10147: PPUSH
10148: CALL_OW 72
10152: ST_TO_ADDR
// if k then
10153: LD_VAR 0 3
10157: IFFALSE 10226
// for i in k do
10159: LD_ADDR_VAR 0 1
10163: PUSH
10164: LD_VAR 0 3
10168: PUSH
10169: FOR_IN
10170: IFFALSE 10224
// begin if IsInUnit ( i ) then
10172: LD_VAR 0 1
10176: PPUSH
10177: CALL_OW 310
10181: IFFALSE 10197
// RemoveUnit ( IsInUnit ( i ) ) ;
10183: LD_VAR 0 1
10187: PPUSH
10188: CALL_OW 310
10192: PPUSH
10193: CALL_OW 64
// RemoveUnit ( i ) ;
10197: LD_VAR 0 1
10201: PPUSH
10202: CALL_OW 64
// tmp := tmp diff i ;
10206: LD_ADDR_VAR 0 2
10210: PUSH
10211: LD_VAR 0 2
10215: PUSH
10216: LD_VAR 0 1
10220: DIFF
10221: ST_TO_ADDR
// end ;
10222: GO 10169
10224: POP
10225: POP
// until tmp = [ ] ;
10226: LD_VAR 0 2
10230: PUSH
10231: EMPTY
10232: EQUAL
10233: IFFALSE 10080
// ChangeSideFog ( 5 , 5 ) ;
10235: LD_INT 5
10237: PPUSH
10238: LD_INT 5
10240: PPUSH
10241: CALL_OW 343
// end ;
10245: PPOPN 3
10247: END
// every 0 0$03 trigger ar_patrol do var i , un , veh ;
10248: LD_EXP 7
10252: IFFALSE 10542
10254: GO 10256
10256: DISABLE
10257: LD_INT 0
10259: PPUSH
10260: PPUSH
10261: PPUSH
// begin uc_side := 2 ;
10262: LD_ADDR_OWVAR 20
10266: PUSH
10267: LD_INT 2
10269: ST_TO_ADDR
// uc_nation := 2 ;
10270: LD_ADDR_OWVAR 21
10274: PUSH
10275: LD_INT 2
10277: ST_TO_ADDR
// InitHc ;
10278: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
10282: LD_INT 1
10284: PPUSH
10285: LD_INT 1
10287: PPUSH
10288: LD_INT 6
10290: PPUSH
10291: CALL_OW 380
// un := CreateHuman ;
10295: LD_ADDR_VAR 0 2
10299: PUSH
10300: CALL_OW 44
10304: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_combustion , control_manual , ar_gun , 98 ) ;
10305: LD_INT 14
10307: PPUSH
10308: LD_INT 1
10310: PPUSH
10311: LD_INT 1
10313: PPUSH
10314: LD_INT 27
10316: PPUSH
10317: LD_INT 98
10319: PPUSH
10320: CALL 53945 0 5
// veh := CreateVehicle ;
10324: LD_ADDR_VAR 0 3
10328: PUSH
10329: CALL_OW 45
10333: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
10334: LD_VAR 0 3
10338: PPUSH
10339: LD_INT 4
10341: PPUSH
10342: CALL_OW 233
// PlaceUnitXY ( veh , 179 , 135 , false ) ;
10346: LD_VAR 0 3
10350: PPUSH
10351: LD_INT 179
10353: PPUSH
10354: LD_INT 135
10356: PPUSH
10357: LD_INT 0
10359: PPUSH
10360: CALL_OW 48
// PlaceHumanInUnit ( un , veh ) ;
10364: LD_VAR 0 2
10368: PPUSH
10369: LD_VAR 0 3
10373: PPUSH
10374: CALL_OW 52
// ComMoveXY ( un , 126 , 133 ) ;
10378: LD_VAR 0 2
10382: PPUSH
10383: LD_INT 126
10385: PPUSH
10386: LD_INT 133
10388: PPUSH
10389: CALL_OW 111
// repeat wait ( 0 0$0.3 ) ;
10393: LD_INT 10
10395: PPUSH
10396: CALL_OW 67
// until See ( 1 , veh ) or GetDistUnits ( veh , ar_dep_s ) < 9 ;
10400: LD_INT 1
10402: PPUSH
10403: LD_VAR 0 3
10407: PPUSH
10408: CALL_OW 292
10412: PUSH
10413: LD_VAR 0 3
10417: PPUSH
10418: LD_INT 7
10420: PPUSH
10421: CALL_OW 296
10425: PUSH
10426: LD_INT 9
10428: LESS
10429: OR
10430: IFFALSE 10393
// ComHold ( veh ) ;
10432: LD_VAR 0 3
10436: PPUSH
10437: CALL_OW 140
// Say ( un , D2aa-Ar1-1 ) ;
10441: LD_VAR 0 2
10445: PPUSH
10446: LD_STRING D2aa-Ar1-1
10448: PPUSH
10449: CALL_OW 88
// ComMoveXY ( un , 177 , 96 ) ;
10453: LD_VAR 0 2
10457: PPUSH
10458: LD_INT 177
10460: PPUSH
10461: LD_INT 96
10463: PPUSH
10464: CALL_OW 111
// AddComExitVehicle ( un ) ;
10468: LD_VAR 0 2
10472: PPUSH
10473: CALL_OW 181
// repeat wait ( 0 0$1 ) ;
10477: LD_INT 35
10479: PPUSH
10480: CALL_OW 67
// until GetDistUnits ( un , ar_dep_e ) < 15 ;
10484: LD_VAR 0 2
10488: PPUSH
10489: LD_INT 204
10491: PPUSH
10492: CALL_OW 296
10496: PUSH
10497: LD_INT 15
10499: LESS
10500: IFFALSE 10477
// mc_bases := ReplaceIn ( mc_bases , [ 3 , mc_bases [ 3 ] + 1 ] , un ) ;
10502: LD_ADDR_EXP 50
10506: PUSH
10507: LD_EXP 50
10511: PPUSH
10512: LD_INT 3
10514: PUSH
10515: LD_EXP 50
10519: PUSH
10520: LD_INT 3
10522: ARRAY
10523: PUSH
10524: LD_INT 1
10526: PLUS
10527: PUSH
10528: EMPTY
10529: LIST
10530: LIST
10531: PPUSH
10532: LD_VAR 0 2
10536: PPUSH
10537: CALL 54067 0 3
10541: ST_TO_ADDR
// end ;
10542: PPOPN 3
10544: END
// every 0 0$2 trigger GetSide ( ar_dep_s ) = 1 or IsDead ( ar_dep_s ) do var i , points ;
10545: LD_INT 7
10547: PPUSH
10548: CALL_OW 255
10552: PUSH
10553: LD_INT 1
10555: EQUAL
10556: PUSH
10557: LD_INT 7
10559: PPUSH
10560: CALL_OW 301
10564: OR
10565: IFFALSE 12970
10567: GO 10569
10569: DISABLE
10570: LD_INT 0
10572: PPUSH
10573: PPUSH
// begin for i in UnitFilter ( ar_force_south , [ f_type , unit_building ] ) do
10574: LD_ADDR_VAR 0 1
10578: PUSH
10579: LD_EXP 36
10583: PPUSH
10584: LD_INT 21
10586: PUSH
10587: LD_INT 3
10589: PUSH
10590: EMPTY
10591: LIST
10592: LIST
10593: PPUSH
10594: CALL_OW 72
10598: PUSH
10599: FOR_IN
10600: IFFALSE 10616
// SetSide ( i , 1 ) ;
10602: LD_VAR 0 1
10606: PPUSH
10607: LD_INT 1
10609: PPUSH
10610: CALL_OW 235
10614: GO 10599
10616: POP
10617: POP
// points := [ [ 46 , 41 ] , [ 50 , 25 ] , [ 57 , 75 ] , [ 75 , 89 ] , [ 51 , 45 ] , [ 95 , 95 ] , [ 84 , 77 ] , [ 101 , 76 ] , [ 118 , 81 ] , [ 139 , 97 ] , [ 129 , 114 ] , [ 154 , 111 ] ] ;
10618: LD_ADDR_VAR 0 2
10622: PUSH
10623: LD_INT 46
10625: PUSH
10626: LD_INT 41
10628: PUSH
10629: EMPTY
10630: LIST
10631: LIST
10632: PUSH
10633: LD_INT 50
10635: PUSH
10636: LD_INT 25
10638: PUSH
10639: EMPTY
10640: LIST
10641: LIST
10642: PUSH
10643: LD_INT 57
10645: PUSH
10646: LD_INT 75
10648: PUSH
10649: EMPTY
10650: LIST
10651: LIST
10652: PUSH
10653: LD_INT 75
10655: PUSH
10656: LD_INT 89
10658: PUSH
10659: EMPTY
10660: LIST
10661: LIST
10662: PUSH
10663: LD_INT 51
10665: PUSH
10666: LD_INT 45
10668: PUSH
10669: EMPTY
10670: LIST
10671: LIST
10672: PUSH
10673: LD_INT 95
10675: PUSH
10676: LD_INT 95
10678: PUSH
10679: EMPTY
10680: LIST
10681: LIST
10682: PUSH
10683: LD_INT 84
10685: PUSH
10686: LD_INT 77
10688: PUSH
10689: EMPTY
10690: LIST
10691: LIST
10692: PUSH
10693: LD_INT 101
10695: PUSH
10696: LD_INT 76
10698: PUSH
10699: EMPTY
10700: LIST
10701: LIST
10702: PUSH
10703: LD_INT 118
10705: PUSH
10706: LD_INT 81
10708: PUSH
10709: EMPTY
10710: LIST
10711: LIST
10712: PUSH
10713: LD_INT 139
10715: PUSH
10716: LD_INT 97
10718: PUSH
10719: EMPTY
10720: LIST
10721: LIST
10722: PUSH
10723: LD_INT 129
10725: PUSH
10726: LD_INT 114
10728: PUSH
10729: EMPTY
10730: LIST
10731: LIST
10732: PUSH
10733: LD_INT 154
10735: PUSH
10736: LD_INT 111
10738: PUSH
10739: EMPTY
10740: LIST
10741: LIST
10742: PUSH
10743: EMPTY
10744: LIST
10745: LIST
10746: LIST
10747: LIST
10748: LIST
10749: LIST
10750: LIST
10751: LIST
10752: LIST
10753: LIST
10754: LIST
10755: LIST
10756: ST_TO_ADDR
// base_captured := true ;
10757: LD_ADDR_EXP 6
10761: PUSH
10762: LD_INT 1
10764: ST_TO_ADDR
// DialogueOn ;
10765: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
10769: LD_EXP 21
10773: PPUSH
10774: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
10778: LD_EXP 21
10782: PPUSH
10783: LD_STRING D2-JMM-1
10785: PPUSH
10786: CALL_OW 88
// SayRadio ( Powell , D2-Pow-1 ) ;
10790: LD_EXP 30
10794: PPUSH
10795: LD_STRING D2-Pow-1
10797: PPUSH
10798: CALL_OW 94
// Say ( JMM , D2-JMM-2 ) ;
10802: LD_EXP 21
10806: PPUSH
10807: LD_STRING D2-JMM-2
10809: PPUSH
10810: CALL_OW 88
// SayRadio ( Powell , D2-Pow-2 ) ;
10814: LD_EXP 30
10818: PPUSH
10819: LD_STRING D2-Pow-2
10821: PPUSH
10822: CALL_OW 94
// Say ( JMM , D2-JMM-3 ) ;
10826: LD_EXP 21
10830: PPUSH
10831: LD_STRING D2-JMM-3
10833: PPUSH
10834: CALL_OW 88
// DialogueOff ;
10838: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
10842: LD_STRING M2
10844: PPUSH
10845: CALL_OW 337
// Wait ( 0 0$2 ) ;
10849: LD_INT 70
10851: PPUSH
10852: CALL_OW 67
// if IsOk ( Gary ) then
10856: LD_EXP 32
10860: PPUSH
10861: CALL_OW 302
10865: IFFALSE 10879
// Say ( Gary , D2a-Gary-1 ) ;
10867: LD_EXP 32
10871: PPUSH
10872: LD_STRING D2a-Gary-1
10874: PPUSH
10875: CALL_OW 88
// if IsOk ( Bobby ) then
10879: LD_EXP 24
10883: PPUSH
10884: CALL_OW 302
10888: IFFALSE 10902
// Say ( Bobby , D2a-Bobby-1 ) ;
10890: LD_EXP 24
10894: PPUSH
10895: LD_STRING D2a-Bobby-1
10897: PPUSH
10898: CALL_OW 88
// if IsOk ( Cyrus ) then
10902: LD_EXP 25
10906: PPUSH
10907: CALL_OW 302
10911: IFFALSE 10925
// Say ( Cyrus , D2a-Cyrus-1 ) ;
10913: LD_EXP 25
10917: PPUSH
10918: LD_STRING D2a-Cyrus-1
10920: PPUSH
10921: CALL_OW 88
// if IsOk ( Lisa ) then
10925: LD_EXP 22
10929: PPUSH
10930: CALL_OW 302
10934: IFFALSE 10948
// Say ( Lisa , D2a-Lisa-1 ) ;
10936: LD_EXP 22
10940: PPUSH
10941: LD_STRING D2a-Lisa-1
10943: PPUSH
10944: CALL_OW 88
// if IsOk ( Frank ) then
10948: LD_EXP 33
10952: PPUSH
10953: CALL_OW 302
10957: IFFALSE 10971
// Say ( Frank , D2a-Frank-1 ) ;
10959: LD_EXP 33
10963: PPUSH
10964: LD_STRING D2a-Frank-1
10966: PPUSH
10967: CALL_OW 88
// if IsOk ( Cornel ) then
10971: LD_EXP 31
10975: PPUSH
10976: CALL_OW 302
10980: IFFALSE 10994
// Say ( Cornel , D2a-Corn-1 ) ;
10982: LD_EXP 31
10986: PPUSH
10987: LD_STRING D2a-Corn-1
10989: PPUSH
10990: CALL_OW 88
// if IsOk ( Donaldson ) then
10994: LD_EXP 23
10998: PPUSH
10999: CALL_OW 302
11003: IFFALSE 11017
// Say ( Donaldson , D2a-Don-1 ) ;
11005: LD_EXP 23
11009: PPUSH
11010: LD_STRING D2a-Don-1
11012: PPUSH
11013: CALL_OW 88
// if IsOk ( Brown ) then
11017: LD_EXP 27
11021: PPUSH
11022: CALL_OW 302
11026: IFFALSE 11040
// Say ( Brown , D2a-Brown-1 ) ;
11028: LD_EXP 27
11032: PPUSH
11033: LD_STRING D2a-Brown-1
11035: PPUSH
11036: CALL_OW 88
// Wait ( 0 0$30 ) ;
11040: LD_INT 1050
11042: PPUSH
11043: CALL_OW 67
// if IsOk ( Frank ) then
11047: LD_EXP 33
11051: PPUSH
11052: CALL_OW 302
11056: IFFALSE 12036
// begin DialogueOn ;
11058: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Frank ] ) ;
11062: LD_EXP 21
11066: PUSH
11067: LD_EXP 33
11071: PUSH
11072: EMPTY
11073: LIST
11074: LIST
11075: PPUSH
11076: CALL_OW 87
// Say ( Frank , D3F-Frank-1 ) ;
11080: LD_EXP 33
11084: PPUSH
11085: LD_STRING D3F-Frank-1
11087: PPUSH
11088: CALL_OW 88
// Say ( JMM , D3F-JMM-1 ) ;
11092: LD_EXP 21
11096: PPUSH
11097: LD_STRING D3F-JMM-1
11099: PPUSH
11100: CALL_OW 88
// Say ( Frank , D3F-Frank-2 ) ;
11104: LD_EXP 33
11108: PPUSH
11109: LD_STRING D3F-Frank-2
11111: PPUSH
11112: CALL_OW 88
// case Query ( QFrank ) of 1 :
11116: LD_STRING QFrank
11118: PPUSH
11119: CALL_OW 97
11123: PUSH
11124: LD_INT 1
11126: DOUBLE
11127: EQUAL
11128: IFTRUE 11132
11130: GO 11155
11132: POP
// begin Say ( JMM , D3Fa-JMM-1 ) ;
11133: LD_EXP 21
11137: PPUSH
11138: LD_STRING D3Fa-JMM-1
11140: PPUSH
11141: CALL_OW 88
// us_scout := 1 ;
11145: LD_ADDR_EXP 8
11149: PUSH
11150: LD_INT 1
11152: ST_TO_ADDR
// end ; 2 :
11153: GO 11318
11155: LD_INT 2
11157: DOUBLE
11158: EQUAL
11159: IFTRUE 11163
11161: GO 11285
11163: POP
// begin Say ( JMM , D3Fb-JMM-1 ) ;
11164: LD_EXP 21
11168: PPUSH
11169: LD_STRING D3Fb-JMM-1
11171: PPUSH
11172: CALL_OW 88
// Say ( Frank , D3Fb-Frank-1 ) ;
11176: LD_EXP 33
11180: PPUSH
11181: LD_STRING D3Fb-Frank-1
11183: PPUSH
11184: CALL_OW 88
// case Query ( QFrank2 ) of 1 :
11188: LD_STRING QFrank2
11190: PPUSH
11191: CALL_OW 97
11195: PUSH
11196: LD_INT 1
11198: DOUBLE
11199: EQUAL
11200: IFTRUE 11204
11202: GO 11251
11204: POP
// begin us_scout := 2 ;
11205: LD_ADDR_EXP 8
11209: PUSH
11210: LD_INT 2
11212: ST_TO_ADDR
// Say ( JMM , D3Fba-JMM-1 ) ;
11213: LD_EXP 21
11217: PPUSH
11218: LD_STRING D3Fba-JMM-1
11220: PPUSH
11221: CALL_OW 88
// Say ( Frank , D3Fba-Frank-1 ) ;
11225: LD_EXP 33
11229: PPUSH
11230: LD_STRING D3Fba-Frank-1
11232: PPUSH
11233: CALL_OW 88
// Say ( JMM , D3Fba-JMM-2 ) ;
11237: LD_EXP 21
11241: PPUSH
11242: LD_STRING D3Fba-JMM-2
11244: PPUSH
11245: CALL_OW 88
// end ; 2 :
11249: GO 11283
11251: LD_INT 2
11253: DOUBLE
11254: EQUAL
11255: IFTRUE 11259
11257: GO 11282
11259: POP
// begin us_scout := 0 ;
11260: LD_ADDR_EXP 8
11264: PUSH
11265: LD_INT 0
11267: ST_TO_ADDR
// Say ( JMM , D3Fbb-JMM-1 ) ;
11268: LD_EXP 21
11272: PPUSH
11273: LD_STRING D3Fbb-JMM-1
11275: PPUSH
11276: CALL_OW 88
// end ; end ;
11280: GO 11283
11282: POP
// end ; 3 :
11283: GO 11318
11285: LD_INT 3
11287: DOUBLE
11288: EQUAL
11289: IFTRUE 11293
11291: GO 11317
11293: POP
// begin us_scout := - 1 ;
11294: LD_ADDR_EXP 8
11298: PUSH
11299: LD_INT 1
11301: NEG
11302: ST_TO_ADDR
// Say ( JMM , D3Fc-JMM-1 ) ;
11303: LD_EXP 21
11307: PPUSH
11308: LD_STRING D3Fc-JMM-1
11310: PPUSH
11311: CALL_OW 88
// end ; end ;
11315: GO 11318
11317: POP
// DialogueOff ;
11318: CALL_OW 7
// if us_scout in [ - 1 , 0 ] then
11322: LD_EXP 8
11326: PUSH
11327: LD_INT 1
11329: NEG
11330: PUSH
11331: LD_INT 0
11333: PUSH
11334: EMPTY
11335: LIST
11336: LIST
11337: IN
11338: IFFALSE 11342
// exit ;
11340: GO 12970
// if us_scout in [ 1 , 2 ] then
11342: LD_EXP 8
11346: PUSH
11347: LD_INT 1
11349: PUSH
11350: LD_INT 2
11352: PUSH
11353: EMPTY
11354: LIST
11355: LIST
11356: IN
11357: IFFALSE 12036
// begin if IsInUnit ( Frank ) then
11359: LD_EXP 33
11363: PPUSH
11364: CALL_OW 310
11368: IFFALSE 11379
// ComExit ( Frank ) ;
11370: LD_EXP 33
11374: PPUSH
11375: CALL 87205 0 1
// SetSide ( Frank , 4 ) ;
11379: LD_EXP 33
11383: PPUSH
11384: LD_INT 4
11386: PPUSH
11387: CALL_OW 235
// wait ( 0 0$1 ) ;
11391: LD_INT 35
11393: PPUSH
11394: CALL_OW 67
// if us_scout = 2 then
11398: LD_EXP 8
11402: PUSH
11403: LD_INT 2
11405: EQUAL
11406: IFFALSE 11774
// begin ComMoveXY ( Frank , 75 , 63 ) ;
11408: LD_EXP 33
11412: PPUSH
11413: LD_INT 75
11415: PPUSH
11416: LD_INT 63
11418: PPUSH
11419: CALL_OW 111
// AddComHold ( Frank ) ;
11423: LD_EXP 33
11427: PPUSH
11428: CALL_OW 200
// AddComWait ( Frank , 0 0$22 ) ;
11432: LD_EXP 33
11436: PPUSH
11437: LD_INT 770
11439: PPUSH
11440: CALL_OW 202
// AddComMoveXY ( Frank , 100 , 75 ) ;
11444: LD_EXP 33
11448: PPUSH
11449: LD_INT 100
11451: PPUSH
11452: LD_INT 75
11454: PPUSH
11455: CALL_OW 171
// AddComMoveXY ( Frank , 123 , 103 ) ;
11459: LD_EXP 33
11463: PPUSH
11464: LD_INT 123
11466: PPUSH
11467: LD_INT 103
11469: PPUSH
11470: CALL_OW 171
// AddComMoveXY ( Frank , 138 , 108 ) ;
11474: LD_EXP 33
11478: PPUSH
11479: LD_INT 138
11481: PPUSH
11482: LD_INT 108
11484: PPUSH
11485: CALL_OW 171
// AddComHold ( Frank ) ;
11489: LD_EXP 33
11493: PPUSH
11494: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
11498: LD_INT 35
11500: PPUSH
11501: CALL_OW 67
// until IsAt ( Frank , 138 , 108 ) ;
11505: LD_EXP 33
11509: PPUSH
11510: LD_INT 138
11512: PPUSH
11513: LD_INT 108
11515: PPUSH
11516: CALL_OW 307
11520: IFFALSE 11498
// AddComMoveXY ( Frank , 125 , 132 ) ;
11522: LD_EXP 33
11526: PPUSH
11527: LD_INT 125
11529: PPUSH
11530: LD_INT 132
11532: PPUSH
11533: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11537: LD_INT 35
11539: PPUSH
11540: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 7 ;
11544: LD_INT 1
11546: PPUSH
11547: LD_EXP 33
11551: PPUSH
11552: CALL_OW 292
11556: PUSH
11557: LD_EXP 33
11561: PPUSH
11562: LD_INT 7
11564: PPUSH
11565: CALL_OW 296
11569: PUSH
11570: LD_INT 7
11572: LESS
11573: OR
11574: IFFALSE 11537
// DialogueOn ;
11576: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11580: LD_EXP 33
11584: PPUSH
11585: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
11589: LD_INT 10
11591: PPUSH
11592: CALL_OW 68
// Say ( JMM , D4Fa-JMM-1 ) ;
11596: LD_EXP 21
11600: PPUSH
11601: LD_STRING D4Fa-JMM-1
11603: PPUSH
11604: CALL_OW 88
// for i in points do
11608: LD_ADDR_VAR 0 1
11612: PUSH
11613: LD_VAR 0 2
11617: PUSH
11618: FOR_IN
11619: IFFALSE 11677
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
11621: LD_VAR 0 1
11625: PUSH
11626: LD_INT 1
11628: ARRAY
11629: PPUSH
11630: LD_VAR 0 1
11634: PUSH
11635: LD_INT 2
11637: ARRAY
11638: PPUSH
11639: LD_INT 1
11641: PPUSH
11642: LD_INT 20
11644: NEG
11645: PPUSH
11646: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
11650: LD_VAR 0 1
11654: PUSH
11655: LD_INT 1
11657: ARRAY
11658: PPUSH
11659: LD_VAR 0 1
11663: PUSH
11664: LD_INT 2
11666: ARRAY
11667: PPUSH
11668: LD_INT 1
11670: PPUSH
11671: CALL_OW 331
// end ;
11675: GO 11618
11677: POP
11678: POP
// dwait ( 0 0$0.5 ) ;
11679: LD_INT 18
11681: PPUSH
11682: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
11686: LD_INT 42
11688: PPUSH
11689: LD_INT 27
11691: PPUSH
11692: CALL_OW 84
// Say ( Frank , D4Fa-Frank-1 ) ;
11696: LD_EXP 33
11700: PPUSH
11701: LD_STRING D4Fa-Frank-1
11703: PPUSH
11704: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
11708: LD_INT 18
11710: PPUSH
11711: CALL_OW 68
// Say ( JMM , D4Fa-JMM-2 ) ;
11715: LD_EXP 21
11719: PPUSH
11720: LD_STRING D4Fa-JMM-2
11722: PPUSH
11723: CALL_OW 88
// CenterNowOnXY ( 118 , 80 ) ;
11727: LD_INT 118
11729: PPUSH
11730: LD_INT 80
11732: PPUSH
11733: CALL_OW 86
// Say ( Frank , D4Fa-Frank-2 ) ;
11737: LD_EXP 33
11741: PPUSH
11742: LD_STRING D4Fa-Frank-2
11744: PPUSH
11745: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
11749: LD_INT 10
11751: PPUSH
11752: CALL_OW 68
// DialogueOff ;
11756: CALL_OW 7
// SetSide ( Frank , 1 ) ;
11760: LD_EXP 33
11764: PPUSH
11765: LD_INT 1
11767: PPUSH
11768: CALL_OW 235
// end else
11772: GO 12036
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
11774: LD_INT 2
11776: PPUSH
11777: LD_INT 4
11779: PPUSH
11780: LD_INT 2
11782: PPUSH
11783: LD_INT 1
11785: PPUSH
11786: CALL_OW 80
// ComMoveXY ( Frank , 75 , 63 ) ;
11790: LD_EXP 33
11794: PPUSH
11795: LD_INT 75
11797: PPUSH
11798: LD_INT 63
11800: PPUSH
11801: CALL_OW 111
// AddComWait ( Frank , 0 0$5 ) ;
11805: LD_EXP 33
11809: PPUSH
11810: LD_INT 175
11812: PPUSH
11813: CALL_OW 202
// AddComMoveXY ( Frank , 102 , 76 ) ;
11817: LD_EXP 33
11821: PPUSH
11822: LD_INT 102
11824: PPUSH
11825: LD_INT 76
11827: PPUSH
11828: CALL_OW 171
// AddComMoveXY ( Frank , 108 , 70 ) ;
11832: LD_EXP 33
11836: PPUSH
11837: LD_INT 108
11839: PPUSH
11840: LD_INT 70
11842: PPUSH
11843: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11847: LD_INT 35
11849: PPUSH
11850: CALL_OW 67
// until See ( 2 , Frank ) ;
11854: LD_INT 2
11856: PPUSH
11857: LD_EXP 33
11861: PPUSH
11862: CALL_OW 292
11866: IFFALSE 11847
// ComMoveXY ( Frank , 112 , 118 ) ;
11868: LD_EXP 33
11872: PPUSH
11873: LD_INT 112
11875: PPUSH
11876: LD_INT 118
11878: PPUSH
11879: CALL_OW 111
// if GetLives ( Frank ) >= 750 then
11883: LD_EXP 33
11887: PPUSH
11888: CALL_OW 256
11892: PUSH
11893: LD_INT 750
11895: GREATEREQUAL
11896: IFFALSE 11910
// SetLives ( Frank , 700 ) ;
11898: LD_EXP 33
11902: PPUSH
11903: LD_INT 700
11905: PPUSH
11906: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
11910: LD_INT 35
11912: PPUSH
11913: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 17 ;
11917: LD_INT 1
11919: PPUSH
11920: LD_EXP 33
11924: PPUSH
11925: CALL_OW 292
11929: PUSH
11930: LD_EXP 33
11934: PPUSH
11935: LD_INT 7
11937: PPUSH
11938: CALL_OW 296
11942: PUSH
11943: LD_INT 17
11945: LESS
11946: OR
11947: IFFALSE 11910
// DialogueOn ;
11949: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11953: LD_EXP 33
11957: PPUSH
11958: CALL_OW 87
// Say ( Frank , D4Fb-Frank-1 ) ;
11962: LD_EXP 33
11966: PPUSH
11967: LD_STRING D4Fb-Frank-1
11969: PPUSH
11970: CALL_OW 88
// Say ( JMM , D4Fb-JMM-1 ) ;
11974: LD_EXP 21
11978: PPUSH
11979: LD_STRING D4Fb-JMM-1
11981: PPUSH
11982: CALL_OW 88
// SayRand ( sex_female , D4Fb-FSci1-1 ) ;
11986: LD_INT 2
11988: PPUSH
11989: LD_STRING D4Fb-FSci1-1
11991: PPUSH
11992: CALL 16947 0 2
// Say ( Frank , D4Fb-Frank-2 ) ;
11996: LD_EXP 33
12000: PPUSH
12001: LD_STRING D4Fb-Frank-2
12003: PPUSH
12004: CALL_OW 88
// Say ( JMM , D4Fb-JMM-2 ) ;
12008: LD_EXP 21
12012: PPUSH
12013: LD_STRING D4Fb-JMM-2
12015: PPUSH
12016: CALL_OW 88
// DialogueOff ;
12020: CALL_OW 7
// SetSide ( Frank , 1 ) ;
12024: LD_EXP 33
12028: PPUSH
12029: LD_INT 1
12031: PPUSH
12032: CALL_OW 235
// end ; end ; end ; if IsOk ( Kikuchi ) and not IsOk ( Frank ) then
12036: LD_EXP 34
12040: PPUSH
12041: CALL_OW 302
12045: PUSH
12046: LD_EXP 33
12050: PPUSH
12051: CALL_OW 302
12055: NOT
12056: AND
12057: IFFALSE 12970
// begin DialogueOn ;
12059: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Kikuchi ] ) ;
12063: LD_EXP 21
12067: PUSH
12068: LD_EXP 34
12072: PUSH
12073: EMPTY
12074: LIST
12075: LIST
12076: PPUSH
12077: CALL_OW 87
// Say ( Kikuchi , D3Y-Yam-1 ) ;
12081: LD_EXP 34
12085: PPUSH
12086: LD_STRING D3Y-Yam-1
12088: PPUSH
12089: CALL_OW 88
// Say ( JMM , D3Y-JMM-1 ) ;
12093: LD_EXP 21
12097: PPUSH
12098: LD_STRING D3Y-JMM-1
12100: PPUSH
12101: CALL_OW 88
// Say ( Kikuchi , D3Y-Yam-2 ) ;
12105: LD_EXP 34
12109: PPUSH
12110: LD_STRING D3Y-Yam-2
12112: PPUSH
12113: CALL_OW 88
// case Query ( QYamoko ) of 1 :
12117: LD_STRING QYamoko
12119: PPUSH
12120: CALL_OW 97
12124: PUSH
12125: LD_INT 1
12127: DOUBLE
12128: EQUAL
12129: IFTRUE 12133
12131: GO 12168
12133: POP
// begin Say ( JMM , D3Ya-JMM-1 ) ;
12134: LD_EXP 21
12138: PPUSH
12139: LD_STRING D3Ya-JMM-1
12141: PPUSH
12142: CALL_OW 88
// Say ( Kikuchi , D3Ya-Yam-1 ) ;
12146: LD_EXP 34
12150: PPUSH
12151: LD_STRING D3Ya-Yam-1
12153: PPUSH
12154: CALL_OW 88
// us_scout := 1 ;
12158: LD_ADDR_EXP 8
12162: PUSH
12163: LD_INT 1
12165: ST_TO_ADDR
// end ; 2 :
12166: GO 12201
12168: LD_INT 2
12170: DOUBLE
12171: EQUAL
12172: IFTRUE 12176
12174: GO 12200
12176: POP
// begin us_scout := - 1 ;
12177: LD_ADDR_EXP 8
12181: PUSH
12182: LD_INT 1
12184: NEG
12185: ST_TO_ADDR
// Say ( JMM , D3Yb-JMM-1 ) ;
12186: LD_EXP 21
12190: PPUSH
12191: LD_STRING D3Yb-JMM-1
12193: PPUSH
12194: CALL_OW 88
// end ; end ;
12198: GO 12201
12200: POP
// DialogueOff ;
12201: CALL_OW 7
// if us_scout in [ - 1 , 0 ] then
12205: LD_EXP 8
12209: PUSH
12210: LD_INT 1
12212: NEG
12213: PUSH
12214: LD_INT 0
12216: PUSH
12217: EMPTY
12218: LIST
12219: LIST
12220: IN
12221: IFFALSE 12225
// exit ;
12223: GO 12970
// us_scout := [ 2 , 2 , 1 , 1 ] [ Difficulty ] ;
12225: LD_ADDR_EXP 8
12229: PUSH
12230: LD_INT 2
12232: PUSH
12233: LD_INT 2
12235: PUSH
12236: LD_INT 1
12238: PUSH
12239: LD_INT 1
12241: PUSH
12242: EMPTY
12243: LIST
12244: LIST
12245: LIST
12246: LIST
12247: PUSH
12248: LD_OWVAR 67
12252: ARRAY
12253: ST_TO_ADDR
// if us_scout in [ 1 , 2 ] then
12254: LD_EXP 8
12258: PUSH
12259: LD_INT 1
12261: PUSH
12262: LD_INT 2
12264: PUSH
12265: EMPTY
12266: LIST
12267: LIST
12268: IN
12269: IFFALSE 12970
// begin if IsInUnit ( Kikuchi ) then
12271: LD_EXP 34
12275: PPUSH
12276: CALL_OW 310
12280: IFFALSE 12291
// ComExitBuilding ( Kikuchi ) ;
12282: LD_EXP 34
12286: PPUSH
12287: CALL_OW 122
// if IsDrivenBy ( Kikuchi ) then
12291: LD_EXP 34
12295: PPUSH
12296: CALL_OW 311
12300: IFFALSE 12311
// ComExitVehicle ( Kikuchi ) ;
12302: LD_EXP 34
12306: PPUSH
12307: CALL_OW 121
// SetSide ( Kikuchi , 4 ) ;
12311: LD_EXP 34
12315: PPUSH
12316: LD_INT 4
12318: PPUSH
12319: CALL_OW 235
// wait ( 0 0$1 ) ;
12323: LD_INT 35
12325: PPUSH
12326: CALL_OW 67
// if us_scout = 2 then
12330: LD_EXP 8
12334: PUSH
12335: LD_INT 2
12337: EQUAL
12338: IFFALSE 12718
// begin ComMoveXY ( Kikuchi , 75 , 63 ) ;
12340: LD_EXP 34
12344: PPUSH
12345: LD_INT 75
12347: PPUSH
12348: LD_INT 63
12350: PPUSH
12351: CALL_OW 111
// AddComHold ( Kikuchi ) ;
12355: LD_EXP 34
12359: PPUSH
12360: CALL_OW 200
// AddComWait ( Kikuchi , 0 0$22 ) ;
12364: LD_EXP 34
12368: PPUSH
12369: LD_INT 770
12371: PPUSH
12372: CALL_OW 202
// AddComMoveXY ( Kikuchi , 100 , 75 ) ;
12376: LD_EXP 34
12380: PPUSH
12381: LD_INT 100
12383: PPUSH
12384: LD_INT 75
12386: PPUSH
12387: CALL_OW 171
// AddComMoveXY ( Kikuchi , 123 , 103 ) ;
12391: LD_EXP 34
12395: PPUSH
12396: LD_INT 123
12398: PPUSH
12399: LD_INT 103
12401: PPUSH
12402: CALL_OW 171
// AddComMoveXY ( Kikuchi , 138 , 108 ) ;
12406: LD_EXP 34
12410: PPUSH
12411: LD_INT 138
12413: PPUSH
12414: LD_INT 108
12416: PPUSH
12417: CALL_OW 171
// AddComHold ( Kikuchi ) ;
12421: LD_EXP 34
12425: PPUSH
12426: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
12430: LD_INT 35
12432: PPUSH
12433: CALL_OW 67
// until IsAt ( Kikuchi , 138 , 108 ) ;
12437: LD_EXP 34
12441: PPUSH
12442: LD_INT 138
12444: PPUSH
12445: LD_INT 108
12447: PPUSH
12448: CALL_OW 307
12452: IFFALSE 12430
// AddComMoveXY ( Kikuchi , 125 , 132 ) ;
12454: LD_EXP 34
12458: PPUSH
12459: LD_INT 125
12461: PPUSH
12462: LD_INT 132
12464: PPUSH
12465: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12469: LD_INT 35
12471: PPUSH
12472: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 7 ;
12476: LD_INT 1
12478: PPUSH
12479: LD_EXP 34
12483: PPUSH
12484: CALL_OW 292
12488: PUSH
12489: LD_EXP 34
12493: PPUSH
12494: LD_INT 7
12496: PPUSH
12497: CALL_OW 296
12501: PUSH
12502: LD_INT 7
12504: LESS
12505: OR
12506: IFFALSE 12469
// DialogueOn ;
12508: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12512: LD_EXP 34
12516: PPUSH
12517: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12521: LD_INT 10
12523: PPUSH
12524: CALL_OW 68
// Say ( Kikuchi , D4Ya-Yam-1 ) ;
12528: LD_EXP 34
12532: PPUSH
12533: LD_STRING D4Ya-Yam-1
12535: PPUSH
12536: CALL_OW 88
// Say ( JMM , D4Ya-JMM-1 ) ;
12540: LD_EXP 21
12544: PPUSH
12545: LD_STRING D4Ya-JMM-1
12547: PPUSH
12548: CALL_OW 88
// for i in points do
12552: LD_ADDR_VAR 0 1
12556: PUSH
12557: LD_VAR 0 2
12561: PUSH
12562: FOR_IN
12563: IFFALSE 12621
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
12565: LD_VAR 0 1
12569: PUSH
12570: LD_INT 1
12572: ARRAY
12573: PPUSH
12574: LD_VAR 0 1
12578: PUSH
12579: LD_INT 2
12581: ARRAY
12582: PPUSH
12583: LD_INT 1
12585: PPUSH
12586: LD_INT 20
12588: NEG
12589: PPUSH
12590: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
12594: LD_VAR 0 1
12598: PUSH
12599: LD_INT 1
12601: ARRAY
12602: PPUSH
12603: LD_VAR 0 1
12607: PUSH
12608: LD_INT 2
12610: ARRAY
12611: PPUSH
12612: LD_INT 1
12614: PPUSH
12615: CALL_OW 331
// end ;
12619: GO 12562
12621: POP
12622: POP
// dwait ( 0 0$0.5 ) ;
12623: LD_INT 18
12625: PPUSH
12626: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
12630: LD_INT 42
12632: PPUSH
12633: LD_INT 27
12635: PPUSH
12636: CALL_OW 84
// Say ( Kikuchi , D4Ya-Yam-2 ) ;
12640: LD_EXP 34
12644: PPUSH
12645: LD_STRING D4Ya-Yam-2
12647: PPUSH
12648: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
12652: LD_INT 18
12654: PPUSH
12655: CALL_OW 68
// CenterNowOnXY ( 118 , 80 ) ;
12659: LD_INT 118
12661: PPUSH
12662: LD_INT 80
12664: PPUSH
12665: CALL_OW 86
// Say ( JMM , D4Ya-JMM-2 ) ;
12669: LD_EXP 21
12673: PPUSH
12674: LD_STRING D4Ya-JMM-2
12676: PPUSH
12677: CALL_OW 88
// Say ( Kikuchi , D4Ya-Yam-3 ) ;
12681: LD_EXP 34
12685: PPUSH
12686: LD_STRING D4Ya-Yam-3
12688: PPUSH
12689: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
12693: LD_INT 10
12695: PPUSH
12696: CALL_OW 68
// DialogueOff ;
12700: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12704: LD_EXP 34
12708: PPUSH
12709: LD_INT 1
12711: PPUSH
12712: CALL_OW 235
// end else
12716: GO 12970
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
12718: LD_INT 2
12720: PPUSH
12721: LD_INT 4
12723: PPUSH
12724: LD_INT 2
12726: PPUSH
12727: LD_INT 1
12729: PPUSH
12730: CALL_OW 80
// ComMoveXY ( Kikuchi , 75 , 63 ) ;
12734: LD_EXP 34
12738: PPUSH
12739: LD_INT 75
12741: PPUSH
12742: LD_INT 63
12744: PPUSH
12745: CALL_OW 111
// AddComWait ( Kikuchi , 0 0$5 ) ;
12749: LD_EXP 34
12753: PPUSH
12754: LD_INT 175
12756: PPUSH
12757: CALL_OW 202
// AddComMoveXY ( Kikuchi , 102 , 76 ) ;
12761: LD_EXP 34
12765: PPUSH
12766: LD_INT 102
12768: PPUSH
12769: LD_INT 76
12771: PPUSH
12772: CALL_OW 171
// AddComMoveXY ( Kikuchi , 108 , 70 ) ;
12776: LD_EXP 34
12780: PPUSH
12781: LD_INT 108
12783: PPUSH
12784: LD_INT 70
12786: PPUSH
12787: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12791: LD_INT 35
12793: PPUSH
12794: CALL_OW 67
// until See ( 2 , Kikuchi ) ;
12798: LD_INT 2
12800: PPUSH
12801: LD_EXP 34
12805: PPUSH
12806: CALL_OW 292
12810: IFFALSE 12791
// ComMoveXY ( Kikuchi , 112 , 118 ) ;
12812: LD_EXP 34
12816: PPUSH
12817: LD_INT 112
12819: PPUSH
12820: LD_INT 118
12822: PPUSH
12823: CALL_OW 111
// if GetLives ( Kikuchi ) >= 750 then
12827: LD_EXP 34
12831: PPUSH
12832: CALL_OW 256
12836: PUSH
12837: LD_INT 750
12839: GREATEREQUAL
12840: IFFALSE 12854
// SetLives ( Kikuchi , 700 ) ;
12842: LD_EXP 34
12846: PPUSH
12847: LD_INT 700
12849: PPUSH
12850: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
12854: LD_INT 35
12856: PPUSH
12857: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 17 ;
12861: LD_INT 1
12863: PPUSH
12864: LD_EXP 34
12868: PPUSH
12869: CALL_OW 292
12873: PUSH
12874: LD_EXP 34
12878: PPUSH
12879: LD_INT 7
12881: PPUSH
12882: CALL_OW 296
12886: PUSH
12887: LD_INT 17
12889: LESS
12890: OR
12891: IFFALSE 12854
// DialogueOn ;
12893: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12897: LD_EXP 34
12901: PPUSH
12902: CALL_OW 87
// Say ( Kikuchi , D4Yb-Yam-1 ) ;
12906: LD_EXP 34
12910: PPUSH
12911: LD_STRING D4Yb-Yam-1
12913: PPUSH
12914: CALL_OW 88
// Say ( JMM , D4Yb-JMM-1 ) ;
12918: LD_EXP 21
12922: PPUSH
12923: LD_STRING D4Yb-JMM-1
12925: PPUSH
12926: CALL_OW 88
// Say ( Kikuchi , D4Yb-Yam-2 ) ;
12930: LD_EXP 34
12934: PPUSH
12935: LD_STRING D4Yb-Yam-2
12937: PPUSH
12938: CALL_OW 88
// Say ( JMM , D4Yb-JMM-2 ) ;
12942: LD_EXP 21
12946: PPUSH
12947: LD_STRING D4Yb-JMM-2
12949: PPUSH
12950: CALL_OW 88
// DialogueOff ;
12954: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12958: LD_EXP 34
12962: PPUSH
12963: LD_INT 1
12965: PPUSH
12966: CALL_OW 235
// end ; end ; end ; end ;
12970: PPOPN 2
12972: END
// every 0 0$01 trigger base_captured do var i , tmp , un , un2 ;
12973: LD_EXP 6
12977: IFFALSE 14010
12979: GO 12981
12981: DISABLE
12982: LD_INT 0
12984: PPUSH
12985: PPUSH
12986: PPUSH
12987: PPUSH
// begin enable ;
12988: ENABLE
// if not seen [ 1 ] then
12989: LD_EXP 9
12993: PUSH
12994: LD_INT 1
12996: ARRAY
12997: NOT
12998: IFFALSE 13178
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 11 ] , [ f_control , control_rider ] ] ] ) ;
13000: LD_ADDR_VAR 0 2
13004: PUSH
13005: LD_INT 22
13007: PUSH
13008: LD_INT 2
13010: PUSH
13011: EMPTY
13012: LIST
13013: LIST
13014: PUSH
13015: LD_INT 2
13017: PUSH
13018: LD_INT 25
13020: PUSH
13021: LD_INT 11
13023: PUSH
13024: EMPTY
13025: LIST
13026: LIST
13027: PUSH
13028: LD_INT 33
13030: PUSH
13031: LD_INT 4
13033: PUSH
13034: EMPTY
13035: LIST
13036: LIST
13037: PUSH
13038: EMPTY
13039: LIST
13040: LIST
13041: LIST
13042: PUSH
13043: EMPTY
13044: LIST
13045: LIST
13046: PPUSH
13047: CALL_OW 69
13051: ST_TO_ADDR
// if tmp then
13052: LD_VAR 0 2
13056: IFFALSE 13178
// for i in tmp do
13058: LD_ADDR_VAR 0 1
13062: PUSH
13063: LD_VAR 0 2
13067: PUSH
13068: FOR_IN
13069: IFFALSE 13176
// if See ( 1 , i ) then
13071: LD_INT 1
13073: PPUSH
13074: LD_VAR 0 1
13078: PPUSH
13079: CALL_OW 292
13083: IFFALSE 13174
// begin seen := Replace ( seen , 1 , true ) ;
13085: LD_ADDR_EXP 9
13089: PUSH
13090: LD_EXP 9
13094: PPUSH
13095: LD_INT 1
13097: PPUSH
13098: LD_INT 1
13100: PPUSH
13101: CALL_OW 1
13105: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13106: LD_INT 1
13108: PPUSH
13109: CALL 16769 0 1
13113: IFFALSE 13174
// begin DialogueOn ;
13115: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13119: LD_VAR 0 1
13123: PPUSH
13124: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13128: LD_INT 10
13130: PPUSH
13131: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol2-1 ) ;
13135: LD_ADDR_VAR 0 3
13139: PUSH
13140: LD_INT 1
13142: PPUSH
13143: LD_STRING D5a-Sol2-1
13145: PPUSH
13146: CALL 16947 0 2
13150: ST_TO_ADDR
// if not un then
13151: LD_VAR 0 3
13155: NOT
13156: IFFALSE 13168
// SayRand ( sex_female , D5a-FSol2-1 ) ;
13158: LD_INT 2
13160: PPUSH
13161: LD_STRING D5a-FSol2-1
13163: PPUSH
13164: CALL 16947 0 2
// DialogueOff ;
13168: CALL_OW 7
// break ;
13172: GO 13176
// end ; end ;
13174: GO 13068
13176: POP
13177: POP
// end ; if not seen [ 2 ] then
13178: LD_EXP 9
13182: PUSH
13183: LD_INT 2
13185: ARRAY
13186: NOT
13187: IFFALSE 13412
// begin can_kamikazed := true ;
13189: LD_ADDR_EXP 10
13193: PUSH
13194: LD_INT 1
13196: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 17 ] ] ) ;
13197: LD_ADDR_VAR 0 2
13201: PUSH
13202: LD_INT 22
13204: PUSH
13205: LD_INT 2
13207: PUSH
13208: EMPTY
13209: LIST
13210: LIST
13211: PUSH
13212: LD_INT 25
13214: PUSH
13215: LD_INT 17
13217: PUSH
13218: EMPTY
13219: LIST
13220: LIST
13221: PUSH
13222: EMPTY
13223: LIST
13224: LIST
13225: PPUSH
13226: CALL_OW 69
13230: ST_TO_ADDR
// if tmp then
13231: LD_VAR 0 2
13235: IFFALSE 13412
// for i in tmp do
13237: LD_ADDR_VAR 0 1
13241: PUSH
13242: LD_VAR 0 2
13246: PUSH
13247: FOR_IN
13248: IFFALSE 13410
// if See ( 1 , i ) then
13250: LD_INT 1
13252: PPUSH
13253: LD_VAR 0 1
13257: PPUSH
13258: CALL_OW 292
13262: IFFALSE 13408
// begin seen := Replace ( seen , 2 , true ) ;
13264: LD_ADDR_EXP 9
13268: PUSH
13269: LD_EXP 9
13273: PPUSH
13274: LD_INT 2
13276: PPUSH
13277: LD_INT 1
13279: PPUSH
13280: CALL_OW 1
13284: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13285: LD_INT 1
13287: PPUSH
13288: CALL 16769 0 1
13292: IFFALSE 13408
// begin DialogueOn ;
13294: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13298: LD_VAR 0 1
13302: PPUSH
13303: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13307: LD_INT 10
13309: PPUSH
13310: CALL_OW 68
// un := SayRand ( sex_male , D5b-Sol1-1 ) ;
13314: LD_ADDR_VAR 0 3
13318: PUSH
13319: LD_INT 1
13321: PPUSH
13322: LD_STRING D5b-Sol1-1
13324: PPUSH
13325: CALL 16947 0 2
13329: ST_TO_ADDR
// if not un then
13330: LD_VAR 0 3
13334: NOT
13335: IFFALSE 13353
// un := SayRand ( sex_female , D5b-FSol1-1 ) ;
13337: LD_ADDR_VAR 0 3
13341: PUSH
13342: LD_INT 2
13344: PPUSH
13345: LD_STRING D5b-FSol1-1
13347: PPUSH
13348: CALL 16947 0 2
13352: ST_TO_ADDR
// if un then
13353: LD_VAR 0 3
13357: IFFALSE 13402
// begin un2 := SayRand2 ( sex_male , D5b-Sol2-1 , un ) ;
13359: LD_ADDR_VAR 0 4
13363: PUSH
13364: LD_INT 1
13366: PPUSH
13367: LD_STRING D5b-Sol2-1
13369: PPUSH
13370: LD_VAR 0 3
13374: PPUSH
13375: CALL 17173 0 3
13379: ST_TO_ADDR
// if not un2 then
13380: LD_VAR 0 4
13384: NOT
13385: IFFALSE 13402
// SayRand2 ( sex_female , D5b-FSol2-1 , un ) ;
13387: LD_INT 2
13389: PPUSH
13390: LD_STRING D5b-FSol2-1
13392: PPUSH
13393: LD_VAR 0 3
13397: PPUSH
13398: CALL 17173 0 3
// end ; DialogueOff ;
13402: CALL_OW 7
// break ;
13406: GO 13410
// end ; end ;
13408: GO 13247
13410: POP
13411: POP
// end ; if not seen [ 3 ] then
13412: LD_EXP 9
13416: PUSH
13417: LD_INT 3
13419: ARRAY
13420: NOT
13421: IFFALSE 13595
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] ] ) ;
13423: LD_ADDR_VAR 0 2
13427: PUSH
13428: LD_INT 22
13430: PUSH
13431: LD_INT 2
13433: PUSH
13434: EMPTY
13435: LIST
13436: LIST
13437: PUSH
13438: LD_INT 33
13440: PUSH
13441: LD_INT 2
13443: PUSH
13444: EMPTY
13445: LIST
13446: LIST
13447: PUSH
13448: EMPTY
13449: LIST
13450: LIST
13451: PPUSH
13452: CALL_OW 69
13456: ST_TO_ADDR
// if tmp then
13457: LD_VAR 0 2
13461: IFFALSE 13595
// for i in tmp do
13463: LD_ADDR_VAR 0 1
13467: PUSH
13468: LD_VAR 0 2
13472: PUSH
13473: FOR_IN
13474: IFFALSE 13593
// if See ( 1 , i ) then
13476: LD_INT 1
13478: PPUSH
13479: LD_VAR 0 1
13483: PPUSH
13484: CALL_OW 292
13488: IFFALSE 13591
// begin seen := Replace ( seen , 3 , true ) ;
13490: LD_ADDR_EXP 9
13494: PUSH
13495: LD_EXP 9
13499: PPUSH
13500: LD_INT 3
13502: PPUSH
13503: LD_INT 1
13505: PPUSH
13506: CALL_OW 1
13510: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13511: LD_INT 1
13513: PPUSH
13514: CALL 16769 0 1
13518: IFFALSE 13591
// begin DialogueOn ;
13520: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13524: LD_VAR 0 1
13528: PPUSH
13529: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13533: LD_INT 10
13535: PPUSH
13536: CALL_OW 68
// un := SayRand ( sex_male , D8-Sol1-1 ) ;
13540: LD_ADDR_VAR 0 3
13544: PUSH
13545: LD_INT 1
13547: PPUSH
13548: LD_STRING D8-Sol1-1
13550: PPUSH
13551: CALL 16947 0 2
13555: ST_TO_ADDR
// if not un then
13556: LD_VAR 0 3
13560: NOT
13561: IFFALSE 13573
// SayRand ( sex_female , D8-FSol1-1 ) ;
13563: LD_INT 2
13565: PPUSH
13566: LD_STRING D8-FSol1-1
13568: PPUSH
13569: CALL 16947 0 2
// Say ( JMM , D8-JMM-1 ) ;
13573: LD_EXP 21
13577: PPUSH
13578: LD_STRING D8-JMM-1
13580: PPUSH
13581: CALL_OW 88
// DialogueOff ;
13585: CALL_OW 7
// break ;
13589: GO 13593
// end ; end ;
13591: GO 13473
13593: POP
13594: POP
// end ; if not seen [ 4 ] then
13595: LD_EXP 9
13599: PUSH
13600: LD_INT 4
13602: ARRAY
13603: NOT
13604: IFFALSE 13766
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] ] ) ;
13606: LD_ADDR_VAR 0 2
13610: PUSH
13611: LD_INT 22
13613: PUSH
13614: LD_INT 2
13616: PUSH
13617: EMPTY
13618: LIST
13619: LIST
13620: PUSH
13621: LD_INT 33
13623: PUSH
13624: LD_INT 5
13626: PUSH
13627: EMPTY
13628: LIST
13629: LIST
13630: PUSH
13631: EMPTY
13632: LIST
13633: LIST
13634: PPUSH
13635: CALL_OW 69
13639: ST_TO_ADDR
// if tmp then
13640: LD_VAR 0 2
13644: IFFALSE 13766
// for i in tmp do
13646: LD_ADDR_VAR 0 1
13650: PUSH
13651: LD_VAR 0 2
13655: PUSH
13656: FOR_IN
13657: IFFALSE 13764
// if See ( 1 , i ) then
13659: LD_INT 1
13661: PPUSH
13662: LD_VAR 0 1
13666: PPUSH
13667: CALL_OW 292
13671: IFFALSE 13762
// begin seen := Replace ( seen , 4 , true ) ;
13673: LD_ADDR_EXP 9
13677: PUSH
13678: LD_EXP 9
13682: PPUSH
13683: LD_INT 4
13685: PPUSH
13686: LD_INT 1
13688: PPUSH
13689: CALL_OW 1
13693: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13694: LD_INT 1
13696: PPUSH
13697: CALL 16769 0 1
13701: IFFALSE 13762
// begin DialogueOn ;
13703: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13707: LD_VAR 0 1
13711: PPUSH
13712: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13716: LD_INT 10
13718: PPUSH
13719: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol1-1 ) ;
13723: LD_ADDR_VAR 0 3
13727: PUSH
13728: LD_INT 1
13730: PPUSH
13731: LD_STRING D5a-Sol1-1
13733: PPUSH
13734: CALL 16947 0 2
13738: ST_TO_ADDR
// if not un then
13739: LD_VAR 0 3
13743: NOT
13744: IFFALSE 13756
// SayRand ( sex_female , D5a-FSol1-1 ) ;
13746: LD_INT 2
13748: PPUSH
13749: LD_STRING D5a-FSol1-1
13751: PPUSH
13752: CALL 16947 0 2
// DialogueOff ;
13756: CALL_OW 7
// break ;
13760: GO 13764
// end ; end ;
13762: GO 13656
13764: POP
13765: POP
// end ; if not seen [ 5 ] and seen [ 3 ] then
13766: LD_EXP 9
13770: PUSH
13771: LD_INT 5
13773: ARRAY
13774: NOT
13775: PUSH
13776: LD_EXP 9
13780: PUSH
13781: LD_INT 3
13783: ARRAY
13784: AND
13785: IFFALSE 13959
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) ;
13787: LD_ADDR_VAR 0 2
13791: PUSH
13792: LD_INT 22
13794: PUSH
13795: LD_INT 2
13797: PUSH
13798: EMPTY
13799: LIST
13800: LIST
13801: PUSH
13802: LD_INT 34
13804: PUSH
13805: LD_INT 31
13807: PUSH
13808: EMPTY
13809: LIST
13810: LIST
13811: PUSH
13812: EMPTY
13813: LIST
13814: LIST
13815: PPUSH
13816: CALL_OW 69
13820: ST_TO_ADDR
// if tmp then
13821: LD_VAR 0 2
13825: IFFALSE 13959
// for i in tmp do
13827: LD_ADDR_VAR 0 1
13831: PUSH
13832: LD_VAR 0 2
13836: PUSH
13837: FOR_IN
13838: IFFALSE 13957
// if See ( 1 , i ) then
13840: LD_INT 1
13842: PPUSH
13843: LD_VAR 0 1
13847: PPUSH
13848: CALL_OW 292
13852: IFFALSE 13955
// begin seen := Replace ( seen , 5 , true ) ;
13854: LD_ADDR_EXP 9
13858: PUSH
13859: LD_EXP 9
13863: PPUSH
13864: LD_INT 5
13866: PPUSH
13867: LD_INT 1
13869: PPUSH
13870: CALL_OW 1
13874: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13875: LD_INT 1
13877: PPUSH
13878: CALL 16769 0 1
13882: IFFALSE 13955
// begin DialogueOn ;
13884: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13888: LD_VAR 0 1
13892: PPUSH
13893: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13897: LD_INT 10
13899: PPUSH
13900: CALL_OW 68
// un := SayRand ( sex_male , D8a-Sol2-1 ) ;
13904: LD_ADDR_VAR 0 3
13908: PUSH
13909: LD_INT 1
13911: PPUSH
13912: LD_STRING D8a-Sol2-1
13914: PPUSH
13915: CALL 16947 0 2
13919: ST_TO_ADDR
// if not un then
13920: LD_VAR 0 3
13924: NOT
13925: IFFALSE 13937
// SayRand ( sex_female , D8a-FSol2-1 ) ;
13927: LD_INT 2
13929: PPUSH
13930: LD_STRING D8a-FSol2-1
13932: PPUSH
13933: CALL 16947 0 2
// Say ( JMM , D8a-JMM-1 ) ;
13937: LD_EXP 21
13941: PPUSH
13942: LD_STRING D8a-JMM-1
13944: PPUSH
13945: CALL_OW 88
// DialogueOff ;
13949: CALL_OW 7
// break ;
13953: GO 13957
// end ; end ;
13955: GO 13837
13957: POP
13958: POP
// end ; if seen [ 1 ] and seen [ 2 ] and seen [ 3 ] and seen [ 4 ] and seen [ 5 ] then
13959: LD_EXP 9
13963: PUSH
13964: LD_INT 1
13966: ARRAY
13967: PUSH
13968: LD_EXP 9
13972: PUSH
13973: LD_INT 2
13975: ARRAY
13976: AND
13977: PUSH
13978: LD_EXP 9
13982: PUSH
13983: LD_INT 3
13985: ARRAY
13986: AND
13987: PUSH
13988: LD_EXP 9
13992: PUSH
13993: LD_INT 4
13995: ARRAY
13996: AND
13997: PUSH
13998: LD_EXP 9
14002: PUSH
14003: LD_INT 5
14005: ARRAY
14006: AND
14007: IFFALSE 14010
// disable ;
14009: DISABLE
// end ;
14010: PPOPN 4
14012: END
// every 0 0$1 trigger can_kamikazed and kamikazed do var un ;
14013: LD_EXP 10
14017: PUSH
14018: LD_EXP 11
14022: AND
14023: IFFALSE 14221
14025: GO 14027
14027: DISABLE
14028: LD_INT 0
14030: PPUSH
// begin DialogueOn ;
14031: CALL_OW 6
// CenterNowOnUnits ( kamikazed ) ;
14035: LD_EXP 11
14039: PPUSH
14040: CALL_OW 87
// un := SayRand ( sex_male , D5c-Sol1-1 ) ;
14044: LD_ADDR_VAR 0 1
14048: PUSH
14049: LD_INT 1
14051: PPUSH
14052: LD_STRING D5c-Sol1-1
14054: PPUSH
14055: CALL 16947 0 2
14059: ST_TO_ADDR
// if not un then
14060: LD_VAR 0 1
14064: NOT
14065: IFFALSE 14083
// un := SayRand ( sex_female , D5c-FSol1-1 ) ;
14067: LD_ADDR_VAR 0 1
14071: PUSH
14072: LD_INT 2
14074: PPUSH
14075: LD_STRING D5c-FSol1-1
14077: PPUSH
14078: CALL 16947 0 2
14082: ST_TO_ADDR
// Say ( JMM , D5c-JMM-1 ) ;
14083: LD_EXP 21
14087: PPUSH
14088: LD_STRING D5c-JMM-1
14090: PPUSH
14091: CALL_OW 88
// if IsOk ( Lisa ) then
14095: LD_EXP 22
14099: PPUSH
14100: CALL_OW 302
14104: IFFALSE 14120
// Say ( Lisa , D5d-Lisa-1 ) else
14106: LD_EXP 22
14110: PPUSH
14111: LD_STRING D5d-Lisa-1
14113: PPUSH
14114: CALL_OW 88
14118: GO 14205
// if IsOk ( Cyrus ) then
14120: LD_EXP 25
14124: PPUSH
14125: CALL_OW 302
14129: IFFALSE 14145
// Say ( Cyrus , D5d-Cyrus-1 ) else
14131: LD_EXP 25
14135: PPUSH
14136: LD_STRING D5d-Cyrus-1
14138: PPUSH
14139: CALL_OW 88
14143: GO 14205
// if IsOk ( Gary ) then
14145: LD_EXP 32
14149: PPUSH
14150: CALL_OW 302
14154: IFFALSE 14170
// Say ( Gary , D5d-Gary-1 ) else
14156: LD_EXP 32
14160: PPUSH
14161: LD_STRING D5d-Gary-1
14163: PPUSH
14164: CALL_OW 88
14168: GO 14205
// if GetSex ( un ) = sex_male then
14170: LD_VAR 0 1
14174: PPUSH
14175: CALL_OW 258
14179: PUSH
14180: LD_INT 1
14182: EQUAL
14183: IFFALSE 14199
// Say ( un , D5d-Sol1-1 ) else
14185: LD_VAR 0 1
14189: PPUSH
14190: LD_STRING D5d-Sol1-1
14192: PPUSH
14193: CALL_OW 88
14197: GO 14205
// begin DialogueOff ;
14199: CALL_OW 7
// exit ;
14203: GO 14221
// end ; Say ( JMM , D5d-JMM-1 ) ;
14205: LD_EXP 21
14209: PPUSH
14210: LD_STRING D5d-JMM-1
14212: PPUSH
14213: CALL_OW 88
// DialogueOff ;
14217: CALL_OW 7
// end ;
14221: PPOPN 1
14223: END
// every 0 0$2 trigger SeeArea ( 1 , artifact_area ) >= 2 do var un ;
14224: LD_INT 1
14226: PPUSH
14227: LD_INT 17
14229: PPUSH
14230: CALL_OW 294
14234: PUSH
14235: LD_INT 2
14237: GREATEREQUAL
14238: IFFALSE 14370
14240: GO 14242
14242: DISABLE
14243: LD_INT 0
14245: PPUSH
// begin PlaceSeeing ( 10 , 5 , 1 , - 10 ) ;
14246: LD_INT 10
14248: PPUSH
14249: LD_INT 5
14251: PPUSH
14252: LD_INT 1
14254: PPUSH
14255: LD_INT 10
14257: NEG
14258: PPUSH
14259: CALL_OW 330
// RemoveSeeing ( 10 , 5 , 1 ) ;
14263: LD_INT 10
14265: PPUSH
14266: LD_INT 5
14268: PPUSH
14269: LD_INT 1
14271: PPUSH
14272: CALL_OW 331
// CenterNowOnXY ( 10 , 5 ) ;
14276: LD_INT 10
14278: PPUSH
14279: LD_INT 5
14281: PPUSH
14282: CALL_OW 86
// DialogueOn ;
14286: CALL_OW 6
// un := SayRand ( sex_male , D6-Sci1-1 ) ;
14290: LD_ADDR_VAR 0 1
14294: PUSH
14295: LD_INT 1
14297: PPUSH
14298: LD_STRING D6-Sci1-1
14300: PPUSH
14301: CALL 16947 0 2
14305: ST_TO_ADDR
// if un then
14306: LD_VAR 0 1
14310: IFFALSE 14348
// begin Say ( JMM , D6-JMM-1 ) ;
14312: LD_EXP 21
14316: PPUSH
14317: LD_STRING D6-JMM-1
14319: PPUSH
14320: CALL_OW 88
// Say ( un , D6-Sci1-2 ) ;
14324: LD_VAR 0 1
14328: PPUSH
14329: LD_STRING D6-Sci1-2
14331: PPUSH
14332: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
14336: LD_EXP 21
14340: PPUSH
14341: LD_STRING D6-JMM-2
14343: PPUSH
14344: CALL_OW 88
// end ; DialogueOff ;
14348: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
14352: LD_STRING M3
14354: PPUSH
14355: CALL_OW 337
// wait ( 0 0$30 ) ;
14359: LD_INT 1050
14361: PPUSH
14362: CALL_OW 67
// AmericanReinforcements ;
14366: CALL 2345 0 0
// end ;
14370: PPOPN 1
14372: END
// export ar_mechanic , ar_mechanic_friend ; every 0 0$20 trigger tick >= 20 20$00 and ( DangerAtRangeXY ( 2 , 169 , 90 , 10 ) [ 4 ] = 0 or IsDead ( ar_dep_w ) or GetSide ( ar_dep_w ) = 1 ) and not IsDead ( ar_dep_n ) do var un , i , cargo , tmp , escaped ;
14373: LD_OWVAR 1
14377: PUSH
14378: LD_INT 42000
14380: GREATEREQUAL
14381: PUSH
14382: LD_INT 2
14384: PPUSH
14385: LD_INT 169
14387: PPUSH
14388: LD_INT 90
14390: PPUSH
14391: LD_INT 10
14393: PPUSH
14394: CALL 55331 0 4
14398: PUSH
14399: LD_INT 4
14401: ARRAY
14402: PUSH
14403: LD_INT 0
14405: EQUAL
14406: PUSH
14407: LD_INT 45
14409: PPUSH
14410: CALL_OW 301
14414: OR
14415: PUSH
14416: LD_INT 45
14418: PPUSH
14419: CALL_OW 255
14423: PUSH
14424: LD_INT 1
14426: EQUAL
14427: OR
14428: AND
14429: PUSH
14430: LD_INT 94
14432: PPUSH
14433: CALL_OW 301
14437: NOT
14438: AND
14439: IFFALSE 15644
14441: GO 14443
14443: DISABLE
14444: LD_INT 0
14446: PPUSH
14447: PPUSH
14448: PPUSH
14449: PPUSH
14450: PPUSH
// begin uc_side := 5 ;
14451: LD_ADDR_OWVAR 20
14455: PUSH
14456: LD_INT 5
14458: ST_TO_ADDR
// uc_nation := 2 ;
14459: LD_ADDR_OWVAR 21
14463: PUSH
14464: LD_INT 2
14466: ST_TO_ADDR
// InitHc ;
14467: CALL_OW 19
// PrepareHuman ( sex_male , 3 , 8 ) ;
14471: LD_INT 1
14473: PPUSH
14474: LD_INT 3
14476: PPUSH
14477: LD_INT 8
14479: PPUSH
14480: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
14484: LD_ADDR_OWVAR 29
14488: PUSH
14489: LD_INT 12
14491: PUSH
14492: LD_INT 12
14494: PUSH
14495: EMPTY
14496: LIST
14497: LIST
14498: ST_TO_ADDR
// hc_name := Hans Fliege ;
14499: LD_ADDR_OWVAR 26
14503: PUSH
14504: LD_STRING Hans Fliege
14506: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
14507: LD_ADDR_OWVAR 33
14511: PUSH
14512: LD_STRING SecondCharsGal
14514: ST_TO_ADDR
// hc_face_number := 7 ;
14515: LD_ADDR_OWVAR 34
14519: PUSH
14520: LD_INT 7
14522: ST_TO_ADDR
// ar_mechanic := CreateHuman ;
14523: LD_ADDR_EXP 46
14527: PUSH
14528: CALL_OW 44
14532: ST_TO_ADDR
// InitHc ;
14533: CALL_OW 19
// PrepareHuman ( sex_male , 16 , 2 ) ;
14537: LD_INT 1
14539: PPUSH
14540: LD_INT 16
14542: PPUSH
14543: LD_INT 2
14545: PPUSH
14546: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
14550: LD_ADDR_OWVAR 29
14554: PUSH
14555: LD_INT 12
14557: PUSH
14558: LD_INT 12
14560: PUSH
14561: EMPTY
14562: LIST
14563: LIST
14564: ST_TO_ADDR
// hc_name :=  ;
14565: LD_ADDR_OWVAR 26
14569: PUSH
14570: LD_STRING 
14572: ST_TO_ADDR
// ar_mechanic_friend := CreateHuman ;
14573: LD_ADDR_EXP 47
14577: PUSH
14578: CALL_OW 44
14582: ST_TO_ADDR
// InitHc ;
14583: CALL_OW 19
// repeat wait ( 0 0$1 ) ;
14587: LD_INT 35
14589: PPUSH
14590: CALL_OW 67
// until not InBattle ( 1 ) ;
14594: LD_INT 1
14596: PPUSH
14597: CALL_OW 463
14601: NOT
14602: IFFALSE 14587
// wait ( 0 0$5 ) ;
14604: LD_INT 175
14606: PPUSH
14607: CALL_OW 67
// DialogueOn ;
14611: CALL_OW 6
// InGameOn ;
14615: CALL_OW 8
// un := UnitFilter ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , [ f_sex , sex_male ] ) [ 1 ] ;
14619: LD_ADDR_VAR 0 1
14623: PUSH
14624: LD_INT 22
14626: PUSH
14627: LD_INT 1
14629: PUSH
14630: EMPTY
14631: LIST
14632: LIST
14633: PUSH
14634: LD_INT 2
14636: PUSH
14637: LD_INT 25
14639: PUSH
14640: LD_INT 1
14642: PUSH
14643: EMPTY
14644: LIST
14645: LIST
14646: PUSH
14647: LD_INT 25
14649: PUSH
14650: LD_INT 2
14652: PUSH
14653: EMPTY
14654: LIST
14655: LIST
14656: PUSH
14657: LD_INT 25
14659: PUSH
14660: LD_INT 3
14662: PUSH
14663: EMPTY
14664: LIST
14665: LIST
14666: PUSH
14667: LD_INT 25
14669: PUSH
14670: LD_INT 4
14672: PUSH
14673: EMPTY
14674: LIST
14675: LIST
14676: PUSH
14677: LD_INT 25
14679: PUSH
14680: LD_INT 5
14682: PUSH
14683: EMPTY
14684: LIST
14685: LIST
14686: PUSH
14687: LD_INT 25
14689: PUSH
14690: LD_INT 8
14692: PUSH
14693: EMPTY
14694: LIST
14695: LIST
14696: PUSH
14697: EMPTY
14698: LIST
14699: LIST
14700: LIST
14701: LIST
14702: LIST
14703: LIST
14704: LIST
14705: PUSH
14706: EMPTY
14707: LIST
14708: LIST
14709: PPUSH
14710: CALL_OW 69
14714: PUSH
14715: LD_EXP 21
14719: PUSH
14720: LD_EXP 22
14724: PUSH
14725: LD_EXP 23
14729: PUSH
14730: LD_EXP 24
14734: PUSH
14735: LD_EXP 25
14739: PUSH
14740: LD_EXP 26
14744: PUSH
14745: LD_EXP 27
14749: PUSH
14750: LD_EXP 28
14754: PUSH
14755: LD_EXP 29
14759: PUSH
14760: LD_EXP 31
14764: PUSH
14765: LD_EXP 32
14769: PUSH
14770: LD_EXP 33
14774: PUSH
14775: LD_EXP 34
14779: PUSH
14780: EMPTY
14781: LIST
14782: LIST
14783: LIST
14784: LIST
14785: LIST
14786: LIST
14787: LIST
14788: LIST
14789: LIST
14790: LIST
14791: LIST
14792: LIST
14793: LIST
14794: DIFF
14795: PPUSH
14796: LD_INT 26
14798: PUSH
14799: LD_INT 1
14801: PUSH
14802: EMPTY
14803: LIST
14804: LIST
14805: PPUSH
14806: CALL_OW 72
14810: PUSH
14811: LD_INT 1
14813: ARRAY
14814: ST_TO_ADDR
// if Brown then
14815: LD_EXP 27
14819: IFFALSE 14831
// un := Brown ;
14821: LD_ADDR_VAR 0 1
14825: PUSH
14826: LD_EXP 27
14830: ST_TO_ADDR
// if un then
14831: LD_VAR 0 1
14835: IFFALSE 14861
// begin Say ( un , D7-Sol1-1 ) ;
14837: LD_VAR 0 1
14841: PPUSH
14842: LD_STRING D7-Sol1-1
14844: PPUSH
14845: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
14849: LD_EXP 21
14853: PPUSH
14854: LD_STRING D7-JMM-1
14856: PPUSH
14857: CALL_OW 88
// end ; SayRadio ( ar_mechanic , D7-Ar1-1 ) ;
14861: LD_EXP 46
14865: PPUSH
14866: LD_STRING D7-Ar1-1
14868: PPUSH
14869: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
14873: LD_EXP 21
14877: PPUSH
14878: LD_STRING D7-JMM-2
14880: PPUSH
14881: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-2 ) ;
14885: LD_EXP 46
14889: PPUSH
14890: LD_STRING D7-Ar1-2
14892: PPUSH
14893: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
14897: LD_EXP 21
14901: PPUSH
14902: LD_STRING D7-JMM-3
14904: PPUSH
14905: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-3 ) ;
14909: LD_EXP 46
14913: PPUSH
14914: LD_STRING D7-Ar1-3
14916: PPUSH
14917: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
14921: LD_EXP 21
14925: PPUSH
14926: LD_STRING D7-JMM-4
14928: PPUSH
14929: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-4 ) ;
14933: LD_EXP 46
14937: PPUSH
14938: LD_STRING D7-Ar1-4
14940: PPUSH
14941: CALL_OW 94
// InGameOff ;
14945: CALL_OW 9
// DialogueOff ;
14949: CALL_OW 7
// case Query ( QCameras ) of 1 :
14953: LD_STRING QCameras
14955: PPUSH
14956: CALL_OW 97
14960: PUSH
14961: LD_INT 1
14963: DOUBLE
14964: EQUAL
14965: IFTRUE 14969
14967: GO 14972
14969: POP
// ; 2 :
14970: GO 14986
14972: LD_INT 2
14974: DOUBLE
14975: EQUAL
14976: IFTRUE 14980
14978: GO 14985
14980: POP
// exit ; end ;
14981: GO 15644
14983: GO 14986
14985: POP
// ChangeMissionObjectives ( MCar ) ;
14986: LD_STRING MCar
14988: PPUSH
14989: CALL_OW 337
// PlaceSeeing ( 124 , 90 , 1 , - 6 ) ;
14993: LD_INT 124
14995: PPUSH
14996: LD_INT 90
14998: PPUSH
14999: LD_INT 1
15001: PPUSH
15002: LD_INT 6
15004: NEG
15005: PPUSH
15006: CALL_OW 330
// RemoveSeeing ( 124 , 90 , 1 ) ;
15010: LD_INT 124
15012: PPUSH
15013: LD_INT 90
15015: PPUSH
15016: LD_INT 1
15018: PPUSH
15019: CALL_OW 331
// SetAreaMapShow ( parking_marea , 1 ) ;
15023: LD_INT 12
15025: PPUSH
15026: LD_INT 1
15028: PPUSH
15029: CALL_OW 424
// wait ( 3 ) ;
15033: LD_INT 3
15035: PPUSH
15036: CALL_OW 67
// CenterNowOnXY ( 124 , 90 ) ;
15040: LD_INT 124
15042: PPUSH
15043: LD_INT 90
15045: PPUSH
15046: CALL_OW 86
// cargo := false ;
15050: LD_ADDR_VAR 0 3
15054: PUSH
15055: LD_INT 0
15057: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
15058: LD_INT 35
15060: PPUSH
15061: CALL_OW 67
// cargo := FilterUnitsInArea ( parking_marea , [ [ f_engine , engine_siberite ] , [ f_weapon , ar_cargo_bay ] , [ f_empty ] ] ) ;
15065: LD_ADDR_VAR 0 3
15069: PUSH
15070: LD_INT 12
15072: PPUSH
15073: LD_INT 32
15075: PUSH
15076: LD_INT 3
15078: PUSH
15079: EMPTY
15080: LIST
15081: LIST
15082: PUSH
15083: LD_INT 34
15085: PUSH
15086: LD_INT 32
15088: PUSH
15089: EMPTY
15090: LIST
15091: LIST
15092: PUSH
15093: LD_INT 58
15095: PUSH
15096: EMPTY
15097: LIST
15098: PUSH
15099: EMPTY
15100: LIST
15101: LIST
15102: LIST
15103: PPUSH
15104: CALL_OW 70
15108: ST_TO_ADDR
// until cargo ;
15109: LD_VAR 0 3
15113: IFFALSE 15058
// cargo := cargo [ 1 ] ;
15115: LD_ADDR_VAR 0 3
15119: PUSH
15120: LD_VAR 0 3
15124: PUSH
15125: LD_INT 1
15127: ARRAY
15128: ST_TO_ADDR
// SetSide ( cargo , 5 ) ;
15129: LD_VAR 0 3
15133: PPUSH
15134: LD_INT 5
15136: PPUSH
15137: CALL_OW 235
// SetAreaMapShow ( parking_marea , 0 ) ;
15141: LD_INT 12
15143: PPUSH
15144: LD_INT 0
15146: PPUSH
15147: CALL_OW 424
// PlaceUnitArea ( ar_mechanic , mechanic_spawn , false ) ;
15151: LD_EXP 46
15155: PPUSH
15156: LD_INT 11
15158: PPUSH
15159: LD_INT 0
15161: PPUSH
15162: CALL_OW 49
// PlaceUnitArea ( ar_mechanic_friend , mechanic_spawn , false ) ;
15166: LD_EXP 47
15170: PPUSH
15171: LD_INT 11
15173: PPUSH
15174: LD_INT 0
15176: PPUSH
15177: CALL_OW 49
// ComMoveToArea ( [ ar_mechanic , ar_mechanic_friend ] , parking_marea ) ;
15181: LD_EXP 46
15185: PUSH
15186: LD_EXP 47
15190: PUSH
15191: EMPTY
15192: LIST
15193: LIST
15194: PPUSH
15195: LD_INT 12
15197: PPUSH
15198: CALL_OW 113
// AddComEnterUnit ( ar_mechanic , cargo ) ;
15202: LD_EXP 46
15206: PPUSH
15207: LD_VAR 0 3
15211: PPUSH
15212: CALL_OW 180
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
15216: LD_EXP 46
15220: PUSH
15221: LD_EXP 47
15225: PUSH
15226: EMPTY
15227: LIST
15228: LIST
15229: PPUSH
15230: LD_INT 209
15232: PPUSH
15233: LD_INT 178
15235: PPUSH
15236: CALL_OW 171
// escaped := 0 ;
15240: LD_ADDR_VAR 0 5
15244: PUSH
15245: LD_INT 0
15247: ST_TO_ADDR
// while ( true ) do
15248: LD_INT 1
15250: IFFALSE 15466
// begin wait ( 0 0$1 ) ;
15252: LD_INT 35
15254: PPUSH
15255: CALL_OW 67
// if not HasTask ( ar_mechanic ) or not HasTask ( ar_mechanic_friend ) then
15259: LD_EXP 46
15263: PPUSH
15264: CALL_OW 314
15268: NOT
15269: PUSH
15270: LD_EXP 47
15274: PPUSH
15275: CALL_OW 314
15279: NOT
15280: OR
15281: IFFALSE 15307
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
15283: LD_EXP 46
15287: PUSH
15288: LD_EXP 47
15292: PUSH
15293: EMPTY
15294: LIST
15295: LIST
15296: PPUSH
15297: LD_INT 209
15299: PPUSH
15300: LD_INT 178
15302: PPUSH
15303: CALL_OW 171
// if IsInArea ( ar_mechanic , escape_area ) then
15307: LD_EXP 46
15311: PPUSH
15312: LD_INT 10
15314: PPUSH
15315: CALL_OW 308
15319: IFFALSE 15344
// begin RemoveUnit ( ar_mechanic ) ;
15321: LD_EXP 46
15325: PPUSH
15326: CALL_OW 64
// escaped := escaped + 1 ;
15330: LD_ADDR_VAR 0 5
15334: PUSH
15335: LD_VAR 0 5
15339: PUSH
15340: LD_INT 1
15342: PLUS
15343: ST_TO_ADDR
// end ; if IsInArea ( ar_mechanic_friend , escape_area ) then
15344: LD_EXP 47
15348: PPUSH
15349: LD_INT 10
15351: PPUSH
15352: CALL_OW 308
15356: IFFALSE 15381
// begin RemoveUnit ( ar_mechanic_friend ) ;
15358: LD_EXP 47
15362: PPUSH
15363: CALL_OW 64
// escaped := escaped + 1 ;
15367: LD_ADDR_VAR 0 5
15371: PUSH
15372: LD_VAR 0 5
15376: PUSH
15377: LD_INT 1
15379: PLUS
15380: ST_TO_ADDR
// end ; if IsInArea ( cargo , escape_area ) then
15381: LD_VAR 0 3
15385: PPUSH
15386: LD_INT 10
15388: PPUSH
15389: CALL_OW 308
15393: IFFALSE 15404
// RemoveUnit ( cargo ) ;
15395: LD_VAR 0 3
15399: PPUSH
15400: CALL_OW 64
// if not IsPlaced ( ar_mechanic ) and escaped >= 2 then
15404: LD_EXP 46
15408: PPUSH
15409: CALL_OW 305
15413: NOT
15414: PUSH
15415: LD_VAR 0 5
15419: PUSH
15420: LD_INT 2
15422: GREATEREQUAL
15423: AND
15424: IFFALSE 15428
// break ;
15426: GO 15466
// if not IsPlaced ( ar_mechanic ) and not IsPlaced ( ar_mechanic_friend ) and escaped < 2 then
15428: LD_EXP 46
15432: PPUSH
15433: CALL_OW 305
15437: NOT
15438: PUSH
15439: LD_EXP 47
15443: PPUSH
15444: CALL_OW 305
15448: NOT
15449: AND
15450: PUSH
15451: LD_VAR 0 5
15455: PUSH
15456: LD_INT 2
15458: LESS
15459: AND
15460: IFFALSE 15464
// exit ;
15462: GO 15644
// end ;
15464: GO 15248
// wait ( 0 0$2 ) ;
15466: LD_INT 70
15468: PPUSH
15469: CALL_OW 67
// SayRadio ( ar_mechanic , D7a-Ar1-1 ) ;
15473: LD_EXP 46
15477: PPUSH
15478: LD_STRING D7a-Ar1-1
15480: PPUSH
15481: CALL_OW 94
// tmp := [ [ 129 , 10 ] , [ 103 , 6 ] , [ 148 , 47 ] , [ 155 , 16 ] ] ;
15485: LD_ADDR_VAR 0 4
15489: PUSH
15490: LD_INT 129
15492: PUSH
15493: LD_INT 10
15495: PUSH
15496: EMPTY
15497: LIST
15498: LIST
15499: PUSH
15500: LD_INT 103
15502: PUSH
15503: LD_INT 6
15505: PUSH
15506: EMPTY
15507: LIST
15508: LIST
15509: PUSH
15510: LD_INT 148
15512: PUSH
15513: LD_INT 47
15515: PUSH
15516: EMPTY
15517: LIST
15518: LIST
15519: PUSH
15520: LD_INT 155
15522: PUSH
15523: LD_INT 16
15525: PUSH
15526: EMPTY
15527: LIST
15528: LIST
15529: PUSH
15530: EMPTY
15531: LIST
15532: LIST
15533: LIST
15534: LIST
15535: ST_TO_ADDR
// if Difficulty = 1 then
15536: LD_OWVAR 67
15540: PUSH
15541: LD_INT 1
15543: EQUAL
15544: IFFALSE 15581
// tmp := tmp ^ [ [ 78 , 7 ] , [ 104 , 43 ] ] ;
15546: LD_ADDR_VAR 0 4
15550: PUSH
15551: LD_VAR 0 4
15555: PUSH
15556: LD_INT 78
15558: PUSH
15559: LD_INT 7
15561: PUSH
15562: EMPTY
15563: LIST
15564: LIST
15565: PUSH
15566: LD_INT 104
15568: PUSH
15569: LD_INT 43
15571: PUSH
15572: EMPTY
15573: LIST
15574: LIST
15575: PUSH
15576: EMPTY
15577: LIST
15578: LIST
15579: ADD
15580: ST_TO_ADDR
// for i in tmp do
15581: LD_ADDR_VAR 0 2
15585: PUSH
15586: LD_VAR 0 4
15590: PUSH
15591: FOR_IN
15592: IFFALSE 15625
// PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 9 ) ;
15594: LD_VAR 0 2
15598: PUSH
15599: LD_INT 1
15601: ARRAY
15602: PPUSH
15603: LD_VAR 0 2
15607: PUSH
15608: LD_INT 2
15610: ARRAY
15611: PPUSH
15612: LD_INT 1
15614: PPUSH
15615: LD_INT 9
15617: NEG
15618: PPUSH
15619: CALL_OW 330
15623: GO 15591
15625: POP
15626: POP
// SetAchievement ( ACH_FRIEND ) ;
15627: LD_STRING ACH_FRIEND
15629: PPUSH
15630: CALL_OW 543
// CenterOnXY ( 129 , 10 ) ;
15634: LD_INT 129
15636: PPUSH
15637: LD_INT 10
15639: PPUSH
15640: CALL_OW 84
// end ;
15644: PPOPN 5
15646: END
// every 0 0$1 trigger game_time - 10 10$00 <= tick do
15647: LD_EXP 15
15651: PUSH
15652: LD_INT 21000
15654: MINUS
15655: PUSH
15656: LD_OWVAR 1
15660: LESSEQUAL
15661: IFFALSE 15701
15663: GO 15665
15665: DISABLE
// begin powell_warn := true ;
15666: LD_ADDR_EXP 16
15670: PUSH
15671: LD_INT 1
15673: ST_TO_ADDR
// DialogueOn ;
15674: CALL_OW 6
// SayRadio ( Powell , D9-Pow-1 ) ;
15678: LD_EXP 30
15682: PPUSH
15683: LD_STRING D9-Pow-1
15685: PPUSH
15686: CALL_OW 94
// dwait ( 0 0$0.3 ) ;
15690: LD_INT 10
15692: PPUSH
15693: CALL_OW 68
// DialogueOff ;
15697: CALL_OW 7
// end ;
15701: END
// every 0 0$1 trigger game_time <= tick do
15702: LD_EXP 15
15706: PUSH
15707: LD_OWVAR 1
15711: LESSEQUAL
15712: IFFALSE 15751
15714: GO 15716
15716: DISABLE
// begin DialogueOn ;
15717: CALL_OW 6
// SayRadio ( Powell , D9a-Pow-1 ) ;
15721: LD_EXP 30
15725: PPUSH
15726: LD_STRING D9a-Pow-1
15728: PPUSH
15729: CALL_OW 94
// dwait ( 0 0$2 ) ;
15733: LD_INT 70
15735: PPUSH
15736: CALL_OW 68
// DialogueOff ;
15740: CALL_OW 7
// YouLost ( Command ) ;
15744: LD_STRING Command
15746: PPUSH
15747: CALL_OW 104
// end ;
15751: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_warehouse ] ] ) = 0 and IsOk ( JMM ) do
15752: LD_INT 22
15754: PUSH
15755: LD_INT 2
15757: PUSH
15758: EMPTY
15759: LIST
15760: LIST
15761: PUSH
15762: LD_INT 30
15764: PUSH
15765: LD_INT 1
15767: PUSH
15768: EMPTY
15769: LIST
15770: LIST
15771: PUSH
15772: EMPTY
15773: LIST
15774: LIST
15775: PPUSH
15776: CALL_OW 69
15780: PUSH
15781: LD_INT 0
15783: EQUAL
15784: PUSH
15785: LD_EXP 21
15789: PPUSH
15790: CALL_OW 302
15794: AND
15795: IFFALSE 15843
15797: GO 15799
15799: DISABLE
// begin case Query ( QEndMission ) of 1 :
15800: LD_STRING QEndMission
15802: PPUSH
15803: CALL_OW 97
15807: PUSH
15808: LD_INT 1
15810: DOUBLE
15811: EQUAL
15812: IFTRUE 15816
15814: GO 15827
15816: POP
// end_the_mission_allowed := true ; 2 :
15817: LD_ADDR_OWVAR 57
15821: PUSH
15822: LD_INT 1
15824: ST_TO_ADDR
15825: GO 15843
15827: LD_INT 2
15829: DOUBLE
15830: EQUAL
15831: IFTRUE 15835
15833: GO 15842
15835: POP
// EndMission ; end ;
15836: CALL 15851 0 0
15840: GO 15843
15842: POP
// end ;
15843: END
// on EndTheMissionRaised ( p ) do begin EndMission ;
15844: CALL 15851 0 0
// end ;
15848: PPOPN 1
15850: END
// function EndMission ; var tmp , m1 , m2 , m3 ; begin
15851: LD_INT 0
15853: PPUSH
15854: PPUSH
15855: PPUSH
15856: PPUSH
15857: PPUSH
// m1 := false ;
15858: LD_ADDR_VAR 0 3
15862: PUSH
15863: LD_INT 0
15865: ST_TO_ADDR
// m2 := false ;
15866: LD_ADDR_VAR 0 4
15870: PUSH
15871: LD_INT 0
15873: ST_TO_ADDR
// m3 := false ;
15874: LD_ADDR_VAR 0 5
15878: PUSH
15879: LD_INT 0
15881: ST_TO_ADDR
// if not am_veh_consturcted then
15882: LD_EXP 20
15886: NOT
15887: IFFALSE 15896
// SetAchievement ( ACH_ARABTECH ) ;
15889: LD_STRING ACH_ARABTECH
15891: PPUSH
15892: CALL_OW 543
// if tick < [ 120 120$00 , 100 100$00 , 95 95$00 , 92 92$00 ] [ Difficulty ] then
15896: LD_OWVAR 1
15900: PUSH
15901: LD_INT 252000
15903: PUSH
15904: LD_INT 210000
15906: PUSH
15907: LD_INT 199500
15909: PUSH
15910: LD_INT 193200
15912: PUSH
15913: EMPTY
15914: LIST
15915: LIST
15916: LIST
15917: LIST
15918: PUSH
15919: LD_OWVAR 67
15923: ARRAY
15924: LESS
15925: IFFALSE 15947
// begin m3 := true ;
15927: LD_ADDR_VAR 0 5
15931: PUSH
15932: LD_INT 1
15934: ST_TO_ADDR
// AddMedal ( Time1 , 1 ) ;
15935: LD_STRING Time1
15937: PPUSH
15938: LD_INT 1
15940: PPUSH
15941: CALL_OW 101
// end else
15945: GO 15978
// if not powell_warn then
15947: LD_EXP 16
15951: NOT
15952: IFFALSE 15967
// AddMedal ( Time1 , - 1 ) else
15954: LD_STRING Time1
15956: PPUSH
15957: LD_INT 1
15959: NEG
15960: PPUSH
15961: CALL_OW 101
15965: GO 15978
// AddMedal ( Time1 , - 2 ) ;
15967: LD_STRING Time1
15969: PPUSH
15970: LD_INT 2
15972: NEG
15973: PPUSH
15974: CALL_OW 101
// if loses_counter >= [ 5 , 4 , 3 , 3 ] [ Difficulty ] then
15978: LD_EXP 17
15982: PUSH
15983: LD_INT 5
15985: PUSH
15986: LD_INT 4
15988: PUSH
15989: LD_INT 3
15991: PUSH
15992: LD_INT 3
15994: PUSH
15995: EMPTY
15996: LIST
15997: LIST
15998: LIST
15999: LIST
16000: PUSH
16001: LD_OWVAR 67
16005: ARRAY
16006: GREATEREQUAL
16007: IFFALSE 16022
// AddMedal ( Destroy , - 2 ) else
16009: LD_STRING Destroy
16011: PPUSH
16012: LD_INT 2
16014: NEG
16015: PPUSH
16016: CALL_OW 101
16020: GO 16155
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 25 then
16022: LD_INT 22
16024: PUSH
16025: LD_INT 2
16027: PUSH
16028: EMPTY
16029: LIST
16030: LIST
16031: PUSH
16032: LD_INT 21
16034: PUSH
16035: LD_INT 3
16037: PUSH
16038: EMPTY
16039: LIST
16040: LIST
16041: PUSH
16042: LD_INT 50
16044: PUSH
16045: EMPTY
16046: LIST
16047: PUSH
16048: EMPTY
16049: LIST
16050: LIST
16051: LIST
16052: PPUSH
16053: CALL_OW 69
16057: PUSH
16058: LD_INT 25
16060: GREATEREQUAL
16061: IFFALSE 16076
// AddMedal ( Destroy , - 1 ) else
16063: LD_STRING Destroy
16065: PPUSH
16066: LD_INT 1
16068: NEG
16069: PPUSH
16070: CALL_OW 101
16074: GO 16155
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 15 then
16076: LD_INT 22
16078: PUSH
16079: LD_INT 2
16081: PUSH
16082: EMPTY
16083: LIST
16084: LIST
16085: PUSH
16086: LD_INT 21
16088: PUSH
16089: LD_INT 3
16091: PUSH
16092: EMPTY
16093: LIST
16094: LIST
16095: PUSH
16096: LD_INT 50
16098: PUSH
16099: EMPTY
16100: LIST
16101: PUSH
16102: EMPTY
16103: LIST
16104: LIST
16105: LIST
16106: PPUSH
16107: CALL_OW 69
16111: PUSH
16112: LD_INT 15
16114: GREATEREQUAL
16115: IFFALSE 16137
// begin m1 := true ;
16117: LD_ADDR_VAR 0 3
16121: PUSH
16122: LD_INT 1
16124: ST_TO_ADDR
// AddMedal ( Destroy , 1 ) ;
16125: LD_STRING Destroy
16127: PPUSH
16128: LD_INT 1
16130: PPUSH
16131: CALL_OW 101
// end else
16135: GO 16155
// begin m1 := true ;
16137: LD_ADDR_VAR 0 3
16141: PUSH
16142: LD_INT 1
16144: ST_TO_ADDR
// AddMedal ( Destroy , 2 ) ;
16145: LD_STRING Destroy
16147: PPUSH
16148: LD_INT 2
16150: PPUSH
16151: CALL_OW 101
// end ; SaveVariable ( artifact_get , 11_artifact_captured ) ;
16155: LD_EXP 13
16159: PPUSH
16160: LD_STRING 11_artifact_captured
16162: PPUSH
16163: CALL_OW 39
// if artifact_get then
16167: LD_EXP 13
16171: IFFALSE 16193
// begin m2 := true ;
16173: LD_ADDR_VAR 0 4
16177: PUSH
16178: LD_INT 1
16180: ST_TO_ADDR
// AddMedal ( Artefact , 1 ) ;
16181: LD_STRING Artefact
16183: PPUSH
16184: LD_INT 1
16186: PPUSH
16187: CALL_OW 101
// end else
16191: GO 16204
// AddMedal ( Artefact , - 1 ) ;
16193: LD_STRING Artefact
16195: PPUSH
16196: LD_INT 1
16198: NEG
16199: PPUSH
16200: CALL_OW 101
// if m1 and m2 and m3 and Difficulty >= 3 then
16204: LD_VAR 0 3
16208: PUSH
16209: LD_VAR 0 4
16213: AND
16214: PUSH
16215: LD_VAR 0 5
16219: AND
16220: PUSH
16221: LD_OWVAR 67
16225: PUSH
16226: LD_INT 3
16228: GREATEREQUAL
16229: AND
16230: IFFALSE 16242
// SetAchievementEX ( ACH_AMER , 11 ) ;
16232: LD_STRING ACH_AMER
16234: PPUSH
16235: LD_INT 11
16237: PPUSH
16238: CALL_OW 564
// if m1 and m2 and m3 and loses_counter = 0 then
16242: LD_VAR 0 3
16246: PUSH
16247: LD_VAR 0 4
16251: AND
16252: PUSH
16253: LD_VAR 0 5
16257: AND
16258: PUSH
16259: LD_EXP 17
16263: PUSH
16264: LD_INT 0
16266: EQUAL
16267: AND
16268: IFFALSE 16284
// begin wait ( 3 ) ;
16270: LD_INT 3
16272: PPUSH
16273: CALL_OW 67
// SetAchievement ( ACH_GENERAL ) ;
16277: LD_STRING ACH_GENERAL
16279: PPUSH
16280: CALL_OW 543
// end ; if tick <= 100 100$00 then
16284: LD_OWVAR 1
16288: PUSH
16289: LD_INT 210000
16291: LESSEQUAL
16292: IFFALSE 16308
// begin wait ( 3 ) ;
16294: LD_INT 3
16296: PPUSH
16297: CALL_OW 67
// SetAchievement ( ACH_ASPEED_11 ) ;
16301: LD_STRING ACH_ASPEED_11
16303: PPUSH
16304: CALL_OW 543
// end ; GiveMedals ( MAIN ) ;
16308: LD_STRING MAIN
16310: PPUSH
16311: CALL_OW 102
// selected := UnitFilter ( selected , [ f_alive ] ) ;
16315: LD_ADDR_EXP 19
16319: PUSH
16320: LD_EXP 19
16324: PPUSH
16325: LD_INT 51
16327: PUSH
16328: EMPTY
16329: LIST
16330: PPUSH
16331: CALL_OW 72
16335: ST_TO_ADDR
// tmp := JMM ^ selected ;
16336: LD_ADDR_VAR 0 2
16340: PUSH
16341: LD_EXP 21
16345: PUSH
16346: LD_EXP 19
16350: ADD
16351: ST_TO_ADDR
// RewardPeople ( tmp ) ;
16352: LD_VAR 0 2
16356: PPUSH
16357: CALL_OW 43
// SaveCharacters ( tmp diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , 11c_others ) ;
16361: LD_VAR 0 2
16365: PUSH
16366: LD_EXP 21
16370: PUSH
16371: LD_EXP 22
16375: PUSH
16376: LD_EXP 23
16380: PUSH
16381: LD_EXP 24
16385: PUSH
16386: LD_EXP 25
16390: PUSH
16391: LD_EXP 26
16395: PUSH
16396: LD_EXP 27
16400: PUSH
16401: LD_EXP 28
16405: PUSH
16406: LD_EXP 29
16410: PUSH
16411: LD_EXP 31
16415: PUSH
16416: LD_EXP 32
16420: PUSH
16421: LD_EXP 33
16425: PUSH
16426: LD_EXP 34
16430: PUSH
16431: EMPTY
16432: LIST
16433: LIST
16434: LIST
16435: LIST
16436: LIST
16437: LIST
16438: LIST
16439: LIST
16440: LIST
16441: LIST
16442: LIST
16443: LIST
16444: LIST
16445: DIFF
16446: PPUSH
16447: LD_STRING 11c_others
16449: PPUSH
16450: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
16454: LD_EXP 21
16458: PPUSH
16459: LD_EXP 3
16463: PUSH
16464: LD_STRING JMM
16466: STR
16467: PPUSH
16468: CALL_OW 38
// if Lisa then
16472: LD_EXP 22
16476: IFFALSE 16496
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
16478: LD_EXP 22
16482: PPUSH
16483: LD_EXP 3
16487: PUSH
16488: LD_STRING Lisa
16490: STR
16491: PPUSH
16492: CALL_OW 38
// if Donaldson then
16496: LD_EXP 23
16500: IFFALSE 16520
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
16502: LD_EXP 23
16506: PPUSH
16507: LD_EXP 3
16511: PUSH
16512: LD_STRING Donaldson
16514: STR
16515: PPUSH
16516: CALL_OW 38
// if Bobby then
16520: LD_EXP 24
16524: IFFALSE 16544
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
16526: LD_EXP 24
16530: PPUSH
16531: LD_EXP 3
16535: PUSH
16536: LD_STRING Bobby
16538: STR
16539: PPUSH
16540: CALL_OW 38
// if Cyrus then
16544: LD_EXP 25
16548: IFFALSE 16568
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
16550: LD_EXP 25
16554: PPUSH
16555: LD_EXP 3
16559: PUSH
16560: LD_STRING Cyrus
16562: STR
16563: PPUSH
16564: CALL_OW 38
// if Denis then
16568: LD_EXP 26
16572: IFFALSE 16592
// SaveCharacters ( Denis , mission_prefix & Denis ) ;
16574: LD_EXP 26
16578: PPUSH
16579: LD_EXP 3
16583: PUSH
16584: LD_STRING Denis
16586: STR
16587: PPUSH
16588: CALL_OW 38
// if Brown then
16592: LD_EXP 27
16596: IFFALSE 16616
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
16598: LD_EXP 27
16602: PPUSH
16603: LD_EXP 3
16607: PUSH
16608: LD_STRING Brown
16610: STR
16611: PPUSH
16612: CALL_OW 38
// if Gladstone then
16616: LD_EXP 28
16620: IFFALSE 16640
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
16622: LD_EXP 28
16626: PPUSH
16627: LD_EXP 3
16631: PUSH
16632: LD_STRING Gladstone
16634: STR
16635: PPUSH
16636: CALL_OW 38
// if Houten then
16640: LD_EXP 29
16644: IFFALSE 16664
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
16646: LD_EXP 29
16650: PPUSH
16651: LD_EXP 3
16655: PUSH
16656: LD_STRING Houten
16658: STR
16659: PPUSH
16660: CALL_OW 38
// if Cornel then
16664: LD_EXP 31
16668: IFFALSE 16688
// SaveCharacters ( Cornel , mission_prefix & Cornell ) ;
16670: LD_EXP 31
16674: PPUSH
16675: LD_EXP 3
16679: PUSH
16680: LD_STRING Cornell
16682: STR
16683: PPUSH
16684: CALL_OW 38
// if Gary then
16688: LD_EXP 32
16692: IFFALSE 16712
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
16694: LD_EXP 32
16698: PPUSH
16699: LD_EXP 3
16703: PUSH
16704: LD_STRING Gary
16706: STR
16707: PPUSH
16708: CALL_OW 38
// if Frank then
16712: LD_EXP 33
16716: IFFALSE 16736
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
16718: LD_EXP 33
16722: PPUSH
16723: LD_EXP 3
16727: PUSH
16728: LD_STRING Frank
16730: STR
16731: PPUSH
16732: CALL_OW 38
// if Kikuchi then
16736: LD_EXP 34
16740: IFFALSE 16760
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
16742: LD_EXP 34
16746: PPUSH
16747: LD_EXP 3
16751: PUSH
16752: LD_STRING Kikuchi
16754: STR
16755: PPUSH
16756: CALL_OW 38
// YouWin ;
16760: CALL_OW 103
// end ;
16764: LD_VAR 0 1
16768: RET
// export function CanSayRand ( side ) ; begin
16769: LD_INT 0
16771: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16772: LD_ADDR_VAR 0 2
16776: PUSH
16777: LD_INT 52
16779: PUSH
16780: EMPTY
16781: LIST
16782: PUSH
16783: LD_INT 22
16785: PUSH
16786: LD_VAR 0 1
16790: PUSH
16791: EMPTY
16792: LIST
16793: LIST
16794: PUSH
16795: LD_INT 2
16797: PUSH
16798: LD_INT 25
16800: PUSH
16801: LD_INT 1
16803: PUSH
16804: EMPTY
16805: LIST
16806: LIST
16807: PUSH
16808: LD_INT 25
16810: PUSH
16811: LD_INT 2
16813: PUSH
16814: EMPTY
16815: LIST
16816: LIST
16817: PUSH
16818: LD_INT 25
16820: PUSH
16821: LD_INT 3
16823: PUSH
16824: EMPTY
16825: LIST
16826: LIST
16827: PUSH
16828: LD_INT 25
16830: PUSH
16831: LD_INT 4
16833: PUSH
16834: EMPTY
16835: LIST
16836: LIST
16837: PUSH
16838: EMPTY
16839: LIST
16840: LIST
16841: LIST
16842: LIST
16843: LIST
16844: PUSH
16845: EMPTY
16846: LIST
16847: LIST
16848: LIST
16849: PPUSH
16850: CALL_OW 69
16854: PUSH
16855: LD_EXP 21
16859: PUSH
16860: LD_EXP 33
16864: PUSH
16865: LD_EXP 22
16869: PUSH
16870: LD_EXP 23
16874: PUSH
16875: LD_EXP 24
16879: PUSH
16880: LD_EXP 25
16884: PUSH
16885: LD_EXP 26
16889: PUSH
16890: LD_EXP 27
16894: PUSH
16895: LD_EXP 28
16899: PUSH
16900: LD_EXP 29
16904: PUSH
16905: LD_EXP 30
16909: PUSH
16910: LD_EXP 31
16914: PUSH
16915: LD_EXP 32
16919: PUSH
16920: LD_EXP 34
16924: PUSH
16925: EMPTY
16926: LIST
16927: LIST
16928: LIST
16929: LIST
16930: LIST
16931: LIST
16932: LIST
16933: LIST
16934: LIST
16935: LIST
16936: LIST
16937: LIST
16938: LIST
16939: LIST
16940: DIFF
16941: ST_TO_ADDR
// end ;
16942: LD_VAR 0 2
16946: RET
// export function SayRand ( sex , dial ) ; begin
16947: LD_INT 0
16949: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16950: LD_ADDR_VAR 0 3
16954: PUSH
16955: LD_INT 52
16957: PUSH
16958: EMPTY
16959: LIST
16960: PUSH
16961: LD_INT 22
16963: PUSH
16964: LD_INT 1
16966: PUSH
16967: EMPTY
16968: LIST
16969: LIST
16970: PUSH
16971: LD_INT 26
16973: PUSH
16974: LD_VAR 0 1
16978: PUSH
16979: EMPTY
16980: LIST
16981: LIST
16982: PUSH
16983: LD_INT 2
16985: PUSH
16986: LD_INT 25
16988: PUSH
16989: LD_INT 1
16991: PUSH
16992: EMPTY
16993: LIST
16994: LIST
16995: PUSH
16996: LD_INT 25
16998: PUSH
16999: LD_INT 2
17001: PUSH
17002: EMPTY
17003: LIST
17004: LIST
17005: PUSH
17006: LD_INT 25
17008: PUSH
17009: LD_INT 3
17011: PUSH
17012: EMPTY
17013: LIST
17014: LIST
17015: PUSH
17016: LD_INT 25
17018: PUSH
17019: LD_INT 4
17021: PUSH
17022: EMPTY
17023: LIST
17024: LIST
17025: PUSH
17026: EMPTY
17027: LIST
17028: LIST
17029: LIST
17030: LIST
17031: LIST
17032: PUSH
17033: EMPTY
17034: LIST
17035: LIST
17036: LIST
17037: LIST
17038: PPUSH
17039: CALL_OW 69
17043: PUSH
17044: LD_EXP 21
17048: PUSH
17049: LD_EXP 33
17053: PUSH
17054: LD_EXP 22
17058: PUSH
17059: LD_EXP 23
17063: PUSH
17064: LD_EXP 24
17068: PUSH
17069: LD_EXP 25
17073: PUSH
17074: LD_EXP 26
17078: PUSH
17079: LD_EXP 27
17083: PUSH
17084: LD_EXP 28
17088: PUSH
17089: LD_EXP 29
17093: PUSH
17094: LD_EXP 30
17098: PUSH
17099: LD_EXP 31
17103: PUSH
17104: LD_EXP 32
17108: PUSH
17109: LD_EXP 34
17113: PUSH
17114: EMPTY
17115: LIST
17116: LIST
17117: LIST
17118: LIST
17119: LIST
17120: LIST
17121: LIST
17122: LIST
17123: LIST
17124: LIST
17125: LIST
17126: LIST
17127: LIST
17128: LIST
17129: DIFF
17130: ST_TO_ADDR
// if not result then
17131: LD_VAR 0 3
17135: NOT
17136: IFFALSE 17140
// exit ;
17138: GO 17168
// result := result [ 1 ] ;
17140: LD_ADDR_VAR 0 3
17144: PUSH
17145: LD_VAR 0 3
17149: PUSH
17150: LD_INT 1
17152: ARRAY
17153: ST_TO_ADDR
// Say ( result , dial ) ;
17154: LD_VAR 0 3
17158: PPUSH
17159: LD_VAR 0 2
17163: PPUSH
17164: CALL_OW 88
// end ;
17168: LD_VAR 0 3
17172: RET
// export function SayRand2 ( sex , dial , filter ) ; begin
17173: LD_INT 0
17175: PPUSH
// result := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ^ filter ;
17176: LD_ADDR_VAR 0 4
17180: PUSH
17181: LD_INT 22
17183: PUSH
17184: LD_INT 1
17186: PUSH
17187: EMPTY
17188: LIST
17189: LIST
17190: PUSH
17191: LD_INT 26
17193: PUSH
17194: LD_VAR 0 1
17198: PUSH
17199: EMPTY
17200: LIST
17201: LIST
17202: PUSH
17203: LD_INT 2
17205: PUSH
17206: LD_INT 25
17208: PUSH
17209: LD_INT 1
17211: PUSH
17212: EMPTY
17213: LIST
17214: LIST
17215: PUSH
17216: LD_INT 25
17218: PUSH
17219: LD_INT 2
17221: PUSH
17222: EMPTY
17223: LIST
17224: LIST
17225: PUSH
17226: LD_INT 25
17228: PUSH
17229: LD_INT 3
17231: PUSH
17232: EMPTY
17233: LIST
17234: LIST
17235: PUSH
17236: LD_INT 25
17238: PUSH
17239: LD_INT 4
17241: PUSH
17242: EMPTY
17243: LIST
17244: LIST
17245: PUSH
17246: EMPTY
17247: LIST
17248: LIST
17249: LIST
17250: LIST
17251: LIST
17252: PUSH
17253: EMPTY
17254: LIST
17255: LIST
17256: LIST
17257: PPUSH
17258: CALL_OW 69
17262: PUSH
17263: LD_EXP 21
17267: PUSH
17268: LD_EXP 33
17272: PUSH
17273: LD_EXP 22
17277: PUSH
17278: LD_EXP 23
17282: PUSH
17283: LD_EXP 24
17287: PUSH
17288: LD_EXP 25
17292: PUSH
17293: LD_EXP 26
17297: PUSH
17298: LD_EXP 27
17302: PUSH
17303: LD_EXP 28
17307: PUSH
17308: LD_EXP 29
17312: PUSH
17313: LD_EXP 30
17317: PUSH
17318: LD_EXP 31
17322: PUSH
17323: LD_EXP 32
17327: PUSH
17328: LD_EXP 34
17332: PUSH
17333: EMPTY
17334: LIST
17335: LIST
17336: LIST
17337: LIST
17338: LIST
17339: LIST
17340: LIST
17341: LIST
17342: LIST
17343: LIST
17344: LIST
17345: LIST
17346: LIST
17347: LIST
17348: PUSH
17349: LD_VAR 0 3
17353: ADD
17354: DIFF
17355: ST_TO_ADDR
// if not result then
17356: LD_VAR 0 4
17360: NOT
17361: IFFALSE 17365
// exit ;
17363: GO 17393
// result := result [ 1 ] ;
17365: LD_ADDR_VAR 0 4
17369: PUSH
17370: LD_VAR 0 4
17374: PUSH
17375: LD_INT 1
17377: ARRAY
17378: ST_TO_ADDR
// Say ( result , dial ) ;
17379: LD_VAR 0 4
17383: PPUSH
17384: LD_VAR 0 2
17388: PPUSH
17389: CALL_OW 88
// end ; end_of_file
17393: LD_VAR 0 4
17397: RET
// export function CustomEvent ( event ) ; begin
17398: LD_INT 0
17400: PPUSH
// end ;
17401: LD_VAR 0 2
17405: RET
// on ArtifactLoaded ( cargo , artifact ) do begin if GetSide ( cargo ) = 1 then
17406: LD_VAR 0 1
17410: PPUSH
17411: CALL_OW 255
17415: PUSH
17416: LD_INT 1
17418: EQUAL
17419: IFFALSE 17429
// artifact_get := true ;
17421: LD_ADDR_EXP 13
17425: PUSH
17426: LD_INT 1
17428: ST_TO_ADDR
// if GetSide ( cargo ) = 2 then
17429: LD_VAR 0 1
17433: PPUSH
17434: CALL_OW 255
17438: PUSH
17439: LD_INT 2
17441: EQUAL
17442: IFFALSE 17460
// begin artifact_get := false ;
17444: LD_ADDR_EXP 13
17448: PUSH
17449: LD_INT 0
17451: ST_TO_ADDR
// artifact_stolen := true ;
17452: LD_ADDR_EXP 12
17456: PUSH
17457: LD_INT 1
17459: ST_TO_ADDR
// end ; artifact_oncargo := true ;
17460: LD_ADDR_EXP 14
17464: PUSH
17465: LD_INT 1
17467: ST_TO_ADDR
// end ;
17468: PPOPN 2
17470: END
// on ArtifactUnloaded ( cargo , artifact ) do begin artifact_oncargo := false ;
17471: LD_ADDR_EXP 14
17475: PUSH
17476: LD_INT 0
17478: ST_TO_ADDR
// end ;
17479: PPOPN 2
17481: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
17482: LD_VAR 0 1
17486: PPUSH
17487: CALL 106831 0 1
// if un = JMM then
17491: LD_VAR 0 1
17495: PUSH
17496: LD_EXP 21
17500: EQUAL
17501: IFFALSE 17512
// begin YouLost ( JMM ) ;
17503: LD_STRING JMM
17505: PPUSH
17506: CALL_OW 104
// exit ;
17510: GO 17644
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) then
17512: LD_VAR 0 1
17516: PUSH
17517: LD_INT 22
17519: PUSH
17520: LD_INT 1
17522: PUSH
17523: EMPTY
17524: LIST
17525: LIST
17526: PUSH
17527: LD_INT 21
17529: PUSH
17530: LD_INT 1
17532: PUSH
17533: EMPTY
17534: LIST
17535: LIST
17536: PUSH
17537: LD_INT 2
17539: PUSH
17540: LD_INT 25
17542: PUSH
17543: LD_INT 1
17545: PUSH
17546: EMPTY
17547: LIST
17548: LIST
17549: PUSH
17550: LD_INT 25
17552: PUSH
17553: LD_INT 2
17555: PUSH
17556: EMPTY
17557: LIST
17558: LIST
17559: PUSH
17560: LD_INT 25
17562: PUSH
17563: LD_INT 3
17565: PUSH
17566: EMPTY
17567: LIST
17568: LIST
17569: PUSH
17570: LD_INT 25
17572: PUSH
17573: LD_INT 4
17575: PUSH
17576: EMPTY
17577: LIST
17578: LIST
17579: PUSH
17580: LD_INT 25
17582: PUSH
17583: LD_INT 5
17585: PUSH
17586: EMPTY
17587: LIST
17588: LIST
17589: PUSH
17590: LD_INT 25
17592: PUSH
17593: LD_INT 8
17595: PUSH
17596: EMPTY
17597: LIST
17598: LIST
17599: PUSH
17600: EMPTY
17601: LIST
17602: LIST
17603: LIST
17604: LIST
17605: LIST
17606: LIST
17607: LIST
17608: PUSH
17609: EMPTY
17610: LIST
17611: LIST
17612: LIST
17613: PPUSH
17614: CALL_OW 69
17618: IN
17619: IFFALSE 17635
// loses_counter := loses_counter + 1 ;
17621: LD_ADDR_EXP 17
17625: PUSH
17626: LD_EXP 17
17630: PUSH
17631: LD_INT 1
17633: PLUS
17634: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
17635: LD_VAR 0 1
17639: PPUSH
17640: CALL 46121 0 1
// end ;
17644: PPOPN 1
17646: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
17647: LD_VAR 0 1
17651: PPUSH
17652: LD_VAR 0 2
17656: PPUSH
17657: CALL 48453 0 2
// end ;
17661: PPOPN 2
17663: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
17664: LD_VAR 0 1
17668: PPUSH
17669: CALL 47762 0 1
// end ;
17673: PPOPN 1
17675: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
17676: LD_VAR 0 1
17680: PPUSH
17681: LD_VAR 0 2
17685: PPUSH
17686: LD_VAR 0 3
17690: PPUSH
17691: LD_VAR 0 4
17695: PPUSH
17696: LD_VAR 0 5
17700: PPUSH
17701: CALL 45437 0 5
// end ;
17705: PPOPN 5
17707: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
17708: LD_VAR 0 1
17712: PPUSH
17713: LD_VAR 0 2
17717: PPUSH
17718: CALL 106951 0 2
// if GetNation ( vehicle ) = nation_american then
17722: LD_VAR 0 1
17726: PPUSH
17727: CALL_OW 248
17731: PUSH
17732: LD_INT 1
17734: EQUAL
17735: IFFALSE 17745
// am_veh_consturcted := true ;
17737: LD_ADDR_EXP 20
17741: PUSH
17742: LD_INT 1
17744: ST_TO_ADDR
// MCE_VehicleConstructed ( vehicle , factory ) ;
17745: LD_VAR 0 1
17749: PPUSH
17750: LD_VAR 0 2
17754: PPUSH
17755: CALL 44990 0 2
// end ;
17759: PPOPN 2
17761: END
// on UnitKamikazed ( unit ) do begin if GetType ( unit ) = unit_vehicle then
17762: LD_VAR 0 1
17766: PPUSH
17767: CALL_OW 247
17771: PUSH
17772: LD_INT 2
17774: EQUAL
17775: IFFALSE 17779
// exit ;
17777: GO 17796
// if not kamikazed then
17779: LD_EXP 11
17783: NOT
17784: IFFALSE 17796
// kamikazed := unit ;
17786: LD_ADDR_EXP 11
17790: PUSH
17791: LD_VAR 0 1
17795: ST_TO_ADDR
// end ;
17796: PPOPN 1
17798: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do var i , tmp ;
17799: LD_INT 0
17801: PPUSH
17802: PPUSH
// begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
17803: LD_VAR 0 1
17807: PPUSH
17808: LD_VAR 0 2
17812: PPUSH
17813: LD_VAR 0 3
17817: PPUSH
17818: LD_VAR 0 4
17822: PPUSH
17823: CALL 44828 0 4
// end ;
17827: PPOPN 6
17829: END
// on BuildingCaptured ( building , side , capturning_unit ) do var i ;
17830: LD_INT 0
17832: PPUSH
// begin if building = ar_dep_n then
17833: LD_VAR 0 1
17837: PUSH
17838: LD_INT 94
17840: EQUAL
17841: IFFALSE 17893
// begin for i := 1 to 3 do
17843: LD_ADDR_VAR 0 4
17847: PUSH
17848: DOUBLE
17849: LD_INT 1
17851: DEC
17852: ST_TO_ADDR
17853: LD_INT 3
17855: PUSH
17856: FOR_TO
17857: IFFALSE 17891
// begin MineExplosion ( 115 + ( i * 2 ) , 6 , 1 ) ;
17859: LD_INT 115
17861: PUSH
17862: LD_VAR 0 4
17866: PUSH
17867: LD_INT 2
17869: MUL
17870: PLUS
17871: PPUSH
17872: LD_INT 6
17874: PPUSH
17875: LD_INT 1
17877: PPUSH
17878: CALL_OW 453
// wait ( 0 0$0.3 ) ;
17882: LD_INT 10
17884: PPUSH
17885: CALL_OW 67
// end ;
17889: GO 17856
17891: POP
17892: POP
// end ; MCE_BuildingCaptured ( building , side , capturning_unit ) ;
17893: LD_VAR 0 1
17897: PPUSH
17898: LD_VAR 0 2
17902: PPUSH
17903: LD_VAR 0 3
17907: PPUSH
17908: CALL 44603 0 3
// end ;
17912: PPOPN 4
17914: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
17915: LD_VAR 0 1
17919: PPUSH
17920: LD_VAR 0 2
17924: PPUSH
17925: CALL 45817 0 2
// end ;
17929: PPOPN 2
17931: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
17932: LD_VAR 0 1
17936: PPUSH
17937: LD_VAR 0 2
17941: PPUSH
17942: CALL 44297 0 2
// end ;
17946: PPOPN 2
17948: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
17949: LD_VAR 0 1
17953: PPUSH
17954: LD_VAR 0 2
17958: PPUSH
17959: CALL 44488 0 2
// end ;
17963: PPOPN 2
17965: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
17966: LD_VAR 0 1
17970: PPUSH
17971: CALL 47521 0 1
// end ;
17975: PPOPN 1
17977: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
17978: LD_VAR 0 1
17982: PPUSH
17983: LD_VAR 0 2
17987: PPUSH
17988: CALL 48748 0 2
// end ;
17992: PPOPN 2
17994: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
17995: LD_VAR 0 1
17999: PPUSH
18000: LD_VAR 0 2
18004: PPUSH
18005: LD_VAR 0 3
18009: PPUSH
18010: LD_VAR 0 4
18014: PPUSH
18015: CALL 48964 0 4
// end ;
18019: PPOPN 4
18021: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
18022: LD_VAR 0 1
18026: PPUSH
18027: CALL 106935 0 1
// end ;
18031: PPOPN 1
18033: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_ok ] , [ f_type , engine_combustion ] ] ) do var i ;
18034: LD_INT 22
18036: PUSH
18037: LD_INT 2
18039: PUSH
18040: EMPTY
18041: LIST
18042: LIST
18043: PUSH
18044: LD_INT 50
18046: PUSH
18047: EMPTY
18048: LIST
18049: PUSH
18050: LD_INT 21
18052: PUSH
18053: LD_INT 1
18055: PUSH
18056: EMPTY
18057: LIST
18058: LIST
18059: PUSH
18060: EMPTY
18061: LIST
18062: LIST
18063: LIST
18064: PPUSH
18065: CALL_OW 69
18069: IFFALSE 18153
18071: GO 18073
18073: DISABLE
18074: LD_INT 0
18076: PPUSH
// begin enable ;
18077: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_ok ] , [ f_type , engine_combustion ] ] ) do
18078: LD_ADDR_VAR 0 1
18082: PUSH
18083: LD_INT 22
18085: PUSH
18086: LD_INT 2
18088: PUSH
18089: EMPTY
18090: LIST
18091: LIST
18092: PUSH
18093: LD_INT 50
18095: PUSH
18096: EMPTY
18097: LIST
18098: PUSH
18099: LD_INT 21
18101: PUSH
18102: LD_INT 1
18104: PUSH
18105: EMPTY
18106: LIST
18107: LIST
18108: PUSH
18109: EMPTY
18110: LIST
18111: LIST
18112: LIST
18113: PPUSH
18114: CALL_OW 69
18118: PUSH
18119: FOR_IN
18120: IFFALSE 18151
// if GetFuel ( i ) < 3 then
18122: LD_VAR 0 1
18126: PPUSH
18127: CALL_OW 261
18131: PUSH
18132: LD_INT 3
18134: LESS
18135: IFFALSE 18149
// SetFuel ( i , 5 ) ;
18137: LD_VAR 0 1
18141: PPUSH
18142: LD_INT 5
18144: PPUSH
18145: CALL_OW 240
18149: GO 18119
18151: POP
18152: POP
// end ; end_of_file
18153: PPOPN 1
18155: END
// every 0 0$1 trigger game do
18156: LD_EXP 2
18160: IFFALSE 18190
18162: GO 18164
18164: DISABLE
// SpawnCrates ( [ crates_west , crates_east , crates_north_west , crates_east ] , 0 0$50 ) ;
18165: LD_INT 7
18167: PUSH
18168: LD_INT 6
18170: PUSH
18171: LD_INT 4
18173: PUSH
18174: LD_INT 6
18176: PUSH
18177: EMPTY
18178: LIST
18179: LIST
18180: LIST
18181: LIST
18182: PPUSH
18183: LD_INT 1750
18185: PPUSH
18186: CALL 18191 0 2
18190: END
// export function SpawnCrates ( areas , time ) ; var i , p ; begin
18191: LD_INT 0
18193: PPUSH
18194: PPUSH
18195: PPUSH
// if not areas then
18196: LD_VAR 0 1
18200: NOT
18201: IFFALSE 18205
// exit ;
18203: GO 18335
// repeat wait ( time ) ;
18205: LD_VAR 0 2
18209: PPUSH
18210: CALL_OW 67
// for i in areas do
18214: LD_ADDR_VAR 0 4
18218: PUSH
18219: LD_VAR 0 1
18223: PUSH
18224: FOR_IN
18225: IFFALSE 18294
// begin p := rand ( 1 , 90 ) ;
18227: LD_ADDR_VAR 0 5
18231: PUSH
18232: LD_INT 1
18234: PPUSH
18235: LD_INT 90
18237: PPUSH
18238: CALL_OW 12
18242: ST_TO_ADDR
// if Prob ( p ) then
18243: LD_VAR 0 5
18247: PPUSH
18248: CALL_OW 13
18252: IFFALSE 18292
// begin CreateCratesArea ( rand ( 2 , 5 ) , i , true ) ;
18254: LD_INT 2
18256: PPUSH
18257: LD_INT 5
18259: PPUSH
18260: CALL_OW 12
18264: PPUSH
18265: LD_VAR 0 4
18269: PPUSH
18270: LD_INT 1
18272: PPUSH
18273: CALL_OW 55
// wait ( rand ( 0 0$21 , 0 0$37 ) ) ;
18277: LD_INT 735
18279: PPUSH
18280: LD_INT 1295
18282: PPUSH
18283: CALL_OW 12
18287: PPUSH
18288: CALL_OW 67
// end ; end ;
18292: GO 18224
18294: POP
18295: POP
// time := time + 0 0$3 ;
18296: LD_ADDR_VAR 0 2
18300: PUSH
18301: LD_VAR 0 2
18305: PUSH
18306: LD_INT 105
18308: PLUS
18309: ST_TO_ADDR
// if time > 3 3$00 then
18310: LD_VAR 0 2
18314: PUSH
18315: LD_INT 6300
18317: GREATER
18318: IFFALSE 18328
// time := 0 0$40 ;
18320: LD_ADDR_VAR 0 2
18324: PUSH
18325: LD_INT 1400
18327: ST_TO_ADDR
// until not game ;
18328: LD_EXP 2
18332: NOT
18333: IFFALSE 18205
// end ;
18335: LD_VAR 0 3
18339: RET
// every 0 0$45 + 3 3$00 trigger tick < [ 40 40$00 , 35 35$00 , 30 30$00 , 25 25$00 ] [ Difficulty ] do
18340: LD_OWVAR 1
18344: PUSH
18345: LD_INT 84000
18347: PUSH
18348: LD_INT 73500
18350: PUSH
18351: LD_INT 63000
18353: PUSH
18354: LD_INT 52500
18356: PUSH
18357: EMPTY
18358: LIST
18359: LIST
18360: LIST
18361: LIST
18362: PUSH
18363: LD_OWVAR 67
18367: ARRAY
18368: LESS
18369: IFFALSE 18396
18371: GO 18373
18373: DISABLE
// begin enable ;
18374: ENABLE
// CreateCratesArea ( rand ( 1 , 5 ) , crates_west , true ) ;
18375: LD_INT 1
18377: PPUSH
18378: LD_INT 5
18380: PPUSH
18381: CALL_OW 12
18385: PPUSH
18386: LD_INT 7
18388: PPUSH
18389: LD_INT 1
18391: PPUSH
18392: CALL_OW 55
// end ; end_of_file
18396: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
18397: LD_INT 0
18399: PPUSH
18400: PPUSH
// skirmish := false ;
18401: LD_ADDR_EXP 48
18405: PUSH
18406: LD_INT 0
18408: ST_TO_ADDR
// debug_mc := false ;
18409: LD_ADDR_EXP 49
18413: PUSH
18414: LD_INT 0
18416: ST_TO_ADDR
// mc_bases := [ ] ;
18417: LD_ADDR_EXP 50
18421: PUSH
18422: EMPTY
18423: ST_TO_ADDR
// mc_sides := [ ] ;
18424: LD_ADDR_EXP 76
18428: PUSH
18429: EMPTY
18430: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
18431: LD_ADDR_EXP 51
18435: PUSH
18436: EMPTY
18437: ST_TO_ADDR
// mc_building_repairs := [ ] ;
18438: LD_ADDR_EXP 52
18442: PUSH
18443: EMPTY
18444: ST_TO_ADDR
// mc_need_heal := [ ] ;
18445: LD_ADDR_EXP 53
18449: PUSH
18450: EMPTY
18451: ST_TO_ADDR
// mc_healers := [ ] ;
18452: LD_ADDR_EXP 54
18456: PUSH
18457: EMPTY
18458: ST_TO_ADDR
// mc_build_list := [ ] ;
18459: LD_ADDR_EXP 55
18463: PUSH
18464: EMPTY
18465: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
18466: LD_ADDR_EXP 82
18470: PUSH
18471: EMPTY
18472: ST_TO_ADDR
// mc_builders := [ ] ;
18473: LD_ADDR_EXP 56
18477: PUSH
18478: EMPTY
18479: ST_TO_ADDR
// mc_construct_list := [ ] ;
18480: LD_ADDR_EXP 57
18484: PUSH
18485: EMPTY
18486: ST_TO_ADDR
// mc_turret_list := [ ] ;
18487: LD_ADDR_EXP 58
18491: PUSH
18492: EMPTY
18493: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
18494: LD_ADDR_EXP 59
18498: PUSH
18499: EMPTY
18500: ST_TO_ADDR
// mc_miners := [ ] ;
18501: LD_ADDR_EXP 64
18505: PUSH
18506: EMPTY
18507: ST_TO_ADDR
// mc_mines := [ ] ;
18508: LD_ADDR_EXP 63
18512: PUSH
18513: EMPTY
18514: ST_TO_ADDR
// mc_minefields := [ ] ;
18515: LD_ADDR_EXP 65
18519: PUSH
18520: EMPTY
18521: ST_TO_ADDR
// mc_crates := [ ] ;
18522: LD_ADDR_EXP 66
18526: PUSH
18527: EMPTY
18528: ST_TO_ADDR
// mc_crates_collector := [ ] ;
18529: LD_ADDR_EXP 67
18533: PUSH
18534: EMPTY
18535: ST_TO_ADDR
// mc_crates_area := [ ] ;
18536: LD_ADDR_EXP 68
18540: PUSH
18541: EMPTY
18542: ST_TO_ADDR
// mc_vehicles := [ ] ;
18543: LD_ADDR_EXP 69
18547: PUSH
18548: EMPTY
18549: ST_TO_ADDR
// mc_attack := [ ] ;
18550: LD_ADDR_EXP 70
18554: PUSH
18555: EMPTY
18556: ST_TO_ADDR
// mc_produce := [ ] ;
18557: LD_ADDR_EXP 71
18561: PUSH
18562: EMPTY
18563: ST_TO_ADDR
// mc_defender := [ ] ;
18564: LD_ADDR_EXP 72
18568: PUSH
18569: EMPTY
18570: ST_TO_ADDR
// mc_parking := [ ] ;
18571: LD_ADDR_EXP 74
18575: PUSH
18576: EMPTY
18577: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
18578: LD_ADDR_EXP 60
18582: PUSH
18583: EMPTY
18584: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
18585: LD_ADDR_EXP 62
18589: PUSH
18590: EMPTY
18591: ST_TO_ADDR
// mc_scan := [ ] ;
18592: LD_ADDR_EXP 73
18596: PUSH
18597: EMPTY
18598: ST_TO_ADDR
// mc_scan_area := [ ] ;
18599: LD_ADDR_EXP 75
18603: PUSH
18604: EMPTY
18605: ST_TO_ADDR
// mc_tech := [ ] ;
18606: LD_ADDR_EXP 77
18610: PUSH
18611: EMPTY
18612: ST_TO_ADDR
// mc_class := [ ] ;
18613: LD_ADDR_EXP 91
18617: PUSH
18618: EMPTY
18619: ST_TO_ADDR
// mc_class_case_use := [ ] ;
18620: LD_ADDR_EXP 92
18624: PUSH
18625: EMPTY
18626: ST_TO_ADDR
// mc_is_defending := [ ] ;
18627: LD_ADDR_EXP 93
18631: PUSH
18632: EMPTY
18633: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
18634: LD_ADDR_EXP 84
18638: PUSH
18639: EMPTY
18640: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
18641: LD_ADDR_EXP 94
18645: PUSH
18646: LD_INT 0
18648: ST_TO_ADDR
// end ;
18649: LD_VAR 0 1
18653: RET
// export function MC_Kill ( base ) ; begin
18654: LD_INT 0
18656: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
18657: LD_ADDR_EXP 50
18661: PUSH
18662: LD_EXP 50
18666: PPUSH
18667: LD_VAR 0 1
18671: PPUSH
18672: EMPTY
18673: PPUSH
18674: CALL_OW 1
18678: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
18679: LD_ADDR_EXP 51
18683: PUSH
18684: LD_EXP 51
18688: PPUSH
18689: LD_VAR 0 1
18693: PPUSH
18694: EMPTY
18695: PPUSH
18696: CALL_OW 1
18700: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
18701: LD_ADDR_EXP 52
18705: PUSH
18706: LD_EXP 52
18710: PPUSH
18711: LD_VAR 0 1
18715: PPUSH
18716: EMPTY
18717: PPUSH
18718: CALL_OW 1
18722: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
18723: LD_ADDR_EXP 53
18727: PUSH
18728: LD_EXP 53
18732: PPUSH
18733: LD_VAR 0 1
18737: PPUSH
18738: EMPTY
18739: PPUSH
18740: CALL_OW 1
18744: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
18745: LD_ADDR_EXP 54
18749: PUSH
18750: LD_EXP 54
18754: PPUSH
18755: LD_VAR 0 1
18759: PPUSH
18760: EMPTY
18761: PPUSH
18762: CALL_OW 1
18766: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
18767: LD_ADDR_EXP 55
18771: PUSH
18772: LD_EXP 55
18776: PPUSH
18777: LD_VAR 0 1
18781: PPUSH
18782: EMPTY
18783: PPUSH
18784: CALL_OW 1
18788: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
18789: LD_ADDR_EXP 56
18793: PUSH
18794: LD_EXP 56
18798: PPUSH
18799: LD_VAR 0 1
18803: PPUSH
18804: EMPTY
18805: PPUSH
18806: CALL_OW 1
18810: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
18811: LD_ADDR_EXP 57
18815: PUSH
18816: LD_EXP 57
18820: PPUSH
18821: LD_VAR 0 1
18825: PPUSH
18826: EMPTY
18827: PPUSH
18828: CALL_OW 1
18832: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
18833: LD_ADDR_EXP 58
18837: PUSH
18838: LD_EXP 58
18842: PPUSH
18843: LD_VAR 0 1
18847: PPUSH
18848: EMPTY
18849: PPUSH
18850: CALL_OW 1
18854: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
18855: LD_ADDR_EXP 59
18859: PUSH
18860: LD_EXP 59
18864: PPUSH
18865: LD_VAR 0 1
18869: PPUSH
18870: EMPTY
18871: PPUSH
18872: CALL_OW 1
18876: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
18877: LD_ADDR_EXP 60
18881: PUSH
18882: LD_EXP 60
18886: PPUSH
18887: LD_VAR 0 1
18891: PPUSH
18892: EMPTY
18893: PPUSH
18894: CALL_OW 1
18898: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
18899: LD_ADDR_EXP 61
18903: PUSH
18904: LD_EXP 61
18908: PPUSH
18909: LD_VAR 0 1
18913: PPUSH
18914: LD_INT 0
18916: PPUSH
18917: CALL_OW 1
18921: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
18922: LD_ADDR_EXP 62
18926: PUSH
18927: LD_EXP 62
18931: PPUSH
18932: LD_VAR 0 1
18936: PPUSH
18937: EMPTY
18938: PPUSH
18939: CALL_OW 1
18943: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
18944: LD_ADDR_EXP 63
18948: PUSH
18949: LD_EXP 63
18953: PPUSH
18954: LD_VAR 0 1
18958: PPUSH
18959: EMPTY
18960: PPUSH
18961: CALL_OW 1
18965: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
18966: LD_ADDR_EXP 64
18970: PUSH
18971: LD_EXP 64
18975: PPUSH
18976: LD_VAR 0 1
18980: PPUSH
18981: EMPTY
18982: PPUSH
18983: CALL_OW 1
18987: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
18988: LD_ADDR_EXP 65
18992: PUSH
18993: LD_EXP 65
18997: PPUSH
18998: LD_VAR 0 1
19002: PPUSH
19003: EMPTY
19004: PPUSH
19005: CALL_OW 1
19009: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
19010: LD_ADDR_EXP 66
19014: PUSH
19015: LD_EXP 66
19019: PPUSH
19020: LD_VAR 0 1
19024: PPUSH
19025: EMPTY
19026: PPUSH
19027: CALL_OW 1
19031: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
19032: LD_ADDR_EXP 67
19036: PUSH
19037: LD_EXP 67
19041: PPUSH
19042: LD_VAR 0 1
19046: PPUSH
19047: EMPTY
19048: PPUSH
19049: CALL_OW 1
19053: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
19054: LD_ADDR_EXP 68
19058: PUSH
19059: LD_EXP 68
19063: PPUSH
19064: LD_VAR 0 1
19068: PPUSH
19069: EMPTY
19070: PPUSH
19071: CALL_OW 1
19075: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
19076: LD_ADDR_EXP 69
19080: PUSH
19081: LD_EXP 69
19085: PPUSH
19086: LD_VAR 0 1
19090: PPUSH
19091: EMPTY
19092: PPUSH
19093: CALL_OW 1
19097: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
19098: LD_ADDR_EXP 70
19102: PUSH
19103: LD_EXP 70
19107: PPUSH
19108: LD_VAR 0 1
19112: PPUSH
19113: EMPTY
19114: PPUSH
19115: CALL_OW 1
19119: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
19120: LD_ADDR_EXP 71
19124: PUSH
19125: LD_EXP 71
19129: PPUSH
19130: LD_VAR 0 1
19134: PPUSH
19135: EMPTY
19136: PPUSH
19137: CALL_OW 1
19141: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
19142: LD_ADDR_EXP 72
19146: PUSH
19147: LD_EXP 72
19151: PPUSH
19152: LD_VAR 0 1
19156: PPUSH
19157: EMPTY
19158: PPUSH
19159: CALL_OW 1
19163: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
19164: LD_ADDR_EXP 73
19168: PUSH
19169: LD_EXP 73
19173: PPUSH
19174: LD_VAR 0 1
19178: PPUSH
19179: EMPTY
19180: PPUSH
19181: CALL_OW 1
19185: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
19186: LD_ADDR_EXP 74
19190: PUSH
19191: LD_EXP 74
19195: PPUSH
19196: LD_VAR 0 1
19200: PPUSH
19201: EMPTY
19202: PPUSH
19203: CALL_OW 1
19207: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
19208: LD_ADDR_EXP 75
19212: PUSH
19213: LD_EXP 75
19217: PPUSH
19218: LD_VAR 0 1
19222: PPUSH
19223: EMPTY
19224: PPUSH
19225: CALL_OW 1
19229: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
19230: LD_ADDR_EXP 77
19234: PUSH
19235: LD_EXP 77
19239: PPUSH
19240: LD_VAR 0 1
19244: PPUSH
19245: EMPTY
19246: PPUSH
19247: CALL_OW 1
19251: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
19252: LD_ADDR_EXP 79
19256: PUSH
19257: LD_EXP 79
19261: PPUSH
19262: LD_VAR 0 1
19266: PPUSH
19267: EMPTY
19268: PPUSH
19269: CALL_OW 1
19273: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
19274: LD_ADDR_EXP 80
19278: PUSH
19279: LD_EXP 80
19283: PPUSH
19284: LD_VAR 0 1
19288: PPUSH
19289: EMPTY
19290: PPUSH
19291: CALL_OW 1
19295: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
19296: LD_ADDR_EXP 81
19300: PUSH
19301: LD_EXP 81
19305: PPUSH
19306: LD_VAR 0 1
19310: PPUSH
19311: EMPTY
19312: PPUSH
19313: CALL_OW 1
19317: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
19318: LD_ADDR_EXP 82
19322: PUSH
19323: LD_EXP 82
19327: PPUSH
19328: LD_VAR 0 1
19332: PPUSH
19333: EMPTY
19334: PPUSH
19335: CALL_OW 1
19339: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
19340: LD_ADDR_EXP 83
19344: PUSH
19345: LD_EXP 83
19349: PPUSH
19350: LD_VAR 0 1
19354: PPUSH
19355: EMPTY
19356: PPUSH
19357: CALL_OW 1
19361: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
19362: LD_ADDR_EXP 84
19366: PUSH
19367: LD_EXP 84
19371: PPUSH
19372: LD_VAR 0 1
19376: PPUSH
19377: EMPTY
19378: PPUSH
19379: CALL_OW 1
19383: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
19384: LD_ADDR_EXP 85
19388: PUSH
19389: LD_EXP 85
19393: PPUSH
19394: LD_VAR 0 1
19398: PPUSH
19399: EMPTY
19400: PPUSH
19401: CALL_OW 1
19405: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
19406: LD_ADDR_EXP 86
19410: PUSH
19411: LD_EXP 86
19415: PPUSH
19416: LD_VAR 0 1
19420: PPUSH
19421: EMPTY
19422: PPUSH
19423: CALL_OW 1
19427: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
19428: LD_ADDR_EXP 87
19432: PUSH
19433: LD_EXP 87
19437: PPUSH
19438: LD_VAR 0 1
19442: PPUSH
19443: EMPTY
19444: PPUSH
19445: CALL_OW 1
19449: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
19450: LD_ADDR_EXP 88
19454: PUSH
19455: LD_EXP 88
19459: PPUSH
19460: LD_VAR 0 1
19464: PPUSH
19465: EMPTY
19466: PPUSH
19467: CALL_OW 1
19471: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
19472: LD_ADDR_EXP 89
19476: PUSH
19477: LD_EXP 89
19481: PPUSH
19482: LD_VAR 0 1
19486: PPUSH
19487: EMPTY
19488: PPUSH
19489: CALL_OW 1
19493: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
19494: LD_ADDR_EXP 90
19498: PUSH
19499: LD_EXP 90
19503: PPUSH
19504: LD_VAR 0 1
19508: PPUSH
19509: EMPTY
19510: PPUSH
19511: CALL_OW 1
19515: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
19516: LD_ADDR_EXP 91
19520: PUSH
19521: LD_EXP 91
19525: PPUSH
19526: LD_VAR 0 1
19530: PPUSH
19531: EMPTY
19532: PPUSH
19533: CALL_OW 1
19537: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
19538: LD_ADDR_EXP 92
19542: PUSH
19543: LD_EXP 92
19547: PPUSH
19548: LD_VAR 0 1
19552: PPUSH
19553: LD_INT 0
19555: PPUSH
19556: CALL_OW 1
19560: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
19561: LD_ADDR_EXP 93
19565: PUSH
19566: LD_EXP 93
19570: PPUSH
19571: LD_VAR 0 1
19575: PPUSH
19576: LD_INT 0
19578: PPUSH
19579: CALL_OW 1
19583: ST_TO_ADDR
// end ;
19584: LD_VAR 0 2
19588: RET
// export function MC_Add ( side , units ) ; var base ; begin
19589: LD_INT 0
19591: PPUSH
19592: PPUSH
// base := mc_bases + 1 ;
19593: LD_ADDR_VAR 0 4
19597: PUSH
19598: LD_EXP 50
19602: PUSH
19603: LD_INT 1
19605: PLUS
19606: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
19607: LD_ADDR_EXP 76
19611: PUSH
19612: LD_EXP 76
19616: PPUSH
19617: LD_VAR 0 4
19621: PPUSH
19622: LD_VAR 0 1
19626: PPUSH
19627: CALL_OW 1
19631: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
19632: LD_ADDR_EXP 50
19636: PUSH
19637: LD_EXP 50
19641: PPUSH
19642: LD_VAR 0 4
19646: PPUSH
19647: LD_VAR 0 2
19651: PPUSH
19652: CALL_OW 1
19656: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
19657: LD_ADDR_EXP 51
19661: PUSH
19662: LD_EXP 51
19666: PPUSH
19667: LD_VAR 0 4
19671: PPUSH
19672: EMPTY
19673: PPUSH
19674: CALL_OW 1
19678: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
19679: LD_ADDR_EXP 52
19683: PUSH
19684: LD_EXP 52
19688: PPUSH
19689: LD_VAR 0 4
19693: PPUSH
19694: EMPTY
19695: PPUSH
19696: CALL_OW 1
19700: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
19701: LD_ADDR_EXP 53
19705: PUSH
19706: LD_EXP 53
19710: PPUSH
19711: LD_VAR 0 4
19715: PPUSH
19716: EMPTY
19717: PPUSH
19718: CALL_OW 1
19722: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
19723: LD_ADDR_EXP 54
19727: PUSH
19728: LD_EXP 54
19732: PPUSH
19733: LD_VAR 0 4
19737: PPUSH
19738: EMPTY
19739: PPUSH
19740: CALL_OW 1
19744: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
19745: LD_ADDR_EXP 55
19749: PUSH
19750: LD_EXP 55
19754: PPUSH
19755: LD_VAR 0 4
19759: PPUSH
19760: EMPTY
19761: PPUSH
19762: CALL_OW 1
19766: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
19767: LD_ADDR_EXP 56
19771: PUSH
19772: LD_EXP 56
19776: PPUSH
19777: LD_VAR 0 4
19781: PPUSH
19782: EMPTY
19783: PPUSH
19784: CALL_OW 1
19788: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
19789: LD_ADDR_EXP 57
19793: PUSH
19794: LD_EXP 57
19798: PPUSH
19799: LD_VAR 0 4
19803: PPUSH
19804: EMPTY
19805: PPUSH
19806: CALL_OW 1
19810: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
19811: LD_ADDR_EXP 58
19815: PUSH
19816: LD_EXP 58
19820: PPUSH
19821: LD_VAR 0 4
19825: PPUSH
19826: EMPTY
19827: PPUSH
19828: CALL_OW 1
19832: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
19833: LD_ADDR_EXP 59
19837: PUSH
19838: LD_EXP 59
19842: PPUSH
19843: LD_VAR 0 4
19847: PPUSH
19848: EMPTY
19849: PPUSH
19850: CALL_OW 1
19854: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
19855: LD_ADDR_EXP 60
19859: PUSH
19860: LD_EXP 60
19864: PPUSH
19865: LD_VAR 0 4
19869: PPUSH
19870: EMPTY
19871: PPUSH
19872: CALL_OW 1
19876: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
19877: LD_ADDR_EXP 61
19881: PUSH
19882: LD_EXP 61
19886: PPUSH
19887: LD_VAR 0 4
19891: PPUSH
19892: LD_INT 0
19894: PPUSH
19895: CALL_OW 1
19899: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
19900: LD_ADDR_EXP 62
19904: PUSH
19905: LD_EXP 62
19909: PPUSH
19910: LD_VAR 0 4
19914: PPUSH
19915: EMPTY
19916: PPUSH
19917: CALL_OW 1
19921: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
19922: LD_ADDR_EXP 63
19926: PUSH
19927: LD_EXP 63
19931: PPUSH
19932: LD_VAR 0 4
19936: PPUSH
19937: EMPTY
19938: PPUSH
19939: CALL_OW 1
19943: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
19944: LD_ADDR_EXP 64
19948: PUSH
19949: LD_EXP 64
19953: PPUSH
19954: LD_VAR 0 4
19958: PPUSH
19959: EMPTY
19960: PPUSH
19961: CALL_OW 1
19965: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
19966: LD_ADDR_EXP 65
19970: PUSH
19971: LD_EXP 65
19975: PPUSH
19976: LD_VAR 0 4
19980: PPUSH
19981: EMPTY
19982: PPUSH
19983: CALL_OW 1
19987: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
19988: LD_ADDR_EXP 66
19992: PUSH
19993: LD_EXP 66
19997: PPUSH
19998: LD_VAR 0 4
20002: PPUSH
20003: EMPTY
20004: PPUSH
20005: CALL_OW 1
20009: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
20010: LD_ADDR_EXP 67
20014: PUSH
20015: LD_EXP 67
20019: PPUSH
20020: LD_VAR 0 4
20024: PPUSH
20025: EMPTY
20026: PPUSH
20027: CALL_OW 1
20031: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
20032: LD_ADDR_EXP 68
20036: PUSH
20037: LD_EXP 68
20041: PPUSH
20042: LD_VAR 0 4
20046: PPUSH
20047: EMPTY
20048: PPUSH
20049: CALL_OW 1
20053: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
20054: LD_ADDR_EXP 69
20058: PUSH
20059: LD_EXP 69
20063: PPUSH
20064: LD_VAR 0 4
20068: PPUSH
20069: EMPTY
20070: PPUSH
20071: CALL_OW 1
20075: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
20076: LD_ADDR_EXP 70
20080: PUSH
20081: LD_EXP 70
20085: PPUSH
20086: LD_VAR 0 4
20090: PPUSH
20091: EMPTY
20092: PPUSH
20093: CALL_OW 1
20097: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
20098: LD_ADDR_EXP 71
20102: PUSH
20103: LD_EXP 71
20107: PPUSH
20108: LD_VAR 0 4
20112: PPUSH
20113: EMPTY
20114: PPUSH
20115: CALL_OW 1
20119: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
20120: LD_ADDR_EXP 72
20124: PUSH
20125: LD_EXP 72
20129: PPUSH
20130: LD_VAR 0 4
20134: PPUSH
20135: EMPTY
20136: PPUSH
20137: CALL_OW 1
20141: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
20142: LD_ADDR_EXP 73
20146: PUSH
20147: LD_EXP 73
20151: PPUSH
20152: LD_VAR 0 4
20156: PPUSH
20157: EMPTY
20158: PPUSH
20159: CALL_OW 1
20163: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
20164: LD_ADDR_EXP 74
20168: PUSH
20169: LD_EXP 74
20173: PPUSH
20174: LD_VAR 0 4
20178: PPUSH
20179: EMPTY
20180: PPUSH
20181: CALL_OW 1
20185: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
20186: LD_ADDR_EXP 75
20190: PUSH
20191: LD_EXP 75
20195: PPUSH
20196: LD_VAR 0 4
20200: PPUSH
20201: EMPTY
20202: PPUSH
20203: CALL_OW 1
20207: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
20208: LD_ADDR_EXP 77
20212: PUSH
20213: LD_EXP 77
20217: PPUSH
20218: LD_VAR 0 4
20222: PPUSH
20223: EMPTY
20224: PPUSH
20225: CALL_OW 1
20229: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
20230: LD_ADDR_EXP 79
20234: PUSH
20235: LD_EXP 79
20239: PPUSH
20240: LD_VAR 0 4
20244: PPUSH
20245: EMPTY
20246: PPUSH
20247: CALL_OW 1
20251: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
20252: LD_ADDR_EXP 80
20256: PUSH
20257: LD_EXP 80
20261: PPUSH
20262: LD_VAR 0 4
20266: PPUSH
20267: EMPTY
20268: PPUSH
20269: CALL_OW 1
20273: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
20274: LD_ADDR_EXP 81
20278: PUSH
20279: LD_EXP 81
20283: PPUSH
20284: LD_VAR 0 4
20288: PPUSH
20289: EMPTY
20290: PPUSH
20291: CALL_OW 1
20295: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
20296: LD_ADDR_EXP 82
20300: PUSH
20301: LD_EXP 82
20305: PPUSH
20306: LD_VAR 0 4
20310: PPUSH
20311: EMPTY
20312: PPUSH
20313: CALL_OW 1
20317: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
20318: LD_ADDR_EXP 83
20322: PUSH
20323: LD_EXP 83
20327: PPUSH
20328: LD_VAR 0 4
20332: PPUSH
20333: EMPTY
20334: PPUSH
20335: CALL_OW 1
20339: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
20340: LD_ADDR_EXP 84
20344: PUSH
20345: LD_EXP 84
20349: PPUSH
20350: LD_VAR 0 4
20354: PPUSH
20355: EMPTY
20356: PPUSH
20357: CALL_OW 1
20361: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
20362: LD_ADDR_EXP 85
20366: PUSH
20367: LD_EXP 85
20371: PPUSH
20372: LD_VAR 0 4
20376: PPUSH
20377: EMPTY
20378: PPUSH
20379: CALL_OW 1
20383: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
20384: LD_ADDR_EXP 86
20388: PUSH
20389: LD_EXP 86
20393: PPUSH
20394: LD_VAR 0 4
20398: PPUSH
20399: EMPTY
20400: PPUSH
20401: CALL_OW 1
20405: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
20406: LD_ADDR_EXP 87
20410: PUSH
20411: LD_EXP 87
20415: PPUSH
20416: LD_VAR 0 4
20420: PPUSH
20421: EMPTY
20422: PPUSH
20423: CALL_OW 1
20427: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
20428: LD_ADDR_EXP 88
20432: PUSH
20433: LD_EXP 88
20437: PPUSH
20438: LD_VAR 0 4
20442: PPUSH
20443: EMPTY
20444: PPUSH
20445: CALL_OW 1
20449: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
20450: LD_ADDR_EXP 89
20454: PUSH
20455: LD_EXP 89
20459: PPUSH
20460: LD_VAR 0 4
20464: PPUSH
20465: EMPTY
20466: PPUSH
20467: CALL_OW 1
20471: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
20472: LD_ADDR_EXP 90
20476: PUSH
20477: LD_EXP 90
20481: PPUSH
20482: LD_VAR 0 4
20486: PPUSH
20487: EMPTY
20488: PPUSH
20489: CALL_OW 1
20493: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
20494: LD_ADDR_EXP 91
20498: PUSH
20499: LD_EXP 91
20503: PPUSH
20504: LD_VAR 0 4
20508: PPUSH
20509: EMPTY
20510: PPUSH
20511: CALL_OW 1
20515: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
20516: LD_ADDR_EXP 92
20520: PUSH
20521: LD_EXP 92
20525: PPUSH
20526: LD_VAR 0 4
20530: PPUSH
20531: LD_INT 0
20533: PPUSH
20534: CALL_OW 1
20538: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
20539: LD_ADDR_EXP 93
20543: PUSH
20544: LD_EXP 93
20548: PPUSH
20549: LD_VAR 0 4
20553: PPUSH
20554: LD_INT 0
20556: PPUSH
20557: CALL_OW 1
20561: ST_TO_ADDR
// result := base ;
20562: LD_ADDR_VAR 0 3
20566: PUSH
20567: LD_VAR 0 4
20571: ST_TO_ADDR
// end ;
20572: LD_VAR 0 3
20576: RET
// export function MC_Start ( ) ; var i ; begin
20577: LD_INT 0
20579: PPUSH
20580: PPUSH
// for i = 1 to mc_bases do
20581: LD_ADDR_VAR 0 2
20585: PUSH
20586: DOUBLE
20587: LD_INT 1
20589: DEC
20590: ST_TO_ADDR
20591: LD_EXP 50
20595: PUSH
20596: FOR_TO
20597: IFFALSE 21697
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
20599: LD_ADDR_EXP 50
20603: PUSH
20604: LD_EXP 50
20608: PPUSH
20609: LD_VAR 0 2
20613: PPUSH
20614: LD_EXP 50
20618: PUSH
20619: LD_VAR 0 2
20623: ARRAY
20624: PUSH
20625: LD_INT 0
20627: DIFF
20628: PPUSH
20629: CALL_OW 1
20633: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
20634: LD_ADDR_EXP 51
20638: PUSH
20639: LD_EXP 51
20643: PPUSH
20644: LD_VAR 0 2
20648: PPUSH
20649: EMPTY
20650: PPUSH
20651: CALL_OW 1
20655: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
20656: LD_ADDR_EXP 52
20660: PUSH
20661: LD_EXP 52
20665: PPUSH
20666: LD_VAR 0 2
20670: PPUSH
20671: EMPTY
20672: PPUSH
20673: CALL_OW 1
20677: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
20678: LD_ADDR_EXP 53
20682: PUSH
20683: LD_EXP 53
20687: PPUSH
20688: LD_VAR 0 2
20692: PPUSH
20693: EMPTY
20694: PPUSH
20695: CALL_OW 1
20699: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
20700: LD_ADDR_EXP 54
20704: PUSH
20705: LD_EXP 54
20709: PPUSH
20710: LD_VAR 0 2
20714: PPUSH
20715: EMPTY
20716: PUSH
20717: EMPTY
20718: PUSH
20719: EMPTY
20720: LIST
20721: LIST
20722: PPUSH
20723: CALL_OW 1
20727: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
20728: LD_ADDR_EXP 55
20732: PUSH
20733: LD_EXP 55
20737: PPUSH
20738: LD_VAR 0 2
20742: PPUSH
20743: EMPTY
20744: PPUSH
20745: CALL_OW 1
20749: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
20750: LD_ADDR_EXP 82
20754: PUSH
20755: LD_EXP 82
20759: PPUSH
20760: LD_VAR 0 2
20764: PPUSH
20765: EMPTY
20766: PPUSH
20767: CALL_OW 1
20771: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
20772: LD_ADDR_EXP 56
20776: PUSH
20777: LD_EXP 56
20781: PPUSH
20782: LD_VAR 0 2
20786: PPUSH
20787: EMPTY
20788: PPUSH
20789: CALL_OW 1
20793: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
20794: LD_ADDR_EXP 57
20798: PUSH
20799: LD_EXP 57
20803: PPUSH
20804: LD_VAR 0 2
20808: PPUSH
20809: EMPTY
20810: PPUSH
20811: CALL_OW 1
20815: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
20816: LD_ADDR_EXP 58
20820: PUSH
20821: LD_EXP 58
20825: PPUSH
20826: LD_VAR 0 2
20830: PPUSH
20831: LD_EXP 50
20835: PUSH
20836: LD_VAR 0 2
20840: ARRAY
20841: PPUSH
20842: LD_INT 2
20844: PUSH
20845: LD_INT 30
20847: PUSH
20848: LD_INT 32
20850: PUSH
20851: EMPTY
20852: LIST
20853: LIST
20854: PUSH
20855: LD_INT 30
20857: PUSH
20858: LD_INT 33
20860: PUSH
20861: EMPTY
20862: LIST
20863: LIST
20864: PUSH
20865: EMPTY
20866: LIST
20867: LIST
20868: LIST
20869: PPUSH
20870: CALL_OW 72
20874: PPUSH
20875: CALL_OW 1
20879: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
20880: LD_ADDR_EXP 59
20884: PUSH
20885: LD_EXP 59
20889: PPUSH
20890: LD_VAR 0 2
20894: PPUSH
20895: LD_EXP 50
20899: PUSH
20900: LD_VAR 0 2
20904: ARRAY
20905: PPUSH
20906: LD_INT 2
20908: PUSH
20909: LD_INT 30
20911: PUSH
20912: LD_INT 32
20914: PUSH
20915: EMPTY
20916: LIST
20917: LIST
20918: PUSH
20919: LD_INT 30
20921: PUSH
20922: LD_INT 31
20924: PUSH
20925: EMPTY
20926: LIST
20927: LIST
20928: PUSH
20929: EMPTY
20930: LIST
20931: LIST
20932: LIST
20933: PUSH
20934: LD_INT 58
20936: PUSH
20937: EMPTY
20938: LIST
20939: PUSH
20940: EMPTY
20941: LIST
20942: LIST
20943: PPUSH
20944: CALL_OW 72
20948: PPUSH
20949: CALL_OW 1
20953: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
20954: LD_ADDR_EXP 60
20958: PUSH
20959: LD_EXP 60
20963: PPUSH
20964: LD_VAR 0 2
20968: PPUSH
20969: EMPTY
20970: PPUSH
20971: CALL_OW 1
20975: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
20976: LD_ADDR_EXP 64
20980: PUSH
20981: LD_EXP 64
20985: PPUSH
20986: LD_VAR 0 2
20990: PPUSH
20991: EMPTY
20992: PPUSH
20993: CALL_OW 1
20997: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
20998: LD_ADDR_EXP 63
21002: PUSH
21003: LD_EXP 63
21007: PPUSH
21008: LD_VAR 0 2
21012: PPUSH
21013: EMPTY
21014: PPUSH
21015: CALL_OW 1
21019: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
21020: LD_ADDR_EXP 65
21024: PUSH
21025: LD_EXP 65
21029: PPUSH
21030: LD_VAR 0 2
21034: PPUSH
21035: EMPTY
21036: PPUSH
21037: CALL_OW 1
21041: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
21042: LD_ADDR_EXP 66
21046: PUSH
21047: LD_EXP 66
21051: PPUSH
21052: LD_VAR 0 2
21056: PPUSH
21057: EMPTY
21058: PPUSH
21059: CALL_OW 1
21063: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
21064: LD_ADDR_EXP 67
21068: PUSH
21069: LD_EXP 67
21073: PPUSH
21074: LD_VAR 0 2
21078: PPUSH
21079: EMPTY
21080: PPUSH
21081: CALL_OW 1
21085: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
21086: LD_ADDR_EXP 68
21090: PUSH
21091: LD_EXP 68
21095: PPUSH
21096: LD_VAR 0 2
21100: PPUSH
21101: EMPTY
21102: PPUSH
21103: CALL_OW 1
21107: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
21108: LD_ADDR_EXP 69
21112: PUSH
21113: LD_EXP 69
21117: PPUSH
21118: LD_VAR 0 2
21122: PPUSH
21123: EMPTY
21124: PPUSH
21125: CALL_OW 1
21129: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
21130: LD_ADDR_EXP 70
21134: PUSH
21135: LD_EXP 70
21139: PPUSH
21140: LD_VAR 0 2
21144: PPUSH
21145: EMPTY
21146: PPUSH
21147: CALL_OW 1
21151: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
21152: LD_ADDR_EXP 71
21156: PUSH
21157: LD_EXP 71
21161: PPUSH
21162: LD_VAR 0 2
21166: PPUSH
21167: EMPTY
21168: PPUSH
21169: CALL_OW 1
21173: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
21174: LD_ADDR_EXP 72
21178: PUSH
21179: LD_EXP 72
21183: PPUSH
21184: LD_VAR 0 2
21188: PPUSH
21189: EMPTY
21190: PPUSH
21191: CALL_OW 1
21195: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
21196: LD_ADDR_EXP 61
21200: PUSH
21201: LD_EXP 61
21205: PPUSH
21206: LD_VAR 0 2
21210: PPUSH
21211: LD_INT 0
21213: PPUSH
21214: CALL_OW 1
21218: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
21219: LD_ADDR_EXP 74
21223: PUSH
21224: LD_EXP 74
21228: PPUSH
21229: LD_VAR 0 2
21233: PPUSH
21234: LD_INT 0
21236: PPUSH
21237: CALL_OW 1
21241: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
21242: LD_ADDR_EXP 62
21246: PUSH
21247: LD_EXP 62
21251: PPUSH
21252: LD_VAR 0 2
21256: PPUSH
21257: EMPTY
21258: PPUSH
21259: CALL_OW 1
21263: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
21264: LD_ADDR_EXP 73
21268: PUSH
21269: LD_EXP 73
21273: PPUSH
21274: LD_VAR 0 2
21278: PPUSH
21279: LD_INT 0
21281: PPUSH
21282: CALL_OW 1
21286: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
21287: LD_ADDR_EXP 75
21291: PUSH
21292: LD_EXP 75
21296: PPUSH
21297: LD_VAR 0 2
21301: PPUSH
21302: EMPTY
21303: PPUSH
21304: CALL_OW 1
21308: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
21309: LD_ADDR_EXP 78
21313: PUSH
21314: LD_EXP 78
21318: PPUSH
21319: LD_VAR 0 2
21323: PPUSH
21324: LD_INT 0
21326: PPUSH
21327: CALL_OW 1
21331: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
21332: LD_ADDR_EXP 79
21336: PUSH
21337: LD_EXP 79
21341: PPUSH
21342: LD_VAR 0 2
21346: PPUSH
21347: EMPTY
21348: PPUSH
21349: CALL_OW 1
21353: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
21354: LD_ADDR_EXP 80
21358: PUSH
21359: LD_EXP 80
21363: PPUSH
21364: LD_VAR 0 2
21368: PPUSH
21369: EMPTY
21370: PPUSH
21371: CALL_OW 1
21375: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
21376: LD_ADDR_EXP 81
21380: PUSH
21381: LD_EXP 81
21385: PPUSH
21386: LD_VAR 0 2
21390: PPUSH
21391: EMPTY
21392: PPUSH
21393: CALL_OW 1
21397: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
21398: LD_ADDR_EXP 83
21402: PUSH
21403: LD_EXP 83
21407: PPUSH
21408: LD_VAR 0 2
21412: PPUSH
21413: LD_EXP 50
21417: PUSH
21418: LD_VAR 0 2
21422: ARRAY
21423: PPUSH
21424: LD_INT 2
21426: PUSH
21427: LD_INT 30
21429: PUSH
21430: LD_INT 6
21432: PUSH
21433: EMPTY
21434: LIST
21435: LIST
21436: PUSH
21437: LD_INT 30
21439: PUSH
21440: LD_INT 7
21442: PUSH
21443: EMPTY
21444: LIST
21445: LIST
21446: PUSH
21447: LD_INT 30
21449: PUSH
21450: LD_INT 8
21452: PUSH
21453: EMPTY
21454: LIST
21455: LIST
21456: PUSH
21457: EMPTY
21458: LIST
21459: LIST
21460: LIST
21461: LIST
21462: PPUSH
21463: CALL_OW 72
21467: PPUSH
21468: CALL_OW 1
21472: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
21473: LD_ADDR_EXP 84
21477: PUSH
21478: LD_EXP 84
21482: PPUSH
21483: LD_VAR 0 2
21487: PPUSH
21488: EMPTY
21489: PPUSH
21490: CALL_OW 1
21494: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
21495: LD_ADDR_EXP 85
21499: PUSH
21500: LD_EXP 85
21504: PPUSH
21505: LD_VAR 0 2
21509: PPUSH
21510: EMPTY
21511: PPUSH
21512: CALL_OW 1
21516: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
21517: LD_ADDR_EXP 86
21521: PUSH
21522: LD_EXP 86
21526: PPUSH
21527: LD_VAR 0 2
21531: PPUSH
21532: EMPTY
21533: PPUSH
21534: CALL_OW 1
21538: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
21539: LD_ADDR_EXP 87
21543: PUSH
21544: LD_EXP 87
21548: PPUSH
21549: LD_VAR 0 2
21553: PPUSH
21554: EMPTY
21555: PPUSH
21556: CALL_OW 1
21560: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
21561: LD_ADDR_EXP 88
21565: PUSH
21566: LD_EXP 88
21570: PPUSH
21571: LD_VAR 0 2
21575: PPUSH
21576: EMPTY
21577: PPUSH
21578: CALL_OW 1
21582: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
21583: LD_ADDR_EXP 89
21587: PUSH
21588: LD_EXP 89
21592: PPUSH
21593: LD_VAR 0 2
21597: PPUSH
21598: EMPTY
21599: PPUSH
21600: CALL_OW 1
21604: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
21605: LD_ADDR_EXP 90
21609: PUSH
21610: LD_EXP 90
21614: PPUSH
21615: LD_VAR 0 2
21619: PPUSH
21620: EMPTY
21621: PPUSH
21622: CALL_OW 1
21626: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
21627: LD_ADDR_EXP 91
21631: PUSH
21632: LD_EXP 91
21636: PPUSH
21637: LD_VAR 0 2
21641: PPUSH
21642: EMPTY
21643: PPUSH
21644: CALL_OW 1
21648: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
21649: LD_ADDR_EXP 92
21653: PUSH
21654: LD_EXP 92
21658: PPUSH
21659: LD_VAR 0 2
21663: PPUSH
21664: LD_INT 0
21666: PPUSH
21667: CALL_OW 1
21671: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
21672: LD_ADDR_EXP 93
21676: PUSH
21677: LD_EXP 93
21681: PPUSH
21682: LD_VAR 0 2
21686: PPUSH
21687: LD_INT 0
21689: PPUSH
21690: CALL_OW 1
21694: ST_TO_ADDR
// end ;
21695: GO 20596
21697: POP
21698: POP
// MC_InitSides ( ) ;
21699: CALL 21985 0 0
// MC_InitResearch ( ) ;
21703: CALL 21724 0 0
// CustomInitMacro ( ) ;
21707: CALL 304 0 0
// skirmish := true ;
21711: LD_ADDR_EXP 48
21715: PUSH
21716: LD_INT 1
21718: ST_TO_ADDR
// end ;
21719: LD_VAR 0 1
21723: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
21724: LD_INT 0
21726: PPUSH
21727: PPUSH
21728: PPUSH
21729: PPUSH
21730: PPUSH
21731: PPUSH
// if not mc_bases then
21732: LD_EXP 50
21736: NOT
21737: IFFALSE 21741
// exit ;
21739: GO 21980
// for i = 1 to 8 do
21741: LD_ADDR_VAR 0 2
21745: PUSH
21746: DOUBLE
21747: LD_INT 1
21749: DEC
21750: ST_TO_ADDR
21751: LD_INT 8
21753: PUSH
21754: FOR_TO
21755: IFFALSE 21781
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
21757: LD_ADDR_EXP 77
21761: PUSH
21762: LD_EXP 77
21766: PPUSH
21767: LD_VAR 0 2
21771: PPUSH
21772: EMPTY
21773: PPUSH
21774: CALL_OW 1
21778: ST_TO_ADDR
21779: GO 21754
21781: POP
21782: POP
// tmp := [ ] ;
21783: LD_ADDR_VAR 0 5
21787: PUSH
21788: EMPTY
21789: ST_TO_ADDR
// for i = 1 to mc_sides do
21790: LD_ADDR_VAR 0 2
21794: PUSH
21795: DOUBLE
21796: LD_INT 1
21798: DEC
21799: ST_TO_ADDR
21800: LD_EXP 76
21804: PUSH
21805: FOR_TO
21806: IFFALSE 21864
// if not mc_sides [ i ] in tmp then
21808: LD_EXP 76
21812: PUSH
21813: LD_VAR 0 2
21817: ARRAY
21818: PUSH
21819: LD_VAR 0 5
21823: IN
21824: NOT
21825: IFFALSE 21862
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
21827: LD_ADDR_VAR 0 5
21831: PUSH
21832: LD_VAR 0 5
21836: PPUSH
21837: LD_VAR 0 5
21841: PUSH
21842: LD_INT 1
21844: PLUS
21845: PPUSH
21846: LD_EXP 76
21850: PUSH
21851: LD_VAR 0 2
21855: ARRAY
21856: PPUSH
21857: CALL_OW 2
21861: ST_TO_ADDR
21862: GO 21805
21864: POP
21865: POP
// if not tmp then
21866: LD_VAR 0 5
21870: NOT
21871: IFFALSE 21875
// exit ;
21873: GO 21980
// for j in tmp do
21875: LD_ADDR_VAR 0 3
21879: PUSH
21880: LD_VAR 0 5
21884: PUSH
21885: FOR_IN
21886: IFFALSE 21978
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
21888: LD_ADDR_VAR 0 6
21892: PUSH
21893: LD_INT 22
21895: PUSH
21896: LD_VAR 0 3
21900: PUSH
21901: EMPTY
21902: LIST
21903: LIST
21904: PPUSH
21905: CALL_OW 69
21909: ST_TO_ADDR
// if not un then
21910: LD_VAR 0 6
21914: NOT
21915: IFFALSE 21919
// continue ;
21917: GO 21885
// nation := GetNation ( un [ 1 ] ) ;
21919: LD_ADDR_VAR 0 4
21923: PUSH
21924: LD_VAR 0 6
21928: PUSH
21929: LD_INT 1
21931: ARRAY
21932: PPUSH
21933: CALL_OW 248
21937: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
21938: LD_ADDR_EXP 77
21942: PUSH
21943: LD_EXP 77
21947: PPUSH
21948: LD_VAR 0 3
21952: PPUSH
21953: LD_VAR 0 3
21957: PPUSH
21958: LD_VAR 0 4
21962: PPUSH
21963: LD_INT 1
21965: PPUSH
21966: CALL 49168 0 3
21970: PPUSH
21971: CALL_OW 1
21975: ST_TO_ADDR
// end ;
21976: GO 21885
21978: POP
21979: POP
// end ;
21980: LD_VAR 0 1
21984: RET
// export function MC_InitSides ( ) ; var i ; begin
21985: LD_INT 0
21987: PPUSH
21988: PPUSH
// if not mc_bases then
21989: LD_EXP 50
21993: NOT
21994: IFFALSE 21998
// exit ;
21996: GO 22072
// for i = 1 to mc_bases do
21998: LD_ADDR_VAR 0 2
22002: PUSH
22003: DOUBLE
22004: LD_INT 1
22006: DEC
22007: ST_TO_ADDR
22008: LD_EXP 50
22012: PUSH
22013: FOR_TO
22014: IFFALSE 22070
// if mc_bases [ i ] then
22016: LD_EXP 50
22020: PUSH
22021: LD_VAR 0 2
22025: ARRAY
22026: IFFALSE 22068
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
22028: LD_ADDR_EXP 76
22032: PUSH
22033: LD_EXP 76
22037: PPUSH
22038: LD_VAR 0 2
22042: PPUSH
22043: LD_EXP 50
22047: PUSH
22048: LD_VAR 0 2
22052: ARRAY
22053: PUSH
22054: LD_INT 1
22056: ARRAY
22057: PPUSH
22058: CALL_OW 255
22062: PPUSH
22063: CALL_OW 1
22067: ST_TO_ADDR
22068: GO 22013
22070: POP
22071: POP
// end ;
22072: LD_VAR 0 1
22076: RET
// every 0 0$03 trigger skirmish do
22077: LD_EXP 48
22081: IFFALSE 22235
22083: GO 22085
22085: DISABLE
// begin enable ;
22086: ENABLE
// MC_CheckBuildings ( ) ;
22087: CALL 26747 0 0
// MC_CheckPeopleLife ( ) ;
22091: CALL 26908 0 0
// RaiseSailEvent ( 100 ) ;
22095: LD_INT 100
22097: PPUSH
22098: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
22102: LD_INT 103
22104: PPUSH
22105: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
22109: LD_INT 104
22111: PPUSH
22112: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
22116: LD_INT 105
22118: PPUSH
22119: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
22123: LD_INT 106
22125: PPUSH
22126: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
22130: LD_INT 107
22132: PPUSH
22133: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
22137: LD_INT 108
22139: PPUSH
22140: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
22144: LD_INT 109
22146: PPUSH
22147: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
22151: LD_INT 110
22153: PPUSH
22154: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
22158: LD_INT 111
22160: PPUSH
22161: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
22165: LD_INT 112
22167: PPUSH
22168: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
22172: LD_INT 113
22174: PPUSH
22175: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
22179: LD_INT 120
22181: PPUSH
22182: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
22186: LD_INT 121
22188: PPUSH
22189: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
22193: LD_INT 122
22195: PPUSH
22196: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
22200: LD_INT 123
22202: PPUSH
22203: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
22207: LD_INT 124
22209: PPUSH
22210: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
22214: LD_INT 125
22216: PPUSH
22217: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
22221: LD_INT 126
22223: PPUSH
22224: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
22228: LD_INT 200
22230: PPUSH
22231: CALL_OW 427
// end ;
22235: END
// on SailEvent ( event ) do begin if event < 100 then
22236: LD_VAR 0 1
22240: PUSH
22241: LD_INT 100
22243: LESS
22244: IFFALSE 22255
// CustomEvent ( event ) ;
22246: LD_VAR 0 1
22250: PPUSH
22251: CALL 17398 0 1
// if event = 100 then
22255: LD_VAR 0 1
22259: PUSH
22260: LD_INT 100
22262: EQUAL
22263: IFFALSE 22269
// MC_ClassManager ( ) ;
22265: CALL 22661 0 0
// if event = 101 then
22269: LD_VAR 0 1
22273: PUSH
22274: LD_INT 101
22276: EQUAL
22277: IFFALSE 22283
// MC_RepairBuildings ( ) ;
22279: CALL 27493 0 0
// if event = 102 then
22283: LD_VAR 0 1
22287: PUSH
22288: LD_INT 102
22290: EQUAL
22291: IFFALSE 22297
// MC_Heal ( ) ;
22293: CALL 28428 0 0
// if event = 103 then
22297: LD_VAR 0 1
22301: PUSH
22302: LD_INT 103
22304: EQUAL
22305: IFFALSE 22311
// MC_Build ( ) ;
22307: CALL 28850 0 0
// if event = 104 then
22311: LD_VAR 0 1
22315: PUSH
22316: LD_INT 104
22318: EQUAL
22319: IFFALSE 22325
// MC_TurretWeapon ( ) ;
22321: CALL 30484 0 0
// if event = 105 then
22325: LD_VAR 0 1
22329: PUSH
22330: LD_INT 105
22332: EQUAL
22333: IFFALSE 22339
// MC_BuildUpgrade ( ) ;
22335: CALL 30035 0 0
// if event = 106 then
22339: LD_VAR 0 1
22343: PUSH
22344: LD_INT 106
22346: EQUAL
22347: IFFALSE 22353
// MC_PlantMines ( ) ;
22349: CALL 30914 0 0
// if event = 107 then
22353: LD_VAR 0 1
22357: PUSH
22358: LD_INT 107
22360: EQUAL
22361: IFFALSE 22367
// MC_CollectCrates ( ) ;
22363: CALL 31712 0 0
// if event = 108 then
22367: LD_VAR 0 1
22371: PUSH
22372: LD_INT 108
22374: EQUAL
22375: IFFALSE 22381
// MC_LinkRemoteControl ( ) ;
22377: CALL 33562 0 0
// if event = 109 then
22381: LD_VAR 0 1
22385: PUSH
22386: LD_INT 109
22388: EQUAL
22389: IFFALSE 22395
// MC_ProduceVehicle ( ) ;
22391: CALL 33743 0 0
// if event = 110 then
22395: LD_VAR 0 1
22399: PUSH
22400: LD_INT 110
22402: EQUAL
22403: IFFALSE 22409
// MC_SendAttack ( ) ;
22405: CALL 34209 0 0
// if event = 111 then
22409: LD_VAR 0 1
22413: PUSH
22414: LD_INT 111
22416: EQUAL
22417: IFFALSE 22423
// MC_Defend ( ) ;
22419: CALL 34317 0 0
// if event = 112 then
22423: LD_VAR 0 1
22427: PUSH
22428: LD_INT 112
22430: EQUAL
22431: IFFALSE 22437
// MC_Research ( ) ;
22433: CALL 35197 0 0
// if event = 113 then
22437: LD_VAR 0 1
22441: PUSH
22442: LD_INT 113
22444: EQUAL
22445: IFFALSE 22451
// MC_MinesTrigger ( ) ;
22447: CALL 36311 0 0
// if event = 120 then
22451: LD_VAR 0 1
22455: PUSH
22456: LD_INT 120
22458: EQUAL
22459: IFFALSE 22465
// MC_RepairVehicle ( ) ;
22461: CALL 36410 0 0
// if event = 121 then
22465: LD_VAR 0 1
22469: PUSH
22470: LD_INT 121
22472: EQUAL
22473: IFFALSE 22479
// MC_TameApe ( ) ;
22475: CALL 37179 0 0
// if event = 122 then
22479: LD_VAR 0 1
22483: PUSH
22484: LD_INT 122
22486: EQUAL
22487: IFFALSE 22493
// MC_ChangeApeClass ( ) ;
22489: CALL 38008 0 0
// if event = 123 then
22493: LD_VAR 0 1
22497: PUSH
22498: LD_INT 123
22500: EQUAL
22501: IFFALSE 22507
// MC_Bazooka ( ) ;
22503: CALL 38658 0 0
// if event = 124 then
22507: LD_VAR 0 1
22511: PUSH
22512: LD_INT 124
22514: EQUAL
22515: IFFALSE 22521
// MC_TeleportExit ( ) ;
22517: CALL 38856 0 0
// if event = 125 then
22521: LD_VAR 0 1
22525: PUSH
22526: LD_INT 125
22528: EQUAL
22529: IFFALSE 22535
// MC_Deposits ( ) ;
22531: CALL 39503 0 0
// if event = 126 then
22535: LD_VAR 0 1
22539: PUSH
22540: LD_INT 126
22542: EQUAL
22543: IFFALSE 22549
// MC_RemoteDriver ( ) ;
22545: CALL 40128 0 0
// if event = 200 then
22549: LD_VAR 0 1
22553: PUSH
22554: LD_INT 200
22556: EQUAL
22557: IFFALSE 22563
// MC_Idle ( ) ;
22559: CALL 42035 0 0
// end ;
22563: PPOPN 1
22565: END
// export function MC_Reset ( base , tag ) ; var i ; begin
22566: LD_INT 0
22568: PPUSH
22569: PPUSH
// if not mc_bases [ base ] or not tag then
22570: LD_EXP 50
22574: PUSH
22575: LD_VAR 0 1
22579: ARRAY
22580: NOT
22581: PUSH
22582: LD_VAR 0 2
22586: NOT
22587: OR
22588: IFFALSE 22592
// exit ;
22590: GO 22656
// for i in mc_bases [ base ] union mc_ape [ base ] do
22592: LD_ADDR_VAR 0 4
22596: PUSH
22597: LD_EXP 50
22601: PUSH
22602: LD_VAR 0 1
22606: ARRAY
22607: PUSH
22608: LD_EXP 79
22612: PUSH
22613: LD_VAR 0 1
22617: ARRAY
22618: UNION
22619: PUSH
22620: FOR_IN
22621: IFFALSE 22654
// if GetTag ( i ) = tag then
22623: LD_VAR 0 4
22627: PPUSH
22628: CALL_OW 110
22632: PUSH
22633: LD_VAR 0 2
22637: EQUAL
22638: IFFALSE 22652
// SetTag ( i , 0 ) ;
22640: LD_VAR 0 4
22644: PPUSH
22645: LD_INT 0
22647: PPUSH
22648: CALL_OW 109
22652: GO 22620
22654: POP
22655: POP
// end ;
22656: LD_VAR 0 3
22660: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
22661: LD_INT 0
22663: PPUSH
22664: PPUSH
22665: PPUSH
22666: PPUSH
22667: PPUSH
22668: PPUSH
22669: PPUSH
22670: PPUSH
// if not mc_bases then
22671: LD_EXP 50
22675: NOT
22676: IFFALSE 22680
// exit ;
22678: GO 23129
// for i = 1 to mc_bases do
22680: LD_ADDR_VAR 0 2
22684: PUSH
22685: DOUBLE
22686: LD_INT 1
22688: DEC
22689: ST_TO_ADDR
22690: LD_EXP 50
22694: PUSH
22695: FOR_TO
22696: IFFALSE 23127
// begin tmp := MC_ClassCheckReq ( i ) ;
22698: LD_ADDR_VAR 0 4
22702: PUSH
22703: LD_VAR 0 2
22707: PPUSH
22708: CALL 23134 0 1
22712: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
22713: LD_ADDR_EXP 91
22717: PUSH
22718: LD_EXP 91
22722: PPUSH
22723: LD_VAR 0 2
22727: PPUSH
22728: LD_VAR 0 4
22732: PPUSH
22733: CALL_OW 1
22737: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
22738: LD_ADDR_VAR 0 6
22742: PUSH
22743: LD_EXP 50
22747: PUSH
22748: LD_VAR 0 2
22752: ARRAY
22753: PPUSH
22754: LD_INT 2
22756: PUSH
22757: LD_INT 30
22759: PUSH
22760: LD_INT 4
22762: PUSH
22763: EMPTY
22764: LIST
22765: LIST
22766: PUSH
22767: LD_INT 30
22769: PUSH
22770: LD_INT 5
22772: PUSH
22773: EMPTY
22774: LIST
22775: LIST
22776: PUSH
22777: EMPTY
22778: LIST
22779: LIST
22780: LIST
22781: PPUSH
22782: CALL_OW 72
22786: PUSH
22787: LD_EXP 50
22791: PUSH
22792: LD_VAR 0 2
22796: ARRAY
22797: PPUSH
22798: LD_INT 2
22800: PUSH
22801: LD_INT 30
22803: PUSH
22804: LD_INT 0
22806: PUSH
22807: EMPTY
22808: LIST
22809: LIST
22810: PUSH
22811: LD_INT 30
22813: PUSH
22814: LD_INT 1
22816: PUSH
22817: EMPTY
22818: LIST
22819: LIST
22820: PUSH
22821: EMPTY
22822: LIST
22823: LIST
22824: LIST
22825: PPUSH
22826: CALL_OW 72
22830: PUSH
22831: LD_EXP 50
22835: PUSH
22836: LD_VAR 0 2
22840: ARRAY
22841: PPUSH
22842: LD_INT 30
22844: PUSH
22845: LD_INT 3
22847: PUSH
22848: EMPTY
22849: LIST
22850: LIST
22851: PPUSH
22852: CALL_OW 72
22856: PUSH
22857: LD_EXP 50
22861: PUSH
22862: LD_VAR 0 2
22866: ARRAY
22867: PPUSH
22868: LD_INT 2
22870: PUSH
22871: LD_INT 30
22873: PUSH
22874: LD_INT 6
22876: PUSH
22877: EMPTY
22878: LIST
22879: LIST
22880: PUSH
22881: LD_INT 30
22883: PUSH
22884: LD_INT 7
22886: PUSH
22887: EMPTY
22888: LIST
22889: LIST
22890: PUSH
22891: LD_INT 30
22893: PUSH
22894: LD_INT 8
22896: PUSH
22897: EMPTY
22898: LIST
22899: LIST
22900: PUSH
22901: EMPTY
22902: LIST
22903: LIST
22904: LIST
22905: LIST
22906: PPUSH
22907: CALL_OW 72
22911: PUSH
22912: EMPTY
22913: LIST
22914: LIST
22915: LIST
22916: LIST
22917: ST_TO_ADDR
// for j := 1 to 4 do
22918: LD_ADDR_VAR 0 3
22922: PUSH
22923: DOUBLE
22924: LD_INT 1
22926: DEC
22927: ST_TO_ADDR
22928: LD_INT 4
22930: PUSH
22931: FOR_TO
22932: IFFALSE 23123
// begin if not tmp [ j ] then
22934: LD_VAR 0 4
22938: PUSH
22939: LD_VAR 0 3
22943: ARRAY
22944: NOT
22945: IFFALSE 22949
// continue ;
22947: GO 22931
// for p in tmp [ j ] do
22949: LD_ADDR_VAR 0 5
22953: PUSH
22954: LD_VAR 0 4
22958: PUSH
22959: LD_VAR 0 3
22963: ARRAY
22964: PUSH
22965: FOR_IN
22966: IFFALSE 23119
// begin if not b [ j ] then
22968: LD_VAR 0 6
22972: PUSH
22973: LD_VAR 0 3
22977: ARRAY
22978: NOT
22979: IFFALSE 22983
// break ;
22981: GO 23119
// e := 0 ;
22983: LD_ADDR_VAR 0 7
22987: PUSH
22988: LD_INT 0
22990: ST_TO_ADDR
// for k in b [ j ] do
22991: LD_ADDR_VAR 0 8
22995: PUSH
22996: LD_VAR 0 6
23000: PUSH
23001: LD_VAR 0 3
23005: ARRAY
23006: PUSH
23007: FOR_IN
23008: IFFALSE 23035
// if IsNotFull ( k ) then
23010: LD_VAR 0 8
23014: PPUSH
23015: CALL 51289 0 1
23019: IFFALSE 23033
// begin e := k ;
23021: LD_ADDR_VAR 0 7
23025: PUSH
23026: LD_VAR 0 8
23030: ST_TO_ADDR
// break ;
23031: GO 23035
// end ;
23033: GO 23007
23035: POP
23036: POP
// if e and not UnitGoingToBuilding ( p , e ) then
23037: LD_VAR 0 7
23041: PUSH
23042: LD_VAR 0 5
23046: PPUSH
23047: LD_VAR 0 7
23051: PPUSH
23052: CALL 85439 0 2
23056: NOT
23057: AND
23058: IFFALSE 23117
// begin if IsInUnit ( p ) then
23060: LD_VAR 0 5
23064: PPUSH
23065: CALL_OW 310
23069: IFFALSE 23080
// ComExitBuilding ( p ) ;
23071: LD_VAR 0 5
23075: PPUSH
23076: CALL_OW 122
// ComEnterUnit ( p , e ) ;
23080: LD_VAR 0 5
23084: PPUSH
23085: LD_VAR 0 7
23089: PPUSH
23090: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
23094: LD_VAR 0 5
23098: PPUSH
23099: LD_VAR 0 3
23103: PPUSH
23104: CALL_OW 183
// AddComExitBuilding ( p ) ;
23108: LD_VAR 0 5
23112: PPUSH
23113: CALL_OW 182
// end ; end ;
23117: GO 22965
23119: POP
23120: POP
// end ;
23121: GO 22931
23123: POP
23124: POP
// end ;
23125: GO 22695
23127: POP
23128: POP
// end ;
23129: LD_VAR 0 1
23133: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
23134: LD_INT 0
23136: PPUSH
23137: PPUSH
23138: PPUSH
23139: PPUSH
23140: PPUSH
23141: PPUSH
23142: PPUSH
23143: PPUSH
23144: PPUSH
23145: PPUSH
23146: PPUSH
23147: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
23148: LD_ADDR_VAR 0 2
23152: PUSH
23153: LD_INT 0
23155: PUSH
23156: LD_INT 0
23158: PUSH
23159: LD_INT 0
23161: PUSH
23162: LD_INT 0
23164: PUSH
23165: EMPTY
23166: LIST
23167: LIST
23168: LIST
23169: LIST
23170: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
23171: LD_VAR 0 1
23175: NOT
23176: PUSH
23177: LD_EXP 50
23181: PUSH
23182: LD_VAR 0 1
23186: ARRAY
23187: NOT
23188: OR
23189: PUSH
23190: LD_EXP 50
23194: PUSH
23195: LD_VAR 0 1
23199: ARRAY
23200: PPUSH
23201: LD_INT 2
23203: PUSH
23204: LD_INT 30
23206: PUSH
23207: LD_INT 0
23209: PUSH
23210: EMPTY
23211: LIST
23212: LIST
23213: PUSH
23214: LD_INT 30
23216: PUSH
23217: LD_INT 1
23219: PUSH
23220: EMPTY
23221: LIST
23222: LIST
23223: PUSH
23224: EMPTY
23225: LIST
23226: LIST
23227: LIST
23228: PPUSH
23229: CALL_OW 72
23233: NOT
23234: OR
23235: IFFALSE 23239
// exit ;
23237: GO 26742
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
23239: LD_ADDR_VAR 0 4
23243: PUSH
23244: LD_EXP 50
23248: PUSH
23249: LD_VAR 0 1
23253: ARRAY
23254: PPUSH
23255: LD_INT 2
23257: PUSH
23258: LD_INT 25
23260: PUSH
23261: LD_INT 1
23263: PUSH
23264: EMPTY
23265: LIST
23266: LIST
23267: PUSH
23268: LD_INT 25
23270: PUSH
23271: LD_INT 2
23273: PUSH
23274: EMPTY
23275: LIST
23276: LIST
23277: PUSH
23278: LD_INT 25
23280: PUSH
23281: LD_INT 3
23283: PUSH
23284: EMPTY
23285: LIST
23286: LIST
23287: PUSH
23288: LD_INT 25
23290: PUSH
23291: LD_INT 4
23293: PUSH
23294: EMPTY
23295: LIST
23296: LIST
23297: PUSH
23298: LD_INT 25
23300: PUSH
23301: LD_INT 5
23303: PUSH
23304: EMPTY
23305: LIST
23306: LIST
23307: PUSH
23308: LD_INT 25
23310: PUSH
23311: LD_INT 8
23313: PUSH
23314: EMPTY
23315: LIST
23316: LIST
23317: PUSH
23318: LD_INT 25
23320: PUSH
23321: LD_INT 9
23323: PUSH
23324: EMPTY
23325: LIST
23326: LIST
23327: PUSH
23328: EMPTY
23329: LIST
23330: LIST
23331: LIST
23332: LIST
23333: LIST
23334: LIST
23335: LIST
23336: LIST
23337: PPUSH
23338: CALL_OW 72
23342: ST_TO_ADDR
// if not tmp then
23343: LD_VAR 0 4
23347: NOT
23348: IFFALSE 23352
// exit ;
23350: GO 26742
// for i in tmp do
23352: LD_ADDR_VAR 0 3
23356: PUSH
23357: LD_VAR 0 4
23361: PUSH
23362: FOR_IN
23363: IFFALSE 23394
// if GetTag ( i ) then
23365: LD_VAR 0 3
23369: PPUSH
23370: CALL_OW 110
23374: IFFALSE 23392
// tmp := tmp diff i ;
23376: LD_ADDR_VAR 0 4
23380: PUSH
23381: LD_VAR 0 4
23385: PUSH
23386: LD_VAR 0 3
23390: DIFF
23391: ST_TO_ADDR
23392: GO 23362
23394: POP
23395: POP
// if not tmp then
23396: LD_VAR 0 4
23400: NOT
23401: IFFALSE 23405
// exit ;
23403: GO 26742
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
23405: LD_ADDR_VAR 0 5
23409: PUSH
23410: LD_EXP 50
23414: PUSH
23415: LD_VAR 0 1
23419: ARRAY
23420: PPUSH
23421: LD_INT 2
23423: PUSH
23424: LD_INT 25
23426: PUSH
23427: LD_INT 1
23429: PUSH
23430: EMPTY
23431: LIST
23432: LIST
23433: PUSH
23434: LD_INT 25
23436: PUSH
23437: LD_INT 5
23439: PUSH
23440: EMPTY
23441: LIST
23442: LIST
23443: PUSH
23444: LD_INT 25
23446: PUSH
23447: LD_INT 8
23449: PUSH
23450: EMPTY
23451: LIST
23452: LIST
23453: PUSH
23454: LD_INT 25
23456: PUSH
23457: LD_INT 9
23459: PUSH
23460: EMPTY
23461: LIST
23462: LIST
23463: PUSH
23464: EMPTY
23465: LIST
23466: LIST
23467: LIST
23468: LIST
23469: LIST
23470: PPUSH
23471: CALL_OW 72
23475: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
23476: LD_ADDR_VAR 0 6
23480: PUSH
23481: LD_EXP 50
23485: PUSH
23486: LD_VAR 0 1
23490: ARRAY
23491: PPUSH
23492: LD_INT 25
23494: PUSH
23495: LD_INT 2
23497: PUSH
23498: EMPTY
23499: LIST
23500: LIST
23501: PPUSH
23502: CALL_OW 72
23506: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
23507: LD_ADDR_VAR 0 7
23511: PUSH
23512: LD_EXP 50
23516: PUSH
23517: LD_VAR 0 1
23521: ARRAY
23522: PPUSH
23523: LD_INT 25
23525: PUSH
23526: LD_INT 3
23528: PUSH
23529: EMPTY
23530: LIST
23531: LIST
23532: PPUSH
23533: CALL_OW 72
23537: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
23538: LD_ADDR_VAR 0 8
23542: PUSH
23543: LD_EXP 50
23547: PUSH
23548: LD_VAR 0 1
23552: ARRAY
23553: PPUSH
23554: LD_INT 25
23556: PUSH
23557: LD_INT 4
23559: PUSH
23560: EMPTY
23561: LIST
23562: LIST
23563: PUSH
23564: LD_INT 24
23566: PUSH
23567: LD_INT 251
23569: PUSH
23570: EMPTY
23571: LIST
23572: LIST
23573: PUSH
23574: EMPTY
23575: LIST
23576: LIST
23577: PPUSH
23578: CALL_OW 72
23582: ST_TO_ADDR
// if mc_is_defending [ base ] then
23583: LD_EXP 93
23587: PUSH
23588: LD_VAR 0 1
23592: ARRAY
23593: IFFALSE 24054
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
23595: LD_ADDR_EXP 92
23599: PUSH
23600: LD_EXP 92
23604: PPUSH
23605: LD_VAR 0 1
23609: PPUSH
23610: LD_INT 4
23612: PPUSH
23613: CALL_OW 1
23617: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
23618: LD_ADDR_VAR 0 12
23622: PUSH
23623: LD_EXP 50
23627: PUSH
23628: LD_VAR 0 1
23632: ARRAY
23633: PPUSH
23634: LD_INT 2
23636: PUSH
23637: LD_INT 30
23639: PUSH
23640: LD_INT 4
23642: PUSH
23643: EMPTY
23644: LIST
23645: LIST
23646: PUSH
23647: LD_INT 30
23649: PUSH
23650: LD_INT 5
23652: PUSH
23653: EMPTY
23654: LIST
23655: LIST
23656: PUSH
23657: EMPTY
23658: LIST
23659: LIST
23660: LIST
23661: PPUSH
23662: CALL_OW 72
23666: ST_TO_ADDR
// if not b then
23667: LD_VAR 0 12
23671: NOT
23672: IFFALSE 23676
// exit ;
23674: GO 26742
// p := [ ] ;
23676: LD_ADDR_VAR 0 11
23680: PUSH
23681: EMPTY
23682: ST_TO_ADDR
// if sci >= 2 then
23683: LD_VAR 0 8
23687: PUSH
23688: LD_INT 2
23690: GREATEREQUAL
23691: IFFALSE 23722
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
23693: LD_ADDR_VAR 0 8
23697: PUSH
23698: LD_VAR 0 8
23702: PUSH
23703: LD_INT 1
23705: ARRAY
23706: PUSH
23707: LD_VAR 0 8
23711: PUSH
23712: LD_INT 2
23714: ARRAY
23715: PUSH
23716: EMPTY
23717: LIST
23718: LIST
23719: ST_TO_ADDR
23720: GO 23783
// if sci = 1 then
23722: LD_VAR 0 8
23726: PUSH
23727: LD_INT 1
23729: EQUAL
23730: IFFALSE 23751
// sci := [ sci [ 1 ] ] else
23732: LD_ADDR_VAR 0 8
23736: PUSH
23737: LD_VAR 0 8
23741: PUSH
23742: LD_INT 1
23744: ARRAY
23745: PUSH
23746: EMPTY
23747: LIST
23748: ST_TO_ADDR
23749: GO 23783
// if sci = 0 then
23751: LD_VAR 0 8
23755: PUSH
23756: LD_INT 0
23758: EQUAL
23759: IFFALSE 23783
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
23761: LD_ADDR_VAR 0 11
23765: PUSH
23766: LD_VAR 0 4
23770: PPUSH
23771: LD_INT 4
23773: PPUSH
23774: CALL 85311 0 2
23778: PUSH
23779: LD_INT 1
23781: ARRAY
23782: ST_TO_ADDR
// if eng > 4 then
23783: LD_VAR 0 6
23787: PUSH
23788: LD_INT 4
23790: GREATER
23791: IFFALSE 23837
// for i = eng downto 4 do
23793: LD_ADDR_VAR 0 3
23797: PUSH
23798: DOUBLE
23799: LD_VAR 0 6
23803: INC
23804: ST_TO_ADDR
23805: LD_INT 4
23807: PUSH
23808: FOR_DOWNTO
23809: IFFALSE 23835
// eng := eng diff eng [ i ] ;
23811: LD_ADDR_VAR 0 6
23815: PUSH
23816: LD_VAR 0 6
23820: PUSH
23821: LD_VAR 0 6
23825: PUSH
23826: LD_VAR 0 3
23830: ARRAY
23831: DIFF
23832: ST_TO_ADDR
23833: GO 23808
23835: POP
23836: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
23837: LD_ADDR_VAR 0 4
23841: PUSH
23842: LD_VAR 0 4
23846: PUSH
23847: LD_VAR 0 5
23851: PUSH
23852: LD_VAR 0 6
23856: UNION
23857: PUSH
23858: LD_VAR 0 7
23862: UNION
23863: PUSH
23864: LD_VAR 0 8
23868: UNION
23869: DIFF
23870: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
23871: LD_ADDR_VAR 0 13
23875: PUSH
23876: LD_EXP 50
23880: PUSH
23881: LD_VAR 0 1
23885: ARRAY
23886: PPUSH
23887: LD_INT 2
23889: PUSH
23890: LD_INT 30
23892: PUSH
23893: LD_INT 32
23895: PUSH
23896: EMPTY
23897: LIST
23898: LIST
23899: PUSH
23900: LD_INT 30
23902: PUSH
23903: LD_INT 31
23905: PUSH
23906: EMPTY
23907: LIST
23908: LIST
23909: PUSH
23910: EMPTY
23911: LIST
23912: LIST
23913: LIST
23914: PPUSH
23915: CALL_OW 72
23919: PUSH
23920: LD_EXP 50
23924: PUSH
23925: LD_VAR 0 1
23929: ARRAY
23930: PPUSH
23931: LD_INT 2
23933: PUSH
23934: LD_INT 30
23936: PUSH
23937: LD_INT 4
23939: PUSH
23940: EMPTY
23941: LIST
23942: LIST
23943: PUSH
23944: LD_INT 30
23946: PUSH
23947: LD_INT 5
23949: PUSH
23950: EMPTY
23951: LIST
23952: LIST
23953: PUSH
23954: EMPTY
23955: LIST
23956: LIST
23957: LIST
23958: PPUSH
23959: CALL_OW 72
23963: PUSH
23964: LD_INT 6
23966: MUL
23967: PLUS
23968: ST_TO_ADDR
// if bcount < tmp then
23969: LD_VAR 0 13
23973: PUSH
23974: LD_VAR 0 4
23978: LESS
23979: IFFALSE 24025
// for i = tmp downto bcount do
23981: LD_ADDR_VAR 0 3
23985: PUSH
23986: DOUBLE
23987: LD_VAR 0 4
23991: INC
23992: ST_TO_ADDR
23993: LD_VAR 0 13
23997: PUSH
23998: FOR_DOWNTO
23999: IFFALSE 24023
// tmp := Delete ( tmp , tmp ) ;
24001: LD_ADDR_VAR 0 4
24005: PUSH
24006: LD_VAR 0 4
24010: PPUSH
24011: LD_VAR 0 4
24015: PPUSH
24016: CALL_OW 3
24020: ST_TO_ADDR
24021: GO 23998
24023: POP
24024: POP
// result := [ tmp , 0 , 0 , p ] ;
24025: LD_ADDR_VAR 0 2
24029: PUSH
24030: LD_VAR 0 4
24034: PUSH
24035: LD_INT 0
24037: PUSH
24038: LD_INT 0
24040: PUSH
24041: LD_VAR 0 11
24045: PUSH
24046: EMPTY
24047: LIST
24048: LIST
24049: LIST
24050: LIST
24051: ST_TO_ADDR
// exit ;
24052: GO 26742
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
24054: LD_EXP 50
24058: PUSH
24059: LD_VAR 0 1
24063: ARRAY
24064: PPUSH
24065: LD_INT 2
24067: PUSH
24068: LD_INT 30
24070: PUSH
24071: LD_INT 6
24073: PUSH
24074: EMPTY
24075: LIST
24076: LIST
24077: PUSH
24078: LD_INT 30
24080: PUSH
24081: LD_INT 7
24083: PUSH
24084: EMPTY
24085: LIST
24086: LIST
24087: PUSH
24088: LD_INT 30
24090: PUSH
24091: LD_INT 8
24093: PUSH
24094: EMPTY
24095: LIST
24096: LIST
24097: PUSH
24098: EMPTY
24099: LIST
24100: LIST
24101: LIST
24102: LIST
24103: PPUSH
24104: CALL_OW 72
24108: NOT
24109: PUSH
24110: LD_EXP 50
24114: PUSH
24115: LD_VAR 0 1
24119: ARRAY
24120: PPUSH
24121: LD_INT 30
24123: PUSH
24124: LD_INT 3
24126: PUSH
24127: EMPTY
24128: LIST
24129: LIST
24130: PPUSH
24131: CALL_OW 72
24135: NOT
24136: AND
24137: IFFALSE 24209
// begin if eng = tmp then
24139: LD_VAR 0 6
24143: PUSH
24144: LD_VAR 0 4
24148: EQUAL
24149: IFFALSE 24153
// exit ;
24151: GO 26742
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
24153: LD_ADDR_EXP 92
24157: PUSH
24158: LD_EXP 92
24162: PPUSH
24163: LD_VAR 0 1
24167: PPUSH
24168: LD_INT 1
24170: PPUSH
24171: CALL_OW 1
24175: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
24176: LD_ADDR_VAR 0 2
24180: PUSH
24181: LD_INT 0
24183: PUSH
24184: LD_VAR 0 4
24188: PUSH
24189: LD_VAR 0 6
24193: DIFF
24194: PUSH
24195: LD_INT 0
24197: PUSH
24198: LD_INT 0
24200: PUSH
24201: EMPTY
24202: LIST
24203: LIST
24204: LIST
24205: LIST
24206: ST_TO_ADDR
// exit ;
24207: GO 26742
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
24209: LD_EXP 77
24213: PUSH
24214: LD_EXP 76
24218: PUSH
24219: LD_VAR 0 1
24223: ARRAY
24224: ARRAY
24225: PUSH
24226: LD_EXP 50
24230: PUSH
24231: LD_VAR 0 1
24235: ARRAY
24236: PPUSH
24237: LD_INT 2
24239: PUSH
24240: LD_INT 30
24242: PUSH
24243: LD_INT 6
24245: PUSH
24246: EMPTY
24247: LIST
24248: LIST
24249: PUSH
24250: LD_INT 30
24252: PUSH
24253: LD_INT 7
24255: PUSH
24256: EMPTY
24257: LIST
24258: LIST
24259: PUSH
24260: LD_INT 30
24262: PUSH
24263: LD_INT 8
24265: PUSH
24266: EMPTY
24267: LIST
24268: LIST
24269: PUSH
24270: EMPTY
24271: LIST
24272: LIST
24273: LIST
24274: LIST
24275: PPUSH
24276: CALL_OW 72
24280: AND
24281: PUSH
24282: LD_EXP 50
24286: PUSH
24287: LD_VAR 0 1
24291: ARRAY
24292: PPUSH
24293: LD_INT 30
24295: PUSH
24296: LD_INT 3
24298: PUSH
24299: EMPTY
24300: LIST
24301: LIST
24302: PPUSH
24303: CALL_OW 72
24307: NOT
24308: AND
24309: IFFALSE 24523
// begin if sci >= 6 then
24311: LD_VAR 0 8
24315: PUSH
24316: LD_INT 6
24318: GREATEREQUAL
24319: IFFALSE 24323
// exit ;
24321: GO 26742
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
24323: LD_ADDR_EXP 92
24327: PUSH
24328: LD_EXP 92
24332: PPUSH
24333: LD_VAR 0 1
24337: PPUSH
24338: LD_INT 2
24340: PPUSH
24341: CALL_OW 1
24345: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
24346: LD_ADDR_VAR 0 9
24350: PUSH
24351: LD_VAR 0 4
24355: PUSH
24356: LD_VAR 0 8
24360: DIFF
24361: PPUSH
24362: LD_INT 4
24364: PPUSH
24365: CALL 85311 0 2
24369: ST_TO_ADDR
// p := [ ] ;
24370: LD_ADDR_VAR 0 11
24374: PUSH
24375: EMPTY
24376: ST_TO_ADDR
// if sci < 6 and sort > 6 then
24377: LD_VAR 0 8
24381: PUSH
24382: LD_INT 6
24384: LESS
24385: PUSH
24386: LD_VAR 0 9
24390: PUSH
24391: LD_INT 6
24393: GREATER
24394: AND
24395: IFFALSE 24476
// begin for i = 1 to 6 - sci do
24397: LD_ADDR_VAR 0 3
24401: PUSH
24402: DOUBLE
24403: LD_INT 1
24405: DEC
24406: ST_TO_ADDR
24407: LD_INT 6
24409: PUSH
24410: LD_VAR 0 8
24414: MINUS
24415: PUSH
24416: FOR_TO
24417: IFFALSE 24472
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
24419: LD_ADDR_VAR 0 11
24423: PUSH
24424: LD_VAR 0 11
24428: PPUSH
24429: LD_VAR 0 11
24433: PUSH
24434: LD_INT 1
24436: PLUS
24437: PPUSH
24438: LD_VAR 0 9
24442: PUSH
24443: LD_INT 1
24445: ARRAY
24446: PPUSH
24447: CALL_OW 2
24451: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
24452: LD_ADDR_VAR 0 9
24456: PUSH
24457: LD_VAR 0 9
24461: PPUSH
24462: LD_INT 1
24464: PPUSH
24465: CALL_OW 3
24469: ST_TO_ADDR
// end ;
24470: GO 24416
24472: POP
24473: POP
// end else
24474: GO 24496
// if sort then
24476: LD_VAR 0 9
24480: IFFALSE 24496
// p := sort [ 1 ] ;
24482: LD_ADDR_VAR 0 11
24486: PUSH
24487: LD_VAR 0 9
24491: PUSH
24492: LD_INT 1
24494: ARRAY
24495: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
24496: LD_ADDR_VAR 0 2
24500: PUSH
24501: LD_INT 0
24503: PUSH
24504: LD_INT 0
24506: PUSH
24507: LD_INT 0
24509: PUSH
24510: LD_VAR 0 11
24514: PUSH
24515: EMPTY
24516: LIST
24517: LIST
24518: LIST
24519: LIST
24520: ST_TO_ADDR
// exit ;
24521: GO 26742
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
24523: LD_EXP 77
24527: PUSH
24528: LD_EXP 76
24532: PUSH
24533: LD_VAR 0 1
24537: ARRAY
24538: ARRAY
24539: PUSH
24540: LD_EXP 50
24544: PUSH
24545: LD_VAR 0 1
24549: ARRAY
24550: PPUSH
24551: LD_INT 2
24553: PUSH
24554: LD_INT 30
24556: PUSH
24557: LD_INT 6
24559: PUSH
24560: EMPTY
24561: LIST
24562: LIST
24563: PUSH
24564: LD_INT 30
24566: PUSH
24567: LD_INT 7
24569: PUSH
24570: EMPTY
24571: LIST
24572: LIST
24573: PUSH
24574: LD_INT 30
24576: PUSH
24577: LD_INT 8
24579: PUSH
24580: EMPTY
24581: LIST
24582: LIST
24583: PUSH
24584: EMPTY
24585: LIST
24586: LIST
24587: LIST
24588: LIST
24589: PPUSH
24590: CALL_OW 72
24594: AND
24595: PUSH
24596: LD_EXP 50
24600: PUSH
24601: LD_VAR 0 1
24605: ARRAY
24606: PPUSH
24607: LD_INT 30
24609: PUSH
24610: LD_INT 3
24612: PUSH
24613: EMPTY
24614: LIST
24615: LIST
24616: PPUSH
24617: CALL_OW 72
24621: AND
24622: IFFALSE 25356
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
24624: LD_ADDR_EXP 92
24628: PUSH
24629: LD_EXP 92
24633: PPUSH
24634: LD_VAR 0 1
24638: PPUSH
24639: LD_INT 3
24641: PPUSH
24642: CALL_OW 1
24646: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
24647: LD_ADDR_VAR 0 2
24651: PUSH
24652: LD_INT 0
24654: PUSH
24655: LD_INT 0
24657: PUSH
24658: LD_INT 0
24660: PUSH
24661: LD_INT 0
24663: PUSH
24664: EMPTY
24665: LIST
24666: LIST
24667: LIST
24668: LIST
24669: ST_TO_ADDR
// if not eng then
24670: LD_VAR 0 6
24674: NOT
24675: IFFALSE 24738
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
24677: LD_ADDR_VAR 0 11
24681: PUSH
24682: LD_VAR 0 4
24686: PPUSH
24687: LD_INT 2
24689: PPUSH
24690: CALL 85311 0 2
24694: PUSH
24695: LD_INT 1
24697: ARRAY
24698: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
24699: LD_ADDR_VAR 0 2
24703: PUSH
24704: LD_VAR 0 2
24708: PPUSH
24709: LD_INT 2
24711: PPUSH
24712: LD_VAR 0 11
24716: PPUSH
24717: CALL_OW 1
24721: ST_TO_ADDR
// tmp := tmp diff p ;
24722: LD_ADDR_VAR 0 4
24726: PUSH
24727: LD_VAR 0 4
24731: PUSH
24732: LD_VAR 0 11
24736: DIFF
24737: ST_TO_ADDR
// end ; if tmp and sci < 6 then
24738: LD_VAR 0 4
24742: PUSH
24743: LD_VAR 0 8
24747: PUSH
24748: LD_INT 6
24750: LESS
24751: AND
24752: IFFALSE 24940
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
24754: LD_ADDR_VAR 0 9
24758: PUSH
24759: LD_VAR 0 4
24763: PUSH
24764: LD_VAR 0 8
24768: PUSH
24769: LD_VAR 0 7
24773: UNION
24774: DIFF
24775: PPUSH
24776: LD_INT 4
24778: PPUSH
24779: CALL 85311 0 2
24783: ST_TO_ADDR
// p := [ ] ;
24784: LD_ADDR_VAR 0 11
24788: PUSH
24789: EMPTY
24790: ST_TO_ADDR
// if sort then
24791: LD_VAR 0 9
24795: IFFALSE 24911
// for i = 1 to 6 - sci do
24797: LD_ADDR_VAR 0 3
24801: PUSH
24802: DOUBLE
24803: LD_INT 1
24805: DEC
24806: ST_TO_ADDR
24807: LD_INT 6
24809: PUSH
24810: LD_VAR 0 8
24814: MINUS
24815: PUSH
24816: FOR_TO
24817: IFFALSE 24909
// begin if i = sort then
24819: LD_VAR 0 3
24823: PUSH
24824: LD_VAR 0 9
24828: EQUAL
24829: IFFALSE 24833
// break ;
24831: GO 24909
// if GetClass ( i ) = 4 then
24833: LD_VAR 0 3
24837: PPUSH
24838: CALL_OW 257
24842: PUSH
24843: LD_INT 4
24845: EQUAL
24846: IFFALSE 24850
// continue ;
24848: GO 24816
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24850: LD_ADDR_VAR 0 11
24854: PUSH
24855: LD_VAR 0 11
24859: PPUSH
24860: LD_VAR 0 11
24864: PUSH
24865: LD_INT 1
24867: PLUS
24868: PPUSH
24869: LD_VAR 0 9
24873: PUSH
24874: LD_VAR 0 3
24878: ARRAY
24879: PPUSH
24880: CALL_OW 2
24884: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24885: LD_ADDR_VAR 0 4
24889: PUSH
24890: LD_VAR 0 4
24894: PUSH
24895: LD_VAR 0 9
24899: PUSH
24900: LD_VAR 0 3
24904: ARRAY
24905: DIFF
24906: ST_TO_ADDR
// end ;
24907: GO 24816
24909: POP
24910: POP
// if p then
24911: LD_VAR 0 11
24915: IFFALSE 24940
// result := Replace ( result , 4 , p ) ;
24917: LD_ADDR_VAR 0 2
24921: PUSH
24922: LD_VAR 0 2
24926: PPUSH
24927: LD_INT 4
24929: PPUSH
24930: LD_VAR 0 11
24934: PPUSH
24935: CALL_OW 1
24939: ST_TO_ADDR
// end ; if tmp and mech < 6 then
24940: LD_VAR 0 4
24944: PUSH
24945: LD_VAR 0 7
24949: PUSH
24950: LD_INT 6
24952: LESS
24953: AND
24954: IFFALSE 25142
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
24956: LD_ADDR_VAR 0 9
24960: PUSH
24961: LD_VAR 0 4
24965: PUSH
24966: LD_VAR 0 8
24970: PUSH
24971: LD_VAR 0 7
24975: UNION
24976: DIFF
24977: PPUSH
24978: LD_INT 3
24980: PPUSH
24981: CALL 85311 0 2
24985: ST_TO_ADDR
// p := [ ] ;
24986: LD_ADDR_VAR 0 11
24990: PUSH
24991: EMPTY
24992: ST_TO_ADDR
// if sort then
24993: LD_VAR 0 9
24997: IFFALSE 25113
// for i = 1 to 6 - mech do
24999: LD_ADDR_VAR 0 3
25003: PUSH
25004: DOUBLE
25005: LD_INT 1
25007: DEC
25008: ST_TO_ADDR
25009: LD_INT 6
25011: PUSH
25012: LD_VAR 0 7
25016: MINUS
25017: PUSH
25018: FOR_TO
25019: IFFALSE 25111
// begin if i = sort then
25021: LD_VAR 0 3
25025: PUSH
25026: LD_VAR 0 9
25030: EQUAL
25031: IFFALSE 25035
// break ;
25033: GO 25111
// if GetClass ( i ) = 3 then
25035: LD_VAR 0 3
25039: PPUSH
25040: CALL_OW 257
25044: PUSH
25045: LD_INT 3
25047: EQUAL
25048: IFFALSE 25052
// continue ;
25050: GO 25018
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25052: LD_ADDR_VAR 0 11
25056: PUSH
25057: LD_VAR 0 11
25061: PPUSH
25062: LD_VAR 0 11
25066: PUSH
25067: LD_INT 1
25069: PLUS
25070: PPUSH
25071: LD_VAR 0 9
25075: PUSH
25076: LD_VAR 0 3
25080: ARRAY
25081: PPUSH
25082: CALL_OW 2
25086: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25087: LD_ADDR_VAR 0 4
25091: PUSH
25092: LD_VAR 0 4
25096: PUSH
25097: LD_VAR 0 9
25101: PUSH
25102: LD_VAR 0 3
25106: ARRAY
25107: DIFF
25108: ST_TO_ADDR
// end ;
25109: GO 25018
25111: POP
25112: POP
// if p then
25113: LD_VAR 0 11
25117: IFFALSE 25142
// result := Replace ( result , 3 , p ) ;
25119: LD_ADDR_VAR 0 2
25123: PUSH
25124: LD_VAR 0 2
25128: PPUSH
25129: LD_INT 3
25131: PPUSH
25132: LD_VAR 0 11
25136: PPUSH
25137: CALL_OW 1
25141: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
25142: LD_VAR 0 4
25146: PUSH
25147: LD_INT 6
25149: GREATER
25150: PUSH
25151: LD_VAR 0 6
25155: PUSH
25156: LD_INT 6
25158: LESS
25159: AND
25160: IFFALSE 25354
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
25162: LD_ADDR_VAR 0 9
25166: PUSH
25167: LD_VAR 0 4
25171: PUSH
25172: LD_VAR 0 8
25176: PUSH
25177: LD_VAR 0 7
25181: UNION
25182: PUSH
25183: LD_VAR 0 6
25187: UNION
25188: DIFF
25189: PPUSH
25190: LD_INT 2
25192: PPUSH
25193: CALL 85311 0 2
25197: ST_TO_ADDR
// p := [ ] ;
25198: LD_ADDR_VAR 0 11
25202: PUSH
25203: EMPTY
25204: ST_TO_ADDR
// if sort then
25205: LD_VAR 0 9
25209: IFFALSE 25325
// for i = 1 to 6 - eng do
25211: LD_ADDR_VAR 0 3
25215: PUSH
25216: DOUBLE
25217: LD_INT 1
25219: DEC
25220: ST_TO_ADDR
25221: LD_INT 6
25223: PUSH
25224: LD_VAR 0 6
25228: MINUS
25229: PUSH
25230: FOR_TO
25231: IFFALSE 25323
// begin if i = sort then
25233: LD_VAR 0 3
25237: PUSH
25238: LD_VAR 0 9
25242: EQUAL
25243: IFFALSE 25247
// break ;
25245: GO 25323
// if GetClass ( i ) = 2 then
25247: LD_VAR 0 3
25251: PPUSH
25252: CALL_OW 257
25256: PUSH
25257: LD_INT 2
25259: EQUAL
25260: IFFALSE 25264
// continue ;
25262: GO 25230
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25264: LD_ADDR_VAR 0 11
25268: PUSH
25269: LD_VAR 0 11
25273: PPUSH
25274: LD_VAR 0 11
25278: PUSH
25279: LD_INT 1
25281: PLUS
25282: PPUSH
25283: LD_VAR 0 9
25287: PUSH
25288: LD_VAR 0 3
25292: ARRAY
25293: PPUSH
25294: CALL_OW 2
25298: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25299: LD_ADDR_VAR 0 4
25303: PUSH
25304: LD_VAR 0 4
25308: PUSH
25309: LD_VAR 0 9
25313: PUSH
25314: LD_VAR 0 3
25318: ARRAY
25319: DIFF
25320: ST_TO_ADDR
// end ;
25321: GO 25230
25323: POP
25324: POP
// if p then
25325: LD_VAR 0 11
25329: IFFALSE 25354
// result := Replace ( result , 2 , p ) ;
25331: LD_ADDR_VAR 0 2
25335: PUSH
25336: LD_VAR 0 2
25340: PPUSH
25341: LD_INT 2
25343: PPUSH
25344: LD_VAR 0 11
25348: PPUSH
25349: CALL_OW 1
25353: ST_TO_ADDR
// end ; exit ;
25354: GO 26742
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
25356: LD_EXP 77
25360: PUSH
25361: LD_EXP 76
25365: PUSH
25366: LD_VAR 0 1
25370: ARRAY
25371: ARRAY
25372: NOT
25373: PUSH
25374: LD_EXP 50
25378: PUSH
25379: LD_VAR 0 1
25383: ARRAY
25384: PPUSH
25385: LD_INT 30
25387: PUSH
25388: LD_INT 3
25390: PUSH
25391: EMPTY
25392: LIST
25393: LIST
25394: PPUSH
25395: CALL_OW 72
25399: AND
25400: PUSH
25401: LD_EXP 55
25405: PUSH
25406: LD_VAR 0 1
25410: ARRAY
25411: AND
25412: IFFALSE 26020
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
25414: LD_ADDR_EXP 92
25418: PUSH
25419: LD_EXP 92
25423: PPUSH
25424: LD_VAR 0 1
25428: PPUSH
25429: LD_INT 5
25431: PPUSH
25432: CALL_OW 1
25436: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
25437: LD_ADDR_VAR 0 2
25441: PUSH
25442: LD_INT 0
25444: PUSH
25445: LD_INT 0
25447: PUSH
25448: LD_INT 0
25450: PUSH
25451: LD_INT 0
25453: PUSH
25454: EMPTY
25455: LIST
25456: LIST
25457: LIST
25458: LIST
25459: ST_TO_ADDR
// if sci > 1 then
25460: LD_VAR 0 8
25464: PUSH
25465: LD_INT 1
25467: GREATER
25468: IFFALSE 25496
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
25470: LD_ADDR_VAR 0 4
25474: PUSH
25475: LD_VAR 0 4
25479: PUSH
25480: LD_VAR 0 8
25484: PUSH
25485: LD_VAR 0 8
25489: PUSH
25490: LD_INT 1
25492: ARRAY
25493: DIFF
25494: DIFF
25495: ST_TO_ADDR
// if tmp and not sci then
25496: LD_VAR 0 4
25500: PUSH
25501: LD_VAR 0 8
25505: NOT
25506: AND
25507: IFFALSE 25576
// begin sort := SortBySkill ( tmp , 4 ) ;
25509: LD_ADDR_VAR 0 9
25513: PUSH
25514: LD_VAR 0 4
25518: PPUSH
25519: LD_INT 4
25521: PPUSH
25522: CALL 85311 0 2
25526: ST_TO_ADDR
// if sort then
25527: LD_VAR 0 9
25531: IFFALSE 25547
// p := sort [ 1 ] ;
25533: LD_ADDR_VAR 0 11
25537: PUSH
25538: LD_VAR 0 9
25542: PUSH
25543: LD_INT 1
25545: ARRAY
25546: ST_TO_ADDR
// if p then
25547: LD_VAR 0 11
25551: IFFALSE 25576
// result := Replace ( result , 4 , p ) ;
25553: LD_ADDR_VAR 0 2
25557: PUSH
25558: LD_VAR 0 2
25562: PPUSH
25563: LD_INT 4
25565: PPUSH
25566: LD_VAR 0 11
25570: PPUSH
25571: CALL_OW 1
25575: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
25576: LD_ADDR_VAR 0 4
25580: PUSH
25581: LD_VAR 0 4
25585: PUSH
25586: LD_VAR 0 7
25590: DIFF
25591: ST_TO_ADDR
// if tmp and mech < 6 then
25592: LD_VAR 0 4
25596: PUSH
25597: LD_VAR 0 7
25601: PUSH
25602: LD_INT 6
25604: LESS
25605: AND
25606: IFFALSE 25794
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
25608: LD_ADDR_VAR 0 9
25612: PUSH
25613: LD_VAR 0 4
25617: PUSH
25618: LD_VAR 0 8
25622: PUSH
25623: LD_VAR 0 7
25627: UNION
25628: DIFF
25629: PPUSH
25630: LD_INT 3
25632: PPUSH
25633: CALL 85311 0 2
25637: ST_TO_ADDR
// p := [ ] ;
25638: LD_ADDR_VAR 0 11
25642: PUSH
25643: EMPTY
25644: ST_TO_ADDR
// if sort then
25645: LD_VAR 0 9
25649: IFFALSE 25765
// for i = 1 to 6 - mech do
25651: LD_ADDR_VAR 0 3
25655: PUSH
25656: DOUBLE
25657: LD_INT 1
25659: DEC
25660: ST_TO_ADDR
25661: LD_INT 6
25663: PUSH
25664: LD_VAR 0 7
25668: MINUS
25669: PUSH
25670: FOR_TO
25671: IFFALSE 25763
// begin if i = sort then
25673: LD_VAR 0 3
25677: PUSH
25678: LD_VAR 0 9
25682: EQUAL
25683: IFFALSE 25687
// break ;
25685: GO 25763
// if GetClass ( i ) = 3 then
25687: LD_VAR 0 3
25691: PPUSH
25692: CALL_OW 257
25696: PUSH
25697: LD_INT 3
25699: EQUAL
25700: IFFALSE 25704
// continue ;
25702: GO 25670
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25704: LD_ADDR_VAR 0 11
25708: PUSH
25709: LD_VAR 0 11
25713: PPUSH
25714: LD_VAR 0 11
25718: PUSH
25719: LD_INT 1
25721: PLUS
25722: PPUSH
25723: LD_VAR 0 9
25727: PUSH
25728: LD_VAR 0 3
25732: ARRAY
25733: PPUSH
25734: CALL_OW 2
25738: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25739: LD_ADDR_VAR 0 4
25743: PUSH
25744: LD_VAR 0 4
25748: PUSH
25749: LD_VAR 0 9
25753: PUSH
25754: LD_VAR 0 3
25758: ARRAY
25759: DIFF
25760: ST_TO_ADDR
// end ;
25761: GO 25670
25763: POP
25764: POP
// if p then
25765: LD_VAR 0 11
25769: IFFALSE 25794
// result := Replace ( result , 3 , p ) ;
25771: LD_ADDR_VAR 0 2
25775: PUSH
25776: LD_VAR 0 2
25780: PPUSH
25781: LD_INT 3
25783: PPUSH
25784: LD_VAR 0 11
25788: PPUSH
25789: CALL_OW 1
25793: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
25794: LD_ADDR_VAR 0 4
25798: PUSH
25799: LD_VAR 0 4
25803: PUSH
25804: LD_VAR 0 6
25808: DIFF
25809: ST_TO_ADDR
// if tmp and eng < 6 then
25810: LD_VAR 0 4
25814: PUSH
25815: LD_VAR 0 6
25819: PUSH
25820: LD_INT 6
25822: LESS
25823: AND
25824: IFFALSE 26018
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
25826: LD_ADDR_VAR 0 9
25830: PUSH
25831: LD_VAR 0 4
25835: PUSH
25836: LD_VAR 0 8
25840: PUSH
25841: LD_VAR 0 7
25845: UNION
25846: PUSH
25847: LD_VAR 0 6
25851: UNION
25852: DIFF
25853: PPUSH
25854: LD_INT 2
25856: PPUSH
25857: CALL 85311 0 2
25861: ST_TO_ADDR
// p := [ ] ;
25862: LD_ADDR_VAR 0 11
25866: PUSH
25867: EMPTY
25868: ST_TO_ADDR
// if sort then
25869: LD_VAR 0 9
25873: IFFALSE 25989
// for i = 1 to 6 - eng do
25875: LD_ADDR_VAR 0 3
25879: PUSH
25880: DOUBLE
25881: LD_INT 1
25883: DEC
25884: ST_TO_ADDR
25885: LD_INT 6
25887: PUSH
25888: LD_VAR 0 6
25892: MINUS
25893: PUSH
25894: FOR_TO
25895: IFFALSE 25987
// begin if i = sort then
25897: LD_VAR 0 3
25901: PUSH
25902: LD_VAR 0 9
25906: EQUAL
25907: IFFALSE 25911
// break ;
25909: GO 25987
// if GetClass ( i ) = 2 then
25911: LD_VAR 0 3
25915: PPUSH
25916: CALL_OW 257
25920: PUSH
25921: LD_INT 2
25923: EQUAL
25924: IFFALSE 25928
// continue ;
25926: GO 25894
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25928: LD_ADDR_VAR 0 11
25932: PUSH
25933: LD_VAR 0 11
25937: PPUSH
25938: LD_VAR 0 11
25942: PUSH
25943: LD_INT 1
25945: PLUS
25946: PPUSH
25947: LD_VAR 0 9
25951: PUSH
25952: LD_VAR 0 3
25956: ARRAY
25957: PPUSH
25958: CALL_OW 2
25962: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25963: LD_ADDR_VAR 0 4
25967: PUSH
25968: LD_VAR 0 4
25972: PUSH
25973: LD_VAR 0 9
25977: PUSH
25978: LD_VAR 0 3
25982: ARRAY
25983: DIFF
25984: ST_TO_ADDR
// end ;
25985: GO 25894
25987: POP
25988: POP
// if p then
25989: LD_VAR 0 11
25993: IFFALSE 26018
// result := Replace ( result , 2 , p ) ;
25995: LD_ADDR_VAR 0 2
25999: PUSH
26000: LD_VAR 0 2
26004: PPUSH
26005: LD_INT 2
26007: PPUSH
26008: LD_VAR 0 11
26012: PPUSH
26013: CALL_OW 1
26017: ST_TO_ADDR
// end ; exit ;
26018: GO 26742
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
26020: LD_EXP 77
26024: PUSH
26025: LD_EXP 76
26029: PUSH
26030: LD_VAR 0 1
26034: ARRAY
26035: ARRAY
26036: NOT
26037: PUSH
26038: LD_EXP 50
26042: PUSH
26043: LD_VAR 0 1
26047: ARRAY
26048: PPUSH
26049: LD_INT 30
26051: PUSH
26052: LD_INT 3
26054: PUSH
26055: EMPTY
26056: LIST
26057: LIST
26058: PPUSH
26059: CALL_OW 72
26063: AND
26064: PUSH
26065: LD_EXP 55
26069: PUSH
26070: LD_VAR 0 1
26074: ARRAY
26075: NOT
26076: AND
26077: IFFALSE 26742
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
26079: LD_ADDR_EXP 92
26083: PUSH
26084: LD_EXP 92
26088: PPUSH
26089: LD_VAR 0 1
26093: PPUSH
26094: LD_INT 6
26096: PPUSH
26097: CALL_OW 1
26101: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
26102: LD_ADDR_VAR 0 2
26106: PUSH
26107: LD_INT 0
26109: PUSH
26110: LD_INT 0
26112: PUSH
26113: LD_INT 0
26115: PUSH
26116: LD_INT 0
26118: PUSH
26119: EMPTY
26120: LIST
26121: LIST
26122: LIST
26123: LIST
26124: ST_TO_ADDR
// if sci >= 1 then
26125: LD_VAR 0 8
26129: PUSH
26130: LD_INT 1
26132: GREATEREQUAL
26133: IFFALSE 26155
// tmp := tmp diff sci [ 1 ] ;
26135: LD_ADDR_VAR 0 4
26139: PUSH
26140: LD_VAR 0 4
26144: PUSH
26145: LD_VAR 0 8
26149: PUSH
26150: LD_INT 1
26152: ARRAY
26153: DIFF
26154: ST_TO_ADDR
// if tmp and not sci then
26155: LD_VAR 0 4
26159: PUSH
26160: LD_VAR 0 8
26164: NOT
26165: AND
26166: IFFALSE 26235
// begin sort := SortBySkill ( tmp , 4 ) ;
26168: LD_ADDR_VAR 0 9
26172: PUSH
26173: LD_VAR 0 4
26177: PPUSH
26178: LD_INT 4
26180: PPUSH
26181: CALL 85311 0 2
26185: ST_TO_ADDR
// if sort then
26186: LD_VAR 0 9
26190: IFFALSE 26206
// p := sort [ 1 ] ;
26192: LD_ADDR_VAR 0 11
26196: PUSH
26197: LD_VAR 0 9
26201: PUSH
26202: LD_INT 1
26204: ARRAY
26205: ST_TO_ADDR
// if p then
26206: LD_VAR 0 11
26210: IFFALSE 26235
// result := Replace ( result , 4 , p ) ;
26212: LD_ADDR_VAR 0 2
26216: PUSH
26217: LD_VAR 0 2
26221: PPUSH
26222: LD_INT 4
26224: PPUSH
26225: LD_VAR 0 11
26229: PPUSH
26230: CALL_OW 1
26234: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
26235: LD_ADDR_VAR 0 4
26239: PUSH
26240: LD_VAR 0 4
26244: PUSH
26245: LD_VAR 0 7
26249: DIFF
26250: ST_TO_ADDR
// if tmp and mech < 6 then
26251: LD_VAR 0 4
26255: PUSH
26256: LD_VAR 0 7
26260: PUSH
26261: LD_INT 6
26263: LESS
26264: AND
26265: IFFALSE 26447
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
26267: LD_ADDR_VAR 0 9
26271: PUSH
26272: LD_VAR 0 4
26276: PUSH
26277: LD_VAR 0 7
26281: DIFF
26282: PPUSH
26283: LD_INT 3
26285: PPUSH
26286: CALL 85311 0 2
26290: ST_TO_ADDR
// p := [ ] ;
26291: LD_ADDR_VAR 0 11
26295: PUSH
26296: EMPTY
26297: ST_TO_ADDR
// if sort then
26298: LD_VAR 0 9
26302: IFFALSE 26418
// for i = 1 to 6 - mech do
26304: LD_ADDR_VAR 0 3
26308: PUSH
26309: DOUBLE
26310: LD_INT 1
26312: DEC
26313: ST_TO_ADDR
26314: LD_INT 6
26316: PUSH
26317: LD_VAR 0 7
26321: MINUS
26322: PUSH
26323: FOR_TO
26324: IFFALSE 26416
// begin if i = sort then
26326: LD_VAR 0 3
26330: PUSH
26331: LD_VAR 0 9
26335: EQUAL
26336: IFFALSE 26340
// break ;
26338: GO 26416
// if GetClass ( i ) = 3 then
26340: LD_VAR 0 3
26344: PPUSH
26345: CALL_OW 257
26349: PUSH
26350: LD_INT 3
26352: EQUAL
26353: IFFALSE 26357
// continue ;
26355: GO 26323
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26357: LD_ADDR_VAR 0 11
26361: PUSH
26362: LD_VAR 0 11
26366: PPUSH
26367: LD_VAR 0 11
26371: PUSH
26372: LD_INT 1
26374: PLUS
26375: PPUSH
26376: LD_VAR 0 9
26380: PUSH
26381: LD_VAR 0 3
26385: ARRAY
26386: PPUSH
26387: CALL_OW 2
26391: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26392: LD_ADDR_VAR 0 4
26396: PUSH
26397: LD_VAR 0 4
26401: PUSH
26402: LD_VAR 0 9
26406: PUSH
26407: LD_VAR 0 3
26411: ARRAY
26412: DIFF
26413: ST_TO_ADDR
// end ;
26414: GO 26323
26416: POP
26417: POP
// if p then
26418: LD_VAR 0 11
26422: IFFALSE 26447
// result := Replace ( result , 3 , p ) ;
26424: LD_ADDR_VAR 0 2
26428: PUSH
26429: LD_VAR 0 2
26433: PPUSH
26434: LD_INT 3
26436: PPUSH
26437: LD_VAR 0 11
26441: PPUSH
26442: CALL_OW 1
26446: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
26447: LD_ADDR_VAR 0 4
26451: PUSH
26452: LD_VAR 0 4
26456: PUSH
26457: LD_VAR 0 6
26461: DIFF
26462: ST_TO_ADDR
// if tmp and eng < 4 then
26463: LD_VAR 0 4
26467: PUSH
26468: LD_VAR 0 6
26472: PUSH
26473: LD_INT 4
26475: LESS
26476: AND
26477: IFFALSE 26667
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
26479: LD_ADDR_VAR 0 9
26483: PUSH
26484: LD_VAR 0 4
26488: PUSH
26489: LD_VAR 0 7
26493: PUSH
26494: LD_VAR 0 6
26498: UNION
26499: DIFF
26500: PPUSH
26501: LD_INT 2
26503: PPUSH
26504: CALL 85311 0 2
26508: ST_TO_ADDR
// p := [ ] ;
26509: LD_ADDR_VAR 0 11
26513: PUSH
26514: EMPTY
26515: ST_TO_ADDR
// if sort then
26516: LD_VAR 0 9
26520: IFFALSE 26636
// for i = 1 to 4 - eng do
26522: LD_ADDR_VAR 0 3
26526: PUSH
26527: DOUBLE
26528: LD_INT 1
26530: DEC
26531: ST_TO_ADDR
26532: LD_INT 4
26534: PUSH
26535: LD_VAR 0 6
26539: MINUS
26540: PUSH
26541: FOR_TO
26542: IFFALSE 26634
// begin if i = sort then
26544: LD_VAR 0 3
26548: PUSH
26549: LD_VAR 0 9
26553: EQUAL
26554: IFFALSE 26558
// break ;
26556: GO 26634
// if GetClass ( i ) = 2 then
26558: LD_VAR 0 3
26562: PPUSH
26563: CALL_OW 257
26567: PUSH
26568: LD_INT 2
26570: EQUAL
26571: IFFALSE 26575
// continue ;
26573: GO 26541
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26575: LD_ADDR_VAR 0 11
26579: PUSH
26580: LD_VAR 0 11
26584: PPUSH
26585: LD_VAR 0 11
26589: PUSH
26590: LD_INT 1
26592: PLUS
26593: PPUSH
26594: LD_VAR 0 9
26598: PUSH
26599: LD_VAR 0 3
26603: ARRAY
26604: PPUSH
26605: CALL_OW 2
26609: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26610: LD_ADDR_VAR 0 4
26614: PUSH
26615: LD_VAR 0 4
26619: PUSH
26620: LD_VAR 0 9
26624: PUSH
26625: LD_VAR 0 3
26629: ARRAY
26630: DIFF
26631: ST_TO_ADDR
// end ;
26632: GO 26541
26634: POP
26635: POP
// if p then
26636: LD_VAR 0 11
26640: IFFALSE 26665
// result := Replace ( result , 2 , p ) ;
26642: LD_ADDR_VAR 0 2
26646: PUSH
26647: LD_VAR 0 2
26651: PPUSH
26652: LD_INT 2
26654: PPUSH
26655: LD_VAR 0 11
26659: PPUSH
26660: CALL_OW 1
26664: ST_TO_ADDR
// end else
26665: GO 26711
// for i = eng downto 5 do
26667: LD_ADDR_VAR 0 3
26671: PUSH
26672: DOUBLE
26673: LD_VAR 0 6
26677: INC
26678: ST_TO_ADDR
26679: LD_INT 5
26681: PUSH
26682: FOR_DOWNTO
26683: IFFALSE 26709
// tmp := tmp union eng [ i ] ;
26685: LD_ADDR_VAR 0 4
26689: PUSH
26690: LD_VAR 0 4
26694: PUSH
26695: LD_VAR 0 6
26699: PUSH
26700: LD_VAR 0 3
26704: ARRAY
26705: UNION
26706: ST_TO_ADDR
26707: GO 26682
26709: POP
26710: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
26711: LD_ADDR_VAR 0 2
26715: PUSH
26716: LD_VAR 0 2
26720: PPUSH
26721: LD_INT 1
26723: PPUSH
26724: LD_VAR 0 4
26728: PUSH
26729: LD_VAR 0 5
26733: DIFF
26734: PPUSH
26735: CALL_OW 1
26739: ST_TO_ADDR
// exit ;
26740: GO 26742
// end ; end ;
26742: LD_VAR 0 2
26746: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
26747: LD_INT 0
26749: PPUSH
26750: PPUSH
26751: PPUSH
// if not mc_bases then
26752: LD_EXP 50
26756: NOT
26757: IFFALSE 26761
// exit ;
26759: GO 26903
// for i = 1 to mc_bases do
26761: LD_ADDR_VAR 0 2
26765: PUSH
26766: DOUBLE
26767: LD_INT 1
26769: DEC
26770: ST_TO_ADDR
26771: LD_EXP 50
26775: PUSH
26776: FOR_TO
26777: IFFALSE 26894
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
26779: LD_ADDR_VAR 0 3
26783: PUSH
26784: LD_EXP 50
26788: PUSH
26789: LD_VAR 0 2
26793: ARRAY
26794: PPUSH
26795: LD_INT 21
26797: PUSH
26798: LD_INT 3
26800: PUSH
26801: EMPTY
26802: LIST
26803: LIST
26804: PUSH
26805: LD_INT 3
26807: PUSH
26808: LD_INT 2
26810: PUSH
26811: LD_INT 30
26813: PUSH
26814: LD_INT 29
26816: PUSH
26817: EMPTY
26818: LIST
26819: LIST
26820: PUSH
26821: LD_INT 30
26823: PUSH
26824: LD_INT 30
26826: PUSH
26827: EMPTY
26828: LIST
26829: LIST
26830: PUSH
26831: EMPTY
26832: LIST
26833: LIST
26834: LIST
26835: PUSH
26836: EMPTY
26837: LIST
26838: LIST
26839: PUSH
26840: LD_INT 3
26842: PUSH
26843: LD_INT 24
26845: PUSH
26846: LD_INT 1000
26848: PUSH
26849: EMPTY
26850: LIST
26851: LIST
26852: PUSH
26853: EMPTY
26854: LIST
26855: LIST
26856: PUSH
26857: EMPTY
26858: LIST
26859: LIST
26860: LIST
26861: PPUSH
26862: CALL_OW 72
26866: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
26867: LD_ADDR_EXP 51
26871: PUSH
26872: LD_EXP 51
26876: PPUSH
26877: LD_VAR 0 2
26881: PPUSH
26882: LD_VAR 0 3
26886: PPUSH
26887: CALL_OW 1
26891: ST_TO_ADDR
// end ;
26892: GO 26776
26894: POP
26895: POP
// RaiseSailEvent ( 101 ) ;
26896: LD_INT 101
26898: PPUSH
26899: CALL_OW 427
// end ;
26903: LD_VAR 0 1
26907: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
26908: LD_INT 0
26910: PPUSH
26911: PPUSH
26912: PPUSH
26913: PPUSH
26914: PPUSH
26915: PPUSH
26916: PPUSH
// if not mc_bases then
26917: LD_EXP 50
26921: NOT
26922: IFFALSE 26926
// exit ;
26924: GO 27488
// for i = 1 to mc_bases do
26926: LD_ADDR_VAR 0 2
26930: PUSH
26931: DOUBLE
26932: LD_INT 1
26934: DEC
26935: ST_TO_ADDR
26936: LD_EXP 50
26940: PUSH
26941: FOR_TO
26942: IFFALSE 27479
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
26944: LD_ADDR_VAR 0 5
26948: PUSH
26949: LD_EXP 50
26953: PUSH
26954: LD_VAR 0 2
26958: ARRAY
26959: PUSH
26960: LD_EXP 79
26964: PUSH
26965: LD_VAR 0 2
26969: ARRAY
26970: UNION
26971: PPUSH
26972: LD_INT 21
26974: PUSH
26975: LD_INT 1
26977: PUSH
26978: EMPTY
26979: LIST
26980: LIST
26981: PUSH
26982: LD_INT 1
26984: PUSH
26985: LD_INT 3
26987: PUSH
26988: LD_INT 54
26990: PUSH
26991: EMPTY
26992: LIST
26993: PUSH
26994: EMPTY
26995: LIST
26996: LIST
26997: PUSH
26998: LD_INT 3
27000: PUSH
27001: LD_INT 24
27003: PUSH
27004: LD_INT 1000
27006: PUSH
27007: EMPTY
27008: LIST
27009: LIST
27010: PUSH
27011: EMPTY
27012: LIST
27013: LIST
27014: PUSH
27015: EMPTY
27016: LIST
27017: LIST
27018: LIST
27019: PUSH
27020: EMPTY
27021: LIST
27022: LIST
27023: PPUSH
27024: CALL_OW 72
27028: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
27029: LD_ADDR_VAR 0 6
27033: PUSH
27034: LD_EXP 50
27038: PUSH
27039: LD_VAR 0 2
27043: ARRAY
27044: PPUSH
27045: LD_INT 21
27047: PUSH
27048: LD_INT 1
27050: PUSH
27051: EMPTY
27052: LIST
27053: LIST
27054: PUSH
27055: LD_INT 1
27057: PUSH
27058: LD_INT 3
27060: PUSH
27061: LD_INT 54
27063: PUSH
27064: EMPTY
27065: LIST
27066: PUSH
27067: EMPTY
27068: LIST
27069: LIST
27070: PUSH
27071: LD_INT 3
27073: PUSH
27074: LD_INT 24
27076: PUSH
27077: LD_INT 250
27079: PUSH
27080: EMPTY
27081: LIST
27082: LIST
27083: PUSH
27084: EMPTY
27085: LIST
27086: LIST
27087: PUSH
27088: EMPTY
27089: LIST
27090: LIST
27091: LIST
27092: PUSH
27093: EMPTY
27094: LIST
27095: LIST
27096: PPUSH
27097: CALL_OW 72
27101: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
27102: LD_ADDR_VAR 0 7
27106: PUSH
27107: LD_VAR 0 5
27111: PUSH
27112: LD_VAR 0 6
27116: DIFF
27117: ST_TO_ADDR
// if not need_heal_1 then
27118: LD_VAR 0 6
27122: NOT
27123: IFFALSE 27156
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
27125: LD_ADDR_EXP 53
27129: PUSH
27130: LD_EXP 53
27134: PPUSH
27135: LD_VAR 0 2
27139: PUSH
27140: LD_INT 1
27142: PUSH
27143: EMPTY
27144: LIST
27145: LIST
27146: PPUSH
27147: EMPTY
27148: PPUSH
27149: CALL 54067 0 3
27153: ST_TO_ADDR
27154: GO 27226
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
27156: LD_ADDR_EXP 53
27160: PUSH
27161: LD_EXP 53
27165: PPUSH
27166: LD_VAR 0 2
27170: PUSH
27171: LD_INT 1
27173: PUSH
27174: EMPTY
27175: LIST
27176: LIST
27177: PPUSH
27178: LD_EXP 53
27182: PUSH
27183: LD_VAR 0 2
27187: ARRAY
27188: PUSH
27189: LD_INT 1
27191: ARRAY
27192: PPUSH
27193: LD_INT 3
27195: PUSH
27196: LD_INT 24
27198: PUSH
27199: LD_INT 1000
27201: PUSH
27202: EMPTY
27203: LIST
27204: LIST
27205: PUSH
27206: EMPTY
27207: LIST
27208: LIST
27209: PPUSH
27210: CALL_OW 72
27214: PUSH
27215: LD_VAR 0 6
27219: UNION
27220: PPUSH
27221: CALL 54067 0 3
27225: ST_TO_ADDR
// if not need_heal_2 then
27226: LD_VAR 0 7
27230: NOT
27231: IFFALSE 27264
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
27233: LD_ADDR_EXP 53
27237: PUSH
27238: LD_EXP 53
27242: PPUSH
27243: LD_VAR 0 2
27247: PUSH
27248: LD_INT 2
27250: PUSH
27251: EMPTY
27252: LIST
27253: LIST
27254: PPUSH
27255: EMPTY
27256: PPUSH
27257: CALL 54067 0 3
27261: ST_TO_ADDR
27262: GO 27296
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
27264: LD_ADDR_EXP 53
27268: PUSH
27269: LD_EXP 53
27273: PPUSH
27274: LD_VAR 0 2
27278: PUSH
27279: LD_INT 2
27281: PUSH
27282: EMPTY
27283: LIST
27284: LIST
27285: PPUSH
27286: LD_VAR 0 7
27290: PPUSH
27291: CALL 54067 0 3
27295: ST_TO_ADDR
// if need_heal_2 then
27296: LD_VAR 0 7
27300: IFFALSE 27461
// for j in need_heal_2 do
27302: LD_ADDR_VAR 0 3
27306: PUSH
27307: LD_VAR 0 7
27311: PUSH
27312: FOR_IN
27313: IFFALSE 27459
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
27315: LD_ADDR_VAR 0 5
27319: PUSH
27320: LD_EXP 50
27324: PUSH
27325: LD_VAR 0 2
27329: ARRAY
27330: PPUSH
27331: LD_INT 2
27333: PUSH
27334: LD_INT 30
27336: PUSH
27337: LD_INT 6
27339: PUSH
27340: EMPTY
27341: LIST
27342: LIST
27343: PUSH
27344: LD_INT 30
27346: PUSH
27347: LD_INT 7
27349: PUSH
27350: EMPTY
27351: LIST
27352: LIST
27353: PUSH
27354: LD_INT 30
27356: PUSH
27357: LD_INT 8
27359: PUSH
27360: EMPTY
27361: LIST
27362: LIST
27363: PUSH
27364: LD_INT 30
27366: PUSH
27367: LD_INT 0
27369: PUSH
27370: EMPTY
27371: LIST
27372: LIST
27373: PUSH
27374: LD_INT 30
27376: PUSH
27377: LD_INT 1
27379: PUSH
27380: EMPTY
27381: LIST
27382: LIST
27383: PUSH
27384: EMPTY
27385: LIST
27386: LIST
27387: LIST
27388: LIST
27389: LIST
27390: LIST
27391: PPUSH
27392: CALL_OW 72
27396: ST_TO_ADDR
// if tmp then
27397: LD_VAR 0 5
27401: IFFALSE 27457
// begin k := NearestUnitToUnit ( tmp , j ) ;
27403: LD_ADDR_VAR 0 4
27407: PUSH
27408: LD_VAR 0 5
27412: PPUSH
27413: LD_VAR 0 3
27417: PPUSH
27418: CALL_OW 74
27422: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
27423: LD_VAR 0 3
27427: PPUSH
27428: LD_VAR 0 4
27432: PPUSH
27433: CALL_OW 296
27437: PUSH
27438: LD_INT 5
27440: GREATER
27441: IFFALSE 27457
// ComMoveToNearbyEntrance ( j , k ) ;
27443: LD_VAR 0 3
27447: PPUSH
27448: LD_VAR 0 4
27452: PPUSH
27453: CALL 87684 0 2
// end ; end ;
27457: GO 27312
27459: POP
27460: POP
// if not need_heal_1 and not need_heal_2 then
27461: LD_VAR 0 6
27465: NOT
27466: PUSH
27467: LD_VAR 0 7
27471: NOT
27472: AND
27473: IFFALSE 27477
// continue ;
27475: GO 26941
// end ;
27477: GO 26941
27479: POP
27480: POP
// RaiseSailEvent ( 102 ) ;
27481: LD_INT 102
27483: PPUSH
27484: CALL_OW 427
// end ;
27488: LD_VAR 0 1
27492: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
27493: LD_INT 0
27495: PPUSH
27496: PPUSH
27497: PPUSH
27498: PPUSH
27499: PPUSH
27500: PPUSH
27501: PPUSH
27502: PPUSH
// if not mc_bases then
27503: LD_EXP 50
27507: NOT
27508: IFFALSE 27512
// exit ;
27510: GO 28423
// for i = 1 to mc_bases do
27512: LD_ADDR_VAR 0 2
27516: PUSH
27517: DOUBLE
27518: LD_INT 1
27520: DEC
27521: ST_TO_ADDR
27522: LD_EXP 50
27526: PUSH
27527: FOR_TO
27528: IFFALSE 28421
// begin if not mc_building_need_repair [ i ] then
27530: LD_EXP 51
27534: PUSH
27535: LD_VAR 0 2
27539: ARRAY
27540: NOT
27541: IFFALSE 27726
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
27543: LD_ADDR_VAR 0 6
27547: PUSH
27548: LD_EXP 69
27552: PUSH
27553: LD_VAR 0 2
27557: ARRAY
27558: PPUSH
27559: LD_INT 3
27561: PUSH
27562: LD_INT 24
27564: PUSH
27565: LD_INT 1000
27567: PUSH
27568: EMPTY
27569: LIST
27570: LIST
27571: PUSH
27572: EMPTY
27573: LIST
27574: LIST
27575: PUSH
27576: LD_INT 2
27578: PUSH
27579: LD_INT 34
27581: PUSH
27582: LD_INT 13
27584: PUSH
27585: EMPTY
27586: LIST
27587: LIST
27588: PUSH
27589: LD_INT 34
27591: PUSH
27592: LD_INT 52
27594: PUSH
27595: EMPTY
27596: LIST
27597: LIST
27598: PUSH
27599: LD_INT 34
27601: PUSH
27602: LD_INT 88
27604: PUSH
27605: EMPTY
27606: LIST
27607: LIST
27608: PUSH
27609: EMPTY
27610: LIST
27611: LIST
27612: LIST
27613: LIST
27614: PUSH
27615: EMPTY
27616: LIST
27617: LIST
27618: PPUSH
27619: CALL_OW 72
27623: ST_TO_ADDR
// if cranes then
27624: LD_VAR 0 6
27628: IFFALSE 27690
// for j in cranes do
27630: LD_ADDR_VAR 0 3
27634: PUSH
27635: LD_VAR 0 6
27639: PUSH
27640: FOR_IN
27641: IFFALSE 27688
// if not IsInArea ( j , mc_parking [ i ] ) then
27643: LD_VAR 0 3
27647: PPUSH
27648: LD_EXP 74
27652: PUSH
27653: LD_VAR 0 2
27657: ARRAY
27658: PPUSH
27659: CALL_OW 308
27663: NOT
27664: IFFALSE 27686
// ComMoveToArea ( j , mc_parking [ i ] ) ;
27666: LD_VAR 0 3
27670: PPUSH
27671: LD_EXP 74
27675: PUSH
27676: LD_VAR 0 2
27680: ARRAY
27681: PPUSH
27682: CALL_OW 113
27686: GO 27640
27688: POP
27689: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
27690: LD_ADDR_EXP 52
27694: PUSH
27695: LD_EXP 52
27699: PPUSH
27700: LD_VAR 0 2
27704: PPUSH
27705: EMPTY
27706: PPUSH
27707: CALL_OW 1
27711: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
27712: LD_VAR 0 2
27716: PPUSH
27717: LD_INT 101
27719: PPUSH
27720: CALL 22566 0 2
// continue ;
27724: GO 27527
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
27726: LD_ADDR_EXP 56
27730: PUSH
27731: LD_EXP 56
27735: PPUSH
27736: LD_VAR 0 2
27740: PPUSH
27741: EMPTY
27742: PPUSH
27743: CALL_OW 1
27747: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
27748: LD_VAR 0 2
27752: PPUSH
27753: LD_INT 103
27755: PPUSH
27756: CALL 22566 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
27760: LD_ADDR_VAR 0 5
27764: PUSH
27765: LD_EXP 50
27769: PUSH
27770: LD_VAR 0 2
27774: ARRAY
27775: PUSH
27776: LD_EXP 79
27780: PUSH
27781: LD_VAR 0 2
27785: ARRAY
27786: UNION
27787: PPUSH
27788: LD_INT 2
27790: PUSH
27791: LD_INT 25
27793: PUSH
27794: LD_INT 2
27796: PUSH
27797: EMPTY
27798: LIST
27799: LIST
27800: PUSH
27801: LD_INT 25
27803: PUSH
27804: LD_INT 16
27806: PUSH
27807: EMPTY
27808: LIST
27809: LIST
27810: PUSH
27811: EMPTY
27812: LIST
27813: LIST
27814: LIST
27815: PUSH
27816: EMPTY
27817: LIST
27818: PPUSH
27819: CALL_OW 72
27823: ST_TO_ADDR
// if mc_need_heal [ i ] then
27824: LD_EXP 53
27828: PUSH
27829: LD_VAR 0 2
27833: ARRAY
27834: IFFALSE 27878
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
27836: LD_ADDR_VAR 0 5
27840: PUSH
27841: LD_VAR 0 5
27845: PUSH
27846: LD_EXP 53
27850: PUSH
27851: LD_VAR 0 2
27855: ARRAY
27856: PUSH
27857: LD_INT 1
27859: ARRAY
27860: PUSH
27861: LD_EXP 53
27865: PUSH
27866: LD_VAR 0 2
27870: ARRAY
27871: PUSH
27872: LD_INT 2
27874: ARRAY
27875: UNION
27876: DIFF
27877: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
27878: LD_ADDR_VAR 0 6
27882: PUSH
27883: LD_EXP 69
27887: PUSH
27888: LD_VAR 0 2
27892: ARRAY
27893: PPUSH
27894: LD_INT 2
27896: PUSH
27897: LD_INT 34
27899: PUSH
27900: LD_INT 13
27902: PUSH
27903: EMPTY
27904: LIST
27905: LIST
27906: PUSH
27907: LD_INT 34
27909: PUSH
27910: LD_INT 52
27912: PUSH
27913: EMPTY
27914: LIST
27915: LIST
27916: PUSH
27917: LD_INT 34
27919: PUSH
27920: LD_INT 88
27922: PUSH
27923: EMPTY
27924: LIST
27925: LIST
27926: PUSH
27927: EMPTY
27928: LIST
27929: LIST
27930: LIST
27931: LIST
27932: PPUSH
27933: CALL_OW 72
27937: ST_TO_ADDR
// if cranes then
27938: LD_VAR 0 6
27942: IFFALSE 28110
// begin for j in cranes do
27944: LD_ADDR_VAR 0 3
27948: PUSH
27949: LD_VAR 0 6
27953: PUSH
27954: FOR_IN
27955: IFFALSE 28108
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
27957: LD_VAR 0 3
27961: PPUSH
27962: CALL_OW 256
27966: PUSH
27967: LD_INT 1000
27969: EQUAL
27970: PUSH
27971: LD_VAR 0 3
27975: PPUSH
27976: CALL_OW 314
27980: NOT
27981: AND
27982: IFFALSE 28048
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
27984: LD_ADDR_VAR 0 8
27988: PUSH
27989: LD_EXP 51
27993: PUSH
27994: LD_VAR 0 2
27998: ARRAY
27999: PPUSH
28000: LD_VAR 0 3
28004: PPUSH
28005: CALL_OW 74
28009: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
28010: LD_VAR 0 8
28014: PPUSH
28015: LD_INT 16
28017: PPUSH
28018: CALL 57032 0 2
28022: PUSH
28023: LD_INT 4
28025: ARRAY
28026: PUSH
28027: LD_INT 10
28029: LESS
28030: IFFALSE 28046
// ComRepairBuilding ( j , to_repair ) ;
28032: LD_VAR 0 3
28036: PPUSH
28037: LD_VAR 0 8
28041: PPUSH
28042: CALL_OW 130
// end else
28046: GO 28106
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
28048: LD_VAR 0 3
28052: PPUSH
28053: CALL_OW 256
28057: PUSH
28058: LD_INT 500
28060: LESS
28061: PUSH
28062: LD_VAR 0 3
28066: PPUSH
28067: LD_EXP 74
28071: PUSH
28072: LD_VAR 0 2
28076: ARRAY
28077: PPUSH
28078: CALL_OW 308
28082: NOT
28083: AND
28084: IFFALSE 28106
// ComMoveToArea ( j , mc_parking [ i ] ) ;
28086: LD_VAR 0 3
28090: PPUSH
28091: LD_EXP 74
28095: PUSH
28096: LD_VAR 0 2
28100: ARRAY
28101: PPUSH
28102: CALL_OW 113
// end ;
28106: GO 27954
28108: POP
28109: POP
// end ; if tmp > 3 then
28110: LD_VAR 0 5
28114: PUSH
28115: LD_INT 3
28117: GREATER
28118: IFFALSE 28138
// tmp := ShrinkArray ( tmp , 4 ) ;
28120: LD_ADDR_VAR 0 5
28124: PUSH
28125: LD_VAR 0 5
28129: PPUSH
28130: LD_INT 4
28132: PPUSH
28133: CALL 87122 0 2
28137: ST_TO_ADDR
// if not tmp then
28138: LD_VAR 0 5
28142: NOT
28143: IFFALSE 28147
// continue ;
28145: GO 27527
// for j in tmp do
28147: LD_ADDR_VAR 0 3
28151: PUSH
28152: LD_VAR 0 5
28156: PUSH
28157: FOR_IN
28158: IFFALSE 28417
// begin if IsInUnit ( j ) then
28160: LD_VAR 0 3
28164: PPUSH
28165: CALL_OW 310
28169: IFFALSE 28180
// ComExitBuilding ( j ) ;
28171: LD_VAR 0 3
28175: PPUSH
28176: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
28180: LD_VAR 0 3
28184: PUSH
28185: LD_EXP 52
28189: PUSH
28190: LD_VAR 0 2
28194: ARRAY
28195: IN
28196: NOT
28197: IFFALSE 28255
// begin SetTag ( j , 101 ) ;
28199: LD_VAR 0 3
28203: PPUSH
28204: LD_INT 101
28206: PPUSH
28207: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
28211: LD_ADDR_EXP 52
28215: PUSH
28216: LD_EXP 52
28220: PPUSH
28221: LD_VAR 0 2
28225: PUSH
28226: LD_EXP 52
28230: PUSH
28231: LD_VAR 0 2
28235: ARRAY
28236: PUSH
28237: LD_INT 1
28239: PLUS
28240: PUSH
28241: EMPTY
28242: LIST
28243: LIST
28244: PPUSH
28245: LD_VAR 0 3
28249: PPUSH
28250: CALL 54067 0 3
28254: ST_TO_ADDR
// end ; wait ( 1 ) ;
28255: LD_INT 1
28257: PPUSH
28258: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
28262: LD_ADDR_VAR 0 7
28266: PUSH
28267: LD_EXP 51
28271: PUSH
28272: LD_VAR 0 2
28276: ARRAY
28277: ST_TO_ADDR
// if mc_scan [ i ] then
28278: LD_EXP 73
28282: PUSH
28283: LD_VAR 0 2
28287: ARRAY
28288: IFFALSE 28350
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
28290: LD_ADDR_VAR 0 7
28294: PUSH
28295: LD_EXP 51
28299: PUSH
28300: LD_VAR 0 2
28304: ARRAY
28305: PPUSH
28306: LD_INT 3
28308: PUSH
28309: LD_INT 30
28311: PUSH
28312: LD_INT 32
28314: PUSH
28315: EMPTY
28316: LIST
28317: LIST
28318: PUSH
28319: LD_INT 30
28321: PUSH
28322: LD_INT 33
28324: PUSH
28325: EMPTY
28326: LIST
28327: LIST
28328: PUSH
28329: LD_INT 30
28331: PUSH
28332: LD_INT 31
28334: PUSH
28335: EMPTY
28336: LIST
28337: LIST
28338: PUSH
28339: EMPTY
28340: LIST
28341: LIST
28342: LIST
28343: LIST
28344: PPUSH
28345: CALL_OW 72
28349: ST_TO_ADDR
// if not to_repair_tmp then
28350: LD_VAR 0 7
28354: NOT
28355: IFFALSE 28359
// continue ;
28357: GO 28157
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
28359: LD_ADDR_VAR 0 8
28363: PUSH
28364: LD_VAR 0 7
28368: PPUSH
28369: LD_VAR 0 3
28373: PPUSH
28374: CALL_OW 74
28378: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
28379: LD_VAR 0 8
28383: PPUSH
28384: LD_INT 16
28386: PPUSH
28387: CALL 57032 0 2
28391: PUSH
28392: LD_INT 4
28394: ARRAY
28395: PUSH
28396: LD_INT 14
28398: LESS
28399: IFFALSE 28415
// ComRepairBuilding ( j , to_repair ) ;
28401: LD_VAR 0 3
28405: PPUSH
28406: LD_VAR 0 8
28410: PPUSH
28411: CALL_OW 130
// end ;
28415: GO 28157
28417: POP
28418: POP
// end ;
28419: GO 27527
28421: POP
28422: POP
// end ;
28423: LD_VAR 0 1
28427: RET
// export function MC_Heal ; var i , j , tmp ; begin
28428: LD_INT 0
28430: PPUSH
28431: PPUSH
28432: PPUSH
28433: PPUSH
// if not mc_bases then
28434: LD_EXP 50
28438: NOT
28439: IFFALSE 28443
// exit ;
28441: GO 28845
// for i = 1 to mc_bases do
28443: LD_ADDR_VAR 0 2
28447: PUSH
28448: DOUBLE
28449: LD_INT 1
28451: DEC
28452: ST_TO_ADDR
28453: LD_EXP 50
28457: PUSH
28458: FOR_TO
28459: IFFALSE 28843
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
28461: LD_EXP 53
28465: PUSH
28466: LD_VAR 0 2
28470: ARRAY
28471: PUSH
28472: LD_INT 1
28474: ARRAY
28475: NOT
28476: PUSH
28477: LD_EXP 53
28481: PUSH
28482: LD_VAR 0 2
28486: ARRAY
28487: PUSH
28488: LD_INT 2
28490: ARRAY
28491: NOT
28492: AND
28493: IFFALSE 28531
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
28495: LD_ADDR_EXP 54
28499: PUSH
28500: LD_EXP 54
28504: PPUSH
28505: LD_VAR 0 2
28509: PPUSH
28510: EMPTY
28511: PPUSH
28512: CALL_OW 1
28516: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
28517: LD_VAR 0 2
28521: PPUSH
28522: LD_INT 102
28524: PPUSH
28525: CALL 22566 0 2
// continue ;
28529: GO 28458
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
28531: LD_ADDR_VAR 0 4
28535: PUSH
28536: LD_EXP 50
28540: PUSH
28541: LD_VAR 0 2
28545: ARRAY
28546: PPUSH
28547: LD_INT 25
28549: PUSH
28550: LD_INT 4
28552: PUSH
28553: EMPTY
28554: LIST
28555: LIST
28556: PPUSH
28557: CALL_OW 72
28561: ST_TO_ADDR
// if not tmp then
28562: LD_VAR 0 4
28566: NOT
28567: IFFALSE 28571
// continue ;
28569: GO 28458
// if mc_taming [ i ] then
28571: LD_EXP 81
28575: PUSH
28576: LD_VAR 0 2
28580: ARRAY
28581: IFFALSE 28605
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
28583: LD_ADDR_EXP 81
28587: PUSH
28588: LD_EXP 81
28592: PPUSH
28593: LD_VAR 0 2
28597: PPUSH
28598: EMPTY
28599: PPUSH
28600: CALL_OW 1
28604: ST_TO_ADDR
// for j in tmp do
28605: LD_ADDR_VAR 0 3
28609: PUSH
28610: LD_VAR 0 4
28614: PUSH
28615: FOR_IN
28616: IFFALSE 28839
// begin if IsInUnit ( j ) then
28618: LD_VAR 0 3
28622: PPUSH
28623: CALL_OW 310
28627: IFFALSE 28638
// ComExitBuilding ( j ) ;
28629: LD_VAR 0 3
28633: PPUSH
28634: CALL_OW 122
// if not j in mc_healers [ i ] then
28638: LD_VAR 0 3
28642: PUSH
28643: LD_EXP 54
28647: PUSH
28648: LD_VAR 0 2
28652: ARRAY
28653: IN
28654: NOT
28655: IFFALSE 28701
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
28657: LD_ADDR_EXP 54
28661: PUSH
28662: LD_EXP 54
28666: PPUSH
28667: LD_VAR 0 2
28671: PUSH
28672: LD_EXP 54
28676: PUSH
28677: LD_VAR 0 2
28681: ARRAY
28682: PUSH
28683: LD_INT 1
28685: PLUS
28686: PUSH
28687: EMPTY
28688: LIST
28689: LIST
28690: PPUSH
28691: LD_VAR 0 3
28695: PPUSH
28696: CALL 54067 0 3
28700: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
28701: LD_VAR 0 3
28705: PPUSH
28706: CALL_OW 110
28710: PUSH
28711: LD_INT 102
28713: NONEQUAL
28714: IFFALSE 28728
// SetTag ( j , 102 ) ;
28716: LD_VAR 0 3
28720: PPUSH
28721: LD_INT 102
28723: PPUSH
28724: CALL_OW 109
// Wait ( 3 ) ;
28728: LD_INT 3
28730: PPUSH
28731: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
28735: LD_EXP 53
28739: PUSH
28740: LD_VAR 0 2
28744: ARRAY
28745: PUSH
28746: LD_INT 1
28748: ARRAY
28749: IFFALSE 28781
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
28751: LD_VAR 0 3
28755: PPUSH
28756: LD_EXP 53
28760: PUSH
28761: LD_VAR 0 2
28765: ARRAY
28766: PUSH
28767: LD_INT 1
28769: ARRAY
28770: PUSH
28771: LD_INT 1
28773: ARRAY
28774: PPUSH
28775: CALL_OW 128
28779: GO 28837
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
28781: LD_VAR 0 3
28785: PPUSH
28786: CALL_OW 314
28790: NOT
28791: PUSH
28792: LD_EXP 53
28796: PUSH
28797: LD_VAR 0 2
28801: ARRAY
28802: PUSH
28803: LD_INT 2
28805: ARRAY
28806: AND
28807: IFFALSE 28837
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
28809: LD_VAR 0 3
28813: PPUSH
28814: LD_EXP 53
28818: PUSH
28819: LD_VAR 0 2
28823: ARRAY
28824: PUSH
28825: LD_INT 2
28827: ARRAY
28828: PUSH
28829: LD_INT 1
28831: ARRAY
28832: PPUSH
28833: CALL_OW 128
// end ;
28837: GO 28615
28839: POP
28840: POP
// end ;
28841: GO 28458
28843: POP
28844: POP
// end ;
28845: LD_VAR 0 1
28849: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
28850: LD_INT 0
28852: PPUSH
28853: PPUSH
28854: PPUSH
28855: PPUSH
28856: PPUSH
28857: PPUSH
// if not mc_bases then
28858: LD_EXP 50
28862: NOT
28863: IFFALSE 28867
// exit ;
28865: GO 30030
// for i = 1 to mc_bases do
28867: LD_ADDR_VAR 0 2
28871: PUSH
28872: DOUBLE
28873: LD_INT 1
28875: DEC
28876: ST_TO_ADDR
28877: LD_EXP 50
28881: PUSH
28882: FOR_TO
28883: IFFALSE 30028
// begin if mc_scan [ i ] then
28885: LD_EXP 73
28889: PUSH
28890: LD_VAR 0 2
28894: ARRAY
28895: IFFALSE 28899
// continue ;
28897: GO 28882
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
28899: LD_EXP 55
28903: PUSH
28904: LD_VAR 0 2
28908: ARRAY
28909: NOT
28910: PUSH
28911: LD_EXP 57
28915: PUSH
28916: LD_VAR 0 2
28920: ARRAY
28921: NOT
28922: AND
28923: PUSH
28924: LD_EXP 56
28928: PUSH
28929: LD_VAR 0 2
28933: ARRAY
28934: AND
28935: IFFALSE 28973
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
28937: LD_ADDR_EXP 56
28941: PUSH
28942: LD_EXP 56
28946: PPUSH
28947: LD_VAR 0 2
28951: PPUSH
28952: EMPTY
28953: PPUSH
28954: CALL_OW 1
28958: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
28959: LD_VAR 0 2
28963: PPUSH
28964: LD_INT 103
28966: PPUSH
28967: CALL 22566 0 2
// continue ;
28971: GO 28882
// end ; if mc_construct_list [ i ] then
28973: LD_EXP 57
28977: PUSH
28978: LD_VAR 0 2
28982: ARRAY
28983: IFFALSE 29203
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
28985: LD_ADDR_VAR 0 5
28989: PUSH
28990: LD_EXP 50
28994: PUSH
28995: LD_VAR 0 2
28999: ARRAY
29000: PPUSH
29001: LD_INT 25
29003: PUSH
29004: LD_INT 2
29006: PUSH
29007: EMPTY
29008: LIST
29009: LIST
29010: PPUSH
29011: CALL_OW 72
29015: PUSH
29016: LD_EXP 52
29020: PUSH
29021: LD_VAR 0 2
29025: ARRAY
29026: DIFF
29027: ST_TO_ADDR
// if not tmp then
29028: LD_VAR 0 5
29032: NOT
29033: IFFALSE 29037
// continue ;
29035: GO 28882
// for j in tmp do
29037: LD_ADDR_VAR 0 3
29041: PUSH
29042: LD_VAR 0 5
29046: PUSH
29047: FOR_IN
29048: IFFALSE 29199
// begin if not mc_builders [ i ] then
29050: LD_EXP 56
29054: PUSH
29055: LD_VAR 0 2
29059: ARRAY
29060: NOT
29061: IFFALSE 29119
// begin SetTag ( j , 103 ) ;
29063: LD_VAR 0 3
29067: PPUSH
29068: LD_INT 103
29070: PPUSH
29071: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
29075: LD_ADDR_EXP 56
29079: PUSH
29080: LD_EXP 56
29084: PPUSH
29085: LD_VAR 0 2
29089: PUSH
29090: LD_EXP 56
29094: PUSH
29095: LD_VAR 0 2
29099: ARRAY
29100: PUSH
29101: LD_INT 1
29103: PLUS
29104: PUSH
29105: EMPTY
29106: LIST
29107: LIST
29108: PPUSH
29109: LD_VAR 0 3
29113: PPUSH
29114: CALL 54067 0 3
29118: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
29119: LD_VAR 0 3
29123: PPUSH
29124: CALL_OW 310
29128: IFFALSE 29139
// ComExitBuilding ( j ) ;
29130: LD_VAR 0 3
29134: PPUSH
29135: CALL_OW 122
// wait ( 3 ) ;
29139: LD_INT 3
29141: PPUSH
29142: CALL_OW 67
// if not mc_construct_list [ i ] then
29146: LD_EXP 57
29150: PUSH
29151: LD_VAR 0 2
29155: ARRAY
29156: NOT
29157: IFFALSE 29161
// break ;
29159: GO 29199
// if not HasTask ( j ) then
29161: LD_VAR 0 3
29165: PPUSH
29166: CALL_OW 314
29170: NOT
29171: IFFALSE 29197
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
29173: LD_VAR 0 3
29177: PPUSH
29178: LD_EXP 57
29182: PUSH
29183: LD_VAR 0 2
29187: ARRAY
29188: PUSH
29189: LD_INT 1
29191: ARRAY
29192: PPUSH
29193: CALL 57305 0 2
// end ;
29197: GO 29047
29199: POP
29200: POP
// end else
29201: GO 30026
// if mc_build_list [ i ] then
29203: LD_EXP 55
29207: PUSH
29208: LD_VAR 0 2
29212: ARRAY
29213: IFFALSE 30026
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
29215: LD_EXP 55
29219: PUSH
29220: LD_VAR 0 2
29224: ARRAY
29225: PUSH
29226: LD_INT 1
29228: ARRAY
29229: PUSH
29230: LD_INT 1
29232: ARRAY
29233: PPUSH
29234: CALL 57129 0 1
29238: PUSH
29239: LD_EXP 50
29243: PUSH
29244: LD_VAR 0 2
29248: ARRAY
29249: PPUSH
29250: LD_INT 2
29252: PUSH
29253: LD_INT 30
29255: PUSH
29256: LD_INT 2
29258: PUSH
29259: EMPTY
29260: LIST
29261: LIST
29262: PUSH
29263: LD_INT 30
29265: PUSH
29266: LD_INT 3
29268: PUSH
29269: EMPTY
29270: LIST
29271: LIST
29272: PUSH
29273: EMPTY
29274: LIST
29275: LIST
29276: LIST
29277: PPUSH
29278: CALL_OW 72
29282: NOT
29283: AND
29284: IFFALSE 29389
// begin for j = 1 to mc_build_list [ i ] do
29286: LD_ADDR_VAR 0 3
29290: PUSH
29291: DOUBLE
29292: LD_INT 1
29294: DEC
29295: ST_TO_ADDR
29296: LD_EXP 55
29300: PUSH
29301: LD_VAR 0 2
29305: ARRAY
29306: PUSH
29307: FOR_TO
29308: IFFALSE 29387
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
29310: LD_EXP 55
29314: PUSH
29315: LD_VAR 0 2
29319: ARRAY
29320: PUSH
29321: LD_VAR 0 3
29325: ARRAY
29326: PUSH
29327: LD_INT 1
29329: ARRAY
29330: PUSH
29331: LD_INT 2
29333: EQUAL
29334: IFFALSE 29385
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
29336: LD_ADDR_EXP 55
29340: PUSH
29341: LD_EXP 55
29345: PPUSH
29346: LD_VAR 0 2
29350: PPUSH
29351: LD_EXP 55
29355: PUSH
29356: LD_VAR 0 2
29360: ARRAY
29361: PPUSH
29362: LD_VAR 0 3
29366: PPUSH
29367: LD_INT 1
29369: PPUSH
29370: LD_INT 0
29372: PPUSH
29373: CALL 53485 0 4
29377: PPUSH
29378: CALL_OW 1
29382: ST_TO_ADDR
// break ;
29383: GO 29387
// end ;
29385: GO 29307
29387: POP
29388: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
29389: LD_ADDR_VAR 0 6
29393: PUSH
29394: LD_EXP 50
29398: PUSH
29399: LD_VAR 0 2
29403: ARRAY
29404: PPUSH
29405: LD_INT 2
29407: PUSH
29408: LD_INT 30
29410: PUSH
29411: LD_INT 0
29413: PUSH
29414: EMPTY
29415: LIST
29416: LIST
29417: PUSH
29418: LD_INT 30
29420: PUSH
29421: LD_INT 1
29423: PUSH
29424: EMPTY
29425: LIST
29426: LIST
29427: PUSH
29428: EMPTY
29429: LIST
29430: LIST
29431: LIST
29432: PPUSH
29433: CALL_OW 72
29437: ST_TO_ADDR
// for k := 1 to depot do
29438: LD_ADDR_VAR 0 4
29442: PUSH
29443: DOUBLE
29444: LD_INT 1
29446: DEC
29447: ST_TO_ADDR
29448: LD_VAR 0 6
29452: PUSH
29453: FOR_TO
29454: IFFALSE 30024
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
29456: LD_EXP 55
29460: PUSH
29461: LD_VAR 0 2
29465: ARRAY
29466: PUSH
29467: LD_INT 1
29469: ARRAY
29470: PUSH
29471: LD_INT 1
29473: ARRAY
29474: PUSH
29475: LD_INT 0
29477: EQUAL
29478: PUSH
29479: LD_VAR 0 6
29483: PUSH
29484: LD_VAR 0 4
29488: ARRAY
29489: PPUSH
29490: LD_EXP 55
29494: PUSH
29495: LD_VAR 0 2
29499: ARRAY
29500: PUSH
29501: LD_INT 1
29503: ARRAY
29504: PUSH
29505: LD_INT 1
29507: ARRAY
29508: PPUSH
29509: LD_EXP 55
29513: PUSH
29514: LD_VAR 0 2
29518: ARRAY
29519: PUSH
29520: LD_INT 1
29522: ARRAY
29523: PUSH
29524: LD_INT 2
29526: ARRAY
29527: PPUSH
29528: LD_EXP 55
29532: PUSH
29533: LD_VAR 0 2
29537: ARRAY
29538: PUSH
29539: LD_INT 1
29541: ARRAY
29542: PUSH
29543: LD_INT 3
29545: ARRAY
29546: PPUSH
29547: LD_EXP 55
29551: PUSH
29552: LD_VAR 0 2
29556: ARRAY
29557: PUSH
29558: LD_INT 1
29560: ARRAY
29561: PUSH
29562: LD_INT 4
29564: ARRAY
29565: PPUSH
29566: CALL 62541 0 5
29570: OR
29571: IFFALSE 29852
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
29573: LD_ADDR_VAR 0 5
29577: PUSH
29578: LD_EXP 50
29582: PUSH
29583: LD_VAR 0 2
29587: ARRAY
29588: PPUSH
29589: LD_INT 25
29591: PUSH
29592: LD_INT 2
29594: PUSH
29595: EMPTY
29596: LIST
29597: LIST
29598: PPUSH
29599: CALL_OW 72
29603: PUSH
29604: LD_EXP 52
29608: PUSH
29609: LD_VAR 0 2
29613: ARRAY
29614: DIFF
29615: ST_TO_ADDR
// if not tmp then
29616: LD_VAR 0 5
29620: NOT
29621: IFFALSE 29625
// continue ;
29623: GO 29453
// for j in tmp do
29625: LD_ADDR_VAR 0 3
29629: PUSH
29630: LD_VAR 0 5
29634: PUSH
29635: FOR_IN
29636: IFFALSE 29848
// begin if not mc_builders [ i ] then
29638: LD_EXP 56
29642: PUSH
29643: LD_VAR 0 2
29647: ARRAY
29648: NOT
29649: IFFALSE 29707
// begin SetTag ( j , 103 ) ;
29651: LD_VAR 0 3
29655: PPUSH
29656: LD_INT 103
29658: PPUSH
29659: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
29663: LD_ADDR_EXP 56
29667: PUSH
29668: LD_EXP 56
29672: PPUSH
29673: LD_VAR 0 2
29677: PUSH
29678: LD_EXP 56
29682: PUSH
29683: LD_VAR 0 2
29687: ARRAY
29688: PUSH
29689: LD_INT 1
29691: PLUS
29692: PUSH
29693: EMPTY
29694: LIST
29695: LIST
29696: PPUSH
29697: LD_VAR 0 3
29701: PPUSH
29702: CALL 54067 0 3
29706: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
29707: LD_VAR 0 3
29711: PPUSH
29712: CALL_OW 310
29716: IFFALSE 29727
// ComExitBuilding ( j ) ;
29718: LD_VAR 0 3
29722: PPUSH
29723: CALL_OW 122
// wait ( 3 ) ;
29727: LD_INT 3
29729: PPUSH
29730: CALL_OW 67
// if not mc_build_list [ i ] then
29734: LD_EXP 55
29738: PUSH
29739: LD_VAR 0 2
29743: ARRAY
29744: NOT
29745: IFFALSE 29749
// break ;
29747: GO 29848
// if not HasTask ( j ) then
29749: LD_VAR 0 3
29753: PPUSH
29754: CALL_OW 314
29758: NOT
29759: IFFALSE 29846
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
29761: LD_VAR 0 3
29765: PPUSH
29766: LD_EXP 55
29770: PUSH
29771: LD_VAR 0 2
29775: ARRAY
29776: PUSH
29777: LD_INT 1
29779: ARRAY
29780: PUSH
29781: LD_INT 1
29783: ARRAY
29784: PPUSH
29785: LD_EXP 55
29789: PUSH
29790: LD_VAR 0 2
29794: ARRAY
29795: PUSH
29796: LD_INT 1
29798: ARRAY
29799: PUSH
29800: LD_INT 2
29802: ARRAY
29803: PPUSH
29804: LD_EXP 55
29808: PUSH
29809: LD_VAR 0 2
29813: ARRAY
29814: PUSH
29815: LD_INT 1
29817: ARRAY
29818: PUSH
29819: LD_INT 3
29821: ARRAY
29822: PPUSH
29823: LD_EXP 55
29827: PUSH
29828: LD_VAR 0 2
29832: ARRAY
29833: PUSH
29834: LD_INT 1
29836: ARRAY
29837: PUSH
29838: LD_INT 4
29840: ARRAY
29841: PPUSH
29842: CALL_OW 145
// end ;
29846: GO 29635
29848: POP
29849: POP
// end else
29850: GO 30022
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
29852: LD_EXP 50
29856: PUSH
29857: LD_VAR 0 2
29861: ARRAY
29862: PPUSH
29863: LD_EXP 55
29867: PUSH
29868: LD_VAR 0 2
29872: ARRAY
29873: PUSH
29874: LD_INT 1
29876: ARRAY
29877: PUSH
29878: LD_INT 1
29880: ARRAY
29881: PPUSH
29882: LD_EXP 55
29886: PUSH
29887: LD_VAR 0 2
29891: ARRAY
29892: PUSH
29893: LD_INT 1
29895: ARRAY
29896: PUSH
29897: LD_INT 2
29899: ARRAY
29900: PPUSH
29901: LD_EXP 55
29905: PUSH
29906: LD_VAR 0 2
29910: ARRAY
29911: PUSH
29912: LD_INT 1
29914: ARRAY
29915: PUSH
29916: LD_INT 3
29918: ARRAY
29919: PPUSH
29920: LD_EXP 55
29924: PUSH
29925: LD_VAR 0 2
29929: ARRAY
29930: PUSH
29931: LD_INT 1
29933: ARRAY
29934: PUSH
29935: LD_INT 4
29937: ARRAY
29938: PPUSH
29939: LD_EXP 50
29943: PUSH
29944: LD_VAR 0 2
29948: ARRAY
29949: PPUSH
29950: LD_INT 21
29952: PUSH
29953: LD_INT 3
29955: PUSH
29956: EMPTY
29957: LIST
29958: LIST
29959: PPUSH
29960: CALL_OW 72
29964: PPUSH
29965: EMPTY
29966: PPUSH
29967: CALL 61295 0 7
29971: NOT
29972: IFFALSE 30022
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
29974: LD_ADDR_EXP 55
29978: PUSH
29979: LD_EXP 55
29983: PPUSH
29984: LD_VAR 0 2
29988: PPUSH
29989: LD_EXP 55
29993: PUSH
29994: LD_VAR 0 2
29998: ARRAY
29999: PPUSH
30000: LD_INT 1
30002: PPUSH
30003: LD_INT 1
30005: NEG
30006: PPUSH
30007: LD_INT 0
30009: PPUSH
30010: CALL 53485 0 4
30014: PPUSH
30015: CALL_OW 1
30019: ST_TO_ADDR
// continue ;
30020: GO 29453
// end ; end ;
30022: GO 29453
30024: POP
30025: POP
// end ; end ;
30026: GO 28882
30028: POP
30029: POP
// end ;
30030: LD_VAR 0 1
30034: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
30035: LD_INT 0
30037: PPUSH
30038: PPUSH
30039: PPUSH
30040: PPUSH
30041: PPUSH
30042: PPUSH
// if not mc_bases then
30043: LD_EXP 50
30047: NOT
30048: IFFALSE 30052
// exit ;
30050: GO 30479
// for i = 1 to mc_bases do
30052: LD_ADDR_VAR 0 2
30056: PUSH
30057: DOUBLE
30058: LD_INT 1
30060: DEC
30061: ST_TO_ADDR
30062: LD_EXP 50
30066: PUSH
30067: FOR_TO
30068: IFFALSE 30477
// begin tmp := mc_build_upgrade [ i ] ;
30070: LD_ADDR_VAR 0 4
30074: PUSH
30075: LD_EXP 82
30079: PUSH
30080: LD_VAR 0 2
30084: ARRAY
30085: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
30086: LD_ADDR_VAR 0 6
30090: PUSH
30091: LD_EXP 83
30095: PUSH
30096: LD_VAR 0 2
30100: ARRAY
30101: PPUSH
30102: LD_INT 2
30104: PUSH
30105: LD_INT 30
30107: PUSH
30108: LD_INT 6
30110: PUSH
30111: EMPTY
30112: LIST
30113: LIST
30114: PUSH
30115: LD_INT 30
30117: PUSH
30118: LD_INT 7
30120: PUSH
30121: EMPTY
30122: LIST
30123: LIST
30124: PUSH
30125: EMPTY
30126: LIST
30127: LIST
30128: LIST
30129: PPUSH
30130: CALL_OW 72
30134: ST_TO_ADDR
// if not tmp and not lab then
30135: LD_VAR 0 4
30139: NOT
30140: PUSH
30141: LD_VAR 0 6
30145: NOT
30146: AND
30147: IFFALSE 30151
// continue ;
30149: GO 30067
// if tmp then
30151: LD_VAR 0 4
30155: IFFALSE 30275
// for j in tmp do
30157: LD_ADDR_VAR 0 3
30161: PUSH
30162: LD_VAR 0 4
30166: PUSH
30167: FOR_IN
30168: IFFALSE 30273
// begin if UpgradeCost ( j ) then
30170: LD_VAR 0 3
30174: PPUSH
30175: CALL 60955 0 1
30179: IFFALSE 30271
// begin ComUpgrade ( j ) ;
30181: LD_VAR 0 3
30185: PPUSH
30186: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
30190: LD_ADDR_EXP 82
30194: PUSH
30195: LD_EXP 82
30199: PPUSH
30200: LD_VAR 0 2
30204: PPUSH
30205: LD_EXP 82
30209: PUSH
30210: LD_VAR 0 2
30214: ARRAY
30215: PUSH
30216: LD_VAR 0 3
30220: DIFF
30221: PPUSH
30222: CALL_OW 1
30226: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
30227: LD_ADDR_EXP 57
30231: PUSH
30232: LD_EXP 57
30236: PPUSH
30237: LD_VAR 0 2
30241: PUSH
30242: LD_EXP 57
30246: PUSH
30247: LD_VAR 0 2
30251: ARRAY
30252: PUSH
30253: LD_INT 1
30255: PLUS
30256: PUSH
30257: EMPTY
30258: LIST
30259: LIST
30260: PPUSH
30261: LD_VAR 0 3
30265: PPUSH
30266: CALL 54067 0 3
30270: ST_TO_ADDR
// end ; end ;
30271: GO 30167
30273: POP
30274: POP
// if not lab or not mc_lab_upgrade [ i ] then
30275: LD_VAR 0 6
30279: NOT
30280: PUSH
30281: LD_EXP 84
30285: PUSH
30286: LD_VAR 0 2
30290: ARRAY
30291: NOT
30292: OR
30293: IFFALSE 30297
// continue ;
30295: GO 30067
// for j in lab do
30297: LD_ADDR_VAR 0 3
30301: PUSH
30302: LD_VAR 0 6
30306: PUSH
30307: FOR_IN
30308: IFFALSE 30473
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
30310: LD_VAR 0 3
30314: PPUSH
30315: CALL_OW 266
30319: PUSH
30320: LD_INT 6
30322: PUSH
30323: LD_INT 7
30325: PUSH
30326: EMPTY
30327: LIST
30328: LIST
30329: IN
30330: PUSH
30331: LD_VAR 0 3
30335: PPUSH
30336: CALL_OW 461
30340: PUSH
30341: LD_INT 1
30343: NONEQUAL
30344: AND
30345: IFFALSE 30471
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
30347: LD_VAR 0 3
30351: PPUSH
30352: LD_EXP 84
30356: PUSH
30357: LD_VAR 0 2
30361: ARRAY
30362: PUSH
30363: LD_INT 1
30365: ARRAY
30366: PPUSH
30367: CALL 61160 0 2
30371: IFFALSE 30471
// begin ComCancel ( j ) ;
30373: LD_VAR 0 3
30377: PPUSH
30378: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
30382: LD_VAR 0 3
30386: PPUSH
30387: LD_EXP 84
30391: PUSH
30392: LD_VAR 0 2
30396: ARRAY
30397: PUSH
30398: LD_INT 1
30400: ARRAY
30401: PPUSH
30402: CALL_OW 207
// if not j in mc_construct_list [ i ] then
30406: LD_VAR 0 3
30410: PUSH
30411: LD_EXP 57
30415: PUSH
30416: LD_VAR 0 2
30420: ARRAY
30421: IN
30422: NOT
30423: IFFALSE 30469
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
30425: LD_ADDR_EXP 57
30429: PUSH
30430: LD_EXP 57
30434: PPUSH
30435: LD_VAR 0 2
30439: PUSH
30440: LD_EXP 57
30444: PUSH
30445: LD_VAR 0 2
30449: ARRAY
30450: PUSH
30451: LD_INT 1
30453: PLUS
30454: PUSH
30455: EMPTY
30456: LIST
30457: LIST
30458: PPUSH
30459: LD_VAR 0 3
30463: PPUSH
30464: CALL 54067 0 3
30468: ST_TO_ADDR
// break ;
30469: GO 30473
// end ; end ; end ;
30471: GO 30307
30473: POP
30474: POP
// end ;
30475: GO 30067
30477: POP
30478: POP
// end ;
30479: LD_VAR 0 1
30483: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
30484: LD_INT 0
30486: PPUSH
30487: PPUSH
30488: PPUSH
30489: PPUSH
30490: PPUSH
30491: PPUSH
30492: PPUSH
30493: PPUSH
30494: PPUSH
// if not mc_bases then
30495: LD_EXP 50
30499: NOT
30500: IFFALSE 30504
// exit ;
30502: GO 30909
// for i = 1 to mc_bases do
30504: LD_ADDR_VAR 0 2
30508: PUSH
30509: DOUBLE
30510: LD_INT 1
30512: DEC
30513: ST_TO_ADDR
30514: LD_EXP 50
30518: PUSH
30519: FOR_TO
30520: IFFALSE 30907
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
30522: LD_EXP 58
30526: PUSH
30527: LD_VAR 0 2
30531: ARRAY
30532: NOT
30533: PUSH
30534: LD_EXP 50
30538: PUSH
30539: LD_VAR 0 2
30543: ARRAY
30544: PPUSH
30545: LD_INT 30
30547: PUSH
30548: LD_INT 3
30550: PUSH
30551: EMPTY
30552: LIST
30553: LIST
30554: PPUSH
30555: CALL_OW 72
30559: NOT
30560: OR
30561: IFFALSE 30565
// continue ;
30563: GO 30519
// busy := false ;
30565: LD_ADDR_VAR 0 8
30569: PUSH
30570: LD_INT 0
30572: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
30573: LD_ADDR_VAR 0 4
30577: PUSH
30578: LD_EXP 50
30582: PUSH
30583: LD_VAR 0 2
30587: ARRAY
30588: PPUSH
30589: LD_INT 30
30591: PUSH
30592: LD_INT 3
30594: PUSH
30595: EMPTY
30596: LIST
30597: LIST
30598: PPUSH
30599: CALL_OW 72
30603: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
30604: LD_ADDR_VAR 0 6
30608: PUSH
30609: LD_EXP 58
30613: PUSH
30614: LD_VAR 0 2
30618: ARRAY
30619: PPUSH
30620: LD_INT 2
30622: PUSH
30623: LD_INT 30
30625: PUSH
30626: LD_INT 32
30628: PUSH
30629: EMPTY
30630: LIST
30631: LIST
30632: PUSH
30633: LD_INT 30
30635: PUSH
30636: LD_INT 33
30638: PUSH
30639: EMPTY
30640: LIST
30641: LIST
30642: PUSH
30643: EMPTY
30644: LIST
30645: LIST
30646: LIST
30647: PPUSH
30648: CALL_OW 72
30652: ST_TO_ADDR
// if not t then
30653: LD_VAR 0 6
30657: NOT
30658: IFFALSE 30662
// continue ;
30660: GO 30519
// for j in tmp do
30662: LD_ADDR_VAR 0 3
30666: PUSH
30667: LD_VAR 0 4
30671: PUSH
30672: FOR_IN
30673: IFFALSE 30703
// if not BuildingStatus ( j ) = bs_idle then
30675: LD_VAR 0 3
30679: PPUSH
30680: CALL_OW 461
30684: PUSH
30685: LD_INT 2
30687: EQUAL
30688: NOT
30689: IFFALSE 30701
// begin busy := true ;
30691: LD_ADDR_VAR 0 8
30695: PUSH
30696: LD_INT 1
30698: ST_TO_ADDR
// break ;
30699: GO 30703
// end ;
30701: GO 30672
30703: POP
30704: POP
// if busy then
30705: LD_VAR 0 8
30709: IFFALSE 30713
// continue ;
30711: GO 30519
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
30713: LD_ADDR_VAR 0 7
30717: PUSH
30718: LD_VAR 0 6
30722: PPUSH
30723: LD_INT 35
30725: PUSH
30726: LD_INT 0
30728: PUSH
30729: EMPTY
30730: LIST
30731: LIST
30732: PPUSH
30733: CALL_OW 72
30737: ST_TO_ADDR
// if tw then
30738: LD_VAR 0 7
30742: IFFALSE 30819
// begin tw := tw [ 1 ] ;
30744: LD_ADDR_VAR 0 7
30748: PUSH
30749: LD_VAR 0 7
30753: PUSH
30754: LD_INT 1
30756: ARRAY
30757: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
30758: LD_ADDR_VAR 0 9
30762: PUSH
30763: LD_VAR 0 7
30767: PPUSH
30768: LD_EXP 75
30772: PUSH
30773: LD_VAR 0 2
30777: ARRAY
30778: PPUSH
30779: CALL 59452 0 2
30783: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
30784: LD_EXP 89
30788: PUSH
30789: LD_VAR 0 2
30793: ARRAY
30794: IFFALSE 30817
// if not weapon in mc_allowed_tower_weapons [ i ] then
30796: LD_VAR 0 9
30800: PUSH
30801: LD_EXP 89
30805: PUSH
30806: LD_VAR 0 2
30810: ARRAY
30811: IN
30812: NOT
30813: IFFALSE 30817
// continue ;
30815: GO 30519
// end else
30817: GO 30882
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
30819: LD_ADDR_VAR 0 5
30823: PUSH
30824: LD_EXP 58
30828: PUSH
30829: LD_VAR 0 2
30833: ARRAY
30834: PPUSH
30835: LD_VAR 0 4
30839: PPUSH
30840: CALL 86355 0 2
30844: ST_TO_ADDR
// if not tmp2 then
30845: LD_VAR 0 5
30849: NOT
30850: IFFALSE 30854
// continue ;
30852: GO 30519
// tw := tmp2 [ 1 ] ;
30854: LD_ADDR_VAR 0 7
30858: PUSH
30859: LD_VAR 0 5
30863: PUSH
30864: LD_INT 1
30866: ARRAY
30867: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
30868: LD_ADDR_VAR 0 9
30872: PUSH
30873: LD_VAR 0 5
30877: PUSH
30878: LD_INT 2
30880: ARRAY
30881: ST_TO_ADDR
// end ; if not weapon then
30882: LD_VAR 0 9
30886: NOT
30887: IFFALSE 30891
// continue ;
30889: GO 30519
// ComPlaceWeapon ( tw , weapon ) ;
30891: LD_VAR 0 7
30895: PPUSH
30896: LD_VAR 0 9
30900: PPUSH
30901: CALL_OW 148
// end ;
30905: GO 30519
30907: POP
30908: POP
// end ;
30909: LD_VAR 0 1
30913: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
30914: LD_INT 0
30916: PPUSH
30917: PPUSH
30918: PPUSH
30919: PPUSH
30920: PPUSH
30921: PPUSH
30922: PPUSH
// if not mc_bases then
30923: LD_EXP 50
30927: NOT
30928: IFFALSE 30932
// exit ;
30930: GO 31707
// for i = 1 to mc_bases do
30932: LD_ADDR_VAR 0 2
30936: PUSH
30937: DOUBLE
30938: LD_INT 1
30940: DEC
30941: ST_TO_ADDR
30942: LD_EXP 50
30946: PUSH
30947: FOR_TO
30948: IFFALSE 31705
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
30950: LD_EXP 63
30954: PUSH
30955: LD_VAR 0 2
30959: ARRAY
30960: NOT
30961: PUSH
30962: LD_EXP 63
30966: PUSH
30967: LD_VAR 0 2
30971: ARRAY
30972: PUSH
30973: LD_EXP 64
30977: PUSH
30978: LD_VAR 0 2
30982: ARRAY
30983: EQUAL
30984: OR
30985: PUSH
30986: LD_EXP 73
30990: PUSH
30991: LD_VAR 0 2
30995: ARRAY
30996: OR
30997: IFFALSE 31001
// continue ;
30999: GO 30947
// if mc_miners [ i ] then
31001: LD_EXP 64
31005: PUSH
31006: LD_VAR 0 2
31010: ARRAY
31011: IFFALSE 31392
// begin for j = mc_miners [ i ] downto 1 do
31013: LD_ADDR_VAR 0 3
31017: PUSH
31018: DOUBLE
31019: LD_EXP 64
31023: PUSH
31024: LD_VAR 0 2
31028: ARRAY
31029: INC
31030: ST_TO_ADDR
31031: LD_INT 1
31033: PUSH
31034: FOR_DOWNTO
31035: IFFALSE 31390
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
31037: LD_EXP 64
31041: PUSH
31042: LD_VAR 0 2
31046: ARRAY
31047: PUSH
31048: LD_VAR 0 3
31052: ARRAY
31053: PPUSH
31054: CALL_OW 301
31058: PUSH
31059: LD_EXP 64
31063: PUSH
31064: LD_VAR 0 2
31068: ARRAY
31069: PUSH
31070: LD_VAR 0 3
31074: ARRAY
31075: PPUSH
31076: CALL_OW 257
31080: PUSH
31081: LD_INT 1
31083: NONEQUAL
31084: OR
31085: IFFALSE 31148
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
31087: LD_ADDR_VAR 0 5
31091: PUSH
31092: LD_EXP 64
31096: PUSH
31097: LD_VAR 0 2
31101: ARRAY
31102: PUSH
31103: LD_EXP 64
31107: PUSH
31108: LD_VAR 0 2
31112: ARRAY
31113: PUSH
31114: LD_VAR 0 3
31118: ARRAY
31119: DIFF
31120: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
31121: LD_ADDR_EXP 64
31125: PUSH
31126: LD_EXP 64
31130: PPUSH
31131: LD_VAR 0 2
31135: PPUSH
31136: LD_VAR 0 5
31140: PPUSH
31141: CALL_OW 1
31145: ST_TO_ADDR
// continue ;
31146: GO 31034
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
31148: LD_EXP 64
31152: PUSH
31153: LD_VAR 0 2
31157: ARRAY
31158: PUSH
31159: LD_VAR 0 3
31163: ARRAY
31164: PPUSH
31165: CALL_OW 257
31169: PUSH
31170: LD_INT 1
31172: EQUAL
31173: PUSH
31174: LD_EXP 64
31178: PUSH
31179: LD_VAR 0 2
31183: ARRAY
31184: PUSH
31185: LD_VAR 0 3
31189: ARRAY
31190: PPUSH
31191: CALL_OW 459
31195: NOT
31196: AND
31197: PUSH
31198: LD_EXP 64
31202: PUSH
31203: LD_VAR 0 2
31207: ARRAY
31208: PUSH
31209: LD_VAR 0 3
31213: ARRAY
31214: PPUSH
31215: CALL_OW 314
31219: NOT
31220: AND
31221: IFFALSE 31388
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
31223: LD_EXP 64
31227: PUSH
31228: LD_VAR 0 2
31232: ARRAY
31233: PUSH
31234: LD_VAR 0 3
31238: ARRAY
31239: PPUSH
31240: CALL_OW 310
31244: IFFALSE 31267
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
31246: LD_EXP 64
31250: PUSH
31251: LD_VAR 0 2
31255: ARRAY
31256: PUSH
31257: LD_VAR 0 3
31261: ARRAY
31262: PPUSH
31263: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
31267: LD_EXP 64
31271: PUSH
31272: LD_VAR 0 2
31276: ARRAY
31277: PUSH
31278: LD_VAR 0 3
31282: ARRAY
31283: PPUSH
31284: CALL_OW 314
31288: NOT
31289: IFFALSE 31388
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
31291: LD_ADDR_VAR 0 7
31295: PUSH
31296: LD_VAR 0 3
31300: PUSH
31301: LD_EXP 63
31305: PUSH
31306: LD_VAR 0 2
31310: ARRAY
31311: PPUSH
31312: CALL 51207 0 1
31316: MOD
31317: PUSH
31318: LD_INT 1
31320: PLUS
31321: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
31322: LD_EXP 64
31326: PUSH
31327: LD_VAR 0 2
31331: ARRAY
31332: PUSH
31333: LD_VAR 0 3
31337: ARRAY
31338: PPUSH
31339: LD_EXP 63
31343: PUSH
31344: LD_VAR 0 2
31348: ARRAY
31349: PUSH
31350: LD_VAR 0 7
31354: ARRAY
31355: PUSH
31356: LD_INT 1
31358: ARRAY
31359: PPUSH
31360: LD_EXP 63
31364: PUSH
31365: LD_VAR 0 2
31369: ARRAY
31370: PUSH
31371: LD_VAR 0 7
31375: ARRAY
31376: PUSH
31377: LD_INT 2
31379: ARRAY
31380: PPUSH
31381: LD_INT 0
31383: PPUSH
31384: CALL_OW 193
// end ; end ; end ;
31388: GO 31034
31390: POP
31391: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
31392: LD_ADDR_VAR 0 5
31396: PUSH
31397: LD_EXP 50
31401: PUSH
31402: LD_VAR 0 2
31406: ARRAY
31407: PPUSH
31408: LD_INT 2
31410: PUSH
31411: LD_INT 30
31413: PUSH
31414: LD_INT 4
31416: PUSH
31417: EMPTY
31418: LIST
31419: LIST
31420: PUSH
31421: LD_INT 30
31423: PUSH
31424: LD_INT 5
31426: PUSH
31427: EMPTY
31428: LIST
31429: LIST
31430: PUSH
31431: LD_INT 30
31433: PUSH
31434: LD_INT 32
31436: PUSH
31437: EMPTY
31438: LIST
31439: LIST
31440: PUSH
31441: EMPTY
31442: LIST
31443: LIST
31444: LIST
31445: LIST
31446: PPUSH
31447: CALL_OW 72
31451: ST_TO_ADDR
// if not tmp then
31452: LD_VAR 0 5
31456: NOT
31457: IFFALSE 31461
// continue ;
31459: GO 30947
// list := [ ] ;
31461: LD_ADDR_VAR 0 6
31465: PUSH
31466: EMPTY
31467: ST_TO_ADDR
// for j in tmp do
31468: LD_ADDR_VAR 0 3
31472: PUSH
31473: LD_VAR 0 5
31477: PUSH
31478: FOR_IN
31479: IFFALSE 31548
// begin for k in UnitsInside ( j ) do
31481: LD_ADDR_VAR 0 4
31485: PUSH
31486: LD_VAR 0 3
31490: PPUSH
31491: CALL_OW 313
31495: PUSH
31496: FOR_IN
31497: IFFALSE 31544
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
31499: LD_VAR 0 4
31503: PPUSH
31504: CALL_OW 257
31508: PUSH
31509: LD_INT 1
31511: EQUAL
31512: PUSH
31513: LD_VAR 0 4
31517: PPUSH
31518: CALL_OW 459
31522: NOT
31523: AND
31524: IFFALSE 31542
// list := list ^ k ;
31526: LD_ADDR_VAR 0 6
31530: PUSH
31531: LD_VAR 0 6
31535: PUSH
31536: LD_VAR 0 4
31540: ADD
31541: ST_TO_ADDR
31542: GO 31496
31544: POP
31545: POP
// end ;
31546: GO 31478
31548: POP
31549: POP
// list := list diff mc_miners [ i ] ;
31550: LD_ADDR_VAR 0 6
31554: PUSH
31555: LD_VAR 0 6
31559: PUSH
31560: LD_EXP 64
31564: PUSH
31565: LD_VAR 0 2
31569: ARRAY
31570: DIFF
31571: ST_TO_ADDR
// if not list then
31572: LD_VAR 0 6
31576: NOT
31577: IFFALSE 31581
// continue ;
31579: GO 30947
// k := mc_mines [ i ] - mc_miners [ i ] ;
31581: LD_ADDR_VAR 0 4
31585: PUSH
31586: LD_EXP 63
31590: PUSH
31591: LD_VAR 0 2
31595: ARRAY
31596: PUSH
31597: LD_EXP 64
31601: PUSH
31602: LD_VAR 0 2
31606: ARRAY
31607: MINUS
31608: ST_TO_ADDR
// if k > list then
31609: LD_VAR 0 4
31613: PUSH
31614: LD_VAR 0 6
31618: GREATER
31619: IFFALSE 31631
// k := list ;
31621: LD_ADDR_VAR 0 4
31625: PUSH
31626: LD_VAR 0 6
31630: ST_TO_ADDR
// for j = 1 to k do
31631: LD_ADDR_VAR 0 3
31635: PUSH
31636: DOUBLE
31637: LD_INT 1
31639: DEC
31640: ST_TO_ADDR
31641: LD_VAR 0 4
31645: PUSH
31646: FOR_TO
31647: IFFALSE 31701
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
31649: LD_ADDR_EXP 64
31653: PUSH
31654: LD_EXP 64
31658: PPUSH
31659: LD_VAR 0 2
31663: PUSH
31664: LD_EXP 64
31668: PUSH
31669: LD_VAR 0 2
31673: ARRAY
31674: PUSH
31675: LD_INT 1
31677: PLUS
31678: PUSH
31679: EMPTY
31680: LIST
31681: LIST
31682: PPUSH
31683: LD_VAR 0 6
31687: PUSH
31688: LD_VAR 0 3
31692: ARRAY
31693: PPUSH
31694: CALL 54067 0 3
31698: ST_TO_ADDR
31699: GO 31646
31701: POP
31702: POP
// end ;
31703: GO 30947
31705: POP
31706: POP
// end ;
31707: LD_VAR 0 1
31711: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
31712: LD_INT 0
31714: PPUSH
31715: PPUSH
31716: PPUSH
31717: PPUSH
31718: PPUSH
31719: PPUSH
31720: PPUSH
31721: PPUSH
31722: PPUSH
31723: PPUSH
31724: PPUSH
// if not mc_bases then
31725: LD_EXP 50
31729: NOT
31730: IFFALSE 31734
// exit ;
31732: GO 33557
// for i = 1 to mc_bases do
31734: LD_ADDR_VAR 0 2
31738: PUSH
31739: DOUBLE
31740: LD_INT 1
31742: DEC
31743: ST_TO_ADDR
31744: LD_EXP 50
31748: PUSH
31749: FOR_TO
31750: IFFALSE 33555
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
31752: LD_EXP 50
31756: PUSH
31757: LD_VAR 0 2
31761: ARRAY
31762: NOT
31763: PUSH
31764: LD_EXP 57
31768: PUSH
31769: LD_VAR 0 2
31773: ARRAY
31774: OR
31775: IFFALSE 31779
// continue ;
31777: GO 31749
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
31779: LD_EXP 66
31783: PUSH
31784: LD_VAR 0 2
31788: ARRAY
31789: NOT
31790: PUSH
31791: LD_EXP 67
31795: PUSH
31796: LD_VAR 0 2
31800: ARRAY
31801: AND
31802: IFFALSE 31840
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
31804: LD_ADDR_EXP 67
31808: PUSH
31809: LD_EXP 67
31813: PPUSH
31814: LD_VAR 0 2
31818: PPUSH
31819: EMPTY
31820: PPUSH
31821: CALL_OW 1
31825: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
31826: LD_VAR 0 2
31830: PPUSH
31831: LD_INT 107
31833: PPUSH
31834: CALL 22566 0 2
// continue ;
31838: GO 31749
// end ; target := [ ] ;
31840: LD_ADDR_VAR 0 7
31844: PUSH
31845: EMPTY
31846: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
31847: LD_ADDR_VAR 0 6
31851: PUSH
31852: LD_EXP 50
31856: PUSH
31857: LD_VAR 0 2
31861: ARRAY
31862: PUSH
31863: LD_INT 1
31865: ARRAY
31866: PPUSH
31867: CALL_OW 255
31871: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31872: LD_ADDR_VAR 0 9
31876: PUSH
31877: LD_EXP 50
31881: PUSH
31882: LD_VAR 0 2
31886: ARRAY
31887: PPUSH
31888: LD_INT 2
31890: PUSH
31891: LD_INT 30
31893: PUSH
31894: LD_INT 0
31896: PUSH
31897: EMPTY
31898: LIST
31899: LIST
31900: PUSH
31901: LD_INT 30
31903: PUSH
31904: LD_INT 1
31906: PUSH
31907: EMPTY
31908: LIST
31909: LIST
31910: PUSH
31911: EMPTY
31912: LIST
31913: LIST
31914: LIST
31915: PPUSH
31916: CALL_OW 72
31920: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
31921: LD_ADDR_VAR 0 3
31925: PUSH
31926: DOUBLE
31927: LD_EXP 66
31931: PUSH
31932: LD_VAR 0 2
31936: ARRAY
31937: INC
31938: ST_TO_ADDR
31939: LD_INT 1
31941: PUSH
31942: FOR_DOWNTO
31943: IFFALSE 32188
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
31945: LD_EXP 66
31949: PUSH
31950: LD_VAR 0 2
31954: ARRAY
31955: PUSH
31956: LD_VAR 0 3
31960: ARRAY
31961: PUSH
31962: LD_INT 2
31964: ARRAY
31965: PPUSH
31966: LD_EXP 66
31970: PUSH
31971: LD_VAR 0 2
31975: ARRAY
31976: PUSH
31977: LD_VAR 0 3
31981: ARRAY
31982: PUSH
31983: LD_INT 3
31985: ARRAY
31986: PPUSH
31987: CALL_OW 488
31991: PUSH
31992: LD_EXP 66
31996: PUSH
31997: LD_VAR 0 2
32001: ARRAY
32002: PUSH
32003: LD_VAR 0 3
32007: ARRAY
32008: PUSH
32009: LD_INT 2
32011: ARRAY
32012: PPUSH
32013: LD_EXP 66
32017: PUSH
32018: LD_VAR 0 2
32022: ARRAY
32023: PUSH
32024: LD_VAR 0 3
32028: ARRAY
32029: PUSH
32030: LD_INT 3
32032: ARRAY
32033: PPUSH
32034: CALL_OW 284
32038: PUSH
32039: LD_INT 0
32041: EQUAL
32042: AND
32043: IFFALSE 32098
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
32045: LD_ADDR_VAR 0 5
32049: PUSH
32050: LD_EXP 66
32054: PUSH
32055: LD_VAR 0 2
32059: ARRAY
32060: PPUSH
32061: LD_VAR 0 3
32065: PPUSH
32066: CALL_OW 3
32070: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
32071: LD_ADDR_EXP 66
32075: PUSH
32076: LD_EXP 66
32080: PPUSH
32081: LD_VAR 0 2
32085: PPUSH
32086: LD_VAR 0 5
32090: PPUSH
32091: CALL_OW 1
32095: ST_TO_ADDR
// continue ;
32096: GO 31942
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
32098: LD_VAR 0 6
32102: PPUSH
32103: LD_EXP 66
32107: PUSH
32108: LD_VAR 0 2
32112: ARRAY
32113: PUSH
32114: LD_VAR 0 3
32118: ARRAY
32119: PUSH
32120: LD_INT 2
32122: ARRAY
32123: PPUSH
32124: LD_EXP 66
32128: PUSH
32129: LD_VAR 0 2
32133: ARRAY
32134: PUSH
32135: LD_VAR 0 3
32139: ARRAY
32140: PUSH
32141: LD_INT 3
32143: ARRAY
32144: PPUSH
32145: LD_INT 30
32147: PPUSH
32148: CALL 55331 0 4
32152: PUSH
32153: LD_INT 4
32155: ARRAY
32156: PUSH
32157: LD_INT 0
32159: EQUAL
32160: IFFALSE 32186
// begin target := mc_crates [ i ] [ j ] ;
32162: LD_ADDR_VAR 0 7
32166: PUSH
32167: LD_EXP 66
32171: PUSH
32172: LD_VAR 0 2
32176: ARRAY
32177: PUSH
32178: LD_VAR 0 3
32182: ARRAY
32183: ST_TO_ADDR
// break ;
32184: GO 32188
// end ; end ;
32186: GO 31942
32188: POP
32189: POP
// if not target then
32190: LD_VAR 0 7
32194: NOT
32195: IFFALSE 32199
// continue ;
32197: GO 31749
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
32199: LD_ADDR_VAR 0 8
32203: PUSH
32204: LD_EXP 69
32208: PUSH
32209: LD_VAR 0 2
32213: ARRAY
32214: PPUSH
32215: LD_INT 2
32217: PUSH
32218: LD_INT 3
32220: PUSH
32221: LD_INT 58
32223: PUSH
32224: EMPTY
32225: LIST
32226: PUSH
32227: EMPTY
32228: LIST
32229: LIST
32230: PUSH
32231: LD_INT 61
32233: PUSH
32234: EMPTY
32235: LIST
32236: PUSH
32237: LD_INT 33
32239: PUSH
32240: LD_INT 5
32242: PUSH
32243: EMPTY
32244: LIST
32245: LIST
32246: PUSH
32247: LD_INT 33
32249: PUSH
32250: LD_INT 3
32252: PUSH
32253: EMPTY
32254: LIST
32255: LIST
32256: PUSH
32257: EMPTY
32258: LIST
32259: LIST
32260: LIST
32261: LIST
32262: LIST
32263: PUSH
32264: LD_INT 2
32266: PUSH
32267: LD_INT 34
32269: PUSH
32270: LD_INT 32
32272: PUSH
32273: EMPTY
32274: LIST
32275: LIST
32276: PUSH
32277: LD_INT 34
32279: PUSH
32280: LD_INT 51
32282: PUSH
32283: EMPTY
32284: LIST
32285: LIST
32286: PUSH
32287: LD_INT 34
32289: PUSH
32290: LD_INT 12
32292: PUSH
32293: EMPTY
32294: LIST
32295: LIST
32296: PUSH
32297: EMPTY
32298: LIST
32299: LIST
32300: LIST
32301: LIST
32302: PUSH
32303: EMPTY
32304: LIST
32305: LIST
32306: PPUSH
32307: CALL_OW 72
32311: ST_TO_ADDR
// if not cargo then
32312: LD_VAR 0 8
32316: NOT
32317: IFFALSE 33023
// begin if mc_crates_collector [ i ] < 5 then
32319: LD_EXP 67
32323: PUSH
32324: LD_VAR 0 2
32328: ARRAY
32329: PUSH
32330: LD_INT 5
32332: LESS
32333: IFFALSE 32699
// begin if mc_ape [ i ] then
32335: LD_EXP 79
32339: PUSH
32340: LD_VAR 0 2
32344: ARRAY
32345: IFFALSE 32392
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
32347: LD_ADDR_VAR 0 5
32351: PUSH
32352: LD_EXP 79
32356: PUSH
32357: LD_VAR 0 2
32361: ARRAY
32362: PPUSH
32363: LD_INT 25
32365: PUSH
32366: LD_INT 16
32368: PUSH
32369: EMPTY
32370: LIST
32371: LIST
32372: PUSH
32373: LD_INT 24
32375: PUSH
32376: LD_INT 750
32378: PUSH
32379: EMPTY
32380: LIST
32381: LIST
32382: PUSH
32383: EMPTY
32384: LIST
32385: LIST
32386: PPUSH
32387: CALL_OW 72
32391: ST_TO_ADDR
// if not tmp then
32392: LD_VAR 0 5
32396: NOT
32397: IFFALSE 32444
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
32399: LD_ADDR_VAR 0 5
32403: PUSH
32404: LD_EXP 50
32408: PUSH
32409: LD_VAR 0 2
32413: ARRAY
32414: PPUSH
32415: LD_INT 25
32417: PUSH
32418: LD_INT 2
32420: PUSH
32421: EMPTY
32422: LIST
32423: LIST
32424: PUSH
32425: LD_INT 24
32427: PUSH
32428: LD_INT 750
32430: PUSH
32431: EMPTY
32432: LIST
32433: LIST
32434: PUSH
32435: EMPTY
32436: LIST
32437: LIST
32438: PPUSH
32439: CALL_OW 72
32443: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
32444: LD_EXP 79
32448: PUSH
32449: LD_VAR 0 2
32453: ARRAY
32454: PUSH
32455: LD_EXP 50
32459: PUSH
32460: LD_VAR 0 2
32464: ARRAY
32465: PPUSH
32466: LD_INT 25
32468: PUSH
32469: LD_INT 2
32471: PUSH
32472: EMPTY
32473: LIST
32474: LIST
32475: PUSH
32476: LD_INT 24
32478: PUSH
32479: LD_INT 750
32481: PUSH
32482: EMPTY
32483: LIST
32484: LIST
32485: PUSH
32486: EMPTY
32487: LIST
32488: LIST
32489: PPUSH
32490: CALL_OW 72
32494: AND
32495: PUSH
32496: LD_VAR 0 5
32500: PUSH
32501: LD_INT 5
32503: LESS
32504: AND
32505: IFFALSE 32587
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
32507: LD_ADDR_VAR 0 3
32511: PUSH
32512: LD_EXP 50
32516: PUSH
32517: LD_VAR 0 2
32521: ARRAY
32522: PPUSH
32523: LD_INT 25
32525: PUSH
32526: LD_INT 2
32528: PUSH
32529: EMPTY
32530: LIST
32531: LIST
32532: PUSH
32533: LD_INT 24
32535: PUSH
32536: LD_INT 750
32538: PUSH
32539: EMPTY
32540: LIST
32541: LIST
32542: PUSH
32543: EMPTY
32544: LIST
32545: LIST
32546: PPUSH
32547: CALL_OW 72
32551: PUSH
32552: FOR_IN
32553: IFFALSE 32585
// begin tmp := tmp union j ;
32555: LD_ADDR_VAR 0 5
32559: PUSH
32560: LD_VAR 0 5
32564: PUSH
32565: LD_VAR 0 3
32569: UNION
32570: ST_TO_ADDR
// if tmp >= 5 then
32571: LD_VAR 0 5
32575: PUSH
32576: LD_INT 5
32578: GREATEREQUAL
32579: IFFALSE 32583
// break ;
32581: GO 32585
// end ;
32583: GO 32552
32585: POP
32586: POP
// end ; if not tmp then
32587: LD_VAR 0 5
32591: NOT
32592: IFFALSE 32596
// continue ;
32594: GO 31749
// for j in tmp do
32596: LD_ADDR_VAR 0 3
32600: PUSH
32601: LD_VAR 0 5
32605: PUSH
32606: FOR_IN
32607: IFFALSE 32697
// if not GetTag ( j ) then
32609: LD_VAR 0 3
32613: PPUSH
32614: CALL_OW 110
32618: NOT
32619: IFFALSE 32695
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
32621: LD_ADDR_EXP 67
32625: PUSH
32626: LD_EXP 67
32630: PPUSH
32631: LD_VAR 0 2
32635: PUSH
32636: LD_EXP 67
32640: PUSH
32641: LD_VAR 0 2
32645: ARRAY
32646: PUSH
32647: LD_INT 1
32649: PLUS
32650: PUSH
32651: EMPTY
32652: LIST
32653: LIST
32654: PPUSH
32655: LD_VAR 0 3
32659: PPUSH
32660: CALL 54067 0 3
32664: ST_TO_ADDR
// SetTag ( j , 107 ) ;
32665: LD_VAR 0 3
32669: PPUSH
32670: LD_INT 107
32672: PPUSH
32673: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
32677: LD_EXP 67
32681: PUSH
32682: LD_VAR 0 2
32686: ARRAY
32687: PUSH
32688: LD_INT 5
32690: GREATEREQUAL
32691: IFFALSE 32695
// break ;
32693: GO 32697
// end ;
32695: GO 32606
32697: POP
32698: POP
// end ; if mc_crates_collector [ i ] and target then
32699: LD_EXP 67
32703: PUSH
32704: LD_VAR 0 2
32708: ARRAY
32709: PUSH
32710: LD_VAR 0 7
32714: AND
32715: IFFALSE 33021
// begin if mc_crates_collector [ i ] < target [ 1 ] then
32717: LD_EXP 67
32721: PUSH
32722: LD_VAR 0 2
32726: ARRAY
32727: PUSH
32728: LD_VAR 0 7
32732: PUSH
32733: LD_INT 1
32735: ARRAY
32736: LESS
32737: IFFALSE 32757
// tmp := mc_crates_collector [ i ] else
32739: LD_ADDR_VAR 0 5
32743: PUSH
32744: LD_EXP 67
32748: PUSH
32749: LD_VAR 0 2
32753: ARRAY
32754: ST_TO_ADDR
32755: GO 32771
// tmp := target [ 1 ] ;
32757: LD_ADDR_VAR 0 5
32761: PUSH
32762: LD_VAR 0 7
32766: PUSH
32767: LD_INT 1
32769: ARRAY
32770: ST_TO_ADDR
// k := 0 ;
32771: LD_ADDR_VAR 0 4
32775: PUSH
32776: LD_INT 0
32778: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
32779: LD_ADDR_VAR 0 3
32783: PUSH
32784: LD_EXP 67
32788: PUSH
32789: LD_VAR 0 2
32793: ARRAY
32794: PUSH
32795: FOR_IN
32796: IFFALSE 33019
// begin k := k + 1 ;
32798: LD_ADDR_VAR 0 4
32802: PUSH
32803: LD_VAR 0 4
32807: PUSH
32808: LD_INT 1
32810: PLUS
32811: ST_TO_ADDR
// if k > tmp then
32812: LD_VAR 0 4
32816: PUSH
32817: LD_VAR 0 5
32821: GREATER
32822: IFFALSE 32826
// break ;
32824: GO 33019
// if not GetClass ( j ) in [ 2 , 16 ] then
32826: LD_VAR 0 3
32830: PPUSH
32831: CALL_OW 257
32835: PUSH
32836: LD_INT 2
32838: PUSH
32839: LD_INT 16
32841: PUSH
32842: EMPTY
32843: LIST
32844: LIST
32845: IN
32846: NOT
32847: IFFALSE 32900
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
32849: LD_ADDR_EXP 67
32853: PUSH
32854: LD_EXP 67
32858: PPUSH
32859: LD_VAR 0 2
32863: PPUSH
32864: LD_EXP 67
32868: PUSH
32869: LD_VAR 0 2
32873: ARRAY
32874: PUSH
32875: LD_VAR 0 3
32879: DIFF
32880: PPUSH
32881: CALL_OW 1
32885: ST_TO_ADDR
// SetTag ( j , 0 ) ;
32886: LD_VAR 0 3
32890: PPUSH
32891: LD_INT 0
32893: PPUSH
32894: CALL_OW 109
// continue ;
32898: GO 32795
// end ; if IsInUnit ( j ) then
32900: LD_VAR 0 3
32904: PPUSH
32905: CALL_OW 310
32909: IFFALSE 32920
// ComExitBuilding ( j ) ;
32911: LD_VAR 0 3
32915: PPUSH
32916: CALL_OW 122
// wait ( 3 ) ;
32920: LD_INT 3
32922: PPUSH
32923: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
32927: LD_VAR 0 3
32931: PPUSH
32932: CALL_OW 314
32936: PUSH
32937: LD_VAR 0 6
32941: PPUSH
32942: LD_VAR 0 7
32946: PUSH
32947: LD_INT 2
32949: ARRAY
32950: PPUSH
32951: LD_VAR 0 7
32955: PUSH
32956: LD_INT 3
32958: ARRAY
32959: PPUSH
32960: LD_INT 30
32962: PPUSH
32963: CALL 55331 0 4
32967: PUSH
32968: LD_INT 4
32970: ARRAY
32971: AND
32972: IFFALSE 32990
// ComStandNearbyBuilding ( j , depot ) else
32974: LD_VAR 0 3
32978: PPUSH
32979: LD_VAR 0 9
32983: PPUSH
32984: CALL 50669 0 2
32988: GO 33017
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
32990: LD_VAR 0 3
32994: PPUSH
32995: LD_VAR 0 7
32999: PUSH
33000: LD_INT 2
33002: ARRAY
33003: PPUSH
33004: LD_VAR 0 7
33008: PUSH
33009: LD_INT 3
33011: ARRAY
33012: PPUSH
33013: CALL_OW 117
// end ;
33017: GO 32795
33019: POP
33020: POP
// end ; end else
33021: GO 33553
// begin for j in cargo do
33023: LD_ADDR_VAR 0 3
33027: PUSH
33028: LD_VAR 0 8
33032: PUSH
33033: FOR_IN
33034: IFFALSE 33551
// begin if GetTag ( j ) <> 0 then
33036: LD_VAR 0 3
33040: PPUSH
33041: CALL_OW 110
33045: PUSH
33046: LD_INT 0
33048: NONEQUAL
33049: IFFALSE 33053
// continue ;
33051: GO 33033
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
33053: LD_VAR 0 3
33057: PPUSH
33058: CALL_OW 256
33062: PUSH
33063: LD_INT 1000
33065: LESS
33066: PUSH
33067: LD_VAR 0 3
33071: PPUSH
33072: LD_EXP 74
33076: PUSH
33077: LD_VAR 0 2
33081: ARRAY
33082: PPUSH
33083: CALL_OW 308
33087: NOT
33088: AND
33089: IFFALSE 33111
// ComMoveToArea ( j , mc_parking [ i ] ) ;
33091: LD_VAR 0 3
33095: PPUSH
33096: LD_EXP 74
33100: PUSH
33101: LD_VAR 0 2
33105: ARRAY
33106: PPUSH
33107: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
33111: LD_VAR 0 3
33115: PPUSH
33116: CALL_OW 256
33120: PUSH
33121: LD_INT 1000
33123: LESS
33124: PUSH
33125: LD_VAR 0 3
33129: PPUSH
33130: LD_EXP 74
33134: PUSH
33135: LD_VAR 0 2
33139: ARRAY
33140: PPUSH
33141: CALL_OW 308
33145: AND
33146: IFFALSE 33150
// continue ;
33148: GO 33033
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
33150: LD_VAR 0 3
33154: PPUSH
33155: CALL_OW 262
33159: PUSH
33160: LD_INT 2
33162: EQUAL
33163: PUSH
33164: LD_VAR 0 3
33168: PPUSH
33169: CALL_OW 261
33173: PUSH
33174: LD_INT 15
33176: LESS
33177: AND
33178: IFFALSE 33182
// continue ;
33180: GO 33033
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
33182: LD_VAR 0 3
33186: PPUSH
33187: CALL_OW 262
33191: PUSH
33192: LD_INT 1
33194: EQUAL
33195: PUSH
33196: LD_VAR 0 3
33200: PPUSH
33201: CALL_OW 261
33205: PUSH
33206: LD_INT 10
33208: LESS
33209: AND
33210: IFFALSE 33490
// begin if not depot then
33212: LD_VAR 0 9
33216: NOT
33217: IFFALSE 33221
// continue ;
33219: GO 33033
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
33221: LD_VAR 0 3
33225: PPUSH
33226: LD_VAR 0 9
33230: PPUSH
33231: LD_VAR 0 3
33235: PPUSH
33236: CALL_OW 74
33240: PPUSH
33241: CALL_OW 296
33245: PUSH
33246: LD_INT 6
33248: LESS
33249: IFFALSE 33265
// SetFuel ( j , 100 ) else
33251: LD_VAR 0 3
33255: PPUSH
33256: LD_INT 100
33258: PPUSH
33259: CALL_OW 240
33263: GO 33490
// if GetFuel ( j ) = 0 then
33265: LD_VAR 0 3
33269: PPUSH
33270: CALL_OW 261
33274: PUSH
33275: LD_INT 0
33277: EQUAL
33278: IFFALSE 33490
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
33280: LD_ADDR_EXP 69
33284: PUSH
33285: LD_EXP 69
33289: PPUSH
33290: LD_VAR 0 2
33294: PPUSH
33295: LD_EXP 69
33299: PUSH
33300: LD_VAR 0 2
33304: ARRAY
33305: PUSH
33306: LD_VAR 0 3
33310: DIFF
33311: PPUSH
33312: CALL_OW 1
33316: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
33317: LD_VAR 0 3
33321: PPUSH
33322: CALL_OW 263
33326: PUSH
33327: LD_INT 1
33329: EQUAL
33330: IFFALSE 33346
// ComExitVehicle ( IsInUnit ( j ) ) ;
33332: LD_VAR 0 3
33336: PPUSH
33337: CALL_OW 310
33341: PPUSH
33342: CALL_OW 121
// if GetControl ( j ) = control_remote then
33346: LD_VAR 0 3
33350: PPUSH
33351: CALL_OW 263
33355: PUSH
33356: LD_INT 2
33358: EQUAL
33359: IFFALSE 33370
// ComUnlink ( j ) ;
33361: LD_VAR 0 3
33365: PPUSH
33366: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
33370: LD_ADDR_VAR 0 10
33374: PUSH
33375: LD_VAR 0 2
33379: PPUSH
33380: LD_INT 3
33382: PPUSH
33383: CALL 43134 0 2
33387: ST_TO_ADDR
// if fac then
33388: LD_VAR 0 10
33392: IFFALSE 33488
// begin for k in fac do
33394: LD_ADDR_VAR 0 4
33398: PUSH
33399: LD_VAR 0 10
33403: PUSH
33404: FOR_IN
33405: IFFALSE 33486
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
33407: LD_ADDR_VAR 0 11
33411: PUSH
33412: LD_VAR 0 10
33416: PPUSH
33417: LD_VAR 0 3
33421: PPUSH
33422: CALL_OW 265
33426: PPUSH
33427: LD_VAR 0 3
33431: PPUSH
33432: CALL_OW 262
33436: PPUSH
33437: LD_VAR 0 3
33441: PPUSH
33442: CALL_OW 263
33446: PPUSH
33447: LD_VAR 0 3
33451: PPUSH
33452: CALL_OW 264
33456: PPUSH
33457: CALL 51565 0 5
33461: ST_TO_ADDR
// if components then
33462: LD_VAR 0 11
33466: IFFALSE 33484
// begin MC_InsertProduceList ( i , components ) ;
33468: LD_VAR 0 2
33472: PPUSH
33473: LD_VAR 0 11
33477: PPUSH
33478: CALL 42679 0 2
// break ;
33482: GO 33486
// end ; end ;
33484: GO 33404
33486: POP
33487: POP
// end ; continue ;
33488: GO 33033
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
33490: LD_VAR 0 3
33494: PPUSH
33495: LD_INT 1
33497: PPUSH
33498: CALL_OW 289
33502: PUSH
33503: LD_INT 100
33505: LESS
33506: PUSH
33507: LD_VAR 0 3
33511: PPUSH
33512: CALL_OW 314
33516: NOT
33517: AND
33518: IFFALSE 33547
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
33520: LD_VAR 0 3
33524: PPUSH
33525: LD_VAR 0 7
33529: PUSH
33530: LD_INT 2
33532: ARRAY
33533: PPUSH
33534: LD_VAR 0 7
33538: PUSH
33539: LD_INT 3
33541: ARRAY
33542: PPUSH
33543: CALL_OW 117
// break ;
33547: GO 33551
// end ;
33549: GO 33033
33551: POP
33552: POP
// end ; end ;
33553: GO 31749
33555: POP
33556: POP
// end ;
33557: LD_VAR 0 1
33561: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
33562: LD_INT 0
33564: PPUSH
33565: PPUSH
33566: PPUSH
33567: PPUSH
// if not mc_bases then
33568: LD_EXP 50
33572: NOT
33573: IFFALSE 33577
// exit ;
33575: GO 33738
// for i = 1 to mc_bases do
33577: LD_ADDR_VAR 0 2
33581: PUSH
33582: DOUBLE
33583: LD_INT 1
33585: DEC
33586: ST_TO_ADDR
33587: LD_EXP 50
33591: PUSH
33592: FOR_TO
33593: IFFALSE 33736
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
33595: LD_ADDR_VAR 0 4
33599: PUSH
33600: LD_EXP 69
33604: PUSH
33605: LD_VAR 0 2
33609: ARRAY
33610: PUSH
33611: LD_EXP 72
33615: PUSH
33616: LD_VAR 0 2
33620: ARRAY
33621: UNION
33622: PPUSH
33623: LD_INT 33
33625: PUSH
33626: LD_INT 2
33628: PUSH
33629: EMPTY
33630: LIST
33631: LIST
33632: PPUSH
33633: CALL_OW 72
33637: ST_TO_ADDR
// if tmp then
33638: LD_VAR 0 4
33642: IFFALSE 33734
// for j in tmp do
33644: LD_ADDR_VAR 0 3
33648: PUSH
33649: LD_VAR 0 4
33653: PUSH
33654: FOR_IN
33655: IFFALSE 33732
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
33657: LD_VAR 0 3
33661: PPUSH
33662: CALL_OW 312
33666: NOT
33667: PUSH
33668: LD_VAR 0 3
33672: PPUSH
33673: CALL_OW 256
33677: PUSH
33678: LD_INT 250
33680: GREATEREQUAL
33681: AND
33682: IFFALSE 33695
// Connect ( j ) else
33684: LD_VAR 0 3
33688: PPUSH
33689: CALL 57413 0 1
33693: GO 33730
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
33695: LD_VAR 0 3
33699: PPUSH
33700: CALL_OW 256
33704: PUSH
33705: LD_INT 250
33707: LESS
33708: PUSH
33709: LD_VAR 0 3
33713: PPUSH
33714: CALL_OW 312
33718: AND
33719: IFFALSE 33730
// ComUnlink ( j ) ;
33721: LD_VAR 0 3
33725: PPUSH
33726: CALL_OW 136
33730: GO 33654
33732: POP
33733: POP
// end ;
33734: GO 33592
33736: POP
33737: POP
// end ;
33738: LD_VAR 0 1
33742: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
33743: LD_INT 0
33745: PPUSH
33746: PPUSH
33747: PPUSH
33748: PPUSH
33749: PPUSH
// if not mc_bases then
33750: LD_EXP 50
33754: NOT
33755: IFFALSE 33759
// exit ;
33757: GO 34204
// for i = 1 to mc_bases do
33759: LD_ADDR_VAR 0 2
33763: PUSH
33764: DOUBLE
33765: LD_INT 1
33767: DEC
33768: ST_TO_ADDR
33769: LD_EXP 50
33773: PUSH
33774: FOR_TO
33775: IFFALSE 34202
// begin if not mc_produce [ i ] then
33777: LD_EXP 71
33781: PUSH
33782: LD_VAR 0 2
33786: ARRAY
33787: NOT
33788: IFFALSE 33792
// continue ;
33790: GO 33774
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
33792: LD_ADDR_VAR 0 5
33796: PUSH
33797: LD_EXP 50
33801: PUSH
33802: LD_VAR 0 2
33806: ARRAY
33807: PPUSH
33808: LD_INT 30
33810: PUSH
33811: LD_INT 3
33813: PUSH
33814: EMPTY
33815: LIST
33816: LIST
33817: PPUSH
33818: CALL_OW 72
33822: ST_TO_ADDR
// if not fac then
33823: LD_VAR 0 5
33827: NOT
33828: IFFALSE 33832
// continue ;
33830: GO 33774
// for j in fac do
33832: LD_ADDR_VAR 0 3
33836: PUSH
33837: LD_VAR 0 5
33841: PUSH
33842: FOR_IN
33843: IFFALSE 34198
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
33845: LD_VAR 0 3
33849: PPUSH
33850: CALL_OW 461
33854: PUSH
33855: LD_INT 2
33857: NONEQUAL
33858: PUSH
33859: LD_VAR 0 3
33863: PPUSH
33864: LD_INT 15
33866: PPUSH
33867: CALL 57032 0 2
33871: PUSH
33872: LD_INT 4
33874: ARRAY
33875: OR
33876: IFFALSE 33880
// continue ;
33878: GO 33842
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
33880: LD_VAR 0 3
33884: PPUSH
33885: LD_EXP 71
33889: PUSH
33890: LD_VAR 0 2
33894: ARRAY
33895: PUSH
33896: LD_INT 1
33898: ARRAY
33899: PUSH
33900: LD_INT 1
33902: ARRAY
33903: PPUSH
33904: LD_EXP 71
33908: PUSH
33909: LD_VAR 0 2
33913: ARRAY
33914: PUSH
33915: LD_INT 1
33917: ARRAY
33918: PUSH
33919: LD_INT 2
33921: ARRAY
33922: PPUSH
33923: LD_EXP 71
33927: PUSH
33928: LD_VAR 0 2
33932: ARRAY
33933: PUSH
33934: LD_INT 1
33936: ARRAY
33937: PUSH
33938: LD_INT 3
33940: ARRAY
33941: PPUSH
33942: LD_EXP 71
33946: PUSH
33947: LD_VAR 0 2
33951: ARRAY
33952: PUSH
33953: LD_INT 1
33955: ARRAY
33956: PUSH
33957: LD_INT 4
33959: ARRAY
33960: PPUSH
33961: CALL_OW 448
33965: PUSH
33966: LD_VAR 0 3
33970: PPUSH
33971: LD_EXP 71
33975: PUSH
33976: LD_VAR 0 2
33980: ARRAY
33981: PUSH
33982: LD_INT 1
33984: ARRAY
33985: PUSH
33986: LD_INT 1
33988: ARRAY
33989: PUSH
33990: LD_EXP 71
33994: PUSH
33995: LD_VAR 0 2
33999: ARRAY
34000: PUSH
34001: LD_INT 1
34003: ARRAY
34004: PUSH
34005: LD_INT 2
34007: ARRAY
34008: PUSH
34009: LD_EXP 71
34013: PUSH
34014: LD_VAR 0 2
34018: ARRAY
34019: PUSH
34020: LD_INT 1
34022: ARRAY
34023: PUSH
34024: LD_INT 3
34026: ARRAY
34027: PUSH
34028: LD_EXP 71
34032: PUSH
34033: LD_VAR 0 2
34037: ARRAY
34038: PUSH
34039: LD_INT 1
34041: ARRAY
34042: PUSH
34043: LD_INT 4
34045: ARRAY
34046: PUSH
34047: EMPTY
34048: LIST
34049: LIST
34050: LIST
34051: LIST
34052: PPUSH
34053: CALL 60808 0 2
34057: AND
34058: IFFALSE 34196
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
34060: LD_VAR 0 3
34064: PPUSH
34065: LD_EXP 71
34069: PUSH
34070: LD_VAR 0 2
34074: ARRAY
34075: PUSH
34076: LD_INT 1
34078: ARRAY
34079: PUSH
34080: LD_INT 1
34082: ARRAY
34083: PPUSH
34084: LD_EXP 71
34088: PUSH
34089: LD_VAR 0 2
34093: ARRAY
34094: PUSH
34095: LD_INT 1
34097: ARRAY
34098: PUSH
34099: LD_INT 2
34101: ARRAY
34102: PPUSH
34103: LD_EXP 71
34107: PUSH
34108: LD_VAR 0 2
34112: ARRAY
34113: PUSH
34114: LD_INT 1
34116: ARRAY
34117: PUSH
34118: LD_INT 3
34120: ARRAY
34121: PPUSH
34122: LD_EXP 71
34126: PUSH
34127: LD_VAR 0 2
34131: ARRAY
34132: PUSH
34133: LD_INT 1
34135: ARRAY
34136: PUSH
34137: LD_INT 4
34139: ARRAY
34140: PPUSH
34141: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
34145: LD_ADDR_VAR 0 4
34149: PUSH
34150: LD_EXP 71
34154: PUSH
34155: LD_VAR 0 2
34159: ARRAY
34160: PPUSH
34161: LD_INT 1
34163: PPUSH
34164: CALL_OW 3
34168: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
34169: LD_ADDR_EXP 71
34173: PUSH
34174: LD_EXP 71
34178: PPUSH
34179: LD_VAR 0 2
34183: PPUSH
34184: LD_VAR 0 4
34188: PPUSH
34189: CALL_OW 1
34193: ST_TO_ADDR
// break ;
34194: GO 34198
// end ; end ;
34196: GO 33842
34198: POP
34199: POP
// end ;
34200: GO 33774
34202: POP
34203: POP
// end ;
34204: LD_VAR 0 1
34208: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
34209: LD_INT 0
34211: PPUSH
34212: PPUSH
34213: PPUSH
// if not mc_bases then
34214: LD_EXP 50
34218: NOT
34219: IFFALSE 34223
// exit ;
34221: GO 34312
// for i = 1 to mc_bases do
34223: LD_ADDR_VAR 0 2
34227: PUSH
34228: DOUBLE
34229: LD_INT 1
34231: DEC
34232: ST_TO_ADDR
34233: LD_EXP 50
34237: PUSH
34238: FOR_TO
34239: IFFALSE 34310
// begin if mc_attack [ i ] then
34241: LD_EXP 70
34245: PUSH
34246: LD_VAR 0 2
34250: ARRAY
34251: IFFALSE 34308
// begin tmp := mc_attack [ i ] [ 1 ] ;
34253: LD_ADDR_VAR 0 3
34257: PUSH
34258: LD_EXP 70
34262: PUSH
34263: LD_VAR 0 2
34267: ARRAY
34268: PUSH
34269: LD_INT 1
34271: ARRAY
34272: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
34273: LD_ADDR_EXP 70
34277: PUSH
34278: LD_EXP 70
34282: PPUSH
34283: LD_VAR 0 2
34287: PPUSH
34288: EMPTY
34289: PPUSH
34290: CALL_OW 1
34294: ST_TO_ADDR
// Attack ( tmp ) ;
34295: LD_VAR 0 3
34299: PPUSH
34300: CALL 111559 0 1
// exit ;
34304: POP
34305: POP
34306: GO 34312
// end ; end ;
34308: GO 34238
34310: POP
34311: POP
// end ;
34312: LD_VAR 0 1
34316: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
34317: LD_INT 0
34319: PPUSH
34320: PPUSH
34321: PPUSH
34322: PPUSH
34323: PPUSH
34324: PPUSH
34325: PPUSH
// if not mc_bases then
34326: LD_EXP 50
34330: NOT
34331: IFFALSE 34335
// exit ;
34333: GO 35192
// for i = 1 to mc_bases do
34335: LD_ADDR_VAR 0 2
34339: PUSH
34340: DOUBLE
34341: LD_INT 1
34343: DEC
34344: ST_TO_ADDR
34345: LD_EXP 50
34349: PUSH
34350: FOR_TO
34351: IFFALSE 35190
// begin if not mc_bases [ i ] then
34353: LD_EXP 50
34357: PUSH
34358: LD_VAR 0 2
34362: ARRAY
34363: NOT
34364: IFFALSE 34368
// continue ;
34366: GO 34350
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
34368: LD_ADDR_VAR 0 7
34372: PUSH
34373: LD_EXP 50
34377: PUSH
34378: LD_VAR 0 2
34382: ARRAY
34383: PUSH
34384: LD_INT 1
34386: ARRAY
34387: PPUSH
34388: CALL 50891 0 1
34392: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
34393: LD_ADDR_EXP 73
34397: PUSH
34398: LD_EXP 73
34402: PPUSH
34403: LD_VAR 0 2
34407: PPUSH
34408: LD_EXP 50
34412: PUSH
34413: LD_VAR 0 2
34417: ARRAY
34418: PUSH
34419: LD_INT 1
34421: ARRAY
34422: PPUSH
34423: CALL_OW 255
34427: PPUSH
34428: LD_EXP 75
34432: PUSH
34433: LD_VAR 0 2
34437: ARRAY
34438: PPUSH
34439: CALL 50856 0 2
34443: PPUSH
34444: CALL_OW 1
34448: ST_TO_ADDR
// if not mc_scan [ i ] then
34449: LD_EXP 73
34453: PUSH
34454: LD_VAR 0 2
34458: ARRAY
34459: NOT
34460: IFFALSE 34638
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
34462: LD_ADDR_EXP 93
34466: PUSH
34467: LD_EXP 93
34471: PPUSH
34472: LD_VAR 0 2
34476: PPUSH
34477: LD_INT 0
34479: PPUSH
34480: CALL_OW 1
34484: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
34485: LD_ADDR_VAR 0 4
34489: PUSH
34490: LD_EXP 50
34494: PUSH
34495: LD_VAR 0 2
34499: ARRAY
34500: PPUSH
34501: LD_INT 2
34503: PUSH
34504: LD_INT 25
34506: PUSH
34507: LD_INT 5
34509: PUSH
34510: EMPTY
34511: LIST
34512: LIST
34513: PUSH
34514: LD_INT 25
34516: PUSH
34517: LD_INT 8
34519: PUSH
34520: EMPTY
34521: LIST
34522: LIST
34523: PUSH
34524: LD_INT 25
34526: PUSH
34527: LD_INT 9
34529: PUSH
34530: EMPTY
34531: LIST
34532: LIST
34533: PUSH
34534: EMPTY
34535: LIST
34536: LIST
34537: LIST
34538: LIST
34539: PPUSH
34540: CALL_OW 72
34544: ST_TO_ADDR
// if not tmp then
34545: LD_VAR 0 4
34549: NOT
34550: IFFALSE 34554
// continue ;
34552: GO 34350
// for j in tmp do
34554: LD_ADDR_VAR 0 3
34558: PUSH
34559: LD_VAR 0 4
34563: PUSH
34564: FOR_IN
34565: IFFALSE 34636
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
34567: LD_VAR 0 3
34571: PPUSH
34572: CALL_OW 310
34576: PPUSH
34577: CALL_OW 266
34581: PUSH
34582: LD_INT 5
34584: EQUAL
34585: PUSH
34586: LD_VAR 0 3
34590: PPUSH
34591: CALL_OW 257
34595: PUSH
34596: LD_INT 1
34598: EQUAL
34599: AND
34600: PUSH
34601: LD_VAR 0 3
34605: PPUSH
34606: CALL_OW 459
34610: NOT
34611: AND
34612: PUSH
34613: LD_VAR 0 7
34617: AND
34618: IFFALSE 34634
// ComChangeProfession ( j , class ) ;
34620: LD_VAR 0 3
34624: PPUSH
34625: LD_VAR 0 7
34629: PPUSH
34630: CALL_OW 123
34634: GO 34564
34636: POP
34637: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
34638: LD_EXP 73
34642: PUSH
34643: LD_VAR 0 2
34647: ARRAY
34648: PUSH
34649: LD_EXP 93
34653: PUSH
34654: LD_VAR 0 2
34658: ARRAY
34659: NOT
34660: AND
34661: PUSH
34662: LD_EXP 72
34666: PUSH
34667: LD_VAR 0 2
34671: ARRAY
34672: NOT
34673: AND
34674: PUSH
34675: LD_EXP 50
34679: PUSH
34680: LD_VAR 0 2
34684: ARRAY
34685: PPUSH
34686: LD_INT 50
34688: PUSH
34689: EMPTY
34690: LIST
34691: PUSH
34692: LD_INT 2
34694: PUSH
34695: LD_INT 30
34697: PUSH
34698: LD_INT 32
34700: PUSH
34701: EMPTY
34702: LIST
34703: LIST
34704: PUSH
34705: LD_INT 30
34707: PUSH
34708: LD_INT 33
34710: PUSH
34711: EMPTY
34712: LIST
34713: LIST
34714: PUSH
34715: LD_INT 30
34717: PUSH
34718: LD_INT 4
34720: PUSH
34721: EMPTY
34722: LIST
34723: LIST
34724: PUSH
34725: LD_INT 30
34727: PUSH
34728: LD_INT 5
34730: PUSH
34731: EMPTY
34732: LIST
34733: LIST
34734: PUSH
34735: EMPTY
34736: LIST
34737: LIST
34738: LIST
34739: LIST
34740: LIST
34741: PUSH
34742: EMPTY
34743: LIST
34744: LIST
34745: PPUSH
34746: CALL_OW 72
34750: PUSH
34751: LD_INT 4
34753: LESS
34754: PUSH
34755: LD_EXP 50
34759: PUSH
34760: LD_VAR 0 2
34764: ARRAY
34765: PPUSH
34766: LD_INT 3
34768: PUSH
34769: LD_INT 24
34771: PUSH
34772: LD_INT 1000
34774: PUSH
34775: EMPTY
34776: LIST
34777: LIST
34778: PUSH
34779: EMPTY
34780: LIST
34781: LIST
34782: PUSH
34783: LD_INT 2
34785: PUSH
34786: LD_INT 30
34788: PUSH
34789: LD_INT 0
34791: PUSH
34792: EMPTY
34793: LIST
34794: LIST
34795: PUSH
34796: LD_INT 30
34798: PUSH
34799: LD_INT 1
34801: PUSH
34802: EMPTY
34803: LIST
34804: LIST
34805: PUSH
34806: EMPTY
34807: LIST
34808: LIST
34809: LIST
34810: PUSH
34811: EMPTY
34812: LIST
34813: LIST
34814: PPUSH
34815: CALL_OW 72
34819: OR
34820: AND
34821: IFFALSE 35072
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
34823: LD_ADDR_EXP 93
34827: PUSH
34828: LD_EXP 93
34832: PPUSH
34833: LD_VAR 0 2
34837: PPUSH
34838: LD_INT 1
34840: PPUSH
34841: CALL_OW 1
34845: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
34846: LD_ADDR_VAR 0 4
34850: PUSH
34851: LD_EXP 50
34855: PUSH
34856: LD_VAR 0 2
34860: ARRAY
34861: PPUSH
34862: LD_INT 2
34864: PUSH
34865: LD_INT 25
34867: PUSH
34868: LD_INT 1
34870: PUSH
34871: EMPTY
34872: LIST
34873: LIST
34874: PUSH
34875: LD_INT 25
34877: PUSH
34878: LD_INT 5
34880: PUSH
34881: EMPTY
34882: LIST
34883: LIST
34884: PUSH
34885: LD_INT 25
34887: PUSH
34888: LD_INT 8
34890: PUSH
34891: EMPTY
34892: LIST
34893: LIST
34894: PUSH
34895: LD_INT 25
34897: PUSH
34898: LD_INT 9
34900: PUSH
34901: EMPTY
34902: LIST
34903: LIST
34904: PUSH
34905: EMPTY
34906: LIST
34907: LIST
34908: LIST
34909: LIST
34910: LIST
34911: PPUSH
34912: CALL_OW 72
34916: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
34917: LD_ADDR_VAR 0 4
34921: PUSH
34922: LD_VAR 0 4
34926: PUSH
34927: LD_VAR 0 4
34931: PPUSH
34932: LD_INT 18
34934: PPUSH
34935: CALL 84376 0 2
34939: DIFF
34940: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
34941: LD_VAR 0 4
34945: NOT
34946: PUSH
34947: LD_EXP 50
34951: PUSH
34952: LD_VAR 0 2
34956: ARRAY
34957: PPUSH
34958: LD_INT 2
34960: PUSH
34961: LD_INT 30
34963: PUSH
34964: LD_INT 4
34966: PUSH
34967: EMPTY
34968: LIST
34969: LIST
34970: PUSH
34971: LD_INT 30
34973: PUSH
34974: LD_INT 5
34976: PUSH
34977: EMPTY
34978: LIST
34979: LIST
34980: PUSH
34981: EMPTY
34982: LIST
34983: LIST
34984: LIST
34985: PPUSH
34986: CALL_OW 72
34990: NOT
34991: AND
34992: IFFALSE 35054
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
34994: LD_ADDR_VAR 0 4
34998: PUSH
34999: LD_EXP 50
35003: PUSH
35004: LD_VAR 0 2
35008: ARRAY
35009: PPUSH
35010: LD_INT 2
35012: PUSH
35013: LD_INT 25
35015: PUSH
35016: LD_INT 2
35018: PUSH
35019: EMPTY
35020: LIST
35021: LIST
35022: PUSH
35023: LD_INT 25
35025: PUSH
35026: LD_INT 3
35028: PUSH
35029: EMPTY
35030: LIST
35031: LIST
35032: PUSH
35033: LD_INT 25
35035: PUSH
35036: LD_INT 4
35038: PUSH
35039: EMPTY
35040: LIST
35041: LIST
35042: PUSH
35043: EMPTY
35044: LIST
35045: LIST
35046: LIST
35047: LIST
35048: PPUSH
35049: CALL_OW 72
35053: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
35054: LD_VAR 0 2
35058: PPUSH
35059: LD_VAR 0 4
35063: PPUSH
35064: CALL 116268 0 2
// exit ;
35068: POP
35069: POP
35070: GO 35192
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
35072: LD_EXP 73
35076: PUSH
35077: LD_VAR 0 2
35081: ARRAY
35082: PUSH
35083: LD_EXP 93
35087: PUSH
35088: LD_VAR 0 2
35092: ARRAY
35093: NOT
35094: AND
35095: PUSH
35096: LD_EXP 72
35100: PUSH
35101: LD_VAR 0 2
35105: ARRAY
35106: AND
35107: IFFALSE 35188
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
35109: LD_ADDR_EXP 93
35113: PUSH
35114: LD_EXP 93
35118: PPUSH
35119: LD_VAR 0 2
35123: PPUSH
35124: LD_INT 1
35126: PPUSH
35127: CALL_OW 1
35131: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
35132: LD_ADDR_VAR 0 4
35136: PUSH
35137: LD_EXP 72
35141: PUSH
35142: LD_VAR 0 2
35146: ARRAY
35147: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
35148: LD_ADDR_EXP 72
35152: PUSH
35153: LD_EXP 72
35157: PPUSH
35158: LD_VAR 0 2
35162: PPUSH
35163: EMPTY
35164: PPUSH
35165: CALL_OW 1
35169: ST_TO_ADDR
// Defend ( i , tmp ) ;
35170: LD_VAR 0 2
35174: PPUSH
35175: LD_VAR 0 4
35179: PPUSH
35180: CALL 116864 0 2
// exit ;
35184: POP
35185: POP
35186: GO 35192
// end ; end ;
35188: GO 34350
35190: POP
35191: POP
// end ;
35192: LD_VAR 0 1
35196: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
35197: LD_INT 0
35199: PPUSH
35200: PPUSH
35201: PPUSH
35202: PPUSH
35203: PPUSH
35204: PPUSH
35205: PPUSH
35206: PPUSH
35207: PPUSH
35208: PPUSH
35209: PPUSH
// if not mc_bases then
35210: LD_EXP 50
35214: NOT
35215: IFFALSE 35219
// exit ;
35217: GO 36306
// for i = 1 to mc_bases do
35219: LD_ADDR_VAR 0 2
35223: PUSH
35224: DOUBLE
35225: LD_INT 1
35227: DEC
35228: ST_TO_ADDR
35229: LD_EXP 50
35233: PUSH
35234: FOR_TO
35235: IFFALSE 36304
// begin tmp := mc_lab [ i ] ;
35237: LD_ADDR_VAR 0 6
35241: PUSH
35242: LD_EXP 83
35246: PUSH
35247: LD_VAR 0 2
35251: ARRAY
35252: ST_TO_ADDR
// if not tmp then
35253: LD_VAR 0 6
35257: NOT
35258: IFFALSE 35262
// continue ;
35260: GO 35234
// idle_lab := 0 ;
35262: LD_ADDR_VAR 0 11
35266: PUSH
35267: LD_INT 0
35269: ST_TO_ADDR
// for j in tmp do
35270: LD_ADDR_VAR 0 3
35274: PUSH
35275: LD_VAR 0 6
35279: PUSH
35280: FOR_IN
35281: IFFALSE 36300
// begin researching := false ;
35283: LD_ADDR_VAR 0 10
35287: PUSH
35288: LD_INT 0
35290: ST_TO_ADDR
// side := GetSide ( j ) ;
35291: LD_ADDR_VAR 0 4
35295: PUSH
35296: LD_VAR 0 3
35300: PPUSH
35301: CALL_OW 255
35305: ST_TO_ADDR
// if not mc_tech [ side ] then
35306: LD_EXP 77
35310: PUSH
35311: LD_VAR 0 4
35315: ARRAY
35316: NOT
35317: IFFALSE 35321
// continue ;
35319: GO 35280
// if BuildingStatus ( j ) = bs_idle then
35321: LD_VAR 0 3
35325: PPUSH
35326: CALL_OW 461
35330: PUSH
35331: LD_INT 2
35333: EQUAL
35334: IFFALSE 35522
// begin if idle_lab and UnitsInside ( j ) < 6 then
35336: LD_VAR 0 11
35340: PUSH
35341: LD_VAR 0 3
35345: PPUSH
35346: CALL_OW 313
35350: PUSH
35351: LD_INT 6
35353: LESS
35354: AND
35355: IFFALSE 35426
// begin tmp2 := UnitsInside ( idle_lab ) ;
35357: LD_ADDR_VAR 0 9
35361: PUSH
35362: LD_VAR 0 11
35366: PPUSH
35367: CALL_OW 313
35371: ST_TO_ADDR
// if tmp2 then
35372: LD_VAR 0 9
35376: IFFALSE 35418
// for x in tmp2 do
35378: LD_ADDR_VAR 0 7
35382: PUSH
35383: LD_VAR 0 9
35387: PUSH
35388: FOR_IN
35389: IFFALSE 35416
// begin ComExitBuilding ( x ) ;
35391: LD_VAR 0 7
35395: PPUSH
35396: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
35400: LD_VAR 0 7
35404: PPUSH
35405: LD_VAR 0 3
35409: PPUSH
35410: CALL_OW 180
// end ;
35414: GO 35388
35416: POP
35417: POP
// idle_lab := 0 ;
35418: LD_ADDR_VAR 0 11
35422: PUSH
35423: LD_INT 0
35425: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
35426: LD_ADDR_VAR 0 5
35430: PUSH
35431: LD_EXP 77
35435: PUSH
35436: LD_VAR 0 4
35440: ARRAY
35441: PUSH
35442: FOR_IN
35443: IFFALSE 35503
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
35445: LD_VAR 0 3
35449: PPUSH
35450: LD_VAR 0 5
35454: PPUSH
35455: CALL_OW 430
35459: PUSH
35460: LD_VAR 0 4
35464: PPUSH
35465: LD_VAR 0 5
35469: PPUSH
35470: CALL 49961 0 2
35474: AND
35475: IFFALSE 35501
// begin researching := true ;
35477: LD_ADDR_VAR 0 10
35481: PUSH
35482: LD_INT 1
35484: ST_TO_ADDR
// ComResearch ( j , t ) ;
35485: LD_VAR 0 3
35489: PPUSH
35490: LD_VAR 0 5
35494: PPUSH
35495: CALL_OW 124
// break ;
35499: GO 35503
// end ;
35501: GO 35442
35503: POP
35504: POP
// if not researching then
35505: LD_VAR 0 10
35509: NOT
35510: IFFALSE 35522
// idle_lab := j ;
35512: LD_ADDR_VAR 0 11
35516: PUSH
35517: LD_VAR 0 3
35521: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
35522: LD_VAR 0 3
35526: PPUSH
35527: CALL_OW 461
35531: PUSH
35532: LD_INT 10
35534: EQUAL
35535: IFFALSE 36123
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
35537: LD_EXP 79
35541: PUSH
35542: LD_VAR 0 2
35546: ARRAY
35547: NOT
35548: PUSH
35549: LD_EXP 80
35553: PUSH
35554: LD_VAR 0 2
35558: ARRAY
35559: NOT
35560: AND
35561: PUSH
35562: LD_EXP 77
35566: PUSH
35567: LD_VAR 0 4
35571: ARRAY
35572: PUSH
35573: LD_INT 1
35575: GREATER
35576: AND
35577: IFFALSE 35708
// begin ComCancel ( j ) ;
35579: LD_VAR 0 3
35583: PPUSH
35584: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
35588: LD_ADDR_EXP 77
35592: PUSH
35593: LD_EXP 77
35597: PPUSH
35598: LD_VAR 0 4
35602: PPUSH
35603: LD_EXP 77
35607: PUSH
35608: LD_VAR 0 4
35612: ARRAY
35613: PPUSH
35614: LD_EXP 77
35618: PUSH
35619: LD_VAR 0 4
35623: ARRAY
35624: PUSH
35625: LD_INT 1
35627: MINUS
35628: PPUSH
35629: LD_EXP 77
35633: PUSH
35634: LD_VAR 0 4
35638: ARRAY
35639: PPUSH
35640: LD_INT 0
35642: PPUSH
35643: CALL 53485 0 4
35647: PPUSH
35648: CALL_OW 1
35652: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
35653: LD_ADDR_EXP 77
35657: PUSH
35658: LD_EXP 77
35662: PPUSH
35663: LD_VAR 0 4
35667: PPUSH
35668: LD_EXP 77
35672: PUSH
35673: LD_VAR 0 4
35677: ARRAY
35678: PPUSH
35679: LD_EXP 77
35683: PUSH
35684: LD_VAR 0 4
35688: ARRAY
35689: PPUSH
35690: LD_INT 1
35692: PPUSH
35693: LD_INT 0
35695: PPUSH
35696: CALL 53485 0 4
35700: PPUSH
35701: CALL_OW 1
35705: ST_TO_ADDR
// continue ;
35706: GO 35280
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
35708: LD_EXP 79
35712: PUSH
35713: LD_VAR 0 2
35717: ARRAY
35718: PUSH
35719: LD_EXP 80
35723: PUSH
35724: LD_VAR 0 2
35728: ARRAY
35729: NOT
35730: AND
35731: IFFALSE 35858
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
35733: LD_ADDR_EXP 80
35737: PUSH
35738: LD_EXP 80
35742: PPUSH
35743: LD_VAR 0 2
35747: PUSH
35748: LD_EXP 80
35752: PUSH
35753: LD_VAR 0 2
35757: ARRAY
35758: PUSH
35759: LD_INT 1
35761: PLUS
35762: PUSH
35763: EMPTY
35764: LIST
35765: LIST
35766: PPUSH
35767: LD_EXP 79
35771: PUSH
35772: LD_VAR 0 2
35776: ARRAY
35777: PUSH
35778: LD_INT 1
35780: ARRAY
35781: PPUSH
35782: CALL 54067 0 3
35786: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
35787: LD_EXP 79
35791: PUSH
35792: LD_VAR 0 2
35796: ARRAY
35797: PUSH
35798: LD_INT 1
35800: ARRAY
35801: PPUSH
35802: LD_INT 112
35804: PPUSH
35805: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
35809: LD_ADDR_VAR 0 9
35813: PUSH
35814: LD_EXP 79
35818: PUSH
35819: LD_VAR 0 2
35823: ARRAY
35824: PPUSH
35825: LD_INT 1
35827: PPUSH
35828: CALL_OW 3
35832: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
35833: LD_ADDR_EXP 79
35837: PUSH
35838: LD_EXP 79
35842: PPUSH
35843: LD_VAR 0 2
35847: PPUSH
35848: LD_VAR 0 9
35852: PPUSH
35853: CALL_OW 1
35857: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
35858: LD_EXP 79
35862: PUSH
35863: LD_VAR 0 2
35867: ARRAY
35868: PUSH
35869: LD_EXP 80
35873: PUSH
35874: LD_VAR 0 2
35878: ARRAY
35879: AND
35880: PUSH
35881: LD_EXP 80
35885: PUSH
35886: LD_VAR 0 2
35890: ARRAY
35891: PUSH
35892: LD_INT 1
35894: ARRAY
35895: PPUSH
35896: CALL_OW 310
35900: NOT
35901: AND
35902: PUSH
35903: LD_VAR 0 3
35907: PPUSH
35908: CALL_OW 313
35912: PUSH
35913: LD_INT 6
35915: EQUAL
35916: AND
35917: IFFALSE 35973
// begin tmp2 := UnitsInside ( j ) ;
35919: LD_ADDR_VAR 0 9
35923: PUSH
35924: LD_VAR 0 3
35928: PPUSH
35929: CALL_OW 313
35933: ST_TO_ADDR
// if tmp2 = 6 then
35934: LD_VAR 0 9
35938: PUSH
35939: LD_INT 6
35941: EQUAL
35942: IFFALSE 35973
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
35944: LD_VAR 0 9
35948: PUSH
35949: LD_INT 1
35951: ARRAY
35952: PPUSH
35953: LD_INT 112
35955: PPUSH
35956: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
35960: LD_VAR 0 9
35964: PUSH
35965: LD_INT 1
35967: ARRAY
35968: PPUSH
35969: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
35973: LD_EXP 80
35977: PUSH
35978: LD_VAR 0 2
35982: ARRAY
35983: PUSH
35984: LD_EXP 80
35988: PUSH
35989: LD_VAR 0 2
35993: ARRAY
35994: PUSH
35995: LD_INT 1
35997: ARRAY
35998: PPUSH
35999: CALL_OW 314
36003: NOT
36004: AND
36005: PUSH
36006: LD_EXP 80
36010: PUSH
36011: LD_VAR 0 2
36015: ARRAY
36016: PUSH
36017: LD_INT 1
36019: ARRAY
36020: PPUSH
36021: CALL_OW 310
36025: NOT
36026: AND
36027: IFFALSE 36053
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
36029: LD_EXP 80
36033: PUSH
36034: LD_VAR 0 2
36038: ARRAY
36039: PUSH
36040: LD_INT 1
36042: ARRAY
36043: PPUSH
36044: LD_VAR 0 3
36048: PPUSH
36049: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
36053: LD_EXP 80
36057: PUSH
36058: LD_VAR 0 2
36062: ARRAY
36063: PUSH
36064: LD_INT 1
36066: ARRAY
36067: PPUSH
36068: CALL_OW 310
36072: PUSH
36073: LD_EXP 80
36077: PUSH
36078: LD_VAR 0 2
36082: ARRAY
36083: PUSH
36084: LD_INT 1
36086: ARRAY
36087: PPUSH
36088: CALL_OW 310
36092: PPUSH
36093: CALL_OW 461
36097: PUSH
36098: LD_INT 3
36100: NONEQUAL
36101: AND
36102: IFFALSE 36123
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
36104: LD_EXP 80
36108: PUSH
36109: LD_VAR 0 2
36113: ARRAY
36114: PUSH
36115: LD_INT 1
36117: ARRAY
36118: PPUSH
36119: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
36123: LD_VAR 0 3
36127: PPUSH
36128: CALL_OW 461
36132: PUSH
36133: LD_INT 6
36135: EQUAL
36136: PUSH
36137: LD_VAR 0 6
36141: PUSH
36142: LD_INT 1
36144: GREATER
36145: AND
36146: IFFALSE 36298
// begin sci := [ ] ;
36148: LD_ADDR_VAR 0 8
36152: PUSH
36153: EMPTY
36154: ST_TO_ADDR
// for x in ( tmp diff j ) do
36155: LD_ADDR_VAR 0 7
36159: PUSH
36160: LD_VAR 0 6
36164: PUSH
36165: LD_VAR 0 3
36169: DIFF
36170: PUSH
36171: FOR_IN
36172: IFFALSE 36224
// begin if sci = 6 then
36174: LD_VAR 0 8
36178: PUSH
36179: LD_INT 6
36181: EQUAL
36182: IFFALSE 36186
// break ;
36184: GO 36224
// if BuildingStatus ( x ) = bs_idle then
36186: LD_VAR 0 7
36190: PPUSH
36191: CALL_OW 461
36195: PUSH
36196: LD_INT 2
36198: EQUAL
36199: IFFALSE 36222
// sci := sci ^ UnitsInside ( x ) ;
36201: LD_ADDR_VAR 0 8
36205: PUSH
36206: LD_VAR 0 8
36210: PUSH
36211: LD_VAR 0 7
36215: PPUSH
36216: CALL_OW 313
36220: ADD
36221: ST_TO_ADDR
// end ;
36222: GO 36171
36224: POP
36225: POP
// if not sci then
36226: LD_VAR 0 8
36230: NOT
36231: IFFALSE 36235
// continue ;
36233: GO 35280
// for x in sci do
36235: LD_ADDR_VAR 0 7
36239: PUSH
36240: LD_VAR 0 8
36244: PUSH
36245: FOR_IN
36246: IFFALSE 36296
// if IsInUnit ( x ) and not HasTask ( x ) then
36248: LD_VAR 0 7
36252: PPUSH
36253: CALL_OW 310
36257: PUSH
36258: LD_VAR 0 7
36262: PPUSH
36263: CALL_OW 314
36267: NOT
36268: AND
36269: IFFALSE 36294
// begin ComExitBuilding ( x ) ;
36271: LD_VAR 0 7
36275: PPUSH
36276: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
36280: LD_VAR 0 7
36284: PPUSH
36285: LD_VAR 0 3
36289: PPUSH
36290: CALL_OW 180
// end ;
36294: GO 36245
36296: POP
36297: POP
// end ; end ;
36298: GO 35280
36300: POP
36301: POP
// end ;
36302: GO 35234
36304: POP
36305: POP
// end ;
36306: LD_VAR 0 1
36310: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
36311: LD_INT 0
36313: PPUSH
36314: PPUSH
// if not mc_bases then
36315: LD_EXP 50
36319: NOT
36320: IFFALSE 36324
// exit ;
36322: GO 36405
// for i = 1 to mc_bases do
36324: LD_ADDR_VAR 0 2
36328: PUSH
36329: DOUBLE
36330: LD_INT 1
36332: DEC
36333: ST_TO_ADDR
36334: LD_EXP 50
36338: PUSH
36339: FOR_TO
36340: IFFALSE 36403
// if mc_mines [ i ] and mc_miners [ i ] then
36342: LD_EXP 63
36346: PUSH
36347: LD_VAR 0 2
36351: ARRAY
36352: PUSH
36353: LD_EXP 64
36357: PUSH
36358: LD_VAR 0 2
36362: ARRAY
36363: AND
36364: IFFALSE 36401
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
36366: LD_EXP 64
36370: PUSH
36371: LD_VAR 0 2
36375: ARRAY
36376: PUSH
36377: LD_INT 1
36379: ARRAY
36380: PPUSH
36381: CALL_OW 255
36385: PPUSH
36386: LD_EXP 63
36390: PUSH
36391: LD_VAR 0 2
36395: ARRAY
36396: PPUSH
36397: CALL 51044 0 2
36401: GO 36339
36403: POP
36404: POP
// end ;
36405: LD_VAR 0 1
36409: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
36410: LD_INT 0
36412: PPUSH
36413: PPUSH
36414: PPUSH
36415: PPUSH
36416: PPUSH
36417: PPUSH
36418: PPUSH
36419: PPUSH
// if not mc_bases or not mc_parking then
36420: LD_EXP 50
36424: NOT
36425: PUSH
36426: LD_EXP 74
36430: NOT
36431: OR
36432: IFFALSE 36436
// exit ;
36434: GO 37174
// for i = 1 to mc_bases do
36436: LD_ADDR_VAR 0 2
36440: PUSH
36441: DOUBLE
36442: LD_INT 1
36444: DEC
36445: ST_TO_ADDR
36446: LD_EXP 50
36450: PUSH
36451: FOR_TO
36452: IFFALSE 37172
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
36454: LD_EXP 50
36458: PUSH
36459: LD_VAR 0 2
36463: ARRAY
36464: NOT
36465: PUSH
36466: LD_EXP 74
36470: PUSH
36471: LD_VAR 0 2
36475: ARRAY
36476: NOT
36477: OR
36478: IFFALSE 36482
// continue ;
36480: GO 36451
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
36482: LD_ADDR_VAR 0 5
36486: PUSH
36487: LD_EXP 50
36491: PUSH
36492: LD_VAR 0 2
36496: ARRAY
36497: PUSH
36498: LD_INT 1
36500: ARRAY
36501: PPUSH
36502: CALL_OW 255
36506: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
36507: LD_ADDR_VAR 0 6
36511: PUSH
36512: LD_EXP 50
36516: PUSH
36517: LD_VAR 0 2
36521: ARRAY
36522: PPUSH
36523: LD_INT 30
36525: PUSH
36526: LD_INT 3
36528: PUSH
36529: EMPTY
36530: LIST
36531: LIST
36532: PPUSH
36533: CALL_OW 72
36537: ST_TO_ADDR
// if not fac then
36538: LD_VAR 0 6
36542: NOT
36543: IFFALSE 36594
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
36545: LD_ADDR_VAR 0 6
36549: PUSH
36550: LD_EXP 50
36554: PUSH
36555: LD_VAR 0 2
36559: ARRAY
36560: PPUSH
36561: LD_INT 2
36563: PUSH
36564: LD_INT 30
36566: PUSH
36567: LD_INT 0
36569: PUSH
36570: EMPTY
36571: LIST
36572: LIST
36573: PUSH
36574: LD_INT 30
36576: PUSH
36577: LD_INT 1
36579: PUSH
36580: EMPTY
36581: LIST
36582: LIST
36583: PUSH
36584: EMPTY
36585: LIST
36586: LIST
36587: LIST
36588: PPUSH
36589: CALL_OW 72
36593: ST_TO_ADDR
// if not fac then
36594: LD_VAR 0 6
36598: NOT
36599: IFFALSE 36603
// continue ;
36601: GO 36451
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
36603: LD_ADDR_VAR 0 7
36607: PUSH
36608: LD_EXP 74
36612: PUSH
36613: LD_VAR 0 2
36617: ARRAY
36618: PPUSH
36619: LD_INT 22
36621: PUSH
36622: LD_VAR 0 5
36626: PUSH
36627: EMPTY
36628: LIST
36629: LIST
36630: PUSH
36631: LD_INT 21
36633: PUSH
36634: LD_INT 2
36636: PUSH
36637: EMPTY
36638: LIST
36639: LIST
36640: PUSH
36641: LD_INT 3
36643: PUSH
36644: LD_INT 60
36646: PUSH
36647: EMPTY
36648: LIST
36649: PUSH
36650: EMPTY
36651: LIST
36652: LIST
36653: PUSH
36654: LD_INT 3
36656: PUSH
36657: LD_INT 24
36659: PUSH
36660: LD_INT 1000
36662: PUSH
36663: EMPTY
36664: LIST
36665: LIST
36666: PUSH
36667: EMPTY
36668: LIST
36669: LIST
36670: PUSH
36671: EMPTY
36672: LIST
36673: LIST
36674: LIST
36675: LIST
36676: PPUSH
36677: CALL_OW 70
36681: ST_TO_ADDR
// for j in fac do
36682: LD_ADDR_VAR 0 3
36686: PUSH
36687: LD_VAR 0 6
36691: PUSH
36692: FOR_IN
36693: IFFALSE 36788
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
36695: LD_ADDR_VAR 0 7
36699: PUSH
36700: LD_VAR 0 7
36704: PUSH
36705: LD_INT 22
36707: PUSH
36708: LD_VAR 0 5
36712: PUSH
36713: EMPTY
36714: LIST
36715: LIST
36716: PUSH
36717: LD_INT 91
36719: PUSH
36720: LD_VAR 0 3
36724: PUSH
36725: LD_INT 15
36727: PUSH
36728: EMPTY
36729: LIST
36730: LIST
36731: LIST
36732: PUSH
36733: LD_INT 21
36735: PUSH
36736: LD_INT 2
36738: PUSH
36739: EMPTY
36740: LIST
36741: LIST
36742: PUSH
36743: LD_INT 3
36745: PUSH
36746: LD_INT 60
36748: PUSH
36749: EMPTY
36750: LIST
36751: PUSH
36752: EMPTY
36753: LIST
36754: LIST
36755: PUSH
36756: LD_INT 3
36758: PUSH
36759: LD_INT 24
36761: PUSH
36762: LD_INT 1000
36764: PUSH
36765: EMPTY
36766: LIST
36767: LIST
36768: PUSH
36769: EMPTY
36770: LIST
36771: LIST
36772: PUSH
36773: EMPTY
36774: LIST
36775: LIST
36776: LIST
36777: LIST
36778: LIST
36779: PPUSH
36780: CALL_OW 69
36784: UNION
36785: ST_TO_ADDR
36786: GO 36692
36788: POP
36789: POP
// if not vehs then
36790: LD_VAR 0 7
36794: NOT
36795: IFFALSE 36821
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
36797: LD_ADDR_EXP 62
36801: PUSH
36802: LD_EXP 62
36806: PPUSH
36807: LD_VAR 0 2
36811: PPUSH
36812: EMPTY
36813: PPUSH
36814: CALL_OW 1
36818: ST_TO_ADDR
// continue ;
36819: GO 36451
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
36821: LD_ADDR_VAR 0 8
36825: PUSH
36826: LD_EXP 50
36830: PUSH
36831: LD_VAR 0 2
36835: ARRAY
36836: PPUSH
36837: LD_INT 30
36839: PUSH
36840: LD_INT 3
36842: PUSH
36843: EMPTY
36844: LIST
36845: LIST
36846: PPUSH
36847: CALL_OW 72
36851: ST_TO_ADDR
// if tmp then
36852: LD_VAR 0 8
36856: IFFALSE 36959
// begin for j in tmp do
36858: LD_ADDR_VAR 0 3
36862: PUSH
36863: LD_VAR 0 8
36867: PUSH
36868: FOR_IN
36869: IFFALSE 36957
// for k in UnitsInside ( j ) do
36871: LD_ADDR_VAR 0 4
36875: PUSH
36876: LD_VAR 0 3
36880: PPUSH
36881: CALL_OW 313
36885: PUSH
36886: FOR_IN
36887: IFFALSE 36953
// if k then
36889: LD_VAR 0 4
36893: IFFALSE 36951
// if not k in mc_repair_vehicle [ i ] then
36895: LD_VAR 0 4
36899: PUSH
36900: LD_EXP 62
36904: PUSH
36905: LD_VAR 0 2
36909: ARRAY
36910: IN
36911: NOT
36912: IFFALSE 36951
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
36914: LD_ADDR_EXP 62
36918: PUSH
36919: LD_EXP 62
36923: PPUSH
36924: LD_VAR 0 2
36928: PPUSH
36929: LD_EXP 62
36933: PUSH
36934: LD_VAR 0 2
36938: ARRAY
36939: PUSH
36940: LD_VAR 0 4
36944: UNION
36945: PPUSH
36946: CALL_OW 1
36950: ST_TO_ADDR
36951: GO 36886
36953: POP
36954: POP
36955: GO 36868
36957: POP
36958: POP
// end ; if not mc_repair_vehicle [ i ] then
36959: LD_EXP 62
36963: PUSH
36964: LD_VAR 0 2
36968: ARRAY
36969: NOT
36970: IFFALSE 36974
// continue ;
36972: GO 36451
// for j in mc_repair_vehicle [ i ] do
36974: LD_ADDR_VAR 0 3
36978: PUSH
36979: LD_EXP 62
36983: PUSH
36984: LD_VAR 0 2
36988: ARRAY
36989: PUSH
36990: FOR_IN
36991: IFFALSE 37168
// begin if GetClass ( j ) <> 3 then
36993: LD_VAR 0 3
36997: PPUSH
36998: CALL_OW 257
37002: PUSH
37003: LD_INT 3
37005: NONEQUAL
37006: IFFALSE 37047
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
37008: LD_ADDR_EXP 62
37012: PUSH
37013: LD_EXP 62
37017: PPUSH
37018: LD_VAR 0 2
37022: PPUSH
37023: LD_EXP 62
37027: PUSH
37028: LD_VAR 0 2
37032: ARRAY
37033: PUSH
37034: LD_VAR 0 3
37038: DIFF
37039: PPUSH
37040: CALL_OW 1
37044: ST_TO_ADDR
// continue ;
37045: GO 36990
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
37047: LD_VAR 0 3
37051: PPUSH
37052: CALL_OW 311
37056: NOT
37057: PUSH
37058: LD_VAR 0 3
37062: PUSH
37063: LD_EXP 53
37067: PUSH
37068: LD_VAR 0 2
37072: ARRAY
37073: PUSH
37074: LD_INT 1
37076: ARRAY
37077: IN
37078: NOT
37079: AND
37080: PUSH
37081: LD_VAR 0 3
37085: PUSH
37086: LD_EXP 53
37090: PUSH
37091: LD_VAR 0 2
37095: ARRAY
37096: PUSH
37097: LD_INT 2
37099: ARRAY
37100: IN
37101: NOT
37102: AND
37103: IFFALSE 37166
// begin if IsInUnit ( j ) then
37105: LD_VAR 0 3
37109: PPUSH
37110: CALL_OW 310
37114: IFFALSE 37127
// ComExitBuilding ( j ) else
37116: LD_VAR 0 3
37120: PPUSH
37121: CALL_OW 122
37125: GO 37166
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
37127: LD_VAR 0 3
37131: PPUSH
37132: LD_VAR 0 7
37136: PUSH
37137: LD_INT 1
37139: ARRAY
37140: PPUSH
37141: CALL 88872 0 2
37145: NOT
37146: IFFALSE 37166
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
37148: LD_VAR 0 3
37152: PPUSH
37153: LD_VAR 0 7
37157: PUSH
37158: LD_INT 1
37160: ARRAY
37161: PPUSH
37162: CALL_OW 129
// end ; end ;
37166: GO 36990
37168: POP
37169: POP
// end ;
37170: GO 36451
37172: POP
37173: POP
// end ;
37174: LD_VAR 0 1
37178: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
37179: LD_INT 0
37181: PPUSH
37182: PPUSH
37183: PPUSH
37184: PPUSH
37185: PPUSH
37186: PPUSH
37187: PPUSH
37188: PPUSH
37189: PPUSH
37190: PPUSH
37191: PPUSH
// if not mc_bases then
37192: LD_EXP 50
37196: NOT
37197: IFFALSE 37201
// exit ;
37199: GO 38003
// for i = 1 to mc_bases do
37201: LD_ADDR_VAR 0 2
37205: PUSH
37206: DOUBLE
37207: LD_INT 1
37209: DEC
37210: ST_TO_ADDR
37211: LD_EXP 50
37215: PUSH
37216: FOR_TO
37217: IFFALSE 38001
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
37219: LD_EXP 78
37223: PUSH
37224: LD_VAR 0 2
37228: ARRAY
37229: NOT
37230: PUSH
37231: LD_EXP 53
37235: PUSH
37236: LD_VAR 0 2
37240: ARRAY
37241: PUSH
37242: LD_INT 1
37244: ARRAY
37245: OR
37246: PUSH
37247: LD_EXP 53
37251: PUSH
37252: LD_VAR 0 2
37256: ARRAY
37257: PUSH
37258: LD_INT 2
37260: ARRAY
37261: OR
37262: PUSH
37263: LD_EXP 76
37267: PUSH
37268: LD_VAR 0 2
37272: ARRAY
37273: PPUSH
37274: LD_INT 1
37276: PPUSH
37277: CALL_OW 325
37281: NOT
37282: OR
37283: PUSH
37284: LD_EXP 73
37288: PUSH
37289: LD_VAR 0 2
37293: ARRAY
37294: OR
37295: IFFALSE 37299
// continue ;
37297: GO 37216
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
37299: LD_ADDR_VAR 0 8
37303: PUSH
37304: LD_EXP 50
37308: PUSH
37309: LD_VAR 0 2
37313: ARRAY
37314: PPUSH
37315: LD_INT 25
37317: PUSH
37318: LD_INT 4
37320: PUSH
37321: EMPTY
37322: LIST
37323: LIST
37324: PUSH
37325: LD_INT 50
37327: PUSH
37328: EMPTY
37329: LIST
37330: PUSH
37331: LD_INT 3
37333: PUSH
37334: LD_INT 60
37336: PUSH
37337: EMPTY
37338: LIST
37339: PUSH
37340: EMPTY
37341: LIST
37342: LIST
37343: PUSH
37344: EMPTY
37345: LIST
37346: LIST
37347: LIST
37348: PPUSH
37349: CALL_OW 72
37353: PUSH
37354: LD_EXP 54
37358: PUSH
37359: LD_VAR 0 2
37363: ARRAY
37364: DIFF
37365: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
37366: LD_ADDR_VAR 0 9
37370: PUSH
37371: LD_EXP 50
37375: PUSH
37376: LD_VAR 0 2
37380: ARRAY
37381: PPUSH
37382: LD_INT 2
37384: PUSH
37385: LD_INT 30
37387: PUSH
37388: LD_INT 0
37390: PUSH
37391: EMPTY
37392: LIST
37393: LIST
37394: PUSH
37395: LD_INT 30
37397: PUSH
37398: LD_INT 1
37400: PUSH
37401: EMPTY
37402: LIST
37403: LIST
37404: PUSH
37405: EMPTY
37406: LIST
37407: LIST
37408: LIST
37409: PPUSH
37410: CALL_OW 72
37414: ST_TO_ADDR
// if not tmp or not dep then
37415: LD_VAR 0 8
37419: NOT
37420: PUSH
37421: LD_VAR 0 9
37425: NOT
37426: OR
37427: IFFALSE 37431
// continue ;
37429: GO 37216
// side := GetSide ( tmp [ 1 ] ) ;
37431: LD_ADDR_VAR 0 11
37435: PUSH
37436: LD_VAR 0 8
37440: PUSH
37441: LD_INT 1
37443: ARRAY
37444: PPUSH
37445: CALL_OW 255
37449: ST_TO_ADDR
// dep := dep [ 1 ] ;
37450: LD_ADDR_VAR 0 9
37454: PUSH
37455: LD_VAR 0 9
37459: PUSH
37460: LD_INT 1
37462: ARRAY
37463: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
37464: LD_ADDR_VAR 0 7
37468: PUSH
37469: LD_EXP 78
37473: PUSH
37474: LD_VAR 0 2
37478: ARRAY
37479: PPUSH
37480: LD_INT 22
37482: PUSH
37483: LD_INT 0
37485: PUSH
37486: EMPTY
37487: LIST
37488: LIST
37489: PUSH
37490: LD_INT 25
37492: PUSH
37493: LD_INT 12
37495: PUSH
37496: EMPTY
37497: LIST
37498: LIST
37499: PUSH
37500: EMPTY
37501: LIST
37502: LIST
37503: PPUSH
37504: CALL_OW 70
37508: PUSH
37509: LD_INT 22
37511: PUSH
37512: LD_INT 0
37514: PUSH
37515: EMPTY
37516: LIST
37517: LIST
37518: PUSH
37519: LD_INT 25
37521: PUSH
37522: LD_INT 12
37524: PUSH
37525: EMPTY
37526: LIST
37527: LIST
37528: PUSH
37529: LD_INT 91
37531: PUSH
37532: LD_VAR 0 9
37536: PUSH
37537: LD_INT 20
37539: PUSH
37540: EMPTY
37541: LIST
37542: LIST
37543: LIST
37544: PUSH
37545: EMPTY
37546: LIST
37547: LIST
37548: LIST
37549: PPUSH
37550: CALL_OW 69
37554: UNION
37555: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
37556: LD_ADDR_VAR 0 10
37560: PUSH
37561: LD_EXP 78
37565: PUSH
37566: LD_VAR 0 2
37570: ARRAY
37571: PPUSH
37572: LD_INT 81
37574: PUSH
37575: LD_VAR 0 11
37579: PUSH
37580: EMPTY
37581: LIST
37582: LIST
37583: PPUSH
37584: CALL_OW 70
37588: ST_TO_ADDR
// if not apes or danger_at_area then
37589: LD_VAR 0 7
37593: NOT
37594: PUSH
37595: LD_VAR 0 10
37599: OR
37600: IFFALSE 37650
// begin if mc_taming [ i ] then
37602: LD_EXP 81
37606: PUSH
37607: LD_VAR 0 2
37611: ARRAY
37612: IFFALSE 37648
// begin MC_Reset ( i , 121 ) ;
37614: LD_VAR 0 2
37618: PPUSH
37619: LD_INT 121
37621: PPUSH
37622: CALL 22566 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
37626: LD_ADDR_EXP 81
37630: PUSH
37631: LD_EXP 81
37635: PPUSH
37636: LD_VAR 0 2
37640: PPUSH
37641: EMPTY
37642: PPUSH
37643: CALL_OW 1
37647: ST_TO_ADDR
// end ; continue ;
37648: GO 37216
// end ; for j in tmp do
37650: LD_ADDR_VAR 0 3
37654: PUSH
37655: LD_VAR 0 8
37659: PUSH
37660: FOR_IN
37661: IFFALSE 37997
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
37663: LD_VAR 0 3
37667: PUSH
37668: LD_EXP 81
37672: PUSH
37673: LD_VAR 0 2
37677: ARRAY
37678: IN
37679: NOT
37680: PUSH
37681: LD_EXP 81
37685: PUSH
37686: LD_VAR 0 2
37690: ARRAY
37691: PUSH
37692: LD_INT 3
37694: LESS
37695: AND
37696: IFFALSE 37754
// begin SetTag ( j , 121 ) ;
37698: LD_VAR 0 3
37702: PPUSH
37703: LD_INT 121
37705: PPUSH
37706: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
37710: LD_ADDR_EXP 81
37714: PUSH
37715: LD_EXP 81
37719: PPUSH
37720: LD_VAR 0 2
37724: PUSH
37725: LD_EXP 81
37729: PUSH
37730: LD_VAR 0 2
37734: ARRAY
37735: PUSH
37736: LD_INT 1
37738: PLUS
37739: PUSH
37740: EMPTY
37741: LIST
37742: LIST
37743: PPUSH
37744: LD_VAR 0 3
37748: PPUSH
37749: CALL 54067 0 3
37753: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
37754: LD_VAR 0 3
37758: PUSH
37759: LD_EXP 81
37763: PUSH
37764: LD_VAR 0 2
37768: ARRAY
37769: IN
37770: IFFALSE 37995
// begin if GetClass ( j ) <> 4 then
37772: LD_VAR 0 3
37776: PPUSH
37777: CALL_OW 257
37781: PUSH
37782: LD_INT 4
37784: NONEQUAL
37785: IFFALSE 37838
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
37787: LD_ADDR_EXP 81
37791: PUSH
37792: LD_EXP 81
37796: PPUSH
37797: LD_VAR 0 2
37801: PPUSH
37802: LD_EXP 81
37806: PUSH
37807: LD_VAR 0 2
37811: ARRAY
37812: PUSH
37813: LD_VAR 0 3
37817: DIFF
37818: PPUSH
37819: CALL_OW 1
37823: ST_TO_ADDR
// SetTag ( j , 0 ) ;
37824: LD_VAR 0 3
37828: PPUSH
37829: LD_INT 0
37831: PPUSH
37832: CALL_OW 109
// continue ;
37836: GO 37660
// end ; if IsInUnit ( j ) then
37838: LD_VAR 0 3
37842: PPUSH
37843: CALL_OW 310
37847: IFFALSE 37858
// ComExitBuilding ( j ) ;
37849: LD_VAR 0 3
37853: PPUSH
37854: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
37858: LD_ADDR_VAR 0 6
37862: PUSH
37863: LD_VAR 0 7
37867: PPUSH
37868: LD_VAR 0 3
37872: PPUSH
37873: CALL_OW 74
37877: ST_TO_ADDR
// if not ape then
37878: LD_VAR 0 6
37882: NOT
37883: IFFALSE 37887
// break ;
37885: GO 37997
// x := GetX ( ape ) ;
37887: LD_ADDR_VAR 0 4
37891: PUSH
37892: LD_VAR 0 6
37896: PPUSH
37897: CALL_OW 250
37901: ST_TO_ADDR
// y := GetY ( ape ) ;
37902: LD_ADDR_VAR 0 5
37906: PUSH
37907: LD_VAR 0 6
37911: PPUSH
37912: CALL_OW 251
37916: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
37917: LD_VAR 0 4
37921: PPUSH
37922: LD_VAR 0 5
37926: PPUSH
37927: CALL_OW 488
37931: NOT
37932: PUSH
37933: LD_VAR 0 11
37937: PPUSH
37938: LD_VAR 0 4
37942: PPUSH
37943: LD_VAR 0 5
37947: PPUSH
37948: LD_INT 20
37950: PPUSH
37951: CALL 55331 0 4
37955: PUSH
37956: LD_INT 4
37958: ARRAY
37959: OR
37960: IFFALSE 37964
// break ;
37962: GO 37997
// if not HasTask ( j ) then
37964: LD_VAR 0 3
37968: PPUSH
37969: CALL_OW 314
37973: NOT
37974: IFFALSE 37995
// ComTameXY ( j , x , y ) ;
37976: LD_VAR 0 3
37980: PPUSH
37981: LD_VAR 0 4
37985: PPUSH
37986: LD_VAR 0 5
37990: PPUSH
37991: CALL_OW 131
// end ; end ;
37995: GO 37660
37997: POP
37998: POP
// end ;
37999: GO 37216
38001: POP
38002: POP
// end ;
38003: LD_VAR 0 1
38007: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
38008: LD_INT 0
38010: PPUSH
38011: PPUSH
38012: PPUSH
38013: PPUSH
38014: PPUSH
38015: PPUSH
38016: PPUSH
38017: PPUSH
// if not mc_bases then
38018: LD_EXP 50
38022: NOT
38023: IFFALSE 38027
// exit ;
38025: GO 38653
// for i = 1 to mc_bases do
38027: LD_ADDR_VAR 0 2
38031: PUSH
38032: DOUBLE
38033: LD_INT 1
38035: DEC
38036: ST_TO_ADDR
38037: LD_EXP 50
38041: PUSH
38042: FOR_TO
38043: IFFALSE 38651
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
38045: LD_EXP 79
38049: PUSH
38050: LD_VAR 0 2
38054: ARRAY
38055: NOT
38056: PUSH
38057: LD_EXP 79
38061: PUSH
38062: LD_VAR 0 2
38066: ARRAY
38067: PPUSH
38068: LD_INT 25
38070: PUSH
38071: LD_INT 12
38073: PUSH
38074: EMPTY
38075: LIST
38076: LIST
38077: PPUSH
38078: CALL_OW 72
38082: NOT
38083: OR
38084: IFFALSE 38088
// continue ;
38086: GO 38042
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
38088: LD_ADDR_VAR 0 5
38092: PUSH
38093: LD_EXP 79
38097: PUSH
38098: LD_VAR 0 2
38102: ARRAY
38103: PUSH
38104: LD_INT 1
38106: ARRAY
38107: PPUSH
38108: CALL_OW 255
38112: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
38113: LD_VAR 0 5
38117: PPUSH
38118: LD_INT 2
38120: PPUSH
38121: CALL_OW 325
38125: IFFALSE 38378
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
38127: LD_ADDR_VAR 0 4
38131: PUSH
38132: LD_EXP 79
38136: PUSH
38137: LD_VAR 0 2
38141: ARRAY
38142: PPUSH
38143: LD_INT 25
38145: PUSH
38146: LD_INT 16
38148: PUSH
38149: EMPTY
38150: LIST
38151: LIST
38152: PPUSH
38153: CALL_OW 72
38157: ST_TO_ADDR
// if tmp < 6 then
38158: LD_VAR 0 4
38162: PUSH
38163: LD_INT 6
38165: LESS
38166: IFFALSE 38378
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
38168: LD_ADDR_VAR 0 6
38172: PUSH
38173: LD_EXP 50
38177: PUSH
38178: LD_VAR 0 2
38182: ARRAY
38183: PPUSH
38184: LD_INT 2
38186: PUSH
38187: LD_INT 30
38189: PUSH
38190: LD_INT 0
38192: PUSH
38193: EMPTY
38194: LIST
38195: LIST
38196: PUSH
38197: LD_INT 30
38199: PUSH
38200: LD_INT 1
38202: PUSH
38203: EMPTY
38204: LIST
38205: LIST
38206: PUSH
38207: EMPTY
38208: LIST
38209: LIST
38210: LIST
38211: PPUSH
38212: CALL_OW 72
38216: ST_TO_ADDR
// if depot then
38217: LD_VAR 0 6
38221: IFFALSE 38378
// begin selected := 0 ;
38223: LD_ADDR_VAR 0 7
38227: PUSH
38228: LD_INT 0
38230: ST_TO_ADDR
// for j in depot do
38231: LD_ADDR_VAR 0 3
38235: PUSH
38236: LD_VAR 0 6
38240: PUSH
38241: FOR_IN
38242: IFFALSE 38273
// begin if UnitsInside ( j ) < 6 then
38244: LD_VAR 0 3
38248: PPUSH
38249: CALL_OW 313
38253: PUSH
38254: LD_INT 6
38256: LESS
38257: IFFALSE 38271
// begin selected := j ;
38259: LD_ADDR_VAR 0 7
38263: PUSH
38264: LD_VAR 0 3
38268: ST_TO_ADDR
// break ;
38269: GO 38273
// end ; end ;
38271: GO 38241
38273: POP
38274: POP
// if selected then
38275: LD_VAR 0 7
38279: IFFALSE 38378
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
38281: LD_ADDR_VAR 0 3
38285: PUSH
38286: LD_EXP 79
38290: PUSH
38291: LD_VAR 0 2
38295: ARRAY
38296: PPUSH
38297: LD_INT 25
38299: PUSH
38300: LD_INT 12
38302: PUSH
38303: EMPTY
38304: LIST
38305: LIST
38306: PPUSH
38307: CALL_OW 72
38311: PUSH
38312: FOR_IN
38313: IFFALSE 38376
// if not HasTask ( j ) then
38315: LD_VAR 0 3
38319: PPUSH
38320: CALL_OW 314
38324: NOT
38325: IFFALSE 38374
// begin if not IsInUnit ( j ) then
38327: LD_VAR 0 3
38331: PPUSH
38332: CALL_OW 310
38336: NOT
38337: IFFALSE 38353
// ComEnterUnit ( j , selected ) ;
38339: LD_VAR 0 3
38343: PPUSH
38344: LD_VAR 0 7
38348: PPUSH
38349: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
38353: LD_VAR 0 3
38357: PPUSH
38358: LD_INT 16
38360: PPUSH
38361: CALL_OW 183
// AddComExitBuilding ( j ) ;
38365: LD_VAR 0 3
38369: PPUSH
38370: CALL_OW 182
// end ;
38374: GO 38312
38376: POP
38377: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
38378: LD_VAR 0 5
38382: PPUSH
38383: LD_INT 11
38385: PPUSH
38386: CALL_OW 325
38390: IFFALSE 38649
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
38392: LD_ADDR_VAR 0 4
38396: PUSH
38397: LD_EXP 79
38401: PUSH
38402: LD_VAR 0 2
38406: ARRAY
38407: PPUSH
38408: LD_INT 25
38410: PUSH
38411: LD_INT 16
38413: PUSH
38414: EMPTY
38415: LIST
38416: LIST
38417: PPUSH
38418: CALL_OW 72
38422: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
38423: LD_VAR 0 4
38427: PUSH
38428: LD_INT 6
38430: GREATEREQUAL
38431: PUSH
38432: LD_VAR 0 5
38436: PPUSH
38437: LD_INT 2
38439: PPUSH
38440: CALL_OW 325
38444: NOT
38445: OR
38446: IFFALSE 38649
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
38448: LD_ADDR_VAR 0 8
38452: PUSH
38453: LD_EXP 50
38457: PUSH
38458: LD_VAR 0 2
38462: ARRAY
38463: PPUSH
38464: LD_INT 2
38466: PUSH
38467: LD_INT 30
38469: PUSH
38470: LD_INT 4
38472: PUSH
38473: EMPTY
38474: LIST
38475: LIST
38476: PUSH
38477: LD_INT 30
38479: PUSH
38480: LD_INT 5
38482: PUSH
38483: EMPTY
38484: LIST
38485: LIST
38486: PUSH
38487: EMPTY
38488: LIST
38489: LIST
38490: LIST
38491: PPUSH
38492: CALL_OW 72
38496: ST_TO_ADDR
// if barracks then
38497: LD_VAR 0 8
38501: IFFALSE 38649
// begin selected := 0 ;
38503: LD_ADDR_VAR 0 7
38507: PUSH
38508: LD_INT 0
38510: ST_TO_ADDR
// for j in barracks do
38511: LD_ADDR_VAR 0 3
38515: PUSH
38516: LD_VAR 0 8
38520: PUSH
38521: FOR_IN
38522: IFFALSE 38553
// begin if UnitsInside ( j ) < 6 then
38524: LD_VAR 0 3
38528: PPUSH
38529: CALL_OW 313
38533: PUSH
38534: LD_INT 6
38536: LESS
38537: IFFALSE 38551
// begin selected := j ;
38539: LD_ADDR_VAR 0 7
38543: PUSH
38544: LD_VAR 0 3
38548: ST_TO_ADDR
// break ;
38549: GO 38553
// end ; end ;
38551: GO 38521
38553: POP
38554: POP
// if selected then
38555: LD_VAR 0 7
38559: IFFALSE 38649
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
38561: LD_ADDR_VAR 0 3
38565: PUSH
38566: LD_EXP 79
38570: PUSH
38571: LD_VAR 0 2
38575: ARRAY
38576: PPUSH
38577: LD_INT 25
38579: PUSH
38580: LD_INT 12
38582: PUSH
38583: EMPTY
38584: LIST
38585: LIST
38586: PPUSH
38587: CALL_OW 72
38591: PUSH
38592: FOR_IN
38593: IFFALSE 38647
// if not IsInUnit ( j ) and not HasTask ( j ) then
38595: LD_VAR 0 3
38599: PPUSH
38600: CALL_OW 310
38604: NOT
38605: PUSH
38606: LD_VAR 0 3
38610: PPUSH
38611: CALL_OW 314
38615: NOT
38616: AND
38617: IFFALSE 38645
// begin ComEnterUnit ( j , selected ) ;
38619: LD_VAR 0 3
38623: PPUSH
38624: LD_VAR 0 7
38628: PPUSH
38629: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
38633: LD_VAR 0 3
38637: PPUSH
38638: LD_INT 15
38640: PPUSH
38641: CALL_OW 183
// end ;
38645: GO 38592
38647: POP
38648: POP
// end ; end ; end ; end ; end ;
38649: GO 38042
38651: POP
38652: POP
// end ;
38653: LD_VAR 0 1
38657: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
38658: LD_INT 0
38660: PPUSH
38661: PPUSH
38662: PPUSH
38663: PPUSH
// if not mc_bases then
38664: LD_EXP 50
38668: NOT
38669: IFFALSE 38673
// exit ;
38671: GO 38851
// for i = 1 to mc_bases do
38673: LD_ADDR_VAR 0 2
38677: PUSH
38678: DOUBLE
38679: LD_INT 1
38681: DEC
38682: ST_TO_ADDR
38683: LD_EXP 50
38687: PUSH
38688: FOR_TO
38689: IFFALSE 38849
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
38691: LD_ADDR_VAR 0 4
38695: PUSH
38696: LD_EXP 50
38700: PUSH
38701: LD_VAR 0 2
38705: ARRAY
38706: PPUSH
38707: LD_INT 25
38709: PUSH
38710: LD_INT 9
38712: PUSH
38713: EMPTY
38714: LIST
38715: LIST
38716: PPUSH
38717: CALL_OW 72
38721: ST_TO_ADDR
// if not tmp then
38722: LD_VAR 0 4
38726: NOT
38727: IFFALSE 38731
// continue ;
38729: GO 38688
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
38731: LD_EXP 76
38735: PUSH
38736: LD_VAR 0 2
38740: ARRAY
38741: PPUSH
38742: LD_INT 29
38744: PPUSH
38745: CALL_OW 325
38749: NOT
38750: PUSH
38751: LD_EXP 76
38755: PUSH
38756: LD_VAR 0 2
38760: ARRAY
38761: PPUSH
38762: LD_INT 28
38764: PPUSH
38765: CALL_OW 325
38769: NOT
38770: AND
38771: IFFALSE 38775
// continue ;
38773: GO 38688
// for j in tmp do
38775: LD_ADDR_VAR 0 3
38779: PUSH
38780: LD_VAR 0 4
38784: PUSH
38785: FOR_IN
38786: IFFALSE 38845
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
38788: LD_VAR 0 3
38792: PUSH
38793: LD_EXP 53
38797: PUSH
38798: LD_VAR 0 2
38802: ARRAY
38803: PUSH
38804: LD_INT 1
38806: ARRAY
38807: IN
38808: NOT
38809: PUSH
38810: LD_VAR 0 3
38814: PUSH
38815: LD_EXP 53
38819: PUSH
38820: LD_VAR 0 2
38824: ARRAY
38825: PUSH
38826: LD_INT 2
38828: ARRAY
38829: IN
38830: NOT
38831: AND
38832: IFFALSE 38843
// ComSpaceTimeShoot ( j ) ;
38834: LD_VAR 0 3
38838: PPUSH
38839: CALL 50052 0 1
38843: GO 38785
38845: POP
38846: POP
// end ;
38847: GO 38688
38849: POP
38850: POP
// end ;
38851: LD_VAR 0 1
38855: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
38856: LD_INT 0
38858: PPUSH
38859: PPUSH
38860: PPUSH
38861: PPUSH
38862: PPUSH
38863: PPUSH
38864: PPUSH
38865: PPUSH
38866: PPUSH
// if not mc_bases then
38867: LD_EXP 50
38871: NOT
38872: IFFALSE 38876
// exit ;
38874: GO 39498
// for i = 1 to mc_bases do
38876: LD_ADDR_VAR 0 2
38880: PUSH
38881: DOUBLE
38882: LD_INT 1
38884: DEC
38885: ST_TO_ADDR
38886: LD_EXP 50
38890: PUSH
38891: FOR_TO
38892: IFFALSE 39496
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
38894: LD_EXP 85
38898: PUSH
38899: LD_VAR 0 2
38903: ARRAY
38904: NOT
38905: PUSH
38906: LD_INT 38
38908: PPUSH
38909: LD_EXP 76
38913: PUSH
38914: LD_VAR 0 2
38918: ARRAY
38919: PPUSH
38920: CALL_OW 321
38924: PUSH
38925: LD_INT 2
38927: NONEQUAL
38928: OR
38929: IFFALSE 38933
// continue ;
38931: GO 38891
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
38933: LD_ADDR_VAR 0 8
38937: PUSH
38938: LD_EXP 50
38942: PUSH
38943: LD_VAR 0 2
38947: ARRAY
38948: PPUSH
38949: LD_INT 30
38951: PUSH
38952: LD_INT 34
38954: PUSH
38955: EMPTY
38956: LIST
38957: LIST
38958: PPUSH
38959: CALL_OW 72
38963: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
38964: LD_ADDR_VAR 0 9
38968: PUSH
38969: LD_EXP 50
38973: PUSH
38974: LD_VAR 0 2
38978: ARRAY
38979: PPUSH
38980: LD_INT 25
38982: PUSH
38983: LD_INT 4
38985: PUSH
38986: EMPTY
38987: LIST
38988: LIST
38989: PPUSH
38990: CALL_OW 72
38994: PPUSH
38995: LD_INT 0
38997: PPUSH
38998: CALL 84376 0 2
39002: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
39003: LD_VAR 0 9
39007: NOT
39008: PUSH
39009: LD_VAR 0 8
39013: NOT
39014: OR
39015: PUSH
39016: LD_EXP 50
39020: PUSH
39021: LD_VAR 0 2
39025: ARRAY
39026: PPUSH
39027: LD_INT 124
39029: PPUSH
39030: CALL 84376 0 2
39034: OR
39035: IFFALSE 39039
// continue ;
39037: GO 38891
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
39039: LD_EXP 86
39043: PUSH
39044: LD_VAR 0 2
39048: ARRAY
39049: PUSH
39050: LD_EXP 85
39054: PUSH
39055: LD_VAR 0 2
39059: ARRAY
39060: LESS
39061: PUSH
39062: LD_EXP 86
39066: PUSH
39067: LD_VAR 0 2
39071: ARRAY
39072: PUSH
39073: LD_VAR 0 8
39077: LESS
39078: AND
39079: IFFALSE 39494
// begin tmp := sci [ 1 ] ;
39081: LD_ADDR_VAR 0 7
39085: PUSH
39086: LD_VAR 0 9
39090: PUSH
39091: LD_INT 1
39093: ARRAY
39094: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
39095: LD_VAR 0 7
39099: PPUSH
39100: LD_INT 124
39102: PPUSH
39103: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
39107: LD_ADDR_VAR 0 3
39111: PUSH
39112: DOUBLE
39113: LD_EXP 85
39117: PUSH
39118: LD_VAR 0 2
39122: ARRAY
39123: INC
39124: ST_TO_ADDR
39125: LD_EXP 85
39129: PUSH
39130: LD_VAR 0 2
39134: ARRAY
39135: PUSH
39136: FOR_DOWNTO
39137: IFFALSE 39480
// begin if IsInUnit ( tmp ) then
39139: LD_VAR 0 7
39143: PPUSH
39144: CALL_OW 310
39148: IFFALSE 39159
// ComExitBuilding ( tmp ) ;
39150: LD_VAR 0 7
39154: PPUSH
39155: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
39159: LD_INT 35
39161: PPUSH
39162: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
39166: LD_VAR 0 7
39170: PPUSH
39171: CALL_OW 310
39175: NOT
39176: PUSH
39177: LD_VAR 0 7
39181: PPUSH
39182: CALL_OW 314
39186: NOT
39187: AND
39188: IFFALSE 39159
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
39190: LD_ADDR_VAR 0 6
39194: PUSH
39195: LD_VAR 0 7
39199: PPUSH
39200: CALL_OW 250
39204: PUSH
39205: LD_VAR 0 7
39209: PPUSH
39210: CALL_OW 251
39214: PUSH
39215: EMPTY
39216: LIST
39217: LIST
39218: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
39219: LD_INT 35
39221: PPUSH
39222: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
39226: LD_ADDR_VAR 0 4
39230: PUSH
39231: LD_EXP 85
39235: PUSH
39236: LD_VAR 0 2
39240: ARRAY
39241: PUSH
39242: LD_VAR 0 3
39246: ARRAY
39247: PUSH
39248: LD_INT 1
39250: ARRAY
39251: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
39252: LD_ADDR_VAR 0 5
39256: PUSH
39257: LD_EXP 85
39261: PUSH
39262: LD_VAR 0 2
39266: ARRAY
39267: PUSH
39268: LD_VAR 0 3
39272: ARRAY
39273: PUSH
39274: LD_INT 2
39276: ARRAY
39277: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
39278: LD_VAR 0 7
39282: PPUSH
39283: LD_INT 10
39285: PPUSH
39286: CALL 57032 0 2
39290: PUSH
39291: LD_INT 4
39293: ARRAY
39294: IFFALSE 39332
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
39296: LD_VAR 0 7
39300: PPUSH
39301: LD_VAR 0 6
39305: PUSH
39306: LD_INT 1
39308: ARRAY
39309: PPUSH
39310: LD_VAR 0 6
39314: PUSH
39315: LD_INT 2
39317: ARRAY
39318: PPUSH
39319: CALL_OW 111
// wait ( 0 0$10 ) ;
39323: LD_INT 350
39325: PPUSH
39326: CALL_OW 67
// end else
39330: GO 39358
// begin ComMoveXY ( tmp , x , y ) ;
39332: LD_VAR 0 7
39336: PPUSH
39337: LD_VAR 0 4
39341: PPUSH
39342: LD_VAR 0 5
39346: PPUSH
39347: CALL_OW 111
// wait ( 0 0$3 ) ;
39351: LD_INT 105
39353: PPUSH
39354: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
39358: LD_VAR 0 7
39362: PPUSH
39363: LD_VAR 0 4
39367: PPUSH
39368: LD_VAR 0 5
39372: PPUSH
39373: CALL_OW 307
39377: IFFALSE 39219
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
39379: LD_VAR 0 7
39383: PPUSH
39384: LD_VAR 0 4
39388: PPUSH
39389: LD_VAR 0 5
39393: PPUSH
39394: LD_VAR 0 8
39398: PUSH
39399: LD_VAR 0 3
39403: ARRAY
39404: PPUSH
39405: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
39409: LD_INT 35
39411: PPUSH
39412: CALL_OW 67
// until not HasTask ( tmp ) ;
39416: LD_VAR 0 7
39420: PPUSH
39421: CALL_OW 314
39425: NOT
39426: IFFALSE 39409
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
39428: LD_ADDR_EXP 86
39432: PUSH
39433: LD_EXP 86
39437: PPUSH
39438: LD_VAR 0 2
39442: PUSH
39443: LD_EXP 86
39447: PUSH
39448: LD_VAR 0 2
39452: ARRAY
39453: PUSH
39454: LD_INT 1
39456: PLUS
39457: PUSH
39458: EMPTY
39459: LIST
39460: LIST
39461: PPUSH
39462: LD_VAR 0 8
39466: PUSH
39467: LD_VAR 0 3
39471: ARRAY
39472: PPUSH
39473: CALL 54067 0 3
39477: ST_TO_ADDR
// end ;
39478: GO 39136
39480: POP
39481: POP
// MC_Reset ( i , 124 ) ;
39482: LD_VAR 0 2
39486: PPUSH
39487: LD_INT 124
39489: PPUSH
39490: CALL 22566 0 2
// end ; end ;
39494: GO 38891
39496: POP
39497: POP
// end ;
39498: LD_VAR 0 1
39502: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
39503: LD_INT 0
39505: PPUSH
39506: PPUSH
39507: PPUSH
// if not mc_bases then
39508: LD_EXP 50
39512: NOT
39513: IFFALSE 39517
// exit ;
39515: GO 40123
// for i = 1 to mc_bases do
39517: LD_ADDR_VAR 0 2
39521: PUSH
39522: DOUBLE
39523: LD_INT 1
39525: DEC
39526: ST_TO_ADDR
39527: LD_EXP 50
39531: PUSH
39532: FOR_TO
39533: IFFALSE 40121
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
39535: LD_ADDR_VAR 0 3
39539: PUSH
39540: LD_EXP 50
39544: PUSH
39545: LD_VAR 0 2
39549: ARRAY
39550: PPUSH
39551: LD_INT 25
39553: PUSH
39554: LD_INT 4
39556: PUSH
39557: EMPTY
39558: LIST
39559: LIST
39560: PPUSH
39561: CALL_OW 72
39565: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
39566: LD_VAR 0 3
39570: NOT
39571: PUSH
39572: LD_EXP 87
39576: PUSH
39577: LD_VAR 0 2
39581: ARRAY
39582: NOT
39583: OR
39584: PUSH
39585: LD_EXP 50
39589: PUSH
39590: LD_VAR 0 2
39594: ARRAY
39595: PPUSH
39596: LD_INT 2
39598: PUSH
39599: LD_INT 30
39601: PUSH
39602: LD_INT 0
39604: PUSH
39605: EMPTY
39606: LIST
39607: LIST
39608: PUSH
39609: LD_INT 30
39611: PUSH
39612: LD_INT 1
39614: PUSH
39615: EMPTY
39616: LIST
39617: LIST
39618: PUSH
39619: EMPTY
39620: LIST
39621: LIST
39622: LIST
39623: PPUSH
39624: CALL_OW 72
39628: NOT
39629: OR
39630: IFFALSE 39680
// begin if mc_deposits_finder [ i ] then
39632: LD_EXP 88
39636: PUSH
39637: LD_VAR 0 2
39641: ARRAY
39642: IFFALSE 39678
// begin MC_Reset ( i , 125 ) ;
39644: LD_VAR 0 2
39648: PPUSH
39649: LD_INT 125
39651: PPUSH
39652: CALL 22566 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
39656: LD_ADDR_EXP 88
39660: PUSH
39661: LD_EXP 88
39665: PPUSH
39666: LD_VAR 0 2
39670: PPUSH
39671: EMPTY
39672: PPUSH
39673: CALL_OW 1
39677: ST_TO_ADDR
// end ; continue ;
39678: GO 39532
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
39680: LD_EXP 87
39684: PUSH
39685: LD_VAR 0 2
39689: ARRAY
39690: PUSH
39691: LD_INT 1
39693: ARRAY
39694: PUSH
39695: LD_INT 3
39697: ARRAY
39698: PUSH
39699: LD_INT 1
39701: EQUAL
39702: PUSH
39703: LD_INT 20
39705: PPUSH
39706: LD_EXP 76
39710: PUSH
39711: LD_VAR 0 2
39715: ARRAY
39716: PPUSH
39717: CALL_OW 321
39721: PUSH
39722: LD_INT 2
39724: NONEQUAL
39725: AND
39726: IFFALSE 39776
// begin if mc_deposits_finder [ i ] then
39728: LD_EXP 88
39732: PUSH
39733: LD_VAR 0 2
39737: ARRAY
39738: IFFALSE 39774
// begin MC_Reset ( i , 125 ) ;
39740: LD_VAR 0 2
39744: PPUSH
39745: LD_INT 125
39747: PPUSH
39748: CALL 22566 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
39752: LD_ADDR_EXP 88
39756: PUSH
39757: LD_EXP 88
39761: PPUSH
39762: LD_VAR 0 2
39766: PPUSH
39767: EMPTY
39768: PPUSH
39769: CALL_OW 1
39773: ST_TO_ADDR
// end ; continue ;
39774: GO 39532
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
39776: LD_EXP 87
39780: PUSH
39781: LD_VAR 0 2
39785: ARRAY
39786: PUSH
39787: LD_INT 1
39789: ARRAY
39790: PUSH
39791: LD_INT 1
39793: ARRAY
39794: PPUSH
39795: LD_EXP 87
39799: PUSH
39800: LD_VAR 0 2
39804: ARRAY
39805: PUSH
39806: LD_INT 1
39808: ARRAY
39809: PUSH
39810: LD_INT 2
39812: ARRAY
39813: PPUSH
39814: LD_EXP 76
39818: PUSH
39819: LD_VAR 0 2
39823: ARRAY
39824: PPUSH
39825: CALL_OW 440
39829: IFFALSE 39872
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
39831: LD_ADDR_EXP 87
39835: PUSH
39836: LD_EXP 87
39840: PPUSH
39841: LD_VAR 0 2
39845: PPUSH
39846: LD_EXP 87
39850: PUSH
39851: LD_VAR 0 2
39855: ARRAY
39856: PPUSH
39857: LD_INT 1
39859: PPUSH
39860: CALL_OW 3
39864: PPUSH
39865: CALL_OW 1
39869: ST_TO_ADDR
39870: GO 40119
// begin if not mc_deposits_finder [ i ] then
39872: LD_EXP 88
39876: PUSH
39877: LD_VAR 0 2
39881: ARRAY
39882: NOT
39883: IFFALSE 39935
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
39885: LD_ADDR_EXP 88
39889: PUSH
39890: LD_EXP 88
39894: PPUSH
39895: LD_VAR 0 2
39899: PPUSH
39900: LD_VAR 0 3
39904: PUSH
39905: LD_INT 1
39907: ARRAY
39908: PUSH
39909: EMPTY
39910: LIST
39911: PPUSH
39912: CALL_OW 1
39916: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
39917: LD_VAR 0 3
39921: PUSH
39922: LD_INT 1
39924: ARRAY
39925: PPUSH
39926: LD_INT 125
39928: PPUSH
39929: CALL_OW 109
// end else
39933: GO 40119
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
39935: LD_EXP 88
39939: PUSH
39940: LD_VAR 0 2
39944: ARRAY
39945: PUSH
39946: LD_INT 1
39948: ARRAY
39949: PPUSH
39950: CALL_OW 310
39954: IFFALSE 39977
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
39956: LD_EXP 88
39960: PUSH
39961: LD_VAR 0 2
39965: ARRAY
39966: PUSH
39967: LD_INT 1
39969: ARRAY
39970: PPUSH
39971: CALL_OW 122
39975: GO 40119
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
39977: LD_EXP 88
39981: PUSH
39982: LD_VAR 0 2
39986: ARRAY
39987: PUSH
39988: LD_INT 1
39990: ARRAY
39991: PPUSH
39992: CALL_OW 314
39996: NOT
39997: PUSH
39998: LD_EXP 88
40002: PUSH
40003: LD_VAR 0 2
40007: ARRAY
40008: PUSH
40009: LD_INT 1
40011: ARRAY
40012: PPUSH
40013: LD_EXP 87
40017: PUSH
40018: LD_VAR 0 2
40022: ARRAY
40023: PUSH
40024: LD_INT 1
40026: ARRAY
40027: PUSH
40028: LD_INT 1
40030: ARRAY
40031: PPUSH
40032: LD_EXP 87
40036: PUSH
40037: LD_VAR 0 2
40041: ARRAY
40042: PUSH
40043: LD_INT 1
40045: ARRAY
40046: PUSH
40047: LD_INT 2
40049: ARRAY
40050: PPUSH
40051: CALL_OW 297
40055: PUSH
40056: LD_INT 6
40058: GREATER
40059: AND
40060: IFFALSE 40119
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
40062: LD_EXP 88
40066: PUSH
40067: LD_VAR 0 2
40071: ARRAY
40072: PUSH
40073: LD_INT 1
40075: ARRAY
40076: PPUSH
40077: LD_EXP 87
40081: PUSH
40082: LD_VAR 0 2
40086: ARRAY
40087: PUSH
40088: LD_INT 1
40090: ARRAY
40091: PUSH
40092: LD_INT 1
40094: ARRAY
40095: PPUSH
40096: LD_EXP 87
40100: PUSH
40101: LD_VAR 0 2
40105: ARRAY
40106: PUSH
40107: LD_INT 1
40109: ARRAY
40110: PUSH
40111: LD_INT 2
40113: ARRAY
40114: PPUSH
40115: CALL_OW 111
// end ; end ; end ;
40119: GO 39532
40121: POP
40122: POP
// end ;
40123: LD_VAR 0 1
40127: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
40128: LD_INT 0
40130: PPUSH
40131: PPUSH
40132: PPUSH
40133: PPUSH
40134: PPUSH
40135: PPUSH
40136: PPUSH
40137: PPUSH
40138: PPUSH
40139: PPUSH
40140: PPUSH
// if not mc_bases then
40141: LD_EXP 50
40145: NOT
40146: IFFALSE 40150
// exit ;
40148: GO 41090
// for i = 1 to mc_bases do
40150: LD_ADDR_VAR 0 2
40154: PUSH
40155: DOUBLE
40156: LD_INT 1
40158: DEC
40159: ST_TO_ADDR
40160: LD_EXP 50
40164: PUSH
40165: FOR_TO
40166: IFFALSE 41088
// begin if not mc_bases [ i ] or mc_scan [ i ] then
40168: LD_EXP 50
40172: PUSH
40173: LD_VAR 0 2
40177: ARRAY
40178: NOT
40179: PUSH
40180: LD_EXP 73
40184: PUSH
40185: LD_VAR 0 2
40189: ARRAY
40190: OR
40191: IFFALSE 40195
// continue ;
40193: GO 40165
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
40195: LD_ADDR_VAR 0 7
40199: PUSH
40200: LD_EXP 50
40204: PUSH
40205: LD_VAR 0 2
40209: ARRAY
40210: PUSH
40211: LD_INT 1
40213: ARRAY
40214: PPUSH
40215: CALL_OW 248
40219: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
40220: LD_VAR 0 7
40224: PUSH
40225: LD_INT 3
40227: EQUAL
40228: PUSH
40229: LD_EXP 69
40233: PUSH
40234: LD_VAR 0 2
40238: ARRAY
40239: PUSH
40240: LD_EXP 72
40244: PUSH
40245: LD_VAR 0 2
40249: ARRAY
40250: UNION
40251: PPUSH
40252: LD_INT 33
40254: PUSH
40255: LD_INT 2
40257: PUSH
40258: EMPTY
40259: LIST
40260: LIST
40261: PPUSH
40262: CALL_OW 72
40266: NOT
40267: OR
40268: IFFALSE 40272
// continue ;
40270: GO 40165
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
40272: LD_ADDR_VAR 0 9
40276: PUSH
40277: LD_EXP 50
40281: PUSH
40282: LD_VAR 0 2
40286: ARRAY
40287: PPUSH
40288: LD_INT 30
40290: PUSH
40291: LD_INT 36
40293: PUSH
40294: EMPTY
40295: LIST
40296: LIST
40297: PPUSH
40298: CALL_OW 72
40302: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
40303: LD_ADDR_VAR 0 10
40307: PUSH
40308: LD_EXP 69
40312: PUSH
40313: LD_VAR 0 2
40317: ARRAY
40318: PPUSH
40319: LD_INT 34
40321: PUSH
40322: LD_INT 31
40324: PUSH
40325: EMPTY
40326: LIST
40327: LIST
40328: PPUSH
40329: CALL_OW 72
40333: ST_TO_ADDR
// if not cts and not mcts then
40334: LD_VAR 0 9
40338: NOT
40339: PUSH
40340: LD_VAR 0 10
40344: NOT
40345: AND
40346: IFFALSE 40350
// continue ;
40348: GO 40165
// x := cts ;
40350: LD_ADDR_VAR 0 11
40354: PUSH
40355: LD_VAR 0 9
40359: ST_TO_ADDR
// if not x then
40360: LD_VAR 0 11
40364: NOT
40365: IFFALSE 40377
// x := mcts ;
40367: LD_ADDR_VAR 0 11
40371: PUSH
40372: LD_VAR 0 10
40376: ST_TO_ADDR
// if not x then
40377: LD_VAR 0 11
40381: NOT
40382: IFFALSE 40386
// continue ;
40384: GO 40165
// if mc_remote_driver [ i ] then
40386: LD_EXP 90
40390: PUSH
40391: LD_VAR 0 2
40395: ARRAY
40396: IFFALSE 40783
// for j in mc_remote_driver [ i ] do
40398: LD_ADDR_VAR 0 3
40402: PUSH
40403: LD_EXP 90
40407: PUSH
40408: LD_VAR 0 2
40412: ARRAY
40413: PUSH
40414: FOR_IN
40415: IFFALSE 40781
// begin if GetClass ( j ) <> 3 then
40417: LD_VAR 0 3
40421: PPUSH
40422: CALL_OW 257
40426: PUSH
40427: LD_INT 3
40429: NONEQUAL
40430: IFFALSE 40483
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
40432: LD_ADDR_EXP 90
40436: PUSH
40437: LD_EXP 90
40441: PPUSH
40442: LD_VAR 0 2
40446: PPUSH
40447: LD_EXP 90
40451: PUSH
40452: LD_VAR 0 2
40456: ARRAY
40457: PUSH
40458: LD_VAR 0 3
40462: DIFF
40463: PPUSH
40464: CALL_OW 1
40468: ST_TO_ADDR
// SetTag ( j , 0 ) ;
40469: LD_VAR 0 3
40473: PPUSH
40474: LD_INT 0
40476: PPUSH
40477: CALL_OW 109
// continue ;
40481: GO 40414
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
40483: LD_EXP 69
40487: PUSH
40488: LD_VAR 0 2
40492: ARRAY
40493: PPUSH
40494: LD_INT 34
40496: PUSH
40497: LD_INT 31
40499: PUSH
40500: EMPTY
40501: LIST
40502: LIST
40503: PUSH
40504: LD_INT 58
40506: PUSH
40507: EMPTY
40508: LIST
40509: PUSH
40510: EMPTY
40511: LIST
40512: LIST
40513: PPUSH
40514: CALL_OW 72
40518: PUSH
40519: LD_VAR 0 3
40523: PPUSH
40524: CALL 84411 0 1
40528: NOT
40529: AND
40530: IFFALSE 40601
// begin if IsInUnit ( j ) then
40532: LD_VAR 0 3
40536: PPUSH
40537: CALL_OW 310
40541: IFFALSE 40552
// ComExitBuilding ( j ) ;
40543: LD_VAR 0 3
40547: PPUSH
40548: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
40552: LD_VAR 0 3
40556: PPUSH
40557: LD_EXP 69
40561: PUSH
40562: LD_VAR 0 2
40566: ARRAY
40567: PPUSH
40568: LD_INT 34
40570: PUSH
40571: LD_INT 31
40573: PUSH
40574: EMPTY
40575: LIST
40576: LIST
40577: PUSH
40578: LD_INT 58
40580: PUSH
40581: EMPTY
40582: LIST
40583: PUSH
40584: EMPTY
40585: LIST
40586: LIST
40587: PPUSH
40588: CALL_OW 72
40592: PUSH
40593: LD_INT 1
40595: ARRAY
40596: PPUSH
40597: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
40601: LD_VAR 0 3
40605: PPUSH
40606: CALL_OW 310
40610: NOT
40611: PUSH
40612: LD_VAR 0 3
40616: PPUSH
40617: CALL_OW 310
40621: PPUSH
40622: CALL_OW 266
40626: PUSH
40627: LD_INT 36
40629: NONEQUAL
40630: PUSH
40631: LD_VAR 0 3
40635: PPUSH
40636: CALL 84411 0 1
40640: NOT
40641: AND
40642: OR
40643: IFFALSE 40779
// begin if IsInUnit ( j ) then
40645: LD_VAR 0 3
40649: PPUSH
40650: CALL_OW 310
40654: IFFALSE 40665
// ComExitBuilding ( j ) ;
40656: LD_VAR 0 3
40660: PPUSH
40661: CALL_OW 122
// ct := 0 ;
40665: LD_ADDR_VAR 0 8
40669: PUSH
40670: LD_INT 0
40672: ST_TO_ADDR
// for k in x do
40673: LD_ADDR_VAR 0 4
40677: PUSH
40678: LD_VAR 0 11
40682: PUSH
40683: FOR_IN
40684: IFFALSE 40757
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
40686: LD_VAR 0 4
40690: PPUSH
40691: CALL_OW 264
40695: PUSH
40696: LD_INT 31
40698: EQUAL
40699: PUSH
40700: LD_VAR 0 4
40704: PPUSH
40705: CALL_OW 311
40709: NOT
40710: AND
40711: PUSH
40712: LD_VAR 0 4
40716: PPUSH
40717: CALL_OW 266
40721: PUSH
40722: LD_INT 36
40724: EQUAL
40725: PUSH
40726: LD_VAR 0 4
40730: PPUSH
40731: CALL_OW 313
40735: PUSH
40736: LD_INT 3
40738: LESS
40739: AND
40740: OR
40741: IFFALSE 40755
// begin ct := k ;
40743: LD_ADDR_VAR 0 8
40747: PUSH
40748: LD_VAR 0 4
40752: ST_TO_ADDR
// break ;
40753: GO 40757
// end ;
40755: GO 40683
40757: POP
40758: POP
// if ct then
40759: LD_VAR 0 8
40763: IFFALSE 40779
// ComEnterUnit ( j , ct ) ;
40765: LD_VAR 0 3
40769: PPUSH
40770: LD_VAR 0 8
40774: PPUSH
40775: CALL_OW 120
// end ; end ;
40779: GO 40414
40781: POP
40782: POP
// places := 0 ;
40783: LD_ADDR_VAR 0 5
40787: PUSH
40788: LD_INT 0
40790: ST_TO_ADDR
// for j = 1 to x do
40791: LD_ADDR_VAR 0 3
40795: PUSH
40796: DOUBLE
40797: LD_INT 1
40799: DEC
40800: ST_TO_ADDR
40801: LD_VAR 0 11
40805: PUSH
40806: FOR_TO
40807: IFFALSE 40883
// if GetWeapon ( x [ j ] ) = ar_control_tower then
40809: LD_VAR 0 11
40813: PUSH
40814: LD_VAR 0 3
40818: ARRAY
40819: PPUSH
40820: CALL_OW 264
40824: PUSH
40825: LD_INT 31
40827: EQUAL
40828: IFFALSE 40846
// places := places + 1 else
40830: LD_ADDR_VAR 0 5
40834: PUSH
40835: LD_VAR 0 5
40839: PUSH
40840: LD_INT 1
40842: PLUS
40843: ST_TO_ADDR
40844: GO 40881
// if GetBType ( x [ j ] ) = b_control_tower then
40846: LD_VAR 0 11
40850: PUSH
40851: LD_VAR 0 3
40855: ARRAY
40856: PPUSH
40857: CALL_OW 266
40861: PUSH
40862: LD_INT 36
40864: EQUAL
40865: IFFALSE 40881
// places := places + 3 ;
40867: LD_ADDR_VAR 0 5
40871: PUSH
40872: LD_VAR 0 5
40876: PUSH
40877: LD_INT 3
40879: PLUS
40880: ST_TO_ADDR
40881: GO 40806
40883: POP
40884: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
40885: LD_VAR 0 5
40889: PUSH
40890: LD_INT 0
40892: EQUAL
40893: PUSH
40894: LD_VAR 0 5
40898: PUSH
40899: LD_EXP 90
40903: PUSH
40904: LD_VAR 0 2
40908: ARRAY
40909: LESSEQUAL
40910: OR
40911: IFFALSE 40915
// continue ;
40913: GO 40165
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
40915: LD_ADDR_VAR 0 6
40919: PUSH
40920: LD_EXP 50
40924: PUSH
40925: LD_VAR 0 2
40929: ARRAY
40930: PPUSH
40931: LD_INT 25
40933: PUSH
40934: LD_INT 3
40936: PUSH
40937: EMPTY
40938: LIST
40939: LIST
40940: PPUSH
40941: CALL_OW 72
40945: PUSH
40946: LD_EXP 90
40950: PUSH
40951: LD_VAR 0 2
40955: ARRAY
40956: DIFF
40957: PPUSH
40958: LD_INT 3
40960: PPUSH
40961: CALL 85311 0 2
40965: ST_TO_ADDR
// for j in tmp do
40966: LD_ADDR_VAR 0 3
40970: PUSH
40971: LD_VAR 0 6
40975: PUSH
40976: FOR_IN
40977: IFFALSE 41012
// if GetTag ( j ) > 0 then
40979: LD_VAR 0 3
40983: PPUSH
40984: CALL_OW 110
40988: PUSH
40989: LD_INT 0
40991: GREATER
40992: IFFALSE 41010
// tmp := tmp diff j ;
40994: LD_ADDR_VAR 0 6
40998: PUSH
40999: LD_VAR 0 6
41003: PUSH
41004: LD_VAR 0 3
41008: DIFF
41009: ST_TO_ADDR
41010: GO 40976
41012: POP
41013: POP
// if not tmp then
41014: LD_VAR 0 6
41018: NOT
41019: IFFALSE 41023
// continue ;
41021: GO 40165
// if places then
41023: LD_VAR 0 5
41027: IFFALSE 41086
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
41029: LD_ADDR_EXP 90
41033: PUSH
41034: LD_EXP 90
41038: PPUSH
41039: LD_VAR 0 2
41043: PPUSH
41044: LD_EXP 90
41048: PUSH
41049: LD_VAR 0 2
41053: ARRAY
41054: PUSH
41055: LD_VAR 0 6
41059: PUSH
41060: LD_INT 1
41062: ARRAY
41063: UNION
41064: PPUSH
41065: CALL_OW 1
41069: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
41070: LD_VAR 0 6
41074: PUSH
41075: LD_INT 1
41077: ARRAY
41078: PPUSH
41079: LD_INT 126
41081: PPUSH
41082: CALL_OW 109
// end ; end ;
41086: GO 40165
41088: POP
41089: POP
// end ;
41090: LD_VAR 0 1
41094: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
41095: LD_INT 0
41097: PPUSH
41098: PPUSH
41099: PPUSH
41100: PPUSH
41101: PPUSH
41102: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
41103: LD_VAR 0 1
41107: NOT
41108: PUSH
41109: LD_VAR 0 2
41113: NOT
41114: OR
41115: PUSH
41116: LD_VAR 0 3
41120: NOT
41121: OR
41122: PUSH
41123: LD_VAR 0 4
41127: PUSH
41128: LD_INT 1
41130: PUSH
41131: LD_INT 2
41133: PUSH
41134: LD_INT 3
41136: PUSH
41137: LD_INT 4
41139: PUSH
41140: LD_INT 5
41142: PUSH
41143: LD_INT 8
41145: PUSH
41146: LD_INT 9
41148: PUSH
41149: LD_INT 15
41151: PUSH
41152: LD_INT 16
41154: PUSH
41155: EMPTY
41156: LIST
41157: LIST
41158: LIST
41159: LIST
41160: LIST
41161: LIST
41162: LIST
41163: LIST
41164: LIST
41165: IN
41166: NOT
41167: OR
41168: IFFALSE 41172
// exit ;
41170: GO 42030
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
41172: LD_ADDR_VAR 0 2
41176: PUSH
41177: LD_VAR 0 2
41181: PPUSH
41182: LD_INT 21
41184: PUSH
41185: LD_INT 3
41187: PUSH
41188: EMPTY
41189: LIST
41190: LIST
41191: PUSH
41192: LD_INT 24
41194: PUSH
41195: LD_INT 250
41197: PUSH
41198: EMPTY
41199: LIST
41200: LIST
41201: PUSH
41202: EMPTY
41203: LIST
41204: LIST
41205: PPUSH
41206: CALL_OW 72
41210: ST_TO_ADDR
// case class of 1 , 15 :
41211: LD_VAR 0 4
41215: PUSH
41216: LD_INT 1
41218: DOUBLE
41219: EQUAL
41220: IFTRUE 41230
41222: LD_INT 15
41224: DOUBLE
41225: EQUAL
41226: IFTRUE 41230
41228: GO 41315
41230: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
41231: LD_ADDR_VAR 0 8
41235: PUSH
41236: LD_VAR 0 2
41240: PPUSH
41241: LD_INT 2
41243: PUSH
41244: LD_INT 30
41246: PUSH
41247: LD_INT 32
41249: PUSH
41250: EMPTY
41251: LIST
41252: LIST
41253: PUSH
41254: LD_INT 30
41256: PUSH
41257: LD_INT 31
41259: PUSH
41260: EMPTY
41261: LIST
41262: LIST
41263: PUSH
41264: EMPTY
41265: LIST
41266: LIST
41267: LIST
41268: PPUSH
41269: CALL_OW 72
41273: PUSH
41274: LD_VAR 0 2
41278: PPUSH
41279: LD_INT 2
41281: PUSH
41282: LD_INT 30
41284: PUSH
41285: LD_INT 4
41287: PUSH
41288: EMPTY
41289: LIST
41290: LIST
41291: PUSH
41292: LD_INT 30
41294: PUSH
41295: LD_INT 5
41297: PUSH
41298: EMPTY
41299: LIST
41300: LIST
41301: PUSH
41302: EMPTY
41303: LIST
41304: LIST
41305: LIST
41306: PPUSH
41307: CALL_OW 72
41311: ADD
41312: ST_TO_ADDR
41313: GO 41561
41315: LD_INT 2
41317: DOUBLE
41318: EQUAL
41319: IFTRUE 41329
41321: LD_INT 16
41323: DOUBLE
41324: EQUAL
41325: IFTRUE 41329
41327: GO 41375
41329: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
41330: LD_ADDR_VAR 0 8
41334: PUSH
41335: LD_VAR 0 2
41339: PPUSH
41340: LD_INT 2
41342: PUSH
41343: LD_INT 30
41345: PUSH
41346: LD_INT 0
41348: PUSH
41349: EMPTY
41350: LIST
41351: LIST
41352: PUSH
41353: LD_INT 30
41355: PUSH
41356: LD_INT 1
41358: PUSH
41359: EMPTY
41360: LIST
41361: LIST
41362: PUSH
41363: EMPTY
41364: LIST
41365: LIST
41366: LIST
41367: PPUSH
41368: CALL_OW 72
41372: ST_TO_ADDR
41373: GO 41561
41375: LD_INT 3
41377: DOUBLE
41378: EQUAL
41379: IFTRUE 41383
41381: GO 41429
41383: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
41384: LD_ADDR_VAR 0 8
41388: PUSH
41389: LD_VAR 0 2
41393: PPUSH
41394: LD_INT 2
41396: PUSH
41397: LD_INT 30
41399: PUSH
41400: LD_INT 2
41402: PUSH
41403: EMPTY
41404: LIST
41405: LIST
41406: PUSH
41407: LD_INT 30
41409: PUSH
41410: LD_INT 3
41412: PUSH
41413: EMPTY
41414: LIST
41415: LIST
41416: PUSH
41417: EMPTY
41418: LIST
41419: LIST
41420: LIST
41421: PPUSH
41422: CALL_OW 72
41426: ST_TO_ADDR
41427: GO 41561
41429: LD_INT 4
41431: DOUBLE
41432: EQUAL
41433: IFTRUE 41437
41435: GO 41494
41437: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
41438: LD_ADDR_VAR 0 8
41442: PUSH
41443: LD_VAR 0 2
41447: PPUSH
41448: LD_INT 2
41450: PUSH
41451: LD_INT 30
41453: PUSH
41454: LD_INT 6
41456: PUSH
41457: EMPTY
41458: LIST
41459: LIST
41460: PUSH
41461: LD_INT 30
41463: PUSH
41464: LD_INT 7
41466: PUSH
41467: EMPTY
41468: LIST
41469: LIST
41470: PUSH
41471: LD_INT 30
41473: PUSH
41474: LD_INT 8
41476: PUSH
41477: EMPTY
41478: LIST
41479: LIST
41480: PUSH
41481: EMPTY
41482: LIST
41483: LIST
41484: LIST
41485: LIST
41486: PPUSH
41487: CALL_OW 72
41491: ST_TO_ADDR
41492: GO 41561
41494: LD_INT 5
41496: DOUBLE
41497: EQUAL
41498: IFTRUE 41514
41500: LD_INT 8
41502: DOUBLE
41503: EQUAL
41504: IFTRUE 41514
41506: LD_INT 9
41508: DOUBLE
41509: EQUAL
41510: IFTRUE 41514
41512: GO 41560
41514: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
41515: LD_ADDR_VAR 0 8
41519: PUSH
41520: LD_VAR 0 2
41524: PPUSH
41525: LD_INT 2
41527: PUSH
41528: LD_INT 30
41530: PUSH
41531: LD_INT 4
41533: PUSH
41534: EMPTY
41535: LIST
41536: LIST
41537: PUSH
41538: LD_INT 30
41540: PUSH
41541: LD_INT 5
41543: PUSH
41544: EMPTY
41545: LIST
41546: LIST
41547: PUSH
41548: EMPTY
41549: LIST
41550: LIST
41551: LIST
41552: PPUSH
41553: CALL_OW 72
41557: ST_TO_ADDR
41558: GO 41561
41560: POP
// if not tmp then
41561: LD_VAR 0 8
41565: NOT
41566: IFFALSE 41570
// exit ;
41568: GO 42030
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
41570: LD_VAR 0 4
41574: PUSH
41575: LD_INT 1
41577: PUSH
41578: LD_INT 15
41580: PUSH
41581: EMPTY
41582: LIST
41583: LIST
41584: IN
41585: PUSH
41586: LD_EXP 59
41590: PUSH
41591: LD_VAR 0 1
41595: ARRAY
41596: AND
41597: IFFALSE 41753
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
41599: LD_ADDR_VAR 0 9
41603: PUSH
41604: LD_EXP 59
41608: PUSH
41609: LD_VAR 0 1
41613: ARRAY
41614: PUSH
41615: LD_INT 1
41617: ARRAY
41618: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
41619: LD_VAR 0 9
41623: PUSH
41624: LD_EXP 60
41628: PUSH
41629: LD_VAR 0 1
41633: ARRAY
41634: IN
41635: NOT
41636: IFFALSE 41751
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
41638: LD_ADDR_EXP 60
41642: PUSH
41643: LD_EXP 60
41647: PPUSH
41648: LD_VAR 0 1
41652: PUSH
41653: LD_EXP 60
41657: PUSH
41658: LD_VAR 0 1
41662: ARRAY
41663: PUSH
41664: LD_INT 1
41666: PLUS
41667: PUSH
41668: EMPTY
41669: LIST
41670: LIST
41671: PPUSH
41672: LD_VAR 0 9
41676: PPUSH
41677: CALL 54067 0 3
41681: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
41682: LD_ADDR_EXP 59
41686: PUSH
41687: LD_EXP 59
41691: PPUSH
41692: LD_VAR 0 1
41696: PPUSH
41697: LD_EXP 59
41701: PUSH
41702: LD_VAR 0 1
41706: ARRAY
41707: PUSH
41708: LD_VAR 0 9
41712: DIFF
41713: PPUSH
41714: CALL_OW 1
41718: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
41719: LD_VAR 0 3
41723: PPUSH
41724: LD_EXP 60
41728: PUSH
41729: LD_VAR 0 1
41733: ARRAY
41734: PUSH
41735: LD_EXP 60
41739: PUSH
41740: LD_VAR 0 1
41744: ARRAY
41745: ARRAY
41746: PPUSH
41747: CALL_OW 120
// end ; exit ;
41751: GO 42030
// end ; if tmp > 1 then
41753: LD_VAR 0 8
41757: PUSH
41758: LD_INT 1
41760: GREATER
41761: IFFALSE 41865
// for i = 2 to tmp do
41763: LD_ADDR_VAR 0 6
41767: PUSH
41768: DOUBLE
41769: LD_INT 2
41771: DEC
41772: ST_TO_ADDR
41773: LD_VAR 0 8
41777: PUSH
41778: FOR_TO
41779: IFFALSE 41863
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
41781: LD_VAR 0 8
41785: PUSH
41786: LD_VAR 0 6
41790: ARRAY
41791: PPUSH
41792: CALL_OW 461
41796: PUSH
41797: LD_INT 6
41799: EQUAL
41800: IFFALSE 41861
// begin x := tmp [ i ] ;
41802: LD_ADDR_VAR 0 9
41806: PUSH
41807: LD_VAR 0 8
41811: PUSH
41812: LD_VAR 0 6
41816: ARRAY
41817: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
41818: LD_ADDR_VAR 0 8
41822: PUSH
41823: LD_VAR 0 8
41827: PPUSH
41828: LD_VAR 0 6
41832: PPUSH
41833: CALL_OW 3
41837: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
41838: LD_ADDR_VAR 0 8
41842: PUSH
41843: LD_VAR 0 8
41847: PPUSH
41848: LD_INT 1
41850: PPUSH
41851: LD_VAR 0 9
41855: PPUSH
41856: CALL_OW 2
41860: ST_TO_ADDR
// end ;
41861: GO 41778
41863: POP
41864: POP
// for i in tmp do
41865: LD_ADDR_VAR 0 6
41869: PUSH
41870: LD_VAR 0 8
41874: PUSH
41875: FOR_IN
41876: IFFALSE 41903
// begin if IsNotFull ( i ) then
41878: LD_VAR 0 6
41882: PPUSH
41883: CALL 51289 0 1
41887: IFFALSE 41901
// begin j := i ;
41889: LD_ADDR_VAR 0 7
41893: PUSH
41894: LD_VAR 0 6
41898: ST_TO_ADDR
// break ;
41899: GO 41903
// end ; end ;
41901: GO 41875
41903: POP
41904: POP
// if j then
41905: LD_VAR 0 7
41909: IFFALSE 41927
// ComEnterUnit ( unit , j ) else
41911: LD_VAR 0 3
41915: PPUSH
41916: LD_VAR 0 7
41920: PPUSH
41921: CALL_OW 120
41925: GO 42030
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
41927: LD_ADDR_VAR 0 10
41931: PUSH
41932: LD_VAR 0 2
41936: PPUSH
41937: LD_INT 2
41939: PUSH
41940: LD_INT 30
41942: PUSH
41943: LD_INT 0
41945: PUSH
41946: EMPTY
41947: LIST
41948: LIST
41949: PUSH
41950: LD_INT 30
41952: PUSH
41953: LD_INT 1
41955: PUSH
41956: EMPTY
41957: LIST
41958: LIST
41959: PUSH
41960: EMPTY
41961: LIST
41962: LIST
41963: LIST
41964: PPUSH
41965: CALL_OW 72
41969: ST_TO_ADDR
// if depot then
41970: LD_VAR 0 10
41974: IFFALSE 42030
// begin depot := NearestUnitToUnit ( depot , unit ) ;
41976: LD_ADDR_VAR 0 10
41980: PUSH
41981: LD_VAR 0 10
41985: PPUSH
41986: LD_VAR 0 3
41990: PPUSH
41991: CALL_OW 74
41995: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
41996: LD_VAR 0 3
42000: PPUSH
42001: LD_VAR 0 10
42005: PPUSH
42006: CALL_OW 296
42010: PUSH
42011: LD_INT 10
42013: GREATER
42014: IFFALSE 42030
// ComStandNearbyBuilding ( unit , depot ) ;
42016: LD_VAR 0 3
42020: PPUSH
42021: LD_VAR 0 10
42025: PPUSH
42026: CALL 50669 0 2
// end ; end ; end ;
42030: LD_VAR 0 5
42034: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
42035: LD_INT 0
42037: PPUSH
42038: PPUSH
42039: PPUSH
42040: PPUSH
// if not mc_bases then
42041: LD_EXP 50
42045: NOT
42046: IFFALSE 42050
// exit ;
42048: GO 42289
// for i = 1 to mc_bases do
42050: LD_ADDR_VAR 0 2
42054: PUSH
42055: DOUBLE
42056: LD_INT 1
42058: DEC
42059: ST_TO_ADDR
42060: LD_EXP 50
42064: PUSH
42065: FOR_TO
42066: IFFALSE 42287
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
42068: LD_ADDR_VAR 0 4
42072: PUSH
42073: LD_EXP 50
42077: PUSH
42078: LD_VAR 0 2
42082: ARRAY
42083: PPUSH
42084: LD_INT 21
42086: PUSH
42087: LD_INT 1
42089: PUSH
42090: EMPTY
42091: LIST
42092: LIST
42093: PPUSH
42094: CALL_OW 72
42098: PUSH
42099: LD_EXP 79
42103: PUSH
42104: LD_VAR 0 2
42108: ARRAY
42109: UNION
42110: ST_TO_ADDR
// if not tmp then
42111: LD_VAR 0 4
42115: NOT
42116: IFFALSE 42120
// continue ;
42118: GO 42065
// for j in tmp do
42120: LD_ADDR_VAR 0 3
42124: PUSH
42125: LD_VAR 0 4
42129: PUSH
42130: FOR_IN
42131: IFFALSE 42283
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
42133: LD_VAR 0 3
42137: PPUSH
42138: CALL_OW 110
42142: NOT
42143: PUSH
42144: LD_VAR 0 3
42148: PPUSH
42149: CALL_OW 314
42153: NOT
42154: AND
42155: PUSH
42156: LD_VAR 0 3
42160: PPUSH
42161: CALL_OW 311
42165: NOT
42166: AND
42167: PUSH
42168: LD_VAR 0 3
42172: PPUSH
42173: CALL_OW 310
42177: NOT
42178: AND
42179: PUSH
42180: LD_VAR 0 3
42184: PUSH
42185: LD_EXP 53
42189: PUSH
42190: LD_VAR 0 2
42194: ARRAY
42195: PUSH
42196: LD_INT 1
42198: ARRAY
42199: IN
42200: NOT
42201: AND
42202: PUSH
42203: LD_VAR 0 3
42207: PUSH
42208: LD_EXP 53
42212: PUSH
42213: LD_VAR 0 2
42217: ARRAY
42218: PUSH
42219: LD_INT 2
42221: ARRAY
42222: IN
42223: NOT
42224: AND
42225: PUSH
42226: LD_VAR 0 3
42230: PUSH
42231: LD_EXP 62
42235: PUSH
42236: LD_VAR 0 2
42240: ARRAY
42241: IN
42242: NOT
42243: AND
42244: IFFALSE 42281
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
42246: LD_VAR 0 2
42250: PPUSH
42251: LD_EXP 50
42255: PUSH
42256: LD_VAR 0 2
42260: ARRAY
42261: PPUSH
42262: LD_VAR 0 3
42266: PPUSH
42267: LD_VAR 0 3
42271: PPUSH
42272: CALL_OW 257
42276: PPUSH
42277: CALL 41095 0 4
// end ;
42281: GO 42130
42283: POP
42284: POP
// end ;
42285: GO 42065
42287: POP
42288: POP
// end ;
42289: LD_VAR 0 1
42293: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
42294: LD_INT 0
42296: PPUSH
42297: PPUSH
42298: PPUSH
42299: PPUSH
42300: PPUSH
42301: PPUSH
// if not mc_bases [ base ] then
42302: LD_EXP 50
42306: PUSH
42307: LD_VAR 0 1
42311: ARRAY
42312: NOT
42313: IFFALSE 42317
// exit ;
42315: GO 42518
// tmp := [ ] ;
42317: LD_ADDR_VAR 0 6
42321: PUSH
42322: EMPTY
42323: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
42324: LD_ADDR_VAR 0 7
42328: PUSH
42329: LD_VAR 0 3
42333: PPUSH
42334: LD_INT 0
42336: PPUSH
42337: CALL_OW 517
42341: ST_TO_ADDR
// if not list then
42342: LD_VAR 0 7
42346: NOT
42347: IFFALSE 42351
// exit ;
42349: GO 42518
// c := Count ( list [ 1 ] ) ;
42351: LD_ADDR_VAR 0 9
42355: PUSH
42356: LD_VAR 0 7
42360: PUSH
42361: LD_INT 1
42363: ARRAY
42364: PPUSH
42365: CALL 51207 0 1
42369: ST_TO_ADDR
// if amount > c then
42370: LD_VAR 0 2
42374: PUSH
42375: LD_VAR 0 9
42379: GREATER
42380: IFFALSE 42392
// amount := c ;
42382: LD_ADDR_VAR 0 2
42386: PUSH
42387: LD_VAR 0 9
42391: ST_TO_ADDR
// for i := 1 to amount do
42392: LD_ADDR_VAR 0 5
42396: PUSH
42397: DOUBLE
42398: LD_INT 1
42400: DEC
42401: ST_TO_ADDR
42402: LD_VAR 0 2
42406: PUSH
42407: FOR_TO
42408: IFFALSE 42466
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
42410: LD_ADDR_VAR 0 6
42414: PUSH
42415: LD_VAR 0 6
42419: PPUSH
42420: LD_VAR 0 5
42424: PPUSH
42425: LD_VAR 0 7
42429: PUSH
42430: LD_INT 1
42432: ARRAY
42433: PUSH
42434: LD_VAR 0 5
42438: ARRAY
42439: PUSH
42440: LD_VAR 0 7
42444: PUSH
42445: LD_INT 2
42447: ARRAY
42448: PUSH
42449: LD_VAR 0 5
42453: ARRAY
42454: PUSH
42455: EMPTY
42456: LIST
42457: LIST
42458: PPUSH
42459: CALL_OW 1
42463: ST_TO_ADDR
42464: GO 42407
42466: POP
42467: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
42468: LD_ADDR_EXP 63
42472: PUSH
42473: LD_EXP 63
42477: PPUSH
42478: LD_VAR 0 1
42482: PPUSH
42483: LD_VAR 0 6
42487: PPUSH
42488: CALL_OW 1
42492: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
42493: LD_ADDR_EXP 65
42497: PUSH
42498: LD_EXP 65
42502: PPUSH
42503: LD_VAR 0 1
42507: PPUSH
42508: LD_VAR 0 3
42512: PPUSH
42513: CALL_OW 1
42517: ST_TO_ADDR
// end ;
42518: LD_VAR 0 4
42522: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
42523: LD_INT 0
42525: PPUSH
// if not mc_bases [ base ] then
42526: LD_EXP 50
42530: PUSH
42531: LD_VAR 0 1
42535: ARRAY
42536: NOT
42537: IFFALSE 42541
// exit ;
42539: GO 42566
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
42541: LD_ADDR_EXP 55
42545: PUSH
42546: LD_EXP 55
42550: PPUSH
42551: LD_VAR 0 1
42555: PPUSH
42556: LD_VAR 0 2
42560: PPUSH
42561: CALL_OW 1
42565: ST_TO_ADDR
// end ;
42566: LD_VAR 0 3
42570: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
42571: LD_INT 0
42573: PPUSH
// if not mc_bases [ base ] then
42574: LD_EXP 50
42578: PUSH
42579: LD_VAR 0 1
42583: ARRAY
42584: NOT
42585: IFFALSE 42589
// exit ;
42587: GO 42626
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
42589: LD_ADDR_EXP 55
42593: PUSH
42594: LD_EXP 55
42598: PPUSH
42599: LD_VAR 0 1
42603: PPUSH
42604: LD_EXP 55
42608: PUSH
42609: LD_VAR 0 1
42613: ARRAY
42614: PUSH
42615: LD_VAR 0 2
42619: UNION
42620: PPUSH
42621: CALL_OW 1
42625: ST_TO_ADDR
// end ;
42626: LD_VAR 0 3
42630: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
42631: LD_INT 0
42633: PPUSH
// if not mc_bases [ base ] then
42634: LD_EXP 50
42638: PUSH
42639: LD_VAR 0 1
42643: ARRAY
42644: NOT
42645: IFFALSE 42649
// exit ;
42647: GO 42674
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
42649: LD_ADDR_EXP 71
42653: PUSH
42654: LD_EXP 71
42658: PPUSH
42659: LD_VAR 0 1
42663: PPUSH
42664: LD_VAR 0 2
42668: PPUSH
42669: CALL_OW 1
42673: ST_TO_ADDR
// end ;
42674: LD_VAR 0 3
42678: RET
// export function MC_InsertProduceList ( base , components ) ; begin
42679: LD_INT 0
42681: PPUSH
// if not mc_bases [ base ] then
42682: LD_EXP 50
42686: PUSH
42687: LD_VAR 0 1
42691: ARRAY
42692: NOT
42693: IFFALSE 42697
// exit ;
42695: GO 42734
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
42697: LD_ADDR_EXP 71
42701: PUSH
42702: LD_EXP 71
42706: PPUSH
42707: LD_VAR 0 1
42711: PPUSH
42712: LD_EXP 71
42716: PUSH
42717: LD_VAR 0 1
42721: ARRAY
42722: PUSH
42723: LD_VAR 0 2
42727: ADD
42728: PPUSH
42729: CALL_OW 1
42733: ST_TO_ADDR
// end ;
42734: LD_VAR 0 3
42738: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
42739: LD_INT 0
42741: PPUSH
// if not mc_bases [ base ] then
42742: LD_EXP 50
42746: PUSH
42747: LD_VAR 0 1
42751: ARRAY
42752: NOT
42753: IFFALSE 42757
// exit ;
42755: GO 42811
// mc_defender := Replace ( mc_defender , base , deflist ) ;
42757: LD_ADDR_EXP 72
42761: PUSH
42762: LD_EXP 72
42766: PPUSH
42767: LD_VAR 0 1
42771: PPUSH
42772: LD_VAR 0 2
42776: PPUSH
42777: CALL_OW 1
42781: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
42782: LD_ADDR_EXP 61
42786: PUSH
42787: LD_EXP 61
42791: PPUSH
42792: LD_VAR 0 1
42796: PPUSH
42797: LD_VAR 0 2
42801: PUSH
42802: LD_INT 0
42804: PLUS
42805: PPUSH
42806: CALL_OW 1
42810: ST_TO_ADDR
// end ;
42811: LD_VAR 0 3
42815: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
42816: LD_INT 0
42818: PPUSH
// if not mc_bases [ base ] then
42819: LD_EXP 50
42823: PUSH
42824: LD_VAR 0 1
42828: ARRAY
42829: NOT
42830: IFFALSE 42834
// exit ;
42832: GO 42859
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
42834: LD_ADDR_EXP 61
42838: PUSH
42839: LD_EXP 61
42843: PPUSH
42844: LD_VAR 0 1
42848: PPUSH
42849: LD_VAR 0 2
42853: PPUSH
42854: CALL_OW 1
42858: ST_TO_ADDR
// end ;
42859: LD_VAR 0 3
42863: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
42864: LD_INT 0
42866: PPUSH
42867: PPUSH
42868: PPUSH
42869: PPUSH
// if not mc_bases [ base ] then
42870: LD_EXP 50
42874: PUSH
42875: LD_VAR 0 1
42879: ARRAY
42880: NOT
42881: IFFALSE 42885
// exit ;
42883: GO 42950
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
42885: LD_ADDR_EXP 70
42889: PUSH
42890: LD_EXP 70
42894: PPUSH
42895: LD_VAR 0 1
42899: PUSH
42900: LD_EXP 70
42904: PUSH
42905: LD_VAR 0 1
42909: ARRAY
42910: PUSH
42911: LD_INT 1
42913: PLUS
42914: PUSH
42915: EMPTY
42916: LIST
42917: LIST
42918: PPUSH
42919: LD_VAR 0 1
42923: PUSH
42924: LD_VAR 0 2
42928: PUSH
42929: LD_VAR 0 3
42933: PUSH
42934: LD_VAR 0 4
42938: PUSH
42939: EMPTY
42940: LIST
42941: LIST
42942: LIST
42943: LIST
42944: PPUSH
42945: CALL 54067 0 3
42949: ST_TO_ADDR
// end ;
42950: LD_VAR 0 5
42954: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
42955: LD_INT 0
42957: PPUSH
// if not mc_bases [ base ] then
42958: LD_EXP 50
42962: PUSH
42963: LD_VAR 0 1
42967: ARRAY
42968: NOT
42969: IFFALSE 42973
// exit ;
42971: GO 42998
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
42973: LD_ADDR_EXP 87
42977: PUSH
42978: LD_EXP 87
42982: PPUSH
42983: LD_VAR 0 1
42987: PPUSH
42988: LD_VAR 0 2
42992: PPUSH
42993: CALL_OW 1
42997: ST_TO_ADDR
// end ;
42998: LD_VAR 0 3
43002: RET
// export function MC_GetMinesField ( base ) ; begin
43003: LD_INT 0
43005: PPUSH
// result := mc_mines [ base ] ;
43006: LD_ADDR_VAR 0 2
43010: PUSH
43011: LD_EXP 63
43015: PUSH
43016: LD_VAR 0 1
43020: ARRAY
43021: ST_TO_ADDR
// end ;
43022: LD_VAR 0 2
43026: RET
// export function MC_GetProduceList ( base ) ; begin
43027: LD_INT 0
43029: PPUSH
// result := mc_produce [ base ] ;
43030: LD_ADDR_VAR 0 2
43034: PUSH
43035: LD_EXP 71
43039: PUSH
43040: LD_VAR 0 1
43044: ARRAY
43045: ST_TO_ADDR
// end ;
43046: LD_VAR 0 2
43050: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
43051: LD_INT 0
43053: PPUSH
43054: PPUSH
// if not mc_bases then
43055: LD_EXP 50
43059: NOT
43060: IFFALSE 43064
// exit ;
43062: GO 43129
// if mc_bases [ base ] then
43064: LD_EXP 50
43068: PUSH
43069: LD_VAR 0 1
43073: ARRAY
43074: IFFALSE 43129
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
43076: LD_ADDR_VAR 0 3
43080: PUSH
43081: LD_EXP 50
43085: PUSH
43086: LD_VAR 0 1
43090: ARRAY
43091: PPUSH
43092: LD_INT 30
43094: PUSH
43095: LD_VAR 0 2
43099: PUSH
43100: EMPTY
43101: LIST
43102: LIST
43103: PPUSH
43104: CALL_OW 72
43108: ST_TO_ADDR
// if result then
43109: LD_VAR 0 3
43113: IFFALSE 43129
// result := result [ 1 ] ;
43115: LD_ADDR_VAR 0 3
43119: PUSH
43120: LD_VAR 0 3
43124: PUSH
43125: LD_INT 1
43127: ARRAY
43128: ST_TO_ADDR
// end ; end ;
43129: LD_VAR 0 3
43133: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
43134: LD_INT 0
43136: PPUSH
43137: PPUSH
// if not mc_bases then
43138: LD_EXP 50
43142: NOT
43143: IFFALSE 43147
// exit ;
43145: GO 43192
// if mc_bases [ base ] then
43147: LD_EXP 50
43151: PUSH
43152: LD_VAR 0 1
43156: ARRAY
43157: IFFALSE 43192
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
43159: LD_ADDR_VAR 0 3
43163: PUSH
43164: LD_EXP 50
43168: PUSH
43169: LD_VAR 0 1
43173: ARRAY
43174: PPUSH
43175: LD_INT 30
43177: PUSH
43178: LD_VAR 0 2
43182: PUSH
43183: EMPTY
43184: LIST
43185: LIST
43186: PPUSH
43187: CALL_OW 72
43191: ST_TO_ADDR
// end ;
43192: LD_VAR 0 3
43196: RET
// export function MC_SetTame ( base , area ) ; begin
43197: LD_INT 0
43199: PPUSH
// if not mc_bases or not base then
43200: LD_EXP 50
43204: NOT
43205: PUSH
43206: LD_VAR 0 1
43210: NOT
43211: OR
43212: IFFALSE 43216
// exit ;
43214: GO 43241
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
43216: LD_ADDR_EXP 78
43220: PUSH
43221: LD_EXP 78
43225: PPUSH
43226: LD_VAR 0 1
43230: PPUSH
43231: LD_VAR 0 2
43235: PPUSH
43236: CALL_OW 1
43240: ST_TO_ADDR
// end ;
43241: LD_VAR 0 3
43245: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
43246: LD_INT 0
43248: PPUSH
43249: PPUSH
// if not mc_bases or not base then
43250: LD_EXP 50
43254: NOT
43255: PUSH
43256: LD_VAR 0 1
43260: NOT
43261: OR
43262: IFFALSE 43266
// exit ;
43264: GO 43368
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
43266: LD_ADDR_VAR 0 4
43270: PUSH
43271: LD_EXP 50
43275: PUSH
43276: LD_VAR 0 1
43280: ARRAY
43281: PPUSH
43282: LD_INT 30
43284: PUSH
43285: LD_VAR 0 2
43289: PUSH
43290: EMPTY
43291: LIST
43292: LIST
43293: PPUSH
43294: CALL_OW 72
43298: ST_TO_ADDR
// if not tmp then
43299: LD_VAR 0 4
43303: NOT
43304: IFFALSE 43308
// exit ;
43306: GO 43368
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
43308: LD_ADDR_EXP 82
43312: PUSH
43313: LD_EXP 82
43317: PPUSH
43318: LD_VAR 0 1
43322: PPUSH
43323: LD_EXP 82
43327: PUSH
43328: LD_VAR 0 1
43332: ARRAY
43333: PPUSH
43334: LD_EXP 82
43338: PUSH
43339: LD_VAR 0 1
43343: ARRAY
43344: PUSH
43345: LD_INT 1
43347: PLUS
43348: PPUSH
43349: LD_VAR 0 4
43353: PUSH
43354: LD_INT 1
43356: ARRAY
43357: PPUSH
43358: CALL_OW 2
43362: PPUSH
43363: CALL_OW 1
43367: ST_TO_ADDR
// end ;
43368: LD_VAR 0 3
43372: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
43373: LD_INT 0
43375: PPUSH
43376: PPUSH
// if not mc_bases or not base or not kinds then
43377: LD_EXP 50
43381: NOT
43382: PUSH
43383: LD_VAR 0 1
43387: NOT
43388: OR
43389: PUSH
43390: LD_VAR 0 2
43394: NOT
43395: OR
43396: IFFALSE 43400
// exit ;
43398: GO 43461
// for i in kinds do
43400: LD_ADDR_VAR 0 4
43404: PUSH
43405: LD_VAR 0 2
43409: PUSH
43410: FOR_IN
43411: IFFALSE 43459
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
43413: LD_ADDR_EXP 84
43417: PUSH
43418: LD_EXP 84
43422: PPUSH
43423: LD_VAR 0 1
43427: PUSH
43428: LD_EXP 84
43432: PUSH
43433: LD_VAR 0 1
43437: ARRAY
43438: PUSH
43439: LD_INT 1
43441: PLUS
43442: PUSH
43443: EMPTY
43444: LIST
43445: LIST
43446: PPUSH
43447: LD_VAR 0 4
43451: PPUSH
43452: CALL 54067 0 3
43456: ST_TO_ADDR
43457: GO 43410
43459: POP
43460: POP
// end ;
43461: LD_VAR 0 3
43465: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
43466: LD_INT 0
43468: PPUSH
// if not mc_bases or not base or not areas then
43469: LD_EXP 50
43473: NOT
43474: PUSH
43475: LD_VAR 0 1
43479: NOT
43480: OR
43481: PUSH
43482: LD_VAR 0 2
43486: NOT
43487: OR
43488: IFFALSE 43492
// exit ;
43490: GO 43517
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
43492: LD_ADDR_EXP 68
43496: PUSH
43497: LD_EXP 68
43501: PPUSH
43502: LD_VAR 0 1
43506: PPUSH
43507: LD_VAR 0 2
43511: PPUSH
43512: CALL_OW 1
43516: ST_TO_ADDR
// end ;
43517: LD_VAR 0 3
43521: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
43522: LD_INT 0
43524: PPUSH
// if not mc_bases or not base or not teleports_exit then
43525: LD_EXP 50
43529: NOT
43530: PUSH
43531: LD_VAR 0 1
43535: NOT
43536: OR
43537: PUSH
43538: LD_VAR 0 2
43542: NOT
43543: OR
43544: IFFALSE 43548
// exit ;
43546: GO 43573
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
43548: LD_ADDR_EXP 85
43552: PUSH
43553: LD_EXP 85
43557: PPUSH
43558: LD_VAR 0 1
43562: PPUSH
43563: LD_VAR 0 2
43567: PPUSH
43568: CALL_OW 1
43572: ST_TO_ADDR
// end ;
43573: LD_VAR 0 3
43577: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
43578: LD_INT 0
43580: PPUSH
43581: PPUSH
43582: PPUSH
// if not mc_bases or not base or not ext_list then
43583: LD_EXP 50
43587: NOT
43588: PUSH
43589: LD_VAR 0 1
43593: NOT
43594: OR
43595: PUSH
43596: LD_VAR 0 5
43600: NOT
43601: OR
43602: IFFALSE 43606
// exit ;
43604: GO 43779
// tmp := GetFacExtXYD ( x , y , d ) ;
43606: LD_ADDR_VAR 0 8
43610: PUSH
43611: LD_VAR 0 2
43615: PPUSH
43616: LD_VAR 0 3
43620: PPUSH
43621: LD_VAR 0 4
43625: PPUSH
43626: CALL 84441 0 3
43630: ST_TO_ADDR
// if not tmp then
43631: LD_VAR 0 8
43635: NOT
43636: IFFALSE 43640
// exit ;
43638: GO 43779
// for i in tmp do
43640: LD_ADDR_VAR 0 7
43644: PUSH
43645: LD_VAR 0 8
43649: PUSH
43650: FOR_IN
43651: IFFALSE 43777
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
43653: LD_ADDR_EXP 55
43657: PUSH
43658: LD_EXP 55
43662: PPUSH
43663: LD_VAR 0 1
43667: PPUSH
43668: LD_EXP 55
43672: PUSH
43673: LD_VAR 0 1
43677: ARRAY
43678: PPUSH
43679: LD_EXP 55
43683: PUSH
43684: LD_VAR 0 1
43688: ARRAY
43689: PUSH
43690: LD_INT 1
43692: PLUS
43693: PPUSH
43694: LD_VAR 0 5
43698: PUSH
43699: LD_INT 1
43701: ARRAY
43702: PUSH
43703: LD_VAR 0 7
43707: PUSH
43708: LD_INT 1
43710: ARRAY
43711: PUSH
43712: LD_VAR 0 7
43716: PUSH
43717: LD_INT 2
43719: ARRAY
43720: PUSH
43721: LD_VAR 0 7
43725: PUSH
43726: LD_INT 3
43728: ARRAY
43729: PUSH
43730: EMPTY
43731: LIST
43732: LIST
43733: LIST
43734: LIST
43735: PPUSH
43736: CALL_OW 2
43740: PPUSH
43741: CALL_OW 1
43745: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
43746: LD_ADDR_VAR 0 5
43750: PUSH
43751: LD_VAR 0 5
43755: PPUSH
43756: LD_INT 1
43758: PPUSH
43759: CALL_OW 3
43763: ST_TO_ADDR
// if not ext_list then
43764: LD_VAR 0 5
43768: NOT
43769: IFFALSE 43775
// exit ;
43771: POP
43772: POP
43773: GO 43779
// end ;
43775: GO 43650
43777: POP
43778: POP
// end ;
43779: LD_VAR 0 6
43783: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
43784: LD_INT 0
43786: PPUSH
// if not mc_bases or not base or not weapon_list then
43787: LD_EXP 50
43791: NOT
43792: PUSH
43793: LD_VAR 0 1
43797: NOT
43798: OR
43799: PUSH
43800: LD_VAR 0 2
43804: NOT
43805: OR
43806: IFFALSE 43810
// exit ;
43808: GO 43835
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
43810: LD_ADDR_EXP 89
43814: PUSH
43815: LD_EXP 89
43819: PPUSH
43820: LD_VAR 0 1
43824: PPUSH
43825: LD_VAR 0 2
43829: PPUSH
43830: CALL_OW 1
43834: ST_TO_ADDR
// end ;
43835: LD_VAR 0 3
43839: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
43840: LD_INT 0
43842: PPUSH
// if not mc_bases or not base or not tech_list then
43843: LD_EXP 50
43847: NOT
43848: PUSH
43849: LD_VAR 0 1
43853: NOT
43854: OR
43855: PUSH
43856: LD_VAR 0 2
43860: NOT
43861: OR
43862: IFFALSE 43866
// exit ;
43864: GO 43891
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
43866: LD_ADDR_EXP 77
43870: PUSH
43871: LD_EXP 77
43875: PPUSH
43876: LD_VAR 0 1
43880: PPUSH
43881: LD_VAR 0 2
43885: PPUSH
43886: CALL_OW 1
43890: ST_TO_ADDR
// end ;
43891: LD_VAR 0 3
43895: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
43896: LD_INT 0
43898: PPUSH
// if not mc_bases or not parking_area or not base then
43899: LD_EXP 50
43903: NOT
43904: PUSH
43905: LD_VAR 0 2
43909: NOT
43910: OR
43911: PUSH
43912: LD_VAR 0 1
43916: NOT
43917: OR
43918: IFFALSE 43922
// exit ;
43920: GO 43947
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
43922: LD_ADDR_EXP 74
43926: PUSH
43927: LD_EXP 74
43931: PPUSH
43932: LD_VAR 0 1
43936: PPUSH
43937: LD_VAR 0 2
43941: PPUSH
43942: CALL_OW 1
43946: ST_TO_ADDR
// end ;
43947: LD_VAR 0 3
43951: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
43952: LD_INT 0
43954: PPUSH
// if not mc_bases or not base or not scan_area then
43955: LD_EXP 50
43959: NOT
43960: PUSH
43961: LD_VAR 0 1
43965: NOT
43966: OR
43967: PUSH
43968: LD_VAR 0 2
43972: NOT
43973: OR
43974: IFFALSE 43978
// exit ;
43976: GO 44003
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
43978: LD_ADDR_EXP 75
43982: PUSH
43983: LD_EXP 75
43987: PPUSH
43988: LD_VAR 0 1
43992: PPUSH
43993: LD_VAR 0 2
43997: PPUSH
43998: CALL_OW 1
44002: ST_TO_ADDR
// end ;
44003: LD_VAR 0 3
44007: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
44008: LD_INT 0
44010: PPUSH
44011: PPUSH
// if not mc_bases or not base then
44012: LD_EXP 50
44016: NOT
44017: PUSH
44018: LD_VAR 0 1
44022: NOT
44023: OR
44024: IFFALSE 44028
// exit ;
44026: GO 44092
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
44028: LD_ADDR_VAR 0 3
44032: PUSH
44033: LD_INT 1
44035: PUSH
44036: LD_INT 2
44038: PUSH
44039: LD_INT 3
44041: PUSH
44042: LD_INT 4
44044: PUSH
44045: LD_INT 11
44047: PUSH
44048: EMPTY
44049: LIST
44050: LIST
44051: LIST
44052: LIST
44053: LIST
44054: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
44055: LD_ADDR_EXP 77
44059: PUSH
44060: LD_EXP 77
44064: PPUSH
44065: LD_VAR 0 1
44069: PPUSH
44070: LD_EXP 77
44074: PUSH
44075: LD_VAR 0 1
44079: ARRAY
44080: PUSH
44081: LD_VAR 0 3
44085: DIFF
44086: PPUSH
44087: CALL_OW 1
44091: ST_TO_ADDR
// end ;
44092: LD_VAR 0 2
44096: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
44097: LD_INT 0
44099: PPUSH
// result := mc_vehicles [ base ] ;
44100: LD_ADDR_VAR 0 3
44104: PUSH
44105: LD_EXP 69
44109: PUSH
44110: LD_VAR 0 1
44114: ARRAY
44115: ST_TO_ADDR
// if onlyCombat then
44116: LD_VAR 0 2
44120: IFFALSE 44292
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
44122: LD_ADDR_VAR 0 3
44126: PUSH
44127: LD_VAR 0 3
44131: PUSH
44132: LD_VAR 0 3
44136: PPUSH
44137: LD_INT 2
44139: PUSH
44140: LD_INT 34
44142: PUSH
44143: LD_INT 12
44145: PUSH
44146: EMPTY
44147: LIST
44148: LIST
44149: PUSH
44150: LD_INT 34
44152: PUSH
44153: LD_INT 51
44155: PUSH
44156: EMPTY
44157: LIST
44158: LIST
44159: PUSH
44160: LD_INT 34
44162: PUSH
44163: LD_INT 89
44165: PUSH
44166: EMPTY
44167: LIST
44168: LIST
44169: PUSH
44170: LD_INT 34
44172: PUSH
44173: LD_INT 32
44175: PUSH
44176: EMPTY
44177: LIST
44178: LIST
44179: PUSH
44180: LD_INT 34
44182: PUSH
44183: LD_INT 13
44185: PUSH
44186: EMPTY
44187: LIST
44188: LIST
44189: PUSH
44190: LD_INT 34
44192: PUSH
44193: LD_INT 52
44195: PUSH
44196: EMPTY
44197: LIST
44198: LIST
44199: PUSH
44200: LD_INT 34
44202: PUSH
44203: LD_INT 88
44205: PUSH
44206: EMPTY
44207: LIST
44208: LIST
44209: PUSH
44210: LD_INT 34
44212: PUSH
44213: LD_INT 14
44215: PUSH
44216: EMPTY
44217: LIST
44218: LIST
44219: PUSH
44220: LD_INT 34
44222: PUSH
44223: LD_INT 53
44225: PUSH
44226: EMPTY
44227: LIST
44228: LIST
44229: PUSH
44230: LD_INT 34
44232: PUSH
44233: LD_INT 98
44235: PUSH
44236: EMPTY
44237: LIST
44238: LIST
44239: PUSH
44240: LD_INT 34
44242: PUSH
44243: LD_INT 31
44245: PUSH
44246: EMPTY
44247: LIST
44248: LIST
44249: PUSH
44250: LD_INT 34
44252: PUSH
44253: LD_INT 48
44255: PUSH
44256: EMPTY
44257: LIST
44258: LIST
44259: PUSH
44260: LD_INT 34
44262: PUSH
44263: LD_INT 8
44265: PUSH
44266: EMPTY
44267: LIST
44268: LIST
44269: PUSH
44270: EMPTY
44271: LIST
44272: LIST
44273: LIST
44274: LIST
44275: LIST
44276: LIST
44277: LIST
44278: LIST
44279: LIST
44280: LIST
44281: LIST
44282: LIST
44283: LIST
44284: LIST
44285: PPUSH
44286: CALL_OW 72
44290: DIFF
44291: ST_TO_ADDR
// end ; end_of_file
44292: LD_VAR 0 3
44296: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
44297: LD_INT 0
44299: PPUSH
44300: PPUSH
44301: PPUSH
// if not mc_bases or not skirmish then
44302: LD_EXP 50
44306: NOT
44307: PUSH
44308: LD_EXP 48
44312: NOT
44313: OR
44314: IFFALSE 44318
// exit ;
44316: GO 44483
// for i = 1 to mc_bases do
44318: LD_ADDR_VAR 0 4
44322: PUSH
44323: DOUBLE
44324: LD_INT 1
44326: DEC
44327: ST_TO_ADDR
44328: LD_EXP 50
44332: PUSH
44333: FOR_TO
44334: IFFALSE 44481
// begin if sci in mc_bases [ i ] then
44336: LD_VAR 0 2
44340: PUSH
44341: LD_EXP 50
44345: PUSH
44346: LD_VAR 0 4
44350: ARRAY
44351: IN
44352: IFFALSE 44479
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
44354: LD_ADDR_EXP 79
44358: PUSH
44359: LD_EXP 79
44363: PPUSH
44364: LD_VAR 0 4
44368: PUSH
44369: LD_EXP 79
44373: PUSH
44374: LD_VAR 0 4
44378: ARRAY
44379: PUSH
44380: LD_INT 1
44382: PLUS
44383: PUSH
44384: EMPTY
44385: LIST
44386: LIST
44387: PPUSH
44388: LD_VAR 0 1
44392: PPUSH
44393: CALL 54067 0 3
44397: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
44398: LD_ADDR_VAR 0 5
44402: PUSH
44403: LD_EXP 50
44407: PUSH
44408: LD_VAR 0 4
44412: ARRAY
44413: PPUSH
44414: LD_INT 2
44416: PUSH
44417: LD_INT 30
44419: PUSH
44420: LD_INT 0
44422: PUSH
44423: EMPTY
44424: LIST
44425: LIST
44426: PUSH
44427: LD_INT 30
44429: PUSH
44430: LD_INT 1
44432: PUSH
44433: EMPTY
44434: LIST
44435: LIST
44436: PUSH
44437: EMPTY
44438: LIST
44439: LIST
44440: LIST
44441: PPUSH
44442: CALL_OW 72
44446: PPUSH
44447: LD_VAR 0 1
44451: PPUSH
44452: CALL_OW 74
44456: ST_TO_ADDR
// if tmp then
44457: LD_VAR 0 5
44461: IFFALSE 44477
// ComStandNearbyBuilding ( ape , tmp ) ;
44463: LD_VAR 0 1
44467: PPUSH
44468: LD_VAR 0 5
44472: PPUSH
44473: CALL 50669 0 2
// break ;
44477: GO 44481
// end ; end ;
44479: GO 44333
44481: POP
44482: POP
// end ;
44483: LD_VAR 0 3
44487: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
44488: LD_INT 0
44490: PPUSH
44491: PPUSH
44492: PPUSH
// if not mc_bases or not skirmish then
44493: LD_EXP 50
44497: NOT
44498: PUSH
44499: LD_EXP 48
44503: NOT
44504: OR
44505: IFFALSE 44509
// exit ;
44507: GO 44598
// for i = 1 to mc_bases do
44509: LD_ADDR_VAR 0 4
44513: PUSH
44514: DOUBLE
44515: LD_INT 1
44517: DEC
44518: ST_TO_ADDR
44519: LD_EXP 50
44523: PUSH
44524: FOR_TO
44525: IFFALSE 44596
// begin if building in mc_busy_turret_list [ i ] then
44527: LD_VAR 0 1
44531: PUSH
44532: LD_EXP 60
44536: PUSH
44537: LD_VAR 0 4
44541: ARRAY
44542: IN
44543: IFFALSE 44594
// begin tmp := mc_busy_turret_list [ i ] diff building ;
44545: LD_ADDR_VAR 0 5
44549: PUSH
44550: LD_EXP 60
44554: PUSH
44555: LD_VAR 0 4
44559: ARRAY
44560: PUSH
44561: LD_VAR 0 1
44565: DIFF
44566: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
44567: LD_ADDR_EXP 60
44571: PUSH
44572: LD_EXP 60
44576: PPUSH
44577: LD_VAR 0 4
44581: PPUSH
44582: LD_VAR 0 5
44586: PPUSH
44587: CALL_OW 1
44591: ST_TO_ADDR
// break ;
44592: GO 44596
// end ; end ;
44594: GO 44524
44596: POP
44597: POP
// end ;
44598: LD_VAR 0 3
44602: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
44603: LD_INT 0
44605: PPUSH
44606: PPUSH
44607: PPUSH
// if not mc_bases or not skirmish then
44608: LD_EXP 50
44612: NOT
44613: PUSH
44614: LD_EXP 48
44618: NOT
44619: OR
44620: IFFALSE 44624
// exit ;
44622: GO 44823
// for i = 1 to mc_bases do
44624: LD_ADDR_VAR 0 5
44628: PUSH
44629: DOUBLE
44630: LD_INT 1
44632: DEC
44633: ST_TO_ADDR
44634: LD_EXP 50
44638: PUSH
44639: FOR_TO
44640: IFFALSE 44821
// if building in mc_bases [ i ] then
44642: LD_VAR 0 1
44646: PUSH
44647: LD_EXP 50
44651: PUSH
44652: LD_VAR 0 5
44656: ARRAY
44657: IN
44658: IFFALSE 44819
// begin tmp := mc_bases [ i ] diff building ;
44660: LD_ADDR_VAR 0 6
44664: PUSH
44665: LD_EXP 50
44669: PUSH
44670: LD_VAR 0 5
44674: ARRAY
44675: PUSH
44676: LD_VAR 0 1
44680: DIFF
44681: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
44682: LD_ADDR_EXP 50
44686: PUSH
44687: LD_EXP 50
44691: PPUSH
44692: LD_VAR 0 5
44696: PPUSH
44697: LD_VAR 0 6
44701: PPUSH
44702: CALL_OW 1
44706: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
44707: LD_VAR 0 1
44711: PUSH
44712: LD_EXP 58
44716: PUSH
44717: LD_VAR 0 5
44721: ARRAY
44722: IN
44723: IFFALSE 44762
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
44725: LD_ADDR_EXP 58
44729: PUSH
44730: LD_EXP 58
44734: PPUSH
44735: LD_VAR 0 5
44739: PPUSH
44740: LD_EXP 58
44744: PUSH
44745: LD_VAR 0 5
44749: ARRAY
44750: PUSH
44751: LD_VAR 0 1
44755: DIFF
44756: PPUSH
44757: CALL_OW 1
44761: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
44762: LD_VAR 0 1
44766: PUSH
44767: LD_EXP 59
44771: PUSH
44772: LD_VAR 0 5
44776: ARRAY
44777: IN
44778: IFFALSE 44817
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
44780: LD_ADDR_EXP 59
44784: PUSH
44785: LD_EXP 59
44789: PPUSH
44790: LD_VAR 0 5
44794: PPUSH
44795: LD_EXP 59
44799: PUSH
44800: LD_VAR 0 5
44804: ARRAY
44805: PUSH
44806: LD_VAR 0 1
44810: DIFF
44811: PPUSH
44812: CALL_OW 1
44816: ST_TO_ADDR
// break ;
44817: GO 44821
// end ;
44819: GO 44639
44821: POP
44822: POP
// end ;
44823: LD_VAR 0 4
44827: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
44828: LD_INT 0
44830: PPUSH
44831: PPUSH
44832: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
44833: LD_EXP 50
44837: NOT
44838: PUSH
44839: LD_EXP 48
44843: NOT
44844: OR
44845: PUSH
44846: LD_VAR 0 3
44850: PUSH
44851: LD_EXP 76
44855: IN
44856: NOT
44857: OR
44858: IFFALSE 44862
// exit ;
44860: GO 44985
// for i = 1 to mc_vehicles do
44862: LD_ADDR_VAR 0 6
44866: PUSH
44867: DOUBLE
44868: LD_INT 1
44870: DEC
44871: ST_TO_ADDR
44872: LD_EXP 69
44876: PUSH
44877: FOR_TO
44878: IFFALSE 44983
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
44880: LD_VAR 0 2
44884: PUSH
44885: LD_EXP 69
44889: PUSH
44890: LD_VAR 0 6
44894: ARRAY
44895: IN
44896: PUSH
44897: LD_VAR 0 1
44901: PUSH
44902: LD_EXP 69
44906: PUSH
44907: LD_VAR 0 6
44911: ARRAY
44912: IN
44913: OR
44914: IFFALSE 44981
// begin tmp := mc_vehicles [ i ] diff old ;
44916: LD_ADDR_VAR 0 7
44920: PUSH
44921: LD_EXP 69
44925: PUSH
44926: LD_VAR 0 6
44930: ARRAY
44931: PUSH
44932: LD_VAR 0 2
44936: DIFF
44937: ST_TO_ADDR
// tmp := tmp diff new ;
44938: LD_ADDR_VAR 0 7
44942: PUSH
44943: LD_VAR 0 7
44947: PUSH
44948: LD_VAR 0 1
44952: DIFF
44953: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
44954: LD_ADDR_EXP 69
44958: PUSH
44959: LD_EXP 69
44963: PPUSH
44964: LD_VAR 0 6
44968: PPUSH
44969: LD_VAR 0 7
44973: PPUSH
44974: CALL_OW 1
44978: ST_TO_ADDR
// break ;
44979: GO 44983
// end ;
44981: GO 44877
44983: POP
44984: POP
// end ;
44985: LD_VAR 0 5
44989: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
44990: LD_INT 0
44992: PPUSH
44993: PPUSH
44994: PPUSH
44995: PPUSH
// if not mc_bases or not skirmish then
44996: LD_EXP 50
45000: NOT
45001: PUSH
45002: LD_EXP 48
45006: NOT
45007: OR
45008: IFFALSE 45012
// exit ;
45010: GO 45432
// repeat wait ( 0 0$1 ) ;
45012: LD_INT 35
45014: PPUSH
45015: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
45019: LD_EXP 94
45023: NOT
45024: IFFALSE 45012
// mc_block_vehicle_constructed_thread := true ;
45026: LD_ADDR_EXP 94
45030: PUSH
45031: LD_INT 1
45033: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
45034: LD_ADDR_VAR 0 5
45038: PUSH
45039: LD_VAR 0 1
45043: PPUSH
45044: CALL_OW 255
45048: ST_TO_ADDR
// for i = 1 to mc_bases do
45049: LD_ADDR_VAR 0 4
45053: PUSH
45054: DOUBLE
45055: LD_INT 1
45057: DEC
45058: ST_TO_ADDR
45059: LD_EXP 50
45063: PUSH
45064: FOR_TO
45065: IFFALSE 45422
// begin if factory in mc_bases [ i ] then
45067: LD_VAR 0 2
45071: PUSH
45072: LD_EXP 50
45076: PUSH
45077: LD_VAR 0 4
45081: ARRAY
45082: IN
45083: IFFALSE 45420
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
45085: LD_EXP 72
45089: PUSH
45090: LD_VAR 0 4
45094: ARRAY
45095: PUSH
45096: LD_EXP 61
45100: PUSH
45101: LD_VAR 0 4
45105: ARRAY
45106: LESS
45107: PUSH
45108: LD_VAR 0 1
45112: PPUSH
45113: CALL_OW 264
45117: PUSH
45118: LD_INT 31
45120: PUSH
45121: LD_INT 32
45123: PUSH
45124: LD_INT 51
45126: PUSH
45127: LD_INT 89
45129: PUSH
45130: LD_INT 12
45132: PUSH
45133: LD_INT 30
45135: PUSH
45136: LD_INT 98
45138: PUSH
45139: LD_INT 11
45141: PUSH
45142: LD_INT 53
45144: PUSH
45145: LD_INT 14
45147: PUSH
45148: LD_INT 91
45150: PUSH
45151: LD_INT 29
45153: PUSH
45154: LD_INT 99
45156: PUSH
45157: LD_INT 13
45159: PUSH
45160: LD_INT 52
45162: PUSH
45163: LD_INT 88
45165: PUSH
45166: LD_INT 48
45168: PUSH
45169: LD_INT 8
45171: PUSH
45172: EMPTY
45173: LIST
45174: LIST
45175: LIST
45176: LIST
45177: LIST
45178: LIST
45179: LIST
45180: LIST
45181: LIST
45182: LIST
45183: LIST
45184: LIST
45185: LIST
45186: LIST
45187: LIST
45188: LIST
45189: LIST
45190: LIST
45191: IN
45192: NOT
45193: AND
45194: IFFALSE 45242
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
45196: LD_ADDR_EXP 72
45200: PUSH
45201: LD_EXP 72
45205: PPUSH
45206: LD_VAR 0 4
45210: PUSH
45211: LD_EXP 72
45215: PUSH
45216: LD_VAR 0 4
45220: ARRAY
45221: PUSH
45222: LD_INT 1
45224: PLUS
45225: PUSH
45226: EMPTY
45227: LIST
45228: LIST
45229: PPUSH
45230: LD_VAR 0 1
45234: PPUSH
45235: CALL 54067 0 3
45239: ST_TO_ADDR
45240: GO 45286
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
45242: LD_ADDR_EXP 69
45246: PUSH
45247: LD_EXP 69
45251: PPUSH
45252: LD_VAR 0 4
45256: PUSH
45257: LD_EXP 69
45261: PUSH
45262: LD_VAR 0 4
45266: ARRAY
45267: PUSH
45268: LD_INT 1
45270: PLUS
45271: PUSH
45272: EMPTY
45273: LIST
45274: LIST
45275: PPUSH
45276: LD_VAR 0 1
45280: PPUSH
45281: CALL 54067 0 3
45285: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
45286: LD_ADDR_EXP 94
45290: PUSH
45291: LD_INT 0
45293: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
45294: LD_VAR 0 1
45298: PPUSH
45299: CALL_OW 263
45303: PUSH
45304: LD_INT 2
45306: EQUAL
45307: IFFALSE 45336
// begin repeat wait ( 0 0$3 ) ;
45309: LD_INT 105
45311: PPUSH
45312: CALL_OW 67
// Connect ( vehicle ) ;
45316: LD_VAR 0 1
45320: PPUSH
45321: CALL 57413 0 1
// until IsControledBy ( vehicle ) ;
45325: LD_VAR 0 1
45329: PPUSH
45330: CALL_OW 312
45334: IFFALSE 45309
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
45336: LD_VAR 0 1
45340: PPUSH
45341: LD_EXP 74
45345: PUSH
45346: LD_VAR 0 4
45350: ARRAY
45351: PPUSH
45352: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
45356: LD_VAR 0 1
45360: PPUSH
45361: CALL_OW 263
45365: PUSH
45366: LD_INT 1
45368: NONEQUAL
45369: IFFALSE 45373
// break ;
45371: GO 45422
// repeat wait ( 0 0$1 ) ;
45373: LD_INT 35
45375: PPUSH
45376: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
45380: LD_VAR 0 1
45384: PPUSH
45385: LD_EXP 74
45389: PUSH
45390: LD_VAR 0 4
45394: ARRAY
45395: PPUSH
45396: CALL_OW 308
45400: IFFALSE 45373
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
45402: LD_VAR 0 1
45406: PPUSH
45407: CALL_OW 311
45411: PPUSH
45412: CALL_OW 121
// exit ;
45416: POP
45417: POP
45418: GO 45432
// end ; end ;
45420: GO 45064
45422: POP
45423: POP
// mc_block_vehicle_constructed_thread := false ;
45424: LD_ADDR_EXP 94
45428: PUSH
45429: LD_INT 0
45431: ST_TO_ADDR
// end ;
45432: LD_VAR 0 3
45436: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
45437: LD_INT 0
45439: PPUSH
45440: PPUSH
45441: PPUSH
45442: PPUSH
// if not mc_bases or not skirmish then
45443: LD_EXP 50
45447: NOT
45448: PUSH
45449: LD_EXP 48
45453: NOT
45454: OR
45455: IFFALSE 45459
// exit ;
45457: GO 45812
// repeat wait ( 0 0$1 ) ;
45459: LD_INT 35
45461: PPUSH
45462: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
45466: LD_VAR 0 2
45470: PPUSH
45471: LD_VAR 0 3
45475: PPUSH
45476: CALL_OW 284
45480: IFFALSE 45459
// if GetResourceTypeXY ( x , y ) = mat_artefact then
45482: LD_VAR 0 2
45486: PPUSH
45487: LD_VAR 0 3
45491: PPUSH
45492: CALL_OW 283
45496: PUSH
45497: LD_INT 4
45499: EQUAL
45500: IFFALSE 45504
// exit ;
45502: GO 45812
// for i = 1 to mc_bases do
45504: LD_ADDR_VAR 0 7
45508: PUSH
45509: DOUBLE
45510: LD_INT 1
45512: DEC
45513: ST_TO_ADDR
45514: LD_EXP 50
45518: PUSH
45519: FOR_TO
45520: IFFALSE 45810
// begin if mc_crates_area [ i ] then
45522: LD_EXP 68
45526: PUSH
45527: LD_VAR 0 7
45531: ARRAY
45532: IFFALSE 45643
// for j in mc_crates_area [ i ] do
45534: LD_ADDR_VAR 0 8
45538: PUSH
45539: LD_EXP 68
45543: PUSH
45544: LD_VAR 0 7
45548: ARRAY
45549: PUSH
45550: FOR_IN
45551: IFFALSE 45641
// if InArea ( x , y , j ) then
45553: LD_VAR 0 2
45557: PPUSH
45558: LD_VAR 0 3
45562: PPUSH
45563: LD_VAR 0 8
45567: PPUSH
45568: CALL_OW 309
45572: IFFALSE 45639
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
45574: LD_ADDR_EXP 66
45578: PUSH
45579: LD_EXP 66
45583: PPUSH
45584: LD_VAR 0 7
45588: PUSH
45589: LD_EXP 66
45593: PUSH
45594: LD_VAR 0 7
45598: ARRAY
45599: PUSH
45600: LD_INT 1
45602: PLUS
45603: PUSH
45604: EMPTY
45605: LIST
45606: LIST
45607: PPUSH
45608: LD_VAR 0 4
45612: PUSH
45613: LD_VAR 0 2
45617: PUSH
45618: LD_VAR 0 3
45622: PUSH
45623: EMPTY
45624: LIST
45625: LIST
45626: LIST
45627: PPUSH
45628: CALL 54067 0 3
45632: ST_TO_ADDR
// exit ;
45633: POP
45634: POP
45635: POP
45636: POP
45637: GO 45812
// end ;
45639: GO 45550
45641: POP
45642: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
45643: LD_ADDR_VAR 0 9
45647: PUSH
45648: LD_EXP 50
45652: PUSH
45653: LD_VAR 0 7
45657: ARRAY
45658: PPUSH
45659: LD_INT 2
45661: PUSH
45662: LD_INT 30
45664: PUSH
45665: LD_INT 0
45667: PUSH
45668: EMPTY
45669: LIST
45670: LIST
45671: PUSH
45672: LD_INT 30
45674: PUSH
45675: LD_INT 1
45677: PUSH
45678: EMPTY
45679: LIST
45680: LIST
45681: PUSH
45682: EMPTY
45683: LIST
45684: LIST
45685: LIST
45686: PPUSH
45687: CALL_OW 72
45691: ST_TO_ADDR
// if not depot then
45692: LD_VAR 0 9
45696: NOT
45697: IFFALSE 45701
// continue ;
45699: GO 45519
// for j in depot do
45701: LD_ADDR_VAR 0 8
45705: PUSH
45706: LD_VAR 0 9
45710: PUSH
45711: FOR_IN
45712: IFFALSE 45806
// if GetDistUnitXY ( j , x , y ) < 30 then
45714: LD_VAR 0 8
45718: PPUSH
45719: LD_VAR 0 2
45723: PPUSH
45724: LD_VAR 0 3
45728: PPUSH
45729: CALL_OW 297
45733: PUSH
45734: LD_INT 30
45736: LESS
45737: IFFALSE 45804
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
45739: LD_ADDR_EXP 66
45743: PUSH
45744: LD_EXP 66
45748: PPUSH
45749: LD_VAR 0 7
45753: PUSH
45754: LD_EXP 66
45758: PUSH
45759: LD_VAR 0 7
45763: ARRAY
45764: PUSH
45765: LD_INT 1
45767: PLUS
45768: PUSH
45769: EMPTY
45770: LIST
45771: LIST
45772: PPUSH
45773: LD_VAR 0 4
45777: PUSH
45778: LD_VAR 0 2
45782: PUSH
45783: LD_VAR 0 3
45787: PUSH
45788: EMPTY
45789: LIST
45790: LIST
45791: LIST
45792: PPUSH
45793: CALL 54067 0 3
45797: ST_TO_ADDR
// exit ;
45798: POP
45799: POP
45800: POP
45801: POP
45802: GO 45812
// end ;
45804: GO 45711
45806: POP
45807: POP
// end ;
45808: GO 45519
45810: POP
45811: POP
// end ;
45812: LD_VAR 0 6
45816: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
45817: LD_INT 0
45819: PPUSH
45820: PPUSH
45821: PPUSH
45822: PPUSH
// if not mc_bases or not skirmish then
45823: LD_EXP 50
45827: NOT
45828: PUSH
45829: LD_EXP 48
45833: NOT
45834: OR
45835: IFFALSE 45839
// exit ;
45837: GO 46116
// side := GetSide ( lab ) ;
45839: LD_ADDR_VAR 0 4
45843: PUSH
45844: LD_VAR 0 2
45848: PPUSH
45849: CALL_OW 255
45853: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
45854: LD_VAR 0 4
45858: PUSH
45859: LD_EXP 76
45863: IN
45864: NOT
45865: PUSH
45866: LD_EXP 77
45870: NOT
45871: OR
45872: PUSH
45873: LD_EXP 50
45877: NOT
45878: OR
45879: IFFALSE 45883
// exit ;
45881: GO 46116
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
45883: LD_ADDR_EXP 77
45887: PUSH
45888: LD_EXP 77
45892: PPUSH
45893: LD_VAR 0 4
45897: PPUSH
45898: LD_EXP 77
45902: PUSH
45903: LD_VAR 0 4
45907: ARRAY
45908: PUSH
45909: LD_VAR 0 1
45913: DIFF
45914: PPUSH
45915: CALL_OW 1
45919: ST_TO_ADDR
// for i = 1 to mc_bases do
45920: LD_ADDR_VAR 0 5
45924: PUSH
45925: DOUBLE
45926: LD_INT 1
45928: DEC
45929: ST_TO_ADDR
45930: LD_EXP 50
45934: PUSH
45935: FOR_TO
45936: IFFALSE 46114
// begin if lab in mc_bases [ i ] then
45938: LD_VAR 0 2
45942: PUSH
45943: LD_EXP 50
45947: PUSH
45948: LD_VAR 0 5
45952: ARRAY
45953: IN
45954: IFFALSE 46112
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
45956: LD_VAR 0 1
45960: PUSH
45961: LD_INT 11
45963: PUSH
45964: LD_INT 4
45966: PUSH
45967: LD_INT 3
45969: PUSH
45970: LD_INT 2
45972: PUSH
45973: EMPTY
45974: LIST
45975: LIST
45976: LIST
45977: LIST
45978: IN
45979: PUSH
45980: LD_EXP 80
45984: PUSH
45985: LD_VAR 0 5
45989: ARRAY
45990: AND
45991: IFFALSE 46112
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
45993: LD_ADDR_VAR 0 6
45997: PUSH
45998: LD_EXP 80
46002: PUSH
46003: LD_VAR 0 5
46007: ARRAY
46008: PUSH
46009: LD_INT 1
46011: ARRAY
46012: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
46013: LD_ADDR_EXP 80
46017: PUSH
46018: LD_EXP 80
46022: PPUSH
46023: LD_VAR 0 5
46027: PPUSH
46028: EMPTY
46029: PPUSH
46030: CALL_OW 1
46034: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
46035: LD_VAR 0 6
46039: PPUSH
46040: LD_INT 0
46042: PPUSH
46043: CALL_OW 109
// ComExitBuilding ( tmp ) ;
46047: LD_VAR 0 6
46051: PPUSH
46052: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
46056: LD_ADDR_EXP 79
46060: PUSH
46061: LD_EXP 79
46065: PPUSH
46066: LD_VAR 0 5
46070: PPUSH
46071: LD_EXP 79
46075: PUSH
46076: LD_VAR 0 5
46080: ARRAY
46081: PPUSH
46082: LD_INT 1
46084: PPUSH
46085: LD_VAR 0 6
46089: PPUSH
46090: CALL_OW 2
46094: PPUSH
46095: CALL_OW 1
46099: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
46100: LD_VAR 0 5
46104: PPUSH
46105: LD_INT 112
46107: PPUSH
46108: CALL 22566 0 2
// end ; end ; end ;
46112: GO 45935
46114: POP
46115: POP
// end ;
46116: LD_VAR 0 3
46120: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
46121: LD_INT 0
46123: PPUSH
46124: PPUSH
46125: PPUSH
46126: PPUSH
46127: PPUSH
46128: PPUSH
46129: PPUSH
46130: PPUSH
// if not mc_bases or not skirmish then
46131: LD_EXP 50
46135: NOT
46136: PUSH
46137: LD_EXP 48
46141: NOT
46142: OR
46143: IFFALSE 46147
// exit ;
46145: GO 47516
// for i = 1 to mc_bases do
46147: LD_ADDR_VAR 0 3
46151: PUSH
46152: DOUBLE
46153: LD_INT 1
46155: DEC
46156: ST_TO_ADDR
46157: LD_EXP 50
46161: PUSH
46162: FOR_TO
46163: IFFALSE 47514
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
46165: LD_VAR 0 1
46169: PUSH
46170: LD_EXP 50
46174: PUSH
46175: LD_VAR 0 3
46179: ARRAY
46180: IN
46181: PUSH
46182: LD_VAR 0 1
46186: PUSH
46187: LD_EXP 57
46191: PUSH
46192: LD_VAR 0 3
46196: ARRAY
46197: IN
46198: OR
46199: PUSH
46200: LD_VAR 0 1
46204: PUSH
46205: LD_EXP 72
46209: PUSH
46210: LD_VAR 0 3
46214: ARRAY
46215: IN
46216: OR
46217: PUSH
46218: LD_VAR 0 1
46222: PUSH
46223: LD_EXP 69
46227: PUSH
46228: LD_VAR 0 3
46232: ARRAY
46233: IN
46234: OR
46235: PUSH
46236: LD_VAR 0 1
46240: PUSH
46241: LD_EXP 79
46245: PUSH
46246: LD_VAR 0 3
46250: ARRAY
46251: IN
46252: OR
46253: PUSH
46254: LD_VAR 0 1
46258: PUSH
46259: LD_EXP 80
46263: PUSH
46264: LD_VAR 0 3
46268: ARRAY
46269: IN
46270: OR
46271: IFFALSE 47512
// begin if un in mc_ape [ i ] then
46273: LD_VAR 0 1
46277: PUSH
46278: LD_EXP 79
46282: PUSH
46283: LD_VAR 0 3
46287: ARRAY
46288: IN
46289: IFFALSE 46328
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
46291: LD_ADDR_EXP 79
46295: PUSH
46296: LD_EXP 79
46300: PPUSH
46301: LD_VAR 0 3
46305: PPUSH
46306: LD_EXP 79
46310: PUSH
46311: LD_VAR 0 3
46315: ARRAY
46316: PUSH
46317: LD_VAR 0 1
46321: DIFF
46322: PPUSH
46323: CALL_OW 1
46327: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
46328: LD_VAR 0 1
46332: PUSH
46333: LD_EXP 80
46337: PUSH
46338: LD_VAR 0 3
46342: ARRAY
46343: IN
46344: IFFALSE 46368
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
46346: LD_ADDR_EXP 80
46350: PUSH
46351: LD_EXP 80
46355: PPUSH
46356: LD_VAR 0 3
46360: PPUSH
46361: EMPTY
46362: PPUSH
46363: CALL_OW 1
46367: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
46368: LD_VAR 0 1
46372: PPUSH
46373: CALL_OW 247
46377: PUSH
46378: LD_INT 2
46380: EQUAL
46381: PUSH
46382: LD_VAR 0 1
46386: PPUSH
46387: CALL_OW 110
46391: PUSH
46392: LD_INT 20
46394: EQUAL
46395: PUSH
46396: LD_VAR 0 1
46400: PUSH
46401: LD_EXP 72
46405: PUSH
46406: LD_VAR 0 3
46410: ARRAY
46411: IN
46412: OR
46413: PUSH
46414: LD_VAR 0 1
46418: PPUSH
46419: CALL_OW 264
46423: PUSH
46424: LD_INT 12
46426: PUSH
46427: LD_INT 51
46429: PUSH
46430: LD_INT 89
46432: PUSH
46433: LD_INT 32
46435: PUSH
46436: LD_INT 13
46438: PUSH
46439: LD_INT 52
46441: PUSH
46442: LD_INT 31
46444: PUSH
46445: EMPTY
46446: LIST
46447: LIST
46448: LIST
46449: LIST
46450: LIST
46451: LIST
46452: LIST
46453: IN
46454: OR
46455: AND
46456: IFFALSE 46764
// begin if un in mc_defender [ i ] then
46458: LD_VAR 0 1
46462: PUSH
46463: LD_EXP 72
46467: PUSH
46468: LD_VAR 0 3
46472: ARRAY
46473: IN
46474: IFFALSE 46513
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
46476: LD_ADDR_EXP 72
46480: PUSH
46481: LD_EXP 72
46485: PPUSH
46486: LD_VAR 0 3
46490: PPUSH
46491: LD_EXP 72
46495: PUSH
46496: LD_VAR 0 3
46500: ARRAY
46501: PUSH
46502: LD_VAR 0 1
46506: DIFF
46507: PPUSH
46508: CALL_OW 1
46512: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
46513: LD_ADDR_VAR 0 8
46517: PUSH
46518: LD_VAR 0 3
46522: PPUSH
46523: LD_INT 3
46525: PPUSH
46526: CALL 43134 0 2
46530: ST_TO_ADDR
// if fac then
46531: LD_VAR 0 8
46535: IFFALSE 46764
// begin for j in fac do
46537: LD_ADDR_VAR 0 4
46541: PUSH
46542: LD_VAR 0 8
46546: PUSH
46547: FOR_IN
46548: IFFALSE 46762
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
46550: LD_ADDR_VAR 0 9
46554: PUSH
46555: LD_VAR 0 8
46559: PPUSH
46560: LD_VAR 0 1
46564: PPUSH
46565: CALL_OW 265
46569: PPUSH
46570: LD_VAR 0 1
46574: PPUSH
46575: CALL_OW 262
46579: PPUSH
46580: LD_VAR 0 1
46584: PPUSH
46585: CALL_OW 263
46589: PPUSH
46590: LD_VAR 0 1
46594: PPUSH
46595: CALL_OW 264
46599: PPUSH
46600: CALL 51565 0 5
46604: ST_TO_ADDR
// if components then
46605: LD_VAR 0 9
46609: IFFALSE 46760
// begin if GetWeapon ( un ) = ar_control_tower then
46611: LD_VAR 0 1
46615: PPUSH
46616: CALL_OW 264
46620: PUSH
46621: LD_INT 31
46623: EQUAL
46624: IFFALSE 46741
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
46626: LD_VAR 0 1
46630: PPUSH
46631: CALL_OW 311
46635: PPUSH
46636: LD_INT 0
46638: PPUSH
46639: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
46643: LD_ADDR_EXP 90
46647: PUSH
46648: LD_EXP 90
46652: PPUSH
46653: LD_VAR 0 3
46657: PPUSH
46658: LD_EXP 90
46662: PUSH
46663: LD_VAR 0 3
46667: ARRAY
46668: PUSH
46669: LD_VAR 0 1
46673: PPUSH
46674: CALL_OW 311
46678: DIFF
46679: PPUSH
46680: CALL_OW 1
46684: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
46685: LD_ADDR_VAR 0 7
46689: PUSH
46690: LD_EXP 71
46694: PUSH
46695: LD_VAR 0 3
46699: ARRAY
46700: PPUSH
46701: LD_INT 1
46703: PPUSH
46704: LD_VAR 0 9
46708: PPUSH
46709: CALL_OW 2
46713: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
46714: LD_ADDR_EXP 71
46718: PUSH
46719: LD_EXP 71
46723: PPUSH
46724: LD_VAR 0 3
46728: PPUSH
46729: LD_VAR 0 7
46733: PPUSH
46734: CALL_OW 1
46738: ST_TO_ADDR
// end else
46739: GO 46758
// MC_InsertProduceList ( i , [ components ] ) ;
46741: LD_VAR 0 3
46745: PPUSH
46746: LD_VAR 0 9
46750: PUSH
46751: EMPTY
46752: LIST
46753: PPUSH
46754: CALL 42679 0 2
// break ;
46758: GO 46762
// end ; end ;
46760: GO 46547
46762: POP
46763: POP
// end ; end ; if GetType ( un ) = unit_building then
46764: LD_VAR 0 1
46768: PPUSH
46769: CALL_OW 247
46773: PUSH
46774: LD_INT 3
46776: EQUAL
46777: IFFALSE 47180
// begin btype := GetBType ( un ) ;
46779: LD_ADDR_VAR 0 5
46783: PUSH
46784: LD_VAR 0 1
46788: PPUSH
46789: CALL_OW 266
46793: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
46794: LD_VAR 0 5
46798: PUSH
46799: LD_INT 29
46801: PUSH
46802: LD_INT 30
46804: PUSH
46805: EMPTY
46806: LIST
46807: LIST
46808: IN
46809: IFFALSE 46882
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
46811: LD_VAR 0 1
46815: PPUSH
46816: CALL_OW 250
46820: PPUSH
46821: LD_VAR 0 1
46825: PPUSH
46826: CALL_OW 251
46830: PPUSH
46831: LD_VAR 0 1
46835: PPUSH
46836: CALL_OW 255
46840: PPUSH
46841: CALL_OW 440
46845: NOT
46846: IFFALSE 46882
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
46848: LD_VAR 0 1
46852: PPUSH
46853: CALL_OW 250
46857: PPUSH
46858: LD_VAR 0 1
46862: PPUSH
46863: CALL_OW 251
46867: PPUSH
46868: LD_VAR 0 1
46872: PPUSH
46873: CALL_OW 255
46877: PPUSH
46878: CALL_OW 441
// end ; if btype = b_warehouse then
46882: LD_VAR 0 5
46886: PUSH
46887: LD_INT 1
46889: EQUAL
46890: IFFALSE 46908
// begin btype := b_depot ;
46892: LD_ADDR_VAR 0 5
46896: PUSH
46897: LD_INT 0
46899: ST_TO_ADDR
// pos := 1 ;
46900: LD_ADDR_VAR 0 6
46904: PUSH
46905: LD_INT 1
46907: ST_TO_ADDR
// end ; if btype = b_factory then
46908: LD_VAR 0 5
46912: PUSH
46913: LD_INT 3
46915: EQUAL
46916: IFFALSE 46934
// begin btype := b_workshop ;
46918: LD_ADDR_VAR 0 5
46922: PUSH
46923: LD_INT 2
46925: ST_TO_ADDR
// pos := 1 ;
46926: LD_ADDR_VAR 0 6
46930: PUSH
46931: LD_INT 1
46933: ST_TO_ADDR
// end ; if btype = b_barracks then
46934: LD_VAR 0 5
46938: PUSH
46939: LD_INT 5
46941: EQUAL
46942: IFFALSE 46952
// btype := b_armoury ;
46944: LD_ADDR_VAR 0 5
46948: PUSH
46949: LD_INT 4
46951: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
46952: LD_VAR 0 5
46956: PUSH
46957: LD_INT 7
46959: PUSH
46960: LD_INT 8
46962: PUSH
46963: EMPTY
46964: LIST
46965: LIST
46966: IN
46967: IFFALSE 46977
// btype := b_lab ;
46969: LD_ADDR_VAR 0 5
46973: PUSH
46974: LD_INT 6
46976: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
46977: LD_ADDR_EXP 55
46981: PUSH
46982: LD_EXP 55
46986: PPUSH
46987: LD_VAR 0 3
46991: PUSH
46992: LD_EXP 55
46996: PUSH
46997: LD_VAR 0 3
47001: ARRAY
47002: PUSH
47003: LD_INT 1
47005: PLUS
47006: PUSH
47007: EMPTY
47008: LIST
47009: LIST
47010: PPUSH
47011: LD_VAR 0 5
47015: PUSH
47016: LD_VAR 0 1
47020: PPUSH
47021: CALL_OW 250
47025: PUSH
47026: LD_VAR 0 1
47030: PPUSH
47031: CALL_OW 251
47035: PUSH
47036: LD_VAR 0 1
47040: PPUSH
47041: CALL_OW 254
47045: PUSH
47046: EMPTY
47047: LIST
47048: LIST
47049: LIST
47050: LIST
47051: PPUSH
47052: CALL 54067 0 3
47056: ST_TO_ADDR
// if pos = 1 then
47057: LD_VAR 0 6
47061: PUSH
47062: LD_INT 1
47064: EQUAL
47065: IFFALSE 47180
// begin tmp := mc_build_list [ i ] ;
47067: LD_ADDR_VAR 0 7
47071: PUSH
47072: LD_EXP 55
47076: PUSH
47077: LD_VAR 0 3
47081: ARRAY
47082: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
47083: LD_VAR 0 7
47087: PPUSH
47088: LD_INT 2
47090: PUSH
47091: LD_INT 30
47093: PUSH
47094: LD_INT 0
47096: PUSH
47097: EMPTY
47098: LIST
47099: LIST
47100: PUSH
47101: LD_INT 30
47103: PUSH
47104: LD_INT 1
47106: PUSH
47107: EMPTY
47108: LIST
47109: LIST
47110: PUSH
47111: EMPTY
47112: LIST
47113: LIST
47114: LIST
47115: PPUSH
47116: CALL_OW 72
47120: IFFALSE 47130
// pos := 2 ;
47122: LD_ADDR_VAR 0 6
47126: PUSH
47127: LD_INT 2
47129: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
47130: LD_ADDR_VAR 0 7
47134: PUSH
47135: LD_VAR 0 7
47139: PPUSH
47140: LD_VAR 0 6
47144: PPUSH
47145: LD_VAR 0 7
47149: PPUSH
47150: CALL 54393 0 3
47154: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
47155: LD_ADDR_EXP 55
47159: PUSH
47160: LD_EXP 55
47164: PPUSH
47165: LD_VAR 0 3
47169: PPUSH
47170: LD_VAR 0 7
47174: PPUSH
47175: CALL_OW 1
47179: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
47180: LD_VAR 0 1
47184: PUSH
47185: LD_EXP 50
47189: PUSH
47190: LD_VAR 0 3
47194: ARRAY
47195: IN
47196: IFFALSE 47235
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
47198: LD_ADDR_EXP 50
47202: PUSH
47203: LD_EXP 50
47207: PPUSH
47208: LD_VAR 0 3
47212: PPUSH
47213: LD_EXP 50
47217: PUSH
47218: LD_VAR 0 3
47222: ARRAY
47223: PUSH
47224: LD_VAR 0 1
47228: DIFF
47229: PPUSH
47230: CALL_OW 1
47234: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
47235: LD_VAR 0 1
47239: PUSH
47240: LD_EXP 57
47244: PUSH
47245: LD_VAR 0 3
47249: ARRAY
47250: IN
47251: IFFALSE 47290
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
47253: LD_ADDR_EXP 57
47257: PUSH
47258: LD_EXP 57
47262: PPUSH
47263: LD_VAR 0 3
47267: PPUSH
47268: LD_EXP 57
47272: PUSH
47273: LD_VAR 0 3
47277: ARRAY
47278: PUSH
47279: LD_VAR 0 1
47283: DIFF
47284: PPUSH
47285: CALL_OW 1
47289: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
47290: LD_VAR 0 1
47294: PUSH
47295: LD_EXP 69
47299: PUSH
47300: LD_VAR 0 3
47304: ARRAY
47305: IN
47306: IFFALSE 47345
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
47308: LD_ADDR_EXP 69
47312: PUSH
47313: LD_EXP 69
47317: PPUSH
47318: LD_VAR 0 3
47322: PPUSH
47323: LD_EXP 69
47327: PUSH
47328: LD_VAR 0 3
47332: ARRAY
47333: PUSH
47334: LD_VAR 0 1
47338: DIFF
47339: PPUSH
47340: CALL_OW 1
47344: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
47345: LD_VAR 0 1
47349: PUSH
47350: LD_EXP 72
47354: PUSH
47355: LD_VAR 0 3
47359: ARRAY
47360: IN
47361: IFFALSE 47400
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
47363: LD_ADDR_EXP 72
47367: PUSH
47368: LD_EXP 72
47372: PPUSH
47373: LD_VAR 0 3
47377: PPUSH
47378: LD_EXP 72
47382: PUSH
47383: LD_VAR 0 3
47387: ARRAY
47388: PUSH
47389: LD_VAR 0 1
47393: DIFF
47394: PPUSH
47395: CALL_OW 1
47399: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
47400: LD_VAR 0 1
47404: PUSH
47405: LD_EXP 59
47409: PUSH
47410: LD_VAR 0 3
47414: ARRAY
47415: IN
47416: IFFALSE 47455
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
47418: LD_ADDR_EXP 59
47422: PUSH
47423: LD_EXP 59
47427: PPUSH
47428: LD_VAR 0 3
47432: PPUSH
47433: LD_EXP 59
47437: PUSH
47438: LD_VAR 0 3
47442: ARRAY
47443: PUSH
47444: LD_VAR 0 1
47448: DIFF
47449: PPUSH
47450: CALL_OW 1
47454: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
47455: LD_VAR 0 1
47459: PUSH
47460: LD_EXP 58
47464: PUSH
47465: LD_VAR 0 3
47469: ARRAY
47470: IN
47471: IFFALSE 47510
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
47473: LD_ADDR_EXP 58
47477: PUSH
47478: LD_EXP 58
47482: PPUSH
47483: LD_VAR 0 3
47487: PPUSH
47488: LD_EXP 58
47492: PUSH
47493: LD_VAR 0 3
47497: ARRAY
47498: PUSH
47499: LD_VAR 0 1
47503: DIFF
47504: PPUSH
47505: CALL_OW 1
47509: ST_TO_ADDR
// end ; break ;
47510: GO 47514
// end ;
47512: GO 46162
47514: POP
47515: POP
// end ;
47516: LD_VAR 0 2
47520: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
47521: LD_INT 0
47523: PPUSH
47524: PPUSH
47525: PPUSH
// if not mc_bases or not skirmish then
47526: LD_EXP 50
47530: NOT
47531: PUSH
47532: LD_EXP 48
47536: NOT
47537: OR
47538: IFFALSE 47542
// exit ;
47540: GO 47757
// for i = 1 to mc_bases do
47542: LD_ADDR_VAR 0 3
47546: PUSH
47547: DOUBLE
47548: LD_INT 1
47550: DEC
47551: ST_TO_ADDR
47552: LD_EXP 50
47556: PUSH
47557: FOR_TO
47558: IFFALSE 47755
// begin if building in mc_construct_list [ i ] then
47560: LD_VAR 0 1
47564: PUSH
47565: LD_EXP 57
47569: PUSH
47570: LD_VAR 0 3
47574: ARRAY
47575: IN
47576: IFFALSE 47753
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
47578: LD_ADDR_EXP 57
47582: PUSH
47583: LD_EXP 57
47587: PPUSH
47588: LD_VAR 0 3
47592: PPUSH
47593: LD_EXP 57
47597: PUSH
47598: LD_VAR 0 3
47602: ARRAY
47603: PUSH
47604: LD_VAR 0 1
47608: DIFF
47609: PPUSH
47610: CALL_OW 1
47614: ST_TO_ADDR
// if building in mc_lab [ i ] then
47615: LD_VAR 0 1
47619: PUSH
47620: LD_EXP 83
47624: PUSH
47625: LD_VAR 0 3
47629: ARRAY
47630: IN
47631: IFFALSE 47686
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
47633: LD_ADDR_EXP 84
47637: PUSH
47638: LD_EXP 84
47642: PPUSH
47643: LD_VAR 0 3
47647: PPUSH
47648: LD_EXP 84
47652: PUSH
47653: LD_VAR 0 3
47657: ARRAY
47658: PPUSH
47659: LD_INT 1
47661: PPUSH
47662: LD_EXP 84
47666: PUSH
47667: LD_VAR 0 3
47671: ARRAY
47672: PPUSH
47673: LD_INT 0
47675: PPUSH
47676: CALL 53485 0 4
47680: PPUSH
47681: CALL_OW 1
47685: ST_TO_ADDR
// if not building in mc_bases [ i ] then
47686: LD_VAR 0 1
47690: PUSH
47691: LD_EXP 50
47695: PUSH
47696: LD_VAR 0 3
47700: ARRAY
47701: IN
47702: NOT
47703: IFFALSE 47749
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
47705: LD_ADDR_EXP 50
47709: PUSH
47710: LD_EXP 50
47714: PPUSH
47715: LD_VAR 0 3
47719: PUSH
47720: LD_EXP 50
47724: PUSH
47725: LD_VAR 0 3
47729: ARRAY
47730: PUSH
47731: LD_INT 1
47733: PLUS
47734: PUSH
47735: EMPTY
47736: LIST
47737: LIST
47738: PPUSH
47739: LD_VAR 0 1
47743: PPUSH
47744: CALL 54067 0 3
47748: ST_TO_ADDR
// exit ;
47749: POP
47750: POP
47751: GO 47757
// end ; end ;
47753: GO 47557
47755: POP
47756: POP
// end ;
47757: LD_VAR 0 2
47761: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
47762: LD_INT 0
47764: PPUSH
47765: PPUSH
47766: PPUSH
47767: PPUSH
47768: PPUSH
47769: PPUSH
47770: PPUSH
// if not mc_bases or not skirmish then
47771: LD_EXP 50
47775: NOT
47776: PUSH
47777: LD_EXP 48
47781: NOT
47782: OR
47783: IFFALSE 47787
// exit ;
47785: GO 48448
// for i = 1 to mc_bases do
47787: LD_ADDR_VAR 0 3
47791: PUSH
47792: DOUBLE
47793: LD_INT 1
47795: DEC
47796: ST_TO_ADDR
47797: LD_EXP 50
47801: PUSH
47802: FOR_TO
47803: IFFALSE 48446
// begin if building in mc_construct_list [ i ] then
47805: LD_VAR 0 1
47809: PUSH
47810: LD_EXP 57
47814: PUSH
47815: LD_VAR 0 3
47819: ARRAY
47820: IN
47821: IFFALSE 48444
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
47823: LD_ADDR_EXP 57
47827: PUSH
47828: LD_EXP 57
47832: PPUSH
47833: LD_VAR 0 3
47837: PPUSH
47838: LD_EXP 57
47842: PUSH
47843: LD_VAR 0 3
47847: ARRAY
47848: PUSH
47849: LD_VAR 0 1
47853: DIFF
47854: PPUSH
47855: CALL_OW 1
47859: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
47860: LD_ADDR_EXP 50
47864: PUSH
47865: LD_EXP 50
47869: PPUSH
47870: LD_VAR 0 3
47874: PUSH
47875: LD_EXP 50
47879: PUSH
47880: LD_VAR 0 3
47884: ARRAY
47885: PUSH
47886: LD_INT 1
47888: PLUS
47889: PUSH
47890: EMPTY
47891: LIST
47892: LIST
47893: PPUSH
47894: LD_VAR 0 1
47898: PPUSH
47899: CALL 54067 0 3
47903: ST_TO_ADDR
// btype := GetBType ( building ) ;
47904: LD_ADDR_VAR 0 5
47908: PUSH
47909: LD_VAR 0 1
47913: PPUSH
47914: CALL_OW 266
47918: ST_TO_ADDR
// side := GetSide ( building ) ;
47919: LD_ADDR_VAR 0 8
47923: PUSH
47924: LD_VAR 0 1
47928: PPUSH
47929: CALL_OW 255
47933: ST_TO_ADDR
// if btype = b_lab then
47934: LD_VAR 0 5
47938: PUSH
47939: LD_INT 6
47941: EQUAL
47942: IFFALSE 47992
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
47944: LD_ADDR_EXP 83
47948: PUSH
47949: LD_EXP 83
47953: PPUSH
47954: LD_VAR 0 3
47958: PUSH
47959: LD_EXP 83
47963: PUSH
47964: LD_VAR 0 3
47968: ARRAY
47969: PUSH
47970: LD_INT 1
47972: PLUS
47973: PUSH
47974: EMPTY
47975: LIST
47976: LIST
47977: PPUSH
47978: LD_VAR 0 1
47982: PPUSH
47983: CALL 54067 0 3
47987: ST_TO_ADDR
// exit ;
47988: POP
47989: POP
47990: GO 48448
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
47992: LD_VAR 0 5
47996: PUSH
47997: LD_INT 0
47999: PUSH
48000: LD_INT 2
48002: PUSH
48003: LD_INT 4
48005: PUSH
48006: EMPTY
48007: LIST
48008: LIST
48009: LIST
48010: IN
48011: IFFALSE 48135
// begin if btype = b_armoury then
48013: LD_VAR 0 5
48017: PUSH
48018: LD_INT 4
48020: EQUAL
48021: IFFALSE 48031
// btype := b_barracks ;
48023: LD_ADDR_VAR 0 5
48027: PUSH
48028: LD_INT 5
48030: ST_TO_ADDR
// if btype = b_depot then
48031: LD_VAR 0 5
48035: PUSH
48036: LD_INT 0
48038: EQUAL
48039: IFFALSE 48049
// btype := b_warehouse ;
48041: LD_ADDR_VAR 0 5
48045: PUSH
48046: LD_INT 1
48048: ST_TO_ADDR
// if btype = b_workshop then
48049: LD_VAR 0 5
48053: PUSH
48054: LD_INT 2
48056: EQUAL
48057: IFFALSE 48067
// btype := b_factory ;
48059: LD_ADDR_VAR 0 5
48063: PUSH
48064: LD_INT 3
48066: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
48067: LD_VAR 0 5
48071: PPUSH
48072: LD_VAR 0 8
48076: PPUSH
48077: CALL_OW 323
48081: PUSH
48082: LD_INT 1
48084: EQUAL
48085: IFFALSE 48131
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
48087: LD_ADDR_EXP 82
48091: PUSH
48092: LD_EXP 82
48096: PPUSH
48097: LD_VAR 0 3
48101: PUSH
48102: LD_EXP 82
48106: PUSH
48107: LD_VAR 0 3
48111: ARRAY
48112: PUSH
48113: LD_INT 1
48115: PLUS
48116: PUSH
48117: EMPTY
48118: LIST
48119: LIST
48120: PPUSH
48121: LD_VAR 0 1
48125: PPUSH
48126: CALL 54067 0 3
48130: ST_TO_ADDR
// exit ;
48131: POP
48132: POP
48133: GO 48448
// end ; if btype in [ b_bunker , b_turret ] then
48135: LD_VAR 0 5
48139: PUSH
48140: LD_INT 32
48142: PUSH
48143: LD_INT 33
48145: PUSH
48146: EMPTY
48147: LIST
48148: LIST
48149: IN
48150: IFFALSE 48440
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
48152: LD_ADDR_EXP 58
48156: PUSH
48157: LD_EXP 58
48161: PPUSH
48162: LD_VAR 0 3
48166: PUSH
48167: LD_EXP 58
48171: PUSH
48172: LD_VAR 0 3
48176: ARRAY
48177: PUSH
48178: LD_INT 1
48180: PLUS
48181: PUSH
48182: EMPTY
48183: LIST
48184: LIST
48185: PPUSH
48186: LD_VAR 0 1
48190: PPUSH
48191: CALL 54067 0 3
48195: ST_TO_ADDR
// if btype = b_bunker then
48196: LD_VAR 0 5
48200: PUSH
48201: LD_INT 32
48203: EQUAL
48204: IFFALSE 48440
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
48206: LD_ADDR_EXP 59
48210: PUSH
48211: LD_EXP 59
48215: PPUSH
48216: LD_VAR 0 3
48220: PUSH
48221: LD_EXP 59
48225: PUSH
48226: LD_VAR 0 3
48230: ARRAY
48231: PUSH
48232: LD_INT 1
48234: PLUS
48235: PUSH
48236: EMPTY
48237: LIST
48238: LIST
48239: PPUSH
48240: LD_VAR 0 1
48244: PPUSH
48245: CALL 54067 0 3
48249: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
48250: LD_ADDR_VAR 0 6
48254: PUSH
48255: LD_EXP 50
48259: PUSH
48260: LD_VAR 0 3
48264: ARRAY
48265: PPUSH
48266: LD_INT 25
48268: PUSH
48269: LD_INT 1
48271: PUSH
48272: EMPTY
48273: LIST
48274: LIST
48275: PUSH
48276: LD_INT 3
48278: PUSH
48279: LD_INT 54
48281: PUSH
48282: EMPTY
48283: LIST
48284: PUSH
48285: EMPTY
48286: LIST
48287: LIST
48288: PUSH
48289: EMPTY
48290: LIST
48291: LIST
48292: PPUSH
48293: CALL_OW 72
48297: ST_TO_ADDR
// if tmp then
48298: LD_VAR 0 6
48302: IFFALSE 48308
// exit ;
48304: POP
48305: POP
48306: GO 48448
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
48308: LD_ADDR_VAR 0 6
48312: PUSH
48313: LD_EXP 50
48317: PUSH
48318: LD_VAR 0 3
48322: ARRAY
48323: PPUSH
48324: LD_INT 2
48326: PUSH
48327: LD_INT 30
48329: PUSH
48330: LD_INT 4
48332: PUSH
48333: EMPTY
48334: LIST
48335: LIST
48336: PUSH
48337: LD_INT 30
48339: PUSH
48340: LD_INT 5
48342: PUSH
48343: EMPTY
48344: LIST
48345: LIST
48346: PUSH
48347: EMPTY
48348: LIST
48349: LIST
48350: LIST
48351: PPUSH
48352: CALL_OW 72
48356: ST_TO_ADDR
// if not tmp then
48357: LD_VAR 0 6
48361: NOT
48362: IFFALSE 48368
// exit ;
48364: POP
48365: POP
48366: GO 48448
// for j in tmp do
48368: LD_ADDR_VAR 0 4
48372: PUSH
48373: LD_VAR 0 6
48377: PUSH
48378: FOR_IN
48379: IFFALSE 48438
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
48381: LD_ADDR_VAR 0 7
48385: PUSH
48386: LD_VAR 0 4
48390: PPUSH
48391: CALL_OW 313
48395: PPUSH
48396: LD_INT 25
48398: PUSH
48399: LD_INT 1
48401: PUSH
48402: EMPTY
48403: LIST
48404: LIST
48405: PPUSH
48406: CALL_OW 72
48410: ST_TO_ADDR
// if units then
48411: LD_VAR 0 7
48415: IFFALSE 48436
// begin ComExitBuilding ( units [ 1 ] ) ;
48417: LD_VAR 0 7
48421: PUSH
48422: LD_INT 1
48424: ARRAY
48425: PPUSH
48426: CALL_OW 122
// exit ;
48430: POP
48431: POP
48432: POP
48433: POP
48434: GO 48448
// end ; end ;
48436: GO 48378
48438: POP
48439: POP
// end ; end ; exit ;
48440: POP
48441: POP
48442: GO 48448
// end ; end ;
48444: GO 47802
48446: POP
48447: POP
// end ;
48448: LD_VAR 0 2
48452: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
48453: LD_INT 0
48455: PPUSH
48456: PPUSH
48457: PPUSH
48458: PPUSH
48459: PPUSH
48460: PPUSH
48461: PPUSH
// if not mc_bases or not skirmish then
48462: LD_EXP 50
48466: NOT
48467: PUSH
48468: LD_EXP 48
48472: NOT
48473: OR
48474: IFFALSE 48478
// exit ;
48476: GO 48743
// btype := GetBType ( building ) ;
48478: LD_ADDR_VAR 0 6
48482: PUSH
48483: LD_VAR 0 1
48487: PPUSH
48488: CALL_OW 266
48492: ST_TO_ADDR
// x := GetX ( building ) ;
48493: LD_ADDR_VAR 0 7
48497: PUSH
48498: LD_VAR 0 1
48502: PPUSH
48503: CALL_OW 250
48507: ST_TO_ADDR
// y := GetY ( building ) ;
48508: LD_ADDR_VAR 0 8
48512: PUSH
48513: LD_VAR 0 1
48517: PPUSH
48518: CALL_OW 251
48522: ST_TO_ADDR
// d := GetDir ( building ) ;
48523: LD_ADDR_VAR 0 9
48527: PUSH
48528: LD_VAR 0 1
48532: PPUSH
48533: CALL_OW 254
48537: ST_TO_ADDR
// for i = 1 to mc_bases do
48538: LD_ADDR_VAR 0 4
48542: PUSH
48543: DOUBLE
48544: LD_INT 1
48546: DEC
48547: ST_TO_ADDR
48548: LD_EXP 50
48552: PUSH
48553: FOR_TO
48554: IFFALSE 48741
// begin if not mc_build_list [ i ] then
48556: LD_EXP 55
48560: PUSH
48561: LD_VAR 0 4
48565: ARRAY
48566: NOT
48567: IFFALSE 48571
// continue ;
48569: GO 48553
// for j := 1 to mc_build_list [ i ] do
48571: LD_ADDR_VAR 0 5
48575: PUSH
48576: DOUBLE
48577: LD_INT 1
48579: DEC
48580: ST_TO_ADDR
48581: LD_EXP 55
48585: PUSH
48586: LD_VAR 0 4
48590: ARRAY
48591: PUSH
48592: FOR_TO
48593: IFFALSE 48737
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
48595: LD_VAR 0 6
48599: PUSH
48600: LD_VAR 0 7
48604: PUSH
48605: LD_VAR 0 8
48609: PUSH
48610: LD_VAR 0 9
48614: PUSH
48615: EMPTY
48616: LIST
48617: LIST
48618: LIST
48619: LIST
48620: PPUSH
48621: LD_EXP 55
48625: PUSH
48626: LD_VAR 0 4
48630: ARRAY
48631: PUSH
48632: LD_VAR 0 5
48636: ARRAY
48637: PPUSH
48638: CALL 60624 0 2
48642: IFFALSE 48735
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
48644: LD_ADDR_EXP 55
48648: PUSH
48649: LD_EXP 55
48653: PPUSH
48654: LD_VAR 0 4
48658: PPUSH
48659: LD_EXP 55
48663: PUSH
48664: LD_VAR 0 4
48668: ARRAY
48669: PPUSH
48670: LD_VAR 0 5
48674: PPUSH
48675: CALL_OW 3
48679: PPUSH
48680: CALL_OW 1
48684: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
48685: LD_ADDR_EXP 57
48689: PUSH
48690: LD_EXP 57
48694: PPUSH
48695: LD_VAR 0 4
48699: PUSH
48700: LD_EXP 57
48704: PUSH
48705: LD_VAR 0 4
48709: ARRAY
48710: PUSH
48711: LD_INT 1
48713: PLUS
48714: PUSH
48715: EMPTY
48716: LIST
48717: LIST
48718: PPUSH
48719: LD_VAR 0 1
48723: PPUSH
48724: CALL 54067 0 3
48728: ST_TO_ADDR
// exit ;
48729: POP
48730: POP
48731: POP
48732: POP
48733: GO 48743
// end ;
48735: GO 48592
48737: POP
48738: POP
// end ;
48739: GO 48553
48741: POP
48742: POP
// end ;
48743: LD_VAR 0 3
48747: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
48748: LD_INT 0
48750: PPUSH
48751: PPUSH
48752: PPUSH
// if not mc_bases or not skirmish then
48753: LD_EXP 50
48757: NOT
48758: PUSH
48759: LD_EXP 48
48763: NOT
48764: OR
48765: IFFALSE 48769
// exit ;
48767: GO 48959
// for i = 1 to mc_bases do
48769: LD_ADDR_VAR 0 4
48773: PUSH
48774: DOUBLE
48775: LD_INT 1
48777: DEC
48778: ST_TO_ADDR
48779: LD_EXP 50
48783: PUSH
48784: FOR_TO
48785: IFFALSE 48872
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
48787: LD_VAR 0 1
48791: PUSH
48792: LD_EXP 58
48796: PUSH
48797: LD_VAR 0 4
48801: ARRAY
48802: IN
48803: PUSH
48804: LD_VAR 0 1
48808: PUSH
48809: LD_EXP 59
48813: PUSH
48814: LD_VAR 0 4
48818: ARRAY
48819: IN
48820: NOT
48821: AND
48822: IFFALSE 48870
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
48824: LD_ADDR_EXP 59
48828: PUSH
48829: LD_EXP 59
48833: PPUSH
48834: LD_VAR 0 4
48838: PUSH
48839: LD_EXP 59
48843: PUSH
48844: LD_VAR 0 4
48848: ARRAY
48849: PUSH
48850: LD_INT 1
48852: PLUS
48853: PUSH
48854: EMPTY
48855: LIST
48856: LIST
48857: PPUSH
48858: LD_VAR 0 1
48862: PPUSH
48863: CALL 54067 0 3
48867: ST_TO_ADDR
// break ;
48868: GO 48872
// end ; end ;
48870: GO 48784
48872: POP
48873: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
48874: LD_VAR 0 1
48878: PPUSH
48879: CALL_OW 257
48883: PUSH
48884: LD_EXP 76
48888: IN
48889: PUSH
48890: LD_VAR 0 1
48894: PPUSH
48895: CALL_OW 266
48899: PUSH
48900: LD_INT 5
48902: EQUAL
48903: AND
48904: PUSH
48905: LD_VAR 0 2
48909: PPUSH
48910: CALL_OW 110
48914: PUSH
48915: LD_INT 18
48917: NONEQUAL
48918: AND
48919: IFFALSE 48959
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
48921: LD_VAR 0 2
48925: PPUSH
48926: CALL_OW 257
48930: PUSH
48931: LD_INT 5
48933: PUSH
48934: LD_INT 8
48936: PUSH
48937: LD_INT 9
48939: PUSH
48940: EMPTY
48941: LIST
48942: LIST
48943: LIST
48944: IN
48945: IFFALSE 48959
// SetClass ( unit , 1 ) ;
48947: LD_VAR 0 2
48951: PPUSH
48952: LD_INT 1
48954: PPUSH
48955: CALL_OW 336
// end ;
48959: LD_VAR 0 3
48963: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
48964: LD_INT 0
48966: PPUSH
48967: PPUSH
// if not mc_bases or not skirmish then
48968: LD_EXP 50
48972: NOT
48973: PUSH
48974: LD_EXP 48
48978: NOT
48979: OR
48980: IFFALSE 48984
// exit ;
48982: GO 49100
// if GetLives ( abandoned_vehicle ) > 250 then
48984: LD_VAR 0 2
48988: PPUSH
48989: CALL_OW 256
48993: PUSH
48994: LD_INT 250
48996: GREATER
48997: IFFALSE 49001
// exit ;
48999: GO 49100
// for i = 1 to mc_bases do
49001: LD_ADDR_VAR 0 6
49005: PUSH
49006: DOUBLE
49007: LD_INT 1
49009: DEC
49010: ST_TO_ADDR
49011: LD_EXP 50
49015: PUSH
49016: FOR_TO
49017: IFFALSE 49098
// begin if driver in mc_bases [ i ] then
49019: LD_VAR 0 1
49023: PUSH
49024: LD_EXP 50
49028: PUSH
49029: LD_VAR 0 6
49033: ARRAY
49034: IN
49035: IFFALSE 49096
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
49037: LD_VAR 0 1
49041: PPUSH
49042: LD_EXP 50
49046: PUSH
49047: LD_VAR 0 6
49051: ARRAY
49052: PPUSH
49053: LD_INT 2
49055: PUSH
49056: LD_INT 30
49058: PUSH
49059: LD_INT 0
49061: PUSH
49062: EMPTY
49063: LIST
49064: LIST
49065: PUSH
49066: LD_INT 30
49068: PUSH
49069: LD_INT 1
49071: PUSH
49072: EMPTY
49073: LIST
49074: LIST
49075: PUSH
49076: EMPTY
49077: LIST
49078: LIST
49079: LIST
49080: PPUSH
49081: CALL_OW 72
49085: PUSH
49086: LD_INT 1
49088: ARRAY
49089: PPUSH
49090: CALL 87684 0 2
// break ;
49094: GO 49098
// end ; end ;
49096: GO 49016
49098: POP
49099: POP
// end ; end_of_file
49100: LD_VAR 0 5
49104: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
49105: LD_INT 0
49107: PPUSH
49108: PPUSH
// if exist_mode then
49109: LD_VAR 0 2
49113: IFFALSE 49138
// unit := CreateCharacter ( prefix & ident ) else
49115: LD_ADDR_VAR 0 5
49119: PUSH
49120: LD_VAR 0 3
49124: PUSH
49125: LD_VAR 0 1
49129: STR
49130: PPUSH
49131: CALL_OW 34
49135: ST_TO_ADDR
49136: GO 49153
// unit := NewCharacter ( ident ) ;
49138: LD_ADDR_VAR 0 5
49142: PUSH
49143: LD_VAR 0 1
49147: PPUSH
49148: CALL_OW 25
49152: ST_TO_ADDR
// result := unit ;
49153: LD_ADDR_VAR 0 4
49157: PUSH
49158: LD_VAR 0 5
49162: ST_TO_ADDR
// end ;
49163: LD_VAR 0 4
49167: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
49168: LD_INT 0
49170: PPUSH
49171: PPUSH
// if not side or not nation then
49172: LD_VAR 0 1
49176: NOT
49177: PUSH
49178: LD_VAR 0 2
49182: NOT
49183: OR
49184: IFFALSE 49188
// exit ;
49186: GO 49956
// case nation of nation_american :
49188: LD_VAR 0 2
49192: PUSH
49193: LD_INT 1
49195: DOUBLE
49196: EQUAL
49197: IFTRUE 49201
49199: GO 49415
49201: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
49202: LD_ADDR_VAR 0 4
49206: PUSH
49207: LD_INT 35
49209: PUSH
49210: LD_INT 45
49212: PUSH
49213: LD_INT 46
49215: PUSH
49216: LD_INT 47
49218: PUSH
49219: LD_INT 82
49221: PUSH
49222: LD_INT 83
49224: PUSH
49225: LD_INT 84
49227: PUSH
49228: LD_INT 85
49230: PUSH
49231: LD_INT 86
49233: PUSH
49234: LD_INT 1
49236: PUSH
49237: LD_INT 2
49239: PUSH
49240: LD_INT 6
49242: PUSH
49243: LD_INT 15
49245: PUSH
49246: LD_INT 16
49248: PUSH
49249: LD_INT 7
49251: PUSH
49252: LD_INT 12
49254: PUSH
49255: LD_INT 13
49257: PUSH
49258: LD_INT 10
49260: PUSH
49261: LD_INT 14
49263: PUSH
49264: LD_INT 20
49266: PUSH
49267: LD_INT 21
49269: PUSH
49270: LD_INT 22
49272: PUSH
49273: LD_INT 25
49275: PUSH
49276: LD_INT 32
49278: PUSH
49279: LD_INT 27
49281: PUSH
49282: LD_INT 36
49284: PUSH
49285: LD_INT 69
49287: PUSH
49288: LD_INT 39
49290: PUSH
49291: LD_INT 34
49293: PUSH
49294: LD_INT 40
49296: PUSH
49297: LD_INT 48
49299: PUSH
49300: LD_INT 49
49302: PUSH
49303: LD_INT 50
49305: PUSH
49306: LD_INT 51
49308: PUSH
49309: LD_INT 52
49311: PUSH
49312: LD_INT 53
49314: PUSH
49315: LD_INT 54
49317: PUSH
49318: LD_INT 55
49320: PUSH
49321: LD_INT 56
49323: PUSH
49324: LD_INT 57
49326: PUSH
49327: LD_INT 58
49329: PUSH
49330: LD_INT 59
49332: PUSH
49333: LD_INT 60
49335: PUSH
49336: LD_INT 61
49338: PUSH
49339: LD_INT 62
49341: PUSH
49342: LD_INT 80
49344: PUSH
49345: LD_INT 82
49347: PUSH
49348: LD_INT 83
49350: PUSH
49351: LD_INT 84
49353: PUSH
49354: LD_INT 85
49356: PUSH
49357: LD_INT 86
49359: PUSH
49360: EMPTY
49361: LIST
49362: LIST
49363: LIST
49364: LIST
49365: LIST
49366: LIST
49367: LIST
49368: LIST
49369: LIST
49370: LIST
49371: LIST
49372: LIST
49373: LIST
49374: LIST
49375: LIST
49376: LIST
49377: LIST
49378: LIST
49379: LIST
49380: LIST
49381: LIST
49382: LIST
49383: LIST
49384: LIST
49385: LIST
49386: LIST
49387: LIST
49388: LIST
49389: LIST
49390: LIST
49391: LIST
49392: LIST
49393: LIST
49394: LIST
49395: LIST
49396: LIST
49397: LIST
49398: LIST
49399: LIST
49400: LIST
49401: LIST
49402: LIST
49403: LIST
49404: LIST
49405: LIST
49406: LIST
49407: LIST
49408: LIST
49409: LIST
49410: LIST
49411: LIST
49412: ST_TO_ADDR
49413: GO 49880
49415: LD_INT 2
49417: DOUBLE
49418: EQUAL
49419: IFTRUE 49423
49421: GO 49649
49423: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
49424: LD_ADDR_VAR 0 4
49428: PUSH
49429: LD_INT 35
49431: PUSH
49432: LD_INT 45
49434: PUSH
49435: LD_INT 46
49437: PUSH
49438: LD_INT 47
49440: PUSH
49441: LD_INT 82
49443: PUSH
49444: LD_INT 83
49446: PUSH
49447: LD_INT 84
49449: PUSH
49450: LD_INT 85
49452: PUSH
49453: LD_INT 87
49455: PUSH
49456: LD_INT 70
49458: PUSH
49459: LD_INT 1
49461: PUSH
49462: LD_INT 11
49464: PUSH
49465: LD_INT 3
49467: PUSH
49468: LD_INT 4
49470: PUSH
49471: LD_INT 5
49473: PUSH
49474: LD_INT 6
49476: PUSH
49477: LD_INT 15
49479: PUSH
49480: LD_INT 18
49482: PUSH
49483: LD_INT 7
49485: PUSH
49486: LD_INT 17
49488: PUSH
49489: LD_INT 8
49491: PUSH
49492: LD_INT 20
49494: PUSH
49495: LD_INT 21
49497: PUSH
49498: LD_INT 22
49500: PUSH
49501: LD_INT 72
49503: PUSH
49504: LD_INT 26
49506: PUSH
49507: LD_INT 69
49509: PUSH
49510: LD_INT 39
49512: PUSH
49513: LD_INT 40
49515: PUSH
49516: LD_INT 41
49518: PUSH
49519: LD_INT 42
49521: PUSH
49522: LD_INT 43
49524: PUSH
49525: LD_INT 48
49527: PUSH
49528: LD_INT 49
49530: PUSH
49531: LD_INT 50
49533: PUSH
49534: LD_INT 51
49536: PUSH
49537: LD_INT 52
49539: PUSH
49540: LD_INT 53
49542: PUSH
49543: LD_INT 54
49545: PUSH
49546: LD_INT 55
49548: PUSH
49549: LD_INT 56
49551: PUSH
49552: LD_INT 60
49554: PUSH
49555: LD_INT 61
49557: PUSH
49558: LD_INT 62
49560: PUSH
49561: LD_INT 66
49563: PUSH
49564: LD_INT 67
49566: PUSH
49567: LD_INT 68
49569: PUSH
49570: LD_INT 81
49572: PUSH
49573: LD_INT 82
49575: PUSH
49576: LD_INT 83
49578: PUSH
49579: LD_INT 84
49581: PUSH
49582: LD_INT 85
49584: PUSH
49585: LD_INT 87
49587: PUSH
49588: LD_INT 88
49590: PUSH
49591: EMPTY
49592: LIST
49593: LIST
49594: LIST
49595: LIST
49596: LIST
49597: LIST
49598: LIST
49599: LIST
49600: LIST
49601: LIST
49602: LIST
49603: LIST
49604: LIST
49605: LIST
49606: LIST
49607: LIST
49608: LIST
49609: LIST
49610: LIST
49611: LIST
49612: LIST
49613: LIST
49614: LIST
49615: LIST
49616: LIST
49617: LIST
49618: LIST
49619: LIST
49620: LIST
49621: LIST
49622: LIST
49623: LIST
49624: LIST
49625: LIST
49626: LIST
49627: LIST
49628: LIST
49629: LIST
49630: LIST
49631: LIST
49632: LIST
49633: LIST
49634: LIST
49635: LIST
49636: LIST
49637: LIST
49638: LIST
49639: LIST
49640: LIST
49641: LIST
49642: LIST
49643: LIST
49644: LIST
49645: LIST
49646: ST_TO_ADDR
49647: GO 49880
49649: LD_INT 3
49651: DOUBLE
49652: EQUAL
49653: IFTRUE 49657
49655: GO 49879
49657: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
49658: LD_ADDR_VAR 0 4
49662: PUSH
49663: LD_INT 46
49665: PUSH
49666: LD_INT 47
49668: PUSH
49669: LD_INT 1
49671: PUSH
49672: LD_INT 2
49674: PUSH
49675: LD_INT 82
49677: PUSH
49678: LD_INT 83
49680: PUSH
49681: LD_INT 84
49683: PUSH
49684: LD_INT 85
49686: PUSH
49687: LD_INT 86
49689: PUSH
49690: LD_INT 11
49692: PUSH
49693: LD_INT 9
49695: PUSH
49696: LD_INT 20
49698: PUSH
49699: LD_INT 19
49701: PUSH
49702: LD_INT 21
49704: PUSH
49705: LD_INT 24
49707: PUSH
49708: LD_INT 22
49710: PUSH
49711: LD_INT 25
49713: PUSH
49714: LD_INT 28
49716: PUSH
49717: LD_INT 29
49719: PUSH
49720: LD_INT 30
49722: PUSH
49723: LD_INT 31
49725: PUSH
49726: LD_INT 37
49728: PUSH
49729: LD_INT 38
49731: PUSH
49732: LD_INT 32
49734: PUSH
49735: LD_INT 27
49737: PUSH
49738: LD_INT 33
49740: PUSH
49741: LD_INT 69
49743: PUSH
49744: LD_INT 39
49746: PUSH
49747: LD_INT 34
49749: PUSH
49750: LD_INT 40
49752: PUSH
49753: LD_INT 71
49755: PUSH
49756: LD_INT 23
49758: PUSH
49759: LD_INT 44
49761: PUSH
49762: LD_INT 48
49764: PUSH
49765: LD_INT 49
49767: PUSH
49768: LD_INT 50
49770: PUSH
49771: LD_INT 51
49773: PUSH
49774: LD_INT 52
49776: PUSH
49777: LD_INT 53
49779: PUSH
49780: LD_INT 54
49782: PUSH
49783: LD_INT 55
49785: PUSH
49786: LD_INT 56
49788: PUSH
49789: LD_INT 57
49791: PUSH
49792: LD_INT 58
49794: PUSH
49795: LD_INT 59
49797: PUSH
49798: LD_INT 63
49800: PUSH
49801: LD_INT 64
49803: PUSH
49804: LD_INT 65
49806: PUSH
49807: LD_INT 82
49809: PUSH
49810: LD_INT 83
49812: PUSH
49813: LD_INT 84
49815: PUSH
49816: LD_INT 85
49818: PUSH
49819: LD_INT 86
49821: PUSH
49822: EMPTY
49823: LIST
49824: LIST
49825: LIST
49826: LIST
49827: LIST
49828: LIST
49829: LIST
49830: LIST
49831: LIST
49832: LIST
49833: LIST
49834: LIST
49835: LIST
49836: LIST
49837: LIST
49838: LIST
49839: LIST
49840: LIST
49841: LIST
49842: LIST
49843: LIST
49844: LIST
49845: LIST
49846: LIST
49847: LIST
49848: LIST
49849: LIST
49850: LIST
49851: LIST
49852: LIST
49853: LIST
49854: LIST
49855: LIST
49856: LIST
49857: LIST
49858: LIST
49859: LIST
49860: LIST
49861: LIST
49862: LIST
49863: LIST
49864: LIST
49865: LIST
49866: LIST
49867: LIST
49868: LIST
49869: LIST
49870: LIST
49871: LIST
49872: LIST
49873: LIST
49874: LIST
49875: LIST
49876: ST_TO_ADDR
49877: GO 49880
49879: POP
// if state > - 1 and state < 3 then
49880: LD_VAR 0 3
49884: PUSH
49885: LD_INT 1
49887: NEG
49888: GREATER
49889: PUSH
49890: LD_VAR 0 3
49894: PUSH
49895: LD_INT 3
49897: LESS
49898: AND
49899: IFFALSE 49956
// for i in result do
49901: LD_ADDR_VAR 0 5
49905: PUSH
49906: LD_VAR 0 4
49910: PUSH
49911: FOR_IN
49912: IFFALSE 49954
// if GetTech ( i , side ) <> state then
49914: LD_VAR 0 5
49918: PPUSH
49919: LD_VAR 0 1
49923: PPUSH
49924: CALL_OW 321
49928: PUSH
49929: LD_VAR 0 3
49933: NONEQUAL
49934: IFFALSE 49952
// result := result diff i ;
49936: LD_ADDR_VAR 0 4
49940: PUSH
49941: LD_VAR 0 4
49945: PUSH
49946: LD_VAR 0 5
49950: DIFF
49951: ST_TO_ADDR
49952: GO 49911
49954: POP
49955: POP
// end ;
49956: LD_VAR 0 4
49960: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
49961: LD_INT 0
49963: PPUSH
49964: PPUSH
49965: PPUSH
// result := true ;
49966: LD_ADDR_VAR 0 3
49970: PUSH
49971: LD_INT 1
49973: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
49974: LD_ADDR_VAR 0 5
49978: PUSH
49979: LD_VAR 0 2
49983: PPUSH
49984: CALL_OW 480
49988: ST_TO_ADDR
// if not tmp then
49989: LD_VAR 0 5
49993: NOT
49994: IFFALSE 49998
// exit ;
49996: GO 50047
// for i in tmp do
49998: LD_ADDR_VAR 0 4
50002: PUSH
50003: LD_VAR 0 5
50007: PUSH
50008: FOR_IN
50009: IFFALSE 50045
// if GetTech ( i , side ) <> state_researched then
50011: LD_VAR 0 4
50015: PPUSH
50016: LD_VAR 0 1
50020: PPUSH
50021: CALL_OW 321
50025: PUSH
50026: LD_INT 2
50028: NONEQUAL
50029: IFFALSE 50043
// begin result := false ;
50031: LD_ADDR_VAR 0 3
50035: PUSH
50036: LD_INT 0
50038: ST_TO_ADDR
// exit ;
50039: POP
50040: POP
50041: GO 50047
// end ;
50043: GO 50008
50045: POP
50046: POP
// end ;
50047: LD_VAR 0 3
50051: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
50052: LD_INT 0
50054: PPUSH
50055: PPUSH
50056: PPUSH
50057: PPUSH
50058: PPUSH
50059: PPUSH
50060: PPUSH
50061: PPUSH
50062: PPUSH
50063: PPUSH
50064: PPUSH
50065: PPUSH
50066: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
50067: LD_VAR 0 1
50071: NOT
50072: PUSH
50073: LD_VAR 0 1
50077: PPUSH
50078: CALL_OW 257
50082: PUSH
50083: LD_INT 9
50085: NONEQUAL
50086: OR
50087: IFFALSE 50091
// exit ;
50089: GO 50664
// side := GetSide ( unit ) ;
50091: LD_ADDR_VAR 0 9
50095: PUSH
50096: LD_VAR 0 1
50100: PPUSH
50101: CALL_OW 255
50105: ST_TO_ADDR
// tech_space := tech_spacanom ;
50106: LD_ADDR_VAR 0 12
50110: PUSH
50111: LD_INT 29
50113: ST_TO_ADDR
// tech_time := tech_taurad ;
50114: LD_ADDR_VAR 0 13
50118: PUSH
50119: LD_INT 28
50121: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
50122: LD_ADDR_VAR 0 11
50126: PUSH
50127: LD_VAR 0 1
50131: PPUSH
50132: CALL_OW 310
50136: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
50137: LD_VAR 0 11
50141: PPUSH
50142: CALL_OW 247
50146: PUSH
50147: LD_INT 2
50149: EQUAL
50150: IFFALSE 50154
// exit ;
50152: GO 50664
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
50154: LD_ADDR_VAR 0 8
50158: PUSH
50159: LD_INT 81
50161: PUSH
50162: LD_VAR 0 9
50166: PUSH
50167: EMPTY
50168: LIST
50169: LIST
50170: PUSH
50171: LD_INT 3
50173: PUSH
50174: LD_INT 21
50176: PUSH
50177: LD_INT 3
50179: PUSH
50180: EMPTY
50181: LIST
50182: LIST
50183: PUSH
50184: EMPTY
50185: LIST
50186: LIST
50187: PUSH
50188: EMPTY
50189: LIST
50190: LIST
50191: PPUSH
50192: CALL_OW 69
50196: ST_TO_ADDR
// if not tmp then
50197: LD_VAR 0 8
50201: NOT
50202: IFFALSE 50206
// exit ;
50204: GO 50664
// if in_unit then
50206: LD_VAR 0 11
50210: IFFALSE 50234
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
50212: LD_ADDR_VAR 0 10
50216: PUSH
50217: LD_VAR 0 8
50221: PPUSH
50222: LD_VAR 0 11
50226: PPUSH
50227: CALL_OW 74
50231: ST_TO_ADDR
50232: GO 50254
// enemy := NearestUnitToUnit ( tmp , unit ) ;
50234: LD_ADDR_VAR 0 10
50238: PUSH
50239: LD_VAR 0 8
50243: PPUSH
50244: LD_VAR 0 1
50248: PPUSH
50249: CALL_OW 74
50253: ST_TO_ADDR
// if not enemy then
50254: LD_VAR 0 10
50258: NOT
50259: IFFALSE 50263
// exit ;
50261: GO 50664
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
50263: LD_VAR 0 11
50267: PUSH
50268: LD_VAR 0 11
50272: PPUSH
50273: LD_VAR 0 10
50277: PPUSH
50278: CALL_OW 296
50282: PUSH
50283: LD_INT 13
50285: GREATER
50286: AND
50287: PUSH
50288: LD_VAR 0 1
50292: PPUSH
50293: LD_VAR 0 10
50297: PPUSH
50298: CALL_OW 296
50302: PUSH
50303: LD_INT 12
50305: GREATER
50306: OR
50307: IFFALSE 50311
// exit ;
50309: GO 50664
// missile := [ 1 ] ;
50311: LD_ADDR_VAR 0 14
50315: PUSH
50316: LD_INT 1
50318: PUSH
50319: EMPTY
50320: LIST
50321: ST_TO_ADDR
// if Researched ( side , tech_space ) then
50322: LD_VAR 0 9
50326: PPUSH
50327: LD_VAR 0 12
50331: PPUSH
50332: CALL_OW 325
50336: IFFALSE 50365
// missile := Replace ( missile , missile + 1 , 2 ) ;
50338: LD_ADDR_VAR 0 14
50342: PUSH
50343: LD_VAR 0 14
50347: PPUSH
50348: LD_VAR 0 14
50352: PUSH
50353: LD_INT 1
50355: PLUS
50356: PPUSH
50357: LD_INT 2
50359: PPUSH
50360: CALL_OW 1
50364: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
50365: LD_VAR 0 9
50369: PPUSH
50370: LD_VAR 0 13
50374: PPUSH
50375: CALL_OW 325
50379: PUSH
50380: LD_VAR 0 10
50384: PPUSH
50385: CALL_OW 255
50389: PPUSH
50390: LD_VAR 0 13
50394: PPUSH
50395: CALL_OW 325
50399: NOT
50400: AND
50401: IFFALSE 50430
// missile := Replace ( missile , missile + 1 , 3 ) ;
50403: LD_ADDR_VAR 0 14
50407: PUSH
50408: LD_VAR 0 14
50412: PPUSH
50413: LD_VAR 0 14
50417: PUSH
50418: LD_INT 1
50420: PLUS
50421: PPUSH
50422: LD_INT 3
50424: PPUSH
50425: CALL_OW 1
50429: ST_TO_ADDR
// if missile < 2 then
50430: LD_VAR 0 14
50434: PUSH
50435: LD_INT 2
50437: LESS
50438: IFFALSE 50442
// exit ;
50440: GO 50664
// x := GetX ( enemy ) ;
50442: LD_ADDR_VAR 0 4
50446: PUSH
50447: LD_VAR 0 10
50451: PPUSH
50452: CALL_OW 250
50456: ST_TO_ADDR
// y := GetY ( enemy ) ;
50457: LD_ADDR_VAR 0 5
50461: PUSH
50462: LD_VAR 0 10
50466: PPUSH
50467: CALL_OW 251
50471: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
50472: LD_ADDR_VAR 0 6
50476: PUSH
50477: LD_VAR 0 4
50481: PUSH
50482: LD_INT 1
50484: NEG
50485: PPUSH
50486: LD_INT 1
50488: PPUSH
50489: CALL_OW 12
50493: PLUS
50494: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
50495: LD_ADDR_VAR 0 7
50499: PUSH
50500: LD_VAR 0 5
50504: PUSH
50505: LD_INT 1
50507: NEG
50508: PPUSH
50509: LD_INT 1
50511: PPUSH
50512: CALL_OW 12
50516: PLUS
50517: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
50518: LD_VAR 0 6
50522: PPUSH
50523: LD_VAR 0 7
50527: PPUSH
50528: CALL_OW 488
50532: NOT
50533: IFFALSE 50555
// begin _x := x ;
50535: LD_ADDR_VAR 0 6
50539: PUSH
50540: LD_VAR 0 4
50544: ST_TO_ADDR
// _y := y ;
50545: LD_ADDR_VAR 0 7
50549: PUSH
50550: LD_VAR 0 5
50554: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
50555: LD_ADDR_VAR 0 3
50559: PUSH
50560: LD_INT 1
50562: PPUSH
50563: LD_VAR 0 14
50567: PPUSH
50568: CALL_OW 12
50572: ST_TO_ADDR
// case i of 1 :
50573: LD_VAR 0 3
50577: PUSH
50578: LD_INT 1
50580: DOUBLE
50581: EQUAL
50582: IFTRUE 50586
50584: GO 50603
50586: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
50587: LD_VAR 0 1
50591: PPUSH
50592: LD_VAR 0 10
50596: PPUSH
50597: CALL_OW 115
50601: GO 50664
50603: LD_INT 2
50605: DOUBLE
50606: EQUAL
50607: IFTRUE 50611
50609: GO 50633
50611: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
50612: LD_VAR 0 1
50616: PPUSH
50617: LD_VAR 0 6
50621: PPUSH
50622: LD_VAR 0 7
50626: PPUSH
50627: CALL_OW 153
50631: GO 50664
50633: LD_INT 3
50635: DOUBLE
50636: EQUAL
50637: IFTRUE 50641
50639: GO 50663
50641: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
50642: LD_VAR 0 1
50646: PPUSH
50647: LD_VAR 0 6
50651: PPUSH
50652: LD_VAR 0 7
50656: PPUSH
50657: CALL_OW 154
50661: GO 50664
50663: POP
// end ;
50664: LD_VAR 0 2
50668: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
50669: LD_INT 0
50671: PPUSH
50672: PPUSH
50673: PPUSH
50674: PPUSH
50675: PPUSH
50676: PPUSH
// if not unit or not building then
50677: LD_VAR 0 1
50681: NOT
50682: PUSH
50683: LD_VAR 0 2
50687: NOT
50688: OR
50689: IFFALSE 50693
// exit ;
50691: GO 50851
// x := GetX ( building ) ;
50693: LD_ADDR_VAR 0 5
50697: PUSH
50698: LD_VAR 0 2
50702: PPUSH
50703: CALL_OW 250
50707: ST_TO_ADDR
// y := GetY ( building ) ;
50708: LD_ADDR_VAR 0 6
50712: PUSH
50713: LD_VAR 0 2
50717: PPUSH
50718: CALL_OW 251
50722: ST_TO_ADDR
// for i = 0 to 5 do
50723: LD_ADDR_VAR 0 4
50727: PUSH
50728: DOUBLE
50729: LD_INT 0
50731: DEC
50732: ST_TO_ADDR
50733: LD_INT 5
50735: PUSH
50736: FOR_TO
50737: IFFALSE 50849
// begin _x := ShiftX ( x , i , 3 ) ;
50739: LD_ADDR_VAR 0 7
50743: PUSH
50744: LD_VAR 0 5
50748: PPUSH
50749: LD_VAR 0 4
50753: PPUSH
50754: LD_INT 3
50756: PPUSH
50757: CALL_OW 272
50761: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
50762: LD_ADDR_VAR 0 8
50766: PUSH
50767: LD_VAR 0 6
50771: PPUSH
50772: LD_VAR 0 4
50776: PPUSH
50777: LD_INT 3
50779: PPUSH
50780: CALL_OW 273
50784: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
50785: LD_VAR 0 7
50789: PPUSH
50790: LD_VAR 0 8
50794: PPUSH
50795: CALL_OW 488
50799: NOT
50800: IFFALSE 50804
// continue ;
50802: GO 50736
// if HexInfo ( _x , _y ) = 0 then
50804: LD_VAR 0 7
50808: PPUSH
50809: LD_VAR 0 8
50813: PPUSH
50814: CALL_OW 428
50818: PUSH
50819: LD_INT 0
50821: EQUAL
50822: IFFALSE 50847
// begin ComMoveXY ( unit , _x , _y ) ;
50824: LD_VAR 0 1
50828: PPUSH
50829: LD_VAR 0 7
50833: PPUSH
50834: LD_VAR 0 8
50838: PPUSH
50839: CALL_OW 111
// exit ;
50843: POP
50844: POP
50845: GO 50851
// end ; end ;
50847: GO 50736
50849: POP
50850: POP
// end ;
50851: LD_VAR 0 3
50855: RET
// export function ScanBase ( side , base_area ) ; begin
50856: LD_INT 0
50858: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
50859: LD_ADDR_VAR 0 3
50863: PUSH
50864: LD_VAR 0 2
50868: PPUSH
50869: LD_INT 81
50871: PUSH
50872: LD_VAR 0 1
50876: PUSH
50877: EMPTY
50878: LIST
50879: LIST
50880: PPUSH
50881: CALL_OW 70
50885: ST_TO_ADDR
// end ;
50886: LD_VAR 0 3
50890: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
50891: LD_INT 0
50893: PPUSH
50894: PPUSH
50895: PPUSH
50896: PPUSH
// result := false ;
50897: LD_ADDR_VAR 0 2
50901: PUSH
50902: LD_INT 0
50904: ST_TO_ADDR
// side := GetSide ( unit ) ;
50905: LD_ADDR_VAR 0 3
50909: PUSH
50910: LD_VAR 0 1
50914: PPUSH
50915: CALL_OW 255
50919: ST_TO_ADDR
// nat := GetNation ( unit ) ;
50920: LD_ADDR_VAR 0 4
50924: PUSH
50925: LD_VAR 0 1
50929: PPUSH
50930: CALL_OW 248
50934: ST_TO_ADDR
// case nat of 1 :
50935: LD_VAR 0 4
50939: PUSH
50940: LD_INT 1
50942: DOUBLE
50943: EQUAL
50944: IFTRUE 50948
50946: GO 50959
50948: POP
// tech := tech_lassight ; 2 :
50949: LD_ADDR_VAR 0 5
50953: PUSH
50954: LD_INT 12
50956: ST_TO_ADDR
50957: GO 50998
50959: LD_INT 2
50961: DOUBLE
50962: EQUAL
50963: IFTRUE 50967
50965: GO 50978
50967: POP
// tech := tech_mortar ; 3 :
50968: LD_ADDR_VAR 0 5
50972: PUSH
50973: LD_INT 41
50975: ST_TO_ADDR
50976: GO 50998
50978: LD_INT 3
50980: DOUBLE
50981: EQUAL
50982: IFTRUE 50986
50984: GO 50997
50986: POP
// tech := tech_bazooka ; end ;
50987: LD_ADDR_VAR 0 5
50991: PUSH
50992: LD_INT 44
50994: ST_TO_ADDR
50995: GO 50998
50997: POP
// if Researched ( side , tech ) then
50998: LD_VAR 0 3
51002: PPUSH
51003: LD_VAR 0 5
51007: PPUSH
51008: CALL_OW 325
51012: IFFALSE 51039
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
51014: LD_ADDR_VAR 0 2
51018: PUSH
51019: LD_INT 5
51021: PUSH
51022: LD_INT 8
51024: PUSH
51025: LD_INT 9
51027: PUSH
51028: EMPTY
51029: LIST
51030: LIST
51031: LIST
51032: PUSH
51033: LD_VAR 0 4
51037: ARRAY
51038: ST_TO_ADDR
// end ;
51039: LD_VAR 0 2
51043: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
51044: LD_INT 0
51046: PPUSH
51047: PPUSH
51048: PPUSH
// if not mines then
51049: LD_VAR 0 2
51053: NOT
51054: IFFALSE 51058
// exit ;
51056: GO 51202
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
51058: LD_ADDR_VAR 0 5
51062: PUSH
51063: LD_INT 81
51065: PUSH
51066: LD_VAR 0 1
51070: PUSH
51071: EMPTY
51072: LIST
51073: LIST
51074: PUSH
51075: LD_INT 3
51077: PUSH
51078: LD_INT 21
51080: PUSH
51081: LD_INT 3
51083: PUSH
51084: EMPTY
51085: LIST
51086: LIST
51087: PUSH
51088: EMPTY
51089: LIST
51090: LIST
51091: PUSH
51092: EMPTY
51093: LIST
51094: LIST
51095: PPUSH
51096: CALL_OW 69
51100: ST_TO_ADDR
// for i in mines do
51101: LD_ADDR_VAR 0 4
51105: PUSH
51106: LD_VAR 0 2
51110: PUSH
51111: FOR_IN
51112: IFFALSE 51200
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
51114: LD_VAR 0 4
51118: PUSH
51119: LD_INT 1
51121: ARRAY
51122: PPUSH
51123: LD_VAR 0 4
51127: PUSH
51128: LD_INT 2
51130: ARRAY
51131: PPUSH
51132: CALL_OW 458
51136: NOT
51137: IFFALSE 51141
// continue ;
51139: GO 51111
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
51141: LD_VAR 0 4
51145: PUSH
51146: LD_INT 1
51148: ARRAY
51149: PPUSH
51150: LD_VAR 0 4
51154: PUSH
51155: LD_INT 2
51157: ARRAY
51158: PPUSH
51159: CALL_OW 428
51163: PUSH
51164: LD_VAR 0 5
51168: IN
51169: IFFALSE 51198
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
51171: LD_VAR 0 4
51175: PUSH
51176: LD_INT 1
51178: ARRAY
51179: PPUSH
51180: LD_VAR 0 4
51184: PUSH
51185: LD_INT 2
51187: ARRAY
51188: PPUSH
51189: LD_VAR 0 1
51193: PPUSH
51194: CALL_OW 456
// end ;
51198: GO 51111
51200: POP
51201: POP
// end ;
51202: LD_VAR 0 3
51206: RET
// export function Count ( array ) ; begin
51207: LD_INT 0
51209: PPUSH
// result := array + 0 ;
51210: LD_ADDR_VAR 0 2
51214: PUSH
51215: LD_VAR 0 1
51219: PUSH
51220: LD_INT 0
51222: PLUS
51223: ST_TO_ADDR
// end ;
51224: LD_VAR 0 2
51228: RET
// export function IsEmpty ( building ) ; begin
51229: LD_INT 0
51231: PPUSH
// if not building then
51232: LD_VAR 0 1
51236: NOT
51237: IFFALSE 51241
// exit ;
51239: GO 51284
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
51241: LD_ADDR_VAR 0 2
51245: PUSH
51246: LD_VAR 0 1
51250: PUSH
51251: LD_INT 22
51253: PUSH
51254: LD_VAR 0 1
51258: PPUSH
51259: CALL_OW 255
51263: PUSH
51264: EMPTY
51265: LIST
51266: LIST
51267: PUSH
51268: LD_INT 58
51270: PUSH
51271: EMPTY
51272: LIST
51273: PUSH
51274: EMPTY
51275: LIST
51276: LIST
51277: PPUSH
51278: CALL_OW 69
51282: IN
51283: ST_TO_ADDR
// end ;
51284: LD_VAR 0 2
51288: RET
// export function IsNotFull ( building ) ; var places ; begin
51289: LD_INT 0
51291: PPUSH
51292: PPUSH
// if not building then
51293: LD_VAR 0 1
51297: NOT
51298: IFFALSE 51302
// exit ;
51300: GO 51330
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
51302: LD_ADDR_VAR 0 2
51306: PUSH
51307: LD_VAR 0 1
51311: PPUSH
51312: LD_INT 3
51314: PUSH
51315: LD_INT 62
51317: PUSH
51318: EMPTY
51319: LIST
51320: PUSH
51321: EMPTY
51322: LIST
51323: LIST
51324: PPUSH
51325: CALL_OW 72
51329: ST_TO_ADDR
// end ;
51330: LD_VAR 0 2
51334: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
51335: LD_INT 0
51337: PPUSH
51338: PPUSH
51339: PPUSH
51340: PPUSH
// tmp := [ ] ;
51341: LD_ADDR_VAR 0 3
51345: PUSH
51346: EMPTY
51347: ST_TO_ADDR
// list := [ ] ;
51348: LD_ADDR_VAR 0 5
51352: PUSH
51353: EMPTY
51354: ST_TO_ADDR
// for i = 16 to 25 do
51355: LD_ADDR_VAR 0 4
51359: PUSH
51360: DOUBLE
51361: LD_INT 16
51363: DEC
51364: ST_TO_ADDR
51365: LD_INT 25
51367: PUSH
51368: FOR_TO
51369: IFFALSE 51442
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
51371: LD_ADDR_VAR 0 3
51375: PUSH
51376: LD_VAR 0 3
51380: PUSH
51381: LD_INT 22
51383: PUSH
51384: LD_VAR 0 1
51388: PPUSH
51389: CALL_OW 255
51393: PUSH
51394: EMPTY
51395: LIST
51396: LIST
51397: PUSH
51398: LD_INT 91
51400: PUSH
51401: LD_VAR 0 1
51405: PUSH
51406: LD_INT 6
51408: PUSH
51409: EMPTY
51410: LIST
51411: LIST
51412: LIST
51413: PUSH
51414: LD_INT 30
51416: PUSH
51417: LD_VAR 0 4
51421: PUSH
51422: EMPTY
51423: LIST
51424: LIST
51425: PUSH
51426: EMPTY
51427: LIST
51428: LIST
51429: LIST
51430: PUSH
51431: EMPTY
51432: LIST
51433: PPUSH
51434: CALL_OW 69
51438: ADD
51439: ST_TO_ADDR
51440: GO 51368
51442: POP
51443: POP
// for i = 1 to tmp do
51444: LD_ADDR_VAR 0 4
51448: PUSH
51449: DOUBLE
51450: LD_INT 1
51452: DEC
51453: ST_TO_ADDR
51454: LD_VAR 0 3
51458: PUSH
51459: FOR_TO
51460: IFFALSE 51548
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
51462: LD_ADDR_VAR 0 5
51466: PUSH
51467: LD_VAR 0 5
51471: PUSH
51472: LD_VAR 0 3
51476: PUSH
51477: LD_VAR 0 4
51481: ARRAY
51482: PPUSH
51483: CALL_OW 266
51487: PUSH
51488: LD_VAR 0 3
51492: PUSH
51493: LD_VAR 0 4
51497: ARRAY
51498: PPUSH
51499: CALL_OW 250
51503: PUSH
51504: LD_VAR 0 3
51508: PUSH
51509: LD_VAR 0 4
51513: ARRAY
51514: PPUSH
51515: CALL_OW 251
51519: PUSH
51520: LD_VAR 0 3
51524: PUSH
51525: LD_VAR 0 4
51529: ARRAY
51530: PPUSH
51531: CALL_OW 254
51535: PUSH
51536: EMPTY
51537: LIST
51538: LIST
51539: LIST
51540: LIST
51541: PUSH
51542: EMPTY
51543: LIST
51544: ADD
51545: ST_TO_ADDR
51546: GO 51459
51548: POP
51549: POP
// result := list ;
51550: LD_ADDR_VAR 0 2
51554: PUSH
51555: LD_VAR 0 5
51559: ST_TO_ADDR
// end ;
51560: LD_VAR 0 2
51564: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
51565: LD_INT 0
51567: PPUSH
51568: PPUSH
51569: PPUSH
51570: PPUSH
51571: PPUSH
51572: PPUSH
51573: PPUSH
// if not factory then
51574: LD_VAR 0 1
51578: NOT
51579: IFFALSE 51583
// exit ;
51581: GO 52176
// if control = control_apeman then
51583: LD_VAR 0 4
51587: PUSH
51588: LD_INT 5
51590: EQUAL
51591: IFFALSE 51700
// begin tmp := UnitsInside ( factory ) ;
51593: LD_ADDR_VAR 0 8
51597: PUSH
51598: LD_VAR 0 1
51602: PPUSH
51603: CALL_OW 313
51607: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
51608: LD_VAR 0 8
51612: PPUSH
51613: LD_INT 25
51615: PUSH
51616: LD_INT 12
51618: PUSH
51619: EMPTY
51620: LIST
51621: LIST
51622: PPUSH
51623: CALL_OW 72
51627: NOT
51628: IFFALSE 51638
// control := control_manual ;
51630: LD_ADDR_VAR 0 4
51634: PUSH
51635: LD_INT 1
51637: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
51638: LD_ADDR_VAR 0 8
51642: PUSH
51643: LD_VAR 0 1
51647: PPUSH
51648: CALL 51335 0 1
51652: ST_TO_ADDR
// if tmp then
51653: LD_VAR 0 8
51657: IFFALSE 51700
// begin for i in tmp do
51659: LD_ADDR_VAR 0 7
51663: PUSH
51664: LD_VAR 0 8
51668: PUSH
51669: FOR_IN
51670: IFFALSE 51698
// if i [ 1 ] = b_ext_radio then
51672: LD_VAR 0 7
51676: PUSH
51677: LD_INT 1
51679: ARRAY
51680: PUSH
51681: LD_INT 22
51683: EQUAL
51684: IFFALSE 51696
// begin control := control_remote ;
51686: LD_ADDR_VAR 0 4
51690: PUSH
51691: LD_INT 2
51693: ST_TO_ADDR
// break ;
51694: GO 51698
// end ;
51696: GO 51669
51698: POP
51699: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
51700: LD_VAR 0 1
51704: PPUSH
51705: LD_VAR 0 2
51709: PPUSH
51710: LD_VAR 0 3
51714: PPUSH
51715: LD_VAR 0 4
51719: PPUSH
51720: LD_VAR 0 5
51724: PPUSH
51725: CALL_OW 448
51729: IFFALSE 51764
// begin result := [ chassis , engine , control , weapon ] ;
51731: LD_ADDR_VAR 0 6
51735: PUSH
51736: LD_VAR 0 2
51740: PUSH
51741: LD_VAR 0 3
51745: PUSH
51746: LD_VAR 0 4
51750: PUSH
51751: LD_VAR 0 5
51755: PUSH
51756: EMPTY
51757: LIST
51758: LIST
51759: LIST
51760: LIST
51761: ST_TO_ADDR
// exit ;
51762: GO 52176
// end ; _chassis := AvailableChassisList ( factory ) ;
51764: LD_ADDR_VAR 0 9
51768: PUSH
51769: LD_VAR 0 1
51773: PPUSH
51774: CALL_OW 475
51778: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
51779: LD_ADDR_VAR 0 11
51783: PUSH
51784: LD_VAR 0 1
51788: PPUSH
51789: CALL_OW 476
51793: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
51794: LD_ADDR_VAR 0 12
51798: PUSH
51799: LD_VAR 0 1
51803: PPUSH
51804: CALL_OW 477
51808: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
51809: LD_ADDR_VAR 0 10
51813: PUSH
51814: LD_VAR 0 1
51818: PPUSH
51819: CALL_OW 478
51823: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
51824: LD_VAR 0 9
51828: NOT
51829: PUSH
51830: LD_VAR 0 11
51834: NOT
51835: OR
51836: PUSH
51837: LD_VAR 0 12
51841: NOT
51842: OR
51843: PUSH
51844: LD_VAR 0 10
51848: NOT
51849: OR
51850: IFFALSE 51885
// begin result := [ chassis , engine , control , weapon ] ;
51852: LD_ADDR_VAR 0 6
51856: PUSH
51857: LD_VAR 0 2
51861: PUSH
51862: LD_VAR 0 3
51866: PUSH
51867: LD_VAR 0 4
51871: PUSH
51872: LD_VAR 0 5
51876: PUSH
51877: EMPTY
51878: LIST
51879: LIST
51880: LIST
51881: LIST
51882: ST_TO_ADDR
// exit ;
51883: GO 52176
// end ; if not chassis in _chassis then
51885: LD_VAR 0 2
51889: PUSH
51890: LD_VAR 0 9
51894: IN
51895: NOT
51896: IFFALSE 51922
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
51898: LD_ADDR_VAR 0 2
51902: PUSH
51903: LD_VAR 0 9
51907: PUSH
51908: LD_INT 1
51910: PPUSH
51911: LD_VAR 0 9
51915: PPUSH
51916: CALL_OW 12
51920: ARRAY
51921: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
51922: LD_VAR 0 2
51926: PPUSH
51927: LD_VAR 0 3
51931: PPUSH
51932: CALL 52181 0 2
51936: NOT
51937: IFFALSE 51996
// repeat engine := _engine [ 1 ] ;
51939: LD_ADDR_VAR 0 3
51943: PUSH
51944: LD_VAR 0 11
51948: PUSH
51949: LD_INT 1
51951: ARRAY
51952: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
51953: LD_ADDR_VAR 0 11
51957: PUSH
51958: LD_VAR 0 11
51962: PPUSH
51963: LD_INT 1
51965: PPUSH
51966: CALL_OW 3
51970: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
51971: LD_VAR 0 2
51975: PPUSH
51976: LD_VAR 0 3
51980: PPUSH
51981: CALL 52181 0 2
51985: PUSH
51986: LD_VAR 0 11
51990: PUSH
51991: EMPTY
51992: EQUAL
51993: OR
51994: IFFALSE 51939
// if not control in _control then
51996: LD_VAR 0 4
52000: PUSH
52001: LD_VAR 0 12
52005: IN
52006: NOT
52007: IFFALSE 52033
// control := _control [ rand ( 1 , _control ) ] ;
52009: LD_ADDR_VAR 0 4
52013: PUSH
52014: LD_VAR 0 12
52018: PUSH
52019: LD_INT 1
52021: PPUSH
52022: LD_VAR 0 12
52026: PPUSH
52027: CALL_OW 12
52031: ARRAY
52032: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
52033: LD_VAR 0 2
52037: PPUSH
52038: LD_VAR 0 5
52042: PPUSH
52043: CALL 52401 0 2
52047: NOT
52048: IFFALSE 52107
// repeat weapon := _weapon [ 1 ] ;
52050: LD_ADDR_VAR 0 5
52054: PUSH
52055: LD_VAR 0 10
52059: PUSH
52060: LD_INT 1
52062: ARRAY
52063: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
52064: LD_ADDR_VAR 0 10
52068: PUSH
52069: LD_VAR 0 10
52073: PPUSH
52074: LD_INT 1
52076: PPUSH
52077: CALL_OW 3
52081: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
52082: LD_VAR 0 2
52086: PPUSH
52087: LD_VAR 0 5
52091: PPUSH
52092: CALL 52401 0 2
52096: PUSH
52097: LD_VAR 0 10
52101: PUSH
52102: EMPTY
52103: EQUAL
52104: OR
52105: IFFALSE 52050
// result := [ ] ;
52107: LD_ADDR_VAR 0 6
52111: PUSH
52112: EMPTY
52113: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
52114: LD_VAR 0 1
52118: PPUSH
52119: LD_VAR 0 2
52123: PPUSH
52124: LD_VAR 0 3
52128: PPUSH
52129: LD_VAR 0 4
52133: PPUSH
52134: LD_VAR 0 5
52138: PPUSH
52139: CALL_OW 448
52143: IFFALSE 52176
// result := [ chassis , engine , control , weapon ] ;
52145: LD_ADDR_VAR 0 6
52149: PUSH
52150: LD_VAR 0 2
52154: PUSH
52155: LD_VAR 0 3
52159: PUSH
52160: LD_VAR 0 4
52164: PUSH
52165: LD_VAR 0 5
52169: PUSH
52170: EMPTY
52171: LIST
52172: LIST
52173: LIST
52174: LIST
52175: ST_TO_ADDR
// end ;
52176: LD_VAR 0 6
52180: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
52181: LD_INT 0
52183: PPUSH
// if not chassis or not engine then
52184: LD_VAR 0 1
52188: NOT
52189: PUSH
52190: LD_VAR 0 2
52194: NOT
52195: OR
52196: IFFALSE 52200
// exit ;
52198: GO 52396
// case engine of engine_solar :
52200: LD_VAR 0 2
52204: PUSH
52205: LD_INT 2
52207: DOUBLE
52208: EQUAL
52209: IFTRUE 52213
52211: GO 52251
52213: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
52214: LD_ADDR_VAR 0 3
52218: PUSH
52219: LD_INT 11
52221: PUSH
52222: LD_INT 12
52224: PUSH
52225: LD_INT 13
52227: PUSH
52228: LD_INT 14
52230: PUSH
52231: LD_INT 1
52233: PUSH
52234: LD_INT 2
52236: PUSH
52237: LD_INT 3
52239: PUSH
52240: EMPTY
52241: LIST
52242: LIST
52243: LIST
52244: LIST
52245: LIST
52246: LIST
52247: LIST
52248: ST_TO_ADDR
52249: GO 52380
52251: LD_INT 1
52253: DOUBLE
52254: EQUAL
52255: IFTRUE 52259
52257: GO 52321
52259: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
52260: LD_ADDR_VAR 0 3
52264: PUSH
52265: LD_INT 11
52267: PUSH
52268: LD_INT 12
52270: PUSH
52271: LD_INT 13
52273: PUSH
52274: LD_INT 14
52276: PUSH
52277: LD_INT 1
52279: PUSH
52280: LD_INT 2
52282: PUSH
52283: LD_INT 3
52285: PUSH
52286: LD_INT 4
52288: PUSH
52289: LD_INT 5
52291: PUSH
52292: LD_INT 21
52294: PUSH
52295: LD_INT 23
52297: PUSH
52298: LD_INT 22
52300: PUSH
52301: LD_INT 24
52303: PUSH
52304: EMPTY
52305: LIST
52306: LIST
52307: LIST
52308: LIST
52309: LIST
52310: LIST
52311: LIST
52312: LIST
52313: LIST
52314: LIST
52315: LIST
52316: LIST
52317: LIST
52318: ST_TO_ADDR
52319: GO 52380
52321: LD_INT 3
52323: DOUBLE
52324: EQUAL
52325: IFTRUE 52329
52327: GO 52379
52329: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
52330: LD_ADDR_VAR 0 3
52334: PUSH
52335: LD_INT 13
52337: PUSH
52338: LD_INT 14
52340: PUSH
52341: LD_INT 2
52343: PUSH
52344: LD_INT 3
52346: PUSH
52347: LD_INT 4
52349: PUSH
52350: LD_INT 5
52352: PUSH
52353: LD_INT 21
52355: PUSH
52356: LD_INT 22
52358: PUSH
52359: LD_INT 23
52361: PUSH
52362: LD_INT 24
52364: PUSH
52365: EMPTY
52366: LIST
52367: LIST
52368: LIST
52369: LIST
52370: LIST
52371: LIST
52372: LIST
52373: LIST
52374: LIST
52375: LIST
52376: ST_TO_ADDR
52377: GO 52380
52379: POP
// result := ( chassis in result ) ;
52380: LD_ADDR_VAR 0 3
52384: PUSH
52385: LD_VAR 0 1
52389: PUSH
52390: LD_VAR 0 3
52394: IN
52395: ST_TO_ADDR
// end ;
52396: LD_VAR 0 3
52400: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
52401: LD_INT 0
52403: PPUSH
// if not chassis or not weapon then
52404: LD_VAR 0 1
52408: NOT
52409: PUSH
52410: LD_VAR 0 2
52414: NOT
52415: OR
52416: IFFALSE 52420
// exit ;
52418: GO 53480
// case weapon of us_machine_gun :
52420: LD_VAR 0 2
52424: PUSH
52425: LD_INT 2
52427: DOUBLE
52428: EQUAL
52429: IFTRUE 52433
52431: GO 52463
52433: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
52434: LD_ADDR_VAR 0 3
52438: PUSH
52439: LD_INT 1
52441: PUSH
52442: LD_INT 2
52444: PUSH
52445: LD_INT 3
52447: PUSH
52448: LD_INT 4
52450: PUSH
52451: LD_INT 5
52453: PUSH
52454: EMPTY
52455: LIST
52456: LIST
52457: LIST
52458: LIST
52459: LIST
52460: ST_TO_ADDR
52461: GO 53464
52463: LD_INT 3
52465: DOUBLE
52466: EQUAL
52467: IFTRUE 52471
52469: GO 52501
52471: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
52472: LD_ADDR_VAR 0 3
52476: PUSH
52477: LD_INT 1
52479: PUSH
52480: LD_INT 2
52482: PUSH
52483: LD_INT 3
52485: PUSH
52486: LD_INT 4
52488: PUSH
52489: LD_INT 5
52491: PUSH
52492: EMPTY
52493: LIST
52494: LIST
52495: LIST
52496: LIST
52497: LIST
52498: ST_TO_ADDR
52499: GO 53464
52501: LD_INT 11
52503: DOUBLE
52504: EQUAL
52505: IFTRUE 52509
52507: GO 52539
52509: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
52510: LD_ADDR_VAR 0 3
52514: PUSH
52515: LD_INT 1
52517: PUSH
52518: LD_INT 2
52520: PUSH
52521: LD_INT 3
52523: PUSH
52524: LD_INT 4
52526: PUSH
52527: LD_INT 5
52529: PUSH
52530: EMPTY
52531: LIST
52532: LIST
52533: LIST
52534: LIST
52535: LIST
52536: ST_TO_ADDR
52537: GO 53464
52539: LD_INT 4
52541: DOUBLE
52542: EQUAL
52543: IFTRUE 52547
52545: GO 52573
52547: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
52548: LD_ADDR_VAR 0 3
52552: PUSH
52553: LD_INT 2
52555: PUSH
52556: LD_INT 3
52558: PUSH
52559: LD_INT 4
52561: PUSH
52562: LD_INT 5
52564: PUSH
52565: EMPTY
52566: LIST
52567: LIST
52568: LIST
52569: LIST
52570: ST_TO_ADDR
52571: GO 53464
52573: LD_INT 5
52575: DOUBLE
52576: EQUAL
52577: IFTRUE 52581
52579: GO 52607
52581: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
52582: LD_ADDR_VAR 0 3
52586: PUSH
52587: LD_INT 2
52589: PUSH
52590: LD_INT 3
52592: PUSH
52593: LD_INT 4
52595: PUSH
52596: LD_INT 5
52598: PUSH
52599: EMPTY
52600: LIST
52601: LIST
52602: LIST
52603: LIST
52604: ST_TO_ADDR
52605: GO 53464
52607: LD_INT 9
52609: DOUBLE
52610: EQUAL
52611: IFTRUE 52615
52613: GO 52641
52615: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
52616: LD_ADDR_VAR 0 3
52620: PUSH
52621: LD_INT 2
52623: PUSH
52624: LD_INT 3
52626: PUSH
52627: LD_INT 4
52629: PUSH
52630: LD_INT 5
52632: PUSH
52633: EMPTY
52634: LIST
52635: LIST
52636: LIST
52637: LIST
52638: ST_TO_ADDR
52639: GO 53464
52641: LD_INT 7
52643: DOUBLE
52644: EQUAL
52645: IFTRUE 52649
52647: GO 52675
52649: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
52650: LD_ADDR_VAR 0 3
52654: PUSH
52655: LD_INT 2
52657: PUSH
52658: LD_INT 3
52660: PUSH
52661: LD_INT 4
52663: PUSH
52664: LD_INT 5
52666: PUSH
52667: EMPTY
52668: LIST
52669: LIST
52670: LIST
52671: LIST
52672: ST_TO_ADDR
52673: GO 53464
52675: LD_INT 12
52677: DOUBLE
52678: EQUAL
52679: IFTRUE 52683
52681: GO 52709
52683: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
52684: LD_ADDR_VAR 0 3
52688: PUSH
52689: LD_INT 2
52691: PUSH
52692: LD_INT 3
52694: PUSH
52695: LD_INT 4
52697: PUSH
52698: LD_INT 5
52700: PUSH
52701: EMPTY
52702: LIST
52703: LIST
52704: LIST
52705: LIST
52706: ST_TO_ADDR
52707: GO 53464
52709: LD_INT 13
52711: DOUBLE
52712: EQUAL
52713: IFTRUE 52717
52715: GO 52743
52717: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
52718: LD_ADDR_VAR 0 3
52722: PUSH
52723: LD_INT 2
52725: PUSH
52726: LD_INT 3
52728: PUSH
52729: LD_INT 4
52731: PUSH
52732: LD_INT 5
52734: PUSH
52735: EMPTY
52736: LIST
52737: LIST
52738: LIST
52739: LIST
52740: ST_TO_ADDR
52741: GO 53464
52743: LD_INT 14
52745: DOUBLE
52746: EQUAL
52747: IFTRUE 52751
52749: GO 52769
52751: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
52752: LD_ADDR_VAR 0 3
52756: PUSH
52757: LD_INT 4
52759: PUSH
52760: LD_INT 5
52762: PUSH
52763: EMPTY
52764: LIST
52765: LIST
52766: ST_TO_ADDR
52767: GO 53464
52769: LD_INT 6
52771: DOUBLE
52772: EQUAL
52773: IFTRUE 52777
52775: GO 52795
52777: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
52778: LD_ADDR_VAR 0 3
52782: PUSH
52783: LD_INT 4
52785: PUSH
52786: LD_INT 5
52788: PUSH
52789: EMPTY
52790: LIST
52791: LIST
52792: ST_TO_ADDR
52793: GO 53464
52795: LD_INT 10
52797: DOUBLE
52798: EQUAL
52799: IFTRUE 52803
52801: GO 52821
52803: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
52804: LD_ADDR_VAR 0 3
52808: PUSH
52809: LD_INT 4
52811: PUSH
52812: LD_INT 5
52814: PUSH
52815: EMPTY
52816: LIST
52817: LIST
52818: ST_TO_ADDR
52819: GO 53464
52821: LD_INT 22
52823: DOUBLE
52824: EQUAL
52825: IFTRUE 52829
52827: GO 52855
52829: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
52830: LD_ADDR_VAR 0 3
52834: PUSH
52835: LD_INT 11
52837: PUSH
52838: LD_INT 12
52840: PUSH
52841: LD_INT 13
52843: PUSH
52844: LD_INT 14
52846: PUSH
52847: EMPTY
52848: LIST
52849: LIST
52850: LIST
52851: LIST
52852: ST_TO_ADDR
52853: GO 53464
52855: LD_INT 23
52857: DOUBLE
52858: EQUAL
52859: IFTRUE 52863
52861: GO 52889
52863: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
52864: LD_ADDR_VAR 0 3
52868: PUSH
52869: LD_INT 11
52871: PUSH
52872: LD_INT 12
52874: PUSH
52875: LD_INT 13
52877: PUSH
52878: LD_INT 14
52880: PUSH
52881: EMPTY
52882: LIST
52883: LIST
52884: LIST
52885: LIST
52886: ST_TO_ADDR
52887: GO 53464
52889: LD_INT 24
52891: DOUBLE
52892: EQUAL
52893: IFTRUE 52897
52895: GO 52923
52897: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
52898: LD_ADDR_VAR 0 3
52902: PUSH
52903: LD_INT 11
52905: PUSH
52906: LD_INT 12
52908: PUSH
52909: LD_INT 13
52911: PUSH
52912: LD_INT 14
52914: PUSH
52915: EMPTY
52916: LIST
52917: LIST
52918: LIST
52919: LIST
52920: ST_TO_ADDR
52921: GO 53464
52923: LD_INT 30
52925: DOUBLE
52926: EQUAL
52927: IFTRUE 52931
52929: GO 52957
52931: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
52932: LD_ADDR_VAR 0 3
52936: PUSH
52937: LD_INT 11
52939: PUSH
52940: LD_INT 12
52942: PUSH
52943: LD_INT 13
52945: PUSH
52946: LD_INT 14
52948: PUSH
52949: EMPTY
52950: LIST
52951: LIST
52952: LIST
52953: LIST
52954: ST_TO_ADDR
52955: GO 53464
52957: LD_INT 25
52959: DOUBLE
52960: EQUAL
52961: IFTRUE 52965
52963: GO 52983
52965: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
52966: LD_ADDR_VAR 0 3
52970: PUSH
52971: LD_INT 13
52973: PUSH
52974: LD_INT 14
52976: PUSH
52977: EMPTY
52978: LIST
52979: LIST
52980: ST_TO_ADDR
52981: GO 53464
52983: LD_INT 27
52985: DOUBLE
52986: EQUAL
52987: IFTRUE 52991
52989: GO 53009
52991: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
52992: LD_ADDR_VAR 0 3
52996: PUSH
52997: LD_INT 13
52999: PUSH
53000: LD_INT 14
53002: PUSH
53003: EMPTY
53004: LIST
53005: LIST
53006: ST_TO_ADDR
53007: GO 53464
53009: LD_INT 92
53011: DOUBLE
53012: EQUAL
53013: IFTRUE 53017
53015: GO 53043
53017: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
53018: LD_ADDR_VAR 0 3
53022: PUSH
53023: LD_INT 11
53025: PUSH
53026: LD_INT 12
53028: PUSH
53029: LD_INT 13
53031: PUSH
53032: LD_INT 14
53034: PUSH
53035: EMPTY
53036: LIST
53037: LIST
53038: LIST
53039: LIST
53040: ST_TO_ADDR
53041: GO 53464
53043: LD_INT 28
53045: DOUBLE
53046: EQUAL
53047: IFTRUE 53051
53049: GO 53069
53051: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
53052: LD_ADDR_VAR 0 3
53056: PUSH
53057: LD_INT 13
53059: PUSH
53060: LD_INT 14
53062: PUSH
53063: EMPTY
53064: LIST
53065: LIST
53066: ST_TO_ADDR
53067: GO 53464
53069: LD_INT 29
53071: DOUBLE
53072: EQUAL
53073: IFTRUE 53077
53075: GO 53095
53077: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
53078: LD_ADDR_VAR 0 3
53082: PUSH
53083: LD_INT 13
53085: PUSH
53086: LD_INT 14
53088: PUSH
53089: EMPTY
53090: LIST
53091: LIST
53092: ST_TO_ADDR
53093: GO 53464
53095: LD_INT 31
53097: DOUBLE
53098: EQUAL
53099: IFTRUE 53103
53101: GO 53121
53103: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
53104: LD_ADDR_VAR 0 3
53108: PUSH
53109: LD_INT 13
53111: PUSH
53112: LD_INT 14
53114: PUSH
53115: EMPTY
53116: LIST
53117: LIST
53118: ST_TO_ADDR
53119: GO 53464
53121: LD_INT 26
53123: DOUBLE
53124: EQUAL
53125: IFTRUE 53129
53127: GO 53147
53129: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
53130: LD_ADDR_VAR 0 3
53134: PUSH
53135: LD_INT 13
53137: PUSH
53138: LD_INT 14
53140: PUSH
53141: EMPTY
53142: LIST
53143: LIST
53144: ST_TO_ADDR
53145: GO 53464
53147: LD_INT 42
53149: DOUBLE
53150: EQUAL
53151: IFTRUE 53155
53153: GO 53181
53155: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
53156: LD_ADDR_VAR 0 3
53160: PUSH
53161: LD_INT 21
53163: PUSH
53164: LD_INT 22
53166: PUSH
53167: LD_INT 23
53169: PUSH
53170: LD_INT 24
53172: PUSH
53173: EMPTY
53174: LIST
53175: LIST
53176: LIST
53177: LIST
53178: ST_TO_ADDR
53179: GO 53464
53181: LD_INT 43
53183: DOUBLE
53184: EQUAL
53185: IFTRUE 53189
53187: GO 53215
53189: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
53190: LD_ADDR_VAR 0 3
53194: PUSH
53195: LD_INT 21
53197: PUSH
53198: LD_INT 22
53200: PUSH
53201: LD_INT 23
53203: PUSH
53204: LD_INT 24
53206: PUSH
53207: EMPTY
53208: LIST
53209: LIST
53210: LIST
53211: LIST
53212: ST_TO_ADDR
53213: GO 53464
53215: LD_INT 44
53217: DOUBLE
53218: EQUAL
53219: IFTRUE 53223
53221: GO 53249
53223: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
53224: LD_ADDR_VAR 0 3
53228: PUSH
53229: LD_INT 21
53231: PUSH
53232: LD_INT 22
53234: PUSH
53235: LD_INT 23
53237: PUSH
53238: LD_INT 24
53240: PUSH
53241: EMPTY
53242: LIST
53243: LIST
53244: LIST
53245: LIST
53246: ST_TO_ADDR
53247: GO 53464
53249: LD_INT 45
53251: DOUBLE
53252: EQUAL
53253: IFTRUE 53257
53255: GO 53283
53257: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
53258: LD_ADDR_VAR 0 3
53262: PUSH
53263: LD_INT 21
53265: PUSH
53266: LD_INT 22
53268: PUSH
53269: LD_INT 23
53271: PUSH
53272: LD_INT 24
53274: PUSH
53275: EMPTY
53276: LIST
53277: LIST
53278: LIST
53279: LIST
53280: ST_TO_ADDR
53281: GO 53464
53283: LD_INT 49
53285: DOUBLE
53286: EQUAL
53287: IFTRUE 53291
53289: GO 53317
53291: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
53292: LD_ADDR_VAR 0 3
53296: PUSH
53297: LD_INT 21
53299: PUSH
53300: LD_INT 22
53302: PUSH
53303: LD_INT 23
53305: PUSH
53306: LD_INT 24
53308: PUSH
53309: EMPTY
53310: LIST
53311: LIST
53312: LIST
53313: LIST
53314: ST_TO_ADDR
53315: GO 53464
53317: LD_INT 51
53319: DOUBLE
53320: EQUAL
53321: IFTRUE 53325
53323: GO 53351
53325: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
53326: LD_ADDR_VAR 0 3
53330: PUSH
53331: LD_INT 21
53333: PUSH
53334: LD_INT 22
53336: PUSH
53337: LD_INT 23
53339: PUSH
53340: LD_INT 24
53342: PUSH
53343: EMPTY
53344: LIST
53345: LIST
53346: LIST
53347: LIST
53348: ST_TO_ADDR
53349: GO 53464
53351: LD_INT 52
53353: DOUBLE
53354: EQUAL
53355: IFTRUE 53359
53357: GO 53385
53359: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
53360: LD_ADDR_VAR 0 3
53364: PUSH
53365: LD_INT 21
53367: PUSH
53368: LD_INT 22
53370: PUSH
53371: LD_INT 23
53373: PUSH
53374: LD_INT 24
53376: PUSH
53377: EMPTY
53378: LIST
53379: LIST
53380: LIST
53381: LIST
53382: ST_TO_ADDR
53383: GO 53464
53385: LD_INT 53
53387: DOUBLE
53388: EQUAL
53389: IFTRUE 53393
53391: GO 53411
53393: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
53394: LD_ADDR_VAR 0 3
53398: PUSH
53399: LD_INT 23
53401: PUSH
53402: LD_INT 24
53404: PUSH
53405: EMPTY
53406: LIST
53407: LIST
53408: ST_TO_ADDR
53409: GO 53464
53411: LD_INT 46
53413: DOUBLE
53414: EQUAL
53415: IFTRUE 53419
53417: GO 53437
53419: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
53420: LD_ADDR_VAR 0 3
53424: PUSH
53425: LD_INT 23
53427: PUSH
53428: LD_INT 24
53430: PUSH
53431: EMPTY
53432: LIST
53433: LIST
53434: ST_TO_ADDR
53435: GO 53464
53437: LD_INT 47
53439: DOUBLE
53440: EQUAL
53441: IFTRUE 53445
53443: GO 53463
53445: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
53446: LD_ADDR_VAR 0 3
53450: PUSH
53451: LD_INT 23
53453: PUSH
53454: LD_INT 24
53456: PUSH
53457: EMPTY
53458: LIST
53459: LIST
53460: ST_TO_ADDR
53461: GO 53464
53463: POP
// result := ( chassis in result ) ;
53464: LD_ADDR_VAR 0 3
53468: PUSH
53469: LD_VAR 0 1
53473: PUSH
53474: LD_VAR 0 3
53478: IN
53479: ST_TO_ADDR
// end ;
53480: LD_VAR 0 3
53484: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
53485: LD_INT 0
53487: PPUSH
53488: PPUSH
53489: PPUSH
53490: PPUSH
53491: PPUSH
53492: PPUSH
53493: PPUSH
// result := array ;
53494: LD_ADDR_VAR 0 5
53498: PUSH
53499: LD_VAR 0 1
53503: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
53504: LD_VAR 0 1
53508: NOT
53509: PUSH
53510: LD_VAR 0 2
53514: NOT
53515: OR
53516: PUSH
53517: LD_VAR 0 3
53521: NOT
53522: OR
53523: PUSH
53524: LD_VAR 0 2
53528: PUSH
53529: LD_VAR 0 1
53533: GREATER
53534: OR
53535: PUSH
53536: LD_VAR 0 3
53540: PUSH
53541: LD_VAR 0 1
53545: GREATER
53546: OR
53547: IFFALSE 53551
// exit ;
53549: GO 53847
// if direction then
53551: LD_VAR 0 4
53555: IFFALSE 53619
// begin d := 1 ;
53557: LD_ADDR_VAR 0 9
53561: PUSH
53562: LD_INT 1
53564: ST_TO_ADDR
// if i_from > i_to then
53565: LD_VAR 0 2
53569: PUSH
53570: LD_VAR 0 3
53574: GREATER
53575: IFFALSE 53601
// length := ( array - i_from ) + i_to else
53577: LD_ADDR_VAR 0 11
53581: PUSH
53582: LD_VAR 0 1
53586: PUSH
53587: LD_VAR 0 2
53591: MINUS
53592: PUSH
53593: LD_VAR 0 3
53597: PLUS
53598: ST_TO_ADDR
53599: GO 53617
// length := i_to - i_from ;
53601: LD_ADDR_VAR 0 11
53605: PUSH
53606: LD_VAR 0 3
53610: PUSH
53611: LD_VAR 0 2
53615: MINUS
53616: ST_TO_ADDR
// end else
53617: GO 53680
// begin d := - 1 ;
53619: LD_ADDR_VAR 0 9
53623: PUSH
53624: LD_INT 1
53626: NEG
53627: ST_TO_ADDR
// if i_from > i_to then
53628: LD_VAR 0 2
53632: PUSH
53633: LD_VAR 0 3
53637: GREATER
53638: IFFALSE 53658
// length := i_from - i_to else
53640: LD_ADDR_VAR 0 11
53644: PUSH
53645: LD_VAR 0 2
53649: PUSH
53650: LD_VAR 0 3
53654: MINUS
53655: ST_TO_ADDR
53656: GO 53680
// length := ( array - i_to ) + i_from ;
53658: LD_ADDR_VAR 0 11
53662: PUSH
53663: LD_VAR 0 1
53667: PUSH
53668: LD_VAR 0 3
53672: MINUS
53673: PUSH
53674: LD_VAR 0 2
53678: PLUS
53679: ST_TO_ADDR
// end ; if not length then
53680: LD_VAR 0 11
53684: NOT
53685: IFFALSE 53689
// exit ;
53687: GO 53847
// tmp := array ;
53689: LD_ADDR_VAR 0 10
53693: PUSH
53694: LD_VAR 0 1
53698: ST_TO_ADDR
// for i = 1 to length do
53699: LD_ADDR_VAR 0 6
53703: PUSH
53704: DOUBLE
53705: LD_INT 1
53707: DEC
53708: ST_TO_ADDR
53709: LD_VAR 0 11
53713: PUSH
53714: FOR_TO
53715: IFFALSE 53835
// begin for j = 1 to array do
53717: LD_ADDR_VAR 0 7
53721: PUSH
53722: DOUBLE
53723: LD_INT 1
53725: DEC
53726: ST_TO_ADDR
53727: LD_VAR 0 1
53731: PUSH
53732: FOR_TO
53733: IFFALSE 53821
// begin k := j + d ;
53735: LD_ADDR_VAR 0 8
53739: PUSH
53740: LD_VAR 0 7
53744: PUSH
53745: LD_VAR 0 9
53749: PLUS
53750: ST_TO_ADDR
// if k > array then
53751: LD_VAR 0 8
53755: PUSH
53756: LD_VAR 0 1
53760: GREATER
53761: IFFALSE 53771
// k := 1 ;
53763: LD_ADDR_VAR 0 8
53767: PUSH
53768: LD_INT 1
53770: ST_TO_ADDR
// if not k then
53771: LD_VAR 0 8
53775: NOT
53776: IFFALSE 53788
// k := array ;
53778: LD_ADDR_VAR 0 8
53782: PUSH
53783: LD_VAR 0 1
53787: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
53788: LD_ADDR_VAR 0 10
53792: PUSH
53793: LD_VAR 0 10
53797: PPUSH
53798: LD_VAR 0 8
53802: PPUSH
53803: LD_VAR 0 1
53807: PUSH
53808: LD_VAR 0 7
53812: ARRAY
53813: PPUSH
53814: CALL_OW 1
53818: ST_TO_ADDR
// end ;
53819: GO 53732
53821: POP
53822: POP
// array := tmp ;
53823: LD_ADDR_VAR 0 1
53827: PUSH
53828: LD_VAR 0 10
53832: ST_TO_ADDR
// end ;
53833: GO 53714
53835: POP
53836: POP
// result := array ;
53837: LD_ADDR_VAR 0 5
53841: PUSH
53842: LD_VAR 0 1
53846: ST_TO_ADDR
// end ;
53847: LD_VAR 0 5
53851: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
53852: LD_INT 0
53854: PPUSH
53855: PPUSH
// result := 0 ;
53856: LD_ADDR_VAR 0 3
53860: PUSH
53861: LD_INT 0
53863: ST_TO_ADDR
// if not array or not value in array then
53864: LD_VAR 0 1
53868: NOT
53869: PUSH
53870: LD_VAR 0 2
53874: PUSH
53875: LD_VAR 0 1
53879: IN
53880: NOT
53881: OR
53882: IFFALSE 53886
// exit ;
53884: GO 53940
// for i = 1 to array do
53886: LD_ADDR_VAR 0 4
53890: PUSH
53891: DOUBLE
53892: LD_INT 1
53894: DEC
53895: ST_TO_ADDR
53896: LD_VAR 0 1
53900: PUSH
53901: FOR_TO
53902: IFFALSE 53938
// if value = array [ i ] then
53904: LD_VAR 0 2
53908: PUSH
53909: LD_VAR 0 1
53913: PUSH
53914: LD_VAR 0 4
53918: ARRAY
53919: EQUAL
53920: IFFALSE 53936
// begin result := i ;
53922: LD_ADDR_VAR 0 3
53926: PUSH
53927: LD_VAR 0 4
53931: ST_TO_ADDR
// exit ;
53932: POP
53933: POP
53934: GO 53940
// end ;
53936: GO 53901
53938: POP
53939: POP
// end ;
53940: LD_VAR 0 3
53944: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
53945: LD_INT 0
53947: PPUSH
// vc_chassis := chassis ;
53948: LD_ADDR_OWVAR 37
53952: PUSH
53953: LD_VAR 0 1
53957: ST_TO_ADDR
// vc_engine := engine ;
53958: LD_ADDR_OWVAR 39
53962: PUSH
53963: LD_VAR 0 2
53967: ST_TO_ADDR
// vc_control := control ;
53968: LD_ADDR_OWVAR 38
53972: PUSH
53973: LD_VAR 0 3
53977: ST_TO_ADDR
// vc_weapon := weapon ;
53978: LD_ADDR_OWVAR 40
53982: PUSH
53983: LD_VAR 0 4
53987: ST_TO_ADDR
// vc_fuel_battery := fuel ;
53988: LD_ADDR_OWVAR 41
53992: PUSH
53993: LD_VAR 0 5
53997: ST_TO_ADDR
// end ;
53998: LD_VAR 0 6
54002: RET
// export function WantPlant ( unit ) ; var task ; begin
54003: LD_INT 0
54005: PPUSH
54006: PPUSH
// result := false ;
54007: LD_ADDR_VAR 0 2
54011: PUSH
54012: LD_INT 0
54014: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
54015: LD_ADDR_VAR 0 3
54019: PUSH
54020: LD_VAR 0 1
54024: PPUSH
54025: CALL_OW 437
54029: ST_TO_ADDR
// if task then
54030: LD_VAR 0 3
54034: IFFALSE 54062
// if task [ 1 ] [ 1 ] = p then
54036: LD_VAR 0 3
54040: PUSH
54041: LD_INT 1
54043: ARRAY
54044: PUSH
54045: LD_INT 1
54047: ARRAY
54048: PUSH
54049: LD_STRING p
54051: EQUAL
54052: IFFALSE 54062
// result := true ;
54054: LD_ADDR_VAR 0 2
54058: PUSH
54059: LD_INT 1
54061: ST_TO_ADDR
// end ;
54062: LD_VAR 0 2
54066: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
54067: LD_INT 0
54069: PPUSH
54070: PPUSH
54071: PPUSH
54072: PPUSH
// if pos < 1 then
54073: LD_VAR 0 2
54077: PUSH
54078: LD_INT 1
54080: LESS
54081: IFFALSE 54085
// exit ;
54083: GO 54388
// if pos = 1 then
54085: LD_VAR 0 2
54089: PUSH
54090: LD_INT 1
54092: EQUAL
54093: IFFALSE 54126
// result := Replace ( arr , pos [ 1 ] , value ) else
54095: LD_ADDR_VAR 0 4
54099: PUSH
54100: LD_VAR 0 1
54104: PPUSH
54105: LD_VAR 0 2
54109: PUSH
54110: LD_INT 1
54112: ARRAY
54113: PPUSH
54114: LD_VAR 0 3
54118: PPUSH
54119: CALL_OW 1
54123: ST_TO_ADDR
54124: GO 54388
// begin tmp := arr ;
54126: LD_ADDR_VAR 0 6
54130: PUSH
54131: LD_VAR 0 1
54135: ST_TO_ADDR
// s_arr := [ tmp ] ;
54136: LD_ADDR_VAR 0 7
54140: PUSH
54141: LD_VAR 0 6
54145: PUSH
54146: EMPTY
54147: LIST
54148: ST_TO_ADDR
// for i = 1 to pos - 1 do
54149: LD_ADDR_VAR 0 5
54153: PUSH
54154: DOUBLE
54155: LD_INT 1
54157: DEC
54158: ST_TO_ADDR
54159: LD_VAR 0 2
54163: PUSH
54164: LD_INT 1
54166: MINUS
54167: PUSH
54168: FOR_TO
54169: IFFALSE 54214
// begin tmp := tmp [ pos [ i ] ] ;
54171: LD_ADDR_VAR 0 6
54175: PUSH
54176: LD_VAR 0 6
54180: PUSH
54181: LD_VAR 0 2
54185: PUSH
54186: LD_VAR 0 5
54190: ARRAY
54191: ARRAY
54192: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
54193: LD_ADDR_VAR 0 7
54197: PUSH
54198: LD_VAR 0 7
54202: PUSH
54203: LD_VAR 0 6
54207: PUSH
54208: EMPTY
54209: LIST
54210: ADD
54211: ST_TO_ADDR
// end ;
54212: GO 54168
54214: POP
54215: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
54216: LD_ADDR_VAR 0 6
54220: PUSH
54221: LD_VAR 0 6
54225: PPUSH
54226: LD_VAR 0 2
54230: PUSH
54231: LD_VAR 0 2
54235: ARRAY
54236: PPUSH
54237: LD_VAR 0 3
54241: PPUSH
54242: CALL_OW 1
54246: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
54247: LD_ADDR_VAR 0 7
54251: PUSH
54252: LD_VAR 0 7
54256: PPUSH
54257: LD_VAR 0 7
54261: PPUSH
54262: LD_VAR 0 6
54266: PPUSH
54267: CALL_OW 1
54271: ST_TO_ADDR
// for i = s_arr downto 2 do
54272: LD_ADDR_VAR 0 5
54276: PUSH
54277: DOUBLE
54278: LD_VAR 0 7
54282: INC
54283: ST_TO_ADDR
54284: LD_INT 2
54286: PUSH
54287: FOR_DOWNTO
54288: IFFALSE 54372
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
54290: LD_ADDR_VAR 0 6
54294: PUSH
54295: LD_VAR 0 7
54299: PUSH
54300: LD_VAR 0 5
54304: PUSH
54305: LD_INT 1
54307: MINUS
54308: ARRAY
54309: PPUSH
54310: LD_VAR 0 2
54314: PUSH
54315: LD_VAR 0 5
54319: PUSH
54320: LD_INT 1
54322: MINUS
54323: ARRAY
54324: PPUSH
54325: LD_VAR 0 7
54329: PUSH
54330: LD_VAR 0 5
54334: ARRAY
54335: PPUSH
54336: CALL_OW 1
54340: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
54341: LD_ADDR_VAR 0 7
54345: PUSH
54346: LD_VAR 0 7
54350: PPUSH
54351: LD_VAR 0 5
54355: PUSH
54356: LD_INT 1
54358: MINUS
54359: PPUSH
54360: LD_VAR 0 6
54364: PPUSH
54365: CALL_OW 1
54369: ST_TO_ADDR
// end ;
54370: GO 54287
54372: POP
54373: POP
// result := s_arr [ 1 ] ;
54374: LD_ADDR_VAR 0 4
54378: PUSH
54379: LD_VAR 0 7
54383: PUSH
54384: LD_INT 1
54386: ARRAY
54387: ST_TO_ADDR
// end ; end ;
54388: LD_VAR 0 4
54392: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
54393: LD_INT 0
54395: PPUSH
54396: PPUSH
// if not list then
54397: LD_VAR 0 1
54401: NOT
54402: IFFALSE 54406
// exit ;
54404: GO 54497
// i := list [ pos1 ] ;
54406: LD_ADDR_VAR 0 5
54410: PUSH
54411: LD_VAR 0 1
54415: PUSH
54416: LD_VAR 0 2
54420: ARRAY
54421: ST_TO_ADDR
// if not i then
54422: LD_VAR 0 5
54426: NOT
54427: IFFALSE 54431
// exit ;
54429: GO 54497
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
54431: LD_ADDR_VAR 0 1
54435: PUSH
54436: LD_VAR 0 1
54440: PPUSH
54441: LD_VAR 0 2
54445: PPUSH
54446: LD_VAR 0 1
54450: PUSH
54451: LD_VAR 0 3
54455: ARRAY
54456: PPUSH
54457: CALL_OW 1
54461: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
54462: LD_ADDR_VAR 0 1
54466: PUSH
54467: LD_VAR 0 1
54471: PPUSH
54472: LD_VAR 0 3
54476: PPUSH
54477: LD_VAR 0 5
54481: PPUSH
54482: CALL_OW 1
54486: ST_TO_ADDR
// result := list ;
54487: LD_ADDR_VAR 0 4
54491: PUSH
54492: LD_VAR 0 1
54496: ST_TO_ADDR
// end ;
54497: LD_VAR 0 4
54501: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
54502: LD_INT 0
54504: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
54505: LD_ADDR_VAR 0 5
54509: PUSH
54510: LD_VAR 0 1
54514: PPUSH
54515: CALL_OW 250
54519: PPUSH
54520: LD_VAR 0 1
54524: PPUSH
54525: CALL_OW 251
54529: PPUSH
54530: LD_VAR 0 2
54534: PPUSH
54535: LD_VAR 0 3
54539: PPUSH
54540: LD_VAR 0 4
54544: PPUSH
54545: CALL 54923 0 5
54549: ST_TO_ADDR
// end ;
54550: LD_VAR 0 5
54554: RET
// export function SortHexesByDistanceFromUnit ( unit , list , asc , mode ) ; var i , j , tmp ; begin
54555: LD_INT 0
54557: PPUSH
54558: PPUSH
54559: PPUSH
54560: PPUSH
// if not list or not unit then
54561: LD_VAR 0 2
54565: NOT
54566: PUSH
54567: LD_VAR 0 1
54571: NOT
54572: OR
54573: IFFALSE 54577
// exit ;
54575: GO 54918
// result := [ ] ;
54577: LD_ADDR_VAR 0 5
54581: PUSH
54582: EMPTY
54583: ST_TO_ADDR
// for i in list do
54584: LD_ADDR_VAR 0 6
54588: PUSH
54589: LD_VAR 0 2
54593: PUSH
54594: FOR_IN
54595: IFFALSE 54813
// begin tmp := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
54597: LD_ADDR_VAR 0 8
54601: PUSH
54602: LD_VAR 0 1
54606: PPUSH
54607: LD_VAR 0 6
54611: PUSH
54612: LD_INT 1
54614: ARRAY
54615: PPUSH
54616: LD_VAR 0 6
54620: PUSH
54621: LD_INT 2
54623: ARRAY
54624: PPUSH
54625: CALL_OW 297
54629: ST_TO_ADDR
// if not Count ( result ) then
54630: LD_VAR 0 5
54634: PPUSH
54635: CALL 51207 0 1
54639: NOT
54640: IFFALSE 54673
// begin result := Join ( result , [ i , tmp ] ) ;
54642: LD_ADDR_VAR 0 5
54646: PUSH
54647: LD_VAR 0 5
54651: PPUSH
54652: LD_VAR 0 6
54656: PUSH
54657: LD_VAR 0 8
54661: PUSH
54662: EMPTY
54663: LIST
54664: LIST
54665: PPUSH
54666: CALL 86807 0 2
54670: ST_TO_ADDR
// continue ;
54671: GO 54594
// end ; if result [ result ] [ 2 ] <= tmp then
54673: LD_VAR 0 5
54677: PUSH
54678: LD_VAR 0 5
54682: ARRAY
54683: PUSH
54684: LD_INT 2
54686: ARRAY
54687: PUSH
54688: LD_VAR 0 8
54692: LESSEQUAL
54693: IFFALSE 54726
// result := Join ( result , [ i , tmp ] ) else
54695: LD_ADDR_VAR 0 5
54699: PUSH
54700: LD_VAR 0 5
54704: PPUSH
54705: LD_VAR 0 6
54709: PUSH
54710: LD_VAR 0 8
54714: PUSH
54715: EMPTY
54716: LIST
54717: LIST
54718: PPUSH
54719: CALL 86807 0 2
54723: ST_TO_ADDR
54724: GO 54811
// begin for j := 1 to Count ( result ) do
54726: LD_ADDR_VAR 0 7
54730: PUSH
54731: DOUBLE
54732: LD_INT 1
54734: DEC
54735: ST_TO_ADDR
54736: LD_VAR 0 5
54740: PPUSH
54741: CALL 51207 0 1
54745: PUSH
54746: FOR_TO
54747: IFFALSE 54809
// begin if tmp < result [ j ] [ 2 ] then
54749: LD_VAR 0 8
54753: PUSH
54754: LD_VAR 0 5
54758: PUSH
54759: LD_VAR 0 7
54763: ARRAY
54764: PUSH
54765: LD_INT 2
54767: ARRAY
54768: LESS
54769: IFFALSE 54807
// begin result := Insert ( result , j , [ i , tmp ] ) ;
54771: LD_ADDR_VAR 0 5
54775: PUSH
54776: LD_VAR 0 5
54780: PPUSH
54781: LD_VAR 0 7
54785: PPUSH
54786: LD_VAR 0 6
54790: PUSH
54791: LD_VAR 0 8
54795: PUSH
54796: EMPTY
54797: LIST
54798: LIST
54799: PPUSH
54800: CALL_OW 2
54804: ST_TO_ADDR
// break ;
54805: GO 54809
// end ; end ;
54807: GO 54746
54809: POP
54810: POP
// end ; end ;
54811: GO 54594
54813: POP
54814: POP
// if result and not asc then
54815: LD_VAR 0 5
54819: PUSH
54820: LD_VAR 0 3
54824: NOT
54825: AND
54826: IFFALSE 54843
// result := ReverseArray ( result ) ;
54828: LD_ADDR_VAR 0 5
54832: PUSH
54833: LD_VAR 0 5
54837: PPUSH
54838: CALL 82083 0 1
54842: ST_TO_ADDR
// tmp := [ ] ;
54843: LD_ADDR_VAR 0 8
54847: PUSH
54848: EMPTY
54849: ST_TO_ADDR
// if mode then
54850: LD_VAR 0 4
54854: IFFALSE 54918
// begin for i := 1 to result do
54856: LD_ADDR_VAR 0 6
54860: PUSH
54861: DOUBLE
54862: LD_INT 1
54864: DEC
54865: ST_TO_ADDR
54866: LD_VAR 0 5
54870: PUSH
54871: FOR_TO
54872: IFFALSE 54906
// tmp := Join ( tmp , result [ i ] [ 1 ] ) ;
54874: LD_ADDR_VAR 0 8
54878: PUSH
54879: LD_VAR 0 8
54883: PPUSH
54884: LD_VAR 0 5
54888: PUSH
54889: LD_VAR 0 6
54893: ARRAY
54894: PUSH
54895: LD_INT 1
54897: ARRAY
54898: PPUSH
54899: CALL 86807 0 2
54903: ST_TO_ADDR
54904: GO 54871
54906: POP
54907: POP
// result := tmp ;
54908: LD_ADDR_VAR 0 5
54912: PUSH
54913: LD_VAR 0 8
54917: ST_TO_ADDR
// end ; end ;
54918: LD_VAR 0 5
54922: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
54923: LD_INT 0
54925: PPUSH
54926: PPUSH
54927: PPUSH
54928: PPUSH
// if not list then
54929: LD_VAR 0 3
54933: NOT
54934: IFFALSE 54938
// exit ;
54936: GO 55326
// result := [ ] ;
54938: LD_ADDR_VAR 0 6
54942: PUSH
54943: EMPTY
54944: ST_TO_ADDR
// for i in list do
54945: LD_ADDR_VAR 0 7
54949: PUSH
54950: LD_VAR 0 3
54954: PUSH
54955: FOR_IN
54956: IFFALSE 55158
// begin tmp := GetDistUnitXY ( i , x , y ) ;
54958: LD_ADDR_VAR 0 9
54962: PUSH
54963: LD_VAR 0 7
54967: PPUSH
54968: LD_VAR 0 1
54972: PPUSH
54973: LD_VAR 0 2
54977: PPUSH
54978: CALL_OW 297
54982: ST_TO_ADDR
// if not result then
54983: LD_VAR 0 6
54987: NOT
54988: IFFALSE 55014
// result := [ [ i , tmp ] ] else
54990: LD_ADDR_VAR 0 6
54994: PUSH
54995: LD_VAR 0 7
54999: PUSH
55000: LD_VAR 0 9
55004: PUSH
55005: EMPTY
55006: LIST
55007: LIST
55008: PUSH
55009: EMPTY
55010: LIST
55011: ST_TO_ADDR
55012: GO 55156
// begin if result [ result ] [ 2 ] < tmp then
55014: LD_VAR 0 6
55018: PUSH
55019: LD_VAR 0 6
55023: ARRAY
55024: PUSH
55025: LD_INT 2
55027: ARRAY
55028: PUSH
55029: LD_VAR 0 9
55033: LESS
55034: IFFALSE 55076
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
55036: LD_ADDR_VAR 0 6
55040: PUSH
55041: LD_VAR 0 6
55045: PPUSH
55046: LD_VAR 0 6
55050: PUSH
55051: LD_INT 1
55053: PLUS
55054: PPUSH
55055: LD_VAR 0 7
55059: PUSH
55060: LD_VAR 0 9
55064: PUSH
55065: EMPTY
55066: LIST
55067: LIST
55068: PPUSH
55069: CALL_OW 2
55073: ST_TO_ADDR
55074: GO 55156
// for j = 1 to result do
55076: LD_ADDR_VAR 0 8
55080: PUSH
55081: DOUBLE
55082: LD_INT 1
55084: DEC
55085: ST_TO_ADDR
55086: LD_VAR 0 6
55090: PUSH
55091: FOR_TO
55092: IFFALSE 55154
// begin if tmp < result [ j ] [ 2 ] then
55094: LD_VAR 0 9
55098: PUSH
55099: LD_VAR 0 6
55103: PUSH
55104: LD_VAR 0 8
55108: ARRAY
55109: PUSH
55110: LD_INT 2
55112: ARRAY
55113: LESS
55114: IFFALSE 55152
// begin result := Insert ( result , j , [ i , tmp ] ) ;
55116: LD_ADDR_VAR 0 6
55120: PUSH
55121: LD_VAR 0 6
55125: PPUSH
55126: LD_VAR 0 8
55130: PPUSH
55131: LD_VAR 0 7
55135: PUSH
55136: LD_VAR 0 9
55140: PUSH
55141: EMPTY
55142: LIST
55143: LIST
55144: PPUSH
55145: CALL_OW 2
55149: ST_TO_ADDR
// break ;
55150: GO 55154
// end ; end ;
55152: GO 55091
55154: POP
55155: POP
// end ; end ;
55156: GO 54955
55158: POP
55159: POP
// if result and not asc then
55160: LD_VAR 0 6
55164: PUSH
55165: LD_VAR 0 4
55169: NOT
55170: AND
55171: IFFALSE 55246
// begin tmp := result ;
55173: LD_ADDR_VAR 0 9
55177: PUSH
55178: LD_VAR 0 6
55182: ST_TO_ADDR
// for i = tmp downto 1 do
55183: LD_ADDR_VAR 0 7
55187: PUSH
55188: DOUBLE
55189: LD_VAR 0 9
55193: INC
55194: ST_TO_ADDR
55195: LD_INT 1
55197: PUSH
55198: FOR_DOWNTO
55199: IFFALSE 55244
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
55201: LD_ADDR_VAR 0 6
55205: PUSH
55206: LD_VAR 0 6
55210: PPUSH
55211: LD_VAR 0 9
55215: PUSH
55216: LD_VAR 0 7
55220: MINUS
55221: PUSH
55222: LD_INT 1
55224: PLUS
55225: PPUSH
55226: LD_VAR 0 9
55230: PUSH
55231: LD_VAR 0 7
55235: ARRAY
55236: PPUSH
55237: CALL_OW 1
55241: ST_TO_ADDR
55242: GO 55198
55244: POP
55245: POP
// end ; tmp := [ ] ;
55246: LD_ADDR_VAR 0 9
55250: PUSH
55251: EMPTY
55252: ST_TO_ADDR
// if mode then
55253: LD_VAR 0 5
55257: IFFALSE 55326
// begin for i = 1 to result do
55259: LD_ADDR_VAR 0 7
55263: PUSH
55264: DOUBLE
55265: LD_INT 1
55267: DEC
55268: ST_TO_ADDR
55269: LD_VAR 0 6
55273: PUSH
55274: FOR_TO
55275: IFFALSE 55314
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
55277: LD_ADDR_VAR 0 9
55281: PUSH
55282: LD_VAR 0 9
55286: PPUSH
55287: LD_VAR 0 7
55291: PPUSH
55292: LD_VAR 0 6
55296: PUSH
55297: LD_VAR 0 7
55301: ARRAY
55302: PUSH
55303: LD_INT 1
55305: ARRAY
55306: PPUSH
55307: CALL_OW 1
55311: ST_TO_ADDR
55312: GO 55274
55314: POP
55315: POP
// result := tmp ;
55316: LD_ADDR_VAR 0 6
55320: PUSH
55321: LD_VAR 0 9
55325: ST_TO_ADDR
// end ; end ;
55326: LD_VAR 0 6
55330: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
55331: LD_INT 0
55333: PPUSH
55334: PPUSH
55335: PPUSH
55336: PPUSH
55337: PPUSH
55338: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
55339: LD_ADDR_VAR 0 5
55343: PUSH
55344: LD_INT 0
55346: PUSH
55347: LD_INT 0
55349: PUSH
55350: LD_INT 0
55352: PUSH
55353: EMPTY
55354: PUSH
55355: EMPTY
55356: LIST
55357: LIST
55358: LIST
55359: LIST
55360: ST_TO_ADDR
// if not x or not y then
55361: LD_VAR 0 2
55365: NOT
55366: PUSH
55367: LD_VAR 0 3
55371: NOT
55372: OR
55373: IFFALSE 55377
// exit ;
55375: GO 57027
// if not range then
55377: LD_VAR 0 4
55381: NOT
55382: IFFALSE 55392
// range := 10 ;
55384: LD_ADDR_VAR 0 4
55388: PUSH
55389: LD_INT 10
55391: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
55392: LD_ADDR_VAR 0 8
55396: PUSH
55397: LD_INT 81
55399: PUSH
55400: LD_VAR 0 1
55404: PUSH
55405: EMPTY
55406: LIST
55407: LIST
55408: PUSH
55409: LD_INT 92
55411: PUSH
55412: LD_VAR 0 2
55416: PUSH
55417: LD_VAR 0 3
55421: PUSH
55422: LD_VAR 0 4
55426: PUSH
55427: EMPTY
55428: LIST
55429: LIST
55430: LIST
55431: LIST
55432: PUSH
55433: LD_INT 3
55435: PUSH
55436: LD_INT 21
55438: PUSH
55439: LD_INT 3
55441: PUSH
55442: EMPTY
55443: LIST
55444: LIST
55445: PUSH
55446: EMPTY
55447: LIST
55448: LIST
55449: PUSH
55450: EMPTY
55451: LIST
55452: LIST
55453: LIST
55454: PPUSH
55455: CALL_OW 69
55459: ST_TO_ADDR
// if not tmp then
55460: LD_VAR 0 8
55464: NOT
55465: IFFALSE 55469
// exit ;
55467: GO 57027
// for i in tmp do
55469: LD_ADDR_VAR 0 6
55473: PUSH
55474: LD_VAR 0 8
55478: PUSH
55479: FOR_IN
55480: IFFALSE 57002
// begin points := [ 0 , 0 , 0 ] ;
55482: LD_ADDR_VAR 0 9
55486: PUSH
55487: LD_INT 0
55489: PUSH
55490: LD_INT 0
55492: PUSH
55493: LD_INT 0
55495: PUSH
55496: EMPTY
55497: LIST
55498: LIST
55499: LIST
55500: ST_TO_ADDR
// bpoints := 1 ;
55501: LD_ADDR_VAR 0 10
55505: PUSH
55506: LD_INT 1
55508: ST_TO_ADDR
// case GetType ( i ) of unit_human :
55509: LD_VAR 0 6
55513: PPUSH
55514: CALL_OW 247
55518: PUSH
55519: LD_INT 1
55521: DOUBLE
55522: EQUAL
55523: IFTRUE 55527
55525: GO 56105
55527: POP
// begin if GetClass ( i ) = 1 then
55528: LD_VAR 0 6
55532: PPUSH
55533: CALL_OW 257
55537: PUSH
55538: LD_INT 1
55540: EQUAL
55541: IFFALSE 55562
// points := [ 10 , 5 , 3 ] ;
55543: LD_ADDR_VAR 0 9
55547: PUSH
55548: LD_INT 10
55550: PUSH
55551: LD_INT 5
55553: PUSH
55554: LD_INT 3
55556: PUSH
55557: EMPTY
55558: LIST
55559: LIST
55560: LIST
55561: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
55562: LD_VAR 0 6
55566: PPUSH
55567: CALL_OW 257
55571: PUSH
55572: LD_INT 2
55574: PUSH
55575: LD_INT 3
55577: PUSH
55578: LD_INT 4
55580: PUSH
55581: EMPTY
55582: LIST
55583: LIST
55584: LIST
55585: IN
55586: IFFALSE 55607
// points := [ 3 , 2 , 1 ] ;
55588: LD_ADDR_VAR 0 9
55592: PUSH
55593: LD_INT 3
55595: PUSH
55596: LD_INT 2
55598: PUSH
55599: LD_INT 1
55601: PUSH
55602: EMPTY
55603: LIST
55604: LIST
55605: LIST
55606: ST_TO_ADDR
// if GetClass ( i ) = 5 then
55607: LD_VAR 0 6
55611: PPUSH
55612: CALL_OW 257
55616: PUSH
55617: LD_INT 5
55619: EQUAL
55620: IFFALSE 55641
// points := [ 130 , 5 , 2 ] ;
55622: LD_ADDR_VAR 0 9
55626: PUSH
55627: LD_INT 130
55629: PUSH
55630: LD_INT 5
55632: PUSH
55633: LD_INT 2
55635: PUSH
55636: EMPTY
55637: LIST
55638: LIST
55639: LIST
55640: ST_TO_ADDR
// if GetClass ( i ) = 8 then
55641: LD_VAR 0 6
55645: PPUSH
55646: CALL_OW 257
55650: PUSH
55651: LD_INT 8
55653: EQUAL
55654: IFFALSE 55675
// points := [ 35 , 35 , 30 ] ;
55656: LD_ADDR_VAR 0 9
55660: PUSH
55661: LD_INT 35
55663: PUSH
55664: LD_INT 35
55666: PUSH
55667: LD_INT 30
55669: PUSH
55670: EMPTY
55671: LIST
55672: LIST
55673: LIST
55674: ST_TO_ADDR
// if GetClass ( i ) = 9 then
55675: LD_VAR 0 6
55679: PPUSH
55680: CALL_OW 257
55684: PUSH
55685: LD_INT 9
55687: EQUAL
55688: IFFALSE 55709
// points := [ 20 , 55 , 40 ] ;
55690: LD_ADDR_VAR 0 9
55694: PUSH
55695: LD_INT 20
55697: PUSH
55698: LD_INT 55
55700: PUSH
55701: LD_INT 40
55703: PUSH
55704: EMPTY
55705: LIST
55706: LIST
55707: LIST
55708: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
55709: LD_VAR 0 6
55713: PPUSH
55714: CALL_OW 257
55718: PUSH
55719: LD_INT 12
55721: PUSH
55722: LD_INT 16
55724: PUSH
55725: EMPTY
55726: LIST
55727: LIST
55728: IN
55729: IFFALSE 55750
// points := [ 5 , 3 , 2 ] ;
55731: LD_ADDR_VAR 0 9
55735: PUSH
55736: LD_INT 5
55738: PUSH
55739: LD_INT 3
55741: PUSH
55742: LD_INT 2
55744: PUSH
55745: EMPTY
55746: LIST
55747: LIST
55748: LIST
55749: ST_TO_ADDR
// if GetClass ( i ) = 17 then
55750: LD_VAR 0 6
55754: PPUSH
55755: CALL_OW 257
55759: PUSH
55760: LD_INT 17
55762: EQUAL
55763: IFFALSE 55784
// points := [ 100 , 50 , 75 ] ;
55765: LD_ADDR_VAR 0 9
55769: PUSH
55770: LD_INT 100
55772: PUSH
55773: LD_INT 50
55775: PUSH
55776: LD_INT 75
55778: PUSH
55779: EMPTY
55780: LIST
55781: LIST
55782: LIST
55783: ST_TO_ADDR
// if GetClass ( i ) = 15 then
55784: LD_VAR 0 6
55788: PPUSH
55789: CALL_OW 257
55793: PUSH
55794: LD_INT 15
55796: EQUAL
55797: IFFALSE 55818
// points := [ 10 , 5 , 3 ] ;
55799: LD_ADDR_VAR 0 9
55803: PUSH
55804: LD_INT 10
55806: PUSH
55807: LD_INT 5
55809: PUSH
55810: LD_INT 3
55812: PUSH
55813: EMPTY
55814: LIST
55815: LIST
55816: LIST
55817: ST_TO_ADDR
// if GetClass ( i ) = 14 then
55818: LD_VAR 0 6
55822: PPUSH
55823: CALL_OW 257
55827: PUSH
55828: LD_INT 14
55830: EQUAL
55831: IFFALSE 55852
// points := [ 10 , 0 , 0 ] ;
55833: LD_ADDR_VAR 0 9
55837: PUSH
55838: LD_INT 10
55840: PUSH
55841: LD_INT 0
55843: PUSH
55844: LD_INT 0
55846: PUSH
55847: EMPTY
55848: LIST
55849: LIST
55850: LIST
55851: ST_TO_ADDR
// if GetClass ( i ) = 11 then
55852: LD_VAR 0 6
55856: PPUSH
55857: CALL_OW 257
55861: PUSH
55862: LD_INT 11
55864: EQUAL
55865: IFFALSE 55886
// points := [ 30 , 10 , 5 ] ;
55867: LD_ADDR_VAR 0 9
55871: PUSH
55872: LD_INT 30
55874: PUSH
55875: LD_INT 10
55877: PUSH
55878: LD_INT 5
55880: PUSH
55881: EMPTY
55882: LIST
55883: LIST
55884: LIST
55885: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
55886: LD_VAR 0 1
55890: PPUSH
55891: LD_INT 5
55893: PPUSH
55894: CALL_OW 321
55898: PUSH
55899: LD_INT 2
55901: EQUAL
55902: IFFALSE 55919
// bpoints := bpoints * 1.8 ;
55904: LD_ADDR_VAR 0 10
55908: PUSH
55909: LD_VAR 0 10
55913: PUSH
55914: LD_REAL  1.80000000000000E+0000
55917: MUL
55918: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
55919: LD_VAR 0 6
55923: PPUSH
55924: CALL_OW 257
55928: PUSH
55929: LD_INT 1
55931: PUSH
55932: LD_INT 2
55934: PUSH
55935: LD_INT 3
55937: PUSH
55938: LD_INT 4
55940: PUSH
55941: EMPTY
55942: LIST
55943: LIST
55944: LIST
55945: LIST
55946: IN
55947: PUSH
55948: LD_VAR 0 1
55952: PPUSH
55953: LD_INT 51
55955: PPUSH
55956: CALL_OW 321
55960: PUSH
55961: LD_INT 2
55963: EQUAL
55964: AND
55965: IFFALSE 55982
// bpoints := bpoints * 1.2 ;
55967: LD_ADDR_VAR 0 10
55971: PUSH
55972: LD_VAR 0 10
55976: PUSH
55977: LD_REAL  1.20000000000000E+0000
55980: MUL
55981: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
55982: LD_VAR 0 6
55986: PPUSH
55987: CALL_OW 257
55991: PUSH
55992: LD_INT 5
55994: PUSH
55995: LD_INT 7
55997: PUSH
55998: LD_INT 9
56000: PUSH
56001: EMPTY
56002: LIST
56003: LIST
56004: LIST
56005: IN
56006: PUSH
56007: LD_VAR 0 1
56011: PPUSH
56012: LD_INT 52
56014: PPUSH
56015: CALL_OW 321
56019: PUSH
56020: LD_INT 2
56022: EQUAL
56023: AND
56024: IFFALSE 56041
// bpoints := bpoints * 1.5 ;
56026: LD_ADDR_VAR 0 10
56030: PUSH
56031: LD_VAR 0 10
56035: PUSH
56036: LD_REAL  1.50000000000000E+0000
56039: MUL
56040: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
56041: LD_VAR 0 1
56045: PPUSH
56046: LD_INT 66
56048: PPUSH
56049: CALL_OW 321
56053: PUSH
56054: LD_INT 2
56056: EQUAL
56057: IFFALSE 56074
// bpoints := bpoints * 1.1 ;
56059: LD_ADDR_VAR 0 10
56063: PUSH
56064: LD_VAR 0 10
56068: PUSH
56069: LD_REAL  1.10000000000000E+0000
56072: MUL
56073: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
56074: LD_ADDR_VAR 0 10
56078: PUSH
56079: LD_VAR 0 10
56083: PUSH
56084: LD_VAR 0 6
56088: PPUSH
56089: LD_INT 1
56091: PPUSH
56092: CALL_OW 259
56096: PUSH
56097: LD_REAL  1.15000000000000E+0000
56100: MUL
56101: MUL
56102: ST_TO_ADDR
// end ; unit_vehicle :
56103: GO 56931
56105: LD_INT 2
56107: DOUBLE
56108: EQUAL
56109: IFTRUE 56113
56111: GO 56919
56113: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
56114: LD_VAR 0 6
56118: PPUSH
56119: CALL_OW 264
56123: PUSH
56124: LD_INT 2
56126: PUSH
56127: LD_INT 42
56129: PUSH
56130: LD_INT 24
56132: PUSH
56133: EMPTY
56134: LIST
56135: LIST
56136: LIST
56137: IN
56138: IFFALSE 56159
// points := [ 25 , 5 , 3 ] ;
56140: LD_ADDR_VAR 0 9
56144: PUSH
56145: LD_INT 25
56147: PUSH
56148: LD_INT 5
56150: PUSH
56151: LD_INT 3
56153: PUSH
56154: EMPTY
56155: LIST
56156: LIST
56157: LIST
56158: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
56159: LD_VAR 0 6
56163: PPUSH
56164: CALL_OW 264
56168: PUSH
56169: LD_INT 4
56171: PUSH
56172: LD_INT 43
56174: PUSH
56175: LD_INT 25
56177: PUSH
56178: EMPTY
56179: LIST
56180: LIST
56181: LIST
56182: IN
56183: IFFALSE 56204
// points := [ 40 , 15 , 5 ] ;
56185: LD_ADDR_VAR 0 9
56189: PUSH
56190: LD_INT 40
56192: PUSH
56193: LD_INT 15
56195: PUSH
56196: LD_INT 5
56198: PUSH
56199: EMPTY
56200: LIST
56201: LIST
56202: LIST
56203: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
56204: LD_VAR 0 6
56208: PPUSH
56209: CALL_OW 264
56213: PUSH
56214: LD_INT 3
56216: PUSH
56217: LD_INT 23
56219: PUSH
56220: EMPTY
56221: LIST
56222: LIST
56223: IN
56224: IFFALSE 56245
// points := [ 7 , 25 , 8 ] ;
56226: LD_ADDR_VAR 0 9
56230: PUSH
56231: LD_INT 7
56233: PUSH
56234: LD_INT 25
56236: PUSH
56237: LD_INT 8
56239: PUSH
56240: EMPTY
56241: LIST
56242: LIST
56243: LIST
56244: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
56245: LD_VAR 0 6
56249: PPUSH
56250: CALL_OW 264
56254: PUSH
56255: LD_INT 5
56257: PUSH
56258: LD_INT 27
56260: PUSH
56261: LD_INT 44
56263: PUSH
56264: EMPTY
56265: LIST
56266: LIST
56267: LIST
56268: IN
56269: IFFALSE 56290
// points := [ 14 , 50 , 16 ] ;
56271: LD_ADDR_VAR 0 9
56275: PUSH
56276: LD_INT 14
56278: PUSH
56279: LD_INT 50
56281: PUSH
56282: LD_INT 16
56284: PUSH
56285: EMPTY
56286: LIST
56287: LIST
56288: LIST
56289: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
56290: LD_VAR 0 6
56294: PPUSH
56295: CALL_OW 264
56299: PUSH
56300: LD_INT 6
56302: PUSH
56303: LD_INT 46
56305: PUSH
56306: EMPTY
56307: LIST
56308: LIST
56309: IN
56310: IFFALSE 56331
// points := [ 32 , 120 , 70 ] ;
56312: LD_ADDR_VAR 0 9
56316: PUSH
56317: LD_INT 32
56319: PUSH
56320: LD_INT 120
56322: PUSH
56323: LD_INT 70
56325: PUSH
56326: EMPTY
56327: LIST
56328: LIST
56329: LIST
56330: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
56331: LD_VAR 0 6
56335: PPUSH
56336: CALL_OW 264
56340: PUSH
56341: LD_INT 7
56343: PUSH
56344: LD_INT 28
56346: PUSH
56347: LD_INT 45
56349: PUSH
56350: LD_INT 92
56352: PUSH
56353: EMPTY
56354: LIST
56355: LIST
56356: LIST
56357: LIST
56358: IN
56359: IFFALSE 56380
// points := [ 35 , 20 , 45 ] ;
56361: LD_ADDR_VAR 0 9
56365: PUSH
56366: LD_INT 35
56368: PUSH
56369: LD_INT 20
56371: PUSH
56372: LD_INT 45
56374: PUSH
56375: EMPTY
56376: LIST
56377: LIST
56378: LIST
56379: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
56380: LD_VAR 0 6
56384: PPUSH
56385: CALL_OW 264
56389: PUSH
56390: LD_INT 47
56392: PUSH
56393: EMPTY
56394: LIST
56395: IN
56396: IFFALSE 56417
// points := [ 67 , 45 , 75 ] ;
56398: LD_ADDR_VAR 0 9
56402: PUSH
56403: LD_INT 67
56405: PUSH
56406: LD_INT 45
56408: PUSH
56409: LD_INT 75
56411: PUSH
56412: EMPTY
56413: LIST
56414: LIST
56415: LIST
56416: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
56417: LD_VAR 0 6
56421: PPUSH
56422: CALL_OW 264
56426: PUSH
56427: LD_INT 26
56429: PUSH
56430: EMPTY
56431: LIST
56432: IN
56433: IFFALSE 56454
// points := [ 120 , 30 , 80 ] ;
56435: LD_ADDR_VAR 0 9
56439: PUSH
56440: LD_INT 120
56442: PUSH
56443: LD_INT 30
56445: PUSH
56446: LD_INT 80
56448: PUSH
56449: EMPTY
56450: LIST
56451: LIST
56452: LIST
56453: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
56454: LD_VAR 0 6
56458: PPUSH
56459: CALL_OW 264
56463: PUSH
56464: LD_INT 22
56466: PUSH
56467: EMPTY
56468: LIST
56469: IN
56470: IFFALSE 56491
// points := [ 40 , 1 , 1 ] ;
56472: LD_ADDR_VAR 0 9
56476: PUSH
56477: LD_INT 40
56479: PUSH
56480: LD_INT 1
56482: PUSH
56483: LD_INT 1
56485: PUSH
56486: EMPTY
56487: LIST
56488: LIST
56489: LIST
56490: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
56491: LD_VAR 0 6
56495: PPUSH
56496: CALL_OW 264
56500: PUSH
56501: LD_INT 29
56503: PUSH
56504: EMPTY
56505: LIST
56506: IN
56507: IFFALSE 56528
// points := [ 70 , 200 , 400 ] ;
56509: LD_ADDR_VAR 0 9
56513: PUSH
56514: LD_INT 70
56516: PUSH
56517: LD_INT 200
56519: PUSH
56520: LD_INT 400
56522: PUSH
56523: EMPTY
56524: LIST
56525: LIST
56526: LIST
56527: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
56528: LD_VAR 0 6
56532: PPUSH
56533: CALL_OW 264
56537: PUSH
56538: LD_INT 14
56540: PUSH
56541: LD_INT 53
56543: PUSH
56544: EMPTY
56545: LIST
56546: LIST
56547: IN
56548: IFFALSE 56569
// points := [ 40 , 10 , 20 ] ;
56550: LD_ADDR_VAR 0 9
56554: PUSH
56555: LD_INT 40
56557: PUSH
56558: LD_INT 10
56560: PUSH
56561: LD_INT 20
56563: PUSH
56564: EMPTY
56565: LIST
56566: LIST
56567: LIST
56568: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
56569: LD_VAR 0 6
56573: PPUSH
56574: CALL_OW 264
56578: PUSH
56579: LD_INT 9
56581: PUSH
56582: EMPTY
56583: LIST
56584: IN
56585: IFFALSE 56606
// points := [ 5 , 70 , 20 ] ;
56587: LD_ADDR_VAR 0 9
56591: PUSH
56592: LD_INT 5
56594: PUSH
56595: LD_INT 70
56597: PUSH
56598: LD_INT 20
56600: PUSH
56601: EMPTY
56602: LIST
56603: LIST
56604: LIST
56605: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
56606: LD_VAR 0 6
56610: PPUSH
56611: CALL_OW 264
56615: PUSH
56616: LD_INT 10
56618: PUSH
56619: EMPTY
56620: LIST
56621: IN
56622: IFFALSE 56643
// points := [ 35 , 110 , 70 ] ;
56624: LD_ADDR_VAR 0 9
56628: PUSH
56629: LD_INT 35
56631: PUSH
56632: LD_INT 110
56634: PUSH
56635: LD_INT 70
56637: PUSH
56638: EMPTY
56639: LIST
56640: LIST
56641: LIST
56642: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
56643: LD_VAR 0 6
56647: PPUSH
56648: CALL_OW 265
56652: PUSH
56653: LD_INT 25
56655: EQUAL
56656: IFFALSE 56677
// points := [ 80 , 65 , 100 ] ;
56658: LD_ADDR_VAR 0 9
56662: PUSH
56663: LD_INT 80
56665: PUSH
56666: LD_INT 65
56668: PUSH
56669: LD_INT 100
56671: PUSH
56672: EMPTY
56673: LIST
56674: LIST
56675: LIST
56676: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
56677: LD_VAR 0 6
56681: PPUSH
56682: CALL_OW 263
56686: PUSH
56687: LD_INT 1
56689: EQUAL
56690: IFFALSE 56725
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
56692: LD_ADDR_VAR 0 10
56696: PUSH
56697: LD_VAR 0 10
56701: PUSH
56702: LD_VAR 0 6
56706: PPUSH
56707: CALL_OW 311
56711: PPUSH
56712: LD_INT 3
56714: PPUSH
56715: CALL_OW 259
56719: PUSH
56720: LD_INT 4
56722: MUL
56723: MUL
56724: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
56725: LD_VAR 0 6
56729: PPUSH
56730: CALL_OW 263
56734: PUSH
56735: LD_INT 2
56737: EQUAL
56738: IFFALSE 56789
// begin j := IsControledBy ( i ) ;
56740: LD_ADDR_VAR 0 7
56744: PUSH
56745: LD_VAR 0 6
56749: PPUSH
56750: CALL_OW 312
56754: ST_TO_ADDR
// if j then
56755: LD_VAR 0 7
56759: IFFALSE 56789
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
56761: LD_ADDR_VAR 0 10
56765: PUSH
56766: LD_VAR 0 10
56770: PUSH
56771: LD_VAR 0 7
56775: PPUSH
56776: LD_INT 3
56778: PPUSH
56779: CALL_OW 259
56783: PUSH
56784: LD_INT 3
56786: MUL
56787: MUL
56788: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
56789: LD_VAR 0 6
56793: PPUSH
56794: CALL_OW 264
56798: PUSH
56799: LD_INT 5
56801: PUSH
56802: LD_INT 6
56804: PUSH
56805: LD_INT 46
56807: PUSH
56808: LD_INT 44
56810: PUSH
56811: LD_INT 47
56813: PUSH
56814: LD_INT 45
56816: PUSH
56817: LD_INT 28
56819: PUSH
56820: LD_INT 7
56822: PUSH
56823: LD_INT 27
56825: PUSH
56826: LD_INT 29
56828: PUSH
56829: EMPTY
56830: LIST
56831: LIST
56832: LIST
56833: LIST
56834: LIST
56835: LIST
56836: LIST
56837: LIST
56838: LIST
56839: LIST
56840: IN
56841: PUSH
56842: LD_VAR 0 1
56846: PPUSH
56847: LD_INT 52
56849: PPUSH
56850: CALL_OW 321
56854: PUSH
56855: LD_INT 2
56857: EQUAL
56858: AND
56859: IFFALSE 56876
// bpoints := bpoints * 1.2 ;
56861: LD_ADDR_VAR 0 10
56865: PUSH
56866: LD_VAR 0 10
56870: PUSH
56871: LD_REAL  1.20000000000000E+0000
56874: MUL
56875: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
56876: LD_VAR 0 6
56880: PPUSH
56881: CALL_OW 264
56885: PUSH
56886: LD_INT 6
56888: PUSH
56889: LD_INT 46
56891: PUSH
56892: LD_INT 47
56894: PUSH
56895: EMPTY
56896: LIST
56897: LIST
56898: LIST
56899: IN
56900: IFFALSE 56917
// bpoints := bpoints * 1.2 ;
56902: LD_ADDR_VAR 0 10
56906: PUSH
56907: LD_VAR 0 10
56911: PUSH
56912: LD_REAL  1.20000000000000E+0000
56915: MUL
56916: ST_TO_ADDR
// end ; unit_building :
56917: GO 56931
56919: LD_INT 3
56921: DOUBLE
56922: EQUAL
56923: IFTRUE 56927
56925: GO 56930
56927: POP
// ; end ;
56928: GO 56931
56930: POP
// for j = 1 to 3 do
56931: LD_ADDR_VAR 0 7
56935: PUSH
56936: DOUBLE
56937: LD_INT 1
56939: DEC
56940: ST_TO_ADDR
56941: LD_INT 3
56943: PUSH
56944: FOR_TO
56945: IFFALSE 56998
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
56947: LD_ADDR_VAR 0 5
56951: PUSH
56952: LD_VAR 0 5
56956: PPUSH
56957: LD_VAR 0 7
56961: PPUSH
56962: LD_VAR 0 5
56966: PUSH
56967: LD_VAR 0 7
56971: ARRAY
56972: PUSH
56973: LD_VAR 0 9
56977: PUSH
56978: LD_VAR 0 7
56982: ARRAY
56983: PUSH
56984: LD_VAR 0 10
56988: MUL
56989: PLUS
56990: PPUSH
56991: CALL_OW 1
56995: ST_TO_ADDR
56996: GO 56944
56998: POP
56999: POP
// end ;
57000: GO 55479
57002: POP
57003: POP
// result := Replace ( result , 4 , tmp ) ;
57004: LD_ADDR_VAR 0 5
57008: PUSH
57009: LD_VAR 0 5
57013: PPUSH
57014: LD_INT 4
57016: PPUSH
57017: LD_VAR 0 8
57021: PPUSH
57022: CALL_OW 1
57026: ST_TO_ADDR
// end ;
57027: LD_VAR 0 5
57031: RET
// export function DangerAtRange ( unit , range ) ; begin
57032: LD_INT 0
57034: PPUSH
// if not unit then
57035: LD_VAR 0 1
57039: NOT
57040: IFFALSE 57044
// exit ;
57042: GO 57089
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
57044: LD_ADDR_VAR 0 3
57048: PUSH
57049: LD_VAR 0 1
57053: PPUSH
57054: CALL_OW 255
57058: PPUSH
57059: LD_VAR 0 1
57063: PPUSH
57064: CALL_OW 250
57068: PPUSH
57069: LD_VAR 0 1
57073: PPUSH
57074: CALL_OW 251
57078: PPUSH
57079: LD_VAR 0 2
57083: PPUSH
57084: CALL 55331 0 4
57088: ST_TO_ADDR
// end ;
57089: LD_VAR 0 3
57093: RET
// export function DangerInArea ( side , area ) ; begin
57094: LD_INT 0
57096: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
57097: LD_ADDR_VAR 0 3
57101: PUSH
57102: LD_VAR 0 2
57106: PPUSH
57107: LD_INT 81
57109: PUSH
57110: LD_VAR 0 1
57114: PUSH
57115: EMPTY
57116: LIST
57117: LIST
57118: PPUSH
57119: CALL_OW 70
57123: ST_TO_ADDR
// end ;
57124: LD_VAR 0 3
57128: RET
// export function IsExtension ( b ) ; begin
57129: LD_INT 0
57131: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
57132: LD_ADDR_VAR 0 2
57136: PUSH
57137: LD_VAR 0 1
57141: PUSH
57142: LD_INT 23
57144: PUSH
57145: LD_INT 20
57147: PUSH
57148: LD_INT 22
57150: PUSH
57151: LD_INT 17
57153: PUSH
57154: LD_INT 24
57156: PUSH
57157: LD_INT 21
57159: PUSH
57160: LD_INT 19
57162: PUSH
57163: LD_INT 16
57165: PUSH
57166: LD_INT 25
57168: PUSH
57169: LD_INT 18
57171: PUSH
57172: EMPTY
57173: LIST
57174: LIST
57175: LIST
57176: LIST
57177: LIST
57178: LIST
57179: LIST
57180: LIST
57181: LIST
57182: LIST
57183: IN
57184: ST_TO_ADDR
// end ;
57185: LD_VAR 0 2
57189: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
57190: LD_INT 0
57192: PPUSH
57193: PPUSH
57194: PPUSH
// result := [ ] ;
57195: LD_ADDR_VAR 0 4
57199: PUSH
57200: EMPTY
57201: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
57202: LD_ADDR_VAR 0 5
57206: PUSH
57207: LD_VAR 0 2
57211: PPUSH
57212: LD_INT 21
57214: PUSH
57215: LD_INT 3
57217: PUSH
57218: EMPTY
57219: LIST
57220: LIST
57221: PPUSH
57222: CALL_OW 70
57226: ST_TO_ADDR
// if not tmp then
57227: LD_VAR 0 5
57231: NOT
57232: IFFALSE 57236
// exit ;
57234: GO 57300
// if checkLink then
57236: LD_VAR 0 3
57240: IFFALSE 57290
// begin for i in tmp do
57242: LD_ADDR_VAR 0 6
57246: PUSH
57247: LD_VAR 0 5
57251: PUSH
57252: FOR_IN
57253: IFFALSE 57288
// if GetBase ( i ) <> base then
57255: LD_VAR 0 6
57259: PPUSH
57260: CALL_OW 274
57264: PUSH
57265: LD_VAR 0 1
57269: NONEQUAL
57270: IFFALSE 57286
// ComLinkToBase ( base , i ) ;
57272: LD_VAR 0 1
57276: PPUSH
57277: LD_VAR 0 6
57281: PPUSH
57282: CALL_OW 169
57286: GO 57252
57288: POP
57289: POP
// end ; result := tmp ;
57290: LD_ADDR_VAR 0 4
57294: PUSH
57295: LD_VAR 0 5
57299: ST_TO_ADDR
// end ;
57300: LD_VAR 0 4
57304: RET
// export function ComComplete ( units , b ) ; var i ; begin
57305: LD_INT 0
57307: PPUSH
57308: PPUSH
// if not units then
57309: LD_VAR 0 1
57313: NOT
57314: IFFALSE 57318
// exit ;
57316: GO 57408
// for i in units do
57318: LD_ADDR_VAR 0 4
57322: PUSH
57323: LD_VAR 0 1
57327: PUSH
57328: FOR_IN
57329: IFFALSE 57406
// if BuildingStatus ( b ) = bs_build then
57331: LD_VAR 0 2
57335: PPUSH
57336: CALL_OW 461
57340: PUSH
57341: LD_INT 1
57343: EQUAL
57344: IFFALSE 57404
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
57346: LD_VAR 0 4
57350: PPUSH
57351: LD_STRING h
57353: PUSH
57354: LD_VAR 0 2
57358: PPUSH
57359: CALL_OW 250
57363: PUSH
57364: LD_VAR 0 2
57368: PPUSH
57369: CALL_OW 251
57373: PUSH
57374: LD_VAR 0 2
57378: PUSH
57379: LD_INT 0
57381: PUSH
57382: LD_INT 0
57384: PUSH
57385: LD_INT 0
57387: PUSH
57388: EMPTY
57389: LIST
57390: LIST
57391: LIST
57392: LIST
57393: LIST
57394: LIST
57395: LIST
57396: PUSH
57397: EMPTY
57398: LIST
57399: PPUSH
57400: CALL_OW 446
57404: GO 57328
57406: POP
57407: POP
// end ;
57408: LD_VAR 0 3
57412: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
57413: LD_INT 0
57415: PPUSH
57416: PPUSH
57417: PPUSH
57418: PPUSH
57419: PPUSH
57420: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
57421: LD_VAR 0 1
57425: NOT
57426: PUSH
57427: LD_VAR 0 1
57431: PPUSH
57432: CALL_OW 263
57436: PUSH
57437: LD_INT 2
57439: NONEQUAL
57440: OR
57441: IFFALSE 57445
// exit ;
57443: GO 57761
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
57445: LD_ADDR_VAR 0 6
57449: PUSH
57450: LD_INT 22
57452: PUSH
57453: LD_VAR 0 1
57457: PPUSH
57458: CALL_OW 255
57462: PUSH
57463: EMPTY
57464: LIST
57465: LIST
57466: PUSH
57467: LD_INT 2
57469: PUSH
57470: LD_INT 30
57472: PUSH
57473: LD_INT 36
57475: PUSH
57476: EMPTY
57477: LIST
57478: LIST
57479: PUSH
57480: LD_INT 34
57482: PUSH
57483: LD_INT 31
57485: PUSH
57486: EMPTY
57487: LIST
57488: LIST
57489: PUSH
57490: EMPTY
57491: LIST
57492: LIST
57493: LIST
57494: PUSH
57495: EMPTY
57496: LIST
57497: LIST
57498: PPUSH
57499: CALL_OW 69
57503: ST_TO_ADDR
// if not tmp then
57504: LD_VAR 0 6
57508: NOT
57509: IFFALSE 57513
// exit ;
57511: GO 57761
// result := [ ] ;
57513: LD_ADDR_VAR 0 2
57517: PUSH
57518: EMPTY
57519: ST_TO_ADDR
// for i in tmp do
57520: LD_ADDR_VAR 0 3
57524: PUSH
57525: LD_VAR 0 6
57529: PUSH
57530: FOR_IN
57531: IFFALSE 57602
// begin t := UnitsInside ( i ) ;
57533: LD_ADDR_VAR 0 4
57537: PUSH
57538: LD_VAR 0 3
57542: PPUSH
57543: CALL_OW 313
57547: ST_TO_ADDR
// if t then
57548: LD_VAR 0 4
57552: IFFALSE 57600
// for j in t do
57554: LD_ADDR_VAR 0 7
57558: PUSH
57559: LD_VAR 0 4
57563: PUSH
57564: FOR_IN
57565: IFFALSE 57598
// result := Replace ( result , result + 1 , j ) ;
57567: LD_ADDR_VAR 0 2
57571: PUSH
57572: LD_VAR 0 2
57576: PPUSH
57577: LD_VAR 0 2
57581: PUSH
57582: LD_INT 1
57584: PLUS
57585: PPUSH
57586: LD_VAR 0 7
57590: PPUSH
57591: CALL_OW 1
57595: ST_TO_ADDR
57596: GO 57564
57598: POP
57599: POP
// end ;
57600: GO 57530
57602: POP
57603: POP
// if not result then
57604: LD_VAR 0 2
57608: NOT
57609: IFFALSE 57613
// exit ;
57611: GO 57761
// mech := result [ 1 ] ;
57613: LD_ADDR_VAR 0 5
57617: PUSH
57618: LD_VAR 0 2
57622: PUSH
57623: LD_INT 1
57625: ARRAY
57626: ST_TO_ADDR
// if result > 1 then
57627: LD_VAR 0 2
57631: PUSH
57632: LD_INT 1
57634: GREATER
57635: IFFALSE 57747
// begin for i = 2 to result do
57637: LD_ADDR_VAR 0 3
57641: PUSH
57642: DOUBLE
57643: LD_INT 2
57645: DEC
57646: ST_TO_ADDR
57647: LD_VAR 0 2
57651: PUSH
57652: FOR_TO
57653: IFFALSE 57745
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
57655: LD_ADDR_VAR 0 4
57659: PUSH
57660: LD_VAR 0 2
57664: PUSH
57665: LD_VAR 0 3
57669: ARRAY
57670: PPUSH
57671: LD_INT 3
57673: PPUSH
57674: CALL_OW 259
57678: PUSH
57679: LD_VAR 0 2
57683: PUSH
57684: LD_VAR 0 3
57688: ARRAY
57689: PPUSH
57690: CALL_OW 432
57694: MINUS
57695: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
57696: LD_VAR 0 4
57700: PUSH
57701: LD_VAR 0 5
57705: PPUSH
57706: LD_INT 3
57708: PPUSH
57709: CALL_OW 259
57713: PUSH
57714: LD_VAR 0 5
57718: PPUSH
57719: CALL_OW 432
57723: MINUS
57724: GREATEREQUAL
57725: IFFALSE 57743
// mech := result [ i ] ;
57727: LD_ADDR_VAR 0 5
57731: PUSH
57732: LD_VAR 0 2
57736: PUSH
57737: LD_VAR 0 3
57741: ARRAY
57742: ST_TO_ADDR
// end ;
57743: GO 57652
57745: POP
57746: POP
// end ; ComLinkTo ( vehicle , mech ) ;
57747: LD_VAR 0 1
57751: PPUSH
57752: LD_VAR 0 5
57756: PPUSH
57757: CALL_OW 135
// end ;
57761: LD_VAR 0 2
57765: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
57766: LD_INT 0
57768: PPUSH
57769: PPUSH
57770: PPUSH
57771: PPUSH
57772: PPUSH
57773: PPUSH
57774: PPUSH
57775: PPUSH
57776: PPUSH
57777: PPUSH
57778: PPUSH
57779: PPUSH
57780: PPUSH
// result := [ ] ;
57781: LD_ADDR_VAR 0 7
57785: PUSH
57786: EMPTY
57787: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
57788: LD_VAR 0 1
57792: PPUSH
57793: CALL_OW 266
57797: PUSH
57798: LD_INT 0
57800: PUSH
57801: LD_INT 1
57803: PUSH
57804: EMPTY
57805: LIST
57806: LIST
57807: IN
57808: NOT
57809: IFFALSE 57813
// exit ;
57811: GO 59447
// if name then
57813: LD_VAR 0 3
57817: IFFALSE 57833
// SetBName ( base_dep , name ) ;
57819: LD_VAR 0 1
57823: PPUSH
57824: LD_VAR 0 3
57828: PPUSH
57829: CALL_OW 500
// base := GetBase ( base_dep ) ;
57833: LD_ADDR_VAR 0 15
57837: PUSH
57838: LD_VAR 0 1
57842: PPUSH
57843: CALL_OW 274
57847: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
57848: LD_ADDR_VAR 0 16
57852: PUSH
57853: LD_VAR 0 1
57857: PPUSH
57858: CALL_OW 255
57862: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
57863: LD_ADDR_VAR 0 17
57867: PUSH
57868: LD_VAR 0 1
57872: PPUSH
57873: CALL_OW 248
57877: ST_TO_ADDR
// if sources then
57878: LD_VAR 0 5
57882: IFFALSE 57929
// for i = 1 to 3 do
57884: LD_ADDR_VAR 0 8
57888: PUSH
57889: DOUBLE
57890: LD_INT 1
57892: DEC
57893: ST_TO_ADDR
57894: LD_INT 3
57896: PUSH
57897: FOR_TO
57898: IFFALSE 57927
// AddResourceType ( base , i , sources [ i ] ) ;
57900: LD_VAR 0 15
57904: PPUSH
57905: LD_VAR 0 8
57909: PPUSH
57910: LD_VAR 0 5
57914: PUSH
57915: LD_VAR 0 8
57919: ARRAY
57920: PPUSH
57921: CALL_OW 276
57925: GO 57897
57927: POP
57928: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
57929: LD_ADDR_VAR 0 18
57933: PUSH
57934: LD_VAR 0 15
57938: PPUSH
57939: LD_VAR 0 2
57943: PPUSH
57944: LD_INT 1
57946: PPUSH
57947: CALL 57190 0 3
57951: ST_TO_ADDR
// InitHc ;
57952: CALL_OW 19
// InitUc ;
57956: CALL_OW 18
// uc_side := side ;
57960: LD_ADDR_OWVAR 20
57964: PUSH
57965: LD_VAR 0 16
57969: ST_TO_ADDR
// uc_nation := nation ;
57970: LD_ADDR_OWVAR 21
57974: PUSH
57975: LD_VAR 0 17
57979: ST_TO_ADDR
// if buildings then
57980: LD_VAR 0 18
57984: IFFALSE 59306
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
57986: LD_ADDR_VAR 0 19
57990: PUSH
57991: LD_VAR 0 18
57995: PPUSH
57996: LD_INT 2
57998: PUSH
57999: LD_INT 30
58001: PUSH
58002: LD_INT 29
58004: PUSH
58005: EMPTY
58006: LIST
58007: LIST
58008: PUSH
58009: LD_INT 30
58011: PUSH
58012: LD_INT 30
58014: PUSH
58015: EMPTY
58016: LIST
58017: LIST
58018: PUSH
58019: EMPTY
58020: LIST
58021: LIST
58022: LIST
58023: PPUSH
58024: CALL_OW 72
58028: ST_TO_ADDR
// if tmp then
58029: LD_VAR 0 19
58033: IFFALSE 58081
// for i in tmp do
58035: LD_ADDR_VAR 0 8
58039: PUSH
58040: LD_VAR 0 19
58044: PUSH
58045: FOR_IN
58046: IFFALSE 58079
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
58048: LD_VAR 0 8
58052: PPUSH
58053: CALL_OW 250
58057: PPUSH
58058: LD_VAR 0 8
58062: PPUSH
58063: CALL_OW 251
58067: PPUSH
58068: LD_VAR 0 16
58072: PPUSH
58073: CALL_OW 441
58077: GO 58045
58079: POP
58080: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
58081: LD_VAR 0 18
58085: PPUSH
58086: LD_INT 2
58088: PUSH
58089: LD_INT 30
58091: PUSH
58092: LD_INT 32
58094: PUSH
58095: EMPTY
58096: LIST
58097: LIST
58098: PUSH
58099: LD_INT 30
58101: PUSH
58102: LD_INT 33
58104: PUSH
58105: EMPTY
58106: LIST
58107: LIST
58108: PUSH
58109: EMPTY
58110: LIST
58111: LIST
58112: LIST
58113: PPUSH
58114: CALL_OW 72
58118: IFFALSE 58206
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
58120: LD_ADDR_VAR 0 8
58124: PUSH
58125: LD_VAR 0 18
58129: PPUSH
58130: LD_INT 2
58132: PUSH
58133: LD_INT 30
58135: PUSH
58136: LD_INT 32
58138: PUSH
58139: EMPTY
58140: LIST
58141: LIST
58142: PUSH
58143: LD_INT 30
58145: PUSH
58146: LD_INT 33
58148: PUSH
58149: EMPTY
58150: LIST
58151: LIST
58152: PUSH
58153: EMPTY
58154: LIST
58155: LIST
58156: LIST
58157: PPUSH
58158: CALL_OW 72
58162: PUSH
58163: FOR_IN
58164: IFFALSE 58204
// begin if not GetBWeapon ( i ) then
58166: LD_VAR 0 8
58170: PPUSH
58171: CALL_OW 269
58175: NOT
58176: IFFALSE 58202
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
58178: LD_VAR 0 8
58182: PPUSH
58183: LD_VAR 0 8
58187: PPUSH
58188: LD_VAR 0 2
58192: PPUSH
58193: CALL 59452 0 2
58197: PPUSH
58198: CALL_OW 431
// end ;
58202: GO 58163
58204: POP
58205: POP
// end ; for i = 1 to personel do
58206: LD_ADDR_VAR 0 8
58210: PUSH
58211: DOUBLE
58212: LD_INT 1
58214: DEC
58215: ST_TO_ADDR
58216: LD_VAR 0 6
58220: PUSH
58221: FOR_TO
58222: IFFALSE 59286
// begin if i > 4 then
58224: LD_VAR 0 8
58228: PUSH
58229: LD_INT 4
58231: GREATER
58232: IFFALSE 58236
// break ;
58234: GO 59286
// case i of 1 :
58236: LD_VAR 0 8
58240: PUSH
58241: LD_INT 1
58243: DOUBLE
58244: EQUAL
58245: IFTRUE 58249
58247: GO 58329
58249: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
58250: LD_ADDR_VAR 0 12
58254: PUSH
58255: LD_VAR 0 18
58259: PPUSH
58260: LD_INT 22
58262: PUSH
58263: LD_VAR 0 16
58267: PUSH
58268: EMPTY
58269: LIST
58270: LIST
58271: PUSH
58272: LD_INT 58
58274: PUSH
58275: EMPTY
58276: LIST
58277: PUSH
58278: LD_INT 2
58280: PUSH
58281: LD_INT 30
58283: PUSH
58284: LD_INT 32
58286: PUSH
58287: EMPTY
58288: LIST
58289: LIST
58290: PUSH
58291: LD_INT 30
58293: PUSH
58294: LD_INT 4
58296: PUSH
58297: EMPTY
58298: LIST
58299: LIST
58300: PUSH
58301: LD_INT 30
58303: PUSH
58304: LD_INT 5
58306: PUSH
58307: EMPTY
58308: LIST
58309: LIST
58310: PUSH
58311: EMPTY
58312: LIST
58313: LIST
58314: LIST
58315: LIST
58316: PUSH
58317: EMPTY
58318: LIST
58319: LIST
58320: LIST
58321: PPUSH
58322: CALL_OW 72
58326: ST_TO_ADDR
58327: GO 58551
58329: LD_INT 2
58331: DOUBLE
58332: EQUAL
58333: IFTRUE 58337
58335: GO 58399
58337: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
58338: LD_ADDR_VAR 0 12
58342: PUSH
58343: LD_VAR 0 18
58347: PPUSH
58348: LD_INT 22
58350: PUSH
58351: LD_VAR 0 16
58355: PUSH
58356: EMPTY
58357: LIST
58358: LIST
58359: PUSH
58360: LD_INT 2
58362: PUSH
58363: LD_INT 30
58365: PUSH
58366: LD_INT 0
58368: PUSH
58369: EMPTY
58370: LIST
58371: LIST
58372: PUSH
58373: LD_INT 30
58375: PUSH
58376: LD_INT 1
58378: PUSH
58379: EMPTY
58380: LIST
58381: LIST
58382: PUSH
58383: EMPTY
58384: LIST
58385: LIST
58386: LIST
58387: PUSH
58388: EMPTY
58389: LIST
58390: LIST
58391: PPUSH
58392: CALL_OW 72
58396: ST_TO_ADDR
58397: GO 58551
58399: LD_INT 3
58401: DOUBLE
58402: EQUAL
58403: IFTRUE 58407
58405: GO 58469
58407: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
58408: LD_ADDR_VAR 0 12
58412: PUSH
58413: LD_VAR 0 18
58417: PPUSH
58418: LD_INT 22
58420: PUSH
58421: LD_VAR 0 16
58425: PUSH
58426: EMPTY
58427: LIST
58428: LIST
58429: PUSH
58430: LD_INT 2
58432: PUSH
58433: LD_INT 30
58435: PUSH
58436: LD_INT 2
58438: PUSH
58439: EMPTY
58440: LIST
58441: LIST
58442: PUSH
58443: LD_INT 30
58445: PUSH
58446: LD_INT 3
58448: PUSH
58449: EMPTY
58450: LIST
58451: LIST
58452: PUSH
58453: EMPTY
58454: LIST
58455: LIST
58456: LIST
58457: PUSH
58458: EMPTY
58459: LIST
58460: LIST
58461: PPUSH
58462: CALL_OW 72
58466: ST_TO_ADDR
58467: GO 58551
58469: LD_INT 4
58471: DOUBLE
58472: EQUAL
58473: IFTRUE 58477
58475: GO 58550
58477: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
58478: LD_ADDR_VAR 0 12
58482: PUSH
58483: LD_VAR 0 18
58487: PPUSH
58488: LD_INT 22
58490: PUSH
58491: LD_VAR 0 16
58495: PUSH
58496: EMPTY
58497: LIST
58498: LIST
58499: PUSH
58500: LD_INT 2
58502: PUSH
58503: LD_INT 30
58505: PUSH
58506: LD_INT 6
58508: PUSH
58509: EMPTY
58510: LIST
58511: LIST
58512: PUSH
58513: LD_INT 30
58515: PUSH
58516: LD_INT 7
58518: PUSH
58519: EMPTY
58520: LIST
58521: LIST
58522: PUSH
58523: LD_INT 30
58525: PUSH
58526: LD_INT 8
58528: PUSH
58529: EMPTY
58530: LIST
58531: LIST
58532: PUSH
58533: EMPTY
58534: LIST
58535: LIST
58536: LIST
58537: LIST
58538: PUSH
58539: EMPTY
58540: LIST
58541: LIST
58542: PPUSH
58543: CALL_OW 72
58547: ST_TO_ADDR
58548: GO 58551
58550: POP
// if i = 1 then
58551: LD_VAR 0 8
58555: PUSH
58556: LD_INT 1
58558: EQUAL
58559: IFFALSE 58670
// begin tmp := [ ] ;
58561: LD_ADDR_VAR 0 19
58565: PUSH
58566: EMPTY
58567: ST_TO_ADDR
// for j in f do
58568: LD_ADDR_VAR 0 9
58572: PUSH
58573: LD_VAR 0 12
58577: PUSH
58578: FOR_IN
58579: IFFALSE 58652
// if GetBType ( j ) = b_bunker then
58581: LD_VAR 0 9
58585: PPUSH
58586: CALL_OW 266
58590: PUSH
58591: LD_INT 32
58593: EQUAL
58594: IFFALSE 58621
// tmp := Insert ( tmp , 1 , j ) else
58596: LD_ADDR_VAR 0 19
58600: PUSH
58601: LD_VAR 0 19
58605: PPUSH
58606: LD_INT 1
58608: PPUSH
58609: LD_VAR 0 9
58613: PPUSH
58614: CALL_OW 2
58618: ST_TO_ADDR
58619: GO 58650
// tmp := Insert ( tmp , tmp + 1 , j ) ;
58621: LD_ADDR_VAR 0 19
58625: PUSH
58626: LD_VAR 0 19
58630: PPUSH
58631: LD_VAR 0 19
58635: PUSH
58636: LD_INT 1
58638: PLUS
58639: PPUSH
58640: LD_VAR 0 9
58644: PPUSH
58645: CALL_OW 2
58649: ST_TO_ADDR
58650: GO 58578
58652: POP
58653: POP
// if tmp then
58654: LD_VAR 0 19
58658: IFFALSE 58670
// f := tmp ;
58660: LD_ADDR_VAR 0 12
58664: PUSH
58665: LD_VAR 0 19
58669: ST_TO_ADDR
// end ; x := personel [ i ] ;
58670: LD_ADDR_VAR 0 13
58674: PUSH
58675: LD_VAR 0 6
58679: PUSH
58680: LD_VAR 0 8
58684: ARRAY
58685: ST_TO_ADDR
// if x = - 1 then
58686: LD_VAR 0 13
58690: PUSH
58691: LD_INT 1
58693: NEG
58694: EQUAL
58695: IFFALSE 58904
// begin for j in f do
58697: LD_ADDR_VAR 0 9
58701: PUSH
58702: LD_VAR 0 12
58706: PUSH
58707: FOR_IN
58708: IFFALSE 58900
// repeat InitHc ;
58710: CALL_OW 19
// if GetBType ( j ) = b_barracks then
58714: LD_VAR 0 9
58718: PPUSH
58719: CALL_OW 266
58723: PUSH
58724: LD_INT 5
58726: EQUAL
58727: IFFALSE 58797
// begin if UnitsInside ( j ) < 3 then
58729: LD_VAR 0 9
58733: PPUSH
58734: CALL_OW 313
58738: PUSH
58739: LD_INT 3
58741: LESS
58742: IFFALSE 58778
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
58744: LD_INT 0
58746: PPUSH
58747: LD_INT 5
58749: PUSH
58750: LD_INT 8
58752: PUSH
58753: LD_INT 9
58755: PUSH
58756: EMPTY
58757: LIST
58758: LIST
58759: LIST
58760: PUSH
58761: LD_VAR 0 17
58765: ARRAY
58766: PPUSH
58767: LD_VAR 0 4
58771: PPUSH
58772: CALL_OW 380
58776: GO 58795
// PrepareHuman ( false , i , skill ) ;
58778: LD_INT 0
58780: PPUSH
58781: LD_VAR 0 8
58785: PPUSH
58786: LD_VAR 0 4
58790: PPUSH
58791: CALL_OW 380
// end else
58795: GO 58814
// PrepareHuman ( false , i , skill ) ;
58797: LD_INT 0
58799: PPUSH
58800: LD_VAR 0 8
58804: PPUSH
58805: LD_VAR 0 4
58809: PPUSH
58810: CALL_OW 380
// un := CreateHuman ;
58814: LD_ADDR_VAR 0 14
58818: PUSH
58819: CALL_OW 44
58823: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58824: LD_ADDR_VAR 0 7
58828: PUSH
58829: LD_VAR 0 7
58833: PPUSH
58834: LD_INT 1
58836: PPUSH
58837: LD_VAR 0 14
58841: PPUSH
58842: CALL_OW 2
58846: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
58847: LD_VAR 0 14
58851: PPUSH
58852: LD_VAR 0 9
58856: PPUSH
58857: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
58861: LD_VAR 0 9
58865: PPUSH
58866: CALL_OW 313
58870: PUSH
58871: LD_INT 6
58873: EQUAL
58874: PUSH
58875: LD_VAR 0 9
58879: PPUSH
58880: CALL_OW 266
58884: PUSH
58885: LD_INT 32
58887: PUSH
58888: LD_INT 31
58890: PUSH
58891: EMPTY
58892: LIST
58893: LIST
58894: IN
58895: OR
58896: IFFALSE 58710
58898: GO 58707
58900: POP
58901: POP
// end else
58902: GO 59284
// for j = 1 to x do
58904: LD_ADDR_VAR 0 9
58908: PUSH
58909: DOUBLE
58910: LD_INT 1
58912: DEC
58913: ST_TO_ADDR
58914: LD_VAR 0 13
58918: PUSH
58919: FOR_TO
58920: IFFALSE 59282
// begin InitHc ;
58922: CALL_OW 19
// if not f then
58926: LD_VAR 0 12
58930: NOT
58931: IFFALSE 59020
// begin PrepareHuman ( false , i , skill ) ;
58933: LD_INT 0
58935: PPUSH
58936: LD_VAR 0 8
58940: PPUSH
58941: LD_VAR 0 4
58945: PPUSH
58946: CALL_OW 380
// un := CreateHuman ;
58950: LD_ADDR_VAR 0 14
58954: PUSH
58955: CALL_OW 44
58959: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58960: LD_ADDR_VAR 0 7
58964: PUSH
58965: LD_VAR 0 7
58969: PPUSH
58970: LD_INT 1
58972: PPUSH
58973: LD_VAR 0 14
58977: PPUSH
58978: CALL_OW 2
58982: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
58983: LD_VAR 0 14
58987: PPUSH
58988: LD_VAR 0 1
58992: PPUSH
58993: CALL_OW 250
58997: PPUSH
58998: LD_VAR 0 1
59002: PPUSH
59003: CALL_OW 251
59007: PPUSH
59008: LD_INT 10
59010: PPUSH
59011: LD_INT 0
59013: PPUSH
59014: CALL_OW 50
// continue ;
59018: GO 58919
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
59020: LD_VAR 0 12
59024: PUSH
59025: LD_INT 1
59027: ARRAY
59028: PPUSH
59029: CALL_OW 313
59033: PUSH
59034: LD_VAR 0 12
59038: PUSH
59039: LD_INT 1
59041: ARRAY
59042: PPUSH
59043: CALL_OW 266
59047: PUSH
59048: LD_INT 32
59050: PUSH
59051: LD_INT 31
59053: PUSH
59054: EMPTY
59055: LIST
59056: LIST
59057: IN
59058: AND
59059: PUSH
59060: LD_VAR 0 12
59064: PUSH
59065: LD_INT 1
59067: ARRAY
59068: PPUSH
59069: CALL_OW 313
59073: PUSH
59074: LD_INT 6
59076: EQUAL
59077: OR
59078: IFFALSE 59098
// f := Delete ( f , 1 ) ;
59080: LD_ADDR_VAR 0 12
59084: PUSH
59085: LD_VAR 0 12
59089: PPUSH
59090: LD_INT 1
59092: PPUSH
59093: CALL_OW 3
59097: ST_TO_ADDR
// if not f then
59098: LD_VAR 0 12
59102: NOT
59103: IFFALSE 59121
// begin x := x + 2 ;
59105: LD_ADDR_VAR 0 13
59109: PUSH
59110: LD_VAR 0 13
59114: PUSH
59115: LD_INT 2
59117: PLUS
59118: ST_TO_ADDR
// continue ;
59119: GO 58919
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
59121: LD_VAR 0 12
59125: PUSH
59126: LD_INT 1
59128: ARRAY
59129: PPUSH
59130: CALL_OW 266
59134: PUSH
59135: LD_INT 5
59137: EQUAL
59138: IFFALSE 59212
// begin if UnitsInside ( f [ 1 ] ) < 3 then
59140: LD_VAR 0 12
59144: PUSH
59145: LD_INT 1
59147: ARRAY
59148: PPUSH
59149: CALL_OW 313
59153: PUSH
59154: LD_INT 3
59156: LESS
59157: IFFALSE 59193
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
59159: LD_INT 0
59161: PPUSH
59162: LD_INT 5
59164: PUSH
59165: LD_INT 8
59167: PUSH
59168: LD_INT 9
59170: PUSH
59171: EMPTY
59172: LIST
59173: LIST
59174: LIST
59175: PUSH
59176: LD_VAR 0 17
59180: ARRAY
59181: PPUSH
59182: LD_VAR 0 4
59186: PPUSH
59187: CALL_OW 380
59191: GO 59210
// PrepareHuman ( false , i , skill ) ;
59193: LD_INT 0
59195: PPUSH
59196: LD_VAR 0 8
59200: PPUSH
59201: LD_VAR 0 4
59205: PPUSH
59206: CALL_OW 380
// end else
59210: GO 59229
// PrepareHuman ( false , i , skill ) ;
59212: LD_INT 0
59214: PPUSH
59215: LD_VAR 0 8
59219: PPUSH
59220: LD_VAR 0 4
59224: PPUSH
59225: CALL_OW 380
// un := CreateHuman ;
59229: LD_ADDR_VAR 0 14
59233: PUSH
59234: CALL_OW 44
59238: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
59239: LD_ADDR_VAR 0 7
59243: PUSH
59244: LD_VAR 0 7
59248: PPUSH
59249: LD_INT 1
59251: PPUSH
59252: LD_VAR 0 14
59256: PPUSH
59257: CALL_OW 2
59261: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
59262: LD_VAR 0 14
59266: PPUSH
59267: LD_VAR 0 12
59271: PUSH
59272: LD_INT 1
59274: ARRAY
59275: PPUSH
59276: CALL_OW 52
// end ;
59280: GO 58919
59282: POP
59283: POP
// end ;
59284: GO 58221
59286: POP
59287: POP
// result := result ^ buildings ;
59288: LD_ADDR_VAR 0 7
59292: PUSH
59293: LD_VAR 0 7
59297: PUSH
59298: LD_VAR 0 18
59302: ADD
59303: ST_TO_ADDR
// end else
59304: GO 59447
// begin for i = 1 to personel do
59306: LD_ADDR_VAR 0 8
59310: PUSH
59311: DOUBLE
59312: LD_INT 1
59314: DEC
59315: ST_TO_ADDR
59316: LD_VAR 0 6
59320: PUSH
59321: FOR_TO
59322: IFFALSE 59445
// begin if i > 4 then
59324: LD_VAR 0 8
59328: PUSH
59329: LD_INT 4
59331: GREATER
59332: IFFALSE 59336
// break ;
59334: GO 59445
// x := personel [ i ] ;
59336: LD_ADDR_VAR 0 13
59340: PUSH
59341: LD_VAR 0 6
59345: PUSH
59346: LD_VAR 0 8
59350: ARRAY
59351: ST_TO_ADDR
// if x = - 1 then
59352: LD_VAR 0 13
59356: PUSH
59357: LD_INT 1
59359: NEG
59360: EQUAL
59361: IFFALSE 59365
// continue ;
59363: GO 59321
// PrepareHuman ( false , i , skill ) ;
59365: LD_INT 0
59367: PPUSH
59368: LD_VAR 0 8
59372: PPUSH
59373: LD_VAR 0 4
59377: PPUSH
59378: CALL_OW 380
// un := CreateHuman ;
59382: LD_ADDR_VAR 0 14
59386: PUSH
59387: CALL_OW 44
59391: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
59392: LD_VAR 0 14
59396: PPUSH
59397: LD_VAR 0 1
59401: PPUSH
59402: CALL_OW 250
59406: PPUSH
59407: LD_VAR 0 1
59411: PPUSH
59412: CALL_OW 251
59416: PPUSH
59417: LD_INT 10
59419: PPUSH
59420: LD_INT 0
59422: PPUSH
59423: CALL_OW 50
// result := result ^ un ;
59427: LD_ADDR_VAR 0 7
59431: PUSH
59432: LD_VAR 0 7
59436: PUSH
59437: LD_VAR 0 14
59441: ADD
59442: ST_TO_ADDR
// end ;
59443: GO 59321
59445: POP
59446: POP
// end ; end ;
59447: LD_VAR 0 7
59451: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
59452: LD_INT 0
59454: PPUSH
59455: PPUSH
59456: PPUSH
59457: PPUSH
59458: PPUSH
59459: PPUSH
59460: PPUSH
59461: PPUSH
59462: PPUSH
59463: PPUSH
59464: PPUSH
59465: PPUSH
59466: PPUSH
59467: PPUSH
59468: PPUSH
59469: PPUSH
// result := false ;
59470: LD_ADDR_VAR 0 3
59474: PUSH
59475: LD_INT 0
59477: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
59478: LD_VAR 0 1
59482: NOT
59483: PUSH
59484: LD_VAR 0 1
59488: PPUSH
59489: CALL_OW 266
59493: PUSH
59494: LD_INT 32
59496: PUSH
59497: LD_INT 33
59499: PUSH
59500: EMPTY
59501: LIST
59502: LIST
59503: IN
59504: NOT
59505: OR
59506: IFFALSE 59510
// exit ;
59508: GO 60619
// nat := GetNation ( tower ) ;
59510: LD_ADDR_VAR 0 12
59514: PUSH
59515: LD_VAR 0 1
59519: PPUSH
59520: CALL_OW 248
59524: ST_TO_ADDR
// side := GetSide ( tower ) ;
59525: LD_ADDR_VAR 0 16
59529: PUSH
59530: LD_VAR 0 1
59534: PPUSH
59535: CALL_OW 255
59539: ST_TO_ADDR
// x := GetX ( tower ) ;
59540: LD_ADDR_VAR 0 10
59544: PUSH
59545: LD_VAR 0 1
59549: PPUSH
59550: CALL_OW 250
59554: ST_TO_ADDR
// y := GetY ( tower ) ;
59555: LD_ADDR_VAR 0 11
59559: PUSH
59560: LD_VAR 0 1
59564: PPUSH
59565: CALL_OW 251
59569: ST_TO_ADDR
// if not x or not y then
59570: LD_VAR 0 10
59574: NOT
59575: PUSH
59576: LD_VAR 0 11
59580: NOT
59581: OR
59582: IFFALSE 59586
// exit ;
59584: GO 60619
// weapon := 0 ;
59586: LD_ADDR_VAR 0 18
59590: PUSH
59591: LD_INT 0
59593: ST_TO_ADDR
// fac_list := [ ] ;
59594: LD_ADDR_VAR 0 17
59598: PUSH
59599: EMPTY
59600: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
59601: LD_ADDR_VAR 0 6
59605: PUSH
59606: LD_VAR 0 1
59610: PPUSH
59611: CALL_OW 274
59615: PPUSH
59616: LD_VAR 0 2
59620: PPUSH
59621: LD_INT 0
59623: PPUSH
59624: CALL 57190 0 3
59628: PPUSH
59629: LD_INT 30
59631: PUSH
59632: LD_INT 3
59634: PUSH
59635: EMPTY
59636: LIST
59637: LIST
59638: PPUSH
59639: CALL_OW 72
59643: ST_TO_ADDR
// if not factories then
59644: LD_VAR 0 6
59648: NOT
59649: IFFALSE 59653
// exit ;
59651: GO 60619
// for i in factories do
59653: LD_ADDR_VAR 0 8
59657: PUSH
59658: LD_VAR 0 6
59662: PUSH
59663: FOR_IN
59664: IFFALSE 59689
// fac_list := fac_list union AvailableWeaponList ( i ) ;
59666: LD_ADDR_VAR 0 17
59670: PUSH
59671: LD_VAR 0 17
59675: PUSH
59676: LD_VAR 0 8
59680: PPUSH
59681: CALL_OW 478
59685: UNION
59686: ST_TO_ADDR
59687: GO 59663
59689: POP
59690: POP
// if not fac_list then
59691: LD_VAR 0 17
59695: NOT
59696: IFFALSE 59700
// exit ;
59698: GO 60619
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
59700: LD_ADDR_VAR 0 5
59704: PUSH
59705: LD_INT 4
59707: PUSH
59708: LD_INT 5
59710: PUSH
59711: LD_INT 9
59713: PUSH
59714: LD_INT 10
59716: PUSH
59717: LD_INT 6
59719: PUSH
59720: LD_INT 7
59722: PUSH
59723: LD_INT 11
59725: PUSH
59726: EMPTY
59727: LIST
59728: LIST
59729: LIST
59730: LIST
59731: LIST
59732: LIST
59733: LIST
59734: PUSH
59735: LD_INT 27
59737: PUSH
59738: LD_INT 28
59740: PUSH
59741: LD_INT 26
59743: PUSH
59744: LD_INT 30
59746: PUSH
59747: EMPTY
59748: LIST
59749: LIST
59750: LIST
59751: LIST
59752: PUSH
59753: LD_INT 43
59755: PUSH
59756: LD_INT 44
59758: PUSH
59759: LD_INT 46
59761: PUSH
59762: LD_INT 45
59764: PUSH
59765: LD_INT 47
59767: PUSH
59768: LD_INT 49
59770: PUSH
59771: EMPTY
59772: LIST
59773: LIST
59774: LIST
59775: LIST
59776: LIST
59777: LIST
59778: PUSH
59779: EMPTY
59780: LIST
59781: LIST
59782: LIST
59783: PUSH
59784: LD_VAR 0 12
59788: ARRAY
59789: ST_TO_ADDR
// list := list isect fac_list ;
59790: LD_ADDR_VAR 0 5
59794: PUSH
59795: LD_VAR 0 5
59799: PUSH
59800: LD_VAR 0 17
59804: ISECT
59805: ST_TO_ADDR
// if not list then
59806: LD_VAR 0 5
59810: NOT
59811: IFFALSE 59815
// exit ;
59813: GO 60619
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
59815: LD_VAR 0 12
59819: PUSH
59820: LD_INT 3
59822: EQUAL
59823: PUSH
59824: LD_INT 49
59826: PUSH
59827: LD_VAR 0 5
59831: IN
59832: AND
59833: PUSH
59834: LD_INT 31
59836: PPUSH
59837: LD_VAR 0 16
59841: PPUSH
59842: CALL_OW 321
59846: PUSH
59847: LD_INT 2
59849: EQUAL
59850: AND
59851: IFFALSE 59911
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
59853: LD_INT 22
59855: PUSH
59856: LD_VAR 0 16
59860: PUSH
59861: EMPTY
59862: LIST
59863: LIST
59864: PUSH
59865: LD_INT 35
59867: PUSH
59868: LD_INT 49
59870: PUSH
59871: EMPTY
59872: LIST
59873: LIST
59874: PUSH
59875: LD_INT 91
59877: PUSH
59878: LD_VAR 0 1
59882: PUSH
59883: LD_INT 10
59885: PUSH
59886: EMPTY
59887: LIST
59888: LIST
59889: LIST
59890: PUSH
59891: EMPTY
59892: LIST
59893: LIST
59894: LIST
59895: PPUSH
59896: CALL_OW 69
59900: NOT
59901: IFFALSE 59911
// weapon := ru_time_lapser ;
59903: LD_ADDR_VAR 0 18
59907: PUSH
59908: LD_INT 49
59910: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
59911: LD_VAR 0 12
59915: PUSH
59916: LD_INT 1
59918: PUSH
59919: LD_INT 2
59921: PUSH
59922: EMPTY
59923: LIST
59924: LIST
59925: IN
59926: PUSH
59927: LD_INT 11
59929: PUSH
59930: LD_VAR 0 5
59934: IN
59935: PUSH
59936: LD_INT 30
59938: PUSH
59939: LD_VAR 0 5
59943: IN
59944: OR
59945: AND
59946: PUSH
59947: LD_INT 6
59949: PPUSH
59950: LD_VAR 0 16
59954: PPUSH
59955: CALL_OW 321
59959: PUSH
59960: LD_INT 2
59962: EQUAL
59963: AND
59964: IFFALSE 60129
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
59966: LD_INT 22
59968: PUSH
59969: LD_VAR 0 16
59973: PUSH
59974: EMPTY
59975: LIST
59976: LIST
59977: PUSH
59978: LD_INT 2
59980: PUSH
59981: LD_INT 35
59983: PUSH
59984: LD_INT 11
59986: PUSH
59987: EMPTY
59988: LIST
59989: LIST
59990: PUSH
59991: LD_INT 35
59993: PUSH
59994: LD_INT 30
59996: PUSH
59997: EMPTY
59998: LIST
59999: LIST
60000: PUSH
60001: EMPTY
60002: LIST
60003: LIST
60004: LIST
60005: PUSH
60006: LD_INT 91
60008: PUSH
60009: LD_VAR 0 1
60013: PUSH
60014: LD_INT 18
60016: PUSH
60017: EMPTY
60018: LIST
60019: LIST
60020: LIST
60021: PUSH
60022: EMPTY
60023: LIST
60024: LIST
60025: LIST
60026: PPUSH
60027: CALL_OW 69
60031: NOT
60032: PUSH
60033: LD_INT 22
60035: PUSH
60036: LD_VAR 0 16
60040: PUSH
60041: EMPTY
60042: LIST
60043: LIST
60044: PUSH
60045: LD_INT 2
60047: PUSH
60048: LD_INT 30
60050: PUSH
60051: LD_INT 32
60053: PUSH
60054: EMPTY
60055: LIST
60056: LIST
60057: PUSH
60058: LD_INT 30
60060: PUSH
60061: LD_INT 33
60063: PUSH
60064: EMPTY
60065: LIST
60066: LIST
60067: PUSH
60068: EMPTY
60069: LIST
60070: LIST
60071: LIST
60072: PUSH
60073: LD_INT 91
60075: PUSH
60076: LD_VAR 0 1
60080: PUSH
60081: LD_INT 12
60083: PUSH
60084: EMPTY
60085: LIST
60086: LIST
60087: LIST
60088: PUSH
60089: EMPTY
60090: LIST
60091: LIST
60092: LIST
60093: PUSH
60094: EMPTY
60095: LIST
60096: PPUSH
60097: CALL_OW 69
60101: PUSH
60102: LD_INT 2
60104: GREATER
60105: AND
60106: IFFALSE 60129
// weapon := [ us_radar , ar_radar ] [ nat ] ;
60108: LD_ADDR_VAR 0 18
60112: PUSH
60113: LD_INT 11
60115: PUSH
60116: LD_INT 30
60118: PUSH
60119: EMPTY
60120: LIST
60121: LIST
60122: PUSH
60123: LD_VAR 0 12
60127: ARRAY
60128: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
60129: LD_VAR 0 18
60133: NOT
60134: PUSH
60135: LD_INT 40
60137: PPUSH
60138: LD_VAR 0 16
60142: PPUSH
60143: CALL_OW 321
60147: PUSH
60148: LD_INT 2
60150: EQUAL
60151: AND
60152: PUSH
60153: LD_INT 7
60155: PUSH
60156: LD_VAR 0 5
60160: IN
60161: PUSH
60162: LD_INT 28
60164: PUSH
60165: LD_VAR 0 5
60169: IN
60170: OR
60171: PUSH
60172: LD_INT 45
60174: PUSH
60175: LD_VAR 0 5
60179: IN
60180: OR
60181: AND
60182: IFFALSE 60436
// begin hex := GetHexInfo ( x , y ) ;
60184: LD_ADDR_VAR 0 4
60188: PUSH
60189: LD_VAR 0 10
60193: PPUSH
60194: LD_VAR 0 11
60198: PPUSH
60199: CALL_OW 546
60203: ST_TO_ADDR
// if hex [ 1 ] then
60204: LD_VAR 0 4
60208: PUSH
60209: LD_INT 1
60211: ARRAY
60212: IFFALSE 60216
// exit ;
60214: GO 60619
// height := hex [ 2 ] ;
60216: LD_ADDR_VAR 0 15
60220: PUSH
60221: LD_VAR 0 4
60225: PUSH
60226: LD_INT 2
60228: ARRAY
60229: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
60230: LD_ADDR_VAR 0 14
60234: PUSH
60235: LD_INT 0
60237: PUSH
60238: LD_INT 2
60240: PUSH
60241: LD_INT 3
60243: PUSH
60244: LD_INT 5
60246: PUSH
60247: EMPTY
60248: LIST
60249: LIST
60250: LIST
60251: LIST
60252: ST_TO_ADDR
// for i in tmp do
60253: LD_ADDR_VAR 0 8
60257: PUSH
60258: LD_VAR 0 14
60262: PUSH
60263: FOR_IN
60264: IFFALSE 60434
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
60266: LD_ADDR_VAR 0 9
60270: PUSH
60271: LD_VAR 0 10
60275: PPUSH
60276: LD_VAR 0 8
60280: PPUSH
60281: LD_INT 5
60283: PPUSH
60284: CALL_OW 272
60288: PUSH
60289: LD_VAR 0 11
60293: PPUSH
60294: LD_VAR 0 8
60298: PPUSH
60299: LD_INT 5
60301: PPUSH
60302: CALL_OW 273
60306: PUSH
60307: EMPTY
60308: LIST
60309: LIST
60310: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
60311: LD_VAR 0 9
60315: PUSH
60316: LD_INT 1
60318: ARRAY
60319: PPUSH
60320: LD_VAR 0 9
60324: PUSH
60325: LD_INT 2
60327: ARRAY
60328: PPUSH
60329: CALL_OW 488
60333: IFFALSE 60432
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
60335: LD_ADDR_VAR 0 4
60339: PUSH
60340: LD_VAR 0 9
60344: PUSH
60345: LD_INT 1
60347: ARRAY
60348: PPUSH
60349: LD_VAR 0 9
60353: PUSH
60354: LD_INT 2
60356: ARRAY
60357: PPUSH
60358: CALL_OW 546
60362: ST_TO_ADDR
// if hex [ 1 ] then
60363: LD_VAR 0 4
60367: PUSH
60368: LD_INT 1
60370: ARRAY
60371: IFFALSE 60375
// continue ;
60373: GO 60263
// h := hex [ 2 ] ;
60375: LD_ADDR_VAR 0 13
60379: PUSH
60380: LD_VAR 0 4
60384: PUSH
60385: LD_INT 2
60387: ARRAY
60388: ST_TO_ADDR
// if h + 7 < height then
60389: LD_VAR 0 13
60393: PUSH
60394: LD_INT 7
60396: PLUS
60397: PUSH
60398: LD_VAR 0 15
60402: LESS
60403: IFFALSE 60432
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
60405: LD_ADDR_VAR 0 18
60409: PUSH
60410: LD_INT 7
60412: PUSH
60413: LD_INT 28
60415: PUSH
60416: LD_INT 45
60418: PUSH
60419: EMPTY
60420: LIST
60421: LIST
60422: LIST
60423: PUSH
60424: LD_VAR 0 12
60428: ARRAY
60429: ST_TO_ADDR
// break ;
60430: GO 60434
// end ; end ; end ;
60432: GO 60263
60434: POP
60435: POP
// end ; if not weapon then
60436: LD_VAR 0 18
60440: NOT
60441: IFFALSE 60501
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
60443: LD_ADDR_VAR 0 5
60447: PUSH
60448: LD_VAR 0 5
60452: PUSH
60453: LD_INT 11
60455: PUSH
60456: LD_INT 30
60458: PUSH
60459: LD_INT 49
60461: PUSH
60462: EMPTY
60463: LIST
60464: LIST
60465: LIST
60466: DIFF
60467: ST_TO_ADDR
// if not list then
60468: LD_VAR 0 5
60472: NOT
60473: IFFALSE 60477
// exit ;
60475: GO 60619
// weapon := list [ rand ( 1 , list ) ] ;
60477: LD_ADDR_VAR 0 18
60481: PUSH
60482: LD_VAR 0 5
60486: PUSH
60487: LD_INT 1
60489: PPUSH
60490: LD_VAR 0 5
60494: PPUSH
60495: CALL_OW 12
60499: ARRAY
60500: ST_TO_ADDR
// end ; if weapon then
60501: LD_VAR 0 18
60505: IFFALSE 60619
// begin tmp := CostOfWeapon ( weapon ) ;
60507: LD_ADDR_VAR 0 14
60511: PUSH
60512: LD_VAR 0 18
60516: PPUSH
60517: CALL_OW 451
60521: ST_TO_ADDR
// j := GetBase ( tower ) ;
60522: LD_ADDR_VAR 0 9
60526: PUSH
60527: LD_VAR 0 1
60531: PPUSH
60532: CALL_OW 274
60536: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
60537: LD_VAR 0 9
60541: PPUSH
60542: LD_INT 1
60544: PPUSH
60545: CALL_OW 275
60549: PUSH
60550: LD_VAR 0 14
60554: PUSH
60555: LD_INT 1
60557: ARRAY
60558: GREATEREQUAL
60559: PUSH
60560: LD_VAR 0 9
60564: PPUSH
60565: LD_INT 2
60567: PPUSH
60568: CALL_OW 275
60572: PUSH
60573: LD_VAR 0 14
60577: PUSH
60578: LD_INT 2
60580: ARRAY
60581: GREATEREQUAL
60582: AND
60583: PUSH
60584: LD_VAR 0 9
60588: PPUSH
60589: LD_INT 3
60591: PPUSH
60592: CALL_OW 275
60596: PUSH
60597: LD_VAR 0 14
60601: PUSH
60602: LD_INT 3
60604: ARRAY
60605: GREATEREQUAL
60606: AND
60607: IFFALSE 60619
// result := weapon ;
60609: LD_ADDR_VAR 0 3
60613: PUSH
60614: LD_VAR 0 18
60618: ST_TO_ADDR
// end ; end ;
60619: LD_VAR 0 3
60623: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
60624: LD_INT 0
60626: PPUSH
60627: PPUSH
// result := true ;
60628: LD_ADDR_VAR 0 3
60632: PUSH
60633: LD_INT 1
60635: ST_TO_ADDR
// if array1 = array2 then
60636: LD_VAR 0 1
60640: PUSH
60641: LD_VAR 0 2
60645: EQUAL
60646: IFFALSE 60706
// begin for i = 1 to array1 do
60648: LD_ADDR_VAR 0 4
60652: PUSH
60653: DOUBLE
60654: LD_INT 1
60656: DEC
60657: ST_TO_ADDR
60658: LD_VAR 0 1
60662: PUSH
60663: FOR_TO
60664: IFFALSE 60702
// if array1 [ i ] <> array2 [ i ] then
60666: LD_VAR 0 1
60670: PUSH
60671: LD_VAR 0 4
60675: ARRAY
60676: PUSH
60677: LD_VAR 0 2
60681: PUSH
60682: LD_VAR 0 4
60686: ARRAY
60687: NONEQUAL
60688: IFFALSE 60700
// begin result := false ;
60690: LD_ADDR_VAR 0 3
60694: PUSH
60695: LD_INT 0
60697: ST_TO_ADDR
// break ;
60698: GO 60702
// end ;
60700: GO 60663
60702: POP
60703: POP
// end else
60704: GO 60714
// result := false ;
60706: LD_ADDR_VAR 0 3
60710: PUSH
60711: LD_INT 0
60713: ST_TO_ADDR
// end ;
60714: LD_VAR 0 3
60718: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
60719: LD_INT 0
60721: PPUSH
60722: PPUSH
// if not array1 or not array2 then
60723: LD_VAR 0 1
60727: NOT
60728: PUSH
60729: LD_VAR 0 2
60733: NOT
60734: OR
60735: IFFALSE 60739
// exit ;
60737: GO 60803
// result := true ;
60739: LD_ADDR_VAR 0 3
60743: PUSH
60744: LD_INT 1
60746: ST_TO_ADDR
// for i = 1 to array1 do
60747: LD_ADDR_VAR 0 4
60751: PUSH
60752: DOUBLE
60753: LD_INT 1
60755: DEC
60756: ST_TO_ADDR
60757: LD_VAR 0 1
60761: PUSH
60762: FOR_TO
60763: IFFALSE 60801
// if array1 [ i ] <> array2 [ i ] then
60765: LD_VAR 0 1
60769: PUSH
60770: LD_VAR 0 4
60774: ARRAY
60775: PUSH
60776: LD_VAR 0 2
60780: PUSH
60781: LD_VAR 0 4
60785: ARRAY
60786: NONEQUAL
60787: IFFALSE 60799
// begin result := false ;
60789: LD_ADDR_VAR 0 3
60793: PUSH
60794: LD_INT 0
60796: ST_TO_ADDR
// break ;
60797: GO 60801
// end ;
60799: GO 60762
60801: POP
60802: POP
// end ;
60803: LD_VAR 0 3
60807: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
60808: LD_INT 0
60810: PPUSH
60811: PPUSH
60812: PPUSH
// pom := GetBase ( fac ) ;
60813: LD_ADDR_VAR 0 5
60817: PUSH
60818: LD_VAR 0 1
60822: PPUSH
60823: CALL_OW 274
60827: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
60828: LD_ADDR_VAR 0 4
60832: PUSH
60833: LD_VAR 0 2
60837: PUSH
60838: LD_INT 1
60840: ARRAY
60841: PPUSH
60842: LD_VAR 0 2
60846: PUSH
60847: LD_INT 2
60849: ARRAY
60850: PPUSH
60851: LD_VAR 0 2
60855: PUSH
60856: LD_INT 3
60858: ARRAY
60859: PPUSH
60860: LD_VAR 0 2
60864: PUSH
60865: LD_INT 4
60867: ARRAY
60868: PPUSH
60869: CALL_OW 449
60873: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60874: LD_ADDR_VAR 0 3
60878: PUSH
60879: LD_VAR 0 5
60883: PPUSH
60884: LD_INT 1
60886: PPUSH
60887: CALL_OW 275
60891: PUSH
60892: LD_VAR 0 4
60896: PUSH
60897: LD_INT 1
60899: ARRAY
60900: GREATEREQUAL
60901: PUSH
60902: LD_VAR 0 5
60906: PPUSH
60907: LD_INT 2
60909: PPUSH
60910: CALL_OW 275
60914: PUSH
60915: LD_VAR 0 4
60919: PUSH
60920: LD_INT 2
60922: ARRAY
60923: GREATEREQUAL
60924: AND
60925: PUSH
60926: LD_VAR 0 5
60930: PPUSH
60931: LD_INT 3
60933: PPUSH
60934: CALL_OW 275
60938: PUSH
60939: LD_VAR 0 4
60943: PUSH
60944: LD_INT 3
60946: ARRAY
60947: GREATEREQUAL
60948: AND
60949: ST_TO_ADDR
// end ;
60950: LD_VAR 0 3
60954: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
60955: LD_INT 0
60957: PPUSH
60958: PPUSH
60959: PPUSH
60960: PPUSH
// pom := GetBase ( building ) ;
60961: LD_ADDR_VAR 0 3
60965: PUSH
60966: LD_VAR 0 1
60970: PPUSH
60971: CALL_OW 274
60975: ST_TO_ADDR
// if not pom then
60976: LD_VAR 0 3
60980: NOT
60981: IFFALSE 60985
// exit ;
60983: GO 61155
// btype := GetBType ( building ) ;
60985: LD_ADDR_VAR 0 5
60989: PUSH
60990: LD_VAR 0 1
60994: PPUSH
60995: CALL_OW 266
60999: ST_TO_ADDR
// if btype = b_armoury then
61000: LD_VAR 0 5
61004: PUSH
61005: LD_INT 4
61007: EQUAL
61008: IFFALSE 61018
// btype := b_barracks ;
61010: LD_ADDR_VAR 0 5
61014: PUSH
61015: LD_INT 5
61017: ST_TO_ADDR
// if btype = b_depot then
61018: LD_VAR 0 5
61022: PUSH
61023: LD_INT 0
61025: EQUAL
61026: IFFALSE 61036
// btype := b_warehouse ;
61028: LD_ADDR_VAR 0 5
61032: PUSH
61033: LD_INT 1
61035: ST_TO_ADDR
// if btype = b_workshop then
61036: LD_VAR 0 5
61040: PUSH
61041: LD_INT 2
61043: EQUAL
61044: IFFALSE 61054
// btype := b_factory ;
61046: LD_ADDR_VAR 0 5
61050: PUSH
61051: LD_INT 3
61053: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
61054: LD_ADDR_VAR 0 4
61058: PUSH
61059: LD_VAR 0 5
61063: PPUSH
61064: LD_VAR 0 1
61068: PPUSH
61069: CALL_OW 248
61073: PPUSH
61074: CALL_OW 450
61078: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
61079: LD_ADDR_VAR 0 2
61083: PUSH
61084: LD_VAR 0 3
61088: PPUSH
61089: LD_INT 1
61091: PPUSH
61092: CALL_OW 275
61096: PUSH
61097: LD_VAR 0 4
61101: PUSH
61102: LD_INT 1
61104: ARRAY
61105: GREATEREQUAL
61106: PUSH
61107: LD_VAR 0 3
61111: PPUSH
61112: LD_INT 2
61114: PPUSH
61115: CALL_OW 275
61119: PUSH
61120: LD_VAR 0 4
61124: PUSH
61125: LD_INT 2
61127: ARRAY
61128: GREATEREQUAL
61129: AND
61130: PUSH
61131: LD_VAR 0 3
61135: PPUSH
61136: LD_INT 3
61138: PPUSH
61139: CALL_OW 275
61143: PUSH
61144: LD_VAR 0 4
61148: PUSH
61149: LD_INT 3
61151: ARRAY
61152: GREATEREQUAL
61153: AND
61154: ST_TO_ADDR
// end ;
61155: LD_VAR 0 2
61159: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
61160: LD_INT 0
61162: PPUSH
61163: PPUSH
61164: PPUSH
// pom := GetBase ( building ) ;
61165: LD_ADDR_VAR 0 4
61169: PUSH
61170: LD_VAR 0 1
61174: PPUSH
61175: CALL_OW 274
61179: ST_TO_ADDR
// if not pom then
61180: LD_VAR 0 4
61184: NOT
61185: IFFALSE 61189
// exit ;
61187: GO 61290
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
61189: LD_ADDR_VAR 0 5
61193: PUSH
61194: LD_VAR 0 2
61198: PPUSH
61199: LD_VAR 0 1
61203: PPUSH
61204: CALL_OW 248
61208: PPUSH
61209: CALL_OW 450
61213: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
61214: LD_ADDR_VAR 0 3
61218: PUSH
61219: LD_VAR 0 4
61223: PPUSH
61224: LD_INT 1
61226: PPUSH
61227: CALL_OW 275
61231: PUSH
61232: LD_VAR 0 5
61236: PUSH
61237: LD_INT 1
61239: ARRAY
61240: GREATEREQUAL
61241: PUSH
61242: LD_VAR 0 4
61246: PPUSH
61247: LD_INT 2
61249: PPUSH
61250: CALL_OW 275
61254: PUSH
61255: LD_VAR 0 5
61259: PUSH
61260: LD_INT 2
61262: ARRAY
61263: GREATEREQUAL
61264: AND
61265: PUSH
61266: LD_VAR 0 4
61270: PPUSH
61271: LD_INT 3
61273: PPUSH
61274: CALL_OW 275
61278: PUSH
61279: LD_VAR 0 5
61283: PUSH
61284: LD_INT 3
61286: ARRAY
61287: GREATEREQUAL
61288: AND
61289: ST_TO_ADDR
// end ;
61290: LD_VAR 0 3
61294: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
61295: LD_INT 0
61297: PPUSH
61298: PPUSH
61299: PPUSH
61300: PPUSH
61301: PPUSH
61302: PPUSH
61303: PPUSH
61304: PPUSH
61305: PPUSH
61306: PPUSH
61307: PPUSH
// result := false ;
61308: LD_ADDR_VAR 0 8
61312: PUSH
61313: LD_INT 0
61315: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
61316: LD_VAR 0 5
61320: NOT
61321: PUSH
61322: LD_VAR 0 1
61326: NOT
61327: OR
61328: PUSH
61329: LD_VAR 0 2
61333: NOT
61334: OR
61335: PUSH
61336: LD_VAR 0 3
61340: NOT
61341: OR
61342: IFFALSE 61346
// exit ;
61344: GO 62160
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
61346: LD_ADDR_VAR 0 14
61350: PUSH
61351: LD_VAR 0 1
61355: PPUSH
61356: LD_VAR 0 2
61360: PPUSH
61361: LD_VAR 0 3
61365: PPUSH
61366: LD_VAR 0 4
61370: PPUSH
61371: LD_VAR 0 5
61375: PUSH
61376: LD_INT 1
61378: ARRAY
61379: PPUSH
61380: CALL_OW 248
61384: PPUSH
61385: LD_INT 0
61387: PPUSH
61388: CALL 63413 0 6
61392: ST_TO_ADDR
// if not hexes then
61393: LD_VAR 0 14
61397: NOT
61398: IFFALSE 61402
// exit ;
61400: GO 62160
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
61402: LD_ADDR_VAR 0 17
61406: PUSH
61407: LD_VAR 0 5
61411: PPUSH
61412: LD_INT 22
61414: PUSH
61415: LD_VAR 0 13
61419: PPUSH
61420: CALL_OW 255
61424: PUSH
61425: EMPTY
61426: LIST
61427: LIST
61428: PUSH
61429: LD_INT 2
61431: PUSH
61432: LD_INT 30
61434: PUSH
61435: LD_INT 0
61437: PUSH
61438: EMPTY
61439: LIST
61440: LIST
61441: PUSH
61442: LD_INT 30
61444: PUSH
61445: LD_INT 1
61447: PUSH
61448: EMPTY
61449: LIST
61450: LIST
61451: PUSH
61452: EMPTY
61453: LIST
61454: LIST
61455: LIST
61456: PUSH
61457: EMPTY
61458: LIST
61459: LIST
61460: PPUSH
61461: CALL_OW 72
61465: ST_TO_ADDR
// for i = 1 to hexes do
61466: LD_ADDR_VAR 0 9
61470: PUSH
61471: DOUBLE
61472: LD_INT 1
61474: DEC
61475: ST_TO_ADDR
61476: LD_VAR 0 14
61480: PUSH
61481: FOR_TO
61482: IFFALSE 62158
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
61484: LD_ADDR_VAR 0 13
61488: PUSH
61489: LD_VAR 0 14
61493: PUSH
61494: LD_VAR 0 9
61498: ARRAY
61499: PUSH
61500: LD_INT 1
61502: ARRAY
61503: PPUSH
61504: LD_VAR 0 14
61508: PUSH
61509: LD_VAR 0 9
61513: ARRAY
61514: PUSH
61515: LD_INT 2
61517: ARRAY
61518: PPUSH
61519: CALL_OW 428
61523: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
61524: LD_VAR 0 14
61528: PUSH
61529: LD_VAR 0 9
61533: ARRAY
61534: PUSH
61535: LD_INT 1
61537: ARRAY
61538: PPUSH
61539: LD_VAR 0 14
61543: PUSH
61544: LD_VAR 0 9
61548: ARRAY
61549: PUSH
61550: LD_INT 2
61552: ARRAY
61553: PPUSH
61554: CALL_OW 351
61558: PUSH
61559: LD_VAR 0 14
61563: PUSH
61564: LD_VAR 0 9
61568: ARRAY
61569: PUSH
61570: LD_INT 1
61572: ARRAY
61573: PPUSH
61574: LD_VAR 0 14
61578: PUSH
61579: LD_VAR 0 9
61583: ARRAY
61584: PUSH
61585: LD_INT 2
61587: ARRAY
61588: PPUSH
61589: CALL_OW 488
61593: NOT
61594: OR
61595: PUSH
61596: LD_VAR 0 13
61600: PPUSH
61601: CALL_OW 247
61605: PUSH
61606: LD_INT 3
61608: EQUAL
61609: OR
61610: IFFALSE 61616
// exit ;
61612: POP
61613: POP
61614: GO 62160
// if not tmp then
61616: LD_VAR 0 13
61620: NOT
61621: IFFALSE 61625
// continue ;
61623: GO 61481
// result := true ;
61625: LD_ADDR_VAR 0 8
61629: PUSH
61630: LD_INT 1
61632: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
61633: LD_VAR 0 6
61637: PUSH
61638: LD_VAR 0 13
61642: PPUSH
61643: CALL_OW 247
61647: PUSH
61648: LD_INT 2
61650: EQUAL
61651: AND
61652: PUSH
61653: LD_VAR 0 13
61657: PPUSH
61658: CALL_OW 263
61662: PUSH
61663: LD_INT 1
61665: EQUAL
61666: AND
61667: IFFALSE 61831
// begin if IsDrivenBy ( tmp ) then
61669: LD_VAR 0 13
61673: PPUSH
61674: CALL_OW 311
61678: IFFALSE 61682
// continue ;
61680: GO 61481
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
61682: LD_VAR 0 6
61686: PPUSH
61687: LD_INT 3
61689: PUSH
61690: LD_INT 60
61692: PUSH
61693: EMPTY
61694: LIST
61695: PUSH
61696: EMPTY
61697: LIST
61698: LIST
61699: PUSH
61700: LD_INT 3
61702: PUSH
61703: LD_INT 55
61705: PUSH
61706: EMPTY
61707: LIST
61708: PUSH
61709: EMPTY
61710: LIST
61711: LIST
61712: PUSH
61713: EMPTY
61714: LIST
61715: LIST
61716: PPUSH
61717: CALL_OW 72
61721: IFFALSE 61829
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
61723: LD_ADDR_VAR 0 18
61727: PUSH
61728: LD_VAR 0 6
61732: PPUSH
61733: LD_INT 3
61735: PUSH
61736: LD_INT 60
61738: PUSH
61739: EMPTY
61740: LIST
61741: PUSH
61742: EMPTY
61743: LIST
61744: LIST
61745: PUSH
61746: LD_INT 3
61748: PUSH
61749: LD_INT 55
61751: PUSH
61752: EMPTY
61753: LIST
61754: PUSH
61755: EMPTY
61756: LIST
61757: LIST
61758: PUSH
61759: EMPTY
61760: LIST
61761: LIST
61762: PPUSH
61763: CALL_OW 72
61767: PUSH
61768: LD_INT 1
61770: ARRAY
61771: ST_TO_ADDR
// if IsInUnit ( driver ) then
61772: LD_VAR 0 18
61776: PPUSH
61777: CALL_OW 310
61781: IFFALSE 61792
// ComExit ( driver ) ;
61783: LD_VAR 0 18
61787: PPUSH
61788: CALL 87205 0 1
// AddComEnterUnit ( driver , tmp ) ;
61792: LD_VAR 0 18
61796: PPUSH
61797: LD_VAR 0 13
61801: PPUSH
61802: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
61806: LD_VAR 0 18
61810: PPUSH
61811: LD_VAR 0 7
61815: PPUSH
61816: CALL_OW 173
// AddComExitVehicle ( driver ) ;
61820: LD_VAR 0 18
61824: PPUSH
61825: CALL_OW 181
// end ; continue ;
61829: GO 61481
// end ; if not cleaners or not tmp in cleaners then
61831: LD_VAR 0 6
61835: NOT
61836: PUSH
61837: LD_VAR 0 13
61841: PUSH
61842: LD_VAR 0 6
61846: IN
61847: NOT
61848: OR
61849: IFFALSE 62156
// begin if dep then
61851: LD_VAR 0 17
61855: IFFALSE 61991
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
61857: LD_ADDR_VAR 0 16
61861: PUSH
61862: LD_VAR 0 17
61866: PUSH
61867: LD_INT 1
61869: ARRAY
61870: PPUSH
61871: CALL_OW 250
61875: PPUSH
61876: LD_VAR 0 17
61880: PUSH
61881: LD_INT 1
61883: ARRAY
61884: PPUSH
61885: CALL_OW 254
61889: PPUSH
61890: LD_INT 5
61892: PPUSH
61893: CALL_OW 272
61897: PUSH
61898: LD_VAR 0 17
61902: PUSH
61903: LD_INT 1
61905: ARRAY
61906: PPUSH
61907: CALL_OW 251
61911: PPUSH
61912: LD_VAR 0 17
61916: PUSH
61917: LD_INT 1
61919: ARRAY
61920: PPUSH
61921: CALL_OW 254
61925: PPUSH
61926: LD_INT 5
61928: PPUSH
61929: CALL_OW 273
61933: PUSH
61934: EMPTY
61935: LIST
61936: LIST
61937: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
61938: LD_VAR 0 16
61942: PUSH
61943: LD_INT 1
61945: ARRAY
61946: PPUSH
61947: LD_VAR 0 16
61951: PUSH
61952: LD_INT 2
61954: ARRAY
61955: PPUSH
61956: CALL_OW 488
61960: IFFALSE 61991
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
61962: LD_VAR 0 13
61966: PPUSH
61967: LD_VAR 0 16
61971: PUSH
61972: LD_INT 1
61974: ARRAY
61975: PPUSH
61976: LD_VAR 0 16
61980: PUSH
61981: LD_INT 2
61983: ARRAY
61984: PPUSH
61985: CALL_OW 111
// continue ;
61989: GO 61481
// end ; end ; r := GetDir ( tmp ) ;
61991: LD_ADDR_VAR 0 15
61995: PUSH
61996: LD_VAR 0 13
62000: PPUSH
62001: CALL_OW 254
62005: ST_TO_ADDR
// if r = 5 then
62006: LD_VAR 0 15
62010: PUSH
62011: LD_INT 5
62013: EQUAL
62014: IFFALSE 62024
// r := 0 ;
62016: LD_ADDR_VAR 0 15
62020: PUSH
62021: LD_INT 0
62023: ST_TO_ADDR
// for j = r to 5 do
62024: LD_ADDR_VAR 0 10
62028: PUSH
62029: DOUBLE
62030: LD_VAR 0 15
62034: DEC
62035: ST_TO_ADDR
62036: LD_INT 5
62038: PUSH
62039: FOR_TO
62040: IFFALSE 62154
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
62042: LD_ADDR_VAR 0 11
62046: PUSH
62047: LD_VAR 0 13
62051: PPUSH
62052: CALL_OW 250
62056: PPUSH
62057: LD_VAR 0 10
62061: PPUSH
62062: LD_INT 2
62064: PPUSH
62065: CALL_OW 272
62069: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
62070: LD_ADDR_VAR 0 12
62074: PUSH
62075: LD_VAR 0 13
62079: PPUSH
62080: CALL_OW 251
62084: PPUSH
62085: LD_VAR 0 10
62089: PPUSH
62090: LD_INT 2
62092: PPUSH
62093: CALL_OW 273
62097: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
62098: LD_VAR 0 11
62102: PPUSH
62103: LD_VAR 0 12
62107: PPUSH
62108: CALL_OW 488
62112: PUSH
62113: LD_VAR 0 11
62117: PPUSH
62118: LD_VAR 0 12
62122: PPUSH
62123: CALL_OW 428
62127: NOT
62128: AND
62129: IFFALSE 62152
// begin ComMoveXY ( tmp , _x , _y ) ;
62131: LD_VAR 0 13
62135: PPUSH
62136: LD_VAR 0 11
62140: PPUSH
62141: LD_VAR 0 12
62145: PPUSH
62146: CALL_OW 111
// break ;
62150: GO 62154
// end ; end ;
62152: GO 62039
62154: POP
62155: POP
// end ; end ;
62156: GO 61481
62158: POP
62159: POP
// end ;
62160: LD_VAR 0 8
62164: RET
// export function BuildingTechInvented ( side , btype ) ; begin
62165: LD_INT 0
62167: PPUSH
// result := true ;
62168: LD_ADDR_VAR 0 3
62172: PUSH
62173: LD_INT 1
62175: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
62176: LD_VAR 0 2
62180: PUSH
62181: LD_INT 24
62183: DOUBLE
62184: EQUAL
62185: IFTRUE 62195
62187: LD_INT 33
62189: DOUBLE
62190: EQUAL
62191: IFTRUE 62195
62193: GO 62220
62195: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
62196: LD_ADDR_VAR 0 3
62200: PUSH
62201: LD_INT 32
62203: PPUSH
62204: LD_VAR 0 1
62208: PPUSH
62209: CALL_OW 321
62213: PUSH
62214: LD_INT 2
62216: EQUAL
62217: ST_TO_ADDR
62218: GO 62536
62220: LD_INT 20
62222: DOUBLE
62223: EQUAL
62224: IFTRUE 62228
62226: GO 62253
62228: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
62229: LD_ADDR_VAR 0 3
62233: PUSH
62234: LD_INT 6
62236: PPUSH
62237: LD_VAR 0 1
62241: PPUSH
62242: CALL_OW 321
62246: PUSH
62247: LD_INT 2
62249: EQUAL
62250: ST_TO_ADDR
62251: GO 62536
62253: LD_INT 22
62255: DOUBLE
62256: EQUAL
62257: IFTRUE 62267
62259: LD_INT 36
62261: DOUBLE
62262: EQUAL
62263: IFTRUE 62267
62265: GO 62292
62267: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
62268: LD_ADDR_VAR 0 3
62272: PUSH
62273: LD_INT 15
62275: PPUSH
62276: LD_VAR 0 1
62280: PPUSH
62281: CALL_OW 321
62285: PUSH
62286: LD_INT 2
62288: EQUAL
62289: ST_TO_ADDR
62290: GO 62536
62292: LD_INT 30
62294: DOUBLE
62295: EQUAL
62296: IFTRUE 62300
62298: GO 62325
62300: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
62301: LD_ADDR_VAR 0 3
62305: PUSH
62306: LD_INT 20
62308: PPUSH
62309: LD_VAR 0 1
62313: PPUSH
62314: CALL_OW 321
62318: PUSH
62319: LD_INT 2
62321: EQUAL
62322: ST_TO_ADDR
62323: GO 62536
62325: LD_INT 28
62327: DOUBLE
62328: EQUAL
62329: IFTRUE 62339
62331: LD_INT 21
62333: DOUBLE
62334: EQUAL
62335: IFTRUE 62339
62337: GO 62364
62339: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
62340: LD_ADDR_VAR 0 3
62344: PUSH
62345: LD_INT 21
62347: PPUSH
62348: LD_VAR 0 1
62352: PPUSH
62353: CALL_OW 321
62357: PUSH
62358: LD_INT 2
62360: EQUAL
62361: ST_TO_ADDR
62362: GO 62536
62364: LD_INT 16
62366: DOUBLE
62367: EQUAL
62368: IFTRUE 62372
62370: GO 62397
62372: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
62373: LD_ADDR_VAR 0 3
62377: PUSH
62378: LD_INT 84
62380: PPUSH
62381: LD_VAR 0 1
62385: PPUSH
62386: CALL_OW 321
62390: PUSH
62391: LD_INT 2
62393: EQUAL
62394: ST_TO_ADDR
62395: GO 62536
62397: LD_INT 19
62399: DOUBLE
62400: EQUAL
62401: IFTRUE 62411
62403: LD_INT 23
62405: DOUBLE
62406: EQUAL
62407: IFTRUE 62411
62409: GO 62436
62411: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
62412: LD_ADDR_VAR 0 3
62416: PUSH
62417: LD_INT 83
62419: PPUSH
62420: LD_VAR 0 1
62424: PPUSH
62425: CALL_OW 321
62429: PUSH
62430: LD_INT 2
62432: EQUAL
62433: ST_TO_ADDR
62434: GO 62536
62436: LD_INT 17
62438: DOUBLE
62439: EQUAL
62440: IFTRUE 62444
62442: GO 62469
62444: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
62445: LD_ADDR_VAR 0 3
62449: PUSH
62450: LD_INT 39
62452: PPUSH
62453: LD_VAR 0 1
62457: PPUSH
62458: CALL_OW 321
62462: PUSH
62463: LD_INT 2
62465: EQUAL
62466: ST_TO_ADDR
62467: GO 62536
62469: LD_INT 18
62471: DOUBLE
62472: EQUAL
62473: IFTRUE 62477
62475: GO 62502
62477: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
62478: LD_ADDR_VAR 0 3
62482: PUSH
62483: LD_INT 40
62485: PPUSH
62486: LD_VAR 0 1
62490: PPUSH
62491: CALL_OW 321
62495: PUSH
62496: LD_INT 2
62498: EQUAL
62499: ST_TO_ADDR
62500: GO 62536
62502: LD_INT 27
62504: DOUBLE
62505: EQUAL
62506: IFTRUE 62510
62508: GO 62535
62510: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
62511: LD_ADDR_VAR 0 3
62515: PUSH
62516: LD_INT 35
62518: PPUSH
62519: LD_VAR 0 1
62523: PPUSH
62524: CALL_OW 321
62528: PUSH
62529: LD_INT 2
62531: EQUAL
62532: ST_TO_ADDR
62533: GO 62536
62535: POP
// end ;
62536: LD_VAR 0 3
62540: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
62541: LD_INT 0
62543: PPUSH
62544: PPUSH
62545: PPUSH
62546: PPUSH
62547: PPUSH
62548: PPUSH
62549: PPUSH
62550: PPUSH
62551: PPUSH
62552: PPUSH
62553: PPUSH
// result := false ;
62554: LD_ADDR_VAR 0 6
62558: PUSH
62559: LD_INT 0
62561: ST_TO_ADDR
// if btype = b_depot then
62562: LD_VAR 0 2
62566: PUSH
62567: LD_INT 0
62569: EQUAL
62570: IFFALSE 62582
// begin result := true ;
62572: LD_ADDR_VAR 0 6
62576: PUSH
62577: LD_INT 1
62579: ST_TO_ADDR
// exit ;
62580: GO 63408
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
62582: LD_VAR 0 1
62586: NOT
62587: PUSH
62588: LD_VAR 0 1
62592: PPUSH
62593: CALL_OW 266
62597: PUSH
62598: LD_INT 0
62600: PUSH
62601: LD_INT 1
62603: PUSH
62604: EMPTY
62605: LIST
62606: LIST
62607: IN
62608: NOT
62609: OR
62610: PUSH
62611: LD_VAR 0 2
62615: NOT
62616: OR
62617: PUSH
62618: LD_VAR 0 5
62622: PUSH
62623: LD_INT 0
62625: PUSH
62626: LD_INT 1
62628: PUSH
62629: LD_INT 2
62631: PUSH
62632: LD_INT 3
62634: PUSH
62635: LD_INT 4
62637: PUSH
62638: LD_INT 5
62640: PUSH
62641: EMPTY
62642: LIST
62643: LIST
62644: LIST
62645: LIST
62646: LIST
62647: LIST
62648: IN
62649: NOT
62650: OR
62651: PUSH
62652: LD_VAR 0 3
62656: PPUSH
62657: LD_VAR 0 4
62661: PPUSH
62662: CALL_OW 488
62666: NOT
62667: OR
62668: IFFALSE 62672
// exit ;
62670: GO 63408
// side := GetSide ( depot ) ;
62672: LD_ADDR_VAR 0 9
62676: PUSH
62677: LD_VAR 0 1
62681: PPUSH
62682: CALL_OW 255
62686: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
62687: LD_VAR 0 9
62691: PPUSH
62692: LD_VAR 0 2
62696: PPUSH
62697: CALL 62165 0 2
62701: NOT
62702: IFFALSE 62706
// exit ;
62704: GO 63408
// pom := GetBase ( depot ) ;
62706: LD_ADDR_VAR 0 10
62710: PUSH
62711: LD_VAR 0 1
62715: PPUSH
62716: CALL_OW 274
62720: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
62721: LD_ADDR_VAR 0 11
62725: PUSH
62726: LD_VAR 0 2
62730: PPUSH
62731: LD_VAR 0 1
62735: PPUSH
62736: CALL_OW 248
62740: PPUSH
62741: CALL_OW 450
62745: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
62746: LD_VAR 0 10
62750: PPUSH
62751: LD_INT 1
62753: PPUSH
62754: CALL_OW 275
62758: PUSH
62759: LD_VAR 0 11
62763: PUSH
62764: LD_INT 1
62766: ARRAY
62767: GREATEREQUAL
62768: PUSH
62769: LD_VAR 0 10
62773: PPUSH
62774: LD_INT 2
62776: PPUSH
62777: CALL_OW 275
62781: PUSH
62782: LD_VAR 0 11
62786: PUSH
62787: LD_INT 2
62789: ARRAY
62790: GREATEREQUAL
62791: AND
62792: PUSH
62793: LD_VAR 0 10
62797: PPUSH
62798: LD_INT 3
62800: PPUSH
62801: CALL_OW 275
62805: PUSH
62806: LD_VAR 0 11
62810: PUSH
62811: LD_INT 3
62813: ARRAY
62814: GREATEREQUAL
62815: AND
62816: NOT
62817: IFFALSE 62821
// exit ;
62819: GO 63408
// if GetBType ( depot ) = b_depot then
62821: LD_VAR 0 1
62825: PPUSH
62826: CALL_OW 266
62830: PUSH
62831: LD_INT 0
62833: EQUAL
62834: IFFALSE 62846
// dist := 28 else
62836: LD_ADDR_VAR 0 14
62840: PUSH
62841: LD_INT 28
62843: ST_TO_ADDR
62844: GO 62854
// dist := 36 ;
62846: LD_ADDR_VAR 0 14
62850: PUSH
62851: LD_INT 36
62853: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
62854: LD_VAR 0 1
62858: PPUSH
62859: LD_VAR 0 3
62863: PPUSH
62864: LD_VAR 0 4
62868: PPUSH
62869: CALL_OW 297
62873: PUSH
62874: LD_VAR 0 14
62878: GREATER
62879: IFFALSE 62883
// exit ;
62881: GO 63408
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
62883: LD_ADDR_VAR 0 12
62887: PUSH
62888: LD_VAR 0 2
62892: PPUSH
62893: LD_VAR 0 3
62897: PPUSH
62898: LD_VAR 0 4
62902: PPUSH
62903: LD_VAR 0 5
62907: PPUSH
62908: LD_VAR 0 1
62912: PPUSH
62913: CALL_OW 248
62917: PPUSH
62918: LD_INT 0
62920: PPUSH
62921: CALL 63413 0 6
62925: ST_TO_ADDR
// if not hexes then
62926: LD_VAR 0 12
62930: NOT
62931: IFFALSE 62935
// exit ;
62933: GO 63408
// hex := GetHexInfo ( x , y ) ;
62935: LD_ADDR_VAR 0 15
62939: PUSH
62940: LD_VAR 0 3
62944: PPUSH
62945: LD_VAR 0 4
62949: PPUSH
62950: CALL_OW 546
62954: ST_TO_ADDR
// if hex [ 1 ] then
62955: LD_VAR 0 15
62959: PUSH
62960: LD_INT 1
62962: ARRAY
62963: IFFALSE 62967
// exit ;
62965: GO 63408
// height := hex [ 2 ] ;
62967: LD_ADDR_VAR 0 13
62971: PUSH
62972: LD_VAR 0 15
62976: PUSH
62977: LD_INT 2
62979: ARRAY
62980: ST_TO_ADDR
// for i = 1 to hexes do
62981: LD_ADDR_VAR 0 7
62985: PUSH
62986: DOUBLE
62987: LD_INT 1
62989: DEC
62990: ST_TO_ADDR
62991: LD_VAR 0 12
62995: PUSH
62996: FOR_TO
62997: IFFALSE 63327
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
62999: LD_VAR 0 12
63003: PUSH
63004: LD_VAR 0 7
63008: ARRAY
63009: PUSH
63010: LD_INT 1
63012: ARRAY
63013: PPUSH
63014: LD_VAR 0 12
63018: PUSH
63019: LD_VAR 0 7
63023: ARRAY
63024: PUSH
63025: LD_INT 2
63027: ARRAY
63028: PPUSH
63029: CALL_OW 488
63033: NOT
63034: PUSH
63035: LD_VAR 0 12
63039: PUSH
63040: LD_VAR 0 7
63044: ARRAY
63045: PUSH
63046: LD_INT 1
63048: ARRAY
63049: PPUSH
63050: LD_VAR 0 12
63054: PUSH
63055: LD_VAR 0 7
63059: ARRAY
63060: PUSH
63061: LD_INT 2
63063: ARRAY
63064: PPUSH
63065: CALL_OW 428
63069: PUSH
63070: LD_INT 0
63072: GREATER
63073: OR
63074: PUSH
63075: LD_VAR 0 12
63079: PUSH
63080: LD_VAR 0 7
63084: ARRAY
63085: PUSH
63086: LD_INT 1
63088: ARRAY
63089: PPUSH
63090: LD_VAR 0 12
63094: PUSH
63095: LD_VAR 0 7
63099: ARRAY
63100: PUSH
63101: LD_INT 2
63103: ARRAY
63104: PPUSH
63105: CALL_OW 351
63109: OR
63110: IFFALSE 63116
// exit ;
63112: POP
63113: POP
63114: GO 63408
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
63116: LD_ADDR_VAR 0 8
63120: PUSH
63121: LD_VAR 0 12
63125: PUSH
63126: LD_VAR 0 7
63130: ARRAY
63131: PUSH
63132: LD_INT 1
63134: ARRAY
63135: PPUSH
63136: LD_VAR 0 12
63140: PUSH
63141: LD_VAR 0 7
63145: ARRAY
63146: PUSH
63147: LD_INT 2
63149: ARRAY
63150: PPUSH
63151: CALL_OW 546
63155: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
63156: LD_VAR 0 8
63160: PUSH
63161: LD_INT 1
63163: ARRAY
63164: PUSH
63165: LD_VAR 0 8
63169: PUSH
63170: LD_INT 2
63172: ARRAY
63173: PUSH
63174: LD_VAR 0 13
63178: PUSH
63179: LD_INT 2
63181: PLUS
63182: GREATER
63183: OR
63184: PUSH
63185: LD_VAR 0 8
63189: PUSH
63190: LD_INT 2
63192: ARRAY
63193: PUSH
63194: LD_VAR 0 13
63198: PUSH
63199: LD_INT 2
63201: MINUS
63202: LESS
63203: OR
63204: PUSH
63205: LD_VAR 0 8
63209: PUSH
63210: LD_INT 3
63212: ARRAY
63213: PUSH
63214: LD_INT 0
63216: PUSH
63217: LD_INT 8
63219: PUSH
63220: LD_INT 9
63222: PUSH
63223: LD_INT 10
63225: PUSH
63226: LD_INT 11
63228: PUSH
63229: LD_INT 12
63231: PUSH
63232: LD_INT 13
63234: PUSH
63235: LD_INT 16
63237: PUSH
63238: LD_INT 17
63240: PUSH
63241: LD_INT 18
63243: PUSH
63244: LD_INT 19
63246: PUSH
63247: LD_INT 20
63249: PUSH
63250: LD_INT 21
63252: PUSH
63253: EMPTY
63254: LIST
63255: LIST
63256: LIST
63257: LIST
63258: LIST
63259: LIST
63260: LIST
63261: LIST
63262: LIST
63263: LIST
63264: LIST
63265: LIST
63266: LIST
63267: IN
63268: NOT
63269: OR
63270: PUSH
63271: LD_VAR 0 8
63275: PUSH
63276: LD_INT 5
63278: ARRAY
63279: NOT
63280: OR
63281: PUSH
63282: LD_VAR 0 8
63286: PUSH
63287: LD_INT 6
63289: ARRAY
63290: PUSH
63291: LD_INT 1
63293: PUSH
63294: LD_INT 2
63296: PUSH
63297: LD_INT 7
63299: PUSH
63300: LD_INT 9
63302: PUSH
63303: LD_INT 10
63305: PUSH
63306: LD_INT 11
63308: PUSH
63309: EMPTY
63310: LIST
63311: LIST
63312: LIST
63313: LIST
63314: LIST
63315: LIST
63316: IN
63317: NOT
63318: OR
63319: IFFALSE 63325
// exit ;
63321: POP
63322: POP
63323: GO 63408
// end ;
63325: GO 62996
63327: POP
63328: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
63329: LD_VAR 0 9
63333: PPUSH
63334: LD_VAR 0 3
63338: PPUSH
63339: LD_VAR 0 4
63343: PPUSH
63344: LD_INT 20
63346: PPUSH
63347: CALL 55331 0 4
63351: PUSH
63352: LD_INT 4
63354: ARRAY
63355: IFFALSE 63359
// exit ;
63357: GO 63408
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
63359: LD_VAR 0 2
63363: PUSH
63364: LD_INT 29
63366: PUSH
63367: LD_INT 30
63369: PUSH
63370: EMPTY
63371: LIST
63372: LIST
63373: IN
63374: PUSH
63375: LD_VAR 0 3
63379: PPUSH
63380: LD_VAR 0 4
63384: PPUSH
63385: LD_VAR 0 9
63389: PPUSH
63390: CALL_OW 440
63394: NOT
63395: AND
63396: IFFALSE 63400
// exit ;
63398: GO 63408
// result := true ;
63400: LD_ADDR_VAR 0 6
63404: PUSH
63405: LD_INT 1
63407: ST_TO_ADDR
// end ;
63408: LD_VAR 0 6
63412: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
63413: LD_INT 0
63415: PPUSH
63416: PPUSH
63417: PPUSH
63418: PPUSH
63419: PPUSH
63420: PPUSH
63421: PPUSH
63422: PPUSH
63423: PPUSH
63424: PPUSH
63425: PPUSH
63426: PPUSH
63427: PPUSH
63428: PPUSH
63429: PPUSH
63430: PPUSH
63431: PPUSH
63432: PPUSH
63433: PPUSH
63434: PPUSH
63435: PPUSH
63436: PPUSH
63437: PPUSH
63438: PPUSH
63439: PPUSH
63440: PPUSH
63441: PPUSH
63442: PPUSH
63443: PPUSH
63444: PPUSH
63445: PPUSH
63446: PPUSH
63447: PPUSH
63448: PPUSH
63449: PPUSH
63450: PPUSH
63451: PPUSH
63452: PPUSH
63453: PPUSH
63454: PPUSH
63455: PPUSH
63456: PPUSH
63457: PPUSH
63458: PPUSH
63459: PPUSH
63460: PPUSH
63461: PPUSH
63462: PPUSH
63463: PPUSH
63464: PPUSH
63465: PPUSH
63466: PPUSH
63467: PPUSH
63468: PPUSH
63469: PPUSH
63470: PPUSH
63471: PPUSH
63472: PPUSH
// result = [ ] ;
63473: LD_ADDR_VAR 0 7
63477: PUSH
63478: EMPTY
63479: ST_TO_ADDR
// temp_list = [ ] ;
63480: LD_ADDR_VAR 0 9
63484: PUSH
63485: EMPTY
63486: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
63487: LD_VAR 0 4
63491: PUSH
63492: LD_INT 0
63494: PUSH
63495: LD_INT 1
63497: PUSH
63498: LD_INT 2
63500: PUSH
63501: LD_INT 3
63503: PUSH
63504: LD_INT 4
63506: PUSH
63507: LD_INT 5
63509: PUSH
63510: EMPTY
63511: LIST
63512: LIST
63513: LIST
63514: LIST
63515: LIST
63516: LIST
63517: IN
63518: NOT
63519: PUSH
63520: LD_VAR 0 1
63524: PUSH
63525: LD_INT 0
63527: PUSH
63528: LD_INT 1
63530: PUSH
63531: EMPTY
63532: LIST
63533: LIST
63534: IN
63535: PUSH
63536: LD_VAR 0 5
63540: PUSH
63541: LD_INT 1
63543: PUSH
63544: LD_INT 2
63546: PUSH
63547: LD_INT 3
63549: PUSH
63550: EMPTY
63551: LIST
63552: LIST
63553: LIST
63554: IN
63555: NOT
63556: AND
63557: OR
63558: IFFALSE 63562
// exit ;
63560: GO 81953
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
63562: LD_VAR 0 1
63566: PUSH
63567: LD_INT 6
63569: PUSH
63570: LD_INT 7
63572: PUSH
63573: LD_INT 8
63575: PUSH
63576: LD_INT 13
63578: PUSH
63579: LD_INT 12
63581: PUSH
63582: LD_INT 15
63584: PUSH
63585: LD_INT 11
63587: PUSH
63588: LD_INT 14
63590: PUSH
63591: LD_INT 10
63593: PUSH
63594: EMPTY
63595: LIST
63596: LIST
63597: LIST
63598: LIST
63599: LIST
63600: LIST
63601: LIST
63602: LIST
63603: LIST
63604: IN
63605: IFFALSE 63615
// btype = b_lab ;
63607: LD_ADDR_VAR 0 1
63611: PUSH
63612: LD_INT 6
63614: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
63615: LD_VAR 0 6
63619: PUSH
63620: LD_INT 0
63622: PUSH
63623: LD_INT 1
63625: PUSH
63626: LD_INT 2
63628: PUSH
63629: EMPTY
63630: LIST
63631: LIST
63632: LIST
63633: IN
63634: NOT
63635: PUSH
63636: LD_VAR 0 1
63640: PUSH
63641: LD_INT 0
63643: PUSH
63644: LD_INT 1
63646: PUSH
63647: LD_INT 2
63649: PUSH
63650: LD_INT 3
63652: PUSH
63653: LD_INT 6
63655: PUSH
63656: LD_INT 36
63658: PUSH
63659: LD_INT 4
63661: PUSH
63662: LD_INT 5
63664: PUSH
63665: LD_INT 31
63667: PUSH
63668: LD_INT 32
63670: PUSH
63671: LD_INT 33
63673: PUSH
63674: EMPTY
63675: LIST
63676: LIST
63677: LIST
63678: LIST
63679: LIST
63680: LIST
63681: LIST
63682: LIST
63683: LIST
63684: LIST
63685: LIST
63686: IN
63687: NOT
63688: PUSH
63689: LD_VAR 0 6
63693: PUSH
63694: LD_INT 1
63696: EQUAL
63697: AND
63698: OR
63699: PUSH
63700: LD_VAR 0 1
63704: PUSH
63705: LD_INT 2
63707: PUSH
63708: LD_INT 3
63710: PUSH
63711: EMPTY
63712: LIST
63713: LIST
63714: IN
63715: NOT
63716: PUSH
63717: LD_VAR 0 6
63721: PUSH
63722: LD_INT 2
63724: EQUAL
63725: AND
63726: OR
63727: IFFALSE 63737
// mode = 0 ;
63729: LD_ADDR_VAR 0 6
63733: PUSH
63734: LD_INT 0
63736: ST_TO_ADDR
// case mode of 0 :
63737: LD_VAR 0 6
63741: PUSH
63742: LD_INT 0
63744: DOUBLE
63745: EQUAL
63746: IFTRUE 63750
63748: GO 75203
63750: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
63751: LD_ADDR_VAR 0 11
63755: PUSH
63756: LD_INT 0
63758: PUSH
63759: LD_INT 0
63761: PUSH
63762: EMPTY
63763: LIST
63764: LIST
63765: PUSH
63766: LD_INT 0
63768: PUSH
63769: LD_INT 1
63771: NEG
63772: PUSH
63773: EMPTY
63774: LIST
63775: LIST
63776: PUSH
63777: LD_INT 1
63779: PUSH
63780: LD_INT 0
63782: PUSH
63783: EMPTY
63784: LIST
63785: LIST
63786: PUSH
63787: LD_INT 1
63789: PUSH
63790: LD_INT 1
63792: PUSH
63793: EMPTY
63794: LIST
63795: LIST
63796: PUSH
63797: LD_INT 0
63799: PUSH
63800: LD_INT 1
63802: PUSH
63803: EMPTY
63804: LIST
63805: LIST
63806: PUSH
63807: LD_INT 1
63809: NEG
63810: PUSH
63811: LD_INT 0
63813: PUSH
63814: EMPTY
63815: LIST
63816: LIST
63817: PUSH
63818: LD_INT 1
63820: NEG
63821: PUSH
63822: LD_INT 1
63824: NEG
63825: PUSH
63826: EMPTY
63827: LIST
63828: LIST
63829: PUSH
63830: LD_INT 1
63832: NEG
63833: PUSH
63834: LD_INT 2
63836: NEG
63837: PUSH
63838: EMPTY
63839: LIST
63840: LIST
63841: PUSH
63842: LD_INT 0
63844: PUSH
63845: LD_INT 2
63847: NEG
63848: PUSH
63849: EMPTY
63850: LIST
63851: LIST
63852: PUSH
63853: LD_INT 1
63855: PUSH
63856: LD_INT 1
63858: NEG
63859: PUSH
63860: EMPTY
63861: LIST
63862: LIST
63863: PUSH
63864: LD_INT 1
63866: PUSH
63867: LD_INT 2
63869: PUSH
63870: EMPTY
63871: LIST
63872: LIST
63873: PUSH
63874: LD_INT 0
63876: PUSH
63877: LD_INT 2
63879: PUSH
63880: EMPTY
63881: LIST
63882: LIST
63883: PUSH
63884: LD_INT 1
63886: NEG
63887: PUSH
63888: LD_INT 1
63890: PUSH
63891: EMPTY
63892: LIST
63893: LIST
63894: PUSH
63895: LD_INT 1
63897: PUSH
63898: LD_INT 3
63900: PUSH
63901: EMPTY
63902: LIST
63903: LIST
63904: PUSH
63905: LD_INT 0
63907: PUSH
63908: LD_INT 3
63910: PUSH
63911: EMPTY
63912: LIST
63913: LIST
63914: PUSH
63915: LD_INT 1
63917: NEG
63918: PUSH
63919: LD_INT 2
63921: PUSH
63922: EMPTY
63923: LIST
63924: LIST
63925: PUSH
63926: EMPTY
63927: LIST
63928: LIST
63929: LIST
63930: LIST
63931: LIST
63932: LIST
63933: LIST
63934: LIST
63935: LIST
63936: LIST
63937: LIST
63938: LIST
63939: LIST
63940: LIST
63941: LIST
63942: LIST
63943: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
63944: LD_ADDR_VAR 0 12
63948: PUSH
63949: LD_INT 0
63951: PUSH
63952: LD_INT 0
63954: PUSH
63955: EMPTY
63956: LIST
63957: LIST
63958: PUSH
63959: LD_INT 0
63961: PUSH
63962: LD_INT 1
63964: NEG
63965: PUSH
63966: EMPTY
63967: LIST
63968: LIST
63969: PUSH
63970: LD_INT 1
63972: PUSH
63973: LD_INT 0
63975: PUSH
63976: EMPTY
63977: LIST
63978: LIST
63979: PUSH
63980: LD_INT 1
63982: PUSH
63983: LD_INT 1
63985: PUSH
63986: EMPTY
63987: LIST
63988: LIST
63989: PUSH
63990: LD_INT 0
63992: PUSH
63993: LD_INT 1
63995: PUSH
63996: EMPTY
63997: LIST
63998: LIST
63999: PUSH
64000: LD_INT 1
64002: NEG
64003: PUSH
64004: LD_INT 0
64006: PUSH
64007: EMPTY
64008: LIST
64009: LIST
64010: PUSH
64011: LD_INT 1
64013: NEG
64014: PUSH
64015: LD_INT 1
64017: NEG
64018: PUSH
64019: EMPTY
64020: LIST
64021: LIST
64022: PUSH
64023: LD_INT 1
64025: PUSH
64026: LD_INT 1
64028: NEG
64029: PUSH
64030: EMPTY
64031: LIST
64032: LIST
64033: PUSH
64034: LD_INT 2
64036: PUSH
64037: LD_INT 0
64039: PUSH
64040: EMPTY
64041: LIST
64042: LIST
64043: PUSH
64044: LD_INT 2
64046: PUSH
64047: LD_INT 1
64049: PUSH
64050: EMPTY
64051: LIST
64052: LIST
64053: PUSH
64054: LD_INT 1
64056: NEG
64057: PUSH
64058: LD_INT 1
64060: PUSH
64061: EMPTY
64062: LIST
64063: LIST
64064: PUSH
64065: LD_INT 2
64067: NEG
64068: PUSH
64069: LD_INT 0
64071: PUSH
64072: EMPTY
64073: LIST
64074: LIST
64075: PUSH
64076: LD_INT 2
64078: NEG
64079: PUSH
64080: LD_INT 1
64082: NEG
64083: PUSH
64084: EMPTY
64085: LIST
64086: LIST
64087: PUSH
64088: LD_INT 2
64090: NEG
64091: PUSH
64092: LD_INT 1
64094: PUSH
64095: EMPTY
64096: LIST
64097: LIST
64098: PUSH
64099: LD_INT 3
64101: NEG
64102: PUSH
64103: LD_INT 0
64105: PUSH
64106: EMPTY
64107: LIST
64108: LIST
64109: PUSH
64110: LD_INT 3
64112: NEG
64113: PUSH
64114: LD_INT 1
64116: NEG
64117: PUSH
64118: EMPTY
64119: LIST
64120: LIST
64121: PUSH
64122: EMPTY
64123: LIST
64124: LIST
64125: LIST
64126: LIST
64127: LIST
64128: LIST
64129: LIST
64130: LIST
64131: LIST
64132: LIST
64133: LIST
64134: LIST
64135: LIST
64136: LIST
64137: LIST
64138: LIST
64139: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
64140: LD_ADDR_VAR 0 13
64144: PUSH
64145: LD_INT 0
64147: PUSH
64148: LD_INT 0
64150: PUSH
64151: EMPTY
64152: LIST
64153: LIST
64154: PUSH
64155: LD_INT 0
64157: PUSH
64158: LD_INT 1
64160: NEG
64161: PUSH
64162: EMPTY
64163: LIST
64164: LIST
64165: PUSH
64166: LD_INT 1
64168: PUSH
64169: LD_INT 0
64171: PUSH
64172: EMPTY
64173: LIST
64174: LIST
64175: PUSH
64176: LD_INT 1
64178: PUSH
64179: LD_INT 1
64181: PUSH
64182: EMPTY
64183: LIST
64184: LIST
64185: PUSH
64186: LD_INT 0
64188: PUSH
64189: LD_INT 1
64191: PUSH
64192: EMPTY
64193: LIST
64194: LIST
64195: PUSH
64196: LD_INT 1
64198: NEG
64199: PUSH
64200: LD_INT 0
64202: PUSH
64203: EMPTY
64204: LIST
64205: LIST
64206: PUSH
64207: LD_INT 1
64209: NEG
64210: PUSH
64211: LD_INT 1
64213: NEG
64214: PUSH
64215: EMPTY
64216: LIST
64217: LIST
64218: PUSH
64219: LD_INT 1
64221: NEG
64222: PUSH
64223: LD_INT 2
64225: NEG
64226: PUSH
64227: EMPTY
64228: LIST
64229: LIST
64230: PUSH
64231: LD_INT 2
64233: PUSH
64234: LD_INT 1
64236: PUSH
64237: EMPTY
64238: LIST
64239: LIST
64240: PUSH
64241: LD_INT 2
64243: PUSH
64244: LD_INT 2
64246: PUSH
64247: EMPTY
64248: LIST
64249: LIST
64250: PUSH
64251: LD_INT 1
64253: PUSH
64254: LD_INT 2
64256: PUSH
64257: EMPTY
64258: LIST
64259: LIST
64260: PUSH
64261: LD_INT 2
64263: NEG
64264: PUSH
64265: LD_INT 1
64267: NEG
64268: PUSH
64269: EMPTY
64270: LIST
64271: LIST
64272: PUSH
64273: LD_INT 2
64275: NEG
64276: PUSH
64277: LD_INT 2
64279: NEG
64280: PUSH
64281: EMPTY
64282: LIST
64283: LIST
64284: PUSH
64285: LD_INT 2
64287: NEG
64288: PUSH
64289: LD_INT 3
64291: NEG
64292: PUSH
64293: EMPTY
64294: LIST
64295: LIST
64296: PUSH
64297: LD_INT 3
64299: NEG
64300: PUSH
64301: LD_INT 2
64303: NEG
64304: PUSH
64305: EMPTY
64306: LIST
64307: LIST
64308: PUSH
64309: LD_INT 3
64311: NEG
64312: PUSH
64313: LD_INT 3
64315: NEG
64316: PUSH
64317: EMPTY
64318: LIST
64319: LIST
64320: PUSH
64321: EMPTY
64322: LIST
64323: LIST
64324: LIST
64325: LIST
64326: LIST
64327: LIST
64328: LIST
64329: LIST
64330: LIST
64331: LIST
64332: LIST
64333: LIST
64334: LIST
64335: LIST
64336: LIST
64337: LIST
64338: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
64339: LD_ADDR_VAR 0 14
64343: PUSH
64344: LD_INT 0
64346: PUSH
64347: LD_INT 0
64349: PUSH
64350: EMPTY
64351: LIST
64352: LIST
64353: PUSH
64354: LD_INT 0
64356: PUSH
64357: LD_INT 1
64359: NEG
64360: PUSH
64361: EMPTY
64362: LIST
64363: LIST
64364: PUSH
64365: LD_INT 1
64367: PUSH
64368: LD_INT 0
64370: PUSH
64371: EMPTY
64372: LIST
64373: LIST
64374: PUSH
64375: LD_INT 1
64377: PUSH
64378: LD_INT 1
64380: PUSH
64381: EMPTY
64382: LIST
64383: LIST
64384: PUSH
64385: LD_INT 0
64387: PUSH
64388: LD_INT 1
64390: PUSH
64391: EMPTY
64392: LIST
64393: LIST
64394: PUSH
64395: LD_INT 1
64397: NEG
64398: PUSH
64399: LD_INT 0
64401: PUSH
64402: EMPTY
64403: LIST
64404: LIST
64405: PUSH
64406: LD_INT 1
64408: NEG
64409: PUSH
64410: LD_INT 1
64412: NEG
64413: PUSH
64414: EMPTY
64415: LIST
64416: LIST
64417: PUSH
64418: LD_INT 1
64420: NEG
64421: PUSH
64422: LD_INT 2
64424: NEG
64425: PUSH
64426: EMPTY
64427: LIST
64428: LIST
64429: PUSH
64430: LD_INT 0
64432: PUSH
64433: LD_INT 2
64435: NEG
64436: PUSH
64437: EMPTY
64438: LIST
64439: LIST
64440: PUSH
64441: LD_INT 1
64443: PUSH
64444: LD_INT 1
64446: NEG
64447: PUSH
64448: EMPTY
64449: LIST
64450: LIST
64451: PUSH
64452: LD_INT 1
64454: PUSH
64455: LD_INT 2
64457: PUSH
64458: EMPTY
64459: LIST
64460: LIST
64461: PUSH
64462: LD_INT 0
64464: PUSH
64465: LD_INT 2
64467: PUSH
64468: EMPTY
64469: LIST
64470: LIST
64471: PUSH
64472: LD_INT 1
64474: NEG
64475: PUSH
64476: LD_INT 1
64478: PUSH
64479: EMPTY
64480: LIST
64481: LIST
64482: PUSH
64483: LD_INT 1
64485: NEG
64486: PUSH
64487: LD_INT 3
64489: NEG
64490: PUSH
64491: EMPTY
64492: LIST
64493: LIST
64494: PUSH
64495: LD_INT 0
64497: PUSH
64498: LD_INT 3
64500: NEG
64501: PUSH
64502: EMPTY
64503: LIST
64504: LIST
64505: PUSH
64506: LD_INT 1
64508: PUSH
64509: LD_INT 2
64511: NEG
64512: PUSH
64513: EMPTY
64514: LIST
64515: LIST
64516: PUSH
64517: EMPTY
64518: LIST
64519: LIST
64520: LIST
64521: LIST
64522: LIST
64523: LIST
64524: LIST
64525: LIST
64526: LIST
64527: LIST
64528: LIST
64529: LIST
64530: LIST
64531: LIST
64532: LIST
64533: LIST
64534: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
64535: LD_ADDR_VAR 0 15
64539: PUSH
64540: LD_INT 0
64542: PUSH
64543: LD_INT 0
64545: PUSH
64546: EMPTY
64547: LIST
64548: LIST
64549: PUSH
64550: LD_INT 0
64552: PUSH
64553: LD_INT 1
64555: NEG
64556: PUSH
64557: EMPTY
64558: LIST
64559: LIST
64560: PUSH
64561: LD_INT 1
64563: PUSH
64564: LD_INT 0
64566: PUSH
64567: EMPTY
64568: LIST
64569: LIST
64570: PUSH
64571: LD_INT 1
64573: PUSH
64574: LD_INT 1
64576: PUSH
64577: EMPTY
64578: LIST
64579: LIST
64580: PUSH
64581: LD_INT 0
64583: PUSH
64584: LD_INT 1
64586: PUSH
64587: EMPTY
64588: LIST
64589: LIST
64590: PUSH
64591: LD_INT 1
64593: NEG
64594: PUSH
64595: LD_INT 0
64597: PUSH
64598: EMPTY
64599: LIST
64600: LIST
64601: PUSH
64602: LD_INT 1
64604: NEG
64605: PUSH
64606: LD_INT 1
64608: NEG
64609: PUSH
64610: EMPTY
64611: LIST
64612: LIST
64613: PUSH
64614: LD_INT 1
64616: PUSH
64617: LD_INT 1
64619: NEG
64620: PUSH
64621: EMPTY
64622: LIST
64623: LIST
64624: PUSH
64625: LD_INT 2
64627: PUSH
64628: LD_INT 0
64630: PUSH
64631: EMPTY
64632: LIST
64633: LIST
64634: PUSH
64635: LD_INT 2
64637: PUSH
64638: LD_INT 1
64640: PUSH
64641: EMPTY
64642: LIST
64643: LIST
64644: PUSH
64645: LD_INT 1
64647: NEG
64648: PUSH
64649: LD_INT 1
64651: PUSH
64652: EMPTY
64653: LIST
64654: LIST
64655: PUSH
64656: LD_INT 2
64658: NEG
64659: PUSH
64660: LD_INT 0
64662: PUSH
64663: EMPTY
64664: LIST
64665: LIST
64666: PUSH
64667: LD_INT 2
64669: NEG
64670: PUSH
64671: LD_INT 1
64673: NEG
64674: PUSH
64675: EMPTY
64676: LIST
64677: LIST
64678: PUSH
64679: LD_INT 2
64681: PUSH
64682: LD_INT 1
64684: NEG
64685: PUSH
64686: EMPTY
64687: LIST
64688: LIST
64689: PUSH
64690: LD_INT 3
64692: PUSH
64693: LD_INT 0
64695: PUSH
64696: EMPTY
64697: LIST
64698: LIST
64699: PUSH
64700: LD_INT 3
64702: PUSH
64703: LD_INT 1
64705: PUSH
64706: EMPTY
64707: LIST
64708: LIST
64709: PUSH
64710: EMPTY
64711: LIST
64712: LIST
64713: LIST
64714: LIST
64715: LIST
64716: LIST
64717: LIST
64718: LIST
64719: LIST
64720: LIST
64721: LIST
64722: LIST
64723: LIST
64724: LIST
64725: LIST
64726: LIST
64727: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
64728: LD_ADDR_VAR 0 16
64732: PUSH
64733: LD_INT 0
64735: PUSH
64736: LD_INT 0
64738: PUSH
64739: EMPTY
64740: LIST
64741: LIST
64742: PUSH
64743: LD_INT 0
64745: PUSH
64746: LD_INT 1
64748: NEG
64749: PUSH
64750: EMPTY
64751: LIST
64752: LIST
64753: PUSH
64754: LD_INT 1
64756: PUSH
64757: LD_INT 0
64759: PUSH
64760: EMPTY
64761: LIST
64762: LIST
64763: PUSH
64764: LD_INT 1
64766: PUSH
64767: LD_INT 1
64769: PUSH
64770: EMPTY
64771: LIST
64772: LIST
64773: PUSH
64774: LD_INT 0
64776: PUSH
64777: LD_INT 1
64779: PUSH
64780: EMPTY
64781: LIST
64782: LIST
64783: PUSH
64784: LD_INT 1
64786: NEG
64787: PUSH
64788: LD_INT 0
64790: PUSH
64791: EMPTY
64792: LIST
64793: LIST
64794: PUSH
64795: LD_INT 1
64797: NEG
64798: PUSH
64799: LD_INT 1
64801: NEG
64802: PUSH
64803: EMPTY
64804: LIST
64805: LIST
64806: PUSH
64807: LD_INT 1
64809: NEG
64810: PUSH
64811: LD_INT 2
64813: NEG
64814: PUSH
64815: EMPTY
64816: LIST
64817: LIST
64818: PUSH
64819: LD_INT 2
64821: PUSH
64822: LD_INT 1
64824: PUSH
64825: EMPTY
64826: LIST
64827: LIST
64828: PUSH
64829: LD_INT 2
64831: PUSH
64832: LD_INT 2
64834: PUSH
64835: EMPTY
64836: LIST
64837: LIST
64838: PUSH
64839: LD_INT 1
64841: PUSH
64842: LD_INT 2
64844: PUSH
64845: EMPTY
64846: LIST
64847: LIST
64848: PUSH
64849: LD_INT 2
64851: NEG
64852: PUSH
64853: LD_INT 1
64855: NEG
64856: PUSH
64857: EMPTY
64858: LIST
64859: LIST
64860: PUSH
64861: LD_INT 2
64863: NEG
64864: PUSH
64865: LD_INT 2
64867: NEG
64868: PUSH
64869: EMPTY
64870: LIST
64871: LIST
64872: PUSH
64873: LD_INT 3
64875: PUSH
64876: LD_INT 2
64878: PUSH
64879: EMPTY
64880: LIST
64881: LIST
64882: PUSH
64883: LD_INT 3
64885: PUSH
64886: LD_INT 3
64888: PUSH
64889: EMPTY
64890: LIST
64891: LIST
64892: PUSH
64893: LD_INT 2
64895: PUSH
64896: LD_INT 3
64898: PUSH
64899: EMPTY
64900: LIST
64901: LIST
64902: PUSH
64903: EMPTY
64904: LIST
64905: LIST
64906: LIST
64907: LIST
64908: LIST
64909: LIST
64910: LIST
64911: LIST
64912: LIST
64913: LIST
64914: LIST
64915: LIST
64916: LIST
64917: LIST
64918: LIST
64919: LIST
64920: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64921: LD_ADDR_VAR 0 17
64925: PUSH
64926: LD_INT 0
64928: PUSH
64929: LD_INT 0
64931: PUSH
64932: EMPTY
64933: LIST
64934: LIST
64935: PUSH
64936: LD_INT 0
64938: PUSH
64939: LD_INT 1
64941: NEG
64942: PUSH
64943: EMPTY
64944: LIST
64945: LIST
64946: PUSH
64947: LD_INT 1
64949: PUSH
64950: LD_INT 0
64952: PUSH
64953: EMPTY
64954: LIST
64955: LIST
64956: PUSH
64957: LD_INT 1
64959: PUSH
64960: LD_INT 1
64962: PUSH
64963: EMPTY
64964: LIST
64965: LIST
64966: PUSH
64967: LD_INT 0
64969: PUSH
64970: LD_INT 1
64972: PUSH
64973: EMPTY
64974: LIST
64975: LIST
64976: PUSH
64977: LD_INT 1
64979: NEG
64980: PUSH
64981: LD_INT 0
64983: PUSH
64984: EMPTY
64985: LIST
64986: LIST
64987: PUSH
64988: LD_INT 1
64990: NEG
64991: PUSH
64992: LD_INT 1
64994: NEG
64995: PUSH
64996: EMPTY
64997: LIST
64998: LIST
64999: PUSH
65000: LD_INT 1
65002: NEG
65003: PUSH
65004: LD_INT 2
65006: NEG
65007: PUSH
65008: EMPTY
65009: LIST
65010: LIST
65011: PUSH
65012: LD_INT 0
65014: PUSH
65015: LD_INT 2
65017: NEG
65018: PUSH
65019: EMPTY
65020: LIST
65021: LIST
65022: PUSH
65023: LD_INT 1
65025: PUSH
65026: LD_INT 1
65028: NEG
65029: PUSH
65030: EMPTY
65031: LIST
65032: LIST
65033: PUSH
65034: LD_INT 2
65036: PUSH
65037: LD_INT 0
65039: PUSH
65040: EMPTY
65041: LIST
65042: LIST
65043: PUSH
65044: LD_INT 2
65046: PUSH
65047: LD_INT 1
65049: PUSH
65050: EMPTY
65051: LIST
65052: LIST
65053: PUSH
65054: LD_INT 2
65056: PUSH
65057: LD_INT 2
65059: PUSH
65060: EMPTY
65061: LIST
65062: LIST
65063: PUSH
65064: LD_INT 1
65066: PUSH
65067: LD_INT 2
65069: PUSH
65070: EMPTY
65071: LIST
65072: LIST
65073: PUSH
65074: LD_INT 0
65076: PUSH
65077: LD_INT 2
65079: PUSH
65080: EMPTY
65081: LIST
65082: LIST
65083: PUSH
65084: LD_INT 1
65086: NEG
65087: PUSH
65088: LD_INT 1
65090: PUSH
65091: EMPTY
65092: LIST
65093: LIST
65094: PUSH
65095: LD_INT 2
65097: NEG
65098: PUSH
65099: LD_INT 0
65101: PUSH
65102: EMPTY
65103: LIST
65104: LIST
65105: PUSH
65106: LD_INT 2
65108: NEG
65109: PUSH
65110: LD_INT 1
65112: NEG
65113: PUSH
65114: EMPTY
65115: LIST
65116: LIST
65117: PUSH
65118: LD_INT 2
65120: NEG
65121: PUSH
65122: LD_INT 2
65124: NEG
65125: PUSH
65126: EMPTY
65127: LIST
65128: LIST
65129: PUSH
65130: EMPTY
65131: LIST
65132: LIST
65133: LIST
65134: LIST
65135: LIST
65136: LIST
65137: LIST
65138: LIST
65139: LIST
65140: LIST
65141: LIST
65142: LIST
65143: LIST
65144: LIST
65145: LIST
65146: LIST
65147: LIST
65148: LIST
65149: LIST
65150: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65151: LD_ADDR_VAR 0 18
65155: PUSH
65156: LD_INT 0
65158: PUSH
65159: LD_INT 0
65161: PUSH
65162: EMPTY
65163: LIST
65164: LIST
65165: PUSH
65166: LD_INT 0
65168: PUSH
65169: LD_INT 1
65171: NEG
65172: PUSH
65173: EMPTY
65174: LIST
65175: LIST
65176: PUSH
65177: LD_INT 1
65179: PUSH
65180: LD_INT 0
65182: PUSH
65183: EMPTY
65184: LIST
65185: LIST
65186: PUSH
65187: LD_INT 1
65189: PUSH
65190: LD_INT 1
65192: PUSH
65193: EMPTY
65194: LIST
65195: LIST
65196: PUSH
65197: LD_INT 0
65199: PUSH
65200: LD_INT 1
65202: PUSH
65203: EMPTY
65204: LIST
65205: LIST
65206: PUSH
65207: LD_INT 1
65209: NEG
65210: PUSH
65211: LD_INT 0
65213: PUSH
65214: EMPTY
65215: LIST
65216: LIST
65217: PUSH
65218: LD_INT 1
65220: NEG
65221: PUSH
65222: LD_INT 1
65224: NEG
65225: PUSH
65226: EMPTY
65227: LIST
65228: LIST
65229: PUSH
65230: LD_INT 1
65232: NEG
65233: PUSH
65234: LD_INT 2
65236: NEG
65237: PUSH
65238: EMPTY
65239: LIST
65240: LIST
65241: PUSH
65242: LD_INT 0
65244: PUSH
65245: LD_INT 2
65247: NEG
65248: PUSH
65249: EMPTY
65250: LIST
65251: LIST
65252: PUSH
65253: LD_INT 1
65255: PUSH
65256: LD_INT 1
65258: NEG
65259: PUSH
65260: EMPTY
65261: LIST
65262: LIST
65263: PUSH
65264: LD_INT 2
65266: PUSH
65267: LD_INT 0
65269: PUSH
65270: EMPTY
65271: LIST
65272: LIST
65273: PUSH
65274: LD_INT 2
65276: PUSH
65277: LD_INT 1
65279: PUSH
65280: EMPTY
65281: LIST
65282: LIST
65283: PUSH
65284: LD_INT 2
65286: PUSH
65287: LD_INT 2
65289: PUSH
65290: EMPTY
65291: LIST
65292: LIST
65293: PUSH
65294: LD_INT 1
65296: PUSH
65297: LD_INT 2
65299: PUSH
65300: EMPTY
65301: LIST
65302: LIST
65303: PUSH
65304: LD_INT 0
65306: PUSH
65307: LD_INT 2
65309: PUSH
65310: EMPTY
65311: LIST
65312: LIST
65313: PUSH
65314: LD_INT 1
65316: NEG
65317: PUSH
65318: LD_INT 1
65320: PUSH
65321: EMPTY
65322: LIST
65323: LIST
65324: PUSH
65325: LD_INT 2
65327: NEG
65328: PUSH
65329: LD_INT 0
65331: PUSH
65332: EMPTY
65333: LIST
65334: LIST
65335: PUSH
65336: LD_INT 2
65338: NEG
65339: PUSH
65340: LD_INT 1
65342: NEG
65343: PUSH
65344: EMPTY
65345: LIST
65346: LIST
65347: PUSH
65348: LD_INT 2
65350: NEG
65351: PUSH
65352: LD_INT 2
65354: NEG
65355: PUSH
65356: EMPTY
65357: LIST
65358: LIST
65359: PUSH
65360: EMPTY
65361: LIST
65362: LIST
65363: LIST
65364: LIST
65365: LIST
65366: LIST
65367: LIST
65368: LIST
65369: LIST
65370: LIST
65371: LIST
65372: LIST
65373: LIST
65374: LIST
65375: LIST
65376: LIST
65377: LIST
65378: LIST
65379: LIST
65380: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65381: LD_ADDR_VAR 0 19
65385: PUSH
65386: LD_INT 0
65388: PUSH
65389: LD_INT 0
65391: PUSH
65392: EMPTY
65393: LIST
65394: LIST
65395: PUSH
65396: LD_INT 0
65398: PUSH
65399: LD_INT 1
65401: NEG
65402: PUSH
65403: EMPTY
65404: LIST
65405: LIST
65406: PUSH
65407: LD_INT 1
65409: PUSH
65410: LD_INT 0
65412: PUSH
65413: EMPTY
65414: LIST
65415: LIST
65416: PUSH
65417: LD_INT 1
65419: PUSH
65420: LD_INT 1
65422: PUSH
65423: EMPTY
65424: LIST
65425: LIST
65426: PUSH
65427: LD_INT 0
65429: PUSH
65430: LD_INT 1
65432: PUSH
65433: EMPTY
65434: LIST
65435: LIST
65436: PUSH
65437: LD_INT 1
65439: NEG
65440: PUSH
65441: LD_INT 0
65443: PUSH
65444: EMPTY
65445: LIST
65446: LIST
65447: PUSH
65448: LD_INT 1
65450: NEG
65451: PUSH
65452: LD_INT 1
65454: NEG
65455: PUSH
65456: EMPTY
65457: LIST
65458: LIST
65459: PUSH
65460: LD_INT 1
65462: NEG
65463: PUSH
65464: LD_INT 2
65466: NEG
65467: PUSH
65468: EMPTY
65469: LIST
65470: LIST
65471: PUSH
65472: LD_INT 0
65474: PUSH
65475: LD_INT 2
65477: NEG
65478: PUSH
65479: EMPTY
65480: LIST
65481: LIST
65482: PUSH
65483: LD_INT 1
65485: PUSH
65486: LD_INT 1
65488: NEG
65489: PUSH
65490: EMPTY
65491: LIST
65492: LIST
65493: PUSH
65494: LD_INT 2
65496: PUSH
65497: LD_INT 0
65499: PUSH
65500: EMPTY
65501: LIST
65502: LIST
65503: PUSH
65504: LD_INT 2
65506: PUSH
65507: LD_INT 1
65509: PUSH
65510: EMPTY
65511: LIST
65512: LIST
65513: PUSH
65514: LD_INT 2
65516: PUSH
65517: LD_INT 2
65519: PUSH
65520: EMPTY
65521: LIST
65522: LIST
65523: PUSH
65524: LD_INT 1
65526: PUSH
65527: LD_INT 2
65529: PUSH
65530: EMPTY
65531: LIST
65532: LIST
65533: PUSH
65534: LD_INT 0
65536: PUSH
65537: LD_INT 2
65539: PUSH
65540: EMPTY
65541: LIST
65542: LIST
65543: PUSH
65544: LD_INT 1
65546: NEG
65547: PUSH
65548: LD_INT 1
65550: PUSH
65551: EMPTY
65552: LIST
65553: LIST
65554: PUSH
65555: LD_INT 2
65557: NEG
65558: PUSH
65559: LD_INT 0
65561: PUSH
65562: EMPTY
65563: LIST
65564: LIST
65565: PUSH
65566: LD_INT 2
65568: NEG
65569: PUSH
65570: LD_INT 1
65572: NEG
65573: PUSH
65574: EMPTY
65575: LIST
65576: LIST
65577: PUSH
65578: LD_INT 2
65580: NEG
65581: PUSH
65582: LD_INT 2
65584: NEG
65585: PUSH
65586: EMPTY
65587: LIST
65588: LIST
65589: PUSH
65590: EMPTY
65591: LIST
65592: LIST
65593: LIST
65594: LIST
65595: LIST
65596: LIST
65597: LIST
65598: LIST
65599: LIST
65600: LIST
65601: LIST
65602: LIST
65603: LIST
65604: LIST
65605: LIST
65606: LIST
65607: LIST
65608: LIST
65609: LIST
65610: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65611: LD_ADDR_VAR 0 20
65615: PUSH
65616: LD_INT 0
65618: PUSH
65619: LD_INT 0
65621: PUSH
65622: EMPTY
65623: LIST
65624: LIST
65625: PUSH
65626: LD_INT 0
65628: PUSH
65629: LD_INT 1
65631: NEG
65632: PUSH
65633: EMPTY
65634: LIST
65635: LIST
65636: PUSH
65637: LD_INT 1
65639: PUSH
65640: LD_INT 0
65642: PUSH
65643: EMPTY
65644: LIST
65645: LIST
65646: PUSH
65647: LD_INT 1
65649: PUSH
65650: LD_INT 1
65652: PUSH
65653: EMPTY
65654: LIST
65655: LIST
65656: PUSH
65657: LD_INT 0
65659: PUSH
65660: LD_INT 1
65662: PUSH
65663: EMPTY
65664: LIST
65665: LIST
65666: PUSH
65667: LD_INT 1
65669: NEG
65670: PUSH
65671: LD_INT 0
65673: PUSH
65674: EMPTY
65675: LIST
65676: LIST
65677: PUSH
65678: LD_INT 1
65680: NEG
65681: PUSH
65682: LD_INT 1
65684: NEG
65685: PUSH
65686: EMPTY
65687: LIST
65688: LIST
65689: PUSH
65690: LD_INT 1
65692: NEG
65693: PUSH
65694: LD_INT 2
65696: NEG
65697: PUSH
65698: EMPTY
65699: LIST
65700: LIST
65701: PUSH
65702: LD_INT 0
65704: PUSH
65705: LD_INT 2
65707: NEG
65708: PUSH
65709: EMPTY
65710: LIST
65711: LIST
65712: PUSH
65713: LD_INT 1
65715: PUSH
65716: LD_INT 1
65718: NEG
65719: PUSH
65720: EMPTY
65721: LIST
65722: LIST
65723: PUSH
65724: LD_INT 2
65726: PUSH
65727: LD_INT 0
65729: PUSH
65730: EMPTY
65731: LIST
65732: LIST
65733: PUSH
65734: LD_INT 2
65736: PUSH
65737: LD_INT 1
65739: PUSH
65740: EMPTY
65741: LIST
65742: LIST
65743: PUSH
65744: LD_INT 2
65746: PUSH
65747: LD_INT 2
65749: PUSH
65750: EMPTY
65751: LIST
65752: LIST
65753: PUSH
65754: LD_INT 1
65756: PUSH
65757: LD_INT 2
65759: PUSH
65760: EMPTY
65761: LIST
65762: LIST
65763: PUSH
65764: LD_INT 0
65766: PUSH
65767: LD_INT 2
65769: PUSH
65770: EMPTY
65771: LIST
65772: LIST
65773: PUSH
65774: LD_INT 1
65776: NEG
65777: PUSH
65778: LD_INT 1
65780: PUSH
65781: EMPTY
65782: LIST
65783: LIST
65784: PUSH
65785: LD_INT 2
65787: NEG
65788: PUSH
65789: LD_INT 0
65791: PUSH
65792: EMPTY
65793: LIST
65794: LIST
65795: PUSH
65796: LD_INT 2
65798: NEG
65799: PUSH
65800: LD_INT 1
65802: NEG
65803: PUSH
65804: EMPTY
65805: LIST
65806: LIST
65807: PUSH
65808: LD_INT 2
65810: NEG
65811: PUSH
65812: LD_INT 2
65814: NEG
65815: PUSH
65816: EMPTY
65817: LIST
65818: LIST
65819: PUSH
65820: EMPTY
65821: LIST
65822: LIST
65823: LIST
65824: LIST
65825: LIST
65826: LIST
65827: LIST
65828: LIST
65829: LIST
65830: LIST
65831: LIST
65832: LIST
65833: LIST
65834: LIST
65835: LIST
65836: LIST
65837: LIST
65838: LIST
65839: LIST
65840: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65841: LD_ADDR_VAR 0 21
65845: PUSH
65846: LD_INT 0
65848: PUSH
65849: LD_INT 0
65851: PUSH
65852: EMPTY
65853: LIST
65854: LIST
65855: PUSH
65856: LD_INT 0
65858: PUSH
65859: LD_INT 1
65861: NEG
65862: PUSH
65863: EMPTY
65864: LIST
65865: LIST
65866: PUSH
65867: LD_INT 1
65869: PUSH
65870: LD_INT 0
65872: PUSH
65873: EMPTY
65874: LIST
65875: LIST
65876: PUSH
65877: LD_INT 1
65879: PUSH
65880: LD_INT 1
65882: PUSH
65883: EMPTY
65884: LIST
65885: LIST
65886: PUSH
65887: LD_INT 0
65889: PUSH
65890: LD_INT 1
65892: PUSH
65893: EMPTY
65894: LIST
65895: LIST
65896: PUSH
65897: LD_INT 1
65899: NEG
65900: PUSH
65901: LD_INT 0
65903: PUSH
65904: EMPTY
65905: LIST
65906: LIST
65907: PUSH
65908: LD_INT 1
65910: NEG
65911: PUSH
65912: LD_INT 1
65914: NEG
65915: PUSH
65916: EMPTY
65917: LIST
65918: LIST
65919: PUSH
65920: LD_INT 1
65922: NEG
65923: PUSH
65924: LD_INT 2
65926: NEG
65927: PUSH
65928: EMPTY
65929: LIST
65930: LIST
65931: PUSH
65932: LD_INT 0
65934: PUSH
65935: LD_INT 2
65937: NEG
65938: PUSH
65939: EMPTY
65940: LIST
65941: LIST
65942: PUSH
65943: LD_INT 1
65945: PUSH
65946: LD_INT 1
65948: NEG
65949: PUSH
65950: EMPTY
65951: LIST
65952: LIST
65953: PUSH
65954: LD_INT 2
65956: PUSH
65957: LD_INT 0
65959: PUSH
65960: EMPTY
65961: LIST
65962: LIST
65963: PUSH
65964: LD_INT 2
65966: PUSH
65967: LD_INT 1
65969: PUSH
65970: EMPTY
65971: LIST
65972: LIST
65973: PUSH
65974: LD_INT 2
65976: PUSH
65977: LD_INT 2
65979: PUSH
65980: EMPTY
65981: LIST
65982: LIST
65983: PUSH
65984: LD_INT 1
65986: PUSH
65987: LD_INT 2
65989: PUSH
65990: EMPTY
65991: LIST
65992: LIST
65993: PUSH
65994: LD_INT 0
65996: PUSH
65997: LD_INT 2
65999: PUSH
66000: EMPTY
66001: LIST
66002: LIST
66003: PUSH
66004: LD_INT 1
66006: NEG
66007: PUSH
66008: LD_INT 1
66010: PUSH
66011: EMPTY
66012: LIST
66013: LIST
66014: PUSH
66015: LD_INT 2
66017: NEG
66018: PUSH
66019: LD_INT 0
66021: PUSH
66022: EMPTY
66023: LIST
66024: LIST
66025: PUSH
66026: LD_INT 2
66028: NEG
66029: PUSH
66030: LD_INT 1
66032: NEG
66033: PUSH
66034: EMPTY
66035: LIST
66036: LIST
66037: PUSH
66038: LD_INT 2
66040: NEG
66041: PUSH
66042: LD_INT 2
66044: NEG
66045: PUSH
66046: EMPTY
66047: LIST
66048: LIST
66049: PUSH
66050: EMPTY
66051: LIST
66052: LIST
66053: LIST
66054: LIST
66055: LIST
66056: LIST
66057: LIST
66058: LIST
66059: LIST
66060: LIST
66061: LIST
66062: LIST
66063: LIST
66064: LIST
66065: LIST
66066: LIST
66067: LIST
66068: LIST
66069: LIST
66070: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66071: LD_ADDR_VAR 0 22
66075: PUSH
66076: LD_INT 0
66078: PUSH
66079: LD_INT 0
66081: PUSH
66082: EMPTY
66083: LIST
66084: LIST
66085: PUSH
66086: LD_INT 0
66088: PUSH
66089: LD_INT 1
66091: NEG
66092: PUSH
66093: EMPTY
66094: LIST
66095: LIST
66096: PUSH
66097: LD_INT 1
66099: PUSH
66100: LD_INT 0
66102: PUSH
66103: EMPTY
66104: LIST
66105: LIST
66106: PUSH
66107: LD_INT 1
66109: PUSH
66110: LD_INT 1
66112: PUSH
66113: EMPTY
66114: LIST
66115: LIST
66116: PUSH
66117: LD_INT 0
66119: PUSH
66120: LD_INT 1
66122: PUSH
66123: EMPTY
66124: LIST
66125: LIST
66126: PUSH
66127: LD_INT 1
66129: NEG
66130: PUSH
66131: LD_INT 0
66133: PUSH
66134: EMPTY
66135: LIST
66136: LIST
66137: PUSH
66138: LD_INT 1
66140: NEG
66141: PUSH
66142: LD_INT 1
66144: NEG
66145: PUSH
66146: EMPTY
66147: LIST
66148: LIST
66149: PUSH
66150: LD_INT 1
66152: NEG
66153: PUSH
66154: LD_INT 2
66156: NEG
66157: PUSH
66158: EMPTY
66159: LIST
66160: LIST
66161: PUSH
66162: LD_INT 0
66164: PUSH
66165: LD_INT 2
66167: NEG
66168: PUSH
66169: EMPTY
66170: LIST
66171: LIST
66172: PUSH
66173: LD_INT 1
66175: PUSH
66176: LD_INT 1
66178: NEG
66179: PUSH
66180: EMPTY
66181: LIST
66182: LIST
66183: PUSH
66184: LD_INT 2
66186: PUSH
66187: LD_INT 0
66189: PUSH
66190: EMPTY
66191: LIST
66192: LIST
66193: PUSH
66194: LD_INT 2
66196: PUSH
66197: LD_INT 1
66199: PUSH
66200: EMPTY
66201: LIST
66202: LIST
66203: PUSH
66204: LD_INT 2
66206: PUSH
66207: LD_INT 2
66209: PUSH
66210: EMPTY
66211: LIST
66212: LIST
66213: PUSH
66214: LD_INT 1
66216: PUSH
66217: LD_INT 2
66219: PUSH
66220: EMPTY
66221: LIST
66222: LIST
66223: PUSH
66224: LD_INT 0
66226: PUSH
66227: LD_INT 2
66229: PUSH
66230: EMPTY
66231: LIST
66232: LIST
66233: PUSH
66234: LD_INT 1
66236: NEG
66237: PUSH
66238: LD_INT 1
66240: PUSH
66241: EMPTY
66242: LIST
66243: LIST
66244: PUSH
66245: LD_INT 2
66247: NEG
66248: PUSH
66249: LD_INT 0
66251: PUSH
66252: EMPTY
66253: LIST
66254: LIST
66255: PUSH
66256: LD_INT 2
66258: NEG
66259: PUSH
66260: LD_INT 1
66262: NEG
66263: PUSH
66264: EMPTY
66265: LIST
66266: LIST
66267: PUSH
66268: LD_INT 2
66270: NEG
66271: PUSH
66272: LD_INT 2
66274: NEG
66275: PUSH
66276: EMPTY
66277: LIST
66278: LIST
66279: PUSH
66280: EMPTY
66281: LIST
66282: LIST
66283: LIST
66284: LIST
66285: LIST
66286: LIST
66287: LIST
66288: LIST
66289: LIST
66290: LIST
66291: LIST
66292: LIST
66293: LIST
66294: LIST
66295: LIST
66296: LIST
66297: LIST
66298: LIST
66299: LIST
66300: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
66301: LD_ADDR_VAR 0 23
66305: PUSH
66306: LD_INT 0
66308: PUSH
66309: LD_INT 0
66311: PUSH
66312: EMPTY
66313: LIST
66314: LIST
66315: PUSH
66316: LD_INT 0
66318: PUSH
66319: LD_INT 1
66321: NEG
66322: PUSH
66323: EMPTY
66324: LIST
66325: LIST
66326: PUSH
66327: LD_INT 1
66329: PUSH
66330: LD_INT 0
66332: PUSH
66333: EMPTY
66334: LIST
66335: LIST
66336: PUSH
66337: LD_INT 1
66339: PUSH
66340: LD_INT 1
66342: PUSH
66343: EMPTY
66344: LIST
66345: LIST
66346: PUSH
66347: LD_INT 0
66349: PUSH
66350: LD_INT 1
66352: PUSH
66353: EMPTY
66354: LIST
66355: LIST
66356: PUSH
66357: LD_INT 1
66359: NEG
66360: PUSH
66361: LD_INT 0
66363: PUSH
66364: EMPTY
66365: LIST
66366: LIST
66367: PUSH
66368: LD_INT 1
66370: NEG
66371: PUSH
66372: LD_INT 1
66374: NEG
66375: PUSH
66376: EMPTY
66377: LIST
66378: LIST
66379: PUSH
66380: LD_INT 1
66382: NEG
66383: PUSH
66384: LD_INT 2
66386: NEG
66387: PUSH
66388: EMPTY
66389: LIST
66390: LIST
66391: PUSH
66392: LD_INT 0
66394: PUSH
66395: LD_INT 2
66397: NEG
66398: PUSH
66399: EMPTY
66400: LIST
66401: LIST
66402: PUSH
66403: LD_INT 1
66405: PUSH
66406: LD_INT 1
66408: NEG
66409: PUSH
66410: EMPTY
66411: LIST
66412: LIST
66413: PUSH
66414: LD_INT 2
66416: PUSH
66417: LD_INT 0
66419: PUSH
66420: EMPTY
66421: LIST
66422: LIST
66423: PUSH
66424: LD_INT 2
66426: PUSH
66427: LD_INT 1
66429: PUSH
66430: EMPTY
66431: LIST
66432: LIST
66433: PUSH
66434: LD_INT 2
66436: PUSH
66437: LD_INT 2
66439: PUSH
66440: EMPTY
66441: LIST
66442: LIST
66443: PUSH
66444: LD_INT 1
66446: PUSH
66447: LD_INT 2
66449: PUSH
66450: EMPTY
66451: LIST
66452: LIST
66453: PUSH
66454: LD_INT 0
66456: PUSH
66457: LD_INT 2
66459: PUSH
66460: EMPTY
66461: LIST
66462: LIST
66463: PUSH
66464: LD_INT 1
66466: NEG
66467: PUSH
66468: LD_INT 1
66470: PUSH
66471: EMPTY
66472: LIST
66473: LIST
66474: PUSH
66475: LD_INT 2
66477: NEG
66478: PUSH
66479: LD_INT 0
66481: PUSH
66482: EMPTY
66483: LIST
66484: LIST
66485: PUSH
66486: LD_INT 2
66488: NEG
66489: PUSH
66490: LD_INT 1
66492: NEG
66493: PUSH
66494: EMPTY
66495: LIST
66496: LIST
66497: PUSH
66498: LD_INT 2
66500: NEG
66501: PUSH
66502: LD_INT 2
66504: NEG
66505: PUSH
66506: EMPTY
66507: LIST
66508: LIST
66509: PUSH
66510: LD_INT 2
66512: NEG
66513: PUSH
66514: LD_INT 3
66516: NEG
66517: PUSH
66518: EMPTY
66519: LIST
66520: LIST
66521: PUSH
66522: LD_INT 1
66524: NEG
66525: PUSH
66526: LD_INT 3
66528: NEG
66529: PUSH
66530: EMPTY
66531: LIST
66532: LIST
66533: PUSH
66534: LD_INT 1
66536: PUSH
66537: LD_INT 2
66539: NEG
66540: PUSH
66541: EMPTY
66542: LIST
66543: LIST
66544: PUSH
66545: LD_INT 2
66547: PUSH
66548: LD_INT 1
66550: NEG
66551: PUSH
66552: EMPTY
66553: LIST
66554: LIST
66555: PUSH
66556: EMPTY
66557: LIST
66558: LIST
66559: LIST
66560: LIST
66561: LIST
66562: LIST
66563: LIST
66564: LIST
66565: LIST
66566: LIST
66567: LIST
66568: LIST
66569: LIST
66570: LIST
66571: LIST
66572: LIST
66573: LIST
66574: LIST
66575: LIST
66576: LIST
66577: LIST
66578: LIST
66579: LIST
66580: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
66581: LD_ADDR_VAR 0 24
66585: PUSH
66586: LD_INT 0
66588: PUSH
66589: LD_INT 0
66591: PUSH
66592: EMPTY
66593: LIST
66594: LIST
66595: PUSH
66596: LD_INT 0
66598: PUSH
66599: LD_INT 1
66601: NEG
66602: PUSH
66603: EMPTY
66604: LIST
66605: LIST
66606: PUSH
66607: LD_INT 1
66609: PUSH
66610: LD_INT 0
66612: PUSH
66613: EMPTY
66614: LIST
66615: LIST
66616: PUSH
66617: LD_INT 1
66619: PUSH
66620: LD_INT 1
66622: PUSH
66623: EMPTY
66624: LIST
66625: LIST
66626: PUSH
66627: LD_INT 0
66629: PUSH
66630: LD_INT 1
66632: PUSH
66633: EMPTY
66634: LIST
66635: LIST
66636: PUSH
66637: LD_INT 1
66639: NEG
66640: PUSH
66641: LD_INT 0
66643: PUSH
66644: EMPTY
66645: LIST
66646: LIST
66647: PUSH
66648: LD_INT 1
66650: NEG
66651: PUSH
66652: LD_INT 1
66654: NEG
66655: PUSH
66656: EMPTY
66657: LIST
66658: LIST
66659: PUSH
66660: LD_INT 1
66662: NEG
66663: PUSH
66664: LD_INT 2
66666: NEG
66667: PUSH
66668: EMPTY
66669: LIST
66670: LIST
66671: PUSH
66672: LD_INT 0
66674: PUSH
66675: LD_INT 2
66677: NEG
66678: PUSH
66679: EMPTY
66680: LIST
66681: LIST
66682: PUSH
66683: LD_INT 1
66685: PUSH
66686: LD_INT 1
66688: NEG
66689: PUSH
66690: EMPTY
66691: LIST
66692: LIST
66693: PUSH
66694: LD_INT 2
66696: PUSH
66697: LD_INT 0
66699: PUSH
66700: EMPTY
66701: LIST
66702: LIST
66703: PUSH
66704: LD_INT 2
66706: PUSH
66707: LD_INT 1
66709: PUSH
66710: EMPTY
66711: LIST
66712: LIST
66713: PUSH
66714: LD_INT 2
66716: PUSH
66717: LD_INT 2
66719: PUSH
66720: EMPTY
66721: LIST
66722: LIST
66723: PUSH
66724: LD_INT 1
66726: PUSH
66727: LD_INT 2
66729: PUSH
66730: EMPTY
66731: LIST
66732: LIST
66733: PUSH
66734: LD_INT 0
66736: PUSH
66737: LD_INT 2
66739: PUSH
66740: EMPTY
66741: LIST
66742: LIST
66743: PUSH
66744: LD_INT 1
66746: NEG
66747: PUSH
66748: LD_INT 1
66750: PUSH
66751: EMPTY
66752: LIST
66753: LIST
66754: PUSH
66755: LD_INT 2
66757: NEG
66758: PUSH
66759: LD_INT 0
66761: PUSH
66762: EMPTY
66763: LIST
66764: LIST
66765: PUSH
66766: LD_INT 2
66768: NEG
66769: PUSH
66770: LD_INT 1
66772: NEG
66773: PUSH
66774: EMPTY
66775: LIST
66776: LIST
66777: PUSH
66778: LD_INT 2
66780: NEG
66781: PUSH
66782: LD_INT 2
66784: NEG
66785: PUSH
66786: EMPTY
66787: LIST
66788: LIST
66789: PUSH
66790: LD_INT 1
66792: PUSH
66793: LD_INT 2
66795: NEG
66796: PUSH
66797: EMPTY
66798: LIST
66799: LIST
66800: PUSH
66801: LD_INT 2
66803: PUSH
66804: LD_INT 1
66806: NEG
66807: PUSH
66808: EMPTY
66809: LIST
66810: LIST
66811: PUSH
66812: LD_INT 3
66814: PUSH
66815: LD_INT 1
66817: PUSH
66818: EMPTY
66819: LIST
66820: LIST
66821: PUSH
66822: LD_INT 3
66824: PUSH
66825: LD_INT 2
66827: PUSH
66828: EMPTY
66829: LIST
66830: LIST
66831: PUSH
66832: EMPTY
66833: LIST
66834: LIST
66835: LIST
66836: LIST
66837: LIST
66838: LIST
66839: LIST
66840: LIST
66841: LIST
66842: LIST
66843: LIST
66844: LIST
66845: LIST
66846: LIST
66847: LIST
66848: LIST
66849: LIST
66850: LIST
66851: LIST
66852: LIST
66853: LIST
66854: LIST
66855: LIST
66856: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
66857: LD_ADDR_VAR 0 25
66861: PUSH
66862: LD_INT 0
66864: PUSH
66865: LD_INT 0
66867: PUSH
66868: EMPTY
66869: LIST
66870: LIST
66871: PUSH
66872: LD_INT 0
66874: PUSH
66875: LD_INT 1
66877: NEG
66878: PUSH
66879: EMPTY
66880: LIST
66881: LIST
66882: PUSH
66883: LD_INT 1
66885: PUSH
66886: LD_INT 0
66888: PUSH
66889: EMPTY
66890: LIST
66891: LIST
66892: PUSH
66893: LD_INT 1
66895: PUSH
66896: LD_INT 1
66898: PUSH
66899: EMPTY
66900: LIST
66901: LIST
66902: PUSH
66903: LD_INT 0
66905: PUSH
66906: LD_INT 1
66908: PUSH
66909: EMPTY
66910: LIST
66911: LIST
66912: PUSH
66913: LD_INT 1
66915: NEG
66916: PUSH
66917: LD_INT 0
66919: PUSH
66920: EMPTY
66921: LIST
66922: LIST
66923: PUSH
66924: LD_INT 1
66926: NEG
66927: PUSH
66928: LD_INT 1
66930: NEG
66931: PUSH
66932: EMPTY
66933: LIST
66934: LIST
66935: PUSH
66936: LD_INT 1
66938: NEG
66939: PUSH
66940: LD_INT 2
66942: NEG
66943: PUSH
66944: EMPTY
66945: LIST
66946: LIST
66947: PUSH
66948: LD_INT 0
66950: PUSH
66951: LD_INT 2
66953: NEG
66954: PUSH
66955: EMPTY
66956: LIST
66957: LIST
66958: PUSH
66959: LD_INT 1
66961: PUSH
66962: LD_INT 1
66964: NEG
66965: PUSH
66966: EMPTY
66967: LIST
66968: LIST
66969: PUSH
66970: LD_INT 2
66972: PUSH
66973: LD_INT 0
66975: PUSH
66976: EMPTY
66977: LIST
66978: LIST
66979: PUSH
66980: LD_INT 2
66982: PUSH
66983: LD_INT 1
66985: PUSH
66986: EMPTY
66987: LIST
66988: LIST
66989: PUSH
66990: LD_INT 2
66992: PUSH
66993: LD_INT 2
66995: PUSH
66996: EMPTY
66997: LIST
66998: LIST
66999: PUSH
67000: LD_INT 1
67002: PUSH
67003: LD_INT 2
67005: PUSH
67006: EMPTY
67007: LIST
67008: LIST
67009: PUSH
67010: LD_INT 0
67012: PUSH
67013: LD_INT 2
67015: PUSH
67016: EMPTY
67017: LIST
67018: LIST
67019: PUSH
67020: LD_INT 1
67022: NEG
67023: PUSH
67024: LD_INT 1
67026: PUSH
67027: EMPTY
67028: LIST
67029: LIST
67030: PUSH
67031: LD_INT 2
67033: NEG
67034: PUSH
67035: LD_INT 0
67037: PUSH
67038: EMPTY
67039: LIST
67040: LIST
67041: PUSH
67042: LD_INT 2
67044: NEG
67045: PUSH
67046: LD_INT 1
67048: NEG
67049: PUSH
67050: EMPTY
67051: LIST
67052: LIST
67053: PUSH
67054: LD_INT 2
67056: NEG
67057: PUSH
67058: LD_INT 2
67060: NEG
67061: PUSH
67062: EMPTY
67063: LIST
67064: LIST
67065: PUSH
67066: LD_INT 3
67068: PUSH
67069: LD_INT 1
67071: PUSH
67072: EMPTY
67073: LIST
67074: LIST
67075: PUSH
67076: LD_INT 3
67078: PUSH
67079: LD_INT 2
67081: PUSH
67082: EMPTY
67083: LIST
67084: LIST
67085: PUSH
67086: LD_INT 2
67088: PUSH
67089: LD_INT 3
67091: PUSH
67092: EMPTY
67093: LIST
67094: LIST
67095: PUSH
67096: LD_INT 1
67098: PUSH
67099: LD_INT 3
67101: PUSH
67102: EMPTY
67103: LIST
67104: LIST
67105: PUSH
67106: EMPTY
67107: LIST
67108: LIST
67109: LIST
67110: LIST
67111: LIST
67112: LIST
67113: LIST
67114: LIST
67115: LIST
67116: LIST
67117: LIST
67118: LIST
67119: LIST
67120: LIST
67121: LIST
67122: LIST
67123: LIST
67124: LIST
67125: LIST
67126: LIST
67127: LIST
67128: LIST
67129: LIST
67130: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
67131: LD_ADDR_VAR 0 26
67135: PUSH
67136: LD_INT 0
67138: PUSH
67139: LD_INT 0
67141: PUSH
67142: EMPTY
67143: LIST
67144: LIST
67145: PUSH
67146: LD_INT 0
67148: PUSH
67149: LD_INT 1
67151: NEG
67152: PUSH
67153: EMPTY
67154: LIST
67155: LIST
67156: PUSH
67157: LD_INT 1
67159: PUSH
67160: LD_INT 0
67162: PUSH
67163: EMPTY
67164: LIST
67165: LIST
67166: PUSH
67167: LD_INT 1
67169: PUSH
67170: LD_INT 1
67172: PUSH
67173: EMPTY
67174: LIST
67175: LIST
67176: PUSH
67177: LD_INT 0
67179: PUSH
67180: LD_INT 1
67182: PUSH
67183: EMPTY
67184: LIST
67185: LIST
67186: PUSH
67187: LD_INT 1
67189: NEG
67190: PUSH
67191: LD_INT 0
67193: PUSH
67194: EMPTY
67195: LIST
67196: LIST
67197: PUSH
67198: LD_INT 1
67200: NEG
67201: PUSH
67202: LD_INT 1
67204: NEG
67205: PUSH
67206: EMPTY
67207: LIST
67208: LIST
67209: PUSH
67210: LD_INT 1
67212: NEG
67213: PUSH
67214: LD_INT 2
67216: NEG
67217: PUSH
67218: EMPTY
67219: LIST
67220: LIST
67221: PUSH
67222: LD_INT 0
67224: PUSH
67225: LD_INT 2
67227: NEG
67228: PUSH
67229: EMPTY
67230: LIST
67231: LIST
67232: PUSH
67233: LD_INT 1
67235: PUSH
67236: LD_INT 1
67238: NEG
67239: PUSH
67240: EMPTY
67241: LIST
67242: LIST
67243: PUSH
67244: LD_INT 2
67246: PUSH
67247: LD_INT 0
67249: PUSH
67250: EMPTY
67251: LIST
67252: LIST
67253: PUSH
67254: LD_INT 2
67256: PUSH
67257: LD_INT 1
67259: PUSH
67260: EMPTY
67261: LIST
67262: LIST
67263: PUSH
67264: LD_INT 2
67266: PUSH
67267: LD_INT 2
67269: PUSH
67270: EMPTY
67271: LIST
67272: LIST
67273: PUSH
67274: LD_INT 1
67276: PUSH
67277: LD_INT 2
67279: PUSH
67280: EMPTY
67281: LIST
67282: LIST
67283: PUSH
67284: LD_INT 0
67286: PUSH
67287: LD_INT 2
67289: PUSH
67290: EMPTY
67291: LIST
67292: LIST
67293: PUSH
67294: LD_INT 1
67296: NEG
67297: PUSH
67298: LD_INT 1
67300: PUSH
67301: EMPTY
67302: LIST
67303: LIST
67304: PUSH
67305: LD_INT 2
67307: NEG
67308: PUSH
67309: LD_INT 0
67311: PUSH
67312: EMPTY
67313: LIST
67314: LIST
67315: PUSH
67316: LD_INT 2
67318: NEG
67319: PUSH
67320: LD_INT 1
67322: NEG
67323: PUSH
67324: EMPTY
67325: LIST
67326: LIST
67327: PUSH
67328: LD_INT 2
67330: NEG
67331: PUSH
67332: LD_INT 2
67334: NEG
67335: PUSH
67336: EMPTY
67337: LIST
67338: LIST
67339: PUSH
67340: LD_INT 2
67342: PUSH
67343: LD_INT 3
67345: PUSH
67346: EMPTY
67347: LIST
67348: LIST
67349: PUSH
67350: LD_INT 1
67352: PUSH
67353: LD_INT 3
67355: PUSH
67356: EMPTY
67357: LIST
67358: LIST
67359: PUSH
67360: LD_INT 1
67362: NEG
67363: PUSH
67364: LD_INT 2
67366: PUSH
67367: EMPTY
67368: LIST
67369: LIST
67370: PUSH
67371: LD_INT 2
67373: NEG
67374: PUSH
67375: LD_INT 1
67377: PUSH
67378: EMPTY
67379: LIST
67380: LIST
67381: PUSH
67382: EMPTY
67383: LIST
67384: LIST
67385: LIST
67386: LIST
67387: LIST
67388: LIST
67389: LIST
67390: LIST
67391: LIST
67392: LIST
67393: LIST
67394: LIST
67395: LIST
67396: LIST
67397: LIST
67398: LIST
67399: LIST
67400: LIST
67401: LIST
67402: LIST
67403: LIST
67404: LIST
67405: LIST
67406: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
67407: LD_ADDR_VAR 0 27
67411: PUSH
67412: LD_INT 0
67414: PUSH
67415: LD_INT 0
67417: PUSH
67418: EMPTY
67419: LIST
67420: LIST
67421: PUSH
67422: LD_INT 0
67424: PUSH
67425: LD_INT 1
67427: NEG
67428: PUSH
67429: EMPTY
67430: LIST
67431: LIST
67432: PUSH
67433: LD_INT 1
67435: PUSH
67436: LD_INT 0
67438: PUSH
67439: EMPTY
67440: LIST
67441: LIST
67442: PUSH
67443: LD_INT 1
67445: PUSH
67446: LD_INT 1
67448: PUSH
67449: EMPTY
67450: LIST
67451: LIST
67452: PUSH
67453: LD_INT 0
67455: PUSH
67456: LD_INT 1
67458: PUSH
67459: EMPTY
67460: LIST
67461: LIST
67462: PUSH
67463: LD_INT 1
67465: NEG
67466: PUSH
67467: LD_INT 0
67469: PUSH
67470: EMPTY
67471: LIST
67472: LIST
67473: PUSH
67474: LD_INT 1
67476: NEG
67477: PUSH
67478: LD_INT 1
67480: NEG
67481: PUSH
67482: EMPTY
67483: LIST
67484: LIST
67485: PUSH
67486: LD_INT 1
67488: NEG
67489: PUSH
67490: LD_INT 2
67492: NEG
67493: PUSH
67494: EMPTY
67495: LIST
67496: LIST
67497: PUSH
67498: LD_INT 0
67500: PUSH
67501: LD_INT 2
67503: NEG
67504: PUSH
67505: EMPTY
67506: LIST
67507: LIST
67508: PUSH
67509: LD_INT 1
67511: PUSH
67512: LD_INT 1
67514: NEG
67515: PUSH
67516: EMPTY
67517: LIST
67518: LIST
67519: PUSH
67520: LD_INT 2
67522: PUSH
67523: LD_INT 0
67525: PUSH
67526: EMPTY
67527: LIST
67528: LIST
67529: PUSH
67530: LD_INT 2
67532: PUSH
67533: LD_INT 1
67535: PUSH
67536: EMPTY
67537: LIST
67538: LIST
67539: PUSH
67540: LD_INT 2
67542: PUSH
67543: LD_INT 2
67545: PUSH
67546: EMPTY
67547: LIST
67548: LIST
67549: PUSH
67550: LD_INT 1
67552: PUSH
67553: LD_INT 2
67555: PUSH
67556: EMPTY
67557: LIST
67558: LIST
67559: PUSH
67560: LD_INT 0
67562: PUSH
67563: LD_INT 2
67565: PUSH
67566: EMPTY
67567: LIST
67568: LIST
67569: PUSH
67570: LD_INT 1
67572: NEG
67573: PUSH
67574: LD_INT 1
67576: PUSH
67577: EMPTY
67578: LIST
67579: LIST
67580: PUSH
67581: LD_INT 2
67583: NEG
67584: PUSH
67585: LD_INT 0
67587: PUSH
67588: EMPTY
67589: LIST
67590: LIST
67591: PUSH
67592: LD_INT 2
67594: NEG
67595: PUSH
67596: LD_INT 1
67598: NEG
67599: PUSH
67600: EMPTY
67601: LIST
67602: LIST
67603: PUSH
67604: LD_INT 2
67606: NEG
67607: PUSH
67608: LD_INT 2
67610: NEG
67611: PUSH
67612: EMPTY
67613: LIST
67614: LIST
67615: PUSH
67616: LD_INT 1
67618: NEG
67619: PUSH
67620: LD_INT 2
67622: PUSH
67623: EMPTY
67624: LIST
67625: LIST
67626: PUSH
67627: LD_INT 2
67629: NEG
67630: PUSH
67631: LD_INT 1
67633: PUSH
67634: EMPTY
67635: LIST
67636: LIST
67637: PUSH
67638: LD_INT 3
67640: NEG
67641: PUSH
67642: LD_INT 1
67644: NEG
67645: PUSH
67646: EMPTY
67647: LIST
67648: LIST
67649: PUSH
67650: LD_INT 3
67652: NEG
67653: PUSH
67654: LD_INT 2
67656: NEG
67657: PUSH
67658: EMPTY
67659: LIST
67660: LIST
67661: PUSH
67662: EMPTY
67663: LIST
67664: LIST
67665: LIST
67666: LIST
67667: LIST
67668: LIST
67669: LIST
67670: LIST
67671: LIST
67672: LIST
67673: LIST
67674: LIST
67675: LIST
67676: LIST
67677: LIST
67678: LIST
67679: LIST
67680: LIST
67681: LIST
67682: LIST
67683: LIST
67684: LIST
67685: LIST
67686: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
67687: LD_ADDR_VAR 0 28
67691: PUSH
67692: LD_INT 0
67694: PUSH
67695: LD_INT 0
67697: PUSH
67698: EMPTY
67699: LIST
67700: LIST
67701: PUSH
67702: LD_INT 0
67704: PUSH
67705: LD_INT 1
67707: NEG
67708: PUSH
67709: EMPTY
67710: LIST
67711: LIST
67712: PUSH
67713: LD_INT 1
67715: PUSH
67716: LD_INT 0
67718: PUSH
67719: EMPTY
67720: LIST
67721: LIST
67722: PUSH
67723: LD_INT 1
67725: PUSH
67726: LD_INT 1
67728: PUSH
67729: EMPTY
67730: LIST
67731: LIST
67732: PUSH
67733: LD_INT 0
67735: PUSH
67736: LD_INT 1
67738: PUSH
67739: EMPTY
67740: LIST
67741: LIST
67742: PUSH
67743: LD_INT 1
67745: NEG
67746: PUSH
67747: LD_INT 0
67749: PUSH
67750: EMPTY
67751: LIST
67752: LIST
67753: PUSH
67754: LD_INT 1
67756: NEG
67757: PUSH
67758: LD_INT 1
67760: NEG
67761: PUSH
67762: EMPTY
67763: LIST
67764: LIST
67765: PUSH
67766: LD_INT 1
67768: NEG
67769: PUSH
67770: LD_INT 2
67772: NEG
67773: PUSH
67774: EMPTY
67775: LIST
67776: LIST
67777: PUSH
67778: LD_INT 0
67780: PUSH
67781: LD_INT 2
67783: NEG
67784: PUSH
67785: EMPTY
67786: LIST
67787: LIST
67788: PUSH
67789: LD_INT 1
67791: PUSH
67792: LD_INT 1
67794: NEG
67795: PUSH
67796: EMPTY
67797: LIST
67798: LIST
67799: PUSH
67800: LD_INT 2
67802: PUSH
67803: LD_INT 0
67805: PUSH
67806: EMPTY
67807: LIST
67808: LIST
67809: PUSH
67810: LD_INT 2
67812: PUSH
67813: LD_INT 1
67815: PUSH
67816: EMPTY
67817: LIST
67818: LIST
67819: PUSH
67820: LD_INT 2
67822: PUSH
67823: LD_INT 2
67825: PUSH
67826: EMPTY
67827: LIST
67828: LIST
67829: PUSH
67830: LD_INT 1
67832: PUSH
67833: LD_INT 2
67835: PUSH
67836: EMPTY
67837: LIST
67838: LIST
67839: PUSH
67840: LD_INT 0
67842: PUSH
67843: LD_INT 2
67845: PUSH
67846: EMPTY
67847: LIST
67848: LIST
67849: PUSH
67850: LD_INT 1
67852: NEG
67853: PUSH
67854: LD_INT 1
67856: PUSH
67857: EMPTY
67858: LIST
67859: LIST
67860: PUSH
67861: LD_INT 2
67863: NEG
67864: PUSH
67865: LD_INT 0
67867: PUSH
67868: EMPTY
67869: LIST
67870: LIST
67871: PUSH
67872: LD_INT 2
67874: NEG
67875: PUSH
67876: LD_INT 1
67878: NEG
67879: PUSH
67880: EMPTY
67881: LIST
67882: LIST
67883: PUSH
67884: LD_INT 2
67886: NEG
67887: PUSH
67888: LD_INT 2
67890: NEG
67891: PUSH
67892: EMPTY
67893: LIST
67894: LIST
67895: PUSH
67896: LD_INT 2
67898: NEG
67899: PUSH
67900: LD_INT 3
67902: NEG
67903: PUSH
67904: EMPTY
67905: LIST
67906: LIST
67907: PUSH
67908: LD_INT 1
67910: NEG
67911: PUSH
67912: LD_INT 3
67914: NEG
67915: PUSH
67916: EMPTY
67917: LIST
67918: LIST
67919: PUSH
67920: LD_INT 3
67922: NEG
67923: PUSH
67924: LD_INT 1
67926: NEG
67927: PUSH
67928: EMPTY
67929: LIST
67930: LIST
67931: PUSH
67932: LD_INT 3
67934: NEG
67935: PUSH
67936: LD_INT 2
67938: NEG
67939: PUSH
67940: EMPTY
67941: LIST
67942: LIST
67943: PUSH
67944: EMPTY
67945: LIST
67946: LIST
67947: LIST
67948: LIST
67949: LIST
67950: LIST
67951: LIST
67952: LIST
67953: LIST
67954: LIST
67955: LIST
67956: LIST
67957: LIST
67958: LIST
67959: LIST
67960: LIST
67961: LIST
67962: LIST
67963: LIST
67964: LIST
67965: LIST
67966: LIST
67967: LIST
67968: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
67969: LD_ADDR_VAR 0 29
67973: PUSH
67974: LD_INT 0
67976: PUSH
67977: LD_INT 0
67979: PUSH
67980: EMPTY
67981: LIST
67982: LIST
67983: PUSH
67984: LD_INT 0
67986: PUSH
67987: LD_INT 1
67989: NEG
67990: PUSH
67991: EMPTY
67992: LIST
67993: LIST
67994: PUSH
67995: LD_INT 1
67997: PUSH
67998: LD_INT 0
68000: PUSH
68001: EMPTY
68002: LIST
68003: LIST
68004: PUSH
68005: LD_INT 1
68007: PUSH
68008: LD_INT 1
68010: PUSH
68011: EMPTY
68012: LIST
68013: LIST
68014: PUSH
68015: LD_INT 0
68017: PUSH
68018: LD_INT 1
68020: PUSH
68021: EMPTY
68022: LIST
68023: LIST
68024: PUSH
68025: LD_INT 1
68027: NEG
68028: PUSH
68029: LD_INT 0
68031: PUSH
68032: EMPTY
68033: LIST
68034: LIST
68035: PUSH
68036: LD_INT 1
68038: NEG
68039: PUSH
68040: LD_INT 1
68042: NEG
68043: PUSH
68044: EMPTY
68045: LIST
68046: LIST
68047: PUSH
68048: LD_INT 1
68050: NEG
68051: PUSH
68052: LD_INT 2
68054: NEG
68055: PUSH
68056: EMPTY
68057: LIST
68058: LIST
68059: PUSH
68060: LD_INT 0
68062: PUSH
68063: LD_INT 2
68065: NEG
68066: PUSH
68067: EMPTY
68068: LIST
68069: LIST
68070: PUSH
68071: LD_INT 1
68073: PUSH
68074: LD_INT 1
68076: NEG
68077: PUSH
68078: EMPTY
68079: LIST
68080: LIST
68081: PUSH
68082: LD_INT 2
68084: PUSH
68085: LD_INT 0
68087: PUSH
68088: EMPTY
68089: LIST
68090: LIST
68091: PUSH
68092: LD_INT 2
68094: PUSH
68095: LD_INT 1
68097: PUSH
68098: EMPTY
68099: LIST
68100: LIST
68101: PUSH
68102: LD_INT 1
68104: PUSH
68105: LD_INT 2
68107: PUSH
68108: EMPTY
68109: LIST
68110: LIST
68111: PUSH
68112: LD_INT 0
68114: PUSH
68115: LD_INT 2
68117: PUSH
68118: EMPTY
68119: LIST
68120: LIST
68121: PUSH
68122: LD_INT 1
68124: NEG
68125: PUSH
68126: LD_INT 1
68128: PUSH
68129: EMPTY
68130: LIST
68131: LIST
68132: PUSH
68133: LD_INT 2
68135: NEG
68136: PUSH
68137: LD_INT 1
68139: NEG
68140: PUSH
68141: EMPTY
68142: LIST
68143: LIST
68144: PUSH
68145: LD_INT 2
68147: NEG
68148: PUSH
68149: LD_INT 2
68151: NEG
68152: PUSH
68153: EMPTY
68154: LIST
68155: LIST
68156: PUSH
68157: LD_INT 2
68159: NEG
68160: PUSH
68161: LD_INT 3
68163: NEG
68164: PUSH
68165: EMPTY
68166: LIST
68167: LIST
68168: PUSH
68169: LD_INT 2
68171: PUSH
68172: LD_INT 1
68174: NEG
68175: PUSH
68176: EMPTY
68177: LIST
68178: LIST
68179: PUSH
68180: LD_INT 3
68182: PUSH
68183: LD_INT 1
68185: PUSH
68186: EMPTY
68187: LIST
68188: LIST
68189: PUSH
68190: LD_INT 1
68192: PUSH
68193: LD_INT 3
68195: PUSH
68196: EMPTY
68197: LIST
68198: LIST
68199: PUSH
68200: LD_INT 1
68202: NEG
68203: PUSH
68204: LD_INT 2
68206: PUSH
68207: EMPTY
68208: LIST
68209: LIST
68210: PUSH
68211: LD_INT 3
68213: NEG
68214: PUSH
68215: LD_INT 2
68217: NEG
68218: PUSH
68219: EMPTY
68220: LIST
68221: LIST
68222: PUSH
68223: EMPTY
68224: LIST
68225: LIST
68226: LIST
68227: LIST
68228: LIST
68229: LIST
68230: LIST
68231: LIST
68232: LIST
68233: LIST
68234: LIST
68235: LIST
68236: LIST
68237: LIST
68238: LIST
68239: LIST
68240: LIST
68241: LIST
68242: LIST
68243: LIST
68244: LIST
68245: LIST
68246: LIST
68247: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
68248: LD_ADDR_VAR 0 30
68252: PUSH
68253: LD_INT 0
68255: PUSH
68256: LD_INT 0
68258: PUSH
68259: EMPTY
68260: LIST
68261: LIST
68262: PUSH
68263: LD_INT 0
68265: PUSH
68266: LD_INT 1
68268: NEG
68269: PUSH
68270: EMPTY
68271: LIST
68272: LIST
68273: PUSH
68274: LD_INT 1
68276: PUSH
68277: LD_INT 0
68279: PUSH
68280: EMPTY
68281: LIST
68282: LIST
68283: PUSH
68284: LD_INT 1
68286: PUSH
68287: LD_INT 1
68289: PUSH
68290: EMPTY
68291: LIST
68292: LIST
68293: PUSH
68294: LD_INT 0
68296: PUSH
68297: LD_INT 1
68299: PUSH
68300: EMPTY
68301: LIST
68302: LIST
68303: PUSH
68304: LD_INT 1
68306: NEG
68307: PUSH
68308: LD_INT 0
68310: PUSH
68311: EMPTY
68312: LIST
68313: LIST
68314: PUSH
68315: LD_INT 1
68317: NEG
68318: PUSH
68319: LD_INT 1
68321: NEG
68322: PUSH
68323: EMPTY
68324: LIST
68325: LIST
68326: PUSH
68327: LD_INT 1
68329: NEG
68330: PUSH
68331: LD_INT 2
68333: NEG
68334: PUSH
68335: EMPTY
68336: LIST
68337: LIST
68338: PUSH
68339: LD_INT 0
68341: PUSH
68342: LD_INT 2
68344: NEG
68345: PUSH
68346: EMPTY
68347: LIST
68348: LIST
68349: PUSH
68350: LD_INT 1
68352: PUSH
68353: LD_INT 1
68355: NEG
68356: PUSH
68357: EMPTY
68358: LIST
68359: LIST
68360: PUSH
68361: LD_INT 2
68363: PUSH
68364: LD_INT 0
68366: PUSH
68367: EMPTY
68368: LIST
68369: LIST
68370: PUSH
68371: LD_INT 2
68373: PUSH
68374: LD_INT 1
68376: PUSH
68377: EMPTY
68378: LIST
68379: LIST
68380: PUSH
68381: LD_INT 2
68383: PUSH
68384: LD_INT 2
68386: PUSH
68387: EMPTY
68388: LIST
68389: LIST
68390: PUSH
68391: LD_INT 1
68393: PUSH
68394: LD_INT 2
68396: PUSH
68397: EMPTY
68398: LIST
68399: LIST
68400: PUSH
68401: LD_INT 1
68403: NEG
68404: PUSH
68405: LD_INT 1
68407: PUSH
68408: EMPTY
68409: LIST
68410: LIST
68411: PUSH
68412: LD_INT 2
68414: NEG
68415: PUSH
68416: LD_INT 0
68418: PUSH
68419: EMPTY
68420: LIST
68421: LIST
68422: PUSH
68423: LD_INT 2
68425: NEG
68426: PUSH
68427: LD_INT 1
68429: NEG
68430: PUSH
68431: EMPTY
68432: LIST
68433: LIST
68434: PUSH
68435: LD_INT 1
68437: NEG
68438: PUSH
68439: LD_INT 3
68441: NEG
68442: PUSH
68443: EMPTY
68444: LIST
68445: LIST
68446: PUSH
68447: LD_INT 1
68449: PUSH
68450: LD_INT 2
68452: NEG
68453: PUSH
68454: EMPTY
68455: LIST
68456: LIST
68457: PUSH
68458: LD_INT 3
68460: PUSH
68461: LD_INT 2
68463: PUSH
68464: EMPTY
68465: LIST
68466: LIST
68467: PUSH
68468: LD_INT 2
68470: PUSH
68471: LD_INT 3
68473: PUSH
68474: EMPTY
68475: LIST
68476: LIST
68477: PUSH
68478: LD_INT 2
68480: NEG
68481: PUSH
68482: LD_INT 1
68484: PUSH
68485: EMPTY
68486: LIST
68487: LIST
68488: PUSH
68489: LD_INT 3
68491: NEG
68492: PUSH
68493: LD_INT 1
68495: NEG
68496: PUSH
68497: EMPTY
68498: LIST
68499: LIST
68500: PUSH
68501: EMPTY
68502: LIST
68503: LIST
68504: LIST
68505: LIST
68506: LIST
68507: LIST
68508: LIST
68509: LIST
68510: LIST
68511: LIST
68512: LIST
68513: LIST
68514: LIST
68515: LIST
68516: LIST
68517: LIST
68518: LIST
68519: LIST
68520: LIST
68521: LIST
68522: LIST
68523: LIST
68524: LIST
68525: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
68526: LD_ADDR_VAR 0 31
68530: PUSH
68531: LD_INT 0
68533: PUSH
68534: LD_INT 0
68536: PUSH
68537: EMPTY
68538: LIST
68539: LIST
68540: PUSH
68541: LD_INT 0
68543: PUSH
68544: LD_INT 1
68546: NEG
68547: PUSH
68548: EMPTY
68549: LIST
68550: LIST
68551: PUSH
68552: LD_INT 1
68554: PUSH
68555: LD_INT 0
68557: PUSH
68558: EMPTY
68559: LIST
68560: LIST
68561: PUSH
68562: LD_INT 1
68564: PUSH
68565: LD_INT 1
68567: PUSH
68568: EMPTY
68569: LIST
68570: LIST
68571: PUSH
68572: LD_INT 0
68574: PUSH
68575: LD_INT 1
68577: PUSH
68578: EMPTY
68579: LIST
68580: LIST
68581: PUSH
68582: LD_INT 1
68584: NEG
68585: PUSH
68586: LD_INT 0
68588: PUSH
68589: EMPTY
68590: LIST
68591: LIST
68592: PUSH
68593: LD_INT 1
68595: NEG
68596: PUSH
68597: LD_INT 1
68599: NEG
68600: PUSH
68601: EMPTY
68602: LIST
68603: LIST
68604: PUSH
68605: LD_INT 1
68607: NEG
68608: PUSH
68609: LD_INT 2
68611: NEG
68612: PUSH
68613: EMPTY
68614: LIST
68615: LIST
68616: PUSH
68617: LD_INT 1
68619: PUSH
68620: LD_INT 1
68622: NEG
68623: PUSH
68624: EMPTY
68625: LIST
68626: LIST
68627: PUSH
68628: LD_INT 2
68630: PUSH
68631: LD_INT 0
68633: PUSH
68634: EMPTY
68635: LIST
68636: LIST
68637: PUSH
68638: LD_INT 2
68640: PUSH
68641: LD_INT 1
68643: PUSH
68644: EMPTY
68645: LIST
68646: LIST
68647: PUSH
68648: LD_INT 2
68650: PUSH
68651: LD_INT 2
68653: PUSH
68654: EMPTY
68655: LIST
68656: LIST
68657: PUSH
68658: LD_INT 1
68660: PUSH
68661: LD_INT 2
68663: PUSH
68664: EMPTY
68665: LIST
68666: LIST
68667: PUSH
68668: LD_INT 0
68670: PUSH
68671: LD_INT 2
68673: PUSH
68674: EMPTY
68675: LIST
68676: LIST
68677: PUSH
68678: LD_INT 1
68680: NEG
68681: PUSH
68682: LD_INT 1
68684: PUSH
68685: EMPTY
68686: LIST
68687: LIST
68688: PUSH
68689: LD_INT 2
68691: NEG
68692: PUSH
68693: LD_INT 1
68695: NEG
68696: PUSH
68697: EMPTY
68698: LIST
68699: LIST
68700: PUSH
68701: LD_INT 2
68703: NEG
68704: PUSH
68705: LD_INT 2
68707: NEG
68708: PUSH
68709: EMPTY
68710: LIST
68711: LIST
68712: PUSH
68713: LD_INT 2
68715: NEG
68716: PUSH
68717: LD_INT 3
68719: NEG
68720: PUSH
68721: EMPTY
68722: LIST
68723: LIST
68724: PUSH
68725: LD_INT 2
68727: PUSH
68728: LD_INT 1
68730: NEG
68731: PUSH
68732: EMPTY
68733: LIST
68734: LIST
68735: PUSH
68736: LD_INT 3
68738: PUSH
68739: LD_INT 1
68741: PUSH
68742: EMPTY
68743: LIST
68744: LIST
68745: PUSH
68746: LD_INT 1
68748: PUSH
68749: LD_INT 3
68751: PUSH
68752: EMPTY
68753: LIST
68754: LIST
68755: PUSH
68756: LD_INT 1
68758: NEG
68759: PUSH
68760: LD_INT 2
68762: PUSH
68763: EMPTY
68764: LIST
68765: LIST
68766: PUSH
68767: LD_INT 3
68769: NEG
68770: PUSH
68771: LD_INT 2
68773: NEG
68774: PUSH
68775: EMPTY
68776: LIST
68777: LIST
68778: PUSH
68779: EMPTY
68780: LIST
68781: LIST
68782: LIST
68783: LIST
68784: LIST
68785: LIST
68786: LIST
68787: LIST
68788: LIST
68789: LIST
68790: LIST
68791: LIST
68792: LIST
68793: LIST
68794: LIST
68795: LIST
68796: LIST
68797: LIST
68798: LIST
68799: LIST
68800: LIST
68801: LIST
68802: LIST
68803: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
68804: LD_ADDR_VAR 0 32
68808: PUSH
68809: LD_INT 0
68811: PUSH
68812: LD_INT 0
68814: PUSH
68815: EMPTY
68816: LIST
68817: LIST
68818: PUSH
68819: LD_INT 0
68821: PUSH
68822: LD_INT 1
68824: NEG
68825: PUSH
68826: EMPTY
68827: LIST
68828: LIST
68829: PUSH
68830: LD_INT 1
68832: PUSH
68833: LD_INT 0
68835: PUSH
68836: EMPTY
68837: LIST
68838: LIST
68839: PUSH
68840: LD_INT 1
68842: PUSH
68843: LD_INT 1
68845: PUSH
68846: EMPTY
68847: LIST
68848: LIST
68849: PUSH
68850: LD_INT 0
68852: PUSH
68853: LD_INT 1
68855: PUSH
68856: EMPTY
68857: LIST
68858: LIST
68859: PUSH
68860: LD_INT 1
68862: NEG
68863: PUSH
68864: LD_INT 0
68866: PUSH
68867: EMPTY
68868: LIST
68869: LIST
68870: PUSH
68871: LD_INT 1
68873: NEG
68874: PUSH
68875: LD_INT 1
68877: NEG
68878: PUSH
68879: EMPTY
68880: LIST
68881: LIST
68882: PUSH
68883: LD_INT 1
68885: NEG
68886: PUSH
68887: LD_INT 2
68889: NEG
68890: PUSH
68891: EMPTY
68892: LIST
68893: LIST
68894: PUSH
68895: LD_INT 0
68897: PUSH
68898: LD_INT 2
68900: NEG
68901: PUSH
68902: EMPTY
68903: LIST
68904: LIST
68905: PUSH
68906: LD_INT 1
68908: PUSH
68909: LD_INT 1
68911: NEG
68912: PUSH
68913: EMPTY
68914: LIST
68915: LIST
68916: PUSH
68917: LD_INT 2
68919: PUSH
68920: LD_INT 1
68922: PUSH
68923: EMPTY
68924: LIST
68925: LIST
68926: PUSH
68927: LD_INT 2
68929: PUSH
68930: LD_INT 2
68932: PUSH
68933: EMPTY
68934: LIST
68935: LIST
68936: PUSH
68937: LD_INT 1
68939: PUSH
68940: LD_INT 2
68942: PUSH
68943: EMPTY
68944: LIST
68945: LIST
68946: PUSH
68947: LD_INT 0
68949: PUSH
68950: LD_INT 2
68952: PUSH
68953: EMPTY
68954: LIST
68955: LIST
68956: PUSH
68957: LD_INT 1
68959: NEG
68960: PUSH
68961: LD_INT 1
68963: PUSH
68964: EMPTY
68965: LIST
68966: LIST
68967: PUSH
68968: LD_INT 2
68970: NEG
68971: PUSH
68972: LD_INT 0
68974: PUSH
68975: EMPTY
68976: LIST
68977: LIST
68978: PUSH
68979: LD_INT 2
68981: NEG
68982: PUSH
68983: LD_INT 1
68985: NEG
68986: PUSH
68987: EMPTY
68988: LIST
68989: LIST
68990: PUSH
68991: LD_INT 1
68993: NEG
68994: PUSH
68995: LD_INT 3
68997: NEG
68998: PUSH
68999: EMPTY
69000: LIST
69001: LIST
69002: PUSH
69003: LD_INT 1
69005: PUSH
69006: LD_INT 2
69008: NEG
69009: PUSH
69010: EMPTY
69011: LIST
69012: LIST
69013: PUSH
69014: LD_INT 3
69016: PUSH
69017: LD_INT 2
69019: PUSH
69020: EMPTY
69021: LIST
69022: LIST
69023: PUSH
69024: LD_INT 2
69026: PUSH
69027: LD_INT 3
69029: PUSH
69030: EMPTY
69031: LIST
69032: LIST
69033: PUSH
69034: LD_INT 2
69036: NEG
69037: PUSH
69038: LD_INT 1
69040: PUSH
69041: EMPTY
69042: LIST
69043: LIST
69044: PUSH
69045: LD_INT 3
69047: NEG
69048: PUSH
69049: LD_INT 1
69051: NEG
69052: PUSH
69053: EMPTY
69054: LIST
69055: LIST
69056: PUSH
69057: EMPTY
69058: LIST
69059: LIST
69060: LIST
69061: LIST
69062: LIST
69063: LIST
69064: LIST
69065: LIST
69066: LIST
69067: LIST
69068: LIST
69069: LIST
69070: LIST
69071: LIST
69072: LIST
69073: LIST
69074: LIST
69075: LIST
69076: LIST
69077: LIST
69078: LIST
69079: LIST
69080: LIST
69081: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
69082: LD_ADDR_VAR 0 33
69086: PUSH
69087: LD_INT 0
69089: PUSH
69090: LD_INT 0
69092: PUSH
69093: EMPTY
69094: LIST
69095: LIST
69096: PUSH
69097: LD_INT 0
69099: PUSH
69100: LD_INT 1
69102: NEG
69103: PUSH
69104: EMPTY
69105: LIST
69106: LIST
69107: PUSH
69108: LD_INT 1
69110: PUSH
69111: LD_INT 0
69113: PUSH
69114: EMPTY
69115: LIST
69116: LIST
69117: PUSH
69118: LD_INT 1
69120: PUSH
69121: LD_INT 1
69123: PUSH
69124: EMPTY
69125: LIST
69126: LIST
69127: PUSH
69128: LD_INT 0
69130: PUSH
69131: LD_INT 1
69133: PUSH
69134: EMPTY
69135: LIST
69136: LIST
69137: PUSH
69138: LD_INT 1
69140: NEG
69141: PUSH
69142: LD_INT 0
69144: PUSH
69145: EMPTY
69146: LIST
69147: LIST
69148: PUSH
69149: LD_INT 1
69151: NEG
69152: PUSH
69153: LD_INT 1
69155: NEG
69156: PUSH
69157: EMPTY
69158: LIST
69159: LIST
69160: PUSH
69161: LD_INT 1
69163: NEG
69164: PUSH
69165: LD_INT 2
69167: NEG
69168: PUSH
69169: EMPTY
69170: LIST
69171: LIST
69172: PUSH
69173: LD_INT 1
69175: PUSH
69176: LD_INT 1
69178: NEG
69179: PUSH
69180: EMPTY
69181: LIST
69182: LIST
69183: PUSH
69184: LD_INT 2
69186: PUSH
69187: LD_INT 0
69189: PUSH
69190: EMPTY
69191: LIST
69192: LIST
69193: PUSH
69194: LD_INT 2
69196: PUSH
69197: LD_INT 1
69199: PUSH
69200: EMPTY
69201: LIST
69202: LIST
69203: PUSH
69204: LD_INT 1
69206: PUSH
69207: LD_INT 2
69209: PUSH
69210: EMPTY
69211: LIST
69212: LIST
69213: PUSH
69214: LD_INT 0
69216: PUSH
69217: LD_INT 2
69219: PUSH
69220: EMPTY
69221: LIST
69222: LIST
69223: PUSH
69224: LD_INT 1
69226: NEG
69227: PUSH
69228: LD_INT 1
69230: PUSH
69231: EMPTY
69232: LIST
69233: LIST
69234: PUSH
69235: LD_INT 2
69237: NEG
69238: PUSH
69239: LD_INT 0
69241: PUSH
69242: EMPTY
69243: LIST
69244: LIST
69245: PUSH
69246: LD_INT 2
69248: NEG
69249: PUSH
69250: LD_INT 1
69252: NEG
69253: PUSH
69254: EMPTY
69255: LIST
69256: LIST
69257: PUSH
69258: LD_INT 2
69260: NEG
69261: PUSH
69262: LD_INT 2
69264: NEG
69265: PUSH
69266: EMPTY
69267: LIST
69268: LIST
69269: PUSH
69270: LD_INT 2
69272: NEG
69273: PUSH
69274: LD_INT 3
69276: NEG
69277: PUSH
69278: EMPTY
69279: LIST
69280: LIST
69281: PUSH
69282: LD_INT 2
69284: PUSH
69285: LD_INT 1
69287: NEG
69288: PUSH
69289: EMPTY
69290: LIST
69291: LIST
69292: PUSH
69293: LD_INT 3
69295: PUSH
69296: LD_INT 1
69298: PUSH
69299: EMPTY
69300: LIST
69301: LIST
69302: PUSH
69303: LD_INT 1
69305: PUSH
69306: LD_INT 3
69308: PUSH
69309: EMPTY
69310: LIST
69311: LIST
69312: PUSH
69313: LD_INT 1
69315: NEG
69316: PUSH
69317: LD_INT 2
69319: PUSH
69320: EMPTY
69321: LIST
69322: LIST
69323: PUSH
69324: LD_INT 3
69326: NEG
69327: PUSH
69328: LD_INT 2
69330: NEG
69331: PUSH
69332: EMPTY
69333: LIST
69334: LIST
69335: PUSH
69336: EMPTY
69337: LIST
69338: LIST
69339: LIST
69340: LIST
69341: LIST
69342: LIST
69343: LIST
69344: LIST
69345: LIST
69346: LIST
69347: LIST
69348: LIST
69349: LIST
69350: LIST
69351: LIST
69352: LIST
69353: LIST
69354: LIST
69355: LIST
69356: LIST
69357: LIST
69358: LIST
69359: LIST
69360: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
69361: LD_ADDR_VAR 0 34
69365: PUSH
69366: LD_INT 0
69368: PUSH
69369: LD_INT 0
69371: PUSH
69372: EMPTY
69373: LIST
69374: LIST
69375: PUSH
69376: LD_INT 0
69378: PUSH
69379: LD_INT 1
69381: NEG
69382: PUSH
69383: EMPTY
69384: LIST
69385: LIST
69386: PUSH
69387: LD_INT 1
69389: PUSH
69390: LD_INT 0
69392: PUSH
69393: EMPTY
69394: LIST
69395: LIST
69396: PUSH
69397: LD_INT 1
69399: PUSH
69400: LD_INT 1
69402: PUSH
69403: EMPTY
69404: LIST
69405: LIST
69406: PUSH
69407: LD_INT 0
69409: PUSH
69410: LD_INT 1
69412: PUSH
69413: EMPTY
69414: LIST
69415: LIST
69416: PUSH
69417: LD_INT 1
69419: NEG
69420: PUSH
69421: LD_INT 0
69423: PUSH
69424: EMPTY
69425: LIST
69426: LIST
69427: PUSH
69428: LD_INT 1
69430: NEG
69431: PUSH
69432: LD_INT 1
69434: NEG
69435: PUSH
69436: EMPTY
69437: LIST
69438: LIST
69439: PUSH
69440: LD_INT 1
69442: NEG
69443: PUSH
69444: LD_INT 2
69446: NEG
69447: PUSH
69448: EMPTY
69449: LIST
69450: LIST
69451: PUSH
69452: LD_INT 0
69454: PUSH
69455: LD_INT 2
69457: NEG
69458: PUSH
69459: EMPTY
69460: LIST
69461: LIST
69462: PUSH
69463: LD_INT 1
69465: PUSH
69466: LD_INT 1
69468: NEG
69469: PUSH
69470: EMPTY
69471: LIST
69472: LIST
69473: PUSH
69474: LD_INT 2
69476: PUSH
69477: LD_INT 1
69479: PUSH
69480: EMPTY
69481: LIST
69482: LIST
69483: PUSH
69484: LD_INT 2
69486: PUSH
69487: LD_INT 2
69489: PUSH
69490: EMPTY
69491: LIST
69492: LIST
69493: PUSH
69494: LD_INT 1
69496: PUSH
69497: LD_INT 2
69499: PUSH
69500: EMPTY
69501: LIST
69502: LIST
69503: PUSH
69504: LD_INT 1
69506: NEG
69507: PUSH
69508: LD_INT 1
69510: PUSH
69511: EMPTY
69512: LIST
69513: LIST
69514: PUSH
69515: LD_INT 2
69517: NEG
69518: PUSH
69519: LD_INT 0
69521: PUSH
69522: EMPTY
69523: LIST
69524: LIST
69525: PUSH
69526: LD_INT 2
69528: NEG
69529: PUSH
69530: LD_INT 1
69532: NEG
69533: PUSH
69534: EMPTY
69535: LIST
69536: LIST
69537: PUSH
69538: LD_INT 2
69540: NEG
69541: PUSH
69542: LD_INT 2
69544: NEG
69545: PUSH
69546: EMPTY
69547: LIST
69548: LIST
69549: PUSH
69550: LD_INT 1
69552: NEG
69553: PUSH
69554: LD_INT 3
69556: NEG
69557: PUSH
69558: EMPTY
69559: LIST
69560: LIST
69561: PUSH
69562: LD_INT 1
69564: PUSH
69565: LD_INT 2
69567: NEG
69568: PUSH
69569: EMPTY
69570: LIST
69571: LIST
69572: PUSH
69573: LD_INT 3
69575: PUSH
69576: LD_INT 2
69578: PUSH
69579: EMPTY
69580: LIST
69581: LIST
69582: PUSH
69583: LD_INT 2
69585: PUSH
69586: LD_INT 3
69588: PUSH
69589: EMPTY
69590: LIST
69591: LIST
69592: PUSH
69593: LD_INT 2
69595: NEG
69596: PUSH
69597: LD_INT 1
69599: PUSH
69600: EMPTY
69601: LIST
69602: LIST
69603: PUSH
69604: LD_INT 3
69606: NEG
69607: PUSH
69608: LD_INT 1
69610: NEG
69611: PUSH
69612: EMPTY
69613: LIST
69614: LIST
69615: PUSH
69616: EMPTY
69617: LIST
69618: LIST
69619: LIST
69620: LIST
69621: LIST
69622: LIST
69623: LIST
69624: LIST
69625: LIST
69626: LIST
69627: LIST
69628: LIST
69629: LIST
69630: LIST
69631: LIST
69632: LIST
69633: LIST
69634: LIST
69635: LIST
69636: LIST
69637: LIST
69638: LIST
69639: LIST
69640: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
69641: LD_ADDR_VAR 0 35
69645: PUSH
69646: LD_INT 0
69648: PUSH
69649: LD_INT 0
69651: PUSH
69652: EMPTY
69653: LIST
69654: LIST
69655: PUSH
69656: LD_INT 0
69658: PUSH
69659: LD_INT 1
69661: NEG
69662: PUSH
69663: EMPTY
69664: LIST
69665: LIST
69666: PUSH
69667: LD_INT 1
69669: PUSH
69670: LD_INT 0
69672: PUSH
69673: EMPTY
69674: LIST
69675: LIST
69676: PUSH
69677: LD_INT 1
69679: PUSH
69680: LD_INT 1
69682: PUSH
69683: EMPTY
69684: LIST
69685: LIST
69686: PUSH
69687: LD_INT 0
69689: PUSH
69690: LD_INT 1
69692: PUSH
69693: EMPTY
69694: LIST
69695: LIST
69696: PUSH
69697: LD_INT 1
69699: NEG
69700: PUSH
69701: LD_INT 0
69703: PUSH
69704: EMPTY
69705: LIST
69706: LIST
69707: PUSH
69708: LD_INT 1
69710: NEG
69711: PUSH
69712: LD_INT 1
69714: NEG
69715: PUSH
69716: EMPTY
69717: LIST
69718: LIST
69719: PUSH
69720: LD_INT 2
69722: PUSH
69723: LD_INT 1
69725: PUSH
69726: EMPTY
69727: LIST
69728: LIST
69729: PUSH
69730: LD_INT 2
69732: NEG
69733: PUSH
69734: LD_INT 1
69736: NEG
69737: PUSH
69738: EMPTY
69739: LIST
69740: LIST
69741: PUSH
69742: EMPTY
69743: LIST
69744: LIST
69745: LIST
69746: LIST
69747: LIST
69748: LIST
69749: LIST
69750: LIST
69751: LIST
69752: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
69753: LD_ADDR_VAR 0 36
69757: PUSH
69758: LD_INT 0
69760: PUSH
69761: LD_INT 0
69763: PUSH
69764: EMPTY
69765: LIST
69766: LIST
69767: PUSH
69768: LD_INT 0
69770: PUSH
69771: LD_INT 1
69773: NEG
69774: PUSH
69775: EMPTY
69776: LIST
69777: LIST
69778: PUSH
69779: LD_INT 1
69781: PUSH
69782: LD_INT 0
69784: PUSH
69785: EMPTY
69786: LIST
69787: LIST
69788: PUSH
69789: LD_INT 1
69791: PUSH
69792: LD_INT 1
69794: PUSH
69795: EMPTY
69796: LIST
69797: LIST
69798: PUSH
69799: LD_INT 0
69801: PUSH
69802: LD_INT 1
69804: PUSH
69805: EMPTY
69806: LIST
69807: LIST
69808: PUSH
69809: LD_INT 1
69811: NEG
69812: PUSH
69813: LD_INT 0
69815: PUSH
69816: EMPTY
69817: LIST
69818: LIST
69819: PUSH
69820: LD_INT 1
69822: NEG
69823: PUSH
69824: LD_INT 1
69826: NEG
69827: PUSH
69828: EMPTY
69829: LIST
69830: LIST
69831: PUSH
69832: LD_INT 1
69834: NEG
69835: PUSH
69836: LD_INT 2
69838: NEG
69839: PUSH
69840: EMPTY
69841: LIST
69842: LIST
69843: PUSH
69844: LD_INT 1
69846: PUSH
69847: LD_INT 2
69849: PUSH
69850: EMPTY
69851: LIST
69852: LIST
69853: PUSH
69854: EMPTY
69855: LIST
69856: LIST
69857: LIST
69858: LIST
69859: LIST
69860: LIST
69861: LIST
69862: LIST
69863: LIST
69864: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
69865: LD_ADDR_VAR 0 37
69869: PUSH
69870: LD_INT 0
69872: PUSH
69873: LD_INT 0
69875: PUSH
69876: EMPTY
69877: LIST
69878: LIST
69879: PUSH
69880: LD_INT 0
69882: PUSH
69883: LD_INT 1
69885: NEG
69886: PUSH
69887: EMPTY
69888: LIST
69889: LIST
69890: PUSH
69891: LD_INT 1
69893: PUSH
69894: LD_INT 0
69896: PUSH
69897: EMPTY
69898: LIST
69899: LIST
69900: PUSH
69901: LD_INT 1
69903: PUSH
69904: LD_INT 1
69906: PUSH
69907: EMPTY
69908: LIST
69909: LIST
69910: PUSH
69911: LD_INT 0
69913: PUSH
69914: LD_INT 1
69916: PUSH
69917: EMPTY
69918: LIST
69919: LIST
69920: PUSH
69921: LD_INT 1
69923: NEG
69924: PUSH
69925: LD_INT 0
69927: PUSH
69928: EMPTY
69929: LIST
69930: LIST
69931: PUSH
69932: LD_INT 1
69934: NEG
69935: PUSH
69936: LD_INT 1
69938: NEG
69939: PUSH
69940: EMPTY
69941: LIST
69942: LIST
69943: PUSH
69944: LD_INT 1
69946: PUSH
69947: LD_INT 1
69949: NEG
69950: PUSH
69951: EMPTY
69952: LIST
69953: LIST
69954: PUSH
69955: LD_INT 1
69957: NEG
69958: PUSH
69959: LD_INT 1
69961: PUSH
69962: EMPTY
69963: LIST
69964: LIST
69965: PUSH
69966: EMPTY
69967: LIST
69968: LIST
69969: LIST
69970: LIST
69971: LIST
69972: LIST
69973: LIST
69974: LIST
69975: LIST
69976: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
69977: LD_ADDR_VAR 0 38
69981: PUSH
69982: LD_INT 0
69984: PUSH
69985: LD_INT 0
69987: PUSH
69988: EMPTY
69989: LIST
69990: LIST
69991: PUSH
69992: LD_INT 0
69994: PUSH
69995: LD_INT 1
69997: NEG
69998: PUSH
69999: EMPTY
70000: LIST
70001: LIST
70002: PUSH
70003: LD_INT 1
70005: PUSH
70006: LD_INT 0
70008: PUSH
70009: EMPTY
70010: LIST
70011: LIST
70012: PUSH
70013: LD_INT 1
70015: PUSH
70016: LD_INT 1
70018: PUSH
70019: EMPTY
70020: LIST
70021: LIST
70022: PUSH
70023: LD_INT 0
70025: PUSH
70026: LD_INT 1
70028: PUSH
70029: EMPTY
70030: LIST
70031: LIST
70032: PUSH
70033: LD_INT 1
70035: NEG
70036: PUSH
70037: LD_INT 0
70039: PUSH
70040: EMPTY
70041: LIST
70042: LIST
70043: PUSH
70044: LD_INT 1
70046: NEG
70047: PUSH
70048: LD_INT 1
70050: NEG
70051: PUSH
70052: EMPTY
70053: LIST
70054: LIST
70055: PUSH
70056: LD_INT 2
70058: PUSH
70059: LD_INT 1
70061: PUSH
70062: EMPTY
70063: LIST
70064: LIST
70065: PUSH
70066: LD_INT 2
70068: NEG
70069: PUSH
70070: LD_INT 1
70072: NEG
70073: PUSH
70074: EMPTY
70075: LIST
70076: LIST
70077: PUSH
70078: EMPTY
70079: LIST
70080: LIST
70081: LIST
70082: LIST
70083: LIST
70084: LIST
70085: LIST
70086: LIST
70087: LIST
70088: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
70089: LD_ADDR_VAR 0 39
70093: PUSH
70094: LD_INT 0
70096: PUSH
70097: LD_INT 0
70099: PUSH
70100: EMPTY
70101: LIST
70102: LIST
70103: PUSH
70104: LD_INT 0
70106: PUSH
70107: LD_INT 1
70109: NEG
70110: PUSH
70111: EMPTY
70112: LIST
70113: LIST
70114: PUSH
70115: LD_INT 1
70117: PUSH
70118: LD_INT 0
70120: PUSH
70121: EMPTY
70122: LIST
70123: LIST
70124: PUSH
70125: LD_INT 1
70127: PUSH
70128: LD_INT 1
70130: PUSH
70131: EMPTY
70132: LIST
70133: LIST
70134: PUSH
70135: LD_INT 0
70137: PUSH
70138: LD_INT 1
70140: PUSH
70141: EMPTY
70142: LIST
70143: LIST
70144: PUSH
70145: LD_INT 1
70147: NEG
70148: PUSH
70149: LD_INT 0
70151: PUSH
70152: EMPTY
70153: LIST
70154: LIST
70155: PUSH
70156: LD_INT 1
70158: NEG
70159: PUSH
70160: LD_INT 1
70162: NEG
70163: PUSH
70164: EMPTY
70165: LIST
70166: LIST
70167: PUSH
70168: LD_INT 1
70170: NEG
70171: PUSH
70172: LD_INT 2
70174: NEG
70175: PUSH
70176: EMPTY
70177: LIST
70178: LIST
70179: PUSH
70180: LD_INT 1
70182: PUSH
70183: LD_INT 2
70185: PUSH
70186: EMPTY
70187: LIST
70188: LIST
70189: PUSH
70190: EMPTY
70191: LIST
70192: LIST
70193: LIST
70194: LIST
70195: LIST
70196: LIST
70197: LIST
70198: LIST
70199: LIST
70200: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
70201: LD_ADDR_VAR 0 40
70205: PUSH
70206: LD_INT 0
70208: PUSH
70209: LD_INT 0
70211: PUSH
70212: EMPTY
70213: LIST
70214: LIST
70215: PUSH
70216: LD_INT 0
70218: PUSH
70219: LD_INT 1
70221: NEG
70222: PUSH
70223: EMPTY
70224: LIST
70225: LIST
70226: PUSH
70227: LD_INT 1
70229: PUSH
70230: LD_INT 0
70232: PUSH
70233: EMPTY
70234: LIST
70235: LIST
70236: PUSH
70237: LD_INT 1
70239: PUSH
70240: LD_INT 1
70242: PUSH
70243: EMPTY
70244: LIST
70245: LIST
70246: PUSH
70247: LD_INT 0
70249: PUSH
70250: LD_INT 1
70252: PUSH
70253: EMPTY
70254: LIST
70255: LIST
70256: PUSH
70257: LD_INT 1
70259: NEG
70260: PUSH
70261: LD_INT 0
70263: PUSH
70264: EMPTY
70265: LIST
70266: LIST
70267: PUSH
70268: LD_INT 1
70270: NEG
70271: PUSH
70272: LD_INT 1
70274: NEG
70275: PUSH
70276: EMPTY
70277: LIST
70278: LIST
70279: PUSH
70280: LD_INT 1
70282: PUSH
70283: LD_INT 1
70285: NEG
70286: PUSH
70287: EMPTY
70288: LIST
70289: LIST
70290: PUSH
70291: LD_INT 1
70293: NEG
70294: PUSH
70295: LD_INT 1
70297: PUSH
70298: EMPTY
70299: LIST
70300: LIST
70301: PUSH
70302: EMPTY
70303: LIST
70304: LIST
70305: LIST
70306: LIST
70307: LIST
70308: LIST
70309: LIST
70310: LIST
70311: LIST
70312: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70313: LD_ADDR_VAR 0 41
70317: PUSH
70318: LD_INT 0
70320: PUSH
70321: LD_INT 0
70323: PUSH
70324: EMPTY
70325: LIST
70326: LIST
70327: PUSH
70328: LD_INT 0
70330: PUSH
70331: LD_INT 1
70333: NEG
70334: PUSH
70335: EMPTY
70336: LIST
70337: LIST
70338: PUSH
70339: LD_INT 1
70341: PUSH
70342: LD_INT 0
70344: PUSH
70345: EMPTY
70346: LIST
70347: LIST
70348: PUSH
70349: LD_INT 1
70351: PUSH
70352: LD_INT 1
70354: PUSH
70355: EMPTY
70356: LIST
70357: LIST
70358: PUSH
70359: LD_INT 0
70361: PUSH
70362: LD_INT 1
70364: PUSH
70365: EMPTY
70366: LIST
70367: LIST
70368: PUSH
70369: LD_INT 1
70371: NEG
70372: PUSH
70373: LD_INT 0
70375: PUSH
70376: EMPTY
70377: LIST
70378: LIST
70379: PUSH
70380: LD_INT 1
70382: NEG
70383: PUSH
70384: LD_INT 1
70386: NEG
70387: PUSH
70388: EMPTY
70389: LIST
70390: LIST
70391: PUSH
70392: LD_INT 1
70394: NEG
70395: PUSH
70396: LD_INT 2
70398: NEG
70399: PUSH
70400: EMPTY
70401: LIST
70402: LIST
70403: PUSH
70404: LD_INT 1
70406: PUSH
70407: LD_INT 1
70409: NEG
70410: PUSH
70411: EMPTY
70412: LIST
70413: LIST
70414: PUSH
70415: LD_INT 2
70417: PUSH
70418: LD_INT 0
70420: PUSH
70421: EMPTY
70422: LIST
70423: LIST
70424: PUSH
70425: LD_INT 2
70427: PUSH
70428: LD_INT 1
70430: PUSH
70431: EMPTY
70432: LIST
70433: LIST
70434: PUSH
70435: LD_INT 2
70437: PUSH
70438: LD_INT 2
70440: PUSH
70441: EMPTY
70442: LIST
70443: LIST
70444: PUSH
70445: LD_INT 1
70447: PUSH
70448: LD_INT 2
70450: PUSH
70451: EMPTY
70452: LIST
70453: LIST
70454: PUSH
70455: LD_INT 1
70457: NEG
70458: PUSH
70459: LD_INT 1
70461: PUSH
70462: EMPTY
70463: LIST
70464: LIST
70465: PUSH
70466: LD_INT 2
70468: NEG
70469: PUSH
70470: LD_INT 0
70472: PUSH
70473: EMPTY
70474: LIST
70475: LIST
70476: PUSH
70477: LD_INT 2
70479: NEG
70480: PUSH
70481: LD_INT 1
70483: NEG
70484: PUSH
70485: EMPTY
70486: LIST
70487: LIST
70488: PUSH
70489: LD_INT 2
70491: NEG
70492: PUSH
70493: LD_INT 2
70495: NEG
70496: PUSH
70497: EMPTY
70498: LIST
70499: LIST
70500: PUSH
70501: LD_INT 2
70503: NEG
70504: PUSH
70505: LD_INT 3
70507: NEG
70508: PUSH
70509: EMPTY
70510: LIST
70511: LIST
70512: PUSH
70513: LD_INT 2
70515: PUSH
70516: LD_INT 1
70518: NEG
70519: PUSH
70520: EMPTY
70521: LIST
70522: LIST
70523: PUSH
70524: LD_INT 3
70526: PUSH
70527: LD_INT 0
70529: PUSH
70530: EMPTY
70531: LIST
70532: LIST
70533: PUSH
70534: LD_INT 3
70536: PUSH
70537: LD_INT 1
70539: PUSH
70540: EMPTY
70541: LIST
70542: LIST
70543: PUSH
70544: LD_INT 3
70546: PUSH
70547: LD_INT 2
70549: PUSH
70550: EMPTY
70551: LIST
70552: LIST
70553: PUSH
70554: LD_INT 3
70556: PUSH
70557: LD_INT 3
70559: PUSH
70560: EMPTY
70561: LIST
70562: LIST
70563: PUSH
70564: LD_INT 2
70566: PUSH
70567: LD_INT 3
70569: PUSH
70570: EMPTY
70571: LIST
70572: LIST
70573: PUSH
70574: LD_INT 2
70576: NEG
70577: PUSH
70578: LD_INT 1
70580: PUSH
70581: EMPTY
70582: LIST
70583: LIST
70584: PUSH
70585: LD_INT 3
70587: NEG
70588: PUSH
70589: LD_INT 0
70591: PUSH
70592: EMPTY
70593: LIST
70594: LIST
70595: PUSH
70596: LD_INT 3
70598: NEG
70599: PUSH
70600: LD_INT 1
70602: NEG
70603: PUSH
70604: EMPTY
70605: LIST
70606: LIST
70607: PUSH
70608: LD_INT 3
70610: NEG
70611: PUSH
70612: LD_INT 2
70614: NEG
70615: PUSH
70616: EMPTY
70617: LIST
70618: LIST
70619: PUSH
70620: LD_INT 3
70622: NEG
70623: PUSH
70624: LD_INT 3
70626: NEG
70627: PUSH
70628: EMPTY
70629: LIST
70630: LIST
70631: PUSH
70632: EMPTY
70633: LIST
70634: LIST
70635: LIST
70636: LIST
70637: LIST
70638: LIST
70639: LIST
70640: LIST
70641: LIST
70642: LIST
70643: LIST
70644: LIST
70645: LIST
70646: LIST
70647: LIST
70648: LIST
70649: LIST
70650: LIST
70651: LIST
70652: LIST
70653: LIST
70654: LIST
70655: LIST
70656: LIST
70657: LIST
70658: LIST
70659: LIST
70660: LIST
70661: LIST
70662: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70663: LD_ADDR_VAR 0 42
70667: PUSH
70668: LD_INT 0
70670: PUSH
70671: LD_INT 0
70673: PUSH
70674: EMPTY
70675: LIST
70676: LIST
70677: PUSH
70678: LD_INT 0
70680: PUSH
70681: LD_INT 1
70683: NEG
70684: PUSH
70685: EMPTY
70686: LIST
70687: LIST
70688: PUSH
70689: LD_INT 1
70691: PUSH
70692: LD_INT 0
70694: PUSH
70695: EMPTY
70696: LIST
70697: LIST
70698: PUSH
70699: LD_INT 1
70701: PUSH
70702: LD_INT 1
70704: PUSH
70705: EMPTY
70706: LIST
70707: LIST
70708: PUSH
70709: LD_INT 0
70711: PUSH
70712: LD_INT 1
70714: PUSH
70715: EMPTY
70716: LIST
70717: LIST
70718: PUSH
70719: LD_INT 1
70721: NEG
70722: PUSH
70723: LD_INT 0
70725: PUSH
70726: EMPTY
70727: LIST
70728: LIST
70729: PUSH
70730: LD_INT 1
70732: NEG
70733: PUSH
70734: LD_INT 1
70736: NEG
70737: PUSH
70738: EMPTY
70739: LIST
70740: LIST
70741: PUSH
70742: LD_INT 1
70744: NEG
70745: PUSH
70746: LD_INT 2
70748: NEG
70749: PUSH
70750: EMPTY
70751: LIST
70752: LIST
70753: PUSH
70754: LD_INT 0
70756: PUSH
70757: LD_INT 2
70759: NEG
70760: PUSH
70761: EMPTY
70762: LIST
70763: LIST
70764: PUSH
70765: LD_INT 1
70767: PUSH
70768: LD_INT 1
70770: NEG
70771: PUSH
70772: EMPTY
70773: LIST
70774: LIST
70775: PUSH
70776: LD_INT 2
70778: PUSH
70779: LD_INT 1
70781: PUSH
70782: EMPTY
70783: LIST
70784: LIST
70785: PUSH
70786: LD_INT 2
70788: PUSH
70789: LD_INT 2
70791: PUSH
70792: EMPTY
70793: LIST
70794: LIST
70795: PUSH
70796: LD_INT 1
70798: PUSH
70799: LD_INT 2
70801: PUSH
70802: EMPTY
70803: LIST
70804: LIST
70805: PUSH
70806: LD_INT 0
70808: PUSH
70809: LD_INT 2
70811: PUSH
70812: EMPTY
70813: LIST
70814: LIST
70815: PUSH
70816: LD_INT 1
70818: NEG
70819: PUSH
70820: LD_INT 1
70822: PUSH
70823: EMPTY
70824: LIST
70825: LIST
70826: PUSH
70827: LD_INT 2
70829: NEG
70830: PUSH
70831: LD_INT 1
70833: NEG
70834: PUSH
70835: EMPTY
70836: LIST
70837: LIST
70838: PUSH
70839: LD_INT 2
70841: NEG
70842: PUSH
70843: LD_INT 2
70845: NEG
70846: PUSH
70847: EMPTY
70848: LIST
70849: LIST
70850: PUSH
70851: LD_INT 2
70853: NEG
70854: PUSH
70855: LD_INT 3
70857: NEG
70858: PUSH
70859: EMPTY
70860: LIST
70861: LIST
70862: PUSH
70863: LD_INT 1
70865: NEG
70866: PUSH
70867: LD_INT 3
70869: NEG
70870: PUSH
70871: EMPTY
70872: LIST
70873: LIST
70874: PUSH
70875: LD_INT 0
70877: PUSH
70878: LD_INT 3
70880: NEG
70881: PUSH
70882: EMPTY
70883: LIST
70884: LIST
70885: PUSH
70886: LD_INT 1
70888: PUSH
70889: LD_INT 2
70891: NEG
70892: PUSH
70893: EMPTY
70894: LIST
70895: LIST
70896: PUSH
70897: LD_INT 3
70899: PUSH
70900: LD_INT 2
70902: PUSH
70903: EMPTY
70904: LIST
70905: LIST
70906: PUSH
70907: LD_INT 3
70909: PUSH
70910: LD_INT 3
70912: PUSH
70913: EMPTY
70914: LIST
70915: LIST
70916: PUSH
70917: LD_INT 2
70919: PUSH
70920: LD_INT 3
70922: PUSH
70923: EMPTY
70924: LIST
70925: LIST
70926: PUSH
70927: LD_INT 1
70929: PUSH
70930: LD_INT 3
70932: PUSH
70933: EMPTY
70934: LIST
70935: LIST
70936: PUSH
70937: LD_INT 0
70939: PUSH
70940: LD_INT 3
70942: PUSH
70943: EMPTY
70944: LIST
70945: LIST
70946: PUSH
70947: LD_INT 1
70949: NEG
70950: PUSH
70951: LD_INT 2
70953: PUSH
70954: EMPTY
70955: LIST
70956: LIST
70957: PUSH
70958: LD_INT 3
70960: NEG
70961: PUSH
70962: LD_INT 2
70964: NEG
70965: PUSH
70966: EMPTY
70967: LIST
70968: LIST
70969: PUSH
70970: LD_INT 3
70972: NEG
70973: PUSH
70974: LD_INT 3
70976: NEG
70977: PUSH
70978: EMPTY
70979: LIST
70980: LIST
70981: PUSH
70982: EMPTY
70983: LIST
70984: LIST
70985: LIST
70986: LIST
70987: LIST
70988: LIST
70989: LIST
70990: LIST
70991: LIST
70992: LIST
70993: LIST
70994: LIST
70995: LIST
70996: LIST
70997: LIST
70998: LIST
70999: LIST
71000: LIST
71001: LIST
71002: LIST
71003: LIST
71004: LIST
71005: LIST
71006: LIST
71007: LIST
71008: LIST
71009: LIST
71010: LIST
71011: LIST
71012: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
71013: LD_ADDR_VAR 0 43
71017: PUSH
71018: LD_INT 0
71020: PUSH
71021: LD_INT 0
71023: PUSH
71024: EMPTY
71025: LIST
71026: LIST
71027: PUSH
71028: LD_INT 0
71030: PUSH
71031: LD_INT 1
71033: NEG
71034: PUSH
71035: EMPTY
71036: LIST
71037: LIST
71038: PUSH
71039: LD_INT 1
71041: PUSH
71042: LD_INT 0
71044: PUSH
71045: EMPTY
71046: LIST
71047: LIST
71048: PUSH
71049: LD_INT 1
71051: PUSH
71052: LD_INT 1
71054: PUSH
71055: EMPTY
71056: LIST
71057: LIST
71058: PUSH
71059: LD_INT 0
71061: PUSH
71062: LD_INT 1
71064: PUSH
71065: EMPTY
71066: LIST
71067: LIST
71068: PUSH
71069: LD_INT 1
71071: NEG
71072: PUSH
71073: LD_INT 0
71075: PUSH
71076: EMPTY
71077: LIST
71078: LIST
71079: PUSH
71080: LD_INT 1
71082: NEG
71083: PUSH
71084: LD_INT 1
71086: NEG
71087: PUSH
71088: EMPTY
71089: LIST
71090: LIST
71091: PUSH
71092: LD_INT 1
71094: NEG
71095: PUSH
71096: LD_INT 2
71098: NEG
71099: PUSH
71100: EMPTY
71101: LIST
71102: LIST
71103: PUSH
71104: LD_INT 0
71106: PUSH
71107: LD_INT 2
71109: NEG
71110: PUSH
71111: EMPTY
71112: LIST
71113: LIST
71114: PUSH
71115: LD_INT 1
71117: PUSH
71118: LD_INT 1
71120: NEG
71121: PUSH
71122: EMPTY
71123: LIST
71124: LIST
71125: PUSH
71126: LD_INT 2
71128: PUSH
71129: LD_INT 0
71131: PUSH
71132: EMPTY
71133: LIST
71134: LIST
71135: PUSH
71136: LD_INT 2
71138: PUSH
71139: LD_INT 1
71141: PUSH
71142: EMPTY
71143: LIST
71144: LIST
71145: PUSH
71146: LD_INT 1
71148: PUSH
71149: LD_INT 2
71151: PUSH
71152: EMPTY
71153: LIST
71154: LIST
71155: PUSH
71156: LD_INT 0
71158: PUSH
71159: LD_INT 2
71161: PUSH
71162: EMPTY
71163: LIST
71164: LIST
71165: PUSH
71166: LD_INT 1
71168: NEG
71169: PUSH
71170: LD_INT 1
71172: PUSH
71173: EMPTY
71174: LIST
71175: LIST
71176: PUSH
71177: LD_INT 2
71179: NEG
71180: PUSH
71181: LD_INT 0
71183: PUSH
71184: EMPTY
71185: LIST
71186: LIST
71187: PUSH
71188: LD_INT 2
71190: NEG
71191: PUSH
71192: LD_INT 1
71194: NEG
71195: PUSH
71196: EMPTY
71197: LIST
71198: LIST
71199: PUSH
71200: LD_INT 1
71202: NEG
71203: PUSH
71204: LD_INT 3
71206: NEG
71207: PUSH
71208: EMPTY
71209: LIST
71210: LIST
71211: PUSH
71212: LD_INT 0
71214: PUSH
71215: LD_INT 3
71217: NEG
71218: PUSH
71219: EMPTY
71220: LIST
71221: LIST
71222: PUSH
71223: LD_INT 1
71225: PUSH
71226: LD_INT 2
71228: NEG
71229: PUSH
71230: EMPTY
71231: LIST
71232: LIST
71233: PUSH
71234: LD_INT 2
71236: PUSH
71237: LD_INT 1
71239: NEG
71240: PUSH
71241: EMPTY
71242: LIST
71243: LIST
71244: PUSH
71245: LD_INT 3
71247: PUSH
71248: LD_INT 0
71250: PUSH
71251: EMPTY
71252: LIST
71253: LIST
71254: PUSH
71255: LD_INT 3
71257: PUSH
71258: LD_INT 1
71260: PUSH
71261: EMPTY
71262: LIST
71263: LIST
71264: PUSH
71265: LD_INT 1
71267: PUSH
71268: LD_INT 3
71270: PUSH
71271: EMPTY
71272: LIST
71273: LIST
71274: PUSH
71275: LD_INT 0
71277: PUSH
71278: LD_INT 3
71280: PUSH
71281: EMPTY
71282: LIST
71283: LIST
71284: PUSH
71285: LD_INT 1
71287: NEG
71288: PUSH
71289: LD_INT 2
71291: PUSH
71292: EMPTY
71293: LIST
71294: LIST
71295: PUSH
71296: LD_INT 2
71298: NEG
71299: PUSH
71300: LD_INT 1
71302: PUSH
71303: EMPTY
71304: LIST
71305: LIST
71306: PUSH
71307: LD_INT 3
71309: NEG
71310: PUSH
71311: LD_INT 0
71313: PUSH
71314: EMPTY
71315: LIST
71316: LIST
71317: PUSH
71318: LD_INT 3
71320: NEG
71321: PUSH
71322: LD_INT 1
71324: NEG
71325: PUSH
71326: EMPTY
71327: LIST
71328: LIST
71329: PUSH
71330: EMPTY
71331: LIST
71332: LIST
71333: LIST
71334: LIST
71335: LIST
71336: LIST
71337: LIST
71338: LIST
71339: LIST
71340: LIST
71341: LIST
71342: LIST
71343: LIST
71344: LIST
71345: LIST
71346: LIST
71347: LIST
71348: LIST
71349: LIST
71350: LIST
71351: LIST
71352: LIST
71353: LIST
71354: LIST
71355: LIST
71356: LIST
71357: LIST
71358: LIST
71359: LIST
71360: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
71361: LD_ADDR_VAR 0 44
71365: PUSH
71366: LD_INT 0
71368: PUSH
71369: LD_INT 0
71371: PUSH
71372: EMPTY
71373: LIST
71374: LIST
71375: PUSH
71376: LD_INT 0
71378: PUSH
71379: LD_INT 1
71381: NEG
71382: PUSH
71383: EMPTY
71384: LIST
71385: LIST
71386: PUSH
71387: LD_INT 1
71389: PUSH
71390: LD_INT 0
71392: PUSH
71393: EMPTY
71394: LIST
71395: LIST
71396: PUSH
71397: LD_INT 1
71399: PUSH
71400: LD_INT 1
71402: PUSH
71403: EMPTY
71404: LIST
71405: LIST
71406: PUSH
71407: LD_INT 0
71409: PUSH
71410: LD_INT 1
71412: PUSH
71413: EMPTY
71414: LIST
71415: LIST
71416: PUSH
71417: LD_INT 1
71419: NEG
71420: PUSH
71421: LD_INT 0
71423: PUSH
71424: EMPTY
71425: LIST
71426: LIST
71427: PUSH
71428: LD_INT 1
71430: NEG
71431: PUSH
71432: LD_INT 1
71434: NEG
71435: PUSH
71436: EMPTY
71437: LIST
71438: LIST
71439: PUSH
71440: LD_INT 1
71442: NEG
71443: PUSH
71444: LD_INT 2
71446: NEG
71447: PUSH
71448: EMPTY
71449: LIST
71450: LIST
71451: PUSH
71452: LD_INT 1
71454: PUSH
71455: LD_INT 1
71457: NEG
71458: PUSH
71459: EMPTY
71460: LIST
71461: LIST
71462: PUSH
71463: LD_INT 2
71465: PUSH
71466: LD_INT 0
71468: PUSH
71469: EMPTY
71470: LIST
71471: LIST
71472: PUSH
71473: LD_INT 2
71475: PUSH
71476: LD_INT 1
71478: PUSH
71479: EMPTY
71480: LIST
71481: LIST
71482: PUSH
71483: LD_INT 2
71485: PUSH
71486: LD_INT 2
71488: PUSH
71489: EMPTY
71490: LIST
71491: LIST
71492: PUSH
71493: LD_INT 1
71495: PUSH
71496: LD_INT 2
71498: PUSH
71499: EMPTY
71500: LIST
71501: LIST
71502: PUSH
71503: LD_INT 1
71505: NEG
71506: PUSH
71507: LD_INT 1
71509: PUSH
71510: EMPTY
71511: LIST
71512: LIST
71513: PUSH
71514: LD_INT 2
71516: NEG
71517: PUSH
71518: LD_INT 0
71520: PUSH
71521: EMPTY
71522: LIST
71523: LIST
71524: PUSH
71525: LD_INT 2
71527: NEG
71528: PUSH
71529: LD_INT 1
71531: NEG
71532: PUSH
71533: EMPTY
71534: LIST
71535: LIST
71536: PUSH
71537: LD_INT 2
71539: NEG
71540: PUSH
71541: LD_INT 2
71543: NEG
71544: PUSH
71545: EMPTY
71546: LIST
71547: LIST
71548: PUSH
71549: LD_INT 2
71551: NEG
71552: PUSH
71553: LD_INT 3
71555: NEG
71556: PUSH
71557: EMPTY
71558: LIST
71559: LIST
71560: PUSH
71561: LD_INT 2
71563: PUSH
71564: LD_INT 1
71566: NEG
71567: PUSH
71568: EMPTY
71569: LIST
71570: LIST
71571: PUSH
71572: LD_INT 3
71574: PUSH
71575: LD_INT 0
71577: PUSH
71578: EMPTY
71579: LIST
71580: LIST
71581: PUSH
71582: LD_INT 3
71584: PUSH
71585: LD_INT 1
71587: PUSH
71588: EMPTY
71589: LIST
71590: LIST
71591: PUSH
71592: LD_INT 3
71594: PUSH
71595: LD_INT 2
71597: PUSH
71598: EMPTY
71599: LIST
71600: LIST
71601: PUSH
71602: LD_INT 3
71604: PUSH
71605: LD_INT 3
71607: PUSH
71608: EMPTY
71609: LIST
71610: LIST
71611: PUSH
71612: LD_INT 2
71614: PUSH
71615: LD_INT 3
71617: PUSH
71618: EMPTY
71619: LIST
71620: LIST
71621: PUSH
71622: LD_INT 2
71624: NEG
71625: PUSH
71626: LD_INT 1
71628: PUSH
71629: EMPTY
71630: LIST
71631: LIST
71632: PUSH
71633: LD_INT 3
71635: NEG
71636: PUSH
71637: LD_INT 0
71639: PUSH
71640: EMPTY
71641: LIST
71642: LIST
71643: PUSH
71644: LD_INT 3
71646: NEG
71647: PUSH
71648: LD_INT 1
71650: NEG
71651: PUSH
71652: EMPTY
71653: LIST
71654: LIST
71655: PUSH
71656: LD_INT 3
71658: NEG
71659: PUSH
71660: LD_INT 2
71662: NEG
71663: PUSH
71664: EMPTY
71665: LIST
71666: LIST
71667: PUSH
71668: LD_INT 3
71670: NEG
71671: PUSH
71672: LD_INT 3
71674: NEG
71675: PUSH
71676: EMPTY
71677: LIST
71678: LIST
71679: PUSH
71680: EMPTY
71681: LIST
71682: LIST
71683: LIST
71684: LIST
71685: LIST
71686: LIST
71687: LIST
71688: LIST
71689: LIST
71690: LIST
71691: LIST
71692: LIST
71693: LIST
71694: LIST
71695: LIST
71696: LIST
71697: LIST
71698: LIST
71699: LIST
71700: LIST
71701: LIST
71702: LIST
71703: LIST
71704: LIST
71705: LIST
71706: LIST
71707: LIST
71708: LIST
71709: LIST
71710: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
71711: LD_ADDR_VAR 0 45
71715: PUSH
71716: LD_INT 0
71718: PUSH
71719: LD_INT 0
71721: PUSH
71722: EMPTY
71723: LIST
71724: LIST
71725: PUSH
71726: LD_INT 0
71728: PUSH
71729: LD_INT 1
71731: NEG
71732: PUSH
71733: EMPTY
71734: LIST
71735: LIST
71736: PUSH
71737: LD_INT 1
71739: PUSH
71740: LD_INT 0
71742: PUSH
71743: EMPTY
71744: LIST
71745: LIST
71746: PUSH
71747: LD_INT 1
71749: PUSH
71750: LD_INT 1
71752: PUSH
71753: EMPTY
71754: LIST
71755: LIST
71756: PUSH
71757: LD_INT 0
71759: PUSH
71760: LD_INT 1
71762: PUSH
71763: EMPTY
71764: LIST
71765: LIST
71766: PUSH
71767: LD_INT 1
71769: NEG
71770: PUSH
71771: LD_INT 0
71773: PUSH
71774: EMPTY
71775: LIST
71776: LIST
71777: PUSH
71778: LD_INT 1
71780: NEG
71781: PUSH
71782: LD_INT 1
71784: NEG
71785: PUSH
71786: EMPTY
71787: LIST
71788: LIST
71789: PUSH
71790: LD_INT 1
71792: NEG
71793: PUSH
71794: LD_INT 2
71796: NEG
71797: PUSH
71798: EMPTY
71799: LIST
71800: LIST
71801: PUSH
71802: LD_INT 0
71804: PUSH
71805: LD_INT 2
71807: NEG
71808: PUSH
71809: EMPTY
71810: LIST
71811: LIST
71812: PUSH
71813: LD_INT 1
71815: PUSH
71816: LD_INT 1
71818: NEG
71819: PUSH
71820: EMPTY
71821: LIST
71822: LIST
71823: PUSH
71824: LD_INT 2
71826: PUSH
71827: LD_INT 1
71829: PUSH
71830: EMPTY
71831: LIST
71832: LIST
71833: PUSH
71834: LD_INT 2
71836: PUSH
71837: LD_INT 2
71839: PUSH
71840: EMPTY
71841: LIST
71842: LIST
71843: PUSH
71844: LD_INT 1
71846: PUSH
71847: LD_INT 2
71849: PUSH
71850: EMPTY
71851: LIST
71852: LIST
71853: PUSH
71854: LD_INT 0
71856: PUSH
71857: LD_INT 2
71859: PUSH
71860: EMPTY
71861: LIST
71862: LIST
71863: PUSH
71864: LD_INT 1
71866: NEG
71867: PUSH
71868: LD_INT 1
71870: PUSH
71871: EMPTY
71872: LIST
71873: LIST
71874: PUSH
71875: LD_INT 2
71877: NEG
71878: PUSH
71879: LD_INT 1
71881: NEG
71882: PUSH
71883: EMPTY
71884: LIST
71885: LIST
71886: PUSH
71887: LD_INT 2
71889: NEG
71890: PUSH
71891: LD_INT 2
71893: NEG
71894: PUSH
71895: EMPTY
71896: LIST
71897: LIST
71898: PUSH
71899: LD_INT 2
71901: NEG
71902: PUSH
71903: LD_INT 3
71905: NEG
71906: PUSH
71907: EMPTY
71908: LIST
71909: LIST
71910: PUSH
71911: LD_INT 1
71913: NEG
71914: PUSH
71915: LD_INT 3
71917: NEG
71918: PUSH
71919: EMPTY
71920: LIST
71921: LIST
71922: PUSH
71923: LD_INT 0
71925: PUSH
71926: LD_INT 3
71928: NEG
71929: PUSH
71930: EMPTY
71931: LIST
71932: LIST
71933: PUSH
71934: LD_INT 1
71936: PUSH
71937: LD_INT 2
71939: NEG
71940: PUSH
71941: EMPTY
71942: LIST
71943: LIST
71944: PUSH
71945: LD_INT 3
71947: PUSH
71948: LD_INT 2
71950: PUSH
71951: EMPTY
71952: LIST
71953: LIST
71954: PUSH
71955: LD_INT 3
71957: PUSH
71958: LD_INT 3
71960: PUSH
71961: EMPTY
71962: LIST
71963: LIST
71964: PUSH
71965: LD_INT 2
71967: PUSH
71968: LD_INT 3
71970: PUSH
71971: EMPTY
71972: LIST
71973: LIST
71974: PUSH
71975: LD_INT 1
71977: PUSH
71978: LD_INT 3
71980: PUSH
71981: EMPTY
71982: LIST
71983: LIST
71984: PUSH
71985: LD_INT 0
71987: PUSH
71988: LD_INT 3
71990: PUSH
71991: EMPTY
71992: LIST
71993: LIST
71994: PUSH
71995: LD_INT 1
71997: NEG
71998: PUSH
71999: LD_INT 2
72001: PUSH
72002: EMPTY
72003: LIST
72004: LIST
72005: PUSH
72006: LD_INT 3
72008: NEG
72009: PUSH
72010: LD_INT 2
72012: NEG
72013: PUSH
72014: EMPTY
72015: LIST
72016: LIST
72017: PUSH
72018: LD_INT 3
72020: NEG
72021: PUSH
72022: LD_INT 3
72024: NEG
72025: PUSH
72026: EMPTY
72027: LIST
72028: LIST
72029: PUSH
72030: EMPTY
72031: LIST
72032: LIST
72033: LIST
72034: LIST
72035: LIST
72036: LIST
72037: LIST
72038: LIST
72039: LIST
72040: LIST
72041: LIST
72042: LIST
72043: LIST
72044: LIST
72045: LIST
72046: LIST
72047: LIST
72048: LIST
72049: LIST
72050: LIST
72051: LIST
72052: LIST
72053: LIST
72054: LIST
72055: LIST
72056: LIST
72057: LIST
72058: LIST
72059: LIST
72060: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
72061: LD_ADDR_VAR 0 46
72065: PUSH
72066: LD_INT 0
72068: PUSH
72069: LD_INT 0
72071: PUSH
72072: EMPTY
72073: LIST
72074: LIST
72075: PUSH
72076: LD_INT 0
72078: PUSH
72079: LD_INT 1
72081: NEG
72082: PUSH
72083: EMPTY
72084: LIST
72085: LIST
72086: PUSH
72087: LD_INT 1
72089: PUSH
72090: LD_INT 0
72092: PUSH
72093: EMPTY
72094: LIST
72095: LIST
72096: PUSH
72097: LD_INT 1
72099: PUSH
72100: LD_INT 1
72102: PUSH
72103: EMPTY
72104: LIST
72105: LIST
72106: PUSH
72107: LD_INT 0
72109: PUSH
72110: LD_INT 1
72112: PUSH
72113: EMPTY
72114: LIST
72115: LIST
72116: PUSH
72117: LD_INT 1
72119: NEG
72120: PUSH
72121: LD_INT 0
72123: PUSH
72124: EMPTY
72125: LIST
72126: LIST
72127: PUSH
72128: LD_INT 1
72130: NEG
72131: PUSH
72132: LD_INT 1
72134: NEG
72135: PUSH
72136: EMPTY
72137: LIST
72138: LIST
72139: PUSH
72140: LD_INT 1
72142: NEG
72143: PUSH
72144: LD_INT 2
72146: NEG
72147: PUSH
72148: EMPTY
72149: LIST
72150: LIST
72151: PUSH
72152: LD_INT 0
72154: PUSH
72155: LD_INT 2
72157: NEG
72158: PUSH
72159: EMPTY
72160: LIST
72161: LIST
72162: PUSH
72163: LD_INT 1
72165: PUSH
72166: LD_INT 1
72168: NEG
72169: PUSH
72170: EMPTY
72171: LIST
72172: LIST
72173: PUSH
72174: LD_INT 2
72176: PUSH
72177: LD_INT 0
72179: PUSH
72180: EMPTY
72181: LIST
72182: LIST
72183: PUSH
72184: LD_INT 2
72186: PUSH
72187: LD_INT 1
72189: PUSH
72190: EMPTY
72191: LIST
72192: LIST
72193: PUSH
72194: LD_INT 1
72196: PUSH
72197: LD_INT 2
72199: PUSH
72200: EMPTY
72201: LIST
72202: LIST
72203: PUSH
72204: LD_INT 0
72206: PUSH
72207: LD_INT 2
72209: PUSH
72210: EMPTY
72211: LIST
72212: LIST
72213: PUSH
72214: LD_INT 1
72216: NEG
72217: PUSH
72218: LD_INT 1
72220: PUSH
72221: EMPTY
72222: LIST
72223: LIST
72224: PUSH
72225: LD_INT 2
72227: NEG
72228: PUSH
72229: LD_INT 0
72231: PUSH
72232: EMPTY
72233: LIST
72234: LIST
72235: PUSH
72236: LD_INT 2
72238: NEG
72239: PUSH
72240: LD_INT 1
72242: NEG
72243: PUSH
72244: EMPTY
72245: LIST
72246: LIST
72247: PUSH
72248: LD_INT 1
72250: NEG
72251: PUSH
72252: LD_INT 3
72254: NEG
72255: PUSH
72256: EMPTY
72257: LIST
72258: LIST
72259: PUSH
72260: LD_INT 0
72262: PUSH
72263: LD_INT 3
72265: NEG
72266: PUSH
72267: EMPTY
72268: LIST
72269: LIST
72270: PUSH
72271: LD_INT 1
72273: PUSH
72274: LD_INT 2
72276: NEG
72277: PUSH
72278: EMPTY
72279: LIST
72280: LIST
72281: PUSH
72282: LD_INT 2
72284: PUSH
72285: LD_INT 1
72287: NEG
72288: PUSH
72289: EMPTY
72290: LIST
72291: LIST
72292: PUSH
72293: LD_INT 3
72295: PUSH
72296: LD_INT 0
72298: PUSH
72299: EMPTY
72300: LIST
72301: LIST
72302: PUSH
72303: LD_INT 3
72305: PUSH
72306: LD_INT 1
72308: PUSH
72309: EMPTY
72310: LIST
72311: LIST
72312: PUSH
72313: LD_INT 1
72315: PUSH
72316: LD_INT 3
72318: PUSH
72319: EMPTY
72320: LIST
72321: LIST
72322: PUSH
72323: LD_INT 0
72325: PUSH
72326: LD_INT 3
72328: PUSH
72329: EMPTY
72330: LIST
72331: LIST
72332: PUSH
72333: LD_INT 1
72335: NEG
72336: PUSH
72337: LD_INT 2
72339: PUSH
72340: EMPTY
72341: LIST
72342: LIST
72343: PUSH
72344: LD_INT 2
72346: NEG
72347: PUSH
72348: LD_INT 1
72350: PUSH
72351: EMPTY
72352: LIST
72353: LIST
72354: PUSH
72355: LD_INT 3
72357: NEG
72358: PUSH
72359: LD_INT 0
72361: PUSH
72362: EMPTY
72363: LIST
72364: LIST
72365: PUSH
72366: LD_INT 3
72368: NEG
72369: PUSH
72370: LD_INT 1
72372: NEG
72373: PUSH
72374: EMPTY
72375: LIST
72376: LIST
72377: PUSH
72378: EMPTY
72379: LIST
72380: LIST
72381: LIST
72382: LIST
72383: LIST
72384: LIST
72385: LIST
72386: LIST
72387: LIST
72388: LIST
72389: LIST
72390: LIST
72391: LIST
72392: LIST
72393: LIST
72394: LIST
72395: LIST
72396: LIST
72397: LIST
72398: LIST
72399: LIST
72400: LIST
72401: LIST
72402: LIST
72403: LIST
72404: LIST
72405: LIST
72406: LIST
72407: LIST
72408: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72409: LD_ADDR_VAR 0 47
72413: PUSH
72414: LD_INT 0
72416: PUSH
72417: LD_INT 0
72419: PUSH
72420: EMPTY
72421: LIST
72422: LIST
72423: PUSH
72424: LD_INT 0
72426: PUSH
72427: LD_INT 1
72429: NEG
72430: PUSH
72431: EMPTY
72432: LIST
72433: LIST
72434: PUSH
72435: LD_INT 1
72437: PUSH
72438: LD_INT 0
72440: PUSH
72441: EMPTY
72442: LIST
72443: LIST
72444: PUSH
72445: LD_INT 1
72447: PUSH
72448: LD_INT 1
72450: PUSH
72451: EMPTY
72452: LIST
72453: LIST
72454: PUSH
72455: LD_INT 0
72457: PUSH
72458: LD_INT 1
72460: PUSH
72461: EMPTY
72462: LIST
72463: LIST
72464: PUSH
72465: LD_INT 1
72467: NEG
72468: PUSH
72469: LD_INT 0
72471: PUSH
72472: EMPTY
72473: LIST
72474: LIST
72475: PUSH
72476: LD_INT 1
72478: NEG
72479: PUSH
72480: LD_INT 1
72482: NEG
72483: PUSH
72484: EMPTY
72485: LIST
72486: LIST
72487: PUSH
72488: LD_INT 1
72490: NEG
72491: PUSH
72492: LD_INT 2
72494: NEG
72495: PUSH
72496: EMPTY
72497: LIST
72498: LIST
72499: PUSH
72500: LD_INT 0
72502: PUSH
72503: LD_INT 2
72505: NEG
72506: PUSH
72507: EMPTY
72508: LIST
72509: LIST
72510: PUSH
72511: LD_INT 1
72513: PUSH
72514: LD_INT 1
72516: NEG
72517: PUSH
72518: EMPTY
72519: LIST
72520: LIST
72521: PUSH
72522: LD_INT 2
72524: NEG
72525: PUSH
72526: LD_INT 1
72528: NEG
72529: PUSH
72530: EMPTY
72531: LIST
72532: LIST
72533: PUSH
72534: LD_INT 2
72536: NEG
72537: PUSH
72538: LD_INT 2
72540: NEG
72541: PUSH
72542: EMPTY
72543: LIST
72544: LIST
72545: PUSH
72546: EMPTY
72547: LIST
72548: LIST
72549: LIST
72550: LIST
72551: LIST
72552: LIST
72553: LIST
72554: LIST
72555: LIST
72556: LIST
72557: LIST
72558: LIST
72559: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
72560: LD_ADDR_VAR 0 48
72564: PUSH
72565: LD_INT 0
72567: PUSH
72568: LD_INT 0
72570: PUSH
72571: EMPTY
72572: LIST
72573: LIST
72574: PUSH
72575: LD_INT 0
72577: PUSH
72578: LD_INT 1
72580: NEG
72581: PUSH
72582: EMPTY
72583: LIST
72584: LIST
72585: PUSH
72586: LD_INT 1
72588: PUSH
72589: LD_INT 0
72591: PUSH
72592: EMPTY
72593: LIST
72594: LIST
72595: PUSH
72596: LD_INT 1
72598: PUSH
72599: LD_INT 1
72601: PUSH
72602: EMPTY
72603: LIST
72604: LIST
72605: PUSH
72606: LD_INT 0
72608: PUSH
72609: LD_INT 1
72611: PUSH
72612: EMPTY
72613: LIST
72614: LIST
72615: PUSH
72616: LD_INT 1
72618: NEG
72619: PUSH
72620: LD_INT 0
72622: PUSH
72623: EMPTY
72624: LIST
72625: LIST
72626: PUSH
72627: LD_INT 1
72629: NEG
72630: PUSH
72631: LD_INT 1
72633: NEG
72634: PUSH
72635: EMPTY
72636: LIST
72637: LIST
72638: PUSH
72639: LD_INT 1
72641: NEG
72642: PUSH
72643: LD_INT 2
72645: NEG
72646: PUSH
72647: EMPTY
72648: LIST
72649: LIST
72650: PUSH
72651: LD_INT 0
72653: PUSH
72654: LD_INT 2
72656: NEG
72657: PUSH
72658: EMPTY
72659: LIST
72660: LIST
72661: PUSH
72662: LD_INT 1
72664: PUSH
72665: LD_INT 1
72667: NEG
72668: PUSH
72669: EMPTY
72670: LIST
72671: LIST
72672: PUSH
72673: LD_INT 2
72675: PUSH
72676: LD_INT 0
72678: PUSH
72679: EMPTY
72680: LIST
72681: LIST
72682: PUSH
72683: LD_INT 2
72685: PUSH
72686: LD_INT 1
72688: PUSH
72689: EMPTY
72690: LIST
72691: LIST
72692: PUSH
72693: EMPTY
72694: LIST
72695: LIST
72696: LIST
72697: LIST
72698: LIST
72699: LIST
72700: LIST
72701: LIST
72702: LIST
72703: LIST
72704: LIST
72705: LIST
72706: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
72707: LD_ADDR_VAR 0 49
72711: PUSH
72712: LD_INT 0
72714: PUSH
72715: LD_INT 0
72717: PUSH
72718: EMPTY
72719: LIST
72720: LIST
72721: PUSH
72722: LD_INT 0
72724: PUSH
72725: LD_INT 1
72727: NEG
72728: PUSH
72729: EMPTY
72730: LIST
72731: LIST
72732: PUSH
72733: LD_INT 1
72735: PUSH
72736: LD_INT 0
72738: PUSH
72739: EMPTY
72740: LIST
72741: LIST
72742: PUSH
72743: LD_INT 1
72745: PUSH
72746: LD_INT 1
72748: PUSH
72749: EMPTY
72750: LIST
72751: LIST
72752: PUSH
72753: LD_INT 0
72755: PUSH
72756: LD_INT 1
72758: PUSH
72759: EMPTY
72760: LIST
72761: LIST
72762: PUSH
72763: LD_INT 1
72765: NEG
72766: PUSH
72767: LD_INT 0
72769: PUSH
72770: EMPTY
72771: LIST
72772: LIST
72773: PUSH
72774: LD_INT 1
72776: NEG
72777: PUSH
72778: LD_INT 1
72780: NEG
72781: PUSH
72782: EMPTY
72783: LIST
72784: LIST
72785: PUSH
72786: LD_INT 1
72788: PUSH
72789: LD_INT 1
72791: NEG
72792: PUSH
72793: EMPTY
72794: LIST
72795: LIST
72796: PUSH
72797: LD_INT 2
72799: PUSH
72800: LD_INT 0
72802: PUSH
72803: EMPTY
72804: LIST
72805: LIST
72806: PUSH
72807: LD_INT 2
72809: PUSH
72810: LD_INT 1
72812: PUSH
72813: EMPTY
72814: LIST
72815: LIST
72816: PUSH
72817: LD_INT 2
72819: PUSH
72820: LD_INT 2
72822: PUSH
72823: EMPTY
72824: LIST
72825: LIST
72826: PUSH
72827: LD_INT 1
72829: PUSH
72830: LD_INT 2
72832: PUSH
72833: EMPTY
72834: LIST
72835: LIST
72836: PUSH
72837: EMPTY
72838: LIST
72839: LIST
72840: LIST
72841: LIST
72842: LIST
72843: LIST
72844: LIST
72845: LIST
72846: LIST
72847: LIST
72848: LIST
72849: LIST
72850: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
72851: LD_ADDR_VAR 0 50
72855: PUSH
72856: LD_INT 0
72858: PUSH
72859: LD_INT 0
72861: PUSH
72862: EMPTY
72863: LIST
72864: LIST
72865: PUSH
72866: LD_INT 0
72868: PUSH
72869: LD_INT 1
72871: NEG
72872: PUSH
72873: EMPTY
72874: LIST
72875: LIST
72876: PUSH
72877: LD_INT 1
72879: PUSH
72880: LD_INT 0
72882: PUSH
72883: EMPTY
72884: LIST
72885: LIST
72886: PUSH
72887: LD_INT 1
72889: PUSH
72890: LD_INT 1
72892: PUSH
72893: EMPTY
72894: LIST
72895: LIST
72896: PUSH
72897: LD_INT 0
72899: PUSH
72900: LD_INT 1
72902: PUSH
72903: EMPTY
72904: LIST
72905: LIST
72906: PUSH
72907: LD_INT 1
72909: NEG
72910: PUSH
72911: LD_INT 0
72913: PUSH
72914: EMPTY
72915: LIST
72916: LIST
72917: PUSH
72918: LD_INT 1
72920: NEG
72921: PUSH
72922: LD_INT 1
72924: NEG
72925: PUSH
72926: EMPTY
72927: LIST
72928: LIST
72929: PUSH
72930: LD_INT 2
72932: PUSH
72933: LD_INT 1
72935: PUSH
72936: EMPTY
72937: LIST
72938: LIST
72939: PUSH
72940: LD_INT 2
72942: PUSH
72943: LD_INT 2
72945: PUSH
72946: EMPTY
72947: LIST
72948: LIST
72949: PUSH
72950: LD_INT 1
72952: PUSH
72953: LD_INT 2
72955: PUSH
72956: EMPTY
72957: LIST
72958: LIST
72959: PUSH
72960: LD_INT 0
72962: PUSH
72963: LD_INT 2
72965: PUSH
72966: EMPTY
72967: LIST
72968: LIST
72969: PUSH
72970: LD_INT 1
72972: NEG
72973: PUSH
72974: LD_INT 1
72976: PUSH
72977: EMPTY
72978: LIST
72979: LIST
72980: PUSH
72981: EMPTY
72982: LIST
72983: LIST
72984: LIST
72985: LIST
72986: LIST
72987: LIST
72988: LIST
72989: LIST
72990: LIST
72991: LIST
72992: LIST
72993: LIST
72994: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
72995: LD_ADDR_VAR 0 51
72999: PUSH
73000: LD_INT 0
73002: PUSH
73003: LD_INT 0
73005: PUSH
73006: EMPTY
73007: LIST
73008: LIST
73009: PUSH
73010: LD_INT 0
73012: PUSH
73013: LD_INT 1
73015: NEG
73016: PUSH
73017: EMPTY
73018: LIST
73019: LIST
73020: PUSH
73021: LD_INT 1
73023: PUSH
73024: LD_INT 0
73026: PUSH
73027: EMPTY
73028: LIST
73029: LIST
73030: PUSH
73031: LD_INT 1
73033: PUSH
73034: LD_INT 1
73036: PUSH
73037: EMPTY
73038: LIST
73039: LIST
73040: PUSH
73041: LD_INT 0
73043: PUSH
73044: LD_INT 1
73046: PUSH
73047: EMPTY
73048: LIST
73049: LIST
73050: PUSH
73051: LD_INT 1
73053: NEG
73054: PUSH
73055: LD_INT 0
73057: PUSH
73058: EMPTY
73059: LIST
73060: LIST
73061: PUSH
73062: LD_INT 1
73064: NEG
73065: PUSH
73066: LD_INT 1
73068: NEG
73069: PUSH
73070: EMPTY
73071: LIST
73072: LIST
73073: PUSH
73074: LD_INT 1
73076: PUSH
73077: LD_INT 2
73079: PUSH
73080: EMPTY
73081: LIST
73082: LIST
73083: PUSH
73084: LD_INT 0
73086: PUSH
73087: LD_INT 2
73089: PUSH
73090: EMPTY
73091: LIST
73092: LIST
73093: PUSH
73094: LD_INT 1
73096: NEG
73097: PUSH
73098: LD_INT 1
73100: PUSH
73101: EMPTY
73102: LIST
73103: LIST
73104: PUSH
73105: LD_INT 2
73107: NEG
73108: PUSH
73109: LD_INT 0
73111: PUSH
73112: EMPTY
73113: LIST
73114: LIST
73115: PUSH
73116: LD_INT 2
73118: NEG
73119: PUSH
73120: LD_INT 1
73122: NEG
73123: PUSH
73124: EMPTY
73125: LIST
73126: LIST
73127: PUSH
73128: EMPTY
73129: LIST
73130: LIST
73131: LIST
73132: LIST
73133: LIST
73134: LIST
73135: LIST
73136: LIST
73137: LIST
73138: LIST
73139: LIST
73140: LIST
73141: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73142: LD_ADDR_VAR 0 52
73146: PUSH
73147: LD_INT 0
73149: PUSH
73150: LD_INT 0
73152: PUSH
73153: EMPTY
73154: LIST
73155: LIST
73156: PUSH
73157: LD_INT 0
73159: PUSH
73160: LD_INT 1
73162: NEG
73163: PUSH
73164: EMPTY
73165: LIST
73166: LIST
73167: PUSH
73168: LD_INT 1
73170: PUSH
73171: LD_INT 0
73173: PUSH
73174: EMPTY
73175: LIST
73176: LIST
73177: PUSH
73178: LD_INT 1
73180: PUSH
73181: LD_INT 1
73183: PUSH
73184: EMPTY
73185: LIST
73186: LIST
73187: PUSH
73188: LD_INT 0
73190: PUSH
73191: LD_INT 1
73193: PUSH
73194: EMPTY
73195: LIST
73196: LIST
73197: PUSH
73198: LD_INT 1
73200: NEG
73201: PUSH
73202: LD_INT 0
73204: PUSH
73205: EMPTY
73206: LIST
73207: LIST
73208: PUSH
73209: LD_INT 1
73211: NEG
73212: PUSH
73213: LD_INT 1
73215: NEG
73216: PUSH
73217: EMPTY
73218: LIST
73219: LIST
73220: PUSH
73221: LD_INT 1
73223: NEG
73224: PUSH
73225: LD_INT 2
73227: NEG
73228: PUSH
73229: EMPTY
73230: LIST
73231: LIST
73232: PUSH
73233: LD_INT 1
73235: NEG
73236: PUSH
73237: LD_INT 1
73239: PUSH
73240: EMPTY
73241: LIST
73242: LIST
73243: PUSH
73244: LD_INT 2
73246: NEG
73247: PUSH
73248: LD_INT 0
73250: PUSH
73251: EMPTY
73252: LIST
73253: LIST
73254: PUSH
73255: LD_INT 2
73257: NEG
73258: PUSH
73259: LD_INT 1
73261: NEG
73262: PUSH
73263: EMPTY
73264: LIST
73265: LIST
73266: PUSH
73267: LD_INT 2
73269: NEG
73270: PUSH
73271: LD_INT 2
73273: NEG
73274: PUSH
73275: EMPTY
73276: LIST
73277: LIST
73278: PUSH
73279: EMPTY
73280: LIST
73281: LIST
73282: LIST
73283: LIST
73284: LIST
73285: LIST
73286: LIST
73287: LIST
73288: LIST
73289: LIST
73290: LIST
73291: LIST
73292: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73293: LD_ADDR_VAR 0 53
73297: PUSH
73298: LD_INT 0
73300: PUSH
73301: LD_INT 0
73303: PUSH
73304: EMPTY
73305: LIST
73306: LIST
73307: PUSH
73308: LD_INT 0
73310: PUSH
73311: LD_INT 1
73313: NEG
73314: PUSH
73315: EMPTY
73316: LIST
73317: LIST
73318: PUSH
73319: LD_INT 1
73321: PUSH
73322: LD_INT 0
73324: PUSH
73325: EMPTY
73326: LIST
73327: LIST
73328: PUSH
73329: LD_INT 1
73331: PUSH
73332: LD_INT 1
73334: PUSH
73335: EMPTY
73336: LIST
73337: LIST
73338: PUSH
73339: LD_INT 0
73341: PUSH
73342: LD_INT 1
73344: PUSH
73345: EMPTY
73346: LIST
73347: LIST
73348: PUSH
73349: LD_INT 1
73351: NEG
73352: PUSH
73353: LD_INT 0
73355: PUSH
73356: EMPTY
73357: LIST
73358: LIST
73359: PUSH
73360: LD_INT 1
73362: NEG
73363: PUSH
73364: LD_INT 1
73366: NEG
73367: PUSH
73368: EMPTY
73369: LIST
73370: LIST
73371: PUSH
73372: LD_INT 1
73374: NEG
73375: PUSH
73376: LD_INT 2
73378: NEG
73379: PUSH
73380: EMPTY
73381: LIST
73382: LIST
73383: PUSH
73384: LD_INT 0
73386: PUSH
73387: LD_INT 2
73389: NEG
73390: PUSH
73391: EMPTY
73392: LIST
73393: LIST
73394: PUSH
73395: LD_INT 1
73397: PUSH
73398: LD_INT 1
73400: NEG
73401: PUSH
73402: EMPTY
73403: LIST
73404: LIST
73405: PUSH
73406: LD_INT 2
73408: PUSH
73409: LD_INT 0
73411: PUSH
73412: EMPTY
73413: LIST
73414: LIST
73415: PUSH
73416: LD_INT 2
73418: PUSH
73419: LD_INT 1
73421: PUSH
73422: EMPTY
73423: LIST
73424: LIST
73425: PUSH
73426: LD_INT 2
73428: PUSH
73429: LD_INT 2
73431: PUSH
73432: EMPTY
73433: LIST
73434: LIST
73435: PUSH
73436: LD_INT 1
73438: PUSH
73439: LD_INT 2
73441: PUSH
73442: EMPTY
73443: LIST
73444: LIST
73445: PUSH
73446: LD_INT 0
73448: PUSH
73449: LD_INT 2
73451: PUSH
73452: EMPTY
73453: LIST
73454: LIST
73455: PUSH
73456: LD_INT 1
73458: NEG
73459: PUSH
73460: LD_INT 1
73462: PUSH
73463: EMPTY
73464: LIST
73465: LIST
73466: PUSH
73467: LD_INT 2
73469: NEG
73470: PUSH
73471: LD_INT 0
73473: PUSH
73474: EMPTY
73475: LIST
73476: LIST
73477: PUSH
73478: LD_INT 2
73480: NEG
73481: PUSH
73482: LD_INT 1
73484: NEG
73485: PUSH
73486: EMPTY
73487: LIST
73488: LIST
73489: PUSH
73490: LD_INT 2
73492: NEG
73493: PUSH
73494: LD_INT 2
73496: NEG
73497: PUSH
73498: EMPTY
73499: LIST
73500: LIST
73501: PUSH
73502: EMPTY
73503: LIST
73504: LIST
73505: LIST
73506: LIST
73507: LIST
73508: LIST
73509: LIST
73510: LIST
73511: LIST
73512: LIST
73513: LIST
73514: LIST
73515: LIST
73516: LIST
73517: LIST
73518: LIST
73519: LIST
73520: LIST
73521: LIST
73522: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73523: LD_ADDR_VAR 0 54
73527: PUSH
73528: LD_INT 0
73530: PUSH
73531: LD_INT 0
73533: PUSH
73534: EMPTY
73535: LIST
73536: LIST
73537: PUSH
73538: LD_INT 0
73540: PUSH
73541: LD_INT 1
73543: NEG
73544: PUSH
73545: EMPTY
73546: LIST
73547: LIST
73548: PUSH
73549: LD_INT 1
73551: PUSH
73552: LD_INT 0
73554: PUSH
73555: EMPTY
73556: LIST
73557: LIST
73558: PUSH
73559: LD_INT 1
73561: PUSH
73562: LD_INT 1
73564: PUSH
73565: EMPTY
73566: LIST
73567: LIST
73568: PUSH
73569: LD_INT 0
73571: PUSH
73572: LD_INT 1
73574: PUSH
73575: EMPTY
73576: LIST
73577: LIST
73578: PUSH
73579: LD_INT 1
73581: NEG
73582: PUSH
73583: LD_INT 0
73585: PUSH
73586: EMPTY
73587: LIST
73588: LIST
73589: PUSH
73590: LD_INT 1
73592: NEG
73593: PUSH
73594: LD_INT 1
73596: NEG
73597: PUSH
73598: EMPTY
73599: LIST
73600: LIST
73601: PUSH
73602: LD_INT 1
73604: NEG
73605: PUSH
73606: LD_INT 2
73608: NEG
73609: PUSH
73610: EMPTY
73611: LIST
73612: LIST
73613: PUSH
73614: LD_INT 0
73616: PUSH
73617: LD_INT 2
73619: NEG
73620: PUSH
73621: EMPTY
73622: LIST
73623: LIST
73624: PUSH
73625: LD_INT 1
73627: PUSH
73628: LD_INT 1
73630: NEG
73631: PUSH
73632: EMPTY
73633: LIST
73634: LIST
73635: PUSH
73636: LD_INT 2
73638: PUSH
73639: LD_INT 0
73641: PUSH
73642: EMPTY
73643: LIST
73644: LIST
73645: PUSH
73646: LD_INT 2
73648: PUSH
73649: LD_INT 1
73651: PUSH
73652: EMPTY
73653: LIST
73654: LIST
73655: PUSH
73656: LD_INT 2
73658: PUSH
73659: LD_INT 2
73661: PUSH
73662: EMPTY
73663: LIST
73664: LIST
73665: PUSH
73666: LD_INT 1
73668: PUSH
73669: LD_INT 2
73671: PUSH
73672: EMPTY
73673: LIST
73674: LIST
73675: PUSH
73676: LD_INT 0
73678: PUSH
73679: LD_INT 2
73681: PUSH
73682: EMPTY
73683: LIST
73684: LIST
73685: PUSH
73686: LD_INT 1
73688: NEG
73689: PUSH
73690: LD_INT 1
73692: PUSH
73693: EMPTY
73694: LIST
73695: LIST
73696: PUSH
73697: LD_INT 2
73699: NEG
73700: PUSH
73701: LD_INT 0
73703: PUSH
73704: EMPTY
73705: LIST
73706: LIST
73707: PUSH
73708: LD_INT 2
73710: NEG
73711: PUSH
73712: LD_INT 1
73714: NEG
73715: PUSH
73716: EMPTY
73717: LIST
73718: LIST
73719: PUSH
73720: LD_INT 2
73722: NEG
73723: PUSH
73724: LD_INT 2
73726: NEG
73727: PUSH
73728: EMPTY
73729: LIST
73730: LIST
73731: PUSH
73732: EMPTY
73733: LIST
73734: LIST
73735: LIST
73736: LIST
73737: LIST
73738: LIST
73739: LIST
73740: LIST
73741: LIST
73742: LIST
73743: LIST
73744: LIST
73745: LIST
73746: LIST
73747: LIST
73748: LIST
73749: LIST
73750: LIST
73751: LIST
73752: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73753: LD_ADDR_VAR 0 55
73757: PUSH
73758: LD_INT 0
73760: PUSH
73761: LD_INT 0
73763: PUSH
73764: EMPTY
73765: LIST
73766: LIST
73767: PUSH
73768: LD_INT 0
73770: PUSH
73771: LD_INT 1
73773: NEG
73774: PUSH
73775: EMPTY
73776: LIST
73777: LIST
73778: PUSH
73779: LD_INT 1
73781: PUSH
73782: LD_INT 0
73784: PUSH
73785: EMPTY
73786: LIST
73787: LIST
73788: PUSH
73789: LD_INT 1
73791: PUSH
73792: LD_INT 1
73794: PUSH
73795: EMPTY
73796: LIST
73797: LIST
73798: PUSH
73799: LD_INT 0
73801: PUSH
73802: LD_INT 1
73804: PUSH
73805: EMPTY
73806: LIST
73807: LIST
73808: PUSH
73809: LD_INT 1
73811: NEG
73812: PUSH
73813: LD_INT 0
73815: PUSH
73816: EMPTY
73817: LIST
73818: LIST
73819: PUSH
73820: LD_INT 1
73822: NEG
73823: PUSH
73824: LD_INT 1
73826: NEG
73827: PUSH
73828: EMPTY
73829: LIST
73830: LIST
73831: PUSH
73832: LD_INT 1
73834: NEG
73835: PUSH
73836: LD_INT 2
73838: NEG
73839: PUSH
73840: EMPTY
73841: LIST
73842: LIST
73843: PUSH
73844: LD_INT 0
73846: PUSH
73847: LD_INT 2
73849: NEG
73850: PUSH
73851: EMPTY
73852: LIST
73853: LIST
73854: PUSH
73855: LD_INT 1
73857: PUSH
73858: LD_INT 1
73860: NEG
73861: PUSH
73862: EMPTY
73863: LIST
73864: LIST
73865: PUSH
73866: LD_INT 2
73868: PUSH
73869: LD_INT 0
73871: PUSH
73872: EMPTY
73873: LIST
73874: LIST
73875: PUSH
73876: LD_INT 2
73878: PUSH
73879: LD_INT 1
73881: PUSH
73882: EMPTY
73883: LIST
73884: LIST
73885: PUSH
73886: LD_INT 2
73888: PUSH
73889: LD_INT 2
73891: PUSH
73892: EMPTY
73893: LIST
73894: LIST
73895: PUSH
73896: LD_INT 1
73898: PUSH
73899: LD_INT 2
73901: PUSH
73902: EMPTY
73903: LIST
73904: LIST
73905: PUSH
73906: LD_INT 0
73908: PUSH
73909: LD_INT 2
73911: PUSH
73912: EMPTY
73913: LIST
73914: LIST
73915: PUSH
73916: LD_INT 1
73918: NEG
73919: PUSH
73920: LD_INT 1
73922: PUSH
73923: EMPTY
73924: LIST
73925: LIST
73926: PUSH
73927: LD_INT 2
73929: NEG
73930: PUSH
73931: LD_INT 0
73933: PUSH
73934: EMPTY
73935: LIST
73936: LIST
73937: PUSH
73938: LD_INT 2
73940: NEG
73941: PUSH
73942: LD_INT 1
73944: NEG
73945: PUSH
73946: EMPTY
73947: LIST
73948: LIST
73949: PUSH
73950: LD_INT 2
73952: NEG
73953: PUSH
73954: LD_INT 2
73956: NEG
73957: PUSH
73958: EMPTY
73959: LIST
73960: LIST
73961: PUSH
73962: EMPTY
73963: LIST
73964: LIST
73965: LIST
73966: LIST
73967: LIST
73968: LIST
73969: LIST
73970: LIST
73971: LIST
73972: LIST
73973: LIST
73974: LIST
73975: LIST
73976: LIST
73977: LIST
73978: LIST
73979: LIST
73980: LIST
73981: LIST
73982: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73983: LD_ADDR_VAR 0 56
73987: PUSH
73988: LD_INT 0
73990: PUSH
73991: LD_INT 0
73993: PUSH
73994: EMPTY
73995: LIST
73996: LIST
73997: PUSH
73998: LD_INT 0
74000: PUSH
74001: LD_INT 1
74003: NEG
74004: PUSH
74005: EMPTY
74006: LIST
74007: LIST
74008: PUSH
74009: LD_INT 1
74011: PUSH
74012: LD_INT 0
74014: PUSH
74015: EMPTY
74016: LIST
74017: LIST
74018: PUSH
74019: LD_INT 1
74021: PUSH
74022: LD_INT 1
74024: PUSH
74025: EMPTY
74026: LIST
74027: LIST
74028: PUSH
74029: LD_INT 0
74031: PUSH
74032: LD_INT 1
74034: PUSH
74035: EMPTY
74036: LIST
74037: LIST
74038: PUSH
74039: LD_INT 1
74041: NEG
74042: PUSH
74043: LD_INT 0
74045: PUSH
74046: EMPTY
74047: LIST
74048: LIST
74049: PUSH
74050: LD_INT 1
74052: NEG
74053: PUSH
74054: LD_INT 1
74056: NEG
74057: PUSH
74058: EMPTY
74059: LIST
74060: LIST
74061: PUSH
74062: LD_INT 1
74064: NEG
74065: PUSH
74066: LD_INT 2
74068: NEG
74069: PUSH
74070: EMPTY
74071: LIST
74072: LIST
74073: PUSH
74074: LD_INT 0
74076: PUSH
74077: LD_INT 2
74079: NEG
74080: PUSH
74081: EMPTY
74082: LIST
74083: LIST
74084: PUSH
74085: LD_INT 1
74087: PUSH
74088: LD_INT 1
74090: NEG
74091: PUSH
74092: EMPTY
74093: LIST
74094: LIST
74095: PUSH
74096: LD_INT 2
74098: PUSH
74099: LD_INT 0
74101: PUSH
74102: EMPTY
74103: LIST
74104: LIST
74105: PUSH
74106: LD_INT 2
74108: PUSH
74109: LD_INT 1
74111: PUSH
74112: EMPTY
74113: LIST
74114: LIST
74115: PUSH
74116: LD_INT 2
74118: PUSH
74119: LD_INT 2
74121: PUSH
74122: EMPTY
74123: LIST
74124: LIST
74125: PUSH
74126: LD_INT 1
74128: PUSH
74129: LD_INT 2
74131: PUSH
74132: EMPTY
74133: LIST
74134: LIST
74135: PUSH
74136: LD_INT 0
74138: PUSH
74139: LD_INT 2
74141: PUSH
74142: EMPTY
74143: LIST
74144: LIST
74145: PUSH
74146: LD_INT 1
74148: NEG
74149: PUSH
74150: LD_INT 1
74152: PUSH
74153: EMPTY
74154: LIST
74155: LIST
74156: PUSH
74157: LD_INT 2
74159: NEG
74160: PUSH
74161: LD_INT 0
74163: PUSH
74164: EMPTY
74165: LIST
74166: LIST
74167: PUSH
74168: LD_INT 2
74170: NEG
74171: PUSH
74172: LD_INT 1
74174: NEG
74175: PUSH
74176: EMPTY
74177: LIST
74178: LIST
74179: PUSH
74180: LD_INT 2
74182: NEG
74183: PUSH
74184: LD_INT 2
74186: NEG
74187: PUSH
74188: EMPTY
74189: LIST
74190: LIST
74191: PUSH
74192: EMPTY
74193: LIST
74194: LIST
74195: LIST
74196: LIST
74197: LIST
74198: LIST
74199: LIST
74200: LIST
74201: LIST
74202: LIST
74203: LIST
74204: LIST
74205: LIST
74206: LIST
74207: LIST
74208: LIST
74209: LIST
74210: LIST
74211: LIST
74212: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74213: LD_ADDR_VAR 0 57
74217: PUSH
74218: LD_INT 0
74220: PUSH
74221: LD_INT 0
74223: PUSH
74224: EMPTY
74225: LIST
74226: LIST
74227: PUSH
74228: LD_INT 0
74230: PUSH
74231: LD_INT 1
74233: NEG
74234: PUSH
74235: EMPTY
74236: LIST
74237: LIST
74238: PUSH
74239: LD_INT 1
74241: PUSH
74242: LD_INT 0
74244: PUSH
74245: EMPTY
74246: LIST
74247: LIST
74248: PUSH
74249: LD_INT 1
74251: PUSH
74252: LD_INT 1
74254: PUSH
74255: EMPTY
74256: LIST
74257: LIST
74258: PUSH
74259: LD_INT 0
74261: PUSH
74262: LD_INT 1
74264: PUSH
74265: EMPTY
74266: LIST
74267: LIST
74268: PUSH
74269: LD_INT 1
74271: NEG
74272: PUSH
74273: LD_INT 0
74275: PUSH
74276: EMPTY
74277: LIST
74278: LIST
74279: PUSH
74280: LD_INT 1
74282: NEG
74283: PUSH
74284: LD_INT 1
74286: NEG
74287: PUSH
74288: EMPTY
74289: LIST
74290: LIST
74291: PUSH
74292: LD_INT 1
74294: NEG
74295: PUSH
74296: LD_INT 2
74298: NEG
74299: PUSH
74300: EMPTY
74301: LIST
74302: LIST
74303: PUSH
74304: LD_INT 0
74306: PUSH
74307: LD_INT 2
74309: NEG
74310: PUSH
74311: EMPTY
74312: LIST
74313: LIST
74314: PUSH
74315: LD_INT 1
74317: PUSH
74318: LD_INT 1
74320: NEG
74321: PUSH
74322: EMPTY
74323: LIST
74324: LIST
74325: PUSH
74326: LD_INT 2
74328: PUSH
74329: LD_INT 0
74331: PUSH
74332: EMPTY
74333: LIST
74334: LIST
74335: PUSH
74336: LD_INT 2
74338: PUSH
74339: LD_INT 1
74341: PUSH
74342: EMPTY
74343: LIST
74344: LIST
74345: PUSH
74346: LD_INT 2
74348: PUSH
74349: LD_INT 2
74351: PUSH
74352: EMPTY
74353: LIST
74354: LIST
74355: PUSH
74356: LD_INT 1
74358: PUSH
74359: LD_INT 2
74361: PUSH
74362: EMPTY
74363: LIST
74364: LIST
74365: PUSH
74366: LD_INT 0
74368: PUSH
74369: LD_INT 2
74371: PUSH
74372: EMPTY
74373: LIST
74374: LIST
74375: PUSH
74376: LD_INT 1
74378: NEG
74379: PUSH
74380: LD_INT 1
74382: PUSH
74383: EMPTY
74384: LIST
74385: LIST
74386: PUSH
74387: LD_INT 2
74389: NEG
74390: PUSH
74391: LD_INT 0
74393: PUSH
74394: EMPTY
74395: LIST
74396: LIST
74397: PUSH
74398: LD_INT 2
74400: NEG
74401: PUSH
74402: LD_INT 1
74404: NEG
74405: PUSH
74406: EMPTY
74407: LIST
74408: LIST
74409: PUSH
74410: LD_INT 2
74412: NEG
74413: PUSH
74414: LD_INT 2
74416: NEG
74417: PUSH
74418: EMPTY
74419: LIST
74420: LIST
74421: PUSH
74422: EMPTY
74423: LIST
74424: LIST
74425: LIST
74426: LIST
74427: LIST
74428: LIST
74429: LIST
74430: LIST
74431: LIST
74432: LIST
74433: LIST
74434: LIST
74435: LIST
74436: LIST
74437: LIST
74438: LIST
74439: LIST
74440: LIST
74441: LIST
74442: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74443: LD_ADDR_VAR 0 58
74447: PUSH
74448: LD_INT 0
74450: PUSH
74451: LD_INT 0
74453: PUSH
74454: EMPTY
74455: LIST
74456: LIST
74457: PUSH
74458: LD_INT 0
74460: PUSH
74461: LD_INT 1
74463: NEG
74464: PUSH
74465: EMPTY
74466: LIST
74467: LIST
74468: PUSH
74469: LD_INT 1
74471: PUSH
74472: LD_INT 0
74474: PUSH
74475: EMPTY
74476: LIST
74477: LIST
74478: PUSH
74479: LD_INT 1
74481: PUSH
74482: LD_INT 1
74484: PUSH
74485: EMPTY
74486: LIST
74487: LIST
74488: PUSH
74489: LD_INT 0
74491: PUSH
74492: LD_INT 1
74494: PUSH
74495: EMPTY
74496: LIST
74497: LIST
74498: PUSH
74499: LD_INT 1
74501: NEG
74502: PUSH
74503: LD_INT 0
74505: PUSH
74506: EMPTY
74507: LIST
74508: LIST
74509: PUSH
74510: LD_INT 1
74512: NEG
74513: PUSH
74514: LD_INT 1
74516: NEG
74517: PUSH
74518: EMPTY
74519: LIST
74520: LIST
74521: PUSH
74522: LD_INT 1
74524: NEG
74525: PUSH
74526: LD_INT 2
74528: NEG
74529: PUSH
74530: EMPTY
74531: LIST
74532: LIST
74533: PUSH
74534: LD_INT 0
74536: PUSH
74537: LD_INT 2
74539: NEG
74540: PUSH
74541: EMPTY
74542: LIST
74543: LIST
74544: PUSH
74545: LD_INT 1
74547: PUSH
74548: LD_INT 1
74550: NEG
74551: PUSH
74552: EMPTY
74553: LIST
74554: LIST
74555: PUSH
74556: LD_INT 2
74558: PUSH
74559: LD_INT 0
74561: PUSH
74562: EMPTY
74563: LIST
74564: LIST
74565: PUSH
74566: LD_INT 2
74568: PUSH
74569: LD_INT 1
74571: PUSH
74572: EMPTY
74573: LIST
74574: LIST
74575: PUSH
74576: LD_INT 2
74578: PUSH
74579: LD_INT 2
74581: PUSH
74582: EMPTY
74583: LIST
74584: LIST
74585: PUSH
74586: LD_INT 1
74588: PUSH
74589: LD_INT 2
74591: PUSH
74592: EMPTY
74593: LIST
74594: LIST
74595: PUSH
74596: LD_INT 0
74598: PUSH
74599: LD_INT 2
74601: PUSH
74602: EMPTY
74603: LIST
74604: LIST
74605: PUSH
74606: LD_INT 1
74608: NEG
74609: PUSH
74610: LD_INT 1
74612: PUSH
74613: EMPTY
74614: LIST
74615: LIST
74616: PUSH
74617: LD_INT 2
74619: NEG
74620: PUSH
74621: LD_INT 0
74623: PUSH
74624: EMPTY
74625: LIST
74626: LIST
74627: PUSH
74628: LD_INT 2
74630: NEG
74631: PUSH
74632: LD_INT 1
74634: NEG
74635: PUSH
74636: EMPTY
74637: LIST
74638: LIST
74639: PUSH
74640: LD_INT 2
74642: NEG
74643: PUSH
74644: LD_INT 2
74646: NEG
74647: PUSH
74648: EMPTY
74649: LIST
74650: LIST
74651: PUSH
74652: EMPTY
74653: LIST
74654: LIST
74655: LIST
74656: LIST
74657: LIST
74658: LIST
74659: LIST
74660: LIST
74661: LIST
74662: LIST
74663: LIST
74664: LIST
74665: LIST
74666: LIST
74667: LIST
74668: LIST
74669: LIST
74670: LIST
74671: LIST
74672: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74673: LD_ADDR_VAR 0 59
74677: PUSH
74678: LD_INT 0
74680: PUSH
74681: LD_INT 0
74683: PUSH
74684: EMPTY
74685: LIST
74686: LIST
74687: PUSH
74688: LD_INT 0
74690: PUSH
74691: LD_INT 1
74693: NEG
74694: PUSH
74695: EMPTY
74696: LIST
74697: LIST
74698: PUSH
74699: LD_INT 1
74701: PUSH
74702: LD_INT 0
74704: PUSH
74705: EMPTY
74706: LIST
74707: LIST
74708: PUSH
74709: LD_INT 1
74711: PUSH
74712: LD_INT 1
74714: PUSH
74715: EMPTY
74716: LIST
74717: LIST
74718: PUSH
74719: LD_INT 0
74721: PUSH
74722: LD_INT 1
74724: PUSH
74725: EMPTY
74726: LIST
74727: LIST
74728: PUSH
74729: LD_INT 1
74731: NEG
74732: PUSH
74733: LD_INT 0
74735: PUSH
74736: EMPTY
74737: LIST
74738: LIST
74739: PUSH
74740: LD_INT 1
74742: NEG
74743: PUSH
74744: LD_INT 1
74746: NEG
74747: PUSH
74748: EMPTY
74749: LIST
74750: LIST
74751: PUSH
74752: EMPTY
74753: LIST
74754: LIST
74755: LIST
74756: LIST
74757: LIST
74758: LIST
74759: LIST
74760: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74761: LD_ADDR_VAR 0 60
74765: PUSH
74766: LD_INT 0
74768: PUSH
74769: LD_INT 0
74771: PUSH
74772: EMPTY
74773: LIST
74774: LIST
74775: PUSH
74776: LD_INT 0
74778: PUSH
74779: LD_INT 1
74781: NEG
74782: PUSH
74783: EMPTY
74784: LIST
74785: LIST
74786: PUSH
74787: LD_INT 1
74789: PUSH
74790: LD_INT 0
74792: PUSH
74793: EMPTY
74794: LIST
74795: LIST
74796: PUSH
74797: LD_INT 1
74799: PUSH
74800: LD_INT 1
74802: PUSH
74803: EMPTY
74804: LIST
74805: LIST
74806: PUSH
74807: LD_INT 0
74809: PUSH
74810: LD_INT 1
74812: PUSH
74813: EMPTY
74814: LIST
74815: LIST
74816: PUSH
74817: LD_INT 1
74819: NEG
74820: PUSH
74821: LD_INT 0
74823: PUSH
74824: EMPTY
74825: LIST
74826: LIST
74827: PUSH
74828: LD_INT 1
74830: NEG
74831: PUSH
74832: LD_INT 1
74834: NEG
74835: PUSH
74836: EMPTY
74837: LIST
74838: LIST
74839: PUSH
74840: EMPTY
74841: LIST
74842: LIST
74843: LIST
74844: LIST
74845: LIST
74846: LIST
74847: LIST
74848: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74849: LD_ADDR_VAR 0 61
74853: PUSH
74854: LD_INT 0
74856: PUSH
74857: LD_INT 0
74859: PUSH
74860: EMPTY
74861: LIST
74862: LIST
74863: PUSH
74864: LD_INT 0
74866: PUSH
74867: LD_INT 1
74869: NEG
74870: PUSH
74871: EMPTY
74872: LIST
74873: LIST
74874: PUSH
74875: LD_INT 1
74877: PUSH
74878: LD_INT 0
74880: PUSH
74881: EMPTY
74882: LIST
74883: LIST
74884: PUSH
74885: LD_INT 1
74887: PUSH
74888: LD_INT 1
74890: PUSH
74891: EMPTY
74892: LIST
74893: LIST
74894: PUSH
74895: LD_INT 0
74897: PUSH
74898: LD_INT 1
74900: PUSH
74901: EMPTY
74902: LIST
74903: LIST
74904: PUSH
74905: LD_INT 1
74907: NEG
74908: PUSH
74909: LD_INT 0
74911: PUSH
74912: EMPTY
74913: LIST
74914: LIST
74915: PUSH
74916: LD_INT 1
74918: NEG
74919: PUSH
74920: LD_INT 1
74922: NEG
74923: PUSH
74924: EMPTY
74925: LIST
74926: LIST
74927: PUSH
74928: EMPTY
74929: LIST
74930: LIST
74931: LIST
74932: LIST
74933: LIST
74934: LIST
74935: LIST
74936: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74937: LD_ADDR_VAR 0 62
74941: PUSH
74942: LD_INT 0
74944: PUSH
74945: LD_INT 0
74947: PUSH
74948: EMPTY
74949: LIST
74950: LIST
74951: PUSH
74952: LD_INT 0
74954: PUSH
74955: LD_INT 1
74957: NEG
74958: PUSH
74959: EMPTY
74960: LIST
74961: LIST
74962: PUSH
74963: LD_INT 1
74965: PUSH
74966: LD_INT 0
74968: PUSH
74969: EMPTY
74970: LIST
74971: LIST
74972: PUSH
74973: LD_INT 1
74975: PUSH
74976: LD_INT 1
74978: PUSH
74979: EMPTY
74980: LIST
74981: LIST
74982: PUSH
74983: LD_INT 0
74985: PUSH
74986: LD_INT 1
74988: PUSH
74989: EMPTY
74990: LIST
74991: LIST
74992: PUSH
74993: LD_INT 1
74995: NEG
74996: PUSH
74997: LD_INT 0
74999: PUSH
75000: EMPTY
75001: LIST
75002: LIST
75003: PUSH
75004: LD_INT 1
75006: NEG
75007: PUSH
75008: LD_INT 1
75010: NEG
75011: PUSH
75012: EMPTY
75013: LIST
75014: LIST
75015: PUSH
75016: EMPTY
75017: LIST
75018: LIST
75019: LIST
75020: LIST
75021: LIST
75022: LIST
75023: LIST
75024: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75025: LD_ADDR_VAR 0 63
75029: PUSH
75030: LD_INT 0
75032: PUSH
75033: LD_INT 0
75035: PUSH
75036: EMPTY
75037: LIST
75038: LIST
75039: PUSH
75040: LD_INT 0
75042: PUSH
75043: LD_INT 1
75045: NEG
75046: PUSH
75047: EMPTY
75048: LIST
75049: LIST
75050: PUSH
75051: LD_INT 1
75053: PUSH
75054: LD_INT 0
75056: PUSH
75057: EMPTY
75058: LIST
75059: LIST
75060: PUSH
75061: LD_INT 1
75063: PUSH
75064: LD_INT 1
75066: PUSH
75067: EMPTY
75068: LIST
75069: LIST
75070: PUSH
75071: LD_INT 0
75073: PUSH
75074: LD_INT 1
75076: PUSH
75077: EMPTY
75078: LIST
75079: LIST
75080: PUSH
75081: LD_INT 1
75083: NEG
75084: PUSH
75085: LD_INT 0
75087: PUSH
75088: EMPTY
75089: LIST
75090: LIST
75091: PUSH
75092: LD_INT 1
75094: NEG
75095: PUSH
75096: LD_INT 1
75098: NEG
75099: PUSH
75100: EMPTY
75101: LIST
75102: LIST
75103: PUSH
75104: EMPTY
75105: LIST
75106: LIST
75107: LIST
75108: LIST
75109: LIST
75110: LIST
75111: LIST
75112: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75113: LD_ADDR_VAR 0 64
75117: PUSH
75118: LD_INT 0
75120: PUSH
75121: LD_INT 0
75123: PUSH
75124: EMPTY
75125: LIST
75126: LIST
75127: PUSH
75128: LD_INT 0
75130: PUSH
75131: LD_INT 1
75133: NEG
75134: PUSH
75135: EMPTY
75136: LIST
75137: LIST
75138: PUSH
75139: LD_INT 1
75141: PUSH
75142: LD_INT 0
75144: PUSH
75145: EMPTY
75146: LIST
75147: LIST
75148: PUSH
75149: LD_INT 1
75151: PUSH
75152: LD_INT 1
75154: PUSH
75155: EMPTY
75156: LIST
75157: LIST
75158: PUSH
75159: LD_INT 0
75161: PUSH
75162: LD_INT 1
75164: PUSH
75165: EMPTY
75166: LIST
75167: LIST
75168: PUSH
75169: LD_INT 1
75171: NEG
75172: PUSH
75173: LD_INT 0
75175: PUSH
75176: EMPTY
75177: LIST
75178: LIST
75179: PUSH
75180: LD_INT 1
75182: NEG
75183: PUSH
75184: LD_INT 1
75186: NEG
75187: PUSH
75188: EMPTY
75189: LIST
75190: LIST
75191: PUSH
75192: EMPTY
75193: LIST
75194: LIST
75195: LIST
75196: LIST
75197: LIST
75198: LIST
75199: LIST
75200: ST_TO_ADDR
// end ; 1 :
75201: GO 81098
75203: LD_INT 1
75205: DOUBLE
75206: EQUAL
75207: IFTRUE 75211
75209: GO 77834
75211: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
75212: LD_ADDR_VAR 0 11
75216: PUSH
75217: LD_INT 1
75219: NEG
75220: PUSH
75221: LD_INT 3
75223: NEG
75224: PUSH
75225: EMPTY
75226: LIST
75227: LIST
75228: PUSH
75229: LD_INT 0
75231: PUSH
75232: LD_INT 3
75234: NEG
75235: PUSH
75236: EMPTY
75237: LIST
75238: LIST
75239: PUSH
75240: LD_INT 1
75242: PUSH
75243: LD_INT 2
75245: NEG
75246: PUSH
75247: EMPTY
75248: LIST
75249: LIST
75250: PUSH
75251: EMPTY
75252: LIST
75253: LIST
75254: LIST
75255: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
75256: LD_ADDR_VAR 0 12
75260: PUSH
75261: LD_INT 2
75263: PUSH
75264: LD_INT 1
75266: NEG
75267: PUSH
75268: EMPTY
75269: LIST
75270: LIST
75271: PUSH
75272: LD_INT 3
75274: PUSH
75275: LD_INT 0
75277: PUSH
75278: EMPTY
75279: LIST
75280: LIST
75281: PUSH
75282: LD_INT 3
75284: PUSH
75285: LD_INT 1
75287: PUSH
75288: EMPTY
75289: LIST
75290: LIST
75291: PUSH
75292: EMPTY
75293: LIST
75294: LIST
75295: LIST
75296: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
75297: LD_ADDR_VAR 0 13
75301: PUSH
75302: LD_INT 3
75304: PUSH
75305: LD_INT 2
75307: PUSH
75308: EMPTY
75309: LIST
75310: LIST
75311: PUSH
75312: LD_INT 3
75314: PUSH
75315: LD_INT 3
75317: PUSH
75318: EMPTY
75319: LIST
75320: LIST
75321: PUSH
75322: LD_INT 2
75324: PUSH
75325: LD_INT 3
75327: PUSH
75328: EMPTY
75329: LIST
75330: LIST
75331: PUSH
75332: EMPTY
75333: LIST
75334: LIST
75335: LIST
75336: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
75337: LD_ADDR_VAR 0 14
75341: PUSH
75342: LD_INT 1
75344: PUSH
75345: LD_INT 3
75347: PUSH
75348: EMPTY
75349: LIST
75350: LIST
75351: PUSH
75352: LD_INT 0
75354: PUSH
75355: LD_INT 3
75357: PUSH
75358: EMPTY
75359: LIST
75360: LIST
75361: PUSH
75362: LD_INT 1
75364: NEG
75365: PUSH
75366: LD_INT 2
75368: PUSH
75369: EMPTY
75370: LIST
75371: LIST
75372: PUSH
75373: EMPTY
75374: LIST
75375: LIST
75376: LIST
75377: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
75378: LD_ADDR_VAR 0 15
75382: PUSH
75383: LD_INT 2
75385: NEG
75386: PUSH
75387: LD_INT 1
75389: PUSH
75390: EMPTY
75391: LIST
75392: LIST
75393: PUSH
75394: LD_INT 3
75396: NEG
75397: PUSH
75398: LD_INT 0
75400: PUSH
75401: EMPTY
75402: LIST
75403: LIST
75404: PUSH
75405: LD_INT 3
75407: NEG
75408: PUSH
75409: LD_INT 1
75411: NEG
75412: PUSH
75413: EMPTY
75414: LIST
75415: LIST
75416: PUSH
75417: EMPTY
75418: LIST
75419: LIST
75420: LIST
75421: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75422: LD_ADDR_VAR 0 16
75426: PUSH
75427: LD_INT 2
75429: NEG
75430: PUSH
75431: LD_INT 3
75433: NEG
75434: PUSH
75435: EMPTY
75436: LIST
75437: LIST
75438: PUSH
75439: LD_INT 3
75441: NEG
75442: PUSH
75443: LD_INT 2
75445: NEG
75446: PUSH
75447: EMPTY
75448: LIST
75449: LIST
75450: PUSH
75451: LD_INT 3
75453: NEG
75454: PUSH
75455: LD_INT 3
75457: NEG
75458: PUSH
75459: EMPTY
75460: LIST
75461: LIST
75462: PUSH
75463: EMPTY
75464: LIST
75465: LIST
75466: LIST
75467: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
75468: LD_ADDR_VAR 0 17
75472: PUSH
75473: LD_INT 1
75475: NEG
75476: PUSH
75477: LD_INT 3
75479: NEG
75480: PUSH
75481: EMPTY
75482: LIST
75483: LIST
75484: PUSH
75485: LD_INT 0
75487: PUSH
75488: LD_INT 3
75490: NEG
75491: PUSH
75492: EMPTY
75493: LIST
75494: LIST
75495: PUSH
75496: LD_INT 1
75498: PUSH
75499: LD_INT 2
75501: NEG
75502: PUSH
75503: EMPTY
75504: LIST
75505: LIST
75506: PUSH
75507: EMPTY
75508: LIST
75509: LIST
75510: LIST
75511: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
75512: LD_ADDR_VAR 0 18
75516: PUSH
75517: LD_INT 2
75519: PUSH
75520: LD_INT 1
75522: NEG
75523: PUSH
75524: EMPTY
75525: LIST
75526: LIST
75527: PUSH
75528: LD_INT 3
75530: PUSH
75531: LD_INT 0
75533: PUSH
75534: EMPTY
75535: LIST
75536: LIST
75537: PUSH
75538: LD_INT 3
75540: PUSH
75541: LD_INT 1
75543: PUSH
75544: EMPTY
75545: LIST
75546: LIST
75547: PUSH
75548: EMPTY
75549: LIST
75550: LIST
75551: LIST
75552: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
75553: LD_ADDR_VAR 0 19
75557: PUSH
75558: LD_INT 3
75560: PUSH
75561: LD_INT 2
75563: PUSH
75564: EMPTY
75565: LIST
75566: LIST
75567: PUSH
75568: LD_INT 3
75570: PUSH
75571: LD_INT 3
75573: PUSH
75574: EMPTY
75575: LIST
75576: LIST
75577: PUSH
75578: LD_INT 2
75580: PUSH
75581: LD_INT 3
75583: PUSH
75584: EMPTY
75585: LIST
75586: LIST
75587: PUSH
75588: EMPTY
75589: LIST
75590: LIST
75591: LIST
75592: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
75593: LD_ADDR_VAR 0 20
75597: PUSH
75598: LD_INT 1
75600: PUSH
75601: LD_INT 3
75603: PUSH
75604: EMPTY
75605: LIST
75606: LIST
75607: PUSH
75608: LD_INT 0
75610: PUSH
75611: LD_INT 3
75613: PUSH
75614: EMPTY
75615: LIST
75616: LIST
75617: PUSH
75618: LD_INT 1
75620: NEG
75621: PUSH
75622: LD_INT 2
75624: PUSH
75625: EMPTY
75626: LIST
75627: LIST
75628: PUSH
75629: EMPTY
75630: LIST
75631: LIST
75632: LIST
75633: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
75634: LD_ADDR_VAR 0 21
75638: PUSH
75639: LD_INT 2
75641: NEG
75642: PUSH
75643: LD_INT 1
75645: PUSH
75646: EMPTY
75647: LIST
75648: LIST
75649: PUSH
75650: LD_INT 3
75652: NEG
75653: PUSH
75654: LD_INT 0
75656: PUSH
75657: EMPTY
75658: LIST
75659: LIST
75660: PUSH
75661: LD_INT 3
75663: NEG
75664: PUSH
75665: LD_INT 1
75667: NEG
75668: PUSH
75669: EMPTY
75670: LIST
75671: LIST
75672: PUSH
75673: EMPTY
75674: LIST
75675: LIST
75676: LIST
75677: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75678: LD_ADDR_VAR 0 22
75682: PUSH
75683: LD_INT 2
75685: NEG
75686: PUSH
75687: LD_INT 3
75689: NEG
75690: PUSH
75691: EMPTY
75692: LIST
75693: LIST
75694: PUSH
75695: LD_INT 3
75697: NEG
75698: PUSH
75699: LD_INT 2
75701: NEG
75702: PUSH
75703: EMPTY
75704: LIST
75705: LIST
75706: PUSH
75707: LD_INT 3
75709: NEG
75710: PUSH
75711: LD_INT 3
75713: NEG
75714: PUSH
75715: EMPTY
75716: LIST
75717: LIST
75718: PUSH
75719: EMPTY
75720: LIST
75721: LIST
75722: LIST
75723: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
75724: LD_ADDR_VAR 0 23
75728: PUSH
75729: LD_INT 0
75731: PUSH
75732: LD_INT 3
75734: NEG
75735: PUSH
75736: EMPTY
75737: LIST
75738: LIST
75739: PUSH
75740: LD_INT 1
75742: NEG
75743: PUSH
75744: LD_INT 4
75746: NEG
75747: PUSH
75748: EMPTY
75749: LIST
75750: LIST
75751: PUSH
75752: LD_INT 1
75754: PUSH
75755: LD_INT 3
75757: NEG
75758: PUSH
75759: EMPTY
75760: LIST
75761: LIST
75762: PUSH
75763: EMPTY
75764: LIST
75765: LIST
75766: LIST
75767: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
75768: LD_ADDR_VAR 0 24
75772: PUSH
75773: LD_INT 3
75775: PUSH
75776: LD_INT 0
75778: PUSH
75779: EMPTY
75780: LIST
75781: LIST
75782: PUSH
75783: LD_INT 3
75785: PUSH
75786: LD_INT 1
75788: NEG
75789: PUSH
75790: EMPTY
75791: LIST
75792: LIST
75793: PUSH
75794: LD_INT 4
75796: PUSH
75797: LD_INT 1
75799: PUSH
75800: EMPTY
75801: LIST
75802: LIST
75803: PUSH
75804: EMPTY
75805: LIST
75806: LIST
75807: LIST
75808: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
75809: LD_ADDR_VAR 0 25
75813: PUSH
75814: LD_INT 3
75816: PUSH
75817: LD_INT 3
75819: PUSH
75820: EMPTY
75821: LIST
75822: LIST
75823: PUSH
75824: LD_INT 4
75826: PUSH
75827: LD_INT 3
75829: PUSH
75830: EMPTY
75831: LIST
75832: LIST
75833: PUSH
75834: LD_INT 3
75836: PUSH
75837: LD_INT 4
75839: PUSH
75840: EMPTY
75841: LIST
75842: LIST
75843: PUSH
75844: EMPTY
75845: LIST
75846: LIST
75847: LIST
75848: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
75849: LD_ADDR_VAR 0 26
75853: PUSH
75854: LD_INT 0
75856: PUSH
75857: LD_INT 3
75859: PUSH
75860: EMPTY
75861: LIST
75862: LIST
75863: PUSH
75864: LD_INT 1
75866: PUSH
75867: LD_INT 4
75869: PUSH
75870: EMPTY
75871: LIST
75872: LIST
75873: PUSH
75874: LD_INT 1
75876: NEG
75877: PUSH
75878: LD_INT 3
75880: PUSH
75881: EMPTY
75882: LIST
75883: LIST
75884: PUSH
75885: EMPTY
75886: LIST
75887: LIST
75888: LIST
75889: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
75890: LD_ADDR_VAR 0 27
75894: PUSH
75895: LD_INT 3
75897: NEG
75898: PUSH
75899: LD_INT 0
75901: PUSH
75902: EMPTY
75903: LIST
75904: LIST
75905: PUSH
75906: LD_INT 3
75908: NEG
75909: PUSH
75910: LD_INT 1
75912: PUSH
75913: EMPTY
75914: LIST
75915: LIST
75916: PUSH
75917: LD_INT 4
75919: NEG
75920: PUSH
75921: LD_INT 1
75923: NEG
75924: PUSH
75925: EMPTY
75926: LIST
75927: LIST
75928: PUSH
75929: EMPTY
75930: LIST
75931: LIST
75932: LIST
75933: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
75934: LD_ADDR_VAR 0 28
75938: PUSH
75939: LD_INT 3
75941: NEG
75942: PUSH
75943: LD_INT 3
75945: NEG
75946: PUSH
75947: EMPTY
75948: LIST
75949: LIST
75950: PUSH
75951: LD_INT 3
75953: NEG
75954: PUSH
75955: LD_INT 4
75957: NEG
75958: PUSH
75959: EMPTY
75960: LIST
75961: LIST
75962: PUSH
75963: LD_INT 4
75965: NEG
75966: PUSH
75967: LD_INT 3
75969: NEG
75970: PUSH
75971: EMPTY
75972: LIST
75973: LIST
75974: PUSH
75975: EMPTY
75976: LIST
75977: LIST
75978: LIST
75979: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
75980: LD_ADDR_VAR 0 29
75984: PUSH
75985: LD_INT 1
75987: NEG
75988: PUSH
75989: LD_INT 3
75991: NEG
75992: PUSH
75993: EMPTY
75994: LIST
75995: LIST
75996: PUSH
75997: LD_INT 0
75999: PUSH
76000: LD_INT 3
76002: NEG
76003: PUSH
76004: EMPTY
76005: LIST
76006: LIST
76007: PUSH
76008: LD_INT 1
76010: PUSH
76011: LD_INT 2
76013: NEG
76014: PUSH
76015: EMPTY
76016: LIST
76017: LIST
76018: PUSH
76019: LD_INT 1
76021: NEG
76022: PUSH
76023: LD_INT 4
76025: NEG
76026: PUSH
76027: EMPTY
76028: LIST
76029: LIST
76030: PUSH
76031: LD_INT 0
76033: PUSH
76034: LD_INT 4
76036: NEG
76037: PUSH
76038: EMPTY
76039: LIST
76040: LIST
76041: PUSH
76042: LD_INT 1
76044: PUSH
76045: LD_INT 3
76047: NEG
76048: PUSH
76049: EMPTY
76050: LIST
76051: LIST
76052: PUSH
76053: LD_INT 1
76055: NEG
76056: PUSH
76057: LD_INT 5
76059: NEG
76060: PUSH
76061: EMPTY
76062: LIST
76063: LIST
76064: PUSH
76065: LD_INT 0
76067: PUSH
76068: LD_INT 5
76070: NEG
76071: PUSH
76072: EMPTY
76073: LIST
76074: LIST
76075: PUSH
76076: LD_INT 1
76078: PUSH
76079: LD_INT 4
76081: NEG
76082: PUSH
76083: EMPTY
76084: LIST
76085: LIST
76086: PUSH
76087: LD_INT 1
76089: NEG
76090: PUSH
76091: LD_INT 6
76093: NEG
76094: PUSH
76095: EMPTY
76096: LIST
76097: LIST
76098: PUSH
76099: LD_INT 0
76101: PUSH
76102: LD_INT 6
76104: NEG
76105: PUSH
76106: EMPTY
76107: LIST
76108: LIST
76109: PUSH
76110: LD_INT 1
76112: PUSH
76113: LD_INT 5
76115: NEG
76116: PUSH
76117: EMPTY
76118: LIST
76119: LIST
76120: PUSH
76121: EMPTY
76122: LIST
76123: LIST
76124: LIST
76125: LIST
76126: LIST
76127: LIST
76128: LIST
76129: LIST
76130: LIST
76131: LIST
76132: LIST
76133: LIST
76134: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
76135: LD_ADDR_VAR 0 30
76139: PUSH
76140: LD_INT 2
76142: PUSH
76143: LD_INT 1
76145: NEG
76146: PUSH
76147: EMPTY
76148: LIST
76149: LIST
76150: PUSH
76151: LD_INT 3
76153: PUSH
76154: LD_INT 0
76156: PUSH
76157: EMPTY
76158: LIST
76159: LIST
76160: PUSH
76161: LD_INT 3
76163: PUSH
76164: LD_INT 1
76166: PUSH
76167: EMPTY
76168: LIST
76169: LIST
76170: PUSH
76171: LD_INT 3
76173: PUSH
76174: LD_INT 1
76176: NEG
76177: PUSH
76178: EMPTY
76179: LIST
76180: LIST
76181: PUSH
76182: LD_INT 4
76184: PUSH
76185: LD_INT 0
76187: PUSH
76188: EMPTY
76189: LIST
76190: LIST
76191: PUSH
76192: LD_INT 4
76194: PUSH
76195: LD_INT 1
76197: PUSH
76198: EMPTY
76199: LIST
76200: LIST
76201: PUSH
76202: LD_INT 4
76204: PUSH
76205: LD_INT 1
76207: NEG
76208: PUSH
76209: EMPTY
76210: LIST
76211: LIST
76212: PUSH
76213: LD_INT 5
76215: PUSH
76216: LD_INT 0
76218: PUSH
76219: EMPTY
76220: LIST
76221: LIST
76222: PUSH
76223: LD_INT 5
76225: PUSH
76226: LD_INT 1
76228: PUSH
76229: EMPTY
76230: LIST
76231: LIST
76232: PUSH
76233: LD_INT 5
76235: PUSH
76236: LD_INT 1
76238: NEG
76239: PUSH
76240: EMPTY
76241: LIST
76242: LIST
76243: PUSH
76244: LD_INT 6
76246: PUSH
76247: LD_INT 0
76249: PUSH
76250: EMPTY
76251: LIST
76252: LIST
76253: PUSH
76254: LD_INT 6
76256: PUSH
76257: LD_INT 1
76259: PUSH
76260: EMPTY
76261: LIST
76262: LIST
76263: PUSH
76264: EMPTY
76265: LIST
76266: LIST
76267: LIST
76268: LIST
76269: LIST
76270: LIST
76271: LIST
76272: LIST
76273: LIST
76274: LIST
76275: LIST
76276: LIST
76277: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
76278: LD_ADDR_VAR 0 31
76282: PUSH
76283: LD_INT 3
76285: PUSH
76286: LD_INT 2
76288: PUSH
76289: EMPTY
76290: LIST
76291: LIST
76292: PUSH
76293: LD_INT 3
76295: PUSH
76296: LD_INT 3
76298: PUSH
76299: EMPTY
76300: LIST
76301: LIST
76302: PUSH
76303: LD_INT 2
76305: PUSH
76306: LD_INT 3
76308: PUSH
76309: EMPTY
76310: LIST
76311: LIST
76312: PUSH
76313: LD_INT 4
76315: PUSH
76316: LD_INT 3
76318: PUSH
76319: EMPTY
76320: LIST
76321: LIST
76322: PUSH
76323: LD_INT 4
76325: PUSH
76326: LD_INT 4
76328: PUSH
76329: EMPTY
76330: LIST
76331: LIST
76332: PUSH
76333: LD_INT 3
76335: PUSH
76336: LD_INT 4
76338: PUSH
76339: EMPTY
76340: LIST
76341: LIST
76342: PUSH
76343: LD_INT 5
76345: PUSH
76346: LD_INT 4
76348: PUSH
76349: EMPTY
76350: LIST
76351: LIST
76352: PUSH
76353: LD_INT 5
76355: PUSH
76356: LD_INT 5
76358: PUSH
76359: EMPTY
76360: LIST
76361: LIST
76362: PUSH
76363: LD_INT 4
76365: PUSH
76366: LD_INT 5
76368: PUSH
76369: EMPTY
76370: LIST
76371: LIST
76372: PUSH
76373: LD_INT 6
76375: PUSH
76376: LD_INT 5
76378: PUSH
76379: EMPTY
76380: LIST
76381: LIST
76382: PUSH
76383: LD_INT 6
76385: PUSH
76386: LD_INT 6
76388: PUSH
76389: EMPTY
76390: LIST
76391: LIST
76392: PUSH
76393: LD_INT 5
76395: PUSH
76396: LD_INT 6
76398: PUSH
76399: EMPTY
76400: LIST
76401: LIST
76402: PUSH
76403: EMPTY
76404: LIST
76405: LIST
76406: LIST
76407: LIST
76408: LIST
76409: LIST
76410: LIST
76411: LIST
76412: LIST
76413: LIST
76414: LIST
76415: LIST
76416: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
76417: LD_ADDR_VAR 0 32
76421: PUSH
76422: LD_INT 1
76424: PUSH
76425: LD_INT 3
76427: PUSH
76428: EMPTY
76429: LIST
76430: LIST
76431: PUSH
76432: LD_INT 0
76434: PUSH
76435: LD_INT 3
76437: PUSH
76438: EMPTY
76439: LIST
76440: LIST
76441: PUSH
76442: LD_INT 1
76444: NEG
76445: PUSH
76446: LD_INT 2
76448: PUSH
76449: EMPTY
76450: LIST
76451: LIST
76452: PUSH
76453: LD_INT 1
76455: PUSH
76456: LD_INT 4
76458: PUSH
76459: EMPTY
76460: LIST
76461: LIST
76462: PUSH
76463: LD_INT 0
76465: PUSH
76466: LD_INT 4
76468: PUSH
76469: EMPTY
76470: LIST
76471: LIST
76472: PUSH
76473: LD_INT 1
76475: NEG
76476: PUSH
76477: LD_INT 3
76479: PUSH
76480: EMPTY
76481: LIST
76482: LIST
76483: PUSH
76484: LD_INT 1
76486: PUSH
76487: LD_INT 5
76489: PUSH
76490: EMPTY
76491: LIST
76492: LIST
76493: PUSH
76494: LD_INT 0
76496: PUSH
76497: LD_INT 5
76499: PUSH
76500: EMPTY
76501: LIST
76502: LIST
76503: PUSH
76504: LD_INT 1
76506: NEG
76507: PUSH
76508: LD_INT 4
76510: PUSH
76511: EMPTY
76512: LIST
76513: LIST
76514: PUSH
76515: LD_INT 1
76517: PUSH
76518: LD_INT 6
76520: PUSH
76521: EMPTY
76522: LIST
76523: LIST
76524: PUSH
76525: LD_INT 0
76527: PUSH
76528: LD_INT 6
76530: PUSH
76531: EMPTY
76532: LIST
76533: LIST
76534: PUSH
76535: LD_INT 1
76537: NEG
76538: PUSH
76539: LD_INT 5
76541: PUSH
76542: EMPTY
76543: LIST
76544: LIST
76545: PUSH
76546: EMPTY
76547: LIST
76548: LIST
76549: LIST
76550: LIST
76551: LIST
76552: LIST
76553: LIST
76554: LIST
76555: LIST
76556: LIST
76557: LIST
76558: LIST
76559: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
76560: LD_ADDR_VAR 0 33
76564: PUSH
76565: LD_INT 2
76567: NEG
76568: PUSH
76569: LD_INT 1
76571: PUSH
76572: EMPTY
76573: LIST
76574: LIST
76575: PUSH
76576: LD_INT 3
76578: NEG
76579: PUSH
76580: LD_INT 0
76582: PUSH
76583: EMPTY
76584: LIST
76585: LIST
76586: PUSH
76587: LD_INT 3
76589: NEG
76590: PUSH
76591: LD_INT 1
76593: NEG
76594: PUSH
76595: EMPTY
76596: LIST
76597: LIST
76598: PUSH
76599: LD_INT 3
76601: NEG
76602: PUSH
76603: LD_INT 1
76605: PUSH
76606: EMPTY
76607: LIST
76608: LIST
76609: PUSH
76610: LD_INT 4
76612: NEG
76613: PUSH
76614: LD_INT 0
76616: PUSH
76617: EMPTY
76618: LIST
76619: LIST
76620: PUSH
76621: LD_INT 4
76623: NEG
76624: PUSH
76625: LD_INT 1
76627: NEG
76628: PUSH
76629: EMPTY
76630: LIST
76631: LIST
76632: PUSH
76633: LD_INT 4
76635: NEG
76636: PUSH
76637: LD_INT 1
76639: PUSH
76640: EMPTY
76641: LIST
76642: LIST
76643: PUSH
76644: LD_INT 5
76646: NEG
76647: PUSH
76648: LD_INT 0
76650: PUSH
76651: EMPTY
76652: LIST
76653: LIST
76654: PUSH
76655: LD_INT 5
76657: NEG
76658: PUSH
76659: LD_INT 1
76661: NEG
76662: PUSH
76663: EMPTY
76664: LIST
76665: LIST
76666: PUSH
76667: LD_INT 5
76669: NEG
76670: PUSH
76671: LD_INT 1
76673: PUSH
76674: EMPTY
76675: LIST
76676: LIST
76677: PUSH
76678: LD_INT 6
76680: NEG
76681: PUSH
76682: LD_INT 0
76684: PUSH
76685: EMPTY
76686: LIST
76687: LIST
76688: PUSH
76689: LD_INT 6
76691: NEG
76692: PUSH
76693: LD_INT 1
76695: NEG
76696: PUSH
76697: EMPTY
76698: LIST
76699: LIST
76700: PUSH
76701: EMPTY
76702: LIST
76703: LIST
76704: LIST
76705: LIST
76706: LIST
76707: LIST
76708: LIST
76709: LIST
76710: LIST
76711: LIST
76712: LIST
76713: LIST
76714: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
76715: LD_ADDR_VAR 0 34
76719: PUSH
76720: LD_INT 2
76722: NEG
76723: PUSH
76724: LD_INT 3
76726: NEG
76727: PUSH
76728: EMPTY
76729: LIST
76730: LIST
76731: PUSH
76732: LD_INT 3
76734: NEG
76735: PUSH
76736: LD_INT 2
76738: NEG
76739: PUSH
76740: EMPTY
76741: LIST
76742: LIST
76743: PUSH
76744: LD_INT 3
76746: NEG
76747: PUSH
76748: LD_INT 3
76750: NEG
76751: PUSH
76752: EMPTY
76753: LIST
76754: LIST
76755: PUSH
76756: LD_INT 3
76758: NEG
76759: PUSH
76760: LD_INT 4
76762: NEG
76763: PUSH
76764: EMPTY
76765: LIST
76766: LIST
76767: PUSH
76768: LD_INT 4
76770: NEG
76771: PUSH
76772: LD_INT 3
76774: NEG
76775: PUSH
76776: EMPTY
76777: LIST
76778: LIST
76779: PUSH
76780: LD_INT 4
76782: NEG
76783: PUSH
76784: LD_INT 4
76786: NEG
76787: PUSH
76788: EMPTY
76789: LIST
76790: LIST
76791: PUSH
76792: LD_INT 4
76794: NEG
76795: PUSH
76796: LD_INT 5
76798: NEG
76799: PUSH
76800: EMPTY
76801: LIST
76802: LIST
76803: PUSH
76804: LD_INT 5
76806: NEG
76807: PUSH
76808: LD_INT 4
76810: NEG
76811: PUSH
76812: EMPTY
76813: LIST
76814: LIST
76815: PUSH
76816: LD_INT 5
76818: NEG
76819: PUSH
76820: LD_INT 5
76822: NEG
76823: PUSH
76824: EMPTY
76825: LIST
76826: LIST
76827: PUSH
76828: LD_INT 5
76830: NEG
76831: PUSH
76832: LD_INT 6
76834: NEG
76835: PUSH
76836: EMPTY
76837: LIST
76838: LIST
76839: PUSH
76840: LD_INT 6
76842: NEG
76843: PUSH
76844: LD_INT 5
76846: NEG
76847: PUSH
76848: EMPTY
76849: LIST
76850: LIST
76851: PUSH
76852: LD_INT 6
76854: NEG
76855: PUSH
76856: LD_INT 6
76858: NEG
76859: PUSH
76860: EMPTY
76861: LIST
76862: LIST
76863: PUSH
76864: EMPTY
76865: LIST
76866: LIST
76867: LIST
76868: LIST
76869: LIST
76870: LIST
76871: LIST
76872: LIST
76873: LIST
76874: LIST
76875: LIST
76876: LIST
76877: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
76878: LD_ADDR_VAR 0 41
76882: PUSH
76883: LD_INT 0
76885: PUSH
76886: LD_INT 2
76888: NEG
76889: PUSH
76890: EMPTY
76891: LIST
76892: LIST
76893: PUSH
76894: LD_INT 1
76896: NEG
76897: PUSH
76898: LD_INT 3
76900: NEG
76901: PUSH
76902: EMPTY
76903: LIST
76904: LIST
76905: PUSH
76906: LD_INT 1
76908: PUSH
76909: LD_INT 2
76911: NEG
76912: PUSH
76913: EMPTY
76914: LIST
76915: LIST
76916: PUSH
76917: EMPTY
76918: LIST
76919: LIST
76920: LIST
76921: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
76922: LD_ADDR_VAR 0 42
76926: PUSH
76927: LD_INT 2
76929: PUSH
76930: LD_INT 0
76932: PUSH
76933: EMPTY
76934: LIST
76935: LIST
76936: PUSH
76937: LD_INT 2
76939: PUSH
76940: LD_INT 1
76942: NEG
76943: PUSH
76944: EMPTY
76945: LIST
76946: LIST
76947: PUSH
76948: LD_INT 3
76950: PUSH
76951: LD_INT 1
76953: PUSH
76954: EMPTY
76955: LIST
76956: LIST
76957: PUSH
76958: EMPTY
76959: LIST
76960: LIST
76961: LIST
76962: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
76963: LD_ADDR_VAR 0 43
76967: PUSH
76968: LD_INT 2
76970: PUSH
76971: LD_INT 2
76973: PUSH
76974: EMPTY
76975: LIST
76976: LIST
76977: PUSH
76978: LD_INT 3
76980: PUSH
76981: LD_INT 2
76983: PUSH
76984: EMPTY
76985: LIST
76986: LIST
76987: PUSH
76988: LD_INT 2
76990: PUSH
76991: LD_INT 3
76993: PUSH
76994: EMPTY
76995: LIST
76996: LIST
76997: PUSH
76998: EMPTY
76999: LIST
77000: LIST
77001: LIST
77002: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
77003: LD_ADDR_VAR 0 44
77007: PUSH
77008: LD_INT 0
77010: PUSH
77011: LD_INT 2
77013: PUSH
77014: EMPTY
77015: LIST
77016: LIST
77017: PUSH
77018: LD_INT 1
77020: PUSH
77021: LD_INT 3
77023: PUSH
77024: EMPTY
77025: LIST
77026: LIST
77027: PUSH
77028: LD_INT 1
77030: NEG
77031: PUSH
77032: LD_INT 2
77034: PUSH
77035: EMPTY
77036: LIST
77037: LIST
77038: PUSH
77039: EMPTY
77040: LIST
77041: LIST
77042: LIST
77043: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
77044: LD_ADDR_VAR 0 45
77048: PUSH
77049: LD_INT 2
77051: NEG
77052: PUSH
77053: LD_INT 0
77055: PUSH
77056: EMPTY
77057: LIST
77058: LIST
77059: PUSH
77060: LD_INT 2
77062: NEG
77063: PUSH
77064: LD_INT 1
77066: PUSH
77067: EMPTY
77068: LIST
77069: LIST
77070: PUSH
77071: LD_INT 3
77073: NEG
77074: PUSH
77075: LD_INT 1
77077: NEG
77078: PUSH
77079: EMPTY
77080: LIST
77081: LIST
77082: PUSH
77083: EMPTY
77084: LIST
77085: LIST
77086: LIST
77087: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
77088: LD_ADDR_VAR 0 46
77092: PUSH
77093: LD_INT 2
77095: NEG
77096: PUSH
77097: LD_INT 2
77099: NEG
77100: PUSH
77101: EMPTY
77102: LIST
77103: LIST
77104: PUSH
77105: LD_INT 2
77107: NEG
77108: PUSH
77109: LD_INT 3
77111: NEG
77112: PUSH
77113: EMPTY
77114: LIST
77115: LIST
77116: PUSH
77117: LD_INT 3
77119: NEG
77120: PUSH
77121: LD_INT 2
77123: NEG
77124: PUSH
77125: EMPTY
77126: LIST
77127: LIST
77128: PUSH
77129: EMPTY
77130: LIST
77131: LIST
77132: LIST
77133: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
77134: LD_ADDR_VAR 0 47
77138: PUSH
77139: LD_INT 2
77141: NEG
77142: PUSH
77143: LD_INT 3
77145: NEG
77146: PUSH
77147: EMPTY
77148: LIST
77149: LIST
77150: PUSH
77151: LD_INT 1
77153: NEG
77154: PUSH
77155: LD_INT 3
77157: NEG
77158: PUSH
77159: EMPTY
77160: LIST
77161: LIST
77162: PUSH
77163: EMPTY
77164: LIST
77165: LIST
77166: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
77167: LD_ADDR_VAR 0 48
77171: PUSH
77172: LD_INT 1
77174: PUSH
77175: LD_INT 2
77177: NEG
77178: PUSH
77179: EMPTY
77180: LIST
77181: LIST
77182: PUSH
77183: LD_INT 2
77185: PUSH
77186: LD_INT 1
77188: NEG
77189: PUSH
77190: EMPTY
77191: LIST
77192: LIST
77193: PUSH
77194: EMPTY
77195: LIST
77196: LIST
77197: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
77198: LD_ADDR_VAR 0 49
77202: PUSH
77203: LD_INT 3
77205: PUSH
77206: LD_INT 1
77208: PUSH
77209: EMPTY
77210: LIST
77211: LIST
77212: PUSH
77213: LD_INT 3
77215: PUSH
77216: LD_INT 2
77218: PUSH
77219: EMPTY
77220: LIST
77221: LIST
77222: PUSH
77223: EMPTY
77224: LIST
77225: LIST
77226: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
77227: LD_ADDR_VAR 0 50
77231: PUSH
77232: LD_INT 2
77234: PUSH
77235: LD_INT 3
77237: PUSH
77238: EMPTY
77239: LIST
77240: LIST
77241: PUSH
77242: LD_INT 1
77244: PUSH
77245: LD_INT 3
77247: PUSH
77248: EMPTY
77249: LIST
77250: LIST
77251: PUSH
77252: EMPTY
77253: LIST
77254: LIST
77255: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
77256: LD_ADDR_VAR 0 51
77260: PUSH
77261: LD_INT 1
77263: NEG
77264: PUSH
77265: LD_INT 2
77267: PUSH
77268: EMPTY
77269: LIST
77270: LIST
77271: PUSH
77272: LD_INT 2
77274: NEG
77275: PUSH
77276: LD_INT 1
77278: PUSH
77279: EMPTY
77280: LIST
77281: LIST
77282: PUSH
77283: EMPTY
77284: LIST
77285: LIST
77286: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
77287: LD_ADDR_VAR 0 52
77291: PUSH
77292: LD_INT 3
77294: NEG
77295: PUSH
77296: LD_INT 1
77298: NEG
77299: PUSH
77300: EMPTY
77301: LIST
77302: LIST
77303: PUSH
77304: LD_INT 3
77306: NEG
77307: PUSH
77308: LD_INT 2
77310: NEG
77311: PUSH
77312: EMPTY
77313: LIST
77314: LIST
77315: PUSH
77316: EMPTY
77317: LIST
77318: LIST
77319: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
77320: LD_ADDR_VAR 0 53
77324: PUSH
77325: LD_INT 1
77327: NEG
77328: PUSH
77329: LD_INT 3
77331: NEG
77332: PUSH
77333: EMPTY
77334: LIST
77335: LIST
77336: PUSH
77337: LD_INT 0
77339: PUSH
77340: LD_INT 3
77342: NEG
77343: PUSH
77344: EMPTY
77345: LIST
77346: LIST
77347: PUSH
77348: LD_INT 1
77350: PUSH
77351: LD_INT 2
77353: NEG
77354: PUSH
77355: EMPTY
77356: LIST
77357: LIST
77358: PUSH
77359: EMPTY
77360: LIST
77361: LIST
77362: LIST
77363: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
77364: LD_ADDR_VAR 0 54
77368: PUSH
77369: LD_INT 2
77371: PUSH
77372: LD_INT 1
77374: NEG
77375: PUSH
77376: EMPTY
77377: LIST
77378: LIST
77379: PUSH
77380: LD_INT 3
77382: PUSH
77383: LD_INT 0
77385: PUSH
77386: EMPTY
77387: LIST
77388: LIST
77389: PUSH
77390: LD_INT 3
77392: PUSH
77393: LD_INT 1
77395: PUSH
77396: EMPTY
77397: LIST
77398: LIST
77399: PUSH
77400: EMPTY
77401: LIST
77402: LIST
77403: LIST
77404: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
77405: LD_ADDR_VAR 0 55
77409: PUSH
77410: LD_INT 3
77412: PUSH
77413: LD_INT 2
77415: PUSH
77416: EMPTY
77417: LIST
77418: LIST
77419: PUSH
77420: LD_INT 3
77422: PUSH
77423: LD_INT 3
77425: PUSH
77426: EMPTY
77427: LIST
77428: LIST
77429: PUSH
77430: LD_INT 2
77432: PUSH
77433: LD_INT 3
77435: PUSH
77436: EMPTY
77437: LIST
77438: LIST
77439: PUSH
77440: EMPTY
77441: LIST
77442: LIST
77443: LIST
77444: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
77445: LD_ADDR_VAR 0 56
77449: PUSH
77450: LD_INT 1
77452: PUSH
77453: LD_INT 3
77455: PUSH
77456: EMPTY
77457: LIST
77458: LIST
77459: PUSH
77460: LD_INT 0
77462: PUSH
77463: LD_INT 3
77465: PUSH
77466: EMPTY
77467: LIST
77468: LIST
77469: PUSH
77470: LD_INT 1
77472: NEG
77473: PUSH
77474: LD_INT 2
77476: PUSH
77477: EMPTY
77478: LIST
77479: LIST
77480: PUSH
77481: EMPTY
77482: LIST
77483: LIST
77484: LIST
77485: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
77486: LD_ADDR_VAR 0 57
77490: PUSH
77491: LD_INT 2
77493: NEG
77494: PUSH
77495: LD_INT 1
77497: PUSH
77498: EMPTY
77499: LIST
77500: LIST
77501: PUSH
77502: LD_INT 3
77504: NEG
77505: PUSH
77506: LD_INT 0
77508: PUSH
77509: EMPTY
77510: LIST
77511: LIST
77512: PUSH
77513: LD_INT 3
77515: NEG
77516: PUSH
77517: LD_INT 1
77519: NEG
77520: PUSH
77521: EMPTY
77522: LIST
77523: LIST
77524: PUSH
77525: EMPTY
77526: LIST
77527: LIST
77528: LIST
77529: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
77530: LD_ADDR_VAR 0 58
77534: PUSH
77535: LD_INT 2
77537: NEG
77538: PUSH
77539: LD_INT 3
77541: NEG
77542: PUSH
77543: EMPTY
77544: LIST
77545: LIST
77546: PUSH
77547: LD_INT 3
77549: NEG
77550: PUSH
77551: LD_INT 2
77553: NEG
77554: PUSH
77555: EMPTY
77556: LIST
77557: LIST
77558: PUSH
77559: LD_INT 3
77561: NEG
77562: PUSH
77563: LD_INT 3
77565: NEG
77566: PUSH
77567: EMPTY
77568: LIST
77569: LIST
77570: PUSH
77571: EMPTY
77572: LIST
77573: LIST
77574: LIST
77575: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
77576: LD_ADDR_VAR 0 59
77580: PUSH
77581: LD_INT 1
77583: NEG
77584: PUSH
77585: LD_INT 2
77587: NEG
77588: PUSH
77589: EMPTY
77590: LIST
77591: LIST
77592: PUSH
77593: LD_INT 0
77595: PUSH
77596: LD_INT 2
77598: NEG
77599: PUSH
77600: EMPTY
77601: LIST
77602: LIST
77603: PUSH
77604: LD_INT 1
77606: PUSH
77607: LD_INT 1
77609: NEG
77610: PUSH
77611: EMPTY
77612: LIST
77613: LIST
77614: PUSH
77615: EMPTY
77616: LIST
77617: LIST
77618: LIST
77619: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
77620: LD_ADDR_VAR 0 60
77624: PUSH
77625: LD_INT 1
77627: PUSH
77628: LD_INT 1
77630: NEG
77631: PUSH
77632: EMPTY
77633: LIST
77634: LIST
77635: PUSH
77636: LD_INT 2
77638: PUSH
77639: LD_INT 0
77641: PUSH
77642: EMPTY
77643: LIST
77644: LIST
77645: PUSH
77646: LD_INT 2
77648: PUSH
77649: LD_INT 1
77651: PUSH
77652: EMPTY
77653: LIST
77654: LIST
77655: PUSH
77656: EMPTY
77657: LIST
77658: LIST
77659: LIST
77660: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
77661: LD_ADDR_VAR 0 61
77665: PUSH
77666: LD_INT 2
77668: PUSH
77669: LD_INT 1
77671: PUSH
77672: EMPTY
77673: LIST
77674: LIST
77675: PUSH
77676: LD_INT 2
77678: PUSH
77679: LD_INT 2
77681: PUSH
77682: EMPTY
77683: LIST
77684: LIST
77685: PUSH
77686: LD_INT 1
77688: PUSH
77689: LD_INT 2
77691: PUSH
77692: EMPTY
77693: LIST
77694: LIST
77695: PUSH
77696: EMPTY
77697: LIST
77698: LIST
77699: LIST
77700: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
77701: LD_ADDR_VAR 0 62
77705: PUSH
77706: LD_INT 1
77708: PUSH
77709: LD_INT 2
77711: PUSH
77712: EMPTY
77713: LIST
77714: LIST
77715: PUSH
77716: LD_INT 0
77718: PUSH
77719: LD_INT 2
77721: PUSH
77722: EMPTY
77723: LIST
77724: LIST
77725: PUSH
77726: LD_INT 1
77728: NEG
77729: PUSH
77730: LD_INT 1
77732: PUSH
77733: EMPTY
77734: LIST
77735: LIST
77736: PUSH
77737: EMPTY
77738: LIST
77739: LIST
77740: LIST
77741: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
77742: LD_ADDR_VAR 0 63
77746: PUSH
77747: LD_INT 1
77749: NEG
77750: PUSH
77751: LD_INT 1
77753: PUSH
77754: EMPTY
77755: LIST
77756: LIST
77757: PUSH
77758: LD_INT 2
77760: NEG
77761: PUSH
77762: LD_INT 0
77764: PUSH
77765: EMPTY
77766: LIST
77767: LIST
77768: PUSH
77769: LD_INT 2
77771: NEG
77772: PUSH
77773: LD_INT 1
77775: NEG
77776: PUSH
77777: EMPTY
77778: LIST
77779: LIST
77780: PUSH
77781: EMPTY
77782: LIST
77783: LIST
77784: LIST
77785: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77786: LD_ADDR_VAR 0 64
77790: PUSH
77791: LD_INT 1
77793: NEG
77794: PUSH
77795: LD_INT 2
77797: NEG
77798: PUSH
77799: EMPTY
77800: LIST
77801: LIST
77802: PUSH
77803: LD_INT 2
77805: NEG
77806: PUSH
77807: LD_INT 1
77809: NEG
77810: PUSH
77811: EMPTY
77812: LIST
77813: LIST
77814: PUSH
77815: LD_INT 2
77817: NEG
77818: PUSH
77819: LD_INT 2
77821: NEG
77822: PUSH
77823: EMPTY
77824: LIST
77825: LIST
77826: PUSH
77827: EMPTY
77828: LIST
77829: LIST
77830: LIST
77831: ST_TO_ADDR
// end ; 2 :
77832: GO 81098
77834: LD_INT 2
77836: DOUBLE
77837: EQUAL
77838: IFTRUE 77842
77840: GO 81097
77842: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
77843: LD_ADDR_VAR 0 29
77847: PUSH
77848: LD_INT 4
77850: PUSH
77851: LD_INT 0
77853: PUSH
77854: EMPTY
77855: LIST
77856: LIST
77857: PUSH
77858: LD_INT 4
77860: PUSH
77861: LD_INT 1
77863: NEG
77864: PUSH
77865: EMPTY
77866: LIST
77867: LIST
77868: PUSH
77869: LD_INT 5
77871: PUSH
77872: LD_INT 0
77874: PUSH
77875: EMPTY
77876: LIST
77877: LIST
77878: PUSH
77879: LD_INT 5
77881: PUSH
77882: LD_INT 1
77884: PUSH
77885: EMPTY
77886: LIST
77887: LIST
77888: PUSH
77889: LD_INT 4
77891: PUSH
77892: LD_INT 1
77894: PUSH
77895: EMPTY
77896: LIST
77897: LIST
77898: PUSH
77899: LD_INT 3
77901: PUSH
77902: LD_INT 0
77904: PUSH
77905: EMPTY
77906: LIST
77907: LIST
77908: PUSH
77909: LD_INT 3
77911: PUSH
77912: LD_INT 1
77914: NEG
77915: PUSH
77916: EMPTY
77917: LIST
77918: LIST
77919: PUSH
77920: LD_INT 3
77922: PUSH
77923: LD_INT 2
77925: NEG
77926: PUSH
77927: EMPTY
77928: LIST
77929: LIST
77930: PUSH
77931: LD_INT 5
77933: PUSH
77934: LD_INT 2
77936: PUSH
77937: EMPTY
77938: LIST
77939: LIST
77940: PUSH
77941: LD_INT 3
77943: PUSH
77944: LD_INT 3
77946: PUSH
77947: EMPTY
77948: LIST
77949: LIST
77950: PUSH
77951: LD_INT 3
77953: PUSH
77954: LD_INT 2
77956: PUSH
77957: EMPTY
77958: LIST
77959: LIST
77960: PUSH
77961: LD_INT 4
77963: PUSH
77964: LD_INT 3
77966: PUSH
77967: EMPTY
77968: LIST
77969: LIST
77970: PUSH
77971: LD_INT 4
77973: PUSH
77974: LD_INT 4
77976: PUSH
77977: EMPTY
77978: LIST
77979: LIST
77980: PUSH
77981: LD_INT 3
77983: PUSH
77984: LD_INT 4
77986: PUSH
77987: EMPTY
77988: LIST
77989: LIST
77990: PUSH
77991: LD_INT 2
77993: PUSH
77994: LD_INT 3
77996: PUSH
77997: EMPTY
77998: LIST
77999: LIST
78000: PUSH
78001: LD_INT 2
78003: PUSH
78004: LD_INT 2
78006: PUSH
78007: EMPTY
78008: LIST
78009: LIST
78010: PUSH
78011: LD_INT 4
78013: PUSH
78014: LD_INT 2
78016: PUSH
78017: EMPTY
78018: LIST
78019: LIST
78020: PUSH
78021: LD_INT 2
78023: PUSH
78024: LD_INT 4
78026: PUSH
78027: EMPTY
78028: LIST
78029: LIST
78030: PUSH
78031: LD_INT 0
78033: PUSH
78034: LD_INT 4
78036: PUSH
78037: EMPTY
78038: LIST
78039: LIST
78040: PUSH
78041: LD_INT 0
78043: PUSH
78044: LD_INT 3
78046: PUSH
78047: EMPTY
78048: LIST
78049: LIST
78050: PUSH
78051: LD_INT 1
78053: PUSH
78054: LD_INT 4
78056: PUSH
78057: EMPTY
78058: LIST
78059: LIST
78060: PUSH
78061: LD_INT 1
78063: PUSH
78064: LD_INT 5
78066: PUSH
78067: EMPTY
78068: LIST
78069: LIST
78070: PUSH
78071: LD_INT 0
78073: PUSH
78074: LD_INT 5
78076: PUSH
78077: EMPTY
78078: LIST
78079: LIST
78080: PUSH
78081: LD_INT 1
78083: NEG
78084: PUSH
78085: LD_INT 4
78087: PUSH
78088: EMPTY
78089: LIST
78090: LIST
78091: PUSH
78092: LD_INT 1
78094: NEG
78095: PUSH
78096: LD_INT 3
78098: PUSH
78099: EMPTY
78100: LIST
78101: LIST
78102: PUSH
78103: LD_INT 2
78105: PUSH
78106: LD_INT 5
78108: PUSH
78109: EMPTY
78110: LIST
78111: LIST
78112: PUSH
78113: LD_INT 2
78115: NEG
78116: PUSH
78117: LD_INT 3
78119: PUSH
78120: EMPTY
78121: LIST
78122: LIST
78123: PUSH
78124: LD_INT 3
78126: NEG
78127: PUSH
78128: LD_INT 0
78130: PUSH
78131: EMPTY
78132: LIST
78133: LIST
78134: PUSH
78135: LD_INT 3
78137: NEG
78138: PUSH
78139: LD_INT 1
78141: NEG
78142: PUSH
78143: EMPTY
78144: LIST
78145: LIST
78146: PUSH
78147: LD_INT 2
78149: NEG
78150: PUSH
78151: LD_INT 0
78153: PUSH
78154: EMPTY
78155: LIST
78156: LIST
78157: PUSH
78158: LD_INT 2
78160: NEG
78161: PUSH
78162: LD_INT 1
78164: PUSH
78165: EMPTY
78166: LIST
78167: LIST
78168: PUSH
78169: LD_INT 3
78171: NEG
78172: PUSH
78173: LD_INT 1
78175: PUSH
78176: EMPTY
78177: LIST
78178: LIST
78179: PUSH
78180: LD_INT 4
78182: NEG
78183: PUSH
78184: LD_INT 0
78186: PUSH
78187: EMPTY
78188: LIST
78189: LIST
78190: PUSH
78191: LD_INT 4
78193: NEG
78194: PUSH
78195: LD_INT 1
78197: NEG
78198: PUSH
78199: EMPTY
78200: LIST
78201: LIST
78202: PUSH
78203: LD_INT 4
78205: NEG
78206: PUSH
78207: LD_INT 2
78209: NEG
78210: PUSH
78211: EMPTY
78212: LIST
78213: LIST
78214: PUSH
78215: LD_INT 2
78217: NEG
78218: PUSH
78219: LD_INT 2
78221: PUSH
78222: EMPTY
78223: LIST
78224: LIST
78225: PUSH
78226: LD_INT 4
78228: NEG
78229: PUSH
78230: LD_INT 4
78232: NEG
78233: PUSH
78234: EMPTY
78235: LIST
78236: LIST
78237: PUSH
78238: LD_INT 4
78240: NEG
78241: PUSH
78242: LD_INT 5
78244: NEG
78245: PUSH
78246: EMPTY
78247: LIST
78248: LIST
78249: PUSH
78250: LD_INT 3
78252: NEG
78253: PUSH
78254: LD_INT 4
78256: NEG
78257: PUSH
78258: EMPTY
78259: LIST
78260: LIST
78261: PUSH
78262: LD_INT 3
78264: NEG
78265: PUSH
78266: LD_INT 3
78268: NEG
78269: PUSH
78270: EMPTY
78271: LIST
78272: LIST
78273: PUSH
78274: LD_INT 4
78276: NEG
78277: PUSH
78278: LD_INT 3
78280: NEG
78281: PUSH
78282: EMPTY
78283: LIST
78284: LIST
78285: PUSH
78286: LD_INT 5
78288: NEG
78289: PUSH
78290: LD_INT 4
78292: NEG
78293: PUSH
78294: EMPTY
78295: LIST
78296: LIST
78297: PUSH
78298: LD_INT 5
78300: NEG
78301: PUSH
78302: LD_INT 5
78304: NEG
78305: PUSH
78306: EMPTY
78307: LIST
78308: LIST
78309: PUSH
78310: LD_INT 3
78312: NEG
78313: PUSH
78314: LD_INT 5
78316: NEG
78317: PUSH
78318: EMPTY
78319: LIST
78320: LIST
78321: PUSH
78322: LD_INT 5
78324: NEG
78325: PUSH
78326: LD_INT 3
78328: NEG
78329: PUSH
78330: EMPTY
78331: LIST
78332: LIST
78333: PUSH
78334: EMPTY
78335: LIST
78336: LIST
78337: LIST
78338: LIST
78339: LIST
78340: LIST
78341: LIST
78342: LIST
78343: LIST
78344: LIST
78345: LIST
78346: LIST
78347: LIST
78348: LIST
78349: LIST
78350: LIST
78351: LIST
78352: LIST
78353: LIST
78354: LIST
78355: LIST
78356: LIST
78357: LIST
78358: LIST
78359: LIST
78360: LIST
78361: LIST
78362: LIST
78363: LIST
78364: LIST
78365: LIST
78366: LIST
78367: LIST
78368: LIST
78369: LIST
78370: LIST
78371: LIST
78372: LIST
78373: LIST
78374: LIST
78375: LIST
78376: LIST
78377: LIST
78378: LIST
78379: LIST
78380: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
78381: LD_ADDR_VAR 0 30
78385: PUSH
78386: LD_INT 4
78388: PUSH
78389: LD_INT 4
78391: PUSH
78392: EMPTY
78393: LIST
78394: LIST
78395: PUSH
78396: LD_INT 4
78398: PUSH
78399: LD_INT 3
78401: PUSH
78402: EMPTY
78403: LIST
78404: LIST
78405: PUSH
78406: LD_INT 5
78408: PUSH
78409: LD_INT 4
78411: PUSH
78412: EMPTY
78413: LIST
78414: LIST
78415: PUSH
78416: LD_INT 5
78418: PUSH
78419: LD_INT 5
78421: PUSH
78422: EMPTY
78423: LIST
78424: LIST
78425: PUSH
78426: LD_INT 4
78428: PUSH
78429: LD_INT 5
78431: PUSH
78432: EMPTY
78433: LIST
78434: LIST
78435: PUSH
78436: LD_INT 3
78438: PUSH
78439: LD_INT 4
78441: PUSH
78442: EMPTY
78443: LIST
78444: LIST
78445: PUSH
78446: LD_INT 3
78448: PUSH
78449: LD_INT 3
78451: PUSH
78452: EMPTY
78453: LIST
78454: LIST
78455: PUSH
78456: LD_INT 5
78458: PUSH
78459: LD_INT 3
78461: PUSH
78462: EMPTY
78463: LIST
78464: LIST
78465: PUSH
78466: LD_INT 3
78468: PUSH
78469: LD_INT 5
78471: PUSH
78472: EMPTY
78473: LIST
78474: LIST
78475: PUSH
78476: LD_INT 0
78478: PUSH
78479: LD_INT 3
78481: PUSH
78482: EMPTY
78483: LIST
78484: LIST
78485: PUSH
78486: LD_INT 0
78488: PUSH
78489: LD_INT 2
78491: PUSH
78492: EMPTY
78493: LIST
78494: LIST
78495: PUSH
78496: LD_INT 1
78498: PUSH
78499: LD_INT 3
78501: PUSH
78502: EMPTY
78503: LIST
78504: LIST
78505: PUSH
78506: LD_INT 1
78508: PUSH
78509: LD_INT 4
78511: PUSH
78512: EMPTY
78513: LIST
78514: LIST
78515: PUSH
78516: LD_INT 0
78518: PUSH
78519: LD_INT 4
78521: PUSH
78522: EMPTY
78523: LIST
78524: LIST
78525: PUSH
78526: LD_INT 1
78528: NEG
78529: PUSH
78530: LD_INT 3
78532: PUSH
78533: EMPTY
78534: LIST
78535: LIST
78536: PUSH
78537: LD_INT 1
78539: NEG
78540: PUSH
78541: LD_INT 2
78543: PUSH
78544: EMPTY
78545: LIST
78546: LIST
78547: PUSH
78548: LD_INT 2
78550: PUSH
78551: LD_INT 4
78553: PUSH
78554: EMPTY
78555: LIST
78556: LIST
78557: PUSH
78558: LD_INT 2
78560: NEG
78561: PUSH
78562: LD_INT 2
78564: PUSH
78565: EMPTY
78566: LIST
78567: LIST
78568: PUSH
78569: LD_INT 4
78571: NEG
78572: PUSH
78573: LD_INT 0
78575: PUSH
78576: EMPTY
78577: LIST
78578: LIST
78579: PUSH
78580: LD_INT 4
78582: NEG
78583: PUSH
78584: LD_INT 1
78586: NEG
78587: PUSH
78588: EMPTY
78589: LIST
78590: LIST
78591: PUSH
78592: LD_INT 3
78594: NEG
78595: PUSH
78596: LD_INT 0
78598: PUSH
78599: EMPTY
78600: LIST
78601: LIST
78602: PUSH
78603: LD_INT 3
78605: NEG
78606: PUSH
78607: LD_INT 1
78609: PUSH
78610: EMPTY
78611: LIST
78612: LIST
78613: PUSH
78614: LD_INT 4
78616: NEG
78617: PUSH
78618: LD_INT 1
78620: PUSH
78621: EMPTY
78622: LIST
78623: LIST
78624: PUSH
78625: LD_INT 5
78627: NEG
78628: PUSH
78629: LD_INT 0
78631: PUSH
78632: EMPTY
78633: LIST
78634: LIST
78635: PUSH
78636: LD_INT 5
78638: NEG
78639: PUSH
78640: LD_INT 1
78642: NEG
78643: PUSH
78644: EMPTY
78645: LIST
78646: LIST
78647: PUSH
78648: LD_INT 5
78650: NEG
78651: PUSH
78652: LD_INT 2
78654: NEG
78655: PUSH
78656: EMPTY
78657: LIST
78658: LIST
78659: PUSH
78660: LD_INT 3
78662: NEG
78663: PUSH
78664: LD_INT 2
78666: PUSH
78667: EMPTY
78668: LIST
78669: LIST
78670: PUSH
78671: LD_INT 3
78673: NEG
78674: PUSH
78675: LD_INT 3
78677: NEG
78678: PUSH
78679: EMPTY
78680: LIST
78681: LIST
78682: PUSH
78683: LD_INT 3
78685: NEG
78686: PUSH
78687: LD_INT 4
78689: NEG
78690: PUSH
78691: EMPTY
78692: LIST
78693: LIST
78694: PUSH
78695: LD_INT 2
78697: NEG
78698: PUSH
78699: LD_INT 3
78701: NEG
78702: PUSH
78703: EMPTY
78704: LIST
78705: LIST
78706: PUSH
78707: LD_INT 2
78709: NEG
78710: PUSH
78711: LD_INT 2
78713: NEG
78714: PUSH
78715: EMPTY
78716: LIST
78717: LIST
78718: PUSH
78719: LD_INT 3
78721: NEG
78722: PUSH
78723: LD_INT 2
78725: NEG
78726: PUSH
78727: EMPTY
78728: LIST
78729: LIST
78730: PUSH
78731: LD_INT 4
78733: NEG
78734: PUSH
78735: LD_INT 3
78737: NEG
78738: PUSH
78739: EMPTY
78740: LIST
78741: LIST
78742: PUSH
78743: LD_INT 4
78745: NEG
78746: PUSH
78747: LD_INT 4
78749: NEG
78750: PUSH
78751: EMPTY
78752: LIST
78753: LIST
78754: PUSH
78755: LD_INT 2
78757: NEG
78758: PUSH
78759: LD_INT 4
78761: NEG
78762: PUSH
78763: EMPTY
78764: LIST
78765: LIST
78766: PUSH
78767: LD_INT 4
78769: NEG
78770: PUSH
78771: LD_INT 2
78773: NEG
78774: PUSH
78775: EMPTY
78776: LIST
78777: LIST
78778: PUSH
78779: LD_INT 0
78781: PUSH
78782: LD_INT 4
78784: NEG
78785: PUSH
78786: EMPTY
78787: LIST
78788: LIST
78789: PUSH
78790: LD_INT 0
78792: PUSH
78793: LD_INT 5
78795: NEG
78796: PUSH
78797: EMPTY
78798: LIST
78799: LIST
78800: PUSH
78801: LD_INT 1
78803: PUSH
78804: LD_INT 4
78806: NEG
78807: PUSH
78808: EMPTY
78809: LIST
78810: LIST
78811: PUSH
78812: LD_INT 1
78814: PUSH
78815: LD_INT 3
78817: NEG
78818: PUSH
78819: EMPTY
78820: LIST
78821: LIST
78822: PUSH
78823: LD_INT 0
78825: PUSH
78826: LD_INT 3
78828: NEG
78829: PUSH
78830: EMPTY
78831: LIST
78832: LIST
78833: PUSH
78834: LD_INT 1
78836: NEG
78837: PUSH
78838: LD_INT 4
78840: NEG
78841: PUSH
78842: EMPTY
78843: LIST
78844: LIST
78845: PUSH
78846: LD_INT 1
78848: NEG
78849: PUSH
78850: LD_INT 5
78852: NEG
78853: PUSH
78854: EMPTY
78855: LIST
78856: LIST
78857: PUSH
78858: LD_INT 2
78860: PUSH
78861: LD_INT 3
78863: NEG
78864: PUSH
78865: EMPTY
78866: LIST
78867: LIST
78868: PUSH
78869: LD_INT 2
78871: NEG
78872: PUSH
78873: LD_INT 5
78875: NEG
78876: PUSH
78877: EMPTY
78878: LIST
78879: LIST
78880: PUSH
78881: EMPTY
78882: LIST
78883: LIST
78884: LIST
78885: LIST
78886: LIST
78887: LIST
78888: LIST
78889: LIST
78890: LIST
78891: LIST
78892: LIST
78893: LIST
78894: LIST
78895: LIST
78896: LIST
78897: LIST
78898: LIST
78899: LIST
78900: LIST
78901: LIST
78902: LIST
78903: LIST
78904: LIST
78905: LIST
78906: LIST
78907: LIST
78908: LIST
78909: LIST
78910: LIST
78911: LIST
78912: LIST
78913: LIST
78914: LIST
78915: LIST
78916: LIST
78917: LIST
78918: LIST
78919: LIST
78920: LIST
78921: LIST
78922: LIST
78923: LIST
78924: LIST
78925: LIST
78926: LIST
78927: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
78928: LD_ADDR_VAR 0 31
78932: PUSH
78933: LD_INT 0
78935: PUSH
78936: LD_INT 4
78938: PUSH
78939: EMPTY
78940: LIST
78941: LIST
78942: PUSH
78943: LD_INT 0
78945: PUSH
78946: LD_INT 3
78948: PUSH
78949: EMPTY
78950: LIST
78951: LIST
78952: PUSH
78953: LD_INT 1
78955: PUSH
78956: LD_INT 4
78958: PUSH
78959: EMPTY
78960: LIST
78961: LIST
78962: PUSH
78963: LD_INT 1
78965: PUSH
78966: LD_INT 5
78968: PUSH
78969: EMPTY
78970: LIST
78971: LIST
78972: PUSH
78973: LD_INT 0
78975: PUSH
78976: LD_INT 5
78978: PUSH
78979: EMPTY
78980: LIST
78981: LIST
78982: PUSH
78983: LD_INT 1
78985: NEG
78986: PUSH
78987: LD_INT 4
78989: PUSH
78990: EMPTY
78991: LIST
78992: LIST
78993: PUSH
78994: LD_INT 1
78996: NEG
78997: PUSH
78998: LD_INT 3
79000: PUSH
79001: EMPTY
79002: LIST
79003: LIST
79004: PUSH
79005: LD_INT 2
79007: PUSH
79008: LD_INT 5
79010: PUSH
79011: EMPTY
79012: LIST
79013: LIST
79014: PUSH
79015: LD_INT 2
79017: NEG
79018: PUSH
79019: LD_INT 3
79021: PUSH
79022: EMPTY
79023: LIST
79024: LIST
79025: PUSH
79026: LD_INT 3
79028: NEG
79029: PUSH
79030: LD_INT 0
79032: PUSH
79033: EMPTY
79034: LIST
79035: LIST
79036: PUSH
79037: LD_INT 3
79039: NEG
79040: PUSH
79041: LD_INT 1
79043: NEG
79044: PUSH
79045: EMPTY
79046: LIST
79047: LIST
79048: PUSH
79049: LD_INT 2
79051: NEG
79052: PUSH
79053: LD_INT 0
79055: PUSH
79056: EMPTY
79057: LIST
79058: LIST
79059: PUSH
79060: LD_INT 2
79062: NEG
79063: PUSH
79064: LD_INT 1
79066: PUSH
79067: EMPTY
79068: LIST
79069: LIST
79070: PUSH
79071: LD_INT 3
79073: NEG
79074: PUSH
79075: LD_INT 1
79077: PUSH
79078: EMPTY
79079: LIST
79080: LIST
79081: PUSH
79082: LD_INT 4
79084: NEG
79085: PUSH
79086: LD_INT 0
79088: PUSH
79089: EMPTY
79090: LIST
79091: LIST
79092: PUSH
79093: LD_INT 4
79095: NEG
79096: PUSH
79097: LD_INT 1
79099: NEG
79100: PUSH
79101: EMPTY
79102: LIST
79103: LIST
79104: PUSH
79105: LD_INT 4
79107: NEG
79108: PUSH
79109: LD_INT 2
79111: NEG
79112: PUSH
79113: EMPTY
79114: LIST
79115: LIST
79116: PUSH
79117: LD_INT 2
79119: NEG
79120: PUSH
79121: LD_INT 2
79123: PUSH
79124: EMPTY
79125: LIST
79126: LIST
79127: PUSH
79128: LD_INT 4
79130: NEG
79131: PUSH
79132: LD_INT 4
79134: NEG
79135: PUSH
79136: EMPTY
79137: LIST
79138: LIST
79139: PUSH
79140: LD_INT 4
79142: NEG
79143: PUSH
79144: LD_INT 5
79146: NEG
79147: PUSH
79148: EMPTY
79149: LIST
79150: LIST
79151: PUSH
79152: LD_INT 3
79154: NEG
79155: PUSH
79156: LD_INT 4
79158: NEG
79159: PUSH
79160: EMPTY
79161: LIST
79162: LIST
79163: PUSH
79164: LD_INT 3
79166: NEG
79167: PUSH
79168: LD_INT 3
79170: NEG
79171: PUSH
79172: EMPTY
79173: LIST
79174: LIST
79175: PUSH
79176: LD_INT 4
79178: NEG
79179: PUSH
79180: LD_INT 3
79182: NEG
79183: PUSH
79184: EMPTY
79185: LIST
79186: LIST
79187: PUSH
79188: LD_INT 5
79190: NEG
79191: PUSH
79192: LD_INT 4
79194: NEG
79195: PUSH
79196: EMPTY
79197: LIST
79198: LIST
79199: PUSH
79200: LD_INT 5
79202: NEG
79203: PUSH
79204: LD_INT 5
79206: NEG
79207: PUSH
79208: EMPTY
79209: LIST
79210: LIST
79211: PUSH
79212: LD_INT 3
79214: NEG
79215: PUSH
79216: LD_INT 5
79218: NEG
79219: PUSH
79220: EMPTY
79221: LIST
79222: LIST
79223: PUSH
79224: LD_INT 5
79226: NEG
79227: PUSH
79228: LD_INT 3
79230: NEG
79231: PUSH
79232: EMPTY
79233: LIST
79234: LIST
79235: PUSH
79236: LD_INT 0
79238: PUSH
79239: LD_INT 3
79241: NEG
79242: PUSH
79243: EMPTY
79244: LIST
79245: LIST
79246: PUSH
79247: LD_INT 0
79249: PUSH
79250: LD_INT 4
79252: NEG
79253: PUSH
79254: EMPTY
79255: LIST
79256: LIST
79257: PUSH
79258: LD_INT 1
79260: PUSH
79261: LD_INT 3
79263: NEG
79264: PUSH
79265: EMPTY
79266: LIST
79267: LIST
79268: PUSH
79269: LD_INT 1
79271: PUSH
79272: LD_INT 2
79274: NEG
79275: PUSH
79276: EMPTY
79277: LIST
79278: LIST
79279: PUSH
79280: LD_INT 0
79282: PUSH
79283: LD_INT 2
79285: NEG
79286: PUSH
79287: EMPTY
79288: LIST
79289: LIST
79290: PUSH
79291: LD_INT 1
79293: NEG
79294: PUSH
79295: LD_INT 3
79297: NEG
79298: PUSH
79299: EMPTY
79300: LIST
79301: LIST
79302: PUSH
79303: LD_INT 1
79305: NEG
79306: PUSH
79307: LD_INT 4
79309: NEG
79310: PUSH
79311: EMPTY
79312: LIST
79313: LIST
79314: PUSH
79315: LD_INT 2
79317: PUSH
79318: LD_INT 2
79320: NEG
79321: PUSH
79322: EMPTY
79323: LIST
79324: LIST
79325: PUSH
79326: LD_INT 2
79328: NEG
79329: PUSH
79330: LD_INT 4
79332: NEG
79333: PUSH
79334: EMPTY
79335: LIST
79336: LIST
79337: PUSH
79338: LD_INT 4
79340: PUSH
79341: LD_INT 0
79343: PUSH
79344: EMPTY
79345: LIST
79346: LIST
79347: PUSH
79348: LD_INT 4
79350: PUSH
79351: LD_INT 1
79353: NEG
79354: PUSH
79355: EMPTY
79356: LIST
79357: LIST
79358: PUSH
79359: LD_INT 5
79361: PUSH
79362: LD_INT 0
79364: PUSH
79365: EMPTY
79366: LIST
79367: LIST
79368: PUSH
79369: LD_INT 5
79371: PUSH
79372: LD_INT 1
79374: PUSH
79375: EMPTY
79376: LIST
79377: LIST
79378: PUSH
79379: LD_INT 4
79381: PUSH
79382: LD_INT 1
79384: PUSH
79385: EMPTY
79386: LIST
79387: LIST
79388: PUSH
79389: LD_INT 3
79391: PUSH
79392: LD_INT 0
79394: PUSH
79395: EMPTY
79396: LIST
79397: LIST
79398: PUSH
79399: LD_INT 3
79401: PUSH
79402: LD_INT 1
79404: NEG
79405: PUSH
79406: EMPTY
79407: LIST
79408: LIST
79409: PUSH
79410: LD_INT 3
79412: PUSH
79413: LD_INT 2
79415: NEG
79416: PUSH
79417: EMPTY
79418: LIST
79419: LIST
79420: PUSH
79421: LD_INT 5
79423: PUSH
79424: LD_INT 2
79426: PUSH
79427: EMPTY
79428: LIST
79429: LIST
79430: PUSH
79431: EMPTY
79432: LIST
79433: LIST
79434: LIST
79435: LIST
79436: LIST
79437: LIST
79438: LIST
79439: LIST
79440: LIST
79441: LIST
79442: LIST
79443: LIST
79444: LIST
79445: LIST
79446: LIST
79447: LIST
79448: LIST
79449: LIST
79450: LIST
79451: LIST
79452: LIST
79453: LIST
79454: LIST
79455: LIST
79456: LIST
79457: LIST
79458: LIST
79459: LIST
79460: LIST
79461: LIST
79462: LIST
79463: LIST
79464: LIST
79465: LIST
79466: LIST
79467: LIST
79468: LIST
79469: LIST
79470: LIST
79471: LIST
79472: LIST
79473: LIST
79474: LIST
79475: LIST
79476: LIST
79477: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
79478: LD_ADDR_VAR 0 32
79482: PUSH
79483: LD_INT 4
79485: NEG
79486: PUSH
79487: LD_INT 0
79489: PUSH
79490: EMPTY
79491: LIST
79492: LIST
79493: PUSH
79494: LD_INT 4
79496: NEG
79497: PUSH
79498: LD_INT 1
79500: NEG
79501: PUSH
79502: EMPTY
79503: LIST
79504: LIST
79505: PUSH
79506: LD_INT 3
79508: NEG
79509: PUSH
79510: LD_INT 0
79512: PUSH
79513: EMPTY
79514: LIST
79515: LIST
79516: PUSH
79517: LD_INT 3
79519: NEG
79520: PUSH
79521: LD_INT 1
79523: PUSH
79524: EMPTY
79525: LIST
79526: LIST
79527: PUSH
79528: LD_INT 4
79530: NEG
79531: PUSH
79532: LD_INT 1
79534: PUSH
79535: EMPTY
79536: LIST
79537: LIST
79538: PUSH
79539: LD_INT 5
79541: NEG
79542: PUSH
79543: LD_INT 0
79545: PUSH
79546: EMPTY
79547: LIST
79548: LIST
79549: PUSH
79550: LD_INT 5
79552: NEG
79553: PUSH
79554: LD_INT 1
79556: NEG
79557: PUSH
79558: EMPTY
79559: LIST
79560: LIST
79561: PUSH
79562: LD_INT 5
79564: NEG
79565: PUSH
79566: LD_INT 2
79568: NEG
79569: PUSH
79570: EMPTY
79571: LIST
79572: LIST
79573: PUSH
79574: LD_INT 3
79576: NEG
79577: PUSH
79578: LD_INT 2
79580: PUSH
79581: EMPTY
79582: LIST
79583: LIST
79584: PUSH
79585: LD_INT 3
79587: NEG
79588: PUSH
79589: LD_INT 3
79591: NEG
79592: PUSH
79593: EMPTY
79594: LIST
79595: LIST
79596: PUSH
79597: LD_INT 3
79599: NEG
79600: PUSH
79601: LD_INT 4
79603: NEG
79604: PUSH
79605: EMPTY
79606: LIST
79607: LIST
79608: PUSH
79609: LD_INT 2
79611: NEG
79612: PUSH
79613: LD_INT 3
79615: NEG
79616: PUSH
79617: EMPTY
79618: LIST
79619: LIST
79620: PUSH
79621: LD_INT 2
79623: NEG
79624: PUSH
79625: LD_INT 2
79627: NEG
79628: PUSH
79629: EMPTY
79630: LIST
79631: LIST
79632: PUSH
79633: LD_INT 3
79635: NEG
79636: PUSH
79637: LD_INT 2
79639: NEG
79640: PUSH
79641: EMPTY
79642: LIST
79643: LIST
79644: PUSH
79645: LD_INT 4
79647: NEG
79648: PUSH
79649: LD_INT 3
79651: NEG
79652: PUSH
79653: EMPTY
79654: LIST
79655: LIST
79656: PUSH
79657: LD_INT 4
79659: NEG
79660: PUSH
79661: LD_INT 4
79663: NEG
79664: PUSH
79665: EMPTY
79666: LIST
79667: LIST
79668: PUSH
79669: LD_INT 2
79671: NEG
79672: PUSH
79673: LD_INT 4
79675: NEG
79676: PUSH
79677: EMPTY
79678: LIST
79679: LIST
79680: PUSH
79681: LD_INT 4
79683: NEG
79684: PUSH
79685: LD_INT 2
79687: NEG
79688: PUSH
79689: EMPTY
79690: LIST
79691: LIST
79692: PUSH
79693: LD_INT 0
79695: PUSH
79696: LD_INT 4
79698: NEG
79699: PUSH
79700: EMPTY
79701: LIST
79702: LIST
79703: PUSH
79704: LD_INT 0
79706: PUSH
79707: LD_INT 5
79709: NEG
79710: PUSH
79711: EMPTY
79712: LIST
79713: LIST
79714: PUSH
79715: LD_INT 1
79717: PUSH
79718: LD_INT 4
79720: NEG
79721: PUSH
79722: EMPTY
79723: LIST
79724: LIST
79725: PUSH
79726: LD_INT 1
79728: PUSH
79729: LD_INT 3
79731: NEG
79732: PUSH
79733: EMPTY
79734: LIST
79735: LIST
79736: PUSH
79737: LD_INT 0
79739: PUSH
79740: LD_INT 3
79742: NEG
79743: PUSH
79744: EMPTY
79745: LIST
79746: LIST
79747: PUSH
79748: LD_INT 1
79750: NEG
79751: PUSH
79752: LD_INT 4
79754: NEG
79755: PUSH
79756: EMPTY
79757: LIST
79758: LIST
79759: PUSH
79760: LD_INT 1
79762: NEG
79763: PUSH
79764: LD_INT 5
79766: NEG
79767: PUSH
79768: EMPTY
79769: LIST
79770: LIST
79771: PUSH
79772: LD_INT 2
79774: PUSH
79775: LD_INT 3
79777: NEG
79778: PUSH
79779: EMPTY
79780: LIST
79781: LIST
79782: PUSH
79783: LD_INT 2
79785: NEG
79786: PUSH
79787: LD_INT 5
79789: NEG
79790: PUSH
79791: EMPTY
79792: LIST
79793: LIST
79794: PUSH
79795: LD_INT 3
79797: PUSH
79798: LD_INT 0
79800: PUSH
79801: EMPTY
79802: LIST
79803: LIST
79804: PUSH
79805: LD_INT 3
79807: PUSH
79808: LD_INT 1
79810: NEG
79811: PUSH
79812: EMPTY
79813: LIST
79814: LIST
79815: PUSH
79816: LD_INT 4
79818: PUSH
79819: LD_INT 0
79821: PUSH
79822: EMPTY
79823: LIST
79824: LIST
79825: PUSH
79826: LD_INT 4
79828: PUSH
79829: LD_INT 1
79831: PUSH
79832: EMPTY
79833: LIST
79834: LIST
79835: PUSH
79836: LD_INT 3
79838: PUSH
79839: LD_INT 1
79841: PUSH
79842: EMPTY
79843: LIST
79844: LIST
79845: PUSH
79846: LD_INT 2
79848: PUSH
79849: LD_INT 0
79851: PUSH
79852: EMPTY
79853: LIST
79854: LIST
79855: PUSH
79856: LD_INT 2
79858: PUSH
79859: LD_INT 1
79861: NEG
79862: PUSH
79863: EMPTY
79864: LIST
79865: LIST
79866: PUSH
79867: LD_INT 2
79869: PUSH
79870: LD_INT 2
79872: NEG
79873: PUSH
79874: EMPTY
79875: LIST
79876: LIST
79877: PUSH
79878: LD_INT 4
79880: PUSH
79881: LD_INT 2
79883: PUSH
79884: EMPTY
79885: LIST
79886: LIST
79887: PUSH
79888: LD_INT 4
79890: PUSH
79891: LD_INT 4
79893: PUSH
79894: EMPTY
79895: LIST
79896: LIST
79897: PUSH
79898: LD_INT 4
79900: PUSH
79901: LD_INT 3
79903: PUSH
79904: EMPTY
79905: LIST
79906: LIST
79907: PUSH
79908: LD_INT 5
79910: PUSH
79911: LD_INT 4
79913: PUSH
79914: EMPTY
79915: LIST
79916: LIST
79917: PUSH
79918: LD_INT 5
79920: PUSH
79921: LD_INT 5
79923: PUSH
79924: EMPTY
79925: LIST
79926: LIST
79927: PUSH
79928: LD_INT 4
79930: PUSH
79931: LD_INT 5
79933: PUSH
79934: EMPTY
79935: LIST
79936: LIST
79937: PUSH
79938: LD_INT 3
79940: PUSH
79941: LD_INT 4
79943: PUSH
79944: EMPTY
79945: LIST
79946: LIST
79947: PUSH
79948: LD_INT 3
79950: PUSH
79951: LD_INT 3
79953: PUSH
79954: EMPTY
79955: LIST
79956: LIST
79957: PUSH
79958: LD_INT 5
79960: PUSH
79961: LD_INT 3
79963: PUSH
79964: EMPTY
79965: LIST
79966: LIST
79967: PUSH
79968: LD_INT 3
79970: PUSH
79971: LD_INT 5
79973: PUSH
79974: EMPTY
79975: LIST
79976: LIST
79977: PUSH
79978: EMPTY
79979: LIST
79980: LIST
79981: LIST
79982: LIST
79983: LIST
79984: LIST
79985: LIST
79986: LIST
79987: LIST
79988: LIST
79989: LIST
79990: LIST
79991: LIST
79992: LIST
79993: LIST
79994: LIST
79995: LIST
79996: LIST
79997: LIST
79998: LIST
79999: LIST
80000: LIST
80001: LIST
80002: LIST
80003: LIST
80004: LIST
80005: LIST
80006: LIST
80007: LIST
80008: LIST
80009: LIST
80010: LIST
80011: LIST
80012: LIST
80013: LIST
80014: LIST
80015: LIST
80016: LIST
80017: LIST
80018: LIST
80019: LIST
80020: LIST
80021: LIST
80022: LIST
80023: LIST
80024: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
80025: LD_ADDR_VAR 0 33
80029: PUSH
80030: LD_INT 4
80032: NEG
80033: PUSH
80034: LD_INT 4
80036: NEG
80037: PUSH
80038: EMPTY
80039: LIST
80040: LIST
80041: PUSH
80042: LD_INT 4
80044: NEG
80045: PUSH
80046: LD_INT 5
80048: NEG
80049: PUSH
80050: EMPTY
80051: LIST
80052: LIST
80053: PUSH
80054: LD_INT 3
80056: NEG
80057: PUSH
80058: LD_INT 4
80060: NEG
80061: PUSH
80062: EMPTY
80063: LIST
80064: LIST
80065: PUSH
80066: LD_INT 3
80068: NEG
80069: PUSH
80070: LD_INT 3
80072: NEG
80073: PUSH
80074: EMPTY
80075: LIST
80076: LIST
80077: PUSH
80078: LD_INT 4
80080: NEG
80081: PUSH
80082: LD_INT 3
80084: NEG
80085: PUSH
80086: EMPTY
80087: LIST
80088: LIST
80089: PUSH
80090: LD_INT 5
80092: NEG
80093: PUSH
80094: LD_INT 4
80096: NEG
80097: PUSH
80098: EMPTY
80099: LIST
80100: LIST
80101: PUSH
80102: LD_INT 5
80104: NEG
80105: PUSH
80106: LD_INT 5
80108: NEG
80109: PUSH
80110: EMPTY
80111: LIST
80112: LIST
80113: PUSH
80114: LD_INT 3
80116: NEG
80117: PUSH
80118: LD_INT 5
80120: NEG
80121: PUSH
80122: EMPTY
80123: LIST
80124: LIST
80125: PUSH
80126: LD_INT 5
80128: NEG
80129: PUSH
80130: LD_INT 3
80132: NEG
80133: PUSH
80134: EMPTY
80135: LIST
80136: LIST
80137: PUSH
80138: LD_INT 0
80140: PUSH
80141: LD_INT 3
80143: NEG
80144: PUSH
80145: EMPTY
80146: LIST
80147: LIST
80148: PUSH
80149: LD_INT 0
80151: PUSH
80152: LD_INT 4
80154: NEG
80155: PUSH
80156: EMPTY
80157: LIST
80158: LIST
80159: PUSH
80160: LD_INT 1
80162: PUSH
80163: LD_INT 3
80165: NEG
80166: PUSH
80167: EMPTY
80168: LIST
80169: LIST
80170: PUSH
80171: LD_INT 1
80173: PUSH
80174: LD_INT 2
80176: NEG
80177: PUSH
80178: EMPTY
80179: LIST
80180: LIST
80181: PUSH
80182: LD_INT 0
80184: PUSH
80185: LD_INT 2
80187: NEG
80188: PUSH
80189: EMPTY
80190: LIST
80191: LIST
80192: PUSH
80193: LD_INT 1
80195: NEG
80196: PUSH
80197: LD_INT 3
80199: NEG
80200: PUSH
80201: EMPTY
80202: LIST
80203: LIST
80204: PUSH
80205: LD_INT 1
80207: NEG
80208: PUSH
80209: LD_INT 4
80211: NEG
80212: PUSH
80213: EMPTY
80214: LIST
80215: LIST
80216: PUSH
80217: LD_INT 2
80219: PUSH
80220: LD_INT 2
80222: NEG
80223: PUSH
80224: EMPTY
80225: LIST
80226: LIST
80227: PUSH
80228: LD_INT 2
80230: NEG
80231: PUSH
80232: LD_INT 4
80234: NEG
80235: PUSH
80236: EMPTY
80237: LIST
80238: LIST
80239: PUSH
80240: LD_INT 4
80242: PUSH
80243: LD_INT 0
80245: PUSH
80246: EMPTY
80247: LIST
80248: LIST
80249: PUSH
80250: LD_INT 4
80252: PUSH
80253: LD_INT 1
80255: NEG
80256: PUSH
80257: EMPTY
80258: LIST
80259: LIST
80260: PUSH
80261: LD_INT 5
80263: PUSH
80264: LD_INT 0
80266: PUSH
80267: EMPTY
80268: LIST
80269: LIST
80270: PUSH
80271: LD_INT 5
80273: PUSH
80274: LD_INT 1
80276: PUSH
80277: EMPTY
80278: LIST
80279: LIST
80280: PUSH
80281: LD_INT 4
80283: PUSH
80284: LD_INT 1
80286: PUSH
80287: EMPTY
80288: LIST
80289: LIST
80290: PUSH
80291: LD_INT 3
80293: PUSH
80294: LD_INT 0
80296: PUSH
80297: EMPTY
80298: LIST
80299: LIST
80300: PUSH
80301: LD_INT 3
80303: PUSH
80304: LD_INT 1
80306: NEG
80307: PUSH
80308: EMPTY
80309: LIST
80310: LIST
80311: PUSH
80312: LD_INT 3
80314: PUSH
80315: LD_INT 2
80317: NEG
80318: PUSH
80319: EMPTY
80320: LIST
80321: LIST
80322: PUSH
80323: LD_INT 5
80325: PUSH
80326: LD_INT 2
80328: PUSH
80329: EMPTY
80330: LIST
80331: LIST
80332: PUSH
80333: LD_INT 3
80335: PUSH
80336: LD_INT 3
80338: PUSH
80339: EMPTY
80340: LIST
80341: LIST
80342: PUSH
80343: LD_INT 3
80345: PUSH
80346: LD_INT 2
80348: PUSH
80349: EMPTY
80350: LIST
80351: LIST
80352: PUSH
80353: LD_INT 4
80355: PUSH
80356: LD_INT 3
80358: PUSH
80359: EMPTY
80360: LIST
80361: LIST
80362: PUSH
80363: LD_INT 4
80365: PUSH
80366: LD_INT 4
80368: PUSH
80369: EMPTY
80370: LIST
80371: LIST
80372: PUSH
80373: LD_INT 3
80375: PUSH
80376: LD_INT 4
80378: PUSH
80379: EMPTY
80380: LIST
80381: LIST
80382: PUSH
80383: LD_INT 2
80385: PUSH
80386: LD_INT 3
80388: PUSH
80389: EMPTY
80390: LIST
80391: LIST
80392: PUSH
80393: LD_INT 2
80395: PUSH
80396: LD_INT 2
80398: PUSH
80399: EMPTY
80400: LIST
80401: LIST
80402: PUSH
80403: LD_INT 4
80405: PUSH
80406: LD_INT 2
80408: PUSH
80409: EMPTY
80410: LIST
80411: LIST
80412: PUSH
80413: LD_INT 2
80415: PUSH
80416: LD_INT 4
80418: PUSH
80419: EMPTY
80420: LIST
80421: LIST
80422: PUSH
80423: LD_INT 0
80425: PUSH
80426: LD_INT 4
80428: PUSH
80429: EMPTY
80430: LIST
80431: LIST
80432: PUSH
80433: LD_INT 0
80435: PUSH
80436: LD_INT 3
80438: PUSH
80439: EMPTY
80440: LIST
80441: LIST
80442: PUSH
80443: LD_INT 1
80445: PUSH
80446: LD_INT 4
80448: PUSH
80449: EMPTY
80450: LIST
80451: LIST
80452: PUSH
80453: LD_INT 1
80455: PUSH
80456: LD_INT 5
80458: PUSH
80459: EMPTY
80460: LIST
80461: LIST
80462: PUSH
80463: LD_INT 0
80465: PUSH
80466: LD_INT 5
80468: PUSH
80469: EMPTY
80470: LIST
80471: LIST
80472: PUSH
80473: LD_INT 1
80475: NEG
80476: PUSH
80477: LD_INT 4
80479: PUSH
80480: EMPTY
80481: LIST
80482: LIST
80483: PUSH
80484: LD_INT 1
80486: NEG
80487: PUSH
80488: LD_INT 3
80490: PUSH
80491: EMPTY
80492: LIST
80493: LIST
80494: PUSH
80495: LD_INT 2
80497: PUSH
80498: LD_INT 5
80500: PUSH
80501: EMPTY
80502: LIST
80503: LIST
80504: PUSH
80505: LD_INT 2
80507: NEG
80508: PUSH
80509: LD_INT 3
80511: PUSH
80512: EMPTY
80513: LIST
80514: LIST
80515: PUSH
80516: EMPTY
80517: LIST
80518: LIST
80519: LIST
80520: LIST
80521: LIST
80522: LIST
80523: LIST
80524: LIST
80525: LIST
80526: LIST
80527: LIST
80528: LIST
80529: LIST
80530: LIST
80531: LIST
80532: LIST
80533: LIST
80534: LIST
80535: LIST
80536: LIST
80537: LIST
80538: LIST
80539: LIST
80540: LIST
80541: LIST
80542: LIST
80543: LIST
80544: LIST
80545: LIST
80546: LIST
80547: LIST
80548: LIST
80549: LIST
80550: LIST
80551: LIST
80552: LIST
80553: LIST
80554: LIST
80555: LIST
80556: LIST
80557: LIST
80558: LIST
80559: LIST
80560: LIST
80561: LIST
80562: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
80563: LD_ADDR_VAR 0 34
80567: PUSH
80568: LD_INT 0
80570: PUSH
80571: LD_INT 4
80573: NEG
80574: PUSH
80575: EMPTY
80576: LIST
80577: LIST
80578: PUSH
80579: LD_INT 0
80581: PUSH
80582: LD_INT 5
80584: NEG
80585: PUSH
80586: EMPTY
80587: LIST
80588: LIST
80589: PUSH
80590: LD_INT 1
80592: PUSH
80593: LD_INT 4
80595: NEG
80596: PUSH
80597: EMPTY
80598: LIST
80599: LIST
80600: PUSH
80601: LD_INT 1
80603: PUSH
80604: LD_INT 3
80606: NEG
80607: PUSH
80608: EMPTY
80609: LIST
80610: LIST
80611: PUSH
80612: LD_INT 0
80614: PUSH
80615: LD_INT 3
80617: NEG
80618: PUSH
80619: EMPTY
80620: LIST
80621: LIST
80622: PUSH
80623: LD_INT 1
80625: NEG
80626: PUSH
80627: LD_INT 4
80629: NEG
80630: PUSH
80631: EMPTY
80632: LIST
80633: LIST
80634: PUSH
80635: LD_INT 1
80637: NEG
80638: PUSH
80639: LD_INT 5
80641: NEG
80642: PUSH
80643: EMPTY
80644: LIST
80645: LIST
80646: PUSH
80647: LD_INT 2
80649: PUSH
80650: LD_INT 3
80652: NEG
80653: PUSH
80654: EMPTY
80655: LIST
80656: LIST
80657: PUSH
80658: LD_INT 2
80660: NEG
80661: PUSH
80662: LD_INT 5
80664: NEG
80665: PUSH
80666: EMPTY
80667: LIST
80668: LIST
80669: PUSH
80670: LD_INT 3
80672: PUSH
80673: LD_INT 0
80675: PUSH
80676: EMPTY
80677: LIST
80678: LIST
80679: PUSH
80680: LD_INT 3
80682: PUSH
80683: LD_INT 1
80685: NEG
80686: PUSH
80687: EMPTY
80688: LIST
80689: LIST
80690: PUSH
80691: LD_INT 4
80693: PUSH
80694: LD_INT 0
80696: PUSH
80697: EMPTY
80698: LIST
80699: LIST
80700: PUSH
80701: LD_INT 4
80703: PUSH
80704: LD_INT 1
80706: PUSH
80707: EMPTY
80708: LIST
80709: LIST
80710: PUSH
80711: LD_INT 3
80713: PUSH
80714: LD_INT 1
80716: PUSH
80717: EMPTY
80718: LIST
80719: LIST
80720: PUSH
80721: LD_INT 2
80723: PUSH
80724: LD_INT 0
80726: PUSH
80727: EMPTY
80728: LIST
80729: LIST
80730: PUSH
80731: LD_INT 2
80733: PUSH
80734: LD_INT 1
80736: NEG
80737: PUSH
80738: EMPTY
80739: LIST
80740: LIST
80741: PUSH
80742: LD_INT 2
80744: PUSH
80745: LD_INT 2
80747: NEG
80748: PUSH
80749: EMPTY
80750: LIST
80751: LIST
80752: PUSH
80753: LD_INT 4
80755: PUSH
80756: LD_INT 2
80758: PUSH
80759: EMPTY
80760: LIST
80761: LIST
80762: PUSH
80763: LD_INT 4
80765: PUSH
80766: LD_INT 4
80768: PUSH
80769: EMPTY
80770: LIST
80771: LIST
80772: PUSH
80773: LD_INT 4
80775: PUSH
80776: LD_INT 3
80778: PUSH
80779: EMPTY
80780: LIST
80781: LIST
80782: PUSH
80783: LD_INT 5
80785: PUSH
80786: LD_INT 4
80788: PUSH
80789: EMPTY
80790: LIST
80791: LIST
80792: PUSH
80793: LD_INT 5
80795: PUSH
80796: LD_INT 5
80798: PUSH
80799: EMPTY
80800: LIST
80801: LIST
80802: PUSH
80803: LD_INT 4
80805: PUSH
80806: LD_INT 5
80808: PUSH
80809: EMPTY
80810: LIST
80811: LIST
80812: PUSH
80813: LD_INT 3
80815: PUSH
80816: LD_INT 4
80818: PUSH
80819: EMPTY
80820: LIST
80821: LIST
80822: PUSH
80823: LD_INT 3
80825: PUSH
80826: LD_INT 3
80828: PUSH
80829: EMPTY
80830: LIST
80831: LIST
80832: PUSH
80833: LD_INT 5
80835: PUSH
80836: LD_INT 3
80838: PUSH
80839: EMPTY
80840: LIST
80841: LIST
80842: PUSH
80843: LD_INT 3
80845: PUSH
80846: LD_INT 5
80848: PUSH
80849: EMPTY
80850: LIST
80851: LIST
80852: PUSH
80853: LD_INT 0
80855: PUSH
80856: LD_INT 3
80858: PUSH
80859: EMPTY
80860: LIST
80861: LIST
80862: PUSH
80863: LD_INT 0
80865: PUSH
80866: LD_INT 2
80868: PUSH
80869: EMPTY
80870: LIST
80871: LIST
80872: PUSH
80873: LD_INT 1
80875: PUSH
80876: LD_INT 3
80878: PUSH
80879: EMPTY
80880: LIST
80881: LIST
80882: PUSH
80883: LD_INT 1
80885: PUSH
80886: LD_INT 4
80888: PUSH
80889: EMPTY
80890: LIST
80891: LIST
80892: PUSH
80893: LD_INT 0
80895: PUSH
80896: LD_INT 4
80898: PUSH
80899: EMPTY
80900: LIST
80901: LIST
80902: PUSH
80903: LD_INT 1
80905: NEG
80906: PUSH
80907: LD_INT 3
80909: PUSH
80910: EMPTY
80911: LIST
80912: LIST
80913: PUSH
80914: LD_INT 1
80916: NEG
80917: PUSH
80918: LD_INT 2
80920: PUSH
80921: EMPTY
80922: LIST
80923: LIST
80924: PUSH
80925: LD_INT 2
80927: PUSH
80928: LD_INT 4
80930: PUSH
80931: EMPTY
80932: LIST
80933: LIST
80934: PUSH
80935: LD_INT 2
80937: NEG
80938: PUSH
80939: LD_INT 2
80941: PUSH
80942: EMPTY
80943: LIST
80944: LIST
80945: PUSH
80946: LD_INT 4
80948: NEG
80949: PUSH
80950: LD_INT 0
80952: PUSH
80953: EMPTY
80954: LIST
80955: LIST
80956: PUSH
80957: LD_INT 4
80959: NEG
80960: PUSH
80961: LD_INT 1
80963: NEG
80964: PUSH
80965: EMPTY
80966: LIST
80967: LIST
80968: PUSH
80969: LD_INT 3
80971: NEG
80972: PUSH
80973: LD_INT 0
80975: PUSH
80976: EMPTY
80977: LIST
80978: LIST
80979: PUSH
80980: LD_INT 3
80982: NEG
80983: PUSH
80984: LD_INT 1
80986: PUSH
80987: EMPTY
80988: LIST
80989: LIST
80990: PUSH
80991: LD_INT 4
80993: NEG
80994: PUSH
80995: LD_INT 1
80997: PUSH
80998: EMPTY
80999: LIST
81000: LIST
81001: PUSH
81002: LD_INT 5
81004: NEG
81005: PUSH
81006: LD_INT 0
81008: PUSH
81009: EMPTY
81010: LIST
81011: LIST
81012: PUSH
81013: LD_INT 5
81015: NEG
81016: PUSH
81017: LD_INT 1
81019: NEG
81020: PUSH
81021: EMPTY
81022: LIST
81023: LIST
81024: PUSH
81025: LD_INT 5
81027: NEG
81028: PUSH
81029: LD_INT 2
81031: NEG
81032: PUSH
81033: EMPTY
81034: LIST
81035: LIST
81036: PUSH
81037: LD_INT 3
81039: NEG
81040: PUSH
81041: LD_INT 2
81043: PUSH
81044: EMPTY
81045: LIST
81046: LIST
81047: PUSH
81048: EMPTY
81049: LIST
81050: LIST
81051: LIST
81052: LIST
81053: LIST
81054: LIST
81055: LIST
81056: LIST
81057: LIST
81058: LIST
81059: LIST
81060: LIST
81061: LIST
81062: LIST
81063: LIST
81064: LIST
81065: LIST
81066: LIST
81067: LIST
81068: LIST
81069: LIST
81070: LIST
81071: LIST
81072: LIST
81073: LIST
81074: LIST
81075: LIST
81076: LIST
81077: LIST
81078: LIST
81079: LIST
81080: LIST
81081: LIST
81082: LIST
81083: LIST
81084: LIST
81085: LIST
81086: LIST
81087: LIST
81088: LIST
81089: LIST
81090: LIST
81091: LIST
81092: LIST
81093: LIST
81094: ST_TO_ADDR
// end ; end ;
81095: GO 81098
81097: POP
// case btype of b_depot , b_warehouse :
81098: LD_VAR 0 1
81102: PUSH
81103: LD_INT 0
81105: DOUBLE
81106: EQUAL
81107: IFTRUE 81117
81109: LD_INT 1
81111: DOUBLE
81112: EQUAL
81113: IFTRUE 81117
81115: GO 81318
81117: POP
// case nation of nation_american :
81118: LD_VAR 0 5
81122: PUSH
81123: LD_INT 1
81125: DOUBLE
81126: EQUAL
81127: IFTRUE 81131
81129: GO 81187
81131: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
81132: LD_ADDR_VAR 0 9
81136: PUSH
81137: LD_VAR 0 11
81141: PUSH
81142: LD_VAR 0 12
81146: PUSH
81147: LD_VAR 0 13
81151: PUSH
81152: LD_VAR 0 14
81156: PUSH
81157: LD_VAR 0 15
81161: PUSH
81162: LD_VAR 0 16
81166: PUSH
81167: EMPTY
81168: LIST
81169: LIST
81170: LIST
81171: LIST
81172: LIST
81173: LIST
81174: PUSH
81175: LD_VAR 0 4
81179: PUSH
81180: LD_INT 1
81182: PLUS
81183: ARRAY
81184: ST_TO_ADDR
81185: GO 81316
81187: LD_INT 2
81189: DOUBLE
81190: EQUAL
81191: IFTRUE 81195
81193: GO 81251
81195: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
81196: LD_ADDR_VAR 0 9
81200: PUSH
81201: LD_VAR 0 17
81205: PUSH
81206: LD_VAR 0 18
81210: PUSH
81211: LD_VAR 0 19
81215: PUSH
81216: LD_VAR 0 20
81220: PUSH
81221: LD_VAR 0 21
81225: PUSH
81226: LD_VAR 0 22
81230: PUSH
81231: EMPTY
81232: LIST
81233: LIST
81234: LIST
81235: LIST
81236: LIST
81237: LIST
81238: PUSH
81239: LD_VAR 0 4
81243: PUSH
81244: LD_INT 1
81246: PLUS
81247: ARRAY
81248: ST_TO_ADDR
81249: GO 81316
81251: LD_INT 3
81253: DOUBLE
81254: EQUAL
81255: IFTRUE 81259
81257: GO 81315
81259: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
81260: LD_ADDR_VAR 0 9
81264: PUSH
81265: LD_VAR 0 23
81269: PUSH
81270: LD_VAR 0 24
81274: PUSH
81275: LD_VAR 0 25
81279: PUSH
81280: LD_VAR 0 26
81284: PUSH
81285: LD_VAR 0 27
81289: PUSH
81290: LD_VAR 0 28
81294: PUSH
81295: EMPTY
81296: LIST
81297: LIST
81298: LIST
81299: LIST
81300: LIST
81301: LIST
81302: PUSH
81303: LD_VAR 0 4
81307: PUSH
81308: LD_INT 1
81310: PLUS
81311: ARRAY
81312: ST_TO_ADDR
81313: GO 81316
81315: POP
81316: GO 81871
81318: LD_INT 2
81320: DOUBLE
81321: EQUAL
81322: IFTRUE 81332
81324: LD_INT 3
81326: DOUBLE
81327: EQUAL
81328: IFTRUE 81332
81330: GO 81388
81332: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
81333: LD_ADDR_VAR 0 9
81337: PUSH
81338: LD_VAR 0 29
81342: PUSH
81343: LD_VAR 0 30
81347: PUSH
81348: LD_VAR 0 31
81352: PUSH
81353: LD_VAR 0 32
81357: PUSH
81358: LD_VAR 0 33
81362: PUSH
81363: LD_VAR 0 34
81367: PUSH
81368: EMPTY
81369: LIST
81370: LIST
81371: LIST
81372: LIST
81373: LIST
81374: LIST
81375: PUSH
81376: LD_VAR 0 4
81380: PUSH
81381: LD_INT 1
81383: PLUS
81384: ARRAY
81385: ST_TO_ADDR
81386: GO 81871
81388: LD_INT 16
81390: DOUBLE
81391: EQUAL
81392: IFTRUE 81450
81394: LD_INT 17
81396: DOUBLE
81397: EQUAL
81398: IFTRUE 81450
81400: LD_INT 18
81402: DOUBLE
81403: EQUAL
81404: IFTRUE 81450
81406: LD_INT 19
81408: DOUBLE
81409: EQUAL
81410: IFTRUE 81450
81412: LD_INT 22
81414: DOUBLE
81415: EQUAL
81416: IFTRUE 81450
81418: LD_INT 20
81420: DOUBLE
81421: EQUAL
81422: IFTRUE 81450
81424: LD_INT 21
81426: DOUBLE
81427: EQUAL
81428: IFTRUE 81450
81430: LD_INT 23
81432: DOUBLE
81433: EQUAL
81434: IFTRUE 81450
81436: LD_INT 24
81438: DOUBLE
81439: EQUAL
81440: IFTRUE 81450
81442: LD_INT 25
81444: DOUBLE
81445: EQUAL
81446: IFTRUE 81450
81448: GO 81506
81450: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
81451: LD_ADDR_VAR 0 9
81455: PUSH
81456: LD_VAR 0 35
81460: PUSH
81461: LD_VAR 0 36
81465: PUSH
81466: LD_VAR 0 37
81470: PUSH
81471: LD_VAR 0 38
81475: PUSH
81476: LD_VAR 0 39
81480: PUSH
81481: LD_VAR 0 40
81485: PUSH
81486: EMPTY
81487: LIST
81488: LIST
81489: LIST
81490: LIST
81491: LIST
81492: LIST
81493: PUSH
81494: LD_VAR 0 4
81498: PUSH
81499: LD_INT 1
81501: PLUS
81502: ARRAY
81503: ST_TO_ADDR
81504: GO 81871
81506: LD_INT 6
81508: DOUBLE
81509: EQUAL
81510: IFTRUE 81562
81512: LD_INT 7
81514: DOUBLE
81515: EQUAL
81516: IFTRUE 81562
81518: LD_INT 8
81520: DOUBLE
81521: EQUAL
81522: IFTRUE 81562
81524: LD_INT 13
81526: DOUBLE
81527: EQUAL
81528: IFTRUE 81562
81530: LD_INT 12
81532: DOUBLE
81533: EQUAL
81534: IFTRUE 81562
81536: LD_INT 15
81538: DOUBLE
81539: EQUAL
81540: IFTRUE 81562
81542: LD_INT 11
81544: DOUBLE
81545: EQUAL
81546: IFTRUE 81562
81548: LD_INT 14
81550: DOUBLE
81551: EQUAL
81552: IFTRUE 81562
81554: LD_INT 10
81556: DOUBLE
81557: EQUAL
81558: IFTRUE 81562
81560: GO 81618
81562: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
81563: LD_ADDR_VAR 0 9
81567: PUSH
81568: LD_VAR 0 41
81572: PUSH
81573: LD_VAR 0 42
81577: PUSH
81578: LD_VAR 0 43
81582: PUSH
81583: LD_VAR 0 44
81587: PUSH
81588: LD_VAR 0 45
81592: PUSH
81593: LD_VAR 0 46
81597: PUSH
81598: EMPTY
81599: LIST
81600: LIST
81601: LIST
81602: LIST
81603: LIST
81604: LIST
81605: PUSH
81606: LD_VAR 0 4
81610: PUSH
81611: LD_INT 1
81613: PLUS
81614: ARRAY
81615: ST_TO_ADDR
81616: GO 81871
81618: LD_INT 36
81620: DOUBLE
81621: EQUAL
81622: IFTRUE 81626
81624: GO 81682
81626: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
81627: LD_ADDR_VAR 0 9
81631: PUSH
81632: LD_VAR 0 47
81636: PUSH
81637: LD_VAR 0 48
81641: PUSH
81642: LD_VAR 0 49
81646: PUSH
81647: LD_VAR 0 50
81651: PUSH
81652: LD_VAR 0 51
81656: PUSH
81657: LD_VAR 0 52
81661: PUSH
81662: EMPTY
81663: LIST
81664: LIST
81665: LIST
81666: LIST
81667: LIST
81668: LIST
81669: PUSH
81670: LD_VAR 0 4
81674: PUSH
81675: LD_INT 1
81677: PLUS
81678: ARRAY
81679: ST_TO_ADDR
81680: GO 81871
81682: LD_INT 4
81684: DOUBLE
81685: EQUAL
81686: IFTRUE 81708
81688: LD_INT 5
81690: DOUBLE
81691: EQUAL
81692: IFTRUE 81708
81694: LD_INT 34
81696: DOUBLE
81697: EQUAL
81698: IFTRUE 81708
81700: LD_INT 37
81702: DOUBLE
81703: EQUAL
81704: IFTRUE 81708
81706: GO 81764
81708: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
81709: LD_ADDR_VAR 0 9
81713: PUSH
81714: LD_VAR 0 53
81718: PUSH
81719: LD_VAR 0 54
81723: PUSH
81724: LD_VAR 0 55
81728: PUSH
81729: LD_VAR 0 56
81733: PUSH
81734: LD_VAR 0 57
81738: PUSH
81739: LD_VAR 0 58
81743: PUSH
81744: EMPTY
81745: LIST
81746: LIST
81747: LIST
81748: LIST
81749: LIST
81750: LIST
81751: PUSH
81752: LD_VAR 0 4
81756: PUSH
81757: LD_INT 1
81759: PLUS
81760: ARRAY
81761: ST_TO_ADDR
81762: GO 81871
81764: LD_INT 31
81766: DOUBLE
81767: EQUAL
81768: IFTRUE 81814
81770: LD_INT 32
81772: DOUBLE
81773: EQUAL
81774: IFTRUE 81814
81776: LD_INT 33
81778: DOUBLE
81779: EQUAL
81780: IFTRUE 81814
81782: LD_INT 27
81784: DOUBLE
81785: EQUAL
81786: IFTRUE 81814
81788: LD_INT 26
81790: DOUBLE
81791: EQUAL
81792: IFTRUE 81814
81794: LD_INT 28
81796: DOUBLE
81797: EQUAL
81798: IFTRUE 81814
81800: LD_INT 29
81802: DOUBLE
81803: EQUAL
81804: IFTRUE 81814
81806: LD_INT 30
81808: DOUBLE
81809: EQUAL
81810: IFTRUE 81814
81812: GO 81870
81814: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
81815: LD_ADDR_VAR 0 9
81819: PUSH
81820: LD_VAR 0 59
81824: PUSH
81825: LD_VAR 0 60
81829: PUSH
81830: LD_VAR 0 61
81834: PUSH
81835: LD_VAR 0 62
81839: PUSH
81840: LD_VAR 0 63
81844: PUSH
81845: LD_VAR 0 64
81849: PUSH
81850: EMPTY
81851: LIST
81852: LIST
81853: LIST
81854: LIST
81855: LIST
81856: LIST
81857: PUSH
81858: LD_VAR 0 4
81862: PUSH
81863: LD_INT 1
81865: PLUS
81866: ARRAY
81867: ST_TO_ADDR
81868: GO 81871
81870: POP
// temp_list2 = [ ] ;
81871: LD_ADDR_VAR 0 10
81875: PUSH
81876: EMPTY
81877: ST_TO_ADDR
// for i in temp_list do
81878: LD_ADDR_VAR 0 8
81882: PUSH
81883: LD_VAR 0 9
81887: PUSH
81888: FOR_IN
81889: IFFALSE 81941
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
81891: LD_ADDR_VAR 0 10
81895: PUSH
81896: LD_VAR 0 10
81900: PUSH
81901: LD_VAR 0 8
81905: PUSH
81906: LD_INT 1
81908: ARRAY
81909: PUSH
81910: LD_VAR 0 2
81914: PLUS
81915: PUSH
81916: LD_VAR 0 8
81920: PUSH
81921: LD_INT 2
81923: ARRAY
81924: PUSH
81925: LD_VAR 0 3
81929: PLUS
81930: PUSH
81931: EMPTY
81932: LIST
81933: LIST
81934: PUSH
81935: EMPTY
81936: LIST
81937: ADD
81938: ST_TO_ADDR
81939: GO 81888
81941: POP
81942: POP
// result = temp_list2 ;
81943: LD_ADDR_VAR 0 7
81947: PUSH
81948: LD_VAR 0 10
81952: ST_TO_ADDR
// end ;
81953: LD_VAR 0 7
81957: RET
// export function EnemyInRange ( unit , dist ) ; begin
81958: LD_INT 0
81960: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
81961: LD_ADDR_VAR 0 3
81965: PUSH
81966: LD_VAR 0 1
81970: PPUSH
81971: CALL_OW 255
81975: PPUSH
81976: LD_VAR 0 1
81980: PPUSH
81981: CALL_OW 250
81985: PPUSH
81986: LD_VAR 0 1
81990: PPUSH
81991: CALL_OW 251
81995: PPUSH
81996: LD_VAR 0 2
82000: PPUSH
82001: CALL 55331 0 4
82005: PUSH
82006: LD_INT 4
82008: ARRAY
82009: ST_TO_ADDR
// end ;
82010: LD_VAR 0 3
82014: RET
// export function PlayerSeeMe ( unit ) ; begin
82015: LD_INT 0
82017: PPUSH
// result := See ( your_side , unit ) ;
82018: LD_ADDR_VAR 0 2
82022: PUSH
82023: LD_OWVAR 2
82027: PPUSH
82028: LD_VAR 0 1
82032: PPUSH
82033: CALL_OW 292
82037: ST_TO_ADDR
// end ;
82038: LD_VAR 0 2
82042: RET
// export function ReverseDir ( unit ) ; begin
82043: LD_INT 0
82045: PPUSH
// if not unit then
82046: LD_VAR 0 1
82050: NOT
82051: IFFALSE 82055
// exit ;
82053: GO 82078
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
82055: LD_ADDR_VAR 0 2
82059: PUSH
82060: LD_VAR 0 1
82064: PPUSH
82065: CALL_OW 254
82069: PUSH
82070: LD_INT 3
82072: PLUS
82073: PUSH
82074: LD_INT 6
82076: MOD
82077: ST_TO_ADDR
// end ;
82078: LD_VAR 0 2
82082: RET
// export function ReverseArray ( array ) ; var i ; begin
82083: LD_INT 0
82085: PPUSH
82086: PPUSH
// if not array then
82087: LD_VAR 0 1
82091: NOT
82092: IFFALSE 82096
// exit ;
82094: GO 82151
// result := [ ] ;
82096: LD_ADDR_VAR 0 2
82100: PUSH
82101: EMPTY
82102: ST_TO_ADDR
// for i := array downto 1 do
82103: LD_ADDR_VAR 0 3
82107: PUSH
82108: DOUBLE
82109: LD_VAR 0 1
82113: INC
82114: ST_TO_ADDR
82115: LD_INT 1
82117: PUSH
82118: FOR_DOWNTO
82119: IFFALSE 82149
// result := Join ( result , array [ i ] ) ;
82121: LD_ADDR_VAR 0 2
82125: PUSH
82126: LD_VAR 0 2
82130: PPUSH
82131: LD_VAR 0 1
82135: PUSH
82136: LD_VAR 0 3
82140: ARRAY
82141: PPUSH
82142: CALL 86807 0 2
82146: ST_TO_ADDR
82147: GO 82118
82149: POP
82150: POP
// end ;
82151: LD_VAR 0 2
82155: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
82156: LD_INT 0
82158: PPUSH
82159: PPUSH
82160: PPUSH
82161: PPUSH
82162: PPUSH
82163: PPUSH
// if not unit or not hexes then
82164: LD_VAR 0 1
82168: NOT
82169: PUSH
82170: LD_VAR 0 2
82174: NOT
82175: OR
82176: IFFALSE 82180
// exit ;
82178: GO 82303
// dist := 9999 ;
82180: LD_ADDR_VAR 0 5
82184: PUSH
82185: LD_INT 9999
82187: ST_TO_ADDR
// for i = 1 to hexes do
82188: LD_ADDR_VAR 0 4
82192: PUSH
82193: DOUBLE
82194: LD_INT 1
82196: DEC
82197: ST_TO_ADDR
82198: LD_VAR 0 2
82202: PUSH
82203: FOR_TO
82204: IFFALSE 82291
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
82206: LD_ADDR_VAR 0 6
82210: PUSH
82211: LD_VAR 0 1
82215: PPUSH
82216: LD_VAR 0 2
82220: PUSH
82221: LD_VAR 0 4
82225: ARRAY
82226: PUSH
82227: LD_INT 1
82229: ARRAY
82230: PPUSH
82231: LD_VAR 0 2
82235: PUSH
82236: LD_VAR 0 4
82240: ARRAY
82241: PUSH
82242: LD_INT 2
82244: ARRAY
82245: PPUSH
82246: CALL_OW 297
82250: ST_TO_ADDR
// if tdist < dist then
82251: LD_VAR 0 6
82255: PUSH
82256: LD_VAR 0 5
82260: LESS
82261: IFFALSE 82289
// begin hex := hexes [ i ] ;
82263: LD_ADDR_VAR 0 8
82267: PUSH
82268: LD_VAR 0 2
82272: PUSH
82273: LD_VAR 0 4
82277: ARRAY
82278: ST_TO_ADDR
// dist := tdist ;
82279: LD_ADDR_VAR 0 5
82283: PUSH
82284: LD_VAR 0 6
82288: ST_TO_ADDR
// end ; end ;
82289: GO 82203
82291: POP
82292: POP
// result := hex ;
82293: LD_ADDR_VAR 0 3
82297: PUSH
82298: LD_VAR 0 8
82302: ST_TO_ADDR
// end ;
82303: LD_VAR 0 3
82307: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
82308: LD_INT 0
82310: PPUSH
82311: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
82312: LD_VAR 0 1
82316: NOT
82317: PUSH
82318: LD_VAR 0 1
82322: PUSH
82323: LD_INT 21
82325: PUSH
82326: LD_INT 2
82328: PUSH
82329: EMPTY
82330: LIST
82331: LIST
82332: PUSH
82333: LD_INT 23
82335: PUSH
82336: LD_INT 2
82338: PUSH
82339: EMPTY
82340: LIST
82341: LIST
82342: PUSH
82343: EMPTY
82344: LIST
82345: LIST
82346: PPUSH
82347: CALL_OW 69
82351: IN
82352: NOT
82353: OR
82354: IFFALSE 82358
// exit ;
82356: GO 82405
// for i = 1 to 3 do
82358: LD_ADDR_VAR 0 3
82362: PUSH
82363: DOUBLE
82364: LD_INT 1
82366: DEC
82367: ST_TO_ADDR
82368: LD_INT 3
82370: PUSH
82371: FOR_TO
82372: IFFALSE 82403
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
82374: LD_VAR 0 1
82378: PPUSH
82379: CALL_OW 250
82383: PPUSH
82384: LD_VAR 0 1
82388: PPUSH
82389: CALL_OW 251
82393: PPUSH
82394: LD_INT 1
82396: PPUSH
82397: CALL_OW 453
82401: GO 82371
82403: POP
82404: POP
// end ;
82405: LD_VAR 0 2
82409: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
82410: LD_INT 0
82412: PPUSH
82413: PPUSH
82414: PPUSH
82415: PPUSH
82416: PPUSH
82417: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
82418: LD_VAR 0 1
82422: NOT
82423: PUSH
82424: LD_VAR 0 2
82428: NOT
82429: OR
82430: PUSH
82431: LD_VAR 0 1
82435: PPUSH
82436: CALL_OW 314
82440: OR
82441: IFFALSE 82445
// exit ;
82443: GO 82912
// if GetLives ( i ) < 250 then
82445: LD_VAR 0 4
82449: PPUSH
82450: CALL_OW 256
82454: PUSH
82455: LD_INT 250
82457: LESS
82458: IFFALSE 82471
// begin ComAutodestruct ( i ) ;
82460: LD_VAR 0 4
82464: PPUSH
82465: CALL 82308 0 1
// exit ;
82469: GO 82912
// end ; x := GetX ( enemy_unit ) ;
82471: LD_ADDR_VAR 0 7
82475: PUSH
82476: LD_VAR 0 2
82480: PPUSH
82481: CALL_OW 250
82485: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
82486: LD_ADDR_VAR 0 8
82490: PUSH
82491: LD_VAR 0 2
82495: PPUSH
82496: CALL_OW 251
82500: ST_TO_ADDR
// if not x or not y then
82501: LD_VAR 0 7
82505: NOT
82506: PUSH
82507: LD_VAR 0 8
82511: NOT
82512: OR
82513: IFFALSE 82517
// exit ;
82515: GO 82912
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
82517: LD_ADDR_VAR 0 6
82521: PUSH
82522: LD_VAR 0 7
82526: PPUSH
82527: LD_INT 0
82529: PPUSH
82530: LD_INT 4
82532: PPUSH
82533: CALL_OW 272
82537: PUSH
82538: LD_VAR 0 8
82542: PPUSH
82543: LD_INT 0
82545: PPUSH
82546: LD_INT 4
82548: PPUSH
82549: CALL_OW 273
82553: PUSH
82554: EMPTY
82555: LIST
82556: LIST
82557: PUSH
82558: LD_VAR 0 7
82562: PPUSH
82563: LD_INT 1
82565: PPUSH
82566: LD_INT 4
82568: PPUSH
82569: CALL_OW 272
82573: PUSH
82574: LD_VAR 0 8
82578: PPUSH
82579: LD_INT 1
82581: PPUSH
82582: LD_INT 4
82584: PPUSH
82585: CALL_OW 273
82589: PUSH
82590: EMPTY
82591: LIST
82592: LIST
82593: PUSH
82594: LD_VAR 0 7
82598: PPUSH
82599: LD_INT 2
82601: PPUSH
82602: LD_INT 4
82604: PPUSH
82605: CALL_OW 272
82609: PUSH
82610: LD_VAR 0 8
82614: PPUSH
82615: LD_INT 2
82617: PPUSH
82618: LD_INT 4
82620: PPUSH
82621: CALL_OW 273
82625: PUSH
82626: EMPTY
82627: LIST
82628: LIST
82629: PUSH
82630: LD_VAR 0 7
82634: PPUSH
82635: LD_INT 3
82637: PPUSH
82638: LD_INT 4
82640: PPUSH
82641: CALL_OW 272
82645: PUSH
82646: LD_VAR 0 8
82650: PPUSH
82651: LD_INT 3
82653: PPUSH
82654: LD_INT 4
82656: PPUSH
82657: CALL_OW 273
82661: PUSH
82662: EMPTY
82663: LIST
82664: LIST
82665: PUSH
82666: LD_VAR 0 7
82670: PPUSH
82671: LD_INT 4
82673: PPUSH
82674: LD_INT 4
82676: PPUSH
82677: CALL_OW 272
82681: PUSH
82682: LD_VAR 0 8
82686: PPUSH
82687: LD_INT 4
82689: PPUSH
82690: LD_INT 4
82692: PPUSH
82693: CALL_OW 273
82697: PUSH
82698: EMPTY
82699: LIST
82700: LIST
82701: PUSH
82702: LD_VAR 0 7
82706: PPUSH
82707: LD_INT 5
82709: PPUSH
82710: LD_INT 4
82712: PPUSH
82713: CALL_OW 272
82717: PUSH
82718: LD_VAR 0 8
82722: PPUSH
82723: LD_INT 5
82725: PPUSH
82726: LD_INT 4
82728: PPUSH
82729: CALL_OW 273
82733: PUSH
82734: EMPTY
82735: LIST
82736: LIST
82737: PUSH
82738: EMPTY
82739: LIST
82740: LIST
82741: LIST
82742: LIST
82743: LIST
82744: LIST
82745: ST_TO_ADDR
// for i = tmp downto 1 do
82746: LD_ADDR_VAR 0 4
82750: PUSH
82751: DOUBLE
82752: LD_VAR 0 6
82756: INC
82757: ST_TO_ADDR
82758: LD_INT 1
82760: PUSH
82761: FOR_DOWNTO
82762: IFFALSE 82863
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
82764: LD_VAR 0 6
82768: PUSH
82769: LD_VAR 0 4
82773: ARRAY
82774: PUSH
82775: LD_INT 1
82777: ARRAY
82778: PPUSH
82779: LD_VAR 0 6
82783: PUSH
82784: LD_VAR 0 4
82788: ARRAY
82789: PUSH
82790: LD_INT 2
82792: ARRAY
82793: PPUSH
82794: CALL_OW 488
82798: NOT
82799: PUSH
82800: LD_VAR 0 6
82804: PUSH
82805: LD_VAR 0 4
82809: ARRAY
82810: PUSH
82811: LD_INT 1
82813: ARRAY
82814: PPUSH
82815: LD_VAR 0 6
82819: PUSH
82820: LD_VAR 0 4
82824: ARRAY
82825: PUSH
82826: LD_INT 2
82828: ARRAY
82829: PPUSH
82830: CALL_OW 428
82834: PUSH
82835: LD_INT 0
82837: NONEQUAL
82838: OR
82839: IFFALSE 82861
// tmp := Delete ( tmp , i ) ;
82841: LD_ADDR_VAR 0 6
82845: PUSH
82846: LD_VAR 0 6
82850: PPUSH
82851: LD_VAR 0 4
82855: PPUSH
82856: CALL_OW 3
82860: ST_TO_ADDR
82861: GO 82761
82863: POP
82864: POP
// j := GetClosestHex ( unit , tmp ) ;
82865: LD_ADDR_VAR 0 5
82869: PUSH
82870: LD_VAR 0 1
82874: PPUSH
82875: LD_VAR 0 6
82879: PPUSH
82880: CALL 82156 0 2
82884: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
82885: LD_VAR 0 1
82889: PPUSH
82890: LD_VAR 0 5
82894: PUSH
82895: LD_INT 1
82897: ARRAY
82898: PPUSH
82899: LD_VAR 0 5
82903: PUSH
82904: LD_INT 2
82906: ARRAY
82907: PPUSH
82908: CALL_OW 111
// end ;
82912: LD_VAR 0 3
82916: RET
// export function PrepareApemanSoldier ( ) ; begin
82917: LD_INT 0
82919: PPUSH
// uc_nation := 0 ;
82920: LD_ADDR_OWVAR 21
82924: PUSH
82925: LD_INT 0
82927: ST_TO_ADDR
// hc_sex := sex_male ;
82928: LD_ADDR_OWVAR 27
82932: PUSH
82933: LD_INT 1
82935: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
82936: LD_ADDR_OWVAR 28
82940: PUSH
82941: LD_INT 15
82943: ST_TO_ADDR
// hc_gallery :=  ;
82944: LD_ADDR_OWVAR 33
82948: PUSH
82949: LD_STRING 
82951: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
82952: LD_ADDR_OWVAR 31
82956: PUSH
82957: LD_INT 0
82959: PPUSH
82960: LD_INT 3
82962: PPUSH
82963: CALL_OW 12
82967: PUSH
82968: LD_INT 0
82970: PPUSH
82971: LD_INT 3
82973: PPUSH
82974: CALL_OW 12
82978: PUSH
82979: LD_INT 0
82981: PUSH
82982: LD_INT 0
82984: PUSH
82985: EMPTY
82986: LIST
82987: LIST
82988: LIST
82989: LIST
82990: ST_TO_ADDR
// end ;
82991: LD_VAR 0 1
82995: RET
// export function PrepareApemanEngineer ( ) ; begin
82996: LD_INT 0
82998: PPUSH
// uc_nation := 0 ;
82999: LD_ADDR_OWVAR 21
83003: PUSH
83004: LD_INT 0
83006: ST_TO_ADDR
// hc_sex := sex_male ;
83007: LD_ADDR_OWVAR 27
83011: PUSH
83012: LD_INT 1
83014: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
83015: LD_ADDR_OWVAR 28
83019: PUSH
83020: LD_INT 16
83022: ST_TO_ADDR
// hc_gallery :=  ;
83023: LD_ADDR_OWVAR 33
83027: PUSH
83028: LD_STRING 
83030: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
83031: LD_ADDR_OWVAR 31
83035: PUSH
83036: LD_INT 0
83038: PPUSH
83039: LD_INT 3
83041: PPUSH
83042: CALL_OW 12
83046: PUSH
83047: LD_INT 0
83049: PPUSH
83050: LD_INT 3
83052: PPUSH
83053: CALL_OW 12
83057: PUSH
83058: LD_INT 0
83060: PUSH
83061: LD_INT 0
83063: PUSH
83064: EMPTY
83065: LIST
83066: LIST
83067: LIST
83068: LIST
83069: ST_TO_ADDR
// end ;
83070: LD_VAR 0 1
83074: RET
// export function PrepareApeman ( agressivity ) ; begin
83075: LD_INT 0
83077: PPUSH
// uc_side := 0 ;
83078: LD_ADDR_OWVAR 20
83082: PUSH
83083: LD_INT 0
83085: ST_TO_ADDR
// uc_nation := 0 ;
83086: LD_ADDR_OWVAR 21
83090: PUSH
83091: LD_INT 0
83093: ST_TO_ADDR
// hc_sex := sex_male ;
83094: LD_ADDR_OWVAR 27
83098: PUSH
83099: LD_INT 1
83101: ST_TO_ADDR
// hc_class := class_apeman ;
83102: LD_ADDR_OWVAR 28
83106: PUSH
83107: LD_INT 12
83109: ST_TO_ADDR
// hc_gallery :=  ;
83110: LD_ADDR_OWVAR 33
83114: PUSH
83115: LD_STRING 
83117: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
83118: LD_ADDR_OWVAR 35
83122: PUSH
83123: LD_VAR 0 1
83127: NEG
83128: PPUSH
83129: LD_VAR 0 1
83133: PPUSH
83134: CALL_OW 12
83138: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
83139: LD_ADDR_OWVAR 31
83143: PUSH
83144: LD_INT 0
83146: PPUSH
83147: LD_INT 3
83149: PPUSH
83150: CALL_OW 12
83154: PUSH
83155: LD_INT 0
83157: PPUSH
83158: LD_INT 3
83160: PPUSH
83161: CALL_OW 12
83165: PUSH
83166: LD_INT 0
83168: PUSH
83169: LD_INT 0
83171: PUSH
83172: EMPTY
83173: LIST
83174: LIST
83175: LIST
83176: LIST
83177: ST_TO_ADDR
// end ;
83178: LD_VAR 0 2
83182: RET
// export function PrepareTiger ( agressivity ) ; begin
83183: LD_INT 0
83185: PPUSH
// uc_side := 0 ;
83186: LD_ADDR_OWVAR 20
83190: PUSH
83191: LD_INT 0
83193: ST_TO_ADDR
// uc_nation := 0 ;
83194: LD_ADDR_OWVAR 21
83198: PUSH
83199: LD_INT 0
83201: ST_TO_ADDR
// hc_class := class_tiger ;
83202: LD_ADDR_OWVAR 28
83206: PUSH
83207: LD_INT 14
83209: ST_TO_ADDR
// hc_gallery :=  ;
83210: LD_ADDR_OWVAR 33
83214: PUSH
83215: LD_STRING 
83217: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
83218: LD_ADDR_OWVAR 35
83222: PUSH
83223: LD_VAR 0 1
83227: NEG
83228: PPUSH
83229: LD_VAR 0 1
83233: PPUSH
83234: CALL_OW 12
83238: ST_TO_ADDR
// end ;
83239: LD_VAR 0 2
83243: RET
// export function PrepareEnchidna ( ) ; begin
83244: LD_INT 0
83246: PPUSH
// uc_side := 0 ;
83247: LD_ADDR_OWVAR 20
83251: PUSH
83252: LD_INT 0
83254: ST_TO_ADDR
// uc_nation := 0 ;
83255: LD_ADDR_OWVAR 21
83259: PUSH
83260: LD_INT 0
83262: ST_TO_ADDR
// hc_class := class_baggie ;
83263: LD_ADDR_OWVAR 28
83267: PUSH
83268: LD_INT 13
83270: ST_TO_ADDR
// hc_gallery :=  ;
83271: LD_ADDR_OWVAR 33
83275: PUSH
83276: LD_STRING 
83278: ST_TO_ADDR
// end ;
83279: LD_VAR 0 1
83283: RET
// export function PrepareFrog ( ) ; begin
83284: LD_INT 0
83286: PPUSH
// uc_side := 0 ;
83287: LD_ADDR_OWVAR 20
83291: PUSH
83292: LD_INT 0
83294: ST_TO_ADDR
// uc_nation := 0 ;
83295: LD_ADDR_OWVAR 21
83299: PUSH
83300: LD_INT 0
83302: ST_TO_ADDR
// hc_class := class_frog ;
83303: LD_ADDR_OWVAR 28
83307: PUSH
83308: LD_INT 19
83310: ST_TO_ADDR
// hc_gallery :=  ;
83311: LD_ADDR_OWVAR 33
83315: PUSH
83316: LD_STRING 
83318: ST_TO_ADDR
// end ;
83319: LD_VAR 0 1
83323: RET
// export function PrepareFish ( ) ; begin
83324: LD_INT 0
83326: PPUSH
// uc_side := 0 ;
83327: LD_ADDR_OWVAR 20
83331: PUSH
83332: LD_INT 0
83334: ST_TO_ADDR
// uc_nation := 0 ;
83335: LD_ADDR_OWVAR 21
83339: PUSH
83340: LD_INT 0
83342: ST_TO_ADDR
// hc_class := class_fish ;
83343: LD_ADDR_OWVAR 28
83347: PUSH
83348: LD_INT 20
83350: ST_TO_ADDR
// hc_gallery :=  ;
83351: LD_ADDR_OWVAR 33
83355: PUSH
83356: LD_STRING 
83358: ST_TO_ADDR
// end ;
83359: LD_VAR 0 1
83363: RET
// export function PrepareBird ( ) ; begin
83364: LD_INT 0
83366: PPUSH
// uc_side := 0 ;
83367: LD_ADDR_OWVAR 20
83371: PUSH
83372: LD_INT 0
83374: ST_TO_ADDR
// uc_nation := 0 ;
83375: LD_ADDR_OWVAR 21
83379: PUSH
83380: LD_INT 0
83382: ST_TO_ADDR
// hc_class := class_phororhacos ;
83383: LD_ADDR_OWVAR 28
83387: PUSH
83388: LD_INT 18
83390: ST_TO_ADDR
// hc_gallery :=  ;
83391: LD_ADDR_OWVAR 33
83395: PUSH
83396: LD_STRING 
83398: ST_TO_ADDR
// end ;
83399: LD_VAR 0 1
83403: RET
// export function PrepareHorse ( ) ; begin
83404: LD_INT 0
83406: PPUSH
// uc_side := 0 ;
83407: LD_ADDR_OWVAR 20
83411: PUSH
83412: LD_INT 0
83414: ST_TO_ADDR
// uc_nation := 0 ;
83415: LD_ADDR_OWVAR 21
83419: PUSH
83420: LD_INT 0
83422: ST_TO_ADDR
// hc_class := class_horse ;
83423: LD_ADDR_OWVAR 28
83427: PUSH
83428: LD_INT 21
83430: ST_TO_ADDR
// hc_gallery :=  ;
83431: LD_ADDR_OWVAR 33
83435: PUSH
83436: LD_STRING 
83438: ST_TO_ADDR
// end ;
83439: LD_VAR 0 1
83443: RET
// export function PrepareMastodont ( ) ; begin
83444: LD_INT 0
83446: PPUSH
// uc_side := 0 ;
83447: LD_ADDR_OWVAR 20
83451: PUSH
83452: LD_INT 0
83454: ST_TO_ADDR
// uc_nation := 0 ;
83455: LD_ADDR_OWVAR 21
83459: PUSH
83460: LD_INT 0
83462: ST_TO_ADDR
// vc_chassis := class_mastodont ;
83463: LD_ADDR_OWVAR 37
83467: PUSH
83468: LD_INT 31
83470: ST_TO_ADDR
// vc_control := control_rider ;
83471: LD_ADDR_OWVAR 38
83475: PUSH
83476: LD_INT 4
83478: ST_TO_ADDR
// end ;
83479: LD_VAR 0 1
83483: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
83484: LD_INT 0
83486: PPUSH
83487: PPUSH
83488: PPUSH
// uc_side = 0 ;
83489: LD_ADDR_OWVAR 20
83493: PUSH
83494: LD_INT 0
83496: ST_TO_ADDR
// uc_nation = 0 ;
83497: LD_ADDR_OWVAR 21
83501: PUSH
83502: LD_INT 0
83504: ST_TO_ADDR
// InitHc_All ( ) ;
83505: CALL_OW 584
// InitVc ;
83509: CALL_OW 20
// if mastodonts then
83513: LD_VAR 0 6
83517: IFFALSE 83584
// for i = 1 to mastodonts do
83519: LD_ADDR_VAR 0 11
83523: PUSH
83524: DOUBLE
83525: LD_INT 1
83527: DEC
83528: ST_TO_ADDR
83529: LD_VAR 0 6
83533: PUSH
83534: FOR_TO
83535: IFFALSE 83582
// begin vc_chassis := 31 ;
83537: LD_ADDR_OWVAR 37
83541: PUSH
83542: LD_INT 31
83544: ST_TO_ADDR
// vc_control := control_rider ;
83545: LD_ADDR_OWVAR 38
83549: PUSH
83550: LD_INT 4
83552: ST_TO_ADDR
// animal := CreateVehicle ;
83553: LD_ADDR_VAR 0 12
83557: PUSH
83558: CALL_OW 45
83562: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83563: LD_VAR 0 12
83567: PPUSH
83568: LD_VAR 0 8
83572: PPUSH
83573: LD_INT 0
83575: PPUSH
83576: CALL 85712 0 3
// end ;
83580: GO 83534
83582: POP
83583: POP
// if horses then
83584: LD_VAR 0 5
83588: IFFALSE 83655
// for i = 1 to horses do
83590: LD_ADDR_VAR 0 11
83594: PUSH
83595: DOUBLE
83596: LD_INT 1
83598: DEC
83599: ST_TO_ADDR
83600: LD_VAR 0 5
83604: PUSH
83605: FOR_TO
83606: IFFALSE 83653
// begin hc_class := 21 ;
83608: LD_ADDR_OWVAR 28
83612: PUSH
83613: LD_INT 21
83615: ST_TO_ADDR
// hc_gallery :=  ;
83616: LD_ADDR_OWVAR 33
83620: PUSH
83621: LD_STRING 
83623: ST_TO_ADDR
// animal := CreateHuman ;
83624: LD_ADDR_VAR 0 12
83628: PUSH
83629: CALL_OW 44
83633: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83634: LD_VAR 0 12
83638: PPUSH
83639: LD_VAR 0 8
83643: PPUSH
83644: LD_INT 0
83646: PPUSH
83647: CALL 85712 0 3
// end ;
83651: GO 83605
83653: POP
83654: POP
// if birds then
83655: LD_VAR 0 1
83659: IFFALSE 83726
// for i = 1 to birds do
83661: LD_ADDR_VAR 0 11
83665: PUSH
83666: DOUBLE
83667: LD_INT 1
83669: DEC
83670: ST_TO_ADDR
83671: LD_VAR 0 1
83675: PUSH
83676: FOR_TO
83677: IFFALSE 83724
// begin hc_class := 18 ;
83679: LD_ADDR_OWVAR 28
83683: PUSH
83684: LD_INT 18
83686: ST_TO_ADDR
// hc_gallery =  ;
83687: LD_ADDR_OWVAR 33
83691: PUSH
83692: LD_STRING 
83694: ST_TO_ADDR
// animal := CreateHuman ;
83695: LD_ADDR_VAR 0 12
83699: PUSH
83700: CALL_OW 44
83704: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83705: LD_VAR 0 12
83709: PPUSH
83710: LD_VAR 0 8
83714: PPUSH
83715: LD_INT 0
83717: PPUSH
83718: CALL 85712 0 3
// end ;
83722: GO 83676
83724: POP
83725: POP
// if tigers then
83726: LD_VAR 0 2
83730: IFFALSE 83814
// for i = 1 to tigers do
83732: LD_ADDR_VAR 0 11
83736: PUSH
83737: DOUBLE
83738: LD_INT 1
83740: DEC
83741: ST_TO_ADDR
83742: LD_VAR 0 2
83746: PUSH
83747: FOR_TO
83748: IFFALSE 83812
// begin hc_class = class_tiger ;
83750: LD_ADDR_OWVAR 28
83754: PUSH
83755: LD_INT 14
83757: ST_TO_ADDR
// hc_gallery =  ;
83758: LD_ADDR_OWVAR 33
83762: PUSH
83763: LD_STRING 
83765: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
83766: LD_ADDR_OWVAR 35
83770: PUSH
83771: LD_INT 7
83773: NEG
83774: PPUSH
83775: LD_INT 7
83777: PPUSH
83778: CALL_OW 12
83782: ST_TO_ADDR
// animal := CreateHuman ;
83783: LD_ADDR_VAR 0 12
83787: PUSH
83788: CALL_OW 44
83792: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83793: LD_VAR 0 12
83797: PPUSH
83798: LD_VAR 0 8
83802: PPUSH
83803: LD_INT 0
83805: PPUSH
83806: CALL 85712 0 3
// end ;
83810: GO 83747
83812: POP
83813: POP
// if apemans then
83814: LD_VAR 0 3
83818: IFFALSE 83941
// for i = 1 to apemans do
83820: LD_ADDR_VAR 0 11
83824: PUSH
83825: DOUBLE
83826: LD_INT 1
83828: DEC
83829: ST_TO_ADDR
83830: LD_VAR 0 3
83834: PUSH
83835: FOR_TO
83836: IFFALSE 83939
// begin hc_class = class_apeman ;
83838: LD_ADDR_OWVAR 28
83842: PUSH
83843: LD_INT 12
83845: ST_TO_ADDR
// hc_gallery =  ;
83846: LD_ADDR_OWVAR 33
83850: PUSH
83851: LD_STRING 
83853: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
83854: LD_ADDR_OWVAR 35
83858: PUSH
83859: LD_INT 2
83861: NEG
83862: PPUSH
83863: LD_INT 2
83865: PPUSH
83866: CALL_OW 12
83870: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
83871: LD_ADDR_OWVAR 31
83875: PUSH
83876: LD_INT 1
83878: PPUSH
83879: LD_INT 3
83881: PPUSH
83882: CALL_OW 12
83886: PUSH
83887: LD_INT 1
83889: PPUSH
83890: LD_INT 3
83892: PPUSH
83893: CALL_OW 12
83897: PUSH
83898: LD_INT 0
83900: PUSH
83901: LD_INT 0
83903: PUSH
83904: EMPTY
83905: LIST
83906: LIST
83907: LIST
83908: LIST
83909: ST_TO_ADDR
// animal := CreateHuman ;
83910: LD_ADDR_VAR 0 12
83914: PUSH
83915: CALL_OW 44
83919: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83920: LD_VAR 0 12
83924: PPUSH
83925: LD_VAR 0 8
83929: PPUSH
83930: LD_INT 0
83932: PPUSH
83933: CALL 85712 0 3
// end ;
83937: GO 83835
83939: POP
83940: POP
// if enchidnas then
83941: LD_VAR 0 4
83945: IFFALSE 84012
// for i = 1 to enchidnas do
83947: LD_ADDR_VAR 0 11
83951: PUSH
83952: DOUBLE
83953: LD_INT 1
83955: DEC
83956: ST_TO_ADDR
83957: LD_VAR 0 4
83961: PUSH
83962: FOR_TO
83963: IFFALSE 84010
// begin hc_class = 13 ;
83965: LD_ADDR_OWVAR 28
83969: PUSH
83970: LD_INT 13
83972: ST_TO_ADDR
// hc_gallery =  ;
83973: LD_ADDR_OWVAR 33
83977: PUSH
83978: LD_STRING 
83980: ST_TO_ADDR
// animal := CreateHuman ;
83981: LD_ADDR_VAR 0 12
83985: PUSH
83986: CALL_OW 44
83990: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83991: LD_VAR 0 12
83995: PPUSH
83996: LD_VAR 0 8
84000: PPUSH
84001: LD_INT 0
84003: PPUSH
84004: CALL 85712 0 3
// end ;
84008: GO 83962
84010: POP
84011: POP
// if fishes then
84012: LD_VAR 0 7
84016: IFFALSE 84083
// for i = 1 to fishes do
84018: LD_ADDR_VAR 0 11
84022: PUSH
84023: DOUBLE
84024: LD_INT 1
84026: DEC
84027: ST_TO_ADDR
84028: LD_VAR 0 7
84032: PUSH
84033: FOR_TO
84034: IFFALSE 84081
// begin hc_class = 20 ;
84036: LD_ADDR_OWVAR 28
84040: PUSH
84041: LD_INT 20
84043: ST_TO_ADDR
// hc_gallery =  ;
84044: LD_ADDR_OWVAR 33
84048: PUSH
84049: LD_STRING 
84051: ST_TO_ADDR
// animal := CreateHuman ;
84052: LD_ADDR_VAR 0 12
84056: PUSH
84057: CALL_OW 44
84061: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
84062: LD_VAR 0 12
84066: PPUSH
84067: LD_VAR 0 9
84071: PPUSH
84072: LD_INT 0
84074: PPUSH
84075: CALL 85712 0 3
// end ;
84079: GO 84033
84081: POP
84082: POP
// end ;
84083: LD_VAR 0 10
84087: RET
// export function WantHeal ( sci , unit ) ; begin
84088: LD_INT 0
84090: PPUSH
// if GetTaskList ( sci ) > 0 then
84091: LD_VAR 0 1
84095: PPUSH
84096: CALL_OW 437
84100: PUSH
84101: LD_INT 0
84103: GREATER
84104: IFFALSE 84174
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
84106: LD_VAR 0 1
84110: PPUSH
84111: CALL_OW 437
84115: PUSH
84116: LD_INT 1
84118: ARRAY
84119: PUSH
84120: LD_INT 1
84122: ARRAY
84123: PUSH
84124: LD_STRING l
84126: EQUAL
84127: PUSH
84128: LD_VAR 0 1
84132: PPUSH
84133: CALL_OW 437
84137: PUSH
84138: LD_INT 1
84140: ARRAY
84141: PUSH
84142: LD_INT 4
84144: ARRAY
84145: PUSH
84146: LD_VAR 0 2
84150: EQUAL
84151: AND
84152: IFFALSE 84164
// result := true else
84154: LD_ADDR_VAR 0 3
84158: PUSH
84159: LD_INT 1
84161: ST_TO_ADDR
84162: GO 84172
// result := false ;
84164: LD_ADDR_VAR 0 3
84168: PUSH
84169: LD_INT 0
84171: ST_TO_ADDR
// end else
84172: GO 84182
// result := false ;
84174: LD_ADDR_VAR 0 3
84178: PUSH
84179: LD_INT 0
84181: ST_TO_ADDR
// end ;
84182: LD_VAR 0 3
84186: RET
// export function HealTarget ( sci ) ; begin
84187: LD_INT 0
84189: PPUSH
// if not sci then
84190: LD_VAR 0 1
84194: NOT
84195: IFFALSE 84199
// exit ;
84197: GO 84264
// result := 0 ;
84199: LD_ADDR_VAR 0 2
84203: PUSH
84204: LD_INT 0
84206: ST_TO_ADDR
// if GetTaskList ( sci ) then
84207: LD_VAR 0 1
84211: PPUSH
84212: CALL_OW 437
84216: IFFALSE 84264
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
84218: LD_VAR 0 1
84222: PPUSH
84223: CALL_OW 437
84227: PUSH
84228: LD_INT 1
84230: ARRAY
84231: PUSH
84232: LD_INT 1
84234: ARRAY
84235: PUSH
84236: LD_STRING l
84238: EQUAL
84239: IFFALSE 84264
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
84241: LD_ADDR_VAR 0 2
84245: PUSH
84246: LD_VAR 0 1
84250: PPUSH
84251: CALL_OW 437
84255: PUSH
84256: LD_INT 1
84258: ARRAY
84259: PUSH
84260: LD_INT 4
84262: ARRAY
84263: ST_TO_ADDR
// end ;
84264: LD_VAR 0 2
84268: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
84269: LD_INT 0
84271: PPUSH
84272: PPUSH
84273: PPUSH
84274: PPUSH
// if not base_units then
84275: LD_VAR 0 1
84279: NOT
84280: IFFALSE 84284
// exit ;
84282: GO 84371
// result := false ;
84284: LD_ADDR_VAR 0 2
84288: PUSH
84289: LD_INT 0
84291: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
84292: LD_ADDR_VAR 0 5
84296: PUSH
84297: LD_VAR 0 1
84301: PPUSH
84302: LD_INT 21
84304: PUSH
84305: LD_INT 3
84307: PUSH
84308: EMPTY
84309: LIST
84310: LIST
84311: PPUSH
84312: CALL_OW 72
84316: ST_TO_ADDR
// if not tmp then
84317: LD_VAR 0 5
84321: NOT
84322: IFFALSE 84326
// exit ;
84324: GO 84371
// for i in tmp do
84326: LD_ADDR_VAR 0 3
84330: PUSH
84331: LD_VAR 0 5
84335: PUSH
84336: FOR_IN
84337: IFFALSE 84369
// begin result := EnemyInRange ( i , 22 ) ;
84339: LD_ADDR_VAR 0 2
84343: PUSH
84344: LD_VAR 0 3
84348: PPUSH
84349: LD_INT 22
84351: PPUSH
84352: CALL 81958 0 2
84356: ST_TO_ADDR
// if result then
84357: LD_VAR 0 2
84361: IFFALSE 84367
// exit ;
84363: POP
84364: POP
84365: GO 84371
// end ;
84367: GO 84336
84369: POP
84370: POP
// end ;
84371: LD_VAR 0 2
84375: RET
// export function FilterByTag ( units , tag ) ; begin
84376: LD_INT 0
84378: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
84379: LD_ADDR_VAR 0 3
84383: PUSH
84384: LD_VAR 0 1
84388: PPUSH
84389: LD_INT 120
84391: PUSH
84392: LD_VAR 0 2
84396: PUSH
84397: EMPTY
84398: LIST
84399: LIST
84400: PPUSH
84401: CALL_OW 72
84405: ST_TO_ADDR
// end ;
84406: LD_VAR 0 3
84410: RET
// export function IsDriver ( un ) ; begin
84411: LD_INT 0
84413: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
84414: LD_ADDR_VAR 0 2
84418: PUSH
84419: LD_VAR 0 1
84423: PUSH
84424: LD_INT 55
84426: PUSH
84427: EMPTY
84428: LIST
84429: PPUSH
84430: CALL_OW 69
84434: IN
84435: ST_TO_ADDR
// end ;
84436: LD_VAR 0 2
84440: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
84441: LD_INT 0
84443: PPUSH
84444: PPUSH
// list := [ ] ;
84445: LD_ADDR_VAR 0 5
84449: PUSH
84450: EMPTY
84451: ST_TO_ADDR
// case d of 0 :
84452: LD_VAR 0 3
84456: PUSH
84457: LD_INT 0
84459: DOUBLE
84460: EQUAL
84461: IFTRUE 84465
84463: GO 84598
84465: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
84466: LD_ADDR_VAR 0 5
84470: PUSH
84471: LD_VAR 0 1
84475: PUSH
84476: LD_INT 4
84478: MINUS
84479: PUSH
84480: LD_VAR 0 2
84484: PUSH
84485: LD_INT 4
84487: MINUS
84488: PUSH
84489: LD_INT 2
84491: PUSH
84492: EMPTY
84493: LIST
84494: LIST
84495: LIST
84496: PUSH
84497: LD_VAR 0 1
84501: PUSH
84502: LD_INT 3
84504: MINUS
84505: PUSH
84506: LD_VAR 0 2
84510: PUSH
84511: LD_INT 1
84513: PUSH
84514: EMPTY
84515: LIST
84516: LIST
84517: LIST
84518: PUSH
84519: LD_VAR 0 1
84523: PUSH
84524: LD_INT 4
84526: PLUS
84527: PUSH
84528: LD_VAR 0 2
84532: PUSH
84533: LD_INT 4
84535: PUSH
84536: EMPTY
84537: LIST
84538: LIST
84539: LIST
84540: PUSH
84541: LD_VAR 0 1
84545: PUSH
84546: LD_INT 3
84548: PLUS
84549: PUSH
84550: LD_VAR 0 2
84554: PUSH
84555: LD_INT 3
84557: PLUS
84558: PUSH
84559: LD_INT 5
84561: PUSH
84562: EMPTY
84563: LIST
84564: LIST
84565: LIST
84566: PUSH
84567: LD_VAR 0 1
84571: PUSH
84572: LD_VAR 0 2
84576: PUSH
84577: LD_INT 4
84579: PLUS
84580: PUSH
84581: LD_INT 0
84583: PUSH
84584: EMPTY
84585: LIST
84586: LIST
84587: LIST
84588: PUSH
84589: EMPTY
84590: LIST
84591: LIST
84592: LIST
84593: LIST
84594: LIST
84595: ST_TO_ADDR
// end ; 1 :
84596: GO 85296
84598: LD_INT 1
84600: DOUBLE
84601: EQUAL
84602: IFTRUE 84606
84604: GO 84739
84606: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
84607: LD_ADDR_VAR 0 5
84611: PUSH
84612: LD_VAR 0 1
84616: PUSH
84617: LD_VAR 0 2
84621: PUSH
84622: LD_INT 4
84624: MINUS
84625: PUSH
84626: LD_INT 3
84628: PUSH
84629: EMPTY
84630: LIST
84631: LIST
84632: LIST
84633: PUSH
84634: LD_VAR 0 1
84638: PUSH
84639: LD_INT 3
84641: MINUS
84642: PUSH
84643: LD_VAR 0 2
84647: PUSH
84648: LD_INT 3
84650: MINUS
84651: PUSH
84652: LD_INT 2
84654: PUSH
84655: EMPTY
84656: LIST
84657: LIST
84658: LIST
84659: PUSH
84660: LD_VAR 0 1
84664: PUSH
84665: LD_INT 4
84667: MINUS
84668: PUSH
84669: LD_VAR 0 2
84673: PUSH
84674: LD_INT 1
84676: PUSH
84677: EMPTY
84678: LIST
84679: LIST
84680: LIST
84681: PUSH
84682: LD_VAR 0 1
84686: PUSH
84687: LD_VAR 0 2
84691: PUSH
84692: LD_INT 3
84694: PLUS
84695: PUSH
84696: LD_INT 0
84698: PUSH
84699: EMPTY
84700: LIST
84701: LIST
84702: LIST
84703: PUSH
84704: LD_VAR 0 1
84708: PUSH
84709: LD_INT 4
84711: PLUS
84712: PUSH
84713: LD_VAR 0 2
84717: PUSH
84718: LD_INT 4
84720: PLUS
84721: PUSH
84722: LD_INT 5
84724: PUSH
84725: EMPTY
84726: LIST
84727: LIST
84728: LIST
84729: PUSH
84730: EMPTY
84731: LIST
84732: LIST
84733: LIST
84734: LIST
84735: LIST
84736: ST_TO_ADDR
// end ; 2 :
84737: GO 85296
84739: LD_INT 2
84741: DOUBLE
84742: EQUAL
84743: IFTRUE 84747
84745: GO 84876
84747: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
84748: LD_ADDR_VAR 0 5
84752: PUSH
84753: LD_VAR 0 1
84757: PUSH
84758: LD_VAR 0 2
84762: PUSH
84763: LD_INT 3
84765: MINUS
84766: PUSH
84767: LD_INT 3
84769: PUSH
84770: EMPTY
84771: LIST
84772: LIST
84773: LIST
84774: PUSH
84775: LD_VAR 0 1
84779: PUSH
84780: LD_INT 4
84782: PLUS
84783: PUSH
84784: LD_VAR 0 2
84788: PUSH
84789: LD_INT 4
84791: PUSH
84792: EMPTY
84793: LIST
84794: LIST
84795: LIST
84796: PUSH
84797: LD_VAR 0 1
84801: PUSH
84802: LD_VAR 0 2
84806: PUSH
84807: LD_INT 4
84809: PLUS
84810: PUSH
84811: LD_INT 0
84813: PUSH
84814: EMPTY
84815: LIST
84816: LIST
84817: LIST
84818: PUSH
84819: LD_VAR 0 1
84823: PUSH
84824: LD_INT 3
84826: MINUS
84827: PUSH
84828: LD_VAR 0 2
84832: PUSH
84833: LD_INT 1
84835: PUSH
84836: EMPTY
84837: LIST
84838: LIST
84839: LIST
84840: PUSH
84841: LD_VAR 0 1
84845: PUSH
84846: LD_INT 4
84848: MINUS
84849: PUSH
84850: LD_VAR 0 2
84854: PUSH
84855: LD_INT 4
84857: MINUS
84858: PUSH
84859: LD_INT 2
84861: PUSH
84862: EMPTY
84863: LIST
84864: LIST
84865: LIST
84866: PUSH
84867: EMPTY
84868: LIST
84869: LIST
84870: LIST
84871: LIST
84872: LIST
84873: ST_TO_ADDR
// end ; 3 :
84874: GO 85296
84876: LD_INT 3
84878: DOUBLE
84879: EQUAL
84880: IFTRUE 84884
84882: GO 85017
84884: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
84885: LD_ADDR_VAR 0 5
84889: PUSH
84890: LD_VAR 0 1
84894: PUSH
84895: LD_INT 3
84897: PLUS
84898: PUSH
84899: LD_VAR 0 2
84903: PUSH
84904: LD_INT 4
84906: PUSH
84907: EMPTY
84908: LIST
84909: LIST
84910: LIST
84911: PUSH
84912: LD_VAR 0 1
84916: PUSH
84917: LD_INT 4
84919: PLUS
84920: PUSH
84921: LD_VAR 0 2
84925: PUSH
84926: LD_INT 4
84928: PLUS
84929: PUSH
84930: LD_INT 5
84932: PUSH
84933: EMPTY
84934: LIST
84935: LIST
84936: LIST
84937: PUSH
84938: LD_VAR 0 1
84942: PUSH
84943: LD_INT 4
84945: MINUS
84946: PUSH
84947: LD_VAR 0 2
84951: PUSH
84952: LD_INT 1
84954: PUSH
84955: EMPTY
84956: LIST
84957: LIST
84958: LIST
84959: PUSH
84960: LD_VAR 0 1
84964: PUSH
84965: LD_VAR 0 2
84969: PUSH
84970: LD_INT 4
84972: MINUS
84973: PUSH
84974: LD_INT 3
84976: PUSH
84977: EMPTY
84978: LIST
84979: LIST
84980: LIST
84981: PUSH
84982: LD_VAR 0 1
84986: PUSH
84987: LD_INT 3
84989: MINUS
84990: PUSH
84991: LD_VAR 0 2
84995: PUSH
84996: LD_INT 3
84998: MINUS
84999: PUSH
85000: LD_INT 2
85002: PUSH
85003: EMPTY
85004: LIST
85005: LIST
85006: LIST
85007: PUSH
85008: EMPTY
85009: LIST
85010: LIST
85011: LIST
85012: LIST
85013: LIST
85014: ST_TO_ADDR
// end ; 4 :
85015: GO 85296
85017: LD_INT 4
85019: DOUBLE
85020: EQUAL
85021: IFTRUE 85025
85023: GO 85158
85025: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
85026: LD_ADDR_VAR 0 5
85030: PUSH
85031: LD_VAR 0 1
85035: PUSH
85036: LD_VAR 0 2
85040: PUSH
85041: LD_INT 4
85043: PLUS
85044: PUSH
85045: LD_INT 0
85047: PUSH
85048: EMPTY
85049: LIST
85050: LIST
85051: LIST
85052: PUSH
85053: LD_VAR 0 1
85057: PUSH
85058: LD_INT 3
85060: PLUS
85061: PUSH
85062: LD_VAR 0 2
85066: PUSH
85067: LD_INT 3
85069: PLUS
85070: PUSH
85071: LD_INT 5
85073: PUSH
85074: EMPTY
85075: LIST
85076: LIST
85077: LIST
85078: PUSH
85079: LD_VAR 0 1
85083: PUSH
85084: LD_INT 4
85086: PLUS
85087: PUSH
85088: LD_VAR 0 2
85092: PUSH
85093: LD_INT 4
85095: PUSH
85096: EMPTY
85097: LIST
85098: LIST
85099: LIST
85100: PUSH
85101: LD_VAR 0 1
85105: PUSH
85106: LD_VAR 0 2
85110: PUSH
85111: LD_INT 3
85113: MINUS
85114: PUSH
85115: LD_INT 3
85117: PUSH
85118: EMPTY
85119: LIST
85120: LIST
85121: LIST
85122: PUSH
85123: LD_VAR 0 1
85127: PUSH
85128: LD_INT 4
85130: MINUS
85131: PUSH
85132: LD_VAR 0 2
85136: PUSH
85137: LD_INT 4
85139: MINUS
85140: PUSH
85141: LD_INT 2
85143: PUSH
85144: EMPTY
85145: LIST
85146: LIST
85147: LIST
85148: PUSH
85149: EMPTY
85150: LIST
85151: LIST
85152: LIST
85153: LIST
85154: LIST
85155: ST_TO_ADDR
// end ; 5 :
85156: GO 85296
85158: LD_INT 5
85160: DOUBLE
85161: EQUAL
85162: IFTRUE 85166
85164: GO 85295
85166: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
85167: LD_ADDR_VAR 0 5
85171: PUSH
85172: LD_VAR 0 1
85176: PUSH
85177: LD_INT 4
85179: MINUS
85180: PUSH
85181: LD_VAR 0 2
85185: PUSH
85186: LD_INT 1
85188: PUSH
85189: EMPTY
85190: LIST
85191: LIST
85192: LIST
85193: PUSH
85194: LD_VAR 0 1
85198: PUSH
85199: LD_VAR 0 2
85203: PUSH
85204: LD_INT 4
85206: MINUS
85207: PUSH
85208: LD_INT 3
85210: PUSH
85211: EMPTY
85212: LIST
85213: LIST
85214: LIST
85215: PUSH
85216: LD_VAR 0 1
85220: PUSH
85221: LD_INT 4
85223: PLUS
85224: PUSH
85225: LD_VAR 0 2
85229: PUSH
85230: LD_INT 4
85232: PLUS
85233: PUSH
85234: LD_INT 5
85236: PUSH
85237: EMPTY
85238: LIST
85239: LIST
85240: LIST
85241: PUSH
85242: LD_VAR 0 1
85246: PUSH
85247: LD_INT 3
85249: PLUS
85250: PUSH
85251: LD_VAR 0 2
85255: PUSH
85256: LD_INT 4
85258: PUSH
85259: EMPTY
85260: LIST
85261: LIST
85262: LIST
85263: PUSH
85264: LD_VAR 0 1
85268: PUSH
85269: LD_VAR 0 2
85273: PUSH
85274: LD_INT 3
85276: PLUS
85277: PUSH
85278: LD_INT 0
85280: PUSH
85281: EMPTY
85282: LIST
85283: LIST
85284: LIST
85285: PUSH
85286: EMPTY
85287: LIST
85288: LIST
85289: LIST
85290: LIST
85291: LIST
85292: ST_TO_ADDR
// end ; end ;
85293: GO 85296
85295: POP
// result := list ;
85296: LD_ADDR_VAR 0 4
85300: PUSH
85301: LD_VAR 0 5
85305: ST_TO_ADDR
// end ;
85306: LD_VAR 0 4
85310: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
85311: LD_INT 0
85313: PPUSH
85314: PPUSH
85315: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
85316: LD_VAR 0 1
85320: NOT
85321: PUSH
85322: LD_VAR 0 2
85326: PUSH
85327: LD_INT 1
85329: PUSH
85330: LD_INT 2
85332: PUSH
85333: LD_INT 3
85335: PUSH
85336: LD_INT 4
85338: PUSH
85339: EMPTY
85340: LIST
85341: LIST
85342: LIST
85343: LIST
85344: IN
85345: NOT
85346: OR
85347: IFFALSE 85351
// exit ;
85349: GO 85434
// tmp := [ ] ;
85351: LD_ADDR_VAR 0 5
85355: PUSH
85356: EMPTY
85357: ST_TO_ADDR
// for i in units do
85358: LD_ADDR_VAR 0 4
85362: PUSH
85363: LD_VAR 0 1
85367: PUSH
85368: FOR_IN
85369: IFFALSE 85403
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
85371: LD_ADDR_VAR 0 5
85375: PUSH
85376: LD_VAR 0 5
85380: PPUSH
85381: LD_VAR 0 4
85385: PPUSH
85386: LD_VAR 0 2
85390: PPUSH
85391: CALL_OW 259
85395: PPUSH
85396: CALL 86807 0 2
85400: ST_TO_ADDR
85401: GO 85368
85403: POP
85404: POP
// if not tmp then
85405: LD_VAR 0 5
85409: NOT
85410: IFFALSE 85414
// exit ;
85412: GO 85434
// result := SortListByListDesc ( units , tmp ) ;
85414: LD_ADDR_VAR 0 3
85418: PUSH
85419: LD_VAR 0 1
85423: PPUSH
85424: LD_VAR 0 5
85428: PPUSH
85429: CALL_OW 77
85433: ST_TO_ADDR
// end ;
85434: LD_VAR 0 3
85438: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
85439: LD_INT 0
85441: PPUSH
85442: PPUSH
85443: PPUSH
// result := false ;
85444: LD_ADDR_VAR 0 3
85448: PUSH
85449: LD_INT 0
85451: ST_TO_ADDR
// if not building then
85452: LD_VAR 0 2
85456: NOT
85457: IFFALSE 85461
// exit ;
85459: GO 85599
// x := GetX ( building ) ;
85461: LD_ADDR_VAR 0 4
85465: PUSH
85466: LD_VAR 0 2
85470: PPUSH
85471: CALL_OW 250
85475: ST_TO_ADDR
// y := GetY ( building ) ;
85476: LD_ADDR_VAR 0 5
85480: PUSH
85481: LD_VAR 0 2
85485: PPUSH
85486: CALL_OW 251
85490: ST_TO_ADDR
// if not x or not y then
85491: LD_VAR 0 4
85495: NOT
85496: PUSH
85497: LD_VAR 0 5
85501: NOT
85502: OR
85503: IFFALSE 85507
// exit ;
85505: GO 85599
// if GetTaskList ( unit ) then
85507: LD_VAR 0 1
85511: PPUSH
85512: CALL_OW 437
85516: IFFALSE 85599
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
85518: LD_STRING e
85520: PUSH
85521: LD_VAR 0 1
85525: PPUSH
85526: CALL_OW 437
85530: PUSH
85531: LD_INT 1
85533: ARRAY
85534: PUSH
85535: LD_INT 1
85537: ARRAY
85538: EQUAL
85539: PUSH
85540: LD_VAR 0 4
85544: PUSH
85545: LD_VAR 0 1
85549: PPUSH
85550: CALL_OW 437
85554: PUSH
85555: LD_INT 1
85557: ARRAY
85558: PUSH
85559: LD_INT 2
85561: ARRAY
85562: EQUAL
85563: AND
85564: PUSH
85565: LD_VAR 0 5
85569: PUSH
85570: LD_VAR 0 1
85574: PPUSH
85575: CALL_OW 437
85579: PUSH
85580: LD_INT 1
85582: ARRAY
85583: PUSH
85584: LD_INT 3
85586: ARRAY
85587: EQUAL
85588: AND
85589: IFFALSE 85599
// result := true end ;
85591: LD_ADDR_VAR 0 3
85595: PUSH
85596: LD_INT 1
85598: ST_TO_ADDR
// end ;
85599: LD_VAR 0 3
85603: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
85604: LD_INT 0
85606: PPUSH
// result := false ;
85607: LD_ADDR_VAR 0 4
85611: PUSH
85612: LD_INT 0
85614: ST_TO_ADDR
// if GetTaskList ( unit ) then
85615: LD_VAR 0 1
85619: PPUSH
85620: CALL_OW 437
85624: IFFALSE 85707
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
85626: LD_STRING M
85628: PUSH
85629: LD_VAR 0 1
85633: PPUSH
85634: CALL_OW 437
85638: PUSH
85639: LD_INT 1
85641: ARRAY
85642: PUSH
85643: LD_INT 1
85645: ARRAY
85646: EQUAL
85647: PUSH
85648: LD_VAR 0 2
85652: PUSH
85653: LD_VAR 0 1
85657: PPUSH
85658: CALL_OW 437
85662: PUSH
85663: LD_INT 1
85665: ARRAY
85666: PUSH
85667: LD_INT 2
85669: ARRAY
85670: EQUAL
85671: AND
85672: PUSH
85673: LD_VAR 0 3
85677: PUSH
85678: LD_VAR 0 1
85682: PPUSH
85683: CALL_OW 437
85687: PUSH
85688: LD_INT 1
85690: ARRAY
85691: PUSH
85692: LD_INT 3
85694: ARRAY
85695: EQUAL
85696: AND
85697: IFFALSE 85707
// result := true ;
85699: LD_ADDR_VAR 0 4
85703: PUSH
85704: LD_INT 1
85706: ST_TO_ADDR
// end ; end ;
85707: LD_VAR 0 4
85711: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
85712: LD_INT 0
85714: PPUSH
85715: PPUSH
85716: PPUSH
85717: PPUSH
// if not unit or not area then
85718: LD_VAR 0 1
85722: NOT
85723: PUSH
85724: LD_VAR 0 2
85728: NOT
85729: OR
85730: IFFALSE 85734
// exit ;
85732: GO 85910
// tmp := AreaToList ( area , i ) ;
85734: LD_ADDR_VAR 0 6
85738: PUSH
85739: LD_VAR 0 2
85743: PPUSH
85744: LD_VAR 0 5
85748: PPUSH
85749: CALL_OW 517
85753: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
85754: LD_ADDR_VAR 0 5
85758: PUSH
85759: DOUBLE
85760: LD_INT 1
85762: DEC
85763: ST_TO_ADDR
85764: LD_VAR 0 6
85768: PUSH
85769: LD_INT 1
85771: ARRAY
85772: PUSH
85773: FOR_TO
85774: IFFALSE 85908
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
85776: LD_ADDR_VAR 0 7
85780: PUSH
85781: LD_VAR 0 6
85785: PUSH
85786: LD_INT 1
85788: ARRAY
85789: PUSH
85790: LD_VAR 0 5
85794: ARRAY
85795: PUSH
85796: LD_VAR 0 6
85800: PUSH
85801: LD_INT 2
85803: ARRAY
85804: PUSH
85805: LD_VAR 0 5
85809: ARRAY
85810: PUSH
85811: EMPTY
85812: LIST
85813: LIST
85814: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 2 ] ) = 0 then
85815: LD_INT 92
85817: PUSH
85818: LD_VAR 0 7
85822: PUSH
85823: LD_INT 1
85825: ARRAY
85826: PUSH
85827: LD_VAR 0 7
85831: PUSH
85832: LD_INT 2
85834: ARRAY
85835: PUSH
85836: LD_INT 2
85838: PUSH
85839: EMPTY
85840: LIST
85841: LIST
85842: LIST
85843: LIST
85844: PPUSH
85845: CALL_OW 69
85849: PUSH
85850: LD_INT 0
85852: EQUAL
85853: IFFALSE 85906
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
85855: LD_VAR 0 1
85859: PPUSH
85860: LD_VAR 0 7
85864: PUSH
85865: LD_INT 1
85867: ARRAY
85868: PPUSH
85869: LD_VAR 0 7
85873: PUSH
85874: LD_INT 2
85876: ARRAY
85877: PPUSH
85878: LD_VAR 0 3
85882: PPUSH
85883: CALL_OW 48
// result := IsPlaced ( unit ) ;
85887: LD_ADDR_VAR 0 4
85891: PUSH
85892: LD_VAR 0 1
85896: PPUSH
85897: CALL_OW 305
85901: ST_TO_ADDR
// exit ;
85902: POP
85903: POP
85904: GO 85910
// end ; end ;
85906: GO 85773
85908: POP
85909: POP
// end ;
85910: LD_VAR 0 4
85914: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
85915: LD_INT 0
85917: PPUSH
85918: PPUSH
85919: PPUSH
// if not side or side > 8 then
85920: LD_VAR 0 1
85924: NOT
85925: PUSH
85926: LD_VAR 0 1
85930: PUSH
85931: LD_INT 8
85933: GREATER
85934: OR
85935: IFFALSE 85939
// exit ;
85937: GO 86126
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
85939: LD_ADDR_VAR 0 4
85943: PUSH
85944: LD_INT 22
85946: PUSH
85947: LD_VAR 0 1
85951: PUSH
85952: EMPTY
85953: LIST
85954: LIST
85955: PUSH
85956: LD_INT 21
85958: PUSH
85959: LD_INT 3
85961: PUSH
85962: EMPTY
85963: LIST
85964: LIST
85965: PUSH
85966: EMPTY
85967: LIST
85968: LIST
85969: PPUSH
85970: CALL_OW 69
85974: ST_TO_ADDR
// if not tmp then
85975: LD_VAR 0 4
85979: NOT
85980: IFFALSE 85984
// exit ;
85982: GO 86126
// enable_addtolog := true ;
85984: LD_ADDR_OWVAR 81
85988: PUSH
85989: LD_INT 1
85991: ST_TO_ADDR
// AddToLog ( [ ) ;
85992: LD_STRING [
85994: PPUSH
85995: CALL_OW 561
// for i in tmp do
85999: LD_ADDR_VAR 0 3
86003: PUSH
86004: LD_VAR 0 4
86008: PUSH
86009: FOR_IN
86010: IFFALSE 86117
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
86012: LD_STRING [
86014: PUSH
86015: LD_VAR 0 3
86019: PPUSH
86020: CALL_OW 266
86024: STR
86025: PUSH
86026: LD_STRING , 
86028: STR
86029: PUSH
86030: LD_VAR 0 3
86034: PPUSH
86035: CALL_OW 250
86039: STR
86040: PUSH
86041: LD_STRING , 
86043: STR
86044: PUSH
86045: LD_VAR 0 3
86049: PPUSH
86050: CALL_OW 251
86054: STR
86055: PUSH
86056: LD_STRING , 
86058: STR
86059: PUSH
86060: LD_VAR 0 3
86064: PPUSH
86065: CALL_OW 254
86069: STR
86070: PUSH
86071: LD_STRING , 
86073: STR
86074: PUSH
86075: LD_VAR 0 3
86079: PPUSH
86080: LD_INT 1
86082: PPUSH
86083: CALL_OW 268
86087: STR
86088: PUSH
86089: LD_STRING , 
86091: STR
86092: PUSH
86093: LD_VAR 0 3
86097: PPUSH
86098: LD_INT 2
86100: PPUSH
86101: CALL_OW 268
86105: STR
86106: PUSH
86107: LD_STRING ],
86109: STR
86110: PPUSH
86111: CALL_OW 561
// end ;
86115: GO 86009
86117: POP
86118: POP
// AddToLog ( ]; ) ;
86119: LD_STRING ];
86121: PPUSH
86122: CALL_OW 561
// end ;
86126: LD_VAR 0 2
86130: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
86131: LD_INT 0
86133: PPUSH
86134: PPUSH
86135: PPUSH
86136: PPUSH
86137: PPUSH
// if not area or not rate or not max then
86138: LD_VAR 0 1
86142: NOT
86143: PUSH
86144: LD_VAR 0 2
86148: NOT
86149: OR
86150: PUSH
86151: LD_VAR 0 4
86155: NOT
86156: OR
86157: IFFALSE 86161
// exit ;
86159: GO 86350
// while 1 do
86161: LD_INT 1
86163: IFFALSE 86350
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
86165: LD_ADDR_VAR 0 9
86169: PUSH
86170: LD_VAR 0 1
86174: PPUSH
86175: LD_INT 1
86177: PPUSH
86178: CALL_OW 287
86182: PUSH
86183: LD_INT 10
86185: MUL
86186: ST_TO_ADDR
// r := rate / 10 ;
86187: LD_ADDR_VAR 0 7
86191: PUSH
86192: LD_VAR 0 2
86196: PUSH
86197: LD_INT 10
86199: DIVREAL
86200: ST_TO_ADDR
// time := 1 1$00 ;
86201: LD_ADDR_VAR 0 8
86205: PUSH
86206: LD_INT 2100
86208: ST_TO_ADDR
// if amount < min then
86209: LD_VAR 0 9
86213: PUSH
86214: LD_VAR 0 3
86218: LESS
86219: IFFALSE 86237
// r := r * 2 else
86221: LD_ADDR_VAR 0 7
86225: PUSH
86226: LD_VAR 0 7
86230: PUSH
86231: LD_INT 2
86233: MUL
86234: ST_TO_ADDR
86235: GO 86263
// if amount > max then
86237: LD_VAR 0 9
86241: PUSH
86242: LD_VAR 0 4
86246: GREATER
86247: IFFALSE 86263
// r := r / 2 ;
86249: LD_ADDR_VAR 0 7
86253: PUSH
86254: LD_VAR 0 7
86258: PUSH
86259: LD_INT 2
86261: DIVREAL
86262: ST_TO_ADDR
// time := time / r ;
86263: LD_ADDR_VAR 0 8
86267: PUSH
86268: LD_VAR 0 8
86272: PUSH
86273: LD_VAR 0 7
86277: DIVREAL
86278: ST_TO_ADDR
// if time < 0 then
86279: LD_VAR 0 8
86283: PUSH
86284: LD_INT 0
86286: LESS
86287: IFFALSE 86304
// time := time * - 1 ;
86289: LD_ADDR_VAR 0 8
86293: PUSH
86294: LD_VAR 0 8
86298: PUSH
86299: LD_INT 1
86301: NEG
86302: MUL
86303: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
86304: LD_VAR 0 8
86308: PUSH
86309: LD_INT 35
86311: PPUSH
86312: LD_INT 875
86314: PPUSH
86315: CALL_OW 12
86319: PLUS
86320: PPUSH
86321: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
86325: LD_INT 1
86327: PPUSH
86328: LD_INT 5
86330: PPUSH
86331: CALL_OW 12
86335: PPUSH
86336: LD_VAR 0 1
86340: PPUSH
86341: LD_INT 1
86343: PPUSH
86344: CALL_OW 55
// end ;
86348: GO 86161
// end ;
86350: LD_VAR 0 5
86354: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
86355: LD_INT 0
86357: PPUSH
86358: PPUSH
86359: PPUSH
86360: PPUSH
86361: PPUSH
86362: PPUSH
86363: PPUSH
86364: PPUSH
// if not turrets or not factories then
86365: LD_VAR 0 1
86369: NOT
86370: PUSH
86371: LD_VAR 0 2
86375: NOT
86376: OR
86377: IFFALSE 86381
// exit ;
86379: GO 86688
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
86381: LD_ADDR_VAR 0 10
86385: PUSH
86386: LD_INT 5
86388: PUSH
86389: LD_INT 6
86391: PUSH
86392: EMPTY
86393: LIST
86394: LIST
86395: PUSH
86396: LD_INT 2
86398: PUSH
86399: LD_INT 4
86401: PUSH
86402: EMPTY
86403: LIST
86404: LIST
86405: PUSH
86406: LD_INT 3
86408: PUSH
86409: LD_INT 5
86411: PUSH
86412: EMPTY
86413: LIST
86414: LIST
86415: PUSH
86416: EMPTY
86417: LIST
86418: LIST
86419: LIST
86420: PUSH
86421: LD_INT 24
86423: PUSH
86424: LD_INT 25
86426: PUSH
86427: EMPTY
86428: LIST
86429: LIST
86430: PUSH
86431: LD_INT 23
86433: PUSH
86434: LD_INT 27
86436: PUSH
86437: EMPTY
86438: LIST
86439: LIST
86440: PUSH
86441: EMPTY
86442: LIST
86443: LIST
86444: PUSH
86445: LD_INT 42
86447: PUSH
86448: LD_INT 43
86450: PUSH
86451: EMPTY
86452: LIST
86453: LIST
86454: PUSH
86455: LD_INT 44
86457: PUSH
86458: LD_INT 46
86460: PUSH
86461: EMPTY
86462: LIST
86463: LIST
86464: PUSH
86465: LD_INT 45
86467: PUSH
86468: LD_INT 47
86470: PUSH
86471: EMPTY
86472: LIST
86473: LIST
86474: PUSH
86475: EMPTY
86476: LIST
86477: LIST
86478: LIST
86479: PUSH
86480: EMPTY
86481: LIST
86482: LIST
86483: LIST
86484: ST_TO_ADDR
// result := [ ] ;
86485: LD_ADDR_VAR 0 3
86489: PUSH
86490: EMPTY
86491: ST_TO_ADDR
// for i in turrets do
86492: LD_ADDR_VAR 0 4
86496: PUSH
86497: LD_VAR 0 1
86501: PUSH
86502: FOR_IN
86503: IFFALSE 86686
// begin nat := GetNation ( i ) ;
86505: LD_ADDR_VAR 0 7
86509: PUSH
86510: LD_VAR 0 4
86514: PPUSH
86515: CALL_OW 248
86519: ST_TO_ADDR
// weapon := 0 ;
86520: LD_ADDR_VAR 0 8
86524: PUSH
86525: LD_INT 0
86527: ST_TO_ADDR
// if not nat then
86528: LD_VAR 0 7
86532: NOT
86533: IFFALSE 86537
// continue ;
86535: GO 86502
// for j in list [ nat ] do
86537: LD_ADDR_VAR 0 5
86541: PUSH
86542: LD_VAR 0 10
86546: PUSH
86547: LD_VAR 0 7
86551: ARRAY
86552: PUSH
86553: FOR_IN
86554: IFFALSE 86595
// if GetBWeapon ( i ) = j [ 1 ] then
86556: LD_VAR 0 4
86560: PPUSH
86561: CALL_OW 269
86565: PUSH
86566: LD_VAR 0 5
86570: PUSH
86571: LD_INT 1
86573: ARRAY
86574: EQUAL
86575: IFFALSE 86593
// begin weapon := j [ 2 ] ;
86577: LD_ADDR_VAR 0 8
86581: PUSH
86582: LD_VAR 0 5
86586: PUSH
86587: LD_INT 2
86589: ARRAY
86590: ST_TO_ADDR
// break ;
86591: GO 86595
// end ;
86593: GO 86553
86595: POP
86596: POP
// if not weapon then
86597: LD_VAR 0 8
86601: NOT
86602: IFFALSE 86606
// continue ;
86604: GO 86502
// for k in factories do
86606: LD_ADDR_VAR 0 6
86610: PUSH
86611: LD_VAR 0 2
86615: PUSH
86616: FOR_IN
86617: IFFALSE 86682
// begin weapons := AvailableWeaponList ( k ) ;
86619: LD_ADDR_VAR 0 9
86623: PUSH
86624: LD_VAR 0 6
86628: PPUSH
86629: CALL_OW 478
86633: ST_TO_ADDR
// if not weapons then
86634: LD_VAR 0 9
86638: NOT
86639: IFFALSE 86643
// continue ;
86641: GO 86616
// if weapon in weapons then
86643: LD_VAR 0 8
86647: PUSH
86648: LD_VAR 0 9
86652: IN
86653: IFFALSE 86680
// begin result := [ i , weapon ] ;
86655: LD_ADDR_VAR 0 3
86659: PUSH
86660: LD_VAR 0 4
86664: PUSH
86665: LD_VAR 0 8
86669: PUSH
86670: EMPTY
86671: LIST
86672: LIST
86673: ST_TO_ADDR
// exit ;
86674: POP
86675: POP
86676: POP
86677: POP
86678: GO 86688
// end ; end ;
86680: GO 86616
86682: POP
86683: POP
// end ;
86684: GO 86502
86686: POP
86687: POP
// end ;
86688: LD_VAR 0 3
86692: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
86693: LD_INT 0
86695: PPUSH
// if not side or side > 8 then
86696: LD_VAR 0 3
86700: NOT
86701: PUSH
86702: LD_VAR 0 3
86706: PUSH
86707: LD_INT 8
86709: GREATER
86710: OR
86711: IFFALSE 86715
// exit ;
86713: GO 86774
// if not range then
86715: LD_VAR 0 4
86719: NOT
86720: IFFALSE 86731
// range := - 12 ;
86722: LD_ADDR_VAR 0 4
86726: PUSH
86727: LD_INT 12
86729: NEG
86730: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
86731: LD_VAR 0 1
86735: PPUSH
86736: LD_VAR 0 2
86740: PPUSH
86741: LD_VAR 0 3
86745: PPUSH
86746: LD_VAR 0 4
86750: PPUSH
86751: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
86755: LD_VAR 0 1
86759: PPUSH
86760: LD_VAR 0 2
86764: PPUSH
86765: LD_VAR 0 3
86769: PPUSH
86770: CALL_OW 331
// end ;
86774: LD_VAR 0 5
86778: RET
// export function Video ( mode ) ; begin
86779: LD_INT 0
86781: PPUSH
// ingame_video = mode ;
86782: LD_ADDR_OWVAR 52
86786: PUSH
86787: LD_VAR 0 1
86791: ST_TO_ADDR
// interface_hidden = mode ;
86792: LD_ADDR_OWVAR 54
86796: PUSH
86797: LD_VAR 0 1
86801: ST_TO_ADDR
// end ;
86802: LD_VAR 0 2
86806: RET
// export function Join ( array , element ) ; begin
86807: LD_INT 0
86809: PPUSH
// result := Replace ( array , array + 1 , element ) ;
86810: LD_ADDR_VAR 0 3
86814: PUSH
86815: LD_VAR 0 1
86819: PPUSH
86820: LD_VAR 0 1
86824: PUSH
86825: LD_INT 1
86827: PLUS
86828: PPUSH
86829: LD_VAR 0 2
86833: PPUSH
86834: CALL_OW 1
86838: ST_TO_ADDR
// end ;
86839: LD_VAR 0 3
86843: RET
// export function JoinUnion ( array , element ) ; begin
86844: LD_INT 0
86846: PPUSH
// result := array union element ;
86847: LD_ADDR_VAR 0 3
86851: PUSH
86852: LD_VAR 0 1
86856: PUSH
86857: LD_VAR 0 2
86861: UNION
86862: ST_TO_ADDR
// end ;
86863: LD_VAR 0 3
86867: RET
// export function GetBehemoths ( side ) ; begin
86868: LD_INT 0
86870: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
86871: LD_ADDR_VAR 0 2
86875: PUSH
86876: LD_INT 22
86878: PUSH
86879: LD_VAR 0 1
86883: PUSH
86884: EMPTY
86885: LIST
86886: LIST
86887: PUSH
86888: LD_INT 31
86890: PUSH
86891: LD_INT 25
86893: PUSH
86894: EMPTY
86895: LIST
86896: LIST
86897: PUSH
86898: EMPTY
86899: LIST
86900: LIST
86901: PPUSH
86902: CALL_OW 69
86906: ST_TO_ADDR
// end ;
86907: LD_VAR 0 2
86911: RET
// export function Shuffle ( array ) ; var i , index ; begin
86912: LD_INT 0
86914: PPUSH
86915: PPUSH
86916: PPUSH
// result := [ ] ;
86917: LD_ADDR_VAR 0 2
86921: PUSH
86922: EMPTY
86923: ST_TO_ADDR
// if not array then
86924: LD_VAR 0 1
86928: NOT
86929: IFFALSE 86933
// exit ;
86931: GO 87032
// Randomize ;
86933: CALL_OW 10
// for i = array downto 1 do
86937: LD_ADDR_VAR 0 3
86941: PUSH
86942: DOUBLE
86943: LD_VAR 0 1
86947: INC
86948: ST_TO_ADDR
86949: LD_INT 1
86951: PUSH
86952: FOR_DOWNTO
86953: IFFALSE 87030
// begin index := rand ( 1 , array ) ;
86955: LD_ADDR_VAR 0 4
86959: PUSH
86960: LD_INT 1
86962: PPUSH
86963: LD_VAR 0 1
86967: PPUSH
86968: CALL_OW 12
86972: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
86973: LD_ADDR_VAR 0 2
86977: PUSH
86978: LD_VAR 0 2
86982: PPUSH
86983: LD_VAR 0 2
86987: PUSH
86988: LD_INT 1
86990: PLUS
86991: PPUSH
86992: LD_VAR 0 1
86996: PUSH
86997: LD_VAR 0 4
87001: ARRAY
87002: PPUSH
87003: CALL_OW 2
87007: ST_TO_ADDR
// array := Delete ( array , index ) ;
87008: LD_ADDR_VAR 0 1
87012: PUSH
87013: LD_VAR 0 1
87017: PPUSH
87018: LD_VAR 0 4
87022: PPUSH
87023: CALL_OW 3
87027: ST_TO_ADDR
// end ;
87028: GO 86952
87030: POP
87031: POP
// end ;
87032: LD_VAR 0 2
87036: RET
// export function GetBaseMaterials ( base ) ; begin
87037: LD_INT 0
87039: PPUSH
// result := [ 0 , 0 , 0 ] ;
87040: LD_ADDR_VAR 0 2
87044: PUSH
87045: LD_INT 0
87047: PUSH
87048: LD_INT 0
87050: PUSH
87051: LD_INT 0
87053: PUSH
87054: EMPTY
87055: LIST
87056: LIST
87057: LIST
87058: ST_TO_ADDR
// if not base then
87059: LD_VAR 0 1
87063: NOT
87064: IFFALSE 87068
// exit ;
87066: GO 87117
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
87068: LD_ADDR_VAR 0 2
87072: PUSH
87073: LD_VAR 0 1
87077: PPUSH
87078: LD_INT 1
87080: PPUSH
87081: CALL_OW 275
87085: PUSH
87086: LD_VAR 0 1
87090: PPUSH
87091: LD_INT 2
87093: PPUSH
87094: CALL_OW 275
87098: PUSH
87099: LD_VAR 0 1
87103: PPUSH
87104: LD_INT 3
87106: PPUSH
87107: CALL_OW 275
87111: PUSH
87112: EMPTY
87113: LIST
87114: LIST
87115: LIST
87116: ST_TO_ADDR
// end ;
87117: LD_VAR 0 2
87121: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
87122: LD_INT 0
87124: PPUSH
87125: PPUSH
// result := array ;
87126: LD_ADDR_VAR 0 3
87130: PUSH
87131: LD_VAR 0 1
87135: ST_TO_ADDR
// if size >= result then
87136: LD_VAR 0 2
87140: PUSH
87141: LD_VAR 0 3
87145: GREATEREQUAL
87146: IFFALSE 87150
// exit ;
87148: GO 87200
// if size then
87150: LD_VAR 0 2
87154: IFFALSE 87200
// for i := array downto size do
87156: LD_ADDR_VAR 0 4
87160: PUSH
87161: DOUBLE
87162: LD_VAR 0 1
87166: INC
87167: ST_TO_ADDR
87168: LD_VAR 0 2
87172: PUSH
87173: FOR_DOWNTO
87174: IFFALSE 87198
// result := Delete ( result , result ) ;
87176: LD_ADDR_VAR 0 3
87180: PUSH
87181: LD_VAR 0 3
87185: PPUSH
87186: LD_VAR 0 3
87190: PPUSH
87191: CALL_OW 3
87195: ST_TO_ADDR
87196: GO 87173
87198: POP
87199: POP
// end ;
87200: LD_VAR 0 3
87204: RET
// export function ComExit ( unit ) ; var tmp ; begin
87205: LD_INT 0
87207: PPUSH
87208: PPUSH
// if not IsInUnit ( unit ) then
87209: LD_VAR 0 1
87213: PPUSH
87214: CALL_OW 310
87218: NOT
87219: IFFALSE 87223
// exit ;
87221: GO 87283
// tmp := IsInUnit ( unit ) ;
87223: LD_ADDR_VAR 0 3
87227: PUSH
87228: LD_VAR 0 1
87232: PPUSH
87233: CALL_OW 310
87237: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
87238: LD_VAR 0 3
87242: PPUSH
87243: CALL_OW 247
87247: PUSH
87248: LD_INT 2
87250: EQUAL
87251: IFFALSE 87264
// ComExitVehicle ( unit ) else
87253: LD_VAR 0 1
87257: PPUSH
87258: CALL_OW 121
87262: GO 87273
// ComExitBuilding ( unit ) ;
87264: LD_VAR 0 1
87268: PPUSH
87269: CALL_OW 122
// result := tmp ;
87273: LD_ADDR_VAR 0 2
87277: PUSH
87278: LD_VAR 0 3
87282: ST_TO_ADDR
// end ;
87283: LD_VAR 0 2
87287: RET
// export function ComExitAll ( units ) ; var i ; begin
87288: LD_INT 0
87290: PPUSH
87291: PPUSH
// if not units then
87292: LD_VAR 0 1
87296: NOT
87297: IFFALSE 87301
// exit ;
87299: GO 87327
// for i in units do
87301: LD_ADDR_VAR 0 3
87305: PUSH
87306: LD_VAR 0 1
87310: PUSH
87311: FOR_IN
87312: IFFALSE 87325
// ComExit ( i ) ;
87314: LD_VAR 0 3
87318: PPUSH
87319: CALL 87205 0 1
87323: GO 87311
87325: POP
87326: POP
// end ;
87327: LD_VAR 0 2
87331: RET
// export function ResetHc ; begin
87332: LD_INT 0
87334: PPUSH
// InitHc ;
87335: CALL_OW 19
// hc_importance := 0 ;
87339: LD_ADDR_OWVAR 32
87343: PUSH
87344: LD_INT 0
87346: ST_TO_ADDR
// end ;
87347: LD_VAR 0 1
87351: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
87352: LD_INT 0
87354: PPUSH
87355: PPUSH
87356: PPUSH
// _x := ( x1 + x2 ) div 2 ;
87357: LD_ADDR_VAR 0 6
87361: PUSH
87362: LD_VAR 0 1
87366: PUSH
87367: LD_VAR 0 3
87371: PLUS
87372: PUSH
87373: LD_INT 2
87375: DIV
87376: ST_TO_ADDR
// if _x < 0 then
87377: LD_VAR 0 6
87381: PUSH
87382: LD_INT 0
87384: LESS
87385: IFFALSE 87402
// _x := _x * - 1 ;
87387: LD_ADDR_VAR 0 6
87391: PUSH
87392: LD_VAR 0 6
87396: PUSH
87397: LD_INT 1
87399: NEG
87400: MUL
87401: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
87402: LD_ADDR_VAR 0 7
87406: PUSH
87407: LD_VAR 0 2
87411: PUSH
87412: LD_VAR 0 4
87416: PLUS
87417: PUSH
87418: LD_INT 2
87420: DIV
87421: ST_TO_ADDR
// if _y < 0 then
87422: LD_VAR 0 7
87426: PUSH
87427: LD_INT 0
87429: LESS
87430: IFFALSE 87447
// _y := _y * - 1 ;
87432: LD_ADDR_VAR 0 7
87436: PUSH
87437: LD_VAR 0 7
87441: PUSH
87442: LD_INT 1
87444: NEG
87445: MUL
87446: ST_TO_ADDR
// result := [ _x , _y ] ;
87447: LD_ADDR_VAR 0 5
87451: PUSH
87452: LD_VAR 0 6
87456: PUSH
87457: LD_VAR 0 7
87461: PUSH
87462: EMPTY
87463: LIST
87464: LIST
87465: ST_TO_ADDR
// end ;
87466: LD_VAR 0 5
87470: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
87471: LD_INT 0
87473: PPUSH
87474: PPUSH
87475: PPUSH
87476: PPUSH
// task := GetTaskList ( unit ) ;
87477: LD_ADDR_VAR 0 7
87481: PUSH
87482: LD_VAR 0 1
87486: PPUSH
87487: CALL_OW 437
87491: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
87492: LD_VAR 0 7
87496: NOT
87497: PUSH
87498: LD_VAR 0 1
87502: PPUSH
87503: LD_VAR 0 2
87507: PPUSH
87508: CALL_OW 308
87512: NOT
87513: AND
87514: IFFALSE 87518
// exit ;
87516: GO 87636
// if IsInArea ( unit , area ) then
87518: LD_VAR 0 1
87522: PPUSH
87523: LD_VAR 0 2
87527: PPUSH
87528: CALL_OW 308
87532: IFFALSE 87550
// begin ComMoveToArea ( unit , goAway ) ;
87534: LD_VAR 0 1
87538: PPUSH
87539: LD_VAR 0 3
87543: PPUSH
87544: CALL_OW 113
// exit ;
87548: GO 87636
// end ; if task [ 1 ] [ 1 ] <> M then
87550: LD_VAR 0 7
87554: PUSH
87555: LD_INT 1
87557: ARRAY
87558: PUSH
87559: LD_INT 1
87561: ARRAY
87562: PUSH
87563: LD_STRING M
87565: NONEQUAL
87566: IFFALSE 87570
// exit ;
87568: GO 87636
// x := task [ 1 ] [ 2 ] ;
87570: LD_ADDR_VAR 0 5
87574: PUSH
87575: LD_VAR 0 7
87579: PUSH
87580: LD_INT 1
87582: ARRAY
87583: PUSH
87584: LD_INT 2
87586: ARRAY
87587: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
87588: LD_ADDR_VAR 0 6
87592: PUSH
87593: LD_VAR 0 7
87597: PUSH
87598: LD_INT 1
87600: ARRAY
87601: PUSH
87602: LD_INT 3
87604: ARRAY
87605: ST_TO_ADDR
// if InArea ( x , y , area ) then
87606: LD_VAR 0 5
87610: PPUSH
87611: LD_VAR 0 6
87615: PPUSH
87616: LD_VAR 0 2
87620: PPUSH
87621: CALL_OW 309
87625: IFFALSE 87636
// ComStop ( unit ) ;
87627: LD_VAR 0 1
87631: PPUSH
87632: CALL_OW 141
// end ;
87636: LD_VAR 0 4
87640: RET
// export function Abs ( value ) ; begin
87641: LD_INT 0
87643: PPUSH
// result := value ;
87644: LD_ADDR_VAR 0 2
87648: PUSH
87649: LD_VAR 0 1
87653: ST_TO_ADDR
// if value < 0 then
87654: LD_VAR 0 1
87658: PUSH
87659: LD_INT 0
87661: LESS
87662: IFFALSE 87679
// result := value * - 1 ;
87664: LD_ADDR_VAR 0 2
87668: PUSH
87669: LD_VAR 0 1
87673: PUSH
87674: LD_INT 1
87676: NEG
87677: MUL
87678: ST_TO_ADDR
// end ;
87679: LD_VAR 0 2
87683: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
87684: LD_INT 0
87686: PPUSH
87687: PPUSH
87688: PPUSH
87689: PPUSH
87690: PPUSH
87691: PPUSH
87692: PPUSH
87693: PPUSH
// if not unit or not building then
87694: LD_VAR 0 1
87698: NOT
87699: PUSH
87700: LD_VAR 0 2
87704: NOT
87705: OR
87706: IFFALSE 87710
// exit ;
87708: GO 87936
// x := GetX ( building ) ;
87710: LD_ADDR_VAR 0 4
87714: PUSH
87715: LD_VAR 0 2
87719: PPUSH
87720: CALL_OW 250
87724: ST_TO_ADDR
// y := GetY ( building ) ;
87725: LD_ADDR_VAR 0 6
87729: PUSH
87730: LD_VAR 0 2
87734: PPUSH
87735: CALL_OW 251
87739: ST_TO_ADDR
// d := GetDir ( building ) ;
87740: LD_ADDR_VAR 0 8
87744: PUSH
87745: LD_VAR 0 2
87749: PPUSH
87750: CALL_OW 254
87754: ST_TO_ADDR
// r := 4 ;
87755: LD_ADDR_VAR 0 9
87759: PUSH
87760: LD_INT 4
87762: ST_TO_ADDR
// for i := 1 to 5 do
87763: LD_ADDR_VAR 0 10
87767: PUSH
87768: DOUBLE
87769: LD_INT 1
87771: DEC
87772: ST_TO_ADDR
87773: LD_INT 5
87775: PUSH
87776: FOR_TO
87777: IFFALSE 87934
// begin _x := ShiftX ( x , d , r + i ) ;
87779: LD_ADDR_VAR 0 5
87783: PUSH
87784: LD_VAR 0 4
87788: PPUSH
87789: LD_VAR 0 8
87793: PPUSH
87794: LD_VAR 0 9
87798: PUSH
87799: LD_VAR 0 10
87803: PLUS
87804: PPUSH
87805: CALL_OW 272
87809: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
87810: LD_ADDR_VAR 0 7
87814: PUSH
87815: LD_VAR 0 6
87819: PPUSH
87820: LD_VAR 0 8
87824: PPUSH
87825: LD_VAR 0 9
87829: PUSH
87830: LD_VAR 0 10
87834: PLUS
87835: PPUSH
87836: CALL_OW 273
87840: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
87841: LD_VAR 0 5
87845: PPUSH
87846: LD_VAR 0 7
87850: PPUSH
87851: CALL_OW 488
87855: PUSH
87856: LD_VAR 0 5
87860: PPUSH
87861: LD_VAR 0 7
87865: PPUSH
87866: CALL_OW 428
87870: PPUSH
87871: CALL_OW 247
87875: PUSH
87876: LD_INT 3
87878: PUSH
87879: LD_INT 2
87881: PUSH
87882: EMPTY
87883: LIST
87884: LIST
87885: IN
87886: NOT
87887: AND
87888: IFFALSE 87932
// begin ComMoveXY ( unit , _x , _y ) ;
87890: LD_VAR 0 1
87894: PPUSH
87895: LD_VAR 0 5
87899: PPUSH
87900: LD_VAR 0 7
87904: PPUSH
87905: CALL_OW 111
// result := [ _x , _y ] ;
87909: LD_ADDR_VAR 0 3
87913: PUSH
87914: LD_VAR 0 5
87918: PUSH
87919: LD_VAR 0 7
87923: PUSH
87924: EMPTY
87925: LIST
87926: LIST
87927: ST_TO_ADDR
// exit ;
87928: POP
87929: POP
87930: GO 87936
// end ; end ;
87932: GO 87776
87934: POP
87935: POP
// end ;
87936: LD_VAR 0 3
87940: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
87941: LD_INT 0
87943: PPUSH
87944: PPUSH
87945: PPUSH
// result := 0 ;
87946: LD_ADDR_VAR 0 3
87950: PUSH
87951: LD_INT 0
87953: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
87954: LD_VAR 0 1
87958: PUSH
87959: LD_INT 0
87961: LESS
87962: PUSH
87963: LD_VAR 0 1
87967: PUSH
87968: LD_INT 8
87970: GREATER
87971: OR
87972: PUSH
87973: LD_VAR 0 2
87977: PUSH
87978: LD_INT 0
87980: LESS
87981: OR
87982: PUSH
87983: LD_VAR 0 2
87987: PUSH
87988: LD_INT 8
87990: GREATER
87991: OR
87992: IFFALSE 87996
// exit ;
87994: GO 88071
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
87996: LD_ADDR_VAR 0 4
88000: PUSH
88001: LD_INT 22
88003: PUSH
88004: LD_VAR 0 2
88008: PUSH
88009: EMPTY
88010: LIST
88011: LIST
88012: PPUSH
88013: CALL_OW 69
88017: PUSH
88018: FOR_IN
88019: IFFALSE 88069
// begin un := UnitShoot ( i ) ;
88021: LD_ADDR_VAR 0 5
88025: PUSH
88026: LD_VAR 0 4
88030: PPUSH
88031: CALL_OW 504
88035: ST_TO_ADDR
// if GetSide ( un ) = side1 then
88036: LD_VAR 0 5
88040: PPUSH
88041: CALL_OW 255
88045: PUSH
88046: LD_VAR 0 1
88050: EQUAL
88051: IFFALSE 88067
// begin result := un ;
88053: LD_ADDR_VAR 0 3
88057: PUSH
88058: LD_VAR 0 5
88062: ST_TO_ADDR
// exit ;
88063: POP
88064: POP
88065: GO 88071
// end ; end ;
88067: GO 88018
88069: POP
88070: POP
// end ;
88071: LD_VAR 0 3
88075: RET
// export function GetCargoBay ( units ) ; begin
88076: LD_INT 0
88078: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
88079: LD_ADDR_VAR 0 2
88083: PUSH
88084: LD_VAR 0 1
88088: PPUSH
88089: LD_INT 2
88091: PUSH
88092: LD_INT 34
88094: PUSH
88095: LD_INT 12
88097: PUSH
88098: EMPTY
88099: LIST
88100: LIST
88101: PUSH
88102: LD_INT 34
88104: PUSH
88105: LD_INT 51
88107: PUSH
88108: EMPTY
88109: LIST
88110: LIST
88111: PUSH
88112: LD_INT 34
88114: PUSH
88115: LD_INT 32
88117: PUSH
88118: EMPTY
88119: LIST
88120: LIST
88121: PUSH
88122: LD_INT 34
88124: PUSH
88125: LD_INT 89
88127: PUSH
88128: EMPTY
88129: LIST
88130: LIST
88131: PUSH
88132: EMPTY
88133: LIST
88134: LIST
88135: LIST
88136: LIST
88137: LIST
88138: PPUSH
88139: CALL_OW 72
88143: ST_TO_ADDR
// end ;
88144: LD_VAR 0 2
88148: RET
// export function Negate ( value ) ; begin
88149: LD_INT 0
88151: PPUSH
// result := not value ;
88152: LD_ADDR_VAR 0 2
88156: PUSH
88157: LD_VAR 0 1
88161: NOT
88162: ST_TO_ADDR
// end ;
88163: LD_VAR 0 2
88167: RET
// export function Inc ( value ) ; begin
88168: LD_INT 0
88170: PPUSH
// result := value + 1 ;
88171: LD_ADDR_VAR 0 2
88175: PUSH
88176: LD_VAR 0 1
88180: PUSH
88181: LD_INT 1
88183: PLUS
88184: ST_TO_ADDR
// end ;
88185: LD_VAR 0 2
88189: RET
// export function Dec ( value ) ; begin
88190: LD_INT 0
88192: PPUSH
// result := value - 1 ;
88193: LD_ADDR_VAR 0 2
88197: PUSH
88198: LD_VAR 0 1
88202: PUSH
88203: LD_INT 1
88205: MINUS
88206: ST_TO_ADDR
// end ;
88207: LD_VAR 0 2
88211: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
88212: LD_INT 0
88214: PPUSH
88215: PPUSH
88216: PPUSH
88217: PPUSH
88218: PPUSH
88219: PPUSH
88220: PPUSH
88221: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
88222: LD_VAR 0 1
88226: PPUSH
88227: LD_VAR 0 2
88231: PPUSH
88232: CALL_OW 488
88236: NOT
88237: PUSH
88238: LD_VAR 0 3
88242: PPUSH
88243: LD_VAR 0 4
88247: PPUSH
88248: CALL_OW 488
88252: NOT
88253: OR
88254: IFFALSE 88267
// begin result := - 1 ;
88256: LD_ADDR_VAR 0 5
88260: PUSH
88261: LD_INT 1
88263: NEG
88264: ST_TO_ADDR
// exit ;
88265: GO 88502
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
88267: LD_ADDR_VAR 0 12
88271: PUSH
88272: LD_VAR 0 1
88276: PPUSH
88277: LD_VAR 0 2
88281: PPUSH
88282: LD_VAR 0 3
88286: PPUSH
88287: LD_VAR 0 4
88291: PPUSH
88292: CALL 87352 0 4
88296: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
88297: LD_ADDR_VAR 0 11
88301: PUSH
88302: LD_VAR 0 1
88306: PPUSH
88307: LD_VAR 0 2
88311: PPUSH
88312: LD_VAR 0 12
88316: PUSH
88317: LD_INT 1
88319: ARRAY
88320: PPUSH
88321: LD_VAR 0 12
88325: PUSH
88326: LD_INT 2
88328: ARRAY
88329: PPUSH
88330: CALL_OW 298
88334: ST_TO_ADDR
// distance := 9999 ;
88335: LD_ADDR_VAR 0 10
88339: PUSH
88340: LD_INT 9999
88342: ST_TO_ADDR
// for i := 0 to 5 do
88343: LD_ADDR_VAR 0 6
88347: PUSH
88348: DOUBLE
88349: LD_INT 0
88351: DEC
88352: ST_TO_ADDR
88353: LD_INT 5
88355: PUSH
88356: FOR_TO
88357: IFFALSE 88500
// begin _x := ShiftX ( x1 , i , centerDist ) ;
88359: LD_ADDR_VAR 0 7
88363: PUSH
88364: LD_VAR 0 1
88368: PPUSH
88369: LD_VAR 0 6
88373: PPUSH
88374: LD_VAR 0 11
88378: PPUSH
88379: CALL_OW 272
88383: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
88384: LD_ADDR_VAR 0 8
88388: PUSH
88389: LD_VAR 0 2
88393: PPUSH
88394: LD_VAR 0 6
88398: PPUSH
88399: LD_VAR 0 11
88403: PPUSH
88404: CALL_OW 273
88408: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
88409: LD_VAR 0 7
88413: PPUSH
88414: LD_VAR 0 8
88418: PPUSH
88419: CALL_OW 488
88423: NOT
88424: IFFALSE 88428
// continue ;
88426: GO 88356
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
88428: LD_ADDR_VAR 0 9
88432: PUSH
88433: LD_VAR 0 12
88437: PUSH
88438: LD_INT 1
88440: ARRAY
88441: PPUSH
88442: LD_VAR 0 12
88446: PUSH
88447: LD_INT 2
88449: ARRAY
88450: PPUSH
88451: LD_VAR 0 7
88455: PPUSH
88456: LD_VAR 0 8
88460: PPUSH
88461: CALL_OW 298
88465: ST_TO_ADDR
// if tmp < distance then
88466: LD_VAR 0 9
88470: PUSH
88471: LD_VAR 0 10
88475: LESS
88476: IFFALSE 88498
// begin result := i ;
88478: LD_ADDR_VAR 0 5
88482: PUSH
88483: LD_VAR 0 6
88487: ST_TO_ADDR
// distance := tmp ;
88488: LD_ADDR_VAR 0 10
88492: PUSH
88493: LD_VAR 0 9
88497: ST_TO_ADDR
// end ; end ;
88498: GO 88356
88500: POP
88501: POP
// end ;
88502: LD_VAR 0 5
88506: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
88507: LD_INT 0
88509: PPUSH
88510: PPUSH
// if not driver or not IsInUnit ( driver ) then
88511: LD_VAR 0 1
88515: NOT
88516: PUSH
88517: LD_VAR 0 1
88521: PPUSH
88522: CALL_OW 310
88526: NOT
88527: OR
88528: IFFALSE 88532
// exit ;
88530: GO 88622
// vehicle := IsInUnit ( driver ) ;
88532: LD_ADDR_VAR 0 3
88536: PUSH
88537: LD_VAR 0 1
88541: PPUSH
88542: CALL_OW 310
88546: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
88547: LD_VAR 0 1
88551: PPUSH
88552: LD_STRING \
88554: PUSH
88555: LD_INT 0
88557: PUSH
88558: LD_INT 0
88560: PUSH
88561: LD_INT 0
88563: PUSH
88564: LD_INT 0
88566: PUSH
88567: LD_INT 0
88569: PUSH
88570: LD_INT 0
88572: PUSH
88573: EMPTY
88574: LIST
88575: LIST
88576: LIST
88577: LIST
88578: LIST
88579: LIST
88580: LIST
88581: PUSH
88582: LD_STRING E
88584: PUSH
88585: LD_INT 0
88587: PUSH
88588: LD_INT 0
88590: PUSH
88591: LD_VAR 0 3
88595: PUSH
88596: LD_INT 0
88598: PUSH
88599: LD_INT 0
88601: PUSH
88602: LD_INT 0
88604: PUSH
88605: EMPTY
88606: LIST
88607: LIST
88608: LIST
88609: LIST
88610: LIST
88611: LIST
88612: LIST
88613: PUSH
88614: EMPTY
88615: LIST
88616: LIST
88617: PPUSH
88618: CALL_OW 446
// end ;
88622: LD_VAR 0 2
88626: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
88627: LD_INT 0
88629: PPUSH
88630: PPUSH
// if not driver or not IsInUnit ( driver ) then
88631: LD_VAR 0 1
88635: NOT
88636: PUSH
88637: LD_VAR 0 1
88641: PPUSH
88642: CALL_OW 310
88646: NOT
88647: OR
88648: IFFALSE 88652
// exit ;
88650: GO 88742
// vehicle := IsInUnit ( driver ) ;
88652: LD_ADDR_VAR 0 3
88656: PUSH
88657: LD_VAR 0 1
88661: PPUSH
88662: CALL_OW 310
88666: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
88667: LD_VAR 0 1
88671: PPUSH
88672: LD_STRING \
88674: PUSH
88675: LD_INT 0
88677: PUSH
88678: LD_INT 0
88680: PUSH
88681: LD_INT 0
88683: PUSH
88684: LD_INT 0
88686: PUSH
88687: LD_INT 0
88689: PUSH
88690: LD_INT 0
88692: PUSH
88693: EMPTY
88694: LIST
88695: LIST
88696: LIST
88697: LIST
88698: LIST
88699: LIST
88700: LIST
88701: PUSH
88702: LD_STRING E
88704: PUSH
88705: LD_INT 0
88707: PUSH
88708: LD_INT 0
88710: PUSH
88711: LD_VAR 0 3
88715: PUSH
88716: LD_INT 0
88718: PUSH
88719: LD_INT 0
88721: PUSH
88722: LD_INT 0
88724: PUSH
88725: EMPTY
88726: LIST
88727: LIST
88728: LIST
88729: LIST
88730: LIST
88731: LIST
88732: LIST
88733: PUSH
88734: EMPTY
88735: LIST
88736: LIST
88737: PPUSH
88738: CALL_OW 447
// end ;
88742: LD_VAR 0 2
88746: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
88747: LD_INT 0
88749: PPUSH
88750: PPUSH
88751: PPUSH
// tmp := [ ] ;
88752: LD_ADDR_VAR 0 5
88756: PUSH
88757: EMPTY
88758: ST_TO_ADDR
// for i in units do
88759: LD_ADDR_VAR 0 4
88763: PUSH
88764: LD_VAR 0 1
88768: PUSH
88769: FOR_IN
88770: IFFALSE 88808
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
88772: LD_ADDR_VAR 0 5
88776: PUSH
88777: LD_VAR 0 5
88781: PPUSH
88782: LD_VAR 0 5
88786: PUSH
88787: LD_INT 1
88789: PLUS
88790: PPUSH
88791: LD_VAR 0 4
88795: PPUSH
88796: CALL_OW 256
88800: PPUSH
88801: CALL_OW 2
88805: ST_TO_ADDR
88806: GO 88769
88808: POP
88809: POP
// if not tmp then
88810: LD_VAR 0 5
88814: NOT
88815: IFFALSE 88819
// exit ;
88817: GO 88867
// if asc then
88819: LD_VAR 0 2
88823: IFFALSE 88847
// result := SortListByListAsc ( units , tmp ) else
88825: LD_ADDR_VAR 0 3
88829: PUSH
88830: LD_VAR 0 1
88834: PPUSH
88835: LD_VAR 0 5
88839: PPUSH
88840: CALL_OW 76
88844: ST_TO_ADDR
88845: GO 88867
// result := SortListByListDesc ( units , tmp ) ;
88847: LD_ADDR_VAR 0 3
88851: PUSH
88852: LD_VAR 0 1
88856: PPUSH
88857: LD_VAR 0 5
88861: PPUSH
88862: CALL_OW 77
88866: ST_TO_ADDR
// end ;
88867: LD_VAR 0 3
88871: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
88872: LD_INT 0
88874: PPUSH
88875: PPUSH
// task := GetTaskList ( mech ) ;
88876: LD_ADDR_VAR 0 4
88880: PUSH
88881: LD_VAR 0 1
88885: PPUSH
88886: CALL_OW 437
88890: ST_TO_ADDR
// if not task then
88891: LD_VAR 0 4
88895: NOT
88896: IFFALSE 88900
// exit ;
88898: GO 88942
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
88900: LD_ADDR_VAR 0 3
88904: PUSH
88905: LD_VAR 0 4
88909: PUSH
88910: LD_INT 1
88912: ARRAY
88913: PUSH
88914: LD_INT 1
88916: ARRAY
88917: PUSH
88918: LD_STRING r
88920: EQUAL
88921: PUSH
88922: LD_VAR 0 4
88926: PUSH
88927: LD_INT 1
88929: ARRAY
88930: PUSH
88931: LD_INT 4
88933: ARRAY
88934: PUSH
88935: LD_VAR 0 2
88939: EQUAL
88940: AND
88941: ST_TO_ADDR
// end ;
88942: LD_VAR 0 3
88946: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
88947: LD_INT 0
88949: PPUSH
// SetDir ( unit , d ) ;
88950: LD_VAR 0 1
88954: PPUSH
88955: LD_VAR 0 4
88959: PPUSH
88960: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
88964: LD_VAR 0 1
88968: PPUSH
88969: LD_VAR 0 2
88973: PPUSH
88974: LD_VAR 0 3
88978: PPUSH
88979: LD_VAR 0 5
88983: PPUSH
88984: CALL_OW 48
// end ;
88988: LD_VAR 0 6
88992: RET
// export function ToNaturalNumber ( number ) ; begin
88993: LD_INT 0
88995: PPUSH
// result := number div 1 ;
88996: LD_ADDR_VAR 0 2
89000: PUSH
89001: LD_VAR 0 1
89005: PUSH
89006: LD_INT 1
89008: DIV
89009: ST_TO_ADDR
// if number < 0 then
89010: LD_VAR 0 1
89014: PUSH
89015: LD_INT 0
89017: LESS
89018: IFFALSE 89028
// result := 0 ;
89020: LD_ADDR_VAR 0 2
89024: PUSH
89025: LD_INT 0
89027: ST_TO_ADDR
// end ;
89028: LD_VAR 0 2
89032: RET
// export function SortByClass ( units , class ) ; var un ; begin
89033: LD_INT 0
89035: PPUSH
89036: PPUSH
// if not units or not class then
89037: LD_VAR 0 1
89041: NOT
89042: PUSH
89043: LD_VAR 0 2
89047: NOT
89048: OR
89049: IFFALSE 89053
// exit ;
89051: GO 89148
// result := [ ] ;
89053: LD_ADDR_VAR 0 3
89057: PUSH
89058: EMPTY
89059: ST_TO_ADDR
// for un in units do
89060: LD_ADDR_VAR 0 4
89064: PUSH
89065: LD_VAR 0 1
89069: PUSH
89070: FOR_IN
89071: IFFALSE 89146
// if GetClass ( un ) = class then
89073: LD_VAR 0 4
89077: PPUSH
89078: CALL_OW 257
89082: PUSH
89083: LD_VAR 0 2
89087: EQUAL
89088: IFFALSE 89115
// result := Insert ( result , 1 , un ) else
89090: LD_ADDR_VAR 0 3
89094: PUSH
89095: LD_VAR 0 3
89099: PPUSH
89100: LD_INT 1
89102: PPUSH
89103: LD_VAR 0 4
89107: PPUSH
89108: CALL_OW 2
89112: ST_TO_ADDR
89113: GO 89144
// result := Replace ( result , result + 1 , un ) ;
89115: LD_ADDR_VAR 0 3
89119: PUSH
89120: LD_VAR 0 3
89124: PPUSH
89125: LD_VAR 0 3
89129: PUSH
89130: LD_INT 1
89132: PLUS
89133: PPUSH
89134: LD_VAR 0 4
89138: PPUSH
89139: CALL_OW 1
89143: ST_TO_ADDR
89144: GO 89070
89146: POP
89147: POP
// end ;
89148: LD_VAR 0 3
89152: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
89153: LD_INT 0
89155: PPUSH
89156: PPUSH
89157: PPUSH
89158: PPUSH
89159: PPUSH
89160: PPUSH
89161: PPUSH
// result := [ ] ;
89162: LD_ADDR_VAR 0 4
89166: PUSH
89167: EMPTY
89168: ST_TO_ADDR
// if x - r < 0 then
89169: LD_VAR 0 1
89173: PUSH
89174: LD_VAR 0 3
89178: MINUS
89179: PUSH
89180: LD_INT 0
89182: LESS
89183: IFFALSE 89195
// min_x := 0 else
89185: LD_ADDR_VAR 0 8
89189: PUSH
89190: LD_INT 0
89192: ST_TO_ADDR
89193: GO 89211
// min_x := x - r ;
89195: LD_ADDR_VAR 0 8
89199: PUSH
89200: LD_VAR 0 1
89204: PUSH
89205: LD_VAR 0 3
89209: MINUS
89210: ST_TO_ADDR
// if y - r < 0 then
89211: LD_VAR 0 2
89215: PUSH
89216: LD_VAR 0 3
89220: MINUS
89221: PUSH
89222: LD_INT 0
89224: LESS
89225: IFFALSE 89237
// min_y := 0 else
89227: LD_ADDR_VAR 0 7
89231: PUSH
89232: LD_INT 0
89234: ST_TO_ADDR
89235: GO 89253
// min_y := y - r ;
89237: LD_ADDR_VAR 0 7
89241: PUSH
89242: LD_VAR 0 2
89246: PUSH
89247: LD_VAR 0 3
89251: MINUS
89252: ST_TO_ADDR
// max_x := x + r ;
89253: LD_ADDR_VAR 0 9
89257: PUSH
89258: LD_VAR 0 1
89262: PUSH
89263: LD_VAR 0 3
89267: PLUS
89268: ST_TO_ADDR
// max_y := y + r ;
89269: LD_ADDR_VAR 0 10
89273: PUSH
89274: LD_VAR 0 2
89278: PUSH
89279: LD_VAR 0 3
89283: PLUS
89284: ST_TO_ADDR
// for _x = min_x to max_x do
89285: LD_ADDR_VAR 0 5
89289: PUSH
89290: DOUBLE
89291: LD_VAR 0 8
89295: DEC
89296: ST_TO_ADDR
89297: LD_VAR 0 9
89301: PUSH
89302: FOR_TO
89303: IFFALSE 89404
// for _y = min_y to max_y do
89305: LD_ADDR_VAR 0 6
89309: PUSH
89310: DOUBLE
89311: LD_VAR 0 7
89315: DEC
89316: ST_TO_ADDR
89317: LD_VAR 0 10
89321: PUSH
89322: FOR_TO
89323: IFFALSE 89400
// begin if not ValidHex ( _x , _y ) then
89325: LD_VAR 0 5
89329: PPUSH
89330: LD_VAR 0 6
89334: PPUSH
89335: CALL_OW 488
89339: NOT
89340: IFFALSE 89344
// continue ;
89342: GO 89322
// if GetResourceTypeXY ( _x , _y ) then
89344: LD_VAR 0 5
89348: PPUSH
89349: LD_VAR 0 6
89353: PPUSH
89354: CALL_OW 283
89358: IFFALSE 89398
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
89360: LD_ADDR_VAR 0 4
89364: PUSH
89365: LD_VAR 0 4
89369: PPUSH
89370: LD_VAR 0 4
89374: PUSH
89375: LD_INT 1
89377: PLUS
89378: PPUSH
89379: LD_VAR 0 5
89383: PUSH
89384: LD_VAR 0 6
89388: PUSH
89389: EMPTY
89390: LIST
89391: LIST
89392: PPUSH
89393: CALL_OW 1
89397: ST_TO_ADDR
// end ;
89398: GO 89322
89400: POP
89401: POP
89402: GO 89302
89404: POP
89405: POP
// end ;
89406: LD_VAR 0 4
89410: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
89411: LD_INT 0
89413: PPUSH
89414: PPUSH
89415: PPUSH
89416: PPUSH
89417: PPUSH
89418: PPUSH
89419: PPUSH
89420: PPUSH
// if not units then
89421: LD_VAR 0 1
89425: NOT
89426: IFFALSE 89430
// exit ;
89428: GO 89954
// result := UnitFilter ( units , [ f_ok ] ) ;
89430: LD_ADDR_VAR 0 3
89434: PUSH
89435: LD_VAR 0 1
89439: PPUSH
89440: LD_INT 50
89442: PUSH
89443: EMPTY
89444: LIST
89445: PPUSH
89446: CALL_OW 72
89450: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
89451: LD_ADDR_VAR 0 8
89455: PUSH
89456: LD_VAR 0 1
89460: PUSH
89461: LD_INT 1
89463: ARRAY
89464: PPUSH
89465: CALL_OW 255
89469: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
89470: LD_ADDR_VAR 0 10
89474: PUSH
89475: LD_INT 29
89477: PUSH
89478: LD_INT 91
89480: PUSH
89481: LD_INT 49
89483: PUSH
89484: EMPTY
89485: LIST
89486: LIST
89487: LIST
89488: ST_TO_ADDR
// if not result then
89489: LD_VAR 0 3
89493: NOT
89494: IFFALSE 89498
// exit ;
89496: GO 89954
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
89498: LD_ADDR_VAR 0 5
89502: PUSH
89503: LD_INT 81
89505: PUSH
89506: LD_VAR 0 8
89510: PUSH
89511: EMPTY
89512: LIST
89513: LIST
89514: PPUSH
89515: CALL_OW 69
89519: ST_TO_ADDR
// for i in result do
89520: LD_ADDR_VAR 0 4
89524: PUSH
89525: LD_VAR 0 3
89529: PUSH
89530: FOR_IN
89531: IFFALSE 89952
// begin tag := GetTag ( i ) + 1 ;
89533: LD_ADDR_VAR 0 9
89537: PUSH
89538: LD_VAR 0 4
89542: PPUSH
89543: CALL_OW 110
89547: PUSH
89548: LD_INT 1
89550: PLUS
89551: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
89552: LD_ADDR_VAR 0 7
89556: PUSH
89557: LD_VAR 0 4
89561: PPUSH
89562: CALL_OW 250
89566: PPUSH
89567: LD_VAR 0 4
89571: PPUSH
89572: CALL_OW 251
89576: PPUSH
89577: LD_INT 6
89579: PPUSH
89580: CALL 89153 0 3
89584: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
89585: LD_VAR 0 4
89589: PPUSH
89590: CALL_OW 247
89594: PUSH
89595: LD_INT 2
89597: EQUAL
89598: PUSH
89599: LD_VAR 0 7
89603: AND
89604: PUSH
89605: LD_VAR 0 4
89609: PPUSH
89610: CALL_OW 264
89614: PUSH
89615: LD_VAR 0 10
89619: IN
89620: NOT
89621: AND
89622: IFFALSE 89661
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
89624: LD_VAR 0 4
89628: PPUSH
89629: LD_VAR 0 7
89633: PUSH
89634: LD_INT 1
89636: ARRAY
89637: PUSH
89638: LD_INT 1
89640: ARRAY
89641: PPUSH
89642: LD_VAR 0 7
89646: PUSH
89647: LD_INT 1
89649: ARRAY
89650: PUSH
89651: LD_INT 2
89653: ARRAY
89654: PPUSH
89655: CALL_OW 116
89659: GO 89950
// if path > tag then
89661: LD_VAR 0 2
89665: PUSH
89666: LD_VAR 0 9
89670: GREATER
89671: IFFALSE 89879
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
89673: LD_ADDR_VAR 0 6
89677: PUSH
89678: LD_VAR 0 5
89682: PPUSH
89683: LD_INT 91
89685: PUSH
89686: LD_VAR 0 4
89690: PUSH
89691: LD_INT 8
89693: PUSH
89694: EMPTY
89695: LIST
89696: LIST
89697: LIST
89698: PPUSH
89699: CALL_OW 72
89703: ST_TO_ADDR
// if nearEnemy then
89704: LD_VAR 0 6
89708: IFFALSE 89777
// begin if GetWeapon ( i ) = ru_time_lapser then
89710: LD_VAR 0 4
89714: PPUSH
89715: CALL_OW 264
89719: PUSH
89720: LD_INT 49
89722: EQUAL
89723: IFFALSE 89751
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
89725: LD_VAR 0 4
89729: PPUSH
89730: LD_VAR 0 6
89734: PPUSH
89735: LD_VAR 0 4
89739: PPUSH
89740: CALL_OW 74
89744: PPUSH
89745: CALL_OW 112
89749: GO 89775
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
89751: LD_VAR 0 4
89755: PPUSH
89756: LD_VAR 0 6
89760: PPUSH
89761: LD_VAR 0 4
89765: PPUSH
89766: CALL_OW 74
89770: PPUSH
89771: CALL 90879 0 2
// end else
89775: GO 89877
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
89777: LD_VAR 0 4
89781: PPUSH
89782: LD_VAR 0 2
89786: PUSH
89787: LD_VAR 0 9
89791: ARRAY
89792: PUSH
89793: LD_INT 1
89795: ARRAY
89796: PPUSH
89797: LD_VAR 0 2
89801: PUSH
89802: LD_VAR 0 9
89806: ARRAY
89807: PUSH
89808: LD_INT 2
89810: ARRAY
89811: PPUSH
89812: CALL_OW 297
89816: PUSH
89817: LD_INT 6
89819: GREATER
89820: IFFALSE 89863
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
89822: LD_VAR 0 4
89826: PPUSH
89827: LD_VAR 0 2
89831: PUSH
89832: LD_VAR 0 9
89836: ARRAY
89837: PUSH
89838: LD_INT 1
89840: ARRAY
89841: PPUSH
89842: LD_VAR 0 2
89846: PUSH
89847: LD_VAR 0 9
89851: ARRAY
89852: PUSH
89853: LD_INT 2
89855: ARRAY
89856: PPUSH
89857: CALL_OW 114
89861: GO 89877
// SetTag ( i , tag ) ;
89863: LD_VAR 0 4
89867: PPUSH
89868: LD_VAR 0 9
89872: PPUSH
89873: CALL_OW 109
// end else
89877: GO 89950
// if enemy then
89879: LD_VAR 0 5
89883: IFFALSE 89950
// begin if GetWeapon ( i ) = ru_time_lapser then
89885: LD_VAR 0 4
89889: PPUSH
89890: CALL_OW 264
89894: PUSH
89895: LD_INT 49
89897: EQUAL
89898: IFFALSE 89926
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
89900: LD_VAR 0 4
89904: PPUSH
89905: LD_VAR 0 5
89909: PPUSH
89910: LD_VAR 0 4
89914: PPUSH
89915: CALL_OW 74
89919: PPUSH
89920: CALL_OW 112
89924: GO 89950
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
89926: LD_VAR 0 4
89930: PPUSH
89931: LD_VAR 0 5
89935: PPUSH
89936: LD_VAR 0 4
89940: PPUSH
89941: CALL_OW 74
89945: PPUSH
89946: CALL 90879 0 2
// end ; end ;
89950: GO 89530
89952: POP
89953: POP
// end ;
89954: LD_VAR 0 3
89958: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
89959: LD_INT 0
89961: PPUSH
89962: PPUSH
89963: PPUSH
// if not unit or IsInUnit ( unit ) then
89964: LD_VAR 0 1
89968: NOT
89969: PUSH
89970: LD_VAR 0 1
89974: PPUSH
89975: CALL_OW 310
89979: OR
89980: IFFALSE 89984
// exit ;
89982: GO 90075
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
89984: LD_ADDR_VAR 0 4
89988: PUSH
89989: LD_VAR 0 1
89993: PPUSH
89994: CALL_OW 250
89998: PPUSH
89999: LD_VAR 0 2
90003: PPUSH
90004: LD_INT 1
90006: PPUSH
90007: CALL_OW 272
90011: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
90012: LD_ADDR_VAR 0 5
90016: PUSH
90017: LD_VAR 0 1
90021: PPUSH
90022: CALL_OW 251
90026: PPUSH
90027: LD_VAR 0 2
90031: PPUSH
90032: LD_INT 1
90034: PPUSH
90035: CALL_OW 273
90039: ST_TO_ADDR
// if ValidHex ( x , y ) then
90040: LD_VAR 0 4
90044: PPUSH
90045: LD_VAR 0 5
90049: PPUSH
90050: CALL_OW 488
90054: IFFALSE 90075
// ComTurnXY ( unit , x , y ) ;
90056: LD_VAR 0 1
90060: PPUSH
90061: LD_VAR 0 4
90065: PPUSH
90066: LD_VAR 0 5
90070: PPUSH
90071: CALL_OW 118
// end ;
90075: LD_VAR 0 3
90079: RET
// export function SeeUnits ( side , units ) ; var i ; begin
90080: LD_INT 0
90082: PPUSH
90083: PPUSH
// result := false ;
90084: LD_ADDR_VAR 0 3
90088: PUSH
90089: LD_INT 0
90091: ST_TO_ADDR
// if not units then
90092: LD_VAR 0 2
90096: NOT
90097: IFFALSE 90101
// exit ;
90099: GO 90146
// for i in units do
90101: LD_ADDR_VAR 0 4
90105: PUSH
90106: LD_VAR 0 2
90110: PUSH
90111: FOR_IN
90112: IFFALSE 90144
// if See ( side , i ) then
90114: LD_VAR 0 1
90118: PPUSH
90119: LD_VAR 0 4
90123: PPUSH
90124: CALL_OW 292
90128: IFFALSE 90142
// begin result := true ;
90130: LD_ADDR_VAR 0 3
90134: PUSH
90135: LD_INT 1
90137: ST_TO_ADDR
// exit ;
90138: POP
90139: POP
90140: GO 90146
// end ;
90142: GO 90111
90144: POP
90145: POP
// end ;
90146: LD_VAR 0 3
90150: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
90151: LD_INT 0
90153: PPUSH
90154: PPUSH
90155: PPUSH
90156: PPUSH
// if not unit or not points then
90157: LD_VAR 0 1
90161: NOT
90162: PUSH
90163: LD_VAR 0 2
90167: NOT
90168: OR
90169: IFFALSE 90173
// exit ;
90171: GO 90263
// dist := 99999 ;
90173: LD_ADDR_VAR 0 5
90177: PUSH
90178: LD_INT 99999
90180: ST_TO_ADDR
// for i in points do
90181: LD_ADDR_VAR 0 4
90185: PUSH
90186: LD_VAR 0 2
90190: PUSH
90191: FOR_IN
90192: IFFALSE 90261
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
90194: LD_ADDR_VAR 0 6
90198: PUSH
90199: LD_VAR 0 1
90203: PPUSH
90204: LD_VAR 0 4
90208: PUSH
90209: LD_INT 1
90211: ARRAY
90212: PPUSH
90213: LD_VAR 0 4
90217: PUSH
90218: LD_INT 2
90220: ARRAY
90221: PPUSH
90222: CALL_OW 297
90226: ST_TO_ADDR
// if tmpDist < dist then
90227: LD_VAR 0 6
90231: PUSH
90232: LD_VAR 0 5
90236: LESS
90237: IFFALSE 90259
// begin result := i ;
90239: LD_ADDR_VAR 0 3
90243: PUSH
90244: LD_VAR 0 4
90248: ST_TO_ADDR
// dist := tmpDist ;
90249: LD_ADDR_VAR 0 5
90253: PUSH
90254: LD_VAR 0 6
90258: ST_TO_ADDR
// end ; end ;
90259: GO 90191
90261: POP
90262: POP
// end ;
90263: LD_VAR 0 3
90267: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
90268: LD_INT 0
90270: PPUSH
// uc_side := side ;
90271: LD_ADDR_OWVAR 20
90275: PUSH
90276: LD_VAR 0 1
90280: ST_TO_ADDR
// uc_nation := 3 ;
90281: LD_ADDR_OWVAR 21
90285: PUSH
90286: LD_INT 3
90288: ST_TO_ADDR
// vc_chassis := 25 ;
90289: LD_ADDR_OWVAR 37
90293: PUSH
90294: LD_INT 25
90296: ST_TO_ADDR
// vc_engine := engine_siberite ;
90297: LD_ADDR_OWVAR 39
90301: PUSH
90302: LD_INT 3
90304: ST_TO_ADDR
// vc_control := control_computer ;
90305: LD_ADDR_OWVAR 38
90309: PUSH
90310: LD_INT 3
90312: ST_TO_ADDR
// vc_weapon := 59 ;
90313: LD_ADDR_OWVAR 40
90317: PUSH
90318: LD_INT 59
90320: ST_TO_ADDR
// result := CreateVehicle ;
90321: LD_ADDR_VAR 0 5
90325: PUSH
90326: CALL_OW 45
90330: ST_TO_ADDR
// SetDir ( result , d ) ;
90331: LD_VAR 0 5
90335: PPUSH
90336: LD_VAR 0 4
90340: PPUSH
90341: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
90345: LD_VAR 0 5
90349: PPUSH
90350: LD_VAR 0 2
90354: PPUSH
90355: LD_VAR 0 3
90359: PPUSH
90360: LD_INT 0
90362: PPUSH
90363: CALL_OW 48
// end ;
90367: LD_VAR 0 5
90371: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
90372: LD_INT 0
90374: PPUSH
90375: PPUSH
90376: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
90377: LD_ADDR_VAR 0 2
90381: PUSH
90382: LD_INT 0
90384: PUSH
90385: LD_INT 0
90387: PUSH
90388: LD_INT 0
90390: PUSH
90391: LD_INT 0
90393: PUSH
90394: EMPTY
90395: LIST
90396: LIST
90397: LIST
90398: LIST
90399: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
90400: LD_VAR 0 1
90404: NOT
90405: PUSH
90406: LD_VAR 0 1
90410: PPUSH
90411: CALL_OW 264
90415: PUSH
90416: LD_INT 12
90418: PUSH
90419: LD_INT 51
90421: PUSH
90422: LD_INT 32
90424: PUSH
90425: LD_INT 89
90427: PUSH
90428: EMPTY
90429: LIST
90430: LIST
90431: LIST
90432: LIST
90433: IN
90434: NOT
90435: OR
90436: IFFALSE 90440
// exit ;
90438: GO 90538
// for i := 1 to 3 do
90440: LD_ADDR_VAR 0 3
90444: PUSH
90445: DOUBLE
90446: LD_INT 1
90448: DEC
90449: ST_TO_ADDR
90450: LD_INT 3
90452: PUSH
90453: FOR_TO
90454: IFFALSE 90536
// begin tmp := GetCargo ( cargo , i ) ;
90456: LD_ADDR_VAR 0 4
90460: PUSH
90461: LD_VAR 0 1
90465: PPUSH
90466: LD_VAR 0 3
90470: PPUSH
90471: CALL_OW 289
90475: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
90476: LD_ADDR_VAR 0 2
90480: PUSH
90481: LD_VAR 0 2
90485: PPUSH
90486: LD_VAR 0 3
90490: PPUSH
90491: LD_VAR 0 4
90495: PPUSH
90496: CALL_OW 1
90500: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
90501: LD_ADDR_VAR 0 2
90505: PUSH
90506: LD_VAR 0 2
90510: PPUSH
90511: LD_INT 4
90513: PPUSH
90514: LD_VAR 0 2
90518: PUSH
90519: LD_INT 4
90521: ARRAY
90522: PUSH
90523: LD_VAR 0 4
90527: PLUS
90528: PPUSH
90529: CALL_OW 1
90533: ST_TO_ADDR
// end ;
90534: GO 90453
90536: POP
90537: POP
// end ;
90538: LD_VAR 0 2
90542: RET
// export function Length ( array ) ; begin
90543: LD_INT 0
90545: PPUSH
// result := array + 0 ;
90546: LD_ADDR_VAR 0 2
90550: PUSH
90551: LD_VAR 0 1
90555: PUSH
90556: LD_INT 0
90558: PLUS
90559: ST_TO_ADDR
// end ;
90560: LD_VAR 0 2
90564: RET
// export function PrepareArray ( array ) ; begin
90565: LD_INT 0
90567: PPUSH
// result := array diff 0 ;
90568: LD_ADDR_VAR 0 2
90572: PUSH
90573: LD_VAR 0 1
90577: PUSH
90578: LD_INT 0
90580: DIFF
90581: ST_TO_ADDR
// if not result [ 1 ] then
90582: LD_VAR 0 2
90586: PUSH
90587: LD_INT 1
90589: ARRAY
90590: NOT
90591: IFFALSE 90611
// result := Delete ( result , 1 ) ;
90593: LD_ADDR_VAR 0 2
90597: PUSH
90598: LD_VAR 0 2
90602: PPUSH
90603: LD_INT 1
90605: PPUSH
90606: CALL_OW 3
90610: ST_TO_ADDR
// end ;
90611: LD_VAR 0 2
90615: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
90616: LD_INT 0
90618: PPUSH
90619: PPUSH
90620: PPUSH
90621: PPUSH
// sibRocketRange := 25 ;
90622: LD_ADDR_VAR 0 6
90626: PUSH
90627: LD_INT 25
90629: ST_TO_ADDR
// result := false ;
90630: LD_ADDR_VAR 0 4
90634: PUSH
90635: LD_INT 0
90637: ST_TO_ADDR
// for i := 0 to 5 do
90638: LD_ADDR_VAR 0 5
90642: PUSH
90643: DOUBLE
90644: LD_INT 0
90646: DEC
90647: ST_TO_ADDR
90648: LD_INT 5
90650: PUSH
90651: FOR_TO
90652: IFFALSE 90719
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
90654: LD_VAR 0 1
90658: PPUSH
90659: LD_VAR 0 5
90663: PPUSH
90664: LD_VAR 0 6
90668: PPUSH
90669: CALL_OW 272
90673: PPUSH
90674: LD_VAR 0 2
90678: PPUSH
90679: LD_VAR 0 5
90683: PPUSH
90684: LD_VAR 0 6
90688: PPUSH
90689: CALL_OW 273
90693: PPUSH
90694: LD_VAR 0 3
90698: PPUSH
90699: CALL_OW 309
90703: IFFALSE 90717
// begin result := true ;
90705: LD_ADDR_VAR 0 4
90709: PUSH
90710: LD_INT 1
90712: ST_TO_ADDR
// exit ;
90713: POP
90714: POP
90715: GO 90721
// end ;
90717: GO 90651
90719: POP
90720: POP
// end ;
90721: LD_VAR 0 4
90725: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
90726: LD_INT 0
90728: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
90729: LD_VAR 0 1
90733: PPUSH
90734: LD_VAR 0 2
90738: PPUSH
90739: LD_INT 0
90741: PPUSH
90742: LD_INT 0
90744: PPUSH
90745: LD_INT 1
90747: PPUSH
90748: LD_INT 0
90750: PPUSH
90751: CALL_OW 587
// end ;
90755: LD_VAR 0 3
90759: RET
// export function CenterOnNow ( unit ) ; begin
90760: LD_INT 0
90762: PPUSH
// result := IsInUnit ( unit ) ;
90763: LD_ADDR_VAR 0 2
90767: PUSH
90768: LD_VAR 0 1
90772: PPUSH
90773: CALL_OW 310
90777: ST_TO_ADDR
// if not result then
90778: LD_VAR 0 2
90782: NOT
90783: IFFALSE 90795
// result := unit ;
90785: LD_ADDR_VAR 0 2
90789: PUSH
90790: LD_VAR 0 1
90794: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
90795: LD_VAR 0 1
90799: PPUSH
90800: CALL_OW 87
// end ;
90804: LD_VAR 0 2
90808: RET
// export function ComMoveHex ( unit , hex ) ; begin
90809: LD_INT 0
90811: PPUSH
// if not hex then
90812: LD_VAR 0 2
90816: NOT
90817: IFFALSE 90821
// exit ;
90819: GO 90874
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
90821: LD_VAR 0 2
90825: PUSH
90826: LD_INT 1
90828: ARRAY
90829: PPUSH
90830: LD_VAR 0 2
90834: PUSH
90835: LD_INT 2
90837: ARRAY
90838: PPUSH
90839: CALL_OW 428
90843: IFFALSE 90847
// exit ;
90845: GO 90874
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
90847: LD_VAR 0 1
90851: PPUSH
90852: LD_VAR 0 2
90856: PUSH
90857: LD_INT 1
90859: ARRAY
90860: PPUSH
90861: LD_VAR 0 2
90865: PUSH
90866: LD_INT 2
90868: ARRAY
90869: PPUSH
90870: CALL_OW 111
// end ;
90874: LD_VAR 0 3
90878: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
90879: LD_INT 0
90881: PPUSH
90882: PPUSH
90883: PPUSH
// if not unit or not enemy then
90884: LD_VAR 0 1
90888: NOT
90889: PUSH
90890: LD_VAR 0 2
90894: NOT
90895: OR
90896: IFFALSE 90900
// exit ;
90898: GO 91024
// x := GetX ( enemy ) ;
90900: LD_ADDR_VAR 0 4
90904: PUSH
90905: LD_VAR 0 2
90909: PPUSH
90910: CALL_OW 250
90914: ST_TO_ADDR
// y := GetY ( enemy ) ;
90915: LD_ADDR_VAR 0 5
90919: PUSH
90920: LD_VAR 0 2
90924: PPUSH
90925: CALL_OW 251
90929: ST_TO_ADDR
// if ValidHex ( x , y ) then
90930: LD_VAR 0 4
90934: PPUSH
90935: LD_VAR 0 5
90939: PPUSH
90940: CALL_OW 488
90944: IFFALSE 91024
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] and See ( GetSide ( unit ) , enemy ) then
90946: LD_VAR 0 2
90950: PPUSH
90951: CALL_OW 247
90955: PUSH
90956: LD_INT 3
90958: PUSH
90959: LD_INT 2
90961: PUSH
90962: EMPTY
90963: LIST
90964: LIST
90965: IN
90966: PUSH
90967: LD_VAR 0 1
90971: PPUSH
90972: CALL_OW 255
90976: PPUSH
90977: LD_VAR 0 2
90981: PPUSH
90982: CALL_OW 292
90986: AND
90987: IFFALSE 91005
// ComAttackUnit ( unit , enemy ) else
90989: LD_VAR 0 1
90993: PPUSH
90994: LD_VAR 0 2
90998: PPUSH
90999: CALL_OW 115
91003: GO 91024
// ComAgressiveMove ( unit , x , y ) ;
91005: LD_VAR 0 1
91009: PPUSH
91010: LD_VAR 0 4
91014: PPUSH
91015: LD_VAR 0 5
91019: PPUSH
91020: CALL_OW 114
// end ; end_of_file end_of_file
91024: LD_VAR 0 3
91028: RET
// export globalGameSaveCounter ; every 0 0$1 do
91029: GO 91031
91031: DISABLE
// begin enable ;
91032: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
91033: LD_STRING updateTimer(
91035: PUSH
91036: LD_OWVAR 1
91040: STR
91041: PUSH
91042: LD_STRING );
91044: STR
91045: PPUSH
91046: CALL_OW 559
// end ;
91050: END
// every 0 0$1 do
91051: GO 91053
91053: DISABLE
// begin globalGameSaveCounter := 0 ;
91054: LD_ADDR_EXP 95
91058: PUSH
91059: LD_INT 0
91061: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
91062: LD_STRING setGameSaveCounter(0)
91064: PPUSH
91065: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
91069: LD_STRING initStreamRollete();
91071: PPUSH
91072: CALL_OW 559
// InitStreamMode ;
91076: CALL 92402 0 0
// DefineStreamItems ( false ) ;
91080: LD_INT 0
91082: PPUSH
91083: CALL 92866 0 1
// end ;
91087: END
// export function SOS_MapStart ( ) ; begin
91088: LD_INT 0
91090: PPUSH
// if streamModeActive then
91091: LD_EXP 96
91095: IFFALSE 91104
// DefineStreamItems ( true ) ;
91097: LD_INT 1
91099: PPUSH
91100: CALL 92866 0 1
// UpdateLuaVariables ( ) ;
91104: CALL 91121 0 0
// UpdateFactoryWaypoints ( ) ;
91108: CALL 105735 0 0
// UpdateWarehouseGatheringPoints ( ) ;
91112: CALL 105992 0 0
// end ;
91116: LD_VAR 0 1
91120: RET
// function UpdateLuaVariables ( ) ; begin
91121: LD_INT 0
91123: PPUSH
// if globalGameSaveCounter then
91124: LD_EXP 95
91128: IFFALSE 91162
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
91130: LD_ADDR_EXP 95
91134: PUSH
91135: LD_EXP 95
91139: PPUSH
91140: CALL 88168 0 1
91144: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
91145: LD_STRING setGameSaveCounter(
91147: PUSH
91148: LD_EXP 95
91152: STR
91153: PUSH
91154: LD_STRING )
91156: STR
91157: PPUSH
91158: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
91162: LD_STRING setGameDifficulty(
91164: PUSH
91165: LD_OWVAR 67
91169: STR
91170: PUSH
91171: LD_STRING )
91173: STR
91174: PPUSH
91175: CALL_OW 559
// end ;
91179: LD_VAR 0 1
91183: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
91184: LD_INT 0
91186: PPUSH
// if p2 = stream_mode then
91187: LD_VAR 0 2
91191: PUSH
91192: LD_INT 100
91194: EQUAL
91195: IFFALSE 92198
// begin if not StreamModeActive then
91197: LD_EXP 96
91201: NOT
91202: IFFALSE 91212
// StreamModeActive := true ;
91204: LD_ADDR_EXP 96
91208: PUSH
91209: LD_INT 1
91211: ST_TO_ADDR
// if p3 = 0 then
91212: LD_VAR 0 3
91216: PUSH
91217: LD_INT 0
91219: EQUAL
91220: IFFALSE 91226
// InitStreamMode ;
91222: CALL 92402 0 0
// if p3 = 1 then
91226: LD_VAR 0 3
91230: PUSH
91231: LD_INT 1
91233: EQUAL
91234: IFFALSE 91244
// sRocket := true ;
91236: LD_ADDR_EXP 101
91240: PUSH
91241: LD_INT 1
91243: ST_TO_ADDR
// if p3 = 2 then
91244: LD_VAR 0 3
91248: PUSH
91249: LD_INT 2
91251: EQUAL
91252: IFFALSE 91262
// sSpeed := true ;
91254: LD_ADDR_EXP 100
91258: PUSH
91259: LD_INT 1
91261: ST_TO_ADDR
// if p3 = 3 then
91262: LD_VAR 0 3
91266: PUSH
91267: LD_INT 3
91269: EQUAL
91270: IFFALSE 91280
// sEngine := true ;
91272: LD_ADDR_EXP 102
91276: PUSH
91277: LD_INT 1
91279: ST_TO_ADDR
// if p3 = 4 then
91280: LD_VAR 0 3
91284: PUSH
91285: LD_INT 4
91287: EQUAL
91288: IFFALSE 91298
// sSpec := true ;
91290: LD_ADDR_EXP 99
91294: PUSH
91295: LD_INT 1
91297: ST_TO_ADDR
// if p3 = 5 then
91298: LD_VAR 0 3
91302: PUSH
91303: LD_INT 5
91305: EQUAL
91306: IFFALSE 91316
// sLevel := true ;
91308: LD_ADDR_EXP 103
91312: PUSH
91313: LD_INT 1
91315: ST_TO_ADDR
// if p3 = 6 then
91316: LD_VAR 0 3
91320: PUSH
91321: LD_INT 6
91323: EQUAL
91324: IFFALSE 91334
// sArmoury := true ;
91326: LD_ADDR_EXP 104
91330: PUSH
91331: LD_INT 1
91333: ST_TO_ADDR
// if p3 = 7 then
91334: LD_VAR 0 3
91338: PUSH
91339: LD_INT 7
91341: EQUAL
91342: IFFALSE 91352
// sRadar := true ;
91344: LD_ADDR_EXP 105
91348: PUSH
91349: LD_INT 1
91351: ST_TO_ADDR
// if p3 = 8 then
91352: LD_VAR 0 3
91356: PUSH
91357: LD_INT 8
91359: EQUAL
91360: IFFALSE 91370
// sBunker := true ;
91362: LD_ADDR_EXP 106
91366: PUSH
91367: LD_INT 1
91369: ST_TO_ADDR
// if p3 = 9 then
91370: LD_VAR 0 3
91374: PUSH
91375: LD_INT 9
91377: EQUAL
91378: IFFALSE 91388
// sHack := true ;
91380: LD_ADDR_EXP 107
91384: PUSH
91385: LD_INT 1
91387: ST_TO_ADDR
// if p3 = 10 then
91388: LD_VAR 0 3
91392: PUSH
91393: LD_INT 10
91395: EQUAL
91396: IFFALSE 91406
// sFire := true ;
91398: LD_ADDR_EXP 108
91402: PUSH
91403: LD_INT 1
91405: ST_TO_ADDR
// if p3 = 11 then
91406: LD_VAR 0 3
91410: PUSH
91411: LD_INT 11
91413: EQUAL
91414: IFFALSE 91424
// sRefresh := true ;
91416: LD_ADDR_EXP 109
91420: PUSH
91421: LD_INT 1
91423: ST_TO_ADDR
// if p3 = 12 then
91424: LD_VAR 0 3
91428: PUSH
91429: LD_INT 12
91431: EQUAL
91432: IFFALSE 91442
// sExp := true ;
91434: LD_ADDR_EXP 110
91438: PUSH
91439: LD_INT 1
91441: ST_TO_ADDR
// if p3 = 13 then
91442: LD_VAR 0 3
91446: PUSH
91447: LD_INT 13
91449: EQUAL
91450: IFFALSE 91460
// sDepot := true ;
91452: LD_ADDR_EXP 111
91456: PUSH
91457: LD_INT 1
91459: ST_TO_ADDR
// if p3 = 14 then
91460: LD_VAR 0 3
91464: PUSH
91465: LD_INT 14
91467: EQUAL
91468: IFFALSE 91478
// sFlag := true ;
91470: LD_ADDR_EXP 112
91474: PUSH
91475: LD_INT 1
91477: ST_TO_ADDR
// if p3 = 15 then
91478: LD_VAR 0 3
91482: PUSH
91483: LD_INT 15
91485: EQUAL
91486: IFFALSE 91496
// sKamikadze := true ;
91488: LD_ADDR_EXP 120
91492: PUSH
91493: LD_INT 1
91495: ST_TO_ADDR
// if p3 = 16 then
91496: LD_VAR 0 3
91500: PUSH
91501: LD_INT 16
91503: EQUAL
91504: IFFALSE 91514
// sTroll := true ;
91506: LD_ADDR_EXP 121
91510: PUSH
91511: LD_INT 1
91513: ST_TO_ADDR
// if p3 = 17 then
91514: LD_VAR 0 3
91518: PUSH
91519: LD_INT 17
91521: EQUAL
91522: IFFALSE 91532
// sSlow := true ;
91524: LD_ADDR_EXP 122
91528: PUSH
91529: LD_INT 1
91531: ST_TO_ADDR
// if p3 = 18 then
91532: LD_VAR 0 3
91536: PUSH
91537: LD_INT 18
91539: EQUAL
91540: IFFALSE 91550
// sLack := true ;
91542: LD_ADDR_EXP 123
91546: PUSH
91547: LD_INT 1
91549: ST_TO_ADDR
// if p3 = 19 then
91550: LD_VAR 0 3
91554: PUSH
91555: LD_INT 19
91557: EQUAL
91558: IFFALSE 91568
// sTank := true ;
91560: LD_ADDR_EXP 125
91564: PUSH
91565: LD_INT 1
91567: ST_TO_ADDR
// if p3 = 20 then
91568: LD_VAR 0 3
91572: PUSH
91573: LD_INT 20
91575: EQUAL
91576: IFFALSE 91586
// sRemote := true ;
91578: LD_ADDR_EXP 126
91582: PUSH
91583: LD_INT 1
91585: ST_TO_ADDR
// if p3 = 21 then
91586: LD_VAR 0 3
91590: PUSH
91591: LD_INT 21
91593: EQUAL
91594: IFFALSE 91604
// sPowell := true ;
91596: LD_ADDR_EXP 127
91600: PUSH
91601: LD_INT 1
91603: ST_TO_ADDR
// if p3 = 22 then
91604: LD_VAR 0 3
91608: PUSH
91609: LD_INT 22
91611: EQUAL
91612: IFFALSE 91622
// sTeleport := true ;
91614: LD_ADDR_EXP 130
91618: PUSH
91619: LD_INT 1
91621: ST_TO_ADDR
// if p3 = 23 then
91622: LD_VAR 0 3
91626: PUSH
91627: LD_INT 23
91629: EQUAL
91630: IFFALSE 91640
// sOilTower := true ;
91632: LD_ADDR_EXP 132
91636: PUSH
91637: LD_INT 1
91639: ST_TO_ADDR
// if p3 = 24 then
91640: LD_VAR 0 3
91644: PUSH
91645: LD_INT 24
91647: EQUAL
91648: IFFALSE 91658
// sShovel := true ;
91650: LD_ADDR_EXP 133
91654: PUSH
91655: LD_INT 1
91657: ST_TO_ADDR
// if p3 = 25 then
91658: LD_VAR 0 3
91662: PUSH
91663: LD_INT 25
91665: EQUAL
91666: IFFALSE 91676
// sSheik := true ;
91668: LD_ADDR_EXP 134
91672: PUSH
91673: LD_INT 1
91675: ST_TO_ADDR
// if p3 = 26 then
91676: LD_VAR 0 3
91680: PUSH
91681: LD_INT 26
91683: EQUAL
91684: IFFALSE 91694
// sEarthquake := true ;
91686: LD_ADDR_EXP 136
91690: PUSH
91691: LD_INT 1
91693: ST_TO_ADDR
// if p3 = 27 then
91694: LD_VAR 0 3
91698: PUSH
91699: LD_INT 27
91701: EQUAL
91702: IFFALSE 91712
// sAI := true ;
91704: LD_ADDR_EXP 137
91708: PUSH
91709: LD_INT 1
91711: ST_TO_ADDR
// if p3 = 28 then
91712: LD_VAR 0 3
91716: PUSH
91717: LD_INT 28
91719: EQUAL
91720: IFFALSE 91730
// sCargo := true ;
91722: LD_ADDR_EXP 140
91726: PUSH
91727: LD_INT 1
91729: ST_TO_ADDR
// if p3 = 29 then
91730: LD_VAR 0 3
91734: PUSH
91735: LD_INT 29
91737: EQUAL
91738: IFFALSE 91748
// sDLaser := true ;
91740: LD_ADDR_EXP 141
91744: PUSH
91745: LD_INT 1
91747: ST_TO_ADDR
// if p3 = 30 then
91748: LD_VAR 0 3
91752: PUSH
91753: LD_INT 30
91755: EQUAL
91756: IFFALSE 91766
// sExchange := true ;
91758: LD_ADDR_EXP 142
91762: PUSH
91763: LD_INT 1
91765: ST_TO_ADDR
// if p3 = 31 then
91766: LD_VAR 0 3
91770: PUSH
91771: LD_INT 31
91773: EQUAL
91774: IFFALSE 91784
// sFac := true ;
91776: LD_ADDR_EXP 143
91780: PUSH
91781: LD_INT 1
91783: ST_TO_ADDR
// if p3 = 32 then
91784: LD_VAR 0 3
91788: PUSH
91789: LD_INT 32
91791: EQUAL
91792: IFFALSE 91802
// sPower := true ;
91794: LD_ADDR_EXP 144
91798: PUSH
91799: LD_INT 1
91801: ST_TO_ADDR
// if p3 = 33 then
91802: LD_VAR 0 3
91806: PUSH
91807: LD_INT 33
91809: EQUAL
91810: IFFALSE 91820
// sRandom := true ;
91812: LD_ADDR_EXP 145
91816: PUSH
91817: LD_INT 1
91819: ST_TO_ADDR
// if p3 = 34 then
91820: LD_VAR 0 3
91824: PUSH
91825: LD_INT 34
91827: EQUAL
91828: IFFALSE 91838
// sShield := true ;
91830: LD_ADDR_EXP 146
91834: PUSH
91835: LD_INT 1
91837: ST_TO_ADDR
// if p3 = 35 then
91838: LD_VAR 0 3
91842: PUSH
91843: LD_INT 35
91845: EQUAL
91846: IFFALSE 91856
// sTime := true ;
91848: LD_ADDR_EXP 147
91852: PUSH
91853: LD_INT 1
91855: ST_TO_ADDR
// if p3 = 36 then
91856: LD_VAR 0 3
91860: PUSH
91861: LD_INT 36
91863: EQUAL
91864: IFFALSE 91874
// sTools := true ;
91866: LD_ADDR_EXP 148
91870: PUSH
91871: LD_INT 1
91873: ST_TO_ADDR
// if p3 = 101 then
91874: LD_VAR 0 3
91878: PUSH
91879: LD_INT 101
91881: EQUAL
91882: IFFALSE 91892
// sSold := true ;
91884: LD_ADDR_EXP 113
91888: PUSH
91889: LD_INT 1
91891: ST_TO_ADDR
// if p3 = 102 then
91892: LD_VAR 0 3
91896: PUSH
91897: LD_INT 102
91899: EQUAL
91900: IFFALSE 91910
// sDiff := true ;
91902: LD_ADDR_EXP 114
91906: PUSH
91907: LD_INT 1
91909: ST_TO_ADDR
// if p3 = 103 then
91910: LD_VAR 0 3
91914: PUSH
91915: LD_INT 103
91917: EQUAL
91918: IFFALSE 91928
// sFog := true ;
91920: LD_ADDR_EXP 117
91924: PUSH
91925: LD_INT 1
91927: ST_TO_ADDR
// if p3 = 104 then
91928: LD_VAR 0 3
91932: PUSH
91933: LD_INT 104
91935: EQUAL
91936: IFFALSE 91946
// sReset := true ;
91938: LD_ADDR_EXP 118
91942: PUSH
91943: LD_INT 1
91945: ST_TO_ADDR
// if p3 = 105 then
91946: LD_VAR 0 3
91950: PUSH
91951: LD_INT 105
91953: EQUAL
91954: IFFALSE 91964
// sSun := true ;
91956: LD_ADDR_EXP 119
91960: PUSH
91961: LD_INT 1
91963: ST_TO_ADDR
// if p3 = 106 then
91964: LD_VAR 0 3
91968: PUSH
91969: LD_INT 106
91971: EQUAL
91972: IFFALSE 91982
// sTiger := true ;
91974: LD_ADDR_EXP 115
91978: PUSH
91979: LD_INT 1
91981: ST_TO_ADDR
// if p3 = 107 then
91982: LD_VAR 0 3
91986: PUSH
91987: LD_INT 107
91989: EQUAL
91990: IFFALSE 92000
// sBomb := true ;
91992: LD_ADDR_EXP 116
91996: PUSH
91997: LD_INT 1
91999: ST_TO_ADDR
// if p3 = 108 then
92000: LD_VAR 0 3
92004: PUSH
92005: LD_INT 108
92007: EQUAL
92008: IFFALSE 92018
// sWound := true ;
92010: LD_ADDR_EXP 124
92014: PUSH
92015: LD_INT 1
92017: ST_TO_ADDR
// if p3 = 109 then
92018: LD_VAR 0 3
92022: PUSH
92023: LD_INT 109
92025: EQUAL
92026: IFFALSE 92036
// sBetray := true ;
92028: LD_ADDR_EXP 128
92032: PUSH
92033: LD_INT 1
92035: ST_TO_ADDR
// if p3 = 110 then
92036: LD_VAR 0 3
92040: PUSH
92041: LD_INT 110
92043: EQUAL
92044: IFFALSE 92054
// sContamin := true ;
92046: LD_ADDR_EXP 129
92050: PUSH
92051: LD_INT 1
92053: ST_TO_ADDR
// if p3 = 111 then
92054: LD_VAR 0 3
92058: PUSH
92059: LD_INT 111
92061: EQUAL
92062: IFFALSE 92072
// sOil := true ;
92064: LD_ADDR_EXP 131
92068: PUSH
92069: LD_INT 1
92071: ST_TO_ADDR
// if p3 = 112 then
92072: LD_VAR 0 3
92076: PUSH
92077: LD_INT 112
92079: EQUAL
92080: IFFALSE 92090
// sStu := true ;
92082: LD_ADDR_EXP 135
92086: PUSH
92087: LD_INT 1
92089: ST_TO_ADDR
// if p3 = 113 then
92090: LD_VAR 0 3
92094: PUSH
92095: LD_INT 113
92097: EQUAL
92098: IFFALSE 92108
// sBazooka := true ;
92100: LD_ADDR_EXP 138
92104: PUSH
92105: LD_INT 1
92107: ST_TO_ADDR
// if p3 = 114 then
92108: LD_VAR 0 3
92112: PUSH
92113: LD_INT 114
92115: EQUAL
92116: IFFALSE 92126
// sMortar := true ;
92118: LD_ADDR_EXP 139
92122: PUSH
92123: LD_INT 1
92125: ST_TO_ADDR
// if p3 = 115 then
92126: LD_VAR 0 3
92130: PUSH
92131: LD_INT 115
92133: EQUAL
92134: IFFALSE 92144
// sRanger := true ;
92136: LD_ADDR_EXP 149
92140: PUSH
92141: LD_INT 1
92143: ST_TO_ADDR
// if p3 = 116 then
92144: LD_VAR 0 3
92148: PUSH
92149: LD_INT 116
92151: EQUAL
92152: IFFALSE 92162
// sComputer := true ;
92154: LD_ADDR_EXP 150
92158: PUSH
92159: LD_INT 1
92161: ST_TO_ADDR
// if p3 = 117 then
92162: LD_VAR 0 3
92166: PUSH
92167: LD_INT 117
92169: EQUAL
92170: IFFALSE 92180
// s30 := true ;
92172: LD_ADDR_EXP 151
92176: PUSH
92177: LD_INT 1
92179: ST_TO_ADDR
// if p3 = 118 then
92180: LD_VAR 0 3
92184: PUSH
92185: LD_INT 118
92187: EQUAL
92188: IFFALSE 92198
// s60 := true ;
92190: LD_ADDR_EXP 152
92194: PUSH
92195: LD_INT 1
92197: ST_TO_ADDR
// end ; if p2 = hack_mode then
92198: LD_VAR 0 2
92202: PUSH
92203: LD_INT 101
92205: EQUAL
92206: IFFALSE 92334
// begin case p3 of 1 :
92208: LD_VAR 0 3
92212: PUSH
92213: LD_INT 1
92215: DOUBLE
92216: EQUAL
92217: IFTRUE 92221
92219: GO 92228
92221: POP
// hHackUnlimitedResources ; 2 :
92222: CALL 104481 0 0
92226: GO 92334
92228: LD_INT 2
92230: DOUBLE
92231: EQUAL
92232: IFTRUE 92236
92234: GO 92243
92236: POP
// hHackSetLevel10 ; 3 :
92237: CALL 104614 0 0
92241: GO 92334
92243: LD_INT 3
92245: DOUBLE
92246: EQUAL
92247: IFTRUE 92251
92249: GO 92258
92251: POP
// hHackSetLevel10YourUnits ; 4 :
92252: CALL 104699 0 0
92256: GO 92334
92258: LD_INT 4
92260: DOUBLE
92261: EQUAL
92262: IFTRUE 92266
92264: GO 92273
92266: POP
// hHackInvincible ; 5 :
92267: CALL 105147 0 0
92271: GO 92334
92273: LD_INT 5
92275: DOUBLE
92276: EQUAL
92277: IFTRUE 92281
92279: GO 92288
92281: POP
// hHackInvisible ; 6 :
92282: CALL 105258 0 0
92286: GO 92334
92288: LD_INT 6
92290: DOUBLE
92291: EQUAL
92292: IFTRUE 92296
92294: GO 92303
92296: POP
// hHackChangeYourSide ; 7 :
92297: CALL 105315 0 0
92301: GO 92334
92303: LD_INT 7
92305: DOUBLE
92306: EQUAL
92307: IFTRUE 92311
92309: GO 92318
92311: POP
// hHackChangeUnitSide ; 8 :
92312: CALL 105357 0 0
92316: GO 92334
92318: LD_INT 8
92320: DOUBLE
92321: EQUAL
92322: IFTRUE 92326
92324: GO 92333
92326: POP
// hHackFog ; end ;
92327: CALL 105458 0 0
92331: GO 92334
92333: POP
// end ; if p2 = game_save_mode then
92334: LD_VAR 0 2
92338: PUSH
92339: LD_INT 102
92341: EQUAL
92342: IFFALSE 92397
// begin if p3 = 1 then
92344: LD_VAR 0 3
92348: PUSH
92349: LD_INT 1
92351: EQUAL
92352: IFFALSE 92364
// globalGameSaveCounter := p4 ;
92354: LD_ADDR_EXP 95
92358: PUSH
92359: LD_VAR 0 4
92363: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
92364: LD_VAR 0 3
92368: PUSH
92369: LD_INT 2
92371: EQUAL
92372: PUSH
92373: LD_EXP 95
92377: AND
92378: IFFALSE 92397
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
92380: LD_STRING setGameSaveCounter(
92382: PUSH
92383: LD_EXP 95
92387: STR
92388: PUSH
92389: LD_STRING )
92391: STR
92392: PPUSH
92393: CALL_OW 559
// end ; end ;
92397: LD_VAR 0 7
92401: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
92402: LD_INT 0
92404: PPUSH
// streamModeActive := false ;
92405: LD_ADDR_EXP 96
92409: PUSH
92410: LD_INT 0
92412: ST_TO_ADDR
// normalCounter := 36 ;
92413: LD_ADDR_EXP 97
92417: PUSH
92418: LD_INT 36
92420: ST_TO_ADDR
// hardcoreCounter := 18 ;
92421: LD_ADDR_EXP 98
92425: PUSH
92426: LD_INT 18
92428: ST_TO_ADDR
// sRocket := false ;
92429: LD_ADDR_EXP 101
92433: PUSH
92434: LD_INT 0
92436: ST_TO_ADDR
// sSpeed := false ;
92437: LD_ADDR_EXP 100
92441: PUSH
92442: LD_INT 0
92444: ST_TO_ADDR
// sEngine := false ;
92445: LD_ADDR_EXP 102
92449: PUSH
92450: LD_INT 0
92452: ST_TO_ADDR
// sSpec := false ;
92453: LD_ADDR_EXP 99
92457: PUSH
92458: LD_INT 0
92460: ST_TO_ADDR
// sLevel := false ;
92461: LD_ADDR_EXP 103
92465: PUSH
92466: LD_INT 0
92468: ST_TO_ADDR
// sArmoury := false ;
92469: LD_ADDR_EXP 104
92473: PUSH
92474: LD_INT 0
92476: ST_TO_ADDR
// sRadar := false ;
92477: LD_ADDR_EXP 105
92481: PUSH
92482: LD_INT 0
92484: ST_TO_ADDR
// sBunker := false ;
92485: LD_ADDR_EXP 106
92489: PUSH
92490: LD_INT 0
92492: ST_TO_ADDR
// sHack := false ;
92493: LD_ADDR_EXP 107
92497: PUSH
92498: LD_INT 0
92500: ST_TO_ADDR
// sFire := false ;
92501: LD_ADDR_EXP 108
92505: PUSH
92506: LD_INT 0
92508: ST_TO_ADDR
// sRefresh := false ;
92509: LD_ADDR_EXP 109
92513: PUSH
92514: LD_INT 0
92516: ST_TO_ADDR
// sExp := false ;
92517: LD_ADDR_EXP 110
92521: PUSH
92522: LD_INT 0
92524: ST_TO_ADDR
// sDepot := false ;
92525: LD_ADDR_EXP 111
92529: PUSH
92530: LD_INT 0
92532: ST_TO_ADDR
// sFlag := false ;
92533: LD_ADDR_EXP 112
92537: PUSH
92538: LD_INT 0
92540: ST_TO_ADDR
// sKamikadze := false ;
92541: LD_ADDR_EXP 120
92545: PUSH
92546: LD_INT 0
92548: ST_TO_ADDR
// sTroll := false ;
92549: LD_ADDR_EXP 121
92553: PUSH
92554: LD_INT 0
92556: ST_TO_ADDR
// sSlow := false ;
92557: LD_ADDR_EXP 122
92561: PUSH
92562: LD_INT 0
92564: ST_TO_ADDR
// sLack := false ;
92565: LD_ADDR_EXP 123
92569: PUSH
92570: LD_INT 0
92572: ST_TO_ADDR
// sTank := false ;
92573: LD_ADDR_EXP 125
92577: PUSH
92578: LD_INT 0
92580: ST_TO_ADDR
// sRemote := false ;
92581: LD_ADDR_EXP 126
92585: PUSH
92586: LD_INT 0
92588: ST_TO_ADDR
// sPowell := false ;
92589: LD_ADDR_EXP 127
92593: PUSH
92594: LD_INT 0
92596: ST_TO_ADDR
// sTeleport := false ;
92597: LD_ADDR_EXP 130
92601: PUSH
92602: LD_INT 0
92604: ST_TO_ADDR
// sOilTower := false ;
92605: LD_ADDR_EXP 132
92609: PUSH
92610: LD_INT 0
92612: ST_TO_ADDR
// sShovel := false ;
92613: LD_ADDR_EXP 133
92617: PUSH
92618: LD_INT 0
92620: ST_TO_ADDR
// sSheik := false ;
92621: LD_ADDR_EXP 134
92625: PUSH
92626: LD_INT 0
92628: ST_TO_ADDR
// sEarthquake := false ;
92629: LD_ADDR_EXP 136
92633: PUSH
92634: LD_INT 0
92636: ST_TO_ADDR
// sAI := false ;
92637: LD_ADDR_EXP 137
92641: PUSH
92642: LD_INT 0
92644: ST_TO_ADDR
// sCargo := false ;
92645: LD_ADDR_EXP 140
92649: PUSH
92650: LD_INT 0
92652: ST_TO_ADDR
// sDLaser := false ;
92653: LD_ADDR_EXP 141
92657: PUSH
92658: LD_INT 0
92660: ST_TO_ADDR
// sExchange := false ;
92661: LD_ADDR_EXP 142
92665: PUSH
92666: LD_INT 0
92668: ST_TO_ADDR
// sFac := false ;
92669: LD_ADDR_EXP 143
92673: PUSH
92674: LD_INT 0
92676: ST_TO_ADDR
// sPower := false ;
92677: LD_ADDR_EXP 144
92681: PUSH
92682: LD_INT 0
92684: ST_TO_ADDR
// sRandom := false ;
92685: LD_ADDR_EXP 145
92689: PUSH
92690: LD_INT 0
92692: ST_TO_ADDR
// sShield := false ;
92693: LD_ADDR_EXP 146
92697: PUSH
92698: LD_INT 0
92700: ST_TO_ADDR
// sTime := false ;
92701: LD_ADDR_EXP 147
92705: PUSH
92706: LD_INT 0
92708: ST_TO_ADDR
// sTools := false ;
92709: LD_ADDR_EXP 148
92713: PUSH
92714: LD_INT 0
92716: ST_TO_ADDR
// sSold := false ;
92717: LD_ADDR_EXP 113
92721: PUSH
92722: LD_INT 0
92724: ST_TO_ADDR
// sDiff := false ;
92725: LD_ADDR_EXP 114
92729: PUSH
92730: LD_INT 0
92732: ST_TO_ADDR
// sFog := false ;
92733: LD_ADDR_EXP 117
92737: PUSH
92738: LD_INT 0
92740: ST_TO_ADDR
// sReset := false ;
92741: LD_ADDR_EXP 118
92745: PUSH
92746: LD_INT 0
92748: ST_TO_ADDR
// sSun := false ;
92749: LD_ADDR_EXP 119
92753: PUSH
92754: LD_INT 0
92756: ST_TO_ADDR
// sTiger := false ;
92757: LD_ADDR_EXP 115
92761: PUSH
92762: LD_INT 0
92764: ST_TO_ADDR
// sBomb := false ;
92765: LD_ADDR_EXP 116
92769: PUSH
92770: LD_INT 0
92772: ST_TO_ADDR
// sWound := false ;
92773: LD_ADDR_EXP 124
92777: PUSH
92778: LD_INT 0
92780: ST_TO_ADDR
// sBetray := false ;
92781: LD_ADDR_EXP 128
92785: PUSH
92786: LD_INT 0
92788: ST_TO_ADDR
// sContamin := false ;
92789: LD_ADDR_EXP 129
92793: PUSH
92794: LD_INT 0
92796: ST_TO_ADDR
// sOil := false ;
92797: LD_ADDR_EXP 131
92801: PUSH
92802: LD_INT 0
92804: ST_TO_ADDR
// sStu := false ;
92805: LD_ADDR_EXP 135
92809: PUSH
92810: LD_INT 0
92812: ST_TO_ADDR
// sBazooka := false ;
92813: LD_ADDR_EXP 138
92817: PUSH
92818: LD_INT 0
92820: ST_TO_ADDR
// sMortar := false ;
92821: LD_ADDR_EXP 139
92825: PUSH
92826: LD_INT 0
92828: ST_TO_ADDR
// sRanger := false ;
92829: LD_ADDR_EXP 149
92833: PUSH
92834: LD_INT 0
92836: ST_TO_ADDR
// sComputer := false ;
92837: LD_ADDR_EXP 150
92841: PUSH
92842: LD_INT 0
92844: ST_TO_ADDR
// s30 := false ;
92845: LD_ADDR_EXP 151
92849: PUSH
92850: LD_INT 0
92852: ST_TO_ADDR
// s60 := false ;
92853: LD_ADDR_EXP 152
92857: PUSH
92858: LD_INT 0
92860: ST_TO_ADDR
// end ;
92861: LD_VAR 0 1
92865: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
92866: LD_INT 0
92868: PPUSH
92869: PPUSH
92870: PPUSH
92871: PPUSH
92872: PPUSH
92873: PPUSH
92874: PPUSH
// result := [ ] ;
92875: LD_ADDR_VAR 0 2
92879: PUSH
92880: EMPTY
92881: ST_TO_ADDR
// if campaign_id = 1 then
92882: LD_OWVAR 69
92886: PUSH
92887: LD_INT 1
92889: EQUAL
92890: IFFALSE 96056
// begin case mission_number of 1 :
92892: LD_OWVAR 70
92896: PUSH
92897: LD_INT 1
92899: DOUBLE
92900: EQUAL
92901: IFTRUE 92905
92903: GO 92981
92905: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
92906: LD_ADDR_VAR 0 2
92910: PUSH
92911: LD_INT 2
92913: PUSH
92914: LD_INT 4
92916: PUSH
92917: LD_INT 11
92919: PUSH
92920: LD_INT 12
92922: PUSH
92923: LD_INT 15
92925: PUSH
92926: LD_INT 16
92928: PUSH
92929: LD_INT 22
92931: PUSH
92932: LD_INT 23
92934: PUSH
92935: LD_INT 26
92937: PUSH
92938: EMPTY
92939: LIST
92940: LIST
92941: LIST
92942: LIST
92943: LIST
92944: LIST
92945: LIST
92946: LIST
92947: LIST
92948: PUSH
92949: LD_INT 101
92951: PUSH
92952: LD_INT 102
92954: PUSH
92955: LD_INT 106
92957: PUSH
92958: LD_INT 116
92960: PUSH
92961: LD_INT 117
92963: PUSH
92964: LD_INT 118
92966: PUSH
92967: EMPTY
92968: LIST
92969: LIST
92970: LIST
92971: LIST
92972: LIST
92973: LIST
92974: PUSH
92975: EMPTY
92976: LIST
92977: LIST
92978: ST_TO_ADDR
92979: GO 96054
92981: LD_INT 2
92983: DOUBLE
92984: EQUAL
92985: IFTRUE 92989
92987: GO 93073
92989: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
92990: LD_ADDR_VAR 0 2
92994: PUSH
92995: LD_INT 2
92997: PUSH
92998: LD_INT 4
93000: PUSH
93001: LD_INT 11
93003: PUSH
93004: LD_INT 12
93006: PUSH
93007: LD_INT 15
93009: PUSH
93010: LD_INT 16
93012: PUSH
93013: LD_INT 22
93015: PUSH
93016: LD_INT 23
93018: PUSH
93019: LD_INT 26
93021: PUSH
93022: EMPTY
93023: LIST
93024: LIST
93025: LIST
93026: LIST
93027: LIST
93028: LIST
93029: LIST
93030: LIST
93031: LIST
93032: PUSH
93033: LD_INT 101
93035: PUSH
93036: LD_INT 102
93038: PUSH
93039: LD_INT 105
93041: PUSH
93042: LD_INT 106
93044: PUSH
93045: LD_INT 108
93047: PUSH
93048: LD_INT 116
93050: PUSH
93051: LD_INT 117
93053: PUSH
93054: LD_INT 118
93056: PUSH
93057: EMPTY
93058: LIST
93059: LIST
93060: LIST
93061: LIST
93062: LIST
93063: LIST
93064: LIST
93065: LIST
93066: PUSH
93067: EMPTY
93068: LIST
93069: LIST
93070: ST_TO_ADDR
93071: GO 96054
93073: LD_INT 3
93075: DOUBLE
93076: EQUAL
93077: IFTRUE 93081
93079: GO 93169
93081: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
93082: LD_ADDR_VAR 0 2
93086: PUSH
93087: LD_INT 2
93089: PUSH
93090: LD_INT 4
93092: PUSH
93093: LD_INT 5
93095: PUSH
93096: LD_INT 11
93098: PUSH
93099: LD_INT 12
93101: PUSH
93102: LD_INT 15
93104: PUSH
93105: LD_INT 16
93107: PUSH
93108: LD_INT 22
93110: PUSH
93111: LD_INT 26
93113: PUSH
93114: LD_INT 36
93116: PUSH
93117: EMPTY
93118: LIST
93119: LIST
93120: LIST
93121: LIST
93122: LIST
93123: LIST
93124: LIST
93125: LIST
93126: LIST
93127: LIST
93128: PUSH
93129: LD_INT 101
93131: PUSH
93132: LD_INT 102
93134: PUSH
93135: LD_INT 105
93137: PUSH
93138: LD_INT 106
93140: PUSH
93141: LD_INT 108
93143: PUSH
93144: LD_INT 116
93146: PUSH
93147: LD_INT 117
93149: PUSH
93150: LD_INT 118
93152: PUSH
93153: EMPTY
93154: LIST
93155: LIST
93156: LIST
93157: LIST
93158: LIST
93159: LIST
93160: LIST
93161: LIST
93162: PUSH
93163: EMPTY
93164: LIST
93165: LIST
93166: ST_TO_ADDR
93167: GO 96054
93169: LD_INT 4
93171: DOUBLE
93172: EQUAL
93173: IFTRUE 93177
93175: GO 93273
93177: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
93178: LD_ADDR_VAR 0 2
93182: PUSH
93183: LD_INT 2
93185: PUSH
93186: LD_INT 4
93188: PUSH
93189: LD_INT 5
93191: PUSH
93192: LD_INT 8
93194: PUSH
93195: LD_INT 11
93197: PUSH
93198: LD_INT 12
93200: PUSH
93201: LD_INT 15
93203: PUSH
93204: LD_INT 16
93206: PUSH
93207: LD_INT 22
93209: PUSH
93210: LD_INT 23
93212: PUSH
93213: LD_INT 26
93215: PUSH
93216: LD_INT 36
93218: PUSH
93219: EMPTY
93220: LIST
93221: LIST
93222: LIST
93223: LIST
93224: LIST
93225: LIST
93226: LIST
93227: LIST
93228: LIST
93229: LIST
93230: LIST
93231: LIST
93232: PUSH
93233: LD_INT 101
93235: PUSH
93236: LD_INT 102
93238: PUSH
93239: LD_INT 105
93241: PUSH
93242: LD_INT 106
93244: PUSH
93245: LD_INT 108
93247: PUSH
93248: LD_INT 116
93250: PUSH
93251: LD_INT 117
93253: PUSH
93254: LD_INT 118
93256: PUSH
93257: EMPTY
93258: LIST
93259: LIST
93260: LIST
93261: LIST
93262: LIST
93263: LIST
93264: LIST
93265: LIST
93266: PUSH
93267: EMPTY
93268: LIST
93269: LIST
93270: ST_TO_ADDR
93271: GO 96054
93273: LD_INT 5
93275: DOUBLE
93276: EQUAL
93277: IFTRUE 93281
93279: GO 93393
93281: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
93282: LD_ADDR_VAR 0 2
93286: PUSH
93287: LD_INT 2
93289: PUSH
93290: LD_INT 4
93292: PUSH
93293: LD_INT 5
93295: PUSH
93296: LD_INT 6
93298: PUSH
93299: LD_INT 8
93301: PUSH
93302: LD_INT 11
93304: PUSH
93305: LD_INT 12
93307: PUSH
93308: LD_INT 15
93310: PUSH
93311: LD_INT 16
93313: PUSH
93314: LD_INT 22
93316: PUSH
93317: LD_INT 23
93319: PUSH
93320: LD_INT 25
93322: PUSH
93323: LD_INT 26
93325: PUSH
93326: LD_INT 36
93328: PUSH
93329: EMPTY
93330: LIST
93331: LIST
93332: LIST
93333: LIST
93334: LIST
93335: LIST
93336: LIST
93337: LIST
93338: LIST
93339: LIST
93340: LIST
93341: LIST
93342: LIST
93343: LIST
93344: PUSH
93345: LD_INT 101
93347: PUSH
93348: LD_INT 102
93350: PUSH
93351: LD_INT 105
93353: PUSH
93354: LD_INT 106
93356: PUSH
93357: LD_INT 108
93359: PUSH
93360: LD_INT 109
93362: PUSH
93363: LD_INT 112
93365: PUSH
93366: LD_INT 116
93368: PUSH
93369: LD_INT 117
93371: PUSH
93372: LD_INT 118
93374: PUSH
93375: EMPTY
93376: LIST
93377: LIST
93378: LIST
93379: LIST
93380: LIST
93381: LIST
93382: LIST
93383: LIST
93384: LIST
93385: LIST
93386: PUSH
93387: EMPTY
93388: LIST
93389: LIST
93390: ST_TO_ADDR
93391: GO 96054
93393: LD_INT 6
93395: DOUBLE
93396: EQUAL
93397: IFTRUE 93401
93399: GO 93533
93401: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
93402: LD_ADDR_VAR 0 2
93406: PUSH
93407: LD_INT 2
93409: PUSH
93410: LD_INT 4
93412: PUSH
93413: LD_INT 5
93415: PUSH
93416: LD_INT 6
93418: PUSH
93419: LD_INT 8
93421: PUSH
93422: LD_INT 11
93424: PUSH
93425: LD_INT 12
93427: PUSH
93428: LD_INT 15
93430: PUSH
93431: LD_INT 16
93433: PUSH
93434: LD_INT 20
93436: PUSH
93437: LD_INT 21
93439: PUSH
93440: LD_INT 22
93442: PUSH
93443: LD_INT 23
93445: PUSH
93446: LD_INT 25
93448: PUSH
93449: LD_INT 26
93451: PUSH
93452: LD_INT 30
93454: PUSH
93455: LD_INT 31
93457: PUSH
93458: LD_INT 32
93460: PUSH
93461: LD_INT 36
93463: PUSH
93464: EMPTY
93465: LIST
93466: LIST
93467: LIST
93468: LIST
93469: LIST
93470: LIST
93471: LIST
93472: LIST
93473: LIST
93474: LIST
93475: LIST
93476: LIST
93477: LIST
93478: LIST
93479: LIST
93480: LIST
93481: LIST
93482: LIST
93483: LIST
93484: PUSH
93485: LD_INT 101
93487: PUSH
93488: LD_INT 102
93490: PUSH
93491: LD_INT 105
93493: PUSH
93494: LD_INT 106
93496: PUSH
93497: LD_INT 108
93499: PUSH
93500: LD_INT 109
93502: PUSH
93503: LD_INT 112
93505: PUSH
93506: LD_INT 116
93508: PUSH
93509: LD_INT 117
93511: PUSH
93512: LD_INT 118
93514: PUSH
93515: EMPTY
93516: LIST
93517: LIST
93518: LIST
93519: LIST
93520: LIST
93521: LIST
93522: LIST
93523: LIST
93524: LIST
93525: LIST
93526: PUSH
93527: EMPTY
93528: LIST
93529: LIST
93530: ST_TO_ADDR
93531: GO 96054
93533: LD_INT 7
93535: DOUBLE
93536: EQUAL
93537: IFTRUE 93541
93539: GO 93653
93541: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
93542: LD_ADDR_VAR 0 2
93546: PUSH
93547: LD_INT 2
93549: PUSH
93550: LD_INT 4
93552: PUSH
93553: LD_INT 5
93555: PUSH
93556: LD_INT 7
93558: PUSH
93559: LD_INT 11
93561: PUSH
93562: LD_INT 12
93564: PUSH
93565: LD_INT 15
93567: PUSH
93568: LD_INT 16
93570: PUSH
93571: LD_INT 20
93573: PUSH
93574: LD_INT 21
93576: PUSH
93577: LD_INT 22
93579: PUSH
93580: LD_INT 23
93582: PUSH
93583: LD_INT 25
93585: PUSH
93586: LD_INT 26
93588: PUSH
93589: EMPTY
93590: LIST
93591: LIST
93592: LIST
93593: LIST
93594: LIST
93595: LIST
93596: LIST
93597: LIST
93598: LIST
93599: LIST
93600: LIST
93601: LIST
93602: LIST
93603: LIST
93604: PUSH
93605: LD_INT 101
93607: PUSH
93608: LD_INT 102
93610: PUSH
93611: LD_INT 103
93613: PUSH
93614: LD_INT 105
93616: PUSH
93617: LD_INT 106
93619: PUSH
93620: LD_INT 108
93622: PUSH
93623: LD_INT 112
93625: PUSH
93626: LD_INT 116
93628: PUSH
93629: LD_INT 117
93631: PUSH
93632: LD_INT 118
93634: PUSH
93635: EMPTY
93636: LIST
93637: LIST
93638: LIST
93639: LIST
93640: LIST
93641: LIST
93642: LIST
93643: LIST
93644: LIST
93645: LIST
93646: PUSH
93647: EMPTY
93648: LIST
93649: LIST
93650: ST_TO_ADDR
93651: GO 96054
93653: LD_INT 8
93655: DOUBLE
93656: EQUAL
93657: IFTRUE 93661
93659: GO 93801
93661: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
93662: LD_ADDR_VAR 0 2
93666: PUSH
93667: LD_INT 2
93669: PUSH
93670: LD_INT 4
93672: PUSH
93673: LD_INT 5
93675: PUSH
93676: LD_INT 6
93678: PUSH
93679: LD_INT 7
93681: PUSH
93682: LD_INT 8
93684: PUSH
93685: LD_INT 11
93687: PUSH
93688: LD_INT 12
93690: PUSH
93691: LD_INT 15
93693: PUSH
93694: LD_INT 16
93696: PUSH
93697: LD_INT 20
93699: PUSH
93700: LD_INT 21
93702: PUSH
93703: LD_INT 22
93705: PUSH
93706: LD_INT 23
93708: PUSH
93709: LD_INT 25
93711: PUSH
93712: LD_INT 26
93714: PUSH
93715: LD_INT 30
93717: PUSH
93718: LD_INT 31
93720: PUSH
93721: LD_INT 32
93723: PUSH
93724: LD_INT 36
93726: PUSH
93727: EMPTY
93728: LIST
93729: LIST
93730: LIST
93731: LIST
93732: LIST
93733: LIST
93734: LIST
93735: LIST
93736: LIST
93737: LIST
93738: LIST
93739: LIST
93740: LIST
93741: LIST
93742: LIST
93743: LIST
93744: LIST
93745: LIST
93746: LIST
93747: LIST
93748: PUSH
93749: LD_INT 101
93751: PUSH
93752: LD_INT 102
93754: PUSH
93755: LD_INT 103
93757: PUSH
93758: LD_INT 105
93760: PUSH
93761: LD_INT 106
93763: PUSH
93764: LD_INT 108
93766: PUSH
93767: LD_INT 109
93769: PUSH
93770: LD_INT 112
93772: PUSH
93773: LD_INT 116
93775: PUSH
93776: LD_INT 117
93778: PUSH
93779: LD_INT 118
93781: PUSH
93782: EMPTY
93783: LIST
93784: LIST
93785: LIST
93786: LIST
93787: LIST
93788: LIST
93789: LIST
93790: LIST
93791: LIST
93792: LIST
93793: LIST
93794: PUSH
93795: EMPTY
93796: LIST
93797: LIST
93798: ST_TO_ADDR
93799: GO 96054
93801: LD_INT 9
93803: DOUBLE
93804: EQUAL
93805: IFTRUE 93809
93807: GO 93957
93809: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
93810: LD_ADDR_VAR 0 2
93814: PUSH
93815: LD_INT 2
93817: PUSH
93818: LD_INT 4
93820: PUSH
93821: LD_INT 5
93823: PUSH
93824: LD_INT 6
93826: PUSH
93827: LD_INT 7
93829: PUSH
93830: LD_INT 8
93832: PUSH
93833: LD_INT 11
93835: PUSH
93836: LD_INT 12
93838: PUSH
93839: LD_INT 15
93841: PUSH
93842: LD_INT 16
93844: PUSH
93845: LD_INT 20
93847: PUSH
93848: LD_INT 21
93850: PUSH
93851: LD_INT 22
93853: PUSH
93854: LD_INT 23
93856: PUSH
93857: LD_INT 25
93859: PUSH
93860: LD_INT 26
93862: PUSH
93863: LD_INT 28
93865: PUSH
93866: LD_INT 30
93868: PUSH
93869: LD_INT 31
93871: PUSH
93872: LD_INT 32
93874: PUSH
93875: LD_INT 36
93877: PUSH
93878: EMPTY
93879: LIST
93880: LIST
93881: LIST
93882: LIST
93883: LIST
93884: LIST
93885: LIST
93886: LIST
93887: LIST
93888: LIST
93889: LIST
93890: LIST
93891: LIST
93892: LIST
93893: LIST
93894: LIST
93895: LIST
93896: LIST
93897: LIST
93898: LIST
93899: LIST
93900: PUSH
93901: LD_INT 101
93903: PUSH
93904: LD_INT 102
93906: PUSH
93907: LD_INT 103
93909: PUSH
93910: LD_INT 105
93912: PUSH
93913: LD_INT 106
93915: PUSH
93916: LD_INT 108
93918: PUSH
93919: LD_INT 109
93921: PUSH
93922: LD_INT 112
93924: PUSH
93925: LD_INT 114
93927: PUSH
93928: LD_INT 116
93930: PUSH
93931: LD_INT 117
93933: PUSH
93934: LD_INT 118
93936: PUSH
93937: EMPTY
93938: LIST
93939: LIST
93940: LIST
93941: LIST
93942: LIST
93943: LIST
93944: LIST
93945: LIST
93946: LIST
93947: LIST
93948: LIST
93949: LIST
93950: PUSH
93951: EMPTY
93952: LIST
93953: LIST
93954: ST_TO_ADDR
93955: GO 96054
93957: LD_INT 10
93959: DOUBLE
93960: EQUAL
93961: IFTRUE 93965
93963: GO 94161
93965: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
93966: LD_ADDR_VAR 0 2
93970: PUSH
93971: LD_INT 2
93973: PUSH
93974: LD_INT 4
93976: PUSH
93977: LD_INT 5
93979: PUSH
93980: LD_INT 6
93982: PUSH
93983: LD_INT 7
93985: PUSH
93986: LD_INT 8
93988: PUSH
93989: LD_INT 9
93991: PUSH
93992: LD_INT 10
93994: PUSH
93995: LD_INT 11
93997: PUSH
93998: LD_INT 12
94000: PUSH
94001: LD_INT 13
94003: PUSH
94004: LD_INT 14
94006: PUSH
94007: LD_INT 15
94009: PUSH
94010: LD_INT 16
94012: PUSH
94013: LD_INT 17
94015: PUSH
94016: LD_INT 18
94018: PUSH
94019: LD_INT 19
94021: PUSH
94022: LD_INT 20
94024: PUSH
94025: LD_INT 21
94027: PUSH
94028: LD_INT 22
94030: PUSH
94031: LD_INT 23
94033: PUSH
94034: LD_INT 24
94036: PUSH
94037: LD_INT 25
94039: PUSH
94040: LD_INT 26
94042: PUSH
94043: LD_INT 28
94045: PUSH
94046: LD_INT 30
94048: PUSH
94049: LD_INT 31
94051: PUSH
94052: LD_INT 32
94054: PUSH
94055: LD_INT 36
94057: PUSH
94058: EMPTY
94059: LIST
94060: LIST
94061: LIST
94062: LIST
94063: LIST
94064: LIST
94065: LIST
94066: LIST
94067: LIST
94068: LIST
94069: LIST
94070: LIST
94071: LIST
94072: LIST
94073: LIST
94074: LIST
94075: LIST
94076: LIST
94077: LIST
94078: LIST
94079: LIST
94080: LIST
94081: LIST
94082: LIST
94083: LIST
94084: LIST
94085: LIST
94086: LIST
94087: LIST
94088: PUSH
94089: LD_INT 101
94091: PUSH
94092: LD_INT 102
94094: PUSH
94095: LD_INT 103
94097: PUSH
94098: LD_INT 104
94100: PUSH
94101: LD_INT 105
94103: PUSH
94104: LD_INT 106
94106: PUSH
94107: LD_INT 107
94109: PUSH
94110: LD_INT 108
94112: PUSH
94113: LD_INT 109
94115: PUSH
94116: LD_INT 110
94118: PUSH
94119: LD_INT 111
94121: PUSH
94122: LD_INT 112
94124: PUSH
94125: LD_INT 114
94127: PUSH
94128: LD_INT 116
94130: PUSH
94131: LD_INT 117
94133: PUSH
94134: LD_INT 118
94136: PUSH
94137: EMPTY
94138: LIST
94139: LIST
94140: LIST
94141: LIST
94142: LIST
94143: LIST
94144: LIST
94145: LIST
94146: LIST
94147: LIST
94148: LIST
94149: LIST
94150: LIST
94151: LIST
94152: LIST
94153: LIST
94154: PUSH
94155: EMPTY
94156: LIST
94157: LIST
94158: ST_TO_ADDR
94159: GO 96054
94161: LD_INT 11
94163: DOUBLE
94164: EQUAL
94165: IFTRUE 94169
94167: GO 94373
94169: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
94170: LD_ADDR_VAR 0 2
94174: PUSH
94175: LD_INT 2
94177: PUSH
94178: LD_INT 3
94180: PUSH
94181: LD_INT 4
94183: PUSH
94184: LD_INT 5
94186: PUSH
94187: LD_INT 6
94189: PUSH
94190: LD_INT 7
94192: PUSH
94193: LD_INT 8
94195: PUSH
94196: LD_INT 9
94198: PUSH
94199: LD_INT 10
94201: PUSH
94202: LD_INT 11
94204: PUSH
94205: LD_INT 12
94207: PUSH
94208: LD_INT 13
94210: PUSH
94211: LD_INT 14
94213: PUSH
94214: LD_INT 15
94216: PUSH
94217: LD_INT 16
94219: PUSH
94220: LD_INT 17
94222: PUSH
94223: LD_INT 18
94225: PUSH
94226: LD_INT 19
94228: PUSH
94229: LD_INT 20
94231: PUSH
94232: LD_INT 21
94234: PUSH
94235: LD_INT 22
94237: PUSH
94238: LD_INT 23
94240: PUSH
94241: LD_INT 24
94243: PUSH
94244: LD_INT 25
94246: PUSH
94247: LD_INT 26
94249: PUSH
94250: LD_INT 28
94252: PUSH
94253: LD_INT 30
94255: PUSH
94256: LD_INT 31
94258: PUSH
94259: LD_INT 32
94261: PUSH
94262: LD_INT 34
94264: PUSH
94265: LD_INT 36
94267: PUSH
94268: EMPTY
94269: LIST
94270: LIST
94271: LIST
94272: LIST
94273: LIST
94274: LIST
94275: LIST
94276: LIST
94277: LIST
94278: LIST
94279: LIST
94280: LIST
94281: LIST
94282: LIST
94283: LIST
94284: LIST
94285: LIST
94286: LIST
94287: LIST
94288: LIST
94289: LIST
94290: LIST
94291: LIST
94292: LIST
94293: LIST
94294: LIST
94295: LIST
94296: LIST
94297: LIST
94298: LIST
94299: LIST
94300: PUSH
94301: LD_INT 101
94303: PUSH
94304: LD_INT 102
94306: PUSH
94307: LD_INT 103
94309: PUSH
94310: LD_INT 104
94312: PUSH
94313: LD_INT 105
94315: PUSH
94316: LD_INT 106
94318: PUSH
94319: LD_INT 107
94321: PUSH
94322: LD_INT 108
94324: PUSH
94325: LD_INT 109
94327: PUSH
94328: LD_INT 110
94330: PUSH
94331: LD_INT 111
94333: PUSH
94334: LD_INT 112
94336: PUSH
94337: LD_INT 114
94339: PUSH
94340: LD_INT 116
94342: PUSH
94343: LD_INT 117
94345: PUSH
94346: LD_INT 118
94348: PUSH
94349: EMPTY
94350: LIST
94351: LIST
94352: LIST
94353: LIST
94354: LIST
94355: LIST
94356: LIST
94357: LIST
94358: LIST
94359: LIST
94360: LIST
94361: LIST
94362: LIST
94363: LIST
94364: LIST
94365: LIST
94366: PUSH
94367: EMPTY
94368: LIST
94369: LIST
94370: ST_TO_ADDR
94371: GO 96054
94373: LD_INT 12
94375: DOUBLE
94376: EQUAL
94377: IFTRUE 94381
94379: GO 94601
94381: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
94382: LD_ADDR_VAR 0 2
94386: PUSH
94387: LD_INT 1
94389: PUSH
94390: LD_INT 2
94392: PUSH
94393: LD_INT 3
94395: PUSH
94396: LD_INT 4
94398: PUSH
94399: LD_INT 5
94401: PUSH
94402: LD_INT 6
94404: PUSH
94405: LD_INT 7
94407: PUSH
94408: LD_INT 8
94410: PUSH
94411: LD_INT 9
94413: PUSH
94414: LD_INT 10
94416: PUSH
94417: LD_INT 11
94419: PUSH
94420: LD_INT 12
94422: PUSH
94423: LD_INT 13
94425: PUSH
94426: LD_INT 14
94428: PUSH
94429: LD_INT 15
94431: PUSH
94432: LD_INT 16
94434: PUSH
94435: LD_INT 17
94437: PUSH
94438: LD_INT 18
94440: PUSH
94441: LD_INT 19
94443: PUSH
94444: LD_INT 20
94446: PUSH
94447: LD_INT 21
94449: PUSH
94450: LD_INT 22
94452: PUSH
94453: LD_INT 23
94455: PUSH
94456: LD_INT 24
94458: PUSH
94459: LD_INT 25
94461: PUSH
94462: LD_INT 26
94464: PUSH
94465: LD_INT 27
94467: PUSH
94468: LD_INT 28
94470: PUSH
94471: LD_INT 30
94473: PUSH
94474: LD_INT 31
94476: PUSH
94477: LD_INT 32
94479: PUSH
94480: LD_INT 33
94482: PUSH
94483: LD_INT 34
94485: PUSH
94486: LD_INT 36
94488: PUSH
94489: EMPTY
94490: LIST
94491: LIST
94492: LIST
94493: LIST
94494: LIST
94495: LIST
94496: LIST
94497: LIST
94498: LIST
94499: LIST
94500: LIST
94501: LIST
94502: LIST
94503: LIST
94504: LIST
94505: LIST
94506: LIST
94507: LIST
94508: LIST
94509: LIST
94510: LIST
94511: LIST
94512: LIST
94513: LIST
94514: LIST
94515: LIST
94516: LIST
94517: LIST
94518: LIST
94519: LIST
94520: LIST
94521: LIST
94522: LIST
94523: LIST
94524: PUSH
94525: LD_INT 101
94527: PUSH
94528: LD_INT 102
94530: PUSH
94531: LD_INT 103
94533: PUSH
94534: LD_INT 104
94536: PUSH
94537: LD_INT 105
94539: PUSH
94540: LD_INT 106
94542: PUSH
94543: LD_INT 107
94545: PUSH
94546: LD_INT 108
94548: PUSH
94549: LD_INT 109
94551: PUSH
94552: LD_INT 110
94554: PUSH
94555: LD_INT 111
94557: PUSH
94558: LD_INT 112
94560: PUSH
94561: LD_INT 113
94563: PUSH
94564: LD_INT 114
94566: PUSH
94567: LD_INT 116
94569: PUSH
94570: LD_INT 117
94572: PUSH
94573: LD_INT 118
94575: PUSH
94576: EMPTY
94577: LIST
94578: LIST
94579: LIST
94580: LIST
94581: LIST
94582: LIST
94583: LIST
94584: LIST
94585: LIST
94586: LIST
94587: LIST
94588: LIST
94589: LIST
94590: LIST
94591: LIST
94592: LIST
94593: LIST
94594: PUSH
94595: EMPTY
94596: LIST
94597: LIST
94598: ST_TO_ADDR
94599: GO 96054
94601: LD_INT 13
94603: DOUBLE
94604: EQUAL
94605: IFTRUE 94609
94607: GO 94817
94609: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
94610: LD_ADDR_VAR 0 2
94614: PUSH
94615: LD_INT 1
94617: PUSH
94618: LD_INT 2
94620: PUSH
94621: LD_INT 3
94623: PUSH
94624: LD_INT 4
94626: PUSH
94627: LD_INT 5
94629: PUSH
94630: LD_INT 8
94632: PUSH
94633: LD_INT 9
94635: PUSH
94636: LD_INT 10
94638: PUSH
94639: LD_INT 11
94641: PUSH
94642: LD_INT 12
94644: PUSH
94645: LD_INT 14
94647: PUSH
94648: LD_INT 15
94650: PUSH
94651: LD_INT 16
94653: PUSH
94654: LD_INT 17
94656: PUSH
94657: LD_INT 18
94659: PUSH
94660: LD_INT 19
94662: PUSH
94663: LD_INT 20
94665: PUSH
94666: LD_INT 21
94668: PUSH
94669: LD_INT 22
94671: PUSH
94672: LD_INT 23
94674: PUSH
94675: LD_INT 24
94677: PUSH
94678: LD_INT 25
94680: PUSH
94681: LD_INT 26
94683: PUSH
94684: LD_INT 27
94686: PUSH
94687: LD_INT 28
94689: PUSH
94690: LD_INT 30
94692: PUSH
94693: LD_INT 31
94695: PUSH
94696: LD_INT 32
94698: PUSH
94699: LD_INT 33
94701: PUSH
94702: LD_INT 34
94704: PUSH
94705: LD_INT 36
94707: PUSH
94708: EMPTY
94709: LIST
94710: LIST
94711: LIST
94712: LIST
94713: LIST
94714: LIST
94715: LIST
94716: LIST
94717: LIST
94718: LIST
94719: LIST
94720: LIST
94721: LIST
94722: LIST
94723: LIST
94724: LIST
94725: LIST
94726: LIST
94727: LIST
94728: LIST
94729: LIST
94730: LIST
94731: LIST
94732: LIST
94733: LIST
94734: LIST
94735: LIST
94736: LIST
94737: LIST
94738: LIST
94739: LIST
94740: PUSH
94741: LD_INT 101
94743: PUSH
94744: LD_INT 102
94746: PUSH
94747: LD_INT 103
94749: PUSH
94750: LD_INT 104
94752: PUSH
94753: LD_INT 105
94755: PUSH
94756: LD_INT 106
94758: PUSH
94759: LD_INT 107
94761: PUSH
94762: LD_INT 108
94764: PUSH
94765: LD_INT 109
94767: PUSH
94768: LD_INT 110
94770: PUSH
94771: LD_INT 111
94773: PUSH
94774: LD_INT 112
94776: PUSH
94777: LD_INT 113
94779: PUSH
94780: LD_INT 114
94782: PUSH
94783: LD_INT 116
94785: PUSH
94786: LD_INT 117
94788: PUSH
94789: LD_INT 118
94791: PUSH
94792: EMPTY
94793: LIST
94794: LIST
94795: LIST
94796: LIST
94797: LIST
94798: LIST
94799: LIST
94800: LIST
94801: LIST
94802: LIST
94803: LIST
94804: LIST
94805: LIST
94806: LIST
94807: LIST
94808: LIST
94809: LIST
94810: PUSH
94811: EMPTY
94812: LIST
94813: LIST
94814: ST_TO_ADDR
94815: GO 96054
94817: LD_INT 14
94819: DOUBLE
94820: EQUAL
94821: IFTRUE 94825
94823: GO 95049
94825: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
94826: LD_ADDR_VAR 0 2
94830: PUSH
94831: LD_INT 1
94833: PUSH
94834: LD_INT 2
94836: PUSH
94837: LD_INT 3
94839: PUSH
94840: LD_INT 4
94842: PUSH
94843: LD_INT 5
94845: PUSH
94846: LD_INT 6
94848: PUSH
94849: LD_INT 7
94851: PUSH
94852: LD_INT 8
94854: PUSH
94855: LD_INT 9
94857: PUSH
94858: LD_INT 10
94860: PUSH
94861: LD_INT 11
94863: PUSH
94864: LD_INT 12
94866: PUSH
94867: LD_INT 13
94869: PUSH
94870: LD_INT 14
94872: PUSH
94873: LD_INT 15
94875: PUSH
94876: LD_INT 16
94878: PUSH
94879: LD_INT 17
94881: PUSH
94882: LD_INT 18
94884: PUSH
94885: LD_INT 19
94887: PUSH
94888: LD_INT 20
94890: PUSH
94891: LD_INT 21
94893: PUSH
94894: LD_INT 22
94896: PUSH
94897: LD_INT 23
94899: PUSH
94900: LD_INT 24
94902: PUSH
94903: LD_INT 25
94905: PUSH
94906: LD_INT 26
94908: PUSH
94909: LD_INT 27
94911: PUSH
94912: LD_INT 28
94914: PUSH
94915: LD_INT 29
94917: PUSH
94918: LD_INT 30
94920: PUSH
94921: LD_INT 31
94923: PUSH
94924: LD_INT 32
94926: PUSH
94927: LD_INT 33
94929: PUSH
94930: LD_INT 34
94932: PUSH
94933: LD_INT 36
94935: PUSH
94936: EMPTY
94937: LIST
94938: LIST
94939: LIST
94940: LIST
94941: LIST
94942: LIST
94943: LIST
94944: LIST
94945: LIST
94946: LIST
94947: LIST
94948: LIST
94949: LIST
94950: LIST
94951: LIST
94952: LIST
94953: LIST
94954: LIST
94955: LIST
94956: LIST
94957: LIST
94958: LIST
94959: LIST
94960: LIST
94961: LIST
94962: LIST
94963: LIST
94964: LIST
94965: LIST
94966: LIST
94967: LIST
94968: LIST
94969: LIST
94970: LIST
94971: LIST
94972: PUSH
94973: LD_INT 101
94975: PUSH
94976: LD_INT 102
94978: PUSH
94979: LD_INT 103
94981: PUSH
94982: LD_INT 104
94984: PUSH
94985: LD_INT 105
94987: PUSH
94988: LD_INT 106
94990: PUSH
94991: LD_INT 107
94993: PUSH
94994: LD_INT 108
94996: PUSH
94997: LD_INT 109
94999: PUSH
95000: LD_INT 110
95002: PUSH
95003: LD_INT 111
95005: PUSH
95006: LD_INT 112
95008: PUSH
95009: LD_INT 113
95011: PUSH
95012: LD_INT 114
95014: PUSH
95015: LD_INT 116
95017: PUSH
95018: LD_INT 117
95020: PUSH
95021: LD_INT 118
95023: PUSH
95024: EMPTY
95025: LIST
95026: LIST
95027: LIST
95028: LIST
95029: LIST
95030: LIST
95031: LIST
95032: LIST
95033: LIST
95034: LIST
95035: LIST
95036: LIST
95037: LIST
95038: LIST
95039: LIST
95040: LIST
95041: LIST
95042: PUSH
95043: EMPTY
95044: LIST
95045: LIST
95046: ST_TO_ADDR
95047: GO 96054
95049: LD_INT 15
95051: DOUBLE
95052: EQUAL
95053: IFTRUE 95057
95055: GO 95281
95057: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
95058: LD_ADDR_VAR 0 2
95062: PUSH
95063: LD_INT 1
95065: PUSH
95066: LD_INT 2
95068: PUSH
95069: LD_INT 3
95071: PUSH
95072: LD_INT 4
95074: PUSH
95075: LD_INT 5
95077: PUSH
95078: LD_INT 6
95080: PUSH
95081: LD_INT 7
95083: PUSH
95084: LD_INT 8
95086: PUSH
95087: LD_INT 9
95089: PUSH
95090: LD_INT 10
95092: PUSH
95093: LD_INT 11
95095: PUSH
95096: LD_INT 12
95098: PUSH
95099: LD_INT 13
95101: PUSH
95102: LD_INT 14
95104: PUSH
95105: LD_INT 15
95107: PUSH
95108: LD_INT 16
95110: PUSH
95111: LD_INT 17
95113: PUSH
95114: LD_INT 18
95116: PUSH
95117: LD_INT 19
95119: PUSH
95120: LD_INT 20
95122: PUSH
95123: LD_INT 21
95125: PUSH
95126: LD_INT 22
95128: PUSH
95129: LD_INT 23
95131: PUSH
95132: LD_INT 24
95134: PUSH
95135: LD_INT 25
95137: PUSH
95138: LD_INT 26
95140: PUSH
95141: LD_INT 27
95143: PUSH
95144: LD_INT 28
95146: PUSH
95147: LD_INT 29
95149: PUSH
95150: LD_INT 30
95152: PUSH
95153: LD_INT 31
95155: PUSH
95156: LD_INT 32
95158: PUSH
95159: LD_INT 33
95161: PUSH
95162: LD_INT 34
95164: PUSH
95165: LD_INT 36
95167: PUSH
95168: EMPTY
95169: LIST
95170: LIST
95171: LIST
95172: LIST
95173: LIST
95174: LIST
95175: LIST
95176: LIST
95177: LIST
95178: LIST
95179: LIST
95180: LIST
95181: LIST
95182: LIST
95183: LIST
95184: LIST
95185: LIST
95186: LIST
95187: LIST
95188: LIST
95189: LIST
95190: LIST
95191: LIST
95192: LIST
95193: LIST
95194: LIST
95195: LIST
95196: LIST
95197: LIST
95198: LIST
95199: LIST
95200: LIST
95201: LIST
95202: LIST
95203: LIST
95204: PUSH
95205: LD_INT 101
95207: PUSH
95208: LD_INT 102
95210: PUSH
95211: LD_INT 103
95213: PUSH
95214: LD_INT 104
95216: PUSH
95217: LD_INT 105
95219: PUSH
95220: LD_INT 106
95222: PUSH
95223: LD_INT 107
95225: PUSH
95226: LD_INT 108
95228: PUSH
95229: LD_INT 109
95231: PUSH
95232: LD_INT 110
95234: PUSH
95235: LD_INT 111
95237: PUSH
95238: LD_INT 112
95240: PUSH
95241: LD_INT 113
95243: PUSH
95244: LD_INT 114
95246: PUSH
95247: LD_INT 116
95249: PUSH
95250: LD_INT 117
95252: PUSH
95253: LD_INT 118
95255: PUSH
95256: EMPTY
95257: LIST
95258: LIST
95259: LIST
95260: LIST
95261: LIST
95262: LIST
95263: LIST
95264: LIST
95265: LIST
95266: LIST
95267: LIST
95268: LIST
95269: LIST
95270: LIST
95271: LIST
95272: LIST
95273: LIST
95274: PUSH
95275: EMPTY
95276: LIST
95277: LIST
95278: ST_TO_ADDR
95279: GO 96054
95281: LD_INT 16
95283: DOUBLE
95284: EQUAL
95285: IFTRUE 95289
95287: GO 95425
95289: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
95290: LD_ADDR_VAR 0 2
95294: PUSH
95295: LD_INT 2
95297: PUSH
95298: LD_INT 4
95300: PUSH
95301: LD_INT 5
95303: PUSH
95304: LD_INT 7
95306: PUSH
95307: LD_INT 11
95309: PUSH
95310: LD_INT 12
95312: PUSH
95313: LD_INT 15
95315: PUSH
95316: LD_INT 16
95318: PUSH
95319: LD_INT 20
95321: PUSH
95322: LD_INT 21
95324: PUSH
95325: LD_INT 22
95327: PUSH
95328: LD_INT 23
95330: PUSH
95331: LD_INT 25
95333: PUSH
95334: LD_INT 26
95336: PUSH
95337: LD_INT 30
95339: PUSH
95340: LD_INT 31
95342: PUSH
95343: LD_INT 32
95345: PUSH
95346: LD_INT 33
95348: PUSH
95349: LD_INT 34
95351: PUSH
95352: EMPTY
95353: LIST
95354: LIST
95355: LIST
95356: LIST
95357: LIST
95358: LIST
95359: LIST
95360: LIST
95361: LIST
95362: LIST
95363: LIST
95364: LIST
95365: LIST
95366: LIST
95367: LIST
95368: LIST
95369: LIST
95370: LIST
95371: LIST
95372: PUSH
95373: LD_INT 101
95375: PUSH
95376: LD_INT 102
95378: PUSH
95379: LD_INT 103
95381: PUSH
95382: LD_INT 106
95384: PUSH
95385: LD_INT 108
95387: PUSH
95388: LD_INT 112
95390: PUSH
95391: LD_INT 113
95393: PUSH
95394: LD_INT 114
95396: PUSH
95397: LD_INT 116
95399: PUSH
95400: LD_INT 117
95402: PUSH
95403: LD_INT 118
95405: PUSH
95406: EMPTY
95407: LIST
95408: LIST
95409: LIST
95410: LIST
95411: LIST
95412: LIST
95413: LIST
95414: LIST
95415: LIST
95416: LIST
95417: LIST
95418: PUSH
95419: EMPTY
95420: LIST
95421: LIST
95422: ST_TO_ADDR
95423: GO 96054
95425: LD_INT 17
95427: DOUBLE
95428: EQUAL
95429: IFTRUE 95433
95431: GO 95657
95433: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
95434: LD_ADDR_VAR 0 2
95438: PUSH
95439: LD_INT 1
95441: PUSH
95442: LD_INT 2
95444: PUSH
95445: LD_INT 3
95447: PUSH
95448: LD_INT 4
95450: PUSH
95451: LD_INT 5
95453: PUSH
95454: LD_INT 6
95456: PUSH
95457: LD_INT 7
95459: PUSH
95460: LD_INT 8
95462: PUSH
95463: LD_INT 9
95465: PUSH
95466: LD_INT 10
95468: PUSH
95469: LD_INT 11
95471: PUSH
95472: LD_INT 12
95474: PUSH
95475: LD_INT 13
95477: PUSH
95478: LD_INT 14
95480: PUSH
95481: LD_INT 15
95483: PUSH
95484: LD_INT 16
95486: PUSH
95487: LD_INT 17
95489: PUSH
95490: LD_INT 18
95492: PUSH
95493: LD_INT 19
95495: PUSH
95496: LD_INT 20
95498: PUSH
95499: LD_INT 21
95501: PUSH
95502: LD_INT 22
95504: PUSH
95505: LD_INT 23
95507: PUSH
95508: LD_INT 24
95510: PUSH
95511: LD_INT 25
95513: PUSH
95514: LD_INT 26
95516: PUSH
95517: LD_INT 27
95519: PUSH
95520: LD_INT 28
95522: PUSH
95523: LD_INT 29
95525: PUSH
95526: LD_INT 30
95528: PUSH
95529: LD_INT 31
95531: PUSH
95532: LD_INT 32
95534: PUSH
95535: LD_INT 33
95537: PUSH
95538: LD_INT 34
95540: PUSH
95541: LD_INT 36
95543: PUSH
95544: EMPTY
95545: LIST
95546: LIST
95547: LIST
95548: LIST
95549: LIST
95550: LIST
95551: LIST
95552: LIST
95553: LIST
95554: LIST
95555: LIST
95556: LIST
95557: LIST
95558: LIST
95559: LIST
95560: LIST
95561: LIST
95562: LIST
95563: LIST
95564: LIST
95565: LIST
95566: LIST
95567: LIST
95568: LIST
95569: LIST
95570: LIST
95571: LIST
95572: LIST
95573: LIST
95574: LIST
95575: LIST
95576: LIST
95577: LIST
95578: LIST
95579: LIST
95580: PUSH
95581: LD_INT 101
95583: PUSH
95584: LD_INT 102
95586: PUSH
95587: LD_INT 103
95589: PUSH
95590: LD_INT 104
95592: PUSH
95593: LD_INT 105
95595: PUSH
95596: LD_INT 106
95598: PUSH
95599: LD_INT 107
95601: PUSH
95602: LD_INT 108
95604: PUSH
95605: LD_INT 109
95607: PUSH
95608: LD_INT 110
95610: PUSH
95611: LD_INT 111
95613: PUSH
95614: LD_INT 112
95616: PUSH
95617: LD_INT 113
95619: PUSH
95620: LD_INT 114
95622: PUSH
95623: LD_INT 116
95625: PUSH
95626: LD_INT 117
95628: PUSH
95629: LD_INT 118
95631: PUSH
95632: EMPTY
95633: LIST
95634: LIST
95635: LIST
95636: LIST
95637: LIST
95638: LIST
95639: LIST
95640: LIST
95641: LIST
95642: LIST
95643: LIST
95644: LIST
95645: LIST
95646: LIST
95647: LIST
95648: LIST
95649: LIST
95650: PUSH
95651: EMPTY
95652: LIST
95653: LIST
95654: ST_TO_ADDR
95655: GO 96054
95657: LD_INT 18
95659: DOUBLE
95660: EQUAL
95661: IFTRUE 95665
95663: GO 95813
95665: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
95666: LD_ADDR_VAR 0 2
95670: PUSH
95671: LD_INT 2
95673: PUSH
95674: LD_INT 4
95676: PUSH
95677: LD_INT 5
95679: PUSH
95680: LD_INT 7
95682: PUSH
95683: LD_INT 11
95685: PUSH
95686: LD_INT 12
95688: PUSH
95689: LD_INT 15
95691: PUSH
95692: LD_INT 16
95694: PUSH
95695: LD_INT 20
95697: PUSH
95698: LD_INT 21
95700: PUSH
95701: LD_INT 22
95703: PUSH
95704: LD_INT 23
95706: PUSH
95707: LD_INT 25
95709: PUSH
95710: LD_INT 26
95712: PUSH
95713: LD_INT 30
95715: PUSH
95716: LD_INT 31
95718: PUSH
95719: LD_INT 32
95721: PUSH
95722: LD_INT 33
95724: PUSH
95725: LD_INT 34
95727: PUSH
95728: LD_INT 35
95730: PUSH
95731: LD_INT 36
95733: PUSH
95734: EMPTY
95735: LIST
95736: LIST
95737: LIST
95738: LIST
95739: LIST
95740: LIST
95741: LIST
95742: LIST
95743: LIST
95744: LIST
95745: LIST
95746: LIST
95747: LIST
95748: LIST
95749: LIST
95750: LIST
95751: LIST
95752: LIST
95753: LIST
95754: LIST
95755: LIST
95756: PUSH
95757: LD_INT 101
95759: PUSH
95760: LD_INT 102
95762: PUSH
95763: LD_INT 103
95765: PUSH
95766: LD_INT 106
95768: PUSH
95769: LD_INT 108
95771: PUSH
95772: LD_INT 112
95774: PUSH
95775: LD_INT 113
95777: PUSH
95778: LD_INT 114
95780: PUSH
95781: LD_INT 115
95783: PUSH
95784: LD_INT 116
95786: PUSH
95787: LD_INT 117
95789: PUSH
95790: LD_INT 118
95792: PUSH
95793: EMPTY
95794: LIST
95795: LIST
95796: LIST
95797: LIST
95798: LIST
95799: LIST
95800: LIST
95801: LIST
95802: LIST
95803: LIST
95804: LIST
95805: LIST
95806: PUSH
95807: EMPTY
95808: LIST
95809: LIST
95810: ST_TO_ADDR
95811: GO 96054
95813: LD_INT 19
95815: DOUBLE
95816: EQUAL
95817: IFTRUE 95821
95819: GO 96053
95821: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
95822: LD_ADDR_VAR 0 2
95826: PUSH
95827: LD_INT 1
95829: PUSH
95830: LD_INT 2
95832: PUSH
95833: LD_INT 3
95835: PUSH
95836: LD_INT 4
95838: PUSH
95839: LD_INT 5
95841: PUSH
95842: LD_INT 6
95844: PUSH
95845: LD_INT 7
95847: PUSH
95848: LD_INT 8
95850: PUSH
95851: LD_INT 9
95853: PUSH
95854: LD_INT 10
95856: PUSH
95857: LD_INT 11
95859: PUSH
95860: LD_INT 12
95862: PUSH
95863: LD_INT 13
95865: PUSH
95866: LD_INT 14
95868: PUSH
95869: LD_INT 15
95871: PUSH
95872: LD_INT 16
95874: PUSH
95875: LD_INT 17
95877: PUSH
95878: LD_INT 18
95880: PUSH
95881: LD_INT 19
95883: PUSH
95884: LD_INT 20
95886: PUSH
95887: LD_INT 21
95889: PUSH
95890: LD_INT 22
95892: PUSH
95893: LD_INT 23
95895: PUSH
95896: LD_INT 24
95898: PUSH
95899: LD_INT 25
95901: PUSH
95902: LD_INT 26
95904: PUSH
95905: LD_INT 27
95907: PUSH
95908: LD_INT 28
95910: PUSH
95911: LD_INT 29
95913: PUSH
95914: LD_INT 30
95916: PUSH
95917: LD_INT 31
95919: PUSH
95920: LD_INT 32
95922: PUSH
95923: LD_INT 33
95925: PUSH
95926: LD_INT 34
95928: PUSH
95929: LD_INT 35
95931: PUSH
95932: LD_INT 36
95934: PUSH
95935: EMPTY
95936: LIST
95937: LIST
95938: LIST
95939: LIST
95940: LIST
95941: LIST
95942: LIST
95943: LIST
95944: LIST
95945: LIST
95946: LIST
95947: LIST
95948: LIST
95949: LIST
95950: LIST
95951: LIST
95952: LIST
95953: LIST
95954: LIST
95955: LIST
95956: LIST
95957: LIST
95958: LIST
95959: LIST
95960: LIST
95961: LIST
95962: LIST
95963: LIST
95964: LIST
95965: LIST
95966: LIST
95967: LIST
95968: LIST
95969: LIST
95970: LIST
95971: LIST
95972: PUSH
95973: LD_INT 101
95975: PUSH
95976: LD_INT 102
95978: PUSH
95979: LD_INT 103
95981: PUSH
95982: LD_INT 104
95984: PUSH
95985: LD_INT 105
95987: PUSH
95988: LD_INT 106
95990: PUSH
95991: LD_INT 107
95993: PUSH
95994: LD_INT 108
95996: PUSH
95997: LD_INT 109
95999: PUSH
96000: LD_INT 110
96002: PUSH
96003: LD_INT 111
96005: PUSH
96006: LD_INT 112
96008: PUSH
96009: LD_INT 113
96011: PUSH
96012: LD_INT 114
96014: PUSH
96015: LD_INT 115
96017: PUSH
96018: LD_INT 116
96020: PUSH
96021: LD_INT 117
96023: PUSH
96024: LD_INT 118
96026: PUSH
96027: EMPTY
96028: LIST
96029: LIST
96030: LIST
96031: LIST
96032: LIST
96033: LIST
96034: LIST
96035: LIST
96036: LIST
96037: LIST
96038: LIST
96039: LIST
96040: LIST
96041: LIST
96042: LIST
96043: LIST
96044: LIST
96045: LIST
96046: PUSH
96047: EMPTY
96048: LIST
96049: LIST
96050: ST_TO_ADDR
96051: GO 96054
96053: POP
// end else
96054: GO 96285
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
96056: LD_ADDR_VAR 0 2
96060: PUSH
96061: LD_INT 1
96063: PUSH
96064: LD_INT 2
96066: PUSH
96067: LD_INT 3
96069: PUSH
96070: LD_INT 4
96072: PUSH
96073: LD_INT 5
96075: PUSH
96076: LD_INT 6
96078: PUSH
96079: LD_INT 7
96081: PUSH
96082: LD_INT 8
96084: PUSH
96085: LD_INT 9
96087: PUSH
96088: LD_INT 10
96090: PUSH
96091: LD_INT 11
96093: PUSH
96094: LD_INT 12
96096: PUSH
96097: LD_INT 13
96099: PUSH
96100: LD_INT 14
96102: PUSH
96103: LD_INT 15
96105: PUSH
96106: LD_INT 16
96108: PUSH
96109: LD_INT 17
96111: PUSH
96112: LD_INT 18
96114: PUSH
96115: LD_INT 19
96117: PUSH
96118: LD_INT 20
96120: PUSH
96121: LD_INT 21
96123: PUSH
96124: LD_INT 22
96126: PUSH
96127: LD_INT 23
96129: PUSH
96130: LD_INT 24
96132: PUSH
96133: LD_INT 25
96135: PUSH
96136: LD_INT 26
96138: PUSH
96139: LD_INT 27
96141: PUSH
96142: LD_INT 28
96144: PUSH
96145: LD_INT 29
96147: PUSH
96148: LD_INT 30
96150: PUSH
96151: LD_INT 31
96153: PUSH
96154: LD_INT 32
96156: PUSH
96157: LD_INT 33
96159: PUSH
96160: LD_INT 34
96162: PUSH
96163: LD_INT 35
96165: PUSH
96166: LD_INT 36
96168: PUSH
96169: EMPTY
96170: LIST
96171: LIST
96172: LIST
96173: LIST
96174: LIST
96175: LIST
96176: LIST
96177: LIST
96178: LIST
96179: LIST
96180: LIST
96181: LIST
96182: LIST
96183: LIST
96184: LIST
96185: LIST
96186: LIST
96187: LIST
96188: LIST
96189: LIST
96190: LIST
96191: LIST
96192: LIST
96193: LIST
96194: LIST
96195: LIST
96196: LIST
96197: LIST
96198: LIST
96199: LIST
96200: LIST
96201: LIST
96202: LIST
96203: LIST
96204: LIST
96205: LIST
96206: PUSH
96207: LD_INT 101
96209: PUSH
96210: LD_INT 102
96212: PUSH
96213: LD_INT 103
96215: PUSH
96216: LD_INT 104
96218: PUSH
96219: LD_INT 105
96221: PUSH
96222: LD_INT 106
96224: PUSH
96225: LD_INT 107
96227: PUSH
96228: LD_INT 108
96230: PUSH
96231: LD_INT 109
96233: PUSH
96234: LD_INT 110
96236: PUSH
96237: LD_INT 111
96239: PUSH
96240: LD_INT 112
96242: PUSH
96243: LD_INT 113
96245: PUSH
96246: LD_INT 114
96248: PUSH
96249: LD_INT 115
96251: PUSH
96252: LD_INT 116
96254: PUSH
96255: LD_INT 117
96257: PUSH
96258: LD_INT 118
96260: PUSH
96261: EMPTY
96262: LIST
96263: LIST
96264: LIST
96265: LIST
96266: LIST
96267: LIST
96268: LIST
96269: LIST
96270: LIST
96271: LIST
96272: LIST
96273: LIST
96274: LIST
96275: LIST
96276: LIST
96277: LIST
96278: LIST
96279: LIST
96280: PUSH
96281: EMPTY
96282: LIST
96283: LIST
96284: ST_TO_ADDR
// if result then
96285: LD_VAR 0 2
96289: IFFALSE 97075
// begin normal :=  ;
96291: LD_ADDR_VAR 0 5
96295: PUSH
96296: LD_STRING 
96298: ST_TO_ADDR
// hardcore :=  ;
96299: LD_ADDR_VAR 0 6
96303: PUSH
96304: LD_STRING 
96306: ST_TO_ADDR
// active :=  ;
96307: LD_ADDR_VAR 0 7
96311: PUSH
96312: LD_STRING 
96314: ST_TO_ADDR
// for i = 1 to normalCounter do
96315: LD_ADDR_VAR 0 8
96319: PUSH
96320: DOUBLE
96321: LD_INT 1
96323: DEC
96324: ST_TO_ADDR
96325: LD_EXP 97
96329: PUSH
96330: FOR_TO
96331: IFFALSE 96432
// begin tmp := 0 ;
96333: LD_ADDR_VAR 0 3
96337: PUSH
96338: LD_STRING 0
96340: ST_TO_ADDR
// if result [ 1 ] then
96341: LD_VAR 0 2
96345: PUSH
96346: LD_INT 1
96348: ARRAY
96349: IFFALSE 96414
// if result [ 1 ] [ 1 ] = i then
96351: LD_VAR 0 2
96355: PUSH
96356: LD_INT 1
96358: ARRAY
96359: PUSH
96360: LD_INT 1
96362: ARRAY
96363: PUSH
96364: LD_VAR 0 8
96368: EQUAL
96369: IFFALSE 96414
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
96371: LD_ADDR_VAR 0 2
96375: PUSH
96376: LD_VAR 0 2
96380: PPUSH
96381: LD_INT 1
96383: PPUSH
96384: LD_VAR 0 2
96388: PUSH
96389: LD_INT 1
96391: ARRAY
96392: PPUSH
96393: LD_INT 1
96395: PPUSH
96396: CALL_OW 3
96400: PPUSH
96401: CALL_OW 1
96405: ST_TO_ADDR
// tmp := 1 ;
96406: LD_ADDR_VAR 0 3
96410: PUSH
96411: LD_STRING 1
96413: ST_TO_ADDR
// end ; normal := normal & tmp ;
96414: LD_ADDR_VAR 0 5
96418: PUSH
96419: LD_VAR 0 5
96423: PUSH
96424: LD_VAR 0 3
96428: STR
96429: ST_TO_ADDR
// end ;
96430: GO 96330
96432: POP
96433: POP
// for i = 1 to hardcoreCounter do
96434: LD_ADDR_VAR 0 8
96438: PUSH
96439: DOUBLE
96440: LD_INT 1
96442: DEC
96443: ST_TO_ADDR
96444: LD_EXP 98
96448: PUSH
96449: FOR_TO
96450: IFFALSE 96555
// begin tmp := 0 ;
96452: LD_ADDR_VAR 0 3
96456: PUSH
96457: LD_STRING 0
96459: ST_TO_ADDR
// if result [ 2 ] then
96460: LD_VAR 0 2
96464: PUSH
96465: LD_INT 2
96467: ARRAY
96468: IFFALSE 96537
// if result [ 2 ] [ 1 ] = 100 + i then
96470: LD_VAR 0 2
96474: PUSH
96475: LD_INT 2
96477: ARRAY
96478: PUSH
96479: LD_INT 1
96481: ARRAY
96482: PUSH
96483: LD_INT 100
96485: PUSH
96486: LD_VAR 0 8
96490: PLUS
96491: EQUAL
96492: IFFALSE 96537
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
96494: LD_ADDR_VAR 0 2
96498: PUSH
96499: LD_VAR 0 2
96503: PPUSH
96504: LD_INT 2
96506: PPUSH
96507: LD_VAR 0 2
96511: PUSH
96512: LD_INT 2
96514: ARRAY
96515: PPUSH
96516: LD_INT 1
96518: PPUSH
96519: CALL_OW 3
96523: PPUSH
96524: CALL_OW 1
96528: ST_TO_ADDR
// tmp := 1 ;
96529: LD_ADDR_VAR 0 3
96533: PUSH
96534: LD_STRING 1
96536: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
96537: LD_ADDR_VAR 0 6
96541: PUSH
96542: LD_VAR 0 6
96546: PUSH
96547: LD_VAR 0 3
96551: STR
96552: ST_TO_ADDR
// end ;
96553: GO 96449
96555: POP
96556: POP
// if isGameLoad then
96557: LD_VAR 0 1
96561: IFFALSE 97036
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
96563: LD_ADDR_VAR 0 4
96567: PUSH
96568: LD_EXP 101
96572: PUSH
96573: LD_EXP 100
96577: PUSH
96578: LD_EXP 102
96582: PUSH
96583: LD_EXP 99
96587: PUSH
96588: LD_EXP 103
96592: PUSH
96593: LD_EXP 104
96597: PUSH
96598: LD_EXP 105
96602: PUSH
96603: LD_EXP 106
96607: PUSH
96608: LD_EXP 107
96612: PUSH
96613: LD_EXP 108
96617: PUSH
96618: LD_EXP 109
96622: PUSH
96623: LD_EXP 110
96627: PUSH
96628: LD_EXP 111
96632: PUSH
96633: LD_EXP 112
96637: PUSH
96638: LD_EXP 120
96642: PUSH
96643: LD_EXP 121
96647: PUSH
96648: LD_EXP 122
96652: PUSH
96653: LD_EXP 123
96657: PUSH
96658: LD_EXP 125
96662: PUSH
96663: LD_EXP 126
96667: PUSH
96668: LD_EXP 127
96672: PUSH
96673: LD_EXP 130
96677: PUSH
96678: LD_EXP 132
96682: PUSH
96683: LD_EXP 133
96687: PUSH
96688: LD_EXP 134
96692: PUSH
96693: LD_EXP 136
96697: PUSH
96698: LD_EXP 137
96702: PUSH
96703: LD_EXP 140
96707: PUSH
96708: LD_EXP 141
96712: PUSH
96713: LD_EXP 142
96717: PUSH
96718: LD_EXP 143
96722: PUSH
96723: LD_EXP 144
96727: PUSH
96728: LD_EXP 145
96732: PUSH
96733: LD_EXP 146
96737: PUSH
96738: LD_EXP 147
96742: PUSH
96743: LD_EXP 148
96747: PUSH
96748: LD_EXP 113
96752: PUSH
96753: LD_EXP 114
96757: PUSH
96758: LD_EXP 117
96762: PUSH
96763: LD_EXP 118
96767: PUSH
96768: LD_EXP 119
96772: PUSH
96773: LD_EXP 115
96777: PUSH
96778: LD_EXP 116
96782: PUSH
96783: LD_EXP 124
96787: PUSH
96788: LD_EXP 128
96792: PUSH
96793: LD_EXP 129
96797: PUSH
96798: LD_EXP 131
96802: PUSH
96803: LD_EXP 135
96807: PUSH
96808: LD_EXP 138
96812: PUSH
96813: LD_EXP 139
96817: PUSH
96818: LD_EXP 149
96822: PUSH
96823: LD_EXP 150
96827: PUSH
96828: LD_EXP 151
96832: PUSH
96833: LD_EXP 152
96837: PUSH
96838: EMPTY
96839: LIST
96840: LIST
96841: LIST
96842: LIST
96843: LIST
96844: LIST
96845: LIST
96846: LIST
96847: LIST
96848: LIST
96849: LIST
96850: LIST
96851: LIST
96852: LIST
96853: LIST
96854: LIST
96855: LIST
96856: LIST
96857: LIST
96858: LIST
96859: LIST
96860: LIST
96861: LIST
96862: LIST
96863: LIST
96864: LIST
96865: LIST
96866: LIST
96867: LIST
96868: LIST
96869: LIST
96870: LIST
96871: LIST
96872: LIST
96873: LIST
96874: LIST
96875: LIST
96876: LIST
96877: LIST
96878: LIST
96879: LIST
96880: LIST
96881: LIST
96882: LIST
96883: LIST
96884: LIST
96885: LIST
96886: LIST
96887: LIST
96888: LIST
96889: LIST
96890: LIST
96891: LIST
96892: LIST
96893: ST_TO_ADDR
// tmp :=  ;
96894: LD_ADDR_VAR 0 3
96898: PUSH
96899: LD_STRING 
96901: ST_TO_ADDR
// for i = 1 to normalCounter do
96902: LD_ADDR_VAR 0 8
96906: PUSH
96907: DOUBLE
96908: LD_INT 1
96910: DEC
96911: ST_TO_ADDR
96912: LD_EXP 97
96916: PUSH
96917: FOR_TO
96918: IFFALSE 96954
// begin if flags [ i ] then
96920: LD_VAR 0 4
96924: PUSH
96925: LD_VAR 0 8
96929: ARRAY
96930: IFFALSE 96952
// tmp := tmp & i & ; ;
96932: LD_ADDR_VAR 0 3
96936: PUSH
96937: LD_VAR 0 3
96941: PUSH
96942: LD_VAR 0 8
96946: STR
96947: PUSH
96948: LD_STRING ;
96950: STR
96951: ST_TO_ADDR
// end ;
96952: GO 96917
96954: POP
96955: POP
// for i = 1 to hardcoreCounter do
96956: LD_ADDR_VAR 0 8
96960: PUSH
96961: DOUBLE
96962: LD_INT 1
96964: DEC
96965: ST_TO_ADDR
96966: LD_EXP 98
96970: PUSH
96971: FOR_TO
96972: IFFALSE 97018
// begin if flags [ normalCounter + i ] then
96974: LD_VAR 0 4
96978: PUSH
96979: LD_EXP 97
96983: PUSH
96984: LD_VAR 0 8
96988: PLUS
96989: ARRAY
96990: IFFALSE 97016
// tmp := tmp & ( 100 + i ) & ; ;
96992: LD_ADDR_VAR 0 3
96996: PUSH
96997: LD_VAR 0 3
97001: PUSH
97002: LD_INT 100
97004: PUSH
97005: LD_VAR 0 8
97009: PLUS
97010: STR
97011: PUSH
97012: LD_STRING ;
97014: STR
97015: ST_TO_ADDR
// end ;
97016: GO 96971
97018: POP
97019: POP
// if tmp then
97020: LD_VAR 0 3
97024: IFFALSE 97036
// active := tmp ;
97026: LD_ADDR_VAR 0 7
97030: PUSH
97031: LD_VAR 0 3
97035: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
97036: LD_STRING getStreamItemsFromMission("
97038: PUSH
97039: LD_VAR 0 5
97043: STR
97044: PUSH
97045: LD_STRING ","
97047: STR
97048: PUSH
97049: LD_VAR 0 6
97053: STR
97054: PUSH
97055: LD_STRING ","
97057: STR
97058: PUSH
97059: LD_VAR 0 7
97063: STR
97064: PUSH
97065: LD_STRING ")
97067: STR
97068: PPUSH
97069: CALL_OW 559
// end else
97073: GO 97082
// ToLua ( getStreamItemsFromMission("","","") ) ;
97075: LD_STRING getStreamItemsFromMission("","","")
97077: PPUSH
97078: CALL_OW 559
// end ;
97082: LD_VAR 0 2
97086: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
97087: LD_EXP 96
97091: PUSH
97092: LD_EXP 101
97096: AND
97097: IFFALSE 97221
97099: GO 97101
97101: DISABLE
97102: LD_INT 0
97104: PPUSH
97105: PPUSH
// begin enable ;
97106: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
97107: LD_ADDR_VAR 0 2
97111: PUSH
97112: LD_INT 22
97114: PUSH
97115: LD_OWVAR 2
97119: PUSH
97120: EMPTY
97121: LIST
97122: LIST
97123: PUSH
97124: LD_INT 2
97126: PUSH
97127: LD_INT 34
97129: PUSH
97130: LD_INT 7
97132: PUSH
97133: EMPTY
97134: LIST
97135: LIST
97136: PUSH
97137: LD_INT 34
97139: PUSH
97140: LD_INT 45
97142: PUSH
97143: EMPTY
97144: LIST
97145: LIST
97146: PUSH
97147: LD_INT 34
97149: PUSH
97150: LD_INT 28
97152: PUSH
97153: EMPTY
97154: LIST
97155: LIST
97156: PUSH
97157: LD_INT 34
97159: PUSH
97160: LD_INT 47
97162: PUSH
97163: EMPTY
97164: LIST
97165: LIST
97166: PUSH
97167: EMPTY
97168: LIST
97169: LIST
97170: LIST
97171: LIST
97172: LIST
97173: PUSH
97174: EMPTY
97175: LIST
97176: LIST
97177: PPUSH
97178: CALL_OW 69
97182: ST_TO_ADDR
// if not tmp then
97183: LD_VAR 0 2
97187: NOT
97188: IFFALSE 97192
// exit ;
97190: GO 97221
// for i in tmp do
97192: LD_ADDR_VAR 0 1
97196: PUSH
97197: LD_VAR 0 2
97201: PUSH
97202: FOR_IN
97203: IFFALSE 97219
// begin SetLives ( i , 0 ) ;
97205: LD_VAR 0 1
97209: PPUSH
97210: LD_INT 0
97212: PPUSH
97213: CALL_OW 234
// end ;
97217: GO 97202
97219: POP
97220: POP
// end ;
97221: PPOPN 2
97223: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
97224: LD_EXP 96
97228: PUSH
97229: LD_EXP 102
97233: AND
97234: IFFALSE 97318
97236: GO 97238
97238: DISABLE
97239: LD_INT 0
97241: PPUSH
97242: PPUSH
// begin enable ;
97243: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
97244: LD_ADDR_VAR 0 2
97248: PUSH
97249: LD_INT 22
97251: PUSH
97252: LD_OWVAR 2
97256: PUSH
97257: EMPTY
97258: LIST
97259: LIST
97260: PUSH
97261: LD_INT 32
97263: PUSH
97264: LD_INT 3
97266: PUSH
97267: EMPTY
97268: LIST
97269: LIST
97270: PUSH
97271: EMPTY
97272: LIST
97273: LIST
97274: PPUSH
97275: CALL_OW 69
97279: ST_TO_ADDR
// if not tmp then
97280: LD_VAR 0 2
97284: NOT
97285: IFFALSE 97289
// exit ;
97287: GO 97318
// for i in tmp do
97289: LD_ADDR_VAR 0 1
97293: PUSH
97294: LD_VAR 0 2
97298: PUSH
97299: FOR_IN
97300: IFFALSE 97316
// begin SetLives ( i , 0 ) ;
97302: LD_VAR 0 1
97306: PPUSH
97307: LD_INT 0
97309: PPUSH
97310: CALL_OW 234
// end ;
97314: GO 97299
97316: POP
97317: POP
// end ;
97318: PPOPN 2
97320: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
97321: LD_EXP 96
97325: PUSH
97326: LD_EXP 99
97330: AND
97331: IFFALSE 97424
97333: GO 97335
97335: DISABLE
97336: LD_INT 0
97338: PPUSH
// begin enable ;
97339: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
97340: LD_ADDR_VAR 0 1
97344: PUSH
97345: LD_INT 22
97347: PUSH
97348: LD_OWVAR 2
97352: PUSH
97353: EMPTY
97354: LIST
97355: LIST
97356: PUSH
97357: LD_INT 2
97359: PUSH
97360: LD_INT 25
97362: PUSH
97363: LD_INT 5
97365: PUSH
97366: EMPTY
97367: LIST
97368: LIST
97369: PUSH
97370: LD_INT 25
97372: PUSH
97373: LD_INT 9
97375: PUSH
97376: EMPTY
97377: LIST
97378: LIST
97379: PUSH
97380: LD_INT 25
97382: PUSH
97383: LD_INT 8
97385: PUSH
97386: EMPTY
97387: LIST
97388: LIST
97389: PUSH
97390: EMPTY
97391: LIST
97392: LIST
97393: LIST
97394: LIST
97395: PUSH
97396: EMPTY
97397: LIST
97398: LIST
97399: PPUSH
97400: CALL_OW 69
97404: PUSH
97405: FOR_IN
97406: IFFALSE 97422
// begin SetClass ( i , 1 ) ;
97408: LD_VAR 0 1
97412: PPUSH
97413: LD_INT 1
97415: PPUSH
97416: CALL_OW 336
// end ;
97420: GO 97405
97422: POP
97423: POP
// end ;
97424: PPOPN 1
97426: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
97427: LD_EXP 96
97431: PUSH
97432: LD_EXP 100
97436: AND
97437: PUSH
97438: LD_OWVAR 65
97442: PUSH
97443: LD_INT 7
97445: LESS
97446: AND
97447: IFFALSE 97461
97449: GO 97451
97451: DISABLE
// begin enable ;
97452: ENABLE
// game_speed := 7 ;
97453: LD_ADDR_OWVAR 65
97457: PUSH
97458: LD_INT 7
97460: ST_TO_ADDR
// end ;
97461: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
97462: LD_EXP 96
97466: PUSH
97467: LD_EXP 103
97471: AND
97472: IFFALSE 97674
97474: GO 97476
97476: DISABLE
97477: LD_INT 0
97479: PPUSH
97480: PPUSH
97481: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
97482: LD_ADDR_VAR 0 3
97486: PUSH
97487: LD_INT 81
97489: PUSH
97490: LD_OWVAR 2
97494: PUSH
97495: EMPTY
97496: LIST
97497: LIST
97498: PUSH
97499: LD_INT 21
97501: PUSH
97502: LD_INT 1
97504: PUSH
97505: EMPTY
97506: LIST
97507: LIST
97508: PUSH
97509: EMPTY
97510: LIST
97511: LIST
97512: PPUSH
97513: CALL_OW 69
97517: ST_TO_ADDR
// if not tmp then
97518: LD_VAR 0 3
97522: NOT
97523: IFFALSE 97527
// exit ;
97525: GO 97674
// if tmp > 5 then
97527: LD_VAR 0 3
97531: PUSH
97532: LD_INT 5
97534: GREATER
97535: IFFALSE 97547
// k := 5 else
97537: LD_ADDR_VAR 0 2
97541: PUSH
97542: LD_INT 5
97544: ST_TO_ADDR
97545: GO 97557
// k := tmp ;
97547: LD_ADDR_VAR 0 2
97551: PUSH
97552: LD_VAR 0 3
97556: ST_TO_ADDR
// for i := 1 to k do
97557: LD_ADDR_VAR 0 1
97561: PUSH
97562: DOUBLE
97563: LD_INT 1
97565: DEC
97566: ST_TO_ADDR
97567: LD_VAR 0 2
97571: PUSH
97572: FOR_TO
97573: IFFALSE 97672
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
97575: LD_VAR 0 3
97579: PUSH
97580: LD_VAR 0 1
97584: ARRAY
97585: PPUSH
97586: LD_VAR 0 1
97590: PUSH
97591: LD_INT 4
97593: MOD
97594: PUSH
97595: LD_INT 1
97597: PLUS
97598: PPUSH
97599: CALL_OW 259
97603: PUSH
97604: LD_INT 10
97606: LESS
97607: IFFALSE 97670
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
97609: LD_VAR 0 3
97613: PUSH
97614: LD_VAR 0 1
97618: ARRAY
97619: PPUSH
97620: LD_VAR 0 1
97624: PUSH
97625: LD_INT 4
97627: MOD
97628: PUSH
97629: LD_INT 1
97631: PLUS
97632: PPUSH
97633: LD_VAR 0 3
97637: PUSH
97638: LD_VAR 0 1
97642: ARRAY
97643: PPUSH
97644: LD_VAR 0 1
97648: PUSH
97649: LD_INT 4
97651: MOD
97652: PUSH
97653: LD_INT 1
97655: PLUS
97656: PPUSH
97657: CALL_OW 259
97661: PUSH
97662: LD_INT 1
97664: PLUS
97665: PPUSH
97666: CALL_OW 237
97670: GO 97572
97672: POP
97673: POP
// end ;
97674: PPOPN 3
97676: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
97677: LD_EXP 96
97681: PUSH
97682: LD_EXP 104
97686: AND
97687: IFFALSE 97707
97689: GO 97691
97691: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
97692: LD_INT 4
97694: PPUSH
97695: LD_OWVAR 2
97699: PPUSH
97700: LD_INT 0
97702: PPUSH
97703: CALL_OW 324
97707: END
// every 0 0$1 trigger StreamModeActive and sShovel do
97708: LD_EXP 96
97712: PUSH
97713: LD_EXP 133
97717: AND
97718: IFFALSE 97738
97720: GO 97722
97722: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
97723: LD_INT 19
97725: PPUSH
97726: LD_OWVAR 2
97730: PPUSH
97731: LD_INT 0
97733: PPUSH
97734: CALL_OW 324
97738: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
97739: LD_EXP 96
97743: PUSH
97744: LD_EXP 105
97748: AND
97749: IFFALSE 97851
97751: GO 97753
97753: DISABLE
97754: LD_INT 0
97756: PPUSH
97757: PPUSH
// begin enable ;
97758: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
97759: LD_ADDR_VAR 0 2
97763: PUSH
97764: LD_INT 22
97766: PUSH
97767: LD_OWVAR 2
97771: PUSH
97772: EMPTY
97773: LIST
97774: LIST
97775: PUSH
97776: LD_INT 2
97778: PUSH
97779: LD_INT 34
97781: PUSH
97782: LD_INT 11
97784: PUSH
97785: EMPTY
97786: LIST
97787: LIST
97788: PUSH
97789: LD_INT 34
97791: PUSH
97792: LD_INT 30
97794: PUSH
97795: EMPTY
97796: LIST
97797: LIST
97798: PUSH
97799: EMPTY
97800: LIST
97801: LIST
97802: LIST
97803: PUSH
97804: EMPTY
97805: LIST
97806: LIST
97807: PPUSH
97808: CALL_OW 69
97812: ST_TO_ADDR
// if not tmp then
97813: LD_VAR 0 2
97817: NOT
97818: IFFALSE 97822
// exit ;
97820: GO 97851
// for i in tmp do
97822: LD_ADDR_VAR 0 1
97826: PUSH
97827: LD_VAR 0 2
97831: PUSH
97832: FOR_IN
97833: IFFALSE 97849
// begin SetLives ( i , 0 ) ;
97835: LD_VAR 0 1
97839: PPUSH
97840: LD_INT 0
97842: PPUSH
97843: CALL_OW 234
// end ;
97847: GO 97832
97849: POP
97850: POP
// end ;
97851: PPOPN 2
97853: END
// every 0 0$1 trigger StreamModeActive and sBunker do
97854: LD_EXP 96
97858: PUSH
97859: LD_EXP 106
97863: AND
97864: IFFALSE 97884
97866: GO 97868
97868: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
97869: LD_INT 32
97871: PPUSH
97872: LD_OWVAR 2
97876: PPUSH
97877: LD_INT 0
97879: PPUSH
97880: CALL_OW 324
97884: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
97885: LD_EXP 96
97889: PUSH
97890: LD_EXP 107
97894: AND
97895: IFFALSE 98076
97897: GO 97899
97899: DISABLE
97900: LD_INT 0
97902: PPUSH
97903: PPUSH
97904: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
97905: LD_ADDR_VAR 0 2
97909: PUSH
97910: LD_INT 22
97912: PUSH
97913: LD_OWVAR 2
97917: PUSH
97918: EMPTY
97919: LIST
97920: LIST
97921: PUSH
97922: LD_INT 33
97924: PUSH
97925: LD_INT 3
97927: PUSH
97928: EMPTY
97929: LIST
97930: LIST
97931: PUSH
97932: EMPTY
97933: LIST
97934: LIST
97935: PPUSH
97936: CALL_OW 69
97940: ST_TO_ADDR
// if not tmp then
97941: LD_VAR 0 2
97945: NOT
97946: IFFALSE 97950
// exit ;
97948: GO 98076
// side := 0 ;
97950: LD_ADDR_VAR 0 3
97954: PUSH
97955: LD_INT 0
97957: ST_TO_ADDR
// for i := 1 to 8 do
97958: LD_ADDR_VAR 0 1
97962: PUSH
97963: DOUBLE
97964: LD_INT 1
97966: DEC
97967: ST_TO_ADDR
97968: LD_INT 8
97970: PUSH
97971: FOR_TO
97972: IFFALSE 98020
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
97974: LD_OWVAR 2
97978: PUSH
97979: LD_VAR 0 1
97983: NONEQUAL
97984: PUSH
97985: LD_OWVAR 2
97989: PPUSH
97990: LD_VAR 0 1
97994: PPUSH
97995: CALL_OW 81
97999: PUSH
98000: LD_INT 2
98002: EQUAL
98003: AND
98004: IFFALSE 98018
// begin side := i ;
98006: LD_ADDR_VAR 0 3
98010: PUSH
98011: LD_VAR 0 1
98015: ST_TO_ADDR
// break ;
98016: GO 98020
// end ;
98018: GO 97971
98020: POP
98021: POP
// if not side then
98022: LD_VAR 0 3
98026: NOT
98027: IFFALSE 98031
// exit ;
98029: GO 98076
// for i := 1 to tmp do
98031: LD_ADDR_VAR 0 1
98035: PUSH
98036: DOUBLE
98037: LD_INT 1
98039: DEC
98040: ST_TO_ADDR
98041: LD_VAR 0 2
98045: PUSH
98046: FOR_TO
98047: IFFALSE 98074
// if Prob ( 60 ) then
98049: LD_INT 60
98051: PPUSH
98052: CALL_OW 13
98056: IFFALSE 98072
// SetSide ( i , side ) ;
98058: LD_VAR 0 1
98062: PPUSH
98063: LD_VAR 0 3
98067: PPUSH
98068: CALL_OW 235
98072: GO 98046
98074: POP
98075: POP
// end ;
98076: PPOPN 3
98078: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
98079: LD_EXP 96
98083: PUSH
98084: LD_EXP 109
98088: AND
98089: IFFALSE 98208
98091: GO 98093
98093: DISABLE
98094: LD_INT 0
98096: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
98097: LD_ADDR_VAR 0 1
98101: PUSH
98102: LD_INT 22
98104: PUSH
98105: LD_OWVAR 2
98109: PUSH
98110: EMPTY
98111: LIST
98112: LIST
98113: PUSH
98114: LD_INT 21
98116: PUSH
98117: LD_INT 1
98119: PUSH
98120: EMPTY
98121: LIST
98122: LIST
98123: PUSH
98124: LD_INT 3
98126: PUSH
98127: LD_INT 23
98129: PUSH
98130: LD_INT 0
98132: PUSH
98133: EMPTY
98134: LIST
98135: LIST
98136: PUSH
98137: EMPTY
98138: LIST
98139: LIST
98140: PUSH
98141: EMPTY
98142: LIST
98143: LIST
98144: LIST
98145: PPUSH
98146: CALL_OW 69
98150: PUSH
98151: FOR_IN
98152: IFFALSE 98206
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
98154: LD_VAR 0 1
98158: PPUSH
98159: CALL_OW 257
98163: PUSH
98164: LD_INT 1
98166: PUSH
98167: LD_INT 2
98169: PUSH
98170: LD_INT 3
98172: PUSH
98173: LD_INT 4
98175: PUSH
98176: EMPTY
98177: LIST
98178: LIST
98179: LIST
98180: LIST
98181: IN
98182: IFFALSE 98204
// SetClass ( un , rand ( 1 , 4 ) ) ;
98184: LD_VAR 0 1
98188: PPUSH
98189: LD_INT 1
98191: PPUSH
98192: LD_INT 4
98194: PPUSH
98195: CALL_OW 12
98199: PPUSH
98200: CALL_OW 336
98204: GO 98151
98206: POP
98207: POP
// end ;
98208: PPOPN 1
98210: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
98211: LD_EXP 96
98215: PUSH
98216: LD_EXP 108
98220: AND
98221: IFFALSE 98300
98223: GO 98225
98225: DISABLE
98226: LD_INT 0
98228: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
98229: LD_ADDR_VAR 0 1
98233: PUSH
98234: LD_INT 22
98236: PUSH
98237: LD_OWVAR 2
98241: PUSH
98242: EMPTY
98243: LIST
98244: LIST
98245: PUSH
98246: LD_INT 21
98248: PUSH
98249: LD_INT 3
98251: PUSH
98252: EMPTY
98253: LIST
98254: LIST
98255: PUSH
98256: EMPTY
98257: LIST
98258: LIST
98259: PPUSH
98260: CALL_OW 69
98264: ST_TO_ADDR
// if not tmp then
98265: LD_VAR 0 1
98269: NOT
98270: IFFALSE 98274
// exit ;
98272: GO 98300
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
98274: LD_VAR 0 1
98278: PUSH
98279: LD_INT 1
98281: PPUSH
98282: LD_VAR 0 1
98286: PPUSH
98287: CALL_OW 12
98291: ARRAY
98292: PPUSH
98293: LD_INT 100
98295: PPUSH
98296: CALL_OW 234
// end ;
98300: PPOPN 1
98302: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
98303: LD_EXP 96
98307: PUSH
98308: LD_EXP 110
98312: AND
98313: IFFALSE 98411
98315: GO 98317
98317: DISABLE
98318: LD_INT 0
98320: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
98321: LD_ADDR_VAR 0 1
98325: PUSH
98326: LD_INT 22
98328: PUSH
98329: LD_OWVAR 2
98333: PUSH
98334: EMPTY
98335: LIST
98336: LIST
98337: PUSH
98338: LD_INT 21
98340: PUSH
98341: LD_INT 1
98343: PUSH
98344: EMPTY
98345: LIST
98346: LIST
98347: PUSH
98348: EMPTY
98349: LIST
98350: LIST
98351: PPUSH
98352: CALL_OW 69
98356: ST_TO_ADDR
// if not tmp then
98357: LD_VAR 0 1
98361: NOT
98362: IFFALSE 98366
// exit ;
98364: GO 98411
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
98366: LD_VAR 0 1
98370: PUSH
98371: LD_INT 1
98373: PPUSH
98374: LD_VAR 0 1
98378: PPUSH
98379: CALL_OW 12
98383: ARRAY
98384: PPUSH
98385: LD_INT 1
98387: PPUSH
98388: LD_INT 4
98390: PPUSH
98391: CALL_OW 12
98395: PPUSH
98396: LD_INT 3000
98398: PPUSH
98399: LD_INT 9000
98401: PPUSH
98402: CALL_OW 12
98406: PPUSH
98407: CALL_OW 492
// end ;
98411: PPOPN 1
98413: END
// every 0 0$1 trigger StreamModeActive and sDepot do
98414: LD_EXP 96
98418: PUSH
98419: LD_EXP 111
98423: AND
98424: IFFALSE 98444
98426: GO 98428
98428: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
98429: LD_INT 1
98431: PPUSH
98432: LD_OWVAR 2
98436: PPUSH
98437: LD_INT 0
98439: PPUSH
98440: CALL_OW 324
98444: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
98445: LD_EXP 96
98449: PUSH
98450: LD_EXP 112
98454: AND
98455: IFFALSE 98538
98457: GO 98459
98459: DISABLE
98460: LD_INT 0
98462: PPUSH
98463: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
98464: LD_ADDR_VAR 0 2
98468: PUSH
98469: LD_INT 22
98471: PUSH
98472: LD_OWVAR 2
98476: PUSH
98477: EMPTY
98478: LIST
98479: LIST
98480: PUSH
98481: LD_INT 21
98483: PUSH
98484: LD_INT 3
98486: PUSH
98487: EMPTY
98488: LIST
98489: LIST
98490: PUSH
98491: EMPTY
98492: LIST
98493: LIST
98494: PPUSH
98495: CALL_OW 69
98499: ST_TO_ADDR
// if not tmp then
98500: LD_VAR 0 2
98504: NOT
98505: IFFALSE 98509
// exit ;
98507: GO 98538
// for i in tmp do
98509: LD_ADDR_VAR 0 1
98513: PUSH
98514: LD_VAR 0 2
98518: PUSH
98519: FOR_IN
98520: IFFALSE 98536
// SetBLevel ( i , 10 ) ;
98522: LD_VAR 0 1
98526: PPUSH
98527: LD_INT 10
98529: PPUSH
98530: CALL_OW 241
98534: GO 98519
98536: POP
98537: POP
// end ;
98538: PPOPN 2
98540: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
98541: LD_EXP 96
98545: PUSH
98546: LD_EXP 113
98550: AND
98551: IFFALSE 98662
98553: GO 98555
98555: DISABLE
98556: LD_INT 0
98558: PPUSH
98559: PPUSH
98560: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
98561: LD_ADDR_VAR 0 3
98565: PUSH
98566: LD_INT 22
98568: PUSH
98569: LD_OWVAR 2
98573: PUSH
98574: EMPTY
98575: LIST
98576: LIST
98577: PUSH
98578: LD_INT 25
98580: PUSH
98581: LD_INT 1
98583: PUSH
98584: EMPTY
98585: LIST
98586: LIST
98587: PUSH
98588: EMPTY
98589: LIST
98590: LIST
98591: PPUSH
98592: CALL_OW 69
98596: ST_TO_ADDR
// if not tmp then
98597: LD_VAR 0 3
98601: NOT
98602: IFFALSE 98606
// exit ;
98604: GO 98662
// un := tmp [ rand ( 1 , tmp ) ] ;
98606: LD_ADDR_VAR 0 2
98610: PUSH
98611: LD_VAR 0 3
98615: PUSH
98616: LD_INT 1
98618: PPUSH
98619: LD_VAR 0 3
98623: PPUSH
98624: CALL_OW 12
98628: ARRAY
98629: ST_TO_ADDR
// if Crawls ( un ) then
98630: LD_VAR 0 2
98634: PPUSH
98635: CALL_OW 318
98639: IFFALSE 98650
// ComWalk ( un ) ;
98641: LD_VAR 0 2
98645: PPUSH
98646: CALL_OW 138
// SetClass ( un , class_sniper ) ;
98650: LD_VAR 0 2
98654: PPUSH
98655: LD_INT 5
98657: PPUSH
98658: CALL_OW 336
// end ;
98662: PPOPN 3
98664: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
98665: LD_EXP 96
98669: PUSH
98670: LD_EXP 114
98674: AND
98675: PUSH
98676: LD_OWVAR 67
98680: PUSH
98681: LD_INT 4
98683: LESS
98684: AND
98685: IFFALSE 98704
98687: GO 98689
98689: DISABLE
// begin Difficulty := Difficulty + 1 ;
98690: LD_ADDR_OWVAR 67
98694: PUSH
98695: LD_OWVAR 67
98699: PUSH
98700: LD_INT 1
98702: PLUS
98703: ST_TO_ADDR
// end ;
98704: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
98705: LD_EXP 96
98709: PUSH
98710: LD_EXP 115
98714: AND
98715: IFFALSE 98818
98717: GO 98719
98719: DISABLE
98720: LD_INT 0
98722: PPUSH
// begin for i := 1 to 5 do
98723: LD_ADDR_VAR 0 1
98727: PUSH
98728: DOUBLE
98729: LD_INT 1
98731: DEC
98732: ST_TO_ADDR
98733: LD_INT 5
98735: PUSH
98736: FOR_TO
98737: IFFALSE 98816
// begin uc_nation := nation_nature ;
98739: LD_ADDR_OWVAR 21
98743: PUSH
98744: LD_INT 0
98746: ST_TO_ADDR
// uc_side := 0 ;
98747: LD_ADDR_OWVAR 20
98751: PUSH
98752: LD_INT 0
98754: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
98755: LD_ADDR_OWVAR 29
98759: PUSH
98760: LD_INT 12
98762: PUSH
98763: LD_INT 12
98765: PUSH
98766: EMPTY
98767: LIST
98768: LIST
98769: ST_TO_ADDR
// hc_agressivity := 20 ;
98770: LD_ADDR_OWVAR 35
98774: PUSH
98775: LD_INT 20
98777: ST_TO_ADDR
// hc_class := class_tiger ;
98778: LD_ADDR_OWVAR 28
98782: PUSH
98783: LD_INT 14
98785: ST_TO_ADDR
// hc_gallery :=  ;
98786: LD_ADDR_OWVAR 33
98790: PUSH
98791: LD_STRING 
98793: ST_TO_ADDR
// hc_name :=  ;
98794: LD_ADDR_OWVAR 26
98798: PUSH
98799: LD_STRING 
98801: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
98802: CALL_OW 44
98806: PPUSH
98807: LD_INT 0
98809: PPUSH
98810: CALL_OW 51
// end ;
98814: GO 98736
98816: POP
98817: POP
// end ;
98818: PPOPN 1
98820: END
// every 0 0$1 trigger StreamModeActive and sBomb do
98821: LD_EXP 96
98825: PUSH
98826: LD_EXP 116
98830: AND
98831: IFFALSE 98840
98833: GO 98835
98835: DISABLE
// StreamSibBomb ;
98836: CALL 98841 0 0
98840: END
// export function StreamSibBomb ; var i , x , y ; begin
98841: LD_INT 0
98843: PPUSH
98844: PPUSH
98845: PPUSH
98846: PPUSH
// result := false ;
98847: LD_ADDR_VAR 0 1
98851: PUSH
98852: LD_INT 0
98854: ST_TO_ADDR
// for i := 1 to 16 do
98855: LD_ADDR_VAR 0 2
98859: PUSH
98860: DOUBLE
98861: LD_INT 1
98863: DEC
98864: ST_TO_ADDR
98865: LD_INT 16
98867: PUSH
98868: FOR_TO
98869: IFFALSE 99068
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
98871: LD_ADDR_VAR 0 3
98875: PUSH
98876: LD_INT 10
98878: PUSH
98879: LD_INT 20
98881: PUSH
98882: LD_INT 30
98884: PUSH
98885: LD_INT 40
98887: PUSH
98888: LD_INT 50
98890: PUSH
98891: LD_INT 60
98893: PUSH
98894: LD_INT 70
98896: PUSH
98897: LD_INT 80
98899: PUSH
98900: LD_INT 90
98902: PUSH
98903: LD_INT 100
98905: PUSH
98906: LD_INT 110
98908: PUSH
98909: LD_INT 120
98911: PUSH
98912: LD_INT 130
98914: PUSH
98915: LD_INT 140
98917: PUSH
98918: LD_INT 150
98920: PUSH
98921: EMPTY
98922: LIST
98923: LIST
98924: LIST
98925: LIST
98926: LIST
98927: LIST
98928: LIST
98929: LIST
98930: LIST
98931: LIST
98932: LIST
98933: LIST
98934: LIST
98935: LIST
98936: LIST
98937: PUSH
98938: LD_INT 1
98940: PPUSH
98941: LD_INT 15
98943: PPUSH
98944: CALL_OW 12
98948: ARRAY
98949: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
98950: LD_ADDR_VAR 0 4
98954: PUSH
98955: LD_INT 10
98957: PUSH
98958: LD_INT 20
98960: PUSH
98961: LD_INT 30
98963: PUSH
98964: LD_INT 40
98966: PUSH
98967: LD_INT 50
98969: PUSH
98970: LD_INT 60
98972: PUSH
98973: LD_INT 70
98975: PUSH
98976: LD_INT 80
98978: PUSH
98979: LD_INT 90
98981: PUSH
98982: LD_INT 100
98984: PUSH
98985: LD_INT 110
98987: PUSH
98988: LD_INT 120
98990: PUSH
98991: LD_INT 130
98993: PUSH
98994: LD_INT 140
98996: PUSH
98997: LD_INT 150
98999: PUSH
99000: EMPTY
99001: LIST
99002: LIST
99003: LIST
99004: LIST
99005: LIST
99006: LIST
99007: LIST
99008: LIST
99009: LIST
99010: LIST
99011: LIST
99012: LIST
99013: LIST
99014: LIST
99015: LIST
99016: PUSH
99017: LD_INT 1
99019: PPUSH
99020: LD_INT 15
99022: PPUSH
99023: CALL_OW 12
99027: ARRAY
99028: ST_TO_ADDR
// if ValidHex ( x , y ) then
99029: LD_VAR 0 3
99033: PPUSH
99034: LD_VAR 0 4
99038: PPUSH
99039: CALL_OW 488
99043: IFFALSE 99066
// begin result := [ x , y ] ;
99045: LD_ADDR_VAR 0 1
99049: PUSH
99050: LD_VAR 0 3
99054: PUSH
99055: LD_VAR 0 4
99059: PUSH
99060: EMPTY
99061: LIST
99062: LIST
99063: ST_TO_ADDR
// break ;
99064: GO 99068
// end ; end ;
99066: GO 98868
99068: POP
99069: POP
// if result then
99070: LD_VAR 0 1
99074: IFFALSE 99134
// begin ToLua ( playSibBomb() ) ;
99076: LD_STRING playSibBomb()
99078: PPUSH
99079: CALL_OW 559
// wait ( 0 0$14 ) ;
99083: LD_INT 490
99085: PPUSH
99086: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
99090: LD_VAR 0 1
99094: PUSH
99095: LD_INT 1
99097: ARRAY
99098: PPUSH
99099: LD_VAR 0 1
99103: PUSH
99104: LD_INT 2
99106: ARRAY
99107: PPUSH
99108: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
99112: LD_VAR 0 1
99116: PUSH
99117: LD_INT 1
99119: ARRAY
99120: PPUSH
99121: LD_VAR 0 1
99125: PUSH
99126: LD_INT 2
99128: ARRAY
99129: PPUSH
99130: CALL_OW 429
// end ; end ;
99134: LD_VAR 0 1
99138: RET
// every 0 0$1 trigger StreamModeActive and sReset do
99139: LD_EXP 96
99143: PUSH
99144: LD_EXP 118
99148: AND
99149: IFFALSE 99161
99151: GO 99153
99153: DISABLE
// YouLost (  ) ;
99154: LD_STRING 
99156: PPUSH
99157: CALL_OW 104
99161: END
// every 0 0$1 trigger StreamModeActive and sFog do
99162: LD_EXP 96
99166: PUSH
99167: LD_EXP 117
99171: AND
99172: IFFALSE 99186
99174: GO 99176
99176: DISABLE
// FogOff ( your_side ) ;
99177: LD_OWVAR 2
99181: PPUSH
99182: CALL_OW 344
99186: END
// every 0 0$1 trigger StreamModeActive and sSun do
99187: LD_EXP 96
99191: PUSH
99192: LD_EXP 119
99196: AND
99197: IFFALSE 99225
99199: GO 99201
99201: DISABLE
// begin solar_recharge_percent := 0 ;
99202: LD_ADDR_OWVAR 79
99206: PUSH
99207: LD_INT 0
99209: ST_TO_ADDR
// wait ( 5 5$00 ) ;
99210: LD_INT 10500
99212: PPUSH
99213: CALL_OW 67
// solar_recharge_percent := 100 ;
99217: LD_ADDR_OWVAR 79
99221: PUSH
99222: LD_INT 100
99224: ST_TO_ADDR
// end ;
99225: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
99226: LD_EXP 96
99230: PUSH
99231: LD_EXP 120
99235: AND
99236: IFFALSE 99475
99238: GO 99240
99240: DISABLE
99241: LD_INT 0
99243: PPUSH
99244: PPUSH
99245: PPUSH
// begin tmp := [ ] ;
99246: LD_ADDR_VAR 0 3
99250: PUSH
99251: EMPTY
99252: ST_TO_ADDR
// for i := 1 to 6 do
99253: LD_ADDR_VAR 0 1
99257: PUSH
99258: DOUBLE
99259: LD_INT 1
99261: DEC
99262: ST_TO_ADDR
99263: LD_INT 6
99265: PUSH
99266: FOR_TO
99267: IFFALSE 99372
// begin uc_nation := nation_nature ;
99269: LD_ADDR_OWVAR 21
99273: PUSH
99274: LD_INT 0
99276: ST_TO_ADDR
// uc_side := 0 ;
99277: LD_ADDR_OWVAR 20
99281: PUSH
99282: LD_INT 0
99284: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
99285: LD_ADDR_OWVAR 29
99289: PUSH
99290: LD_INT 12
99292: PUSH
99293: LD_INT 12
99295: PUSH
99296: EMPTY
99297: LIST
99298: LIST
99299: ST_TO_ADDR
// hc_agressivity := 20 ;
99300: LD_ADDR_OWVAR 35
99304: PUSH
99305: LD_INT 20
99307: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
99308: LD_ADDR_OWVAR 28
99312: PUSH
99313: LD_INT 17
99315: ST_TO_ADDR
// hc_gallery :=  ;
99316: LD_ADDR_OWVAR 33
99320: PUSH
99321: LD_STRING 
99323: ST_TO_ADDR
// hc_name :=  ;
99324: LD_ADDR_OWVAR 26
99328: PUSH
99329: LD_STRING 
99331: ST_TO_ADDR
// un := CreateHuman ;
99332: LD_ADDR_VAR 0 2
99336: PUSH
99337: CALL_OW 44
99341: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
99342: LD_VAR 0 2
99346: PPUSH
99347: LD_INT 1
99349: PPUSH
99350: CALL_OW 51
// tmp := tmp ^ un ;
99354: LD_ADDR_VAR 0 3
99358: PUSH
99359: LD_VAR 0 3
99363: PUSH
99364: LD_VAR 0 2
99368: ADD
99369: ST_TO_ADDR
// end ;
99370: GO 99266
99372: POP
99373: POP
// repeat wait ( 0 0$1 ) ;
99374: LD_INT 35
99376: PPUSH
99377: CALL_OW 67
// for un in tmp do
99381: LD_ADDR_VAR 0 2
99385: PUSH
99386: LD_VAR 0 3
99390: PUSH
99391: FOR_IN
99392: IFFALSE 99466
// begin if IsDead ( un ) then
99394: LD_VAR 0 2
99398: PPUSH
99399: CALL_OW 301
99403: IFFALSE 99423
// begin tmp := tmp diff un ;
99405: LD_ADDR_VAR 0 3
99409: PUSH
99410: LD_VAR 0 3
99414: PUSH
99415: LD_VAR 0 2
99419: DIFF
99420: ST_TO_ADDR
// continue ;
99421: GO 99391
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
99423: LD_VAR 0 2
99427: PPUSH
99428: LD_INT 3
99430: PUSH
99431: LD_INT 22
99433: PUSH
99434: LD_INT 0
99436: PUSH
99437: EMPTY
99438: LIST
99439: LIST
99440: PUSH
99441: EMPTY
99442: LIST
99443: LIST
99444: PPUSH
99445: CALL_OW 69
99449: PPUSH
99450: LD_VAR 0 2
99454: PPUSH
99455: CALL_OW 74
99459: PPUSH
99460: CALL_OW 115
// end ;
99464: GO 99391
99466: POP
99467: POP
// until not tmp ;
99468: LD_VAR 0 3
99472: NOT
99473: IFFALSE 99374
// end ;
99475: PPOPN 3
99477: END
// every 0 0$1 trigger StreamModeActive and sTroll do
99478: LD_EXP 96
99482: PUSH
99483: LD_EXP 121
99487: AND
99488: IFFALSE 99542
99490: GO 99492
99492: DISABLE
// begin ToLua ( displayTroll(); ) ;
99493: LD_STRING displayTroll();
99495: PPUSH
99496: CALL_OW 559
// wait ( 3 3$00 ) ;
99500: LD_INT 6300
99502: PPUSH
99503: CALL_OW 67
// ToLua ( hideTroll(); ) ;
99507: LD_STRING hideTroll();
99509: PPUSH
99510: CALL_OW 559
// wait ( 1 1$00 ) ;
99514: LD_INT 2100
99516: PPUSH
99517: CALL_OW 67
// ToLua ( displayTroll(); ) ;
99521: LD_STRING displayTroll();
99523: PPUSH
99524: CALL_OW 559
// wait ( 1 1$00 ) ;
99528: LD_INT 2100
99530: PPUSH
99531: CALL_OW 67
// ToLua ( hideTroll(); ) ;
99535: LD_STRING hideTroll();
99537: PPUSH
99538: CALL_OW 559
// end ;
99542: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
99543: LD_EXP 96
99547: PUSH
99548: LD_EXP 122
99552: AND
99553: IFFALSE 99616
99555: GO 99557
99557: DISABLE
99558: LD_INT 0
99560: PPUSH
// begin p := 0 ;
99561: LD_ADDR_VAR 0 1
99565: PUSH
99566: LD_INT 0
99568: ST_TO_ADDR
// repeat game_speed := 1 ;
99569: LD_ADDR_OWVAR 65
99573: PUSH
99574: LD_INT 1
99576: ST_TO_ADDR
// wait ( 0 0$1 ) ;
99577: LD_INT 35
99579: PPUSH
99580: CALL_OW 67
// p := p + 1 ;
99584: LD_ADDR_VAR 0 1
99588: PUSH
99589: LD_VAR 0 1
99593: PUSH
99594: LD_INT 1
99596: PLUS
99597: ST_TO_ADDR
// until p >= 60 ;
99598: LD_VAR 0 1
99602: PUSH
99603: LD_INT 60
99605: GREATEREQUAL
99606: IFFALSE 99569
// game_speed := 4 ;
99608: LD_ADDR_OWVAR 65
99612: PUSH
99613: LD_INT 4
99615: ST_TO_ADDR
// end ;
99616: PPOPN 1
99618: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
99619: LD_EXP 96
99623: PUSH
99624: LD_EXP 123
99628: AND
99629: IFFALSE 99775
99631: GO 99633
99633: DISABLE
99634: LD_INT 0
99636: PPUSH
99637: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
99638: LD_ADDR_VAR 0 1
99642: PUSH
99643: LD_INT 22
99645: PUSH
99646: LD_OWVAR 2
99650: PUSH
99651: EMPTY
99652: LIST
99653: LIST
99654: PUSH
99655: LD_INT 2
99657: PUSH
99658: LD_INT 30
99660: PUSH
99661: LD_INT 0
99663: PUSH
99664: EMPTY
99665: LIST
99666: LIST
99667: PUSH
99668: LD_INT 30
99670: PUSH
99671: LD_INT 1
99673: PUSH
99674: EMPTY
99675: LIST
99676: LIST
99677: PUSH
99678: EMPTY
99679: LIST
99680: LIST
99681: LIST
99682: PUSH
99683: EMPTY
99684: LIST
99685: LIST
99686: PPUSH
99687: CALL_OW 69
99691: ST_TO_ADDR
// if not depot then
99692: LD_VAR 0 1
99696: NOT
99697: IFFALSE 99701
// exit ;
99699: GO 99775
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
99701: LD_ADDR_VAR 0 2
99705: PUSH
99706: LD_VAR 0 1
99710: PUSH
99711: LD_INT 1
99713: PPUSH
99714: LD_VAR 0 1
99718: PPUSH
99719: CALL_OW 12
99723: ARRAY
99724: PPUSH
99725: CALL_OW 274
99729: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
99730: LD_VAR 0 2
99734: PPUSH
99735: LD_INT 1
99737: PPUSH
99738: LD_INT 0
99740: PPUSH
99741: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
99745: LD_VAR 0 2
99749: PPUSH
99750: LD_INT 2
99752: PPUSH
99753: LD_INT 0
99755: PPUSH
99756: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
99760: LD_VAR 0 2
99764: PPUSH
99765: LD_INT 3
99767: PPUSH
99768: LD_INT 0
99770: PPUSH
99771: CALL_OW 277
// end ;
99775: PPOPN 2
99777: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
99778: LD_EXP 96
99782: PUSH
99783: LD_EXP 124
99787: AND
99788: IFFALSE 99885
99790: GO 99792
99792: DISABLE
99793: LD_INT 0
99795: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
99796: LD_ADDR_VAR 0 1
99800: PUSH
99801: LD_INT 22
99803: PUSH
99804: LD_OWVAR 2
99808: PUSH
99809: EMPTY
99810: LIST
99811: LIST
99812: PUSH
99813: LD_INT 21
99815: PUSH
99816: LD_INT 1
99818: PUSH
99819: EMPTY
99820: LIST
99821: LIST
99822: PUSH
99823: LD_INT 3
99825: PUSH
99826: LD_INT 23
99828: PUSH
99829: LD_INT 0
99831: PUSH
99832: EMPTY
99833: LIST
99834: LIST
99835: PUSH
99836: EMPTY
99837: LIST
99838: LIST
99839: PUSH
99840: EMPTY
99841: LIST
99842: LIST
99843: LIST
99844: PPUSH
99845: CALL_OW 69
99849: ST_TO_ADDR
// if not tmp then
99850: LD_VAR 0 1
99854: NOT
99855: IFFALSE 99859
// exit ;
99857: GO 99885
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
99859: LD_VAR 0 1
99863: PUSH
99864: LD_INT 1
99866: PPUSH
99867: LD_VAR 0 1
99871: PPUSH
99872: CALL_OW 12
99876: ARRAY
99877: PPUSH
99878: LD_INT 200
99880: PPUSH
99881: CALL_OW 234
// end ;
99885: PPOPN 1
99887: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
99888: LD_EXP 96
99892: PUSH
99893: LD_EXP 125
99897: AND
99898: IFFALSE 99977
99900: GO 99902
99902: DISABLE
99903: LD_INT 0
99905: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
99906: LD_ADDR_VAR 0 1
99910: PUSH
99911: LD_INT 22
99913: PUSH
99914: LD_OWVAR 2
99918: PUSH
99919: EMPTY
99920: LIST
99921: LIST
99922: PUSH
99923: LD_INT 21
99925: PUSH
99926: LD_INT 2
99928: PUSH
99929: EMPTY
99930: LIST
99931: LIST
99932: PUSH
99933: EMPTY
99934: LIST
99935: LIST
99936: PPUSH
99937: CALL_OW 69
99941: ST_TO_ADDR
// if not tmp then
99942: LD_VAR 0 1
99946: NOT
99947: IFFALSE 99951
// exit ;
99949: GO 99977
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
99951: LD_VAR 0 1
99955: PUSH
99956: LD_INT 1
99958: PPUSH
99959: LD_VAR 0 1
99963: PPUSH
99964: CALL_OW 12
99968: ARRAY
99969: PPUSH
99970: LD_INT 60
99972: PPUSH
99973: CALL_OW 234
// end ;
99977: PPOPN 1
99979: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
99980: LD_EXP 96
99984: PUSH
99985: LD_EXP 126
99989: AND
99990: IFFALSE 100089
99992: GO 99994
99994: DISABLE
99995: LD_INT 0
99997: PPUSH
99998: PPUSH
// begin enable ;
99999: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
100000: LD_ADDR_VAR 0 1
100004: PUSH
100005: LD_INT 22
100007: PUSH
100008: LD_OWVAR 2
100012: PUSH
100013: EMPTY
100014: LIST
100015: LIST
100016: PUSH
100017: LD_INT 61
100019: PUSH
100020: EMPTY
100021: LIST
100022: PUSH
100023: LD_INT 33
100025: PUSH
100026: LD_INT 2
100028: PUSH
100029: EMPTY
100030: LIST
100031: LIST
100032: PUSH
100033: EMPTY
100034: LIST
100035: LIST
100036: LIST
100037: PPUSH
100038: CALL_OW 69
100042: ST_TO_ADDR
// if not tmp then
100043: LD_VAR 0 1
100047: NOT
100048: IFFALSE 100052
// exit ;
100050: GO 100089
// for i in tmp do
100052: LD_ADDR_VAR 0 2
100056: PUSH
100057: LD_VAR 0 1
100061: PUSH
100062: FOR_IN
100063: IFFALSE 100087
// if IsControledBy ( i ) then
100065: LD_VAR 0 2
100069: PPUSH
100070: CALL_OW 312
100074: IFFALSE 100085
// ComUnlink ( i ) ;
100076: LD_VAR 0 2
100080: PPUSH
100081: CALL_OW 136
100085: GO 100062
100087: POP
100088: POP
// end ;
100089: PPOPN 2
100091: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
100092: LD_EXP 96
100096: PUSH
100097: LD_EXP 127
100101: AND
100102: IFFALSE 100242
100104: GO 100106
100106: DISABLE
100107: LD_INT 0
100109: PPUSH
100110: PPUSH
// begin ToLua ( displayPowell(); ) ;
100111: LD_STRING displayPowell();
100113: PPUSH
100114: CALL_OW 559
// uc_side := 0 ;
100118: LD_ADDR_OWVAR 20
100122: PUSH
100123: LD_INT 0
100125: ST_TO_ADDR
// uc_nation := 2 ;
100126: LD_ADDR_OWVAR 21
100130: PUSH
100131: LD_INT 2
100133: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
100134: LD_ADDR_OWVAR 37
100138: PUSH
100139: LD_INT 14
100141: ST_TO_ADDR
// vc_engine := engine_siberite ;
100142: LD_ADDR_OWVAR 39
100146: PUSH
100147: LD_INT 3
100149: ST_TO_ADDR
// vc_control := control_apeman ;
100150: LD_ADDR_OWVAR 38
100154: PUSH
100155: LD_INT 5
100157: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
100158: LD_ADDR_OWVAR 40
100162: PUSH
100163: LD_INT 29
100165: ST_TO_ADDR
// un := CreateVehicle ;
100166: LD_ADDR_VAR 0 2
100170: PUSH
100171: CALL_OW 45
100175: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
100176: LD_VAR 0 2
100180: PPUSH
100181: LD_INT 1
100183: PPUSH
100184: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
100188: LD_INT 35
100190: PPUSH
100191: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
100195: LD_VAR 0 2
100199: PPUSH
100200: LD_INT 22
100202: PUSH
100203: LD_OWVAR 2
100207: PUSH
100208: EMPTY
100209: LIST
100210: LIST
100211: PPUSH
100212: CALL_OW 69
100216: PPUSH
100217: LD_VAR 0 2
100221: PPUSH
100222: CALL_OW 74
100226: PPUSH
100227: CALL_OW 115
// until IsDead ( un ) ;
100231: LD_VAR 0 2
100235: PPUSH
100236: CALL_OW 301
100240: IFFALSE 100188
// end ;
100242: PPOPN 2
100244: END
// every 0 0$1 trigger StreamModeActive and sStu do
100245: LD_EXP 96
100249: PUSH
100250: LD_EXP 135
100254: AND
100255: IFFALSE 100271
100257: GO 100259
100259: DISABLE
// begin ToLua ( displayStucuk(); ) ;
100260: LD_STRING displayStucuk();
100262: PPUSH
100263: CALL_OW 559
// ResetFog ;
100267: CALL_OW 335
// end ;
100271: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
100272: LD_EXP 96
100276: PUSH
100277: LD_EXP 128
100281: AND
100282: IFFALSE 100423
100284: GO 100286
100286: DISABLE
100287: LD_INT 0
100289: PPUSH
100290: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
100291: LD_ADDR_VAR 0 2
100295: PUSH
100296: LD_INT 22
100298: PUSH
100299: LD_OWVAR 2
100303: PUSH
100304: EMPTY
100305: LIST
100306: LIST
100307: PUSH
100308: LD_INT 21
100310: PUSH
100311: LD_INT 1
100313: PUSH
100314: EMPTY
100315: LIST
100316: LIST
100317: PUSH
100318: EMPTY
100319: LIST
100320: LIST
100321: PPUSH
100322: CALL_OW 69
100326: ST_TO_ADDR
// if not tmp then
100327: LD_VAR 0 2
100331: NOT
100332: IFFALSE 100336
// exit ;
100334: GO 100423
// un := tmp [ rand ( 1 , tmp ) ] ;
100336: LD_ADDR_VAR 0 1
100340: PUSH
100341: LD_VAR 0 2
100345: PUSH
100346: LD_INT 1
100348: PPUSH
100349: LD_VAR 0 2
100353: PPUSH
100354: CALL_OW 12
100358: ARRAY
100359: ST_TO_ADDR
// SetSide ( un , 0 ) ;
100360: LD_VAR 0 1
100364: PPUSH
100365: LD_INT 0
100367: PPUSH
100368: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
100372: LD_VAR 0 1
100376: PPUSH
100377: LD_OWVAR 3
100381: PUSH
100382: LD_VAR 0 1
100386: DIFF
100387: PPUSH
100388: LD_VAR 0 1
100392: PPUSH
100393: CALL_OW 74
100397: PPUSH
100398: CALL_OW 115
// wait ( 0 0$20 ) ;
100402: LD_INT 700
100404: PPUSH
100405: CALL_OW 67
// SetSide ( un , your_side ) ;
100409: LD_VAR 0 1
100413: PPUSH
100414: LD_OWVAR 2
100418: PPUSH
100419: CALL_OW 235
// end ;
100423: PPOPN 2
100425: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
100426: LD_EXP 96
100430: PUSH
100431: LD_EXP 129
100435: AND
100436: IFFALSE 100542
100438: GO 100440
100440: DISABLE
100441: LD_INT 0
100443: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
100444: LD_ADDR_VAR 0 1
100448: PUSH
100449: LD_INT 22
100451: PUSH
100452: LD_OWVAR 2
100456: PUSH
100457: EMPTY
100458: LIST
100459: LIST
100460: PUSH
100461: LD_INT 2
100463: PUSH
100464: LD_INT 30
100466: PUSH
100467: LD_INT 0
100469: PUSH
100470: EMPTY
100471: LIST
100472: LIST
100473: PUSH
100474: LD_INT 30
100476: PUSH
100477: LD_INT 1
100479: PUSH
100480: EMPTY
100481: LIST
100482: LIST
100483: PUSH
100484: EMPTY
100485: LIST
100486: LIST
100487: LIST
100488: PUSH
100489: EMPTY
100490: LIST
100491: LIST
100492: PPUSH
100493: CALL_OW 69
100497: ST_TO_ADDR
// if not depot then
100498: LD_VAR 0 1
100502: NOT
100503: IFFALSE 100507
// exit ;
100505: GO 100542
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
100507: LD_VAR 0 1
100511: PUSH
100512: LD_INT 1
100514: ARRAY
100515: PPUSH
100516: CALL_OW 250
100520: PPUSH
100521: LD_VAR 0 1
100525: PUSH
100526: LD_INT 1
100528: ARRAY
100529: PPUSH
100530: CALL_OW 251
100534: PPUSH
100535: LD_INT 70
100537: PPUSH
100538: CALL_OW 495
// end ;
100542: PPOPN 1
100544: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
100545: LD_EXP 96
100549: PUSH
100550: LD_EXP 130
100554: AND
100555: IFFALSE 100766
100557: GO 100559
100559: DISABLE
100560: LD_INT 0
100562: PPUSH
100563: PPUSH
100564: PPUSH
100565: PPUSH
100566: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
100567: LD_ADDR_VAR 0 5
100571: PUSH
100572: LD_INT 22
100574: PUSH
100575: LD_OWVAR 2
100579: PUSH
100580: EMPTY
100581: LIST
100582: LIST
100583: PUSH
100584: LD_INT 21
100586: PUSH
100587: LD_INT 1
100589: PUSH
100590: EMPTY
100591: LIST
100592: LIST
100593: PUSH
100594: EMPTY
100595: LIST
100596: LIST
100597: PPUSH
100598: CALL_OW 69
100602: ST_TO_ADDR
// if not tmp then
100603: LD_VAR 0 5
100607: NOT
100608: IFFALSE 100612
// exit ;
100610: GO 100766
// for i in tmp do
100612: LD_ADDR_VAR 0 1
100616: PUSH
100617: LD_VAR 0 5
100621: PUSH
100622: FOR_IN
100623: IFFALSE 100764
// begin d := rand ( 0 , 5 ) ;
100625: LD_ADDR_VAR 0 4
100629: PUSH
100630: LD_INT 0
100632: PPUSH
100633: LD_INT 5
100635: PPUSH
100636: CALL_OW 12
100640: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
100641: LD_ADDR_VAR 0 2
100645: PUSH
100646: LD_VAR 0 1
100650: PPUSH
100651: CALL_OW 250
100655: PPUSH
100656: LD_VAR 0 4
100660: PPUSH
100661: LD_INT 3
100663: PPUSH
100664: LD_INT 12
100666: PPUSH
100667: CALL_OW 12
100671: PPUSH
100672: CALL_OW 272
100676: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
100677: LD_ADDR_VAR 0 3
100681: PUSH
100682: LD_VAR 0 1
100686: PPUSH
100687: CALL_OW 251
100691: PPUSH
100692: LD_VAR 0 4
100696: PPUSH
100697: LD_INT 3
100699: PPUSH
100700: LD_INT 12
100702: PPUSH
100703: CALL_OW 12
100707: PPUSH
100708: CALL_OW 273
100712: ST_TO_ADDR
// if ValidHex ( x , y ) then
100713: LD_VAR 0 2
100717: PPUSH
100718: LD_VAR 0 3
100722: PPUSH
100723: CALL_OW 488
100727: IFFALSE 100762
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
100729: LD_VAR 0 1
100733: PPUSH
100734: LD_VAR 0 2
100738: PPUSH
100739: LD_VAR 0 3
100743: PPUSH
100744: LD_INT 3
100746: PPUSH
100747: LD_INT 6
100749: PPUSH
100750: CALL_OW 12
100754: PPUSH
100755: LD_INT 1
100757: PPUSH
100758: CALL_OW 483
// end ;
100762: GO 100622
100764: POP
100765: POP
// end ;
100766: PPOPN 5
100768: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
100769: LD_EXP 96
100773: PUSH
100774: LD_EXP 131
100778: AND
100779: IFFALSE 100873
100781: GO 100783
100783: DISABLE
100784: LD_INT 0
100786: PPUSH
100787: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
100788: LD_ADDR_VAR 0 2
100792: PUSH
100793: LD_INT 22
100795: PUSH
100796: LD_OWVAR 2
100800: PUSH
100801: EMPTY
100802: LIST
100803: LIST
100804: PUSH
100805: LD_INT 32
100807: PUSH
100808: LD_INT 1
100810: PUSH
100811: EMPTY
100812: LIST
100813: LIST
100814: PUSH
100815: LD_INT 21
100817: PUSH
100818: LD_INT 2
100820: PUSH
100821: EMPTY
100822: LIST
100823: LIST
100824: PUSH
100825: EMPTY
100826: LIST
100827: LIST
100828: LIST
100829: PPUSH
100830: CALL_OW 69
100834: ST_TO_ADDR
// if not tmp then
100835: LD_VAR 0 2
100839: NOT
100840: IFFALSE 100844
// exit ;
100842: GO 100873
// for i in tmp do
100844: LD_ADDR_VAR 0 1
100848: PUSH
100849: LD_VAR 0 2
100853: PUSH
100854: FOR_IN
100855: IFFALSE 100871
// SetFuel ( i , 0 ) ;
100857: LD_VAR 0 1
100861: PPUSH
100862: LD_INT 0
100864: PPUSH
100865: CALL_OW 240
100869: GO 100854
100871: POP
100872: POP
// end ;
100873: PPOPN 2
100875: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
100876: LD_EXP 96
100880: PUSH
100881: LD_EXP 132
100885: AND
100886: IFFALSE 100952
100888: GO 100890
100890: DISABLE
100891: LD_INT 0
100893: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
100894: LD_ADDR_VAR 0 1
100898: PUSH
100899: LD_INT 22
100901: PUSH
100902: LD_OWVAR 2
100906: PUSH
100907: EMPTY
100908: LIST
100909: LIST
100910: PUSH
100911: LD_INT 30
100913: PUSH
100914: LD_INT 29
100916: PUSH
100917: EMPTY
100918: LIST
100919: LIST
100920: PUSH
100921: EMPTY
100922: LIST
100923: LIST
100924: PPUSH
100925: CALL_OW 69
100929: ST_TO_ADDR
// if not tmp then
100930: LD_VAR 0 1
100934: NOT
100935: IFFALSE 100939
// exit ;
100937: GO 100952
// DestroyUnit ( tmp [ 1 ] ) ;
100939: LD_VAR 0 1
100943: PUSH
100944: LD_INT 1
100946: ARRAY
100947: PPUSH
100948: CALL_OW 65
// end ;
100952: PPOPN 1
100954: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
100955: LD_EXP 96
100959: PUSH
100960: LD_EXP 134
100964: AND
100965: IFFALSE 101094
100967: GO 100969
100969: DISABLE
100970: LD_INT 0
100972: PPUSH
// begin uc_side := 0 ;
100973: LD_ADDR_OWVAR 20
100977: PUSH
100978: LD_INT 0
100980: ST_TO_ADDR
// uc_nation := nation_arabian ;
100981: LD_ADDR_OWVAR 21
100985: PUSH
100986: LD_INT 2
100988: ST_TO_ADDR
// hc_gallery :=  ;
100989: LD_ADDR_OWVAR 33
100993: PUSH
100994: LD_STRING 
100996: ST_TO_ADDR
// hc_name :=  ;
100997: LD_ADDR_OWVAR 26
101001: PUSH
101002: LD_STRING 
101004: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
101005: LD_INT 1
101007: PPUSH
101008: LD_INT 11
101010: PPUSH
101011: LD_INT 10
101013: PPUSH
101014: CALL_OW 380
// un := CreateHuman ;
101018: LD_ADDR_VAR 0 1
101022: PUSH
101023: CALL_OW 44
101027: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
101028: LD_VAR 0 1
101032: PPUSH
101033: LD_INT 1
101035: PPUSH
101036: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
101040: LD_INT 35
101042: PPUSH
101043: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
101047: LD_VAR 0 1
101051: PPUSH
101052: LD_INT 22
101054: PUSH
101055: LD_OWVAR 2
101059: PUSH
101060: EMPTY
101061: LIST
101062: LIST
101063: PPUSH
101064: CALL_OW 69
101068: PPUSH
101069: LD_VAR 0 1
101073: PPUSH
101074: CALL_OW 74
101078: PPUSH
101079: CALL_OW 115
// until IsDead ( un ) ;
101083: LD_VAR 0 1
101087: PPUSH
101088: CALL_OW 301
101092: IFFALSE 101040
// end ;
101094: PPOPN 1
101096: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
101097: LD_EXP 96
101101: PUSH
101102: LD_EXP 136
101106: AND
101107: IFFALSE 101119
101109: GO 101111
101111: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
101112: LD_STRING earthquake(getX(game), 0, 32)
101114: PPUSH
101115: CALL_OW 559
101119: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
101120: LD_EXP 96
101124: PUSH
101125: LD_EXP 137
101129: AND
101130: IFFALSE 101221
101132: GO 101134
101134: DISABLE
101135: LD_INT 0
101137: PPUSH
// begin enable ;
101138: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
101139: LD_ADDR_VAR 0 1
101143: PUSH
101144: LD_INT 22
101146: PUSH
101147: LD_OWVAR 2
101151: PUSH
101152: EMPTY
101153: LIST
101154: LIST
101155: PUSH
101156: LD_INT 21
101158: PUSH
101159: LD_INT 2
101161: PUSH
101162: EMPTY
101163: LIST
101164: LIST
101165: PUSH
101166: LD_INT 33
101168: PUSH
101169: LD_INT 3
101171: PUSH
101172: EMPTY
101173: LIST
101174: LIST
101175: PUSH
101176: EMPTY
101177: LIST
101178: LIST
101179: LIST
101180: PPUSH
101181: CALL_OW 69
101185: ST_TO_ADDR
// if not tmp then
101186: LD_VAR 0 1
101190: NOT
101191: IFFALSE 101195
// exit ;
101193: GO 101221
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
101195: LD_VAR 0 1
101199: PUSH
101200: LD_INT 1
101202: PPUSH
101203: LD_VAR 0 1
101207: PPUSH
101208: CALL_OW 12
101212: ARRAY
101213: PPUSH
101214: LD_INT 1
101216: PPUSH
101217: CALL_OW 234
// end ;
101221: PPOPN 1
101223: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
101224: LD_EXP 96
101228: PUSH
101229: LD_EXP 138
101233: AND
101234: IFFALSE 101375
101236: GO 101238
101238: DISABLE
101239: LD_INT 0
101241: PPUSH
101242: PPUSH
101243: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
101244: LD_ADDR_VAR 0 3
101248: PUSH
101249: LD_INT 22
101251: PUSH
101252: LD_OWVAR 2
101256: PUSH
101257: EMPTY
101258: LIST
101259: LIST
101260: PUSH
101261: LD_INT 25
101263: PUSH
101264: LD_INT 1
101266: PUSH
101267: EMPTY
101268: LIST
101269: LIST
101270: PUSH
101271: EMPTY
101272: LIST
101273: LIST
101274: PPUSH
101275: CALL_OW 69
101279: ST_TO_ADDR
// if not tmp then
101280: LD_VAR 0 3
101284: NOT
101285: IFFALSE 101289
// exit ;
101287: GO 101375
// un := tmp [ rand ( 1 , tmp ) ] ;
101289: LD_ADDR_VAR 0 2
101293: PUSH
101294: LD_VAR 0 3
101298: PUSH
101299: LD_INT 1
101301: PPUSH
101302: LD_VAR 0 3
101306: PPUSH
101307: CALL_OW 12
101311: ARRAY
101312: ST_TO_ADDR
// if Crawls ( un ) then
101313: LD_VAR 0 2
101317: PPUSH
101318: CALL_OW 318
101322: IFFALSE 101333
// ComWalk ( un ) ;
101324: LD_VAR 0 2
101328: PPUSH
101329: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
101333: LD_VAR 0 2
101337: PPUSH
101338: LD_INT 9
101340: PPUSH
101341: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
101345: LD_INT 28
101347: PPUSH
101348: LD_OWVAR 2
101352: PPUSH
101353: LD_INT 2
101355: PPUSH
101356: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
101360: LD_INT 29
101362: PPUSH
101363: LD_OWVAR 2
101367: PPUSH
101368: LD_INT 2
101370: PPUSH
101371: CALL_OW 322
// end ;
101375: PPOPN 3
101377: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
101378: LD_EXP 96
101382: PUSH
101383: LD_EXP 139
101387: AND
101388: IFFALSE 101499
101390: GO 101392
101392: DISABLE
101393: LD_INT 0
101395: PPUSH
101396: PPUSH
101397: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
101398: LD_ADDR_VAR 0 3
101402: PUSH
101403: LD_INT 22
101405: PUSH
101406: LD_OWVAR 2
101410: PUSH
101411: EMPTY
101412: LIST
101413: LIST
101414: PUSH
101415: LD_INT 25
101417: PUSH
101418: LD_INT 1
101420: PUSH
101421: EMPTY
101422: LIST
101423: LIST
101424: PUSH
101425: EMPTY
101426: LIST
101427: LIST
101428: PPUSH
101429: CALL_OW 69
101433: ST_TO_ADDR
// if not tmp then
101434: LD_VAR 0 3
101438: NOT
101439: IFFALSE 101443
// exit ;
101441: GO 101499
// un := tmp [ rand ( 1 , tmp ) ] ;
101443: LD_ADDR_VAR 0 2
101447: PUSH
101448: LD_VAR 0 3
101452: PUSH
101453: LD_INT 1
101455: PPUSH
101456: LD_VAR 0 3
101460: PPUSH
101461: CALL_OW 12
101465: ARRAY
101466: ST_TO_ADDR
// if Crawls ( un ) then
101467: LD_VAR 0 2
101471: PPUSH
101472: CALL_OW 318
101476: IFFALSE 101487
// ComWalk ( un ) ;
101478: LD_VAR 0 2
101482: PPUSH
101483: CALL_OW 138
// SetClass ( un , class_mortar ) ;
101487: LD_VAR 0 2
101491: PPUSH
101492: LD_INT 8
101494: PPUSH
101495: CALL_OW 336
// end ;
101499: PPOPN 3
101501: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
101502: LD_EXP 96
101506: PUSH
101507: LD_EXP 140
101511: AND
101512: IFFALSE 101656
101514: GO 101516
101516: DISABLE
101517: LD_INT 0
101519: PPUSH
101520: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
101521: LD_ADDR_VAR 0 2
101525: PUSH
101526: LD_INT 22
101528: PUSH
101529: LD_OWVAR 2
101533: PUSH
101534: EMPTY
101535: LIST
101536: LIST
101537: PUSH
101538: LD_INT 21
101540: PUSH
101541: LD_INT 2
101543: PUSH
101544: EMPTY
101545: LIST
101546: LIST
101547: PUSH
101548: LD_INT 2
101550: PUSH
101551: LD_INT 34
101553: PUSH
101554: LD_INT 12
101556: PUSH
101557: EMPTY
101558: LIST
101559: LIST
101560: PUSH
101561: LD_INT 34
101563: PUSH
101564: LD_INT 51
101566: PUSH
101567: EMPTY
101568: LIST
101569: LIST
101570: PUSH
101571: LD_INT 34
101573: PUSH
101574: LD_INT 32
101576: PUSH
101577: EMPTY
101578: LIST
101579: LIST
101580: PUSH
101581: EMPTY
101582: LIST
101583: LIST
101584: LIST
101585: LIST
101586: PUSH
101587: EMPTY
101588: LIST
101589: LIST
101590: LIST
101591: PPUSH
101592: CALL_OW 69
101596: ST_TO_ADDR
// if not tmp then
101597: LD_VAR 0 2
101601: NOT
101602: IFFALSE 101606
// exit ;
101604: GO 101656
// for i in tmp do
101606: LD_ADDR_VAR 0 1
101610: PUSH
101611: LD_VAR 0 2
101615: PUSH
101616: FOR_IN
101617: IFFALSE 101654
// if GetCargo ( i , mat_artifact ) = 0 then
101619: LD_VAR 0 1
101623: PPUSH
101624: LD_INT 4
101626: PPUSH
101627: CALL_OW 289
101631: PUSH
101632: LD_INT 0
101634: EQUAL
101635: IFFALSE 101652
// SetCargo ( i , mat_siberit , 100 ) ;
101637: LD_VAR 0 1
101641: PPUSH
101642: LD_INT 3
101644: PPUSH
101645: LD_INT 100
101647: PPUSH
101648: CALL_OW 290
101652: GO 101616
101654: POP
101655: POP
// end ;
101656: PPOPN 2
101658: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
101659: LD_EXP 96
101663: PUSH
101664: LD_EXP 141
101668: AND
101669: IFFALSE 101852
101671: GO 101673
101673: DISABLE
101674: LD_INT 0
101676: PPUSH
101677: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
101678: LD_ADDR_VAR 0 2
101682: PUSH
101683: LD_INT 22
101685: PUSH
101686: LD_OWVAR 2
101690: PUSH
101691: EMPTY
101692: LIST
101693: LIST
101694: PPUSH
101695: CALL_OW 69
101699: ST_TO_ADDR
// if not tmp then
101700: LD_VAR 0 2
101704: NOT
101705: IFFALSE 101709
// exit ;
101707: GO 101852
// for i := 1 to 2 do
101709: LD_ADDR_VAR 0 1
101713: PUSH
101714: DOUBLE
101715: LD_INT 1
101717: DEC
101718: ST_TO_ADDR
101719: LD_INT 2
101721: PUSH
101722: FOR_TO
101723: IFFALSE 101850
// begin uc_side := your_side ;
101725: LD_ADDR_OWVAR 20
101729: PUSH
101730: LD_OWVAR 2
101734: ST_TO_ADDR
// uc_nation := nation_american ;
101735: LD_ADDR_OWVAR 21
101739: PUSH
101740: LD_INT 1
101742: ST_TO_ADDR
// vc_chassis := us_morphling ;
101743: LD_ADDR_OWVAR 37
101747: PUSH
101748: LD_INT 5
101750: ST_TO_ADDR
// vc_engine := engine_siberite ;
101751: LD_ADDR_OWVAR 39
101755: PUSH
101756: LD_INT 3
101758: ST_TO_ADDR
// vc_control := control_computer ;
101759: LD_ADDR_OWVAR 38
101763: PUSH
101764: LD_INT 3
101766: ST_TO_ADDR
// vc_weapon := us_double_laser ;
101767: LD_ADDR_OWVAR 40
101771: PUSH
101772: LD_INT 10
101774: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
101775: LD_VAR 0 2
101779: PUSH
101780: LD_INT 1
101782: ARRAY
101783: PPUSH
101784: CALL_OW 310
101788: NOT
101789: IFFALSE 101836
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
101791: CALL_OW 45
101795: PPUSH
101796: LD_VAR 0 2
101800: PUSH
101801: LD_INT 1
101803: ARRAY
101804: PPUSH
101805: CALL_OW 250
101809: PPUSH
101810: LD_VAR 0 2
101814: PUSH
101815: LD_INT 1
101817: ARRAY
101818: PPUSH
101819: CALL_OW 251
101823: PPUSH
101824: LD_INT 12
101826: PPUSH
101827: LD_INT 1
101829: PPUSH
101830: CALL_OW 50
101834: GO 101848
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
101836: CALL_OW 45
101840: PPUSH
101841: LD_INT 1
101843: PPUSH
101844: CALL_OW 51
// end ;
101848: GO 101722
101850: POP
101851: POP
// end ;
101852: PPOPN 2
101854: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
101855: LD_EXP 96
101859: PUSH
101860: LD_EXP 142
101864: AND
101865: IFFALSE 102087
101867: GO 101869
101869: DISABLE
101870: LD_INT 0
101872: PPUSH
101873: PPUSH
101874: PPUSH
101875: PPUSH
101876: PPUSH
101877: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
101878: LD_ADDR_VAR 0 6
101882: PUSH
101883: LD_INT 22
101885: PUSH
101886: LD_OWVAR 2
101890: PUSH
101891: EMPTY
101892: LIST
101893: LIST
101894: PUSH
101895: LD_INT 21
101897: PUSH
101898: LD_INT 1
101900: PUSH
101901: EMPTY
101902: LIST
101903: LIST
101904: PUSH
101905: LD_INT 3
101907: PUSH
101908: LD_INT 23
101910: PUSH
101911: LD_INT 0
101913: PUSH
101914: EMPTY
101915: LIST
101916: LIST
101917: PUSH
101918: EMPTY
101919: LIST
101920: LIST
101921: PUSH
101922: EMPTY
101923: LIST
101924: LIST
101925: LIST
101926: PPUSH
101927: CALL_OW 69
101931: ST_TO_ADDR
// if not tmp then
101932: LD_VAR 0 6
101936: NOT
101937: IFFALSE 101941
// exit ;
101939: GO 102087
// s1 := rand ( 1 , 4 ) ;
101941: LD_ADDR_VAR 0 2
101945: PUSH
101946: LD_INT 1
101948: PPUSH
101949: LD_INT 4
101951: PPUSH
101952: CALL_OW 12
101956: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
101957: LD_ADDR_VAR 0 4
101961: PUSH
101962: LD_VAR 0 6
101966: PUSH
101967: LD_INT 1
101969: ARRAY
101970: PPUSH
101971: LD_VAR 0 2
101975: PPUSH
101976: CALL_OW 259
101980: ST_TO_ADDR
// if s1 = 1 then
101981: LD_VAR 0 2
101985: PUSH
101986: LD_INT 1
101988: EQUAL
101989: IFFALSE 102009
// s2 := rand ( 2 , 4 ) else
101991: LD_ADDR_VAR 0 3
101995: PUSH
101996: LD_INT 2
101998: PPUSH
101999: LD_INT 4
102001: PPUSH
102002: CALL_OW 12
102006: ST_TO_ADDR
102007: GO 102017
// s2 := 1 ;
102009: LD_ADDR_VAR 0 3
102013: PUSH
102014: LD_INT 1
102016: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
102017: LD_ADDR_VAR 0 5
102021: PUSH
102022: LD_VAR 0 6
102026: PUSH
102027: LD_INT 1
102029: ARRAY
102030: PPUSH
102031: LD_VAR 0 3
102035: PPUSH
102036: CALL_OW 259
102040: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
102041: LD_VAR 0 6
102045: PUSH
102046: LD_INT 1
102048: ARRAY
102049: PPUSH
102050: LD_VAR 0 2
102054: PPUSH
102055: LD_VAR 0 5
102059: PPUSH
102060: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
102064: LD_VAR 0 6
102068: PUSH
102069: LD_INT 1
102071: ARRAY
102072: PPUSH
102073: LD_VAR 0 3
102077: PPUSH
102078: LD_VAR 0 4
102082: PPUSH
102083: CALL_OW 237
// end ;
102087: PPOPN 6
102089: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
102090: LD_EXP 96
102094: PUSH
102095: LD_EXP 143
102099: AND
102100: IFFALSE 102179
102102: GO 102104
102104: DISABLE
102105: LD_INT 0
102107: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
102108: LD_ADDR_VAR 0 1
102112: PUSH
102113: LD_INT 22
102115: PUSH
102116: LD_OWVAR 2
102120: PUSH
102121: EMPTY
102122: LIST
102123: LIST
102124: PUSH
102125: LD_INT 30
102127: PUSH
102128: LD_INT 3
102130: PUSH
102131: EMPTY
102132: LIST
102133: LIST
102134: PUSH
102135: EMPTY
102136: LIST
102137: LIST
102138: PPUSH
102139: CALL_OW 69
102143: ST_TO_ADDR
// if not tmp then
102144: LD_VAR 0 1
102148: NOT
102149: IFFALSE 102153
// exit ;
102151: GO 102179
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
102153: LD_VAR 0 1
102157: PUSH
102158: LD_INT 1
102160: PPUSH
102161: LD_VAR 0 1
102165: PPUSH
102166: CALL_OW 12
102170: ARRAY
102171: PPUSH
102172: LD_INT 1
102174: PPUSH
102175: CALL_OW 234
// end ;
102179: PPOPN 1
102181: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
102182: LD_EXP 96
102186: PUSH
102187: LD_EXP 144
102191: AND
102192: IFFALSE 102304
102194: GO 102196
102196: DISABLE
102197: LD_INT 0
102199: PPUSH
102200: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
102201: LD_ADDR_VAR 0 2
102205: PUSH
102206: LD_INT 22
102208: PUSH
102209: LD_OWVAR 2
102213: PUSH
102214: EMPTY
102215: LIST
102216: LIST
102217: PUSH
102218: LD_INT 2
102220: PUSH
102221: LD_INT 30
102223: PUSH
102224: LD_INT 27
102226: PUSH
102227: EMPTY
102228: LIST
102229: LIST
102230: PUSH
102231: LD_INT 30
102233: PUSH
102234: LD_INT 26
102236: PUSH
102237: EMPTY
102238: LIST
102239: LIST
102240: PUSH
102241: LD_INT 30
102243: PUSH
102244: LD_INT 28
102246: PUSH
102247: EMPTY
102248: LIST
102249: LIST
102250: PUSH
102251: EMPTY
102252: LIST
102253: LIST
102254: LIST
102255: LIST
102256: PUSH
102257: EMPTY
102258: LIST
102259: LIST
102260: PPUSH
102261: CALL_OW 69
102265: ST_TO_ADDR
// if not tmp then
102266: LD_VAR 0 2
102270: NOT
102271: IFFALSE 102275
// exit ;
102273: GO 102304
// for i in tmp do
102275: LD_ADDR_VAR 0 1
102279: PUSH
102280: LD_VAR 0 2
102284: PUSH
102285: FOR_IN
102286: IFFALSE 102302
// SetLives ( i , 1 ) ;
102288: LD_VAR 0 1
102292: PPUSH
102293: LD_INT 1
102295: PPUSH
102296: CALL_OW 234
102300: GO 102285
102302: POP
102303: POP
// end ;
102304: PPOPN 2
102306: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
102307: LD_EXP 96
102311: PUSH
102312: LD_EXP 145
102316: AND
102317: IFFALSE 102604
102319: GO 102321
102321: DISABLE
102322: LD_INT 0
102324: PPUSH
102325: PPUSH
102326: PPUSH
// begin i := rand ( 1 , 7 ) ;
102327: LD_ADDR_VAR 0 1
102331: PUSH
102332: LD_INT 1
102334: PPUSH
102335: LD_INT 7
102337: PPUSH
102338: CALL_OW 12
102342: ST_TO_ADDR
// case i of 1 :
102343: LD_VAR 0 1
102347: PUSH
102348: LD_INT 1
102350: DOUBLE
102351: EQUAL
102352: IFTRUE 102356
102354: GO 102366
102356: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
102357: LD_STRING earthquake(getX(game), 0, 32)
102359: PPUSH
102360: CALL_OW 559
102364: GO 102604
102366: LD_INT 2
102368: DOUBLE
102369: EQUAL
102370: IFTRUE 102374
102372: GO 102388
102374: POP
// begin ToLua ( displayStucuk(); ) ;
102375: LD_STRING displayStucuk();
102377: PPUSH
102378: CALL_OW 559
// ResetFog ;
102382: CALL_OW 335
// end ; 3 :
102386: GO 102604
102388: LD_INT 3
102390: DOUBLE
102391: EQUAL
102392: IFTRUE 102396
102394: GO 102500
102396: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102397: LD_ADDR_VAR 0 2
102401: PUSH
102402: LD_INT 22
102404: PUSH
102405: LD_OWVAR 2
102409: PUSH
102410: EMPTY
102411: LIST
102412: LIST
102413: PUSH
102414: LD_INT 25
102416: PUSH
102417: LD_INT 1
102419: PUSH
102420: EMPTY
102421: LIST
102422: LIST
102423: PUSH
102424: EMPTY
102425: LIST
102426: LIST
102427: PPUSH
102428: CALL_OW 69
102432: ST_TO_ADDR
// if not tmp then
102433: LD_VAR 0 2
102437: NOT
102438: IFFALSE 102442
// exit ;
102440: GO 102604
// un := tmp [ rand ( 1 , tmp ) ] ;
102442: LD_ADDR_VAR 0 3
102446: PUSH
102447: LD_VAR 0 2
102451: PUSH
102452: LD_INT 1
102454: PPUSH
102455: LD_VAR 0 2
102459: PPUSH
102460: CALL_OW 12
102464: ARRAY
102465: ST_TO_ADDR
// if Crawls ( un ) then
102466: LD_VAR 0 3
102470: PPUSH
102471: CALL_OW 318
102475: IFFALSE 102486
// ComWalk ( un ) ;
102477: LD_VAR 0 3
102481: PPUSH
102482: CALL_OW 138
// SetClass ( un , class_mortar ) ;
102486: LD_VAR 0 3
102490: PPUSH
102491: LD_INT 8
102493: PPUSH
102494: CALL_OW 336
// end ; 4 :
102498: GO 102604
102500: LD_INT 4
102502: DOUBLE
102503: EQUAL
102504: IFTRUE 102508
102506: GO 102582
102508: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
102509: LD_ADDR_VAR 0 2
102513: PUSH
102514: LD_INT 22
102516: PUSH
102517: LD_OWVAR 2
102521: PUSH
102522: EMPTY
102523: LIST
102524: LIST
102525: PUSH
102526: LD_INT 30
102528: PUSH
102529: LD_INT 29
102531: PUSH
102532: EMPTY
102533: LIST
102534: LIST
102535: PUSH
102536: EMPTY
102537: LIST
102538: LIST
102539: PPUSH
102540: CALL_OW 69
102544: ST_TO_ADDR
// if not tmp then
102545: LD_VAR 0 2
102549: NOT
102550: IFFALSE 102554
// exit ;
102552: GO 102604
// CenterNowOnUnits ( tmp [ 1 ] ) ;
102554: LD_VAR 0 2
102558: PUSH
102559: LD_INT 1
102561: ARRAY
102562: PPUSH
102563: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
102567: LD_VAR 0 2
102571: PUSH
102572: LD_INT 1
102574: ARRAY
102575: PPUSH
102576: CALL_OW 65
// end ; 5 .. 7 :
102580: GO 102604
102582: LD_INT 5
102584: DOUBLE
102585: GREATEREQUAL
102586: IFFALSE 102594
102588: LD_INT 7
102590: DOUBLE
102591: LESSEQUAL
102592: IFTRUE 102596
102594: GO 102603
102596: POP
// StreamSibBomb ; end ;
102597: CALL 98841 0 0
102601: GO 102604
102603: POP
// end ;
102604: PPOPN 3
102606: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
102607: LD_EXP 96
102611: PUSH
102612: LD_EXP 146
102616: AND
102617: IFFALSE 102773
102619: GO 102621
102621: DISABLE
102622: LD_INT 0
102624: PPUSH
102625: PPUSH
102626: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
102627: LD_ADDR_VAR 0 2
102631: PUSH
102632: LD_INT 81
102634: PUSH
102635: LD_OWVAR 2
102639: PUSH
102640: EMPTY
102641: LIST
102642: LIST
102643: PUSH
102644: LD_INT 2
102646: PUSH
102647: LD_INT 21
102649: PUSH
102650: LD_INT 1
102652: PUSH
102653: EMPTY
102654: LIST
102655: LIST
102656: PUSH
102657: LD_INT 21
102659: PUSH
102660: LD_INT 2
102662: PUSH
102663: EMPTY
102664: LIST
102665: LIST
102666: PUSH
102667: EMPTY
102668: LIST
102669: LIST
102670: LIST
102671: PUSH
102672: EMPTY
102673: LIST
102674: LIST
102675: PPUSH
102676: CALL_OW 69
102680: ST_TO_ADDR
// if not tmp then
102681: LD_VAR 0 2
102685: NOT
102686: IFFALSE 102690
// exit ;
102688: GO 102773
// p := 0 ;
102690: LD_ADDR_VAR 0 3
102694: PUSH
102695: LD_INT 0
102697: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
102698: LD_INT 35
102700: PPUSH
102701: CALL_OW 67
// p := p + 1 ;
102705: LD_ADDR_VAR 0 3
102709: PUSH
102710: LD_VAR 0 3
102714: PUSH
102715: LD_INT 1
102717: PLUS
102718: ST_TO_ADDR
// for i in tmp do
102719: LD_ADDR_VAR 0 1
102723: PUSH
102724: LD_VAR 0 2
102728: PUSH
102729: FOR_IN
102730: IFFALSE 102761
// if GetLives ( i ) < 1000 then
102732: LD_VAR 0 1
102736: PPUSH
102737: CALL_OW 256
102741: PUSH
102742: LD_INT 1000
102744: LESS
102745: IFFALSE 102759
// SetLives ( i , 1000 ) ;
102747: LD_VAR 0 1
102751: PPUSH
102752: LD_INT 1000
102754: PPUSH
102755: CALL_OW 234
102759: GO 102729
102761: POP
102762: POP
// until p > 20 ;
102763: LD_VAR 0 3
102767: PUSH
102768: LD_INT 20
102770: GREATER
102771: IFFALSE 102698
// end ;
102773: PPOPN 3
102775: END
// every 0 0$1 trigger StreamModeActive and sTime do
102776: LD_EXP 96
102780: PUSH
102781: LD_EXP 147
102785: AND
102786: IFFALSE 102821
102788: GO 102790
102790: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
102791: LD_INT 28
102793: PPUSH
102794: LD_OWVAR 2
102798: PPUSH
102799: LD_INT 2
102801: PPUSH
102802: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
102806: LD_INT 30
102808: PPUSH
102809: LD_OWVAR 2
102813: PPUSH
102814: LD_INT 2
102816: PPUSH
102817: CALL_OW 322
// end ;
102821: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
102822: LD_EXP 96
102826: PUSH
102827: LD_EXP 148
102831: AND
102832: IFFALSE 102953
102834: GO 102836
102836: DISABLE
102837: LD_INT 0
102839: PPUSH
102840: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
102841: LD_ADDR_VAR 0 2
102845: PUSH
102846: LD_INT 22
102848: PUSH
102849: LD_OWVAR 2
102853: PUSH
102854: EMPTY
102855: LIST
102856: LIST
102857: PUSH
102858: LD_INT 21
102860: PUSH
102861: LD_INT 1
102863: PUSH
102864: EMPTY
102865: LIST
102866: LIST
102867: PUSH
102868: LD_INT 3
102870: PUSH
102871: LD_INT 23
102873: PUSH
102874: LD_INT 0
102876: PUSH
102877: EMPTY
102878: LIST
102879: LIST
102880: PUSH
102881: EMPTY
102882: LIST
102883: LIST
102884: PUSH
102885: EMPTY
102886: LIST
102887: LIST
102888: LIST
102889: PPUSH
102890: CALL_OW 69
102894: ST_TO_ADDR
// if not tmp then
102895: LD_VAR 0 2
102899: NOT
102900: IFFALSE 102904
// exit ;
102902: GO 102953
// for i in tmp do
102904: LD_ADDR_VAR 0 1
102908: PUSH
102909: LD_VAR 0 2
102913: PUSH
102914: FOR_IN
102915: IFFALSE 102951
// begin if Crawls ( i ) then
102917: LD_VAR 0 1
102921: PPUSH
102922: CALL_OW 318
102926: IFFALSE 102937
// ComWalk ( i ) ;
102928: LD_VAR 0 1
102932: PPUSH
102933: CALL_OW 138
// SetClass ( i , 2 ) ;
102937: LD_VAR 0 1
102941: PPUSH
102942: LD_INT 2
102944: PPUSH
102945: CALL_OW 336
// end ;
102949: GO 102914
102951: POP
102952: POP
// end ;
102953: PPOPN 2
102955: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
102956: LD_EXP 96
102960: PUSH
102961: LD_EXP 149
102965: AND
102966: IFFALSE 103254
102968: GO 102970
102970: DISABLE
102971: LD_INT 0
102973: PPUSH
102974: PPUSH
102975: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
102976: LD_OWVAR 2
102980: PPUSH
102981: LD_INT 9
102983: PPUSH
102984: LD_INT 1
102986: PPUSH
102987: LD_INT 1
102989: PPUSH
102990: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
102994: LD_INT 9
102996: PPUSH
102997: LD_OWVAR 2
103001: PPUSH
103002: CALL_OW 343
// uc_side := 9 ;
103006: LD_ADDR_OWVAR 20
103010: PUSH
103011: LD_INT 9
103013: ST_TO_ADDR
// uc_nation := 2 ;
103014: LD_ADDR_OWVAR 21
103018: PUSH
103019: LD_INT 2
103021: ST_TO_ADDR
// hc_name := Dark Warrior ;
103022: LD_ADDR_OWVAR 26
103026: PUSH
103027: LD_STRING Dark Warrior
103029: ST_TO_ADDR
// hc_gallery :=  ;
103030: LD_ADDR_OWVAR 33
103034: PUSH
103035: LD_STRING 
103037: ST_TO_ADDR
// hc_noskilllimit := true ;
103038: LD_ADDR_OWVAR 76
103042: PUSH
103043: LD_INT 1
103045: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
103046: LD_ADDR_OWVAR 31
103050: PUSH
103051: LD_INT 30
103053: PUSH
103054: LD_INT 30
103056: PUSH
103057: LD_INT 30
103059: PUSH
103060: LD_INT 30
103062: PUSH
103063: EMPTY
103064: LIST
103065: LIST
103066: LIST
103067: LIST
103068: ST_TO_ADDR
// un := CreateHuman ;
103069: LD_ADDR_VAR 0 3
103073: PUSH
103074: CALL_OW 44
103078: ST_TO_ADDR
// hc_noskilllimit := false ;
103079: LD_ADDR_OWVAR 76
103083: PUSH
103084: LD_INT 0
103086: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
103087: LD_VAR 0 3
103091: PPUSH
103092: LD_INT 1
103094: PPUSH
103095: CALL_OW 51
// ToLua ( playRanger() ) ;
103099: LD_STRING playRanger()
103101: PPUSH
103102: CALL_OW 559
// p := 0 ;
103106: LD_ADDR_VAR 0 2
103110: PUSH
103111: LD_INT 0
103113: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
103114: LD_INT 35
103116: PPUSH
103117: CALL_OW 67
// p := p + 1 ;
103121: LD_ADDR_VAR 0 2
103125: PUSH
103126: LD_VAR 0 2
103130: PUSH
103131: LD_INT 1
103133: PLUS
103134: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
103135: LD_VAR 0 3
103139: PPUSH
103140: CALL_OW 256
103144: PUSH
103145: LD_INT 1000
103147: LESS
103148: IFFALSE 103162
// SetLives ( un , 1000 ) ;
103150: LD_VAR 0 3
103154: PPUSH
103155: LD_INT 1000
103157: PPUSH
103158: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
103162: LD_VAR 0 3
103166: PPUSH
103167: LD_INT 81
103169: PUSH
103170: LD_OWVAR 2
103174: PUSH
103175: EMPTY
103176: LIST
103177: LIST
103178: PUSH
103179: LD_INT 91
103181: PUSH
103182: LD_VAR 0 3
103186: PUSH
103187: LD_INT 30
103189: PUSH
103190: EMPTY
103191: LIST
103192: LIST
103193: LIST
103194: PUSH
103195: EMPTY
103196: LIST
103197: LIST
103198: PPUSH
103199: CALL_OW 69
103203: PPUSH
103204: LD_VAR 0 3
103208: PPUSH
103209: CALL_OW 74
103213: PPUSH
103214: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
103218: LD_VAR 0 2
103222: PUSH
103223: LD_INT 80
103225: GREATER
103226: PUSH
103227: LD_VAR 0 3
103231: PPUSH
103232: CALL_OW 301
103236: OR
103237: IFFALSE 103114
// if un then
103239: LD_VAR 0 3
103243: IFFALSE 103254
// RemoveUnit ( un ) ;
103245: LD_VAR 0 3
103249: PPUSH
103250: CALL_OW 64
// end ;
103254: PPOPN 3
103256: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
103257: LD_EXP 150
103261: IFFALSE 103377
103263: GO 103265
103265: DISABLE
103266: LD_INT 0
103268: PPUSH
103269: PPUSH
103270: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
103271: LD_ADDR_VAR 0 2
103275: PUSH
103276: LD_INT 81
103278: PUSH
103279: LD_OWVAR 2
103283: PUSH
103284: EMPTY
103285: LIST
103286: LIST
103287: PUSH
103288: LD_INT 21
103290: PUSH
103291: LD_INT 1
103293: PUSH
103294: EMPTY
103295: LIST
103296: LIST
103297: PUSH
103298: EMPTY
103299: LIST
103300: LIST
103301: PPUSH
103302: CALL_OW 69
103306: ST_TO_ADDR
// ToLua ( playComputer() ) ;
103307: LD_STRING playComputer()
103309: PPUSH
103310: CALL_OW 559
// if not tmp then
103314: LD_VAR 0 2
103318: NOT
103319: IFFALSE 103323
// exit ;
103321: GO 103377
// for i in tmp do
103323: LD_ADDR_VAR 0 1
103327: PUSH
103328: LD_VAR 0 2
103332: PUSH
103333: FOR_IN
103334: IFFALSE 103375
// for j := 1 to 4 do
103336: LD_ADDR_VAR 0 3
103340: PUSH
103341: DOUBLE
103342: LD_INT 1
103344: DEC
103345: ST_TO_ADDR
103346: LD_INT 4
103348: PUSH
103349: FOR_TO
103350: IFFALSE 103371
// SetSkill ( i , j , 10 ) ;
103352: LD_VAR 0 1
103356: PPUSH
103357: LD_VAR 0 3
103361: PPUSH
103362: LD_INT 10
103364: PPUSH
103365: CALL_OW 237
103369: GO 103349
103371: POP
103372: POP
103373: GO 103333
103375: POP
103376: POP
// end ;
103377: PPOPN 3
103379: END
// every 0 0$1 trigger s30 do var i , tmp ;
103380: LD_EXP 151
103384: IFFALSE 103453
103386: GO 103388
103388: DISABLE
103389: LD_INT 0
103391: PPUSH
103392: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
103393: LD_ADDR_VAR 0 2
103397: PUSH
103398: LD_INT 22
103400: PUSH
103401: LD_OWVAR 2
103405: PUSH
103406: EMPTY
103407: LIST
103408: LIST
103409: PPUSH
103410: CALL_OW 69
103414: ST_TO_ADDR
// if not tmp then
103415: LD_VAR 0 2
103419: NOT
103420: IFFALSE 103424
// exit ;
103422: GO 103453
// for i in tmp do
103424: LD_ADDR_VAR 0 1
103428: PUSH
103429: LD_VAR 0 2
103433: PUSH
103434: FOR_IN
103435: IFFALSE 103451
// SetLives ( i , 300 ) ;
103437: LD_VAR 0 1
103441: PPUSH
103442: LD_INT 300
103444: PPUSH
103445: CALL_OW 234
103449: GO 103434
103451: POP
103452: POP
// end ;
103453: PPOPN 2
103455: END
// every 0 0$1 trigger s60 do var i , tmp ;
103456: LD_EXP 152
103460: IFFALSE 103529
103462: GO 103464
103464: DISABLE
103465: LD_INT 0
103467: PPUSH
103468: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
103469: LD_ADDR_VAR 0 2
103473: PUSH
103474: LD_INT 22
103476: PUSH
103477: LD_OWVAR 2
103481: PUSH
103482: EMPTY
103483: LIST
103484: LIST
103485: PPUSH
103486: CALL_OW 69
103490: ST_TO_ADDR
// if not tmp then
103491: LD_VAR 0 2
103495: NOT
103496: IFFALSE 103500
// exit ;
103498: GO 103529
// for i in tmp do
103500: LD_ADDR_VAR 0 1
103504: PUSH
103505: LD_VAR 0 2
103509: PUSH
103510: FOR_IN
103511: IFFALSE 103527
// SetLives ( i , 600 ) ;
103513: LD_VAR 0 1
103517: PPUSH
103518: LD_INT 600
103520: PPUSH
103521: CALL_OW 234
103525: GO 103510
103527: POP
103528: POP
// end ;
103529: PPOPN 2
103531: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
103532: LD_INT 0
103534: PPUSH
// case cmd of 301 :
103535: LD_VAR 0 1
103539: PUSH
103540: LD_INT 301
103542: DOUBLE
103543: EQUAL
103544: IFTRUE 103548
103546: GO 103580
103548: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
103549: LD_VAR 0 6
103553: PPUSH
103554: LD_VAR 0 7
103558: PPUSH
103559: LD_VAR 0 8
103563: PPUSH
103564: LD_VAR 0 4
103568: PPUSH
103569: LD_VAR 0 5
103573: PPUSH
103574: CALL 104789 0 5
103578: GO 103701
103580: LD_INT 302
103582: DOUBLE
103583: EQUAL
103584: IFTRUE 103588
103586: GO 103625
103588: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
103589: LD_VAR 0 6
103593: PPUSH
103594: LD_VAR 0 7
103598: PPUSH
103599: LD_VAR 0 8
103603: PPUSH
103604: LD_VAR 0 9
103608: PPUSH
103609: LD_VAR 0 4
103613: PPUSH
103614: LD_VAR 0 5
103618: PPUSH
103619: CALL 104880 0 6
103623: GO 103701
103625: LD_INT 303
103627: DOUBLE
103628: EQUAL
103629: IFTRUE 103633
103631: GO 103670
103633: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
103634: LD_VAR 0 6
103638: PPUSH
103639: LD_VAR 0 7
103643: PPUSH
103644: LD_VAR 0 8
103648: PPUSH
103649: LD_VAR 0 9
103653: PPUSH
103654: LD_VAR 0 4
103658: PPUSH
103659: LD_VAR 0 5
103663: PPUSH
103664: CALL 103706 0 6
103668: GO 103701
103670: LD_INT 304
103672: DOUBLE
103673: EQUAL
103674: IFTRUE 103678
103676: GO 103700
103678: POP
// hHackTeleport ( unit , x , y ) ; end ;
103679: LD_VAR 0 2
103683: PPUSH
103684: LD_VAR 0 4
103688: PPUSH
103689: LD_VAR 0 5
103693: PPUSH
103694: CALL 105473 0 3
103698: GO 103701
103700: POP
// end ;
103701: LD_VAR 0 12
103705: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
103706: LD_INT 0
103708: PPUSH
103709: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
103710: LD_VAR 0 1
103714: PUSH
103715: LD_INT 1
103717: LESS
103718: PUSH
103719: LD_VAR 0 1
103723: PUSH
103724: LD_INT 3
103726: GREATER
103727: OR
103728: PUSH
103729: LD_VAR 0 5
103733: PPUSH
103734: LD_VAR 0 6
103738: PPUSH
103739: CALL_OW 428
103743: OR
103744: IFFALSE 103748
// exit ;
103746: GO 104476
// uc_side := your_side ;
103748: LD_ADDR_OWVAR 20
103752: PUSH
103753: LD_OWVAR 2
103757: ST_TO_ADDR
// uc_nation := nation ;
103758: LD_ADDR_OWVAR 21
103762: PUSH
103763: LD_VAR 0 1
103767: ST_TO_ADDR
// bc_level = 1 ;
103768: LD_ADDR_OWVAR 43
103772: PUSH
103773: LD_INT 1
103775: ST_TO_ADDR
// case btype of 1 :
103776: LD_VAR 0 2
103780: PUSH
103781: LD_INT 1
103783: DOUBLE
103784: EQUAL
103785: IFTRUE 103789
103787: GO 103800
103789: POP
// bc_type := b_depot ; 2 :
103790: LD_ADDR_OWVAR 42
103794: PUSH
103795: LD_INT 0
103797: ST_TO_ADDR
103798: GO 104420
103800: LD_INT 2
103802: DOUBLE
103803: EQUAL
103804: IFTRUE 103808
103806: GO 103819
103808: POP
// bc_type := b_warehouse ; 3 :
103809: LD_ADDR_OWVAR 42
103813: PUSH
103814: LD_INT 1
103816: ST_TO_ADDR
103817: GO 104420
103819: LD_INT 3
103821: DOUBLE
103822: EQUAL
103823: IFTRUE 103827
103825: GO 103838
103827: POP
// bc_type := b_lab ; 4 .. 9 :
103828: LD_ADDR_OWVAR 42
103832: PUSH
103833: LD_INT 6
103835: ST_TO_ADDR
103836: GO 104420
103838: LD_INT 4
103840: DOUBLE
103841: GREATEREQUAL
103842: IFFALSE 103850
103844: LD_INT 9
103846: DOUBLE
103847: LESSEQUAL
103848: IFTRUE 103852
103850: GO 103912
103852: POP
// begin bc_type := b_lab_half ;
103853: LD_ADDR_OWVAR 42
103857: PUSH
103858: LD_INT 7
103860: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
103861: LD_ADDR_OWVAR 44
103865: PUSH
103866: LD_INT 10
103868: PUSH
103869: LD_INT 11
103871: PUSH
103872: LD_INT 12
103874: PUSH
103875: LD_INT 15
103877: PUSH
103878: LD_INT 14
103880: PUSH
103881: LD_INT 13
103883: PUSH
103884: EMPTY
103885: LIST
103886: LIST
103887: LIST
103888: LIST
103889: LIST
103890: LIST
103891: PUSH
103892: LD_VAR 0 2
103896: PUSH
103897: LD_INT 3
103899: MINUS
103900: ARRAY
103901: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
103902: LD_ADDR_OWVAR 45
103906: PUSH
103907: LD_INT 9
103909: ST_TO_ADDR
// end ; 10 .. 13 :
103910: GO 104420
103912: LD_INT 10
103914: DOUBLE
103915: GREATEREQUAL
103916: IFFALSE 103924
103918: LD_INT 13
103920: DOUBLE
103921: LESSEQUAL
103922: IFTRUE 103926
103924: GO 104003
103926: POP
// begin bc_type := b_lab_full ;
103927: LD_ADDR_OWVAR 42
103931: PUSH
103932: LD_INT 8
103934: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
103935: LD_ADDR_OWVAR 44
103939: PUSH
103940: LD_INT 10
103942: PUSH
103943: LD_INT 12
103945: PUSH
103946: LD_INT 14
103948: PUSH
103949: LD_INT 13
103951: PUSH
103952: EMPTY
103953: LIST
103954: LIST
103955: LIST
103956: LIST
103957: PUSH
103958: LD_VAR 0 2
103962: PUSH
103963: LD_INT 9
103965: MINUS
103966: ARRAY
103967: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
103968: LD_ADDR_OWVAR 45
103972: PUSH
103973: LD_INT 11
103975: PUSH
103976: LD_INT 15
103978: PUSH
103979: LD_INT 12
103981: PUSH
103982: LD_INT 15
103984: PUSH
103985: EMPTY
103986: LIST
103987: LIST
103988: LIST
103989: LIST
103990: PUSH
103991: LD_VAR 0 2
103995: PUSH
103996: LD_INT 9
103998: MINUS
103999: ARRAY
104000: ST_TO_ADDR
// end ; 14 :
104001: GO 104420
104003: LD_INT 14
104005: DOUBLE
104006: EQUAL
104007: IFTRUE 104011
104009: GO 104022
104011: POP
// bc_type := b_workshop ; 15 :
104012: LD_ADDR_OWVAR 42
104016: PUSH
104017: LD_INT 2
104019: ST_TO_ADDR
104020: GO 104420
104022: LD_INT 15
104024: DOUBLE
104025: EQUAL
104026: IFTRUE 104030
104028: GO 104041
104030: POP
// bc_type := b_factory ; 16 :
104031: LD_ADDR_OWVAR 42
104035: PUSH
104036: LD_INT 3
104038: ST_TO_ADDR
104039: GO 104420
104041: LD_INT 16
104043: DOUBLE
104044: EQUAL
104045: IFTRUE 104049
104047: GO 104060
104049: POP
// bc_type := b_ext_gun ; 17 :
104050: LD_ADDR_OWVAR 42
104054: PUSH
104055: LD_INT 17
104057: ST_TO_ADDR
104058: GO 104420
104060: LD_INT 17
104062: DOUBLE
104063: EQUAL
104064: IFTRUE 104068
104066: GO 104096
104068: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
104069: LD_ADDR_OWVAR 42
104073: PUSH
104074: LD_INT 19
104076: PUSH
104077: LD_INT 23
104079: PUSH
104080: LD_INT 19
104082: PUSH
104083: EMPTY
104084: LIST
104085: LIST
104086: LIST
104087: PUSH
104088: LD_VAR 0 1
104092: ARRAY
104093: ST_TO_ADDR
104094: GO 104420
104096: LD_INT 18
104098: DOUBLE
104099: EQUAL
104100: IFTRUE 104104
104102: GO 104115
104104: POP
// bc_type := b_ext_radar ; 19 :
104105: LD_ADDR_OWVAR 42
104109: PUSH
104110: LD_INT 20
104112: ST_TO_ADDR
104113: GO 104420
104115: LD_INT 19
104117: DOUBLE
104118: EQUAL
104119: IFTRUE 104123
104121: GO 104134
104123: POP
// bc_type := b_ext_radio ; 20 :
104124: LD_ADDR_OWVAR 42
104128: PUSH
104129: LD_INT 22
104131: ST_TO_ADDR
104132: GO 104420
104134: LD_INT 20
104136: DOUBLE
104137: EQUAL
104138: IFTRUE 104142
104140: GO 104153
104142: POP
// bc_type := b_ext_siberium ; 21 :
104143: LD_ADDR_OWVAR 42
104147: PUSH
104148: LD_INT 21
104150: ST_TO_ADDR
104151: GO 104420
104153: LD_INT 21
104155: DOUBLE
104156: EQUAL
104157: IFTRUE 104161
104159: GO 104172
104161: POP
// bc_type := b_ext_computer ; 22 :
104162: LD_ADDR_OWVAR 42
104166: PUSH
104167: LD_INT 24
104169: ST_TO_ADDR
104170: GO 104420
104172: LD_INT 22
104174: DOUBLE
104175: EQUAL
104176: IFTRUE 104180
104178: GO 104191
104180: POP
// bc_type := b_ext_track ; 23 :
104181: LD_ADDR_OWVAR 42
104185: PUSH
104186: LD_INT 16
104188: ST_TO_ADDR
104189: GO 104420
104191: LD_INT 23
104193: DOUBLE
104194: EQUAL
104195: IFTRUE 104199
104197: GO 104210
104199: POP
// bc_type := b_ext_laser ; 24 :
104200: LD_ADDR_OWVAR 42
104204: PUSH
104205: LD_INT 25
104207: ST_TO_ADDR
104208: GO 104420
104210: LD_INT 24
104212: DOUBLE
104213: EQUAL
104214: IFTRUE 104218
104216: GO 104229
104218: POP
// bc_type := b_control_tower ; 25 :
104219: LD_ADDR_OWVAR 42
104223: PUSH
104224: LD_INT 36
104226: ST_TO_ADDR
104227: GO 104420
104229: LD_INT 25
104231: DOUBLE
104232: EQUAL
104233: IFTRUE 104237
104235: GO 104248
104237: POP
// bc_type := b_breastwork ; 26 :
104238: LD_ADDR_OWVAR 42
104242: PUSH
104243: LD_INT 31
104245: ST_TO_ADDR
104246: GO 104420
104248: LD_INT 26
104250: DOUBLE
104251: EQUAL
104252: IFTRUE 104256
104254: GO 104267
104256: POP
// bc_type := b_bunker ; 27 :
104257: LD_ADDR_OWVAR 42
104261: PUSH
104262: LD_INT 32
104264: ST_TO_ADDR
104265: GO 104420
104267: LD_INT 27
104269: DOUBLE
104270: EQUAL
104271: IFTRUE 104275
104273: GO 104286
104275: POP
// bc_type := b_turret ; 28 :
104276: LD_ADDR_OWVAR 42
104280: PUSH
104281: LD_INT 33
104283: ST_TO_ADDR
104284: GO 104420
104286: LD_INT 28
104288: DOUBLE
104289: EQUAL
104290: IFTRUE 104294
104292: GO 104305
104294: POP
// bc_type := b_armoury ; 29 :
104295: LD_ADDR_OWVAR 42
104299: PUSH
104300: LD_INT 4
104302: ST_TO_ADDR
104303: GO 104420
104305: LD_INT 29
104307: DOUBLE
104308: EQUAL
104309: IFTRUE 104313
104311: GO 104324
104313: POP
// bc_type := b_barracks ; 30 :
104314: LD_ADDR_OWVAR 42
104318: PUSH
104319: LD_INT 5
104321: ST_TO_ADDR
104322: GO 104420
104324: LD_INT 30
104326: DOUBLE
104327: EQUAL
104328: IFTRUE 104332
104330: GO 104343
104332: POP
// bc_type := b_solar_power ; 31 :
104333: LD_ADDR_OWVAR 42
104337: PUSH
104338: LD_INT 27
104340: ST_TO_ADDR
104341: GO 104420
104343: LD_INT 31
104345: DOUBLE
104346: EQUAL
104347: IFTRUE 104351
104349: GO 104362
104351: POP
// bc_type := b_oil_power ; 32 :
104352: LD_ADDR_OWVAR 42
104356: PUSH
104357: LD_INT 26
104359: ST_TO_ADDR
104360: GO 104420
104362: LD_INT 32
104364: DOUBLE
104365: EQUAL
104366: IFTRUE 104370
104368: GO 104381
104370: POP
// bc_type := b_siberite_power ; 33 :
104371: LD_ADDR_OWVAR 42
104375: PUSH
104376: LD_INT 28
104378: ST_TO_ADDR
104379: GO 104420
104381: LD_INT 33
104383: DOUBLE
104384: EQUAL
104385: IFTRUE 104389
104387: GO 104400
104389: POP
// bc_type := b_oil_mine ; 34 :
104390: LD_ADDR_OWVAR 42
104394: PUSH
104395: LD_INT 29
104397: ST_TO_ADDR
104398: GO 104420
104400: LD_INT 34
104402: DOUBLE
104403: EQUAL
104404: IFTRUE 104408
104406: GO 104419
104408: POP
// bc_type := b_siberite_mine ; end ;
104409: LD_ADDR_OWVAR 42
104413: PUSH
104414: LD_INT 30
104416: ST_TO_ADDR
104417: GO 104420
104419: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
104420: LD_ADDR_VAR 0 8
104424: PUSH
104425: LD_VAR 0 5
104429: PPUSH
104430: LD_VAR 0 6
104434: PPUSH
104435: LD_VAR 0 3
104439: PPUSH
104440: CALL_OW 47
104444: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
104445: LD_OWVAR 42
104449: PUSH
104450: LD_INT 32
104452: PUSH
104453: LD_INT 33
104455: PUSH
104456: EMPTY
104457: LIST
104458: LIST
104459: IN
104460: IFFALSE 104476
// PlaceWeaponTurret ( b , weapon ) ;
104462: LD_VAR 0 8
104466: PPUSH
104467: LD_VAR 0 4
104471: PPUSH
104472: CALL_OW 431
// end ;
104476: LD_VAR 0 7
104480: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
104481: LD_INT 0
104483: PPUSH
104484: PPUSH
104485: PPUSH
104486: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
104487: LD_ADDR_VAR 0 4
104491: PUSH
104492: LD_INT 22
104494: PUSH
104495: LD_OWVAR 2
104499: PUSH
104500: EMPTY
104501: LIST
104502: LIST
104503: PUSH
104504: LD_INT 2
104506: PUSH
104507: LD_INT 30
104509: PUSH
104510: LD_INT 0
104512: PUSH
104513: EMPTY
104514: LIST
104515: LIST
104516: PUSH
104517: LD_INT 30
104519: PUSH
104520: LD_INT 1
104522: PUSH
104523: EMPTY
104524: LIST
104525: LIST
104526: PUSH
104527: EMPTY
104528: LIST
104529: LIST
104530: LIST
104531: PUSH
104532: EMPTY
104533: LIST
104534: LIST
104535: PPUSH
104536: CALL_OW 69
104540: ST_TO_ADDR
// if not tmp then
104541: LD_VAR 0 4
104545: NOT
104546: IFFALSE 104550
// exit ;
104548: GO 104609
// for i in tmp do
104550: LD_ADDR_VAR 0 2
104554: PUSH
104555: LD_VAR 0 4
104559: PUSH
104560: FOR_IN
104561: IFFALSE 104607
// for j = 1 to 3 do
104563: LD_ADDR_VAR 0 3
104567: PUSH
104568: DOUBLE
104569: LD_INT 1
104571: DEC
104572: ST_TO_ADDR
104573: LD_INT 3
104575: PUSH
104576: FOR_TO
104577: IFFALSE 104603
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
104579: LD_VAR 0 2
104583: PPUSH
104584: CALL_OW 274
104588: PPUSH
104589: LD_VAR 0 3
104593: PPUSH
104594: LD_INT 99999
104596: PPUSH
104597: CALL_OW 277
104601: GO 104576
104603: POP
104604: POP
104605: GO 104560
104607: POP
104608: POP
// end ;
104609: LD_VAR 0 1
104613: RET
// export function hHackSetLevel10 ; var i , j ; begin
104614: LD_INT 0
104616: PPUSH
104617: PPUSH
104618: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
104619: LD_ADDR_VAR 0 2
104623: PUSH
104624: LD_INT 21
104626: PUSH
104627: LD_INT 1
104629: PUSH
104630: EMPTY
104631: LIST
104632: LIST
104633: PPUSH
104634: CALL_OW 69
104638: PUSH
104639: FOR_IN
104640: IFFALSE 104692
// if IsSelected ( i ) then
104642: LD_VAR 0 2
104646: PPUSH
104647: CALL_OW 306
104651: IFFALSE 104690
// begin for j := 1 to 4 do
104653: LD_ADDR_VAR 0 3
104657: PUSH
104658: DOUBLE
104659: LD_INT 1
104661: DEC
104662: ST_TO_ADDR
104663: LD_INT 4
104665: PUSH
104666: FOR_TO
104667: IFFALSE 104688
// SetSkill ( i , j , 10 ) ;
104669: LD_VAR 0 2
104673: PPUSH
104674: LD_VAR 0 3
104678: PPUSH
104679: LD_INT 10
104681: PPUSH
104682: CALL_OW 237
104686: GO 104666
104688: POP
104689: POP
// end ;
104690: GO 104639
104692: POP
104693: POP
// end ;
104694: LD_VAR 0 1
104698: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
104699: LD_INT 0
104701: PPUSH
104702: PPUSH
104703: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
104704: LD_ADDR_VAR 0 2
104708: PUSH
104709: LD_INT 22
104711: PUSH
104712: LD_OWVAR 2
104716: PUSH
104717: EMPTY
104718: LIST
104719: LIST
104720: PUSH
104721: LD_INT 21
104723: PUSH
104724: LD_INT 1
104726: PUSH
104727: EMPTY
104728: LIST
104729: LIST
104730: PUSH
104731: EMPTY
104732: LIST
104733: LIST
104734: PPUSH
104735: CALL_OW 69
104739: PUSH
104740: FOR_IN
104741: IFFALSE 104782
// begin for j := 1 to 4 do
104743: LD_ADDR_VAR 0 3
104747: PUSH
104748: DOUBLE
104749: LD_INT 1
104751: DEC
104752: ST_TO_ADDR
104753: LD_INT 4
104755: PUSH
104756: FOR_TO
104757: IFFALSE 104778
// SetSkill ( i , j , 10 ) ;
104759: LD_VAR 0 2
104763: PPUSH
104764: LD_VAR 0 3
104768: PPUSH
104769: LD_INT 10
104771: PPUSH
104772: CALL_OW 237
104776: GO 104756
104778: POP
104779: POP
// end ;
104780: GO 104740
104782: POP
104783: POP
// end ;
104784: LD_VAR 0 1
104788: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
104789: LD_INT 0
104791: PPUSH
// uc_side := your_side ;
104792: LD_ADDR_OWVAR 20
104796: PUSH
104797: LD_OWVAR 2
104801: ST_TO_ADDR
// uc_nation := nation ;
104802: LD_ADDR_OWVAR 21
104806: PUSH
104807: LD_VAR 0 1
104811: ST_TO_ADDR
// InitHc ;
104812: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
104816: LD_INT 0
104818: PPUSH
104819: LD_VAR 0 2
104823: PPUSH
104824: LD_VAR 0 3
104828: PPUSH
104829: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
104833: LD_VAR 0 4
104837: PPUSH
104838: LD_VAR 0 5
104842: PPUSH
104843: CALL_OW 428
104847: PUSH
104848: LD_INT 0
104850: EQUAL
104851: IFFALSE 104875
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
104853: CALL_OW 44
104857: PPUSH
104858: LD_VAR 0 4
104862: PPUSH
104863: LD_VAR 0 5
104867: PPUSH
104868: LD_INT 1
104870: PPUSH
104871: CALL_OW 48
// end ;
104875: LD_VAR 0 6
104879: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
104880: LD_INT 0
104882: PPUSH
104883: PPUSH
// uc_side := your_side ;
104884: LD_ADDR_OWVAR 20
104888: PUSH
104889: LD_OWVAR 2
104893: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
104894: LD_VAR 0 1
104898: PUSH
104899: LD_INT 1
104901: PUSH
104902: LD_INT 2
104904: PUSH
104905: LD_INT 3
104907: PUSH
104908: LD_INT 4
104910: PUSH
104911: LD_INT 5
104913: PUSH
104914: EMPTY
104915: LIST
104916: LIST
104917: LIST
104918: LIST
104919: LIST
104920: IN
104921: IFFALSE 104933
// uc_nation := nation_american else
104923: LD_ADDR_OWVAR 21
104927: PUSH
104928: LD_INT 1
104930: ST_TO_ADDR
104931: GO 104976
// if chassis in [ 11 , 12 , 13 , 14 ] then
104933: LD_VAR 0 1
104937: PUSH
104938: LD_INT 11
104940: PUSH
104941: LD_INT 12
104943: PUSH
104944: LD_INT 13
104946: PUSH
104947: LD_INT 14
104949: PUSH
104950: EMPTY
104951: LIST
104952: LIST
104953: LIST
104954: LIST
104955: IN
104956: IFFALSE 104968
// uc_nation := nation_arabian else
104958: LD_ADDR_OWVAR 21
104962: PUSH
104963: LD_INT 2
104965: ST_TO_ADDR
104966: GO 104976
// uc_nation := nation_russian ;
104968: LD_ADDR_OWVAR 21
104972: PUSH
104973: LD_INT 3
104975: ST_TO_ADDR
// vc_chassis := chassis ;
104976: LD_ADDR_OWVAR 37
104980: PUSH
104981: LD_VAR 0 1
104985: ST_TO_ADDR
// vc_engine := engine ;
104986: LD_ADDR_OWVAR 39
104990: PUSH
104991: LD_VAR 0 2
104995: ST_TO_ADDR
// vc_control := control ;
104996: LD_ADDR_OWVAR 38
105000: PUSH
105001: LD_VAR 0 3
105005: ST_TO_ADDR
// vc_weapon := weapon ;
105006: LD_ADDR_OWVAR 40
105010: PUSH
105011: LD_VAR 0 4
105015: ST_TO_ADDR
// un := CreateVehicle ;
105016: LD_ADDR_VAR 0 8
105020: PUSH
105021: CALL_OW 45
105025: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
105026: LD_VAR 0 8
105030: PPUSH
105031: LD_INT 0
105033: PPUSH
105034: LD_INT 5
105036: PPUSH
105037: CALL_OW 12
105041: PPUSH
105042: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
105046: LD_VAR 0 8
105050: PPUSH
105051: LD_VAR 0 5
105055: PPUSH
105056: LD_VAR 0 6
105060: PPUSH
105061: LD_INT 1
105063: PPUSH
105064: CALL_OW 48
// end ;
105068: LD_VAR 0 7
105072: RET
// export hInvincible ; every 1 do
105073: GO 105075
105075: DISABLE
// hInvincible := [ ] ;
105076: LD_ADDR_EXP 153
105080: PUSH
105081: EMPTY
105082: ST_TO_ADDR
105083: END
// every 10 do var i ;
105084: GO 105086
105086: DISABLE
105087: LD_INT 0
105089: PPUSH
// begin enable ;
105090: ENABLE
// if not hInvincible then
105091: LD_EXP 153
105095: NOT
105096: IFFALSE 105100
// exit ;
105098: GO 105144
// for i in hInvincible do
105100: LD_ADDR_VAR 0 1
105104: PUSH
105105: LD_EXP 153
105109: PUSH
105110: FOR_IN
105111: IFFALSE 105142
// if GetLives ( i ) < 1000 then
105113: LD_VAR 0 1
105117: PPUSH
105118: CALL_OW 256
105122: PUSH
105123: LD_INT 1000
105125: LESS
105126: IFFALSE 105140
// SetLives ( i , 1000 ) ;
105128: LD_VAR 0 1
105132: PPUSH
105133: LD_INT 1000
105135: PPUSH
105136: CALL_OW 234
105140: GO 105110
105142: POP
105143: POP
// end ;
105144: PPOPN 1
105146: END
// export function hHackInvincible ; var i ; begin
105147: LD_INT 0
105149: PPUSH
105150: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
105151: LD_ADDR_VAR 0 2
105155: PUSH
105156: LD_INT 2
105158: PUSH
105159: LD_INT 21
105161: PUSH
105162: LD_INT 1
105164: PUSH
105165: EMPTY
105166: LIST
105167: LIST
105168: PUSH
105169: LD_INT 21
105171: PUSH
105172: LD_INT 2
105174: PUSH
105175: EMPTY
105176: LIST
105177: LIST
105178: PUSH
105179: EMPTY
105180: LIST
105181: LIST
105182: LIST
105183: PPUSH
105184: CALL_OW 69
105188: PUSH
105189: FOR_IN
105190: IFFALSE 105251
// if IsSelected ( i ) then
105192: LD_VAR 0 2
105196: PPUSH
105197: CALL_OW 306
105201: IFFALSE 105249
// begin if i in hInvincible then
105203: LD_VAR 0 2
105207: PUSH
105208: LD_EXP 153
105212: IN
105213: IFFALSE 105233
// hInvincible := hInvincible diff i else
105215: LD_ADDR_EXP 153
105219: PUSH
105220: LD_EXP 153
105224: PUSH
105225: LD_VAR 0 2
105229: DIFF
105230: ST_TO_ADDR
105231: GO 105249
// hInvincible := hInvincible union i ;
105233: LD_ADDR_EXP 153
105237: PUSH
105238: LD_EXP 153
105242: PUSH
105243: LD_VAR 0 2
105247: UNION
105248: ST_TO_ADDR
// end ;
105249: GO 105189
105251: POP
105252: POP
// end ;
105253: LD_VAR 0 1
105257: RET
// export function hHackInvisible ; var i , j ; begin
105258: LD_INT 0
105260: PPUSH
105261: PPUSH
105262: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
105263: LD_ADDR_VAR 0 2
105267: PUSH
105268: LD_INT 21
105270: PUSH
105271: LD_INT 1
105273: PUSH
105274: EMPTY
105275: LIST
105276: LIST
105277: PPUSH
105278: CALL_OW 69
105282: PUSH
105283: FOR_IN
105284: IFFALSE 105308
// if IsSelected ( i ) then
105286: LD_VAR 0 2
105290: PPUSH
105291: CALL_OW 306
105295: IFFALSE 105306
// ComForceInvisible ( i ) ;
105297: LD_VAR 0 2
105301: PPUSH
105302: CALL_OW 496
105306: GO 105283
105308: POP
105309: POP
// end ;
105310: LD_VAR 0 1
105314: RET
// export function hHackChangeYourSide ; begin
105315: LD_INT 0
105317: PPUSH
// if your_side = 8 then
105318: LD_OWVAR 2
105322: PUSH
105323: LD_INT 8
105325: EQUAL
105326: IFFALSE 105338
// your_side := 0 else
105328: LD_ADDR_OWVAR 2
105332: PUSH
105333: LD_INT 0
105335: ST_TO_ADDR
105336: GO 105352
// your_side := your_side + 1 ;
105338: LD_ADDR_OWVAR 2
105342: PUSH
105343: LD_OWVAR 2
105347: PUSH
105348: LD_INT 1
105350: PLUS
105351: ST_TO_ADDR
// end ;
105352: LD_VAR 0 1
105356: RET
// export function hHackChangeUnitSide ; var i , j ; begin
105357: LD_INT 0
105359: PPUSH
105360: PPUSH
105361: PPUSH
// for i in all_units do
105362: LD_ADDR_VAR 0 2
105366: PUSH
105367: LD_OWVAR 3
105371: PUSH
105372: FOR_IN
105373: IFFALSE 105451
// if IsSelected ( i ) then
105375: LD_VAR 0 2
105379: PPUSH
105380: CALL_OW 306
105384: IFFALSE 105449
// begin j := GetSide ( i ) ;
105386: LD_ADDR_VAR 0 3
105390: PUSH
105391: LD_VAR 0 2
105395: PPUSH
105396: CALL_OW 255
105400: ST_TO_ADDR
// if j = 8 then
105401: LD_VAR 0 3
105405: PUSH
105406: LD_INT 8
105408: EQUAL
105409: IFFALSE 105421
// j := 0 else
105411: LD_ADDR_VAR 0 3
105415: PUSH
105416: LD_INT 0
105418: ST_TO_ADDR
105419: GO 105435
// j := j + 1 ;
105421: LD_ADDR_VAR 0 3
105425: PUSH
105426: LD_VAR 0 3
105430: PUSH
105431: LD_INT 1
105433: PLUS
105434: ST_TO_ADDR
// SetSide ( i , j ) ;
105435: LD_VAR 0 2
105439: PPUSH
105440: LD_VAR 0 3
105444: PPUSH
105445: CALL_OW 235
// end ;
105449: GO 105372
105451: POP
105452: POP
// end ;
105453: LD_VAR 0 1
105457: RET
// export function hHackFog ; begin
105458: LD_INT 0
105460: PPUSH
// FogOff ( true ) ;
105461: LD_INT 1
105463: PPUSH
105464: CALL_OW 344
// end ;
105468: LD_VAR 0 1
105472: RET
// export function hHackTeleport ( unit , x , y ) ; begin
105473: LD_INT 0
105475: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
105476: LD_VAR 0 1
105480: PPUSH
105481: LD_VAR 0 2
105485: PPUSH
105486: LD_VAR 0 3
105490: PPUSH
105491: LD_INT 1
105493: PPUSH
105494: LD_INT 1
105496: PPUSH
105497: CALL_OW 483
// CenterOnXY ( x , y ) ;
105501: LD_VAR 0 2
105505: PPUSH
105506: LD_VAR 0 3
105510: PPUSH
105511: CALL_OW 84
// end ;
105515: LD_VAR 0 4
105519: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
105520: LD_INT 0
105522: PPUSH
105523: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
105524: LD_VAR 0 1
105528: NOT
105529: PUSH
105530: LD_VAR 0 2
105534: PPUSH
105535: LD_VAR 0 3
105539: PPUSH
105540: CALL_OW 488
105544: NOT
105545: OR
105546: PUSH
105547: LD_VAR 0 1
105551: PPUSH
105552: CALL_OW 266
105556: PUSH
105557: LD_INT 3
105559: NONEQUAL
105560: PUSH
105561: LD_VAR 0 1
105565: PPUSH
105566: CALL_OW 247
105570: PUSH
105571: LD_INT 1
105573: EQUAL
105574: NOT
105575: AND
105576: OR
105577: IFFALSE 105581
// exit ;
105579: GO 105730
// if GetType ( factory ) = unit_human then
105581: LD_VAR 0 1
105585: PPUSH
105586: CALL_OW 247
105590: PUSH
105591: LD_INT 1
105593: EQUAL
105594: IFFALSE 105611
// factory := IsInUnit ( factory ) ;
105596: LD_ADDR_VAR 0 1
105600: PUSH
105601: LD_VAR 0 1
105605: PPUSH
105606: CALL_OW 310
105610: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
105611: LD_VAR 0 1
105615: PPUSH
105616: CALL_OW 266
105620: PUSH
105621: LD_INT 3
105623: NONEQUAL
105624: IFFALSE 105628
// exit ;
105626: GO 105730
// if HexInfo ( x , y ) = factory then
105628: LD_VAR 0 2
105632: PPUSH
105633: LD_VAR 0 3
105637: PPUSH
105638: CALL_OW 428
105642: PUSH
105643: LD_VAR 0 1
105647: EQUAL
105648: IFFALSE 105675
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
105650: LD_ADDR_EXP 154
105654: PUSH
105655: LD_EXP 154
105659: PPUSH
105660: LD_VAR 0 1
105664: PPUSH
105665: LD_INT 0
105667: PPUSH
105668: CALL_OW 1
105672: ST_TO_ADDR
105673: GO 105726
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
105675: LD_ADDR_EXP 154
105679: PUSH
105680: LD_EXP 154
105684: PPUSH
105685: LD_VAR 0 1
105689: PPUSH
105690: LD_VAR 0 1
105694: PPUSH
105695: CALL_OW 255
105699: PUSH
105700: LD_VAR 0 1
105704: PUSH
105705: LD_VAR 0 2
105709: PUSH
105710: LD_VAR 0 3
105714: PUSH
105715: EMPTY
105716: LIST
105717: LIST
105718: LIST
105719: LIST
105720: PPUSH
105721: CALL_OW 1
105725: ST_TO_ADDR
// UpdateFactoryWaypoints ;
105726: CALL 105735 0 0
// end ;
105730: LD_VAR 0 4
105734: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
105735: LD_INT 0
105737: PPUSH
105738: PPUSH
105739: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
105740: LD_STRING resetFactoryWaypoint();
105742: PPUSH
105743: CALL_OW 559
// if factoryWaypoints then
105747: LD_EXP 154
105751: IFFALSE 105877
// begin list := PrepareArray ( factoryWaypoints ) ;
105753: LD_ADDR_VAR 0 3
105757: PUSH
105758: LD_EXP 154
105762: PPUSH
105763: CALL 90565 0 1
105767: ST_TO_ADDR
// for i := 1 to list do
105768: LD_ADDR_VAR 0 2
105772: PUSH
105773: DOUBLE
105774: LD_INT 1
105776: DEC
105777: ST_TO_ADDR
105778: LD_VAR 0 3
105782: PUSH
105783: FOR_TO
105784: IFFALSE 105875
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
105786: LD_STRING setFactoryWaypointXY(
105788: PUSH
105789: LD_VAR 0 3
105793: PUSH
105794: LD_VAR 0 2
105798: ARRAY
105799: PUSH
105800: LD_INT 1
105802: ARRAY
105803: STR
105804: PUSH
105805: LD_STRING ,
105807: STR
105808: PUSH
105809: LD_VAR 0 3
105813: PUSH
105814: LD_VAR 0 2
105818: ARRAY
105819: PUSH
105820: LD_INT 2
105822: ARRAY
105823: STR
105824: PUSH
105825: LD_STRING ,
105827: STR
105828: PUSH
105829: LD_VAR 0 3
105833: PUSH
105834: LD_VAR 0 2
105838: ARRAY
105839: PUSH
105840: LD_INT 3
105842: ARRAY
105843: STR
105844: PUSH
105845: LD_STRING ,
105847: STR
105848: PUSH
105849: LD_VAR 0 3
105853: PUSH
105854: LD_VAR 0 2
105858: ARRAY
105859: PUSH
105860: LD_INT 4
105862: ARRAY
105863: STR
105864: PUSH
105865: LD_STRING )
105867: STR
105868: PPUSH
105869: CALL_OW 559
105873: GO 105783
105875: POP
105876: POP
// end ; end ;
105877: LD_VAR 0 1
105881: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
105882: LD_INT 0
105884: PPUSH
// if HexInfo ( x , y ) = warehouse then
105885: LD_VAR 0 2
105889: PPUSH
105890: LD_VAR 0 3
105894: PPUSH
105895: CALL_OW 428
105899: PUSH
105900: LD_VAR 0 1
105904: EQUAL
105905: IFFALSE 105932
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
105907: LD_ADDR_EXP 155
105911: PUSH
105912: LD_EXP 155
105916: PPUSH
105917: LD_VAR 0 1
105921: PPUSH
105922: LD_INT 0
105924: PPUSH
105925: CALL_OW 1
105929: ST_TO_ADDR
105930: GO 105983
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
105932: LD_ADDR_EXP 155
105936: PUSH
105937: LD_EXP 155
105941: PPUSH
105942: LD_VAR 0 1
105946: PPUSH
105947: LD_VAR 0 1
105951: PPUSH
105952: CALL_OW 255
105956: PUSH
105957: LD_VAR 0 1
105961: PUSH
105962: LD_VAR 0 2
105966: PUSH
105967: LD_VAR 0 3
105971: PUSH
105972: EMPTY
105973: LIST
105974: LIST
105975: LIST
105976: LIST
105977: PPUSH
105978: CALL_OW 1
105982: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
105983: CALL 105992 0 0
// end ;
105987: LD_VAR 0 4
105991: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
105992: LD_INT 0
105994: PPUSH
105995: PPUSH
105996: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
105997: LD_STRING resetWarehouseGatheringPoints();
105999: PPUSH
106000: CALL_OW 559
// if warehouseGatheringPoints then
106004: LD_EXP 155
106008: IFFALSE 106134
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
106010: LD_ADDR_VAR 0 3
106014: PUSH
106015: LD_EXP 155
106019: PPUSH
106020: CALL 90565 0 1
106024: ST_TO_ADDR
// for i := 1 to list do
106025: LD_ADDR_VAR 0 2
106029: PUSH
106030: DOUBLE
106031: LD_INT 1
106033: DEC
106034: ST_TO_ADDR
106035: LD_VAR 0 3
106039: PUSH
106040: FOR_TO
106041: IFFALSE 106132
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
106043: LD_STRING setWarehouseGatheringPointXY(
106045: PUSH
106046: LD_VAR 0 3
106050: PUSH
106051: LD_VAR 0 2
106055: ARRAY
106056: PUSH
106057: LD_INT 1
106059: ARRAY
106060: STR
106061: PUSH
106062: LD_STRING ,
106064: STR
106065: PUSH
106066: LD_VAR 0 3
106070: PUSH
106071: LD_VAR 0 2
106075: ARRAY
106076: PUSH
106077: LD_INT 2
106079: ARRAY
106080: STR
106081: PUSH
106082: LD_STRING ,
106084: STR
106085: PUSH
106086: LD_VAR 0 3
106090: PUSH
106091: LD_VAR 0 2
106095: ARRAY
106096: PUSH
106097: LD_INT 3
106099: ARRAY
106100: STR
106101: PUSH
106102: LD_STRING ,
106104: STR
106105: PUSH
106106: LD_VAR 0 3
106110: PUSH
106111: LD_VAR 0 2
106115: ARRAY
106116: PUSH
106117: LD_INT 4
106119: ARRAY
106120: STR
106121: PUSH
106122: LD_STRING )
106124: STR
106125: PPUSH
106126: CALL_OW 559
106130: GO 106040
106132: POP
106133: POP
// end ; end ;
106134: LD_VAR 0 1
106138: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
106139: LD_EXP 155
106143: IFFALSE 106828
106145: GO 106147
106147: DISABLE
106148: LD_INT 0
106150: PPUSH
106151: PPUSH
106152: PPUSH
106153: PPUSH
106154: PPUSH
106155: PPUSH
106156: PPUSH
106157: PPUSH
106158: PPUSH
// begin enable ;
106159: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
106160: LD_ADDR_VAR 0 3
106164: PUSH
106165: LD_EXP 155
106169: PPUSH
106170: CALL 90565 0 1
106174: ST_TO_ADDR
// if not list then
106175: LD_VAR 0 3
106179: NOT
106180: IFFALSE 106184
// exit ;
106182: GO 106828
// for i := 1 to list do
106184: LD_ADDR_VAR 0 1
106188: PUSH
106189: DOUBLE
106190: LD_INT 1
106192: DEC
106193: ST_TO_ADDR
106194: LD_VAR 0 3
106198: PUSH
106199: FOR_TO
106200: IFFALSE 106826
// begin depot := list [ i ] [ 2 ] ;
106202: LD_ADDR_VAR 0 8
106206: PUSH
106207: LD_VAR 0 3
106211: PUSH
106212: LD_VAR 0 1
106216: ARRAY
106217: PUSH
106218: LD_INT 2
106220: ARRAY
106221: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
106222: LD_ADDR_VAR 0 5
106226: PUSH
106227: LD_VAR 0 3
106231: PUSH
106232: LD_VAR 0 1
106236: ARRAY
106237: PUSH
106238: LD_INT 1
106240: ARRAY
106241: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
106242: LD_VAR 0 8
106246: PPUSH
106247: CALL_OW 301
106251: PUSH
106252: LD_VAR 0 5
106256: PUSH
106257: LD_VAR 0 8
106261: PPUSH
106262: CALL_OW 255
106266: NONEQUAL
106267: OR
106268: IFFALSE 106297
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
106270: LD_ADDR_EXP 155
106274: PUSH
106275: LD_EXP 155
106279: PPUSH
106280: LD_VAR 0 8
106284: PPUSH
106285: LD_INT 0
106287: PPUSH
106288: CALL_OW 1
106292: ST_TO_ADDR
// exit ;
106293: POP
106294: POP
106295: GO 106828
// end ; x := list [ i ] [ 3 ] ;
106297: LD_ADDR_VAR 0 6
106301: PUSH
106302: LD_VAR 0 3
106306: PUSH
106307: LD_VAR 0 1
106311: ARRAY
106312: PUSH
106313: LD_INT 3
106315: ARRAY
106316: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
106317: LD_ADDR_VAR 0 7
106321: PUSH
106322: LD_VAR 0 3
106326: PUSH
106327: LD_VAR 0 1
106331: ARRAY
106332: PUSH
106333: LD_INT 4
106335: ARRAY
106336: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
106337: LD_ADDR_VAR 0 9
106341: PUSH
106342: LD_VAR 0 6
106346: PPUSH
106347: LD_VAR 0 7
106351: PPUSH
106352: LD_INT 16
106354: PPUSH
106355: CALL 89153 0 3
106359: ST_TO_ADDR
// if not cratesNearbyPoint then
106360: LD_VAR 0 9
106364: NOT
106365: IFFALSE 106371
// exit ;
106367: POP
106368: POP
106369: GO 106828
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
106371: LD_ADDR_VAR 0 4
106375: PUSH
106376: LD_INT 22
106378: PUSH
106379: LD_VAR 0 5
106383: PUSH
106384: EMPTY
106385: LIST
106386: LIST
106387: PUSH
106388: LD_INT 3
106390: PUSH
106391: LD_INT 60
106393: PUSH
106394: EMPTY
106395: LIST
106396: PUSH
106397: EMPTY
106398: LIST
106399: LIST
106400: PUSH
106401: LD_INT 91
106403: PUSH
106404: LD_VAR 0 8
106408: PUSH
106409: LD_INT 6
106411: PUSH
106412: EMPTY
106413: LIST
106414: LIST
106415: LIST
106416: PUSH
106417: LD_INT 2
106419: PUSH
106420: LD_INT 25
106422: PUSH
106423: LD_INT 2
106425: PUSH
106426: EMPTY
106427: LIST
106428: LIST
106429: PUSH
106430: LD_INT 25
106432: PUSH
106433: LD_INT 16
106435: PUSH
106436: EMPTY
106437: LIST
106438: LIST
106439: PUSH
106440: EMPTY
106441: LIST
106442: LIST
106443: LIST
106444: PUSH
106445: EMPTY
106446: LIST
106447: LIST
106448: LIST
106449: LIST
106450: PPUSH
106451: CALL_OW 69
106455: PUSH
106456: LD_VAR 0 8
106460: PPUSH
106461: CALL_OW 313
106465: PPUSH
106466: LD_INT 3
106468: PUSH
106469: LD_INT 60
106471: PUSH
106472: EMPTY
106473: LIST
106474: PUSH
106475: EMPTY
106476: LIST
106477: LIST
106478: PUSH
106479: LD_INT 2
106481: PUSH
106482: LD_INT 25
106484: PUSH
106485: LD_INT 2
106487: PUSH
106488: EMPTY
106489: LIST
106490: LIST
106491: PUSH
106492: LD_INT 25
106494: PUSH
106495: LD_INT 16
106497: PUSH
106498: EMPTY
106499: LIST
106500: LIST
106501: PUSH
106502: EMPTY
106503: LIST
106504: LIST
106505: LIST
106506: PUSH
106507: EMPTY
106508: LIST
106509: LIST
106510: PPUSH
106511: CALL_OW 72
106515: UNION
106516: ST_TO_ADDR
// if tmp then
106517: LD_VAR 0 4
106521: IFFALSE 106601
// begin tmp := ShrinkArray ( tmp , 3 ) ;
106523: LD_ADDR_VAR 0 4
106527: PUSH
106528: LD_VAR 0 4
106532: PPUSH
106533: LD_INT 3
106535: PPUSH
106536: CALL 87122 0 2
106540: ST_TO_ADDR
// for j in tmp do
106541: LD_ADDR_VAR 0 2
106545: PUSH
106546: LD_VAR 0 4
106550: PUSH
106551: FOR_IN
106552: IFFALSE 106595
// begin if IsInUnit ( j ) then
106554: LD_VAR 0 2
106558: PPUSH
106559: CALL_OW 310
106563: IFFALSE 106574
// ComExit ( j ) ;
106565: LD_VAR 0 2
106569: PPUSH
106570: CALL 87205 0 1
// AddComCollect ( j , x , y ) ;
106574: LD_VAR 0 2
106578: PPUSH
106579: LD_VAR 0 6
106583: PPUSH
106584: LD_VAR 0 7
106588: PPUSH
106589: CALL_OW 177
// end ;
106593: GO 106551
106595: POP
106596: POP
// exit ;
106597: POP
106598: POP
106599: GO 106828
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
106601: LD_ADDR_VAR 0 4
106605: PUSH
106606: LD_INT 22
106608: PUSH
106609: LD_VAR 0 5
106613: PUSH
106614: EMPTY
106615: LIST
106616: LIST
106617: PUSH
106618: LD_INT 91
106620: PUSH
106621: LD_VAR 0 8
106625: PUSH
106626: LD_INT 8
106628: PUSH
106629: EMPTY
106630: LIST
106631: LIST
106632: LIST
106633: PUSH
106634: LD_INT 2
106636: PUSH
106637: LD_INT 34
106639: PUSH
106640: LD_INT 12
106642: PUSH
106643: EMPTY
106644: LIST
106645: LIST
106646: PUSH
106647: LD_INT 34
106649: PUSH
106650: LD_INT 51
106652: PUSH
106653: EMPTY
106654: LIST
106655: LIST
106656: PUSH
106657: LD_INT 34
106659: PUSH
106660: LD_INT 32
106662: PUSH
106663: EMPTY
106664: LIST
106665: LIST
106666: PUSH
106667: LD_INT 34
106669: PUSH
106670: LD_INT 89
106672: PUSH
106673: EMPTY
106674: LIST
106675: LIST
106676: PUSH
106677: EMPTY
106678: LIST
106679: LIST
106680: LIST
106681: LIST
106682: LIST
106683: PUSH
106684: EMPTY
106685: LIST
106686: LIST
106687: LIST
106688: PPUSH
106689: CALL_OW 69
106693: ST_TO_ADDR
// if tmp then
106694: LD_VAR 0 4
106698: IFFALSE 106824
// begin for j in tmp do
106700: LD_ADDR_VAR 0 2
106704: PUSH
106705: LD_VAR 0 4
106709: PUSH
106710: FOR_IN
106711: IFFALSE 106822
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
106713: LD_VAR 0 2
106717: PPUSH
106718: CALL_OW 262
106722: PUSH
106723: LD_INT 3
106725: EQUAL
106726: PUSH
106727: LD_VAR 0 2
106731: PPUSH
106732: CALL_OW 261
106736: PUSH
106737: LD_INT 20
106739: GREATER
106740: OR
106741: PUSH
106742: LD_VAR 0 2
106746: PPUSH
106747: CALL_OW 314
106751: NOT
106752: AND
106753: PUSH
106754: LD_VAR 0 2
106758: PPUSH
106759: CALL_OW 263
106763: PUSH
106764: LD_INT 1
106766: NONEQUAL
106767: PUSH
106768: LD_VAR 0 2
106772: PPUSH
106773: CALL_OW 311
106777: OR
106778: AND
106779: IFFALSE 106820
// begin ComCollect ( j , x , y ) ;
106781: LD_VAR 0 2
106785: PPUSH
106786: LD_VAR 0 6
106790: PPUSH
106791: LD_VAR 0 7
106795: PPUSH
106796: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
106800: LD_VAR 0 2
106804: PPUSH
106805: LD_VAR 0 8
106809: PPUSH
106810: CALL_OW 172
// exit ;
106814: POP
106815: POP
106816: POP
106817: POP
106818: GO 106828
// end ;
106820: GO 106710
106822: POP
106823: POP
// end ; end ;
106824: GO 106199
106826: POP
106827: POP
// end ; end_of_file
106828: PPOPN 9
106830: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
106831: LD_INT 0
106833: PPUSH
106834: PPUSH
106835: PPUSH
106836: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
106837: LD_VAR 0 1
106841: PPUSH
106842: CALL_OW 264
106846: PUSH
106847: LD_INT 91
106849: EQUAL
106850: IFFALSE 106922
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
106852: LD_INT 68
106854: PPUSH
106855: LD_VAR 0 1
106859: PPUSH
106860: CALL_OW 255
106864: PPUSH
106865: CALL_OW 321
106869: PUSH
106870: LD_INT 2
106872: EQUAL
106873: IFFALSE 106885
// eff := 70 else
106875: LD_ADDR_VAR 0 4
106879: PUSH
106880: LD_INT 70
106882: ST_TO_ADDR
106883: GO 106893
// eff := 30 ;
106885: LD_ADDR_VAR 0 4
106889: PUSH
106890: LD_INT 30
106892: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
106893: LD_VAR 0 1
106897: PPUSH
106898: CALL_OW 250
106902: PPUSH
106903: LD_VAR 0 1
106907: PPUSH
106908: CALL_OW 251
106912: PPUSH
106913: LD_VAR 0 4
106917: PPUSH
106918: CALL_OW 495
// end ; end ;
106922: LD_VAR 0 2
106926: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
106927: LD_INT 0
106929: PPUSH
// end ;
106930: LD_VAR 0 4
106934: RET
// export function SOS_Command ( cmd ) ; begin
106935: LD_INT 0
106937: PPUSH
// end ;
106938: LD_VAR 0 2
106942: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
106943: LD_INT 0
106945: PPUSH
// end ;
106946: LD_VAR 0 6
106950: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
106951: LD_INT 0
106953: PPUSH
106954: PPUSH
// if not vehicle or not factory then
106955: LD_VAR 0 1
106959: NOT
106960: PUSH
106961: LD_VAR 0 2
106965: NOT
106966: OR
106967: IFFALSE 106971
// exit ;
106969: GO 107202
// if factoryWaypoints >= factory then
106971: LD_EXP 154
106975: PUSH
106976: LD_VAR 0 2
106980: GREATEREQUAL
106981: IFFALSE 107202
// if factoryWaypoints [ factory ] then
106983: LD_EXP 154
106987: PUSH
106988: LD_VAR 0 2
106992: ARRAY
106993: IFFALSE 107202
// begin if GetControl ( vehicle ) = control_manual then
106995: LD_VAR 0 1
106999: PPUSH
107000: CALL_OW 263
107004: PUSH
107005: LD_INT 1
107007: EQUAL
107008: IFFALSE 107089
// begin driver := IsDrivenBy ( vehicle ) ;
107010: LD_ADDR_VAR 0 4
107014: PUSH
107015: LD_VAR 0 1
107019: PPUSH
107020: CALL_OW 311
107024: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
107025: LD_VAR 0 4
107029: PPUSH
107030: LD_EXP 154
107034: PUSH
107035: LD_VAR 0 2
107039: ARRAY
107040: PUSH
107041: LD_INT 3
107043: ARRAY
107044: PPUSH
107045: LD_EXP 154
107049: PUSH
107050: LD_VAR 0 2
107054: ARRAY
107055: PUSH
107056: LD_INT 4
107058: ARRAY
107059: PPUSH
107060: CALL_OW 171
// AddComExitVehicle ( driver ) ;
107064: LD_VAR 0 4
107068: PPUSH
107069: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
107073: LD_VAR 0 4
107077: PPUSH
107078: LD_VAR 0 2
107082: PPUSH
107083: CALL_OW 180
// end else
107087: GO 107202
// if GetControl ( vehicle ) = control_remote then
107089: LD_VAR 0 1
107093: PPUSH
107094: CALL_OW 263
107098: PUSH
107099: LD_INT 2
107101: EQUAL
107102: IFFALSE 107163
// begin wait ( 0 0$2 ) ;
107104: LD_INT 70
107106: PPUSH
107107: CALL_OW 67
// if Connect ( vehicle ) then
107111: LD_VAR 0 1
107115: PPUSH
107116: CALL 57413 0 1
107120: IFFALSE 107161
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
107122: LD_VAR 0 1
107126: PPUSH
107127: LD_EXP 154
107131: PUSH
107132: LD_VAR 0 2
107136: ARRAY
107137: PUSH
107138: LD_INT 3
107140: ARRAY
107141: PPUSH
107142: LD_EXP 154
107146: PUSH
107147: LD_VAR 0 2
107151: ARRAY
107152: PUSH
107153: LD_INT 4
107155: ARRAY
107156: PPUSH
107157: CALL_OW 171
// end else
107161: GO 107202
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
107163: LD_VAR 0 1
107167: PPUSH
107168: LD_EXP 154
107172: PUSH
107173: LD_VAR 0 2
107177: ARRAY
107178: PUSH
107179: LD_INT 3
107181: ARRAY
107182: PPUSH
107183: LD_EXP 154
107187: PUSH
107188: LD_VAR 0 2
107192: ARRAY
107193: PUSH
107194: LD_INT 4
107196: ARRAY
107197: PPUSH
107198: CALL_OW 171
// end ; end ;
107202: LD_VAR 0 3
107206: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
107207: LD_INT 0
107209: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
107210: LD_VAR 0 1
107214: PUSH
107215: LD_INT 250
107217: EQUAL
107218: PUSH
107219: LD_VAR 0 2
107223: PPUSH
107224: CALL_OW 264
107228: PUSH
107229: LD_INT 81
107231: EQUAL
107232: AND
107233: IFFALSE 107254
// MinerPlaceMine ( unit , x , y ) ;
107235: LD_VAR 0 2
107239: PPUSH
107240: LD_VAR 0 4
107244: PPUSH
107245: LD_VAR 0 5
107249: PPUSH
107250: CALL 110078 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
107254: LD_VAR 0 1
107258: PUSH
107259: LD_INT 251
107261: EQUAL
107262: PUSH
107263: LD_VAR 0 2
107267: PPUSH
107268: CALL_OW 264
107272: PUSH
107273: LD_INT 81
107275: EQUAL
107276: AND
107277: IFFALSE 107298
// MinerDetonateMine ( unit , x , y ) ;
107279: LD_VAR 0 2
107283: PPUSH
107284: LD_VAR 0 4
107288: PPUSH
107289: LD_VAR 0 5
107293: PPUSH
107294: CALL 110353 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
107298: LD_VAR 0 1
107302: PUSH
107303: LD_INT 252
107305: EQUAL
107306: PUSH
107307: LD_VAR 0 2
107311: PPUSH
107312: CALL_OW 264
107316: PUSH
107317: LD_INT 81
107319: EQUAL
107320: AND
107321: IFFALSE 107342
// MinerCreateMinefield ( unit , x , y ) ;
107323: LD_VAR 0 2
107327: PPUSH
107328: LD_VAR 0 4
107332: PPUSH
107333: LD_VAR 0 5
107337: PPUSH
107338: CALL 110770 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
107342: LD_VAR 0 1
107346: PUSH
107347: LD_INT 253
107349: EQUAL
107350: PUSH
107351: LD_VAR 0 2
107355: PPUSH
107356: CALL_OW 257
107360: PUSH
107361: LD_INT 5
107363: EQUAL
107364: AND
107365: IFFALSE 107386
// ComBinocular ( unit , x , y ) ;
107367: LD_VAR 0 2
107371: PPUSH
107372: LD_VAR 0 4
107376: PPUSH
107377: LD_VAR 0 5
107381: PPUSH
107382: CALL 111139 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
107386: LD_VAR 0 1
107390: PUSH
107391: LD_INT 254
107393: EQUAL
107394: PUSH
107395: LD_VAR 0 2
107399: PPUSH
107400: CALL_OW 264
107404: PUSH
107405: LD_INT 99
107407: EQUAL
107408: AND
107409: PUSH
107410: LD_VAR 0 3
107414: PPUSH
107415: CALL_OW 263
107419: PUSH
107420: LD_INT 3
107422: EQUAL
107423: AND
107424: IFFALSE 107440
// HackDestroyVehicle ( unit , selectedUnit ) ;
107426: LD_VAR 0 2
107430: PPUSH
107431: LD_VAR 0 3
107435: PPUSH
107436: CALL 109442 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
107440: LD_VAR 0 1
107444: PUSH
107445: LD_INT 255
107447: EQUAL
107448: PUSH
107449: LD_VAR 0 2
107453: PPUSH
107454: CALL_OW 264
107458: PUSH
107459: LD_INT 14
107461: PUSH
107462: LD_INT 53
107464: PUSH
107465: EMPTY
107466: LIST
107467: LIST
107468: IN
107469: AND
107470: PUSH
107471: LD_VAR 0 4
107475: PPUSH
107476: LD_VAR 0 5
107480: PPUSH
107481: CALL_OW 488
107485: AND
107486: IFFALSE 107510
// CutTreeXYR ( unit , x , y , 12 ) ;
107488: LD_VAR 0 2
107492: PPUSH
107493: LD_VAR 0 4
107497: PPUSH
107498: LD_VAR 0 5
107502: PPUSH
107503: LD_INT 12
107505: PPUSH
107506: CALL 107605 0 4
// if cmd = 256 then
107510: LD_VAR 0 1
107514: PUSH
107515: LD_INT 256
107517: EQUAL
107518: IFFALSE 107539
// SetFactoryWaypoint ( unit , x , y ) ;
107520: LD_VAR 0 2
107524: PPUSH
107525: LD_VAR 0 4
107529: PPUSH
107530: LD_VAR 0 5
107534: PPUSH
107535: CALL 105520 0 3
// if cmd = 257 then
107539: LD_VAR 0 1
107543: PUSH
107544: LD_INT 257
107546: EQUAL
107547: IFFALSE 107568
// SetWarehouseGatheringPoint ( unit , x , y ) ;
107549: LD_VAR 0 2
107553: PPUSH
107554: LD_VAR 0 4
107558: PPUSH
107559: LD_VAR 0 5
107563: PPUSH
107564: CALL 105882 0 3
// if cmd = 258 then
107568: LD_VAR 0 1
107572: PUSH
107573: LD_INT 258
107575: EQUAL
107576: IFFALSE 107600
// BurnTreeXYR ( unit , x , y , 8 ) ;
107578: LD_VAR 0 2
107582: PPUSH
107583: LD_VAR 0 4
107587: PPUSH
107588: LD_VAR 0 5
107592: PPUSH
107593: LD_INT 8
107595: PPUSH
107596: CALL 107999 0 4
// end ;
107600: LD_VAR 0 6
107604: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
107605: LD_INT 0
107607: PPUSH
107608: PPUSH
107609: PPUSH
107610: PPUSH
107611: PPUSH
107612: PPUSH
107613: PPUSH
107614: PPUSH
107615: PPUSH
// if not IsOk ( bulldozer ) or not ValidHex ( x , y ) or not r then
107616: LD_VAR 0 1
107620: PPUSH
107621: CALL_OW 302
107625: NOT
107626: PUSH
107627: LD_VAR 0 2
107631: PPUSH
107632: LD_VAR 0 3
107636: PPUSH
107637: CALL_OW 488
107641: NOT
107642: OR
107643: PUSH
107644: LD_VAR 0 4
107648: NOT
107649: OR
107650: IFFALSE 107654
// exit ;
107652: GO 107994
// list := [ ] ;
107654: LD_ADDR_VAR 0 13
107658: PUSH
107659: EMPTY
107660: ST_TO_ADDR
// if x - r < 0 then
107661: LD_VAR 0 2
107665: PUSH
107666: LD_VAR 0 4
107670: MINUS
107671: PUSH
107672: LD_INT 0
107674: LESS
107675: IFFALSE 107687
// min_x := 0 else
107677: LD_ADDR_VAR 0 7
107681: PUSH
107682: LD_INT 0
107684: ST_TO_ADDR
107685: GO 107703
// min_x := x - r ;
107687: LD_ADDR_VAR 0 7
107691: PUSH
107692: LD_VAR 0 2
107696: PUSH
107697: LD_VAR 0 4
107701: MINUS
107702: ST_TO_ADDR
// if y - r < 0 then
107703: LD_VAR 0 3
107707: PUSH
107708: LD_VAR 0 4
107712: MINUS
107713: PUSH
107714: LD_INT 0
107716: LESS
107717: IFFALSE 107729
// min_y := 0 else
107719: LD_ADDR_VAR 0 8
107723: PUSH
107724: LD_INT 0
107726: ST_TO_ADDR
107727: GO 107745
// min_y := y - r ;
107729: LD_ADDR_VAR 0 8
107733: PUSH
107734: LD_VAR 0 3
107738: PUSH
107739: LD_VAR 0 4
107743: MINUS
107744: ST_TO_ADDR
// max_x := x + r ;
107745: LD_ADDR_VAR 0 9
107749: PUSH
107750: LD_VAR 0 2
107754: PUSH
107755: LD_VAR 0 4
107759: PLUS
107760: ST_TO_ADDR
// max_y := y + r ;
107761: LD_ADDR_VAR 0 10
107765: PUSH
107766: LD_VAR 0 3
107770: PUSH
107771: LD_VAR 0 4
107775: PLUS
107776: ST_TO_ADDR
// for _x = min_x to max_x do
107777: LD_ADDR_VAR 0 11
107781: PUSH
107782: DOUBLE
107783: LD_VAR 0 7
107787: DEC
107788: ST_TO_ADDR
107789: LD_VAR 0 9
107793: PUSH
107794: FOR_TO
107795: IFFALSE 107912
// for _y = min_y to max_y do
107797: LD_ADDR_VAR 0 12
107801: PUSH
107802: DOUBLE
107803: LD_VAR 0 8
107807: DEC
107808: ST_TO_ADDR
107809: LD_VAR 0 10
107813: PUSH
107814: FOR_TO
107815: IFFALSE 107908
// begin if not ValidHex ( _x , _y ) then
107817: LD_VAR 0 11
107821: PPUSH
107822: LD_VAR 0 12
107826: PPUSH
107827: CALL_OW 488
107831: NOT
107832: IFFALSE 107836
// continue ;
107834: GO 107814
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
107836: LD_VAR 0 11
107840: PPUSH
107841: LD_VAR 0 12
107845: PPUSH
107846: CALL_OW 351
107850: PUSH
107851: LD_VAR 0 11
107855: PPUSH
107856: LD_VAR 0 12
107860: PPUSH
107861: CALL_OW 554
107865: AND
107866: IFFALSE 107906
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
107868: LD_ADDR_VAR 0 13
107872: PUSH
107873: LD_VAR 0 13
107877: PPUSH
107878: LD_VAR 0 13
107882: PUSH
107883: LD_INT 1
107885: PLUS
107886: PPUSH
107887: LD_VAR 0 11
107891: PUSH
107892: LD_VAR 0 12
107896: PUSH
107897: EMPTY
107898: LIST
107899: LIST
107900: PPUSH
107901: CALL_OW 2
107905: ST_TO_ADDR
// end ;
107906: GO 107814
107908: POP
107909: POP
107910: GO 107794
107912: POP
107913: POP
// if not list then
107914: LD_VAR 0 13
107918: NOT
107919: IFFALSE 107923
// exit ;
107921: GO 107994
// for i in list do
107923: LD_ADDR_VAR 0 6
107927: PUSH
107928: LD_VAR 0 13
107932: PUSH
107933: FOR_IN
107934: IFFALSE 107992
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
107936: LD_VAR 0 1
107940: PPUSH
107941: LD_STRING M
107943: PUSH
107944: LD_VAR 0 6
107948: PUSH
107949: LD_INT 1
107951: ARRAY
107952: PUSH
107953: LD_VAR 0 6
107957: PUSH
107958: LD_INT 2
107960: ARRAY
107961: PUSH
107962: LD_INT 0
107964: PUSH
107965: LD_INT 0
107967: PUSH
107968: LD_INT 0
107970: PUSH
107971: LD_INT 0
107973: PUSH
107974: EMPTY
107975: LIST
107976: LIST
107977: LIST
107978: LIST
107979: LIST
107980: LIST
107981: LIST
107982: PUSH
107983: EMPTY
107984: LIST
107985: PPUSH
107986: CALL_OW 447
107990: GO 107933
107992: POP
107993: POP
// end ;
107994: LD_VAR 0 5
107998: RET
// function BurnTreeXYR ( flame , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
107999: LD_INT 0
108001: PPUSH
108002: PPUSH
108003: PPUSH
108004: PPUSH
108005: PPUSH
108006: PPUSH
108007: PPUSH
108008: PPUSH
108009: PPUSH
// if not IsOk ( flame ) or not ValidHex ( x , y ) or not r then
108010: LD_VAR 0 1
108014: PPUSH
108015: CALL_OW 302
108019: NOT
108020: PUSH
108021: LD_VAR 0 2
108025: PPUSH
108026: LD_VAR 0 3
108030: PPUSH
108031: CALL_OW 488
108035: NOT
108036: OR
108037: PUSH
108038: LD_VAR 0 4
108042: NOT
108043: OR
108044: IFFALSE 108048
// exit ;
108046: GO 108396
// list := [ ] ;
108048: LD_ADDR_VAR 0 13
108052: PUSH
108053: EMPTY
108054: ST_TO_ADDR
// if x - r < 0 then
108055: LD_VAR 0 2
108059: PUSH
108060: LD_VAR 0 4
108064: MINUS
108065: PUSH
108066: LD_INT 0
108068: LESS
108069: IFFALSE 108081
// min_x := 0 else
108071: LD_ADDR_VAR 0 7
108075: PUSH
108076: LD_INT 0
108078: ST_TO_ADDR
108079: GO 108097
// min_x := x - r ;
108081: LD_ADDR_VAR 0 7
108085: PUSH
108086: LD_VAR 0 2
108090: PUSH
108091: LD_VAR 0 4
108095: MINUS
108096: ST_TO_ADDR
// if y - r < 0 then
108097: LD_VAR 0 3
108101: PUSH
108102: LD_VAR 0 4
108106: MINUS
108107: PUSH
108108: LD_INT 0
108110: LESS
108111: IFFALSE 108123
// min_y := 0 else
108113: LD_ADDR_VAR 0 8
108117: PUSH
108118: LD_INT 0
108120: ST_TO_ADDR
108121: GO 108139
// min_y := y - r ;
108123: LD_ADDR_VAR 0 8
108127: PUSH
108128: LD_VAR 0 3
108132: PUSH
108133: LD_VAR 0 4
108137: MINUS
108138: ST_TO_ADDR
// max_x := x + r ;
108139: LD_ADDR_VAR 0 9
108143: PUSH
108144: LD_VAR 0 2
108148: PUSH
108149: LD_VAR 0 4
108153: PLUS
108154: ST_TO_ADDR
// max_y := y + r ;
108155: LD_ADDR_VAR 0 10
108159: PUSH
108160: LD_VAR 0 3
108164: PUSH
108165: LD_VAR 0 4
108169: PLUS
108170: ST_TO_ADDR
// for _x = min_x to max_x do
108171: LD_ADDR_VAR 0 11
108175: PUSH
108176: DOUBLE
108177: LD_VAR 0 7
108181: DEC
108182: ST_TO_ADDR
108183: LD_VAR 0 9
108187: PUSH
108188: FOR_TO
108189: IFFALSE 108306
// for _y = min_y to max_y do
108191: LD_ADDR_VAR 0 12
108195: PUSH
108196: DOUBLE
108197: LD_VAR 0 8
108201: DEC
108202: ST_TO_ADDR
108203: LD_VAR 0 10
108207: PUSH
108208: FOR_TO
108209: IFFALSE 108302
// begin if not ValidHex ( _x , _y ) then
108211: LD_VAR 0 11
108215: PPUSH
108216: LD_VAR 0 12
108220: PPUSH
108221: CALL_OW 488
108225: NOT
108226: IFFALSE 108230
// continue ;
108228: GO 108208
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
108230: LD_VAR 0 11
108234: PPUSH
108235: LD_VAR 0 12
108239: PPUSH
108240: CALL_OW 351
108244: PUSH
108245: LD_VAR 0 11
108249: PPUSH
108250: LD_VAR 0 12
108254: PPUSH
108255: CALL_OW 554
108259: AND
108260: IFFALSE 108300
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
108262: LD_ADDR_VAR 0 13
108266: PUSH
108267: LD_VAR 0 13
108271: PPUSH
108272: LD_VAR 0 13
108276: PUSH
108277: LD_INT 1
108279: PLUS
108280: PPUSH
108281: LD_VAR 0 11
108285: PUSH
108286: LD_VAR 0 12
108290: PUSH
108291: EMPTY
108292: LIST
108293: LIST
108294: PPUSH
108295: CALL_OW 2
108299: ST_TO_ADDR
// end ;
108300: GO 108208
108302: POP
108303: POP
108304: GO 108188
108306: POP
108307: POP
// if not list then
108308: LD_VAR 0 13
108312: NOT
108313: IFFALSE 108317
// exit ;
108315: GO 108396
// list := SortHexesByDistanceFromUnit ( flame , list , true , true ) ;
108317: LD_ADDR_VAR 0 13
108321: PUSH
108322: LD_VAR 0 1
108326: PPUSH
108327: LD_VAR 0 13
108331: PPUSH
108332: LD_INT 1
108334: PPUSH
108335: LD_INT 1
108337: PPUSH
108338: CALL 54555 0 4
108342: ST_TO_ADDR
// ComStop ( flame ) ;
108343: LD_VAR 0 1
108347: PPUSH
108348: CALL_OW 141
// for i in list do
108352: LD_ADDR_VAR 0 6
108356: PUSH
108357: LD_VAR 0 13
108361: PUSH
108362: FOR_IN
108363: IFFALSE 108394
// AddComAttackPlace ( flame , i [ 1 ] , i [ 2 ] ) ;
108365: LD_VAR 0 1
108369: PPUSH
108370: LD_VAR 0 6
108374: PUSH
108375: LD_INT 1
108377: ARRAY
108378: PPUSH
108379: LD_VAR 0 6
108383: PUSH
108384: LD_INT 2
108386: ARRAY
108387: PPUSH
108388: CALL_OW 176
108392: GO 108362
108394: POP
108395: POP
// end ;
108396: LD_VAR 0 5
108400: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
108401: LD_EXP 157
108405: NOT
108406: IFFALSE 108456
108408: GO 108410
108410: DISABLE
// begin initHack := true ;
108411: LD_ADDR_EXP 157
108415: PUSH
108416: LD_INT 1
108418: ST_TO_ADDR
// hackTanks := [ ] ;
108419: LD_ADDR_EXP 158
108423: PUSH
108424: EMPTY
108425: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
108426: LD_ADDR_EXP 159
108430: PUSH
108431: EMPTY
108432: ST_TO_ADDR
// hackLimit := 3 ;
108433: LD_ADDR_EXP 160
108437: PUSH
108438: LD_INT 3
108440: ST_TO_ADDR
// hackDist := 12 ;
108441: LD_ADDR_EXP 161
108445: PUSH
108446: LD_INT 12
108448: ST_TO_ADDR
// hackCounter := [ ] ;
108449: LD_ADDR_EXP 162
108453: PUSH
108454: EMPTY
108455: ST_TO_ADDR
// end ;
108456: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
108457: LD_EXP 157
108461: PUSH
108462: LD_INT 34
108464: PUSH
108465: LD_INT 99
108467: PUSH
108468: EMPTY
108469: LIST
108470: LIST
108471: PPUSH
108472: CALL_OW 69
108476: AND
108477: IFFALSE 108730
108479: GO 108481
108481: DISABLE
108482: LD_INT 0
108484: PPUSH
108485: PPUSH
// begin enable ;
108486: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
108487: LD_ADDR_VAR 0 1
108491: PUSH
108492: LD_INT 34
108494: PUSH
108495: LD_INT 99
108497: PUSH
108498: EMPTY
108499: LIST
108500: LIST
108501: PPUSH
108502: CALL_OW 69
108506: PUSH
108507: FOR_IN
108508: IFFALSE 108728
// begin if not i in hackTanks then
108510: LD_VAR 0 1
108514: PUSH
108515: LD_EXP 158
108519: IN
108520: NOT
108521: IFFALSE 108604
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
108523: LD_ADDR_EXP 158
108527: PUSH
108528: LD_EXP 158
108532: PPUSH
108533: LD_EXP 158
108537: PUSH
108538: LD_INT 1
108540: PLUS
108541: PPUSH
108542: LD_VAR 0 1
108546: PPUSH
108547: CALL_OW 1
108551: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
108552: LD_ADDR_EXP 159
108556: PUSH
108557: LD_EXP 159
108561: PPUSH
108562: LD_EXP 159
108566: PUSH
108567: LD_INT 1
108569: PLUS
108570: PPUSH
108571: EMPTY
108572: PPUSH
108573: CALL_OW 1
108577: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
108578: LD_ADDR_EXP 162
108582: PUSH
108583: LD_EXP 162
108587: PPUSH
108588: LD_EXP 162
108592: PUSH
108593: LD_INT 1
108595: PLUS
108596: PPUSH
108597: EMPTY
108598: PPUSH
108599: CALL_OW 1
108603: ST_TO_ADDR
// end ; if not IsOk ( i ) then
108604: LD_VAR 0 1
108608: PPUSH
108609: CALL_OW 302
108613: NOT
108614: IFFALSE 108627
// begin HackUnlinkAll ( i ) ;
108616: LD_VAR 0 1
108620: PPUSH
108621: CALL 108733 0 1
// continue ;
108625: GO 108507
// end ; HackCheckCapturedStatus ( i ) ;
108627: LD_VAR 0 1
108631: PPUSH
108632: CALL 109176 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
108636: LD_ADDR_VAR 0 2
108640: PUSH
108641: LD_INT 81
108643: PUSH
108644: LD_VAR 0 1
108648: PPUSH
108649: CALL_OW 255
108653: PUSH
108654: EMPTY
108655: LIST
108656: LIST
108657: PUSH
108658: LD_INT 33
108660: PUSH
108661: LD_INT 3
108663: PUSH
108664: EMPTY
108665: LIST
108666: LIST
108667: PUSH
108668: LD_INT 91
108670: PUSH
108671: LD_VAR 0 1
108675: PUSH
108676: LD_EXP 161
108680: PUSH
108681: EMPTY
108682: LIST
108683: LIST
108684: LIST
108685: PUSH
108686: LD_INT 50
108688: PUSH
108689: EMPTY
108690: LIST
108691: PUSH
108692: EMPTY
108693: LIST
108694: LIST
108695: LIST
108696: LIST
108697: PPUSH
108698: CALL_OW 69
108702: ST_TO_ADDR
// if not tmp then
108703: LD_VAR 0 2
108707: NOT
108708: IFFALSE 108712
// continue ;
108710: GO 108507
// HackLink ( i , tmp ) ;
108712: LD_VAR 0 1
108716: PPUSH
108717: LD_VAR 0 2
108721: PPUSH
108722: CALL 108869 0 2
// end ;
108726: GO 108507
108728: POP
108729: POP
// end ;
108730: PPOPN 2
108732: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
108733: LD_INT 0
108735: PPUSH
108736: PPUSH
108737: PPUSH
// if not hack in hackTanks then
108738: LD_VAR 0 1
108742: PUSH
108743: LD_EXP 158
108747: IN
108748: NOT
108749: IFFALSE 108753
// exit ;
108751: GO 108864
// index := GetElementIndex ( hackTanks , hack ) ;
108753: LD_ADDR_VAR 0 4
108757: PUSH
108758: LD_EXP 158
108762: PPUSH
108763: LD_VAR 0 1
108767: PPUSH
108768: CALL 53852 0 2
108772: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
108773: LD_EXP 159
108777: PUSH
108778: LD_VAR 0 4
108782: ARRAY
108783: IFFALSE 108864
// begin for i in hackTanksCaptured [ index ] do
108785: LD_ADDR_VAR 0 3
108789: PUSH
108790: LD_EXP 159
108794: PUSH
108795: LD_VAR 0 4
108799: ARRAY
108800: PUSH
108801: FOR_IN
108802: IFFALSE 108828
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
108804: LD_VAR 0 3
108808: PUSH
108809: LD_INT 1
108811: ARRAY
108812: PPUSH
108813: LD_VAR 0 3
108817: PUSH
108818: LD_INT 2
108820: ARRAY
108821: PPUSH
108822: CALL_OW 235
108826: GO 108801
108828: POP
108829: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
108830: LD_ADDR_EXP 159
108834: PUSH
108835: LD_EXP 159
108839: PPUSH
108840: LD_VAR 0 4
108844: PPUSH
108845: EMPTY
108846: PPUSH
108847: CALL_OW 1
108851: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
108852: LD_VAR 0 1
108856: PPUSH
108857: LD_INT 0
108859: PPUSH
108860: CALL_OW 505
// end ; end ;
108864: LD_VAR 0 2
108868: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
108869: LD_INT 0
108871: PPUSH
108872: PPUSH
108873: PPUSH
// if not hack in hackTanks or not vehicles then
108874: LD_VAR 0 1
108878: PUSH
108879: LD_EXP 158
108883: IN
108884: NOT
108885: PUSH
108886: LD_VAR 0 2
108890: NOT
108891: OR
108892: IFFALSE 108896
// exit ;
108894: GO 109171
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
108896: LD_ADDR_VAR 0 2
108900: PUSH
108901: LD_VAR 0 1
108905: PPUSH
108906: LD_VAR 0 2
108910: PPUSH
108911: LD_INT 1
108913: PPUSH
108914: LD_INT 1
108916: PPUSH
108917: CALL 54502 0 4
108921: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
108922: LD_ADDR_VAR 0 5
108926: PUSH
108927: LD_EXP 158
108931: PPUSH
108932: LD_VAR 0 1
108936: PPUSH
108937: CALL 53852 0 2
108941: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
108942: LD_EXP 159
108946: PUSH
108947: LD_VAR 0 5
108951: ARRAY
108952: PUSH
108953: LD_EXP 160
108957: LESS
108958: IFFALSE 109147
// begin for i := 1 to vehicles do
108960: LD_ADDR_VAR 0 4
108964: PUSH
108965: DOUBLE
108966: LD_INT 1
108968: DEC
108969: ST_TO_ADDR
108970: LD_VAR 0 2
108974: PUSH
108975: FOR_TO
108976: IFFALSE 109145
// begin if hackTanksCaptured [ index ] = hackLimit then
108978: LD_EXP 159
108982: PUSH
108983: LD_VAR 0 5
108987: ARRAY
108988: PUSH
108989: LD_EXP 160
108993: EQUAL
108994: IFFALSE 108998
// break ;
108996: GO 109145
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
108998: LD_ADDR_EXP 162
109002: PUSH
109003: LD_EXP 162
109007: PPUSH
109008: LD_VAR 0 5
109012: PPUSH
109013: LD_EXP 162
109017: PUSH
109018: LD_VAR 0 5
109022: ARRAY
109023: PUSH
109024: LD_INT 1
109026: PLUS
109027: PPUSH
109028: CALL_OW 1
109032: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
109033: LD_ADDR_EXP 159
109037: PUSH
109038: LD_EXP 159
109042: PPUSH
109043: LD_VAR 0 5
109047: PUSH
109048: LD_EXP 159
109052: PUSH
109053: LD_VAR 0 5
109057: ARRAY
109058: PUSH
109059: LD_INT 1
109061: PLUS
109062: PUSH
109063: EMPTY
109064: LIST
109065: LIST
109066: PPUSH
109067: LD_VAR 0 2
109071: PUSH
109072: LD_VAR 0 4
109076: ARRAY
109077: PUSH
109078: LD_VAR 0 2
109082: PUSH
109083: LD_VAR 0 4
109087: ARRAY
109088: PPUSH
109089: CALL_OW 255
109093: PUSH
109094: EMPTY
109095: LIST
109096: LIST
109097: PPUSH
109098: CALL 54067 0 3
109102: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
109103: LD_VAR 0 2
109107: PUSH
109108: LD_VAR 0 4
109112: ARRAY
109113: PPUSH
109114: LD_VAR 0 1
109118: PPUSH
109119: CALL_OW 255
109123: PPUSH
109124: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
109128: LD_VAR 0 2
109132: PUSH
109133: LD_VAR 0 4
109137: ARRAY
109138: PPUSH
109139: CALL_OW 141
// end ;
109143: GO 108975
109145: POP
109146: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
109147: LD_VAR 0 1
109151: PPUSH
109152: LD_EXP 159
109156: PUSH
109157: LD_VAR 0 5
109161: ARRAY
109162: PUSH
109163: LD_INT 0
109165: PLUS
109166: PPUSH
109167: CALL_OW 505
// end ;
109171: LD_VAR 0 3
109175: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
109176: LD_INT 0
109178: PPUSH
109179: PPUSH
109180: PPUSH
109181: PPUSH
// if not hack in hackTanks then
109182: LD_VAR 0 1
109186: PUSH
109187: LD_EXP 158
109191: IN
109192: NOT
109193: IFFALSE 109197
// exit ;
109195: GO 109437
// index := GetElementIndex ( hackTanks , hack ) ;
109197: LD_ADDR_VAR 0 4
109201: PUSH
109202: LD_EXP 158
109206: PPUSH
109207: LD_VAR 0 1
109211: PPUSH
109212: CALL 53852 0 2
109216: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
109217: LD_ADDR_VAR 0 3
109221: PUSH
109222: DOUBLE
109223: LD_EXP 159
109227: PUSH
109228: LD_VAR 0 4
109232: ARRAY
109233: INC
109234: ST_TO_ADDR
109235: LD_INT 1
109237: PUSH
109238: FOR_DOWNTO
109239: IFFALSE 109411
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
109241: LD_ADDR_VAR 0 5
109245: PUSH
109246: LD_EXP 159
109250: PUSH
109251: LD_VAR 0 4
109255: ARRAY
109256: PUSH
109257: LD_VAR 0 3
109261: ARRAY
109262: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
109263: LD_VAR 0 5
109267: PUSH
109268: LD_INT 1
109270: ARRAY
109271: PPUSH
109272: CALL_OW 302
109276: NOT
109277: PUSH
109278: LD_VAR 0 5
109282: PUSH
109283: LD_INT 1
109285: ARRAY
109286: PPUSH
109287: CALL_OW 255
109291: PUSH
109292: LD_VAR 0 1
109296: PPUSH
109297: CALL_OW 255
109301: NONEQUAL
109302: OR
109303: IFFALSE 109409
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
109305: LD_VAR 0 5
109309: PUSH
109310: LD_INT 1
109312: ARRAY
109313: PPUSH
109314: CALL_OW 305
109318: PUSH
109319: LD_VAR 0 5
109323: PUSH
109324: LD_INT 1
109326: ARRAY
109327: PPUSH
109328: CALL_OW 255
109332: PUSH
109333: LD_VAR 0 1
109337: PPUSH
109338: CALL_OW 255
109342: EQUAL
109343: AND
109344: IFFALSE 109368
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
109346: LD_VAR 0 5
109350: PUSH
109351: LD_INT 1
109353: ARRAY
109354: PPUSH
109355: LD_VAR 0 5
109359: PUSH
109360: LD_INT 2
109362: ARRAY
109363: PPUSH
109364: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
109368: LD_ADDR_EXP 159
109372: PUSH
109373: LD_EXP 159
109377: PPUSH
109378: LD_VAR 0 4
109382: PPUSH
109383: LD_EXP 159
109387: PUSH
109388: LD_VAR 0 4
109392: ARRAY
109393: PPUSH
109394: LD_VAR 0 3
109398: PPUSH
109399: CALL_OW 3
109403: PPUSH
109404: CALL_OW 1
109408: ST_TO_ADDR
// end ; end ;
109409: GO 109238
109411: POP
109412: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
109413: LD_VAR 0 1
109417: PPUSH
109418: LD_EXP 159
109422: PUSH
109423: LD_VAR 0 4
109427: ARRAY
109428: PUSH
109429: LD_INT 0
109431: PLUS
109432: PPUSH
109433: CALL_OW 505
// end ;
109437: LD_VAR 0 2
109441: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
109442: LD_INT 0
109444: PPUSH
109445: PPUSH
109446: PPUSH
109447: PPUSH
// if not hack in hackTanks then
109448: LD_VAR 0 1
109452: PUSH
109453: LD_EXP 158
109457: IN
109458: NOT
109459: IFFALSE 109463
// exit ;
109461: GO 109548
// index := GetElementIndex ( hackTanks , hack ) ;
109463: LD_ADDR_VAR 0 5
109467: PUSH
109468: LD_EXP 158
109472: PPUSH
109473: LD_VAR 0 1
109477: PPUSH
109478: CALL 53852 0 2
109482: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
109483: LD_ADDR_VAR 0 4
109487: PUSH
109488: DOUBLE
109489: LD_INT 1
109491: DEC
109492: ST_TO_ADDR
109493: LD_EXP 159
109497: PUSH
109498: LD_VAR 0 5
109502: ARRAY
109503: PUSH
109504: FOR_TO
109505: IFFALSE 109546
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
109507: LD_EXP 159
109511: PUSH
109512: LD_VAR 0 5
109516: ARRAY
109517: PUSH
109518: LD_VAR 0 4
109522: ARRAY
109523: PUSH
109524: LD_INT 1
109526: ARRAY
109527: PUSH
109528: LD_VAR 0 2
109532: EQUAL
109533: IFFALSE 109544
// KillUnit ( vehicle ) ;
109535: LD_VAR 0 2
109539: PPUSH
109540: CALL_OW 66
109544: GO 109504
109546: POP
109547: POP
// end ;
109548: LD_VAR 0 3
109552: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
109553: LD_EXP 163
109557: NOT
109558: IFFALSE 109593
109560: GO 109562
109562: DISABLE
// begin initMiner := true ;
109563: LD_ADDR_EXP 163
109567: PUSH
109568: LD_INT 1
109570: ST_TO_ADDR
// minersList := [ ] ;
109571: LD_ADDR_EXP 164
109575: PUSH
109576: EMPTY
109577: ST_TO_ADDR
// minerMinesList := [ ] ;
109578: LD_ADDR_EXP 165
109582: PUSH
109583: EMPTY
109584: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
109585: LD_ADDR_EXP 166
109589: PUSH
109590: LD_INT 5
109592: ST_TO_ADDR
// end ;
109593: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
109594: LD_EXP 163
109598: PUSH
109599: LD_INT 34
109601: PUSH
109602: LD_INT 81
109604: PUSH
109605: EMPTY
109606: LIST
109607: LIST
109608: PPUSH
109609: CALL_OW 69
109613: AND
109614: IFFALSE 110075
109616: GO 109618
109618: DISABLE
109619: LD_INT 0
109621: PPUSH
109622: PPUSH
109623: PPUSH
109624: PPUSH
// begin enable ;
109625: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
109626: LD_ADDR_VAR 0 1
109630: PUSH
109631: LD_INT 34
109633: PUSH
109634: LD_INT 81
109636: PUSH
109637: EMPTY
109638: LIST
109639: LIST
109640: PPUSH
109641: CALL_OW 69
109645: PUSH
109646: FOR_IN
109647: IFFALSE 109719
// begin if not i in minersList then
109649: LD_VAR 0 1
109653: PUSH
109654: LD_EXP 164
109658: IN
109659: NOT
109660: IFFALSE 109717
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
109662: LD_ADDR_EXP 164
109666: PUSH
109667: LD_EXP 164
109671: PPUSH
109672: LD_EXP 164
109676: PUSH
109677: LD_INT 1
109679: PLUS
109680: PPUSH
109681: LD_VAR 0 1
109685: PPUSH
109686: CALL_OW 1
109690: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
109691: LD_ADDR_EXP 165
109695: PUSH
109696: LD_EXP 165
109700: PPUSH
109701: LD_EXP 165
109705: PUSH
109706: LD_INT 1
109708: PLUS
109709: PPUSH
109710: EMPTY
109711: PPUSH
109712: CALL_OW 1
109716: ST_TO_ADDR
// end end ;
109717: GO 109646
109719: POP
109720: POP
// for i := minerMinesList downto 1 do
109721: LD_ADDR_VAR 0 1
109725: PUSH
109726: DOUBLE
109727: LD_EXP 165
109731: INC
109732: ST_TO_ADDR
109733: LD_INT 1
109735: PUSH
109736: FOR_DOWNTO
109737: IFFALSE 110073
// begin if IsLive ( minersList [ i ] ) then
109739: LD_EXP 164
109743: PUSH
109744: LD_VAR 0 1
109748: ARRAY
109749: PPUSH
109750: CALL_OW 300
109754: IFFALSE 109782
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
109756: LD_EXP 164
109760: PUSH
109761: LD_VAR 0 1
109765: ARRAY
109766: PPUSH
109767: LD_EXP 165
109771: PUSH
109772: LD_VAR 0 1
109776: ARRAY
109777: PPUSH
109778: CALL_OW 505
// if not minerMinesList [ i ] then
109782: LD_EXP 165
109786: PUSH
109787: LD_VAR 0 1
109791: ARRAY
109792: NOT
109793: IFFALSE 109797
// continue ;
109795: GO 109736
// for j := minerMinesList [ i ] downto 1 do
109797: LD_ADDR_VAR 0 2
109801: PUSH
109802: DOUBLE
109803: LD_EXP 165
109807: PUSH
109808: LD_VAR 0 1
109812: ARRAY
109813: INC
109814: ST_TO_ADDR
109815: LD_INT 1
109817: PUSH
109818: FOR_DOWNTO
109819: IFFALSE 110069
// begin side := GetSide ( minersList [ i ] ) ;
109821: LD_ADDR_VAR 0 3
109825: PUSH
109826: LD_EXP 164
109830: PUSH
109831: LD_VAR 0 1
109835: ARRAY
109836: PPUSH
109837: CALL_OW 255
109841: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
109842: LD_ADDR_VAR 0 4
109846: PUSH
109847: LD_EXP 165
109851: PUSH
109852: LD_VAR 0 1
109856: ARRAY
109857: PUSH
109858: LD_VAR 0 2
109862: ARRAY
109863: PUSH
109864: LD_INT 1
109866: ARRAY
109867: PPUSH
109868: LD_EXP 165
109872: PUSH
109873: LD_VAR 0 1
109877: ARRAY
109878: PUSH
109879: LD_VAR 0 2
109883: ARRAY
109884: PUSH
109885: LD_INT 2
109887: ARRAY
109888: PPUSH
109889: CALL_OW 428
109893: ST_TO_ADDR
// if not tmp then
109894: LD_VAR 0 4
109898: NOT
109899: IFFALSE 109903
// continue ;
109901: GO 109818
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
109903: LD_VAR 0 4
109907: PUSH
109908: LD_INT 81
109910: PUSH
109911: LD_VAR 0 3
109915: PUSH
109916: EMPTY
109917: LIST
109918: LIST
109919: PPUSH
109920: CALL_OW 69
109924: IN
109925: PUSH
109926: LD_EXP 165
109930: PUSH
109931: LD_VAR 0 1
109935: ARRAY
109936: PUSH
109937: LD_VAR 0 2
109941: ARRAY
109942: PUSH
109943: LD_INT 1
109945: ARRAY
109946: PPUSH
109947: LD_EXP 165
109951: PUSH
109952: LD_VAR 0 1
109956: ARRAY
109957: PUSH
109958: LD_VAR 0 2
109962: ARRAY
109963: PUSH
109964: LD_INT 2
109966: ARRAY
109967: PPUSH
109968: CALL_OW 458
109972: AND
109973: IFFALSE 110067
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
109975: LD_EXP 165
109979: PUSH
109980: LD_VAR 0 1
109984: ARRAY
109985: PUSH
109986: LD_VAR 0 2
109990: ARRAY
109991: PUSH
109992: LD_INT 1
109994: ARRAY
109995: PPUSH
109996: LD_EXP 165
110000: PUSH
110001: LD_VAR 0 1
110005: ARRAY
110006: PUSH
110007: LD_VAR 0 2
110011: ARRAY
110012: PUSH
110013: LD_INT 2
110015: ARRAY
110016: PPUSH
110017: LD_VAR 0 3
110021: PPUSH
110022: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
110026: LD_ADDR_EXP 165
110030: PUSH
110031: LD_EXP 165
110035: PPUSH
110036: LD_VAR 0 1
110040: PPUSH
110041: LD_EXP 165
110045: PUSH
110046: LD_VAR 0 1
110050: ARRAY
110051: PPUSH
110052: LD_VAR 0 2
110056: PPUSH
110057: CALL_OW 3
110061: PPUSH
110062: CALL_OW 1
110066: ST_TO_ADDR
// end ; end ;
110067: GO 109818
110069: POP
110070: POP
// end ;
110071: GO 109736
110073: POP
110074: POP
// end ;
110075: PPOPN 4
110077: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
110078: LD_INT 0
110080: PPUSH
110081: PPUSH
// result := false ;
110082: LD_ADDR_VAR 0 4
110086: PUSH
110087: LD_INT 0
110089: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
110090: LD_VAR 0 1
110094: PPUSH
110095: CALL_OW 264
110099: PUSH
110100: LD_INT 81
110102: EQUAL
110103: NOT
110104: IFFALSE 110108
// exit ;
110106: GO 110348
// index := GetElementIndex ( minersList , unit ) ;
110108: LD_ADDR_VAR 0 5
110112: PUSH
110113: LD_EXP 164
110117: PPUSH
110118: LD_VAR 0 1
110122: PPUSH
110123: CALL 53852 0 2
110127: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
110128: LD_EXP 165
110132: PUSH
110133: LD_VAR 0 5
110137: ARRAY
110138: PUSH
110139: LD_EXP 166
110143: GREATEREQUAL
110144: IFFALSE 110148
// exit ;
110146: GO 110348
// ComMoveXY ( unit , x , y ) ;
110148: LD_VAR 0 1
110152: PPUSH
110153: LD_VAR 0 2
110157: PPUSH
110158: LD_VAR 0 3
110162: PPUSH
110163: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
110167: LD_INT 35
110169: PPUSH
110170: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
110174: LD_VAR 0 1
110178: PPUSH
110179: LD_VAR 0 2
110183: PPUSH
110184: LD_VAR 0 3
110188: PPUSH
110189: CALL 85604 0 3
110193: NOT
110194: PUSH
110195: LD_VAR 0 1
110199: PPUSH
110200: CALL_OW 314
110204: AND
110205: IFFALSE 110209
// exit ;
110207: GO 110348
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
110209: LD_VAR 0 2
110213: PPUSH
110214: LD_VAR 0 3
110218: PPUSH
110219: CALL_OW 428
110223: PUSH
110224: LD_VAR 0 1
110228: EQUAL
110229: PUSH
110230: LD_VAR 0 1
110234: PPUSH
110235: CALL_OW 314
110239: NOT
110240: AND
110241: IFFALSE 110167
// PlaySoundXY ( x , y , PlantMine ) ;
110243: LD_VAR 0 2
110247: PPUSH
110248: LD_VAR 0 3
110252: PPUSH
110253: LD_STRING PlantMine
110255: PPUSH
110256: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
110260: LD_VAR 0 2
110264: PPUSH
110265: LD_VAR 0 3
110269: PPUSH
110270: LD_VAR 0 1
110274: PPUSH
110275: CALL_OW 255
110279: PPUSH
110280: LD_INT 0
110282: PPUSH
110283: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
110287: LD_ADDR_EXP 165
110291: PUSH
110292: LD_EXP 165
110296: PPUSH
110297: LD_VAR 0 5
110301: PUSH
110302: LD_EXP 165
110306: PUSH
110307: LD_VAR 0 5
110311: ARRAY
110312: PUSH
110313: LD_INT 1
110315: PLUS
110316: PUSH
110317: EMPTY
110318: LIST
110319: LIST
110320: PPUSH
110321: LD_VAR 0 2
110325: PUSH
110326: LD_VAR 0 3
110330: PUSH
110331: EMPTY
110332: LIST
110333: LIST
110334: PPUSH
110335: CALL 54067 0 3
110339: ST_TO_ADDR
// result := true ;
110340: LD_ADDR_VAR 0 4
110344: PUSH
110345: LD_INT 1
110347: ST_TO_ADDR
// end ;
110348: LD_VAR 0 4
110352: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
110353: LD_INT 0
110355: PPUSH
110356: PPUSH
110357: PPUSH
// if not unit in minersList then
110358: LD_VAR 0 1
110362: PUSH
110363: LD_EXP 164
110367: IN
110368: NOT
110369: IFFALSE 110373
// exit ;
110371: GO 110765
// index := GetElementIndex ( minersList , unit ) ;
110373: LD_ADDR_VAR 0 6
110377: PUSH
110378: LD_EXP 164
110382: PPUSH
110383: LD_VAR 0 1
110387: PPUSH
110388: CALL 53852 0 2
110392: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
110393: LD_ADDR_VAR 0 5
110397: PUSH
110398: DOUBLE
110399: LD_EXP 165
110403: PUSH
110404: LD_VAR 0 6
110408: ARRAY
110409: INC
110410: ST_TO_ADDR
110411: LD_INT 1
110413: PUSH
110414: FOR_DOWNTO
110415: IFFALSE 110576
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
110417: LD_EXP 165
110421: PUSH
110422: LD_VAR 0 6
110426: ARRAY
110427: PUSH
110428: LD_VAR 0 5
110432: ARRAY
110433: PUSH
110434: LD_INT 1
110436: ARRAY
110437: PUSH
110438: LD_VAR 0 2
110442: EQUAL
110443: PUSH
110444: LD_EXP 165
110448: PUSH
110449: LD_VAR 0 6
110453: ARRAY
110454: PUSH
110455: LD_VAR 0 5
110459: ARRAY
110460: PUSH
110461: LD_INT 2
110463: ARRAY
110464: PUSH
110465: LD_VAR 0 3
110469: EQUAL
110470: AND
110471: IFFALSE 110574
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
110473: LD_EXP 165
110477: PUSH
110478: LD_VAR 0 6
110482: ARRAY
110483: PUSH
110484: LD_VAR 0 5
110488: ARRAY
110489: PUSH
110490: LD_INT 1
110492: ARRAY
110493: PPUSH
110494: LD_EXP 165
110498: PUSH
110499: LD_VAR 0 6
110503: ARRAY
110504: PUSH
110505: LD_VAR 0 5
110509: ARRAY
110510: PUSH
110511: LD_INT 2
110513: ARRAY
110514: PPUSH
110515: LD_VAR 0 1
110519: PPUSH
110520: CALL_OW 255
110524: PPUSH
110525: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
110529: LD_ADDR_EXP 165
110533: PUSH
110534: LD_EXP 165
110538: PPUSH
110539: LD_VAR 0 6
110543: PPUSH
110544: LD_EXP 165
110548: PUSH
110549: LD_VAR 0 6
110553: ARRAY
110554: PPUSH
110555: LD_VAR 0 5
110559: PPUSH
110560: CALL_OW 3
110564: PPUSH
110565: CALL_OW 1
110569: ST_TO_ADDR
// exit ;
110570: POP
110571: POP
110572: GO 110765
// end ; end ;
110574: GO 110414
110576: POP
110577: POP
// for i := minerMinesList [ index ] downto 1 do
110578: LD_ADDR_VAR 0 5
110582: PUSH
110583: DOUBLE
110584: LD_EXP 165
110588: PUSH
110589: LD_VAR 0 6
110593: ARRAY
110594: INC
110595: ST_TO_ADDR
110596: LD_INT 1
110598: PUSH
110599: FOR_DOWNTO
110600: IFFALSE 110763
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
110602: LD_EXP 165
110606: PUSH
110607: LD_VAR 0 6
110611: ARRAY
110612: PUSH
110613: LD_VAR 0 5
110617: ARRAY
110618: PUSH
110619: LD_INT 1
110621: ARRAY
110622: PPUSH
110623: LD_EXP 165
110627: PUSH
110628: LD_VAR 0 6
110632: ARRAY
110633: PUSH
110634: LD_VAR 0 5
110638: ARRAY
110639: PUSH
110640: LD_INT 2
110642: ARRAY
110643: PPUSH
110644: LD_VAR 0 2
110648: PPUSH
110649: LD_VAR 0 3
110653: PPUSH
110654: CALL_OW 298
110658: PUSH
110659: LD_INT 6
110661: LESS
110662: IFFALSE 110761
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
110664: LD_EXP 165
110668: PUSH
110669: LD_VAR 0 6
110673: ARRAY
110674: PUSH
110675: LD_VAR 0 5
110679: ARRAY
110680: PUSH
110681: LD_INT 1
110683: ARRAY
110684: PPUSH
110685: LD_EXP 165
110689: PUSH
110690: LD_VAR 0 6
110694: ARRAY
110695: PUSH
110696: LD_VAR 0 5
110700: ARRAY
110701: PUSH
110702: LD_INT 2
110704: ARRAY
110705: PPUSH
110706: LD_VAR 0 1
110710: PPUSH
110711: CALL_OW 255
110715: PPUSH
110716: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
110720: LD_ADDR_EXP 165
110724: PUSH
110725: LD_EXP 165
110729: PPUSH
110730: LD_VAR 0 6
110734: PPUSH
110735: LD_EXP 165
110739: PUSH
110740: LD_VAR 0 6
110744: ARRAY
110745: PPUSH
110746: LD_VAR 0 5
110750: PPUSH
110751: CALL_OW 3
110755: PPUSH
110756: CALL_OW 1
110760: ST_TO_ADDR
// end ; end ;
110761: GO 110599
110763: POP
110764: POP
// end ;
110765: LD_VAR 0 4
110769: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
110770: LD_INT 0
110772: PPUSH
110773: PPUSH
110774: PPUSH
110775: PPUSH
110776: PPUSH
110777: PPUSH
110778: PPUSH
110779: PPUSH
110780: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
110781: LD_VAR 0 1
110785: PPUSH
110786: CALL_OW 264
110790: PUSH
110791: LD_INT 81
110793: EQUAL
110794: NOT
110795: PUSH
110796: LD_VAR 0 1
110800: PUSH
110801: LD_EXP 164
110805: IN
110806: NOT
110807: OR
110808: IFFALSE 110812
// exit ;
110810: GO 111134
// index := GetElementIndex ( minersList , unit ) ;
110812: LD_ADDR_VAR 0 6
110816: PUSH
110817: LD_EXP 164
110821: PPUSH
110822: LD_VAR 0 1
110826: PPUSH
110827: CALL 53852 0 2
110831: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
110832: LD_ADDR_VAR 0 8
110836: PUSH
110837: LD_EXP 166
110841: PUSH
110842: LD_EXP 165
110846: PUSH
110847: LD_VAR 0 6
110851: ARRAY
110852: MINUS
110853: ST_TO_ADDR
// if not minesFreeAmount then
110854: LD_VAR 0 8
110858: NOT
110859: IFFALSE 110863
// exit ;
110861: GO 111134
// tmp := [ ] ;
110863: LD_ADDR_VAR 0 7
110867: PUSH
110868: EMPTY
110869: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
110870: LD_ADDR_VAR 0 5
110874: PUSH
110875: DOUBLE
110876: LD_INT 1
110878: DEC
110879: ST_TO_ADDR
110880: LD_VAR 0 8
110884: PUSH
110885: FOR_TO
110886: IFFALSE 111081
// begin _d := rand ( 0 , 5 ) ;
110888: LD_ADDR_VAR 0 11
110892: PUSH
110893: LD_INT 0
110895: PPUSH
110896: LD_INT 5
110898: PPUSH
110899: CALL_OW 12
110903: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
110904: LD_ADDR_VAR 0 12
110908: PUSH
110909: LD_INT 2
110911: PPUSH
110912: LD_INT 6
110914: PPUSH
110915: CALL_OW 12
110919: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
110920: LD_ADDR_VAR 0 9
110924: PUSH
110925: LD_VAR 0 2
110929: PPUSH
110930: LD_VAR 0 11
110934: PPUSH
110935: LD_VAR 0 12
110939: PPUSH
110940: CALL_OW 272
110944: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
110945: LD_ADDR_VAR 0 10
110949: PUSH
110950: LD_VAR 0 3
110954: PPUSH
110955: LD_VAR 0 11
110959: PPUSH
110960: LD_VAR 0 12
110964: PPUSH
110965: CALL_OW 273
110969: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
110970: LD_VAR 0 9
110974: PPUSH
110975: LD_VAR 0 10
110979: PPUSH
110980: CALL_OW 488
110984: PUSH
110985: LD_VAR 0 9
110989: PUSH
110990: LD_VAR 0 10
110994: PUSH
110995: EMPTY
110996: LIST
110997: LIST
110998: PUSH
110999: LD_VAR 0 7
111003: IN
111004: NOT
111005: AND
111006: PUSH
111007: LD_VAR 0 9
111011: PPUSH
111012: LD_VAR 0 10
111016: PPUSH
111017: CALL_OW 458
111021: NOT
111022: AND
111023: IFFALSE 111065
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
111025: LD_ADDR_VAR 0 7
111029: PUSH
111030: LD_VAR 0 7
111034: PPUSH
111035: LD_VAR 0 7
111039: PUSH
111040: LD_INT 1
111042: PLUS
111043: PPUSH
111044: LD_VAR 0 9
111048: PUSH
111049: LD_VAR 0 10
111053: PUSH
111054: EMPTY
111055: LIST
111056: LIST
111057: PPUSH
111058: CALL_OW 1
111062: ST_TO_ADDR
111063: GO 111079
// i := i - 1 ;
111065: LD_ADDR_VAR 0 5
111069: PUSH
111070: LD_VAR 0 5
111074: PUSH
111075: LD_INT 1
111077: MINUS
111078: ST_TO_ADDR
// end ;
111079: GO 110885
111081: POP
111082: POP
// for i in tmp do
111083: LD_ADDR_VAR 0 5
111087: PUSH
111088: LD_VAR 0 7
111092: PUSH
111093: FOR_IN
111094: IFFALSE 111132
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
111096: LD_VAR 0 1
111100: PPUSH
111101: LD_VAR 0 5
111105: PUSH
111106: LD_INT 1
111108: ARRAY
111109: PPUSH
111110: LD_VAR 0 5
111114: PUSH
111115: LD_INT 2
111117: ARRAY
111118: PPUSH
111119: CALL 110078 0 3
111123: NOT
111124: IFFALSE 111130
// exit ;
111126: POP
111127: POP
111128: GO 111134
111130: GO 111093
111132: POP
111133: POP
// end ;
111134: LD_VAR 0 4
111138: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
111139: LD_INT 0
111141: PPUSH
111142: PPUSH
111143: PPUSH
111144: PPUSH
111145: PPUSH
111146: PPUSH
111147: PPUSH
// if not GetClass ( unit ) = class_sniper then
111148: LD_VAR 0 1
111152: PPUSH
111153: CALL_OW 257
111157: PUSH
111158: LD_INT 5
111160: EQUAL
111161: NOT
111162: IFFALSE 111166
// exit ;
111164: GO 111554
// dist := 8 ;
111166: LD_ADDR_VAR 0 5
111170: PUSH
111171: LD_INT 8
111173: ST_TO_ADDR
// viewRange := 12 ;
111174: LD_ADDR_VAR 0 7
111178: PUSH
111179: LD_INT 12
111181: ST_TO_ADDR
// side := GetSide ( unit ) ;
111182: LD_ADDR_VAR 0 6
111186: PUSH
111187: LD_VAR 0 1
111191: PPUSH
111192: CALL_OW 255
111196: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
111197: LD_INT 61
111199: PPUSH
111200: LD_VAR 0 6
111204: PPUSH
111205: CALL_OW 321
111209: PUSH
111210: LD_INT 2
111212: EQUAL
111213: IFFALSE 111223
// viewRange := 16 ;
111215: LD_ADDR_VAR 0 7
111219: PUSH
111220: LD_INT 16
111222: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
111223: LD_VAR 0 1
111227: PPUSH
111228: LD_VAR 0 2
111232: PPUSH
111233: LD_VAR 0 3
111237: PPUSH
111238: CALL_OW 297
111242: PUSH
111243: LD_VAR 0 5
111247: GREATER
111248: IFFALSE 111327
// begin ComMoveXY ( unit , x , y ) ;
111250: LD_VAR 0 1
111254: PPUSH
111255: LD_VAR 0 2
111259: PPUSH
111260: LD_VAR 0 3
111264: PPUSH
111265: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
111269: LD_INT 35
111271: PPUSH
111272: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
111276: LD_VAR 0 1
111280: PPUSH
111281: LD_VAR 0 2
111285: PPUSH
111286: LD_VAR 0 3
111290: PPUSH
111291: CALL 85604 0 3
111295: NOT
111296: IFFALSE 111300
// exit ;
111298: GO 111554
// until GetDistUnitXY ( unit , x , y ) < dist ;
111300: LD_VAR 0 1
111304: PPUSH
111305: LD_VAR 0 2
111309: PPUSH
111310: LD_VAR 0 3
111314: PPUSH
111315: CALL_OW 297
111319: PUSH
111320: LD_VAR 0 5
111324: LESS
111325: IFFALSE 111269
// end ; ComTurnXY ( unit , x , y ) ;
111327: LD_VAR 0 1
111331: PPUSH
111332: LD_VAR 0 2
111336: PPUSH
111337: LD_VAR 0 3
111341: PPUSH
111342: CALL_OW 118
// wait ( 5 ) ;
111346: LD_INT 5
111348: PPUSH
111349: CALL_OW 67
// _d := GetDir ( unit ) ;
111353: LD_ADDR_VAR 0 10
111357: PUSH
111358: LD_VAR 0 1
111362: PPUSH
111363: CALL_OW 254
111367: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
111368: LD_ADDR_VAR 0 8
111372: PUSH
111373: LD_VAR 0 1
111377: PPUSH
111378: CALL_OW 250
111382: PPUSH
111383: LD_VAR 0 10
111387: PPUSH
111388: LD_VAR 0 5
111392: PPUSH
111393: CALL_OW 272
111397: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
111398: LD_ADDR_VAR 0 9
111402: PUSH
111403: LD_VAR 0 1
111407: PPUSH
111408: CALL_OW 251
111412: PPUSH
111413: LD_VAR 0 10
111417: PPUSH
111418: LD_VAR 0 5
111422: PPUSH
111423: CALL_OW 273
111427: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
111428: LD_VAR 0 8
111432: PPUSH
111433: LD_VAR 0 9
111437: PPUSH
111438: CALL_OW 488
111442: NOT
111443: IFFALSE 111447
// exit ;
111445: GO 111554
// ComAnimCustom ( unit , 1 ) ;
111447: LD_VAR 0 1
111451: PPUSH
111452: LD_INT 1
111454: PPUSH
111455: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
111459: LD_VAR 0 8
111463: PPUSH
111464: LD_VAR 0 9
111468: PPUSH
111469: LD_VAR 0 6
111473: PPUSH
111474: LD_VAR 0 7
111478: PPUSH
111479: CALL_OW 330
// repeat wait ( 1 ) ;
111483: LD_INT 1
111485: PPUSH
111486: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
111490: LD_VAR 0 1
111494: PPUSH
111495: CALL_OW 316
111499: PUSH
111500: LD_VAR 0 1
111504: PPUSH
111505: CALL_OW 314
111509: OR
111510: PUSH
111511: LD_VAR 0 1
111515: PPUSH
111516: CALL_OW 302
111520: NOT
111521: OR
111522: PUSH
111523: LD_VAR 0 1
111527: PPUSH
111528: CALL_OW 301
111532: OR
111533: IFFALSE 111483
// RemoveSeeing ( _x , _y , side ) ;
111535: LD_VAR 0 8
111539: PPUSH
111540: LD_VAR 0 9
111544: PPUSH
111545: LD_VAR 0 6
111549: PPUSH
111550: CALL_OW 331
// end ; end_of_file
111554: LD_VAR 0 4
111558: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
111559: LD_INT 0
111561: PPUSH
111562: PPUSH
111563: PPUSH
111564: PPUSH
111565: PPUSH
111566: PPUSH
111567: PPUSH
111568: PPUSH
111569: PPUSH
111570: PPUSH
111571: PPUSH
111572: PPUSH
111573: PPUSH
111574: PPUSH
111575: PPUSH
111576: PPUSH
111577: PPUSH
111578: PPUSH
111579: PPUSH
111580: PPUSH
111581: PPUSH
111582: PPUSH
111583: PPUSH
111584: PPUSH
111585: PPUSH
111586: PPUSH
111587: PPUSH
111588: PPUSH
111589: PPUSH
111590: PPUSH
111591: PPUSH
111592: PPUSH
111593: PPUSH
111594: PPUSH
// if not list then
111595: LD_VAR 0 1
111599: NOT
111600: IFFALSE 111604
// exit ;
111602: GO 116263
// base := list [ 1 ] ;
111604: LD_ADDR_VAR 0 3
111608: PUSH
111609: LD_VAR 0 1
111613: PUSH
111614: LD_INT 1
111616: ARRAY
111617: ST_TO_ADDR
// group := list [ 2 ] ;
111618: LD_ADDR_VAR 0 4
111622: PUSH
111623: LD_VAR 0 1
111627: PUSH
111628: LD_INT 2
111630: ARRAY
111631: ST_TO_ADDR
// path := list [ 3 ] ;
111632: LD_ADDR_VAR 0 5
111636: PUSH
111637: LD_VAR 0 1
111641: PUSH
111642: LD_INT 3
111644: ARRAY
111645: ST_TO_ADDR
// flags := list [ 4 ] ;
111646: LD_ADDR_VAR 0 6
111650: PUSH
111651: LD_VAR 0 1
111655: PUSH
111656: LD_INT 4
111658: ARRAY
111659: ST_TO_ADDR
// mined := [ ] ;
111660: LD_ADDR_VAR 0 27
111664: PUSH
111665: EMPTY
111666: ST_TO_ADDR
// bombed := [ ] ;
111667: LD_ADDR_VAR 0 28
111671: PUSH
111672: EMPTY
111673: ST_TO_ADDR
// healers := [ ] ;
111674: LD_ADDR_VAR 0 31
111678: PUSH
111679: EMPTY
111680: ST_TO_ADDR
// to_heal := [ ] ;
111681: LD_ADDR_VAR 0 30
111685: PUSH
111686: EMPTY
111687: ST_TO_ADDR
// repairs := [ ] ;
111688: LD_ADDR_VAR 0 33
111692: PUSH
111693: EMPTY
111694: ST_TO_ADDR
// to_repair := [ ] ;
111695: LD_ADDR_VAR 0 32
111699: PUSH
111700: EMPTY
111701: ST_TO_ADDR
// if not group or not path then
111702: LD_VAR 0 4
111706: NOT
111707: PUSH
111708: LD_VAR 0 5
111712: NOT
111713: OR
111714: IFFALSE 111718
// exit ;
111716: GO 116263
// side := GetSide ( group [ 1 ] ) ;
111718: LD_ADDR_VAR 0 35
111722: PUSH
111723: LD_VAR 0 4
111727: PUSH
111728: LD_INT 1
111730: ARRAY
111731: PPUSH
111732: CALL_OW 255
111736: ST_TO_ADDR
// if flags then
111737: LD_VAR 0 6
111741: IFFALSE 111885
// begin f_ignore_area := flags [ 1 ] ;
111743: LD_ADDR_VAR 0 17
111747: PUSH
111748: LD_VAR 0 6
111752: PUSH
111753: LD_INT 1
111755: ARRAY
111756: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
111757: LD_ADDR_VAR 0 18
111761: PUSH
111762: LD_VAR 0 6
111766: PUSH
111767: LD_INT 2
111769: ARRAY
111770: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
111771: LD_ADDR_VAR 0 19
111775: PUSH
111776: LD_VAR 0 6
111780: PUSH
111781: LD_INT 3
111783: ARRAY
111784: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
111785: LD_ADDR_VAR 0 20
111789: PUSH
111790: LD_VAR 0 6
111794: PUSH
111795: LD_INT 4
111797: ARRAY
111798: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
111799: LD_ADDR_VAR 0 21
111803: PUSH
111804: LD_VAR 0 6
111808: PUSH
111809: LD_INT 5
111811: ARRAY
111812: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
111813: LD_ADDR_VAR 0 22
111817: PUSH
111818: LD_VAR 0 6
111822: PUSH
111823: LD_INT 6
111825: ARRAY
111826: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
111827: LD_ADDR_VAR 0 23
111831: PUSH
111832: LD_VAR 0 6
111836: PUSH
111837: LD_INT 7
111839: ARRAY
111840: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
111841: LD_ADDR_VAR 0 24
111845: PUSH
111846: LD_VAR 0 6
111850: PUSH
111851: LD_INT 8
111853: ARRAY
111854: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
111855: LD_ADDR_VAR 0 25
111859: PUSH
111860: LD_VAR 0 6
111864: PUSH
111865: LD_INT 9
111867: ARRAY
111868: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
111869: LD_ADDR_VAR 0 26
111873: PUSH
111874: LD_VAR 0 6
111878: PUSH
111879: LD_INT 10
111881: ARRAY
111882: ST_TO_ADDR
// end else
111883: GO 111965
// begin f_ignore_area := false ;
111885: LD_ADDR_VAR 0 17
111889: PUSH
111890: LD_INT 0
111892: ST_TO_ADDR
// f_capture := false ;
111893: LD_ADDR_VAR 0 18
111897: PUSH
111898: LD_INT 0
111900: ST_TO_ADDR
// f_ignore_civ := false ;
111901: LD_ADDR_VAR 0 19
111905: PUSH
111906: LD_INT 0
111908: ST_TO_ADDR
// f_murder := false ;
111909: LD_ADDR_VAR 0 20
111913: PUSH
111914: LD_INT 0
111916: ST_TO_ADDR
// f_mines := false ;
111917: LD_ADDR_VAR 0 21
111921: PUSH
111922: LD_INT 0
111924: ST_TO_ADDR
// f_repair := false ;
111925: LD_ADDR_VAR 0 22
111929: PUSH
111930: LD_INT 0
111932: ST_TO_ADDR
// f_heal := false ;
111933: LD_ADDR_VAR 0 23
111937: PUSH
111938: LD_INT 0
111940: ST_TO_ADDR
// f_spacetime := false ;
111941: LD_ADDR_VAR 0 24
111945: PUSH
111946: LD_INT 0
111948: ST_TO_ADDR
// f_attack_depot := false ;
111949: LD_ADDR_VAR 0 25
111953: PUSH
111954: LD_INT 0
111956: ST_TO_ADDR
// f_crawl := false ;
111957: LD_ADDR_VAR 0 26
111961: PUSH
111962: LD_INT 0
111964: ST_TO_ADDR
// end ; if f_heal then
111965: LD_VAR 0 23
111969: IFFALSE 111996
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
111971: LD_ADDR_VAR 0 31
111975: PUSH
111976: LD_VAR 0 4
111980: PPUSH
111981: LD_INT 25
111983: PUSH
111984: LD_INT 4
111986: PUSH
111987: EMPTY
111988: LIST
111989: LIST
111990: PPUSH
111991: CALL_OW 72
111995: ST_TO_ADDR
// if f_repair then
111996: LD_VAR 0 22
112000: IFFALSE 112027
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
112002: LD_ADDR_VAR 0 33
112006: PUSH
112007: LD_VAR 0 4
112011: PPUSH
112012: LD_INT 25
112014: PUSH
112015: LD_INT 3
112017: PUSH
112018: EMPTY
112019: LIST
112020: LIST
112021: PPUSH
112022: CALL_OW 72
112026: ST_TO_ADDR
// units_path := [ ] ;
112027: LD_ADDR_VAR 0 16
112031: PUSH
112032: EMPTY
112033: ST_TO_ADDR
// for i = 1 to group do
112034: LD_ADDR_VAR 0 7
112038: PUSH
112039: DOUBLE
112040: LD_INT 1
112042: DEC
112043: ST_TO_ADDR
112044: LD_VAR 0 4
112048: PUSH
112049: FOR_TO
112050: IFFALSE 112079
// units_path := Replace ( units_path , i , path ) ;
112052: LD_ADDR_VAR 0 16
112056: PUSH
112057: LD_VAR 0 16
112061: PPUSH
112062: LD_VAR 0 7
112066: PPUSH
112067: LD_VAR 0 5
112071: PPUSH
112072: CALL_OW 1
112076: ST_TO_ADDR
112077: GO 112049
112079: POP
112080: POP
// repeat for i = group downto 1 do
112081: LD_ADDR_VAR 0 7
112085: PUSH
112086: DOUBLE
112087: LD_VAR 0 4
112091: INC
112092: ST_TO_ADDR
112093: LD_INT 1
112095: PUSH
112096: FOR_DOWNTO
112097: IFFALSE 116219
// begin wait ( 5 ) ;
112099: LD_INT 5
112101: PPUSH
112102: CALL_OW 67
// tmp := [ ] ;
112106: LD_ADDR_VAR 0 14
112110: PUSH
112111: EMPTY
112112: ST_TO_ADDR
// attacking := false ;
112113: LD_ADDR_VAR 0 29
112117: PUSH
112118: LD_INT 0
112120: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
112121: LD_VAR 0 4
112125: PUSH
112126: LD_VAR 0 7
112130: ARRAY
112131: PPUSH
112132: CALL_OW 301
112136: PUSH
112137: LD_VAR 0 4
112141: PUSH
112142: LD_VAR 0 7
112146: ARRAY
112147: NOT
112148: OR
112149: IFFALSE 112258
// begin if GetType ( group [ i ] ) = unit_human then
112151: LD_VAR 0 4
112155: PUSH
112156: LD_VAR 0 7
112160: ARRAY
112161: PPUSH
112162: CALL_OW 247
112166: PUSH
112167: LD_INT 1
112169: EQUAL
112170: IFFALSE 112216
// begin to_heal := to_heal diff group [ i ] ;
112172: LD_ADDR_VAR 0 30
112176: PUSH
112177: LD_VAR 0 30
112181: PUSH
112182: LD_VAR 0 4
112186: PUSH
112187: LD_VAR 0 7
112191: ARRAY
112192: DIFF
112193: ST_TO_ADDR
// healers := healers diff group [ i ] ;
112194: LD_ADDR_VAR 0 31
112198: PUSH
112199: LD_VAR 0 31
112203: PUSH
112204: LD_VAR 0 4
112208: PUSH
112209: LD_VAR 0 7
112213: ARRAY
112214: DIFF
112215: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
112216: LD_ADDR_VAR 0 4
112220: PUSH
112221: LD_VAR 0 4
112225: PPUSH
112226: LD_VAR 0 7
112230: PPUSH
112231: CALL_OW 3
112235: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
112236: LD_ADDR_VAR 0 16
112240: PUSH
112241: LD_VAR 0 16
112245: PPUSH
112246: LD_VAR 0 7
112250: PPUSH
112251: CALL_OW 3
112255: ST_TO_ADDR
// continue ;
112256: GO 112096
// end ; if f_repair then
112258: LD_VAR 0 22
112262: IFFALSE 112751
// begin if GetType ( group [ i ] ) = unit_vehicle then
112264: LD_VAR 0 4
112268: PUSH
112269: LD_VAR 0 7
112273: ARRAY
112274: PPUSH
112275: CALL_OW 247
112279: PUSH
112280: LD_INT 2
112282: EQUAL
112283: IFFALSE 112473
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
112285: LD_VAR 0 4
112289: PUSH
112290: LD_VAR 0 7
112294: ARRAY
112295: PPUSH
112296: CALL_OW 256
112300: PUSH
112301: LD_INT 700
112303: LESS
112304: PUSH
112305: LD_VAR 0 4
112309: PUSH
112310: LD_VAR 0 7
112314: ARRAY
112315: PUSH
112316: LD_VAR 0 32
112320: IN
112321: NOT
112322: AND
112323: IFFALSE 112347
// to_repair := to_repair union group [ i ] ;
112325: LD_ADDR_VAR 0 32
112329: PUSH
112330: LD_VAR 0 32
112334: PUSH
112335: LD_VAR 0 4
112339: PUSH
112340: LD_VAR 0 7
112344: ARRAY
112345: UNION
112346: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
112347: LD_VAR 0 4
112351: PUSH
112352: LD_VAR 0 7
112356: ARRAY
112357: PPUSH
112358: CALL_OW 256
112362: PUSH
112363: LD_INT 1000
112365: EQUAL
112366: PUSH
112367: LD_VAR 0 4
112371: PUSH
112372: LD_VAR 0 7
112376: ARRAY
112377: PUSH
112378: LD_VAR 0 32
112382: IN
112383: AND
112384: IFFALSE 112408
// to_repair := to_repair diff group [ i ] ;
112386: LD_ADDR_VAR 0 32
112390: PUSH
112391: LD_VAR 0 32
112395: PUSH
112396: LD_VAR 0 4
112400: PUSH
112401: LD_VAR 0 7
112405: ARRAY
112406: DIFF
112407: ST_TO_ADDR
// if group [ i ] in to_repair then
112408: LD_VAR 0 4
112412: PUSH
112413: LD_VAR 0 7
112417: ARRAY
112418: PUSH
112419: LD_VAR 0 32
112423: IN
112424: IFFALSE 112471
// begin if not IsInArea ( group [ i ] , f_repair ) then
112426: LD_VAR 0 4
112430: PUSH
112431: LD_VAR 0 7
112435: ARRAY
112436: PPUSH
112437: LD_VAR 0 22
112441: PPUSH
112442: CALL_OW 308
112446: NOT
112447: IFFALSE 112469
// ComMoveToArea ( group [ i ] , f_repair ) ;
112449: LD_VAR 0 4
112453: PUSH
112454: LD_VAR 0 7
112458: ARRAY
112459: PPUSH
112460: LD_VAR 0 22
112464: PPUSH
112465: CALL_OW 113
// continue ;
112469: GO 112096
// end ; end else
112471: GO 112751
// if group [ i ] in repairs then
112473: LD_VAR 0 4
112477: PUSH
112478: LD_VAR 0 7
112482: ARRAY
112483: PUSH
112484: LD_VAR 0 33
112488: IN
112489: IFFALSE 112751
// begin if IsInUnit ( group [ i ] ) then
112491: LD_VAR 0 4
112495: PUSH
112496: LD_VAR 0 7
112500: ARRAY
112501: PPUSH
112502: CALL_OW 310
112506: IFFALSE 112574
// begin z := IsInUnit ( group [ i ] ) ;
112508: LD_ADDR_VAR 0 13
112512: PUSH
112513: LD_VAR 0 4
112517: PUSH
112518: LD_VAR 0 7
112522: ARRAY
112523: PPUSH
112524: CALL_OW 310
112528: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
112529: LD_VAR 0 13
112533: PUSH
112534: LD_VAR 0 32
112538: IN
112539: PUSH
112540: LD_VAR 0 13
112544: PPUSH
112545: LD_VAR 0 22
112549: PPUSH
112550: CALL_OW 308
112554: AND
112555: IFFALSE 112572
// ComExitVehicle ( group [ i ] ) ;
112557: LD_VAR 0 4
112561: PUSH
112562: LD_VAR 0 7
112566: ARRAY
112567: PPUSH
112568: CALL_OW 121
// end else
112572: GO 112751
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
112574: LD_ADDR_VAR 0 13
112578: PUSH
112579: LD_VAR 0 4
112583: PPUSH
112584: LD_INT 95
112586: PUSH
112587: LD_VAR 0 22
112591: PUSH
112592: EMPTY
112593: LIST
112594: LIST
112595: PUSH
112596: LD_INT 58
112598: PUSH
112599: EMPTY
112600: LIST
112601: PUSH
112602: EMPTY
112603: LIST
112604: LIST
112605: PPUSH
112606: CALL_OW 72
112610: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
112611: LD_VAR 0 4
112615: PUSH
112616: LD_VAR 0 7
112620: ARRAY
112621: PPUSH
112622: CALL_OW 314
112626: NOT
112627: IFFALSE 112749
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
112629: LD_ADDR_VAR 0 10
112633: PUSH
112634: LD_VAR 0 13
112638: PPUSH
112639: LD_VAR 0 4
112643: PUSH
112644: LD_VAR 0 7
112648: ARRAY
112649: PPUSH
112650: CALL_OW 74
112654: ST_TO_ADDR
// if not x then
112655: LD_VAR 0 10
112659: NOT
112660: IFFALSE 112664
// continue ;
112662: GO 112096
// if GetLives ( x ) < 1000 then
112664: LD_VAR 0 10
112668: PPUSH
112669: CALL_OW 256
112673: PUSH
112674: LD_INT 1000
112676: LESS
112677: IFFALSE 112701
// ComRepairVehicle ( group [ i ] , x ) else
112679: LD_VAR 0 4
112683: PUSH
112684: LD_VAR 0 7
112688: ARRAY
112689: PPUSH
112690: LD_VAR 0 10
112694: PPUSH
112695: CALL_OW 129
112699: GO 112749
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
112701: LD_VAR 0 23
112705: PUSH
112706: LD_VAR 0 4
112710: PUSH
112711: LD_VAR 0 7
112715: ARRAY
112716: PPUSH
112717: CALL_OW 256
112721: PUSH
112722: LD_INT 1000
112724: LESS
112725: AND
112726: NOT
112727: IFFALSE 112749
// ComEnterUnit ( group [ i ] , x ) ;
112729: LD_VAR 0 4
112733: PUSH
112734: LD_VAR 0 7
112738: ARRAY
112739: PPUSH
112740: LD_VAR 0 10
112744: PPUSH
112745: CALL_OW 120
// end ; continue ;
112749: GO 112096
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
112751: LD_VAR 0 23
112755: PUSH
112756: LD_VAR 0 4
112760: PUSH
112761: LD_VAR 0 7
112765: ARRAY
112766: PPUSH
112767: CALL_OW 247
112771: PUSH
112772: LD_INT 1
112774: EQUAL
112775: AND
112776: IFFALSE 113254
// begin if group [ i ] in healers then
112778: LD_VAR 0 4
112782: PUSH
112783: LD_VAR 0 7
112787: ARRAY
112788: PUSH
112789: LD_VAR 0 31
112793: IN
112794: IFFALSE 113067
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
112796: LD_VAR 0 4
112800: PUSH
112801: LD_VAR 0 7
112805: ARRAY
112806: PPUSH
112807: LD_VAR 0 23
112811: PPUSH
112812: CALL_OW 308
112816: NOT
112817: PUSH
112818: LD_VAR 0 4
112822: PUSH
112823: LD_VAR 0 7
112827: ARRAY
112828: PPUSH
112829: CALL_OW 314
112833: NOT
112834: AND
112835: IFFALSE 112859
// ComMoveToArea ( group [ i ] , f_heal ) else
112837: LD_VAR 0 4
112841: PUSH
112842: LD_VAR 0 7
112846: ARRAY
112847: PPUSH
112848: LD_VAR 0 23
112852: PPUSH
112853: CALL_OW 113
112857: GO 113065
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
112859: LD_VAR 0 4
112863: PUSH
112864: LD_VAR 0 7
112868: ARRAY
112869: PPUSH
112870: CALL 84187 0 1
112874: PPUSH
112875: CALL_OW 256
112879: PUSH
112880: LD_INT 1000
112882: EQUAL
112883: IFFALSE 112902
// ComStop ( group [ i ] ) else
112885: LD_VAR 0 4
112889: PUSH
112890: LD_VAR 0 7
112894: ARRAY
112895: PPUSH
112896: CALL_OW 141
112900: GO 113065
// if not HasTask ( group [ i ] ) and to_heal then
112902: LD_VAR 0 4
112906: PUSH
112907: LD_VAR 0 7
112911: ARRAY
112912: PPUSH
112913: CALL_OW 314
112917: NOT
112918: PUSH
112919: LD_VAR 0 30
112923: AND
112924: IFFALSE 113065
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
112926: LD_ADDR_VAR 0 13
112930: PUSH
112931: LD_VAR 0 30
112935: PPUSH
112936: LD_INT 3
112938: PUSH
112939: LD_INT 54
112941: PUSH
112942: EMPTY
112943: LIST
112944: PUSH
112945: EMPTY
112946: LIST
112947: LIST
112948: PPUSH
112949: CALL_OW 72
112953: PPUSH
112954: LD_VAR 0 4
112958: PUSH
112959: LD_VAR 0 7
112963: ARRAY
112964: PPUSH
112965: CALL_OW 74
112969: ST_TO_ADDR
// if z then
112970: LD_VAR 0 13
112974: IFFALSE 113065
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
112976: LD_INT 91
112978: PUSH
112979: LD_VAR 0 13
112983: PUSH
112984: LD_INT 10
112986: PUSH
112987: EMPTY
112988: LIST
112989: LIST
112990: LIST
112991: PUSH
112992: LD_INT 81
112994: PUSH
112995: LD_VAR 0 13
112999: PPUSH
113000: CALL_OW 255
113004: PUSH
113005: EMPTY
113006: LIST
113007: LIST
113008: PUSH
113009: EMPTY
113010: LIST
113011: LIST
113012: PPUSH
113013: CALL_OW 69
113017: PUSH
113018: LD_INT 0
113020: EQUAL
113021: IFFALSE 113045
// ComHeal ( group [ i ] , z ) else
113023: LD_VAR 0 4
113027: PUSH
113028: LD_VAR 0 7
113032: ARRAY
113033: PPUSH
113034: LD_VAR 0 13
113038: PPUSH
113039: CALL_OW 128
113043: GO 113065
// ComMoveToArea ( group [ i ] , f_heal ) ;
113045: LD_VAR 0 4
113049: PUSH
113050: LD_VAR 0 7
113054: ARRAY
113055: PPUSH
113056: LD_VAR 0 23
113060: PPUSH
113061: CALL_OW 113
// end ; continue ;
113065: GO 112096
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
113067: LD_VAR 0 4
113071: PUSH
113072: LD_VAR 0 7
113076: ARRAY
113077: PPUSH
113078: CALL_OW 256
113082: PUSH
113083: LD_INT 700
113085: LESS
113086: PUSH
113087: LD_VAR 0 4
113091: PUSH
113092: LD_VAR 0 7
113096: ARRAY
113097: PUSH
113098: LD_VAR 0 30
113102: IN
113103: NOT
113104: AND
113105: IFFALSE 113129
// to_heal := to_heal union group [ i ] ;
113107: LD_ADDR_VAR 0 30
113111: PUSH
113112: LD_VAR 0 30
113116: PUSH
113117: LD_VAR 0 4
113121: PUSH
113122: LD_VAR 0 7
113126: ARRAY
113127: UNION
113128: ST_TO_ADDR
// if group [ i ] in to_heal then
113129: LD_VAR 0 4
113133: PUSH
113134: LD_VAR 0 7
113138: ARRAY
113139: PUSH
113140: LD_VAR 0 30
113144: IN
113145: IFFALSE 113254
// begin if GetLives ( group [ i ] ) = 1000 then
113147: LD_VAR 0 4
113151: PUSH
113152: LD_VAR 0 7
113156: ARRAY
113157: PPUSH
113158: CALL_OW 256
113162: PUSH
113163: LD_INT 1000
113165: EQUAL
113166: IFFALSE 113192
// to_heal := to_heal diff group [ i ] else
113168: LD_ADDR_VAR 0 30
113172: PUSH
113173: LD_VAR 0 30
113177: PUSH
113178: LD_VAR 0 4
113182: PUSH
113183: LD_VAR 0 7
113187: ARRAY
113188: DIFF
113189: ST_TO_ADDR
113190: GO 113254
// begin if not IsInArea ( group [ i ] , to_heal ) then
113192: LD_VAR 0 4
113196: PUSH
113197: LD_VAR 0 7
113201: ARRAY
113202: PPUSH
113203: LD_VAR 0 30
113207: PPUSH
113208: CALL_OW 308
113212: NOT
113213: IFFALSE 113237
// ComMoveToArea ( group [ i ] , f_heal ) else
113215: LD_VAR 0 4
113219: PUSH
113220: LD_VAR 0 7
113224: ARRAY
113225: PPUSH
113226: LD_VAR 0 23
113230: PPUSH
113231: CALL_OW 113
113235: GO 113252
// ComHold ( group [ i ] ) ;
113237: LD_VAR 0 4
113241: PUSH
113242: LD_VAR 0 7
113246: ARRAY
113247: PPUSH
113248: CALL_OW 140
// continue ;
113252: GO 112096
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
113254: LD_VAR 0 4
113258: PUSH
113259: LD_VAR 0 7
113263: ARRAY
113264: PPUSH
113265: LD_INT 10
113267: PPUSH
113268: CALL 81958 0 2
113272: NOT
113273: PUSH
113274: LD_VAR 0 16
113278: PUSH
113279: LD_VAR 0 7
113283: ARRAY
113284: PUSH
113285: EMPTY
113286: EQUAL
113287: NOT
113288: AND
113289: IFFALSE 113555
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
113291: LD_VAR 0 4
113295: PUSH
113296: LD_VAR 0 7
113300: ARRAY
113301: PPUSH
113302: CALL_OW 262
113306: PUSH
113307: LD_INT 1
113309: PUSH
113310: LD_INT 2
113312: PUSH
113313: EMPTY
113314: LIST
113315: LIST
113316: IN
113317: IFFALSE 113358
// if GetFuel ( group [ i ] ) < 10 then
113319: LD_VAR 0 4
113323: PUSH
113324: LD_VAR 0 7
113328: ARRAY
113329: PPUSH
113330: CALL_OW 261
113334: PUSH
113335: LD_INT 10
113337: LESS
113338: IFFALSE 113358
// SetFuel ( group [ i ] , 12 ) ;
113340: LD_VAR 0 4
113344: PUSH
113345: LD_VAR 0 7
113349: ARRAY
113350: PPUSH
113351: LD_INT 12
113353: PPUSH
113354: CALL_OW 240
// if units_path [ i ] then
113358: LD_VAR 0 16
113362: PUSH
113363: LD_VAR 0 7
113367: ARRAY
113368: IFFALSE 113553
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
113370: LD_VAR 0 4
113374: PUSH
113375: LD_VAR 0 7
113379: ARRAY
113380: PPUSH
113381: LD_VAR 0 16
113385: PUSH
113386: LD_VAR 0 7
113390: ARRAY
113391: PUSH
113392: LD_INT 1
113394: ARRAY
113395: PUSH
113396: LD_INT 1
113398: ARRAY
113399: PPUSH
113400: LD_VAR 0 16
113404: PUSH
113405: LD_VAR 0 7
113409: ARRAY
113410: PUSH
113411: LD_INT 1
113413: ARRAY
113414: PUSH
113415: LD_INT 2
113417: ARRAY
113418: PPUSH
113419: CALL_OW 297
113423: PUSH
113424: LD_INT 6
113426: GREATER
113427: IFFALSE 113502
// begin if not HasTask ( group [ i ] ) then
113429: LD_VAR 0 4
113433: PUSH
113434: LD_VAR 0 7
113438: ARRAY
113439: PPUSH
113440: CALL_OW 314
113444: NOT
113445: IFFALSE 113500
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
113447: LD_VAR 0 4
113451: PUSH
113452: LD_VAR 0 7
113456: ARRAY
113457: PPUSH
113458: LD_VAR 0 16
113462: PUSH
113463: LD_VAR 0 7
113467: ARRAY
113468: PUSH
113469: LD_INT 1
113471: ARRAY
113472: PUSH
113473: LD_INT 1
113475: ARRAY
113476: PPUSH
113477: LD_VAR 0 16
113481: PUSH
113482: LD_VAR 0 7
113486: ARRAY
113487: PUSH
113488: LD_INT 1
113490: ARRAY
113491: PUSH
113492: LD_INT 2
113494: ARRAY
113495: PPUSH
113496: CALL_OW 114
// end else
113500: GO 113553
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
113502: LD_ADDR_VAR 0 15
113506: PUSH
113507: LD_VAR 0 16
113511: PUSH
113512: LD_VAR 0 7
113516: ARRAY
113517: PPUSH
113518: LD_INT 1
113520: PPUSH
113521: CALL_OW 3
113525: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
113526: LD_ADDR_VAR 0 16
113530: PUSH
113531: LD_VAR 0 16
113535: PPUSH
113536: LD_VAR 0 7
113540: PPUSH
113541: LD_VAR 0 15
113545: PPUSH
113546: CALL_OW 1
113550: ST_TO_ADDR
// continue ;
113551: GO 112096
// end ; end ; end else
113553: GO 116217
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
113555: LD_ADDR_VAR 0 14
113559: PUSH
113560: LD_INT 81
113562: PUSH
113563: LD_VAR 0 4
113567: PUSH
113568: LD_VAR 0 7
113572: ARRAY
113573: PPUSH
113574: CALL_OW 255
113578: PUSH
113579: EMPTY
113580: LIST
113581: LIST
113582: PPUSH
113583: CALL_OW 69
113587: ST_TO_ADDR
// if not tmp then
113588: LD_VAR 0 14
113592: NOT
113593: IFFALSE 113597
// continue ;
113595: GO 112096
// if f_ignore_area then
113597: LD_VAR 0 17
113601: IFFALSE 113689
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
113603: LD_ADDR_VAR 0 15
113607: PUSH
113608: LD_VAR 0 14
113612: PPUSH
113613: LD_INT 3
113615: PUSH
113616: LD_INT 92
113618: PUSH
113619: LD_VAR 0 17
113623: PUSH
113624: LD_INT 1
113626: ARRAY
113627: PUSH
113628: LD_VAR 0 17
113632: PUSH
113633: LD_INT 2
113635: ARRAY
113636: PUSH
113637: LD_VAR 0 17
113641: PUSH
113642: LD_INT 3
113644: ARRAY
113645: PUSH
113646: EMPTY
113647: LIST
113648: LIST
113649: LIST
113650: LIST
113651: PUSH
113652: EMPTY
113653: LIST
113654: LIST
113655: PPUSH
113656: CALL_OW 72
113660: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
113661: LD_VAR 0 14
113665: PUSH
113666: LD_VAR 0 15
113670: DIFF
113671: IFFALSE 113689
// tmp := tmp diff tmp2 ;
113673: LD_ADDR_VAR 0 14
113677: PUSH
113678: LD_VAR 0 14
113682: PUSH
113683: LD_VAR 0 15
113687: DIFF
113688: ST_TO_ADDR
// end ; if not f_murder then
113689: LD_VAR 0 20
113693: NOT
113694: IFFALSE 113752
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
113696: LD_ADDR_VAR 0 15
113700: PUSH
113701: LD_VAR 0 14
113705: PPUSH
113706: LD_INT 3
113708: PUSH
113709: LD_INT 50
113711: PUSH
113712: EMPTY
113713: LIST
113714: PUSH
113715: EMPTY
113716: LIST
113717: LIST
113718: PPUSH
113719: CALL_OW 72
113723: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
113724: LD_VAR 0 14
113728: PUSH
113729: LD_VAR 0 15
113733: DIFF
113734: IFFALSE 113752
// tmp := tmp diff tmp2 ;
113736: LD_ADDR_VAR 0 14
113740: PUSH
113741: LD_VAR 0 14
113745: PUSH
113746: LD_VAR 0 15
113750: DIFF
113751: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
113752: LD_ADDR_VAR 0 14
113756: PUSH
113757: LD_VAR 0 4
113761: PUSH
113762: LD_VAR 0 7
113766: ARRAY
113767: PPUSH
113768: LD_VAR 0 14
113772: PPUSH
113773: LD_INT 1
113775: PPUSH
113776: LD_INT 1
113778: PPUSH
113779: CALL 54502 0 4
113783: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
113784: LD_VAR 0 4
113788: PUSH
113789: LD_VAR 0 7
113793: ARRAY
113794: PPUSH
113795: CALL_OW 257
113799: PUSH
113800: LD_INT 1
113802: EQUAL
113803: IFFALSE 114251
// begin if WantPlant ( group [ i ] ) then
113805: LD_VAR 0 4
113809: PUSH
113810: LD_VAR 0 7
113814: ARRAY
113815: PPUSH
113816: CALL 54003 0 1
113820: IFFALSE 113824
// continue ;
113822: GO 112096
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
113824: LD_VAR 0 18
113828: PUSH
113829: LD_VAR 0 4
113833: PUSH
113834: LD_VAR 0 7
113838: ARRAY
113839: PPUSH
113840: CALL_OW 310
113844: NOT
113845: AND
113846: PUSH
113847: LD_VAR 0 14
113851: PUSH
113852: LD_INT 1
113854: ARRAY
113855: PUSH
113856: LD_VAR 0 14
113860: PPUSH
113861: LD_INT 21
113863: PUSH
113864: LD_INT 2
113866: PUSH
113867: EMPTY
113868: LIST
113869: LIST
113870: PUSH
113871: LD_INT 58
113873: PUSH
113874: EMPTY
113875: LIST
113876: PUSH
113877: EMPTY
113878: LIST
113879: LIST
113880: PPUSH
113881: CALL_OW 72
113885: IN
113886: AND
113887: IFFALSE 113923
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
113889: LD_VAR 0 4
113893: PUSH
113894: LD_VAR 0 7
113898: ARRAY
113899: PPUSH
113900: LD_VAR 0 14
113904: PUSH
113905: LD_INT 1
113907: ARRAY
113908: PPUSH
113909: CALL_OW 120
// attacking := true ;
113913: LD_ADDR_VAR 0 29
113917: PUSH
113918: LD_INT 1
113920: ST_TO_ADDR
// continue ;
113921: GO 112096
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
113923: LD_VAR 0 26
113927: PUSH
113928: LD_VAR 0 4
113932: PUSH
113933: LD_VAR 0 7
113937: ARRAY
113938: PPUSH
113939: CALL_OW 257
113943: PUSH
113944: LD_INT 1
113946: EQUAL
113947: AND
113948: PUSH
113949: LD_VAR 0 4
113953: PUSH
113954: LD_VAR 0 7
113958: ARRAY
113959: PPUSH
113960: CALL_OW 256
113964: PUSH
113965: LD_INT 800
113967: LESS
113968: AND
113969: PUSH
113970: LD_VAR 0 4
113974: PUSH
113975: LD_VAR 0 7
113979: ARRAY
113980: PPUSH
113981: CALL_OW 318
113985: NOT
113986: AND
113987: IFFALSE 114004
// ComCrawl ( group [ i ] ) ;
113989: LD_VAR 0 4
113993: PUSH
113994: LD_VAR 0 7
113998: ARRAY
113999: PPUSH
114000: CALL_OW 137
// if f_mines then
114004: LD_VAR 0 21
114008: IFFALSE 114251
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
114010: LD_VAR 0 14
114014: PUSH
114015: LD_INT 1
114017: ARRAY
114018: PPUSH
114019: CALL_OW 247
114023: PUSH
114024: LD_INT 3
114026: EQUAL
114027: PUSH
114028: LD_VAR 0 14
114032: PUSH
114033: LD_INT 1
114035: ARRAY
114036: PUSH
114037: LD_VAR 0 27
114041: IN
114042: NOT
114043: AND
114044: IFFALSE 114251
// begin x := GetX ( tmp [ 1 ] ) ;
114046: LD_ADDR_VAR 0 10
114050: PUSH
114051: LD_VAR 0 14
114055: PUSH
114056: LD_INT 1
114058: ARRAY
114059: PPUSH
114060: CALL_OW 250
114064: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
114065: LD_ADDR_VAR 0 11
114069: PUSH
114070: LD_VAR 0 14
114074: PUSH
114075: LD_INT 1
114077: ARRAY
114078: PPUSH
114079: CALL_OW 251
114083: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
114084: LD_ADDR_VAR 0 12
114088: PUSH
114089: LD_VAR 0 4
114093: PUSH
114094: LD_VAR 0 7
114098: ARRAY
114099: PPUSH
114100: CALL 82043 0 1
114104: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
114105: LD_VAR 0 4
114109: PUSH
114110: LD_VAR 0 7
114114: ARRAY
114115: PPUSH
114116: LD_VAR 0 10
114120: PPUSH
114121: LD_VAR 0 11
114125: PPUSH
114126: LD_VAR 0 14
114130: PUSH
114131: LD_INT 1
114133: ARRAY
114134: PPUSH
114135: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
114139: LD_VAR 0 4
114143: PUSH
114144: LD_VAR 0 7
114148: ARRAY
114149: PPUSH
114150: LD_VAR 0 10
114154: PPUSH
114155: LD_VAR 0 12
114159: PPUSH
114160: LD_INT 7
114162: PPUSH
114163: CALL_OW 272
114167: PPUSH
114168: LD_VAR 0 11
114172: PPUSH
114173: LD_VAR 0 12
114177: PPUSH
114178: LD_INT 7
114180: PPUSH
114181: CALL_OW 273
114185: PPUSH
114186: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
114190: LD_VAR 0 4
114194: PUSH
114195: LD_VAR 0 7
114199: ARRAY
114200: PPUSH
114201: LD_INT 71
114203: PPUSH
114204: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
114208: LD_ADDR_VAR 0 27
114212: PUSH
114213: LD_VAR 0 27
114217: PPUSH
114218: LD_VAR 0 27
114222: PUSH
114223: LD_INT 1
114225: PLUS
114226: PPUSH
114227: LD_VAR 0 14
114231: PUSH
114232: LD_INT 1
114234: ARRAY
114235: PPUSH
114236: CALL_OW 1
114240: ST_TO_ADDR
// attacking := true ;
114241: LD_ADDR_VAR 0 29
114245: PUSH
114246: LD_INT 1
114248: ST_TO_ADDR
// continue ;
114249: GO 112096
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
114251: LD_VAR 0 4
114255: PUSH
114256: LD_VAR 0 7
114260: ARRAY
114261: PPUSH
114262: CALL_OW 257
114266: PUSH
114267: LD_INT 17
114269: EQUAL
114270: PUSH
114271: LD_VAR 0 4
114275: PUSH
114276: LD_VAR 0 7
114280: ARRAY
114281: PPUSH
114282: CALL_OW 110
114286: PUSH
114287: LD_INT 71
114289: EQUAL
114290: NOT
114291: AND
114292: IFFALSE 114438
// begin attacking := false ;
114294: LD_ADDR_VAR 0 29
114298: PUSH
114299: LD_INT 0
114301: ST_TO_ADDR
// k := 5 ;
114302: LD_ADDR_VAR 0 9
114306: PUSH
114307: LD_INT 5
114309: ST_TO_ADDR
// if tmp < k then
114310: LD_VAR 0 14
114314: PUSH
114315: LD_VAR 0 9
114319: LESS
114320: IFFALSE 114332
// k := tmp ;
114322: LD_ADDR_VAR 0 9
114326: PUSH
114327: LD_VAR 0 14
114331: ST_TO_ADDR
// for j = 1 to k do
114332: LD_ADDR_VAR 0 8
114336: PUSH
114337: DOUBLE
114338: LD_INT 1
114340: DEC
114341: ST_TO_ADDR
114342: LD_VAR 0 9
114346: PUSH
114347: FOR_TO
114348: IFFALSE 114436
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
114350: LD_VAR 0 14
114354: PUSH
114355: LD_VAR 0 8
114359: ARRAY
114360: PUSH
114361: LD_VAR 0 14
114365: PPUSH
114366: LD_INT 58
114368: PUSH
114369: EMPTY
114370: LIST
114371: PPUSH
114372: CALL_OW 72
114376: IN
114377: NOT
114378: IFFALSE 114434
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
114380: LD_VAR 0 4
114384: PUSH
114385: LD_VAR 0 7
114389: ARRAY
114390: PPUSH
114391: LD_VAR 0 14
114395: PUSH
114396: LD_VAR 0 8
114400: ARRAY
114401: PPUSH
114402: CALL_OW 115
// attacking := true ;
114406: LD_ADDR_VAR 0 29
114410: PUSH
114411: LD_INT 1
114413: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
114414: LD_VAR 0 4
114418: PUSH
114419: LD_VAR 0 7
114423: ARRAY
114424: PPUSH
114425: LD_INT 71
114427: PPUSH
114428: CALL_OW 109
// continue ;
114432: GO 114347
// end ; end ;
114434: GO 114347
114436: POP
114437: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
114438: LD_VAR 0 4
114442: PUSH
114443: LD_VAR 0 7
114447: ARRAY
114448: PPUSH
114449: CALL_OW 257
114453: PUSH
114454: LD_INT 8
114456: EQUAL
114457: PUSH
114458: LD_VAR 0 4
114462: PUSH
114463: LD_VAR 0 7
114467: ARRAY
114468: PPUSH
114469: CALL_OW 264
114473: PUSH
114474: LD_INT 28
114476: PUSH
114477: LD_INT 45
114479: PUSH
114480: LD_INT 7
114482: PUSH
114483: LD_INT 47
114485: PUSH
114486: EMPTY
114487: LIST
114488: LIST
114489: LIST
114490: LIST
114491: IN
114492: OR
114493: IFFALSE 114749
// begin attacking := false ;
114495: LD_ADDR_VAR 0 29
114499: PUSH
114500: LD_INT 0
114502: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
114503: LD_VAR 0 14
114507: PUSH
114508: LD_INT 1
114510: ARRAY
114511: PPUSH
114512: CALL_OW 266
114516: PUSH
114517: LD_INT 32
114519: PUSH
114520: LD_INT 31
114522: PUSH
114523: LD_INT 33
114525: PUSH
114526: LD_INT 4
114528: PUSH
114529: LD_INT 5
114531: PUSH
114532: EMPTY
114533: LIST
114534: LIST
114535: LIST
114536: LIST
114537: LIST
114538: IN
114539: IFFALSE 114725
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
114541: LD_ADDR_VAR 0 9
114545: PUSH
114546: LD_VAR 0 14
114550: PUSH
114551: LD_INT 1
114553: ARRAY
114554: PPUSH
114555: CALL_OW 266
114559: PPUSH
114560: LD_VAR 0 14
114564: PUSH
114565: LD_INT 1
114567: ARRAY
114568: PPUSH
114569: CALL_OW 250
114573: PPUSH
114574: LD_VAR 0 14
114578: PUSH
114579: LD_INT 1
114581: ARRAY
114582: PPUSH
114583: CALL_OW 251
114587: PPUSH
114588: LD_VAR 0 14
114592: PUSH
114593: LD_INT 1
114595: ARRAY
114596: PPUSH
114597: CALL_OW 254
114601: PPUSH
114602: LD_VAR 0 14
114606: PUSH
114607: LD_INT 1
114609: ARRAY
114610: PPUSH
114611: CALL_OW 248
114615: PPUSH
114616: LD_INT 0
114618: PPUSH
114619: CALL 63413 0 6
114623: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
114624: LD_ADDR_VAR 0 8
114628: PUSH
114629: LD_VAR 0 4
114633: PUSH
114634: LD_VAR 0 7
114638: ARRAY
114639: PPUSH
114640: LD_VAR 0 9
114644: PPUSH
114645: CALL 82156 0 2
114649: ST_TO_ADDR
// if j then
114650: LD_VAR 0 8
114654: IFFALSE 114723
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
114656: LD_VAR 0 8
114660: PUSH
114661: LD_INT 1
114663: ARRAY
114664: PPUSH
114665: LD_VAR 0 8
114669: PUSH
114670: LD_INT 2
114672: ARRAY
114673: PPUSH
114674: CALL_OW 488
114678: IFFALSE 114723
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
114680: LD_VAR 0 4
114684: PUSH
114685: LD_VAR 0 7
114689: ARRAY
114690: PPUSH
114691: LD_VAR 0 8
114695: PUSH
114696: LD_INT 1
114698: ARRAY
114699: PPUSH
114700: LD_VAR 0 8
114704: PUSH
114705: LD_INT 2
114707: ARRAY
114708: PPUSH
114709: CALL_OW 116
// attacking := true ;
114713: LD_ADDR_VAR 0 29
114717: PUSH
114718: LD_INT 1
114720: ST_TO_ADDR
// continue ;
114721: GO 112096
// end ; end else
114723: GO 114749
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
114725: LD_VAR 0 4
114729: PUSH
114730: LD_VAR 0 7
114734: ARRAY
114735: PPUSH
114736: LD_VAR 0 14
114740: PUSH
114741: LD_INT 1
114743: ARRAY
114744: PPUSH
114745: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
114749: LD_VAR 0 4
114753: PUSH
114754: LD_VAR 0 7
114758: ARRAY
114759: PPUSH
114760: CALL_OW 265
114764: PUSH
114765: LD_INT 11
114767: EQUAL
114768: IFFALSE 115046
// begin k := 10 ;
114770: LD_ADDR_VAR 0 9
114774: PUSH
114775: LD_INT 10
114777: ST_TO_ADDR
// x := 0 ;
114778: LD_ADDR_VAR 0 10
114782: PUSH
114783: LD_INT 0
114785: ST_TO_ADDR
// if tmp < k then
114786: LD_VAR 0 14
114790: PUSH
114791: LD_VAR 0 9
114795: LESS
114796: IFFALSE 114808
// k := tmp ;
114798: LD_ADDR_VAR 0 9
114802: PUSH
114803: LD_VAR 0 14
114807: ST_TO_ADDR
// for j = k downto 1 do
114808: LD_ADDR_VAR 0 8
114812: PUSH
114813: DOUBLE
114814: LD_VAR 0 9
114818: INC
114819: ST_TO_ADDR
114820: LD_INT 1
114822: PUSH
114823: FOR_DOWNTO
114824: IFFALSE 114899
// begin if GetType ( tmp [ j ] ) = unit_human then
114826: LD_VAR 0 14
114830: PUSH
114831: LD_VAR 0 8
114835: ARRAY
114836: PPUSH
114837: CALL_OW 247
114841: PUSH
114842: LD_INT 1
114844: EQUAL
114845: IFFALSE 114897
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
114847: LD_VAR 0 4
114851: PUSH
114852: LD_VAR 0 7
114856: ARRAY
114857: PPUSH
114858: LD_VAR 0 14
114862: PUSH
114863: LD_VAR 0 8
114867: ARRAY
114868: PPUSH
114869: CALL 82410 0 2
// x := tmp [ j ] ;
114873: LD_ADDR_VAR 0 10
114877: PUSH
114878: LD_VAR 0 14
114882: PUSH
114883: LD_VAR 0 8
114887: ARRAY
114888: ST_TO_ADDR
// attacking := true ;
114889: LD_ADDR_VAR 0 29
114893: PUSH
114894: LD_INT 1
114896: ST_TO_ADDR
// end ; end ;
114897: GO 114823
114899: POP
114900: POP
// if not x then
114901: LD_VAR 0 10
114905: NOT
114906: IFFALSE 115046
// begin attacking := true ;
114908: LD_ADDR_VAR 0 29
114912: PUSH
114913: LD_INT 1
114915: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
114916: LD_VAR 0 4
114920: PUSH
114921: LD_VAR 0 7
114925: ARRAY
114926: PPUSH
114927: CALL_OW 250
114931: PPUSH
114932: LD_VAR 0 4
114936: PUSH
114937: LD_VAR 0 7
114941: ARRAY
114942: PPUSH
114943: CALL_OW 251
114947: PPUSH
114948: CALL_OW 546
114952: PUSH
114953: LD_INT 2
114955: ARRAY
114956: PUSH
114957: LD_VAR 0 14
114961: PUSH
114962: LD_INT 1
114964: ARRAY
114965: PPUSH
114966: CALL_OW 250
114970: PPUSH
114971: LD_VAR 0 14
114975: PUSH
114976: LD_INT 1
114978: ARRAY
114979: PPUSH
114980: CALL_OW 251
114984: PPUSH
114985: CALL_OW 546
114989: PUSH
114990: LD_INT 2
114992: ARRAY
114993: EQUAL
114994: IFFALSE 115022
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
114996: LD_VAR 0 4
115000: PUSH
115001: LD_VAR 0 7
115005: ARRAY
115006: PPUSH
115007: LD_VAR 0 14
115011: PUSH
115012: LD_INT 1
115014: ARRAY
115015: PPUSH
115016: CALL 82410 0 2
115020: GO 115046
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
115022: LD_VAR 0 4
115026: PUSH
115027: LD_VAR 0 7
115031: ARRAY
115032: PPUSH
115033: LD_VAR 0 14
115037: PUSH
115038: LD_INT 1
115040: ARRAY
115041: PPUSH
115042: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
115046: LD_VAR 0 4
115050: PUSH
115051: LD_VAR 0 7
115055: ARRAY
115056: PPUSH
115057: CALL_OW 264
115061: PUSH
115062: LD_INT 29
115064: EQUAL
115065: IFFALSE 115431
// begin if WantsToAttack ( group [ i ] ) in bombed then
115067: LD_VAR 0 4
115071: PUSH
115072: LD_VAR 0 7
115076: ARRAY
115077: PPUSH
115078: CALL_OW 319
115082: PUSH
115083: LD_VAR 0 28
115087: IN
115088: IFFALSE 115092
// continue ;
115090: GO 112096
// k := 8 ;
115092: LD_ADDR_VAR 0 9
115096: PUSH
115097: LD_INT 8
115099: ST_TO_ADDR
// x := 0 ;
115100: LD_ADDR_VAR 0 10
115104: PUSH
115105: LD_INT 0
115107: ST_TO_ADDR
// if tmp < k then
115108: LD_VAR 0 14
115112: PUSH
115113: LD_VAR 0 9
115117: LESS
115118: IFFALSE 115130
// k := tmp ;
115120: LD_ADDR_VAR 0 9
115124: PUSH
115125: LD_VAR 0 14
115129: ST_TO_ADDR
// for j = 1 to k do
115130: LD_ADDR_VAR 0 8
115134: PUSH
115135: DOUBLE
115136: LD_INT 1
115138: DEC
115139: ST_TO_ADDR
115140: LD_VAR 0 9
115144: PUSH
115145: FOR_TO
115146: IFFALSE 115278
// begin if GetType ( tmp [ j ] ) = unit_building then
115148: LD_VAR 0 14
115152: PUSH
115153: LD_VAR 0 8
115157: ARRAY
115158: PPUSH
115159: CALL_OW 247
115163: PUSH
115164: LD_INT 3
115166: EQUAL
115167: IFFALSE 115276
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
115169: LD_VAR 0 14
115173: PUSH
115174: LD_VAR 0 8
115178: ARRAY
115179: PUSH
115180: LD_VAR 0 28
115184: IN
115185: NOT
115186: PUSH
115187: LD_VAR 0 14
115191: PUSH
115192: LD_VAR 0 8
115196: ARRAY
115197: PPUSH
115198: CALL_OW 313
115202: AND
115203: IFFALSE 115276
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
115205: LD_VAR 0 4
115209: PUSH
115210: LD_VAR 0 7
115214: ARRAY
115215: PPUSH
115216: LD_VAR 0 14
115220: PUSH
115221: LD_VAR 0 8
115225: ARRAY
115226: PPUSH
115227: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
115231: LD_ADDR_VAR 0 28
115235: PUSH
115236: LD_VAR 0 28
115240: PPUSH
115241: LD_VAR 0 28
115245: PUSH
115246: LD_INT 1
115248: PLUS
115249: PPUSH
115250: LD_VAR 0 14
115254: PUSH
115255: LD_VAR 0 8
115259: ARRAY
115260: PPUSH
115261: CALL_OW 1
115265: ST_TO_ADDR
// attacking := true ;
115266: LD_ADDR_VAR 0 29
115270: PUSH
115271: LD_INT 1
115273: ST_TO_ADDR
// break ;
115274: GO 115278
// end ; end ;
115276: GO 115145
115278: POP
115279: POP
// if not attacking and f_attack_depot then
115280: LD_VAR 0 29
115284: NOT
115285: PUSH
115286: LD_VAR 0 25
115290: AND
115291: IFFALSE 115386
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
115293: LD_ADDR_VAR 0 13
115297: PUSH
115298: LD_VAR 0 14
115302: PPUSH
115303: LD_INT 2
115305: PUSH
115306: LD_INT 30
115308: PUSH
115309: LD_INT 0
115311: PUSH
115312: EMPTY
115313: LIST
115314: LIST
115315: PUSH
115316: LD_INT 30
115318: PUSH
115319: LD_INT 1
115321: PUSH
115322: EMPTY
115323: LIST
115324: LIST
115325: PUSH
115326: EMPTY
115327: LIST
115328: LIST
115329: LIST
115330: PPUSH
115331: CALL_OW 72
115335: ST_TO_ADDR
// if z then
115336: LD_VAR 0 13
115340: IFFALSE 115386
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
115342: LD_VAR 0 4
115346: PUSH
115347: LD_VAR 0 7
115351: ARRAY
115352: PPUSH
115353: LD_VAR 0 13
115357: PPUSH
115358: LD_VAR 0 4
115362: PUSH
115363: LD_VAR 0 7
115367: ARRAY
115368: PPUSH
115369: CALL_OW 74
115373: PPUSH
115374: CALL_OW 115
// attacking := true ;
115378: LD_ADDR_VAR 0 29
115382: PUSH
115383: LD_INT 1
115385: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
115386: LD_VAR 0 4
115390: PUSH
115391: LD_VAR 0 7
115395: ARRAY
115396: PPUSH
115397: CALL_OW 256
115401: PUSH
115402: LD_INT 500
115404: LESS
115405: IFFALSE 115431
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
115407: LD_VAR 0 4
115411: PUSH
115412: LD_VAR 0 7
115416: ARRAY
115417: PPUSH
115418: LD_VAR 0 14
115422: PUSH
115423: LD_INT 1
115425: ARRAY
115426: PPUSH
115427: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
115431: LD_VAR 0 4
115435: PUSH
115436: LD_VAR 0 7
115440: ARRAY
115441: PPUSH
115442: CALL_OW 264
115446: PUSH
115447: LD_INT 49
115449: EQUAL
115450: IFFALSE 115571
// begin if not HasTask ( group [ i ] ) then
115452: LD_VAR 0 4
115456: PUSH
115457: LD_VAR 0 7
115461: ARRAY
115462: PPUSH
115463: CALL_OW 314
115467: NOT
115468: IFFALSE 115571
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
115470: LD_ADDR_VAR 0 9
115474: PUSH
115475: LD_INT 81
115477: PUSH
115478: LD_VAR 0 4
115482: PUSH
115483: LD_VAR 0 7
115487: ARRAY
115488: PPUSH
115489: CALL_OW 255
115493: PUSH
115494: EMPTY
115495: LIST
115496: LIST
115497: PPUSH
115498: CALL_OW 69
115502: PPUSH
115503: LD_VAR 0 4
115507: PUSH
115508: LD_VAR 0 7
115512: ARRAY
115513: PPUSH
115514: CALL_OW 74
115518: ST_TO_ADDR
// if k then
115519: LD_VAR 0 9
115523: IFFALSE 115571
// if GetDistUnits ( group [ i ] , k ) > 10 then
115525: LD_VAR 0 4
115529: PUSH
115530: LD_VAR 0 7
115534: ARRAY
115535: PPUSH
115536: LD_VAR 0 9
115540: PPUSH
115541: CALL_OW 296
115545: PUSH
115546: LD_INT 10
115548: GREATER
115549: IFFALSE 115571
// ComMoveUnit ( group [ i ] , k ) ;
115551: LD_VAR 0 4
115555: PUSH
115556: LD_VAR 0 7
115560: ARRAY
115561: PPUSH
115562: LD_VAR 0 9
115566: PPUSH
115567: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
115571: LD_VAR 0 4
115575: PUSH
115576: LD_VAR 0 7
115580: ARRAY
115581: PPUSH
115582: CALL_OW 256
115586: PUSH
115587: LD_INT 250
115589: LESS
115590: PUSH
115591: LD_VAR 0 4
115595: PUSH
115596: LD_VAR 0 7
115600: ARRAY
115601: PUSH
115602: LD_INT 21
115604: PUSH
115605: LD_INT 2
115607: PUSH
115608: EMPTY
115609: LIST
115610: LIST
115611: PUSH
115612: LD_INT 23
115614: PUSH
115615: LD_INT 2
115617: PUSH
115618: EMPTY
115619: LIST
115620: LIST
115621: PUSH
115622: EMPTY
115623: LIST
115624: LIST
115625: PPUSH
115626: CALL_OW 69
115630: IN
115631: AND
115632: IFFALSE 115757
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
115634: LD_ADDR_VAR 0 9
115638: PUSH
115639: LD_OWVAR 3
115643: PUSH
115644: LD_VAR 0 4
115648: PUSH
115649: LD_VAR 0 7
115653: ARRAY
115654: DIFF
115655: PPUSH
115656: LD_VAR 0 4
115660: PUSH
115661: LD_VAR 0 7
115665: ARRAY
115666: PPUSH
115667: CALL_OW 74
115671: ST_TO_ADDR
// if not k then
115672: LD_VAR 0 9
115676: NOT
115677: IFFALSE 115681
// continue ;
115679: GO 112096
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
115681: LD_VAR 0 9
115685: PUSH
115686: LD_INT 81
115688: PUSH
115689: LD_VAR 0 4
115693: PUSH
115694: LD_VAR 0 7
115698: ARRAY
115699: PPUSH
115700: CALL_OW 255
115704: PUSH
115705: EMPTY
115706: LIST
115707: LIST
115708: PPUSH
115709: CALL_OW 69
115713: IN
115714: PUSH
115715: LD_VAR 0 9
115719: PPUSH
115720: LD_VAR 0 4
115724: PUSH
115725: LD_VAR 0 7
115729: ARRAY
115730: PPUSH
115731: CALL_OW 296
115735: PUSH
115736: LD_INT 5
115738: LESS
115739: AND
115740: IFFALSE 115757
// ComAutodestruct ( group [ i ] ) ;
115742: LD_VAR 0 4
115746: PUSH
115747: LD_VAR 0 7
115751: ARRAY
115752: PPUSH
115753: CALL 82308 0 1
// end ; if f_attack_depot then
115757: LD_VAR 0 25
115761: IFFALSE 115873
// begin k := 6 ;
115763: LD_ADDR_VAR 0 9
115767: PUSH
115768: LD_INT 6
115770: ST_TO_ADDR
// if tmp < k then
115771: LD_VAR 0 14
115775: PUSH
115776: LD_VAR 0 9
115780: LESS
115781: IFFALSE 115793
// k := tmp ;
115783: LD_ADDR_VAR 0 9
115787: PUSH
115788: LD_VAR 0 14
115792: ST_TO_ADDR
// for j = 1 to k do
115793: LD_ADDR_VAR 0 8
115797: PUSH
115798: DOUBLE
115799: LD_INT 1
115801: DEC
115802: ST_TO_ADDR
115803: LD_VAR 0 9
115807: PUSH
115808: FOR_TO
115809: IFFALSE 115871
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
115811: LD_VAR 0 8
115815: PPUSH
115816: CALL_OW 266
115820: PUSH
115821: LD_INT 0
115823: PUSH
115824: LD_INT 1
115826: PUSH
115827: EMPTY
115828: LIST
115829: LIST
115830: IN
115831: IFFALSE 115869
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
115833: LD_VAR 0 4
115837: PUSH
115838: LD_VAR 0 7
115842: ARRAY
115843: PPUSH
115844: LD_VAR 0 14
115848: PUSH
115849: LD_VAR 0 8
115853: ARRAY
115854: PPUSH
115855: CALL_OW 115
// attacking := true ;
115859: LD_ADDR_VAR 0 29
115863: PUSH
115864: LD_INT 1
115866: ST_TO_ADDR
// break ;
115867: GO 115871
// end ;
115869: GO 115808
115871: POP
115872: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
115873: LD_VAR 0 4
115877: PUSH
115878: LD_VAR 0 7
115882: ARRAY
115883: PPUSH
115884: CALL_OW 302
115888: PUSH
115889: LD_VAR 0 29
115893: NOT
115894: AND
115895: IFFALSE 116217
// begin if GetTag ( group [ i ] ) = 71 then
115897: LD_VAR 0 4
115901: PUSH
115902: LD_VAR 0 7
115906: ARRAY
115907: PPUSH
115908: CALL_OW 110
115912: PUSH
115913: LD_INT 71
115915: EQUAL
115916: IFFALSE 115957
// begin if HasTask ( group [ i ] ) then
115918: LD_VAR 0 4
115922: PUSH
115923: LD_VAR 0 7
115927: ARRAY
115928: PPUSH
115929: CALL_OW 314
115933: IFFALSE 115939
// continue else
115935: GO 112096
115937: GO 115957
// SetTag ( group [ i ] , 0 ) ;
115939: LD_VAR 0 4
115943: PUSH
115944: LD_VAR 0 7
115948: ARRAY
115949: PPUSH
115950: LD_INT 0
115952: PPUSH
115953: CALL_OW 109
// end ; k := 8 ;
115957: LD_ADDR_VAR 0 9
115961: PUSH
115962: LD_INT 8
115964: ST_TO_ADDR
// x := 0 ;
115965: LD_ADDR_VAR 0 10
115969: PUSH
115970: LD_INT 0
115972: ST_TO_ADDR
// if tmp < k then
115973: LD_VAR 0 14
115977: PUSH
115978: LD_VAR 0 9
115982: LESS
115983: IFFALSE 115995
// k := tmp ;
115985: LD_ADDR_VAR 0 9
115989: PUSH
115990: LD_VAR 0 14
115994: ST_TO_ADDR
// for j = 1 to k do
115995: LD_ADDR_VAR 0 8
115999: PUSH
116000: DOUBLE
116001: LD_INT 1
116003: DEC
116004: ST_TO_ADDR
116005: LD_VAR 0 9
116009: PUSH
116010: FOR_TO
116011: IFFALSE 116109
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
116013: LD_VAR 0 14
116017: PUSH
116018: LD_VAR 0 8
116022: ARRAY
116023: PPUSH
116024: CALL_OW 247
116028: PUSH
116029: LD_INT 1
116031: EQUAL
116032: PUSH
116033: LD_VAR 0 14
116037: PUSH
116038: LD_VAR 0 8
116042: ARRAY
116043: PPUSH
116044: CALL_OW 256
116048: PUSH
116049: LD_INT 250
116051: LESS
116052: PUSH
116053: LD_VAR 0 20
116057: AND
116058: PUSH
116059: LD_VAR 0 20
116063: NOT
116064: PUSH
116065: LD_VAR 0 14
116069: PUSH
116070: LD_VAR 0 8
116074: ARRAY
116075: PPUSH
116076: CALL_OW 256
116080: PUSH
116081: LD_INT 250
116083: GREATEREQUAL
116084: AND
116085: OR
116086: AND
116087: IFFALSE 116107
// begin x := tmp [ j ] ;
116089: LD_ADDR_VAR 0 10
116093: PUSH
116094: LD_VAR 0 14
116098: PUSH
116099: LD_VAR 0 8
116103: ARRAY
116104: ST_TO_ADDR
// break ;
116105: GO 116109
// end ;
116107: GO 116010
116109: POP
116110: POP
// if x then
116111: LD_VAR 0 10
116115: IFFALSE 116139
// ComAttackUnit ( group [ i ] , x ) else
116117: LD_VAR 0 4
116121: PUSH
116122: LD_VAR 0 7
116126: ARRAY
116127: PPUSH
116128: LD_VAR 0 10
116132: PPUSH
116133: CALL_OW 115
116137: GO 116163
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
116139: LD_VAR 0 4
116143: PUSH
116144: LD_VAR 0 7
116148: ARRAY
116149: PPUSH
116150: LD_VAR 0 14
116154: PUSH
116155: LD_INT 1
116157: ARRAY
116158: PPUSH
116159: CALL_OW 115
// if not HasTask ( group [ i ] ) then
116163: LD_VAR 0 4
116167: PUSH
116168: LD_VAR 0 7
116172: ARRAY
116173: PPUSH
116174: CALL_OW 314
116178: NOT
116179: IFFALSE 116217
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
116181: LD_VAR 0 4
116185: PUSH
116186: LD_VAR 0 7
116190: ARRAY
116191: PPUSH
116192: LD_VAR 0 14
116196: PPUSH
116197: LD_VAR 0 4
116201: PUSH
116202: LD_VAR 0 7
116206: ARRAY
116207: PPUSH
116208: CALL_OW 74
116212: PPUSH
116213: CALL_OW 115
// end ; end ; end ;
116217: GO 112096
116219: POP
116220: POP
// wait ( 0 0$2 ) ;
116221: LD_INT 70
116223: PPUSH
116224: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
116228: LD_VAR 0 4
116232: NOT
116233: PUSH
116234: LD_VAR 0 4
116238: PUSH
116239: EMPTY
116240: EQUAL
116241: OR
116242: PUSH
116243: LD_INT 81
116245: PUSH
116246: LD_VAR 0 35
116250: PUSH
116251: EMPTY
116252: LIST
116253: LIST
116254: PPUSH
116255: CALL_OW 69
116259: NOT
116260: OR
116261: IFFALSE 112081
// end ;
116263: LD_VAR 0 2
116267: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
116268: LD_INT 0
116270: PPUSH
116271: PPUSH
116272: PPUSH
116273: PPUSH
116274: PPUSH
116275: PPUSH
// if not base or not mc_bases [ base ] or not solds then
116276: LD_VAR 0 1
116280: NOT
116281: PUSH
116282: LD_EXP 50
116286: PUSH
116287: LD_VAR 0 1
116291: ARRAY
116292: NOT
116293: OR
116294: PUSH
116295: LD_VAR 0 2
116299: NOT
116300: OR
116301: IFFALSE 116305
// exit ;
116303: GO 116859
// side := mc_sides [ base ] ;
116305: LD_ADDR_VAR 0 6
116309: PUSH
116310: LD_EXP 76
116314: PUSH
116315: LD_VAR 0 1
116319: ARRAY
116320: ST_TO_ADDR
// if not side then
116321: LD_VAR 0 6
116325: NOT
116326: IFFALSE 116330
// exit ;
116328: GO 116859
// for i in solds do
116330: LD_ADDR_VAR 0 7
116334: PUSH
116335: LD_VAR 0 2
116339: PUSH
116340: FOR_IN
116341: IFFALSE 116402
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
116343: LD_VAR 0 7
116347: PPUSH
116348: CALL_OW 310
116352: PPUSH
116353: CALL_OW 266
116357: PUSH
116358: LD_INT 32
116360: PUSH
116361: LD_INT 31
116363: PUSH
116364: EMPTY
116365: LIST
116366: LIST
116367: IN
116368: IFFALSE 116388
// solds := solds diff i else
116370: LD_ADDR_VAR 0 2
116374: PUSH
116375: LD_VAR 0 2
116379: PUSH
116380: LD_VAR 0 7
116384: DIFF
116385: ST_TO_ADDR
116386: GO 116400
// SetTag ( i , 18 ) ;
116388: LD_VAR 0 7
116392: PPUSH
116393: LD_INT 18
116395: PPUSH
116396: CALL_OW 109
116400: GO 116340
116402: POP
116403: POP
// if not solds then
116404: LD_VAR 0 2
116408: NOT
116409: IFFALSE 116413
// exit ;
116411: GO 116859
// repeat wait ( 0 0$2 ) ;
116413: LD_INT 70
116415: PPUSH
116416: CALL_OW 67
// enemy := mc_scan [ base ] ;
116420: LD_ADDR_VAR 0 4
116424: PUSH
116425: LD_EXP 73
116429: PUSH
116430: LD_VAR 0 1
116434: ARRAY
116435: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
116436: LD_EXP 50
116440: PUSH
116441: LD_VAR 0 1
116445: ARRAY
116446: NOT
116447: PUSH
116448: LD_EXP 50
116452: PUSH
116453: LD_VAR 0 1
116457: ARRAY
116458: PUSH
116459: EMPTY
116460: EQUAL
116461: OR
116462: IFFALSE 116499
// begin for i in solds do
116464: LD_ADDR_VAR 0 7
116468: PUSH
116469: LD_VAR 0 2
116473: PUSH
116474: FOR_IN
116475: IFFALSE 116488
// ComStop ( i ) ;
116477: LD_VAR 0 7
116481: PPUSH
116482: CALL_OW 141
116486: GO 116474
116488: POP
116489: POP
// solds := [ ] ;
116490: LD_ADDR_VAR 0 2
116494: PUSH
116495: EMPTY
116496: ST_TO_ADDR
// exit ;
116497: GO 116859
// end ; for i in solds do
116499: LD_ADDR_VAR 0 7
116503: PUSH
116504: LD_VAR 0 2
116508: PUSH
116509: FOR_IN
116510: IFFALSE 116831
// begin if IsInUnit ( i ) then
116512: LD_VAR 0 7
116516: PPUSH
116517: CALL_OW 310
116521: IFFALSE 116532
// ComExitBuilding ( i ) ;
116523: LD_VAR 0 7
116527: PPUSH
116528: CALL_OW 122
// if GetLives ( i ) > 500 then
116532: LD_VAR 0 7
116536: PPUSH
116537: CALL_OW 256
116541: PUSH
116542: LD_INT 500
116544: GREATER
116545: IFFALSE 116598
// begin e := NearestUnitToUnit ( enemy , i ) ;
116547: LD_ADDR_VAR 0 5
116551: PUSH
116552: LD_VAR 0 4
116556: PPUSH
116557: LD_VAR 0 7
116561: PPUSH
116562: CALL_OW 74
116566: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
116567: LD_VAR 0 7
116571: PPUSH
116572: LD_VAR 0 5
116576: PPUSH
116577: CALL_OW 250
116581: PPUSH
116582: LD_VAR 0 5
116586: PPUSH
116587: CALL_OW 251
116591: PPUSH
116592: CALL_OW 114
// end else
116596: GO 116829
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
116598: LD_VAR 0 7
116602: PPUSH
116603: LD_EXP 50
116607: PUSH
116608: LD_VAR 0 1
116612: ARRAY
116613: PPUSH
116614: LD_INT 2
116616: PUSH
116617: LD_INT 30
116619: PUSH
116620: LD_INT 0
116622: PUSH
116623: EMPTY
116624: LIST
116625: LIST
116626: PUSH
116627: LD_INT 30
116629: PUSH
116630: LD_INT 1
116632: PUSH
116633: EMPTY
116634: LIST
116635: LIST
116636: PUSH
116637: LD_INT 30
116639: PUSH
116640: LD_INT 6
116642: PUSH
116643: EMPTY
116644: LIST
116645: LIST
116646: PUSH
116647: EMPTY
116648: LIST
116649: LIST
116650: LIST
116651: LIST
116652: PPUSH
116653: CALL_OW 72
116657: PPUSH
116658: LD_VAR 0 7
116662: PPUSH
116663: CALL_OW 74
116667: PPUSH
116668: CALL_OW 296
116672: PUSH
116673: LD_INT 10
116675: GREATER
116676: IFFALSE 116829
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
116678: LD_ADDR_VAR 0 8
116682: PUSH
116683: LD_EXP 50
116687: PUSH
116688: LD_VAR 0 1
116692: ARRAY
116693: PPUSH
116694: LD_INT 2
116696: PUSH
116697: LD_INT 30
116699: PUSH
116700: LD_INT 0
116702: PUSH
116703: EMPTY
116704: LIST
116705: LIST
116706: PUSH
116707: LD_INT 30
116709: PUSH
116710: LD_INT 1
116712: PUSH
116713: EMPTY
116714: LIST
116715: LIST
116716: PUSH
116717: LD_INT 30
116719: PUSH
116720: LD_INT 6
116722: PUSH
116723: EMPTY
116724: LIST
116725: LIST
116726: PUSH
116727: EMPTY
116728: LIST
116729: LIST
116730: LIST
116731: LIST
116732: PPUSH
116733: CALL_OW 72
116737: PPUSH
116738: LD_VAR 0 7
116742: PPUSH
116743: CALL_OW 74
116747: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
116748: LD_VAR 0 7
116752: PPUSH
116753: LD_VAR 0 8
116757: PPUSH
116758: CALL_OW 250
116762: PPUSH
116763: LD_INT 3
116765: PPUSH
116766: LD_INT 5
116768: PPUSH
116769: CALL_OW 272
116773: PPUSH
116774: LD_VAR 0 8
116778: PPUSH
116779: CALL_OW 251
116783: PPUSH
116784: LD_INT 3
116786: PPUSH
116787: LD_INT 5
116789: PPUSH
116790: CALL_OW 273
116794: PPUSH
116795: CALL_OW 111
// SetTag ( i , 0 ) ;
116799: LD_VAR 0 7
116803: PPUSH
116804: LD_INT 0
116806: PPUSH
116807: CALL_OW 109
// solds := solds diff i ;
116811: LD_ADDR_VAR 0 2
116815: PUSH
116816: LD_VAR 0 2
116820: PUSH
116821: LD_VAR 0 7
116825: DIFF
116826: ST_TO_ADDR
// continue ;
116827: GO 116509
// end ; end ;
116829: GO 116509
116831: POP
116832: POP
// until not solds or not enemy ;
116833: LD_VAR 0 2
116837: NOT
116838: PUSH
116839: LD_VAR 0 4
116843: NOT
116844: OR
116845: IFFALSE 116413
// MC_Reset ( base , 18 ) ;
116847: LD_VAR 0 1
116851: PPUSH
116852: LD_INT 18
116854: PPUSH
116855: CALL 22566 0 2
// end ;
116859: LD_VAR 0 3
116863: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
116864: LD_INT 0
116866: PPUSH
116867: PPUSH
116868: PPUSH
116869: PPUSH
116870: PPUSH
116871: PPUSH
116872: PPUSH
116873: PPUSH
116874: PPUSH
116875: PPUSH
116876: PPUSH
116877: PPUSH
116878: PPUSH
116879: PPUSH
116880: PPUSH
116881: PPUSH
116882: PPUSH
116883: PPUSH
116884: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
116885: LD_ADDR_VAR 0 12
116889: PUSH
116890: LD_EXP 50
116894: PUSH
116895: LD_VAR 0 1
116899: ARRAY
116900: PPUSH
116901: LD_INT 25
116903: PUSH
116904: LD_INT 3
116906: PUSH
116907: EMPTY
116908: LIST
116909: LIST
116910: PPUSH
116911: CALL_OW 72
116915: ST_TO_ADDR
// if mc_remote_driver [ base ] then
116916: LD_EXP 90
116920: PUSH
116921: LD_VAR 0 1
116925: ARRAY
116926: IFFALSE 116950
// mechs := mechs diff mc_remote_driver [ base ] ;
116928: LD_ADDR_VAR 0 12
116932: PUSH
116933: LD_VAR 0 12
116937: PUSH
116938: LD_EXP 90
116942: PUSH
116943: LD_VAR 0 1
116947: ARRAY
116948: DIFF
116949: ST_TO_ADDR
// for i in mechs do
116950: LD_ADDR_VAR 0 4
116954: PUSH
116955: LD_VAR 0 12
116959: PUSH
116960: FOR_IN
116961: IFFALSE 116996
// if GetTag ( i ) > 0 then
116963: LD_VAR 0 4
116967: PPUSH
116968: CALL_OW 110
116972: PUSH
116973: LD_INT 0
116975: GREATER
116976: IFFALSE 116994
// mechs := mechs diff i ;
116978: LD_ADDR_VAR 0 12
116982: PUSH
116983: LD_VAR 0 12
116987: PUSH
116988: LD_VAR 0 4
116992: DIFF
116993: ST_TO_ADDR
116994: GO 116960
116996: POP
116997: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
116998: LD_ADDR_VAR 0 8
117002: PUSH
117003: LD_EXP 50
117007: PUSH
117008: LD_VAR 0 1
117012: ARRAY
117013: PPUSH
117014: LD_INT 2
117016: PUSH
117017: LD_INT 25
117019: PUSH
117020: LD_INT 1
117022: PUSH
117023: EMPTY
117024: LIST
117025: LIST
117026: PUSH
117027: LD_INT 25
117029: PUSH
117030: LD_INT 5
117032: PUSH
117033: EMPTY
117034: LIST
117035: LIST
117036: PUSH
117037: LD_INT 25
117039: PUSH
117040: LD_INT 8
117042: PUSH
117043: EMPTY
117044: LIST
117045: LIST
117046: PUSH
117047: LD_INT 25
117049: PUSH
117050: LD_INT 9
117052: PUSH
117053: EMPTY
117054: LIST
117055: LIST
117056: PUSH
117057: EMPTY
117058: LIST
117059: LIST
117060: LIST
117061: LIST
117062: LIST
117063: PPUSH
117064: CALL_OW 72
117068: ST_TO_ADDR
// if not defenders and not solds then
117069: LD_VAR 0 2
117073: NOT
117074: PUSH
117075: LD_VAR 0 8
117079: NOT
117080: AND
117081: IFFALSE 117085
// exit ;
117083: GO 118855
// depot_under_attack := false ;
117085: LD_ADDR_VAR 0 16
117089: PUSH
117090: LD_INT 0
117092: ST_TO_ADDR
// sold_defenders := [ ] ;
117093: LD_ADDR_VAR 0 17
117097: PUSH
117098: EMPTY
117099: ST_TO_ADDR
// if mechs then
117100: LD_VAR 0 12
117104: IFFALSE 117257
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
117106: LD_ADDR_VAR 0 4
117110: PUSH
117111: LD_VAR 0 2
117115: PPUSH
117116: LD_INT 21
117118: PUSH
117119: LD_INT 2
117121: PUSH
117122: EMPTY
117123: LIST
117124: LIST
117125: PPUSH
117126: CALL_OW 72
117130: PUSH
117131: FOR_IN
117132: IFFALSE 117255
// begin if GetTag ( i ) <> 20 then
117134: LD_VAR 0 4
117138: PPUSH
117139: CALL_OW 110
117143: PUSH
117144: LD_INT 20
117146: NONEQUAL
117147: IFFALSE 117161
// SetTag ( i , 20 ) ;
117149: LD_VAR 0 4
117153: PPUSH
117154: LD_INT 20
117156: PPUSH
117157: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
117161: LD_VAR 0 4
117165: PPUSH
117166: CALL_OW 263
117170: PUSH
117171: LD_INT 1
117173: EQUAL
117174: PUSH
117175: LD_VAR 0 4
117179: PPUSH
117180: CALL_OW 311
117184: NOT
117185: AND
117186: IFFALSE 117253
// begin un := mechs [ 1 ] ;
117188: LD_ADDR_VAR 0 10
117192: PUSH
117193: LD_VAR 0 12
117197: PUSH
117198: LD_INT 1
117200: ARRAY
117201: ST_TO_ADDR
// ComExit ( un ) ;
117202: LD_VAR 0 10
117206: PPUSH
117207: CALL 87205 0 1
// AddComEnterUnit ( un , i ) ;
117211: LD_VAR 0 10
117215: PPUSH
117216: LD_VAR 0 4
117220: PPUSH
117221: CALL_OW 180
// SetTag ( un , 19 ) ;
117225: LD_VAR 0 10
117229: PPUSH
117230: LD_INT 19
117232: PPUSH
117233: CALL_OW 109
// mechs := mechs diff un ;
117237: LD_ADDR_VAR 0 12
117241: PUSH
117242: LD_VAR 0 12
117246: PUSH
117247: LD_VAR 0 10
117251: DIFF
117252: ST_TO_ADDR
// end ; end ;
117253: GO 117131
117255: POP
117256: POP
// if solds then
117257: LD_VAR 0 8
117261: IFFALSE 117320
// for i in solds do
117263: LD_ADDR_VAR 0 4
117267: PUSH
117268: LD_VAR 0 8
117272: PUSH
117273: FOR_IN
117274: IFFALSE 117318
// if not GetTag ( i ) then
117276: LD_VAR 0 4
117280: PPUSH
117281: CALL_OW 110
117285: NOT
117286: IFFALSE 117316
// begin defenders := defenders union i ;
117288: LD_ADDR_VAR 0 2
117292: PUSH
117293: LD_VAR 0 2
117297: PUSH
117298: LD_VAR 0 4
117302: UNION
117303: ST_TO_ADDR
// SetTag ( i , 18 ) ;
117304: LD_VAR 0 4
117308: PPUSH
117309: LD_INT 18
117311: PPUSH
117312: CALL_OW 109
// end ;
117316: GO 117273
117318: POP
117319: POP
// repeat wait ( 0 0$2 ) ;
117320: LD_INT 70
117322: PPUSH
117323: CALL_OW 67
// enemy := mc_scan [ base ] ;
117327: LD_ADDR_VAR 0 21
117331: PUSH
117332: LD_EXP 73
117336: PUSH
117337: LD_VAR 0 1
117341: ARRAY
117342: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
117343: LD_EXP 50
117347: PUSH
117348: LD_VAR 0 1
117352: ARRAY
117353: NOT
117354: PUSH
117355: LD_EXP 50
117359: PUSH
117360: LD_VAR 0 1
117364: ARRAY
117365: PUSH
117366: EMPTY
117367: EQUAL
117368: OR
117369: IFFALSE 117406
// begin for i in defenders do
117371: LD_ADDR_VAR 0 4
117375: PUSH
117376: LD_VAR 0 2
117380: PUSH
117381: FOR_IN
117382: IFFALSE 117395
// ComStop ( i ) ;
117384: LD_VAR 0 4
117388: PPUSH
117389: CALL_OW 141
117393: GO 117381
117395: POP
117396: POP
// defenders := [ ] ;
117397: LD_ADDR_VAR 0 2
117401: PUSH
117402: EMPTY
117403: ST_TO_ADDR
// exit ;
117404: GO 118855
// end ; for i in defenders do
117406: LD_ADDR_VAR 0 4
117410: PUSH
117411: LD_VAR 0 2
117415: PUSH
117416: FOR_IN
117417: IFFALSE 118315
// begin e := NearestUnitToUnit ( enemy , i ) ;
117419: LD_ADDR_VAR 0 13
117423: PUSH
117424: LD_VAR 0 21
117428: PPUSH
117429: LD_VAR 0 4
117433: PPUSH
117434: CALL_OW 74
117438: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
117439: LD_ADDR_VAR 0 7
117443: PUSH
117444: LD_EXP 50
117448: PUSH
117449: LD_VAR 0 1
117453: ARRAY
117454: PPUSH
117455: LD_INT 2
117457: PUSH
117458: LD_INT 30
117460: PUSH
117461: LD_INT 0
117463: PUSH
117464: EMPTY
117465: LIST
117466: LIST
117467: PUSH
117468: LD_INT 30
117470: PUSH
117471: LD_INT 1
117473: PUSH
117474: EMPTY
117475: LIST
117476: LIST
117477: PUSH
117478: EMPTY
117479: LIST
117480: LIST
117481: LIST
117482: PPUSH
117483: CALL_OW 72
117487: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
117488: LD_ADDR_VAR 0 16
117492: PUSH
117493: LD_VAR 0 7
117497: NOT
117498: PUSH
117499: LD_VAR 0 7
117503: PPUSH
117504: LD_INT 3
117506: PUSH
117507: LD_INT 24
117509: PUSH
117510: LD_INT 600
117512: PUSH
117513: EMPTY
117514: LIST
117515: LIST
117516: PUSH
117517: EMPTY
117518: LIST
117519: LIST
117520: PPUSH
117521: CALL_OW 72
117525: OR
117526: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
117527: LD_VAR 0 4
117531: PPUSH
117532: CALL_OW 247
117536: PUSH
117537: LD_INT 2
117539: DOUBLE
117540: EQUAL
117541: IFTRUE 117545
117543: GO 117941
117545: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
117546: LD_VAR 0 4
117550: PPUSH
117551: CALL_OW 256
117555: PUSH
117556: LD_INT 1000
117558: EQUAL
117559: PUSH
117560: LD_VAR 0 4
117564: PPUSH
117565: LD_VAR 0 13
117569: PPUSH
117570: CALL_OW 296
117574: PUSH
117575: LD_INT 40
117577: LESS
117578: PUSH
117579: LD_VAR 0 13
117583: PPUSH
117584: LD_EXP 75
117588: PUSH
117589: LD_VAR 0 1
117593: ARRAY
117594: PPUSH
117595: CALL_OW 308
117599: OR
117600: AND
117601: IFFALSE 117723
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
117603: LD_VAR 0 4
117607: PPUSH
117608: CALL_OW 262
117612: PUSH
117613: LD_INT 1
117615: EQUAL
117616: PUSH
117617: LD_VAR 0 4
117621: PPUSH
117622: CALL_OW 261
117626: PUSH
117627: LD_INT 30
117629: LESS
117630: AND
117631: PUSH
117632: LD_VAR 0 7
117636: AND
117637: IFFALSE 117707
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
117639: LD_VAR 0 4
117643: PPUSH
117644: LD_VAR 0 7
117648: PPUSH
117649: LD_VAR 0 4
117653: PPUSH
117654: CALL_OW 74
117658: PPUSH
117659: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
117663: LD_VAR 0 4
117667: PPUSH
117668: LD_VAR 0 7
117672: PPUSH
117673: LD_VAR 0 4
117677: PPUSH
117678: CALL_OW 74
117682: PPUSH
117683: CALL_OW 296
117687: PUSH
117688: LD_INT 6
117690: LESS
117691: IFFALSE 117705
// SetFuel ( i , 100 ) ;
117693: LD_VAR 0 4
117697: PPUSH
117698: LD_INT 100
117700: PPUSH
117701: CALL_OW 240
// end else
117705: GO 117721
// ComAttackUnit ( i , e ) ;
117707: LD_VAR 0 4
117711: PPUSH
117712: LD_VAR 0 13
117716: PPUSH
117717: CALL_OW 115
// end else
117721: GO 117824
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
117723: LD_VAR 0 13
117727: PPUSH
117728: LD_EXP 75
117732: PUSH
117733: LD_VAR 0 1
117737: ARRAY
117738: PPUSH
117739: CALL_OW 308
117743: NOT
117744: PUSH
117745: LD_VAR 0 4
117749: PPUSH
117750: LD_VAR 0 13
117754: PPUSH
117755: CALL_OW 296
117759: PUSH
117760: LD_INT 40
117762: GREATEREQUAL
117763: AND
117764: PUSH
117765: LD_VAR 0 4
117769: PPUSH
117770: CALL_OW 256
117774: PUSH
117775: LD_INT 650
117777: LESSEQUAL
117778: OR
117779: PUSH
117780: LD_VAR 0 4
117784: PPUSH
117785: LD_EXP 74
117789: PUSH
117790: LD_VAR 0 1
117794: ARRAY
117795: PPUSH
117796: CALL_OW 308
117800: NOT
117801: AND
117802: IFFALSE 117824
// ComMoveToArea ( i , mc_parking [ base ] ) ;
117804: LD_VAR 0 4
117808: PPUSH
117809: LD_EXP 74
117813: PUSH
117814: LD_VAR 0 1
117818: ARRAY
117819: PPUSH
117820: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
117824: LD_VAR 0 4
117828: PPUSH
117829: CALL_OW 256
117833: PUSH
117834: LD_INT 1000
117836: LESS
117837: PUSH
117838: LD_VAR 0 4
117842: PPUSH
117843: CALL_OW 263
117847: PUSH
117848: LD_INT 1
117850: EQUAL
117851: AND
117852: PUSH
117853: LD_VAR 0 4
117857: PPUSH
117858: CALL_OW 311
117862: AND
117863: PUSH
117864: LD_VAR 0 4
117868: PPUSH
117869: LD_EXP 74
117873: PUSH
117874: LD_VAR 0 1
117878: ARRAY
117879: PPUSH
117880: CALL_OW 308
117884: AND
117885: IFFALSE 117939
// begin mech := IsDrivenBy ( i ) ;
117887: LD_ADDR_VAR 0 9
117891: PUSH
117892: LD_VAR 0 4
117896: PPUSH
117897: CALL_OW 311
117901: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
117902: LD_VAR 0 9
117906: PPUSH
117907: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
117911: LD_VAR 0 9
117915: PPUSH
117916: LD_VAR 0 4
117920: PPUSH
117921: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
117925: LD_VAR 0 9
117929: PPUSH
117930: LD_VAR 0 4
117934: PPUSH
117935: CALL_OW 180
// end ; end ; unit_human :
117939: GO 118286
117941: LD_INT 1
117943: DOUBLE
117944: EQUAL
117945: IFTRUE 117949
117947: GO 118285
117949: POP
// begin b := IsInUnit ( i ) ;
117950: LD_ADDR_VAR 0 18
117954: PUSH
117955: LD_VAR 0 4
117959: PPUSH
117960: CALL_OW 310
117964: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
117965: LD_ADDR_VAR 0 19
117969: PUSH
117970: LD_VAR 0 18
117974: NOT
117975: PUSH
117976: LD_VAR 0 18
117980: PPUSH
117981: CALL_OW 266
117985: PUSH
117986: LD_INT 32
117988: PUSH
117989: LD_INT 31
117991: PUSH
117992: EMPTY
117993: LIST
117994: LIST
117995: IN
117996: OR
117997: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
117998: LD_VAR 0 18
118002: PPUSH
118003: CALL_OW 266
118007: PUSH
118008: LD_INT 5
118010: EQUAL
118011: PUSH
118012: LD_VAR 0 4
118016: PPUSH
118017: CALL_OW 257
118021: PUSH
118022: LD_INT 1
118024: PUSH
118025: LD_INT 2
118027: PUSH
118028: LD_INT 3
118030: PUSH
118031: LD_INT 4
118033: PUSH
118034: EMPTY
118035: LIST
118036: LIST
118037: LIST
118038: LIST
118039: IN
118040: AND
118041: IFFALSE 118078
// begin class := AllowSpecClass ( i ) ;
118043: LD_ADDR_VAR 0 20
118047: PUSH
118048: LD_VAR 0 4
118052: PPUSH
118053: CALL 50891 0 1
118057: ST_TO_ADDR
// if class then
118058: LD_VAR 0 20
118062: IFFALSE 118078
// ComChangeProfession ( i , class ) ;
118064: LD_VAR 0 4
118068: PPUSH
118069: LD_VAR 0 20
118073: PPUSH
118074: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
118078: LD_VAR 0 16
118082: PUSH
118083: LD_VAR 0 2
118087: PPUSH
118088: LD_INT 21
118090: PUSH
118091: LD_INT 2
118093: PUSH
118094: EMPTY
118095: LIST
118096: LIST
118097: PPUSH
118098: CALL_OW 72
118102: PUSH
118103: LD_INT 1
118105: LESSEQUAL
118106: OR
118107: PUSH
118108: LD_VAR 0 19
118112: AND
118113: PUSH
118114: LD_VAR 0 4
118118: PUSH
118119: LD_VAR 0 17
118123: IN
118124: NOT
118125: AND
118126: IFFALSE 118219
// begin if b then
118128: LD_VAR 0 18
118132: IFFALSE 118181
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
118134: LD_VAR 0 18
118138: PPUSH
118139: LD_VAR 0 21
118143: PPUSH
118144: LD_VAR 0 18
118148: PPUSH
118149: CALL_OW 74
118153: PPUSH
118154: CALL_OW 296
118158: PUSH
118159: LD_INT 10
118161: LESS
118162: PUSH
118163: LD_VAR 0 18
118167: PPUSH
118168: CALL_OW 461
118172: PUSH
118173: LD_INT 7
118175: NONEQUAL
118176: AND
118177: IFFALSE 118181
// continue ;
118179: GO 117416
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
118181: LD_ADDR_VAR 0 17
118185: PUSH
118186: LD_VAR 0 17
118190: PPUSH
118191: LD_VAR 0 17
118195: PUSH
118196: LD_INT 1
118198: PLUS
118199: PPUSH
118200: LD_VAR 0 4
118204: PPUSH
118205: CALL_OW 1
118209: ST_TO_ADDR
// ComExitBuilding ( i ) ;
118210: LD_VAR 0 4
118214: PPUSH
118215: CALL_OW 122
// end ; if sold_defenders then
118219: LD_VAR 0 17
118223: IFFALSE 118283
// if i in sold_defenders then
118225: LD_VAR 0 4
118229: PUSH
118230: LD_VAR 0 17
118234: IN
118235: IFFALSE 118283
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
118237: LD_VAR 0 4
118241: PPUSH
118242: CALL_OW 314
118246: NOT
118247: PUSH
118248: LD_VAR 0 4
118252: PPUSH
118253: LD_VAR 0 13
118257: PPUSH
118258: CALL_OW 296
118262: PUSH
118263: LD_INT 30
118265: LESS
118266: AND
118267: IFFALSE 118283
// ComAttackUnit ( i , e ) ;
118269: LD_VAR 0 4
118273: PPUSH
118274: LD_VAR 0 13
118278: PPUSH
118279: CALL_OW 115
// end ; end ; end ;
118283: GO 118286
118285: POP
// if IsDead ( i ) then
118286: LD_VAR 0 4
118290: PPUSH
118291: CALL_OW 301
118295: IFFALSE 118313
// defenders := defenders diff i ;
118297: LD_ADDR_VAR 0 2
118301: PUSH
118302: LD_VAR 0 2
118306: PUSH
118307: LD_VAR 0 4
118311: DIFF
118312: ST_TO_ADDR
// end ;
118313: GO 117416
118315: POP
118316: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
118317: LD_VAR 0 21
118321: NOT
118322: PUSH
118323: LD_VAR 0 2
118327: NOT
118328: OR
118329: PUSH
118330: LD_EXP 50
118334: PUSH
118335: LD_VAR 0 1
118339: ARRAY
118340: NOT
118341: OR
118342: IFFALSE 117320
// MC_Reset ( base , 18 ) ;
118344: LD_VAR 0 1
118348: PPUSH
118349: LD_INT 18
118351: PPUSH
118352: CALL 22566 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
118356: LD_ADDR_VAR 0 2
118360: PUSH
118361: LD_VAR 0 2
118365: PUSH
118366: LD_VAR 0 2
118370: PPUSH
118371: LD_INT 2
118373: PUSH
118374: LD_INT 25
118376: PUSH
118377: LD_INT 1
118379: PUSH
118380: EMPTY
118381: LIST
118382: LIST
118383: PUSH
118384: LD_INT 25
118386: PUSH
118387: LD_INT 5
118389: PUSH
118390: EMPTY
118391: LIST
118392: LIST
118393: PUSH
118394: LD_INT 25
118396: PUSH
118397: LD_INT 8
118399: PUSH
118400: EMPTY
118401: LIST
118402: LIST
118403: PUSH
118404: LD_INT 25
118406: PUSH
118407: LD_INT 9
118409: PUSH
118410: EMPTY
118411: LIST
118412: LIST
118413: PUSH
118414: EMPTY
118415: LIST
118416: LIST
118417: LIST
118418: LIST
118419: LIST
118420: PPUSH
118421: CALL_OW 72
118425: DIFF
118426: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
118427: LD_VAR 0 21
118431: NOT
118432: PUSH
118433: LD_VAR 0 2
118437: PPUSH
118438: LD_INT 21
118440: PUSH
118441: LD_INT 2
118443: PUSH
118444: EMPTY
118445: LIST
118446: LIST
118447: PPUSH
118448: CALL_OW 72
118452: AND
118453: IFFALSE 118791
// begin tmp := FilterByTag ( defenders , 19 ) ;
118455: LD_ADDR_VAR 0 11
118459: PUSH
118460: LD_VAR 0 2
118464: PPUSH
118465: LD_INT 19
118467: PPUSH
118468: CALL 84376 0 2
118472: ST_TO_ADDR
// if tmp then
118473: LD_VAR 0 11
118477: IFFALSE 118547
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
118479: LD_ADDR_VAR 0 11
118483: PUSH
118484: LD_VAR 0 11
118488: PPUSH
118489: LD_INT 25
118491: PUSH
118492: LD_INT 3
118494: PUSH
118495: EMPTY
118496: LIST
118497: LIST
118498: PPUSH
118499: CALL_OW 72
118503: ST_TO_ADDR
// if tmp then
118504: LD_VAR 0 11
118508: IFFALSE 118547
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
118510: LD_ADDR_EXP 62
118514: PUSH
118515: LD_EXP 62
118519: PPUSH
118520: LD_VAR 0 1
118524: PPUSH
118525: LD_EXP 62
118529: PUSH
118530: LD_VAR 0 1
118534: ARRAY
118535: PUSH
118536: LD_VAR 0 11
118540: UNION
118541: PPUSH
118542: CALL_OW 1
118546: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
118547: LD_VAR 0 1
118551: PPUSH
118552: LD_INT 19
118554: PPUSH
118555: CALL 22566 0 2
// repeat wait ( 0 0$1 ) ;
118559: LD_INT 35
118561: PPUSH
118562: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
118566: LD_EXP 50
118570: PUSH
118571: LD_VAR 0 1
118575: ARRAY
118576: NOT
118577: PUSH
118578: LD_EXP 50
118582: PUSH
118583: LD_VAR 0 1
118587: ARRAY
118588: PUSH
118589: EMPTY
118590: EQUAL
118591: OR
118592: IFFALSE 118629
// begin for i in defenders do
118594: LD_ADDR_VAR 0 4
118598: PUSH
118599: LD_VAR 0 2
118603: PUSH
118604: FOR_IN
118605: IFFALSE 118618
// ComStop ( i ) ;
118607: LD_VAR 0 4
118611: PPUSH
118612: CALL_OW 141
118616: GO 118604
118618: POP
118619: POP
// defenders := [ ] ;
118620: LD_ADDR_VAR 0 2
118624: PUSH
118625: EMPTY
118626: ST_TO_ADDR
// exit ;
118627: GO 118855
// end ; for i in defenders do
118629: LD_ADDR_VAR 0 4
118633: PUSH
118634: LD_VAR 0 2
118638: PUSH
118639: FOR_IN
118640: IFFALSE 118729
// begin if not IsInArea ( i , mc_parking [ base ] ) then
118642: LD_VAR 0 4
118646: PPUSH
118647: LD_EXP 74
118651: PUSH
118652: LD_VAR 0 1
118656: ARRAY
118657: PPUSH
118658: CALL_OW 308
118662: NOT
118663: IFFALSE 118687
// ComMoveToArea ( i , mc_parking [ base ] ) else
118665: LD_VAR 0 4
118669: PPUSH
118670: LD_EXP 74
118674: PUSH
118675: LD_VAR 0 1
118679: ARRAY
118680: PPUSH
118681: CALL_OW 113
118685: GO 118727
// if GetControl ( i ) = control_manual then
118687: LD_VAR 0 4
118691: PPUSH
118692: CALL_OW 263
118696: PUSH
118697: LD_INT 1
118699: EQUAL
118700: IFFALSE 118727
// if IsDrivenBy ( i ) then
118702: LD_VAR 0 4
118706: PPUSH
118707: CALL_OW 311
118711: IFFALSE 118727
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
118713: LD_VAR 0 4
118717: PPUSH
118718: CALL_OW 311
118722: PPUSH
118723: CALL_OW 121
// end ;
118727: GO 118639
118729: POP
118730: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
118731: LD_VAR 0 2
118735: PPUSH
118736: LD_INT 95
118738: PUSH
118739: LD_EXP 74
118743: PUSH
118744: LD_VAR 0 1
118748: ARRAY
118749: PUSH
118750: EMPTY
118751: LIST
118752: LIST
118753: PPUSH
118754: CALL_OW 72
118758: PUSH
118759: LD_VAR 0 2
118763: EQUAL
118764: PUSH
118765: LD_EXP 73
118769: PUSH
118770: LD_VAR 0 1
118774: ARRAY
118775: OR
118776: PUSH
118777: LD_EXP 50
118781: PUSH
118782: LD_VAR 0 1
118786: ARRAY
118787: NOT
118788: OR
118789: IFFALSE 118559
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
118791: LD_ADDR_EXP 72
118795: PUSH
118796: LD_EXP 72
118800: PPUSH
118801: LD_VAR 0 1
118805: PPUSH
118806: LD_VAR 0 2
118810: PPUSH
118811: LD_INT 21
118813: PUSH
118814: LD_INT 2
118816: PUSH
118817: EMPTY
118818: LIST
118819: LIST
118820: PPUSH
118821: CALL_OW 72
118825: PPUSH
118826: CALL_OW 1
118830: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
118831: LD_VAR 0 1
118835: PPUSH
118836: LD_INT 19
118838: PPUSH
118839: CALL 22566 0 2
// MC_Reset ( base , 20 ) ;
118843: LD_VAR 0 1
118847: PPUSH
118848: LD_INT 20
118850: PPUSH
118851: CALL 22566 0 2
// end ; end_of_file
118855: LD_VAR 0 3
118859: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
118860: LD_VAR 0 1
118864: PUSH
118865: LD_INT 200
118867: DOUBLE
118868: GREATEREQUAL
118869: IFFALSE 118877
118871: LD_INT 299
118873: DOUBLE
118874: LESSEQUAL
118875: IFTRUE 118879
118877: GO 118911
118879: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
118880: LD_VAR 0 1
118884: PPUSH
118885: LD_VAR 0 2
118889: PPUSH
118890: LD_VAR 0 3
118894: PPUSH
118895: LD_VAR 0 4
118899: PPUSH
118900: LD_VAR 0 5
118904: PPUSH
118905: CALL 107207 0 5
118909: GO 118988
118911: LD_INT 300
118913: DOUBLE
118914: GREATEREQUAL
118915: IFFALSE 118923
118917: LD_INT 399
118919: DOUBLE
118920: LESSEQUAL
118921: IFTRUE 118925
118923: GO 118987
118925: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
118926: LD_VAR 0 1
118930: PPUSH
118931: LD_VAR 0 2
118935: PPUSH
118936: LD_VAR 0 3
118940: PPUSH
118941: LD_VAR 0 4
118945: PPUSH
118946: LD_VAR 0 5
118950: PPUSH
118951: LD_VAR 0 6
118955: PPUSH
118956: LD_VAR 0 7
118960: PPUSH
118961: LD_VAR 0 8
118965: PPUSH
118966: LD_VAR 0 9
118970: PPUSH
118971: LD_VAR 0 10
118975: PPUSH
118976: LD_VAR 0 11
118980: PPUSH
118981: CALL 103532 0 11
118985: GO 118988
118987: POP
// end ;
118988: PPOPN 11
118990: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
118991: LD_VAR 0 1
118995: PPUSH
118996: LD_VAR 0 2
119000: PPUSH
119001: LD_VAR 0 3
119005: PPUSH
119006: LD_VAR 0 4
119010: PPUSH
119011: LD_VAR 0 5
119015: PPUSH
119016: CALL 106943 0 5
// end ; end_of_file
119020: PPOPN 5
119022: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
119023: LD_VAR 0 1
119027: PPUSH
119028: LD_VAR 0 2
119032: PPUSH
119033: LD_VAR 0 3
119037: PPUSH
119038: LD_VAR 0 4
119042: PPUSH
119043: LD_VAR 0 5
119047: PPUSH
119048: LD_VAR 0 6
119052: PPUSH
119053: CALL 91184 0 6
// end ;
119057: PPOPN 6
119059: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
119060: LD_INT 0
119062: PPUSH
// begin if not units then
119063: LD_VAR 0 1
119067: NOT
119068: IFFALSE 119072
// exit ;
119070: GO 119072
// end ;
119072: PPOPN 7
119074: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
119075: CALL 91088 0 0
// end ;
119079: PPOPN 1
119081: END
