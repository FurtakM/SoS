// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Randomize ;
  11: CALL_OW 10
// InitVariables ;
  15: CALL 94 0 0
// InitMacro ;
  19: CALL 17988 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// ChangeSideFog ( 8 , 1 ) ;
  36: LD_INT 8
  38: PPUSH
  39: LD_INT 1
  41: PPUSH
  42: CALL_OW 343
// PrepareNature ( 4 , 3 , 6 , 3 , 2 , 0 , 7 , natureArea , waterArea ) ;
  46: LD_INT 4
  48: PPUSH
  49: LD_INT 3
  51: PPUSH
  52: LD_INT 6
  54: PPUSH
  55: LD_INT 3
  57: PPUSH
  58: LD_INT 2
  60: PPUSH
  61: LD_INT 0
  63: PPUSH
  64: LD_INT 7
  66: PPUSH
  67: LD_INT 18
  69: PPUSH
  70: LD_INT 19
  72: PPUSH
  73: CALL 82783 0 9
// PrepareAmerican ;
  77: CALL 653 0 0
// PrepareArabian ;
  81: CALL 2605 0 0
// MC_Start ( ) ;
  85: CALL 20160 0 0
// Action ;
  89: CALL 8544 0 0
// end ;
  93: END
// export debug , game ; export mission_prefix , mission_prefix_prev ; export ar_run , base_captured , ar_patrol , us_scout , seen , can_kamikazed , kamikazed , artifact_stolen , artifact_get , artifact_oncargo , game_time , powell_warn , loses_counter , gensher_active , selected , am_veh_consturcted ; function InitVariables ; begin
  94: LD_INT 0
  96: PPUSH
// debug := false ;
  97: LD_ADDR_EXP 1
 101: PUSH
 102: LD_INT 0
 104: ST_TO_ADDR
// game := true ;
 105: LD_ADDR_EXP 2
 109: PUSH
 110: LD_INT 1
 112: ST_TO_ADDR
// mission_prefix := 11_ ;
 113: LD_ADDR_EXP 3
 117: PUSH
 118: LD_STRING 11_
 120: ST_TO_ADDR
// mission_prefix_prev := 10c_ ;
 121: LD_ADDR_EXP 4
 125: PUSH
 126: LD_STRING 10c_
 128: ST_TO_ADDR
// ar_run := false ;
 129: LD_ADDR_EXP 5
 133: PUSH
 134: LD_INT 0
 136: ST_TO_ADDR
// ar_patrol := false ;
 137: LD_ADDR_EXP 7
 141: PUSH
 142: LD_INT 0
 144: ST_TO_ADDR
// base_captured := false ;
 145: LD_ADDR_EXP 6
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// us_scout := 0 ;
 153: LD_ADDR_EXP 8
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// seen := [ 0 , 0 , 0 , 0 , 0 ] ;
 161: LD_ADDR_EXP 9
 165: PUSH
 166: LD_INT 0
 168: PUSH
 169: LD_INT 0
 171: PUSH
 172: LD_INT 0
 174: PUSH
 175: LD_INT 0
 177: PUSH
 178: LD_INT 0
 180: PUSH
 181: EMPTY
 182: LIST
 183: LIST
 184: LIST
 185: LIST
 186: LIST
 187: ST_TO_ADDR
// kamikazed := false ;
 188: LD_ADDR_EXP 11
 192: PUSH
 193: LD_INT 0
 195: ST_TO_ADDR
// artifact_stolen := false ;
 196: LD_ADDR_EXP 12
 200: PUSH
 201: LD_INT 0
 203: ST_TO_ADDR
// artifact_get := false ;
 204: LD_ADDR_EXP 13
 208: PUSH
 209: LD_INT 0
 211: ST_TO_ADDR
// game_time := [ 130 130$00 , 120 120$00 , 115 115$00 , 112 112$00 ] [ Difficulty ] ;
 212: LD_ADDR_EXP 15
 216: PUSH
 217: LD_INT 273000
 219: PUSH
 220: LD_INT 252000
 222: PUSH
 223: LD_INT 241500
 225: PUSH
 226: LD_INT 235200
 228: PUSH
 229: EMPTY
 230: LIST
 231: LIST
 232: LIST
 233: LIST
 234: PUSH
 235: LD_OWVAR 67
 239: ARRAY
 240: ST_TO_ADDR
// powell_warn := false ;
 241: LD_ADDR_EXP 16
 245: PUSH
 246: LD_INT 0
 248: ST_TO_ADDR
// loses_counter := 0 ;
 249: LD_ADDR_EXP 17
 253: PUSH
 254: LD_INT 0
 256: ST_TO_ADDR
// artifact_oncargo := false ;
 257: LD_ADDR_EXP 14
 261: PUSH
 262: LD_INT 0
 264: ST_TO_ADDR
// gensher_active := LoadVariable ( 10_GensherEscape_1 , debug ) ;
 265: LD_ADDR_EXP 18
 269: PUSH
 270: LD_STRING 10_GensherEscape_1
 272: PPUSH
 273: LD_EXP 1
 277: PPUSH
 278: CALL_OW 30
 282: ST_TO_ADDR
// can_kamikazed := false ;
 283: LD_ADDR_EXP 10
 287: PUSH
 288: LD_INT 0
 290: ST_TO_ADDR
// am_veh_consturcted := false ;
 291: LD_ADDR_EXP 20
 295: PUSH
 296: LD_INT 0
 298: ST_TO_ADDR
// end ;
 299: LD_VAR 0 1
 303: RET
// export function CustomInitMacro ; var i ; begin
 304: LD_INT 0
 306: PPUSH
 307: PPUSH
// mc_parking := [ parking_north , parking_west , parking_east ] ;
 308: LD_ADDR_EXP 74
 312: PUSH
 313: LD_INT 20
 315: PUSH
 316: LD_INT 21
 318: PUSH
 319: LD_INT 22
 321: PUSH
 322: EMPTY
 323: LIST
 324: LIST
 325: LIST
 326: ST_TO_ADDR
// mc_scan_area := [ base_north , base_west , base_east ] ;
 327: LD_ADDR_EXP 75
 331: PUSH
 332: LD_INT 28
 334: PUSH
 335: LD_INT 24
 337: PUSH
 338: LD_INT 26
 340: PUSH
 341: EMPTY
 342: LIST
 343: LIST
 344: LIST
 345: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield1_left ) ;
 346: LD_INT 1
 348: PPUSH
 349: LD_INT 4
 351: PUSH
 352: LD_INT 6
 354: PUSH
 355: LD_INT 8
 357: PUSH
 358: LD_INT 9
 360: PUSH
 361: EMPTY
 362: LIST
 363: LIST
 364: LIST
 365: LIST
 366: PUSH
 367: LD_OWVAR 67
 371: ARRAY
 372: PPUSH
 373: LD_INT 3
 375: PPUSH
 376: CALL 41898 0 3
// MC_SetMinesField ( 2 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield2_left ) ;
 380: LD_INT 2
 382: PPUSH
 383: LD_INT 4
 385: PUSH
 386: LD_INT 6
 388: PUSH
 389: LD_INT 8
 391: PUSH
 392: LD_INT 9
 394: PUSH
 395: EMPTY
 396: LIST
 397: LIST
 398: LIST
 399: LIST
 400: PUSH
 401: LD_OWVAR 67
 405: ARRAY
 406: PPUSH
 407: LD_INT 2
 409: PPUSH
 410: CALL 41898 0 3
// MC_SetMinesField ( 3 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield3_left ) ;
 414: LD_INT 3
 416: PPUSH
 417: LD_INT 4
 419: PUSH
 420: LD_INT 6
 422: PUSH
 423: LD_INT 8
 425: PUSH
 426: LD_INT 9
 428: PUSH
 429: EMPTY
 430: LIST
 431: LIST
 432: LIST
 433: LIST
 434: PUSH
 435: LD_OWVAR 67
 439: ARRAY
 440: PPUSH
 441: LD_INT 1
 443: PPUSH
 444: CALL 41898 0 3
// for i = 1 to mc_bases do
 448: LD_ADDR_VAR 0 2
 452: PUSH
 453: DOUBLE
 454: LD_INT 1
 456: DEC
 457: ST_TO_ADDR
 458: LD_EXP 50
 462: PUSH
 463: FOR_TO
 464: IFFALSE 488
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 466: LD_VAR 0 2
 470: PPUSH
 471: LD_EXP 43
 475: PUSH
 476: LD_VAR 0 2
 480: ARRAY
 481: PPUSH
 482: CALL 42324 0 2
 486: GO 463
 488: POP
 489: POP
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] , ] ) ;
 490: LD_INT 1
 492: PPUSH
 493: LD_INT 14
 495: PUSH
 496: LD_INT 1
 498: PUSH
 499: LD_INT 2
 501: PUSH
 502: LD_INT 88
 504: PUSH
 505: EMPTY
 506: LIST
 507: LIST
 508: LIST
 509: LIST
 510: PUSH
 511: LD_INT 14
 513: PUSH
 514: LD_INT 1
 516: PUSH
 517: LD_INT 2
 519: PUSH
 520: LD_INT 88
 522: PUSH
 523: EMPTY
 524: LIST
 525: LIST
 526: LIST
 527: LIST
 528: PUSH
 529: EMPTY
 530: LIST
 531: LIST
 532: PPUSH
 533: CALL 42216 0 2
// MC_SetProduceList ( 2 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 537: LD_INT 2
 539: PPUSH
 540: LD_INT 14
 542: PUSH
 543: LD_INT 1
 545: PUSH
 546: LD_INT 2
 548: PUSH
 549: LD_INT 88
 551: PUSH
 552: EMPTY
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: PUSH
 558: EMPTY
 559: LIST
 560: PPUSH
 561: CALL 42216 0 2
// end ;
 565: LD_VAR 0 1
 569: RET
// function Debuger ; var i ; begin
 570: LD_INT 0
 572: PPUSH
 573: PPUSH
// if not debug then
 574: LD_EXP 1
 578: NOT
 579: IFFALSE 583
// exit ;
 581: GO 619
// game_speed := 5 ;
 583: LD_ADDR_OWVAR 65
 587: PUSH
 588: LD_INT 5
 590: ST_TO_ADDR
// uc_side := 1 ;
 591: LD_ADDR_OWVAR 20
 595: PUSH
 596: LD_INT 1
 598: ST_TO_ADDR
// uc_nation := 1 ;
 599: LD_ADDR_OWVAR 21
 603: PUSH
 604: LD_INT 1
 606: ST_TO_ADDR
// SetSide ( ar_force_south , 1 ) ;
 607: LD_EXP 36
 611: PPUSH
 612: LD_INT 1
 614: PPUSH
 615: CALL_OW 235
// end ;
 619: LD_VAR 0 1
 623: RET
// every 0 0$1 trigger IsDead ( ar_dep_n ) and IsOk ( ar_dep_w ) do
 624: LD_INT 94
 626: PPUSH
 627: CALL_OW 301
 631: PUSH
 632: LD_INT 45
 634: PPUSH
 635: CALL_OW 302
 639: AND
 640: IFFALSE 652
 642: GO 644
 644: DISABLE
// SetAchievement ( ACH_EAST ) ; end_of_file
 645: LD_STRING ACH_EAST
 647: PPUSH
 648: CALL_OW 543
 652: END
// export JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Frank , Kikuchi ; export function PrepareAmerican ; var i , k , un , tmp , vehs , veh , others ; begin
 653: LD_INT 0
 655: PPUSH
 656: PPUSH
 657: PPUSH
 658: PPUSH
 659: PPUSH
 660: PPUSH
 661: PPUSH
 662: PPUSH
// uc_side := 4 ;
 663: LD_ADDR_OWVAR 20
 667: PUSH
 668: LD_INT 4
 670: ST_TO_ADDR
// uc_nation := 1 ;
 671: LD_ADDR_OWVAR 21
 675: PUSH
 676: LD_INT 1
 678: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
 679: LD_ADDR_EXP 30
 683: PUSH
 684: LD_STRING Powell
 686: PPUSH
 687: LD_INT 0
 689: PPUSH
 690: LD_STRING 
 692: PPUSH
 693: CALL 48652 0 3
 697: ST_TO_ADDR
// uc_side := 1 ;
 698: LD_ADDR_OWVAR 20
 702: PUSH
 703: LD_INT 1
 705: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , mission_prefix_prev ) ;
 706: LD_ADDR_EXP 21
 710: PUSH
 711: LD_STRING JMM
 713: PPUSH
 714: LD_EXP 1
 718: NOT
 719: PPUSH
 720: LD_EXP 4
 724: PPUSH
 725: CALL 48652 0 3
 729: ST_TO_ADDR
// if GetClass ( JMM ) > 4 then
 730: LD_EXP 21
 734: PPUSH
 735: CALL_OW 257
 739: PUSH
 740: LD_INT 4
 742: GREATER
 743: IFFALSE 757
// SetClass ( JMM , 1 ) ;
 745: LD_EXP 21
 749: PPUSH
 750: LD_INT 1
 752: PPUSH
 753: CALL_OW 336
// Lisa := PrepareUnit ( Lisa , ( not debug ) , mission_prefix_prev ) ;
 757: LD_ADDR_EXP 22
 761: PUSH
 762: LD_STRING Lisa
 764: PPUSH
 765: LD_EXP 1
 769: NOT
 770: PPUSH
 771: LD_EXP 4
 775: PPUSH
 776: CALL 48652 0 3
 780: ST_TO_ADDR
// if not Lisa then
 781: LD_EXP 22
 785: NOT
 786: IFFALSE 801
// Lisa := CreateCharacter ( 10_Lisa ) ;
 788: LD_ADDR_EXP 22
 792: PUSH
 793: LD_STRING 10_Lisa
 795: PPUSH
 796: CALL_OW 34
 800: ST_TO_ADDR
// if not Lisa then
 801: LD_EXP 22
 805: NOT
 806: IFFALSE 821
// Lisa := CreateCharacter ( 09_Lisa ) ;
 808: LD_ADDR_EXP 22
 812: PUSH
 813: LD_STRING 09_Lisa
 815: PPUSH
 816: CALL_OW 34
 820: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , mission_prefix_prev ) ;
 821: LD_ADDR_EXP 31
 825: PUSH
 826: LD_STRING Cornel
 828: PPUSH
 829: LD_EXP 1
 833: NOT
 834: PPUSH
 835: LD_EXP 4
 839: PPUSH
 840: CALL 48652 0 3
 844: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , mission_prefix_prev ) ;
 845: LD_ADDR_EXP 23
 849: PUSH
 850: LD_STRING Donaldson
 852: PPUSH
 853: LD_EXP 1
 857: NOT
 858: PPUSH
 859: LD_EXP 4
 863: PPUSH
 864: CALL 48652 0 3
 868: ST_TO_ADDR
// if not Donaldson then
 869: LD_EXP 23
 873: NOT
 874: IFFALSE 889
// Donaldson := CreateCharacter ( 10_Donaldson ) ;
 876: LD_ADDR_EXP 23
 880: PUSH
 881: LD_STRING 10_Donaldson
 883: PPUSH
 884: CALL_OW 34
 888: ST_TO_ADDR
// if not Donaldson then
 889: LD_EXP 23
 893: NOT
 894: IFFALSE 909
// Donaldson := CreateCharacter ( 09_Donaldson ) ;
 896: LD_ADDR_EXP 23
 900: PUSH
 901: LD_STRING 09_Donaldson
 903: PPUSH
 904: CALL_OW 34
 908: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , mission_prefix_prev ) ;
 909: LD_ADDR_EXP 24
 913: PUSH
 914: LD_STRING Bobby
 916: PPUSH
 917: LD_EXP 1
 921: NOT
 922: PPUSH
 923: LD_EXP 4
 927: PPUSH
 928: CALL 48652 0 3
 932: ST_TO_ADDR
// if not Bobby then
 933: LD_EXP 24
 937: NOT
 938: IFFALSE 953
// Bobby := CreateCharacter ( 10_Bobby ) ;
 940: LD_ADDR_EXP 24
 944: PUSH
 945: LD_STRING 10_Bobby
 947: PPUSH
 948: CALL_OW 34
 952: ST_TO_ADDR
// if not Bobby then
 953: LD_EXP 24
 957: NOT
 958: IFFALSE 973
// Bobby := CreateCharacter ( 09_Bobby ) ;
 960: LD_ADDR_EXP 24
 964: PUSH
 965: LD_STRING 09_Bobby
 967: PPUSH
 968: CALL_OW 34
 972: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , mission_prefix_prev ) ;
 973: LD_ADDR_EXP 25
 977: PUSH
 978: LD_STRING Cyrus
 980: PPUSH
 981: LD_EXP 1
 985: NOT
 986: PPUSH
 987: LD_EXP 4
 991: PPUSH
 992: CALL 48652 0 3
 996: ST_TO_ADDR
// if not Cyrus then
 997: LD_EXP 25
1001: NOT
1002: IFFALSE 1017
// Cyrus := CreateCharacter ( 10_Cyrus ) ;
1004: LD_ADDR_EXP 25
1008: PUSH
1009: LD_STRING 10_Cyrus
1011: PPUSH
1012: CALL_OW 34
1016: ST_TO_ADDR
// if not Cyrus then
1017: LD_EXP 25
1021: NOT
1022: IFFALSE 1037
// Cyrus := CreateCharacter ( 09_Cyrus ) ;
1024: LD_ADDR_EXP 25
1028: PUSH
1029: LD_STRING 09_Cyrus
1031: PPUSH
1032: CALL_OW 34
1036: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , mission_prefix_prev ) ;
1037: LD_ADDR_EXP 26
1041: PUSH
1042: LD_STRING Denis
1044: PPUSH
1045: LD_EXP 1
1049: NOT
1050: PPUSH
1051: LD_EXP 4
1055: PPUSH
1056: CALL 48652 0 3
1060: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , mission_prefix_prev ) ;
1061: LD_ADDR_EXP 27
1065: PUSH
1066: LD_STRING Brown
1068: PPUSH
1069: LD_EXP 1
1073: NOT
1074: PPUSH
1075: LD_EXP 4
1079: PPUSH
1080: CALL 48652 0 3
1084: ST_TO_ADDR
// if not Brown then
1085: LD_EXP 27
1089: NOT
1090: IFFALSE 1105
// Brown := CreateCharacter ( 10_Brown ) ;
1092: LD_ADDR_EXP 27
1096: PUSH
1097: LD_STRING 10_Brown
1099: PPUSH
1100: CALL_OW 34
1104: ST_TO_ADDR
// if not Brown then
1105: LD_EXP 27
1109: NOT
1110: IFFALSE 1125
// Brown := CreateCharacter ( 08_Brown ) ;
1112: LD_ADDR_EXP 27
1116: PUSH
1117: LD_STRING 08_Brown
1119: PPUSH
1120: CALL_OW 34
1124: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , mission_prefix_prev ) ;
1125: LD_ADDR_EXP 28
1129: PUSH
1130: LD_STRING Gladstone
1132: PPUSH
1133: LD_EXP 1
1137: NOT
1138: PPUSH
1139: LD_EXP 4
1143: PPUSH
1144: CALL 48652 0 3
1148: ST_TO_ADDR
// if not Gladstone then
1149: LD_EXP 28
1153: NOT
1154: IFFALSE 1169
// Gladstone := CreateCharacter ( 10_Gladstone ) ;
1156: LD_ADDR_EXP 28
1160: PUSH
1161: LD_STRING 10_Gladstone
1163: PPUSH
1164: CALL_OW 34
1168: ST_TO_ADDR
// if not Gladstone then
1169: LD_EXP 28
1173: NOT
1174: IFFALSE 1189
// Gladstone := CreateCharacter ( 08_Gladstone ) ;
1176: LD_ADDR_EXP 28
1180: PUSH
1181: LD_STRING 08_Gladstone
1183: PPUSH
1184: CALL_OW 34
1188: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , mission_prefix_prev ) ;
1189: LD_ADDR_EXP 29
1193: PUSH
1194: LD_STRING Houten
1196: PPUSH
1197: LD_EXP 1
1201: NOT
1202: PPUSH
1203: LD_EXP 4
1207: PPUSH
1208: CALL 48652 0 3
1212: ST_TO_ADDR
// if not Houten then
1213: LD_EXP 29
1217: NOT
1218: IFFALSE 1233
// Houten := CreateCharacter ( 10_Houten ) ;
1220: LD_ADDR_EXP 29
1224: PUSH
1225: LD_STRING 10_Houten
1227: PPUSH
1228: CALL_OW 34
1232: ST_TO_ADDR
// if not Houten then
1233: LD_EXP 29
1237: NOT
1238: IFFALSE 1253
// Houten := CreateCharacter ( 09_Houten ) ;
1240: LD_ADDR_EXP 29
1244: PUSH
1245: LD_STRING 09_Houten
1247: PPUSH
1248: CALL_OW 34
1252: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , ( not debug ) , mission_prefix_prev ) ;
1253: LD_ADDR_EXP 31
1257: PUSH
1258: LD_STRING Cornell
1260: PPUSH
1261: LD_EXP 1
1265: NOT
1266: PPUSH
1267: LD_EXP 4
1271: PPUSH
1272: CALL 48652 0 3
1276: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , mission_prefix_prev ) ;
1277: LD_ADDR_EXP 32
1281: PUSH
1282: LD_STRING Gary
1284: PPUSH
1285: LD_EXP 1
1289: NOT
1290: PPUSH
1291: LD_EXP 4
1295: PPUSH
1296: CALL 48652 0 3
1300: ST_TO_ADDR
// if not Gary then
1301: LD_EXP 32
1305: NOT
1306: IFFALSE 1321
// Gary := CreateCharacter ( 10_Gary ) ;
1308: LD_ADDR_EXP 32
1312: PUSH
1313: LD_STRING 10_Gary
1315: PPUSH
1316: CALL_OW 34
1320: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , mission_prefix_prev ) ;
1321: LD_ADDR_EXP 33
1325: PUSH
1326: LD_STRING Frank
1328: PPUSH
1329: LD_EXP 1
1333: NOT
1334: PPUSH
1335: LD_EXP 4
1339: PPUSH
1340: CALL 48652 0 3
1344: ST_TO_ADDR
// if not Frank then
1345: LD_EXP 33
1349: NOT
1350: IFFALSE 1365
// Frank := CreateCharacter ( 08_Frank ) ;
1352: LD_ADDR_EXP 33
1356: PUSH
1357: LD_STRING 08_Frank
1359: PPUSH
1360: CALL_OW 34
1364: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , mission_prefix_prev ) ;
1365: LD_ADDR_EXP 34
1369: PUSH
1370: LD_STRING Kikuchi
1372: PPUSH
1373: LD_EXP 1
1377: NOT
1378: PPUSH
1379: LD_EXP 4
1383: PPUSH
1384: CALL 48652 0 3
1388: ST_TO_ADDR
// if not Kikuchi then
1389: LD_EXP 34
1393: NOT
1394: IFFALSE 1409
// Kikuchi := CreateCharacter ( 08_Kikuchi ) ;
1396: LD_ADDR_EXP 34
1400: PUSH
1401: LD_STRING 08_Kikuchi
1403: PPUSH
1404: CALL_OW 34
1408: ST_TO_ADDR
// tmp := [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1409: LD_ADDR_VAR 0 5
1413: PUSH
1414: LD_EXP 22
1418: PUSH
1419: LD_EXP 23
1423: PUSH
1424: LD_EXP 24
1428: PUSH
1429: LD_EXP 25
1433: PUSH
1434: LD_EXP 26
1438: PUSH
1439: LD_EXP 27
1443: PUSH
1444: LD_EXP 28
1448: PUSH
1449: LD_EXP 29
1453: PUSH
1454: LD_EXP 31
1458: PUSH
1459: LD_EXP 32
1463: PUSH
1464: LD_EXP 33
1468: PUSH
1469: LD_EXP 34
1473: PUSH
1474: EMPTY
1475: LIST
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: LIST
1481: LIST
1482: LIST
1483: LIST
1484: LIST
1485: LIST
1486: LIST
1487: ST_TO_ADDR
// tmp := tmp diff 0 ;
1488: LD_ADDR_VAR 0 5
1492: PUSH
1493: LD_VAR 0 5
1497: PUSH
1498: LD_INT 0
1500: DIFF
1501: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10_lock ) ;
1502: LD_ADDR_VAR 0 5
1506: PUSH
1507: LD_VAR 0 5
1511: PUSH
1512: LD_STRING 10_lock
1514: PPUSH
1515: CALL_OW 31
1519: UNION
1520: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10c_lock ) ;
1521: LD_ADDR_VAR 0 5
1525: PUSH
1526: LD_VAR 0 5
1530: PUSH
1531: LD_STRING 10c_lock
1533: PPUSH
1534: CALL_OW 31
1538: UNION
1539: ST_TO_ADDR
// DeleteCharacters ( 10_lock ) ;
1540: LD_STRING 10_lock
1542: PPUSH
1543: CALL_OW 40
// DeleteCharacters ( 10c_lock ) ;
1547: LD_STRING 10c_lock
1549: PPUSH
1550: CALL_OW 40
// for i in tmp do
1554: LD_ADDR_VAR 0 2
1558: PUSH
1559: LD_VAR 0 5
1563: PUSH
1564: FOR_IN
1565: IFFALSE 1603
// if GetClass ( i ) in [ class_mortar , class_engineer ] then
1567: LD_VAR 0 2
1571: PPUSH
1572: CALL_OW 257
1576: PUSH
1577: LD_INT 8
1579: PUSH
1580: LD_INT 2
1582: PUSH
1583: EMPTY
1584: LIST
1585: LIST
1586: IN
1587: IFFALSE 1601
// SetClass ( i , class_soldier ) ;
1589: LD_VAR 0 2
1593: PPUSH
1594: LD_INT 1
1596: PPUSH
1597: CALL_OW 336
1601: GO 1564
1603: POP
1604: POP
// if tmp < 12 then
1605: LD_VAR 0 5
1609: PUSH
1610: LD_INT 12
1612: LESS
1613: IFFALSE 1707
// begin k := 16 - tmp ;
1615: LD_ADDR_VAR 0 3
1619: PUSH
1620: LD_INT 16
1622: PUSH
1623: LD_VAR 0 5
1627: MINUS
1628: ST_TO_ADDR
// for i = 1 to k do
1629: LD_ADDR_VAR 0 2
1633: PUSH
1634: DOUBLE
1635: LD_INT 1
1637: DEC
1638: ST_TO_ADDR
1639: LD_VAR 0 3
1643: PUSH
1644: FOR_TO
1645: IFFALSE 1705
// begin PrepareHuman ( false , [ 1 , 1 , 3 , 4 ] [ rand ( 1 , 4 ) ] , 6 ) ;
1647: LD_INT 0
1649: PPUSH
1650: LD_INT 1
1652: PUSH
1653: LD_INT 1
1655: PUSH
1656: LD_INT 3
1658: PUSH
1659: LD_INT 4
1661: PUSH
1662: EMPTY
1663: LIST
1664: LIST
1665: LIST
1666: LIST
1667: PUSH
1668: LD_INT 1
1670: PPUSH
1671: LD_INT 4
1673: PPUSH
1674: CALL_OW 12
1678: ARRAY
1679: PPUSH
1680: LD_INT 6
1682: PPUSH
1683: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
1687: LD_ADDR_VAR 0 5
1691: PUSH
1692: LD_VAR 0 5
1696: PUSH
1697: CALL_OW 44
1701: ADD
1702: ST_TO_ADDR
// end ;
1703: GO 1644
1705: POP
1706: POP
// end ; selected := CharacterSelection ( 1 , 12 , 12 , [ sel_change_class , JMM , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp ^ [ sel_dont_change_class , sel_not_changeable , Powell ] , [ [ class_soldier , 4 ] , [ class_mechanic , 0 , 5 ] , [ class_scientistic , 0 , 3 ] , [ class_sniper , 0 , 2 ] ] ) ;
1707: LD_ADDR_EXP 19
1711: PUSH
1712: LD_STRING 1
1714: PPUSH
1715: LD_INT 12
1717: PPUSH
1718: LD_INT 12
1720: PPUSH
1721: LD_INT -5
1723: PUSH
1724: LD_EXP 21
1728: PUSH
1729: LD_INT -2
1731: PUSH
1732: LD_INT -3
1734: PUSH
1735: LD_INT -5
1737: PUSH
1738: EMPTY
1739: LIST
1740: LIST
1741: LIST
1742: LIST
1743: LIST
1744: PUSH
1745: LD_VAR 0 5
1749: ADD
1750: PUSH
1751: LD_INT -6
1753: PUSH
1754: LD_INT -4
1756: PUSH
1757: LD_EXP 30
1761: PUSH
1762: EMPTY
1763: LIST
1764: LIST
1765: LIST
1766: ADD
1767: PPUSH
1768: LD_INT 1
1770: PUSH
1771: LD_INT 4
1773: PUSH
1774: EMPTY
1775: LIST
1776: LIST
1777: PUSH
1778: LD_INT 3
1780: PUSH
1781: LD_INT 0
1783: PUSH
1784: LD_INT 5
1786: PUSH
1787: EMPTY
1788: LIST
1789: LIST
1790: LIST
1791: PUSH
1792: LD_INT 4
1794: PUSH
1795: LD_INT 0
1797: PUSH
1798: LD_INT 3
1800: PUSH
1801: EMPTY
1802: LIST
1803: LIST
1804: LIST
1805: PUSH
1806: LD_INT 5
1808: PUSH
1809: LD_INT 0
1811: PUSH
1812: LD_INT 2
1814: PUSH
1815: EMPTY
1816: LIST
1817: LIST
1818: LIST
1819: PUSH
1820: EMPTY
1821: LIST
1822: LIST
1823: LIST
1824: LIST
1825: PPUSH
1826: CALL_OW 42
1830: ST_TO_ADDR
// others := tmp diff selected ;
1831: LD_ADDR_VAR 0 8
1835: PUSH
1836: LD_VAR 0 5
1840: PUSH
1841: LD_EXP 19
1845: DIFF
1846: ST_TO_ADDR
// others := others diff [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1847: LD_ADDR_VAR 0 8
1851: PUSH
1852: LD_VAR 0 8
1856: PUSH
1857: LD_EXP 22
1861: PUSH
1862: LD_EXP 23
1866: PUSH
1867: LD_EXP 24
1871: PUSH
1872: LD_EXP 25
1876: PUSH
1877: LD_EXP 26
1881: PUSH
1882: LD_EXP 27
1886: PUSH
1887: LD_EXP 28
1891: PUSH
1892: LD_EXP 29
1896: PUSH
1897: LD_EXP 31
1901: PUSH
1902: LD_EXP 32
1906: PUSH
1907: LD_EXP 33
1911: PUSH
1912: LD_EXP 34
1916: PUSH
1917: EMPTY
1918: LIST
1919: LIST
1920: LIST
1921: LIST
1922: LIST
1923: LIST
1924: LIST
1925: LIST
1926: LIST
1927: LIST
1928: LIST
1929: LIST
1930: DIFF
1931: ST_TO_ADDR
// if others then
1932: LD_VAR 0 8
1936: IFFALSE 1950
// SaveCharacters ( others , 11_others ) ;
1938: LD_VAR 0 8
1942: PPUSH
1943: LD_STRING 11_others
1945: PPUSH
1946: CALL_OW 38
// vehs := [ [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun ] , [ us_medium_wheeled , engine_solar , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_medium_wheeled , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_solar , control_manual , us_rocket_launcher ] ] ;
1950: LD_ADDR_VAR 0 6
1954: PUSH
1955: LD_INT 3
1957: PUSH
1958: LD_INT 1
1960: PUSH
1961: LD_INT 1
1963: PUSH
1964: LD_INT 4
1966: PUSH
1967: EMPTY
1968: LIST
1969: LIST
1970: LIST
1971: LIST
1972: PUSH
1973: LD_INT 2
1975: PUSH
1976: LD_INT 2
1978: PUSH
1979: LD_INT 1
1981: PUSH
1982: LD_INT 5
1984: PUSH
1985: EMPTY
1986: LIST
1987: LIST
1988: LIST
1989: LIST
1990: PUSH
1991: LD_INT 4
1993: PUSH
1994: LD_INT 1
1996: PUSH
1997: LD_INT 1
1999: PUSH
2000: LD_INT 5
2002: PUSH
2003: EMPTY
2004: LIST
2005: LIST
2006: LIST
2007: LIST
2008: PUSH
2009: LD_INT 2
2011: PUSH
2012: LD_INT 1
2014: PUSH
2015: LD_INT 1
2017: PUSH
2018: LD_INT 7
2020: PUSH
2021: EMPTY
2022: LIST
2023: LIST
2024: LIST
2025: LIST
2026: PUSH
2027: LD_INT 3
2029: PUSH
2030: LD_INT 2
2032: PUSH
2033: LD_INT 1
2035: PUSH
2036: LD_INT 7
2038: PUSH
2039: EMPTY
2040: LIST
2041: LIST
2042: LIST
2043: LIST
2044: PUSH
2045: EMPTY
2046: LIST
2047: LIST
2048: LIST
2049: LIST
2050: LIST
2051: ST_TO_ADDR
// for i in JMM ^ selected do
2052: LD_ADDR_VAR 0 2
2056: PUSH
2057: LD_EXP 21
2061: PUSH
2062: LD_EXP 19
2066: ADD
2067: PUSH
2068: FOR_IN
2069: IFFALSE 2259
// begin if GetClass ( i ) = 3 then
2071: LD_VAR 0 2
2075: PPUSH
2076: CALL_OW 257
2080: PUSH
2081: LD_INT 3
2083: EQUAL
2084: IFFALSE 2242
// begin vc_chassis := vehs [ 1 ] [ 1 ] ;
2086: LD_ADDR_OWVAR 37
2090: PUSH
2091: LD_VAR 0 6
2095: PUSH
2096: LD_INT 1
2098: ARRAY
2099: PUSH
2100: LD_INT 1
2102: ARRAY
2103: ST_TO_ADDR
// vc_engine := vehs [ 1 ] [ 2 ] ;
2104: LD_ADDR_OWVAR 39
2108: PUSH
2109: LD_VAR 0 6
2113: PUSH
2114: LD_INT 1
2116: ARRAY
2117: PUSH
2118: LD_INT 2
2120: ARRAY
2121: ST_TO_ADDR
// vc_control := vehs [ 1 ] [ 3 ] ;
2122: LD_ADDR_OWVAR 38
2126: PUSH
2127: LD_VAR 0 6
2131: PUSH
2132: LD_INT 1
2134: ARRAY
2135: PUSH
2136: LD_INT 3
2138: ARRAY
2139: ST_TO_ADDR
// vc_weapon := vehs [ 1 ] [ 4 ] ;
2140: LD_ADDR_OWVAR 40
2144: PUSH
2145: LD_VAR 0 6
2149: PUSH
2150: LD_INT 1
2152: ARRAY
2153: PUSH
2154: LD_INT 4
2156: ARRAY
2157: ST_TO_ADDR
// vehs := Delete ( vehs , 1 ) ;
2158: LD_ADDR_VAR 0 6
2162: PUSH
2163: LD_VAR 0 6
2167: PPUSH
2168: LD_INT 1
2170: PPUSH
2171: CALL_OW 3
2175: ST_TO_ADDR
// veh := CreateVehicle ;
2176: LD_ADDR_VAR 0 7
2180: PUSH
2181: CALL_OW 45
2185: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2186: LD_VAR 0 7
2190: PPUSH
2191: LD_INT 8
2193: PPUSH
2194: LD_INT 0
2196: PPUSH
2197: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
2201: LD_VAR 0 2
2205: PPUSH
2206: LD_VAR 0 7
2210: PPUSH
2211: CALL_OW 52
// if i = JMM then
2215: LD_VAR 0 2
2219: PUSH
2220: LD_EXP 21
2224: EQUAL
2225: IFFALSE 2240
// SetMark ( veh , - 1 ) ;
2227: LD_VAR 0 7
2231: PPUSH
2232: LD_INT 1
2234: NEG
2235: PPUSH
2236: CALL_OW 242
// end else
2240: GO 2257
// PlaceUnitArea ( i , am_hum_start , false ) ;
2242: LD_VAR 0 2
2246: PPUSH
2247: LD_INT 9
2249: PPUSH
2250: LD_INT 0
2252: PPUSH
2253: CALL_OW 49
// end ;
2257: GO 2068
2259: POP
2260: POP
// vc_chassis := us_medium_tracked ;
2261: LD_ADDR_OWVAR 37
2265: PUSH
2266: LD_INT 3
2268: ST_TO_ADDR
// vc_engine := engine_solar ;
2269: LD_ADDR_OWVAR 39
2273: PUSH
2274: LD_INT 2
2276: ST_TO_ADDR
// vc_control := control_computer ;
2277: LD_ADDR_OWVAR 38
2281: PUSH
2282: LD_INT 3
2284: ST_TO_ADDR
// vc_weapon := us_radar ;
2285: LD_ADDR_OWVAR 40
2289: PUSH
2290: LD_INT 11
2292: ST_TO_ADDR
// veh := CreateVehicle ;
2293: LD_ADDR_VAR 0 7
2297: PUSH
2298: CALL_OW 45
2302: ST_TO_ADDR
// PlaceUnitXY ( veh , 87 , 142 , false ) ;
2303: LD_VAR 0 7
2307: PPUSH
2308: LD_INT 87
2310: PPUSH
2311: LD_INT 142
2313: PPUSH
2314: LD_INT 0
2316: PPUSH
2317: CALL_OW 48
// end ;
2321: LD_VAR 0 1
2325: RET
// export function AmericanReinforcements ; var i , vehs , veh ; begin
2326: LD_INT 0
2328: PPUSH
2329: PPUSH
2330: PPUSH
2331: PPUSH
// uc_side := 1 ;
2332: LD_ADDR_OWVAR 20
2336: PUSH
2337: LD_INT 1
2339: ST_TO_ADDR
// uc_nation := 1 ;
2340: LD_ADDR_OWVAR 21
2344: PUSH
2345: LD_INT 1
2347: ST_TO_ADDR
// vehs := [ [ us_medium_tracked , engine_combustion , control_computer , us_double_gun ] , [ us_medium_tracked , engine_combustion , control_computer , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_computer , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_computer , us_radar ] , [ us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_computer , us_double_gun ] ] ;
2348: LD_ADDR_VAR 0 3
2352: PUSH
2353: LD_INT 3
2355: PUSH
2356: LD_INT 1
2358: PUSH
2359: LD_INT 3
2361: PUSH
2362: LD_INT 5
2364: PUSH
2365: EMPTY
2366: LIST
2367: LIST
2368: LIST
2369: LIST
2370: PUSH
2371: LD_INT 3
2373: PUSH
2374: LD_INT 1
2376: PUSH
2377: LD_INT 3
2379: PUSH
2380: LD_INT 7
2382: PUSH
2383: EMPTY
2384: LIST
2385: LIST
2386: LIST
2387: LIST
2388: PUSH
2389: LD_INT 3
2391: PUSH
2392: LD_INT 1
2394: PUSH
2395: LD_INT 3
2397: PUSH
2398: LD_INT 7
2400: PUSH
2401: EMPTY
2402: LIST
2403: LIST
2404: LIST
2405: LIST
2406: PUSH
2407: LD_INT 3
2409: PUSH
2410: LD_INT 1
2412: PUSH
2413: LD_INT 3
2415: PUSH
2416: LD_INT 11
2418: PUSH
2419: EMPTY
2420: LIST
2421: LIST
2422: LIST
2423: LIST
2424: PUSH
2425: LD_INT 4
2427: PUSH
2428: LD_INT 1
2430: PUSH
2431: LD_INT 3
2433: PUSH
2434: LD_INT 6
2436: PUSH
2437: EMPTY
2438: LIST
2439: LIST
2440: LIST
2441: LIST
2442: PUSH
2443: LD_INT 4
2445: PUSH
2446: LD_INT 1
2448: PUSH
2449: LD_INT 3
2451: PUSH
2452: LD_INT 5
2454: PUSH
2455: EMPTY
2456: LIST
2457: LIST
2458: LIST
2459: LIST
2460: PUSH
2461: EMPTY
2462: LIST
2463: LIST
2464: LIST
2465: LIST
2466: LIST
2467: LIST
2468: ST_TO_ADDR
// for i := 1 to 7 - Difficulty do
2469: LD_ADDR_VAR 0 2
2473: PUSH
2474: DOUBLE
2475: LD_INT 1
2477: DEC
2478: ST_TO_ADDR
2479: LD_INT 7
2481: PUSH
2482: LD_OWVAR 67
2486: MINUS
2487: PUSH
2488: FOR_TO
2489: IFFALSE 2598
// begin vc_chassis := vehs [ i ] [ 1 ] ;
2491: LD_ADDR_OWVAR 37
2495: PUSH
2496: LD_VAR 0 3
2500: PUSH
2501: LD_VAR 0 2
2505: ARRAY
2506: PUSH
2507: LD_INT 1
2509: ARRAY
2510: ST_TO_ADDR
// vc_engine := vehs [ i ] [ 2 ] ;
2511: LD_ADDR_OWVAR 39
2515: PUSH
2516: LD_VAR 0 3
2520: PUSH
2521: LD_VAR 0 2
2525: ARRAY
2526: PUSH
2527: LD_INT 2
2529: ARRAY
2530: ST_TO_ADDR
// vc_control := vehs [ i ] [ 3 ] ;
2531: LD_ADDR_OWVAR 38
2535: PUSH
2536: LD_VAR 0 3
2540: PUSH
2541: LD_VAR 0 2
2545: ARRAY
2546: PUSH
2547: LD_INT 3
2549: ARRAY
2550: ST_TO_ADDR
// vc_weapon := vehs [ i ] [ 4 ] ;
2551: LD_ADDR_OWVAR 40
2555: PUSH
2556: LD_VAR 0 3
2560: PUSH
2561: LD_VAR 0 2
2565: ARRAY
2566: PUSH
2567: LD_INT 4
2569: ARRAY
2570: ST_TO_ADDR
// veh := CreateVehicle ;
2571: LD_ADDR_VAR 0 4
2575: PUSH
2576: CALL_OW 45
2580: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2581: LD_VAR 0 4
2585: PPUSH
2586: LD_INT 8
2588: PPUSH
2589: LD_INT 0
2591: PPUSH
2592: CALL_OW 49
// end ;
2596: GO 2488
2598: POP
2599: POP
// end ; end_of_file
2600: LD_VAR 0 1
2604: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_north_2 , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_kamikadze , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ; var i , d , un , skill , tmp ; begin
2605: LD_INT 0
2607: PPUSH
2608: PPUSH
2609: PPUSH
2610: PPUSH
2611: PPUSH
2612: PPUSH
// if Difficulty = 1 then
2613: LD_OWVAR 67
2617: PUSH
2618: LD_INT 1
2620: EQUAL
2621: IFFALSE 2718
// begin tmp := [ [ 129 , 45 ] , [ 143 , 58 ] , [ 184 , 113 ] , [ 163 , 107 ] ] ;
2623: LD_ADDR_VAR 0 6
2627: PUSH
2628: LD_INT 129
2630: PUSH
2631: LD_INT 45
2633: PUSH
2634: EMPTY
2635: LIST
2636: LIST
2637: PUSH
2638: LD_INT 143
2640: PUSH
2641: LD_INT 58
2643: PUSH
2644: EMPTY
2645: LIST
2646: LIST
2647: PUSH
2648: LD_INT 184
2650: PUSH
2651: LD_INT 113
2653: PUSH
2654: EMPTY
2655: LIST
2656: LIST
2657: PUSH
2658: LD_INT 163
2660: PUSH
2661: LD_INT 107
2663: PUSH
2664: EMPTY
2665: LIST
2666: LIST
2667: PUSH
2668: EMPTY
2669: LIST
2670: LIST
2671: LIST
2672: LIST
2673: ST_TO_ADDR
// for i in tmp do
2674: LD_ADDR_VAR 0 2
2678: PUSH
2679: LD_VAR 0 6
2683: PUSH
2684: FOR_IN
2685: IFFALSE 2716
// RemoveUnit ( HexInfo ( i [ 1 ] , i [ 2 ] ) ) ;
2687: LD_VAR 0 2
2691: PUSH
2692: LD_INT 1
2694: ARRAY
2695: PPUSH
2696: LD_VAR 0 2
2700: PUSH
2701: LD_INT 2
2703: ARRAY
2704: PPUSH
2705: CALL_OW 428
2709: PPUSH
2710: CALL_OW 64
2714: GO 2684
2716: POP
2717: POP
// end ; for i in FilterAllUnits ( [ f_type , unit_building ] ) do
2718: LD_ADDR_VAR 0 2
2722: PUSH
2723: LD_INT 21
2725: PUSH
2726: LD_INT 3
2728: PUSH
2729: EMPTY
2730: LIST
2731: LIST
2732: PPUSH
2733: CALL_OW 69
2737: PUSH
2738: FOR_IN
2739: IFFALSE 2776
// SetBLevel ( i , [ 5 , 6 , 7 , 8 ] [ Difficulty ] ) ;
2741: LD_VAR 0 2
2745: PPUSH
2746: LD_INT 5
2748: PUSH
2749: LD_INT 6
2751: PUSH
2752: LD_INT 7
2754: PUSH
2755: LD_INT 8
2757: PUSH
2758: EMPTY
2759: LIST
2760: LIST
2761: LIST
2762: LIST
2763: PUSH
2764: LD_OWVAR 67
2768: ARRAY
2769: PPUSH
2770: CALL_OW 241
2774: GO 2738
2776: POP
2777: POP
// skill := [ 5 , 6 , 7 , 8 ] [ Difficulty ] ;
2778: LD_ADDR_VAR 0 5
2782: PUSH
2783: LD_INT 5
2785: PUSH
2786: LD_INT 6
2788: PUSH
2789: LD_INT 7
2791: PUSH
2792: LD_INT 8
2794: PUSH
2795: EMPTY
2796: LIST
2797: LIST
2798: LIST
2799: LIST
2800: PUSH
2801: LD_OWVAR 67
2805: ARRAY
2806: ST_TO_ADDR
// uc_side := 2 ;
2807: LD_ADDR_OWVAR 20
2811: PUSH
2812: LD_INT 2
2814: ST_TO_ADDR
// uc_nation := 2 ;
2815: LD_ADDR_OWVAR 21
2819: PUSH
2820: LD_INT 2
2822: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
2823: LD_ADDR_OWVAR 37
2827: PUSH
2828: LD_INT 14
2830: ST_TO_ADDR
// vc_engine := engine_siberite ;
2831: LD_ADDR_OWVAR 39
2835: PUSH
2836: LD_INT 3
2838: ST_TO_ADDR
// vc_control := control_manual ;
2839: LD_ADDR_OWVAR 38
2843: PUSH
2844: LD_INT 1
2846: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
2847: LD_ADDR_OWVAR 40
2851: PUSH
2852: LD_INT 31
2854: ST_TO_ADDR
// for i = 1 to 3 do
2855: LD_ADDR_VAR 0 2
2859: PUSH
2860: DOUBLE
2861: LD_INT 1
2863: DEC
2864: ST_TO_ADDR
2865: LD_INT 3
2867: PUSH
2868: FOR_TO
2869: IFFALSE 2953
// begin PrepareHuman ( false , class_mechanic , skill ) ;
2871: LD_INT 0
2873: PPUSH
2874: LD_INT 3
2876: PPUSH
2877: LD_VAR 0 5
2881: PPUSH
2882: CALL_OW 380
// un := CreateVehicle ;
2886: LD_ADDR_VAR 0 4
2890: PUSH
2891: CALL_OW 45
2895: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
2896: LD_VAR 0 4
2900: PPUSH
2901: LD_INT 0
2903: PPUSH
2904: LD_INT 5
2906: PPUSH
2907: CALL_OW 12
2911: PPUSH
2912: CALL_OW 233
// PlaceUnitXYR ( un , 156 , 15 , 6 , false ) ;
2916: LD_VAR 0 4
2920: PPUSH
2921: LD_INT 156
2923: PPUSH
2924: LD_INT 15
2926: PPUSH
2927: LD_INT 6
2929: PPUSH
2930: LD_INT 0
2932: PPUSH
2933: CALL_OW 50
// PlaceHumanInUnit ( CreateHuman , un ) ;
2937: CALL_OW 44
2941: PPUSH
2942: LD_VAR 0 4
2946: PPUSH
2947: CALL_OW 52
// end ;
2951: GO 2868
2953: POP
2954: POP
// ar_force_north := PrepareBase ( ar_dep_n , base_north , dammam , skill , [ 10000 , 1000 , 300 ] , [ 12 , [ 2 , 3 , 4 , 4 ] [ Difficulty ] , - 1 , 4 ] ) ;
2955: LD_ADDR_EXP 37
2959: PUSH
2960: LD_INT 94
2962: PPUSH
2963: LD_INT 28
2965: PPUSH
2966: LD_STRING dammam
2968: PPUSH
2969: LD_VAR 0 5
2973: PPUSH
2974: LD_INT 10000
2976: PUSH
2977: LD_INT 1000
2979: PUSH
2980: LD_INT 300
2982: PUSH
2983: EMPTY
2984: LIST
2985: LIST
2986: LIST
2987: PPUSH
2988: LD_INT 12
2990: PUSH
2991: LD_INT 2
2993: PUSH
2994: LD_INT 3
2996: PUSH
2997: LD_INT 4
2999: PUSH
3000: LD_INT 4
3002: PUSH
3003: EMPTY
3004: LIST
3005: LIST
3006: LIST
3007: LIST
3008: PUSH
3009: LD_OWVAR 67
3013: ARRAY
3014: PUSH
3015: LD_INT 1
3017: NEG
3018: PUSH
3019: LD_INT 4
3021: PUSH
3022: EMPTY
3023: LIST
3024: LIST
3025: LIST
3026: LIST
3027: PPUSH
3028: CALL 57111 0 6
3032: ST_TO_ADDR
// ar_force_north := ar_force_north union PrepareBase ( ar_dep_n2 , base_north_2 ,  , skill , [ 500 , 60 , 0 ] , [ 8 , [ 2 , 3 , 4 , 5 ] [ Difficulty ] , 2 , 0 ] ) ;
3033: LD_ADDR_EXP 37
3037: PUSH
3038: LD_EXP 37
3042: PUSH
3043: LD_INT 122
3045: PPUSH
3046: LD_INT 25
3048: PPUSH
3049: LD_STRING 
3051: PPUSH
3052: LD_VAR 0 5
3056: PPUSH
3057: LD_INT 500
3059: PUSH
3060: LD_INT 60
3062: PUSH
3063: LD_INT 0
3065: PUSH
3066: EMPTY
3067: LIST
3068: LIST
3069: LIST
3070: PPUSH
3071: LD_INT 8
3073: PUSH
3074: LD_INT 2
3076: PUSH
3077: LD_INT 3
3079: PUSH
3080: LD_INT 4
3082: PUSH
3083: LD_INT 5
3085: PUSH
3086: EMPTY
3087: LIST
3088: LIST
3089: LIST
3090: LIST
3091: PUSH
3092: LD_OWVAR 67
3096: ARRAY
3097: PUSH
3098: LD_INT 2
3100: PUSH
3101: LD_INT 0
3103: PUSH
3104: EMPTY
3105: LIST
3106: LIST
3107: LIST
3108: LIST
3109: PPUSH
3110: CALL 57111 0 6
3114: UNION
3115: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , base_west , jeddah , skill , [ 700 , 300 , 10 ] , [ 9 , 4 , 3 , 2 ] ) ;
3116: LD_ADDR_EXP 35
3120: PUSH
3121: LD_INT 45
3123: PPUSH
3124: LD_INT 24
3126: PPUSH
3127: LD_STRING jeddah
3129: PPUSH
3130: LD_VAR 0 5
3134: PPUSH
3135: LD_INT 700
3137: PUSH
3138: LD_INT 300
3140: PUSH
3141: LD_INT 10
3143: PUSH
3144: EMPTY
3145: LIST
3146: LIST
3147: LIST
3148: PPUSH
3149: LD_INT 9
3151: PUSH
3152: LD_INT 4
3154: PUSH
3155: LD_INT 3
3157: PUSH
3158: LD_INT 2
3160: PUSH
3161: EMPTY
3162: LIST
3163: LIST
3164: LIST
3165: LIST
3166: PPUSH
3167: CALL 57111 0 6
3171: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , base_south , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
3172: LD_ADDR_EXP 36
3176: PUSH
3177: LD_INT 7
3179: PPUSH
3180: LD_INT 27
3182: PPUSH
3183: LD_STRING riyadh
3185: PPUSH
3186: LD_VAR 0 5
3190: PPUSH
3191: LD_INT 500
3193: PUSH
3194: LD_INT 60
3196: PUSH
3197: LD_INT 0
3199: PUSH
3200: EMPTY
3201: LIST
3202: LIST
3203: LIST
3204: PPUSH
3205: LD_INT 4
3207: PUSH
3208: LD_INT 2
3210: PUSH
3211: LD_INT 3
3213: PUSH
3214: LD_INT 1
3216: PUSH
3217: EMPTY
3218: LIST
3219: LIST
3220: LIST
3221: LIST
3222: PPUSH
3223: CALL 57111 0 6
3227: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e , base_east ,  , skill , [ 500 , 50 , 0 ] , [ 9 , 2 , 3 , 1 ] ) ;
3228: LD_ADDR_EXP 39
3232: PUSH
3233: LD_INT 204
3235: PPUSH
3236: LD_INT 26
3238: PPUSH
3239: LD_STRING 
3241: PPUSH
3242: LD_VAR 0 5
3246: PPUSH
3247: LD_INT 500
3249: PUSH
3250: LD_INT 50
3252: PUSH
3253: LD_INT 0
3255: PUSH
3256: EMPTY
3257: LIST
3258: LIST
3259: LIST
3260: PPUSH
3261: LD_INT 9
3263: PUSH
3264: LD_INT 2
3266: PUSH
3267: LD_INT 3
3269: PUSH
3270: LD_INT 1
3272: PUSH
3273: EMPTY
3274: LIST
3275: LIST
3276: LIST
3277: LIST
3278: PPUSH
3279: CALL 57111 0 6
3283: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east ] ;
3284: LD_ADDR_EXP 50
3288: PUSH
3289: LD_EXP 37
3293: PUSH
3294: LD_EXP 35
3298: PUSH
3299: LD_EXP 39
3303: PUSH
3304: EMPTY
3305: LIST
3306: LIST
3307: LIST
3308: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
3309: LD_ADDR_VAR 0 2
3313: PUSH
3314: LD_INT 22
3316: PUSH
3317: LD_INT 2
3319: PUSH
3320: EMPTY
3321: LIST
3322: LIST
3323: PUSH
3324: LD_INT 30
3326: PUSH
3327: LD_INT 31
3329: PUSH
3330: EMPTY
3331: LIST
3332: LIST
3333: PUSH
3334: LD_INT 58
3336: PUSH
3337: EMPTY
3338: LIST
3339: PUSH
3340: EMPTY
3341: LIST
3342: LIST
3343: LIST
3344: PPUSH
3345: CALL_OW 69
3349: PUSH
3350: FOR_IN
3351: IFFALSE 3476
// begin if GetBase ( i ) then
3353: LD_VAR 0 2
3357: PPUSH
3358: CALL_OW 274
3362: IFFALSE 3366
// continue ;
3364: GO 3350
// d := GetDir ( i ) ;
3366: LD_ADDR_VAR 0 3
3370: PUSH
3371: LD_VAR 0 2
3375: PPUSH
3376: CALL_OW 254
3380: ST_TO_ADDR
// if d < 3 then
3381: LD_VAR 0 3
3385: PUSH
3386: LD_INT 3
3388: LESS
3389: IFFALSE 3407
// d := d + 3 else
3391: LD_ADDR_VAR 0 3
3395: PUSH
3396: LD_VAR 0 3
3400: PUSH
3401: LD_INT 3
3403: PLUS
3404: ST_TO_ADDR
3405: GO 3421
// d := d - 3 ;
3407: LD_ADDR_VAR 0 3
3411: PUSH
3412: LD_VAR 0 3
3416: PUSH
3417: LD_INT 3
3419: MINUS
3420: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
3421: LD_INT 0
3423: PPUSH
3424: LD_INT 8
3426: PPUSH
3427: LD_VAR 0 5
3431: PPUSH
3432: CALL_OW 380
// un := CreateHuman ;
3436: LD_ADDR_VAR 0 4
3440: PUSH
3441: CALL_OW 44
3445: ST_TO_ADDR
// SetDir ( un , d ) ;
3446: LD_VAR 0 4
3450: PPUSH
3451: LD_VAR 0 3
3455: PPUSH
3456: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
3460: LD_VAR 0 4
3464: PPUSH
3465: LD_VAR 0 2
3469: PPUSH
3470: CALL_OW 52
// end ;
3474: GO 3350
3476: POP
3477: POP
// if Difficulty > 1 then
3478: LD_OWVAR 67
3482: PUSH
3483: LD_INT 1
3485: GREATER
3486: IFFALSE 3857
// begin ar_kamikadze := [ ] ;
3488: LD_ADDR_EXP 42
3492: PUSH
3493: EMPTY
3494: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
3495: LD_INT 0
3497: PPUSH
3498: LD_INT 1
3500: PPUSH
3501: LD_VAR 0 5
3505: PPUSH
3506: CALL_OW 380
// un := CreateHuman ;
3510: LD_ADDR_VAR 0 4
3514: PUSH
3515: CALL_OW 44
3519: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3520: LD_VAR 0 4
3524: PPUSH
3525: LD_INT 3
3527: PPUSH
3528: CALL_OW 233
// PlaceUnitXY ( un , 23 , 44 , false ) ;
3532: LD_VAR 0 4
3536: PPUSH
3537: LD_INT 23
3539: PPUSH
3540: LD_INT 44
3542: PPUSH
3543: LD_INT 0
3545: PPUSH
3546: CALL_OW 48
// ComCrawl ( un ) ;
3550: LD_VAR 0 4
3554: PPUSH
3555: CALL_OW 137
// un := CreateHuman ;
3559: LD_ADDR_VAR 0 4
3563: PUSH
3564: CALL_OW 44
3568: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3569: LD_VAR 0 4
3573: PPUSH
3574: LD_INT 3
3576: PPUSH
3577: CALL_OW 233
// PlaceUnitXY ( un , 30 , 39 , false ) ;
3581: LD_VAR 0 4
3585: PPUSH
3586: LD_INT 30
3588: PPUSH
3589: LD_INT 39
3591: PPUSH
3592: LD_INT 0
3594: PPUSH
3595: CALL_OW 48
// ComCrawl ( un ) ;
3599: LD_VAR 0 4
3603: PPUSH
3604: CALL_OW 137
// PrepareHuman ( false , 17 , skill ) ;
3608: LD_INT 0
3610: PPUSH
3611: LD_INT 17
3613: PPUSH
3614: LD_VAR 0 5
3618: PPUSH
3619: CALL_OW 380
// un := CreateHuman ;
3623: LD_ADDR_VAR 0 4
3627: PUSH
3628: CALL_OW 44
3632: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3633: LD_VAR 0 4
3637: PPUSH
3638: LD_INT 3
3640: PPUSH
3641: CALL_OW 233
// PlaceUnitXY ( un , 45 , 86 , false ) ;
3645: LD_VAR 0 4
3649: PPUSH
3650: LD_INT 45
3652: PPUSH
3653: LD_INT 86
3655: PPUSH
3656: LD_INT 0
3658: PPUSH
3659: CALL_OW 48
// ComHold ( un ) ;
3663: LD_VAR 0 4
3667: PPUSH
3668: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3672: LD_ADDR_EXP 42
3676: PUSH
3677: LD_EXP 42
3681: PPUSH
3682: LD_EXP 42
3686: PUSH
3687: LD_INT 1
3689: PLUS
3690: PPUSH
3691: LD_VAR 0 4
3695: PPUSH
3696: CALL_OW 1
3700: ST_TO_ADDR
// un := CreateHuman ;
3701: LD_ADDR_VAR 0 4
3705: PUSH
3706: CALL_OW 44
3710: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3711: LD_VAR 0 4
3715: PPUSH
3716: LD_INT 3
3718: PPUSH
3719: CALL_OW 233
// PlaceUnitXY ( un , 60 , 85 , false ) ;
3723: LD_VAR 0 4
3727: PPUSH
3728: LD_INT 60
3730: PPUSH
3731: LD_INT 85
3733: PPUSH
3734: LD_INT 0
3736: PPUSH
3737: CALL_OW 48
// ComHold ( un ) ;
3741: LD_VAR 0 4
3745: PPUSH
3746: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3750: LD_ADDR_EXP 42
3754: PUSH
3755: LD_EXP 42
3759: PPUSH
3760: LD_EXP 42
3764: PUSH
3765: LD_INT 1
3767: PLUS
3768: PPUSH
3769: LD_VAR 0 4
3773: PPUSH
3774: CALL_OW 1
3778: ST_TO_ADDR
// un := CreateHuman ;
3779: LD_ADDR_VAR 0 4
3783: PUSH
3784: CALL_OW 44
3788: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3789: LD_VAR 0 4
3793: PPUSH
3794: LD_INT 3
3796: PPUSH
3797: CALL_OW 233
// PlaceUnitXY ( un , 222 , 166 , false ) ;
3801: LD_VAR 0 4
3805: PPUSH
3806: LD_INT 222
3808: PPUSH
3809: LD_INT 166
3811: PPUSH
3812: LD_INT 0
3814: PPUSH
3815: CALL_OW 48
// ComHold ( un ) ;
3819: LD_VAR 0 4
3823: PPUSH
3824: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3828: LD_ADDR_EXP 42
3832: PUSH
3833: LD_EXP 42
3837: PPUSH
3838: LD_EXP 42
3842: PUSH
3843: LD_INT 1
3845: PLUS
3846: PPUSH
3847: LD_VAR 0 4
3851: PPUSH
3852: CALL_OW 1
3856: ST_TO_ADDR
// end ; ar_force_tmp := [ ] ;
3857: LD_ADDR_EXP 40
3861: PUSH
3862: EMPTY
3863: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
3864: LD_INT 1
3866: PPUSH
3867: LD_INT 1
3869: PPUSH
3870: LD_VAR 0 5
3874: PPUSH
3875: CALL_OW 380
// hc_name := Pavel Grigorovic ;
3879: LD_ADDR_OWVAR 26
3883: PUSH
3884: LD_STRING Pavel Grigorovic
3886: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3887: LD_ADDR_OWVAR 33
3891: PUSH
3892: LD_STRING SecondCharsGal
3894: ST_TO_ADDR
// hc_face_number := 4 ;
3895: LD_ADDR_OWVAR 34
3899: PUSH
3900: LD_INT 4
3902: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
3903: LD_ADDR_EXP 40
3907: PUSH
3908: LD_EXP 40
3912: PPUSH
3913: LD_INT 1
3915: PPUSH
3916: CALL_OW 44
3920: PPUSH
3921: CALL_OW 1
3925: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3926: LD_INT 2
3928: PPUSH
3929: LD_INT 4
3931: PPUSH
3932: LD_INT 2
3934: PPUSH
3935: CALL_OW 380
// hc_name := Lucy Sebel ;
3939: LD_ADDR_OWVAR 26
3943: PUSH
3944: LD_STRING Lucy Sebel
3946: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3947: LD_ADDR_OWVAR 33
3951: PUSH
3952: LD_STRING SecondCharsGal
3954: ST_TO_ADDR
// hc_face_number := 15 ;
3955: LD_ADDR_OWVAR 34
3959: PUSH
3960: LD_INT 15
3962: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
3963: LD_ADDR_EXP 40
3967: PUSH
3968: LD_EXP 40
3972: PPUSH
3973: LD_INT 2
3975: PPUSH
3976: CALL_OW 44
3980: PPUSH
3981: CALL_OW 1
3985: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3986: LD_INT 2
3988: PPUSH
3989: LD_INT 4
3991: PPUSH
3992: LD_INT 2
3994: PPUSH
3995: CALL_OW 380
// hc_gallery :=  ;
3999: LD_ADDR_OWVAR 33
4003: PUSH
4004: LD_STRING 
4006: ST_TO_ADDR
// hc_name :=  ;
4007: LD_ADDR_OWVAR 26
4011: PUSH
4012: LD_STRING 
4014: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
4015: LD_ADDR_EXP 40
4019: PUSH
4020: LD_EXP 40
4024: PPUSH
4025: LD_INT 3
4027: PPUSH
4028: CALL_OW 44
4032: PPUSH
4033: CALL_OW 1
4037: ST_TO_ADDR
// hc_sex := sex_male ;
4038: LD_ADDR_OWVAR 27
4042: PUSH
4043: LD_INT 1
4045: ST_TO_ADDR
// hc_class = 11 ;
4046: LD_ADDR_OWVAR 28
4050: PUSH
4051: LD_INT 11
4053: ST_TO_ADDR
// hc_gallery = sandar ;
4054: LD_ADDR_OWVAR 33
4058: PUSH
4059: LD_STRING sandar
4061: ST_TO_ADDR
// hc_face_number = 33 ;
4062: LD_ADDR_OWVAR 34
4066: PUSH
4067: LD_INT 33
4069: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
4070: LD_ADDR_OWVAR 26
4074: PUSH
4075: LD_STRING Thabit Muhair Saliba
4077: ST_TO_ADDR
// hc_skills = [ 0 , 0 , 0 , 0 ] ;
4078: LD_ADDR_OWVAR 31
4082: PUSH
4083: LD_INT 0
4085: PUSH
4086: LD_INT 0
4088: PUSH
4089: LD_INT 0
4091: PUSH
4092: LD_INT 0
4094: PUSH
4095: EMPTY
4096: LIST
4097: LIST
4098: LIST
4099: LIST
4100: ST_TO_ADDR
// Saliba = CreateHuman ;
4101: LD_ADDR_EXP 44
4105: PUSH
4106: CALL_OW 44
4110: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
4111: LD_EXP 44
4115: PPUSH
4116: LD_INT 7
4118: PPUSH
4119: CALL_OW 52
// if gensher_active then
4123: LD_EXP 18
4127: IFFALSE 4154
// begin Gensher = NewCharacter ( Dietrich ) ;
4129: LD_ADDR_EXP 45
4133: PUSH
4134: LD_STRING Dietrich
4136: PPUSH
4137: CALL_OW 25
4141: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
4142: LD_EXP 45
4146: PPUSH
4147: LD_INT 94
4149: PPUSH
4150: CALL_OW 52
// end ; InitHc ;
4154: CALL_OW 19
// ar_vehicles_tmp := [ ] ;
4158: LD_ADDR_EXP 41
4162: PUSH
4163: EMPTY
4164: ST_TO_ADDR
// for i = 1 to 5 do
4165: LD_ADDR_VAR 0 2
4169: PUSH
4170: DOUBLE
4171: LD_INT 1
4173: DEC
4174: ST_TO_ADDR
4175: LD_INT 5
4177: PUSH
4178: FOR_TO
4179: IFFALSE 4351
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , [ engine_combustion , engine_solar ] [ rand ( 1 , 2 ) ] , control_manual , [ ar_gatling_gun , ar_gun , ar_flame_thrower ] [ rand ( 1 , 3 ) ] , rand ( 60 , 100 ) ) ;
4181: LD_INT 13
4183: PUSH
4184: LD_INT 14
4186: PUSH
4187: EMPTY
4188: LIST
4189: LIST
4190: PUSH
4191: LD_INT 1
4193: PPUSH
4194: LD_INT 2
4196: PPUSH
4197: CALL_OW 12
4201: ARRAY
4202: PPUSH
4203: LD_INT 1
4205: PUSH
4206: LD_INT 2
4208: PUSH
4209: EMPTY
4210: LIST
4211: LIST
4212: PUSH
4213: LD_INT 1
4215: PPUSH
4216: LD_INT 2
4218: PPUSH
4219: CALL_OW 12
4223: ARRAY
4224: PPUSH
4225: LD_INT 1
4227: PPUSH
4228: LD_INT 25
4230: PUSH
4231: LD_INT 27
4233: PUSH
4234: LD_INT 26
4236: PUSH
4237: EMPTY
4238: LIST
4239: LIST
4240: LIST
4241: PUSH
4242: LD_INT 1
4244: PPUSH
4245: LD_INT 3
4247: PPUSH
4248: CALL_OW 12
4252: ARRAY
4253: PPUSH
4254: LD_INT 60
4256: PPUSH
4257: LD_INT 100
4259: PPUSH
4260: CALL_OW 12
4264: PPUSH
4265: CALL 53667 0 5
// un := CreateVehicle ;
4269: LD_ADDR_VAR 0 4
4273: PUSH
4274: CALL_OW 45
4278: ST_TO_ADDR
// ar_vehicles_tmp := Replace ( ar_vehicles_tmp , ar_vehicles_tmp + 1 , un ) ;
4279: LD_ADDR_EXP 41
4283: PUSH
4284: LD_EXP 41
4288: PPUSH
4289: LD_EXP 41
4293: PUSH
4294: LD_INT 1
4296: PLUS
4297: PPUSH
4298: LD_VAR 0 4
4302: PPUSH
4303: CALL_OW 1
4307: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4308: LD_VAR 0 4
4312: PPUSH
4313: LD_INT 0
4315: PPUSH
4316: LD_INT 5
4318: PPUSH
4319: CALL_OW 12
4323: PPUSH
4324: CALL_OW 233
// PlaceUnitXYR ( un , 124 , 141 , 8 , false ) ;
4328: LD_VAR 0 4
4332: PPUSH
4333: LD_INT 124
4335: PPUSH
4336: LD_INT 141
4338: PPUSH
4339: LD_INT 8
4341: PPUSH
4342: LD_INT 0
4344: PPUSH
4345: CALL_OW 50
// end ;
4349: GO 4178
4351: POP
4352: POP
// ar_defenders_tmp := [ [ ] , [ ] , [ ] ] ;
4353: LD_ADDR_EXP 43
4357: PUSH
4358: EMPTY
4359: PUSH
4360: EMPTY
4361: PUSH
4362: EMPTY
4363: PUSH
4364: EMPTY
4365: LIST
4366: LIST
4367: LIST
4368: ST_TO_ADDR
// for d = 1 to [ 3 , 3 , 4 , 4 ] [ Difficulty ] do
4369: LD_ADDR_VAR 0 3
4373: PUSH
4374: DOUBLE
4375: LD_INT 1
4377: DEC
4378: ST_TO_ADDR
4379: LD_INT 3
4381: PUSH
4382: LD_INT 3
4384: PUSH
4385: LD_INT 4
4387: PUSH
4388: LD_INT 4
4390: PUSH
4391: EMPTY
4392: LIST
4393: LIST
4394: LIST
4395: LIST
4396: PUSH
4397: LD_OWVAR 67
4401: ARRAY
4402: PUSH
4403: FOR_TO
4404: IFFALSE 4618
// for i = 1 to 3 do
4406: LD_ADDR_VAR 0 2
4410: PUSH
4411: DOUBLE
4412: LD_INT 1
4414: DEC
4415: ST_TO_ADDR
4416: LD_INT 3
4418: PUSH
4419: FOR_TO
4420: IFFALSE 4614
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
4422: LD_INT 14
4424: PPUSH
4425: LD_INT 3
4427: PUSH
4428: LD_INT 2
4430: PUSH
4431: EMPTY
4432: LIST
4433: LIST
4434: PUSH
4435: LD_INT 1
4437: PPUSH
4438: LD_INT 2
4440: PPUSH
4441: CALL_OW 12
4445: ARRAY
4446: PPUSH
4447: LD_INT 1
4449: PUSH
4450: LD_INT 5
4452: PUSH
4453: EMPTY
4454: LIST
4455: LIST
4456: PUSH
4457: LD_INT 1
4459: PPUSH
4460: LD_INT 2
4462: PPUSH
4463: CALL_OW 12
4467: ARRAY
4468: PPUSH
4469: LD_INT 25
4471: PUSH
4472: LD_INT 27
4474: PUSH
4475: LD_INT 26
4477: PUSH
4478: LD_INT 28
4480: PUSH
4481: EMPTY
4482: LIST
4483: LIST
4484: LIST
4485: LIST
4486: PUSH
4487: LD_INT 1
4489: PPUSH
4490: LD_INT 4
4492: PPUSH
4493: CALL_OW 12
4497: ARRAY
4498: PPUSH
4499: LD_INT 100
4501: PPUSH
4502: CALL 53667 0 5
// un := CreateVehicle ;
4506: LD_ADDR_VAR 0 4
4510: PUSH
4511: CALL_OW 45
4515: ST_TO_ADDR
// ar_defenders_tmp := ReplaceIn ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
4516: LD_ADDR_EXP 43
4520: PUSH
4521: LD_EXP 43
4525: PPUSH
4526: LD_VAR 0 2
4530: PUSH
4531: LD_EXP 43
4535: PUSH
4536: LD_VAR 0 2
4540: ARRAY
4541: PUSH
4542: LD_INT 1
4544: PLUS
4545: PUSH
4546: EMPTY
4547: LIST
4548: LIST
4549: PPUSH
4550: LD_VAR 0 4
4554: PPUSH
4555: CALL 53789 0 3
4559: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4560: LD_VAR 0 4
4564: PPUSH
4565: LD_INT 0
4567: PPUSH
4568: LD_INT 5
4570: PPUSH
4571: CALL_OW 12
4575: PPUSH
4576: CALL_OW 233
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east ] [ i ] , false ) ;
4580: LD_VAR 0 4
4584: PPUSH
4585: LD_INT 20
4587: PUSH
4588: LD_INT 21
4590: PUSH
4591: LD_INT 22
4593: PUSH
4594: EMPTY
4595: LIST
4596: LIST
4597: LIST
4598: PUSH
4599: LD_VAR 0 2
4603: ARRAY
4604: PPUSH
4605: LD_INT 0
4607: PPUSH
4608: CALL_OW 49
// end ;
4612: GO 4419
4614: POP
4615: POP
4616: GO 4403
4618: POP
4619: POP
// InitHc ;
4620: CALL_OW 19
// CreateResourcesXY ( mat_artifact , 5 , 10 , 5 , false ) ;
4624: LD_INT 4
4626: PPUSH
4627: LD_INT 5
4629: PPUSH
4630: LD_INT 10
4632: PPUSH
4633: LD_INT 5
4635: PPUSH
4636: LD_INT 0
4638: PPUSH
4639: CALL_OW 58
// end ;
4643: LD_VAR 0 1
4647: RET
// every 0 0$1 trigger ar_kamikadze do var i ;
4648: LD_EXP 42
4652: IFFALSE 4726
4654: GO 4656
4656: DISABLE
4657: LD_INT 0
4659: PPUSH
// begin enable ;
4660: ENABLE
// for i in ar_kamikadze do
4661: LD_ADDR_VAR 0 1
4665: PUSH
4666: LD_EXP 42
4670: PUSH
4671: FOR_IN
4672: IFFALSE 4724
// if See ( 1 , i ) then
4674: LD_INT 1
4676: PPUSH
4677: LD_VAR 0 1
4681: PPUSH
4682: CALL_OW 292
4686: IFFALSE 4722
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
4688: LD_VAR 0 1
4692: PPUSH
4693: LD_INT 81
4695: PUSH
4696: LD_INT 2
4698: PUSH
4699: EMPTY
4700: LIST
4701: LIST
4702: PPUSH
4703: CALL_OW 69
4707: PPUSH
4708: LD_VAR 0 1
4712: PPUSH
4713: CALL_OW 74
4717: PPUSH
4718: CALL_OW 115
4722: GO 4671
4724: POP
4725: POP
// end ;
4726: PPOPN 1
4728: END
// every 5 5$20 trigger artifact_get do var i , cargo , tmp , pos ;
4729: LD_EXP 13
4733: IFFALSE 5050
4735: GO 4737
4737: DISABLE
4738: LD_INT 0
4740: PPUSH
4741: PPUSH
4742: PPUSH
4743: PPUSH
// begin repeat wait ( 0 0$1 ) ;
4744: LD_INT 35
4746: PPUSH
4747: CALL_OW 67
// until MC_GetProduceList ( 1 ) = 0 ;
4751: LD_INT 1
4753: PPUSH
4754: CALL 42612 0 1
4758: PUSH
4759: LD_INT 0
4761: EQUAL
4762: IFFALSE 4744
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
4764: LD_INT 1
4766: PPUSH
4767: LD_INT 14
4769: PUSH
4770: LD_INT 3
4772: PUSH
4773: LD_INT 2
4775: PUSH
4776: LD_INT 32
4778: PUSH
4779: EMPTY
4780: LIST
4781: LIST
4782: LIST
4783: LIST
4784: PUSH
4785: EMPTY
4786: LIST
4787: PPUSH
4788: CALL 42216 0 2
// repeat wait ( 0 0$1 ) ;
4792: LD_INT 35
4794: PPUSH
4795: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) ;
4799: LD_EXP 69
4803: PUSH
4804: LD_INT 1
4806: ARRAY
4807: PPUSH
4808: LD_INT 33
4810: PUSH
4811: LD_INT 2
4813: PUSH
4814: EMPTY
4815: LIST
4816: LIST
4817: PUSH
4818: LD_INT 34
4820: PUSH
4821: LD_INT 32
4823: PUSH
4824: EMPTY
4825: LIST
4826: LIST
4827: PUSH
4828: EMPTY
4829: LIST
4830: LIST
4831: PPUSH
4832: CALL_OW 72
4836: IFFALSE 4792
// cargo := UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) [ 1 ] ;
4838: LD_ADDR_VAR 0 2
4842: PUSH
4843: LD_EXP 69
4847: PUSH
4848: LD_INT 1
4850: ARRAY
4851: PPUSH
4852: LD_INT 33
4854: PUSH
4855: LD_INT 2
4857: PUSH
4858: EMPTY
4859: LIST
4860: LIST
4861: PUSH
4862: LD_INT 34
4864: PUSH
4865: LD_INT 32
4867: PUSH
4868: EMPTY
4869: LIST
4870: LIST
4871: PUSH
4872: EMPTY
4873: LIST
4874: LIST
4875: PPUSH
4876: CALL_OW 72
4880: PUSH
4881: LD_INT 1
4883: ARRAY
4884: ST_TO_ADDR
// pos := FindArtifact ( 5 ) ;
4885: LD_ADDR_VAR 0 4
4889: PUSH
4890: LD_INT 5
4892: PPUSH
4893: CALL_OW 469
4897: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4898: LD_INT 35
4900: PPUSH
4901: CALL_OW 67
// pos := FindArtifact ( 5 ) ;
4905: LD_ADDR_VAR 0 4
4909: PUSH
4910: LD_INT 5
4912: PPUSH
4913: CALL_OW 469
4917: ST_TO_ADDR
// tmp := 100 ;
4918: LD_ADDR_VAR 0 3
4922: PUSH
4923: LD_INT 100
4925: ST_TO_ADDR
// if pos then
4926: LD_VAR 0 4
4930: IFFALSE 4970
// tmp := DangerAtRangeXY ( 2 , pos [ 1 ] , pos [ 2 ] , 20 ) [ 4 ] ;
4932: LD_ADDR_VAR 0 3
4936: PUSH
4937: LD_INT 2
4939: PPUSH
4940: LD_VAR 0 4
4944: PUSH
4945: LD_INT 1
4947: ARRAY
4948: PPUSH
4949: LD_VAR 0 4
4953: PUSH
4954: LD_INT 2
4956: ARRAY
4957: PPUSH
4958: LD_INT 20
4960: PPUSH
4961: CALL 54685 0 4
4965: PUSH
4966: LD_INT 4
4968: ARRAY
4969: ST_TO_ADDR
// until pos and not artifact_oncargo and tmp < 10 ;
4970: LD_VAR 0 4
4974: PUSH
4975: LD_EXP 14
4979: NOT
4980: AND
4981: PUSH
4982: LD_VAR 0 3
4986: PUSH
4987: LD_INT 10
4989: LESS
4990: AND
4991: IFFALSE 4898
// ComGet ( cargo , pos [ 1 ] , pos [ 2 ] ) ;
4993: LD_VAR 0 2
4997: PPUSH
4998: LD_VAR 0 4
5002: PUSH
5003: LD_INT 1
5005: ARRAY
5006: PPUSH
5007: LD_VAR 0 4
5011: PUSH
5012: LD_INT 2
5014: ARRAY
5015: PPUSH
5016: CALL_OW 160
// AddComMoveXY ( cargo , 198 , 113 ) ;
5020: LD_VAR 0 2
5024: PPUSH
5025: LD_INT 198
5027: PPUSH
5028: LD_INT 113
5030: PPUSH
5031: CALL_OW 171
// AddComMoveXY ( cargo , 124 , 7 ) ;
5035: LD_VAR 0 2
5039: PPUSH
5040: LD_INT 124
5042: PPUSH
5043: LD_INT 7
5045: PPUSH
5046: CALL_OW 171
// end ;
5050: PPOPN 4
5052: END
// every 5 5$00 trigger base_captured do var i , un , tmp , skill , coords , flags , w , list ;
5053: LD_EXP 6
5057: IFFALSE 7920
5059: GO 5061
5061: DISABLE
5062: LD_INT 0
5064: PPUSH
5065: PPUSH
5066: PPUSH
5067: PPUSH
5068: PPUSH
5069: PPUSH
5070: PPUSH
5071: PPUSH
// begin skill := [ 5 , 6 , 7 , 8 ] [ Difficulty ] ;
5072: LD_ADDR_VAR 0 4
5076: PUSH
5077: LD_INT 5
5079: PUSH
5080: LD_INT 6
5082: PUSH
5083: LD_INT 7
5085: PUSH
5086: LD_INT 8
5088: PUSH
5089: EMPTY
5090: LIST
5091: LIST
5092: LIST
5093: LIST
5094: PUSH
5095: LD_OWVAR 67
5099: ARRAY
5100: ST_TO_ADDR
// coords := [ ] ;
5101: LD_ADDR_VAR 0 5
5105: PUSH
5106: EMPTY
5107: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
5108: LD_ADDR_VAR 0 6
5112: PUSH
5113: LD_INT 0
5115: PUSH
5116: LD_INT 0
5118: PUSH
5119: LD_INT 0
5121: PUSH
5122: LD_INT 0
5124: PUSH
5125: LD_INT 1
5127: PUSH
5128: LD_INT 0
5130: PUSH
5131: LD_INT 0
5133: PUSH
5134: LD_INT 0
5136: PUSH
5137: LD_INT 1
5139: PUSH
5140: LD_INT 0
5142: PUSH
5143: EMPTY
5144: LIST
5145: LIST
5146: LIST
5147: LIST
5148: LIST
5149: LIST
5150: LIST
5151: LIST
5152: LIST
5153: LIST
5154: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ) ;
5155: LD_INT 1
5157: PPUSH
5158: LD_INT 14
5160: PUSH
5161: LD_INT 1
5163: PUSH
5164: LD_INT 2
5166: PUSH
5167: LD_INT 28
5169: PUSH
5170: EMPTY
5171: LIST
5172: LIST
5173: LIST
5174: LIST
5175: PUSH
5176: LD_INT 14
5178: PUSH
5179: LD_INT 1
5181: PUSH
5182: LD_INT 2
5184: PUSH
5185: LD_INT 25
5187: PUSH
5188: EMPTY
5189: LIST
5190: LIST
5191: LIST
5192: LIST
5193: PUSH
5194: LD_INT 14
5196: PUSH
5197: LD_INT 1
5199: PUSH
5200: LD_INT 2
5202: PUSH
5203: LD_INT 28
5205: PUSH
5206: EMPTY
5207: LIST
5208: LIST
5209: LIST
5210: LIST
5211: PUSH
5212: LD_INT 14
5214: PUSH
5215: LD_INT 1
5217: PUSH
5218: LD_INT 2
5220: PUSH
5221: LD_INT 29
5223: PUSH
5224: EMPTY
5225: LIST
5226: LIST
5227: LIST
5228: LIST
5229: PUSH
5230: EMPTY
5231: LIST
5232: LIST
5233: LIST
5234: LIST
5235: PPUSH
5236: CALL 42216 0 2
// wait ( [ 10 10$00 , 9 9$30 , 9 9$00 , 8 8$40 ] [ Difficulty ] ) ;
5240: LD_INT 21000
5242: PUSH
5243: LD_INT 19950
5245: PUSH
5246: LD_INT 18900
5248: PUSH
5249: LD_INT 18200
5251: PUSH
5252: EMPTY
5253: LIST
5254: LIST
5255: LIST
5256: LIST
5257: PUSH
5258: LD_OWVAR 67
5262: ARRAY
5263: PPUSH
5264: CALL_OW 67
// InitHc ;
5268: CALL_OW 19
// InitUc ;
5272: CALL_OW 18
// uc_side := 2 ;
5276: LD_ADDR_OWVAR 20
5280: PUSH
5281: LD_INT 2
5283: ST_TO_ADDR
// uc_nation := 2 ;
5284: LD_ADDR_OWVAR 21
5288: PUSH
5289: LD_INT 2
5291: ST_TO_ADDR
// tmp := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
5292: LD_ADDR_VAR 0 3
5296: PUSH
5297: EMPTY
5298: PUSH
5299: EMPTY
5300: PUSH
5301: EMPTY
5302: PUSH
5303: EMPTY
5304: PUSH
5305: EMPTY
5306: PUSH
5307: EMPTY
5308: LIST
5309: LIST
5310: LIST
5311: LIST
5312: LIST
5313: ST_TO_ADDR
// tmp := Replace ( tmp , 1 , mc_vehicles [ 1 ] diff FilterAllUnits ( [ f_or , [ f_weapon , ar_crane ] , [ f_weapon , ar_cargo_bay ] ] ) ) ;
5314: LD_ADDR_VAR 0 3
5318: PUSH
5319: LD_VAR 0 3
5323: PPUSH
5324: LD_INT 1
5326: PPUSH
5327: LD_EXP 69
5331: PUSH
5332: LD_INT 1
5334: ARRAY
5335: PUSH
5336: LD_INT 2
5338: PUSH
5339: LD_INT 34
5341: PUSH
5342: LD_INT 88
5344: PUSH
5345: EMPTY
5346: LIST
5347: LIST
5348: PUSH
5349: LD_INT 34
5351: PUSH
5352: LD_INT 32
5354: PUSH
5355: EMPTY
5356: LIST
5357: LIST
5358: PUSH
5359: EMPTY
5360: LIST
5361: LIST
5362: LIST
5363: PPUSH
5364: CALL_OW 69
5368: DIFF
5369: PPUSH
5370: CALL_OW 1
5374: ST_TO_ADDR
// for i = 1 to Difficulty do
5375: LD_ADDR_VAR 0 1
5379: PUSH
5380: DOUBLE
5381: LD_INT 1
5383: DEC
5384: ST_TO_ADDR
5385: LD_OWVAR 67
5389: PUSH
5390: FOR_TO
5391: IFFALSE 5529
// begin uc_side := 2 ;
5393: LD_ADDR_OWVAR 20
5397: PUSH
5398: LD_INT 2
5400: ST_TO_ADDR
// uc_nation := 2 ;
5401: LD_ADDR_OWVAR 21
5405: PUSH
5406: LD_INT 2
5408: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
5409: LD_INT 13
5411: PPUSH
5412: LD_INT 3
5414: PPUSH
5415: LD_INT 5
5417: PPUSH
5418: LD_INT 29
5420: PPUSH
5421: LD_INT 100
5423: PPUSH
5424: CALL 53667 0 5
// un := CreateVehicle ;
5428: LD_ADDR_VAR 0 2
5432: PUSH
5433: CALL_OW 45
5437: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 1 , tmp [ 1 ] + 1 ] , un ) ;
5438: LD_ADDR_VAR 0 3
5442: PUSH
5443: LD_VAR 0 3
5447: PPUSH
5448: LD_INT 1
5450: PUSH
5451: LD_VAR 0 3
5455: PUSH
5456: LD_INT 1
5458: ARRAY
5459: PUSH
5460: LD_INT 1
5462: PLUS
5463: PUSH
5464: EMPTY
5465: LIST
5466: LIST
5467: PPUSH
5468: LD_VAR 0 2
5472: PPUSH
5473: CALL 53789 0 3
5477: ST_TO_ADDR
// SetDir ( un , 3 ) ;
5478: LD_VAR 0 2
5482: PPUSH
5483: LD_INT 3
5485: PPUSH
5486: CALL_OW 233
// PlaceUnitArea ( un , north_attack_spawn , false ) ;
5490: LD_VAR 0 2
5494: PPUSH
5495: LD_INT 16
5497: PPUSH
5498: LD_INT 0
5500: PPUSH
5501: CALL_OW 49
// ComMoveXY ( un , 51 , 10 ) ;
5505: LD_VAR 0 2
5509: PPUSH
5510: LD_INT 51
5512: PPUSH
5513: LD_INT 10
5515: PPUSH
5516: CALL_OW 111
// wait ( 0 0$2 ) ;
5520: LD_INT 70
5522: PPUSH
5523: CALL_OW 67
// end ;
5527: GO 5390
5529: POP
5530: POP
// coords := [ [ 51 , 24 ] , [ 75 , 90 ] ] ;
5531: LD_ADDR_VAR 0 5
5535: PUSH
5536: LD_INT 51
5538: PUSH
5539: LD_INT 24
5541: PUSH
5542: EMPTY
5543: LIST
5544: LIST
5545: PUSH
5546: LD_INT 75
5548: PUSH
5549: LD_INT 90
5551: PUSH
5552: EMPTY
5553: LIST
5554: LIST
5555: PUSH
5556: EMPTY
5557: LIST
5558: LIST
5559: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 1 ] , coords , flags ) ;
5560: LD_INT 1
5562: PPUSH
5563: LD_VAR 0 3
5567: PUSH
5568: LD_INT 1
5570: ARRAY
5571: PPUSH
5572: LD_VAR 0 5
5576: PPUSH
5577: LD_VAR 0 6
5581: PPUSH
5582: CALL 42449 0 4
// for i = 1 to [ 1 , 3 , 4 , 5 ] [ Difficulty ] do
5586: LD_ADDR_VAR 0 1
5590: PUSH
5591: DOUBLE
5592: LD_INT 1
5594: DEC
5595: ST_TO_ADDR
5596: LD_INT 1
5598: PUSH
5599: LD_INT 3
5601: PUSH
5602: LD_INT 4
5604: PUSH
5605: LD_INT 5
5607: PUSH
5608: EMPTY
5609: LIST
5610: LIST
5611: LIST
5612: LIST
5613: PUSH
5614: LD_OWVAR 67
5618: ARRAY
5619: PUSH
5620: FOR_TO
5621: IFFALSE 5721
// begin uc_side := 2 ;
5623: LD_ADDR_OWVAR 20
5627: PUSH
5628: LD_INT 2
5630: ST_TO_ADDR
// uc_nation := 2 ;
5631: LD_ADDR_OWVAR 21
5635: PUSH
5636: LD_INT 2
5638: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5639: LD_INT 0
5641: PPUSH
5642: LD_INT 17
5644: PPUSH
5645: LD_VAR 0 4
5649: PPUSH
5650: CALL_OW 380
// un := CreateHuman ;
5654: LD_ADDR_VAR 0 2
5658: PUSH
5659: CALL_OW 44
5663: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5664: LD_ADDR_VAR 0 3
5668: PUSH
5669: LD_VAR 0 3
5673: PPUSH
5674: LD_INT 2
5676: PUSH
5677: LD_VAR 0 3
5681: PUSH
5682: LD_INT 2
5684: ARRAY
5685: PUSH
5686: LD_INT 1
5688: PLUS
5689: PUSH
5690: EMPTY
5691: LIST
5692: LIST
5693: PPUSH
5694: LD_VAR 0 2
5698: PPUSH
5699: CALL 53789 0 3
5703: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5704: LD_VAR 0 2
5708: PPUSH
5709: LD_INT 13
5711: PPUSH
5712: LD_INT 0
5714: PPUSH
5715: CALL_OW 49
// end ;
5719: GO 5620
5721: POP
5722: POP
// for i = 1 to [ 3 , 4 , 5 , 6 ] [ Difficulty ] do
5723: LD_ADDR_VAR 0 1
5727: PUSH
5728: DOUBLE
5729: LD_INT 1
5731: DEC
5732: ST_TO_ADDR
5733: LD_INT 3
5735: PUSH
5736: LD_INT 4
5738: PUSH
5739: LD_INT 5
5741: PUSH
5742: LD_INT 6
5744: PUSH
5745: EMPTY
5746: LIST
5747: LIST
5748: LIST
5749: LIST
5750: PUSH
5751: LD_OWVAR 67
5755: ARRAY
5756: PUSH
5757: FOR_TO
5758: IFFALSE 5879
// begin uc_side := 2 ;
5760: LD_ADDR_OWVAR 20
5764: PUSH
5765: LD_INT 2
5767: ST_TO_ADDR
// uc_nation := 2 ;
5768: LD_ADDR_OWVAR 21
5772: PUSH
5773: LD_INT 2
5775: ST_TO_ADDR
// PrepareHuman ( false , [ 1 , 8 ] [ i mod 2 + 1 ] , skill ) ;
5776: LD_INT 0
5778: PPUSH
5779: LD_INT 1
5781: PUSH
5782: LD_INT 8
5784: PUSH
5785: EMPTY
5786: LIST
5787: LIST
5788: PUSH
5789: LD_VAR 0 1
5793: PUSH
5794: LD_INT 2
5796: MOD
5797: PUSH
5798: LD_INT 1
5800: PLUS
5801: ARRAY
5802: PPUSH
5803: LD_VAR 0 4
5807: PPUSH
5808: CALL_OW 380
// un := CreateHuman ;
5812: LD_ADDR_VAR 0 2
5816: PUSH
5817: CALL_OW 44
5821: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5822: LD_ADDR_VAR 0 3
5826: PUSH
5827: LD_VAR 0 3
5831: PPUSH
5832: LD_INT 2
5834: PUSH
5835: LD_VAR 0 3
5839: PUSH
5840: LD_INT 2
5842: ARRAY
5843: PUSH
5844: LD_INT 1
5846: PLUS
5847: PUSH
5848: EMPTY
5849: LIST
5850: LIST
5851: PPUSH
5852: LD_VAR 0 2
5856: PPUSH
5857: CALL 53789 0 3
5861: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5862: LD_VAR 0 2
5866: PPUSH
5867: LD_INT 13
5869: PPUSH
5870: LD_INT 0
5872: PPUSH
5873: CALL_OW 49
// end ;
5877: GO 5757
5879: POP
5880: POP
// coords := [ [ 67 , 112 ] , [ 85 , 130 ] ] ;
5881: LD_ADDR_VAR 0 5
5885: PUSH
5886: LD_INT 67
5888: PUSH
5889: LD_INT 112
5891: PUSH
5892: EMPTY
5893: LIST
5894: LIST
5895: PUSH
5896: LD_INT 85
5898: PUSH
5899: LD_INT 130
5901: PUSH
5902: EMPTY
5903: LIST
5904: LIST
5905: PUSH
5906: EMPTY
5907: LIST
5908: LIST
5909: ST_TO_ADDR
// MC_PrepareAttack ( 2 , tmp [ 2 ] , coords , flags ) ;
5910: LD_INT 2
5912: PPUSH
5913: LD_VAR 0 3
5917: PUSH
5918: LD_INT 2
5920: ARRAY
5921: PPUSH
5922: LD_VAR 0 5
5926: PPUSH
5927: LD_VAR 0 6
5931: PPUSH
5932: CALL 42449 0 4
// for i = 1 to [ 1 , 2 , 3 , 5 ] [ Difficulty ] do
5936: LD_ADDR_VAR 0 1
5940: PUSH
5941: DOUBLE
5942: LD_INT 1
5944: DEC
5945: ST_TO_ADDR
5946: LD_INT 1
5948: PUSH
5949: LD_INT 2
5951: PUSH
5952: LD_INT 3
5954: PUSH
5955: LD_INT 5
5957: PUSH
5958: EMPTY
5959: LIST
5960: LIST
5961: LIST
5962: LIST
5963: PUSH
5964: LD_OWVAR 67
5968: ARRAY
5969: PUSH
5970: FOR_TO
5971: IFFALSE 6071
// begin uc_side := 2 ;
5973: LD_ADDR_OWVAR 20
5977: PUSH
5978: LD_INT 2
5980: ST_TO_ADDR
// uc_nation := 2 ;
5981: LD_ADDR_OWVAR 21
5985: PUSH
5986: LD_INT 2
5988: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5989: LD_INT 0
5991: PPUSH
5992: LD_INT 17
5994: PPUSH
5995: LD_VAR 0 4
5999: PPUSH
6000: CALL_OW 380
// un := CreateHuman ;
6004: LD_ADDR_VAR 0 2
6008: PUSH
6009: CALL_OW 44
6013: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 3 , tmp [ 3 ] + 1 ] , un ) ;
6014: LD_ADDR_VAR 0 3
6018: PUSH
6019: LD_VAR 0 3
6023: PPUSH
6024: LD_INT 3
6026: PUSH
6027: LD_VAR 0 3
6031: PUSH
6032: LD_INT 3
6034: ARRAY
6035: PUSH
6036: LD_INT 1
6038: PLUS
6039: PUSH
6040: EMPTY
6041: LIST
6042: LIST
6043: PPUSH
6044: LD_VAR 0 2
6048: PPUSH
6049: CALL 53789 0 3
6053: ST_TO_ADDR
// PlaceUnitArea ( un , south_attack_spawn , false ) ;
6054: LD_VAR 0 2
6058: PPUSH
6059: LD_INT 14
6061: PPUSH
6062: LD_INT 0
6064: PPUSH
6065: CALL_OW 49
// end ;
6069: GO 5970
6071: POP
6072: POP
// coords := [ [ 148 , 158 ] , [ 148 , 158 ] ] ;
6073: LD_ADDR_VAR 0 5
6077: PUSH
6078: LD_INT 148
6080: PUSH
6081: LD_INT 158
6083: PUSH
6084: EMPTY
6085: LIST
6086: LIST
6087: PUSH
6088: LD_INT 148
6090: PUSH
6091: LD_INT 158
6093: PUSH
6094: EMPTY
6095: LIST
6096: LIST
6097: PUSH
6098: EMPTY
6099: LIST
6100: LIST
6101: ST_TO_ADDR
// MC_PrepareAttack ( 3 , tmp [ 3 ] , coords , flags ) ;
6102: LD_INT 3
6104: PPUSH
6105: LD_VAR 0 3
6109: PUSH
6110: LD_INT 3
6112: ARRAY
6113: PPUSH
6114: LD_VAR 0 5
6118: PPUSH
6119: LD_VAR 0 6
6123: PPUSH
6124: CALL 42449 0 4
// for i = 1 to [ 2 , 3 , 4 , 5 ] [ Difficulty ] do
6128: LD_ADDR_VAR 0 1
6132: PUSH
6133: DOUBLE
6134: LD_INT 1
6136: DEC
6137: ST_TO_ADDR
6138: LD_INT 2
6140: PUSH
6141: LD_INT 3
6143: PUSH
6144: LD_INT 4
6146: PUSH
6147: LD_INT 5
6149: PUSH
6150: EMPTY
6151: LIST
6152: LIST
6153: LIST
6154: LIST
6155: PUSH
6156: LD_OWVAR 67
6160: ARRAY
6161: PUSH
6162: FOR_TO
6163: IFFALSE 6387
// begin uc_side := 2 ;
6165: LD_ADDR_OWVAR 20
6169: PUSH
6170: LD_INT 2
6172: ST_TO_ADDR
// uc_nation := 2 ;
6173: LD_ADDR_OWVAR 21
6177: PUSH
6178: LD_INT 2
6180: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 3 ) ] , 100 ) ;
6181: LD_INT 14
6183: PPUSH
6184: LD_INT 3
6186: PPUSH
6187: LD_INT 1
6189: PUSH
6190: LD_INT 5
6192: PUSH
6193: EMPTY
6194: LIST
6195: LIST
6196: PUSH
6197: LD_INT 1
6199: PPUSH
6200: LD_INT 2
6202: PPUSH
6203: CALL_OW 12
6207: ARRAY
6208: PPUSH
6209: LD_INT 27
6211: PUSH
6212: LD_INT 26
6214: PUSH
6215: LD_INT 28
6217: PUSH
6218: EMPTY
6219: LIST
6220: LIST
6221: LIST
6222: PUSH
6223: LD_INT 1
6225: PPUSH
6226: LD_INT 3
6228: PPUSH
6229: CALL_OW 12
6233: ARRAY
6234: PPUSH
6235: LD_INT 100
6237: PPUSH
6238: CALL 53667 0 5
// un := CreateVehicle ;
6242: LD_ADDR_VAR 0 2
6246: PUSH
6247: CALL_OW 45
6251: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , un ) ;
6252: LD_ADDR_VAR 0 3
6256: PUSH
6257: LD_VAR 0 3
6261: PPUSH
6262: LD_INT 4
6264: PUSH
6265: LD_VAR 0 3
6269: PUSH
6270: LD_INT 4
6272: ARRAY
6273: PUSH
6274: LD_INT 1
6276: PLUS
6277: PUSH
6278: EMPTY
6279: LIST
6280: LIST
6281: PPUSH
6282: LD_VAR 0 2
6286: PPUSH
6287: CALL 53789 0 3
6291: ST_TO_ADDR
// SetDir ( un , 5 ) ;
6292: LD_VAR 0 2
6296: PPUSH
6297: LD_INT 5
6299: PPUSH
6300: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
6304: LD_VAR 0 2
6308: PPUSH
6309: LD_INT 15
6311: PPUSH
6312: LD_INT 0
6314: PPUSH
6315: CALL_OW 49
// if GetControl ( un ) = control_manual then
6319: LD_VAR 0 2
6323: PPUSH
6324: CALL_OW 263
6328: PUSH
6329: LD_INT 1
6331: EQUAL
6332: IFFALSE 6363
// begin PrepareHuman ( false , 3 , skill ) ;
6334: LD_INT 0
6336: PPUSH
6337: LD_INT 3
6339: PPUSH
6340: LD_VAR 0 4
6344: PPUSH
6345: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
6349: CALL_OW 44
6353: PPUSH
6354: LD_VAR 0 2
6358: PPUSH
6359: CALL_OW 52
// end ; ComMoveXY ( un , 179 , 135 ) ;
6363: LD_VAR 0 2
6367: PPUSH
6368: LD_INT 179
6370: PPUSH
6371: LD_INT 135
6373: PPUSH
6374: CALL_OW 111
// wait ( 0 0$2 ) ;
6378: LD_INT 70
6380: PPUSH
6381: CALL_OW 67
// end ;
6385: GO 6162
6387: POP
6388: POP
// vc_chassis := 15 ;
6389: LD_ADDR_OWVAR 37
6393: PUSH
6394: LD_INT 15
6396: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateVehicle ) ;
6397: LD_ADDR_VAR 0 3
6401: PUSH
6402: LD_VAR 0 3
6406: PPUSH
6407: LD_INT 4
6409: PUSH
6410: LD_VAR 0 3
6414: PUSH
6415: LD_INT 4
6417: ARRAY
6418: PUSH
6419: LD_INT 1
6421: PLUS
6422: PUSH
6423: EMPTY
6424: LIST
6425: LIST
6426: PPUSH
6427: CALL_OW 45
6431: PPUSH
6432: CALL 53789 0 3
6436: ST_TO_ADDR
// PlaceUnitArea ( tmp [ 4 ] [ tmp [ 4 ] ] , east_attack_spawn , false ) ;
6437: LD_VAR 0 3
6441: PUSH
6442: LD_INT 4
6444: ARRAY
6445: PUSH
6446: LD_VAR 0 3
6450: PUSH
6451: LD_INT 4
6453: ARRAY
6454: ARRAY
6455: PPUSH
6456: LD_INT 15
6458: PPUSH
6459: LD_INT 0
6461: PPUSH
6462: CALL_OW 49
// PrepareHuman ( false , class_desert_warior , skill ) ;
6466: LD_INT 0
6468: PPUSH
6469: LD_INT 11
6471: PPUSH
6472: LD_VAR 0 4
6476: PPUSH
6477: CALL_OW 380
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateHuman ) ;
6481: LD_ADDR_VAR 0 3
6485: PUSH
6486: LD_VAR 0 3
6490: PPUSH
6491: LD_INT 4
6493: PUSH
6494: LD_VAR 0 3
6498: PUSH
6499: LD_INT 4
6501: ARRAY
6502: PUSH
6503: LD_INT 1
6505: PLUS
6506: PUSH
6507: EMPTY
6508: LIST
6509: LIST
6510: PPUSH
6511: CALL_OW 44
6515: PPUSH
6516: CALL 53789 0 3
6520: ST_TO_ADDR
// PlaceHumanInUnit ( tmp [ 4 ] [ tmp [ 4 ] ] , tmp [ 4 ] [ tmp [ 4 ] - 1 ] ) ;
6521: LD_VAR 0 3
6525: PUSH
6526: LD_INT 4
6528: ARRAY
6529: PUSH
6530: LD_VAR 0 3
6534: PUSH
6535: LD_INT 4
6537: ARRAY
6538: ARRAY
6539: PPUSH
6540: LD_VAR 0 3
6544: PUSH
6545: LD_INT 4
6547: ARRAY
6548: PUSH
6549: LD_VAR 0 3
6553: PUSH
6554: LD_INT 4
6556: ARRAY
6557: PUSH
6558: LD_INT 1
6560: MINUS
6561: ARRAY
6562: PPUSH
6563: CALL_OW 52
// coords := [ [ 148 , 140 ] ] ;
6567: LD_ADDR_VAR 0 5
6571: PUSH
6572: LD_INT 148
6574: PUSH
6575: LD_INT 140
6577: PUSH
6578: EMPTY
6579: LIST
6580: LIST
6581: PUSH
6582: EMPTY
6583: LIST
6584: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 4 ] , coords , flags ) ;
6585: LD_INT 1
6587: PPUSH
6588: LD_VAR 0 3
6592: PUSH
6593: LD_INT 4
6595: ARRAY
6596: PPUSH
6597: LD_VAR 0 5
6601: PPUSH
6602: LD_VAR 0 6
6606: PPUSH
6607: CALL 42449 0 4
// if gensher_active then
6611: LD_EXP 18
6615: IFFALSE 7021
// begin SayRadio ( Gensher , D10-Diet-1 ) ;
6617: LD_EXP 45
6621: PPUSH
6622: LD_STRING D10-Diet-1
6624: PPUSH
6625: CALL_OW 94
// for i = 1 to 2 do
6629: LD_ADDR_VAR 0 1
6633: PUSH
6634: DOUBLE
6635: LD_INT 1
6637: DEC
6638: ST_TO_ADDR
6639: LD_INT 2
6641: PUSH
6642: FOR_TO
6643: IFFALSE 6781
// begin uc_side := 2 ;
6645: LD_ADDR_OWVAR 20
6649: PUSH
6650: LD_INT 2
6652: ST_TO_ADDR
// uc_nation := 2 ;
6653: LD_ADDR_OWVAR 21
6657: PUSH
6658: LD_INT 2
6660: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
6661: LD_INT 13
6663: PPUSH
6664: LD_INT 3
6666: PPUSH
6667: LD_INT 5
6669: PPUSH
6670: LD_INT 29
6672: PPUSH
6673: LD_INT 100
6675: PPUSH
6676: CALL 53667 0 5
// un := CreateVehicle ;
6680: LD_ADDR_VAR 0 2
6684: PUSH
6685: CALL_OW 45
6689: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6690: LD_ADDR_VAR 0 3
6694: PUSH
6695: LD_VAR 0 3
6699: PPUSH
6700: LD_INT 5
6702: PUSH
6703: LD_VAR 0 3
6707: PUSH
6708: LD_INT 5
6710: ARRAY
6711: PUSH
6712: LD_INT 1
6714: PLUS
6715: PUSH
6716: EMPTY
6717: LIST
6718: LIST
6719: PPUSH
6720: LD_VAR 0 2
6724: PPUSH
6725: CALL 53789 0 3
6729: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6730: LD_VAR 0 2
6734: PPUSH
6735: LD_INT 0
6737: PPUSH
6738: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6742: LD_VAR 0 2
6746: PPUSH
6747: LD_INT 23
6749: PPUSH
6750: LD_INT 0
6752: PPUSH
6753: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6757: LD_VAR 0 2
6761: PPUSH
6762: LD_INT 85
6764: PPUSH
6765: LD_INT 152
6767: PPUSH
6768: CALL_OW 111
// wait ( 0 0$2 ) ;
6772: LD_INT 70
6774: PPUSH
6775: CALL_OW 67
// end ;
6779: GO 6642
6781: POP
6782: POP
// for i = 1 to [ 2 , 3 , 3 , 4 ] [ Difficulty ] do
6783: LD_ADDR_VAR 0 1
6787: PUSH
6788: DOUBLE
6789: LD_INT 1
6791: DEC
6792: ST_TO_ADDR
6793: LD_INT 2
6795: PUSH
6796: LD_INT 3
6798: PUSH
6799: LD_INT 3
6801: PUSH
6802: LD_INT 4
6804: PUSH
6805: EMPTY
6806: LIST
6807: LIST
6808: LIST
6809: LIST
6810: PUSH
6811: LD_OWVAR 67
6815: ARRAY
6816: PUSH
6817: FOR_TO
6818: IFFALSE 6975
// begin uc_side := 2 ;
6820: LD_ADDR_OWVAR 20
6824: PUSH
6825: LD_INT 2
6827: ST_TO_ADDR
// uc_nation := 2 ;
6828: LD_ADDR_OWVAR 21
6832: PUSH
6833: LD_INT 2
6835: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
6836: LD_INT 14
6838: PPUSH
6839: LD_INT 3
6841: PPUSH
6842: LD_INT 5
6844: PPUSH
6845: LD_INT 27
6847: PUSH
6848: LD_INT 28
6850: PUSH
6851: EMPTY
6852: LIST
6853: LIST
6854: PUSH
6855: LD_INT 1
6857: PPUSH
6858: LD_INT 2
6860: PPUSH
6861: CALL_OW 12
6865: ARRAY
6866: PPUSH
6867: LD_INT 100
6869: PPUSH
6870: CALL 53667 0 5
// un := CreateVehicle ;
6874: LD_ADDR_VAR 0 2
6878: PUSH
6879: CALL_OW 45
6883: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6884: LD_ADDR_VAR 0 3
6888: PUSH
6889: LD_VAR 0 3
6893: PPUSH
6894: LD_INT 5
6896: PUSH
6897: LD_VAR 0 3
6901: PUSH
6902: LD_INT 5
6904: ARRAY
6905: PUSH
6906: LD_INT 1
6908: PLUS
6909: PUSH
6910: EMPTY
6911: LIST
6912: LIST
6913: PPUSH
6914: LD_VAR 0 2
6918: PPUSH
6919: CALL 53789 0 3
6923: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6924: LD_VAR 0 2
6928: PPUSH
6929: LD_INT 0
6931: PPUSH
6932: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6936: LD_VAR 0 2
6940: PPUSH
6941: LD_INT 23
6943: PPUSH
6944: LD_INT 0
6946: PPUSH
6947: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6951: LD_VAR 0 2
6955: PPUSH
6956: LD_INT 85
6958: PPUSH
6959: LD_INT 152
6961: PPUSH
6962: CALL_OW 111
// wait ( 0 0$2 ) ;
6966: LD_INT 70
6968: PPUSH
6969: CALL_OW 67
// end ;
6973: GO 6817
6975: POP
6976: POP
// coords := [ [ 97 , 143 ] ] ;
6977: LD_ADDR_VAR 0 5
6981: PUSH
6982: LD_INT 97
6984: PUSH
6985: LD_INT 143
6987: PUSH
6988: EMPTY
6989: LIST
6990: LIST
6991: PUSH
6992: EMPTY
6993: LIST
6994: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 5 ] , coords , flags ) ;
6995: LD_INT 1
6997: PPUSH
6998: LD_VAR 0 3
7002: PUSH
7003: LD_INT 5
7005: ARRAY
7006: PPUSH
7007: LD_VAR 0 5
7011: PPUSH
7012: LD_VAR 0 6
7016: PPUSH
7017: CALL 42449 0 4
// end ; Wait ( 13 13$00 ) ;
7021: LD_INT 27300
7023: PPUSH
7024: CALL_OW 67
// tmp := [ ] ;
7028: LD_ADDR_VAR 0 3
7032: PUSH
7033: EMPTY
7034: ST_TO_ADDR
// w := 1 ;
7035: LD_ADDR_VAR 0 7
7039: PUSH
7040: LD_INT 1
7042: ST_TO_ADDR
// repeat tmp := [ ] ;
7043: LD_ADDR_VAR 0 3
7047: PUSH
7048: EMPTY
7049: ST_TO_ADDR
// if w mod 4 = 0 then
7050: LD_VAR 0 7
7054: PUSH
7055: LD_INT 4
7057: MOD
7058: PUSH
7059: LD_INT 0
7061: EQUAL
7062: IFFALSE 7149
// list := [ [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] else
7064: LD_ADDR_VAR 0 8
7068: PUSH
7069: LD_INT 11
7071: PUSH
7072: LD_INT 1
7074: PUSH
7075: LD_INT 2
7077: PUSH
7078: LD_INT 24
7080: PUSH
7081: EMPTY
7082: LIST
7083: LIST
7084: LIST
7085: LIST
7086: PUSH
7087: LD_INT 11
7089: PUSH
7090: LD_INT 1
7092: PUSH
7093: LD_INT 2
7095: PUSH
7096: LD_INT 24
7098: PUSH
7099: EMPTY
7100: LIST
7101: LIST
7102: LIST
7103: LIST
7104: PUSH
7105: LD_INT 11
7107: PUSH
7108: LD_INT 1
7110: PUSH
7111: LD_INT 2
7113: PUSH
7114: LD_INT 24
7116: PUSH
7117: EMPTY
7118: LIST
7119: LIST
7120: LIST
7121: LIST
7122: PUSH
7123: LD_INT 11
7125: PUSH
7126: LD_INT 1
7128: PUSH
7129: LD_INT 2
7131: PUSH
7132: LD_INT 24
7134: PUSH
7135: EMPTY
7136: LIST
7137: LIST
7138: LIST
7139: LIST
7140: PUSH
7141: EMPTY
7142: LIST
7143: LIST
7144: LIST
7145: LIST
7146: ST_TO_ADDR
7147: GO 7251
// list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] ;
7149: LD_ADDR_VAR 0 8
7153: PUSH
7154: LD_INT 14
7156: PUSH
7157: LD_INT 1
7159: PUSH
7160: LD_INT 2
7162: PUSH
7163: LD_INT 28
7165: PUSH
7166: EMPTY
7167: LIST
7168: LIST
7169: LIST
7170: LIST
7171: PUSH
7172: LD_INT 14
7174: PUSH
7175: LD_INT 1
7177: PUSH
7178: LD_INT 2
7180: PUSH
7181: LD_INT 25
7183: PUSH
7184: EMPTY
7185: LIST
7186: LIST
7187: LIST
7188: LIST
7189: PUSH
7190: LD_INT 14
7192: PUSH
7193: LD_INT 1
7195: PUSH
7196: LD_INT 2
7198: PUSH
7199: LD_INT 28
7201: PUSH
7202: EMPTY
7203: LIST
7204: LIST
7205: LIST
7206: LIST
7207: PUSH
7208: LD_INT 14
7210: PUSH
7211: LD_INT 1
7213: PUSH
7214: LD_INT 2
7216: PUSH
7217: LD_INT 29
7219: PUSH
7220: EMPTY
7221: LIST
7222: LIST
7223: LIST
7224: LIST
7225: PUSH
7226: LD_INT 11
7228: PUSH
7229: LD_INT 1
7231: PUSH
7232: LD_INT 2
7234: PUSH
7235: LD_INT 24
7237: PUSH
7238: EMPTY
7239: LIST
7240: LIST
7241: LIST
7242: LIST
7243: PUSH
7244: EMPTY
7245: LIST
7246: LIST
7247: LIST
7248: LIST
7249: LIST
7250: ST_TO_ADDR
// if w mod 3 = 0 then
7251: LD_VAR 0 7
7255: PUSH
7256: LD_INT 3
7258: MOD
7259: PUSH
7260: LD_INT 0
7262: EQUAL
7263: IFFALSE 7339
// list := ReplaceIn ( list , [ 1 , list [ i ] + 1 ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gatling_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] ] ) ;
7265: LD_ADDR_VAR 0 8
7269: PUSH
7270: LD_VAR 0 8
7274: PPUSH
7275: LD_INT 1
7277: PUSH
7278: LD_VAR 0 8
7282: PUSH
7283: LD_VAR 0 1
7287: ARRAY
7288: PUSH
7289: LD_INT 1
7291: PLUS
7292: PUSH
7293: EMPTY
7294: LIST
7295: LIST
7296: PPUSH
7297: LD_INT 14
7299: PUSH
7300: LD_INT 1
7302: PUSH
7303: LD_INT 2
7305: PUSH
7306: LD_INT 25
7308: PUSH
7309: LD_INT 28
7311: PUSH
7312: EMPTY
7313: LIST
7314: LIST
7315: PUSH
7316: LD_INT 1
7318: PPUSH
7319: LD_INT 2
7321: PPUSH
7322: CALL_OW 12
7326: ARRAY
7327: PUSH
7328: EMPTY
7329: LIST
7330: LIST
7331: LIST
7332: LIST
7333: PPUSH
7334: CALL 53789 0 3
7338: ST_TO_ADDR
// MC_SetProduceList ( 1 , list ) ;
7339: LD_INT 1
7341: PPUSH
7342: LD_VAR 0 8
7346: PPUSH
7347: CALL 42216 0 2
// if GetSide ( ar_dep_w ) = 2 then
7351: LD_INT 45
7353: PPUSH
7354: CALL_OW 255
7358: PUSH
7359: LD_INT 2
7361: EQUAL
7362: IFFALSE 7447
// begin list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] ] ;
7364: LD_ADDR_VAR 0 8
7368: PUSH
7369: LD_INT 14
7371: PUSH
7372: LD_INT 1
7374: PUSH
7375: LD_INT 2
7377: PUSH
7378: LD_INT 28
7380: PUSH
7381: EMPTY
7382: LIST
7383: LIST
7384: LIST
7385: LIST
7386: PUSH
7387: LD_INT 14
7389: PUSH
7390: LD_INT 1
7392: PUSH
7393: LD_INT 2
7395: PUSH
7396: LD_INT 27
7398: PUSH
7399: EMPTY
7400: LIST
7401: LIST
7402: LIST
7403: LIST
7404: PUSH
7405: LD_INT 14
7407: PUSH
7408: LD_INT 1
7410: PUSH
7411: LD_INT 2
7413: PUSH
7414: LD_INT 27
7416: PUSH
7417: EMPTY
7418: LIST
7419: LIST
7420: LIST
7421: LIST
7422: PUSH
7423: EMPTY
7424: LIST
7425: LIST
7426: LIST
7427: ST_TO_ADDR
// MC_SetProduceList ( 2 , list ) ;
7428: LD_INT 2
7430: PPUSH
7431: LD_VAR 0 8
7435: PPUSH
7436: CALL 42216 0 2
// wait ( 0 0$50 ) ;
7440: LD_INT 1750
7442: PPUSH
7443: CALL_OW 67
// end ; repeat wait ( 0 0$1 ) ;
7447: LD_INT 35
7449: PPUSH
7450: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ] ) >= 4 ;
7454: LD_EXP 69
7458: PUSH
7459: LD_INT 1
7461: ARRAY
7462: PPUSH
7463: LD_INT 3
7465: PUSH
7466: LD_INT 2
7468: PUSH
7469: LD_INT 34
7471: PUSH
7472: LD_INT 32
7474: PUSH
7475: EMPTY
7476: LIST
7477: LIST
7478: PUSH
7479: LD_INT 34
7481: PUSH
7482: LD_INT 88
7484: PUSH
7485: EMPTY
7486: LIST
7487: LIST
7488: PUSH
7489: EMPTY
7490: LIST
7491: LIST
7492: LIST
7493: PUSH
7494: EMPTY
7495: LIST
7496: LIST
7497: PPUSH
7498: CALL_OW 72
7502: PUSH
7503: LD_INT 4
7505: GREATEREQUAL
7506: IFFALSE 7447
// wait ( 0 0$10 ) ;
7508: LD_INT 350
7510: PPUSH
7511: CALL_OW 67
// tmp := UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ] ) ;
7515: LD_ADDR_VAR 0 3
7519: PUSH
7520: LD_EXP 69
7524: PUSH
7525: LD_INT 1
7527: ARRAY
7528: PPUSH
7529: LD_INT 3
7531: PUSH
7532: LD_INT 2
7534: PUSH
7535: LD_INT 34
7537: PUSH
7538: LD_INT 32
7540: PUSH
7541: EMPTY
7542: LIST
7543: LIST
7544: PUSH
7545: LD_INT 34
7547: PUSH
7548: LD_INT 88
7550: PUSH
7551: EMPTY
7552: LIST
7553: LIST
7554: PUSH
7555: EMPTY
7556: LIST
7557: LIST
7558: LIST
7559: PUSH
7560: EMPTY
7561: LIST
7562: LIST
7563: PPUSH
7564: CALL_OW 72
7568: ST_TO_ADDR
// if Prob ( 100 ) < 50 then
7569: LD_INT 100
7571: PPUSH
7572: CALL_OW 13
7576: PUSH
7577: LD_INT 50
7579: LESS
7580: IFFALSE 7613
// coords := [ [ 55 , 7 ] , [ 75 , 90 ] ] else
7582: LD_ADDR_VAR 0 5
7586: PUSH
7587: LD_INT 55
7589: PUSH
7590: LD_INT 7
7592: PUSH
7593: EMPTY
7594: LIST
7595: LIST
7596: PUSH
7597: LD_INT 75
7599: PUSH
7600: LD_INT 90
7602: PUSH
7603: EMPTY
7604: LIST
7605: LIST
7606: PUSH
7607: EMPTY
7608: LIST
7609: LIST
7610: ST_TO_ADDR
7611: GO 7642
// coords := [ [ 128 , 94 ] , [ 180 , 135 ] ] ;
7613: LD_ADDR_VAR 0 5
7617: PUSH
7618: LD_INT 128
7620: PUSH
7621: LD_INT 94
7623: PUSH
7624: EMPTY
7625: LIST
7626: LIST
7627: PUSH
7628: LD_INT 180
7630: PUSH
7631: LD_INT 135
7633: PUSH
7634: EMPTY
7635: LIST
7636: LIST
7637: PUSH
7638: EMPTY
7639: LIST
7640: LIST
7641: ST_TO_ADDR
// if w mod 4 = 0 then
7642: LD_VAR 0 7
7646: PUSH
7647: LD_INT 4
7649: MOD
7650: PUSH
7651: LD_INT 0
7653: EQUAL
7654: IFFALSE 7685
// coords := [ [ 91 , 58 ] , [ 117 , 107 ] ] ;
7656: LD_ADDR_VAR 0 5
7660: PUSH
7661: LD_INT 91
7663: PUSH
7664: LD_INT 58
7666: PUSH
7667: EMPTY
7668: LIST
7669: LIST
7670: PUSH
7671: LD_INT 117
7673: PUSH
7674: LD_INT 107
7676: PUSH
7677: EMPTY
7678: LIST
7679: LIST
7680: PUSH
7681: EMPTY
7682: LIST
7683: LIST
7684: ST_TO_ADDR
// ComAgressiveMove ( tmp , coords [ 1 ] , coords [ 2 ] ) ;
7685: LD_VAR 0 3
7689: PPUSH
7690: LD_VAR 0 5
7694: PUSH
7695: LD_INT 1
7697: ARRAY
7698: PPUSH
7699: LD_VAR 0 5
7703: PUSH
7704: LD_INT 2
7706: ARRAY
7707: PPUSH
7708: CALL_OW 114
// repeat wait ( 0 0$1 ) ;
7712: LD_INT 35
7714: PPUSH
7715: CALL_OW 67
// until UnitFilter ( tmp , [ f_hastask ] ) = 0 ;
7719: LD_VAR 0 3
7723: PPUSH
7724: LD_INT 60
7726: PUSH
7727: EMPTY
7728: LIST
7729: PPUSH
7730: CALL_OW 72
7734: PUSH
7735: LD_INT 0
7737: EQUAL
7738: IFFALSE 7712
// repeat wait ( 0 0$2 ) ;
7740: LD_INT 70
7742: PPUSH
7743: CALL_OW 67
// for i in tmp do
7747: LD_ADDR_VAR 0 1
7751: PUSH
7752: LD_VAR 0 3
7756: PUSH
7757: FOR_IN
7758: IFFALSE 7847
// if GetChassis ( i ) = ar_hovercraft then
7760: LD_VAR 0 1
7764: PPUSH
7765: CALL_OW 265
7769: PUSH
7770: LD_INT 11
7772: EQUAL
7773: IFFALSE 7811
// AttackHovercraft ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) else
7775: LD_VAR 0 1
7779: PPUSH
7780: LD_INT 22
7782: PUSH
7783: LD_INT 1
7785: PUSH
7786: EMPTY
7787: LIST
7788: LIST
7789: PPUSH
7790: CALL_OW 69
7794: PPUSH
7795: LD_VAR 0 1
7799: PPUSH
7800: CALL_OW 74
7804: PPUSH
7805: CALL 81735 0 2
7809: GO 7845
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
7811: LD_VAR 0 1
7815: PPUSH
7816: LD_INT 22
7818: PUSH
7819: LD_INT 1
7821: PUSH
7822: EMPTY
7823: LIST
7824: LIST
7825: PPUSH
7826: CALL_OW 69
7830: PPUSH
7831: LD_VAR 0 1
7835: PPUSH
7836: CALL_OW 74
7840: PPUSH
7841: CALL_OW 115
7845: GO 7757
7847: POP
7848: POP
// until not tmp ;
7849: LD_VAR 0 3
7853: NOT
7854: IFFALSE 7740
// wait ( rand ( 10 10$30 , 13 13$30 ) ) ;
7856: LD_INT 22050
7858: PPUSH
7859: LD_INT 28350
7861: PPUSH
7862: CALL_OW 12
7866: PPUSH
7867: CALL_OW 67
// w := w + 1 ;
7871: LD_ADDR_VAR 0 7
7875: PUSH
7876: LD_VAR 0 7
7880: PUSH
7881: LD_INT 1
7883: PLUS
7884: ST_TO_ADDR
// until IsDead ( ar_dep_n ) or not UnitFilter ( mc_bases [ 1 ] , [ f_btype , b_factory ] ) ;
7885: LD_INT 94
7887: PPUSH
7888: CALL_OW 301
7892: PUSH
7893: LD_EXP 50
7897: PUSH
7898: LD_INT 1
7900: ARRAY
7901: PPUSH
7902: LD_INT 30
7904: PUSH
7905: LD_INT 3
7907: PUSH
7908: EMPTY
7909: LIST
7910: LIST
7911: PPUSH
7912: CALL_OW 72
7916: NOT
7917: OR
7918: IFFALSE 7043
// end ;
7920: PPOPN 8
7922: END
// every 28 28$00 trigger ar_dep_e do var i , tmp , un , x ;
7923: LD_INT 204
7925: IFFALSE 8391
7927: GO 7929
7929: DISABLE
7930: LD_INT 0
7932: PPUSH
7933: PPUSH
7934: PPUSH
7935: PPUSH
// begin enable ;
7936: ENABLE
// wait ( rand ( 0 0$1 , 0 0$34 ) ) ;
7937: LD_INT 35
7939: PPUSH
7940: LD_INT 1190
7942: PPUSH
7943: CALL_OW 12
7947: PPUSH
7948: CALL_OW 67
// tmp := [ ] ;
7952: LD_ADDR_VAR 0 2
7956: PUSH
7957: EMPTY
7958: ST_TO_ADDR
// uc_side := 8 ;
7959: LD_ADDR_OWVAR 20
7963: PUSH
7964: LD_INT 8
7966: ST_TO_ADDR
// uc_nation := 2 ;
7967: LD_ADDR_OWVAR 21
7971: PUSH
7972: LD_INT 2
7974: ST_TO_ADDR
// InitHc ;
7975: CALL_OW 19
// for i = 1 to 3 do
7979: LD_ADDR_VAR 0 1
7983: PUSH
7984: DOUBLE
7985: LD_INT 1
7987: DEC
7988: ST_TO_ADDR
7989: LD_INT 3
7991: PUSH
7992: FOR_TO
7993: IFFALSE 8120
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
7995: LD_INT 13
7997: PUSH
7998: LD_INT 14
8000: PUSH
8001: EMPTY
8002: LIST
8003: LIST
8004: PUSH
8005: LD_INT 1
8007: PPUSH
8008: LD_INT 2
8010: PPUSH
8011: CALL_OW 12
8015: ARRAY
8016: PPUSH
8017: LD_INT 3
8019: PPUSH
8020: LD_INT 5
8022: PPUSH
8023: LD_INT 27
8025: PUSH
8026: LD_INT 28
8028: PUSH
8029: EMPTY
8030: LIST
8031: LIST
8032: PUSH
8033: LD_INT 1
8035: PPUSH
8036: LD_INT 2
8038: PPUSH
8039: CALL_OW 12
8043: ARRAY
8044: PPUSH
8045: LD_INT 100
8047: PPUSH
8048: CALL 53667 0 5
// un := CreateVehicle ;
8052: LD_ADDR_VAR 0 3
8056: PUSH
8057: CALL_OW 45
8061: ST_TO_ADDR
// SetDir ( un , 4 ) ;
8062: LD_VAR 0 3
8066: PPUSH
8067: LD_INT 4
8069: PPUSH
8070: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
8074: LD_VAR 0 3
8078: PPUSH
8079: LD_INT 15
8081: PPUSH
8082: LD_INT 0
8084: PPUSH
8085: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8089: LD_ADDR_VAR 0 2
8093: PUSH
8094: LD_VAR 0 2
8098: PPUSH
8099: LD_VAR 0 2
8103: PUSH
8104: LD_INT 1
8106: PLUS
8107: PPUSH
8108: LD_VAR 0 3
8112: PPUSH
8113: CALL_OW 1
8117: ST_TO_ADDR
// end ;
8118: GO 7992
8120: POP
8121: POP
// for i = 1 to 4 do
8122: LD_ADDR_VAR 0 1
8126: PUSH
8127: DOUBLE
8128: LD_INT 1
8130: DEC
8131: ST_TO_ADDR
8132: LD_INT 4
8134: PUSH
8135: FOR_TO
8136: IFFALSE 8207
// begin PrepareHuman ( false , 1 , 6 ) ;
8138: LD_INT 0
8140: PPUSH
8141: LD_INT 1
8143: PPUSH
8144: LD_INT 6
8146: PPUSH
8147: CALL_OW 380
// un := CreateHuman ;
8151: LD_ADDR_VAR 0 3
8155: PUSH
8156: CALL_OW 44
8160: ST_TO_ADDR
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
8161: LD_VAR 0 3
8165: PPUSH
8166: LD_INT 15
8168: PPUSH
8169: LD_INT 0
8171: PPUSH
8172: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8176: LD_ADDR_VAR 0 2
8180: PUSH
8181: LD_VAR 0 2
8185: PPUSH
8186: LD_VAR 0 2
8190: PUSH
8191: LD_INT 1
8193: PLUS
8194: PPUSH
8195: LD_VAR 0 3
8199: PPUSH
8200: CALL_OW 1
8204: ST_TO_ADDR
// end ;
8205: GO 8135
8207: POP
8208: POP
// wait ( 0 0$3 ) ;
8209: LD_INT 105
8211: PPUSH
8212: CALL_OW 67
// for i in tmp do
8216: LD_ADDR_VAR 0 1
8220: PUSH
8221: LD_VAR 0 2
8225: PUSH
8226: FOR_IN
8227: IFFALSE 8295
// if GetClass ( i ) = 1 or GetType ( i ) = unit_vehicle then
8229: LD_VAR 0 1
8233: PPUSH
8234: CALL_OW 257
8238: PUSH
8239: LD_INT 1
8241: EQUAL
8242: PUSH
8243: LD_VAR 0 1
8247: PPUSH
8248: CALL_OW 247
8252: PUSH
8253: LD_INT 2
8255: EQUAL
8256: OR
8257: IFFALSE 8293
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
8259: LD_VAR 0 1
8263: PPUSH
8264: LD_INT 81
8266: PUSH
8267: LD_INT 8
8269: PUSH
8270: EMPTY
8271: LIST
8272: LIST
8273: PPUSH
8274: CALL_OW 69
8278: PPUSH
8279: LD_VAR 0 1
8283: PPUSH
8284: CALL_OW 74
8288: PPUSH
8289: CALL_OW 115
8293: GO 8226
8295: POP
8296: POP
// repeat AddComAgressiveMove ( tmp , 210 , 178 ) ;
8297: LD_VAR 0 2
8301: PPUSH
8302: LD_INT 210
8304: PPUSH
8305: LD_INT 178
8307: PPUSH
8308: CALL_OW 174
// x := FilterUnitsInArea ( escape_area , [ f_side , 8 ] ) ;
8312: LD_ADDR_VAR 0 4
8316: PUSH
8317: LD_INT 10
8319: PPUSH
8320: LD_INT 22
8322: PUSH
8323: LD_INT 8
8325: PUSH
8326: EMPTY
8327: LIST
8328: LIST
8329: PPUSH
8330: CALL_OW 70
8334: ST_TO_ADDR
// if x then
8335: LD_VAR 0 4
8339: IFFALSE 8367
// for i in x do
8341: LD_ADDR_VAR 0 1
8345: PUSH
8346: LD_VAR 0 4
8350: PUSH
8351: FOR_IN
8352: IFFALSE 8365
// RemoveUnit ( i ) ;
8354: LD_VAR 0 1
8358: PPUSH
8359: CALL_OW 64
8363: GO 8351
8365: POP
8366: POP
// wait ( 0 0$1 ) ;
8367: LD_INT 35
8369: PPUSH
8370: CALL_OW 67
// until not FilterAllUnits ( [ f_side , 8 ] ) ;
8374: LD_INT 22
8376: PUSH
8377: LD_INT 8
8379: PUSH
8380: EMPTY
8381: LIST
8382: LIST
8383: PPUSH
8384: CALL_OW 69
8388: NOT
8389: IFFALSE 8297
// end ;
8391: PPOPN 4
8393: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
8394: LD_INT 22
8396: PUSH
8397: LD_INT 2
8399: PUSH
8400: EMPTY
8401: LIST
8402: LIST
8403: PUSH
8404: LD_INT 34
8406: PUSH
8407: LD_INT 31
8409: PUSH
8410: EMPTY
8411: LIST
8412: LIST
8413: PUSH
8414: LD_INT 3
8416: PUSH
8417: LD_INT 24
8419: PUSH
8420: LD_INT 1000
8422: PUSH
8423: EMPTY
8424: LIST
8425: LIST
8426: PUSH
8427: EMPTY
8428: LIST
8429: LIST
8430: PUSH
8431: EMPTY
8432: LIST
8433: LIST
8434: LIST
8435: PPUSH
8436: CALL_OW 69
8440: IFFALSE 8543
8442: GO 8444
8444: DISABLE
// begin if IsOk ( ar_dep_w ) and GetSide ( ar_dep_w ) then
8445: LD_INT 45
8447: PPUSH
8448: CALL_OW 302
8452: PUSH
8453: LD_INT 45
8455: PPUSH
8456: CALL_OW 255
8460: AND
8461: IFFALSE 8504
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 18 , 8 ) else
8463: LD_INT 22
8465: PUSH
8466: LD_INT 2
8468: PUSH
8469: EMPTY
8470: LIST
8471: LIST
8472: PUSH
8473: LD_INT 34
8475: PUSH
8476: LD_INT 31
8478: PUSH
8479: EMPTY
8480: LIST
8481: LIST
8482: PUSH
8483: EMPTY
8484: LIST
8485: LIST
8486: PPUSH
8487: CALL_OW 69
8491: PPUSH
8492: LD_INT 18
8494: PPUSH
8495: LD_INT 8
8497: PPUSH
8498: CALL_OW 111
8502: GO 8543
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 106 , 14 ) ;
8504: LD_INT 22
8506: PUSH
8507: LD_INT 2
8509: PUSH
8510: EMPTY
8511: LIST
8512: LIST
8513: PUSH
8514: LD_INT 34
8516: PUSH
8517: LD_INT 31
8519: PUSH
8520: EMPTY
8521: LIST
8522: LIST
8523: PUSH
8524: EMPTY
8525: LIST
8526: LIST
8527: PPUSH
8528: CALL_OW 69
8532: PPUSH
8533: LD_INT 106
8535: PPUSH
8536: LD_INT 14
8538: PPUSH
8539: CALL_OW 111
// end ; end_of_file
8543: END
// export function Action ; var tmp , p , radar , sols , i ; begin
8544: LD_INT 0
8546: PPUSH
8547: PPUSH
8548: PPUSH
8549: PPUSH
8550: PPUSH
8551: PPUSH
// InGameOn ;
8552: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
8556: LD_EXP 21
8560: PPUSH
8561: CALL_OW 87
// SetAttitude ( 2 , 1 , att_friend , true ) ;
8565: LD_INT 2
8567: PPUSH
8568: LD_INT 1
8570: PPUSH
8571: LD_INT 1
8573: PPUSH
8574: LD_INT 1
8576: PPUSH
8577: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) ;
8581: LD_ADDR_VAR 0 2
8585: PUSH
8586: LD_INT 22
8588: PUSH
8589: LD_INT 1
8591: PUSH
8592: EMPTY
8593: LIST
8594: LIST
8595: PUSH
8596: LD_INT 25
8598: PUSH
8599: LD_INT 1
8601: PUSH
8602: EMPTY
8603: LIST
8604: LIST
8605: PUSH
8606: EMPTY
8607: LIST
8608: LIST
8609: PPUSH
8610: CALL_OW 69
8614: ST_TO_ADDR
// radar := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_radar ] ] ) [ 1 ] ;
8615: LD_ADDR_VAR 0 4
8619: PUSH
8620: LD_INT 22
8622: PUSH
8623: LD_INT 1
8625: PUSH
8626: EMPTY
8627: LIST
8628: LIST
8629: PUSH
8630: LD_INT 34
8632: PUSH
8633: LD_INT 11
8635: PUSH
8636: EMPTY
8637: LIST
8638: LIST
8639: PUSH
8640: EMPTY
8641: LIST
8642: LIST
8643: PPUSH
8644: CALL_OW 69
8648: PUSH
8649: LD_INT 1
8651: ARRAY
8652: ST_TO_ADDR
// for i = 1 to tmp do
8653: LD_ADDR_VAR 0 6
8657: PUSH
8658: DOUBLE
8659: LD_INT 1
8661: DEC
8662: ST_TO_ADDR
8663: LD_VAR 0 2
8667: PUSH
8668: FOR_TO
8669: IFFALSE 8716
// begin if i = 5 then
8671: LD_VAR 0 6
8675: PUSH
8676: LD_INT 5
8678: EQUAL
8679: IFFALSE 8683
// break ;
8681: GO 8716
// sols := Replace ( sols , i , tmp [ i ] ) ;
8683: LD_ADDR_VAR 0 5
8687: PUSH
8688: LD_VAR 0 5
8692: PPUSH
8693: LD_VAR 0 6
8697: PPUSH
8698: LD_VAR 0 2
8702: PUSH
8703: LD_VAR 0 6
8707: ARRAY
8708: PPUSH
8709: CALL_OW 1
8713: ST_TO_ADDR
// end ;
8714: GO 8668
8716: POP
8717: POP
// tmp := ar_force_tmp ;
8718: LD_ADDR_VAR 0 2
8722: PUSH
8723: LD_EXP 40
8727: ST_TO_ADDR
// PlaceUnitXY ( tmp [ 1 ] , 108 , 139 , false ) ;
8728: LD_VAR 0 2
8732: PUSH
8733: LD_INT 1
8735: ARRAY
8736: PPUSH
8737: LD_INT 108
8739: PPUSH
8740: LD_INT 139
8742: PPUSH
8743: LD_INT 0
8745: PPUSH
8746: CALL_OW 48
// ComTurnUnit ( tmp [ 1 ] , JMM ) ;
8750: LD_VAR 0 2
8754: PUSH
8755: LD_INT 1
8757: ARRAY
8758: PPUSH
8759: LD_EXP 21
8763: PPUSH
8764: CALL_OW 119
// PlaceUnitXY ( tmp [ 2 ] , 114 , 132 , false ) ;
8768: LD_VAR 0 2
8772: PUSH
8773: LD_INT 2
8775: ARRAY
8776: PPUSH
8777: LD_INT 114
8779: PPUSH
8780: LD_INT 132
8782: PPUSH
8783: LD_INT 0
8785: PPUSH
8786: CALL_OW 48
// PlaceUnitXY ( tmp [ 3 ] , 115 , 132 , false ) ;
8790: LD_VAR 0 2
8794: PUSH
8795: LD_INT 3
8797: ARRAY
8798: PPUSH
8799: LD_INT 115
8801: PPUSH
8802: LD_INT 132
8804: PPUSH
8805: LD_INT 0
8807: PPUSH
8808: CALL_OW 48
// ComHold ( [ tmp [ 2 ] , tmp [ 3 ] ] ) ;
8812: LD_VAR 0 2
8816: PUSH
8817: LD_INT 2
8819: ARRAY
8820: PUSH
8821: LD_VAR 0 2
8825: PUSH
8826: LD_INT 3
8828: ARRAY
8829: PUSH
8830: EMPTY
8831: LIST
8832: LIST
8833: PPUSH
8834: CALL_OW 140
// ComMoveXY ( radar , 83 , 123 ) ;
8838: LD_VAR 0 4
8842: PPUSH
8843: LD_INT 83
8845: PPUSH
8846: LD_INT 123
8848: PPUSH
8849: CALL_OW 111
// Wait ( 0 0$01 ) ;
8853: LD_INT 35
8855: PPUSH
8856: CALL_OW 67
// CenterOnXY ( 90 , 144 ) ;
8860: LD_INT 90
8862: PPUSH
8863: LD_INT 144
8865: PPUSH
8866: CALL_OW 84
// ComMoveXY ( sols , 88 , 129 ) ;
8870: LD_VAR 0 5
8874: PPUSH
8875: LD_INT 88
8877: PPUSH
8878: LD_INT 129
8880: PPUSH
8881: CALL_OW 111
// p := [ [ 92 , 131 ] , [ 88 , 127 ] , [ 91 , 132 ] , [ 92 , 134 ] ] ;
8885: LD_ADDR_VAR 0 3
8889: PUSH
8890: LD_INT 92
8892: PUSH
8893: LD_INT 131
8895: PUSH
8896: EMPTY
8897: LIST
8898: LIST
8899: PUSH
8900: LD_INT 88
8902: PUSH
8903: LD_INT 127
8905: PUSH
8906: EMPTY
8907: LIST
8908: LIST
8909: PUSH
8910: LD_INT 91
8912: PUSH
8913: LD_INT 132
8915: PUSH
8916: EMPTY
8917: LIST
8918: LIST
8919: PUSH
8920: LD_INT 92
8922: PUSH
8923: LD_INT 134
8925: PUSH
8926: EMPTY
8927: LIST
8928: LIST
8929: PUSH
8930: EMPTY
8931: LIST
8932: LIST
8933: LIST
8934: LIST
8935: ST_TO_ADDR
// for i = 1 to sols do
8936: LD_ADDR_VAR 0 6
8940: PUSH
8941: DOUBLE
8942: LD_INT 1
8944: DEC
8945: ST_TO_ADDR
8946: LD_VAR 0 5
8950: PUSH
8951: FOR_TO
8952: IFFALSE 9025
// begin AddComMoveXY ( sols [ i ] , p [ i ] [ 1 ] , p [ i ] [ 2 ] ) ;
8954: LD_VAR 0 5
8958: PUSH
8959: LD_VAR 0 6
8963: ARRAY
8964: PPUSH
8965: LD_VAR 0 3
8969: PUSH
8970: LD_VAR 0 6
8974: ARRAY
8975: PUSH
8976: LD_INT 1
8978: ARRAY
8979: PPUSH
8980: LD_VAR 0 3
8984: PUSH
8985: LD_VAR 0 6
8989: ARRAY
8990: PUSH
8991: LD_INT 2
8993: ARRAY
8994: PPUSH
8995: CALL_OW 171
// AddComCrawl ( sols [ i ] ) ;
8999: LD_VAR 0 5
9003: PUSH
9004: LD_VAR 0 6
9008: ARRAY
9009: PPUSH
9010: CALL_OW 197
// AddComHold ( sols ) ;
9014: LD_VAR 0 5
9018: PPUSH
9019: CALL_OW 200
// end ;
9023: GO 8951
9025: POP
9026: POP
// repeat wait ( 0 0$1 ) ;
9027: LD_INT 35
9029: PPUSH
9030: CALL_OW 67
// until GetDistUnitXY ( sols [ 1 ] , 92 , 131 ) < 4 ;
9034: LD_VAR 0 5
9038: PUSH
9039: LD_INT 1
9041: ARRAY
9042: PPUSH
9043: LD_INT 92
9045: PPUSH
9046: LD_INT 131
9048: PPUSH
9049: CALL_OW 297
9053: PUSH
9054: LD_INT 4
9056: LESS
9057: IFFALSE 9027
// CenterOnXY ( 96 , 139 ) ;
9059: LD_INT 96
9061: PPUSH
9062: LD_INT 139
9064: PPUSH
9065: CALL_OW 84
// wait ( 0 0$3 ) ;
9069: LD_INT 105
9071: PPUSH
9072: CALL_OW 67
// PlaceSeeing ( 111 , 135 , 1 , - 25 ) ;
9076: LD_INT 111
9078: PPUSH
9079: LD_INT 135
9081: PPUSH
9082: LD_INT 1
9084: PPUSH
9085: LD_INT 25
9087: NEG
9088: PPUSH
9089: CALL_OW 330
// ComMoveXY ( tmp [ 2 ] , GetX ( tmp [ 1 ] ) + 3 , GetY ( tmp [ 1 ] ) ) ;
9093: LD_VAR 0 2
9097: PUSH
9098: LD_INT 2
9100: ARRAY
9101: PPUSH
9102: LD_VAR 0 2
9106: PUSH
9107: LD_INT 1
9109: ARRAY
9110: PPUSH
9111: CALL_OW 250
9115: PUSH
9116: LD_INT 3
9118: PLUS
9119: PPUSH
9120: LD_VAR 0 2
9124: PUSH
9125: LD_INT 1
9127: ARRAY
9128: PPUSH
9129: CALL_OW 251
9133: PPUSH
9134: CALL_OW 111
// ComEnterUnit ( tmp [ 3 ] , ar_dep_s ) ;
9138: LD_VAR 0 2
9142: PUSH
9143: LD_INT 3
9145: ARRAY
9146: PPUSH
9147: LD_INT 7
9149: PPUSH
9150: CALL_OW 120
// AddComTurnUnit ( tmp [ 2 ] , tmp [ 1 ] ) ;
9154: LD_VAR 0 2
9158: PUSH
9159: LD_INT 2
9161: ARRAY
9162: PPUSH
9163: LD_VAR 0 2
9167: PUSH
9168: LD_INT 1
9170: ARRAY
9171: PPUSH
9172: CALL_OW 179
// repeat wait ( 0 0$1 ) ;
9176: LD_INT 35
9178: PPUSH
9179: CALL_OW 67
// until GetDistUnits ( tmp [ 1 ] , tmp [ 2 ] ) < 5 ;
9183: LD_VAR 0 2
9187: PUSH
9188: LD_INT 1
9190: ARRAY
9191: PPUSH
9192: LD_VAR 0 2
9196: PUSH
9197: LD_INT 2
9199: ARRAY
9200: PPUSH
9201: CALL_OW 296
9205: PUSH
9206: LD_INT 5
9208: LESS
9209: IFFALSE 9176
// ComTurnUnit ( tmp [ 1 ] , tmp [ 2 ] ) ;
9211: LD_VAR 0 2
9215: PUSH
9216: LD_INT 1
9218: ARRAY
9219: PPUSH
9220: LD_VAR 0 2
9224: PUSH
9225: LD_INT 2
9227: ARRAY
9228: PPUSH
9229: CALL_OW 119
// Say ( tmp [ 1 ] , D1a-Merc1-1 ) ;
9233: LD_VAR 0 2
9237: PUSH
9238: LD_INT 1
9240: ARRAY
9241: PPUSH
9242: LD_STRING D1a-Merc1-1
9244: PPUSH
9245: CALL_OW 88
// Say ( tmp [ 2 ] , D1a-FMerc2-1 ) ;
9249: LD_VAR 0 2
9253: PUSH
9254: LD_INT 2
9256: ARRAY
9257: PPUSH
9258: LD_STRING D1a-FMerc2-1
9260: PPUSH
9261: CALL_OW 88
// ComHeal ( tmp [ 2 ] , tmp [ 1 ] ) ;
9265: LD_VAR 0 2
9269: PUSH
9270: LD_INT 2
9272: ARRAY
9273: PPUSH
9274: LD_VAR 0 2
9278: PUSH
9279: LD_INT 1
9281: ARRAY
9282: PPUSH
9283: CALL_OW 128
// SetLives ( tmp [ 1 ] , 500 ) ;
9287: LD_VAR 0 2
9291: PUSH
9292: LD_INT 1
9294: ARRAY
9295: PPUSH
9296: LD_INT 500
9298: PPUSH
9299: CALL_OW 234
// wait ( 0 0$2 ) ;
9303: LD_INT 70
9305: PPUSH
9306: CALL_OW 67
// SetLives ( tmp [ 1 ] , 2 ) ;
9310: LD_VAR 0 2
9314: PUSH
9315: LD_INT 1
9317: ARRAY
9318: PPUSH
9319: LD_INT 2
9321: PPUSH
9322: CALL_OW 234
// wait ( 0 0$0.3 ) ;
9326: LD_INT 10
9328: PPUSH
9329: CALL_OW 67
// ForceSay ( tmp [ 1 ] , D1a-Merc1-2 ) ;
9333: LD_VAR 0 2
9337: PUSH
9338: LD_INT 1
9340: ARRAY
9341: PPUSH
9342: LD_STRING D1a-Merc1-2
9344: PPUSH
9345: CALL_OW 91
// wait ( 0 0$0.2 ) ;
9349: LD_INT 7
9351: PPUSH
9352: CALL_OW 67
// KillUnit ( tmp [ 1 ] ) ;
9356: LD_VAR 0 2
9360: PUSH
9361: LD_INT 1
9363: ARRAY
9364: PPUSH
9365: CALL_OW 66
// ComMoveToArea ( tmp [ 2 ] , escape_area ) ;
9369: LD_VAR 0 2
9373: PUSH
9374: LD_INT 2
9376: ARRAY
9377: PPUSH
9378: LD_INT 10
9380: PPUSH
9381: CALL_OW 113
// Say ( tmp [ 2 ] , D1a-FMerc2-2 ) ;
9385: LD_VAR 0 2
9389: PUSH
9390: LD_INT 2
9392: ARRAY
9393: PPUSH
9394: LD_STRING D1a-FMerc2-2
9396: PPUSH
9397: CALL_OW 88
// wait ( 0 0$1 ) ;
9401: LD_INT 35
9403: PPUSH
9404: CALL_OW 67
// CenterOnUnits ( ar_dep_s ) ;
9408: LD_INT 7
9410: PPUSH
9411: CALL_OW 85
// wait ( 0 0$2 ) ;
9415: LD_INT 70
9417: PPUSH
9418: CALL_OW 67
// ForceSay ( Saliba , D1a-Saliba-1 ) ;
9422: LD_EXP 44
9426: PPUSH
9427: LD_STRING D1a-Saliba-1
9429: PPUSH
9430: CALL_OW 91
// KillUnit ( Saliba ) ;
9434: LD_EXP 44
9438: PPUSH
9439: CALL_OW 66
// ComExitBuilding ( tmp [ 3 ] ) ;
9443: LD_VAR 0 2
9447: PUSH
9448: LD_INT 3
9450: ARRAY
9451: PPUSH
9452: CALL_OW 122
// CenterOnUnits ( JMM ) ;
9456: LD_EXP 21
9460: PPUSH
9461: CALL_OW 85
// wait ( 0 0$1 ) ;
9465: LD_INT 35
9467: PPUSH
9468: CALL_OW 67
// ComMoveXY ( sols , 88 , 141 ) ;
9472: LD_VAR 0 5
9476: PPUSH
9477: LD_INT 88
9479: PPUSH
9480: LD_INT 141
9482: PPUSH
9483: CALL_OW 111
// AddComWait ( sols , 0 0$2 ) ;
9487: LD_VAR 0 5
9491: PPUSH
9492: LD_INT 70
9494: PPUSH
9495: CALL_OW 202
// wait ( 0 0$2 ) ;
9499: LD_INT 70
9501: PPUSH
9502: CALL_OW 67
// SetAttitude ( 2 , 1 , att_enemy , true ) ;
9506: LD_INT 2
9508: PPUSH
9509: LD_INT 1
9511: PPUSH
9512: LD_INT 2
9514: PPUSH
9515: LD_INT 1
9517: PPUSH
9518: CALL_OW 80
// InGameOff ;
9522: CALL_OW 9
// ComWalk ( sols ) ;
9526: LD_VAR 0 5
9530: PPUSH
9531: CALL_OW 138
// ChangeMissionObjectives ( M1 ) ;
9535: LD_STRING M1
9537: PPUSH
9538: CALL_OW 337
// game_speed := 4 ;
9542: LD_ADDR_OWVAR 65
9546: PUSH
9547: LD_INT 4
9549: ST_TO_ADDR
// RemoveSeeing ( 111 , 135 , 1 ) ;
9550: LD_INT 111
9552: PPUSH
9553: LD_INT 135
9555: PPUSH
9556: LD_INT 1
9558: PPUSH
9559: CALL_OW 331
// SaveForQuickRestart ;
9563: CALL_OW 22
// ar_run := true ;
9567: LD_ADDR_EXP 5
9571: PUSH
9572: LD_INT 1
9574: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9575: LD_INT 35
9577: PPUSH
9578: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 1 ] , [ f_dist , ar_dep_s , 10 ] ] ) or GetLives ( ar_dep_s ) < 999 ;
9582: LD_INT 22
9584: PUSH
9585: LD_INT 1
9587: PUSH
9588: EMPTY
9589: LIST
9590: LIST
9591: PUSH
9592: LD_INT 91
9594: PUSH
9595: LD_INT 7
9597: PUSH
9598: LD_INT 10
9600: PUSH
9601: EMPTY
9602: LIST
9603: LIST
9604: LIST
9605: PUSH
9606: EMPTY
9607: LIST
9608: LIST
9609: PPUSH
9610: CALL_OW 69
9614: PUSH
9615: LD_INT 7
9617: PPUSH
9618: CALL_OW 256
9622: PUSH
9623: LD_INT 999
9625: LESS
9626: OR
9627: IFFALSE 9575
// if GetSide ( ar_dep_s ) = 2 then
9629: LD_INT 7
9631: PPUSH
9632: CALL_OW 255
9636: PUSH
9637: LD_INT 2
9639: EQUAL
9640: IFFALSE 9652
// SetSide ( ar_dep_s , 1 ) ;
9642: LD_INT 7
9644: PPUSH
9645: LD_INT 1
9647: PPUSH
9648: CALL_OW 235
// end ;
9652: LD_VAR 0 1
9656: RET
// every 0 0$2 trigger ar_run do var i , tmp , k ;
9657: LD_EXP 5
9661: IFFALSE 10021
9663: GO 9665
9665: DISABLE
9666: LD_INT 0
9668: PPUSH
9669: PPUSH
9670: PPUSH
// begin tmp := ar_force_tmp ^ UnitFilter ( ar_force_south , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ) ;
9671: LD_ADDR_VAR 0 2
9675: PUSH
9676: LD_EXP 40
9680: PUSH
9681: LD_EXP 36
9685: PPUSH
9686: LD_INT 2
9688: PUSH
9689: LD_INT 21
9691: PUSH
9692: LD_INT 2
9694: PUSH
9695: EMPTY
9696: LIST
9697: LIST
9698: PUSH
9699: LD_INT 21
9701: PUSH
9702: LD_INT 1
9704: PUSH
9705: EMPTY
9706: LIST
9707: LIST
9708: PUSH
9709: EMPTY
9710: LIST
9711: LIST
9712: LIST
9713: PPUSH
9714: CALL_OW 72
9718: ADD
9719: ST_TO_ADDR
// SetSide ( tmp , 5 ) ;
9720: LD_VAR 0 2
9724: PPUSH
9725: LD_INT 5
9727: PPUSH
9728: CALL_OW 235
// ChangeSideFog ( 5 , 1 ) ;
9732: LD_INT 5
9734: PPUSH
9735: LD_INT 1
9737: PPUSH
9738: CALL_OW 343
// k := 1 ;
9742: LD_ADDR_VAR 0 3
9746: PUSH
9747: LD_INT 1
9749: ST_TO_ADDR
// for i in tmp do
9750: LD_ADDR_VAR 0 1
9754: PUSH
9755: LD_VAR 0 2
9759: PUSH
9760: FOR_IN
9761: IFFALSE 9846
// begin if IsInUnit ( i ) then
9763: LD_VAR 0 1
9767: PPUSH
9768: CALL_OW 310
9772: IFFALSE 9783
// ComExitBuilding ( i ) ;
9774: LD_VAR 0 1
9778: PPUSH
9779: CALL_OW 122
// if GetClass ( i ) = 3 then
9783: LD_VAR 0 1
9787: PPUSH
9788: CALL_OW 257
9792: PUSH
9793: LD_INT 3
9795: EQUAL
9796: IFFALSE 9832
// begin AddComEnterUnit ( i , ar_vehicles_tmp [ k ] ) ;
9798: LD_VAR 0 1
9802: PPUSH
9803: LD_EXP 41
9807: PUSH
9808: LD_VAR 0 3
9812: ARRAY
9813: PPUSH
9814: CALL_OW 180
// k := k + 1 ;
9818: LD_ADDR_VAR 0 3
9822: PUSH
9823: LD_VAR 0 3
9827: PUSH
9828: LD_INT 1
9830: PLUS
9831: ST_TO_ADDR
// end ; AddComMoveToArea ( i , escape_area ) ;
9832: LD_VAR 0 1
9836: PPUSH
9837: LD_INT 10
9839: PPUSH
9840: CALL_OW 173
// end ;
9844: GO 9760
9846: POP
9847: POP
// ar_patrol := true ;
9848: LD_ADDR_EXP 7
9852: PUSH
9853: LD_INT 1
9855: ST_TO_ADDR
// repeat wait ( 0 0$0.3 ) ;
9856: LD_INT 10
9858: PPUSH
9859: CALL_OW 67
// for i in tmp do
9863: LD_ADDR_VAR 0 1
9867: PUSH
9868: LD_VAR 0 2
9872: PUSH
9873: FOR_IN
9874: IFFALSE 9902
// if not HasTask ( i ) then
9876: LD_VAR 0 1
9880: PPUSH
9881: CALL_OW 314
9885: NOT
9886: IFFALSE 9900
// ComMoveToArea ( i , escape_area ) ;
9888: LD_VAR 0 1
9892: PPUSH
9893: LD_INT 10
9895: PPUSH
9896: CALL_OW 113
9900: GO 9873
9902: POP
9903: POP
// k := UnitFilter ( tmp , [ f_inarea , escape_area ] ) ;
9904: LD_ADDR_VAR 0 3
9908: PUSH
9909: LD_VAR 0 2
9913: PPUSH
9914: LD_INT 95
9916: PUSH
9917: LD_INT 10
9919: PUSH
9920: EMPTY
9921: LIST
9922: LIST
9923: PPUSH
9924: CALL_OW 72
9928: ST_TO_ADDR
// if k then
9929: LD_VAR 0 3
9933: IFFALSE 10002
// for i in k do
9935: LD_ADDR_VAR 0 1
9939: PUSH
9940: LD_VAR 0 3
9944: PUSH
9945: FOR_IN
9946: IFFALSE 10000
// begin if IsInUnit ( i ) then
9948: LD_VAR 0 1
9952: PPUSH
9953: CALL_OW 310
9957: IFFALSE 9973
// RemoveUnit ( IsInUnit ( i ) ) ;
9959: LD_VAR 0 1
9963: PPUSH
9964: CALL_OW 310
9968: PPUSH
9969: CALL_OW 64
// RemoveUnit ( i ) ;
9973: LD_VAR 0 1
9977: PPUSH
9978: CALL_OW 64
// tmp := tmp diff i ;
9982: LD_ADDR_VAR 0 2
9986: PUSH
9987: LD_VAR 0 2
9991: PUSH
9992: LD_VAR 0 1
9996: DIFF
9997: ST_TO_ADDR
// end ;
9998: GO 9945
10000: POP
10001: POP
// until tmp = [ ] ;
10002: LD_VAR 0 2
10006: PUSH
10007: EMPTY
10008: EQUAL
10009: IFFALSE 9856
// ChangeSideFog ( 5 , 5 ) ;
10011: LD_INT 5
10013: PPUSH
10014: LD_INT 5
10016: PPUSH
10017: CALL_OW 343
// end ;
10021: PPOPN 3
10023: END
// every 0 0$03 trigger ar_patrol do var i , un , veh ;
10024: LD_EXP 7
10028: IFFALSE 10318
10030: GO 10032
10032: DISABLE
10033: LD_INT 0
10035: PPUSH
10036: PPUSH
10037: PPUSH
// begin uc_side := 2 ;
10038: LD_ADDR_OWVAR 20
10042: PUSH
10043: LD_INT 2
10045: ST_TO_ADDR
// uc_nation := 2 ;
10046: LD_ADDR_OWVAR 21
10050: PUSH
10051: LD_INT 2
10053: ST_TO_ADDR
// InitHc ;
10054: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
10058: LD_INT 1
10060: PPUSH
10061: LD_INT 1
10063: PPUSH
10064: LD_INT 6
10066: PPUSH
10067: CALL_OW 380
// un := CreateHuman ;
10071: LD_ADDR_VAR 0 2
10075: PUSH
10076: CALL_OW 44
10080: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_combustion , control_manual , ar_gun , 98 ) ;
10081: LD_INT 14
10083: PPUSH
10084: LD_INT 1
10086: PPUSH
10087: LD_INT 1
10089: PPUSH
10090: LD_INT 27
10092: PPUSH
10093: LD_INT 98
10095: PPUSH
10096: CALL 53667 0 5
// veh := CreateVehicle ;
10100: LD_ADDR_VAR 0 3
10104: PUSH
10105: CALL_OW 45
10109: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
10110: LD_VAR 0 3
10114: PPUSH
10115: LD_INT 4
10117: PPUSH
10118: CALL_OW 233
// PlaceUnitXY ( veh , 179 , 135 , false ) ;
10122: LD_VAR 0 3
10126: PPUSH
10127: LD_INT 179
10129: PPUSH
10130: LD_INT 135
10132: PPUSH
10133: LD_INT 0
10135: PPUSH
10136: CALL_OW 48
// PlaceHumanInUnit ( un , veh ) ;
10140: LD_VAR 0 2
10144: PPUSH
10145: LD_VAR 0 3
10149: PPUSH
10150: CALL_OW 52
// ComMoveXY ( un , 126 , 133 ) ;
10154: LD_VAR 0 2
10158: PPUSH
10159: LD_INT 126
10161: PPUSH
10162: LD_INT 133
10164: PPUSH
10165: CALL_OW 111
// repeat wait ( 0 0$0.3 ) ;
10169: LD_INT 10
10171: PPUSH
10172: CALL_OW 67
// until See ( 1 , veh ) or GetDistUnits ( veh , ar_dep_s ) < 9 ;
10176: LD_INT 1
10178: PPUSH
10179: LD_VAR 0 3
10183: PPUSH
10184: CALL_OW 292
10188: PUSH
10189: LD_VAR 0 3
10193: PPUSH
10194: LD_INT 7
10196: PPUSH
10197: CALL_OW 296
10201: PUSH
10202: LD_INT 9
10204: LESS
10205: OR
10206: IFFALSE 10169
// ComHold ( veh ) ;
10208: LD_VAR 0 3
10212: PPUSH
10213: CALL_OW 140
// Say ( un , D2aa-Ar1-1 ) ;
10217: LD_VAR 0 2
10221: PPUSH
10222: LD_STRING D2aa-Ar1-1
10224: PPUSH
10225: CALL_OW 88
// ComMoveXY ( un , 177 , 96 ) ;
10229: LD_VAR 0 2
10233: PPUSH
10234: LD_INT 177
10236: PPUSH
10237: LD_INT 96
10239: PPUSH
10240: CALL_OW 111
// AddComExitVehicle ( un ) ;
10244: LD_VAR 0 2
10248: PPUSH
10249: CALL_OW 181
// repeat wait ( 0 0$1 ) ;
10253: LD_INT 35
10255: PPUSH
10256: CALL_OW 67
// until GetDistUnits ( un , ar_dep_e ) < 15 ;
10260: LD_VAR 0 2
10264: PPUSH
10265: LD_INT 204
10267: PPUSH
10268: CALL_OW 296
10272: PUSH
10273: LD_INT 15
10275: LESS
10276: IFFALSE 10253
// mc_bases := ReplaceIn ( mc_bases , [ 3 , mc_bases [ 3 ] + 1 ] , un ) ;
10278: LD_ADDR_EXP 50
10282: PUSH
10283: LD_EXP 50
10287: PPUSH
10288: LD_INT 3
10290: PUSH
10291: LD_EXP 50
10295: PUSH
10296: LD_INT 3
10298: ARRAY
10299: PUSH
10300: LD_INT 1
10302: PLUS
10303: PUSH
10304: EMPTY
10305: LIST
10306: LIST
10307: PPUSH
10308: LD_VAR 0 2
10312: PPUSH
10313: CALL 53789 0 3
10317: ST_TO_ADDR
// end ;
10318: PPOPN 3
10320: END
// every 0 0$2 trigger GetSide ( ar_dep_s ) = 1 or IsDead ( ar_dep_s ) do var i , points ;
10321: LD_INT 7
10323: PPUSH
10324: CALL_OW 255
10328: PUSH
10329: LD_INT 1
10331: EQUAL
10332: PUSH
10333: LD_INT 7
10335: PPUSH
10336: CALL_OW 301
10340: OR
10341: IFFALSE 12746
10343: GO 10345
10345: DISABLE
10346: LD_INT 0
10348: PPUSH
10349: PPUSH
// begin for i in UnitFilter ( ar_force_south , [ f_type , unit_building ] ) do
10350: LD_ADDR_VAR 0 1
10354: PUSH
10355: LD_EXP 36
10359: PPUSH
10360: LD_INT 21
10362: PUSH
10363: LD_INT 3
10365: PUSH
10366: EMPTY
10367: LIST
10368: LIST
10369: PPUSH
10370: CALL_OW 72
10374: PUSH
10375: FOR_IN
10376: IFFALSE 10392
// SetSide ( i , 1 ) ;
10378: LD_VAR 0 1
10382: PPUSH
10383: LD_INT 1
10385: PPUSH
10386: CALL_OW 235
10390: GO 10375
10392: POP
10393: POP
// points := [ [ 46 , 41 ] , [ 50 , 25 ] , [ 57 , 75 ] , [ 75 , 89 ] , [ 51 , 45 ] , [ 95 , 95 ] , [ 84 , 77 ] , [ 101 , 76 ] , [ 118 , 81 ] , [ 139 , 97 ] , [ 129 , 114 ] , [ 154 , 111 ] ] ;
10394: LD_ADDR_VAR 0 2
10398: PUSH
10399: LD_INT 46
10401: PUSH
10402: LD_INT 41
10404: PUSH
10405: EMPTY
10406: LIST
10407: LIST
10408: PUSH
10409: LD_INT 50
10411: PUSH
10412: LD_INT 25
10414: PUSH
10415: EMPTY
10416: LIST
10417: LIST
10418: PUSH
10419: LD_INT 57
10421: PUSH
10422: LD_INT 75
10424: PUSH
10425: EMPTY
10426: LIST
10427: LIST
10428: PUSH
10429: LD_INT 75
10431: PUSH
10432: LD_INT 89
10434: PUSH
10435: EMPTY
10436: LIST
10437: LIST
10438: PUSH
10439: LD_INT 51
10441: PUSH
10442: LD_INT 45
10444: PUSH
10445: EMPTY
10446: LIST
10447: LIST
10448: PUSH
10449: LD_INT 95
10451: PUSH
10452: LD_INT 95
10454: PUSH
10455: EMPTY
10456: LIST
10457: LIST
10458: PUSH
10459: LD_INT 84
10461: PUSH
10462: LD_INT 77
10464: PUSH
10465: EMPTY
10466: LIST
10467: LIST
10468: PUSH
10469: LD_INT 101
10471: PUSH
10472: LD_INT 76
10474: PUSH
10475: EMPTY
10476: LIST
10477: LIST
10478: PUSH
10479: LD_INT 118
10481: PUSH
10482: LD_INT 81
10484: PUSH
10485: EMPTY
10486: LIST
10487: LIST
10488: PUSH
10489: LD_INT 139
10491: PUSH
10492: LD_INT 97
10494: PUSH
10495: EMPTY
10496: LIST
10497: LIST
10498: PUSH
10499: LD_INT 129
10501: PUSH
10502: LD_INT 114
10504: PUSH
10505: EMPTY
10506: LIST
10507: LIST
10508: PUSH
10509: LD_INT 154
10511: PUSH
10512: LD_INT 111
10514: PUSH
10515: EMPTY
10516: LIST
10517: LIST
10518: PUSH
10519: EMPTY
10520: LIST
10521: LIST
10522: LIST
10523: LIST
10524: LIST
10525: LIST
10526: LIST
10527: LIST
10528: LIST
10529: LIST
10530: LIST
10531: LIST
10532: ST_TO_ADDR
// base_captured := true ;
10533: LD_ADDR_EXP 6
10537: PUSH
10538: LD_INT 1
10540: ST_TO_ADDR
// DialogueOn ;
10541: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
10545: LD_EXP 21
10549: PPUSH
10550: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
10554: LD_EXP 21
10558: PPUSH
10559: LD_STRING D2-JMM-1
10561: PPUSH
10562: CALL_OW 88
// SayRadio ( Powell , D2-Pow-1 ) ;
10566: LD_EXP 30
10570: PPUSH
10571: LD_STRING D2-Pow-1
10573: PPUSH
10574: CALL_OW 94
// Say ( JMM , D2-JMM-2 ) ;
10578: LD_EXP 21
10582: PPUSH
10583: LD_STRING D2-JMM-2
10585: PPUSH
10586: CALL_OW 88
// SayRadio ( Powell , D2-Pow-2 ) ;
10590: LD_EXP 30
10594: PPUSH
10595: LD_STRING D2-Pow-2
10597: PPUSH
10598: CALL_OW 94
// Say ( JMM , D2-JMM-3 ) ;
10602: LD_EXP 21
10606: PPUSH
10607: LD_STRING D2-JMM-3
10609: PPUSH
10610: CALL_OW 88
// DialogueOff ;
10614: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
10618: LD_STRING M2
10620: PPUSH
10621: CALL_OW 337
// Wait ( 0 0$2 ) ;
10625: LD_INT 70
10627: PPUSH
10628: CALL_OW 67
// if IsOk ( Gary ) then
10632: LD_EXP 32
10636: PPUSH
10637: CALL_OW 302
10641: IFFALSE 10655
// Say ( Gary , D2a-Gary-1 ) ;
10643: LD_EXP 32
10647: PPUSH
10648: LD_STRING D2a-Gary-1
10650: PPUSH
10651: CALL_OW 88
// if IsOk ( Bobby ) then
10655: LD_EXP 24
10659: PPUSH
10660: CALL_OW 302
10664: IFFALSE 10678
// Say ( Bobby , D2a-Bobby-1 ) ;
10666: LD_EXP 24
10670: PPUSH
10671: LD_STRING D2a-Bobby-1
10673: PPUSH
10674: CALL_OW 88
// if IsOk ( Cyrus ) then
10678: LD_EXP 25
10682: PPUSH
10683: CALL_OW 302
10687: IFFALSE 10701
// Say ( Cyrus , D2a-Cyrus-1 ) ;
10689: LD_EXP 25
10693: PPUSH
10694: LD_STRING D2a-Cyrus-1
10696: PPUSH
10697: CALL_OW 88
// if IsOk ( Lisa ) then
10701: LD_EXP 22
10705: PPUSH
10706: CALL_OW 302
10710: IFFALSE 10724
// Say ( Lisa , D2a-Lisa-1 ) ;
10712: LD_EXP 22
10716: PPUSH
10717: LD_STRING D2a-Lisa-1
10719: PPUSH
10720: CALL_OW 88
// if IsOk ( Frank ) then
10724: LD_EXP 33
10728: PPUSH
10729: CALL_OW 302
10733: IFFALSE 10747
// Say ( Frank , D2a-Frank-1 ) ;
10735: LD_EXP 33
10739: PPUSH
10740: LD_STRING D2a-Frank-1
10742: PPUSH
10743: CALL_OW 88
// if IsOk ( Cornel ) then
10747: LD_EXP 31
10751: PPUSH
10752: CALL_OW 302
10756: IFFALSE 10770
// Say ( Cornel , D2a-Corn-1 ) ;
10758: LD_EXP 31
10762: PPUSH
10763: LD_STRING D2a-Corn-1
10765: PPUSH
10766: CALL_OW 88
// if IsOk ( Donaldson ) then
10770: LD_EXP 23
10774: PPUSH
10775: CALL_OW 302
10779: IFFALSE 10793
// Say ( Donaldson , D2a-Don-1 ) ;
10781: LD_EXP 23
10785: PPUSH
10786: LD_STRING D2a-Don-1
10788: PPUSH
10789: CALL_OW 88
// if IsOk ( Brown ) then
10793: LD_EXP 27
10797: PPUSH
10798: CALL_OW 302
10802: IFFALSE 10816
// Say ( Brown , D2a-Brown-1 ) ;
10804: LD_EXP 27
10808: PPUSH
10809: LD_STRING D2a-Brown-1
10811: PPUSH
10812: CALL_OW 88
// Wait ( 0 0$30 ) ;
10816: LD_INT 1050
10818: PPUSH
10819: CALL_OW 67
// if IsOk ( Frank ) then
10823: LD_EXP 33
10827: PPUSH
10828: CALL_OW 302
10832: IFFALSE 11812
// begin DialogueOn ;
10834: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Frank ] ) ;
10838: LD_EXP 21
10842: PUSH
10843: LD_EXP 33
10847: PUSH
10848: EMPTY
10849: LIST
10850: LIST
10851: PPUSH
10852: CALL_OW 87
// Say ( Frank , D3F-Frank-1 ) ;
10856: LD_EXP 33
10860: PPUSH
10861: LD_STRING D3F-Frank-1
10863: PPUSH
10864: CALL_OW 88
// Say ( JMM , D3F-JMM-1 ) ;
10868: LD_EXP 21
10872: PPUSH
10873: LD_STRING D3F-JMM-1
10875: PPUSH
10876: CALL_OW 88
// Say ( Frank , D3F-Frank-2 ) ;
10880: LD_EXP 33
10884: PPUSH
10885: LD_STRING D3F-Frank-2
10887: PPUSH
10888: CALL_OW 88
// case Query ( QFrank ) of 1 :
10892: LD_STRING QFrank
10894: PPUSH
10895: CALL_OW 97
10899: PUSH
10900: LD_INT 1
10902: DOUBLE
10903: EQUAL
10904: IFTRUE 10908
10906: GO 10931
10908: POP
// begin Say ( JMM , D3Fa-JMM-1 ) ;
10909: LD_EXP 21
10913: PPUSH
10914: LD_STRING D3Fa-JMM-1
10916: PPUSH
10917: CALL_OW 88
// us_scout := 1 ;
10921: LD_ADDR_EXP 8
10925: PUSH
10926: LD_INT 1
10928: ST_TO_ADDR
// end ; 2 :
10929: GO 11094
10931: LD_INT 2
10933: DOUBLE
10934: EQUAL
10935: IFTRUE 10939
10937: GO 11061
10939: POP
// begin Say ( JMM , D3Fb-JMM-1 ) ;
10940: LD_EXP 21
10944: PPUSH
10945: LD_STRING D3Fb-JMM-1
10947: PPUSH
10948: CALL_OW 88
// Say ( Frank , D3Fb-Frank-1 ) ;
10952: LD_EXP 33
10956: PPUSH
10957: LD_STRING D3Fb-Frank-1
10959: PPUSH
10960: CALL_OW 88
// case Query ( QFrank2 ) of 1 :
10964: LD_STRING QFrank2
10966: PPUSH
10967: CALL_OW 97
10971: PUSH
10972: LD_INT 1
10974: DOUBLE
10975: EQUAL
10976: IFTRUE 10980
10978: GO 11027
10980: POP
// begin us_scout := 2 ;
10981: LD_ADDR_EXP 8
10985: PUSH
10986: LD_INT 2
10988: ST_TO_ADDR
// Say ( JMM , D3Fba-JMM-1 ) ;
10989: LD_EXP 21
10993: PPUSH
10994: LD_STRING D3Fba-JMM-1
10996: PPUSH
10997: CALL_OW 88
// Say ( Frank , D3Fba-Frank-1 ) ;
11001: LD_EXP 33
11005: PPUSH
11006: LD_STRING D3Fba-Frank-1
11008: PPUSH
11009: CALL_OW 88
// Say ( JMM , D3Fba-JMM-2 ) ;
11013: LD_EXP 21
11017: PPUSH
11018: LD_STRING D3Fba-JMM-2
11020: PPUSH
11021: CALL_OW 88
// end ; 2 :
11025: GO 11059
11027: LD_INT 2
11029: DOUBLE
11030: EQUAL
11031: IFTRUE 11035
11033: GO 11058
11035: POP
// begin us_scout := 0 ;
11036: LD_ADDR_EXP 8
11040: PUSH
11041: LD_INT 0
11043: ST_TO_ADDR
// Say ( JMM , D3Fbb-JMM-1 ) ;
11044: LD_EXP 21
11048: PPUSH
11049: LD_STRING D3Fbb-JMM-1
11051: PPUSH
11052: CALL_OW 88
// end ; end ;
11056: GO 11059
11058: POP
// end ; 3 :
11059: GO 11094
11061: LD_INT 3
11063: DOUBLE
11064: EQUAL
11065: IFTRUE 11069
11067: GO 11093
11069: POP
// begin us_scout := - 1 ;
11070: LD_ADDR_EXP 8
11074: PUSH
11075: LD_INT 1
11077: NEG
11078: ST_TO_ADDR
// Say ( JMM , D3Fc-JMM-1 ) ;
11079: LD_EXP 21
11083: PPUSH
11084: LD_STRING D3Fc-JMM-1
11086: PPUSH
11087: CALL_OW 88
// end ; end ;
11091: GO 11094
11093: POP
// DialogueOff ;
11094: CALL_OW 7
// if us_scout in [ - 1 , 0 ] then
11098: LD_EXP 8
11102: PUSH
11103: LD_INT 1
11105: NEG
11106: PUSH
11107: LD_INT 0
11109: PUSH
11110: EMPTY
11111: LIST
11112: LIST
11113: IN
11114: IFFALSE 11118
// exit ;
11116: GO 12746
// if us_scout in [ 1 , 2 ] then
11118: LD_EXP 8
11122: PUSH
11123: LD_INT 1
11125: PUSH
11126: LD_INT 2
11128: PUSH
11129: EMPTY
11130: LIST
11131: LIST
11132: IN
11133: IFFALSE 11812
// begin if IsInUnit ( Frank ) then
11135: LD_EXP 33
11139: PPUSH
11140: CALL_OW 310
11144: IFFALSE 11155
// ComExit ( Frank ) ;
11146: LD_EXP 33
11150: PPUSH
11151: CALL 86499 0 1
// SetSide ( Frank , 4 ) ;
11155: LD_EXP 33
11159: PPUSH
11160: LD_INT 4
11162: PPUSH
11163: CALL_OW 235
// wait ( 0 0$1 ) ;
11167: LD_INT 35
11169: PPUSH
11170: CALL_OW 67
// if us_scout = 2 then
11174: LD_EXP 8
11178: PUSH
11179: LD_INT 2
11181: EQUAL
11182: IFFALSE 11550
// begin ComMoveXY ( Frank , 75 , 63 ) ;
11184: LD_EXP 33
11188: PPUSH
11189: LD_INT 75
11191: PPUSH
11192: LD_INT 63
11194: PPUSH
11195: CALL_OW 111
// AddComHold ( Frank ) ;
11199: LD_EXP 33
11203: PPUSH
11204: CALL_OW 200
// AddComWait ( Frank , 0 0$22 ) ;
11208: LD_EXP 33
11212: PPUSH
11213: LD_INT 770
11215: PPUSH
11216: CALL_OW 202
// AddComMoveXY ( Frank , 100 , 75 ) ;
11220: LD_EXP 33
11224: PPUSH
11225: LD_INT 100
11227: PPUSH
11228: LD_INT 75
11230: PPUSH
11231: CALL_OW 171
// AddComMoveXY ( Frank , 123 , 103 ) ;
11235: LD_EXP 33
11239: PPUSH
11240: LD_INT 123
11242: PPUSH
11243: LD_INT 103
11245: PPUSH
11246: CALL_OW 171
// AddComMoveXY ( Frank , 138 , 108 ) ;
11250: LD_EXP 33
11254: PPUSH
11255: LD_INT 138
11257: PPUSH
11258: LD_INT 108
11260: PPUSH
11261: CALL_OW 171
// AddComHold ( Frank ) ;
11265: LD_EXP 33
11269: PPUSH
11270: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
11274: LD_INT 35
11276: PPUSH
11277: CALL_OW 67
// until IsAt ( Frank , 138 , 108 ) ;
11281: LD_EXP 33
11285: PPUSH
11286: LD_INT 138
11288: PPUSH
11289: LD_INT 108
11291: PPUSH
11292: CALL_OW 307
11296: IFFALSE 11274
// AddComMoveXY ( Frank , 125 , 132 ) ;
11298: LD_EXP 33
11302: PPUSH
11303: LD_INT 125
11305: PPUSH
11306: LD_INT 132
11308: PPUSH
11309: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11313: LD_INT 35
11315: PPUSH
11316: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 7 ;
11320: LD_INT 1
11322: PPUSH
11323: LD_EXP 33
11327: PPUSH
11328: CALL_OW 292
11332: PUSH
11333: LD_EXP 33
11337: PPUSH
11338: LD_INT 7
11340: PPUSH
11341: CALL_OW 296
11345: PUSH
11346: LD_INT 7
11348: LESS
11349: OR
11350: IFFALSE 11313
// DialogueOn ;
11352: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11356: LD_EXP 33
11360: PPUSH
11361: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
11365: LD_INT 10
11367: PPUSH
11368: CALL_OW 68
// Say ( JMM , D4Fa-JMM-1 ) ;
11372: LD_EXP 21
11376: PPUSH
11377: LD_STRING D4Fa-JMM-1
11379: PPUSH
11380: CALL_OW 88
// for i in points do
11384: LD_ADDR_VAR 0 1
11388: PUSH
11389: LD_VAR 0 2
11393: PUSH
11394: FOR_IN
11395: IFFALSE 11453
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
11397: LD_VAR 0 1
11401: PUSH
11402: LD_INT 1
11404: ARRAY
11405: PPUSH
11406: LD_VAR 0 1
11410: PUSH
11411: LD_INT 2
11413: ARRAY
11414: PPUSH
11415: LD_INT 1
11417: PPUSH
11418: LD_INT 20
11420: NEG
11421: PPUSH
11422: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
11426: LD_VAR 0 1
11430: PUSH
11431: LD_INT 1
11433: ARRAY
11434: PPUSH
11435: LD_VAR 0 1
11439: PUSH
11440: LD_INT 2
11442: ARRAY
11443: PPUSH
11444: LD_INT 1
11446: PPUSH
11447: CALL_OW 331
// end ;
11451: GO 11394
11453: POP
11454: POP
// dwait ( 0 0$0.5 ) ;
11455: LD_INT 18
11457: PPUSH
11458: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
11462: LD_INT 42
11464: PPUSH
11465: LD_INT 27
11467: PPUSH
11468: CALL_OW 84
// Say ( Frank , D4Fa-Frank-1 ) ;
11472: LD_EXP 33
11476: PPUSH
11477: LD_STRING D4Fa-Frank-1
11479: PPUSH
11480: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
11484: LD_INT 18
11486: PPUSH
11487: CALL_OW 68
// Say ( JMM , D4Fa-JMM-2 ) ;
11491: LD_EXP 21
11495: PPUSH
11496: LD_STRING D4Fa-JMM-2
11498: PPUSH
11499: CALL_OW 88
// CenterNowOnXY ( 118 , 80 ) ;
11503: LD_INT 118
11505: PPUSH
11506: LD_INT 80
11508: PPUSH
11509: CALL_OW 86
// Say ( Frank , D4Fa-Frank-2 ) ;
11513: LD_EXP 33
11517: PPUSH
11518: LD_STRING D4Fa-Frank-2
11520: PPUSH
11521: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
11525: LD_INT 10
11527: PPUSH
11528: CALL_OW 68
// DialogueOff ;
11532: CALL_OW 7
// SetSide ( Frank , 1 ) ;
11536: LD_EXP 33
11540: PPUSH
11541: LD_INT 1
11543: PPUSH
11544: CALL_OW 235
// end else
11548: GO 11812
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
11550: LD_INT 2
11552: PPUSH
11553: LD_INT 4
11555: PPUSH
11556: LD_INT 2
11558: PPUSH
11559: LD_INT 1
11561: PPUSH
11562: CALL_OW 80
// ComMoveXY ( Frank , 75 , 63 ) ;
11566: LD_EXP 33
11570: PPUSH
11571: LD_INT 75
11573: PPUSH
11574: LD_INT 63
11576: PPUSH
11577: CALL_OW 111
// AddComWait ( Frank , 0 0$5 ) ;
11581: LD_EXP 33
11585: PPUSH
11586: LD_INT 175
11588: PPUSH
11589: CALL_OW 202
// AddComMoveXY ( Frank , 102 , 76 ) ;
11593: LD_EXP 33
11597: PPUSH
11598: LD_INT 102
11600: PPUSH
11601: LD_INT 76
11603: PPUSH
11604: CALL_OW 171
// AddComMoveXY ( Frank , 108 , 70 ) ;
11608: LD_EXP 33
11612: PPUSH
11613: LD_INT 108
11615: PPUSH
11616: LD_INT 70
11618: PPUSH
11619: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11623: LD_INT 35
11625: PPUSH
11626: CALL_OW 67
// until See ( 2 , Frank ) ;
11630: LD_INT 2
11632: PPUSH
11633: LD_EXP 33
11637: PPUSH
11638: CALL_OW 292
11642: IFFALSE 11623
// ComMoveXY ( Frank , 112 , 118 ) ;
11644: LD_EXP 33
11648: PPUSH
11649: LD_INT 112
11651: PPUSH
11652: LD_INT 118
11654: PPUSH
11655: CALL_OW 111
// if GetLives ( Frank ) >= 750 then
11659: LD_EXP 33
11663: PPUSH
11664: CALL_OW 256
11668: PUSH
11669: LD_INT 750
11671: GREATEREQUAL
11672: IFFALSE 11686
// SetLives ( Frank , 700 ) ;
11674: LD_EXP 33
11678: PPUSH
11679: LD_INT 700
11681: PPUSH
11682: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
11686: LD_INT 35
11688: PPUSH
11689: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 17 ;
11693: LD_INT 1
11695: PPUSH
11696: LD_EXP 33
11700: PPUSH
11701: CALL_OW 292
11705: PUSH
11706: LD_EXP 33
11710: PPUSH
11711: LD_INT 7
11713: PPUSH
11714: CALL_OW 296
11718: PUSH
11719: LD_INT 17
11721: LESS
11722: OR
11723: IFFALSE 11686
// DialogueOn ;
11725: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11729: LD_EXP 33
11733: PPUSH
11734: CALL_OW 87
// Say ( Frank , D4Fb-Frank-1 ) ;
11738: LD_EXP 33
11742: PPUSH
11743: LD_STRING D4Fb-Frank-1
11745: PPUSH
11746: CALL_OW 88
// Say ( JMM , D4Fb-JMM-1 ) ;
11750: LD_EXP 21
11754: PPUSH
11755: LD_STRING D4Fb-JMM-1
11757: PPUSH
11758: CALL_OW 88
// SayRand ( sex_female , D4Fb-FSci1-1 ) ;
11762: LD_INT 2
11764: PPUSH
11765: LD_STRING D4Fb-FSci1-1
11767: PPUSH
11768: CALL 16723 0 2
// Say ( Frank , D4Fb-Frank-2 ) ;
11772: LD_EXP 33
11776: PPUSH
11777: LD_STRING D4Fb-Frank-2
11779: PPUSH
11780: CALL_OW 88
// Say ( JMM , D4Fb-JMM-2 ) ;
11784: LD_EXP 21
11788: PPUSH
11789: LD_STRING D4Fb-JMM-2
11791: PPUSH
11792: CALL_OW 88
// DialogueOff ;
11796: CALL_OW 7
// SetSide ( Frank , 1 ) ;
11800: LD_EXP 33
11804: PPUSH
11805: LD_INT 1
11807: PPUSH
11808: CALL_OW 235
// end ; end ; end ; if IsOk ( Kikuchi ) and not IsOk ( Frank ) then
11812: LD_EXP 34
11816: PPUSH
11817: CALL_OW 302
11821: PUSH
11822: LD_EXP 33
11826: PPUSH
11827: CALL_OW 302
11831: NOT
11832: AND
11833: IFFALSE 12746
// begin DialogueOn ;
11835: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Kikuchi ] ) ;
11839: LD_EXP 21
11843: PUSH
11844: LD_EXP 34
11848: PUSH
11849: EMPTY
11850: LIST
11851: LIST
11852: PPUSH
11853: CALL_OW 87
// Say ( Kikuchi , D3Y-Yam-1 ) ;
11857: LD_EXP 34
11861: PPUSH
11862: LD_STRING D3Y-Yam-1
11864: PPUSH
11865: CALL_OW 88
// Say ( JMM , D3Y-JMM-1 ) ;
11869: LD_EXP 21
11873: PPUSH
11874: LD_STRING D3Y-JMM-1
11876: PPUSH
11877: CALL_OW 88
// Say ( Kikuchi , D3Y-Yam-2 ) ;
11881: LD_EXP 34
11885: PPUSH
11886: LD_STRING D3Y-Yam-2
11888: PPUSH
11889: CALL_OW 88
// case Query ( QYamoko ) of 1 :
11893: LD_STRING QYamoko
11895: PPUSH
11896: CALL_OW 97
11900: PUSH
11901: LD_INT 1
11903: DOUBLE
11904: EQUAL
11905: IFTRUE 11909
11907: GO 11944
11909: POP
// begin Say ( JMM , D3Ya-JMM-1 ) ;
11910: LD_EXP 21
11914: PPUSH
11915: LD_STRING D3Ya-JMM-1
11917: PPUSH
11918: CALL_OW 88
// Say ( Kikuchi , D3Ya-Yam-1 ) ;
11922: LD_EXP 34
11926: PPUSH
11927: LD_STRING D3Ya-Yam-1
11929: PPUSH
11930: CALL_OW 88
// us_scout := 1 ;
11934: LD_ADDR_EXP 8
11938: PUSH
11939: LD_INT 1
11941: ST_TO_ADDR
// end ; 2 :
11942: GO 11977
11944: LD_INT 2
11946: DOUBLE
11947: EQUAL
11948: IFTRUE 11952
11950: GO 11976
11952: POP
// begin us_scout := - 1 ;
11953: LD_ADDR_EXP 8
11957: PUSH
11958: LD_INT 1
11960: NEG
11961: ST_TO_ADDR
// Say ( JMM , D3Yb-JMM-1 ) ;
11962: LD_EXP 21
11966: PPUSH
11967: LD_STRING D3Yb-JMM-1
11969: PPUSH
11970: CALL_OW 88
// end ; end ;
11974: GO 11977
11976: POP
// DialogueOff ;
11977: CALL_OW 7
// if us_scout in [ - 1 , 0 ] then
11981: LD_EXP 8
11985: PUSH
11986: LD_INT 1
11988: NEG
11989: PUSH
11990: LD_INT 0
11992: PUSH
11993: EMPTY
11994: LIST
11995: LIST
11996: IN
11997: IFFALSE 12001
// exit ;
11999: GO 12746
// us_scout := [ 2 , 2 , 1 , 1 ] [ Difficulty ] ;
12001: LD_ADDR_EXP 8
12005: PUSH
12006: LD_INT 2
12008: PUSH
12009: LD_INT 2
12011: PUSH
12012: LD_INT 1
12014: PUSH
12015: LD_INT 1
12017: PUSH
12018: EMPTY
12019: LIST
12020: LIST
12021: LIST
12022: LIST
12023: PUSH
12024: LD_OWVAR 67
12028: ARRAY
12029: ST_TO_ADDR
// if us_scout in [ 1 , 2 ] then
12030: LD_EXP 8
12034: PUSH
12035: LD_INT 1
12037: PUSH
12038: LD_INT 2
12040: PUSH
12041: EMPTY
12042: LIST
12043: LIST
12044: IN
12045: IFFALSE 12746
// begin if IsInUnit ( Kikuchi ) then
12047: LD_EXP 34
12051: PPUSH
12052: CALL_OW 310
12056: IFFALSE 12067
// ComExitBuilding ( Kikuchi ) ;
12058: LD_EXP 34
12062: PPUSH
12063: CALL_OW 122
// if IsDrivenBy ( Kikuchi ) then
12067: LD_EXP 34
12071: PPUSH
12072: CALL_OW 311
12076: IFFALSE 12087
// ComExitVehicle ( Kikuchi ) ;
12078: LD_EXP 34
12082: PPUSH
12083: CALL_OW 121
// SetSide ( Kikuchi , 4 ) ;
12087: LD_EXP 34
12091: PPUSH
12092: LD_INT 4
12094: PPUSH
12095: CALL_OW 235
// wait ( 0 0$1 ) ;
12099: LD_INT 35
12101: PPUSH
12102: CALL_OW 67
// if us_scout = 2 then
12106: LD_EXP 8
12110: PUSH
12111: LD_INT 2
12113: EQUAL
12114: IFFALSE 12494
// begin ComMoveXY ( Kikuchi , 75 , 63 ) ;
12116: LD_EXP 34
12120: PPUSH
12121: LD_INT 75
12123: PPUSH
12124: LD_INT 63
12126: PPUSH
12127: CALL_OW 111
// AddComHold ( Kikuchi ) ;
12131: LD_EXP 34
12135: PPUSH
12136: CALL_OW 200
// AddComWait ( Kikuchi , 0 0$22 ) ;
12140: LD_EXP 34
12144: PPUSH
12145: LD_INT 770
12147: PPUSH
12148: CALL_OW 202
// AddComMoveXY ( Kikuchi , 100 , 75 ) ;
12152: LD_EXP 34
12156: PPUSH
12157: LD_INT 100
12159: PPUSH
12160: LD_INT 75
12162: PPUSH
12163: CALL_OW 171
// AddComMoveXY ( Kikuchi , 123 , 103 ) ;
12167: LD_EXP 34
12171: PPUSH
12172: LD_INT 123
12174: PPUSH
12175: LD_INT 103
12177: PPUSH
12178: CALL_OW 171
// AddComMoveXY ( Kikuchi , 138 , 108 ) ;
12182: LD_EXP 34
12186: PPUSH
12187: LD_INT 138
12189: PPUSH
12190: LD_INT 108
12192: PPUSH
12193: CALL_OW 171
// AddComHold ( Kikuchi ) ;
12197: LD_EXP 34
12201: PPUSH
12202: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
12206: LD_INT 35
12208: PPUSH
12209: CALL_OW 67
// until IsAt ( Kikuchi , 138 , 108 ) ;
12213: LD_EXP 34
12217: PPUSH
12218: LD_INT 138
12220: PPUSH
12221: LD_INT 108
12223: PPUSH
12224: CALL_OW 307
12228: IFFALSE 12206
// AddComMoveXY ( Kikuchi , 125 , 132 ) ;
12230: LD_EXP 34
12234: PPUSH
12235: LD_INT 125
12237: PPUSH
12238: LD_INT 132
12240: PPUSH
12241: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12245: LD_INT 35
12247: PPUSH
12248: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 7 ;
12252: LD_INT 1
12254: PPUSH
12255: LD_EXP 34
12259: PPUSH
12260: CALL_OW 292
12264: PUSH
12265: LD_EXP 34
12269: PPUSH
12270: LD_INT 7
12272: PPUSH
12273: CALL_OW 296
12277: PUSH
12278: LD_INT 7
12280: LESS
12281: OR
12282: IFFALSE 12245
// DialogueOn ;
12284: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12288: LD_EXP 34
12292: PPUSH
12293: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12297: LD_INT 10
12299: PPUSH
12300: CALL_OW 68
// Say ( Kikuchi , D4Ya-Yam-1 ) ;
12304: LD_EXP 34
12308: PPUSH
12309: LD_STRING D4Ya-Yam-1
12311: PPUSH
12312: CALL_OW 88
// Say ( JMM , D4Ya-JMM-1 ) ;
12316: LD_EXP 21
12320: PPUSH
12321: LD_STRING D4Ya-JMM-1
12323: PPUSH
12324: CALL_OW 88
// for i in points do
12328: LD_ADDR_VAR 0 1
12332: PUSH
12333: LD_VAR 0 2
12337: PUSH
12338: FOR_IN
12339: IFFALSE 12397
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
12341: LD_VAR 0 1
12345: PUSH
12346: LD_INT 1
12348: ARRAY
12349: PPUSH
12350: LD_VAR 0 1
12354: PUSH
12355: LD_INT 2
12357: ARRAY
12358: PPUSH
12359: LD_INT 1
12361: PPUSH
12362: LD_INT 20
12364: NEG
12365: PPUSH
12366: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
12370: LD_VAR 0 1
12374: PUSH
12375: LD_INT 1
12377: ARRAY
12378: PPUSH
12379: LD_VAR 0 1
12383: PUSH
12384: LD_INT 2
12386: ARRAY
12387: PPUSH
12388: LD_INT 1
12390: PPUSH
12391: CALL_OW 331
// end ;
12395: GO 12338
12397: POP
12398: POP
// dwait ( 0 0$0.5 ) ;
12399: LD_INT 18
12401: PPUSH
12402: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
12406: LD_INT 42
12408: PPUSH
12409: LD_INT 27
12411: PPUSH
12412: CALL_OW 84
// Say ( Kikuchi , D4Ya-Yam-2 ) ;
12416: LD_EXP 34
12420: PPUSH
12421: LD_STRING D4Ya-Yam-2
12423: PPUSH
12424: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
12428: LD_INT 18
12430: PPUSH
12431: CALL_OW 68
// CenterNowOnXY ( 118 , 80 ) ;
12435: LD_INT 118
12437: PPUSH
12438: LD_INT 80
12440: PPUSH
12441: CALL_OW 86
// Say ( JMM , D4Ya-JMM-2 ) ;
12445: LD_EXP 21
12449: PPUSH
12450: LD_STRING D4Ya-JMM-2
12452: PPUSH
12453: CALL_OW 88
// Say ( Kikuchi , D4Ya-Yam-3 ) ;
12457: LD_EXP 34
12461: PPUSH
12462: LD_STRING D4Ya-Yam-3
12464: PPUSH
12465: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
12469: LD_INT 10
12471: PPUSH
12472: CALL_OW 68
// DialogueOff ;
12476: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12480: LD_EXP 34
12484: PPUSH
12485: LD_INT 1
12487: PPUSH
12488: CALL_OW 235
// end else
12492: GO 12746
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
12494: LD_INT 2
12496: PPUSH
12497: LD_INT 4
12499: PPUSH
12500: LD_INT 2
12502: PPUSH
12503: LD_INT 1
12505: PPUSH
12506: CALL_OW 80
// ComMoveXY ( Kikuchi , 75 , 63 ) ;
12510: LD_EXP 34
12514: PPUSH
12515: LD_INT 75
12517: PPUSH
12518: LD_INT 63
12520: PPUSH
12521: CALL_OW 111
// AddComWait ( Kikuchi , 0 0$5 ) ;
12525: LD_EXP 34
12529: PPUSH
12530: LD_INT 175
12532: PPUSH
12533: CALL_OW 202
// AddComMoveXY ( Kikuchi , 102 , 76 ) ;
12537: LD_EXP 34
12541: PPUSH
12542: LD_INT 102
12544: PPUSH
12545: LD_INT 76
12547: PPUSH
12548: CALL_OW 171
// AddComMoveXY ( Kikuchi , 108 , 70 ) ;
12552: LD_EXP 34
12556: PPUSH
12557: LD_INT 108
12559: PPUSH
12560: LD_INT 70
12562: PPUSH
12563: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12567: LD_INT 35
12569: PPUSH
12570: CALL_OW 67
// until See ( 2 , Kikuchi ) ;
12574: LD_INT 2
12576: PPUSH
12577: LD_EXP 34
12581: PPUSH
12582: CALL_OW 292
12586: IFFALSE 12567
// ComMoveXY ( Kikuchi , 112 , 118 ) ;
12588: LD_EXP 34
12592: PPUSH
12593: LD_INT 112
12595: PPUSH
12596: LD_INT 118
12598: PPUSH
12599: CALL_OW 111
// if GetLives ( Kikuchi ) >= 750 then
12603: LD_EXP 34
12607: PPUSH
12608: CALL_OW 256
12612: PUSH
12613: LD_INT 750
12615: GREATEREQUAL
12616: IFFALSE 12630
// SetLives ( Kikuchi , 700 ) ;
12618: LD_EXP 34
12622: PPUSH
12623: LD_INT 700
12625: PPUSH
12626: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
12630: LD_INT 35
12632: PPUSH
12633: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 17 ;
12637: LD_INT 1
12639: PPUSH
12640: LD_EXP 34
12644: PPUSH
12645: CALL_OW 292
12649: PUSH
12650: LD_EXP 34
12654: PPUSH
12655: LD_INT 7
12657: PPUSH
12658: CALL_OW 296
12662: PUSH
12663: LD_INT 17
12665: LESS
12666: OR
12667: IFFALSE 12630
// DialogueOn ;
12669: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12673: LD_EXP 34
12677: PPUSH
12678: CALL_OW 87
// Say ( Kikuchi , D4Yb-Yam-1 ) ;
12682: LD_EXP 34
12686: PPUSH
12687: LD_STRING D4Yb-Yam-1
12689: PPUSH
12690: CALL_OW 88
// Say ( JMM , D4Yb-JMM-1 ) ;
12694: LD_EXP 21
12698: PPUSH
12699: LD_STRING D4Yb-JMM-1
12701: PPUSH
12702: CALL_OW 88
// Say ( Kikuchi , D4Yb-Yam-2 ) ;
12706: LD_EXP 34
12710: PPUSH
12711: LD_STRING D4Yb-Yam-2
12713: PPUSH
12714: CALL_OW 88
// Say ( JMM , D4Yb-JMM-2 ) ;
12718: LD_EXP 21
12722: PPUSH
12723: LD_STRING D4Yb-JMM-2
12725: PPUSH
12726: CALL_OW 88
// DialogueOff ;
12730: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12734: LD_EXP 34
12738: PPUSH
12739: LD_INT 1
12741: PPUSH
12742: CALL_OW 235
// end ; end ; end ; end ;
12746: PPOPN 2
12748: END
// every 0 0$01 trigger base_captured do var i , tmp , un , un2 ;
12749: LD_EXP 6
12753: IFFALSE 13786
12755: GO 12757
12757: DISABLE
12758: LD_INT 0
12760: PPUSH
12761: PPUSH
12762: PPUSH
12763: PPUSH
// begin enable ;
12764: ENABLE
// if not seen [ 1 ] then
12765: LD_EXP 9
12769: PUSH
12770: LD_INT 1
12772: ARRAY
12773: NOT
12774: IFFALSE 12954
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 11 ] , [ f_control , control_rider ] ] ] ) ;
12776: LD_ADDR_VAR 0 2
12780: PUSH
12781: LD_INT 22
12783: PUSH
12784: LD_INT 2
12786: PUSH
12787: EMPTY
12788: LIST
12789: LIST
12790: PUSH
12791: LD_INT 2
12793: PUSH
12794: LD_INT 25
12796: PUSH
12797: LD_INT 11
12799: PUSH
12800: EMPTY
12801: LIST
12802: LIST
12803: PUSH
12804: LD_INT 33
12806: PUSH
12807: LD_INT 4
12809: PUSH
12810: EMPTY
12811: LIST
12812: LIST
12813: PUSH
12814: EMPTY
12815: LIST
12816: LIST
12817: LIST
12818: PUSH
12819: EMPTY
12820: LIST
12821: LIST
12822: PPUSH
12823: CALL_OW 69
12827: ST_TO_ADDR
// if tmp then
12828: LD_VAR 0 2
12832: IFFALSE 12954
// for i in tmp do
12834: LD_ADDR_VAR 0 1
12838: PUSH
12839: LD_VAR 0 2
12843: PUSH
12844: FOR_IN
12845: IFFALSE 12952
// if See ( 1 , i ) then
12847: LD_INT 1
12849: PPUSH
12850: LD_VAR 0 1
12854: PPUSH
12855: CALL_OW 292
12859: IFFALSE 12950
// begin seen := Replace ( seen , 1 , true ) ;
12861: LD_ADDR_EXP 9
12865: PUSH
12866: LD_EXP 9
12870: PPUSH
12871: LD_INT 1
12873: PPUSH
12874: LD_INT 1
12876: PPUSH
12877: CALL_OW 1
12881: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12882: LD_INT 1
12884: PPUSH
12885: CALL 16545 0 1
12889: IFFALSE 12950
// begin DialogueOn ;
12891: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12895: LD_VAR 0 1
12899: PPUSH
12900: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12904: LD_INT 10
12906: PPUSH
12907: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol2-1 ) ;
12911: LD_ADDR_VAR 0 3
12915: PUSH
12916: LD_INT 1
12918: PPUSH
12919: LD_STRING D5a-Sol2-1
12921: PPUSH
12922: CALL 16723 0 2
12926: ST_TO_ADDR
// if not un then
12927: LD_VAR 0 3
12931: NOT
12932: IFFALSE 12944
// SayRand ( sex_female , D5a-FSol2-1 ) ;
12934: LD_INT 2
12936: PPUSH
12937: LD_STRING D5a-FSol2-1
12939: PPUSH
12940: CALL 16723 0 2
// DialogueOff ;
12944: CALL_OW 7
// break ;
12948: GO 12952
// end ; end ;
12950: GO 12844
12952: POP
12953: POP
// end ; if not seen [ 2 ] then
12954: LD_EXP 9
12958: PUSH
12959: LD_INT 2
12961: ARRAY
12962: NOT
12963: IFFALSE 13188
// begin can_kamikazed := true ;
12965: LD_ADDR_EXP 10
12969: PUSH
12970: LD_INT 1
12972: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 17 ] ] ) ;
12973: LD_ADDR_VAR 0 2
12977: PUSH
12978: LD_INT 22
12980: PUSH
12981: LD_INT 2
12983: PUSH
12984: EMPTY
12985: LIST
12986: LIST
12987: PUSH
12988: LD_INT 25
12990: PUSH
12991: LD_INT 17
12993: PUSH
12994: EMPTY
12995: LIST
12996: LIST
12997: PUSH
12998: EMPTY
12999: LIST
13000: LIST
13001: PPUSH
13002: CALL_OW 69
13006: ST_TO_ADDR
// if tmp then
13007: LD_VAR 0 2
13011: IFFALSE 13188
// for i in tmp do
13013: LD_ADDR_VAR 0 1
13017: PUSH
13018: LD_VAR 0 2
13022: PUSH
13023: FOR_IN
13024: IFFALSE 13186
// if See ( 1 , i ) then
13026: LD_INT 1
13028: PPUSH
13029: LD_VAR 0 1
13033: PPUSH
13034: CALL_OW 292
13038: IFFALSE 13184
// begin seen := Replace ( seen , 2 , true ) ;
13040: LD_ADDR_EXP 9
13044: PUSH
13045: LD_EXP 9
13049: PPUSH
13050: LD_INT 2
13052: PPUSH
13053: LD_INT 1
13055: PPUSH
13056: CALL_OW 1
13060: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13061: LD_INT 1
13063: PPUSH
13064: CALL 16545 0 1
13068: IFFALSE 13184
// begin DialogueOn ;
13070: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13074: LD_VAR 0 1
13078: PPUSH
13079: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13083: LD_INT 10
13085: PPUSH
13086: CALL_OW 68
// un := SayRand ( sex_male , D5b-Sol1-1 ) ;
13090: LD_ADDR_VAR 0 3
13094: PUSH
13095: LD_INT 1
13097: PPUSH
13098: LD_STRING D5b-Sol1-1
13100: PPUSH
13101: CALL 16723 0 2
13105: ST_TO_ADDR
// if not un then
13106: LD_VAR 0 3
13110: NOT
13111: IFFALSE 13129
// un := SayRand ( sex_female , D5b-FSol1-1 ) ;
13113: LD_ADDR_VAR 0 3
13117: PUSH
13118: LD_INT 2
13120: PPUSH
13121: LD_STRING D5b-FSol1-1
13123: PPUSH
13124: CALL 16723 0 2
13128: ST_TO_ADDR
// if un then
13129: LD_VAR 0 3
13133: IFFALSE 13178
// begin un2 := SayRand2 ( sex_male , D5b-Sol2-1 , un ) ;
13135: LD_ADDR_VAR 0 4
13139: PUSH
13140: LD_INT 1
13142: PPUSH
13143: LD_STRING D5b-Sol2-1
13145: PPUSH
13146: LD_VAR 0 3
13150: PPUSH
13151: CALL 16949 0 3
13155: ST_TO_ADDR
// if not un2 then
13156: LD_VAR 0 4
13160: NOT
13161: IFFALSE 13178
// SayRand2 ( sex_female , D5b-FSol2-1 , un ) ;
13163: LD_INT 2
13165: PPUSH
13166: LD_STRING D5b-FSol2-1
13168: PPUSH
13169: LD_VAR 0 3
13173: PPUSH
13174: CALL 16949 0 3
// end ; DialogueOff ;
13178: CALL_OW 7
// break ;
13182: GO 13186
// end ; end ;
13184: GO 13023
13186: POP
13187: POP
// end ; if not seen [ 3 ] then
13188: LD_EXP 9
13192: PUSH
13193: LD_INT 3
13195: ARRAY
13196: NOT
13197: IFFALSE 13371
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] ] ) ;
13199: LD_ADDR_VAR 0 2
13203: PUSH
13204: LD_INT 22
13206: PUSH
13207: LD_INT 2
13209: PUSH
13210: EMPTY
13211: LIST
13212: LIST
13213: PUSH
13214: LD_INT 33
13216: PUSH
13217: LD_INT 2
13219: PUSH
13220: EMPTY
13221: LIST
13222: LIST
13223: PUSH
13224: EMPTY
13225: LIST
13226: LIST
13227: PPUSH
13228: CALL_OW 69
13232: ST_TO_ADDR
// if tmp then
13233: LD_VAR 0 2
13237: IFFALSE 13371
// for i in tmp do
13239: LD_ADDR_VAR 0 1
13243: PUSH
13244: LD_VAR 0 2
13248: PUSH
13249: FOR_IN
13250: IFFALSE 13369
// if See ( 1 , i ) then
13252: LD_INT 1
13254: PPUSH
13255: LD_VAR 0 1
13259: PPUSH
13260: CALL_OW 292
13264: IFFALSE 13367
// begin seen := Replace ( seen , 3 , true ) ;
13266: LD_ADDR_EXP 9
13270: PUSH
13271: LD_EXP 9
13275: PPUSH
13276: LD_INT 3
13278: PPUSH
13279: LD_INT 1
13281: PPUSH
13282: CALL_OW 1
13286: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13287: LD_INT 1
13289: PPUSH
13290: CALL 16545 0 1
13294: IFFALSE 13367
// begin DialogueOn ;
13296: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13300: LD_VAR 0 1
13304: PPUSH
13305: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13309: LD_INT 10
13311: PPUSH
13312: CALL_OW 68
// un := SayRand ( sex_male , D8-Sol1-1 ) ;
13316: LD_ADDR_VAR 0 3
13320: PUSH
13321: LD_INT 1
13323: PPUSH
13324: LD_STRING D8-Sol1-1
13326: PPUSH
13327: CALL 16723 0 2
13331: ST_TO_ADDR
// if not un then
13332: LD_VAR 0 3
13336: NOT
13337: IFFALSE 13349
// SayRand ( sex_female , D8-FSol1-1 ) ;
13339: LD_INT 2
13341: PPUSH
13342: LD_STRING D8-FSol1-1
13344: PPUSH
13345: CALL 16723 0 2
// Say ( JMM , D8-JMM-1 ) ;
13349: LD_EXP 21
13353: PPUSH
13354: LD_STRING D8-JMM-1
13356: PPUSH
13357: CALL_OW 88
// DialogueOff ;
13361: CALL_OW 7
// break ;
13365: GO 13369
// end ; end ;
13367: GO 13249
13369: POP
13370: POP
// end ; if not seen [ 4 ] then
13371: LD_EXP 9
13375: PUSH
13376: LD_INT 4
13378: ARRAY
13379: NOT
13380: IFFALSE 13542
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] ] ) ;
13382: LD_ADDR_VAR 0 2
13386: PUSH
13387: LD_INT 22
13389: PUSH
13390: LD_INT 2
13392: PUSH
13393: EMPTY
13394: LIST
13395: LIST
13396: PUSH
13397: LD_INT 33
13399: PUSH
13400: LD_INT 5
13402: PUSH
13403: EMPTY
13404: LIST
13405: LIST
13406: PUSH
13407: EMPTY
13408: LIST
13409: LIST
13410: PPUSH
13411: CALL_OW 69
13415: ST_TO_ADDR
// if tmp then
13416: LD_VAR 0 2
13420: IFFALSE 13542
// for i in tmp do
13422: LD_ADDR_VAR 0 1
13426: PUSH
13427: LD_VAR 0 2
13431: PUSH
13432: FOR_IN
13433: IFFALSE 13540
// if See ( 1 , i ) then
13435: LD_INT 1
13437: PPUSH
13438: LD_VAR 0 1
13442: PPUSH
13443: CALL_OW 292
13447: IFFALSE 13538
// begin seen := Replace ( seen , 4 , true ) ;
13449: LD_ADDR_EXP 9
13453: PUSH
13454: LD_EXP 9
13458: PPUSH
13459: LD_INT 4
13461: PPUSH
13462: LD_INT 1
13464: PPUSH
13465: CALL_OW 1
13469: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13470: LD_INT 1
13472: PPUSH
13473: CALL 16545 0 1
13477: IFFALSE 13538
// begin DialogueOn ;
13479: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13483: LD_VAR 0 1
13487: PPUSH
13488: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13492: LD_INT 10
13494: PPUSH
13495: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol1-1 ) ;
13499: LD_ADDR_VAR 0 3
13503: PUSH
13504: LD_INT 1
13506: PPUSH
13507: LD_STRING D5a-Sol1-1
13509: PPUSH
13510: CALL 16723 0 2
13514: ST_TO_ADDR
// if not un then
13515: LD_VAR 0 3
13519: NOT
13520: IFFALSE 13532
// SayRand ( sex_female , D5a-FSol1-1 ) ;
13522: LD_INT 2
13524: PPUSH
13525: LD_STRING D5a-FSol1-1
13527: PPUSH
13528: CALL 16723 0 2
// DialogueOff ;
13532: CALL_OW 7
// break ;
13536: GO 13540
// end ; end ;
13538: GO 13432
13540: POP
13541: POP
// end ; if not seen [ 5 ] and seen [ 3 ] then
13542: LD_EXP 9
13546: PUSH
13547: LD_INT 5
13549: ARRAY
13550: NOT
13551: PUSH
13552: LD_EXP 9
13556: PUSH
13557: LD_INT 3
13559: ARRAY
13560: AND
13561: IFFALSE 13735
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) ;
13563: LD_ADDR_VAR 0 2
13567: PUSH
13568: LD_INT 22
13570: PUSH
13571: LD_INT 2
13573: PUSH
13574: EMPTY
13575: LIST
13576: LIST
13577: PUSH
13578: LD_INT 34
13580: PUSH
13581: LD_INT 31
13583: PUSH
13584: EMPTY
13585: LIST
13586: LIST
13587: PUSH
13588: EMPTY
13589: LIST
13590: LIST
13591: PPUSH
13592: CALL_OW 69
13596: ST_TO_ADDR
// if tmp then
13597: LD_VAR 0 2
13601: IFFALSE 13735
// for i in tmp do
13603: LD_ADDR_VAR 0 1
13607: PUSH
13608: LD_VAR 0 2
13612: PUSH
13613: FOR_IN
13614: IFFALSE 13733
// if See ( 1 , i ) then
13616: LD_INT 1
13618: PPUSH
13619: LD_VAR 0 1
13623: PPUSH
13624: CALL_OW 292
13628: IFFALSE 13731
// begin seen := Replace ( seen , 5 , true ) ;
13630: LD_ADDR_EXP 9
13634: PUSH
13635: LD_EXP 9
13639: PPUSH
13640: LD_INT 5
13642: PPUSH
13643: LD_INT 1
13645: PPUSH
13646: CALL_OW 1
13650: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13651: LD_INT 1
13653: PPUSH
13654: CALL 16545 0 1
13658: IFFALSE 13731
// begin DialogueOn ;
13660: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13664: LD_VAR 0 1
13668: PPUSH
13669: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13673: LD_INT 10
13675: PPUSH
13676: CALL_OW 68
// un := SayRand ( sex_male , D8a-Sol2-1 ) ;
13680: LD_ADDR_VAR 0 3
13684: PUSH
13685: LD_INT 1
13687: PPUSH
13688: LD_STRING D8a-Sol2-1
13690: PPUSH
13691: CALL 16723 0 2
13695: ST_TO_ADDR
// if not un then
13696: LD_VAR 0 3
13700: NOT
13701: IFFALSE 13713
// SayRand ( sex_female , D8a-FSol2-1 ) ;
13703: LD_INT 2
13705: PPUSH
13706: LD_STRING D8a-FSol2-1
13708: PPUSH
13709: CALL 16723 0 2
// Say ( JMM , D8a-JMM-1 ) ;
13713: LD_EXP 21
13717: PPUSH
13718: LD_STRING D8a-JMM-1
13720: PPUSH
13721: CALL_OW 88
// DialogueOff ;
13725: CALL_OW 7
// break ;
13729: GO 13733
// end ; end ;
13731: GO 13613
13733: POP
13734: POP
// end ; if seen [ 1 ] and seen [ 2 ] and seen [ 3 ] and seen [ 4 ] and seen [ 5 ] then
13735: LD_EXP 9
13739: PUSH
13740: LD_INT 1
13742: ARRAY
13743: PUSH
13744: LD_EXP 9
13748: PUSH
13749: LD_INT 2
13751: ARRAY
13752: AND
13753: PUSH
13754: LD_EXP 9
13758: PUSH
13759: LD_INT 3
13761: ARRAY
13762: AND
13763: PUSH
13764: LD_EXP 9
13768: PUSH
13769: LD_INT 4
13771: ARRAY
13772: AND
13773: PUSH
13774: LD_EXP 9
13778: PUSH
13779: LD_INT 5
13781: ARRAY
13782: AND
13783: IFFALSE 13786
// disable ;
13785: DISABLE
// end ;
13786: PPOPN 4
13788: END
// every 0 0$1 trigger can_kamikazed and kamikazed do var un ;
13789: LD_EXP 10
13793: PUSH
13794: LD_EXP 11
13798: AND
13799: IFFALSE 13997
13801: GO 13803
13803: DISABLE
13804: LD_INT 0
13806: PPUSH
// begin DialogueOn ;
13807: CALL_OW 6
// CenterNowOnUnits ( kamikazed ) ;
13811: LD_EXP 11
13815: PPUSH
13816: CALL_OW 87
// un := SayRand ( sex_male , D5c-Sol1-1 ) ;
13820: LD_ADDR_VAR 0 1
13824: PUSH
13825: LD_INT 1
13827: PPUSH
13828: LD_STRING D5c-Sol1-1
13830: PPUSH
13831: CALL 16723 0 2
13835: ST_TO_ADDR
// if not un then
13836: LD_VAR 0 1
13840: NOT
13841: IFFALSE 13859
// un := SayRand ( sex_female , D5c-FSol1-1 ) ;
13843: LD_ADDR_VAR 0 1
13847: PUSH
13848: LD_INT 2
13850: PPUSH
13851: LD_STRING D5c-FSol1-1
13853: PPUSH
13854: CALL 16723 0 2
13858: ST_TO_ADDR
// Say ( JMM , D5c-JMM-1 ) ;
13859: LD_EXP 21
13863: PPUSH
13864: LD_STRING D5c-JMM-1
13866: PPUSH
13867: CALL_OW 88
// if IsOk ( Lisa ) then
13871: LD_EXP 22
13875: PPUSH
13876: CALL_OW 302
13880: IFFALSE 13896
// Say ( Lisa , D5d-Lisa-1 ) else
13882: LD_EXP 22
13886: PPUSH
13887: LD_STRING D5d-Lisa-1
13889: PPUSH
13890: CALL_OW 88
13894: GO 13981
// if IsOk ( Cyrus ) then
13896: LD_EXP 25
13900: PPUSH
13901: CALL_OW 302
13905: IFFALSE 13921
// Say ( Cyrus , D5d-Cyrus-1 ) else
13907: LD_EXP 25
13911: PPUSH
13912: LD_STRING D5d-Cyrus-1
13914: PPUSH
13915: CALL_OW 88
13919: GO 13981
// if IsOk ( Gary ) then
13921: LD_EXP 32
13925: PPUSH
13926: CALL_OW 302
13930: IFFALSE 13946
// Say ( Gary , D5d-Gary-1 ) else
13932: LD_EXP 32
13936: PPUSH
13937: LD_STRING D5d-Gary-1
13939: PPUSH
13940: CALL_OW 88
13944: GO 13981
// if GetSex ( un ) = sex_male then
13946: LD_VAR 0 1
13950: PPUSH
13951: CALL_OW 258
13955: PUSH
13956: LD_INT 1
13958: EQUAL
13959: IFFALSE 13975
// Say ( un , D5d-Sol1-1 ) else
13961: LD_VAR 0 1
13965: PPUSH
13966: LD_STRING D5d-Sol1-1
13968: PPUSH
13969: CALL_OW 88
13973: GO 13981
// begin DialogueOff ;
13975: CALL_OW 7
// exit ;
13979: GO 13997
// end ; Say ( JMM , D5d-JMM-1 ) ;
13981: LD_EXP 21
13985: PPUSH
13986: LD_STRING D5d-JMM-1
13988: PPUSH
13989: CALL_OW 88
// DialogueOff ;
13993: CALL_OW 7
// end ;
13997: PPOPN 1
13999: END
// every 0 0$2 trigger SeeArea ( 1 , artifact_area ) >= 2 do var un ;
14000: LD_INT 1
14002: PPUSH
14003: LD_INT 17
14005: PPUSH
14006: CALL_OW 294
14010: PUSH
14011: LD_INT 2
14013: GREATEREQUAL
14014: IFFALSE 14146
14016: GO 14018
14018: DISABLE
14019: LD_INT 0
14021: PPUSH
// begin PlaceSeeing ( 10 , 5 , 1 , - 10 ) ;
14022: LD_INT 10
14024: PPUSH
14025: LD_INT 5
14027: PPUSH
14028: LD_INT 1
14030: PPUSH
14031: LD_INT 10
14033: NEG
14034: PPUSH
14035: CALL_OW 330
// RemoveSeeing ( 10 , 5 , 1 ) ;
14039: LD_INT 10
14041: PPUSH
14042: LD_INT 5
14044: PPUSH
14045: LD_INT 1
14047: PPUSH
14048: CALL_OW 331
// CenterNowOnXY ( 10 , 5 ) ;
14052: LD_INT 10
14054: PPUSH
14055: LD_INT 5
14057: PPUSH
14058: CALL_OW 86
// DialogueOn ;
14062: CALL_OW 6
// un := SayRand ( sex_male , D6-Sci1-1 ) ;
14066: LD_ADDR_VAR 0 1
14070: PUSH
14071: LD_INT 1
14073: PPUSH
14074: LD_STRING D6-Sci1-1
14076: PPUSH
14077: CALL 16723 0 2
14081: ST_TO_ADDR
// if un then
14082: LD_VAR 0 1
14086: IFFALSE 14124
// begin Say ( JMM , D6-JMM-1 ) ;
14088: LD_EXP 21
14092: PPUSH
14093: LD_STRING D6-JMM-1
14095: PPUSH
14096: CALL_OW 88
// Say ( un , D6-Sci1-2 ) ;
14100: LD_VAR 0 1
14104: PPUSH
14105: LD_STRING D6-Sci1-2
14107: PPUSH
14108: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
14112: LD_EXP 21
14116: PPUSH
14117: LD_STRING D6-JMM-2
14119: PPUSH
14120: CALL_OW 88
// end ; DialogueOff ;
14124: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
14128: LD_STRING M3
14130: PPUSH
14131: CALL_OW 337
// wait ( 0 0$30 ) ;
14135: LD_INT 1050
14137: PPUSH
14138: CALL_OW 67
// AmericanReinforcements ;
14142: CALL 2326 0 0
// end ;
14146: PPOPN 1
14148: END
// export ar_mechanic , ar_mechanic_friend ; every 0 0$20 trigger tick >= 20 20$00 and ( DangerAtRangeXY ( 2 , 169 , 90 , 10 ) [ 4 ] = 0 or IsDead ( ar_dep_w ) or GetSide ( ar_dep_w ) = 1 ) and not IsDead ( ar_dep_n ) do var un , i , cargo , tmp , escaped ;
14149: LD_OWVAR 1
14153: PUSH
14154: LD_INT 42000
14156: GREATEREQUAL
14157: PUSH
14158: LD_INT 2
14160: PPUSH
14161: LD_INT 169
14163: PPUSH
14164: LD_INT 90
14166: PPUSH
14167: LD_INT 10
14169: PPUSH
14170: CALL 54685 0 4
14174: PUSH
14175: LD_INT 4
14177: ARRAY
14178: PUSH
14179: LD_INT 0
14181: EQUAL
14182: PUSH
14183: LD_INT 45
14185: PPUSH
14186: CALL_OW 301
14190: OR
14191: PUSH
14192: LD_INT 45
14194: PPUSH
14195: CALL_OW 255
14199: PUSH
14200: LD_INT 1
14202: EQUAL
14203: OR
14204: AND
14205: PUSH
14206: LD_INT 94
14208: PPUSH
14209: CALL_OW 301
14213: NOT
14214: AND
14215: IFFALSE 15420
14217: GO 14219
14219: DISABLE
14220: LD_INT 0
14222: PPUSH
14223: PPUSH
14224: PPUSH
14225: PPUSH
14226: PPUSH
// begin uc_side := 5 ;
14227: LD_ADDR_OWVAR 20
14231: PUSH
14232: LD_INT 5
14234: ST_TO_ADDR
// uc_nation := 2 ;
14235: LD_ADDR_OWVAR 21
14239: PUSH
14240: LD_INT 2
14242: ST_TO_ADDR
// InitHc ;
14243: CALL_OW 19
// PrepareHuman ( sex_male , 3 , 8 ) ;
14247: LD_INT 1
14249: PPUSH
14250: LD_INT 3
14252: PPUSH
14253: LD_INT 8
14255: PPUSH
14256: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
14260: LD_ADDR_OWVAR 29
14264: PUSH
14265: LD_INT 12
14267: PUSH
14268: LD_INT 12
14270: PUSH
14271: EMPTY
14272: LIST
14273: LIST
14274: ST_TO_ADDR
// hc_name := Hans Fliege ;
14275: LD_ADDR_OWVAR 26
14279: PUSH
14280: LD_STRING Hans Fliege
14282: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
14283: LD_ADDR_OWVAR 33
14287: PUSH
14288: LD_STRING SecondCharsGal
14290: ST_TO_ADDR
// hc_face_number := 7 ;
14291: LD_ADDR_OWVAR 34
14295: PUSH
14296: LD_INT 7
14298: ST_TO_ADDR
// ar_mechanic := CreateHuman ;
14299: LD_ADDR_EXP 46
14303: PUSH
14304: CALL_OW 44
14308: ST_TO_ADDR
// InitHc ;
14309: CALL_OW 19
// PrepareHuman ( sex_male , 16 , 2 ) ;
14313: LD_INT 1
14315: PPUSH
14316: LD_INT 16
14318: PPUSH
14319: LD_INT 2
14321: PPUSH
14322: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
14326: LD_ADDR_OWVAR 29
14330: PUSH
14331: LD_INT 12
14333: PUSH
14334: LD_INT 12
14336: PUSH
14337: EMPTY
14338: LIST
14339: LIST
14340: ST_TO_ADDR
// hc_name :=  ;
14341: LD_ADDR_OWVAR 26
14345: PUSH
14346: LD_STRING 
14348: ST_TO_ADDR
// ar_mechanic_friend := CreateHuman ;
14349: LD_ADDR_EXP 47
14353: PUSH
14354: CALL_OW 44
14358: ST_TO_ADDR
// InitHc ;
14359: CALL_OW 19
// repeat wait ( 0 0$1 ) ;
14363: LD_INT 35
14365: PPUSH
14366: CALL_OW 67
// until not InBattle ( 1 ) ;
14370: LD_INT 1
14372: PPUSH
14373: CALL_OW 463
14377: NOT
14378: IFFALSE 14363
// wait ( 0 0$5 ) ;
14380: LD_INT 175
14382: PPUSH
14383: CALL_OW 67
// DialogueOn ;
14387: CALL_OW 6
// InGameOn ;
14391: CALL_OW 8
// un := UnitFilter ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , [ f_sex , sex_male ] ) [ 1 ] ;
14395: LD_ADDR_VAR 0 1
14399: PUSH
14400: LD_INT 22
14402: PUSH
14403: LD_INT 1
14405: PUSH
14406: EMPTY
14407: LIST
14408: LIST
14409: PUSH
14410: LD_INT 2
14412: PUSH
14413: LD_INT 25
14415: PUSH
14416: LD_INT 1
14418: PUSH
14419: EMPTY
14420: LIST
14421: LIST
14422: PUSH
14423: LD_INT 25
14425: PUSH
14426: LD_INT 2
14428: PUSH
14429: EMPTY
14430: LIST
14431: LIST
14432: PUSH
14433: LD_INT 25
14435: PUSH
14436: LD_INT 3
14438: PUSH
14439: EMPTY
14440: LIST
14441: LIST
14442: PUSH
14443: LD_INT 25
14445: PUSH
14446: LD_INT 4
14448: PUSH
14449: EMPTY
14450: LIST
14451: LIST
14452: PUSH
14453: LD_INT 25
14455: PUSH
14456: LD_INT 5
14458: PUSH
14459: EMPTY
14460: LIST
14461: LIST
14462: PUSH
14463: LD_INT 25
14465: PUSH
14466: LD_INT 8
14468: PUSH
14469: EMPTY
14470: LIST
14471: LIST
14472: PUSH
14473: EMPTY
14474: LIST
14475: LIST
14476: LIST
14477: LIST
14478: LIST
14479: LIST
14480: LIST
14481: PUSH
14482: EMPTY
14483: LIST
14484: LIST
14485: PPUSH
14486: CALL_OW 69
14490: PUSH
14491: LD_EXP 21
14495: PUSH
14496: LD_EXP 22
14500: PUSH
14501: LD_EXP 23
14505: PUSH
14506: LD_EXP 24
14510: PUSH
14511: LD_EXP 25
14515: PUSH
14516: LD_EXP 26
14520: PUSH
14521: LD_EXP 27
14525: PUSH
14526: LD_EXP 28
14530: PUSH
14531: LD_EXP 29
14535: PUSH
14536: LD_EXP 31
14540: PUSH
14541: LD_EXP 32
14545: PUSH
14546: LD_EXP 33
14550: PUSH
14551: LD_EXP 34
14555: PUSH
14556: EMPTY
14557: LIST
14558: LIST
14559: LIST
14560: LIST
14561: LIST
14562: LIST
14563: LIST
14564: LIST
14565: LIST
14566: LIST
14567: LIST
14568: LIST
14569: LIST
14570: DIFF
14571: PPUSH
14572: LD_INT 26
14574: PUSH
14575: LD_INT 1
14577: PUSH
14578: EMPTY
14579: LIST
14580: LIST
14581: PPUSH
14582: CALL_OW 72
14586: PUSH
14587: LD_INT 1
14589: ARRAY
14590: ST_TO_ADDR
// if Brown then
14591: LD_EXP 27
14595: IFFALSE 14607
// un := Brown ;
14597: LD_ADDR_VAR 0 1
14601: PUSH
14602: LD_EXP 27
14606: ST_TO_ADDR
// if un then
14607: LD_VAR 0 1
14611: IFFALSE 14637
// begin Say ( un , D7-Sol1-1 ) ;
14613: LD_VAR 0 1
14617: PPUSH
14618: LD_STRING D7-Sol1-1
14620: PPUSH
14621: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
14625: LD_EXP 21
14629: PPUSH
14630: LD_STRING D7-JMM-1
14632: PPUSH
14633: CALL_OW 88
// end ; SayRadio ( ar_mechanic , D7-Ar1-1 ) ;
14637: LD_EXP 46
14641: PPUSH
14642: LD_STRING D7-Ar1-1
14644: PPUSH
14645: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
14649: LD_EXP 21
14653: PPUSH
14654: LD_STRING D7-JMM-2
14656: PPUSH
14657: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-2 ) ;
14661: LD_EXP 46
14665: PPUSH
14666: LD_STRING D7-Ar1-2
14668: PPUSH
14669: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
14673: LD_EXP 21
14677: PPUSH
14678: LD_STRING D7-JMM-3
14680: PPUSH
14681: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-3 ) ;
14685: LD_EXP 46
14689: PPUSH
14690: LD_STRING D7-Ar1-3
14692: PPUSH
14693: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
14697: LD_EXP 21
14701: PPUSH
14702: LD_STRING D7-JMM-4
14704: PPUSH
14705: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-4 ) ;
14709: LD_EXP 46
14713: PPUSH
14714: LD_STRING D7-Ar1-4
14716: PPUSH
14717: CALL_OW 94
// InGameOff ;
14721: CALL_OW 9
// DialogueOff ;
14725: CALL_OW 7
// case Query ( QCameras ) of 1 :
14729: LD_STRING QCameras
14731: PPUSH
14732: CALL_OW 97
14736: PUSH
14737: LD_INT 1
14739: DOUBLE
14740: EQUAL
14741: IFTRUE 14745
14743: GO 14748
14745: POP
// ; 2 :
14746: GO 14762
14748: LD_INT 2
14750: DOUBLE
14751: EQUAL
14752: IFTRUE 14756
14754: GO 14761
14756: POP
// exit ; end ;
14757: GO 15420
14759: GO 14762
14761: POP
// ChangeMissionObjectives ( MCar ) ;
14762: LD_STRING MCar
14764: PPUSH
14765: CALL_OW 337
// PlaceSeeing ( 124 , 90 , 1 , - 6 ) ;
14769: LD_INT 124
14771: PPUSH
14772: LD_INT 90
14774: PPUSH
14775: LD_INT 1
14777: PPUSH
14778: LD_INT 6
14780: NEG
14781: PPUSH
14782: CALL_OW 330
// RemoveSeeing ( 124 , 90 , 1 ) ;
14786: LD_INT 124
14788: PPUSH
14789: LD_INT 90
14791: PPUSH
14792: LD_INT 1
14794: PPUSH
14795: CALL_OW 331
// SetAreaMapShow ( parking_marea , 1 ) ;
14799: LD_INT 12
14801: PPUSH
14802: LD_INT 1
14804: PPUSH
14805: CALL_OW 424
// wait ( 3 ) ;
14809: LD_INT 3
14811: PPUSH
14812: CALL_OW 67
// CenterNowOnXY ( 124 , 90 ) ;
14816: LD_INT 124
14818: PPUSH
14819: LD_INT 90
14821: PPUSH
14822: CALL_OW 86
// cargo := false ;
14826: LD_ADDR_VAR 0 3
14830: PUSH
14831: LD_INT 0
14833: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
14834: LD_INT 35
14836: PPUSH
14837: CALL_OW 67
// cargo := FilterUnitsInArea ( parking_marea , [ [ f_engine , engine_siberite ] , [ f_weapon , ar_cargo_bay ] , [ f_empty ] ] ) ;
14841: LD_ADDR_VAR 0 3
14845: PUSH
14846: LD_INT 12
14848: PPUSH
14849: LD_INT 32
14851: PUSH
14852: LD_INT 3
14854: PUSH
14855: EMPTY
14856: LIST
14857: LIST
14858: PUSH
14859: LD_INT 34
14861: PUSH
14862: LD_INT 32
14864: PUSH
14865: EMPTY
14866: LIST
14867: LIST
14868: PUSH
14869: LD_INT 58
14871: PUSH
14872: EMPTY
14873: LIST
14874: PUSH
14875: EMPTY
14876: LIST
14877: LIST
14878: LIST
14879: PPUSH
14880: CALL_OW 70
14884: ST_TO_ADDR
// until cargo ;
14885: LD_VAR 0 3
14889: IFFALSE 14834
// cargo := cargo [ 1 ] ;
14891: LD_ADDR_VAR 0 3
14895: PUSH
14896: LD_VAR 0 3
14900: PUSH
14901: LD_INT 1
14903: ARRAY
14904: ST_TO_ADDR
// SetSide ( cargo , 5 ) ;
14905: LD_VAR 0 3
14909: PPUSH
14910: LD_INT 5
14912: PPUSH
14913: CALL_OW 235
// SetAreaMapShow ( parking_marea , 0 ) ;
14917: LD_INT 12
14919: PPUSH
14920: LD_INT 0
14922: PPUSH
14923: CALL_OW 424
// PlaceUnitArea ( ar_mechanic , mechanic_spawn , false ) ;
14927: LD_EXP 46
14931: PPUSH
14932: LD_INT 11
14934: PPUSH
14935: LD_INT 0
14937: PPUSH
14938: CALL_OW 49
// PlaceUnitArea ( ar_mechanic_friend , mechanic_spawn , false ) ;
14942: LD_EXP 47
14946: PPUSH
14947: LD_INT 11
14949: PPUSH
14950: LD_INT 0
14952: PPUSH
14953: CALL_OW 49
// ComMoveToArea ( [ ar_mechanic , ar_mechanic_friend ] , parking_marea ) ;
14957: LD_EXP 46
14961: PUSH
14962: LD_EXP 47
14966: PUSH
14967: EMPTY
14968: LIST
14969: LIST
14970: PPUSH
14971: LD_INT 12
14973: PPUSH
14974: CALL_OW 113
// AddComEnterUnit ( ar_mechanic , cargo ) ;
14978: LD_EXP 46
14982: PPUSH
14983: LD_VAR 0 3
14987: PPUSH
14988: CALL_OW 180
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
14992: LD_EXP 46
14996: PUSH
14997: LD_EXP 47
15001: PUSH
15002: EMPTY
15003: LIST
15004: LIST
15005: PPUSH
15006: LD_INT 209
15008: PPUSH
15009: LD_INT 178
15011: PPUSH
15012: CALL_OW 171
// escaped := 0 ;
15016: LD_ADDR_VAR 0 5
15020: PUSH
15021: LD_INT 0
15023: ST_TO_ADDR
// while ( true ) do
15024: LD_INT 1
15026: IFFALSE 15242
// begin wait ( 0 0$1 ) ;
15028: LD_INT 35
15030: PPUSH
15031: CALL_OW 67
// if not HasTask ( ar_mechanic ) or not HasTask ( ar_mechanic_friend ) then
15035: LD_EXP 46
15039: PPUSH
15040: CALL_OW 314
15044: NOT
15045: PUSH
15046: LD_EXP 47
15050: PPUSH
15051: CALL_OW 314
15055: NOT
15056: OR
15057: IFFALSE 15083
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
15059: LD_EXP 46
15063: PUSH
15064: LD_EXP 47
15068: PUSH
15069: EMPTY
15070: LIST
15071: LIST
15072: PPUSH
15073: LD_INT 209
15075: PPUSH
15076: LD_INT 178
15078: PPUSH
15079: CALL_OW 171
// if IsInArea ( ar_mechanic , escape_area ) then
15083: LD_EXP 46
15087: PPUSH
15088: LD_INT 10
15090: PPUSH
15091: CALL_OW 308
15095: IFFALSE 15120
// begin RemoveUnit ( ar_mechanic ) ;
15097: LD_EXP 46
15101: PPUSH
15102: CALL_OW 64
// escaped := escaped + 1 ;
15106: LD_ADDR_VAR 0 5
15110: PUSH
15111: LD_VAR 0 5
15115: PUSH
15116: LD_INT 1
15118: PLUS
15119: ST_TO_ADDR
// end ; if IsInArea ( ar_mechanic_friend , escape_area ) then
15120: LD_EXP 47
15124: PPUSH
15125: LD_INT 10
15127: PPUSH
15128: CALL_OW 308
15132: IFFALSE 15157
// begin RemoveUnit ( ar_mechanic_friend ) ;
15134: LD_EXP 47
15138: PPUSH
15139: CALL_OW 64
// escaped := escaped + 1 ;
15143: LD_ADDR_VAR 0 5
15147: PUSH
15148: LD_VAR 0 5
15152: PUSH
15153: LD_INT 1
15155: PLUS
15156: ST_TO_ADDR
// end ; if IsInArea ( cargo , escape_area ) then
15157: LD_VAR 0 3
15161: PPUSH
15162: LD_INT 10
15164: PPUSH
15165: CALL_OW 308
15169: IFFALSE 15180
// RemoveUnit ( cargo ) ;
15171: LD_VAR 0 3
15175: PPUSH
15176: CALL_OW 64
// if not IsPlaced ( ar_mechanic ) and escaped >= 2 then
15180: LD_EXP 46
15184: PPUSH
15185: CALL_OW 305
15189: NOT
15190: PUSH
15191: LD_VAR 0 5
15195: PUSH
15196: LD_INT 2
15198: GREATEREQUAL
15199: AND
15200: IFFALSE 15204
// break ;
15202: GO 15242
// if not IsPlaced ( ar_mechanic ) and not IsPlaced ( ar_mechanic_friend ) and escaped < 2 then
15204: LD_EXP 46
15208: PPUSH
15209: CALL_OW 305
15213: NOT
15214: PUSH
15215: LD_EXP 47
15219: PPUSH
15220: CALL_OW 305
15224: NOT
15225: AND
15226: PUSH
15227: LD_VAR 0 5
15231: PUSH
15232: LD_INT 2
15234: LESS
15235: AND
15236: IFFALSE 15240
// exit ;
15238: GO 15420
// end ;
15240: GO 15024
// wait ( 0 0$2 ) ;
15242: LD_INT 70
15244: PPUSH
15245: CALL_OW 67
// SayRadio ( ar_mechanic , D7a-Ar1-1 ) ;
15249: LD_EXP 46
15253: PPUSH
15254: LD_STRING D7a-Ar1-1
15256: PPUSH
15257: CALL_OW 94
// tmp := [ [ 129 , 10 ] , [ 103 , 6 ] , [ 148 , 47 ] , [ 155 , 16 ] ] ;
15261: LD_ADDR_VAR 0 4
15265: PUSH
15266: LD_INT 129
15268: PUSH
15269: LD_INT 10
15271: PUSH
15272: EMPTY
15273: LIST
15274: LIST
15275: PUSH
15276: LD_INT 103
15278: PUSH
15279: LD_INT 6
15281: PUSH
15282: EMPTY
15283: LIST
15284: LIST
15285: PUSH
15286: LD_INT 148
15288: PUSH
15289: LD_INT 47
15291: PUSH
15292: EMPTY
15293: LIST
15294: LIST
15295: PUSH
15296: LD_INT 155
15298: PUSH
15299: LD_INT 16
15301: PUSH
15302: EMPTY
15303: LIST
15304: LIST
15305: PUSH
15306: EMPTY
15307: LIST
15308: LIST
15309: LIST
15310: LIST
15311: ST_TO_ADDR
// if Difficulty = 1 then
15312: LD_OWVAR 67
15316: PUSH
15317: LD_INT 1
15319: EQUAL
15320: IFFALSE 15357
// tmp := tmp ^ [ [ 78 , 7 ] , [ 104 , 43 ] ] ;
15322: LD_ADDR_VAR 0 4
15326: PUSH
15327: LD_VAR 0 4
15331: PUSH
15332: LD_INT 78
15334: PUSH
15335: LD_INT 7
15337: PUSH
15338: EMPTY
15339: LIST
15340: LIST
15341: PUSH
15342: LD_INT 104
15344: PUSH
15345: LD_INT 43
15347: PUSH
15348: EMPTY
15349: LIST
15350: LIST
15351: PUSH
15352: EMPTY
15353: LIST
15354: LIST
15355: ADD
15356: ST_TO_ADDR
// for i in tmp do
15357: LD_ADDR_VAR 0 2
15361: PUSH
15362: LD_VAR 0 4
15366: PUSH
15367: FOR_IN
15368: IFFALSE 15401
// PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 9 ) ;
15370: LD_VAR 0 2
15374: PUSH
15375: LD_INT 1
15377: ARRAY
15378: PPUSH
15379: LD_VAR 0 2
15383: PUSH
15384: LD_INT 2
15386: ARRAY
15387: PPUSH
15388: LD_INT 1
15390: PPUSH
15391: LD_INT 9
15393: NEG
15394: PPUSH
15395: CALL_OW 330
15399: GO 15367
15401: POP
15402: POP
// SetAchievement ( ACH_FRIEND ) ;
15403: LD_STRING ACH_FRIEND
15405: PPUSH
15406: CALL_OW 543
// CenterOnXY ( 129 , 10 ) ;
15410: LD_INT 129
15412: PPUSH
15413: LD_INT 10
15415: PPUSH
15416: CALL_OW 84
// end ;
15420: PPOPN 5
15422: END
// every 0 0$1 trigger game_time - 10 10$00 <= tick do
15423: LD_EXP 15
15427: PUSH
15428: LD_INT 21000
15430: MINUS
15431: PUSH
15432: LD_OWVAR 1
15436: LESSEQUAL
15437: IFFALSE 15477
15439: GO 15441
15441: DISABLE
// begin powell_warn := true ;
15442: LD_ADDR_EXP 16
15446: PUSH
15447: LD_INT 1
15449: ST_TO_ADDR
// DialogueOn ;
15450: CALL_OW 6
// SayRadio ( Powell , D9-Pow-1 ) ;
15454: LD_EXP 30
15458: PPUSH
15459: LD_STRING D9-Pow-1
15461: PPUSH
15462: CALL_OW 94
// dwait ( 0 0$0.3 ) ;
15466: LD_INT 10
15468: PPUSH
15469: CALL_OW 68
// DialogueOff ;
15473: CALL_OW 7
// end ;
15477: END
// every 0 0$1 trigger game_time <= tick do
15478: LD_EXP 15
15482: PUSH
15483: LD_OWVAR 1
15487: LESSEQUAL
15488: IFFALSE 15527
15490: GO 15492
15492: DISABLE
// begin DialogueOn ;
15493: CALL_OW 6
// SayRadio ( Powell , D9a-Pow-1 ) ;
15497: LD_EXP 30
15501: PPUSH
15502: LD_STRING D9a-Pow-1
15504: PPUSH
15505: CALL_OW 94
// dwait ( 0 0$2 ) ;
15509: LD_INT 70
15511: PPUSH
15512: CALL_OW 68
// DialogueOff ;
15516: CALL_OW 7
// YouLost ( Command ) ;
15520: LD_STRING Command
15522: PPUSH
15523: CALL_OW 104
// end ;
15527: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_warehouse ] ] ) = 0 and IsOk ( JMM ) do
15528: LD_INT 22
15530: PUSH
15531: LD_INT 2
15533: PUSH
15534: EMPTY
15535: LIST
15536: LIST
15537: PUSH
15538: LD_INT 30
15540: PUSH
15541: LD_INT 1
15543: PUSH
15544: EMPTY
15545: LIST
15546: LIST
15547: PUSH
15548: EMPTY
15549: LIST
15550: LIST
15551: PPUSH
15552: CALL_OW 69
15556: PUSH
15557: LD_INT 0
15559: EQUAL
15560: PUSH
15561: LD_EXP 21
15565: PPUSH
15566: CALL_OW 302
15570: AND
15571: IFFALSE 15619
15573: GO 15575
15575: DISABLE
// begin case Query ( QEndMission ) of 1 :
15576: LD_STRING QEndMission
15578: PPUSH
15579: CALL_OW 97
15583: PUSH
15584: LD_INT 1
15586: DOUBLE
15587: EQUAL
15588: IFTRUE 15592
15590: GO 15603
15592: POP
// end_the_mission_allowed := true ; 2 :
15593: LD_ADDR_OWVAR 57
15597: PUSH
15598: LD_INT 1
15600: ST_TO_ADDR
15601: GO 15619
15603: LD_INT 2
15605: DOUBLE
15606: EQUAL
15607: IFTRUE 15611
15609: GO 15618
15611: POP
// EndMission ; end ;
15612: CALL 15627 0 0
15616: GO 15619
15618: POP
// end ;
15619: END
// on EndTheMissionRaised ( p ) do begin EndMission ;
15620: CALL 15627 0 0
// end ;
15624: PPOPN 1
15626: END
// function EndMission ; var tmp , m1 , m2 , m3 ; begin
15627: LD_INT 0
15629: PPUSH
15630: PPUSH
15631: PPUSH
15632: PPUSH
15633: PPUSH
// m1 := false ;
15634: LD_ADDR_VAR 0 3
15638: PUSH
15639: LD_INT 0
15641: ST_TO_ADDR
// m2 := false ;
15642: LD_ADDR_VAR 0 4
15646: PUSH
15647: LD_INT 0
15649: ST_TO_ADDR
// m3 := false ;
15650: LD_ADDR_VAR 0 5
15654: PUSH
15655: LD_INT 0
15657: ST_TO_ADDR
// if not am_veh_consturcted then
15658: LD_EXP 20
15662: NOT
15663: IFFALSE 15672
// SetAchievement ( ACH_ARABTECH ) ;
15665: LD_STRING ACH_ARABTECH
15667: PPUSH
15668: CALL_OW 543
// if tick < [ 120 120$00 , 100 100$00 , 95 95$00 , 92 92$00 ] [ Difficulty ] then
15672: LD_OWVAR 1
15676: PUSH
15677: LD_INT 252000
15679: PUSH
15680: LD_INT 210000
15682: PUSH
15683: LD_INT 199500
15685: PUSH
15686: LD_INT 193200
15688: PUSH
15689: EMPTY
15690: LIST
15691: LIST
15692: LIST
15693: LIST
15694: PUSH
15695: LD_OWVAR 67
15699: ARRAY
15700: LESS
15701: IFFALSE 15723
// begin m3 := true ;
15703: LD_ADDR_VAR 0 5
15707: PUSH
15708: LD_INT 1
15710: ST_TO_ADDR
// AddMedal ( Time1 , 1 ) ;
15711: LD_STRING Time1
15713: PPUSH
15714: LD_INT 1
15716: PPUSH
15717: CALL_OW 101
// end else
15721: GO 15754
// if not powell_warn then
15723: LD_EXP 16
15727: NOT
15728: IFFALSE 15743
// AddMedal ( Time1 , - 1 ) else
15730: LD_STRING Time1
15732: PPUSH
15733: LD_INT 1
15735: NEG
15736: PPUSH
15737: CALL_OW 101
15741: GO 15754
// AddMedal ( Time1 , - 2 ) ;
15743: LD_STRING Time1
15745: PPUSH
15746: LD_INT 2
15748: NEG
15749: PPUSH
15750: CALL_OW 101
// if loses_counter >= [ 5 , 4 , 3 , 3 ] [ Difficulty ] then
15754: LD_EXP 17
15758: PUSH
15759: LD_INT 5
15761: PUSH
15762: LD_INT 4
15764: PUSH
15765: LD_INT 3
15767: PUSH
15768: LD_INT 3
15770: PUSH
15771: EMPTY
15772: LIST
15773: LIST
15774: LIST
15775: LIST
15776: PUSH
15777: LD_OWVAR 67
15781: ARRAY
15782: GREATEREQUAL
15783: IFFALSE 15798
// AddMedal ( Destroy , - 2 ) else
15785: LD_STRING Destroy
15787: PPUSH
15788: LD_INT 2
15790: NEG
15791: PPUSH
15792: CALL_OW 101
15796: GO 15931
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 25 then
15798: LD_INT 22
15800: PUSH
15801: LD_INT 2
15803: PUSH
15804: EMPTY
15805: LIST
15806: LIST
15807: PUSH
15808: LD_INT 21
15810: PUSH
15811: LD_INT 3
15813: PUSH
15814: EMPTY
15815: LIST
15816: LIST
15817: PUSH
15818: LD_INT 50
15820: PUSH
15821: EMPTY
15822: LIST
15823: PUSH
15824: EMPTY
15825: LIST
15826: LIST
15827: LIST
15828: PPUSH
15829: CALL_OW 69
15833: PUSH
15834: LD_INT 25
15836: GREATEREQUAL
15837: IFFALSE 15852
// AddMedal ( Destroy , - 1 ) else
15839: LD_STRING Destroy
15841: PPUSH
15842: LD_INT 1
15844: NEG
15845: PPUSH
15846: CALL_OW 101
15850: GO 15931
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 15 then
15852: LD_INT 22
15854: PUSH
15855: LD_INT 2
15857: PUSH
15858: EMPTY
15859: LIST
15860: LIST
15861: PUSH
15862: LD_INT 21
15864: PUSH
15865: LD_INT 3
15867: PUSH
15868: EMPTY
15869: LIST
15870: LIST
15871: PUSH
15872: LD_INT 50
15874: PUSH
15875: EMPTY
15876: LIST
15877: PUSH
15878: EMPTY
15879: LIST
15880: LIST
15881: LIST
15882: PPUSH
15883: CALL_OW 69
15887: PUSH
15888: LD_INT 15
15890: GREATEREQUAL
15891: IFFALSE 15913
// begin m1 := true ;
15893: LD_ADDR_VAR 0 3
15897: PUSH
15898: LD_INT 1
15900: ST_TO_ADDR
// AddMedal ( Destroy , 1 ) ;
15901: LD_STRING Destroy
15903: PPUSH
15904: LD_INT 1
15906: PPUSH
15907: CALL_OW 101
// end else
15911: GO 15931
// begin m1 := true ;
15913: LD_ADDR_VAR 0 3
15917: PUSH
15918: LD_INT 1
15920: ST_TO_ADDR
// AddMedal ( Destroy , 2 ) ;
15921: LD_STRING Destroy
15923: PPUSH
15924: LD_INT 2
15926: PPUSH
15927: CALL_OW 101
// end ; SaveVariable ( artifact_get , 11_artifact_captured ) ;
15931: LD_EXP 13
15935: PPUSH
15936: LD_STRING 11_artifact_captured
15938: PPUSH
15939: CALL_OW 39
// if artifact_get then
15943: LD_EXP 13
15947: IFFALSE 15969
// begin m2 := true ;
15949: LD_ADDR_VAR 0 4
15953: PUSH
15954: LD_INT 1
15956: ST_TO_ADDR
// AddMedal ( Artefact , 1 ) ;
15957: LD_STRING Artefact
15959: PPUSH
15960: LD_INT 1
15962: PPUSH
15963: CALL_OW 101
// end else
15967: GO 15980
// AddMedal ( Artefact , - 1 ) ;
15969: LD_STRING Artefact
15971: PPUSH
15972: LD_INT 1
15974: NEG
15975: PPUSH
15976: CALL_OW 101
// if m1 and m2 and m3 and Difficulty >= 3 then
15980: LD_VAR 0 3
15984: PUSH
15985: LD_VAR 0 4
15989: AND
15990: PUSH
15991: LD_VAR 0 5
15995: AND
15996: PUSH
15997: LD_OWVAR 67
16001: PUSH
16002: LD_INT 3
16004: GREATEREQUAL
16005: AND
16006: IFFALSE 16018
// SetAchievementEX ( ACH_AMER , 11 ) ;
16008: LD_STRING ACH_AMER
16010: PPUSH
16011: LD_INT 11
16013: PPUSH
16014: CALL_OW 564
// if m1 and m2 and m3 and loses_counter = 0 then
16018: LD_VAR 0 3
16022: PUSH
16023: LD_VAR 0 4
16027: AND
16028: PUSH
16029: LD_VAR 0 5
16033: AND
16034: PUSH
16035: LD_EXP 17
16039: PUSH
16040: LD_INT 0
16042: EQUAL
16043: AND
16044: IFFALSE 16060
// begin wait ( 3 ) ;
16046: LD_INT 3
16048: PPUSH
16049: CALL_OW 67
// SetAchievement ( ACH_GENERAL ) ;
16053: LD_STRING ACH_GENERAL
16055: PPUSH
16056: CALL_OW 543
// end ; if tick <= 100 100$00 then
16060: LD_OWVAR 1
16064: PUSH
16065: LD_INT 210000
16067: LESSEQUAL
16068: IFFALSE 16084
// begin wait ( 3 ) ;
16070: LD_INT 3
16072: PPUSH
16073: CALL_OW 67
// SetAchievement ( ACH_ASPEED_11 ) ;
16077: LD_STRING ACH_ASPEED_11
16079: PPUSH
16080: CALL_OW 543
// end ; GiveMedals ( MAIN ) ;
16084: LD_STRING MAIN
16086: PPUSH
16087: CALL_OW 102
// selected := UnitFilter ( selected , [ f_alive ] ) ;
16091: LD_ADDR_EXP 19
16095: PUSH
16096: LD_EXP 19
16100: PPUSH
16101: LD_INT 51
16103: PUSH
16104: EMPTY
16105: LIST
16106: PPUSH
16107: CALL_OW 72
16111: ST_TO_ADDR
// tmp := JMM ^ selected ;
16112: LD_ADDR_VAR 0 2
16116: PUSH
16117: LD_EXP 21
16121: PUSH
16122: LD_EXP 19
16126: ADD
16127: ST_TO_ADDR
// RewardPeople ( tmp ) ;
16128: LD_VAR 0 2
16132: PPUSH
16133: CALL_OW 43
// SaveCharacters ( tmp diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , 11c_others ) ;
16137: LD_VAR 0 2
16141: PUSH
16142: LD_EXP 21
16146: PUSH
16147: LD_EXP 22
16151: PUSH
16152: LD_EXP 23
16156: PUSH
16157: LD_EXP 24
16161: PUSH
16162: LD_EXP 25
16166: PUSH
16167: LD_EXP 26
16171: PUSH
16172: LD_EXP 27
16176: PUSH
16177: LD_EXP 28
16181: PUSH
16182: LD_EXP 29
16186: PUSH
16187: LD_EXP 31
16191: PUSH
16192: LD_EXP 32
16196: PUSH
16197: LD_EXP 33
16201: PUSH
16202: LD_EXP 34
16206: PUSH
16207: EMPTY
16208: LIST
16209: LIST
16210: LIST
16211: LIST
16212: LIST
16213: LIST
16214: LIST
16215: LIST
16216: LIST
16217: LIST
16218: LIST
16219: LIST
16220: LIST
16221: DIFF
16222: PPUSH
16223: LD_STRING 11c_others
16225: PPUSH
16226: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
16230: LD_EXP 21
16234: PPUSH
16235: LD_EXP 3
16239: PUSH
16240: LD_STRING JMM
16242: STR
16243: PPUSH
16244: CALL_OW 38
// if Lisa then
16248: LD_EXP 22
16252: IFFALSE 16272
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
16254: LD_EXP 22
16258: PPUSH
16259: LD_EXP 3
16263: PUSH
16264: LD_STRING Lisa
16266: STR
16267: PPUSH
16268: CALL_OW 38
// if Donaldson then
16272: LD_EXP 23
16276: IFFALSE 16296
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
16278: LD_EXP 23
16282: PPUSH
16283: LD_EXP 3
16287: PUSH
16288: LD_STRING Donaldson
16290: STR
16291: PPUSH
16292: CALL_OW 38
// if Bobby then
16296: LD_EXP 24
16300: IFFALSE 16320
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
16302: LD_EXP 24
16306: PPUSH
16307: LD_EXP 3
16311: PUSH
16312: LD_STRING Bobby
16314: STR
16315: PPUSH
16316: CALL_OW 38
// if Cyrus then
16320: LD_EXP 25
16324: IFFALSE 16344
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
16326: LD_EXP 25
16330: PPUSH
16331: LD_EXP 3
16335: PUSH
16336: LD_STRING Cyrus
16338: STR
16339: PPUSH
16340: CALL_OW 38
// if Denis then
16344: LD_EXP 26
16348: IFFALSE 16368
// SaveCharacters ( Denis , mission_prefix & Denis ) ;
16350: LD_EXP 26
16354: PPUSH
16355: LD_EXP 3
16359: PUSH
16360: LD_STRING Denis
16362: STR
16363: PPUSH
16364: CALL_OW 38
// if Brown then
16368: LD_EXP 27
16372: IFFALSE 16392
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
16374: LD_EXP 27
16378: PPUSH
16379: LD_EXP 3
16383: PUSH
16384: LD_STRING Brown
16386: STR
16387: PPUSH
16388: CALL_OW 38
// if Gladstone then
16392: LD_EXP 28
16396: IFFALSE 16416
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
16398: LD_EXP 28
16402: PPUSH
16403: LD_EXP 3
16407: PUSH
16408: LD_STRING Gladstone
16410: STR
16411: PPUSH
16412: CALL_OW 38
// if Houten then
16416: LD_EXP 29
16420: IFFALSE 16440
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
16422: LD_EXP 29
16426: PPUSH
16427: LD_EXP 3
16431: PUSH
16432: LD_STRING Houten
16434: STR
16435: PPUSH
16436: CALL_OW 38
// if Cornel then
16440: LD_EXP 31
16444: IFFALSE 16464
// SaveCharacters ( Cornel , mission_prefix & Cornell ) ;
16446: LD_EXP 31
16450: PPUSH
16451: LD_EXP 3
16455: PUSH
16456: LD_STRING Cornell
16458: STR
16459: PPUSH
16460: CALL_OW 38
// if Gary then
16464: LD_EXP 32
16468: IFFALSE 16488
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
16470: LD_EXP 32
16474: PPUSH
16475: LD_EXP 3
16479: PUSH
16480: LD_STRING Gary
16482: STR
16483: PPUSH
16484: CALL_OW 38
// if Frank then
16488: LD_EXP 33
16492: IFFALSE 16512
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
16494: LD_EXP 33
16498: PPUSH
16499: LD_EXP 3
16503: PUSH
16504: LD_STRING Frank
16506: STR
16507: PPUSH
16508: CALL_OW 38
// if Kikuchi then
16512: LD_EXP 34
16516: IFFALSE 16536
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
16518: LD_EXP 34
16522: PPUSH
16523: LD_EXP 3
16527: PUSH
16528: LD_STRING Kikuchi
16530: STR
16531: PPUSH
16532: CALL_OW 38
// YouWin ;
16536: CALL_OW 103
// end ;
16540: LD_VAR 0 1
16544: RET
// export function CanSayRand ( side ) ; begin
16545: LD_INT 0
16547: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16548: LD_ADDR_VAR 0 2
16552: PUSH
16553: LD_INT 52
16555: PUSH
16556: EMPTY
16557: LIST
16558: PUSH
16559: LD_INT 22
16561: PUSH
16562: LD_VAR 0 1
16566: PUSH
16567: EMPTY
16568: LIST
16569: LIST
16570: PUSH
16571: LD_INT 2
16573: PUSH
16574: LD_INT 25
16576: PUSH
16577: LD_INT 1
16579: PUSH
16580: EMPTY
16581: LIST
16582: LIST
16583: PUSH
16584: LD_INT 25
16586: PUSH
16587: LD_INT 2
16589: PUSH
16590: EMPTY
16591: LIST
16592: LIST
16593: PUSH
16594: LD_INT 25
16596: PUSH
16597: LD_INT 3
16599: PUSH
16600: EMPTY
16601: LIST
16602: LIST
16603: PUSH
16604: LD_INT 25
16606: PUSH
16607: LD_INT 4
16609: PUSH
16610: EMPTY
16611: LIST
16612: LIST
16613: PUSH
16614: EMPTY
16615: LIST
16616: LIST
16617: LIST
16618: LIST
16619: LIST
16620: PUSH
16621: EMPTY
16622: LIST
16623: LIST
16624: LIST
16625: PPUSH
16626: CALL_OW 69
16630: PUSH
16631: LD_EXP 21
16635: PUSH
16636: LD_EXP 33
16640: PUSH
16641: LD_EXP 22
16645: PUSH
16646: LD_EXP 23
16650: PUSH
16651: LD_EXP 24
16655: PUSH
16656: LD_EXP 25
16660: PUSH
16661: LD_EXP 26
16665: PUSH
16666: LD_EXP 27
16670: PUSH
16671: LD_EXP 28
16675: PUSH
16676: LD_EXP 29
16680: PUSH
16681: LD_EXP 30
16685: PUSH
16686: LD_EXP 31
16690: PUSH
16691: LD_EXP 32
16695: PUSH
16696: LD_EXP 34
16700: PUSH
16701: EMPTY
16702: LIST
16703: LIST
16704: LIST
16705: LIST
16706: LIST
16707: LIST
16708: LIST
16709: LIST
16710: LIST
16711: LIST
16712: LIST
16713: LIST
16714: LIST
16715: LIST
16716: DIFF
16717: ST_TO_ADDR
// end ;
16718: LD_VAR 0 2
16722: RET
// export function SayRand ( sex , dial ) ; begin
16723: LD_INT 0
16725: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16726: LD_ADDR_VAR 0 3
16730: PUSH
16731: LD_INT 52
16733: PUSH
16734: EMPTY
16735: LIST
16736: PUSH
16737: LD_INT 22
16739: PUSH
16740: LD_INT 1
16742: PUSH
16743: EMPTY
16744: LIST
16745: LIST
16746: PUSH
16747: LD_INT 26
16749: PUSH
16750: LD_VAR 0 1
16754: PUSH
16755: EMPTY
16756: LIST
16757: LIST
16758: PUSH
16759: LD_INT 2
16761: PUSH
16762: LD_INT 25
16764: PUSH
16765: LD_INT 1
16767: PUSH
16768: EMPTY
16769: LIST
16770: LIST
16771: PUSH
16772: LD_INT 25
16774: PUSH
16775: LD_INT 2
16777: PUSH
16778: EMPTY
16779: LIST
16780: LIST
16781: PUSH
16782: LD_INT 25
16784: PUSH
16785: LD_INT 3
16787: PUSH
16788: EMPTY
16789: LIST
16790: LIST
16791: PUSH
16792: LD_INT 25
16794: PUSH
16795: LD_INT 4
16797: PUSH
16798: EMPTY
16799: LIST
16800: LIST
16801: PUSH
16802: EMPTY
16803: LIST
16804: LIST
16805: LIST
16806: LIST
16807: LIST
16808: PUSH
16809: EMPTY
16810: LIST
16811: LIST
16812: LIST
16813: LIST
16814: PPUSH
16815: CALL_OW 69
16819: PUSH
16820: LD_EXP 21
16824: PUSH
16825: LD_EXP 33
16829: PUSH
16830: LD_EXP 22
16834: PUSH
16835: LD_EXP 23
16839: PUSH
16840: LD_EXP 24
16844: PUSH
16845: LD_EXP 25
16849: PUSH
16850: LD_EXP 26
16854: PUSH
16855: LD_EXP 27
16859: PUSH
16860: LD_EXP 28
16864: PUSH
16865: LD_EXP 29
16869: PUSH
16870: LD_EXP 30
16874: PUSH
16875: LD_EXP 31
16879: PUSH
16880: LD_EXP 32
16884: PUSH
16885: LD_EXP 34
16889: PUSH
16890: EMPTY
16891: LIST
16892: LIST
16893: LIST
16894: LIST
16895: LIST
16896: LIST
16897: LIST
16898: LIST
16899: LIST
16900: LIST
16901: LIST
16902: LIST
16903: LIST
16904: LIST
16905: DIFF
16906: ST_TO_ADDR
// if not result then
16907: LD_VAR 0 3
16911: NOT
16912: IFFALSE 16916
// exit ;
16914: GO 16944
// result := result [ 1 ] ;
16916: LD_ADDR_VAR 0 3
16920: PUSH
16921: LD_VAR 0 3
16925: PUSH
16926: LD_INT 1
16928: ARRAY
16929: ST_TO_ADDR
// Say ( result , dial ) ;
16930: LD_VAR 0 3
16934: PPUSH
16935: LD_VAR 0 2
16939: PPUSH
16940: CALL_OW 88
// end ;
16944: LD_VAR 0 3
16948: RET
// export function SayRand2 ( sex , dial , filter ) ; begin
16949: LD_INT 0
16951: PPUSH
// result := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ^ filter ;
16952: LD_ADDR_VAR 0 4
16956: PUSH
16957: LD_INT 22
16959: PUSH
16960: LD_INT 1
16962: PUSH
16963: EMPTY
16964: LIST
16965: LIST
16966: PUSH
16967: LD_INT 26
16969: PUSH
16970: LD_VAR 0 1
16974: PUSH
16975: EMPTY
16976: LIST
16977: LIST
16978: PUSH
16979: LD_INT 2
16981: PUSH
16982: LD_INT 25
16984: PUSH
16985: LD_INT 1
16987: PUSH
16988: EMPTY
16989: LIST
16990: LIST
16991: PUSH
16992: LD_INT 25
16994: PUSH
16995: LD_INT 2
16997: PUSH
16998: EMPTY
16999: LIST
17000: LIST
17001: PUSH
17002: LD_INT 25
17004: PUSH
17005: LD_INT 3
17007: PUSH
17008: EMPTY
17009: LIST
17010: LIST
17011: PUSH
17012: LD_INT 25
17014: PUSH
17015: LD_INT 4
17017: PUSH
17018: EMPTY
17019: LIST
17020: LIST
17021: PUSH
17022: EMPTY
17023: LIST
17024: LIST
17025: LIST
17026: LIST
17027: LIST
17028: PUSH
17029: EMPTY
17030: LIST
17031: LIST
17032: LIST
17033: PPUSH
17034: CALL_OW 69
17038: PUSH
17039: LD_EXP 21
17043: PUSH
17044: LD_EXP 33
17048: PUSH
17049: LD_EXP 22
17053: PUSH
17054: LD_EXP 23
17058: PUSH
17059: LD_EXP 24
17063: PUSH
17064: LD_EXP 25
17068: PUSH
17069: LD_EXP 26
17073: PUSH
17074: LD_EXP 27
17078: PUSH
17079: LD_EXP 28
17083: PUSH
17084: LD_EXP 29
17088: PUSH
17089: LD_EXP 30
17093: PUSH
17094: LD_EXP 31
17098: PUSH
17099: LD_EXP 32
17103: PUSH
17104: LD_EXP 34
17108: PUSH
17109: EMPTY
17110: LIST
17111: LIST
17112: LIST
17113: LIST
17114: LIST
17115: LIST
17116: LIST
17117: LIST
17118: LIST
17119: LIST
17120: LIST
17121: LIST
17122: LIST
17123: LIST
17124: PUSH
17125: LD_VAR 0 3
17129: ADD
17130: DIFF
17131: ST_TO_ADDR
// if not result then
17132: LD_VAR 0 4
17136: NOT
17137: IFFALSE 17141
// exit ;
17139: GO 17169
// result := result [ 1 ] ;
17141: LD_ADDR_VAR 0 4
17145: PUSH
17146: LD_VAR 0 4
17150: PUSH
17151: LD_INT 1
17153: ARRAY
17154: ST_TO_ADDR
// Say ( result , dial ) ;
17155: LD_VAR 0 4
17159: PPUSH
17160: LD_VAR 0 2
17164: PPUSH
17165: CALL_OW 88
// end ; end_of_file
17169: LD_VAR 0 4
17173: RET
// export function CustomEvent ( event ) ; begin
17174: LD_INT 0
17176: PPUSH
// end ;
17177: LD_VAR 0 2
17181: RET
// on ArtifactLoaded ( cargo , artifact ) do begin if GetSide ( cargo ) = 1 then
17182: LD_VAR 0 1
17186: PPUSH
17187: CALL_OW 255
17191: PUSH
17192: LD_INT 1
17194: EQUAL
17195: IFFALSE 17205
// artifact_get := true ;
17197: LD_ADDR_EXP 13
17201: PUSH
17202: LD_INT 1
17204: ST_TO_ADDR
// if GetSide ( cargo ) = 2 then
17205: LD_VAR 0 1
17209: PPUSH
17210: CALL_OW 255
17214: PUSH
17215: LD_INT 2
17217: EQUAL
17218: IFFALSE 17236
// begin artifact_get := false ;
17220: LD_ADDR_EXP 13
17224: PUSH
17225: LD_INT 0
17227: ST_TO_ADDR
// artifact_stolen := true ;
17228: LD_ADDR_EXP 12
17232: PUSH
17233: LD_INT 1
17235: ST_TO_ADDR
// end ; artifact_oncargo := true ;
17236: LD_ADDR_EXP 14
17240: PUSH
17241: LD_INT 1
17243: ST_TO_ADDR
// end ;
17244: PPOPN 2
17246: END
// on ArtifactUnloaded ( cargo , artifact ) do begin artifact_oncargo := false ;
17247: LD_ADDR_EXP 14
17251: PUSH
17252: LD_INT 0
17254: ST_TO_ADDR
// end ;
17255: PPOPN 2
17257: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
17258: LD_VAR 0 1
17262: PPUSH
17263: CALL 105703 0 1
// if un = JMM then
17267: LD_VAR 0 1
17271: PUSH
17272: LD_EXP 21
17276: EQUAL
17277: IFFALSE 17288
// begin YouLost ( JMM ) ;
17279: LD_STRING JMM
17281: PPUSH
17282: CALL_OW 104
// exit ;
17286: GO 17420
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) then
17288: LD_VAR 0 1
17292: PUSH
17293: LD_INT 22
17295: PUSH
17296: LD_INT 1
17298: PUSH
17299: EMPTY
17300: LIST
17301: LIST
17302: PUSH
17303: LD_INT 21
17305: PUSH
17306: LD_INT 1
17308: PUSH
17309: EMPTY
17310: LIST
17311: LIST
17312: PUSH
17313: LD_INT 2
17315: PUSH
17316: LD_INT 25
17318: PUSH
17319: LD_INT 1
17321: PUSH
17322: EMPTY
17323: LIST
17324: LIST
17325: PUSH
17326: LD_INT 25
17328: PUSH
17329: LD_INT 2
17331: PUSH
17332: EMPTY
17333: LIST
17334: LIST
17335: PUSH
17336: LD_INT 25
17338: PUSH
17339: LD_INT 3
17341: PUSH
17342: EMPTY
17343: LIST
17344: LIST
17345: PUSH
17346: LD_INT 25
17348: PUSH
17349: LD_INT 4
17351: PUSH
17352: EMPTY
17353: LIST
17354: LIST
17355: PUSH
17356: LD_INT 25
17358: PUSH
17359: LD_INT 5
17361: PUSH
17362: EMPTY
17363: LIST
17364: LIST
17365: PUSH
17366: LD_INT 25
17368: PUSH
17369: LD_INT 8
17371: PUSH
17372: EMPTY
17373: LIST
17374: LIST
17375: PUSH
17376: EMPTY
17377: LIST
17378: LIST
17379: LIST
17380: LIST
17381: LIST
17382: LIST
17383: LIST
17384: PUSH
17385: EMPTY
17386: LIST
17387: LIST
17388: LIST
17389: PPUSH
17390: CALL_OW 69
17394: IN
17395: IFFALSE 17411
// loses_counter := loses_counter + 1 ;
17397: LD_ADDR_EXP 17
17401: PUSH
17402: LD_EXP 17
17406: PUSH
17407: LD_INT 1
17409: PLUS
17410: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
17411: LD_VAR 0 1
17415: PPUSH
17416: CALL 45668 0 1
// end ;
17420: PPOPN 1
17422: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
17423: LD_VAR 0 1
17427: PPUSH
17428: LD_VAR 0 2
17432: PPUSH
17433: CALL 48000 0 2
// end ;
17437: PPOPN 2
17439: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
17440: LD_VAR 0 1
17444: PPUSH
17445: CALL 47309 0 1
// end ;
17449: PPOPN 1
17451: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
17452: LD_VAR 0 1
17456: PPUSH
17457: LD_VAR 0 2
17461: PPUSH
17462: LD_VAR 0 3
17466: PPUSH
17467: LD_VAR 0 4
17471: PPUSH
17472: LD_VAR 0 5
17476: PPUSH
17477: CALL 44984 0 5
// end ;
17481: PPOPN 5
17483: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
17484: LD_VAR 0 1
17488: PPUSH
17489: LD_VAR 0 2
17493: PPUSH
17494: CALL 105823 0 2
// if GetNation ( vehicle ) = nation_american then
17498: LD_VAR 0 1
17502: PPUSH
17503: CALL_OW 248
17507: PUSH
17508: LD_INT 1
17510: EQUAL
17511: IFFALSE 17521
// am_veh_consturcted := true ;
17513: LD_ADDR_EXP 20
17517: PUSH
17518: LD_INT 1
17520: ST_TO_ADDR
// MCE_VehicleConstructed ( vehicle , factory ) ;
17521: LD_VAR 0 1
17525: PPUSH
17526: LD_VAR 0 2
17530: PPUSH
17531: CALL 44575 0 2
// end ;
17535: PPOPN 2
17537: END
// on UnitKamikazed ( unit ) do begin if GetType ( unit ) = unit_vehicle then
17538: LD_VAR 0 1
17542: PPUSH
17543: CALL_OW 247
17547: PUSH
17548: LD_INT 2
17550: EQUAL
17551: IFFALSE 17555
// exit ;
17553: GO 17572
// if not kamikazed then
17555: LD_EXP 11
17559: NOT
17560: IFFALSE 17572
// kamikazed := unit ;
17562: LD_ADDR_EXP 11
17566: PUSH
17567: LD_VAR 0 1
17571: ST_TO_ADDR
// end ;
17572: PPOPN 1
17574: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do var i , tmp ;
17575: LD_INT 0
17577: PPUSH
17578: PPUSH
// begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
17579: LD_VAR 0 1
17583: PPUSH
17584: LD_VAR 0 2
17588: PPUSH
17589: LD_VAR 0 3
17593: PPUSH
17594: LD_VAR 0 4
17598: PPUSH
17599: CALL 44413 0 4
// end ;
17603: PPOPN 6
17605: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
17606: LD_VAR 0 1
17610: PPUSH
17611: LD_VAR 0 2
17615: PPUSH
17616: LD_VAR 0 3
17620: PPUSH
17621: CALL 44188 0 3
// end ;
17625: PPOPN 3
17627: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
17628: LD_VAR 0 1
17632: PPUSH
17633: LD_VAR 0 2
17637: PPUSH
17638: CALL 45364 0 2
// end ;
17642: PPOPN 2
17644: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
17645: LD_VAR 0 1
17649: PPUSH
17650: LD_VAR 0 2
17654: PPUSH
17655: CALL 43882 0 2
// end ;
17659: PPOPN 2
17661: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
17662: LD_VAR 0 1
17666: PPUSH
17667: LD_VAR 0 2
17671: PPUSH
17672: CALL 44073 0 2
// end ;
17676: PPOPN 2
17678: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
17679: LD_VAR 0 1
17683: PPUSH
17684: CALL 47068 0 1
// end ;
17688: PPOPN 1
17690: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
17691: LD_VAR 0 1
17695: PPUSH
17696: LD_VAR 0 2
17700: PPUSH
17701: CALL 48295 0 2
// end ;
17705: PPOPN 2
17707: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
17708: LD_VAR 0 1
17712: PPUSH
17713: LD_VAR 0 2
17717: PPUSH
17718: LD_VAR 0 3
17722: PPUSH
17723: LD_VAR 0 4
17727: PPUSH
17728: CALL 48511 0 4
// end ;
17732: PPOPN 4
17734: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
17735: LD_VAR 0 1
17739: PPUSH
17740: CALL 105807 0 1
// end ; end_of_file
17744: PPOPN 1
17746: END
// every 0 0$1 trigger game do
17747: LD_EXP 2
17751: IFFALSE 17781
17753: GO 17755
17755: DISABLE
// SpawnCrates ( [ crates_west , crates_east , crates_north_west , crates_east ] , 0 0$50 ) ;
17756: LD_INT 7
17758: PUSH
17759: LD_INT 6
17761: PUSH
17762: LD_INT 4
17764: PUSH
17765: LD_INT 6
17767: PUSH
17768: EMPTY
17769: LIST
17770: LIST
17771: LIST
17772: LIST
17773: PPUSH
17774: LD_INT 1750
17776: PPUSH
17777: CALL 17782 0 2
17781: END
// export function SpawnCrates ( areas , time ) ; var i , p ; begin
17782: LD_INT 0
17784: PPUSH
17785: PPUSH
17786: PPUSH
// if not areas then
17787: LD_VAR 0 1
17791: NOT
17792: IFFALSE 17796
// exit ;
17794: GO 17926
// repeat wait ( time ) ;
17796: LD_VAR 0 2
17800: PPUSH
17801: CALL_OW 67
// for i in areas do
17805: LD_ADDR_VAR 0 4
17809: PUSH
17810: LD_VAR 0 1
17814: PUSH
17815: FOR_IN
17816: IFFALSE 17885
// begin p := rand ( 1 , 90 ) ;
17818: LD_ADDR_VAR 0 5
17822: PUSH
17823: LD_INT 1
17825: PPUSH
17826: LD_INT 90
17828: PPUSH
17829: CALL_OW 12
17833: ST_TO_ADDR
// if Prob ( p ) then
17834: LD_VAR 0 5
17838: PPUSH
17839: CALL_OW 13
17843: IFFALSE 17883
// begin CreateCratesArea ( rand ( 2 , 5 ) , i , true ) ;
17845: LD_INT 2
17847: PPUSH
17848: LD_INT 5
17850: PPUSH
17851: CALL_OW 12
17855: PPUSH
17856: LD_VAR 0 4
17860: PPUSH
17861: LD_INT 1
17863: PPUSH
17864: CALL_OW 55
// wait ( rand ( 0 0$21 , 0 0$37 ) ) ;
17868: LD_INT 735
17870: PPUSH
17871: LD_INT 1295
17873: PPUSH
17874: CALL_OW 12
17878: PPUSH
17879: CALL_OW 67
// end ; end ;
17883: GO 17815
17885: POP
17886: POP
// time := time + 0 0$3 ;
17887: LD_ADDR_VAR 0 2
17891: PUSH
17892: LD_VAR 0 2
17896: PUSH
17897: LD_INT 105
17899: PLUS
17900: ST_TO_ADDR
// if time > 6 6$00 then
17901: LD_VAR 0 2
17905: PUSH
17906: LD_INT 12600
17908: GREATER
17909: IFFALSE 17919
// time := 0 0$40 ;
17911: LD_ADDR_VAR 0 2
17915: PUSH
17916: LD_INT 1400
17918: ST_TO_ADDR
// until not game ;
17919: LD_EXP 2
17923: NOT
17924: IFFALSE 17796
// end ;
17926: LD_VAR 0 3
17930: RET
// every 0 0$45 + 3 3$00 trigger tick < [ 40 40$00 , 35 35$00 , 30 30$00 , 25 25$00 ] [ Difficulty ] do
17931: LD_OWVAR 1
17935: PUSH
17936: LD_INT 84000
17938: PUSH
17939: LD_INT 73500
17941: PUSH
17942: LD_INT 63000
17944: PUSH
17945: LD_INT 52500
17947: PUSH
17948: EMPTY
17949: LIST
17950: LIST
17951: LIST
17952: LIST
17953: PUSH
17954: LD_OWVAR 67
17958: ARRAY
17959: LESS
17960: IFFALSE 17987
17962: GO 17964
17964: DISABLE
// begin enable ;
17965: ENABLE
// CreateCratesArea ( rand ( 1 , 5 ) , crates_west , true ) ;
17966: LD_INT 1
17968: PPUSH
17969: LD_INT 5
17971: PPUSH
17972: CALL_OW 12
17976: PPUSH
17977: LD_INT 7
17979: PPUSH
17980: LD_INT 1
17982: PPUSH
17983: CALL_OW 55
// end ; end_of_file
17987: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
17988: LD_INT 0
17990: PPUSH
17991: PPUSH
// skirmish := false ;
17992: LD_ADDR_EXP 48
17996: PUSH
17997: LD_INT 0
17999: ST_TO_ADDR
// debug_mc := false ;
18000: LD_ADDR_EXP 49
18004: PUSH
18005: LD_INT 0
18007: ST_TO_ADDR
// mc_bases := [ ] ;
18008: LD_ADDR_EXP 50
18012: PUSH
18013: EMPTY
18014: ST_TO_ADDR
// mc_sides := [ ] ;
18015: LD_ADDR_EXP 76
18019: PUSH
18020: EMPTY
18021: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
18022: LD_ADDR_EXP 51
18026: PUSH
18027: EMPTY
18028: ST_TO_ADDR
// mc_building_repairs := [ ] ;
18029: LD_ADDR_EXP 52
18033: PUSH
18034: EMPTY
18035: ST_TO_ADDR
// mc_need_heal := [ ] ;
18036: LD_ADDR_EXP 53
18040: PUSH
18041: EMPTY
18042: ST_TO_ADDR
// mc_healers := [ ] ;
18043: LD_ADDR_EXP 54
18047: PUSH
18048: EMPTY
18049: ST_TO_ADDR
// mc_build_list := [ ] ;
18050: LD_ADDR_EXP 55
18054: PUSH
18055: EMPTY
18056: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
18057: LD_ADDR_EXP 82
18061: PUSH
18062: EMPTY
18063: ST_TO_ADDR
// mc_builders := [ ] ;
18064: LD_ADDR_EXP 56
18068: PUSH
18069: EMPTY
18070: ST_TO_ADDR
// mc_construct_list := [ ] ;
18071: LD_ADDR_EXP 57
18075: PUSH
18076: EMPTY
18077: ST_TO_ADDR
// mc_turret_list := [ ] ;
18078: LD_ADDR_EXP 58
18082: PUSH
18083: EMPTY
18084: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
18085: LD_ADDR_EXP 59
18089: PUSH
18090: EMPTY
18091: ST_TO_ADDR
// mc_miners := [ ] ;
18092: LD_ADDR_EXP 64
18096: PUSH
18097: EMPTY
18098: ST_TO_ADDR
// mc_mines := [ ] ;
18099: LD_ADDR_EXP 63
18103: PUSH
18104: EMPTY
18105: ST_TO_ADDR
// mc_minefields := [ ] ;
18106: LD_ADDR_EXP 65
18110: PUSH
18111: EMPTY
18112: ST_TO_ADDR
// mc_crates := [ ] ;
18113: LD_ADDR_EXP 66
18117: PUSH
18118: EMPTY
18119: ST_TO_ADDR
// mc_crates_collector := [ ] ;
18120: LD_ADDR_EXP 67
18124: PUSH
18125: EMPTY
18126: ST_TO_ADDR
// mc_crates_area := [ ] ;
18127: LD_ADDR_EXP 68
18131: PUSH
18132: EMPTY
18133: ST_TO_ADDR
// mc_vehicles := [ ] ;
18134: LD_ADDR_EXP 69
18138: PUSH
18139: EMPTY
18140: ST_TO_ADDR
// mc_attack := [ ] ;
18141: LD_ADDR_EXP 70
18145: PUSH
18146: EMPTY
18147: ST_TO_ADDR
// mc_produce := [ ] ;
18148: LD_ADDR_EXP 71
18152: PUSH
18153: EMPTY
18154: ST_TO_ADDR
// mc_defender := [ ] ;
18155: LD_ADDR_EXP 72
18159: PUSH
18160: EMPTY
18161: ST_TO_ADDR
// mc_parking := [ ] ;
18162: LD_ADDR_EXP 74
18166: PUSH
18167: EMPTY
18168: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
18169: LD_ADDR_EXP 60
18173: PUSH
18174: EMPTY
18175: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
18176: LD_ADDR_EXP 62
18180: PUSH
18181: EMPTY
18182: ST_TO_ADDR
// mc_scan := [ ] ;
18183: LD_ADDR_EXP 73
18187: PUSH
18188: EMPTY
18189: ST_TO_ADDR
// mc_scan_area := [ ] ;
18190: LD_ADDR_EXP 75
18194: PUSH
18195: EMPTY
18196: ST_TO_ADDR
// mc_tech := [ ] ;
18197: LD_ADDR_EXP 77
18201: PUSH
18202: EMPTY
18203: ST_TO_ADDR
// mc_class := [ ] ;
18204: LD_ADDR_EXP 91
18208: PUSH
18209: EMPTY
18210: ST_TO_ADDR
// mc_class_case_use := [ ] ;
18211: LD_ADDR_EXP 92
18215: PUSH
18216: EMPTY
18217: ST_TO_ADDR
// mc_is_defending := [ ] ;
18218: LD_ADDR_EXP 93
18222: PUSH
18223: EMPTY
18224: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
18225: LD_ADDR_EXP 84
18229: PUSH
18230: EMPTY
18231: ST_TO_ADDR
// end ;
18232: LD_VAR 0 1
18236: RET
// export function MC_Kill ( base ) ; begin
18237: LD_INT 0
18239: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
18240: LD_ADDR_EXP 50
18244: PUSH
18245: LD_EXP 50
18249: PPUSH
18250: LD_VAR 0 1
18254: PPUSH
18255: EMPTY
18256: PPUSH
18257: CALL_OW 1
18261: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
18262: LD_ADDR_EXP 51
18266: PUSH
18267: LD_EXP 51
18271: PPUSH
18272: LD_VAR 0 1
18276: PPUSH
18277: EMPTY
18278: PPUSH
18279: CALL_OW 1
18283: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
18284: LD_ADDR_EXP 52
18288: PUSH
18289: LD_EXP 52
18293: PPUSH
18294: LD_VAR 0 1
18298: PPUSH
18299: EMPTY
18300: PPUSH
18301: CALL_OW 1
18305: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
18306: LD_ADDR_EXP 53
18310: PUSH
18311: LD_EXP 53
18315: PPUSH
18316: LD_VAR 0 1
18320: PPUSH
18321: EMPTY
18322: PPUSH
18323: CALL_OW 1
18327: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
18328: LD_ADDR_EXP 54
18332: PUSH
18333: LD_EXP 54
18337: PPUSH
18338: LD_VAR 0 1
18342: PPUSH
18343: EMPTY
18344: PPUSH
18345: CALL_OW 1
18349: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
18350: LD_ADDR_EXP 55
18354: PUSH
18355: LD_EXP 55
18359: PPUSH
18360: LD_VAR 0 1
18364: PPUSH
18365: EMPTY
18366: PPUSH
18367: CALL_OW 1
18371: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
18372: LD_ADDR_EXP 56
18376: PUSH
18377: LD_EXP 56
18381: PPUSH
18382: LD_VAR 0 1
18386: PPUSH
18387: EMPTY
18388: PPUSH
18389: CALL_OW 1
18393: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
18394: LD_ADDR_EXP 57
18398: PUSH
18399: LD_EXP 57
18403: PPUSH
18404: LD_VAR 0 1
18408: PPUSH
18409: EMPTY
18410: PPUSH
18411: CALL_OW 1
18415: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
18416: LD_ADDR_EXP 58
18420: PUSH
18421: LD_EXP 58
18425: PPUSH
18426: LD_VAR 0 1
18430: PPUSH
18431: EMPTY
18432: PPUSH
18433: CALL_OW 1
18437: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
18438: LD_ADDR_EXP 59
18442: PUSH
18443: LD_EXP 59
18447: PPUSH
18448: LD_VAR 0 1
18452: PPUSH
18453: EMPTY
18454: PPUSH
18455: CALL_OW 1
18459: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
18460: LD_ADDR_EXP 60
18464: PUSH
18465: LD_EXP 60
18469: PPUSH
18470: LD_VAR 0 1
18474: PPUSH
18475: EMPTY
18476: PPUSH
18477: CALL_OW 1
18481: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
18482: LD_ADDR_EXP 61
18486: PUSH
18487: LD_EXP 61
18491: PPUSH
18492: LD_VAR 0 1
18496: PPUSH
18497: LD_INT 0
18499: PPUSH
18500: CALL_OW 1
18504: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
18505: LD_ADDR_EXP 62
18509: PUSH
18510: LD_EXP 62
18514: PPUSH
18515: LD_VAR 0 1
18519: PPUSH
18520: EMPTY
18521: PPUSH
18522: CALL_OW 1
18526: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
18527: LD_ADDR_EXP 63
18531: PUSH
18532: LD_EXP 63
18536: PPUSH
18537: LD_VAR 0 1
18541: PPUSH
18542: EMPTY
18543: PPUSH
18544: CALL_OW 1
18548: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
18549: LD_ADDR_EXP 64
18553: PUSH
18554: LD_EXP 64
18558: PPUSH
18559: LD_VAR 0 1
18563: PPUSH
18564: EMPTY
18565: PPUSH
18566: CALL_OW 1
18570: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
18571: LD_ADDR_EXP 65
18575: PUSH
18576: LD_EXP 65
18580: PPUSH
18581: LD_VAR 0 1
18585: PPUSH
18586: EMPTY
18587: PPUSH
18588: CALL_OW 1
18592: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
18593: LD_ADDR_EXP 66
18597: PUSH
18598: LD_EXP 66
18602: PPUSH
18603: LD_VAR 0 1
18607: PPUSH
18608: EMPTY
18609: PPUSH
18610: CALL_OW 1
18614: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
18615: LD_ADDR_EXP 67
18619: PUSH
18620: LD_EXP 67
18624: PPUSH
18625: LD_VAR 0 1
18629: PPUSH
18630: EMPTY
18631: PPUSH
18632: CALL_OW 1
18636: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
18637: LD_ADDR_EXP 68
18641: PUSH
18642: LD_EXP 68
18646: PPUSH
18647: LD_VAR 0 1
18651: PPUSH
18652: EMPTY
18653: PPUSH
18654: CALL_OW 1
18658: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
18659: LD_ADDR_EXP 69
18663: PUSH
18664: LD_EXP 69
18668: PPUSH
18669: LD_VAR 0 1
18673: PPUSH
18674: EMPTY
18675: PPUSH
18676: CALL_OW 1
18680: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
18681: LD_ADDR_EXP 70
18685: PUSH
18686: LD_EXP 70
18690: PPUSH
18691: LD_VAR 0 1
18695: PPUSH
18696: EMPTY
18697: PPUSH
18698: CALL_OW 1
18702: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
18703: LD_ADDR_EXP 71
18707: PUSH
18708: LD_EXP 71
18712: PPUSH
18713: LD_VAR 0 1
18717: PPUSH
18718: EMPTY
18719: PPUSH
18720: CALL_OW 1
18724: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
18725: LD_ADDR_EXP 72
18729: PUSH
18730: LD_EXP 72
18734: PPUSH
18735: LD_VAR 0 1
18739: PPUSH
18740: EMPTY
18741: PPUSH
18742: CALL_OW 1
18746: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
18747: LD_ADDR_EXP 73
18751: PUSH
18752: LD_EXP 73
18756: PPUSH
18757: LD_VAR 0 1
18761: PPUSH
18762: EMPTY
18763: PPUSH
18764: CALL_OW 1
18768: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
18769: LD_ADDR_EXP 74
18773: PUSH
18774: LD_EXP 74
18778: PPUSH
18779: LD_VAR 0 1
18783: PPUSH
18784: EMPTY
18785: PPUSH
18786: CALL_OW 1
18790: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
18791: LD_ADDR_EXP 75
18795: PUSH
18796: LD_EXP 75
18800: PPUSH
18801: LD_VAR 0 1
18805: PPUSH
18806: EMPTY
18807: PPUSH
18808: CALL_OW 1
18812: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
18813: LD_ADDR_EXP 77
18817: PUSH
18818: LD_EXP 77
18822: PPUSH
18823: LD_VAR 0 1
18827: PPUSH
18828: EMPTY
18829: PPUSH
18830: CALL_OW 1
18834: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
18835: LD_ADDR_EXP 79
18839: PUSH
18840: LD_EXP 79
18844: PPUSH
18845: LD_VAR 0 1
18849: PPUSH
18850: EMPTY
18851: PPUSH
18852: CALL_OW 1
18856: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
18857: LD_ADDR_EXP 80
18861: PUSH
18862: LD_EXP 80
18866: PPUSH
18867: LD_VAR 0 1
18871: PPUSH
18872: EMPTY
18873: PPUSH
18874: CALL_OW 1
18878: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
18879: LD_ADDR_EXP 81
18883: PUSH
18884: LD_EXP 81
18888: PPUSH
18889: LD_VAR 0 1
18893: PPUSH
18894: EMPTY
18895: PPUSH
18896: CALL_OW 1
18900: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
18901: LD_ADDR_EXP 82
18905: PUSH
18906: LD_EXP 82
18910: PPUSH
18911: LD_VAR 0 1
18915: PPUSH
18916: EMPTY
18917: PPUSH
18918: CALL_OW 1
18922: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
18923: LD_ADDR_EXP 83
18927: PUSH
18928: LD_EXP 83
18932: PPUSH
18933: LD_VAR 0 1
18937: PPUSH
18938: EMPTY
18939: PPUSH
18940: CALL_OW 1
18944: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
18945: LD_ADDR_EXP 84
18949: PUSH
18950: LD_EXP 84
18954: PPUSH
18955: LD_VAR 0 1
18959: PPUSH
18960: EMPTY
18961: PPUSH
18962: CALL_OW 1
18966: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
18967: LD_ADDR_EXP 85
18971: PUSH
18972: LD_EXP 85
18976: PPUSH
18977: LD_VAR 0 1
18981: PPUSH
18982: EMPTY
18983: PPUSH
18984: CALL_OW 1
18988: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
18989: LD_ADDR_EXP 86
18993: PUSH
18994: LD_EXP 86
18998: PPUSH
18999: LD_VAR 0 1
19003: PPUSH
19004: EMPTY
19005: PPUSH
19006: CALL_OW 1
19010: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
19011: LD_ADDR_EXP 87
19015: PUSH
19016: LD_EXP 87
19020: PPUSH
19021: LD_VAR 0 1
19025: PPUSH
19026: EMPTY
19027: PPUSH
19028: CALL_OW 1
19032: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
19033: LD_ADDR_EXP 88
19037: PUSH
19038: LD_EXP 88
19042: PPUSH
19043: LD_VAR 0 1
19047: PPUSH
19048: EMPTY
19049: PPUSH
19050: CALL_OW 1
19054: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
19055: LD_ADDR_EXP 89
19059: PUSH
19060: LD_EXP 89
19064: PPUSH
19065: LD_VAR 0 1
19069: PPUSH
19070: EMPTY
19071: PPUSH
19072: CALL_OW 1
19076: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
19077: LD_ADDR_EXP 90
19081: PUSH
19082: LD_EXP 90
19086: PPUSH
19087: LD_VAR 0 1
19091: PPUSH
19092: EMPTY
19093: PPUSH
19094: CALL_OW 1
19098: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
19099: LD_ADDR_EXP 91
19103: PUSH
19104: LD_EXP 91
19108: PPUSH
19109: LD_VAR 0 1
19113: PPUSH
19114: EMPTY
19115: PPUSH
19116: CALL_OW 1
19120: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
19121: LD_ADDR_EXP 92
19125: PUSH
19126: LD_EXP 92
19130: PPUSH
19131: LD_VAR 0 1
19135: PPUSH
19136: LD_INT 0
19138: PPUSH
19139: CALL_OW 1
19143: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
19144: LD_ADDR_EXP 93
19148: PUSH
19149: LD_EXP 93
19153: PPUSH
19154: LD_VAR 0 1
19158: PPUSH
19159: LD_INT 0
19161: PPUSH
19162: CALL_OW 1
19166: ST_TO_ADDR
// end ;
19167: LD_VAR 0 2
19171: RET
// export function MC_Add ( side , units ) ; var base ; begin
19172: LD_INT 0
19174: PPUSH
19175: PPUSH
// base := mc_bases + 1 ;
19176: LD_ADDR_VAR 0 4
19180: PUSH
19181: LD_EXP 50
19185: PUSH
19186: LD_INT 1
19188: PLUS
19189: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
19190: LD_ADDR_EXP 76
19194: PUSH
19195: LD_EXP 76
19199: PPUSH
19200: LD_VAR 0 4
19204: PPUSH
19205: LD_VAR 0 1
19209: PPUSH
19210: CALL_OW 1
19214: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
19215: LD_ADDR_EXP 50
19219: PUSH
19220: LD_EXP 50
19224: PPUSH
19225: LD_VAR 0 4
19229: PPUSH
19230: LD_VAR 0 2
19234: PPUSH
19235: CALL_OW 1
19239: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
19240: LD_ADDR_EXP 51
19244: PUSH
19245: LD_EXP 51
19249: PPUSH
19250: LD_VAR 0 4
19254: PPUSH
19255: EMPTY
19256: PPUSH
19257: CALL_OW 1
19261: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
19262: LD_ADDR_EXP 52
19266: PUSH
19267: LD_EXP 52
19271: PPUSH
19272: LD_VAR 0 4
19276: PPUSH
19277: EMPTY
19278: PPUSH
19279: CALL_OW 1
19283: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
19284: LD_ADDR_EXP 53
19288: PUSH
19289: LD_EXP 53
19293: PPUSH
19294: LD_VAR 0 4
19298: PPUSH
19299: EMPTY
19300: PPUSH
19301: CALL_OW 1
19305: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
19306: LD_ADDR_EXP 54
19310: PUSH
19311: LD_EXP 54
19315: PPUSH
19316: LD_VAR 0 4
19320: PPUSH
19321: EMPTY
19322: PPUSH
19323: CALL_OW 1
19327: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
19328: LD_ADDR_EXP 55
19332: PUSH
19333: LD_EXP 55
19337: PPUSH
19338: LD_VAR 0 4
19342: PPUSH
19343: EMPTY
19344: PPUSH
19345: CALL_OW 1
19349: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
19350: LD_ADDR_EXP 56
19354: PUSH
19355: LD_EXP 56
19359: PPUSH
19360: LD_VAR 0 4
19364: PPUSH
19365: EMPTY
19366: PPUSH
19367: CALL_OW 1
19371: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
19372: LD_ADDR_EXP 57
19376: PUSH
19377: LD_EXP 57
19381: PPUSH
19382: LD_VAR 0 4
19386: PPUSH
19387: EMPTY
19388: PPUSH
19389: CALL_OW 1
19393: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
19394: LD_ADDR_EXP 58
19398: PUSH
19399: LD_EXP 58
19403: PPUSH
19404: LD_VAR 0 4
19408: PPUSH
19409: EMPTY
19410: PPUSH
19411: CALL_OW 1
19415: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
19416: LD_ADDR_EXP 59
19420: PUSH
19421: LD_EXP 59
19425: PPUSH
19426: LD_VAR 0 4
19430: PPUSH
19431: EMPTY
19432: PPUSH
19433: CALL_OW 1
19437: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
19438: LD_ADDR_EXP 60
19442: PUSH
19443: LD_EXP 60
19447: PPUSH
19448: LD_VAR 0 4
19452: PPUSH
19453: EMPTY
19454: PPUSH
19455: CALL_OW 1
19459: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
19460: LD_ADDR_EXP 61
19464: PUSH
19465: LD_EXP 61
19469: PPUSH
19470: LD_VAR 0 4
19474: PPUSH
19475: LD_INT 0
19477: PPUSH
19478: CALL_OW 1
19482: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
19483: LD_ADDR_EXP 62
19487: PUSH
19488: LD_EXP 62
19492: PPUSH
19493: LD_VAR 0 4
19497: PPUSH
19498: EMPTY
19499: PPUSH
19500: CALL_OW 1
19504: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
19505: LD_ADDR_EXP 63
19509: PUSH
19510: LD_EXP 63
19514: PPUSH
19515: LD_VAR 0 4
19519: PPUSH
19520: EMPTY
19521: PPUSH
19522: CALL_OW 1
19526: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
19527: LD_ADDR_EXP 64
19531: PUSH
19532: LD_EXP 64
19536: PPUSH
19537: LD_VAR 0 4
19541: PPUSH
19542: EMPTY
19543: PPUSH
19544: CALL_OW 1
19548: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
19549: LD_ADDR_EXP 65
19553: PUSH
19554: LD_EXP 65
19558: PPUSH
19559: LD_VAR 0 4
19563: PPUSH
19564: EMPTY
19565: PPUSH
19566: CALL_OW 1
19570: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
19571: LD_ADDR_EXP 66
19575: PUSH
19576: LD_EXP 66
19580: PPUSH
19581: LD_VAR 0 4
19585: PPUSH
19586: EMPTY
19587: PPUSH
19588: CALL_OW 1
19592: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
19593: LD_ADDR_EXP 67
19597: PUSH
19598: LD_EXP 67
19602: PPUSH
19603: LD_VAR 0 4
19607: PPUSH
19608: EMPTY
19609: PPUSH
19610: CALL_OW 1
19614: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
19615: LD_ADDR_EXP 68
19619: PUSH
19620: LD_EXP 68
19624: PPUSH
19625: LD_VAR 0 4
19629: PPUSH
19630: EMPTY
19631: PPUSH
19632: CALL_OW 1
19636: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
19637: LD_ADDR_EXP 69
19641: PUSH
19642: LD_EXP 69
19646: PPUSH
19647: LD_VAR 0 4
19651: PPUSH
19652: EMPTY
19653: PPUSH
19654: CALL_OW 1
19658: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
19659: LD_ADDR_EXP 70
19663: PUSH
19664: LD_EXP 70
19668: PPUSH
19669: LD_VAR 0 4
19673: PPUSH
19674: EMPTY
19675: PPUSH
19676: CALL_OW 1
19680: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
19681: LD_ADDR_EXP 71
19685: PUSH
19686: LD_EXP 71
19690: PPUSH
19691: LD_VAR 0 4
19695: PPUSH
19696: EMPTY
19697: PPUSH
19698: CALL_OW 1
19702: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
19703: LD_ADDR_EXP 72
19707: PUSH
19708: LD_EXP 72
19712: PPUSH
19713: LD_VAR 0 4
19717: PPUSH
19718: EMPTY
19719: PPUSH
19720: CALL_OW 1
19724: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
19725: LD_ADDR_EXP 73
19729: PUSH
19730: LD_EXP 73
19734: PPUSH
19735: LD_VAR 0 4
19739: PPUSH
19740: EMPTY
19741: PPUSH
19742: CALL_OW 1
19746: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
19747: LD_ADDR_EXP 74
19751: PUSH
19752: LD_EXP 74
19756: PPUSH
19757: LD_VAR 0 4
19761: PPUSH
19762: EMPTY
19763: PPUSH
19764: CALL_OW 1
19768: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
19769: LD_ADDR_EXP 75
19773: PUSH
19774: LD_EXP 75
19778: PPUSH
19779: LD_VAR 0 4
19783: PPUSH
19784: EMPTY
19785: PPUSH
19786: CALL_OW 1
19790: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
19791: LD_ADDR_EXP 77
19795: PUSH
19796: LD_EXP 77
19800: PPUSH
19801: LD_VAR 0 4
19805: PPUSH
19806: EMPTY
19807: PPUSH
19808: CALL_OW 1
19812: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
19813: LD_ADDR_EXP 79
19817: PUSH
19818: LD_EXP 79
19822: PPUSH
19823: LD_VAR 0 4
19827: PPUSH
19828: EMPTY
19829: PPUSH
19830: CALL_OW 1
19834: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
19835: LD_ADDR_EXP 80
19839: PUSH
19840: LD_EXP 80
19844: PPUSH
19845: LD_VAR 0 4
19849: PPUSH
19850: EMPTY
19851: PPUSH
19852: CALL_OW 1
19856: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
19857: LD_ADDR_EXP 81
19861: PUSH
19862: LD_EXP 81
19866: PPUSH
19867: LD_VAR 0 4
19871: PPUSH
19872: EMPTY
19873: PPUSH
19874: CALL_OW 1
19878: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
19879: LD_ADDR_EXP 82
19883: PUSH
19884: LD_EXP 82
19888: PPUSH
19889: LD_VAR 0 4
19893: PPUSH
19894: EMPTY
19895: PPUSH
19896: CALL_OW 1
19900: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
19901: LD_ADDR_EXP 83
19905: PUSH
19906: LD_EXP 83
19910: PPUSH
19911: LD_VAR 0 4
19915: PPUSH
19916: EMPTY
19917: PPUSH
19918: CALL_OW 1
19922: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
19923: LD_ADDR_EXP 84
19927: PUSH
19928: LD_EXP 84
19932: PPUSH
19933: LD_VAR 0 4
19937: PPUSH
19938: EMPTY
19939: PPUSH
19940: CALL_OW 1
19944: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
19945: LD_ADDR_EXP 85
19949: PUSH
19950: LD_EXP 85
19954: PPUSH
19955: LD_VAR 0 4
19959: PPUSH
19960: EMPTY
19961: PPUSH
19962: CALL_OW 1
19966: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
19967: LD_ADDR_EXP 86
19971: PUSH
19972: LD_EXP 86
19976: PPUSH
19977: LD_VAR 0 4
19981: PPUSH
19982: EMPTY
19983: PPUSH
19984: CALL_OW 1
19988: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
19989: LD_ADDR_EXP 87
19993: PUSH
19994: LD_EXP 87
19998: PPUSH
19999: LD_VAR 0 4
20003: PPUSH
20004: EMPTY
20005: PPUSH
20006: CALL_OW 1
20010: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
20011: LD_ADDR_EXP 88
20015: PUSH
20016: LD_EXP 88
20020: PPUSH
20021: LD_VAR 0 4
20025: PPUSH
20026: EMPTY
20027: PPUSH
20028: CALL_OW 1
20032: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
20033: LD_ADDR_EXP 89
20037: PUSH
20038: LD_EXP 89
20042: PPUSH
20043: LD_VAR 0 4
20047: PPUSH
20048: EMPTY
20049: PPUSH
20050: CALL_OW 1
20054: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
20055: LD_ADDR_EXP 90
20059: PUSH
20060: LD_EXP 90
20064: PPUSH
20065: LD_VAR 0 4
20069: PPUSH
20070: EMPTY
20071: PPUSH
20072: CALL_OW 1
20076: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
20077: LD_ADDR_EXP 91
20081: PUSH
20082: LD_EXP 91
20086: PPUSH
20087: LD_VAR 0 4
20091: PPUSH
20092: EMPTY
20093: PPUSH
20094: CALL_OW 1
20098: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
20099: LD_ADDR_EXP 92
20103: PUSH
20104: LD_EXP 92
20108: PPUSH
20109: LD_VAR 0 4
20113: PPUSH
20114: LD_INT 0
20116: PPUSH
20117: CALL_OW 1
20121: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
20122: LD_ADDR_EXP 93
20126: PUSH
20127: LD_EXP 93
20131: PPUSH
20132: LD_VAR 0 4
20136: PPUSH
20137: LD_INT 0
20139: PPUSH
20140: CALL_OW 1
20144: ST_TO_ADDR
// result := base ;
20145: LD_ADDR_VAR 0 3
20149: PUSH
20150: LD_VAR 0 4
20154: ST_TO_ADDR
// end ;
20155: LD_VAR 0 3
20159: RET
// export function MC_Start ( ) ; var i ; begin
20160: LD_INT 0
20162: PPUSH
20163: PPUSH
// for i = 1 to mc_bases do
20164: LD_ADDR_VAR 0 2
20168: PUSH
20169: DOUBLE
20170: LD_INT 1
20172: DEC
20173: ST_TO_ADDR
20174: LD_EXP 50
20178: PUSH
20179: FOR_TO
20180: IFFALSE 21280
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
20182: LD_ADDR_EXP 50
20186: PUSH
20187: LD_EXP 50
20191: PPUSH
20192: LD_VAR 0 2
20196: PPUSH
20197: LD_EXP 50
20201: PUSH
20202: LD_VAR 0 2
20206: ARRAY
20207: PUSH
20208: LD_INT 0
20210: DIFF
20211: PPUSH
20212: CALL_OW 1
20216: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
20217: LD_ADDR_EXP 51
20221: PUSH
20222: LD_EXP 51
20226: PPUSH
20227: LD_VAR 0 2
20231: PPUSH
20232: EMPTY
20233: PPUSH
20234: CALL_OW 1
20238: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
20239: LD_ADDR_EXP 52
20243: PUSH
20244: LD_EXP 52
20248: PPUSH
20249: LD_VAR 0 2
20253: PPUSH
20254: EMPTY
20255: PPUSH
20256: CALL_OW 1
20260: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
20261: LD_ADDR_EXP 53
20265: PUSH
20266: LD_EXP 53
20270: PPUSH
20271: LD_VAR 0 2
20275: PPUSH
20276: EMPTY
20277: PPUSH
20278: CALL_OW 1
20282: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
20283: LD_ADDR_EXP 54
20287: PUSH
20288: LD_EXP 54
20292: PPUSH
20293: LD_VAR 0 2
20297: PPUSH
20298: EMPTY
20299: PUSH
20300: EMPTY
20301: PUSH
20302: EMPTY
20303: LIST
20304: LIST
20305: PPUSH
20306: CALL_OW 1
20310: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
20311: LD_ADDR_EXP 55
20315: PUSH
20316: LD_EXP 55
20320: PPUSH
20321: LD_VAR 0 2
20325: PPUSH
20326: EMPTY
20327: PPUSH
20328: CALL_OW 1
20332: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
20333: LD_ADDR_EXP 82
20337: PUSH
20338: LD_EXP 82
20342: PPUSH
20343: LD_VAR 0 2
20347: PPUSH
20348: EMPTY
20349: PPUSH
20350: CALL_OW 1
20354: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
20355: LD_ADDR_EXP 56
20359: PUSH
20360: LD_EXP 56
20364: PPUSH
20365: LD_VAR 0 2
20369: PPUSH
20370: EMPTY
20371: PPUSH
20372: CALL_OW 1
20376: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
20377: LD_ADDR_EXP 57
20381: PUSH
20382: LD_EXP 57
20386: PPUSH
20387: LD_VAR 0 2
20391: PPUSH
20392: EMPTY
20393: PPUSH
20394: CALL_OW 1
20398: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
20399: LD_ADDR_EXP 58
20403: PUSH
20404: LD_EXP 58
20408: PPUSH
20409: LD_VAR 0 2
20413: PPUSH
20414: LD_EXP 50
20418: PUSH
20419: LD_VAR 0 2
20423: ARRAY
20424: PPUSH
20425: LD_INT 2
20427: PUSH
20428: LD_INT 30
20430: PUSH
20431: LD_INT 32
20433: PUSH
20434: EMPTY
20435: LIST
20436: LIST
20437: PUSH
20438: LD_INT 30
20440: PUSH
20441: LD_INT 33
20443: PUSH
20444: EMPTY
20445: LIST
20446: LIST
20447: PUSH
20448: EMPTY
20449: LIST
20450: LIST
20451: LIST
20452: PPUSH
20453: CALL_OW 72
20457: PPUSH
20458: CALL_OW 1
20462: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
20463: LD_ADDR_EXP 59
20467: PUSH
20468: LD_EXP 59
20472: PPUSH
20473: LD_VAR 0 2
20477: PPUSH
20478: LD_EXP 50
20482: PUSH
20483: LD_VAR 0 2
20487: ARRAY
20488: PPUSH
20489: LD_INT 2
20491: PUSH
20492: LD_INT 30
20494: PUSH
20495: LD_INT 32
20497: PUSH
20498: EMPTY
20499: LIST
20500: LIST
20501: PUSH
20502: LD_INT 30
20504: PUSH
20505: LD_INT 31
20507: PUSH
20508: EMPTY
20509: LIST
20510: LIST
20511: PUSH
20512: EMPTY
20513: LIST
20514: LIST
20515: LIST
20516: PUSH
20517: LD_INT 58
20519: PUSH
20520: EMPTY
20521: LIST
20522: PUSH
20523: EMPTY
20524: LIST
20525: LIST
20526: PPUSH
20527: CALL_OW 72
20531: PPUSH
20532: CALL_OW 1
20536: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
20537: LD_ADDR_EXP 60
20541: PUSH
20542: LD_EXP 60
20546: PPUSH
20547: LD_VAR 0 2
20551: PPUSH
20552: EMPTY
20553: PPUSH
20554: CALL_OW 1
20558: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
20559: LD_ADDR_EXP 64
20563: PUSH
20564: LD_EXP 64
20568: PPUSH
20569: LD_VAR 0 2
20573: PPUSH
20574: EMPTY
20575: PPUSH
20576: CALL_OW 1
20580: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
20581: LD_ADDR_EXP 63
20585: PUSH
20586: LD_EXP 63
20590: PPUSH
20591: LD_VAR 0 2
20595: PPUSH
20596: EMPTY
20597: PPUSH
20598: CALL_OW 1
20602: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
20603: LD_ADDR_EXP 65
20607: PUSH
20608: LD_EXP 65
20612: PPUSH
20613: LD_VAR 0 2
20617: PPUSH
20618: EMPTY
20619: PPUSH
20620: CALL_OW 1
20624: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
20625: LD_ADDR_EXP 66
20629: PUSH
20630: LD_EXP 66
20634: PPUSH
20635: LD_VAR 0 2
20639: PPUSH
20640: EMPTY
20641: PPUSH
20642: CALL_OW 1
20646: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
20647: LD_ADDR_EXP 67
20651: PUSH
20652: LD_EXP 67
20656: PPUSH
20657: LD_VAR 0 2
20661: PPUSH
20662: EMPTY
20663: PPUSH
20664: CALL_OW 1
20668: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
20669: LD_ADDR_EXP 68
20673: PUSH
20674: LD_EXP 68
20678: PPUSH
20679: LD_VAR 0 2
20683: PPUSH
20684: EMPTY
20685: PPUSH
20686: CALL_OW 1
20690: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
20691: LD_ADDR_EXP 69
20695: PUSH
20696: LD_EXP 69
20700: PPUSH
20701: LD_VAR 0 2
20705: PPUSH
20706: EMPTY
20707: PPUSH
20708: CALL_OW 1
20712: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
20713: LD_ADDR_EXP 70
20717: PUSH
20718: LD_EXP 70
20722: PPUSH
20723: LD_VAR 0 2
20727: PPUSH
20728: EMPTY
20729: PPUSH
20730: CALL_OW 1
20734: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
20735: LD_ADDR_EXP 71
20739: PUSH
20740: LD_EXP 71
20744: PPUSH
20745: LD_VAR 0 2
20749: PPUSH
20750: EMPTY
20751: PPUSH
20752: CALL_OW 1
20756: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
20757: LD_ADDR_EXP 72
20761: PUSH
20762: LD_EXP 72
20766: PPUSH
20767: LD_VAR 0 2
20771: PPUSH
20772: EMPTY
20773: PPUSH
20774: CALL_OW 1
20778: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
20779: LD_ADDR_EXP 61
20783: PUSH
20784: LD_EXP 61
20788: PPUSH
20789: LD_VAR 0 2
20793: PPUSH
20794: LD_INT 0
20796: PPUSH
20797: CALL_OW 1
20801: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
20802: LD_ADDR_EXP 74
20806: PUSH
20807: LD_EXP 74
20811: PPUSH
20812: LD_VAR 0 2
20816: PPUSH
20817: LD_INT 0
20819: PPUSH
20820: CALL_OW 1
20824: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
20825: LD_ADDR_EXP 62
20829: PUSH
20830: LD_EXP 62
20834: PPUSH
20835: LD_VAR 0 2
20839: PPUSH
20840: EMPTY
20841: PPUSH
20842: CALL_OW 1
20846: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
20847: LD_ADDR_EXP 73
20851: PUSH
20852: LD_EXP 73
20856: PPUSH
20857: LD_VAR 0 2
20861: PPUSH
20862: LD_INT 0
20864: PPUSH
20865: CALL_OW 1
20869: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
20870: LD_ADDR_EXP 75
20874: PUSH
20875: LD_EXP 75
20879: PPUSH
20880: LD_VAR 0 2
20884: PPUSH
20885: EMPTY
20886: PPUSH
20887: CALL_OW 1
20891: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
20892: LD_ADDR_EXP 78
20896: PUSH
20897: LD_EXP 78
20901: PPUSH
20902: LD_VAR 0 2
20906: PPUSH
20907: LD_INT 0
20909: PPUSH
20910: CALL_OW 1
20914: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
20915: LD_ADDR_EXP 79
20919: PUSH
20920: LD_EXP 79
20924: PPUSH
20925: LD_VAR 0 2
20929: PPUSH
20930: EMPTY
20931: PPUSH
20932: CALL_OW 1
20936: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
20937: LD_ADDR_EXP 80
20941: PUSH
20942: LD_EXP 80
20946: PPUSH
20947: LD_VAR 0 2
20951: PPUSH
20952: EMPTY
20953: PPUSH
20954: CALL_OW 1
20958: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
20959: LD_ADDR_EXP 81
20963: PUSH
20964: LD_EXP 81
20968: PPUSH
20969: LD_VAR 0 2
20973: PPUSH
20974: EMPTY
20975: PPUSH
20976: CALL_OW 1
20980: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
20981: LD_ADDR_EXP 83
20985: PUSH
20986: LD_EXP 83
20990: PPUSH
20991: LD_VAR 0 2
20995: PPUSH
20996: LD_EXP 50
21000: PUSH
21001: LD_VAR 0 2
21005: ARRAY
21006: PPUSH
21007: LD_INT 2
21009: PUSH
21010: LD_INT 30
21012: PUSH
21013: LD_INT 6
21015: PUSH
21016: EMPTY
21017: LIST
21018: LIST
21019: PUSH
21020: LD_INT 30
21022: PUSH
21023: LD_INT 7
21025: PUSH
21026: EMPTY
21027: LIST
21028: LIST
21029: PUSH
21030: LD_INT 30
21032: PUSH
21033: LD_INT 8
21035: PUSH
21036: EMPTY
21037: LIST
21038: LIST
21039: PUSH
21040: EMPTY
21041: LIST
21042: LIST
21043: LIST
21044: LIST
21045: PPUSH
21046: CALL_OW 72
21050: PPUSH
21051: CALL_OW 1
21055: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
21056: LD_ADDR_EXP 84
21060: PUSH
21061: LD_EXP 84
21065: PPUSH
21066: LD_VAR 0 2
21070: PPUSH
21071: EMPTY
21072: PPUSH
21073: CALL_OW 1
21077: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
21078: LD_ADDR_EXP 85
21082: PUSH
21083: LD_EXP 85
21087: PPUSH
21088: LD_VAR 0 2
21092: PPUSH
21093: EMPTY
21094: PPUSH
21095: CALL_OW 1
21099: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
21100: LD_ADDR_EXP 86
21104: PUSH
21105: LD_EXP 86
21109: PPUSH
21110: LD_VAR 0 2
21114: PPUSH
21115: EMPTY
21116: PPUSH
21117: CALL_OW 1
21121: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
21122: LD_ADDR_EXP 87
21126: PUSH
21127: LD_EXP 87
21131: PPUSH
21132: LD_VAR 0 2
21136: PPUSH
21137: EMPTY
21138: PPUSH
21139: CALL_OW 1
21143: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
21144: LD_ADDR_EXP 88
21148: PUSH
21149: LD_EXP 88
21153: PPUSH
21154: LD_VAR 0 2
21158: PPUSH
21159: EMPTY
21160: PPUSH
21161: CALL_OW 1
21165: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
21166: LD_ADDR_EXP 89
21170: PUSH
21171: LD_EXP 89
21175: PPUSH
21176: LD_VAR 0 2
21180: PPUSH
21181: EMPTY
21182: PPUSH
21183: CALL_OW 1
21187: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
21188: LD_ADDR_EXP 90
21192: PUSH
21193: LD_EXP 90
21197: PPUSH
21198: LD_VAR 0 2
21202: PPUSH
21203: EMPTY
21204: PPUSH
21205: CALL_OW 1
21209: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
21210: LD_ADDR_EXP 91
21214: PUSH
21215: LD_EXP 91
21219: PPUSH
21220: LD_VAR 0 2
21224: PPUSH
21225: EMPTY
21226: PPUSH
21227: CALL_OW 1
21231: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
21232: LD_ADDR_EXP 92
21236: PUSH
21237: LD_EXP 92
21241: PPUSH
21242: LD_VAR 0 2
21246: PPUSH
21247: LD_INT 0
21249: PPUSH
21250: CALL_OW 1
21254: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
21255: LD_ADDR_EXP 93
21259: PUSH
21260: LD_EXP 93
21264: PPUSH
21265: LD_VAR 0 2
21269: PPUSH
21270: LD_INT 0
21272: PPUSH
21273: CALL_OW 1
21277: ST_TO_ADDR
// end ;
21278: GO 20179
21280: POP
21281: POP
// MC_InitSides ( ) ;
21282: CALL 21568 0 0
// MC_InitResearch ( ) ;
21286: CALL 21307 0 0
// CustomInitMacro ( ) ;
21290: CALL 304 0 0
// skirmish := true ;
21294: LD_ADDR_EXP 48
21298: PUSH
21299: LD_INT 1
21301: ST_TO_ADDR
// end ;
21302: LD_VAR 0 1
21306: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
21307: LD_INT 0
21309: PPUSH
21310: PPUSH
21311: PPUSH
21312: PPUSH
21313: PPUSH
21314: PPUSH
// if not mc_bases then
21315: LD_EXP 50
21319: NOT
21320: IFFALSE 21324
// exit ;
21322: GO 21563
// for i = 1 to 8 do
21324: LD_ADDR_VAR 0 2
21328: PUSH
21329: DOUBLE
21330: LD_INT 1
21332: DEC
21333: ST_TO_ADDR
21334: LD_INT 8
21336: PUSH
21337: FOR_TO
21338: IFFALSE 21364
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
21340: LD_ADDR_EXP 77
21344: PUSH
21345: LD_EXP 77
21349: PPUSH
21350: LD_VAR 0 2
21354: PPUSH
21355: EMPTY
21356: PPUSH
21357: CALL_OW 1
21361: ST_TO_ADDR
21362: GO 21337
21364: POP
21365: POP
// tmp := [ ] ;
21366: LD_ADDR_VAR 0 5
21370: PUSH
21371: EMPTY
21372: ST_TO_ADDR
// for i = 1 to mc_sides do
21373: LD_ADDR_VAR 0 2
21377: PUSH
21378: DOUBLE
21379: LD_INT 1
21381: DEC
21382: ST_TO_ADDR
21383: LD_EXP 76
21387: PUSH
21388: FOR_TO
21389: IFFALSE 21447
// if not mc_sides [ i ] in tmp then
21391: LD_EXP 76
21395: PUSH
21396: LD_VAR 0 2
21400: ARRAY
21401: PUSH
21402: LD_VAR 0 5
21406: IN
21407: NOT
21408: IFFALSE 21445
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
21410: LD_ADDR_VAR 0 5
21414: PUSH
21415: LD_VAR 0 5
21419: PPUSH
21420: LD_VAR 0 5
21424: PUSH
21425: LD_INT 1
21427: PLUS
21428: PPUSH
21429: LD_EXP 76
21433: PUSH
21434: LD_VAR 0 2
21438: ARRAY
21439: PPUSH
21440: CALL_OW 2
21444: ST_TO_ADDR
21445: GO 21388
21447: POP
21448: POP
// if not tmp then
21449: LD_VAR 0 5
21453: NOT
21454: IFFALSE 21458
// exit ;
21456: GO 21563
// for j in tmp do
21458: LD_ADDR_VAR 0 3
21462: PUSH
21463: LD_VAR 0 5
21467: PUSH
21468: FOR_IN
21469: IFFALSE 21561
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
21471: LD_ADDR_VAR 0 6
21475: PUSH
21476: LD_INT 22
21478: PUSH
21479: LD_VAR 0 3
21483: PUSH
21484: EMPTY
21485: LIST
21486: LIST
21487: PPUSH
21488: CALL_OW 69
21492: ST_TO_ADDR
// if not un then
21493: LD_VAR 0 6
21497: NOT
21498: IFFALSE 21502
// continue ;
21500: GO 21468
// nation := GetNation ( un [ 1 ] ) ;
21502: LD_ADDR_VAR 0 4
21506: PUSH
21507: LD_VAR 0 6
21511: PUSH
21512: LD_INT 1
21514: ARRAY
21515: PPUSH
21516: CALL_OW 248
21520: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
21521: LD_ADDR_EXP 77
21525: PUSH
21526: LD_EXP 77
21530: PPUSH
21531: LD_VAR 0 3
21535: PPUSH
21536: LD_VAR 0 3
21540: PPUSH
21541: LD_VAR 0 4
21545: PPUSH
21546: LD_INT 1
21548: PPUSH
21549: CALL 48715 0 3
21553: PPUSH
21554: CALL_OW 1
21558: ST_TO_ADDR
// end ;
21559: GO 21468
21561: POP
21562: POP
// end ;
21563: LD_VAR 0 1
21567: RET
// export function MC_InitSides ( ) ; var i ; begin
21568: LD_INT 0
21570: PPUSH
21571: PPUSH
// if not mc_bases then
21572: LD_EXP 50
21576: NOT
21577: IFFALSE 21581
// exit ;
21579: GO 21655
// for i = 1 to mc_bases do
21581: LD_ADDR_VAR 0 2
21585: PUSH
21586: DOUBLE
21587: LD_INT 1
21589: DEC
21590: ST_TO_ADDR
21591: LD_EXP 50
21595: PUSH
21596: FOR_TO
21597: IFFALSE 21653
// if mc_bases [ i ] then
21599: LD_EXP 50
21603: PUSH
21604: LD_VAR 0 2
21608: ARRAY
21609: IFFALSE 21651
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
21611: LD_ADDR_EXP 76
21615: PUSH
21616: LD_EXP 76
21620: PPUSH
21621: LD_VAR 0 2
21625: PPUSH
21626: LD_EXP 50
21630: PUSH
21631: LD_VAR 0 2
21635: ARRAY
21636: PUSH
21637: LD_INT 1
21639: ARRAY
21640: PPUSH
21641: CALL_OW 255
21645: PPUSH
21646: CALL_OW 1
21650: ST_TO_ADDR
21651: GO 21596
21653: POP
21654: POP
// end ;
21655: LD_VAR 0 1
21659: RET
// every 0 0$03 trigger skirmish do
21660: LD_EXP 48
21664: IFFALSE 21818
21666: GO 21668
21668: DISABLE
// begin enable ;
21669: ENABLE
// MC_CheckBuildings ( ) ;
21670: CALL 26316 0 0
// MC_CheckPeopleLife ( ) ;
21674: CALL 26477 0 0
// RaiseSailEvent ( 100 ) ;
21678: LD_INT 100
21680: PPUSH
21681: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
21685: LD_INT 103
21687: PPUSH
21688: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
21692: LD_INT 104
21694: PPUSH
21695: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
21699: LD_INT 105
21701: PPUSH
21702: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
21706: LD_INT 106
21708: PPUSH
21709: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
21713: LD_INT 107
21715: PPUSH
21716: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
21720: LD_INT 108
21722: PPUSH
21723: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
21727: LD_INT 109
21729: PPUSH
21730: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
21734: LD_INT 110
21736: PPUSH
21737: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
21741: LD_INT 111
21743: PPUSH
21744: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
21748: LD_INT 112
21750: PPUSH
21751: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
21755: LD_INT 113
21757: PPUSH
21758: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
21762: LD_INT 120
21764: PPUSH
21765: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
21769: LD_INT 121
21771: PPUSH
21772: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
21776: LD_INT 122
21778: PPUSH
21779: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
21783: LD_INT 123
21785: PPUSH
21786: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
21790: LD_INT 124
21792: PPUSH
21793: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
21797: LD_INT 125
21799: PPUSH
21800: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
21804: LD_INT 126
21806: PPUSH
21807: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
21811: LD_INT 200
21813: PPUSH
21814: CALL_OW 427
// end ;
21818: END
// on SailEvent ( event ) do begin if event < 100 then
21819: LD_VAR 0 1
21823: PUSH
21824: LD_INT 100
21826: LESS
21827: IFFALSE 21838
// CustomEvent ( event ) ;
21829: LD_VAR 0 1
21833: PPUSH
21834: CALL 17174 0 1
// if event = 100 then
21838: LD_VAR 0 1
21842: PUSH
21843: LD_INT 100
21845: EQUAL
21846: IFFALSE 21852
// MC_ClassManager ( ) ;
21848: CALL 22244 0 0
// if event = 101 then
21852: LD_VAR 0 1
21856: PUSH
21857: LD_INT 101
21859: EQUAL
21860: IFFALSE 21866
// MC_RepairBuildings ( ) ;
21862: CALL 27062 0 0
// if event = 102 then
21866: LD_VAR 0 1
21870: PUSH
21871: LD_INT 102
21873: EQUAL
21874: IFFALSE 21880
// MC_Heal ( ) ;
21876: CALL 27997 0 0
// if event = 103 then
21880: LD_VAR 0 1
21884: PUSH
21885: LD_INT 103
21887: EQUAL
21888: IFFALSE 21894
// MC_Build ( ) ;
21890: CALL 28419 0 0
// if event = 104 then
21894: LD_VAR 0 1
21898: PUSH
21899: LD_INT 104
21901: EQUAL
21902: IFFALSE 21908
// MC_TurretWeapon ( ) ;
21904: CALL 30053 0 0
// if event = 105 then
21908: LD_VAR 0 1
21912: PUSH
21913: LD_INT 105
21915: EQUAL
21916: IFFALSE 21922
// MC_BuildUpgrade ( ) ;
21918: CALL 29604 0 0
// if event = 106 then
21922: LD_VAR 0 1
21926: PUSH
21927: LD_INT 106
21929: EQUAL
21930: IFFALSE 21936
// MC_PlantMines ( ) ;
21932: CALL 30483 0 0
// if event = 107 then
21936: LD_VAR 0 1
21940: PUSH
21941: LD_INT 107
21943: EQUAL
21944: IFFALSE 21950
// MC_CollectCrates ( ) ;
21946: CALL 31274 0 0
// if event = 108 then
21950: LD_VAR 0 1
21954: PUSH
21955: LD_INT 108
21957: EQUAL
21958: IFFALSE 21964
// MC_LinkRemoteControl ( ) ;
21960: CALL 33124 0 0
// if event = 109 then
21964: LD_VAR 0 1
21968: PUSH
21969: LD_INT 109
21971: EQUAL
21972: IFFALSE 21978
// MC_ProduceVehicle ( ) ;
21974: CALL 33305 0 0
// if event = 110 then
21978: LD_VAR 0 1
21982: PUSH
21983: LD_INT 110
21985: EQUAL
21986: IFFALSE 21992
// MC_SendAttack ( ) ;
21988: CALL 33771 0 0
// if event = 111 then
21992: LD_VAR 0 1
21996: PUSH
21997: LD_INT 111
21999: EQUAL
22000: IFFALSE 22006
// MC_Defend ( ) ;
22002: CALL 33879 0 0
// if event = 112 then
22006: LD_VAR 0 1
22010: PUSH
22011: LD_INT 112
22013: EQUAL
22014: IFFALSE 22020
// MC_Research ( ) ;
22016: CALL 34759 0 0
// if event = 113 then
22020: LD_VAR 0 1
22024: PUSH
22025: LD_INT 113
22027: EQUAL
22028: IFFALSE 22034
// MC_MinesTrigger ( ) ;
22030: CALL 35873 0 0
// if event = 120 then
22034: LD_VAR 0 1
22038: PUSH
22039: LD_INT 120
22041: EQUAL
22042: IFFALSE 22048
// MC_RepairVehicle ( ) ;
22044: CALL 35972 0 0
// if event = 121 then
22048: LD_VAR 0 1
22052: PUSH
22053: LD_INT 121
22055: EQUAL
22056: IFFALSE 22062
// MC_TameApe ( ) ;
22058: CALL 36741 0 0
// if event = 122 then
22062: LD_VAR 0 1
22066: PUSH
22067: LD_INT 122
22069: EQUAL
22070: IFFALSE 22076
// MC_ChangeApeClass ( ) ;
22072: CALL 37570 0 0
// if event = 123 then
22076: LD_VAR 0 1
22080: PUSH
22081: LD_INT 123
22083: EQUAL
22084: IFFALSE 22090
// MC_Bazooka ( ) ;
22086: CALL 38220 0 0
// if event = 124 then
22090: LD_VAR 0 1
22094: PUSH
22095: LD_INT 124
22097: EQUAL
22098: IFFALSE 22104
// MC_TeleportExit ( ) ;
22100: CALL 38418 0 0
// if event = 125 then
22104: LD_VAR 0 1
22108: PUSH
22109: LD_INT 125
22111: EQUAL
22112: IFFALSE 22118
// MC_Deposits ( ) ;
22114: CALL 39065 0 0
// if event = 126 then
22118: LD_VAR 0 1
22122: PUSH
22123: LD_INT 126
22125: EQUAL
22126: IFFALSE 22132
// MC_RemoteDriver ( ) ;
22128: CALL 39690 0 0
// if event = 200 then
22132: LD_VAR 0 1
22136: PUSH
22137: LD_INT 200
22139: EQUAL
22140: IFFALSE 22146
// MC_Idle ( ) ;
22142: CALL 41639 0 0
// end ;
22146: PPOPN 1
22148: END
// export function MC_Reset ( base , tag ) ; var i ; begin
22149: LD_INT 0
22151: PPUSH
22152: PPUSH
// if not mc_bases [ base ] or not tag then
22153: LD_EXP 50
22157: PUSH
22158: LD_VAR 0 1
22162: ARRAY
22163: NOT
22164: PUSH
22165: LD_VAR 0 2
22169: NOT
22170: OR
22171: IFFALSE 22175
// exit ;
22173: GO 22239
// for i in mc_bases [ base ] union mc_ape [ base ] do
22175: LD_ADDR_VAR 0 4
22179: PUSH
22180: LD_EXP 50
22184: PUSH
22185: LD_VAR 0 1
22189: ARRAY
22190: PUSH
22191: LD_EXP 79
22195: PUSH
22196: LD_VAR 0 1
22200: ARRAY
22201: UNION
22202: PUSH
22203: FOR_IN
22204: IFFALSE 22237
// if GetTag ( i ) = tag then
22206: LD_VAR 0 4
22210: PPUSH
22211: CALL_OW 110
22215: PUSH
22216: LD_VAR 0 2
22220: EQUAL
22221: IFFALSE 22235
// SetTag ( i , 0 ) ;
22223: LD_VAR 0 4
22227: PPUSH
22228: LD_INT 0
22230: PPUSH
22231: CALL_OW 109
22235: GO 22203
22237: POP
22238: POP
// end ;
22239: LD_VAR 0 3
22243: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
22244: LD_INT 0
22246: PPUSH
22247: PPUSH
22248: PPUSH
22249: PPUSH
22250: PPUSH
22251: PPUSH
22252: PPUSH
22253: PPUSH
// if not mc_bases then
22254: LD_EXP 50
22258: NOT
22259: IFFALSE 22263
// exit ;
22261: GO 22721
// for i = 1 to mc_bases do
22263: LD_ADDR_VAR 0 2
22267: PUSH
22268: DOUBLE
22269: LD_INT 1
22271: DEC
22272: ST_TO_ADDR
22273: LD_EXP 50
22277: PUSH
22278: FOR_TO
22279: IFFALSE 22719
// begin tmp := MC_ClassCheckReq ( i ) ;
22281: LD_ADDR_VAR 0 4
22285: PUSH
22286: LD_VAR 0 2
22290: PPUSH
22291: CALL 22726 0 1
22295: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
22296: LD_ADDR_EXP 91
22300: PUSH
22301: LD_EXP 91
22305: PPUSH
22306: LD_VAR 0 2
22310: PPUSH
22311: LD_VAR 0 4
22315: PPUSH
22316: CALL_OW 1
22320: ST_TO_ADDR
// if not tmp then
22321: LD_VAR 0 4
22325: NOT
22326: IFFALSE 22330
// continue ;
22328: GO 22278
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
22330: LD_ADDR_VAR 0 6
22334: PUSH
22335: LD_EXP 50
22339: PUSH
22340: LD_VAR 0 2
22344: ARRAY
22345: PPUSH
22346: LD_INT 2
22348: PUSH
22349: LD_INT 30
22351: PUSH
22352: LD_INT 4
22354: PUSH
22355: EMPTY
22356: LIST
22357: LIST
22358: PUSH
22359: LD_INT 30
22361: PUSH
22362: LD_INT 5
22364: PUSH
22365: EMPTY
22366: LIST
22367: LIST
22368: PUSH
22369: EMPTY
22370: LIST
22371: LIST
22372: LIST
22373: PPUSH
22374: CALL_OW 72
22378: PUSH
22379: LD_EXP 50
22383: PUSH
22384: LD_VAR 0 2
22388: ARRAY
22389: PPUSH
22390: LD_INT 2
22392: PUSH
22393: LD_INT 30
22395: PUSH
22396: LD_INT 0
22398: PUSH
22399: EMPTY
22400: LIST
22401: LIST
22402: PUSH
22403: LD_INT 30
22405: PUSH
22406: LD_INT 1
22408: PUSH
22409: EMPTY
22410: LIST
22411: LIST
22412: PUSH
22413: EMPTY
22414: LIST
22415: LIST
22416: LIST
22417: PPUSH
22418: CALL_OW 72
22422: PUSH
22423: LD_EXP 50
22427: PUSH
22428: LD_VAR 0 2
22432: ARRAY
22433: PPUSH
22434: LD_INT 30
22436: PUSH
22437: LD_INT 3
22439: PUSH
22440: EMPTY
22441: LIST
22442: LIST
22443: PPUSH
22444: CALL_OW 72
22448: PUSH
22449: LD_EXP 50
22453: PUSH
22454: LD_VAR 0 2
22458: ARRAY
22459: PPUSH
22460: LD_INT 2
22462: PUSH
22463: LD_INT 30
22465: PUSH
22466: LD_INT 6
22468: PUSH
22469: EMPTY
22470: LIST
22471: LIST
22472: PUSH
22473: LD_INT 30
22475: PUSH
22476: LD_INT 7
22478: PUSH
22479: EMPTY
22480: LIST
22481: LIST
22482: PUSH
22483: LD_INT 30
22485: PUSH
22486: LD_INT 8
22488: PUSH
22489: EMPTY
22490: LIST
22491: LIST
22492: PUSH
22493: EMPTY
22494: LIST
22495: LIST
22496: LIST
22497: LIST
22498: PPUSH
22499: CALL_OW 72
22503: PUSH
22504: EMPTY
22505: LIST
22506: LIST
22507: LIST
22508: LIST
22509: ST_TO_ADDR
// for j = 1 to 4 do
22510: LD_ADDR_VAR 0 3
22514: PUSH
22515: DOUBLE
22516: LD_INT 1
22518: DEC
22519: ST_TO_ADDR
22520: LD_INT 4
22522: PUSH
22523: FOR_TO
22524: IFFALSE 22715
// begin if not tmp [ j ] then
22526: LD_VAR 0 4
22530: PUSH
22531: LD_VAR 0 3
22535: ARRAY
22536: NOT
22537: IFFALSE 22541
// continue ;
22539: GO 22523
// for p in tmp [ j ] do
22541: LD_ADDR_VAR 0 5
22545: PUSH
22546: LD_VAR 0 4
22550: PUSH
22551: LD_VAR 0 3
22555: ARRAY
22556: PUSH
22557: FOR_IN
22558: IFFALSE 22711
// begin if not b [ j ] then
22560: LD_VAR 0 6
22564: PUSH
22565: LD_VAR 0 3
22569: ARRAY
22570: NOT
22571: IFFALSE 22575
// break ;
22573: GO 22711
// e := 0 ;
22575: LD_ADDR_VAR 0 7
22579: PUSH
22580: LD_INT 0
22582: ST_TO_ADDR
// for k in b [ j ] do
22583: LD_ADDR_VAR 0 8
22587: PUSH
22588: LD_VAR 0 6
22592: PUSH
22593: LD_VAR 0 3
22597: ARRAY
22598: PUSH
22599: FOR_IN
22600: IFFALSE 22627
// if IsNotFull ( k ) then
22602: LD_VAR 0 8
22606: PPUSH
22607: CALL 50868 0 1
22611: IFFALSE 22625
// begin e := k ;
22613: LD_ADDR_VAR 0 7
22617: PUSH
22618: LD_VAR 0 8
22622: ST_TO_ADDR
// break ;
22623: GO 22627
// end ;
22625: GO 22599
22627: POP
22628: POP
// if e and not UnitGoingToBuilding ( p , e ) then
22629: LD_VAR 0 7
22633: PUSH
22634: LD_VAR 0 5
22638: PPUSH
22639: LD_VAR 0 7
22643: PPUSH
22644: CALL 84747 0 2
22648: NOT
22649: AND
22650: IFFALSE 22709
// begin if IsInUnit ( p ) then
22652: LD_VAR 0 5
22656: PPUSH
22657: CALL_OW 310
22661: IFFALSE 22672
// ComExitBuilding ( p ) ;
22663: LD_VAR 0 5
22667: PPUSH
22668: CALL_OW 122
// ComEnterUnit ( p , e ) ;
22672: LD_VAR 0 5
22676: PPUSH
22677: LD_VAR 0 7
22681: PPUSH
22682: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
22686: LD_VAR 0 5
22690: PPUSH
22691: LD_VAR 0 3
22695: PPUSH
22696: CALL_OW 183
// AddComExitBuilding ( p ) ;
22700: LD_VAR 0 5
22704: PPUSH
22705: CALL_OW 182
// end ; end ;
22709: GO 22557
22711: POP
22712: POP
// end ;
22713: GO 22523
22715: POP
22716: POP
// end ;
22717: GO 22278
22719: POP
22720: POP
// end ;
22721: LD_VAR 0 1
22725: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
22726: LD_INT 0
22728: PPUSH
22729: PPUSH
22730: PPUSH
22731: PPUSH
22732: PPUSH
22733: PPUSH
22734: PPUSH
22735: PPUSH
22736: PPUSH
22737: PPUSH
22738: PPUSH
22739: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
22740: LD_VAR 0 1
22744: NOT
22745: PUSH
22746: LD_EXP 50
22750: PUSH
22751: LD_VAR 0 1
22755: ARRAY
22756: NOT
22757: OR
22758: PUSH
22759: LD_EXP 50
22763: PUSH
22764: LD_VAR 0 1
22768: ARRAY
22769: PPUSH
22770: LD_INT 2
22772: PUSH
22773: LD_INT 30
22775: PUSH
22776: LD_INT 0
22778: PUSH
22779: EMPTY
22780: LIST
22781: LIST
22782: PUSH
22783: LD_INT 30
22785: PUSH
22786: LD_INT 1
22788: PUSH
22789: EMPTY
22790: LIST
22791: LIST
22792: PUSH
22793: EMPTY
22794: LIST
22795: LIST
22796: LIST
22797: PPUSH
22798: CALL_OW 72
22802: NOT
22803: OR
22804: IFFALSE 22808
// exit ;
22806: GO 26311
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
22808: LD_ADDR_VAR 0 4
22812: PUSH
22813: LD_EXP 50
22817: PUSH
22818: LD_VAR 0 1
22822: ARRAY
22823: PPUSH
22824: LD_INT 2
22826: PUSH
22827: LD_INT 25
22829: PUSH
22830: LD_INT 1
22832: PUSH
22833: EMPTY
22834: LIST
22835: LIST
22836: PUSH
22837: LD_INT 25
22839: PUSH
22840: LD_INT 2
22842: PUSH
22843: EMPTY
22844: LIST
22845: LIST
22846: PUSH
22847: LD_INT 25
22849: PUSH
22850: LD_INT 3
22852: PUSH
22853: EMPTY
22854: LIST
22855: LIST
22856: PUSH
22857: LD_INT 25
22859: PUSH
22860: LD_INT 4
22862: PUSH
22863: EMPTY
22864: LIST
22865: LIST
22866: PUSH
22867: LD_INT 25
22869: PUSH
22870: LD_INT 5
22872: PUSH
22873: EMPTY
22874: LIST
22875: LIST
22876: PUSH
22877: LD_INT 25
22879: PUSH
22880: LD_INT 8
22882: PUSH
22883: EMPTY
22884: LIST
22885: LIST
22886: PUSH
22887: LD_INT 25
22889: PUSH
22890: LD_INT 9
22892: PUSH
22893: EMPTY
22894: LIST
22895: LIST
22896: PUSH
22897: EMPTY
22898: LIST
22899: LIST
22900: LIST
22901: LIST
22902: LIST
22903: LIST
22904: LIST
22905: LIST
22906: PPUSH
22907: CALL_OW 72
22911: ST_TO_ADDR
// if not tmp then
22912: LD_VAR 0 4
22916: NOT
22917: IFFALSE 22921
// exit ;
22919: GO 26311
// for i in tmp do
22921: LD_ADDR_VAR 0 3
22925: PUSH
22926: LD_VAR 0 4
22930: PUSH
22931: FOR_IN
22932: IFFALSE 22963
// if GetTag ( i ) then
22934: LD_VAR 0 3
22938: PPUSH
22939: CALL_OW 110
22943: IFFALSE 22961
// tmp := tmp diff i ;
22945: LD_ADDR_VAR 0 4
22949: PUSH
22950: LD_VAR 0 4
22954: PUSH
22955: LD_VAR 0 3
22959: DIFF
22960: ST_TO_ADDR
22961: GO 22931
22963: POP
22964: POP
// if not tmp then
22965: LD_VAR 0 4
22969: NOT
22970: IFFALSE 22974
// exit ;
22972: GO 26311
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
22974: LD_ADDR_VAR 0 5
22978: PUSH
22979: LD_EXP 50
22983: PUSH
22984: LD_VAR 0 1
22988: ARRAY
22989: PPUSH
22990: LD_INT 2
22992: PUSH
22993: LD_INT 25
22995: PUSH
22996: LD_INT 1
22998: PUSH
22999: EMPTY
23000: LIST
23001: LIST
23002: PUSH
23003: LD_INT 25
23005: PUSH
23006: LD_INT 5
23008: PUSH
23009: EMPTY
23010: LIST
23011: LIST
23012: PUSH
23013: LD_INT 25
23015: PUSH
23016: LD_INT 8
23018: PUSH
23019: EMPTY
23020: LIST
23021: LIST
23022: PUSH
23023: LD_INT 25
23025: PUSH
23026: LD_INT 9
23028: PUSH
23029: EMPTY
23030: LIST
23031: LIST
23032: PUSH
23033: EMPTY
23034: LIST
23035: LIST
23036: LIST
23037: LIST
23038: LIST
23039: PPUSH
23040: CALL_OW 72
23044: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
23045: LD_ADDR_VAR 0 6
23049: PUSH
23050: LD_EXP 50
23054: PUSH
23055: LD_VAR 0 1
23059: ARRAY
23060: PPUSH
23061: LD_INT 25
23063: PUSH
23064: LD_INT 2
23066: PUSH
23067: EMPTY
23068: LIST
23069: LIST
23070: PPUSH
23071: CALL_OW 72
23075: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
23076: LD_ADDR_VAR 0 7
23080: PUSH
23081: LD_EXP 50
23085: PUSH
23086: LD_VAR 0 1
23090: ARRAY
23091: PPUSH
23092: LD_INT 25
23094: PUSH
23095: LD_INT 3
23097: PUSH
23098: EMPTY
23099: LIST
23100: LIST
23101: PPUSH
23102: CALL_OW 72
23106: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
23107: LD_ADDR_VAR 0 8
23111: PUSH
23112: LD_EXP 50
23116: PUSH
23117: LD_VAR 0 1
23121: ARRAY
23122: PPUSH
23123: LD_INT 25
23125: PUSH
23126: LD_INT 4
23128: PUSH
23129: EMPTY
23130: LIST
23131: LIST
23132: PUSH
23133: LD_INT 24
23135: PUSH
23136: LD_INT 251
23138: PUSH
23139: EMPTY
23140: LIST
23141: LIST
23142: PUSH
23143: EMPTY
23144: LIST
23145: LIST
23146: PPUSH
23147: CALL_OW 72
23151: ST_TO_ADDR
// if mc_is_defending [ base ] then
23152: LD_EXP 93
23156: PUSH
23157: LD_VAR 0 1
23161: ARRAY
23162: IFFALSE 23623
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
23164: LD_ADDR_EXP 92
23168: PUSH
23169: LD_EXP 92
23173: PPUSH
23174: LD_VAR 0 1
23178: PPUSH
23179: LD_INT 4
23181: PPUSH
23182: CALL_OW 1
23186: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
23187: LD_ADDR_VAR 0 12
23191: PUSH
23192: LD_EXP 50
23196: PUSH
23197: LD_VAR 0 1
23201: ARRAY
23202: PPUSH
23203: LD_INT 2
23205: PUSH
23206: LD_INT 30
23208: PUSH
23209: LD_INT 4
23211: PUSH
23212: EMPTY
23213: LIST
23214: LIST
23215: PUSH
23216: LD_INT 30
23218: PUSH
23219: LD_INT 5
23221: PUSH
23222: EMPTY
23223: LIST
23224: LIST
23225: PUSH
23226: EMPTY
23227: LIST
23228: LIST
23229: LIST
23230: PPUSH
23231: CALL_OW 72
23235: ST_TO_ADDR
// if not b then
23236: LD_VAR 0 12
23240: NOT
23241: IFFALSE 23245
// exit ;
23243: GO 26311
// p := [ ] ;
23245: LD_ADDR_VAR 0 11
23249: PUSH
23250: EMPTY
23251: ST_TO_ADDR
// if sci >= 2 then
23252: LD_VAR 0 8
23256: PUSH
23257: LD_INT 2
23259: GREATEREQUAL
23260: IFFALSE 23291
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
23262: LD_ADDR_VAR 0 8
23266: PUSH
23267: LD_VAR 0 8
23271: PUSH
23272: LD_INT 1
23274: ARRAY
23275: PUSH
23276: LD_VAR 0 8
23280: PUSH
23281: LD_INT 2
23283: ARRAY
23284: PUSH
23285: EMPTY
23286: LIST
23287: LIST
23288: ST_TO_ADDR
23289: GO 23352
// if sci = 1 then
23291: LD_VAR 0 8
23295: PUSH
23296: LD_INT 1
23298: EQUAL
23299: IFFALSE 23320
// sci := [ sci [ 1 ] ] else
23301: LD_ADDR_VAR 0 8
23305: PUSH
23306: LD_VAR 0 8
23310: PUSH
23311: LD_INT 1
23313: ARRAY
23314: PUSH
23315: EMPTY
23316: LIST
23317: ST_TO_ADDR
23318: GO 23352
// if sci = 0 then
23320: LD_VAR 0 8
23324: PUSH
23325: LD_INT 0
23327: EQUAL
23328: IFFALSE 23352
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
23330: LD_ADDR_VAR 0 11
23334: PUSH
23335: LD_VAR 0 4
23339: PPUSH
23340: LD_INT 4
23342: PPUSH
23343: CALL 84610 0 2
23347: PUSH
23348: LD_INT 1
23350: ARRAY
23351: ST_TO_ADDR
// if eng > 4 then
23352: LD_VAR 0 6
23356: PUSH
23357: LD_INT 4
23359: GREATER
23360: IFFALSE 23406
// for i = eng downto 4 do
23362: LD_ADDR_VAR 0 3
23366: PUSH
23367: DOUBLE
23368: LD_VAR 0 6
23372: INC
23373: ST_TO_ADDR
23374: LD_INT 4
23376: PUSH
23377: FOR_DOWNTO
23378: IFFALSE 23404
// eng := eng diff eng [ i ] ;
23380: LD_ADDR_VAR 0 6
23384: PUSH
23385: LD_VAR 0 6
23389: PUSH
23390: LD_VAR 0 6
23394: PUSH
23395: LD_VAR 0 3
23399: ARRAY
23400: DIFF
23401: ST_TO_ADDR
23402: GO 23377
23404: POP
23405: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
23406: LD_ADDR_VAR 0 4
23410: PUSH
23411: LD_VAR 0 4
23415: PUSH
23416: LD_VAR 0 5
23420: PUSH
23421: LD_VAR 0 6
23425: UNION
23426: PUSH
23427: LD_VAR 0 7
23431: UNION
23432: PUSH
23433: LD_VAR 0 8
23437: UNION
23438: DIFF
23439: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
23440: LD_ADDR_VAR 0 13
23444: PUSH
23445: LD_EXP 50
23449: PUSH
23450: LD_VAR 0 1
23454: ARRAY
23455: PPUSH
23456: LD_INT 2
23458: PUSH
23459: LD_INT 30
23461: PUSH
23462: LD_INT 32
23464: PUSH
23465: EMPTY
23466: LIST
23467: LIST
23468: PUSH
23469: LD_INT 30
23471: PUSH
23472: LD_INT 31
23474: PUSH
23475: EMPTY
23476: LIST
23477: LIST
23478: PUSH
23479: EMPTY
23480: LIST
23481: LIST
23482: LIST
23483: PPUSH
23484: CALL_OW 72
23488: PUSH
23489: LD_EXP 50
23493: PUSH
23494: LD_VAR 0 1
23498: ARRAY
23499: PPUSH
23500: LD_INT 2
23502: PUSH
23503: LD_INT 30
23505: PUSH
23506: LD_INT 4
23508: PUSH
23509: EMPTY
23510: LIST
23511: LIST
23512: PUSH
23513: LD_INT 30
23515: PUSH
23516: LD_INT 5
23518: PUSH
23519: EMPTY
23520: LIST
23521: LIST
23522: PUSH
23523: EMPTY
23524: LIST
23525: LIST
23526: LIST
23527: PPUSH
23528: CALL_OW 72
23532: PUSH
23533: LD_INT 6
23535: MUL
23536: PLUS
23537: ST_TO_ADDR
// if bcount < tmp then
23538: LD_VAR 0 13
23542: PUSH
23543: LD_VAR 0 4
23547: LESS
23548: IFFALSE 23594
// for i = tmp downto bcount do
23550: LD_ADDR_VAR 0 3
23554: PUSH
23555: DOUBLE
23556: LD_VAR 0 4
23560: INC
23561: ST_TO_ADDR
23562: LD_VAR 0 13
23566: PUSH
23567: FOR_DOWNTO
23568: IFFALSE 23592
// tmp := Delete ( tmp , tmp ) ;
23570: LD_ADDR_VAR 0 4
23574: PUSH
23575: LD_VAR 0 4
23579: PPUSH
23580: LD_VAR 0 4
23584: PPUSH
23585: CALL_OW 3
23589: ST_TO_ADDR
23590: GO 23567
23592: POP
23593: POP
// result := [ tmp , 0 , 0 , p ] ;
23594: LD_ADDR_VAR 0 2
23598: PUSH
23599: LD_VAR 0 4
23603: PUSH
23604: LD_INT 0
23606: PUSH
23607: LD_INT 0
23609: PUSH
23610: LD_VAR 0 11
23614: PUSH
23615: EMPTY
23616: LIST
23617: LIST
23618: LIST
23619: LIST
23620: ST_TO_ADDR
// exit ;
23621: GO 26311
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
23623: LD_EXP 50
23627: PUSH
23628: LD_VAR 0 1
23632: ARRAY
23633: PPUSH
23634: LD_INT 2
23636: PUSH
23637: LD_INT 30
23639: PUSH
23640: LD_INT 6
23642: PUSH
23643: EMPTY
23644: LIST
23645: LIST
23646: PUSH
23647: LD_INT 30
23649: PUSH
23650: LD_INT 7
23652: PUSH
23653: EMPTY
23654: LIST
23655: LIST
23656: PUSH
23657: LD_INT 30
23659: PUSH
23660: LD_INT 8
23662: PUSH
23663: EMPTY
23664: LIST
23665: LIST
23666: PUSH
23667: EMPTY
23668: LIST
23669: LIST
23670: LIST
23671: LIST
23672: PPUSH
23673: CALL_OW 72
23677: NOT
23678: PUSH
23679: LD_EXP 50
23683: PUSH
23684: LD_VAR 0 1
23688: ARRAY
23689: PPUSH
23690: LD_INT 30
23692: PUSH
23693: LD_INT 3
23695: PUSH
23696: EMPTY
23697: LIST
23698: LIST
23699: PPUSH
23700: CALL_OW 72
23704: NOT
23705: AND
23706: IFFALSE 23778
// begin if eng = tmp then
23708: LD_VAR 0 6
23712: PUSH
23713: LD_VAR 0 4
23717: EQUAL
23718: IFFALSE 23722
// exit ;
23720: GO 26311
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
23722: LD_ADDR_EXP 92
23726: PUSH
23727: LD_EXP 92
23731: PPUSH
23732: LD_VAR 0 1
23736: PPUSH
23737: LD_INT 1
23739: PPUSH
23740: CALL_OW 1
23744: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
23745: LD_ADDR_VAR 0 2
23749: PUSH
23750: LD_INT 0
23752: PUSH
23753: LD_VAR 0 4
23757: PUSH
23758: LD_VAR 0 6
23762: DIFF
23763: PUSH
23764: LD_INT 0
23766: PUSH
23767: LD_INT 0
23769: PUSH
23770: EMPTY
23771: LIST
23772: LIST
23773: LIST
23774: LIST
23775: ST_TO_ADDR
// exit ;
23776: GO 26311
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
23778: LD_EXP 77
23782: PUSH
23783: LD_EXP 76
23787: PUSH
23788: LD_VAR 0 1
23792: ARRAY
23793: ARRAY
23794: PUSH
23795: LD_EXP 50
23799: PUSH
23800: LD_VAR 0 1
23804: ARRAY
23805: PPUSH
23806: LD_INT 2
23808: PUSH
23809: LD_INT 30
23811: PUSH
23812: LD_INT 6
23814: PUSH
23815: EMPTY
23816: LIST
23817: LIST
23818: PUSH
23819: LD_INT 30
23821: PUSH
23822: LD_INT 7
23824: PUSH
23825: EMPTY
23826: LIST
23827: LIST
23828: PUSH
23829: LD_INT 30
23831: PUSH
23832: LD_INT 8
23834: PUSH
23835: EMPTY
23836: LIST
23837: LIST
23838: PUSH
23839: EMPTY
23840: LIST
23841: LIST
23842: LIST
23843: LIST
23844: PPUSH
23845: CALL_OW 72
23849: AND
23850: PUSH
23851: LD_EXP 50
23855: PUSH
23856: LD_VAR 0 1
23860: ARRAY
23861: PPUSH
23862: LD_INT 30
23864: PUSH
23865: LD_INT 3
23867: PUSH
23868: EMPTY
23869: LIST
23870: LIST
23871: PPUSH
23872: CALL_OW 72
23876: NOT
23877: AND
23878: IFFALSE 24092
// begin if sci >= 6 then
23880: LD_VAR 0 8
23884: PUSH
23885: LD_INT 6
23887: GREATEREQUAL
23888: IFFALSE 23892
// exit ;
23890: GO 26311
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
23892: LD_ADDR_EXP 92
23896: PUSH
23897: LD_EXP 92
23901: PPUSH
23902: LD_VAR 0 1
23906: PPUSH
23907: LD_INT 2
23909: PPUSH
23910: CALL_OW 1
23914: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
23915: LD_ADDR_VAR 0 9
23919: PUSH
23920: LD_VAR 0 4
23924: PUSH
23925: LD_VAR 0 8
23929: DIFF
23930: PPUSH
23931: LD_INT 4
23933: PPUSH
23934: CALL 84610 0 2
23938: ST_TO_ADDR
// p := [ ] ;
23939: LD_ADDR_VAR 0 11
23943: PUSH
23944: EMPTY
23945: ST_TO_ADDR
// if sci < 6 and sort > 6 then
23946: LD_VAR 0 8
23950: PUSH
23951: LD_INT 6
23953: LESS
23954: PUSH
23955: LD_VAR 0 9
23959: PUSH
23960: LD_INT 6
23962: GREATER
23963: AND
23964: IFFALSE 24045
// begin for i = 1 to 6 - sci do
23966: LD_ADDR_VAR 0 3
23970: PUSH
23971: DOUBLE
23972: LD_INT 1
23974: DEC
23975: ST_TO_ADDR
23976: LD_INT 6
23978: PUSH
23979: LD_VAR 0 8
23983: MINUS
23984: PUSH
23985: FOR_TO
23986: IFFALSE 24041
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
23988: LD_ADDR_VAR 0 11
23992: PUSH
23993: LD_VAR 0 11
23997: PPUSH
23998: LD_VAR 0 11
24002: PUSH
24003: LD_INT 1
24005: PLUS
24006: PPUSH
24007: LD_VAR 0 9
24011: PUSH
24012: LD_INT 1
24014: ARRAY
24015: PPUSH
24016: CALL_OW 2
24020: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
24021: LD_ADDR_VAR 0 9
24025: PUSH
24026: LD_VAR 0 9
24030: PPUSH
24031: LD_INT 1
24033: PPUSH
24034: CALL_OW 3
24038: ST_TO_ADDR
// end ;
24039: GO 23985
24041: POP
24042: POP
// end else
24043: GO 24065
// if sort then
24045: LD_VAR 0 9
24049: IFFALSE 24065
// p := sort [ 1 ] ;
24051: LD_ADDR_VAR 0 11
24055: PUSH
24056: LD_VAR 0 9
24060: PUSH
24061: LD_INT 1
24063: ARRAY
24064: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
24065: LD_ADDR_VAR 0 2
24069: PUSH
24070: LD_INT 0
24072: PUSH
24073: LD_INT 0
24075: PUSH
24076: LD_INT 0
24078: PUSH
24079: LD_VAR 0 11
24083: PUSH
24084: EMPTY
24085: LIST
24086: LIST
24087: LIST
24088: LIST
24089: ST_TO_ADDR
// exit ;
24090: GO 26311
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
24092: LD_EXP 77
24096: PUSH
24097: LD_EXP 76
24101: PUSH
24102: LD_VAR 0 1
24106: ARRAY
24107: ARRAY
24108: PUSH
24109: LD_EXP 50
24113: PUSH
24114: LD_VAR 0 1
24118: ARRAY
24119: PPUSH
24120: LD_INT 2
24122: PUSH
24123: LD_INT 30
24125: PUSH
24126: LD_INT 6
24128: PUSH
24129: EMPTY
24130: LIST
24131: LIST
24132: PUSH
24133: LD_INT 30
24135: PUSH
24136: LD_INT 7
24138: PUSH
24139: EMPTY
24140: LIST
24141: LIST
24142: PUSH
24143: LD_INT 30
24145: PUSH
24146: LD_INT 8
24148: PUSH
24149: EMPTY
24150: LIST
24151: LIST
24152: PUSH
24153: EMPTY
24154: LIST
24155: LIST
24156: LIST
24157: LIST
24158: PPUSH
24159: CALL_OW 72
24163: AND
24164: PUSH
24165: LD_EXP 50
24169: PUSH
24170: LD_VAR 0 1
24174: ARRAY
24175: PPUSH
24176: LD_INT 30
24178: PUSH
24179: LD_INT 3
24181: PUSH
24182: EMPTY
24183: LIST
24184: LIST
24185: PPUSH
24186: CALL_OW 72
24190: AND
24191: IFFALSE 24925
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
24193: LD_ADDR_EXP 92
24197: PUSH
24198: LD_EXP 92
24202: PPUSH
24203: LD_VAR 0 1
24207: PPUSH
24208: LD_INT 3
24210: PPUSH
24211: CALL_OW 1
24215: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
24216: LD_ADDR_VAR 0 2
24220: PUSH
24221: LD_INT 0
24223: PUSH
24224: LD_INT 0
24226: PUSH
24227: LD_INT 0
24229: PUSH
24230: LD_INT 0
24232: PUSH
24233: EMPTY
24234: LIST
24235: LIST
24236: LIST
24237: LIST
24238: ST_TO_ADDR
// if not eng then
24239: LD_VAR 0 6
24243: NOT
24244: IFFALSE 24307
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
24246: LD_ADDR_VAR 0 11
24250: PUSH
24251: LD_VAR 0 4
24255: PPUSH
24256: LD_INT 2
24258: PPUSH
24259: CALL 84610 0 2
24263: PUSH
24264: LD_INT 1
24266: ARRAY
24267: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
24268: LD_ADDR_VAR 0 2
24272: PUSH
24273: LD_VAR 0 2
24277: PPUSH
24278: LD_INT 2
24280: PPUSH
24281: LD_VAR 0 11
24285: PPUSH
24286: CALL_OW 1
24290: ST_TO_ADDR
// tmp := tmp diff p ;
24291: LD_ADDR_VAR 0 4
24295: PUSH
24296: LD_VAR 0 4
24300: PUSH
24301: LD_VAR 0 11
24305: DIFF
24306: ST_TO_ADDR
// end ; if tmp and sci < 6 then
24307: LD_VAR 0 4
24311: PUSH
24312: LD_VAR 0 8
24316: PUSH
24317: LD_INT 6
24319: LESS
24320: AND
24321: IFFALSE 24509
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
24323: LD_ADDR_VAR 0 9
24327: PUSH
24328: LD_VAR 0 4
24332: PUSH
24333: LD_VAR 0 8
24337: PUSH
24338: LD_VAR 0 7
24342: UNION
24343: DIFF
24344: PPUSH
24345: LD_INT 4
24347: PPUSH
24348: CALL 84610 0 2
24352: ST_TO_ADDR
// p := [ ] ;
24353: LD_ADDR_VAR 0 11
24357: PUSH
24358: EMPTY
24359: ST_TO_ADDR
// if sort then
24360: LD_VAR 0 9
24364: IFFALSE 24480
// for i = 1 to 6 - sci do
24366: LD_ADDR_VAR 0 3
24370: PUSH
24371: DOUBLE
24372: LD_INT 1
24374: DEC
24375: ST_TO_ADDR
24376: LD_INT 6
24378: PUSH
24379: LD_VAR 0 8
24383: MINUS
24384: PUSH
24385: FOR_TO
24386: IFFALSE 24478
// begin if i = sort then
24388: LD_VAR 0 3
24392: PUSH
24393: LD_VAR 0 9
24397: EQUAL
24398: IFFALSE 24402
// break ;
24400: GO 24478
// if GetClass ( i ) = 4 then
24402: LD_VAR 0 3
24406: PPUSH
24407: CALL_OW 257
24411: PUSH
24412: LD_INT 4
24414: EQUAL
24415: IFFALSE 24419
// continue ;
24417: GO 24385
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24419: LD_ADDR_VAR 0 11
24423: PUSH
24424: LD_VAR 0 11
24428: PPUSH
24429: LD_VAR 0 11
24433: PUSH
24434: LD_INT 1
24436: PLUS
24437: PPUSH
24438: LD_VAR 0 9
24442: PUSH
24443: LD_VAR 0 3
24447: ARRAY
24448: PPUSH
24449: CALL_OW 2
24453: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24454: LD_ADDR_VAR 0 4
24458: PUSH
24459: LD_VAR 0 4
24463: PUSH
24464: LD_VAR 0 9
24468: PUSH
24469: LD_VAR 0 3
24473: ARRAY
24474: DIFF
24475: ST_TO_ADDR
// end ;
24476: GO 24385
24478: POP
24479: POP
// if p then
24480: LD_VAR 0 11
24484: IFFALSE 24509
// result := Replace ( result , 4 , p ) ;
24486: LD_ADDR_VAR 0 2
24490: PUSH
24491: LD_VAR 0 2
24495: PPUSH
24496: LD_INT 4
24498: PPUSH
24499: LD_VAR 0 11
24503: PPUSH
24504: CALL_OW 1
24508: ST_TO_ADDR
// end ; if tmp and mech < 6 then
24509: LD_VAR 0 4
24513: PUSH
24514: LD_VAR 0 7
24518: PUSH
24519: LD_INT 6
24521: LESS
24522: AND
24523: IFFALSE 24711
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
24525: LD_ADDR_VAR 0 9
24529: PUSH
24530: LD_VAR 0 4
24534: PUSH
24535: LD_VAR 0 8
24539: PUSH
24540: LD_VAR 0 7
24544: UNION
24545: DIFF
24546: PPUSH
24547: LD_INT 3
24549: PPUSH
24550: CALL 84610 0 2
24554: ST_TO_ADDR
// p := [ ] ;
24555: LD_ADDR_VAR 0 11
24559: PUSH
24560: EMPTY
24561: ST_TO_ADDR
// if sort then
24562: LD_VAR 0 9
24566: IFFALSE 24682
// for i = 1 to 6 - mech do
24568: LD_ADDR_VAR 0 3
24572: PUSH
24573: DOUBLE
24574: LD_INT 1
24576: DEC
24577: ST_TO_ADDR
24578: LD_INT 6
24580: PUSH
24581: LD_VAR 0 7
24585: MINUS
24586: PUSH
24587: FOR_TO
24588: IFFALSE 24680
// begin if i = sort then
24590: LD_VAR 0 3
24594: PUSH
24595: LD_VAR 0 9
24599: EQUAL
24600: IFFALSE 24604
// break ;
24602: GO 24680
// if GetClass ( i ) = 3 then
24604: LD_VAR 0 3
24608: PPUSH
24609: CALL_OW 257
24613: PUSH
24614: LD_INT 3
24616: EQUAL
24617: IFFALSE 24621
// continue ;
24619: GO 24587
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24621: LD_ADDR_VAR 0 11
24625: PUSH
24626: LD_VAR 0 11
24630: PPUSH
24631: LD_VAR 0 11
24635: PUSH
24636: LD_INT 1
24638: PLUS
24639: PPUSH
24640: LD_VAR 0 9
24644: PUSH
24645: LD_VAR 0 3
24649: ARRAY
24650: PPUSH
24651: CALL_OW 2
24655: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24656: LD_ADDR_VAR 0 4
24660: PUSH
24661: LD_VAR 0 4
24665: PUSH
24666: LD_VAR 0 9
24670: PUSH
24671: LD_VAR 0 3
24675: ARRAY
24676: DIFF
24677: ST_TO_ADDR
// end ;
24678: GO 24587
24680: POP
24681: POP
// if p then
24682: LD_VAR 0 11
24686: IFFALSE 24711
// result := Replace ( result , 3 , p ) ;
24688: LD_ADDR_VAR 0 2
24692: PUSH
24693: LD_VAR 0 2
24697: PPUSH
24698: LD_INT 3
24700: PPUSH
24701: LD_VAR 0 11
24705: PPUSH
24706: CALL_OW 1
24710: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
24711: LD_VAR 0 4
24715: PUSH
24716: LD_INT 6
24718: GREATER
24719: PUSH
24720: LD_VAR 0 6
24724: PUSH
24725: LD_INT 6
24727: LESS
24728: AND
24729: IFFALSE 24923
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
24731: LD_ADDR_VAR 0 9
24735: PUSH
24736: LD_VAR 0 4
24740: PUSH
24741: LD_VAR 0 8
24745: PUSH
24746: LD_VAR 0 7
24750: UNION
24751: PUSH
24752: LD_VAR 0 6
24756: UNION
24757: DIFF
24758: PPUSH
24759: LD_INT 2
24761: PPUSH
24762: CALL 84610 0 2
24766: ST_TO_ADDR
// p := [ ] ;
24767: LD_ADDR_VAR 0 11
24771: PUSH
24772: EMPTY
24773: ST_TO_ADDR
// if sort then
24774: LD_VAR 0 9
24778: IFFALSE 24894
// for i = 1 to 6 - eng do
24780: LD_ADDR_VAR 0 3
24784: PUSH
24785: DOUBLE
24786: LD_INT 1
24788: DEC
24789: ST_TO_ADDR
24790: LD_INT 6
24792: PUSH
24793: LD_VAR 0 6
24797: MINUS
24798: PUSH
24799: FOR_TO
24800: IFFALSE 24892
// begin if i = sort then
24802: LD_VAR 0 3
24806: PUSH
24807: LD_VAR 0 9
24811: EQUAL
24812: IFFALSE 24816
// break ;
24814: GO 24892
// if GetClass ( i ) = 2 then
24816: LD_VAR 0 3
24820: PPUSH
24821: CALL_OW 257
24825: PUSH
24826: LD_INT 2
24828: EQUAL
24829: IFFALSE 24833
// continue ;
24831: GO 24799
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24833: LD_ADDR_VAR 0 11
24837: PUSH
24838: LD_VAR 0 11
24842: PPUSH
24843: LD_VAR 0 11
24847: PUSH
24848: LD_INT 1
24850: PLUS
24851: PPUSH
24852: LD_VAR 0 9
24856: PUSH
24857: LD_VAR 0 3
24861: ARRAY
24862: PPUSH
24863: CALL_OW 2
24867: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24868: LD_ADDR_VAR 0 4
24872: PUSH
24873: LD_VAR 0 4
24877: PUSH
24878: LD_VAR 0 9
24882: PUSH
24883: LD_VAR 0 3
24887: ARRAY
24888: DIFF
24889: ST_TO_ADDR
// end ;
24890: GO 24799
24892: POP
24893: POP
// if p then
24894: LD_VAR 0 11
24898: IFFALSE 24923
// result := Replace ( result , 2 , p ) ;
24900: LD_ADDR_VAR 0 2
24904: PUSH
24905: LD_VAR 0 2
24909: PPUSH
24910: LD_INT 2
24912: PPUSH
24913: LD_VAR 0 11
24917: PPUSH
24918: CALL_OW 1
24922: ST_TO_ADDR
// end ; exit ;
24923: GO 26311
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
24925: LD_EXP 77
24929: PUSH
24930: LD_EXP 76
24934: PUSH
24935: LD_VAR 0 1
24939: ARRAY
24940: ARRAY
24941: NOT
24942: PUSH
24943: LD_EXP 50
24947: PUSH
24948: LD_VAR 0 1
24952: ARRAY
24953: PPUSH
24954: LD_INT 30
24956: PUSH
24957: LD_INT 3
24959: PUSH
24960: EMPTY
24961: LIST
24962: LIST
24963: PPUSH
24964: CALL_OW 72
24968: AND
24969: PUSH
24970: LD_EXP 55
24974: PUSH
24975: LD_VAR 0 1
24979: ARRAY
24980: AND
24981: IFFALSE 25589
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
24983: LD_ADDR_EXP 92
24987: PUSH
24988: LD_EXP 92
24992: PPUSH
24993: LD_VAR 0 1
24997: PPUSH
24998: LD_INT 5
25000: PPUSH
25001: CALL_OW 1
25005: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
25006: LD_ADDR_VAR 0 2
25010: PUSH
25011: LD_INT 0
25013: PUSH
25014: LD_INT 0
25016: PUSH
25017: LD_INT 0
25019: PUSH
25020: LD_INT 0
25022: PUSH
25023: EMPTY
25024: LIST
25025: LIST
25026: LIST
25027: LIST
25028: ST_TO_ADDR
// if sci > 1 then
25029: LD_VAR 0 8
25033: PUSH
25034: LD_INT 1
25036: GREATER
25037: IFFALSE 25065
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
25039: LD_ADDR_VAR 0 4
25043: PUSH
25044: LD_VAR 0 4
25048: PUSH
25049: LD_VAR 0 8
25053: PUSH
25054: LD_VAR 0 8
25058: PUSH
25059: LD_INT 1
25061: ARRAY
25062: DIFF
25063: DIFF
25064: ST_TO_ADDR
// if tmp and not sci then
25065: LD_VAR 0 4
25069: PUSH
25070: LD_VAR 0 8
25074: NOT
25075: AND
25076: IFFALSE 25145
// begin sort := SortBySkill ( tmp , 4 ) ;
25078: LD_ADDR_VAR 0 9
25082: PUSH
25083: LD_VAR 0 4
25087: PPUSH
25088: LD_INT 4
25090: PPUSH
25091: CALL 84610 0 2
25095: ST_TO_ADDR
// if sort then
25096: LD_VAR 0 9
25100: IFFALSE 25116
// p := sort [ 1 ] ;
25102: LD_ADDR_VAR 0 11
25106: PUSH
25107: LD_VAR 0 9
25111: PUSH
25112: LD_INT 1
25114: ARRAY
25115: ST_TO_ADDR
// if p then
25116: LD_VAR 0 11
25120: IFFALSE 25145
// result := Replace ( result , 4 , p ) ;
25122: LD_ADDR_VAR 0 2
25126: PUSH
25127: LD_VAR 0 2
25131: PPUSH
25132: LD_INT 4
25134: PPUSH
25135: LD_VAR 0 11
25139: PPUSH
25140: CALL_OW 1
25144: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
25145: LD_ADDR_VAR 0 4
25149: PUSH
25150: LD_VAR 0 4
25154: PUSH
25155: LD_VAR 0 7
25159: DIFF
25160: ST_TO_ADDR
// if tmp and mech < 6 then
25161: LD_VAR 0 4
25165: PUSH
25166: LD_VAR 0 7
25170: PUSH
25171: LD_INT 6
25173: LESS
25174: AND
25175: IFFALSE 25363
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
25177: LD_ADDR_VAR 0 9
25181: PUSH
25182: LD_VAR 0 4
25186: PUSH
25187: LD_VAR 0 8
25191: PUSH
25192: LD_VAR 0 7
25196: UNION
25197: DIFF
25198: PPUSH
25199: LD_INT 3
25201: PPUSH
25202: CALL 84610 0 2
25206: ST_TO_ADDR
// p := [ ] ;
25207: LD_ADDR_VAR 0 11
25211: PUSH
25212: EMPTY
25213: ST_TO_ADDR
// if sort then
25214: LD_VAR 0 9
25218: IFFALSE 25334
// for i = 1 to 6 - mech do
25220: LD_ADDR_VAR 0 3
25224: PUSH
25225: DOUBLE
25226: LD_INT 1
25228: DEC
25229: ST_TO_ADDR
25230: LD_INT 6
25232: PUSH
25233: LD_VAR 0 7
25237: MINUS
25238: PUSH
25239: FOR_TO
25240: IFFALSE 25332
// begin if i = sort then
25242: LD_VAR 0 3
25246: PUSH
25247: LD_VAR 0 9
25251: EQUAL
25252: IFFALSE 25256
// break ;
25254: GO 25332
// if GetClass ( i ) = 3 then
25256: LD_VAR 0 3
25260: PPUSH
25261: CALL_OW 257
25265: PUSH
25266: LD_INT 3
25268: EQUAL
25269: IFFALSE 25273
// continue ;
25271: GO 25239
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25273: LD_ADDR_VAR 0 11
25277: PUSH
25278: LD_VAR 0 11
25282: PPUSH
25283: LD_VAR 0 11
25287: PUSH
25288: LD_INT 1
25290: PLUS
25291: PPUSH
25292: LD_VAR 0 9
25296: PUSH
25297: LD_VAR 0 3
25301: ARRAY
25302: PPUSH
25303: CALL_OW 2
25307: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25308: LD_ADDR_VAR 0 4
25312: PUSH
25313: LD_VAR 0 4
25317: PUSH
25318: LD_VAR 0 9
25322: PUSH
25323: LD_VAR 0 3
25327: ARRAY
25328: DIFF
25329: ST_TO_ADDR
// end ;
25330: GO 25239
25332: POP
25333: POP
// if p then
25334: LD_VAR 0 11
25338: IFFALSE 25363
// result := Replace ( result , 3 , p ) ;
25340: LD_ADDR_VAR 0 2
25344: PUSH
25345: LD_VAR 0 2
25349: PPUSH
25350: LD_INT 3
25352: PPUSH
25353: LD_VAR 0 11
25357: PPUSH
25358: CALL_OW 1
25362: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
25363: LD_ADDR_VAR 0 4
25367: PUSH
25368: LD_VAR 0 4
25372: PUSH
25373: LD_VAR 0 6
25377: DIFF
25378: ST_TO_ADDR
// if tmp and eng < 6 then
25379: LD_VAR 0 4
25383: PUSH
25384: LD_VAR 0 6
25388: PUSH
25389: LD_INT 6
25391: LESS
25392: AND
25393: IFFALSE 25587
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
25395: LD_ADDR_VAR 0 9
25399: PUSH
25400: LD_VAR 0 4
25404: PUSH
25405: LD_VAR 0 8
25409: PUSH
25410: LD_VAR 0 7
25414: UNION
25415: PUSH
25416: LD_VAR 0 6
25420: UNION
25421: DIFF
25422: PPUSH
25423: LD_INT 2
25425: PPUSH
25426: CALL 84610 0 2
25430: ST_TO_ADDR
// p := [ ] ;
25431: LD_ADDR_VAR 0 11
25435: PUSH
25436: EMPTY
25437: ST_TO_ADDR
// if sort then
25438: LD_VAR 0 9
25442: IFFALSE 25558
// for i = 1 to 6 - eng do
25444: LD_ADDR_VAR 0 3
25448: PUSH
25449: DOUBLE
25450: LD_INT 1
25452: DEC
25453: ST_TO_ADDR
25454: LD_INT 6
25456: PUSH
25457: LD_VAR 0 6
25461: MINUS
25462: PUSH
25463: FOR_TO
25464: IFFALSE 25556
// begin if i = sort then
25466: LD_VAR 0 3
25470: PUSH
25471: LD_VAR 0 9
25475: EQUAL
25476: IFFALSE 25480
// break ;
25478: GO 25556
// if GetClass ( i ) = 2 then
25480: LD_VAR 0 3
25484: PPUSH
25485: CALL_OW 257
25489: PUSH
25490: LD_INT 2
25492: EQUAL
25493: IFFALSE 25497
// continue ;
25495: GO 25463
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25497: LD_ADDR_VAR 0 11
25501: PUSH
25502: LD_VAR 0 11
25506: PPUSH
25507: LD_VAR 0 11
25511: PUSH
25512: LD_INT 1
25514: PLUS
25515: PPUSH
25516: LD_VAR 0 9
25520: PUSH
25521: LD_VAR 0 3
25525: ARRAY
25526: PPUSH
25527: CALL_OW 2
25531: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25532: LD_ADDR_VAR 0 4
25536: PUSH
25537: LD_VAR 0 4
25541: PUSH
25542: LD_VAR 0 9
25546: PUSH
25547: LD_VAR 0 3
25551: ARRAY
25552: DIFF
25553: ST_TO_ADDR
// end ;
25554: GO 25463
25556: POP
25557: POP
// if p then
25558: LD_VAR 0 11
25562: IFFALSE 25587
// result := Replace ( result , 2 , p ) ;
25564: LD_ADDR_VAR 0 2
25568: PUSH
25569: LD_VAR 0 2
25573: PPUSH
25574: LD_INT 2
25576: PPUSH
25577: LD_VAR 0 11
25581: PPUSH
25582: CALL_OW 1
25586: ST_TO_ADDR
// end ; exit ;
25587: GO 26311
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
25589: LD_EXP 77
25593: PUSH
25594: LD_EXP 76
25598: PUSH
25599: LD_VAR 0 1
25603: ARRAY
25604: ARRAY
25605: NOT
25606: PUSH
25607: LD_EXP 50
25611: PUSH
25612: LD_VAR 0 1
25616: ARRAY
25617: PPUSH
25618: LD_INT 30
25620: PUSH
25621: LD_INT 3
25623: PUSH
25624: EMPTY
25625: LIST
25626: LIST
25627: PPUSH
25628: CALL_OW 72
25632: AND
25633: PUSH
25634: LD_EXP 55
25638: PUSH
25639: LD_VAR 0 1
25643: ARRAY
25644: NOT
25645: AND
25646: IFFALSE 26311
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
25648: LD_ADDR_EXP 92
25652: PUSH
25653: LD_EXP 92
25657: PPUSH
25658: LD_VAR 0 1
25662: PPUSH
25663: LD_INT 6
25665: PPUSH
25666: CALL_OW 1
25670: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
25671: LD_ADDR_VAR 0 2
25675: PUSH
25676: LD_INT 0
25678: PUSH
25679: LD_INT 0
25681: PUSH
25682: LD_INT 0
25684: PUSH
25685: LD_INT 0
25687: PUSH
25688: EMPTY
25689: LIST
25690: LIST
25691: LIST
25692: LIST
25693: ST_TO_ADDR
// if sci >= 1 then
25694: LD_VAR 0 8
25698: PUSH
25699: LD_INT 1
25701: GREATEREQUAL
25702: IFFALSE 25724
// tmp := tmp diff sci [ 1 ] ;
25704: LD_ADDR_VAR 0 4
25708: PUSH
25709: LD_VAR 0 4
25713: PUSH
25714: LD_VAR 0 8
25718: PUSH
25719: LD_INT 1
25721: ARRAY
25722: DIFF
25723: ST_TO_ADDR
// if tmp and not sci then
25724: LD_VAR 0 4
25728: PUSH
25729: LD_VAR 0 8
25733: NOT
25734: AND
25735: IFFALSE 25804
// begin sort := SortBySkill ( tmp , 4 ) ;
25737: LD_ADDR_VAR 0 9
25741: PUSH
25742: LD_VAR 0 4
25746: PPUSH
25747: LD_INT 4
25749: PPUSH
25750: CALL 84610 0 2
25754: ST_TO_ADDR
// if sort then
25755: LD_VAR 0 9
25759: IFFALSE 25775
// p := sort [ 1 ] ;
25761: LD_ADDR_VAR 0 11
25765: PUSH
25766: LD_VAR 0 9
25770: PUSH
25771: LD_INT 1
25773: ARRAY
25774: ST_TO_ADDR
// if p then
25775: LD_VAR 0 11
25779: IFFALSE 25804
// result := Replace ( result , 4 , p ) ;
25781: LD_ADDR_VAR 0 2
25785: PUSH
25786: LD_VAR 0 2
25790: PPUSH
25791: LD_INT 4
25793: PPUSH
25794: LD_VAR 0 11
25798: PPUSH
25799: CALL_OW 1
25803: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
25804: LD_ADDR_VAR 0 4
25808: PUSH
25809: LD_VAR 0 4
25813: PUSH
25814: LD_VAR 0 7
25818: DIFF
25819: ST_TO_ADDR
// if tmp and mech < 6 then
25820: LD_VAR 0 4
25824: PUSH
25825: LD_VAR 0 7
25829: PUSH
25830: LD_INT 6
25832: LESS
25833: AND
25834: IFFALSE 26016
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
25836: LD_ADDR_VAR 0 9
25840: PUSH
25841: LD_VAR 0 4
25845: PUSH
25846: LD_VAR 0 7
25850: DIFF
25851: PPUSH
25852: LD_INT 3
25854: PPUSH
25855: CALL 84610 0 2
25859: ST_TO_ADDR
// p := [ ] ;
25860: LD_ADDR_VAR 0 11
25864: PUSH
25865: EMPTY
25866: ST_TO_ADDR
// if sort then
25867: LD_VAR 0 9
25871: IFFALSE 25987
// for i = 1 to 6 - mech do
25873: LD_ADDR_VAR 0 3
25877: PUSH
25878: DOUBLE
25879: LD_INT 1
25881: DEC
25882: ST_TO_ADDR
25883: LD_INT 6
25885: PUSH
25886: LD_VAR 0 7
25890: MINUS
25891: PUSH
25892: FOR_TO
25893: IFFALSE 25985
// begin if i = sort then
25895: LD_VAR 0 3
25899: PUSH
25900: LD_VAR 0 9
25904: EQUAL
25905: IFFALSE 25909
// break ;
25907: GO 25985
// if GetClass ( i ) = 3 then
25909: LD_VAR 0 3
25913: PPUSH
25914: CALL_OW 257
25918: PUSH
25919: LD_INT 3
25921: EQUAL
25922: IFFALSE 25926
// continue ;
25924: GO 25892
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25926: LD_ADDR_VAR 0 11
25930: PUSH
25931: LD_VAR 0 11
25935: PPUSH
25936: LD_VAR 0 11
25940: PUSH
25941: LD_INT 1
25943: PLUS
25944: PPUSH
25945: LD_VAR 0 9
25949: PUSH
25950: LD_VAR 0 3
25954: ARRAY
25955: PPUSH
25956: CALL_OW 2
25960: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25961: LD_ADDR_VAR 0 4
25965: PUSH
25966: LD_VAR 0 4
25970: PUSH
25971: LD_VAR 0 9
25975: PUSH
25976: LD_VAR 0 3
25980: ARRAY
25981: DIFF
25982: ST_TO_ADDR
// end ;
25983: GO 25892
25985: POP
25986: POP
// if p then
25987: LD_VAR 0 11
25991: IFFALSE 26016
// result := Replace ( result , 3 , p ) ;
25993: LD_ADDR_VAR 0 2
25997: PUSH
25998: LD_VAR 0 2
26002: PPUSH
26003: LD_INT 3
26005: PPUSH
26006: LD_VAR 0 11
26010: PPUSH
26011: CALL_OW 1
26015: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
26016: LD_ADDR_VAR 0 4
26020: PUSH
26021: LD_VAR 0 4
26025: PUSH
26026: LD_VAR 0 6
26030: DIFF
26031: ST_TO_ADDR
// if tmp and eng < 4 then
26032: LD_VAR 0 4
26036: PUSH
26037: LD_VAR 0 6
26041: PUSH
26042: LD_INT 4
26044: LESS
26045: AND
26046: IFFALSE 26236
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
26048: LD_ADDR_VAR 0 9
26052: PUSH
26053: LD_VAR 0 4
26057: PUSH
26058: LD_VAR 0 7
26062: PUSH
26063: LD_VAR 0 6
26067: UNION
26068: DIFF
26069: PPUSH
26070: LD_INT 2
26072: PPUSH
26073: CALL 84610 0 2
26077: ST_TO_ADDR
// p := [ ] ;
26078: LD_ADDR_VAR 0 11
26082: PUSH
26083: EMPTY
26084: ST_TO_ADDR
// if sort then
26085: LD_VAR 0 9
26089: IFFALSE 26205
// for i = 1 to 4 - eng do
26091: LD_ADDR_VAR 0 3
26095: PUSH
26096: DOUBLE
26097: LD_INT 1
26099: DEC
26100: ST_TO_ADDR
26101: LD_INT 4
26103: PUSH
26104: LD_VAR 0 6
26108: MINUS
26109: PUSH
26110: FOR_TO
26111: IFFALSE 26203
// begin if i = sort then
26113: LD_VAR 0 3
26117: PUSH
26118: LD_VAR 0 9
26122: EQUAL
26123: IFFALSE 26127
// break ;
26125: GO 26203
// if GetClass ( i ) = 2 then
26127: LD_VAR 0 3
26131: PPUSH
26132: CALL_OW 257
26136: PUSH
26137: LD_INT 2
26139: EQUAL
26140: IFFALSE 26144
// continue ;
26142: GO 26110
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26144: LD_ADDR_VAR 0 11
26148: PUSH
26149: LD_VAR 0 11
26153: PPUSH
26154: LD_VAR 0 11
26158: PUSH
26159: LD_INT 1
26161: PLUS
26162: PPUSH
26163: LD_VAR 0 9
26167: PUSH
26168: LD_VAR 0 3
26172: ARRAY
26173: PPUSH
26174: CALL_OW 2
26178: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26179: LD_ADDR_VAR 0 4
26183: PUSH
26184: LD_VAR 0 4
26188: PUSH
26189: LD_VAR 0 9
26193: PUSH
26194: LD_VAR 0 3
26198: ARRAY
26199: DIFF
26200: ST_TO_ADDR
// end ;
26201: GO 26110
26203: POP
26204: POP
// if p then
26205: LD_VAR 0 11
26209: IFFALSE 26234
// result := Replace ( result , 2 , p ) ;
26211: LD_ADDR_VAR 0 2
26215: PUSH
26216: LD_VAR 0 2
26220: PPUSH
26221: LD_INT 2
26223: PPUSH
26224: LD_VAR 0 11
26228: PPUSH
26229: CALL_OW 1
26233: ST_TO_ADDR
// end else
26234: GO 26280
// for i = eng downto 5 do
26236: LD_ADDR_VAR 0 3
26240: PUSH
26241: DOUBLE
26242: LD_VAR 0 6
26246: INC
26247: ST_TO_ADDR
26248: LD_INT 5
26250: PUSH
26251: FOR_DOWNTO
26252: IFFALSE 26278
// tmp := tmp union eng [ i ] ;
26254: LD_ADDR_VAR 0 4
26258: PUSH
26259: LD_VAR 0 4
26263: PUSH
26264: LD_VAR 0 6
26268: PUSH
26269: LD_VAR 0 3
26273: ARRAY
26274: UNION
26275: ST_TO_ADDR
26276: GO 26251
26278: POP
26279: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
26280: LD_ADDR_VAR 0 2
26284: PUSH
26285: LD_VAR 0 2
26289: PPUSH
26290: LD_INT 1
26292: PPUSH
26293: LD_VAR 0 4
26297: PUSH
26298: LD_VAR 0 5
26302: DIFF
26303: PPUSH
26304: CALL_OW 1
26308: ST_TO_ADDR
// exit ;
26309: GO 26311
// end ; end ;
26311: LD_VAR 0 2
26315: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
26316: LD_INT 0
26318: PPUSH
26319: PPUSH
26320: PPUSH
// if not mc_bases then
26321: LD_EXP 50
26325: NOT
26326: IFFALSE 26330
// exit ;
26328: GO 26472
// for i = 1 to mc_bases do
26330: LD_ADDR_VAR 0 2
26334: PUSH
26335: DOUBLE
26336: LD_INT 1
26338: DEC
26339: ST_TO_ADDR
26340: LD_EXP 50
26344: PUSH
26345: FOR_TO
26346: IFFALSE 26463
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
26348: LD_ADDR_VAR 0 3
26352: PUSH
26353: LD_EXP 50
26357: PUSH
26358: LD_VAR 0 2
26362: ARRAY
26363: PPUSH
26364: LD_INT 21
26366: PUSH
26367: LD_INT 3
26369: PUSH
26370: EMPTY
26371: LIST
26372: LIST
26373: PUSH
26374: LD_INT 3
26376: PUSH
26377: LD_INT 2
26379: PUSH
26380: LD_INT 30
26382: PUSH
26383: LD_INT 29
26385: PUSH
26386: EMPTY
26387: LIST
26388: LIST
26389: PUSH
26390: LD_INT 30
26392: PUSH
26393: LD_INT 30
26395: PUSH
26396: EMPTY
26397: LIST
26398: LIST
26399: PUSH
26400: EMPTY
26401: LIST
26402: LIST
26403: LIST
26404: PUSH
26405: EMPTY
26406: LIST
26407: LIST
26408: PUSH
26409: LD_INT 3
26411: PUSH
26412: LD_INT 24
26414: PUSH
26415: LD_INT 1000
26417: PUSH
26418: EMPTY
26419: LIST
26420: LIST
26421: PUSH
26422: EMPTY
26423: LIST
26424: LIST
26425: PUSH
26426: EMPTY
26427: LIST
26428: LIST
26429: LIST
26430: PPUSH
26431: CALL_OW 72
26435: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
26436: LD_ADDR_EXP 51
26440: PUSH
26441: LD_EXP 51
26445: PPUSH
26446: LD_VAR 0 2
26450: PPUSH
26451: LD_VAR 0 3
26455: PPUSH
26456: CALL_OW 1
26460: ST_TO_ADDR
// end ;
26461: GO 26345
26463: POP
26464: POP
// RaiseSailEvent ( 101 ) ;
26465: LD_INT 101
26467: PPUSH
26468: CALL_OW 427
// end ;
26472: LD_VAR 0 1
26476: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
26477: LD_INT 0
26479: PPUSH
26480: PPUSH
26481: PPUSH
26482: PPUSH
26483: PPUSH
26484: PPUSH
26485: PPUSH
// if not mc_bases then
26486: LD_EXP 50
26490: NOT
26491: IFFALSE 26495
// exit ;
26493: GO 27057
// for i = 1 to mc_bases do
26495: LD_ADDR_VAR 0 2
26499: PUSH
26500: DOUBLE
26501: LD_INT 1
26503: DEC
26504: ST_TO_ADDR
26505: LD_EXP 50
26509: PUSH
26510: FOR_TO
26511: IFFALSE 27048
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
26513: LD_ADDR_VAR 0 5
26517: PUSH
26518: LD_EXP 50
26522: PUSH
26523: LD_VAR 0 2
26527: ARRAY
26528: PUSH
26529: LD_EXP 79
26533: PUSH
26534: LD_VAR 0 2
26538: ARRAY
26539: UNION
26540: PPUSH
26541: LD_INT 21
26543: PUSH
26544: LD_INT 1
26546: PUSH
26547: EMPTY
26548: LIST
26549: LIST
26550: PUSH
26551: LD_INT 1
26553: PUSH
26554: LD_INT 3
26556: PUSH
26557: LD_INT 54
26559: PUSH
26560: EMPTY
26561: LIST
26562: PUSH
26563: EMPTY
26564: LIST
26565: LIST
26566: PUSH
26567: LD_INT 3
26569: PUSH
26570: LD_INT 24
26572: PUSH
26573: LD_INT 1000
26575: PUSH
26576: EMPTY
26577: LIST
26578: LIST
26579: PUSH
26580: EMPTY
26581: LIST
26582: LIST
26583: PUSH
26584: EMPTY
26585: LIST
26586: LIST
26587: LIST
26588: PUSH
26589: EMPTY
26590: LIST
26591: LIST
26592: PPUSH
26593: CALL_OW 72
26597: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
26598: LD_ADDR_VAR 0 6
26602: PUSH
26603: LD_EXP 50
26607: PUSH
26608: LD_VAR 0 2
26612: ARRAY
26613: PPUSH
26614: LD_INT 21
26616: PUSH
26617: LD_INT 1
26619: PUSH
26620: EMPTY
26621: LIST
26622: LIST
26623: PUSH
26624: LD_INT 1
26626: PUSH
26627: LD_INT 3
26629: PUSH
26630: LD_INT 54
26632: PUSH
26633: EMPTY
26634: LIST
26635: PUSH
26636: EMPTY
26637: LIST
26638: LIST
26639: PUSH
26640: LD_INT 3
26642: PUSH
26643: LD_INT 24
26645: PUSH
26646: LD_INT 250
26648: PUSH
26649: EMPTY
26650: LIST
26651: LIST
26652: PUSH
26653: EMPTY
26654: LIST
26655: LIST
26656: PUSH
26657: EMPTY
26658: LIST
26659: LIST
26660: LIST
26661: PUSH
26662: EMPTY
26663: LIST
26664: LIST
26665: PPUSH
26666: CALL_OW 72
26670: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
26671: LD_ADDR_VAR 0 7
26675: PUSH
26676: LD_VAR 0 5
26680: PUSH
26681: LD_VAR 0 6
26685: DIFF
26686: ST_TO_ADDR
// if not need_heal_1 then
26687: LD_VAR 0 6
26691: NOT
26692: IFFALSE 26725
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
26694: LD_ADDR_EXP 53
26698: PUSH
26699: LD_EXP 53
26703: PPUSH
26704: LD_VAR 0 2
26708: PUSH
26709: LD_INT 1
26711: PUSH
26712: EMPTY
26713: LIST
26714: LIST
26715: PPUSH
26716: EMPTY
26717: PPUSH
26718: CALL 53789 0 3
26722: ST_TO_ADDR
26723: GO 26795
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
26725: LD_ADDR_EXP 53
26729: PUSH
26730: LD_EXP 53
26734: PPUSH
26735: LD_VAR 0 2
26739: PUSH
26740: LD_INT 1
26742: PUSH
26743: EMPTY
26744: LIST
26745: LIST
26746: PPUSH
26747: LD_EXP 53
26751: PUSH
26752: LD_VAR 0 2
26756: ARRAY
26757: PUSH
26758: LD_INT 1
26760: ARRAY
26761: PPUSH
26762: LD_INT 3
26764: PUSH
26765: LD_INT 24
26767: PUSH
26768: LD_INT 1000
26770: PUSH
26771: EMPTY
26772: LIST
26773: LIST
26774: PUSH
26775: EMPTY
26776: LIST
26777: LIST
26778: PPUSH
26779: CALL_OW 72
26783: PUSH
26784: LD_VAR 0 6
26788: UNION
26789: PPUSH
26790: CALL 53789 0 3
26794: ST_TO_ADDR
// if not need_heal_2 then
26795: LD_VAR 0 7
26799: NOT
26800: IFFALSE 26833
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
26802: LD_ADDR_EXP 53
26806: PUSH
26807: LD_EXP 53
26811: PPUSH
26812: LD_VAR 0 2
26816: PUSH
26817: LD_INT 2
26819: PUSH
26820: EMPTY
26821: LIST
26822: LIST
26823: PPUSH
26824: EMPTY
26825: PPUSH
26826: CALL 53789 0 3
26830: ST_TO_ADDR
26831: GO 26865
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
26833: LD_ADDR_EXP 53
26837: PUSH
26838: LD_EXP 53
26842: PPUSH
26843: LD_VAR 0 2
26847: PUSH
26848: LD_INT 2
26850: PUSH
26851: EMPTY
26852: LIST
26853: LIST
26854: PPUSH
26855: LD_VAR 0 7
26859: PPUSH
26860: CALL 53789 0 3
26864: ST_TO_ADDR
// if need_heal_2 then
26865: LD_VAR 0 7
26869: IFFALSE 27030
// for j in need_heal_2 do
26871: LD_ADDR_VAR 0 3
26875: PUSH
26876: LD_VAR 0 7
26880: PUSH
26881: FOR_IN
26882: IFFALSE 27028
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
26884: LD_ADDR_VAR 0 5
26888: PUSH
26889: LD_EXP 50
26893: PUSH
26894: LD_VAR 0 2
26898: ARRAY
26899: PPUSH
26900: LD_INT 2
26902: PUSH
26903: LD_INT 30
26905: PUSH
26906: LD_INT 6
26908: PUSH
26909: EMPTY
26910: LIST
26911: LIST
26912: PUSH
26913: LD_INT 30
26915: PUSH
26916: LD_INT 7
26918: PUSH
26919: EMPTY
26920: LIST
26921: LIST
26922: PUSH
26923: LD_INT 30
26925: PUSH
26926: LD_INT 8
26928: PUSH
26929: EMPTY
26930: LIST
26931: LIST
26932: PUSH
26933: LD_INT 30
26935: PUSH
26936: LD_INT 0
26938: PUSH
26939: EMPTY
26940: LIST
26941: LIST
26942: PUSH
26943: LD_INT 30
26945: PUSH
26946: LD_INT 1
26948: PUSH
26949: EMPTY
26950: LIST
26951: LIST
26952: PUSH
26953: EMPTY
26954: LIST
26955: LIST
26956: LIST
26957: LIST
26958: LIST
26959: LIST
26960: PPUSH
26961: CALL_OW 72
26965: ST_TO_ADDR
// if tmp then
26966: LD_VAR 0 5
26970: IFFALSE 27026
// begin k := NearestUnitToUnit ( tmp , j ) ;
26972: LD_ADDR_VAR 0 4
26976: PUSH
26977: LD_VAR 0 5
26981: PPUSH
26982: LD_VAR 0 3
26986: PPUSH
26987: CALL_OW 74
26991: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
26992: LD_VAR 0 3
26996: PPUSH
26997: LD_VAR 0 4
27001: PPUSH
27002: CALL_OW 296
27006: PUSH
27007: LD_INT 5
27009: GREATER
27010: IFFALSE 27026
// ComMoveToNearbyEntrance ( j , k ) ;
27012: LD_VAR 0 3
27016: PPUSH
27017: LD_VAR 0 4
27021: PPUSH
27022: CALL 86978 0 2
// end ; end ;
27026: GO 26881
27028: POP
27029: POP
// if not need_heal_1 and not need_heal_2 then
27030: LD_VAR 0 6
27034: NOT
27035: PUSH
27036: LD_VAR 0 7
27040: NOT
27041: AND
27042: IFFALSE 27046
// continue ;
27044: GO 26510
// end ;
27046: GO 26510
27048: POP
27049: POP
// RaiseSailEvent ( 102 ) ;
27050: LD_INT 102
27052: PPUSH
27053: CALL_OW 427
// end ;
27057: LD_VAR 0 1
27061: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
27062: LD_INT 0
27064: PPUSH
27065: PPUSH
27066: PPUSH
27067: PPUSH
27068: PPUSH
27069: PPUSH
27070: PPUSH
27071: PPUSH
// if not mc_bases then
27072: LD_EXP 50
27076: NOT
27077: IFFALSE 27081
// exit ;
27079: GO 27992
// for i = 1 to mc_bases do
27081: LD_ADDR_VAR 0 2
27085: PUSH
27086: DOUBLE
27087: LD_INT 1
27089: DEC
27090: ST_TO_ADDR
27091: LD_EXP 50
27095: PUSH
27096: FOR_TO
27097: IFFALSE 27990
// begin if not mc_building_need_repair [ i ] then
27099: LD_EXP 51
27103: PUSH
27104: LD_VAR 0 2
27108: ARRAY
27109: NOT
27110: IFFALSE 27295
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
27112: LD_ADDR_VAR 0 6
27116: PUSH
27117: LD_EXP 69
27121: PUSH
27122: LD_VAR 0 2
27126: ARRAY
27127: PPUSH
27128: LD_INT 3
27130: PUSH
27131: LD_INT 24
27133: PUSH
27134: LD_INT 1000
27136: PUSH
27137: EMPTY
27138: LIST
27139: LIST
27140: PUSH
27141: EMPTY
27142: LIST
27143: LIST
27144: PUSH
27145: LD_INT 2
27147: PUSH
27148: LD_INT 34
27150: PUSH
27151: LD_INT 13
27153: PUSH
27154: EMPTY
27155: LIST
27156: LIST
27157: PUSH
27158: LD_INT 34
27160: PUSH
27161: LD_INT 52
27163: PUSH
27164: EMPTY
27165: LIST
27166: LIST
27167: PUSH
27168: LD_INT 34
27170: PUSH
27171: LD_INT 88
27173: PUSH
27174: EMPTY
27175: LIST
27176: LIST
27177: PUSH
27178: EMPTY
27179: LIST
27180: LIST
27181: LIST
27182: LIST
27183: PUSH
27184: EMPTY
27185: LIST
27186: LIST
27187: PPUSH
27188: CALL_OW 72
27192: ST_TO_ADDR
// if cranes then
27193: LD_VAR 0 6
27197: IFFALSE 27259
// for j in cranes do
27199: LD_ADDR_VAR 0 3
27203: PUSH
27204: LD_VAR 0 6
27208: PUSH
27209: FOR_IN
27210: IFFALSE 27257
// if not IsInArea ( j , mc_parking [ i ] ) then
27212: LD_VAR 0 3
27216: PPUSH
27217: LD_EXP 74
27221: PUSH
27222: LD_VAR 0 2
27226: ARRAY
27227: PPUSH
27228: CALL_OW 308
27232: NOT
27233: IFFALSE 27255
// ComMoveToArea ( j , mc_parking [ i ] ) ;
27235: LD_VAR 0 3
27239: PPUSH
27240: LD_EXP 74
27244: PUSH
27245: LD_VAR 0 2
27249: ARRAY
27250: PPUSH
27251: CALL_OW 113
27255: GO 27209
27257: POP
27258: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
27259: LD_ADDR_EXP 52
27263: PUSH
27264: LD_EXP 52
27268: PPUSH
27269: LD_VAR 0 2
27273: PPUSH
27274: EMPTY
27275: PPUSH
27276: CALL_OW 1
27280: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
27281: LD_VAR 0 2
27285: PPUSH
27286: LD_INT 101
27288: PPUSH
27289: CALL 22149 0 2
// continue ;
27293: GO 27096
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
27295: LD_ADDR_EXP 56
27299: PUSH
27300: LD_EXP 56
27304: PPUSH
27305: LD_VAR 0 2
27309: PPUSH
27310: EMPTY
27311: PPUSH
27312: CALL_OW 1
27316: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
27317: LD_VAR 0 2
27321: PPUSH
27322: LD_INT 103
27324: PPUSH
27325: CALL 22149 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
27329: LD_ADDR_VAR 0 5
27333: PUSH
27334: LD_EXP 50
27338: PUSH
27339: LD_VAR 0 2
27343: ARRAY
27344: PUSH
27345: LD_EXP 79
27349: PUSH
27350: LD_VAR 0 2
27354: ARRAY
27355: UNION
27356: PPUSH
27357: LD_INT 2
27359: PUSH
27360: LD_INT 25
27362: PUSH
27363: LD_INT 2
27365: PUSH
27366: EMPTY
27367: LIST
27368: LIST
27369: PUSH
27370: LD_INT 25
27372: PUSH
27373: LD_INT 16
27375: PUSH
27376: EMPTY
27377: LIST
27378: LIST
27379: PUSH
27380: EMPTY
27381: LIST
27382: LIST
27383: LIST
27384: PUSH
27385: EMPTY
27386: LIST
27387: PPUSH
27388: CALL_OW 72
27392: ST_TO_ADDR
// if mc_need_heal [ i ] then
27393: LD_EXP 53
27397: PUSH
27398: LD_VAR 0 2
27402: ARRAY
27403: IFFALSE 27447
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
27405: LD_ADDR_VAR 0 5
27409: PUSH
27410: LD_VAR 0 5
27414: PUSH
27415: LD_EXP 53
27419: PUSH
27420: LD_VAR 0 2
27424: ARRAY
27425: PUSH
27426: LD_INT 1
27428: ARRAY
27429: PUSH
27430: LD_EXP 53
27434: PUSH
27435: LD_VAR 0 2
27439: ARRAY
27440: PUSH
27441: LD_INT 2
27443: ARRAY
27444: UNION
27445: DIFF
27446: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
27447: LD_ADDR_VAR 0 6
27451: PUSH
27452: LD_EXP 69
27456: PUSH
27457: LD_VAR 0 2
27461: ARRAY
27462: PPUSH
27463: LD_INT 2
27465: PUSH
27466: LD_INT 34
27468: PUSH
27469: LD_INT 13
27471: PUSH
27472: EMPTY
27473: LIST
27474: LIST
27475: PUSH
27476: LD_INT 34
27478: PUSH
27479: LD_INT 52
27481: PUSH
27482: EMPTY
27483: LIST
27484: LIST
27485: PUSH
27486: LD_INT 34
27488: PUSH
27489: LD_INT 88
27491: PUSH
27492: EMPTY
27493: LIST
27494: LIST
27495: PUSH
27496: EMPTY
27497: LIST
27498: LIST
27499: LIST
27500: LIST
27501: PPUSH
27502: CALL_OW 72
27506: ST_TO_ADDR
// if cranes then
27507: LD_VAR 0 6
27511: IFFALSE 27679
// begin for j in cranes do
27513: LD_ADDR_VAR 0 3
27517: PUSH
27518: LD_VAR 0 6
27522: PUSH
27523: FOR_IN
27524: IFFALSE 27677
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
27526: LD_VAR 0 3
27530: PPUSH
27531: CALL_OW 256
27535: PUSH
27536: LD_INT 1000
27538: EQUAL
27539: PUSH
27540: LD_VAR 0 3
27544: PPUSH
27545: CALL_OW 314
27549: NOT
27550: AND
27551: IFFALSE 27617
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
27553: LD_ADDR_VAR 0 8
27557: PUSH
27558: LD_EXP 51
27562: PUSH
27563: LD_VAR 0 2
27567: ARRAY
27568: PPUSH
27569: LD_VAR 0 3
27573: PPUSH
27574: CALL_OW 74
27578: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
27579: LD_VAR 0 8
27583: PPUSH
27584: LD_INT 16
27586: PPUSH
27587: CALL 56386 0 2
27591: PUSH
27592: LD_INT 4
27594: ARRAY
27595: PUSH
27596: LD_INT 10
27598: LESS
27599: IFFALSE 27615
// ComRepairBuilding ( j , to_repair ) ;
27601: LD_VAR 0 3
27605: PPUSH
27606: LD_VAR 0 8
27610: PPUSH
27611: CALL_OW 130
// end else
27615: GO 27675
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
27617: LD_VAR 0 3
27621: PPUSH
27622: CALL_OW 256
27626: PUSH
27627: LD_INT 500
27629: LESS
27630: PUSH
27631: LD_VAR 0 3
27635: PPUSH
27636: LD_EXP 74
27640: PUSH
27641: LD_VAR 0 2
27645: ARRAY
27646: PPUSH
27647: CALL_OW 308
27651: NOT
27652: AND
27653: IFFALSE 27675
// ComMoveToArea ( j , mc_parking [ i ] ) ;
27655: LD_VAR 0 3
27659: PPUSH
27660: LD_EXP 74
27664: PUSH
27665: LD_VAR 0 2
27669: ARRAY
27670: PPUSH
27671: CALL_OW 113
// end ;
27675: GO 27523
27677: POP
27678: POP
// end ; if tmp > 3 then
27679: LD_VAR 0 5
27683: PUSH
27684: LD_INT 3
27686: GREATER
27687: IFFALSE 27707
// tmp := ShrinkArray ( tmp , 4 ) ;
27689: LD_ADDR_VAR 0 5
27693: PUSH
27694: LD_VAR 0 5
27698: PPUSH
27699: LD_INT 4
27701: PPUSH
27702: CALL 86416 0 2
27706: ST_TO_ADDR
// if not tmp then
27707: LD_VAR 0 5
27711: NOT
27712: IFFALSE 27716
// continue ;
27714: GO 27096
// for j in tmp do
27716: LD_ADDR_VAR 0 3
27720: PUSH
27721: LD_VAR 0 5
27725: PUSH
27726: FOR_IN
27727: IFFALSE 27986
// begin if IsInUnit ( j ) then
27729: LD_VAR 0 3
27733: PPUSH
27734: CALL_OW 310
27738: IFFALSE 27749
// ComExitBuilding ( j ) ;
27740: LD_VAR 0 3
27744: PPUSH
27745: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
27749: LD_VAR 0 3
27753: PUSH
27754: LD_EXP 52
27758: PUSH
27759: LD_VAR 0 2
27763: ARRAY
27764: IN
27765: NOT
27766: IFFALSE 27824
// begin SetTag ( j , 101 ) ;
27768: LD_VAR 0 3
27772: PPUSH
27773: LD_INT 101
27775: PPUSH
27776: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
27780: LD_ADDR_EXP 52
27784: PUSH
27785: LD_EXP 52
27789: PPUSH
27790: LD_VAR 0 2
27794: PUSH
27795: LD_EXP 52
27799: PUSH
27800: LD_VAR 0 2
27804: ARRAY
27805: PUSH
27806: LD_INT 1
27808: PLUS
27809: PUSH
27810: EMPTY
27811: LIST
27812: LIST
27813: PPUSH
27814: LD_VAR 0 3
27818: PPUSH
27819: CALL 53789 0 3
27823: ST_TO_ADDR
// end ; wait ( 1 ) ;
27824: LD_INT 1
27826: PPUSH
27827: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
27831: LD_ADDR_VAR 0 7
27835: PUSH
27836: LD_EXP 51
27840: PUSH
27841: LD_VAR 0 2
27845: ARRAY
27846: ST_TO_ADDR
// if mc_scan [ i ] then
27847: LD_EXP 73
27851: PUSH
27852: LD_VAR 0 2
27856: ARRAY
27857: IFFALSE 27919
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
27859: LD_ADDR_VAR 0 7
27863: PUSH
27864: LD_EXP 51
27868: PUSH
27869: LD_VAR 0 2
27873: ARRAY
27874: PPUSH
27875: LD_INT 3
27877: PUSH
27878: LD_INT 30
27880: PUSH
27881: LD_INT 32
27883: PUSH
27884: EMPTY
27885: LIST
27886: LIST
27887: PUSH
27888: LD_INT 30
27890: PUSH
27891: LD_INT 33
27893: PUSH
27894: EMPTY
27895: LIST
27896: LIST
27897: PUSH
27898: LD_INT 30
27900: PUSH
27901: LD_INT 31
27903: PUSH
27904: EMPTY
27905: LIST
27906: LIST
27907: PUSH
27908: EMPTY
27909: LIST
27910: LIST
27911: LIST
27912: LIST
27913: PPUSH
27914: CALL_OW 72
27918: ST_TO_ADDR
// if not to_repair_tmp then
27919: LD_VAR 0 7
27923: NOT
27924: IFFALSE 27928
// continue ;
27926: GO 27726
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
27928: LD_ADDR_VAR 0 8
27932: PUSH
27933: LD_VAR 0 7
27937: PPUSH
27938: LD_VAR 0 3
27942: PPUSH
27943: CALL_OW 74
27947: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
27948: LD_VAR 0 8
27952: PPUSH
27953: LD_INT 16
27955: PPUSH
27956: CALL 56386 0 2
27960: PUSH
27961: LD_INT 4
27963: ARRAY
27964: PUSH
27965: LD_INT 14
27967: LESS
27968: IFFALSE 27984
// ComRepairBuilding ( j , to_repair ) ;
27970: LD_VAR 0 3
27974: PPUSH
27975: LD_VAR 0 8
27979: PPUSH
27980: CALL_OW 130
// end ;
27984: GO 27726
27986: POP
27987: POP
// end ;
27988: GO 27096
27990: POP
27991: POP
// end ;
27992: LD_VAR 0 1
27996: RET
// export function MC_Heal ; var i , j , tmp ; begin
27997: LD_INT 0
27999: PPUSH
28000: PPUSH
28001: PPUSH
28002: PPUSH
// if not mc_bases then
28003: LD_EXP 50
28007: NOT
28008: IFFALSE 28012
// exit ;
28010: GO 28414
// for i = 1 to mc_bases do
28012: LD_ADDR_VAR 0 2
28016: PUSH
28017: DOUBLE
28018: LD_INT 1
28020: DEC
28021: ST_TO_ADDR
28022: LD_EXP 50
28026: PUSH
28027: FOR_TO
28028: IFFALSE 28412
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
28030: LD_EXP 53
28034: PUSH
28035: LD_VAR 0 2
28039: ARRAY
28040: PUSH
28041: LD_INT 1
28043: ARRAY
28044: NOT
28045: PUSH
28046: LD_EXP 53
28050: PUSH
28051: LD_VAR 0 2
28055: ARRAY
28056: PUSH
28057: LD_INT 2
28059: ARRAY
28060: NOT
28061: AND
28062: IFFALSE 28100
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
28064: LD_ADDR_EXP 54
28068: PUSH
28069: LD_EXP 54
28073: PPUSH
28074: LD_VAR 0 2
28078: PPUSH
28079: EMPTY
28080: PPUSH
28081: CALL_OW 1
28085: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
28086: LD_VAR 0 2
28090: PPUSH
28091: LD_INT 102
28093: PPUSH
28094: CALL 22149 0 2
// continue ;
28098: GO 28027
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
28100: LD_ADDR_VAR 0 4
28104: PUSH
28105: LD_EXP 50
28109: PUSH
28110: LD_VAR 0 2
28114: ARRAY
28115: PPUSH
28116: LD_INT 25
28118: PUSH
28119: LD_INT 4
28121: PUSH
28122: EMPTY
28123: LIST
28124: LIST
28125: PPUSH
28126: CALL_OW 72
28130: ST_TO_ADDR
// if not tmp then
28131: LD_VAR 0 4
28135: NOT
28136: IFFALSE 28140
// continue ;
28138: GO 28027
// if mc_taming [ i ] then
28140: LD_EXP 81
28144: PUSH
28145: LD_VAR 0 2
28149: ARRAY
28150: IFFALSE 28174
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
28152: LD_ADDR_EXP 81
28156: PUSH
28157: LD_EXP 81
28161: PPUSH
28162: LD_VAR 0 2
28166: PPUSH
28167: EMPTY
28168: PPUSH
28169: CALL_OW 1
28173: ST_TO_ADDR
// for j in tmp do
28174: LD_ADDR_VAR 0 3
28178: PUSH
28179: LD_VAR 0 4
28183: PUSH
28184: FOR_IN
28185: IFFALSE 28408
// begin if IsInUnit ( j ) then
28187: LD_VAR 0 3
28191: PPUSH
28192: CALL_OW 310
28196: IFFALSE 28207
// ComExitBuilding ( j ) ;
28198: LD_VAR 0 3
28202: PPUSH
28203: CALL_OW 122
// if not j in mc_healers [ i ] then
28207: LD_VAR 0 3
28211: PUSH
28212: LD_EXP 54
28216: PUSH
28217: LD_VAR 0 2
28221: ARRAY
28222: IN
28223: NOT
28224: IFFALSE 28270
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
28226: LD_ADDR_EXP 54
28230: PUSH
28231: LD_EXP 54
28235: PPUSH
28236: LD_VAR 0 2
28240: PUSH
28241: LD_EXP 54
28245: PUSH
28246: LD_VAR 0 2
28250: ARRAY
28251: PUSH
28252: LD_INT 1
28254: PLUS
28255: PUSH
28256: EMPTY
28257: LIST
28258: LIST
28259: PPUSH
28260: LD_VAR 0 3
28264: PPUSH
28265: CALL 53789 0 3
28269: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
28270: LD_VAR 0 3
28274: PPUSH
28275: CALL_OW 110
28279: PUSH
28280: LD_INT 102
28282: NONEQUAL
28283: IFFALSE 28297
// SetTag ( j , 102 ) ;
28285: LD_VAR 0 3
28289: PPUSH
28290: LD_INT 102
28292: PPUSH
28293: CALL_OW 109
// Wait ( 3 ) ;
28297: LD_INT 3
28299: PPUSH
28300: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
28304: LD_EXP 53
28308: PUSH
28309: LD_VAR 0 2
28313: ARRAY
28314: PUSH
28315: LD_INT 1
28317: ARRAY
28318: IFFALSE 28350
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
28320: LD_VAR 0 3
28324: PPUSH
28325: LD_EXP 53
28329: PUSH
28330: LD_VAR 0 2
28334: ARRAY
28335: PUSH
28336: LD_INT 1
28338: ARRAY
28339: PUSH
28340: LD_INT 1
28342: ARRAY
28343: PPUSH
28344: CALL_OW 128
28348: GO 28406
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
28350: LD_VAR 0 3
28354: PPUSH
28355: CALL_OW 314
28359: NOT
28360: PUSH
28361: LD_EXP 53
28365: PUSH
28366: LD_VAR 0 2
28370: ARRAY
28371: PUSH
28372: LD_INT 2
28374: ARRAY
28375: AND
28376: IFFALSE 28406
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
28378: LD_VAR 0 3
28382: PPUSH
28383: LD_EXP 53
28387: PUSH
28388: LD_VAR 0 2
28392: ARRAY
28393: PUSH
28394: LD_INT 2
28396: ARRAY
28397: PUSH
28398: LD_INT 1
28400: ARRAY
28401: PPUSH
28402: CALL_OW 128
// end ;
28406: GO 28184
28408: POP
28409: POP
// end ;
28410: GO 28027
28412: POP
28413: POP
// end ;
28414: LD_VAR 0 1
28418: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
28419: LD_INT 0
28421: PPUSH
28422: PPUSH
28423: PPUSH
28424: PPUSH
28425: PPUSH
28426: PPUSH
// if not mc_bases then
28427: LD_EXP 50
28431: NOT
28432: IFFALSE 28436
// exit ;
28434: GO 29599
// for i = 1 to mc_bases do
28436: LD_ADDR_VAR 0 2
28440: PUSH
28441: DOUBLE
28442: LD_INT 1
28444: DEC
28445: ST_TO_ADDR
28446: LD_EXP 50
28450: PUSH
28451: FOR_TO
28452: IFFALSE 29597
// begin if mc_scan [ i ] then
28454: LD_EXP 73
28458: PUSH
28459: LD_VAR 0 2
28463: ARRAY
28464: IFFALSE 28468
// continue ;
28466: GO 28451
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
28468: LD_EXP 55
28472: PUSH
28473: LD_VAR 0 2
28477: ARRAY
28478: NOT
28479: PUSH
28480: LD_EXP 57
28484: PUSH
28485: LD_VAR 0 2
28489: ARRAY
28490: NOT
28491: AND
28492: PUSH
28493: LD_EXP 56
28497: PUSH
28498: LD_VAR 0 2
28502: ARRAY
28503: AND
28504: IFFALSE 28542
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
28506: LD_ADDR_EXP 56
28510: PUSH
28511: LD_EXP 56
28515: PPUSH
28516: LD_VAR 0 2
28520: PPUSH
28521: EMPTY
28522: PPUSH
28523: CALL_OW 1
28527: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
28528: LD_VAR 0 2
28532: PPUSH
28533: LD_INT 103
28535: PPUSH
28536: CALL 22149 0 2
// continue ;
28540: GO 28451
// end ; if mc_construct_list [ i ] then
28542: LD_EXP 57
28546: PUSH
28547: LD_VAR 0 2
28551: ARRAY
28552: IFFALSE 28772
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
28554: LD_ADDR_VAR 0 5
28558: PUSH
28559: LD_EXP 50
28563: PUSH
28564: LD_VAR 0 2
28568: ARRAY
28569: PPUSH
28570: LD_INT 25
28572: PUSH
28573: LD_INT 2
28575: PUSH
28576: EMPTY
28577: LIST
28578: LIST
28579: PPUSH
28580: CALL_OW 72
28584: PUSH
28585: LD_EXP 52
28589: PUSH
28590: LD_VAR 0 2
28594: ARRAY
28595: DIFF
28596: ST_TO_ADDR
// if not tmp then
28597: LD_VAR 0 5
28601: NOT
28602: IFFALSE 28606
// continue ;
28604: GO 28451
// for j in tmp do
28606: LD_ADDR_VAR 0 3
28610: PUSH
28611: LD_VAR 0 5
28615: PUSH
28616: FOR_IN
28617: IFFALSE 28768
// begin if not mc_builders [ i ] then
28619: LD_EXP 56
28623: PUSH
28624: LD_VAR 0 2
28628: ARRAY
28629: NOT
28630: IFFALSE 28688
// begin SetTag ( j , 103 ) ;
28632: LD_VAR 0 3
28636: PPUSH
28637: LD_INT 103
28639: PPUSH
28640: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
28644: LD_ADDR_EXP 56
28648: PUSH
28649: LD_EXP 56
28653: PPUSH
28654: LD_VAR 0 2
28658: PUSH
28659: LD_EXP 56
28663: PUSH
28664: LD_VAR 0 2
28668: ARRAY
28669: PUSH
28670: LD_INT 1
28672: PLUS
28673: PUSH
28674: EMPTY
28675: LIST
28676: LIST
28677: PPUSH
28678: LD_VAR 0 3
28682: PPUSH
28683: CALL 53789 0 3
28687: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
28688: LD_VAR 0 3
28692: PPUSH
28693: CALL_OW 310
28697: IFFALSE 28708
// ComExitBuilding ( j ) ;
28699: LD_VAR 0 3
28703: PPUSH
28704: CALL_OW 122
// wait ( 3 ) ;
28708: LD_INT 3
28710: PPUSH
28711: CALL_OW 67
// if not mc_construct_list [ i ] then
28715: LD_EXP 57
28719: PUSH
28720: LD_VAR 0 2
28724: ARRAY
28725: NOT
28726: IFFALSE 28730
// break ;
28728: GO 28768
// if not HasTask ( j ) then
28730: LD_VAR 0 3
28734: PPUSH
28735: CALL_OW 314
28739: NOT
28740: IFFALSE 28766
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
28742: LD_VAR 0 3
28746: PPUSH
28747: LD_EXP 57
28751: PUSH
28752: LD_VAR 0 2
28756: ARRAY
28757: PUSH
28758: LD_INT 1
28760: ARRAY
28761: PPUSH
28762: CALL 56650 0 2
// end ;
28766: GO 28616
28768: POP
28769: POP
// end else
28770: GO 29595
// if mc_build_list [ i ] then
28772: LD_EXP 55
28776: PUSH
28777: LD_VAR 0 2
28781: ARRAY
28782: IFFALSE 29595
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
28784: LD_EXP 55
28788: PUSH
28789: LD_VAR 0 2
28793: ARRAY
28794: PUSH
28795: LD_INT 1
28797: ARRAY
28798: PUSH
28799: LD_INT 1
28801: ARRAY
28802: PPUSH
28803: CALL 56474 0 1
28807: PUSH
28808: LD_EXP 50
28812: PUSH
28813: LD_VAR 0 2
28817: ARRAY
28818: PPUSH
28819: LD_INT 2
28821: PUSH
28822: LD_INT 30
28824: PUSH
28825: LD_INT 2
28827: PUSH
28828: EMPTY
28829: LIST
28830: LIST
28831: PUSH
28832: LD_INT 30
28834: PUSH
28835: LD_INT 3
28837: PUSH
28838: EMPTY
28839: LIST
28840: LIST
28841: PUSH
28842: EMPTY
28843: LIST
28844: LIST
28845: LIST
28846: PPUSH
28847: CALL_OW 72
28851: NOT
28852: AND
28853: IFFALSE 28958
// begin for j = 1 to mc_build_list [ i ] do
28855: LD_ADDR_VAR 0 3
28859: PUSH
28860: DOUBLE
28861: LD_INT 1
28863: DEC
28864: ST_TO_ADDR
28865: LD_EXP 55
28869: PUSH
28870: LD_VAR 0 2
28874: ARRAY
28875: PUSH
28876: FOR_TO
28877: IFFALSE 28956
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
28879: LD_EXP 55
28883: PUSH
28884: LD_VAR 0 2
28888: ARRAY
28889: PUSH
28890: LD_VAR 0 3
28894: ARRAY
28895: PUSH
28896: LD_INT 1
28898: ARRAY
28899: PUSH
28900: LD_INT 2
28902: EQUAL
28903: IFFALSE 28954
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
28905: LD_ADDR_EXP 55
28909: PUSH
28910: LD_EXP 55
28914: PPUSH
28915: LD_VAR 0 2
28919: PPUSH
28920: LD_EXP 55
28924: PUSH
28925: LD_VAR 0 2
28929: ARRAY
28930: PPUSH
28931: LD_VAR 0 3
28935: PPUSH
28936: LD_INT 1
28938: PPUSH
28939: LD_INT 0
28941: PPUSH
28942: CALL 53207 0 4
28946: PPUSH
28947: CALL_OW 1
28951: ST_TO_ADDR
// break ;
28952: GO 28956
// end ;
28954: GO 28876
28956: POP
28957: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
28958: LD_ADDR_VAR 0 6
28962: PUSH
28963: LD_EXP 50
28967: PUSH
28968: LD_VAR 0 2
28972: ARRAY
28973: PPUSH
28974: LD_INT 2
28976: PUSH
28977: LD_INT 30
28979: PUSH
28980: LD_INT 0
28982: PUSH
28983: EMPTY
28984: LIST
28985: LIST
28986: PUSH
28987: LD_INT 30
28989: PUSH
28990: LD_INT 1
28992: PUSH
28993: EMPTY
28994: LIST
28995: LIST
28996: PUSH
28997: EMPTY
28998: LIST
28999: LIST
29000: LIST
29001: PPUSH
29002: CALL_OW 72
29006: ST_TO_ADDR
// for k := 1 to depot do
29007: LD_ADDR_VAR 0 4
29011: PUSH
29012: DOUBLE
29013: LD_INT 1
29015: DEC
29016: ST_TO_ADDR
29017: LD_VAR 0 6
29021: PUSH
29022: FOR_TO
29023: IFFALSE 29593
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
29025: LD_EXP 55
29029: PUSH
29030: LD_VAR 0 2
29034: ARRAY
29035: PUSH
29036: LD_INT 1
29038: ARRAY
29039: PUSH
29040: LD_INT 1
29042: ARRAY
29043: PUSH
29044: LD_INT 0
29046: EQUAL
29047: PUSH
29048: LD_VAR 0 6
29052: PUSH
29053: LD_VAR 0 4
29057: ARRAY
29058: PPUSH
29059: LD_EXP 55
29063: PUSH
29064: LD_VAR 0 2
29068: ARRAY
29069: PUSH
29070: LD_INT 1
29072: ARRAY
29073: PUSH
29074: LD_INT 1
29076: ARRAY
29077: PPUSH
29078: LD_EXP 55
29082: PUSH
29083: LD_VAR 0 2
29087: ARRAY
29088: PUSH
29089: LD_INT 1
29091: ARRAY
29092: PUSH
29093: LD_INT 2
29095: ARRAY
29096: PPUSH
29097: LD_EXP 55
29101: PUSH
29102: LD_VAR 0 2
29106: ARRAY
29107: PUSH
29108: LD_INT 1
29110: ARRAY
29111: PUSH
29112: LD_INT 3
29114: ARRAY
29115: PPUSH
29116: LD_EXP 55
29120: PUSH
29121: LD_VAR 0 2
29125: ARRAY
29126: PUSH
29127: LD_INT 1
29129: ARRAY
29130: PUSH
29131: LD_INT 4
29133: ARRAY
29134: PPUSH
29135: CALL 61886 0 5
29139: OR
29140: IFFALSE 29421
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
29142: LD_ADDR_VAR 0 5
29146: PUSH
29147: LD_EXP 50
29151: PUSH
29152: LD_VAR 0 2
29156: ARRAY
29157: PPUSH
29158: LD_INT 25
29160: PUSH
29161: LD_INT 2
29163: PUSH
29164: EMPTY
29165: LIST
29166: LIST
29167: PPUSH
29168: CALL_OW 72
29172: PUSH
29173: LD_EXP 52
29177: PUSH
29178: LD_VAR 0 2
29182: ARRAY
29183: DIFF
29184: ST_TO_ADDR
// if not tmp then
29185: LD_VAR 0 5
29189: NOT
29190: IFFALSE 29194
// continue ;
29192: GO 29022
// for j in tmp do
29194: LD_ADDR_VAR 0 3
29198: PUSH
29199: LD_VAR 0 5
29203: PUSH
29204: FOR_IN
29205: IFFALSE 29417
// begin if not mc_builders [ i ] then
29207: LD_EXP 56
29211: PUSH
29212: LD_VAR 0 2
29216: ARRAY
29217: NOT
29218: IFFALSE 29276
// begin SetTag ( j , 103 ) ;
29220: LD_VAR 0 3
29224: PPUSH
29225: LD_INT 103
29227: PPUSH
29228: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
29232: LD_ADDR_EXP 56
29236: PUSH
29237: LD_EXP 56
29241: PPUSH
29242: LD_VAR 0 2
29246: PUSH
29247: LD_EXP 56
29251: PUSH
29252: LD_VAR 0 2
29256: ARRAY
29257: PUSH
29258: LD_INT 1
29260: PLUS
29261: PUSH
29262: EMPTY
29263: LIST
29264: LIST
29265: PPUSH
29266: LD_VAR 0 3
29270: PPUSH
29271: CALL 53789 0 3
29275: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
29276: LD_VAR 0 3
29280: PPUSH
29281: CALL_OW 310
29285: IFFALSE 29296
// ComExitBuilding ( j ) ;
29287: LD_VAR 0 3
29291: PPUSH
29292: CALL_OW 122
// wait ( 3 ) ;
29296: LD_INT 3
29298: PPUSH
29299: CALL_OW 67
// if not mc_build_list [ i ] then
29303: LD_EXP 55
29307: PUSH
29308: LD_VAR 0 2
29312: ARRAY
29313: NOT
29314: IFFALSE 29318
// break ;
29316: GO 29417
// if not HasTask ( j ) then
29318: LD_VAR 0 3
29322: PPUSH
29323: CALL_OW 314
29327: NOT
29328: IFFALSE 29415
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
29330: LD_VAR 0 3
29334: PPUSH
29335: LD_EXP 55
29339: PUSH
29340: LD_VAR 0 2
29344: ARRAY
29345: PUSH
29346: LD_INT 1
29348: ARRAY
29349: PUSH
29350: LD_INT 1
29352: ARRAY
29353: PPUSH
29354: LD_EXP 55
29358: PUSH
29359: LD_VAR 0 2
29363: ARRAY
29364: PUSH
29365: LD_INT 1
29367: ARRAY
29368: PUSH
29369: LD_INT 2
29371: ARRAY
29372: PPUSH
29373: LD_EXP 55
29377: PUSH
29378: LD_VAR 0 2
29382: ARRAY
29383: PUSH
29384: LD_INT 1
29386: ARRAY
29387: PUSH
29388: LD_INT 3
29390: ARRAY
29391: PPUSH
29392: LD_EXP 55
29396: PUSH
29397: LD_VAR 0 2
29401: ARRAY
29402: PUSH
29403: LD_INT 1
29405: ARRAY
29406: PUSH
29407: LD_INT 4
29409: ARRAY
29410: PPUSH
29411: CALL_OW 145
// end ;
29415: GO 29204
29417: POP
29418: POP
// end else
29419: GO 29591
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
29421: LD_EXP 50
29425: PUSH
29426: LD_VAR 0 2
29430: ARRAY
29431: PPUSH
29432: LD_EXP 55
29436: PUSH
29437: LD_VAR 0 2
29441: ARRAY
29442: PUSH
29443: LD_INT 1
29445: ARRAY
29446: PUSH
29447: LD_INT 1
29449: ARRAY
29450: PPUSH
29451: LD_EXP 55
29455: PUSH
29456: LD_VAR 0 2
29460: ARRAY
29461: PUSH
29462: LD_INT 1
29464: ARRAY
29465: PUSH
29466: LD_INT 2
29468: ARRAY
29469: PPUSH
29470: LD_EXP 55
29474: PUSH
29475: LD_VAR 0 2
29479: ARRAY
29480: PUSH
29481: LD_INT 1
29483: ARRAY
29484: PUSH
29485: LD_INT 3
29487: ARRAY
29488: PPUSH
29489: LD_EXP 55
29493: PUSH
29494: LD_VAR 0 2
29498: ARRAY
29499: PUSH
29500: LD_INT 1
29502: ARRAY
29503: PUSH
29504: LD_INT 4
29506: ARRAY
29507: PPUSH
29508: LD_EXP 50
29512: PUSH
29513: LD_VAR 0 2
29517: ARRAY
29518: PPUSH
29519: LD_INT 21
29521: PUSH
29522: LD_INT 3
29524: PUSH
29525: EMPTY
29526: LIST
29527: LIST
29528: PPUSH
29529: CALL_OW 72
29533: PPUSH
29534: EMPTY
29535: PPUSH
29536: CALL 60640 0 7
29540: NOT
29541: IFFALSE 29591
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
29543: LD_ADDR_EXP 55
29547: PUSH
29548: LD_EXP 55
29552: PPUSH
29553: LD_VAR 0 2
29557: PPUSH
29558: LD_EXP 55
29562: PUSH
29563: LD_VAR 0 2
29567: ARRAY
29568: PPUSH
29569: LD_INT 1
29571: PPUSH
29572: LD_INT 1
29574: NEG
29575: PPUSH
29576: LD_INT 0
29578: PPUSH
29579: CALL 53207 0 4
29583: PPUSH
29584: CALL_OW 1
29588: ST_TO_ADDR
// continue ;
29589: GO 29022
// end ; end ;
29591: GO 29022
29593: POP
29594: POP
// end ; end ;
29595: GO 28451
29597: POP
29598: POP
// end ;
29599: LD_VAR 0 1
29603: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
29604: LD_INT 0
29606: PPUSH
29607: PPUSH
29608: PPUSH
29609: PPUSH
29610: PPUSH
29611: PPUSH
// if not mc_bases then
29612: LD_EXP 50
29616: NOT
29617: IFFALSE 29621
// exit ;
29619: GO 30048
// for i = 1 to mc_bases do
29621: LD_ADDR_VAR 0 2
29625: PUSH
29626: DOUBLE
29627: LD_INT 1
29629: DEC
29630: ST_TO_ADDR
29631: LD_EXP 50
29635: PUSH
29636: FOR_TO
29637: IFFALSE 30046
// begin tmp := mc_build_upgrade [ i ] ;
29639: LD_ADDR_VAR 0 4
29643: PUSH
29644: LD_EXP 82
29648: PUSH
29649: LD_VAR 0 2
29653: ARRAY
29654: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
29655: LD_ADDR_VAR 0 6
29659: PUSH
29660: LD_EXP 83
29664: PUSH
29665: LD_VAR 0 2
29669: ARRAY
29670: PPUSH
29671: LD_INT 2
29673: PUSH
29674: LD_INT 30
29676: PUSH
29677: LD_INT 6
29679: PUSH
29680: EMPTY
29681: LIST
29682: LIST
29683: PUSH
29684: LD_INT 30
29686: PUSH
29687: LD_INT 7
29689: PUSH
29690: EMPTY
29691: LIST
29692: LIST
29693: PUSH
29694: EMPTY
29695: LIST
29696: LIST
29697: LIST
29698: PPUSH
29699: CALL_OW 72
29703: ST_TO_ADDR
// if not tmp and not lab then
29704: LD_VAR 0 4
29708: NOT
29709: PUSH
29710: LD_VAR 0 6
29714: NOT
29715: AND
29716: IFFALSE 29720
// continue ;
29718: GO 29636
// if tmp then
29720: LD_VAR 0 4
29724: IFFALSE 29844
// for j in tmp do
29726: LD_ADDR_VAR 0 3
29730: PUSH
29731: LD_VAR 0 4
29735: PUSH
29736: FOR_IN
29737: IFFALSE 29842
// begin if UpgradeCost ( j ) then
29739: LD_VAR 0 3
29743: PPUSH
29744: CALL 60300 0 1
29748: IFFALSE 29840
// begin ComUpgrade ( j ) ;
29750: LD_VAR 0 3
29754: PPUSH
29755: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
29759: LD_ADDR_EXP 82
29763: PUSH
29764: LD_EXP 82
29768: PPUSH
29769: LD_VAR 0 2
29773: PPUSH
29774: LD_EXP 82
29778: PUSH
29779: LD_VAR 0 2
29783: ARRAY
29784: PUSH
29785: LD_VAR 0 3
29789: DIFF
29790: PPUSH
29791: CALL_OW 1
29795: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
29796: LD_ADDR_EXP 57
29800: PUSH
29801: LD_EXP 57
29805: PPUSH
29806: LD_VAR 0 2
29810: PUSH
29811: LD_EXP 57
29815: PUSH
29816: LD_VAR 0 2
29820: ARRAY
29821: PUSH
29822: LD_INT 1
29824: PLUS
29825: PUSH
29826: EMPTY
29827: LIST
29828: LIST
29829: PPUSH
29830: LD_VAR 0 3
29834: PPUSH
29835: CALL 53789 0 3
29839: ST_TO_ADDR
// end ; end ;
29840: GO 29736
29842: POP
29843: POP
// if not lab or not mc_lab_upgrade [ i ] then
29844: LD_VAR 0 6
29848: NOT
29849: PUSH
29850: LD_EXP 84
29854: PUSH
29855: LD_VAR 0 2
29859: ARRAY
29860: NOT
29861: OR
29862: IFFALSE 29866
// continue ;
29864: GO 29636
// for j in lab do
29866: LD_ADDR_VAR 0 3
29870: PUSH
29871: LD_VAR 0 6
29875: PUSH
29876: FOR_IN
29877: IFFALSE 30042
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
29879: LD_VAR 0 3
29883: PPUSH
29884: CALL_OW 266
29888: PUSH
29889: LD_INT 6
29891: PUSH
29892: LD_INT 7
29894: PUSH
29895: EMPTY
29896: LIST
29897: LIST
29898: IN
29899: PUSH
29900: LD_VAR 0 3
29904: PPUSH
29905: CALL_OW 461
29909: PUSH
29910: LD_INT 1
29912: NONEQUAL
29913: AND
29914: IFFALSE 30040
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
29916: LD_VAR 0 3
29920: PPUSH
29921: LD_EXP 84
29925: PUSH
29926: LD_VAR 0 2
29930: ARRAY
29931: PUSH
29932: LD_INT 1
29934: ARRAY
29935: PPUSH
29936: CALL 60505 0 2
29940: IFFALSE 30040
// begin ComCancel ( j ) ;
29942: LD_VAR 0 3
29946: PPUSH
29947: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
29951: LD_VAR 0 3
29955: PPUSH
29956: LD_EXP 84
29960: PUSH
29961: LD_VAR 0 2
29965: ARRAY
29966: PUSH
29967: LD_INT 1
29969: ARRAY
29970: PPUSH
29971: CALL_OW 207
// if not j in mc_construct_list [ i ] then
29975: LD_VAR 0 3
29979: PUSH
29980: LD_EXP 57
29984: PUSH
29985: LD_VAR 0 2
29989: ARRAY
29990: IN
29991: NOT
29992: IFFALSE 30038
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
29994: LD_ADDR_EXP 57
29998: PUSH
29999: LD_EXP 57
30003: PPUSH
30004: LD_VAR 0 2
30008: PUSH
30009: LD_EXP 57
30013: PUSH
30014: LD_VAR 0 2
30018: ARRAY
30019: PUSH
30020: LD_INT 1
30022: PLUS
30023: PUSH
30024: EMPTY
30025: LIST
30026: LIST
30027: PPUSH
30028: LD_VAR 0 3
30032: PPUSH
30033: CALL 53789 0 3
30037: ST_TO_ADDR
// break ;
30038: GO 30042
// end ; end ; end ;
30040: GO 29876
30042: POP
30043: POP
// end ;
30044: GO 29636
30046: POP
30047: POP
// end ;
30048: LD_VAR 0 1
30052: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
30053: LD_INT 0
30055: PPUSH
30056: PPUSH
30057: PPUSH
30058: PPUSH
30059: PPUSH
30060: PPUSH
30061: PPUSH
30062: PPUSH
30063: PPUSH
// if not mc_bases then
30064: LD_EXP 50
30068: NOT
30069: IFFALSE 30073
// exit ;
30071: GO 30478
// for i = 1 to mc_bases do
30073: LD_ADDR_VAR 0 2
30077: PUSH
30078: DOUBLE
30079: LD_INT 1
30081: DEC
30082: ST_TO_ADDR
30083: LD_EXP 50
30087: PUSH
30088: FOR_TO
30089: IFFALSE 30476
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
30091: LD_EXP 58
30095: PUSH
30096: LD_VAR 0 2
30100: ARRAY
30101: NOT
30102: PUSH
30103: LD_EXP 50
30107: PUSH
30108: LD_VAR 0 2
30112: ARRAY
30113: PPUSH
30114: LD_INT 30
30116: PUSH
30117: LD_INT 3
30119: PUSH
30120: EMPTY
30121: LIST
30122: LIST
30123: PPUSH
30124: CALL_OW 72
30128: NOT
30129: OR
30130: IFFALSE 30134
// continue ;
30132: GO 30088
// busy := false ;
30134: LD_ADDR_VAR 0 8
30138: PUSH
30139: LD_INT 0
30141: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
30142: LD_ADDR_VAR 0 4
30146: PUSH
30147: LD_EXP 50
30151: PUSH
30152: LD_VAR 0 2
30156: ARRAY
30157: PPUSH
30158: LD_INT 30
30160: PUSH
30161: LD_INT 3
30163: PUSH
30164: EMPTY
30165: LIST
30166: LIST
30167: PPUSH
30168: CALL_OW 72
30172: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
30173: LD_ADDR_VAR 0 6
30177: PUSH
30178: LD_EXP 58
30182: PUSH
30183: LD_VAR 0 2
30187: ARRAY
30188: PPUSH
30189: LD_INT 2
30191: PUSH
30192: LD_INT 30
30194: PUSH
30195: LD_INT 32
30197: PUSH
30198: EMPTY
30199: LIST
30200: LIST
30201: PUSH
30202: LD_INT 30
30204: PUSH
30205: LD_INT 33
30207: PUSH
30208: EMPTY
30209: LIST
30210: LIST
30211: PUSH
30212: EMPTY
30213: LIST
30214: LIST
30215: LIST
30216: PPUSH
30217: CALL_OW 72
30221: ST_TO_ADDR
// if not t then
30222: LD_VAR 0 6
30226: NOT
30227: IFFALSE 30231
// continue ;
30229: GO 30088
// for j in tmp do
30231: LD_ADDR_VAR 0 3
30235: PUSH
30236: LD_VAR 0 4
30240: PUSH
30241: FOR_IN
30242: IFFALSE 30272
// if not BuildingStatus ( j ) = bs_idle then
30244: LD_VAR 0 3
30248: PPUSH
30249: CALL_OW 461
30253: PUSH
30254: LD_INT 2
30256: EQUAL
30257: NOT
30258: IFFALSE 30270
// begin busy := true ;
30260: LD_ADDR_VAR 0 8
30264: PUSH
30265: LD_INT 1
30267: ST_TO_ADDR
// break ;
30268: GO 30272
// end ;
30270: GO 30241
30272: POP
30273: POP
// if busy then
30274: LD_VAR 0 8
30278: IFFALSE 30282
// continue ;
30280: GO 30088
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
30282: LD_ADDR_VAR 0 7
30286: PUSH
30287: LD_VAR 0 6
30291: PPUSH
30292: LD_INT 35
30294: PUSH
30295: LD_INT 0
30297: PUSH
30298: EMPTY
30299: LIST
30300: LIST
30301: PPUSH
30302: CALL_OW 72
30306: ST_TO_ADDR
// if tw then
30307: LD_VAR 0 7
30311: IFFALSE 30388
// begin tw := tw [ 1 ] ;
30313: LD_ADDR_VAR 0 7
30317: PUSH
30318: LD_VAR 0 7
30322: PUSH
30323: LD_INT 1
30325: ARRAY
30326: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
30327: LD_ADDR_VAR 0 9
30331: PUSH
30332: LD_VAR 0 7
30336: PPUSH
30337: LD_EXP 75
30341: PUSH
30342: LD_VAR 0 2
30346: ARRAY
30347: PPUSH
30348: CALL 58797 0 2
30352: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
30353: LD_EXP 89
30357: PUSH
30358: LD_VAR 0 2
30362: ARRAY
30363: IFFALSE 30386
// if not weapon in mc_allowed_tower_weapons [ i ] then
30365: LD_VAR 0 9
30369: PUSH
30370: LD_EXP 89
30374: PUSH
30375: LD_VAR 0 2
30379: ARRAY
30380: IN
30381: NOT
30382: IFFALSE 30386
// continue ;
30384: GO 30088
// end else
30386: GO 30451
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
30388: LD_ADDR_VAR 0 5
30392: PUSH
30393: LD_EXP 58
30397: PUSH
30398: LD_VAR 0 2
30402: ARRAY
30403: PPUSH
30404: LD_VAR 0 4
30408: PPUSH
30409: CALL 85649 0 2
30413: ST_TO_ADDR
// if not tmp2 then
30414: LD_VAR 0 5
30418: NOT
30419: IFFALSE 30423
// continue ;
30421: GO 30088
// tw := tmp2 [ 1 ] ;
30423: LD_ADDR_VAR 0 7
30427: PUSH
30428: LD_VAR 0 5
30432: PUSH
30433: LD_INT 1
30435: ARRAY
30436: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
30437: LD_ADDR_VAR 0 9
30441: PUSH
30442: LD_VAR 0 5
30446: PUSH
30447: LD_INT 2
30449: ARRAY
30450: ST_TO_ADDR
// end ; if not weapon then
30451: LD_VAR 0 9
30455: NOT
30456: IFFALSE 30460
// continue ;
30458: GO 30088
// ComPlaceWeapon ( tw , weapon ) ;
30460: LD_VAR 0 7
30464: PPUSH
30465: LD_VAR 0 9
30469: PPUSH
30470: CALL_OW 148
// end ;
30474: GO 30088
30476: POP
30477: POP
// end ;
30478: LD_VAR 0 1
30482: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
30483: LD_INT 0
30485: PPUSH
30486: PPUSH
30487: PPUSH
30488: PPUSH
30489: PPUSH
30490: PPUSH
30491: PPUSH
// if not mc_bases then
30492: LD_EXP 50
30496: NOT
30497: IFFALSE 30501
// exit ;
30499: GO 31269
// for i = 1 to mc_bases do
30501: LD_ADDR_VAR 0 2
30505: PUSH
30506: DOUBLE
30507: LD_INT 1
30509: DEC
30510: ST_TO_ADDR
30511: LD_EXP 50
30515: PUSH
30516: FOR_TO
30517: IFFALSE 31267
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
30519: LD_EXP 63
30523: PUSH
30524: LD_VAR 0 2
30528: ARRAY
30529: NOT
30530: PUSH
30531: LD_EXP 63
30535: PUSH
30536: LD_VAR 0 2
30540: ARRAY
30541: PUSH
30542: LD_EXP 64
30546: PUSH
30547: LD_VAR 0 2
30551: ARRAY
30552: EQUAL
30553: OR
30554: PUSH
30555: LD_EXP 73
30559: PUSH
30560: LD_VAR 0 2
30564: ARRAY
30565: OR
30566: IFFALSE 30570
// continue ;
30568: GO 30516
// if mc_miners [ i ] then
30570: LD_EXP 64
30574: PUSH
30575: LD_VAR 0 2
30579: ARRAY
30580: IFFALSE 30954
// begin for j = mc_miners [ i ] downto 1 do
30582: LD_ADDR_VAR 0 3
30586: PUSH
30587: DOUBLE
30588: LD_EXP 64
30592: PUSH
30593: LD_VAR 0 2
30597: ARRAY
30598: INC
30599: ST_TO_ADDR
30600: LD_INT 1
30602: PUSH
30603: FOR_DOWNTO
30604: IFFALSE 30952
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
30606: LD_EXP 64
30610: PUSH
30611: LD_VAR 0 2
30615: ARRAY
30616: PUSH
30617: LD_VAR 0 3
30621: ARRAY
30622: PPUSH
30623: CALL_OW 301
30627: PUSH
30628: LD_EXP 64
30632: PUSH
30633: LD_VAR 0 2
30637: ARRAY
30638: PUSH
30639: LD_VAR 0 3
30643: ARRAY
30644: PPUSH
30645: CALL_OW 257
30649: PUSH
30650: LD_INT 1
30652: NONEQUAL
30653: OR
30654: IFFALSE 30717
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
30656: LD_ADDR_VAR 0 5
30660: PUSH
30661: LD_EXP 64
30665: PUSH
30666: LD_VAR 0 2
30670: ARRAY
30671: PUSH
30672: LD_EXP 64
30676: PUSH
30677: LD_VAR 0 2
30681: ARRAY
30682: PUSH
30683: LD_VAR 0 3
30687: ARRAY
30688: DIFF
30689: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
30690: LD_ADDR_EXP 64
30694: PUSH
30695: LD_EXP 64
30699: PPUSH
30700: LD_VAR 0 2
30704: PPUSH
30705: LD_VAR 0 5
30709: PPUSH
30710: CALL_OW 1
30714: ST_TO_ADDR
// continue ;
30715: GO 30603
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
30717: LD_EXP 64
30721: PUSH
30722: LD_VAR 0 2
30726: ARRAY
30727: PUSH
30728: LD_VAR 0 3
30732: ARRAY
30733: PPUSH
30734: CALL_OW 257
30738: PUSH
30739: LD_INT 1
30741: EQUAL
30742: PUSH
30743: LD_EXP 64
30747: PUSH
30748: LD_VAR 0 2
30752: ARRAY
30753: PUSH
30754: LD_VAR 0 3
30758: ARRAY
30759: PPUSH
30760: CALL_OW 459
30764: NOT
30765: AND
30766: PUSH
30767: LD_EXP 64
30771: PUSH
30772: LD_VAR 0 2
30776: ARRAY
30777: PUSH
30778: LD_VAR 0 3
30782: ARRAY
30783: PPUSH
30784: CALL_OW 314
30788: NOT
30789: AND
30790: IFFALSE 30950
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
30792: LD_EXP 64
30796: PUSH
30797: LD_VAR 0 2
30801: ARRAY
30802: PUSH
30803: LD_VAR 0 3
30807: ARRAY
30808: PPUSH
30809: CALL_OW 310
30813: IFFALSE 30836
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
30815: LD_EXP 64
30819: PUSH
30820: LD_VAR 0 2
30824: ARRAY
30825: PUSH
30826: LD_VAR 0 3
30830: ARRAY
30831: PPUSH
30832: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
30836: LD_EXP 64
30840: PUSH
30841: LD_VAR 0 2
30845: ARRAY
30846: PUSH
30847: LD_VAR 0 3
30851: ARRAY
30852: PPUSH
30853: CALL_OW 314
30857: NOT
30858: IFFALSE 30950
// begin r := rand ( 1 , mc_mines [ i ] ) ;
30860: LD_ADDR_VAR 0 7
30864: PUSH
30865: LD_INT 1
30867: PPUSH
30868: LD_EXP 63
30872: PUSH
30873: LD_VAR 0 2
30877: ARRAY
30878: PPUSH
30879: CALL_OW 12
30883: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
30884: LD_EXP 64
30888: PUSH
30889: LD_VAR 0 2
30893: ARRAY
30894: PUSH
30895: LD_VAR 0 3
30899: ARRAY
30900: PPUSH
30901: LD_EXP 63
30905: PUSH
30906: LD_VAR 0 2
30910: ARRAY
30911: PUSH
30912: LD_VAR 0 7
30916: ARRAY
30917: PUSH
30918: LD_INT 1
30920: ARRAY
30921: PPUSH
30922: LD_EXP 63
30926: PUSH
30927: LD_VAR 0 2
30931: ARRAY
30932: PUSH
30933: LD_VAR 0 7
30937: ARRAY
30938: PUSH
30939: LD_INT 2
30941: ARRAY
30942: PPUSH
30943: LD_INT 0
30945: PPUSH
30946: CALL_OW 193
// end ; end ; end ;
30950: GO 30603
30952: POP
30953: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
30954: LD_ADDR_VAR 0 5
30958: PUSH
30959: LD_EXP 50
30963: PUSH
30964: LD_VAR 0 2
30968: ARRAY
30969: PPUSH
30970: LD_INT 2
30972: PUSH
30973: LD_INT 30
30975: PUSH
30976: LD_INT 4
30978: PUSH
30979: EMPTY
30980: LIST
30981: LIST
30982: PUSH
30983: LD_INT 30
30985: PUSH
30986: LD_INT 5
30988: PUSH
30989: EMPTY
30990: LIST
30991: LIST
30992: PUSH
30993: LD_INT 30
30995: PUSH
30996: LD_INT 32
30998: PUSH
30999: EMPTY
31000: LIST
31001: LIST
31002: PUSH
31003: EMPTY
31004: LIST
31005: LIST
31006: LIST
31007: LIST
31008: PPUSH
31009: CALL_OW 72
31013: ST_TO_ADDR
// if not tmp then
31014: LD_VAR 0 5
31018: NOT
31019: IFFALSE 31023
// continue ;
31021: GO 30516
// list := [ ] ;
31023: LD_ADDR_VAR 0 6
31027: PUSH
31028: EMPTY
31029: ST_TO_ADDR
// for j in tmp do
31030: LD_ADDR_VAR 0 3
31034: PUSH
31035: LD_VAR 0 5
31039: PUSH
31040: FOR_IN
31041: IFFALSE 31110
// begin for k in UnitsInside ( j ) do
31043: LD_ADDR_VAR 0 4
31047: PUSH
31048: LD_VAR 0 3
31052: PPUSH
31053: CALL_OW 313
31057: PUSH
31058: FOR_IN
31059: IFFALSE 31106
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
31061: LD_VAR 0 4
31065: PPUSH
31066: CALL_OW 257
31070: PUSH
31071: LD_INT 1
31073: EQUAL
31074: PUSH
31075: LD_VAR 0 4
31079: PPUSH
31080: CALL_OW 459
31084: NOT
31085: AND
31086: IFFALSE 31104
// list := list ^ k ;
31088: LD_ADDR_VAR 0 6
31092: PUSH
31093: LD_VAR 0 6
31097: PUSH
31098: LD_VAR 0 4
31102: ADD
31103: ST_TO_ADDR
31104: GO 31058
31106: POP
31107: POP
// end ;
31108: GO 31040
31110: POP
31111: POP
// list := list diff mc_miners [ i ] ;
31112: LD_ADDR_VAR 0 6
31116: PUSH
31117: LD_VAR 0 6
31121: PUSH
31122: LD_EXP 64
31126: PUSH
31127: LD_VAR 0 2
31131: ARRAY
31132: DIFF
31133: ST_TO_ADDR
// if not list then
31134: LD_VAR 0 6
31138: NOT
31139: IFFALSE 31143
// continue ;
31141: GO 30516
// k := mc_mines [ i ] - mc_miners [ i ] ;
31143: LD_ADDR_VAR 0 4
31147: PUSH
31148: LD_EXP 63
31152: PUSH
31153: LD_VAR 0 2
31157: ARRAY
31158: PUSH
31159: LD_EXP 64
31163: PUSH
31164: LD_VAR 0 2
31168: ARRAY
31169: MINUS
31170: ST_TO_ADDR
// if k > list then
31171: LD_VAR 0 4
31175: PUSH
31176: LD_VAR 0 6
31180: GREATER
31181: IFFALSE 31193
// k := list ;
31183: LD_ADDR_VAR 0 4
31187: PUSH
31188: LD_VAR 0 6
31192: ST_TO_ADDR
// for j = 1 to k do
31193: LD_ADDR_VAR 0 3
31197: PUSH
31198: DOUBLE
31199: LD_INT 1
31201: DEC
31202: ST_TO_ADDR
31203: LD_VAR 0 4
31207: PUSH
31208: FOR_TO
31209: IFFALSE 31263
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
31211: LD_ADDR_EXP 64
31215: PUSH
31216: LD_EXP 64
31220: PPUSH
31221: LD_VAR 0 2
31225: PUSH
31226: LD_EXP 64
31230: PUSH
31231: LD_VAR 0 2
31235: ARRAY
31236: PUSH
31237: LD_INT 1
31239: PLUS
31240: PUSH
31241: EMPTY
31242: LIST
31243: LIST
31244: PPUSH
31245: LD_VAR 0 6
31249: PUSH
31250: LD_VAR 0 3
31254: ARRAY
31255: PPUSH
31256: CALL 53789 0 3
31260: ST_TO_ADDR
31261: GO 31208
31263: POP
31264: POP
// end ;
31265: GO 30516
31267: POP
31268: POP
// end ;
31269: LD_VAR 0 1
31273: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
31274: LD_INT 0
31276: PPUSH
31277: PPUSH
31278: PPUSH
31279: PPUSH
31280: PPUSH
31281: PPUSH
31282: PPUSH
31283: PPUSH
31284: PPUSH
31285: PPUSH
31286: PPUSH
// if not mc_bases then
31287: LD_EXP 50
31291: NOT
31292: IFFALSE 31296
// exit ;
31294: GO 33119
// for i = 1 to mc_bases do
31296: LD_ADDR_VAR 0 2
31300: PUSH
31301: DOUBLE
31302: LD_INT 1
31304: DEC
31305: ST_TO_ADDR
31306: LD_EXP 50
31310: PUSH
31311: FOR_TO
31312: IFFALSE 33117
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
31314: LD_EXP 50
31318: PUSH
31319: LD_VAR 0 2
31323: ARRAY
31324: NOT
31325: PUSH
31326: LD_EXP 57
31330: PUSH
31331: LD_VAR 0 2
31335: ARRAY
31336: OR
31337: IFFALSE 31341
// continue ;
31339: GO 31311
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
31341: LD_EXP 66
31345: PUSH
31346: LD_VAR 0 2
31350: ARRAY
31351: NOT
31352: PUSH
31353: LD_EXP 67
31357: PUSH
31358: LD_VAR 0 2
31362: ARRAY
31363: AND
31364: IFFALSE 31402
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
31366: LD_ADDR_EXP 67
31370: PUSH
31371: LD_EXP 67
31375: PPUSH
31376: LD_VAR 0 2
31380: PPUSH
31381: EMPTY
31382: PPUSH
31383: CALL_OW 1
31387: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
31388: LD_VAR 0 2
31392: PPUSH
31393: LD_INT 107
31395: PPUSH
31396: CALL 22149 0 2
// continue ;
31400: GO 31311
// end ; target := [ ] ;
31402: LD_ADDR_VAR 0 7
31406: PUSH
31407: EMPTY
31408: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
31409: LD_ADDR_VAR 0 6
31413: PUSH
31414: LD_EXP 50
31418: PUSH
31419: LD_VAR 0 2
31423: ARRAY
31424: PUSH
31425: LD_INT 1
31427: ARRAY
31428: PPUSH
31429: CALL_OW 255
31433: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31434: LD_ADDR_VAR 0 9
31438: PUSH
31439: LD_EXP 50
31443: PUSH
31444: LD_VAR 0 2
31448: ARRAY
31449: PPUSH
31450: LD_INT 2
31452: PUSH
31453: LD_INT 30
31455: PUSH
31456: LD_INT 0
31458: PUSH
31459: EMPTY
31460: LIST
31461: LIST
31462: PUSH
31463: LD_INT 30
31465: PUSH
31466: LD_INT 1
31468: PUSH
31469: EMPTY
31470: LIST
31471: LIST
31472: PUSH
31473: EMPTY
31474: LIST
31475: LIST
31476: LIST
31477: PPUSH
31478: CALL_OW 72
31482: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
31483: LD_ADDR_VAR 0 3
31487: PUSH
31488: DOUBLE
31489: LD_EXP 66
31493: PUSH
31494: LD_VAR 0 2
31498: ARRAY
31499: INC
31500: ST_TO_ADDR
31501: LD_INT 1
31503: PUSH
31504: FOR_DOWNTO
31505: IFFALSE 31750
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
31507: LD_EXP 66
31511: PUSH
31512: LD_VAR 0 2
31516: ARRAY
31517: PUSH
31518: LD_VAR 0 3
31522: ARRAY
31523: PUSH
31524: LD_INT 2
31526: ARRAY
31527: PPUSH
31528: LD_EXP 66
31532: PUSH
31533: LD_VAR 0 2
31537: ARRAY
31538: PUSH
31539: LD_VAR 0 3
31543: ARRAY
31544: PUSH
31545: LD_INT 3
31547: ARRAY
31548: PPUSH
31549: CALL_OW 488
31553: PUSH
31554: LD_EXP 66
31558: PUSH
31559: LD_VAR 0 2
31563: ARRAY
31564: PUSH
31565: LD_VAR 0 3
31569: ARRAY
31570: PUSH
31571: LD_INT 2
31573: ARRAY
31574: PPUSH
31575: LD_EXP 66
31579: PUSH
31580: LD_VAR 0 2
31584: ARRAY
31585: PUSH
31586: LD_VAR 0 3
31590: ARRAY
31591: PUSH
31592: LD_INT 3
31594: ARRAY
31595: PPUSH
31596: CALL_OW 284
31600: PUSH
31601: LD_INT 0
31603: EQUAL
31604: AND
31605: IFFALSE 31660
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
31607: LD_ADDR_VAR 0 5
31611: PUSH
31612: LD_EXP 66
31616: PUSH
31617: LD_VAR 0 2
31621: ARRAY
31622: PPUSH
31623: LD_VAR 0 3
31627: PPUSH
31628: CALL_OW 3
31632: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
31633: LD_ADDR_EXP 66
31637: PUSH
31638: LD_EXP 66
31642: PPUSH
31643: LD_VAR 0 2
31647: PPUSH
31648: LD_VAR 0 5
31652: PPUSH
31653: CALL_OW 1
31657: ST_TO_ADDR
// continue ;
31658: GO 31504
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
31660: LD_VAR 0 6
31664: PPUSH
31665: LD_EXP 66
31669: PUSH
31670: LD_VAR 0 2
31674: ARRAY
31675: PUSH
31676: LD_VAR 0 3
31680: ARRAY
31681: PUSH
31682: LD_INT 2
31684: ARRAY
31685: PPUSH
31686: LD_EXP 66
31690: PUSH
31691: LD_VAR 0 2
31695: ARRAY
31696: PUSH
31697: LD_VAR 0 3
31701: ARRAY
31702: PUSH
31703: LD_INT 3
31705: ARRAY
31706: PPUSH
31707: LD_INT 30
31709: PPUSH
31710: CALL 54685 0 4
31714: PUSH
31715: LD_INT 4
31717: ARRAY
31718: PUSH
31719: LD_INT 0
31721: EQUAL
31722: IFFALSE 31748
// begin target := mc_crates [ i ] [ j ] ;
31724: LD_ADDR_VAR 0 7
31728: PUSH
31729: LD_EXP 66
31733: PUSH
31734: LD_VAR 0 2
31738: ARRAY
31739: PUSH
31740: LD_VAR 0 3
31744: ARRAY
31745: ST_TO_ADDR
// break ;
31746: GO 31750
// end ; end ;
31748: GO 31504
31750: POP
31751: POP
// if not target then
31752: LD_VAR 0 7
31756: NOT
31757: IFFALSE 31761
// continue ;
31759: GO 31311
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
31761: LD_ADDR_VAR 0 8
31765: PUSH
31766: LD_EXP 69
31770: PUSH
31771: LD_VAR 0 2
31775: ARRAY
31776: PPUSH
31777: LD_INT 2
31779: PUSH
31780: LD_INT 3
31782: PUSH
31783: LD_INT 58
31785: PUSH
31786: EMPTY
31787: LIST
31788: PUSH
31789: EMPTY
31790: LIST
31791: LIST
31792: PUSH
31793: LD_INT 61
31795: PUSH
31796: EMPTY
31797: LIST
31798: PUSH
31799: LD_INT 33
31801: PUSH
31802: LD_INT 5
31804: PUSH
31805: EMPTY
31806: LIST
31807: LIST
31808: PUSH
31809: LD_INT 33
31811: PUSH
31812: LD_INT 3
31814: PUSH
31815: EMPTY
31816: LIST
31817: LIST
31818: PUSH
31819: EMPTY
31820: LIST
31821: LIST
31822: LIST
31823: LIST
31824: LIST
31825: PUSH
31826: LD_INT 2
31828: PUSH
31829: LD_INT 34
31831: PUSH
31832: LD_INT 32
31834: PUSH
31835: EMPTY
31836: LIST
31837: LIST
31838: PUSH
31839: LD_INT 34
31841: PUSH
31842: LD_INT 51
31844: PUSH
31845: EMPTY
31846: LIST
31847: LIST
31848: PUSH
31849: LD_INT 34
31851: PUSH
31852: LD_INT 12
31854: PUSH
31855: EMPTY
31856: LIST
31857: LIST
31858: PUSH
31859: EMPTY
31860: LIST
31861: LIST
31862: LIST
31863: LIST
31864: PUSH
31865: EMPTY
31866: LIST
31867: LIST
31868: PPUSH
31869: CALL_OW 72
31873: ST_TO_ADDR
// if not cargo then
31874: LD_VAR 0 8
31878: NOT
31879: IFFALSE 32585
// begin if mc_crates_collector [ i ] < 5 then
31881: LD_EXP 67
31885: PUSH
31886: LD_VAR 0 2
31890: ARRAY
31891: PUSH
31892: LD_INT 5
31894: LESS
31895: IFFALSE 32261
// begin if mc_ape [ i ] then
31897: LD_EXP 79
31901: PUSH
31902: LD_VAR 0 2
31906: ARRAY
31907: IFFALSE 31954
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
31909: LD_ADDR_VAR 0 5
31913: PUSH
31914: LD_EXP 79
31918: PUSH
31919: LD_VAR 0 2
31923: ARRAY
31924: PPUSH
31925: LD_INT 25
31927: PUSH
31928: LD_INT 16
31930: PUSH
31931: EMPTY
31932: LIST
31933: LIST
31934: PUSH
31935: LD_INT 24
31937: PUSH
31938: LD_INT 750
31940: PUSH
31941: EMPTY
31942: LIST
31943: LIST
31944: PUSH
31945: EMPTY
31946: LIST
31947: LIST
31948: PPUSH
31949: CALL_OW 72
31953: ST_TO_ADDR
// if not tmp then
31954: LD_VAR 0 5
31958: NOT
31959: IFFALSE 32006
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
31961: LD_ADDR_VAR 0 5
31965: PUSH
31966: LD_EXP 50
31970: PUSH
31971: LD_VAR 0 2
31975: ARRAY
31976: PPUSH
31977: LD_INT 25
31979: PUSH
31980: LD_INT 2
31982: PUSH
31983: EMPTY
31984: LIST
31985: LIST
31986: PUSH
31987: LD_INT 24
31989: PUSH
31990: LD_INT 750
31992: PUSH
31993: EMPTY
31994: LIST
31995: LIST
31996: PUSH
31997: EMPTY
31998: LIST
31999: LIST
32000: PPUSH
32001: CALL_OW 72
32005: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
32006: LD_EXP 79
32010: PUSH
32011: LD_VAR 0 2
32015: ARRAY
32016: PUSH
32017: LD_EXP 50
32021: PUSH
32022: LD_VAR 0 2
32026: ARRAY
32027: PPUSH
32028: LD_INT 25
32030: PUSH
32031: LD_INT 2
32033: PUSH
32034: EMPTY
32035: LIST
32036: LIST
32037: PUSH
32038: LD_INT 24
32040: PUSH
32041: LD_INT 750
32043: PUSH
32044: EMPTY
32045: LIST
32046: LIST
32047: PUSH
32048: EMPTY
32049: LIST
32050: LIST
32051: PPUSH
32052: CALL_OW 72
32056: AND
32057: PUSH
32058: LD_VAR 0 5
32062: PUSH
32063: LD_INT 5
32065: LESS
32066: AND
32067: IFFALSE 32149
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
32069: LD_ADDR_VAR 0 3
32073: PUSH
32074: LD_EXP 50
32078: PUSH
32079: LD_VAR 0 2
32083: ARRAY
32084: PPUSH
32085: LD_INT 25
32087: PUSH
32088: LD_INT 2
32090: PUSH
32091: EMPTY
32092: LIST
32093: LIST
32094: PUSH
32095: LD_INT 24
32097: PUSH
32098: LD_INT 750
32100: PUSH
32101: EMPTY
32102: LIST
32103: LIST
32104: PUSH
32105: EMPTY
32106: LIST
32107: LIST
32108: PPUSH
32109: CALL_OW 72
32113: PUSH
32114: FOR_IN
32115: IFFALSE 32147
// begin tmp := tmp union j ;
32117: LD_ADDR_VAR 0 5
32121: PUSH
32122: LD_VAR 0 5
32126: PUSH
32127: LD_VAR 0 3
32131: UNION
32132: ST_TO_ADDR
// if tmp >= 5 then
32133: LD_VAR 0 5
32137: PUSH
32138: LD_INT 5
32140: GREATEREQUAL
32141: IFFALSE 32145
// break ;
32143: GO 32147
// end ;
32145: GO 32114
32147: POP
32148: POP
// end ; if not tmp then
32149: LD_VAR 0 5
32153: NOT
32154: IFFALSE 32158
// continue ;
32156: GO 31311
// for j in tmp do
32158: LD_ADDR_VAR 0 3
32162: PUSH
32163: LD_VAR 0 5
32167: PUSH
32168: FOR_IN
32169: IFFALSE 32259
// if not GetTag ( j ) then
32171: LD_VAR 0 3
32175: PPUSH
32176: CALL_OW 110
32180: NOT
32181: IFFALSE 32257
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
32183: LD_ADDR_EXP 67
32187: PUSH
32188: LD_EXP 67
32192: PPUSH
32193: LD_VAR 0 2
32197: PUSH
32198: LD_EXP 67
32202: PUSH
32203: LD_VAR 0 2
32207: ARRAY
32208: PUSH
32209: LD_INT 1
32211: PLUS
32212: PUSH
32213: EMPTY
32214: LIST
32215: LIST
32216: PPUSH
32217: LD_VAR 0 3
32221: PPUSH
32222: CALL 53789 0 3
32226: ST_TO_ADDR
// SetTag ( j , 107 ) ;
32227: LD_VAR 0 3
32231: PPUSH
32232: LD_INT 107
32234: PPUSH
32235: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
32239: LD_EXP 67
32243: PUSH
32244: LD_VAR 0 2
32248: ARRAY
32249: PUSH
32250: LD_INT 5
32252: GREATEREQUAL
32253: IFFALSE 32257
// break ;
32255: GO 32259
// end ;
32257: GO 32168
32259: POP
32260: POP
// end ; if mc_crates_collector [ i ] and target then
32261: LD_EXP 67
32265: PUSH
32266: LD_VAR 0 2
32270: ARRAY
32271: PUSH
32272: LD_VAR 0 7
32276: AND
32277: IFFALSE 32583
// begin if mc_crates_collector [ i ] < target [ 1 ] then
32279: LD_EXP 67
32283: PUSH
32284: LD_VAR 0 2
32288: ARRAY
32289: PUSH
32290: LD_VAR 0 7
32294: PUSH
32295: LD_INT 1
32297: ARRAY
32298: LESS
32299: IFFALSE 32319
// tmp := mc_crates_collector [ i ] else
32301: LD_ADDR_VAR 0 5
32305: PUSH
32306: LD_EXP 67
32310: PUSH
32311: LD_VAR 0 2
32315: ARRAY
32316: ST_TO_ADDR
32317: GO 32333
// tmp := target [ 1 ] ;
32319: LD_ADDR_VAR 0 5
32323: PUSH
32324: LD_VAR 0 7
32328: PUSH
32329: LD_INT 1
32331: ARRAY
32332: ST_TO_ADDR
// k := 0 ;
32333: LD_ADDR_VAR 0 4
32337: PUSH
32338: LD_INT 0
32340: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
32341: LD_ADDR_VAR 0 3
32345: PUSH
32346: LD_EXP 67
32350: PUSH
32351: LD_VAR 0 2
32355: ARRAY
32356: PUSH
32357: FOR_IN
32358: IFFALSE 32581
// begin k := k + 1 ;
32360: LD_ADDR_VAR 0 4
32364: PUSH
32365: LD_VAR 0 4
32369: PUSH
32370: LD_INT 1
32372: PLUS
32373: ST_TO_ADDR
// if k > tmp then
32374: LD_VAR 0 4
32378: PUSH
32379: LD_VAR 0 5
32383: GREATER
32384: IFFALSE 32388
// break ;
32386: GO 32581
// if not GetClass ( j ) in [ 2 , 16 ] then
32388: LD_VAR 0 3
32392: PPUSH
32393: CALL_OW 257
32397: PUSH
32398: LD_INT 2
32400: PUSH
32401: LD_INT 16
32403: PUSH
32404: EMPTY
32405: LIST
32406: LIST
32407: IN
32408: NOT
32409: IFFALSE 32462
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
32411: LD_ADDR_EXP 67
32415: PUSH
32416: LD_EXP 67
32420: PPUSH
32421: LD_VAR 0 2
32425: PPUSH
32426: LD_EXP 67
32430: PUSH
32431: LD_VAR 0 2
32435: ARRAY
32436: PUSH
32437: LD_VAR 0 3
32441: DIFF
32442: PPUSH
32443: CALL_OW 1
32447: ST_TO_ADDR
// SetTag ( j , 0 ) ;
32448: LD_VAR 0 3
32452: PPUSH
32453: LD_INT 0
32455: PPUSH
32456: CALL_OW 109
// continue ;
32460: GO 32357
// end ; if IsInUnit ( j ) then
32462: LD_VAR 0 3
32466: PPUSH
32467: CALL_OW 310
32471: IFFALSE 32482
// ComExitBuilding ( j ) ;
32473: LD_VAR 0 3
32477: PPUSH
32478: CALL_OW 122
// wait ( 3 ) ;
32482: LD_INT 3
32484: PPUSH
32485: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
32489: LD_VAR 0 3
32493: PPUSH
32494: CALL_OW 314
32498: PUSH
32499: LD_VAR 0 6
32503: PPUSH
32504: LD_VAR 0 7
32508: PUSH
32509: LD_INT 2
32511: ARRAY
32512: PPUSH
32513: LD_VAR 0 7
32517: PUSH
32518: LD_INT 3
32520: ARRAY
32521: PPUSH
32522: LD_INT 30
32524: PPUSH
32525: CALL 54685 0 4
32529: PUSH
32530: LD_INT 4
32532: ARRAY
32533: AND
32534: IFFALSE 32552
// ComStandNearbyBuilding ( j , depot ) else
32536: LD_VAR 0 3
32540: PPUSH
32541: LD_VAR 0 9
32545: PPUSH
32546: CALL 50216 0 2
32550: GO 32579
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
32552: LD_VAR 0 3
32556: PPUSH
32557: LD_VAR 0 7
32561: PUSH
32562: LD_INT 2
32564: ARRAY
32565: PPUSH
32566: LD_VAR 0 7
32570: PUSH
32571: LD_INT 3
32573: ARRAY
32574: PPUSH
32575: CALL_OW 117
// end ;
32579: GO 32357
32581: POP
32582: POP
// end ; end else
32583: GO 33115
// begin for j in cargo do
32585: LD_ADDR_VAR 0 3
32589: PUSH
32590: LD_VAR 0 8
32594: PUSH
32595: FOR_IN
32596: IFFALSE 33113
// begin if GetTag ( j ) <> 0 then
32598: LD_VAR 0 3
32602: PPUSH
32603: CALL_OW 110
32607: PUSH
32608: LD_INT 0
32610: NONEQUAL
32611: IFFALSE 32615
// continue ;
32613: GO 32595
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
32615: LD_VAR 0 3
32619: PPUSH
32620: CALL_OW 256
32624: PUSH
32625: LD_INT 1000
32627: LESS
32628: PUSH
32629: LD_VAR 0 3
32633: PPUSH
32634: LD_EXP 74
32638: PUSH
32639: LD_VAR 0 2
32643: ARRAY
32644: PPUSH
32645: CALL_OW 308
32649: NOT
32650: AND
32651: IFFALSE 32673
// ComMoveToArea ( j , mc_parking [ i ] ) ;
32653: LD_VAR 0 3
32657: PPUSH
32658: LD_EXP 74
32662: PUSH
32663: LD_VAR 0 2
32667: ARRAY
32668: PPUSH
32669: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
32673: LD_VAR 0 3
32677: PPUSH
32678: CALL_OW 256
32682: PUSH
32683: LD_INT 1000
32685: LESS
32686: PUSH
32687: LD_VAR 0 3
32691: PPUSH
32692: LD_EXP 74
32696: PUSH
32697: LD_VAR 0 2
32701: ARRAY
32702: PPUSH
32703: CALL_OW 308
32707: AND
32708: IFFALSE 32712
// continue ;
32710: GO 32595
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
32712: LD_VAR 0 3
32716: PPUSH
32717: CALL_OW 262
32721: PUSH
32722: LD_INT 2
32724: EQUAL
32725: PUSH
32726: LD_VAR 0 3
32730: PPUSH
32731: CALL_OW 261
32735: PUSH
32736: LD_INT 15
32738: LESS
32739: AND
32740: IFFALSE 32744
// continue ;
32742: GO 32595
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
32744: LD_VAR 0 3
32748: PPUSH
32749: CALL_OW 262
32753: PUSH
32754: LD_INT 1
32756: EQUAL
32757: PUSH
32758: LD_VAR 0 3
32762: PPUSH
32763: CALL_OW 261
32767: PUSH
32768: LD_INT 10
32770: LESS
32771: AND
32772: IFFALSE 33052
// begin if not depot then
32774: LD_VAR 0 9
32778: NOT
32779: IFFALSE 32783
// continue ;
32781: GO 32595
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
32783: LD_VAR 0 3
32787: PPUSH
32788: LD_VAR 0 9
32792: PPUSH
32793: LD_VAR 0 3
32797: PPUSH
32798: CALL_OW 74
32802: PPUSH
32803: CALL_OW 296
32807: PUSH
32808: LD_INT 6
32810: LESS
32811: IFFALSE 32827
// SetFuel ( j , 100 ) else
32813: LD_VAR 0 3
32817: PPUSH
32818: LD_INT 100
32820: PPUSH
32821: CALL_OW 240
32825: GO 33052
// if GetFuel ( j ) = 0 then
32827: LD_VAR 0 3
32831: PPUSH
32832: CALL_OW 261
32836: PUSH
32837: LD_INT 0
32839: EQUAL
32840: IFFALSE 33052
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
32842: LD_ADDR_EXP 69
32846: PUSH
32847: LD_EXP 69
32851: PPUSH
32852: LD_VAR 0 2
32856: PPUSH
32857: LD_EXP 69
32861: PUSH
32862: LD_VAR 0 2
32866: ARRAY
32867: PUSH
32868: LD_VAR 0 3
32872: DIFF
32873: PPUSH
32874: CALL_OW 1
32878: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
32879: LD_VAR 0 3
32883: PPUSH
32884: CALL_OW 263
32888: PUSH
32889: LD_INT 1
32891: EQUAL
32892: IFFALSE 32908
// ComExitVehicle ( IsInUnit ( j ) ) ;
32894: LD_VAR 0 3
32898: PPUSH
32899: CALL_OW 310
32903: PPUSH
32904: CALL_OW 121
// if GetControl ( j ) = control_remote then
32908: LD_VAR 0 3
32912: PPUSH
32913: CALL_OW 263
32917: PUSH
32918: LD_INT 2
32920: EQUAL
32921: IFFALSE 32932
// ComUnlink ( j ) ;
32923: LD_VAR 0 3
32927: PPUSH
32928: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
32932: LD_ADDR_VAR 0 10
32936: PUSH
32937: LD_VAR 0 2
32941: PPUSH
32942: LD_INT 3
32944: PPUSH
32945: CALL 42719 0 2
32949: ST_TO_ADDR
// if fac then
32950: LD_VAR 0 10
32954: IFFALSE 33050
// begin for k in fac do
32956: LD_ADDR_VAR 0 4
32960: PUSH
32961: LD_VAR 0 10
32965: PUSH
32966: FOR_IN
32967: IFFALSE 33048
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
32969: LD_ADDR_VAR 0 11
32973: PUSH
32974: LD_VAR 0 10
32978: PPUSH
32979: LD_VAR 0 3
32983: PPUSH
32984: CALL_OW 265
32988: PPUSH
32989: LD_VAR 0 3
32993: PPUSH
32994: CALL_OW 262
32998: PPUSH
32999: LD_VAR 0 3
33003: PPUSH
33004: CALL_OW 263
33008: PPUSH
33009: LD_VAR 0 3
33013: PPUSH
33014: CALL_OW 264
33018: PPUSH
33019: CALL 51287 0 5
33023: ST_TO_ADDR
// if components then
33024: LD_VAR 0 11
33028: IFFALSE 33046
// begin MC_InsertProduceList ( i , components ) ;
33030: LD_VAR 0 2
33034: PPUSH
33035: LD_VAR 0 11
33039: PPUSH
33040: CALL 42264 0 2
// break ;
33044: GO 33048
// end ; end ;
33046: GO 32966
33048: POP
33049: POP
// end ; continue ;
33050: GO 32595
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
33052: LD_VAR 0 3
33056: PPUSH
33057: LD_INT 1
33059: PPUSH
33060: CALL_OW 289
33064: PUSH
33065: LD_INT 100
33067: LESS
33068: PUSH
33069: LD_VAR 0 3
33073: PPUSH
33074: CALL_OW 314
33078: NOT
33079: AND
33080: IFFALSE 33109
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
33082: LD_VAR 0 3
33086: PPUSH
33087: LD_VAR 0 7
33091: PUSH
33092: LD_INT 2
33094: ARRAY
33095: PPUSH
33096: LD_VAR 0 7
33100: PUSH
33101: LD_INT 3
33103: ARRAY
33104: PPUSH
33105: CALL_OW 117
// break ;
33109: GO 33113
// end ;
33111: GO 32595
33113: POP
33114: POP
// end ; end ;
33115: GO 31311
33117: POP
33118: POP
// end ;
33119: LD_VAR 0 1
33123: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
33124: LD_INT 0
33126: PPUSH
33127: PPUSH
33128: PPUSH
33129: PPUSH
// if not mc_bases then
33130: LD_EXP 50
33134: NOT
33135: IFFALSE 33139
// exit ;
33137: GO 33300
// for i = 1 to mc_bases do
33139: LD_ADDR_VAR 0 2
33143: PUSH
33144: DOUBLE
33145: LD_INT 1
33147: DEC
33148: ST_TO_ADDR
33149: LD_EXP 50
33153: PUSH
33154: FOR_TO
33155: IFFALSE 33298
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
33157: LD_ADDR_VAR 0 4
33161: PUSH
33162: LD_EXP 69
33166: PUSH
33167: LD_VAR 0 2
33171: ARRAY
33172: PUSH
33173: LD_EXP 72
33177: PUSH
33178: LD_VAR 0 2
33182: ARRAY
33183: UNION
33184: PPUSH
33185: LD_INT 33
33187: PUSH
33188: LD_INT 2
33190: PUSH
33191: EMPTY
33192: LIST
33193: LIST
33194: PPUSH
33195: CALL_OW 72
33199: ST_TO_ADDR
// if tmp then
33200: LD_VAR 0 4
33204: IFFALSE 33296
// for j in tmp do
33206: LD_ADDR_VAR 0 3
33210: PUSH
33211: LD_VAR 0 4
33215: PUSH
33216: FOR_IN
33217: IFFALSE 33294
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
33219: LD_VAR 0 3
33223: PPUSH
33224: CALL_OW 312
33228: NOT
33229: PUSH
33230: LD_VAR 0 3
33234: PPUSH
33235: CALL_OW 256
33239: PUSH
33240: LD_INT 250
33242: GREATEREQUAL
33243: AND
33244: IFFALSE 33257
// Connect ( j ) else
33246: LD_VAR 0 3
33250: PPUSH
33251: CALL 56758 0 1
33255: GO 33292
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
33257: LD_VAR 0 3
33261: PPUSH
33262: CALL_OW 256
33266: PUSH
33267: LD_INT 250
33269: LESS
33270: PUSH
33271: LD_VAR 0 3
33275: PPUSH
33276: CALL_OW 312
33280: AND
33281: IFFALSE 33292
// ComUnlink ( j ) ;
33283: LD_VAR 0 3
33287: PPUSH
33288: CALL_OW 136
33292: GO 33216
33294: POP
33295: POP
// end ;
33296: GO 33154
33298: POP
33299: POP
// end ;
33300: LD_VAR 0 1
33304: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
33305: LD_INT 0
33307: PPUSH
33308: PPUSH
33309: PPUSH
33310: PPUSH
33311: PPUSH
// if not mc_bases then
33312: LD_EXP 50
33316: NOT
33317: IFFALSE 33321
// exit ;
33319: GO 33766
// for i = 1 to mc_bases do
33321: LD_ADDR_VAR 0 2
33325: PUSH
33326: DOUBLE
33327: LD_INT 1
33329: DEC
33330: ST_TO_ADDR
33331: LD_EXP 50
33335: PUSH
33336: FOR_TO
33337: IFFALSE 33764
// begin if not mc_produce [ i ] then
33339: LD_EXP 71
33343: PUSH
33344: LD_VAR 0 2
33348: ARRAY
33349: NOT
33350: IFFALSE 33354
// continue ;
33352: GO 33336
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
33354: LD_ADDR_VAR 0 5
33358: PUSH
33359: LD_EXP 50
33363: PUSH
33364: LD_VAR 0 2
33368: ARRAY
33369: PPUSH
33370: LD_INT 30
33372: PUSH
33373: LD_INT 3
33375: PUSH
33376: EMPTY
33377: LIST
33378: LIST
33379: PPUSH
33380: CALL_OW 72
33384: ST_TO_ADDR
// if not fac then
33385: LD_VAR 0 5
33389: NOT
33390: IFFALSE 33394
// continue ;
33392: GO 33336
// for j in fac do
33394: LD_ADDR_VAR 0 3
33398: PUSH
33399: LD_VAR 0 5
33403: PUSH
33404: FOR_IN
33405: IFFALSE 33760
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
33407: LD_VAR 0 3
33411: PPUSH
33412: CALL_OW 461
33416: PUSH
33417: LD_INT 2
33419: NONEQUAL
33420: PUSH
33421: LD_VAR 0 3
33425: PPUSH
33426: LD_INT 15
33428: PPUSH
33429: CALL 56386 0 2
33433: PUSH
33434: LD_INT 4
33436: ARRAY
33437: OR
33438: IFFALSE 33442
// continue ;
33440: GO 33404
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
33442: LD_VAR 0 3
33446: PPUSH
33447: LD_EXP 71
33451: PUSH
33452: LD_VAR 0 2
33456: ARRAY
33457: PUSH
33458: LD_INT 1
33460: ARRAY
33461: PUSH
33462: LD_INT 1
33464: ARRAY
33465: PPUSH
33466: LD_EXP 71
33470: PUSH
33471: LD_VAR 0 2
33475: ARRAY
33476: PUSH
33477: LD_INT 1
33479: ARRAY
33480: PUSH
33481: LD_INT 2
33483: ARRAY
33484: PPUSH
33485: LD_EXP 71
33489: PUSH
33490: LD_VAR 0 2
33494: ARRAY
33495: PUSH
33496: LD_INT 1
33498: ARRAY
33499: PUSH
33500: LD_INT 3
33502: ARRAY
33503: PPUSH
33504: LD_EXP 71
33508: PUSH
33509: LD_VAR 0 2
33513: ARRAY
33514: PUSH
33515: LD_INT 1
33517: ARRAY
33518: PUSH
33519: LD_INT 4
33521: ARRAY
33522: PPUSH
33523: CALL_OW 448
33527: PUSH
33528: LD_VAR 0 3
33532: PPUSH
33533: LD_EXP 71
33537: PUSH
33538: LD_VAR 0 2
33542: ARRAY
33543: PUSH
33544: LD_INT 1
33546: ARRAY
33547: PUSH
33548: LD_INT 1
33550: ARRAY
33551: PUSH
33552: LD_EXP 71
33556: PUSH
33557: LD_VAR 0 2
33561: ARRAY
33562: PUSH
33563: LD_INT 1
33565: ARRAY
33566: PUSH
33567: LD_INT 2
33569: ARRAY
33570: PUSH
33571: LD_EXP 71
33575: PUSH
33576: LD_VAR 0 2
33580: ARRAY
33581: PUSH
33582: LD_INT 1
33584: ARRAY
33585: PUSH
33586: LD_INT 3
33588: ARRAY
33589: PUSH
33590: LD_EXP 71
33594: PUSH
33595: LD_VAR 0 2
33599: ARRAY
33600: PUSH
33601: LD_INT 1
33603: ARRAY
33604: PUSH
33605: LD_INT 4
33607: ARRAY
33608: PUSH
33609: EMPTY
33610: LIST
33611: LIST
33612: LIST
33613: LIST
33614: PPUSH
33615: CALL 60153 0 2
33619: AND
33620: IFFALSE 33758
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
33622: LD_VAR 0 3
33626: PPUSH
33627: LD_EXP 71
33631: PUSH
33632: LD_VAR 0 2
33636: ARRAY
33637: PUSH
33638: LD_INT 1
33640: ARRAY
33641: PUSH
33642: LD_INT 1
33644: ARRAY
33645: PPUSH
33646: LD_EXP 71
33650: PUSH
33651: LD_VAR 0 2
33655: ARRAY
33656: PUSH
33657: LD_INT 1
33659: ARRAY
33660: PUSH
33661: LD_INT 2
33663: ARRAY
33664: PPUSH
33665: LD_EXP 71
33669: PUSH
33670: LD_VAR 0 2
33674: ARRAY
33675: PUSH
33676: LD_INT 1
33678: ARRAY
33679: PUSH
33680: LD_INT 3
33682: ARRAY
33683: PPUSH
33684: LD_EXP 71
33688: PUSH
33689: LD_VAR 0 2
33693: ARRAY
33694: PUSH
33695: LD_INT 1
33697: ARRAY
33698: PUSH
33699: LD_INT 4
33701: ARRAY
33702: PPUSH
33703: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
33707: LD_ADDR_VAR 0 4
33711: PUSH
33712: LD_EXP 71
33716: PUSH
33717: LD_VAR 0 2
33721: ARRAY
33722: PPUSH
33723: LD_INT 1
33725: PPUSH
33726: CALL_OW 3
33730: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
33731: LD_ADDR_EXP 71
33735: PUSH
33736: LD_EXP 71
33740: PPUSH
33741: LD_VAR 0 2
33745: PPUSH
33746: LD_VAR 0 4
33750: PPUSH
33751: CALL_OW 1
33755: ST_TO_ADDR
// break ;
33756: GO 33760
// end ; end ;
33758: GO 33404
33760: POP
33761: POP
// end ;
33762: GO 33336
33764: POP
33765: POP
// end ;
33766: LD_VAR 0 1
33770: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
33771: LD_INT 0
33773: PPUSH
33774: PPUSH
33775: PPUSH
// if not mc_bases then
33776: LD_EXP 50
33780: NOT
33781: IFFALSE 33785
// exit ;
33783: GO 33874
// for i = 1 to mc_bases do
33785: LD_ADDR_VAR 0 2
33789: PUSH
33790: DOUBLE
33791: LD_INT 1
33793: DEC
33794: ST_TO_ADDR
33795: LD_EXP 50
33799: PUSH
33800: FOR_TO
33801: IFFALSE 33872
// begin if mc_attack [ i ] then
33803: LD_EXP 70
33807: PUSH
33808: LD_VAR 0 2
33812: ARRAY
33813: IFFALSE 33870
// begin tmp := mc_attack [ i ] [ 1 ] ;
33815: LD_ADDR_VAR 0 3
33819: PUSH
33820: LD_EXP 70
33824: PUSH
33825: LD_VAR 0 2
33829: ARRAY
33830: PUSH
33831: LD_INT 1
33833: ARRAY
33834: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
33835: LD_ADDR_EXP 70
33839: PUSH
33840: LD_EXP 70
33844: PPUSH
33845: LD_VAR 0 2
33849: PPUSH
33850: EMPTY
33851: PPUSH
33852: CALL_OW 1
33856: ST_TO_ADDR
// Attack ( tmp ) ;
33857: LD_VAR 0 3
33861: PPUSH
33862: CALL 109992 0 1
// exit ;
33866: POP
33867: POP
33868: GO 33874
// end ; end ;
33870: GO 33800
33872: POP
33873: POP
// end ;
33874: LD_VAR 0 1
33878: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
33879: LD_INT 0
33881: PPUSH
33882: PPUSH
33883: PPUSH
33884: PPUSH
33885: PPUSH
33886: PPUSH
33887: PPUSH
// if not mc_bases then
33888: LD_EXP 50
33892: NOT
33893: IFFALSE 33897
// exit ;
33895: GO 34754
// for i = 1 to mc_bases do
33897: LD_ADDR_VAR 0 2
33901: PUSH
33902: DOUBLE
33903: LD_INT 1
33905: DEC
33906: ST_TO_ADDR
33907: LD_EXP 50
33911: PUSH
33912: FOR_TO
33913: IFFALSE 34752
// begin if not mc_bases [ i ] then
33915: LD_EXP 50
33919: PUSH
33920: LD_VAR 0 2
33924: ARRAY
33925: NOT
33926: IFFALSE 33930
// continue ;
33928: GO 33912
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
33930: LD_ADDR_VAR 0 7
33934: PUSH
33935: LD_EXP 50
33939: PUSH
33940: LD_VAR 0 2
33944: ARRAY
33945: PUSH
33946: LD_INT 1
33948: ARRAY
33949: PPUSH
33950: CALL 50438 0 1
33954: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
33955: LD_ADDR_EXP 73
33959: PUSH
33960: LD_EXP 73
33964: PPUSH
33965: LD_VAR 0 2
33969: PPUSH
33970: LD_EXP 50
33974: PUSH
33975: LD_VAR 0 2
33979: ARRAY
33980: PUSH
33981: LD_INT 1
33983: ARRAY
33984: PPUSH
33985: CALL_OW 255
33989: PPUSH
33990: LD_EXP 75
33994: PUSH
33995: LD_VAR 0 2
33999: ARRAY
34000: PPUSH
34001: CALL 50403 0 2
34005: PPUSH
34006: CALL_OW 1
34010: ST_TO_ADDR
// if not mc_scan [ i ] then
34011: LD_EXP 73
34015: PUSH
34016: LD_VAR 0 2
34020: ARRAY
34021: NOT
34022: IFFALSE 34200
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
34024: LD_ADDR_EXP 93
34028: PUSH
34029: LD_EXP 93
34033: PPUSH
34034: LD_VAR 0 2
34038: PPUSH
34039: LD_INT 0
34041: PPUSH
34042: CALL_OW 1
34046: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
34047: LD_ADDR_VAR 0 4
34051: PUSH
34052: LD_EXP 50
34056: PUSH
34057: LD_VAR 0 2
34061: ARRAY
34062: PPUSH
34063: LD_INT 2
34065: PUSH
34066: LD_INT 25
34068: PUSH
34069: LD_INT 5
34071: PUSH
34072: EMPTY
34073: LIST
34074: LIST
34075: PUSH
34076: LD_INT 25
34078: PUSH
34079: LD_INT 8
34081: PUSH
34082: EMPTY
34083: LIST
34084: LIST
34085: PUSH
34086: LD_INT 25
34088: PUSH
34089: LD_INT 9
34091: PUSH
34092: EMPTY
34093: LIST
34094: LIST
34095: PUSH
34096: EMPTY
34097: LIST
34098: LIST
34099: LIST
34100: LIST
34101: PPUSH
34102: CALL_OW 72
34106: ST_TO_ADDR
// if not tmp then
34107: LD_VAR 0 4
34111: NOT
34112: IFFALSE 34116
// continue ;
34114: GO 33912
// for j in tmp do
34116: LD_ADDR_VAR 0 3
34120: PUSH
34121: LD_VAR 0 4
34125: PUSH
34126: FOR_IN
34127: IFFALSE 34198
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
34129: LD_VAR 0 3
34133: PPUSH
34134: CALL_OW 310
34138: PPUSH
34139: CALL_OW 266
34143: PUSH
34144: LD_INT 5
34146: EQUAL
34147: PUSH
34148: LD_VAR 0 3
34152: PPUSH
34153: CALL_OW 257
34157: PUSH
34158: LD_INT 1
34160: EQUAL
34161: AND
34162: PUSH
34163: LD_VAR 0 3
34167: PPUSH
34168: CALL_OW 459
34172: NOT
34173: AND
34174: PUSH
34175: LD_VAR 0 7
34179: AND
34180: IFFALSE 34196
// ComChangeProfession ( j , class ) ;
34182: LD_VAR 0 3
34186: PPUSH
34187: LD_VAR 0 7
34191: PPUSH
34192: CALL_OW 123
34196: GO 34126
34198: POP
34199: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
34200: LD_EXP 73
34204: PUSH
34205: LD_VAR 0 2
34209: ARRAY
34210: PUSH
34211: LD_EXP 93
34215: PUSH
34216: LD_VAR 0 2
34220: ARRAY
34221: NOT
34222: AND
34223: PUSH
34224: LD_EXP 72
34228: PUSH
34229: LD_VAR 0 2
34233: ARRAY
34234: NOT
34235: AND
34236: PUSH
34237: LD_EXP 50
34241: PUSH
34242: LD_VAR 0 2
34246: ARRAY
34247: PPUSH
34248: LD_INT 50
34250: PUSH
34251: EMPTY
34252: LIST
34253: PUSH
34254: LD_INT 2
34256: PUSH
34257: LD_INT 30
34259: PUSH
34260: LD_INT 32
34262: PUSH
34263: EMPTY
34264: LIST
34265: LIST
34266: PUSH
34267: LD_INT 30
34269: PUSH
34270: LD_INT 33
34272: PUSH
34273: EMPTY
34274: LIST
34275: LIST
34276: PUSH
34277: LD_INT 30
34279: PUSH
34280: LD_INT 4
34282: PUSH
34283: EMPTY
34284: LIST
34285: LIST
34286: PUSH
34287: LD_INT 30
34289: PUSH
34290: LD_INT 5
34292: PUSH
34293: EMPTY
34294: LIST
34295: LIST
34296: PUSH
34297: EMPTY
34298: LIST
34299: LIST
34300: LIST
34301: LIST
34302: LIST
34303: PUSH
34304: EMPTY
34305: LIST
34306: LIST
34307: PPUSH
34308: CALL_OW 72
34312: PUSH
34313: LD_INT 4
34315: LESS
34316: PUSH
34317: LD_EXP 50
34321: PUSH
34322: LD_VAR 0 2
34326: ARRAY
34327: PPUSH
34328: LD_INT 3
34330: PUSH
34331: LD_INT 24
34333: PUSH
34334: LD_INT 1000
34336: PUSH
34337: EMPTY
34338: LIST
34339: LIST
34340: PUSH
34341: EMPTY
34342: LIST
34343: LIST
34344: PUSH
34345: LD_INT 2
34347: PUSH
34348: LD_INT 30
34350: PUSH
34351: LD_INT 0
34353: PUSH
34354: EMPTY
34355: LIST
34356: LIST
34357: PUSH
34358: LD_INT 30
34360: PUSH
34361: LD_INT 1
34363: PUSH
34364: EMPTY
34365: LIST
34366: LIST
34367: PUSH
34368: EMPTY
34369: LIST
34370: LIST
34371: LIST
34372: PUSH
34373: EMPTY
34374: LIST
34375: LIST
34376: PPUSH
34377: CALL_OW 72
34381: OR
34382: AND
34383: IFFALSE 34634
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
34385: LD_ADDR_EXP 93
34389: PUSH
34390: LD_EXP 93
34394: PPUSH
34395: LD_VAR 0 2
34399: PPUSH
34400: LD_INT 1
34402: PPUSH
34403: CALL_OW 1
34407: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
34408: LD_ADDR_VAR 0 4
34412: PUSH
34413: LD_EXP 50
34417: PUSH
34418: LD_VAR 0 2
34422: ARRAY
34423: PPUSH
34424: LD_INT 2
34426: PUSH
34427: LD_INT 25
34429: PUSH
34430: LD_INT 1
34432: PUSH
34433: EMPTY
34434: LIST
34435: LIST
34436: PUSH
34437: LD_INT 25
34439: PUSH
34440: LD_INT 5
34442: PUSH
34443: EMPTY
34444: LIST
34445: LIST
34446: PUSH
34447: LD_INT 25
34449: PUSH
34450: LD_INT 8
34452: PUSH
34453: EMPTY
34454: LIST
34455: LIST
34456: PUSH
34457: LD_INT 25
34459: PUSH
34460: LD_INT 9
34462: PUSH
34463: EMPTY
34464: LIST
34465: LIST
34466: PUSH
34467: EMPTY
34468: LIST
34469: LIST
34470: LIST
34471: LIST
34472: LIST
34473: PPUSH
34474: CALL_OW 72
34478: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
34479: LD_ADDR_VAR 0 4
34483: PUSH
34484: LD_VAR 0 4
34488: PUSH
34489: LD_VAR 0 4
34493: PPUSH
34494: LD_INT 18
34496: PPUSH
34497: CALL 83675 0 2
34501: DIFF
34502: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
34503: LD_VAR 0 4
34507: NOT
34508: PUSH
34509: LD_EXP 50
34513: PUSH
34514: LD_VAR 0 2
34518: ARRAY
34519: PPUSH
34520: LD_INT 2
34522: PUSH
34523: LD_INT 30
34525: PUSH
34526: LD_INT 4
34528: PUSH
34529: EMPTY
34530: LIST
34531: LIST
34532: PUSH
34533: LD_INT 30
34535: PUSH
34536: LD_INT 5
34538: PUSH
34539: EMPTY
34540: LIST
34541: LIST
34542: PUSH
34543: EMPTY
34544: LIST
34545: LIST
34546: LIST
34547: PPUSH
34548: CALL_OW 72
34552: NOT
34553: AND
34554: IFFALSE 34616
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
34556: LD_ADDR_VAR 0 4
34560: PUSH
34561: LD_EXP 50
34565: PUSH
34566: LD_VAR 0 2
34570: ARRAY
34571: PPUSH
34572: LD_INT 2
34574: PUSH
34575: LD_INT 25
34577: PUSH
34578: LD_INT 2
34580: PUSH
34581: EMPTY
34582: LIST
34583: LIST
34584: PUSH
34585: LD_INT 25
34587: PUSH
34588: LD_INT 3
34590: PUSH
34591: EMPTY
34592: LIST
34593: LIST
34594: PUSH
34595: LD_INT 25
34597: PUSH
34598: LD_INT 4
34600: PUSH
34601: EMPTY
34602: LIST
34603: LIST
34604: PUSH
34605: EMPTY
34606: LIST
34607: LIST
34608: LIST
34609: LIST
34610: PPUSH
34611: CALL_OW 72
34615: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
34616: LD_VAR 0 2
34620: PPUSH
34621: LD_VAR 0 4
34625: PPUSH
34626: CALL 114701 0 2
// exit ;
34630: POP
34631: POP
34632: GO 34754
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
34634: LD_EXP 73
34638: PUSH
34639: LD_VAR 0 2
34643: ARRAY
34644: PUSH
34645: LD_EXP 93
34649: PUSH
34650: LD_VAR 0 2
34654: ARRAY
34655: NOT
34656: AND
34657: PUSH
34658: LD_EXP 72
34662: PUSH
34663: LD_VAR 0 2
34667: ARRAY
34668: AND
34669: IFFALSE 34750
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
34671: LD_ADDR_EXP 93
34675: PUSH
34676: LD_EXP 93
34680: PPUSH
34681: LD_VAR 0 2
34685: PPUSH
34686: LD_INT 1
34688: PPUSH
34689: CALL_OW 1
34693: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
34694: LD_ADDR_VAR 0 4
34698: PUSH
34699: LD_EXP 72
34703: PUSH
34704: LD_VAR 0 2
34708: ARRAY
34709: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
34710: LD_ADDR_EXP 72
34714: PUSH
34715: LD_EXP 72
34719: PPUSH
34720: LD_VAR 0 2
34724: PPUSH
34725: EMPTY
34726: PPUSH
34727: CALL_OW 1
34731: ST_TO_ADDR
// Defend ( i , tmp ) ;
34732: LD_VAR 0 2
34736: PPUSH
34737: LD_VAR 0 4
34741: PPUSH
34742: CALL 115297 0 2
// exit ;
34746: POP
34747: POP
34748: GO 34754
// end ; end ;
34750: GO 33912
34752: POP
34753: POP
// end ;
34754: LD_VAR 0 1
34758: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
34759: LD_INT 0
34761: PPUSH
34762: PPUSH
34763: PPUSH
34764: PPUSH
34765: PPUSH
34766: PPUSH
34767: PPUSH
34768: PPUSH
34769: PPUSH
34770: PPUSH
34771: PPUSH
// if not mc_bases then
34772: LD_EXP 50
34776: NOT
34777: IFFALSE 34781
// exit ;
34779: GO 35868
// for i = 1 to mc_bases do
34781: LD_ADDR_VAR 0 2
34785: PUSH
34786: DOUBLE
34787: LD_INT 1
34789: DEC
34790: ST_TO_ADDR
34791: LD_EXP 50
34795: PUSH
34796: FOR_TO
34797: IFFALSE 35866
// begin tmp := mc_lab [ i ] ;
34799: LD_ADDR_VAR 0 6
34803: PUSH
34804: LD_EXP 83
34808: PUSH
34809: LD_VAR 0 2
34813: ARRAY
34814: ST_TO_ADDR
// if not tmp then
34815: LD_VAR 0 6
34819: NOT
34820: IFFALSE 34824
// continue ;
34822: GO 34796
// idle_lab := 0 ;
34824: LD_ADDR_VAR 0 11
34828: PUSH
34829: LD_INT 0
34831: ST_TO_ADDR
// for j in tmp do
34832: LD_ADDR_VAR 0 3
34836: PUSH
34837: LD_VAR 0 6
34841: PUSH
34842: FOR_IN
34843: IFFALSE 35862
// begin researching := false ;
34845: LD_ADDR_VAR 0 10
34849: PUSH
34850: LD_INT 0
34852: ST_TO_ADDR
// side := GetSide ( j ) ;
34853: LD_ADDR_VAR 0 4
34857: PUSH
34858: LD_VAR 0 3
34862: PPUSH
34863: CALL_OW 255
34867: ST_TO_ADDR
// if not mc_tech [ side ] then
34868: LD_EXP 77
34872: PUSH
34873: LD_VAR 0 4
34877: ARRAY
34878: NOT
34879: IFFALSE 34883
// continue ;
34881: GO 34842
// if BuildingStatus ( j ) = bs_idle then
34883: LD_VAR 0 3
34887: PPUSH
34888: CALL_OW 461
34892: PUSH
34893: LD_INT 2
34895: EQUAL
34896: IFFALSE 35084
// begin if idle_lab and UnitsInside ( j ) < 6 then
34898: LD_VAR 0 11
34902: PUSH
34903: LD_VAR 0 3
34907: PPUSH
34908: CALL_OW 313
34912: PUSH
34913: LD_INT 6
34915: LESS
34916: AND
34917: IFFALSE 34988
// begin tmp2 := UnitsInside ( idle_lab ) ;
34919: LD_ADDR_VAR 0 9
34923: PUSH
34924: LD_VAR 0 11
34928: PPUSH
34929: CALL_OW 313
34933: ST_TO_ADDR
// if tmp2 then
34934: LD_VAR 0 9
34938: IFFALSE 34980
// for x in tmp2 do
34940: LD_ADDR_VAR 0 7
34944: PUSH
34945: LD_VAR 0 9
34949: PUSH
34950: FOR_IN
34951: IFFALSE 34978
// begin ComExitBuilding ( x ) ;
34953: LD_VAR 0 7
34957: PPUSH
34958: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
34962: LD_VAR 0 7
34966: PPUSH
34967: LD_VAR 0 3
34971: PPUSH
34972: CALL_OW 180
// end ;
34976: GO 34950
34978: POP
34979: POP
// idle_lab := 0 ;
34980: LD_ADDR_VAR 0 11
34984: PUSH
34985: LD_INT 0
34987: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
34988: LD_ADDR_VAR 0 5
34992: PUSH
34993: LD_EXP 77
34997: PUSH
34998: LD_VAR 0 4
35002: ARRAY
35003: PUSH
35004: FOR_IN
35005: IFFALSE 35065
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
35007: LD_VAR 0 3
35011: PPUSH
35012: LD_VAR 0 5
35016: PPUSH
35017: CALL_OW 430
35021: PUSH
35022: LD_VAR 0 4
35026: PPUSH
35027: LD_VAR 0 5
35031: PPUSH
35032: CALL 49508 0 2
35036: AND
35037: IFFALSE 35063
// begin researching := true ;
35039: LD_ADDR_VAR 0 10
35043: PUSH
35044: LD_INT 1
35046: ST_TO_ADDR
// ComResearch ( j , t ) ;
35047: LD_VAR 0 3
35051: PPUSH
35052: LD_VAR 0 5
35056: PPUSH
35057: CALL_OW 124
// break ;
35061: GO 35065
// end ;
35063: GO 35004
35065: POP
35066: POP
// if not researching then
35067: LD_VAR 0 10
35071: NOT
35072: IFFALSE 35084
// idle_lab := j ;
35074: LD_ADDR_VAR 0 11
35078: PUSH
35079: LD_VAR 0 3
35083: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
35084: LD_VAR 0 3
35088: PPUSH
35089: CALL_OW 461
35093: PUSH
35094: LD_INT 10
35096: EQUAL
35097: IFFALSE 35685
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
35099: LD_EXP 79
35103: PUSH
35104: LD_VAR 0 2
35108: ARRAY
35109: NOT
35110: PUSH
35111: LD_EXP 80
35115: PUSH
35116: LD_VAR 0 2
35120: ARRAY
35121: NOT
35122: AND
35123: PUSH
35124: LD_EXP 77
35128: PUSH
35129: LD_VAR 0 4
35133: ARRAY
35134: PUSH
35135: LD_INT 1
35137: GREATER
35138: AND
35139: IFFALSE 35270
// begin ComCancel ( j ) ;
35141: LD_VAR 0 3
35145: PPUSH
35146: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
35150: LD_ADDR_EXP 77
35154: PUSH
35155: LD_EXP 77
35159: PPUSH
35160: LD_VAR 0 4
35164: PPUSH
35165: LD_EXP 77
35169: PUSH
35170: LD_VAR 0 4
35174: ARRAY
35175: PPUSH
35176: LD_EXP 77
35180: PUSH
35181: LD_VAR 0 4
35185: ARRAY
35186: PUSH
35187: LD_INT 1
35189: MINUS
35190: PPUSH
35191: LD_EXP 77
35195: PUSH
35196: LD_VAR 0 4
35200: ARRAY
35201: PPUSH
35202: LD_INT 0
35204: PPUSH
35205: CALL 53207 0 4
35209: PPUSH
35210: CALL_OW 1
35214: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
35215: LD_ADDR_EXP 77
35219: PUSH
35220: LD_EXP 77
35224: PPUSH
35225: LD_VAR 0 4
35229: PPUSH
35230: LD_EXP 77
35234: PUSH
35235: LD_VAR 0 4
35239: ARRAY
35240: PPUSH
35241: LD_EXP 77
35245: PUSH
35246: LD_VAR 0 4
35250: ARRAY
35251: PPUSH
35252: LD_INT 1
35254: PPUSH
35255: LD_INT 0
35257: PPUSH
35258: CALL 53207 0 4
35262: PPUSH
35263: CALL_OW 1
35267: ST_TO_ADDR
// continue ;
35268: GO 34842
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
35270: LD_EXP 79
35274: PUSH
35275: LD_VAR 0 2
35279: ARRAY
35280: PUSH
35281: LD_EXP 80
35285: PUSH
35286: LD_VAR 0 2
35290: ARRAY
35291: NOT
35292: AND
35293: IFFALSE 35420
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
35295: LD_ADDR_EXP 80
35299: PUSH
35300: LD_EXP 80
35304: PPUSH
35305: LD_VAR 0 2
35309: PUSH
35310: LD_EXP 80
35314: PUSH
35315: LD_VAR 0 2
35319: ARRAY
35320: PUSH
35321: LD_INT 1
35323: PLUS
35324: PUSH
35325: EMPTY
35326: LIST
35327: LIST
35328: PPUSH
35329: LD_EXP 79
35333: PUSH
35334: LD_VAR 0 2
35338: ARRAY
35339: PUSH
35340: LD_INT 1
35342: ARRAY
35343: PPUSH
35344: CALL 53789 0 3
35348: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
35349: LD_EXP 79
35353: PUSH
35354: LD_VAR 0 2
35358: ARRAY
35359: PUSH
35360: LD_INT 1
35362: ARRAY
35363: PPUSH
35364: LD_INT 112
35366: PPUSH
35367: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
35371: LD_ADDR_VAR 0 9
35375: PUSH
35376: LD_EXP 79
35380: PUSH
35381: LD_VAR 0 2
35385: ARRAY
35386: PPUSH
35387: LD_INT 1
35389: PPUSH
35390: CALL_OW 3
35394: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
35395: LD_ADDR_EXP 79
35399: PUSH
35400: LD_EXP 79
35404: PPUSH
35405: LD_VAR 0 2
35409: PPUSH
35410: LD_VAR 0 9
35414: PPUSH
35415: CALL_OW 1
35419: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
35420: LD_EXP 79
35424: PUSH
35425: LD_VAR 0 2
35429: ARRAY
35430: PUSH
35431: LD_EXP 80
35435: PUSH
35436: LD_VAR 0 2
35440: ARRAY
35441: AND
35442: PUSH
35443: LD_EXP 80
35447: PUSH
35448: LD_VAR 0 2
35452: ARRAY
35453: PUSH
35454: LD_INT 1
35456: ARRAY
35457: PPUSH
35458: CALL_OW 310
35462: NOT
35463: AND
35464: PUSH
35465: LD_VAR 0 3
35469: PPUSH
35470: CALL_OW 313
35474: PUSH
35475: LD_INT 6
35477: EQUAL
35478: AND
35479: IFFALSE 35535
// begin tmp2 := UnitsInside ( j ) ;
35481: LD_ADDR_VAR 0 9
35485: PUSH
35486: LD_VAR 0 3
35490: PPUSH
35491: CALL_OW 313
35495: ST_TO_ADDR
// if tmp2 = 6 then
35496: LD_VAR 0 9
35500: PUSH
35501: LD_INT 6
35503: EQUAL
35504: IFFALSE 35535
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
35506: LD_VAR 0 9
35510: PUSH
35511: LD_INT 1
35513: ARRAY
35514: PPUSH
35515: LD_INT 112
35517: PPUSH
35518: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
35522: LD_VAR 0 9
35526: PUSH
35527: LD_INT 1
35529: ARRAY
35530: PPUSH
35531: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
35535: LD_EXP 80
35539: PUSH
35540: LD_VAR 0 2
35544: ARRAY
35545: PUSH
35546: LD_EXP 80
35550: PUSH
35551: LD_VAR 0 2
35555: ARRAY
35556: PUSH
35557: LD_INT 1
35559: ARRAY
35560: PPUSH
35561: CALL_OW 314
35565: NOT
35566: AND
35567: PUSH
35568: LD_EXP 80
35572: PUSH
35573: LD_VAR 0 2
35577: ARRAY
35578: PUSH
35579: LD_INT 1
35581: ARRAY
35582: PPUSH
35583: CALL_OW 310
35587: NOT
35588: AND
35589: IFFALSE 35615
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
35591: LD_EXP 80
35595: PUSH
35596: LD_VAR 0 2
35600: ARRAY
35601: PUSH
35602: LD_INT 1
35604: ARRAY
35605: PPUSH
35606: LD_VAR 0 3
35610: PPUSH
35611: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
35615: LD_EXP 80
35619: PUSH
35620: LD_VAR 0 2
35624: ARRAY
35625: PUSH
35626: LD_INT 1
35628: ARRAY
35629: PPUSH
35630: CALL_OW 310
35634: PUSH
35635: LD_EXP 80
35639: PUSH
35640: LD_VAR 0 2
35644: ARRAY
35645: PUSH
35646: LD_INT 1
35648: ARRAY
35649: PPUSH
35650: CALL_OW 310
35654: PPUSH
35655: CALL_OW 461
35659: PUSH
35660: LD_INT 3
35662: NONEQUAL
35663: AND
35664: IFFALSE 35685
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
35666: LD_EXP 80
35670: PUSH
35671: LD_VAR 0 2
35675: ARRAY
35676: PUSH
35677: LD_INT 1
35679: ARRAY
35680: PPUSH
35681: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
35685: LD_VAR 0 3
35689: PPUSH
35690: CALL_OW 461
35694: PUSH
35695: LD_INT 6
35697: EQUAL
35698: PUSH
35699: LD_VAR 0 6
35703: PUSH
35704: LD_INT 1
35706: GREATER
35707: AND
35708: IFFALSE 35860
// begin sci := [ ] ;
35710: LD_ADDR_VAR 0 8
35714: PUSH
35715: EMPTY
35716: ST_TO_ADDR
// for x in ( tmp diff j ) do
35717: LD_ADDR_VAR 0 7
35721: PUSH
35722: LD_VAR 0 6
35726: PUSH
35727: LD_VAR 0 3
35731: DIFF
35732: PUSH
35733: FOR_IN
35734: IFFALSE 35786
// begin if sci = 6 then
35736: LD_VAR 0 8
35740: PUSH
35741: LD_INT 6
35743: EQUAL
35744: IFFALSE 35748
// break ;
35746: GO 35786
// if BuildingStatus ( x ) = bs_idle then
35748: LD_VAR 0 7
35752: PPUSH
35753: CALL_OW 461
35757: PUSH
35758: LD_INT 2
35760: EQUAL
35761: IFFALSE 35784
// sci := sci ^ UnitsInside ( x ) ;
35763: LD_ADDR_VAR 0 8
35767: PUSH
35768: LD_VAR 0 8
35772: PUSH
35773: LD_VAR 0 7
35777: PPUSH
35778: CALL_OW 313
35782: ADD
35783: ST_TO_ADDR
// end ;
35784: GO 35733
35786: POP
35787: POP
// if not sci then
35788: LD_VAR 0 8
35792: NOT
35793: IFFALSE 35797
// continue ;
35795: GO 34842
// for x in sci do
35797: LD_ADDR_VAR 0 7
35801: PUSH
35802: LD_VAR 0 8
35806: PUSH
35807: FOR_IN
35808: IFFALSE 35858
// if IsInUnit ( x ) and not HasTask ( x ) then
35810: LD_VAR 0 7
35814: PPUSH
35815: CALL_OW 310
35819: PUSH
35820: LD_VAR 0 7
35824: PPUSH
35825: CALL_OW 314
35829: NOT
35830: AND
35831: IFFALSE 35856
// begin ComExitBuilding ( x ) ;
35833: LD_VAR 0 7
35837: PPUSH
35838: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
35842: LD_VAR 0 7
35846: PPUSH
35847: LD_VAR 0 3
35851: PPUSH
35852: CALL_OW 180
// end ;
35856: GO 35807
35858: POP
35859: POP
// end ; end ;
35860: GO 34842
35862: POP
35863: POP
// end ;
35864: GO 34796
35866: POP
35867: POP
// end ;
35868: LD_VAR 0 1
35872: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
35873: LD_INT 0
35875: PPUSH
35876: PPUSH
// if not mc_bases then
35877: LD_EXP 50
35881: NOT
35882: IFFALSE 35886
// exit ;
35884: GO 35967
// for i = 1 to mc_bases do
35886: LD_ADDR_VAR 0 2
35890: PUSH
35891: DOUBLE
35892: LD_INT 1
35894: DEC
35895: ST_TO_ADDR
35896: LD_EXP 50
35900: PUSH
35901: FOR_TO
35902: IFFALSE 35965
// if mc_mines [ i ] and mc_miners [ i ] then
35904: LD_EXP 63
35908: PUSH
35909: LD_VAR 0 2
35913: ARRAY
35914: PUSH
35915: LD_EXP 64
35919: PUSH
35920: LD_VAR 0 2
35924: ARRAY
35925: AND
35926: IFFALSE 35963
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
35928: LD_EXP 64
35932: PUSH
35933: LD_VAR 0 2
35937: ARRAY
35938: PUSH
35939: LD_INT 1
35941: ARRAY
35942: PPUSH
35943: CALL_OW 255
35947: PPUSH
35948: LD_EXP 63
35952: PUSH
35953: LD_VAR 0 2
35957: ARRAY
35958: PPUSH
35959: CALL 50591 0 2
35963: GO 35901
35965: POP
35966: POP
// end ;
35967: LD_VAR 0 1
35971: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
35972: LD_INT 0
35974: PPUSH
35975: PPUSH
35976: PPUSH
35977: PPUSH
35978: PPUSH
35979: PPUSH
35980: PPUSH
35981: PPUSH
// if not mc_bases or not mc_parking then
35982: LD_EXP 50
35986: NOT
35987: PUSH
35988: LD_EXP 74
35992: NOT
35993: OR
35994: IFFALSE 35998
// exit ;
35996: GO 36736
// for i = 1 to mc_bases do
35998: LD_ADDR_VAR 0 2
36002: PUSH
36003: DOUBLE
36004: LD_INT 1
36006: DEC
36007: ST_TO_ADDR
36008: LD_EXP 50
36012: PUSH
36013: FOR_TO
36014: IFFALSE 36734
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
36016: LD_EXP 50
36020: PUSH
36021: LD_VAR 0 2
36025: ARRAY
36026: NOT
36027: PUSH
36028: LD_EXP 74
36032: PUSH
36033: LD_VAR 0 2
36037: ARRAY
36038: NOT
36039: OR
36040: IFFALSE 36044
// continue ;
36042: GO 36013
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
36044: LD_ADDR_VAR 0 5
36048: PUSH
36049: LD_EXP 50
36053: PUSH
36054: LD_VAR 0 2
36058: ARRAY
36059: PUSH
36060: LD_INT 1
36062: ARRAY
36063: PPUSH
36064: CALL_OW 255
36068: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
36069: LD_ADDR_VAR 0 6
36073: PUSH
36074: LD_EXP 50
36078: PUSH
36079: LD_VAR 0 2
36083: ARRAY
36084: PPUSH
36085: LD_INT 30
36087: PUSH
36088: LD_INT 3
36090: PUSH
36091: EMPTY
36092: LIST
36093: LIST
36094: PPUSH
36095: CALL_OW 72
36099: ST_TO_ADDR
// if not fac then
36100: LD_VAR 0 6
36104: NOT
36105: IFFALSE 36156
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
36107: LD_ADDR_VAR 0 6
36111: PUSH
36112: LD_EXP 50
36116: PUSH
36117: LD_VAR 0 2
36121: ARRAY
36122: PPUSH
36123: LD_INT 2
36125: PUSH
36126: LD_INT 30
36128: PUSH
36129: LD_INT 0
36131: PUSH
36132: EMPTY
36133: LIST
36134: LIST
36135: PUSH
36136: LD_INT 30
36138: PUSH
36139: LD_INT 1
36141: PUSH
36142: EMPTY
36143: LIST
36144: LIST
36145: PUSH
36146: EMPTY
36147: LIST
36148: LIST
36149: LIST
36150: PPUSH
36151: CALL_OW 72
36155: ST_TO_ADDR
// if not fac then
36156: LD_VAR 0 6
36160: NOT
36161: IFFALSE 36165
// continue ;
36163: GO 36013
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
36165: LD_ADDR_VAR 0 7
36169: PUSH
36170: LD_EXP 74
36174: PUSH
36175: LD_VAR 0 2
36179: ARRAY
36180: PPUSH
36181: LD_INT 22
36183: PUSH
36184: LD_VAR 0 5
36188: PUSH
36189: EMPTY
36190: LIST
36191: LIST
36192: PUSH
36193: LD_INT 21
36195: PUSH
36196: LD_INT 2
36198: PUSH
36199: EMPTY
36200: LIST
36201: LIST
36202: PUSH
36203: LD_INT 3
36205: PUSH
36206: LD_INT 60
36208: PUSH
36209: EMPTY
36210: LIST
36211: PUSH
36212: EMPTY
36213: LIST
36214: LIST
36215: PUSH
36216: LD_INT 3
36218: PUSH
36219: LD_INT 24
36221: PUSH
36222: LD_INT 1000
36224: PUSH
36225: EMPTY
36226: LIST
36227: LIST
36228: PUSH
36229: EMPTY
36230: LIST
36231: LIST
36232: PUSH
36233: EMPTY
36234: LIST
36235: LIST
36236: LIST
36237: LIST
36238: PPUSH
36239: CALL_OW 70
36243: ST_TO_ADDR
// for j in fac do
36244: LD_ADDR_VAR 0 3
36248: PUSH
36249: LD_VAR 0 6
36253: PUSH
36254: FOR_IN
36255: IFFALSE 36350
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
36257: LD_ADDR_VAR 0 7
36261: PUSH
36262: LD_VAR 0 7
36266: PUSH
36267: LD_INT 22
36269: PUSH
36270: LD_VAR 0 5
36274: PUSH
36275: EMPTY
36276: LIST
36277: LIST
36278: PUSH
36279: LD_INT 91
36281: PUSH
36282: LD_VAR 0 3
36286: PUSH
36287: LD_INT 15
36289: PUSH
36290: EMPTY
36291: LIST
36292: LIST
36293: LIST
36294: PUSH
36295: LD_INT 21
36297: PUSH
36298: LD_INT 2
36300: PUSH
36301: EMPTY
36302: LIST
36303: LIST
36304: PUSH
36305: LD_INT 3
36307: PUSH
36308: LD_INT 60
36310: PUSH
36311: EMPTY
36312: LIST
36313: PUSH
36314: EMPTY
36315: LIST
36316: LIST
36317: PUSH
36318: LD_INT 3
36320: PUSH
36321: LD_INT 24
36323: PUSH
36324: LD_INT 1000
36326: PUSH
36327: EMPTY
36328: LIST
36329: LIST
36330: PUSH
36331: EMPTY
36332: LIST
36333: LIST
36334: PUSH
36335: EMPTY
36336: LIST
36337: LIST
36338: LIST
36339: LIST
36340: LIST
36341: PPUSH
36342: CALL_OW 69
36346: UNION
36347: ST_TO_ADDR
36348: GO 36254
36350: POP
36351: POP
// if not vehs then
36352: LD_VAR 0 7
36356: NOT
36357: IFFALSE 36383
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
36359: LD_ADDR_EXP 62
36363: PUSH
36364: LD_EXP 62
36368: PPUSH
36369: LD_VAR 0 2
36373: PPUSH
36374: EMPTY
36375: PPUSH
36376: CALL_OW 1
36380: ST_TO_ADDR
// continue ;
36381: GO 36013
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
36383: LD_ADDR_VAR 0 8
36387: PUSH
36388: LD_EXP 50
36392: PUSH
36393: LD_VAR 0 2
36397: ARRAY
36398: PPUSH
36399: LD_INT 30
36401: PUSH
36402: LD_INT 3
36404: PUSH
36405: EMPTY
36406: LIST
36407: LIST
36408: PPUSH
36409: CALL_OW 72
36413: ST_TO_ADDR
// if tmp then
36414: LD_VAR 0 8
36418: IFFALSE 36521
// begin for j in tmp do
36420: LD_ADDR_VAR 0 3
36424: PUSH
36425: LD_VAR 0 8
36429: PUSH
36430: FOR_IN
36431: IFFALSE 36519
// for k in UnitsInside ( j ) do
36433: LD_ADDR_VAR 0 4
36437: PUSH
36438: LD_VAR 0 3
36442: PPUSH
36443: CALL_OW 313
36447: PUSH
36448: FOR_IN
36449: IFFALSE 36515
// if k then
36451: LD_VAR 0 4
36455: IFFALSE 36513
// if not k in mc_repair_vehicle [ i ] then
36457: LD_VAR 0 4
36461: PUSH
36462: LD_EXP 62
36466: PUSH
36467: LD_VAR 0 2
36471: ARRAY
36472: IN
36473: NOT
36474: IFFALSE 36513
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
36476: LD_ADDR_EXP 62
36480: PUSH
36481: LD_EXP 62
36485: PPUSH
36486: LD_VAR 0 2
36490: PPUSH
36491: LD_EXP 62
36495: PUSH
36496: LD_VAR 0 2
36500: ARRAY
36501: PUSH
36502: LD_VAR 0 4
36506: UNION
36507: PPUSH
36508: CALL_OW 1
36512: ST_TO_ADDR
36513: GO 36448
36515: POP
36516: POP
36517: GO 36430
36519: POP
36520: POP
// end ; if not mc_repair_vehicle [ i ] then
36521: LD_EXP 62
36525: PUSH
36526: LD_VAR 0 2
36530: ARRAY
36531: NOT
36532: IFFALSE 36536
// continue ;
36534: GO 36013
// for j in mc_repair_vehicle [ i ] do
36536: LD_ADDR_VAR 0 3
36540: PUSH
36541: LD_EXP 62
36545: PUSH
36546: LD_VAR 0 2
36550: ARRAY
36551: PUSH
36552: FOR_IN
36553: IFFALSE 36730
// begin if GetClass ( j ) <> 3 then
36555: LD_VAR 0 3
36559: PPUSH
36560: CALL_OW 257
36564: PUSH
36565: LD_INT 3
36567: NONEQUAL
36568: IFFALSE 36609
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
36570: LD_ADDR_EXP 62
36574: PUSH
36575: LD_EXP 62
36579: PPUSH
36580: LD_VAR 0 2
36584: PPUSH
36585: LD_EXP 62
36589: PUSH
36590: LD_VAR 0 2
36594: ARRAY
36595: PUSH
36596: LD_VAR 0 3
36600: DIFF
36601: PPUSH
36602: CALL_OW 1
36606: ST_TO_ADDR
// continue ;
36607: GO 36552
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
36609: LD_VAR 0 3
36613: PPUSH
36614: CALL_OW 311
36618: NOT
36619: PUSH
36620: LD_VAR 0 3
36624: PUSH
36625: LD_EXP 53
36629: PUSH
36630: LD_VAR 0 2
36634: ARRAY
36635: PUSH
36636: LD_INT 1
36638: ARRAY
36639: IN
36640: NOT
36641: AND
36642: PUSH
36643: LD_VAR 0 3
36647: PUSH
36648: LD_EXP 53
36652: PUSH
36653: LD_VAR 0 2
36657: ARRAY
36658: PUSH
36659: LD_INT 2
36661: ARRAY
36662: IN
36663: NOT
36664: AND
36665: IFFALSE 36728
// begin if IsInUnit ( j ) then
36667: LD_VAR 0 3
36671: PPUSH
36672: CALL_OW 310
36676: IFFALSE 36689
// ComExitBuilding ( j ) else
36678: LD_VAR 0 3
36682: PPUSH
36683: CALL_OW 122
36687: GO 36728
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
36689: LD_VAR 0 3
36693: PPUSH
36694: LD_VAR 0 7
36698: PUSH
36699: LD_INT 1
36701: ARRAY
36702: PPUSH
36703: CALL 88166 0 2
36707: NOT
36708: IFFALSE 36728
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
36710: LD_VAR 0 3
36714: PPUSH
36715: LD_VAR 0 7
36719: PUSH
36720: LD_INT 1
36722: ARRAY
36723: PPUSH
36724: CALL_OW 129
// end ; end ;
36728: GO 36552
36730: POP
36731: POP
// end ;
36732: GO 36013
36734: POP
36735: POP
// end ;
36736: LD_VAR 0 1
36740: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
36741: LD_INT 0
36743: PPUSH
36744: PPUSH
36745: PPUSH
36746: PPUSH
36747: PPUSH
36748: PPUSH
36749: PPUSH
36750: PPUSH
36751: PPUSH
36752: PPUSH
36753: PPUSH
// if not mc_bases then
36754: LD_EXP 50
36758: NOT
36759: IFFALSE 36763
// exit ;
36761: GO 37565
// for i = 1 to mc_bases do
36763: LD_ADDR_VAR 0 2
36767: PUSH
36768: DOUBLE
36769: LD_INT 1
36771: DEC
36772: ST_TO_ADDR
36773: LD_EXP 50
36777: PUSH
36778: FOR_TO
36779: IFFALSE 37563
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
36781: LD_EXP 78
36785: PUSH
36786: LD_VAR 0 2
36790: ARRAY
36791: NOT
36792: PUSH
36793: LD_EXP 53
36797: PUSH
36798: LD_VAR 0 2
36802: ARRAY
36803: PUSH
36804: LD_INT 1
36806: ARRAY
36807: OR
36808: PUSH
36809: LD_EXP 53
36813: PUSH
36814: LD_VAR 0 2
36818: ARRAY
36819: PUSH
36820: LD_INT 2
36822: ARRAY
36823: OR
36824: PUSH
36825: LD_EXP 76
36829: PUSH
36830: LD_VAR 0 2
36834: ARRAY
36835: PPUSH
36836: LD_INT 1
36838: PPUSH
36839: CALL_OW 325
36843: NOT
36844: OR
36845: PUSH
36846: LD_EXP 73
36850: PUSH
36851: LD_VAR 0 2
36855: ARRAY
36856: OR
36857: IFFALSE 36861
// continue ;
36859: GO 36778
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
36861: LD_ADDR_VAR 0 8
36865: PUSH
36866: LD_EXP 50
36870: PUSH
36871: LD_VAR 0 2
36875: ARRAY
36876: PPUSH
36877: LD_INT 25
36879: PUSH
36880: LD_INT 4
36882: PUSH
36883: EMPTY
36884: LIST
36885: LIST
36886: PUSH
36887: LD_INT 50
36889: PUSH
36890: EMPTY
36891: LIST
36892: PUSH
36893: LD_INT 3
36895: PUSH
36896: LD_INT 60
36898: PUSH
36899: EMPTY
36900: LIST
36901: PUSH
36902: EMPTY
36903: LIST
36904: LIST
36905: PUSH
36906: EMPTY
36907: LIST
36908: LIST
36909: LIST
36910: PPUSH
36911: CALL_OW 72
36915: PUSH
36916: LD_EXP 54
36920: PUSH
36921: LD_VAR 0 2
36925: ARRAY
36926: DIFF
36927: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
36928: LD_ADDR_VAR 0 9
36932: PUSH
36933: LD_EXP 50
36937: PUSH
36938: LD_VAR 0 2
36942: ARRAY
36943: PPUSH
36944: LD_INT 2
36946: PUSH
36947: LD_INT 30
36949: PUSH
36950: LD_INT 0
36952: PUSH
36953: EMPTY
36954: LIST
36955: LIST
36956: PUSH
36957: LD_INT 30
36959: PUSH
36960: LD_INT 1
36962: PUSH
36963: EMPTY
36964: LIST
36965: LIST
36966: PUSH
36967: EMPTY
36968: LIST
36969: LIST
36970: LIST
36971: PPUSH
36972: CALL_OW 72
36976: ST_TO_ADDR
// if not tmp or not dep then
36977: LD_VAR 0 8
36981: NOT
36982: PUSH
36983: LD_VAR 0 9
36987: NOT
36988: OR
36989: IFFALSE 36993
// continue ;
36991: GO 36778
// side := GetSide ( tmp [ 1 ] ) ;
36993: LD_ADDR_VAR 0 11
36997: PUSH
36998: LD_VAR 0 8
37002: PUSH
37003: LD_INT 1
37005: ARRAY
37006: PPUSH
37007: CALL_OW 255
37011: ST_TO_ADDR
// dep := dep [ 1 ] ;
37012: LD_ADDR_VAR 0 9
37016: PUSH
37017: LD_VAR 0 9
37021: PUSH
37022: LD_INT 1
37024: ARRAY
37025: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
37026: LD_ADDR_VAR 0 7
37030: PUSH
37031: LD_EXP 78
37035: PUSH
37036: LD_VAR 0 2
37040: ARRAY
37041: PPUSH
37042: LD_INT 22
37044: PUSH
37045: LD_INT 0
37047: PUSH
37048: EMPTY
37049: LIST
37050: LIST
37051: PUSH
37052: LD_INT 25
37054: PUSH
37055: LD_INT 12
37057: PUSH
37058: EMPTY
37059: LIST
37060: LIST
37061: PUSH
37062: EMPTY
37063: LIST
37064: LIST
37065: PPUSH
37066: CALL_OW 70
37070: PUSH
37071: LD_INT 22
37073: PUSH
37074: LD_INT 0
37076: PUSH
37077: EMPTY
37078: LIST
37079: LIST
37080: PUSH
37081: LD_INT 25
37083: PUSH
37084: LD_INT 12
37086: PUSH
37087: EMPTY
37088: LIST
37089: LIST
37090: PUSH
37091: LD_INT 91
37093: PUSH
37094: LD_VAR 0 9
37098: PUSH
37099: LD_INT 20
37101: PUSH
37102: EMPTY
37103: LIST
37104: LIST
37105: LIST
37106: PUSH
37107: EMPTY
37108: LIST
37109: LIST
37110: LIST
37111: PPUSH
37112: CALL_OW 69
37116: UNION
37117: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
37118: LD_ADDR_VAR 0 10
37122: PUSH
37123: LD_EXP 78
37127: PUSH
37128: LD_VAR 0 2
37132: ARRAY
37133: PPUSH
37134: LD_INT 81
37136: PUSH
37137: LD_VAR 0 11
37141: PUSH
37142: EMPTY
37143: LIST
37144: LIST
37145: PPUSH
37146: CALL_OW 70
37150: ST_TO_ADDR
// if not apes or danger_at_area then
37151: LD_VAR 0 7
37155: NOT
37156: PUSH
37157: LD_VAR 0 10
37161: OR
37162: IFFALSE 37212
// begin if mc_taming [ i ] then
37164: LD_EXP 81
37168: PUSH
37169: LD_VAR 0 2
37173: ARRAY
37174: IFFALSE 37210
// begin MC_Reset ( i , 121 ) ;
37176: LD_VAR 0 2
37180: PPUSH
37181: LD_INT 121
37183: PPUSH
37184: CALL 22149 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
37188: LD_ADDR_EXP 81
37192: PUSH
37193: LD_EXP 81
37197: PPUSH
37198: LD_VAR 0 2
37202: PPUSH
37203: EMPTY
37204: PPUSH
37205: CALL_OW 1
37209: ST_TO_ADDR
// end ; continue ;
37210: GO 36778
// end ; for j in tmp do
37212: LD_ADDR_VAR 0 3
37216: PUSH
37217: LD_VAR 0 8
37221: PUSH
37222: FOR_IN
37223: IFFALSE 37559
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
37225: LD_VAR 0 3
37229: PUSH
37230: LD_EXP 81
37234: PUSH
37235: LD_VAR 0 2
37239: ARRAY
37240: IN
37241: NOT
37242: PUSH
37243: LD_EXP 81
37247: PUSH
37248: LD_VAR 0 2
37252: ARRAY
37253: PUSH
37254: LD_INT 3
37256: LESS
37257: AND
37258: IFFALSE 37316
// begin SetTag ( j , 121 ) ;
37260: LD_VAR 0 3
37264: PPUSH
37265: LD_INT 121
37267: PPUSH
37268: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
37272: LD_ADDR_EXP 81
37276: PUSH
37277: LD_EXP 81
37281: PPUSH
37282: LD_VAR 0 2
37286: PUSH
37287: LD_EXP 81
37291: PUSH
37292: LD_VAR 0 2
37296: ARRAY
37297: PUSH
37298: LD_INT 1
37300: PLUS
37301: PUSH
37302: EMPTY
37303: LIST
37304: LIST
37305: PPUSH
37306: LD_VAR 0 3
37310: PPUSH
37311: CALL 53789 0 3
37315: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
37316: LD_VAR 0 3
37320: PUSH
37321: LD_EXP 81
37325: PUSH
37326: LD_VAR 0 2
37330: ARRAY
37331: IN
37332: IFFALSE 37557
// begin if GetClass ( j ) <> 4 then
37334: LD_VAR 0 3
37338: PPUSH
37339: CALL_OW 257
37343: PUSH
37344: LD_INT 4
37346: NONEQUAL
37347: IFFALSE 37400
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
37349: LD_ADDR_EXP 81
37353: PUSH
37354: LD_EXP 81
37358: PPUSH
37359: LD_VAR 0 2
37363: PPUSH
37364: LD_EXP 81
37368: PUSH
37369: LD_VAR 0 2
37373: ARRAY
37374: PUSH
37375: LD_VAR 0 3
37379: DIFF
37380: PPUSH
37381: CALL_OW 1
37385: ST_TO_ADDR
// SetTag ( j , 0 ) ;
37386: LD_VAR 0 3
37390: PPUSH
37391: LD_INT 0
37393: PPUSH
37394: CALL_OW 109
// continue ;
37398: GO 37222
// end ; if IsInUnit ( j ) then
37400: LD_VAR 0 3
37404: PPUSH
37405: CALL_OW 310
37409: IFFALSE 37420
// ComExitBuilding ( j ) ;
37411: LD_VAR 0 3
37415: PPUSH
37416: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
37420: LD_ADDR_VAR 0 6
37424: PUSH
37425: LD_VAR 0 7
37429: PPUSH
37430: LD_VAR 0 3
37434: PPUSH
37435: CALL_OW 74
37439: ST_TO_ADDR
// if not ape then
37440: LD_VAR 0 6
37444: NOT
37445: IFFALSE 37449
// break ;
37447: GO 37559
// x := GetX ( ape ) ;
37449: LD_ADDR_VAR 0 4
37453: PUSH
37454: LD_VAR 0 6
37458: PPUSH
37459: CALL_OW 250
37463: ST_TO_ADDR
// y := GetY ( ape ) ;
37464: LD_ADDR_VAR 0 5
37468: PUSH
37469: LD_VAR 0 6
37473: PPUSH
37474: CALL_OW 251
37478: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
37479: LD_VAR 0 4
37483: PPUSH
37484: LD_VAR 0 5
37488: PPUSH
37489: CALL_OW 488
37493: NOT
37494: PUSH
37495: LD_VAR 0 11
37499: PPUSH
37500: LD_VAR 0 4
37504: PPUSH
37505: LD_VAR 0 5
37509: PPUSH
37510: LD_INT 20
37512: PPUSH
37513: CALL 54685 0 4
37517: PUSH
37518: LD_INT 4
37520: ARRAY
37521: OR
37522: IFFALSE 37526
// break ;
37524: GO 37559
// if not HasTask ( j ) then
37526: LD_VAR 0 3
37530: PPUSH
37531: CALL_OW 314
37535: NOT
37536: IFFALSE 37557
// ComTameXY ( j , x , y ) ;
37538: LD_VAR 0 3
37542: PPUSH
37543: LD_VAR 0 4
37547: PPUSH
37548: LD_VAR 0 5
37552: PPUSH
37553: CALL_OW 131
// end ; end ;
37557: GO 37222
37559: POP
37560: POP
// end ;
37561: GO 36778
37563: POP
37564: POP
// end ;
37565: LD_VAR 0 1
37569: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
37570: LD_INT 0
37572: PPUSH
37573: PPUSH
37574: PPUSH
37575: PPUSH
37576: PPUSH
37577: PPUSH
37578: PPUSH
37579: PPUSH
// if not mc_bases then
37580: LD_EXP 50
37584: NOT
37585: IFFALSE 37589
// exit ;
37587: GO 38215
// for i = 1 to mc_bases do
37589: LD_ADDR_VAR 0 2
37593: PUSH
37594: DOUBLE
37595: LD_INT 1
37597: DEC
37598: ST_TO_ADDR
37599: LD_EXP 50
37603: PUSH
37604: FOR_TO
37605: IFFALSE 38213
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
37607: LD_EXP 79
37611: PUSH
37612: LD_VAR 0 2
37616: ARRAY
37617: NOT
37618: PUSH
37619: LD_EXP 79
37623: PUSH
37624: LD_VAR 0 2
37628: ARRAY
37629: PPUSH
37630: LD_INT 25
37632: PUSH
37633: LD_INT 12
37635: PUSH
37636: EMPTY
37637: LIST
37638: LIST
37639: PPUSH
37640: CALL_OW 72
37644: NOT
37645: OR
37646: IFFALSE 37650
// continue ;
37648: GO 37604
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
37650: LD_ADDR_VAR 0 5
37654: PUSH
37655: LD_EXP 79
37659: PUSH
37660: LD_VAR 0 2
37664: ARRAY
37665: PUSH
37666: LD_INT 1
37668: ARRAY
37669: PPUSH
37670: CALL_OW 255
37674: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
37675: LD_VAR 0 5
37679: PPUSH
37680: LD_INT 2
37682: PPUSH
37683: CALL_OW 325
37687: IFFALSE 37940
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
37689: LD_ADDR_VAR 0 4
37693: PUSH
37694: LD_EXP 79
37698: PUSH
37699: LD_VAR 0 2
37703: ARRAY
37704: PPUSH
37705: LD_INT 25
37707: PUSH
37708: LD_INT 16
37710: PUSH
37711: EMPTY
37712: LIST
37713: LIST
37714: PPUSH
37715: CALL_OW 72
37719: ST_TO_ADDR
// if tmp < 6 then
37720: LD_VAR 0 4
37724: PUSH
37725: LD_INT 6
37727: LESS
37728: IFFALSE 37940
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
37730: LD_ADDR_VAR 0 6
37734: PUSH
37735: LD_EXP 50
37739: PUSH
37740: LD_VAR 0 2
37744: ARRAY
37745: PPUSH
37746: LD_INT 2
37748: PUSH
37749: LD_INT 30
37751: PUSH
37752: LD_INT 0
37754: PUSH
37755: EMPTY
37756: LIST
37757: LIST
37758: PUSH
37759: LD_INT 30
37761: PUSH
37762: LD_INT 1
37764: PUSH
37765: EMPTY
37766: LIST
37767: LIST
37768: PUSH
37769: EMPTY
37770: LIST
37771: LIST
37772: LIST
37773: PPUSH
37774: CALL_OW 72
37778: ST_TO_ADDR
// if depot then
37779: LD_VAR 0 6
37783: IFFALSE 37940
// begin selected := 0 ;
37785: LD_ADDR_VAR 0 7
37789: PUSH
37790: LD_INT 0
37792: ST_TO_ADDR
// for j in depot do
37793: LD_ADDR_VAR 0 3
37797: PUSH
37798: LD_VAR 0 6
37802: PUSH
37803: FOR_IN
37804: IFFALSE 37835
// begin if UnitsInside ( j ) < 6 then
37806: LD_VAR 0 3
37810: PPUSH
37811: CALL_OW 313
37815: PUSH
37816: LD_INT 6
37818: LESS
37819: IFFALSE 37833
// begin selected := j ;
37821: LD_ADDR_VAR 0 7
37825: PUSH
37826: LD_VAR 0 3
37830: ST_TO_ADDR
// break ;
37831: GO 37835
// end ; end ;
37833: GO 37803
37835: POP
37836: POP
// if selected then
37837: LD_VAR 0 7
37841: IFFALSE 37940
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
37843: LD_ADDR_VAR 0 3
37847: PUSH
37848: LD_EXP 79
37852: PUSH
37853: LD_VAR 0 2
37857: ARRAY
37858: PPUSH
37859: LD_INT 25
37861: PUSH
37862: LD_INT 12
37864: PUSH
37865: EMPTY
37866: LIST
37867: LIST
37868: PPUSH
37869: CALL_OW 72
37873: PUSH
37874: FOR_IN
37875: IFFALSE 37938
// if not HasTask ( j ) then
37877: LD_VAR 0 3
37881: PPUSH
37882: CALL_OW 314
37886: NOT
37887: IFFALSE 37936
// begin if not IsInUnit ( j ) then
37889: LD_VAR 0 3
37893: PPUSH
37894: CALL_OW 310
37898: NOT
37899: IFFALSE 37915
// ComEnterUnit ( j , selected ) ;
37901: LD_VAR 0 3
37905: PPUSH
37906: LD_VAR 0 7
37910: PPUSH
37911: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
37915: LD_VAR 0 3
37919: PPUSH
37920: LD_INT 16
37922: PPUSH
37923: CALL_OW 183
// AddComExitBuilding ( j ) ;
37927: LD_VAR 0 3
37931: PPUSH
37932: CALL_OW 182
// end ;
37936: GO 37874
37938: POP
37939: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
37940: LD_VAR 0 5
37944: PPUSH
37945: LD_INT 11
37947: PPUSH
37948: CALL_OW 325
37952: IFFALSE 38211
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
37954: LD_ADDR_VAR 0 4
37958: PUSH
37959: LD_EXP 79
37963: PUSH
37964: LD_VAR 0 2
37968: ARRAY
37969: PPUSH
37970: LD_INT 25
37972: PUSH
37973: LD_INT 16
37975: PUSH
37976: EMPTY
37977: LIST
37978: LIST
37979: PPUSH
37980: CALL_OW 72
37984: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
37985: LD_VAR 0 4
37989: PUSH
37990: LD_INT 6
37992: GREATEREQUAL
37993: PUSH
37994: LD_VAR 0 5
37998: PPUSH
37999: LD_INT 2
38001: PPUSH
38002: CALL_OW 325
38006: NOT
38007: OR
38008: IFFALSE 38211
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
38010: LD_ADDR_VAR 0 8
38014: PUSH
38015: LD_EXP 50
38019: PUSH
38020: LD_VAR 0 2
38024: ARRAY
38025: PPUSH
38026: LD_INT 2
38028: PUSH
38029: LD_INT 30
38031: PUSH
38032: LD_INT 4
38034: PUSH
38035: EMPTY
38036: LIST
38037: LIST
38038: PUSH
38039: LD_INT 30
38041: PUSH
38042: LD_INT 5
38044: PUSH
38045: EMPTY
38046: LIST
38047: LIST
38048: PUSH
38049: EMPTY
38050: LIST
38051: LIST
38052: LIST
38053: PPUSH
38054: CALL_OW 72
38058: ST_TO_ADDR
// if barracks then
38059: LD_VAR 0 8
38063: IFFALSE 38211
// begin selected := 0 ;
38065: LD_ADDR_VAR 0 7
38069: PUSH
38070: LD_INT 0
38072: ST_TO_ADDR
// for j in barracks do
38073: LD_ADDR_VAR 0 3
38077: PUSH
38078: LD_VAR 0 8
38082: PUSH
38083: FOR_IN
38084: IFFALSE 38115
// begin if UnitsInside ( j ) < 6 then
38086: LD_VAR 0 3
38090: PPUSH
38091: CALL_OW 313
38095: PUSH
38096: LD_INT 6
38098: LESS
38099: IFFALSE 38113
// begin selected := j ;
38101: LD_ADDR_VAR 0 7
38105: PUSH
38106: LD_VAR 0 3
38110: ST_TO_ADDR
// break ;
38111: GO 38115
// end ; end ;
38113: GO 38083
38115: POP
38116: POP
// if selected then
38117: LD_VAR 0 7
38121: IFFALSE 38211
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
38123: LD_ADDR_VAR 0 3
38127: PUSH
38128: LD_EXP 79
38132: PUSH
38133: LD_VAR 0 2
38137: ARRAY
38138: PPUSH
38139: LD_INT 25
38141: PUSH
38142: LD_INT 12
38144: PUSH
38145: EMPTY
38146: LIST
38147: LIST
38148: PPUSH
38149: CALL_OW 72
38153: PUSH
38154: FOR_IN
38155: IFFALSE 38209
// if not IsInUnit ( j ) and not HasTask ( j ) then
38157: LD_VAR 0 3
38161: PPUSH
38162: CALL_OW 310
38166: NOT
38167: PUSH
38168: LD_VAR 0 3
38172: PPUSH
38173: CALL_OW 314
38177: NOT
38178: AND
38179: IFFALSE 38207
// begin ComEnterUnit ( j , selected ) ;
38181: LD_VAR 0 3
38185: PPUSH
38186: LD_VAR 0 7
38190: PPUSH
38191: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
38195: LD_VAR 0 3
38199: PPUSH
38200: LD_INT 15
38202: PPUSH
38203: CALL_OW 183
// end ;
38207: GO 38154
38209: POP
38210: POP
// end ; end ; end ; end ; end ;
38211: GO 37604
38213: POP
38214: POP
// end ;
38215: LD_VAR 0 1
38219: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
38220: LD_INT 0
38222: PPUSH
38223: PPUSH
38224: PPUSH
38225: PPUSH
// if not mc_bases then
38226: LD_EXP 50
38230: NOT
38231: IFFALSE 38235
// exit ;
38233: GO 38413
// for i = 1 to mc_bases do
38235: LD_ADDR_VAR 0 2
38239: PUSH
38240: DOUBLE
38241: LD_INT 1
38243: DEC
38244: ST_TO_ADDR
38245: LD_EXP 50
38249: PUSH
38250: FOR_TO
38251: IFFALSE 38411
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
38253: LD_ADDR_VAR 0 4
38257: PUSH
38258: LD_EXP 50
38262: PUSH
38263: LD_VAR 0 2
38267: ARRAY
38268: PPUSH
38269: LD_INT 25
38271: PUSH
38272: LD_INT 9
38274: PUSH
38275: EMPTY
38276: LIST
38277: LIST
38278: PPUSH
38279: CALL_OW 72
38283: ST_TO_ADDR
// if not tmp then
38284: LD_VAR 0 4
38288: NOT
38289: IFFALSE 38293
// continue ;
38291: GO 38250
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
38293: LD_EXP 76
38297: PUSH
38298: LD_VAR 0 2
38302: ARRAY
38303: PPUSH
38304: LD_INT 29
38306: PPUSH
38307: CALL_OW 325
38311: NOT
38312: PUSH
38313: LD_EXP 76
38317: PUSH
38318: LD_VAR 0 2
38322: ARRAY
38323: PPUSH
38324: LD_INT 28
38326: PPUSH
38327: CALL_OW 325
38331: NOT
38332: AND
38333: IFFALSE 38337
// continue ;
38335: GO 38250
// for j in tmp do
38337: LD_ADDR_VAR 0 3
38341: PUSH
38342: LD_VAR 0 4
38346: PUSH
38347: FOR_IN
38348: IFFALSE 38407
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
38350: LD_VAR 0 3
38354: PUSH
38355: LD_EXP 53
38359: PUSH
38360: LD_VAR 0 2
38364: ARRAY
38365: PUSH
38366: LD_INT 1
38368: ARRAY
38369: IN
38370: NOT
38371: PUSH
38372: LD_VAR 0 3
38376: PUSH
38377: LD_EXP 53
38381: PUSH
38382: LD_VAR 0 2
38386: ARRAY
38387: PUSH
38388: LD_INT 2
38390: ARRAY
38391: IN
38392: NOT
38393: AND
38394: IFFALSE 38405
// ComSpaceTimeShoot ( j ) ;
38396: LD_VAR 0 3
38400: PPUSH
38401: CALL 49599 0 1
38405: GO 38347
38407: POP
38408: POP
// end ;
38409: GO 38250
38411: POP
38412: POP
// end ;
38413: LD_VAR 0 1
38417: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
38418: LD_INT 0
38420: PPUSH
38421: PPUSH
38422: PPUSH
38423: PPUSH
38424: PPUSH
38425: PPUSH
38426: PPUSH
38427: PPUSH
38428: PPUSH
// if not mc_bases then
38429: LD_EXP 50
38433: NOT
38434: IFFALSE 38438
// exit ;
38436: GO 39060
// for i = 1 to mc_bases do
38438: LD_ADDR_VAR 0 2
38442: PUSH
38443: DOUBLE
38444: LD_INT 1
38446: DEC
38447: ST_TO_ADDR
38448: LD_EXP 50
38452: PUSH
38453: FOR_TO
38454: IFFALSE 39058
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
38456: LD_EXP 85
38460: PUSH
38461: LD_VAR 0 2
38465: ARRAY
38466: NOT
38467: PUSH
38468: LD_INT 38
38470: PPUSH
38471: LD_EXP 76
38475: PUSH
38476: LD_VAR 0 2
38480: ARRAY
38481: PPUSH
38482: CALL_OW 321
38486: PUSH
38487: LD_INT 2
38489: NONEQUAL
38490: OR
38491: IFFALSE 38495
// continue ;
38493: GO 38453
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
38495: LD_ADDR_VAR 0 8
38499: PUSH
38500: LD_EXP 50
38504: PUSH
38505: LD_VAR 0 2
38509: ARRAY
38510: PPUSH
38511: LD_INT 30
38513: PUSH
38514: LD_INT 34
38516: PUSH
38517: EMPTY
38518: LIST
38519: LIST
38520: PPUSH
38521: CALL_OW 72
38525: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
38526: LD_ADDR_VAR 0 9
38530: PUSH
38531: LD_EXP 50
38535: PUSH
38536: LD_VAR 0 2
38540: ARRAY
38541: PPUSH
38542: LD_INT 25
38544: PUSH
38545: LD_INT 4
38547: PUSH
38548: EMPTY
38549: LIST
38550: LIST
38551: PPUSH
38552: CALL_OW 72
38556: PPUSH
38557: LD_INT 0
38559: PPUSH
38560: CALL 83675 0 2
38564: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
38565: LD_VAR 0 9
38569: NOT
38570: PUSH
38571: LD_VAR 0 8
38575: NOT
38576: OR
38577: PUSH
38578: LD_EXP 50
38582: PUSH
38583: LD_VAR 0 2
38587: ARRAY
38588: PPUSH
38589: LD_INT 124
38591: PPUSH
38592: CALL 83675 0 2
38596: OR
38597: IFFALSE 38601
// continue ;
38599: GO 38453
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
38601: LD_EXP 86
38605: PUSH
38606: LD_VAR 0 2
38610: ARRAY
38611: PUSH
38612: LD_EXP 85
38616: PUSH
38617: LD_VAR 0 2
38621: ARRAY
38622: LESS
38623: PUSH
38624: LD_EXP 86
38628: PUSH
38629: LD_VAR 0 2
38633: ARRAY
38634: PUSH
38635: LD_VAR 0 8
38639: LESS
38640: AND
38641: IFFALSE 39056
// begin tmp := sci [ 1 ] ;
38643: LD_ADDR_VAR 0 7
38647: PUSH
38648: LD_VAR 0 9
38652: PUSH
38653: LD_INT 1
38655: ARRAY
38656: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
38657: LD_VAR 0 7
38661: PPUSH
38662: LD_INT 124
38664: PPUSH
38665: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
38669: LD_ADDR_VAR 0 3
38673: PUSH
38674: DOUBLE
38675: LD_EXP 85
38679: PUSH
38680: LD_VAR 0 2
38684: ARRAY
38685: INC
38686: ST_TO_ADDR
38687: LD_EXP 85
38691: PUSH
38692: LD_VAR 0 2
38696: ARRAY
38697: PUSH
38698: FOR_DOWNTO
38699: IFFALSE 39042
// begin if IsInUnit ( tmp ) then
38701: LD_VAR 0 7
38705: PPUSH
38706: CALL_OW 310
38710: IFFALSE 38721
// ComExitBuilding ( tmp ) ;
38712: LD_VAR 0 7
38716: PPUSH
38717: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
38721: LD_INT 35
38723: PPUSH
38724: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
38728: LD_VAR 0 7
38732: PPUSH
38733: CALL_OW 310
38737: NOT
38738: PUSH
38739: LD_VAR 0 7
38743: PPUSH
38744: CALL_OW 314
38748: NOT
38749: AND
38750: IFFALSE 38721
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
38752: LD_ADDR_VAR 0 6
38756: PUSH
38757: LD_VAR 0 7
38761: PPUSH
38762: CALL_OW 250
38766: PUSH
38767: LD_VAR 0 7
38771: PPUSH
38772: CALL_OW 251
38776: PUSH
38777: EMPTY
38778: LIST
38779: LIST
38780: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
38781: LD_INT 35
38783: PPUSH
38784: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
38788: LD_ADDR_VAR 0 4
38792: PUSH
38793: LD_EXP 85
38797: PUSH
38798: LD_VAR 0 2
38802: ARRAY
38803: PUSH
38804: LD_VAR 0 3
38808: ARRAY
38809: PUSH
38810: LD_INT 1
38812: ARRAY
38813: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
38814: LD_ADDR_VAR 0 5
38818: PUSH
38819: LD_EXP 85
38823: PUSH
38824: LD_VAR 0 2
38828: ARRAY
38829: PUSH
38830: LD_VAR 0 3
38834: ARRAY
38835: PUSH
38836: LD_INT 2
38838: ARRAY
38839: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
38840: LD_VAR 0 7
38844: PPUSH
38845: LD_INT 10
38847: PPUSH
38848: CALL 56386 0 2
38852: PUSH
38853: LD_INT 4
38855: ARRAY
38856: IFFALSE 38894
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
38858: LD_VAR 0 7
38862: PPUSH
38863: LD_VAR 0 6
38867: PUSH
38868: LD_INT 1
38870: ARRAY
38871: PPUSH
38872: LD_VAR 0 6
38876: PUSH
38877: LD_INT 2
38879: ARRAY
38880: PPUSH
38881: CALL_OW 111
// wait ( 0 0$10 ) ;
38885: LD_INT 350
38887: PPUSH
38888: CALL_OW 67
// end else
38892: GO 38920
// begin ComMoveXY ( tmp , x , y ) ;
38894: LD_VAR 0 7
38898: PPUSH
38899: LD_VAR 0 4
38903: PPUSH
38904: LD_VAR 0 5
38908: PPUSH
38909: CALL_OW 111
// wait ( 0 0$3 ) ;
38913: LD_INT 105
38915: PPUSH
38916: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
38920: LD_VAR 0 7
38924: PPUSH
38925: LD_VAR 0 4
38929: PPUSH
38930: LD_VAR 0 5
38934: PPUSH
38935: CALL_OW 307
38939: IFFALSE 38781
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
38941: LD_VAR 0 7
38945: PPUSH
38946: LD_VAR 0 4
38950: PPUSH
38951: LD_VAR 0 5
38955: PPUSH
38956: LD_VAR 0 8
38960: PUSH
38961: LD_VAR 0 3
38965: ARRAY
38966: PPUSH
38967: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
38971: LD_INT 35
38973: PPUSH
38974: CALL_OW 67
// until not HasTask ( tmp ) ;
38978: LD_VAR 0 7
38982: PPUSH
38983: CALL_OW 314
38987: NOT
38988: IFFALSE 38971
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
38990: LD_ADDR_EXP 86
38994: PUSH
38995: LD_EXP 86
38999: PPUSH
39000: LD_VAR 0 2
39004: PUSH
39005: LD_EXP 86
39009: PUSH
39010: LD_VAR 0 2
39014: ARRAY
39015: PUSH
39016: LD_INT 1
39018: PLUS
39019: PUSH
39020: EMPTY
39021: LIST
39022: LIST
39023: PPUSH
39024: LD_VAR 0 8
39028: PUSH
39029: LD_VAR 0 3
39033: ARRAY
39034: PPUSH
39035: CALL 53789 0 3
39039: ST_TO_ADDR
// end ;
39040: GO 38698
39042: POP
39043: POP
// MC_Reset ( i , 124 ) ;
39044: LD_VAR 0 2
39048: PPUSH
39049: LD_INT 124
39051: PPUSH
39052: CALL 22149 0 2
// end ; end ;
39056: GO 38453
39058: POP
39059: POP
// end ;
39060: LD_VAR 0 1
39064: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
39065: LD_INT 0
39067: PPUSH
39068: PPUSH
39069: PPUSH
// if not mc_bases then
39070: LD_EXP 50
39074: NOT
39075: IFFALSE 39079
// exit ;
39077: GO 39685
// for i = 1 to mc_bases do
39079: LD_ADDR_VAR 0 2
39083: PUSH
39084: DOUBLE
39085: LD_INT 1
39087: DEC
39088: ST_TO_ADDR
39089: LD_EXP 50
39093: PUSH
39094: FOR_TO
39095: IFFALSE 39683
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
39097: LD_ADDR_VAR 0 3
39101: PUSH
39102: LD_EXP 50
39106: PUSH
39107: LD_VAR 0 2
39111: ARRAY
39112: PPUSH
39113: LD_INT 25
39115: PUSH
39116: LD_INT 4
39118: PUSH
39119: EMPTY
39120: LIST
39121: LIST
39122: PPUSH
39123: CALL_OW 72
39127: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
39128: LD_VAR 0 3
39132: NOT
39133: PUSH
39134: LD_EXP 87
39138: PUSH
39139: LD_VAR 0 2
39143: ARRAY
39144: NOT
39145: OR
39146: PUSH
39147: LD_EXP 50
39151: PUSH
39152: LD_VAR 0 2
39156: ARRAY
39157: PPUSH
39158: LD_INT 2
39160: PUSH
39161: LD_INT 30
39163: PUSH
39164: LD_INT 0
39166: PUSH
39167: EMPTY
39168: LIST
39169: LIST
39170: PUSH
39171: LD_INT 30
39173: PUSH
39174: LD_INT 1
39176: PUSH
39177: EMPTY
39178: LIST
39179: LIST
39180: PUSH
39181: EMPTY
39182: LIST
39183: LIST
39184: LIST
39185: PPUSH
39186: CALL_OW 72
39190: NOT
39191: OR
39192: IFFALSE 39242
// begin if mc_deposits_finder [ i ] then
39194: LD_EXP 88
39198: PUSH
39199: LD_VAR 0 2
39203: ARRAY
39204: IFFALSE 39240
// begin MC_Reset ( i , 125 ) ;
39206: LD_VAR 0 2
39210: PPUSH
39211: LD_INT 125
39213: PPUSH
39214: CALL 22149 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
39218: LD_ADDR_EXP 88
39222: PUSH
39223: LD_EXP 88
39227: PPUSH
39228: LD_VAR 0 2
39232: PPUSH
39233: EMPTY
39234: PPUSH
39235: CALL_OW 1
39239: ST_TO_ADDR
// end ; continue ;
39240: GO 39094
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
39242: LD_EXP 87
39246: PUSH
39247: LD_VAR 0 2
39251: ARRAY
39252: PUSH
39253: LD_INT 1
39255: ARRAY
39256: PUSH
39257: LD_INT 3
39259: ARRAY
39260: PUSH
39261: LD_INT 1
39263: EQUAL
39264: PUSH
39265: LD_INT 20
39267: PPUSH
39268: LD_EXP 76
39272: PUSH
39273: LD_VAR 0 2
39277: ARRAY
39278: PPUSH
39279: CALL_OW 321
39283: PUSH
39284: LD_INT 2
39286: NONEQUAL
39287: AND
39288: IFFALSE 39338
// begin if mc_deposits_finder [ i ] then
39290: LD_EXP 88
39294: PUSH
39295: LD_VAR 0 2
39299: ARRAY
39300: IFFALSE 39336
// begin MC_Reset ( i , 125 ) ;
39302: LD_VAR 0 2
39306: PPUSH
39307: LD_INT 125
39309: PPUSH
39310: CALL 22149 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
39314: LD_ADDR_EXP 88
39318: PUSH
39319: LD_EXP 88
39323: PPUSH
39324: LD_VAR 0 2
39328: PPUSH
39329: EMPTY
39330: PPUSH
39331: CALL_OW 1
39335: ST_TO_ADDR
// end ; continue ;
39336: GO 39094
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
39338: LD_EXP 87
39342: PUSH
39343: LD_VAR 0 2
39347: ARRAY
39348: PUSH
39349: LD_INT 1
39351: ARRAY
39352: PUSH
39353: LD_INT 1
39355: ARRAY
39356: PPUSH
39357: LD_EXP 87
39361: PUSH
39362: LD_VAR 0 2
39366: ARRAY
39367: PUSH
39368: LD_INT 1
39370: ARRAY
39371: PUSH
39372: LD_INT 2
39374: ARRAY
39375: PPUSH
39376: LD_EXP 76
39380: PUSH
39381: LD_VAR 0 2
39385: ARRAY
39386: PPUSH
39387: CALL_OW 440
39391: IFFALSE 39434
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
39393: LD_ADDR_EXP 87
39397: PUSH
39398: LD_EXP 87
39402: PPUSH
39403: LD_VAR 0 2
39407: PPUSH
39408: LD_EXP 87
39412: PUSH
39413: LD_VAR 0 2
39417: ARRAY
39418: PPUSH
39419: LD_INT 1
39421: PPUSH
39422: CALL_OW 3
39426: PPUSH
39427: CALL_OW 1
39431: ST_TO_ADDR
39432: GO 39681
// begin if not mc_deposits_finder [ i ] then
39434: LD_EXP 88
39438: PUSH
39439: LD_VAR 0 2
39443: ARRAY
39444: NOT
39445: IFFALSE 39497
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
39447: LD_ADDR_EXP 88
39451: PUSH
39452: LD_EXP 88
39456: PPUSH
39457: LD_VAR 0 2
39461: PPUSH
39462: LD_VAR 0 3
39466: PUSH
39467: LD_INT 1
39469: ARRAY
39470: PUSH
39471: EMPTY
39472: LIST
39473: PPUSH
39474: CALL_OW 1
39478: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
39479: LD_VAR 0 3
39483: PUSH
39484: LD_INT 1
39486: ARRAY
39487: PPUSH
39488: LD_INT 125
39490: PPUSH
39491: CALL_OW 109
// end else
39495: GO 39681
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
39497: LD_EXP 88
39501: PUSH
39502: LD_VAR 0 2
39506: ARRAY
39507: PUSH
39508: LD_INT 1
39510: ARRAY
39511: PPUSH
39512: CALL_OW 310
39516: IFFALSE 39539
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
39518: LD_EXP 88
39522: PUSH
39523: LD_VAR 0 2
39527: ARRAY
39528: PUSH
39529: LD_INT 1
39531: ARRAY
39532: PPUSH
39533: CALL_OW 122
39537: GO 39681
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
39539: LD_EXP 88
39543: PUSH
39544: LD_VAR 0 2
39548: ARRAY
39549: PUSH
39550: LD_INT 1
39552: ARRAY
39553: PPUSH
39554: CALL_OW 314
39558: NOT
39559: PUSH
39560: LD_EXP 88
39564: PUSH
39565: LD_VAR 0 2
39569: ARRAY
39570: PUSH
39571: LD_INT 1
39573: ARRAY
39574: PPUSH
39575: LD_EXP 87
39579: PUSH
39580: LD_VAR 0 2
39584: ARRAY
39585: PUSH
39586: LD_INT 1
39588: ARRAY
39589: PUSH
39590: LD_INT 1
39592: ARRAY
39593: PPUSH
39594: LD_EXP 87
39598: PUSH
39599: LD_VAR 0 2
39603: ARRAY
39604: PUSH
39605: LD_INT 1
39607: ARRAY
39608: PUSH
39609: LD_INT 2
39611: ARRAY
39612: PPUSH
39613: CALL_OW 297
39617: PUSH
39618: LD_INT 6
39620: GREATER
39621: AND
39622: IFFALSE 39681
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
39624: LD_EXP 88
39628: PUSH
39629: LD_VAR 0 2
39633: ARRAY
39634: PUSH
39635: LD_INT 1
39637: ARRAY
39638: PPUSH
39639: LD_EXP 87
39643: PUSH
39644: LD_VAR 0 2
39648: ARRAY
39649: PUSH
39650: LD_INT 1
39652: ARRAY
39653: PUSH
39654: LD_INT 1
39656: ARRAY
39657: PPUSH
39658: LD_EXP 87
39662: PUSH
39663: LD_VAR 0 2
39667: ARRAY
39668: PUSH
39669: LD_INT 1
39671: ARRAY
39672: PUSH
39673: LD_INT 2
39675: ARRAY
39676: PPUSH
39677: CALL_OW 111
// end ; end ; end ;
39681: GO 39094
39683: POP
39684: POP
// end ;
39685: LD_VAR 0 1
39689: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
39690: LD_INT 0
39692: PPUSH
39693: PPUSH
39694: PPUSH
39695: PPUSH
39696: PPUSH
39697: PPUSH
39698: PPUSH
39699: PPUSH
39700: PPUSH
39701: PPUSH
39702: PPUSH
// if not mc_bases then
39703: LD_EXP 50
39707: NOT
39708: IFFALSE 39712
// exit ;
39710: GO 40652
// for i = 1 to mc_bases do
39712: LD_ADDR_VAR 0 2
39716: PUSH
39717: DOUBLE
39718: LD_INT 1
39720: DEC
39721: ST_TO_ADDR
39722: LD_EXP 50
39726: PUSH
39727: FOR_TO
39728: IFFALSE 40650
// begin if not mc_bases [ i ] or mc_scan [ i ] then
39730: LD_EXP 50
39734: PUSH
39735: LD_VAR 0 2
39739: ARRAY
39740: NOT
39741: PUSH
39742: LD_EXP 73
39746: PUSH
39747: LD_VAR 0 2
39751: ARRAY
39752: OR
39753: IFFALSE 39757
// continue ;
39755: GO 39727
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
39757: LD_ADDR_VAR 0 7
39761: PUSH
39762: LD_EXP 50
39766: PUSH
39767: LD_VAR 0 2
39771: ARRAY
39772: PUSH
39773: LD_INT 1
39775: ARRAY
39776: PPUSH
39777: CALL_OW 248
39781: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
39782: LD_VAR 0 7
39786: PUSH
39787: LD_INT 3
39789: EQUAL
39790: PUSH
39791: LD_EXP 69
39795: PUSH
39796: LD_VAR 0 2
39800: ARRAY
39801: PUSH
39802: LD_EXP 72
39806: PUSH
39807: LD_VAR 0 2
39811: ARRAY
39812: UNION
39813: PPUSH
39814: LD_INT 33
39816: PUSH
39817: LD_INT 2
39819: PUSH
39820: EMPTY
39821: LIST
39822: LIST
39823: PPUSH
39824: CALL_OW 72
39828: NOT
39829: OR
39830: IFFALSE 39834
// continue ;
39832: GO 39727
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
39834: LD_ADDR_VAR 0 9
39838: PUSH
39839: LD_EXP 50
39843: PUSH
39844: LD_VAR 0 2
39848: ARRAY
39849: PPUSH
39850: LD_INT 30
39852: PUSH
39853: LD_INT 36
39855: PUSH
39856: EMPTY
39857: LIST
39858: LIST
39859: PPUSH
39860: CALL_OW 72
39864: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
39865: LD_ADDR_VAR 0 10
39869: PUSH
39870: LD_EXP 69
39874: PUSH
39875: LD_VAR 0 2
39879: ARRAY
39880: PPUSH
39881: LD_INT 34
39883: PUSH
39884: LD_INT 31
39886: PUSH
39887: EMPTY
39888: LIST
39889: LIST
39890: PPUSH
39891: CALL_OW 72
39895: ST_TO_ADDR
// if not cts and not mcts then
39896: LD_VAR 0 9
39900: NOT
39901: PUSH
39902: LD_VAR 0 10
39906: NOT
39907: AND
39908: IFFALSE 39912
// continue ;
39910: GO 39727
// x := cts ;
39912: LD_ADDR_VAR 0 11
39916: PUSH
39917: LD_VAR 0 9
39921: ST_TO_ADDR
// if not x then
39922: LD_VAR 0 11
39926: NOT
39927: IFFALSE 39939
// x := mcts ;
39929: LD_ADDR_VAR 0 11
39933: PUSH
39934: LD_VAR 0 10
39938: ST_TO_ADDR
// if not x then
39939: LD_VAR 0 11
39943: NOT
39944: IFFALSE 39948
// continue ;
39946: GO 39727
// if mc_remote_driver [ i ] then
39948: LD_EXP 90
39952: PUSH
39953: LD_VAR 0 2
39957: ARRAY
39958: IFFALSE 40345
// for j in mc_remote_driver [ i ] do
39960: LD_ADDR_VAR 0 3
39964: PUSH
39965: LD_EXP 90
39969: PUSH
39970: LD_VAR 0 2
39974: ARRAY
39975: PUSH
39976: FOR_IN
39977: IFFALSE 40343
// begin if GetClass ( j ) <> 3 then
39979: LD_VAR 0 3
39983: PPUSH
39984: CALL_OW 257
39988: PUSH
39989: LD_INT 3
39991: NONEQUAL
39992: IFFALSE 40045
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
39994: LD_ADDR_EXP 90
39998: PUSH
39999: LD_EXP 90
40003: PPUSH
40004: LD_VAR 0 2
40008: PPUSH
40009: LD_EXP 90
40013: PUSH
40014: LD_VAR 0 2
40018: ARRAY
40019: PUSH
40020: LD_VAR 0 3
40024: DIFF
40025: PPUSH
40026: CALL_OW 1
40030: ST_TO_ADDR
// SetTag ( j , 0 ) ;
40031: LD_VAR 0 3
40035: PPUSH
40036: LD_INT 0
40038: PPUSH
40039: CALL_OW 109
// continue ;
40043: GO 39976
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
40045: LD_EXP 69
40049: PUSH
40050: LD_VAR 0 2
40054: ARRAY
40055: PPUSH
40056: LD_INT 34
40058: PUSH
40059: LD_INT 31
40061: PUSH
40062: EMPTY
40063: LIST
40064: LIST
40065: PUSH
40066: LD_INT 58
40068: PUSH
40069: EMPTY
40070: LIST
40071: PUSH
40072: EMPTY
40073: LIST
40074: LIST
40075: PPUSH
40076: CALL_OW 72
40080: PUSH
40081: LD_VAR 0 3
40085: PPUSH
40086: CALL 83710 0 1
40090: NOT
40091: AND
40092: IFFALSE 40163
// begin if IsInUnit ( j ) then
40094: LD_VAR 0 3
40098: PPUSH
40099: CALL_OW 310
40103: IFFALSE 40114
// ComExitBuilding ( j ) ;
40105: LD_VAR 0 3
40109: PPUSH
40110: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
40114: LD_VAR 0 3
40118: PPUSH
40119: LD_EXP 69
40123: PUSH
40124: LD_VAR 0 2
40128: ARRAY
40129: PPUSH
40130: LD_INT 34
40132: PUSH
40133: LD_INT 31
40135: PUSH
40136: EMPTY
40137: LIST
40138: LIST
40139: PUSH
40140: LD_INT 58
40142: PUSH
40143: EMPTY
40144: LIST
40145: PUSH
40146: EMPTY
40147: LIST
40148: LIST
40149: PPUSH
40150: CALL_OW 72
40154: PUSH
40155: LD_INT 1
40157: ARRAY
40158: PPUSH
40159: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
40163: LD_VAR 0 3
40167: PPUSH
40168: CALL_OW 310
40172: NOT
40173: PUSH
40174: LD_VAR 0 3
40178: PPUSH
40179: CALL_OW 310
40183: PPUSH
40184: CALL_OW 266
40188: PUSH
40189: LD_INT 36
40191: NONEQUAL
40192: PUSH
40193: LD_VAR 0 3
40197: PPUSH
40198: CALL 83710 0 1
40202: NOT
40203: AND
40204: OR
40205: IFFALSE 40341
// begin if IsInUnit ( j ) then
40207: LD_VAR 0 3
40211: PPUSH
40212: CALL_OW 310
40216: IFFALSE 40227
// ComExitBuilding ( j ) ;
40218: LD_VAR 0 3
40222: PPUSH
40223: CALL_OW 122
// ct := 0 ;
40227: LD_ADDR_VAR 0 8
40231: PUSH
40232: LD_INT 0
40234: ST_TO_ADDR
// for k in x do
40235: LD_ADDR_VAR 0 4
40239: PUSH
40240: LD_VAR 0 11
40244: PUSH
40245: FOR_IN
40246: IFFALSE 40319
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
40248: LD_VAR 0 4
40252: PPUSH
40253: CALL_OW 264
40257: PUSH
40258: LD_INT 31
40260: EQUAL
40261: PUSH
40262: LD_VAR 0 4
40266: PPUSH
40267: CALL_OW 311
40271: NOT
40272: AND
40273: PUSH
40274: LD_VAR 0 4
40278: PPUSH
40279: CALL_OW 266
40283: PUSH
40284: LD_INT 36
40286: EQUAL
40287: PUSH
40288: LD_VAR 0 4
40292: PPUSH
40293: CALL_OW 313
40297: PUSH
40298: LD_INT 3
40300: LESS
40301: AND
40302: OR
40303: IFFALSE 40317
// begin ct := k ;
40305: LD_ADDR_VAR 0 8
40309: PUSH
40310: LD_VAR 0 4
40314: ST_TO_ADDR
// break ;
40315: GO 40319
// end ;
40317: GO 40245
40319: POP
40320: POP
// if ct then
40321: LD_VAR 0 8
40325: IFFALSE 40341
// ComEnterUnit ( j , ct ) ;
40327: LD_VAR 0 3
40331: PPUSH
40332: LD_VAR 0 8
40336: PPUSH
40337: CALL_OW 120
// end ; end ;
40341: GO 39976
40343: POP
40344: POP
// places := 0 ;
40345: LD_ADDR_VAR 0 5
40349: PUSH
40350: LD_INT 0
40352: ST_TO_ADDR
// for j = 1 to x do
40353: LD_ADDR_VAR 0 3
40357: PUSH
40358: DOUBLE
40359: LD_INT 1
40361: DEC
40362: ST_TO_ADDR
40363: LD_VAR 0 11
40367: PUSH
40368: FOR_TO
40369: IFFALSE 40445
// if GetWeapon ( x [ j ] ) = ar_control_tower then
40371: LD_VAR 0 11
40375: PUSH
40376: LD_VAR 0 3
40380: ARRAY
40381: PPUSH
40382: CALL_OW 264
40386: PUSH
40387: LD_INT 31
40389: EQUAL
40390: IFFALSE 40408
// places := places + 1 else
40392: LD_ADDR_VAR 0 5
40396: PUSH
40397: LD_VAR 0 5
40401: PUSH
40402: LD_INT 1
40404: PLUS
40405: ST_TO_ADDR
40406: GO 40443
// if GetBType ( x [ j ] ) = b_control_tower then
40408: LD_VAR 0 11
40412: PUSH
40413: LD_VAR 0 3
40417: ARRAY
40418: PPUSH
40419: CALL_OW 266
40423: PUSH
40424: LD_INT 36
40426: EQUAL
40427: IFFALSE 40443
// places := places + 3 ;
40429: LD_ADDR_VAR 0 5
40433: PUSH
40434: LD_VAR 0 5
40438: PUSH
40439: LD_INT 3
40441: PLUS
40442: ST_TO_ADDR
40443: GO 40368
40445: POP
40446: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
40447: LD_VAR 0 5
40451: PUSH
40452: LD_INT 0
40454: EQUAL
40455: PUSH
40456: LD_VAR 0 5
40460: PUSH
40461: LD_EXP 90
40465: PUSH
40466: LD_VAR 0 2
40470: ARRAY
40471: LESSEQUAL
40472: OR
40473: IFFALSE 40477
// continue ;
40475: GO 39727
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
40477: LD_ADDR_VAR 0 6
40481: PUSH
40482: LD_EXP 50
40486: PUSH
40487: LD_VAR 0 2
40491: ARRAY
40492: PPUSH
40493: LD_INT 25
40495: PUSH
40496: LD_INT 3
40498: PUSH
40499: EMPTY
40500: LIST
40501: LIST
40502: PPUSH
40503: CALL_OW 72
40507: PUSH
40508: LD_EXP 90
40512: PUSH
40513: LD_VAR 0 2
40517: ARRAY
40518: DIFF
40519: PPUSH
40520: LD_INT 3
40522: PPUSH
40523: CALL 84610 0 2
40527: ST_TO_ADDR
// for j in tmp do
40528: LD_ADDR_VAR 0 3
40532: PUSH
40533: LD_VAR 0 6
40537: PUSH
40538: FOR_IN
40539: IFFALSE 40574
// if GetTag ( j ) > 0 then
40541: LD_VAR 0 3
40545: PPUSH
40546: CALL_OW 110
40550: PUSH
40551: LD_INT 0
40553: GREATER
40554: IFFALSE 40572
// tmp := tmp diff j ;
40556: LD_ADDR_VAR 0 6
40560: PUSH
40561: LD_VAR 0 6
40565: PUSH
40566: LD_VAR 0 3
40570: DIFF
40571: ST_TO_ADDR
40572: GO 40538
40574: POP
40575: POP
// if not tmp then
40576: LD_VAR 0 6
40580: NOT
40581: IFFALSE 40585
// continue ;
40583: GO 39727
// if places then
40585: LD_VAR 0 5
40589: IFFALSE 40648
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
40591: LD_ADDR_EXP 90
40595: PUSH
40596: LD_EXP 90
40600: PPUSH
40601: LD_VAR 0 2
40605: PPUSH
40606: LD_EXP 90
40610: PUSH
40611: LD_VAR 0 2
40615: ARRAY
40616: PUSH
40617: LD_VAR 0 6
40621: PUSH
40622: LD_INT 1
40624: ARRAY
40625: UNION
40626: PPUSH
40627: CALL_OW 1
40631: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
40632: LD_VAR 0 6
40636: PUSH
40637: LD_INT 1
40639: ARRAY
40640: PPUSH
40641: LD_INT 126
40643: PPUSH
40644: CALL_OW 109
// end ; end ;
40648: GO 39727
40650: POP
40651: POP
// end ;
40652: LD_VAR 0 1
40656: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
40657: LD_INT 0
40659: PPUSH
40660: PPUSH
40661: PPUSH
40662: PPUSH
40663: PPUSH
40664: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
40665: LD_VAR 0 1
40669: NOT
40670: PUSH
40671: LD_VAR 0 2
40675: NOT
40676: OR
40677: PUSH
40678: LD_VAR 0 3
40682: NOT
40683: OR
40684: PUSH
40685: LD_VAR 0 4
40689: PUSH
40690: LD_INT 1
40692: PUSH
40693: LD_INT 2
40695: PUSH
40696: LD_INT 3
40698: PUSH
40699: LD_INT 4
40701: PUSH
40702: LD_INT 5
40704: PUSH
40705: LD_INT 8
40707: PUSH
40708: LD_INT 9
40710: PUSH
40711: LD_INT 15
40713: PUSH
40714: LD_INT 16
40716: PUSH
40717: EMPTY
40718: LIST
40719: LIST
40720: LIST
40721: LIST
40722: LIST
40723: LIST
40724: LIST
40725: LIST
40726: LIST
40727: IN
40728: NOT
40729: OR
40730: IFFALSE 40734
// exit ;
40732: GO 41634
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
40734: LD_ADDR_VAR 0 2
40738: PUSH
40739: LD_VAR 0 2
40743: PPUSH
40744: LD_INT 21
40746: PUSH
40747: LD_INT 3
40749: PUSH
40750: EMPTY
40751: LIST
40752: LIST
40753: PUSH
40754: LD_INT 24
40756: PUSH
40757: LD_INT 250
40759: PUSH
40760: EMPTY
40761: LIST
40762: LIST
40763: PUSH
40764: EMPTY
40765: LIST
40766: LIST
40767: PPUSH
40768: CALL_OW 72
40772: ST_TO_ADDR
// case class of 1 , 15 :
40773: LD_VAR 0 4
40777: PUSH
40778: LD_INT 1
40780: DOUBLE
40781: EQUAL
40782: IFTRUE 40792
40784: LD_INT 15
40786: DOUBLE
40787: EQUAL
40788: IFTRUE 40792
40790: GO 40877
40792: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
40793: LD_ADDR_VAR 0 8
40797: PUSH
40798: LD_VAR 0 2
40802: PPUSH
40803: LD_INT 2
40805: PUSH
40806: LD_INT 30
40808: PUSH
40809: LD_INT 32
40811: PUSH
40812: EMPTY
40813: LIST
40814: LIST
40815: PUSH
40816: LD_INT 30
40818: PUSH
40819: LD_INT 31
40821: PUSH
40822: EMPTY
40823: LIST
40824: LIST
40825: PUSH
40826: EMPTY
40827: LIST
40828: LIST
40829: LIST
40830: PPUSH
40831: CALL_OW 72
40835: PUSH
40836: LD_VAR 0 2
40840: PPUSH
40841: LD_INT 2
40843: PUSH
40844: LD_INT 30
40846: PUSH
40847: LD_INT 4
40849: PUSH
40850: EMPTY
40851: LIST
40852: LIST
40853: PUSH
40854: LD_INT 30
40856: PUSH
40857: LD_INT 5
40859: PUSH
40860: EMPTY
40861: LIST
40862: LIST
40863: PUSH
40864: EMPTY
40865: LIST
40866: LIST
40867: LIST
40868: PPUSH
40869: CALL_OW 72
40873: ADD
40874: ST_TO_ADDR
40875: GO 41123
40877: LD_INT 2
40879: DOUBLE
40880: EQUAL
40881: IFTRUE 40891
40883: LD_INT 16
40885: DOUBLE
40886: EQUAL
40887: IFTRUE 40891
40889: GO 40937
40891: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
40892: LD_ADDR_VAR 0 8
40896: PUSH
40897: LD_VAR 0 2
40901: PPUSH
40902: LD_INT 2
40904: PUSH
40905: LD_INT 30
40907: PUSH
40908: LD_INT 0
40910: PUSH
40911: EMPTY
40912: LIST
40913: LIST
40914: PUSH
40915: LD_INT 30
40917: PUSH
40918: LD_INT 1
40920: PUSH
40921: EMPTY
40922: LIST
40923: LIST
40924: PUSH
40925: EMPTY
40926: LIST
40927: LIST
40928: LIST
40929: PPUSH
40930: CALL_OW 72
40934: ST_TO_ADDR
40935: GO 41123
40937: LD_INT 3
40939: DOUBLE
40940: EQUAL
40941: IFTRUE 40945
40943: GO 40991
40945: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
40946: LD_ADDR_VAR 0 8
40950: PUSH
40951: LD_VAR 0 2
40955: PPUSH
40956: LD_INT 2
40958: PUSH
40959: LD_INT 30
40961: PUSH
40962: LD_INT 2
40964: PUSH
40965: EMPTY
40966: LIST
40967: LIST
40968: PUSH
40969: LD_INT 30
40971: PUSH
40972: LD_INT 3
40974: PUSH
40975: EMPTY
40976: LIST
40977: LIST
40978: PUSH
40979: EMPTY
40980: LIST
40981: LIST
40982: LIST
40983: PPUSH
40984: CALL_OW 72
40988: ST_TO_ADDR
40989: GO 41123
40991: LD_INT 4
40993: DOUBLE
40994: EQUAL
40995: IFTRUE 40999
40997: GO 41056
40999: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
41000: LD_ADDR_VAR 0 8
41004: PUSH
41005: LD_VAR 0 2
41009: PPUSH
41010: LD_INT 2
41012: PUSH
41013: LD_INT 30
41015: PUSH
41016: LD_INT 6
41018: PUSH
41019: EMPTY
41020: LIST
41021: LIST
41022: PUSH
41023: LD_INT 30
41025: PUSH
41026: LD_INT 7
41028: PUSH
41029: EMPTY
41030: LIST
41031: LIST
41032: PUSH
41033: LD_INT 30
41035: PUSH
41036: LD_INT 8
41038: PUSH
41039: EMPTY
41040: LIST
41041: LIST
41042: PUSH
41043: EMPTY
41044: LIST
41045: LIST
41046: LIST
41047: LIST
41048: PPUSH
41049: CALL_OW 72
41053: ST_TO_ADDR
41054: GO 41123
41056: LD_INT 5
41058: DOUBLE
41059: EQUAL
41060: IFTRUE 41076
41062: LD_INT 8
41064: DOUBLE
41065: EQUAL
41066: IFTRUE 41076
41068: LD_INT 9
41070: DOUBLE
41071: EQUAL
41072: IFTRUE 41076
41074: GO 41122
41076: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
41077: LD_ADDR_VAR 0 8
41081: PUSH
41082: LD_VAR 0 2
41086: PPUSH
41087: LD_INT 2
41089: PUSH
41090: LD_INT 30
41092: PUSH
41093: LD_INT 4
41095: PUSH
41096: EMPTY
41097: LIST
41098: LIST
41099: PUSH
41100: LD_INT 30
41102: PUSH
41103: LD_INT 5
41105: PUSH
41106: EMPTY
41107: LIST
41108: LIST
41109: PUSH
41110: EMPTY
41111: LIST
41112: LIST
41113: LIST
41114: PPUSH
41115: CALL_OW 72
41119: ST_TO_ADDR
41120: GO 41123
41122: POP
// if not tmp then
41123: LD_VAR 0 8
41127: NOT
41128: IFFALSE 41132
// exit ;
41130: GO 41634
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
41132: LD_VAR 0 4
41136: PUSH
41137: LD_INT 1
41139: PUSH
41140: LD_INT 15
41142: PUSH
41143: EMPTY
41144: LIST
41145: LIST
41146: IN
41147: PUSH
41148: LD_EXP 59
41152: PUSH
41153: LD_VAR 0 1
41157: ARRAY
41158: AND
41159: IFFALSE 41315
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
41161: LD_ADDR_VAR 0 9
41165: PUSH
41166: LD_EXP 59
41170: PUSH
41171: LD_VAR 0 1
41175: ARRAY
41176: PUSH
41177: LD_INT 1
41179: ARRAY
41180: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
41181: LD_VAR 0 9
41185: PUSH
41186: LD_EXP 60
41190: PUSH
41191: LD_VAR 0 1
41195: ARRAY
41196: IN
41197: NOT
41198: IFFALSE 41313
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
41200: LD_ADDR_EXP 60
41204: PUSH
41205: LD_EXP 60
41209: PPUSH
41210: LD_VAR 0 1
41214: PUSH
41215: LD_EXP 60
41219: PUSH
41220: LD_VAR 0 1
41224: ARRAY
41225: PUSH
41226: LD_INT 1
41228: PLUS
41229: PUSH
41230: EMPTY
41231: LIST
41232: LIST
41233: PPUSH
41234: LD_VAR 0 9
41238: PPUSH
41239: CALL 53789 0 3
41243: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
41244: LD_ADDR_EXP 59
41248: PUSH
41249: LD_EXP 59
41253: PPUSH
41254: LD_VAR 0 1
41258: PPUSH
41259: LD_EXP 59
41263: PUSH
41264: LD_VAR 0 1
41268: ARRAY
41269: PUSH
41270: LD_VAR 0 9
41274: DIFF
41275: PPUSH
41276: CALL_OW 1
41280: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
41281: LD_VAR 0 3
41285: PPUSH
41286: LD_EXP 60
41290: PUSH
41291: LD_VAR 0 1
41295: ARRAY
41296: PUSH
41297: LD_EXP 60
41301: PUSH
41302: LD_VAR 0 1
41306: ARRAY
41307: ARRAY
41308: PPUSH
41309: CALL_OW 120
// end ; exit ;
41313: GO 41634
// end ; if tmp > 1 then
41315: LD_VAR 0 8
41319: PUSH
41320: LD_INT 1
41322: GREATER
41323: IFFALSE 41427
// for i = 2 to tmp do
41325: LD_ADDR_VAR 0 6
41329: PUSH
41330: DOUBLE
41331: LD_INT 2
41333: DEC
41334: ST_TO_ADDR
41335: LD_VAR 0 8
41339: PUSH
41340: FOR_TO
41341: IFFALSE 41425
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
41343: LD_VAR 0 8
41347: PUSH
41348: LD_VAR 0 6
41352: ARRAY
41353: PPUSH
41354: CALL_OW 461
41358: PUSH
41359: LD_INT 6
41361: EQUAL
41362: IFFALSE 41423
// begin x := tmp [ i ] ;
41364: LD_ADDR_VAR 0 9
41368: PUSH
41369: LD_VAR 0 8
41373: PUSH
41374: LD_VAR 0 6
41378: ARRAY
41379: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
41380: LD_ADDR_VAR 0 8
41384: PUSH
41385: LD_VAR 0 8
41389: PPUSH
41390: LD_VAR 0 6
41394: PPUSH
41395: CALL_OW 3
41399: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
41400: LD_ADDR_VAR 0 8
41404: PUSH
41405: LD_VAR 0 8
41409: PPUSH
41410: LD_INT 1
41412: PPUSH
41413: LD_VAR 0 9
41417: PPUSH
41418: CALL_OW 2
41422: ST_TO_ADDR
// end ;
41423: GO 41340
41425: POP
41426: POP
// for i in tmp do
41427: LD_ADDR_VAR 0 6
41431: PUSH
41432: LD_VAR 0 8
41436: PUSH
41437: FOR_IN
41438: IFFALSE 41507
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
41440: LD_VAR 0 6
41444: PPUSH
41445: CALL_OW 313
41449: PUSH
41450: LD_INT 6
41452: LESS
41453: PUSH
41454: LD_VAR 0 6
41458: PPUSH
41459: CALL_OW 266
41463: PUSH
41464: LD_INT 31
41466: PUSH
41467: LD_INT 32
41469: PUSH
41470: EMPTY
41471: LIST
41472: LIST
41473: IN
41474: NOT
41475: AND
41476: PUSH
41477: LD_VAR 0 6
41481: PPUSH
41482: CALL_OW 313
41486: PUSH
41487: LD_INT 0
41489: EQUAL
41490: OR
41491: IFFALSE 41505
// begin j := i ;
41493: LD_ADDR_VAR 0 7
41497: PUSH
41498: LD_VAR 0 6
41502: ST_TO_ADDR
// break ;
41503: GO 41507
// end ; end ;
41505: GO 41437
41507: POP
41508: POP
// if j then
41509: LD_VAR 0 7
41513: IFFALSE 41531
// ComEnterUnit ( unit , j ) else
41515: LD_VAR 0 3
41519: PPUSH
41520: LD_VAR 0 7
41524: PPUSH
41525: CALL_OW 120
41529: GO 41634
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
41531: LD_ADDR_VAR 0 10
41535: PUSH
41536: LD_VAR 0 2
41540: PPUSH
41541: LD_INT 2
41543: PUSH
41544: LD_INT 30
41546: PUSH
41547: LD_INT 0
41549: PUSH
41550: EMPTY
41551: LIST
41552: LIST
41553: PUSH
41554: LD_INT 30
41556: PUSH
41557: LD_INT 1
41559: PUSH
41560: EMPTY
41561: LIST
41562: LIST
41563: PUSH
41564: EMPTY
41565: LIST
41566: LIST
41567: LIST
41568: PPUSH
41569: CALL_OW 72
41573: ST_TO_ADDR
// if depot then
41574: LD_VAR 0 10
41578: IFFALSE 41634
// begin depot := NearestUnitToUnit ( depot , unit ) ;
41580: LD_ADDR_VAR 0 10
41584: PUSH
41585: LD_VAR 0 10
41589: PPUSH
41590: LD_VAR 0 3
41594: PPUSH
41595: CALL_OW 74
41599: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
41600: LD_VAR 0 3
41604: PPUSH
41605: LD_VAR 0 10
41609: PPUSH
41610: CALL_OW 296
41614: PUSH
41615: LD_INT 10
41617: GREATER
41618: IFFALSE 41634
// ComStandNearbyBuilding ( unit , depot ) ;
41620: LD_VAR 0 3
41624: PPUSH
41625: LD_VAR 0 10
41629: PPUSH
41630: CALL 50216 0 2
// end ; end ; end ;
41634: LD_VAR 0 5
41638: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
41639: LD_INT 0
41641: PPUSH
41642: PPUSH
41643: PPUSH
41644: PPUSH
// if not mc_bases then
41645: LD_EXP 50
41649: NOT
41650: IFFALSE 41654
// exit ;
41652: GO 41893
// for i = 1 to mc_bases do
41654: LD_ADDR_VAR 0 2
41658: PUSH
41659: DOUBLE
41660: LD_INT 1
41662: DEC
41663: ST_TO_ADDR
41664: LD_EXP 50
41668: PUSH
41669: FOR_TO
41670: IFFALSE 41891
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
41672: LD_ADDR_VAR 0 4
41676: PUSH
41677: LD_EXP 50
41681: PUSH
41682: LD_VAR 0 2
41686: ARRAY
41687: PPUSH
41688: LD_INT 21
41690: PUSH
41691: LD_INT 1
41693: PUSH
41694: EMPTY
41695: LIST
41696: LIST
41697: PPUSH
41698: CALL_OW 72
41702: PUSH
41703: LD_EXP 79
41707: PUSH
41708: LD_VAR 0 2
41712: ARRAY
41713: UNION
41714: ST_TO_ADDR
// if not tmp then
41715: LD_VAR 0 4
41719: NOT
41720: IFFALSE 41724
// continue ;
41722: GO 41669
// for j in tmp do
41724: LD_ADDR_VAR 0 3
41728: PUSH
41729: LD_VAR 0 4
41733: PUSH
41734: FOR_IN
41735: IFFALSE 41887
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
41737: LD_VAR 0 3
41741: PPUSH
41742: CALL_OW 110
41746: NOT
41747: PUSH
41748: LD_VAR 0 3
41752: PPUSH
41753: CALL_OW 314
41757: NOT
41758: AND
41759: PUSH
41760: LD_VAR 0 3
41764: PPUSH
41765: CALL_OW 311
41769: NOT
41770: AND
41771: PUSH
41772: LD_VAR 0 3
41776: PPUSH
41777: CALL_OW 310
41781: NOT
41782: AND
41783: PUSH
41784: LD_VAR 0 3
41788: PUSH
41789: LD_EXP 53
41793: PUSH
41794: LD_VAR 0 2
41798: ARRAY
41799: PUSH
41800: LD_INT 1
41802: ARRAY
41803: IN
41804: NOT
41805: AND
41806: PUSH
41807: LD_VAR 0 3
41811: PUSH
41812: LD_EXP 53
41816: PUSH
41817: LD_VAR 0 2
41821: ARRAY
41822: PUSH
41823: LD_INT 2
41825: ARRAY
41826: IN
41827: NOT
41828: AND
41829: PUSH
41830: LD_VAR 0 3
41834: PUSH
41835: LD_EXP 62
41839: PUSH
41840: LD_VAR 0 2
41844: ARRAY
41845: IN
41846: NOT
41847: AND
41848: IFFALSE 41885
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
41850: LD_VAR 0 2
41854: PPUSH
41855: LD_EXP 50
41859: PUSH
41860: LD_VAR 0 2
41864: ARRAY
41865: PPUSH
41866: LD_VAR 0 3
41870: PPUSH
41871: LD_VAR 0 3
41875: PPUSH
41876: CALL_OW 257
41880: PPUSH
41881: CALL 40657 0 4
// end ;
41885: GO 41734
41887: POP
41888: POP
// end ;
41889: GO 41669
41891: POP
41892: POP
// end ;
41893: LD_VAR 0 1
41897: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
41898: LD_INT 0
41900: PPUSH
41901: PPUSH
41902: PPUSH
41903: PPUSH
41904: PPUSH
41905: PPUSH
// if not mc_bases [ base ] then
41906: LD_EXP 50
41910: PUSH
41911: LD_VAR 0 1
41915: ARRAY
41916: NOT
41917: IFFALSE 41921
// exit ;
41919: GO 42103
// tmp := [ ] ;
41921: LD_ADDR_VAR 0 6
41925: PUSH
41926: EMPTY
41927: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
41928: LD_ADDR_VAR 0 7
41932: PUSH
41933: LD_VAR 0 3
41937: PPUSH
41938: LD_INT 0
41940: PPUSH
41941: CALL_OW 517
41945: ST_TO_ADDR
// if not list then
41946: LD_VAR 0 7
41950: NOT
41951: IFFALSE 41955
// exit ;
41953: GO 42103
// for i = 1 to amount do
41955: LD_ADDR_VAR 0 5
41959: PUSH
41960: DOUBLE
41961: LD_INT 1
41963: DEC
41964: ST_TO_ADDR
41965: LD_VAR 0 2
41969: PUSH
41970: FOR_TO
41971: IFFALSE 42051
// begin x := rand ( 1 , list [ 1 ] ) ;
41973: LD_ADDR_VAR 0 8
41977: PUSH
41978: LD_INT 1
41980: PPUSH
41981: LD_VAR 0 7
41985: PUSH
41986: LD_INT 1
41988: ARRAY
41989: PPUSH
41990: CALL_OW 12
41994: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
41995: LD_ADDR_VAR 0 6
41999: PUSH
42000: LD_VAR 0 6
42004: PPUSH
42005: LD_VAR 0 5
42009: PPUSH
42010: LD_VAR 0 7
42014: PUSH
42015: LD_INT 1
42017: ARRAY
42018: PUSH
42019: LD_VAR 0 8
42023: ARRAY
42024: PUSH
42025: LD_VAR 0 7
42029: PUSH
42030: LD_INT 2
42032: ARRAY
42033: PUSH
42034: LD_VAR 0 8
42038: ARRAY
42039: PUSH
42040: EMPTY
42041: LIST
42042: LIST
42043: PPUSH
42044: CALL_OW 1
42048: ST_TO_ADDR
// end ;
42049: GO 41970
42051: POP
42052: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
42053: LD_ADDR_EXP 63
42057: PUSH
42058: LD_EXP 63
42062: PPUSH
42063: LD_VAR 0 1
42067: PPUSH
42068: LD_VAR 0 6
42072: PPUSH
42073: CALL_OW 1
42077: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
42078: LD_ADDR_EXP 65
42082: PUSH
42083: LD_EXP 65
42087: PPUSH
42088: LD_VAR 0 1
42092: PPUSH
42093: LD_VAR 0 3
42097: PPUSH
42098: CALL_OW 1
42102: ST_TO_ADDR
// end ;
42103: LD_VAR 0 4
42107: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
42108: LD_INT 0
42110: PPUSH
// if not mc_bases [ base ] then
42111: LD_EXP 50
42115: PUSH
42116: LD_VAR 0 1
42120: ARRAY
42121: NOT
42122: IFFALSE 42126
// exit ;
42124: GO 42151
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
42126: LD_ADDR_EXP 55
42130: PUSH
42131: LD_EXP 55
42135: PPUSH
42136: LD_VAR 0 1
42140: PPUSH
42141: LD_VAR 0 2
42145: PPUSH
42146: CALL_OW 1
42150: ST_TO_ADDR
// end ;
42151: LD_VAR 0 3
42155: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
42156: LD_INT 0
42158: PPUSH
// if not mc_bases [ base ] then
42159: LD_EXP 50
42163: PUSH
42164: LD_VAR 0 1
42168: ARRAY
42169: NOT
42170: IFFALSE 42174
// exit ;
42172: GO 42211
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
42174: LD_ADDR_EXP 55
42178: PUSH
42179: LD_EXP 55
42183: PPUSH
42184: LD_VAR 0 1
42188: PPUSH
42189: LD_EXP 55
42193: PUSH
42194: LD_VAR 0 1
42198: ARRAY
42199: PUSH
42200: LD_VAR 0 2
42204: UNION
42205: PPUSH
42206: CALL_OW 1
42210: ST_TO_ADDR
// end ;
42211: LD_VAR 0 3
42215: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
42216: LD_INT 0
42218: PPUSH
// if not mc_bases [ base ] then
42219: LD_EXP 50
42223: PUSH
42224: LD_VAR 0 1
42228: ARRAY
42229: NOT
42230: IFFALSE 42234
// exit ;
42232: GO 42259
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
42234: LD_ADDR_EXP 71
42238: PUSH
42239: LD_EXP 71
42243: PPUSH
42244: LD_VAR 0 1
42248: PPUSH
42249: LD_VAR 0 2
42253: PPUSH
42254: CALL_OW 1
42258: ST_TO_ADDR
// end ;
42259: LD_VAR 0 3
42263: RET
// export function MC_InsertProduceList ( base , components ) ; begin
42264: LD_INT 0
42266: PPUSH
// if not mc_bases [ base ] then
42267: LD_EXP 50
42271: PUSH
42272: LD_VAR 0 1
42276: ARRAY
42277: NOT
42278: IFFALSE 42282
// exit ;
42280: GO 42319
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
42282: LD_ADDR_EXP 71
42286: PUSH
42287: LD_EXP 71
42291: PPUSH
42292: LD_VAR 0 1
42296: PPUSH
42297: LD_EXP 71
42301: PUSH
42302: LD_VAR 0 1
42306: ARRAY
42307: PUSH
42308: LD_VAR 0 2
42312: ADD
42313: PPUSH
42314: CALL_OW 1
42318: ST_TO_ADDR
// end ;
42319: LD_VAR 0 3
42323: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
42324: LD_INT 0
42326: PPUSH
// if not mc_bases [ base ] then
42327: LD_EXP 50
42331: PUSH
42332: LD_VAR 0 1
42336: ARRAY
42337: NOT
42338: IFFALSE 42342
// exit ;
42340: GO 42396
// mc_defender := Replace ( mc_defender , base , deflist ) ;
42342: LD_ADDR_EXP 72
42346: PUSH
42347: LD_EXP 72
42351: PPUSH
42352: LD_VAR 0 1
42356: PPUSH
42357: LD_VAR 0 2
42361: PPUSH
42362: CALL_OW 1
42366: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
42367: LD_ADDR_EXP 61
42371: PUSH
42372: LD_EXP 61
42376: PPUSH
42377: LD_VAR 0 1
42381: PPUSH
42382: LD_VAR 0 2
42386: PUSH
42387: LD_INT 0
42389: PLUS
42390: PPUSH
42391: CALL_OW 1
42395: ST_TO_ADDR
// end ;
42396: LD_VAR 0 3
42400: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
42401: LD_INT 0
42403: PPUSH
// if not mc_bases [ base ] then
42404: LD_EXP 50
42408: PUSH
42409: LD_VAR 0 1
42413: ARRAY
42414: NOT
42415: IFFALSE 42419
// exit ;
42417: GO 42444
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
42419: LD_ADDR_EXP 61
42423: PUSH
42424: LD_EXP 61
42428: PPUSH
42429: LD_VAR 0 1
42433: PPUSH
42434: LD_VAR 0 2
42438: PPUSH
42439: CALL_OW 1
42443: ST_TO_ADDR
// end ;
42444: LD_VAR 0 3
42448: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
42449: LD_INT 0
42451: PPUSH
42452: PPUSH
42453: PPUSH
42454: PPUSH
// if not mc_bases [ base ] then
42455: LD_EXP 50
42459: PUSH
42460: LD_VAR 0 1
42464: ARRAY
42465: NOT
42466: IFFALSE 42470
// exit ;
42468: GO 42535
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
42470: LD_ADDR_EXP 70
42474: PUSH
42475: LD_EXP 70
42479: PPUSH
42480: LD_VAR 0 1
42484: PUSH
42485: LD_EXP 70
42489: PUSH
42490: LD_VAR 0 1
42494: ARRAY
42495: PUSH
42496: LD_INT 1
42498: PLUS
42499: PUSH
42500: EMPTY
42501: LIST
42502: LIST
42503: PPUSH
42504: LD_VAR 0 1
42508: PUSH
42509: LD_VAR 0 2
42513: PUSH
42514: LD_VAR 0 3
42518: PUSH
42519: LD_VAR 0 4
42523: PUSH
42524: EMPTY
42525: LIST
42526: LIST
42527: LIST
42528: LIST
42529: PPUSH
42530: CALL 53789 0 3
42534: ST_TO_ADDR
// end ;
42535: LD_VAR 0 5
42539: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
42540: LD_INT 0
42542: PPUSH
// if not mc_bases [ base ] then
42543: LD_EXP 50
42547: PUSH
42548: LD_VAR 0 1
42552: ARRAY
42553: NOT
42554: IFFALSE 42558
// exit ;
42556: GO 42583
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
42558: LD_ADDR_EXP 87
42562: PUSH
42563: LD_EXP 87
42567: PPUSH
42568: LD_VAR 0 1
42572: PPUSH
42573: LD_VAR 0 2
42577: PPUSH
42578: CALL_OW 1
42582: ST_TO_ADDR
// end ;
42583: LD_VAR 0 3
42587: RET
// export function MC_GetMinesField ( base ) ; begin
42588: LD_INT 0
42590: PPUSH
// result := mc_mines [ base ] ;
42591: LD_ADDR_VAR 0 2
42595: PUSH
42596: LD_EXP 63
42600: PUSH
42601: LD_VAR 0 1
42605: ARRAY
42606: ST_TO_ADDR
// end ;
42607: LD_VAR 0 2
42611: RET
// export function MC_GetProduceList ( base ) ; begin
42612: LD_INT 0
42614: PPUSH
// result := mc_produce [ base ] ;
42615: LD_ADDR_VAR 0 2
42619: PUSH
42620: LD_EXP 71
42624: PUSH
42625: LD_VAR 0 1
42629: ARRAY
42630: ST_TO_ADDR
// end ;
42631: LD_VAR 0 2
42635: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
42636: LD_INT 0
42638: PPUSH
42639: PPUSH
// if not mc_bases then
42640: LD_EXP 50
42644: NOT
42645: IFFALSE 42649
// exit ;
42647: GO 42714
// if mc_bases [ base ] then
42649: LD_EXP 50
42653: PUSH
42654: LD_VAR 0 1
42658: ARRAY
42659: IFFALSE 42714
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
42661: LD_ADDR_VAR 0 3
42665: PUSH
42666: LD_EXP 50
42670: PUSH
42671: LD_VAR 0 1
42675: ARRAY
42676: PPUSH
42677: LD_INT 30
42679: PUSH
42680: LD_VAR 0 2
42684: PUSH
42685: EMPTY
42686: LIST
42687: LIST
42688: PPUSH
42689: CALL_OW 72
42693: ST_TO_ADDR
// if result then
42694: LD_VAR 0 3
42698: IFFALSE 42714
// result := result [ 1 ] ;
42700: LD_ADDR_VAR 0 3
42704: PUSH
42705: LD_VAR 0 3
42709: PUSH
42710: LD_INT 1
42712: ARRAY
42713: ST_TO_ADDR
// end ; end ;
42714: LD_VAR 0 3
42718: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
42719: LD_INT 0
42721: PPUSH
42722: PPUSH
// if not mc_bases then
42723: LD_EXP 50
42727: NOT
42728: IFFALSE 42732
// exit ;
42730: GO 42777
// if mc_bases [ base ] then
42732: LD_EXP 50
42736: PUSH
42737: LD_VAR 0 1
42741: ARRAY
42742: IFFALSE 42777
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
42744: LD_ADDR_VAR 0 3
42748: PUSH
42749: LD_EXP 50
42753: PUSH
42754: LD_VAR 0 1
42758: ARRAY
42759: PPUSH
42760: LD_INT 30
42762: PUSH
42763: LD_VAR 0 2
42767: PUSH
42768: EMPTY
42769: LIST
42770: LIST
42771: PPUSH
42772: CALL_OW 72
42776: ST_TO_ADDR
// end ;
42777: LD_VAR 0 3
42781: RET
// export function MC_SetTame ( base , area ) ; begin
42782: LD_INT 0
42784: PPUSH
// if not mc_bases or not base then
42785: LD_EXP 50
42789: NOT
42790: PUSH
42791: LD_VAR 0 1
42795: NOT
42796: OR
42797: IFFALSE 42801
// exit ;
42799: GO 42826
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
42801: LD_ADDR_EXP 78
42805: PUSH
42806: LD_EXP 78
42810: PPUSH
42811: LD_VAR 0 1
42815: PPUSH
42816: LD_VAR 0 2
42820: PPUSH
42821: CALL_OW 1
42825: ST_TO_ADDR
// end ;
42826: LD_VAR 0 3
42830: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
42831: LD_INT 0
42833: PPUSH
42834: PPUSH
// if not mc_bases or not base then
42835: LD_EXP 50
42839: NOT
42840: PUSH
42841: LD_VAR 0 1
42845: NOT
42846: OR
42847: IFFALSE 42851
// exit ;
42849: GO 42953
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
42851: LD_ADDR_VAR 0 4
42855: PUSH
42856: LD_EXP 50
42860: PUSH
42861: LD_VAR 0 1
42865: ARRAY
42866: PPUSH
42867: LD_INT 30
42869: PUSH
42870: LD_VAR 0 2
42874: PUSH
42875: EMPTY
42876: LIST
42877: LIST
42878: PPUSH
42879: CALL_OW 72
42883: ST_TO_ADDR
// if not tmp then
42884: LD_VAR 0 4
42888: NOT
42889: IFFALSE 42893
// exit ;
42891: GO 42953
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
42893: LD_ADDR_EXP 82
42897: PUSH
42898: LD_EXP 82
42902: PPUSH
42903: LD_VAR 0 1
42907: PPUSH
42908: LD_EXP 82
42912: PUSH
42913: LD_VAR 0 1
42917: ARRAY
42918: PPUSH
42919: LD_EXP 82
42923: PUSH
42924: LD_VAR 0 1
42928: ARRAY
42929: PUSH
42930: LD_INT 1
42932: PLUS
42933: PPUSH
42934: LD_VAR 0 4
42938: PUSH
42939: LD_INT 1
42941: ARRAY
42942: PPUSH
42943: CALL_OW 2
42947: PPUSH
42948: CALL_OW 1
42952: ST_TO_ADDR
// end ;
42953: LD_VAR 0 3
42957: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
42958: LD_INT 0
42960: PPUSH
42961: PPUSH
// if not mc_bases or not base or not kinds then
42962: LD_EXP 50
42966: NOT
42967: PUSH
42968: LD_VAR 0 1
42972: NOT
42973: OR
42974: PUSH
42975: LD_VAR 0 2
42979: NOT
42980: OR
42981: IFFALSE 42985
// exit ;
42983: GO 43046
// for i in kinds do
42985: LD_ADDR_VAR 0 4
42989: PUSH
42990: LD_VAR 0 2
42994: PUSH
42995: FOR_IN
42996: IFFALSE 43044
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
42998: LD_ADDR_EXP 84
43002: PUSH
43003: LD_EXP 84
43007: PPUSH
43008: LD_VAR 0 1
43012: PUSH
43013: LD_EXP 84
43017: PUSH
43018: LD_VAR 0 1
43022: ARRAY
43023: PUSH
43024: LD_INT 1
43026: PLUS
43027: PUSH
43028: EMPTY
43029: LIST
43030: LIST
43031: PPUSH
43032: LD_VAR 0 4
43036: PPUSH
43037: CALL 53789 0 3
43041: ST_TO_ADDR
43042: GO 42995
43044: POP
43045: POP
// end ;
43046: LD_VAR 0 3
43050: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
43051: LD_INT 0
43053: PPUSH
// if not mc_bases or not base or not areas then
43054: LD_EXP 50
43058: NOT
43059: PUSH
43060: LD_VAR 0 1
43064: NOT
43065: OR
43066: PUSH
43067: LD_VAR 0 2
43071: NOT
43072: OR
43073: IFFALSE 43077
// exit ;
43075: GO 43102
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
43077: LD_ADDR_EXP 68
43081: PUSH
43082: LD_EXP 68
43086: PPUSH
43087: LD_VAR 0 1
43091: PPUSH
43092: LD_VAR 0 2
43096: PPUSH
43097: CALL_OW 1
43101: ST_TO_ADDR
// end ;
43102: LD_VAR 0 3
43106: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
43107: LD_INT 0
43109: PPUSH
// if not mc_bases or not base or not teleports_exit then
43110: LD_EXP 50
43114: NOT
43115: PUSH
43116: LD_VAR 0 1
43120: NOT
43121: OR
43122: PUSH
43123: LD_VAR 0 2
43127: NOT
43128: OR
43129: IFFALSE 43133
// exit ;
43131: GO 43158
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
43133: LD_ADDR_EXP 85
43137: PUSH
43138: LD_EXP 85
43142: PPUSH
43143: LD_VAR 0 1
43147: PPUSH
43148: LD_VAR 0 2
43152: PPUSH
43153: CALL_OW 1
43157: ST_TO_ADDR
// end ;
43158: LD_VAR 0 3
43162: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
43163: LD_INT 0
43165: PPUSH
43166: PPUSH
43167: PPUSH
// if not mc_bases or not base or not ext_list then
43168: LD_EXP 50
43172: NOT
43173: PUSH
43174: LD_VAR 0 1
43178: NOT
43179: OR
43180: PUSH
43181: LD_VAR 0 5
43185: NOT
43186: OR
43187: IFFALSE 43191
// exit ;
43189: GO 43364
// tmp := GetFacExtXYD ( x , y , d ) ;
43191: LD_ADDR_VAR 0 8
43195: PUSH
43196: LD_VAR 0 2
43200: PPUSH
43201: LD_VAR 0 3
43205: PPUSH
43206: LD_VAR 0 4
43210: PPUSH
43211: CALL 83740 0 3
43215: ST_TO_ADDR
// if not tmp then
43216: LD_VAR 0 8
43220: NOT
43221: IFFALSE 43225
// exit ;
43223: GO 43364
// for i in tmp do
43225: LD_ADDR_VAR 0 7
43229: PUSH
43230: LD_VAR 0 8
43234: PUSH
43235: FOR_IN
43236: IFFALSE 43362
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
43238: LD_ADDR_EXP 55
43242: PUSH
43243: LD_EXP 55
43247: PPUSH
43248: LD_VAR 0 1
43252: PPUSH
43253: LD_EXP 55
43257: PUSH
43258: LD_VAR 0 1
43262: ARRAY
43263: PPUSH
43264: LD_EXP 55
43268: PUSH
43269: LD_VAR 0 1
43273: ARRAY
43274: PUSH
43275: LD_INT 1
43277: PLUS
43278: PPUSH
43279: LD_VAR 0 5
43283: PUSH
43284: LD_INT 1
43286: ARRAY
43287: PUSH
43288: LD_VAR 0 7
43292: PUSH
43293: LD_INT 1
43295: ARRAY
43296: PUSH
43297: LD_VAR 0 7
43301: PUSH
43302: LD_INT 2
43304: ARRAY
43305: PUSH
43306: LD_VAR 0 7
43310: PUSH
43311: LD_INT 3
43313: ARRAY
43314: PUSH
43315: EMPTY
43316: LIST
43317: LIST
43318: LIST
43319: LIST
43320: PPUSH
43321: CALL_OW 2
43325: PPUSH
43326: CALL_OW 1
43330: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
43331: LD_ADDR_VAR 0 5
43335: PUSH
43336: LD_VAR 0 5
43340: PPUSH
43341: LD_INT 1
43343: PPUSH
43344: CALL_OW 3
43348: ST_TO_ADDR
// if not ext_list then
43349: LD_VAR 0 5
43353: NOT
43354: IFFALSE 43360
// exit ;
43356: POP
43357: POP
43358: GO 43364
// end ;
43360: GO 43235
43362: POP
43363: POP
// end ;
43364: LD_VAR 0 6
43368: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
43369: LD_INT 0
43371: PPUSH
// if not mc_bases or not base or not weapon_list then
43372: LD_EXP 50
43376: NOT
43377: PUSH
43378: LD_VAR 0 1
43382: NOT
43383: OR
43384: PUSH
43385: LD_VAR 0 2
43389: NOT
43390: OR
43391: IFFALSE 43395
// exit ;
43393: GO 43420
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
43395: LD_ADDR_EXP 89
43399: PUSH
43400: LD_EXP 89
43404: PPUSH
43405: LD_VAR 0 1
43409: PPUSH
43410: LD_VAR 0 2
43414: PPUSH
43415: CALL_OW 1
43419: ST_TO_ADDR
// end ;
43420: LD_VAR 0 3
43424: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
43425: LD_INT 0
43427: PPUSH
// if not mc_bases or not base or not tech_list then
43428: LD_EXP 50
43432: NOT
43433: PUSH
43434: LD_VAR 0 1
43438: NOT
43439: OR
43440: PUSH
43441: LD_VAR 0 2
43445: NOT
43446: OR
43447: IFFALSE 43451
// exit ;
43449: GO 43476
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
43451: LD_ADDR_EXP 77
43455: PUSH
43456: LD_EXP 77
43460: PPUSH
43461: LD_VAR 0 1
43465: PPUSH
43466: LD_VAR 0 2
43470: PPUSH
43471: CALL_OW 1
43475: ST_TO_ADDR
// end ;
43476: LD_VAR 0 3
43480: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
43481: LD_INT 0
43483: PPUSH
// if not mc_bases or not parking_area or not base then
43484: LD_EXP 50
43488: NOT
43489: PUSH
43490: LD_VAR 0 2
43494: NOT
43495: OR
43496: PUSH
43497: LD_VAR 0 1
43501: NOT
43502: OR
43503: IFFALSE 43507
// exit ;
43505: GO 43532
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
43507: LD_ADDR_EXP 74
43511: PUSH
43512: LD_EXP 74
43516: PPUSH
43517: LD_VAR 0 1
43521: PPUSH
43522: LD_VAR 0 2
43526: PPUSH
43527: CALL_OW 1
43531: ST_TO_ADDR
// end ;
43532: LD_VAR 0 3
43536: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
43537: LD_INT 0
43539: PPUSH
// if not mc_bases or not base or not scan_area then
43540: LD_EXP 50
43544: NOT
43545: PUSH
43546: LD_VAR 0 1
43550: NOT
43551: OR
43552: PUSH
43553: LD_VAR 0 2
43557: NOT
43558: OR
43559: IFFALSE 43563
// exit ;
43561: GO 43588
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
43563: LD_ADDR_EXP 75
43567: PUSH
43568: LD_EXP 75
43572: PPUSH
43573: LD_VAR 0 1
43577: PPUSH
43578: LD_VAR 0 2
43582: PPUSH
43583: CALL_OW 1
43587: ST_TO_ADDR
// end ;
43588: LD_VAR 0 3
43592: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
43593: LD_INT 0
43595: PPUSH
43596: PPUSH
// if not mc_bases or not base then
43597: LD_EXP 50
43601: NOT
43602: PUSH
43603: LD_VAR 0 1
43607: NOT
43608: OR
43609: IFFALSE 43613
// exit ;
43611: GO 43677
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
43613: LD_ADDR_VAR 0 3
43617: PUSH
43618: LD_INT 1
43620: PUSH
43621: LD_INT 2
43623: PUSH
43624: LD_INT 3
43626: PUSH
43627: LD_INT 4
43629: PUSH
43630: LD_INT 11
43632: PUSH
43633: EMPTY
43634: LIST
43635: LIST
43636: LIST
43637: LIST
43638: LIST
43639: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
43640: LD_ADDR_EXP 77
43644: PUSH
43645: LD_EXP 77
43649: PPUSH
43650: LD_VAR 0 1
43654: PPUSH
43655: LD_EXP 77
43659: PUSH
43660: LD_VAR 0 1
43664: ARRAY
43665: PUSH
43666: LD_VAR 0 3
43670: DIFF
43671: PPUSH
43672: CALL_OW 1
43676: ST_TO_ADDR
// end ;
43677: LD_VAR 0 2
43681: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
43682: LD_INT 0
43684: PPUSH
// result := mc_vehicles [ base ] ;
43685: LD_ADDR_VAR 0 3
43689: PUSH
43690: LD_EXP 69
43694: PUSH
43695: LD_VAR 0 1
43699: ARRAY
43700: ST_TO_ADDR
// if onlyCombat then
43701: LD_VAR 0 2
43705: IFFALSE 43877
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
43707: LD_ADDR_VAR 0 3
43711: PUSH
43712: LD_VAR 0 3
43716: PUSH
43717: LD_VAR 0 3
43721: PPUSH
43722: LD_INT 2
43724: PUSH
43725: LD_INT 34
43727: PUSH
43728: LD_INT 12
43730: PUSH
43731: EMPTY
43732: LIST
43733: LIST
43734: PUSH
43735: LD_INT 34
43737: PUSH
43738: LD_INT 51
43740: PUSH
43741: EMPTY
43742: LIST
43743: LIST
43744: PUSH
43745: LD_INT 34
43747: PUSH
43748: LD_INT 89
43750: PUSH
43751: EMPTY
43752: LIST
43753: LIST
43754: PUSH
43755: LD_INT 34
43757: PUSH
43758: LD_INT 32
43760: PUSH
43761: EMPTY
43762: LIST
43763: LIST
43764: PUSH
43765: LD_INT 34
43767: PUSH
43768: LD_INT 13
43770: PUSH
43771: EMPTY
43772: LIST
43773: LIST
43774: PUSH
43775: LD_INT 34
43777: PUSH
43778: LD_INT 52
43780: PUSH
43781: EMPTY
43782: LIST
43783: LIST
43784: PUSH
43785: LD_INT 34
43787: PUSH
43788: LD_INT 88
43790: PUSH
43791: EMPTY
43792: LIST
43793: LIST
43794: PUSH
43795: LD_INT 34
43797: PUSH
43798: LD_INT 14
43800: PUSH
43801: EMPTY
43802: LIST
43803: LIST
43804: PUSH
43805: LD_INT 34
43807: PUSH
43808: LD_INT 53
43810: PUSH
43811: EMPTY
43812: LIST
43813: LIST
43814: PUSH
43815: LD_INT 34
43817: PUSH
43818: LD_INT 98
43820: PUSH
43821: EMPTY
43822: LIST
43823: LIST
43824: PUSH
43825: LD_INT 34
43827: PUSH
43828: LD_INT 31
43830: PUSH
43831: EMPTY
43832: LIST
43833: LIST
43834: PUSH
43835: LD_INT 34
43837: PUSH
43838: LD_INT 48
43840: PUSH
43841: EMPTY
43842: LIST
43843: LIST
43844: PUSH
43845: LD_INT 34
43847: PUSH
43848: LD_INT 8
43850: PUSH
43851: EMPTY
43852: LIST
43853: LIST
43854: PUSH
43855: EMPTY
43856: LIST
43857: LIST
43858: LIST
43859: LIST
43860: LIST
43861: LIST
43862: LIST
43863: LIST
43864: LIST
43865: LIST
43866: LIST
43867: LIST
43868: LIST
43869: LIST
43870: PPUSH
43871: CALL_OW 72
43875: DIFF
43876: ST_TO_ADDR
// end ; end_of_file
43877: LD_VAR 0 3
43881: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
43882: LD_INT 0
43884: PPUSH
43885: PPUSH
43886: PPUSH
// if not mc_bases or not skirmish then
43887: LD_EXP 50
43891: NOT
43892: PUSH
43893: LD_EXP 48
43897: NOT
43898: OR
43899: IFFALSE 43903
// exit ;
43901: GO 44068
// for i = 1 to mc_bases do
43903: LD_ADDR_VAR 0 4
43907: PUSH
43908: DOUBLE
43909: LD_INT 1
43911: DEC
43912: ST_TO_ADDR
43913: LD_EXP 50
43917: PUSH
43918: FOR_TO
43919: IFFALSE 44066
// begin if sci in mc_bases [ i ] then
43921: LD_VAR 0 2
43925: PUSH
43926: LD_EXP 50
43930: PUSH
43931: LD_VAR 0 4
43935: ARRAY
43936: IN
43937: IFFALSE 44064
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
43939: LD_ADDR_EXP 79
43943: PUSH
43944: LD_EXP 79
43948: PPUSH
43949: LD_VAR 0 4
43953: PUSH
43954: LD_EXP 79
43958: PUSH
43959: LD_VAR 0 4
43963: ARRAY
43964: PUSH
43965: LD_INT 1
43967: PLUS
43968: PUSH
43969: EMPTY
43970: LIST
43971: LIST
43972: PPUSH
43973: LD_VAR 0 1
43977: PPUSH
43978: CALL 53789 0 3
43982: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
43983: LD_ADDR_VAR 0 5
43987: PUSH
43988: LD_EXP 50
43992: PUSH
43993: LD_VAR 0 4
43997: ARRAY
43998: PPUSH
43999: LD_INT 2
44001: PUSH
44002: LD_INT 30
44004: PUSH
44005: LD_INT 0
44007: PUSH
44008: EMPTY
44009: LIST
44010: LIST
44011: PUSH
44012: LD_INT 30
44014: PUSH
44015: LD_INT 1
44017: PUSH
44018: EMPTY
44019: LIST
44020: LIST
44021: PUSH
44022: EMPTY
44023: LIST
44024: LIST
44025: LIST
44026: PPUSH
44027: CALL_OW 72
44031: PPUSH
44032: LD_VAR 0 1
44036: PPUSH
44037: CALL_OW 74
44041: ST_TO_ADDR
// if tmp then
44042: LD_VAR 0 5
44046: IFFALSE 44062
// ComStandNearbyBuilding ( ape , tmp ) ;
44048: LD_VAR 0 1
44052: PPUSH
44053: LD_VAR 0 5
44057: PPUSH
44058: CALL 50216 0 2
// break ;
44062: GO 44066
// end ; end ;
44064: GO 43918
44066: POP
44067: POP
// end ;
44068: LD_VAR 0 3
44072: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
44073: LD_INT 0
44075: PPUSH
44076: PPUSH
44077: PPUSH
// if not mc_bases or not skirmish then
44078: LD_EXP 50
44082: NOT
44083: PUSH
44084: LD_EXP 48
44088: NOT
44089: OR
44090: IFFALSE 44094
// exit ;
44092: GO 44183
// for i = 1 to mc_bases do
44094: LD_ADDR_VAR 0 4
44098: PUSH
44099: DOUBLE
44100: LD_INT 1
44102: DEC
44103: ST_TO_ADDR
44104: LD_EXP 50
44108: PUSH
44109: FOR_TO
44110: IFFALSE 44181
// begin if building in mc_busy_turret_list [ i ] then
44112: LD_VAR 0 1
44116: PUSH
44117: LD_EXP 60
44121: PUSH
44122: LD_VAR 0 4
44126: ARRAY
44127: IN
44128: IFFALSE 44179
// begin tmp := mc_busy_turret_list [ i ] diff building ;
44130: LD_ADDR_VAR 0 5
44134: PUSH
44135: LD_EXP 60
44139: PUSH
44140: LD_VAR 0 4
44144: ARRAY
44145: PUSH
44146: LD_VAR 0 1
44150: DIFF
44151: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
44152: LD_ADDR_EXP 60
44156: PUSH
44157: LD_EXP 60
44161: PPUSH
44162: LD_VAR 0 4
44166: PPUSH
44167: LD_VAR 0 5
44171: PPUSH
44172: CALL_OW 1
44176: ST_TO_ADDR
// break ;
44177: GO 44181
// end ; end ;
44179: GO 44109
44181: POP
44182: POP
// end ;
44183: LD_VAR 0 3
44187: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
44188: LD_INT 0
44190: PPUSH
44191: PPUSH
44192: PPUSH
// if not mc_bases or not skirmish then
44193: LD_EXP 50
44197: NOT
44198: PUSH
44199: LD_EXP 48
44203: NOT
44204: OR
44205: IFFALSE 44209
// exit ;
44207: GO 44408
// for i = 1 to mc_bases do
44209: LD_ADDR_VAR 0 5
44213: PUSH
44214: DOUBLE
44215: LD_INT 1
44217: DEC
44218: ST_TO_ADDR
44219: LD_EXP 50
44223: PUSH
44224: FOR_TO
44225: IFFALSE 44406
// if building in mc_bases [ i ] then
44227: LD_VAR 0 1
44231: PUSH
44232: LD_EXP 50
44236: PUSH
44237: LD_VAR 0 5
44241: ARRAY
44242: IN
44243: IFFALSE 44404
// begin tmp := mc_bases [ i ] diff building ;
44245: LD_ADDR_VAR 0 6
44249: PUSH
44250: LD_EXP 50
44254: PUSH
44255: LD_VAR 0 5
44259: ARRAY
44260: PUSH
44261: LD_VAR 0 1
44265: DIFF
44266: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
44267: LD_ADDR_EXP 50
44271: PUSH
44272: LD_EXP 50
44276: PPUSH
44277: LD_VAR 0 5
44281: PPUSH
44282: LD_VAR 0 6
44286: PPUSH
44287: CALL_OW 1
44291: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
44292: LD_VAR 0 1
44296: PUSH
44297: LD_EXP 58
44301: PUSH
44302: LD_VAR 0 5
44306: ARRAY
44307: IN
44308: IFFALSE 44347
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
44310: LD_ADDR_EXP 58
44314: PUSH
44315: LD_EXP 58
44319: PPUSH
44320: LD_VAR 0 5
44324: PPUSH
44325: LD_EXP 58
44329: PUSH
44330: LD_VAR 0 5
44334: ARRAY
44335: PUSH
44336: LD_VAR 0 1
44340: DIFF
44341: PPUSH
44342: CALL_OW 1
44346: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
44347: LD_VAR 0 1
44351: PUSH
44352: LD_EXP 59
44356: PUSH
44357: LD_VAR 0 5
44361: ARRAY
44362: IN
44363: IFFALSE 44402
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
44365: LD_ADDR_EXP 59
44369: PUSH
44370: LD_EXP 59
44374: PPUSH
44375: LD_VAR 0 5
44379: PPUSH
44380: LD_EXP 59
44384: PUSH
44385: LD_VAR 0 5
44389: ARRAY
44390: PUSH
44391: LD_VAR 0 1
44395: DIFF
44396: PPUSH
44397: CALL_OW 1
44401: ST_TO_ADDR
// break ;
44402: GO 44406
// end ;
44404: GO 44224
44406: POP
44407: POP
// end ;
44408: LD_VAR 0 4
44412: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
44413: LD_INT 0
44415: PPUSH
44416: PPUSH
44417: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
44418: LD_EXP 50
44422: NOT
44423: PUSH
44424: LD_EXP 48
44428: NOT
44429: OR
44430: PUSH
44431: LD_VAR 0 3
44435: PUSH
44436: LD_EXP 76
44440: IN
44441: NOT
44442: OR
44443: IFFALSE 44447
// exit ;
44445: GO 44570
// for i = 1 to mc_vehicles do
44447: LD_ADDR_VAR 0 6
44451: PUSH
44452: DOUBLE
44453: LD_INT 1
44455: DEC
44456: ST_TO_ADDR
44457: LD_EXP 69
44461: PUSH
44462: FOR_TO
44463: IFFALSE 44568
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
44465: LD_VAR 0 2
44469: PUSH
44470: LD_EXP 69
44474: PUSH
44475: LD_VAR 0 6
44479: ARRAY
44480: IN
44481: PUSH
44482: LD_VAR 0 1
44486: PUSH
44487: LD_EXP 69
44491: PUSH
44492: LD_VAR 0 6
44496: ARRAY
44497: IN
44498: OR
44499: IFFALSE 44566
// begin tmp := mc_vehicles [ i ] diff old ;
44501: LD_ADDR_VAR 0 7
44505: PUSH
44506: LD_EXP 69
44510: PUSH
44511: LD_VAR 0 6
44515: ARRAY
44516: PUSH
44517: LD_VAR 0 2
44521: DIFF
44522: ST_TO_ADDR
// tmp := tmp diff new ;
44523: LD_ADDR_VAR 0 7
44527: PUSH
44528: LD_VAR 0 7
44532: PUSH
44533: LD_VAR 0 1
44537: DIFF
44538: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
44539: LD_ADDR_EXP 69
44543: PUSH
44544: LD_EXP 69
44548: PPUSH
44549: LD_VAR 0 6
44553: PPUSH
44554: LD_VAR 0 7
44558: PPUSH
44559: CALL_OW 1
44563: ST_TO_ADDR
// break ;
44564: GO 44568
// end ;
44566: GO 44462
44568: POP
44569: POP
// end ;
44570: LD_VAR 0 5
44574: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
44575: LD_INT 0
44577: PPUSH
44578: PPUSH
44579: PPUSH
44580: PPUSH
// if not mc_bases or not skirmish then
44581: LD_EXP 50
44585: NOT
44586: PUSH
44587: LD_EXP 48
44591: NOT
44592: OR
44593: IFFALSE 44597
// exit ;
44595: GO 44979
// side := GetSide ( vehicle ) ;
44597: LD_ADDR_VAR 0 5
44601: PUSH
44602: LD_VAR 0 1
44606: PPUSH
44607: CALL_OW 255
44611: ST_TO_ADDR
// for i = 1 to mc_bases do
44612: LD_ADDR_VAR 0 4
44616: PUSH
44617: DOUBLE
44618: LD_INT 1
44620: DEC
44621: ST_TO_ADDR
44622: LD_EXP 50
44626: PUSH
44627: FOR_TO
44628: IFFALSE 44977
// begin if factory in mc_bases [ i ] then
44630: LD_VAR 0 2
44634: PUSH
44635: LD_EXP 50
44639: PUSH
44640: LD_VAR 0 4
44644: ARRAY
44645: IN
44646: IFFALSE 44975
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
44648: LD_EXP 72
44652: PUSH
44653: LD_VAR 0 4
44657: ARRAY
44658: PUSH
44659: LD_EXP 61
44663: PUSH
44664: LD_VAR 0 4
44668: ARRAY
44669: LESS
44670: PUSH
44671: LD_VAR 0 1
44675: PPUSH
44676: CALL_OW 264
44680: PUSH
44681: LD_INT 31
44683: PUSH
44684: LD_INT 32
44686: PUSH
44687: LD_INT 51
44689: PUSH
44690: LD_INT 89
44692: PUSH
44693: LD_INT 12
44695: PUSH
44696: LD_INT 30
44698: PUSH
44699: LD_INT 98
44701: PUSH
44702: LD_INT 11
44704: PUSH
44705: LD_INT 53
44707: PUSH
44708: LD_INT 14
44710: PUSH
44711: LD_INT 91
44713: PUSH
44714: LD_INT 29
44716: PUSH
44717: LD_INT 99
44719: PUSH
44720: LD_INT 13
44722: PUSH
44723: LD_INT 52
44725: PUSH
44726: LD_INT 88
44728: PUSH
44729: LD_INT 48
44731: PUSH
44732: LD_INT 8
44734: PUSH
44735: EMPTY
44736: LIST
44737: LIST
44738: LIST
44739: LIST
44740: LIST
44741: LIST
44742: LIST
44743: LIST
44744: LIST
44745: LIST
44746: LIST
44747: LIST
44748: LIST
44749: LIST
44750: LIST
44751: LIST
44752: LIST
44753: LIST
44754: IN
44755: NOT
44756: AND
44757: IFFALSE 44805
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
44759: LD_ADDR_EXP 72
44763: PUSH
44764: LD_EXP 72
44768: PPUSH
44769: LD_VAR 0 4
44773: PUSH
44774: LD_EXP 72
44778: PUSH
44779: LD_VAR 0 4
44783: ARRAY
44784: PUSH
44785: LD_INT 1
44787: PLUS
44788: PUSH
44789: EMPTY
44790: LIST
44791: LIST
44792: PPUSH
44793: LD_VAR 0 1
44797: PPUSH
44798: CALL 53789 0 3
44802: ST_TO_ADDR
44803: GO 44849
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
44805: LD_ADDR_EXP 69
44809: PUSH
44810: LD_EXP 69
44814: PPUSH
44815: LD_VAR 0 4
44819: PUSH
44820: LD_EXP 69
44824: PUSH
44825: LD_VAR 0 4
44829: ARRAY
44830: PUSH
44831: LD_INT 1
44833: PLUS
44834: PUSH
44835: EMPTY
44836: LIST
44837: LIST
44838: PPUSH
44839: LD_VAR 0 1
44843: PPUSH
44844: CALL 53789 0 3
44848: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
44849: LD_VAR 0 1
44853: PPUSH
44854: CALL_OW 263
44858: PUSH
44859: LD_INT 2
44861: EQUAL
44862: IFFALSE 44891
// begin repeat wait ( 0 0$3 ) ;
44864: LD_INT 105
44866: PPUSH
44867: CALL_OW 67
// Connect ( vehicle ) ;
44871: LD_VAR 0 1
44875: PPUSH
44876: CALL 56758 0 1
// until IsControledBy ( vehicle ) ;
44880: LD_VAR 0 1
44884: PPUSH
44885: CALL_OW 312
44889: IFFALSE 44864
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
44891: LD_VAR 0 1
44895: PPUSH
44896: LD_EXP 74
44900: PUSH
44901: LD_VAR 0 4
44905: ARRAY
44906: PPUSH
44907: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
44911: LD_VAR 0 1
44915: PPUSH
44916: CALL_OW 263
44920: PUSH
44921: LD_INT 1
44923: NONEQUAL
44924: IFFALSE 44928
// break ;
44926: GO 44977
// repeat wait ( 0 0$1 ) ;
44928: LD_INT 35
44930: PPUSH
44931: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
44935: LD_VAR 0 1
44939: PPUSH
44940: LD_EXP 74
44944: PUSH
44945: LD_VAR 0 4
44949: ARRAY
44950: PPUSH
44951: CALL_OW 308
44955: IFFALSE 44928
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
44957: LD_VAR 0 1
44961: PPUSH
44962: CALL_OW 311
44966: PPUSH
44967: CALL_OW 121
// exit ;
44971: POP
44972: POP
44973: GO 44979
// end ; end ;
44975: GO 44627
44977: POP
44978: POP
// end ;
44979: LD_VAR 0 3
44983: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
44984: LD_INT 0
44986: PPUSH
44987: PPUSH
44988: PPUSH
44989: PPUSH
// if not mc_bases or not skirmish then
44990: LD_EXP 50
44994: NOT
44995: PUSH
44996: LD_EXP 48
45000: NOT
45001: OR
45002: IFFALSE 45006
// exit ;
45004: GO 45359
// repeat wait ( 0 0$1 ) ;
45006: LD_INT 35
45008: PPUSH
45009: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
45013: LD_VAR 0 2
45017: PPUSH
45018: LD_VAR 0 3
45022: PPUSH
45023: CALL_OW 284
45027: IFFALSE 45006
// if GetResourceTypeXY ( x , y ) = mat_artefact then
45029: LD_VAR 0 2
45033: PPUSH
45034: LD_VAR 0 3
45038: PPUSH
45039: CALL_OW 283
45043: PUSH
45044: LD_INT 4
45046: EQUAL
45047: IFFALSE 45051
// exit ;
45049: GO 45359
// for i = 1 to mc_bases do
45051: LD_ADDR_VAR 0 7
45055: PUSH
45056: DOUBLE
45057: LD_INT 1
45059: DEC
45060: ST_TO_ADDR
45061: LD_EXP 50
45065: PUSH
45066: FOR_TO
45067: IFFALSE 45357
// begin if mc_crates_area [ i ] then
45069: LD_EXP 68
45073: PUSH
45074: LD_VAR 0 7
45078: ARRAY
45079: IFFALSE 45190
// for j in mc_crates_area [ i ] do
45081: LD_ADDR_VAR 0 8
45085: PUSH
45086: LD_EXP 68
45090: PUSH
45091: LD_VAR 0 7
45095: ARRAY
45096: PUSH
45097: FOR_IN
45098: IFFALSE 45188
// if InArea ( x , y , j ) then
45100: LD_VAR 0 2
45104: PPUSH
45105: LD_VAR 0 3
45109: PPUSH
45110: LD_VAR 0 8
45114: PPUSH
45115: CALL_OW 309
45119: IFFALSE 45186
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
45121: LD_ADDR_EXP 66
45125: PUSH
45126: LD_EXP 66
45130: PPUSH
45131: LD_VAR 0 7
45135: PUSH
45136: LD_EXP 66
45140: PUSH
45141: LD_VAR 0 7
45145: ARRAY
45146: PUSH
45147: LD_INT 1
45149: PLUS
45150: PUSH
45151: EMPTY
45152: LIST
45153: LIST
45154: PPUSH
45155: LD_VAR 0 4
45159: PUSH
45160: LD_VAR 0 2
45164: PUSH
45165: LD_VAR 0 3
45169: PUSH
45170: EMPTY
45171: LIST
45172: LIST
45173: LIST
45174: PPUSH
45175: CALL 53789 0 3
45179: ST_TO_ADDR
// exit ;
45180: POP
45181: POP
45182: POP
45183: POP
45184: GO 45359
// end ;
45186: GO 45097
45188: POP
45189: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
45190: LD_ADDR_VAR 0 9
45194: PUSH
45195: LD_EXP 50
45199: PUSH
45200: LD_VAR 0 7
45204: ARRAY
45205: PPUSH
45206: LD_INT 2
45208: PUSH
45209: LD_INT 30
45211: PUSH
45212: LD_INT 0
45214: PUSH
45215: EMPTY
45216: LIST
45217: LIST
45218: PUSH
45219: LD_INT 30
45221: PUSH
45222: LD_INT 1
45224: PUSH
45225: EMPTY
45226: LIST
45227: LIST
45228: PUSH
45229: EMPTY
45230: LIST
45231: LIST
45232: LIST
45233: PPUSH
45234: CALL_OW 72
45238: ST_TO_ADDR
// if not depot then
45239: LD_VAR 0 9
45243: NOT
45244: IFFALSE 45248
// continue ;
45246: GO 45066
// for j in depot do
45248: LD_ADDR_VAR 0 8
45252: PUSH
45253: LD_VAR 0 9
45257: PUSH
45258: FOR_IN
45259: IFFALSE 45353
// if GetDistUnitXY ( j , x , y ) < 30 then
45261: LD_VAR 0 8
45265: PPUSH
45266: LD_VAR 0 2
45270: PPUSH
45271: LD_VAR 0 3
45275: PPUSH
45276: CALL_OW 297
45280: PUSH
45281: LD_INT 30
45283: LESS
45284: IFFALSE 45351
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
45286: LD_ADDR_EXP 66
45290: PUSH
45291: LD_EXP 66
45295: PPUSH
45296: LD_VAR 0 7
45300: PUSH
45301: LD_EXP 66
45305: PUSH
45306: LD_VAR 0 7
45310: ARRAY
45311: PUSH
45312: LD_INT 1
45314: PLUS
45315: PUSH
45316: EMPTY
45317: LIST
45318: LIST
45319: PPUSH
45320: LD_VAR 0 4
45324: PUSH
45325: LD_VAR 0 2
45329: PUSH
45330: LD_VAR 0 3
45334: PUSH
45335: EMPTY
45336: LIST
45337: LIST
45338: LIST
45339: PPUSH
45340: CALL 53789 0 3
45344: ST_TO_ADDR
// exit ;
45345: POP
45346: POP
45347: POP
45348: POP
45349: GO 45359
// end ;
45351: GO 45258
45353: POP
45354: POP
// end ;
45355: GO 45066
45357: POP
45358: POP
// end ;
45359: LD_VAR 0 6
45363: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
45364: LD_INT 0
45366: PPUSH
45367: PPUSH
45368: PPUSH
45369: PPUSH
// if not mc_bases or not skirmish then
45370: LD_EXP 50
45374: NOT
45375: PUSH
45376: LD_EXP 48
45380: NOT
45381: OR
45382: IFFALSE 45386
// exit ;
45384: GO 45663
// side := GetSide ( lab ) ;
45386: LD_ADDR_VAR 0 4
45390: PUSH
45391: LD_VAR 0 2
45395: PPUSH
45396: CALL_OW 255
45400: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
45401: LD_VAR 0 4
45405: PUSH
45406: LD_EXP 76
45410: IN
45411: NOT
45412: PUSH
45413: LD_EXP 77
45417: NOT
45418: OR
45419: PUSH
45420: LD_EXP 50
45424: NOT
45425: OR
45426: IFFALSE 45430
// exit ;
45428: GO 45663
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
45430: LD_ADDR_EXP 77
45434: PUSH
45435: LD_EXP 77
45439: PPUSH
45440: LD_VAR 0 4
45444: PPUSH
45445: LD_EXP 77
45449: PUSH
45450: LD_VAR 0 4
45454: ARRAY
45455: PUSH
45456: LD_VAR 0 1
45460: DIFF
45461: PPUSH
45462: CALL_OW 1
45466: ST_TO_ADDR
// for i = 1 to mc_bases do
45467: LD_ADDR_VAR 0 5
45471: PUSH
45472: DOUBLE
45473: LD_INT 1
45475: DEC
45476: ST_TO_ADDR
45477: LD_EXP 50
45481: PUSH
45482: FOR_TO
45483: IFFALSE 45661
// begin if lab in mc_bases [ i ] then
45485: LD_VAR 0 2
45489: PUSH
45490: LD_EXP 50
45494: PUSH
45495: LD_VAR 0 5
45499: ARRAY
45500: IN
45501: IFFALSE 45659
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
45503: LD_VAR 0 1
45507: PUSH
45508: LD_INT 11
45510: PUSH
45511: LD_INT 4
45513: PUSH
45514: LD_INT 3
45516: PUSH
45517: LD_INT 2
45519: PUSH
45520: EMPTY
45521: LIST
45522: LIST
45523: LIST
45524: LIST
45525: IN
45526: PUSH
45527: LD_EXP 80
45531: PUSH
45532: LD_VAR 0 5
45536: ARRAY
45537: AND
45538: IFFALSE 45659
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
45540: LD_ADDR_VAR 0 6
45544: PUSH
45545: LD_EXP 80
45549: PUSH
45550: LD_VAR 0 5
45554: ARRAY
45555: PUSH
45556: LD_INT 1
45558: ARRAY
45559: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
45560: LD_ADDR_EXP 80
45564: PUSH
45565: LD_EXP 80
45569: PPUSH
45570: LD_VAR 0 5
45574: PPUSH
45575: EMPTY
45576: PPUSH
45577: CALL_OW 1
45581: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
45582: LD_VAR 0 6
45586: PPUSH
45587: LD_INT 0
45589: PPUSH
45590: CALL_OW 109
// ComExitBuilding ( tmp ) ;
45594: LD_VAR 0 6
45598: PPUSH
45599: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
45603: LD_ADDR_EXP 79
45607: PUSH
45608: LD_EXP 79
45612: PPUSH
45613: LD_VAR 0 5
45617: PPUSH
45618: LD_EXP 79
45622: PUSH
45623: LD_VAR 0 5
45627: ARRAY
45628: PPUSH
45629: LD_INT 1
45631: PPUSH
45632: LD_VAR 0 6
45636: PPUSH
45637: CALL_OW 2
45641: PPUSH
45642: CALL_OW 1
45646: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
45647: LD_VAR 0 5
45651: PPUSH
45652: LD_INT 112
45654: PPUSH
45655: CALL 22149 0 2
// end ; end ; end ;
45659: GO 45482
45661: POP
45662: POP
// end ;
45663: LD_VAR 0 3
45667: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
45668: LD_INT 0
45670: PPUSH
45671: PPUSH
45672: PPUSH
45673: PPUSH
45674: PPUSH
45675: PPUSH
45676: PPUSH
45677: PPUSH
// if not mc_bases or not skirmish then
45678: LD_EXP 50
45682: NOT
45683: PUSH
45684: LD_EXP 48
45688: NOT
45689: OR
45690: IFFALSE 45694
// exit ;
45692: GO 47063
// for i = 1 to mc_bases do
45694: LD_ADDR_VAR 0 3
45698: PUSH
45699: DOUBLE
45700: LD_INT 1
45702: DEC
45703: ST_TO_ADDR
45704: LD_EXP 50
45708: PUSH
45709: FOR_TO
45710: IFFALSE 47061
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
45712: LD_VAR 0 1
45716: PUSH
45717: LD_EXP 50
45721: PUSH
45722: LD_VAR 0 3
45726: ARRAY
45727: IN
45728: PUSH
45729: LD_VAR 0 1
45733: PUSH
45734: LD_EXP 57
45738: PUSH
45739: LD_VAR 0 3
45743: ARRAY
45744: IN
45745: OR
45746: PUSH
45747: LD_VAR 0 1
45751: PUSH
45752: LD_EXP 72
45756: PUSH
45757: LD_VAR 0 3
45761: ARRAY
45762: IN
45763: OR
45764: PUSH
45765: LD_VAR 0 1
45769: PUSH
45770: LD_EXP 69
45774: PUSH
45775: LD_VAR 0 3
45779: ARRAY
45780: IN
45781: OR
45782: PUSH
45783: LD_VAR 0 1
45787: PUSH
45788: LD_EXP 79
45792: PUSH
45793: LD_VAR 0 3
45797: ARRAY
45798: IN
45799: OR
45800: PUSH
45801: LD_VAR 0 1
45805: PUSH
45806: LD_EXP 80
45810: PUSH
45811: LD_VAR 0 3
45815: ARRAY
45816: IN
45817: OR
45818: IFFALSE 47059
// begin if un in mc_ape [ i ] then
45820: LD_VAR 0 1
45824: PUSH
45825: LD_EXP 79
45829: PUSH
45830: LD_VAR 0 3
45834: ARRAY
45835: IN
45836: IFFALSE 45875
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
45838: LD_ADDR_EXP 79
45842: PUSH
45843: LD_EXP 79
45847: PPUSH
45848: LD_VAR 0 3
45852: PPUSH
45853: LD_EXP 79
45857: PUSH
45858: LD_VAR 0 3
45862: ARRAY
45863: PUSH
45864: LD_VAR 0 1
45868: DIFF
45869: PPUSH
45870: CALL_OW 1
45874: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
45875: LD_VAR 0 1
45879: PUSH
45880: LD_EXP 80
45884: PUSH
45885: LD_VAR 0 3
45889: ARRAY
45890: IN
45891: IFFALSE 45915
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
45893: LD_ADDR_EXP 80
45897: PUSH
45898: LD_EXP 80
45902: PPUSH
45903: LD_VAR 0 3
45907: PPUSH
45908: EMPTY
45909: PPUSH
45910: CALL_OW 1
45914: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
45915: LD_VAR 0 1
45919: PPUSH
45920: CALL_OW 247
45924: PUSH
45925: LD_INT 2
45927: EQUAL
45928: PUSH
45929: LD_VAR 0 1
45933: PPUSH
45934: CALL_OW 110
45938: PUSH
45939: LD_INT 20
45941: EQUAL
45942: PUSH
45943: LD_VAR 0 1
45947: PUSH
45948: LD_EXP 72
45952: PUSH
45953: LD_VAR 0 3
45957: ARRAY
45958: IN
45959: OR
45960: PUSH
45961: LD_VAR 0 1
45965: PPUSH
45966: CALL_OW 264
45970: PUSH
45971: LD_INT 12
45973: PUSH
45974: LD_INT 51
45976: PUSH
45977: LD_INT 89
45979: PUSH
45980: LD_INT 32
45982: PUSH
45983: LD_INT 13
45985: PUSH
45986: LD_INT 52
45988: PUSH
45989: LD_INT 31
45991: PUSH
45992: EMPTY
45993: LIST
45994: LIST
45995: LIST
45996: LIST
45997: LIST
45998: LIST
45999: LIST
46000: IN
46001: OR
46002: AND
46003: IFFALSE 46311
// begin if un in mc_defender [ i ] then
46005: LD_VAR 0 1
46009: PUSH
46010: LD_EXP 72
46014: PUSH
46015: LD_VAR 0 3
46019: ARRAY
46020: IN
46021: IFFALSE 46060
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
46023: LD_ADDR_EXP 72
46027: PUSH
46028: LD_EXP 72
46032: PPUSH
46033: LD_VAR 0 3
46037: PPUSH
46038: LD_EXP 72
46042: PUSH
46043: LD_VAR 0 3
46047: ARRAY
46048: PUSH
46049: LD_VAR 0 1
46053: DIFF
46054: PPUSH
46055: CALL_OW 1
46059: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
46060: LD_ADDR_VAR 0 8
46064: PUSH
46065: LD_VAR 0 3
46069: PPUSH
46070: LD_INT 3
46072: PPUSH
46073: CALL 42719 0 2
46077: ST_TO_ADDR
// if fac then
46078: LD_VAR 0 8
46082: IFFALSE 46311
// begin for j in fac do
46084: LD_ADDR_VAR 0 4
46088: PUSH
46089: LD_VAR 0 8
46093: PUSH
46094: FOR_IN
46095: IFFALSE 46309
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
46097: LD_ADDR_VAR 0 9
46101: PUSH
46102: LD_VAR 0 8
46106: PPUSH
46107: LD_VAR 0 1
46111: PPUSH
46112: CALL_OW 265
46116: PPUSH
46117: LD_VAR 0 1
46121: PPUSH
46122: CALL_OW 262
46126: PPUSH
46127: LD_VAR 0 1
46131: PPUSH
46132: CALL_OW 263
46136: PPUSH
46137: LD_VAR 0 1
46141: PPUSH
46142: CALL_OW 264
46146: PPUSH
46147: CALL 51287 0 5
46151: ST_TO_ADDR
// if components then
46152: LD_VAR 0 9
46156: IFFALSE 46307
// begin if GetWeapon ( un ) = ar_control_tower then
46158: LD_VAR 0 1
46162: PPUSH
46163: CALL_OW 264
46167: PUSH
46168: LD_INT 31
46170: EQUAL
46171: IFFALSE 46288
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
46173: LD_VAR 0 1
46177: PPUSH
46178: CALL_OW 311
46182: PPUSH
46183: LD_INT 0
46185: PPUSH
46186: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
46190: LD_ADDR_EXP 90
46194: PUSH
46195: LD_EXP 90
46199: PPUSH
46200: LD_VAR 0 3
46204: PPUSH
46205: LD_EXP 90
46209: PUSH
46210: LD_VAR 0 3
46214: ARRAY
46215: PUSH
46216: LD_VAR 0 1
46220: PPUSH
46221: CALL_OW 311
46225: DIFF
46226: PPUSH
46227: CALL_OW 1
46231: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
46232: LD_ADDR_VAR 0 7
46236: PUSH
46237: LD_EXP 71
46241: PUSH
46242: LD_VAR 0 3
46246: ARRAY
46247: PPUSH
46248: LD_INT 1
46250: PPUSH
46251: LD_VAR 0 9
46255: PPUSH
46256: CALL_OW 2
46260: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
46261: LD_ADDR_EXP 71
46265: PUSH
46266: LD_EXP 71
46270: PPUSH
46271: LD_VAR 0 3
46275: PPUSH
46276: LD_VAR 0 7
46280: PPUSH
46281: CALL_OW 1
46285: ST_TO_ADDR
// end else
46286: GO 46305
// MC_InsertProduceList ( i , [ components ] ) ;
46288: LD_VAR 0 3
46292: PPUSH
46293: LD_VAR 0 9
46297: PUSH
46298: EMPTY
46299: LIST
46300: PPUSH
46301: CALL 42264 0 2
// break ;
46305: GO 46309
// end ; end ;
46307: GO 46094
46309: POP
46310: POP
// end ; end ; if GetType ( un ) = unit_building then
46311: LD_VAR 0 1
46315: PPUSH
46316: CALL_OW 247
46320: PUSH
46321: LD_INT 3
46323: EQUAL
46324: IFFALSE 46727
// begin btype := GetBType ( un ) ;
46326: LD_ADDR_VAR 0 5
46330: PUSH
46331: LD_VAR 0 1
46335: PPUSH
46336: CALL_OW 266
46340: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
46341: LD_VAR 0 5
46345: PUSH
46346: LD_INT 29
46348: PUSH
46349: LD_INT 30
46351: PUSH
46352: EMPTY
46353: LIST
46354: LIST
46355: IN
46356: IFFALSE 46429
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
46358: LD_VAR 0 1
46362: PPUSH
46363: CALL_OW 250
46367: PPUSH
46368: LD_VAR 0 1
46372: PPUSH
46373: CALL_OW 251
46377: PPUSH
46378: LD_VAR 0 1
46382: PPUSH
46383: CALL_OW 255
46387: PPUSH
46388: CALL_OW 440
46392: NOT
46393: IFFALSE 46429
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
46395: LD_VAR 0 1
46399: PPUSH
46400: CALL_OW 250
46404: PPUSH
46405: LD_VAR 0 1
46409: PPUSH
46410: CALL_OW 251
46414: PPUSH
46415: LD_VAR 0 1
46419: PPUSH
46420: CALL_OW 255
46424: PPUSH
46425: CALL_OW 441
// end ; if btype = b_warehouse then
46429: LD_VAR 0 5
46433: PUSH
46434: LD_INT 1
46436: EQUAL
46437: IFFALSE 46455
// begin btype := b_depot ;
46439: LD_ADDR_VAR 0 5
46443: PUSH
46444: LD_INT 0
46446: ST_TO_ADDR
// pos := 1 ;
46447: LD_ADDR_VAR 0 6
46451: PUSH
46452: LD_INT 1
46454: ST_TO_ADDR
// end ; if btype = b_factory then
46455: LD_VAR 0 5
46459: PUSH
46460: LD_INT 3
46462: EQUAL
46463: IFFALSE 46481
// begin btype := b_workshop ;
46465: LD_ADDR_VAR 0 5
46469: PUSH
46470: LD_INT 2
46472: ST_TO_ADDR
// pos := 1 ;
46473: LD_ADDR_VAR 0 6
46477: PUSH
46478: LD_INT 1
46480: ST_TO_ADDR
// end ; if btype = b_barracks then
46481: LD_VAR 0 5
46485: PUSH
46486: LD_INT 5
46488: EQUAL
46489: IFFALSE 46499
// btype := b_armoury ;
46491: LD_ADDR_VAR 0 5
46495: PUSH
46496: LD_INT 4
46498: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
46499: LD_VAR 0 5
46503: PUSH
46504: LD_INT 7
46506: PUSH
46507: LD_INT 8
46509: PUSH
46510: EMPTY
46511: LIST
46512: LIST
46513: IN
46514: IFFALSE 46524
// btype := b_lab ;
46516: LD_ADDR_VAR 0 5
46520: PUSH
46521: LD_INT 6
46523: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
46524: LD_ADDR_EXP 55
46528: PUSH
46529: LD_EXP 55
46533: PPUSH
46534: LD_VAR 0 3
46538: PUSH
46539: LD_EXP 55
46543: PUSH
46544: LD_VAR 0 3
46548: ARRAY
46549: PUSH
46550: LD_INT 1
46552: PLUS
46553: PUSH
46554: EMPTY
46555: LIST
46556: LIST
46557: PPUSH
46558: LD_VAR 0 5
46562: PUSH
46563: LD_VAR 0 1
46567: PPUSH
46568: CALL_OW 250
46572: PUSH
46573: LD_VAR 0 1
46577: PPUSH
46578: CALL_OW 251
46582: PUSH
46583: LD_VAR 0 1
46587: PPUSH
46588: CALL_OW 254
46592: PUSH
46593: EMPTY
46594: LIST
46595: LIST
46596: LIST
46597: LIST
46598: PPUSH
46599: CALL 53789 0 3
46603: ST_TO_ADDR
// if pos = 1 then
46604: LD_VAR 0 6
46608: PUSH
46609: LD_INT 1
46611: EQUAL
46612: IFFALSE 46727
// begin tmp := mc_build_list [ i ] ;
46614: LD_ADDR_VAR 0 7
46618: PUSH
46619: LD_EXP 55
46623: PUSH
46624: LD_VAR 0 3
46628: ARRAY
46629: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
46630: LD_VAR 0 7
46634: PPUSH
46635: LD_INT 2
46637: PUSH
46638: LD_INT 30
46640: PUSH
46641: LD_INT 0
46643: PUSH
46644: EMPTY
46645: LIST
46646: LIST
46647: PUSH
46648: LD_INT 30
46650: PUSH
46651: LD_INT 1
46653: PUSH
46654: EMPTY
46655: LIST
46656: LIST
46657: PUSH
46658: EMPTY
46659: LIST
46660: LIST
46661: LIST
46662: PPUSH
46663: CALL_OW 72
46667: IFFALSE 46677
// pos := 2 ;
46669: LD_ADDR_VAR 0 6
46673: PUSH
46674: LD_INT 2
46676: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
46677: LD_ADDR_VAR 0 7
46681: PUSH
46682: LD_VAR 0 7
46686: PPUSH
46687: LD_VAR 0 6
46691: PPUSH
46692: LD_VAR 0 7
46696: PPUSH
46697: CALL 54115 0 3
46701: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
46702: LD_ADDR_EXP 55
46706: PUSH
46707: LD_EXP 55
46711: PPUSH
46712: LD_VAR 0 3
46716: PPUSH
46717: LD_VAR 0 7
46721: PPUSH
46722: CALL_OW 1
46726: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
46727: LD_VAR 0 1
46731: PUSH
46732: LD_EXP 50
46736: PUSH
46737: LD_VAR 0 3
46741: ARRAY
46742: IN
46743: IFFALSE 46782
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
46745: LD_ADDR_EXP 50
46749: PUSH
46750: LD_EXP 50
46754: PPUSH
46755: LD_VAR 0 3
46759: PPUSH
46760: LD_EXP 50
46764: PUSH
46765: LD_VAR 0 3
46769: ARRAY
46770: PUSH
46771: LD_VAR 0 1
46775: DIFF
46776: PPUSH
46777: CALL_OW 1
46781: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
46782: LD_VAR 0 1
46786: PUSH
46787: LD_EXP 57
46791: PUSH
46792: LD_VAR 0 3
46796: ARRAY
46797: IN
46798: IFFALSE 46837
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
46800: LD_ADDR_EXP 57
46804: PUSH
46805: LD_EXP 57
46809: PPUSH
46810: LD_VAR 0 3
46814: PPUSH
46815: LD_EXP 57
46819: PUSH
46820: LD_VAR 0 3
46824: ARRAY
46825: PUSH
46826: LD_VAR 0 1
46830: DIFF
46831: PPUSH
46832: CALL_OW 1
46836: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
46837: LD_VAR 0 1
46841: PUSH
46842: LD_EXP 69
46846: PUSH
46847: LD_VAR 0 3
46851: ARRAY
46852: IN
46853: IFFALSE 46892
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
46855: LD_ADDR_EXP 69
46859: PUSH
46860: LD_EXP 69
46864: PPUSH
46865: LD_VAR 0 3
46869: PPUSH
46870: LD_EXP 69
46874: PUSH
46875: LD_VAR 0 3
46879: ARRAY
46880: PUSH
46881: LD_VAR 0 1
46885: DIFF
46886: PPUSH
46887: CALL_OW 1
46891: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
46892: LD_VAR 0 1
46896: PUSH
46897: LD_EXP 72
46901: PUSH
46902: LD_VAR 0 3
46906: ARRAY
46907: IN
46908: IFFALSE 46947
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
46910: LD_ADDR_EXP 72
46914: PUSH
46915: LD_EXP 72
46919: PPUSH
46920: LD_VAR 0 3
46924: PPUSH
46925: LD_EXP 72
46929: PUSH
46930: LD_VAR 0 3
46934: ARRAY
46935: PUSH
46936: LD_VAR 0 1
46940: DIFF
46941: PPUSH
46942: CALL_OW 1
46946: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
46947: LD_VAR 0 1
46951: PUSH
46952: LD_EXP 59
46956: PUSH
46957: LD_VAR 0 3
46961: ARRAY
46962: IN
46963: IFFALSE 47002
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
46965: LD_ADDR_EXP 59
46969: PUSH
46970: LD_EXP 59
46974: PPUSH
46975: LD_VAR 0 3
46979: PPUSH
46980: LD_EXP 59
46984: PUSH
46985: LD_VAR 0 3
46989: ARRAY
46990: PUSH
46991: LD_VAR 0 1
46995: DIFF
46996: PPUSH
46997: CALL_OW 1
47001: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
47002: LD_VAR 0 1
47006: PUSH
47007: LD_EXP 58
47011: PUSH
47012: LD_VAR 0 3
47016: ARRAY
47017: IN
47018: IFFALSE 47057
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
47020: LD_ADDR_EXP 58
47024: PUSH
47025: LD_EXP 58
47029: PPUSH
47030: LD_VAR 0 3
47034: PPUSH
47035: LD_EXP 58
47039: PUSH
47040: LD_VAR 0 3
47044: ARRAY
47045: PUSH
47046: LD_VAR 0 1
47050: DIFF
47051: PPUSH
47052: CALL_OW 1
47056: ST_TO_ADDR
// end ; break ;
47057: GO 47061
// end ;
47059: GO 45709
47061: POP
47062: POP
// end ;
47063: LD_VAR 0 2
47067: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
47068: LD_INT 0
47070: PPUSH
47071: PPUSH
47072: PPUSH
// if not mc_bases or not skirmish then
47073: LD_EXP 50
47077: NOT
47078: PUSH
47079: LD_EXP 48
47083: NOT
47084: OR
47085: IFFALSE 47089
// exit ;
47087: GO 47304
// for i = 1 to mc_bases do
47089: LD_ADDR_VAR 0 3
47093: PUSH
47094: DOUBLE
47095: LD_INT 1
47097: DEC
47098: ST_TO_ADDR
47099: LD_EXP 50
47103: PUSH
47104: FOR_TO
47105: IFFALSE 47302
// begin if building in mc_construct_list [ i ] then
47107: LD_VAR 0 1
47111: PUSH
47112: LD_EXP 57
47116: PUSH
47117: LD_VAR 0 3
47121: ARRAY
47122: IN
47123: IFFALSE 47300
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
47125: LD_ADDR_EXP 57
47129: PUSH
47130: LD_EXP 57
47134: PPUSH
47135: LD_VAR 0 3
47139: PPUSH
47140: LD_EXP 57
47144: PUSH
47145: LD_VAR 0 3
47149: ARRAY
47150: PUSH
47151: LD_VAR 0 1
47155: DIFF
47156: PPUSH
47157: CALL_OW 1
47161: ST_TO_ADDR
// if building in mc_lab [ i ] then
47162: LD_VAR 0 1
47166: PUSH
47167: LD_EXP 83
47171: PUSH
47172: LD_VAR 0 3
47176: ARRAY
47177: IN
47178: IFFALSE 47233
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
47180: LD_ADDR_EXP 84
47184: PUSH
47185: LD_EXP 84
47189: PPUSH
47190: LD_VAR 0 3
47194: PPUSH
47195: LD_EXP 84
47199: PUSH
47200: LD_VAR 0 3
47204: ARRAY
47205: PPUSH
47206: LD_INT 1
47208: PPUSH
47209: LD_EXP 84
47213: PUSH
47214: LD_VAR 0 3
47218: ARRAY
47219: PPUSH
47220: LD_INT 0
47222: PPUSH
47223: CALL 53207 0 4
47227: PPUSH
47228: CALL_OW 1
47232: ST_TO_ADDR
// if not building in mc_bases [ i ] then
47233: LD_VAR 0 1
47237: PUSH
47238: LD_EXP 50
47242: PUSH
47243: LD_VAR 0 3
47247: ARRAY
47248: IN
47249: NOT
47250: IFFALSE 47296
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
47252: LD_ADDR_EXP 50
47256: PUSH
47257: LD_EXP 50
47261: PPUSH
47262: LD_VAR 0 3
47266: PUSH
47267: LD_EXP 50
47271: PUSH
47272: LD_VAR 0 3
47276: ARRAY
47277: PUSH
47278: LD_INT 1
47280: PLUS
47281: PUSH
47282: EMPTY
47283: LIST
47284: LIST
47285: PPUSH
47286: LD_VAR 0 1
47290: PPUSH
47291: CALL 53789 0 3
47295: ST_TO_ADDR
// exit ;
47296: POP
47297: POP
47298: GO 47304
// end ; end ;
47300: GO 47104
47302: POP
47303: POP
// end ;
47304: LD_VAR 0 2
47308: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
47309: LD_INT 0
47311: PPUSH
47312: PPUSH
47313: PPUSH
47314: PPUSH
47315: PPUSH
47316: PPUSH
47317: PPUSH
// if not mc_bases or not skirmish then
47318: LD_EXP 50
47322: NOT
47323: PUSH
47324: LD_EXP 48
47328: NOT
47329: OR
47330: IFFALSE 47334
// exit ;
47332: GO 47995
// for i = 1 to mc_bases do
47334: LD_ADDR_VAR 0 3
47338: PUSH
47339: DOUBLE
47340: LD_INT 1
47342: DEC
47343: ST_TO_ADDR
47344: LD_EXP 50
47348: PUSH
47349: FOR_TO
47350: IFFALSE 47993
// begin if building in mc_construct_list [ i ] then
47352: LD_VAR 0 1
47356: PUSH
47357: LD_EXP 57
47361: PUSH
47362: LD_VAR 0 3
47366: ARRAY
47367: IN
47368: IFFALSE 47991
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
47370: LD_ADDR_EXP 57
47374: PUSH
47375: LD_EXP 57
47379: PPUSH
47380: LD_VAR 0 3
47384: PPUSH
47385: LD_EXP 57
47389: PUSH
47390: LD_VAR 0 3
47394: ARRAY
47395: PUSH
47396: LD_VAR 0 1
47400: DIFF
47401: PPUSH
47402: CALL_OW 1
47406: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
47407: LD_ADDR_EXP 50
47411: PUSH
47412: LD_EXP 50
47416: PPUSH
47417: LD_VAR 0 3
47421: PUSH
47422: LD_EXP 50
47426: PUSH
47427: LD_VAR 0 3
47431: ARRAY
47432: PUSH
47433: LD_INT 1
47435: PLUS
47436: PUSH
47437: EMPTY
47438: LIST
47439: LIST
47440: PPUSH
47441: LD_VAR 0 1
47445: PPUSH
47446: CALL 53789 0 3
47450: ST_TO_ADDR
// btype := GetBType ( building ) ;
47451: LD_ADDR_VAR 0 5
47455: PUSH
47456: LD_VAR 0 1
47460: PPUSH
47461: CALL_OW 266
47465: ST_TO_ADDR
// side := GetSide ( building ) ;
47466: LD_ADDR_VAR 0 8
47470: PUSH
47471: LD_VAR 0 1
47475: PPUSH
47476: CALL_OW 255
47480: ST_TO_ADDR
// if btype = b_lab then
47481: LD_VAR 0 5
47485: PUSH
47486: LD_INT 6
47488: EQUAL
47489: IFFALSE 47539
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
47491: LD_ADDR_EXP 83
47495: PUSH
47496: LD_EXP 83
47500: PPUSH
47501: LD_VAR 0 3
47505: PUSH
47506: LD_EXP 83
47510: PUSH
47511: LD_VAR 0 3
47515: ARRAY
47516: PUSH
47517: LD_INT 1
47519: PLUS
47520: PUSH
47521: EMPTY
47522: LIST
47523: LIST
47524: PPUSH
47525: LD_VAR 0 1
47529: PPUSH
47530: CALL 53789 0 3
47534: ST_TO_ADDR
// exit ;
47535: POP
47536: POP
47537: GO 47995
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
47539: LD_VAR 0 5
47543: PUSH
47544: LD_INT 0
47546: PUSH
47547: LD_INT 2
47549: PUSH
47550: LD_INT 4
47552: PUSH
47553: EMPTY
47554: LIST
47555: LIST
47556: LIST
47557: IN
47558: IFFALSE 47682
// begin if btype = b_armoury then
47560: LD_VAR 0 5
47564: PUSH
47565: LD_INT 4
47567: EQUAL
47568: IFFALSE 47578
// btype := b_barracks ;
47570: LD_ADDR_VAR 0 5
47574: PUSH
47575: LD_INT 5
47577: ST_TO_ADDR
// if btype = b_depot then
47578: LD_VAR 0 5
47582: PUSH
47583: LD_INT 0
47585: EQUAL
47586: IFFALSE 47596
// btype := b_warehouse ;
47588: LD_ADDR_VAR 0 5
47592: PUSH
47593: LD_INT 1
47595: ST_TO_ADDR
// if btype = b_workshop then
47596: LD_VAR 0 5
47600: PUSH
47601: LD_INT 2
47603: EQUAL
47604: IFFALSE 47614
// btype := b_factory ;
47606: LD_ADDR_VAR 0 5
47610: PUSH
47611: LD_INT 3
47613: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
47614: LD_VAR 0 5
47618: PPUSH
47619: LD_VAR 0 8
47623: PPUSH
47624: CALL_OW 323
47628: PUSH
47629: LD_INT 1
47631: EQUAL
47632: IFFALSE 47678
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
47634: LD_ADDR_EXP 82
47638: PUSH
47639: LD_EXP 82
47643: PPUSH
47644: LD_VAR 0 3
47648: PUSH
47649: LD_EXP 82
47653: PUSH
47654: LD_VAR 0 3
47658: ARRAY
47659: PUSH
47660: LD_INT 1
47662: PLUS
47663: PUSH
47664: EMPTY
47665: LIST
47666: LIST
47667: PPUSH
47668: LD_VAR 0 1
47672: PPUSH
47673: CALL 53789 0 3
47677: ST_TO_ADDR
// exit ;
47678: POP
47679: POP
47680: GO 47995
// end ; if btype in [ b_bunker , b_turret ] then
47682: LD_VAR 0 5
47686: PUSH
47687: LD_INT 32
47689: PUSH
47690: LD_INT 33
47692: PUSH
47693: EMPTY
47694: LIST
47695: LIST
47696: IN
47697: IFFALSE 47987
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
47699: LD_ADDR_EXP 58
47703: PUSH
47704: LD_EXP 58
47708: PPUSH
47709: LD_VAR 0 3
47713: PUSH
47714: LD_EXP 58
47718: PUSH
47719: LD_VAR 0 3
47723: ARRAY
47724: PUSH
47725: LD_INT 1
47727: PLUS
47728: PUSH
47729: EMPTY
47730: LIST
47731: LIST
47732: PPUSH
47733: LD_VAR 0 1
47737: PPUSH
47738: CALL 53789 0 3
47742: ST_TO_ADDR
// if btype = b_bunker then
47743: LD_VAR 0 5
47747: PUSH
47748: LD_INT 32
47750: EQUAL
47751: IFFALSE 47987
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
47753: LD_ADDR_EXP 59
47757: PUSH
47758: LD_EXP 59
47762: PPUSH
47763: LD_VAR 0 3
47767: PUSH
47768: LD_EXP 59
47772: PUSH
47773: LD_VAR 0 3
47777: ARRAY
47778: PUSH
47779: LD_INT 1
47781: PLUS
47782: PUSH
47783: EMPTY
47784: LIST
47785: LIST
47786: PPUSH
47787: LD_VAR 0 1
47791: PPUSH
47792: CALL 53789 0 3
47796: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
47797: LD_ADDR_VAR 0 6
47801: PUSH
47802: LD_EXP 50
47806: PUSH
47807: LD_VAR 0 3
47811: ARRAY
47812: PPUSH
47813: LD_INT 25
47815: PUSH
47816: LD_INT 1
47818: PUSH
47819: EMPTY
47820: LIST
47821: LIST
47822: PUSH
47823: LD_INT 3
47825: PUSH
47826: LD_INT 54
47828: PUSH
47829: EMPTY
47830: LIST
47831: PUSH
47832: EMPTY
47833: LIST
47834: LIST
47835: PUSH
47836: EMPTY
47837: LIST
47838: LIST
47839: PPUSH
47840: CALL_OW 72
47844: ST_TO_ADDR
// if tmp then
47845: LD_VAR 0 6
47849: IFFALSE 47855
// exit ;
47851: POP
47852: POP
47853: GO 47995
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
47855: LD_ADDR_VAR 0 6
47859: PUSH
47860: LD_EXP 50
47864: PUSH
47865: LD_VAR 0 3
47869: ARRAY
47870: PPUSH
47871: LD_INT 2
47873: PUSH
47874: LD_INT 30
47876: PUSH
47877: LD_INT 4
47879: PUSH
47880: EMPTY
47881: LIST
47882: LIST
47883: PUSH
47884: LD_INT 30
47886: PUSH
47887: LD_INT 5
47889: PUSH
47890: EMPTY
47891: LIST
47892: LIST
47893: PUSH
47894: EMPTY
47895: LIST
47896: LIST
47897: LIST
47898: PPUSH
47899: CALL_OW 72
47903: ST_TO_ADDR
// if not tmp then
47904: LD_VAR 0 6
47908: NOT
47909: IFFALSE 47915
// exit ;
47911: POP
47912: POP
47913: GO 47995
// for j in tmp do
47915: LD_ADDR_VAR 0 4
47919: PUSH
47920: LD_VAR 0 6
47924: PUSH
47925: FOR_IN
47926: IFFALSE 47985
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
47928: LD_ADDR_VAR 0 7
47932: PUSH
47933: LD_VAR 0 4
47937: PPUSH
47938: CALL_OW 313
47942: PPUSH
47943: LD_INT 25
47945: PUSH
47946: LD_INT 1
47948: PUSH
47949: EMPTY
47950: LIST
47951: LIST
47952: PPUSH
47953: CALL_OW 72
47957: ST_TO_ADDR
// if units then
47958: LD_VAR 0 7
47962: IFFALSE 47983
// begin ComExitBuilding ( units [ 1 ] ) ;
47964: LD_VAR 0 7
47968: PUSH
47969: LD_INT 1
47971: ARRAY
47972: PPUSH
47973: CALL_OW 122
// exit ;
47977: POP
47978: POP
47979: POP
47980: POP
47981: GO 47995
// end ; end ;
47983: GO 47925
47985: POP
47986: POP
// end ; end ; exit ;
47987: POP
47988: POP
47989: GO 47995
// end ; end ;
47991: GO 47349
47993: POP
47994: POP
// end ;
47995: LD_VAR 0 2
47999: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
48000: LD_INT 0
48002: PPUSH
48003: PPUSH
48004: PPUSH
48005: PPUSH
48006: PPUSH
48007: PPUSH
48008: PPUSH
// if not mc_bases or not skirmish then
48009: LD_EXP 50
48013: NOT
48014: PUSH
48015: LD_EXP 48
48019: NOT
48020: OR
48021: IFFALSE 48025
// exit ;
48023: GO 48290
// btype := GetBType ( building ) ;
48025: LD_ADDR_VAR 0 6
48029: PUSH
48030: LD_VAR 0 1
48034: PPUSH
48035: CALL_OW 266
48039: ST_TO_ADDR
// x := GetX ( building ) ;
48040: LD_ADDR_VAR 0 7
48044: PUSH
48045: LD_VAR 0 1
48049: PPUSH
48050: CALL_OW 250
48054: ST_TO_ADDR
// y := GetY ( building ) ;
48055: LD_ADDR_VAR 0 8
48059: PUSH
48060: LD_VAR 0 1
48064: PPUSH
48065: CALL_OW 251
48069: ST_TO_ADDR
// d := GetDir ( building ) ;
48070: LD_ADDR_VAR 0 9
48074: PUSH
48075: LD_VAR 0 1
48079: PPUSH
48080: CALL_OW 254
48084: ST_TO_ADDR
// for i = 1 to mc_bases do
48085: LD_ADDR_VAR 0 4
48089: PUSH
48090: DOUBLE
48091: LD_INT 1
48093: DEC
48094: ST_TO_ADDR
48095: LD_EXP 50
48099: PUSH
48100: FOR_TO
48101: IFFALSE 48288
// begin if not mc_build_list [ i ] then
48103: LD_EXP 55
48107: PUSH
48108: LD_VAR 0 4
48112: ARRAY
48113: NOT
48114: IFFALSE 48118
// continue ;
48116: GO 48100
// for j := 1 to mc_build_list [ i ] do
48118: LD_ADDR_VAR 0 5
48122: PUSH
48123: DOUBLE
48124: LD_INT 1
48126: DEC
48127: ST_TO_ADDR
48128: LD_EXP 55
48132: PUSH
48133: LD_VAR 0 4
48137: ARRAY
48138: PUSH
48139: FOR_TO
48140: IFFALSE 48284
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
48142: LD_VAR 0 6
48146: PUSH
48147: LD_VAR 0 7
48151: PUSH
48152: LD_VAR 0 8
48156: PUSH
48157: LD_VAR 0 9
48161: PUSH
48162: EMPTY
48163: LIST
48164: LIST
48165: LIST
48166: LIST
48167: PPUSH
48168: LD_EXP 55
48172: PUSH
48173: LD_VAR 0 4
48177: ARRAY
48178: PUSH
48179: LD_VAR 0 5
48183: ARRAY
48184: PPUSH
48185: CALL 59969 0 2
48189: IFFALSE 48282
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
48191: LD_ADDR_EXP 55
48195: PUSH
48196: LD_EXP 55
48200: PPUSH
48201: LD_VAR 0 4
48205: PPUSH
48206: LD_EXP 55
48210: PUSH
48211: LD_VAR 0 4
48215: ARRAY
48216: PPUSH
48217: LD_VAR 0 5
48221: PPUSH
48222: CALL_OW 3
48226: PPUSH
48227: CALL_OW 1
48231: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
48232: LD_ADDR_EXP 57
48236: PUSH
48237: LD_EXP 57
48241: PPUSH
48242: LD_VAR 0 4
48246: PUSH
48247: LD_EXP 57
48251: PUSH
48252: LD_VAR 0 4
48256: ARRAY
48257: PUSH
48258: LD_INT 1
48260: PLUS
48261: PUSH
48262: EMPTY
48263: LIST
48264: LIST
48265: PPUSH
48266: LD_VAR 0 1
48270: PPUSH
48271: CALL 53789 0 3
48275: ST_TO_ADDR
// exit ;
48276: POP
48277: POP
48278: POP
48279: POP
48280: GO 48290
// end ;
48282: GO 48139
48284: POP
48285: POP
// end ;
48286: GO 48100
48288: POP
48289: POP
// end ;
48290: LD_VAR 0 3
48294: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
48295: LD_INT 0
48297: PPUSH
48298: PPUSH
48299: PPUSH
// if not mc_bases or not skirmish then
48300: LD_EXP 50
48304: NOT
48305: PUSH
48306: LD_EXP 48
48310: NOT
48311: OR
48312: IFFALSE 48316
// exit ;
48314: GO 48506
// for i = 1 to mc_bases do
48316: LD_ADDR_VAR 0 4
48320: PUSH
48321: DOUBLE
48322: LD_INT 1
48324: DEC
48325: ST_TO_ADDR
48326: LD_EXP 50
48330: PUSH
48331: FOR_TO
48332: IFFALSE 48419
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
48334: LD_VAR 0 1
48338: PUSH
48339: LD_EXP 58
48343: PUSH
48344: LD_VAR 0 4
48348: ARRAY
48349: IN
48350: PUSH
48351: LD_VAR 0 1
48355: PUSH
48356: LD_EXP 59
48360: PUSH
48361: LD_VAR 0 4
48365: ARRAY
48366: IN
48367: NOT
48368: AND
48369: IFFALSE 48417
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
48371: LD_ADDR_EXP 59
48375: PUSH
48376: LD_EXP 59
48380: PPUSH
48381: LD_VAR 0 4
48385: PUSH
48386: LD_EXP 59
48390: PUSH
48391: LD_VAR 0 4
48395: ARRAY
48396: PUSH
48397: LD_INT 1
48399: PLUS
48400: PUSH
48401: EMPTY
48402: LIST
48403: LIST
48404: PPUSH
48405: LD_VAR 0 1
48409: PPUSH
48410: CALL 53789 0 3
48414: ST_TO_ADDR
// break ;
48415: GO 48419
// end ; end ;
48417: GO 48331
48419: POP
48420: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
48421: LD_VAR 0 1
48425: PPUSH
48426: CALL_OW 257
48430: PUSH
48431: LD_EXP 76
48435: IN
48436: PUSH
48437: LD_VAR 0 1
48441: PPUSH
48442: CALL_OW 266
48446: PUSH
48447: LD_INT 5
48449: EQUAL
48450: AND
48451: PUSH
48452: LD_VAR 0 2
48456: PPUSH
48457: CALL_OW 110
48461: PUSH
48462: LD_INT 18
48464: NONEQUAL
48465: AND
48466: IFFALSE 48506
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
48468: LD_VAR 0 2
48472: PPUSH
48473: CALL_OW 257
48477: PUSH
48478: LD_INT 5
48480: PUSH
48481: LD_INT 8
48483: PUSH
48484: LD_INT 9
48486: PUSH
48487: EMPTY
48488: LIST
48489: LIST
48490: LIST
48491: IN
48492: IFFALSE 48506
// SetClass ( unit , 1 ) ;
48494: LD_VAR 0 2
48498: PPUSH
48499: LD_INT 1
48501: PPUSH
48502: CALL_OW 336
// end ;
48506: LD_VAR 0 3
48510: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
48511: LD_INT 0
48513: PPUSH
48514: PPUSH
// if not mc_bases or not skirmish then
48515: LD_EXP 50
48519: NOT
48520: PUSH
48521: LD_EXP 48
48525: NOT
48526: OR
48527: IFFALSE 48531
// exit ;
48529: GO 48647
// if GetLives ( abandoned_vehicle ) > 250 then
48531: LD_VAR 0 2
48535: PPUSH
48536: CALL_OW 256
48540: PUSH
48541: LD_INT 250
48543: GREATER
48544: IFFALSE 48548
// exit ;
48546: GO 48647
// for i = 1 to mc_bases do
48548: LD_ADDR_VAR 0 6
48552: PUSH
48553: DOUBLE
48554: LD_INT 1
48556: DEC
48557: ST_TO_ADDR
48558: LD_EXP 50
48562: PUSH
48563: FOR_TO
48564: IFFALSE 48645
// begin if driver in mc_bases [ i ] then
48566: LD_VAR 0 1
48570: PUSH
48571: LD_EXP 50
48575: PUSH
48576: LD_VAR 0 6
48580: ARRAY
48581: IN
48582: IFFALSE 48643
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
48584: LD_VAR 0 1
48588: PPUSH
48589: LD_EXP 50
48593: PUSH
48594: LD_VAR 0 6
48598: ARRAY
48599: PPUSH
48600: LD_INT 2
48602: PUSH
48603: LD_INT 30
48605: PUSH
48606: LD_INT 0
48608: PUSH
48609: EMPTY
48610: LIST
48611: LIST
48612: PUSH
48613: LD_INT 30
48615: PUSH
48616: LD_INT 1
48618: PUSH
48619: EMPTY
48620: LIST
48621: LIST
48622: PUSH
48623: EMPTY
48624: LIST
48625: LIST
48626: LIST
48627: PPUSH
48628: CALL_OW 72
48632: PUSH
48633: LD_INT 1
48635: ARRAY
48636: PPUSH
48637: CALL 86978 0 2
// break ;
48641: GO 48645
// end ; end ;
48643: GO 48563
48645: POP
48646: POP
// end ; end_of_file
48647: LD_VAR 0 5
48651: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
48652: LD_INT 0
48654: PPUSH
48655: PPUSH
// if exist_mode then
48656: LD_VAR 0 2
48660: IFFALSE 48685
// unit := CreateCharacter ( prefix & ident ) else
48662: LD_ADDR_VAR 0 5
48666: PUSH
48667: LD_VAR 0 3
48671: PUSH
48672: LD_VAR 0 1
48676: STR
48677: PPUSH
48678: CALL_OW 34
48682: ST_TO_ADDR
48683: GO 48700
// unit := NewCharacter ( ident ) ;
48685: LD_ADDR_VAR 0 5
48689: PUSH
48690: LD_VAR 0 1
48694: PPUSH
48695: CALL_OW 25
48699: ST_TO_ADDR
// result := unit ;
48700: LD_ADDR_VAR 0 4
48704: PUSH
48705: LD_VAR 0 5
48709: ST_TO_ADDR
// end ;
48710: LD_VAR 0 4
48714: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
48715: LD_INT 0
48717: PPUSH
48718: PPUSH
// if not side or not nation then
48719: LD_VAR 0 1
48723: NOT
48724: PUSH
48725: LD_VAR 0 2
48729: NOT
48730: OR
48731: IFFALSE 48735
// exit ;
48733: GO 49503
// case nation of nation_american :
48735: LD_VAR 0 2
48739: PUSH
48740: LD_INT 1
48742: DOUBLE
48743: EQUAL
48744: IFTRUE 48748
48746: GO 48962
48748: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
48749: LD_ADDR_VAR 0 4
48753: PUSH
48754: LD_INT 35
48756: PUSH
48757: LD_INT 45
48759: PUSH
48760: LD_INT 46
48762: PUSH
48763: LD_INT 47
48765: PUSH
48766: LD_INT 82
48768: PUSH
48769: LD_INT 83
48771: PUSH
48772: LD_INT 84
48774: PUSH
48775: LD_INT 85
48777: PUSH
48778: LD_INT 86
48780: PUSH
48781: LD_INT 1
48783: PUSH
48784: LD_INT 2
48786: PUSH
48787: LD_INT 6
48789: PUSH
48790: LD_INT 15
48792: PUSH
48793: LD_INT 16
48795: PUSH
48796: LD_INT 7
48798: PUSH
48799: LD_INT 12
48801: PUSH
48802: LD_INT 13
48804: PUSH
48805: LD_INT 10
48807: PUSH
48808: LD_INT 14
48810: PUSH
48811: LD_INT 20
48813: PUSH
48814: LD_INT 21
48816: PUSH
48817: LD_INT 22
48819: PUSH
48820: LD_INT 25
48822: PUSH
48823: LD_INT 32
48825: PUSH
48826: LD_INT 27
48828: PUSH
48829: LD_INT 36
48831: PUSH
48832: LD_INT 69
48834: PUSH
48835: LD_INT 39
48837: PUSH
48838: LD_INT 34
48840: PUSH
48841: LD_INT 40
48843: PUSH
48844: LD_INT 48
48846: PUSH
48847: LD_INT 49
48849: PUSH
48850: LD_INT 50
48852: PUSH
48853: LD_INT 51
48855: PUSH
48856: LD_INT 52
48858: PUSH
48859: LD_INT 53
48861: PUSH
48862: LD_INT 54
48864: PUSH
48865: LD_INT 55
48867: PUSH
48868: LD_INT 56
48870: PUSH
48871: LD_INT 57
48873: PUSH
48874: LD_INT 58
48876: PUSH
48877: LD_INT 59
48879: PUSH
48880: LD_INT 60
48882: PUSH
48883: LD_INT 61
48885: PUSH
48886: LD_INT 62
48888: PUSH
48889: LD_INT 80
48891: PUSH
48892: LD_INT 82
48894: PUSH
48895: LD_INT 83
48897: PUSH
48898: LD_INT 84
48900: PUSH
48901: LD_INT 85
48903: PUSH
48904: LD_INT 86
48906: PUSH
48907: EMPTY
48908: LIST
48909: LIST
48910: LIST
48911: LIST
48912: LIST
48913: LIST
48914: LIST
48915: LIST
48916: LIST
48917: LIST
48918: LIST
48919: LIST
48920: LIST
48921: LIST
48922: LIST
48923: LIST
48924: LIST
48925: LIST
48926: LIST
48927: LIST
48928: LIST
48929: LIST
48930: LIST
48931: LIST
48932: LIST
48933: LIST
48934: LIST
48935: LIST
48936: LIST
48937: LIST
48938: LIST
48939: LIST
48940: LIST
48941: LIST
48942: LIST
48943: LIST
48944: LIST
48945: LIST
48946: LIST
48947: LIST
48948: LIST
48949: LIST
48950: LIST
48951: LIST
48952: LIST
48953: LIST
48954: LIST
48955: LIST
48956: LIST
48957: LIST
48958: LIST
48959: ST_TO_ADDR
48960: GO 49427
48962: LD_INT 2
48964: DOUBLE
48965: EQUAL
48966: IFTRUE 48970
48968: GO 49196
48970: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
48971: LD_ADDR_VAR 0 4
48975: PUSH
48976: LD_INT 35
48978: PUSH
48979: LD_INT 45
48981: PUSH
48982: LD_INT 46
48984: PUSH
48985: LD_INT 47
48987: PUSH
48988: LD_INT 82
48990: PUSH
48991: LD_INT 83
48993: PUSH
48994: LD_INT 84
48996: PUSH
48997: LD_INT 85
48999: PUSH
49000: LD_INT 87
49002: PUSH
49003: LD_INT 70
49005: PUSH
49006: LD_INT 1
49008: PUSH
49009: LD_INT 11
49011: PUSH
49012: LD_INT 3
49014: PUSH
49015: LD_INT 4
49017: PUSH
49018: LD_INT 5
49020: PUSH
49021: LD_INT 6
49023: PUSH
49024: LD_INT 15
49026: PUSH
49027: LD_INT 18
49029: PUSH
49030: LD_INT 7
49032: PUSH
49033: LD_INT 17
49035: PUSH
49036: LD_INT 8
49038: PUSH
49039: LD_INT 20
49041: PUSH
49042: LD_INT 21
49044: PUSH
49045: LD_INT 22
49047: PUSH
49048: LD_INT 72
49050: PUSH
49051: LD_INT 26
49053: PUSH
49054: LD_INT 69
49056: PUSH
49057: LD_INT 39
49059: PUSH
49060: LD_INT 40
49062: PUSH
49063: LD_INT 41
49065: PUSH
49066: LD_INT 42
49068: PUSH
49069: LD_INT 43
49071: PUSH
49072: LD_INT 48
49074: PUSH
49075: LD_INT 49
49077: PUSH
49078: LD_INT 50
49080: PUSH
49081: LD_INT 51
49083: PUSH
49084: LD_INT 52
49086: PUSH
49087: LD_INT 53
49089: PUSH
49090: LD_INT 54
49092: PUSH
49093: LD_INT 55
49095: PUSH
49096: LD_INT 56
49098: PUSH
49099: LD_INT 60
49101: PUSH
49102: LD_INT 61
49104: PUSH
49105: LD_INT 62
49107: PUSH
49108: LD_INT 66
49110: PUSH
49111: LD_INT 67
49113: PUSH
49114: LD_INT 68
49116: PUSH
49117: LD_INT 81
49119: PUSH
49120: LD_INT 82
49122: PUSH
49123: LD_INT 83
49125: PUSH
49126: LD_INT 84
49128: PUSH
49129: LD_INT 85
49131: PUSH
49132: LD_INT 87
49134: PUSH
49135: LD_INT 88
49137: PUSH
49138: EMPTY
49139: LIST
49140: LIST
49141: LIST
49142: LIST
49143: LIST
49144: LIST
49145: LIST
49146: LIST
49147: LIST
49148: LIST
49149: LIST
49150: LIST
49151: LIST
49152: LIST
49153: LIST
49154: LIST
49155: LIST
49156: LIST
49157: LIST
49158: LIST
49159: LIST
49160: LIST
49161: LIST
49162: LIST
49163: LIST
49164: LIST
49165: LIST
49166: LIST
49167: LIST
49168: LIST
49169: LIST
49170: LIST
49171: LIST
49172: LIST
49173: LIST
49174: LIST
49175: LIST
49176: LIST
49177: LIST
49178: LIST
49179: LIST
49180: LIST
49181: LIST
49182: LIST
49183: LIST
49184: LIST
49185: LIST
49186: LIST
49187: LIST
49188: LIST
49189: LIST
49190: LIST
49191: LIST
49192: LIST
49193: ST_TO_ADDR
49194: GO 49427
49196: LD_INT 3
49198: DOUBLE
49199: EQUAL
49200: IFTRUE 49204
49202: GO 49426
49204: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
49205: LD_ADDR_VAR 0 4
49209: PUSH
49210: LD_INT 46
49212: PUSH
49213: LD_INT 47
49215: PUSH
49216: LD_INT 1
49218: PUSH
49219: LD_INT 2
49221: PUSH
49222: LD_INT 82
49224: PUSH
49225: LD_INT 83
49227: PUSH
49228: LD_INT 84
49230: PUSH
49231: LD_INT 85
49233: PUSH
49234: LD_INT 86
49236: PUSH
49237: LD_INT 11
49239: PUSH
49240: LD_INT 9
49242: PUSH
49243: LD_INT 20
49245: PUSH
49246: LD_INT 19
49248: PUSH
49249: LD_INT 21
49251: PUSH
49252: LD_INT 24
49254: PUSH
49255: LD_INT 22
49257: PUSH
49258: LD_INT 25
49260: PUSH
49261: LD_INT 28
49263: PUSH
49264: LD_INT 29
49266: PUSH
49267: LD_INT 30
49269: PUSH
49270: LD_INT 31
49272: PUSH
49273: LD_INT 37
49275: PUSH
49276: LD_INT 38
49278: PUSH
49279: LD_INT 32
49281: PUSH
49282: LD_INT 27
49284: PUSH
49285: LD_INT 33
49287: PUSH
49288: LD_INT 69
49290: PUSH
49291: LD_INT 39
49293: PUSH
49294: LD_INT 34
49296: PUSH
49297: LD_INT 40
49299: PUSH
49300: LD_INT 71
49302: PUSH
49303: LD_INT 23
49305: PUSH
49306: LD_INT 44
49308: PUSH
49309: LD_INT 48
49311: PUSH
49312: LD_INT 49
49314: PUSH
49315: LD_INT 50
49317: PUSH
49318: LD_INT 51
49320: PUSH
49321: LD_INT 52
49323: PUSH
49324: LD_INT 53
49326: PUSH
49327: LD_INT 54
49329: PUSH
49330: LD_INT 55
49332: PUSH
49333: LD_INT 56
49335: PUSH
49336: LD_INT 57
49338: PUSH
49339: LD_INT 58
49341: PUSH
49342: LD_INT 59
49344: PUSH
49345: LD_INT 63
49347: PUSH
49348: LD_INT 64
49350: PUSH
49351: LD_INT 65
49353: PUSH
49354: LD_INT 82
49356: PUSH
49357: LD_INT 83
49359: PUSH
49360: LD_INT 84
49362: PUSH
49363: LD_INT 85
49365: PUSH
49366: LD_INT 86
49368: PUSH
49369: EMPTY
49370: LIST
49371: LIST
49372: LIST
49373: LIST
49374: LIST
49375: LIST
49376: LIST
49377: LIST
49378: LIST
49379: LIST
49380: LIST
49381: LIST
49382: LIST
49383: LIST
49384: LIST
49385: LIST
49386: LIST
49387: LIST
49388: LIST
49389: LIST
49390: LIST
49391: LIST
49392: LIST
49393: LIST
49394: LIST
49395: LIST
49396: LIST
49397: LIST
49398: LIST
49399: LIST
49400: LIST
49401: LIST
49402: LIST
49403: LIST
49404: LIST
49405: LIST
49406: LIST
49407: LIST
49408: LIST
49409: LIST
49410: LIST
49411: LIST
49412: LIST
49413: LIST
49414: LIST
49415: LIST
49416: LIST
49417: LIST
49418: LIST
49419: LIST
49420: LIST
49421: LIST
49422: LIST
49423: ST_TO_ADDR
49424: GO 49427
49426: POP
// if state > - 1 and state < 3 then
49427: LD_VAR 0 3
49431: PUSH
49432: LD_INT 1
49434: NEG
49435: GREATER
49436: PUSH
49437: LD_VAR 0 3
49441: PUSH
49442: LD_INT 3
49444: LESS
49445: AND
49446: IFFALSE 49503
// for i in result do
49448: LD_ADDR_VAR 0 5
49452: PUSH
49453: LD_VAR 0 4
49457: PUSH
49458: FOR_IN
49459: IFFALSE 49501
// if GetTech ( i , side ) <> state then
49461: LD_VAR 0 5
49465: PPUSH
49466: LD_VAR 0 1
49470: PPUSH
49471: CALL_OW 321
49475: PUSH
49476: LD_VAR 0 3
49480: NONEQUAL
49481: IFFALSE 49499
// result := result diff i ;
49483: LD_ADDR_VAR 0 4
49487: PUSH
49488: LD_VAR 0 4
49492: PUSH
49493: LD_VAR 0 5
49497: DIFF
49498: ST_TO_ADDR
49499: GO 49458
49501: POP
49502: POP
// end ;
49503: LD_VAR 0 4
49507: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
49508: LD_INT 0
49510: PPUSH
49511: PPUSH
49512: PPUSH
// result := true ;
49513: LD_ADDR_VAR 0 3
49517: PUSH
49518: LD_INT 1
49520: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
49521: LD_ADDR_VAR 0 5
49525: PUSH
49526: LD_VAR 0 2
49530: PPUSH
49531: CALL_OW 480
49535: ST_TO_ADDR
// if not tmp then
49536: LD_VAR 0 5
49540: NOT
49541: IFFALSE 49545
// exit ;
49543: GO 49594
// for i in tmp do
49545: LD_ADDR_VAR 0 4
49549: PUSH
49550: LD_VAR 0 5
49554: PUSH
49555: FOR_IN
49556: IFFALSE 49592
// if GetTech ( i , side ) <> state_researched then
49558: LD_VAR 0 4
49562: PPUSH
49563: LD_VAR 0 1
49567: PPUSH
49568: CALL_OW 321
49572: PUSH
49573: LD_INT 2
49575: NONEQUAL
49576: IFFALSE 49590
// begin result := false ;
49578: LD_ADDR_VAR 0 3
49582: PUSH
49583: LD_INT 0
49585: ST_TO_ADDR
// exit ;
49586: POP
49587: POP
49588: GO 49594
// end ;
49590: GO 49555
49592: POP
49593: POP
// end ;
49594: LD_VAR 0 3
49598: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
49599: LD_INT 0
49601: PPUSH
49602: PPUSH
49603: PPUSH
49604: PPUSH
49605: PPUSH
49606: PPUSH
49607: PPUSH
49608: PPUSH
49609: PPUSH
49610: PPUSH
49611: PPUSH
49612: PPUSH
49613: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
49614: LD_VAR 0 1
49618: NOT
49619: PUSH
49620: LD_VAR 0 1
49624: PPUSH
49625: CALL_OW 257
49629: PUSH
49630: LD_INT 9
49632: NONEQUAL
49633: OR
49634: IFFALSE 49638
// exit ;
49636: GO 50211
// side := GetSide ( unit ) ;
49638: LD_ADDR_VAR 0 9
49642: PUSH
49643: LD_VAR 0 1
49647: PPUSH
49648: CALL_OW 255
49652: ST_TO_ADDR
// tech_space := tech_spacanom ;
49653: LD_ADDR_VAR 0 12
49657: PUSH
49658: LD_INT 29
49660: ST_TO_ADDR
// tech_time := tech_taurad ;
49661: LD_ADDR_VAR 0 13
49665: PUSH
49666: LD_INT 28
49668: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
49669: LD_ADDR_VAR 0 11
49673: PUSH
49674: LD_VAR 0 1
49678: PPUSH
49679: CALL_OW 310
49683: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
49684: LD_VAR 0 11
49688: PPUSH
49689: CALL_OW 247
49693: PUSH
49694: LD_INT 2
49696: EQUAL
49697: IFFALSE 49701
// exit ;
49699: GO 50211
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
49701: LD_ADDR_VAR 0 8
49705: PUSH
49706: LD_INT 81
49708: PUSH
49709: LD_VAR 0 9
49713: PUSH
49714: EMPTY
49715: LIST
49716: LIST
49717: PUSH
49718: LD_INT 3
49720: PUSH
49721: LD_INT 21
49723: PUSH
49724: LD_INT 3
49726: PUSH
49727: EMPTY
49728: LIST
49729: LIST
49730: PUSH
49731: EMPTY
49732: LIST
49733: LIST
49734: PUSH
49735: EMPTY
49736: LIST
49737: LIST
49738: PPUSH
49739: CALL_OW 69
49743: ST_TO_ADDR
// if not tmp then
49744: LD_VAR 0 8
49748: NOT
49749: IFFALSE 49753
// exit ;
49751: GO 50211
// if in_unit then
49753: LD_VAR 0 11
49757: IFFALSE 49781
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
49759: LD_ADDR_VAR 0 10
49763: PUSH
49764: LD_VAR 0 8
49768: PPUSH
49769: LD_VAR 0 11
49773: PPUSH
49774: CALL_OW 74
49778: ST_TO_ADDR
49779: GO 49801
// enemy := NearestUnitToUnit ( tmp , unit ) ;
49781: LD_ADDR_VAR 0 10
49785: PUSH
49786: LD_VAR 0 8
49790: PPUSH
49791: LD_VAR 0 1
49795: PPUSH
49796: CALL_OW 74
49800: ST_TO_ADDR
// if not enemy then
49801: LD_VAR 0 10
49805: NOT
49806: IFFALSE 49810
// exit ;
49808: GO 50211
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
49810: LD_VAR 0 11
49814: PUSH
49815: LD_VAR 0 11
49819: PPUSH
49820: LD_VAR 0 10
49824: PPUSH
49825: CALL_OW 296
49829: PUSH
49830: LD_INT 13
49832: GREATER
49833: AND
49834: PUSH
49835: LD_VAR 0 1
49839: PPUSH
49840: LD_VAR 0 10
49844: PPUSH
49845: CALL_OW 296
49849: PUSH
49850: LD_INT 12
49852: GREATER
49853: OR
49854: IFFALSE 49858
// exit ;
49856: GO 50211
// missile := [ 1 ] ;
49858: LD_ADDR_VAR 0 14
49862: PUSH
49863: LD_INT 1
49865: PUSH
49866: EMPTY
49867: LIST
49868: ST_TO_ADDR
// if Researched ( side , tech_space ) then
49869: LD_VAR 0 9
49873: PPUSH
49874: LD_VAR 0 12
49878: PPUSH
49879: CALL_OW 325
49883: IFFALSE 49912
// missile := Replace ( missile , missile + 1 , 2 ) ;
49885: LD_ADDR_VAR 0 14
49889: PUSH
49890: LD_VAR 0 14
49894: PPUSH
49895: LD_VAR 0 14
49899: PUSH
49900: LD_INT 1
49902: PLUS
49903: PPUSH
49904: LD_INT 2
49906: PPUSH
49907: CALL_OW 1
49911: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
49912: LD_VAR 0 9
49916: PPUSH
49917: LD_VAR 0 13
49921: PPUSH
49922: CALL_OW 325
49926: PUSH
49927: LD_VAR 0 10
49931: PPUSH
49932: CALL_OW 255
49936: PPUSH
49937: LD_VAR 0 13
49941: PPUSH
49942: CALL_OW 325
49946: NOT
49947: AND
49948: IFFALSE 49977
// missile := Replace ( missile , missile + 1 , 3 ) ;
49950: LD_ADDR_VAR 0 14
49954: PUSH
49955: LD_VAR 0 14
49959: PPUSH
49960: LD_VAR 0 14
49964: PUSH
49965: LD_INT 1
49967: PLUS
49968: PPUSH
49969: LD_INT 3
49971: PPUSH
49972: CALL_OW 1
49976: ST_TO_ADDR
// if missile < 2 then
49977: LD_VAR 0 14
49981: PUSH
49982: LD_INT 2
49984: LESS
49985: IFFALSE 49989
// exit ;
49987: GO 50211
// x := GetX ( enemy ) ;
49989: LD_ADDR_VAR 0 4
49993: PUSH
49994: LD_VAR 0 10
49998: PPUSH
49999: CALL_OW 250
50003: ST_TO_ADDR
// y := GetY ( enemy ) ;
50004: LD_ADDR_VAR 0 5
50008: PUSH
50009: LD_VAR 0 10
50013: PPUSH
50014: CALL_OW 251
50018: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
50019: LD_ADDR_VAR 0 6
50023: PUSH
50024: LD_VAR 0 4
50028: PUSH
50029: LD_INT 1
50031: NEG
50032: PPUSH
50033: LD_INT 1
50035: PPUSH
50036: CALL_OW 12
50040: PLUS
50041: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
50042: LD_ADDR_VAR 0 7
50046: PUSH
50047: LD_VAR 0 5
50051: PUSH
50052: LD_INT 1
50054: NEG
50055: PPUSH
50056: LD_INT 1
50058: PPUSH
50059: CALL_OW 12
50063: PLUS
50064: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
50065: LD_VAR 0 6
50069: PPUSH
50070: LD_VAR 0 7
50074: PPUSH
50075: CALL_OW 488
50079: NOT
50080: IFFALSE 50102
// begin _x := x ;
50082: LD_ADDR_VAR 0 6
50086: PUSH
50087: LD_VAR 0 4
50091: ST_TO_ADDR
// _y := y ;
50092: LD_ADDR_VAR 0 7
50096: PUSH
50097: LD_VAR 0 5
50101: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
50102: LD_ADDR_VAR 0 3
50106: PUSH
50107: LD_INT 1
50109: PPUSH
50110: LD_VAR 0 14
50114: PPUSH
50115: CALL_OW 12
50119: ST_TO_ADDR
// case i of 1 :
50120: LD_VAR 0 3
50124: PUSH
50125: LD_INT 1
50127: DOUBLE
50128: EQUAL
50129: IFTRUE 50133
50131: GO 50150
50133: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
50134: LD_VAR 0 1
50138: PPUSH
50139: LD_VAR 0 10
50143: PPUSH
50144: CALL_OW 115
50148: GO 50211
50150: LD_INT 2
50152: DOUBLE
50153: EQUAL
50154: IFTRUE 50158
50156: GO 50180
50158: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
50159: LD_VAR 0 1
50163: PPUSH
50164: LD_VAR 0 6
50168: PPUSH
50169: LD_VAR 0 7
50173: PPUSH
50174: CALL_OW 153
50178: GO 50211
50180: LD_INT 3
50182: DOUBLE
50183: EQUAL
50184: IFTRUE 50188
50186: GO 50210
50188: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
50189: LD_VAR 0 1
50193: PPUSH
50194: LD_VAR 0 6
50198: PPUSH
50199: LD_VAR 0 7
50203: PPUSH
50204: CALL_OW 154
50208: GO 50211
50210: POP
// end ;
50211: LD_VAR 0 2
50215: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
50216: LD_INT 0
50218: PPUSH
50219: PPUSH
50220: PPUSH
50221: PPUSH
50222: PPUSH
50223: PPUSH
// if not unit or not building then
50224: LD_VAR 0 1
50228: NOT
50229: PUSH
50230: LD_VAR 0 2
50234: NOT
50235: OR
50236: IFFALSE 50240
// exit ;
50238: GO 50398
// x := GetX ( building ) ;
50240: LD_ADDR_VAR 0 5
50244: PUSH
50245: LD_VAR 0 2
50249: PPUSH
50250: CALL_OW 250
50254: ST_TO_ADDR
// y := GetY ( building ) ;
50255: LD_ADDR_VAR 0 6
50259: PUSH
50260: LD_VAR 0 2
50264: PPUSH
50265: CALL_OW 251
50269: ST_TO_ADDR
// for i = 0 to 5 do
50270: LD_ADDR_VAR 0 4
50274: PUSH
50275: DOUBLE
50276: LD_INT 0
50278: DEC
50279: ST_TO_ADDR
50280: LD_INT 5
50282: PUSH
50283: FOR_TO
50284: IFFALSE 50396
// begin _x := ShiftX ( x , i , 3 ) ;
50286: LD_ADDR_VAR 0 7
50290: PUSH
50291: LD_VAR 0 5
50295: PPUSH
50296: LD_VAR 0 4
50300: PPUSH
50301: LD_INT 3
50303: PPUSH
50304: CALL_OW 272
50308: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
50309: LD_ADDR_VAR 0 8
50313: PUSH
50314: LD_VAR 0 6
50318: PPUSH
50319: LD_VAR 0 4
50323: PPUSH
50324: LD_INT 3
50326: PPUSH
50327: CALL_OW 273
50331: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
50332: LD_VAR 0 7
50336: PPUSH
50337: LD_VAR 0 8
50341: PPUSH
50342: CALL_OW 488
50346: NOT
50347: IFFALSE 50351
// continue ;
50349: GO 50283
// if HexInfo ( _x , _y ) = 0 then
50351: LD_VAR 0 7
50355: PPUSH
50356: LD_VAR 0 8
50360: PPUSH
50361: CALL_OW 428
50365: PUSH
50366: LD_INT 0
50368: EQUAL
50369: IFFALSE 50394
// begin ComMoveXY ( unit , _x , _y ) ;
50371: LD_VAR 0 1
50375: PPUSH
50376: LD_VAR 0 7
50380: PPUSH
50381: LD_VAR 0 8
50385: PPUSH
50386: CALL_OW 111
// exit ;
50390: POP
50391: POP
50392: GO 50398
// end ; end ;
50394: GO 50283
50396: POP
50397: POP
// end ;
50398: LD_VAR 0 3
50402: RET
// export function ScanBase ( side , base_area ) ; begin
50403: LD_INT 0
50405: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
50406: LD_ADDR_VAR 0 3
50410: PUSH
50411: LD_VAR 0 2
50415: PPUSH
50416: LD_INT 81
50418: PUSH
50419: LD_VAR 0 1
50423: PUSH
50424: EMPTY
50425: LIST
50426: LIST
50427: PPUSH
50428: CALL_OW 70
50432: ST_TO_ADDR
// end ;
50433: LD_VAR 0 3
50437: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
50438: LD_INT 0
50440: PPUSH
50441: PPUSH
50442: PPUSH
50443: PPUSH
// result := false ;
50444: LD_ADDR_VAR 0 2
50448: PUSH
50449: LD_INT 0
50451: ST_TO_ADDR
// side := GetSide ( unit ) ;
50452: LD_ADDR_VAR 0 3
50456: PUSH
50457: LD_VAR 0 1
50461: PPUSH
50462: CALL_OW 255
50466: ST_TO_ADDR
// nat := GetNation ( unit ) ;
50467: LD_ADDR_VAR 0 4
50471: PUSH
50472: LD_VAR 0 1
50476: PPUSH
50477: CALL_OW 248
50481: ST_TO_ADDR
// case nat of 1 :
50482: LD_VAR 0 4
50486: PUSH
50487: LD_INT 1
50489: DOUBLE
50490: EQUAL
50491: IFTRUE 50495
50493: GO 50506
50495: POP
// tech := tech_lassight ; 2 :
50496: LD_ADDR_VAR 0 5
50500: PUSH
50501: LD_INT 12
50503: ST_TO_ADDR
50504: GO 50545
50506: LD_INT 2
50508: DOUBLE
50509: EQUAL
50510: IFTRUE 50514
50512: GO 50525
50514: POP
// tech := tech_mortar ; 3 :
50515: LD_ADDR_VAR 0 5
50519: PUSH
50520: LD_INT 41
50522: ST_TO_ADDR
50523: GO 50545
50525: LD_INT 3
50527: DOUBLE
50528: EQUAL
50529: IFTRUE 50533
50531: GO 50544
50533: POP
// tech := tech_bazooka ; end ;
50534: LD_ADDR_VAR 0 5
50538: PUSH
50539: LD_INT 44
50541: ST_TO_ADDR
50542: GO 50545
50544: POP
// if Researched ( side , tech ) then
50545: LD_VAR 0 3
50549: PPUSH
50550: LD_VAR 0 5
50554: PPUSH
50555: CALL_OW 325
50559: IFFALSE 50586
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
50561: LD_ADDR_VAR 0 2
50565: PUSH
50566: LD_INT 5
50568: PUSH
50569: LD_INT 8
50571: PUSH
50572: LD_INT 9
50574: PUSH
50575: EMPTY
50576: LIST
50577: LIST
50578: LIST
50579: PUSH
50580: LD_VAR 0 4
50584: ARRAY
50585: ST_TO_ADDR
// end ;
50586: LD_VAR 0 2
50590: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
50591: LD_INT 0
50593: PPUSH
50594: PPUSH
50595: PPUSH
// if not mines then
50596: LD_VAR 0 2
50600: NOT
50601: IFFALSE 50605
// exit ;
50603: GO 50749
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
50605: LD_ADDR_VAR 0 5
50609: PUSH
50610: LD_INT 81
50612: PUSH
50613: LD_VAR 0 1
50617: PUSH
50618: EMPTY
50619: LIST
50620: LIST
50621: PUSH
50622: LD_INT 3
50624: PUSH
50625: LD_INT 21
50627: PUSH
50628: LD_INT 3
50630: PUSH
50631: EMPTY
50632: LIST
50633: LIST
50634: PUSH
50635: EMPTY
50636: LIST
50637: LIST
50638: PUSH
50639: EMPTY
50640: LIST
50641: LIST
50642: PPUSH
50643: CALL_OW 69
50647: ST_TO_ADDR
// for i in mines do
50648: LD_ADDR_VAR 0 4
50652: PUSH
50653: LD_VAR 0 2
50657: PUSH
50658: FOR_IN
50659: IFFALSE 50747
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
50661: LD_VAR 0 4
50665: PUSH
50666: LD_INT 1
50668: ARRAY
50669: PPUSH
50670: LD_VAR 0 4
50674: PUSH
50675: LD_INT 2
50677: ARRAY
50678: PPUSH
50679: CALL_OW 458
50683: NOT
50684: IFFALSE 50688
// continue ;
50686: GO 50658
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
50688: LD_VAR 0 4
50692: PUSH
50693: LD_INT 1
50695: ARRAY
50696: PPUSH
50697: LD_VAR 0 4
50701: PUSH
50702: LD_INT 2
50704: ARRAY
50705: PPUSH
50706: CALL_OW 428
50710: PUSH
50711: LD_VAR 0 5
50715: IN
50716: IFFALSE 50745
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
50718: LD_VAR 0 4
50722: PUSH
50723: LD_INT 1
50725: ARRAY
50726: PPUSH
50727: LD_VAR 0 4
50731: PUSH
50732: LD_INT 2
50734: ARRAY
50735: PPUSH
50736: LD_VAR 0 1
50740: PPUSH
50741: CALL_OW 456
// end ;
50745: GO 50658
50747: POP
50748: POP
// end ;
50749: LD_VAR 0 3
50753: RET
// export function Count ( array ) ; var i ; begin
50754: LD_INT 0
50756: PPUSH
50757: PPUSH
// result := 0 ;
50758: LD_ADDR_VAR 0 2
50762: PUSH
50763: LD_INT 0
50765: ST_TO_ADDR
// for i in array do
50766: LD_ADDR_VAR 0 3
50770: PUSH
50771: LD_VAR 0 1
50775: PUSH
50776: FOR_IN
50777: IFFALSE 50801
// if i then
50779: LD_VAR 0 3
50783: IFFALSE 50799
// result := result + 1 ;
50785: LD_ADDR_VAR 0 2
50789: PUSH
50790: LD_VAR 0 2
50794: PUSH
50795: LD_INT 1
50797: PLUS
50798: ST_TO_ADDR
50799: GO 50776
50801: POP
50802: POP
// end ;
50803: LD_VAR 0 2
50807: RET
// export function IsEmpty ( building ) ; begin
50808: LD_INT 0
50810: PPUSH
// if not building then
50811: LD_VAR 0 1
50815: NOT
50816: IFFALSE 50820
// exit ;
50818: GO 50863
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
50820: LD_ADDR_VAR 0 2
50824: PUSH
50825: LD_VAR 0 1
50829: PUSH
50830: LD_INT 22
50832: PUSH
50833: LD_VAR 0 1
50837: PPUSH
50838: CALL_OW 255
50842: PUSH
50843: EMPTY
50844: LIST
50845: LIST
50846: PUSH
50847: LD_INT 58
50849: PUSH
50850: EMPTY
50851: LIST
50852: PUSH
50853: EMPTY
50854: LIST
50855: LIST
50856: PPUSH
50857: CALL_OW 69
50861: IN
50862: ST_TO_ADDR
// end ;
50863: LD_VAR 0 2
50867: RET
// export function IsNotFull ( building ) ; var places ; begin
50868: LD_INT 0
50870: PPUSH
50871: PPUSH
// if not building then
50872: LD_VAR 0 1
50876: NOT
50877: IFFALSE 50881
// exit ;
50879: GO 51052
// result := false ;
50881: LD_ADDR_VAR 0 2
50885: PUSH
50886: LD_INT 0
50888: ST_TO_ADDR
// places := 0 ;
50889: LD_ADDR_VAR 0 3
50893: PUSH
50894: LD_INT 0
50896: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
50897: LD_VAR 0 1
50901: PPUSH
50902: CALL_OW 266
50906: PUSH
50907: LD_INT 0
50909: DOUBLE
50910: EQUAL
50911: IFTRUE 50969
50913: LD_INT 1
50915: DOUBLE
50916: EQUAL
50917: IFTRUE 50969
50919: LD_INT 6
50921: DOUBLE
50922: EQUAL
50923: IFTRUE 50969
50925: LD_INT 7
50927: DOUBLE
50928: EQUAL
50929: IFTRUE 50969
50931: LD_INT 8
50933: DOUBLE
50934: EQUAL
50935: IFTRUE 50969
50937: LD_INT 4
50939: DOUBLE
50940: EQUAL
50941: IFTRUE 50969
50943: LD_INT 5
50945: DOUBLE
50946: EQUAL
50947: IFTRUE 50969
50949: LD_INT 2
50951: DOUBLE
50952: EQUAL
50953: IFTRUE 50969
50955: LD_INT 3
50957: DOUBLE
50958: EQUAL
50959: IFTRUE 50969
50961: LD_INT 35
50963: DOUBLE
50964: EQUAL
50965: IFTRUE 50969
50967: GO 50980
50969: POP
// places := 6 ; b_bunker , b_breastwork :
50970: LD_ADDR_VAR 0 3
50974: PUSH
50975: LD_INT 6
50977: ST_TO_ADDR
50978: GO 51025
50980: LD_INT 32
50982: DOUBLE
50983: EQUAL
50984: IFTRUE 50994
50986: LD_INT 31
50988: DOUBLE
50989: EQUAL
50990: IFTRUE 50994
50992: GO 51005
50994: POP
// places := 1 ; b_control_tower :
50995: LD_ADDR_VAR 0 3
50999: PUSH
51000: LD_INT 1
51002: ST_TO_ADDR
51003: GO 51025
51005: LD_INT 36
51007: DOUBLE
51008: EQUAL
51009: IFTRUE 51013
51011: GO 51024
51013: POP
// places := 3 ; end ;
51014: LD_ADDR_VAR 0 3
51018: PUSH
51019: LD_INT 3
51021: ST_TO_ADDR
51022: GO 51025
51024: POP
// if places then
51025: LD_VAR 0 3
51029: IFFALSE 51052
// result := UnitsInside ( building ) < places ;
51031: LD_ADDR_VAR 0 2
51035: PUSH
51036: LD_VAR 0 1
51040: PPUSH
51041: CALL_OW 313
51045: PUSH
51046: LD_VAR 0 3
51050: LESS
51051: ST_TO_ADDR
// end ;
51052: LD_VAR 0 2
51056: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
51057: LD_INT 0
51059: PPUSH
51060: PPUSH
51061: PPUSH
51062: PPUSH
// tmp := [ ] ;
51063: LD_ADDR_VAR 0 3
51067: PUSH
51068: EMPTY
51069: ST_TO_ADDR
// list := [ ] ;
51070: LD_ADDR_VAR 0 5
51074: PUSH
51075: EMPTY
51076: ST_TO_ADDR
// for i = 16 to 25 do
51077: LD_ADDR_VAR 0 4
51081: PUSH
51082: DOUBLE
51083: LD_INT 16
51085: DEC
51086: ST_TO_ADDR
51087: LD_INT 25
51089: PUSH
51090: FOR_TO
51091: IFFALSE 51164
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
51093: LD_ADDR_VAR 0 3
51097: PUSH
51098: LD_VAR 0 3
51102: PUSH
51103: LD_INT 22
51105: PUSH
51106: LD_VAR 0 1
51110: PPUSH
51111: CALL_OW 255
51115: PUSH
51116: EMPTY
51117: LIST
51118: LIST
51119: PUSH
51120: LD_INT 91
51122: PUSH
51123: LD_VAR 0 1
51127: PUSH
51128: LD_INT 6
51130: PUSH
51131: EMPTY
51132: LIST
51133: LIST
51134: LIST
51135: PUSH
51136: LD_INT 30
51138: PUSH
51139: LD_VAR 0 4
51143: PUSH
51144: EMPTY
51145: LIST
51146: LIST
51147: PUSH
51148: EMPTY
51149: LIST
51150: LIST
51151: LIST
51152: PUSH
51153: EMPTY
51154: LIST
51155: PPUSH
51156: CALL_OW 69
51160: ADD
51161: ST_TO_ADDR
51162: GO 51090
51164: POP
51165: POP
// for i = 1 to tmp do
51166: LD_ADDR_VAR 0 4
51170: PUSH
51171: DOUBLE
51172: LD_INT 1
51174: DEC
51175: ST_TO_ADDR
51176: LD_VAR 0 3
51180: PUSH
51181: FOR_TO
51182: IFFALSE 51270
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
51184: LD_ADDR_VAR 0 5
51188: PUSH
51189: LD_VAR 0 5
51193: PUSH
51194: LD_VAR 0 3
51198: PUSH
51199: LD_VAR 0 4
51203: ARRAY
51204: PPUSH
51205: CALL_OW 266
51209: PUSH
51210: LD_VAR 0 3
51214: PUSH
51215: LD_VAR 0 4
51219: ARRAY
51220: PPUSH
51221: CALL_OW 250
51225: PUSH
51226: LD_VAR 0 3
51230: PUSH
51231: LD_VAR 0 4
51235: ARRAY
51236: PPUSH
51237: CALL_OW 251
51241: PUSH
51242: LD_VAR 0 3
51246: PUSH
51247: LD_VAR 0 4
51251: ARRAY
51252: PPUSH
51253: CALL_OW 254
51257: PUSH
51258: EMPTY
51259: LIST
51260: LIST
51261: LIST
51262: LIST
51263: PUSH
51264: EMPTY
51265: LIST
51266: ADD
51267: ST_TO_ADDR
51268: GO 51181
51270: POP
51271: POP
// result := list ;
51272: LD_ADDR_VAR 0 2
51276: PUSH
51277: LD_VAR 0 5
51281: ST_TO_ADDR
// end ;
51282: LD_VAR 0 2
51286: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
51287: LD_INT 0
51289: PPUSH
51290: PPUSH
51291: PPUSH
51292: PPUSH
51293: PPUSH
51294: PPUSH
51295: PPUSH
// if not factory then
51296: LD_VAR 0 1
51300: NOT
51301: IFFALSE 51305
// exit ;
51303: GO 51898
// if control = control_apeman then
51305: LD_VAR 0 4
51309: PUSH
51310: LD_INT 5
51312: EQUAL
51313: IFFALSE 51422
// begin tmp := UnitsInside ( factory ) ;
51315: LD_ADDR_VAR 0 8
51319: PUSH
51320: LD_VAR 0 1
51324: PPUSH
51325: CALL_OW 313
51329: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
51330: LD_VAR 0 8
51334: PPUSH
51335: LD_INT 25
51337: PUSH
51338: LD_INT 12
51340: PUSH
51341: EMPTY
51342: LIST
51343: LIST
51344: PPUSH
51345: CALL_OW 72
51349: NOT
51350: IFFALSE 51360
// control := control_manual ;
51352: LD_ADDR_VAR 0 4
51356: PUSH
51357: LD_INT 1
51359: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
51360: LD_ADDR_VAR 0 8
51364: PUSH
51365: LD_VAR 0 1
51369: PPUSH
51370: CALL 51057 0 1
51374: ST_TO_ADDR
// if tmp then
51375: LD_VAR 0 8
51379: IFFALSE 51422
// begin for i in tmp do
51381: LD_ADDR_VAR 0 7
51385: PUSH
51386: LD_VAR 0 8
51390: PUSH
51391: FOR_IN
51392: IFFALSE 51420
// if i [ 1 ] = b_ext_radio then
51394: LD_VAR 0 7
51398: PUSH
51399: LD_INT 1
51401: ARRAY
51402: PUSH
51403: LD_INT 22
51405: EQUAL
51406: IFFALSE 51418
// begin control := control_remote ;
51408: LD_ADDR_VAR 0 4
51412: PUSH
51413: LD_INT 2
51415: ST_TO_ADDR
// break ;
51416: GO 51420
// end ;
51418: GO 51391
51420: POP
51421: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
51422: LD_VAR 0 1
51426: PPUSH
51427: LD_VAR 0 2
51431: PPUSH
51432: LD_VAR 0 3
51436: PPUSH
51437: LD_VAR 0 4
51441: PPUSH
51442: LD_VAR 0 5
51446: PPUSH
51447: CALL_OW 448
51451: IFFALSE 51486
// begin result := [ chassis , engine , control , weapon ] ;
51453: LD_ADDR_VAR 0 6
51457: PUSH
51458: LD_VAR 0 2
51462: PUSH
51463: LD_VAR 0 3
51467: PUSH
51468: LD_VAR 0 4
51472: PUSH
51473: LD_VAR 0 5
51477: PUSH
51478: EMPTY
51479: LIST
51480: LIST
51481: LIST
51482: LIST
51483: ST_TO_ADDR
// exit ;
51484: GO 51898
// end ; _chassis := AvailableChassisList ( factory ) ;
51486: LD_ADDR_VAR 0 9
51490: PUSH
51491: LD_VAR 0 1
51495: PPUSH
51496: CALL_OW 475
51500: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
51501: LD_ADDR_VAR 0 11
51505: PUSH
51506: LD_VAR 0 1
51510: PPUSH
51511: CALL_OW 476
51515: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
51516: LD_ADDR_VAR 0 12
51520: PUSH
51521: LD_VAR 0 1
51525: PPUSH
51526: CALL_OW 477
51530: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
51531: LD_ADDR_VAR 0 10
51535: PUSH
51536: LD_VAR 0 1
51540: PPUSH
51541: CALL_OW 478
51545: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
51546: LD_VAR 0 9
51550: NOT
51551: PUSH
51552: LD_VAR 0 11
51556: NOT
51557: OR
51558: PUSH
51559: LD_VAR 0 12
51563: NOT
51564: OR
51565: PUSH
51566: LD_VAR 0 10
51570: NOT
51571: OR
51572: IFFALSE 51607
// begin result := [ chassis , engine , control , weapon ] ;
51574: LD_ADDR_VAR 0 6
51578: PUSH
51579: LD_VAR 0 2
51583: PUSH
51584: LD_VAR 0 3
51588: PUSH
51589: LD_VAR 0 4
51593: PUSH
51594: LD_VAR 0 5
51598: PUSH
51599: EMPTY
51600: LIST
51601: LIST
51602: LIST
51603: LIST
51604: ST_TO_ADDR
// exit ;
51605: GO 51898
// end ; if not chassis in _chassis then
51607: LD_VAR 0 2
51611: PUSH
51612: LD_VAR 0 9
51616: IN
51617: NOT
51618: IFFALSE 51644
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
51620: LD_ADDR_VAR 0 2
51624: PUSH
51625: LD_VAR 0 9
51629: PUSH
51630: LD_INT 1
51632: PPUSH
51633: LD_VAR 0 9
51637: PPUSH
51638: CALL_OW 12
51642: ARRAY
51643: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
51644: LD_VAR 0 2
51648: PPUSH
51649: LD_VAR 0 3
51653: PPUSH
51654: CALL 51903 0 2
51658: NOT
51659: IFFALSE 51718
// repeat engine := _engine [ 1 ] ;
51661: LD_ADDR_VAR 0 3
51665: PUSH
51666: LD_VAR 0 11
51670: PUSH
51671: LD_INT 1
51673: ARRAY
51674: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
51675: LD_ADDR_VAR 0 11
51679: PUSH
51680: LD_VAR 0 11
51684: PPUSH
51685: LD_INT 1
51687: PPUSH
51688: CALL_OW 3
51692: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
51693: LD_VAR 0 2
51697: PPUSH
51698: LD_VAR 0 3
51702: PPUSH
51703: CALL 51903 0 2
51707: PUSH
51708: LD_VAR 0 11
51712: PUSH
51713: EMPTY
51714: EQUAL
51715: OR
51716: IFFALSE 51661
// if not control in _control then
51718: LD_VAR 0 4
51722: PUSH
51723: LD_VAR 0 12
51727: IN
51728: NOT
51729: IFFALSE 51755
// control := _control [ rand ( 1 , _control ) ] ;
51731: LD_ADDR_VAR 0 4
51735: PUSH
51736: LD_VAR 0 12
51740: PUSH
51741: LD_INT 1
51743: PPUSH
51744: LD_VAR 0 12
51748: PPUSH
51749: CALL_OW 12
51753: ARRAY
51754: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
51755: LD_VAR 0 2
51759: PPUSH
51760: LD_VAR 0 5
51764: PPUSH
51765: CALL 52123 0 2
51769: NOT
51770: IFFALSE 51829
// repeat weapon := _weapon [ 1 ] ;
51772: LD_ADDR_VAR 0 5
51776: PUSH
51777: LD_VAR 0 10
51781: PUSH
51782: LD_INT 1
51784: ARRAY
51785: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
51786: LD_ADDR_VAR 0 10
51790: PUSH
51791: LD_VAR 0 10
51795: PPUSH
51796: LD_INT 1
51798: PPUSH
51799: CALL_OW 3
51803: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
51804: LD_VAR 0 2
51808: PPUSH
51809: LD_VAR 0 5
51813: PPUSH
51814: CALL 52123 0 2
51818: PUSH
51819: LD_VAR 0 10
51823: PUSH
51824: EMPTY
51825: EQUAL
51826: OR
51827: IFFALSE 51772
// result := [ ] ;
51829: LD_ADDR_VAR 0 6
51833: PUSH
51834: EMPTY
51835: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
51836: LD_VAR 0 1
51840: PPUSH
51841: LD_VAR 0 2
51845: PPUSH
51846: LD_VAR 0 3
51850: PPUSH
51851: LD_VAR 0 4
51855: PPUSH
51856: LD_VAR 0 5
51860: PPUSH
51861: CALL_OW 448
51865: IFFALSE 51898
// result := [ chassis , engine , control , weapon ] ;
51867: LD_ADDR_VAR 0 6
51871: PUSH
51872: LD_VAR 0 2
51876: PUSH
51877: LD_VAR 0 3
51881: PUSH
51882: LD_VAR 0 4
51886: PUSH
51887: LD_VAR 0 5
51891: PUSH
51892: EMPTY
51893: LIST
51894: LIST
51895: LIST
51896: LIST
51897: ST_TO_ADDR
// end ;
51898: LD_VAR 0 6
51902: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
51903: LD_INT 0
51905: PPUSH
// if not chassis or not engine then
51906: LD_VAR 0 1
51910: NOT
51911: PUSH
51912: LD_VAR 0 2
51916: NOT
51917: OR
51918: IFFALSE 51922
// exit ;
51920: GO 52118
// case engine of engine_solar :
51922: LD_VAR 0 2
51926: PUSH
51927: LD_INT 2
51929: DOUBLE
51930: EQUAL
51931: IFTRUE 51935
51933: GO 51973
51935: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
51936: LD_ADDR_VAR 0 3
51940: PUSH
51941: LD_INT 11
51943: PUSH
51944: LD_INT 12
51946: PUSH
51947: LD_INT 13
51949: PUSH
51950: LD_INT 14
51952: PUSH
51953: LD_INT 1
51955: PUSH
51956: LD_INT 2
51958: PUSH
51959: LD_INT 3
51961: PUSH
51962: EMPTY
51963: LIST
51964: LIST
51965: LIST
51966: LIST
51967: LIST
51968: LIST
51969: LIST
51970: ST_TO_ADDR
51971: GO 52102
51973: LD_INT 1
51975: DOUBLE
51976: EQUAL
51977: IFTRUE 51981
51979: GO 52043
51981: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
51982: LD_ADDR_VAR 0 3
51986: PUSH
51987: LD_INT 11
51989: PUSH
51990: LD_INT 12
51992: PUSH
51993: LD_INT 13
51995: PUSH
51996: LD_INT 14
51998: PUSH
51999: LD_INT 1
52001: PUSH
52002: LD_INT 2
52004: PUSH
52005: LD_INT 3
52007: PUSH
52008: LD_INT 4
52010: PUSH
52011: LD_INT 5
52013: PUSH
52014: LD_INT 21
52016: PUSH
52017: LD_INT 23
52019: PUSH
52020: LD_INT 22
52022: PUSH
52023: LD_INT 24
52025: PUSH
52026: EMPTY
52027: LIST
52028: LIST
52029: LIST
52030: LIST
52031: LIST
52032: LIST
52033: LIST
52034: LIST
52035: LIST
52036: LIST
52037: LIST
52038: LIST
52039: LIST
52040: ST_TO_ADDR
52041: GO 52102
52043: LD_INT 3
52045: DOUBLE
52046: EQUAL
52047: IFTRUE 52051
52049: GO 52101
52051: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
52052: LD_ADDR_VAR 0 3
52056: PUSH
52057: LD_INT 13
52059: PUSH
52060: LD_INT 14
52062: PUSH
52063: LD_INT 2
52065: PUSH
52066: LD_INT 3
52068: PUSH
52069: LD_INT 4
52071: PUSH
52072: LD_INT 5
52074: PUSH
52075: LD_INT 21
52077: PUSH
52078: LD_INT 22
52080: PUSH
52081: LD_INT 23
52083: PUSH
52084: LD_INT 24
52086: PUSH
52087: EMPTY
52088: LIST
52089: LIST
52090: LIST
52091: LIST
52092: LIST
52093: LIST
52094: LIST
52095: LIST
52096: LIST
52097: LIST
52098: ST_TO_ADDR
52099: GO 52102
52101: POP
// result := ( chassis in result ) ;
52102: LD_ADDR_VAR 0 3
52106: PUSH
52107: LD_VAR 0 1
52111: PUSH
52112: LD_VAR 0 3
52116: IN
52117: ST_TO_ADDR
// end ;
52118: LD_VAR 0 3
52122: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
52123: LD_INT 0
52125: PPUSH
// if not chassis or not weapon then
52126: LD_VAR 0 1
52130: NOT
52131: PUSH
52132: LD_VAR 0 2
52136: NOT
52137: OR
52138: IFFALSE 52142
// exit ;
52140: GO 53202
// case weapon of us_machine_gun :
52142: LD_VAR 0 2
52146: PUSH
52147: LD_INT 2
52149: DOUBLE
52150: EQUAL
52151: IFTRUE 52155
52153: GO 52185
52155: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
52156: LD_ADDR_VAR 0 3
52160: PUSH
52161: LD_INT 1
52163: PUSH
52164: LD_INT 2
52166: PUSH
52167: LD_INT 3
52169: PUSH
52170: LD_INT 4
52172: PUSH
52173: LD_INT 5
52175: PUSH
52176: EMPTY
52177: LIST
52178: LIST
52179: LIST
52180: LIST
52181: LIST
52182: ST_TO_ADDR
52183: GO 53186
52185: LD_INT 3
52187: DOUBLE
52188: EQUAL
52189: IFTRUE 52193
52191: GO 52223
52193: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
52194: LD_ADDR_VAR 0 3
52198: PUSH
52199: LD_INT 1
52201: PUSH
52202: LD_INT 2
52204: PUSH
52205: LD_INT 3
52207: PUSH
52208: LD_INT 4
52210: PUSH
52211: LD_INT 5
52213: PUSH
52214: EMPTY
52215: LIST
52216: LIST
52217: LIST
52218: LIST
52219: LIST
52220: ST_TO_ADDR
52221: GO 53186
52223: LD_INT 11
52225: DOUBLE
52226: EQUAL
52227: IFTRUE 52231
52229: GO 52261
52231: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
52232: LD_ADDR_VAR 0 3
52236: PUSH
52237: LD_INT 1
52239: PUSH
52240: LD_INT 2
52242: PUSH
52243: LD_INT 3
52245: PUSH
52246: LD_INT 4
52248: PUSH
52249: LD_INT 5
52251: PUSH
52252: EMPTY
52253: LIST
52254: LIST
52255: LIST
52256: LIST
52257: LIST
52258: ST_TO_ADDR
52259: GO 53186
52261: LD_INT 4
52263: DOUBLE
52264: EQUAL
52265: IFTRUE 52269
52267: GO 52295
52269: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
52270: LD_ADDR_VAR 0 3
52274: PUSH
52275: LD_INT 2
52277: PUSH
52278: LD_INT 3
52280: PUSH
52281: LD_INT 4
52283: PUSH
52284: LD_INT 5
52286: PUSH
52287: EMPTY
52288: LIST
52289: LIST
52290: LIST
52291: LIST
52292: ST_TO_ADDR
52293: GO 53186
52295: LD_INT 5
52297: DOUBLE
52298: EQUAL
52299: IFTRUE 52303
52301: GO 52329
52303: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
52304: LD_ADDR_VAR 0 3
52308: PUSH
52309: LD_INT 2
52311: PUSH
52312: LD_INT 3
52314: PUSH
52315: LD_INT 4
52317: PUSH
52318: LD_INT 5
52320: PUSH
52321: EMPTY
52322: LIST
52323: LIST
52324: LIST
52325: LIST
52326: ST_TO_ADDR
52327: GO 53186
52329: LD_INT 9
52331: DOUBLE
52332: EQUAL
52333: IFTRUE 52337
52335: GO 52363
52337: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
52338: LD_ADDR_VAR 0 3
52342: PUSH
52343: LD_INT 2
52345: PUSH
52346: LD_INT 3
52348: PUSH
52349: LD_INT 4
52351: PUSH
52352: LD_INT 5
52354: PUSH
52355: EMPTY
52356: LIST
52357: LIST
52358: LIST
52359: LIST
52360: ST_TO_ADDR
52361: GO 53186
52363: LD_INT 7
52365: DOUBLE
52366: EQUAL
52367: IFTRUE 52371
52369: GO 52397
52371: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
52372: LD_ADDR_VAR 0 3
52376: PUSH
52377: LD_INT 2
52379: PUSH
52380: LD_INT 3
52382: PUSH
52383: LD_INT 4
52385: PUSH
52386: LD_INT 5
52388: PUSH
52389: EMPTY
52390: LIST
52391: LIST
52392: LIST
52393: LIST
52394: ST_TO_ADDR
52395: GO 53186
52397: LD_INT 12
52399: DOUBLE
52400: EQUAL
52401: IFTRUE 52405
52403: GO 52431
52405: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
52406: LD_ADDR_VAR 0 3
52410: PUSH
52411: LD_INT 2
52413: PUSH
52414: LD_INT 3
52416: PUSH
52417: LD_INT 4
52419: PUSH
52420: LD_INT 5
52422: PUSH
52423: EMPTY
52424: LIST
52425: LIST
52426: LIST
52427: LIST
52428: ST_TO_ADDR
52429: GO 53186
52431: LD_INT 13
52433: DOUBLE
52434: EQUAL
52435: IFTRUE 52439
52437: GO 52465
52439: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
52440: LD_ADDR_VAR 0 3
52444: PUSH
52445: LD_INT 2
52447: PUSH
52448: LD_INT 3
52450: PUSH
52451: LD_INT 4
52453: PUSH
52454: LD_INT 5
52456: PUSH
52457: EMPTY
52458: LIST
52459: LIST
52460: LIST
52461: LIST
52462: ST_TO_ADDR
52463: GO 53186
52465: LD_INT 14
52467: DOUBLE
52468: EQUAL
52469: IFTRUE 52473
52471: GO 52491
52473: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
52474: LD_ADDR_VAR 0 3
52478: PUSH
52479: LD_INT 4
52481: PUSH
52482: LD_INT 5
52484: PUSH
52485: EMPTY
52486: LIST
52487: LIST
52488: ST_TO_ADDR
52489: GO 53186
52491: LD_INT 6
52493: DOUBLE
52494: EQUAL
52495: IFTRUE 52499
52497: GO 52517
52499: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
52500: LD_ADDR_VAR 0 3
52504: PUSH
52505: LD_INT 4
52507: PUSH
52508: LD_INT 5
52510: PUSH
52511: EMPTY
52512: LIST
52513: LIST
52514: ST_TO_ADDR
52515: GO 53186
52517: LD_INT 10
52519: DOUBLE
52520: EQUAL
52521: IFTRUE 52525
52523: GO 52543
52525: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
52526: LD_ADDR_VAR 0 3
52530: PUSH
52531: LD_INT 4
52533: PUSH
52534: LD_INT 5
52536: PUSH
52537: EMPTY
52538: LIST
52539: LIST
52540: ST_TO_ADDR
52541: GO 53186
52543: LD_INT 22
52545: DOUBLE
52546: EQUAL
52547: IFTRUE 52551
52549: GO 52577
52551: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
52552: LD_ADDR_VAR 0 3
52556: PUSH
52557: LD_INT 11
52559: PUSH
52560: LD_INT 12
52562: PUSH
52563: LD_INT 13
52565: PUSH
52566: LD_INT 14
52568: PUSH
52569: EMPTY
52570: LIST
52571: LIST
52572: LIST
52573: LIST
52574: ST_TO_ADDR
52575: GO 53186
52577: LD_INT 23
52579: DOUBLE
52580: EQUAL
52581: IFTRUE 52585
52583: GO 52611
52585: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
52586: LD_ADDR_VAR 0 3
52590: PUSH
52591: LD_INT 11
52593: PUSH
52594: LD_INT 12
52596: PUSH
52597: LD_INT 13
52599: PUSH
52600: LD_INT 14
52602: PUSH
52603: EMPTY
52604: LIST
52605: LIST
52606: LIST
52607: LIST
52608: ST_TO_ADDR
52609: GO 53186
52611: LD_INT 24
52613: DOUBLE
52614: EQUAL
52615: IFTRUE 52619
52617: GO 52645
52619: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
52620: LD_ADDR_VAR 0 3
52624: PUSH
52625: LD_INT 11
52627: PUSH
52628: LD_INT 12
52630: PUSH
52631: LD_INT 13
52633: PUSH
52634: LD_INT 14
52636: PUSH
52637: EMPTY
52638: LIST
52639: LIST
52640: LIST
52641: LIST
52642: ST_TO_ADDR
52643: GO 53186
52645: LD_INT 30
52647: DOUBLE
52648: EQUAL
52649: IFTRUE 52653
52651: GO 52679
52653: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
52654: LD_ADDR_VAR 0 3
52658: PUSH
52659: LD_INT 11
52661: PUSH
52662: LD_INT 12
52664: PUSH
52665: LD_INT 13
52667: PUSH
52668: LD_INT 14
52670: PUSH
52671: EMPTY
52672: LIST
52673: LIST
52674: LIST
52675: LIST
52676: ST_TO_ADDR
52677: GO 53186
52679: LD_INT 25
52681: DOUBLE
52682: EQUAL
52683: IFTRUE 52687
52685: GO 52705
52687: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
52688: LD_ADDR_VAR 0 3
52692: PUSH
52693: LD_INT 13
52695: PUSH
52696: LD_INT 14
52698: PUSH
52699: EMPTY
52700: LIST
52701: LIST
52702: ST_TO_ADDR
52703: GO 53186
52705: LD_INT 27
52707: DOUBLE
52708: EQUAL
52709: IFTRUE 52713
52711: GO 52731
52713: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
52714: LD_ADDR_VAR 0 3
52718: PUSH
52719: LD_INT 13
52721: PUSH
52722: LD_INT 14
52724: PUSH
52725: EMPTY
52726: LIST
52727: LIST
52728: ST_TO_ADDR
52729: GO 53186
52731: LD_INT 92
52733: DOUBLE
52734: EQUAL
52735: IFTRUE 52739
52737: GO 52765
52739: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
52740: LD_ADDR_VAR 0 3
52744: PUSH
52745: LD_INT 11
52747: PUSH
52748: LD_INT 12
52750: PUSH
52751: LD_INT 13
52753: PUSH
52754: LD_INT 14
52756: PUSH
52757: EMPTY
52758: LIST
52759: LIST
52760: LIST
52761: LIST
52762: ST_TO_ADDR
52763: GO 53186
52765: LD_INT 28
52767: DOUBLE
52768: EQUAL
52769: IFTRUE 52773
52771: GO 52791
52773: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
52774: LD_ADDR_VAR 0 3
52778: PUSH
52779: LD_INT 13
52781: PUSH
52782: LD_INT 14
52784: PUSH
52785: EMPTY
52786: LIST
52787: LIST
52788: ST_TO_ADDR
52789: GO 53186
52791: LD_INT 29
52793: DOUBLE
52794: EQUAL
52795: IFTRUE 52799
52797: GO 52817
52799: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
52800: LD_ADDR_VAR 0 3
52804: PUSH
52805: LD_INT 13
52807: PUSH
52808: LD_INT 14
52810: PUSH
52811: EMPTY
52812: LIST
52813: LIST
52814: ST_TO_ADDR
52815: GO 53186
52817: LD_INT 31
52819: DOUBLE
52820: EQUAL
52821: IFTRUE 52825
52823: GO 52843
52825: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
52826: LD_ADDR_VAR 0 3
52830: PUSH
52831: LD_INT 13
52833: PUSH
52834: LD_INT 14
52836: PUSH
52837: EMPTY
52838: LIST
52839: LIST
52840: ST_TO_ADDR
52841: GO 53186
52843: LD_INT 26
52845: DOUBLE
52846: EQUAL
52847: IFTRUE 52851
52849: GO 52869
52851: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
52852: LD_ADDR_VAR 0 3
52856: PUSH
52857: LD_INT 13
52859: PUSH
52860: LD_INT 14
52862: PUSH
52863: EMPTY
52864: LIST
52865: LIST
52866: ST_TO_ADDR
52867: GO 53186
52869: LD_INT 42
52871: DOUBLE
52872: EQUAL
52873: IFTRUE 52877
52875: GO 52903
52877: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
52878: LD_ADDR_VAR 0 3
52882: PUSH
52883: LD_INT 21
52885: PUSH
52886: LD_INT 22
52888: PUSH
52889: LD_INT 23
52891: PUSH
52892: LD_INT 24
52894: PUSH
52895: EMPTY
52896: LIST
52897: LIST
52898: LIST
52899: LIST
52900: ST_TO_ADDR
52901: GO 53186
52903: LD_INT 43
52905: DOUBLE
52906: EQUAL
52907: IFTRUE 52911
52909: GO 52937
52911: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
52912: LD_ADDR_VAR 0 3
52916: PUSH
52917: LD_INT 21
52919: PUSH
52920: LD_INT 22
52922: PUSH
52923: LD_INT 23
52925: PUSH
52926: LD_INT 24
52928: PUSH
52929: EMPTY
52930: LIST
52931: LIST
52932: LIST
52933: LIST
52934: ST_TO_ADDR
52935: GO 53186
52937: LD_INT 44
52939: DOUBLE
52940: EQUAL
52941: IFTRUE 52945
52943: GO 52971
52945: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
52946: LD_ADDR_VAR 0 3
52950: PUSH
52951: LD_INT 21
52953: PUSH
52954: LD_INT 22
52956: PUSH
52957: LD_INT 23
52959: PUSH
52960: LD_INT 24
52962: PUSH
52963: EMPTY
52964: LIST
52965: LIST
52966: LIST
52967: LIST
52968: ST_TO_ADDR
52969: GO 53186
52971: LD_INT 45
52973: DOUBLE
52974: EQUAL
52975: IFTRUE 52979
52977: GO 53005
52979: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
52980: LD_ADDR_VAR 0 3
52984: PUSH
52985: LD_INT 21
52987: PUSH
52988: LD_INT 22
52990: PUSH
52991: LD_INT 23
52993: PUSH
52994: LD_INT 24
52996: PUSH
52997: EMPTY
52998: LIST
52999: LIST
53000: LIST
53001: LIST
53002: ST_TO_ADDR
53003: GO 53186
53005: LD_INT 49
53007: DOUBLE
53008: EQUAL
53009: IFTRUE 53013
53011: GO 53039
53013: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
53014: LD_ADDR_VAR 0 3
53018: PUSH
53019: LD_INT 21
53021: PUSH
53022: LD_INT 22
53024: PUSH
53025: LD_INT 23
53027: PUSH
53028: LD_INT 24
53030: PUSH
53031: EMPTY
53032: LIST
53033: LIST
53034: LIST
53035: LIST
53036: ST_TO_ADDR
53037: GO 53186
53039: LD_INT 51
53041: DOUBLE
53042: EQUAL
53043: IFTRUE 53047
53045: GO 53073
53047: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
53048: LD_ADDR_VAR 0 3
53052: PUSH
53053: LD_INT 21
53055: PUSH
53056: LD_INT 22
53058: PUSH
53059: LD_INT 23
53061: PUSH
53062: LD_INT 24
53064: PUSH
53065: EMPTY
53066: LIST
53067: LIST
53068: LIST
53069: LIST
53070: ST_TO_ADDR
53071: GO 53186
53073: LD_INT 52
53075: DOUBLE
53076: EQUAL
53077: IFTRUE 53081
53079: GO 53107
53081: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
53082: LD_ADDR_VAR 0 3
53086: PUSH
53087: LD_INT 21
53089: PUSH
53090: LD_INT 22
53092: PUSH
53093: LD_INT 23
53095: PUSH
53096: LD_INT 24
53098: PUSH
53099: EMPTY
53100: LIST
53101: LIST
53102: LIST
53103: LIST
53104: ST_TO_ADDR
53105: GO 53186
53107: LD_INT 53
53109: DOUBLE
53110: EQUAL
53111: IFTRUE 53115
53113: GO 53133
53115: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
53116: LD_ADDR_VAR 0 3
53120: PUSH
53121: LD_INT 23
53123: PUSH
53124: LD_INT 24
53126: PUSH
53127: EMPTY
53128: LIST
53129: LIST
53130: ST_TO_ADDR
53131: GO 53186
53133: LD_INT 46
53135: DOUBLE
53136: EQUAL
53137: IFTRUE 53141
53139: GO 53159
53141: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
53142: LD_ADDR_VAR 0 3
53146: PUSH
53147: LD_INT 23
53149: PUSH
53150: LD_INT 24
53152: PUSH
53153: EMPTY
53154: LIST
53155: LIST
53156: ST_TO_ADDR
53157: GO 53186
53159: LD_INT 47
53161: DOUBLE
53162: EQUAL
53163: IFTRUE 53167
53165: GO 53185
53167: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
53168: LD_ADDR_VAR 0 3
53172: PUSH
53173: LD_INT 23
53175: PUSH
53176: LD_INT 24
53178: PUSH
53179: EMPTY
53180: LIST
53181: LIST
53182: ST_TO_ADDR
53183: GO 53186
53185: POP
// result := ( chassis in result ) ;
53186: LD_ADDR_VAR 0 3
53190: PUSH
53191: LD_VAR 0 1
53195: PUSH
53196: LD_VAR 0 3
53200: IN
53201: ST_TO_ADDR
// end ;
53202: LD_VAR 0 3
53206: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
53207: LD_INT 0
53209: PPUSH
53210: PPUSH
53211: PPUSH
53212: PPUSH
53213: PPUSH
53214: PPUSH
53215: PPUSH
// result := array ;
53216: LD_ADDR_VAR 0 5
53220: PUSH
53221: LD_VAR 0 1
53225: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
53226: LD_VAR 0 1
53230: NOT
53231: PUSH
53232: LD_VAR 0 2
53236: NOT
53237: OR
53238: PUSH
53239: LD_VAR 0 3
53243: NOT
53244: OR
53245: PUSH
53246: LD_VAR 0 2
53250: PUSH
53251: LD_VAR 0 1
53255: GREATER
53256: OR
53257: PUSH
53258: LD_VAR 0 3
53262: PUSH
53263: LD_VAR 0 1
53267: GREATER
53268: OR
53269: IFFALSE 53273
// exit ;
53271: GO 53569
// if direction then
53273: LD_VAR 0 4
53277: IFFALSE 53341
// begin d := 1 ;
53279: LD_ADDR_VAR 0 9
53283: PUSH
53284: LD_INT 1
53286: ST_TO_ADDR
// if i_from > i_to then
53287: LD_VAR 0 2
53291: PUSH
53292: LD_VAR 0 3
53296: GREATER
53297: IFFALSE 53323
// length := ( array - i_from ) + i_to else
53299: LD_ADDR_VAR 0 11
53303: PUSH
53304: LD_VAR 0 1
53308: PUSH
53309: LD_VAR 0 2
53313: MINUS
53314: PUSH
53315: LD_VAR 0 3
53319: PLUS
53320: ST_TO_ADDR
53321: GO 53339
// length := i_to - i_from ;
53323: LD_ADDR_VAR 0 11
53327: PUSH
53328: LD_VAR 0 3
53332: PUSH
53333: LD_VAR 0 2
53337: MINUS
53338: ST_TO_ADDR
// end else
53339: GO 53402
// begin d := - 1 ;
53341: LD_ADDR_VAR 0 9
53345: PUSH
53346: LD_INT 1
53348: NEG
53349: ST_TO_ADDR
// if i_from > i_to then
53350: LD_VAR 0 2
53354: PUSH
53355: LD_VAR 0 3
53359: GREATER
53360: IFFALSE 53380
// length := i_from - i_to else
53362: LD_ADDR_VAR 0 11
53366: PUSH
53367: LD_VAR 0 2
53371: PUSH
53372: LD_VAR 0 3
53376: MINUS
53377: ST_TO_ADDR
53378: GO 53402
// length := ( array - i_to ) + i_from ;
53380: LD_ADDR_VAR 0 11
53384: PUSH
53385: LD_VAR 0 1
53389: PUSH
53390: LD_VAR 0 3
53394: MINUS
53395: PUSH
53396: LD_VAR 0 2
53400: PLUS
53401: ST_TO_ADDR
// end ; if not length then
53402: LD_VAR 0 11
53406: NOT
53407: IFFALSE 53411
// exit ;
53409: GO 53569
// tmp := array ;
53411: LD_ADDR_VAR 0 10
53415: PUSH
53416: LD_VAR 0 1
53420: ST_TO_ADDR
// for i = 1 to length do
53421: LD_ADDR_VAR 0 6
53425: PUSH
53426: DOUBLE
53427: LD_INT 1
53429: DEC
53430: ST_TO_ADDR
53431: LD_VAR 0 11
53435: PUSH
53436: FOR_TO
53437: IFFALSE 53557
// begin for j = 1 to array do
53439: LD_ADDR_VAR 0 7
53443: PUSH
53444: DOUBLE
53445: LD_INT 1
53447: DEC
53448: ST_TO_ADDR
53449: LD_VAR 0 1
53453: PUSH
53454: FOR_TO
53455: IFFALSE 53543
// begin k := j + d ;
53457: LD_ADDR_VAR 0 8
53461: PUSH
53462: LD_VAR 0 7
53466: PUSH
53467: LD_VAR 0 9
53471: PLUS
53472: ST_TO_ADDR
// if k > array then
53473: LD_VAR 0 8
53477: PUSH
53478: LD_VAR 0 1
53482: GREATER
53483: IFFALSE 53493
// k := 1 ;
53485: LD_ADDR_VAR 0 8
53489: PUSH
53490: LD_INT 1
53492: ST_TO_ADDR
// if not k then
53493: LD_VAR 0 8
53497: NOT
53498: IFFALSE 53510
// k := array ;
53500: LD_ADDR_VAR 0 8
53504: PUSH
53505: LD_VAR 0 1
53509: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
53510: LD_ADDR_VAR 0 10
53514: PUSH
53515: LD_VAR 0 10
53519: PPUSH
53520: LD_VAR 0 8
53524: PPUSH
53525: LD_VAR 0 1
53529: PUSH
53530: LD_VAR 0 7
53534: ARRAY
53535: PPUSH
53536: CALL_OW 1
53540: ST_TO_ADDR
// end ;
53541: GO 53454
53543: POP
53544: POP
// array := tmp ;
53545: LD_ADDR_VAR 0 1
53549: PUSH
53550: LD_VAR 0 10
53554: ST_TO_ADDR
// end ;
53555: GO 53436
53557: POP
53558: POP
// result := array ;
53559: LD_ADDR_VAR 0 5
53563: PUSH
53564: LD_VAR 0 1
53568: ST_TO_ADDR
// end ;
53569: LD_VAR 0 5
53573: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
53574: LD_INT 0
53576: PPUSH
53577: PPUSH
// result := 0 ;
53578: LD_ADDR_VAR 0 3
53582: PUSH
53583: LD_INT 0
53585: ST_TO_ADDR
// if not array or not value in array then
53586: LD_VAR 0 1
53590: NOT
53591: PUSH
53592: LD_VAR 0 2
53596: PUSH
53597: LD_VAR 0 1
53601: IN
53602: NOT
53603: OR
53604: IFFALSE 53608
// exit ;
53606: GO 53662
// for i = 1 to array do
53608: LD_ADDR_VAR 0 4
53612: PUSH
53613: DOUBLE
53614: LD_INT 1
53616: DEC
53617: ST_TO_ADDR
53618: LD_VAR 0 1
53622: PUSH
53623: FOR_TO
53624: IFFALSE 53660
// if value = array [ i ] then
53626: LD_VAR 0 2
53630: PUSH
53631: LD_VAR 0 1
53635: PUSH
53636: LD_VAR 0 4
53640: ARRAY
53641: EQUAL
53642: IFFALSE 53658
// begin result := i ;
53644: LD_ADDR_VAR 0 3
53648: PUSH
53649: LD_VAR 0 4
53653: ST_TO_ADDR
// exit ;
53654: POP
53655: POP
53656: GO 53662
// end ;
53658: GO 53623
53660: POP
53661: POP
// end ;
53662: LD_VAR 0 3
53666: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
53667: LD_INT 0
53669: PPUSH
// vc_chassis := chassis ;
53670: LD_ADDR_OWVAR 37
53674: PUSH
53675: LD_VAR 0 1
53679: ST_TO_ADDR
// vc_engine := engine ;
53680: LD_ADDR_OWVAR 39
53684: PUSH
53685: LD_VAR 0 2
53689: ST_TO_ADDR
// vc_control := control ;
53690: LD_ADDR_OWVAR 38
53694: PUSH
53695: LD_VAR 0 3
53699: ST_TO_ADDR
// vc_weapon := weapon ;
53700: LD_ADDR_OWVAR 40
53704: PUSH
53705: LD_VAR 0 4
53709: ST_TO_ADDR
// vc_fuel_battery := fuel ;
53710: LD_ADDR_OWVAR 41
53714: PUSH
53715: LD_VAR 0 5
53719: ST_TO_ADDR
// end ;
53720: LD_VAR 0 6
53724: RET
// export function WantPlant ( unit ) ; var task ; begin
53725: LD_INT 0
53727: PPUSH
53728: PPUSH
// result := false ;
53729: LD_ADDR_VAR 0 2
53733: PUSH
53734: LD_INT 0
53736: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
53737: LD_ADDR_VAR 0 3
53741: PUSH
53742: LD_VAR 0 1
53746: PPUSH
53747: CALL_OW 437
53751: ST_TO_ADDR
// if task then
53752: LD_VAR 0 3
53756: IFFALSE 53784
// if task [ 1 ] [ 1 ] = p then
53758: LD_VAR 0 3
53762: PUSH
53763: LD_INT 1
53765: ARRAY
53766: PUSH
53767: LD_INT 1
53769: ARRAY
53770: PUSH
53771: LD_STRING p
53773: EQUAL
53774: IFFALSE 53784
// result := true ;
53776: LD_ADDR_VAR 0 2
53780: PUSH
53781: LD_INT 1
53783: ST_TO_ADDR
// end ;
53784: LD_VAR 0 2
53788: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
53789: LD_INT 0
53791: PPUSH
53792: PPUSH
53793: PPUSH
53794: PPUSH
// if pos < 1 then
53795: LD_VAR 0 2
53799: PUSH
53800: LD_INT 1
53802: LESS
53803: IFFALSE 53807
// exit ;
53805: GO 54110
// if pos = 1 then
53807: LD_VAR 0 2
53811: PUSH
53812: LD_INT 1
53814: EQUAL
53815: IFFALSE 53848
// result := Replace ( arr , pos [ 1 ] , value ) else
53817: LD_ADDR_VAR 0 4
53821: PUSH
53822: LD_VAR 0 1
53826: PPUSH
53827: LD_VAR 0 2
53831: PUSH
53832: LD_INT 1
53834: ARRAY
53835: PPUSH
53836: LD_VAR 0 3
53840: PPUSH
53841: CALL_OW 1
53845: ST_TO_ADDR
53846: GO 54110
// begin tmp := arr ;
53848: LD_ADDR_VAR 0 6
53852: PUSH
53853: LD_VAR 0 1
53857: ST_TO_ADDR
// s_arr := [ tmp ] ;
53858: LD_ADDR_VAR 0 7
53862: PUSH
53863: LD_VAR 0 6
53867: PUSH
53868: EMPTY
53869: LIST
53870: ST_TO_ADDR
// for i = 1 to pos - 1 do
53871: LD_ADDR_VAR 0 5
53875: PUSH
53876: DOUBLE
53877: LD_INT 1
53879: DEC
53880: ST_TO_ADDR
53881: LD_VAR 0 2
53885: PUSH
53886: LD_INT 1
53888: MINUS
53889: PUSH
53890: FOR_TO
53891: IFFALSE 53936
// begin tmp := tmp [ pos [ i ] ] ;
53893: LD_ADDR_VAR 0 6
53897: PUSH
53898: LD_VAR 0 6
53902: PUSH
53903: LD_VAR 0 2
53907: PUSH
53908: LD_VAR 0 5
53912: ARRAY
53913: ARRAY
53914: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
53915: LD_ADDR_VAR 0 7
53919: PUSH
53920: LD_VAR 0 7
53924: PUSH
53925: LD_VAR 0 6
53929: PUSH
53930: EMPTY
53931: LIST
53932: ADD
53933: ST_TO_ADDR
// end ;
53934: GO 53890
53936: POP
53937: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
53938: LD_ADDR_VAR 0 6
53942: PUSH
53943: LD_VAR 0 6
53947: PPUSH
53948: LD_VAR 0 2
53952: PUSH
53953: LD_VAR 0 2
53957: ARRAY
53958: PPUSH
53959: LD_VAR 0 3
53963: PPUSH
53964: CALL_OW 1
53968: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
53969: LD_ADDR_VAR 0 7
53973: PUSH
53974: LD_VAR 0 7
53978: PPUSH
53979: LD_VAR 0 7
53983: PPUSH
53984: LD_VAR 0 6
53988: PPUSH
53989: CALL_OW 1
53993: ST_TO_ADDR
// for i = s_arr downto 2 do
53994: LD_ADDR_VAR 0 5
53998: PUSH
53999: DOUBLE
54000: LD_VAR 0 7
54004: INC
54005: ST_TO_ADDR
54006: LD_INT 2
54008: PUSH
54009: FOR_DOWNTO
54010: IFFALSE 54094
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
54012: LD_ADDR_VAR 0 6
54016: PUSH
54017: LD_VAR 0 7
54021: PUSH
54022: LD_VAR 0 5
54026: PUSH
54027: LD_INT 1
54029: MINUS
54030: ARRAY
54031: PPUSH
54032: LD_VAR 0 2
54036: PUSH
54037: LD_VAR 0 5
54041: PUSH
54042: LD_INT 1
54044: MINUS
54045: ARRAY
54046: PPUSH
54047: LD_VAR 0 7
54051: PUSH
54052: LD_VAR 0 5
54056: ARRAY
54057: PPUSH
54058: CALL_OW 1
54062: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
54063: LD_ADDR_VAR 0 7
54067: PUSH
54068: LD_VAR 0 7
54072: PPUSH
54073: LD_VAR 0 5
54077: PUSH
54078: LD_INT 1
54080: MINUS
54081: PPUSH
54082: LD_VAR 0 6
54086: PPUSH
54087: CALL_OW 1
54091: ST_TO_ADDR
// end ;
54092: GO 54009
54094: POP
54095: POP
// result := s_arr [ 1 ] ;
54096: LD_ADDR_VAR 0 4
54100: PUSH
54101: LD_VAR 0 7
54105: PUSH
54106: LD_INT 1
54108: ARRAY
54109: ST_TO_ADDR
// end ; end ;
54110: LD_VAR 0 4
54114: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
54115: LD_INT 0
54117: PPUSH
54118: PPUSH
// if not list then
54119: LD_VAR 0 1
54123: NOT
54124: IFFALSE 54128
// exit ;
54126: GO 54219
// i := list [ pos1 ] ;
54128: LD_ADDR_VAR 0 5
54132: PUSH
54133: LD_VAR 0 1
54137: PUSH
54138: LD_VAR 0 2
54142: ARRAY
54143: ST_TO_ADDR
// if not i then
54144: LD_VAR 0 5
54148: NOT
54149: IFFALSE 54153
// exit ;
54151: GO 54219
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
54153: LD_ADDR_VAR 0 1
54157: PUSH
54158: LD_VAR 0 1
54162: PPUSH
54163: LD_VAR 0 2
54167: PPUSH
54168: LD_VAR 0 1
54172: PUSH
54173: LD_VAR 0 3
54177: ARRAY
54178: PPUSH
54179: CALL_OW 1
54183: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
54184: LD_ADDR_VAR 0 1
54188: PUSH
54189: LD_VAR 0 1
54193: PPUSH
54194: LD_VAR 0 3
54198: PPUSH
54199: LD_VAR 0 5
54203: PPUSH
54204: CALL_OW 1
54208: ST_TO_ADDR
// result := list ;
54209: LD_ADDR_VAR 0 4
54213: PUSH
54214: LD_VAR 0 1
54218: ST_TO_ADDR
// end ;
54219: LD_VAR 0 4
54223: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
54224: LD_INT 0
54226: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
54227: LD_ADDR_VAR 0 5
54231: PUSH
54232: LD_VAR 0 1
54236: PPUSH
54237: CALL_OW 250
54241: PPUSH
54242: LD_VAR 0 1
54246: PPUSH
54247: CALL_OW 251
54251: PPUSH
54252: LD_VAR 0 2
54256: PPUSH
54257: LD_VAR 0 3
54261: PPUSH
54262: LD_VAR 0 4
54266: PPUSH
54267: CALL 54277 0 5
54271: ST_TO_ADDR
// end ;
54272: LD_VAR 0 5
54276: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
54277: LD_INT 0
54279: PPUSH
54280: PPUSH
54281: PPUSH
54282: PPUSH
// if not list then
54283: LD_VAR 0 3
54287: NOT
54288: IFFALSE 54292
// exit ;
54290: GO 54680
// result := [ ] ;
54292: LD_ADDR_VAR 0 6
54296: PUSH
54297: EMPTY
54298: ST_TO_ADDR
// for i in list do
54299: LD_ADDR_VAR 0 7
54303: PUSH
54304: LD_VAR 0 3
54308: PUSH
54309: FOR_IN
54310: IFFALSE 54512
// begin tmp := GetDistUnitXY ( i , x , y ) ;
54312: LD_ADDR_VAR 0 9
54316: PUSH
54317: LD_VAR 0 7
54321: PPUSH
54322: LD_VAR 0 1
54326: PPUSH
54327: LD_VAR 0 2
54331: PPUSH
54332: CALL_OW 297
54336: ST_TO_ADDR
// if not result then
54337: LD_VAR 0 6
54341: NOT
54342: IFFALSE 54368
// result := [ [ i , tmp ] ] else
54344: LD_ADDR_VAR 0 6
54348: PUSH
54349: LD_VAR 0 7
54353: PUSH
54354: LD_VAR 0 9
54358: PUSH
54359: EMPTY
54360: LIST
54361: LIST
54362: PUSH
54363: EMPTY
54364: LIST
54365: ST_TO_ADDR
54366: GO 54510
// begin if result [ result ] [ 2 ] < tmp then
54368: LD_VAR 0 6
54372: PUSH
54373: LD_VAR 0 6
54377: ARRAY
54378: PUSH
54379: LD_INT 2
54381: ARRAY
54382: PUSH
54383: LD_VAR 0 9
54387: LESS
54388: IFFALSE 54430
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
54390: LD_ADDR_VAR 0 6
54394: PUSH
54395: LD_VAR 0 6
54399: PPUSH
54400: LD_VAR 0 6
54404: PUSH
54405: LD_INT 1
54407: PLUS
54408: PPUSH
54409: LD_VAR 0 7
54413: PUSH
54414: LD_VAR 0 9
54418: PUSH
54419: EMPTY
54420: LIST
54421: LIST
54422: PPUSH
54423: CALL_OW 2
54427: ST_TO_ADDR
54428: GO 54510
// for j = 1 to result do
54430: LD_ADDR_VAR 0 8
54434: PUSH
54435: DOUBLE
54436: LD_INT 1
54438: DEC
54439: ST_TO_ADDR
54440: LD_VAR 0 6
54444: PUSH
54445: FOR_TO
54446: IFFALSE 54508
// begin if tmp < result [ j ] [ 2 ] then
54448: LD_VAR 0 9
54452: PUSH
54453: LD_VAR 0 6
54457: PUSH
54458: LD_VAR 0 8
54462: ARRAY
54463: PUSH
54464: LD_INT 2
54466: ARRAY
54467: LESS
54468: IFFALSE 54506
// begin result := Insert ( result , j , [ i , tmp ] ) ;
54470: LD_ADDR_VAR 0 6
54474: PUSH
54475: LD_VAR 0 6
54479: PPUSH
54480: LD_VAR 0 8
54484: PPUSH
54485: LD_VAR 0 7
54489: PUSH
54490: LD_VAR 0 9
54494: PUSH
54495: EMPTY
54496: LIST
54497: LIST
54498: PPUSH
54499: CALL_OW 2
54503: ST_TO_ADDR
// break ;
54504: GO 54508
// end ; end ;
54506: GO 54445
54508: POP
54509: POP
// end ; end ;
54510: GO 54309
54512: POP
54513: POP
// if result and not asc then
54514: LD_VAR 0 6
54518: PUSH
54519: LD_VAR 0 4
54523: NOT
54524: AND
54525: IFFALSE 54600
// begin tmp := result ;
54527: LD_ADDR_VAR 0 9
54531: PUSH
54532: LD_VAR 0 6
54536: ST_TO_ADDR
// for i = tmp downto 1 do
54537: LD_ADDR_VAR 0 7
54541: PUSH
54542: DOUBLE
54543: LD_VAR 0 9
54547: INC
54548: ST_TO_ADDR
54549: LD_INT 1
54551: PUSH
54552: FOR_DOWNTO
54553: IFFALSE 54598
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
54555: LD_ADDR_VAR 0 6
54559: PUSH
54560: LD_VAR 0 6
54564: PPUSH
54565: LD_VAR 0 9
54569: PUSH
54570: LD_VAR 0 7
54574: MINUS
54575: PUSH
54576: LD_INT 1
54578: PLUS
54579: PPUSH
54580: LD_VAR 0 9
54584: PUSH
54585: LD_VAR 0 7
54589: ARRAY
54590: PPUSH
54591: CALL_OW 1
54595: ST_TO_ADDR
54596: GO 54552
54598: POP
54599: POP
// end ; tmp := [ ] ;
54600: LD_ADDR_VAR 0 9
54604: PUSH
54605: EMPTY
54606: ST_TO_ADDR
// if mode then
54607: LD_VAR 0 5
54611: IFFALSE 54680
// begin for i = 1 to result do
54613: LD_ADDR_VAR 0 7
54617: PUSH
54618: DOUBLE
54619: LD_INT 1
54621: DEC
54622: ST_TO_ADDR
54623: LD_VAR 0 6
54627: PUSH
54628: FOR_TO
54629: IFFALSE 54668
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
54631: LD_ADDR_VAR 0 9
54635: PUSH
54636: LD_VAR 0 9
54640: PPUSH
54641: LD_VAR 0 7
54645: PPUSH
54646: LD_VAR 0 6
54650: PUSH
54651: LD_VAR 0 7
54655: ARRAY
54656: PUSH
54657: LD_INT 1
54659: ARRAY
54660: PPUSH
54661: CALL_OW 1
54665: ST_TO_ADDR
54666: GO 54628
54668: POP
54669: POP
// result := tmp ;
54670: LD_ADDR_VAR 0 6
54674: PUSH
54675: LD_VAR 0 9
54679: ST_TO_ADDR
// end ; end ;
54680: LD_VAR 0 6
54684: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
54685: LD_INT 0
54687: PPUSH
54688: PPUSH
54689: PPUSH
54690: PPUSH
54691: PPUSH
54692: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
54693: LD_ADDR_VAR 0 5
54697: PUSH
54698: LD_INT 0
54700: PUSH
54701: LD_INT 0
54703: PUSH
54704: LD_INT 0
54706: PUSH
54707: EMPTY
54708: PUSH
54709: EMPTY
54710: LIST
54711: LIST
54712: LIST
54713: LIST
54714: ST_TO_ADDR
// if not x or not y then
54715: LD_VAR 0 2
54719: NOT
54720: PUSH
54721: LD_VAR 0 3
54725: NOT
54726: OR
54727: IFFALSE 54731
// exit ;
54729: GO 56381
// if not range then
54731: LD_VAR 0 4
54735: NOT
54736: IFFALSE 54746
// range := 10 ;
54738: LD_ADDR_VAR 0 4
54742: PUSH
54743: LD_INT 10
54745: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
54746: LD_ADDR_VAR 0 8
54750: PUSH
54751: LD_INT 81
54753: PUSH
54754: LD_VAR 0 1
54758: PUSH
54759: EMPTY
54760: LIST
54761: LIST
54762: PUSH
54763: LD_INT 92
54765: PUSH
54766: LD_VAR 0 2
54770: PUSH
54771: LD_VAR 0 3
54775: PUSH
54776: LD_VAR 0 4
54780: PUSH
54781: EMPTY
54782: LIST
54783: LIST
54784: LIST
54785: LIST
54786: PUSH
54787: LD_INT 3
54789: PUSH
54790: LD_INT 21
54792: PUSH
54793: LD_INT 3
54795: PUSH
54796: EMPTY
54797: LIST
54798: LIST
54799: PUSH
54800: EMPTY
54801: LIST
54802: LIST
54803: PUSH
54804: EMPTY
54805: LIST
54806: LIST
54807: LIST
54808: PPUSH
54809: CALL_OW 69
54813: ST_TO_ADDR
// if not tmp then
54814: LD_VAR 0 8
54818: NOT
54819: IFFALSE 54823
// exit ;
54821: GO 56381
// for i in tmp do
54823: LD_ADDR_VAR 0 6
54827: PUSH
54828: LD_VAR 0 8
54832: PUSH
54833: FOR_IN
54834: IFFALSE 56356
// begin points := [ 0 , 0 , 0 ] ;
54836: LD_ADDR_VAR 0 9
54840: PUSH
54841: LD_INT 0
54843: PUSH
54844: LD_INT 0
54846: PUSH
54847: LD_INT 0
54849: PUSH
54850: EMPTY
54851: LIST
54852: LIST
54853: LIST
54854: ST_TO_ADDR
// bpoints := 1 ;
54855: LD_ADDR_VAR 0 10
54859: PUSH
54860: LD_INT 1
54862: ST_TO_ADDR
// case GetType ( i ) of unit_human :
54863: LD_VAR 0 6
54867: PPUSH
54868: CALL_OW 247
54872: PUSH
54873: LD_INT 1
54875: DOUBLE
54876: EQUAL
54877: IFTRUE 54881
54879: GO 55459
54881: POP
// begin if GetClass ( i ) = 1 then
54882: LD_VAR 0 6
54886: PPUSH
54887: CALL_OW 257
54891: PUSH
54892: LD_INT 1
54894: EQUAL
54895: IFFALSE 54916
// points := [ 10 , 5 , 3 ] ;
54897: LD_ADDR_VAR 0 9
54901: PUSH
54902: LD_INT 10
54904: PUSH
54905: LD_INT 5
54907: PUSH
54908: LD_INT 3
54910: PUSH
54911: EMPTY
54912: LIST
54913: LIST
54914: LIST
54915: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
54916: LD_VAR 0 6
54920: PPUSH
54921: CALL_OW 257
54925: PUSH
54926: LD_INT 2
54928: PUSH
54929: LD_INT 3
54931: PUSH
54932: LD_INT 4
54934: PUSH
54935: EMPTY
54936: LIST
54937: LIST
54938: LIST
54939: IN
54940: IFFALSE 54961
// points := [ 3 , 2 , 1 ] ;
54942: LD_ADDR_VAR 0 9
54946: PUSH
54947: LD_INT 3
54949: PUSH
54950: LD_INT 2
54952: PUSH
54953: LD_INT 1
54955: PUSH
54956: EMPTY
54957: LIST
54958: LIST
54959: LIST
54960: ST_TO_ADDR
// if GetClass ( i ) = 5 then
54961: LD_VAR 0 6
54965: PPUSH
54966: CALL_OW 257
54970: PUSH
54971: LD_INT 5
54973: EQUAL
54974: IFFALSE 54995
// points := [ 130 , 5 , 2 ] ;
54976: LD_ADDR_VAR 0 9
54980: PUSH
54981: LD_INT 130
54983: PUSH
54984: LD_INT 5
54986: PUSH
54987: LD_INT 2
54989: PUSH
54990: EMPTY
54991: LIST
54992: LIST
54993: LIST
54994: ST_TO_ADDR
// if GetClass ( i ) = 8 then
54995: LD_VAR 0 6
54999: PPUSH
55000: CALL_OW 257
55004: PUSH
55005: LD_INT 8
55007: EQUAL
55008: IFFALSE 55029
// points := [ 35 , 35 , 30 ] ;
55010: LD_ADDR_VAR 0 9
55014: PUSH
55015: LD_INT 35
55017: PUSH
55018: LD_INT 35
55020: PUSH
55021: LD_INT 30
55023: PUSH
55024: EMPTY
55025: LIST
55026: LIST
55027: LIST
55028: ST_TO_ADDR
// if GetClass ( i ) = 9 then
55029: LD_VAR 0 6
55033: PPUSH
55034: CALL_OW 257
55038: PUSH
55039: LD_INT 9
55041: EQUAL
55042: IFFALSE 55063
// points := [ 20 , 55 , 40 ] ;
55044: LD_ADDR_VAR 0 9
55048: PUSH
55049: LD_INT 20
55051: PUSH
55052: LD_INT 55
55054: PUSH
55055: LD_INT 40
55057: PUSH
55058: EMPTY
55059: LIST
55060: LIST
55061: LIST
55062: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
55063: LD_VAR 0 6
55067: PPUSH
55068: CALL_OW 257
55072: PUSH
55073: LD_INT 12
55075: PUSH
55076: LD_INT 16
55078: PUSH
55079: EMPTY
55080: LIST
55081: LIST
55082: IN
55083: IFFALSE 55104
// points := [ 5 , 3 , 2 ] ;
55085: LD_ADDR_VAR 0 9
55089: PUSH
55090: LD_INT 5
55092: PUSH
55093: LD_INT 3
55095: PUSH
55096: LD_INT 2
55098: PUSH
55099: EMPTY
55100: LIST
55101: LIST
55102: LIST
55103: ST_TO_ADDR
// if GetClass ( i ) = 17 then
55104: LD_VAR 0 6
55108: PPUSH
55109: CALL_OW 257
55113: PUSH
55114: LD_INT 17
55116: EQUAL
55117: IFFALSE 55138
// points := [ 100 , 50 , 75 ] ;
55119: LD_ADDR_VAR 0 9
55123: PUSH
55124: LD_INT 100
55126: PUSH
55127: LD_INT 50
55129: PUSH
55130: LD_INT 75
55132: PUSH
55133: EMPTY
55134: LIST
55135: LIST
55136: LIST
55137: ST_TO_ADDR
// if GetClass ( i ) = 15 then
55138: LD_VAR 0 6
55142: PPUSH
55143: CALL_OW 257
55147: PUSH
55148: LD_INT 15
55150: EQUAL
55151: IFFALSE 55172
// points := [ 10 , 5 , 3 ] ;
55153: LD_ADDR_VAR 0 9
55157: PUSH
55158: LD_INT 10
55160: PUSH
55161: LD_INT 5
55163: PUSH
55164: LD_INT 3
55166: PUSH
55167: EMPTY
55168: LIST
55169: LIST
55170: LIST
55171: ST_TO_ADDR
// if GetClass ( i ) = 14 then
55172: LD_VAR 0 6
55176: PPUSH
55177: CALL_OW 257
55181: PUSH
55182: LD_INT 14
55184: EQUAL
55185: IFFALSE 55206
// points := [ 10 , 0 , 0 ] ;
55187: LD_ADDR_VAR 0 9
55191: PUSH
55192: LD_INT 10
55194: PUSH
55195: LD_INT 0
55197: PUSH
55198: LD_INT 0
55200: PUSH
55201: EMPTY
55202: LIST
55203: LIST
55204: LIST
55205: ST_TO_ADDR
// if GetClass ( i ) = 11 then
55206: LD_VAR 0 6
55210: PPUSH
55211: CALL_OW 257
55215: PUSH
55216: LD_INT 11
55218: EQUAL
55219: IFFALSE 55240
// points := [ 30 , 10 , 5 ] ;
55221: LD_ADDR_VAR 0 9
55225: PUSH
55226: LD_INT 30
55228: PUSH
55229: LD_INT 10
55231: PUSH
55232: LD_INT 5
55234: PUSH
55235: EMPTY
55236: LIST
55237: LIST
55238: LIST
55239: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
55240: LD_VAR 0 1
55244: PPUSH
55245: LD_INT 5
55247: PPUSH
55248: CALL_OW 321
55252: PUSH
55253: LD_INT 2
55255: EQUAL
55256: IFFALSE 55273
// bpoints := bpoints * 1.8 ;
55258: LD_ADDR_VAR 0 10
55262: PUSH
55263: LD_VAR 0 10
55267: PUSH
55268: LD_REAL  1.80000000000000E+0000
55271: MUL
55272: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
55273: LD_VAR 0 6
55277: PPUSH
55278: CALL_OW 257
55282: PUSH
55283: LD_INT 1
55285: PUSH
55286: LD_INT 2
55288: PUSH
55289: LD_INT 3
55291: PUSH
55292: LD_INT 4
55294: PUSH
55295: EMPTY
55296: LIST
55297: LIST
55298: LIST
55299: LIST
55300: IN
55301: PUSH
55302: LD_VAR 0 1
55306: PPUSH
55307: LD_INT 51
55309: PPUSH
55310: CALL_OW 321
55314: PUSH
55315: LD_INT 2
55317: EQUAL
55318: AND
55319: IFFALSE 55336
// bpoints := bpoints * 1.2 ;
55321: LD_ADDR_VAR 0 10
55325: PUSH
55326: LD_VAR 0 10
55330: PUSH
55331: LD_REAL  1.20000000000000E+0000
55334: MUL
55335: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
55336: LD_VAR 0 6
55340: PPUSH
55341: CALL_OW 257
55345: PUSH
55346: LD_INT 5
55348: PUSH
55349: LD_INT 7
55351: PUSH
55352: LD_INT 9
55354: PUSH
55355: EMPTY
55356: LIST
55357: LIST
55358: LIST
55359: IN
55360: PUSH
55361: LD_VAR 0 1
55365: PPUSH
55366: LD_INT 52
55368: PPUSH
55369: CALL_OW 321
55373: PUSH
55374: LD_INT 2
55376: EQUAL
55377: AND
55378: IFFALSE 55395
// bpoints := bpoints * 1.5 ;
55380: LD_ADDR_VAR 0 10
55384: PUSH
55385: LD_VAR 0 10
55389: PUSH
55390: LD_REAL  1.50000000000000E+0000
55393: MUL
55394: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
55395: LD_VAR 0 1
55399: PPUSH
55400: LD_INT 66
55402: PPUSH
55403: CALL_OW 321
55407: PUSH
55408: LD_INT 2
55410: EQUAL
55411: IFFALSE 55428
// bpoints := bpoints * 1.1 ;
55413: LD_ADDR_VAR 0 10
55417: PUSH
55418: LD_VAR 0 10
55422: PUSH
55423: LD_REAL  1.10000000000000E+0000
55426: MUL
55427: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
55428: LD_ADDR_VAR 0 10
55432: PUSH
55433: LD_VAR 0 10
55437: PUSH
55438: LD_VAR 0 6
55442: PPUSH
55443: LD_INT 1
55445: PPUSH
55446: CALL_OW 259
55450: PUSH
55451: LD_REAL  1.15000000000000E+0000
55454: MUL
55455: MUL
55456: ST_TO_ADDR
// end ; unit_vehicle :
55457: GO 56285
55459: LD_INT 2
55461: DOUBLE
55462: EQUAL
55463: IFTRUE 55467
55465: GO 56273
55467: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
55468: LD_VAR 0 6
55472: PPUSH
55473: CALL_OW 264
55477: PUSH
55478: LD_INT 2
55480: PUSH
55481: LD_INT 42
55483: PUSH
55484: LD_INT 24
55486: PUSH
55487: EMPTY
55488: LIST
55489: LIST
55490: LIST
55491: IN
55492: IFFALSE 55513
// points := [ 25 , 5 , 3 ] ;
55494: LD_ADDR_VAR 0 9
55498: PUSH
55499: LD_INT 25
55501: PUSH
55502: LD_INT 5
55504: PUSH
55505: LD_INT 3
55507: PUSH
55508: EMPTY
55509: LIST
55510: LIST
55511: LIST
55512: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
55513: LD_VAR 0 6
55517: PPUSH
55518: CALL_OW 264
55522: PUSH
55523: LD_INT 4
55525: PUSH
55526: LD_INT 43
55528: PUSH
55529: LD_INT 25
55531: PUSH
55532: EMPTY
55533: LIST
55534: LIST
55535: LIST
55536: IN
55537: IFFALSE 55558
// points := [ 40 , 15 , 5 ] ;
55539: LD_ADDR_VAR 0 9
55543: PUSH
55544: LD_INT 40
55546: PUSH
55547: LD_INT 15
55549: PUSH
55550: LD_INT 5
55552: PUSH
55553: EMPTY
55554: LIST
55555: LIST
55556: LIST
55557: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
55558: LD_VAR 0 6
55562: PPUSH
55563: CALL_OW 264
55567: PUSH
55568: LD_INT 3
55570: PUSH
55571: LD_INT 23
55573: PUSH
55574: EMPTY
55575: LIST
55576: LIST
55577: IN
55578: IFFALSE 55599
// points := [ 7 , 25 , 8 ] ;
55580: LD_ADDR_VAR 0 9
55584: PUSH
55585: LD_INT 7
55587: PUSH
55588: LD_INT 25
55590: PUSH
55591: LD_INT 8
55593: PUSH
55594: EMPTY
55595: LIST
55596: LIST
55597: LIST
55598: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
55599: LD_VAR 0 6
55603: PPUSH
55604: CALL_OW 264
55608: PUSH
55609: LD_INT 5
55611: PUSH
55612: LD_INT 27
55614: PUSH
55615: LD_INT 44
55617: PUSH
55618: EMPTY
55619: LIST
55620: LIST
55621: LIST
55622: IN
55623: IFFALSE 55644
// points := [ 14 , 50 , 16 ] ;
55625: LD_ADDR_VAR 0 9
55629: PUSH
55630: LD_INT 14
55632: PUSH
55633: LD_INT 50
55635: PUSH
55636: LD_INT 16
55638: PUSH
55639: EMPTY
55640: LIST
55641: LIST
55642: LIST
55643: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
55644: LD_VAR 0 6
55648: PPUSH
55649: CALL_OW 264
55653: PUSH
55654: LD_INT 6
55656: PUSH
55657: LD_INT 46
55659: PUSH
55660: EMPTY
55661: LIST
55662: LIST
55663: IN
55664: IFFALSE 55685
// points := [ 32 , 120 , 70 ] ;
55666: LD_ADDR_VAR 0 9
55670: PUSH
55671: LD_INT 32
55673: PUSH
55674: LD_INT 120
55676: PUSH
55677: LD_INT 70
55679: PUSH
55680: EMPTY
55681: LIST
55682: LIST
55683: LIST
55684: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
55685: LD_VAR 0 6
55689: PPUSH
55690: CALL_OW 264
55694: PUSH
55695: LD_INT 7
55697: PUSH
55698: LD_INT 28
55700: PUSH
55701: LD_INT 45
55703: PUSH
55704: LD_INT 92
55706: PUSH
55707: EMPTY
55708: LIST
55709: LIST
55710: LIST
55711: LIST
55712: IN
55713: IFFALSE 55734
// points := [ 35 , 20 , 45 ] ;
55715: LD_ADDR_VAR 0 9
55719: PUSH
55720: LD_INT 35
55722: PUSH
55723: LD_INT 20
55725: PUSH
55726: LD_INT 45
55728: PUSH
55729: EMPTY
55730: LIST
55731: LIST
55732: LIST
55733: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
55734: LD_VAR 0 6
55738: PPUSH
55739: CALL_OW 264
55743: PUSH
55744: LD_INT 47
55746: PUSH
55747: EMPTY
55748: LIST
55749: IN
55750: IFFALSE 55771
// points := [ 67 , 45 , 75 ] ;
55752: LD_ADDR_VAR 0 9
55756: PUSH
55757: LD_INT 67
55759: PUSH
55760: LD_INT 45
55762: PUSH
55763: LD_INT 75
55765: PUSH
55766: EMPTY
55767: LIST
55768: LIST
55769: LIST
55770: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
55771: LD_VAR 0 6
55775: PPUSH
55776: CALL_OW 264
55780: PUSH
55781: LD_INT 26
55783: PUSH
55784: EMPTY
55785: LIST
55786: IN
55787: IFFALSE 55808
// points := [ 120 , 30 , 80 ] ;
55789: LD_ADDR_VAR 0 9
55793: PUSH
55794: LD_INT 120
55796: PUSH
55797: LD_INT 30
55799: PUSH
55800: LD_INT 80
55802: PUSH
55803: EMPTY
55804: LIST
55805: LIST
55806: LIST
55807: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
55808: LD_VAR 0 6
55812: PPUSH
55813: CALL_OW 264
55817: PUSH
55818: LD_INT 22
55820: PUSH
55821: EMPTY
55822: LIST
55823: IN
55824: IFFALSE 55845
// points := [ 40 , 1 , 1 ] ;
55826: LD_ADDR_VAR 0 9
55830: PUSH
55831: LD_INT 40
55833: PUSH
55834: LD_INT 1
55836: PUSH
55837: LD_INT 1
55839: PUSH
55840: EMPTY
55841: LIST
55842: LIST
55843: LIST
55844: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
55845: LD_VAR 0 6
55849: PPUSH
55850: CALL_OW 264
55854: PUSH
55855: LD_INT 29
55857: PUSH
55858: EMPTY
55859: LIST
55860: IN
55861: IFFALSE 55882
// points := [ 70 , 200 , 400 ] ;
55863: LD_ADDR_VAR 0 9
55867: PUSH
55868: LD_INT 70
55870: PUSH
55871: LD_INT 200
55873: PUSH
55874: LD_INT 400
55876: PUSH
55877: EMPTY
55878: LIST
55879: LIST
55880: LIST
55881: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
55882: LD_VAR 0 6
55886: PPUSH
55887: CALL_OW 264
55891: PUSH
55892: LD_INT 14
55894: PUSH
55895: LD_INT 53
55897: PUSH
55898: EMPTY
55899: LIST
55900: LIST
55901: IN
55902: IFFALSE 55923
// points := [ 40 , 10 , 20 ] ;
55904: LD_ADDR_VAR 0 9
55908: PUSH
55909: LD_INT 40
55911: PUSH
55912: LD_INT 10
55914: PUSH
55915: LD_INT 20
55917: PUSH
55918: EMPTY
55919: LIST
55920: LIST
55921: LIST
55922: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
55923: LD_VAR 0 6
55927: PPUSH
55928: CALL_OW 264
55932: PUSH
55933: LD_INT 9
55935: PUSH
55936: EMPTY
55937: LIST
55938: IN
55939: IFFALSE 55960
// points := [ 5 , 70 , 20 ] ;
55941: LD_ADDR_VAR 0 9
55945: PUSH
55946: LD_INT 5
55948: PUSH
55949: LD_INT 70
55951: PUSH
55952: LD_INT 20
55954: PUSH
55955: EMPTY
55956: LIST
55957: LIST
55958: LIST
55959: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
55960: LD_VAR 0 6
55964: PPUSH
55965: CALL_OW 264
55969: PUSH
55970: LD_INT 10
55972: PUSH
55973: EMPTY
55974: LIST
55975: IN
55976: IFFALSE 55997
// points := [ 35 , 110 , 70 ] ;
55978: LD_ADDR_VAR 0 9
55982: PUSH
55983: LD_INT 35
55985: PUSH
55986: LD_INT 110
55988: PUSH
55989: LD_INT 70
55991: PUSH
55992: EMPTY
55993: LIST
55994: LIST
55995: LIST
55996: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
55997: LD_VAR 0 6
56001: PPUSH
56002: CALL_OW 265
56006: PUSH
56007: LD_INT 25
56009: EQUAL
56010: IFFALSE 56031
// points := [ 80 , 65 , 100 ] ;
56012: LD_ADDR_VAR 0 9
56016: PUSH
56017: LD_INT 80
56019: PUSH
56020: LD_INT 65
56022: PUSH
56023: LD_INT 100
56025: PUSH
56026: EMPTY
56027: LIST
56028: LIST
56029: LIST
56030: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
56031: LD_VAR 0 6
56035: PPUSH
56036: CALL_OW 263
56040: PUSH
56041: LD_INT 1
56043: EQUAL
56044: IFFALSE 56079
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
56046: LD_ADDR_VAR 0 10
56050: PUSH
56051: LD_VAR 0 10
56055: PUSH
56056: LD_VAR 0 6
56060: PPUSH
56061: CALL_OW 311
56065: PPUSH
56066: LD_INT 3
56068: PPUSH
56069: CALL_OW 259
56073: PUSH
56074: LD_INT 4
56076: MUL
56077: MUL
56078: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
56079: LD_VAR 0 6
56083: PPUSH
56084: CALL_OW 263
56088: PUSH
56089: LD_INT 2
56091: EQUAL
56092: IFFALSE 56143
// begin j := IsControledBy ( i ) ;
56094: LD_ADDR_VAR 0 7
56098: PUSH
56099: LD_VAR 0 6
56103: PPUSH
56104: CALL_OW 312
56108: ST_TO_ADDR
// if j then
56109: LD_VAR 0 7
56113: IFFALSE 56143
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
56115: LD_ADDR_VAR 0 10
56119: PUSH
56120: LD_VAR 0 10
56124: PUSH
56125: LD_VAR 0 7
56129: PPUSH
56130: LD_INT 3
56132: PPUSH
56133: CALL_OW 259
56137: PUSH
56138: LD_INT 3
56140: MUL
56141: MUL
56142: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
56143: LD_VAR 0 6
56147: PPUSH
56148: CALL_OW 264
56152: PUSH
56153: LD_INT 5
56155: PUSH
56156: LD_INT 6
56158: PUSH
56159: LD_INT 46
56161: PUSH
56162: LD_INT 44
56164: PUSH
56165: LD_INT 47
56167: PUSH
56168: LD_INT 45
56170: PUSH
56171: LD_INT 28
56173: PUSH
56174: LD_INT 7
56176: PUSH
56177: LD_INT 27
56179: PUSH
56180: LD_INT 29
56182: PUSH
56183: EMPTY
56184: LIST
56185: LIST
56186: LIST
56187: LIST
56188: LIST
56189: LIST
56190: LIST
56191: LIST
56192: LIST
56193: LIST
56194: IN
56195: PUSH
56196: LD_VAR 0 1
56200: PPUSH
56201: LD_INT 52
56203: PPUSH
56204: CALL_OW 321
56208: PUSH
56209: LD_INT 2
56211: EQUAL
56212: AND
56213: IFFALSE 56230
// bpoints := bpoints * 1.2 ;
56215: LD_ADDR_VAR 0 10
56219: PUSH
56220: LD_VAR 0 10
56224: PUSH
56225: LD_REAL  1.20000000000000E+0000
56228: MUL
56229: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
56230: LD_VAR 0 6
56234: PPUSH
56235: CALL_OW 264
56239: PUSH
56240: LD_INT 6
56242: PUSH
56243: LD_INT 46
56245: PUSH
56246: LD_INT 47
56248: PUSH
56249: EMPTY
56250: LIST
56251: LIST
56252: LIST
56253: IN
56254: IFFALSE 56271
// bpoints := bpoints * 1.2 ;
56256: LD_ADDR_VAR 0 10
56260: PUSH
56261: LD_VAR 0 10
56265: PUSH
56266: LD_REAL  1.20000000000000E+0000
56269: MUL
56270: ST_TO_ADDR
// end ; unit_building :
56271: GO 56285
56273: LD_INT 3
56275: DOUBLE
56276: EQUAL
56277: IFTRUE 56281
56279: GO 56284
56281: POP
// ; end ;
56282: GO 56285
56284: POP
// for j = 1 to 3 do
56285: LD_ADDR_VAR 0 7
56289: PUSH
56290: DOUBLE
56291: LD_INT 1
56293: DEC
56294: ST_TO_ADDR
56295: LD_INT 3
56297: PUSH
56298: FOR_TO
56299: IFFALSE 56352
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
56301: LD_ADDR_VAR 0 5
56305: PUSH
56306: LD_VAR 0 5
56310: PPUSH
56311: LD_VAR 0 7
56315: PPUSH
56316: LD_VAR 0 5
56320: PUSH
56321: LD_VAR 0 7
56325: ARRAY
56326: PUSH
56327: LD_VAR 0 9
56331: PUSH
56332: LD_VAR 0 7
56336: ARRAY
56337: PUSH
56338: LD_VAR 0 10
56342: MUL
56343: PLUS
56344: PPUSH
56345: CALL_OW 1
56349: ST_TO_ADDR
56350: GO 56298
56352: POP
56353: POP
// end ;
56354: GO 54833
56356: POP
56357: POP
// result := Replace ( result , 4 , tmp ) ;
56358: LD_ADDR_VAR 0 5
56362: PUSH
56363: LD_VAR 0 5
56367: PPUSH
56368: LD_INT 4
56370: PPUSH
56371: LD_VAR 0 8
56375: PPUSH
56376: CALL_OW 1
56380: ST_TO_ADDR
// end ;
56381: LD_VAR 0 5
56385: RET
// export function DangerAtRange ( unit , range ) ; begin
56386: LD_INT 0
56388: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
56389: LD_ADDR_VAR 0 3
56393: PUSH
56394: LD_VAR 0 1
56398: PPUSH
56399: CALL_OW 255
56403: PPUSH
56404: LD_VAR 0 1
56408: PPUSH
56409: CALL_OW 250
56413: PPUSH
56414: LD_VAR 0 1
56418: PPUSH
56419: CALL_OW 251
56423: PPUSH
56424: LD_VAR 0 2
56428: PPUSH
56429: CALL 54685 0 4
56433: ST_TO_ADDR
// end ;
56434: LD_VAR 0 3
56438: RET
// export function DangerInArea ( side , area ) ; begin
56439: LD_INT 0
56441: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
56442: LD_ADDR_VAR 0 3
56446: PUSH
56447: LD_VAR 0 2
56451: PPUSH
56452: LD_INT 81
56454: PUSH
56455: LD_VAR 0 1
56459: PUSH
56460: EMPTY
56461: LIST
56462: LIST
56463: PPUSH
56464: CALL_OW 70
56468: ST_TO_ADDR
// end ;
56469: LD_VAR 0 3
56473: RET
// export function IsExtension ( b ) ; begin
56474: LD_INT 0
56476: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
56477: LD_ADDR_VAR 0 2
56481: PUSH
56482: LD_VAR 0 1
56486: PUSH
56487: LD_INT 23
56489: PUSH
56490: LD_INT 20
56492: PUSH
56493: LD_INT 22
56495: PUSH
56496: LD_INT 17
56498: PUSH
56499: LD_INT 24
56501: PUSH
56502: LD_INT 21
56504: PUSH
56505: LD_INT 19
56507: PUSH
56508: LD_INT 16
56510: PUSH
56511: LD_INT 25
56513: PUSH
56514: LD_INT 18
56516: PUSH
56517: EMPTY
56518: LIST
56519: LIST
56520: LIST
56521: LIST
56522: LIST
56523: LIST
56524: LIST
56525: LIST
56526: LIST
56527: LIST
56528: IN
56529: ST_TO_ADDR
// end ;
56530: LD_VAR 0 2
56534: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
56535: LD_INT 0
56537: PPUSH
56538: PPUSH
56539: PPUSH
// result := [ ] ;
56540: LD_ADDR_VAR 0 4
56544: PUSH
56545: EMPTY
56546: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
56547: LD_ADDR_VAR 0 5
56551: PUSH
56552: LD_VAR 0 2
56556: PPUSH
56557: LD_INT 21
56559: PUSH
56560: LD_INT 3
56562: PUSH
56563: EMPTY
56564: LIST
56565: LIST
56566: PPUSH
56567: CALL_OW 70
56571: ST_TO_ADDR
// if not tmp then
56572: LD_VAR 0 5
56576: NOT
56577: IFFALSE 56581
// exit ;
56579: GO 56645
// if checkLink then
56581: LD_VAR 0 3
56585: IFFALSE 56635
// begin for i in tmp do
56587: LD_ADDR_VAR 0 6
56591: PUSH
56592: LD_VAR 0 5
56596: PUSH
56597: FOR_IN
56598: IFFALSE 56633
// if GetBase ( i ) <> base then
56600: LD_VAR 0 6
56604: PPUSH
56605: CALL_OW 274
56609: PUSH
56610: LD_VAR 0 1
56614: NONEQUAL
56615: IFFALSE 56631
// ComLinkToBase ( base , i ) ;
56617: LD_VAR 0 1
56621: PPUSH
56622: LD_VAR 0 6
56626: PPUSH
56627: CALL_OW 169
56631: GO 56597
56633: POP
56634: POP
// end ; result := tmp ;
56635: LD_ADDR_VAR 0 4
56639: PUSH
56640: LD_VAR 0 5
56644: ST_TO_ADDR
// end ;
56645: LD_VAR 0 4
56649: RET
// export function ComComplete ( units , b ) ; var i ; begin
56650: LD_INT 0
56652: PPUSH
56653: PPUSH
// if not units then
56654: LD_VAR 0 1
56658: NOT
56659: IFFALSE 56663
// exit ;
56661: GO 56753
// for i in units do
56663: LD_ADDR_VAR 0 4
56667: PUSH
56668: LD_VAR 0 1
56672: PUSH
56673: FOR_IN
56674: IFFALSE 56751
// if BuildingStatus ( b ) = bs_build then
56676: LD_VAR 0 2
56680: PPUSH
56681: CALL_OW 461
56685: PUSH
56686: LD_INT 1
56688: EQUAL
56689: IFFALSE 56749
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
56691: LD_VAR 0 4
56695: PPUSH
56696: LD_STRING h
56698: PUSH
56699: LD_VAR 0 2
56703: PPUSH
56704: CALL_OW 250
56708: PUSH
56709: LD_VAR 0 2
56713: PPUSH
56714: CALL_OW 251
56718: PUSH
56719: LD_VAR 0 2
56723: PUSH
56724: LD_INT 0
56726: PUSH
56727: LD_INT 0
56729: PUSH
56730: LD_INT 0
56732: PUSH
56733: EMPTY
56734: LIST
56735: LIST
56736: LIST
56737: LIST
56738: LIST
56739: LIST
56740: LIST
56741: PUSH
56742: EMPTY
56743: LIST
56744: PPUSH
56745: CALL_OW 446
56749: GO 56673
56751: POP
56752: POP
// end ;
56753: LD_VAR 0 3
56757: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
56758: LD_INT 0
56760: PPUSH
56761: PPUSH
56762: PPUSH
56763: PPUSH
56764: PPUSH
56765: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
56766: LD_VAR 0 1
56770: NOT
56771: PUSH
56772: LD_VAR 0 1
56776: PPUSH
56777: CALL_OW 263
56781: PUSH
56782: LD_INT 2
56784: NONEQUAL
56785: OR
56786: IFFALSE 56790
// exit ;
56788: GO 57106
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
56790: LD_ADDR_VAR 0 6
56794: PUSH
56795: LD_INT 22
56797: PUSH
56798: LD_VAR 0 1
56802: PPUSH
56803: CALL_OW 255
56807: PUSH
56808: EMPTY
56809: LIST
56810: LIST
56811: PUSH
56812: LD_INT 2
56814: PUSH
56815: LD_INT 30
56817: PUSH
56818: LD_INT 36
56820: PUSH
56821: EMPTY
56822: LIST
56823: LIST
56824: PUSH
56825: LD_INT 34
56827: PUSH
56828: LD_INT 31
56830: PUSH
56831: EMPTY
56832: LIST
56833: LIST
56834: PUSH
56835: EMPTY
56836: LIST
56837: LIST
56838: LIST
56839: PUSH
56840: EMPTY
56841: LIST
56842: LIST
56843: PPUSH
56844: CALL_OW 69
56848: ST_TO_ADDR
// if not tmp then
56849: LD_VAR 0 6
56853: NOT
56854: IFFALSE 56858
// exit ;
56856: GO 57106
// result := [ ] ;
56858: LD_ADDR_VAR 0 2
56862: PUSH
56863: EMPTY
56864: ST_TO_ADDR
// for i in tmp do
56865: LD_ADDR_VAR 0 3
56869: PUSH
56870: LD_VAR 0 6
56874: PUSH
56875: FOR_IN
56876: IFFALSE 56947
// begin t := UnitsInside ( i ) ;
56878: LD_ADDR_VAR 0 4
56882: PUSH
56883: LD_VAR 0 3
56887: PPUSH
56888: CALL_OW 313
56892: ST_TO_ADDR
// if t then
56893: LD_VAR 0 4
56897: IFFALSE 56945
// for j in t do
56899: LD_ADDR_VAR 0 7
56903: PUSH
56904: LD_VAR 0 4
56908: PUSH
56909: FOR_IN
56910: IFFALSE 56943
// result := Replace ( result , result + 1 , j ) ;
56912: LD_ADDR_VAR 0 2
56916: PUSH
56917: LD_VAR 0 2
56921: PPUSH
56922: LD_VAR 0 2
56926: PUSH
56927: LD_INT 1
56929: PLUS
56930: PPUSH
56931: LD_VAR 0 7
56935: PPUSH
56936: CALL_OW 1
56940: ST_TO_ADDR
56941: GO 56909
56943: POP
56944: POP
// end ;
56945: GO 56875
56947: POP
56948: POP
// if not result then
56949: LD_VAR 0 2
56953: NOT
56954: IFFALSE 56958
// exit ;
56956: GO 57106
// mech := result [ 1 ] ;
56958: LD_ADDR_VAR 0 5
56962: PUSH
56963: LD_VAR 0 2
56967: PUSH
56968: LD_INT 1
56970: ARRAY
56971: ST_TO_ADDR
// if result > 1 then
56972: LD_VAR 0 2
56976: PUSH
56977: LD_INT 1
56979: GREATER
56980: IFFALSE 57092
// begin for i = 2 to result do
56982: LD_ADDR_VAR 0 3
56986: PUSH
56987: DOUBLE
56988: LD_INT 2
56990: DEC
56991: ST_TO_ADDR
56992: LD_VAR 0 2
56996: PUSH
56997: FOR_TO
56998: IFFALSE 57090
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
57000: LD_ADDR_VAR 0 4
57004: PUSH
57005: LD_VAR 0 2
57009: PUSH
57010: LD_VAR 0 3
57014: ARRAY
57015: PPUSH
57016: LD_INT 3
57018: PPUSH
57019: CALL_OW 259
57023: PUSH
57024: LD_VAR 0 2
57028: PUSH
57029: LD_VAR 0 3
57033: ARRAY
57034: PPUSH
57035: CALL_OW 432
57039: MINUS
57040: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
57041: LD_VAR 0 4
57045: PUSH
57046: LD_VAR 0 5
57050: PPUSH
57051: LD_INT 3
57053: PPUSH
57054: CALL_OW 259
57058: PUSH
57059: LD_VAR 0 5
57063: PPUSH
57064: CALL_OW 432
57068: MINUS
57069: GREATEREQUAL
57070: IFFALSE 57088
// mech := result [ i ] ;
57072: LD_ADDR_VAR 0 5
57076: PUSH
57077: LD_VAR 0 2
57081: PUSH
57082: LD_VAR 0 3
57086: ARRAY
57087: ST_TO_ADDR
// end ;
57088: GO 56997
57090: POP
57091: POP
// end ; ComLinkTo ( vehicle , mech ) ;
57092: LD_VAR 0 1
57096: PPUSH
57097: LD_VAR 0 5
57101: PPUSH
57102: CALL_OW 135
// end ;
57106: LD_VAR 0 2
57110: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
57111: LD_INT 0
57113: PPUSH
57114: PPUSH
57115: PPUSH
57116: PPUSH
57117: PPUSH
57118: PPUSH
57119: PPUSH
57120: PPUSH
57121: PPUSH
57122: PPUSH
57123: PPUSH
57124: PPUSH
57125: PPUSH
// result := [ ] ;
57126: LD_ADDR_VAR 0 7
57130: PUSH
57131: EMPTY
57132: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
57133: LD_VAR 0 1
57137: PPUSH
57138: CALL_OW 266
57142: PUSH
57143: LD_INT 0
57145: PUSH
57146: LD_INT 1
57148: PUSH
57149: EMPTY
57150: LIST
57151: LIST
57152: IN
57153: NOT
57154: IFFALSE 57158
// exit ;
57156: GO 58792
// if name then
57158: LD_VAR 0 3
57162: IFFALSE 57178
// SetBName ( base_dep , name ) ;
57164: LD_VAR 0 1
57168: PPUSH
57169: LD_VAR 0 3
57173: PPUSH
57174: CALL_OW 500
// base := GetBase ( base_dep ) ;
57178: LD_ADDR_VAR 0 15
57182: PUSH
57183: LD_VAR 0 1
57187: PPUSH
57188: CALL_OW 274
57192: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
57193: LD_ADDR_VAR 0 16
57197: PUSH
57198: LD_VAR 0 1
57202: PPUSH
57203: CALL_OW 255
57207: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
57208: LD_ADDR_VAR 0 17
57212: PUSH
57213: LD_VAR 0 1
57217: PPUSH
57218: CALL_OW 248
57222: ST_TO_ADDR
// if sources then
57223: LD_VAR 0 5
57227: IFFALSE 57274
// for i = 1 to 3 do
57229: LD_ADDR_VAR 0 8
57233: PUSH
57234: DOUBLE
57235: LD_INT 1
57237: DEC
57238: ST_TO_ADDR
57239: LD_INT 3
57241: PUSH
57242: FOR_TO
57243: IFFALSE 57272
// AddResourceType ( base , i , sources [ i ] ) ;
57245: LD_VAR 0 15
57249: PPUSH
57250: LD_VAR 0 8
57254: PPUSH
57255: LD_VAR 0 5
57259: PUSH
57260: LD_VAR 0 8
57264: ARRAY
57265: PPUSH
57266: CALL_OW 276
57270: GO 57242
57272: POP
57273: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
57274: LD_ADDR_VAR 0 18
57278: PUSH
57279: LD_VAR 0 15
57283: PPUSH
57284: LD_VAR 0 2
57288: PPUSH
57289: LD_INT 1
57291: PPUSH
57292: CALL 56535 0 3
57296: ST_TO_ADDR
// InitHc ;
57297: CALL_OW 19
// InitUc ;
57301: CALL_OW 18
// uc_side := side ;
57305: LD_ADDR_OWVAR 20
57309: PUSH
57310: LD_VAR 0 16
57314: ST_TO_ADDR
// uc_nation := nation ;
57315: LD_ADDR_OWVAR 21
57319: PUSH
57320: LD_VAR 0 17
57324: ST_TO_ADDR
// if buildings then
57325: LD_VAR 0 18
57329: IFFALSE 58651
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
57331: LD_ADDR_VAR 0 19
57335: PUSH
57336: LD_VAR 0 18
57340: PPUSH
57341: LD_INT 2
57343: PUSH
57344: LD_INT 30
57346: PUSH
57347: LD_INT 29
57349: PUSH
57350: EMPTY
57351: LIST
57352: LIST
57353: PUSH
57354: LD_INT 30
57356: PUSH
57357: LD_INT 30
57359: PUSH
57360: EMPTY
57361: LIST
57362: LIST
57363: PUSH
57364: EMPTY
57365: LIST
57366: LIST
57367: LIST
57368: PPUSH
57369: CALL_OW 72
57373: ST_TO_ADDR
// if tmp then
57374: LD_VAR 0 19
57378: IFFALSE 57426
// for i in tmp do
57380: LD_ADDR_VAR 0 8
57384: PUSH
57385: LD_VAR 0 19
57389: PUSH
57390: FOR_IN
57391: IFFALSE 57424
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
57393: LD_VAR 0 8
57397: PPUSH
57398: CALL_OW 250
57402: PPUSH
57403: LD_VAR 0 8
57407: PPUSH
57408: CALL_OW 251
57412: PPUSH
57413: LD_VAR 0 16
57417: PPUSH
57418: CALL_OW 441
57422: GO 57390
57424: POP
57425: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
57426: LD_VAR 0 18
57430: PPUSH
57431: LD_INT 2
57433: PUSH
57434: LD_INT 30
57436: PUSH
57437: LD_INT 32
57439: PUSH
57440: EMPTY
57441: LIST
57442: LIST
57443: PUSH
57444: LD_INT 30
57446: PUSH
57447: LD_INT 33
57449: PUSH
57450: EMPTY
57451: LIST
57452: LIST
57453: PUSH
57454: EMPTY
57455: LIST
57456: LIST
57457: LIST
57458: PPUSH
57459: CALL_OW 72
57463: IFFALSE 57551
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
57465: LD_ADDR_VAR 0 8
57469: PUSH
57470: LD_VAR 0 18
57474: PPUSH
57475: LD_INT 2
57477: PUSH
57478: LD_INT 30
57480: PUSH
57481: LD_INT 32
57483: PUSH
57484: EMPTY
57485: LIST
57486: LIST
57487: PUSH
57488: LD_INT 30
57490: PUSH
57491: LD_INT 33
57493: PUSH
57494: EMPTY
57495: LIST
57496: LIST
57497: PUSH
57498: EMPTY
57499: LIST
57500: LIST
57501: LIST
57502: PPUSH
57503: CALL_OW 72
57507: PUSH
57508: FOR_IN
57509: IFFALSE 57549
// begin if not GetBWeapon ( i ) then
57511: LD_VAR 0 8
57515: PPUSH
57516: CALL_OW 269
57520: NOT
57521: IFFALSE 57547
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
57523: LD_VAR 0 8
57527: PPUSH
57528: LD_VAR 0 8
57532: PPUSH
57533: LD_VAR 0 2
57537: PPUSH
57538: CALL 58797 0 2
57542: PPUSH
57543: CALL_OW 431
// end ;
57547: GO 57508
57549: POP
57550: POP
// end ; for i = 1 to personel do
57551: LD_ADDR_VAR 0 8
57555: PUSH
57556: DOUBLE
57557: LD_INT 1
57559: DEC
57560: ST_TO_ADDR
57561: LD_VAR 0 6
57565: PUSH
57566: FOR_TO
57567: IFFALSE 58631
// begin if i > 4 then
57569: LD_VAR 0 8
57573: PUSH
57574: LD_INT 4
57576: GREATER
57577: IFFALSE 57581
// break ;
57579: GO 58631
// case i of 1 :
57581: LD_VAR 0 8
57585: PUSH
57586: LD_INT 1
57588: DOUBLE
57589: EQUAL
57590: IFTRUE 57594
57592: GO 57674
57594: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
57595: LD_ADDR_VAR 0 12
57599: PUSH
57600: LD_VAR 0 18
57604: PPUSH
57605: LD_INT 22
57607: PUSH
57608: LD_VAR 0 16
57612: PUSH
57613: EMPTY
57614: LIST
57615: LIST
57616: PUSH
57617: LD_INT 58
57619: PUSH
57620: EMPTY
57621: LIST
57622: PUSH
57623: LD_INT 2
57625: PUSH
57626: LD_INT 30
57628: PUSH
57629: LD_INT 32
57631: PUSH
57632: EMPTY
57633: LIST
57634: LIST
57635: PUSH
57636: LD_INT 30
57638: PUSH
57639: LD_INT 4
57641: PUSH
57642: EMPTY
57643: LIST
57644: LIST
57645: PUSH
57646: LD_INT 30
57648: PUSH
57649: LD_INT 5
57651: PUSH
57652: EMPTY
57653: LIST
57654: LIST
57655: PUSH
57656: EMPTY
57657: LIST
57658: LIST
57659: LIST
57660: LIST
57661: PUSH
57662: EMPTY
57663: LIST
57664: LIST
57665: LIST
57666: PPUSH
57667: CALL_OW 72
57671: ST_TO_ADDR
57672: GO 57896
57674: LD_INT 2
57676: DOUBLE
57677: EQUAL
57678: IFTRUE 57682
57680: GO 57744
57682: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
57683: LD_ADDR_VAR 0 12
57687: PUSH
57688: LD_VAR 0 18
57692: PPUSH
57693: LD_INT 22
57695: PUSH
57696: LD_VAR 0 16
57700: PUSH
57701: EMPTY
57702: LIST
57703: LIST
57704: PUSH
57705: LD_INT 2
57707: PUSH
57708: LD_INT 30
57710: PUSH
57711: LD_INT 0
57713: PUSH
57714: EMPTY
57715: LIST
57716: LIST
57717: PUSH
57718: LD_INT 30
57720: PUSH
57721: LD_INT 1
57723: PUSH
57724: EMPTY
57725: LIST
57726: LIST
57727: PUSH
57728: EMPTY
57729: LIST
57730: LIST
57731: LIST
57732: PUSH
57733: EMPTY
57734: LIST
57735: LIST
57736: PPUSH
57737: CALL_OW 72
57741: ST_TO_ADDR
57742: GO 57896
57744: LD_INT 3
57746: DOUBLE
57747: EQUAL
57748: IFTRUE 57752
57750: GO 57814
57752: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
57753: LD_ADDR_VAR 0 12
57757: PUSH
57758: LD_VAR 0 18
57762: PPUSH
57763: LD_INT 22
57765: PUSH
57766: LD_VAR 0 16
57770: PUSH
57771: EMPTY
57772: LIST
57773: LIST
57774: PUSH
57775: LD_INT 2
57777: PUSH
57778: LD_INT 30
57780: PUSH
57781: LD_INT 2
57783: PUSH
57784: EMPTY
57785: LIST
57786: LIST
57787: PUSH
57788: LD_INT 30
57790: PUSH
57791: LD_INT 3
57793: PUSH
57794: EMPTY
57795: LIST
57796: LIST
57797: PUSH
57798: EMPTY
57799: LIST
57800: LIST
57801: LIST
57802: PUSH
57803: EMPTY
57804: LIST
57805: LIST
57806: PPUSH
57807: CALL_OW 72
57811: ST_TO_ADDR
57812: GO 57896
57814: LD_INT 4
57816: DOUBLE
57817: EQUAL
57818: IFTRUE 57822
57820: GO 57895
57822: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
57823: LD_ADDR_VAR 0 12
57827: PUSH
57828: LD_VAR 0 18
57832: PPUSH
57833: LD_INT 22
57835: PUSH
57836: LD_VAR 0 16
57840: PUSH
57841: EMPTY
57842: LIST
57843: LIST
57844: PUSH
57845: LD_INT 2
57847: PUSH
57848: LD_INT 30
57850: PUSH
57851: LD_INT 6
57853: PUSH
57854: EMPTY
57855: LIST
57856: LIST
57857: PUSH
57858: LD_INT 30
57860: PUSH
57861: LD_INT 7
57863: PUSH
57864: EMPTY
57865: LIST
57866: LIST
57867: PUSH
57868: LD_INT 30
57870: PUSH
57871: LD_INT 8
57873: PUSH
57874: EMPTY
57875: LIST
57876: LIST
57877: PUSH
57878: EMPTY
57879: LIST
57880: LIST
57881: LIST
57882: LIST
57883: PUSH
57884: EMPTY
57885: LIST
57886: LIST
57887: PPUSH
57888: CALL_OW 72
57892: ST_TO_ADDR
57893: GO 57896
57895: POP
// if i = 1 then
57896: LD_VAR 0 8
57900: PUSH
57901: LD_INT 1
57903: EQUAL
57904: IFFALSE 58015
// begin tmp := [ ] ;
57906: LD_ADDR_VAR 0 19
57910: PUSH
57911: EMPTY
57912: ST_TO_ADDR
// for j in f do
57913: LD_ADDR_VAR 0 9
57917: PUSH
57918: LD_VAR 0 12
57922: PUSH
57923: FOR_IN
57924: IFFALSE 57997
// if GetBType ( j ) = b_bunker then
57926: LD_VAR 0 9
57930: PPUSH
57931: CALL_OW 266
57935: PUSH
57936: LD_INT 32
57938: EQUAL
57939: IFFALSE 57966
// tmp := Insert ( tmp , 1 , j ) else
57941: LD_ADDR_VAR 0 19
57945: PUSH
57946: LD_VAR 0 19
57950: PPUSH
57951: LD_INT 1
57953: PPUSH
57954: LD_VAR 0 9
57958: PPUSH
57959: CALL_OW 2
57963: ST_TO_ADDR
57964: GO 57995
// tmp := Insert ( tmp , tmp + 1 , j ) ;
57966: LD_ADDR_VAR 0 19
57970: PUSH
57971: LD_VAR 0 19
57975: PPUSH
57976: LD_VAR 0 19
57980: PUSH
57981: LD_INT 1
57983: PLUS
57984: PPUSH
57985: LD_VAR 0 9
57989: PPUSH
57990: CALL_OW 2
57994: ST_TO_ADDR
57995: GO 57923
57997: POP
57998: POP
// if tmp then
57999: LD_VAR 0 19
58003: IFFALSE 58015
// f := tmp ;
58005: LD_ADDR_VAR 0 12
58009: PUSH
58010: LD_VAR 0 19
58014: ST_TO_ADDR
// end ; x := personel [ i ] ;
58015: LD_ADDR_VAR 0 13
58019: PUSH
58020: LD_VAR 0 6
58024: PUSH
58025: LD_VAR 0 8
58029: ARRAY
58030: ST_TO_ADDR
// if x = - 1 then
58031: LD_VAR 0 13
58035: PUSH
58036: LD_INT 1
58038: NEG
58039: EQUAL
58040: IFFALSE 58249
// begin for j in f do
58042: LD_ADDR_VAR 0 9
58046: PUSH
58047: LD_VAR 0 12
58051: PUSH
58052: FOR_IN
58053: IFFALSE 58245
// repeat InitHc ;
58055: CALL_OW 19
// if GetBType ( j ) = b_barracks then
58059: LD_VAR 0 9
58063: PPUSH
58064: CALL_OW 266
58068: PUSH
58069: LD_INT 5
58071: EQUAL
58072: IFFALSE 58142
// begin if UnitsInside ( j ) < 3 then
58074: LD_VAR 0 9
58078: PPUSH
58079: CALL_OW 313
58083: PUSH
58084: LD_INT 3
58086: LESS
58087: IFFALSE 58123
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
58089: LD_INT 0
58091: PPUSH
58092: LD_INT 5
58094: PUSH
58095: LD_INT 8
58097: PUSH
58098: LD_INT 9
58100: PUSH
58101: EMPTY
58102: LIST
58103: LIST
58104: LIST
58105: PUSH
58106: LD_VAR 0 17
58110: ARRAY
58111: PPUSH
58112: LD_VAR 0 4
58116: PPUSH
58117: CALL_OW 380
58121: GO 58140
// PrepareHuman ( false , i , skill ) ;
58123: LD_INT 0
58125: PPUSH
58126: LD_VAR 0 8
58130: PPUSH
58131: LD_VAR 0 4
58135: PPUSH
58136: CALL_OW 380
// end else
58140: GO 58159
// PrepareHuman ( false , i , skill ) ;
58142: LD_INT 0
58144: PPUSH
58145: LD_VAR 0 8
58149: PPUSH
58150: LD_VAR 0 4
58154: PPUSH
58155: CALL_OW 380
// un := CreateHuman ;
58159: LD_ADDR_VAR 0 14
58163: PUSH
58164: CALL_OW 44
58168: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58169: LD_ADDR_VAR 0 7
58173: PUSH
58174: LD_VAR 0 7
58178: PPUSH
58179: LD_INT 1
58181: PPUSH
58182: LD_VAR 0 14
58186: PPUSH
58187: CALL_OW 2
58191: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
58192: LD_VAR 0 14
58196: PPUSH
58197: LD_VAR 0 9
58201: PPUSH
58202: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
58206: LD_VAR 0 9
58210: PPUSH
58211: CALL_OW 313
58215: PUSH
58216: LD_INT 6
58218: EQUAL
58219: PUSH
58220: LD_VAR 0 9
58224: PPUSH
58225: CALL_OW 266
58229: PUSH
58230: LD_INT 32
58232: PUSH
58233: LD_INT 31
58235: PUSH
58236: EMPTY
58237: LIST
58238: LIST
58239: IN
58240: OR
58241: IFFALSE 58055
58243: GO 58052
58245: POP
58246: POP
// end else
58247: GO 58629
// for j = 1 to x do
58249: LD_ADDR_VAR 0 9
58253: PUSH
58254: DOUBLE
58255: LD_INT 1
58257: DEC
58258: ST_TO_ADDR
58259: LD_VAR 0 13
58263: PUSH
58264: FOR_TO
58265: IFFALSE 58627
// begin InitHc ;
58267: CALL_OW 19
// if not f then
58271: LD_VAR 0 12
58275: NOT
58276: IFFALSE 58365
// begin PrepareHuman ( false , i , skill ) ;
58278: LD_INT 0
58280: PPUSH
58281: LD_VAR 0 8
58285: PPUSH
58286: LD_VAR 0 4
58290: PPUSH
58291: CALL_OW 380
// un := CreateHuman ;
58295: LD_ADDR_VAR 0 14
58299: PUSH
58300: CALL_OW 44
58304: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58305: LD_ADDR_VAR 0 7
58309: PUSH
58310: LD_VAR 0 7
58314: PPUSH
58315: LD_INT 1
58317: PPUSH
58318: LD_VAR 0 14
58322: PPUSH
58323: CALL_OW 2
58327: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
58328: LD_VAR 0 14
58332: PPUSH
58333: LD_VAR 0 1
58337: PPUSH
58338: CALL_OW 250
58342: PPUSH
58343: LD_VAR 0 1
58347: PPUSH
58348: CALL_OW 251
58352: PPUSH
58353: LD_INT 10
58355: PPUSH
58356: LD_INT 0
58358: PPUSH
58359: CALL_OW 50
// continue ;
58363: GO 58264
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
58365: LD_VAR 0 12
58369: PUSH
58370: LD_INT 1
58372: ARRAY
58373: PPUSH
58374: CALL_OW 313
58378: PUSH
58379: LD_VAR 0 12
58383: PUSH
58384: LD_INT 1
58386: ARRAY
58387: PPUSH
58388: CALL_OW 266
58392: PUSH
58393: LD_INT 32
58395: PUSH
58396: LD_INT 31
58398: PUSH
58399: EMPTY
58400: LIST
58401: LIST
58402: IN
58403: AND
58404: PUSH
58405: LD_VAR 0 12
58409: PUSH
58410: LD_INT 1
58412: ARRAY
58413: PPUSH
58414: CALL_OW 313
58418: PUSH
58419: LD_INT 6
58421: EQUAL
58422: OR
58423: IFFALSE 58443
// f := Delete ( f , 1 ) ;
58425: LD_ADDR_VAR 0 12
58429: PUSH
58430: LD_VAR 0 12
58434: PPUSH
58435: LD_INT 1
58437: PPUSH
58438: CALL_OW 3
58442: ST_TO_ADDR
// if not f then
58443: LD_VAR 0 12
58447: NOT
58448: IFFALSE 58466
// begin x := x + 2 ;
58450: LD_ADDR_VAR 0 13
58454: PUSH
58455: LD_VAR 0 13
58459: PUSH
58460: LD_INT 2
58462: PLUS
58463: ST_TO_ADDR
// continue ;
58464: GO 58264
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
58466: LD_VAR 0 12
58470: PUSH
58471: LD_INT 1
58473: ARRAY
58474: PPUSH
58475: CALL_OW 266
58479: PUSH
58480: LD_INT 5
58482: EQUAL
58483: IFFALSE 58557
// begin if UnitsInside ( f [ 1 ] ) < 3 then
58485: LD_VAR 0 12
58489: PUSH
58490: LD_INT 1
58492: ARRAY
58493: PPUSH
58494: CALL_OW 313
58498: PUSH
58499: LD_INT 3
58501: LESS
58502: IFFALSE 58538
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
58504: LD_INT 0
58506: PPUSH
58507: LD_INT 5
58509: PUSH
58510: LD_INT 8
58512: PUSH
58513: LD_INT 9
58515: PUSH
58516: EMPTY
58517: LIST
58518: LIST
58519: LIST
58520: PUSH
58521: LD_VAR 0 17
58525: ARRAY
58526: PPUSH
58527: LD_VAR 0 4
58531: PPUSH
58532: CALL_OW 380
58536: GO 58555
// PrepareHuman ( false , i , skill ) ;
58538: LD_INT 0
58540: PPUSH
58541: LD_VAR 0 8
58545: PPUSH
58546: LD_VAR 0 4
58550: PPUSH
58551: CALL_OW 380
// end else
58555: GO 58574
// PrepareHuman ( false , i , skill ) ;
58557: LD_INT 0
58559: PPUSH
58560: LD_VAR 0 8
58564: PPUSH
58565: LD_VAR 0 4
58569: PPUSH
58570: CALL_OW 380
// un := CreateHuman ;
58574: LD_ADDR_VAR 0 14
58578: PUSH
58579: CALL_OW 44
58583: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58584: LD_ADDR_VAR 0 7
58588: PUSH
58589: LD_VAR 0 7
58593: PPUSH
58594: LD_INT 1
58596: PPUSH
58597: LD_VAR 0 14
58601: PPUSH
58602: CALL_OW 2
58606: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
58607: LD_VAR 0 14
58611: PPUSH
58612: LD_VAR 0 12
58616: PUSH
58617: LD_INT 1
58619: ARRAY
58620: PPUSH
58621: CALL_OW 52
// end ;
58625: GO 58264
58627: POP
58628: POP
// end ;
58629: GO 57566
58631: POP
58632: POP
// result := result ^ buildings ;
58633: LD_ADDR_VAR 0 7
58637: PUSH
58638: LD_VAR 0 7
58642: PUSH
58643: LD_VAR 0 18
58647: ADD
58648: ST_TO_ADDR
// end else
58649: GO 58792
// begin for i = 1 to personel do
58651: LD_ADDR_VAR 0 8
58655: PUSH
58656: DOUBLE
58657: LD_INT 1
58659: DEC
58660: ST_TO_ADDR
58661: LD_VAR 0 6
58665: PUSH
58666: FOR_TO
58667: IFFALSE 58790
// begin if i > 4 then
58669: LD_VAR 0 8
58673: PUSH
58674: LD_INT 4
58676: GREATER
58677: IFFALSE 58681
// break ;
58679: GO 58790
// x := personel [ i ] ;
58681: LD_ADDR_VAR 0 13
58685: PUSH
58686: LD_VAR 0 6
58690: PUSH
58691: LD_VAR 0 8
58695: ARRAY
58696: ST_TO_ADDR
// if x = - 1 then
58697: LD_VAR 0 13
58701: PUSH
58702: LD_INT 1
58704: NEG
58705: EQUAL
58706: IFFALSE 58710
// continue ;
58708: GO 58666
// PrepareHuman ( false , i , skill ) ;
58710: LD_INT 0
58712: PPUSH
58713: LD_VAR 0 8
58717: PPUSH
58718: LD_VAR 0 4
58722: PPUSH
58723: CALL_OW 380
// un := CreateHuman ;
58727: LD_ADDR_VAR 0 14
58731: PUSH
58732: CALL_OW 44
58736: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
58737: LD_VAR 0 14
58741: PPUSH
58742: LD_VAR 0 1
58746: PPUSH
58747: CALL_OW 250
58751: PPUSH
58752: LD_VAR 0 1
58756: PPUSH
58757: CALL_OW 251
58761: PPUSH
58762: LD_INT 10
58764: PPUSH
58765: LD_INT 0
58767: PPUSH
58768: CALL_OW 50
// result := result ^ un ;
58772: LD_ADDR_VAR 0 7
58776: PUSH
58777: LD_VAR 0 7
58781: PUSH
58782: LD_VAR 0 14
58786: ADD
58787: ST_TO_ADDR
// end ;
58788: GO 58666
58790: POP
58791: POP
// end ; end ;
58792: LD_VAR 0 7
58796: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
58797: LD_INT 0
58799: PPUSH
58800: PPUSH
58801: PPUSH
58802: PPUSH
58803: PPUSH
58804: PPUSH
58805: PPUSH
58806: PPUSH
58807: PPUSH
58808: PPUSH
58809: PPUSH
58810: PPUSH
58811: PPUSH
58812: PPUSH
58813: PPUSH
58814: PPUSH
// result := false ;
58815: LD_ADDR_VAR 0 3
58819: PUSH
58820: LD_INT 0
58822: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
58823: LD_VAR 0 1
58827: NOT
58828: PUSH
58829: LD_VAR 0 1
58833: PPUSH
58834: CALL_OW 266
58838: PUSH
58839: LD_INT 32
58841: PUSH
58842: LD_INT 33
58844: PUSH
58845: EMPTY
58846: LIST
58847: LIST
58848: IN
58849: NOT
58850: OR
58851: IFFALSE 58855
// exit ;
58853: GO 59964
// nat := GetNation ( tower ) ;
58855: LD_ADDR_VAR 0 12
58859: PUSH
58860: LD_VAR 0 1
58864: PPUSH
58865: CALL_OW 248
58869: ST_TO_ADDR
// side := GetSide ( tower ) ;
58870: LD_ADDR_VAR 0 16
58874: PUSH
58875: LD_VAR 0 1
58879: PPUSH
58880: CALL_OW 255
58884: ST_TO_ADDR
// x := GetX ( tower ) ;
58885: LD_ADDR_VAR 0 10
58889: PUSH
58890: LD_VAR 0 1
58894: PPUSH
58895: CALL_OW 250
58899: ST_TO_ADDR
// y := GetY ( tower ) ;
58900: LD_ADDR_VAR 0 11
58904: PUSH
58905: LD_VAR 0 1
58909: PPUSH
58910: CALL_OW 251
58914: ST_TO_ADDR
// if not x or not y then
58915: LD_VAR 0 10
58919: NOT
58920: PUSH
58921: LD_VAR 0 11
58925: NOT
58926: OR
58927: IFFALSE 58931
// exit ;
58929: GO 59964
// weapon := 0 ;
58931: LD_ADDR_VAR 0 18
58935: PUSH
58936: LD_INT 0
58938: ST_TO_ADDR
// fac_list := [ ] ;
58939: LD_ADDR_VAR 0 17
58943: PUSH
58944: EMPTY
58945: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
58946: LD_ADDR_VAR 0 6
58950: PUSH
58951: LD_VAR 0 1
58955: PPUSH
58956: CALL_OW 274
58960: PPUSH
58961: LD_VAR 0 2
58965: PPUSH
58966: LD_INT 0
58968: PPUSH
58969: CALL 56535 0 3
58973: PPUSH
58974: LD_INT 30
58976: PUSH
58977: LD_INT 3
58979: PUSH
58980: EMPTY
58981: LIST
58982: LIST
58983: PPUSH
58984: CALL_OW 72
58988: ST_TO_ADDR
// if not factories then
58989: LD_VAR 0 6
58993: NOT
58994: IFFALSE 58998
// exit ;
58996: GO 59964
// for i in factories do
58998: LD_ADDR_VAR 0 8
59002: PUSH
59003: LD_VAR 0 6
59007: PUSH
59008: FOR_IN
59009: IFFALSE 59034
// fac_list := fac_list union AvailableWeaponList ( i ) ;
59011: LD_ADDR_VAR 0 17
59015: PUSH
59016: LD_VAR 0 17
59020: PUSH
59021: LD_VAR 0 8
59025: PPUSH
59026: CALL_OW 478
59030: UNION
59031: ST_TO_ADDR
59032: GO 59008
59034: POP
59035: POP
// if not fac_list then
59036: LD_VAR 0 17
59040: NOT
59041: IFFALSE 59045
// exit ;
59043: GO 59964
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
59045: LD_ADDR_VAR 0 5
59049: PUSH
59050: LD_INT 4
59052: PUSH
59053: LD_INT 5
59055: PUSH
59056: LD_INT 9
59058: PUSH
59059: LD_INT 10
59061: PUSH
59062: LD_INT 6
59064: PUSH
59065: LD_INT 7
59067: PUSH
59068: LD_INT 11
59070: PUSH
59071: EMPTY
59072: LIST
59073: LIST
59074: LIST
59075: LIST
59076: LIST
59077: LIST
59078: LIST
59079: PUSH
59080: LD_INT 27
59082: PUSH
59083: LD_INT 28
59085: PUSH
59086: LD_INT 26
59088: PUSH
59089: LD_INT 30
59091: PUSH
59092: EMPTY
59093: LIST
59094: LIST
59095: LIST
59096: LIST
59097: PUSH
59098: LD_INT 43
59100: PUSH
59101: LD_INT 44
59103: PUSH
59104: LD_INT 46
59106: PUSH
59107: LD_INT 45
59109: PUSH
59110: LD_INT 47
59112: PUSH
59113: LD_INT 49
59115: PUSH
59116: EMPTY
59117: LIST
59118: LIST
59119: LIST
59120: LIST
59121: LIST
59122: LIST
59123: PUSH
59124: EMPTY
59125: LIST
59126: LIST
59127: LIST
59128: PUSH
59129: LD_VAR 0 12
59133: ARRAY
59134: ST_TO_ADDR
// list := list isect fac_list ;
59135: LD_ADDR_VAR 0 5
59139: PUSH
59140: LD_VAR 0 5
59144: PUSH
59145: LD_VAR 0 17
59149: ISECT
59150: ST_TO_ADDR
// if not list then
59151: LD_VAR 0 5
59155: NOT
59156: IFFALSE 59160
// exit ;
59158: GO 59964
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
59160: LD_VAR 0 12
59164: PUSH
59165: LD_INT 3
59167: EQUAL
59168: PUSH
59169: LD_INT 49
59171: PUSH
59172: LD_VAR 0 5
59176: IN
59177: AND
59178: PUSH
59179: LD_INT 31
59181: PPUSH
59182: LD_VAR 0 16
59186: PPUSH
59187: CALL_OW 321
59191: PUSH
59192: LD_INT 2
59194: EQUAL
59195: AND
59196: IFFALSE 59256
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
59198: LD_INT 22
59200: PUSH
59201: LD_VAR 0 16
59205: PUSH
59206: EMPTY
59207: LIST
59208: LIST
59209: PUSH
59210: LD_INT 35
59212: PUSH
59213: LD_INT 49
59215: PUSH
59216: EMPTY
59217: LIST
59218: LIST
59219: PUSH
59220: LD_INT 91
59222: PUSH
59223: LD_VAR 0 1
59227: PUSH
59228: LD_INT 10
59230: PUSH
59231: EMPTY
59232: LIST
59233: LIST
59234: LIST
59235: PUSH
59236: EMPTY
59237: LIST
59238: LIST
59239: LIST
59240: PPUSH
59241: CALL_OW 69
59245: NOT
59246: IFFALSE 59256
// weapon := ru_time_lapser ;
59248: LD_ADDR_VAR 0 18
59252: PUSH
59253: LD_INT 49
59255: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
59256: LD_VAR 0 12
59260: PUSH
59261: LD_INT 1
59263: PUSH
59264: LD_INT 2
59266: PUSH
59267: EMPTY
59268: LIST
59269: LIST
59270: IN
59271: PUSH
59272: LD_INT 11
59274: PUSH
59275: LD_VAR 0 5
59279: IN
59280: PUSH
59281: LD_INT 30
59283: PUSH
59284: LD_VAR 0 5
59288: IN
59289: OR
59290: AND
59291: PUSH
59292: LD_INT 6
59294: PPUSH
59295: LD_VAR 0 16
59299: PPUSH
59300: CALL_OW 321
59304: PUSH
59305: LD_INT 2
59307: EQUAL
59308: AND
59309: IFFALSE 59474
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
59311: LD_INT 22
59313: PUSH
59314: LD_VAR 0 16
59318: PUSH
59319: EMPTY
59320: LIST
59321: LIST
59322: PUSH
59323: LD_INT 2
59325: PUSH
59326: LD_INT 35
59328: PUSH
59329: LD_INT 11
59331: PUSH
59332: EMPTY
59333: LIST
59334: LIST
59335: PUSH
59336: LD_INT 35
59338: PUSH
59339: LD_INT 30
59341: PUSH
59342: EMPTY
59343: LIST
59344: LIST
59345: PUSH
59346: EMPTY
59347: LIST
59348: LIST
59349: LIST
59350: PUSH
59351: LD_INT 91
59353: PUSH
59354: LD_VAR 0 1
59358: PUSH
59359: LD_INT 18
59361: PUSH
59362: EMPTY
59363: LIST
59364: LIST
59365: LIST
59366: PUSH
59367: EMPTY
59368: LIST
59369: LIST
59370: LIST
59371: PPUSH
59372: CALL_OW 69
59376: NOT
59377: PUSH
59378: LD_INT 22
59380: PUSH
59381: LD_VAR 0 16
59385: PUSH
59386: EMPTY
59387: LIST
59388: LIST
59389: PUSH
59390: LD_INT 2
59392: PUSH
59393: LD_INT 30
59395: PUSH
59396: LD_INT 32
59398: PUSH
59399: EMPTY
59400: LIST
59401: LIST
59402: PUSH
59403: LD_INT 30
59405: PUSH
59406: LD_INT 33
59408: PUSH
59409: EMPTY
59410: LIST
59411: LIST
59412: PUSH
59413: EMPTY
59414: LIST
59415: LIST
59416: LIST
59417: PUSH
59418: LD_INT 91
59420: PUSH
59421: LD_VAR 0 1
59425: PUSH
59426: LD_INT 12
59428: PUSH
59429: EMPTY
59430: LIST
59431: LIST
59432: LIST
59433: PUSH
59434: EMPTY
59435: LIST
59436: LIST
59437: LIST
59438: PUSH
59439: EMPTY
59440: LIST
59441: PPUSH
59442: CALL_OW 69
59446: PUSH
59447: LD_INT 2
59449: GREATER
59450: AND
59451: IFFALSE 59474
// weapon := [ us_radar , ar_radar ] [ nat ] ;
59453: LD_ADDR_VAR 0 18
59457: PUSH
59458: LD_INT 11
59460: PUSH
59461: LD_INT 30
59463: PUSH
59464: EMPTY
59465: LIST
59466: LIST
59467: PUSH
59468: LD_VAR 0 12
59472: ARRAY
59473: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
59474: LD_VAR 0 18
59478: NOT
59479: PUSH
59480: LD_INT 40
59482: PPUSH
59483: LD_VAR 0 16
59487: PPUSH
59488: CALL_OW 321
59492: PUSH
59493: LD_INT 2
59495: EQUAL
59496: AND
59497: PUSH
59498: LD_INT 7
59500: PUSH
59501: LD_VAR 0 5
59505: IN
59506: PUSH
59507: LD_INT 28
59509: PUSH
59510: LD_VAR 0 5
59514: IN
59515: OR
59516: PUSH
59517: LD_INT 45
59519: PUSH
59520: LD_VAR 0 5
59524: IN
59525: OR
59526: AND
59527: IFFALSE 59781
// begin hex := GetHexInfo ( x , y ) ;
59529: LD_ADDR_VAR 0 4
59533: PUSH
59534: LD_VAR 0 10
59538: PPUSH
59539: LD_VAR 0 11
59543: PPUSH
59544: CALL_OW 546
59548: ST_TO_ADDR
// if hex [ 1 ] then
59549: LD_VAR 0 4
59553: PUSH
59554: LD_INT 1
59556: ARRAY
59557: IFFALSE 59561
// exit ;
59559: GO 59964
// height := hex [ 2 ] ;
59561: LD_ADDR_VAR 0 15
59565: PUSH
59566: LD_VAR 0 4
59570: PUSH
59571: LD_INT 2
59573: ARRAY
59574: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
59575: LD_ADDR_VAR 0 14
59579: PUSH
59580: LD_INT 0
59582: PUSH
59583: LD_INT 2
59585: PUSH
59586: LD_INT 3
59588: PUSH
59589: LD_INT 5
59591: PUSH
59592: EMPTY
59593: LIST
59594: LIST
59595: LIST
59596: LIST
59597: ST_TO_ADDR
// for i in tmp do
59598: LD_ADDR_VAR 0 8
59602: PUSH
59603: LD_VAR 0 14
59607: PUSH
59608: FOR_IN
59609: IFFALSE 59779
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
59611: LD_ADDR_VAR 0 9
59615: PUSH
59616: LD_VAR 0 10
59620: PPUSH
59621: LD_VAR 0 8
59625: PPUSH
59626: LD_INT 5
59628: PPUSH
59629: CALL_OW 272
59633: PUSH
59634: LD_VAR 0 11
59638: PPUSH
59639: LD_VAR 0 8
59643: PPUSH
59644: LD_INT 5
59646: PPUSH
59647: CALL_OW 273
59651: PUSH
59652: EMPTY
59653: LIST
59654: LIST
59655: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
59656: LD_VAR 0 9
59660: PUSH
59661: LD_INT 1
59663: ARRAY
59664: PPUSH
59665: LD_VAR 0 9
59669: PUSH
59670: LD_INT 2
59672: ARRAY
59673: PPUSH
59674: CALL_OW 488
59678: IFFALSE 59777
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
59680: LD_ADDR_VAR 0 4
59684: PUSH
59685: LD_VAR 0 9
59689: PUSH
59690: LD_INT 1
59692: ARRAY
59693: PPUSH
59694: LD_VAR 0 9
59698: PUSH
59699: LD_INT 2
59701: ARRAY
59702: PPUSH
59703: CALL_OW 546
59707: ST_TO_ADDR
// if hex [ 1 ] then
59708: LD_VAR 0 4
59712: PUSH
59713: LD_INT 1
59715: ARRAY
59716: IFFALSE 59720
// continue ;
59718: GO 59608
// h := hex [ 2 ] ;
59720: LD_ADDR_VAR 0 13
59724: PUSH
59725: LD_VAR 0 4
59729: PUSH
59730: LD_INT 2
59732: ARRAY
59733: ST_TO_ADDR
// if h + 7 < height then
59734: LD_VAR 0 13
59738: PUSH
59739: LD_INT 7
59741: PLUS
59742: PUSH
59743: LD_VAR 0 15
59747: LESS
59748: IFFALSE 59777
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
59750: LD_ADDR_VAR 0 18
59754: PUSH
59755: LD_INT 7
59757: PUSH
59758: LD_INT 28
59760: PUSH
59761: LD_INT 45
59763: PUSH
59764: EMPTY
59765: LIST
59766: LIST
59767: LIST
59768: PUSH
59769: LD_VAR 0 12
59773: ARRAY
59774: ST_TO_ADDR
// break ;
59775: GO 59779
// end ; end ; end ;
59777: GO 59608
59779: POP
59780: POP
// end ; if not weapon then
59781: LD_VAR 0 18
59785: NOT
59786: IFFALSE 59846
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
59788: LD_ADDR_VAR 0 5
59792: PUSH
59793: LD_VAR 0 5
59797: PUSH
59798: LD_INT 11
59800: PUSH
59801: LD_INT 30
59803: PUSH
59804: LD_INT 49
59806: PUSH
59807: EMPTY
59808: LIST
59809: LIST
59810: LIST
59811: DIFF
59812: ST_TO_ADDR
// if not list then
59813: LD_VAR 0 5
59817: NOT
59818: IFFALSE 59822
// exit ;
59820: GO 59964
// weapon := list [ rand ( 1 , list ) ] ;
59822: LD_ADDR_VAR 0 18
59826: PUSH
59827: LD_VAR 0 5
59831: PUSH
59832: LD_INT 1
59834: PPUSH
59835: LD_VAR 0 5
59839: PPUSH
59840: CALL_OW 12
59844: ARRAY
59845: ST_TO_ADDR
// end ; if weapon then
59846: LD_VAR 0 18
59850: IFFALSE 59964
// begin tmp := CostOfWeapon ( weapon ) ;
59852: LD_ADDR_VAR 0 14
59856: PUSH
59857: LD_VAR 0 18
59861: PPUSH
59862: CALL_OW 451
59866: ST_TO_ADDR
// j := GetBase ( tower ) ;
59867: LD_ADDR_VAR 0 9
59871: PUSH
59872: LD_VAR 0 1
59876: PPUSH
59877: CALL_OW 274
59881: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
59882: LD_VAR 0 9
59886: PPUSH
59887: LD_INT 1
59889: PPUSH
59890: CALL_OW 275
59894: PUSH
59895: LD_VAR 0 14
59899: PUSH
59900: LD_INT 1
59902: ARRAY
59903: GREATEREQUAL
59904: PUSH
59905: LD_VAR 0 9
59909: PPUSH
59910: LD_INT 2
59912: PPUSH
59913: CALL_OW 275
59917: PUSH
59918: LD_VAR 0 14
59922: PUSH
59923: LD_INT 2
59925: ARRAY
59926: GREATEREQUAL
59927: AND
59928: PUSH
59929: LD_VAR 0 9
59933: PPUSH
59934: LD_INT 3
59936: PPUSH
59937: CALL_OW 275
59941: PUSH
59942: LD_VAR 0 14
59946: PUSH
59947: LD_INT 3
59949: ARRAY
59950: GREATEREQUAL
59951: AND
59952: IFFALSE 59964
// result := weapon ;
59954: LD_ADDR_VAR 0 3
59958: PUSH
59959: LD_VAR 0 18
59963: ST_TO_ADDR
// end ; end ;
59964: LD_VAR 0 3
59968: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
59969: LD_INT 0
59971: PPUSH
59972: PPUSH
// result := true ;
59973: LD_ADDR_VAR 0 3
59977: PUSH
59978: LD_INT 1
59980: ST_TO_ADDR
// if array1 = array2 then
59981: LD_VAR 0 1
59985: PUSH
59986: LD_VAR 0 2
59990: EQUAL
59991: IFFALSE 60051
// begin for i = 1 to array1 do
59993: LD_ADDR_VAR 0 4
59997: PUSH
59998: DOUBLE
59999: LD_INT 1
60001: DEC
60002: ST_TO_ADDR
60003: LD_VAR 0 1
60007: PUSH
60008: FOR_TO
60009: IFFALSE 60047
// if array1 [ i ] <> array2 [ i ] then
60011: LD_VAR 0 1
60015: PUSH
60016: LD_VAR 0 4
60020: ARRAY
60021: PUSH
60022: LD_VAR 0 2
60026: PUSH
60027: LD_VAR 0 4
60031: ARRAY
60032: NONEQUAL
60033: IFFALSE 60045
// begin result := false ;
60035: LD_ADDR_VAR 0 3
60039: PUSH
60040: LD_INT 0
60042: ST_TO_ADDR
// break ;
60043: GO 60047
// end ;
60045: GO 60008
60047: POP
60048: POP
// end else
60049: GO 60059
// result := false ;
60051: LD_ADDR_VAR 0 3
60055: PUSH
60056: LD_INT 0
60058: ST_TO_ADDR
// end ;
60059: LD_VAR 0 3
60063: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
60064: LD_INT 0
60066: PPUSH
60067: PPUSH
// if not array1 or not array2 then
60068: LD_VAR 0 1
60072: NOT
60073: PUSH
60074: LD_VAR 0 2
60078: NOT
60079: OR
60080: IFFALSE 60084
// exit ;
60082: GO 60148
// result := true ;
60084: LD_ADDR_VAR 0 3
60088: PUSH
60089: LD_INT 1
60091: ST_TO_ADDR
// for i = 1 to array1 do
60092: LD_ADDR_VAR 0 4
60096: PUSH
60097: DOUBLE
60098: LD_INT 1
60100: DEC
60101: ST_TO_ADDR
60102: LD_VAR 0 1
60106: PUSH
60107: FOR_TO
60108: IFFALSE 60146
// if array1 [ i ] <> array2 [ i ] then
60110: LD_VAR 0 1
60114: PUSH
60115: LD_VAR 0 4
60119: ARRAY
60120: PUSH
60121: LD_VAR 0 2
60125: PUSH
60126: LD_VAR 0 4
60130: ARRAY
60131: NONEQUAL
60132: IFFALSE 60144
// begin result := false ;
60134: LD_ADDR_VAR 0 3
60138: PUSH
60139: LD_INT 0
60141: ST_TO_ADDR
// break ;
60142: GO 60146
// end ;
60144: GO 60107
60146: POP
60147: POP
// end ;
60148: LD_VAR 0 3
60152: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
60153: LD_INT 0
60155: PPUSH
60156: PPUSH
60157: PPUSH
// pom := GetBase ( fac ) ;
60158: LD_ADDR_VAR 0 5
60162: PUSH
60163: LD_VAR 0 1
60167: PPUSH
60168: CALL_OW 274
60172: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
60173: LD_ADDR_VAR 0 4
60177: PUSH
60178: LD_VAR 0 2
60182: PUSH
60183: LD_INT 1
60185: ARRAY
60186: PPUSH
60187: LD_VAR 0 2
60191: PUSH
60192: LD_INT 2
60194: ARRAY
60195: PPUSH
60196: LD_VAR 0 2
60200: PUSH
60201: LD_INT 3
60203: ARRAY
60204: PPUSH
60205: LD_VAR 0 2
60209: PUSH
60210: LD_INT 4
60212: ARRAY
60213: PPUSH
60214: CALL_OW 449
60218: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60219: LD_ADDR_VAR 0 3
60223: PUSH
60224: LD_VAR 0 5
60228: PPUSH
60229: LD_INT 1
60231: PPUSH
60232: CALL_OW 275
60236: PUSH
60237: LD_VAR 0 4
60241: PUSH
60242: LD_INT 1
60244: ARRAY
60245: GREATEREQUAL
60246: PUSH
60247: LD_VAR 0 5
60251: PPUSH
60252: LD_INT 2
60254: PPUSH
60255: CALL_OW 275
60259: PUSH
60260: LD_VAR 0 4
60264: PUSH
60265: LD_INT 2
60267: ARRAY
60268: GREATEREQUAL
60269: AND
60270: PUSH
60271: LD_VAR 0 5
60275: PPUSH
60276: LD_INT 3
60278: PPUSH
60279: CALL_OW 275
60283: PUSH
60284: LD_VAR 0 4
60288: PUSH
60289: LD_INT 3
60291: ARRAY
60292: GREATEREQUAL
60293: AND
60294: ST_TO_ADDR
// end ;
60295: LD_VAR 0 3
60299: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
60300: LD_INT 0
60302: PPUSH
60303: PPUSH
60304: PPUSH
60305: PPUSH
// pom := GetBase ( building ) ;
60306: LD_ADDR_VAR 0 3
60310: PUSH
60311: LD_VAR 0 1
60315: PPUSH
60316: CALL_OW 274
60320: ST_TO_ADDR
// if not pom then
60321: LD_VAR 0 3
60325: NOT
60326: IFFALSE 60330
// exit ;
60328: GO 60500
// btype := GetBType ( building ) ;
60330: LD_ADDR_VAR 0 5
60334: PUSH
60335: LD_VAR 0 1
60339: PPUSH
60340: CALL_OW 266
60344: ST_TO_ADDR
// if btype = b_armoury then
60345: LD_VAR 0 5
60349: PUSH
60350: LD_INT 4
60352: EQUAL
60353: IFFALSE 60363
// btype := b_barracks ;
60355: LD_ADDR_VAR 0 5
60359: PUSH
60360: LD_INT 5
60362: ST_TO_ADDR
// if btype = b_depot then
60363: LD_VAR 0 5
60367: PUSH
60368: LD_INT 0
60370: EQUAL
60371: IFFALSE 60381
// btype := b_warehouse ;
60373: LD_ADDR_VAR 0 5
60377: PUSH
60378: LD_INT 1
60380: ST_TO_ADDR
// if btype = b_workshop then
60381: LD_VAR 0 5
60385: PUSH
60386: LD_INT 2
60388: EQUAL
60389: IFFALSE 60399
// btype := b_factory ;
60391: LD_ADDR_VAR 0 5
60395: PUSH
60396: LD_INT 3
60398: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
60399: LD_ADDR_VAR 0 4
60403: PUSH
60404: LD_VAR 0 5
60408: PPUSH
60409: LD_VAR 0 1
60413: PPUSH
60414: CALL_OW 248
60418: PPUSH
60419: CALL_OW 450
60423: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60424: LD_ADDR_VAR 0 2
60428: PUSH
60429: LD_VAR 0 3
60433: PPUSH
60434: LD_INT 1
60436: PPUSH
60437: CALL_OW 275
60441: PUSH
60442: LD_VAR 0 4
60446: PUSH
60447: LD_INT 1
60449: ARRAY
60450: GREATEREQUAL
60451: PUSH
60452: LD_VAR 0 3
60456: PPUSH
60457: LD_INT 2
60459: PPUSH
60460: CALL_OW 275
60464: PUSH
60465: LD_VAR 0 4
60469: PUSH
60470: LD_INT 2
60472: ARRAY
60473: GREATEREQUAL
60474: AND
60475: PUSH
60476: LD_VAR 0 3
60480: PPUSH
60481: LD_INT 3
60483: PPUSH
60484: CALL_OW 275
60488: PUSH
60489: LD_VAR 0 4
60493: PUSH
60494: LD_INT 3
60496: ARRAY
60497: GREATEREQUAL
60498: AND
60499: ST_TO_ADDR
// end ;
60500: LD_VAR 0 2
60504: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
60505: LD_INT 0
60507: PPUSH
60508: PPUSH
60509: PPUSH
// pom := GetBase ( building ) ;
60510: LD_ADDR_VAR 0 4
60514: PUSH
60515: LD_VAR 0 1
60519: PPUSH
60520: CALL_OW 274
60524: ST_TO_ADDR
// if not pom then
60525: LD_VAR 0 4
60529: NOT
60530: IFFALSE 60534
// exit ;
60532: GO 60635
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
60534: LD_ADDR_VAR 0 5
60538: PUSH
60539: LD_VAR 0 2
60543: PPUSH
60544: LD_VAR 0 1
60548: PPUSH
60549: CALL_OW 248
60553: PPUSH
60554: CALL_OW 450
60558: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60559: LD_ADDR_VAR 0 3
60563: PUSH
60564: LD_VAR 0 4
60568: PPUSH
60569: LD_INT 1
60571: PPUSH
60572: CALL_OW 275
60576: PUSH
60577: LD_VAR 0 5
60581: PUSH
60582: LD_INT 1
60584: ARRAY
60585: GREATEREQUAL
60586: PUSH
60587: LD_VAR 0 4
60591: PPUSH
60592: LD_INT 2
60594: PPUSH
60595: CALL_OW 275
60599: PUSH
60600: LD_VAR 0 5
60604: PUSH
60605: LD_INT 2
60607: ARRAY
60608: GREATEREQUAL
60609: AND
60610: PUSH
60611: LD_VAR 0 4
60615: PPUSH
60616: LD_INT 3
60618: PPUSH
60619: CALL_OW 275
60623: PUSH
60624: LD_VAR 0 5
60628: PUSH
60629: LD_INT 3
60631: ARRAY
60632: GREATEREQUAL
60633: AND
60634: ST_TO_ADDR
// end ;
60635: LD_VAR 0 3
60639: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
60640: LD_INT 0
60642: PPUSH
60643: PPUSH
60644: PPUSH
60645: PPUSH
60646: PPUSH
60647: PPUSH
60648: PPUSH
60649: PPUSH
60650: PPUSH
60651: PPUSH
60652: PPUSH
// result := false ;
60653: LD_ADDR_VAR 0 8
60657: PUSH
60658: LD_INT 0
60660: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
60661: LD_VAR 0 5
60665: NOT
60666: PUSH
60667: LD_VAR 0 1
60671: NOT
60672: OR
60673: PUSH
60674: LD_VAR 0 2
60678: NOT
60679: OR
60680: PUSH
60681: LD_VAR 0 3
60685: NOT
60686: OR
60687: IFFALSE 60691
// exit ;
60689: GO 61505
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
60691: LD_ADDR_VAR 0 14
60695: PUSH
60696: LD_VAR 0 1
60700: PPUSH
60701: LD_VAR 0 2
60705: PPUSH
60706: LD_VAR 0 3
60710: PPUSH
60711: LD_VAR 0 4
60715: PPUSH
60716: LD_VAR 0 5
60720: PUSH
60721: LD_INT 1
60723: ARRAY
60724: PPUSH
60725: CALL_OW 248
60729: PPUSH
60730: LD_INT 0
60732: PPUSH
60733: CALL 62738 0 6
60737: ST_TO_ADDR
// if not hexes then
60738: LD_VAR 0 14
60742: NOT
60743: IFFALSE 60747
// exit ;
60745: GO 61505
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
60747: LD_ADDR_VAR 0 17
60751: PUSH
60752: LD_VAR 0 5
60756: PPUSH
60757: LD_INT 22
60759: PUSH
60760: LD_VAR 0 13
60764: PPUSH
60765: CALL_OW 255
60769: PUSH
60770: EMPTY
60771: LIST
60772: LIST
60773: PUSH
60774: LD_INT 2
60776: PUSH
60777: LD_INT 30
60779: PUSH
60780: LD_INT 0
60782: PUSH
60783: EMPTY
60784: LIST
60785: LIST
60786: PUSH
60787: LD_INT 30
60789: PUSH
60790: LD_INT 1
60792: PUSH
60793: EMPTY
60794: LIST
60795: LIST
60796: PUSH
60797: EMPTY
60798: LIST
60799: LIST
60800: LIST
60801: PUSH
60802: EMPTY
60803: LIST
60804: LIST
60805: PPUSH
60806: CALL_OW 72
60810: ST_TO_ADDR
// for i = 1 to hexes do
60811: LD_ADDR_VAR 0 9
60815: PUSH
60816: DOUBLE
60817: LD_INT 1
60819: DEC
60820: ST_TO_ADDR
60821: LD_VAR 0 14
60825: PUSH
60826: FOR_TO
60827: IFFALSE 61503
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
60829: LD_ADDR_VAR 0 13
60833: PUSH
60834: LD_VAR 0 14
60838: PUSH
60839: LD_VAR 0 9
60843: ARRAY
60844: PUSH
60845: LD_INT 1
60847: ARRAY
60848: PPUSH
60849: LD_VAR 0 14
60853: PUSH
60854: LD_VAR 0 9
60858: ARRAY
60859: PUSH
60860: LD_INT 2
60862: ARRAY
60863: PPUSH
60864: CALL_OW 428
60868: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
60869: LD_VAR 0 14
60873: PUSH
60874: LD_VAR 0 9
60878: ARRAY
60879: PUSH
60880: LD_INT 1
60882: ARRAY
60883: PPUSH
60884: LD_VAR 0 14
60888: PUSH
60889: LD_VAR 0 9
60893: ARRAY
60894: PUSH
60895: LD_INT 2
60897: ARRAY
60898: PPUSH
60899: CALL_OW 351
60903: PUSH
60904: LD_VAR 0 14
60908: PUSH
60909: LD_VAR 0 9
60913: ARRAY
60914: PUSH
60915: LD_INT 1
60917: ARRAY
60918: PPUSH
60919: LD_VAR 0 14
60923: PUSH
60924: LD_VAR 0 9
60928: ARRAY
60929: PUSH
60930: LD_INT 2
60932: ARRAY
60933: PPUSH
60934: CALL_OW 488
60938: NOT
60939: OR
60940: PUSH
60941: LD_VAR 0 13
60945: PPUSH
60946: CALL_OW 247
60950: PUSH
60951: LD_INT 3
60953: EQUAL
60954: OR
60955: IFFALSE 60961
// exit ;
60957: POP
60958: POP
60959: GO 61505
// if not tmp then
60961: LD_VAR 0 13
60965: NOT
60966: IFFALSE 60970
// continue ;
60968: GO 60826
// result := true ;
60970: LD_ADDR_VAR 0 8
60974: PUSH
60975: LD_INT 1
60977: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
60978: LD_VAR 0 6
60982: PUSH
60983: LD_VAR 0 13
60987: PPUSH
60988: CALL_OW 247
60992: PUSH
60993: LD_INT 2
60995: EQUAL
60996: AND
60997: PUSH
60998: LD_VAR 0 13
61002: PPUSH
61003: CALL_OW 263
61007: PUSH
61008: LD_INT 1
61010: EQUAL
61011: AND
61012: IFFALSE 61176
// begin if IsDrivenBy ( tmp ) then
61014: LD_VAR 0 13
61018: PPUSH
61019: CALL_OW 311
61023: IFFALSE 61027
// continue ;
61025: GO 60826
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
61027: LD_VAR 0 6
61031: PPUSH
61032: LD_INT 3
61034: PUSH
61035: LD_INT 60
61037: PUSH
61038: EMPTY
61039: LIST
61040: PUSH
61041: EMPTY
61042: LIST
61043: LIST
61044: PUSH
61045: LD_INT 3
61047: PUSH
61048: LD_INT 55
61050: PUSH
61051: EMPTY
61052: LIST
61053: PUSH
61054: EMPTY
61055: LIST
61056: LIST
61057: PUSH
61058: EMPTY
61059: LIST
61060: LIST
61061: PPUSH
61062: CALL_OW 72
61066: IFFALSE 61174
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
61068: LD_ADDR_VAR 0 18
61072: PUSH
61073: LD_VAR 0 6
61077: PPUSH
61078: LD_INT 3
61080: PUSH
61081: LD_INT 60
61083: PUSH
61084: EMPTY
61085: LIST
61086: PUSH
61087: EMPTY
61088: LIST
61089: LIST
61090: PUSH
61091: LD_INT 3
61093: PUSH
61094: LD_INT 55
61096: PUSH
61097: EMPTY
61098: LIST
61099: PUSH
61100: EMPTY
61101: LIST
61102: LIST
61103: PUSH
61104: EMPTY
61105: LIST
61106: LIST
61107: PPUSH
61108: CALL_OW 72
61112: PUSH
61113: LD_INT 1
61115: ARRAY
61116: ST_TO_ADDR
// if IsInUnit ( driver ) then
61117: LD_VAR 0 18
61121: PPUSH
61122: CALL_OW 310
61126: IFFALSE 61137
// ComExit ( driver ) ;
61128: LD_VAR 0 18
61132: PPUSH
61133: CALL 86499 0 1
// AddComEnterUnit ( driver , tmp ) ;
61137: LD_VAR 0 18
61141: PPUSH
61142: LD_VAR 0 13
61146: PPUSH
61147: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
61151: LD_VAR 0 18
61155: PPUSH
61156: LD_VAR 0 7
61160: PPUSH
61161: CALL_OW 173
// AddComExitVehicle ( driver ) ;
61165: LD_VAR 0 18
61169: PPUSH
61170: CALL_OW 181
// end ; continue ;
61174: GO 60826
// end ; if not cleaners or not tmp in cleaners then
61176: LD_VAR 0 6
61180: NOT
61181: PUSH
61182: LD_VAR 0 13
61186: PUSH
61187: LD_VAR 0 6
61191: IN
61192: NOT
61193: OR
61194: IFFALSE 61501
// begin if dep then
61196: LD_VAR 0 17
61200: IFFALSE 61336
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
61202: LD_ADDR_VAR 0 16
61206: PUSH
61207: LD_VAR 0 17
61211: PUSH
61212: LD_INT 1
61214: ARRAY
61215: PPUSH
61216: CALL_OW 250
61220: PPUSH
61221: LD_VAR 0 17
61225: PUSH
61226: LD_INT 1
61228: ARRAY
61229: PPUSH
61230: CALL_OW 254
61234: PPUSH
61235: LD_INT 5
61237: PPUSH
61238: CALL_OW 272
61242: PUSH
61243: LD_VAR 0 17
61247: PUSH
61248: LD_INT 1
61250: ARRAY
61251: PPUSH
61252: CALL_OW 251
61256: PPUSH
61257: LD_VAR 0 17
61261: PUSH
61262: LD_INT 1
61264: ARRAY
61265: PPUSH
61266: CALL_OW 254
61270: PPUSH
61271: LD_INT 5
61273: PPUSH
61274: CALL_OW 273
61278: PUSH
61279: EMPTY
61280: LIST
61281: LIST
61282: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
61283: LD_VAR 0 16
61287: PUSH
61288: LD_INT 1
61290: ARRAY
61291: PPUSH
61292: LD_VAR 0 16
61296: PUSH
61297: LD_INT 2
61299: ARRAY
61300: PPUSH
61301: CALL_OW 488
61305: IFFALSE 61336
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
61307: LD_VAR 0 13
61311: PPUSH
61312: LD_VAR 0 16
61316: PUSH
61317: LD_INT 1
61319: ARRAY
61320: PPUSH
61321: LD_VAR 0 16
61325: PUSH
61326: LD_INT 2
61328: ARRAY
61329: PPUSH
61330: CALL_OW 111
// continue ;
61334: GO 60826
// end ; end ; r := GetDir ( tmp ) ;
61336: LD_ADDR_VAR 0 15
61340: PUSH
61341: LD_VAR 0 13
61345: PPUSH
61346: CALL_OW 254
61350: ST_TO_ADDR
// if r = 5 then
61351: LD_VAR 0 15
61355: PUSH
61356: LD_INT 5
61358: EQUAL
61359: IFFALSE 61369
// r := 0 ;
61361: LD_ADDR_VAR 0 15
61365: PUSH
61366: LD_INT 0
61368: ST_TO_ADDR
// for j = r to 5 do
61369: LD_ADDR_VAR 0 10
61373: PUSH
61374: DOUBLE
61375: LD_VAR 0 15
61379: DEC
61380: ST_TO_ADDR
61381: LD_INT 5
61383: PUSH
61384: FOR_TO
61385: IFFALSE 61499
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
61387: LD_ADDR_VAR 0 11
61391: PUSH
61392: LD_VAR 0 13
61396: PPUSH
61397: CALL_OW 250
61401: PPUSH
61402: LD_VAR 0 10
61406: PPUSH
61407: LD_INT 2
61409: PPUSH
61410: CALL_OW 272
61414: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
61415: LD_ADDR_VAR 0 12
61419: PUSH
61420: LD_VAR 0 13
61424: PPUSH
61425: CALL_OW 251
61429: PPUSH
61430: LD_VAR 0 10
61434: PPUSH
61435: LD_INT 2
61437: PPUSH
61438: CALL_OW 273
61442: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
61443: LD_VAR 0 11
61447: PPUSH
61448: LD_VAR 0 12
61452: PPUSH
61453: CALL_OW 488
61457: PUSH
61458: LD_VAR 0 11
61462: PPUSH
61463: LD_VAR 0 12
61467: PPUSH
61468: CALL_OW 428
61472: NOT
61473: AND
61474: IFFALSE 61497
// begin ComMoveXY ( tmp , _x , _y ) ;
61476: LD_VAR 0 13
61480: PPUSH
61481: LD_VAR 0 11
61485: PPUSH
61486: LD_VAR 0 12
61490: PPUSH
61491: CALL_OW 111
// break ;
61495: GO 61499
// end ; end ;
61497: GO 61384
61499: POP
61500: POP
// end ; end ;
61501: GO 60826
61503: POP
61504: POP
// end ;
61505: LD_VAR 0 8
61509: RET
// export function BuildingTechInvented ( side , btype ) ; begin
61510: LD_INT 0
61512: PPUSH
// result := true ;
61513: LD_ADDR_VAR 0 3
61517: PUSH
61518: LD_INT 1
61520: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
61521: LD_VAR 0 2
61525: PUSH
61526: LD_INT 24
61528: DOUBLE
61529: EQUAL
61530: IFTRUE 61540
61532: LD_INT 33
61534: DOUBLE
61535: EQUAL
61536: IFTRUE 61540
61538: GO 61565
61540: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
61541: LD_ADDR_VAR 0 3
61545: PUSH
61546: LD_INT 32
61548: PPUSH
61549: LD_VAR 0 1
61553: PPUSH
61554: CALL_OW 321
61558: PUSH
61559: LD_INT 2
61561: EQUAL
61562: ST_TO_ADDR
61563: GO 61881
61565: LD_INT 20
61567: DOUBLE
61568: EQUAL
61569: IFTRUE 61573
61571: GO 61598
61573: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
61574: LD_ADDR_VAR 0 3
61578: PUSH
61579: LD_INT 6
61581: PPUSH
61582: LD_VAR 0 1
61586: PPUSH
61587: CALL_OW 321
61591: PUSH
61592: LD_INT 2
61594: EQUAL
61595: ST_TO_ADDR
61596: GO 61881
61598: LD_INT 22
61600: DOUBLE
61601: EQUAL
61602: IFTRUE 61612
61604: LD_INT 36
61606: DOUBLE
61607: EQUAL
61608: IFTRUE 61612
61610: GO 61637
61612: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
61613: LD_ADDR_VAR 0 3
61617: PUSH
61618: LD_INT 15
61620: PPUSH
61621: LD_VAR 0 1
61625: PPUSH
61626: CALL_OW 321
61630: PUSH
61631: LD_INT 2
61633: EQUAL
61634: ST_TO_ADDR
61635: GO 61881
61637: LD_INT 30
61639: DOUBLE
61640: EQUAL
61641: IFTRUE 61645
61643: GO 61670
61645: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
61646: LD_ADDR_VAR 0 3
61650: PUSH
61651: LD_INT 20
61653: PPUSH
61654: LD_VAR 0 1
61658: PPUSH
61659: CALL_OW 321
61663: PUSH
61664: LD_INT 2
61666: EQUAL
61667: ST_TO_ADDR
61668: GO 61881
61670: LD_INT 28
61672: DOUBLE
61673: EQUAL
61674: IFTRUE 61684
61676: LD_INT 21
61678: DOUBLE
61679: EQUAL
61680: IFTRUE 61684
61682: GO 61709
61684: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
61685: LD_ADDR_VAR 0 3
61689: PUSH
61690: LD_INT 21
61692: PPUSH
61693: LD_VAR 0 1
61697: PPUSH
61698: CALL_OW 321
61702: PUSH
61703: LD_INT 2
61705: EQUAL
61706: ST_TO_ADDR
61707: GO 61881
61709: LD_INT 16
61711: DOUBLE
61712: EQUAL
61713: IFTRUE 61717
61715: GO 61742
61717: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
61718: LD_ADDR_VAR 0 3
61722: PUSH
61723: LD_INT 84
61725: PPUSH
61726: LD_VAR 0 1
61730: PPUSH
61731: CALL_OW 321
61735: PUSH
61736: LD_INT 2
61738: EQUAL
61739: ST_TO_ADDR
61740: GO 61881
61742: LD_INT 19
61744: DOUBLE
61745: EQUAL
61746: IFTRUE 61756
61748: LD_INT 23
61750: DOUBLE
61751: EQUAL
61752: IFTRUE 61756
61754: GO 61781
61756: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
61757: LD_ADDR_VAR 0 3
61761: PUSH
61762: LD_INT 83
61764: PPUSH
61765: LD_VAR 0 1
61769: PPUSH
61770: CALL_OW 321
61774: PUSH
61775: LD_INT 2
61777: EQUAL
61778: ST_TO_ADDR
61779: GO 61881
61781: LD_INT 17
61783: DOUBLE
61784: EQUAL
61785: IFTRUE 61789
61787: GO 61814
61789: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
61790: LD_ADDR_VAR 0 3
61794: PUSH
61795: LD_INT 39
61797: PPUSH
61798: LD_VAR 0 1
61802: PPUSH
61803: CALL_OW 321
61807: PUSH
61808: LD_INT 2
61810: EQUAL
61811: ST_TO_ADDR
61812: GO 61881
61814: LD_INT 18
61816: DOUBLE
61817: EQUAL
61818: IFTRUE 61822
61820: GO 61847
61822: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
61823: LD_ADDR_VAR 0 3
61827: PUSH
61828: LD_INT 40
61830: PPUSH
61831: LD_VAR 0 1
61835: PPUSH
61836: CALL_OW 321
61840: PUSH
61841: LD_INT 2
61843: EQUAL
61844: ST_TO_ADDR
61845: GO 61881
61847: LD_INT 27
61849: DOUBLE
61850: EQUAL
61851: IFTRUE 61855
61853: GO 61880
61855: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
61856: LD_ADDR_VAR 0 3
61860: PUSH
61861: LD_INT 35
61863: PPUSH
61864: LD_VAR 0 1
61868: PPUSH
61869: CALL_OW 321
61873: PUSH
61874: LD_INT 2
61876: EQUAL
61877: ST_TO_ADDR
61878: GO 61881
61880: POP
// end ;
61881: LD_VAR 0 3
61885: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
61886: LD_INT 0
61888: PPUSH
61889: PPUSH
61890: PPUSH
61891: PPUSH
61892: PPUSH
61893: PPUSH
61894: PPUSH
61895: PPUSH
61896: PPUSH
61897: PPUSH
61898: PPUSH
// result := false ;
61899: LD_ADDR_VAR 0 6
61903: PUSH
61904: LD_INT 0
61906: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
61907: LD_VAR 0 1
61911: NOT
61912: PUSH
61913: LD_VAR 0 1
61917: PPUSH
61918: CALL_OW 266
61922: PUSH
61923: LD_INT 0
61925: PUSH
61926: LD_INT 1
61928: PUSH
61929: EMPTY
61930: LIST
61931: LIST
61932: IN
61933: NOT
61934: OR
61935: PUSH
61936: LD_VAR 0 2
61940: NOT
61941: OR
61942: PUSH
61943: LD_VAR 0 5
61947: PUSH
61948: LD_INT 0
61950: PUSH
61951: LD_INT 1
61953: PUSH
61954: LD_INT 2
61956: PUSH
61957: LD_INT 3
61959: PUSH
61960: LD_INT 4
61962: PUSH
61963: LD_INT 5
61965: PUSH
61966: EMPTY
61967: LIST
61968: LIST
61969: LIST
61970: LIST
61971: LIST
61972: LIST
61973: IN
61974: NOT
61975: OR
61976: PUSH
61977: LD_VAR 0 3
61981: PPUSH
61982: LD_VAR 0 4
61986: PPUSH
61987: CALL_OW 488
61991: NOT
61992: OR
61993: IFFALSE 61997
// exit ;
61995: GO 62733
// side := GetSide ( depot ) ;
61997: LD_ADDR_VAR 0 9
62001: PUSH
62002: LD_VAR 0 1
62006: PPUSH
62007: CALL_OW 255
62011: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
62012: LD_VAR 0 9
62016: PPUSH
62017: LD_VAR 0 2
62021: PPUSH
62022: CALL 61510 0 2
62026: NOT
62027: IFFALSE 62031
// exit ;
62029: GO 62733
// pom := GetBase ( depot ) ;
62031: LD_ADDR_VAR 0 10
62035: PUSH
62036: LD_VAR 0 1
62040: PPUSH
62041: CALL_OW 274
62045: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
62046: LD_ADDR_VAR 0 11
62050: PUSH
62051: LD_VAR 0 2
62055: PPUSH
62056: LD_VAR 0 1
62060: PPUSH
62061: CALL_OW 248
62065: PPUSH
62066: CALL_OW 450
62070: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
62071: LD_VAR 0 10
62075: PPUSH
62076: LD_INT 1
62078: PPUSH
62079: CALL_OW 275
62083: PUSH
62084: LD_VAR 0 11
62088: PUSH
62089: LD_INT 1
62091: ARRAY
62092: GREATEREQUAL
62093: PUSH
62094: LD_VAR 0 10
62098: PPUSH
62099: LD_INT 2
62101: PPUSH
62102: CALL_OW 275
62106: PUSH
62107: LD_VAR 0 11
62111: PUSH
62112: LD_INT 2
62114: ARRAY
62115: GREATEREQUAL
62116: AND
62117: PUSH
62118: LD_VAR 0 10
62122: PPUSH
62123: LD_INT 3
62125: PPUSH
62126: CALL_OW 275
62130: PUSH
62131: LD_VAR 0 11
62135: PUSH
62136: LD_INT 3
62138: ARRAY
62139: GREATEREQUAL
62140: AND
62141: NOT
62142: IFFALSE 62146
// exit ;
62144: GO 62733
// if GetBType ( depot ) = b_depot then
62146: LD_VAR 0 1
62150: PPUSH
62151: CALL_OW 266
62155: PUSH
62156: LD_INT 0
62158: EQUAL
62159: IFFALSE 62171
// dist := 28 else
62161: LD_ADDR_VAR 0 14
62165: PUSH
62166: LD_INT 28
62168: ST_TO_ADDR
62169: GO 62179
// dist := 36 ;
62171: LD_ADDR_VAR 0 14
62175: PUSH
62176: LD_INT 36
62178: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
62179: LD_VAR 0 1
62183: PPUSH
62184: LD_VAR 0 3
62188: PPUSH
62189: LD_VAR 0 4
62193: PPUSH
62194: CALL_OW 297
62198: PUSH
62199: LD_VAR 0 14
62203: GREATER
62204: IFFALSE 62208
// exit ;
62206: GO 62733
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
62208: LD_ADDR_VAR 0 12
62212: PUSH
62213: LD_VAR 0 2
62217: PPUSH
62218: LD_VAR 0 3
62222: PPUSH
62223: LD_VAR 0 4
62227: PPUSH
62228: LD_VAR 0 5
62232: PPUSH
62233: LD_VAR 0 1
62237: PPUSH
62238: CALL_OW 248
62242: PPUSH
62243: LD_INT 0
62245: PPUSH
62246: CALL 62738 0 6
62250: ST_TO_ADDR
// if not hexes then
62251: LD_VAR 0 12
62255: NOT
62256: IFFALSE 62260
// exit ;
62258: GO 62733
// hex := GetHexInfo ( x , y ) ;
62260: LD_ADDR_VAR 0 15
62264: PUSH
62265: LD_VAR 0 3
62269: PPUSH
62270: LD_VAR 0 4
62274: PPUSH
62275: CALL_OW 546
62279: ST_TO_ADDR
// if hex [ 1 ] then
62280: LD_VAR 0 15
62284: PUSH
62285: LD_INT 1
62287: ARRAY
62288: IFFALSE 62292
// exit ;
62290: GO 62733
// height := hex [ 2 ] ;
62292: LD_ADDR_VAR 0 13
62296: PUSH
62297: LD_VAR 0 15
62301: PUSH
62302: LD_INT 2
62304: ARRAY
62305: ST_TO_ADDR
// for i = 1 to hexes do
62306: LD_ADDR_VAR 0 7
62310: PUSH
62311: DOUBLE
62312: LD_INT 1
62314: DEC
62315: ST_TO_ADDR
62316: LD_VAR 0 12
62320: PUSH
62321: FOR_TO
62322: IFFALSE 62652
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
62324: LD_VAR 0 12
62328: PUSH
62329: LD_VAR 0 7
62333: ARRAY
62334: PUSH
62335: LD_INT 1
62337: ARRAY
62338: PPUSH
62339: LD_VAR 0 12
62343: PUSH
62344: LD_VAR 0 7
62348: ARRAY
62349: PUSH
62350: LD_INT 2
62352: ARRAY
62353: PPUSH
62354: CALL_OW 488
62358: NOT
62359: PUSH
62360: LD_VAR 0 12
62364: PUSH
62365: LD_VAR 0 7
62369: ARRAY
62370: PUSH
62371: LD_INT 1
62373: ARRAY
62374: PPUSH
62375: LD_VAR 0 12
62379: PUSH
62380: LD_VAR 0 7
62384: ARRAY
62385: PUSH
62386: LD_INT 2
62388: ARRAY
62389: PPUSH
62390: CALL_OW 428
62394: PUSH
62395: LD_INT 0
62397: GREATER
62398: OR
62399: PUSH
62400: LD_VAR 0 12
62404: PUSH
62405: LD_VAR 0 7
62409: ARRAY
62410: PUSH
62411: LD_INT 1
62413: ARRAY
62414: PPUSH
62415: LD_VAR 0 12
62419: PUSH
62420: LD_VAR 0 7
62424: ARRAY
62425: PUSH
62426: LD_INT 2
62428: ARRAY
62429: PPUSH
62430: CALL_OW 351
62434: OR
62435: IFFALSE 62441
// exit ;
62437: POP
62438: POP
62439: GO 62733
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
62441: LD_ADDR_VAR 0 8
62445: PUSH
62446: LD_VAR 0 12
62450: PUSH
62451: LD_VAR 0 7
62455: ARRAY
62456: PUSH
62457: LD_INT 1
62459: ARRAY
62460: PPUSH
62461: LD_VAR 0 12
62465: PUSH
62466: LD_VAR 0 7
62470: ARRAY
62471: PUSH
62472: LD_INT 2
62474: ARRAY
62475: PPUSH
62476: CALL_OW 546
62480: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
62481: LD_VAR 0 8
62485: PUSH
62486: LD_INT 1
62488: ARRAY
62489: PUSH
62490: LD_VAR 0 8
62494: PUSH
62495: LD_INT 2
62497: ARRAY
62498: PUSH
62499: LD_VAR 0 13
62503: PUSH
62504: LD_INT 2
62506: PLUS
62507: GREATER
62508: OR
62509: PUSH
62510: LD_VAR 0 8
62514: PUSH
62515: LD_INT 2
62517: ARRAY
62518: PUSH
62519: LD_VAR 0 13
62523: PUSH
62524: LD_INT 2
62526: MINUS
62527: LESS
62528: OR
62529: PUSH
62530: LD_VAR 0 8
62534: PUSH
62535: LD_INT 3
62537: ARRAY
62538: PUSH
62539: LD_INT 0
62541: PUSH
62542: LD_INT 8
62544: PUSH
62545: LD_INT 9
62547: PUSH
62548: LD_INT 10
62550: PUSH
62551: LD_INT 11
62553: PUSH
62554: LD_INT 12
62556: PUSH
62557: LD_INT 13
62559: PUSH
62560: LD_INT 16
62562: PUSH
62563: LD_INT 17
62565: PUSH
62566: LD_INT 18
62568: PUSH
62569: LD_INT 19
62571: PUSH
62572: LD_INT 20
62574: PUSH
62575: LD_INT 21
62577: PUSH
62578: EMPTY
62579: LIST
62580: LIST
62581: LIST
62582: LIST
62583: LIST
62584: LIST
62585: LIST
62586: LIST
62587: LIST
62588: LIST
62589: LIST
62590: LIST
62591: LIST
62592: IN
62593: NOT
62594: OR
62595: PUSH
62596: LD_VAR 0 8
62600: PUSH
62601: LD_INT 5
62603: ARRAY
62604: NOT
62605: OR
62606: PUSH
62607: LD_VAR 0 8
62611: PUSH
62612: LD_INT 6
62614: ARRAY
62615: PUSH
62616: LD_INT 1
62618: PUSH
62619: LD_INT 2
62621: PUSH
62622: LD_INT 7
62624: PUSH
62625: LD_INT 9
62627: PUSH
62628: LD_INT 10
62630: PUSH
62631: LD_INT 11
62633: PUSH
62634: EMPTY
62635: LIST
62636: LIST
62637: LIST
62638: LIST
62639: LIST
62640: LIST
62641: IN
62642: NOT
62643: OR
62644: IFFALSE 62650
// exit ;
62646: POP
62647: POP
62648: GO 62733
// end ;
62650: GO 62321
62652: POP
62653: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
62654: LD_VAR 0 9
62658: PPUSH
62659: LD_VAR 0 3
62663: PPUSH
62664: LD_VAR 0 4
62668: PPUSH
62669: LD_INT 20
62671: PPUSH
62672: CALL 54685 0 4
62676: PUSH
62677: LD_INT 4
62679: ARRAY
62680: IFFALSE 62684
// exit ;
62682: GO 62733
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
62684: LD_VAR 0 2
62688: PUSH
62689: LD_INT 29
62691: PUSH
62692: LD_INT 30
62694: PUSH
62695: EMPTY
62696: LIST
62697: LIST
62698: IN
62699: PUSH
62700: LD_VAR 0 3
62704: PPUSH
62705: LD_VAR 0 4
62709: PPUSH
62710: LD_VAR 0 9
62714: PPUSH
62715: CALL_OW 440
62719: NOT
62720: AND
62721: IFFALSE 62725
// exit ;
62723: GO 62733
// result := true ;
62725: LD_ADDR_VAR 0 6
62729: PUSH
62730: LD_INT 1
62732: ST_TO_ADDR
// end ;
62733: LD_VAR 0 6
62737: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
62738: LD_INT 0
62740: PPUSH
62741: PPUSH
62742: PPUSH
62743: PPUSH
62744: PPUSH
62745: PPUSH
62746: PPUSH
62747: PPUSH
62748: PPUSH
62749: PPUSH
62750: PPUSH
62751: PPUSH
62752: PPUSH
62753: PPUSH
62754: PPUSH
62755: PPUSH
62756: PPUSH
62757: PPUSH
62758: PPUSH
62759: PPUSH
62760: PPUSH
62761: PPUSH
62762: PPUSH
62763: PPUSH
62764: PPUSH
62765: PPUSH
62766: PPUSH
62767: PPUSH
62768: PPUSH
62769: PPUSH
62770: PPUSH
62771: PPUSH
62772: PPUSH
62773: PPUSH
62774: PPUSH
62775: PPUSH
62776: PPUSH
62777: PPUSH
62778: PPUSH
62779: PPUSH
62780: PPUSH
62781: PPUSH
62782: PPUSH
62783: PPUSH
62784: PPUSH
62785: PPUSH
62786: PPUSH
62787: PPUSH
62788: PPUSH
62789: PPUSH
62790: PPUSH
62791: PPUSH
62792: PPUSH
62793: PPUSH
62794: PPUSH
62795: PPUSH
62796: PPUSH
62797: PPUSH
// result = [ ] ;
62798: LD_ADDR_VAR 0 7
62802: PUSH
62803: EMPTY
62804: ST_TO_ADDR
// temp_list = [ ] ;
62805: LD_ADDR_VAR 0 9
62809: PUSH
62810: EMPTY
62811: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
62812: LD_VAR 0 4
62816: PUSH
62817: LD_INT 0
62819: PUSH
62820: LD_INT 1
62822: PUSH
62823: LD_INT 2
62825: PUSH
62826: LD_INT 3
62828: PUSH
62829: LD_INT 4
62831: PUSH
62832: LD_INT 5
62834: PUSH
62835: EMPTY
62836: LIST
62837: LIST
62838: LIST
62839: LIST
62840: LIST
62841: LIST
62842: IN
62843: NOT
62844: PUSH
62845: LD_VAR 0 1
62849: PUSH
62850: LD_INT 0
62852: PUSH
62853: LD_INT 1
62855: PUSH
62856: EMPTY
62857: LIST
62858: LIST
62859: IN
62860: PUSH
62861: LD_VAR 0 5
62865: PUSH
62866: LD_INT 1
62868: PUSH
62869: LD_INT 2
62871: PUSH
62872: LD_INT 3
62874: PUSH
62875: EMPTY
62876: LIST
62877: LIST
62878: LIST
62879: IN
62880: NOT
62881: AND
62882: OR
62883: IFFALSE 62887
// exit ;
62885: GO 81278
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
62887: LD_VAR 0 1
62891: PUSH
62892: LD_INT 6
62894: PUSH
62895: LD_INT 7
62897: PUSH
62898: LD_INT 8
62900: PUSH
62901: LD_INT 13
62903: PUSH
62904: LD_INT 12
62906: PUSH
62907: LD_INT 15
62909: PUSH
62910: LD_INT 11
62912: PUSH
62913: LD_INT 14
62915: PUSH
62916: LD_INT 10
62918: PUSH
62919: EMPTY
62920: LIST
62921: LIST
62922: LIST
62923: LIST
62924: LIST
62925: LIST
62926: LIST
62927: LIST
62928: LIST
62929: IN
62930: IFFALSE 62940
// btype = b_lab ;
62932: LD_ADDR_VAR 0 1
62936: PUSH
62937: LD_INT 6
62939: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
62940: LD_VAR 0 6
62944: PUSH
62945: LD_INT 0
62947: PUSH
62948: LD_INT 1
62950: PUSH
62951: LD_INT 2
62953: PUSH
62954: EMPTY
62955: LIST
62956: LIST
62957: LIST
62958: IN
62959: NOT
62960: PUSH
62961: LD_VAR 0 1
62965: PUSH
62966: LD_INT 0
62968: PUSH
62969: LD_INT 1
62971: PUSH
62972: LD_INT 2
62974: PUSH
62975: LD_INT 3
62977: PUSH
62978: LD_INT 6
62980: PUSH
62981: LD_INT 36
62983: PUSH
62984: LD_INT 4
62986: PUSH
62987: LD_INT 5
62989: PUSH
62990: LD_INT 31
62992: PUSH
62993: LD_INT 32
62995: PUSH
62996: LD_INT 33
62998: PUSH
62999: EMPTY
63000: LIST
63001: LIST
63002: LIST
63003: LIST
63004: LIST
63005: LIST
63006: LIST
63007: LIST
63008: LIST
63009: LIST
63010: LIST
63011: IN
63012: NOT
63013: PUSH
63014: LD_VAR 0 6
63018: PUSH
63019: LD_INT 1
63021: EQUAL
63022: AND
63023: OR
63024: PUSH
63025: LD_VAR 0 1
63029: PUSH
63030: LD_INT 2
63032: PUSH
63033: LD_INT 3
63035: PUSH
63036: EMPTY
63037: LIST
63038: LIST
63039: IN
63040: NOT
63041: PUSH
63042: LD_VAR 0 6
63046: PUSH
63047: LD_INT 2
63049: EQUAL
63050: AND
63051: OR
63052: IFFALSE 63062
// mode = 0 ;
63054: LD_ADDR_VAR 0 6
63058: PUSH
63059: LD_INT 0
63061: ST_TO_ADDR
// case mode of 0 :
63062: LD_VAR 0 6
63066: PUSH
63067: LD_INT 0
63069: DOUBLE
63070: EQUAL
63071: IFTRUE 63075
63073: GO 74528
63075: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
63076: LD_ADDR_VAR 0 11
63080: PUSH
63081: LD_INT 0
63083: PUSH
63084: LD_INT 0
63086: PUSH
63087: EMPTY
63088: LIST
63089: LIST
63090: PUSH
63091: LD_INT 0
63093: PUSH
63094: LD_INT 1
63096: NEG
63097: PUSH
63098: EMPTY
63099: LIST
63100: LIST
63101: PUSH
63102: LD_INT 1
63104: PUSH
63105: LD_INT 0
63107: PUSH
63108: EMPTY
63109: LIST
63110: LIST
63111: PUSH
63112: LD_INT 1
63114: PUSH
63115: LD_INT 1
63117: PUSH
63118: EMPTY
63119: LIST
63120: LIST
63121: PUSH
63122: LD_INT 0
63124: PUSH
63125: LD_INT 1
63127: PUSH
63128: EMPTY
63129: LIST
63130: LIST
63131: PUSH
63132: LD_INT 1
63134: NEG
63135: PUSH
63136: LD_INT 0
63138: PUSH
63139: EMPTY
63140: LIST
63141: LIST
63142: PUSH
63143: LD_INT 1
63145: NEG
63146: PUSH
63147: LD_INT 1
63149: NEG
63150: PUSH
63151: EMPTY
63152: LIST
63153: LIST
63154: PUSH
63155: LD_INT 1
63157: NEG
63158: PUSH
63159: LD_INT 2
63161: NEG
63162: PUSH
63163: EMPTY
63164: LIST
63165: LIST
63166: PUSH
63167: LD_INT 0
63169: PUSH
63170: LD_INT 2
63172: NEG
63173: PUSH
63174: EMPTY
63175: LIST
63176: LIST
63177: PUSH
63178: LD_INT 1
63180: PUSH
63181: LD_INT 1
63183: NEG
63184: PUSH
63185: EMPTY
63186: LIST
63187: LIST
63188: PUSH
63189: LD_INT 1
63191: PUSH
63192: LD_INT 2
63194: PUSH
63195: EMPTY
63196: LIST
63197: LIST
63198: PUSH
63199: LD_INT 0
63201: PUSH
63202: LD_INT 2
63204: PUSH
63205: EMPTY
63206: LIST
63207: LIST
63208: PUSH
63209: LD_INT 1
63211: NEG
63212: PUSH
63213: LD_INT 1
63215: PUSH
63216: EMPTY
63217: LIST
63218: LIST
63219: PUSH
63220: LD_INT 1
63222: PUSH
63223: LD_INT 3
63225: PUSH
63226: EMPTY
63227: LIST
63228: LIST
63229: PUSH
63230: LD_INT 0
63232: PUSH
63233: LD_INT 3
63235: PUSH
63236: EMPTY
63237: LIST
63238: LIST
63239: PUSH
63240: LD_INT 1
63242: NEG
63243: PUSH
63244: LD_INT 2
63246: PUSH
63247: EMPTY
63248: LIST
63249: LIST
63250: PUSH
63251: EMPTY
63252: LIST
63253: LIST
63254: LIST
63255: LIST
63256: LIST
63257: LIST
63258: LIST
63259: LIST
63260: LIST
63261: LIST
63262: LIST
63263: LIST
63264: LIST
63265: LIST
63266: LIST
63267: LIST
63268: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
63269: LD_ADDR_VAR 0 12
63273: PUSH
63274: LD_INT 0
63276: PUSH
63277: LD_INT 0
63279: PUSH
63280: EMPTY
63281: LIST
63282: LIST
63283: PUSH
63284: LD_INT 0
63286: PUSH
63287: LD_INT 1
63289: NEG
63290: PUSH
63291: EMPTY
63292: LIST
63293: LIST
63294: PUSH
63295: LD_INT 1
63297: PUSH
63298: LD_INT 0
63300: PUSH
63301: EMPTY
63302: LIST
63303: LIST
63304: PUSH
63305: LD_INT 1
63307: PUSH
63308: LD_INT 1
63310: PUSH
63311: EMPTY
63312: LIST
63313: LIST
63314: PUSH
63315: LD_INT 0
63317: PUSH
63318: LD_INT 1
63320: PUSH
63321: EMPTY
63322: LIST
63323: LIST
63324: PUSH
63325: LD_INT 1
63327: NEG
63328: PUSH
63329: LD_INT 0
63331: PUSH
63332: EMPTY
63333: LIST
63334: LIST
63335: PUSH
63336: LD_INT 1
63338: NEG
63339: PUSH
63340: LD_INT 1
63342: NEG
63343: PUSH
63344: EMPTY
63345: LIST
63346: LIST
63347: PUSH
63348: LD_INT 1
63350: PUSH
63351: LD_INT 1
63353: NEG
63354: PUSH
63355: EMPTY
63356: LIST
63357: LIST
63358: PUSH
63359: LD_INT 2
63361: PUSH
63362: LD_INT 0
63364: PUSH
63365: EMPTY
63366: LIST
63367: LIST
63368: PUSH
63369: LD_INT 2
63371: PUSH
63372: LD_INT 1
63374: PUSH
63375: EMPTY
63376: LIST
63377: LIST
63378: PUSH
63379: LD_INT 1
63381: NEG
63382: PUSH
63383: LD_INT 1
63385: PUSH
63386: EMPTY
63387: LIST
63388: LIST
63389: PUSH
63390: LD_INT 2
63392: NEG
63393: PUSH
63394: LD_INT 0
63396: PUSH
63397: EMPTY
63398: LIST
63399: LIST
63400: PUSH
63401: LD_INT 2
63403: NEG
63404: PUSH
63405: LD_INT 1
63407: NEG
63408: PUSH
63409: EMPTY
63410: LIST
63411: LIST
63412: PUSH
63413: LD_INT 2
63415: NEG
63416: PUSH
63417: LD_INT 1
63419: PUSH
63420: EMPTY
63421: LIST
63422: LIST
63423: PUSH
63424: LD_INT 3
63426: NEG
63427: PUSH
63428: LD_INT 0
63430: PUSH
63431: EMPTY
63432: LIST
63433: LIST
63434: PUSH
63435: LD_INT 3
63437: NEG
63438: PUSH
63439: LD_INT 1
63441: NEG
63442: PUSH
63443: EMPTY
63444: LIST
63445: LIST
63446: PUSH
63447: EMPTY
63448: LIST
63449: LIST
63450: LIST
63451: LIST
63452: LIST
63453: LIST
63454: LIST
63455: LIST
63456: LIST
63457: LIST
63458: LIST
63459: LIST
63460: LIST
63461: LIST
63462: LIST
63463: LIST
63464: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
63465: LD_ADDR_VAR 0 13
63469: PUSH
63470: LD_INT 0
63472: PUSH
63473: LD_INT 0
63475: PUSH
63476: EMPTY
63477: LIST
63478: LIST
63479: PUSH
63480: LD_INT 0
63482: PUSH
63483: LD_INT 1
63485: NEG
63486: PUSH
63487: EMPTY
63488: LIST
63489: LIST
63490: PUSH
63491: LD_INT 1
63493: PUSH
63494: LD_INT 0
63496: PUSH
63497: EMPTY
63498: LIST
63499: LIST
63500: PUSH
63501: LD_INT 1
63503: PUSH
63504: LD_INT 1
63506: PUSH
63507: EMPTY
63508: LIST
63509: LIST
63510: PUSH
63511: LD_INT 0
63513: PUSH
63514: LD_INT 1
63516: PUSH
63517: EMPTY
63518: LIST
63519: LIST
63520: PUSH
63521: LD_INT 1
63523: NEG
63524: PUSH
63525: LD_INT 0
63527: PUSH
63528: EMPTY
63529: LIST
63530: LIST
63531: PUSH
63532: LD_INT 1
63534: NEG
63535: PUSH
63536: LD_INT 1
63538: NEG
63539: PUSH
63540: EMPTY
63541: LIST
63542: LIST
63543: PUSH
63544: LD_INT 1
63546: NEG
63547: PUSH
63548: LD_INT 2
63550: NEG
63551: PUSH
63552: EMPTY
63553: LIST
63554: LIST
63555: PUSH
63556: LD_INT 2
63558: PUSH
63559: LD_INT 1
63561: PUSH
63562: EMPTY
63563: LIST
63564: LIST
63565: PUSH
63566: LD_INT 2
63568: PUSH
63569: LD_INT 2
63571: PUSH
63572: EMPTY
63573: LIST
63574: LIST
63575: PUSH
63576: LD_INT 1
63578: PUSH
63579: LD_INT 2
63581: PUSH
63582: EMPTY
63583: LIST
63584: LIST
63585: PUSH
63586: LD_INT 2
63588: NEG
63589: PUSH
63590: LD_INT 1
63592: NEG
63593: PUSH
63594: EMPTY
63595: LIST
63596: LIST
63597: PUSH
63598: LD_INT 2
63600: NEG
63601: PUSH
63602: LD_INT 2
63604: NEG
63605: PUSH
63606: EMPTY
63607: LIST
63608: LIST
63609: PUSH
63610: LD_INT 2
63612: NEG
63613: PUSH
63614: LD_INT 3
63616: NEG
63617: PUSH
63618: EMPTY
63619: LIST
63620: LIST
63621: PUSH
63622: LD_INT 3
63624: NEG
63625: PUSH
63626: LD_INT 2
63628: NEG
63629: PUSH
63630: EMPTY
63631: LIST
63632: LIST
63633: PUSH
63634: LD_INT 3
63636: NEG
63637: PUSH
63638: LD_INT 3
63640: NEG
63641: PUSH
63642: EMPTY
63643: LIST
63644: LIST
63645: PUSH
63646: EMPTY
63647: LIST
63648: LIST
63649: LIST
63650: LIST
63651: LIST
63652: LIST
63653: LIST
63654: LIST
63655: LIST
63656: LIST
63657: LIST
63658: LIST
63659: LIST
63660: LIST
63661: LIST
63662: LIST
63663: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
63664: LD_ADDR_VAR 0 14
63668: PUSH
63669: LD_INT 0
63671: PUSH
63672: LD_INT 0
63674: PUSH
63675: EMPTY
63676: LIST
63677: LIST
63678: PUSH
63679: LD_INT 0
63681: PUSH
63682: LD_INT 1
63684: NEG
63685: PUSH
63686: EMPTY
63687: LIST
63688: LIST
63689: PUSH
63690: LD_INT 1
63692: PUSH
63693: LD_INT 0
63695: PUSH
63696: EMPTY
63697: LIST
63698: LIST
63699: PUSH
63700: LD_INT 1
63702: PUSH
63703: LD_INT 1
63705: PUSH
63706: EMPTY
63707: LIST
63708: LIST
63709: PUSH
63710: LD_INT 0
63712: PUSH
63713: LD_INT 1
63715: PUSH
63716: EMPTY
63717: LIST
63718: LIST
63719: PUSH
63720: LD_INT 1
63722: NEG
63723: PUSH
63724: LD_INT 0
63726: PUSH
63727: EMPTY
63728: LIST
63729: LIST
63730: PUSH
63731: LD_INT 1
63733: NEG
63734: PUSH
63735: LD_INT 1
63737: NEG
63738: PUSH
63739: EMPTY
63740: LIST
63741: LIST
63742: PUSH
63743: LD_INT 1
63745: NEG
63746: PUSH
63747: LD_INT 2
63749: NEG
63750: PUSH
63751: EMPTY
63752: LIST
63753: LIST
63754: PUSH
63755: LD_INT 0
63757: PUSH
63758: LD_INT 2
63760: NEG
63761: PUSH
63762: EMPTY
63763: LIST
63764: LIST
63765: PUSH
63766: LD_INT 1
63768: PUSH
63769: LD_INT 1
63771: NEG
63772: PUSH
63773: EMPTY
63774: LIST
63775: LIST
63776: PUSH
63777: LD_INT 1
63779: PUSH
63780: LD_INT 2
63782: PUSH
63783: EMPTY
63784: LIST
63785: LIST
63786: PUSH
63787: LD_INT 0
63789: PUSH
63790: LD_INT 2
63792: PUSH
63793: EMPTY
63794: LIST
63795: LIST
63796: PUSH
63797: LD_INT 1
63799: NEG
63800: PUSH
63801: LD_INT 1
63803: PUSH
63804: EMPTY
63805: LIST
63806: LIST
63807: PUSH
63808: LD_INT 1
63810: NEG
63811: PUSH
63812: LD_INT 3
63814: NEG
63815: PUSH
63816: EMPTY
63817: LIST
63818: LIST
63819: PUSH
63820: LD_INT 0
63822: PUSH
63823: LD_INT 3
63825: NEG
63826: PUSH
63827: EMPTY
63828: LIST
63829: LIST
63830: PUSH
63831: LD_INT 1
63833: PUSH
63834: LD_INT 2
63836: NEG
63837: PUSH
63838: EMPTY
63839: LIST
63840: LIST
63841: PUSH
63842: EMPTY
63843: LIST
63844: LIST
63845: LIST
63846: LIST
63847: LIST
63848: LIST
63849: LIST
63850: LIST
63851: LIST
63852: LIST
63853: LIST
63854: LIST
63855: LIST
63856: LIST
63857: LIST
63858: LIST
63859: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
63860: LD_ADDR_VAR 0 15
63864: PUSH
63865: LD_INT 0
63867: PUSH
63868: LD_INT 0
63870: PUSH
63871: EMPTY
63872: LIST
63873: LIST
63874: PUSH
63875: LD_INT 0
63877: PUSH
63878: LD_INT 1
63880: NEG
63881: PUSH
63882: EMPTY
63883: LIST
63884: LIST
63885: PUSH
63886: LD_INT 1
63888: PUSH
63889: LD_INT 0
63891: PUSH
63892: EMPTY
63893: LIST
63894: LIST
63895: PUSH
63896: LD_INT 1
63898: PUSH
63899: LD_INT 1
63901: PUSH
63902: EMPTY
63903: LIST
63904: LIST
63905: PUSH
63906: LD_INT 0
63908: PUSH
63909: LD_INT 1
63911: PUSH
63912: EMPTY
63913: LIST
63914: LIST
63915: PUSH
63916: LD_INT 1
63918: NEG
63919: PUSH
63920: LD_INT 0
63922: PUSH
63923: EMPTY
63924: LIST
63925: LIST
63926: PUSH
63927: LD_INT 1
63929: NEG
63930: PUSH
63931: LD_INT 1
63933: NEG
63934: PUSH
63935: EMPTY
63936: LIST
63937: LIST
63938: PUSH
63939: LD_INT 1
63941: PUSH
63942: LD_INT 1
63944: NEG
63945: PUSH
63946: EMPTY
63947: LIST
63948: LIST
63949: PUSH
63950: LD_INT 2
63952: PUSH
63953: LD_INT 0
63955: PUSH
63956: EMPTY
63957: LIST
63958: LIST
63959: PUSH
63960: LD_INT 2
63962: PUSH
63963: LD_INT 1
63965: PUSH
63966: EMPTY
63967: LIST
63968: LIST
63969: PUSH
63970: LD_INT 1
63972: NEG
63973: PUSH
63974: LD_INT 1
63976: PUSH
63977: EMPTY
63978: LIST
63979: LIST
63980: PUSH
63981: LD_INT 2
63983: NEG
63984: PUSH
63985: LD_INT 0
63987: PUSH
63988: EMPTY
63989: LIST
63990: LIST
63991: PUSH
63992: LD_INT 2
63994: NEG
63995: PUSH
63996: LD_INT 1
63998: NEG
63999: PUSH
64000: EMPTY
64001: LIST
64002: LIST
64003: PUSH
64004: LD_INT 2
64006: PUSH
64007: LD_INT 1
64009: NEG
64010: PUSH
64011: EMPTY
64012: LIST
64013: LIST
64014: PUSH
64015: LD_INT 3
64017: PUSH
64018: LD_INT 0
64020: PUSH
64021: EMPTY
64022: LIST
64023: LIST
64024: PUSH
64025: LD_INT 3
64027: PUSH
64028: LD_INT 1
64030: PUSH
64031: EMPTY
64032: LIST
64033: LIST
64034: PUSH
64035: EMPTY
64036: LIST
64037: LIST
64038: LIST
64039: LIST
64040: LIST
64041: LIST
64042: LIST
64043: LIST
64044: LIST
64045: LIST
64046: LIST
64047: LIST
64048: LIST
64049: LIST
64050: LIST
64051: LIST
64052: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
64053: LD_ADDR_VAR 0 16
64057: PUSH
64058: LD_INT 0
64060: PUSH
64061: LD_INT 0
64063: PUSH
64064: EMPTY
64065: LIST
64066: LIST
64067: PUSH
64068: LD_INT 0
64070: PUSH
64071: LD_INT 1
64073: NEG
64074: PUSH
64075: EMPTY
64076: LIST
64077: LIST
64078: PUSH
64079: LD_INT 1
64081: PUSH
64082: LD_INT 0
64084: PUSH
64085: EMPTY
64086: LIST
64087: LIST
64088: PUSH
64089: LD_INT 1
64091: PUSH
64092: LD_INT 1
64094: PUSH
64095: EMPTY
64096: LIST
64097: LIST
64098: PUSH
64099: LD_INT 0
64101: PUSH
64102: LD_INT 1
64104: PUSH
64105: EMPTY
64106: LIST
64107: LIST
64108: PUSH
64109: LD_INT 1
64111: NEG
64112: PUSH
64113: LD_INT 0
64115: PUSH
64116: EMPTY
64117: LIST
64118: LIST
64119: PUSH
64120: LD_INT 1
64122: NEG
64123: PUSH
64124: LD_INT 1
64126: NEG
64127: PUSH
64128: EMPTY
64129: LIST
64130: LIST
64131: PUSH
64132: LD_INT 1
64134: NEG
64135: PUSH
64136: LD_INT 2
64138: NEG
64139: PUSH
64140: EMPTY
64141: LIST
64142: LIST
64143: PUSH
64144: LD_INT 2
64146: PUSH
64147: LD_INT 1
64149: PUSH
64150: EMPTY
64151: LIST
64152: LIST
64153: PUSH
64154: LD_INT 2
64156: PUSH
64157: LD_INT 2
64159: PUSH
64160: EMPTY
64161: LIST
64162: LIST
64163: PUSH
64164: LD_INT 1
64166: PUSH
64167: LD_INT 2
64169: PUSH
64170: EMPTY
64171: LIST
64172: LIST
64173: PUSH
64174: LD_INT 2
64176: NEG
64177: PUSH
64178: LD_INT 1
64180: NEG
64181: PUSH
64182: EMPTY
64183: LIST
64184: LIST
64185: PUSH
64186: LD_INT 2
64188: NEG
64189: PUSH
64190: LD_INT 2
64192: NEG
64193: PUSH
64194: EMPTY
64195: LIST
64196: LIST
64197: PUSH
64198: LD_INT 3
64200: PUSH
64201: LD_INT 2
64203: PUSH
64204: EMPTY
64205: LIST
64206: LIST
64207: PUSH
64208: LD_INT 3
64210: PUSH
64211: LD_INT 3
64213: PUSH
64214: EMPTY
64215: LIST
64216: LIST
64217: PUSH
64218: LD_INT 2
64220: PUSH
64221: LD_INT 3
64223: PUSH
64224: EMPTY
64225: LIST
64226: LIST
64227: PUSH
64228: EMPTY
64229: LIST
64230: LIST
64231: LIST
64232: LIST
64233: LIST
64234: LIST
64235: LIST
64236: LIST
64237: LIST
64238: LIST
64239: LIST
64240: LIST
64241: LIST
64242: LIST
64243: LIST
64244: LIST
64245: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64246: LD_ADDR_VAR 0 17
64250: PUSH
64251: LD_INT 0
64253: PUSH
64254: LD_INT 0
64256: PUSH
64257: EMPTY
64258: LIST
64259: LIST
64260: PUSH
64261: LD_INT 0
64263: PUSH
64264: LD_INT 1
64266: NEG
64267: PUSH
64268: EMPTY
64269: LIST
64270: LIST
64271: PUSH
64272: LD_INT 1
64274: PUSH
64275: LD_INT 0
64277: PUSH
64278: EMPTY
64279: LIST
64280: LIST
64281: PUSH
64282: LD_INT 1
64284: PUSH
64285: LD_INT 1
64287: PUSH
64288: EMPTY
64289: LIST
64290: LIST
64291: PUSH
64292: LD_INT 0
64294: PUSH
64295: LD_INT 1
64297: PUSH
64298: EMPTY
64299: LIST
64300: LIST
64301: PUSH
64302: LD_INT 1
64304: NEG
64305: PUSH
64306: LD_INT 0
64308: PUSH
64309: EMPTY
64310: LIST
64311: LIST
64312: PUSH
64313: LD_INT 1
64315: NEG
64316: PUSH
64317: LD_INT 1
64319: NEG
64320: PUSH
64321: EMPTY
64322: LIST
64323: LIST
64324: PUSH
64325: LD_INT 1
64327: NEG
64328: PUSH
64329: LD_INT 2
64331: NEG
64332: PUSH
64333: EMPTY
64334: LIST
64335: LIST
64336: PUSH
64337: LD_INT 0
64339: PUSH
64340: LD_INT 2
64342: NEG
64343: PUSH
64344: EMPTY
64345: LIST
64346: LIST
64347: PUSH
64348: LD_INT 1
64350: PUSH
64351: LD_INT 1
64353: NEG
64354: PUSH
64355: EMPTY
64356: LIST
64357: LIST
64358: PUSH
64359: LD_INT 2
64361: PUSH
64362: LD_INT 0
64364: PUSH
64365: EMPTY
64366: LIST
64367: LIST
64368: PUSH
64369: LD_INT 2
64371: PUSH
64372: LD_INT 1
64374: PUSH
64375: EMPTY
64376: LIST
64377: LIST
64378: PUSH
64379: LD_INT 2
64381: PUSH
64382: LD_INT 2
64384: PUSH
64385: EMPTY
64386: LIST
64387: LIST
64388: PUSH
64389: LD_INT 1
64391: PUSH
64392: LD_INT 2
64394: PUSH
64395: EMPTY
64396: LIST
64397: LIST
64398: PUSH
64399: LD_INT 0
64401: PUSH
64402: LD_INT 2
64404: PUSH
64405: EMPTY
64406: LIST
64407: LIST
64408: PUSH
64409: LD_INT 1
64411: NEG
64412: PUSH
64413: LD_INT 1
64415: PUSH
64416: EMPTY
64417: LIST
64418: LIST
64419: PUSH
64420: LD_INT 2
64422: NEG
64423: PUSH
64424: LD_INT 0
64426: PUSH
64427: EMPTY
64428: LIST
64429: LIST
64430: PUSH
64431: LD_INT 2
64433: NEG
64434: PUSH
64435: LD_INT 1
64437: NEG
64438: PUSH
64439: EMPTY
64440: LIST
64441: LIST
64442: PUSH
64443: LD_INT 2
64445: NEG
64446: PUSH
64447: LD_INT 2
64449: NEG
64450: PUSH
64451: EMPTY
64452: LIST
64453: LIST
64454: PUSH
64455: EMPTY
64456: LIST
64457: LIST
64458: LIST
64459: LIST
64460: LIST
64461: LIST
64462: LIST
64463: LIST
64464: LIST
64465: LIST
64466: LIST
64467: LIST
64468: LIST
64469: LIST
64470: LIST
64471: LIST
64472: LIST
64473: LIST
64474: LIST
64475: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64476: LD_ADDR_VAR 0 18
64480: PUSH
64481: LD_INT 0
64483: PUSH
64484: LD_INT 0
64486: PUSH
64487: EMPTY
64488: LIST
64489: LIST
64490: PUSH
64491: LD_INT 0
64493: PUSH
64494: LD_INT 1
64496: NEG
64497: PUSH
64498: EMPTY
64499: LIST
64500: LIST
64501: PUSH
64502: LD_INT 1
64504: PUSH
64505: LD_INT 0
64507: PUSH
64508: EMPTY
64509: LIST
64510: LIST
64511: PUSH
64512: LD_INT 1
64514: PUSH
64515: LD_INT 1
64517: PUSH
64518: EMPTY
64519: LIST
64520: LIST
64521: PUSH
64522: LD_INT 0
64524: PUSH
64525: LD_INT 1
64527: PUSH
64528: EMPTY
64529: LIST
64530: LIST
64531: PUSH
64532: LD_INT 1
64534: NEG
64535: PUSH
64536: LD_INT 0
64538: PUSH
64539: EMPTY
64540: LIST
64541: LIST
64542: PUSH
64543: LD_INT 1
64545: NEG
64546: PUSH
64547: LD_INT 1
64549: NEG
64550: PUSH
64551: EMPTY
64552: LIST
64553: LIST
64554: PUSH
64555: LD_INT 1
64557: NEG
64558: PUSH
64559: LD_INT 2
64561: NEG
64562: PUSH
64563: EMPTY
64564: LIST
64565: LIST
64566: PUSH
64567: LD_INT 0
64569: PUSH
64570: LD_INT 2
64572: NEG
64573: PUSH
64574: EMPTY
64575: LIST
64576: LIST
64577: PUSH
64578: LD_INT 1
64580: PUSH
64581: LD_INT 1
64583: NEG
64584: PUSH
64585: EMPTY
64586: LIST
64587: LIST
64588: PUSH
64589: LD_INT 2
64591: PUSH
64592: LD_INT 0
64594: PUSH
64595: EMPTY
64596: LIST
64597: LIST
64598: PUSH
64599: LD_INT 2
64601: PUSH
64602: LD_INT 1
64604: PUSH
64605: EMPTY
64606: LIST
64607: LIST
64608: PUSH
64609: LD_INT 2
64611: PUSH
64612: LD_INT 2
64614: PUSH
64615: EMPTY
64616: LIST
64617: LIST
64618: PUSH
64619: LD_INT 1
64621: PUSH
64622: LD_INT 2
64624: PUSH
64625: EMPTY
64626: LIST
64627: LIST
64628: PUSH
64629: LD_INT 0
64631: PUSH
64632: LD_INT 2
64634: PUSH
64635: EMPTY
64636: LIST
64637: LIST
64638: PUSH
64639: LD_INT 1
64641: NEG
64642: PUSH
64643: LD_INT 1
64645: PUSH
64646: EMPTY
64647: LIST
64648: LIST
64649: PUSH
64650: LD_INT 2
64652: NEG
64653: PUSH
64654: LD_INT 0
64656: PUSH
64657: EMPTY
64658: LIST
64659: LIST
64660: PUSH
64661: LD_INT 2
64663: NEG
64664: PUSH
64665: LD_INT 1
64667: NEG
64668: PUSH
64669: EMPTY
64670: LIST
64671: LIST
64672: PUSH
64673: LD_INT 2
64675: NEG
64676: PUSH
64677: LD_INT 2
64679: NEG
64680: PUSH
64681: EMPTY
64682: LIST
64683: LIST
64684: PUSH
64685: EMPTY
64686: LIST
64687: LIST
64688: LIST
64689: LIST
64690: LIST
64691: LIST
64692: LIST
64693: LIST
64694: LIST
64695: LIST
64696: LIST
64697: LIST
64698: LIST
64699: LIST
64700: LIST
64701: LIST
64702: LIST
64703: LIST
64704: LIST
64705: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64706: LD_ADDR_VAR 0 19
64710: PUSH
64711: LD_INT 0
64713: PUSH
64714: LD_INT 0
64716: PUSH
64717: EMPTY
64718: LIST
64719: LIST
64720: PUSH
64721: LD_INT 0
64723: PUSH
64724: LD_INT 1
64726: NEG
64727: PUSH
64728: EMPTY
64729: LIST
64730: LIST
64731: PUSH
64732: LD_INT 1
64734: PUSH
64735: LD_INT 0
64737: PUSH
64738: EMPTY
64739: LIST
64740: LIST
64741: PUSH
64742: LD_INT 1
64744: PUSH
64745: LD_INT 1
64747: PUSH
64748: EMPTY
64749: LIST
64750: LIST
64751: PUSH
64752: LD_INT 0
64754: PUSH
64755: LD_INT 1
64757: PUSH
64758: EMPTY
64759: LIST
64760: LIST
64761: PUSH
64762: LD_INT 1
64764: NEG
64765: PUSH
64766: LD_INT 0
64768: PUSH
64769: EMPTY
64770: LIST
64771: LIST
64772: PUSH
64773: LD_INT 1
64775: NEG
64776: PUSH
64777: LD_INT 1
64779: NEG
64780: PUSH
64781: EMPTY
64782: LIST
64783: LIST
64784: PUSH
64785: LD_INT 1
64787: NEG
64788: PUSH
64789: LD_INT 2
64791: NEG
64792: PUSH
64793: EMPTY
64794: LIST
64795: LIST
64796: PUSH
64797: LD_INT 0
64799: PUSH
64800: LD_INT 2
64802: NEG
64803: PUSH
64804: EMPTY
64805: LIST
64806: LIST
64807: PUSH
64808: LD_INT 1
64810: PUSH
64811: LD_INT 1
64813: NEG
64814: PUSH
64815: EMPTY
64816: LIST
64817: LIST
64818: PUSH
64819: LD_INT 2
64821: PUSH
64822: LD_INT 0
64824: PUSH
64825: EMPTY
64826: LIST
64827: LIST
64828: PUSH
64829: LD_INT 2
64831: PUSH
64832: LD_INT 1
64834: PUSH
64835: EMPTY
64836: LIST
64837: LIST
64838: PUSH
64839: LD_INT 2
64841: PUSH
64842: LD_INT 2
64844: PUSH
64845: EMPTY
64846: LIST
64847: LIST
64848: PUSH
64849: LD_INT 1
64851: PUSH
64852: LD_INT 2
64854: PUSH
64855: EMPTY
64856: LIST
64857: LIST
64858: PUSH
64859: LD_INT 0
64861: PUSH
64862: LD_INT 2
64864: PUSH
64865: EMPTY
64866: LIST
64867: LIST
64868: PUSH
64869: LD_INT 1
64871: NEG
64872: PUSH
64873: LD_INT 1
64875: PUSH
64876: EMPTY
64877: LIST
64878: LIST
64879: PUSH
64880: LD_INT 2
64882: NEG
64883: PUSH
64884: LD_INT 0
64886: PUSH
64887: EMPTY
64888: LIST
64889: LIST
64890: PUSH
64891: LD_INT 2
64893: NEG
64894: PUSH
64895: LD_INT 1
64897: NEG
64898: PUSH
64899: EMPTY
64900: LIST
64901: LIST
64902: PUSH
64903: LD_INT 2
64905: NEG
64906: PUSH
64907: LD_INT 2
64909: NEG
64910: PUSH
64911: EMPTY
64912: LIST
64913: LIST
64914: PUSH
64915: EMPTY
64916: LIST
64917: LIST
64918: LIST
64919: LIST
64920: LIST
64921: LIST
64922: LIST
64923: LIST
64924: LIST
64925: LIST
64926: LIST
64927: LIST
64928: LIST
64929: LIST
64930: LIST
64931: LIST
64932: LIST
64933: LIST
64934: LIST
64935: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64936: LD_ADDR_VAR 0 20
64940: PUSH
64941: LD_INT 0
64943: PUSH
64944: LD_INT 0
64946: PUSH
64947: EMPTY
64948: LIST
64949: LIST
64950: PUSH
64951: LD_INT 0
64953: PUSH
64954: LD_INT 1
64956: NEG
64957: PUSH
64958: EMPTY
64959: LIST
64960: LIST
64961: PUSH
64962: LD_INT 1
64964: PUSH
64965: LD_INT 0
64967: PUSH
64968: EMPTY
64969: LIST
64970: LIST
64971: PUSH
64972: LD_INT 1
64974: PUSH
64975: LD_INT 1
64977: PUSH
64978: EMPTY
64979: LIST
64980: LIST
64981: PUSH
64982: LD_INT 0
64984: PUSH
64985: LD_INT 1
64987: PUSH
64988: EMPTY
64989: LIST
64990: LIST
64991: PUSH
64992: LD_INT 1
64994: NEG
64995: PUSH
64996: LD_INT 0
64998: PUSH
64999: EMPTY
65000: LIST
65001: LIST
65002: PUSH
65003: LD_INT 1
65005: NEG
65006: PUSH
65007: LD_INT 1
65009: NEG
65010: PUSH
65011: EMPTY
65012: LIST
65013: LIST
65014: PUSH
65015: LD_INT 1
65017: NEG
65018: PUSH
65019: LD_INT 2
65021: NEG
65022: PUSH
65023: EMPTY
65024: LIST
65025: LIST
65026: PUSH
65027: LD_INT 0
65029: PUSH
65030: LD_INT 2
65032: NEG
65033: PUSH
65034: EMPTY
65035: LIST
65036: LIST
65037: PUSH
65038: LD_INT 1
65040: PUSH
65041: LD_INT 1
65043: NEG
65044: PUSH
65045: EMPTY
65046: LIST
65047: LIST
65048: PUSH
65049: LD_INT 2
65051: PUSH
65052: LD_INT 0
65054: PUSH
65055: EMPTY
65056: LIST
65057: LIST
65058: PUSH
65059: LD_INT 2
65061: PUSH
65062: LD_INT 1
65064: PUSH
65065: EMPTY
65066: LIST
65067: LIST
65068: PUSH
65069: LD_INT 2
65071: PUSH
65072: LD_INT 2
65074: PUSH
65075: EMPTY
65076: LIST
65077: LIST
65078: PUSH
65079: LD_INT 1
65081: PUSH
65082: LD_INT 2
65084: PUSH
65085: EMPTY
65086: LIST
65087: LIST
65088: PUSH
65089: LD_INT 0
65091: PUSH
65092: LD_INT 2
65094: PUSH
65095: EMPTY
65096: LIST
65097: LIST
65098: PUSH
65099: LD_INT 1
65101: NEG
65102: PUSH
65103: LD_INT 1
65105: PUSH
65106: EMPTY
65107: LIST
65108: LIST
65109: PUSH
65110: LD_INT 2
65112: NEG
65113: PUSH
65114: LD_INT 0
65116: PUSH
65117: EMPTY
65118: LIST
65119: LIST
65120: PUSH
65121: LD_INT 2
65123: NEG
65124: PUSH
65125: LD_INT 1
65127: NEG
65128: PUSH
65129: EMPTY
65130: LIST
65131: LIST
65132: PUSH
65133: LD_INT 2
65135: NEG
65136: PUSH
65137: LD_INT 2
65139: NEG
65140: PUSH
65141: EMPTY
65142: LIST
65143: LIST
65144: PUSH
65145: EMPTY
65146: LIST
65147: LIST
65148: LIST
65149: LIST
65150: LIST
65151: LIST
65152: LIST
65153: LIST
65154: LIST
65155: LIST
65156: LIST
65157: LIST
65158: LIST
65159: LIST
65160: LIST
65161: LIST
65162: LIST
65163: LIST
65164: LIST
65165: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65166: LD_ADDR_VAR 0 21
65170: PUSH
65171: LD_INT 0
65173: PUSH
65174: LD_INT 0
65176: PUSH
65177: EMPTY
65178: LIST
65179: LIST
65180: PUSH
65181: LD_INT 0
65183: PUSH
65184: LD_INT 1
65186: NEG
65187: PUSH
65188: EMPTY
65189: LIST
65190: LIST
65191: PUSH
65192: LD_INT 1
65194: PUSH
65195: LD_INT 0
65197: PUSH
65198: EMPTY
65199: LIST
65200: LIST
65201: PUSH
65202: LD_INT 1
65204: PUSH
65205: LD_INT 1
65207: PUSH
65208: EMPTY
65209: LIST
65210: LIST
65211: PUSH
65212: LD_INT 0
65214: PUSH
65215: LD_INT 1
65217: PUSH
65218: EMPTY
65219: LIST
65220: LIST
65221: PUSH
65222: LD_INT 1
65224: NEG
65225: PUSH
65226: LD_INT 0
65228: PUSH
65229: EMPTY
65230: LIST
65231: LIST
65232: PUSH
65233: LD_INT 1
65235: NEG
65236: PUSH
65237: LD_INT 1
65239: NEG
65240: PUSH
65241: EMPTY
65242: LIST
65243: LIST
65244: PUSH
65245: LD_INT 1
65247: NEG
65248: PUSH
65249: LD_INT 2
65251: NEG
65252: PUSH
65253: EMPTY
65254: LIST
65255: LIST
65256: PUSH
65257: LD_INT 0
65259: PUSH
65260: LD_INT 2
65262: NEG
65263: PUSH
65264: EMPTY
65265: LIST
65266: LIST
65267: PUSH
65268: LD_INT 1
65270: PUSH
65271: LD_INT 1
65273: NEG
65274: PUSH
65275: EMPTY
65276: LIST
65277: LIST
65278: PUSH
65279: LD_INT 2
65281: PUSH
65282: LD_INT 0
65284: PUSH
65285: EMPTY
65286: LIST
65287: LIST
65288: PUSH
65289: LD_INT 2
65291: PUSH
65292: LD_INT 1
65294: PUSH
65295: EMPTY
65296: LIST
65297: LIST
65298: PUSH
65299: LD_INT 2
65301: PUSH
65302: LD_INT 2
65304: PUSH
65305: EMPTY
65306: LIST
65307: LIST
65308: PUSH
65309: LD_INT 1
65311: PUSH
65312: LD_INT 2
65314: PUSH
65315: EMPTY
65316: LIST
65317: LIST
65318: PUSH
65319: LD_INT 0
65321: PUSH
65322: LD_INT 2
65324: PUSH
65325: EMPTY
65326: LIST
65327: LIST
65328: PUSH
65329: LD_INT 1
65331: NEG
65332: PUSH
65333: LD_INT 1
65335: PUSH
65336: EMPTY
65337: LIST
65338: LIST
65339: PUSH
65340: LD_INT 2
65342: NEG
65343: PUSH
65344: LD_INT 0
65346: PUSH
65347: EMPTY
65348: LIST
65349: LIST
65350: PUSH
65351: LD_INT 2
65353: NEG
65354: PUSH
65355: LD_INT 1
65357: NEG
65358: PUSH
65359: EMPTY
65360: LIST
65361: LIST
65362: PUSH
65363: LD_INT 2
65365: NEG
65366: PUSH
65367: LD_INT 2
65369: NEG
65370: PUSH
65371: EMPTY
65372: LIST
65373: LIST
65374: PUSH
65375: EMPTY
65376: LIST
65377: LIST
65378: LIST
65379: LIST
65380: LIST
65381: LIST
65382: LIST
65383: LIST
65384: LIST
65385: LIST
65386: LIST
65387: LIST
65388: LIST
65389: LIST
65390: LIST
65391: LIST
65392: LIST
65393: LIST
65394: LIST
65395: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65396: LD_ADDR_VAR 0 22
65400: PUSH
65401: LD_INT 0
65403: PUSH
65404: LD_INT 0
65406: PUSH
65407: EMPTY
65408: LIST
65409: LIST
65410: PUSH
65411: LD_INT 0
65413: PUSH
65414: LD_INT 1
65416: NEG
65417: PUSH
65418: EMPTY
65419: LIST
65420: LIST
65421: PUSH
65422: LD_INT 1
65424: PUSH
65425: LD_INT 0
65427: PUSH
65428: EMPTY
65429: LIST
65430: LIST
65431: PUSH
65432: LD_INT 1
65434: PUSH
65435: LD_INT 1
65437: PUSH
65438: EMPTY
65439: LIST
65440: LIST
65441: PUSH
65442: LD_INT 0
65444: PUSH
65445: LD_INT 1
65447: PUSH
65448: EMPTY
65449: LIST
65450: LIST
65451: PUSH
65452: LD_INT 1
65454: NEG
65455: PUSH
65456: LD_INT 0
65458: PUSH
65459: EMPTY
65460: LIST
65461: LIST
65462: PUSH
65463: LD_INT 1
65465: NEG
65466: PUSH
65467: LD_INT 1
65469: NEG
65470: PUSH
65471: EMPTY
65472: LIST
65473: LIST
65474: PUSH
65475: LD_INT 1
65477: NEG
65478: PUSH
65479: LD_INT 2
65481: NEG
65482: PUSH
65483: EMPTY
65484: LIST
65485: LIST
65486: PUSH
65487: LD_INT 0
65489: PUSH
65490: LD_INT 2
65492: NEG
65493: PUSH
65494: EMPTY
65495: LIST
65496: LIST
65497: PUSH
65498: LD_INT 1
65500: PUSH
65501: LD_INT 1
65503: NEG
65504: PUSH
65505: EMPTY
65506: LIST
65507: LIST
65508: PUSH
65509: LD_INT 2
65511: PUSH
65512: LD_INT 0
65514: PUSH
65515: EMPTY
65516: LIST
65517: LIST
65518: PUSH
65519: LD_INT 2
65521: PUSH
65522: LD_INT 1
65524: PUSH
65525: EMPTY
65526: LIST
65527: LIST
65528: PUSH
65529: LD_INT 2
65531: PUSH
65532: LD_INT 2
65534: PUSH
65535: EMPTY
65536: LIST
65537: LIST
65538: PUSH
65539: LD_INT 1
65541: PUSH
65542: LD_INT 2
65544: PUSH
65545: EMPTY
65546: LIST
65547: LIST
65548: PUSH
65549: LD_INT 0
65551: PUSH
65552: LD_INT 2
65554: PUSH
65555: EMPTY
65556: LIST
65557: LIST
65558: PUSH
65559: LD_INT 1
65561: NEG
65562: PUSH
65563: LD_INT 1
65565: PUSH
65566: EMPTY
65567: LIST
65568: LIST
65569: PUSH
65570: LD_INT 2
65572: NEG
65573: PUSH
65574: LD_INT 0
65576: PUSH
65577: EMPTY
65578: LIST
65579: LIST
65580: PUSH
65581: LD_INT 2
65583: NEG
65584: PUSH
65585: LD_INT 1
65587: NEG
65588: PUSH
65589: EMPTY
65590: LIST
65591: LIST
65592: PUSH
65593: LD_INT 2
65595: NEG
65596: PUSH
65597: LD_INT 2
65599: NEG
65600: PUSH
65601: EMPTY
65602: LIST
65603: LIST
65604: PUSH
65605: EMPTY
65606: LIST
65607: LIST
65608: LIST
65609: LIST
65610: LIST
65611: LIST
65612: LIST
65613: LIST
65614: LIST
65615: LIST
65616: LIST
65617: LIST
65618: LIST
65619: LIST
65620: LIST
65621: LIST
65622: LIST
65623: LIST
65624: LIST
65625: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
65626: LD_ADDR_VAR 0 23
65630: PUSH
65631: LD_INT 0
65633: PUSH
65634: LD_INT 0
65636: PUSH
65637: EMPTY
65638: LIST
65639: LIST
65640: PUSH
65641: LD_INT 0
65643: PUSH
65644: LD_INT 1
65646: NEG
65647: PUSH
65648: EMPTY
65649: LIST
65650: LIST
65651: PUSH
65652: LD_INT 1
65654: PUSH
65655: LD_INT 0
65657: PUSH
65658: EMPTY
65659: LIST
65660: LIST
65661: PUSH
65662: LD_INT 1
65664: PUSH
65665: LD_INT 1
65667: PUSH
65668: EMPTY
65669: LIST
65670: LIST
65671: PUSH
65672: LD_INT 0
65674: PUSH
65675: LD_INT 1
65677: PUSH
65678: EMPTY
65679: LIST
65680: LIST
65681: PUSH
65682: LD_INT 1
65684: NEG
65685: PUSH
65686: LD_INT 0
65688: PUSH
65689: EMPTY
65690: LIST
65691: LIST
65692: PUSH
65693: LD_INT 1
65695: NEG
65696: PUSH
65697: LD_INT 1
65699: NEG
65700: PUSH
65701: EMPTY
65702: LIST
65703: LIST
65704: PUSH
65705: LD_INT 1
65707: NEG
65708: PUSH
65709: LD_INT 2
65711: NEG
65712: PUSH
65713: EMPTY
65714: LIST
65715: LIST
65716: PUSH
65717: LD_INT 0
65719: PUSH
65720: LD_INT 2
65722: NEG
65723: PUSH
65724: EMPTY
65725: LIST
65726: LIST
65727: PUSH
65728: LD_INT 1
65730: PUSH
65731: LD_INT 1
65733: NEG
65734: PUSH
65735: EMPTY
65736: LIST
65737: LIST
65738: PUSH
65739: LD_INT 2
65741: PUSH
65742: LD_INT 0
65744: PUSH
65745: EMPTY
65746: LIST
65747: LIST
65748: PUSH
65749: LD_INT 2
65751: PUSH
65752: LD_INT 1
65754: PUSH
65755: EMPTY
65756: LIST
65757: LIST
65758: PUSH
65759: LD_INT 2
65761: PUSH
65762: LD_INT 2
65764: PUSH
65765: EMPTY
65766: LIST
65767: LIST
65768: PUSH
65769: LD_INT 1
65771: PUSH
65772: LD_INT 2
65774: PUSH
65775: EMPTY
65776: LIST
65777: LIST
65778: PUSH
65779: LD_INT 0
65781: PUSH
65782: LD_INT 2
65784: PUSH
65785: EMPTY
65786: LIST
65787: LIST
65788: PUSH
65789: LD_INT 1
65791: NEG
65792: PUSH
65793: LD_INT 1
65795: PUSH
65796: EMPTY
65797: LIST
65798: LIST
65799: PUSH
65800: LD_INT 2
65802: NEG
65803: PUSH
65804: LD_INT 0
65806: PUSH
65807: EMPTY
65808: LIST
65809: LIST
65810: PUSH
65811: LD_INT 2
65813: NEG
65814: PUSH
65815: LD_INT 1
65817: NEG
65818: PUSH
65819: EMPTY
65820: LIST
65821: LIST
65822: PUSH
65823: LD_INT 2
65825: NEG
65826: PUSH
65827: LD_INT 2
65829: NEG
65830: PUSH
65831: EMPTY
65832: LIST
65833: LIST
65834: PUSH
65835: LD_INT 2
65837: NEG
65838: PUSH
65839: LD_INT 3
65841: NEG
65842: PUSH
65843: EMPTY
65844: LIST
65845: LIST
65846: PUSH
65847: LD_INT 1
65849: NEG
65850: PUSH
65851: LD_INT 3
65853: NEG
65854: PUSH
65855: EMPTY
65856: LIST
65857: LIST
65858: PUSH
65859: LD_INT 1
65861: PUSH
65862: LD_INT 2
65864: NEG
65865: PUSH
65866: EMPTY
65867: LIST
65868: LIST
65869: PUSH
65870: LD_INT 2
65872: PUSH
65873: LD_INT 1
65875: NEG
65876: PUSH
65877: EMPTY
65878: LIST
65879: LIST
65880: PUSH
65881: EMPTY
65882: LIST
65883: LIST
65884: LIST
65885: LIST
65886: LIST
65887: LIST
65888: LIST
65889: LIST
65890: LIST
65891: LIST
65892: LIST
65893: LIST
65894: LIST
65895: LIST
65896: LIST
65897: LIST
65898: LIST
65899: LIST
65900: LIST
65901: LIST
65902: LIST
65903: LIST
65904: LIST
65905: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
65906: LD_ADDR_VAR 0 24
65910: PUSH
65911: LD_INT 0
65913: PUSH
65914: LD_INT 0
65916: PUSH
65917: EMPTY
65918: LIST
65919: LIST
65920: PUSH
65921: LD_INT 0
65923: PUSH
65924: LD_INT 1
65926: NEG
65927: PUSH
65928: EMPTY
65929: LIST
65930: LIST
65931: PUSH
65932: LD_INT 1
65934: PUSH
65935: LD_INT 0
65937: PUSH
65938: EMPTY
65939: LIST
65940: LIST
65941: PUSH
65942: LD_INT 1
65944: PUSH
65945: LD_INT 1
65947: PUSH
65948: EMPTY
65949: LIST
65950: LIST
65951: PUSH
65952: LD_INT 0
65954: PUSH
65955: LD_INT 1
65957: PUSH
65958: EMPTY
65959: LIST
65960: LIST
65961: PUSH
65962: LD_INT 1
65964: NEG
65965: PUSH
65966: LD_INT 0
65968: PUSH
65969: EMPTY
65970: LIST
65971: LIST
65972: PUSH
65973: LD_INT 1
65975: NEG
65976: PUSH
65977: LD_INT 1
65979: NEG
65980: PUSH
65981: EMPTY
65982: LIST
65983: LIST
65984: PUSH
65985: LD_INT 1
65987: NEG
65988: PUSH
65989: LD_INT 2
65991: NEG
65992: PUSH
65993: EMPTY
65994: LIST
65995: LIST
65996: PUSH
65997: LD_INT 0
65999: PUSH
66000: LD_INT 2
66002: NEG
66003: PUSH
66004: EMPTY
66005: LIST
66006: LIST
66007: PUSH
66008: LD_INT 1
66010: PUSH
66011: LD_INT 1
66013: NEG
66014: PUSH
66015: EMPTY
66016: LIST
66017: LIST
66018: PUSH
66019: LD_INT 2
66021: PUSH
66022: LD_INT 0
66024: PUSH
66025: EMPTY
66026: LIST
66027: LIST
66028: PUSH
66029: LD_INT 2
66031: PUSH
66032: LD_INT 1
66034: PUSH
66035: EMPTY
66036: LIST
66037: LIST
66038: PUSH
66039: LD_INT 2
66041: PUSH
66042: LD_INT 2
66044: PUSH
66045: EMPTY
66046: LIST
66047: LIST
66048: PUSH
66049: LD_INT 1
66051: PUSH
66052: LD_INT 2
66054: PUSH
66055: EMPTY
66056: LIST
66057: LIST
66058: PUSH
66059: LD_INT 0
66061: PUSH
66062: LD_INT 2
66064: PUSH
66065: EMPTY
66066: LIST
66067: LIST
66068: PUSH
66069: LD_INT 1
66071: NEG
66072: PUSH
66073: LD_INT 1
66075: PUSH
66076: EMPTY
66077: LIST
66078: LIST
66079: PUSH
66080: LD_INT 2
66082: NEG
66083: PUSH
66084: LD_INT 0
66086: PUSH
66087: EMPTY
66088: LIST
66089: LIST
66090: PUSH
66091: LD_INT 2
66093: NEG
66094: PUSH
66095: LD_INT 1
66097: NEG
66098: PUSH
66099: EMPTY
66100: LIST
66101: LIST
66102: PUSH
66103: LD_INT 2
66105: NEG
66106: PUSH
66107: LD_INT 2
66109: NEG
66110: PUSH
66111: EMPTY
66112: LIST
66113: LIST
66114: PUSH
66115: LD_INT 1
66117: PUSH
66118: LD_INT 2
66120: NEG
66121: PUSH
66122: EMPTY
66123: LIST
66124: LIST
66125: PUSH
66126: LD_INT 2
66128: PUSH
66129: LD_INT 1
66131: NEG
66132: PUSH
66133: EMPTY
66134: LIST
66135: LIST
66136: PUSH
66137: LD_INT 3
66139: PUSH
66140: LD_INT 1
66142: PUSH
66143: EMPTY
66144: LIST
66145: LIST
66146: PUSH
66147: LD_INT 3
66149: PUSH
66150: LD_INT 2
66152: PUSH
66153: EMPTY
66154: LIST
66155: LIST
66156: PUSH
66157: EMPTY
66158: LIST
66159: LIST
66160: LIST
66161: LIST
66162: LIST
66163: LIST
66164: LIST
66165: LIST
66166: LIST
66167: LIST
66168: LIST
66169: LIST
66170: LIST
66171: LIST
66172: LIST
66173: LIST
66174: LIST
66175: LIST
66176: LIST
66177: LIST
66178: LIST
66179: LIST
66180: LIST
66181: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
66182: LD_ADDR_VAR 0 25
66186: PUSH
66187: LD_INT 0
66189: PUSH
66190: LD_INT 0
66192: PUSH
66193: EMPTY
66194: LIST
66195: LIST
66196: PUSH
66197: LD_INT 0
66199: PUSH
66200: LD_INT 1
66202: NEG
66203: PUSH
66204: EMPTY
66205: LIST
66206: LIST
66207: PUSH
66208: LD_INT 1
66210: PUSH
66211: LD_INT 0
66213: PUSH
66214: EMPTY
66215: LIST
66216: LIST
66217: PUSH
66218: LD_INT 1
66220: PUSH
66221: LD_INT 1
66223: PUSH
66224: EMPTY
66225: LIST
66226: LIST
66227: PUSH
66228: LD_INT 0
66230: PUSH
66231: LD_INT 1
66233: PUSH
66234: EMPTY
66235: LIST
66236: LIST
66237: PUSH
66238: LD_INT 1
66240: NEG
66241: PUSH
66242: LD_INT 0
66244: PUSH
66245: EMPTY
66246: LIST
66247: LIST
66248: PUSH
66249: LD_INT 1
66251: NEG
66252: PUSH
66253: LD_INT 1
66255: NEG
66256: PUSH
66257: EMPTY
66258: LIST
66259: LIST
66260: PUSH
66261: LD_INT 1
66263: NEG
66264: PUSH
66265: LD_INT 2
66267: NEG
66268: PUSH
66269: EMPTY
66270: LIST
66271: LIST
66272: PUSH
66273: LD_INT 0
66275: PUSH
66276: LD_INT 2
66278: NEG
66279: PUSH
66280: EMPTY
66281: LIST
66282: LIST
66283: PUSH
66284: LD_INT 1
66286: PUSH
66287: LD_INT 1
66289: NEG
66290: PUSH
66291: EMPTY
66292: LIST
66293: LIST
66294: PUSH
66295: LD_INT 2
66297: PUSH
66298: LD_INT 0
66300: PUSH
66301: EMPTY
66302: LIST
66303: LIST
66304: PUSH
66305: LD_INT 2
66307: PUSH
66308: LD_INT 1
66310: PUSH
66311: EMPTY
66312: LIST
66313: LIST
66314: PUSH
66315: LD_INT 2
66317: PUSH
66318: LD_INT 2
66320: PUSH
66321: EMPTY
66322: LIST
66323: LIST
66324: PUSH
66325: LD_INT 1
66327: PUSH
66328: LD_INT 2
66330: PUSH
66331: EMPTY
66332: LIST
66333: LIST
66334: PUSH
66335: LD_INT 0
66337: PUSH
66338: LD_INT 2
66340: PUSH
66341: EMPTY
66342: LIST
66343: LIST
66344: PUSH
66345: LD_INT 1
66347: NEG
66348: PUSH
66349: LD_INT 1
66351: PUSH
66352: EMPTY
66353: LIST
66354: LIST
66355: PUSH
66356: LD_INT 2
66358: NEG
66359: PUSH
66360: LD_INT 0
66362: PUSH
66363: EMPTY
66364: LIST
66365: LIST
66366: PUSH
66367: LD_INT 2
66369: NEG
66370: PUSH
66371: LD_INT 1
66373: NEG
66374: PUSH
66375: EMPTY
66376: LIST
66377: LIST
66378: PUSH
66379: LD_INT 2
66381: NEG
66382: PUSH
66383: LD_INT 2
66385: NEG
66386: PUSH
66387: EMPTY
66388: LIST
66389: LIST
66390: PUSH
66391: LD_INT 3
66393: PUSH
66394: LD_INT 1
66396: PUSH
66397: EMPTY
66398: LIST
66399: LIST
66400: PUSH
66401: LD_INT 3
66403: PUSH
66404: LD_INT 2
66406: PUSH
66407: EMPTY
66408: LIST
66409: LIST
66410: PUSH
66411: LD_INT 2
66413: PUSH
66414: LD_INT 3
66416: PUSH
66417: EMPTY
66418: LIST
66419: LIST
66420: PUSH
66421: LD_INT 1
66423: PUSH
66424: LD_INT 3
66426: PUSH
66427: EMPTY
66428: LIST
66429: LIST
66430: PUSH
66431: EMPTY
66432: LIST
66433: LIST
66434: LIST
66435: LIST
66436: LIST
66437: LIST
66438: LIST
66439: LIST
66440: LIST
66441: LIST
66442: LIST
66443: LIST
66444: LIST
66445: LIST
66446: LIST
66447: LIST
66448: LIST
66449: LIST
66450: LIST
66451: LIST
66452: LIST
66453: LIST
66454: LIST
66455: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
66456: LD_ADDR_VAR 0 26
66460: PUSH
66461: LD_INT 0
66463: PUSH
66464: LD_INT 0
66466: PUSH
66467: EMPTY
66468: LIST
66469: LIST
66470: PUSH
66471: LD_INT 0
66473: PUSH
66474: LD_INT 1
66476: NEG
66477: PUSH
66478: EMPTY
66479: LIST
66480: LIST
66481: PUSH
66482: LD_INT 1
66484: PUSH
66485: LD_INT 0
66487: PUSH
66488: EMPTY
66489: LIST
66490: LIST
66491: PUSH
66492: LD_INT 1
66494: PUSH
66495: LD_INT 1
66497: PUSH
66498: EMPTY
66499: LIST
66500: LIST
66501: PUSH
66502: LD_INT 0
66504: PUSH
66505: LD_INT 1
66507: PUSH
66508: EMPTY
66509: LIST
66510: LIST
66511: PUSH
66512: LD_INT 1
66514: NEG
66515: PUSH
66516: LD_INT 0
66518: PUSH
66519: EMPTY
66520: LIST
66521: LIST
66522: PUSH
66523: LD_INT 1
66525: NEG
66526: PUSH
66527: LD_INT 1
66529: NEG
66530: PUSH
66531: EMPTY
66532: LIST
66533: LIST
66534: PUSH
66535: LD_INT 1
66537: NEG
66538: PUSH
66539: LD_INT 2
66541: NEG
66542: PUSH
66543: EMPTY
66544: LIST
66545: LIST
66546: PUSH
66547: LD_INT 0
66549: PUSH
66550: LD_INT 2
66552: NEG
66553: PUSH
66554: EMPTY
66555: LIST
66556: LIST
66557: PUSH
66558: LD_INT 1
66560: PUSH
66561: LD_INT 1
66563: NEG
66564: PUSH
66565: EMPTY
66566: LIST
66567: LIST
66568: PUSH
66569: LD_INT 2
66571: PUSH
66572: LD_INT 0
66574: PUSH
66575: EMPTY
66576: LIST
66577: LIST
66578: PUSH
66579: LD_INT 2
66581: PUSH
66582: LD_INT 1
66584: PUSH
66585: EMPTY
66586: LIST
66587: LIST
66588: PUSH
66589: LD_INT 2
66591: PUSH
66592: LD_INT 2
66594: PUSH
66595: EMPTY
66596: LIST
66597: LIST
66598: PUSH
66599: LD_INT 1
66601: PUSH
66602: LD_INT 2
66604: PUSH
66605: EMPTY
66606: LIST
66607: LIST
66608: PUSH
66609: LD_INT 0
66611: PUSH
66612: LD_INT 2
66614: PUSH
66615: EMPTY
66616: LIST
66617: LIST
66618: PUSH
66619: LD_INT 1
66621: NEG
66622: PUSH
66623: LD_INT 1
66625: PUSH
66626: EMPTY
66627: LIST
66628: LIST
66629: PUSH
66630: LD_INT 2
66632: NEG
66633: PUSH
66634: LD_INT 0
66636: PUSH
66637: EMPTY
66638: LIST
66639: LIST
66640: PUSH
66641: LD_INT 2
66643: NEG
66644: PUSH
66645: LD_INT 1
66647: NEG
66648: PUSH
66649: EMPTY
66650: LIST
66651: LIST
66652: PUSH
66653: LD_INT 2
66655: NEG
66656: PUSH
66657: LD_INT 2
66659: NEG
66660: PUSH
66661: EMPTY
66662: LIST
66663: LIST
66664: PUSH
66665: LD_INT 2
66667: PUSH
66668: LD_INT 3
66670: PUSH
66671: EMPTY
66672: LIST
66673: LIST
66674: PUSH
66675: LD_INT 1
66677: PUSH
66678: LD_INT 3
66680: PUSH
66681: EMPTY
66682: LIST
66683: LIST
66684: PUSH
66685: LD_INT 1
66687: NEG
66688: PUSH
66689: LD_INT 2
66691: PUSH
66692: EMPTY
66693: LIST
66694: LIST
66695: PUSH
66696: LD_INT 2
66698: NEG
66699: PUSH
66700: LD_INT 1
66702: PUSH
66703: EMPTY
66704: LIST
66705: LIST
66706: PUSH
66707: EMPTY
66708: LIST
66709: LIST
66710: LIST
66711: LIST
66712: LIST
66713: LIST
66714: LIST
66715: LIST
66716: LIST
66717: LIST
66718: LIST
66719: LIST
66720: LIST
66721: LIST
66722: LIST
66723: LIST
66724: LIST
66725: LIST
66726: LIST
66727: LIST
66728: LIST
66729: LIST
66730: LIST
66731: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
66732: LD_ADDR_VAR 0 27
66736: PUSH
66737: LD_INT 0
66739: PUSH
66740: LD_INT 0
66742: PUSH
66743: EMPTY
66744: LIST
66745: LIST
66746: PUSH
66747: LD_INT 0
66749: PUSH
66750: LD_INT 1
66752: NEG
66753: PUSH
66754: EMPTY
66755: LIST
66756: LIST
66757: PUSH
66758: LD_INT 1
66760: PUSH
66761: LD_INT 0
66763: PUSH
66764: EMPTY
66765: LIST
66766: LIST
66767: PUSH
66768: LD_INT 1
66770: PUSH
66771: LD_INT 1
66773: PUSH
66774: EMPTY
66775: LIST
66776: LIST
66777: PUSH
66778: LD_INT 0
66780: PUSH
66781: LD_INT 1
66783: PUSH
66784: EMPTY
66785: LIST
66786: LIST
66787: PUSH
66788: LD_INT 1
66790: NEG
66791: PUSH
66792: LD_INT 0
66794: PUSH
66795: EMPTY
66796: LIST
66797: LIST
66798: PUSH
66799: LD_INT 1
66801: NEG
66802: PUSH
66803: LD_INT 1
66805: NEG
66806: PUSH
66807: EMPTY
66808: LIST
66809: LIST
66810: PUSH
66811: LD_INT 1
66813: NEG
66814: PUSH
66815: LD_INT 2
66817: NEG
66818: PUSH
66819: EMPTY
66820: LIST
66821: LIST
66822: PUSH
66823: LD_INT 0
66825: PUSH
66826: LD_INT 2
66828: NEG
66829: PUSH
66830: EMPTY
66831: LIST
66832: LIST
66833: PUSH
66834: LD_INT 1
66836: PUSH
66837: LD_INT 1
66839: NEG
66840: PUSH
66841: EMPTY
66842: LIST
66843: LIST
66844: PUSH
66845: LD_INT 2
66847: PUSH
66848: LD_INT 0
66850: PUSH
66851: EMPTY
66852: LIST
66853: LIST
66854: PUSH
66855: LD_INT 2
66857: PUSH
66858: LD_INT 1
66860: PUSH
66861: EMPTY
66862: LIST
66863: LIST
66864: PUSH
66865: LD_INT 2
66867: PUSH
66868: LD_INT 2
66870: PUSH
66871: EMPTY
66872: LIST
66873: LIST
66874: PUSH
66875: LD_INT 1
66877: PUSH
66878: LD_INT 2
66880: PUSH
66881: EMPTY
66882: LIST
66883: LIST
66884: PUSH
66885: LD_INT 0
66887: PUSH
66888: LD_INT 2
66890: PUSH
66891: EMPTY
66892: LIST
66893: LIST
66894: PUSH
66895: LD_INT 1
66897: NEG
66898: PUSH
66899: LD_INT 1
66901: PUSH
66902: EMPTY
66903: LIST
66904: LIST
66905: PUSH
66906: LD_INT 2
66908: NEG
66909: PUSH
66910: LD_INT 0
66912: PUSH
66913: EMPTY
66914: LIST
66915: LIST
66916: PUSH
66917: LD_INT 2
66919: NEG
66920: PUSH
66921: LD_INT 1
66923: NEG
66924: PUSH
66925: EMPTY
66926: LIST
66927: LIST
66928: PUSH
66929: LD_INT 2
66931: NEG
66932: PUSH
66933: LD_INT 2
66935: NEG
66936: PUSH
66937: EMPTY
66938: LIST
66939: LIST
66940: PUSH
66941: LD_INT 1
66943: NEG
66944: PUSH
66945: LD_INT 2
66947: PUSH
66948: EMPTY
66949: LIST
66950: LIST
66951: PUSH
66952: LD_INT 2
66954: NEG
66955: PUSH
66956: LD_INT 1
66958: PUSH
66959: EMPTY
66960: LIST
66961: LIST
66962: PUSH
66963: LD_INT 3
66965: NEG
66966: PUSH
66967: LD_INT 1
66969: NEG
66970: PUSH
66971: EMPTY
66972: LIST
66973: LIST
66974: PUSH
66975: LD_INT 3
66977: NEG
66978: PUSH
66979: LD_INT 2
66981: NEG
66982: PUSH
66983: EMPTY
66984: LIST
66985: LIST
66986: PUSH
66987: EMPTY
66988: LIST
66989: LIST
66990: LIST
66991: LIST
66992: LIST
66993: LIST
66994: LIST
66995: LIST
66996: LIST
66997: LIST
66998: LIST
66999: LIST
67000: LIST
67001: LIST
67002: LIST
67003: LIST
67004: LIST
67005: LIST
67006: LIST
67007: LIST
67008: LIST
67009: LIST
67010: LIST
67011: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
67012: LD_ADDR_VAR 0 28
67016: PUSH
67017: LD_INT 0
67019: PUSH
67020: LD_INT 0
67022: PUSH
67023: EMPTY
67024: LIST
67025: LIST
67026: PUSH
67027: LD_INT 0
67029: PUSH
67030: LD_INT 1
67032: NEG
67033: PUSH
67034: EMPTY
67035: LIST
67036: LIST
67037: PUSH
67038: LD_INT 1
67040: PUSH
67041: LD_INT 0
67043: PUSH
67044: EMPTY
67045: LIST
67046: LIST
67047: PUSH
67048: LD_INT 1
67050: PUSH
67051: LD_INT 1
67053: PUSH
67054: EMPTY
67055: LIST
67056: LIST
67057: PUSH
67058: LD_INT 0
67060: PUSH
67061: LD_INT 1
67063: PUSH
67064: EMPTY
67065: LIST
67066: LIST
67067: PUSH
67068: LD_INT 1
67070: NEG
67071: PUSH
67072: LD_INT 0
67074: PUSH
67075: EMPTY
67076: LIST
67077: LIST
67078: PUSH
67079: LD_INT 1
67081: NEG
67082: PUSH
67083: LD_INT 1
67085: NEG
67086: PUSH
67087: EMPTY
67088: LIST
67089: LIST
67090: PUSH
67091: LD_INT 1
67093: NEG
67094: PUSH
67095: LD_INT 2
67097: NEG
67098: PUSH
67099: EMPTY
67100: LIST
67101: LIST
67102: PUSH
67103: LD_INT 0
67105: PUSH
67106: LD_INT 2
67108: NEG
67109: PUSH
67110: EMPTY
67111: LIST
67112: LIST
67113: PUSH
67114: LD_INT 1
67116: PUSH
67117: LD_INT 1
67119: NEG
67120: PUSH
67121: EMPTY
67122: LIST
67123: LIST
67124: PUSH
67125: LD_INT 2
67127: PUSH
67128: LD_INT 0
67130: PUSH
67131: EMPTY
67132: LIST
67133: LIST
67134: PUSH
67135: LD_INT 2
67137: PUSH
67138: LD_INT 1
67140: PUSH
67141: EMPTY
67142: LIST
67143: LIST
67144: PUSH
67145: LD_INT 2
67147: PUSH
67148: LD_INT 2
67150: PUSH
67151: EMPTY
67152: LIST
67153: LIST
67154: PUSH
67155: LD_INT 1
67157: PUSH
67158: LD_INT 2
67160: PUSH
67161: EMPTY
67162: LIST
67163: LIST
67164: PUSH
67165: LD_INT 0
67167: PUSH
67168: LD_INT 2
67170: PUSH
67171: EMPTY
67172: LIST
67173: LIST
67174: PUSH
67175: LD_INT 1
67177: NEG
67178: PUSH
67179: LD_INT 1
67181: PUSH
67182: EMPTY
67183: LIST
67184: LIST
67185: PUSH
67186: LD_INT 2
67188: NEG
67189: PUSH
67190: LD_INT 0
67192: PUSH
67193: EMPTY
67194: LIST
67195: LIST
67196: PUSH
67197: LD_INT 2
67199: NEG
67200: PUSH
67201: LD_INT 1
67203: NEG
67204: PUSH
67205: EMPTY
67206: LIST
67207: LIST
67208: PUSH
67209: LD_INT 2
67211: NEG
67212: PUSH
67213: LD_INT 2
67215: NEG
67216: PUSH
67217: EMPTY
67218: LIST
67219: LIST
67220: PUSH
67221: LD_INT 2
67223: NEG
67224: PUSH
67225: LD_INT 3
67227: NEG
67228: PUSH
67229: EMPTY
67230: LIST
67231: LIST
67232: PUSH
67233: LD_INT 1
67235: NEG
67236: PUSH
67237: LD_INT 3
67239: NEG
67240: PUSH
67241: EMPTY
67242: LIST
67243: LIST
67244: PUSH
67245: LD_INT 3
67247: NEG
67248: PUSH
67249: LD_INT 1
67251: NEG
67252: PUSH
67253: EMPTY
67254: LIST
67255: LIST
67256: PUSH
67257: LD_INT 3
67259: NEG
67260: PUSH
67261: LD_INT 2
67263: NEG
67264: PUSH
67265: EMPTY
67266: LIST
67267: LIST
67268: PUSH
67269: EMPTY
67270: LIST
67271: LIST
67272: LIST
67273: LIST
67274: LIST
67275: LIST
67276: LIST
67277: LIST
67278: LIST
67279: LIST
67280: LIST
67281: LIST
67282: LIST
67283: LIST
67284: LIST
67285: LIST
67286: LIST
67287: LIST
67288: LIST
67289: LIST
67290: LIST
67291: LIST
67292: LIST
67293: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
67294: LD_ADDR_VAR 0 29
67298: PUSH
67299: LD_INT 0
67301: PUSH
67302: LD_INT 0
67304: PUSH
67305: EMPTY
67306: LIST
67307: LIST
67308: PUSH
67309: LD_INT 0
67311: PUSH
67312: LD_INT 1
67314: NEG
67315: PUSH
67316: EMPTY
67317: LIST
67318: LIST
67319: PUSH
67320: LD_INT 1
67322: PUSH
67323: LD_INT 0
67325: PUSH
67326: EMPTY
67327: LIST
67328: LIST
67329: PUSH
67330: LD_INT 1
67332: PUSH
67333: LD_INT 1
67335: PUSH
67336: EMPTY
67337: LIST
67338: LIST
67339: PUSH
67340: LD_INT 0
67342: PUSH
67343: LD_INT 1
67345: PUSH
67346: EMPTY
67347: LIST
67348: LIST
67349: PUSH
67350: LD_INT 1
67352: NEG
67353: PUSH
67354: LD_INT 0
67356: PUSH
67357: EMPTY
67358: LIST
67359: LIST
67360: PUSH
67361: LD_INT 1
67363: NEG
67364: PUSH
67365: LD_INT 1
67367: NEG
67368: PUSH
67369: EMPTY
67370: LIST
67371: LIST
67372: PUSH
67373: LD_INT 1
67375: NEG
67376: PUSH
67377: LD_INT 2
67379: NEG
67380: PUSH
67381: EMPTY
67382: LIST
67383: LIST
67384: PUSH
67385: LD_INT 0
67387: PUSH
67388: LD_INT 2
67390: NEG
67391: PUSH
67392: EMPTY
67393: LIST
67394: LIST
67395: PUSH
67396: LD_INT 1
67398: PUSH
67399: LD_INT 1
67401: NEG
67402: PUSH
67403: EMPTY
67404: LIST
67405: LIST
67406: PUSH
67407: LD_INT 2
67409: PUSH
67410: LD_INT 0
67412: PUSH
67413: EMPTY
67414: LIST
67415: LIST
67416: PUSH
67417: LD_INT 2
67419: PUSH
67420: LD_INT 1
67422: PUSH
67423: EMPTY
67424: LIST
67425: LIST
67426: PUSH
67427: LD_INT 1
67429: PUSH
67430: LD_INT 2
67432: PUSH
67433: EMPTY
67434: LIST
67435: LIST
67436: PUSH
67437: LD_INT 0
67439: PUSH
67440: LD_INT 2
67442: PUSH
67443: EMPTY
67444: LIST
67445: LIST
67446: PUSH
67447: LD_INT 1
67449: NEG
67450: PUSH
67451: LD_INT 1
67453: PUSH
67454: EMPTY
67455: LIST
67456: LIST
67457: PUSH
67458: LD_INT 2
67460: NEG
67461: PUSH
67462: LD_INT 1
67464: NEG
67465: PUSH
67466: EMPTY
67467: LIST
67468: LIST
67469: PUSH
67470: LD_INT 2
67472: NEG
67473: PUSH
67474: LD_INT 2
67476: NEG
67477: PUSH
67478: EMPTY
67479: LIST
67480: LIST
67481: PUSH
67482: LD_INT 2
67484: NEG
67485: PUSH
67486: LD_INT 3
67488: NEG
67489: PUSH
67490: EMPTY
67491: LIST
67492: LIST
67493: PUSH
67494: LD_INT 2
67496: PUSH
67497: LD_INT 1
67499: NEG
67500: PUSH
67501: EMPTY
67502: LIST
67503: LIST
67504: PUSH
67505: LD_INT 3
67507: PUSH
67508: LD_INT 1
67510: PUSH
67511: EMPTY
67512: LIST
67513: LIST
67514: PUSH
67515: LD_INT 1
67517: PUSH
67518: LD_INT 3
67520: PUSH
67521: EMPTY
67522: LIST
67523: LIST
67524: PUSH
67525: LD_INT 1
67527: NEG
67528: PUSH
67529: LD_INT 2
67531: PUSH
67532: EMPTY
67533: LIST
67534: LIST
67535: PUSH
67536: LD_INT 3
67538: NEG
67539: PUSH
67540: LD_INT 2
67542: NEG
67543: PUSH
67544: EMPTY
67545: LIST
67546: LIST
67547: PUSH
67548: EMPTY
67549: LIST
67550: LIST
67551: LIST
67552: LIST
67553: LIST
67554: LIST
67555: LIST
67556: LIST
67557: LIST
67558: LIST
67559: LIST
67560: LIST
67561: LIST
67562: LIST
67563: LIST
67564: LIST
67565: LIST
67566: LIST
67567: LIST
67568: LIST
67569: LIST
67570: LIST
67571: LIST
67572: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
67573: LD_ADDR_VAR 0 30
67577: PUSH
67578: LD_INT 0
67580: PUSH
67581: LD_INT 0
67583: PUSH
67584: EMPTY
67585: LIST
67586: LIST
67587: PUSH
67588: LD_INT 0
67590: PUSH
67591: LD_INT 1
67593: NEG
67594: PUSH
67595: EMPTY
67596: LIST
67597: LIST
67598: PUSH
67599: LD_INT 1
67601: PUSH
67602: LD_INT 0
67604: PUSH
67605: EMPTY
67606: LIST
67607: LIST
67608: PUSH
67609: LD_INT 1
67611: PUSH
67612: LD_INT 1
67614: PUSH
67615: EMPTY
67616: LIST
67617: LIST
67618: PUSH
67619: LD_INT 0
67621: PUSH
67622: LD_INT 1
67624: PUSH
67625: EMPTY
67626: LIST
67627: LIST
67628: PUSH
67629: LD_INT 1
67631: NEG
67632: PUSH
67633: LD_INT 0
67635: PUSH
67636: EMPTY
67637: LIST
67638: LIST
67639: PUSH
67640: LD_INT 1
67642: NEG
67643: PUSH
67644: LD_INT 1
67646: NEG
67647: PUSH
67648: EMPTY
67649: LIST
67650: LIST
67651: PUSH
67652: LD_INT 1
67654: NEG
67655: PUSH
67656: LD_INT 2
67658: NEG
67659: PUSH
67660: EMPTY
67661: LIST
67662: LIST
67663: PUSH
67664: LD_INT 0
67666: PUSH
67667: LD_INT 2
67669: NEG
67670: PUSH
67671: EMPTY
67672: LIST
67673: LIST
67674: PUSH
67675: LD_INT 1
67677: PUSH
67678: LD_INT 1
67680: NEG
67681: PUSH
67682: EMPTY
67683: LIST
67684: LIST
67685: PUSH
67686: LD_INT 2
67688: PUSH
67689: LD_INT 0
67691: PUSH
67692: EMPTY
67693: LIST
67694: LIST
67695: PUSH
67696: LD_INT 2
67698: PUSH
67699: LD_INT 1
67701: PUSH
67702: EMPTY
67703: LIST
67704: LIST
67705: PUSH
67706: LD_INT 2
67708: PUSH
67709: LD_INT 2
67711: PUSH
67712: EMPTY
67713: LIST
67714: LIST
67715: PUSH
67716: LD_INT 1
67718: PUSH
67719: LD_INT 2
67721: PUSH
67722: EMPTY
67723: LIST
67724: LIST
67725: PUSH
67726: LD_INT 1
67728: NEG
67729: PUSH
67730: LD_INT 1
67732: PUSH
67733: EMPTY
67734: LIST
67735: LIST
67736: PUSH
67737: LD_INT 2
67739: NEG
67740: PUSH
67741: LD_INT 0
67743: PUSH
67744: EMPTY
67745: LIST
67746: LIST
67747: PUSH
67748: LD_INT 2
67750: NEG
67751: PUSH
67752: LD_INT 1
67754: NEG
67755: PUSH
67756: EMPTY
67757: LIST
67758: LIST
67759: PUSH
67760: LD_INT 1
67762: NEG
67763: PUSH
67764: LD_INT 3
67766: NEG
67767: PUSH
67768: EMPTY
67769: LIST
67770: LIST
67771: PUSH
67772: LD_INT 1
67774: PUSH
67775: LD_INT 2
67777: NEG
67778: PUSH
67779: EMPTY
67780: LIST
67781: LIST
67782: PUSH
67783: LD_INT 3
67785: PUSH
67786: LD_INT 2
67788: PUSH
67789: EMPTY
67790: LIST
67791: LIST
67792: PUSH
67793: LD_INT 2
67795: PUSH
67796: LD_INT 3
67798: PUSH
67799: EMPTY
67800: LIST
67801: LIST
67802: PUSH
67803: LD_INT 2
67805: NEG
67806: PUSH
67807: LD_INT 1
67809: PUSH
67810: EMPTY
67811: LIST
67812: LIST
67813: PUSH
67814: LD_INT 3
67816: NEG
67817: PUSH
67818: LD_INT 1
67820: NEG
67821: PUSH
67822: EMPTY
67823: LIST
67824: LIST
67825: PUSH
67826: EMPTY
67827: LIST
67828: LIST
67829: LIST
67830: LIST
67831: LIST
67832: LIST
67833: LIST
67834: LIST
67835: LIST
67836: LIST
67837: LIST
67838: LIST
67839: LIST
67840: LIST
67841: LIST
67842: LIST
67843: LIST
67844: LIST
67845: LIST
67846: LIST
67847: LIST
67848: LIST
67849: LIST
67850: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
67851: LD_ADDR_VAR 0 31
67855: PUSH
67856: LD_INT 0
67858: PUSH
67859: LD_INT 0
67861: PUSH
67862: EMPTY
67863: LIST
67864: LIST
67865: PUSH
67866: LD_INT 0
67868: PUSH
67869: LD_INT 1
67871: NEG
67872: PUSH
67873: EMPTY
67874: LIST
67875: LIST
67876: PUSH
67877: LD_INT 1
67879: PUSH
67880: LD_INT 0
67882: PUSH
67883: EMPTY
67884: LIST
67885: LIST
67886: PUSH
67887: LD_INT 1
67889: PUSH
67890: LD_INT 1
67892: PUSH
67893: EMPTY
67894: LIST
67895: LIST
67896: PUSH
67897: LD_INT 0
67899: PUSH
67900: LD_INT 1
67902: PUSH
67903: EMPTY
67904: LIST
67905: LIST
67906: PUSH
67907: LD_INT 1
67909: NEG
67910: PUSH
67911: LD_INT 0
67913: PUSH
67914: EMPTY
67915: LIST
67916: LIST
67917: PUSH
67918: LD_INT 1
67920: NEG
67921: PUSH
67922: LD_INT 1
67924: NEG
67925: PUSH
67926: EMPTY
67927: LIST
67928: LIST
67929: PUSH
67930: LD_INT 1
67932: NEG
67933: PUSH
67934: LD_INT 2
67936: NEG
67937: PUSH
67938: EMPTY
67939: LIST
67940: LIST
67941: PUSH
67942: LD_INT 1
67944: PUSH
67945: LD_INT 1
67947: NEG
67948: PUSH
67949: EMPTY
67950: LIST
67951: LIST
67952: PUSH
67953: LD_INT 2
67955: PUSH
67956: LD_INT 0
67958: PUSH
67959: EMPTY
67960: LIST
67961: LIST
67962: PUSH
67963: LD_INT 2
67965: PUSH
67966: LD_INT 1
67968: PUSH
67969: EMPTY
67970: LIST
67971: LIST
67972: PUSH
67973: LD_INT 2
67975: PUSH
67976: LD_INT 2
67978: PUSH
67979: EMPTY
67980: LIST
67981: LIST
67982: PUSH
67983: LD_INT 1
67985: PUSH
67986: LD_INT 2
67988: PUSH
67989: EMPTY
67990: LIST
67991: LIST
67992: PUSH
67993: LD_INT 0
67995: PUSH
67996: LD_INT 2
67998: PUSH
67999: EMPTY
68000: LIST
68001: LIST
68002: PUSH
68003: LD_INT 1
68005: NEG
68006: PUSH
68007: LD_INT 1
68009: PUSH
68010: EMPTY
68011: LIST
68012: LIST
68013: PUSH
68014: LD_INT 2
68016: NEG
68017: PUSH
68018: LD_INT 1
68020: NEG
68021: PUSH
68022: EMPTY
68023: LIST
68024: LIST
68025: PUSH
68026: LD_INT 2
68028: NEG
68029: PUSH
68030: LD_INT 2
68032: NEG
68033: PUSH
68034: EMPTY
68035: LIST
68036: LIST
68037: PUSH
68038: LD_INT 2
68040: NEG
68041: PUSH
68042: LD_INT 3
68044: NEG
68045: PUSH
68046: EMPTY
68047: LIST
68048: LIST
68049: PUSH
68050: LD_INT 2
68052: PUSH
68053: LD_INT 1
68055: NEG
68056: PUSH
68057: EMPTY
68058: LIST
68059: LIST
68060: PUSH
68061: LD_INT 3
68063: PUSH
68064: LD_INT 1
68066: PUSH
68067: EMPTY
68068: LIST
68069: LIST
68070: PUSH
68071: LD_INT 1
68073: PUSH
68074: LD_INT 3
68076: PUSH
68077: EMPTY
68078: LIST
68079: LIST
68080: PUSH
68081: LD_INT 1
68083: NEG
68084: PUSH
68085: LD_INT 2
68087: PUSH
68088: EMPTY
68089: LIST
68090: LIST
68091: PUSH
68092: LD_INT 3
68094: NEG
68095: PUSH
68096: LD_INT 2
68098: NEG
68099: PUSH
68100: EMPTY
68101: LIST
68102: LIST
68103: PUSH
68104: EMPTY
68105: LIST
68106: LIST
68107: LIST
68108: LIST
68109: LIST
68110: LIST
68111: LIST
68112: LIST
68113: LIST
68114: LIST
68115: LIST
68116: LIST
68117: LIST
68118: LIST
68119: LIST
68120: LIST
68121: LIST
68122: LIST
68123: LIST
68124: LIST
68125: LIST
68126: LIST
68127: LIST
68128: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
68129: LD_ADDR_VAR 0 32
68133: PUSH
68134: LD_INT 0
68136: PUSH
68137: LD_INT 0
68139: PUSH
68140: EMPTY
68141: LIST
68142: LIST
68143: PUSH
68144: LD_INT 0
68146: PUSH
68147: LD_INT 1
68149: NEG
68150: PUSH
68151: EMPTY
68152: LIST
68153: LIST
68154: PUSH
68155: LD_INT 1
68157: PUSH
68158: LD_INT 0
68160: PUSH
68161: EMPTY
68162: LIST
68163: LIST
68164: PUSH
68165: LD_INT 1
68167: PUSH
68168: LD_INT 1
68170: PUSH
68171: EMPTY
68172: LIST
68173: LIST
68174: PUSH
68175: LD_INT 0
68177: PUSH
68178: LD_INT 1
68180: PUSH
68181: EMPTY
68182: LIST
68183: LIST
68184: PUSH
68185: LD_INT 1
68187: NEG
68188: PUSH
68189: LD_INT 0
68191: PUSH
68192: EMPTY
68193: LIST
68194: LIST
68195: PUSH
68196: LD_INT 1
68198: NEG
68199: PUSH
68200: LD_INT 1
68202: NEG
68203: PUSH
68204: EMPTY
68205: LIST
68206: LIST
68207: PUSH
68208: LD_INT 1
68210: NEG
68211: PUSH
68212: LD_INT 2
68214: NEG
68215: PUSH
68216: EMPTY
68217: LIST
68218: LIST
68219: PUSH
68220: LD_INT 0
68222: PUSH
68223: LD_INT 2
68225: NEG
68226: PUSH
68227: EMPTY
68228: LIST
68229: LIST
68230: PUSH
68231: LD_INT 1
68233: PUSH
68234: LD_INT 1
68236: NEG
68237: PUSH
68238: EMPTY
68239: LIST
68240: LIST
68241: PUSH
68242: LD_INT 2
68244: PUSH
68245: LD_INT 1
68247: PUSH
68248: EMPTY
68249: LIST
68250: LIST
68251: PUSH
68252: LD_INT 2
68254: PUSH
68255: LD_INT 2
68257: PUSH
68258: EMPTY
68259: LIST
68260: LIST
68261: PUSH
68262: LD_INT 1
68264: PUSH
68265: LD_INT 2
68267: PUSH
68268: EMPTY
68269: LIST
68270: LIST
68271: PUSH
68272: LD_INT 0
68274: PUSH
68275: LD_INT 2
68277: PUSH
68278: EMPTY
68279: LIST
68280: LIST
68281: PUSH
68282: LD_INT 1
68284: NEG
68285: PUSH
68286: LD_INT 1
68288: PUSH
68289: EMPTY
68290: LIST
68291: LIST
68292: PUSH
68293: LD_INT 2
68295: NEG
68296: PUSH
68297: LD_INT 0
68299: PUSH
68300: EMPTY
68301: LIST
68302: LIST
68303: PUSH
68304: LD_INT 2
68306: NEG
68307: PUSH
68308: LD_INT 1
68310: NEG
68311: PUSH
68312: EMPTY
68313: LIST
68314: LIST
68315: PUSH
68316: LD_INT 1
68318: NEG
68319: PUSH
68320: LD_INT 3
68322: NEG
68323: PUSH
68324: EMPTY
68325: LIST
68326: LIST
68327: PUSH
68328: LD_INT 1
68330: PUSH
68331: LD_INT 2
68333: NEG
68334: PUSH
68335: EMPTY
68336: LIST
68337: LIST
68338: PUSH
68339: LD_INT 3
68341: PUSH
68342: LD_INT 2
68344: PUSH
68345: EMPTY
68346: LIST
68347: LIST
68348: PUSH
68349: LD_INT 2
68351: PUSH
68352: LD_INT 3
68354: PUSH
68355: EMPTY
68356: LIST
68357: LIST
68358: PUSH
68359: LD_INT 2
68361: NEG
68362: PUSH
68363: LD_INT 1
68365: PUSH
68366: EMPTY
68367: LIST
68368: LIST
68369: PUSH
68370: LD_INT 3
68372: NEG
68373: PUSH
68374: LD_INT 1
68376: NEG
68377: PUSH
68378: EMPTY
68379: LIST
68380: LIST
68381: PUSH
68382: EMPTY
68383: LIST
68384: LIST
68385: LIST
68386: LIST
68387: LIST
68388: LIST
68389: LIST
68390: LIST
68391: LIST
68392: LIST
68393: LIST
68394: LIST
68395: LIST
68396: LIST
68397: LIST
68398: LIST
68399: LIST
68400: LIST
68401: LIST
68402: LIST
68403: LIST
68404: LIST
68405: LIST
68406: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
68407: LD_ADDR_VAR 0 33
68411: PUSH
68412: LD_INT 0
68414: PUSH
68415: LD_INT 0
68417: PUSH
68418: EMPTY
68419: LIST
68420: LIST
68421: PUSH
68422: LD_INT 0
68424: PUSH
68425: LD_INT 1
68427: NEG
68428: PUSH
68429: EMPTY
68430: LIST
68431: LIST
68432: PUSH
68433: LD_INT 1
68435: PUSH
68436: LD_INT 0
68438: PUSH
68439: EMPTY
68440: LIST
68441: LIST
68442: PUSH
68443: LD_INT 1
68445: PUSH
68446: LD_INT 1
68448: PUSH
68449: EMPTY
68450: LIST
68451: LIST
68452: PUSH
68453: LD_INT 0
68455: PUSH
68456: LD_INT 1
68458: PUSH
68459: EMPTY
68460: LIST
68461: LIST
68462: PUSH
68463: LD_INT 1
68465: NEG
68466: PUSH
68467: LD_INT 0
68469: PUSH
68470: EMPTY
68471: LIST
68472: LIST
68473: PUSH
68474: LD_INT 1
68476: NEG
68477: PUSH
68478: LD_INT 1
68480: NEG
68481: PUSH
68482: EMPTY
68483: LIST
68484: LIST
68485: PUSH
68486: LD_INT 1
68488: NEG
68489: PUSH
68490: LD_INT 2
68492: NEG
68493: PUSH
68494: EMPTY
68495: LIST
68496: LIST
68497: PUSH
68498: LD_INT 1
68500: PUSH
68501: LD_INT 1
68503: NEG
68504: PUSH
68505: EMPTY
68506: LIST
68507: LIST
68508: PUSH
68509: LD_INT 2
68511: PUSH
68512: LD_INT 0
68514: PUSH
68515: EMPTY
68516: LIST
68517: LIST
68518: PUSH
68519: LD_INT 2
68521: PUSH
68522: LD_INT 1
68524: PUSH
68525: EMPTY
68526: LIST
68527: LIST
68528: PUSH
68529: LD_INT 1
68531: PUSH
68532: LD_INT 2
68534: PUSH
68535: EMPTY
68536: LIST
68537: LIST
68538: PUSH
68539: LD_INT 0
68541: PUSH
68542: LD_INT 2
68544: PUSH
68545: EMPTY
68546: LIST
68547: LIST
68548: PUSH
68549: LD_INT 1
68551: NEG
68552: PUSH
68553: LD_INT 1
68555: PUSH
68556: EMPTY
68557: LIST
68558: LIST
68559: PUSH
68560: LD_INT 2
68562: NEG
68563: PUSH
68564: LD_INT 0
68566: PUSH
68567: EMPTY
68568: LIST
68569: LIST
68570: PUSH
68571: LD_INT 2
68573: NEG
68574: PUSH
68575: LD_INT 1
68577: NEG
68578: PUSH
68579: EMPTY
68580: LIST
68581: LIST
68582: PUSH
68583: LD_INT 2
68585: NEG
68586: PUSH
68587: LD_INT 2
68589: NEG
68590: PUSH
68591: EMPTY
68592: LIST
68593: LIST
68594: PUSH
68595: LD_INT 2
68597: NEG
68598: PUSH
68599: LD_INT 3
68601: NEG
68602: PUSH
68603: EMPTY
68604: LIST
68605: LIST
68606: PUSH
68607: LD_INT 2
68609: PUSH
68610: LD_INT 1
68612: NEG
68613: PUSH
68614: EMPTY
68615: LIST
68616: LIST
68617: PUSH
68618: LD_INT 3
68620: PUSH
68621: LD_INT 1
68623: PUSH
68624: EMPTY
68625: LIST
68626: LIST
68627: PUSH
68628: LD_INT 1
68630: PUSH
68631: LD_INT 3
68633: PUSH
68634: EMPTY
68635: LIST
68636: LIST
68637: PUSH
68638: LD_INT 1
68640: NEG
68641: PUSH
68642: LD_INT 2
68644: PUSH
68645: EMPTY
68646: LIST
68647: LIST
68648: PUSH
68649: LD_INT 3
68651: NEG
68652: PUSH
68653: LD_INT 2
68655: NEG
68656: PUSH
68657: EMPTY
68658: LIST
68659: LIST
68660: PUSH
68661: EMPTY
68662: LIST
68663: LIST
68664: LIST
68665: LIST
68666: LIST
68667: LIST
68668: LIST
68669: LIST
68670: LIST
68671: LIST
68672: LIST
68673: LIST
68674: LIST
68675: LIST
68676: LIST
68677: LIST
68678: LIST
68679: LIST
68680: LIST
68681: LIST
68682: LIST
68683: LIST
68684: LIST
68685: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
68686: LD_ADDR_VAR 0 34
68690: PUSH
68691: LD_INT 0
68693: PUSH
68694: LD_INT 0
68696: PUSH
68697: EMPTY
68698: LIST
68699: LIST
68700: PUSH
68701: LD_INT 0
68703: PUSH
68704: LD_INT 1
68706: NEG
68707: PUSH
68708: EMPTY
68709: LIST
68710: LIST
68711: PUSH
68712: LD_INT 1
68714: PUSH
68715: LD_INT 0
68717: PUSH
68718: EMPTY
68719: LIST
68720: LIST
68721: PUSH
68722: LD_INT 1
68724: PUSH
68725: LD_INT 1
68727: PUSH
68728: EMPTY
68729: LIST
68730: LIST
68731: PUSH
68732: LD_INT 0
68734: PUSH
68735: LD_INT 1
68737: PUSH
68738: EMPTY
68739: LIST
68740: LIST
68741: PUSH
68742: LD_INT 1
68744: NEG
68745: PUSH
68746: LD_INT 0
68748: PUSH
68749: EMPTY
68750: LIST
68751: LIST
68752: PUSH
68753: LD_INT 1
68755: NEG
68756: PUSH
68757: LD_INT 1
68759: NEG
68760: PUSH
68761: EMPTY
68762: LIST
68763: LIST
68764: PUSH
68765: LD_INT 1
68767: NEG
68768: PUSH
68769: LD_INT 2
68771: NEG
68772: PUSH
68773: EMPTY
68774: LIST
68775: LIST
68776: PUSH
68777: LD_INT 0
68779: PUSH
68780: LD_INT 2
68782: NEG
68783: PUSH
68784: EMPTY
68785: LIST
68786: LIST
68787: PUSH
68788: LD_INT 1
68790: PUSH
68791: LD_INT 1
68793: NEG
68794: PUSH
68795: EMPTY
68796: LIST
68797: LIST
68798: PUSH
68799: LD_INT 2
68801: PUSH
68802: LD_INT 1
68804: PUSH
68805: EMPTY
68806: LIST
68807: LIST
68808: PUSH
68809: LD_INT 2
68811: PUSH
68812: LD_INT 2
68814: PUSH
68815: EMPTY
68816: LIST
68817: LIST
68818: PUSH
68819: LD_INT 1
68821: PUSH
68822: LD_INT 2
68824: PUSH
68825: EMPTY
68826: LIST
68827: LIST
68828: PUSH
68829: LD_INT 1
68831: NEG
68832: PUSH
68833: LD_INT 1
68835: PUSH
68836: EMPTY
68837: LIST
68838: LIST
68839: PUSH
68840: LD_INT 2
68842: NEG
68843: PUSH
68844: LD_INT 0
68846: PUSH
68847: EMPTY
68848: LIST
68849: LIST
68850: PUSH
68851: LD_INT 2
68853: NEG
68854: PUSH
68855: LD_INT 1
68857: NEG
68858: PUSH
68859: EMPTY
68860: LIST
68861: LIST
68862: PUSH
68863: LD_INT 2
68865: NEG
68866: PUSH
68867: LD_INT 2
68869: NEG
68870: PUSH
68871: EMPTY
68872: LIST
68873: LIST
68874: PUSH
68875: LD_INT 1
68877: NEG
68878: PUSH
68879: LD_INT 3
68881: NEG
68882: PUSH
68883: EMPTY
68884: LIST
68885: LIST
68886: PUSH
68887: LD_INT 1
68889: PUSH
68890: LD_INT 2
68892: NEG
68893: PUSH
68894: EMPTY
68895: LIST
68896: LIST
68897: PUSH
68898: LD_INT 3
68900: PUSH
68901: LD_INT 2
68903: PUSH
68904: EMPTY
68905: LIST
68906: LIST
68907: PUSH
68908: LD_INT 2
68910: PUSH
68911: LD_INT 3
68913: PUSH
68914: EMPTY
68915: LIST
68916: LIST
68917: PUSH
68918: LD_INT 2
68920: NEG
68921: PUSH
68922: LD_INT 1
68924: PUSH
68925: EMPTY
68926: LIST
68927: LIST
68928: PUSH
68929: LD_INT 3
68931: NEG
68932: PUSH
68933: LD_INT 1
68935: NEG
68936: PUSH
68937: EMPTY
68938: LIST
68939: LIST
68940: PUSH
68941: EMPTY
68942: LIST
68943: LIST
68944: LIST
68945: LIST
68946: LIST
68947: LIST
68948: LIST
68949: LIST
68950: LIST
68951: LIST
68952: LIST
68953: LIST
68954: LIST
68955: LIST
68956: LIST
68957: LIST
68958: LIST
68959: LIST
68960: LIST
68961: LIST
68962: LIST
68963: LIST
68964: LIST
68965: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
68966: LD_ADDR_VAR 0 35
68970: PUSH
68971: LD_INT 0
68973: PUSH
68974: LD_INT 0
68976: PUSH
68977: EMPTY
68978: LIST
68979: LIST
68980: PUSH
68981: LD_INT 0
68983: PUSH
68984: LD_INT 1
68986: NEG
68987: PUSH
68988: EMPTY
68989: LIST
68990: LIST
68991: PUSH
68992: LD_INT 1
68994: PUSH
68995: LD_INT 0
68997: PUSH
68998: EMPTY
68999: LIST
69000: LIST
69001: PUSH
69002: LD_INT 1
69004: PUSH
69005: LD_INT 1
69007: PUSH
69008: EMPTY
69009: LIST
69010: LIST
69011: PUSH
69012: LD_INT 0
69014: PUSH
69015: LD_INT 1
69017: PUSH
69018: EMPTY
69019: LIST
69020: LIST
69021: PUSH
69022: LD_INT 1
69024: NEG
69025: PUSH
69026: LD_INT 0
69028: PUSH
69029: EMPTY
69030: LIST
69031: LIST
69032: PUSH
69033: LD_INT 1
69035: NEG
69036: PUSH
69037: LD_INT 1
69039: NEG
69040: PUSH
69041: EMPTY
69042: LIST
69043: LIST
69044: PUSH
69045: LD_INT 2
69047: PUSH
69048: LD_INT 1
69050: PUSH
69051: EMPTY
69052: LIST
69053: LIST
69054: PUSH
69055: LD_INT 2
69057: NEG
69058: PUSH
69059: LD_INT 1
69061: NEG
69062: PUSH
69063: EMPTY
69064: LIST
69065: LIST
69066: PUSH
69067: EMPTY
69068: LIST
69069: LIST
69070: LIST
69071: LIST
69072: LIST
69073: LIST
69074: LIST
69075: LIST
69076: LIST
69077: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
69078: LD_ADDR_VAR 0 36
69082: PUSH
69083: LD_INT 0
69085: PUSH
69086: LD_INT 0
69088: PUSH
69089: EMPTY
69090: LIST
69091: LIST
69092: PUSH
69093: LD_INT 0
69095: PUSH
69096: LD_INT 1
69098: NEG
69099: PUSH
69100: EMPTY
69101: LIST
69102: LIST
69103: PUSH
69104: LD_INT 1
69106: PUSH
69107: LD_INT 0
69109: PUSH
69110: EMPTY
69111: LIST
69112: LIST
69113: PUSH
69114: LD_INT 1
69116: PUSH
69117: LD_INT 1
69119: PUSH
69120: EMPTY
69121: LIST
69122: LIST
69123: PUSH
69124: LD_INT 0
69126: PUSH
69127: LD_INT 1
69129: PUSH
69130: EMPTY
69131: LIST
69132: LIST
69133: PUSH
69134: LD_INT 1
69136: NEG
69137: PUSH
69138: LD_INT 0
69140: PUSH
69141: EMPTY
69142: LIST
69143: LIST
69144: PUSH
69145: LD_INT 1
69147: NEG
69148: PUSH
69149: LD_INT 1
69151: NEG
69152: PUSH
69153: EMPTY
69154: LIST
69155: LIST
69156: PUSH
69157: LD_INT 1
69159: NEG
69160: PUSH
69161: LD_INT 2
69163: NEG
69164: PUSH
69165: EMPTY
69166: LIST
69167: LIST
69168: PUSH
69169: LD_INT 1
69171: PUSH
69172: LD_INT 2
69174: PUSH
69175: EMPTY
69176: LIST
69177: LIST
69178: PUSH
69179: EMPTY
69180: LIST
69181: LIST
69182: LIST
69183: LIST
69184: LIST
69185: LIST
69186: LIST
69187: LIST
69188: LIST
69189: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
69190: LD_ADDR_VAR 0 37
69194: PUSH
69195: LD_INT 0
69197: PUSH
69198: LD_INT 0
69200: PUSH
69201: EMPTY
69202: LIST
69203: LIST
69204: PUSH
69205: LD_INT 0
69207: PUSH
69208: LD_INT 1
69210: NEG
69211: PUSH
69212: EMPTY
69213: LIST
69214: LIST
69215: PUSH
69216: LD_INT 1
69218: PUSH
69219: LD_INT 0
69221: PUSH
69222: EMPTY
69223: LIST
69224: LIST
69225: PUSH
69226: LD_INT 1
69228: PUSH
69229: LD_INT 1
69231: PUSH
69232: EMPTY
69233: LIST
69234: LIST
69235: PUSH
69236: LD_INT 0
69238: PUSH
69239: LD_INT 1
69241: PUSH
69242: EMPTY
69243: LIST
69244: LIST
69245: PUSH
69246: LD_INT 1
69248: NEG
69249: PUSH
69250: LD_INT 0
69252: PUSH
69253: EMPTY
69254: LIST
69255: LIST
69256: PUSH
69257: LD_INT 1
69259: NEG
69260: PUSH
69261: LD_INT 1
69263: NEG
69264: PUSH
69265: EMPTY
69266: LIST
69267: LIST
69268: PUSH
69269: LD_INT 1
69271: PUSH
69272: LD_INT 1
69274: NEG
69275: PUSH
69276: EMPTY
69277: LIST
69278: LIST
69279: PUSH
69280: LD_INT 1
69282: NEG
69283: PUSH
69284: LD_INT 1
69286: PUSH
69287: EMPTY
69288: LIST
69289: LIST
69290: PUSH
69291: EMPTY
69292: LIST
69293: LIST
69294: LIST
69295: LIST
69296: LIST
69297: LIST
69298: LIST
69299: LIST
69300: LIST
69301: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
69302: LD_ADDR_VAR 0 38
69306: PUSH
69307: LD_INT 0
69309: PUSH
69310: LD_INT 0
69312: PUSH
69313: EMPTY
69314: LIST
69315: LIST
69316: PUSH
69317: LD_INT 0
69319: PUSH
69320: LD_INT 1
69322: NEG
69323: PUSH
69324: EMPTY
69325: LIST
69326: LIST
69327: PUSH
69328: LD_INT 1
69330: PUSH
69331: LD_INT 0
69333: PUSH
69334: EMPTY
69335: LIST
69336: LIST
69337: PUSH
69338: LD_INT 1
69340: PUSH
69341: LD_INT 1
69343: PUSH
69344: EMPTY
69345: LIST
69346: LIST
69347: PUSH
69348: LD_INT 0
69350: PUSH
69351: LD_INT 1
69353: PUSH
69354: EMPTY
69355: LIST
69356: LIST
69357: PUSH
69358: LD_INT 1
69360: NEG
69361: PUSH
69362: LD_INT 0
69364: PUSH
69365: EMPTY
69366: LIST
69367: LIST
69368: PUSH
69369: LD_INT 1
69371: NEG
69372: PUSH
69373: LD_INT 1
69375: NEG
69376: PUSH
69377: EMPTY
69378: LIST
69379: LIST
69380: PUSH
69381: LD_INT 2
69383: PUSH
69384: LD_INT 1
69386: PUSH
69387: EMPTY
69388: LIST
69389: LIST
69390: PUSH
69391: LD_INT 2
69393: NEG
69394: PUSH
69395: LD_INT 1
69397: NEG
69398: PUSH
69399: EMPTY
69400: LIST
69401: LIST
69402: PUSH
69403: EMPTY
69404: LIST
69405: LIST
69406: LIST
69407: LIST
69408: LIST
69409: LIST
69410: LIST
69411: LIST
69412: LIST
69413: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
69414: LD_ADDR_VAR 0 39
69418: PUSH
69419: LD_INT 0
69421: PUSH
69422: LD_INT 0
69424: PUSH
69425: EMPTY
69426: LIST
69427: LIST
69428: PUSH
69429: LD_INT 0
69431: PUSH
69432: LD_INT 1
69434: NEG
69435: PUSH
69436: EMPTY
69437: LIST
69438: LIST
69439: PUSH
69440: LD_INT 1
69442: PUSH
69443: LD_INT 0
69445: PUSH
69446: EMPTY
69447: LIST
69448: LIST
69449: PUSH
69450: LD_INT 1
69452: PUSH
69453: LD_INT 1
69455: PUSH
69456: EMPTY
69457: LIST
69458: LIST
69459: PUSH
69460: LD_INT 0
69462: PUSH
69463: LD_INT 1
69465: PUSH
69466: EMPTY
69467: LIST
69468: LIST
69469: PUSH
69470: LD_INT 1
69472: NEG
69473: PUSH
69474: LD_INT 0
69476: PUSH
69477: EMPTY
69478: LIST
69479: LIST
69480: PUSH
69481: LD_INT 1
69483: NEG
69484: PUSH
69485: LD_INT 1
69487: NEG
69488: PUSH
69489: EMPTY
69490: LIST
69491: LIST
69492: PUSH
69493: LD_INT 1
69495: NEG
69496: PUSH
69497: LD_INT 2
69499: NEG
69500: PUSH
69501: EMPTY
69502: LIST
69503: LIST
69504: PUSH
69505: LD_INT 1
69507: PUSH
69508: LD_INT 2
69510: PUSH
69511: EMPTY
69512: LIST
69513: LIST
69514: PUSH
69515: EMPTY
69516: LIST
69517: LIST
69518: LIST
69519: LIST
69520: LIST
69521: LIST
69522: LIST
69523: LIST
69524: LIST
69525: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
69526: LD_ADDR_VAR 0 40
69530: PUSH
69531: LD_INT 0
69533: PUSH
69534: LD_INT 0
69536: PUSH
69537: EMPTY
69538: LIST
69539: LIST
69540: PUSH
69541: LD_INT 0
69543: PUSH
69544: LD_INT 1
69546: NEG
69547: PUSH
69548: EMPTY
69549: LIST
69550: LIST
69551: PUSH
69552: LD_INT 1
69554: PUSH
69555: LD_INT 0
69557: PUSH
69558: EMPTY
69559: LIST
69560: LIST
69561: PUSH
69562: LD_INT 1
69564: PUSH
69565: LD_INT 1
69567: PUSH
69568: EMPTY
69569: LIST
69570: LIST
69571: PUSH
69572: LD_INT 0
69574: PUSH
69575: LD_INT 1
69577: PUSH
69578: EMPTY
69579: LIST
69580: LIST
69581: PUSH
69582: LD_INT 1
69584: NEG
69585: PUSH
69586: LD_INT 0
69588: PUSH
69589: EMPTY
69590: LIST
69591: LIST
69592: PUSH
69593: LD_INT 1
69595: NEG
69596: PUSH
69597: LD_INT 1
69599: NEG
69600: PUSH
69601: EMPTY
69602: LIST
69603: LIST
69604: PUSH
69605: LD_INT 1
69607: PUSH
69608: LD_INT 1
69610: NEG
69611: PUSH
69612: EMPTY
69613: LIST
69614: LIST
69615: PUSH
69616: LD_INT 1
69618: NEG
69619: PUSH
69620: LD_INT 1
69622: PUSH
69623: EMPTY
69624: LIST
69625: LIST
69626: PUSH
69627: EMPTY
69628: LIST
69629: LIST
69630: LIST
69631: LIST
69632: LIST
69633: LIST
69634: LIST
69635: LIST
69636: LIST
69637: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
69638: LD_ADDR_VAR 0 41
69642: PUSH
69643: LD_INT 0
69645: PUSH
69646: LD_INT 0
69648: PUSH
69649: EMPTY
69650: LIST
69651: LIST
69652: PUSH
69653: LD_INT 0
69655: PUSH
69656: LD_INT 1
69658: NEG
69659: PUSH
69660: EMPTY
69661: LIST
69662: LIST
69663: PUSH
69664: LD_INT 1
69666: PUSH
69667: LD_INT 0
69669: PUSH
69670: EMPTY
69671: LIST
69672: LIST
69673: PUSH
69674: LD_INT 1
69676: PUSH
69677: LD_INT 1
69679: PUSH
69680: EMPTY
69681: LIST
69682: LIST
69683: PUSH
69684: LD_INT 0
69686: PUSH
69687: LD_INT 1
69689: PUSH
69690: EMPTY
69691: LIST
69692: LIST
69693: PUSH
69694: LD_INT 1
69696: NEG
69697: PUSH
69698: LD_INT 0
69700: PUSH
69701: EMPTY
69702: LIST
69703: LIST
69704: PUSH
69705: LD_INT 1
69707: NEG
69708: PUSH
69709: LD_INT 1
69711: NEG
69712: PUSH
69713: EMPTY
69714: LIST
69715: LIST
69716: PUSH
69717: LD_INT 1
69719: NEG
69720: PUSH
69721: LD_INT 2
69723: NEG
69724: PUSH
69725: EMPTY
69726: LIST
69727: LIST
69728: PUSH
69729: LD_INT 1
69731: PUSH
69732: LD_INT 1
69734: NEG
69735: PUSH
69736: EMPTY
69737: LIST
69738: LIST
69739: PUSH
69740: LD_INT 2
69742: PUSH
69743: LD_INT 0
69745: PUSH
69746: EMPTY
69747: LIST
69748: LIST
69749: PUSH
69750: LD_INT 2
69752: PUSH
69753: LD_INT 1
69755: PUSH
69756: EMPTY
69757: LIST
69758: LIST
69759: PUSH
69760: LD_INT 2
69762: PUSH
69763: LD_INT 2
69765: PUSH
69766: EMPTY
69767: LIST
69768: LIST
69769: PUSH
69770: LD_INT 1
69772: PUSH
69773: LD_INT 2
69775: PUSH
69776: EMPTY
69777: LIST
69778: LIST
69779: PUSH
69780: LD_INT 1
69782: NEG
69783: PUSH
69784: LD_INT 1
69786: PUSH
69787: EMPTY
69788: LIST
69789: LIST
69790: PUSH
69791: LD_INT 2
69793: NEG
69794: PUSH
69795: LD_INT 0
69797: PUSH
69798: EMPTY
69799: LIST
69800: LIST
69801: PUSH
69802: LD_INT 2
69804: NEG
69805: PUSH
69806: LD_INT 1
69808: NEG
69809: PUSH
69810: EMPTY
69811: LIST
69812: LIST
69813: PUSH
69814: LD_INT 2
69816: NEG
69817: PUSH
69818: LD_INT 2
69820: NEG
69821: PUSH
69822: EMPTY
69823: LIST
69824: LIST
69825: PUSH
69826: LD_INT 2
69828: NEG
69829: PUSH
69830: LD_INT 3
69832: NEG
69833: PUSH
69834: EMPTY
69835: LIST
69836: LIST
69837: PUSH
69838: LD_INT 2
69840: PUSH
69841: LD_INT 1
69843: NEG
69844: PUSH
69845: EMPTY
69846: LIST
69847: LIST
69848: PUSH
69849: LD_INT 3
69851: PUSH
69852: LD_INT 0
69854: PUSH
69855: EMPTY
69856: LIST
69857: LIST
69858: PUSH
69859: LD_INT 3
69861: PUSH
69862: LD_INT 1
69864: PUSH
69865: EMPTY
69866: LIST
69867: LIST
69868: PUSH
69869: LD_INT 3
69871: PUSH
69872: LD_INT 2
69874: PUSH
69875: EMPTY
69876: LIST
69877: LIST
69878: PUSH
69879: LD_INT 3
69881: PUSH
69882: LD_INT 3
69884: PUSH
69885: EMPTY
69886: LIST
69887: LIST
69888: PUSH
69889: LD_INT 2
69891: PUSH
69892: LD_INT 3
69894: PUSH
69895: EMPTY
69896: LIST
69897: LIST
69898: PUSH
69899: LD_INT 2
69901: NEG
69902: PUSH
69903: LD_INT 1
69905: PUSH
69906: EMPTY
69907: LIST
69908: LIST
69909: PUSH
69910: LD_INT 3
69912: NEG
69913: PUSH
69914: LD_INT 0
69916: PUSH
69917: EMPTY
69918: LIST
69919: LIST
69920: PUSH
69921: LD_INT 3
69923: NEG
69924: PUSH
69925: LD_INT 1
69927: NEG
69928: PUSH
69929: EMPTY
69930: LIST
69931: LIST
69932: PUSH
69933: LD_INT 3
69935: NEG
69936: PUSH
69937: LD_INT 2
69939: NEG
69940: PUSH
69941: EMPTY
69942: LIST
69943: LIST
69944: PUSH
69945: LD_INT 3
69947: NEG
69948: PUSH
69949: LD_INT 3
69951: NEG
69952: PUSH
69953: EMPTY
69954: LIST
69955: LIST
69956: PUSH
69957: EMPTY
69958: LIST
69959: LIST
69960: LIST
69961: LIST
69962: LIST
69963: LIST
69964: LIST
69965: LIST
69966: LIST
69967: LIST
69968: LIST
69969: LIST
69970: LIST
69971: LIST
69972: LIST
69973: LIST
69974: LIST
69975: LIST
69976: LIST
69977: LIST
69978: LIST
69979: LIST
69980: LIST
69981: LIST
69982: LIST
69983: LIST
69984: LIST
69985: LIST
69986: LIST
69987: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
69988: LD_ADDR_VAR 0 42
69992: PUSH
69993: LD_INT 0
69995: PUSH
69996: LD_INT 0
69998: PUSH
69999: EMPTY
70000: LIST
70001: LIST
70002: PUSH
70003: LD_INT 0
70005: PUSH
70006: LD_INT 1
70008: NEG
70009: PUSH
70010: EMPTY
70011: LIST
70012: LIST
70013: PUSH
70014: LD_INT 1
70016: PUSH
70017: LD_INT 0
70019: PUSH
70020: EMPTY
70021: LIST
70022: LIST
70023: PUSH
70024: LD_INT 1
70026: PUSH
70027: LD_INT 1
70029: PUSH
70030: EMPTY
70031: LIST
70032: LIST
70033: PUSH
70034: LD_INT 0
70036: PUSH
70037: LD_INT 1
70039: PUSH
70040: EMPTY
70041: LIST
70042: LIST
70043: PUSH
70044: LD_INT 1
70046: NEG
70047: PUSH
70048: LD_INT 0
70050: PUSH
70051: EMPTY
70052: LIST
70053: LIST
70054: PUSH
70055: LD_INT 1
70057: NEG
70058: PUSH
70059: LD_INT 1
70061: NEG
70062: PUSH
70063: EMPTY
70064: LIST
70065: LIST
70066: PUSH
70067: LD_INT 1
70069: NEG
70070: PUSH
70071: LD_INT 2
70073: NEG
70074: PUSH
70075: EMPTY
70076: LIST
70077: LIST
70078: PUSH
70079: LD_INT 0
70081: PUSH
70082: LD_INT 2
70084: NEG
70085: PUSH
70086: EMPTY
70087: LIST
70088: LIST
70089: PUSH
70090: LD_INT 1
70092: PUSH
70093: LD_INT 1
70095: NEG
70096: PUSH
70097: EMPTY
70098: LIST
70099: LIST
70100: PUSH
70101: LD_INT 2
70103: PUSH
70104: LD_INT 1
70106: PUSH
70107: EMPTY
70108: LIST
70109: LIST
70110: PUSH
70111: LD_INT 2
70113: PUSH
70114: LD_INT 2
70116: PUSH
70117: EMPTY
70118: LIST
70119: LIST
70120: PUSH
70121: LD_INT 1
70123: PUSH
70124: LD_INT 2
70126: PUSH
70127: EMPTY
70128: LIST
70129: LIST
70130: PUSH
70131: LD_INT 0
70133: PUSH
70134: LD_INT 2
70136: PUSH
70137: EMPTY
70138: LIST
70139: LIST
70140: PUSH
70141: LD_INT 1
70143: NEG
70144: PUSH
70145: LD_INT 1
70147: PUSH
70148: EMPTY
70149: LIST
70150: LIST
70151: PUSH
70152: LD_INT 2
70154: NEG
70155: PUSH
70156: LD_INT 1
70158: NEG
70159: PUSH
70160: EMPTY
70161: LIST
70162: LIST
70163: PUSH
70164: LD_INT 2
70166: NEG
70167: PUSH
70168: LD_INT 2
70170: NEG
70171: PUSH
70172: EMPTY
70173: LIST
70174: LIST
70175: PUSH
70176: LD_INT 2
70178: NEG
70179: PUSH
70180: LD_INT 3
70182: NEG
70183: PUSH
70184: EMPTY
70185: LIST
70186: LIST
70187: PUSH
70188: LD_INT 1
70190: NEG
70191: PUSH
70192: LD_INT 3
70194: NEG
70195: PUSH
70196: EMPTY
70197: LIST
70198: LIST
70199: PUSH
70200: LD_INT 0
70202: PUSH
70203: LD_INT 3
70205: NEG
70206: PUSH
70207: EMPTY
70208: LIST
70209: LIST
70210: PUSH
70211: LD_INT 1
70213: PUSH
70214: LD_INT 2
70216: NEG
70217: PUSH
70218: EMPTY
70219: LIST
70220: LIST
70221: PUSH
70222: LD_INT 3
70224: PUSH
70225: LD_INT 2
70227: PUSH
70228: EMPTY
70229: LIST
70230: LIST
70231: PUSH
70232: LD_INT 3
70234: PUSH
70235: LD_INT 3
70237: PUSH
70238: EMPTY
70239: LIST
70240: LIST
70241: PUSH
70242: LD_INT 2
70244: PUSH
70245: LD_INT 3
70247: PUSH
70248: EMPTY
70249: LIST
70250: LIST
70251: PUSH
70252: LD_INT 1
70254: PUSH
70255: LD_INT 3
70257: PUSH
70258: EMPTY
70259: LIST
70260: LIST
70261: PUSH
70262: LD_INT 0
70264: PUSH
70265: LD_INT 3
70267: PUSH
70268: EMPTY
70269: LIST
70270: LIST
70271: PUSH
70272: LD_INT 1
70274: NEG
70275: PUSH
70276: LD_INT 2
70278: PUSH
70279: EMPTY
70280: LIST
70281: LIST
70282: PUSH
70283: LD_INT 3
70285: NEG
70286: PUSH
70287: LD_INT 2
70289: NEG
70290: PUSH
70291: EMPTY
70292: LIST
70293: LIST
70294: PUSH
70295: LD_INT 3
70297: NEG
70298: PUSH
70299: LD_INT 3
70301: NEG
70302: PUSH
70303: EMPTY
70304: LIST
70305: LIST
70306: PUSH
70307: EMPTY
70308: LIST
70309: LIST
70310: LIST
70311: LIST
70312: LIST
70313: LIST
70314: LIST
70315: LIST
70316: LIST
70317: LIST
70318: LIST
70319: LIST
70320: LIST
70321: LIST
70322: LIST
70323: LIST
70324: LIST
70325: LIST
70326: LIST
70327: LIST
70328: LIST
70329: LIST
70330: LIST
70331: LIST
70332: LIST
70333: LIST
70334: LIST
70335: LIST
70336: LIST
70337: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
70338: LD_ADDR_VAR 0 43
70342: PUSH
70343: LD_INT 0
70345: PUSH
70346: LD_INT 0
70348: PUSH
70349: EMPTY
70350: LIST
70351: LIST
70352: PUSH
70353: LD_INT 0
70355: PUSH
70356: LD_INT 1
70358: NEG
70359: PUSH
70360: EMPTY
70361: LIST
70362: LIST
70363: PUSH
70364: LD_INT 1
70366: PUSH
70367: LD_INT 0
70369: PUSH
70370: EMPTY
70371: LIST
70372: LIST
70373: PUSH
70374: LD_INT 1
70376: PUSH
70377: LD_INT 1
70379: PUSH
70380: EMPTY
70381: LIST
70382: LIST
70383: PUSH
70384: LD_INT 0
70386: PUSH
70387: LD_INT 1
70389: PUSH
70390: EMPTY
70391: LIST
70392: LIST
70393: PUSH
70394: LD_INT 1
70396: NEG
70397: PUSH
70398: LD_INT 0
70400: PUSH
70401: EMPTY
70402: LIST
70403: LIST
70404: PUSH
70405: LD_INT 1
70407: NEG
70408: PUSH
70409: LD_INT 1
70411: NEG
70412: PUSH
70413: EMPTY
70414: LIST
70415: LIST
70416: PUSH
70417: LD_INT 1
70419: NEG
70420: PUSH
70421: LD_INT 2
70423: NEG
70424: PUSH
70425: EMPTY
70426: LIST
70427: LIST
70428: PUSH
70429: LD_INT 0
70431: PUSH
70432: LD_INT 2
70434: NEG
70435: PUSH
70436: EMPTY
70437: LIST
70438: LIST
70439: PUSH
70440: LD_INT 1
70442: PUSH
70443: LD_INT 1
70445: NEG
70446: PUSH
70447: EMPTY
70448: LIST
70449: LIST
70450: PUSH
70451: LD_INT 2
70453: PUSH
70454: LD_INT 0
70456: PUSH
70457: EMPTY
70458: LIST
70459: LIST
70460: PUSH
70461: LD_INT 2
70463: PUSH
70464: LD_INT 1
70466: PUSH
70467: EMPTY
70468: LIST
70469: LIST
70470: PUSH
70471: LD_INT 1
70473: PUSH
70474: LD_INT 2
70476: PUSH
70477: EMPTY
70478: LIST
70479: LIST
70480: PUSH
70481: LD_INT 0
70483: PUSH
70484: LD_INT 2
70486: PUSH
70487: EMPTY
70488: LIST
70489: LIST
70490: PUSH
70491: LD_INT 1
70493: NEG
70494: PUSH
70495: LD_INT 1
70497: PUSH
70498: EMPTY
70499: LIST
70500: LIST
70501: PUSH
70502: LD_INT 2
70504: NEG
70505: PUSH
70506: LD_INT 0
70508: PUSH
70509: EMPTY
70510: LIST
70511: LIST
70512: PUSH
70513: LD_INT 2
70515: NEG
70516: PUSH
70517: LD_INT 1
70519: NEG
70520: PUSH
70521: EMPTY
70522: LIST
70523: LIST
70524: PUSH
70525: LD_INT 1
70527: NEG
70528: PUSH
70529: LD_INT 3
70531: NEG
70532: PUSH
70533: EMPTY
70534: LIST
70535: LIST
70536: PUSH
70537: LD_INT 0
70539: PUSH
70540: LD_INT 3
70542: NEG
70543: PUSH
70544: EMPTY
70545: LIST
70546: LIST
70547: PUSH
70548: LD_INT 1
70550: PUSH
70551: LD_INT 2
70553: NEG
70554: PUSH
70555: EMPTY
70556: LIST
70557: LIST
70558: PUSH
70559: LD_INT 2
70561: PUSH
70562: LD_INT 1
70564: NEG
70565: PUSH
70566: EMPTY
70567: LIST
70568: LIST
70569: PUSH
70570: LD_INT 3
70572: PUSH
70573: LD_INT 0
70575: PUSH
70576: EMPTY
70577: LIST
70578: LIST
70579: PUSH
70580: LD_INT 3
70582: PUSH
70583: LD_INT 1
70585: PUSH
70586: EMPTY
70587: LIST
70588: LIST
70589: PUSH
70590: LD_INT 1
70592: PUSH
70593: LD_INT 3
70595: PUSH
70596: EMPTY
70597: LIST
70598: LIST
70599: PUSH
70600: LD_INT 0
70602: PUSH
70603: LD_INT 3
70605: PUSH
70606: EMPTY
70607: LIST
70608: LIST
70609: PUSH
70610: LD_INT 1
70612: NEG
70613: PUSH
70614: LD_INT 2
70616: PUSH
70617: EMPTY
70618: LIST
70619: LIST
70620: PUSH
70621: LD_INT 2
70623: NEG
70624: PUSH
70625: LD_INT 1
70627: PUSH
70628: EMPTY
70629: LIST
70630: LIST
70631: PUSH
70632: LD_INT 3
70634: NEG
70635: PUSH
70636: LD_INT 0
70638: PUSH
70639: EMPTY
70640: LIST
70641: LIST
70642: PUSH
70643: LD_INT 3
70645: NEG
70646: PUSH
70647: LD_INT 1
70649: NEG
70650: PUSH
70651: EMPTY
70652: LIST
70653: LIST
70654: PUSH
70655: EMPTY
70656: LIST
70657: LIST
70658: LIST
70659: LIST
70660: LIST
70661: LIST
70662: LIST
70663: LIST
70664: LIST
70665: LIST
70666: LIST
70667: LIST
70668: LIST
70669: LIST
70670: LIST
70671: LIST
70672: LIST
70673: LIST
70674: LIST
70675: LIST
70676: LIST
70677: LIST
70678: LIST
70679: LIST
70680: LIST
70681: LIST
70682: LIST
70683: LIST
70684: LIST
70685: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70686: LD_ADDR_VAR 0 44
70690: PUSH
70691: LD_INT 0
70693: PUSH
70694: LD_INT 0
70696: PUSH
70697: EMPTY
70698: LIST
70699: LIST
70700: PUSH
70701: LD_INT 0
70703: PUSH
70704: LD_INT 1
70706: NEG
70707: PUSH
70708: EMPTY
70709: LIST
70710: LIST
70711: PUSH
70712: LD_INT 1
70714: PUSH
70715: LD_INT 0
70717: PUSH
70718: EMPTY
70719: LIST
70720: LIST
70721: PUSH
70722: LD_INT 1
70724: PUSH
70725: LD_INT 1
70727: PUSH
70728: EMPTY
70729: LIST
70730: LIST
70731: PUSH
70732: LD_INT 0
70734: PUSH
70735: LD_INT 1
70737: PUSH
70738: EMPTY
70739: LIST
70740: LIST
70741: PUSH
70742: LD_INT 1
70744: NEG
70745: PUSH
70746: LD_INT 0
70748: PUSH
70749: EMPTY
70750: LIST
70751: LIST
70752: PUSH
70753: LD_INT 1
70755: NEG
70756: PUSH
70757: LD_INT 1
70759: NEG
70760: PUSH
70761: EMPTY
70762: LIST
70763: LIST
70764: PUSH
70765: LD_INT 1
70767: NEG
70768: PUSH
70769: LD_INT 2
70771: NEG
70772: PUSH
70773: EMPTY
70774: LIST
70775: LIST
70776: PUSH
70777: LD_INT 1
70779: PUSH
70780: LD_INT 1
70782: NEG
70783: PUSH
70784: EMPTY
70785: LIST
70786: LIST
70787: PUSH
70788: LD_INT 2
70790: PUSH
70791: LD_INT 0
70793: PUSH
70794: EMPTY
70795: LIST
70796: LIST
70797: PUSH
70798: LD_INT 2
70800: PUSH
70801: LD_INT 1
70803: PUSH
70804: EMPTY
70805: LIST
70806: LIST
70807: PUSH
70808: LD_INT 2
70810: PUSH
70811: LD_INT 2
70813: PUSH
70814: EMPTY
70815: LIST
70816: LIST
70817: PUSH
70818: LD_INT 1
70820: PUSH
70821: LD_INT 2
70823: PUSH
70824: EMPTY
70825: LIST
70826: LIST
70827: PUSH
70828: LD_INT 1
70830: NEG
70831: PUSH
70832: LD_INT 1
70834: PUSH
70835: EMPTY
70836: LIST
70837: LIST
70838: PUSH
70839: LD_INT 2
70841: NEG
70842: PUSH
70843: LD_INT 0
70845: PUSH
70846: EMPTY
70847: LIST
70848: LIST
70849: PUSH
70850: LD_INT 2
70852: NEG
70853: PUSH
70854: LD_INT 1
70856: NEG
70857: PUSH
70858: EMPTY
70859: LIST
70860: LIST
70861: PUSH
70862: LD_INT 2
70864: NEG
70865: PUSH
70866: LD_INT 2
70868: NEG
70869: PUSH
70870: EMPTY
70871: LIST
70872: LIST
70873: PUSH
70874: LD_INT 2
70876: NEG
70877: PUSH
70878: LD_INT 3
70880: NEG
70881: PUSH
70882: EMPTY
70883: LIST
70884: LIST
70885: PUSH
70886: LD_INT 2
70888: PUSH
70889: LD_INT 1
70891: NEG
70892: PUSH
70893: EMPTY
70894: LIST
70895: LIST
70896: PUSH
70897: LD_INT 3
70899: PUSH
70900: LD_INT 0
70902: PUSH
70903: EMPTY
70904: LIST
70905: LIST
70906: PUSH
70907: LD_INT 3
70909: PUSH
70910: LD_INT 1
70912: PUSH
70913: EMPTY
70914: LIST
70915: LIST
70916: PUSH
70917: LD_INT 3
70919: PUSH
70920: LD_INT 2
70922: PUSH
70923: EMPTY
70924: LIST
70925: LIST
70926: PUSH
70927: LD_INT 3
70929: PUSH
70930: LD_INT 3
70932: PUSH
70933: EMPTY
70934: LIST
70935: LIST
70936: PUSH
70937: LD_INT 2
70939: PUSH
70940: LD_INT 3
70942: PUSH
70943: EMPTY
70944: LIST
70945: LIST
70946: PUSH
70947: LD_INT 2
70949: NEG
70950: PUSH
70951: LD_INT 1
70953: PUSH
70954: EMPTY
70955: LIST
70956: LIST
70957: PUSH
70958: LD_INT 3
70960: NEG
70961: PUSH
70962: LD_INT 0
70964: PUSH
70965: EMPTY
70966: LIST
70967: LIST
70968: PUSH
70969: LD_INT 3
70971: NEG
70972: PUSH
70973: LD_INT 1
70975: NEG
70976: PUSH
70977: EMPTY
70978: LIST
70979: LIST
70980: PUSH
70981: LD_INT 3
70983: NEG
70984: PUSH
70985: LD_INT 2
70987: NEG
70988: PUSH
70989: EMPTY
70990: LIST
70991: LIST
70992: PUSH
70993: LD_INT 3
70995: NEG
70996: PUSH
70997: LD_INT 3
70999: NEG
71000: PUSH
71001: EMPTY
71002: LIST
71003: LIST
71004: PUSH
71005: EMPTY
71006: LIST
71007: LIST
71008: LIST
71009: LIST
71010: LIST
71011: LIST
71012: LIST
71013: LIST
71014: LIST
71015: LIST
71016: LIST
71017: LIST
71018: LIST
71019: LIST
71020: LIST
71021: LIST
71022: LIST
71023: LIST
71024: LIST
71025: LIST
71026: LIST
71027: LIST
71028: LIST
71029: LIST
71030: LIST
71031: LIST
71032: LIST
71033: LIST
71034: LIST
71035: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
71036: LD_ADDR_VAR 0 45
71040: PUSH
71041: LD_INT 0
71043: PUSH
71044: LD_INT 0
71046: PUSH
71047: EMPTY
71048: LIST
71049: LIST
71050: PUSH
71051: LD_INT 0
71053: PUSH
71054: LD_INT 1
71056: NEG
71057: PUSH
71058: EMPTY
71059: LIST
71060: LIST
71061: PUSH
71062: LD_INT 1
71064: PUSH
71065: LD_INT 0
71067: PUSH
71068: EMPTY
71069: LIST
71070: LIST
71071: PUSH
71072: LD_INT 1
71074: PUSH
71075: LD_INT 1
71077: PUSH
71078: EMPTY
71079: LIST
71080: LIST
71081: PUSH
71082: LD_INT 0
71084: PUSH
71085: LD_INT 1
71087: PUSH
71088: EMPTY
71089: LIST
71090: LIST
71091: PUSH
71092: LD_INT 1
71094: NEG
71095: PUSH
71096: LD_INT 0
71098: PUSH
71099: EMPTY
71100: LIST
71101: LIST
71102: PUSH
71103: LD_INT 1
71105: NEG
71106: PUSH
71107: LD_INT 1
71109: NEG
71110: PUSH
71111: EMPTY
71112: LIST
71113: LIST
71114: PUSH
71115: LD_INT 1
71117: NEG
71118: PUSH
71119: LD_INT 2
71121: NEG
71122: PUSH
71123: EMPTY
71124: LIST
71125: LIST
71126: PUSH
71127: LD_INT 0
71129: PUSH
71130: LD_INT 2
71132: NEG
71133: PUSH
71134: EMPTY
71135: LIST
71136: LIST
71137: PUSH
71138: LD_INT 1
71140: PUSH
71141: LD_INT 1
71143: NEG
71144: PUSH
71145: EMPTY
71146: LIST
71147: LIST
71148: PUSH
71149: LD_INT 2
71151: PUSH
71152: LD_INT 1
71154: PUSH
71155: EMPTY
71156: LIST
71157: LIST
71158: PUSH
71159: LD_INT 2
71161: PUSH
71162: LD_INT 2
71164: PUSH
71165: EMPTY
71166: LIST
71167: LIST
71168: PUSH
71169: LD_INT 1
71171: PUSH
71172: LD_INT 2
71174: PUSH
71175: EMPTY
71176: LIST
71177: LIST
71178: PUSH
71179: LD_INT 0
71181: PUSH
71182: LD_INT 2
71184: PUSH
71185: EMPTY
71186: LIST
71187: LIST
71188: PUSH
71189: LD_INT 1
71191: NEG
71192: PUSH
71193: LD_INT 1
71195: PUSH
71196: EMPTY
71197: LIST
71198: LIST
71199: PUSH
71200: LD_INT 2
71202: NEG
71203: PUSH
71204: LD_INT 1
71206: NEG
71207: PUSH
71208: EMPTY
71209: LIST
71210: LIST
71211: PUSH
71212: LD_INT 2
71214: NEG
71215: PUSH
71216: LD_INT 2
71218: NEG
71219: PUSH
71220: EMPTY
71221: LIST
71222: LIST
71223: PUSH
71224: LD_INT 2
71226: NEG
71227: PUSH
71228: LD_INT 3
71230: NEG
71231: PUSH
71232: EMPTY
71233: LIST
71234: LIST
71235: PUSH
71236: LD_INT 1
71238: NEG
71239: PUSH
71240: LD_INT 3
71242: NEG
71243: PUSH
71244: EMPTY
71245: LIST
71246: LIST
71247: PUSH
71248: LD_INT 0
71250: PUSH
71251: LD_INT 3
71253: NEG
71254: PUSH
71255: EMPTY
71256: LIST
71257: LIST
71258: PUSH
71259: LD_INT 1
71261: PUSH
71262: LD_INT 2
71264: NEG
71265: PUSH
71266: EMPTY
71267: LIST
71268: LIST
71269: PUSH
71270: LD_INT 3
71272: PUSH
71273: LD_INT 2
71275: PUSH
71276: EMPTY
71277: LIST
71278: LIST
71279: PUSH
71280: LD_INT 3
71282: PUSH
71283: LD_INT 3
71285: PUSH
71286: EMPTY
71287: LIST
71288: LIST
71289: PUSH
71290: LD_INT 2
71292: PUSH
71293: LD_INT 3
71295: PUSH
71296: EMPTY
71297: LIST
71298: LIST
71299: PUSH
71300: LD_INT 1
71302: PUSH
71303: LD_INT 3
71305: PUSH
71306: EMPTY
71307: LIST
71308: LIST
71309: PUSH
71310: LD_INT 0
71312: PUSH
71313: LD_INT 3
71315: PUSH
71316: EMPTY
71317: LIST
71318: LIST
71319: PUSH
71320: LD_INT 1
71322: NEG
71323: PUSH
71324: LD_INT 2
71326: PUSH
71327: EMPTY
71328: LIST
71329: LIST
71330: PUSH
71331: LD_INT 3
71333: NEG
71334: PUSH
71335: LD_INT 2
71337: NEG
71338: PUSH
71339: EMPTY
71340: LIST
71341: LIST
71342: PUSH
71343: LD_INT 3
71345: NEG
71346: PUSH
71347: LD_INT 3
71349: NEG
71350: PUSH
71351: EMPTY
71352: LIST
71353: LIST
71354: PUSH
71355: EMPTY
71356: LIST
71357: LIST
71358: LIST
71359: LIST
71360: LIST
71361: LIST
71362: LIST
71363: LIST
71364: LIST
71365: LIST
71366: LIST
71367: LIST
71368: LIST
71369: LIST
71370: LIST
71371: LIST
71372: LIST
71373: LIST
71374: LIST
71375: LIST
71376: LIST
71377: LIST
71378: LIST
71379: LIST
71380: LIST
71381: LIST
71382: LIST
71383: LIST
71384: LIST
71385: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
71386: LD_ADDR_VAR 0 46
71390: PUSH
71391: LD_INT 0
71393: PUSH
71394: LD_INT 0
71396: PUSH
71397: EMPTY
71398: LIST
71399: LIST
71400: PUSH
71401: LD_INT 0
71403: PUSH
71404: LD_INT 1
71406: NEG
71407: PUSH
71408: EMPTY
71409: LIST
71410: LIST
71411: PUSH
71412: LD_INT 1
71414: PUSH
71415: LD_INT 0
71417: PUSH
71418: EMPTY
71419: LIST
71420: LIST
71421: PUSH
71422: LD_INT 1
71424: PUSH
71425: LD_INT 1
71427: PUSH
71428: EMPTY
71429: LIST
71430: LIST
71431: PUSH
71432: LD_INT 0
71434: PUSH
71435: LD_INT 1
71437: PUSH
71438: EMPTY
71439: LIST
71440: LIST
71441: PUSH
71442: LD_INT 1
71444: NEG
71445: PUSH
71446: LD_INT 0
71448: PUSH
71449: EMPTY
71450: LIST
71451: LIST
71452: PUSH
71453: LD_INT 1
71455: NEG
71456: PUSH
71457: LD_INT 1
71459: NEG
71460: PUSH
71461: EMPTY
71462: LIST
71463: LIST
71464: PUSH
71465: LD_INT 1
71467: NEG
71468: PUSH
71469: LD_INT 2
71471: NEG
71472: PUSH
71473: EMPTY
71474: LIST
71475: LIST
71476: PUSH
71477: LD_INT 0
71479: PUSH
71480: LD_INT 2
71482: NEG
71483: PUSH
71484: EMPTY
71485: LIST
71486: LIST
71487: PUSH
71488: LD_INT 1
71490: PUSH
71491: LD_INT 1
71493: NEG
71494: PUSH
71495: EMPTY
71496: LIST
71497: LIST
71498: PUSH
71499: LD_INT 2
71501: PUSH
71502: LD_INT 0
71504: PUSH
71505: EMPTY
71506: LIST
71507: LIST
71508: PUSH
71509: LD_INT 2
71511: PUSH
71512: LD_INT 1
71514: PUSH
71515: EMPTY
71516: LIST
71517: LIST
71518: PUSH
71519: LD_INT 1
71521: PUSH
71522: LD_INT 2
71524: PUSH
71525: EMPTY
71526: LIST
71527: LIST
71528: PUSH
71529: LD_INT 0
71531: PUSH
71532: LD_INT 2
71534: PUSH
71535: EMPTY
71536: LIST
71537: LIST
71538: PUSH
71539: LD_INT 1
71541: NEG
71542: PUSH
71543: LD_INT 1
71545: PUSH
71546: EMPTY
71547: LIST
71548: LIST
71549: PUSH
71550: LD_INT 2
71552: NEG
71553: PUSH
71554: LD_INT 0
71556: PUSH
71557: EMPTY
71558: LIST
71559: LIST
71560: PUSH
71561: LD_INT 2
71563: NEG
71564: PUSH
71565: LD_INT 1
71567: NEG
71568: PUSH
71569: EMPTY
71570: LIST
71571: LIST
71572: PUSH
71573: LD_INT 1
71575: NEG
71576: PUSH
71577: LD_INT 3
71579: NEG
71580: PUSH
71581: EMPTY
71582: LIST
71583: LIST
71584: PUSH
71585: LD_INT 0
71587: PUSH
71588: LD_INT 3
71590: NEG
71591: PUSH
71592: EMPTY
71593: LIST
71594: LIST
71595: PUSH
71596: LD_INT 1
71598: PUSH
71599: LD_INT 2
71601: NEG
71602: PUSH
71603: EMPTY
71604: LIST
71605: LIST
71606: PUSH
71607: LD_INT 2
71609: PUSH
71610: LD_INT 1
71612: NEG
71613: PUSH
71614: EMPTY
71615: LIST
71616: LIST
71617: PUSH
71618: LD_INT 3
71620: PUSH
71621: LD_INT 0
71623: PUSH
71624: EMPTY
71625: LIST
71626: LIST
71627: PUSH
71628: LD_INT 3
71630: PUSH
71631: LD_INT 1
71633: PUSH
71634: EMPTY
71635: LIST
71636: LIST
71637: PUSH
71638: LD_INT 1
71640: PUSH
71641: LD_INT 3
71643: PUSH
71644: EMPTY
71645: LIST
71646: LIST
71647: PUSH
71648: LD_INT 0
71650: PUSH
71651: LD_INT 3
71653: PUSH
71654: EMPTY
71655: LIST
71656: LIST
71657: PUSH
71658: LD_INT 1
71660: NEG
71661: PUSH
71662: LD_INT 2
71664: PUSH
71665: EMPTY
71666: LIST
71667: LIST
71668: PUSH
71669: LD_INT 2
71671: NEG
71672: PUSH
71673: LD_INT 1
71675: PUSH
71676: EMPTY
71677: LIST
71678: LIST
71679: PUSH
71680: LD_INT 3
71682: NEG
71683: PUSH
71684: LD_INT 0
71686: PUSH
71687: EMPTY
71688: LIST
71689: LIST
71690: PUSH
71691: LD_INT 3
71693: NEG
71694: PUSH
71695: LD_INT 1
71697: NEG
71698: PUSH
71699: EMPTY
71700: LIST
71701: LIST
71702: PUSH
71703: EMPTY
71704: LIST
71705: LIST
71706: LIST
71707: LIST
71708: LIST
71709: LIST
71710: LIST
71711: LIST
71712: LIST
71713: LIST
71714: LIST
71715: LIST
71716: LIST
71717: LIST
71718: LIST
71719: LIST
71720: LIST
71721: LIST
71722: LIST
71723: LIST
71724: LIST
71725: LIST
71726: LIST
71727: LIST
71728: LIST
71729: LIST
71730: LIST
71731: LIST
71732: LIST
71733: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71734: LD_ADDR_VAR 0 47
71738: PUSH
71739: LD_INT 0
71741: PUSH
71742: LD_INT 0
71744: PUSH
71745: EMPTY
71746: LIST
71747: LIST
71748: PUSH
71749: LD_INT 0
71751: PUSH
71752: LD_INT 1
71754: NEG
71755: PUSH
71756: EMPTY
71757: LIST
71758: LIST
71759: PUSH
71760: LD_INT 1
71762: PUSH
71763: LD_INT 0
71765: PUSH
71766: EMPTY
71767: LIST
71768: LIST
71769: PUSH
71770: LD_INT 1
71772: PUSH
71773: LD_INT 1
71775: PUSH
71776: EMPTY
71777: LIST
71778: LIST
71779: PUSH
71780: LD_INT 0
71782: PUSH
71783: LD_INT 1
71785: PUSH
71786: EMPTY
71787: LIST
71788: LIST
71789: PUSH
71790: LD_INT 1
71792: NEG
71793: PUSH
71794: LD_INT 0
71796: PUSH
71797: EMPTY
71798: LIST
71799: LIST
71800: PUSH
71801: LD_INT 1
71803: NEG
71804: PUSH
71805: LD_INT 1
71807: NEG
71808: PUSH
71809: EMPTY
71810: LIST
71811: LIST
71812: PUSH
71813: LD_INT 1
71815: NEG
71816: PUSH
71817: LD_INT 2
71819: NEG
71820: PUSH
71821: EMPTY
71822: LIST
71823: LIST
71824: PUSH
71825: LD_INT 0
71827: PUSH
71828: LD_INT 2
71830: NEG
71831: PUSH
71832: EMPTY
71833: LIST
71834: LIST
71835: PUSH
71836: LD_INT 1
71838: PUSH
71839: LD_INT 1
71841: NEG
71842: PUSH
71843: EMPTY
71844: LIST
71845: LIST
71846: PUSH
71847: LD_INT 2
71849: NEG
71850: PUSH
71851: LD_INT 1
71853: NEG
71854: PUSH
71855: EMPTY
71856: LIST
71857: LIST
71858: PUSH
71859: LD_INT 2
71861: NEG
71862: PUSH
71863: LD_INT 2
71865: NEG
71866: PUSH
71867: EMPTY
71868: LIST
71869: LIST
71870: PUSH
71871: EMPTY
71872: LIST
71873: LIST
71874: LIST
71875: LIST
71876: LIST
71877: LIST
71878: LIST
71879: LIST
71880: LIST
71881: LIST
71882: LIST
71883: LIST
71884: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
71885: LD_ADDR_VAR 0 48
71889: PUSH
71890: LD_INT 0
71892: PUSH
71893: LD_INT 0
71895: PUSH
71896: EMPTY
71897: LIST
71898: LIST
71899: PUSH
71900: LD_INT 0
71902: PUSH
71903: LD_INT 1
71905: NEG
71906: PUSH
71907: EMPTY
71908: LIST
71909: LIST
71910: PUSH
71911: LD_INT 1
71913: PUSH
71914: LD_INT 0
71916: PUSH
71917: EMPTY
71918: LIST
71919: LIST
71920: PUSH
71921: LD_INT 1
71923: PUSH
71924: LD_INT 1
71926: PUSH
71927: EMPTY
71928: LIST
71929: LIST
71930: PUSH
71931: LD_INT 0
71933: PUSH
71934: LD_INT 1
71936: PUSH
71937: EMPTY
71938: LIST
71939: LIST
71940: PUSH
71941: LD_INT 1
71943: NEG
71944: PUSH
71945: LD_INT 0
71947: PUSH
71948: EMPTY
71949: LIST
71950: LIST
71951: PUSH
71952: LD_INT 1
71954: NEG
71955: PUSH
71956: LD_INT 1
71958: NEG
71959: PUSH
71960: EMPTY
71961: LIST
71962: LIST
71963: PUSH
71964: LD_INT 1
71966: NEG
71967: PUSH
71968: LD_INT 2
71970: NEG
71971: PUSH
71972: EMPTY
71973: LIST
71974: LIST
71975: PUSH
71976: LD_INT 0
71978: PUSH
71979: LD_INT 2
71981: NEG
71982: PUSH
71983: EMPTY
71984: LIST
71985: LIST
71986: PUSH
71987: LD_INT 1
71989: PUSH
71990: LD_INT 1
71992: NEG
71993: PUSH
71994: EMPTY
71995: LIST
71996: LIST
71997: PUSH
71998: LD_INT 2
72000: PUSH
72001: LD_INT 0
72003: PUSH
72004: EMPTY
72005: LIST
72006: LIST
72007: PUSH
72008: LD_INT 2
72010: PUSH
72011: LD_INT 1
72013: PUSH
72014: EMPTY
72015: LIST
72016: LIST
72017: PUSH
72018: EMPTY
72019: LIST
72020: LIST
72021: LIST
72022: LIST
72023: LIST
72024: LIST
72025: LIST
72026: LIST
72027: LIST
72028: LIST
72029: LIST
72030: LIST
72031: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
72032: LD_ADDR_VAR 0 49
72036: PUSH
72037: LD_INT 0
72039: PUSH
72040: LD_INT 0
72042: PUSH
72043: EMPTY
72044: LIST
72045: LIST
72046: PUSH
72047: LD_INT 0
72049: PUSH
72050: LD_INT 1
72052: NEG
72053: PUSH
72054: EMPTY
72055: LIST
72056: LIST
72057: PUSH
72058: LD_INT 1
72060: PUSH
72061: LD_INT 0
72063: PUSH
72064: EMPTY
72065: LIST
72066: LIST
72067: PUSH
72068: LD_INT 1
72070: PUSH
72071: LD_INT 1
72073: PUSH
72074: EMPTY
72075: LIST
72076: LIST
72077: PUSH
72078: LD_INT 0
72080: PUSH
72081: LD_INT 1
72083: PUSH
72084: EMPTY
72085: LIST
72086: LIST
72087: PUSH
72088: LD_INT 1
72090: NEG
72091: PUSH
72092: LD_INT 0
72094: PUSH
72095: EMPTY
72096: LIST
72097: LIST
72098: PUSH
72099: LD_INT 1
72101: NEG
72102: PUSH
72103: LD_INT 1
72105: NEG
72106: PUSH
72107: EMPTY
72108: LIST
72109: LIST
72110: PUSH
72111: LD_INT 1
72113: PUSH
72114: LD_INT 1
72116: NEG
72117: PUSH
72118: EMPTY
72119: LIST
72120: LIST
72121: PUSH
72122: LD_INT 2
72124: PUSH
72125: LD_INT 0
72127: PUSH
72128: EMPTY
72129: LIST
72130: LIST
72131: PUSH
72132: LD_INT 2
72134: PUSH
72135: LD_INT 1
72137: PUSH
72138: EMPTY
72139: LIST
72140: LIST
72141: PUSH
72142: LD_INT 2
72144: PUSH
72145: LD_INT 2
72147: PUSH
72148: EMPTY
72149: LIST
72150: LIST
72151: PUSH
72152: LD_INT 1
72154: PUSH
72155: LD_INT 2
72157: PUSH
72158: EMPTY
72159: LIST
72160: LIST
72161: PUSH
72162: EMPTY
72163: LIST
72164: LIST
72165: LIST
72166: LIST
72167: LIST
72168: LIST
72169: LIST
72170: LIST
72171: LIST
72172: LIST
72173: LIST
72174: LIST
72175: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
72176: LD_ADDR_VAR 0 50
72180: PUSH
72181: LD_INT 0
72183: PUSH
72184: LD_INT 0
72186: PUSH
72187: EMPTY
72188: LIST
72189: LIST
72190: PUSH
72191: LD_INT 0
72193: PUSH
72194: LD_INT 1
72196: NEG
72197: PUSH
72198: EMPTY
72199: LIST
72200: LIST
72201: PUSH
72202: LD_INT 1
72204: PUSH
72205: LD_INT 0
72207: PUSH
72208: EMPTY
72209: LIST
72210: LIST
72211: PUSH
72212: LD_INT 1
72214: PUSH
72215: LD_INT 1
72217: PUSH
72218: EMPTY
72219: LIST
72220: LIST
72221: PUSH
72222: LD_INT 0
72224: PUSH
72225: LD_INT 1
72227: PUSH
72228: EMPTY
72229: LIST
72230: LIST
72231: PUSH
72232: LD_INT 1
72234: NEG
72235: PUSH
72236: LD_INT 0
72238: PUSH
72239: EMPTY
72240: LIST
72241: LIST
72242: PUSH
72243: LD_INT 1
72245: NEG
72246: PUSH
72247: LD_INT 1
72249: NEG
72250: PUSH
72251: EMPTY
72252: LIST
72253: LIST
72254: PUSH
72255: LD_INT 2
72257: PUSH
72258: LD_INT 1
72260: PUSH
72261: EMPTY
72262: LIST
72263: LIST
72264: PUSH
72265: LD_INT 2
72267: PUSH
72268: LD_INT 2
72270: PUSH
72271: EMPTY
72272: LIST
72273: LIST
72274: PUSH
72275: LD_INT 1
72277: PUSH
72278: LD_INT 2
72280: PUSH
72281: EMPTY
72282: LIST
72283: LIST
72284: PUSH
72285: LD_INT 0
72287: PUSH
72288: LD_INT 2
72290: PUSH
72291: EMPTY
72292: LIST
72293: LIST
72294: PUSH
72295: LD_INT 1
72297: NEG
72298: PUSH
72299: LD_INT 1
72301: PUSH
72302: EMPTY
72303: LIST
72304: LIST
72305: PUSH
72306: EMPTY
72307: LIST
72308: LIST
72309: LIST
72310: LIST
72311: LIST
72312: LIST
72313: LIST
72314: LIST
72315: LIST
72316: LIST
72317: LIST
72318: LIST
72319: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
72320: LD_ADDR_VAR 0 51
72324: PUSH
72325: LD_INT 0
72327: PUSH
72328: LD_INT 0
72330: PUSH
72331: EMPTY
72332: LIST
72333: LIST
72334: PUSH
72335: LD_INT 0
72337: PUSH
72338: LD_INT 1
72340: NEG
72341: PUSH
72342: EMPTY
72343: LIST
72344: LIST
72345: PUSH
72346: LD_INT 1
72348: PUSH
72349: LD_INT 0
72351: PUSH
72352: EMPTY
72353: LIST
72354: LIST
72355: PUSH
72356: LD_INT 1
72358: PUSH
72359: LD_INT 1
72361: PUSH
72362: EMPTY
72363: LIST
72364: LIST
72365: PUSH
72366: LD_INT 0
72368: PUSH
72369: LD_INT 1
72371: PUSH
72372: EMPTY
72373: LIST
72374: LIST
72375: PUSH
72376: LD_INT 1
72378: NEG
72379: PUSH
72380: LD_INT 0
72382: PUSH
72383: EMPTY
72384: LIST
72385: LIST
72386: PUSH
72387: LD_INT 1
72389: NEG
72390: PUSH
72391: LD_INT 1
72393: NEG
72394: PUSH
72395: EMPTY
72396: LIST
72397: LIST
72398: PUSH
72399: LD_INT 1
72401: PUSH
72402: LD_INT 2
72404: PUSH
72405: EMPTY
72406: LIST
72407: LIST
72408: PUSH
72409: LD_INT 0
72411: PUSH
72412: LD_INT 2
72414: PUSH
72415: EMPTY
72416: LIST
72417: LIST
72418: PUSH
72419: LD_INT 1
72421: NEG
72422: PUSH
72423: LD_INT 1
72425: PUSH
72426: EMPTY
72427: LIST
72428: LIST
72429: PUSH
72430: LD_INT 2
72432: NEG
72433: PUSH
72434: LD_INT 0
72436: PUSH
72437: EMPTY
72438: LIST
72439: LIST
72440: PUSH
72441: LD_INT 2
72443: NEG
72444: PUSH
72445: LD_INT 1
72447: NEG
72448: PUSH
72449: EMPTY
72450: LIST
72451: LIST
72452: PUSH
72453: EMPTY
72454: LIST
72455: LIST
72456: LIST
72457: LIST
72458: LIST
72459: LIST
72460: LIST
72461: LIST
72462: LIST
72463: LIST
72464: LIST
72465: LIST
72466: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72467: LD_ADDR_VAR 0 52
72471: PUSH
72472: LD_INT 0
72474: PUSH
72475: LD_INT 0
72477: PUSH
72478: EMPTY
72479: LIST
72480: LIST
72481: PUSH
72482: LD_INT 0
72484: PUSH
72485: LD_INT 1
72487: NEG
72488: PUSH
72489: EMPTY
72490: LIST
72491: LIST
72492: PUSH
72493: LD_INT 1
72495: PUSH
72496: LD_INT 0
72498: PUSH
72499: EMPTY
72500: LIST
72501: LIST
72502: PUSH
72503: LD_INT 1
72505: PUSH
72506: LD_INT 1
72508: PUSH
72509: EMPTY
72510: LIST
72511: LIST
72512: PUSH
72513: LD_INT 0
72515: PUSH
72516: LD_INT 1
72518: PUSH
72519: EMPTY
72520: LIST
72521: LIST
72522: PUSH
72523: LD_INT 1
72525: NEG
72526: PUSH
72527: LD_INT 0
72529: PUSH
72530: EMPTY
72531: LIST
72532: LIST
72533: PUSH
72534: LD_INT 1
72536: NEG
72537: PUSH
72538: LD_INT 1
72540: NEG
72541: PUSH
72542: EMPTY
72543: LIST
72544: LIST
72545: PUSH
72546: LD_INT 1
72548: NEG
72549: PUSH
72550: LD_INT 2
72552: NEG
72553: PUSH
72554: EMPTY
72555: LIST
72556: LIST
72557: PUSH
72558: LD_INT 1
72560: NEG
72561: PUSH
72562: LD_INT 1
72564: PUSH
72565: EMPTY
72566: LIST
72567: LIST
72568: PUSH
72569: LD_INT 2
72571: NEG
72572: PUSH
72573: LD_INT 0
72575: PUSH
72576: EMPTY
72577: LIST
72578: LIST
72579: PUSH
72580: LD_INT 2
72582: NEG
72583: PUSH
72584: LD_INT 1
72586: NEG
72587: PUSH
72588: EMPTY
72589: LIST
72590: LIST
72591: PUSH
72592: LD_INT 2
72594: NEG
72595: PUSH
72596: LD_INT 2
72598: NEG
72599: PUSH
72600: EMPTY
72601: LIST
72602: LIST
72603: PUSH
72604: EMPTY
72605: LIST
72606: LIST
72607: LIST
72608: LIST
72609: LIST
72610: LIST
72611: LIST
72612: LIST
72613: LIST
72614: LIST
72615: LIST
72616: LIST
72617: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72618: LD_ADDR_VAR 0 53
72622: PUSH
72623: LD_INT 0
72625: PUSH
72626: LD_INT 0
72628: PUSH
72629: EMPTY
72630: LIST
72631: LIST
72632: PUSH
72633: LD_INT 0
72635: PUSH
72636: LD_INT 1
72638: NEG
72639: PUSH
72640: EMPTY
72641: LIST
72642: LIST
72643: PUSH
72644: LD_INT 1
72646: PUSH
72647: LD_INT 0
72649: PUSH
72650: EMPTY
72651: LIST
72652: LIST
72653: PUSH
72654: LD_INT 1
72656: PUSH
72657: LD_INT 1
72659: PUSH
72660: EMPTY
72661: LIST
72662: LIST
72663: PUSH
72664: LD_INT 0
72666: PUSH
72667: LD_INT 1
72669: PUSH
72670: EMPTY
72671: LIST
72672: LIST
72673: PUSH
72674: LD_INT 1
72676: NEG
72677: PUSH
72678: LD_INT 0
72680: PUSH
72681: EMPTY
72682: LIST
72683: LIST
72684: PUSH
72685: LD_INT 1
72687: NEG
72688: PUSH
72689: LD_INT 1
72691: NEG
72692: PUSH
72693: EMPTY
72694: LIST
72695: LIST
72696: PUSH
72697: LD_INT 1
72699: NEG
72700: PUSH
72701: LD_INT 2
72703: NEG
72704: PUSH
72705: EMPTY
72706: LIST
72707: LIST
72708: PUSH
72709: LD_INT 0
72711: PUSH
72712: LD_INT 2
72714: NEG
72715: PUSH
72716: EMPTY
72717: LIST
72718: LIST
72719: PUSH
72720: LD_INT 1
72722: PUSH
72723: LD_INT 1
72725: NEG
72726: PUSH
72727: EMPTY
72728: LIST
72729: LIST
72730: PUSH
72731: LD_INT 2
72733: PUSH
72734: LD_INT 0
72736: PUSH
72737: EMPTY
72738: LIST
72739: LIST
72740: PUSH
72741: LD_INT 2
72743: PUSH
72744: LD_INT 1
72746: PUSH
72747: EMPTY
72748: LIST
72749: LIST
72750: PUSH
72751: LD_INT 2
72753: PUSH
72754: LD_INT 2
72756: PUSH
72757: EMPTY
72758: LIST
72759: LIST
72760: PUSH
72761: LD_INT 1
72763: PUSH
72764: LD_INT 2
72766: PUSH
72767: EMPTY
72768: LIST
72769: LIST
72770: PUSH
72771: LD_INT 0
72773: PUSH
72774: LD_INT 2
72776: PUSH
72777: EMPTY
72778: LIST
72779: LIST
72780: PUSH
72781: LD_INT 1
72783: NEG
72784: PUSH
72785: LD_INT 1
72787: PUSH
72788: EMPTY
72789: LIST
72790: LIST
72791: PUSH
72792: LD_INT 2
72794: NEG
72795: PUSH
72796: LD_INT 0
72798: PUSH
72799: EMPTY
72800: LIST
72801: LIST
72802: PUSH
72803: LD_INT 2
72805: NEG
72806: PUSH
72807: LD_INT 1
72809: NEG
72810: PUSH
72811: EMPTY
72812: LIST
72813: LIST
72814: PUSH
72815: LD_INT 2
72817: NEG
72818: PUSH
72819: LD_INT 2
72821: NEG
72822: PUSH
72823: EMPTY
72824: LIST
72825: LIST
72826: PUSH
72827: EMPTY
72828: LIST
72829: LIST
72830: LIST
72831: LIST
72832: LIST
72833: LIST
72834: LIST
72835: LIST
72836: LIST
72837: LIST
72838: LIST
72839: LIST
72840: LIST
72841: LIST
72842: LIST
72843: LIST
72844: LIST
72845: LIST
72846: LIST
72847: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72848: LD_ADDR_VAR 0 54
72852: PUSH
72853: LD_INT 0
72855: PUSH
72856: LD_INT 0
72858: PUSH
72859: EMPTY
72860: LIST
72861: LIST
72862: PUSH
72863: LD_INT 0
72865: PUSH
72866: LD_INT 1
72868: NEG
72869: PUSH
72870: EMPTY
72871: LIST
72872: LIST
72873: PUSH
72874: LD_INT 1
72876: PUSH
72877: LD_INT 0
72879: PUSH
72880: EMPTY
72881: LIST
72882: LIST
72883: PUSH
72884: LD_INT 1
72886: PUSH
72887: LD_INT 1
72889: PUSH
72890: EMPTY
72891: LIST
72892: LIST
72893: PUSH
72894: LD_INT 0
72896: PUSH
72897: LD_INT 1
72899: PUSH
72900: EMPTY
72901: LIST
72902: LIST
72903: PUSH
72904: LD_INT 1
72906: NEG
72907: PUSH
72908: LD_INT 0
72910: PUSH
72911: EMPTY
72912: LIST
72913: LIST
72914: PUSH
72915: LD_INT 1
72917: NEG
72918: PUSH
72919: LD_INT 1
72921: NEG
72922: PUSH
72923: EMPTY
72924: LIST
72925: LIST
72926: PUSH
72927: LD_INT 1
72929: NEG
72930: PUSH
72931: LD_INT 2
72933: NEG
72934: PUSH
72935: EMPTY
72936: LIST
72937: LIST
72938: PUSH
72939: LD_INT 0
72941: PUSH
72942: LD_INT 2
72944: NEG
72945: PUSH
72946: EMPTY
72947: LIST
72948: LIST
72949: PUSH
72950: LD_INT 1
72952: PUSH
72953: LD_INT 1
72955: NEG
72956: PUSH
72957: EMPTY
72958: LIST
72959: LIST
72960: PUSH
72961: LD_INT 2
72963: PUSH
72964: LD_INT 0
72966: PUSH
72967: EMPTY
72968: LIST
72969: LIST
72970: PUSH
72971: LD_INT 2
72973: PUSH
72974: LD_INT 1
72976: PUSH
72977: EMPTY
72978: LIST
72979: LIST
72980: PUSH
72981: LD_INT 2
72983: PUSH
72984: LD_INT 2
72986: PUSH
72987: EMPTY
72988: LIST
72989: LIST
72990: PUSH
72991: LD_INT 1
72993: PUSH
72994: LD_INT 2
72996: PUSH
72997: EMPTY
72998: LIST
72999: LIST
73000: PUSH
73001: LD_INT 0
73003: PUSH
73004: LD_INT 2
73006: PUSH
73007: EMPTY
73008: LIST
73009: LIST
73010: PUSH
73011: LD_INT 1
73013: NEG
73014: PUSH
73015: LD_INT 1
73017: PUSH
73018: EMPTY
73019: LIST
73020: LIST
73021: PUSH
73022: LD_INT 2
73024: NEG
73025: PUSH
73026: LD_INT 0
73028: PUSH
73029: EMPTY
73030: LIST
73031: LIST
73032: PUSH
73033: LD_INT 2
73035: NEG
73036: PUSH
73037: LD_INT 1
73039: NEG
73040: PUSH
73041: EMPTY
73042: LIST
73043: LIST
73044: PUSH
73045: LD_INT 2
73047: NEG
73048: PUSH
73049: LD_INT 2
73051: NEG
73052: PUSH
73053: EMPTY
73054: LIST
73055: LIST
73056: PUSH
73057: EMPTY
73058: LIST
73059: LIST
73060: LIST
73061: LIST
73062: LIST
73063: LIST
73064: LIST
73065: LIST
73066: LIST
73067: LIST
73068: LIST
73069: LIST
73070: LIST
73071: LIST
73072: LIST
73073: LIST
73074: LIST
73075: LIST
73076: LIST
73077: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73078: LD_ADDR_VAR 0 55
73082: PUSH
73083: LD_INT 0
73085: PUSH
73086: LD_INT 0
73088: PUSH
73089: EMPTY
73090: LIST
73091: LIST
73092: PUSH
73093: LD_INT 0
73095: PUSH
73096: LD_INT 1
73098: NEG
73099: PUSH
73100: EMPTY
73101: LIST
73102: LIST
73103: PUSH
73104: LD_INT 1
73106: PUSH
73107: LD_INT 0
73109: PUSH
73110: EMPTY
73111: LIST
73112: LIST
73113: PUSH
73114: LD_INT 1
73116: PUSH
73117: LD_INT 1
73119: PUSH
73120: EMPTY
73121: LIST
73122: LIST
73123: PUSH
73124: LD_INT 0
73126: PUSH
73127: LD_INT 1
73129: PUSH
73130: EMPTY
73131: LIST
73132: LIST
73133: PUSH
73134: LD_INT 1
73136: NEG
73137: PUSH
73138: LD_INT 0
73140: PUSH
73141: EMPTY
73142: LIST
73143: LIST
73144: PUSH
73145: LD_INT 1
73147: NEG
73148: PUSH
73149: LD_INT 1
73151: NEG
73152: PUSH
73153: EMPTY
73154: LIST
73155: LIST
73156: PUSH
73157: LD_INT 1
73159: NEG
73160: PUSH
73161: LD_INT 2
73163: NEG
73164: PUSH
73165: EMPTY
73166: LIST
73167: LIST
73168: PUSH
73169: LD_INT 0
73171: PUSH
73172: LD_INT 2
73174: NEG
73175: PUSH
73176: EMPTY
73177: LIST
73178: LIST
73179: PUSH
73180: LD_INT 1
73182: PUSH
73183: LD_INT 1
73185: NEG
73186: PUSH
73187: EMPTY
73188: LIST
73189: LIST
73190: PUSH
73191: LD_INT 2
73193: PUSH
73194: LD_INT 0
73196: PUSH
73197: EMPTY
73198: LIST
73199: LIST
73200: PUSH
73201: LD_INT 2
73203: PUSH
73204: LD_INT 1
73206: PUSH
73207: EMPTY
73208: LIST
73209: LIST
73210: PUSH
73211: LD_INT 2
73213: PUSH
73214: LD_INT 2
73216: PUSH
73217: EMPTY
73218: LIST
73219: LIST
73220: PUSH
73221: LD_INT 1
73223: PUSH
73224: LD_INT 2
73226: PUSH
73227: EMPTY
73228: LIST
73229: LIST
73230: PUSH
73231: LD_INT 0
73233: PUSH
73234: LD_INT 2
73236: PUSH
73237: EMPTY
73238: LIST
73239: LIST
73240: PUSH
73241: LD_INT 1
73243: NEG
73244: PUSH
73245: LD_INT 1
73247: PUSH
73248: EMPTY
73249: LIST
73250: LIST
73251: PUSH
73252: LD_INT 2
73254: NEG
73255: PUSH
73256: LD_INT 0
73258: PUSH
73259: EMPTY
73260: LIST
73261: LIST
73262: PUSH
73263: LD_INT 2
73265: NEG
73266: PUSH
73267: LD_INT 1
73269: NEG
73270: PUSH
73271: EMPTY
73272: LIST
73273: LIST
73274: PUSH
73275: LD_INT 2
73277: NEG
73278: PUSH
73279: LD_INT 2
73281: NEG
73282: PUSH
73283: EMPTY
73284: LIST
73285: LIST
73286: PUSH
73287: EMPTY
73288: LIST
73289: LIST
73290: LIST
73291: LIST
73292: LIST
73293: LIST
73294: LIST
73295: LIST
73296: LIST
73297: LIST
73298: LIST
73299: LIST
73300: LIST
73301: LIST
73302: LIST
73303: LIST
73304: LIST
73305: LIST
73306: LIST
73307: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73308: LD_ADDR_VAR 0 56
73312: PUSH
73313: LD_INT 0
73315: PUSH
73316: LD_INT 0
73318: PUSH
73319: EMPTY
73320: LIST
73321: LIST
73322: PUSH
73323: LD_INT 0
73325: PUSH
73326: LD_INT 1
73328: NEG
73329: PUSH
73330: EMPTY
73331: LIST
73332: LIST
73333: PUSH
73334: LD_INT 1
73336: PUSH
73337: LD_INT 0
73339: PUSH
73340: EMPTY
73341: LIST
73342: LIST
73343: PUSH
73344: LD_INT 1
73346: PUSH
73347: LD_INT 1
73349: PUSH
73350: EMPTY
73351: LIST
73352: LIST
73353: PUSH
73354: LD_INT 0
73356: PUSH
73357: LD_INT 1
73359: PUSH
73360: EMPTY
73361: LIST
73362: LIST
73363: PUSH
73364: LD_INT 1
73366: NEG
73367: PUSH
73368: LD_INT 0
73370: PUSH
73371: EMPTY
73372: LIST
73373: LIST
73374: PUSH
73375: LD_INT 1
73377: NEG
73378: PUSH
73379: LD_INT 1
73381: NEG
73382: PUSH
73383: EMPTY
73384: LIST
73385: LIST
73386: PUSH
73387: LD_INT 1
73389: NEG
73390: PUSH
73391: LD_INT 2
73393: NEG
73394: PUSH
73395: EMPTY
73396: LIST
73397: LIST
73398: PUSH
73399: LD_INT 0
73401: PUSH
73402: LD_INT 2
73404: NEG
73405: PUSH
73406: EMPTY
73407: LIST
73408: LIST
73409: PUSH
73410: LD_INT 1
73412: PUSH
73413: LD_INT 1
73415: NEG
73416: PUSH
73417: EMPTY
73418: LIST
73419: LIST
73420: PUSH
73421: LD_INT 2
73423: PUSH
73424: LD_INT 0
73426: PUSH
73427: EMPTY
73428: LIST
73429: LIST
73430: PUSH
73431: LD_INT 2
73433: PUSH
73434: LD_INT 1
73436: PUSH
73437: EMPTY
73438: LIST
73439: LIST
73440: PUSH
73441: LD_INT 2
73443: PUSH
73444: LD_INT 2
73446: PUSH
73447: EMPTY
73448: LIST
73449: LIST
73450: PUSH
73451: LD_INT 1
73453: PUSH
73454: LD_INT 2
73456: PUSH
73457: EMPTY
73458: LIST
73459: LIST
73460: PUSH
73461: LD_INT 0
73463: PUSH
73464: LD_INT 2
73466: PUSH
73467: EMPTY
73468: LIST
73469: LIST
73470: PUSH
73471: LD_INT 1
73473: NEG
73474: PUSH
73475: LD_INT 1
73477: PUSH
73478: EMPTY
73479: LIST
73480: LIST
73481: PUSH
73482: LD_INT 2
73484: NEG
73485: PUSH
73486: LD_INT 0
73488: PUSH
73489: EMPTY
73490: LIST
73491: LIST
73492: PUSH
73493: LD_INT 2
73495: NEG
73496: PUSH
73497: LD_INT 1
73499: NEG
73500: PUSH
73501: EMPTY
73502: LIST
73503: LIST
73504: PUSH
73505: LD_INT 2
73507: NEG
73508: PUSH
73509: LD_INT 2
73511: NEG
73512: PUSH
73513: EMPTY
73514: LIST
73515: LIST
73516: PUSH
73517: EMPTY
73518: LIST
73519: LIST
73520: LIST
73521: LIST
73522: LIST
73523: LIST
73524: LIST
73525: LIST
73526: LIST
73527: LIST
73528: LIST
73529: LIST
73530: LIST
73531: LIST
73532: LIST
73533: LIST
73534: LIST
73535: LIST
73536: LIST
73537: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73538: LD_ADDR_VAR 0 57
73542: PUSH
73543: LD_INT 0
73545: PUSH
73546: LD_INT 0
73548: PUSH
73549: EMPTY
73550: LIST
73551: LIST
73552: PUSH
73553: LD_INT 0
73555: PUSH
73556: LD_INT 1
73558: NEG
73559: PUSH
73560: EMPTY
73561: LIST
73562: LIST
73563: PUSH
73564: LD_INT 1
73566: PUSH
73567: LD_INT 0
73569: PUSH
73570: EMPTY
73571: LIST
73572: LIST
73573: PUSH
73574: LD_INT 1
73576: PUSH
73577: LD_INT 1
73579: PUSH
73580: EMPTY
73581: LIST
73582: LIST
73583: PUSH
73584: LD_INT 0
73586: PUSH
73587: LD_INT 1
73589: PUSH
73590: EMPTY
73591: LIST
73592: LIST
73593: PUSH
73594: LD_INT 1
73596: NEG
73597: PUSH
73598: LD_INT 0
73600: PUSH
73601: EMPTY
73602: LIST
73603: LIST
73604: PUSH
73605: LD_INT 1
73607: NEG
73608: PUSH
73609: LD_INT 1
73611: NEG
73612: PUSH
73613: EMPTY
73614: LIST
73615: LIST
73616: PUSH
73617: LD_INT 1
73619: NEG
73620: PUSH
73621: LD_INT 2
73623: NEG
73624: PUSH
73625: EMPTY
73626: LIST
73627: LIST
73628: PUSH
73629: LD_INT 0
73631: PUSH
73632: LD_INT 2
73634: NEG
73635: PUSH
73636: EMPTY
73637: LIST
73638: LIST
73639: PUSH
73640: LD_INT 1
73642: PUSH
73643: LD_INT 1
73645: NEG
73646: PUSH
73647: EMPTY
73648: LIST
73649: LIST
73650: PUSH
73651: LD_INT 2
73653: PUSH
73654: LD_INT 0
73656: PUSH
73657: EMPTY
73658: LIST
73659: LIST
73660: PUSH
73661: LD_INT 2
73663: PUSH
73664: LD_INT 1
73666: PUSH
73667: EMPTY
73668: LIST
73669: LIST
73670: PUSH
73671: LD_INT 2
73673: PUSH
73674: LD_INT 2
73676: PUSH
73677: EMPTY
73678: LIST
73679: LIST
73680: PUSH
73681: LD_INT 1
73683: PUSH
73684: LD_INT 2
73686: PUSH
73687: EMPTY
73688: LIST
73689: LIST
73690: PUSH
73691: LD_INT 0
73693: PUSH
73694: LD_INT 2
73696: PUSH
73697: EMPTY
73698: LIST
73699: LIST
73700: PUSH
73701: LD_INT 1
73703: NEG
73704: PUSH
73705: LD_INT 1
73707: PUSH
73708: EMPTY
73709: LIST
73710: LIST
73711: PUSH
73712: LD_INT 2
73714: NEG
73715: PUSH
73716: LD_INT 0
73718: PUSH
73719: EMPTY
73720: LIST
73721: LIST
73722: PUSH
73723: LD_INT 2
73725: NEG
73726: PUSH
73727: LD_INT 1
73729: NEG
73730: PUSH
73731: EMPTY
73732: LIST
73733: LIST
73734: PUSH
73735: LD_INT 2
73737: NEG
73738: PUSH
73739: LD_INT 2
73741: NEG
73742: PUSH
73743: EMPTY
73744: LIST
73745: LIST
73746: PUSH
73747: EMPTY
73748: LIST
73749: LIST
73750: LIST
73751: LIST
73752: LIST
73753: LIST
73754: LIST
73755: LIST
73756: LIST
73757: LIST
73758: LIST
73759: LIST
73760: LIST
73761: LIST
73762: LIST
73763: LIST
73764: LIST
73765: LIST
73766: LIST
73767: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73768: LD_ADDR_VAR 0 58
73772: PUSH
73773: LD_INT 0
73775: PUSH
73776: LD_INT 0
73778: PUSH
73779: EMPTY
73780: LIST
73781: LIST
73782: PUSH
73783: LD_INT 0
73785: PUSH
73786: LD_INT 1
73788: NEG
73789: PUSH
73790: EMPTY
73791: LIST
73792: LIST
73793: PUSH
73794: LD_INT 1
73796: PUSH
73797: LD_INT 0
73799: PUSH
73800: EMPTY
73801: LIST
73802: LIST
73803: PUSH
73804: LD_INT 1
73806: PUSH
73807: LD_INT 1
73809: PUSH
73810: EMPTY
73811: LIST
73812: LIST
73813: PUSH
73814: LD_INT 0
73816: PUSH
73817: LD_INT 1
73819: PUSH
73820: EMPTY
73821: LIST
73822: LIST
73823: PUSH
73824: LD_INT 1
73826: NEG
73827: PUSH
73828: LD_INT 0
73830: PUSH
73831: EMPTY
73832: LIST
73833: LIST
73834: PUSH
73835: LD_INT 1
73837: NEG
73838: PUSH
73839: LD_INT 1
73841: NEG
73842: PUSH
73843: EMPTY
73844: LIST
73845: LIST
73846: PUSH
73847: LD_INT 1
73849: NEG
73850: PUSH
73851: LD_INT 2
73853: NEG
73854: PUSH
73855: EMPTY
73856: LIST
73857: LIST
73858: PUSH
73859: LD_INT 0
73861: PUSH
73862: LD_INT 2
73864: NEG
73865: PUSH
73866: EMPTY
73867: LIST
73868: LIST
73869: PUSH
73870: LD_INT 1
73872: PUSH
73873: LD_INT 1
73875: NEG
73876: PUSH
73877: EMPTY
73878: LIST
73879: LIST
73880: PUSH
73881: LD_INT 2
73883: PUSH
73884: LD_INT 0
73886: PUSH
73887: EMPTY
73888: LIST
73889: LIST
73890: PUSH
73891: LD_INT 2
73893: PUSH
73894: LD_INT 1
73896: PUSH
73897: EMPTY
73898: LIST
73899: LIST
73900: PUSH
73901: LD_INT 2
73903: PUSH
73904: LD_INT 2
73906: PUSH
73907: EMPTY
73908: LIST
73909: LIST
73910: PUSH
73911: LD_INT 1
73913: PUSH
73914: LD_INT 2
73916: PUSH
73917: EMPTY
73918: LIST
73919: LIST
73920: PUSH
73921: LD_INT 0
73923: PUSH
73924: LD_INT 2
73926: PUSH
73927: EMPTY
73928: LIST
73929: LIST
73930: PUSH
73931: LD_INT 1
73933: NEG
73934: PUSH
73935: LD_INT 1
73937: PUSH
73938: EMPTY
73939: LIST
73940: LIST
73941: PUSH
73942: LD_INT 2
73944: NEG
73945: PUSH
73946: LD_INT 0
73948: PUSH
73949: EMPTY
73950: LIST
73951: LIST
73952: PUSH
73953: LD_INT 2
73955: NEG
73956: PUSH
73957: LD_INT 1
73959: NEG
73960: PUSH
73961: EMPTY
73962: LIST
73963: LIST
73964: PUSH
73965: LD_INT 2
73967: NEG
73968: PUSH
73969: LD_INT 2
73971: NEG
73972: PUSH
73973: EMPTY
73974: LIST
73975: LIST
73976: PUSH
73977: EMPTY
73978: LIST
73979: LIST
73980: LIST
73981: LIST
73982: LIST
73983: LIST
73984: LIST
73985: LIST
73986: LIST
73987: LIST
73988: LIST
73989: LIST
73990: LIST
73991: LIST
73992: LIST
73993: LIST
73994: LIST
73995: LIST
73996: LIST
73997: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
73998: LD_ADDR_VAR 0 59
74002: PUSH
74003: LD_INT 0
74005: PUSH
74006: LD_INT 0
74008: PUSH
74009: EMPTY
74010: LIST
74011: LIST
74012: PUSH
74013: LD_INT 0
74015: PUSH
74016: LD_INT 1
74018: NEG
74019: PUSH
74020: EMPTY
74021: LIST
74022: LIST
74023: PUSH
74024: LD_INT 1
74026: PUSH
74027: LD_INT 0
74029: PUSH
74030: EMPTY
74031: LIST
74032: LIST
74033: PUSH
74034: LD_INT 1
74036: PUSH
74037: LD_INT 1
74039: PUSH
74040: EMPTY
74041: LIST
74042: LIST
74043: PUSH
74044: LD_INT 0
74046: PUSH
74047: LD_INT 1
74049: PUSH
74050: EMPTY
74051: LIST
74052: LIST
74053: PUSH
74054: LD_INT 1
74056: NEG
74057: PUSH
74058: LD_INT 0
74060: PUSH
74061: EMPTY
74062: LIST
74063: LIST
74064: PUSH
74065: LD_INT 1
74067: NEG
74068: PUSH
74069: LD_INT 1
74071: NEG
74072: PUSH
74073: EMPTY
74074: LIST
74075: LIST
74076: PUSH
74077: EMPTY
74078: LIST
74079: LIST
74080: LIST
74081: LIST
74082: LIST
74083: LIST
74084: LIST
74085: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74086: LD_ADDR_VAR 0 60
74090: PUSH
74091: LD_INT 0
74093: PUSH
74094: LD_INT 0
74096: PUSH
74097: EMPTY
74098: LIST
74099: LIST
74100: PUSH
74101: LD_INT 0
74103: PUSH
74104: LD_INT 1
74106: NEG
74107: PUSH
74108: EMPTY
74109: LIST
74110: LIST
74111: PUSH
74112: LD_INT 1
74114: PUSH
74115: LD_INT 0
74117: PUSH
74118: EMPTY
74119: LIST
74120: LIST
74121: PUSH
74122: LD_INT 1
74124: PUSH
74125: LD_INT 1
74127: PUSH
74128: EMPTY
74129: LIST
74130: LIST
74131: PUSH
74132: LD_INT 0
74134: PUSH
74135: LD_INT 1
74137: PUSH
74138: EMPTY
74139: LIST
74140: LIST
74141: PUSH
74142: LD_INT 1
74144: NEG
74145: PUSH
74146: LD_INT 0
74148: PUSH
74149: EMPTY
74150: LIST
74151: LIST
74152: PUSH
74153: LD_INT 1
74155: NEG
74156: PUSH
74157: LD_INT 1
74159: NEG
74160: PUSH
74161: EMPTY
74162: LIST
74163: LIST
74164: PUSH
74165: EMPTY
74166: LIST
74167: LIST
74168: LIST
74169: LIST
74170: LIST
74171: LIST
74172: LIST
74173: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74174: LD_ADDR_VAR 0 61
74178: PUSH
74179: LD_INT 0
74181: PUSH
74182: LD_INT 0
74184: PUSH
74185: EMPTY
74186: LIST
74187: LIST
74188: PUSH
74189: LD_INT 0
74191: PUSH
74192: LD_INT 1
74194: NEG
74195: PUSH
74196: EMPTY
74197: LIST
74198: LIST
74199: PUSH
74200: LD_INT 1
74202: PUSH
74203: LD_INT 0
74205: PUSH
74206: EMPTY
74207: LIST
74208: LIST
74209: PUSH
74210: LD_INT 1
74212: PUSH
74213: LD_INT 1
74215: PUSH
74216: EMPTY
74217: LIST
74218: LIST
74219: PUSH
74220: LD_INT 0
74222: PUSH
74223: LD_INT 1
74225: PUSH
74226: EMPTY
74227: LIST
74228: LIST
74229: PUSH
74230: LD_INT 1
74232: NEG
74233: PUSH
74234: LD_INT 0
74236: PUSH
74237: EMPTY
74238: LIST
74239: LIST
74240: PUSH
74241: LD_INT 1
74243: NEG
74244: PUSH
74245: LD_INT 1
74247: NEG
74248: PUSH
74249: EMPTY
74250: LIST
74251: LIST
74252: PUSH
74253: EMPTY
74254: LIST
74255: LIST
74256: LIST
74257: LIST
74258: LIST
74259: LIST
74260: LIST
74261: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74262: LD_ADDR_VAR 0 62
74266: PUSH
74267: LD_INT 0
74269: PUSH
74270: LD_INT 0
74272: PUSH
74273: EMPTY
74274: LIST
74275: LIST
74276: PUSH
74277: LD_INT 0
74279: PUSH
74280: LD_INT 1
74282: NEG
74283: PUSH
74284: EMPTY
74285: LIST
74286: LIST
74287: PUSH
74288: LD_INT 1
74290: PUSH
74291: LD_INT 0
74293: PUSH
74294: EMPTY
74295: LIST
74296: LIST
74297: PUSH
74298: LD_INT 1
74300: PUSH
74301: LD_INT 1
74303: PUSH
74304: EMPTY
74305: LIST
74306: LIST
74307: PUSH
74308: LD_INT 0
74310: PUSH
74311: LD_INT 1
74313: PUSH
74314: EMPTY
74315: LIST
74316: LIST
74317: PUSH
74318: LD_INT 1
74320: NEG
74321: PUSH
74322: LD_INT 0
74324: PUSH
74325: EMPTY
74326: LIST
74327: LIST
74328: PUSH
74329: LD_INT 1
74331: NEG
74332: PUSH
74333: LD_INT 1
74335: NEG
74336: PUSH
74337: EMPTY
74338: LIST
74339: LIST
74340: PUSH
74341: EMPTY
74342: LIST
74343: LIST
74344: LIST
74345: LIST
74346: LIST
74347: LIST
74348: LIST
74349: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74350: LD_ADDR_VAR 0 63
74354: PUSH
74355: LD_INT 0
74357: PUSH
74358: LD_INT 0
74360: PUSH
74361: EMPTY
74362: LIST
74363: LIST
74364: PUSH
74365: LD_INT 0
74367: PUSH
74368: LD_INT 1
74370: NEG
74371: PUSH
74372: EMPTY
74373: LIST
74374: LIST
74375: PUSH
74376: LD_INT 1
74378: PUSH
74379: LD_INT 0
74381: PUSH
74382: EMPTY
74383: LIST
74384: LIST
74385: PUSH
74386: LD_INT 1
74388: PUSH
74389: LD_INT 1
74391: PUSH
74392: EMPTY
74393: LIST
74394: LIST
74395: PUSH
74396: LD_INT 0
74398: PUSH
74399: LD_INT 1
74401: PUSH
74402: EMPTY
74403: LIST
74404: LIST
74405: PUSH
74406: LD_INT 1
74408: NEG
74409: PUSH
74410: LD_INT 0
74412: PUSH
74413: EMPTY
74414: LIST
74415: LIST
74416: PUSH
74417: LD_INT 1
74419: NEG
74420: PUSH
74421: LD_INT 1
74423: NEG
74424: PUSH
74425: EMPTY
74426: LIST
74427: LIST
74428: PUSH
74429: EMPTY
74430: LIST
74431: LIST
74432: LIST
74433: LIST
74434: LIST
74435: LIST
74436: LIST
74437: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74438: LD_ADDR_VAR 0 64
74442: PUSH
74443: LD_INT 0
74445: PUSH
74446: LD_INT 0
74448: PUSH
74449: EMPTY
74450: LIST
74451: LIST
74452: PUSH
74453: LD_INT 0
74455: PUSH
74456: LD_INT 1
74458: NEG
74459: PUSH
74460: EMPTY
74461: LIST
74462: LIST
74463: PUSH
74464: LD_INT 1
74466: PUSH
74467: LD_INT 0
74469: PUSH
74470: EMPTY
74471: LIST
74472: LIST
74473: PUSH
74474: LD_INT 1
74476: PUSH
74477: LD_INT 1
74479: PUSH
74480: EMPTY
74481: LIST
74482: LIST
74483: PUSH
74484: LD_INT 0
74486: PUSH
74487: LD_INT 1
74489: PUSH
74490: EMPTY
74491: LIST
74492: LIST
74493: PUSH
74494: LD_INT 1
74496: NEG
74497: PUSH
74498: LD_INT 0
74500: PUSH
74501: EMPTY
74502: LIST
74503: LIST
74504: PUSH
74505: LD_INT 1
74507: NEG
74508: PUSH
74509: LD_INT 1
74511: NEG
74512: PUSH
74513: EMPTY
74514: LIST
74515: LIST
74516: PUSH
74517: EMPTY
74518: LIST
74519: LIST
74520: LIST
74521: LIST
74522: LIST
74523: LIST
74524: LIST
74525: ST_TO_ADDR
// end ; 1 :
74526: GO 80423
74528: LD_INT 1
74530: DOUBLE
74531: EQUAL
74532: IFTRUE 74536
74534: GO 77159
74536: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
74537: LD_ADDR_VAR 0 11
74541: PUSH
74542: LD_INT 1
74544: NEG
74545: PUSH
74546: LD_INT 3
74548: NEG
74549: PUSH
74550: EMPTY
74551: LIST
74552: LIST
74553: PUSH
74554: LD_INT 0
74556: PUSH
74557: LD_INT 3
74559: NEG
74560: PUSH
74561: EMPTY
74562: LIST
74563: LIST
74564: PUSH
74565: LD_INT 1
74567: PUSH
74568: LD_INT 2
74570: NEG
74571: PUSH
74572: EMPTY
74573: LIST
74574: LIST
74575: PUSH
74576: EMPTY
74577: LIST
74578: LIST
74579: LIST
74580: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
74581: LD_ADDR_VAR 0 12
74585: PUSH
74586: LD_INT 2
74588: PUSH
74589: LD_INT 1
74591: NEG
74592: PUSH
74593: EMPTY
74594: LIST
74595: LIST
74596: PUSH
74597: LD_INT 3
74599: PUSH
74600: LD_INT 0
74602: PUSH
74603: EMPTY
74604: LIST
74605: LIST
74606: PUSH
74607: LD_INT 3
74609: PUSH
74610: LD_INT 1
74612: PUSH
74613: EMPTY
74614: LIST
74615: LIST
74616: PUSH
74617: EMPTY
74618: LIST
74619: LIST
74620: LIST
74621: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
74622: LD_ADDR_VAR 0 13
74626: PUSH
74627: LD_INT 3
74629: PUSH
74630: LD_INT 2
74632: PUSH
74633: EMPTY
74634: LIST
74635: LIST
74636: PUSH
74637: LD_INT 3
74639: PUSH
74640: LD_INT 3
74642: PUSH
74643: EMPTY
74644: LIST
74645: LIST
74646: PUSH
74647: LD_INT 2
74649: PUSH
74650: LD_INT 3
74652: PUSH
74653: EMPTY
74654: LIST
74655: LIST
74656: PUSH
74657: EMPTY
74658: LIST
74659: LIST
74660: LIST
74661: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
74662: LD_ADDR_VAR 0 14
74666: PUSH
74667: LD_INT 1
74669: PUSH
74670: LD_INT 3
74672: PUSH
74673: EMPTY
74674: LIST
74675: LIST
74676: PUSH
74677: LD_INT 0
74679: PUSH
74680: LD_INT 3
74682: PUSH
74683: EMPTY
74684: LIST
74685: LIST
74686: PUSH
74687: LD_INT 1
74689: NEG
74690: PUSH
74691: LD_INT 2
74693: PUSH
74694: EMPTY
74695: LIST
74696: LIST
74697: PUSH
74698: EMPTY
74699: LIST
74700: LIST
74701: LIST
74702: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74703: LD_ADDR_VAR 0 15
74707: PUSH
74708: LD_INT 2
74710: NEG
74711: PUSH
74712: LD_INT 1
74714: PUSH
74715: EMPTY
74716: LIST
74717: LIST
74718: PUSH
74719: LD_INT 3
74721: NEG
74722: PUSH
74723: LD_INT 0
74725: PUSH
74726: EMPTY
74727: LIST
74728: LIST
74729: PUSH
74730: LD_INT 3
74732: NEG
74733: PUSH
74734: LD_INT 1
74736: NEG
74737: PUSH
74738: EMPTY
74739: LIST
74740: LIST
74741: PUSH
74742: EMPTY
74743: LIST
74744: LIST
74745: LIST
74746: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74747: LD_ADDR_VAR 0 16
74751: PUSH
74752: LD_INT 2
74754: NEG
74755: PUSH
74756: LD_INT 3
74758: NEG
74759: PUSH
74760: EMPTY
74761: LIST
74762: LIST
74763: PUSH
74764: LD_INT 3
74766: NEG
74767: PUSH
74768: LD_INT 2
74770: NEG
74771: PUSH
74772: EMPTY
74773: LIST
74774: LIST
74775: PUSH
74776: LD_INT 3
74778: NEG
74779: PUSH
74780: LD_INT 3
74782: NEG
74783: PUSH
74784: EMPTY
74785: LIST
74786: LIST
74787: PUSH
74788: EMPTY
74789: LIST
74790: LIST
74791: LIST
74792: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
74793: LD_ADDR_VAR 0 17
74797: PUSH
74798: LD_INT 1
74800: NEG
74801: PUSH
74802: LD_INT 3
74804: NEG
74805: PUSH
74806: EMPTY
74807: LIST
74808: LIST
74809: PUSH
74810: LD_INT 0
74812: PUSH
74813: LD_INT 3
74815: NEG
74816: PUSH
74817: EMPTY
74818: LIST
74819: LIST
74820: PUSH
74821: LD_INT 1
74823: PUSH
74824: LD_INT 2
74826: NEG
74827: PUSH
74828: EMPTY
74829: LIST
74830: LIST
74831: PUSH
74832: EMPTY
74833: LIST
74834: LIST
74835: LIST
74836: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
74837: LD_ADDR_VAR 0 18
74841: PUSH
74842: LD_INT 2
74844: PUSH
74845: LD_INT 1
74847: NEG
74848: PUSH
74849: EMPTY
74850: LIST
74851: LIST
74852: PUSH
74853: LD_INT 3
74855: PUSH
74856: LD_INT 0
74858: PUSH
74859: EMPTY
74860: LIST
74861: LIST
74862: PUSH
74863: LD_INT 3
74865: PUSH
74866: LD_INT 1
74868: PUSH
74869: EMPTY
74870: LIST
74871: LIST
74872: PUSH
74873: EMPTY
74874: LIST
74875: LIST
74876: LIST
74877: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
74878: LD_ADDR_VAR 0 19
74882: PUSH
74883: LD_INT 3
74885: PUSH
74886: LD_INT 2
74888: PUSH
74889: EMPTY
74890: LIST
74891: LIST
74892: PUSH
74893: LD_INT 3
74895: PUSH
74896: LD_INT 3
74898: PUSH
74899: EMPTY
74900: LIST
74901: LIST
74902: PUSH
74903: LD_INT 2
74905: PUSH
74906: LD_INT 3
74908: PUSH
74909: EMPTY
74910: LIST
74911: LIST
74912: PUSH
74913: EMPTY
74914: LIST
74915: LIST
74916: LIST
74917: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
74918: LD_ADDR_VAR 0 20
74922: PUSH
74923: LD_INT 1
74925: PUSH
74926: LD_INT 3
74928: PUSH
74929: EMPTY
74930: LIST
74931: LIST
74932: PUSH
74933: LD_INT 0
74935: PUSH
74936: LD_INT 3
74938: PUSH
74939: EMPTY
74940: LIST
74941: LIST
74942: PUSH
74943: LD_INT 1
74945: NEG
74946: PUSH
74947: LD_INT 2
74949: PUSH
74950: EMPTY
74951: LIST
74952: LIST
74953: PUSH
74954: EMPTY
74955: LIST
74956: LIST
74957: LIST
74958: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74959: LD_ADDR_VAR 0 21
74963: PUSH
74964: LD_INT 2
74966: NEG
74967: PUSH
74968: LD_INT 1
74970: PUSH
74971: EMPTY
74972: LIST
74973: LIST
74974: PUSH
74975: LD_INT 3
74977: NEG
74978: PUSH
74979: LD_INT 0
74981: PUSH
74982: EMPTY
74983: LIST
74984: LIST
74985: PUSH
74986: LD_INT 3
74988: NEG
74989: PUSH
74990: LD_INT 1
74992: NEG
74993: PUSH
74994: EMPTY
74995: LIST
74996: LIST
74997: PUSH
74998: EMPTY
74999: LIST
75000: LIST
75001: LIST
75002: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75003: LD_ADDR_VAR 0 22
75007: PUSH
75008: LD_INT 2
75010: NEG
75011: PUSH
75012: LD_INT 3
75014: NEG
75015: PUSH
75016: EMPTY
75017: LIST
75018: LIST
75019: PUSH
75020: LD_INT 3
75022: NEG
75023: PUSH
75024: LD_INT 2
75026: NEG
75027: PUSH
75028: EMPTY
75029: LIST
75030: LIST
75031: PUSH
75032: LD_INT 3
75034: NEG
75035: PUSH
75036: LD_INT 3
75038: NEG
75039: PUSH
75040: EMPTY
75041: LIST
75042: LIST
75043: PUSH
75044: EMPTY
75045: LIST
75046: LIST
75047: LIST
75048: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
75049: LD_ADDR_VAR 0 23
75053: PUSH
75054: LD_INT 0
75056: PUSH
75057: LD_INT 3
75059: NEG
75060: PUSH
75061: EMPTY
75062: LIST
75063: LIST
75064: PUSH
75065: LD_INT 1
75067: NEG
75068: PUSH
75069: LD_INT 4
75071: NEG
75072: PUSH
75073: EMPTY
75074: LIST
75075: LIST
75076: PUSH
75077: LD_INT 1
75079: PUSH
75080: LD_INT 3
75082: NEG
75083: PUSH
75084: EMPTY
75085: LIST
75086: LIST
75087: PUSH
75088: EMPTY
75089: LIST
75090: LIST
75091: LIST
75092: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
75093: LD_ADDR_VAR 0 24
75097: PUSH
75098: LD_INT 3
75100: PUSH
75101: LD_INT 0
75103: PUSH
75104: EMPTY
75105: LIST
75106: LIST
75107: PUSH
75108: LD_INT 3
75110: PUSH
75111: LD_INT 1
75113: NEG
75114: PUSH
75115: EMPTY
75116: LIST
75117: LIST
75118: PUSH
75119: LD_INT 4
75121: PUSH
75122: LD_INT 1
75124: PUSH
75125: EMPTY
75126: LIST
75127: LIST
75128: PUSH
75129: EMPTY
75130: LIST
75131: LIST
75132: LIST
75133: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
75134: LD_ADDR_VAR 0 25
75138: PUSH
75139: LD_INT 3
75141: PUSH
75142: LD_INT 3
75144: PUSH
75145: EMPTY
75146: LIST
75147: LIST
75148: PUSH
75149: LD_INT 4
75151: PUSH
75152: LD_INT 3
75154: PUSH
75155: EMPTY
75156: LIST
75157: LIST
75158: PUSH
75159: LD_INT 3
75161: PUSH
75162: LD_INT 4
75164: PUSH
75165: EMPTY
75166: LIST
75167: LIST
75168: PUSH
75169: EMPTY
75170: LIST
75171: LIST
75172: LIST
75173: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
75174: LD_ADDR_VAR 0 26
75178: PUSH
75179: LD_INT 0
75181: PUSH
75182: LD_INT 3
75184: PUSH
75185: EMPTY
75186: LIST
75187: LIST
75188: PUSH
75189: LD_INT 1
75191: PUSH
75192: LD_INT 4
75194: PUSH
75195: EMPTY
75196: LIST
75197: LIST
75198: PUSH
75199: LD_INT 1
75201: NEG
75202: PUSH
75203: LD_INT 3
75205: PUSH
75206: EMPTY
75207: LIST
75208: LIST
75209: PUSH
75210: EMPTY
75211: LIST
75212: LIST
75213: LIST
75214: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
75215: LD_ADDR_VAR 0 27
75219: PUSH
75220: LD_INT 3
75222: NEG
75223: PUSH
75224: LD_INT 0
75226: PUSH
75227: EMPTY
75228: LIST
75229: LIST
75230: PUSH
75231: LD_INT 3
75233: NEG
75234: PUSH
75235: LD_INT 1
75237: PUSH
75238: EMPTY
75239: LIST
75240: LIST
75241: PUSH
75242: LD_INT 4
75244: NEG
75245: PUSH
75246: LD_INT 1
75248: NEG
75249: PUSH
75250: EMPTY
75251: LIST
75252: LIST
75253: PUSH
75254: EMPTY
75255: LIST
75256: LIST
75257: LIST
75258: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
75259: LD_ADDR_VAR 0 28
75263: PUSH
75264: LD_INT 3
75266: NEG
75267: PUSH
75268: LD_INT 3
75270: NEG
75271: PUSH
75272: EMPTY
75273: LIST
75274: LIST
75275: PUSH
75276: LD_INT 3
75278: NEG
75279: PUSH
75280: LD_INT 4
75282: NEG
75283: PUSH
75284: EMPTY
75285: LIST
75286: LIST
75287: PUSH
75288: LD_INT 4
75290: NEG
75291: PUSH
75292: LD_INT 3
75294: NEG
75295: PUSH
75296: EMPTY
75297: LIST
75298: LIST
75299: PUSH
75300: EMPTY
75301: LIST
75302: LIST
75303: LIST
75304: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
75305: LD_ADDR_VAR 0 29
75309: PUSH
75310: LD_INT 1
75312: NEG
75313: PUSH
75314: LD_INT 3
75316: NEG
75317: PUSH
75318: EMPTY
75319: LIST
75320: LIST
75321: PUSH
75322: LD_INT 0
75324: PUSH
75325: LD_INT 3
75327: NEG
75328: PUSH
75329: EMPTY
75330: LIST
75331: LIST
75332: PUSH
75333: LD_INT 1
75335: PUSH
75336: LD_INT 2
75338: NEG
75339: PUSH
75340: EMPTY
75341: LIST
75342: LIST
75343: PUSH
75344: LD_INT 1
75346: NEG
75347: PUSH
75348: LD_INT 4
75350: NEG
75351: PUSH
75352: EMPTY
75353: LIST
75354: LIST
75355: PUSH
75356: LD_INT 0
75358: PUSH
75359: LD_INT 4
75361: NEG
75362: PUSH
75363: EMPTY
75364: LIST
75365: LIST
75366: PUSH
75367: LD_INT 1
75369: PUSH
75370: LD_INT 3
75372: NEG
75373: PUSH
75374: EMPTY
75375: LIST
75376: LIST
75377: PUSH
75378: LD_INT 1
75380: NEG
75381: PUSH
75382: LD_INT 5
75384: NEG
75385: PUSH
75386: EMPTY
75387: LIST
75388: LIST
75389: PUSH
75390: LD_INT 0
75392: PUSH
75393: LD_INT 5
75395: NEG
75396: PUSH
75397: EMPTY
75398: LIST
75399: LIST
75400: PUSH
75401: LD_INT 1
75403: PUSH
75404: LD_INT 4
75406: NEG
75407: PUSH
75408: EMPTY
75409: LIST
75410: LIST
75411: PUSH
75412: LD_INT 1
75414: NEG
75415: PUSH
75416: LD_INT 6
75418: NEG
75419: PUSH
75420: EMPTY
75421: LIST
75422: LIST
75423: PUSH
75424: LD_INT 0
75426: PUSH
75427: LD_INT 6
75429: NEG
75430: PUSH
75431: EMPTY
75432: LIST
75433: LIST
75434: PUSH
75435: LD_INT 1
75437: PUSH
75438: LD_INT 5
75440: NEG
75441: PUSH
75442: EMPTY
75443: LIST
75444: LIST
75445: PUSH
75446: EMPTY
75447: LIST
75448: LIST
75449: LIST
75450: LIST
75451: LIST
75452: LIST
75453: LIST
75454: LIST
75455: LIST
75456: LIST
75457: LIST
75458: LIST
75459: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
75460: LD_ADDR_VAR 0 30
75464: PUSH
75465: LD_INT 2
75467: PUSH
75468: LD_INT 1
75470: NEG
75471: PUSH
75472: EMPTY
75473: LIST
75474: LIST
75475: PUSH
75476: LD_INT 3
75478: PUSH
75479: LD_INT 0
75481: PUSH
75482: EMPTY
75483: LIST
75484: LIST
75485: PUSH
75486: LD_INT 3
75488: PUSH
75489: LD_INT 1
75491: PUSH
75492: EMPTY
75493: LIST
75494: LIST
75495: PUSH
75496: LD_INT 3
75498: PUSH
75499: LD_INT 1
75501: NEG
75502: PUSH
75503: EMPTY
75504: LIST
75505: LIST
75506: PUSH
75507: LD_INT 4
75509: PUSH
75510: LD_INT 0
75512: PUSH
75513: EMPTY
75514: LIST
75515: LIST
75516: PUSH
75517: LD_INT 4
75519: PUSH
75520: LD_INT 1
75522: PUSH
75523: EMPTY
75524: LIST
75525: LIST
75526: PUSH
75527: LD_INT 4
75529: PUSH
75530: LD_INT 1
75532: NEG
75533: PUSH
75534: EMPTY
75535: LIST
75536: LIST
75537: PUSH
75538: LD_INT 5
75540: PUSH
75541: LD_INT 0
75543: PUSH
75544: EMPTY
75545: LIST
75546: LIST
75547: PUSH
75548: LD_INT 5
75550: PUSH
75551: LD_INT 1
75553: PUSH
75554: EMPTY
75555: LIST
75556: LIST
75557: PUSH
75558: LD_INT 5
75560: PUSH
75561: LD_INT 1
75563: NEG
75564: PUSH
75565: EMPTY
75566: LIST
75567: LIST
75568: PUSH
75569: LD_INT 6
75571: PUSH
75572: LD_INT 0
75574: PUSH
75575: EMPTY
75576: LIST
75577: LIST
75578: PUSH
75579: LD_INT 6
75581: PUSH
75582: LD_INT 1
75584: PUSH
75585: EMPTY
75586: LIST
75587: LIST
75588: PUSH
75589: EMPTY
75590: LIST
75591: LIST
75592: LIST
75593: LIST
75594: LIST
75595: LIST
75596: LIST
75597: LIST
75598: LIST
75599: LIST
75600: LIST
75601: LIST
75602: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
75603: LD_ADDR_VAR 0 31
75607: PUSH
75608: LD_INT 3
75610: PUSH
75611: LD_INT 2
75613: PUSH
75614: EMPTY
75615: LIST
75616: LIST
75617: PUSH
75618: LD_INT 3
75620: PUSH
75621: LD_INT 3
75623: PUSH
75624: EMPTY
75625: LIST
75626: LIST
75627: PUSH
75628: LD_INT 2
75630: PUSH
75631: LD_INT 3
75633: PUSH
75634: EMPTY
75635: LIST
75636: LIST
75637: PUSH
75638: LD_INT 4
75640: PUSH
75641: LD_INT 3
75643: PUSH
75644: EMPTY
75645: LIST
75646: LIST
75647: PUSH
75648: LD_INT 4
75650: PUSH
75651: LD_INT 4
75653: PUSH
75654: EMPTY
75655: LIST
75656: LIST
75657: PUSH
75658: LD_INT 3
75660: PUSH
75661: LD_INT 4
75663: PUSH
75664: EMPTY
75665: LIST
75666: LIST
75667: PUSH
75668: LD_INT 5
75670: PUSH
75671: LD_INT 4
75673: PUSH
75674: EMPTY
75675: LIST
75676: LIST
75677: PUSH
75678: LD_INT 5
75680: PUSH
75681: LD_INT 5
75683: PUSH
75684: EMPTY
75685: LIST
75686: LIST
75687: PUSH
75688: LD_INT 4
75690: PUSH
75691: LD_INT 5
75693: PUSH
75694: EMPTY
75695: LIST
75696: LIST
75697: PUSH
75698: LD_INT 6
75700: PUSH
75701: LD_INT 5
75703: PUSH
75704: EMPTY
75705: LIST
75706: LIST
75707: PUSH
75708: LD_INT 6
75710: PUSH
75711: LD_INT 6
75713: PUSH
75714: EMPTY
75715: LIST
75716: LIST
75717: PUSH
75718: LD_INT 5
75720: PUSH
75721: LD_INT 6
75723: PUSH
75724: EMPTY
75725: LIST
75726: LIST
75727: PUSH
75728: EMPTY
75729: LIST
75730: LIST
75731: LIST
75732: LIST
75733: LIST
75734: LIST
75735: LIST
75736: LIST
75737: LIST
75738: LIST
75739: LIST
75740: LIST
75741: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
75742: LD_ADDR_VAR 0 32
75746: PUSH
75747: LD_INT 1
75749: PUSH
75750: LD_INT 3
75752: PUSH
75753: EMPTY
75754: LIST
75755: LIST
75756: PUSH
75757: LD_INT 0
75759: PUSH
75760: LD_INT 3
75762: PUSH
75763: EMPTY
75764: LIST
75765: LIST
75766: PUSH
75767: LD_INT 1
75769: NEG
75770: PUSH
75771: LD_INT 2
75773: PUSH
75774: EMPTY
75775: LIST
75776: LIST
75777: PUSH
75778: LD_INT 1
75780: PUSH
75781: LD_INT 4
75783: PUSH
75784: EMPTY
75785: LIST
75786: LIST
75787: PUSH
75788: LD_INT 0
75790: PUSH
75791: LD_INT 4
75793: PUSH
75794: EMPTY
75795: LIST
75796: LIST
75797: PUSH
75798: LD_INT 1
75800: NEG
75801: PUSH
75802: LD_INT 3
75804: PUSH
75805: EMPTY
75806: LIST
75807: LIST
75808: PUSH
75809: LD_INT 1
75811: PUSH
75812: LD_INT 5
75814: PUSH
75815: EMPTY
75816: LIST
75817: LIST
75818: PUSH
75819: LD_INT 0
75821: PUSH
75822: LD_INT 5
75824: PUSH
75825: EMPTY
75826: LIST
75827: LIST
75828: PUSH
75829: LD_INT 1
75831: NEG
75832: PUSH
75833: LD_INT 4
75835: PUSH
75836: EMPTY
75837: LIST
75838: LIST
75839: PUSH
75840: LD_INT 1
75842: PUSH
75843: LD_INT 6
75845: PUSH
75846: EMPTY
75847: LIST
75848: LIST
75849: PUSH
75850: LD_INT 0
75852: PUSH
75853: LD_INT 6
75855: PUSH
75856: EMPTY
75857: LIST
75858: LIST
75859: PUSH
75860: LD_INT 1
75862: NEG
75863: PUSH
75864: LD_INT 5
75866: PUSH
75867: EMPTY
75868: LIST
75869: LIST
75870: PUSH
75871: EMPTY
75872: LIST
75873: LIST
75874: LIST
75875: LIST
75876: LIST
75877: LIST
75878: LIST
75879: LIST
75880: LIST
75881: LIST
75882: LIST
75883: LIST
75884: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
75885: LD_ADDR_VAR 0 33
75889: PUSH
75890: LD_INT 2
75892: NEG
75893: PUSH
75894: LD_INT 1
75896: PUSH
75897: EMPTY
75898: LIST
75899: LIST
75900: PUSH
75901: LD_INT 3
75903: NEG
75904: PUSH
75905: LD_INT 0
75907: PUSH
75908: EMPTY
75909: LIST
75910: LIST
75911: PUSH
75912: LD_INT 3
75914: NEG
75915: PUSH
75916: LD_INT 1
75918: NEG
75919: PUSH
75920: EMPTY
75921: LIST
75922: LIST
75923: PUSH
75924: LD_INT 3
75926: NEG
75927: PUSH
75928: LD_INT 1
75930: PUSH
75931: EMPTY
75932: LIST
75933: LIST
75934: PUSH
75935: LD_INT 4
75937: NEG
75938: PUSH
75939: LD_INT 0
75941: PUSH
75942: EMPTY
75943: LIST
75944: LIST
75945: PUSH
75946: LD_INT 4
75948: NEG
75949: PUSH
75950: LD_INT 1
75952: NEG
75953: PUSH
75954: EMPTY
75955: LIST
75956: LIST
75957: PUSH
75958: LD_INT 4
75960: NEG
75961: PUSH
75962: LD_INT 1
75964: PUSH
75965: EMPTY
75966: LIST
75967: LIST
75968: PUSH
75969: LD_INT 5
75971: NEG
75972: PUSH
75973: LD_INT 0
75975: PUSH
75976: EMPTY
75977: LIST
75978: LIST
75979: PUSH
75980: LD_INT 5
75982: NEG
75983: PUSH
75984: LD_INT 1
75986: NEG
75987: PUSH
75988: EMPTY
75989: LIST
75990: LIST
75991: PUSH
75992: LD_INT 5
75994: NEG
75995: PUSH
75996: LD_INT 1
75998: PUSH
75999: EMPTY
76000: LIST
76001: LIST
76002: PUSH
76003: LD_INT 6
76005: NEG
76006: PUSH
76007: LD_INT 0
76009: PUSH
76010: EMPTY
76011: LIST
76012: LIST
76013: PUSH
76014: LD_INT 6
76016: NEG
76017: PUSH
76018: LD_INT 1
76020: NEG
76021: PUSH
76022: EMPTY
76023: LIST
76024: LIST
76025: PUSH
76026: EMPTY
76027: LIST
76028: LIST
76029: LIST
76030: LIST
76031: LIST
76032: LIST
76033: LIST
76034: LIST
76035: LIST
76036: LIST
76037: LIST
76038: LIST
76039: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
76040: LD_ADDR_VAR 0 34
76044: PUSH
76045: LD_INT 2
76047: NEG
76048: PUSH
76049: LD_INT 3
76051: NEG
76052: PUSH
76053: EMPTY
76054: LIST
76055: LIST
76056: PUSH
76057: LD_INT 3
76059: NEG
76060: PUSH
76061: LD_INT 2
76063: NEG
76064: PUSH
76065: EMPTY
76066: LIST
76067: LIST
76068: PUSH
76069: LD_INT 3
76071: NEG
76072: PUSH
76073: LD_INT 3
76075: NEG
76076: PUSH
76077: EMPTY
76078: LIST
76079: LIST
76080: PUSH
76081: LD_INT 3
76083: NEG
76084: PUSH
76085: LD_INT 4
76087: NEG
76088: PUSH
76089: EMPTY
76090: LIST
76091: LIST
76092: PUSH
76093: LD_INT 4
76095: NEG
76096: PUSH
76097: LD_INT 3
76099: NEG
76100: PUSH
76101: EMPTY
76102: LIST
76103: LIST
76104: PUSH
76105: LD_INT 4
76107: NEG
76108: PUSH
76109: LD_INT 4
76111: NEG
76112: PUSH
76113: EMPTY
76114: LIST
76115: LIST
76116: PUSH
76117: LD_INT 4
76119: NEG
76120: PUSH
76121: LD_INT 5
76123: NEG
76124: PUSH
76125: EMPTY
76126: LIST
76127: LIST
76128: PUSH
76129: LD_INT 5
76131: NEG
76132: PUSH
76133: LD_INT 4
76135: NEG
76136: PUSH
76137: EMPTY
76138: LIST
76139: LIST
76140: PUSH
76141: LD_INT 5
76143: NEG
76144: PUSH
76145: LD_INT 5
76147: NEG
76148: PUSH
76149: EMPTY
76150: LIST
76151: LIST
76152: PUSH
76153: LD_INT 5
76155: NEG
76156: PUSH
76157: LD_INT 6
76159: NEG
76160: PUSH
76161: EMPTY
76162: LIST
76163: LIST
76164: PUSH
76165: LD_INT 6
76167: NEG
76168: PUSH
76169: LD_INT 5
76171: NEG
76172: PUSH
76173: EMPTY
76174: LIST
76175: LIST
76176: PUSH
76177: LD_INT 6
76179: NEG
76180: PUSH
76181: LD_INT 6
76183: NEG
76184: PUSH
76185: EMPTY
76186: LIST
76187: LIST
76188: PUSH
76189: EMPTY
76190: LIST
76191: LIST
76192: LIST
76193: LIST
76194: LIST
76195: LIST
76196: LIST
76197: LIST
76198: LIST
76199: LIST
76200: LIST
76201: LIST
76202: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
76203: LD_ADDR_VAR 0 41
76207: PUSH
76208: LD_INT 0
76210: PUSH
76211: LD_INT 2
76213: NEG
76214: PUSH
76215: EMPTY
76216: LIST
76217: LIST
76218: PUSH
76219: LD_INT 1
76221: NEG
76222: PUSH
76223: LD_INT 3
76225: NEG
76226: PUSH
76227: EMPTY
76228: LIST
76229: LIST
76230: PUSH
76231: LD_INT 1
76233: PUSH
76234: LD_INT 2
76236: NEG
76237: PUSH
76238: EMPTY
76239: LIST
76240: LIST
76241: PUSH
76242: EMPTY
76243: LIST
76244: LIST
76245: LIST
76246: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
76247: LD_ADDR_VAR 0 42
76251: PUSH
76252: LD_INT 2
76254: PUSH
76255: LD_INT 0
76257: PUSH
76258: EMPTY
76259: LIST
76260: LIST
76261: PUSH
76262: LD_INT 2
76264: PUSH
76265: LD_INT 1
76267: NEG
76268: PUSH
76269: EMPTY
76270: LIST
76271: LIST
76272: PUSH
76273: LD_INT 3
76275: PUSH
76276: LD_INT 1
76278: PUSH
76279: EMPTY
76280: LIST
76281: LIST
76282: PUSH
76283: EMPTY
76284: LIST
76285: LIST
76286: LIST
76287: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
76288: LD_ADDR_VAR 0 43
76292: PUSH
76293: LD_INT 2
76295: PUSH
76296: LD_INT 2
76298: PUSH
76299: EMPTY
76300: LIST
76301: LIST
76302: PUSH
76303: LD_INT 3
76305: PUSH
76306: LD_INT 2
76308: PUSH
76309: EMPTY
76310: LIST
76311: LIST
76312: PUSH
76313: LD_INT 2
76315: PUSH
76316: LD_INT 3
76318: PUSH
76319: EMPTY
76320: LIST
76321: LIST
76322: PUSH
76323: EMPTY
76324: LIST
76325: LIST
76326: LIST
76327: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
76328: LD_ADDR_VAR 0 44
76332: PUSH
76333: LD_INT 0
76335: PUSH
76336: LD_INT 2
76338: PUSH
76339: EMPTY
76340: LIST
76341: LIST
76342: PUSH
76343: LD_INT 1
76345: PUSH
76346: LD_INT 3
76348: PUSH
76349: EMPTY
76350: LIST
76351: LIST
76352: PUSH
76353: LD_INT 1
76355: NEG
76356: PUSH
76357: LD_INT 2
76359: PUSH
76360: EMPTY
76361: LIST
76362: LIST
76363: PUSH
76364: EMPTY
76365: LIST
76366: LIST
76367: LIST
76368: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
76369: LD_ADDR_VAR 0 45
76373: PUSH
76374: LD_INT 2
76376: NEG
76377: PUSH
76378: LD_INT 0
76380: PUSH
76381: EMPTY
76382: LIST
76383: LIST
76384: PUSH
76385: LD_INT 2
76387: NEG
76388: PUSH
76389: LD_INT 1
76391: PUSH
76392: EMPTY
76393: LIST
76394: LIST
76395: PUSH
76396: LD_INT 3
76398: NEG
76399: PUSH
76400: LD_INT 1
76402: NEG
76403: PUSH
76404: EMPTY
76405: LIST
76406: LIST
76407: PUSH
76408: EMPTY
76409: LIST
76410: LIST
76411: LIST
76412: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
76413: LD_ADDR_VAR 0 46
76417: PUSH
76418: LD_INT 2
76420: NEG
76421: PUSH
76422: LD_INT 2
76424: NEG
76425: PUSH
76426: EMPTY
76427: LIST
76428: LIST
76429: PUSH
76430: LD_INT 2
76432: NEG
76433: PUSH
76434: LD_INT 3
76436: NEG
76437: PUSH
76438: EMPTY
76439: LIST
76440: LIST
76441: PUSH
76442: LD_INT 3
76444: NEG
76445: PUSH
76446: LD_INT 2
76448: NEG
76449: PUSH
76450: EMPTY
76451: LIST
76452: LIST
76453: PUSH
76454: EMPTY
76455: LIST
76456: LIST
76457: LIST
76458: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
76459: LD_ADDR_VAR 0 47
76463: PUSH
76464: LD_INT 2
76466: NEG
76467: PUSH
76468: LD_INT 3
76470: NEG
76471: PUSH
76472: EMPTY
76473: LIST
76474: LIST
76475: PUSH
76476: LD_INT 1
76478: NEG
76479: PUSH
76480: LD_INT 3
76482: NEG
76483: PUSH
76484: EMPTY
76485: LIST
76486: LIST
76487: PUSH
76488: EMPTY
76489: LIST
76490: LIST
76491: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
76492: LD_ADDR_VAR 0 48
76496: PUSH
76497: LD_INT 1
76499: PUSH
76500: LD_INT 2
76502: NEG
76503: PUSH
76504: EMPTY
76505: LIST
76506: LIST
76507: PUSH
76508: LD_INT 2
76510: PUSH
76511: LD_INT 1
76513: NEG
76514: PUSH
76515: EMPTY
76516: LIST
76517: LIST
76518: PUSH
76519: EMPTY
76520: LIST
76521: LIST
76522: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
76523: LD_ADDR_VAR 0 49
76527: PUSH
76528: LD_INT 3
76530: PUSH
76531: LD_INT 1
76533: PUSH
76534: EMPTY
76535: LIST
76536: LIST
76537: PUSH
76538: LD_INT 3
76540: PUSH
76541: LD_INT 2
76543: PUSH
76544: EMPTY
76545: LIST
76546: LIST
76547: PUSH
76548: EMPTY
76549: LIST
76550: LIST
76551: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
76552: LD_ADDR_VAR 0 50
76556: PUSH
76557: LD_INT 2
76559: PUSH
76560: LD_INT 3
76562: PUSH
76563: EMPTY
76564: LIST
76565: LIST
76566: PUSH
76567: LD_INT 1
76569: PUSH
76570: LD_INT 3
76572: PUSH
76573: EMPTY
76574: LIST
76575: LIST
76576: PUSH
76577: EMPTY
76578: LIST
76579: LIST
76580: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
76581: LD_ADDR_VAR 0 51
76585: PUSH
76586: LD_INT 1
76588: NEG
76589: PUSH
76590: LD_INT 2
76592: PUSH
76593: EMPTY
76594: LIST
76595: LIST
76596: PUSH
76597: LD_INT 2
76599: NEG
76600: PUSH
76601: LD_INT 1
76603: PUSH
76604: EMPTY
76605: LIST
76606: LIST
76607: PUSH
76608: EMPTY
76609: LIST
76610: LIST
76611: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
76612: LD_ADDR_VAR 0 52
76616: PUSH
76617: LD_INT 3
76619: NEG
76620: PUSH
76621: LD_INT 1
76623: NEG
76624: PUSH
76625: EMPTY
76626: LIST
76627: LIST
76628: PUSH
76629: LD_INT 3
76631: NEG
76632: PUSH
76633: LD_INT 2
76635: NEG
76636: PUSH
76637: EMPTY
76638: LIST
76639: LIST
76640: PUSH
76641: EMPTY
76642: LIST
76643: LIST
76644: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
76645: LD_ADDR_VAR 0 53
76649: PUSH
76650: LD_INT 1
76652: NEG
76653: PUSH
76654: LD_INT 3
76656: NEG
76657: PUSH
76658: EMPTY
76659: LIST
76660: LIST
76661: PUSH
76662: LD_INT 0
76664: PUSH
76665: LD_INT 3
76667: NEG
76668: PUSH
76669: EMPTY
76670: LIST
76671: LIST
76672: PUSH
76673: LD_INT 1
76675: PUSH
76676: LD_INT 2
76678: NEG
76679: PUSH
76680: EMPTY
76681: LIST
76682: LIST
76683: PUSH
76684: EMPTY
76685: LIST
76686: LIST
76687: LIST
76688: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
76689: LD_ADDR_VAR 0 54
76693: PUSH
76694: LD_INT 2
76696: PUSH
76697: LD_INT 1
76699: NEG
76700: PUSH
76701: EMPTY
76702: LIST
76703: LIST
76704: PUSH
76705: LD_INT 3
76707: PUSH
76708: LD_INT 0
76710: PUSH
76711: EMPTY
76712: LIST
76713: LIST
76714: PUSH
76715: LD_INT 3
76717: PUSH
76718: LD_INT 1
76720: PUSH
76721: EMPTY
76722: LIST
76723: LIST
76724: PUSH
76725: EMPTY
76726: LIST
76727: LIST
76728: LIST
76729: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
76730: LD_ADDR_VAR 0 55
76734: PUSH
76735: LD_INT 3
76737: PUSH
76738: LD_INT 2
76740: PUSH
76741: EMPTY
76742: LIST
76743: LIST
76744: PUSH
76745: LD_INT 3
76747: PUSH
76748: LD_INT 3
76750: PUSH
76751: EMPTY
76752: LIST
76753: LIST
76754: PUSH
76755: LD_INT 2
76757: PUSH
76758: LD_INT 3
76760: PUSH
76761: EMPTY
76762: LIST
76763: LIST
76764: PUSH
76765: EMPTY
76766: LIST
76767: LIST
76768: LIST
76769: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
76770: LD_ADDR_VAR 0 56
76774: PUSH
76775: LD_INT 1
76777: PUSH
76778: LD_INT 3
76780: PUSH
76781: EMPTY
76782: LIST
76783: LIST
76784: PUSH
76785: LD_INT 0
76787: PUSH
76788: LD_INT 3
76790: PUSH
76791: EMPTY
76792: LIST
76793: LIST
76794: PUSH
76795: LD_INT 1
76797: NEG
76798: PUSH
76799: LD_INT 2
76801: PUSH
76802: EMPTY
76803: LIST
76804: LIST
76805: PUSH
76806: EMPTY
76807: LIST
76808: LIST
76809: LIST
76810: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
76811: LD_ADDR_VAR 0 57
76815: PUSH
76816: LD_INT 2
76818: NEG
76819: PUSH
76820: LD_INT 1
76822: PUSH
76823: EMPTY
76824: LIST
76825: LIST
76826: PUSH
76827: LD_INT 3
76829: NEG
76830: PUSH
76831: LD_INT 0
76833: PUSH
76834: EMPTY
76835: LIST
76836: LIST
76837: PUSH
76838: LD_INT 3
76840: NEG
76841: PUSH
76842: LD_INT 1
76844: NEG
76845: PUSH
76846: EMPTY
76847: LIST
76848: LIST
76849: PUSH
76850: EMPTY
76851: LIST
76852: LIST
76853: LIST
76854: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
76855: LD_ADDR_VAR 0 58
76859: PUSH
76860: LD_INT 2
76862: NEG
76863: PUSH
76864: LD_INT 3
76866: NEG
76867: PUSH
76868: EMPTY
76869: LIST
76870: LIST
76871: PUSH
76872: LD_INT 3
76874: NEG
76875: PUSH
76876: LD_INT 2
76878: NEG
76879: PUSH
76880: EMPTY
76881: LIST
76882: LIST
76883: PUSH
76884: LD_INT 3
76886: NEG
76887: PUSH
76888: LD_INT 3
76890: NEG
76891: PUSH
76892: EMPTY
76893: LIST
76894: LIST
76895: PUSH
76896: EMPTY
76897: LIST
76898: LIST
76899: LIST
76900: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
76901: LD_ADDR_VAR 0 59
76905: PUSH
76906: LD_INT 1
76908: NEG
76909: PUSH
76910: LD_INT 2
76912: NEG
76913: PUSH
76914: EMPTY
76915: LIST
76916: LIST
76917: PUSH
76918: LD_INT 0
76920: PUSH
76921: LD_INT 2
76923: NEG
76924: PUSH
76925: EMPTY
76926: LIST
76927: LIST
76928: PUSH
76929: LD_INT 1
76931: PUSH
76932: LD_INT 1
76934: NEG
76935: PUSH
76936: EMPTY
76937: LIST
76938: LIST
76939: PUSH
76940: EMPTY
76941: LIST
76942: LIST
76943: LIST
76944: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
76945: LD_ADDR_VAR 0 60
76949: PUSH
76950: LD_INT 1
76952: PUSH
76953: LD_INT 1
76955: NEG
76956: PUSH
76957: EMPTY
76958: LIST
76959: LIST
76960: PUSH
76961: LD_INT 2
76963: PUSH
76964: LD_INT 0
76966: PUSH
76967: EMPTY
76968: LIST
76969: LIST
76970: PUSH
76971: LD_INT 2
76973: PUSH
76974: LD_INT 1
76976: PUSH
76977: EMPTY
76978: LIST
76979: LIST
76980: PUSH
76981: EMPTY
76982: LIST
76983: LIST
76984: LIST
76985: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
76986: LD_ADDR_VAR 0 61
76990: PUSH
76991: LD_INT 2
76993: PUSH
76994: LD_INT 1
76996: PUSH
76997: EMPTY
76998: LIST
76999: LIST
77000: PUSH
77001: LD_INT 2
77003: PUSH
77004: LD_INT 2
77006: PUSH
77007: EMPTY
77008: LIST
77009: LIST
77010: PUSH
77011: LD_INT 1
77013: PUSH
77014: LD_INT 2
77016: PUSH
77017: EMPTY
77018: LIST
77019: LIST
77020: PUSH
77021: EMPTY
77022: LIST
77023: LIST
77024: LIST
77025: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
77026: LD_ADDR_VAR 0 62
77030: PUSH
77031: LD_INT 1
77033: PUSH
77034: LD_INT 2
77036: PUSH
77037: EMPTY
77038: LIST
77039: LIST
77040: PUSH
77041: LD_INT 0
77043: PUSH
77044: LD_INT 2
77046: PUSH
77047: EMPTY
77048: LIST
77049: LIST
77050: PUSH
77051: LD_INT 1
77053: NEG
77054: PUSH
77055: LD_INT 1
77057: PUSH
77058: EMPTY
77059: LIST
77060: LIST
77061: PUSH
77062: EMPTY
77063: LIST
77064: LIST
77065: LIST
77066: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
77067: LD_ADDR_VAR 0 63
77071: PUSH
77072: LD_INT 1
77074: NEG
77075: PUSH
77076: LD_INT 1
77078: PUSH
77079: EMPTY
77080: LIST
77081: LIST
77082: PUSH
77083: LD_INT 2
77085: NEG
77086: PUSH
77087: LD_INT 0
77089: PUSH
77090: EMPTY
77091: LIST
77092: LIST
77093: PUSH
77094: LD_INT 2
77096: NEG
77097: PUSH
77098: LD_INT 1
77100: NEG
77101: PUSH
77102: EMPTY
77103: LIST
77104: LIST
77105: PUSH
77106: EMPTY
77107: LIST
77108: LIST
77109: LIST
77110: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77111: LD_ADDR_VAR 0 64
77115: PUSH
77116: LD_INT 1
77118: NEG
77119: PUSH
77120: LD_INT 2
77122: NEG
77123: PUSH
77124: EMPTY
77125: LIST
77126: LIST
77127: PUSH
77128: LD_INT 2
77130: NEG
77131: PUSH
77132: LD_INT 1
77134: NEG
77135: PUSH
77136: EMPTY
77137: LIST
77138: LIST
77139: PUSH
77140: LD_INT 2
77142: NEG
77143: PUSH
77144: LD_INT 2
77146: NEG
77147: PUSH
77148: EMPTY
77149: LIST
77150: LIST
77151: PUSH
77152: EMPTY
77153: LIST
77154: LIST
77155: LIST
77156: ST_TO_ADDR
// end ; 2 :
77157: GO 80423
77159: LD_INT 2
77161: DOUBLE
77162: EQUAL
77163: IFTRUE 77167
77165: GO 80422
77167: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
77168: LD_ADDR_VAR 0 29
77172: PUSH
77173: LD_INT 4
77175: PUSH
77176: LD_INT 0
77178: PUSH
77179: EMPTY
77180: LIST
77181: LIST
77182: PUSH
77183: LD_INT 4
77185: PUSH
77186: LD_INT 1
77188: NEG
77189: PUSH
77190: EMPTY
77191: LIST
77192: LIST
77193: PUSH
77194: LD_INT 5
77196: PUSH
77197: LD_INT 0
77199: PUSH
77200: EMPTY
77201: LIST
77202: LIST
77203: PUSH
77204: LD_INT 5
77206: PUSH
77207: LD_INT 1
77209: PUSH
77210: EMPTY
77211: LIST
77212: LIST
77213: PUSH
77214: LD_INT 4
77216: PUSH
77217: LD_INT 1
77219: PUSH
77220: EMPTY
77221: LIST
77222: LIST
77223: PUSH
77224: LD_INT 3
77226: PUSH
77227: LD_INT 0
77229: PUSH
77230: EMPTY
77231: LIST
77232: LIST
77233: PUSH
77234: LD_INT 3
77236: PUSH
77237: LD_INT 1
77239: NEG
77240: PUSH
77241: EMPTY
77242: LIST
77243: LIST
77244: PUSH
77245: LD_INT 3
77247: PUSH
77248: LD_INT 2
77250: NEG
77251: PUSH
77252: EMPTY
77253: LIST
77254: LIST
77255: PUSH
77256: LD_INT 5
77258: PUSH
77259: LD_INT 2
77261: PUSH
77262: EMPTY
77263: LIST
77264: LIST
77265: PUSH
77266: LD_INT 3
77268: PUSH
77269: LD_INT 3
77271: PUSH
77272: EMPTY
77273: LIST
77274: LIST
77275: PUSH
77276: LD_INT 3
77278: PUSH
77279: LD_INT 2
77281: PUSH
77282: EMPTY
77283: LIST
77284: LIST
77285: PUSH
77286: LD_INT 4
77288: PUSH
77289: LD_INT 3
77291: PUSH
77292: EMPTY
77293: LIST
77294: LIST
77295: PUSH
77296: LD_INT 4
77298: PUSH
77299: LD_INT 4
77301: PUSH
77302: EMPTY
77303: LIST
77304: LIST
77305: PUSH
77306: LD_INT 3
77308: PUSH
77309: LD_INT 4
77311: PUSH
77312: EMPTY
77313: LIST
77314: LIST
77315: PUSH
77316: LD_INT 2
77318: PUSH
77319: LD_INT 3
77321: PUSH
77322: EMPTY
77323: LIST
77324: LIST
77325: PUSH
77326: LD_INT 2
77328: PUSH
77329: LD_INT 2
77331: PUSH
77332: EMPTY
77333: LIST
77334: LIST
77335: PUSH
77336: LD_INT 4
77338: PUSH
77339: LD_INT 2
77341: PUSH
77342: EMPTY
77343: LIST
77344: LIST
77345: PUSH
77346: LD_INT 2
77348: PUSH
77349: LD_INT 4
77351: PUSH
77352: EMPTY
77353: LIST
77354: LIST
77355: PUSH
77356: LD_INT 0
77358: PUSH
77359: LD_INT 4
77361: PUSH
77362: EMPTY
77363: LIST
77364: LIST
77365: PUSH
77366: LD_INT 0
77368: PUSH
77369: LD_INT 3
77371: PUSH
77372: EMPTY
77373: LIST
77374: LIST
77375: PUSH
77376: LD_INT 1
77378: PUSH
77379: LD_INT 4
77381: PUSH
77382: EMPTY
77383: LIST
77384: LIST
77385: PUSH
77386: LD_INT 1
77388: PUSH
77389: LD_INT 5
77391: PUSH
77392: EMPTY
77393: LIST
77394: LIST
77395: PUSH
77396: LD_INT 0
77398: PUSH
77399: LD_INT 5
77401: PUSH
77402: EMPTY
77403: LIST
77404: LIST
77405: PUSH
77406: LD_INT 1
77408: NEG
77409: PUSH
77410: LD_INT 4
77412: PUSH
77413: EMPTY
77414: LIST
77415: LIST
77416: PUSH
77417: LD_INT 1
77419: NEG
77420: PUSH
77421: LD_INT 3
77423: PUSH
77424: EMPTY
77425: LIST
77426: LIST
77427: PUSH
77428: LD_INT 2
77430: PUSH
77431: LD_INT 5
77433: PUSH
77434: EMPTY
77435: LIST
77436: LIST
77437: PUSH
77438: LD_INT 2
77440: NEG
77441: PUSH
77442: LD_INT 3
77444: PUSH
77445: EMPTY
77446: LIST
77447: LIST
77448: PUSH
77449: LD_INT 3
77451: NEG
77452: PUSH
77453: LD_INT 0
77455: PUSH
77456: EMPTY
77457: LIST
77458: LIST
77459: PUSH
77460: LD_INT 3
77462: NEG
77463: PUSH
77464: LD_INT 1
77466: NEG
77467: PUSH
77468: EMPTY
77469: LIST
77470: LIST
77471: PUSH
77472: LD_INT 2
77474: NEG
77475: PUSH
77476: LD_INT 0
77478: PUSH
77479: EMPTY
77480: LIST
77481: LIST
77482: PUSH
77483: LD_INT 2
77485: NEG
77486: PUSH
77487: LD_INT 1
77489: PUSH
77490: EMPTY
77491: LIST
77492: LIST
77493: PUSH
77494: LD_INT 3
77496: NEG
77497: PUSH
77498: LD_INT 1
77500: PUSH
77501: EMPTY
77502: LIST
77503: LIST
77504: PUSH
77505: LD_INT 4
77507: NEG
77508: PUSH
77509: LD_INT 0
77511: PUSH
77512: EMPTY
77513: LIST
77514: LIST
77515: PUSH
77516: LD_INT 4
77518: NEG
77519: PUSH
77520: LD_INT 1
77522: NEG
77523: PUSH
77524: EMPTY
77525: LIST
77526: LIST
77527: PUSH
77528: LD_INT 4
77530: NEG
77531: PUSH
77532: LD_INT 2
77534: NEG
77535: PUSH
77536: EMPTY
77537: LIST
77538: LIST
77539: PUSH
77540: LD_INT 2
77542: NEG
77543: PUSH
77544: LD_INT 2
77546: PUSH
77547: EMPTY
77548: LIST
77549: LIST
77550: PUSH
77551: LD_INT 4
77553: NEG
77554: PUSH
77555: LD_INT 4
77557: NEG
77558: PUSH
77559: EMPTY
77560: LIST
77561: LIST
77562: PUSH
77563: LD_INT 4
77565: NEG
77566: PUSH
77567: LD_INT 5
77569: NEG
77570: PUSH
77571: EMPTY
77572: LIST
77573: LIST
77574: PUSH
77575: LD_INT 3
77577: NEG
77578: PUSH
77579: LD_INT 4
77581: NEG
77582: PUSH
77583: EMPTY
77584: LIST
77585: LIST
77586: PUSH
77587: LD_INT 3
77589: NEG
77590: PUSH
77591: LD_INT 3
77593: NEG
77594: PUSH
77595: EMPTY
77596: LIST
77597: LIST
77598: PUSH
77599: LD_INT 4
77601: NEG
77602: PUSH
77603: LD_INT 3
77605: NEG
77606: PUSH
77607: EMPTY
77608: LIST
77609: LIST
77610: PUSH
77611: LD_INT 5
77613: NEG
77614: PUSH
77615: LD_INT 4
77617: NEG
77618: PUSH
77619: EMPTY
77620: LIST
77621: LIST
77622: PUSH
77623: LD_INT 5
77625: NEG
77626: PUSH
77627: LD_INT 5
77629: NEG
77630: PUSH
77631: EMPTY
77632: LIST
77633: LIST
77634: PUSH
77635: LD_INT 3
77637: NEG
77638: PUSH
77639: LD_INT 5
77641: NEG
77642: PUSH
77643: EMPTY
77644: LIST
77645: LIST
77646: PUSH
77647: LD_INT 5
77649: NEG
77650: PUSH
77651: LD_INT 3
77653: NEG
77654: PUSH
77655: EMPTY
77656: LIST
77657: LIST
77658: PUSH
77659: EMPTY
77660: LIST
77661: LIST
77662: LIST
77663: LIST
77664: LIST
77665: LIST
77666: LIST
77667: LIST
77668: LIST
77669: LIST
77670: LIST
77671: LIST
77672: LIST
77673: LIST
77674: LIST
77675: LIST
77676: LIST
77677: LIST
77678: LIST
77679: LIST
77680: LIST
77681: LIST
77682: LIST
77683: LIST
77684: LIST
77685: LIST
77686: LIST
77687: LIST
77688: LIST
77689: LIST
77690: LIST
77691: LIST
77692: LIST
77693: LIST
77694: LIST
77695: LIST
77696: LIST
77697: LIST
77698: LIST
77699: LIST
77700: LIST
77701: LIST
77702: LIST
77703: LIST
77704: LIST
77705: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
77706: LD_ADDR_VAR 0 30
77710: PUSH
77711: LD_INT 4
77713: PUSH
77714: LD_INT 4
77716: PUSH
77717: EMPTY
77718: LIST
77719: LIST
77720: PUSH
77721: LD_INT 4
77723: PUSH
77724: LD_INT 3
77726: PUSH
77727: EMPTY
77728: LIST
77729: LIST
77730: PUSH
77731: LD_INT 5
77733: PUSH
77734: LD_INT 4
77736: PUSH
77737: EMPTY
77738: LIST
77739: LIST
77740: PUSH
77741: LD_INT 5
77743: PUSH
77744: LD_INT 5
77746: PUSH
77747: EMPTY
77748: LIST
77749: LIST
77750: PUSH
77751: LD_INT 4
77753: PUSH
77754: LD_INT 5
77756: PUSH
77757: EMPTY
77758: LIST
77759: LIST
77760: PUSH
77761: LD_INT 3
77763: PUSH
77764: LD_INT 4
77766: PUSH
77767: EMPTY
77768: LIST
77769: LIST
77770: PUSH
77771: LD_INT 3
77773: PUSH
77774: LD_INT 3
77776: PUSH
77777: EMPTY
77778: LIST
77779: LIST
77780: PUSH
77781: LD_INT 5
77783: PUSH
77784: LD_INT 3
77786: PUSH
77787: EMPTY
77788: LIST
77789: LIST
77790: PUSH
77791: LD_INT 3
77793: PUSH
77794: LD_INT 5
77796: PUSH
77797: EMPTY
77798: LIST
77799: LIST
77800: PUSH
77801: LD_INT 0
77803: PUSH
77804: LD_INT 3
77806: PUSH
77807: EMPTY
77808: LIST
77809: LIST
77810: PUSH
77811: LD_INT 0
77813: PUSH
77814: LD_INT 2
77816: PUSH
77817: EMPTY
77818: LIST
77819: LIST
77820: PUSH
77821: LD_INT 1
77823: PUSH
77824: LD_INT 3
77826: PUSH
77827: EMPTY
77828: LIST
77829: LIST
77830: PUSH
77831: LD_INT 1
77833: PUSH
77834: LD_INT 4
77836: PUSH
77837: EMPTY
77838: LIST
77839: LIST
77840: PUSH
77841: LD_INT 0
77843: PUSH
77844: LD_INT 4
77846: PUSH
77847: EMPTY
77848: LIST
77849: LIST
77850: PUSH
77851: LD_INT 1
77853: NEG
77854: PUSH
77855: LD_INT 3
77857: PUSH
77858: EMPTY
77859: LIST
77860: LIST
77861: PUSH
77862: LD_INT 1
77864: NEG
77865: PUSH
77866: LD_INT 2
77868: PUSH
77869: EMPTY
77870: LIST
77871: LIST
77872: PUSH
77873: LD_INT 2
77875: PUSH
77876: LD_INT 4
77878: PUSH
77879: EMPTY
77880: LIST
77881: LIST
77882: PUSH
77883: LD_INT 2
77885: NEG
77886: PUSH
77887: LD_INT 2
77889: PUSH
77890: EMPTY
77891: LIST
77892: LIST
77893: PUSH
77894: LD_INT 4
77896: NEG
77897: PUSH
77898: LD_INT 0
77900: PUSH
77901: EMPTY
77902: LIST
77903: LIST
77904: PUSH
77905: LD_INT 4
77907: NEG
77908: PUSH
77909: LD_INT 1
77911: NEG
77912: PUSH
77913: EMPTY
77914: LIST
77915: LIST
77916: PUSH
77917: LD_INT 3
77919: NEG
77920: PUSH
77921: LD_INT 0
77923: PUSH
77924: EMPTY
77925: LIST
77926: LIST
77927: PUSH
77928: LD_INT 3
77930: NEG
77931: PUSH
77932: LD_INT 1
77934: PUSH
77935: EMPTY
77936: LIST
77937: LIST
77938: PUSH
77939: LD_INT 4
77941: NEG
77942: PUSH
77943: LD_INT 1
77945: PUSH
77946: EMPTY
77947: LIST
77948: LIST
77949: PUSH
77950: LD_INT 5
77952: NEG
77953: PUSH
77954: LD_INT 0
77956: PUSH
77957: EMPTY
77958: LIST
77959: LIST
77960: PUSH
77961: LD_INT 5
77963: NEG
77964: PUSH
77965: LD_INT 1
77967: NEG
77968: PUSH
77969: EMPTY
77970: LIST
77971: LIST
77972: PUSH
77973: LD_INT 5
77975: NEG
77976: PUSH
77977: LD_INT 2
77979: NEG
77980: PUSH
77981: EMPTY
77982: LIST
77983: LIST
77984: PUSH
77985: LD_INT 3
77987: NEG
77988: PUSH
77989: LD_INT 2
77991: PUSH
77992: EMPTY
77993: LIST
77994: LIST
77995: PUSH
77996: LD_INT 3
77998: NEG
77999: PUSH
78000: LD_INT 3
78002: NEG
78003: PUSH
78004: EMPTY
78005: LIST
78006: LIST
78007: PUSH
78008: LD_INT 3
78010: NEG
78011: PUSH
78012: LD_INT 4
78014: NEG
78015: PUSH
78016: EMPTY
78017: LIST
78018: LIST
78019: PUSH
78020: LD_INT 2
78022: NEG
78023: PUSH
78024: LD_INT 3
78026: NEG
78027: PUSH
78028: EMPTY
78029: LIST
78030: LIST
78031: PUSH
78032: LD_INT 2
78034: NEG
78035: PUSH
78036: LD_INT 2
78038: NEG
78039: PUSH
78040: EMPTY
78041: LIST
78042: LIST
78043: PUSH
78044: LD_INT 3
78046: NEG
78047: PUSH
78048: LD_INT 2
78050: NEG
78051: PUSH
78052: EMPTY
78053: LIST
78054: LIST
78055: PUSH
78056: LD_INT 4
78058: NEG
78059: PUSH
78060: LD_INT 3
78062: NEG
78063: PUSH
78064: EMPTY
78065: LIST
78066: LIST
78067: PUSH
78068: LD_INT 4
78070: NEG
78071: PUSH
78072: LD_INT 4
78074: NEG
78075: PUSH
78076: EMPTY
78077: LIST
78078: LIST
78079: PUSH
78080: LD_INT 2
78082: NEG
78083: PUSH
78084: LD_INT 4
78086: NEG
78087: PUSH
78088: EMPTY
78089: LIST
78090: LIST
78091: PUSH
78092: LD_INT 4
78094: NEG
78095: PUSH
78096: LD_INT 2
78098: NEG
78099: PUSH
78100: EMPTY
78101: LIST
78102: LIST
78103: PUSH
78104: LD_INT 0
78106: PUSH
78107: LD_INT 4
78109: NEG
78110: PUSH
78111: EMPTY
78112: LIST
78113: LIST
78114: PUSH
78115: LD_INT 0
78117: PUSH
78118: LD_INT 5
78120: NEG
78121: PUSH
78122: EMPTY
78123: LIST
78124: LIST
78125: PUSH
78126: LD_INT 1
78128: PUSH
78129: LD_INT 4
78131: NEG
78132: PUSH
78133: EMPTY
78134: LIST
78135: LIST
78136: PUSH
78137: LD_INT 1
78139: PUSH
78140: LD_INT 3
78142: NEG
78143: PUSH
78144: EMPTY
78145: LIST
78146: LIST
78147: PUSH
78148: LD_INT 0
78150: PUSH
78151: LD_INT 3
78153: NEG
78154: PUSH
78155: EMPTY
78156: LIST
78157: LIST
78158: PUSH
78159: LD_INT 1
78161: NEG
78162: PUSH
78163: LD_INT 4
78165: NEG
78166: PUSH
78167: EMPTY
78168: LIST
78169: LIST
78170: PUSH
78171: LD_INT 1
78173: NEG
78174: PUSH
78175: LD_INT 5
78177: NEG
78178: PUSH
78179: EMPTY
78180: LIST
78181: LIST
78182: PUSH
78183: LD_INT 2
78185: PUSH
78186: LD_INT 3
78188: NEG
78189: PUSH
78190: EMPTY
78191: LIST
78192: LIST
78193: PUSH
78194: LD_INT 2
78196: NEG
78197: PUSH
78198: LD_INT 5
78200: NEG
78201: PUSH
78202: EMPTY
78203: LIST
78204: LIST
78205: PUSH
78206: EMPTY
78207: LIST
78208: LIST
78209: LIST
78210: LIST
78211: LIST
78212: LIST
78213: LIST
78214: LIST
78215: LIST
78216: LIST
78217: LIST
78218: LIST
78219: LIST
78220: LIST
78221: LIST
78222: LIST
78223: LIST
78224: LIST
78225: LIST
78226: LIST
78227: LIST
78228: LIST
78229: LIST
78230: LIST
78231: LIST
78232: LIST
78233: LIST
78234: LIST
78235: LIST
78236: LIST
78237: LIST
78238: LIST
78239: LIST
78240: LIST
78241: LIST
78242: LIST
78243: LIST
78244: LIST
78245: LIST
78246: LIST
78247: LIST
78248: LIST
78249: LIST
78250: LIST
78251: LIST
78252: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
78253: LD_ADDR_VAR 0 31
78257: PUSH
78258: LD_INT 0
78260: PUSH
78261: LD_INT 4
78263: PUSH
78264: EMPTY
78265: LIST
78266: LIST
78267: PUSH
78268: LD_INT 0
78270: PUSH
78271: LD_INT 3
78273: PUSH
78274: EMPTY
78275: LIST
78276: LIST
78277: PUSH
78278: LD_INT 1
78280: PUSH
78281: LD_INT 4
78283: PUSH
78284: EMPTY
78285: LIST
78286: LIST
78287: PUSH
78288: LD_INT 1
78290: PUSH
78291: LD_INT 5
78293: PUSH
78294: EMPTY
78295: LIST
78296: LIST
78297: PUSH
78298: LD_INT 0
78300: PUSH
78301: LD_INT 5
78303: PUSH
78304: EMPTY
78305: LIST
78306: LIST
78307: PUSH
78308: LD_INT 1
78310: NEG
78311: PUSH
78312: LD_INT 4
78314: PUSH
78315: EMPTY
78316: LIST
78317: LIST
78318: PUSH
78319: LD_INT 1
78321: NEG
78322: PUSH
78323: LD_INT 3
78325: PUSH
78326: EMPTY
78327: LIST
78328: LIST
78329: PUSH
78330: LD_INT 2
78332: PUSH
78333: LD_INT 5
78335: PUSH
78336: EMPTY
78337: LIST
78338: LIST
78339: PUSH
78340: LD_INT 2
78342: NEG
78343: PUSH
78344: LD_INT 3
78346: PUSH
78347: EMPTY
78348: LIST
78349: LIST
78350: PUSH
78351: LD_INT 3
78353: NEG
78354: PUSH
78355: LD_INT 0
78357: PUSH
78358: EMPTY
78359: LIST
78360: LIST
78361: PUSH
78362: LD_INT 3
78364: NEG
78365: PUSH
78366: LD_INT 1
78368: NEG
78369: PUSH
78370: EMPTY
78371: LIST
78372: LIST
78373: PUSH
78374: LD_INT 2
78376: NEG
78377: PUSH
78378: LD_INT 0
78380: PUSH
78381: EMPTY
78382: LIST
78383: LIST
78384: PUSH
78385: LD_INT 2
78387: NEG
78388: PUSH
78389: LD_INT 1
78391: PUSH
78392: EMPTY
78393: LIST
78394: LIST
78395: PUSH
78396: LD_INT 3
78398: NEG
78399: PUSH
78400: LD_INT 1
78402: PUSH
78403: EMPTY
78404: LIST
78405: LIST
78406: PUSH
78407: LD_INT 4
78409: NEG
78410: PUSH
78411: LD_INT 0
78413: PUSH
78414: EMPTY
78415: LIST
78416: LIST
78417: PUSH
78418: LD_INT 4
78420: NEG
78421: PUSH
78422: LD_INT 1
78424: NEG
78425: PUSH
78426: EMPTY
78427: LIST
78428: LIST
78429: PUSH
78430: LD_INT 4
78432: NEG
78433: PUSH
78434: LD_INT 2
78436: NEG
78437: PUSH
78438: EMPTY
78439: LIST
78440: LIST
78441: PUSH
78442: LD_INT 2
78444: NEG
78445: PUSH
78446: LD_INT 2
78448: PUSH
78449: EMPTY
78450: LIST
78451: LIST
78452: PUSH
78453: LD_INT 4
78455: NEG
78456: PUSH
78457: LD_INT 4
78459: NEG
78460: PUSH
78461: EMPTY
78462: LIST
78463: LIST
78464: PUSH
78465: LD_INT 4
78467: NEG
78468: PUSH
78469: LD_INT 5
78471: NEG
78472: PUSH
78473: EMPTY
78474: LIST
78475: LIST
78476: PUSH
78477: LD_INT 3
78479: NEG
78480: PUSH
78481: LD_INT 4
78483: NEG
78484: PUSH
78485: EMPTY
78486: LIST
78487: LIST
78488: PUSH
78489: LD_INT 3
78491: NEG
78492: PUSH
78493: LD_INT 3
78495: NEG
78496: PUSH
78497: EMPTY
78498: LIST
78499: LIST
78500: PUSH
78501: LD_INT 4
78503: NEG
78504: PUSH
78505: LD_INT 3
78507: NEG
78508: PUSH
78509: EMPTY
78510: LIST
78511: LIST
78512: PUSH
78513: LD_INT 5
78515: NEG
78516: PUSH
78517: LD_INT 4
78519: NEG
78520: PUSH
78521: EMPTY
78522: LIST
78523: LIST
78524: PUSH
78525: LD_INT 5
78527: NEG
78528: PUSH
78529: LD_INT 5
78531: NEG
78532: PUSH
78533: EMPTY
78534: LIST
78535: LIST
78536: PUSH
78537: LD_INT 3
78539: NEG
78540: PUSH
78541: LD_INT 5
78543: NEG
78544: PUSH
78545: EMPTY
78546: LIST
78547: LIST
78548: PUSH
78549: LD_INT 5
78551: NEG
78552: PUSH
78553: LD_INT 3
78555: NEG
78556: PUSH
78557: EMPTY
78558: LIST
78559: LIST
78560: PUSH
78561: LD_INT 0
78563: PUSH
78564: LD_INT 3
78566: NEG
78567: PUSH
78568: EMPTY
78569: LIST
78570: LIST
78571: PUSH
78572: LD_INT 0
78574: PUSH
78575: LD_INT 4
78577: NEG
78578: PUSH
78579: EMPTY
78580: LIST
78581: LIST
78582: PUSH
78583: LD_INT 1
78585: PUSH
78586: LD_INT 3
78588: NEG
78589: PUSH
78590: EMPTY
78591: LIST
78592: LIST
78593: PUSH
78594: LD_INT 1
78596: PUSH
78597: LD_INT 2
78599: NEG
78600: PUSH
78601: EMPTY
78602: LIST
78603: LIST
78604: PUSH
78605: LD_INT 0
78607: PUSH
78608: LD_INT 2
78610: NEG
78611: PUSH
78612: EMPTY
78613: LIST
78614: LIST
78615: PUSH
78616: LD_INT 1
78618: NEG
78619: PUSH
78620: LD_INT 3
78622: NEG
78623: PUSH
78624: EMPTY
78625: LIST
78626: LIST
78627: PUSH
78628: LD_INT 1
78630: NEG
78631: PUSH
78632: LD_INT 4
78634: NEG
78635: PUSH
78636: EMPTY
78637: LIST
78638: LIST
78639: PUSH
78640: LD_INT 2
78642: PUSH
78643: LD_INT 2
78645: NEG
78646: PUSH
78647: EMPTY
78648: LIST
78649: LIST
78650: PUSH
78651: LD_INT 2
78653: NEG
78654: PUSH
78655: LD_INT 4
78657: NEG
78658: PUSH
78659: EMPTY
78660: LIST
78661: LIST
78662: PUSH
78663: LD_INT 4
78665: PUSH
78666: LD_INT 0
78668: PUSH
78669: EMPTY
78670: LIST
78671: LIST
78672: PUSH
78673: LD_INT 4
78675: PUSH
78676: LD_INT 1
78678: NEG
78679: PUSH
78680: EMPTY
78681: LIST
78682: LIST
78683: PUSH
78684: LD_INT 5
78686: PUSH
78687: LD_INT 0
78689: PUSH
78690: EMPTY
78691: LIST
78692: LIST
78693: PUSH
78694: LD_INT 5
78696: PUSH
78697: LD_INT 1
78699: PUSH
78700: EMPTY
78701: LIST
78702: LIST
78703: PUSH
78704: LD_INT 4
78706: PUSH
78707: LD_INT 1
78709: PUSH
78710: EMPTY
78711: LIST
78712: LIST
78713: PUSH
78714: LD_INT 3
78716: PUSH
78717: LD_INT 0
78719: PUSH
78720: EMPTY
78721: LIST
78722: LIST
78723: PUSH
78724: LD_INT 3
78726: PUSH
78727: LD_INT 1
78729: NEG
78730: PUSH
78731: EMPTY
78732: LIST
78733: LIST
78734: PUSH
78735: LD_INT 3
78737: PUSH
78738: LD_INT 2
78740: NEG
78741: PUSH
78742: EMPTY
78743: LIST
78744: LIST
78745: PUSH
78746: LD_INT 5
78748: PUSH
78749: LD_INT 2
78751: PUSH
78752: EMPTY
78753: LIST
78754: LIST
78755: PUSH
78756: EMPTY
78757: LIST
78758: LIST
78759: LIST
78760: LIST
78761: LIST
78762: LIST
78763: LIST
78764: LIST
78765: LIST
78766: LIST
78767: LIST
78768: LIST
78769: LIST
78770: LIST
78771: LIST
78772: LIST
78773: LIST
78774: LIST
78775: LIST
78776: LIST
78777: LIST
78778: LIST
78779: LIST
78780: LIST
78781: LIST
78782: LIST
78783: LIST
78784: LIST
78785: LIST
78786: LIST
78787: LIST
78788: LIST
78789: LIST
78790: LIST
78791: LIST
78792: LIST
78793: LIST
78794: LIST
78795: LIST
78796: LIST
78797: LIST
78798: LIST
78799: LIST
78800: LIST
78801: LIST
78802: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
78803: LD_ADDR_VAR 0 32
78807: PUSH
78808: LD_INT 4
78810: NEG
78811: PUSH
78812: LD_INT 0
78814: PUSH
78815: EMPTY
78816: LIST
78817: LIST
78818: PUSH
78819: LD_INT 4
78821: NEG
78822: PUSH
78823: LD_INT 1
78825: NEG
78826: PUSH
78827: EMPTY
78828: LIST
78829: LIST
78830: PUSH
78831: LD_INT 3
78833: NEG
78834: PUSH
78835: LD_INT 0
78837: PUSH
78838: EMPTY
78839: LIST
78840: LIST
78841: PUSH
78842: LD_INT 3
78844: NEG
78845: PUSH
78846: LD_INT 1
78848: PUSH
78849: EMPTY
78850: LIST
78851: LIST
78852: PUSH
78853: LD_INT 4
78855: NEG
78856: PUSH
78857: LD_INT 1
78859: PUSH
78860: EMPTY
78861: LIST
78862: LIST
78863: PUSH
78864: LD_INT 5
78866: NEG
78867: PUSH
78868: LD_INT 0
78870: PUSH
78871: EMPTY
78872: LIST
78873: LIST
78874: PUSH
78875: LD_INT 5
78877: NEG
78878: PUSH
78879: LD_INT 1
78881: NEG
78882: PUSH
78883: EMPTY
78884: LIST
78885: LIST
78886: PUSH
78887: LD_INT 5
78889: NEG
78890: PUSH
78891: LD_INT 2
78893: NEG
78894: PUSH
78895: EMPTY
78896: LIST
78897: LIST
78898: PUSH
78899: LD_INT 3
78901: NEG
78902: PUSH
78903: LD_INT 2
78905: PUSH
78906: EMPTY
78907: LIST
78908: LIST
78909: PUSH
78910: LD_INT 3
78912: NEG
78913: PUSH
78914: LD_INT 3
78916: NEG
78917: PUSH
78918: EMPTY
78919: LIST
78920: LIST
78921: PUSH
78922: LD_INT 3
78924: NEG
78925: PUSH
78926: LD_INT 4
78928: NEG
78929: PUSH
78930: EMPTY
78931: LIST
78932: LIST
78933: PUSH
78934: LD_INT 2
78936: NEG
78937: PUSH
78938: LD_INT 3
78940: NEG
78941: PUSH
78942: EMPTY
78943: LIST
78944: LIST
78945: PUSH
78946: LD_INT 2
78948: NEG
78949: PUSH
78950: LD_INT 2
78952: NEG
78953: PUSH
78954: EMPTY
78955: LIST
78956: LIST
78957: PUSH
78958: LD_INT 3
78960: NEG
78961: PUSH
78962: LD_INT 2
78964: NEG
78965: PUSH
78966: EMPTY
78967: LIST
78968: LIST
78969: PUSH
78970: LD_INT 4
78972: NEG
78973: PUSH
78974: LD_INT 3
78976: NEG
78977: PUSH
78978: EMPTY
78979: LIST
78980: LIST
78981: PUSH
78982: LD_INT 4
78984: NEG
78985: PUSH
78986: LD_INT 4
78988: NEG
78989: PUSH
78990: EMPTY
78991: LIST
78992: LIST
78993: PUSH
78994: LD_INT 2
78996: NEG
78997: PUSH
78998: LD_INT 4
79000: NEG
79001: PUSH
79002: EMPTY
79003: LIST
79004: LIST
79005: PUSH
79006: LD_INT 4
79008: NEG
79009: PUSH
79010: LD_INT 2
79012: NEG
79013: PUSH
79014: EMPTY
79015: LIST
79016: LIST
79017: PUSH
79018: LD_INT 0
79020: PUSH
79021: LD_INT 4
79023: NEG
79024: PUSH
79025: EMPTY
79026: LIST
79027: LIST
79028: PUSH
79029: LD_INT 0
79031: PUSH
79032: LD_INT 5
79034: NEG
79035: PUSH
79036: EMPTY
79037: LIST
79038: LIST
79039: PUSH
79040: LD_INT 1
79042: PUSH
79043: LD_INT 4
79045: NEG
79046: PUSH
79047: EMPTY
79048: LIST
79049: LIST
79050: PUSH
79051: LD_INT 1
79053: PUSH
79054: LD_INT 3
79056: NEG
79057: PUSH
79058: EMPTY
79059: LIST
79060: LIST
79061: PUSH
79062: LD_INT 0
79064: PUSH
79065: LD_INT 3
79067: NEG
79068: PUSH
79069: EMPTY
79070: LIST
79071: LIST
79072: PUSH
79073: LD_INT 1
79075: NEG
79076: PUSH
79077: LD_INT 4
79079: NEG
79080: PUSH
79081: EMPTY
79082: LIST
79083: LIST
79084: PUSH
79085: LD_INT 1
79087: NEG
79088: PUSH
79089: LD_INT 5
79091: NEG
79092: PUSH
79093: EMPTY
79094: LIST
79095: LIST
79096: PUSH
79097: LD_INT 2
79099: PUSH
79100: LD_INT 3
79102: NEG
79103: PUSH
79104: EMPTY
79105: LIST
79106: LIST
79107: PUSH
79108: LD_INT 2
79110: NEG
79111: PUSH
79112: LD_INT 5
79114: NEG
79115: PUSH
79116: EMPTY
79117: LIST
79118: LIST
79119: PUSH
79120: LD_INT 3
79122: PUSH
79123: LD_INT 0
79125: PUSH
79126: EMPTY
79127: LIST
79128: LIST
79129: PUSH
79130: LD_INT 3
79132: PUSH
79133: LD_INT 1
79135: NEG
79136: PUSH
79137: EMPTY
79138: LIST
79139: LIST
79140: PUSH
79141: LD_INT 4
79143: PUSH
79144: LD_INT 0
79146: PUSH
79147: EMPTY
79148: LIST
79149: LIST
79150: PUSH
79151: LD_INT 4
79153: PUSH
79154: LD_INT 1
79156: PUSH
79157: EMPTY
79158: LIST
79159: LIST
79160: PUSH
79161: LD_INT 3
79163: PUSH
79164: LD_INT 1
79166: PUSH
79167: EMPTY
79168: LIST
79169: LIST
79170: PUSH
79171: LD_INT 2
79173: PUSH
79174: LD_INT 0
79176: PUSH
79177: EMPTY
79178: LIST
79179: LIST
79180: PUSH
79181: LD_INT 2
79183: PUSH
79184: LD_INT 1
79186: NEG
79187: PUSH
79188: EMPTY
79189: LIST
79190: LIST
79191: PUSH
79192: LD_INT 2
79194: PUSH
79195: LD_INT 2
79197: NEG
79198: PUSH
79199: EMPTY
79200: LIST
79201: LIST
79202: PUSH
79203: LD_INT 4
79205: PUSH
79206: LD_INT 2
79208: PUSH
79209: EMPTY
79210: LIST
79211: LIST
79212: PUSH
79213: LD_INT 4
79215: PUSH
79216: LD_INT 4
79218: PUSH
79219: EMPTY
79220: LIST
79221: LIST
79222: PUSH
79223: LD_INT 4
79225: PUSH
79226: LD_INT 3
79228: PUSH
79229: EMPTY
79230: LIST
79231: LIST
79232: PUSH
79233: LD_INT 5
79235: PUSH
79236: LD_INT 4
79238: PUSH
79239: EMPTY
79240: LIST
79241: LIST
79242: PUSH
79243: LD_INT 5
79245: PUSH
79246: LD_INT 5
79248: PUSH
79249: EMPTY
79250: LIST
79251: LIST
79252: PUSH
79253: LD_INT 4
79255: PUSH
79256: LD_INT 5
79258: PUSH
79259: EMPTY
79260: LIST
79261: LIST
79262: PUSH
79263: LD_INT 3
79265: PUSH
79266: LD_INT 4
79268: PUSH
79269: EMPTY
79270: LIST
79271: LIST
79272: PUSH
79273: LD_INT 3
79275: PUSH
79276: LD_INT 3
79278: PUSH
79279: EMPTY
79280: LIST
79281: LIST
79282: PUSH
79283: LD_INT 5
79285: PUSH
79286: LD_INT 3
79288: PUSH
79289: EMPTY
79290: LIST
79291: LIST
79292: PUSH
79293: LD_INT 3
79295: PUSH
79296: LD_INT 5
79298: PUSH
79299: EMPTY
79300: LIST
79301: LIST
79302: PUSH
79303: EMPTY
79304: LIST
79305: LIST
79306: LIST
79307: LIST
79308: LIST
79309: LIST
79310: LIST
79311: LIST
79312: LIST
79313: LIST
79314: LIST
79315: LIST
79316: LIST
79317: LIST
79318: LIST
79319: LIST
79320: LIST
79321: LIST
79322: LIST
79323: LIST
79324: LIST
79325: LIST
79326: LIST
79327: LIST
79328: LIST
79329: LIST
79330: LIST
79331: LIST
79332: LIST
79333: LIST
79334: LIST
79335: LIST
79336: LIST
79337: LIST
79338: LIST
79339: LIST
79340: LIST
79341: LIST
79342: LIST
79343: LIST
79344: LIST
79345: LIST
79346: LIST
79347: LIST
79348: LIST
79349: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
79350: LD_ADDR_VAR 0 33
79354: PUSH
79355: LD_INT 4
79357: NEG
79358: PUSH
79359: LD_INT 4
79361: NEG
79362: PUSH
79363: EMPTY
79364: LIST
79365: LIST
79366: PUSH
79367: LD_INT 4
79369: NEG
79370: PUSH
79371: LD_INT 5
79373: NEG
79374: PUSH
79375: EMPTY
79376: LIST
79377: LIST
79378: PUSH
79379: LD_INT 3
79381: NEG
79382: PUSH
79383: LD_INT 4
79385: NEG
79386: PUSH
79387: EMPTY
79388: LIST
79389: LIST
79390: PUSH
79391: LD_INT 3
79393: NEG
79394: PUSH
79395: LD_INT 3
79397: NEG
79398: PUSH
79399: EMPTY
79400: LIST
79401: LIST
79402: PUSH
79403: LD_INT 4
79405: NEG
79406: PUSH
79407: LD_INT 3
79409: NEG
79410: PUSH
79411: EMPTY
79412: LIST
79413: LIST
79414: PUSH
79415: LD_INT 5
79417: NEG
79418: PUSH
79419: LD_INT 4
79421: NEG
79422: PUSH
79423: EMPTY
79424: LIST
79425: LIST
79426: PUSH
79427: LD_INT 5
79429: NEG
79430: PUSH
79431: LD_INT 5
79433: NEG
79434: PUSH
79435: EMPTY
79436: LIST
79437: LIST
79438: PUSH
79439: LD_INT 3
79441: NEG
79442: PUSH
79443: LD_INT 5
79445: NEG
79446: PUSH
79447: EMPTY
79448: LIST
79449: LIST
79450: PUSH
79451: LD_INT 5
79453: NEG
79454: PUSH
79455: LD_INT 3
79457: NEG
79458: PUSH
79459: EMPTY
79460: LIST
79461: LIST
79462: PUSH
79463: LD_INT 0
79465: PUSH
79466: LD_INT 3
79468: NEG
79469: PUSH
79470: EMPTY
79471: LIST
79472: LIST
79473: PUSH
79474: LD_INT 0
79476: PUSH
79477: LD_INT 4
79479: NEG
79480: PUSH
79481: EMPTY
79482: LIST
79483: LIST
79484: PUSH
79485: LD_INT 1
79487: PUSH
79488: LD_INT 3
79490: NEG
79491: PUSH
79492: EMPTY
79493: LIST
79494: LIST
79495: PUSH
79496: LD_INT 1
79498: PUSH
79499: LD_INT 2
79501: NEG
79502: PUSH
79503: EMPTY
79504: LIST
79505: LIST
79506: PUSH
79507: LD_INT 0
79509: PUSH
79510: LD_INT 2
79512: NEG
79513: PUSH
79514: EMPTY
79515: LIST
79516: LIST
79517: PUSH
79518: LD_INT 1
79520: NEG
79521: PUSH
79522: LD_INT 3
79524: NEG
79525: PUSH
79526: EMPTY
79527: LIST
79528: LIST
79529: PUSH
79530: LD_INT 1
79532: NEG
79533: PUSH
79534: LD_INT 4
79536: NEG
79537: PUSH
79538: EMPTY
79539: LIST
79540: LIST
79541: PUSH
79542: LD_INT 2
79544: PUSH
79545: LD_INT 2
79547: NEG
79548: PUSH
79549: EMPTY
79550: LIST
79551: LIST
79552: PUSH
79553: LD_INT 2
79555: NEG
79556: PUSH
79557: LD_INT 4
79559: NEG
79560: PUSH
79561: EMPTY
79562: LIST
79563: LIST
79564: PUSH
79565: LD_INT 4
79567: PUSH
79568: LD_INT 0
79570: PUSH
79571: EMPTY
79572: LIST
79573: LIST
79574: PUSH
79575: LD_INT 4
79577: PUSH
79578: LD_INT 1
79580: NEG
79581: PUSH
79582: EMPTY
79583: LIST
79584: LIST
79585: PUSH
79586: LD_INT 5
79588: PUSH
79589: LD_INT 0
79591: PUSH
79592: EMPTY
79593: LIST
79594: LIST
79595: PUSH
79596: LD_INT 5
79598: PUSH
79599: LD_INT 1
79601: PUSH
79602: EMPTY
79603: LIST
79604: LIST
79605: PUSH
79606: LD_INT 4
79608: PUSH
79609: LD_INT 1
79611: PUSH
79612: EMPTY
79613: LIST
79614: LIST
79615: PUSH
79616: LD_INT 3
79618: PUSH
79619: LD_INT 0
79621: PUSH
79622: EMPTY
79623: LIST
79624: LIST
79625: PUSH
79626: LD_INT 3
79628: PUSH
79629: LD_INT 1
79631: NEG
79632: PUSH
79633: EMPTY
79634: LIST
79635: LIST
79636: PUSH
79637: LD_INT 3
79639: PUSH
79640: LD_INT 2
79642: NEG
79643: PUSH
79644: EMPTY
79645: LIST
79646: LIST
79647: PUSH
79648: LD_INT 5
79650: PUSH
79651: LD_INT 2
79653: PUSH
79654: EMPTY
79655: LIST
79656: LIST
79657: PUSH
79658: LD_INT 3
79660: PUSH
79661: LD_INT 3
79663: PUSH
79664: EMPTY
79665: LIST
79666: LIST
79667: PUSH
79668: LD_INT 3
79670: PUSH
79671: LD_INT 2
79673: PUSH
79674: EMPTY
79675: LIST
79676: LIST
79677: PUSH
79678: LD_INT 4
79680: PUSH
79681: LD_INT 3
79683: PUSH
79684: EMPTY
79685: LIST
79686: LIST
79687: PUSH
79688: LD_INT 4
79690: PUSH
79691: LD_INT 4
79693: PUSH
79694: EMPTY
79695: LIST
79696: LIST
79697: PUSH
79698: LD_INT 3
79700: PUSH
79701: LD_INT 4
79703: PUSH
79704: EMPTY
79705: LIST
79706: LIST
79707: PUSH
79708: LD_INT 2
79710: PUSH
79711: LD_INT 3
79713: PUSH
79714: EMPTY
79715: LIST
79716: LIST
79717: PUSH
79718: LD_INT 2
79720: PUSH
79721: LD_INT 2
79723: PUSH
79724: EMPTY
79725: LIST
79726: LIST
79727: PUSH
79728: LD_INT 4
79730: PUSH
79731: LD_INT 2
79733: PUSH
79734: EMPTY
79735: LIST
79736: LIST
79737: PUSH
79738: LD_INT 2
79740: PUSH
79741: LD_INT 4
79743: PUSH
79744: EMPTY
79745: LIST
79746: LIST
79747: PUSH
79748: LD_INT 0
79750: PUSH
79751: LD_INT 4
79753: PUSH
79754: EMPTY
79755: LIST
79756: LIST
79757: PUSH
79758: LD_INT 0
79760: PUSH
79761: LD_INT 3
79763: PUSH
79764: EMPTY
79765: LIST
79766: LIST
79767: PUSH
79768: LD_INT 1
79770: PUSH
79771: LD_INT 4
79773: PUSH
79774: EMPTY
79775: LIST
79776: LIST
79777: PUSH
79778: LD_INT 1
79780: PUSH
79781: LD_INT 5
79783: PUSH
79784: EMPTY
79785: LIST
79786: LIST
79787: PUSH
79788: LD_INT 0
79790: PUSH
79791: LD_INT 5
79793: PUSH
79794: EMPTY
79795: LIST
79796: LIST
79797: PUSH
79798: LD_INT 1
79800: NEG
79801: PUSH
79802: LD_INT 4
79804: PUSH
79805: EMPTY
79806: LIST
79807: LIST
79808: PUSH
79809: LD_INT 1
79811: NEG
79812: PUSH
79813: LD_INT 3
79815: PUSH
79816: EMPTY
79817: LIST
79818: LIST
79819: PUSH
79820: LD_INT 2
79822: PUSH
79823: LD_INT 5
79825: PUSH
79826: EMPTY
79827: LIST
79828: LIST
79829: PUSH
79830: LD_INT 2
79832: NEG
79833: PUSH
79834: LD_INT 3
79836: PUSH
79837: EMPTY
79838: LIST
79839: LIST
79840: PUSH
79841: EMPTY
79842: LIST
79843: LIST
79844: LIST
79845: LIST
79846: LIST
79847: LIST
79848: LIST
79849: LIST
79850: LIST
79851: LIST
79852: LIST
79853: LIST
79854: LIST
79855: LIST
79856: LIST
79857: LIST
79858: LIST
79859: LIST
79860: LIST
79861: LIST
79862: LIST
79863: LIST
79864: LIST
79865: LIST
79866: LIST
79867: LIST
79868: LIST
79869: LIST
79870: LIST
79871: LIST
79872: LIST
79873: LIST
79874: LIST
79875: LIST
79876: LIST
79877: LIST
79878: LIST
79879: LIST
79880: LIST
79881: LIST
79882: LIST
79883: LIST
79884: LIST
79885: LIST
79886: LIST
79887: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
79888: LD_ADDR_VAR 0 34
79892: PUSH
79893: LD_INT 0
79895: PUSH
79896: LD_INT 4
79898: NEG
79899: PUSH
79900: EMPTY
79901: LIST
79902: LIST
79903: PUSH
79904: LD_INT 0
79906: PUSH
79907: LD_INT 5
79909: NEG
79910: PUSH
79911: EMPTY
79912: LIST
79913: LIST
79914: PUSH
79915: LD_INT 1
79917: PUSH
79918: LD_INT 4
79920: NEG
79921: PUSH
79922: EMPTY
79923: LIST
79924: LIST
79925: PUSH
79926: LD_INT 1
79928: PUSH
79929: LD_INT 3
79931: NEG
79932: PUSH
79933: EMPTY
79934: LIST
79935: LIST
79936: PUSH
79937: LD_INT 0
79939: PUSH
79940: LD_INT 3
79942: NEG
79943: PUSH
79944: EMPTY
79945: LIST
79946: LIST
79947: PUSH
79948: LD_INT 1
79950: NEG
79951: PUSH
79952: LD_INT 4
79954: NEG
79955: PUSH
79956: EMPTY
79957: LIST
79958: LIST
79959: PUSH
79960: LD_INT 1
79962: NEG
79963: PUSH
79964: LD_INT 5
79966: NEG
79967: PUSH
79968: EMPTY
79969: LIST
79970: LIST
79971: PUSH
79972: LD_INT 2
79974: PUSH
79975: LD_INT 3
79977: NEG
79978: PUSH
79979: EMPTY
79980: LIST
79981: LIST
79982: PUSH
79983: LD_INT 2
79985: NEG
79986: PUSH
79987: LD_INT 5
79989: NEG
79990: PUSH
79991: EMPTY
79992: LIST
79993: LIST
79994: PUSH
79995: LD_INT 3
79997: PUSH
79998: LD_INT 0
80000: PUSH
80001: EMPTY
80002: LIST
80003: LIST
80004: PUSH
80005: LD_INT 3
80007: PUSH
80008: LD_INT 1
80010: NEG
80011: PUSH
80012: EMPTY
80013: LIST
80014: LIST
80015: PUSH
80016: LD_INT 4
80018: PUSH
80019: LD_INT 0
80021: PUSH
80022: EMPTY
80023: LIST
80024: LIST
80025: PUSH
80026: LD_INT 4
80028: PUSH
80029: LD_INT 1
80031: PUSH
80032: EMPTY
80033: LIST
80034: LIST
80035: PUSH
80036: LD_INT 3
80038: PUSH
80039: LD_INT 1
80041: PUSH
80042: EMPTY
80043: LIST
80044: LIST
80045: PUSH
80046: LD_INT 2
80048: PUSH
80049: LD_INT 0
80051: PUSH
80052: EMPTY
80053: LIST
80054: LIST
80055: PUSH
80056: LD_INT 2
80058: PUSH
80059: LD_INT 1
80061: NEG
80062: PUSH
80063: EMPTY
80064: LIST
80065: LIST
80066: PUSH
80067: LD_INT 2
80069: PUSH
80070: LD_INT 2
80072: NEG
80073: PUSH
80074: EMPTY
80075: LIST
80076: LIST
80077: PUSH
80078: LD_INT 4
80080: PUSH
80081: LD_INT 2
80083: PUSH
80084: EMPTY
80085: LIST
80086: LIST
80087: PUSH
80088: LD_INT 4
80090: PUSH
80091: LD_INT 4
80093: PUSH
80094: EMPTY
80095: LIST
80096: LIST
80097: PUSH
80098: LD_INT 4
80100: PUSH
80101: LD_INT 3
80103: PUSH
80104: EMPTY
80105: LIST
80106: LIST
80107: PUSH
80108: LD_INT 5
80110: PUSH
80111: LD_INT 4
80113: PUSH
80114: EMPTY
80115: LIST
80116: LIST
80117: PUSH
80118: LD_INT 5
80120: PUSH
80121: LD_INT 5
80123: PUSH
80124: EMPTY
80125: LIST
80126: LIST
80127: PUSH
80128: LD_INT 4
80130: PUSH
80131: LD_INT 5
80133: PUSH
80134: EMPTY
80135: LIST
80136: LIST
80137: PUSH
80138: LD_INT 3
80140: PUSH
80141: LD_INT 4
80143: PUSH
80144: EMPTY
80145: LIST
80146: LIST
80147: PUSH
80148: LD_INT 3
80150: PUSH
80151: LD_INT 3
80153: PUSH
80154: EMPTY
80155: LIST
80156: LIST
80157: PUSH
80158: LD_INT 5
80160: PUSH
80161: LD_INT 3
80163: PUSH
80164: EMPTY
80165: LIST
80166: LIST
80167: PUSH
80168: LD_INT 3
80170: PUSH
80171: LD_INT 5
80173: PUSH
80174: EMPTY
80175: LIST
80176: LIST
80177: PUSH
80178: LD_INT 0
80180: PUSH
80181: LD_INT 3
80183: PUSH
80184: EMPTY
80185: LIST
80186: LIST
80187: PUSH
80188: LD_INT 0
80190: PUSH
80191: LD_INT 2
80193: PUSH
80194: EMPTY
80195: LIST
80196: LIST
80197: PUSH
80198: LD_INT 1
80200: PUSH
80201: LD_INT 3
80203: PUSH
80204: EMPTY
80205: LIST
80206: LIST
80207: PUSH
80208: LD_INT 1
80210: PUSH
80211: LD_INT 4
80213: PUSH
80214: EMPTY
80215: LIST
80216: LIST
80217: PUSH
80218: LD_INT 0
80220: PUSH
80221: LD_INT 4
80223: PUSH
80224: EMPTY
80225: LIST
80226: LIST
80227: PUSH
80228: LD_INT 1
80230: NEG
80231: PUSH
80232: LD_INT 3
80234: PUSH
80235: EMPTY
80236: LIST
80237: LIST
80238: PUSH
80239: LD_INT 1
80241: NEG
80242: PUSH
80243: LD_INT 2
80245: PUSH
80246: EMPTY
80247: LIST
80248: LIST
80249: PUSH
80250: LD_INT 2
80252: PUSH
80253: LD_INT 4
80255: PUSH
80256: EMPTY
80257: LIST
80258: LIST
80259: PUSH
80260: LD_INT 2
80262: NEG
80263: PUSH
80264: LD_INT 2
80266: PUSH
80267: EMPTY
80268: LIST
80269: LIST
80270: PUSH
80271: LD_INT 4
80273: NEG
80274: PUSH
80275: LD_INT 0
80277: PUSH
80278: EMPTY
80279: LIST
80280: LIST
80281: PUSH
80282: LD_INT 4
80284: NEG
80285: PUSH
80286: LD_INT 1
80288: NEG
80289: PUSH
80290: EMPTY
80291: LIST
80292: LIST
80293: PUSH
80294: LD_INT 3
80296: NEG
80297: PUSH
80298: LD_INT 0
80300: PUSH
80301: EMPTY
80302: LIST
80303: LIST
80304: PUSH
80305: LD_INT 3
80307: NEG
80308: PUSH
80309: LD_INT 1
80311: PUSH
80312: EMPTY
80313: LIST
80314: LIST
80315: PUSH
80316: LD_INT 4
80318: NEG
80319: PUSH
80320: LD_INT 1
80322: PUSH
80323: EMPTY
80324: LIST
80325: LIST
80326: PUSH
80327: LD_INT 5
80329: NEG
80330: PUSH
80331: LD_INT 0
80333: PUSH
80334: EMPTY
80335: LIST
80336: LIST
80337: PUSH
80338: LD_INT 5
80340: NEG
80341: PUSH
80342: LD_INT 1
80344: NEG
80345: PUSH
80346: EMPTY
80347: LIST
80348: LIST
80349: PUSH
80350: LD_INT 5
80352: NEG
80353: PUSH
80354: LD_INT 2
80356: NEG
80357: PUSH
80358: EMPTY
80359: LIST
80360: LIST
80361: PUSH
80362: LD_INT 3
80364: NEG
80365: PUSH
80366: LD_INT 2
80368: PUSH
80369: EMPTY
80370: LIST
80371: LIST
80372: PUSH
80373: EMPTY
80374: LIST
80375: LIST
80376: LIST
80377: LIST
80378: LIST
80379: LIST
80380: LIST
80381: LIST
80382: LIST
80383: LIST
80384: LIST
80385: LIST
80386: LIST
80387: LIST
80388: LIST
80389: LIST
80390: LIST
80391: LIST
80392: LIST
80393: LIST
80394: LIST
80395: LIST
80396: LIST
80397: LIST
80398: LIST
80399: LIST
80400: LIST
80401: LIST
80402: LIST
80403: LIST
80404: LIST
80405: LIST
80406: LIST
80407: LIST
80408: LIST
80409: LIST
80410: LIST
80411: LIST
80412: LIST
80413: LIST
80414: LIST
80415: LIST
80416: LIST
80417: LIST
80418: LIST
80419: ST_TO_ADDR
// end ; end ;
80420: GO 80423
80422: POP
// case btype of b_depot , b_warehouse :
80423: LD_VAR 0 1
80427: PUSH
80428: LD_INT 0
80430: DOUBLE
80431: EQUAL
80432: IFTRUE 80442
80434: LD_INT 1
80436: DOUBLE
80437: EQUAL
80438: IFTRUE 80442
80440: GO 80643
80442: POP
// case nation of nation_american :
80443: LD_VAR 0 5
80447: PUSH
80448: LD_INT 1
80450: DOUBLE
80451: EQUAL
80452: IFTRUE 80456
80454: GO 80512
80456: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
80457: LD_ADDR_VAR 0 9
80461: PUSH
80462: LD_VAR 0 11
80466: PUSH
80467: LD_VAR 0 12
80471: PUSH
80472: LD_VAR 0 13
80476: PUSH
80477: LD_VAR 0 14
80481: PUSH
80482: LD_VAR 0 15
80486: PUSH
80487: LD_VAR 0 16
80491: PUSH
80492: EMPTY
80493: LIST
80494: LIST
80495: LIST
80496: LIST
80497: LIST
80498: LIST
80499: PUSH
80500: LD_VAR 0 4
80504: PUSH
80505: LD_INT 1
80507: PLUS
80508: ARRAY
80509: ST_TO_ADDR
80510: GO 80641
80512: LD_INT 2
80514: DOUBLE
80515: EQUAL
80516: IFTRUE 80520
80518: GO 80576
80520: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
80521: LD_ADDR_VAR 0 9
80525: PUSH
80526: LD_VAR 0 17
80530: PUSH
80531: LD_VAR 0 18
80535: PUSH
80536: LD_VAR 0 19
80540: PUSH
80541: LD_VAR 0 20
80545: PUSH
80546: LD_VAR 0 21
80550: PUSH
80551: LD_VAR 0 22
80555: PUSH
80556: EMPTY
80557: LIST
80558: LIST
80559: LIST
80560: LIST
80561: LIST
80562: LIST
80563: PUSH
80564: LD_VAR 0 4
80568: PUSH
80569: LD_INT 1
80571: PLUS
80572: ARRAY
80573: ST_TO_ADDR
80574: GO 80641
80576: LD_INT 3
80578: DOUBLE
80579: EQUAL
80580: IFTRUE 80584
80582: GO 80640
80584: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
80585: LD_ADDR_VAR 0 9
80589: PUSH
80590: LD_VAR 0 23
80594: PUSH
80595: LD_VAR 0 24
80599: PUSH
80600: LD_VAR 0 25
80604: PUSH
80605: LD_VAR 0 26
80609: PUSH
80610: LD_VAR 0 27
80614: PUSH
80615: LD_VAR 0 28
80619: PUSH
80620: EMPTY
80621: LIST
80622: LIST
80623: LIST
80624: LIST
80625: LIST
80626: LIST
80627: PUSH
80628: LD_VAR 0 4
80632: PUSH
80633: LD_INT 1
80635: PLUS
80636: ARRAY
80637: ST_TO_ADDR
80638: GO 80641
80640: POP
80641: GO 81196
80643: LD_INT 2
80645: DOUBLE
80646: EQUAL
80647: IFTRUE 80657
80649: LD_INT 3
80651: DOUBLE
80652: EQUAL
80653: IFTRUE 80657
80655: GO 80713
80657: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
80658: LD_ADDR_VAR 0 9
80662: PUSH
80663: LD_VAR 0 29
80667: PUSH
80668: LD_VAR 0 30
80672: PUSH
80673: LD_VAR 0 31
80677: PUSH
80678: LD_VAR 0 32
80682: PUSH
80683: LD_VAR 0 33
80687: PUSH
80688: LD_VAR 0 34
80692: PUSH
80693: EMPTY
80694: LIST
80695: LIST
80696: LIST
80697: LIST
80698: LIST
80699: LIST
80700: PUSH
80701: LD_VAR 0 4
80705: PUSH
80706: LD_INT 1
80708: PLUS
80709: ARRAY
80710: ST_TO_ADDR
80711: GO 81196
80713: LD_INT 16
80715: DOUBLE
80716: EQUAL
80717: IFTRUE 80775
80719: LD_INT 17
80721: DOUBLE
80722: EQUAL
80723: IFTRUE 80775
80725: LD_INT 18
80727: DOUBLE
80728: EQUAL
80729: IFTRUE 80775
80731: LD_INT 19
80733: DOUBLE
80734: EQUAL
80735: IFTRUE 80775
80737: LD_INT 22
80739: DOUBLE
80740: EQUAL
80741: IFTRUE 80775
80743: LD_INT 20
80745: DOUBLE
80746: EQUAL
80747: IFTRUE 80775
80749: LD_INT 21
80751: DOUBLE
80752: EQUAL
80753: IFTRUE 80775
80755: LD_INT 23
80757: DOUBLE
80758: EQUAL
80759: IFTRUE 80775
80761: LD_INT 24
80763: DOUBLE
80764: EQUAL
80765: IFTRUE 80775
80767: LD_INT 25
80769: DOUBLE
80770: EQUAL
80771: IFTRUE 80775
80773: GO 80831
80775: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
80776: LD_ADDR_VAR 0 9
80780: PUSH
80781: LD_VAR 0 35
80785: PUSH
80786: LD_VAR 0 36
80790: PUSH
80791: LD_VAR 0 37
80795: PUSH
80796: LD_VAR 0 38
80800: PUSH
80801: LD_VAR 0 39
80805: PUSH
80806: LD_VAR 0 40
80810: PUSH
80811: EMPTY
80812: LIST
80813: LIST
80814: LIST
80815: LIST
80816: LIST
80817: LIST
80818: PUSH
80819: LD_VAR 0 4
80823: PUSH
80824: LD_INT 1
80826: PLUS
80827: ARRAY
80828: ST_TO_ADDR
80829: GO 81196
80831: LD_INT 6
80833: DOUBLE
80834: EQUAL
80835: IFTRUE 80887
80837: LD_INT 7
80839: DOUBLE
80840: EQUAL
80841: IFTRUE 80887
80843: LD_INT 8
80845: DOUBLE
80846: EQUAL
80847: IFTRUE 80887
80849: LD_INT 13
80851: DOUBLE
80852: EQUAL
80853: IFTRUE 80887
80855: LD_INT 12
80857: DOUBLE
80858: EQUAL
80859: IFTRUE 80887
80861: LD_INT 15
80863: DOUBLE
80864: EQUAL
80865: IFTRUE 80887
80867: LD_INT 11
80869: DOUBLE
80870: EQUAL
80871: IFTRUE 80887
80873: LD_INT 14
80875: DOUBLE
80876: EQUAL
80877: IFTRUE 80887
80879: LD_INT 10
80881: DOUBLE
80882: EQUAL
80883: IFTRUE 80887
80885: GO 80943
80887: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
80888: LD_ADDR_VAR 0 9
80892: PUSH
80893: LD_VAR 0 41
80897: PUSH
80898: LD_VAR 0 42
80902: PUSH
80903: LD_VAR 0 43
80907: PUSH
80908: LD_VAR 0 44
80912: PUSH
80913: LD_VAR 0 45
80917: PUSH
80918: LD_VAR 0 46
80922: PUSH
80923: EMPTY
80924: LIST
80925: LIST
80926: LIST
80927: LIST
80928: LIST
80929: LIST
80930: PUSH
80931: LD_VAR 0 4
80935: PUSH
80936: LD_INT 1
80938: PLUS
80939: ARRAY
80940: ST_TO_ADDR
80941: GO 81196
80943: LD_INT 36
80945: DOUBLE
80946: EQUAL
80947: IFTRUE 80951
80949: GO 81007
80951: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
80952: LD_ADDR_VAR 0 9
80956: PUSH
80957: LD_VAR 0 47
80961: PUSH
80962: LD_VAR 0 48
80966: PUSH
80967: LD_VAR 0 49
80971: PUSH
80972: LD_VAR 0 50
80976: PUSH
80977: LD_VAR 0 51
80981: PUSH
80982: LD_VAR 0 52
80986: PUSH
80987: EMPTY
80988: LIST
80989: LIST
80990: LIST
80991: LIST
80992: LIST
80993: LIST
80994: PUSH
80995: LD_VAR 0 4
80999: PUSH
81000: LD_INT 1
81002: PLUS
81003: ARRAY
81004: ST_TO_ADDR
81005: GO 81196
81007: LD_INT 4
81009: DOUBLE
81010: EQUAL
81011: IFTRUE 81033
81013: LD_INT 5
81015: DOUBLE
81016: EQUAL
81017: IFTRUE 81033
81019: LD_INT 34
81021: DOUBLE
81022: EQUAL
81023: IFTRUE 81033
81025: LD_INT 37
81027: DOUBLE
81028: EQUAL
81029: IFTRUE 81033
81031: GO 81089
81033: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
81034: LD_ADDR_VAR 0 9
81038: PUSH
81039: LD_VAR 0 53
81043: PUSH
81044: LD_VAR 0 54
81048: PUSH
81049: LD_VAR 0 55
81053: PUSH
81054: LD_VAR 0 56
81058: PUSH
81059: LD_VAR 0 57
81063: PUSH
81064: LD_VAR 0 58
81068: PUSH
81069: EMPTY
81070: LIST
81071: LIST
81072: LIST
81073: LIST
81074: LIST
81075: LIST
81076: PUSH
81077: LD_VAR 0 4
81081: PUSH
81082: LD_INT 1
81084: PLUS
81085: ARRAY
81086: ST_TO_ADDR
81087: GO 81196
81089: LD_INT 31
81091: DOUBLE
81092: EQUAL
81093: IFTRUE 81139
81095: LD_INT 32
81097: DOUBLE
81098: EQUAL
81099: IFTRUE 81139
81101: LD_INT 33
81103: DOUBLE
81104: EQUAL
81105: IFTRUE 81139
81107: LD_INT 27
81109: DOUBLE
81110: EQUAL
81111: IFTRUE 81139
81113: LD_INT 26
81115: DOUBLE
81116: EQUAL
81117: IFTRUE 81139
81119: LD_INT 28
81121: DOUBLE
81122: EQUAL
81123: IFTRUE 81139
81125: LD_INT 29
81127: DOUBLE
81128: EQUAL
81129: IFTRUE 81139
81131: LD_INT 30
81133: DOUBLE
81134: EQUAL
81135: IFTRUE 81139
81137: GO 81195
81139: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
81140: LD_ADDR_VAR 0 9
81144: PUSH
81145: LD_VAR 0 59
81149: PUSH
81150: LD_VAR 0 60
81154: PUSH
81155: LD_VAR 0 61
81159: PUSH
81160: LD_VAR 0 62
81164: PUSH
81165: LD_VAR 0 63
81169: PUSH
81170: LD_VAR 0 64
81174: PUSH
81175: EMPTY
81176: LIST
81177: LIST
81178: LIST
81179: LIST
81180: LIST
81181: LIST
81182: PUSH
81183: LD_VAR 0 4
81187: PUSH
81188: LD_INT 1
81190: PLUS
81191: ARRAY
81192: ST_TO_ADDR
81193: GO 81196
81195: POP
// temp_list2 = [ ] ;
81196: LD_ADDR_VAR 0 10
81200: PUSH
81201: EMPTY
81202: ST_TO_ADDR
// for i in temp_list do
81203: LD_ADDR_VAR 0 8
81207: PUSH
81208: LD_VAR 0 9
81212: PUSH
81213: FOR_IN
81214: IFFALSE 81266
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
81216: LD_ADDR_VAR 0 10
81220: PUSH
81221: LD_VAR 0 10
81225: PUSH
81226: LD_VAR 0 8
81230: PUSH
81231: LD_INT 1
81233: ARRAY
81234: PUSH
81235: LD_VAR 0 2
81239: PLUS
81240: PUSH
81241: LD_VAR 0 8
81245: PUSH
81246: LD_INT 2
81248: ARRAY
81249: PUSH
81250: LD_VAR 0 3
81254: PLUS
81255: PUSH
81256: EMPTY
81257: LIST
81258: LIST
81259: PUSH
81260: EMPTY
81261: LIST
81262: ADD
81263: ST_TO_ADDR
81264: GO 81213
81266: POP
81267: POP
// result = temp_list2 ;
81268: LD_ADDR_VAR 0 7
81272: PUSH
81273: LD_VAR 0 10
81277: ST_TO_ADDR
// end ;
81278: LD_VAR 0 7
81282: RET
// export function EnemyInRange ( unit , dist ) ; begin
81283: LD_INT 0
81285: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
81286: LD_ADDR_VAR 0 3
81290: PUSH
81291: LD_VAR 0 1
81295: PPUSH
81296: CALL_OW 255
81300: PPUSH
81301: LD_VAR 0 1
81305: PPUSH
81306: CALL_OW 250
81310: PPUSH
81311: LD_VAR 0 1
81315: PPUSH
81316: CALL_OW 251
81320: PPUSH
81321: LD_VAR 0 2
81325: PPUSH
81326: CALL 54685 0 4
81330: PUSH
81331: LD_INT 4
81333: ARRAY
81334: ST_TO_ADDR
// end ;
81335: LD_VAR 0 3
81339: RET
// export function PlayerSeeMe ( unit ) ; begin
81340: LD_INT 0
81342: PPUSH
// result := See ( your_side , unit ) ;
81343: LD_ADDR_VAR 0 2
81347: PUSH
81348: LD_OWVAR 2
81352: PPUSH
81353: LD_VAR 0 1
81357: PPUSH
81358: CALL_OW 292
81362: ST_TO_ADDR
// end ;
81363: LD_VAR 0 2
81367: RET
// export function ReverseDir ( unit ) ; begin
81368: LD_INT 0
81370: PPUSH
// if not unit then
81371: LD_VAR 0 1
81375: NOT
81376: IFFALSE 81380
// exit ;
81378: GO 81403
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
81380: LD_ADDR_VAR 0 2
81384: PUSH
81385: LD_VAR 0 1
81389: PPUSH
81390: CALL_OW 254
81394: PUSH
81395: LD_INT 3
81397: PLUS
81398: PUSH
81399: LD_INT 6
81401: MOD
81402: ST_TO_ADDR
// end ;
81403: LD_VAR 0 2
81407: RET
// export function ReverseArray ( array ) ; var i ; begin
81408: LD_INT 0
81410: PPUSH
81411: PPUSH
// if not array then
81412: LD_VAR 0 1
81416: NOT
81417: IFFALSE 81421
// exit ;
81419: GO 81476
// result := [ ] ;
81421: LD_ADDR_VAR 0 2
81425: PUSH
81426: EMPTY
81427: ST_TO_ADDR
// for i := array downto 1 do
81428: LD_ADDR_VAR 0 3
81432: PUSH
81433: DOUBLE
81434: LD_VAR 0 1
81438: INC
81439: ST_TO_ADDR
81440: LD_INT 1
81442: PUSH
81443: FOR_DOWNTO
81444: IFFALSE 81474
// result := Join ( result , array [ i ] ) ;
81446: LD_ADDR_VAR 0 2
81450: PUSH
81451: LD_VAR 0 2
81455: PPUSH
81456: LD_VAR 0 1
81460: PUSH
81461: LD_VAR 0 3
81465: ARRAY
81466: PPUSH
81467: CALL 86101 0 2
81471: ST_TO_ADDR
81472: GO 81443
81474: POP
81475: POP
// end ;
81476: LD_VAR 0 2
81480: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
81481: LD_INT 0
81483: PPUSH
81484: PPUSH
81485: PPUSH
81486: PPUSH
81487: PPUSH
81488: PPUSH
// if not unit or not hexes then
81489: LD_VAR 0 1
81493: NOT
81494: PUSH
81495: LD_VAR 0 2
81499: NOT
81500: OR
81501: IFFALSE 81505
// exit ;
81503: GO 81628
// dist := 9999 ;
81505: LD_ADDR_VAR 0 5
81509: PUSH
81510: LD_INT 9999
81512: ST_TO_ADDR
// for i = 1 to hexes do
81513: LD_ADDR_VAR 0 4
81517: PUSH
81518: DOUBLE
81519: LD_INT 1
81521: DEC
81522: ST_TO_ADDR
81523: LD_VAR 0 2
81527: PUSH
81528: FOR_TO
81529: IFFALSE 81616
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
81531: LD_ADDR_VAR 0 6
81535: PUSH
81536: LD_VAR 0 1
81540: PPUSH
81541: LD_VAR 0 2
81545: PUSH
81546: LD_VAR 0 4
81550: ARRAY
81551: PUSH
81552: LD_INT 1
81554: ARRAY
81555: PPUSH
81556: LD_VAR 0 2
81560: PUSH
81561: LD_VAR 0 4
81565: ARRAY
81566: PUSH
81567: LD_INT 2
81569: ARRAY
81570: PPUSH
81571: CALL_OW 297
81575: ST_TO_ADDR
// if tdist < dist then
81576: LD_VAR 0 6
81580: PUSH
81581: LD_VAR 0 5
81585: LESS
81586: IFFALSE 81614
// begin hex := hexes [ i ] ;
81588: LD_ADDR_VAR 0 8
81592: PUSH
81593: LD_VAR 0 2
81597: PUSH
81598: LD_VAR 0 4
81602: ARRAY
81603: ST_TO_ADDR
// dist := tdist ;
81604: LD_ADDR_VAR 0 5
81608: PUSH
81609: LD_VAR 0 6
81613: ST_TO_ADDR
// end ; end ;
81614: GO 81528
81616: POP
81617: POP
// result := hex ;
81618: LD_ADDR_VAR 0 3
81622: PUSH
81623: LD_VAR 0 8
81627: ST_TO_ADDR
// end ;
81628: LD_VAR 0 3
81632: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
81633: LD_INT 0
81635: PPUSH
81636: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
81637: LD_VAR 0 1
81641: NOT
81642: PUSH
81643: LD_VAR 0 1
81647: PUSH
81648: LD_INT 21
81650: PUSH
81651: LD_INT 2
81653: PUSH
81654: EMPTY
81655: LIST
81656: LIST
81657: PUSH
81658: LD_INT 23
81660: PUSH
81661: LD_INT 2
81663: PUSH
81664: EMPTY
81665: LIST
81666: LIST
81667: PUSH
81668: EMPTY
81669: LIST
81670: LIST
81671: PPUSH
81672: CALL_OW 69
81676: IN
81677: NOT
81678: OR
81679: IFFALSE 81683
// exit ;
81681: GO 81730
// for i = 1 to 3 do
81683: LD_ADDR_VAR 0 3
81687: PUSH
81688: DOUBLE
81689: LD_INT 1
81691: DEC
81692: ST_TO_ADDR
81693: LD_INT 3
81695: PUSH
81696: FOR_TO
81697: IFFALSE 81728
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
81699: LD_VAR 0 1
81703: PPUSH
81704: CALL_OW 250
81708: PPUSH
81709: LD_VAR 0 1
81713: PPUSH
81714: CALL_OW 251
81718: PPUSH
81719: LD_INT 1
81721: PPUSH
81722: CALL_OW 453
81726: GO 81696
81728: POP
81729: POP
// end ;
81730: LD_VAR 0 2
81734: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
81735: LD_INT 0
81737: PPUSH
81738: PPUSH
81739: PPUSH
81740: PPUSH
81741: PPUSH
81742: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
81743: LD_VAR 0 1
81747: NOT
81748: PUSH
81749: LD_VAR 0 2
81753: NOT
81754: OR
81755: PUSH
81756: LD_VAR 0 1
81760: PPUSH
81761: CALL_OW 314
81765: OR
81766: IFFALSE 81770
// exit ;
81768: GO 82211
// x := GetX ( enemy_unit ) ;
81770: LD_ADDR_VAR 0 7
81774: PUSH
81775: LD_VAR 0 2
81779: PPUSH
81780: CALL_OW 250
81784: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
81785: LD_ADDR_VAR 0 8
81789: PUSH
81790: LD_VAR 0 2
81794: PPUSH
81795: CALL_OW 251
81799: ST_TO_ADDR
// if not x or not y then
81800: LD_VAR 0 7
81804: NOT
81805: PUSH
81806: LD_VAR 0 8
81810: NOT
81811: OR
81812: IFFALSE 81816
// exit ;
81814: GO 82211
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
81816: LD_ADDR_VAR 0 6
81820: PUSH
81821: LD_VAR 0 7
81825: PPUSH
81826: LD_INT 0
81828: PPUSH
81829: LD_INT 4
81831: PPUSH
81832: CALL_OW 272
81836: PUSH
81837: LD_VAR 0 8
81841: PPUSH
81842: LD_INT 0
81844: PPUSH
81845: LD_INT 4
81847: PPUSH
81848: CALL_OW 273
81852: PUSH
81853: EMPTY
81854: LIST
81855: LIST
81856: PUSH
81857: LD_VAR 0 7
81861: PPUSH
81862: LD_INT 1
81864: PPUSH
81865: LD_INT 4
81867: PPUSH
81868: CALL_OW 272
81872: PUSH
81873: LD_VAR 0 8
81877: PPUSH
81878: LD_INT 1
81880: PPUSH
81881: LD_INT 4
81883: PPUSH
81884: CALL_OW 273
81888: PUSH
81889: EMPTY
81890: LIST
81891: LIST
81892: PUSH
81893: LD_VAR 0 7
81897: PPUSH
81898: LD_INT 2
81900: PPUSH
81901: LD_INT 4
81903: PPUSH
81904: CALL_OW 272
81908: PUSH
81909: LD_VAR 0 8
81913: PPUSH
81914: LD_INT 2
81916: PPUSH
81917: LD_INT 4
81919: PPUSH
81920: CALL_OW 273
81924: PUSH
81925: EMPTY
81926: LIST
81927: LIST
81928: PUSH
81929: LD_VAR 0 7
81933: PPUSH
81934: LD_INT 3
81936: PPUSH
81937: LD_INT 4
81939: PPUSH
81940: CALL_OW 272
81944: PUSH
81945: LD_VAR 0 8
81949: PPUSH
81950: LD_INT 3
81952: PPUSH
81953: LD_INT 4
81955: PPUSH
81956: CALL_OW 273
81960: PUSH
81961: EMPTY
81962: LIST
81963: LIST
81964: PUSH
81965: LD_VAR 0 7
81969: PPUSH
81970: LD_INT 4
81972: PPUSH
81973: LD_INT 4
81975: PPUSH
81976: CALL_OW 272
81980: PUSH
81981: LD_VAR 0 8
81985: PPUSH
81986: LD_INT 4
81988: PPUSH
81989: LD_INT 4
81991: PPUSH
81992: CALL_OW 273
81996: PUSH
81997: EMPTY
81998: LIST
81999: LIST
82000: PUSH
82001: LD_VAR 0 7
82005: PPUSH
82006: LD_INT 5
82008: PPUSH
82009: LD_INT 4
82011: PPUSH
82012: CALL_OW 272
82016: PUSH
82017: LD_VAR 0 8
82021: PPUSH
82022: LD_INT 5
82024: PPUSH
82025: LD_INT 4
82027: PPUSH
82028: CALL_OW 273
82032: PUSH
82033: EMPTY
82034: LIST
82035: LIST
82036: PUSH
82037: EMPTY
82038: LIST
82039: LIST
82040: LIST
82041: LIST
82042: LIST
82043: LIST
82044: ST_TO_ADDR
// for i = tmp downto 1 do
82045: LD_ADDR_VAR 0 4
82049: PUSH
82050: DOUBLE
82051: LD_VAR 0 6
82055: INC
82056: ST_TO_ADDR
82057: LD_INT 1
82059: PUSH
82060: FOR_DOWNTO
82061: IFFALSE 82162
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
82063: LD_VAR 0 6
82067: PUSH
82068: LD_VAR 0 4
82072: ARRAY
82073: PUSH
82074: LD_INT 1
82076: ARRAY
82077: PPUSH
82078: LD_VAR 0 6
82082: PUSH
82083: LD_VAR 0 4
82087: ARRAY
82088: PUSH
82089: LD_INT 2
82091: ARRAY
82092: PPUSH
82093: CALL_OW 488
82097: NOT
82098: PUSH
82099: LD_VAR 0 6
82103: PUSH
82104: LD_VAR 0 4
82108: ARRAY
82109: PUSH
82110: LD_INT 1
82112: ARRAY
82113: PPUSH
82114: LD_VAR 0 6
82118: PUSH
82119: LD_VAR 0 4
82123: ARRAY
82124: PUSH
82125: LD_INT 2
82127: ARRAY
82128: PPUSH
82129: CALL_OW 428
82133: PUSH
82134: LD_INT 0
82136: NONEQUAL
82137: OR
82138: IFFALSE 82160
// tmp := Delete ( tmp , i ) ;
82140: LD_ADDR_VAR 0 6
82144: PUSH
82145: LD_VAR 0 6
82149: PPUSH
82150: LD_VAR 0 4
82154: PPUSH
82155: CALL_OW 3
82159: ST_TO_ADDR
82160: GO 82060
82162: POP
82163: POP
// j := GetClosestHex ( unit , tmp ) ;
82164: LD_ADDR_VAR 0 5
82168: PUSH
82169: LD_VAR 0 1
82173: PPUSH
82174: LD_VAR 0 6
82178: PPUSH
82179: CALL 81481 0 2
82183: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
82184: LD_VAR 0 1
82188: PPUSH
82189: LD_VAR 0 5
82193: PUSH
82194: LD_INT 1
82196: ARRAY
82197: PPUSH
82198: LD_VAR 0 5
82202: PUSH
82203: LD_INT 2
82205: ARRAY
82206: PPUSH
82207: CALL_OW 111
// end ;
82211: LD_VAR 0 3
82215: RET
// export function PrepareApemanSoldier ( ) ; begin
82216: LD_INT 0
82218: PPUSH
// uc_nation := 0 ;
82219: LD_ADDR_OWVAR 21
82223: PUSH
82224: LD_INT 0
82226: ST_TO_ADDR
// hc_sex := sex_male ;
82227: LD_ADDR_OWVAR 27
82231: PUSH
82232: LD_INT 1
82234: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
82235: LD_ADDR_OWVAR 28
82239: PUSH
82240: LD_INT 15
82242: ST_TO_ADDR
// hc_gallery :=  ;
82243: LD_ADDR_OWVAR 33
82247: PUSH
82248: LD_STRING 
82250: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
82251: LD_ADDR_OWVAR 31
82255: PUSH
82256: LD_INT 0
82258: PPUSH
82259: LD_INT 3
82261: PPUSH
82262: CALL_OW 12
82266: PUSH
82267: LD_INT 0
82269: PPUSH
82270: LD_INT 3
82272: PPUSH
82273: CALL_OW 12
82277: PUSH
82278: LD_INT 0
82280: PUSH
82281: LD_INT 0
82283: PUSH
82284: EMPTY
82285: LIST
82286: LIST
82287: LIST
82288: LIST
82289: ST_TO_ADDR
// end ;
82290: LD_VAR 0 1
82294: RET
// export function PrepareApemanEngineer ( ) ; begin
82295: LD_INT 0
82297: PPUSH
// uc_nation := 0 ;
82298: LD_ADDR_OWVAR 21
82302: PUSH
82303: LD_INT 0
82305: ST_TO_ADDR
// hc_sex := sex_male ;
82306: LD_ADDR_OWVAR 27
82310: PUSH
82311: LD_INT 1
82313: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
82314: LD_ADDR_OWVAR 28
82318: PUSH
82319: LD_INT 16
82321: ST_TO_ADDR
// hc_gallery :=  ;
82322: LD_ADDR_OWVAR 33
82326: PUSH
82327: LD_STRING 
82329: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
82330: LD_ADDR_OWVAR 31
82334: PUSH
82335: LD_INT 0
82337: PPUSH
82338: LD_INT 3
82340: PPUSH
82341: CALL_OW 12
82345: PUSH
82346: LD_INT 0
82348: PPUSH
82349: LD_INT 3
82351: PPUSH
82352: CALL_OW 12
82356: PUSH
82357: LD_INT 0
82359: PUSH
82360: LD_INT 0
82362: PUSH
82363: EMPTY
82364: LIST
82365: LIST
82366: LIST
82367: LIST
82368: ST_TO_ADDR
// end ;
82369: LD_VAR 0 1
82373: RET
// export function PrepareApeman ( agressivity ) ; begin
82374: LD_INT 0
82376: PPUSH
// uc_side := 0 ;
82377: LD_ADDR_OWVAR 20
82381: PUSH
82382: LD_INT 0
82384: ST_TO_ADDR
// uc_nation := 0 ;
82385: LD_ADDR_OWVAR 21
82389: PUSH
82390: LD_INT 0
82392: ST_TO_ADDR
// hc_sex := sex_male ;
82393: LD_ADDR_OWVAR 27
82397: PUSH
82398: LD_INT 1
82400: ST_TO_ADDR
// hc_class := class_apeman ;
82401: LD_ADDR_OWVAR 28
82405: PUSH
82406: LD_INT 12
82408: ST_TO_ADDR
// hc_gallery :=  ;
82409: LD_ADDR_OWVAR 33
82413: PUSH
82414: LD_STRING 
82416: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
82417: LD_ADDR_OWVAR 35
82421: PUSH
82422: LD_VAR 0 1
82426: NEG
82427: PPUSH
82428: LD_VAR 0 1
82432: PPUSH
82433: CALL_OW 12
82437: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
82438: LD_ADDR_OWVAR 31
82442: PUSH
82443: LD_INT 0
82445: PPUSH
82446: LD_INT 3
82448: PPUSH
82449: CALL_OW 12
82453: PUSH
82454: LD_INT 0
82456: PPUSH
82457: LD_INT 3
82459: PPUSH
82460: CALL_OW 12
82464: PUSH
82465: LD_INT 0
82467: PUSH
82468: LD_INT 0
82470: PUSH
82471: EMPTY
82472: LIST
82473: LIST
82474: LIST
82475: LIST
82476: ST_TO_ADDR
// end ;
82477: LD_VAR 0 2
82481: RET
// export function PrepareTiger ( agressivity ) ; begin
82482: LD_INT 0
82484: PPUSH
// uc_side := 0 ;
82485: LD_ADDR_OWVAR 20
82489: PUSH
82490: LD_INT 0
82492: ST_TO_ADDR
// uc_nation := 0 ;
82493: LD_ADDR_OWVAR 21
82497: PUSH
82498: LD_INT 0
82500: ST_TO_ADDR
// hc_class := class_tiger ;
82501: LD_ADDR_OWVAR 28
82505: PUSH
82506: LD_INT 14
82508: ST_TO_ADDR
// hc_gallery :=  ;
82509: LD_ADDR_OWVAR 33
82513: PUSH
82514: LD_STRING 
82516: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
82517: LD_ADDR_OWVAR 35
82521: PUSH
82522: LD_VAR 0 1
82526: NEG
82527: PPUSH
82528: LD_VAR 0 1
82532: PPUSH
82533: CALL_OW 12
82537: ST_TO_ADDR
// end ;
82538: LD_VAR 0 2
82542: RET
// export function PrepareEnchidna ( ) ; begin
82543: LD_INT 0
82545: PPUSH
// uc_side := 0 ;
82546: LD_ADDR_OWVAR 20
82550: PUSH
82551: LD_INT 0
82553: ST_TO_ADDR
// uc_nation := 0 ;
82554: LD_ADDR_OWVAR 21
82558: PUSH
82559: LD_INT 0
82561: ST_TO_ADDR
// hc_class := class_baggie ;
82562: LD_ADDR_OWVAR 28
82566: PUSH
82567: LD_INT 13
82569: ST_TO_ADDR
// hc_gallery :=  ;
82570: LD_ADDR_OWVAR 33
82574: PUSH
82575: LD_STRING 
82577: ST_TO_ADDR
// end ;
82578: LD_VAR 0 1
82582: RET
// export function PrepareFrog ( ) ; begin
82583: LD_INT 0
82585: PPUSH
// uc_side := 0 ;
82586: LD_ADDR_OWVAR 20
82590: PUSH
82591: LD_INT 0
82593: ST_TO_ADDR
// uc_nation := 0 ;
82594: LD_ADDR_OWVAR 21
82598: PUSH
82599: LD_INT 0
82601: ST_TO_ADDR
// hc_class := class_frog ;
82602: LD_ADDR_OWVAR 28
82606: PUSH
82607: LD_INT 19
82609: ST_TO_ADDR
// hc_gallery :=  ;
82610: LD_ADDR_OWVAR 33
82614: PUSH
82615: LD_STRING 
82617: ST_TO_ADDR
// end ;
82618: LD_VAR 0 1
82622: RET
// export function PrepareFish ( ) ; begin
82623: LD_INT 0
82625: PPUSH
// uc_side := 0 ;
82626: LD_ADDR_OWVAR 20
82630: PUSH
82631: LD_INT 0
82633: ST_TO_ADDR
// uc_nation := 0 ;
82634: LD_ADDR_OWVAR 21
82638: PUSH
82639: LD_INT 0
82641: ST_TO_ADDR
// hc_class := class_fish ;
82642: LD_ADDR_OWVAR 28
82646: PUSH
82647: LD_INT 20
82649: ST_TO_ADDR
// hc_gallery :=  ;
82650: LD_ADDR_OWVAR 33
82654: PUSH
82655: LD_STRING 
82657: ST_TO_ADDR
// end ;
82658: LD_VAR 0 1
82662: RET
// export function PrepareBird ( ) ; begin
82663: LD_INT 0
82665: PPUSH
// uc_side := 0 ;
82666: LD_ADDR_OWVAR 20
82670: PUSH
82671: LD_INT 0
82673: ST_TO_ADDR
// uc_nation := 0 ;
82674: LD_ADDR_OWVAR 21
82678: PUSH
82679: LD_INT 0
82681: ST_TO_ADDR
// hc_class := class_phororhacos ;
82682: LD_ADDR_OWVAR 28
82686: PUSH
82687: LD_INT 18
82689: ST_TO_ADDR
// hc_gallery :=  ;
82690: LD_ADDR_OWVAR 33
82694: PUSH
82695: LD_STRING 
82697: ST_TO_ADDR
// end ;
82698: LD_VAR 0 1
82702: RET
// export function PrepareHorse ( ) ; begin
82703: LD_INT 0
82705: PPUSH
// uc_side := 0 ;
82706: LD_ADDR_OWVAR 20
82710: PUSH
82711: LD_INT 0
82713: ST_TO_ADDR
// uc_nation := 0 ;
82714: LD_ADDR_OWVAR 21
82718: PUSH
82719: LD_INT 0
82721: ST_TO_ADDR
// hc_class := class_horse ;
82722: LD_ADDR_OWVAR 28
82726: PUSH
82727: LD_INT 21
82729: ST_TO_ADDR
// hc_gallery :=  ;
82730: LD_ADDR_OWVAR 33
82734: PUSH
82735: LD_STRING 
82737: ST_TO_ADDR
// end ;
82738: LD_VAR 0 1
82742: RET
// export function PrepareMastodont ( ) ; begin
82743: LD_INT 0
82745: PPUSH
// uc_side := 0 ;
82746: LD_ADDR_OWVAR 20
82750: PUSH
82751: LD_INT 0
82753: ST_TO_ADDR
// uc_nation := 0 ;
82754: LD_ADDR_OWVAR 21
82758: PUSH
82759: LD_INT 0
82761: ST_TO_ADDR
// vc_chassis := class_mastodont ;
82762: LD_ADDR_OWVAR 37
82766: PUSH
82767: LD_INT 31
82769: ST_TO_ADDR
// vc_control := control_rider ;
82770: LD_ADDR_OWVAR 38
82774: PUSH
82775: LD_INT 4
82777: ST_TO_ADDR
// end ;
82778: LD_VAR 0 1
82782: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
82783: LD_INT 0
82785: PPUSH
82786: PPUSH
82787: PPUSH
// uc_side = 0 ;
82788: LD_ADDR_OWVAR 20
82792: PUSH
82793: LD_INT 0
82795: ST_TO_ADDR
// uc_nation = 0 ;
82796: LD_ADDR_OWVAR 21
82800: PUSH
82801: LD_INT 0
82803: ST_TO_ADDR
// InitHc_All ( ) ;
82804: CALL_OW 584
// InitVc ;
82808: CALL_OW 20
// if mastodonts then
82812: LD_VAR 0 6
82816: IFFALSE 82883
// for i = 1 to mastodonts do
82818: LD_ADDR_VAR 0 11
82822: PUSH
82823: DOUBLE
82824: LD_INT 1
82826: DEC
82827: ST_TO_ADDR
82828: LD_VAR 0 6
82832: PUSH
82833: FOR_TO
82834: IFFALSE 82881
// begin vc_chassis := 31 ;
82836: LD_ADDR_OWVAR 37
82840: PUSH
82841: LD_INT 31
82843: ST_TO_ADDR
// vc_control := control_rider ;
82844: LD_ADDR_OWVAR 38
82848: PUSH
82849: LD_INT 4
82851: ST_TO_ADDR
// animal := CreateVehicle ;
82852: LD_ADDR_VAR 0 12
82856: PUSH
82857: CALL_OW 45
82861: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82862: LD_VAR 0 12
82866: PPUSH
82867: LD_VAR 0 8
82871: PPUSH
82872: LD_INT 0
82874: PPUSH
82875: CALL 85018 0 3
// end ;
82879: GO 82833
82881: POP
82882: POP
// if horses then
82883: LD_VAR 0 5
82887: IFFALSE 82954
// for i = 1 to horses do
82889: LD_ADDR_VAR 0 11
82893: PUSH
82894: DOUBLE
82895: LD_INT 1
82897: DEC
82898: ST_TO_ADDR
82899: LD_VAR 0 5
82903: PUSH
82904: FOR_TO
82905: IFFALSE 82952
// begin hc_class := 21 ;
82907: LD_ADDR_OWVAR 28
82911: PUSH
82912: LD_INT 21
82914: ST_TO_ADDR
// hc_gallery :=  ;
82915: LD_ADDR_OWVAR 33
82919: PUSH
82920: LD_STRING 
82922: ST_TO_ADDR
// animal := CreateHuman ;
82923: LD_ADDR_VAR 0 12
82927: PUSH
82928: CALL_OW 44
82932: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82933: LD_VAR 0 12
82937: PPUSH
82938: LD_VAR 0 8
82942: PPUSH
82943: LD_INT 0
82945: PPUSH
82946: CALL 85018 0 3
// end ;
82950: GO 82904
82952: POP
82953: POP
// if birds then
82954: LD_VAR 0 1
82958: IFFALSE 83025
// for i = 1 to birds do
82960: LD_ADDR_VAR 0 11
82964: PUSH
82965: DOUBLE
82966: LD_INT 1
82968: DEC
82969: ST_TO_ADDR
82970: LD_VAR 0 1
82974: PUSH
82975: FOR_TO
82976: IFFALSE 83023
// begin hc_class = 18 ;
82978: LD_ADDR_OWVAR 28
82982: PUSH
82983: LD_INT 18
82985: ST_TO_ADDR
// hc_gallery =  ;
82986: LD_ADDR_OWVAR 33
82990: PUSH
82991: LD_STRING 
82993: ST_TO_ADDR
// animal := CreateHuman ;
82994: LD_ADDR_VAR 0 12
82998: PUSH
82999: CALL_OW 44
83003: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83004: LD_VAR 0 12
83008: PPUSH
83009: LD_VAR 0 8
83013: PPUSH
83014: LD_INT 0
83016: PPUSH
83017: CALL 85018 0 3
// end ;
83021: GO 82975
83023: POP
83024: POP
// if tigers then
83025: LD_VAR 0 2
83029: IFFALSE 83113
// for i = 1 to tigers do
83031: LD_ADDR_VAR 0 11
83035: PUSH
83036: DOUBLE
83037: LD_INT 1
83039: DEC
83040: ST_TO_ADDR
83041: LD_VAR 0 2
83045: PUSH
83046: FOR_TO
83047: IFFALSE 83111
// begin hc_class = class_tiger ;
83049: LD_ADDR_OWVAR 28
83053: PUSH
83054: LD_INT 14
83056: ST_TO_ADDR
// hc_gallery =  ;
83057: LD_ADDR_OWVAR 33
83061: PUSH
83062: LD_STRING 
83064: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
83065: LD_ADDR_OWVAR 35
83069: PUSH
83070: LD_INT 7
83072: NEG
83073: PPUSH
83074: LD_INT 7
83076: PPUSH
83077: CALL_OW 12
83081: ST_TO_ADDR
// animal := CreateHuman ;
83082: LD_ADDR_VAR 0 12
83086: PUSH
83087: CALL_OW 44
83091: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83092: LD_VAR 0 12
83096: PPUSH
83097: LD_VAR 0 8
83101: PPUSH
83102: LD_INT 0
83104: PPUSH
83105: CALL 85018 0 3
// end ;
83109: GO 83046
83111: POP
83112: POP
// if apemans then
83113: LD_VAR 0 3
83117: IFFALSE 83240
// for i = 1 to apemans do
83119: LD_ADDR_VAR 0 11
83123: PUSH
83124: DOUBLE
83125: LD_INT 1
83127: DEC
83128: ST_TO_ADDR
83129: LD_VAR 0 3
83133: PUSH
83134: FOR_TO
83135: IFFALSE 83238
// begin hc_class = class_apeman ;
83137: LD_ADDR_OWVAR 28
83141: PUSH
83142: LD_INT 12
83144: ST_TO_ADDR
// hc_gallery =  ;
83145: LD_ADDR_OWVAR 33
83149: PUSH
83150: LD_STRING 
83152: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
83153: LD_ADDR_OWVAR 35
83157: PUSH
83158: LD_INT 2
83160: NEG
83161: PPUSH
83162: LD_INT 2
83164: PPUSH
83165: CALL_OW 12
83169: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
83170: LD_ADDR_OWVAR 31
83174: PUSH
83175: LD_INT 1
83177: PPUSH
83178: LD_INT 3
83180: PPUSH
83181: CALL_OW 12
83185: PUSH
83186: LD_INT 1
83188: PPUSH
83189: LD_INT 3
83191: PPUSH
83192: CALL_OW 12
83196: PUSH
83197: LD_INT 0
83199: PUSH
83200: LD_INT 0
83202: PUSH
83203: EMPTY
83204: LIST
83205: LIST
83206: LIST
83207: LIST
83208: ST_TO_ADDR
// animal := CreateHuman ;
83209: LD_ADDR_VAR 0 12
83213: PUSH
83214: CALL_OW 44
83218: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83219: LD_VAR 0 12
83223: PPUSH
83224: LD_VAR 0 8
83228: PPUSH
83229: LD_INT 0
83231: PPUSH
83232: CALL 85018 0 3
// end ;
83236: GO 83134
83238: POP
83239: POP
// if enchidnas then
83240: LD_VAR 0 4
83244: IFFALSE 83311
// for i = 1 to enchidnas do
83246: LD_ADDR_VAR 0 11
83250: PUSH
83251: DOUBLE
83252: LD_INT 1
83254: DEC
83255: ST_TO_ADDR
83256: LD_VAR 0 4
83260: PUSH
83261: FOR_TO
83262: IFFALSE 83309
// begin hc_class = 13 ;
83264: LD_ADDR_OWVAR 28
83268: PUSH
83269: LD_INT 13
83271: ST_TO_ADDR
// hc_gallery =  ;
83272: LD_ADDR_OWVAR 33
83276: PUSH
83277: LD_STRING 
83279: ST_TO_ADDR
// animal := CreateHuman ;
83280: LD_ADDR_VAR 0 12
83284: PUSH
83285: CALL_OW 44
83289: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83290: LD_VAR 0 12
83294: PPUSH
83295: LD_VAR 0 8
83299: PPUSH
83300: LD_INT 0
83302: PPUSH
83303: CALL 85018 0 3
// end ;
83307: GO 83261
83309: POP
83310: POP
// if fishes then
83311: LD_VAR 0 7
83315: IFFALSE 83382
// for i = 1 to fishes do
83317: LD_ADDR_VAR 0 11
83321: PUSH
83322: DOUBLE
83323: LD_INT 1
83325: DEC
83326: ST_TO_ADDR
83327: LD_VAR 0 7
83331: PUSH
83332: FOR_TO
83333: IFFALSE 83380
// begin hc_class = 20 ;
83335: LD_ADDR_OWVAR 28
83339: PUSH
83340: LD_INT 20
83342: ST_TO_ADDR
// hc_gallery =  ;
83343: LD_ADDR_OWVAR 33
83347: PUSH
83348: LD_STRING 
83350: ST_TO_ADDR
// animal := CreateHuman ;
83351: LD_ADDR_VAR 0 12
83355: PUSH
83356: CALL_OW 44
83360: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
83361: LD_VAR 0 12
83365: PPUSH
83366: LD_VAR 0 9
83370: PPUSH
83371: LD_INT 0
83373: PPUSH
83374: CALL 85018 0 3
// end ;
83378: GO 83332
83380: POP
83381: POP
// end ;
83382: LD_VAR 0 10
83386: RET
// export function WantHeal ( sci , unit ) ; begin
83387: LD_INT 0
83389: PPUSH
// if GetTaskList ( sci ) > 0 then
83390: LD_VAR 0 1
83394: PPUSH
83395: CALL_OW 437
83399: PUSH
83400: LD_INT 0
83402: GREATER
83403: IFFALSE 83473
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
83405: LD_VAR 0 1
83409: PPUSH
83410: CALL_OW 437
83414: PUSH
83415: LD_INT 1
83417: ARRAY
83418: PUSH
83419: LD_INT 1
83421: ARRAY
83422: PUSH
83423: LD_STRING l
83425: EQUAL
83426: PUSH
83427: LD_VAR 0 1
83431: PPUSH
83432: CALL_OW 437
83436: PUSH
83437: LD_INT 1
83439: ARRAY
83440: PUSH
83441: LD_INT 4
83443: ARRAY
83444: PUSH
83445: LD_VAR 0 2
83449: EQUAL
83450: AND
83451: IFFALSE 83463
// result := true else
83453: LD_ADDR_VAR 0 3
83457: PUSH
83458: LD_INT 1
83460: ST_TO_ADDR
83461: GO 83471
// result := false ;
83463: LD_ADDR_VAR 0 3
83467: PUSH
83468: LD_INT 0
83470: ST_TO_ADDR
// end else
83471: GO 83481
// result := false ;
83473: LD_ADDR_VAR 0 3
83477: PUSH
83478: LD_INT 0
83480: ST_TO_ADDR
// end ;
83481: LD_VAR 0 3
83485: RET
// export function HealTarget ( sci ) ; begin
83486: LD_INT 0
83488: PPUSH
// if not sci then
83489: LD_VAR 0 1
83493: NOT
83494: IFFALSE 83498
// exit ;
83496: GO 83563
// result := 0 ;
83498: LD_ADDR_VAR 0 2
83502: PUSH
83503: LD_INT 0
83505: ST_TO_ADDR
// if GetTaskList ( sci ) then
83506: LD_VAR 0 1
83510: PPUSH
83511: CALL_OW 437
83515: IFFALSE 83563
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
83517: LD_VAR 0 1
83521: PPUSH
83522: CALL_OW 437
83526: PUSH
83527: LD_INT 1
83529: ARRAY
83530: PUSH
83531: LD_INT 1
83533: ARRAY
83534: PUSH
83535: LD_STRING l
83537: EQUAL
83538: IFFALSE 83563
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
83540: LD_ADDR_VAR 0 2
83544: PUSH
83545: LD_VAR 0 1
83549: PPUSH
83550: CALL_OW 437
83554: PUSH
83555: LD_INT 1
83557: ARRAY
83558: PUSH
83559: LD_INT 4
83561: ARRAY
83562: ST_TO_ADDR
// end ;
83563: LD_VAR 0 2
83567: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
83568: LD_INT 0
83570: PPUSH
83571: PPUSH
83572: PPUSH
83573: PPUSH
// if not base_units then
83574: LD_VAR 0 1
83578: NOT
83579: IFFALSE 83583
// exit ;
83581: GO 83670
// result := false ;
83583: LD_ADDR_VAR 0 2
83587: PUSH
83588: LD_INT 0
83590: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
83591: LD_ADDR_VAR 0 5
83595: PUSH
83596: LD_VAR 0 1
83600: PPUSH
83601: LD_INT 21
83603: PUSH
83604: LD_INT 3
83606: PUSH
83607: EMPTY
83608: LIST
83609: LIST
83610: PPUSH
83611: CALL_OW 72
83615: ST_TO_ADDR
// if not tmp then
83616: LD_VAR 0 5
83620: NOT
83621: IFFALSE 83625
// exit ;
83623: GO 83670
// for i in tmp do
83625: LD_ADDR_VAR 0 3
83629: PUSH
83630: LD_VAR 0 5
83634: PUSH
83635: FOR_IN
83636: IFFALSE 83668
// begin result := EnemyInRange ( i , 22 ) ;
83638: LD_ADDR_VAR 0 2
83642: PUSH
83643: LD_VAR 0 3
83647: PPUSH
83648: LD_INT 22
83650: PPUSH
83651: CALL 81283 0 2
83655: ST_TO_ADDR
// if result then
83656: LD_VAR 0 2
83660: IFFALSE 83666
// exit ;
83662: POP
83663: POP
83664: GO 83670
// end ;
83666: GO 83635
83668: POP
83669: POP
// end ;
83670: LD_VAR 0 2
83674: RET
// export function FilterByTag ( units , tag ) ; begin
83675: LD_INT 0
83677: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
83678: LD_ADDR_VAR 0 3
83682: PUSH
83683: LD_VAR 0 1
83687: PPUSH
83688: LD_INT 120
83690: PUSH
83691: LD_VAR 0 2
83695: PUSH
83696: EMPTY
83697: LIST
83698: LIST
83699: PPUSH
83700: CALL_OW 72
83704: ST_TO_ADDR
// end ;
83705: LD_VAR 0 3
83709: RET
// export function IsDriver ( un ) ; begin
83710: LD_INT 0
83712: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
83713: LD_ADDR_VAR 0 2
83717: PUSH
83718: LD_VAR 0 1
83722: PUSH
83723: LD_INT 55
83725: PUSH
83726: EMPTY
83727: LIST
83728: PPUSH
83729: CALL_OW 69
83733: IN
83734: ST_TO_ADDR
// end ;
83735: LD_VAR 0 2
83739: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
83740: LD_INT 0
83742: PPUSH
83743: PPUSH
// list := [ ] ;
83744: LD_ADDR_VAR 0 5
83748: PUSH
83749: EMPTY
83750: ST_TO_ADDR
// case d of 0 :
83751: LD_VAR 0 3
83755: PUSH
83756: LD_INT 0
83758: DOUBLE
83759: EQUAL
83760: IFTRUE 83764
83762: GO 83897
83764: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
83765: LD_ADDR_VAR 0 5
83769: PUSH
83770: LD_VAR 0 1
83774: PUSH
83775: LD_INT 4
83777: MINUS
83778: PUSH
83779: LD_VAR 0 2
83783: PUSH
83784: LD_INT 4
83786: MINUS
83787: PUSH
83788: LD_INT 2
83790: PUSH
83791: EMPTY
83792: LIST
83793: LIST
83794: LIST
83795: PUSH
83796: LD_VAR 0 1
83800: PUSH
83801: LD_INT 3
83803: MINUS
83804: PUSH
83805: LD_VAR 0 2
83809: PUSH
83810: LD_INT 1
83812: PUSH
83813: EMPTY
83814: LIST
83815: LIST
83816: LIST
83817: PUSH
83818: LD_VAR 0 1
83822: PUSH
83823: LD_INT 4
83825: PLUS
83826: PUSH
83827: LD_VAR 0 2
83831: PUSH
83832: LD_INT 4
83834: PUSH
83835: EMPTY
83836: LIST
83837: LIST
83838: LIST
83839: PUSH
83840: LD_VAR 0 1
83844: PUSH
83845: LD_INT 3
83847: PLUS
83848: PUSH
83849: LD_VAR 0 2
83853: PUSH
83854: LD_INT 3
83856: PLUS
83857: PUSH
83858: LD_INT 5
83860: PUSH
83861: EMPTY
83862: LIST
83863: LIST
83864: LIST
83865: PUSH
83866: LD_VAR 0 1
83870: PUSH
83871: LD_VAR 0 2
83875: PUSH
83876: LD_INT 4
83878: PLUS
83879: PUSH
83880: LD_INT 0
83882: PUSH
83883: EMPTY
83884: LIST
83885: LIST
83886: LIST
83887: PUSH
83888: EMPTY
83889: LIST
83890: LIST
83891: LIST
83892: LIST
83893: LIST
83894: ST_TO_ADDR
// end ; 1 :
83895: GO 84595
83897: LD_INT 1
83899: DOUBLE
83900: EQUAL
83901: IFTRUE 83905
83903: GO 84038
83905: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
83906: LD_ADDR_VAR 0 5
83910: PUSH
83911: LD_VAR 0 1
83915: PUSH
83916: LD_VAR 0 2
83920: PUSH
83921: LD_INT 4
83923: MINUS
83924: PUSH
83925: LD_INT 3
83927: PUSH
83928: EMPTY
83929: LIST
83930: LIST
83931: LIST
83932: PUSH
83933: LD_VAR 0 1
83937: PUSH
83938: LD_INT 3
83940: MINUS
83941: PUSH
83942: LD_VAR 0 2
83946: PUSH
83947: LD_INT 3
83949: MINUS
83950: PUSH
83951: LD_INT 2
83953: PUSH
83954: EMPTY
83955: LIST
83956: LIST
83957: LIST
83958: PUSH
83959: LD_VAR 0 1
83963: PUSH
83964: LD_INT 4
83966: MINUS
83967: PUSH
83968: LD_VAR 0 2
83972: PUSH
83973: LD_INT 1
83975: PUSH
83976: EMPTY
83977: LIST
83978: LIST
83979: LIST
83980: PUSH
83981: LD_VAR 0 1
83985: PUSH
83986: LD_VAR 0 2
83990: PUSH
83991: LD_INT 3
83993: PLUS
83994: PUSH
83995: LD_INT 0
83997: PUSH
83998: EMPTY
83999: LIST
84000: LIST
84001: LIST
84002: PUSH
84003: LD_VAR 0 1
84007: PUSH
84008: LD_INT 4
84010: PLUS
84011: PUSH
84012: LD_VAR 0 2
84016: PUSH
84017: LD_INT 4
84019: PLUS
84020: PUSH
84021: LD_INT 5
84023: PUSH
84024: EMPTY
84025: LIST
84026: LIST
84027: LIST
84028: PUSH
84029: EMPTY
84030: LIST
84031: LIST
84032: LIST
84033: LIST
84034: LIST
84035: ST_TO_ADDR
// end ; 2 :
84036: GO 84595
84038: LD_INT 2
84040: DOUBLE
84041: EQUAL
84042: IFTRUE 84046
84044: GO 84175
84046: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
84047: LD_ADDR_VAR 0 5
84051: PUSH
84052: LD_VAR 0 1
84056: PUSH
84057: LD_VAR 0 2
84061: PUSH
84062: LD_INT 3
84064: MINUS
84065: PUSH
84066: LD_INT 3
84068: PUSH
84069: EMPTY
84070: LIST
84071: LIST
84072: LIST
84073: PUSH
84074: LD_VAR 0 1
84078: PUSH
84079: LD_INT 4
84081: PLUS
84082: PUSH
84083: LD_VAR 0 2
84087: PUSH
84088: LD_INT 4
84090: PUSH
84091: EMPTY
84092: LIST
84093: LIST
84094: LIST
84095: PUSH
84096: LD_VAR 0 1
84100: PUSH
84101: LD_VAR 0 2
84105: PUSH
84106: LD_INT 4
84108: PLUS
84109: PUSH
84110: LD_INT 0
84112: PUSH
84113: EMPTY
84114: LIST
84115: LIST
84116: LIST
84117: PUSH
84118: LD_VAR 0 1
84122: PUSH
84123: LD_INT 3
84125: MINUS
84126: PUSH
84127: LD_VAR 0 2
84131: PUSH
84132: LD_INT 1
84134: PUSH
84135: EMPTY
84136: LIST
84137: LIST
84138: LIST
84139: PUSH
84140: LD_VAR 0 1
84144: PUSH
84145: LD_INT 4
84147: MINUS
84148: PUSH
84149: LD_VAR 0 2
84153: PUSH
84154: LD_INT 4
84156: MINUS
84157: PUSH
84158: LD_INT 2
84160: PUSH
84161: EMPTY
84162: LIST
84163: LIST
84164: LIST
84165: PUSH
84166: EMPTY
84167: LIST
84168: LIST
84169: LIST
84170: LIST
84171: LIST
84172: ST_TO_ADDR
// end ; 3 :
84173: GO 84595
84175: LD_INT 3
84177: DOUBLE
84178: EQUAL
84179: IFTRUE 84183
84181: GO 84316
84183: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
84184: LD_ADDR_VAR 0 5
84188: PUSH
84189: LD_VAR 0 1
84193: PUSH
84194: LD_INT 3
84196: PLUS
84197: PUSH
84198: LD_VAR 0 2
84202: PUSH
84203: LD_INT 4
84205: PUSH
84206: EMPTY
84207: LIST
84208: LIST
84209: LIST
84210: PUSH
84211: LD_VAR 0 1
84215: PUSH
84216: LD_INT 4
84218: PLUS
84219: PUSH
84220: LD_VAR 0 2
84224: PUSH
84225: LD_INT 4
84227: PLUS
84228: PUSH
84229: LD_INT 5
84231: PUSH
84232: EMPTY
84233: LIST
84234: LIST
84235: LIST
84236: PUSH
84237: LD_VAR 0 1
84241: PUSH
84242: LD_INT 4
84244: MINUS
84245: PUSH
84246: LD_VAR 0 2
84250: PUSH
84251: LD_INT 1
84253: PUSH
84254: EMPTY
84255: LIST
84256: LIST
84257: LIST
84258: PUSH
84259: LD_VAR 0 1
84263: PUSH
84264: LD_VAR 0 2
84268: PUSH
84269: LD_INT 4
84271: MINUS
84272: PUSH
84273: LD_INT 3
84275: PUSH
84276: EMPTY
84277: LIST
84278: LIST
84279: LIST
84280: PUSH
84281: LD_VAR 0 1
84285: PUSH
84286: LD_INT 3
84288: MINUS
84289: PUSH
84290: LD_VAR 0 2
84294: PUSH
84295: LD_INT 3
84297: MINUS
84298: PUSH
84299: LD_INT 2
84301: PUSH
84302: EMPTY
84303: LIST
84304: LIST
84305: LIST
84306: PUSH
84307: EMPTY
84308: LIST
84309: LIST
84310: LIST
84311: LIST
84312: LIST
84313: ST_TO_ADDR
// end ; 4 :
84314: GO 84595
84316: LD_INT 4
84318: DOUBLE
84319: EQUAL
84320: IFTRUE 84324
84322: GO 84457
84324: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
84325: LD_ADDR_VAR 0 5
84329: PUSH
84330: LD_VAR 0 1
84334: PUSH
84335: LD_VAR 0 2
84339: PUSH
84340: LD_INT 4
84342: PLUS
84343: PUSH
84344: LD_INT 0
84346: PUSH
84347: EMPTY
84348: LIST
84349: LIST
84350: LIST
84351: PUSH
84352: LD_VAR 0 1
84356: PUSH
84357: LD_INT 3
84359: PLUS
84360: PUSH
84361: LD_VAR 0 2
84365: PUSH
84366: LD_INT 3
84368: PLUS
84369: PUSH
84370: LD_INT 5
84372: PUSH
84373: EMPTY
84374: LIST
84375: LIST
84376: LIST
84377: PUSH
84378: LD_VAR 0 1
84382: PUSH
84383: LD_INT 4
84385: PLUS
84386: PUSH
84387: LD_VAR 0 2
84391: PUSH
84392: LD_INT 4
84394: PUSH
84395: EMPTY
84396: LIST
84397: LIST
84398: LIST
84399: PUSH
84400: LD_VAR 0 1
84404: PUSH
84405: LD_VAR 0 2
84409: PUSH
84410: LD_INT 3
84412: MINUS
84413: PUSH
84414: LD_INT 3
84416: PUSH
84417: EMPTY
84418: LIST
84419: LIST
84420: LIST
84421: PUSH
84422: LD_VAR 0 1
84426: PUSH
84427: LD_INT 4
84429: MINUS
84430: PUSH
84431: LD_VAR 0 2
84435: PUSH
84436: LD_INT 4
84438: MINUS
84439: PUSH
84440: LD_INT 2
84442: PUSH
84443: EMPTY
84444: LIST
84445: LIST
84446: LIST
84447: PUSH
84448: EMPTY
84449: LIST
84450: LIST
84451: LIST
84452: LIST
84453: LIST
84454: ST_TO_ADDR
// end ; 5 :
84455: GO 84595
84457: LD_INT 5
84459: DOUBLE
84460: EQUAL
84461: IFTRUE 84465
84463: GO 84594
84465: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
84466: LD_ADDR_VAR 0 5
84470: PUSH
84471: LD_VAR 0 1
84475: PUSH
84476: LD_INT 4
84478: MINUS
84479: PUSH
84480: LD_VAR 0 2
84484: PUSH
84485: LD_INT 1
84487: PUSH
84488: EMPTY
84489: LIST
84490: LIST
84491: LIST
84492: PUSH
84493: LD_VAR 0 1
84497: PUSH
84498: LD_VAR 0 2
84502: PUSH
84503: LD_INT 4
84505: MINUS
84506: PUSH
84507: LD_INT 3
84509: PUSH
84510: EMPTY
84511: LIST
84512: LIST
84513: LIST
84514: PUSH
84515: LD_VAR 0 1
84519: PUSH
84520: LD_INT 4
84522: PLUS
84523: PUSH
84524: LD_VAR 0 2
84528: PUSH
84529: LD_INT 4
84531: PLUS
84532: PUSH
84533: LD_INT 5
84535: PUSH
84536: EMPTY
84537: LIST
84538: LIST
84539: LIST
84540: PUSH
84541: LD_VAR 0 1
84545: PUSH
84546: LD_INT 3
84548: PLUS
84549: PUSH
84550: LD_VAR 0 2
84554: PUSH
84555: LD_INT 4
84557: PUSH
84558: EMPTY
84559: LIST
84560: LIST
84561: LIST
84562: PUSH
84563: LD_VAR 0 1
84567: PUSH
84568: LD_VAR 0 2
84572: PUSH
84573: LD_INT 3
84575: PLUS
84576: PUSH
84577: LD_INT 0
84579: PUSH
84580: EMPTY
84581: LIST
84582: LIST
84583: LIST
84584: PUSH
84585: EMPTY
84586: LIST
84587: LIST
84588: LIST
84589: LIST
84590: LIST
84591: ST_TO_ADDR
// end ; end ;
84592: GO 84595
84594: POP
// result := list ;
84595: LD_ADDR_VAR 0 4
84599: PUSH
84600: LD_VAR 0 5
84604: ST_TO_ADDR
// end ;
84605: LD_VAR 0 4
84609: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
84610: LD_INT 0
84612: PPUSH
84613: PPUSH
84614: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
84615: LD_VAR 0 1
84619: NOT
84620: PUSH
84621: LD_VAR 0 2
84625: PUSH
84626: LD_INT 1
84628: PUSH
84629: LD_INT 2
84631: PUSH
84632: LD_INT 3
84634: PUSH
84635: LD_INT 4
84637: PUSH
84638: EMPTY
84639: LIST
84640: LIST
84641: LIST
84642: LIST
84643: IN
84644: NOT
84645: OR
84646: IFFALSE 84650
// exit ;
84648: GO 84742
// tmp := [ ] ;
84650: LD_ADDR_VAR 0 5
84654: PUSH
84655: EMPTY
84656: ST_TO_ADDR
// for i in units do
84657: LD_ADDR_VAR 0 4
84661: PUSH
84662: LD_VAR 0 1
84666: PUSH
84667: FOR_IN
84668: IFFALSE 84711
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
84670: LD_ADDR_VAR 0 5
84674: PUSH
84675: LD_VAR 0 5
84679: PPUSH
84680: LD_VAR 0 5
84684: PUSH
84685: LD_INT 1
84687: PLUS
84688: PPUSH
84689: LD_VAR 0 4
84693: PPUSH
84694: LD_VAR 0 2
84698: PPUSH
84699: CALL_OW 259
84703: PPUSH
84704: CALL_OW 2
84708: ST_TO_ADDR
84709: GO 84667
84711: POP
84712: POP
// if not tmp then
84713: LD_VAR 0 5
84717: NOT
84718: IFFALSE 84722
// exit ;
84720: GO 84742
// result := SortListByListDesc ( units , tmp ) ;
84722: LD_ADDR_VAR 0 3
84726: PUSH
84727: LD_VAR 0 1
84731: PPUSH
84732: LD_VAR 0 5
84736: PPUSH
84737: CALL_OW 77
84741: ST_TO_ADDR
// end ;
84742: LD_VAR 0 3
84746: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
84747: LD_INT 0
84749: PPUSH
84750: PPUSH
84751: PPUSH
// result := false ;
84752: LD_ADDR_VAR 0 3
84756: PUSH
84757: LD_INT 0
84759: ST_TO_ADDR
// x := GetX ( building ) ;
84760: LD_ADDR_VAR 0 4
84764: PUSH
84765: LD_VAR 0 2
84769: PPUSH
84770: CALL_OW 250
84774: ST_TO_ADDR
// y := GetY ( building ) ;
84775: LD_ADDR_VAR 0 5
84779: PUSH
84780: LD_VAR 0 2
84784: PPUSH
84785: CALL_OW 251
84789: ST_TO_ADDR
// if not building or not x or not y then
84790: LD_VAR 0 2
84794: NOT
84795: PUSH
84796: LD_VAR 0 4
84800: NOT
84801: OR
84802: PUSH
84803: LD_VAR 0 5
84807: NOT
84808: OR
84809: IFFALSE 84813
// exit ;
84811: GO 84905
// if GetTaskList ( unit ) then
84813: LD_VAR 0 1
84817: PPUSH
84818: CALL_OW 437
84822: IFFALSE 84905
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
84824: LD_STRING e
84826: PUSH
84827: LD_VAR 0 1
84831: PPUSH
84832: CALL_OW 437
84836: PUSH
84837: LD_INT 1
84839: ARRAY
84840: PUSH
84841: LD_INT 1
84843: ARRAY
84844: EQUAL
84845: PUSH
84846: LD_VAR 0 4
84850: PUSH
84851: LD_VAR 0 1
84855: PPUSH
84856: CALL_OW 437
84860: PUSH
84861: LD_INT 1
84863: ARRAY
84864: PUSH
84865: LD_INT 2
84867: ARRAY
84868: EQUAL
84869: AND
84870: PUSH
84871: LD_VAR 0 5
84875: PUSH
84876: LD_VAR 0 1
84880: PPUSH
84881: CALL_OW 437
84885: PUSH
84886: LD_INT 1
84888: ARRAY
84889: PUSH
84890: LD_INT 3
84892: ARRAY
84893: EQUAL
84894: AND
84895: IFFALSE 84905
// result := true end ;
84897: LD_ADDR_VAR 0 3
84901: PUSH
84902: LD_INT 1
84904: ST_TO_ADDR
// end ;
84905: LD_VAR 0 3
84909: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
84910: LD_INT 0
84912: PPUSH
// result := false ;
84913: LD_ADDR_VAR 0 4
84917: PUSH
84918: LD_INT 0
84920: ST_TO_ADDR
// if GetTaskList ( unit ) then
84921: LD_VAR 0 1
84925: PPUSH
84926: CALL_OW 437
84930: IFFALSE 85013
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
84932: LD_STRING M
84934: PUSH
84935: LD_VAR 0 1
84939: PPUSH
84940: CALL_OW 437
84944: PUSH
84945: LD_INT 1
84947: ARRAY
84948: PUSH
84949: LD_INT 1
84951: ARRAY
84952: EQUAL
84953: PUSH
84954: LD_VAR 0 2
84958: PUSH
84959: LD_VAR 0 1
84963: PPUSH
84964: CALL_OW 437
84968: PUSH
84969: LD_INT 1
84971: ARRAY
84972: PUSH
84973: LD_INT 2
84975: ARRAY
84976: EQUAL
84977: AND
84978: PUSH
84979: LD_VAR 0 3
84983: PUSH
84984: LD_VAR 0 1
84988: PPUSH
84989: CALL_OW 437
84993: PUSH
84994: LD_INT 1
84996: ARRAY
84997: PUSH
84998: LD_INT 3
85000: ARRAY
85001: EQUAL
85002: AND
85003: IFFALSE 85013
// result := true ;
85005: LD_ADDR_VAR 0 4
85009: PUSH
85010: LD_INT 1
85012: ST_TO_ADDR
// end ; end ;
85013: LD_VAR 0 4
85017: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
85018: LD_INT 0
85020: PPUSH
85021: PPUSH
85022: PPUSH
85023: PPUSH
// if not unit or not area then
85024: LD_VAR 0 1
85028: NOT
85029: PUSH
85030: LD_VAR 0 2
85034: NOT
85035: OR
85036: IFFALSE 85040
// exit ;
85038: GO 85204
// tmp := AreaToList ( area , i ) ;
85040: LD_ADDR_VAR 0 6
85044: PUSH
85045: LD_VAR 0 2
85049: PPUSH
85050: LD_VAR 0 5
85054: PPUSH
85055: CALL_OW 517
85059: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
85060: LD_ADDR_VAR 0 5
85064: PUSH
85065: DOUBLE
85066: LD_INT 1
85068: DEC
85069: ST_TO_ADDR
85070: LD_VAR 0 6
85074: PUSH
85075: LD_INT 1
85077: ARRAY
85078: PUSH
85079: FOR_TO
85080: IFFALSE 85202
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
85082: LD_ADDR_VAR 0 7
85086: PUSH
85087: LD_VAR 0 6
85091: PUSH
85092: LD_INT 1
85094: ARRAY
85095: PUSH
85096: LD_VAR 0 5
85100: ARRAY
85101: PUSH
85102: LD_VAR 0 6
85106: PUSH
85107: LD_INT 2
85109: ARRAY
85110: PUSH
85111: LD_VAR 0 5
85115: ARRAY
85116: PUSH
85117: EMPTY
85118: LIST
85119: LIST
85120: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
85121: LD_VAR 0 7
85125: PUSH
85126: LD_INT 1
85128: ARRAY
85129: PPUSH
85130: LD_VAR 0 7
85134: PUSH
85135: LD_INT 2
85137: ARRAY
85138: PPUSH
85139: CALL_OW 428
85143: PUSH
85144: LD_INT 0
85146: EQUAL
85147: IFFALSE 85200
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
85149: LD_VAR 0 1
85153: PPUSH
85154: LD_VAR 0 7
85158: PUSH
85159: LD_INT 1
85161: ARRAY
85162: PPUSH
85163: LD_VAR 0 7
85167: PUSH
85168: LD_INT 2
85170: ARRAY
85171: PPUSH
85172: LD_VAR 0 3
85176: PPUSH
85177: CALL_OW 48
// result := IsPlaced ( unit ) ;
85181: LD_ADDR_VAR 0 4
85185: PUSH
85186: LD_VAR 0 1
85190: PPUSH
85191: CALL_OW 305
85195: ST_TO_ADDR
// exit ;
85196: POP
85197: POP
85198: GO 85204
// end ; end ;
85200: GO 85079
85202: POP
85203: POP
// end ;
85204: LD_VAR 0 4
85208: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
85209: LD_INT 0
85211: PPUSH
85212: PPUSH
85213: PPUSH
// if not side or side > 8 then
85214: LD_VAR 0 1
85218: NOT
85219: PUSH
85220: LD_VAR 0 1
85224: PUSH
85225: LD_INT 8
85227: GREATER
85228: OR
85229: IFFALSE 85233
// exit ;
85231: GO 85420
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
85233: LD_ADDR_VAR 0 4
85237: PUSH
85238: LD_INT 22
85240: PUSH
85241: LD_VAR 0 1
85245: PUSH
85246: EMPTY
85247: LIST
85248: LIST
85249: PUSH
85250: LD_INT 21
85252: PUSH
85253: LD_INT 3
85255: PUSH
85256: EMPTY
85257: LIST
85258: LIST
85259: PUSH
85260: EMPTY
85261: LIST
85262: LIST
85263: PPUSH
85264: CALL_OW 69
85268: ST_TO_ADDR
// if not tmp then
85269: LD_VAR 0 4
85273: NOT
85274: IFFALSE 85278
// exit ;
85276: GO 85420
// enable_addtolog := true ;
85278: LD_ADDR_OWVAR 81
85282: PUSH
85283: LD_INT 1
85285: ST_TO_ADDR
// AddToLog ( [ ) ;
85286: LD_STRING [
85288: PPUSH
85289: CALL_OW 561
// for i in tmp do
85293: LD_ADDR_VAR 0 3
85297: PUSH
85298: LD_VAR 0 4
85302: PUSH
85303: FOR_IN
85304: IFFALSE 85411
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
85306: LD_STRING [
85308: PUSH
85309: LD_VAR 0 3
85313: PPUSH
85314: CALL_OW 266
85318: STR
85319: PUSH
85320: LD_STRING , 
85322: STR
85323: PUSH
85324: LD_VAR 0 3
85328: PPUSH
85329: CALL_OW 250
85333: STR
85334: PUSH
85335: LD_STRING , 
85337: STR
85338: PUSH
85339: LD_VAR 0 3
85343: PPUSH
85344: CALL_OW 251
85348: STR
85349: PUSH
85350: LD_STRING , 
85352: STR
85353: PUSH
85354: LD_VAR 0 3
85358: PPUSH
85359: CALL_OW 254
85363: STR
85364: PUSH
85365: LD_STRING , 
85367: STR
85368: PUSH
85369: LD_VAR 0 3
85373: PPUSH
85374: LD_INT 1
85376: PPUSH
85377: CALL_OW 268
85381: STR
85382: PUSH
85383: LD_STRING , 
85385: STR
85386: PUSH
85387: LD_VAR 0 3
85391: PPUSH
85392: LD_INT 2
85394: PPUSH
85395: CALL_OW 268
85399: STR
85400: PUSH
85401: LD_STRING ],
85403: STR
85404: PPUSH
85405: CALL_OW 561
// end ;
85409: GO 85303
85411: POP
85412: POP
// AddToLog ( ]; ) ;
85413: LD_STRING ];
85415: PPUSH
85416: CALL_OW 561
// end ;
85420: LD_VAR 0 2
85424: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
85425: LD_INT 0
85427: PPUSH
85428: PPUSH
85429: PPUSH
85430: PPUSH
85431: PPUSH
// if not area or not rate or not max then
85432: LD_VAR 0 1
85436: NOT
85437: PUSH
85438: LD_VAR 0 2
85442: NOT
85443: OR
85444: PUSH
85445: LD_VAR 0 4
85449: NOT
85450: OR
85451: IFFALSE 85455
// exit ;
85453: GO 85644
// while 1 do
85455: LD_INT 1
85457: IFFALSE 85644
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
85459: LD_ADDR_VAR 0 9
85463: PUSH
85464: LD_VAR 0 1
85468: PPUSH
85469: LD_INT 1
85471: PPUSH
85472: CALL_OW 287
85476: PUSH
85477: LD_INT 10
85479: MUL
85480: ST_TO_ADDR
// r := rate / 10 ;
85481: LD_ADDR_VAR 0 7
85485: PUSH
85486: LD_VAR 0 2
85490: PUSH
85491: LD_INT 10
85493: DIVREAL
85494: ST_TO_ADDR
// time := 1 1$00 ;
85495: LD_ADDR_VAR 0 8
85499: PUSH
85500: LD_INT 2100
85502: ST_TO_ADDR
// if amount < min then
85503: LD_VAR 0 9
85507: PUSH
85508: LD_VAR 0 3
85512: LESS
85513: IFFALSE 85531
// r := r * 2 else
85515: LD_ADDR_VAR 0 7
85519: PUSH
85520: LD_VAR 0 7
85524: PUSH
85525: LD_INT 2
85527: MUL
85528: ST_TO_ADDR
85529: GO 85557
// if amount > max then
85531: LD_VAR 0 9
85535: PUSH
85536: LD_VAR 0 4
85540: GREATER
85541: IFFALSE 85557
// r := r / 2 ;
85543: LD_ADDR_VAR 0 7
85547: PUSH
85548: LD_VAR 0 7
85552: PUSH
85553: LD_INT 2
85555: DIVREAL
85556: ST_TO_ADDR
// time := time / r ;
85557: LD_ADDR_VAR 0 8
85561: PUSH
85562: LD_VAR 0 8
85566: PUSH
85567: LD_VAR 0 7
85571: DIVREAL
85572: ST_TO_ADDR
// if time < 0 then
85573: LD_VAR 0 8
85577: PUSH
85578: LD_INT 0
85580: LESS
85581: IFFALSE 85598
// time := time * - 1 ;
85583: LD_ADDR_VAR 0 8
85587: PUSH
85588: LD_VAR 0 8
85592: PUSH
85593: LD_INT 1
85595: NEG
85596: MUL
85597: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
85598: LD_VAR 0 8
85602: PUSH
85603: LD_INT 35
85605: PPUSH
85606: LD_INT 875
85608: PPUSH
85609: CALL_OW 12
85613: PLUS
85614: PPUSH
85615: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
85619: LD_INT 1
85621: PPUSH
85622: LD_INT 5
85624: PPUSH
85625: CALL_OW 12
85629: PPUSH
85630: LD_VAR 0 1
85634: PPUSH
85635: LD_INT 1
85637: PPUSH
85638: CALL_OW 55
// end ;
85642: GO 85455
// end ;
85644: LD_VAR 0 5
85648: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
85649: LD_INT 0
85651: PPUSH
85652: PPUSH
85653: PPUSH
85654: PPUSH
85655: PPUSH
85656: PPUSH
85657: PPUSH
85658: PPUSH
// if not turrets or not factories then
85659: LD_VAR 0 1
85663: NOT
85664: PUSH
85665: LD_VAR 0 2
85669: NOT
85670: OR
85671: IFFALSE 85675
// exit ;
85673: GO 85982
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
85675: LD_ADDR_VAR 0 10
85679: PUSH
85680: LD_INT 5
85682: PUSH
85683: LD_INT 6
85685: PUSH
85686: EMPTY
85687: LIST
85688: LIST
85689: PUSH
85690: LD_INT 2
85692: PUSH
85693: LD_INT 4
85695: PUSH
85696: EMPTY
85697: LIST
85698: LIST
85699: PUSH
85700: LD_INT 3
85702: PUSH
85703: LD_INT 5
85705: PUSH
85706: EMPTY
85707: LIST
85708: LIST
85709: PUSH
85710: EMPTY
85711: LIST
85712: LIST
85713: LIST
85714: PUSH
85715: LD_INT 24
85717: PUSH
85718: LD_INT 25
85720: PUSH
85721: EMPTY
85722: LIST
85723: LIST
85724: PUSH
85725: LD_INT 23
85727: PUSH
85728: LD_INT 27
85730: PUSH
85731: EMPTY
85732: LIST
85733: LIST
85734: PUSH
85735: EMPTY
85736: LIST
85737: LIST
85738: PUSH
85739: LD_INT 42
85741: PUSH
85742: LD_INT 43
85744: PUSH
85745: EMPTY
85746: LIST
85747: LIST
85748: PUSH
85749: LD_INT 44
85751: PUSH
85752: LD_INT 46
85754: PUSH
85755: EMPTY
85756: LIST
85757: LIST
85758: PUSH
85759: LD_INT 45
85761: PUSH
85762: LD_INT 47
85764: PUSH
85765: EMPTY
85766: LIST
85767: LIST
85768: PUSH
85769: EMPTY
85770: LIST
85771: LIST
85772: LIST
85773: PUSH
85774: EMPTY
85775: LIST
85776: LIST
85777: LIST
85778: ST_TO_ADDR
// result := [ ] ;
85779: LD_ADDR_VAR 0 3
85783: PUSH
85784: EMPTY
85785: ST_TO_ADDR
// for i in turrets do
85786: LD_ADDR_VAR 0 4
85790: PUSH
85791: LD_VAR 0 1
85795: PUSH
85796: FOR_IN
85797: IFFALSE 85980
// begin nat := GetNation ( i ) ;
85799: LD_ADDR_VAR 0 7
85803: PUSH
85804: LD_VAR 0 4
85808: PPUSH
85809: CALL_OW 248
85813: ST_TO_ADDR
// weapon := 0 ;
85814: LD_ADDR_VAR 0 8
85818: PUSH
85819: LD_INT 0
85821: ST_TO_ADDR
// if not nat then
85822: LD_VAR 0 7
85826: NOT
85827: IFFALSE 85831
// continue ;
85829: GO 85796
// for j in list [ nat ] do
85831: LD_ADDR_VAR 0 5
85835: PUSH
85836: LD_VAR 0 10
85840: PUSH
85841: LD_VAR 0 7
85845: ARRAY
85846: PUSH
85847: FOR_IN
85848: IFFALSE 85889
// if GetBWeapon ( i ) = j [ 1 ] then
85850: LD_VAR 0 4
85854: PPUSH
85855: CALL_OW 269
85859: PUSH
85860: LD_VAR 0 5
85864: PUSH
85865: LD_INT 1
85867: ARRAY
85868: EQUAL
85869: IFFALSE 85887
// begin weapon := j [ 2 ] ;
85871: LD_ADDR_VAR 0 8
85875: PUSH
85876: LD_VAR 0 5
85880: PUSH
85881: LD_INT 2
85883: ARRAY
85884: ST_TO_ADDR
// break ;
85885: GO 85889
// end ;
85887: GO 85847
85889: POP
85890: POP
// if not weapon then
85891: LD_VAR 0 8
85895: NOT
85896: IFFALSE 85900
// continue ;
85898: GO 85796
// for k in factories do
85900: LD_ADDR_VAR 0 6
85904: PUSH
85905: LD_VAR 0 2
85909: PUSH
85910: FOR_IN
85911: IFFALSE 85976
// begin weapons := AvailableWeaponList ( k ) ;
85913: LD_ADDR_VAR 0 9
85917: PUSH
85918: LD_VAR 0 6
85922: PPUSH
85923: CALL_OW 478
85927: ST_TO_ADDR
// if not weapons then
85928: LD_VAR 0 9
85932: NOT
85933: IFFALSE 85937
// continue ;
85935: GO 85910
// if weapon in weapons then
85937: LD_VAR 0 8
85941: PUSH
85942: LD_VAR 0 9
85946: IN
85947: IFFALSE 85974
// begin result := [ i , weapon ] ;
85949: LD_ADDR_VAR 0 3
85953: PUSH
85954: LD_VAR 0 4
85958: PUSH
85959: LD_VAR 0 8
85963: PUSH
85964: EMPTY
85965: LIST
85966: LIST
85967: ST_TO_ADDR
// exit ;
85968: POP
85969: POP
85970: POP
85971: POP
85972: GO 85982
// end ; end ;
85974: GO 85910
85976: POP
85977: POP
// end ;
85978: GO 85796
85980: POP
85981: POP
// end ;
85982: LD_VAR 0 3
85986: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
85987: LD_INT 0
85989: PPUSH
// if not side or side > 8 then
85990: LD_VAR 0 3
85994: NOT
85995: PUSH
85996: LD_VAR 0 3
86000: PUSH
86001: LD_INT 8
86003: GREATER
86004: OR
86005: IFFALSE 86009
// exit ;
86007: GO 86068
// if not range then
86009: LD_VAR 0 4
86013: NOT
86014: IFFALSE 86025
// range := - 12 ;
86016: LD_ADDR_VAR 0 4
86020: PUSH
86021: LD_INT 12
86023: NEG
86024: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
86025: LD_VAR 0 1
86029: PPUSH
86030: LD_VAR 0 2
86034: PPUSH
86035: LD_VAR 0 3
86039: PPUSH
86040: LD_VAR 0 4
86044: PPUSH
86045: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
86049: LD_VAR 0 1
86053: PPUSH
86054: LD_VAR 0 2
86058: PPUSH
86059: LD_VAR 0 3
86063: PPUSH
86064: CALL_OW 331
// end ;
86068: LD_VAR 0 5
86072: RET
// export function Video ( mode ) ; begin
86073: LD_INT 0
86075: PPUSH
// ingame_video = mode ;
86076: LD_ADDR_OWVAR 52
86080: PUSH
86081: LD_VAR 0 1
86085: ST_TO_ADDR
// interface_hidden = mode ;
86086: LD_ADDR_OWVAR 54
86090: PUSH
86091: LD_VAR 0 1
86095: ST_TO_ADDR
// end ;
86096: LD_VAR 0 2
86100: RET
// export function Join ( array , element ) ; begin
86101: LD_INT 0
86103: PPUSH
// result := Replace ( array , array + 1 , element ) ;
86104: LD_ADDR_VAR 0 3
86108: PUSH
86109: LD_VAR 0 1
86113: PPUSH
86114: LD_VAR 0 1
86118: PUSH
86119: LD_INT 1
86121: PLUS
86122: PPUSH
86123: LD_VAR 0 2
86127: PPUSH
86128: CALL_OW 1
86132: ST_TO_ADDR
// end ;
86133: LD_VAR 0 3
86137: RET
// export function JoinUnion ( array , element ) ; begin
86138: LD_INT 0
86140: PPUSH
// result := array union element ;
86141: LD_ADDR_VAR 0 3
86145: PUSH
86146: LD_VAR 0 1
86150: PUSH
86151: LD_VAR 0 2
86155: UNION
86156: ST_TO_ADDR
// end ;
86157: LD_VAR 0 3
86161: RET
// export function GetBehemoths ( side ) ; begin
86162: LD_INT 0
86164: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
86165: LD_ADDR_VAR 0 2
86169: PUSH
86170: LD_INT 22
86172: PUSH
86173: LD_VAR 0 1
86177: PUSH
86178: EMPTY
86179: LIST
86180: LIST
86181: PUSH
86182: LD_INT 31
86184: PUSH
86185: LD_INT 25
86187: PUSH
86188: EMPTY
86189: LIST
86190: LIST
86191: PUSH
86192: EMPTY
86193: LIST
86194: LIST
86195: PPUSH
86196: CALL_OW 69
86200: ST_TO_ADDR
// end ;
86201: LD_VAR 0 2
86205: RET
// export function Shuffle ( array ) ; var i , index ; begin
86206: LD_INT 0
86208: PPUSH
86209: PPUSH
86210: PPUSH
// result := [ ] ;
86211: LD_ADDR_VAR 0 2
86215: PUSH
86216: EMPTY
86217: ST_TO_ADDR
// if not array then
86218: LD_VAR 0 1
86222: NOT
86223: IFFALSE 86227
// exit ;
86225: GO 86326
// Randomize ;
86227: CALL_OW 10
// for i = array downto 1 do
86231: LD_ADDR_VAR 0 3
86235: PUSH
86236: DOUBLE
86237: LD_VAR 0 1
86241: INC
86242: ST_TO_ADDR
86243: LD_INT 1
86245: PUSH
86246: FOR_DOWNTO
86247: IFFALSE 86324
// begin index := rand ( 1 , array ) ;
86249: LD_ADDR_VAR 0 4
86253: PUSH
86254: LD_INT 1
86256: PPUSH
86257: LD_VAR 0 1
86261: PPUSH
86262: CALL_OW 12
86266: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
86267: LD_ADDR_VAR 0 2
86271: PUSH
86272: LD_VAR 0 2
86276: PPUSH
86277: LD_VAR 0 2
86281: PUSH
86282: LD_INT 1
86284: PLUS
86285: PPUSH
86286: LD_VAR 0 1
86290: PUSH
86291: LD_VAR 0 4
86295: ARRAY
86296: PPUSH
86297: CALL_OW 2
86301: ST_TO_ADDR
// array := Delete ( array , index ) ;
86302: LD_ADDR_VAR 0 1
86306: PUSH
86307: LD_VAR 0 1
86311: PPUSH
86312: LD_VAR 0 4
86316: PPUSH
86317: CALL_OW 3
86321: ST_TO_ADDR
// end ;
86322: GO 86246
86324: POP
86325: POP
// end ;
86326: LD_VAR 0 2
86330: RET
// export function GetBaseMaterials ( base ) ; begin
86331: LD_INT 0
86333: PPUSH
// result := [ 0 , 0 , 0 ] ;
86334: LD_ADDR_VAR 0 2
86338: PUSH
86339: LD_INT 0
86341: PUSH
86342: LD_INT 0
86344: PUSH
86345: LD_INT 0
86347: PUSH
86348: EMPTY
86349: LIST
86350: LIST
86351: LIST
86352: ST_TO_ADDR
// if not base then
86353: LD_VAR 0 1
86357: NOT
86358: IFFALSE 86362
// exit ;
86360: GO 86411
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
86362: LD_ADDR_VAR 0 2
86366: PUSH
86367: LD_VAR 0 1
86371: PPUSH
86372: LD_INT 1
86374: PPUSH
86375: CALL_OW 275
86379: PUSH
86380: LD_VAR 0 1
86384: PPUSH
86385: LD_INT 2
86387: PPUSH
86388: CALL_OW 275
86392: PUSH
86393: LD_VAR 0 1
86397: PPUSH
86398: LD_INT 3
86400: PPUSH
86401: CALL_OW 275
86405: PUSH
86406: EMPTY
86407: LIST
86408: LIST
86409: LIST
86410: ST_TO_ADDR
// end ;
86411: LD_VAR 0 2
86415: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
86416: LD_INT 0
86418: PPUSH
86419: PPUSH
// result := array ;
86420: LD_ADDR_VAR 0 3
86424: PUSH
86425: LD_VAR 0 1
86429: ST_TO_ADDR
// if size >= result then
86430: LD_VAR 0 2
86434: PUSH
86435: LD_VAR 0 3
86439: GREATEREQUAL
86440: IFFALSE 86444
// exit ;
86442: GO 86494
// if size then
86444: LD_VAR 0 2
86448: IFFALSE 86494
// for i := array downto size do
86450: LD_ADDR_VAR 0 4
86454: PUSH
86455: DOUBLE
86456: LD_VAR 0 1
86460: INC
86461: ST_TO_ADDR
86462: LD_VAR 0 2
86466: PUSH
86467: FOR_DOWNTO
86468: IFFALSE 86492
// result := Delete ( result , result ) ;
86470: LD_ADDR_VAR 0 3
86474: PUSH
86475: LD_VAR 0 3
86479: PPUSH
86480: LD_VAR 0 3
86484: PPUSH
86485: CALL_OW 3
86489: ST_TO_ADDR
86490: GO 86467
86492: POP
86493: POP
// end ;
86494: LD_VAR 0 3
86498: RET
// export function ComExit ( unit ) ; var tmp ; begin
86499: LD_INT 0
86501: PPUSH
86502: PPUSH
// if not IsInUnit ( unit ) then
86503: LD_VAR 0 1
86507: PPUSH
86508: CALL_OW 310
86512: NOT
86513: IFFALSE 86517
// exit ;
86515: GO 86577
// tmp := IsInUnit ( unit ) ;
86517: LD_ADDR_VAR 0 3
86521: PUSH
86522: LD_VAR 0 1
86526: PPUSH
86527: CALL_OW 310
86531: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
86532: LD_VAR 0 3
86536: PPUSH
86537: CALL_OW 247
86541: PUSH
86542: LD_INT 2
86544: EQUAL
86545: IFFALSE 86558
// ComExitVehicle ( unit ) else
86547: LD_VAR 0 1
86551: PPUSH
86552: CALL_OW 121
86556: GO 86567
// ComExitBuilding ( unit ) ;
86558: LD_VAR 0 1
86562: PPUSH
86563: CALL_OW 122
// result := tmp ;
86567: LD_ADDR_VAR 0 2
86571: PUSH
86572: LD_VAR 0 3
86576: ST_TO_ADDR
// end ;
86577: LD_VAR 0 2
86581: RET
// export function ComExitAll ( units ) ; var i ; begin
86582: LD_INT 0
86584: PPUSH
86585: PPUSH
// if not units then
86586: LD_VAR 0 1
86590: NOT
86591: IFFALSE 86595
// exit ;
86593: GO 86621
// for i in units do
86595: LD_ADDR_VAR 0 3
86599: PUSH
86600: LD_VAR 0 1
86604: PUSH
86605: FOR_IN
86606: IFFALSE 86619
// ComExit ( i ) ;
86608: LD_VAR 0 3
86612: PPUSH
86613: CALL 86499 0 1
86617: GO 86605
86619: POP
86620: POP
// end ;
86621: LD_VAR 0 2
86625: RET
// export function ResetHc ; begin
86626: LD_INT 0
86628: PPUSH
// InitHc ;
86629: CALL_OW 19
// hc_importance := 0 ;
86633: LD_ADDR_OWVAR 32
86637: PUSH
86638: LD_INT 0
86640: ST_TO_ADDR
// end ;
86641: LD_VAR 0 1
86645: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
86646: LD_INT 0
86648: PPUSH
86649: PPUSH
86650: PPUSH
// _x := ( x1 + x2 ) div 2 ;
86651: LD_ADDR_VAR 0 6
86655: PUSH
86656: LD_VAR 0 1
86660: PUSH
86661: LD_VAR 0 3
86665: PLUS
86666: PUSH
86667: LD_INT 2
86669: DIV
86670: ST_TO_ADDR
// if _x < 0 then
86671: LD_VAR 0 6
86675: PUSH
86676: LD_INT 0
86678: LESS
86679: IFFALSE 86696
// _x := _x * - 1 ;
86681: LD_ADDR_VAR 0 6
86685: PUSH
86686: LD_VAR 0 6
86690: PUSH
86691: LD_INT 1
86693: NEG
86694: MUL
86695: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
86696: LD_ADDR_VAR 0 7
86700: PUSH
86701: LD_VAR 0 2
86705: PUSH
86706: LD_VAR 0 4
86710: PLUS
86711: PUSH
86712: LD_INT 2
86714: DIV
86715: ST_TO_ADDR
// if _y < 0 then
86716: LD_VAR 0 7
86720: PUSH
86721: LD_INT 0
86723: LESS
86724: IFFALSE 86741
// _y := _y * - 1 ;
86726: LD_ADDR_VAR 0 7
86730: PUSH
86731: LD_VAR 0 7
86735: PUSH
86736: LD_INT 1
86738: NEG
86739: MUL
86740: ST_TO_ADDR
// result := [ _x , _y ] ;
86741: LD_ADDR_VAR 0 5
86745: PUSH
86746: LD_VAR 0 6
86750: PUSH
86751: LD_VAR 0 7
86755: PUSH
86756: EMPTY
86757: LIST
86758: LIST
86759: ST_TO_ADDR
// end ;
86760: LD_VAR 0 5
86764: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
86765: LD_INT 0
86767: PPUSH
86768: PPUSH
86769: PPUSH
86770: PPUSH
// task := GetTaskList ( unit ) ;
86771: LD_ADDR_VAR 0 7
86775: PUSH
86776: LD_VAR 0 1
86780: PPUSH
86781: CALL_OW 437
86785: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
86786: LD_VAR 0 7
86790: NOT
86791: PUSH
86792: LD_VAR 0 1
86796: PPUSH
86797: LD_VAR 0 2
86801: PPUSH
86802: CALL_OW 308
86806: NOT
86807: AND
86808: IFFALSE 86812
// exit ;
86810: GO 86930
// if IsInArea ( unit , area ) then
86812: LD_VAR 0 1
86816: PPUSH
86817: LD_VAR 0 2
86821: PPUSH
86822: CALL_OW 308
86826: IFFALSE 86844
// begin ComMoveToArea ( unit , goAway ) ;
86828: LD_VAR 0 1
86832: PPUSH
86833: LD_VAR 0 3
86837: PPUSH
86838: CALL_OW 113
// exit ;
86842: GO 86930
// end ; if task [ 1 ] [ 1 ] <> M then
86844: LD_VAR 0 7
86848: PUSH
86849: LD_INT 1
86851: ARRAY
86852: PUSH
86853: LD_INT 1
86855: ARRAY
86856: PUSH
86857: LD_STRING M
86859: NONEQUAL
86860: IFFALSE 86864
// exit ;
86862: GO 86930
// x := task [ 1 ] [ 2 ] ;
86864: LD_ADDR_VAR 0 5
86868: PUSH
86869: LD_VAR 0 7
86873: PUSH
86874: LD_INT 1
86876: ARRAY
86877: PUSH
86878: LD_INT 2
86880: ARRAY
86881: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
86882: LD_ADDR_VAR 0 6
86886: PUSH
86887: LD_VAR 0 7
86891: PUSH
86892: LD_INT 1
86894: ARRAY
86895: PUSH
86896: LD_INT 3
86898: ARRAY
86899: ST_TO_ADDR
// if InArea ( x , y , area ) then
86900: LD_VAR 0 5
86904: PPUSH
86905: LD_VAR 0 6
86909: PPUSH
86910: LD_VAR 0 2
86914: PPUSH
86915: CALL_OW 309
86919: IFFALSE 86930
// ComStop ( unit ) ;
86921: LD_VAR 0 1
86925: PPUSH
86926: CALL_OW 141
// end ;
86930: LD_VAR 0 4
86934: RET
// export function Abs ( value ) ; begin
86935: LD_INT 0
86937: PPUSH
// result := value ;
86938: LD_ADDR_VAR 0 2
86942: PUSH
86943: LD_VAR 0 1
86947: ST_TO_ADDR
// if value < 0 then
86948: LD_VAR 0 1
86952: PUSH
86953: LD_INT 0
86955: LESS
86956: IFFALSE 86973
// result := value * - 1 ;
86958: LD_ADDR_VAR 0 2
86962: PUSH
86963: LD_VAR 0 1
86967: PUSH
86968: LD_INT 1
86970: NEG
86971: MUL
86972: ST_TO_ADDR
// end ;
86973: LD_VAR 0 2
86977: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
86978: LD_INT 0
86980: PPUSH
86981: PPUSH
86982: PPUSH
86983: PPUSH
86984: PPUSH
86985: PPUSH
86986: PPUSH
86987: PPUSH
// if not unit or not building then
86988: LD_VAR 0 1
86992: NOT
86993: PUSH
86994: LD_VAR 0 2
86998: NOT
86999: OR
87000: IFFALSE 87004
// exit ;
87002: GO 87230
// x := GetX ( building ) ;
87004: LD_ADDR_VAR 0 4
87008: PUSH
87009: LD_VAR 0 2
87013: PPUSH
87014: CALL_OW 250
87018: ST_TO_ADDR
// y := GetY ( building ) ;
87019: LD_ADDR_VAR 0 6
87023: PUSH
87024: LD_VAR 0 2
87028: PPUSH
87029: CALL_OW 251
87033: ST_TO_ADDR
// d := GetDir ( building ) ;
87034: LD_ADDR_VAR 0 8
87038: PUSH
87039: LD_VAR 0 2
87043: PPUSH
87044: CALL_OW 254
87048: ST_TO_ADDR
// r := 4 ;
87049: LD_ADDR_VAR 0 9
87053: PUSH
87054: LD_INT 4
87056: ST_TO_ADDR
// for i := 1 to 5 do
87057: LD_ADDR_VAR 0 10
87061: PUSH
87062: DOUBLE
87063: LD_INT 1
87065: DEC
87066: ST_TO_ADDR
87067: LD_INT 5
87069: PUSH
87070: FOR_TO
87071: IFFALSE 87228
// begin _x := ShiftX ( x , d , r + i ) ;
87073: LD_ADDR_VAR 0 5
87077: PUSH
87078: LD_VAR 0 4
87082: PPUSH
87083: LD_VAR 0 8
87087: PPUSH
87088: LD_VAR 0 9
87092: PUSH
87093: LD_VAR 0 10
87097: PLUS
87098: PPUSH
87099: CALL_OW 272
87103: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
87104: LD_ADDR_VAR 0 7
87108: PUSH
87109: LD_VAR 0 6
87113: PPUSH
87114: LD_VAR 0 8
87118: PPUSH
87119: LD_VAR 0 9
87123: PUSH
87124: LD_VAR 0 10
87128: PLUS
87129: PPUSH
87130: CALL_OW 273
87134: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
87135: LD_VAR 0 5
87139: PPUSH
87140: LD_VAR 0 7
87144: PPUSH
87145: CALL_OW 488
87149: PUSH
87150: LD_VAR 0 5
87154: PPUSH
87155: LD_VAR 0 7
87159: PPUSH
87160: CALL_OW 428
87164: PPUSH
87165: CALL_OW 247
87169: PUSH
87170: LD_INT 3
87172: PUSH
87173: LD_INT 2
87175: PUSH
87176: EMPTY
87177: LIST
87178: LIST
87179: IN
87180: NOT
87181: AND
87182: IFFALSE 87226
// begin ComMoveXY ( unit , _x , _y ) ;
87184: LD_VAR 0 1
87188: PPUSH
87189: LD_VAR 0 5
87193: PPUSH
87194: LD_VAR 0 7
87198: PPUSH
87199: CALL_OW 111
// result := [ _x , _y ] ;
87203: LD_ADDR_VAR 0 3
87207: PUSH
87208: LD_VAR 0 5
87212: PUSH
87213: LD_VAR 0 7
87217: PUSH
87218: EMPTY
87219: LIST
87220: LIST
87221: ST_TO_ADDR
// exit ;
87222: POP
87223: POP
87224: GO 87230
// end ; end ;
87226: GO 87070
87228: POP
87229: POP
// end ;
87230: LD_VAR 0 3
87234: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
87235: LD_INT 0
87237: PPUSH
87238: PPUSH
87239: PPUSH
// result := 0 ;
87240: LD_ADDR_VAR 0 3
87244: PUSH
87245: LD_INT 0
87247: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
87248: LD_VAR 0 1
87252: PUSH
87253: LD_INT 0
87255: LESS
87256: PUSH
87257: LD_VAR 0 1
87261: PUSH
87262: LD_INT 8
87264: GREATER
87265: OR
87266: PUSH
87267: LD_VAR 0 2
87271: PUSH
87272: LD_INT 0
87274: LESS
87275: OR
87276: PUSH
87277: LD_VAR 0 2
87281: PUSH
87282: LD_INT 8
87284: GREATER
87285: OR
87286: IFFALSE 87290
// exit ;
87288: GO 87365
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
87290: LD_ADDR_VAR 0 4
87294: PUSH
87295: LD_INT 22
87297: PUSH
87298: LD_VAR 0 2
87302: PUSH
87303: EMPTY
87304: LIST
87305: LIST
87306: PPUSH
87307: CALL_OW 69
87311: PUSH
87312: FOR_IN
87313: IFFALSE 87363
// begin un := UnitShoot ( i ) ;
87315: LD_ADDR_VAR 0 5
87319: PUSH
87320: LD_VAR 0 4
87324: PPUSH
87325: CALL_OW 504
87329: ST_TO_ADDR
// if GetSide ( un ) = side1 then
87330: LD_VAR 0 5
87334: PPUSH
87335: CALL_OW 255
87339: PUSH
87340: LD_VAR 0 1
87344: EQUAL
87345: IFFALSE 87361
// begin result := un ;
87347: LD_ADDR_VAR 0 3
87351: PUSH
87352: LD_VAR 0 5
87356: ST_TO_ADDR
// exit ;
87357: POP
87358: POP
87359: GO 87365
// end ; end ;
87361: GO 87312
87363: POP
87364: POP
// end ;
87365: LD_VAR 0 3
87369: RET
// export function GetCargoBay ( units ) ; begin
87370: LD_INT 0
87372: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
87373: LD_ADDR_VAR 0 2
87377: PUSH
87378: LD_VAR 0 1
87382: PPUSH
87383: LD_INT 2
87385: PUSH
87386: LD_INT 34
87388: PUSH
87389: LD_INT 12
87391: PUSH
87392: EMPTY
87393: LIST
87394: LIST
87395: PUSH
87396: LD_INT 34
87398: PUSH
87399: LD_INT 51
87401: PUSH
87402: EMPTY
87403: LIST
87404: LIST
87405: PUSH
87406: LD_INT 34
87408: PUSH
87409: LD_INT 32
87411: PUSH
87412: EMPTY
87413: LIST
87414: LIST
87415: PUSH
87416: LD_INT 34
87418: PUSH
87419: LD_INT 89
87421: PUSH
87422: EMPTY
87423: LIST
87424: LIST
87425: PUSH
87426: EMPTY
87427: LIST
87428: LIST
87429: LIST
87430: LIST
87431: LIST
87432: PPUSH
87433: CALL_OW 72
87437: ST_TO_ADDR
// end ;
87438: LD_VAR 0 2
87442: RET
// export function Negate ( value ) ; begin
87443: LD_INT 0
87445: PPUSH
// result := not value ;
87446: LD_ADDR_VAR 0 2
87450: PUSH
87451: LD_VAR 0 1
87455: NOT
87456: ST_TO_ADDR
// end ;
87457: LD_VAR 0 2
87461: RET
// export function Inc ( value ) ; begin
87462: LD_INT 0
87464: PPUSH
// result := value + 1 ;
87465: LD_ADDR_VAR 0 2
87469: PUSH
87470: LD_VAR 0 1
87474: PUSH
87475: LD_INT 1
87477: PLUS
87478: ST_TO_ADDR
// end ;
87479: LD_VAR 0 2
87483: RET
// export function Dec ( value ) ; begin
87484: LD_INT 0
87486: PPUSH
// result := value - 1 ;
87487: LD_ADDR_VAR 0 2
87491: PUSH
87492: LD_VAR 0 1
87496: PUSH
87497: LD_INT 1
87499: MINUS
87500: ST_TO_ADDR
// end ;
87501: LD_VAR 0 2
87505: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
87506: LD_INT 0
87508: PPUSH
87509: PPUSH
87510: PPUSH
87511: PPUSH
87512: PPUSH
87513: PPUSH
87514: PPUSH
87515: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
87516: LD_VAR 0 1
87520: PPUSH
87521: LD_VAR 0 2
87525: PPUSH
87526: CALL_OW 488
87530: NOT
87531: PUSH
87532: LD_VAR 0 3
87536: PPUSH
87537: LD_VAR 0 4
87541: PPUSH
87542: CALL_OW 488
87546: NOT
87547: OR
87548: IFFALSE 87561
// begin result := - 1 ;
87550: LD_ADDR_VAR 0 5
87554: PUSH
87555: LD_INT 1
87557: NEG
87558: ST_TO_ADDR
// exit ;
87559: GO 87796
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
87561: LD_ADDR_VAR 0 12
87565: PUSH
87566: LD_VAR 0 1
87570: PPUSH
87571: LD_VAR 0 2
87575: PPUSH
87576: LD_VAR 0 3
87580: PPUSH
87581: LD_VAR 0 4
87585: PPUSH
87586: CALL 86646 0 4
87590: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
87591: LD_ADDR_VAR 0 11
87595: PUSH
87596: LD_VAR 0 1
87600: PPUSH
87601: LD_VAR 0 2
87605: PPUSH
87606: LD_VAR 0 12
87610: PUSH
87611: LD_INT 1
87613: ARRAY
87614: PPUSH
87615: LD_VAR 0 12
87619: PUSH
87620: LD_INT 2
87622: ARRAY
87623: PPUSH
87624: CALL_OW 298
87628: ST_TO_ADDR
// distance := 9999 ;
87629: LD_ADDR_VAR 0 10
87633: PUSH
87634: LD_INT 9999
87636: ST_TO_ADDR
// for i := 0 to 5 do
87637: LD_ADDR_VAR 0 6
87641: PUSH
87642: DOUBLE
87643: LD_INT 0
87645: DEC
87646: ST_TO_ADDR
87647: LD_INT 5
87649: PUSH
87650: FOR_TO
87651: IFFALSE 87794
// begin _x := ShiftX ( x1 , i , centerDist ) ;
87653: LD_ADDR_VAR 0 7
87657: PUSH
87658: LD_VAR 0 1
87662: PPUSH
87663: LD_VAR 0 6
87667: PPUSH
87668: LD_VAR 0 11
87672: PPUSH
87673: CALL_OW 272
87677: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
87678: LD_ADDR_VAR 0 8
87682: PUSH
87683: LD_VAR 0 2
87687: PPUSH
87688: LD_VAR 0 6
87692: PPUSH
87693: LD_VAR 0 11
87697: PPUSH
87698: CALL_OW 273
87702: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
87703: LD_VAR 0 7
87707: PPUSH
87708: LD_VAR 0 8
87712: PPUSH
87713: CALL_OW 488
87717: NOT
87718: IFFALSE 87722
// continue ;
87720: GO 87650
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
87722: LD_ADDR_VAR 0 9
87726: PUSH
87727: LD_VAR 0 12
87731: PUSH
87732: LD_INT 1
87734: ARRAY
87735: PPUSH
87736: LD_VAR 0 12
87740: PUSH
87741: LD_INT 2
87743: ARRAY
87744: PPUSH
87745: LD_VAR 0 7
87749: PPUSH
87750: LD_VAR 0 8
87754: PPUSH
87755: CALL_OW 298
87759: ST_TO_ADDR
// if tmp < distance then
87760: LD_VAR 0 9
87764: PUSH
87765: LD_VAR 0 10
87769: LESS
87770: IFFALSE 87792
// begin result := i ;
87772: LD_ADDR_VAR 0 5
87776: PUSH
87777: LD_VAR 0 6
87781: ST_TO_ADDR
// distance := tmp ;
87782: LD_ADDR_VAR 0 10
87786: PUSH
87787: LD_VAR 0 9
87791: ST_TO_ADDR
// end ; end ;
87792: GO 87650
87794: POP
87795: POP
// end ;
87796: LD_VAR 0 5
87800: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
87801: LD_INT 0
87803: PPUSH
87804: PPUSH
// if not driver or not IsInUnit ( driver ) then
87805: LD_VAR 0 1
87809: NOT
87810: PUSH
87811: LD_VAR 0 1
87815: PPUSH
87816: CALL_OW 310
87820: NOT
87821: OR
87822: IFFALSE 87826
// exit ;
87824: GO 87916
// vehicle := IsInUnit ( driver ) ;
87826: LD_ADDR_VAR 0 3
87830: PUSH
87831: LD_VAR 0 1
87835: PPUSH
87836: CALL_OW 310
87840: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
87841: LD_VAR 0 1
87845: PPUSH
87846: LD_STRING \
87848: PUSH
87849: LD_INT 0
87851: PUSH
87852: LD_INT 0
87854: PUSH
87855: LD_INT 0
87857: PUSH
87858: LD_INT 0
87860: PUSH
87861: LD_INT 0
87863: PUSH
87864: LD_INT 0
87866: PUSH
87867: EMPTY
87868: LIST
87869: LIST
87870: LIST
87871: LIST
87872: LIST
87873: LIST
87874: LIST
87875: PUSH
87876: LD_STRING E
87878: PUSH
87879: LD_INT 0
87881: PUSH
87882: LD_INT 0
87884: PUSH
87885: LD_VAR 0 3
87889: PUSH
87890: LD_INT 0
87892: PUSH
87893: LD_INT 0
87895: PUSH
87896: LD_INT 0
87898: PUSH
87899: EMPTY
87900: LIST
87901: LIST
87902: LIST
87903: LIST
87904: LIST
87905: LIST
87906: LIST
87907: PUSH
87908: EMPTY
87909: LIST
87910: LIST
87911: PPUSH
87912: CALL_OW 446
// end ;
87916: LD_VAR 0 2
87920: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
87921: LD_INT 0
87923: PPUSH
87924: PPUSH
// if not driver or not IsInUnit ( driver ) then
87925: LD_VAR 0 1
87929: NOT
87930: PUSH
87931: LD_VAR 0 1
87935: PPUSH
87936: CALL_OW 310
87940: NOT
87941: OR
87942: IFFALSE 87946
// exit ;
87944: GO 88036
// vehicle := IsInUnit ( driver ) ;
87946: LD_ADDR_VAR 0 3
87950: PUSH
87951: LD_VAR 0 1
87955: PPUSH
87956: CALL_OW 310
87960: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
87961: LD_VAR 0 1
87965: PPUSH
87966: LD_STRING \
87968: PUSH
87969: LD_INT 0
87971: PUSH
87972: LD_INT 0
87974: PUSH
87975: LD_INT 0
87977: PUSH
87978: LD_INT 0
87980: PUSH
87981: LD_INT 0
87983: PUSH
87984: LD_INT 0
87986: PUSH
87987: EMPTY
87988: LIST
87989: LIST
87990: LIST
87991: LIST
87992: LIST
87993: LIST
87994: LIST
87995: PUSH
87996: LD_STRING E
87998: PUSH
87999: LD_INT 0
88001: PUSH
88002: LD_INT 0
88004: PUSH
88005: LD_VAR 0 3
88009: PUSH
88010: LD_INT 0
88012: PUSH
88013: LD_INT 0
88015: PUSH
88016: LD_INT 0
88018: PUSH
88019: EMPTY
88020: LIST
88021: LIST
88022: LIST
88023: LIST
88024: LIST
88025: LIST
88026: LIST
88027: PUSH
88028: EMPTY
88029: LIST
88030: LIST
88031: PPUSH
88032: CALL_OW 447
// end ;
88036: LD_VAR 0 2
88040: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
88041: LD_INT 0
88043: PPUSH
88044: PPUSH
88045: PPUSH
// tmp := [ ] ;
88046: LD_ADDR_VAR 0 5
88050: PUSH
88051: EMPTY
88052: ST_TO_ADDR
// for i in units do
88053: LD_ADDR_VAR 0 4
88057: PUSH
88058: LD_VAR 0 1
88062: PUSH
88063: FOR_IN
88064: IFFALSE 88102
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
88066: LD_ADDR_VAR 0 5
88070: PUSH
88071: LD_VAR 0 5
88075: PPUSH
88076: LD_VAR 0 5
88080: PUSH
88081: LD_INT 1
88083: PLUS
88084: PPUSH
88085: LD_VAR 0 4
88089: PPUSH
88090: CALL_OW 256
88094: PPUSH
88095: CALL_OW 2
88099: ST_TO_ADDR
88100: GO 88063
88102: POP
88103: POP
// if not tmp then
88104: LD_VAR 0 5
88108: NOT
88109: IFFALSE 88113
// exit ;
88111: GO 88161
// if asc then
88113: LD_VAR 0 2
88117: IFFALSE 88141
// result := SortListByListAsc ( units , tmp ) else
88119: LD_ADDR_VAR 0 3
88123: PUSH
88124: LD_VAR 0 1
88128: PPUSH
88129: LD_VAR 0 5
88133: PPUSH
88134: CALL_OW 76
88138: ST_TO_ADDR
88139: GO 88161
// result := SortListByListDesc ( units , tmp ) ;
88141: LD_ADDR_VAR 0 3
88145: PUSH
88146: LD_VAR 0 1
88150: PPUSH
88151: LD_VAR 0 5
88155: PPUSH
88156: CALL_OW 77
88160: ST_TO_ADDR
// end ;
88161: LD_VAR 0 3
88165: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
88166: LD_INT 0
88168: PPUSH
88169: PPUSH
// task := GetTaskList ( mech ) ;
88170: LD_ADDR_VAR 0 4
88174: PUSH
88175: LD_VAR 0 1
88179: PPUSH
88180: CALL_OW 437
88184: ST_TO_ADDR
// if not task then
88185: LD_VAR 0 4
88189: NOT
88190: IFFALSE 88194
// exit ;
88192: GO 88236
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
88194: LD_ADDR_VAR 0 3
88198: PUSH
88199: LD_VAR 0 4
88203: PUSH
88204: LD_INT 1
88206: ARRAY
88207: PUSH
88208: LD_INT 1
88210: ARRAY
88211: PUSH
88212: LD_STRING r
88214: EQUAL
88215: PUSH
88216: LD_VAR 0 4
88220: PUSH
88221: LD_INT 1
88223: ARRAY
88224: PUSH
88225: LD_INT 4
88227: ARRAY
88228: PUSH
88229: LD_VAR 0 2
88233: EQUAL
88234: AND
88235: ST_TO_ADDR
// end ;
88236: LD_VAR 0 3
88240: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
88241: LD_INT 0
88243: PPUSH
// SetDir ( unit , d ) ;
88244: LD_VAR 0 1
88248: PPUSH
88249: LD_VAR 0 4
88253: PPUSH
88254: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
88258: LD_VAR 0 1
88262: PPUSH
88263: LD_VAR 0 2
88267: PPUSH
88268: LD_VAR 0 3
88272: PPUSH
88273: LD_VAR 0 5
88277: PPUSH
88278: CALL_OW 48
// end ;
88282: LD_VAR 0 6
88286: RET
// export function ToNaturalNumber ( number ) ; begin
88287: LD_INT 0
88289: PPUSH
// result := number div 1 ;
88290: LD_ADDR_VAR 0 2
88294: PUSH
88295: LD_VAR 0 1
88299: PUSH
88300: LD_INT 1
88302: DIV
88303: ST_TO_ADDR
// if number < 0 then
88304: LD_VAR 0 1
88308: PUSH
88309: LD_INT 0
88311: LESS
88312: IFFALSE 88322
// result := 0 ;
88314: LD_ADDR_VAR 0 2
88318: PUSH
88319: LD_INT 0
88321: ST_TO_ADDR
// end ;
88322: LD_VAR 0 2
88326: RET
// export function SortByClass ( units , class ) ; var un ; begin
88327: LD_INT 0
88329: PPUSH
88330: PPUSH
// if not units or not class then
88331: LD_VAR 0 1
88335: NOT
88336: PUSH
88337: LD_VAR 0 2
88341: NOT
88342: OR
88343: IFFALSE 88347
// exit ;
88345: GO 88442
// result := [ ] ;
88347: LD_ADDR_VAR 0 3
88351: PUSH
88352: EMPTY
88353: ST_TO_ADDR
// for un in units do
88354: LD_ADDR_VAR 0 4
88358: PUSH
88359: LD_VAR 0 1
88363: PUSH
88364: FOR_IN
88365: IFFALSE 88440
// if GetClass ( un ) = class then
88367: LD_VAR 0 4
88371: PPUSH
88372: CALL_OW 257
88376: PUSH
88377: LD_VAR 0 2
88381: EQUAL
88382: IFFALSE 88409
// result := Insert ( result , 1 , un ) else
88384: LD_ADDR_VAR 0 3
88388: PUSH
88389: LD_VAR 0 3
88393: PPUSH
88394: LD_INT 1
88396: PPUSH
88397: LD_VAR 0 4
88401: PPUSH
88402: CALL_OW 2
88406: ST_TO_ADDR
88407: GO 88438
// result := Replace ( result , result + 1 , un ) ;
88409: LD_ADDR_VAR 0 3
88413: PUSH
88414: LD_VAR 0 3
88418: PPUSH
88419: LD_VAR 0 3
88423: PUSH
88424: LD_INT 1
88426: PLUS
88427: PPUSH
88428: LD_VAR 0 4
88432: PPUSH
88433: CALL_OW 1
88437: ST_TO_ADDR
88438: GO 88364
88440: POP
88441: POP
// end ;
88442: LD_VAR 0 3
88446: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
88447: LD_INT 0
88449: PPUSH
88450: PPUSH
88451: PPUSH
88452: PPUSH
88453: PPUSH
88454: PPUSH
88455: PPUSH
// result := [ ] ;
88456: LD_ADDR_VAR 0 4
88460: PUSH
88461: EMPTY
88462: ST_TO_ADDR
// if x - r < 0 then
88463: LD_VAR 0 1
88467: PUSH
88468: LD_VAR 0 3
88472: MINUS
88473: PUSH
88474: LD_INT 0
88476: LESS
88477: IFFALSE 88489
// min_x := 0 else
88479: LD_ADDR_VAR 0 8
88483: PUSH
88484: LD_INT 0
88486: ST_TO_ADDR
88487: GO 88505
// min_x := x - r ;
88489: LD_ADDR_VAR 0 8
88493: PUSH
88494: LD_VAR 0 1
88498: PUSH
88499: LD_VAR 0 3
88503: MINUS
88504: ST_TO_ADDR
// if y - r < 0 then
88505: LD_VAR 0 2
88509: PUSH
88510: LD_VAR 0 3
88514: MINUS
88515: PUSH
88516: LD_INT 0
88518: LESS
88519: IFFALSE 88531
// min_y := 0 else
88521: LD_ADDR_VAR 0 7
88525: PUSH
88526: LD_INT 0
88528: ST_TO_ADDR
88529: GO 88547
// min_y := y - r ;
88531: LD_ADDR_VAR 0 7
88535: PUSH
88536: LD_VAR 0 2
88540: PUSH
88541: LD_VAR 0 3
88545: MINUS
88546: ST_TO_ADDR
// max_x := x + r ;
88547: LD_ADDR_VAR 0 9
88551: PUSH
88552: LD_VAR 0 1
88556: PUSH
88557: LD_VAR 0 3
88561: PLUS
88562: ST_TO_ADDR
// max_y := y + r ;
88563: LD_ADDR_VAR 0 10
88567: PUSH
88568: LD_VAR 0 2
88572: PUSH
88573: LD_VAR 0 3
88577: PLUS
88578: ST_TO_ADDR
// for _x = min_x to max_x do
88579: LD_ADDR_VAR 0 5
88583: PUSH
88584: DOUBLE
88585: LD_VAR 0 8
88589: DEC
88590: ST_TO_ADDR
88591: LD_VAR 0 9
88595: PUSH
88596: FOR_TO
88597: IFFALSE 88698
// for _y = min_y to max_y do
88599: LD_ADDR_VAR 0 6
88603: PUSH
88604: DOUBLE
88605: LD_VAR 0 7
88609: DEC
88610: ST_TO_ADDR
88611: LD_VAR 0 10
88615: PUSH
88616: FOR_TO
88617: IFFALSE 88694
// begin if not ValidHex ( _x , _y ) then
88619: LD_VAR 0 5
88623: PPUSH
88624: LD_VAR 0 6
88628: PPUSH
88629: CALL_OW 488
88633: NOT
88634: IFFALSE 88638
// continue ;
88636: GO 88616
// if GetResourceTypeXY ( _x , _y ) then
88638: LD_VAR 0 5
88642: PPUSH
88643: LD_VAR 0 6
88647: PPUSH
88648: CALL_OW 283
88652: IFFALSE 88692
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
88654: LD_ADDR_VAR 0 4
88658: PUSH
88659: LD_VAR 0 4
88663: PPUSH
88664: LD_VAR 0 4
88668: PUSH
88669: LD_INT 1
88671: PLUS
88672: PPUSH
88673: LD_VAR 0 5
88677: PUSH
88678: LD_VAR 0 6
88682: PUSH
88683: EMPTY
88684: LIST
88685: LIST
88686: PPUSH
88687: CALL_OW 1
88691: ST_TO_ADDR
// end ;
88692: GO 88616
88694: POP
88695: POP
88696: GO 88596
88698: POP
88699: POP
// end ;
88700: LD_VAR 0 4
88704: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
88705: LD_INT 0
88707: PPUSH
88708: PPUSH
88709: PPUSH
88710: PPUSH
88711: PPUSH
88712: PPUSH
88713: PPUSH
88714: PPUSH
// if not units then
88715: LD_VAR 0 1
88719: NOT
88720: IFFALSE 88724
// exit ;
88722: GO 89248
// result := UnitFilter ( units , [ f_ok ] ) ;
88724: LD_ADDR_VAR 0 3
88728: PUSH
88729: LD_VAR 0 1
88733: PPUSH
88734: LD_INT 50
88736: PUSH
88737: EMPTY
88738: LIST
88739: PPUSH
88740: CALL_OW 72
88744: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
88745: LD_ADDR_VAR 0 8
88749: PUSH
88750: LD_VAR 0 1
88754: PUSH
88755: LD_INT 1
88757: ARRAY
88758: PPUSH
88759: CALL_OW 255
88763: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
88764: LD_ADDR_VAR 0 10
88768: PUSH
88769: LD_INT 29
88771: PUSH
88772: LD_INT 91
88774: PUSH
88775: LD_INT 49
88777: PUSH
88778: EMPTY
88779: LIST
88780: LIST
88781: LIST
88782: ST_TO_ADDR
// if not result then
88783: LD_VAR 0 3
88787: NOT
88788: IFFALSE 88792
// exit ;
88790: GO 89248
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
88792: LD_ADDR_VAR 0 5
88796: PUSH
88797: LD_INT 81
88799: PUSH
88800: LD_VAR 0 8
88804: PUSH
88805: EMPTY
88806: LIST
88807: LIST
88808: PPUSH
88809: CALL_OW 69
88813: ST_TO_ADDR
// for i in result do
88814: LD_ADDR_VAR 0 4
88818: PUSH
88819: LD_VAR 0 3
88823: PUSH
88824: FOR_IN
88825: IFFALSE 89246
// begin tag := GetTag ( i ) + 1 ;
88827: LD_ADDR_VAR 0 9
88831: PUSH
88832: LD_VAR 0 4
88836: PPUSH
88837: CALL_OW 110
88841: PUSH
88842: LD_INT 1
88844: PLUS
88845: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
88846: LD_ADDR_VAR 0 7
88850: PUSH
88851: LD_VAR 0 4
88855: PPUSH
88856: CALL_OW 250
88860: PPUSH
88861: LD_VAR 0 4
88865: PPUSH
88866: CALL_OW 251
88870: PPUSH
88871: LD_INT 6
88873: PPUSH
88874: CALL 88447 0 3
88878: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
88879: LD_VAR 0 4
88883: PPUSH
88884: CALL_OW 247
88888: PUSH
88889: LD_INT 2
88891: EQUAL
88892: PUSH
88893: LD_VAR 0 7
88897: AND
88898: PUSH
88899: LD_VAR 0 4
88903: PPUSH
88904: CALL_OW 264
88908: PUSH
88909: LD_VAR 0 10
88913: IN
88914: NOT
88915: AND
88916: IFFALSE 88955
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
88918: LD_VAR 0 4
88922: PPUSH
88923: LD_VAR 0 7
88927: PUSH
88928: LD_INT 1
88930: ARRAY
88931: PUSH
88932: LD_INT 1
88934: ARRAY
88935: PPUSH
88936: LD_VAR 0 7
88940: PUSH
88941: LD_INT 1
88943: ARRAY
88944: PUSH
88945: LD_INT 2
88947: ARRAY
88948: PPUSH
88949: CALL_OW 116
88953: GO 89244
// if path > tag then
88955: LD_VAR 0 2
88959: PUSH
88960: LD_VAR 0 9
88964: GREATER
88965: IFFALSE 89173
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
88967: LD_ADDR_VAR 0 6
88971: PUSH
88972: LD_VAR 0 5
88976: PPUSH
88977: LD_INT 91
88979: PUSH
88980: LD_VAR 0 4
88984: PUSH
88985: LD_INT 8
88987: PUSH
88988: EMPTY
88989: LIST
88990: LIST
88991: LIST
88992: PPUSH
88993: CALL_OW 72
88997: ST_TO_ADDR
// if nearEnemy then
88998: LD_VAR 0 6
89002: IFFALSE 89071
// begin if GetWeapon ( i ) = ru_time_lapser then
89004: LD_VAR 0 4
89008: PPUSH
89009: CALL_OW 264
89013: PUSH
89014: LD_INT 49
89016: EQUAL
89017: IFFALSE 89045
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
89019: LD_VAR 0 4
89023: PPUSH
89024: LD_VAR 0 6
89028: PPUSH
89029: LD_VAR 0 4
89033: PPUSH
89034: CALL_OW 74
89038: PPUSH
89039: CALL_OW 112
89043: GO 89069
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
89045: LD_VAR 0 4
89049: PPUSH
89050: LD_VAR 0 6
89054: PPUSH
89055: LD_VAR 0 4
89059: PPUSH
89060: CALL_OW 74
89064: PPUSH
89065: CALL_OW 115
// end else
89069: GO 89171
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
89071: LD_VAR 0 4
89075: PPUSH
89076: LD_VAR 0 2
89080: PUSH
89081: LD_VAR 0 9
89085: ARRAY
89086: PUSH
89087: LD_INT 1
89089: ARRAY
89090: PPUSH
89091: LD_VAR 0 2
89095: PUSH
89096: LD_VAR 0 9
89100: ARRAY
89101: PUSH
89102: LD_INT 2
89104: ARRAY
89105: PPUSH
89106: CALL_OW 297
89110: PUSH
89111: LD_INT 6
89113: GREATER
89114: IFFALSE 89157
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
89116: LD_VAR 0 4
89120: PPUSH
89121: LD_VAR 0 2
89125: PUSH
89126: LD_VAR 0 9
89130: ARRAY
89131: PUSH
89132: LD_INT 1
89134: ARRAY
89135: PPUSH
89136: LD_VAR 0 2
89140: PUSH
89141: LD_VAR 0 9
89145: ARRAY
89146: PUSH
89147: LD_INT 2
89149: ARRAY
89150: PPUSH
89151: CALL_OW 114
89155: GO 89171
// SetTag ( i , tag ) ;
89157: LD_VAR 0 4
89161: PPUSH
89162: LD_VAR 0 9
89166: PPUSH
89167: CALL_OW 109
// end else
89171: GO 89244
// if enemy then
89173: LD_VAR 0 5
89177: IFFALSE 89244
// begin if GetWeapon ( i ) = ru_time_lapser then
89179: LD_VAR 0 4
89183: PPUSH
89184: CALL_OW 264
89188: PUSH
89189: LD_INT 49
89191: EQUAL
89192: IFFALSE 89220
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
89194: LD_VAR 0 4
89198: PPUSH
89199: LD_VAR 0 5
89203: PPUSH
89204: LD_VAR 0 4
89208: PPUSH
89209: CALL_OW 74
89213: PPUSH
89214: CALL_OW 112
89218: GO 89244
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
89220: LD_VAR 0 4
89224: PPUSH
89225: LD_VAR 0 5
89229: PPUSH
89230: LD_VAR 0 4
89234: PPUSH
89235: CALL_OW 74
89239: PPUSH
89240: CALL_OW 115
// end ; end ;
89244: GO 88824
89246: POP
89247: POP
// end ;
89248: LD_VAR 0 3
89252: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
89253: LD_INT 0
89255: PPUSH
89256: PPUSH
89257: PPUSH
// if not unit or IsInUnit ( unit ) then
89258: LD_VAR 0 1
89262: NOT
89263: PUSH
89264: LD_VAR 0 1
89268: PPUSH
89269: CALL_OW 310
89273: OR
89274: IFFALSE 89278
// exit ;
89276: GO 89369
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
89278: LD_ADDR_VAR 0 4
89282: PUSH
89283: LD_VAR 0 1
89287: PPUSH
89288: CALL_OW 250
89292: PPUSH
89293: LD_VAR 0 2
89297: PPUSH
89298: LD_INT 1
89300: PPUSH
89301: CALL_OW 272
89305: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
89306: LD_ADDR_VAR 0 5
89310: PUSH
89311: LD_VAR 0 1
89315: PPUSH
89316: CALL_OW 251
89320: PPUSH
89321: LD_VAR 0 2
89325: PPUSH
89326: LD_INT 1
89328: PPUSH
89329: CALL_OW 273
89333: ST_TO_ADDR
// if ValidHex ( x , y ) then
89334: LD_VAR 0 4
89338: PPUSH
89339: LD_VAR 0 5
89343: PPUSH
89344: CALL_OW 488
89348: IFFALSE 89369
// ComTurnXY ( unit , x , y ) ;
89350: LD_VAR 0 1
89354: PPUSH
89355: LD_VAR 0 4
89359: PPUSH
89360: LD_VAR 0 5
89364: PPUSH
89365: CALL_OW 118
// end ;
89369: LD_VAR 0 3
89373: RET
// export function SeeUnits ( side , units ) ; var i ; begin
89374: LD_INT 0
89376: PPUSH
89377: PPUSH
// result := false ;
89378: LD_ADDR_VAR 0 3
89382: PUSH
89383: LD_INT 0
89385: ST_TO_ADDR
// if not units then
89386: LD_VAR 0 2
89390: NOT
89391: IFFALSE 89395
// exit ;
89393: GO 89440
// for i in units do
89395: LD_ADDR_VAR 0 4
89399: PUSH
89400: LD_VAR 0 2
89404: PUSH
89405: FOR_IN
89406: IFFALSE 89438
// if See ( side , i ) then
89408: LD_VAR 0 1
89412: PPUSH
89413: LD_VAR 0 4
89417: PPUSH
89418: CALL_OW 292
89422: IFFALSE 89436
// begin result := true ;
89424: LD_ADDR_VAR 0 3
89428: PUSH
89429: LD_INT 1
89431: ST_TO_ADDR
// exit ;
89432: POP
89433: POP
89434: GO 89440
// end ;
89436: GO 89405
89438: POP
89439: POP
// end ;
89440: LD_VAR 0 3
89444: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
89445: LD_INT 0
89447: PPUSH
89448: PPUSH
89449: PPUSH
89450: PPUSH
// if not unit or not points then
89451: LD_VAR 0 1
89455: NOT
89456: PUSH
89457: LD_VAR 0 2
89461: NOT
89462: OR
89463: IFFALSE 89467
// exit ;
89465: GO 89557
// dist := 99999 ;
89467: LD_ADDR_VAR 0 5
89471: PUSH
89472: LD_INT 99999
89474: ST_TO_ADDR
// for i in points do
89475: LD_ADDR_VAR 0 4
89479: PUSH
89480: LD_VAR 0 2
89484: PUSH
89485: FOR_IN
89486: IFFALSE 89555
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
89488: LD_ADDR_VAR 0 6
89492: PUSH
89493: LD_VAR 0 1
89497: PPUSH
89498: LD_VAR 0 4
89502: PUSH
89503: LD_INT 1
89505: ARRAY
89506: PPUSH
89507: LD_VAR 0 4
89511: PUSH
89512: LD_INT 2
89514: ARRAY
89515: PPUSH
89516: CALL_OW 297
89520: ST_TO_ADDR
// if tmpDist < dist then
89521: LD_VAR 0 6
89525: PUSH
89526: LD_VAR 0 5
89530: LESS
89531: IFFALSE 89553
// begin result := i ;
89533: LD_ADDR_VAR 0 3
89537: PUSH
89538: LD_VAR 0 4
89542: ST_TO_ADDR
// dist := tmpDist ;
89543: LD_ADDR_VAR 0 5
89547: PUSH
89548: LD_VAR 0 6
89552: ST_TO_ADDR
// end ; end ;
89553: GO 89485
89555: POP
89556: POP
// end ;
89557: LD_VAR 0 3
89561: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
89562: LD_INT 0
89564: PPUSH
// uc_side := side ;
89565: LD_ADDR_OWVAR 20
89569: PUSH
89570: LD_VAR 0 1
89574: ST_TO_ADDR
// uc_nation := 3 ;
89575: LD_ADDR_OWVAR 21
89579: PUSH
89580: LD_INT 3
89582: ST_TO_ADDR
// vc_chassis := 25 ;
89583: LD_ADDR_OWVAR 37
89587: PUSH
89588: LD_INT 25
89590: ST_TO_ADDR
// vc_engine := engine_siberite ;
89591: LD_ADDR_OWVAR 39
89595: PUSH
89596: LD_INT 3
89598: ST_TO_ADDR
// vc_control := control_computer ;
89599: LD_ADDR_OWVAR 38
89603: PUSH
89604: LD_INT 3
89606: ST_TO_ADDR
// vc_weapon := 59 ;
89607: LD_ADDR_OWVAR 40
89611: PUSH
89612: LD_INT 59
89614: ST_TO_ADDR
// result := CreateVehicle ;
89615: LD_ADDR_VAR 0 5
89619: PUSH
89620: CALL_OW 45
89624: ST_TO_ADDR
// SetDir ( result , d ) ;
89625: LD_VAR 0 5
89629: PPUSH
89630: LD_VAR 0 4
89634: PPUSH
89635: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
89639: LD_VAR 0 5
89643: PPUSH
89644: LD_VAR 0 2
89648: PPUSH
89649: LD_VAR 0 3
89653: PPUSH
89654: LD_INT 0
89656: PPUSH
89657: CALL_OW 48
// end ;
89661: LD_VAR 0 5
89665: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
89666: LD_INT 0
89668: PPUSH
89669: PPUSH
89670: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
89671: LD_ADDR_VAR 0 2
89675: PUSH
89676: LD_INT 0
89678: PUSH
89679: LD_INT 0
89681: PUSH
89682: LD_INT 0
89684: PUSH
89685: LD_INT 0
89687: PUSH
89688: EMPTY
89689: LIST
89690: LIST
89691: LIST
89692: LIST
89693: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
89694: LD_VAR 0 1
89698: NOT
89699: PUSH
89700: LD_VAR 0 1
89704: PPUSH
89705: CALL_OW 264
89709: PUSH
89710: LD_INT 12
89712: PUSH
89713: LD_INT 51
89715: PUSH
89716: LD_INT 32
89718: PUSH
89719: LD_INT 89
89721: PUSH
89722: EMPTY
89723: LIST
89724: LIST
89725: LIST
89726: LIST
89727: IN
89728: NOT
89729: OR
89730: IFFALSE 89734
// exit ;
89732: GO 89832
// for i := 1 to 3 do
89734: LD_ADDR_VAR 0 3
89738: PUSH
89739: DOUBLE
89740: LD_INT 1
89742: DEC
89743: ST_TO_ADDR
89744: LD_INT 3
89746: PUSH
89747: FOR_TO
89748: IFFALSE 89830
// begin tmp := GetCargo ( cargo , i ) ;
89750: LD_ADDR_VAR 0 4
89754: PUSH
89755: LD_VAR 0 1
89759: PPUSH
89760: LD_VAR 0 3
89764: PPUSH
89765: CALL_OW 289
89769: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
89770: LD_ADDR_VAR 0 2
89774: PUSH
89775: LD_VAR 0 2
89779: PPUSH
89780: LD_VAR 0 3
89784: PPUSH
89785: LD_VAR 0 4
89789: PPUSH
89790: CALL_OW 1
89794: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
89795: LD_ADDR_VAR 0 2
89799: PUSH
89800: LD_VAR 0 2
89804: PPUSH
89805: LD_INT 4
89807: PPUSH
89808: LD_VAR 0 2
89812: PUSH
89813: LD_INT 4
89815: ARRAY
89816: PUSH
89817: LD_VAR 0 4
89821: PLUS
89822: PPUSH
89823: CALL_OW 1
89827: ST_TO_ADDR
// end ;
89828: GO 89747
89830: POP
89831: POP
// end ;
89832: LD_VAR 0 2
89836: RET
// export function Length ( array ) ; begin
89837: LD_INT 0
89839: PPUSH
// result := array + 0 ;
89840: LD_ADDR_VAR 0 2
89844: PUSH
89845: LD_VAR 0 1
89849: PUSH
89850: LD_INT 0
89852: PLUS
89853: ST_TO_ADDR
// end ;
89854: LD_VAR 0 2
89858: RET
// export function PrepareArray ( array ) ; begin
89859: LD_INT 0
89861: PPUSH
// result := array diff 0 ;
89862: LD_ADDR_VAR 0 2
89866: PUSH
89867: LD_VAR 0 1
89871: PUSH
89872: LD_INT 0
89874: DIFF
89875: ST_TO_ADDR
// if not result [ 1 ] then
89876: LD_VAR 0 2
89880: PUSH
89881: LD_INT 1
89883: ARRAY
89884: NOT
89885: IFFALSE 89905
// result := Delete ( result , 1 ) ;
89887: LD_ADDR_VAR 0 2
89891: PUSH
89892: LD_VAR 0 2
89896: PPUSH
89897: LD_INT 1
89899: PPUSH
89900: CALL_OW 3
89904: ST_TO_ADDR
// end ;
89905: LD_VAR 0 2
89909: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
89910: LD_INT 0
89912: PPUSH
89913: PPUSH
89914: PPUSH
89915: PPUSH
// sibRocketRange := 25 ;
89916: LD_ADDR_VAR 0 6
89920: PUSH
89921: LD_INT 25
89923: ST_TO_ADDR
// result := false ;
89924: LD_ADDR_VAR 0 4
89928: PUSH
89929: LD_INT 0
89931: ST_TO_ADDR
// for i := 0 to 5 do
89932: LD_ADDR_VAR 0 5
89936: PUSH
89937: DOUBLE
89938: LD_INT 0
89940: DEC
89941: ST_TO_ADDR
89942: LD_INT 5
89944: PUSH
89945: FOR_TO
89946: IFFALSE 90013
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
89948: LD_VAR 0 1
89952: PPUSH
89953: LD_VAR 0 5
89957: PPUSH
89958: LD_VAR 0 6
89962: PPUSH
89963: CALL_OW 272
89967: PPUSH
89968: LD_VAR 0 2
89972: PPUSH
89973: LD_VAR 0 5
89977: PPUSH
89978: LD_VAR 0 6
89982: PPUSH
89983: CALL_OW 273
89987: PPUSH
89988: LD_VAR 0 3
89992: PPUSH
89993: CALL_OW 309
89997: IFFALSE 90011
// begin result := true ;
89999: LD_ADDR_VAR 0 4
90003: PUSH
90004: LD_INT 1
90006: ST_TO_ADDR
// exit ;
90007: POP
90008: POP
90009: GO 90015
// end ;
90011: GO 89945
90013: POP
90014: POP
// end ;
90015: LD_VAR 0 4
90019: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
90020: LD_INT 0
90022: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
90023: LD_VAR 0 1
90027: PPUSH
90028: LD_VAR 0 2
90032: PPUSH
90033: LD_INT 0
90035: PPUSH
90036: LD_INT 0
90038: PPUSH
90039: LD_INT 1
90041: PPUSH
90042: LD_INT 0
90044: PPUSH
90045: CALL_OW 587
// end ; end_of_file end_of_file
90049: LD_VAR 0 3
90053: RET
// every 0 0$1 do
90054: GO 90056
90056: DISABLE
// begin enable ;
90057: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
90058: LD_STRING updateTimer(
90060: PUSH
90061: LD_OWVAR 1
90065: STR
90066: PUSH
90067: LD_STRING );
90069: STR
90070: PPUSH
90071: CALL_OW 559
// end ;
90075: END
// export function SOS_MapStart ( ) ; begin
90076: LD_INT 0
90078: PPUSH
// if streamModeActive then
90079: LD_EXP 94
90083: IFFALSE 90092
// DefineStreamItems ( true ) ;
90085: LD_INT 1
90087: PPUSH
90088: CALL 91746 0 1
// UpdateFactoryWaypoints ( ) ;
90092: CALL 104607 0 0
// UpdateWarehouseGatheringPoints ( ) ;
90096: CALL 104864 0 0
// end ;
90100: LD_VAR 0 1
90104: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
90105: LD_INT 0
90107: PPUSH
// if p2 = hack_mode then
90108: LD_VAR 0 2
90112: PUSH
90113: LD_INT 100
90115: EQUAL
90116: IFFALSE 91119
// begin if not StreamModeActive then
90118: LD_EXP 94
90122: NOT
90123: IFFALSE 90133
// StreamModeActive := true ;
90125: LD_ADDR_EXP 94
90129: PUSH
90130: LD_INT 1
90132: ST_TO_ADDR
// if p3 = 0 then
90133: LD_VAR 0 3
90137: PUSH
90138: LD_INT 0
90140: EQUAL
90141: IFFALSE 90147
// InitStreamMode ;
90143: CALL 91282 0 0
// if p3 = 1 then
90147: LD_VAR 0 3
90151: PUSH
90152: LD_INT 1
90154: EQUAL
90155: IFFALSE 90165
// sRocket := true ;
90157: LD_ADDR_EXP 99
90161: PUSH
90162: LD_INT 1
90164: ST_TO_ADDR
// if p3 = 2 then
90165: LD_VAR 0 3
90169: PUSH
90170: LD_INT 2
90172: EQUAL
90173: IFFALSE 90183
// sSpeed := true ;
90175: LD_ADDR_EXP 98
90179: PUSH
90180: LD_INT 1
90182: ST_TO_ADDR
// if p3 = 3 then
90183: LD_VAR 0 3
90187: PUSH
90188: LD_INT 3
90190: EQUAL
90191: IFFALSE 90201
// sEngine := true ;
90193: LD_ADDR_EXP 100
90197: PUSH
90198: LD_INT 1
90200: ST_TO_ADDR
// if p3 = 4 then
90201: LD_VAR 0 3
90205: PUSH
90206: LD_INT 4
90208: EQUAL
90209: IFFALSE 90219
// sSpec := true ;
90211: LD_ADDR_EXP 97
90215: PUSH
90216: LD_INT 1
90218: ST_TO_ADDR
// if p3 = 5 then
90219: LD_VAR 0 3
90223: PUSH
90224: LD_INT 5
90226: EQUAL
90227: IFFALSE 90237
// sLevel := true ;
90229: LD_ADDR_EXP 101
90233: PUSH
90234: LD_INT 1
90236: ST_TO_ADDR
// if p3 = 6 then
90237: LD_VAR 0 3
90241: PUSH
90242: LD_INT 6
90244: EQUAL
90245: IFFALSE 90255
// sArmoury := true ;
90247: LD_ADDR_EXP 102
90251: PUSH
90252: LD_INT 1
90254: ST_TO_ADDR
// if p3 = 7 then
90255: LD_VAR 0 3
90259: PUSH
90260: LD_INT 7
90262: EQUAL
90263: IFFALSE 90273
// sRadar := true ;
90265: LD_ADDR_EXP 103
90269: PUSH
90270: LD_INT 1
90272: ST_TO_ADDR
// if p3 = 8 then
90273: LD_VAR 0 3
90277: PUSH
90278: LD_INT 8
90280: EQUAL
90281: IFFALSE 90291
// sBunker := true ;
90283: LD_ADDR_EXP 104
90287: PUSH
90288: LD_INT 1
90290: ST_TO_ADDR
// if p3 = 9 then
90291: LD_VAR 0 3
90295: PUSH
90296: LD_INT 9
90298: EQUAL
90299: IFFALSE 90309
// sHack := true ;
90301: LD_ADDR_EXP 105
90305: PUSH
90306: LD_INT 1
90308: ST_TO_ADDR
// if p3 = 10 then
90309: LD_VAR 0 3
90313: PUSH
90314: LD_INT 10
90316: EQUAL
90317: IFFALSE 90327
// sFire := true ;
90319: LD_ADDR_EXP 106
90323: PUSH
90324: LD_INT 1
90326: ST_TO_ADDR
// if p3 = 11 then
90327: LD_VAR 0 3
90331: PUSH
90332: LD_INT 11
90334: EQUAL
90335: IFFALSE 90345
// sRefresh := true ;
90337: LD_ADDR_EXP 107
90341: PUSH
90342: LD_INT 1
90344: ST_TO_ADDR
// if p3 = 12 then
90345: LD_VAR 0 3
90349: PUSH
90350: LD_INT 12
90352: EQUAL
90353: IFFALSE 90363
// sExp := true ;
90355: LD_ADDR_EXP 108
90359: PUSH
90360: LD_INT 1
90362: ST_TO_ADDR
// if p3 = 13 then
90363: LD_VAR 0 3
90367: PUSH
90368: LD_INT 13
90370: EQUAL
90371: IFFALSE 90381
// sDepot := true ;
90373: LD_ADDR_EXP 109
90377: PUSH
90378: LD_INT 1
90380: ST_TO_ADDR
// if p3 = 14 then
90381: LD_VAR 0 3
90385: PUSH
90386: LD_INT 14
90388: EQUAL
90389: IFFALSE 90399
// sFlag := true ;
90391: LD_ADDR_EXP 110
90395: PUSH
90396: LD_INT 1
90398: ST_TO_ADDR
// if p3 = 15 then
90399: LD_VAR 0 3
90403: PUSH
90404: LD_INT 15
90406: EQUAL
90407: IFFALSE 90417
// sKamikadze := true ;
90409: LD_ADDR_EXP 118
90413: PUSH
90414: LD_INT 1
90416: ST_TO_ADDR
// if p3 = 16 then
90417: LD_VAR 0 3
90421: PUSH
90422: LD_INT 16
90424: EQUAL
90425: IFFALSE 90435
// sTroll := true ;
90427: LD_ADDR_EXP 119
90431: PUSH
90432: LD_INT 1
90434: ST_TO_ADDR
// if p3 = 17 then
90435: LD_VAR 0 3
90439: PUSH
90440: LD_INT 17
90442: EQUAL
90443: IFFALSE 90453
// sSlow := true ;
90445: LD_ADDR_EXP 120
90449: PUSH
90450: LD_INT 1
90452: ST_TO_ADDR
// if p3 = 18 then
90453: LD_VAR 0 3
90457: PUSH
90458: LD_INT 18
90460: EQUAL
90461: IFFALSE 90471
// sLack := true ;
90463: LD_ADDR_EXP 121
90467: PUSH
90468: LD_INT 1
90470: ST_TO_ADDR
// if p3 = 19 then
90471: LD_VAR 0 3
90475: PUSH
90476: LD_INT 19
90478: EQUAL
90479: IFFALSE 90489
// sTank := true ;
90481: LD_ADDR_EXP 123
90485: PUSH
90486: LD_INT 1
90488: ST_TO_ADDR
// if p3 = 20 then
90489: LD_VAR 0 3
90493: PUSH
90494: LD_INT 20
90496: EQUAL
90497: IFFALSE 90507
// sRemote := true ;
90499: LD_ADDR_EXP 124
90503: PUSH
90504: LD_INT 1
90506: ST_TO_ADDR
// if p3 = 21 then
90507: LD_VAR 0 3
90511: PUSH
90512: LD_INT 21
90514: EQUAL
90515: IFFALSE 90525
// sPowell := true ;
90517: LD_ADDR_EXP 125
90521: PUSH
90522: LD_INT 1
90524: ST_TO_ADDR
// if p3 = 22 then
90525: LD_VAR 0 3
90529: PUSH
90530: LD_INT 22
90532: EQUAL
90533: IFFALSE 90543
// sTeleport := true ;
90535: LD_ADDR_EXP 128
90539: PUSH
90540: LD_INT 1
90542: ST_TO_ADDR
// if p3 = 23 then
90543: LD_VAR 0 3
90547: PUSH
90548: LD_INT 23
90550: EQUAL
90551: IFFALSE 90561
// sOilTower := true ;
90553: LD_ADDR_EXP 130
90557: PUSH
90558: LD_INT 1
90560: ST_TO_ADDR
// if p3 = 24 then
90561: LD_VAR 0 3
90565: PUSH
90566: LD_INT 24
90568: EQUAL
90569: IFFALSE 90579
// sShovel := true ;
90571: LD_ADDR_EXP 131
90575: PUSH
90576: LD_INT 1
90578: ST_TO_ADDR
// if p3 = 25 then
90579: LD_VAR 0 3
90583: PUSH
90584: LD_INT 25
90586: EQUAL
90587: IFFALSE 90597
// sSheik := true ;
90589: LD_ADDR_EXP 132
90593: PUSH
90594: LD_INT 1
90596: ST_TO_ADDR
// if p3 = 26 then
90597: LD_VAR 0 3
90601: PUSH
90602: LD_INT 26
90604: EQUAL
90605: IFFALSE 90615
// sEarthquake := true ;
90607: LD_ADDR_EXP 134
90611: PUSH
90612: LD_INT 1
90614: ST_TO_ADDR
// if p3 = 27 then
90615: LD_VAR 0 3
90619: PUSH
90620: LD_INT 27
90622: EQUAL
90623: IFFALSE 90633
// sAI := true ;
90625: LD_ADDR_EXP 135
90629: PUSH
90630: LD_INT 1
90632: ST_TO_ADDR
// if p3 = 28 then
90633: LD_VAR 0 3
90637: PUSH
90638: LD_INT 28
90640: EQUAL
90641: IFFALSE 90651
// sCargo := true ;
90643: LD_ADDR_EXP 138
90647: PUSH
90648: LD_INT 1
90650: ST_TO_ADDR
// if p3 = 29 then
90651: LD_VAR 0 3
90655: PUSH
90656: LD_INT 29
90658: EQUAL
90659: IFFALSE 90669
// sDLaser := true ;
90661: LD_ADDR_EXP 139
90665: PUSH
90666: LD_INT 1
90668: ST_TO_ADDR
// if p3 = 30 then
90669: LD_VAR 0 3
90673: PUSH
90674: LD_INT 30
90676: EQUAL
90677: IFFALSE 90687
// sExchange := true ;
90679: LD_ADDR_EXP 140
90683: PUSH
90684: LD_INT 1
90686: ST_TO_ADDR
// if p3 = 31 then
90687: LD_VAR 0 3
90691: PUSH
90692: LD_INT 31
90694: EQUAL
90695: IFFALSE 90705
// sFac := true ;
90697: LD_ADDR_EXP 141
90701: PUSH
90702: LD_INT 1
90704: ST_TO_ADDR
// if p3 = 32 then
90705: LD_VAR 0 3
90709: PUSH
90710: LD_INT 32
90712: EQUAL
90713: IFFALSE 90723
// sPower := true ;
90715: LD_ADDR_EXP 142
90719: PUSH
90720: LD_INT 1
90722: ST_TO_ADDR
// if p3 = 33 then
90723: LD_VAR 0 3
90727: PUSH
90728: LD_INT 33
90730: EQUAL
90731: IFFALSE 90741
// sRandom := true ;
90733: LD_ADDR_EXP 143
90737: PUSH
90738: LD_INT 1
90740: ST_TO_ADDR
// if p3 = 34 then
90741: LD_VAR 0 3
90745: PUSH
90746: LD_INT 34
90748: EQUAL
90749: IFFALSE 90759
// sShield := true ;
90751: LD_ADDR_EXP 144
90755: PUSH
90756: LD_INT 1
90758: ST_TO_ADDR
// if p3 = 35 then
90759: LD_VAR 0 3
90763: PUSH
90764: LD_INT 35
90766: EQUAL
90767: IFFALSE 90777
// sTime := true ;
90769: LD_ADDR_EXP 145
90773: PUSH
90774: LD_INT 1
90776: ST_TO_ADDR
// if p3 = 36 then
90777: LD_VAR 0 3
90781: PUSH
90782: LD_INT 36
90784: EQUAL
90785: IFFALSE 90795
// sTools := true ;
90787: LD_ADDR_EXP 146
90791: PUSH
90792: LD_INT 1
90794: ST_TO_ADDR
// if p3 = 101 then
90795: LD_VAR 0 3
90799: PUSH
90800: LD_INT 101
90802: EQUAL
90803: IFFALSE 90813
// sSold := true ;
90805: LD_ADDR_EXP 111
90809: PUSH
90810: LD_INT 1
90812: ST_TO_ADDR
// if p3 = 102 then
90813: LD_VAR 0 3
90817: PUSH
90818: LD_INT 102
90820: EQUAL
90821: IFFALSE 90831
// sDiff := true ;
90823: LD_ADDR_EXP 112
90827: PUSH
90828: LD_INT 1
90830: ST_TO_ADDR
// if p3 = 103 then
90831: LD_VAR 0 3
90835: PUSH
90836: LD_INT 103
90838: EQUAL
90839: IFFALSE 90849
// sFog := true ;
90841: LD_ADDR_EXP 115
90845: PUSH
90846: LD_INT 1
90848: ST_TO_ADDR
// if p3 = 104 then
90849: LD_VAR 0 3
90853: PUSH
90854: LD_INT 104
90856: EQUAL
90857: IFFALSE 90867
// sReset := true ;
90859: LD_ADDR_EXP 116
90863: PUSH
90864: LD_INT 1
90866: ST_TO_ADDR
// if p3 = 105 then
90867: LD_VAR 0 3
90871: PUSH
90872: LD_INT 105
90874: EQUAL
90875: IFFALSE 90885
// sSun := true ;
90877: LD_ADDR_EXP 117
90881: PUSH
90882: LD_INT 1
90884: ST_TO_ADDR
// if p3 = 106 then
90885: LD_VAR 0 3
90889: PUSH
90890: LD_INT 106
90892: EQUAL
90893: IFFALSE 90903
// sTiger := true ;
90895: LD_ADDR_EXP 113
90899: PUSH
90900: LD_INT 1
90902: ST_TO_ADDR
// if p3 = 107 then
90903: LD_VAR 0 3
90907: PUSH
90908: LD_INT 107
90910: EQUAL
90911: IFFALSE 90921
// sBomb := true ;
90913: LD_ADDR_EXP 114
90917: PUSH
90918: LD_INT 1
90920: ST_TO_ADDR
// if p3 = 108 then
90921: LD_VAR 0 3
90925: PUSH
90926: LD_INT 108
90928: EQUAL
90929: IFFALSE 90939
// sWound := true ;
90931: LD_ADDR_EXP 122
90935: PUSH
90936: LD_INT 1
90938: ST_TO_ADDR
// if p3 = 109 then
90939: LD_VAR 0 3
90943: PUSH
90944: LD_INT 109
90946: EQUAL
90947: IFFALSE 90957
// sBetray := true ;
90949: LD_ADDR_EXP 126
90953: PUSH
90954: LD_INT 1
90956: ST_TO_ADDR
// if p3 = 110 then
90957: LD_VAR 0 3
90961: PUSH
90962: LD_INT 110
90964: EQUAL
90965: IFFALSE 90975
// sContamin := true ;
90967: LD_ADDR_EXP 127
90971: PUSH
90972: LD_INT 1
90974: ST_TO_ADDR
// if p3 = 111 then
90975: LD_VAR 0 3
90979: PUSH
90980: LD_INT 111
90982: EQUAL
90983: IFFALSE 90993
// sOil := true ;
90985: LD_ADDR_EXP 129
90989: PUSH
90990: LD_INT 1
90992: ST_TO_ADDR
// if p3 = 112 then
90993: LD_VAR 0 3
90997: PUSH
90998: LD_INT 112
91000: EQUAL
91001: IFFALSE 91011
// sStu := true ;
91003: LD_ADDR_EXP 133
91007: PUSH
91008: LD_INT 1
91010: ST_TO_ADDR
// if p3 = 113 then
91011: LD_VAR 0 3
91015: PUSH
91016: LD_INT 113
91018: EQUAL
91019: IFFALSE 91029
// sBazooka := true ;
91021: LD_ADDR_EXP 136
91025: PUSH
91026: LD_INT 1
91028: ST_TO_ADDR
// if p3 = 114 then
91029: LD_VAR 0 3
91033: PUSH
91034: LD_INT 114
91036: EQUAL
91037: IFFALSE 91047
// sMortar := true ;
91039: LD_ADDR_EXP 137
91043: PUSH
91044: LD_INT 1
91046: ST_TO_ADDR
// if p3 = 115 then
91047: LD_VAR 0 3
91051: PUSH
91052: LD_INT 115
91054: EQUAL
91055: IFFALSE 91065
// sRanger := true ;
91057: LD_ADDR_EXP 147
91061: PUSH
91062: LD_INT 1
91064: ST_TO_ADDR
// if p3 = 116 then
91065: LD_VAR 0 3
91069: PUSH
91070: LD_INT 116
91072: EQUAL
91073: IFFALSE 91083
// sComputer := true ;
91075: LD_ADDR_EXP 148
91079: PUSH
91080: LD_INT 1
91082: ST_TO_ADDR
// if p3 = 117 then
91083: LD_VAR 0 3
91087: PUSH
91088: LD_INT 117
91090: EQUAL
91091: IFFALSE 91101
// s30 := true ;
91093: LD_ADDR_EXP 149
91097: PUSH
91098: LD_INT 1
91100: ST_TO_ADDR
// if p3 = 118 then
91101: LD_VAR 0 3
91105: PUSH
91106: LD_INT 118
91108: EQUAL
91109: IFFALSE 91119
// s60 := true ;
91111: LD_ADDR_EXP 150
91115: PUSH
91116: LD_INT 1
91118: ST_TO_ADDR
// end ; if p2 = stream_mode then
91119: LD_VAR 0 2
91123: PUSH
91124: LD_INT 101
91126: EQUAL
91127: IFFALSE 91255
// begin case p3 of 1 :
91129: LD_VAR 0 3
91133: PUSH
91134: LD_INT 1
91136: DOUBLE
91137: EQUAL
91138: IFTRUE 91142
91140: GO 91149
91142: POP
// hHackUnlimitedResources ; 2 :
91143: CALL 103353 0 0
91147: GO 91255
91149: LD_INT 2
91151: DOUBLE
91152: EQUAL
91153: IFTRUE 91157
91155: GO 91164
91157: POP
// hHackSetLevel10 ; 3 :
91158: CALL 103486 0 0
91162: GO 91255
91164: LD_INT 3
91166: DOUBLE
91167: EQUAL
91168: IFTRUE 91172
91170: GO 91179
91172: POP
// hHackSetLevel10YourUnits ; 4 :
91173: CALL 103571 0 0
91177: GO 91255
91179: LD_INT 4
91181: DOUBLE
91182: EQUAL
91183: IFTRUE 91187
91185: GO 91194
91187: POP
// hHackInvincible ; 5 :
91188: CALL 104019 0 0
91192: GO 91255
91194: LD_INT 5
91196: DOUBLE
91197: EQUAL
91198: IFTRUE 91202
91200: GO 91209
91202: POP
// hHackInvisible ; 6 :
91203: CALL 104130 0 0
91207: GO 91255
91209: LD_INT 6
91211: DOUBLE
91212: EQUAL
91213: IFTRUE 91217
91215: GO 91224
91217: POP
// hHackChangeYourSide ; 7 :
91218: CALL 104187 0 0
91222: GO 91255
91224: LD_INT 7
91226: DOUBLE
91227: EQUAL
91228: IFTRUE 91232
91230: GO 91239
91232: POP
// hHackChangeUnitSide ; 8 :
91233: CALL 104229 0 0
91237: GO 91255
91239: LD_INT 8
91241: DOUBLE
91242: EQUAL
91243: IFTRUE 91247
91245: GO 91254
91247: POP
// hHackFog ; end ;
91248: CALL 104330 0 0
91252: GO 91255
91254: POP
// end ; end ;
91255: LD_VAR 0 7
91259: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
91260: GO 91262
91262: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
91263: LD_STRING initStreamRollete();
91265: PPUSH
91266: CALL_OW 559
// InitStreamMode ;
91270: CALL 91282 0 0
// DefineStreamItems ( false ) ;
91274: LD_INT 0
91276: PPUSH
91277: CALL 91746 0 1
// end ;
91281: END
// function InitStreamMode ; begin
91282: LD_INT 0
91284: PPUSH
// streamModeActive := false ;
91285: LD_ADDR_EXP 94
91289: PUSH
91290: LD_INT 0
91292: ST_TO_ADDR
// normalCounter := 36 ;
91293: LD_ADDR_EXP 95
91297: PUSH
91298: LD_INT 36
91300: ST_TO_ADDR
// hardcoreCounter := 18 ;
91301: LD_ADDR_EXP 96
91305: PUSH
91306: LD_INT 18
91308: ST_TO_ADDR
// sRocket := false ;
91309: LD_ADDR_EXP 99
91313: PUSH
91314: LD_INT 0
91316: ST_TO_ADDR
// sSpeed := false ;
91317: LD_ADDR_EXP 98
91321: PUSH
91322: LD_INT 0
91324: ST_TO_ADDR
// sEngine := false ;
91325: LD_ADDR_EXP 100
91329: PUSH
91330: LD_INT 0
91332: ST_TO_ADDR
// sSpec := false ;
91333: LD_ADDR_EXP 97
91337: PUSH
91338: LD_INT 0
91340: ST_TO_ADDR
// sLevel := false ;
91341: LD_ADDR_EXP 101
91345: PUSH
91346: LD_INT 0
91348: ST_TO_ADDR
// sArmoury := false ;
91349: LD_ADDR_EXP 102
91353: PUSH
91354: LD_INT 0
91356: ST_TO_ADDR
// sRadar := false ;
91357: LD_ADDR_EXP 103
91361: PUSH
91362: LD_INT 0
91364: ST_TO_ADDR
// sBunker := false ;
91365: LD_ADDR_EXP 104
91369: PUSH
91370: LD_INT 0
91372: ST_TO_ADDR
// sHack := false ;
91373: LD_ADDR_EXP 105
91377: PUSH
91378: LD_INT 0
91380: ST_TO_ADDR
// sFire := false ;
91381: LD_ADDR_EXP 106
91385: PUSH
91386: LD_INT 0
91388: ST_TO_ADDR
// sRefresh := false ;
91389: LD_ADDR_EXP 107
91393: PUSH
91394: LD_INT 0
91396: ST_TO_ADDR
// sExp := false ;
91397: LD_ADDR_EXP 108
91401: PUSH
91402: LD_INT 0
91404: ST_TO_ADDR
// sDepot := false ;
91405: LD_ADDR_EXP 109
91409: PUSH
91410: LD_INT 0
91412: ST_TO_ADDR
// sFlag := false ;
91413: LD_ADDR_EXP 110
91417: PUSH
91418: LD_INT 0
91420: ST_TO_ADDR
// sKamikadze := false ;
91421: LD_ADDR_EXP 118
91425: PUSH
91426: LD_INT 0
91428: ST_TO_ADDR
// sTroll := false ;
91429: LD_ADDR_EXP 119
91433: PUSH
91434: LD_INT 0
91436: ST_TO_ADDR
// sSlow := false ;
91437: LD_ADDR_EXP 120
91441: PUSH
91442: LD_INT 0
91444: ST_TO_ADDR
// sLack := false ;
91445: LD_ADDR_EXP 121
91449: PUSH
91450: LD_INT 0
91452: ST_TO_ADDR
// sTank := false ;
91453: LD_ADDR_EXP 123
91457: PUSH
91458: LD_INT 0
91460: ST_TO_ADDR
// sRemote := false ;
91461: LD_ADDR_EXP 124
91465: PUSH
91466: LD_INT 0
91468: ST_TO_ADDR
// sPowell := false ;
91469: LD_ADDR_EXP 125
91473: PUSH
91474: LD_INT 0
91476: ST_TO_ADDR
// sTeleport := false ;
91477: LD_ADDR_EXP 128
91481: PUSH
91482: LD_INT 0
91484: ST_TO_ADDR
// sOilTower := false ;
91485: LD_ADDR_EXP 130
91489: PUSH
91490: LD_INT 0
91492: ST_TO_ADDR
// sShovel := false ;
91493: LD_ADDR_EXP 131
91497: PUSH
91498: LD_INT 0
91500: ST_TO_ADDR
// sSheik := false ;
91501: LD_ADDR_EXP 132
91505: PUSH
91506: LD_INT 0
91508: ST_TO_ADDR
// sEarthquake := false ;
91509: LD_ADDR_EXP 134
91513: PUSH
91514: LD_INT 0
91516: ST_TO_ADDR
// sAI := false ;
91517: LD_ADDR_EXP 135
91521: PUSH
91522: LD_INT 0
91524: ST_TO_ADDR
// sCargo := false ;
91525: LD_ADDR_EXP 138
91529: PUSH
91530: LD_INT 0
91532: ST_TO_ADDR
// sDLaser := false ;
91533: LD_ADDR_EXP 139
91537: PUSH
91538: LD_INT 0
91540: ST_TO_ADDR
// sExchange := false ;
91541: LD_ADDR_EXP 140
91545: PUSH
91546: LD_INT 0
91548: ST_TO_ADDR
// sFac := false ;
91549: LD_ADDR_EXP 141
91553: PUSH
91554: LD_INT 0
91556: ST_TO_ADDR
// sPower := false ;
91557: LD_ADDR_EXP 142
91561: PUSH
91562: LD_INT 0
91564: ST_TO_ADDR
// sRandom := false ;
91565: LD_ADDR_EXP 143
91569: PUSH
91570: LD_INT 0
91572: ST_TO_ADDR
// sShield := false ;
91573: LD_ADDR_EXP 144
91577: PUSH
91578: LD_INT 0
91580: ST_TO_ADDR
// sTime := false ;
91581: LD_ADDR_EXP 145
91585: PUSH
91586: LD_INT 0
91588: ST_TO_ADDR
// sTools := false ;
91589: LD_ADDR_EXP 146
91593: PUSH
91594: LD_INT 0
91596: ST_TO_ADDR
// sSold := false ;
91597: LD_ADDR_EXP 111
91601: PUSH
91602: LD_INT 0
91604: ST_TO_ADDR
// sDiff := false ;
91605: LD_ADDR_EXP 112
91609: PUSH
91610: LD_INT 0
91612: ST_TO_ADDR
// sFog := false ;
91613: LD_ADDR_EXP 115
91617: PUSH
91618: LD_INT 0
91620: ST_TO_ADDR
// sReset := false ;
91621: LD_ADDR_EXP 116
91625: PUSH
91626: LD_INT 0
91628: ST_TO_ADDR
// sSun := false ;
91629: LD_ADDR_EXP 117
91633: PUSH
91634: LD_INT 0
91636: ST_TO_ADDR
// sTiger := false ;
91637: LD_ADDR_EXP 113
91641: PUSH
91642: LD_INT 0
91644: ST_TO_ADDR
// sBomb := false ;
91645: LD_ADDR_EXP 114
91649: PUSH
91650: LD_INT 0
91652: ST_TO_ADDR
// sWound := false ;
91653: LD_ADDR_EXP 122
91657: PUSH
91658: LD_INT 0
91660: ST_TO_ADDR
// sBetray := false ;
91661: LD_ADDR_EXP 126
91665: PUSH
91666: LD_INT 0
91668: ST_TO_ADDR
// sContamin := false ;
91669: LD_ADDR_EXP 127
91673: PUSH
91674: LD_INT 0
91676: ST_TO_ADDR
// sOil := false ;
91677: LD_ADDR_EXP 129
91681: PUSH
91682: LD_INT 0
91684: ST_TO_ADDR
// sStu := false ;
91685: LD_ADDR_EXP 133
91689: PUSH
91690: LD_INT 0
91692: ST_TO_ADDR
// sBazooka := false ;
91693: LD_ADDR_EXP 136
91697: PUSH
91698: LD_INT 0
91700: ST_TO_ADDR
// sMortar := false ;
91701: LD_ADDR_EXP 137
91705: PUSH
91706: LD_INT 0
91708: ST_TO_ADDR
// sRanger := false ;
91709: LD_ADDR_EXP 147
91713: PUSH
91714: LD_INT 0
91716: ST_TO_ADDR
// sComputer := false ;
91717: LD_ADDR_EXP 148
91721: PUSH
91722: LD_INT 0
91724: ST_TO_ADDR
// s30 := false ;
91725: LD_ADDR_EXP 149
91729: PUSH
91730: LD_INT 0
91732: ST_TO_ADDR
// s60 := false ;
91733: LD_ADDR_EXP 150
91737: PUSH
91738: LD_INT 0
91740: ST_TO_ADDR
// end ;
91741: LD_VAR 0 1
91745: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
91746: LD_INT 0
91748: PPUSH
91749: PPUSH
91750: PPUSH
91751: PPUSH
91752: PPUSH
91753: PPUSH
91754: PPUSH
// result := [ ] ;
91755: LD_ADDR_VAR 0 2
91759: PUSH
91760: EMPTY
91761: ST_TO_ADDR
// if campaign_id = 1 then
91762: LD_OWVAR 69
91766: PUSH
91767: LD_INT 1
91769: EQUAL
91770: IFFALSE 94936
// begin case mission_number of 1 :
91772: LD_OWVAR 70
91776: PUSH
91777: LD_INT 1
91779: DOUBLE
91780: EQUAL
91781: IFTRUE 91785
91783: GO 91861
91785: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
91786: LD_ADDR_VAR 0 2
91790: PUSH
91791: LD_INT 2
91793: PUSH
91794: LD_INT 4
91796: PUSH
91797: LD_INT 11
91799: PUSH
91800: LD_INT 12
91802: PUSH
91803: LD_INT 15
91805: PUSH
91806: LD_INT 16
91808: PUSH
91809: LD_INT 22
91811: PUSH
91812: LD_INT 23
91814: PUSH
91815: LD_INT 26
91817: PUSH
91818: EMPTY
91819: LIST
91820: LIST
91821: LIST
91822: LIST
91823: LIST
91824: LIST
91825: LIST
91826: LIST
91827: LIST
91828: PUSH
91829: LD_INT 101
91831: PUSH
91832: LD_INT 102
91834: PUSH
91835: LD_INT 106
91837: PUSH
91838: LD_INT 116
91840: PUSH
91841: LD_INT 117
91843: PUSH
91844: LD_INT 118
91846: PUSH
91847: EMPTY
91848: LIST
91849: LIST
91850: LIST
91851: LIST
91852: LIST
91853: LIST
91854: PUSH
91855: EMPTY
91856: LIST
91857: LIST
91858: ST_TO_ADDR
91859: GO 94934
91861: LD_INT 2
91863: DOUBLE
91864: EQUAL
91865: IFTRUE 91869
91867: GO 91953
91869: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
91870: LD_ADDR_VAR 0 2
91874: PUSH
91875: LD_INT 2
91877: PUSH
91878: LD_INT 4
91880: PUSH
91881: LD_INT 11
91883: PUSH
91884: LD_INT 12
91886: PUSH
91887: LD_INT 15
91889: PUSH
91890: LD_INT 16
91892: PUSH
91893: LD_INT 22
91895: PUSH
91896: LD_INT 23
91898: PUSH
91899: LD_INT 26
91901: PUSH
91902: EMPTY
91903: LIST
91904: LIST
91905: LIST
91906: LIST
91907: LIST
91908: LIST
91909: LIST
91910: LIST
91911: LIST
91912: PUSH
91913: LD_INT 101
91915: PUSH
91916: LD_INT 102
91918: PUSH
91919: LD_INT 105
91921: PUSH
91922: LD_INT 106
91924: PUSH
91925: LD_INT 108
91927: PUSH
91928: LD_INT 116
91930: PUSH
91931: LD_INT 117
91933: PUSH
91934: LD_INT 118
91936: PUSH
91937: EMPTY
91938: LIST
91939: LIST
91940: LIST
91941: LIST
91942: LIST
91943: LIST
91944: LIST
91945: LIST
91946: PUSH
91947: EMPTY
91948: LIST
91949: LIST
91950: ST_TO_ADDR
91951: GO 94934
91953: LD_INT 3
91955: DOUBLE
91956: EQUAL
91957: IFTRUE 91961
91959: GO 92049
91961: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
91962: LD_ADDR_VAR 0 2
91966: PUSH
91967: LD_INT 2
91969: PUSH
91970: LD_INT 4
91972: PUSH
91973: LD_INT 5
91975: PUSH
91976: LD_INT 11
91978: PUSH
91979: LD_INT 12
91981: PUSH
91982: LD_INT 15
91984: PUSH
91985: LD_INT 16
91987: PUSH
91988: LD_INT 22
91990: PUSH
91991: LD_INT 26
91993: PUSH
91994: LD_INT 36
91996: PUSH
91997: EMPTY
91998: LIST
91999: LIST
92000: LIST
92001: LIST
92002: LIST
92003: LIST
92004: LIST
92005: LIST
92006: LIST
92007: LIST
92008: PUSH
92009: LD_INT 101
92011: PUSH
92012: LD_INT 102
92014: PUSH
92015: LD_INT 105
92017: PUSH
92018: LD_INT 106
92020: PUSH
92021: LD_INT 108
92023: PUSH
92024: LD_INT 116
92026: PUSH
92027: LD_INT 117
92029: PUSH
92030: LD_INT 118
92032: PUSH
92033: EMPTY
92034: LIST
92035: LIST
92036: LIST
92037: LIST
92038: LIST
92039: LIST
92040: LIST
92041: LIST
92042: PUSH
92043: EMPTY
92044: LIST
92045: LIST
92046: ST_TO_ADDR
92047: GO 94934
92049: LD_INT 4
92051: DOUBLE
92052: EQUAL
92053: IFTRUE 92057
92055: GO 92153
92057: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
92058: LD_ADDR_VAR 0 2
92062: PUSH
92063: LD_INT 2
92065: PUSH
92066: LD_INT 4
92068: PUSH
92069: LD_INT 5
92071: PUSH
92072: LD_INT 8
92074: PUSH
92075: LD_INT 11
92077: PUSH
92078: LD_INT 12
92080: PUSH
92081: LD_INT 15
92083: PUSH
92084: LD_INT 16
92086: PUSH
92087: LD_INT 22
92089: PUSH
92090: LD_INT 23
92092: PUSH
92093: LD_INT 26
92095: PUSH
92096: LD_INT 36
92098: PUSH
92099: EMPTY
92100: LIST
92101: LIST
92102: LIST
92103: LIST
92104: LIST
92105: LIST
92106: LIST
92107: LIST
92108: LIST
92109: LIST
92110: LIST
92111: LIST
92112: PUSH
92113: LD_INT 101
92115: PUSH
92116: LD_INT 102
92118: PUSH
92119: LD_INT 105
92121: PUSH
92122: LD_INT 106
92124: PUSH
92125: LD_INT 108
92127: PUSH
92128: LD_INT 116
92130: PUSH
92131: LD_INT 117
92133: PUSH
92134: LD_INT 118
92136: PUSH
92137: EMPTY
92138: LIST
92139: LIST
92140: LIST
92141: LIST
92142: LIST
92143: LIST
92144: LIST
92145: LIST
92146: PUSH
92147: EMPTY
92148: LIST
92149: LIST
92150: ST_TO_ADDR
92151: GO 94934
92153: LD_INT 5
92155: DOUBLE
92156: EQUAL
92157: IFTRUE 92161
92159: GO 92273
92161: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
92162: LD_ADDR_VAR 0 2
92166: PUSH
92167: LD_INT 2
92169: PUSH
92170: LD_INT 4
92172: PUSH
92173: LD_INT 5
92175: PUSH
92176: LD_INT 6
92178: PUSH
92179: LD_INT 8
92181: PUSH
92182: LD_INT 11
92184: PUSH
92185: LD_INT 12
92187: PUSH
92188: LD_INT 15
92190: PUSH
92191: LD_INT 16
92193: PUSH
92194: LD_INT 22
92196: PUSH
92197: LD_INT 23
92199: PUSH
92200: LD_INT 25
92202: PUSH
92203: LD_INT 26
92205: PUSH
92206: LD_INT 36
92208: PUSH
92209: EMPTY
92210: LIST
92211: LIST
92212: LIST
92213: LIST
92214: LIST
92215: LIST
92216: LIST
92217: LIST
92218: LIST
92219: LIST
92220: LIST
92221: LIST
92222: LIST
92223: LIST
92224: PUSH
92225: LD_INT 101
92227: PUSH
92228: LD_INT 102
92230: PUSH
92231: LD_INT 105
92233: PUSH
92234: LD_INT 106
92236: PUSH
92237: LD_INT 108
92239: PUSH
92240: LD_INT 109
92242: PUSH
92243: LD_INT 112
92245: PUSH
92246: LD_INT 116
92248: PUSH
92249: LD_INT 117
92251: PUSH
92252: LD_INT 118
92254: PUSH
92255: EMPTY
92256: LIST
92257: LIST
92258: LIST
92259: LIST
92260: LIST
92261: LIST
92262: LIST
92263: LIST
92264: LIST
92265: LIST
92266: PUSH
92267: EMPTY
92268: LIST
92269: LIST
92270: ST_TO_ADDR
92271: GO 94934
92273: LD_INT 6
92275: DOUBLE
92276: EQUAL
92277: IFTRUE 92281
92279: GO 92413
92281: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
92282: LD_ADDR_VAR 0 2
92286: PUSH
92287: LD_INT 2
92289: PUSH
92290: LD_INT 4
92292: PUSH
92293: LD_INT 5
92295: PUSH
92296: LD_INT 6
92298: PUSH
92299: LD_INT 8
92301: PUSH
92302: LD_INT 11
92304: PUSH
92305: LD_INT 12
92307: PUSH
92308: LD_INT 15
92310: PUSH
92311: LD_INT 16
92313: PUSH
92314: LD_INT 20
92316: PUSH
92317: LD_INT 21
92319: PUSH
92320: LD_INT 22
92322: PUSH
92323: LD_INT 23
92325: PUSH
92326: LD_INT 25
92328: PUSH
92329: LD_INT 26
92331: PUSH
92332: LD_INT 30
92334: PUSH
92335: LD_INT 31
92337: PUSH
92338: LD_INT 32
92340: PUSH
92341: LD_INT 36
92343: PUSH
92344: EMPTY
92345: LIST
92346: LIST
92347: LIST
92348: LIST
92349: LIST
92350: LIST
92351: LIST
92352: LIST
92353: LIST
92354: LIST
92355: LIST
92356: LIST
92357: LIST
92358: LIST
92359: LIST
92360: LIST
92361: LIST
92362: LIST
92363: LIST
92364: PUSH
92365: LD_INT 101
92367: PUSH
92368: LD_INT 102
92370: PUSH
92371: LD_INT 105
92373: PUSH
92374: LD_INT 106
92376: PUSH
92377: LD_INT 108
92379: PUSH
92380: LD_INT 109
92382: PUSH
92383: LD_INT 112
92385: PUSH
92386: LD_INT 116
92388: PUSH
92389: LD_INT 117
92391: PUSH
92392: LD_INT 118
92394: PUSH
92395: EMPTY
92396: LIST
92397: LIST
92398: LIST
92399: LIST
92400: LIST
92401: LIST
92402: LIST
92403: LIST
92404: LIST
92405: LIST
92406: PUSH
92407: EMPTY
92408: LIST
92409: LIST
92410: ST_TO_ADDR
92411: GO 94934
92413: LD_INT 7
92415: DOUBLE
92416: EQUAL
92417: IFTRUE 92421
92419: GO 92533
92421: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
92422: LD_ADDR_VAR 0 2
92426: PUSH
92427: LD_INT 2
92429: PUSH
92430: LD_INT 4
92432: PUSH
92433: LD_INT 5
92435: PUSH
92436: LD_INT 7
92438: PUSH
92439: LD_INT 11
92441: PUSH
92442: LD_INT 12
92444: PUSH
92445: LD_INT 15
92447: PUSH
92448: LD_INT 16
92450: PUSH
92451: LD_INT 20
92453: PUSH
92454: LD_INT 21
92456: PUSH
92457: LD_INT 22
92459: PUSH
92460: LD_INT 23
92462: PUSH
92463: LD_INT 25
92465: PUSH
92466: LD_INT 26
92468: PUSH
92469: EMPTY
92470: LIST
92471: LIST
92472: LIST
92473: LIST
92474: LIST
92475: LIST
92476: LIST
92477: LIST
92478: LIST
92479: LIST
92480: LIST
92481: LIST
92482: LIST
92483: LIST
92484: PUSH
92485: LD_INT 101
92487: PUSH
92488: LD_INT 102
92490: PUSH
92491: LD_INT 103
92493: PUSH
92494: LD_INT 105
92496: PUSH
92497: LD_INT 106
92499: PUSH
92500: LD_INT 108
92502: PUSH
92503: LD_INT 112
92505: PUSH
92506: LD_INT 116
92508: PUSH
92509: LD_INT 117
92511: PUSH
92512: LD_INT 118
92514: PUSH
92515: EMPTY
92516: LIST
92517: LIST
92518: LIST
92519: LIST
92520: LIST
92521: LIST
92522: LIST
92523: LIST
92524: LIST
92525: LIST
92526: PUSH
92527: EMPTY
92528: LIST
92529: LIST
92530: ST_TO_ADDR
92531: GO 94934
92533: LD_INT 8
92535: DOUBLE
92536: EQUAL
92537: IFTRUE 92541
92539: GO 92681
92541: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
92542: LD_ADDR_VAR 0 2
92546: PUSH
92547: LD_INT 2
92549: PUSH
92550: LD_INT 4
92552: PUSH
92553: LD_INT 5
92555: PUSH
92556: LD_INT 6
92558: PUSH
92559: LD_INT 7
92561: PUSH
92562: LD_INT 8
92564: PUSH
92565: LD_INT 11
92567: PUSH
92568: LD_INT 12
92570: PUSH
92571: LD_INT 15
92573: PUSH
92574: LD_INT 16
92576: PUSH
92577: LD_INT 20
92579: PUSH
92580: LD_INT 21
92582: PUSH
92583: LD_INT 22
92585: PUSH
92586: LD_INT 23
92588: PUSH
92589: LD_INT 25
92591: PUSH
92592: LD_INT 26
92594: PUSH
92595: LD_INT 30
92597: PUSH
92598: LD_INT 31
92600: PUSH
92601: LD_INT 32
92603: PUSH
92604: LD_INT 36
92606: PUSH
92607: EMPTY
92608: LIST
92609: LIST
92610: LIST
92611: LIST
92612: LIST
92613: LIST
92614: LIST
92615: LIST
92616: LIST
92617: LIST
92618: LIST
92619: LIST
92620: LIST
92621: LIST
92622: LIST
92623: LIST
92624: LIST
92625: LIST
92626: LIST
92627: LIST
92628: PUSH
92629: LD_INT 101
92631: PUSH
92632: LD_INT 102
92634: PUSH
92635: LD_INT 103
92637: PUSH
92638: LD_INT 105
92640: PUSH
92641: LD_INT 106
92643: PUSH
92644: LD_INT 108
92646: PUSH
92647: LD_INT 109
92649: PUSH
92650: LD_INT 112
92652: PUSH
92653: LD_INT 116
92655: PUSH
92656: LD_INT 117
92658: PUSH
92659: LD_INT 118
92661: PUSH
92662: EMPTY
92663: LIST
92664: LIST
92665: LIST
92666: LIST
92667: LIST
92668: LIST
92669: LIST
92670: LIST
92671: LIST
92672: LIST
92673: LIST
92674: PUSH
92675: EMPTY
92676: LIST
92677: LIST
92678: ST_TO_ADDR
92679: GO 94934
92681: LD_INT 9
92683: DOUBLE
92684: EQUAL
92685: IFTRUE 92689
92687: GO 92837
92689: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
92690: LD_ADDR_VAR 0 2
92694: PUSH
92695: LD_INT 2
92697: PUSH
92698: LD_INT 4
92700: PUSH
92701: LD_INT 5
92703: PUSH
92704: LD_INT 6
92706: PUSH
92707: LD_INT 7
92709: PUSH
92710: LD_INT 8
92712: PUSH
92713: LD_INT 11
92715: PUSH
92716: LD_INT 12
92718: PUSH
92719: LD_INT 15
92721: PUSH
92722: LD_INT 16
92724: PUSH
92725: LD_INT 20
92727: PUSH
92728: LD_INT 21
92730: PUSH
92731: LD_INT 22
92733: PUSH
92734: LD_INT 23
92736: PUSH
92737: LD_INT 25
92739: PUSH
92740: LD_INT 26
92742: PUSH
92743: LD_INT 28
92745: PUSH
92746: LD_INT 30
92748: PUSH
92749: LD_INT 31
92751: PUSH
92752: LD_INT 32
92754: PUSH
92755: LD_INT 36
92757: PUSH
92758: EMPTY
92759: LIST
92760: LIST
92761: LIST
92762: LIST
92763: LIST
92764: LIST
92765: LIST
92766: LIST
92767: LIST
92768: LIST
92769: LIST
92770: LIST
92771: LIST
92772: LIST
92773: LIST
92774: LIST
92775: LIST
92776: LIST
92777: LIST
92778: LIST
92779: LIST
92780: PUSH
92781: LD_INT 101
92783: PUSH
92784: LD_INT 102
92786: PUSH
92787: LD_INT 103
92789: PUSH
92790: LD_INT 105
92792: PUSH
92793: LD_INT 106
92795: PUSH
92796: LD_INT 108
92798: PUSH
92799: LD_INT 109
92801: PUSH
92802: LD_INT 112
92804: PUSH
92805: LD_INT 114
92807: PUSH
92808: LD_INT 116
92810: PUSH
92811: LD_INT 117
92813: PUSH
92814: LD_INT 118
92816: PUSH
92817: EMPTY
92818: LIST
92819: LIST
92820: LIST
92821: LIST
92822: LIST
92823: LIST
92824: LIST
92825: LIST
92826: LIST
92827: LIST
92828: LIST
92829: LIST
92830: PUSH
92831: EMPTY
92832: LIST
92833: LIST
92834: ST_TO_ADDR
92835: GO 94934
92837: LD_INT 10
92839: DOUBLE
92840: EQUAL
92841: IFTRUE 92845
92843: GO 93041
92845: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
92846: LD_ADDR_VAR 0 2
92850: PUSH
92851: LD_INT 2
92853: PUSH
92854: LD_INT 4
92856: PUSH
92857: LD_INT 5
92859: PUSH
92860: LD_INT 6
92862: PUSH
92863: LD_INT 7
92865: PUSH
92866: LD_INT 8
92868: PUSH
92869: LD_INT 9
92871: PUSH
92872: LD_INT 10
92874: PUSH
92875: LD_INT 11
92877: PUSH
92878: LD_INT 12
92880: PUSH
92881: LD_INT 13
92883: PUSH
92884: LD_INT 14
92886: PUSH
92887: LD_INT 15
92889: PUSH
92890: LD_INT 16
92892: PUSH
92893: LD_INT 17
92895: PUSH
92896: LD_INT 18
92898: PUSH
92899: LD_INT 19
92901: PUSH
92902: LD_INT 20
92904: PUSH
92905: LD_INT 21
92907: PUSH
92908: LD_INT 22
92910: PUSH
92911: LD_INT 23
92913: PUSH
92914: LD_INT 24
92916: PUSH
92917: LD_INT 25
92919: PUSH
92920: LD_INT 26
92922: PUSH
92923: LD_INT 28
92925: PUSH
92926: LD_INT 30
92928: PUSH
92929: LD_INT 31
92931: PUSH
92932: LD_INT 32
92934: PUSH
92935: LD_INT 36
92937: PUSH
92938: EMPTY
92939: LIST
92940: LIST
92941: LIST
92942: LIST
92943: LIST
92944: LIST
92945: LIST
92946: LIST
92947: LIST
92948: LIST
92949: LIST
92950: LIST
92951: LIST
92952: LIST
92953: LIST
92954: LIST
92955: LIST
92956: LIST
92957: LIST
92958: LIST
92959: LIST
92960: LIST
92961: LIST
92962: LIST
92963: LIST
92964: LIST
92965: LIST
92966: LIST
92967: LIST
92968: PUSH
92969: LD_INT 101
92971: PUSH
92972: LD_INT 102
92974: PUSH
92975: LD_INT 103
92977: PUSH
92978: LD_INT 104
92980: PUSH
92981: LD_INT 105
92983: PUSH
92984: LD_INT 106
92986: PUSH
92987: LD_INT 107
92989: PUSH
92990: LD_INT 108
92992: PUSH
92993: LD_INT 109
92995: PUSH
92996: LD_INT 110
92998: PUSH
92999: LD_INT 111
93001: PUSH
93002: LD_INT 112
93004: PUSH
93005: LD_INT 114
93007: PUSH
93008: LD_INT 116
93010: PUSH
93011: LD_INT 117
93013: PUSH
93014: LD_INT 118
93016: PUSH
93017: EMPTY
93018: LIST
93019: LIST
93020: LIST
93021: LIST
93022: LIST
93023: LIST
93024: LIST
93025: LIST
93026: LIST
93027: LIST
93028: LIST
93029: LIST
93030: LIST
93031: LIST
93032: LIST
93033: LIST
93034: PUSH
93035: EMPTY
93036: LIST
93037: LIST
93038: ST_TO_ADDR
93039: GO 94934
93041: LD_INT 11
93043: DOUBLE
93044: EQUAL
93045: IFTRUE 93049
93047: GO 93253
93049: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
93050: LD_ADDR_VAR 0 2
93054: PUSH
93055: LD_INT 2
93057: PUSH
93058: LD_INT 3
93060: PUSH
93061: LD_INT 4
93063: PUSH
93064: LD_INT 5
93066: PUSH
93067: LD_INT 6
93069: PUSH
93070: LD_INT 7
93072: PUSH
93073: LD_INT 8
93075: PUSH
93076: LD_INT 9
93078: PUSH
93079: LD_INT 10
93081: PUSH
93082: LD_INT 11
93084: PUSH
93085: LD_INT 12
93087: PUSH
93088: LD_INT 13
93090: PUSH
93091: LD_INT 14
93093: PUSH
93094: LD_INT 15
93096: PUSH
93097: LD_INT 16
93099: PUSH
93100: LD_INT 17
93102: PUSH
93103: LD_INT 18
93105: PUSH
93106: LD_INT 19
93108: PUSH
93109: LD_INT 20
93111: PUSH
93112: LD_INT 21
93114: PUSH
93115: LD_INT 22
93117: PUSH
93118: LD_INT 23
93120: PUSH
93121: LD_INT 24
93123: PUSH
93124: LD_INT 25
93126: PUSH
93127: LD_INT 26
93129: PUSH
93130: LD_INT 28
93132: PUSH
93133: LD_INT 30
93135: PUSH
93136: LD_INT 31
93138: PUSH
93139: LD_INT 32
93141: PUSH
93142: LD_INT 34
93144: PUSH
93145: LD_INT 36
93147: PUSH
93148: EMPTY
93149: LIST
93150: LIST
93151: LIST
93152: LIST
93153: LIST
93154: LIST
93155: LIST
93156: LIST
93157: LIST
93158: LIST
93159: LIST
93160: LIST
93161: LIST
93162: LIST
93163: LIST
93164: LIST
93165: LIST
93166: LIST
93167: LIST
93168: LIST
93169: LIST
93170: LIST
93171: LIST
93172: LIST
93173: LIST
93174: LIST
93175: LIST
93176: LIST
93177: LIST
93178: LIST
93179: LIST
93180: PUSH
93181: LD_INT 101
93183: PUSH
93184: LD_INT 102
93186: PUSH
93187: LD_INT 103
93189: PUSH
93190: LD_INT 104
93192: PUSH
93193: LD_INT 105
93195: PUSH
93196: LD_INT 106
93198: PUSH
93199: LD_INT 107
93201: PUSH
93202: LD_INT 108
93204: PUSH
93205: LD_INT 109
93207: PUSH
93208: LD_INT 110
93210: PUSH
93211: LD_INT 111
93213: PUSH
93214: LD_INT 112
93216: PUSH
93217: LD_INT 114
93219: PUSH
93220: LD_INT 116
93222: PUSH
93223: LD_INT 117
93225: PUSH
93226: LD_INT 118
93228: PUSH
93229: EMPTY
93230: LIST
93231: LIST
93232: LIST
93233: LIST
93234: LIST
93235: LIST
93236: LIST
93237: LIST
93238: LIST
93239: LIST
93240: LIST
93241: LIST
93242: LIST
93243: LIST
93244: LIST
93245: LIST
93246: PUSH
93247: EMPTY
93248: LIST
93249: LIST
93250: ST_TO_ADDR
93251: GO 94934
93253: LD_INT 12
93255: DOUBLE
93256: EQUAL
93257: IFTRUE 93261
93259: GO 93481
93261: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
93262: LD_ADDR_VAR 0 2
93266: PUSH
93267: LD_INT 1
93269: PUSH
93270: LD_INT 2
93272: PUSH
93273: LD_INT 3
93275: PUSH
93276: LD_INT 4
93278: PUSH
93279: LD_INT 5
93281: PUSH
93282: LD_INT 6
93284: PUSH
93285: LD_INT 7
93287: PUSH
93288: LD_INT 8
93290: PUSH
93291: LD_INT 9
93293: PUSH
93294: LD_INT 10
93296: PUSH
93297: LD_INT 11
93299: PUSH
93300: LD_INT 12
93302: PUSH
93303: LD_INT 13
93305: PUSH
93306: LD_INT 14
93308: PUSH
93309: LD_INT 15
93311: PUSH
93312: LD_INT 16
93314: PUSH
93315: LD_INT 17
93317: PUSH
93318: LD_INT 18
93320: PUSH
93321: LD_INT 19
93323: PUSH
93324: LD_INT 20
93326: PUSH
93327: LD_INT 21
93329: PUSH
93330: LD_INT 22
93332: PUSH
93333: LD_INT 23
93335: PUSH
93336: LD_INT 24
93338: PUSH
93339: LD_INT 25
93341: PUSH
93342: LD_INT 26
93344: PUSH
93345: LD_INT 27
93347: PUSH
93348: LD_INT 28
93350: PUSH
93351: LD_INT 30
93353: PUSH
93354: LD_INT 31
93356: PUSH
93357: LD_INT 32
93359: PUSH
93360: LD_INT 33
93362: PUSH
93363: LD_INT 34
93365: PUSH
93366: LD_INT 36
93368: PUSH
93369: EMPTY
93370: LIST
93371: LIST
93372: LIST
93373: LIST
93374: LIST
93375: LIST
93376: LIST
93377: LIST
93378: LIST
93379: LIST
93380: LIST
93381: LIST
93382: LIST
93383: LIST
93384: LIST
93385: LIST
93386: LIST
93387: LIST
93388: LIST
93389: LIST
93390: LIST
93391: LIST
93392: LIST
93393: LIST
93394: LIST
93395: LIST
93396: LIST
93397: LIST
93398: LIST
93399: LIST
93400: LIST
93401: LIST
93402: LIST
93403: LIST
93404: PUSH
93405: LD_INT 101
93407: PUSH
93408: LD_INT 102
93410: PUSH
93411: LD_INT 103
93413: PUSH
93414: LD_INT 104
93416: PUSH
93417: LD_INT 105
93419: PUSH
93420: LD_INT 106
93422: PUSH
93423: LD_INT 107
93425: PUSH
93426: LD_INT 108
93428: PUSH
93429: LD_INT 109
93431: PUSH
93432: LD_INT 110
93434: PUSH
93435: LD_INT 111
93437: PUSH
93438: LD_INT 112
93440: PUSH
93441: LD_INT 113
93443: PUSH
93444: LD_INT 114
93446: PUSH
93447: LD_INT 116
93449: PUSH
93450: LD_INT 117
93452: PUSH
93453: LD_INT 118
93455: PUSH
93456: EMPTY
93457: LIST
93458: LIST
93459: LIST
93460: LIST
93461: LIST
93462: LIST
93463: LIST
93464: LIST
93465: LIST
93466: LIST
93467: LIST
93468: LIST
93469: LIST
93470: LIST
93471: LIST
93472: LIST
93473: LIST
93474: PUSH
93475: EMPTY
93476: LIST
93477: LIST
93478: ST_TO_ADDR
93479: GO 94934
93481: LD_INT 13
93483: DOUBLE
93484: EQUAL
93485: IFTRUE 93489
93487: GO 93697
93489: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
93490: LD_ADDR_VAR 0 2
93494: PUSH
93495: LD_INT 1
93497: PUSH
93498: LD_INT 2
93500: PUSH
93501: LD_INT 3
93503: PUSH
93504: LD_INT 4
93506: PUSH
93507: LD_INT 5
93509: PUSH
93510: LD_INT 8
93512: PUSH
93513: LD_INT 9
93515: PUSH
93516: LD_INT 10
93518: PUSH
93519: LD_INT 11
93521: PUSH
93522: LD_INT 12
93524: PUSH
93525: LD_INT 14
93527: PUSH
93528: LD_INT 15
93530: PUSH
93531: LD_INT 16
93533: PUSH
93534: LD_INT 17
93536: PUSH
93537: LD_INT 18
93539: PUSH
93540: LD_INT 19
93542: PUSH
93543: LD_INT 20
93545: PUSH
93546: LD_INT 21
93548: PUSH
93549: LD_INT 22
93551: PUSH
93552: LD_INT 23
93554: PUSH
93555: LD_INT 24
93557: PUSH
93558: LD_INT 25
93560: PUSH
93561: LD_INT 26
93563: PUSH
93564: LD_INT 27
93566: PUSH
93567: LD_INT 28
93569: PUSH
93570: LD_INT 30
93572: PUSH
93573: LD_INT 31
93575: PUSH
93576: LD_INT 32
93578: PUSH
93579: LD_INT 33
93581: PUSH
93582: LD_INT 34
93584: PUSH
93585: LD_INT 36
93587: PUSH
93588: EMPTY
93589: LIST
93590: LIST
93591: LIST
93592: LIST
93593: LIST
93594: LIST
93595: LIST
93596: LIST
93597: LIST
93598: LIST
93599: LIST
93600: LIST
93601: LIST
93602: LIST
93603: LIST
93604: LIST
93605: LIST
93606: LIST
93607: LIST
93608: LIST
93609: LIST
93610: LIST
93611: LIST
93612: LIST
93613: LIST
93614: LIST
93615: LIST
93616: LIST
93617: LIST
93618: LIST
93619: LIST
93620: PUSH
93621: LD_INT 101
93623: PUSH
93624: LD_INT 102
93626: PUSH
93627: LD_INT 103
93629: PUSH
93630: LD_INT 104
93632: PUSH
93633: LD_INT 105
93635: PUSH
93636: LD_INT 106
93638: PUSH
93639: LD_INT 107
93641: PUSH
93642: LD_INT 108
93644: PUSH
93645: LD_INT 109
93647: PUSH
93648: LD_INT 110
93650: PUSH
93651: LD_INT 111
93653: PUSH
93654: LD_INT 112
93656: PUSH
93657: LD_INT 113
93659: PUSH
93660: LD_INT 114
93662: PUSH
93663: LD_INT 116
93665: PUSH
93666: LD_INT 117
93668: PUSH
93669: LD_INT 118
93671: PUSH
93672: EMPTY
93673: LIST
93674: LIST
93675: LIST
93676: LIST
93677: LIST
93678: LIST
93679: LIST
93680: LIST
93681: LIST
93682: LIST
93683: LIST
93684: LIST
93685: LIST
93686: LIST
93687: LIST
93688: LIST
93689: LIST
93690: PUSH
93691: EMPTY
93692: LIST
93693: LIST
93694: ST_TO_ADDR
93695: GO 94934
93697: LD_INT 14
93699: DOUBLE
93700: EQUAL
93701: IFTRUE 93705
93703: GO 93929
93705: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
93706: LD_ADDR_VAR 0 2
93710: PUSH
93711: LD_INT 1
93713: PUSH
93714: LD_INT 2
93716: PUSH
93717: LD_INT 3
93719: PUSH
93720: LD_INT 4
93722: PUSH
93723: LD_INT 5
93725: PUSH
93726: LD_INT 6
93728: PUSH
93729: LD_INT 7
93731: PUSH
93732: LD_INT 8
93734: PUSH
93735: LD_INT 9
93737: PUSH
93738: LD_INT 10
93740: PUSH
93741: LD_INT 11
93743: PUSH
93744: LD_INT 12
93746: PUSH
93747: LD_INT 13
93749: PUSH
93750: LD_INT 14
93752: PUSH
93753: LD_INT 15
93755: PUSH
93756: LD_INT 16
93758: PUSH
93759: LD_INT 17
93761: PUSH
93762: LD_INT 18
93764: PUSH
93765: LD_INT 19
93767: PUSH
93768: LD_INT 20
93770: PUSH
93771: LD_INT 21
93773: PUSH
93774: LD_INT 22
93776: PUSH
93777: LD_INT 23
93779: PUSH
93780: LD_INT 24
93782: PUSH
93783: LD_INT 25
93785: PUSH
93786: LD_INT 26
93788: PUSH
93789: LD_INT 27
93791: PUSH
93792: LD_INT 28
93794: PUSH
93795: LD_INT 29
93797: PUSH
93798: LD_INT 30
93800: PUSH
93801: LD_INT 31
93803: PUSH
93804: LD_INT 32
93806: PUSH
93807: LD_INT 33
93809: PUSH
93810: LD_INT 34
93812: PUSH
93813: LD_INT 36
93815: PUSH
93816: EMPTY
93817: LIST
93818: LIST
93819: LIST
93820: LIST
93821: LIST
93822: LIST
93823: LIST
93824: LIST
93825: LIST
93826: LIST
93827: LIST
93828: LIST
93829: LIST
93830: LIST
93831: LIST
93832: LIST
93833: LIST
93834: LIST
93835: LIST
93836: LIST
93837: LIST
93838: LIST
93839: LIST
93840: LIST
93841: LIST
93842: LIST
93843: LIST
93844: LIST
93845: LIST
93846: LIST
93847: LIST
93848: LIST
93849: LIST
93850: LIST
93851: LIST
93852: PUSH
93853: LD_INT 101
93855: PUSH
93856: LD_INT 102
93858: PUSH
93859: LD_INT 103
93861: PUSH
93862: LD_INT 104
93864: PUSH
93865: LD_INT 105
93867: PUSH
93868: LD_INT 106
93870: PUSH
93871: LD_INT 107
93873: PUSH
93874: LD_INT 108
93876: PUSH
93877: LD_INT 109
93879: PUSH
93880: LD_INT 110
93882: PUSH
93883: LD_INT 111
93885: PUSH
93886: LD_INT 112
93888: PUSH
93889: LD_INT 113
93891: PUSH
93892: LD_INT 114
93894: PUSH
93895: LD_INT 116
93897: PUSH
93898: LD_INT 117
93900: PUSH
93901: LD_INT 118
93903: PUSH
93904: EMPTY
93905: LIST
93906: LIST
93907: LIST
93908: LIST
93909: LIST
93910: LIST
93911: LIST
93912: LIST
93913: LIST
93914: LIST
93915: LIST
93916: LIST
93917: LIST
93918: LIST
93919: LIST
93920: LIST
93921: LIST
93922: PUSH
93923: EMPTY
93924: LIST
93925: LIST
93926: ST_TO_ADDR
93927: GO 94934
93929: LD_INT 15
93931: DOUBLE
93932: EQUAL
93933: IFTRUE 93937
93935: GO 94161
93937: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
93938: LD_ADDR_VAR 0 2
93942: PUSH
93943: LD_INT 1
93945: PUSH
93946: LD_INT 2
93948: PUSH
93949: LD_INT 3
93951: PUSH
93952: LD_INT 4
93954: PUSH
93955: LD_INT 5
93957: PUSH
93958: LD_INT 6
93960: PUSH
93961: LD_INT 7
93963: PUSH
93964: LD_INT 8
93966: PUSH
93967: LD_INT 9
93969: PUSH
93970: LD_INT 10
93972: PUSH
93973: LD_INT 11
93975: PUSH
93976: LD_INT 12
93978: PUSH
93979: LD_INT 13
93981: PUSH
93982: LD_INT 14
93984: PUSH
93985: LD_INT 15
93987: PUSH
93988: LD_INT 16
93990: PUSH
93991: LD_INT 17
93993: PUSH
93994: LD_INT 18
93996: PUSH
93997: LD_INT 19
93999: PUSH
94000: LD_INT 20
94002: PUSH
94003: LD_INT 21
94005: PUSH
94006: LD_INT 22
94008: PUSH
94009: LD_INT 23
94011: PUSH
94012: LD_INT 24
94014: PUSH
94015: LD_INT 25
94017: PUSH
94018: LD_INT 26
94020: PUSH
94021: LD_INT 27
94023: PUSH
94024: LD_INT 28
94026: PUSH
94027: LD_INT 29
94029: PUSH
94030: LD_INT 30
94032: PUSH
94033: LD_INT 31
94035: PUSH
94036: LD_INT 32
94038: PUSH
94039: LD_INT 33
94041: PUSH
94042: LD_INT 34
94044: PUSH
94045: LD_INT 36
94047: PUSH
94048: EMPTY
94049: LIST
94050: LIST
94051: LIST
94052: LIST
94053: LIST
94054: LIST
94055: LIST
94056: LIST
94057: LIST
94058: LIST
94059: LIST
94060: LIST
94061: LIST
94062: LIST
94063: LIST
94064: LIST
94065: LIST
94066: LIST
94067: LIST
94068: LIST
94069: LIST
94070: LIST
94071: LIST
94072: LIST
94073: LIST
94074: LIST
94075: LIST
94076: LIST
94077: LIST
94078: LIST
94079: LIST
94080: LIST
94081: LIST
94082: LIST
94083: LIST
94084: PUSH
94085: LD_INT 101
94087: PUSH
94088: LD_INT 102
94090: PUSH
94091: LD_INT 103
94093: PUSH
94094: LD_INT 104
94096: PUSH
94097: LD_INT 105
94099: PUSH
94100: LD_INT 106
94102: PUSH
94103: LD_INT 107
94105: PUSH
94106: LD_INT 108
94108: PUSH
94109: LD_INT 109
94111: PUSH
94112: LD_INT 110
94114: PUSH
94115: LD_INT 111
94117: PUSH
94118: LD_INT 112
94120: PUSH
94121: LD_INT 113
94123: PUSH
94124: LD_INT 114
94126: PUSH
94127: LD_INT 116
94129: PUSH
94130: LD_INT 117
94132: PUSH
94133: LD_INT 118
94135: PUSH
94136: EMPTY
94137: LIST
94138: LIST
94139: LIST
94140: LIST
94141: LIST
94142: LIST
94143: LIST
94144: LIST
94145: LIST
94146: LIST
94147: LIST
94148: LIST
94149: LIST
94150: LIST
94151: LIST
94152: LIST
94153: LIST
94154: PUSH
94155: EMPTY
94156: LIST
94157: LIST
94158: ST_TO_ADDR
94159: GO 94934
94161: LD_INT 16
94163: DOUBLE
94164: EQUAL
94165: IFTRUE 94169
94167: GO 94305
94169: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
94170: LD_ADDR_VAR 0 2
94174: PUSH
94175: LD_INT 2
94177: PUSH
94178: LD_INT 4
94180: PUSH
94181: LD_INT 5
94183: PUSH
94184: LD_INT 7
94186: PUSH
94187: LD_INT 11
94189: PUSH
94190: LD_INT 12
94192: PUSH
94193: LD_INT 15
94195: PUSH
94196: LD_INT 16
94198: PUSH
94199: LD_INT 20
94201: PUSH
94202: LD_INT 21
94204: PUSH
94205: LD_INT 22
94207: PUSH
94208: LD_INT 23
94210: PUSH
94211: LD_INT 25
94213: PUSH
94214: LD_INT 26
94216: PUSH
94217: LD_INT 30
94219: PUSH
94220: LD_INT 31
94222: PUSH
94223: LD_INT 32
94225: PUSH
94226: LD_INT 33
94228: PUSH
94229: LD_INT 34
94231: PUSH
94232: EMPTY
94233: LIST
94234: LIST
94235: LIST
94236: LIST
94237: LIST
94238: LIST
94239: LIST
94240: LIST
94241: LIST
94242: LIST
94243: LIST
94244: LIST
94245: LIST
94246: LIST
94247: LIST
94248: LIST
94249: LIST
94250: LIST
94251: LIST
94252: PUSH
94253: LD_INT 101
94255: PUSH
94256: LD_INT 102
94258: PUSH
94259: LD_INT 103
94261: PUSH
94262: LD_INT 106
94264: PUSH
94265: LD_INT 108
94267: PUSH
94268: LD_INT 112
94270: PUSH
94271: LD_INT 113
94273: PUSH
94274: LD_INT 114
94276: PUSH
94277: LD_INT 116
94279: PUSH
94280: LD_INT 117
94282: PUSH
94283: LD_INT 118
94285: PUSH
94286: EMPTY
94287: LIST
94288: LIST
94289: LIST
94290: LIST
94291: LIST
94292: LIST
94293: LIST
94294: LIST
94295: LIST
94296: LIST
94297: LIST
94298: PUSH
94299: EMPTY
94300: LIST
94301: LIST
94302: ST_TO_ADDR
94303: GO 94934
94305: LD_INT 17
94307: DOUBLE
94308: EQUAL
94309: IFTRUE 94313
94311: GO 94537
94313: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
94314: LD_ADDR_VAR 0 2
94318: PUSH
94319: LD_INT 1
94321: PUSH
94322: LD_INT 2
94324: PUSH
94325: LD_INT 3
94327: PUSH
94328: LD_INT 4
94330: PUSH
94331: LD_INT 5
94333: PUSH
94334: LD_INT 6
94336: PUSH
94337: LD_INT 7
94339: PUSH
94340: LD_INT 8
94342: PUSH
94343: LD_INT 9
94345: PUSH
94346: LD_INT 10
94348: PUSH
94349: LD_INT 11
94351: PUSH
94352: LD_INT 12
94354: PUSH
94355: LD_INT 13
94357: PUSH
94358: LD_INT 14
94360: PUSH
94361: LD_INT 15
94363: PUSH
94364: LD_INT 16
94366: PUSH
94367: LD_INT 17
94369: PUSH
94370: LD_INT 18
94372: PUSH
94373: LD_INT 19
94375: PUSH
94376: LD_INT 20
94378: PUSH
94379: LD_INT 21
94381: PUSH
94382: LD_INT 22
94384: PUSH
94385: LD_INT 23
94387: PUSH
94388: LD_INT 24
94390: PUSH
94391: LD_INT 25
94393: PUSH
94394: LD_INT 26
94396: PUSH
94397: LD_INT 27
94399: PUSH
94400: LD_INT 28
94402: PUSH
94403: LD_INT 29
94405: PUSH
94406: LD_INT 30
94408: PUSH
94409: LD_INT 31
94411: PUSH
94412: LD_INT 32
94414: PUSH
94415: LD_INT 33
94417: PUSH
94418: LD_INT 34
94420: PUSH
94421: LD_INT 36
94423: PUSH
94424: EMPTY
94425: LIST
94426: LIST
94427: LIST
94428: LIST
94429: LIST
94430: LIST
94431: LIST
94432: LIST
94433: LIST
94434: LIST
94435: LIST
94436: LIST
94437: LIST
94438: LIST
94439: LIST
94440: LIST
94441: LIST
94442: LIST
94443: LIST
94444: LIST
94445: LIST
94446: LIST
94447: LIST
94448: LIST
94449: LIST
94450: LIST
94451: LIST
94452: LIST
94453: LIST
94454: LIST
94455: LIST
94456: LIST
94457: LIST
94458: LIST
94459: LIST
94460: PUSH
94461: LD_INT 101
94463: PUSH
94464: LD_INT 102
94466: PUSH
94467: LD_INT 103
94469: PUSH
94470: LD_INT 104
94472: PUSH
94473: LD_INT 105
94475: PUSH
94476: LD_INT 106
94478: PUSH
94479: LD_INT 107
94481: PUSH
94482: LD_INT 108
94484: PUSH
94485: LD_INT 109
94487: PUSH
94488: LD_INT 110
94490: PUSH
94491: LD_INT 111
94493: PUSH
94494: LD_INT 112
94496: PUSH
94497: LD_INT 113
94499: PUSH
94500: LD_INT 114
94502: PUSH
94503: LD_INT 116
94505: PUSH
94506: LD_INT 117
94508: PUSH
94509: LD_INT 118
94511: PUSH
94512: EMPTY
94513: LIST
94514: LIST
94515: LIST
94516: LIST
94517: LIST
94518: LIST
94519: LIST
94520: LIST
94521: LIST
94522: LIST
94523: LIST
94524: LIST
94525: LIST
94526: LIST
94527: LIST
94528: LIST
94529: LIST
94530: PUSH
94531: EMPTY
94532: LIST
94533: LIST
94534: ST_TO_ADDR
94535: GO 94934
94537: LD_INT 18
94539: DOUBLE
94540: EQUAL
94541: IFTRUE 94545
94543: GO 94693
94545: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
94546: LD_ADDR_VAR 0 2
94550: PUSH
94551: LD_INT 2
94553: PUSH
94554: LD_INT 4
94556: PUSH
94557: LD_INT 5
94559: PUSH
94560: LD_INT 7
94562: PUSH
94563: LD_INT 11
94565: PUSH
94566: LD_INT 12
94568: PUSH
94569: LD_INT 15
94571: PUSH
94572: LD_INT 16
94574: PUSH
94575: LD_INT 20
94577: PUSH
94578: LD_INT 21
94580: PUSH
94581: LD_INT 22
94583: PUSH
94584: LD_INT 23
94586: PUSH
94587: LD_INT 25
94589: PUSH
94590: LD_INT 26
94592: PUSH
94593: LD_INT 30
94595: PUSH
94596: LD_INT 31
94598: PUSH
94599: LD_INT 32
94601: PUSH
94602: LD_INT 33
94604: PUSH
94605: LD_INT 34
94607: PUSH
94608: LD_INT 35
94610: PUSH
94611: LD_INT 36
94613: PUSH
94614: EMPTY
94615: LIST
94616: LIST
94617: LIST
94618: LIST
94619: LIST
94620: LIST
94621: LIST
94622: LIST
94623: LIST
94624: LIST
94625: LIST
94626: LIST
94627: LIST
94628: LIST
94629: LIST
94630: LIST
94631: LIST
94632: LIST
94633: LIST
94634: LIST
94635: LIST
94636: PUSH
94637: LD_INT 101
94639: PUSH
94640: LD_INT 102
94642: PUSH
94643: LD_INT 103
94645: PUSH
94646: LD_INT 106
94648: PUSH
94649: LD_INT 108
94651: PUSH
94652: LD_INT 112
94654: PUSH
94655: LD_INT 113
94657: PUSH
94658: LD_INT 114
94660: PUSH
94661: LD_INT 115
94663: PUSH
94664: LD_INT 116
94666: PUSH
94667: LD_INT 117
94669: PUSH
94670: LD_INT 118
94672: PUSH
94673: EMPTY
94674: LIST
94675: LIST
94676: LIST
94677: LIST
94678: LIST
94679: LIST
94680: LIST
94681: LIST
94682: LIST
94683: LIST
94684: LIST
94685: LIST
94686: PUSH
94687: EMPTY
94688: LIST
94689: LIST
94690: ST_TO_ADDR
94691: GO 94934
94693: LD_INT 19
94695: DOUBLE
94696: EQUAL
94697: IFTRUE 94701
94699: GO 94933
94701: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
94702: LD_ADDR_VAR 0 2
94706: PUSH
94707: LD_INT 1
94709: PUSH
94710: LD_INT 2
94712: PUSH
94713: LD_INT 3
94715: PUSH
94716: LD_INT 4
94718: PUSH
94719: LD_INT 5
94721: PUSH
94722: LD_INT 6
94724: PUSH
94725: LD_INT 7
94727: PUSH
94728: LD_INT 8
94730: PUSH
94731: LD_INT 9
94733: PUSH
94734: LD_INT 10
94736: PUSH
94737: LD_INT 11
94739: PUSH
94740: LD_INT 12
94742: PUSH
94743: LD_INT 13
94745: PUSH
94746: LD_INT 14
94748: PUSH
94749: LD_INT 15
94751: PUSH
94752: LD_INT 16
94754: PUSH
94755: LD_INT 17
94757: PUSH
94758: LD_INT 18
94760: PUSH
94761: LD_INT 19
94763: PUSH
94764: LD_INT 20
94766: PUSH
94767: LD_INT 21
94769: PUSH
94770: LD_INT 22
94772: PUSH
94773: LD_INT 23
94775: PUSH
94776: LD_INT 24
94778: PUSH
94779: LD_INT 25
94781: PUSH
94782: LD_INT 26
94784: PUSH
94785: LD_INT 27
94787: PUSH
94788: LD_INT 28
94790: PUSH
94791: LD_INT 29
94793: PUSH
94794: LD_INT 30
94796: PUSH
94797: LD_INT 31
94799: PUSH
94800: LD_INT 32
94802: PUSH
94803: LD_INT 33
94805: PUSH
94806: LD_INT 34
94808: PUSH
94809: LD_INT 35
94811: PUSH
94812: LD_INT 36
94814: PUSH
94815: EMPTY
94816: LIST
94817: LIST
94818: LIST
94819: LIST
94820: LIST
94821: LIST
94822: LIST
94823: LIST
94824: LIST
94825: LIST
94826: LIST
94827: LIST
94828: LIST
94829: LIST
94830: LIST
94831: LIST
94832: LIST
94833: LIST
94834: LIST
94835: LIST
94836: LIST
94837: LIST
94838: LIST
94839: LIST
94840: LIST
94841: LIST
94842: LIST
94843: LIST
94844: LIST
94845: LIST
94846: LIST
94847: LIST
94848: LIST
94849: LIST
94850: LIST
94851: LIST
94852: PUSH
94853: LD_INT 101
94855: PUSH
94856: LD_INT 102
94858: PUSH
94859: LD_INT 103
94861: PUSH
94862: LD_INT 104
94864: PUSH
94865: LD_INT 105
94867: PUSH
94868: LD_INT 106
94870: PUSH
94871: LD_INT 107
94873: PUSH
94874: LD_INT 108
94876: PUSH
94877: LD_INT 109
94879: PUSH
94880: LD_INT 110
94882: PUSH
94883: LD_INT 111
94885: PUSH
94886: LD_INT 112
94888: PUSH
94889: LD_INT 113
94891: PUSH
94892: LD_INT 114
94894: PUSH
94895: LD_INT 115
94897: PUSH
94898: LD_INT 116
94900: PUSH
94901: LD_INT 117
94903: PUSH
94904: LD_INT 118
94906: PUSH
94907: EMPTY
94908: LIST
94909: LIST
94910: LIST
94911: LIST
94912: LIST
94913: LIST
94914: LIST
94915: LIST
94916: LIST
94917: LIST
94918: LIST
94919: LIST
94920: LIST
94921: LIST
94922: LIST
94923: LIST
94924: LIST
94925: LIST
94926: PUSH
94927: EMPTY
94928: LIST
94929: LIST
94930: ST_TO_ADDR
94931: GO 94934
94933: POP
// end else
94934: GO 95165
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
94936: LD_ADDR_VAR 0 2
94940: PUSH
94941: LD_INT 1
94943: PUSH
94944: LD_INT 2
94946: PUSH
94947: LD_INT 3
94949: PUSH
94950: LD_INT 4
94952: PUSH
94953: LD_INT 5
94955: PUSH
94956: LD_INT 6
94958: PUSH
94959: LD_INT 7
94961: PUSH
94962: LD_INT 8
94964: PUSH
94965: LD_INT 9
94967: PUSH
94968: LD_INT 10
94970: PUSH
94971: LD_INT 11
94973: PUSH
94974: LD_INT 12
94976: PUSH
94977: LD_INT 13
94979: PUSH
94980: LD_INT 14
94982: PUSH
94983: LD_INT 15
94985: PUSH
94986: LD_INT 16
94988: PUSH
94989: LD_INT 17
94991: PUSH
94992: LD_INT 18
94994: PUSH
94995: LD_INT 19
94997: PUSH
94998: LD_INT 20
95000: PUSH
95001: LD_INT 21
95003: PUSH
95004: LD_INT 22
95006: PUSH
95007: LD_INT 23
95009: PUSH
95010: LD_INT 24
95012: PUSH
95013: LD_INT 25
95015: PUSH
95016: LD_INT 26
95018: PUSH
95019: LD_INT 27
95021: PUSH
95022: LD_INT 28
95024: PUSH
95025: LD_INT 29
95027: PUSH
95028: LD_INT 30
95030: PUSH
95031: LD_INT 31
95033: PUSH
95034: LD_INT 32
95036: PUSH
95037: LD_INT 33
95039: PUSH
95040: LD_INT 34
95042: PUSH
95043: LD_INT 35
95045: PUSH
95046: LD_INT 36
95048: PUSH
95049: EMPTY
95050: LIST
95051: LIST
95052: LIST
95053: LIST
95054: LIST
95055: LIST
95056: LIST
95057: LIST
95058: LIST
95059: LIST
95060: LIST
95061: LIST
95062: LIST
95063: LIST
95064: LIST
95065: LIST
95066: LIST
95067: LIST
95068: LIST
95069: LIST
95070: LIST
95071: LIST
95072: LIST
95073: LIST
95074: LIST
95075: LIST
95076: LIST
95077: LIST
95078: LIST
95079: LIST
95080: LIST
95081: LIST
95082: LIST
95083: LIST
95084: LIST
95085: LIST
95086: PUSH
95087: LD_INT 101
95089: PUSH
95090: LD_INT 102
95092: PUSH
95093: LD_INT 103
95095: PUSH
95096: LD_INT 104
95098: PUSH
95099: LD_INT 105
95101: PUSH
95102: LD_INT 106
95104: PUSH
95105: LD_INT 107
95107: PUSH
95108: LD_INT 108
95110: PUSH
95111: LD_INT 109
95113: PUSH
95114: LD_INT 110
95116: PUSH
95117: LD_INT 111
95119: PUSH
95120: LD_INT 112
95122: PUSH
95123: LD_INT 113
95125: PUSH
95126: LD_INT 114
95128: PUSH
95129: LD_INT 115
95131: PUSH
95132: LD_INT 116
95134: PUSH
95135: LD_INT 117
95137: PUSH
95138: LD_INT 118
95140: PUSH
95141: EMPTY
95142: LIST
95143: LIST
95144: LIST
95145: LIST
95146: LIST
95147: LIST
95148: LIST
95149: LIST
95150: LIST
95151: LIST
95152: LIST
95153: LIST
95154: LIST
95155: LIST
95156: LIST
95157: LIST
95158: LIST
95159: LIST
95160: PUSH
95161: EMPTY
95162: LIST
95163: LIST
95164: ST_TO_ADDR
// if result then
95165: LD_VAR 0 2
95169: IFFALSE 95955
// begin normal :=  ;
95171: LD_ADDR_VAR 0 5
95175: PUSH
95176: LD_STRING 
95178: ST_TO_ADDR
// hardcore :=  ;
95179: LD_ADDR_VAR 0 6
95183: PUSH
95184: LD_STRING 
95186: ST_TO_ADDR
// active :=  ;
95187: LD_ADDR_VAR 0 7
95191: PUSH
95192: LD_STRING 
95194: ST_TO_ADDR
// for i = 1 to normalCounter do
95195: LD_ADDR_VAR 0 8
95199: PUSH
95200: DOUBLE
95201: LD_INT 1
95203: DEC
95204: ST_TO_ADDR
95205: LD_EXP 95
95209: PUSH
95210: FOR_TO
95211: IFFALSE 95312
// begin tmp := 0 ;
95213: LD_ADDR_VAR 0 3
95217: PUSH
95218: LD_STRING 0
95220: ST_TO_ADDR
// if result [ 1 ] then
95221: LD_VAR 0 2
95225: PUSH
95226: LD_INT 1
95228: ARRAY
95229: IFFALSE 95294
// if result [ 1 ] [ 1 ] = i then
95231: LD_VAR 0 2
95235: PUSH
95236: LD_INT 1
95238: ARRAY
95239: PUSH
95240: LD_INT 1
95242: ARRAY
95243: PUSH
95244: LD_VAR 0 8
95248: EQUAL
95249: IFFALSE 95294
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
95251: LD_ADDR_VAR 0 2
95255: PUSH
95256: LD_VAR 0 2
95260: PPUSH
95261: LD_INT 1
95263: PPUSH
95264: LD_VAR 0 2
95268: PUSH
95269: LD_INT 1
95271: ARRAY
95272: PPUSH
95273: LD_INT 1
95275: PPUSH
95276: CALL_OW 3
95280: PPUSH
95281: CALL_OW 1
95285: ST_TO_ADDR
// tmp := 1 ;
95286: LD_ADDR_VAR 0 3
95290: PUSH
95291: LD_STRING 1
95293: ST_TO_ADDR
// end ; normal := normal & tmp ;
95294: LD_ADDR_VAR 0 5
95298: PUSH
95299: LD_VAR 0 5
95303: PUSH
95304: LD_VAR 0 3
95308: STR
95309: ST_TO_ADDR
// end ;
95310: GO 95210
95312: POP
95313: POP
// for i = 1 to hardcoreCounter do
95314: LD_ADDR_VAR 0 8
95318: PUSH
95319: DOUBLE
95320: LD_INT 1
95322: DEC
95323: ST_TO_ADDR
95324: LD_EXP 96
95328: PUSH
95329: FOR_TO
95330: IFFALSE 95435
// begin tmp := 0 ;
95332: LD_ADDR_VAR 0 3
95336: PUSH
95337: LD_STRING 0
95339: ST_TO_ADDR
// if result [ 2 ] then
95340: LD_VAR 0 2
95344: PUSH
95345: LD_INT 2
95347: ARRAY
95348: IFFALSE 95417
// if result [ 2 ] [ 1 ] = 100 + i then
95350: LD_VAR 0 2
95354: PUSH
95355: LD_INT 2
95357: ARRAY
95358: PUSH
95359: LD_INT 1
95361: ARRAY
95362: PUSH
95363: LD_INT 100
95365: PUSH
95366: LD_VAR 0 8
95370: PLUS
95371: EQUAL
95372: IFFALSE 95417
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
95374: LD_ADDR_VAR 0 2
95378: PUSH
95379: LD_VAR 0 2
95383: PPUSH
95384: LD_INT 2
95386: PPUSH
95387: LD_VAR 0 2
95391: PUSH
95392: LD_INT 2
95394: ARRAY
95395: PPUSH
95396: LD_INT 1
95398: PPUSH
95399: CALL_OW 3
95403: PPUSH
95404: CALL_OW 1
95408: ST_TO_ADDR
// tmp := 1 ;
95409: LD_ADDR_VAR 0 3
95413: PUSH
95414: LD_STRING 1
95416: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
95417: LD_ADDR_VAR 0 6
95421: PUSH
95422: LD_VAR 0 6
95426: PUSH
95427: LD_VAR 0 3
95431: STR
95432: ST_TO_ADDR
// end ;
95433: GO 95329
95435: POP
95436: POP
// if isGameLoad then
95437: LD_VAR 0 1
95441: IFFALSE 95916
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
95443: LD_ADDR_VAR 0 4
95447: PUSH
95448: LD_EXP 99
95452: PUSH
95453: LD_EXP 98
95457: PUSH
95458: LD_EXP 100
95462: PUSH
95463: LD_EXP 97
95467: PUSH
95468: LD_EXP 101
95472: PUSH
95473: LD_EXP 102
95477: PUSH
95478: LD_EXP 103
95482: PUSH
95483: LD_EXP 104
95487: PUSH
95488: LD_EXP 105
95492: PUSH
95493: LD_EXP 106
95497: PUSH
95498: LD_EXP 107
95502: PUSH
95503: LD_EXP 108
95507: PUSH
95508: LD_EXP 109
95512: PUSH
95513: LD_EXP 110
95517: PUSH
95518: LD_EXP 118
95522: PUSH
95523: LD_EXP 119
95527: PUSH
95528: LD_EXP 120
95532: PUSH
95533: LD_EXP 121
95537: PUSH
95538: LD_EXP 123
95542: PUSH
95543: LD_EXP 124
95547: PUSH
95548: LD_EXP 125
95552: PUSH
95553: LD_EXP 128
95557: PUSH
95558: LD_EXP 130
95562: PUSH
95563: LD_EXP 131
95567: PUSH
95568: LD_EXP 132
95572: PUSH
95573: LD_EXP 134
95577: PUSH
95578: LD_EXP 135
95582: PUSH
95583: LD_EXP 138
95587: PUSH
95588: LD_EXP 139
95592: PUSH
95593: LD_EXP 140
95597: PUSH
95598: LD_EXP 141
95602: PUSH
95603: LD_EXP 142
95607: PUSH
95608: LD_EXP 143
95612: PUSH
95613: LD_EXP 144
95617: PUSH
95618: LD_EXP 145
95622: PUSH
95623: LD_EXP 146
95627: PUSH
95628: LD_EXP 111
95632: PUSH
95633: LD_EXP 112
95637: PUSH
95638: LD_EXP 115
95642: PUSH
95643: LD_EXP 116
95647: PUSH
95648: LD_EXP 117
95652: PUSH
95653: LD_EXP 113
95657: PUSH
95658: LD_EXP 114
95662: PUSH
95663: LD_EXP 122
95667: PUSH
95668: LD_EXP 126
95672: PUSH
95673: LD_EXP 127
95677: PUSH
95678: LD_EXP 129
95682: PUSH
95683: LD_EXP 133
95687: PUSH
95688: LD_EXP 136
95692: PUSH
95693: LD_EXP 137
95697: PUSH
95698: LD_EXP 147
95702: PUSH
95703: LD_EXP 148
95707: PUSH
95708: LD_EXP 149
95712: PUSH
95713: LD_EXP 150
95717: PUSH
95718: EMPTY
95719: LIST
95720: LIST
95721: LIST
95722: LIST
95723: LIST
95724: LIST
95725: LIST
95726: LIST
95727: LIST
95728: LIST
95729: LIST
95730: LIST
95731: LIST
95732: LIST
95733: LIST
95734: LIST
95735: LIST
95736: LIST
95737: LIST
95738: LIST
95739: LIST
95740: LIST
95741: LIST
95742: LIST
95743: LIST
95744: LIST
95745: LIST
95746: LIST
95747: LIST
95748: LIST
95749: LIST
95750: LIST
95751: LIST
95752: LIST
95753: LIST
95754: LIST
95755: LIST
95756: LIST
95757: LIST
95758: LIST
95759: LIST
95760: LIST
95761: LIST
95762: LIST
95763: LIST
95764: LIST
95765: LIST
95766: LIST
95767: LIST
95768: LIST
95769: LIST
95770: LIST
95771: LIST
95772: LIST
95773: ST_TO_ADDR
// tmp :=  ;
95774: LD_ADDR_VAR 0 3
95778: PUSH
95779: LD_STRING 
95781: ST_TO_ADDR
// for i = 1 to normalCounter do
95782: LD_ADDR_VAR 0 8
95786: PUSH
95787: DOUBLE
95788: LD_INT 1
95790: DEC
95791: ST_TO_ADDR
95792: LD_EXP 95
95796: PUSH
95797: FOR_TO
95798: IFFALSE 95834
// begin if flags [ i ] then
95800: LD_VAR 0 4
95804: PUSH
95805: LD_VAR 0 8
95809: ARRAY
95810: IFFALSE 95832
// tmp := tmp & i & ; ;
95812: LD_ADDR_VAR 0 3
95816: PUSH
95817: LD_VAR 0 3
95821: PUSH
95822: LD_VAR 0 8
95826: STR
95827: PUSH
95828: LD_STRING ;
95830: STR
95831: ST_TO_ADDR
// end ;
95832: GO 95797
95834: POP
95835: POP
// for i = 1 to hardcoreCounter do
95836: LD_ADDR_VAR 0 8
95840: PUSH
95841: DOUBLE
95842: LD_INT 1
95844: DEC
95845: ST_TO_ADDR
95846: LD_EXP 96
95850: PUSH
95851: FOR_TO
95852: IFFALSE 95898
// begin if flags [ normalCounter + i ] then
95854: LD_VAR 0 4
95858: PUSH
95859: LD_EXP 95
95863: PUSH
95864: LD_VAR 0 8
95868: PLUS
95869: ARRAY
95870: IFFALSE 95896
// tmp := tmp & ( 100 + i ) & ; ;
95872: LD_ADDR_VAR 0 3
95876: PUSH
95877: LD_VAR 0 3
95881: PUSH
95882: LD_INT 100
95884: PUSH
95885: LD_VAR 0 8
95889: PLUS
95890: STR
95891: PUSH
95892: LD_STRING ;
95894: STR
95895: ST_TO_ADDR
// end ;
95896: GO 95851
95898: POP
95899: POP
// if tmp then
95900: LD_VAR 0 3
95904: IFFALSE 95916
// active := tmp ;
95906: LD_ADDR_VAR 0 7
95910: PUSH
95911: LD_VAR 0 3
95915: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
95916: LD_STRING getStreamItemsFromMission("
95918: PUSH
95919: LD_VAR 0 5
95923: STR
95924: PUSH
95925: LD_STRING ","
95927: STR
95928: PUSH
95929: LD_VAR 0 6
95933: STR
95934: PUSH
95935: LD_STRING ","
95937: STR
95938: PUSH
95939: LD_VAR 0 7
95943: STR
95944: PUSH
95945: LD_STRING ")
95947: STR
95948: PPUSH
95949: CALL_OW 559
// end else
95953: GO 95962
// ToLua ( getStreamItemsFromMission("","","") ) ;
95955: LD_STRING getStreamItemsFromMission("","","")
95957: PPUSH
95958: CALL_OW 559
// end ;
95962: LD_VAR 0 2
95966: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
95967: LD_EXP 94
95971: PUSH
95972: LD_EXP 99
95976: AND
95977: IFFALSE 96101
95979: GO 95981
95981: DISABLE
95982: LD_INT 0
95984: PPUSH
95985: PPUSH
// begin enable ;
95986: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
95987: LD_ADDR_VAR 0 2
95991: PUSH
95992: LD_INT 22
95994: PUSH
95995: LD_OWVAR 2
95999: PUSH
96000: EMPTY
96001: LIST
96002: LIST
96003: PUSH
96004: LD_INT 2
96006: PUSH
96007: LD_INT 34
96009: PUSH
96010: LD_INT 7
96012: PUSH
96013: EMPTY
96014: LIST
96015: LIST
96016: PUSH
96017: LD_INT 34
96019: PUSH
96020: LD_INT 45
96022: PUSH
96023: EMPTY
96024: LIST
96025: LIST
96026: PUSH
96027: LD_INT 34
96029: PUSH
96030: LD_INT 28
96032: PUSH
96033: EMPTY
96034: LIST
96035: LIST
96036: PUSH
96037: LD_INT 34
96039: PUSH
96040: LD_INT 47
96042: PUSH
96043: EMPTY
96044: LIST
96045: LIST
96046: PUSH
96047: EMPTY
96048: LIST
96049: LIST
96050: LIST
96051: LIST
96052: LIST
96053: PUSH
96054: EMPTY
96055: LIST
96056: LIST
96057: PPUSH
96058: CALL_OW 69
96062: ST_TO_ADDR
// if not tmp then
96063: LD_VAR 0 2
96067: NOT
96068: IFFALSE 96072
// exit ;
96070: GO 96101
// for i in tmp do
96072: LD_ADDR_VAR 0 1
96076: PUSH
96077: LD_VAR 0 2
96081: PUSH
96082: FOR_IN
96083: IFFALSE 96099
// begin SetLives ( i , 0 ) ;
96085: LD_VAR 0 1
96089: PPUSH
96090: LD_INT 0
96092: PPUSH
96093: CALL_OW 234
// end ;
96097: GO 96082
96099: POP
96100: POP
// end ;
96101: PPOPN 2
96103: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
96104: LD_EXP 94
96108: PUSH
96109: LD_EXP 100
96113: AND
96114: IFFALSE 96198
96116: GO 96118
96118: DISABLE
96119: LD_INT 0
96121: PPUSH
96122: PPUSH
// begin enable ;
96123: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
96124: LD_ADDR_VAR 0 2
96128: PUSH
96129: LD_INT 22
96131: PUSH
96132: LD_OWVAR 2
96136: PUSH
96137: EMPTY
96138: LIST
96139: LIST
96140: PUSH
96141: LD_INT 32
96143: PUSH
96144: LD_INT 3
96146: PUSH
96147: EMPTY
96148: LIST
96149: LIST
96150: PUSH
96151: EMPTY
96152: LIST
96153: LIST
96154: PPUSH
96155: CALL_OW 69
96159: ST_TO_ADDR
// if not tmp then
96160: LD_VAR 0 2
96164: NOT
96165: IFFALSE 96169
// exit ;
96167: GO 96198
// for i in tmp do
96169: LD_ADDR_VAR 0 1
96173: PUSH
96174: LD_VAR 0 2
96178: PUSH
96179: FOR_IN
96180: IFFALSE 96196
// begin SetLives ( i , 0 ) ;
96182: LD_VAR 0 1
96186: PPUSH
96187: LD_INT 0
96189: PPUSH
96190: CALL_OW 234
// end ;
96194: GO 96179
96196: POP
96197: POP
// end ;
96198: PPOPN 2
96200: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
96201: LD_EXP 94
96205: PUSH
96206: LD_EXP 97
96210: AND
96211: IFFALSE 96304
96213: GO 96215
96215: DISABLE
96216: LD_INT 0
96218: PPUSH
// begin enable ;
96219: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
96220: LD_ADDR_VAR 0 1
96224: PUSH
96225: LD_INT 22
96227: PUSH
96228: LD_OWVAR 2
96232: PUSH
96233: EMPTY
96234: LIST
96235: LIST
96236: PUSH
96237: LD_INT 2
96239: PUSH
96240: LD_INT 25
96242: PUSH
96243: LD_INT 5
96245: PUSH
96246: EMPTY
96247: LIST
96248: LIST
96249: PUSH
96250: LD_INT 25
96252: PUSH
96253: LD_INT 9
96255: PUSH
96256: EMPTY
96257: LIST
96258: LIST
96259: PUSH
96260: LD_INT 25
96262: PUSH
96263: LD_INT 8
96265: PUSH
96266: EMPTY
96267: LIST
96268: LIST
96269: PUSH
96270: EMPTY
96271: LIST
96272: LIST
96273: LIST
96274: LIST
96275: PUSH
96276: EMPTY
96277: LIST
96278: LIST
96279: PPUSH
96280: CALL_OW 69
96284: PUSH
96285: FOR_IN
96286: IFFALSE 96302
// begin SetClass ( i , 1 ) ;
96288: LD_VAR 0 1
96292: PPUSH
96293: LD_INT 1
96295: PPUSH
96296: CALL_OW 336
// end ;
96300: GO 96285
96302: POP
96303: POP
// end ;
96304: PPOPN 1
96306: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
96307: LD_EXP 94
96311: PUSH
96312: LD_EXP 98
96316: AND
96317: PUSH
96318: LD_OWVAR 65
96322: PUSH
96323: LD_INT 7
96325: LESS
96326: AND
96327: IFFALSE 96341
96329: GO 96331
96331: DISABLE
// begin enable ;
96332: ENABLE
// game_speed := 7 ;
96333: LD_ADDR_OWVAR 65
96337: PUSH
96338: LD_INT 7
96340: ST_TO_ADDR
// end ;
96341: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
96342: LD_EXP 94
96346: PUSH
96347: LD_EXP 101
96351: AND
96352: IFFALSE 96554
96354: GO 96356
96356: DISABLE
96357: LD_INT 0
96359: PPUSH
96360: PPUSH
96361: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
96362: LD_ADDR_VAR 0 3
96366: PUSH
96367: LD_INT 81
96369: PUSH
96370: LD_OWVAR 2
96374: PUSH
96375: EMPTY
96376: LIST
96377: LIST
96378: PUSH
96379: LD_INT 21
96381: PUSH
96382: LD_INT 1
96384: PUSH
96385: EMPTY
96386: LIST
96387: LIST
96388: PUSH
96389: EMPTY
96390: LIST
96391: LIST
96392: PPUSH
96393: CALL_OW 69
96397: ST_TO_ADDR
// if not tmp then
96398: LD_VAR 0 3
96402: NOT
96403: IFFALSE 96407
// exit ;
96405: GO 96554
// if tmp > 5 then
96407: LD_VAR 0 3
96411: PUSH
96412: LD_INT 5
96414: GREATER
96415: IFFALSE 96427
// k := 5 else
96417: LD_ADDR_VAR 0 2
96421: PUSH
96422: LD_INT 5
96424: ST_TO_ADDR
96425: GO 96437
// k := tmp ;
96427: LD_ADDR_VAR 0 2
96431: PUSH
96432: LD_VAR 0 3
96436: ST_TO_ADDR
// for i := 1 to k do
96437: LD_ADDR_VAR 0 1
96441: PUSH
96442: DOUBLE
96443: LD_INT 1
96445: DEC
96446: ST_TO_ADDR
96447: LD_VAR 0 2
96451: PUSH
96452: FOR_TO
96453: IFFALSE 96552
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
96455: LD_VAR 0 3
96459: PUSH
96460: LD_VAR 0 1
96464: ARRAY
96465: PPUSH
96466: LD_VAR 0 1
96470: PUSH
96471: LD_INT 4
96473: MOD
96474: PUSH
96475: LD_INT 1
96477: PLUS
96478: PPUSH
96479: CALL_OW 259
96483: PUSH
96484: LD_INT 10
96486: LESS
96487: IFFALSE 96550
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
96489: LD_VAR 0 3
96493: PUSH
96494: LD_VAR 0 1
96498: ARRAY
96499: PPUSH
96500: LD_VAR 0 1
96504: PUSH
96505: LD_INT 4
96507: MOD
96508: PUSH
96509: LD_INT 1
96511: PLUS
96512: PPUSH
96513: LD_VAR 0 3
96517: PUSH
96518: LD_VAR 0 1
96522: ARRAY
96523: PPUSH
96524: LD_VAR 0 1
96528: PUSH
96529: LD_INT 4
96531: MOD
96532: PUSH
96533: LD_INT 1
96535: PLUS
96536: PPUSH
96537: CALL_OW 259
96541: PUSH
96542: LD_INT 1
96544: PLUS
96545: PPUSH
96546: CALL_OW 237
96550: GO 96452
96552: POP
96553: POP
// end ;
96554: PPOPN 3
96556: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
96557: LD_EXP 94
96561: PUSH
96562: LD_EXP 102
96566: AND
96567: IFFALSE 96587
96569: GO 96571
96571: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
96572: LD_INT 4
96574: PPUSH
96575: LD_OWVAR 2
96579: PPUSH
96580: LD_INT 0
96582: PPUSH
96583: CALL_OW 324
96587: END
// every 0 0$1 trigger StreamModeActive and sShovel do
96588: LD_EXP 94
96592: PUSH
96593: LD_EXP 131
96597: AND
96598: IFFALSE 96618
96600: GO 96602
96602: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
96603: LD_INT 19
96605: PPUSH
96606: LD_OWVAR 2
96610: PPUSH
96611: LD_INT 0
96613: PPUSH
96614: CALL_OW 324
96618: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
96619: LD_EXP 94
96623: PUSH
96624: LD_EXP 103
96628: AND
96629: IFFALSE 96731
96631: GO 96633
96633: DISABLE
96634: LD_INT 0
96636: PPUSH
96637: PPUSH
// begin enable ;
96638: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
96639: LD_ADDR_VAR 0 2
96643: PUSH
96644: LD_INT 22
96646: PUSH
96647: LD_OWVAR 2
96651: PUSH
96652: EMPTY
96653: LIST
96654: LIST
96655: PUSH
96656: LD_INT 2
96658: PUSH
96659: LD_INT 34
96661: PUSH
96662: LD_INT 11
96664: PUSH
96665: EMPTY
96666: LIST
96667: LIST
96668: PUSH
96669: LD_INT 34
96671: PUSH
96672: LD_INT 30
96674: PUSH
96675: EMPTY
96676: LIST
96677: LIST
96678: PUSH
96679: EMPTY
96680: LIST
96681: LIST
96682: LIST
96683: PUSH
96684: EMPTY
96685: LIST
96686: LIST
96687: PPUSH
96688: CALL_OW 69
96692: ST_TO_ADDR
// if not tmp then
96693: LD_VAR 0 2
96697: NOT
96698: IFFALSE 96702
// exit ;
96700: GO 96731
// for i in tmp do
96702: LD_ADDR_VAR 0 1
96706: PUSH
96707: LD_VAR 0 2
96711: PUSH
96712: FOR_IN
96713: IFFALSE 96729
// begin SetLives ( i , 0 ) ;
96715: LD_VAR 0 1
96719: PPUSH
96720: LD_INT 0
96722: PPUSH
96723: CALL_OW 234
// end ;
96727: GO 96712
96729: POP
96730: POP
// end ;
96731: PPOPN 2
96733: END
// every 0 0$1 trigger StreamModeActive and sBunker do
96734: LD_EXP 94
96738: PUSH
96739: LD_EXP 104
96743: AND
96744: IFFALSE 96764
96746: GO 96748
96748: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
96749: LD_INT 32
96751: PPUSH
96752: LD_OWVAR 2
96756: PPUSH
96757: LD_INT 0
96759: PPUSH
96760: CALL_OW 324
96764: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
96765: LD_EXP 94
96769: PUSH
96770: LD_EXP 105
96774: AND
96775: IFFALSE 96956
96777: GO 96779
96779: DISABLE
96780: LD_INT 0
96782: PPUSH
96783: PPUSH
96784: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
96785: LD_ADDR_VAR 0 2
96789: PUSH
96790: LD_INT 22
96792: PUSH
96793: LD_OWVAR 2
96797: PUSH
96798: EMPTY
96799: LIST
96800: LIST
96801: PUSH
96802: LD_INT 33
96804: PUSH
96805: LD_INT 3
96807: PUSH
96808: EMPTY
96809: LIST
96810: LIST
96811: PUSH
96812: EMPTY
96813: LIST
96814: LIST
96815: PPUSH
96816: CALL_OW 69
96820: ST_TO_ADDR
// if not tmp then
96821: LD_VAR 0 2
96825: NOT
96826: IFFALSE 96830
// exit ;
96828: GO 96956
// side := 0 ;
96830: LD_ADDR_VAR 0 3
96834: PUSH
96835: LD_INT 0
96837: ST_TO_ADDR
// for i := 1 to 8 do
96838: LD_ADDR_VAR 0 1
96842: PUSH
96843: DOUBLE
96844: LD_INT 1
96846: DEC
96847: ST_TO_ADDR
96848: LD_INT 8
96850: PUSH
96851: FOR_TO
96852: IFFALSE 96900
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
96854: LD_OWVAR 2
96858: PUSH
96859: LD_VAR 0 1
96863: NONEQUAL
96864: PUSH
96865: LD_OWVAR 2
96869: PPUSH
96870: LD_VAR 0 1
96874: PPUSH
96875: CALL_OW 81
96879: PUSH
96880: LD_INT 2
96882: EQUAL
96883: AND
96884: IFFALSE 96898
// begin side := i ;
96886: LD_ADDR_VAR 0 3
96890: PUSH
96891: LD_VAR 0 1
96895: ST_TO_ADDR
// break ;
96896: GO 96900
// end ;
96898: GO 96851
96900: POP
96901: POP
// if not side then
96902: LD_VAR 0 3
96906: NOT
96907: IFFALSE 96911
// exit ;
96909: GO 96956
// for i := 1 to tmp do
96911: LD_ADDR_VAR 0 1
96915: PUSH
96916: DOUBLE
96917: LD_INT 1
96919: DEC
96920: ST_TO_ADDR
96921: LD_VAR 0 2
96925: PUSH
96926: FOR_TO
96927: IFFALSE 96954
// if Prob ( 60 ) then
96929: LD_INT 60
96931: PPUSH
96932: CALL_OW 13
96936: IFFALSE 96952
// SetSide ( i , side ) ;
96938: LD_VAR 0 1
96942: PPUSH
96943: LD_VAR 0 3
96947: PPUSH
96948: CALL_OW 235
96952: GO 96926
96954: POP
96955: POP
// end ;
96956: PPOPN 3
96958: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
96959: LD_EXP 94
96963: PUSH
96964: LD_EXP 107
96968: AND
96969: IFFALSE 97088
96971: GO 96973
96973: DISABLE
96974: LD_INT 0
96976: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
96977: LD_ADDR_VAR 0 1
96981: PUSH
96982: LD_INT 22
96984: PUSH
96985: LD_OWVAR 2
96989: PUSH
96990: EMPTY
96991: LIST
96992: LIST
96993: PUSH
96994: LD_INT 21
96996: PUSH
96997: LD_INT 1
96999: PUSH
97000: EMPTY
97001: LIST
97002: LIST
97003: PUSH
97004: LD_INT 3
97006: PUSH
97007: LD_INT 23
97009: PUSH
97010: LD_INT 0
97012: PUSH
97013: EMPTY
97014: LIST
97015: LIST
97016: PUSH
97017: EMPTY
97018: LIST
97019: LIST
97020: PUSH
97021: EMPTY
97022: LIST
97023: LIST
97024: LIST
97025: PPUSH
97026: CALL_OW 69
97030: PUSH
97031: FOR_IN
97032: IFFALSE 97086
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
97034: LD_VAR 0 1
97038: PPUSH
97039: CALL_OW 257
97043: PUSH
97044: LD_INT 1
97046: PUSH
97047: LD_INT 2
97049: PUSH
97050: LD_INT 3
97052: PUSH
97053: LD_INT 4
97055: PUSH
97056: EMPTY
97057: LIST
97058: LIST
97059: LIST
97060: LIST
97061: IN
97062: IFFALSE 97084
// SetClass ( un , rand ( 1 , 4 ) ) ;
97064: LD_VAR 0 1
97068: PPUSH
97069: LD_INT 1
97071: PPUSH
97072: LD_INT 4
97074: PPUSH
97075: CALL_OW 12
97079: PPUSH
97080: CALL_OW 336
97084: GO 97031
97086: POP
97087: POP
// end ;
97088: PPOPN 1
97090: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
97091: LD_EXP 94
97095: PUSH
97096: LD_EXP 106
97100: AND
97101: IFFALSE 97180
97103: GO 97105
97105: DISABLE
97106: LD_INT 0
97108: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
97109: LD_ADDR_VAR 0 1
97113: PUSH
97114: LD_INT 22
97116: PUSH
97117: LD_OWVAR 2
97121: PUSH
97122: EMPTY
97123: LIST
97124: LIST
97125: PUSH
97126: LD_INT 21
97128: PUSH
97129: LD_INT 3
97131: PUSH
97132: EMPTY
97133: LIST
97134: LIST
97135: PUSH
97136: EMPTY
97137: LIST
97138: LIST
97139: PPUSH
97140: CALL_OW 69
97144: ST_TO_ADDR
// if not tmp then
97145: LD_VAR 0 1
97149: NOT
97150: IFFALSE 97154
// exit ;
97152: GO 97180
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
97154: LD_VAR 0 1
97158: PUSH
97159: LD_INT 1
97161: PPUSH
97162: LD_VAR 0 1
97166: PPUSH
97167: CALL_OW 12
97171: ARRAY
97172: PPUSH
97173: LD_INT 100
97175: PPUSH
97176: CALL_OW 234
// end ;
97180: PPOPN 1
97182: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
97183: LD_EXP 94
97187: PUSH
97188: LD_EXP 108
97192: AND
97193: IFFALSE 97291
97195: GO 97197
97197: DISABLE
97198: LD_INT 0
97200: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
97201: LD_ADDR_VAR 0 1
97205: PUSH
97206: LD_INT 22
97208: PUSH
97209: LD_OWVAR 2
97213: PUSH
97214: EMPTY
97215: LIST
97216: LIST
97217: PUSH
97218: LD_INT 21
97220: PUSH
97221: LD_INT 1
97223: PUSH
97224: EMPTY
97225: LIST
97226: LIST
97227: PUSH
97228: EMPTY
97229: LIST
97230: LIST
97231: PPUSH
97232: CALL_OW 69
97236: ST_TO_ADDR
// if not tmp then
97237: LD_VAR 0 1
97241: NOT
97242: IFFALSE 97246
// exit ;
97244: GO 97291
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
97246: LD_VAR 0 1
97250: PUSH
97251: LD_INT 1
97253: PPUSH
97254: LD_VAR 0 1
97258: PPUSH
97259: CALL_OW 12
97263: ARRAY
97264: PPUSH
97265: LD_INT 1
97267: PPUSH
97268: LD_INT 4
97270: PPUSH
97271: CALL_OW 12
97275: PPUSH
97276: LD_INT 3000
97278: PPUSH
97279: LD_INT 9000
97281: PPUSH
97282: CALL_OW 12
97286: PPUSH
97287: CALL_OW 492
// end ;
97291: PPOPN 1
97293: END
// every 0 0$1 trigger StreamModeActive and sDepot do
97294: LD_EXP 94
97298: PUSH
97299: LD_EXP 109
97303: AND
97304: IFFALSE 97324
97306: GO 97308
97308: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
97309: LD_INT 1
97311: PPUSH
97312: LD_OWVAR 2
97316: PPUSH
97317: LD_INT 0
97319: PPUSH
97320: CALL_OW 324
97324: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
97325: LD_EXP 94
97329: PUSH
97330: LD_EXP 110
97334: AND
97335: IFFALSE 97418
97337: GO 97339
97339: DISABLE
97340: LD_INT 0
97342: PPUSH
97343: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
97344: LD_ADDR_VAR 0 2
97348: PUSH
97349: LD_INT 22
97351: PUSH
97352: LD_OWVAR 2
97356: PUSH
97357: EMPTY
97358: LIST
97359: LIST
97360: PUSH
97361: LD_INT 21
97363: PUSH
97364: LD_INT 3
97366: PUSH
97367: EMPTY
97368: LIST
97369: LIST
97370: PUSH
97371: EMPTY
97372: LIST
97373: LIST
97374: PPUSH
97375: CALL_OW 69
97379: ST_TO_ADDR
// if not tmp then
97380: LD_VAR 0 2
97384: NOT
97385: IFFALSE 97389
// exit ;
97387: GO 97418
// for i in tmp do
97389: LD_ADDR_VAR 0 1
97393: PUSH
97394: LD_VAR 0 2
97398: PUSH
97399: FOR_IN
97400: IFFALSE 97416
// SetBLevel ( i , 10 ) ;
97402: LD_VAR 0 1
97406: PPUSH
97407: LD_INT 10
97409: PPUSH
97410: CALL_OW 241
97414: GO 97399
97416: POP
97417: POP
// end ;
97418: PPOPN 2
97420: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
97421: LD_EXP 94
97425: PUSH
97426: LD_EXP 111
97430: AND
97431: IFFALSE 97542
97433: GO 97435
97435: DISABLE
97436: LD_INT 0
97438: PPUSH
97439: PPUSH
97440: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
97441: LD_ADDR_VAR 0 3
97445: PUSH
97446: LD_INT 22
97448: PUSH
97449: LD_OWVAR 2
97453: PUSH
97454: EMPTY
97455: LIST
97456: LIST
97457: PUSH
97458: LD_INT 25
97460: PUSH
97461: LD_INT 1
97463: PUSH
97464: EMPTY
97465: LIST
97466: LIST
97467: PUSH
97468: EMPTY
97469: LIST
97470: LIST
97471: PPUSH
97472: CALL_OW 69
97476: ST_TO_ADDR
// if not tmp then
97477: LD_VAR 0 3
97481: NOT
97482: IFFALSE 97486
// exit ;
97484: GO 97542
// un := tmp [ rand ( 1 , tmp ) ] ;
97486: LD_ADDR_VAR 0 2
97490: PUSH
97491: LD_VAR 0 3
97495: PUSH
97496: LD_INT 1
97498: PPUSH
97499: LD_VAR 0 3
97503: PPUSH
97504: CALL_OW 12
97508: ARRAY
97509: ST_TO_ADDR
// if Crawls ( un ) then
97510: LD_VAR 0 2
97514: PPUSH
97515: CALL_OW 318
97519: IFFALSE 97530
// ComWalk ( un ) ;
97521: LD_VAR 0 2
97525: PPUSH
97526: CALL_OW 138
// SetClass ( un , class_sniper ) ;
97530: LD_VAR 0 2
97534: PPUSH
97535: LD_INT 5
97537: PPUSH
97538: CALL_OW 336
// end ;
97542: PPOPN 3
97544: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
97545: LD_EXP 94
97549: PUSH
97550: LD_EXP 112
97554: AND
97555: PUSH
97556: LD_OWVAR 67
97560: PUSH
97561: LD_INT 4
97563: LESS
97564: AND
97565: IFFALSE 97584
97567: GO 97569
97569: DISABLE
// begin Difficulty := Difficulty + 1 ;
97570: LD_ADDR_OWVAR 67
97574: PUSH
97575: LD_OWVAR 67
97579: PUSH
97580: LD_INT 1
97582: PLUS
97583: ST_TO_ADDR
// end ;
97584: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
97585: LD_EXP 94
97589: PUSH
97590: LD_EXP 113
97594: AND
97595: IFFALSE 97698
97597: GO 97599
97599: DISABLE
97600: LD_INT 0
97602: PPUSH
// begin for i := 1 to 5 do
97603: LD_ADDR_VAR 0 1
97607: PUSH
97608: DOUBLE
97609: LD_INT 1
97611: DEC
97612: ST_TO_ADDR
97613: LD_INT 5
97615: PUSH
97616: FOR_TO
97617: IFFALSE 97696
// begin uc_nation := nation_nature ;
97619: LD_ADDR_OWVAR 21
97623: PUSH
97624: LD_INT 0
97626: ST_TO_ADDR
// uc_side := 0 ;
97627: LD_ADDR_OWVAR 20
97631: PUSH
97632: LD_INT 0
97634: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
97635: LD_ADDR_OWVAR 29
97639: PUSH
97640: LD_INT 12
97642: PUSH
97643: LD_INT 12
97645: PUSH
97646: EMPTY
97647: LIST
97648: LIST
97649: ST_TO_ADDR
// hc_agressivity := 20 ;
97650: LD_ADDR_OWVAR 35
97654: PUSH
97655: LD_INT 20
97657: ST_TO_ADDR
// hc_class := class_tiger ;
97658: LD_ADDR_OWVAR 28
97662: PUSH
97663: LD_INT 14
97665: ST_TO_ADDR
// hc_gallery :=  ;
97666: LD_ADDR_OWVAR 33
97670: PUSH
97671: LD_STRING 
97673: ST_TO_ADDR
// hc_name :=  ;
97674: LD_ADDR_OWVAR 26
97678: PUSH
97679: LD_STRING 
97681: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
97682: CALL_OW 44
97686: PPUSH
97687: LD_INT 0
97689: PPUSH
97690: CALL_OW 51
// end ;
97694: GO 97616
97696: POP
97697: POP
// end ;
97698: PPOPN 1
97700: END
// every 0 0$1 trigger StreamModeActive and sBomb do
97701: LD_EXP 94
97705: PUSH
97706: LD_EXP 114
97710: AND
97711: IFFALSE 97720
97713: GO 97715
97715: DISABLE
// StreamSibBomb ;
97716: CALL 97721 0 0
97720: END
// export function StreamSibBomb ; var i , x , y ; begin
97721: LD_INT 0
97723: PPUSH
97724: PPUSH
97725: PPUSH
97726: PPUSH
// result := false ;
97727: LD_ADDR_VAR 0 1
97731: PUSH
97732: LD_INT 0
97734: ST_TO_ADDR
// for i := 1 to 16 do
97735: LD_ADDR_VAR 0 2
97739: PUSH
97740: DOUBLE
97741: LD_INT 1
97743: DEC
97744: ST_TO_ADDR
97745: LD_INT 16
97747: PUSH
97748: FOR_TO
97749: IFFALSE 97948
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
97751: LD_ADDR_VAR 0 3
97755: PUSH
97756: LD_INT 10
97758: PUSH
97759: LD_INT 20
97761: PUSH
97762: LD_INT 30
97764: PUSH
97765: LD_INT 40
97767: PUSH
97768: LD_INT 50
97770: PUSH
97771: LD_INT 60
97773: PUSH
97774: LD_INT 70
97776: PUSH
97777: LD_INT 80
97779: PUSH
97780: LD_INT 90
97782: PUSH
97783: LD_INT 100
97785: PUSH
97786: LD_INT 110
97788: PUSH
97789: LD_INT 120
97791: PUSH
97792: LD_INT 130
97794: PUSH
97795: LD_INT 140
97797: PUSH
97798: LD_INT 150
97800: PUSH
97801: EMPTY
97802: LIST
97803: LIST
97804: LIST
97805: LIST
97806: LIST
97807: LIST
97808: LIST
97809: LIST
97810: LIST
97811: LIST
97812: LIST
97813: LIST
97814: LIST
97815: LIST
97816: LIST
97817: PUSH
97818: LD_INT 1
97820: PPUSH
97821: LD_INT 15
97823: PPUSH
97824: CALL_OW 12
97828: ARRAY
97829: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
97830: LD_ADDR_VAR 0 4
97834: PUSH
97835: LD_INT 10
97837: PUSH
97838: LD_INT 20
97840: PUSH
97841: LD_INT 30
97843: PUSH
97844: LD_INT 40
97846: PUSH
97847: LD_INT 50
97849: PUSH
97850: LD_INT 60
97852: PUSH
97853: LD_INT 70
97855: PUSH
97856: LD_INT 80
97858: PUSH
97859: LD_INT 90
97861: PUSH
97862: LD_INT 100
97864: PUSH
97865: LD_INT 110
97867: PUSH
97868: LD_INT 120
97870: PUSH
97871: LD_INT 130
97873: PUSH
97874: LD_INT 140
97876: PUSH
97877: LD_INT 150
97879: PUSH
97880: EMPTY
97881: LIST
97882: LIST
97883: LIST
97884: LIST
97885: LIST
97886: LIST
97887: LIST
97888: LIST
97889: LIST
97890: LIST
97891: LIST
97892: LIST
97893: LIST
97894: LIST
97895: LIST
97896: PUSH
97897: LD_INT 1
97899: PPUSH
97900: LD_INT 15
97902: PPUSH
97903: CALL_OW 12
97907: ARRAY
97908: ST_TO_ADDR
// if ValidHex ( x , y ) then
97909: LD_VAR 0 3
97913: PPUSH
97914: LD_VAR 0 4
97918: PPUSH
97919: CALL_OW 488
97923: IFFALSE 97946
// begin result := [ x , y ] ;
97925: LD_ADDR_VAR 0 1
97929: PUSH
97930: LD_VAR 0 3
97934: PUSH
97935: LD_VAR 0 4
97939: PUSH
97940: EMPTY
97941: LIST
97942: LIST
97943: ST_TO_ADDR
// break ;
97944: GO 97948
// end ; end ;
97946: GO 97748
97948: POP
97949: POP
// if result then
97950: LD_VAR 0 1
97954: IFFALSE 98014
// begin ToLua ( playSibBomb() ) ;
97956: LD_STRING playSibBomb()
97958: PPUSH
97959: CALL_OW 559
// wait ( 0 0$14 ) ;
97963: LD_INT 490
97965: PPUSH
97966: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
97970: LD_VAR 0 1
97974: PUSH
97975: LD_INT 1
97977: ARRAY
97978: PPUSH
97979: LD_VAR 0 1
97983: PUSH
97984: LD_INT 2
97986: ARRAY
97987: PPUSH
97988: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
97992: LD_VAR 0 1
97996: PUSH
97997: LD_INT 1
97999: ARRAY
98000: PPUSH
98001: LD_VAR 0 1
98005: PUSH
98006: LD_INT 2
98008: ARRAY
98009: PPUSH
98010: CALL_OW 429
// end ; end ;
98014: LD_VAR 0 1
98018: RET
// every 0 0$1 trigger StreamModeActive and sReset do
98019: LD_EXP 94
98023: PUSH
98024: LD_EXP 116
98028: AND
98029: IFFALSE 98041
98031: GO 98033
98033: DISABLE
// YouLost (  ) ;
98034: LD_STRING 
98036: PPUSH
98037: CALL_OW 104
98041: END
// every 0 0$1 trigger StreamModeActive and sFog do
98042: LD_EXP 94
98046: PUSH
98047: LD_EXP 115
98051: AND
98052: IFFALSE 98066
98054: GO 98056
98056: DISABLE
// FogOff ( your_side ) ;
98057: LD_OWVAR 2
98061: PPUSH
98062: CALL_OW 344
98066: END
// every 0 0$1 trigger StreamModeActive and sSun do
98067: LD_EXP 94
98071: PUSH
98072: LD_EXP 117
98076: AND
98077: IFFALSE 98105
98079: GO 98081
98081: DISABLE
// begin solar_recharge_percent := 0 ;
98082: LD_ADDR_OWVAR 79
98086: PUSH
98087: LD_INT 0
98089: ST_TO_ADDR
// wait ( 5 5$00 ) ;
98090: LD_INT 10500
98092: PPUSH
98093: CALL_OW 67
// solar_recharge_percent := 100 ;
98097: LD_ADDR_OWVAR 79
98101: PUSH
98102: LD_INT 100
98104: ST_TO_ADDR
// end ;
98105: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
98106: LD_EXP 94
98110: PUSH
98111: LD_EXP 118
98115: AND
98116: IFFALSE 98355
98118: GO 98120
98120: DISABLE
98121: LD_INT 0
98123: PPUSH
98124: PPUSH
98125: PPUSH
// begin tmp := [ ] ;
98126: LD_ADDR_VAR 0 3
98130: PUSH
98131: EMPTY
98132: ST_TO_ADDR
// for i := 1 to 6 do
98133: LD_ADDR_VAR 0 1
98137: PUSH
98138: DOUBLE
98139: LD_INT 1
98141: DEC
98142: ST_TO_ADDR
98143: LD_INT 6
98145: PUSH
98146: FOR_TO
98147: IFFALSE 98252
// begin uc_nation := nation_nature ;
98149: LD_ADDR_OWVAR 21
98153: PUSH
98154: LD_INT 0
98156: ST_TO_ADDR
// uc_side := 0 ;
98157: LD_ADDR_OWVAR 20
98161: PUSH
98162: LD_INT 0
98164: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
98165: LD_ADDR_OWVAR 29
98169: PUSH
98170: LD_INT 12
98172: PUSH
98173: LD_INT 12
98175: PUSH
98176: EMPTY
98177: LIST
98178: LIST
98179: ST_TO_ADDR
// hc_agressivity := 20 ;
98180: LD_ADDR_OWVAR 35
98184: PUSH
98185: LD_INT 20
98187: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
98188: LD_ADDR_OWVAR 28
98192: PUSH
98193: LD_INT 17
98195: ST_TO_ADDR
// hc_gallery :=  ;
98196: LD_ADDR_OWVAR 33
98200: PUSH
98201: LD_STRING 
98203: ST_TO_ADDR
// hc_name :=  ;
98204: LD_ADDR_OWVAR 26
98208: PUSH
98209: LD_STRING 
98211: ST_TO_ADDR
// un := CreateHuman ;
98212: LD_ADDR_VAR 0 2
98216: PUSH
98217: CALL_OW 44
98221: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
98222: LD_VAR 0 2
98226: PPUSH
98227: LD_INT 1
98229: PPUSH
98230: CALL_OW 51
// tmp := tmp ^ un ;
98234: LD_ADDR_VAR 0 3
98238: PUSH
98239: LD_VAR 0 3
98243: PUSH
98244: LD_VAR 0 2
98248: ADD
98249: ST_TO_ADDR
// end ;
98250: GO 98146
98252: POP
98253: POP
// repeat wait ( 0 0$1 ) ;
98254: LD_INT 35
98256: PPUSH
98257: CALL_OW 67
// for un in tmp do
98261: LD_ADDR_VAR 0 2
98265: PUSH
98266: LD_VAR 0 3
98270: PUSH
98271: FOR_IN
98272: IFFALSE 98346
// begin if IsDead ( un ) then
98274: LD_VAR 0 2
98278: PPUSH
98279: CALL_OW 301
98283: IFFALSE 98303
// begin tmp := tmp diff un ;
98285: LD_ADDR_VAR 0 3
98289: PUSH
98290: LD_VAR 0 3
98294: PUSH
98295: LD_VAR 0 2
98299: DIFF
98300: ST_TO_ADDR
// continue ;
98301: GO 98271
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
98303: LD_VAR 0 2
98307: PPUSH
98308: LD_INT 3
98310: PUSH
98311: LD_INT 22
98313: PUSH
98314: LD_INT 0
98316: PUSH
98317: EMPTY
98318: LIST
98319: LIST
98320: PUSH
98321: EMPTY
98322: LIST
98323: LIST
98324: PPUSH
98325: CALL_OW 69
98329: PPUSH
98330: LD_VAR 0 2
98334: PPUSH
98335: CALL_OW 74
98339: PPUSH
98340: CALL_OW 115
// end ;
98344: GO 98271
98346: POP
98347: POP
// until not tmp ;
98348: LD_VAR 0 3
98352: NOT
98353: IFFALSE 98254
// end ;
98355: PPOPN 3
98357: END
// every 0 0$1 trigger StreamModeActive and sTroll do
98358: LD_EXP 94
98362: PUSH
98363: LD_EXP 119
98367: AND
98368: IFFALSE 98422
98370: GO 98372
98372: DISABLE
// begin ToLua ( displayTroll(); ) ;
98373: LD_STRING displayTroll();
98375: PPUSH
98376: CALL_OW 559
// wait ( 3 3$00 ) ;
98380: LD_INT 6300
98382: PPUSH
98383: CALL_OW 67
// ToLua ( hideTroll(); ) ;
98387: LD_STRING hideTroll();
98389: PPUSH
98390: CALL_OW 559
// wait ( 1 1$00 ) ;
98394: LD_INT 2100
98396: PPUSH
98397: CALL_OW 67
// ToLua ( displayTroll(); ) ;
98401: LD_STRING displayTroll();
98403: PPUSH
98404: CALL_OW 559
// wait ( 1 1$00 ) ;
98408: LD_INT 2100
98410: PPUSH
98411: CALL_OW 67
// ToLua ( hideTroll(); ) ;
98415: LD_STRING hideTroll();
98417: PPUSH
98418: CALL_OW 559
// end ;
98422: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
98423: LD_EXP 94
98427: PUSH
98428: LD_EXP 120
98432: AND
98433: IFFALSE 98496
98435: GO 98437
98437: DISABLE
98438: LD_INT 0
98440: PPUSH
// begin p := 0 ;
98441: LD_ADDR_VAR 0 1
98445: PUSH
98446: LD_INT 0
98448: ST_TO_ADDR
// repeat game_speed := 1 ;
98449: LD_ADDR_OWVAR 65
98453: PUSH
98454: LD_INT 1
98456: ST_TO_ADDR
// wait ( 0 0$1 ) ;
98457: LD_INT 35
98459: PPUSH
98460: CALL_OW 67
// p := p + 1 ;
98464: LD_ADDR_VAR 0 1
98468: PUSH
98469: LD_VAR 0 1
98473: PUSH
98474: LD_INT 1
98476: PLUS
98477: ST_TO_ADDR
// until p >= 60 ;
98478: LD_VAR 0 1
98482: PUSH
98483: LD_INT 60
98485: GREATEREQUAL
98486: IFFALSE 98449
// game_speed := 4 ;
98488: LD_ADDR_OWVAR 65
98492: PUSH
98493: LD_INT 4
98495: ST_TO_ADDR
// end ;
98496: PPOPN 1
98498: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
98499: LD_EXP 94
98503: PUSH
98504: LD_EXP 121
98508: AND
98509: IFFALSE 98655
98511: GO 98513
98513: DISABLE
98514: LD_INT 0
98516: PPUSH
98517: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
98518: LD_ADDR_VAR 0 1
98522: PUSH
98523: LD_INT 22
98525: PUSH
98526: LD_OWVAR 2
98530: PUSH
98531: EMPTY
98532: LIST
98533: LIST
98534: PUSH
98535: LD_INT 2
98537: PUSH
98538: LD_INT 30
98540: PUSH
98541: LD_INT 0
98543: PUSH
98544: EMPTY
98545: LIST
98546: LIST
98547: PUSH
98548: LD_INT 30
98550: PUSH
98551: LD_INT 1
98553: PUSH
98554: EMPTY
98555: LIST
98556: LIST
98557: PUSH
98558: EMPTY
98559: LIST
98560: LIST
98561: LIST
98562: PUSH
98563: EMPTY
98564: LIST
98565: LIST
98566: PPUSH
98567: CALL_OW 69
98571: ST_TO_ADDR
// if not depot then
98572: LD_VAR 0 1
98576: NOT
98577: IFFALSE 98581
// exit ;
98579: GO 98655
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
98581: LD_ADDR_VAR 0 2
98585: PUSH
98586: LD_VAR 0 1
98590: PUSH
98591: LD_INT 1
98593: PPUSH
98594: LD_VAR 0 1
98598: PPUSH
98599: CALL_OW 12
98603: ARRAY
98604: PPUSH
98605: CALL_OW 274
98609: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
98610: LD_VAR 0 2
98614: PPUSH
98615: LD_INT 1
98617: PPUSH
98618: LD_INT 0
98620: PPUSH
98621: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
98625: LD_VAR 0 2
98629: PPUSH
98630: LD_INT 2
98632: PPUSH
98633: LD_INT 0
98635: PPUSH
98636: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
98640: LD_VAR 0 2
98644: PPUSH
98645: LD_INT 3
98647: PPUSH
98648: LD_INT 0
98650: PPUSH
98651: CALL_OW 277
// end ;
98655: PPOPN 2
98657: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
98658: LD_EXP 94
98662: PUSH
98663: LD_EXP 122
98667: AND
98668: IFFALSE 98765
98670: GO 98672
98672: DISABLE
98673: LD_INT 0
98675: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
98676: LD_ADDR_VAR 0 1
98680: PUSH
98681: LD_INT 22
98683: PUSH
98684: LD_OWVAR 2
98688: PUSH
98689: EMPTY
98690: LIST
98691: LIST
98692: PUSH
98693: LD_INT 21
98695: PUSH
98696: LD_INT 1
98698: PUSH
98699: EMPTY
98700: LIST
98701: LIST
98702: PUSH
98703: LD_INT 3
98705: PUSH
98706: LD_INT 23
98708: PUSH
98709: LD_INT 0
98711: PUSH
98712: EMPTY
98713: LIST
98714: LIST
98715: PUSH
98716: EMPTY
98717: LIST
98718: LIST
98719: PUSH
98720: EMPTY
98721: LIST
98722: LIST
98723: LIST
98724: PPUSH
98725: CALL_OW 69
98729: ST_TO_ADDR
// if not tmp then
98730: LD_VAR 0 1
98734: NOT
98735: IFFALSE 98739
// exit ;
98737: GO 98765
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
98739: LD_VAR 0 1
98743: PUSH
98744: LD_INT 1
98746: PPUSH
98747: LD_VAR 0 1
98751: PPUSH
98752: CALL_OW 12
98756: ARRAY
98757: PPUSH
98758: LD_INT 200
98760: PPUSH
98761: CALL_OW 234
// end ;
98765: PPOPN 1
98767: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
98768: LD_EXP 94
98772: PUSH
98773: LD_EXP 123
98777: AND
98778: IFFALSE 98857
98780: GO 98782
98782: DISABLE
98783: LD_INT 0
98785: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
98786: LD_ADDR_VAR 0 1
98790: PUSH
98791: LD_INT 22
98793: PUSH
98794: LD_OWVAR 2
98798: PUSH
98799: EMPTY
98800: LIST
98801: LIST
98802: PUSH
98803: LD_INT 21
98805: PUSH
98806: LD_INT 2
98808: PUSH
98809: EMPTY
98810: LIST
98811: LIST
98812: PUSH
98813: EMPTY
98814: LIST
98815: LIST
98816: PPUSH
98817: CALL_OW 69
98821: ST_TO_ADDR
// if not tmp then
98822: LD_VAR 0 1
98826: NOT
98827: IFFALSE 98831
// exit ;
98829: GO 98857
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
98831: LD_VAR 0 1
98835: PUSH
98836: LD_INT 1
98838: PPUSH
98839: LD_VAR 0 1
98843: PPUSH
98844: CALL_OW 12
98848: ARRAY
98849: PPUSH
98850: LD_INT 60
98852: PPUSH
98853: CALL_OW 234
// end ;
98857: PPOPN 1
98859: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
98860: LD_EXP 94
98864: PUSH
98865: LD_EXP 124
98869: AND
98870: IFFALSE 98969
98872: GO 98874
98874: DISABLE
98875: LD_INT 0
98877: PPUSH
98878: PPUSH
// begin enable ;
98879: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
98880: LD_ADDR_VAR 0 1
98884: PUSH
98885: LD_INT 22
98887: PUSH
98888: LD_OWVAR 2
98892: PUSH
98893: EMPTY
98894: LIST
98895: LIST
98896: PUSH
98897: LD_INT 61
98899: PUSH
98900: EMPTY
98901: LIST
98902: PUSH
98903: LD_INT 33
98905: PUSH
98906: LD_INT 2
98908: PUSH
98909: EMPTY
98910: LIST
98911: LIST
98912: PUSH
98913: EMPTY
98914: LIST
98915: LIST
98916: LIST
98917: PPUSH
98918: CALL_OW 69
98922: ST_TO_ADDR
// if not tmp then
98923: LD_VAR 0 1
98927: NOT
98928: IFFALSE 98932
// exit ;
98930: GO 98969
// for i in tmp do
98932: LD_ADDR_VAR 0 2
98936: PUSH
98937: LD_VAR 0 1
98941: PUSH
98942: FOR_IN
98943: IFFALSE 98967
// if IsControledBy ( i ) then
98945: LD_VAR 0 2
98949: PPUSH
98950: CALL_OW 312
98954: IFFALSE 98965
// ComUnlink ( i ) ;
98956: LD_VAR 0 2
98960: PPUSH
98961: CALL_OW 136
98965: GO 98942
98967: POP
98968: POP
// end ;
98969: PPOPN 2
98971: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
98972: LD_EXP 94
98976: PUSH
98977: LD_EXP 125
98981: AND
98982: IFFALSE 99122
98984: GO 98986
98986: DISABLE
98987: LD_INT 0
98989: PPUSH
98990: PPUSH
// begin ToLua ( displayPowell(); ) ;
98991: LD_STRING displayPowell();
98993: PPUSH
98994: CALL_OW 559
// uc_side := 0 ;
98998: LD_ADDR_OWVAR 20
99002: PUSH
99003: LD_INT 0
99005: ST_TO_ADDR
// uc_nation := 2 ;
99006: LD_ADDR_OWVAR 21
99010: PUSH
99011: LD_INT 2
99013: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
99014: LD_ADDR_OWVAR 37
99018: PUSH
99019: LD_INT 14
99021: ST_TO_ADDR
// vc_engine := engine_siberite ;
99022: LD_ADDR_OWVAR 39
99026: PUSH
99027: LD_INT 3
99029: ST_TO_ADDR
// vc_control := control_apeman ;
99030: LD_ADDR_OWVAR 38
99034: PUSH
99035: LD_INT 5
99037: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
99038: LD_ADDR_OWVAR 40
99042: PUSH
99043: LD_INT 29
99045: ST_TO_ADDR
// un := CreateVehicle ;
99046: LD_ADDR_VAR 0 2
99050: PUSH
99051: CALL_OW 45
99055: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
99056: LD_VAR 0 2
99060: PPUSH
99061: LD_INT 1
99063: PPUSH
99064: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
99068: LD_INT 35
99070: PPUSH
99071: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
99075: LD_VAR 0 2
99079: PPUSH
99080: LD_INT 22
99082: PUSH
99083: LD_OWVAR 2
99087: PUSH
99088: EMPTY
99089: LIST
99090: LIST
99091: PPUSH
99092: CALL_OW 69
99096: PPUSH
99097: LD_VAR 0 2
99101: PPUSH
99102: CALL_OW 74
99106: PPUSH
99107: CALL_OW 115
// until IsDead ( un ) ;
99111: LD_VAR 0 2
99115: PPUSH
99116: CALL_OW 301
99120: IFFALSE 99068
// end ;
99122: PPOPN 2
99124: END
// every 0 0$1 trigger StreamModeActive and sStu do
99125: LD_EXP 94
99129: PUSH
99130: LD_EXP 133
99134: AND
99135: IFFALSE 99151
99137: GO 99139
99139: DISABLE
// begin ToLua ( displayStucuk(); ) ;
99140: LD_STRING displayStucuk();
99142: PPUSH
99143: CALL_OW 559
// ResetFog ;
99147: CALL_OW 335
// end ;
99151: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
99152: LD_EXP 94
99156: PUSH
99157: LD_EXP 126
99161: AND
99162: IFFALSE 99303
99164: GO 99166
99166: DISABLE
99167: LD_INT 0
99169: PPUSH
99170: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
99171: LD_ADDR_VAR 0 2
99175: PUSH
99176: LD_INT 22
99178: PUSH
99179: LD_OWVAR 2
99183: PUSH
99184: EMPTY
99185: LIST
99186: LIST
99187: PUSH
99188: LD_INT 21
99190: PUSH
99191: LD_INT 1
99193: PUSH
99194: EMPTY
99195: LIST
99196: LIST
99197: PUSH
99198: EMPTY
99199: LIST
99200: LIST
99201: PPUSH
99202: CALL_OW 69
99206: ST_TO_ADDR
// if not tmp then
99207: LD_VAR 0 2
99211: NOT
99212: IFFALSE 99216
// exit ;
99214: GO 99303
// un := tmp [ rand ( 1 , tmp ) ] ;
99216: LD_ADDR_VAR 0 1
99220: PUSH
99221: LD_VAR 0 2
99225: PUSH
99226: LD_INT 1
99228: PPUSH
99229: LD_VAR 0 2
99233: PPUSH
99234: CALL_OW 12
99238: ARRAY
99239: ST_TO_ADDR
// SetSide ( un , 0 ) ;
99240: LD_VAR 0 1
99244: PPUSH
99245: LD_INT 0
99247: PPUSH
99248: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
99252: LD_VAR 0 1
99256: PPUSH
99257: LD_OWVAR 3
99261: PUSH
99262: LD_VAR 0 1
99266: DIFF
99267: PPUSH
99268: LD_VAR 0 1
99272: PPUSH
99273: CALL_OW 74
99277: PPUSH
99278: CALL_OW 115
// wait ( 0 0$20 ) ;
99282: LD_INT 700
99284: PPUSH
99285: CALL_OW 67
// SetSide ( un , your_side ) ;
99289: LD_VAR 0 1
99293: PPUSH
99294: LD_OWVAR 2
99298: PPUSH
99299: CALL_OW 235
// end ;
99303: PPOPN 2
99305: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
99306: LD_EXP 94
99310: PUSH
99311: LD_EXP 127
99315: AND
99316: IFFALSE 99422
99318: GO 99320
99320: DISABLE
99321: LD_INT 0
99323: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
99324: LD_ADDR_VAR 0 1
99328: PUSH
99329: LD_INT 22
99331: PUSH
99332: LD_OWVAR 2
99336: PUSH
99337: EMPTY
99338: LIST
99339: LIST
99340: PUSH
99341: LD_INT 2
99343: PUSH
99344: LD_INT 30
99346: PUSH
99347: LD_INT 0
99349: PUSH
99350: EMPTY
99351: LIST
99352: LIST
99353: PUSH
99354: LD_INT 30
99356: PUSH
99357: LD_INT 1
99359: PUSH
99360: EMPTY
99361: LIST
99362: LIST
99363: PUSH
99364: EMPTY
99365: LIST
99366: LIST
99367: LIST
99368: PUSH
99369: EMPTY
99370: LIST
99371: LIST
99372: PPUSH
99373: CALL_OW 69
99377: ST_TO_ADDR
// if not depot then
99378: LD_VAR 0 1
99382: NOT
99383: IFFALSE 99387
// exit ;
99385: GO 99422
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
99387: LD_VAR 0 1
99391: PUSH
99392: LD_INT 1
99394: ARRAY
99395: PPUSH
99396: CALL_OW 250
99400: PPUSH
99401: LD_VAR 0 1
99405: PUSH
99406: LD_INT 1
99408: ARRAY
99409: PPUSH
99410: CALL_OW 251
99414: PPUSH
99415: LD_INT 70
99417: PPUSH
99418: CALL_OW 495
// end ;
99422: PPOPN 1
99424: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
99425: LD_EXP 94
99429: PUSH
99430: LD_EXP 128
99434: AND
99435: IFFALSE 99646
99437: GO 99439
99439: DISABLE
99440: LD_INT 0
99442: PPUSH
99443: PPUSH
99444: PPUSH
99445: PPUSH
99446: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
99447: LD_ADDR_VAR 0 5
99451: PUSH
99452: LD_INT 22
99454: PUSH
99455: LD_OWVAR 2
99459: PUSH
99460: EMPTY
99461: LIST
99462: LIST
99463: PUSH
99464: LD_INT 21
99466: PUSH
99467: LD_INT 1
99469: PUSH
99470: EMPTY
99471: LIST
99472: LIST
99473: PUSH
99474: EMPTY
99475: LIST
99476: LIST
99477: PPUSH
99478: CALL_OW 69
99482: ST_TO_ADDR
// if not tmp then
99483: LD_VAR 0 5
99487: NOT
99488: IFFALSE 99492
// exit ;
99490: GO 99646
// for i in tmp do
99492: LD_ADDR_VAR 0 1
99496: PUSH
99497: LD_VAR 0 5
99501: PUSH
99502: FOR_IN
99503: IFFALSE 99644
// begin d := rand ( 0 , 5 ) ;
99505: LD_ADDR_VAR 0 4
99509: PUSH
99510: LD_INT 0
99512: PPUSH
99513: LD_INT 5
99515: PPUSH
99516: CALL_OW 12
99520: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
99521: LD_ADDR_VAR 0 2
99525: PUSH
99526: LD_VAR 0 1
99530: PPUSH
99531: CALL_OW 250
99535: PPUSH
99536: LD_VAR 0 4
99540: PPUSH
99541: LD_INT 3
99543: PPUSH
99544: LD_INT 12
99546: PPUSH
99547: CALL_OW 12
99551: PPUSH
99552: CALL_OW 272
99556: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
99557: LD_ADDR_VAR 0 3
99561: PUSH
99562: LD_VAR 0 1
99566: PPUSH
99567: CALL_OW 251
99571: PPUSH
99572: LD_VAR 0 4
99576: PPUSH
99577: LD_INT 3
99579: PPUSH
99580: LD_INT 12
99582: PPUSH
99583: CALL_OW 12
99587: PPUSH
99588: CALL_OW 273
99592: ST_TO_ADDR
// if ValidHex ( x , y ) then
99593: LD_VAR 0 2
99597: PPUSH
99598: LD_VAR 0 3
99602: PPUSH
99603: CALL_OW 488
99607: IFFALSE 99642
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
99609: LD_VAR 0 1
99613: PPUSH
99614: LD_VAR 0 2
99618: PPUSH
99619: LD_VAR 0 3
99623: PPUSH
99624: LD_INT 3
99626: PPUSH
99627: LD_INT 6
99629: PPUSH
99630: CALL_OW 12
99634: PPUSH
99635: LD_INT 1
99637: PPUSH
99638: CALL_OW 483
// end ;
99642: GO 99502
99644: POP
99645: POP
// end ;
99646: PPOPN 5
99648: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
99649: LD_EXP 94
99653: PUSH
99654: LD_EXP 129
99658: AND
99659: IFFALSE 99753
99661: GO 99663
99663: DISABLE
99664: LD_INT 0
99666: PPUSH
99667: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
99668: LD_ADDR_VAR 0 2
99672: PUSH
99673: LD_INT 22
99675: PUSH
99676: LD_OWVAR 2
99680: PUSH
99681: EMPTY
99682: LIST
99683: LIST
99684: PUSH
99685: LD_INT 32
99687: PUSH
99688: LD_INT 1
99690: PUSH
99691: EMPTY
99692: LIST
99693: LIST
99694: PUSH
99695: LD_INT 21
99697: PUSH
99698: LD_INT 2
99700: PUSH
99701: EMPTY
99702: LIST
99703: LIST
99704: PUSH
99705: EMPTY
99706: LIST
99707: LIST
99708: LIST
99709: PPUSH
99710: CALL_OW 69
99714: ST_TO_ADDR
// if not tmp then
99715: LD_VAR 0 2
99719: NOT
99720: IFFALSE 99724
// exit ;
99722: GO 99753
// for i in tmp do
99724: LD_ADDR_VAR 0 1
99728: PUSH
99729: LD_VAR 0 2
99733: PUSH
99734: FOR_IN
99735: IFFALSE 99751
// SetFuel ( i , 0 ) ;
99737: LD_VAR 0 1
99741: PPUSH
99742: LD_INT 0
99744: PPUSH
99745: CALL_OW 240
99749: GO 99734
99751: POP
99752: POP
// end ;
99753: PPOPN 2
99755: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
99756: LD_EXP 94
99760: PUSH
99761: LD_EXP 130
99765: AND
99766: IFFALSE 99832
99768: GO 99770
99770: DISABLE
99771: LD_INT 0
99773: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
99774: LD_ADDR_VAR 0 1
99778: PUSH
99779: LD_INT 22
99781: PUSH
99782: LD_OWVAR 2
99786: PUSH
99787: EMPTY
99788: LIST
99789: LIST
99790: PUSH
99791: LD_INT 30
99793: PUSH
99794: LD_INT 29
99796: PUSH
99797: EMPTY
99798: LIST
99799: LIST
99800: PUSH
99801: EMPTY
99802: LIST
99803: LIST
99804: PPUSH
99805: CALL_OW 69
99809: ST_TO_ADDR
// if not tmp then
99810: LD_VAR 0 1
99814: NOT
99815: IFFALSE 99819
// exit ;
99817: GO 99832
// DestroyUnit ( tmp [ 1 ] ) ;
99819: LD_VAR 0 1
99823: PUSH
99824: LD_INT 1
99826: ARRAY
99827: PPUSH
99828: CALL_OW 65
// end ;
99832: PPOPN 1
99834: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
99835: LD_EXP 94
99839: PUSH
99840: LD_EXP 132
99844: AND
99845: IFFALSE 99974
99847: GO 99849
99849: DISABLE
99850: LD_INT 0
99852: PPUSH
// begin uc_side := 0 ;
99853: LD_ADDR_OWVAR 20
99857: PUSH
99858: LD_INT 0
99860: ST_TO_ADDR
// uc_nation := nation_arabian ;
99861: LD_ADDR_OWVAR 21
99865: PUSH
99866: LD_INT 2
99868: ST_TO_ADDR
// hc_gallery :=  ;
99869: LD_ADDR_OWVAR 33
99873: PUSH
99874: LD_STRING 
99876: ST_TO_ADDR
// hc_name :=  ;
99877: LD_ADDR_OWVAR 26
99881: PUSH
99882: LD_STRING 
99884: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
99885: LD_INT 1
99887: PPUSH
99888: LD_INT 11
99890: PPUSH
99891: LD_INT 10
99893: PPUSH
99894: CALL_OW 380
// un := CreateHuman ;
99898: LD_ADDR_VAR 0 1
99902: PUSH
99903: CALL_OW 44
99907: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
99908: LD_VAR 0 1
99912: PPUSH
99913: LD_INT 1
99915: PPUSH
99916: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
99920: LD_INT 35
99922: PPUSH
99923: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
99927: LD_VAR 0 1
99931: PPUSH
99932: LD_INT 22
99934: PUSH
99935: LD_OWVAR 2
99939: PUSH
99940: EMPTY
99941: LIST
99942: LIST
99943: PPUSH
99944: CALL_OW 69
99948: PPUSH
99949: LD_VAR 0 1
99953: PPUSH
99954: CALL_OW 74
99958: PPUSH
99959: CALL_OW 115
// until IsDead ( un ) ;
99963: LD_VAR 0 1
99967: PPUSH
99968: CALL_OW 301
99972: IFFALSE 99920
// end ;
99974: PPOPN 1
99976: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
99977: LD_EXP 94
99981: PUSH
99982: LD_EXP 134
99986: AND
99987: IFFALSE 99999
99989: GO 99991
99991: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
99992: LD_STRING earthquake(getX(game), 0, 32)
99994: PPUSH
99995: CALL_OW 559
99999: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
100000: LD_EXP 94
100004: PUSH
100005: LD_EXP 135
100009: AND
100010: IFFALSE 100101
100012: GO 100014
100014: DISABLE
100015: LD_INT 0
100017: PPUSH
// begin enable ;
100018: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
100019: LD_ADDR_VAR 0 1
100023: PUSH
100024: LD_INT 22
100026: PUSH
100027: LD_OWVAR 2
100031: PUSH
100032: EMPTY
100033: LIST
100034: LIST
100035: PUSH
100036: LD_INT 21
100038: PUSH
100039: LD_INT 2
100041: PUSH
100042: EMPTY
100043: LIST
100044: LIST
100045: PUSH
100046: LD_INT 33
100048: PUSH
100049: LD_INT 3
100051: PUSH
100052: EMPTY
100053: LIST
100054: LIST
100055: PUSH
100056: EMPTY
100057: LIST
100058: LIST
100059: LIST
100060: PPUSH
100061: CALL_OW 69
100065: ST_TO_ADDR
// if not tmp then
100066: LD_VAR 0 1
100070: NOT
100071: IFFALSE 100075
// exit ;
100073: GO 100101
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
100075: LD_VAR 0 1
100079: PUSH
100080: LD_INT 1
100082: PPUSH
100083: LD_VAR 0 1
100087: PPUSH
100088: CALL_OW 12
100092: ARRAY
100093: PPUSH
100094: LD_INT 1
100096: PPUSH
100097: CALL_OW 234
// end ;
100101: PPOPN 1
100103: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
100104: LD_EXP 94
100108: PUSH
100109: LD_EXP 136
100113: AND
100114: IFFALSE 100255
100116: GO 100118
100118: DISABLE
100119: LD_INT 0
100121: PPUSH
100122: PPUSH
100123: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
100124: LD_ADDR_VAR 0 3
100128: PUSH
100129: LD_INT 22
100131: PUSH
100132: LD_OWVAR 2
100136: PUSH
100137: EMPTY
100138: LIST
100139: LIST
100140: PUSH
100141: LD_INT 25
100143: PUSH
100144: LD_INT 1
100146: PUSH
100147: EMPTY
100148: LIST
100149: LIST
100150: PUSH
100151: EMPTY
100152: LIST
100153: LIST
100154: PPUSH
100155: CALL_OW 69
100159: ST_TO_ADDR
// if not tmp then
100160: LD_VAR 0 3
100164: NOT
100165: IFFALSE 100169
// exit ;
100167: GO 100255
// un := tmp [ rand ( 1 , tmp ) ] ;
100169: LD_ADDR_VAR 0 2
100173: PUSH
100174: LD_VAR 0 3
100178: PUSH
100179: LD_INT 1
100181: PPUSH
100182: LD_VAR 0 3
100186: PPUSH
100187: CALL_OW 12
100191: ARRAY
100192: ST_TO_ADDR
// if Crawls ( un ) then
100193: LD_VAR 0 2
100197: PPUSH
100198: CALL_OW 318
100202: IFFALSE 100213
// ComWalk ( un ) ;
100204: LD_VAR 0 2
100208: PPUSH
100209: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
100213: LD_VAR 0 2
100217: PPUSH
100218: LD_INT 9
100220: PPUSH
100221: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
100225: LD_INT 28
100227: PPUSH
100228: LD_OWVAR 2
100232: PPUSH
100233: LD_INT 2
100235: PPUSH
100236: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
100240: LD_INT 29
100242: PPUSH
100243: LD_OWVAR 2
100247: PPUSH
100248: LD_INT 2
100250: PPUSH
100251: CALL_OW 322
// end ;
100255: PPOPN 3
100257: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
100258: LD_EXP 94
100262: PUSH
100263: LD_EXP 137
100267: AND
100268: IFFALSE 100379
100270: GO 100272
100272: DISABLE
100273: LD_INT 0
100275: PPUSH
100276: PPUSH
100277: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
100278: LD_ADDR_VAR 0 3
100282: PUSH
100283: LD_INT 22
100285: PUSH
100286: LD_OWVAR 2
100290: PUSH
100291: EMPTY
100292: LIST
100293: LIST
100294: PUSH
100295: LD_INT 25
100297: PUSH
100298: LD_INT 1
100300: PUSH
100301: EMPTY
100302: LIST
100303: LIST
100304: PUSH
100305: EMPTY
100306: LIST
100307: LIST
100308: PPUSH
100309: CALL_OW 69
100313: ST_TO_ADDR
// if not tmp then
100314: LD_VAR 0 3
100318: NOT
100319: IFFALSE 100323
// exit ;
100321: GO 100379
// un := tmp [ rand ( 1 , tmp ) ] ;
100323: LD_ADDR_VAR 0 2
100327: PUSH
100328: LD_VAR 0 3
100332: PUSH
100333: LD_INT 1
100335: PPUSH
100336: LD_VAR 0 3
100340: PPUSH
100341: CALL_OW 12
100345: ARRAY
100346: ST_TO_ADDR
// if Crawls ( un ) then
100347: LD_VAR 0 2
100351: PPUSH
100352: CALL_OW 318
100356: IFFALSE 100367
// ComWalk ( un ) ;
100358: LD_VAR 0 2
100362: PPUSH
100363: CALL_OW 138
// SetClass ( un , class_mortar ) ;
100367: LD_VAR 0 2
100371: PPUSH
100372: LD_INT 8
100374: PPUSH
100375: CALL_OW 336
// end ;
100379: PPOPN 3
100381: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
100382: LD_EXP 94
100386: PUSH
100387: LD_EXP 138
100391: AND
100392: IFFALSE 100536
100394: GO 100396
100396: DISABLE
100397: LD_INT 0
100399: PPUSH
100400: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
100401: LD_ADDR_VAR 0 2
100405: PUSH
100406: LD_INT 22
100408: PUSH
100409: LD_OWVAR 2
100413: PUSH
100414: EMPTY
100415: LIST
100416: LIST
100417: PUSH
100418: LD_INT 21
100420: PUSH
100421: LD_INT 2
100423: PUSH
100424: EMPTY
100425: LIST
100426: LIST
100427: PUSH
100428: LD_INT 2
100430: PUSH
100431: LD_INT 34
100433: PUSH
100434: LD_INT 12
100436: PUSH
100437: EMPTY
100438: LIST
100439: LIST
100440: PUSH
100441: LD_INT 34
100443: PUSH
100444: LD_INT 51
100446: PUSH
100447: EMPTY
100448: LIST
100449: LIST
100450: PUSH
100451: LD_INT 34
100453: PUSH
100454: LD_INT 32
100456: PUSH
100457: EMPTY
100458: LIST
100459: LIST
100460: PUSH
100461: EMPTY
100462: LIST
100463: LIST
100464: LIST
100465: LIST
100466: PUSH
100467: EMPTY
100468: LIST
100469: LIST
100470: LIST
100471: PPUSH
100472: CALL_OW 69
100476: ST_TO_ADDR
// if not tmp then
100477: LD_VAR 0 2
100481: NOT
100482: IFFALSE 100486
// exit ;
100484: GO 100536
// for i in tmp do
100486: LD_ADDR_VAR 0 1
100490: PUSH
100491: LD_VAR 0 2
100495: PUSH
100496: FOR_IN
100497: IFFALSE 100534
// if GetCargo ( i , mat_artifact ) = 0 then
100499: LD_VAR 0 1
100503: PPUSH
100504: LD_INT 4
100506: PPUSH
100507: CALL_OW 289
100511: PUSH
100512: LD_INT 0
100514: EQUAL
100515: IFFALSE 100532
// SetCargo ( i , mat_siberit , 100 ) ;
100517: LD_VAR 0 1
100521: PPUSH
100522: LD_INT 3
100524: PPUSH
100525: LD_INT 100
100527: PPUSH
100528: CALL_OW 290
100532: GO 100496
100534: POP
100535: POP
// end ;
100536: PPOPN 2
100538: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
100539: LD_EXP 94
100543: PUSH
100544: LD_EXP 139
100548: AND
100549: IFFALSE 100732
100551: GO 100553
100553: DISABLE
100554: LD_INT 0
100556: PPUSH
100557: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
100558: LD_ADDR_VAR 0 2
100562: PUSH
100563: LD_INT 22
100565: PUSH
100566: LD_OWVAR 2
100570: PUSH
100571: EMPTY
100572: LIST
100573: LIST
100574: PPUSH
100575: CALL_OW 69
100579: ST_TO_ADDR
// if not tmp then
100580: LD_VAR 0 2
100584: NOT
100585: IFFALSE 100589
// exit ;
100587: GO 100732
// for i := 1 to 2 do
100589: LD_ADDR_VAR 0 1
100593: PUSH
100594: DOUBLE
100595: LD_INT 1
100597: DEC
100598: ST_TO_ADDR
100599: LD_INT 2
100601: PUSH
100602: FOR_TO
100603: IFFALSE 100730
// begin uc_side := your_side ;
100605: LD_ADDR_OWVAR 20
100609: PUSH
100610: LD_OWVAR 2
100614: ST_TO_ADDR
// uc_nation := nation_american ;
100615: LD_ADDR_OWVAR 21
100619: PUSH
100620: LD_INT 1
100622: ST_TO_ADDR
// vc_chassis := us_morphling ;
100623: LD_ADDR_OWVAR 37
100627: PUSH
100628: LD_INT 5
100630: ST_TO_ADDR
// vc_engine := engine_siberite ;
100631: LD_ADDR_OWVAR 39
100635: PUSH
100636: LD_INT 3
100638: ST_TO_ADDR
// vc_control := control_computer ;
100639: LD_ADDR_OWVAR 38
100643: PUSH
100644: LD_INT 3
100646: ST_TO_ADDR
// vc_weapon := us_double_laser ;
100647: LD_ADDR_OWVAR 40
100651: PUSH
100652: LD_INT 10
100654: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
100655: LD_VAR 0 2
100659: PUSH
100660: LD_INT 1
100662: ARRAY
100663: PPUSH
100664: CALL_OW 310
100668: NOT
100669: IFFALSE 100716
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
100671: CALL_OW 45
100675: PPUSH
100676: LD_VAR 0 2
100680: PUSH
100681: LD_INT 1
100683: ARRAY
100684: PPUSH
100685: CALL_OW 250
100689: PPUSH
100690: LD_VAR 0 2
100694: PUSH
100695: LD_INT 1
100697: ARRAY
100698: PPUSH
100699: CALL_OW 251
100703: PPUSH
100704: LD_INT 12
100706: PPUSH
100707: LD_INT 1
100709: PPUSH
100710: CALL_OW 50
100714: GO 100728
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
100716: CALL_OW 45
100720: PPUSH
100721: LD_INT 1
100723: PPUSH
100724: CALL_OW 51
// end ;
100728: GO 100602
100730: POP
100731: POP
// end ;
100732: PPOPN 2
100734: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
100735: LD_EXP 94
100739: PUSH
100740: LD_EXP 140
100744: AND
100745: IFFALSE 100967
100747: GO 100749
100749: DISABLE
100750: LD_INT 0
100752: PPUSH
100753: PPUSH
100754: PPUSH
100755: PPUSH
100756: PPUSH
100757: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
100758: LD_ADDR_VAR 0 6
100762: PUSH
100763: LD_INT 22
100765: PUSH
100766: LD_OWVAR 2
100770: PUSH
100771: EMPTY
100772: LIST
100773: LIST
100774: PUSH
100775: LD_INT 21
100777: PUSH
100778: LD_INT 1
100780: PUSH
100781: EMPTY
100782: LIST
100783: LIST
100784: PUSH
100785: LD_INT 3
100787: PUSH
100788: LD_INT 23
100790: PUSH
100791: LD_INT 0
100793: PUSH
100794: EMPTY
100795: LIST
100796: LIST
100797: PUSH
100798: EMPTY
100799: LIST
100800: LIST
100801: PUSH
100802: EMPTY
100803: LIST
100804: LIST
100805: LIST
100806: PPUSH
100807: CALL_OW 69
100811: ST_TO_ADDR
// if not tmp then
100812: LD_VAR 0 6
100816: NOT
100817: IFFALSE 100821
// exit ;
100819: GO 100967
// s1 := rand ( 1 , 4 ) ;
100821: LD_ADDR_VAR 0 2
100825: PUSH
100826: LD_INT 1
100828: PPUSH
100829: LD_INT 4
100831: PPUSH
100832: CALL_OW 12
100836: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
100837: LD_ADDR_VAR 0 4
100841: PUSH
100842: LD_VAR 0 6
100846: PUSH
100847: LD_INT 1
100849: ARRAY
100850: PPUSH
100851: LD_VAR 0 2
100855: PPUSH
100856: CALL_OW 259
100860: ST_TO_ADDR
// if s1 = 1 then
100861: LD_VAR 0 2
100865: PUSH
100866: LD_INT 1
100868: EQUAL
100869: IFFALSE 100889
// s2 := rand ( 2 , 4 ) else
100871: LD_ADDR_VAR 0 3
100875: PUSH
100876: LD_INT 2
100878: PPUSH
100879: LD_INT 4
100881: PPUSH
100882: CALL_OW 12
100886: ST_TO_ADDR
100887: GO 100897
// s2 := 1 ;
100889: LD_ADDR_VAR 0 3
100893: PUSH
100894: LD_INT 1
100896: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
100897: LD_ADDR_VAR 0 5
100901: PUSH
100902: LD_VAR 0 6
100906: PUSH
100907: LD_INT 1
100909: ARRAY
100910: PPUSH
100911: LD_VAR 0 3
100915: PPUSH
100916: CALL_OW 259
100920: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
100921: LD_VAR 0 6
100925: PUSH
100926: LD_INT 1
100928: ARRAY
100929: PPUSH
100930: LD_VAR 0 2
100934: PPUSH
100935: LD_VAR 0 5
100939: PPUSH
100940: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
100944: LD_VAR 0 6
100948: PUSH
100949: LD_INT 1
100951: ARRAY
100952: PPUSH
100953: LD_VAR 0 3
100957: PPUSH
100958: LD_VAR 0 4
100962: PPUSH
100963: CALL_OW 237
// end ;
100967: PPOPN 6
100969: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
100970: LD_EXP 94
100974: PUSH
100975: LD_EXP 141
100979: AND
100980: IFFALSE 101059
100982: GO 100984
100984: DISABLE
100985: LD_INT 0
100987: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
100988: LD_ADDR_VAR 0 1
100992: PUSH
100993: LD_INT 22
100995: PUSH
100996: LD_OWVAR 2
101000: PUSH
101001: EMPTY
101002: LIST
101003: LIST
101004: PUSH
101005: LD_INT 30
101007: PUSH
101008: LD_INT 3
101010: PUSH
101011: EMPTY
101012: LIST
101013: LIST
101014: PUSH
101015: EMPTY
101016: LIST
101017: LIST
101018: PPUSH
101019: CALL_OW 69
101023: ST_TO_ADDR
// if not tmp then
101024: LD_VAR 0 1
101028: NOT
101029: IFFALSE 101033
// exit ;
101031: GO 101059
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
101033: LD_VAR 0 1
101037: PUSH
101038: LD_INT 1
101040: PPUSH
101041: LD_VAR 0 1
101045: PPUSH
101046: CALL_OW 12
101050: ARRAY
101051: PPUSH
101052: LD_INT 1
101054: PPUSH
101055: CALL_OW 234
// end ;
101059: PPOPN 1
101061: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
101062: LD_EXP 94
101066: PUSH
101067: LD_EXP 142
101071: AND
101072: IFFALSE 101184
101074: GO 101076
101076: DISABLE
101077: LD_INT 0
101079: PPUSH
101080: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
101081: LD_ADDR_VAR 0 2
101085: PUSH
101086: LD_INT 22
101088: PUSH
101089: LD_OWVAR 2
101093: PUSH
101094: EMPTY
101095: LIST
101096: LIST
101097: PUSH
101098: LD_INT 2
101100: PUSH
101101: LD_INT 30
101103: PUSH
101104: LD_INT 27
101106: PUSH
101107: EMPTY
101108: LIST
101109: LIST
101110: PUSH
101111: LD_INT 30
101113: PUSH
101114: LD_INT 26
101116: PUSH
101117: EMPTY
101118: LIST
101119: LIST
101120: PUSH
101121: LD_INT 30
101123: PUSH
101124: LD_INT 28
101126: PUSH
101127: EMPTY
101128: LIST
101129: LIST
101130: PUSH
101131: EMPTY
101132: LIST
101133: LIST
101134: LIST
101135: LIST
101136: PUSH
101137: EMPTY
101138: LIST
101139: LIST
101140: PPUSH
101141: CALL_OW 69
101145: ST_TO_ADDR
// if not tmp then
101146: LD_VAR 0 2
101150: NOT
101151: IFFALSE 101155
// exit ;
101153: GO 101184
// for i in tmp do
101155: LD_ADDR_VAR 0 1
101159: PUSH
101160: LD_VAR 0 2
101164: PUSH
101165: FOR_IN
101166: IFFALSE 101182
// SetLives ( i , 1 ) ;
101168: LD_VAR 0 1
101172: PPUSH
101173: LD_INT 1
101175: PPUSH
101176: CALL_OW 234
101180: GO 101165
101182: POP
101183: POP
// end ;
101184: PPOPN 2
101186: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
101187: LD_EXP 94
101191: PUSH
101192: LD_EXP 143
101196: AND
101197: IFFALSE 101484
101199: GO 101201
101201: DISABLE
101202: LD_INT 0
101204: PPUSH
101205: PPUSH
101206: PPUSH
// begin i := rand ( 1 , 7 ) ;
101207: LD_ADDR_VAR 0 1
101211: PUSH
101212: LD_INT 1
101214: PPUSH
101215: LD_INT 7
101217: PPUSH
101218: CALL_OW 12
101222: ST_TO_ADDR
// case i of 1 :
101223: LD_VAR 0 1
101227: PUSH
101228: LD_INT 1
101230: DOUBLE
101231: EQUAL
101232: IFTRUE 101236
101234: GO 101246
101236: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
101237: LD_STRING earthquake(getX(game), 0, 32)
101239: PPUSH
101240: CALL_OW 559
101244: GO 101484
101246: LD_INT 2
101248: DOUBLE
101249: EQUAL
101250: IFTRUE 101254
101252: GO 101268
101254: POP
// begin ToLua ( displayStucuk(); ) ;
101255: LD_STRING displayStucuk();
101257: PPUSH
101258: CALL_OW 559
// ResetFog ;
101262: CALL_OW 335
// end ; 3 :
101266: GO 101484
101268: LD_INT 3
101270: DOUBLE
101271: EQUAL
101272: IFTRUE 101276
101274: GO 101380
101276: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
101277: LD_ADDR_VAR 0 2
101281: PUSH
101282: LD_INT 22
101284: PUSH
101285: LD_OWVAR 2
101289: PUSH
101290: EMPTY
101291: LIST
101292: LIST
101293: PUSH
101294: LD_INT 25
101296: PUSH
101297: LD_INT 1
101299: PUSH
101300: EMPTY
101301: LIST
101302: LIST
101303: PUSH
101304: EMPTY
101305: LIST
101306: LIST
101307: PPUSH
101308: CALL_OW 69
101312: ST_TO_ADDR
// if not tmp then
101313: LD_VAR 0 2
101317: NOT
101318: IFFALSE 101322
// exit ;
101320: GO 101484
// un := tmp [ rand ( 1 , tmp ) ] ;
101322: LD_ADDR_VAR 0 3
101326: PUSH
101327: LD_VAR 0 2
101331: PUSH
101332: LD_INT 1
101334: PPUSH
101335: LD_VAR 0 2
101339: PPUSH
101340: CALL_OW 12
101344: ARRAY
101345: ST_TO_ADDR
// if Crawls ( un ) then
101346: LD_VAR 0 3
101350: PPUSH
101351: CALL_OW 318
101355: IFFALSE 101366
// ComWalk ( un ) ;
101357: LD_VAR 0 3
101361: PPUSH
101362: CALL_OW 138
// SetClass ( un , class_mortar ) ;
101366: LD_VAR 0 3
101370: PPUSH
101371: LD_INT 8
101373: PPUSH
101374: CALL_OW 336
// end ; 4 :
101378: GO 101484
101380: LD_INT 4
101382: DOUBLE
101383: EQUAL
101384: IFTRUE 101388
101386: GO 101462
101388: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
101389: LD_ADDR_VAR 0 2
101393: PUSH
101394: LD_INT 22
101396: PUSH
101397: LD_OWVAR 2
101401: PUSH
101402: EMPTY
101403: LIST
101404: LIST
101405: PUSH
101406: LD_INT 30
101408: PUSH
101409: LD_INT 29
101411: PUSH
101412: EMPTY
101413: LIST
101414: LIST
101415: PUSH
101416: EMPTY
101417: LIST
101418: LIST
101419: PPUSH
101420: CALL_OW 69
101424: ST_TO_ADDR
// if not tmp then
101425: LD_VAR 0 2
101429: NOT
101430: IFFALSE 101434
// exit ;
101432: GO 101484
// CenterNowOnUnits ( tmp [ 1 ] ) ;
101434: LD_VAR 0 2
101438: PUSH
101439: LD_INT 1
101441: ARRAY
101442: PPUSH
101443: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
101447: LD_VAR 0 2
101451: PUSH
101452: LD_INT 1
101454: ARRAY
101455: PPUSH
101456: CALL_OW 65
// end ; 5 .. 7 :
101460: GO 101484
101462: LD_INT 5
101464: DOUBLE
101465: GREATEREQUAL
101466: IFFALSE 101474
101468: LD_INT 7
101470: DOUBLE
101471: LESSEQUAL
101472: IFTRUE 101476
101474: GO 101483
101476: POP
// StreamSibBomb ; end ;
101477: CALL 97721 0 0
101481: GO 101484
101483: POP
// end ;
101484: PPOPN 3
101486: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
101487: LD_EXP 94
101491: PUSH
101492: LD_EXP 144
101496: AND
101497: IFFALSE 101653
101499: GO 101501
101501: DISABLE
101502: LD_INT 0
101504: PPUSH
101505: PPUSH
101506: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
101507: LD_ADDR_VAR 0 2
101511: PUSH
101512: LD_INT 81
101514: PUSH
101515: LD_OWVAR 2
101519: PUSH
101520: EMPTY
101521: LIST
101522: LIST
101523: PUSH
101524: LD_INT 2
101526: PUSH
101527: LD_INT 21
101529: PUSH
101530: LD_INT 1
101532: PUSH
101533: EMPTY
101534: LIST
101535: LIST
101536: PUSH
101537: LD_INT 21
101539: PUSH
101540: LD_INT 2
101542: PUSH
101543: EMPTY
101544: LIST
101545: LIST
101546: PUSH
101547: EMPTY
101548: LIST
101549: LIST
101550: LIST
101551: PUSH
101552: EMPTY
101553: LIST
101554: LIST
101555: PPUSH
101556: CALL_OW 69
101560: ST_TO_ADDR
// if not tmp then
101561: LD_VAR 0 2
101565: NOT
101566: IFFALSE 101570
// exit ;
101568: GO 101653
// p := 0 ;
101570: LD_ADDR_VAR 0 3
101574: PUSH
101575: LD_INT 0
101577: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
101578: LD_INT 35
101580: PPUSH
101581: CALL_OW 67
// p := p + 1 ;
101585: LD_ADDR_VAR 0 3
101589: PUSH
101590: LD_VAR 0 3
101594: PUSH
101595: LD_INT 1
101597: PLUS
101598: ST_TO_ADDR
// for i in tmp do
101599: LD_ADDR_VAR 0 1
101603: PUSH
101604: LD_VAR 0 2
101608: PUSH
101609: FOR_IN
101610: IFFALSE 101641
// if GetLives ( i ) < 1000 then
101612: LD_VAR 0 1
101616: PPUSH
101617: CALL_OW 256
101621: PUSH
101622: LD_INT 1000
101624: LESS
101625: IFFALSE 101639
// SetLives ( i , 1000 ) ;
101627: LD_VAR 0 1
101631: PPUSH
101632: LD_INT 1000
101634: PPUSH
101635: CALL_OW 234
101639: GO 101609
101641: POP
101642: POP
// until p > 20 ;
101643: LD_VAR 0 3
101647: PUSH
101648: LD_INT 20
101650: GREATER
101651: IFFALSE 101578
// end ;
101653: PPOPN 3
101655: END
// every 0 0$1 trigger StreamModeActive and sTime do
101656: LD_EXP 94
101660: PUSH
101661: LD_EXP 145
101665: AND
101666: IFFALSE 101701
101668: GO 101670
101670: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
101671: LD_INT 28
101673: PPUSH
101674: LD_OWVAR 2
101678: PPUSH
101679: LD_INT 2
101681: PPUSH
101682: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
101686: LD_INT 30
101688: PPUSH
101689: LD_OWVAR 2
101693: PPUSH
101694: LD_INT 2
101696: PPUSH
101697: CALL_OW 322
// end ;
101701: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
101702: LD_EXP 94
101706: PUSH
101707: LD_EXP 146
101711: AND
101712: IFFALSE 101833
101714: GO 101716
101716: DISABLE
101717: LD_INT 0
101719: PPUSH
101720: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
101721: LD_ADDR_VAR 0 2
101725: PUSH
101726: LD_INT 22
101728: PUSH
101729: LD_OWVAR 2
101733: PUSH
101734: EMPTY
101735: LIST
101736: LIST
101737: PUSH
101738: LD_INT 21
101740: PUSH
101741: LD_INT 1
101743: PUSH
101744: EMPTY
101745: LIST
101746: LIST
101747: PUSH
101748: LD_INT 3
101750: PUSH
101751: LD_INT 23
101753: PUSH
101754: LD_INT 0
101756: PUSH
101757: EMPTY
101758: LIST
101759: LIST
101760: PUSH
101761: EMPTY
101762: LIST
101763: LIST
101764: PUSH
101765: EMPTY
101766: LIST
101767: LIST
101768: LIST
101769: PPUSH
101770: CALL_OW 69
101774: ST_TO_ADDR
// if not tmp then
101775: LD_VAR 0 2
101779: NOT
101780: IFFALSE 101784
// exit ;
101782: GO 101833
// for i in tmp do
101784: LD_ADDR_VAR 0 1
101788: PUSH
101789: LD_VAR 0 2
101793: PUSH
101794: FOR_IN
101795: IFFALSE 101831
// begin if Crawls ( i ) then
101797: LD_VAR 0 1
101801: PPUSH
101802: CALL_OW 318
101806: IFFALSE 101817
// ComWalk ( i ) ;
101808: LD_VAR 0 1
101812: PPUSH
101813: CALL_OW 138
// SetClass ( i , 2 ) ;
101817: LD_VAR 0 1
101821: PPUSH
101822: LD_INT 2
101824: PPUSH
101825: CALL_OW 336
// end ;
101829: GO 101794
101831: POP
101832: POP
// end ;
101833: PPOPN 2
101835: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
101836: LD_EXP 94
101840: PUSH
101841: LD_EXP 147
101845: AND
101846: IFFALSE 102134
101848: GO 101850
101850: DISABLE
101851: LD_INT 0
101853: PPUSH
101854: PPUSH
101855: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
101856: LD_OWVAR 2
101860: PPUSH
101861: LD_INT 9
101863: PPUSH
101864: LD_INT 1
101866: PPUSH
101867: LD_INT 1
101869: PPUSH
101870: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
101874: LD_INT 9
101876: PPUSH
101877: LD_OWVAR 2
101881: PPUSH
101882: CALL_OW 343
// uc_side := 9 ;
101886: LD_ADDR_OWVAR 20
101890: PUSH
101891: LD_INT 9
101893: ST_TO_ADDR
// uc_nation := 2 ;
101894: LD_ADDR_OWVAR 21
101898: PUSH
101899: LD_INT 2
101901: ST_TO_ADDR
// hc_name := Dark Warrior ;
101902: LD_ADDR_OWVAR 26
101906: PUSH
101907: LD_STRING Dark Warrior
101909: ST_TO_ADDR
// hc_gallery :=  ;
101910: LD_ADDR_OWVAR 33
101914: PUSH
101915: LD_STRING 
101917: ST_TO_ADDR
// hc_noskilllimit := true ;
101918: LD_ADDR_OWVAR 76
101922: PUSH
101923: LD_INT 1
101925: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
101926: LD_ADDR_OWVAR 31
101930: PUSH
101931: LD_INT 30
101933: PUSH
101934: LD_INT 30
101936: PUSH
101937: LD_INT 30
101939: PUSH
101940: LD_INT 30
101942: PUSH
101943: EMPTY
101944: LIST
101945: LIST
101946: LIST
101947: LIST
101948: ST_TO_ADDR
// un := CreateHuman ;
101949: LD_ADDR_VAR 0 3
101953: PUSH
101954: CALL_OW 44
101958: ST_TO_ADDR
// hc_noskilllimit := false ;
101959: LD_ADDR_OWVAR 76
101963: PUSH
101964: LD_INT 0
101966: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
101967: LD_VAR 0 3
101971: PPUSH
101972: LD_INT 1
101974: PPUSH
101975: CALL_OW 51
// ToLua ( playRanger() ) ;
101979: LD_STRING playRanger()
101981: PPUSH
101982: CALL_OW 559
// p := 0 ;
101986: LD_ADDR_VAR 0 2
101990: PUSH
101991: LD_INT 0
101993: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
101994: LD_INT 35
101996: PPUSH
101997: CALL_OW 67
// p := p + 1 ;
102001: LD_ADDR_VAR 0 2
102005: PUSH
102006: LD_VAR 0 2
102010: PUSH
102011: LD_INT 1
102013: PLUS
102014: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
102015: LD_VAR 0 3
102019: PPUSH
102020: CALL_OW 256
102024: PUSH
102025: LD_INT 1000
102027: LESS
102028: IFFALSE 102042
// SetLives ( un , 1000 ) ;
102030: LD_VAR 0 3
102034: PPUSH
102035: LD_INT 1000
102037: PPUSH
102038: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
102042: LD_VAR 0 3
102046: PPUSH
102047: LD_INT 81
102049: PUSH
102050: LD_OWVAR 2
102054: PUSH
102055: EMPTY
102056: LIST
102057: LIST
102058: PUSH
102059: LD_INT 91
102061: PUSH
102062: LD_VAR 0 3
102066: PUSH
102067: LD_INT 30
102069: PUSH
102070: EMPTY
102071: LIST
102072: LIST
102073: LIST
102074: PUSH
102075: EMPTY
102076: LIST
102077: LIST
102078: PPUSH
102079: CALL_OW 69
102083: PPUSH
102084: LD_VAR 0 3
102088: PPUSH
102089: CALL_OW 74
102093: PPUSH
102094: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
102098: LD_VAR 0 2
102102: PUSH
102103: LD_INT 80
102105: GREATER
102106: PUSH
102107: LD_VAR 0 3
102111: PPUSH
102112: CALL_OW 301
102116: OR
102117: IFFALSE 101994
// if un then
102119: LD_VAR 0 3
102123: IFFALSE 102134
// RemoveUnit ( un ) ;
102125: LD_VAR 0 3
102129: PPUSH
102130: CALL_OW 64
// end ;
102134: PPOPN 3
102136: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
102137: LD_EXP 148
102141: IFFALSE 102257
102143: GO 102145
102145: DISABLE
102146: LD_INT 0
102148: PPUSH
102149: PPUSH
102150: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
102151: LD_ADDR_VAR 0 2
102155: PUSH
102156: LD_INT 81
102158: PUSH
102159: LD_OWVAR 2
102163: PUSH
102164: EMPTY
102165: LIST
102166: LIST
102167: PUSH
102168: LD_INT 21
102170: PUSH
102171: LD_INT 1
102173: PUSH
102174: EMPTY
102175: LIST
102176: LIST
102177: PUSH
102178: EMPTY
102179: LIST
102180: LIST
102181: PPUSH
102182: CALL_OW 69
102186: ST_TO_ADDR
// ToLua ( playComputer() ) ;
102187: LD_STRING playComputer()
102189: PPUSH
102190: CALL_OW 559
// if not tmp then
102194: LD_VAR 0 2
102198: NOT
102199: IFFALSE 102203
// exit ;
102201: GO 102257
// for i in tmp do
102203: LD_ADDR_VAR 0 1
102207: PUSH
102208: LD_VAR 0 2
102212: PUSH
102213: FOR_IN
102214: IFFALSE 102255
// for j := 1 to 4 do
102216: LD_ADDR_VAR 0 3
102220: PUSH
102221: DOUBLE
102222: LD_INT 1
102224: DEC
102225: ST_TO_ADDR
102226: LD_INT 4
102228: PUSH
102229: FOR_TO
102230: IFFALSE 102251
// SetSkill ( i , j , 10 ) ;
102232: LD_VAR 0 1
102236: PPUSH
102237: LD_VAR 0 3
102241: PPUSH
102242: LD_INT 10
102244: PPUSH
102245: CALL_OW 237
102249: GO 102229
102251: POP
102252: POP
102253: GO 102213
102255: POP
102256: POP
// end ;
102257: PPOPN 3
102259: END
// every 0 0$1 trigger s30 do var i , tmp ;
102260: LD_EXP 149
102264: IFFALSE 102333
102266: GO 102268
102268: DISABLE
102269: LD_INT 0
102271: PPUSH
102272: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
102273: LD_ADDR_VAR 0 2
102277: PUSH
102278: LD_INT 22
102280: PUSH
102281: LD_OWVAR 2
102285: PUSH
102286: EMPTY
102287: LIST
102288: LIST
102289: PPUSH
102290: CALL_OW 69
102294: ST_TO_ADDR
// if not tmp then
102295: LD_VAR 0 2
102299: NOT
102300: IFFALSE 102304
// exit ;
102302: GO 102333
// for i in tmp do
102304: LD_ADDR_VAR 0 1
102308: PUSH
102309: LD_VAR 0 2
102313: PUSH
102314: FOR_IN
102315: IFFALSE 102331
// SetLives ( i , 300 ) ;
102317: LD_VAR 0 1
102321: PPUSH
102322: LD_INT 300
102324: PPUSH
102325: CALL_OW 234
102329: GO 102314
102331: POP
102332: POP
// end ;
102333: PPOPN 2
102335: END
// every 0 0$1 trigger s60 do var i , tmp ;
102336: LD_EXP 150
102340: IFFALSE 102409
102342: GO 102344
102344: DISABLE
102345: LD_INT 0
102347: PPUSH
102348: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
102349: LD_ADDR_VAR 0 2
102353: PUSH
102354: LD_INT 22
102356: PUSH
102357: LD_OWVAR 2
102361: PUSH
102362: EMPTY
102363: LIST
102364: LIST
102365: PPUSH
102366: CALL_OW 69
102370: ST_TO_ADDR
// if not tmp then
102371: LD_VAR 0 2
102375: NOT
102376: IFFALSE 102380
// exit ;
102378: GO 102409
// for i in tmp do
102380: LD_ADDR_VAR 0 1
102384: PUSH
102385: LD_VAR 0 2
102389: PUSH
102390: FOR_IN
102391: IFFALSE 102407
// SetLives ( i , 600 ) ;
102393: LD_VAR 0 1
102397: PPUSH
102398: LD_INT 600
102400: PPUSH
102401: CALL_OW 234
102405: GO 102390
102407: POP
102408: POP
// end ;
102409: PPOPN 2
102411: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
102412: LD_INT 0
102414: PPUSH
// case cmd of 301 :
102415: LD_VAR 0 1
102419: PUSH
102420: LD_INT 301
102422: DOUBLE
102423: EQUAL
102424: IFTRUE 102428
102426: GO 102460
102428: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
102429: LD_VAR 0 6
102433: PPUSH
102434: LD_VAR 0 7
102438: PPUSH
102439: LD_VAR 0 8
102443: PPUSH
102444: LD_VAR 0 4
102448: PPUSH
102449: LD_VAR 0 5
102453: PPUSH
102454: CALL 103661 0 5
102458: GO 102581
102460: LD_INT 302
102462: DOUBLE
102463: EQUAL
102464: IFTRUE 102468
102466: GO 102505
102468: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
102469: LD_VAR 0 6
102473: PPUSH
102474: LD_VAR 0 7
102478: PPUSH
102479: LD_VAR 0 8
102483: PPUSH
102484: LD_VAR 0 9
102488: PPUSH
102489: LD_VAR 0 4
102493: PPUSH
102494: LD_VAR 0 5
102498: PPUSH
102499: CALL 103752 0 6
102503: GO 102581
102505: LD_INT 303
102507: DOUBLE
102508: EQUAL
102509: IFTRUE 102513
102511: GO 102550
102513: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
102514: LD_VAR 0 6
102518: PPUSH
102519: LD_VAR 0 7
102523: PPUSH
102524: LD_VAR 0 8
102528: PPUSH
102529: LD_VAR 0 9
102533: PPUSH
102534: LD_VAR 0 4
102538: PPUSH
102539: LD_VAR 0 5
102543: PPUSH
102544: CALL 102586 0 6
102548: GO 102581
102550: LD_INT 304
102552: DOUBLE
102553: EQUAL
102554: IFTRUE 102558
102556: GO 102580
102558: POP
// hHackTeleport ( unit , x , y ) ; end ;
102559: LD_VAR 0 2
102563: PPUSH
102564: LD_VAR 0 4
102568: PPUSH
102569: LD_VAR 0 5
102573: PPUSH
102574: CALL 104345 0 3
102578: GO 102581
102580: POP
// end ;
102581: LD_VAR 0 12
102585: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
102586: LD_INT 0
102588: PPUSH
102589: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
102590: LD_VAR 0 1
102594: PUSH
102595: LD_INT 1
102597: LESS
102598: PUSH
102599: LD_VAR 0 1
102603: PUSH
102604: LD_INT 3
102606: GREATER
102607: OR
102608: PUSH
102609: LD_VAR 0 5
102613: PPUSH
102614: LD_VAR 0 6
102618: PPUSH
102619: CALL_OW 428
102623: OR
102624: IFFALSE 102628
// exit ;
102626: GO 103348
// uc_side := your_side ;
102628: LD_ADDR_OWVAR 20
102632: PUSH
102633: LD_OWVAR 2
102637: ST_TO_ADDR
// uc_nation := nation ;
102638: LD_ADDR_OWVAR 21
102642: PUSH
102643: LD_VAR 0 1
102647: ST_TO_ADDR
// bc_level = 1 ;
102648: LD_ADDR_OWVAR 43
102652: PUSH
102653: LD_INT 1
102655: ST_TO_ADDR
// case btype of 1 :
102656: LD_VAR 0 2
102660: PUSH
102661: LD_INT 1
102663: DOUBLE
102664: EQUAL
102665: IFTRUE 102669
102667: GO 102680
102669: POP
// bc_type := b_depot ; 2 :
102670: LD_ADDR_OWVAR 42
102674: PUSH
102675: LD_INT 0
102677: ST_TO_ADDR
102678: GO 103292
102680: LD_INT 2
102682: DOUBLE
102683: EQUAL
102684: IFTRUE 102688
102686: GO 102699
102688: POP
// bc_type := b_warehouse ; 3 :
102689: LD_ADDR_OWVAR 42
102693: PUSH
102694: LD_INT 1
102696: ST_TO_ADDR
102697: GO 103292
102699: LD_INT 3
102701: DOUBLE
102702: EQUAL
102703: IFTRUE 102707
102705: GO 102718
102707: POP
// bc_type := b_lab ; 4 .. 9 :
102708: LD_ADDR_OWVAR 42
102712: PUSH
102713: LD_INT 6
102715: ST_TO_ADDR
102716: GO 103292
102718: LD_INT 4
102720: DOUBLE
102721: GREATEREQUAL
102722: IFFALSE 102730
102724: LD_INT 9
102726: DOUBLE
102727: LESSEQUAL
102728: IFTRUE 102732
102730: GO 102784
102732: POP
// begin bc_type := b_lab_half ;
102733: LD_ADDR_OWVAR 42
102737: PUSH
102738: LD_INT 7
102740: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
102741: LD_ADDR_OWVAR 44
102745: PUSH
102746: LD_INT 10
102748: PUSH
102749: LD_INT 11
102751: PUSH
102752: LD_INT 12
102754: PUSH
102755: LD_INT 15
102757: PUSH
102758: LD_INT 14
102760: PUSH
102761: LD_INT 13
102763: PUSH
102764: EMPTY
102765: LIST
102766: LIST
102767: LIST
102768: LIST
102769: LIST
102770: LIST
102771: PUSH
102772: LD_VAR 0 2
102776: PUSH
102777: LD_INT 3
102779: MINUS
102780: ARRAY
102781: ST_TO_ADDR
// end ; 10 .. 13 :
102782: GO 103292
102784: LD_INT 10
102786: DOUBLE
102787: GREATEREQUAL
102788: IFFALSE 102796
102790: LD_INT 13
102792: DOUBLE
102793: LESSEQUAL
102794: IFTRUE 102798
102796: GO 102875
102798: POP
// begin bc_type := b_lab_full ;
102799: LD_ADDR_OWVAR 42
102803: PUSH
102804: LD_INT 8
102806: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
102807: LD_ADDR_OWVAR 44
102811: PUSH
102812: LD_INT 10
102814: PUSH
102815: LD_INT 12
102817: PUSH
102818: LD_INT 14
102820: PUSH
102821: LD_INT 13
102823: PUSH
102824: EMPTY
102825: LIST
102826: LIST
102827: LIST
102828: LIST
102829: PUSH
102830: LD_VAR 0 2
102834: PUSH
102835: LD_INT 9
102837: MINUS
102838: ARRAY
102839: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
102840: LD_ADDR_OWVAR 45
102844: PUSH
102845: LD_INT 11
102847: PUSH
102848: LD_INT 15
102850: PUSH
102851: LD_INT 12
102853: PUSH
102854: LD_INT 15
102856: PUSH
102857: EMPTY
102858: LIST
102859: LIST
102860: LIST
102861: LIST
102862: PUSH
102863: LD_VAR 0 2
102867: PUSH
102868: LD_INT 9
102870: MINUS
102871: ARRAY
102872: ST_TO_ADDR
// end ; 14 :
102873: GO 103292
102875: LD_INT 14
102877: DOUBLE
102878: EQUAL
102879: IFTRUE 102883
102881: GO 102894
102883: POP
// bc_type := b_workshop ; 15 :
102884: LD_ADDR_OWVAR 42
102888: PUSH
102889: LD_INT 2
102891: ST_TO_ADDR
102892: GO 103292
102894: LD_INT 15
102896: DOUBLE
102897: EQUAL
102898: IFTRUE 102902
102900: GO 102913
102902: POP
// bc_type := b_factory ; 16 :
102903: LD_ADDR_OWVAR 42
102907: PUSH
102908: LD_INT 3
102910: ST_TO_ADDR
102911: GO 103292
102913: LD_INT 16
102915: DOUBLE
102916: EQUAL
102917: IFTRUE 102921
102919: GO 102932
102921: POP
// bc_type := b_ext_gun ; 17 :
102922: LD_ADDR_OWVAR 42
102926: PUSH
102927: LD_INT 17
102929: ST_TO_ADDR
102930: GO 103292
102932: LD_INT 17
102934: DOUBLE
102935: EQUAL
102936: IFTRUE 102940
102938: GO 102968
102940: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
102941: LD_ADDR_OWVAR 42
102945: PUSH
102946: LD_INT 19
102948: PUSH
102949: LD_INT 23
102951: PUSH
102952: LD_INT 19
102954: PUSH
102955: EMPTY
102956: LIST
102957: LIST
102958: LIST
102959: PUSH
102960: LD_VAR 0 1
102964: ARRAY
102965: ST_TO_ADDR
102966: GO 103292
102968: LD_INT 18
102970: DOUBLE
102971: EQUAL
102972: IFTRUE 102976
102974: GO 102987
102976: POP
// bc_type := b_ext_radar ; 19 :
102977: LD_ADDR_OWVAR 42
102981: PUSH
102982: LD_INT 20
102984: ST_TO_ADDR
102985: GO 103292
102987: LD_INT 19
102989: DOUBLE
102990: EQUAL
102991: IFTRUE 102995
102993: GO 103006
102995: POP
// bc_type := b_ext_radio ; 20 :
102996: LD_ADDR_OWVAR 42
103000: PUSH
103001: LD_INT 22
103003: ST_TO_ADDR
103004: GO 103292
103006: LD_INT 20
103008: DOUBLE
103009: EQUAL
103010: IFTRUE 103014
103012: GO 103025
103014: POP
// bc_type := b_ext_siberium ; 21 :
103015: LD_ADDR_OWVAR 42
103019: PUSH
103020: LD_INT 21
103022: ST_TO_ADDR
103023: GO 103292
103025: LD_INT 21
103027: DOUBLE
103028: EQUAL
103029: IFTRUE 103033
103031: GO 103044
103033: POP
// bc_type := b_ext_computer ; 22 :
103034: LD_ADDR_OWVAR 42
103038: PUSH
103039: LD_INT 24
103041: ST_TO_ADDR
103042: GO 103292
103044: LD_INT 22
103046: DOUBLE
103047: EQUAL
103048: IFTRUE 103052
103050: GO 103063
103052: POP
// bc_type := b_ext_track ; 23 :
103053: LD_ADDR_OWVAR 42
103057: PUSH
103058: LD_INT 16
103060: ST_TO_ADDR
103061: GO 103292
103063: LD_INT 23
103065: DOUBLE
103066: EQUAL
103067: IFTRUE 103071
103069: GO 103082
103071: POP
// bc_type := b_ext_laser ; 24 :
103072: LD_ADDR_OWVAR 42
103076: PUSH
103077: LD_INT 25
103079: ST_TO_ADDR
103080: GO 103292
103082: LD_INT 24
103084: DOUBLE
103085: EQUAL
103086: IFTRUE 103090
103088: GO 103101
103090: POP
// bc_type := b_control_tower ; 25 :
103091: LD_ADDR_OWVAR 42
103095: PUSH
103096: LD_INT 36
103098: ST_TO_ADDR
103099: GO 103292
103101: LD_INT 25
103103: DOUBLE
103104: EQUAL
103105: IFTRUE 103109
103107: GO 103120
103109: POP
// bc_type := b_breastwork ; 26 :
103110: LD_ADDR_OWVAR 42
103114: PUSH
103115: LD_INT 31
103117: ST_TO_ADDR
103118: GO 103292
103120: LD_INT 26
103122: DOUBLE
103123: EQUAL
103124: IFTRUE 103128
103126: GO 103139
103128: POP
// bc_type := b_bunker ; 27 :
103129: LD_ADDR_OWVAR 42
103133: PUSH
103134: LD_INT 32
103136: ST_TO_ADDR
103137: GO 103292
103139: LD_INT 27
103141: DOUBLE
103142: EQUAL
103143: IFTRUE 103147
103145: GO 103158
103147: POP
// bc_type := b_turret ; 28 :
103148: LD_ADDR_OWVAR 42
103152: PUSH
103153: LD_INT 33
103155: ST_TO_ADDR
103156: GO 103292
103158: LD_INT 28
103160: DOUBLE
103161: EQUAL
103162: IFTRUE 103166
103164: GO 103177
103166: POP
// bc_type := b_armoury ; 29 :
103167: LD_ADDR_OWVAR 42
103171: PUSH
103172: LD_INT 4
103174: ST_TO_ADDR
103175: GO 103292
103177: LD_INT 29
103179: DOUBLE
103180: EQUAL
103181: IFTRUE 103185
103183: GO 103196
103185: POP
// bc_type := b_barracks ; 30 :
103186: LD_ADDR_OWVAR 42
103190: PUSH
103191: LD_INT 5
103193: ST_TO_ADDR
103194: GO 103292
103196: LD_INT 30
103198: DOUBLE
103199: EQUAL
103200: IFTRUE 103204
103202: GO 103215
103204: POP
// bc_type := b_solar_power ; 31 :
103205: LD_ADDR_OWVAR 42
103209: PUSH
103210: LD_INT 27
103212: ST_TO_ADDR
103213: GO 103292
103215: LD_INT 31
103217: DOUBLE
103218: EQUAL
103219: IFTRUE 103223
103221: GO 103234
103223: POP
// bc_type := b_oil_power ; 32 :
103224: LD_ADDR_OWVAR 42
103228: PUSH
103229: LD_INT 26
103231: ST_TO_ADDR
103232: GO 103292
103234: LD_INT 32
103236: DOUBLE
103237: EQUAL
103238: IFTRUE 103242
103240: GO 103253
103242: POP
// bc_type := b_siberite_power ; 33 :
103243: LD_ADDR_OWVAR 42
103247: PUSH
103248: LD_INT 28
103250: ST_TO_ADDR
103251: GO 103292
103253: LD_INT 33
103255: DOUBLE
103256: EQUAL
103257: IFTRUE 103261
103259: GO 103272
103261: POP
// bc_type := b_oil_mine ; 34 :
103262: LD_ADDR_OWVAR 42
103266: PUSH
103267: LD_INT 29
103269: ST_TO_ADDR
103270: GO 103292
103272: LD_INT 34
103274: DOUBLE
103275: EQUAL
103276: IFTRUE 103280
103278: GO 103291
103280: POP
// bc_type := b_siberite_mine ; end ;
103281: LD_ADDR_OWVAR 42
103285: PUSH
103286: LD_INT 30
103288: ST_TO_ADDR
103289: GO 103292
103291: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
103292: LD_ADDR_VAR 0 8
103296: PUSH
103297: LD_VAR 0 5
103301: PPUSH
103302: LD_VAR 0 6
103306: PPUSH
103307: LD_VAR 0 3
103311: PPUSH
103312: CALL_OW 47
103316: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
103317: LD_OWVAR 42
103321: PUSH
103322: LD_INT 32
103324: PUSH
103325: LD_INT 33
103327: PUSH
103328: EMPTY
103329: LIST
103330: LIST
103331: IN
103332: IFFALSE 103348
// PlaceWeaponTurret ( b , weapon ) ;
103334: LD_VAR 0 8
103338: PPUSH
103339: LD_VAR 0 4
103343: PPUSH
103344: CALL_OW 431
// end ;
103348: LD_VAR 0 7
103352: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
103353: LD_INT 0
103355: PPUSH
103356: PPUSH
103357: PPUSH
103358: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
103359: LD_ADDR_VAR 0 4
103363: PUSH
103364: LD_INT 22
103366: PUSH
103367: LD_OWVAR 2
103371: PUSH
103372: EMPTY
103373: LIST
103374: LIST
103375: PUSH
103376: LD_INT 2
103378: PUSH
103379: LD_INT 30
103381: PUSH
103382: LD_INT 0
103384: PUSH
103385: EMPTY
103386: LIST
103387: LIST
103388: PUSH
103389: LD_INT 30
103391: PUSH
103392: LD_INT 1
103394: PUSH
103395: EMPTY
103396: LIST
103397: LIST
103398: PUSH
103399: EMPTY
103400: LIST
103401: LIST
103402: LIST
103403: PUSH
103404: EMPTY
103405: LIST
103406: LIST
103407: PPUSH
103408: CALL_OW 69
103412: ST_TO_ADDR
// if not tmp then
103413: LD_VAR 0 4
103417: NOT
103418: IFFALSE 103422
// exit ;
103420: GO 103481
// for i in tmp do
103422: LD_ADDR_VAR 0 2
103426: PUSH
103427: LD_VAR 0 4
103431: PUSH
103432: FOR_IN
103433: IFFALSE 103479
// for j = 1 to 3 do
103435: LD_ADDR_VAR 0 3
103439: PUSH
103440: DOUBLE
103441: LD_INT 1
103443: DEC
103444: ST_TO_ADDR
103445: LD_INT 3
103447: PUSH
103448: FOR_TO
103449: IFFALSE 103475
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
103451: LD_VAR 0 2
103455: PPUSH
103456: CALL_OW 274
103460: PPUSH
103461: LD_VAR 0 3
103465: PPUSH
103466: LD_INT 99999
103468: PPUSH
103469: CALL_OW 277
103473: GO 103448
103475: POP
103476: POP
103477: GO 103432
103479: POP
103480: POP
// end ;
103481: LD_VAR 0 1
103485: RET
// export function hHackSetLevel10 ; var i , j ; begin
103486: LD_INT 0
103488: PPUSH
103489: PPUSH
103490: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
103491: LD_ADDR_VAR 0 2
103495: PUSH
103496: LD_INT 21
103498: PUSH
103499: LD_INT 1
103501: PUSH
103502: EMPTY
103503: LIST
103504: LIST
103505: PPUSH
103506: CALL_OW 69
103510: PUSH
103511: FOR_IN
103512: IFFALSE 103564
// if IsSelected ( i ) then
103514: LD_VAR 0 2
103518: PPUSH
103519: CALL_OW 306
103523: IFFALSE 103562
// begin for j := 1 to 4 do
103525: LD_ADDR_VAR 0 3
103529: PUSH
103530: DOUBLE
103531: LD_INT 1
103533: DEC
103534: ST_TO_ADDR
103535: LD_INT 4
103537: PUSH
103538: FOR_TO
103539: IFFALSE 103560
// SetSkill ( i , j , 10 ) ;
103541: LD_VAR 0 2
103545: PPUSH
103546: LD_VAR 0 3
103550: PPUSH
103551: LD_INT 10
103553: PPUSH
103554: CALL_OW 237
103558: GO 103538
103560: POP
103561: POP
// end ;
103562: GO 103511
103564: POP
103565: POP
// end ;
103566: LD_VAR 0 1
103570: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
103571: LD_INT 0
103573: PPUSH
103574: PPUSH
103575: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
103576: LD_ADDR_VAR 0 2
103580: PUSH
103581: LD_INT 22
103583: PUSH
103584: LD_OWVAR 2
103588: PUSH
103589: EMPTY
103590: LIST
103591: LIST
103592: PUSH
103593: LD_INT 21
103595: PUSH
103596: LD_INT 1
103598: PUSH
103599: EMPTY
103600: LIST
103601: LIST
103602: PUSH
103603: EMPTY
103604: LIST
103605: LIST
103606: PPUSH
103607: CALL_OW 69
103611: PUSH
103612: FOR_IN
103613: IFFALSE 103654
// begin for j := 1 to 4 do
103615: LD_ADDR_VAR 0 3
103619: PUSH
103620: DOUBLE
103621: LD_INT 1
103623: DEC
103624: ST_TO_ADDR
103625: LD_INT 4
103627: PUSH
103628: FOR_TO
103629: IFFALSE 103650
// SetSkill ( i , j , 10 ) ;
103631: LD_VAR 0 2
103635: PPUSH
103636: LD_VAR 0 3
103640: PPUSH
103641: LD_INT 10
103643: PPUSH
103644: CALL_OW 237
103648: GO 103628
103650: POP
103651: POP
// end ;
103652: GO 103612
103654: POP
103655: POP
// end ;
103656: LD_VAR 0 1
103660: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
103661: LD_INT 0
103663: PPUSH
// uc_side := your_side ;
103664: LD_ADDR_OWVAR 20
103668: PUSH
103669: LD_OWVAR 2
103673: ST_TO_ADDR
// uc_nation := nation ;
103674: LD_ADDR_OWVAR 21
103678: PUSH
103679: LD_VAR 0 1
103683: ST_TO_ADDR
// InitHc ;
103684: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
103688: LD_INT 0
103690: PPUSH
103691: LD_VAR 0 2
103695: PPUSH
103696: LD_VAR 0 3
103700: PPUSH
103701: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
103705: LD_VAR 0 4
103709: PPUSH
103710: LD_VAR 0 5
103714: PPUSH
103715: CALL_OW 428
103719: PUSH
103720: LD_INT 0
103722: EQUAL
103723: IFFALSE 103747
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
103725: CALL_OW 44
103729: PPUSH
103730: LD_VAR 0 4
103734: PPUSH
103735: LD_VAR 0 5
103739: PPUSH
103740: LD_INT 1
103742: PPUSH
103743: CALL_OW 48
// end ;
103747: LD_VAR 0 6
103751: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
103752: LD_INT 0
103754: PPUSH
103755: PPUSH
// uc_side := your_side ;
103756: LD_ADDR_OWVAR 20
103760: PUSH
103761: LD_OWVAR 2
103765: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
103766: LD_VAR 0 1
103770: PUSH
103771: LD_INT 1
103773: PUSH
103774: LD_INT 2
103776: PUSH
103777: LD_INT 3
103779: PUSH
103780: LD_INT 4
103782: PUSH
103783: LD_INT 5
103785: PUSH
103786: EMPTY
103787: LIST
103788: LIST
103789: LIST
103790: LIST
103791: LIST
103792: IN
103793: IFFALSE 103805
// uc_nation := nation_american else
103795: LD_ADDR_OWVAR 21
103799: PUSH
103800: LD_INT 1
103802: ST_TO_ADDR
103803: GO 103848
// if chassis in [ 11 , 12 , 13 , 14 ] then
103805: LD_VAR 0 1
103809: PUSH
103810: LD_INT 11
103812: PUSH
103813: LD_INT 12
103815: PUSH
103816: LD_INT 13
103818: PUSH
103819: LD_INT 14
103821: PUSH
103822: EMPTY
103823: LIST
103824: LIST
103825: LIST
103826: LIST
103827: IN
103828: IFFALSE 103840
// uc_nation := nation_arabian else
103830: LD_ADDR_OWVAR 21
103834: PUSH
103835: LD_INT 2
103837: ST_TO_ADDR
103838: GO 103848
// uc_nation := nation_russian ;
103840: LD_ADDR_OWVAR 21
103844: PUSH
103845: LD_INT 3
103847: ST_TO_ADDR
// vc_chassis := chassis ;
103848: LD_ADDR_OWVAR 37
103852: PUSH
103853: LD_VAR 0 1
103857: ST_TO_ADDR
// vc_engine := engine ;
103858: LD_ADDR_OWVAR 39
103862: PUSH
103863: LD_VAR 0 2
103867: ST_TO_ADDR
// vc_control := control ;
103868: LD_ADDR_OWVAR 38
103872: PUSH
103873: LD_VAR 0 3
103877: ST_TO_ADDR
// vc_weapon := weapon ;
103878: LD_ADDR_OWVAR 40
103882: PUSH
103883: LD_VAR 0 4
103887: ST_TO_ADDR
// un := CreateVehicle ;
103888: LD_ADDR_VAR 0 8
103892: PUSH
103893: CALL_OW 45
103897: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
103898: LD_VAR 0 8
103902: PPUSH
103903: LD_INT 0
103905: PPUSH
103906: LD_INT 5
103908: PPUSH
103909: CALL_OW 12
103913: PPUSH
103914: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
103918: LD_VAR 0 8
103922: PPUSH
103923: LD_VAR 0 5
103927: PPUSH
103928: LD_VAR 0 6
103932: PPUSH
103933: LD_INT 1
103935: PPUSH
103936: CALL_OW 48
// end ;
103940: LD_VAR 0 7
103944: RET
// export hInvincible ; every 1 do
103945: GO 103947
103947: DISABLE
// hInvincible := [ ] ;
103948: LD_ADDR_EXP 151
103952: PUSH
103953: EMPTY
103954: ST_TO_ADDR
103955: END
// every 10 do var i ;
103956: GO 103958
103958: DISABLE
103959: LD_INT 0
103961: PPUSH
// begin enable ;
103962: ENABLE
// if not hInvincible then
103963: LD_EXP 151
103967: NOT
103968: IFFALSE 103972
// exit ;
103970: GO 104016
// for i in hInvincible do
103972: LD_ADDR_VAR 0 1
103976: PUSH
103977: LD_EXP 151
103981: PUSH
103982: FOR_IN
103983: IFFALSE 104014
// if GetLives ( i ) < 1000 then
103985: LD_VAR 0 1
103989: PPUSH
103990: CALL_OW 256
103994: PUSH
103995: LD_INT 1000
103997: LESS
103998: IFFALSE 104012
// SetLives ( i , 1000 ) ;
104000: LD_VAR 0 1
104004: PPUSH
104005: LD_INT 1000
104007: PPUSH
104008: CALL_OW 234
104012: GO 103982
104014: POP
104015: POP
// end ;
104016: PPOPN 1
104018: END
// export function hHackInvincible ; var i ; begin
104019: LD_INT 0
104021: PPUSH
104022: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
104023: LD_ADDR_VAR 0 2
104027: PUSH
104028: LD_INT 2
104030: PUSH
104031: LD_INT 21
104033: PUSH
104034: LD_INT 1
104036: PUSH
104037: EMPTY
104038: LIST
104039: LIST
104040: PUSH
104041: LD_INT 21
104043: PUSH
104044: LD_INT 2
104046: PUSH
104047: EMPTY
104048: LIST
104049: LIST
104050: PUSH
104051: EMPTY
104052: LIST
104053: LIST
104054: LIST
104055: PPUSH
104056: CALL_OW 69
104060: PUSH
104061: FOR_IN
104062: IFFALSE 104123
// if IsSelected ( i ) then
104064: LD_VAR 0 2
104068: PPUSH
104069: CALL_OW 306
104073: IFFALSE 104121
// begin if i in hInvincible then
104075: LD_VAR 0 2
104079: PUSH
104080: LD_EXP 151
104084: IN
104085: IFFALSE 104105
// hInvincible := hInvincible diff i else
104087: LD_ADDR_EXP 151
104091: PUSH
104092: LD_EXP 151
104096: PUSH
104097: LD_VAR 0 2
104101: DIFF
104102: ST_TO_ADDR
104103: GO 104121
// hInvincible := hInvincible union i ;
104105: LD_ADDR_EXP 151
104109: PUSH
104110: LD_EXP 151
104114: PUSH
104115: LD_VAR 0 2
104119: UNION
104120: ST_TO_ADDR
// end ;
104121: GO 104061
104123: POP
104124: POP
// end ;
104125: LD_VAR 0 1
104129: RET
// export function hHackInvisible ; var i , j ; begin
104130: LD_INT 0
104132: PPUSH
104133: PPUSH
104134: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
104135: LD_ADDR_VAR 0 2
104139: PUSH
104140: LD_INT 21
104142: PUSH
104143: LD_INT 1
104145: PUSH
104146: EMPTY
104147: LIST
104148: LIST
104149: PPUSH
104150: CALL_OW 69
104154: PUSH
104155: FOR_IN
104156: IFFALSE 104180
// if IsSelected ( i ) then
104158: LD_VAR 0 2
104162: PPUSH
104163: CALL_OW 306
104167: IFFALSE 104178
// ComForceInvisible ( i ) ;
104169: LD_VAR 0 2
104173: PPUSH
104174: CALL_OW 496
104178: GO 104155
104180: POP
104181: POP
// end ;
104182: LD_VAR 0 1
104186: RET
// export function hHackChangeYourSide ; begin
104187: LD_INT 0
104189: PPUSH
// if your_side = 8 then
104190: LD_OWVAR 2
104194: PUSH
104195: LD_INT 8
104197: EQUAL
104198: IFFALSE 104210
// your_side := 0 else
104200: LD_ADDR_OWVAR 2
104204: PUSH
104205: LD_INT 0
104207: ST_TO_ADDR
104208: GO 104224
// your_side := your_side + 1 ;
104210: LD_ADDR_OWVAR 2
104214: PUSH
104215: LD_OWVAR 2
104219: PUSH
104220: LD_INT 1
104222: PLUS
104223: ST_TO_ADDR
// end ;
104224: LD_VAR 0 1
104228: RET
// export function hHackChangeUnitSide ; var i , j ; begin
104229: LD_INT 0
104231: PPUSH
104232: PPUSH
104233: PPUSH
// for i in all_units do
104234: LD_ADDR_VAR 0 2
104238: PUSH
104239: LD_OWVAR 3
104243: PUSH
104244: FOR_IN
104245: IFFALSE 104323
// if IsSelected ( i ) then
104247: LD_VAR 0 2
104251: PPUSH
104252: CALL_OW 306
104256: IFFALSE 104321
// begin j := GetSide ( i ) ;
104258: LD_ADDR_VAR 0 3
104262: PUSH
104263: LD_VAR 0 2
104267: PPUSH
104268: CALL_OW 255
104272: ST_TO_ADDR
// if j = 8 then
104273: LD_VAR 0 3
104277: PUSH
104278: LD_INT 8
104280: EQUAL
104281: IFFALSE 104293
// j := 0 else
104283: LD_ADDR_VAR 0 3
104287: PUSH
104288: LD_INT 0
104290: ST_TO_ADDR
104291: GO 104307
// j := j + 1 ;
104293: LD_ADDR_VAR 0 3
104297: PUSH
104298: LD_VAR 0 3
104302: PUSH
104303: LD_INT 1
104305: PLUS
104306: ST_TO_ADDR
// SetSide ( i , j ) ;
104307: LD_VAR 0 2
104311: PPUSH
104312: LD_VAR 0 3
104316: PPUSH
104317: CALL_OW 235
// end ;
104321: GO 104244
104323: POP
104324: POP
// end ;
104325: LD_VAR 0 1
104329: RET
// export function hHackFog ; begin
104330: LD_INT 0
104332: PPUSH
// FogOff ( true ) ;
104333: LD_INT 1
104335: PPUSH
104336: CALL_OW 344
// end ;
104340: LD_VAR 0 1
104344: RET
// export function hHackTeleport ( unit , x , y ) ; begin
104345: LD_INT 0
104347: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
104348: LD_VAR 0 1
104352: PPUSH
104353: LD_VAR 0 2
104357: PPUSH
104358: LD_VAR 0 3
104362: PPUSH
104363: LD_INT 1
104365: PPUSH
104366: LD_INT 1
104368: PPUSH
104369: CALL_OW 483
// CenterOnXY ( x , y ) ;
104373: LD_VAR 0 2
104377: PPUSH
104378: LD_VAR 0 3
104382: PPUSH
104383: CALL_OW 84
// end ;
104387: LD_VAR 0 4
104391: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
104392: LD_INT 0
104394: PPUSH
104395: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
104396: LD_VAR 0 1
104400: NOT
104401: PUSH
104402: LD_VAR 0 2
104406: PPUSH
104407: LD_VAR 0 3
104411: PPUSH
104412: CALL_OW 488
104416: NOT
104417: OR
104418: PUSH
104419: LD_VAR 0 1
104423: PPUSH
104424: CALL_OW 266
104428: PUSH
104429: LD_INT 3
104431: NONEQUAL
104432: PUSH
104433: LD_VAR 0 1
104437: PPUSH
104438: CALL_OW 247
104442: PUSH
104443: LD_INT 1
104445: EQUAL
104446: NOT
104447: AND
104448: OR
104449: IFFALSE 104453
// exit ;
104451: GO 104602
// if GetType ( factory ) = unit_human then
104453: LD_VAR 0 1
104457: PPUSH
104458: CALL_OW 247
104462: PUSH
104463: LD_INT 1
104465: EQUAL
104466: IFFALSE 104483
// factory := IsInUnit ( factory ) ;
104468: LD_ADDR_VAR 0 1
104472: PUSH
104473: LD_VAR 0 1
104477: PPUSH
104478: CALL_OW 310
104482: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
104483: LD_VAR 0 1
104487: PPUSH
104488: CALL_OW 266
104492: PUSH
104493: LD_INT 3
104495: NONEQUAL
104496: IFFALSE 104500
// exit ;
104498: GO 104602
// if HexInfo ( x , y ) = factory then
104500: LD_VAR 0 2
104504: PPUSH
104505: LD_VAR 0 3
104509: PPUSH
104510: CALL_OW 428
104514: PUSH
104515: LD_VAR 0 1
104519: EQUAL
104520: IFFALSE 104547
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
104522: LD_ADDR_EXP 152
104526: PUSH
104527: LD_EXP 152
104531: PPUSH
104532: LD_VAR 0 1
104536: PPUSH
104537: LD_INT 0
104539: PPUSH
104540: CALL_OW 1
104544: ST_TO_ADDR
104545: GO 104598
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
104547: LD_ADDR_EXP 152
104551: PUSH
104552: LD_EXP 152
104556: PPUSH
104557: LD_VAR 0 1
104561: PPUSH
104562: LD_VAR 0 1
104566: PPUSH
104567: CALL_OW 255
104571: PUSH
104572: LD_VAR 0 1
104576: PUSH
104577: LD_VAR 0 2
104581: PUSH
104582: LD_VAR 0 3
104586: PUSH
104587: EMPTY
104588: LIST
104589: LIST
104590: LIST
104591: LIST
104592: PPUSH
104593: CALL_OW 1
104597: ST_TO_ADDR
// UpdateFactoryWaypoints ;
104598: CALL 104607 0 0
// end ;
104602: LD_VAR 0 4
104606: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
104607: LD_INT 0
104609: PPUSH
104610: PPUSH
104611: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
104612: LD_STRING resetFactoryWaypoint();
104614: PPUSH
104615: CALL_OW 559
// if factoryWaypoints then
104619: LD_EXP 152
104623: IFFALSE 104749
// begin list := PrepareArray ( factoryWaypoints ) ;
104625: LD_ADDR_VAR 0 3
104629: PUSH
104630: LD_EXP 152
104634: PPUSH
104635: CALL 89859 0 1
104639: ST_TO_ADDR
// for i := 1 to list do
104640: LD_ADDR_VAR 0 2
104644: PUSH
104645: DOUBLE
104646: LD_INT 1
104648: DEC
104649: ST_TO_ADDR
104650: LD_VAR 0 3
104654: PUSH
104655: FOR_TO
104656: IFFALSE 104747
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
104658: LD_STRING setFactoryWaypointXY(
104660: PUSH
104661: LD_VAR 0 3
104665: PUSH
104666: LD_VAR 0 2
104670: ARRAY
104671: PUSH
104672: LD_INT 1
104674: ARRAY
104675: STR
104676: PUSH
104677: LD_STRING ,
104679: STR
104680: PUSH
104681: LD_VAR 0 3
104685: PUSH
104686: LD_VAR 0 2
104690: ARRAY
104691: PUSH
104692: LD_INT 2
104694: ARRAY
104695: STR
104696: PUSH
104697: LD_STRING ,
104699: STR
104700: PUSH
104701: LD_VAR 0 3
104705: PUSH
104706: LD_VAR 0 2
104710: ARRAY
104711: PUSH
104712: LD_INT 3
104714: ARRAY
104715: STR
104716: PUSH
104717: LD_STRING ,
104719: STR
104720: PUSH
104721: LD_VAR 0 3
104725: PUSH
104726: LD_VAR 0 2
104730: ARRAY
104731: PUSH
104732: LD_INT 4
104734: ARRAY
104735: STR
104736: PUSH
104737: LD_STRING )
104739: STR
104740: PPUSH
104741: CALL_OW 559
104745: GO 104655
104747: POP
104748: POP
// end ; end ;
104749: LD_VAR 0 1
104753: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
104754: LD_INT 0
104756: PPUSH
// if HexInfo ( x , y ) = warehouse then
104757: LD_VAR 0 2
104761: PPUSH
104762: LD_VAR 0 3
104766: PPUSH
104767: CALL_OW 428
104771: PUSH
104772: LD_VAR 0 1
104776: EQUAL
104777: IFFALSE 104804
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
104779: LD_ADDR_EXP 153
104783: PUSH
104784: LD_EXP 153
104788: PPUSH
104789: LD_VAR 0 1
104793: PPUSH
104794: LD_INT 0
104796: PPUSH
104797: CALL_OW 1
104801: ST_TO_ADDR
104802: GO 104855
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
104804: LD_ADDR_EXP 153
104808: PUSH
104809: LD_EXP 153
104813: PPUSH
104814: LD_VAR 0 1
104818: PPUSH
104819: LD_VAR 0 1
104823: PPUSH
104824: CALL_OW 255
104828: PUSH
104829: LD_VAR 0 1
104833: PUSH
104834: LD_VAR 0 2
104838: PUSH
104839: LD_VAR 0 3
104843: PUSH
104844: EMPTY
104845: LIST
104846: LIST
104847: LIST
104848: LIST
104849: PPUSH
104850: CALL_OW 1
104854: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
104855: CALL 104864 0 0
// end ;
104859: LD_VAR 0 4
104863: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
104864: LD_INT 0
104866: PPUSH
104867: PPUSH
104868: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
104869: LD_STRING resetWarehouseGatheringPoints();
104871: PPUSH
104872: CALL_OW 559
// if warehouseGatheringPoints then
104876: LD_EXP 153
104880: IFFALSE 105006
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
104882: LD_ADDR_VAR 0 3
104886: PUSH
104887: LD_EXP 153
104891: PPUSH
104892: CALL 89859 0 1
104896: ST_TO_ADDR
// for i := 1 to list do
104897: LD_ADDR_VAR 0 2
104901: PUSH
104902: DOUBLE
104903: LD_INT 1
104905: DEC
104906: ST_TO_ADDR
104907: LD_VAR 0 3
104911: PUSH
104912: FOR_TO
104913: IFFALSE 105004
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
104915: LD_STRING setWarehouseGatheringPointXY(
104917: PUSH
104918: LD_VAR 0 3
104922: PUSH
104923: LD_VAR 0 2
104927: ARRAY
104928: PUSH
104929: LD_INT 1
104931: ARRAY
104932: STR
104933: PUSH
104934: LD_STRING ,
104936: STR
104937: PUSH
104938: LD_VAR 0 3
104942: PUSH
104943: LD_VAR 0 2
104947: ARRAY
104948: PUSH
104949: LD_INT 2
104951: ARRAY
104952: STR
104953: PUSH
104954: LD_STRING ,
104956: STR
104957: PUSH
104958: LD_VAR 0 3
104962: PUSH
104963: LD_VAR 0 2
104967: ARRAY
104968: PUSH
104969: LD_INT 3
104971: ARRAY
104972: STR
104973: PUSH
104974: LD_STRING ,
104976: STR
104977: PUSH
104978: LD_VAR 0 3
104982: PUSH
104983: LD_VAR 0 2
104987: ARRAY
104988: PUSH
104989: LD_INT 4
104991: ARRAY
104992: STR
104993: PUSH
104994: LD_STRING )
104996: STR
104997: PPUSH
104998: CALL_OW 559
105002: GO 104912
105004: POP
105005: POP
// end ; end ;
105006: LD_VAR 0 1
105010: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
105011: LD_EXP 153
105015: IFFALSE 105700
105017: GO 105019
105019: DISABLE
105020: LD_INT 0
105022: PPUSH
105023: PPUSH
105024: PPUSH
105025: PPUSH
105026: PPUSH
105027: PPUSH
105028: PPUSH
105029: PPUSH
105030: PPUSH
// begin enable ;
105031: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
105032: LD_ADDR_VAR 0 3
105036: PUSH
105037: LD_EXP 153
105041: PPUSH
105042: CALL 89859 0 1
105046: ST_TO_ADDR
// if not list then
105047: LD_VAR 0 3
105051: NOT
105052: IFFALSE 105056
// exit ;
105054: GO 105700
// for i := 1 to list do
105056: LD_ADDR_VAR 0 1
105060: PUSH
105061: DOUBLE
105062: LD_INT 1
105064: DEC
105065: ST_TO_ADDR
105066: LD_VAR 0 3
105070: PUSH
105071: FOR_TO
105072: IFFALSE 105698
// begin depot := list [ i ] [ 2 ] ;
105074: LD_ADDR_VAR 0 8
105078: PUSH
105079: LD_VAR 0 3
105083: PUSH
105084: LD_VAR 0 1
105088: ARRAY
105089: PUSH
105090: LD_INT 2
105092: ARRAY
105093: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
105094: LD_ADDR_VAR 0 5
105098: PUSH
105099: LD_VAR 0 3
105103: PUSH
105104: LD_VAR 0 1
105108: ARRAY
105109: PUSH
105110: LD_INT 1
105112: ARRAY
105113: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
105114: LD_VAR 0 8
105118: PPUSH
105119: CALL_OW 301
105123: PUSH
105124: LD_VAR 0 5
105128: PUSH
105129: LD_VAR 0 8
105133: PPUSH
105134: CALL_OW 255
105138: NONEQUAL
105139: OR
105140: IFFALSE 105169
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
105142: LD_ADDR_EXP 153
105146: PUSH
105147: LD_EXP 153
105151: PPUSH
105152: LD_VAR 0 8
105156: PPUSH
105157: LD_INT 0
105159: PPUSH
105160: CALL_OW 1
105164: ST_TO_ADDR
// exit ;
105165: POP
105166: POP
105167: GO 105700
// end ; x := list [ i ] [ 3 ] ;
105169: LD_ADDR_VAR 0 6
105173: PUSH
105174: LD_VAR 0 3
105178: PUSH
105179: LD_VAR 0 1
105183: ARRAY
105184: PUSH
105185: LD_INT 3
105187: ARRAY
105188: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
105189: LD_ADDR_VAR 0 7
105193: PUSH
105194: LD_VAR 0 3
105198: PUSH
105199: LD_VAR 0 1
105203: ARRAY
105204: PUSH
105205: LD_INT 4
105207: ARRAY
105208: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
105209: LD_ADDR_VAR 0 9
105213: PUSH
105214: LD_VAR 0 6
105218: PPUSH
105219: LD_VAR 0 7
105223: PPUSH
105224: LD_INT 16
105226: PPUSH
105227: CALL 88447 0 3
105231: ST_TO_ADDR
// if not cratesNearbyPoint then
105232: LD_VAR 0 9
105236: NOT
105237: IFFALSE 105243
// exit ;
105239: POP
105240: POP
105241: GO 105700
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
105243: LD_ADDR_VAR 0 4
105247: PUSH
105248: LD_INT 22
105250: PUSH
105251: LD_VAR 0 5
105255: PUSH
105256: EMPTY
105257: LIST
105258: LIST
105259: PUSH
105260: LD_INT 3
105262: PUSH
105263: LD_INT 60
105265: PUSH
105266: EMPTY
105267: LIST
105268: PUSH
105269: EMPTY
105270: LIST
105271: LIST
105272: PUSH
105273: LD_INT 91
105275: PUSH
105276: LD_VAR 0 8
105280: PUSH
105281: LD_INT 6
105283: PUSH
105284: EMPTY
105285: LIST
105286: LIST
105287: LIST
105288: PUSH
105289: LD_INT 2
105291: PUSH
105292: LD_INT 25
105294: PUSH
105295: LD_INT 2
105297: PUSH
105298: EMPTY
105299: LIST
105300: LIST
105301: PUSH
105302: LD_INT 25
105304: PUSH
105305: LD_INT 16
105307: PUSH
105308: EMPTY
105309: LIST
105310: LIST
105311: PUSH
105312: EMPTY
105313: LIST
105314: LIST
105315: LIST
105316: PUSH
105317: EMPTY
105318: LIST
105319: LIST
105320: LIST
105321: LIST
105322: PPUSH
105323: CALL_OW 69
105327: PUSH
105328: LD_VAR 0 8
105332: PPUSH
105333: CALL_OW 313
105337: PPUSH
105338: LD_INT 3
105340: PUSH
105341: LD_INT 60
105343: PUSH
105344: EMPTY
105345: LIST
105346: PUSH
105347: EMPTY
105348: LIST
105349: LIST
105350: PUSH
105351: LD_INT 2
105353: PUSH
105354: LD_INT 25
105356: PUSH
105357: LD_INT 2
105359: PUSH
105360: EMPTY
105361: LIST
105362: LIST
105363: PUSH
105364: LD_INT 25
105366: PUSH
105367: LD_INT 16
105369: PUSH
105370: EMPTY
105371: LIST
105372: LIST
105373: PUSH
105374: EMPTY
105375: LIST
105376: LIST
105377: LIST
105378: PUSH
105379: EMPTY
105380: LIST
105381: LIST
105382: PPUSH
105383: CALL_OW 72
105387: UNION
105388: ST_TO_ADDR
// if tmp then
105389: LD_VAR 0 4
105393: IFFALSE 105473
// begin tmp := ShrinkArray ( tmp , 3 ) ;
105395: LD_ADDR_VAR 0 4
105399: PUSH
105400: LD_VAR 0 4
105404: PPUSH
105405: LD_INT 3
105407: PPUSH
105408: CALL 86416 0 2
105412: ST_TO_ADDR
// for j in tmp do
105413: LD_ADDR_VAR 0 2
105417: PUSH
105418: LD_VAR 0 4
105422: PUSH
105423: FOR_IN
105424: IFFALSE 105467
// begin if IsInUnit ( j ) then
105426: LD_VAR 0 2
105430: PPUSH
105431: CALL_OW 310
105435: IFFALSE 105446
// ComExit ( j ) ;
105437: LD_VAR 0 2
105441: PPUSH
105442: CALL 86499 0 1
// AddComCollect ( j , x , y ) ;
105446: LD_VAR 0 2
105450: PPUSH
105451: LD_VAR 0 6
105455: PPUSH
105456: LD_VAR 0 7
105460: PPUSH
105461: CALL_OW 177
// end ;
105465: GO 105423
105467: POP
105468: POP
// exit ;
105469: POP
105470: POP
105471: GO 105700
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
105473: LD_ADDR_VAR 0 4
105477: PUSH
105478: LD_INT 22
105480: PUSH
105481: LD_VAR 0 5
105485: PUSH
105486: EMPTY
105487: LIST
105488: LIST
105489: PUSH
105490: LD_INT 91
105492: PUSH
105493: LD_VAR 0 8
105497: PUSH
105498: LD_INT 8
105500: PUSH
105501: EMPTY
105502: LIST
105503: LIST
105504: LIST
105505: PUSH
105506: LD_INT 2
105508: PUSH
105509: LD_INT 34
105511: PUSH
105512: LD_INT 12
105514: PUSH
105515: EMPTY
105516: LIST
105517: LIST
105518: PUSH
105519: LD_INT 34
105521: PUSH
105522: LD_INT 51
105524: PUSH
105525: EMPTY
105526: LIST
105527: LIST
105528: PUSH
105529: LD_INT 34
105531: PUSH
105532: LD_INT 32
105534: PUSH
105535: EMPTY
105536: LIST
105537: LIST
105538: PUSH
105539: LD_INT 34
105541: PUSH
105542: LD_INT 89
105544: PUSH
105545: EMPTY
105546: LIST
105547: LIST
105548: PUSH
105549: EMPTY
105550: LIST
105551: LIST
105552: LIST
105553: LIST
105554: LIST
105555: PUSH
105556: EMPTY
105557: LIST
105558: LIST
105559: LIST
105560: PPUSH
105561: CALL_OW 69
105565: ST_TO_ADDR
// if tmp then
105566: LD_VAR 0 4
105570: IFFALSE 105696
// begin for j in tmp do
105572: LD_ADDR_VAR 0 2
105576: PUSH
105577: LD_VAR 0 4
105581: PUSH
105582: FOR_IN
105583: IFFALSE 105694
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
105585: LD_VAR 0 2
105589: PPUSH
105590: CALL_OW 262
105594: PUSH
105595: LD_INT 3
105597: EQUAL
105598: PUSH
105599: LD_VAR 0 2
105603: PPUSH
105604: CALL_OW 261
105608: PUSH
105609: LD_INT 20
105611: GREATER
105612: OR
105613: PUSH
105614: LD_VAR 0 2
105618: PPUSH
105619: CALL_OW 314
105623: NOT
105624: AND
105625: PUSH
105626: LD_VAR 0 2
105630: PPUSH
105631: CALL_OW 263
105635: PUSH
105636: LD_INT 1
105638: NONEQUAL
105639: PUSH
105640: LD_VAR 0 2
105644: PPUSH
105645: CALL_OW 311
105649: OR
105650: AND
105651: IFFALSE 105692
// begin ComCollect ( j , x , y ) ;
105653: LD_VAR 0 2
105657: PPUSH
105658: LD_VAR 0 6
105662: PPUSH
105663: LD_VAR 0 7
105667: PPUSH
105668: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
105672: LD_VAR 0 2
105676: PPUSH
105677: LD_VAR 0 8
105681: PPUSH
105682: CALL_OW 172
// exit ;
105686: POP
105687: POP
105688: POP
105689: POP
105690: GO 105700
// end ;
105692: GO 105582
105694: POP
105695: POP
// end ; end ;
105696: GO 105071
105698: POP
105699: POP
// end ; end_of_file
105700: PPOPN 9
105702: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
105703: LD_INT 0
105705: PPUSH
105706: PPUSH
105707: PPUSH
105708: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
105709: LD_VAR 0 1
105713: PPUSH
105714: CALL_OW 264
105718: PUSH
105719: LD_INT 91
105721: EQUAL
105722: IFFALSE 105794
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
105724: LD_INT 68
105726: PPUSH
105727: LD_VAR 0 1
105731: PPUSH
105732: CALL_OW 255
105736: PPUSH
105737: CALL_OW 321
105741: PUSH
105742: LD_INT 2
105744: EQUAL
105745: IFFALSE 105757
// eff := 70 else
105747: LD_ADDR_VAR 0 4
105751: PUSH
105752: LD_INT 70
105754: ST_TO_ADDR
105755: GO 105765
// eff := 30 ;
105757: LD_ADDR_VAR 0 4
105761: PUSH
105762: LD_INT 30
105764: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
105765: LD_VAR 0 1
105769: PPUSH
105770: CALL_OW 250
105774: PPUSH
105775: LD_VAR 0 1
105779: PPUSH
105780: CALL_OW 251
105784: PPUSH
105785: LD_VAR 0 4
105789: PPUSH
105790: CALL_OW 495
// end ; end ;
105794: LD_VAR 0 2
105798: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
105799: LD_INT 0
105801: PPUSH
// end ;
105802: LD_VAR 0 4
105806: RET
// export function SOS_Command ( cmd ) ; begin
105807: LD_INT 0
105809: PPUSH
// end ;
105810: LD_VAR 0 2
105814: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
105815: LD_INT 0
105817: PPUSH
// end ;
105818: LD_VAR 0 6
105822: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
105823: LD_INT 0
105825: PPUSH
105826: PPUSH
// if not vehicle or not factory then
105827: LD_VAR 0 1
105831: NOT
105832: PUSH
105833: LD_VAR 0 2
105837: NOT
105838: OR
105839: IFFALSE 105843
// exit ;
105841: GO 106074
// if factoryWaypoints >= factory then
105843: LD_EXP 152
105847: PUSH
105848: LD_VAR 0 2
105852: GREATEREQUAL
105853: IFFALSE 106074
// if factoryWaypoints [ factory ] then
105855: LD_EXP 152
105859: PUSH
105860: LD_VAR 0 2
105864: ARRAY
105865: IFFALSE 106074
// begin if GetControl ( vehicle ) = control_manual then
105867: LD_VAR 0 1
105871: PPUSH
105872: CALL_OW 263
105876: PUSH
105877: LD_INT 1
105879: EQUAL
105880: IFFALSE 105961
// begin driver := IsDrivenBy ( vehicle ) ;
105882: LD_ADDR_VAR 0 4
105886: PUSH
105887: LD_VAR 0 1
105891: PPUSH
105892: CALL_OW 311
105896: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
105897: LD_VAR 0 4
105901: PPUSH
105902: LD_EXP 152
105906: PUSH
105907: LD_VAR 0 2
105911: ARRAY
105912: PUSH
105913: LD_INT 3
105915: ARRAY
105916: PPUSH
105917: LD_EXP 152
105921: PUSH
105922: LD_VAR 0 2
105926: ARRAY
105927: PUSH
105928: LD_INT 4
105930: ARRAY
105931: PPUSH
105932: CALL_OW 171
// AddComExitVehicle ( driver ) ;
105936: LD_VAR 0 4
105940: PPUSH
105941: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
105945: LD_VAR 0 4
105949: PPUSH
105950: LD_VAR 0 2
105954: PPUSH
105955: CALL_OW 180
// end else
105959: GO 106074
// if GetControl ( vehicle ) = control_remote then
105961: LD_VAR 0 1
105965: PPUSH
105966: CALL_OW 263
105970: PUSH
105971: LD_INT 2
105973: EQUAL
105974: IFFALSE 106035
// begin wait ( 0 0$2 ) ;
105976: LD_INT 70
105978: PPUSH
105979: CALL_OW 67
// if Connect ( vehicle ) then
105983: LD_VAR 0 1
105987: PPUSH
105988: CALL 56758 0 1
105992: IFFALSE 106033
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
105994: LD_VAR 0 1
105998: PPUSH
105999: LD_EXP 152
106003: PUSH
106004: LD_VAR 0 2
106008: ARRAY
106009: PUSH
106010: LD_INT 3
106012: ARRAY
106013: PPUSH
106014: LD_EXP 152
106018: PUSH
106019: LD_VAR 0 2
106023: ARRAY
106024: PUSH
106025: LD_INT 4
106027: ARRAY
106028: PPUSH
106029: CALL_OW 171
// end else
106033: GO 106074
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
106035: LD_VAR 0 1
106039: PPUSH
106040: LD_EXP 152
106044: PUSH
106045: LD_VAR 0 2
106049: ARRAY
106050: PUSH
106051: LD_INT 3
106053: ARRAY
106054: PPUSH
106055: LD_EXP 152
106059: PUSH
106060: LD_VAR 0 2
106064: ARRAY
106065: PUSH
106066: LD_INT 4
106068: ARRAY
106069: PPUSH
106070: CALL_OW 171
// end ; end ;
106074: LD_VAR 0 3
106078: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
106079: LD_INT 0
106081: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
106082: LD_VAR 0 1
106086: PUSH
106087: LD_INT 250
106089: EQUAL
106090: PUSH
106091: LD_VAR 0 2
106095: PPUSH
106096: CALL_OW 264
106100: PUSH
106101: LD_INT 81
106103: EQUAL
106104: AND
106105: IFFALSE 106126
// MinerPlaceMine ( unit , x , y ) ;
106107: LD_VAR 0 2
106111: PPUSH
106112: LD_VAR 0 4
106116: PPUSH
106117: LD_VAR 0 5
106121: PPUSH
106122: CALL 108511 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
106126: LD_VAR 0 1
106130: PUSH
106131: LD_INT 251
106133: EQUAL
106134: PUSH
106135: LD_VAR 0 2
106139: PPUSH
106140: CALL_OW 264
106144: PUSH
106145: LD_INT 81
106147: EQUAL
106148: AND
106149: IFFALSE 106170
// MinerDetonateMine ( unit , x , y ) ;
106151: LD_VAR 0 2
106155: PPUSH
106156: LD_VAR 0 4
106160: PPUSH
106161: LD_VAR 0 5
106165: PPUSH
106166: CALL 108786 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
106170: LD_VAR 0 1
106174: PUSH
106175: LD_INT 252
106177: EQUAL
106178: PUSH
106179: LD_VAR 0 2
106183: PPUSH
106184: CALL_OW 264
106188: PUSH
106189: LD_INT 81
106191: EQUAL
106192: AND
106193: IFFALSE 106214
// MinerCreateMinefield ( unit , x , y ) ;
106195: LD_VAR 0 2
106199: PPUSH
106200: LD_VAR 0 4
106204: PPUSH
106205: LD_VAR 0 5
106209: PPUSH
106210: CALL 109203 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
106214: LD_VAR 0 1
106218: PUSH
106219: LD_INT 253
106221: EQUAL
106222: PUSH
106223: LD_VAR 0 2
106227: PPUSH
106228: CALL_OW 257
106232: PUSH
106233: LD_INT 5
106235: EQUAL
106236: AND
106237: IFFALSE 106258
// ComBinocular ( unit , x , y ) ;
106239: LD_VAR 0 2
106243: PPUSH
106244: LD_VAR 0 4
106248: PPUSH
106249: LD_VAR 0 5
106253: PPUSH
106254: CALL 109572 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
106258: LD_VAR 0 1
106262: PUSH
106263: LD_INT 254
106265: EQUAL
106266: PUSH
106267: LD_VAR 0 2
106271: PPUSH
106272: CALL_OW 264
106276: PUSH
106277: LD_INT 99
106279: EQUAL
106280: AND
106281: PUSH
106282: LD_VAR 0 3
106286: PPUSH
106287: CALL_OW 263
106291: PUSH
106292: LD_INT 3
106294: EQUAL
106295: AND
106296: IFFALSE 106312
// HackDestroyVehicle ( unit , selectedUnit ) ;
106298: LD_VAR 0 2
106302: PPUSH
106303: LD_VAR 0 3
106307: PPUSH
106308: CALL 107875 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
106312: LD_VAR 0 1
106316: PUSH
106317: LD_INT 255
106319: EQUAL
106320: PUSH
106321: LD_VAR 0 2
106325: PPUSH
106326: CALL_OW 264
106330: PUSH
106331: LD_INT 14
106333: PUSH
106334: LD_INT 53
106336: PUSH
106337: EMPTY
106338: LIST
106339: LIST
106340: IN
106341: AND
106342: PUSH
106343: LD_VAR 0 4
106347: PPUSH
106348: LD_VAR 0 5
106352: PPUSH
106353: CALL_OW 488
106357: AND
106358: IFFALSE 106382
// CutTreeXYR ( unit , x , y , 12 ) ;
106360: LD_VAR 0 2
106364: PPUSH
106365: LD_VAR 0 4
106369: PPUSH
106370: LD_VAR 0 5
106374: PPUSH
106375: LD_INT 12
106377: PPUSH
106378: CALL 106445 0 4
// if cmd = 256 then
106382: LD_VAR 0 1
106386: PUSH
106387: LD_INT 256
106389: EQUAL
106390: IFFALSE 106411
// SetFactoryWaypoint ( unit , x , y ) ;
106392: LD_VAR 0 2
106396: PPUSH
106397: LD_VAR 0 4
106401: PPUSH
106402: LD_VAR 0 5
106406: PPUSH
106407: CALL 104392 0 3
// if cmd = 257 then
106411: LD_VAR 0 1
106415: PUSH
106416: LD_INT 257
106418: EQUAL
106419: IFFALSE 106440
// SetWarehouseGatheringPoint ( unit , x , y ) ;
106421: LD_VAR 0 2
106425: PPUSH
106426: LD_VAR 0 4
106430: PPUSH
106431: LD_VAR 0 5
106435: PPUSH
106436: CALL 104754 0 3
// end ;
106440: LD_VAR 0 6
106444: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
106445: LD_INT 0
106447: PPUSH
106448: PPUSH
106449: PPUSH
106450: PPUSH
106451: PPUSH
106452: PPUSH
106453: PPUSH
106454: PPUSH
106455: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
106456: LD_VAR 0 1
106460: NOT
106461: PUSH
106462: LD_VAR 0 2
106466: PPUSH
106467: LD_VAR 0 3
106471: PPUSH
106472: CALL_OW 488
106476: NOT
106477: OR
106478: PUSH
106479: LD_VAR 0 4
106483: NOT
106484: OR
106485: IFFALSE 106489
// exit ;
106487: GO 106829
// list := [ ] ;
106489: LD_ADDR_VAR 0 13
106493: PUSH
106494: EMPTY
106495: ST_TO_ADDR
// if x - r < 0 then
106496: LD_VAR 0 2
106500: PUSH
106501: LD_VAR 0 4
106505: MINUS
106506: PUSH
106507: LD_INT 0
106509: LESS
106510: IFFALSE 106522
// min_x := 0 else
106512: LD_ADDR_VAR 0 7
106516: PUSH
106517: LD_INT 0
106519: ST_TO_ADDR
106520: GO 106538
// min_x := x - r ;
106522: LD_ADDR_VAR 0 7
106526: PUSH
106527: LD_VAR 0 2
106531: PUSH
106532: LD_VAR 0 4
106536: MINUS
106537: ST_TO_ADDR
// if y - r < 0 then
106538: LD_VAR 0 3
106542: PUSH
106543: LD_VAR 0 4
106547: MINUS
106548: PUSH
106549: LD_INT 0
106551: LESS
106552: IFFALSE 106564
// min_y := 0 else
106554: LD_ADDR_VAR 0 8
106558: PUSH
106559: LD_INT 0
106561: ST_TO_ADDR
106562: GO 106580
// min_y := y - r ;
106564: LD_ADDR_VAR 0 8
106568: PUSH
106569: LD_VAR 0 3
106573: PUSH
106574: LD_VAR 0 4
106578: MINUS
106579: ST_TO_ADDR
// max_x := x + r ;
106580: LD_ADDR_VAR 0 9
106584: PUSH
106585: LD_VAR 0 2
106589: PUSH
106590: LD_VAR 0 4
106594: PLUS
106595: ST_TO_ADDR
// max_y := y + r ;
106596: LD_ADDR_VAR 0 10
106600: PUSH
106601: LD_VAR 0 3
106605: PUSH
106606: LD_VAR 0 4
106610: PLUS
106611: ST_TO_ADDR
// for _x = min_x to max_x do
106612: LD_ADDR_VAR 0 11
106616: PUSH
106617: DOUBLE
106618: LD_VAR 0 7
106622: DEC
106623: ST_TO_ADDR
106624: LD_VAR 0 9
106628: PUSH
106629: FOR_TO
106630: IFFALSE 106747
// for _y = min_y to max_y do
106632: LD_ADDR_VAR 0 12
106636: PUSH
106637: DOUBLE
106638: LD_VAR 0 8
106642: DEC
106643: ST_TO_ADDR
106644: LD_VAR 0 10
106648: PUSH
106649: FOR_TO
106650: IFFALSE 106743
// begin if not ValidHex ( _x , _y ) then
106652: LD_VAR 0 11
106656: PPUSH
106657: LD_VAR 0 12
106661: PPUSH
106662: CALL_OW 488
106666: NOT
106667: IFFALSE 106671
// continue ;
106669: GO 106649
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
106671: LD_VAR 0 11
106675: PPUSH
106676: LD_VAR 0 12
106680: PPUSH
106681: CALL_OW 351
106685: PUSH
106686: LD_VAR 0 11
106690: PPUSH
106691: LD_VAR 0 12
106695: PPUSH
106696: CALL_OW 554
106700: AND
106701: IFFALSE 106741
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
106703: LD_ADDR_VAR 0 13
106707: PUSH
106708: LD_VAR 0 13
106712: PPUSH
106713: LD_VAR 0 13
106717: PUSH
106718: LD_INT 1
106720: PLUS
106721: PPUSH
106722: LD_VAR 0 11
106726: PUSH
106727: LD_VAR 0 12
106731: PUSH
106732: EMPTY
106733: LIST
106734: LIST
106735: PPUSH
106736: CALL_OW 2
106740: ST_TO_ADDR
// end ;
106741: GO 106649
106743: POP
106744: POP
106745: GO 106629
106747: POP
106748: POP
// if not list then
106749: LD_VAR 0 13
106753: NOT
106754: IFFALSE 106758
// exit ;
106756: GO 106829
// for i in list do
106758: LD_ADDR_VAR 0 6
106762: PUSH
106763: LD_VAR 0 13
106767: PUSH
106768: FOR_IN
106769: IFFALSE 106827
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
106771: LD_VAR 0 1
106775: PPUSH
106776: LD_STRING M
106778: PUSH
106779: LD_VAR 0 6
106783: PUSH
106784: LD_INT 1
106786: ARRAY
106787: PUSH
106788: LD_VAR 0 6
106792: PUSH
106793: LD_INT 2
106795: ARRAY
106796: PUSH
106797: LD_INT 0
106799: PUSH
106800: LD_INT 0
106802: PUSH
106803: LD_INT 0
106805: PUSH
106806: LD_INT 0
106808: PUSH
106809: EMPTY
106810: LIST
106811: LIST
106812: LIST
106813: LIST
106814: LIST
106815: LIST
106816: LIST
106817: PUSH
106818: EMPTY
106819: LIST
106820: PPUSH
106821: CALL_OW 447
106825: GO 106768
106827: POP
106828: POP
// end ;
106829: LD_VAR 0 5
106833: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
106834: LD_EXP 155
106838: NOT
106839: IFFALSE 106889
106841: GO 106843
106843: DISABLE
// begin initHack := true ;
106844: LD_ADDR_EXP 155
106848: PUSH
106849: LD_INT 1
106851: ST_TO_ADDR
// hackTanks := [ ] ;
106852: LD_ADDR_EXP 156
106856: PUSH
106857: EMPTY
106858: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
106859: LD_ADDR_EXP 157
106863: PUSH
106864: EMPTY
106865: ST_TO_ADDR
// hackLimit := 3 ;
106866: LD_ADDR_EXP 158
106870: PUSH
106871: LD_INT 3
106873: ST_TO_ADDR
// hackDist := 12 ;
106874: LD_ADDR_EXP 159
106878: PUSH
106879: LD_INT 12
106881: ST_TO_ADDR
// hackCounter := [ ] ;
106882: LD_ADDR_EXP 160
106886: PUSH
106887: EMPTY
106888: ST_TO_ADDR
// end ;
106889: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
106890: LD_EXP 155
106894: PUSH
106895: LD_INT 34
106897: PUSH
106898: LD_INT 99
106900: PUSH
106901: EMPTY
106902: LIST
106903: LIST
106904: PPUSH
106905: CALL_OW 69
106909: AND
106910: IFFALSE 107163
106912: GO 106914
106914: DISABLE
106915: LD_INT 0
106917: PPUSH
106918: PPUSH
// begin enable ;
106919: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
106920: LD_ADDR_VAR 0 1
106924: PUSH
106925: LD_INT 34
106927: PUSH
106928: LD_INT 99
106930: PUSH
106931: EMPTY
106932: LIST
106933: LIST
106934: PPUSH
106935: CALL_OW 69
106939: PUSH
106940: FOR_IN
106941: IFFALSE 107161
// begin if not i in hackTanks then
106943: LD_VAR 0 1
106947: PUSH
106948: LD_EXP 156
106952: IN
106953: NOT
106954: IFFALSE 107037
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
106956: LD_ADDR_EXP 156
106960: PUSH
106961: LD_EXP 156
106965: PPUSH
106966: LD_EXP 156
106970: PUSH
106971: LD_INT 1
106973: PLUS
106974: PPUSH
106975: LD_VAR 0 1
106979: PPUSH
106980: CALL_OW 1
106984: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
106985: LD_ADDR_EXP 157
106989: PUSH
106990: LD_EXP 157
106994: PPUSH
106995: LD_EXP 157
106999: PUSH
107000: LD_INT 1
107002: PLUS
107003: PPUSH
107004: EMPTY
107005: PPUSH
107006: CALL_OW 1
107010: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
107011: LD_ADDR_EXP 160
107015: PUSH
107016: LD_EXP 160
107020: PPUSH
107021: LD_EXP 160
107025: PUSH
107026: LD_INT 1
107028: PLUS
107029: PPUSH
107030: EMPTY
107031: PPUSH
107032: CALL_OW 1
107036: ST_TO_ADDR
// end ; if not IsOk ( i ) then
107037: LD_VAR 0 1
107041: PPUSH
107042: CALL_OW 302
107046: NOT
107047: IFFALSE 107060
// begin HackUnlinkAll ( i ) ;
107049: LD_VAR 0 1
107053: PPUSH
107054: CALL 107166 0 1
// continue ;
107058: GO 106940
// end ; HackCheckCapturedStatus ( i ) ;
107060: LD_VAR 0 1
107064: PPUSH
107065: CALL 107609 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
107069: LD_ADDR_VAR 0 2
107073: PUSH
107074: LD_INT 81
107076: PUSH
107077: LD_VAR 0 1
107081: PPUSH
107082: CALL_OW 255
107086: PUSH
107087: EMPTY
107088: LIST
107089: LIST
107090: PUSH
107091: LD_INT 33
107093: PUSH
107094: LD_INT 3
107096: PUSH
107097: EMPTY
107098: LIST
107099: LIST
107100: PUSH
107101: LD_INT 91
107103: PUSH
107104: LD_VAR 0 1
107108: PUSH
107109: LD_EXP 159
107113: PUSH
107114: EMPTY
107115: LIST
107116: LIST
107117: LIST
107118: PUSH
107119: LD_INT 50
107121: PUSH
107122: EMPTY
107123: LIST
107124: PUSH
107125: EMPTY
107126: LIST
107127: LIST
107128: LIST
107129: LIST
107130: PPUSH
107131: CALL_OW 69
107135: ST_TO_ADDR
// if not tmp then
107136: LD_VAR 0 2
107140: NOT
107141: IFFALSE 107145
// continue ;
107143: GO 106940
// HackLink ( i , tmp ) ;
107145: LD_VAR 0 1
107149: PPUSH
107150: LD_VAR 0 2
107154: PPUSH
107155: CALL 107302 0 2
// end ;
107159: GO 106940
107161: POP
107162: POP
// end ;
107163: PPOPN 2
107165: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
107166: LD_INT 0
107168: PPUSH
107169: PPUSH
107170: PPUSH
// if not hack in hackTanks then
107171: LD_VAR 0 1
107175: PUSH
107176: LD_EXP 156
107180: IN
107181: NOT
107182: IFFALSE 107186
// exit ;
107184: GO 107297
// index := GetElementIndex ( hackTanks , hack ) ;
107186: LD_ADDR_VAR 0 4
107190: PUSH
107191: LD_EXP 156
107195: PPUSH
107196: LD_VAR 0 1
107200: PPUSH
107201: CALL 53574 0 2
107205: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
107206: LD_EXP 157
107210: PUSH
107211: LD_VAR 0 4
107215: ARRAY
107216: IFFALSE 107297
// begin for i in hackTanksCaptured [ index ] do
107218: LD_ADDR_VAR 0 3
107222: PUSH
107223: LD_EXP 157
107227: PUSH
107228: LD_VAR 0 4
107232: ARRAY
107233: PUSH
107234: FOR_IN
107235: IFFALSE 107261
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
107237: LD_VAR 0 3
107241: PUSH
107242: LD_INT 1
107244: ARRAY
107245: PPUSH
107246: LD_VAR 0 3
107250: PUSH
107251: LD_INT 2
107253: ARRAY
107254: PPUSH
107255: CALL_OW 235
107259: GO 107234
107261: POP
107262: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
107263: LD_ADDR_EXP 157
107267: PUSH
107268: LD_EXP 157
107272: PPUSH
107273: LD_VAR 0 4
107277: PPUSH
107278: EMPTY
107279: PPUSH
107280: CALL_OW 1
107284: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
107285: LD_VAR 0 1
107289: PPUSH
107290: LD_INT 0
107292: PPUSH
107293: CALL_OW 505
// end ; end ;
107297: LD_VAR 0 2
107301: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
107302: LD_INT 0
107304: PPUSH
107305: PPUSH
107306: PPUSH
// if not hack in hackTanks or not vehicles then
107307: LD_VAR 0 1
107311: PUSH
107312: LD_EXP 156
107316: IN
107317: NOT
107318: PUSH
107319: LD_VAR 0 2
107323: NOT
107324: OR
107325: IFFALSE 107329
// exit ;
107327: GO 107604
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
107329: LD_ADDR_VAR 0 2
107333: PUSH
107334: LD_VAR 0 1
107338: PPUSH
107339: LD_VAR 0 2
107343: PPUSH
107344: LD_INT 1
107346: PPUSH
107347: LD_INT 1
107349: PPUSH
107350: CALL 54224 0 4
107354: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
107355: LD_ADDR_VAR 0 5
107359: PUSH
107360: LD_EXP 156
107364: PPUSH
107365: LD_VAR 0 1
107369: PPUSH
107370: CALL 53574 0 2
107374: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
107375: LD_EXP 157
107379: PUSH
107380: LD_VAR 0 5
107384: ARRAY
107385: PUSH
107386: LD_EXP 158
107390: LESS
107391: IFFALSE 107580
// begin for i := 1 to vehicles do
107393: LD_ADDR_VAR 0 4
107397: PUSH
107398: DOUBLE
107399: LD_INT 1
107401: DEC
107402: ST_TO_ADDR
107403: LD_VAR 0 2
107407: PUSH
107408: FOR_TO
107409: IFFALSE 107578
// begin if hackTanksCaptured [ index ] = hackLimit then
107411: LD_EXP 157
107415: PUSH
107416: LD_VAR 0 5
107420: ARRAY
107421: PUSH
107422: LD_EXP 158
107426: EQUAL
107427: IFFALSE 107431
// break ;
107429: GO 107578
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
107431: LD_ADDR_EXP 160
107435: PUSH
107436: LD_EXP 160
107440: PPUSH
107441: LD_VAR 0 5
107445: PPUSH
107446: LD_EXP 160
107450: PUSH
107451: LD_VAR 0 5
107455: ARRAY
107456: PUSH
107457: LD_INT 1
107459: PLUS
107460: PPUSH
107461: CALL_OW 1
107465: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
107466: LD_ADDR_EXP 157
107470: PUSH
107471: LD_EXP 157
107475: PPUSH
107476: LD_VAR 0 5
107480: PUSH
107481: LD_EXP 157
107485: PUSH
107486: LD_VAR 0 5
107490: ARRAY
107491: PUSH
107492: LD_INT 1
107494: PLUS
107495: PUSH
107496: EMPTY
107497: LIST
107498: LIST
107499: PPUSH
107500: LD_VAR 0 2
107504: PUSH
107505: LD_VAR 0 4
107509: ARRAY
107510: PUSH
107511: LD_VAR 0 2
107515: PUSH
107516: LD_VAR 0 4
107520: ARRAY
107521: PPUSH
107522: CALL_OW 255
107526: PUSH
107527: EMPTY
107528: LIST
107529: LIST
107530: PPUSH
107531: CALL 53789 0 3
107535: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
107536: LD_VAR 0 2
107540: PUSH
107541: LD_VAR 0 4
107545: ARRAY
107546: PPUSH
107547: LD_VAR 0 1
107551: PPUSH
107552: CALL_OW 255
107556: PPUSH
107557: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
107561: LD_VAR 0 2
107565: PUSH
107566: LD_VAR 0 4
107570: ARRAY
107571: PPUSH
107572: CALL_OW 141
// end ;
107576: GO 107408
107578: POP
107579: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
107580: LD_VAR 0 1
107584: PPUSH
107585: LD_EXP 157
107589: PUSH
107590: LD_VAR 0 5
107594: ARRAY
107595: PUSH
107596: LD_INT 0
107598: PLUS
107599: PPUSH
107600: CALL_OW 505
// end ;
107604: LD_VAR 0 3
107608: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
107609: LD_INT 0
107611: PPUSH
107612: PPUSH
107613: PPUSH
107614: PPUSH
// if not hack in hackTanks then
107615: LD_VAR 0 1
107619: PUSH
107620: LD_EXP 156
107624: IN
107625: NOT
107626: IFFALSE 107630
// exit ;
107628: GO 107870
// index := GetElementIndex ( hackTanks , hack ) ;
107630: LD_ADDR_VAR 0 4
107634: PUSH
107635: LD_EXP 156
107639: PPUSH
107640: LD_VAR 0 1
107644: PPUSH
107645: CALL 53574 0 2
107649: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
107650: LD_ADDR_VAR 0 3
107654: PUSH
107655: DOUBLE
107656: LD_EXP 157
107660: PUSH
107661: LD_VAR 0 4
107665: ARRAY
107666: INC
107667: ST_TO_ADDR
107668: LD_INT 1
107670: PUSH
107671: FOR_DOWNTO
107672: IFFALSE 107844
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
107674: LD_ADDR_VAR 0 5
107678: PUSH
107679: LD_EXP 157
107683: PUSH
107684: LD_VAR 0 4
107688: ARRAY
107689: PUSH
107690: LD_VAR 0 3
107694: ARRAY
107695: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
107696: LD_VAR 0 5
107700: PUSH
107701: LD_INT 1
107703: ARRAY
107704: PPUSH
107705: CALL_OW 302
107709: NOT
107710: PUSH
107711: LD_VAR 0 5
107715: PUSH
107716: LD_INT 1
107718: ARRAY
107719: PPUSH
107720: CALL_OW 255
107724: PUSH
107725: LD_VAR 0 1
107729: PPUSH
107730: CALL_OW 255
107734: NONEQUAL
107735: OR
107736: IFFALSE 107842
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
107738: LD_VAR 0 5
107742: PUSH
107743: LD_INT 1
107745: ARRAY
107746: PPUSH
107747: CALL_OW 305
107751: PUSH
107752: LD_VAR 0 5
107756: PUSH
107757: LD_INT 1
107759: ARRAY
107760: PPUSH
107761: CALL_OW 255
107765: PUSH
107766: LD_VAR 0 1
107770: PPUSH
107771: CALL_OW 255
107775: EQUAL
107776: AND
107777: IFFALSE 107801
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
107779: LD_VAR 0 5
107783: PUSH
107784: LD_INT 1
107786: ARRAY
107787: PPUSH
107788: LD_VAR 0 5
107792: PUSH
107793: LD_INT 2
107795: ARRAY
107796: PPUSH
107797: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
107801: LD_ADDR_EXP 157
107805: PUSH
107806: LD_EXP 157
107810: PPUSH
107811: LD_VAR 0 4
107815: PPUSH
107816: LD_EXP 157
107820: PUSH
107821: LD_VAR 0 4
107825: ARRAY
107826: PPUSH
107827: LD_VAR 0 3
107831: PPUSH
107832: CALL_OW 3
107836: PPUSH
107837: CALL_OW 1
107841: ST_TO_ADDR
// end ; end ;
107842: GO 107671
107844: POP
107845: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
107846: LD_VAR 0 1
107850: PPUSH
107851: LD_EXP 157
107855: PUSH
107856: LD_VAR 0 4
107860: ARRAY
107861: PUSH
107862: LD_INT 0
107864: PLUS
107865: PPUSH
107866: CALL_OW 505
// end ;
107870: LD_VAR 0 2
107874: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
107875: LD_INT 0
107877: PPUSH
107878: PPUSH
107879: PPUSH
107880: PPUSH
// if not hack in hackTanks then
107881: LD_VAR 0 1
107885: PUSH
107886: LD_EXP 156
107890: IN
107891: NOT
107892: IFFALSE 107896
// exit ;
107894: GO 107981
// index := GetElementIndex ( hackTanks , hack ) ;
107896: LD_ADDR_VAR 0 5
107900: PUSH
107901: LD_EXP 156
107905: PPUSH
107906: LD_VAR 0 1
107910: PPUSH
107911: CALL 53574 0 2
107915: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
107916: LD_ADDR_VAR 0 4
107920: PUSH
107921: DOUBLE
107922: LD_INT 1
107924: DEC
107925: ST_TO_ADDR
107926: LD_EXP 157
107930: PUSH
107931: LD_VAR 0 5
107935: ARRAY
107936: PUSH
107937: FOR_TO
107938: IFFALSE 107979
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
107940: LD_EXP 157
107944: PUSH
107945: LD_VAR 0 5
107949: ARRAY
107950: PUSH
107951: LD_VAR 0 4
107955: ARRAY
107956: PUSH
107957: LD_INT 1
107959: ARRAY
107960: PUSH
107961: LD_VAR 0 2
107965: EQUAL
107966: IFFALSE 107977
// KillUnit ( vehicle ) ;
107968: LD_VAR 0 2
107972: PPUSH
107973: CALL_OW 66
107977: GO 107937
107979: POP
107980: POP
// end ;
107981: LD_VAR 0 3
107985: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
107986: LD_EXP 161
107990: NOT
107991: IFFALSE 108026
107993: GO 107995
107995: DISABLE
// begin initMiner := true ;
107996: LD_ADDR_EXP 161
108000: PUSH
108001: LD_INT 1
108003: ST_TO_ADDR
// minersList := [ ] ;
108004: LD_ADDR_EXP 162
108008: PUSH
108009: EMPTY
108010: ST_TO_ADDR
// minerMinesList := [ ] ;
108011: LD_ADDR_EXP 163
108015: PUSH
108016: EMPTY
108017: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
108018: LD_ADDR_EXP 164
108022: PUSH
108023: LD_INT 5
108025: ST_TO_ADDR
// end ;
108026: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
108027: LD_EXP 161
108031: PUSH
108032: LD_INT 34
108034: PUSH
108035: LD_INT 81
108037: PUSH
108038: EMPTY
108039: LIST
108040: LIST
108041: PPUSH
108042: CALL_OW 69
108046: AND
108047: IFFALSE 108508
108049: GO 108051
108051: DISABLE
108052: LD_INT 0
108054: PPUSH
108055: PPUSH
108056: PPUSH
108057: PPUSH
// begin enable ;
108058: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
108059: LD_ADDR_VAR 0 1
108063: PUSH
108064: LD_INT 34
108066: PUSH
108067: LD_INT 81
108069: PUSH
108070: EMPTY
108071: LIST
108072: LIST
108073: PPUSH
108074: CALL_OW 69
108078: PUSH
108079: FOR_IN
108080: IFFALSE 108152
// begin if not i in minersList then
108082: LD_VAR 0 1
108086: PUSH
108087: LD_EXP 162
108091: IN
108092: NOT
108093: IFFALSE 108150
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
108095: LD_ADDR_EXP 162
108099: PUSH
108100: LD_EXP 162
108104: PPUSH
108105: LD_EXP 162
108109: PUSH
108110: LD_INT 1
108112: PLUS
108113: PPUSH
108114: LD_VAR 0 1
108118: PPUSH
108119: CALL_OW 1
108123: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
108124: LD_ADDR_EXP 163
108128: PUSH
108129: LD_EXP 163
108133: PPUSH
108134: LD_EXP 163
108138: PUSH
108139: LD_INT 1
108141: PLUS
108142: PPUSH
108143: EMPTY
108144: PPUSH
108145: CALL_OW 1
108149: ST_TO_ADDR
// end end ;
108150: GO 108079
108152: POP
108153: POP
// for i := minerMinesList downto 1 do
108154: LD_ADDR_VAR 0 1
108158: PUSH
108159: DOUBLE
108160: LD_EXP 163
108164: INC
108165: ST_TO_ADDR
108166: LD_INT 1
108168: PUSH
108169: FOR_DOWNTO
108170: IFFALSE 108506
// begin if IsLive ( minersList [ i ] ) then
108172: LD_EXP 162
108176: PUSH
108177: LD_VAR 0 1
108181: ARRAY
108182: PPUSH
108183: CALL_OW 300
108187: IFFALSE 108215
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
108189: LD_EXP 162
108193: PUSH
108194: LD_VAR 0 1
108198: ARRAY
108199: PPUSH
108200: LD_EXP 163
108204: PUSH
108205: LD_VAR 0 1
108209: ARRAY
108210: PPUSH
108211: CALL_OW 505
// if not minerMinesList [ i ] then
108215: LD_EXP 163
108219: PUSH
108220: LD_VAR 0 1
108224: ARRAY
108225: NOT
108226: IFFALSE 108230
// continue ;
108228: GO 108169
// for j := minerMinesList [ i ] downto 1 do
108230: LD_ADDR_VAR 0 2
108234: PUSH
108235: DOUBLE
108236: LD_EXP 163
108240: PUSH
108241: LD_VAR 0 1
108245: ARRAY
108246: INC
108247: ST_TO_ADDR
108248: LD_INT 1
108250: PUSH
108251: FOR_DOWNTO
108252: IFFALSE 108502
// begin side := GetSide ( minersList [ i ] ) ;
108254: LD_ADDR_VAR 0 3
108258: PUSH
108259: LD_EXP 162
108263: PUSH
108264: LD_VAR 0 1
108268: ARRAY
108269: PPUSH
108270: CALL_OW 255
108274: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
108275: LD_ADDR_VAR 0 4
108279: PUSH
108280: LD_EXP 163
108284: PUSH
108285: LD_VAR 0 1
108289: ARRAY
108290: PUSH
108291: LD_VAR 0 2
108295: ARRAY
108296: PUSH
108297: LD_INT 1
108299: ARRAY
108300: PPUSH
108301: LD_EXP 163
108305: PUSH
108306: LD_VAR 0 1
108310: ARRAY
108311: PUSH
108312: LD_VAR 0 2
108316: ARRAY
108317: PUSH
108318: LD_INT 2
108320: ARRAY
108321: PPUSH
108322: CALL_OW 428
108326: ST_TO_ADDR
// if not tmp then
108327: LD_VAR 0 4
108331: NOT
108332: IFFALSE 108336
// continue ;
108334: GO 108251
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
108336: LD_VAR 0 4
108340: PUSH
108341: LD_INT 81
108343: PUSH
108344: LD_VAR 0 3
108348: PUSH
108349: EMPTY
108350: LIST
108351: LIST
108352: PPUSH
108353: CALL_OW 69
108357: IN
108358: PUSH
108359: LD_EXP 163
108363: PUSH
108364: LD_VAR 0 1
108368: ARRAY
108369: PUSH
108370: LD_VAR 0 2
108374: ARRAY
108375: PUSH
108376: LD_INT 1
108378: ARRAY
108379: PPUSH
108380: LD_EXP 163
108384: PUSH
108385: LD_VAR 0 1
108389: ARRAY
108390: PUSH
108391: LD_VAR 0 2
108395: ARRAY
108396: PUSH
108397: LD_INT 2
108399: ARRAY
108400: PPUSH
108401: CALL_OW 458
108405: AND
108406: IFFALSE 108500
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
108408: LD_EXP 163
108412: PUSH
108413: LD_VAR 0 1
108417: ARRAY
108418: PUSH
108419: LD_VAR 0 2
108423: ARRAY
108424: PUSH
108425: LD_INT 1
108427: ARRAY
108428: PPUSH
108429: LD_EXP 163
108433: PUSH
108434: LD_VAR 0 1
108438: ARRAY
108439: PUSH
108440: LD_VAR 0 2
108444: ARRAY
108445: PUSH
108446: LD_INT 2
108448: ARRAY
108449: PPUSH
108450: LD_VAR 0 3
108454: PPUSH
108455: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
108459: LD_ADDR_EXP 163
108463: PUSH
108464: LD_EXP 163
108468: PPUSH
108469: LD_VAR 0 1
108473: PPUSH
108474: LD_EXP 163
108478: PUSH
108479: LD_VAR 0 1
108483: ARRAY
108484: PPUSH
108485: LD_VAR 0 2
108489: PPUSH
108490: CALL_OW 3
108494: PPUSH
108495: CALL_OW 1
108499: ST_TO_ADDR
// end ; end ;
108500: GO 108251
108502: POP
108503: POP
// end ;
108504: GO 108169
108506: POP
108507: POP
// end ;
108508: PPOPN 4
108510: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
108511: LD_INT 0
108513: PPUSH
108514: PPUSH
// result := false ;
108515: LD_ADDR_VAR 0 4
108519: PUSH
108520: LD_INT 0
108522: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
108523: LD_VAR 0 1
108527: PPUSH
108528: CALL_OW 264
108532: PUSH
108533: LD_INT 81
108535: EQUAL
108536: NOT
108537: IFFALSE 108541
// exit ;
108539: GO 108781
// index := GetElementIndex ( minersList , unit ) ;
108541: LD_ADDR_VAR 0 5
108545: PUSH
108546: LD_EXP 162
108550: PPUSH
108551: LD_VAR 0 1
108555: PPUSH
108556: CALL 53574 0 2
108560: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
108561: LD_EXP 163
108565: PUSH
108566: LD_VAR 0 5
108570: ARRAY
108571: PUSH
108572: LD_EXP 164
108576: GREATEREQUAL
108577: IFFALSE 108581
// exit ;
108579: GO 108781
// ComMoveXY ( unit , x , y ) ;
108581: LD_VAR 0 1
108585: PPUSH
108586: LD_VAR 0 2
108590: PPUSH
108591: LD_VAR 0 3
108595: PPUSH
108596: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
108600: LD_INT 35
108602: PPUSH
108603: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
108607: LD_VAR 0 1
108611: PPUSH
108612: LD_VAR 0 2
108616: PPUSH
108617: LD_VAR 0 3
108621: PPUSH
108622: CALL 84910 0 3
108626: NOT
108627: PUSH
108628: LD_VAR 0 1
108632: PPUSH
108633: CALL_OW 314
108637: AND
108638: IFFALSE 108642
// exit ;
108640: GO 108781
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
108642: LD_VAR 0 2
108646: PPUSH
108647: LD_VAR 0 3
108651: PPUSH
108652: CALL_OW 428
108656: PUSH
108657: LD_VAR 0 1
108661: EQUAL
108662: PUSH
108663: LD_VAR 0 1
108667: PPUSH
108668: CALL_OW 314
108672: NOT
108673: AND
108674: IFFALSE 108600
// PlaySoundXY ( x , y , PlantMine ) ;
108676: LD_VAR 0 2
108680: PPUSH
108681: LD_VAR 0 3
108685: PPUSH
108686: LD_STRING PlantMine
108688: PPUSH
108689: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
108693: LD_VAR 0 2
108697: PPUSH
108698: LD_VAR 0 3
108702: PPUSH
108703: LD_VAR 0 1
108707: PPUSH
108708: CALL_OW 255
108712: PPUSH
108713: LD_INT 0
108715: PPUSH
108716: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
108720: LD_ADDR_EXP 163
108724: PUSH
108725: LD_EXP 163
108729: PPUSH
108730: LD_VAR 0 5
108734: PUSH
108735: LD_EXP 163
108739: PUSH
108740: LD_VAR 0 5
108744: ARRAY
108745: PUSH
108746: LD_INT 1
108748: PLUS
108749: PUSH
108750: EMPTY
108751: LIST
108752: LIST
108753: PPUSH
108754: LD_VAR 0 2
108758: PUSH
108759: LD_VAR 0 3
108763: PUSH
108764: EMPTY
108765: LIST
108766: LIST
108767: PPUSH
108768: CALL 53789 0 3
108772: ST_TO_ADDR
// result := true ;
108773: LD_ADDR_VAR 0 4
108777: PUSH
108778: LD_INT 1
108780: ST_TO_ADDR
// end ;
108781: LD_VAR 0 4
108785: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
108786: LD_INT 0
108788: PPUSH
108789: PPUSH
108790: PPUSH
// if not unit in minersList then
108791: LD_VAR 0 1
108795: PUSH
108796: LD_EXP 162
108800: IN
108801: NOT
108802: IFFALSE 108806
// exit ;
108804: GO 109198
// index := GetElementIndex ( minersList , unit ) ;
108806: LD_ADDR_VAR 0 6
108810: PUSH
108811: LD_EXP 162
108815: PPUSH
108816: LD_VAR 0 1
108820: PPUSH
108821: CALL 53574 0 2
108825: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
108826: LD_ADDR_VAR 0 5
108830: PUSH
108831: DOUBLE
108832: LD_EXP 163
108836: PUSH
108837: LD_VAR 0 6
108841: ARRAY
108842: INC
108843: ST_TO_ADDR
108844: LD_INT 1
108846: PUSH
108847: FOR_DOWNTO
108848: IFFALSE 109009
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
108850: LD_EXP 163
108854: PUSH
108855: LD_VAR 0 6
108859: ARRAY
108860: PUSH
108861: LD_VAR 0 5
108865: ARRAY
108866: PUSH
108867: LD_INT 1
108869: ARRAY
108870: PUSH
108871: LD_VAR 0 2
108875: EQUAL
108876: PUSH
108877: LD_EXP 163
108881: PUSH
108882: LD_VAR 0 6
108886: ARRAY
108887: PUSH
108888: LD_VAR 0 5
108892: ARRAY
108893: PUSH
108894: LD_INT 2
108896: ARRAY
108897: PUSH
108898: LD_VAR 0 3
108902: EQUAL
108903: AND
108904: IFFALSE 109007
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
108906: LD_EXP 163
108910: PUSH
108911: LD_VAR 0 6
108915: ARRAY
108916: PUSH
108917: LD_VAR 0 5
108921: ARRAY
108922: PUSH
108923: LD_INT 1
108925: ARRAY
108926: PPUSH
108927: LD_EXP 163
108931: PUSH
108932: LD_VAR 0 6
108936: ARRAY
108937: PUSH
108938: LD_VAR 0 5
108942: ARRAY
108943: PUSH
108944: LD_INT 2
108946: ARRAY
108947: PPUSH
108948: LD_VAR 0 1
108952: PPUSH
108953: CALL_OW 255
108957: PPUSH
108958: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
108962: LD_ADDR_EXP 163
108966: PUSH
108967: LD_EXP 163
108971: PPUSH
108972: LD_VAR 0 6
108976: PPUSH
108977: LD_EXP 163
108981: PUSH
108982: LD_VAR 0 6
108986: ARRAY
108987: PPUSH
108988: LD_VAR 0 5
108992: PPUSH
108993: CALL_OW 3
108997: PPUSH
108998: CALL_OW 1
109002: ST_TO_ADDR
// exit ;
109003: POP
109004: POP
109005: GO 109198
// end ; end ;
109007: GO 108847
109009: POP
109010: POP
// for i := minerMinesList [ index ] downto 1 do
109011: LD_ADDR_VAR 0 5
109015: PUSH
109016: DOUBLE
109017: LD_EXP 163
109021: PUSH
109022: LD_VAR 0 6
109026: ARRAY
109027: INC
109028: ST_TO_ADDR
109029: LD_INT 1
109031: PUSH
109032: FOR_DOWNTO
109033: IFFALSE 109196
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
109035: LD_EXP 163
109039: PUSH
109040: LD_VAR 0 6
109044: ARRAY
109045: PUSH
109046: LD_VAR 0 5
109050: ARRAY
109051: PUSH
109052: LD_INT 1
109054: ARRAY
109055: PPUSH
109056: LD_EXP 163
109060: PUSH
109061: LD_VAR 0 6
109065: ARRAY
109066: PUSH
109067: LD_VAR 0 5
109071: ARRAY
109072: PUSH
109073: LD_INT 2
109075: ARRAY
109076: PPUSH
109077: LD_VAR 0 2
109081: PPUSH
109082: LD_VAR 0 3
109086: PPUSH
109087: CALL_OW 298
109091: PUSH
109092: LD_INT 6
109094: LESS
109095: IFFALSE 109194
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
109097: LD_EXP 163
109101: PUSH
109102: LD_VAR 0 6
109106: ARRAY
109107: PUSH
109108: LD_VAR 0 5
109112: ARRAY
109113: PUSH
109114: LD_INT 1
109116: ARRAY
109117: PPUSH
109118: LD_EXP 163
109122: PUSH
109123: LD_VAR 0 6
109127: ARRAY
109128: PUSH
109129: LD_VAR 0 5
109133: ARRAY
109134: PUSH
109135: LD_INT 2
109137: ARRAY
109138: PPUSH
109139: LD_VAR 0 1
109143: PPUSH
109144: CALL_OW 255
109148: PPUSH
109149: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
109153: LD_ADDR_EXP 163
109157: PUSH
109158: LD_EXP 163
109162: PPUSH
109163: LD_VAR 0 6
109167: PPUSH
109168: LD_EXP 163
109172: PUSH
109173: LD_VAR 0 6
109177: ARRAY
109178: PPUSH
109179: LD_VAR 0 5
109183: PPUSH
109184: CALL_OW 3
109188: PPUSH
109189: CALL_OW 1
109193: ST_TO_ADDR
// end ; end ;
109194: GO 109032
109196: POP
109197: POP
// end ;
109198: LD_VAR 0 4
109202: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
109203: LD_INT 0
109205: PPUSH
109206: PPUSH
109207: PPUSH
109208: PPUSH
109209: PPUSH
109210: PPUSH
109211: PPUSH
109212: PPUSH
109213: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
109214: LD_VAR 0 1
109218: PPUSH
109219: CALL_OW 264
109223: PUSH
109224: LD_INT 81
109226: EQUAL
109227: NOT
109228: PUSH
109229: LD_VAR 0 1
109233: PUSH
109234: LD_EXP 162
109238: IN
109239: NOT
109240: OR
109241: IFFALSE 109245
// exit ;
109243: GO 109567
// index := GetElementIndex ( minersList , unit ) ;
109245: LD_ADDR_VAR 0 6
109249: PUSH
109250: LD_EXP 162
109254: PPUSH
109255: LD_VAR 0 1
109259: PPUSH
109260: CALL 53574 0 2
109264: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
109265: LD_ADDR_VAR 0 8
109269: PUSH
109270: LD_EXP 164
109274: PUSH
109275: LD_EXP 163
109279: PUSH
109280: LD_VAR 0 6
109284: ARRAY
109285: MINUS
109286: ST_TO_ADDR
// if not minesFreeAmount then
109287: LD_VAR 0 8
109291: NOT
109292: IFFALSE 109296
// exit ;
109294: GO 109567
// tmp := [ ] ;
109296: LD_ADDR_VAR 0 7
109300: PUSH
109301: EMPTY
109302: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
109303: LD_ADDR_VAR 0 5
109307: PUSH
109308: DOUBLE
109309: LD_INT 1
109311: DEC
109312: ST_TO_ADDR
109313: LD_VAR 0 8
109317: PUSH
109318: FOR_TO
109319: IFFALSE 109514
// begin _d := rand ( 0 , 5 ) ;
109321: LD_ADDR_VAR 0 11
109325: PUSH
109326: LD_INT 0
109328: PPUSH
109329: LD_INT 5
109331: PPUSH
109332: CALL_OW 12
109336: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
109337: LD_ADDR_VAR 0 12
109341: PUSH
109342: LD_INT 2
109344: PPUSH
109345: LD_INT 6
109347: PPUSH
109348: CALL_OW 12
109352: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
109353: LD_ADDR_VAR 0 9
109357: PUSH
109358: LD_VAR 0 2
109362: PPUSH
109363: LD_VAR 0 11
109367: PPUSH
109368: LD_VAR 0 12
109372: PPUSH
109373: CALL_OW 272
109377: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
109378: LD_ADDR_VAR 0 10
109382: PUSH
109383: LD_VAR 0 3
109387: PPUSH
109388: LD_VAR 0 11
109392: PPUSH
109393: LD_VAR 0 12
109397: PPUSH
109398: CALL_OW 273
109402: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
109403: LD_VAR 0 9
109407: PPUSH
109408: LD_VAR 0 10
109412: PPUSH
109413: CALL_OW 488
109417: PUSH
109418: LD_VAR 0 9
109422: PUSH
109423: LD_VAR 0 10
109427: PUSH
109428: EMPTY
109429: LIST
109430: LIST
109431: PUSH
109432: LD_VAR 0 7
109436: IN
109437: NOT
109438: AND
109439: PUSH
109440: LD_VAR 0 9
109444: PPUSH
109445: LD_VAR 0 10
109449: PPUSH
109450: CALL_OW 458
109454: NOT
109455: AND
109456: IFFALSE 109498
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
109458: LD_ADDR_VAR 0 7
109462: PUSH
109463: LD_VAR 0 7
109467: PPUSH
109468: LD_VAR 0 7
109472: PUSH
109473: LD_INT 1
109475: PLUS
109476: PPUSH
109477: LD_VAR 0 9
109481: PUSH
109482: LD_VAR 0 10
109486: PUSH
109487: EMPTY
109488: LIST
109489: LIST
109490: PPUSH
109491: CALL_OW 1
109495: ST_TO_ADDR
109496: GO 109512
// i := i - 1 ;
109498: LD_ADDR_VAR 0 5
109502: PUSH
109503: LD_VAR 0 5
109507: PUSH
109508: LD_INT 1
109510: MINUS
109511: ST_TO_ADDR
// end ;
109512: GO 109318
109514: POP
109515: POP
// for i in tmp do
109516: LD_ADDR_VAR 0 5
109520: PUSH
109521: LD_VAR 0 7
109525: PUSH
109526: FOR_IN
109527: IFFALSE 109565
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
109529: LD_VAR 0 1
109533: PPUSH
109534: LD_VAR 0 5
109538: PUSH
109539: LD_INT 1
109541: ARRAY
109542: PPUSH
109543: LD_VAR 0 5
109547: PUSH
109548: LD_INT 2
109550: ARRAY
109551: PPUSH
109552: CALL 108511 0 3
109556: NOT
109557: IFFALSE 109563
// exit ;
109559: POP
109560: POP
109561: GO 109567
109563: GO 109526
109565: POP
109566: POP
// end ;
109567: LD_VAR 0 4
109571: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
109572: LD_INT 0
109574: PPUSH
109575: PPUSH
109576: PPUSH
109577: PPUSH
109578: PPUSH
109579: PPUSH
109580: PPUSH
// if not GetClass ( unit ) = class_sniper then
109581: LD_VAR 0 1
109585: PPUSH
109586: CALL_OW 257
109590: PUSH
109591: LD_INT 5
109593: EQUAL
109594: NOT
109595: IFFALSE 109599
// exit ;
109597: GO 109987
// dist := 8 ;
109599: LD_ADDR_VAR 0 5
109603: PUSH
109604: LD_INT 8
109606: ST_TO_ADDR
// viewRange := 12 ;
109607: LD_ADDR_VAR 0 7
109611: PUSH
109612: LD_INT 12
109614: ST_TO_ADDR
// side := GetSide ( unit ) ;
109615: LD_ADDR_VAR 0 6
109619: PUSH
109620: LD_VAR 0 1
109624: PPUSH
109625: CALL_OW 255
109629: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
109630: LD_INT 61
109632: PPUSH
109633: LD_VAR 0 6
109637: PPUSH
109638: CALL_OW 321
109642: PUSH
109643: LD_INT 2
109645: EQUAL
109646: IFFALSE 109656
// viewRange := 16 ;
109648: LD_ADDR_VAR 0 7
109652: PUSH
109653: LD_INT 16
109655: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
109656: LD_VAR 0 1
109660: PPUSH
109661: LD_VAR 0 2
109665: PPUSH
109666: LD_VAR 0 3
109670: PPUSH
109671: CALL_OW 297
109675: PUSH
109676: LD_VAR 0 5
109680: GREATER
109681: IFFALSE 109760
// begin ComMoveXY ( unit , x , y ) ;
109683: LD_VAR 0 1
109687: PPUSH
109688: LD_VAR 0 2
109692: PPUSH
109693: LD_VAR 0 3
109697: PPUSH
109698: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
109702: LD_INT 35
109704: PPUSH
109705: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
109709: LD_VAR 0 1
109713: PPUSH
109714: LD_VAR 0 2
109718: PPUSH
109719: LD_VAR 0 3
109723: PPUSH
109724: CALL 84910 0 3
109728: NOT
109729: IFFALSE 109733
// exit ;
109731: GO 109987
// until GetDistUnitXY ( unit , x , y ) < dist ;
109733: LD_VAR 0 1
109737: PPUSH
109738: LD_VAR 0 2
109742: PPUSH
109743: LD_VAR 0 3
109747: PPUSH
109748: CALL_OW 297
109752: PUSH
109753: LD_VAR 0 5
109757: LESS
109758: IFFALSE 109702
// end ; ComTurnXY ( unit , x , y ) ;
109760: LD_VAR 0 1
109764: PPUSH
109765: LD_VAR 0 2
109769: PPUSH
109770: LD_VAR 0 3
109774: PPUSH
109775: CALL_OW 118
// wait ( 5 ) ;
109779: LD_INT 5
109781: PPUSH
109782: CALL_OW 67
// _d := GetDir ( unit ) ;
109786: LD_ADDR_VAR 0 10
109790: PUSH
109791: LD_VAR 0 1
109795: PPUSH
109796: CALL_OW 254
109800: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
109801: LD_ADDR_VAR 0 8
109805: PUSH
109806: LD_VAR 0 1
109810: PPUSH
109811: CALL_OW 250
109815: PPUSH
109816: LD_VAR 0 10
109820: PPUSH
109821: LD_VAR 0 5
109825: PPUSH
109826: CALL_OW 272
109830: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
109831: LD_ADDR_VAR 0 9
109835: PUSH
109836: LD_VAR 0 1
109840: PPUSH
109841: CALL_OW 251
109845: PPUSH
109846: LD_VAR 0 10
109850: PPUSH
109851: LD_VAR 0 5
109855: PPUSH
109856: CALL_OW 273
109860: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
109861: LD_VAR 0 8
109865: PPUSH
109866: LD_VAR 0 9
109870: PPUSH
109871: CALL_OW 488
109875: NOT
109876: IFFALSE 109880
// exit ;
109878: GO 109987
// ComAnimCustom ( unit , 1 ) ;
109880: LD_VAR 0 1
109884: PPUSH
109885: LD_INT 1
109887: PPUSH
109888: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
109892: LD_VAR 0 8
109896: PPUSH
109897: LD_VAR 0 9
109901: PPUSH
109902: LD_VAR 0 6
109906: PPUSH
109907: LD_VAR 0 7
109911: PPUSH
109912: CALL_OW 330
// repeat wait ( 1 ) ;
109916: LD_INT 1
109918: PPUSH
109919: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
109923: LD_VAR 0 1
109927: PPUSH
109928: CALL_OW 316
109932: PUSH
109933: LD_VAR 0 1
109937: PPUSH
109938: CALL_OW 314
109942: OR
109943: PUSH
109944: LD_VAR 0 1
109948: PPUSH
109949: CALL_OW 302
109953: NOT
109954: OR
109955: PUSH
109956: LD_VAR 0 1
109960: PPUSH
109961: CALL_OW 301
109965: OR
109966: IFFALSE 109916
// RemoveSeeing ( _x , _y , side ) ;
109968: LD_VAR 0 8
109972: PPUSH
109973: LD_VAR 0 9
109977: PPUSH
109978: LD_VAR 0 6
109982: PPUSH
109983: CALL_OW 331
// end ; end_of_file
109987: LD_VAR 0 4
109991: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
109992: LD_INT 0
109994: PPUSH
109995: PPUSH
109996: PPUSH
109997: PPUSH
109998: PPUSH
109999: PPUSH
110000: PPUSH
110001: PPUSH
110002: PPUSH
110003: PPUSH
110004: PPUSH
110005: PPUSH
110006: PPUSH
110007: PPUSH
110008: PPUSH
110009: PPUSH
110010: PPUSH
110011: PPUSH
110012: PPUSH
110013: PPUSH
110014: PPUSH
110015: PPUSH
110016: PPUSH
110017: PPUSH
110018: PPUSH
110019: PPUSH
110020: PPUSH
110021: PPUSH
110022: PPUSH
110023: PPUSH
110024: PPUSH
110025: PPUSH
110026: PPUSH
110027: PPUSH
// if not list then
110028: LD_VAR 0 1
110032: NOT
110033: IFFALSE 110037
// exit ;
110035: GO 114696
// base := list [ 1 ] ;
110037: LD_ADDR_VAR 0 3
110041: PUSH
110042: LD_VAR 0 1
110046: PUSH
110047: LD_INT 1
110049: ARRAY
110050: ST_TO_ADDR
// group := list [ 2 ] ;
110051: LD_ADDR_VAR 0 4
110055: PUSH
110056: LD_VAR 0 1
110060: PUSH
110061: LD_INT 2
110063: ARRAY
110064: ST_TO_ADDR
// path := list [ 3 ] ;
110065: LD_ADDR_VAR 0 5
110069: PUSH
110070: LD_VAR 0 1
110074: PUSH
110075: LD_INT 3
110077: ARRAY
110078: ST_TO_ADDR
// flags := list [ 4 ] ;
110079: LD_ADDR_VAR 0 6
110083: PUSH
110084: LD_VAR 0 1
110088: PUSH
110089: LD_INT 4
110091: ARRAY
110092: ST_TO_ADDR
// mined := [ ] ;
110093: LD_ADDR_VAR 0 27
110097: PUSH
110098: EMPTY
110099: ST_TO_ADDR
// bombed := [ ] ;
110100: LD_ADDR_VAR 0 28
110104: PUSH
110105: EMPTY
110106: ST_TO_ADDR
// healers := [ ] ;
110107: LD_ADDR_VAR 0 31
110111: PUSH
110112: EMPTY
110113: ST_TO_ADDR
// to_heal := [ ] ;
110114: LD_ADDR_VAR 0 30
110118: PUSH
110119: EMPTY
110120: ST_TO_ADDR
// repairs := [ ] ;
110121: LD_ADDR_VAR 0 33
110125: PUSH
110126: EMPTY
110127: ST_TO_ADDR
// to_repair := [ ] ;
110128: LD_ADDR_VAR 0 32
110132: PUSH
110133: EMPTY
110134: ST_TO_ADDR
// if not group or not path then
110135: LD_VAR 0 4
110139: NOT
110140: PUSH
110141: LD_VAR 0 5
110145: NOT
110146: OR
110147: IFFALSE 110151
// exit ;
110149: GO 114696
// side := GetSide ( group [ 1 ] ) ;
110151: LD_ADDR_VAR 0 35
110155: PUSH
110156: LD_VAR 0 4
110160: PUSH
110161: LD_INT 1
110163: ARRAY
110164: PPUSH
110165: CALL_OW 255
110169: ST_TO_ADDR
// if flags then
110170: LD_VAR 0 6
110174: IFFALSE 110318
// begin f_ignore_area := flags [ 1 ] ;
110176: LD_ADDR_VAR 0 17
110180: PUSH
110181: LD_VAR 0 6
110185: PUSH
110186: LD_INT 1
110188: ARRAY
110189: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
110190: LD_ADDR_VAR 0 18
110194: PUSH
110195: LD_VAR 0 6
110199: PUSH
110200: LD_INT 2
110202: ARRAY
110203: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
110204: LD_ADDR_VAR 0 19
110208: PUSH
110209: LD_VAR 0 6
110213: PUSH
110214: LD_INT 3
110216: ARRAY
110217: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
110218: LD_ADDR_VAR 0 20
110222: PUSH
110223: LD_VAR 0 6
110227: PUSH
110228: LD_INT 4
110230: ARRAY
110231: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
110232: LD_ADDR_VAR 0 21
110236: PUSH
110237: LD_VAR 0 6
110241: PUSH
110242: LD_INT 5
110244: ARRAY
110245: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
110246: LD_ADDR_VAR 0 22
110250: PUSH
110251: LD_VAR 0 6
110255: PUSH
110256: LD_INT 6
110258: ARRAY
110259: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
110260: LD_ADDR_VAR 0 23
110264: PUSH
110265: LD_VAR 0 6
110269: PUSH
110270: LD_INT 7
110272: ARRAY
110273: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
110274: LD_ADDR_VAR 0 24
110278: PUSH
110279: LD_VAR 0 6
110283: PUSH
110284: LD_INT 8
110286: ARRAY
110287: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
110288: LD_ADDR_VAR 0 25
110292: PUSH
110293: LD_VAR 0 6
110297: PUSH
110298: LD_INT 9
110300: ARRAY
110301: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
110302: LD_ADDR_VAR 0 26
110306: PUSH
110307: LD_VAR 0 6
110311: PUSH
110312: LD_INT 10
110314: ARRAY
110315: ST_TO_ADDR
// end else
110316: GO 110398
// begin f_ignore_area := false ;
110318: LD_ADDR_VAR 0 17
110322: PUSH
110323: LD_INT 0
110325: ST_TO_ADDR
// f_capture := false ;
110326: LD_ADDR_VAR 0 18
110330: PUSH
110331: LD_INT 0
110333: ST_TO_ADDR
// f_ignore_civ := false ;
110334: LD_ADDR_VAR 0 19
110338: PUSH
110339: LD_INT 0
110341: ST_TO_ADDR
// f_murder := false ;
110342: LD_ADDR_VAR 0 20
110346: PUSH
110347: LD_INT 0
110349: ST_TO_ADDR
// f_mines := false ;
110350: LD_ADDR_VAR 0 21
110354: PUSH
110355: LD_INT 0
110357: ST_TO_ADDR
// f_repair := false ;
110358: LD_ADDR_VAR 0 22
110362: PUSH
110363: LD_INT 0
110365: ST_TO_ADDR
// f_heal := false ;
110366: LD_ADDR_VAR 0 23
110370: PUSH
110371: LD_INT 0
110373: ST_TO_ADDR
// f_spacetime := false ;
110374: LD_ADDR_VAR 0 24
110378: PUSH
110379: LD_INT 0
110381: ST_TO_ADDR
// f_attack_depot := false ;
110382: LD_ADDR_VAR 0 25
110386: PUSH
110387: LD_INT 0
110389: ST_TO_ADDR
// f_crawl := false ;
110390: LD_ADDR_VAR 0 26
110394: PUSH
110395: LD_INT 0
110397: ST_TO_ADDR
// end ; if f_heal then
110398: LD_VAR 0 23
110402: IFFALSE 110429
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
110404: LD_ADDR_VAR 0 31
110408: PUSH
110409: LD_VAR 0 4
110413: PPUSH
110414: LD_INT 25
110416: PUSH
110417: LD_INT 4
110419: PUSH
110420: EMPTY
110421: LIST
110422: LIST
110423: PPUSH
110424: CALL_OW 72
110428: ST_TO_ADDR
// if f_repair then
110429: LD_VAR 0 22
110433: IFFALSE 110460
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
110435: LD_ADDR_VAR 0 33
110439: PUSH
110440: LD_VAR 0 4
110444: PPUSH
110445: LD_INT 25
110447: PUSH
110448: LD_INT 3
110450: PUSH
110451: EMPTY
110452: LIST
110453: LIST
110454: PPUSH
110455: CALL_OW 72
110459: ST_TO_ADDR
// units_path := [ ] ;
110460: LD_ADDR_VAR 0 16
110464: PUSH
110465: EMPTY
110466: ST_TO_ADDR
// for i = 1 to group do
110467: LD_ADDR_VAR 0 7
110471: PUSH
110472: DOUBLE
110473: LD_INT 1
110475: DEC
110476: ST_TO_ADDR
110477: LD_VAR 0 4
110481: PUSH
110482: FOR_TO
110483: IFFALSE 110512
// units_path := Replace ( units_path , i , path ) ;
110485: LD_ADDR_VAR 0 16
110489: PUSH
110490: LD_VAR 0 16
110494: PPUSH
110495: LD_VAR 0 7
110499: PPUSH
110500: LD_VAR 0 5
110504: PPUSH
110505: CALL_OW 1
110509: ST_TO_ADDR
110510: GO 110482
110512: POP
110513: POP
// repeat for i = group downto 1 do
110514: LD_ADDR_VAR 0 7
110518: PUSH
110519: DOUBLE
110520: LD_VAR 0 4
110524: INC
110525: ST_TO_ADDR
110526: LD_INT 1
110528: PUSH
110529: FOR_DOWNTO
110530: IFFALSE 114652
// begin wait ( 5 ) ;
110532: LD_INT 5
110534: PPUSH
110535: CALL_OW 67
// tmp := [ ] ;
110539: LD_ADDR_VAR 0 14
110543: PUSH
110544: EMPTY
110545: ST_TO_ADDR
// attacking := false ;
110546: LD_ADDR_VAR 0 29
110550: PUSH
110551: LD_INT 0
110553: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
110554: LD_VAR 0 4
110558: PUSH
110559: LD_VAR 0 7
110563: ARRAY
110564: PPUSH
110565: CALL_OW 301
110569: PUSH
110570: LD_VAR 0 4
110574: PUSH
110575: LD_VAR 0 7
110579: ARRAY
110580: NOT
110581: OR
110582: IFFALSE 110691
// begin if GetType ( group [ i ] ) = unit_human then
110584: LD_VAR 0 4
110588: PUSH
110589: LD_VAR 0 7
110593: ARRAY
110594: PPUSH
110595: CALL_OW 247
110599: PUSH
110600: LD_INT 1
110602: EQUAL
110603: IFFALSE 110649
// begin to_heal := to_heal diff group [ i ] ;
110605: LD_ADDR_VAR 0 30
110609: PUSH
110610: LD_VAR 0 30
110614: PUSH
110615: LD_VAR 0 4
110619: PUSH
110620: LD_VAR 0 7
110624: ARRAY
110625: DIFF
110626: ST_TO_ADDR
// healers := healers diff group [ i ] ;
110627: LD_ADDR_VAR 0 31
110631: PUSH
110632: LD_VAR 0 31
110636: PUSH
110637: LD_VAR 0 4
110641: PUSH
110642: LD_VAR 0 7
110646: ARRAY
110647: DIFF
110648: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
110649: LD_ADDR_VAR 0 4
110653: PUSH
110654: LD_VAR 0 4
110658: PPUSH
110659: LD_VAR 0 7
110663: PPUSH
110664: CALL_OW 3
110668: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
110669: LD_ADDR_VAR 0 16
110673: PUSH
110674: LD_VAR 0 16
110678: PPUSH
110679: LD_VAR 0 7
110683: PPUSH
110684: CALL_OW 3
110688: ST_TO_ADDR
// continue ;
110689: GO 110529
// end ; if f_repair then
110691: LD_VAR 0 22
110695: IFFALSE 111184
// begin if GetType ( group [ i ] ) = unit_vehicle then
110697: LD_VAR 0 4
110701: PUSH
110702: LD_VAR 0 7
110706: ARRAY
110707: PPUSH
110708: CALL_OW 247
110712: PUSH
110713: LD_INT 2
110715: EQUAL
110716: IFFALSE 110906
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
110718: LD_VAR 0 4
110722: PUSH
110723: LD_VAR 0 7
110727: ARRAY
110728: PPUSH
110729: CALL_OW 256
110733: PUSH
110734: LD_INT 700
110736: LESS
110737: PUSH
110738: LD_VAR 0 4
110742: PUSH
110743: LD_VAR 0 7
110747: ARRAY
110748: PUSH
110749: LD_VAR 0 32
110753: IN
110754: NOT
110755: AND
110756: IFFALSE 110780
// to_repair := to_repair union group [ i ] ;
110758: LD_ADDR_VAR 0 32
110762: PUSH
110763: LD_VAR 0 32
110767: PUSH
110768: LD_VAR 0 4
110772: PUSH
110773: LD_VAR 0 7
110777: ARRAY
110778: UNION
110779: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
110780: LD_VAR 0 4
110784: PUSH
110785: LD_VAR 0 7
110789: ARRAY
110790: PPUSH
110791: CALL_OW 256
110795: PUSH
110796: LD_INT 1000
110798: EQUAL
110799: PUSH
110800: LD_VAR 0 4
110804: PUSH
110805: LD_VAR 0 7
110809: ARRAY
110810: PUSH
110811: LD_VAR 0 32
110815: IN
110816: AND
110817: IFFALSE 110841
// to_repair := to_repair diff group [ i ] ;
110819: LD_ADDR_VAR 0 32
110823: PUSH
110824: LD_VAR 0 32
110828: PUSH
110829: LD_VAR 0 4
110833: PUSH
110834: LD_VAR 0 7
110838: ARRAY
110839: DIFF
110840: ST_TO_ADDR
// if group [ i ] in to_repair then
110841: LD_VAR 0 4
110845: PUSH
110846: LD_VAR 0 7
110850: ARRAY
110851: PUSH
110852: LD_VAR 0 32
110856: IN
110857: IFFALSE 110904
// begin if not IsInArea ( group [ i ] , f_repair ) then
110859: LD_VAR 0 4
110863: PUSH
110864: LD_VAR 0 7
110868: ARRAY
110869: PPUSH
110870: LD_VAR 0 22
110874: PPUSH
110875: CALL_OW 308
110879: NOT
110880: IFFALSE 110902
// ComMoveToArea ( group [ i ] , f_repair ) ;
110882: LD_VAR 0 4
110886: PUSH
110887: LD_VAR 0 7
110891: ARRAY
110892: PPUSH
110893: LD_VAR 0 22
110897: PPUSH
110898: CALL_OW 113
// continue ;
110902: GO 110529
// end ; end else
110904: GO 111184
// if group [ i ] in repairs then
110906: LD_VAR 0 4
110910: PUSH
110911: LD_VAR 0 7
110915: ARRAY
110916: PUSH
110917: LD_VAR 0 33
110921: IN
110922: IFFALSE 111184
// begin if IsInUnit ( group [ i ] ) then
110924: LD_VAR 0 4
110928: PUSH
110929: LD_VAR 0 7
110933: ARRAY
110934: PPUSH
110935: CALL_OW 310
110939: IFFALSE 111007
// begin z := IsInUnit ( group [ i ] ) ;
110941: LD_ADDR_VAR 0 13
110945: PUSH
110946: LD_VAR 0 4
110950: PUSH
110951: LD_VAR 0 7
110955: ARRAY
110956: PPUSH
110957: CALL_OW 310
110961: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
110962: LD_VAR 0 13
110966: PUSH
110967: LD_VAR 0 32
110971: IN
110972: PUSH
110973: LD_VAR 0 13
110977: PPUSH
110978: LD_VAR 0 22
110982: PPUSH
110983: CALL_OW 308
110987: AND
110988: IFFALSE 111005
// ComExitVehicle ( group [ i ] ) ;
110990: LD_VAR 0 4
110994: PUSH
110995: LD_VAR 0 7
110999: ARRAY
111000: PPUSH
111001: CALL_OW 121
// end else
111005: GO 111184
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
111007: LD_ADDR_VAR 0 13
111011: PUSH
111012: LD_VAR 0 4
111016: PPUSH
111017: LD_INT 95
111019: PUSH
111020: LD_VAR 0 22
111024: PUSH
111025: EMPTY
111026: LIST
111027: LIST
111028: PUSH
111029: LD_INT 58
111031: PUSH
111032: EMPTY
111033: LIST
111034: PUSH
111035: EMPTY
111036: LIST
111037: LIST
111038: PPUSH
111039: CALL_OW 72
111043: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
111044: LD_VAR 0 4
111048: PUSH
111049: LD_VAR 0 7
111053: ARRAY
111054: PPUSH
111055: CALL_OW 314
111059: NOT
111060: IFFALSE 111182
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
111062: LD_ADDR_VAR 0 10
111066: PUSH
111067: LD_VAR 0 13
111071: PPUSH
111072: LD_VAR 0 4
111076: PUSH
111077: LD_VAR 0 7
111081: ARRAY
111082: PPUSH
111083: CALL_OW 74
111087: ST_TO_ADDR
// if not x then
111088: LD_VAR 0 10
111092: NOT
111093: IFFALSE 111097
// continue ;
111095: GO 110529
// if GetLives ( x ) < 1000 then
111097: LD_VAR 0 10
111101: PPUSH
111102: CALL_OW 256
111106: PUSH
111107: LD_INT 1000
111109: LESS
111110: IFFALSE 111134
// ComRepairVehicle ( group [ i ] , x ) else
111112: LD_VAR 0 4
111116: PUSH
111117: LD_VAR 0 7
111121: ARRAY
111122: PPUSH
111123: LD_VAR 0 10
111127: PPUSH
111128: CALL_OW 129
111132: GO 111182
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
111134: LD_VAR 0 23
111138: PUSH
111139: LD_VAR 0 4
111143: PUSH
111144: LD_VAR 0 7
111148: ARRAY
111149: PPUSH
111150: CALL_OW 256
111154: PUSH
111155: LD_INT 1000
111157: LESS
111158: AND
111159: NOT
111160: IFFALSE 111182
// ComEnterUnit ( group [ i ] , x ) ;
111162: LD_VAR 0 4
111166: PUSH
111167: LD_VAR 0 7
111171: ARRAY
111172: PPUSH
111173: LD_VAR 0 10
111177: PPUSH
111178: CALL_OW 120
// end ; continue ;
111182: GO 110529
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
111184: LD_VAR 0 23
111188: PUSH
111189: LD_VAR 0 4
111193: PUSH
111194: LD_VAR 0 7
111198: ARRAY
111199: PPUSH
111200: CALL_OW 247
111204: PUSH
111205: LD_INT 1
111207: EQUAL
111208: AND
111209: IFFALSE 111687
// begin if group [ i ] in healers then
111211: LD_VAR 0 4
111215: PUSH
111216: LD_VAR 0 7
111220: ARRAY
111221: PUSH
111222: LD_VAR 0 31
111226: IN
111227: IFFALSE 111500
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
111229: LD_VAR 0 4
111233: PUSH
111234: LD_VAR 0 7
111238: ARRAY
111239: PPUSH
111240: LD_VAR 0 23
111244: PPUSH
111245: CALL_OW 308
111249: NOT
111250: PUSH
111251: LD_VAR 0 4
111255: PUSH
111256: LD_VAR 0 7
111260: ARRAY
111261: PPUSH
111262: CALL_OW 314
111266: NOT
111267: AND
111268: IFFALSE 111292
// ComMoveToArea ( group [ i ] , f_heal ) else
111270: LD_VAR 0 4
111274: PUSH
111275: LD_VAR 0 7
111279: ARRAY
111280: PPUSH
111281: LD_VAR 0 23
111285: PPUSH
111286: CALL_OW 113
111290: GO 111498
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
111292: LD_VAR 0 4
111296: PUSH
111297: LD_VAR 0 7
111301: ARRAY
111302: PPUSH
111303: CALL 83486 0 1
111307: PPUSH
111308: CALL_OW 256
111312: PUSH
111313: LD_INT 1000
111315: EQUAL
111316: IFFALSE 111335
// ComStop ( group [ i ] ) else
111318: LD_VAR 0 4
111322: PUSH
111323: LD_VAR 0 7
111327: ARRAY
111328: PPUSH
111329: CALL_OW 141
111333: GO 111498
// if not HasTask ( group [ i ] ) and to_heal then
111335: LD_VAR 0 4
111339: PUSH
111340: LD_VAR 0 7
111344: ARRAY
111345: PPUSH
111346: CALL_OW 314
111350: NOT
111351: PUSH
111352: LD_VAR 0 30
111356: AND
111357: IFFALSE 111498
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
111359: LD_ADDR_VAR 0 13
111363: PUSH
111364: LD_VAR 0 30
111368: PPUSH
111369: LD_INT 3
111371: PUSH
111372: LD_INT 54
111374: PUSH
111375: EMPTY
111376: LIST
111377: PUSH
111378: EMPTY
111379: LIST
111380: LIST
111381: PPUSH
111382: CALL_OW 72
111386: PPUSH
111387: LD_VAR 0 4
111391: PUSH
111392: LD_VAR 0 7
111396: ARRAY
111397: PPUSH
111398: CALL_OW 74
111402: ST_TO_ADDR
// if z then
111403: LD_VAR 0 13
111407: IFFALSE 111498
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
111409: LD_INT 91
111411: PUSH
111412: LD_VAR 0 13
111416: PUSH
111417: LD_INT 10
111419: PUSH
111420: EMPTY
111421: LIST
111422: LIST
111423: LIST
111424: PUSH
111425: LD_INT 81
111427: PUSH
111428: LD_VAR 0 13
111432: PPUSH
111433: CALL_OW 255
111437: PUSH
111438: EMPTY
111439: LIST
111440: LIST
111441: PUSH
111442: EMPTY
111443: LIST
111444: LIST
111445: PPUSH
111446: CALL_OW 69
111450: PUSH
111451: LD_INT 0
111453: EQUAL
111454: IFFALSE 111478
// ComHeal ( group [ i ] , z ) else
111456: LD_VAR 0 4
111460: PUSH
111461: LD_VAR 0 7
111465: ARRAY
111466: PPUSH
111467: LD_VAR 0 13
111471: PPUSH
111472: CALL_OW 128
111476: GO 111498
// ComMoveToArea ( group [ i ] , f_heal ) ;
111478: LD_VAR 0 4
111482: PUSH
111483: LD_VAR 0 7
111487: ARRAY
111488: PPUSH
111489: LD_VAR 0 23
111493: PPUSH
111494: CALL_OW 113
// end ; continue ;
111498: GO 110529
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
111500: LD_VAR 0 4
111504: PUSH
111505: LD_VAR 0 7
111509: ARRAY
111510: PPUSH
111511: CALL_OW 256
111515: PUSH
111516: LD_INT 700
111518: LESS
111519: PUSH
111520: LD_VAR 0 4
111524: PUSH
111525: LD_VAR 0 7
111529: ARRAY
111530: PUSH
111531: LD_VAR 0 30
111535: IN
111536: NOT
111537: AND
111538: IFFALSE 111562
// to_heal := to_heal union group [ i ] ;
111540: LD_ADDR_VAR 0 30
111544: PUSH
111545: LD_VAR 0 30
111549: PUSH
111550: LD_VAR 0 4
111554: PUSH
111555: LD_VAR 0 7
111559: ARRAY
111560: UNION
111561: ST_TO_ADDR
// if group [ i ] in to_heal then
111562: LD_VAR 0 4
111566: PUSH
111567: LD_VAR 0 7
111571: ARRAY
111572: PUSH
111573: LD_VAR 0 30
111577: IN
111578: IFFALSE 111687
// begin if GetLives ( group [ i ] ) = 1000 then
111580: LD_VAR 0 4
111584: PUSH
111585: LD_VAR 0 7
111589: ARRAY
111590: PPUSH
111591: CALL_OW 256
111595: PUSH
111596: LD_INT 1000
111598: EQUAL
111599: IFFALSE 111625
// to_heal := to_heal diff group [ i ] else
111601: LD_ADDR_VAR 0 30
111605: PUSH
111606: LD_VAR 0 30
111610: PUSH
111611: LD_VAR 0 4
111615: PUSH
111616: LD_VAR 0 7
111620: ARRAY
111621: DIFF
111622: ST_TO_ADDR
111623: GO 111687
// begin if not IsInArea ( group [ i ] , to_heal ) then
111625: LD_VAR 0 4
111629: PUSH
111630: LD_VAR 0 7
111634: ARRAY
111635: PPUSH
111636: LD_VAR 0 30
111640: PPUSH
111641: CALL_OW 308
111645: NOT
111646: IFFALSE 111670
// ComMoveToArea ( group [ i ] , f_heal ) else
111648: LD_VAR 0 4
111652: PUSH
111653: LD_VAR 0 7
111657: ARRAY
111658: PPUSH
111659: LD_VAR 0 23
111663: PPUSH
111664: CALL_OW 113
111668: GO 111685
// ComHold ( group [ i ] ) ;
111670: LD_VAR 0 4
111674: PUSH
111675: LD_VAR 0 7
111679: ARRAY
111680: PPUSH
111681: CALL_OW 140
// continue ;
111685: GO 110529
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
111687: LD_VAR 0 4
111691: PUSH
111692: LD_VAR 0 7
111696: ARRAY
111697: PPUSH
111698: LD_INT 10
111700: PPUSH
111701: CALL 81283 0 2
111705: NOT
111706: PUSH
111707: LD_VAR 0 16
111711: PUSH
111712: LD_VAR 0 7
111716: ARRAY
111717: PUSH
111718: EMPTY
111719: EQUAL
111720: NOT
111721: AND
111722: IFFALSE 111988
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
111724: LD_VAR 0 4
111728: PUSH
111729: LD_VAR 0 7
111733: ARRAY
111734: PPUSH
111735: CALL_OW 262
111739: PUSH
111740: LD_INT 1
111742: PUSH
111743: LD_INT 2
111745: PUSH
111746: EMPTY
111747: LIST
111748: LIST
111749: IN
111750: IFFALSE 111791
// if GetFuel ( group [ i ] ) < 10 then
111752: LD_VAR 0 4
111756: PUSH
111757: LD_VAR 0 7
111761: ARRAY
111762: PPUSH
111763: CALL_OW 261
111767: PUSH
111768: LD_INT 10
111770: LESS
111771: IFFALSE 111791
// SetFuel ( group [ i ] , 12 ) ;
111773: LD_VAR 0 4
111777: PUSH
111778: LD_VAR 0 7
111782: ARRAY
111783: PPUSH
111784: LD_INT 12
111786: PPUSH
111787: CALL_OW 240
// if units_path [ i ] then
111791: LD_VAR 0 16
111795: PUSH
111796: LD_VAR 0 7
111800: ARRAY
111801: IFFALSE 111986
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
111803: LD_VAR 0 4
111807: PUSH
111808: LD_VAR 0 7
111812: ARRAY
111813: PPUSH
111814: LD_VAR 0 16
111818: PUSH
111819: LD_VAR 0 7
111823: ARRAY
111824: PUSH
111825: LD_INT 1
111827: ARRAY
111828: PUSH
111829: LD_INT 1
111831: ARRAY
111832: PPUSH
111833: LD_VAR 0 16
111837: PUSH
111838: LD_VAR 0 7
111842: ARRAY
111843: PUSH
111844: LD_INT 1
111846: ARRAY
111847: PUSH
111848: LD_INT 2
111850: ARRAY
111851: PPUSH
111852: CALL_OW 297
111856: PUSH
111857: LD_INT 6
111859: GREATER
111860: IFFALSE 111935
// begin if not HasTask ( group [ i ] ) then
111862: LD_VAR 0 4
111866: PUSH
111867: LD_VAR 0 7
111871: ARRAY
111872: PPUSH
111873: CALL_OW 314
111877: NOT
111878: IFFALSE 111933
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
111880: LD_VAR 0 4
111884: PUSH
111885: LD_VAR 0 7
111889: ARRAY
111890: PPUSH
111891: LD_VAR 0 16
111895: PUSH
111896: LD_VAR 0 7
111900: ARRAY
111901: PUSH
111902: LD_INT 1
111904: ARRAY
111905: PUSH
111906: LD_INT 1
111908: ARRAY
111909: PPUSH
111910: LD_VAR 0 16
111914: PUSH
111915: LD_VAR 0 7
111919: ARRAY
111920: PUSH
111921: LD_INT 1
111923: ARRAY
111924: PUSH
111925: LD_INT 2
111927: ARRAY
111928: PPUSH
111929: CALL_OW 114
// end else
111933: GO 111986
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
111935: LD_ADDR_VAR 0 15
111939: PUSH
111940: LD_VAR 0 16
111944: PUSH
111945: LD_VAR 0 7
111949: ARRAY
111950: PPUSH
111951: LD_INT 1
111953: PPUSH
111954: CALL_OW 3
111958: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
111959: LD_ADDR_VAR 0 16
111963: PUSH
111964: LD_VAR 0 16
111968: PPUSH
111969: LD_VAR 0 7
111973: PPUSH
111974: LD_VAR 0 15
111978: PPUSH
111979: CALL_OW 1
111983: ST_TO_ADDR
// continue ;
111984: GO 110529
// end ; end ; end else
111986: GO 114650
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
111988: LD_ADDR_VAR 0 14
111992: PUSH
111993: LD_INT 81
111995: PUSH
111996: LD_VAR 0 4
112000: PUSH
112001: LD_VAR 0 7
112005: ARRAY
112006: PPUSH
112007: CALL_OW 255
112011: PUSH
112012: EMPTY
112013: LIST
112014: LIST
112015: PPUSH
112016: CALL_OW 69
112020: ST_TO_ADDR
// if not tmp then
112021: LD_VAR 0 14
112025: NOT
112026: IFFALSE 112030
// continue ;
112028: GO 110529
// if f_ignore_area then
112030: LD_VAR 0 17
112034: IFFALSE 112122
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
112036: LD_ADDR_VAR 0 15
112040: PUSH
112041: LD_VAR 0 14
112045: PPUSH
112046: LD_INT 3
112048: PUSH
112049: LD_INT 92
112051: PUSH
112052: LD_VAR 0 17
112056: PUSH
112057: LD_INT 1
112059: ARRAY
112060: PUSH
112061: LD_VAR 0 17
112065: PUSH
112066: LD_INT 2
112068: ARRAY
112069: PUSH
112070: LD_VAR 0 17
112074: PUSH
112075: LD_INT 3
112077: ARRAY
112078: PUSH
112079: EMPTY
112080: LIST
112081: LIST
112082: LIST
112083: LIST
112084: PUSH
112085: EMPTY
112086: LIST
112087: LIST
112088: PPUSH
112089: CALL_OW 72
112093: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
112094: LD_VAR 0 14
112098: PUSH
112099: LD_VAR 0 15
112103: DIFF
112104: IFFALSE 112122
// tmp := tmp diff tmp2 ;
112106: LD_ADDR_VAR 0 14
112110: PUSH
112111: LD_VAR 0 14
112115: PUSH
112116: LD_VAR 0 15
112120: DIFF
112121: ST_TO_ADDR
// end ; if not f_murder then
112122: LD_VAR 0 20
112126: NOT
112127: IFFALSE 112185
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
112129: LD_ADDR_VAR 0 15
112133: PUSH
112134: LD_VAR 0 14
112138: PPUSH
112139: LD_INT 3
112141: PUSH
112142: LD_INT 50
112144: PUSH
112145: EMPTY
112146: LIST
112147: PUSH
112148: EMPTY
112149: LIST
112150: LIST
112151: PPUSH
112152: CALL_OW 72
112156: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
112157: LD_VAR 0 14
112161: PUSH
112162: LD_VAR 0 15
112166: DIFF
112167: IFFALSE 112185
// tmp := tmp diff tmp2 ;
112169: LD_ADDR_VAR 0 14
112173: PUSH
112174: LD_VAR 0 14
112178: PUSH
112179: LD_VAR 0 15
112183: DIFF
112184: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
112185: LD_ADDR_VAR 0 14
112189: PUSH
112190: LD_VAR 0 4
112194: PUSH
112195: LD_VAR 0 7
112199: ARRAY
112200: PPUSH
112201: LD_VAR 0 14
112205: PPUSH
112206: LD_INT 1
112208: PPUSH
112209: LD_INT 1
112211: PPUSH
112212: CALL 54224 0 4
112216: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
112217: LD_VAR 0 4
112221: PUSH
112222: LD_VAR 0 7
112226: ARRAY
112227: PPUSH
112228: CALL_OW 257
112232: PUSH
112233: LD_INT 1
112235: EQUAL
112236: IFFALSE 112684
// begin if WantPlant ( group [ i ] ) then
112238: LD_VAR 0 4
112242: PUSH
112243: LD_VAR 0 7
112247: ARRAY
112248: PPUSH
112249: CALL 53725 0 1
112253: IFFALSE 112257
// continue ;
112255: GO 110529
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
112257: LD_VAR 0 18
112261: PUSH
112262: LD_VAR 0 4
112266: PUSH
112267: LD_VAR 0 7
112271: ARRAY
112272: PPUSH
112273: CALL_OW 310
112277: NOT
112278: AND
112279: PUSH
112280: LD_VAR 0 14
112284: PUSH
112285: LD_INT 1
112287: ARRAY
112288: PUSH
112289: LD_VAR 0 14
112293: PPUSH
112294: LD_INT 21
112296: PUSH
112297: LD_INT 2
112299: PUSH
112300: EMPTY
112301: LIST
112302: LIST
112303: PUSH
112304: LD_INT 58
112306: PUSH
112307: EMPTY
112308: LIST
112309: PUSH
112310: EMPTY
112311: LIST
112312: LIST
112313: PPUSH
112314: CALL_OW 72
112318: IN
112319: AND
112320: IFFALSE 112356
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
112322: LD_VAR 0 4
112326: PUSH
112327: LD_VAR 0 7
112331: ARRAY
112332: PPUSH
112333: LD_VAR 0 14
112337: PUSH
112338: LD_INT 1
112340: ARRAY
112341: PPUSH
112342: CALL_OW 120
// attacking := true ;
112346: LD_ADDR_VAR 0 29
112350: PUSH
112351: LD_INT 1
112353: ST_TO_ADDR
// continue ;
112354: GO 110529
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
112356: LD_VAR 0 26
112360: PUSH
112361: LD_VAR 0 4
112365: PUSH
112366: LD_VAR 0 7
112370: ARRAY
112371: PPUSH
112372: CALL_OW 257
112376: PUSH
112377: LD_INT 1
112379: EQUAL
112380: AND
112381: PUSH
112382: LD_VAR 0 4
112386: PUSH
112387: LD_VAR 0 7
112391: ARRAY
112392: PPUSH
112393: CALL_OW 256
112397: PUSH
112398: LD_INT 800
112400: LESS
112401: AND
112402: PUSH
112403: LD_VAR 0 4
112407: PUSH
112408: LD_VAR 0 7
112412: ARRAY
112413: PPUSH
112414: CALL_OW 318
112418: NOT
112419: AND
112420: IFFALSE 112437
// ComCrawl ( group [ i ] ) ;
112422: LD_VAR 0 4
112426: PUSH
112427: LD_VAR 0 7
112431: ARRAY
112432: PPUSH
112433: CALL_OW 137
// if f_mines then
112437: LD_VAR 0 21
112441: IFFALSE 112684
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
112443: LD_VAR 0 14
112447: PUSH
112448: LD_INT 1
112450: ARRAY
112451: PPUSH
112452: CALL_OW 247
112456: PUSH
112457: LD_INT 3
112459: EQUAL
112460: PUSH
112461: LD_VAR 0 14
112465: PUSH
112466: LD_INT 1
112468: ARRAY
112469: PUSH
112470: LD_VAR 0 27
112474: IN
112475: NOT
112476: AND
112477: IFFALSE 112684
// begin x := GetX ( tmp [ 1 ] ) ;
112479: LD_ADDR_VAR 0 10
112483: PUSH
112484: LD_VAR 0 14
112488: PUSH
112489: LD_INT 1
112491: ARRAY
112492: PPUSH
112493: CALL_OW 250
112497: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
112498: LD_ADDR_VAR 0 11
112502: PUSH
112503: LD_VAR 0 14
112507: PUSH
112508: LD_INT 1
112510: ARRAY
112511: PPUSH
112512: CALL_OW 251
112516: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
112517: LD_ADDR_VAR 0 12
112521: PUSH
112522: LD_VAR 0 4
112526: PUSH
112527: LD_VAR 0 7
112531: ARRAY
112532: PPUSH
112533: CALL 81368 0 1
112537: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
112538: LD_VAR 0 4
112542: PUSH
112543: LD_VAR 0 7
112547: ARRAY
112548: PPUSH
112549: LD_VAR 0 10
112553: PPUSH
112554: LD_VAR 0 11
112558: PPUSH
112559: LD_VAR 0 14
112563: PUSH
112564: LD_INT 1
112566: ARRAY
112567: PPUSH
112568: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
112572: LD_VAR 0 4
112576: PUSH
112577: LD_VAR 0 7
112581: ARRAY
112582: PPUSH
112583: LD_VAR 0 10
112587: PPUSH
112588: LD_VAR 0 12
112592: PPUSH
112593: LD_INT 7
112595: PPUSH
112596: CALL_OW 272
112600: PPUSH
112601: LD_VAR 0 11
112605: PPUSH
112606: LD_VAR 0 12
112610: PPUSH
112611: LD_INT 7
112613: PPUSH
112614: CALL_OW 273
112618: PPUSH
112619: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
112623: LD_VAR 0 4
112627: PUSH
112628: LD_VAR 0 7
112632: ARRAY
112633: PPUSH
112634: LD_INT 71
112636: PPUSH
112637: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
112641: LD_ADDR_VAR 0 27
112645: PUSH
112646: LD_VAR 0 27
112650: PPUSH
112651: LD_VAR 0 27
112655: PUSH
112656: LD_INT 1
112658: PLUS
112659: PPUSH
112660: LD_VAR 0 14
112664: PUSH
112665: LD_INT 1
112667: ARRAY
112668: PPUSH
112669: CALL_OW 1
112673: ST_TO_ADDR
// attacking := true ;
112674: LD_ADDR_VAR 0 29
112678: PUSH
112679: LD_INT 1
112681: ST_TO_ADDR
// continue ;
112682: GO 110529
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
112684: LD_VAR 0 4
112688: PUSH
112689: LD_VAR 0 7
112693: ARRAY
112694: PPUSH
112695: CALL_OW 257
112699: PUSH
112700: LD_INT 17
112702: EQUAL
112703: PUSH
112704: LD_VAR 0 4
112708: PUSH
112709: LD_VAR 0 7
112713: ARRAY
112714: PPUSH
112715: CALL_OW 110
112719: PUSH
112720: LD_INT 71
112722: EQUAL
112723: NOT
112724: AND
112725: IFFALSE 112871
// begin attacking := false ;
112727: LD_ADDR_VAR 0 29
112731: PUSH
112732: LD_INT 0
112734: ST_TO_ADDR
// k := 5 ;
112735: LD_ADDR_VAR 0 9
112739: PUSH
112740: LD_INT 5
112742: ST_TO_ADDR
// if tmp < k then
112743: LD_VAR 0 14
112747: PUSH
112748: LD_VAR 0 9
112752: LESS
112753: IFFALSE 112765
// k := tmp ;
112755: LD_ADDR_VAR 0 9
112759: PUSH
112760: LD_VAR 0 14
112764: ST_TO_ADDR
// for j = 1 to k do
112765: LD_ADDR_VAR 0 8
112769: PUSH
112770: DOUBLE
112771: LD_INT 1
112773: DEC
112774: ST_TO_ADDR
112775: LD_VAR 0 9
112779: PUSH
112780: FOR_TO
112781: IFFALSE 112869
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
112783: LD_VAR 0 14
112787: PUSH
112788: LD_VAR 0 8
112792: ARRAY
112793: PUSH
112794: LD_VAR 0 14
112798: PPUSH
112799: LD_INT 58
112801: PUSH
112802: EMPTY
112803: LIST
112804: PPUSH
112805: CALL_OW 72
112809: IN
112810: NOT
112811: IFFALSE 112867
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
112813: LD_VAR 0 4
112817: PUSH
112818: LD_VAR 0 7
112822: ARRAY
112823: PPUSH
112824: LD_VAR 0 14
112828: PUSH
112829: LD_VAR 0 8
112833: ARRAY
112834: PPUSH
112835: CALL_OW 115
// attacking := true ;
112839: LD_ADDR_VAR 0 29
112843: PUSH
112844: LD_INT 1
112846: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
112847: LD_VAR 0 4
112851: PUSH
112852: LD_VAR 0 7
112856: ARRAY
112857: PPUSH
112858: LD_INT 71
112860: PPUSH
112861: CALL_OW 109
// continue ;
112865: GO 112780
// end ; end ;
112867: GO 112780
112869: POP
112870: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
112871: LD_VAR 0 4
112875: PUSH
112876: LD_VAR 0 7
112880: ARRAY
112881: PPUSH
112882: CALL_OW 257
112886: PUSH
112887: LD_INT 8
112889: EQUAL
112890: PUSH
112891: LD_VAR 0 4
112895: PUSH
112896: LD_VAR 0 7
112900: ARRAY
112901: PPUSH
112902: CALL_OW 264
112906: PUSH
112907: LD_INT 28
112909: PUSH
112910: LD_INT 45
112912: PUSH
112913: LD_INT 7
112915: PUSH
112916: LD_INT 47
112918: PUSH
112919: EMPTY
112920: LIST
112921: LIST
112922: LIST
112923: LIST
112924: IN
112925: OR
112926: IFFALSE 113182
// begin attacking := false ;
112928: LD_ADDR_VAR 0 29
112932: PUSH
112933: LD_INT 0
112935: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
112936: LD_VAR 0 14
112940: PUSH
112941: LD_INT 1
112943: ARRAY
112944: PPUSH
112945: CALL_OW 266
112949: PUSH
112950: LD_INT 32
112952: PUSH
112953: LD_INT 31
112955: PUSH
112956: LD_INT 33
112958: PUSH
112959: LD_INT 4
112961: PUSH
112962: LD_INT 5
112964: PUSH
112965: EMPTY
112966: LIST
112967: LIST
112968: LIST
112969: LIST
112970: LIST
112971: IN
112972: IFFALSE 113158
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
112974: LD_ADDR_VAR 0 9
112978: PUSH
112979: LD_VAR 0 14
112983: PUSH
112984: LD_INT 1
112986: ARRAY
112987: PPUSH
112988: CALL_OW 266
112992: PPUSH
112993: LD_VAR 0 14
112997: PUSH
112998: LD_INT 1
113000: ARRAY
113001: PPUSH
113002: CALL_OW 250
113006: PPUSH
113007: LD_VAR 0 14
113011: PUSH
113012: LD_INT 1
113014: ARRAY
113015: PPUSH
113016: CALL_OW 251
113020: PPUSH
113021: LD_VAR 0 14
113025: PUSH
113026: LD_INT 1
113028: ARRAY
113029: PPUSH
113030: CALL_OW 254
113034: PPUSH
113035: LD_VAR 0 14
113039: PUSH
113040: LD_INT 1
113042: ARRAY
113043: PPUSH
113044: CALL_OW 248
113048: PPUSH
113049: LD_INT 0
113051: PPUSH
113052: CALL 62738 0 6
113056: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
113057: LD_ADDR_VAR 0 8
113061: PUSH
113062: LD_VAR 0 4
113066: PUSH
113067: LD_VAR 0 7
113071: ARRAY
113072: PPUSH
113073: LD_VAR 0 9
113077: PPUSH
113078: CALL 81481 0 2
113082: ST_TO_ADDR
// if j then
113083: LD_VAR 0 8
113087: IFFALSE 113156
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
113089: LD_VAR 0 8
113093: PUSH
113094: LD_INT 1
113096: ARRAY
113097: PPUSH
113098: LD_VAR 0 8
113102: PUSH
113103: LD_INT 2
113105: ARRAY
113106: PPUSH
113107: CALL_OW 488
113111: IFFALSE 113156
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
113113: LD_VAR 0 4
113117: PUSH
113118: LD_VAR 0 7
113122: ARRAY
113123: PPUSH
113124: LD_VAR 0 8
113128: PUSH
113129: LD_INT 1
113131: ARRAY
113132: PPUSH
113133: LD_VAR 0 8
113137: PUSH
113138: LD_INT 2
113140: ARRAY
113141: PPUSH
113142: CALL_OW 116
// attacking := true ;
113146: LD_ADDR_VAR 0 29
113150: PUSH
113151: LD_INT 1
113153: ST_TO_ADDR
// continue ;
113154: GO 110529
// end ; end else
113156: GO 113182
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
113158: LD_VAR 0 4
113162: PUSH
113163: LD_VAR 0 7
113167: ARRAY
113168: PPUSH
113169: LD_VAR 0 14
113173: PUSH
113174: LD_INT 1
113176: ARRAY
113177: PPUSH
113178: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
113182: LD_VAR 0 4
113186: PUSH
113187: LD_VAR 0 7
113191: ARRAY
113192: PPUSH
113193: CALL_OW 265
113197: PUSH
113198: LD_INT 11
113200: EQUAL
113201: IFFALSE 113479
// begin k := 10 ;
113203: LD_ADDR_VAR 0 9
113207: PUSH
113208: LD_INT 10
113210: ST_TO_ADDR
// x := 0 ;
113211: LD_ADDR_VAR 0 10
113215: PUSH
113216: LD_INT 0
113218: ST_TO_ADDR
// if tmp < k then
113219: LD_VAR 0 14
113223: PUSH
113224: LD_VAR 0 9
113228: LESS
113229: IFFALSE 113241
// k := tmp ;
113231: LD_ADDR_VAR 0 9
113235: PUSH
113236: LD_VAR 0 14
113240: ST_TO_ADDR
// for j = k downto 1 do
113241: LD_ADDR_VAR 0 8
113245: PUSH
113246: DOUBLE
113247: LD_VAR 0 9
113251: INC
113252: ST_TO_ADDR
113253: LD_INT 1
113255: PUSH
113256: FOR_DOWNTO
113257: IFFALSE 113332
// begin if GetType ( tmp [ j ] ) = unit_human then
113259: LD_VAR 0 14
113263: PUSH
113264: LD_VAR 0 8
113268: ARRAY
113269: PPUSH
113270: CALL_OW 247
113274: PUSH
113275: LD_INT 1
113277: EQUAL
113278: IFFALSE 113330
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
113280: LD_VAR 0 4
113284: PUSH
113285: LD_VAR 0 7
113289: ARRAY
113290: PPUSH
113291: LD_VAR 0 14
113295: PUSH
113296: LD_VAR 0 8
113300: ARRAY
113301: PPUSH
113302: CALL 81735 0 2
// x := tmp [ j ] ;
113306: LD_ADDR_VAR 0 10
113310: PUSH
113311: LD_VAR 0 14
113315: PUSH
113316: LD_VAR 0 8
113320: ARRAY
113321: ST_TO_ADDR
// attacking := true ;
113322: LD_ADDR_VAR 0 29
113326: PUSH
113327: LD_INT 1
113329: ST_TO_ADDR
// end ; end ;
113330: GO 113256
113332: POP
113333: POP
// if not x then
113334: LD_VAR 0 10
113338: NOT
113339: IFFALSE 113479
// begin attacking := true ;
113341: LD_ADDR_VAR 0 29
113345: PUSH
113346: LD_INT 1
113348: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
113349: LD_VAR 0 4
113353: PUSH
113354: LD_VAR 0 7
113358: ARRAY
113359: PPUSH
113360: CALL_OW 250
113364: PPUSH
113365: LD_VAR 0 4
113369: PUSH
113370: LD_VAR 0 7
113374: ARRAY
113375: PPUSH
113376: CALL_OW 251
113380: PPUSH
113381: CALL_OW 546
113385: PUSH
113386: LD_INT 2
113388: ARRAY
113389: PUSH
113390: LD_VAR 0 14
113394: PUSH
113395: LD_INT 1
113397: ARRAY
113398: PPUSH
113399: CALL_OW 250
113403: PPUSH
113404: LD_VAR 0 14
113408: PUSH
113409: LD_INT 1
113411: ARRAY
113412: PPUSH
113413: CALL_OW 251
113417: PPUSH
113418: CALL_OW 546
113422: PUSH
113423: LD_INT 2
113425: ARRAY
113426: EQUAL
113427: IFFALSE 113455
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
113429: LD_VAR 0 4
113433: PUSH
113434: LD_VAR 0 7
113438: ARRAY
113439: PPUSH
113440: LD_VAR 0 14
113444: PUSH
113445: LD_INT 1
113447: ARRAY
113448: PPUSH
113449: CALL 81735 0 2
113453: GO 113479
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
113455: LD_VAR 0 4
113459: PUSH
113460: LD_VAR 0 7
113464: ARRAY
113465: PPUSH
113466: LD_VAR 0 14
113470: PUSH
113471: LD_INT 1
113473: ARRAY
113474: PPUSH
113475: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
113479: LD_VAR 0 4
113483: PUSH
113484: LD_VAR 0 7
113488: ARRAY
113489: PPUSH
113490: CALL_OW 264
113494: PUSH
113495: LD_INT 29
113497: EQUAL
113498: IFFALSE 113864
// begin if WantsToAttack ( group [ i ] ) in bombed then
113500: LD_VAR 0 4
113504: PUSH
113505: LD_VAR 0 7
113509: ARRAY
113510: PPUSH
113511: CALL_OW 319
113515: PUSH
113516: LD_VAR 0 28
113520: IN
113521: IFFALSE 113525
// continue ;
113523: GO 110529
// k := 8 ;
113525: LD_ADDR_VAR 0 9
113529: PUSH
113530: LD_INT 8
113532: ST_TO_ADDR
// x := 0 ;
113533: LD_ADDR_VAR 0 10
113537: PUSH
113538: LD_INT 0
113540: ST_TO_ADDR
// if tmp < k then
113541: LD_VAR 0 14
113545: PUSH
113546: LD_VAR 0 9
113550: LESS
113551: IFFALSE 113563
// k := tmp ;
113553: LD_ADDR_VAR 0 9
113557: PUSH
113558: LD_VAR 0 14
113562: ST_TO_ADDR
// for j = 1 to k do
113563: LD_ADDR_VAR 0 8
113567: PUSH
113568: DOUBLE
113569: LD_INT 1
113571: DEC
113572: ST_TO_ADDR
113573: LD_VAR 0 9
113577: PUSH
113578: FOR_TO
113579: IFFALSE 113711
// begin if GetType ( tmp [ j ] ) = unit_building then
113581: LD_VAR 0 14
113585: PUSH
113586: LD_VAR 0 8
113590: ARRAY
113591: PPUSH
113592: CALL_OW 247
113596: PUSH
113597: LD_INT 3
113599: EQUAL
113600: IFFALSE 113709
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
113602: LD_VAR 0 14
113606: PUSH
113607: LD_VAR 0 8
113611: ARRAY
113612: PUSH
113613: LD_VAR 0 28
113617: IN
113618: NOT
113619: PUSH
113620: LD_VAR 0 14
113624: PUSH
113625: LD_VAR 0 8
113629: ARRAY
113630: PPUSH
113631: CALL_OW 313
113635: AND
113636: IFFALSE 113709
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
113638: LD_VAR 0 4
113642: PUSH
113643: LD_VAR 0 7
113647: ARRAY
113648: PPUSH
113649: LD_VAR 0 14
113653: PUSH
113654: LD_VAR 0 8
113658: ARRAY
113659: PPUSH
113660: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
113664: LD_ADDR_VAR 0 28
113668: PUSH
113669: LD_VAR 0 28
113673: PPUSH
113674: LD_VAR 0 28
113678: PUSH
113679: LD_INT 1
113681: PLUS
113682: PPUSH
113683: LD_VAR 0 14
113687: PUSH
113688: LD_VAR 0 8
113692: ARRAY
113693: PPUSH
113694: CALL_OW 1
113698: ST_TO_ADDR
// attacking := true ;
113699: LD_ADDR_VAR 0 29
113703: PUSH
113704: LD_INT 1
113706: ST_TO_ADDR
// break ;
113707: GO 113711
// end ; end ;
113709: GO 113578
113711: POP
113712: POP
// if not attacking and f_attack_depot then
113713: LD_VAR 0 29
113717: NOT
113718: PUSH
113719: LD_VAR 0 25
113723: AND
113724: IFFALSE 113819
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
113726: LD_ADDR_VAR 0 13
113730: PUSH
113731: LD_VAR 0 14
113735: PPUSH
113736: LD_INT 2
113738: PUSH
113739: LD_INT 30
113741: PUSH
113742: LD_INT 0
113744: PUSH
113745: EMPTY
113746: LIST
113747: LIST
113748: PUSH
113749: LD_INT 30
113751: PUSH
113752: LD_INT 1
113754: PUSH
113755: EMPTY
113756: LIST
113757: LIST
113758: PUSH
113759: EMPTY
113760: LIST
113761: LIST
113762: LIST
113763: PPUSH
113764: CALL_OW 72
113768: ST_TO_ADDR
// if z then
113769: LD_VAR 0 13
113773: IFFALSE 113819
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
113775: LD_VAR 0 4
113779: PUSH
113780: LD_VAR 0 7
113784: ARRAY
113785: PPUSH
113786: LD_VAR 0 13
113790: PPUSH
113791: LD_VAR 0 4
113795: PUSH
113796: LD_VAR 0 7
113800: ARRAY
113801: PPUSH
113802: CALL_OW 74
113806: PPUSH
113807: CALL_OW 115
// attacking := true ;
113811: LD_ADDR_VAR 0 29
113815: PUSH
113816: LD_INT 1
113818: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
113819: LD_VAR 0 4
113823: PUSH
113824: LD_VAR 0 7
113828: ARRAY
113829: PPUSH
113830: CALL_OW 256
113834: PUSH
113835: LD_INT 500
113837: LESS
113838: IFFALSE 113864
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
113840: LD_VAR 0 4
113844: PUSH
113845: LD_VAR 0 7
113849: ARRAY
113850: PPUSH
113851: LD_VAR 0 14
113855: PUSH
113856: LD_INT 1
113858: ARRAY
113859: PPUSH
113860: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
113864: LD_VAR 0 4
113868: PUSH
113869: LD_VAR 0 7
113873: ARRAY
113874: PPUSH
113875: CALL_OW 264
113879: PUSH
113880: LD_INT 49
113882: EQUAL
113883: IFFALSE 114004
// begin if not HasTask ( group [ i ] ) then
113885: LD_VAR 0 4
113889: PUSH
113890: LD_VAR 0 7
113894: ARRAY
113895: PPUSH
113896: CALL_OW 314
113900: NOT
113901: IFFALSE 114004
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
113903: LD_ADDR_VAR 0 9
113907: PUSH
113908: LD_INT 81
113910: PUSH
113911: LD_VAR 0 4
113915: PUSH
113916: LD_VAR 0 7
113920: ARRAY
113921: PPUSH
113922: CALL_OW 255
113926: PUSH
113927: EMPTY
113928: LIST
113929: LIST
113930: PPUSH
113931: CALL_OW 69
113935: PPUSH
113936: LD_VAR 0 4
113940: PUSH
113941: LD_VAR 0 7
113945: ARRAY
113946: PPUSH
113947: CALL_OW 74
113951: ST_TO_ADDR
// if k then
113952: LD_VAR 0 9
113956: IFFALSE 114004
// if GetDistUnits ( group [ i ] , k ) > 10 then
113958: LD_VAR 0 4
113962: PUSH
113963: LD_VAR 0 7
113967: ARRAY
113968: PPUSH
113969: LD_VAR 0 9
113973: PPUSH
113974: CALL_OW 296
113978: PUSH
113979: LD_INT 10
113981: GREATER
113982: IFFALSE 114004
// ComMoveUnit ( group [ i ] , k ) ;
113984: LD_VAR 0 4
113988: PUSH
113989: LD_VAR 0 7
113993: ARRAY
113994: PPUSH
113995: LD_VAR 0 9
113999: PPUSH
114000: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
114004: LD_VAR 0 4
114008: PUSH
114009: LD_VAR 0 7
114013: ARRAY
114014: PPUSH
114015: CALL_OW 256
114019: PUSH
114020: LD_INT 250
114022: LESS
114023: PUSH
114024: LD_VAR 0 4
114028: PUSH
114029: LD_VAR 0 7
114033: ARRAY
114034: PUSH
114035: LD_INT 21
114037: PUSH
114038: LD_INT 2
114040: PUSH
114041: EMPTY
114042: LIST
114043: LIST
114044: PUSH
114045: LD_INT 23
114047: PUSH
114048: LD_INT 2
114050: PUSH
114051: EMPTY
114052: LIST
114053: LIST
114054: PUSH
114055: EMPTY
114056: LIST
114057: LIST
114058: PPUSH
114059: CALL_OW 69
114063: IN
114064: AND
114065: IFFALSE 114190
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
114067: LD_ADDR_VAR 0 9
114071: PUSH
114072: LD_OWVAR 3
114076: PUSH
114077: LD_VAR 0 4
114081: PUSH
114082: LD_VAR 0 7
114086: ARRAY
114087: DIFF
114088: PPUSH
114089: LD_VAR 0 4
114093: PUSH
114094: LD_VAR 0 7
114098: ARRAY
114099: PPUSH
114100: CALL_OW 74
114104: ST_TO_ADDR
// if not k then
114105: LD_VAR 0 9
114109: NOT
114110: IFFALSE 114114
// continue ;
114112: GO 110529
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
114114: LD_VAR 0 9
114118: PUSH
114119: LD_INT 81
114121: PUSH
114122: LD_VAR 0 4
114126: PUSH
114127: LD_VAR 0 7
114131: ARRAY
114132: PPUSH
114133: CALL_OW 255
114137: PUSH
114138: EMPTY
114139: LIST
114140: LIST
114141: PPUSH
114142: CALL_OW 69
114146: IN
114147: PUSH
114148: LD_VAR 0 9
114152: PPUSH
114153: LD_VAR 0 4
114157: PUSH
114158: LD_VAR 0 7
114162: ARRAY
114163: PPUSH
114164: CALL_OW 296
114168: PUSH
114169: LD_INT 5
114171: LESS
114172: AND
114173: IFFALSE 114190
// ComAutodestruct ( group [ i ] ) ;
114175: LD_VAR 0 4
114179: PUSH
114180: LD_VAR 0 7
114184: ARRAY
114185: PPUSH
114186: CALL 81633 0 1
// end ; if f_attack_depot then
114190: LD_VAR 0 25
114194: IFFALSE 114306
// begin k := 6 ;
114196: LD_ADDR_VAR 0 9
114200: PUSH
114201: LD_INT 6
114203: ST_TO_ADDR
// if tmp < k then
114204: LD_VAR 0 14
114208: PUSH
114209: LD_VAR 0 9
114213: LESS
114214: IFFALSE 114226
// k := tmp ;
114216: LD_ADDR_VAR 0 9
114220: PUSH
114221: LD_VAR 0 14
114225: ST_TO_ADDR
// for j = 1 to k do
114226: LD_ADDR_VAR 0 8
114230: PUSH
114231: DOUBLE
114232: LD_INT 1
114234: DEC
114235: ST_TO_ADDR
114236: LD_VAR 0 9
114240: PUSH
114241: FOR_TO
114242: IFFALSE 114304
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
114244: LD_VAR 0 8
114248: PPUSH
114249: CALL_OW 266
114253: PUSH
114254: LD_INT 0
114256: PUSH
114257: LD_INT 1
114259: PUSH
114260: EMPTY
114261: LIST
114262: LIST
114263: IN
114264: IFFALSE 114302
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
114266: LD_VAR 0 4
114270: PUSH
114271: LD_VAR 0 7
114275: ARRAY
114276: PPUSH
114277: LD_VAR 0 14
114281: PUSH
114282: LD_VAR 0 8
114286: ARRAY
114287: PPUSH
114288: CALL_OW 115
// attacking := true ;
114292: LD_ADDR_VAR 0 29
114296: PUSH
114297: LD_INT 1
114299: ST_TO_ADDR
// break ;
114300: GO 114304
// end ;
114302: GO 114241
114304: POP
114305: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
114306: LD_VAR 0 4
114310: PUSH
114311: LD_VAR 0 7
114315: ARRAY
114316: PPUSH
114317: CALL_OW 302
114321: PUSH
114322: LD_VAR 0 29
114326: NOT
114327: AND
114328: IFFALSE 114650
// begin if GetTag ( group [ i ] ) = 71 then
114330: LD_VAR 0 4
114334: PUSH
114335: LD_VAR 0 7
114339: ARRAY
114340: PPUSH
114341: CALL_OW 110
114345: PUSH
114346: LD_INT 71
114348: EQUAL
114349: IFFALSE 114390
// begin if HasTask ( group [ i ] ) then
114351: LD_VAR 0 4
114355: PUSH
114356: LD_VAR 0 7
114360: ARRAY
114361: PPUSH
114362: CALL_OW 314
114366: IFFALSE 114372
// continue else
114368: GO 110529
114370: GO 114390
// SetTag ( group [ i ] , 0 ) ;
114372: LD_VAR 0 4
114376: PUSH
114377: LD_VAR 0 7
114381: ARRAY
114382: PPUSH
114383: LD_INT 0
114385: PPUSH
114386: CALL_OW 109
// end ; k := 8 ;
114390: LD_ADDR_VAR 0 9
114394: PUSH
114395: LD_INT 8
114397: ST_TO_ADDR
// x := 0 ;
114398: LD_ADDR_VAR 0 10
114402: PUSH
114403: LD_INT 0
114405: ST_TO_ADDR
// if tmp < k then
114406: LD_VAR 0 14
114410: PUSH
114411: LD_VAR 0 9
114415: LESS
114416: IFFALSE 114428
// k := tmp ;
114418: LD_ADDR_VAR 0 9
114422: PUSH
114423: LD_VAR 0 14
114427: ST_TO_ADDR
// for j = 1 to k do
114428: LD_ADDR_VAR 0 8
114432: PUSH
114433: DOUBLE
114434: LD_INT 1
114436: DEC
114437: ST_TO_ADDR
114438: LD_VAR 0 9
114442: PUSH
114443: FOR_TO
114444: IFFALSE 114542
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
114446: LD_VAR 0 14
114450: PUSH
114451: LD_VAR 0 8
114455: ARRAY
114456: PPUSH
114457: CALL_OW 247
114461: PUSH
114462: LD_INT 1
114464: EQUAL
114465: PUSH
114466: LD_VAR 0 14
114470: PUSH
114471: LD_VAR 0 8
114475: ARRAY
114476: PPUSH
114477: CALL_OW 256
114481: PUSH
114482: LD_INT 250
114484: LESS
114485: PUSH
114486: LD_VAR 0 20
114490: AND
114491: PUSH
114492: LD_VAR 0 20
114496: NOT
114497: PUSH
114498: LD_VAR 0 14
114502: PUSH
114503: LD_VAR 0 8
114507: ARRAY
114508: PPUSH
114509: CALL_OW 256
114513: PUSH
114514: LD_INT 250
114516: GREATEREQUAL
114517: AND
114518: OR
114519: AND
114520: IFFALSE 114540
// begin x := tmp [ j ] ;
114522: LD_ADDR_VAR 0 10
114526: PUSH
114527: LD_VAR 0 14
114531: PUSH
114532: LD_VAR 0 8
114536: ARRAY
114537: ST_TO_ADDR
// break ;
114538: GO 114542
// end ;
114540: GO 114443
114542: POP
114543: POP
// if x then
114544: LD_VAR 0 10
114548: IFFALSE 114572
// ComAttackUnit ( group [ i ] , x ) else
114550: LD_VAR 0 4
114554: PUSH
114555: LD_VAR 0 7
114559: ARRAY
114560: PPUSH
114561: LD_VAR 0 10
114565: PPUSH
114566: CALL_OW 115
114570: GO 114596
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
114572: LD_VAR 0 4
114576: PUSH
114577: LD_VAR 0 7
114581: ARRAY
114582: PPUSH
114583: LD_VAR 0 14
114587: PUSH
114588: LD_INT 1
114590: ARRAY
114591: PPUSH
114592: CALL_OW 115
// if not HasTask ( group [ i ] ) then
114596: LD_VAR 0 4
114600: PUSH
114601: LD_VAR 0 7
114605: ARRAY
114606: PPUSH
114607: CALL_OW 314
114611: NOT
114612: IFFALSE 114650
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
114614: LD_VAR 0 4
114618: PUSH
114619: LD_VAR 0 7
114623: ARRAY
114624: PPUSH
114625: LD_VAR 0 14
114629: PPUSH
114630: LD_VAR 0 4
114634: PUSH
114635: LD_VAR 0 7
114639: ARRAY
114640: PPUSH
114641: CALL_OW 74
114645: PPUSH
114646: CALL_OW 115
// end ; end ; end ;
114650: GO 110529
114652: POP
114653: POP
// wait ( 0 0$2 ) ;
114654: LD_INT 70
114656: PPUSH
114657: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
114661: LD_VAR 0 4
114665: NOT
114666: PUSH
114667: LD_VAR 0 4
114671: PUSH
114672: EMPTY
114673: EQUAL
114674: OR
114675: PUSH
114676: LD_INT 81
114678: PUSH
114679: LD_VAR 0 35
114683: PUSH
114684: EMPTY
114685: LIST
114686: LIST
114687: PPUSH
114688: CALL_OW 69
114692: NOT
114693: OR
114694: IFFALSE 110514
// end ;
114696: LD_VAR 0 2
114700: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
114701: LD_INT 0
114703: PPUSH
114704: PPUSH
114705: PPUSH
114706: PPUSH
114707: PPUSH
114708: PPUSH
// if not base or not mc_bases [ base ] or not solds then
114709: LD_VAR 0 1
114713: NOT
114714: PUSH
114715: LD_EXP 50
114719: PUSH
114720: LD_VAR 0 1
114724: ARRAY
114725: NOT
114726: OR
114727: PUSH
114728: LD_VAR 0 2
114732: NOT
114733: OR
114734: IFFALSE 114738
// exit ;
114736: GO 115292
// side := mc_sides [ base ] ;
114738: LD_ADDR_VAR 0 6
114742: PUSH
114743: LD_EXP 76
114747: PUSH
114748: LD_VAR 0 1
114752: ARRAY
114753: ST_TO_ADDR
// if not side then
114754: LD_VAR 0 6
114758: NOT
114759: IFFALSE 114763
// exit ;
114761: GO 115292
// for i in solds do
114763: LD_ADDR_VAR 0 7
114767: PUSH
114768: LD_VAR 0 2
114772: PUSH
114773: FOR_IN
114774: IFFALSE 114835
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
114776: LD_VAR 0 7
114780: PPUSH
114781: CALL_OW 310
114785: PPUSH
114786: CALL_OW 266
114790: PUSH
114791: LD_INT 32
114793: PUSH
114794: LD_INT 31
114796: PUSH
114797: EMPTY
114798: LIST
114799: LIST
114800: IN
114801: IFFALSE 114821
// solds := solds diff i else
114803: LD_ADDR_VAR 0 2
114807: PUSH
114808: LD_VAR 0 2
114812: PUSH
114813: LD_VAR 0 7
114817: DIFF
114818: ST_TO_ADDR
114819: GO 114833
// SetTag ( i , 18 ) ;
114821: LD_VAR 0 7
114825: PPUSH
114826: LD_INT 18
114828: PPUSH
114829: CALL_OW 109
114833: GO 114773
114835: POP
114836: POP
// if not solds then
114837: LD_VAR 0 2
114841: NOT
114842: IFFALSE 114846
// exit ;
114844: GO 115292
// repeat wait ( 0 0$2 ) ;
114846: LD_INT 70
114848: PPUSH
114849: CALL_OW 67
// enemy := mc_scan [ base ] ;
114853: LD_ADDR_VAR 0 4
114857: PUSH
114858: LD_EXP 73
114862: PUSH
114863: LD_VAR 0 1
114867: ARRAY
114868: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
114869: LD_EXP 50
114873: PUSH
114874: LD_VAR 0 1
114878: ARRAY
114879: NOT
114880: PUSH
114881: LD_EXP 50
114885: PUSH
114886: LD_VAR 0 1
114890: ARRAY
114891: PUSH
114892: EMPTY
114893: EQUAL
114894: OR
114895: IFFALSE 114932
// begin for i in solds do
114897: LD_ADDR_VAR 0 7
114901: PUSH
114902: LD_VAR 0 2
114906: PUSH
114907: FOR_IN
114908: IFFALSE 114921
// ComStop ( i ) ;
114910: LD_VAR 0 7
114914: PPUSH
114915: CALL_OW 141
114919: GO 114907
114921: POP
114922: POP
// solds := [ ] ;
114923: LD_ADDR_VAR 0 2
114927: PUSH
114928: EMPTY
114929: ST_TO_ADDR
// exit ;
114930: GO 115292
// end ; for i in solds do
114932: LD_ADDR_VAR 0 7
114936: PUSH
114937: LD_VAR 0 2
114941: PUSH
114942: FOR_IN
114943: IFFALSE 115264
// begin if IsInUnit ( i ) then
114945: LD_VAR 0 7
114949: PPUSH
114950: CALL_OW 310
114954: IFFALSE 114965
// ComExitBuilding ( i ) ;
114956: LD_VAR 0 7
114960: PPUSH
114961: CALL_OW 122
// if GetLives ( i ) > 500 then
114965: LD_VAR 0 7
114969: PPUSH
114970: CALL_OW 256
114974: PUSH
114975: LD_INT 500
114977: GREATER
114978: IFFALSE 115031
// begin e := NearestUnitToUnit ( enemy , i ) ;
114980: LD_ADDR_VAR 0 5
114984: PUSH
114985: LD_VAR 0 4
114989: PPUSH
114990: LD_VAR 0 7
114994: PPUSH
114995: CALL_OW 74
114999: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
115000: LD_VAR 0 7
115004: PPUSH
115005: LD_VAR 0 5
115009: PPUSH
115010: CALL_OW 250
115014: PPUSH
115015: LD_VAR 0 5
115019: PPUSH
115020: CALL_OW 251
115024: PPUSH
115025: CALL_OW 114
// end else
115029: GO 115262
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
115031: LD_VAR 0 7
115035: PPUSH
115036: LD_EXP 50
115040: PUSH
115041: LD_VAR 0 1
115045: ARRAY
115046: PPUSH
115047: LD_INT 2
115049: PUSH
115050: LD_INT 30
115052: PUSH
115053: LD_INT 0
115055: PUSH
115056: EMPTY
115057: LIST
115058: LIST
115059: PUSH
115060: LD_INT 30
115062: PUSH
115063: LD_INT 1
115065: PUSH
115066: EMPTY
115067: LIST
115068: LIST
115069: PUSH
115070: LD_INT 30
115072: PUSH
115073: LD_INT 6
115075: PUSH
115076: EMPTY
115077: LIST
115078: LIST
115079: PUSH
115080: EMPTY
115081: LIST
115082: LIST
115083: LIST
115084: LIST
115085: PPUSH
115086: CALL_OW 72
115090: PPUSH
115091: LD_VAR 0 7
115095: PPUSH
115096: CALL_OW 74
115100: PPUSH
115101: CALL_OW 296
115105: PUSH
115106: LD_INT 10
115108: GREATER
115109: IFFALSE 115262
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
115111: LD_ADDR_VAR 0 8
115115: PUSH
115116: LD_EXP 50
115120: PUSH
115121: LD_VAR 0 1
115125: ARRAY
115126: PPUSH
115127: LD_INT 2
115129: PUSH
115130: LD_INT 30
115132: PUSH
115133: LD_INT 0
115135: PUSH
115136: EMPTY
115137: LIST
115138: LIST
115139: PUSH
115140: LD_INT 30
115142: PUSH
115143: LD_INT 1
115145: PUSH
115146: EMPTY
115147: LIST
115148: LIST
115149: PUSH
115150: LD_INT 30
115152: PUSH
115153: LD_INT 6
115155: PUSH
115156: EMPTY
115157: LIST
115158: LIST
115159: PUSH
115160: EMPTY
115161: LIST
115162: LIST
115163: LIST
115164: LIST
115165: PPUSH
115166: CALL_OW 72
115170: PPUSH
115171: LD_VAR 0 7
115175: PPUSH
115176: CALL_OW 74
115180: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
115181: LD_VAR 0 7
115185: PPUSH
115186: LD_VAR 0 8
115190: PPUSH
115191: CALL_OW 250
115195: PPUSH
115196: LD_INT 3
115198: PPUSH
115199: LD_INT 5
115201: PPUSH
115202: CALL_OW 272
115206: PPUSH
115207: LD_VAR 0 8
115211: PPUSH
115212: CALL_OW 251
115216: PPUSH
115217: LD_INT 3
115219: PPUSH
115220: LD_INT 5
115222: PPUSH
115223: CALL_OW 273
115227: PPUSH
115228: CALL_OW 111
// SetTag ( i , 0 ) ;
115232: LD_VAR 0 7
115236: PPUSH
115237: LD_INT 0
115239: PPUSH
115240: CALL_OW 109
// solds := solds diff i ;
115244: LD_ADDR_VAR 0 2
115248: PUSH
115249: LD_VAR 0 2
115253: PUSH
115254: LD_VAR 0 7
115258: DIFF
115259: ST_TO_ADDR
// continue ;
115260: GO 114942
// end ; end ;
115262: GO 114942
115264: POP
115265: POP
// until not solds or not enemy ;
115266: LD_VAR 0 2
115270: NOT
115271: PUSH
115272: LD_VAR 0 4
115276: NOT
115277: OR
115278: IFFALSE 114846
// MC_Reset ( base , 18 ) ;
115280: LD_VAR 0 1
115284: PPUSH
115285: LD_INT 18
115287: PPUSH
115288: CALL 22149 0 2
// end ;
115292: LD_VAR 0 3
115296: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
115297: LD_INT 0
115299: PPUSH
115300: PPUSH
115301: PPUSH
115302: PPUSH
115303: PPUSH
115304: PPUSH
115305: PPUSH
115306: PPUSH
115307: PPUSH
115308: PPUSH
115309: PPUSH
115310: PPUSH
115311: PPUSH
115312: PPUSH
115313: PPUSH
115314: PPUSH
115315: PPUSH
115316: PPUSH
115317: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
115318: LD_ADDR_VAR 0 12
115322: PUSH
115323: LD_EXP 50
115327: PUSH
115328: LD_VAR 0 1
115332: ARRAY
115333: PPUSH
115334: LD_INT 25
115336: PUSH
115337: LD_INT 3
115339: PUSH
115340: EMPTY
115341: LIST
115342: LIST
115343: PPUSH
115344: CALL_OW 72
115348: ST_TO_ADDR
// if mc_remote_driver [ base ] then
115349: LD_EXP 90
115353: PUSH
115354: LD_VAR 0 1
115358: ARRAY
115359: IFFALSE 115383
// mechs := mechs diff mc_remote_driver [ base ] ;
115361: LD_ADDR_VAR 0 12
115365: PUSH
115366: LD_VAR 0 12
115370: PUSH
115371: LD_EXP 90
115375: PUSH
115376: LD_VAR 0 1
115380: ARRAY
115381: DIFF
115382: ST_TO_ADDR
// for i in mechs do
115383: LD_ADDR_VAR 0 4
115387: PUSH
115388: LD_VAR 0 12
115392: PUSH
115393: FOR_IN
115394: IFFALSE 115429
// if GetTag ( i ) > 0 then
115396: LD_VAR 0 4
115400: PPUSH
115401: CALL_OW 110
115405: PUSH
115406: LD_INT 0
115408: GREATER
115409: IFFALSE 115427
// mechs := mechs diff i ;
115411: LD_ADDR_VAR 0 12
115415: PUSH
115416: LD_VAR 0 12
115420: PUSH
115421: LD_VAR 0 4
115425: DIFF
115426: ST_TO_ADDR
115427: GO 115393
115429: POP
115430: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
115431: LD_ADDR_VAR 0 8
115435: PUSH
115436: LD_EXP 50
115440: PUSH
115441: LD_VAR 0 1
115445: ARRAY
115446: PPUSH
115447: LD_INT 2
115449: PUSH
115450: LD_INT 25
115452: PUSH
115453: LD_INT 1
115455: PUSH
115456: EMPTY
115457: LIST
115458: LIST
115459: PUSH
115460: LD_INT 25
115462: PUSH
115463: LD_INT 5
115465: PUSH
115466: EMPTY
115467: LIST
115468: LIST
115469: PUSH
115470: LD_INT 25
115472: PUSH
115473: LD_INT 8
115475: PUSH
115476: EMPTY
115477: LIST
115478: LIST
115479: PUSH
115480: LD_INT 25
115482: PUSH
115483: LD_INT 9
115485: PUSH
115486: EMPTY
115487: LIST
115488: LIST
115489: PUSH
115490: EMPTY
115491: LIST
115492: LIST
115493: LIST
115494: LIST
115495: LIST
115496: PPUSH
115497: CALL_OW 72
115501: ST_TO_ADDR
// if not defenders and not solds then
115502: LD_VAR 0 2
115506: NOT
115507: PUSH
115508: LD_VAR 0 8
115512: NOT
115513: AND
115514: IFFALSE 115518
// exit ;
115516: GO 117288
// depot_under_attack := false ;
115518: LD_ADDR_VAR 0 16
115522: PUSH
115523: LD_INT 0
115525: ST_TO_ADDR
// sold_defenders := [ ] ;
115526: LD_ADDR_VAR 0 17
115530: PUSH
115531: EMPTY
115532: ST_TO_ADDR
// if mechs then
115533: LD_VAR 0 12
115537: IFFALSE 115690
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
115539: LD_ADDR_VAR 0 4
115543: PUSH
115544: LD_VAR 0 2
115548: PPUSH
115549: LD_INT 21
115551: PUSH
115552: LD_INT 2
115554: PUSH
115555: EMPTY
115556: LIST
115557: LIST
115558: PPUSH
115559: CALL_OW 72
115563: PUSH
115564: FOR_IN
115565: IFFALSE 115688
// begin if GetTag ( i ) <> 20 then
115567: LD_VAR 0 4
115571: PPUSH
115572: CALL_OW 110
115576: PUSH
115577: LD_INT 20
115579: NONEQUAL
115580: IFFALSE 115594
// SetTag ( i , 20 ) ;
115582: LD_VAR 0 4
115586: PPUSH
115587: LD_INT 20
115589: PPUSH
115590: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
115594: LD_VAR 0 4
115598: PPUSH
115599: CALL_OW 263
115603: PUSH
115604: LD_INT 1
115606: EQUAL
115607: PUSH
115608: LD_VAR 0 4
115612: PPUSH
115613: CALL_OW 311
115617: NOT
115618: AND
115619: IFFALSE 115686
// begin un := mechs [ 1 ] ;
115621: LD_ADDR_VAR 0 10
115625: PUSH
115626: LD_VAR 0 12
115630: PUSH
115631: LD_INT 1
115633: ARRAY
115634: ST_TO_ADDR
// ComExit ( un ) ;
115635: LD_VAR 0 10
115639: PPUSH
115640: CALL 86499 0 1
// AddComEnterUnit ( un , i ) ;
115644: LD_VAR 0 10
115648: PPUSH
115649: LD_VAR 0 4
115653: PPUSH
115654: CALL_OW 180
// SetTag ( un , 19 ) ;
115658: LD_VAR 0 10
115662: PPUSH
115663: LD_INT 19
115665: PPUSH
115666: CALL_OW 109
// mechs := mechs diff un ;
115670: LD_ADDR_VAR 0 12
115674: PUSH
115675: LD_VAR 0 12
115679: PUSH
115680: LD_VAR 0 10
115684: DIFF
115685: ST_TO_ADDR
// end ; end ;
115686: GO 115564
115688: POP
115689: POP
// if solds then
115690: LD_VAR 0 8
115694: IFFALSE 115753
// for i in solds do
115696: LD_ADDR_VAR 0 4
115700: PUSH
115701: LD_VAR 0 8
115705: PUSH
115706: FOR_IN
115707: IFFALSE 115751
// if not GetTag ( i ) then
115709: LD_VAR 0 4
115713: PPUSH
115714: CALL_OW 110
115718: NOT
115719: IFFALSE 115749
// begin defenders := defenders union i ;
115721: LD_ADDR_VAR 0 2
115725: PUSH
115726: LD_VAR 0 2
115730: PUSH
115731: LD_VAR 0 4
115735: UNION
115736: ST_TO_ADDR
// SetTag ( i , 18 ) ;
115737: LD_VAR 0 4
115741: PPUSH
115742: LD_INT 18
115744: PPUSH
115745: CALL_OW 109
// end ;
115749: GO 115706
115751: POP
115752: POP
// repeat wait ( 0 0$2 ) ;
115753: LD_INT 70
115755: PPUSH
115756: CALL_OW 67
// enemy := mc_scan [ base ] ;
115760: LD_ADDR_VAR 0 21
115764: PUSH
115765: LD_EXP 73
115769: PUSH
115770: LD_VAR 0 1
115774: ARRAY
115775: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
115776: LD_EXP 50
115780: PUSH
115781: LD_VAR 0 1
115785: ARRAY
115786: NOT
115787: PUSH
115788: LD_EXP 50
115792: PUSH
115793: LD_VAR 0 1
115797: ARRAY
115798: PUSH
115799: EMPTY
115800: EQUAL
115801: OR
115802: IFFALSE 115839
// begin for i in defenders do
115804: LD_ADDR_VAR 0 4
115808: PUSH
115809: LD_VAR 0 2
115813: PUSH
115814: FOR_IN
115815: IFFALSE 115828
// ComStop ( i ) ;
115817: LD_VAR 0 4
115821: PPUSH
115822: CALL_OW 141
115826: GO 115814
115828: POP
115829: POP
// defenders := [ ] ;
115830: LD_ADDR_VAR 0 2
115834: PUSH
115835: EMPTY
115836: ST_TO_ADDR
// exit ;
115837: GO 117288
// end ; for i in defenders do
115839: LD_ADDR_VAR 0 4
115843: PUSH
115844: LD_VAR 0 2
115848: PUSH
115849: FOR_IN
115850: IFFALSE 116748
// begin e := NearestUnitToUnit ( enemy , i ) ;
115852: LD_ADDR_VAR 0 13
115856: PUSH
115857: LD_VAR 0 21
115861: PPUSH
115862: LD_VAR 0 4
115866: PPUSH
115867: CALL_OW 74
115871: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
115872: LD_ADDR_VAR 0 7
115876: PUSH
115877: LD_EXP 50
115881: PUSH
115882: LD_VAR 0 1
115886: ARRAY
115887: PPUSH
115888: LD_INT 2
115890: PUSH
115891: LD_INT 30
115893: PUSH
115894: LD_INT 0
115896: PUSH
115897: EMPTY
115898: LIST
115899: LIST
115900: PUSH
115901: LD_INT 30
115903: PUSH
115904: LD_INT 1
115906: PUSH
115907: EMPTY
115908: LIST
115909: LIST
115910: PUSH
115911: EMPTY
115912: LIST
115913: LIST
115914: LIST
115915: PPUSH
115916: CALL_OW 72
115920: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
115921: LD_ADDR_VAR 0 16
115925: PUSH
115926: LD_VAR 0 7
115930: NOT
115931: PUSH
115932: LD_VAR 0 7
115936: PPUSH
115937: LD_INT 3
115939: PUSH
115940: LD_INT 24
115942: PUSH
115943: LD_INT 600
115945: PUSH
115946: EMPTY
115947: LIST
115948: LIST
115949: PUSH
115950: EMPTY
115951: LIST
115952: LIST
115953: PPUSH
115954: CALL_OW 72
115958: OR
115959: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
115960: LD_VAR 0 4
115964: PPUSH
115965: CALL_OW 247
115969: PUSH
115970: LD_INT 2
115972: DOUBLE
115973: EQUAL
115974: IFTRUE 115978
115976: GO 116374
115978: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
115979: LD_VAR 0 4
115983: PPUSH
115984: CALL_OW 256
115988: PUSH
115989: LD_INT 1000
115991: EQUAL
115992: PUSH
115993: LD_VAR 0 4
115997: PPUSH
115998: LD_VAR 0 13
116002: PPUSH
116003: CALL_OW 296
116007: PUSH
116008: LD_INT 40
116010: LESS
116011: PUSH
116012: LD_VAR 0 13
116016: PPUSH
116017: LD_EXP 75
116021: PUSH
116022: LD_VAR 0 1
116026: ARRAY
116027: PPUSH
116028: CALL_OW 308
116032: OR
116033: AND
116034: IFFALSE 116156
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
116036: LD_VAR 0 4
116040: PPUSH
116041: CALL_OW 262
116045: PUSH
116046: LD_INT 1
116048: EQUAL
116049: PUSH
116050: LD_VAR 0 4
116054: PPUSH
116055: CALL_OW 261
116059: PUSH
116060: LD_INT 30
116062: LESS
116063: AND
116064: PUSH
116065: LD_VAR 0 7
116069: AND
116070: IFFALSE 116140
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
116072: LD_VAR 0 4
116076: PPUSH
116077: LD_VAR 0 7
116081: PPUSH
116082: LD_VAR 0 4
116086: PPUSH
116087: CALL_OW 74
116091: PPUSH
116092: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
116096: LD_VAR 0 4
116100: PPUSH
116101: LD_VAR 0 7
116105: PPUSH
116106: LD_VAR 0 4
116110: PPUSH
116111: CALL_OW 74
116115: PPUSH
116116: CALL_OW 296
116120: PUSH
116121: LD_INT 6
116123: LESS
116124: IFFALSE 116138
// SetFuel ( i , 100 ) ;
116126: LD_VAR 0 4
116130: PPUSH
116131: LD_INT 100
116133: PPUSH
116134: CALL_OW 240
// end else
116138: GO 116154
// ComAttackUnit ( i , e ) ;
116140: LD_VAR 0 4
116144: PPUSH
116145: LD_VAR 0 13
116149: PPUSH
116150: CALL_OW 115
// end else
116154: GO 116257
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
116156: LD_VAR 0 13
116160: PPUSH
116161: LD_EXP 75
116165: PUSH
116166: LD_VAR 0 1
116170: ARRAY
116171: PPUSH
116172: CALL_OW 308
116176: NOT
116177: PUSH
116178: LD_VAR 0 4
116182: PPUSH
116183: LD_VAR 0 13
116187: PPUSH
116188: CALL_OW 296
116192: PUSH
116193: LD_INT 40
116195: GREATEREQUAL
116196: AND
116197: PUSH
116198: LD_VAR 0 4
116202: PPUSH
116203: CALL_OW 256
116207: PUSH
116208: LD_INT 650
116210: LESSEQUAL
116211: OR
116212: PUSH
116213: LD_VAR 0 4
116217: PPUSH
116218: LD_EXP 74
116222: PUSH
116223: LD_VAR 0 1
116227: ARRAY
116228: PPUSH
116229: CALL_OW 308
116233: NOT
116234: AND
116235: IFFALSE 116257
// ComMoveToArea ( i , mc_parking [ base ] ) ;
116237: LD_VAR 0 4
116241: PPUSH
116242: LD_EXP 74
116246: PUSH
116247: LD_VAR 0 1
116251: ARRAY
116252: PPUSH
116253: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
116257: LD_VAR 0 4
116261: PPUSH
116262: CALL_OW 256
116266: PUSH
116267: LD_INT 1000
116269: LESS
116270: PUSH
116271: LD_VAR 0 4
116275: PPUSH
116276: CALL_OW 263
116280: PUSH
116281: LD_INT 1
116283: EQUAL
116284: AND
116285: PUSH
116286: LD_VAR 0 4
116290: PPUSH
116291: CALL_OW 311
116295: AND
116296: PUSH
116297: LD_VAR 0 4
116301: PPUSH
116302: LD_EXP 74
116306: PUSH
116307: LD_VAR 0 1
116311: ARRAY
116312: PPUSH
116313: CALL_OW 308
116317: AND
116318: IFFALSE 116372
// begin mech := IsDrivenBy ( i ) ;
116320: LD_ADDR_VAR 0 9
116324: PUSH
116325: LD_VAR 0 4
116329: PPUSH
116330: CALL_OW 311
116334: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
116335: LD_VAR 0 9
116339: PPUSH
116340: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
116344: LD_VAR 0 9
116348: PPUSH
116349: LD_VAR 0 4
116353: PPUSH
116354: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
116358: LD_VAR 0 9
116362: PPUSH
116363: LD_VAR 0 4
116367: PPUSH
116368: CALL_OW 180
// end ; end ; unit_human :
116372: GO 116719
116374: LD_INT 1
116376: DOUBLE
116377: EQUAL
116378: IFTRUE 116382
116380: GO 116718
116382: POP
// begin b := IsInUnit ( i ) ;
116383: LD_ADDR_VAR 0 18
116387: PUSH
116388: LD_VAR 0 4
116392: PPUSH
116393: CALL_OW 310
116397: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
116398: LD_ADDR_VAR 0 19
116402: PUSH
116403: LD_VAR 0 18
116407: NOT
116408: PUSH
116409: LD_VAR 0 18
116413: PPUSH
116414: CALL_OW 266
116418: PUSH
116419: LD_INT 32
116421: PUSH
116422: LD_INT 31
116424: PUSH
116425: EMPTY
116426: LIST
116427: LIST
116428: IN
116429: OR
116430: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
116431: LD_VAR 0 18
116435: PPUSH
116436: CALL_OW 266
116440: PUSH
116441: LD_INT 5
116443: EQUAL
116444: PUSH
116445: LD_VAR 0 4
116449: PPUSH
116450: CALL_OW 257
116454: PUSH
116455: LD_INT 1
116457: PUSH
116458: LD_INT 2
116460: PUSH
116461: LD_INT 3
116463: PUSH
116464: LD_INT 4
116466: PUSH
116467: EMPTY
116468: LIST
116469: LIST
116470: LIST
116471: LIST
116472: IN
116473: AND
116474: IFFALSE 116511
// begin class := AllowSpecClass ( i ) ;
116476: LD_ADDR_VAR 0 20
116480: PUSH
116481: LD_VAR 0 4
116485: PPUSH
116486: CALL 50438 0 1
116490: ST_TO_ADDR
// if class then
116491: LD_VAR 0 20
116495: IFFALSE 116511
// ComChangeProfession ( i , class ) ;
116497: LD_VAR 0 4
116501: PPUSH
116502: LD_VAR 0 20
116506: PPUSH
116507: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
116511: LD_VAR 0 16
116515: PUSH
116516: LD_VAR 0 2
116520: PPUSH
116521: LD_INT 21
116523: PUSH
116524: LD_INT 2
116526: PUSH
116527: EMPTY
116528: LIST
116529: LIST
116530: PPUSH
116531: CALL_OW 72
116535: PUSH
116536: LD_INT 1
116538: LESSEQUAL
116539: OR
116540: PUSH
116541: LD_VAR 0 19
116545: AND
116546: PUSH
116547: LD_VAR 0 4
116551: PUSH
116552: LD_VAR 0 17
116556: IN
116557: NOT
116558: AND
116559: IFFALSE 116652
// begin if b then
116561: LD_VAR 0 18
116565: IFFALSE 116614
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
116567: LD_VAR 0 18
116571: PPUSH
116572: LD_VAR 0 21
116576: PPUSH
116577: LD_VAR 0 18
116581: PPUSH
116582: CALL_OW 74
116586: PPUSH
116587: CALL_OW 296
116591: PUSH
116592: LD_INT 10
116594: LESS
116595: PUSH
116596: LD_VAR 0 18
116600: PPUSH
116601: CALL_OW 461
116605: PUSH
116606: LD_INT 7
116608: NONEQUAL
116609: AND
116610: IFFALSE 116614
// continue ;
116612: GO 115849
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
116614: LD_ADDR_VAR 0 17
116618: PUSH
116619: LD_VAR 0 17
116623: PPUSH
116624: LD_VAR 0 17
116628: PUSH
116629: LD_INT 1
116631: PLUS
116632: PPUSH
116633: LD_VAR 0 4
116637: PPUSH
116638: CALL_OW 1
116642: ST_TO_ADDR
// ComExitBuilding ( i ) ;
116643: LD_VAR 0 4
116647: PPUSH
116648: CALL_OW 122
// end ; if sold_defenders then
116652: LD_VAR 0 17
116656: IFFALSE 116716
// if i in sold_defenders then
116658: LD_VAR 0 4
116662: PUSH
116663: LD_VAR 0 17
116667: IN
116668: IFFALSE 116716
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
116670: LD_VAR 0 4
116674: PPUSH
116675: CALL_OW 314
116679: NOT
116680: PUSH
116681: LD_VAR 0 4
116685: PPUSH
116686: LD_VAR 0 13
116690: PPUSH
116691: CALL_OW 296
116695: PUSH
116696: LD_INT 30
116698: LESS
116699: AND
116700: IFFALSE 116716
// ComAttackUnit ( i , e ) ;
116702: LD_VAR 0 4
116706: PPUSH
116707: LD_VAR 0 13
116711: PPUSH
116712: CALL_OW 115
// end ; end ; end ;
116716: GO 116719
116718: POP
// if IsDead ( i ) then
116719: LD_VAR 0 4
116723: PPUSH
116724: CALL_OW 301
116728: IFFALSE 116746
// defenders := defenders diff i ;
116730: LD_ADDR_VAR 0 2
116734: PUSH
116735: LD_VAR 0 2
116739: PUSH
116740: LD_VAR 0 4
116744: DIFF
116745: ST_TO_ADDR
// end ;
116746: GO 115849
116748: POP
116749: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
116750: LD_VAR 0 21
116754: NOT
116755: PUSH
116756: LD_VAR 0 2
116760: NOT
116761: OR
116762: PUSH
116763: LD_EXP 50
116767: PUSH
116768: LD_VAR 0 1
116772: ARRAY
116773: NOT
116774: OR
116775: IFFALSE 115753
// MC_Reset ( base , 18 ) ;
116777: LD_VAR 0 1
116781: PPUSH
116782: LD_INT 18
116784: PPUSH
116785: CALL 22149 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
116789: LD_ADDR_VAR 0 2
116793: PUSH
116794: LD_VAR 0 2
116798: PUSH
116799: LD_VAR 0 2
116803: PPUSH
116804: LD_INT 2
116806: PUSH
116807: LD_INT 25
116809: PUSH
116810: LD_INT 1
116812: PUSH
116813: EMPTY
116814: LIST
116815: LIST
116816: PUSH
116817: LD_INT 25
116819: PUSH
116820: LD_INT 5
116822: PUSH
116823: EMPTY
116824: LIST
116825: LIST
116826: PUSH
116827: LD_INT 25
116829: PUSH
116830: LD_INT 8
116832: PUSH
116833: EMPTY
116834: LIST
116835: LIST
116836: PUSH
116837: LD_INT 25
116839: PUSH
116840: LD_INT 9
116842: PUSH
116843: EMPTY
116844: LIST
116845: LIST
116846: PUSH
116847: EMPTY
116848: LIST
116849: LIST
116850: LIST
116851: LIST
116852: LIST
116853: PPUSH
116854: CALL_OW 72
116858: DIFF
116859: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
116860: LD_VAR 0 21
116864: NOT
116865: PUSH
116866: LD_VAR 0 2
116870: PPUSH
116871: LD_INT 21
116873: PUSH
116874: LD_INT 2
116876: PUSH
116877: EMPTY
116878: LIST
116879: LIST
116880: PPUSH
116881: CALL_OW 72
116885: AND
116886: IFFALSE 117224
// begin tmp := FilterByTag ( defenders , 19 ) ;
116888: LD_ADDR_VAR 0 11
116892: PUSH
116893: LD_VAR 0 2
116897: PPUSH
116898: LD_INT 19
116900: PPUSH
116901: CALL 83675 0 2
116905: ST_TO_ADDR
// if tmp then
116906: LD_VAR 0 11
116910: IFFALSE 116980
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
116912: LD_ADDR_VAR 0 11
116916: PUSH
116917: LD_VAR 0 11
116921: PPUSH
116922: LD_INT 25
116924: PUSH
116925: LD_INT 3
116927: PUSH
116928: EMPTY
116929: LIST
116930: LIST
116931: PPUSH
116932: CALL_OW 72
116936: ST_TO_ADDR
// if tmp then
116937: LD_VAR 0 11
116941: IFFALSE 116980
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
116943: LD_ADDR_EXP 62
116947: PUSH
116948: LD_EXP 62
116952: PPUSH
116953: LD_VAR 0 1
116957: PPUSH
116958: LD_EXP 62
116962: PUSH
116963: LD_VAR 0 1
116967: ARRAY
116968: PUSH
116969: LD_VAR 0 11
116973: UNION
116974: PPUSH
116975: CALL_OW 1
116979: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
116980: LD_VAR 0 1
116984: PPUSH
116985: LD_INT 19
116987: PPUSH
116988: CALL 22149 0 2
// repeat wait ( 0 0$1 ) ;
116992: LD_INT 35
116994: PPUSH
116995: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
116999: LD_EXP 50
117003: PUSH
117004: LD_VAR 0 1
117008: ARRAY
117009: NOT
117010: PUSH
117011: LD_EXP 50
117015: PUSH
117016: LD_VAR 0 1
117020: ARRAY
117021: PUSH
117022: EMPTY
117023: EQUAL
117024: OR
117025: IFFALSE 117062
// begin for i in defenders do
117027: LD_ADDR_VAR 0 4
117031: PUSH
117032: LD_VAR 0 2
117036: PUSH
117037: FOR_IN
117038: IFFALSE 117051
// ComStop ( i ) ;
117040: LD_VAR 0 4
117044: PPUSH
117045: CALL_OW 141
117049: GO 117037
117051: POP
117052: POP
// defenders := [ ] ;
117053: LD_ADDR_VAR 0 2
117057: PUSH
117058: EMPTY
117059: ST_TO_ADDR
// exit ;
117060: GO 117288
// end ; for i in defenders do
117062: LD_ADDR_VAR 0 4
117066: PUSH
117067: LD_VAR 0 2
117071: PUSH
117072: FOR_IN
117073: IFFALSE 117162
// begin if not IsInArea ( i , mc_parking [ base ] ) then
117075: LD_VAR 0 4
117079: PPUSH
117080: LD_EXP 74
117084: PUSH
117085: LD_VAR 0 1
117089: ARRAY
117090: PPUSH
117091: CALL_OW 308
117095: NOT
117096: IFFALSE 117120
// ComMoveToArea ( i , mc_parking [ base ] ) else
117098: LD_VAR 0 4
117102: PPUSH
117103: LD_EXP 74
117107: PUSH
117108: LD_VAR 0 1
117112: ARRAY
117113: PPUSH
117114: CALL_OW 113
117118: GO 117160
// if GetControl ( i ) = control_manual then
117120: LD_VAR 0 4
117124: PPUSH
117125: CALL_OW 263
117129: PUSH
117130: LD_INT 1
117132: EQUAL
117133: IFFALSE 117160
// if IsDrivenBy ( i ) then
117135: LD_VAR 0 4
117139: PPUSH
117140: CALL_OW 311
117144: IFFALSE 117160
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
117146: LD_VAR 0 4
117150: PPUSH
117151: CALL_OW 311
117155: PPUSH
117156: CALL_OW 121
// end ;
117160: GO 117072
117162: POP
117163: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
117164: LD_VAR 0 2
117168: PPUSH
117169: LD_INT 95
117171: PUSH
117172: LD_EXP 74
117176: PUSH
117177: LD_VAR 0 1
117181: ARRAY
117182: PUSH
117183: EMPTY
117184: LIST
117185: LIST
117186: PPUSH
117187: CALL_OW 72
117191: PUSH
117192: LD_VAR 0 2
117196: EQUAL
117197: PUSH
117198: LD_EXP 73
117202: PUSH
117203: LD_VAR 0 1
117207: ARRAY
117208: OR
117209: PUSH
117210: LD_EXP 50
117214: PUSH
117215: LD_VAR 0 1
117219: ARRAY
117220: NOT
117221: OR
117222: IFFALSE 116992
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
117224: LD_ADDR_EXP 72
117228: PUSH
117229: LD_EXP 72
117233: PPUSH
117234: LD_VAR 0 1
117238: PPUSH
117239: LD_VAR 0 2
117243: PPUSH
117244: LD_INT 21
117246: PUSH
117247: LD_INT 2
117249: PUSH
117250: EMPTY
117251: LIST
117252: LIST
117253: PPUSH
117254: CALL_OW 72
117258: PPUSH
117259: CALL_OW 1
117263: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
117264: LD_VAR 0 1
117268: PPUSH
117269: LD_INT 19
117271: PPUSH
117272: CALL 22149 0 2
// MC_Reset ( base , 20 ) ;
117276: LD_VAR 0 1
117280: PPUSH
117281: LD_INT 20
117283: PPUSH
117284: CALL 22149 0 2
// end ; end_of_file
117288: LD_VAR 0 3
117292: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
117293: LD_VAR 0 1
117297: PUSH
117298: LD_INT 200
117300: DOUBLE
117301: GREATEREQUAL
117302: IFFALSE 117310
117304: LD_INT 299
117306: DOUBLE
117307: LESSEQUAL
117308: IFTRUE 117312
117310: GO 117344
117312: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
117313: LD_VAR 0 1
117317: PPUSH
117318: LD_VAR 0 2
117322: PPUSH
117323: LD_VAR 0 3
117327: PPUSH
117328: LD_VAR 0 4
117332: PPUSH
117333: LD_VAR 0 5
117337: PPUSH
117338: CALL 106079 0 5
117342: GO 117421
117344: LD_INT 300
117346: DOUBLE
117347: GREATEREQUAL
117348: IFFALSE 117356
117350: LD_INT 399
117352: DOUBLE
117353: LESSEQUAL
117354: IFTRUE 117358
117356: GO 117420
117358: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
117359: LD_VAR 0 1
117363: PPUSH
117364: LD_VAR 0 2
117368: PPUSH
117369: LD_VAR 0 3
117373: PPUSH
117374: LD_VAR 0 4
117378: PPUSH
117379: LD_VAR 0 5
117383: PPUSH
117384: LD_VAR 0 6
117388: PPUSH
117389: LD_VAR 0 7
117393: PPUSH
117394: LD_VAR 0 8
117398: PPUSH
117399: LD_VAR 0 9
117403: PPUSH
117404: LD_VAR 0 10
117408: PPUSH
117409: LD_VAR 0 11
117413: PPUSH
117414: CALL 102412 0 11
117418: GO 117421
117420: POP
// end ;
117421: PPOPN 11
117423: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
117424: LD_VAR 0 1
117428: PPUSH
117429: LD_VAR 0 2
117433: PPUSH
117434: LD_VAR 0 3
117438: PPUSH
117439: LD_VAR 0 4
117443: PPUSH
117444: LD_VAR 0 5
117448: PPUSH
117449: CALL 105815 0 5
// end ; end_of_file
117453: PPOPN 5
117455: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
117456: LD_VAR 0 1
117460: PPUSH
117461: LD_VAR 0 2
117465: PPUSH
117466: LD_VAR 0 3
117470: PPUSH
117471: LD_VAR 0 4
117475: PPUSH
117476: LD_VAR 0 5
117480: PPUSH
117481: LD_VAR 0 6
117485: PPUSH
117486: CALL 90105 0 6
// end ;
117490: PPOPN 6
117492: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
117493: LD_INT 0
117495: PPUSH
// begin if not units then
117496: LD_VAR 0 1
117500: NOT
117501: IFFALSE 117505
// exit ;
117503: GO 117505
// end ;
117505: PPOPN 7
117507: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
117508: CALL 90076 0 0
// end ;
117512: PPOPN 1
117514: END
